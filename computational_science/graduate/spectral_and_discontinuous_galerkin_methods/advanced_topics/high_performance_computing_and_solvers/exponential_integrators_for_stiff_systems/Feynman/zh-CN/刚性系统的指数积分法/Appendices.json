{
    "hands_on_practices": [
        {
            "introduction": "指数搭配法是一类强大的指数 Runge-Kutta 格式。要理解这些方法，关键在于掌握其构造方式。本练习将引导你从第一性原理出发，为一种特定的指数搭配法推导其积分权重，并用核心的 $\\varphi$-函数来表示。通过这个“纸笔”练习 ，你将深入理解指数积分器是如何从变常数公式和数值积分理论中构建出来的。",
            "id": "3386138",
            "problem": "考虑单个时间步 $[t_n, t_{n+1}]$ 上的半线性刚性常微分方程 (ODE) $u'(t) = A\\,u(t) + N(u(t))$，步长为 $h = t_{n+1} - t_n$，其中 $A \\in \\mathbb{R}^{d \\times d}$ 是一个常数刚性线性算子，$N: \\mathbb{R}^d \\to \\mathbb{R}^d$ 是一个多项式非线性项。从常数变易公式出发，构建一个指数配置法，该方法使用在 $[0,1]$ 上的三个 Legendre–Gauss–Lobatto (LGL) 点，即 $c_0 = 0$、$c_1 = \\tfrac{1}{2}$ 和 $c_2 = 1$，作为用于 $\\varphi$-函数求积的时间配置节点。令 $L_i(\\theta)$（$i=0,1,2$）表示与单位区间上点集 $\\{c_0,c_1,c_2\\}$ 相关联的 Lagrange 基多项式，并定义指数求积权重\n$$\nb_i(hA) = \\int_0^1 \\exp\\!\\big((1-\\theta)\\,hA\\big)\\,L_i(\\theta)\\,d\\theta,\\quad i=0,1,2,\n$$\n用算子 $\\varphi$-函数 $\\varphi_k(hA)$（$k \\in \\mathbb{N}$）表示，其中 $\\varphi_1(X) = ( \\exp(X) - I ) X^{-1}$，并且对 $k \\geq 1$ 递归地有 $\\varphi_{k+1}(X) = \\big( \\varphi_k(X) - \\tfrac{1}{k!} I \\big) X^{-1}$。推导 $b_0(hA)$、$b_1(hA)$ 和 $b_2(hA)$ 关于 $\\varphi_1(hA)$、$\\varphi_2(hA)$ 和 $\\varphi_3(hA)$ 的显式闭式表达式，并从第一性原理出发，确定当 $N(u)$ 是多项式且 $A$ 是刚性线性时，所得指数配置法在该时间步上精确的条件。你的最终答案必须是包含三个权重 $\\big(b_0(hA),\\,b_1(hA),\\,b_2(hA)\\big)$ 的单个行向量，表示为一个仅使用 $\\varphi_1(hA)$、$\\varphi_2(hA)$ 和 $\\varphi_3(hA)$ 的闭式解析表达式。",
            "solution": "该问题要求推导指数求积权重，并确定方法的精确性条件。\n\n为方便起见，令 $Z=hA$。权重定义为 $b_i(Z) = \\int_0^1 \\exp((1-\\theta)Z) L_i(\\theta) d\\theta$。\n\n首先，我们必须确定节点 $c_0=0$、$c_1=\\frac{1}{2}$ 和 $c_2=1$ 的 Lagrange 基多项式 $L_i(\\theta)$。\nLagrange 多项式 $L_i(\\theta)$ 是一个满足 $L_i(c_j) = \\delta_{ij}$ 的二次多项式。\n$$\nL_0(\\theta) = \\frac{(\\theta - c_1)(\\theta - c_2)}{(c_0 - c_1)(c_0 - c_2)} = \\frac{(\\theta - \\frac{1}{2})(\\theta - 1)}{(0 - \\frac{1}{2})(0 - 1)} = \\frac{\\theta^2 - \\frac{3}{2}\\theta + \\frac{1}{2}}{\\frac{1}{2}} = 2\\theta^2 - 3\\theta + 1\n$$\n$$\nL_1(\\theta) = \\frac{(\\theta - c_0)(\\theta - c_2)}{(c_1 - c_0)(c_1 - c_2)} = \\frac{(\\theta - 0)(\\theta - 1)}{(\\frac{1}{2} - 0)(\\frac{1}{2} - 1)} = \\frac{\\theta^2 - \\theta}{-\\frac{1}{4}} = -4\\theta^2 + 4\\theta\n$$\n$$\nL_2(\\theta) = \\frac{(\\theta - c_0)(\\theta - c_1)}{(c_2 - c_0)(c_2 - c_1)} = \\frac{(\\theta - 0)(\\theta - \\frac{1}{2})}{(1 - 0)(1 - \\frac{1}{2})} = \\frac{\\theta^2 - \\frac{1}{2}\\theta}{\\frac{1}{2}} = 2\\theta^2 - \\theta\n$$\n权重 $b_i(Z)$ 是 $I_k(Z) = \\int_0^1 \\exp((1-\\theta)Z) \\theta^k d\\theta$（$k=0, 1, 2$）形式积分的线性组合。我们现在用 $\\varphi$-函数来表示这些积分。\n\n对于 $k=0$：\n$$I_0(Z) = \\int_0^1 \\exp((1-\\theta)Z) d\\theta$$\n令 $s = 1-\\theta$，则 $ds = -d\\theta$。积分限从 $\\theta \\in [0, 1]$ 变为 $s \\in [1, 0]$。\n$$I_0(Z) = \\int_1^0 \\exp(sZ) (-ds) = \\int_0^1 \\exp(sZ) ds = (\\exp(Z) - I)Z^{-1} = \\varphi_1(Z)$$\n\n对于 $k=1$：\n$$I_1(Z) = \\int_0^1 \\exp((1-\\theta)Z) \\theta d\\theta$$\n我们使用分部积分法，令 $u = \\theta$， $dv = \\exp((1-\\theta)Z) d\\theta$。则 $du=d\\theta$， $v = -\\exp((1-\\theta)Z)Z^{-1}$。\n$$\nI_1(Z) = \\Big[-\\theta\\exp((1-\\theta)Z)Z^{-1}\\Big]_0^1 - \\int_0^1 (-\\exp((1-\\theta)Z)Z^{-1}) d\\theta \\\\\n= (-1 \\cdot \\exp(0)Z^{-1} - 0) + Z^{-1}\\int_0^1 \\exp((1-\\theta)Z) d\\theta \\\\\n= -Z^{-1} + Z^{-1}I_0(Z) = Z^{-1}(\\varphi_1(Z) - I) = \\varphi_2(Z)\n$$\n这可由给定的递归定义 $\\varphi_2(Z) = (\\varphi_1(Z) - I)Z^{-1}$ 得出。\n\n对于 $k=2$：\n$$I_2(Z) = \\int_0^1 \\exp((1-\\theta)Z) \\theta^2 d\\theta$$\n我们再次使用分部积分法，令 $u = \\theta^2$， $dv = \\exp((1-\\theta)Z) d\\theta$。则 $du=2\\theta d\\theta$，$v = -\\exp((1-\\theta)Z)Z^{-1}$。\n$$\nI_2(Z) = \\Big[-\\theta^2\\exp((1-\\theta)Z)Z^{-1}\\Big]_0^1 - \\int_0^1 (-\\exp((1-\\theta)Z)Z^{-1}) 2\\theta d\\theta \\\\\n= (-1 \\cdot \\exp(0)Z^{-1} - 0) + 2Z^{-1}\\int_0^1 \\exp((1-\\theta)Z) \\theta d\\theta \\\\\n= -Z^{-1} + 2Z^{-1}I_1(Z) = -Z^{-1} + 2Z^{-1}\\varphi_2(Z)\n$$\n我们需要用 $\\varphi_3(Z)$ 来表示它。根据定义 $\\varphi_3(Z) = (\\varphi_2(Z) - \\frac{1}{2}I)Z^{-1}$，我们有 $Z\\varphi_3(Z) = \\varphi_2(Z) - \\frac{1}{2}I$，整理得 $2Z\\varphi_3(Z) = 2\\varphi_2(Z) - I$。两边乘以 $Z^{-1}$ 得 $2\\varphi_3(Z) = 2\\varphi_2(Z)Z^{-1} - Z^{-1} = 2Z^{-1}\\varphi_2(Z) - Z^{-1}$。\n因此，我们得到 $I_2(Z) = 2\\varphi_3(Z)$。\n\n现在我们可以计算权重 $b_i(Z)$：\n对于 $i=0$：\n$$\nb_0(Z) = \\int_0^1 \\exp((1-\\theta)Z) (2\\theta^2 - 3\\theta + 1) d\\theta \\\\\n= 2I_2(Z) - 3I_1(Z) + 1I_0(Z) \\\\\n= 2(2\\varphi_3(Z)) - 3\\varphi_2(Z) + \\varphi_1(Z) \\\\\n= \\varphi_1(Z) - 3\\varphi_2(Z) + 4\\varphi_3(Z)\n$$\n\n对于 $i=1$：\n$$\nb_1(Z) = \\int_0^1 \\exp((1-\\theta)Z) (-4\\theta^2 + 4\\theta) d\\theta \\\\\n= -4I_2(Z) + 4I_1(Z) \\\\\n= -4(2\\varphi_3(Z)) + 4\\varphi_2(Z) \\\\\n= 4\\varphi_2(Z) - 8\\varphi_3(Z)\n$$\n\n对于 $i=2$：\n$$\nb_2(Z) = \\int_0^1 \\exp((1-\\theta)Z) (2\\theta^2 - \\theta) d\\theta \\\\\n= 2I_2(Z) - I_1(Z) \\\\\n= 2(2\\varphi_3(Z)) - \\varphi_2(Z) \\\\\n= -\\varphi_2(Z) + 4\\varphi_3(Z)\n$$\n将 $Z$ 替换为 $hA$ 即可得到权重的最终表达式。\n\n接下来，我们讨论精确性条件。ODE 在 $[t_n, t_{n+1}]$ 上的精确解由常数变易公式给出：\n$$\nu(t_{n+1}) = \\exp(hA)u(t_n) + \\int_{t_n}^{t_{n+1}} \\exp((t_{n+1}-\\tau)A) N(u(\\tau)) d\\tau\n$$\n将积分变量更改为 $s = (\\tau - t_n)/h$，则 $\\tau = t_n + sh$， $d\\tau = h ds$，我们得到：\n$$\nu(t_{n+1}) = \\exp(hA)u(t_n) + h \\int_0^1 \\exp((1-s)hA) N(u(t_n+sh)) ds\n$$\n指数配置法通过将函数 $g(s) = N(u(t_n+sh))$ 替换为其在配置节点 $\\{c_0, c_1, c_2\\}$ 处次数最多为 2 的唯一多项式插值 $P(s)$ 来近似积分。该插值多项式为 $P(s) = \\sum_{j=0}^2 g(c_j) L_j(s)$。那么，数值解由下式给出：\n$$\nu_{n+1} = \\exp(hA)u_n + h \\int_0^1 \\exp((1-s)hA) P(s) ds\n$$\n代入 $P(s)$ 并使用权重 $b_j(hA)$ 的定义：\n$$\n\\int_0^1 \\exp((1-s)hA) P(s) ds = \\int_0^1 \\exp((1-s)hA) \\sum_{j=0}^{2} g(c_j) L_j(s) ds \\\\\n= \\sum_{j=0}^{2} g(c_j) \\int_0^1 \\exp((1-s)hA) L_j(s) ds = \\sum_{j=0}^{2} b_j(hA) N(u(t_n+c_j h))\n$$\n（在实际实现中，$N(u(t_n+c_j h))$ 将使用内部阶段值进行近似）。\n假设 $u_n=u(t_n)$，如果 $u_{n+1} = u(t_{n+1})$，则该方法在此时间步上是精确的。这当且仅当积分近似是精确的时成立：\n$$\n\\int_0^1 \\exp((1-s)hA) N(u(t_n+sh)) ds = \\int_0^1 \\exp((1-s)hA) P(s) ds\n$$\n如果被插值函数与其插值多项式相同，即 $g(s) \\equiv P(s)$，则此等式成立。这当且仅当 $g(s) = N(u(t_n+sh))$ 是变量 $s$ 在区间 $[0,1]$ 上次数最多为 2 的多项式时发生。这是从求积构造的第一性原理推导出的精确性的基本条件。此条件与 $N(u)$ 是否为 $u$ 的多项式无关。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\varphi_1(hA) - 3\\varphi_2(hA) + 4\\varphi_3(hA) & 4\\varphi_2(hA) - 8\\varphi_3(hA) & -\\varphi_2(hA) + 4\\varphi_3(hA) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在理论上构建了积分器之后，下一步是将其付诸实践。本练习要求你为一个由间断 Galerkin 方法半离散化得到的平流-扩散方程，完整地实现一个二阶 Lawson 方法的时间步。这个编码练习  将抽象的常微分方程组与具体的偏微分方程问题联系起来，让你亲手体验如何利用矩阵指数算符的作用来高效求解刚性系统。",
            "id": "3386153",
            "problem": "考虑定义在周期性区间 $[0,1]$ 上的一维线性平流-扩散偏微分方程，\n$$\nu_t + a\\,u_x = \\nu\\,u_{xx},\n$$\n其中平流速度 $a \\in \\mathbb{R}$ 为常数，扩散系数 $\\nu \\ge 0$ 也为常数。将空间域离散化为包含 $K$ 个单元的均匀网格，单元宽度为 $h = 1/K$。令 $u_j(t)$ 表示在单元 $j$（其中 $j=0,1,\\dots,K-1$）中 $u$ 的单元常数近似（分段多项式次数 $p=0$）。使用周期性边界条件，即索引运算在模 $K$ 下进行。\n\n对于该方程，次数 $p=0$ 的间断 Galerkin (DG) 半离散化可以使用界面上的平流和扩散数值通量来构建。定义界面 $j+\\tfrac{1}{2}$ 上的平流迎风数值通量为\n$$\nF^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) =\n\\begin{cases}\na\\,u_j, & \\text{if } a \\ge 0,\\\\\na\\,u_{j+1}, & \\text{if } a < 0,\n\\end{cases}\n$$\n定义扩散的中心梯度数值通量为\n$$\nF^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) = -\\nu\\,\\frac{u_{j+1}-u_j}{h}.\n$$\n于是，单元 $j$ 中的半离散平衡方程（使用周期性索引）为\n$$\n\\frac{d}{dt}u_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(u)\\right) - \\frac{1}{h}\\left(F^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) - F^{\\mathrm{diff}}_{j-\\frac{1}{2}}(u)\\right).\n$$\n这产生了一个向量形式的常微分方程组，\n$$\n\\frac{d}{dt}\\mathbf{u} = L\\,\\mathbf{u} + N(\\mathbf{u}),\n$$\n其中：\n- $\\mathbf{u} \\in \\mathbb{R}^K$ 汇集了 $K$ 个单元值 $u_j$，\n- $L \\in \\mathbb{R}^{K \\times K}$ 是源于扩散通量的线性扩散算子，具体为\n$$\n(L\\,\\mathbf{u})_j = \\nu\\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2},\n$$\n具有周期性环绕 $u_{-1} \\equiv u_{K-1}$ 和 $u_K \\equiv u_0$，\n- $N(\\mathbf{u}) \\in \\mathbb{R}^K$ 通过迎风数值通量编码了显式平流贡献，\n$$\nN(\\mathbf{u})_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(\\mathbf{u}) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(\\mathbf{u})\\right).\n$$\n\n你的任务是为半离散系统 $\\,\\mathbf{u}' = L\\,\\mathbf{u} + N(\\mathbf{u})\\,$ 实现一个二阶 Lawson 方法的单时间步长。该算法的表达必须完全基于矩阵指数 $e^{\\Delta t\\,L}$ 对向量的作用以及数值平流通量 $N(\\cdot)$ 的求值。所使用的二阶方法是在 Lawson 变量下构建的显式中点 Runge–Kutta 格式。除了上述给出的定义外，你不能做任何简化假设，并且你的实现必须对任何 $K \\ge 3$、任何实数 $a$、任何 $\\nu \\ge 0$ 以及任何 $\\Delta t > 0$ 都有效。\n\n使用以下测试套件，初始条件通过在单元中心 $x_j = (j+\\tfrac{1}{2})h$ 处对 $u(x,0) = \\sin(2\\pi x)$ 进行采样来定义：\n1. $K = 64$，$a = 1.0$，$\\nu = 0.05$，$\\Delta t = 10^{-3}$。\n2. $K = 64$，$a = 0.0$，$\\nu = 0.05$，$\\Delta t = 10^{-3}$。\n3. $K = 64$，$a = 3.0$，$\\nu = 0.0$，$\\Delta t = 10^{-1}$。\n\n对于这三个测试案例中的每一个，从给定的初始条件开始，执行恰好一个 Lawson 步长后，计算并报告以下标量值：\n- 对于案例 1：更新后解的离散 $L^2$ 范数，定义为\n$$\n\\left\\|\\mathbf{u}\\right\\|_{2,h} = \\sqrt{h\\,\\sum_{j=0}^{K-1} u_j^2}.\n$$\n- 对于案例 2：你的 Lawson 更新与纯扩散更新 $e^{\\Delta t\\,L}\\,\\mathbf{u}$ 之间差值的离散 $L^2$ 范数，即，\n$$\n\\sqrt{h\\,\\sum_{j=0}^{K-1} \\left(u^{\\mathrm{Lawson}}_j - u^{\\mathrm{diffusion}}_j\\right)^2}.\n$$\n- 对于案例 3：更新后解在所有单元上的最大绝对值，$\\max_{0 \\le j \\le K-1} |u_j|$。\n\n最终输出格式要求：你的程序应生成单行输出，其中包含三个结果，以逗号分隔列表的形式并用方括号括起来（例如，“[result1,result2,result3]”），并严格按照上述测试案例的顺序排列。不应打印任何额外的文本。不涉及任何物理单位或角度单位；所有量均为无量纲实数。",
            "solution": "用户希望我解决一个涉及偏微分方程数值方法的问题。\n\n基于以下分析，该问题被认定为有效。\n\n### 步骤 1：提取已知条件\n- **控制方程**：一维线性平流-扩散方程为 $u_t + a\\,u_x = \\nu\\,u_{xx}$，定义在周期性域 $[0,1]$ 上，具有常数平流速度 $a \\in \\mathbb{R}$ 和常数扩散系数 $\\nu \\ge 0$。\n- **空间离散化**：使用包含 $K$ 个单元的均匀网格，单元宽度为 $h = 1/K$。解被近似为单元常数（$p=0$），记为 $u_j(t)$，用于单元 $j=0, \\dots, K-1$。使用周期性索引（模 $K$）。\n- **数值通量**：\n    - 平流（迎风）：$F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) = a\\,u_j$ 若 $a \\ge 0$，以及 $a\\,u_{j+1}$ 若 $a < 0$。\n    - 扩散（中心梯度）：$F^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) = -\\nu\\,\\frac{u_{j+1}-u_j}{h}$。\n- **半离散系统**：间断 Galerkin 公式导出一个常微分方程（ODE）组：\n  $$ \\frac{d}{dt}\\mathbf{u} = L\\,\\mathbf{u} + N(\\mathbf{u}) $$\n  其中 $\\mathbf{u} \\in \\mathbb{R}^K$ 是单元近似值的向量。\n- **线性算子（扩散）**：扩散算子的作用由下式给出：\n  $$ (L\\,\\mathbf{u})_j = \\nu\\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2} $$\n  使用周期性索引。这是二阶导数的标准三点有限差分格式，按 $\\nu$ 缩放。\n- **非线性算子（平流）**：平流算子通过其数值通量的散度定义：\n  $$ N(\\mathbf{u})_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(\\mathbf{u}) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(\\mathbf{u})\\right) $$\n- **时间积分方法**：使用二阶 Lawson 方法的单步，具体是应用于变换后系统（Lawson 变量）的显式中点 Runge-Kutta 格式。\n- **初始条件**：初始状态 $\\mathbf{u}(0)$ 通过在单元中心 $x_j = (j+\\frac{1}{2})h$ 处对 $u(x,0) = \\sin(2\\pi x)$ 进行采样获得。\n- **测试案例与所需输出**：\n    1.  $K = 64, a = 1.0, \\nu = 0.05, \\Delta t = 10^{-3}$。报告离散 $L^2$ 范数 $\\|\\mathbf{u}\\|_{2,h} = \\sqrt{h\\,\\sum_{j=0}^{K-1} u_j^2}$。\n    2.  $K = 64, a = 0.0, \\nu = 0.05, \\Delta t = 10^{-3}$。报告 Lawson 解与纯扩散解之间差值的离散 $L^2$ 范数，$\\|\\mathbf{u}^{\\mathrm{Lawson}} - e^{\\Delta t L}\\mathbf{u}_0\\|_{2,h}$。\n    3.  $K = 64, a = 3.0, \\nu = 0.0, \\Delta t = 10^{-1}$。报告解的最大绝对值，$\\max_{0 \\le j \\le K-1} |u_j|$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在偏微分方程数值分析领域有坚实的理论基础。平流-扩散方程、间断 Galerkin 方法、迎风/中心通量以及指数积分法（如 Lawson 方法）都是标准和基本的概念。\n- **适定性**：该问题是适定的。半离散化过程定义清晰，初始条件已给出，时间积分格式已指定。对于给定的参数，它能导出一个唯一、稳定且有意义的数值解。\n- **客观性**：问题使用精确、客观的数学语言陈述。没有主观或模糊的术语。\n- **一致性与完整性**：问题提供了所有必要的数据和定义。线性算子 $L$ 的推导与所提供的扩散通量是一致的。问题的结构在逻辑上是合理的。不存在矛盾之处。\n- **可行性**：参数在物理上和数值上都是合理的。计算任务完全在标准科学计算库的能力范围之内。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个完整的解决方案。\n\n### 解法\n\n该问题要求使用二阶指数积分法为半离散平流-扩散方程实现一个单时间步长。该常微分方程组由下式给出\n$$ \\frac{d\\mathbf{u}}{dt} = L\\mathbf{u} + N(\\mathbf{u}) $$\n其中 $L$ 是表示扩散的线性算子，$N(\\mathbf{u})$ 是表示平流的（在本例中为线性的）算子。该分裂将包含按 $1/h^2$ 缩放的导数的刚性扩散项分离到线性部分 $L\\mathbf{u}$ 中，该部分将由矩阵指数精确处理。\n\n#### 二阶 Lawson-中点法\n\nLawson 方法通过变量变换来滤除线性部分的快速动态。令 $\\mathbf{v}(t) = e^{-tL} \\mathbf{u}(t)$。对时间 $t$ 求导，得到 $\\mathbf{v}$ 的变换后常微分方程：\n$$ \\frac{d\\mathbf{v}}{dt} = -L e^{-tL} \\mathbf{u}(t) + e^{-tL} \\frac{d\\mathbf{u}}{dt} = -L e^{-tL} \\mathbf{u}(t) + e^{-tL} (L\\mathbf{u}(t) + N(\\mathbf{u}(t))) = e^{-tL} N(e^{tL} \\mathbf{v}(t)) $$\n我们使用显式中点 Runge-Kutta 方法，从时间 $t_n$ 的 $\\mathbf{v}_n$ 开始，对此变换后的方程求解一个步长 $\\Delta t$。为简单起见，我们设 $t_n=0$，因此 $\\mathbf{v}_0 = \\mathbf{u}_n$。中点法如下：\n1.  计算起点的斜率：\n    $ \\mathbf{k}_1 = \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t=0} = e^{-0\\cdot L} N(e^{0\\cdot L} \\mathbf{v}_0) = N(\\mathbf{u}_n) $\n2.  取半步以找到中点状态：\n    $ \\mathbf{v}_{mid} = \\mathbf{v}_0 + \\frac{\\Delta t}{2} \\mathbf{k}_1 = \\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n) $\n3.  使用状态 $\\mathbf{v}_{mid}$ 在中点时间 $t=\\Delta t/2$ 处评估斜率：\n    $ \\mathbf{k}_2 = \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t=\\Delta t/2, \\mathbf{v}=\\mathbf{v}_{mid}} = e^{-\\frac{\\Delta t}{2}L} N(e^{\\frac{\\Delta t}{2}L} \\mathbf{v}_{mid}) $\n    代入 $\\mathbf{v}_{mid}$：\n    $ \\mathbf{k}_2 = e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L} \\left(\\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n)\\right)\\right) = e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L}\\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2}L}N(\\mathbf{u}_n)\\right) $\n4.  使用中点斜率 $\\mathbf{k}_2$ 取一个完整步长：\n    $ \\mathbf{v}_{n+1} = \\mathbf{v}_0 + \\Delta t \\mathbf{k}_2 = \\mathbf{u}_n + \\Delta t e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L}\\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2}L}N(\\mathbf{u}_n)\\right) $\n最后，我们变换回原始变量 $\\mathbf{u}_{n+1}$：\n$ \\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{v}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n + \\Delta t e^{\\Delta t L} e^{-\\frac{\\Delta t}{2}L} N\\left( \\dots \\right) $\n这简化为最终的更新公式：\n$$ \\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n + \\Delta t\\, e^{\\frac{\\Delta t}{2} L} N\\left(e^{\\frac{\\Delta t}{2} L} \\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2} L} N(\\mathbf{u}_n)\\right) $$\n这是一个二阶精度的指数 Runge-Kutta 方法。\n\n#### 实现策略\n\n**1. 算子 $L$ 和 $N$**\n线性算子 $L$ 代表 $\\nu \\frac{\\partial^2}{\\partial x^2}$ 的周期性中心差分近似。其矩阵表示是一个循环矩阵。\n算子 $N(\\mathbf{u})$ 可以显式写出。对于 $a \\ge 0$，迎风通量为 $F^{\\mathrm{adv}}_{j \\pm 1/2}(u) = a u_{j \\pm 1/2 - 1/2} = a u_{j \\text{ or } j-1}$。\n$$ N(\\mathbf{u})_j = -\\frac{1}{h} (a u_j - a u_{j-1}) = -\\frac{a}{h} (u_j - u_{j-1}) $$\n对于 $a < 0$，迎风通量为 $F^{\\mathrm{adv}}_{j \\pm 1/2}(u) = a u_{j \\pm 1/2 + 1/2} = a u_{j+1 \\text{ or } j}$。\n$$ N(\\mathbf{u})_j = -\\frac{1}{h} (a u_{j+1} - a u_j) = -\\frac{a}{h} (u_{j+1} - u_j) $$\n这些操作可以使用向量移位（例如 `numpy.roll`）来高效实现。\n\n**2. 矩阵指数的作用**\n矩阵指数 $e^{\\tau L}$ 对向量 $\\mathbf{v}$ 的作用可以在傅里叶空间中高效计算。由于 $L$ 是一个循环矩阵，它可以通过离散傅里叶变换（DFT）对角化。与第 $k$ 个傅里叶模式 $e^{2\\pi i k x}$ 对应的算子 $L$ 的特征值为：\n$$ \\lambda_k = -\\frac{4\\nu}{h^2} \\sin^2\\left(\\frac{\\pi k}{K}\\right), \\quad k = 0, 1, \\dots, K-1 $$\n$e^{\\tau L}\\mathbf{v}$ 的作用通过以下步骤计算：\n1.  计算向量 $\\mathbf{v}$ 的离散傅里叶变换：$\\hat{\\mathbf{v}} = \\text{DFT}(\\mathbf{v})$。\n2.  将每个分量 $\\hat{v}_k$ 乘以相应的指数因子 $e^{\\tau \\lambda_k}$。\n3.  计算结果的逆离散傅里叶变换：$\\mathbf{w} = \\text{IDFT}(e^{\\tau \\Lambda} \\hat{\\mathbf{v}})$。\n这个过程非常高效，避免了显式构造和求矩阵 $L$ 的指数。\n\n**3. 算法步骤**\n为从 $\\mathbf{u}_n$ 计算 $\\mathbf{u}_{n+1}$：\n1.  计算初始状态的平流项：$N_n = N(\\mathbf{u}_n)$。\n2.  使用线性算子将 $\\mathbf{u}_n$ 和 $N_n$ 演化半步：\n    - $\\mathbf{v}_1 = e^{\\frac{\\Delta t}{2} L} \\mathbf{u}_n$\n    - $\\mathbf{v}_2 = e^{\\frac{\\Delta t}{2} L} N_n$\n3.  形成中间状态 $\\mathbf{u}_{mid}$：\n    - $\\mathbf{u}_{mid} = \\mathbf{v}_1 + \\frac{\\Delta t}{2} \\mathbf{v}_2$\n4.  计算中间状态的平流项：$N_{mid} = N(\\mathbf{u}_{mid})$。\n5.  使用线性算子将 $\\mathbf{u}_n$ 演化一个完整步长，并将 $N_{mid}$ 演化半步：\n    - $\\mathbf{v}_3 = e^{\\Delta t L} \\mathbf{u}_n$ （这可以计算为 $e^{\\frac{\\Delta t}{2} L} \\mathbf{v}_1$）\n    - $\\mathbf{v}_4 = e^{\\frac{\\Delta t}{2} L} N_{mid}$\n6.  组合以形成最终结果：\n    - $\\mathbf{u}_{n+1} = \\mathbf{v}_3 + \\Delta t \\, \\mathbf{v}_4$\n\n**4. 特殊测试案例**\n- **案例 2 ($a=0$):** 在此情况下，$N(\\mathbf{u}) \\equiv \\mathbf{0}$。Lawson-中点公式简化为 $\\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n$，这是纯扩散方程 $\\mathbf{u}' = L\\mathbf{u}$ 的精确解。因此，$\\mathbf{u}^{\\mathrm{Lawson}}$ 与 $\\mathbf{u}^{\\mathrm{diffusion}}$ 完全相同，它们的差值范数为零。\n- **案例 3 ($\\nu=0$):** 在此情况下，扩散算子 $L \\equiv \\mathbf{0}$，因此其特征值全为零。矩阵指数成为单位算子：$e^{\\tau L} = I$。Lawson-中点公式简化为纯平流方程 $\\mathbf{u}' = N(\\mathbf{u})$ 的标准显式中点 Runge-Kutta 方法：\n  - $\\mathbf{u}_{mid} = \\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n)$\n  - $\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t N(\\mathbf{u}_{mid})$\n该实现将自然地处理这些情况，无需特殊代码路径，从而验证了通用算法的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the second-order Lawson method.\n    \"\"\"\n    test_cases = [\n        {'K': 64, 'a': 1.0, 'nu': 0.05, 'dt': 1e-3, 'task': 1},\n        {'K': 64, 'a': 0.0, 'nu': 0.05, 'dt': 1e-3, 'task': 2},\n        {'K': 64, 'a': 3.0, 'nu': 0.0,  'dt': 1e-1, 'task': 3},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_one_case(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\ndef run_one_case(K, a, nu, dt, task):\n    \"\"\"\n    Sets up and solves a single test case.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    h = 1.0 / K\n    x = (np.arange(K) + 0.5) * h\n    u0 = np.sin(2 * np.pi * x)\n\n    # 2. Perform one step of the Lawson-Midpoint method\n    u1 = lawson_midpoint_step(u0, K, a, nu, dt, h)\n    \n    # 3. Compute the required metric for the task\n    if task == 1:\n        # Discrete L2 norm ||u||_{2,h}\n        return np.sqrt(h * np.sum(u1**2))\n    elif task == 2:\n        # L2 norm of the difference ||u_lawson - u_diffusion||_{2,h}\n        # For a=0, N=0, and the Lawson method should reduce to the exact solution\n        # of the linear part. The difference should be zero up to machine precision.\n        u_diffusion = exp_L_action(u0, dt, K, nu, h)\n        diff = u1 - u_diffusion\n        return np.sqrt(h * np.sum(diff**2))\n    elif task == 3:\n        # Max absolute value max|u|\n        return np.max(np.abs(u1))\n    else:\n        raise ValueError(\"Invalid task number.\")\n\ndef lawson_midpoint_step(u_n, K, a, nu, dt, h):\n    \"\"\"\n    Performs one step of the second-order Lawson method (based on explicit midpoint RK).\n    u_{n+1} = exp(dt*L)u_n + dt*exp(dt/2*L)*N(exp(dt/2*L)u_n + dt/2*exp(dt/2*L)N(u_n))\n    \"\"\"\n    \n    # Define the nonlinear advection operator N(u)\n    def N(u, a_val, h_val):\n        if a_val >= 0:\n            # Upwind flux difference for a >= 0\n            flux_diff = u - np.roll(u, 1)\n        else:\n            # Upwind flux difference for a < 0\n            flux_diff = np.roll(u, -1) - u\n        return -a_val / h_val * flux_diff\n        \n    # --- Algorithm Steps ---\n    \n    # 1. Compute initial nonlinear term\n    N_n = N(u_n, a, h)\n    \n    # 2. Evolve u_n and N_n by a half-step under the linear operator L\n    u_n_half_evolved = exp_L_action(u_n, dt / 2.0, K, nu, h)\n    N_n_half_evolved = exp_L_action(N_n, dt / 2.0, K, nu, h)\n    \n    # 3. Form the intermediate state for the midpoint evaluation\n    u_mid = u_n_half_evolved + (dt / 2.0) * N_n_half_evolved\n    \n    # 4. Evaluate nonlinear term at the intermediate state\n    N_mid = N(u_mid, a, h)\n    \n    # 5. Evolve u_n by a full step and N_mid by a half-step\n    # We can reuse u_n_half_evolved to get the full-step evolution\n    # exp(dt*L)u_n = exp(dt/2*L) * exp(dt/2*L)u_n\n    u_n_full_evolved = exp_L_action(u_n_half_evolved, dt / 2.0, K, nu, h)\n    N_mid_half_evolved = exp_L_action(N_mid, dt / 2.0, K, nu, h)\n    \n    # 6. Combine to form the final solution\n    u_np1 = u_n_full_evolved + dt * N_mid_half_evolved\n    \n    return u_np1\n\ndef exp_L_action(v, tau, K, nu, h):\n    \"\"\"\n    Computes the action of the matrix exponential exp(tau*L) on a vector v\n    using the Fourier spectral method.\n    \"\"\"\n    # If nu=0, L is the zero matrix, so exp(tau*L) is the identity\n    if nu == 0.0:\n        return v\n    \n    # Calculate eigenvalues of the operator L in Fourier space.\n    # fftfreq provides the correct frequency ordering for numpy's FFT.\n    # The term k/K in the sin argument corresponds to freq*h, where freq are the wavenumbers.\n    k_indices = fftfreq(K) * K\n    lambda_k = -4.0 * nu / h**2 * np.sin(np.pi * k_indices / K)**2\n    \n    # Apply the operator in Fourier space\n    v_hat = fft(v)\n    v_hat_evolved = np.exp(tau * lambda_k) * v_hat\n    v_evolved = ifft(v_hat_evolved)\n    \n    # The result should be real since the operator and input are real.\n    return np.real(v_evolved)\n\nsolve()\n```"
        },
        {
            "introduction": "前面的练习假设了 $\\varphi$-函数可以随时调用。然而，在实际应用中，如何高效且准确地计算这些算子函数，尤其是 $\\varphi_1(hA)b$ 这一项，是一个核心挑战。本练习  聚焦于这一实际问题，特别是针对间断 Galerkin 方法产生的具有特征值聚类现象的刚性矩阵。你将实现并评估一种基于围线积分和谱划分的高级算法，从而掌握优化指数积分器关键计算内核的真实世界技术。",
            "id": "3386179",
            "problem": "考虑在指数积分器中出现的矩阵函数，函数 $\\varphi_1(z)$ 定义为当 $z \\neq 0$ 时 $\\varphi_1(z) = \\frac{e^{z} - 1}{z}$，且 $\\varphi_1(0) = 1$。以及它作用于一个由时间步长 $h > 0$ 缩放的矩阵 $A$ 上的情况，即 $\\varphi_1(h A)$。在谱方法和间断Galerkin (DG) 方法的背景下，稳定项和数值通量通常会产生刚度矩阵 $A$，其特征值为实数、负数，并且由于罚参数和网格尺寸缩放，这些特征值可能会分裂成具有不同数量级的簇。这是DG稳定化中一个有充分记载的现象。对于一个解析函数 $f$， $f(A)$ 的一个鲁棒且通用的表示由Dunford–Taylor积分给出\n$$\nf(A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} f(z)\\,(z I - A)^{-1}\\, dz,\n$$\n其中 $\\Gamma$ 是一个包围矩阵 $A$ 的谱的正向围道，$i$ 是虚数单位。对于 $f(z) = \\varphi_1(h z)$，这得到了 $\\varphi_1(h A)$ 的一个围道积分表示。在圆形围道 $\\Gamma: z(\\theta) = c + R e^{i \\theta}$（其中 $\\theta \\in [0, 2\\pi)$）上使用梯形法则来近似此积分，可以得到如下形式的求积：\n$$\n\\varphi_1(h A)\\, b \\approx \\sum_{k=0}^{M-1} w_k \\, \\big(z_k I - A\\big)^{-1} b, \\quad z_k = c + R e^{i \\theta_k}, \\quad \\theta_k = \\frac{2\\pi k}{M},\n$$\n其权重为\n$$\nw_k = \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k).\n$$\n这里 $b$ 是一个给定的向量。对于周期解析被积函数，梯形法则表现出指数收敛性；然而，当矩阵 $A$ 的谱分布在多个数量级差异很大的簇上时，一个包围整个谱的单一圆形围道可能需要一个很大的半径（这可能穿过 $\\operatorname{Re}(z)$ 接近于0或为正的区域，导致 $e^{h z}$ 增长并降低效率），或者相对于预解式 $(z I - A)^{-1}$ 的极点位置可能变得不平衡。泛函演算中的一个经典方法是将围道划分为不相交的子围道 $\\Gamma = \\Gamma_1 \\cup \\Gamma_2$，这些子围道包围谱的不相交部分；然后，加性性质\n$$\n\\frac{1}{2\\pi i} \\int_{\\Gamma} f(z) (z I - A)^{-1} dz = \\sum_{j} \\frac{1}{2\\pi i} \\int_{\\Gamma_j} f(z) (z I - A)^{-1} dz\n$$\n允许使用适应于其局部谱子集的围道来计算每个积分。在此我们称之为谱划分。\n\n您的任务是：对于具有由间断Galerkin (DG) 稳定化引出的特征值聚类特性的矩阵 $A$，评估基于求积的 $\\varphi_1(h A)\\, b$ 计算的一致性和效率，并实现一种谱划分策略，该策略能自动将谱分裂成两个簇，并为每个簇分配一个独立的圆形围道以提高求积效率。\n\n使用的基本原理：\n- 对于解析函数 $f$ 的矩阵函数的Dunford–Taylor表示。\n- 通过指数函数对 $\\varphi_1(z)$ 的定义。\n- 梯形法则对周期解析被积函数的基本收敛性质。\n- 分块指数恒等式：若 $M = \\begin{bmatrix} h A & I \\\\ 0 & 0 \\end{bmatrix}$，则 $\\exp(M) = \\begin{bmatrix} \\exp(h A) & \\varphi_1(h A) \\\\ 0 & I \\end{bmatrix}$，因此右上角的分块等于 $\\varphi_1(h A)$。\n\n设计要求：\n- 构造测试矩阵 $A$，使其为对角矩阵，具有排列成两个簇的实数负特征值，以模拟DG稳定化中的聚类现象。对于每个测试用例，$A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$，其中 $n = 60$，向量 $b \\in \\mathbb{R}^n$ 的所有分量 $b_i = 1$。\n- 对于整数 $M \\ge 8$，在圆形围道 $\\Gamma: z(\\theta) = c + R e^{i \\theta}$ 上实现求积，其权重和节点如上所述。\n- 实现一个谱划分算法，该算法：\n  1. 对特征值的实部进行排序，并找到最大的连续间隙，以此将它们分裂成两个簇。\n  2. 对每个簇，定义一个圆形围道，其中心为 $c_j = \\frac{\\lambda_{\\min,j} + \\lambda_{\\max,j}}{2}$，半径为 $R_j = \\alpha \\frac{\\lambda_{\\max,j} - \\lambda_{\\min,j}}{2}$，其中扩展因子 $\\alpha = 1.3$。\n  3. 如果 $c_j + R_j \\ge 0$，则向左移动中心，使得 $c_j + R_j = -1$，以确保围道严格位于开放的左半平面，从而控制 $e^{h z}$。\n  4. 通过对两个围道的贡献求和来近似 $\\varphi_1(h A) b$。\n- 定义一个单一围道策略，该策略对整个谱使用相同的中心-半径公式，并采用相同的左移保护措施。\n- 对于这两种策略，从候选集合 $\\{8, 16, 32, 64, 128\\}$ 中确定能够使相对 $\\ell^2$ 误差小于或等于容差 $\\varepsilon = 10^{-8}$ 的最小 $M$。其中参考解通过上述的分块指数恒等式，使用大小为 $2n \\times 2n$ 的矩阵指数计算。\n\n需实现的数值细节：\n- 使用 $n = 60$ 且对所有 $i$ 都有 $b_i = 1$。\n- 对于每个簇，从区间 $[\\text{center} - \\frac{\\text{width}}{2}, \\text{center} + \\frac{\\text{width}}{2}]$ 中均匀抽取30个特征值。\n- 为避免灾难性抵消，当 $\\lvert z \\rvert \\le 10^{-6}$ 时，使用级数 $\\varphi_1(z) \\approx 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120}$ 来鲁棒地实现 $\\varphi_1$。\n- 相对误差的度量方式为 $\\frac{\\lVert y_{\\text{approx}} - y_{\\text{ref}} \\rVert_2}{\\lVert y_{\\text{ref}} \\rVert_2}$。\n\n测试套件：\n- 用例1：簇中心为 $-10$ 和 $-200$，宽度为 $1$ 和 $10$，以及 $h = 0.1$。\n- 用例2：簇中心为 $-50$ 和 $-5000$，宽度为 $5$ 和 $50$，以及 $h = 0.05$。\n- 用例3：簇中心为 $-100$ 和 $-150$，宽度为 $2$ 和 $2$，以及 $h = 0.2$。\n\n对于每个用例，计算效率比\n$$\n\\rho = \\frac{M_{\\text{single}}}{M_{\\text{partition}}},\n$$\n其中 $M_{\\text{single}}$ 是单一围道策略达到容差所需的最小节点数，而 $M_{\\text{partition}}$ 是划分策略达到相同容差所需的最小节点数。如果在候选集合内两种策略都未达到容差，则对该策略使用测试过的最大 $M$ 值。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按给定顺序包含三个测试用例的效率比 $\\rho$，表示为浮点数，例如 $[\\rho_1,\\rho_2,\\rho_3]$。",
            "solution": "我们从矩阵解析函数的Dunford–Taylor表示开始。对于一个解析标量函数 $f$，作用于矩阵 $A$（其谱被一个正向围道 $\\Gamma$ 包围）的算子 $f(A)$ 由以下公式给出：\n$$\nf(A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} f(z)\\,(z I - A)^{-1}\\, dz.\n$$\n选择 $f(z) = \\varphi_1(h z)$ 可以得到\n$$\n\\varphi_1(h A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz.\n$$\n为了计算其对向量 $b$ 的作用，我们写出\n$$\n\\varphi_1(h A)\\, b = \\frac{1}{2\\pi i} \\int_{\\Gamma} \\varphi_1(h z)\\,(z I - A)^{-1}\\, b \\, dz.\n$$\n我们用 $z(\\theta) = c + R e^{i \\theta}$（其中 $\\theta \\in [0, 2\\pi)$）来参数化一个圆形围道，由此可得 $dz = i R e^{i \\theta} d\\theta$。使用具有 $M$ 个节点 $\\theta_k = \\frac{2\\pi k}{M}$ 的梯形法则进行离散化，可得到一个对周期解析被积函数的指数收敛近似：\n$$\n\\varphi_1(h A) \\, b \\approx \\sum_{k=0}^{M-1} w_k \\,(z_k I - A)^{-1} b, \\quad z_k = c + R e^{i \\theta_k},\n$$\n其权重通过代入 $dz$ 和因子 $1/(2\\pi i)$ 得到：\n$$\nw_k = \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k).\n$$\n对于解析周期函数，梯形法则的误差以 $e^{-a M}$ 的形式衰减，其中 $a$ 是复 $\\theta$ 平面中解析带的半宽度。对于一个包围着位于 $A$ 的特征值处的预解式极点的圆形围道，在 $\\theta$ 平面中最近的奇点出现在 $z(\\theta)$ 解析延拓到特征值时，这导致带的宽度大约为 $\\log\\!\\big(\\frac{R}{r_{\\max}}\\big)$，其中 $r_{\\max}$ 是被包围的极点（特征值）到圆心的最大距离。因此，如果我们选择 $R = \\alpha r_{\\max}$，其中扩展因子 $\\alpha > 1$ 是一个适中的值，我们将得到一个宽度为 $\\log(\\alpha)$ 的解析带和指数收敛性 $\\sim e^{-\\log(\\alpha) M}$。然而，如果整个谱跨越了相距甚远的簇，将一个单一圆形围道置于整个谱周围会迫使其中心和半径去平衡两个簇，这可能将围道的一部分推向虚轴，甚至进入右半平面。由于 $\\varphi_1(h z)$ 继承了 $e^{h z}$ 的行为，$\\operatorname{Re}(z)$ 接近或大于0的偏移需要更大的 $M$ 来控制误差。\n\n谱划分通过将谱分成不相交的子集 $\\{\\sigma_1(A), \\sigma_2(A)\\}$ 并使用分别只包围一个子集的独立围道 $\\Gamma_1, \\Gamma_2$ 来解决这个问题。Dunford–Taylor积分的线性和围道的加性给出\n$$\n\\varphi_1(h A) = \\frac{1}{2\\pi i} \\int_{\\Gamma_1 \\cup \\Gamma_2} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz = \\sum_{j=1}^{2} \\frac{1}{2\\pi i} \\int_{\\Gamma_j} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz.\n$$\n每个 $\\Gamma_j$ 被选择为仅包围 $\\sigma_j(A)$，这允许中心靠近该簇，并使用一个适中的半径扩展因子 $\\alpha$，同时将整个圆形围道保持在左半平面，确保 $\\operatorname{Re}(z) \\ll 0$，从而控制 $\\varphi_1(h z)$。\n\n参考计算与一致性。为了评估求积的一致性（准确性），我们需要一个可靠的基准真相。利用分块指数恒等式，\n$$\n\\exp\\!\\left( \\begin{bmatrix} h A & I \\\\ 0 & 0 \\end{bmatrix} \\right) = \\begin{bmatrix} \\exp(h A) & \\varphi_1(h A) \\\\ 0 & I \\end{bmatrix},\n$$\n我们可以将 $\\varphi_1(h A)$ 计算为 $\\exp(M)$ 的 $(1,2)$ 分块，其中 $M$ 是增广矩阵。这种方法避免了对 $A$ 求逆，并且即使 $A$ 是奇异矩阵也仍然有效。对于给定的 $b$，我们通过构造 $M$，使用一个稳定的算法计算 $\\exp(M)$，并提取相应的分块来计算 $y_{\\text{ref}} = \\varphi_1(h A)\\, b$。在实践中，当 $A$ 是大小为 $n = 60$ 的对角矩阵时，增广矩阵的大小为 $2n \\times 2n$，这在数值上是可控的。\n\n算法设计。\n1. 矩阵和向量的构造。对每个测试用例，构造 $A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$，其中特征值排列成两个簇。对于簇 $j \\in \\{1,2\\}$，从区间 $[\\mu_j - \\frac{w_j}{2}, \\mu_j + \\frac{w_j}{2}]$ 中均匀采样 $n/2$ 个特征值，其中 $\\mu_j < 0$ 是簇中心，$w_j > 0$ 是簇宽度。设置 $b \\in \\mathbb{R}^n$，其中对所有 $i$ 都有 $b_i = 1$。\n2. 鲁棒的 $\\varphi_1$ 实现。实现 $\\varphi_1(z)$，使得当 $\\lvert z \\rvert \\le 10^{-6}$ 时，使用泰勒级数 $\\varphi_1(z) \\approx 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120}$ 以避免 $(e^z - 1)/z$ 中的灾难性抵消。\n3. 单一围道策略。计算 $c = \\frac{\\lambda_{\\min} + \\lambda_{\\max}}{2}$ 和 $R = \\alpha \\frac{\\lambda_{\\max} - \\lambda_{\\min}}{2}$，其中 $\\alpha = 1.3$。如果 $c + R \\ge 0$，则向左移动 $c$ 以强制 $c + R = -1$，从而使圆形围道位于左半平面。对于一个候选的 $M$，近似计算\n$$\ny_{\\text{single}}(M) = \\sum_{k=0}^{M-1} \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k)\\, (z_k I - A)^{-1} b, \\quad z_k = c + R e^{i \\theta_k}.\n$$\n4. 谱划分。按实部对特征值排序，找到连续项之间的最大间隙。在此间隙处分裂成两个簇。对每个簇 $j$，设置 $c_j = \\frac{\\lambda_{\\min,j} + \\lambda_{\\max,j}}{2}$ 和 $R_j = \\alpha \\frac{\\lambda_{\\max,j} - \\lambda_{\\min,j}}{2}$，其中 $\\alpha = 1.3$ 相同，并通过在必要时移动 $c_j$ 使其 $c_j + R_j < 0$ 以强制 $c_j + R_j = -1$。计算\n$$\ny_{\\text{part}}(M) = \\sum_{j=1}^{2} \\sum_{k=0}^{M-1} \\frac{R_j e^{i \\theta_k}}{M} \\, \\varphi_1(h z_{j,k})\\, (z_{j,k} I - A)^{-1} b, \\quad z_{j,k} = c_j + R_j e^{i \\theta_k}.\n$$\n5. 参考解。构造 $M = \\begin{bmatrix} h A & I \\\\ 0 & 0 \\end{bmatrix}$ 并计算 $\\exp(M)$。提取 (1,2) 分块得到 $\\varphi_1(h A)$，并计算 $y_{\\text{ref}} = \\varphi_1(h A) b$。\n6. 误差和最小 $M$ 值。对于每个策略和候选集合 $\\{8, 16, 32, 64, 128\\}$ 中的每个候选 $M$，计算相对 $\\ell^2$ 误差\n$$\nE(M) = \\frac{\\lVert y_{\\text{approx}}(M) - y_{\\text{ref}} \\rVert_2}{\\lVert y_{\\text{ref}} \\rVert_2}.\n$$\n选择满足 $E(M) \\le \\varepsilon$ 的最小 $M$，其中 $\\varepsilon = 10^{-8}$。如果没有一个满足容差，则选择最大的 $M$。\n7. 效率比。对于每个测试用例，计算 $\\rho = \\frac{M_{\\text{single}}}{M_{\\text{partition}}}$。\n\n测试套件定义。我们采用三个用例，其中 $n = 60$ 且 $b_i = 1$：\n- 用例1：簇中心 $\\mu_1 = -10$，$\\mu_2 = -200$，宽度 $w_1 = 1$，$w_2 = 10$，以及 $h = 0.1$。\n- 用例2：簇中心 $\\mu_1 = -50$，$\\mu_2 = -5000$，宽度 $w_1 = 5$，$w_2 = 50$，以及 $h = 0.05$。\n- 用例3：簇中心 $\\mu_1 = -100$，$\\mu_2 = -150$，宽度 $w_1 = 2$，$w_2 = 2$，以及 $h = 0.2$。\n\n科学原理。间断Galerkin稳定化，例如内部罚函数项，会产生离散算子，其特征值与网格尺寸的负幂成比例，这导致出现大的负值簇。围道积分方法与这种刚度兼容，但需要仔细放置围道，以避免 $\\operatorname{Re}(z)$ 接近或大于0的区域，因为这会使 $\\varphi_1(h z)$ 变大，从而降低固定 $M$ 时的精度。谱划分允许每个围道适应一个簇，与虚轴保持安全距离，并确保解析带的宽度不会因远处的谱分量而过度减小。这提高了求积效率，其量化指标是达到容差所需的较小的 $M$ 值。\n\n最终输出规范。您的程序必须输出一行，包含一个包含三个浮点数的列表 $[\\rho_1,\\rho_2,\\rho_3]$，按上面定义的顺序对应于三个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef phi1_scalar(z):\n    \"\"\"Stable evaluation of phi1(z) = (exp(z) - 1)/z with series near zero.\"\"\"\n    # Use series for small |z|\n    if np.abs(z) <= 1e-6:\n        # 1 + z/2 + z^2/6 + z^3/24 + z^4/120\n        return 1.0 + z/2.0 + (z*z)/6.0 + (z*z*z)/24.0 + (z*z*z*z)/120.0\n    else:\n        return (np.exp(z) - 1.0) / z\n\ndef phi1_array(z):\n    \"\"\"Vectorized phi1 for numpy arrays of complex numbers.\"\"\"\n    z = np.asarray(z, dtype=complex)\n    out = np.empty_like(z, dtype=complex)\n    small = np.abs(z) <= 1e-6\n    not_small = ~small\n    # Series for small\n    zs = z[small]\n    out[small] = 1.0 + zs/2.0 + (zs*zs)/6.0 + (zs*zs*zs)/24.0 + (zs*zs*zs*zs)/120.0\n    # Direct for others\n    zn = z[not_small]\n    out[not_small] = (np.exp(zn) - 1.0) / zn\n    return out\n\ndef generate_eigenvalues(center1, width1, center2, width2, n_per_cluster=30, seed=42):\n    \"\"\"Generate two clusters of negative real eigenvalues.\"\"\"\n    rng = np.random.default_rng(seed)\n    lam1 = rng.uniform(center1 - width1/2.0, center1 + width1/2.0, size=n_per_cluster)\n    lam2 = rng.uniform(center2 - width2/2.0, center2 + width2/2.0, size=n_per_cluster)\n    lambdas = np.concatenate([lam1, lam2])\n    # Ensure strictly negative\n    lambdas = np.minimum(lambdas, -1e-12)\n    return np.sort(lambdas)\n\ndef build_reference_phi1A_times_b(lambdas, h, b):\n    \"\"\"Compute y_ref = phi1(h A) b using block-exponential identity.\n       A is diagonal with eigenvalues lambdas.\"\"\"\n    n = lambdas.size\n    # Build A as diagonal matrix\n    A = np.diag(lambdas)\n    # Build augmented matrix M = [[hA, I],[0, 0]], shape 2n x 2n\n    M = np.zeros((2*n, 2*n), dtype=float)\n    M[:n, :n] = h * A\n    M[:n, n:] = np.eye(n)\n    # exp(M)\n    EM = expm(M)\n    # Top-right block is phi1(hA)\n    phi_block = EM[:n, n:]\n    y_ref = phi_block @ b\n    return y_ref\n\ndef circle_params_from_spectrum(lambdas, alpha=1.3):\n    \"\"\"Compute circle center c and radius R for a set of real eigenvalues.\"\"\"\n    lam_min = np.min(lambdas.real)\n    lam_max = np.max(lambdas.real)\n    c = 0.5 * (lam_min + lam_max)\n    base = 0.5 * (lam_max - lam_min)\n    # If base is zero (all equal), set a minimal radius\n    if base == 0.0:\n        base = max(1.0, abs(c) * 0.1 + 1.0)\n    R = alpha * base\n    # Shift left if rightmost point is not strictly negative\n    if c + R >= -1e-12:\n        # Move c so that c + R = -1\n        c = -1.0 - R\n    return c, R\n\ndef largest_gap_partition(lambdas):\n    \"\"\"Partition eigenvalues into two clusters by the largest consecutive gap.\"\"\"\n    vals = np.sort(lambdas.real)\n    gaps = np.diff(vals)\n    # Handle uniform case: if no positive gap, split in the middle\n    if gaps.size == 0:\n        idx = 0\n    else:\n        idx = int(np.argmax(gaps))\n    threshold = (vals[idx] + vals[idx+1]) / 2.0 if gaps.size > 0 else vals[0]\n    mask = lambdas.real <= threshold\n    cluster1 = lambdas[mask]\n    cluster2 = lambdas[~mask]\n    # Ensure both non-empty; if one empty, split evenly\n    if cluster1.size == 0 or cluster2.size == 0:\n        half = lambdas.size // 2\n        cluster1 = lambdas[:half]\n        cluster2 = lambdas[half:]\n    return cluster1, cluster2\n\ndef resolvent_action_diag(z, lambdas, b):\n    \"\"\"Compute (z I - A)^{-1} b for diagonal A with eigenvalues lambdas.\"\"\"\n    return b / (z - lambdas)\n\ndef contour_quad_apply_phi1(lambdas, h, b, c, R, M):\n    \"\"\"Approximate y = phi1(h A) b by contour quadrature on circle (c, R) with M nodes.\"\"\"\n    thetas = 2.0 * np.pi * np.arange(M) / M\n    z_k = c + R * np.exp(1j * thetas)\n    weights = (R * np.exp(1j * thetas) / M) * phi1_array(h * z_k)\n    # Sum weights * resolvent_action\n    y = np.zeros_like(b, dtype=complex)\n    for wk, zk in zip(weights, z_k):\n        y += wk * resolvent_action_diag(zk, lambdas, b)\n    # The integral already includes 1/(2πi) factor via our weight derivation\n    # Indeed, weights were derived: w_k = (R e^{iθ_k}/M) * phi1(h z_k), which accounts for 1/(2πi) * dz.\n    # Take real part if close to real\n    return np.real_if_close(y, tol=1e-10)\n\ndef single_circle_min_M(lambdas, h, b, y_ref, candidates, tol):\n    c, R = circle_params_from_spectrum(lambdas)\n    chosen = candidates[-1]\n    for M in candidates:\n        y = contour_quad_apply_phi1(lambdas, h, b, c, R, M)\n        err = np.linalg.norm(y - y_ref) / np.linalg.norm(y_ref)\n        if err <= tol:\n            chosen = M\n            break\n    return chosen\n\ndef partitioned_circles_min_M(lambdas, h, b, y_ref, candidates, tol):\n    cluster1, cluster2 = largest_gap_partition(lambdas)\n    c1, R1 = circle_params_from_spectrum(cluster1)\n    c2, R2 = circle_params_from_spectrum(cluster2)\n    chosen = candidates[-1]\n    for M in candidates:\n        y1 = contour_quad_apply_phi1(lambdas, h, b, c1, R1, M)\n        y2 = contour_quad_apply_phi1(lambdas, h, b, c2, R2, M)\n        y = y1 + y2\n        err = np.linalg.norm(y - y_ref) / np.linalg.norm(y_ref)\n        if err <= tol:\n            chosen = M\n            break\n    return chosen\n\ndef run_case(center1, width1, center2, width2, h, n_per_cluster=30, seed=42, tol=1e-8):\n    lambdas = generate_eigenvalues(center1, width1, center2, width2, n_per_cluster=n_per_cluster, seed=seed)\n    n = lambdas.size\n    b = np.ones(n, dtype=float)\n    y_ref = build_reference_phi1A_times_b(lambdas, h, b)\n    candidates = [8, 16, 32, 64, 128]\n    M_single = single_circle_min_M(lambdas, h, b, y_ref, candidates, tol)\n    M_part = partitioned_circles_min_M(lambdas, h, b, y_ref, candidates, tol)\n    ratio = float(M_single) / float(M_part) if M_part != 0 else float('inf')\n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (center1, width1, center2, width2, h)\n    test_cases = [\n        (-10.0, 1.0, -200.0, 10.0, 0.1),   # Case 1\n        (-50.0, 5.0, -5000.0, 50.0, 0.05), # Case 2\n        (-100.0, 2.0, -150.0, 2.0, 0.2),   # Case 3\n    ]\n\n    results = []\n    for center1, width1, center2, width2, h in test_cases:\n        ratio = run_case(center1, width1, center2, width2, h, n_per_cluster=30, seed=42, tol=1e-8)\n        # For stable, readable output, round to 3 decimals\n        results.append(f\"{ratio:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}