{
    "hands_on_practices": [
        {
            "introduction": "The journey into matrix-free methods begins by building a bridge from the familiar concept of a global sparse matrix. This first practice is designed to provide that connection and a robust verification method for your implementations. You will construct the semi-discrete operator for the linear advection equation in two ways: first, by assembling a global sparse matrix, and second, through a matrix-free function that performs only element-local computations . By comparing the outputs of both methods on random vectors, you will gain confidence that your matrix-free implementation is correct and develop a deep intuition for how local actions aggregate to form the global operator.",
            "id": "3398909",
            "problem": "Consider the one-dimensional linear advection equation with constant velocity on a periodic domain. Let the physical domain be the interval $[0,1]$, partitioned into $E$ affine elements of equal length $h = 1/E$. Each element $e$ is mapped from the reference interval $[-1,1]$ by an affine map with Jacobian $J_e = h/2$. On each element, approximate the solution by a polynomial of degree $N$ using a nodal representation at the Legendre-Gauss-Lobatto (LGL) nodes $\\{\\xi_j\\}_{j=0}^N$ with associated LGL quadrature weights $\\{w_j\\}_{j=0}^N$. Denote the Lagrange interpolating basis functions by $\\{\\phi_j(\\xi)\\}_{j=0}^N$ such that $\\phi_j(\\xi_k) = \\delta_{jk}$, and define the derivative matrix $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ on the reference interval via the identity $d u/d \\xi \\big|_{\\xi = \\xi_j} = \\sum_{k=0}^N D_{jk} u(\\xi_k)$ for any polynomial of degree at most $N$.\n\nFor a constant advection speed $a  0$, the semi-discrete discontinuous Galerkin weak form with the upwind numerical flux on element $e$ states that, for each test function index $j \\in \\{0,\\dots,N\\}$,\n$$\n\\int_{x_{e-1/2}}^{x_{e+1/2}} \\phi_j(x) \\frac{\\partial u}{\\partial t}(x,t) \\, dx\n= -a \\int_{x_{e-1/2}}^{x_{e+1/2}} \\phi_j'(x) u(x,t) \\, dx\n+ a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2},\n$$\nwhere $x_{e\\pm 1/2}$ are the physical element boundaries, the prime denotes derivative with respect to $x$, and $\\hat{u}_{e\\pm 1/2}$ is the upwind numerical trace for $u$ at the right/left element interface. On the periodic mesh and for $a0$, the upwind numerical trace takes the left state at each interface, i.e., $\\hat{u}_{e+1/2} = u_{N}^e$ and $\\hat{u}_{e-1/2} = u_{N}^{e-1}$, where $u_j^e$ denotes the value at node index $j$ on element $e$ and $e-1$ is the left neighbor of $e$ with periodic wrapping.\n\nUse the following well-tested foundational facts:\n- The LGL nodes are the endpoints $\\xi_0 = -1$, $\\xi_N = 1$ together with the $N-1$ roots in $(-1,1)$ of the derivative of the degree-$N$ Legendre polynomial $P_N(\\xi)$.\n- The LGL quadrature weights satisfy $w_j = \\dfrac{2}{N(N+1)} \\dfrac{1}{[P_N(\\xi_j)]^2}$ for $j = 0,\\dots,N$.\n- The mass matrix on element $e$ in the nodal LGL basis is diagonal with entries $M_{jj}^e = J_e w_j$, due to collocation with LGL quadrature.\n- The derivative matrix entries for the Lagrange basis at distinct nodes $\\xi_j \\neq \\xi_k$ are given by the barycentric differentiation identity $D_{jk} = \\dfrac{\\omega_k}{\\omega_j}\\dfrac{1}{\\xi_j - \\xi_k}$, with diagonal entries $D_{jj} = -\\sum_{k\\ne j} D_{jk}$, where $\\omega_j$ are the barycentric weights $\\omega_j = \\left(\\prod_{k\\ne j}(\\xi_j - \\xi_k)\\right)^{-1}$.\n\nTask: Starting from these fundamental definitions and facts, design and implement a procedure to compare, for specified $(E,N,a)$, the actions of a matrix-free discontinuous Galerkin operator with those of a globally assembled sparse matrix operator, both representing the same semi-discrete mapping from nodal degrees of freedom to the right-hand side vector induced by the weak form. Your comparison should be performed by computing norms of differences across random test vectors.\n\nYour program must:\n1. Construct the LGL nodes and weights for a given polynomial degree $N$.\n2. Construct the derivative matrix $D$ using barycentric weights on the LGL nodes.\n3. Define a matrix-free operator application that, without assembling a global matrix, computes the semi-discrete right-hand side at each nodal degree of freedom using only element-local operations, the mass matrix diagonal, the derivative matrix, and upwind numerical fluxes with periodic boundary conditions.\n4. Assemble the global sparse matrix that represents the same semi-discrete operator mapping on the entire periodic mesh with $E$ elements, ordered by concatenating the $(N+1)$ nodes of each element.\n5. For a prescribed number of random test vectors with a fixed seed for reproducibility, compute for each vector the relative $2$-norm of the difference between the matrix-free result and the assembled sparse matrix-vector product result. For each test case, return the maximum of these relative norms.\n\nUse the following test suite (each tuple lists $(E,N,a,\\text{seed},R)$, where $R$ is the number of random vectors tested):\n- $(1,1,1.0,42,3)$: a single element, lowest order case, three random vectors.\n- $(4,3,1.0,7,5)$: a moderate number of elements and degree, five random vectors.\n- $(8,7,0.5,123,4)$: higher polynomial degree, four random vectors.\n- $(10,2,0.0,9,2)$: zero advection speed edge case, two random vectors.\n- $(3,5,2.0,100,4)$: fewer elements with higher speed, four random vectors.\n\nAngle units are not applicable since no angles are used. No physical units need be reported since the output is purely mathematical. For each test case, compute a single floating-point number equal to the maximum relative $2$-norm of the differences across its $R$ random vectors.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), with each result corresponding to the test cases listed in the same order above.",
            "solution": "The problem requires the design, implementation, and verification of two computational approaches for applying the spatial operator of a discontinuous Galerkin (DG) discretization of the one-dimensional linear advection equation. The two approaches are a matrix-free method and a method based on an assembled global sparse matrix. The verification consists of comparing their outputs on random vectors and computing the maximum relative difference.\n\n### Mathematical Formulation\nThe problem considers the linear advection equation $\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$ on a periodic domain $[0,1]$ with advection speed $a  0$. The domain is partitioned into $E$ elements, and on each element, the solution is approximated by a polynomial of degree $N$. The semi-discrete weak form on an element $e$ for a test function $\\phi_j$ is given by:\n$$\n\\int_{x_e} \\phi_j \\frac{\\partial u}{\\partial t} \\, dx = -a \\int_{x_e} \\phi_j' u \\, dx + a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2}\n$$\nThe left side corresponds to the mass matrix acting on the time derivative of the solution coefficients. The task is to compute the right-hand side (RHS) vector for the entire set of degrees of freedom (DOFs). Let $u^e = [u_0^e, \\dots, u_N^e]^T$ be the vector of nodal DOFs on element $e$. The global vector of DOFs $U$ is the concatenation of all $u^e$. The operator to be implemented maps $U$ to the global RHS vector $F(U)$. Let's analyze the contributions to the RHS on a single element $e$.\n\n#### Volume Integral Term\nThe first term is the volume integral, which we denote as $F_{\\text{vol}, j}^e$:\n$$\nF_{\\text{vol}, j}^e = -a \\int_{x_e} \\phi_j'(x) u(x) \\, dx\n$$\nOn element $e$, the solution is $u(x) = \\sum_{k=0}^N u_k^e \\phi_k(x)$. Substituting this into the integral gives:\n$$\nF_{\\text{vol}, j}^e = -a \\sum_{k=0}^N u_k^e \\int_{x_e} \\phi_j'(x) \\phi_k(x) \\, dx\n$$\nThe integral $\\int_{x_e} \\phi_j'(x) \\phi_k(x) \\, dx$ defines the entries of the element stiffness matrix. Transforming to the reference element $[-1,1]$ using the affine map $x(\\xi)$ with Jacobian $J_e = h/2$, where $h=1/E$: $\\phi_j'(x) = \\frac{d\\phi_j}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J_e}\\frac{d\\phi_j}{d\\xi}$ and $dx = J_e d\\xi$. The integral becomes:\n$$\nS^{\\text{ref}}_{jk} = \\int_{-1}^1 \\left(\\frac{1}{J_e}\\frac{d\\phi_j}{d\\xi}\\right) \\phi_k(\\xi) J_e d\\xi = \\int_{-1}^1 \\frac{d\\phi_j}{d\\xi}(\\xi) \\phi_k(\\xi) d\\xi\n$$\nThis reference stiffness matrix is independent of the element. We approximate this integral using the $N+1$-point LGL quadrature rule, which is exact for polynomials of degree up to $2N-1$. The integrand's degree is at most $2N-1$, so the quadrature is not exact in general, but it is the standard DG approach.\nUsing the property that $\\frac{d\\phi_j}{d\\xi}(\\xi) = \\sum_{l=0}^N \\frac{d\\phi_j}{d\\xi}(\\xi_l) \\phi_l(\\xi) = \\sum_{l=0}^N D_{lj} \\phi_l(\\xi)$:\n$$\nS^{\\text{ref}}_{jk} \\approx \\sum_{m=0}^N w_m \\left(\\sum_{l=0}^N D_{lj} \\phi_l(\\xi_m)\\right) \\phi_k(\\xi_m) = \\sum_{m=0}^N w_m \\left(\\sum_{l=0}^N D_{lj} \\delta_{lm}\\right) \\delta_{mk} = w_k D_{kj}\n$$\nIn matrix notation, $S^{\\text{ref}} = D^T \\text{diag}(w)$. The volume contribution to the RHS vector on element $e$ is $F_{\\text{vol}}^e = -a S^{\\text{ref}} u^e$.\n\n#### Surface (Flux) Integral Term\nThe second part of the RHS involves the numerical flux at the element boundaries, $x_{e \\pm 1/2}$:\n$$\nF_{\\text{flux}, j}^e = a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2}\n$$\nThe Lagrange basis functions $\\phi_j$ are defined on the LGL nodes $\\{\\xi_k\\}_{k=0}^N$, where $\\xi_0=-1$ and $\\xi_N=1$. These map to the element boundaries $x_{e-1/2}$ and $x_{e+1/2}$ respectively. Due to the property $\\phi_j(\\xi_k)=\\delta_{jk}$, we have $\\phi_j(x_{e-1/2})=\\delta_{j0}$ and $\\phi_j(x_{e+1/2})=\\delta_{jN}$. This means the flux term is non-zero only for the first and last nodes of the element ($j=0$ and $j=N$).\nFor $a0$, the upwind flux takes the value from the \"left\" state at an interface.\n- At the right boundary $x_{e+1/2}$: $\\hat{u}_{e+1/2} = u(x_{e+1/2}^-)$, which is the value at node $N$ on the current element $e$, so $\\hat{u}_{e+1/2} = u_N^e$.\n- At the left boundary $x_{e-1/2}$: $\\hat{u}_{e-1/2} = u(x_{e-1/2}^-)$, which is the value at node $N$ on the neighboring element to the left, $e-1$. Due to periodicity, if $e=0$, $e-1$ corresponds to element $E-1$. Thus, $\\hat{u}_{e-1/2} = u_N^{e-1}$.\nThe flux contributions are:\n- For node $j=0$: $-a \\cdot 1 \\cdot \\hat{u}_{e-1/2} = -a u_N^{e-1}$.\n- For node $j=N$: $a \\cdot 1 \\cdot \\hat{u}_{e+1/2} = a u_N^e$.\n\n### Algorithmic Implementation Strategy\n\n#### Foundational Components\nThe implementation starts by constructing the necessary building blocks for a given polynomial degree $N$:\n1.  **LGL Nodes and Weights**: The nodes $\\{\\xi_j\\}$ are found as the union of $\\{-1, 1\\}$ and the roots of the derivative of the Legendre polynomial $P_N(\\xi)$, which are equivalent to the roots of the Jacobi polynomial $P_{N-1}^{(1,1)}(\\xi)$. The weights $\\{w_j\\}$ are computed via the provided formula.\n2.  **Derivative Matrix**: The reference derivative matrix $D$ is constructed using the given barycentric formula, $D_{jk} = \\frac{\\omega_k}{\\omega_j}\\frac{1}{\\xi_j - \\xi_k}$, and $D_{jj} = -\\sum_{k\\ne j} D_{jk}$. The barycentric weights $\\omega_j = (\\prod_{k\\ne j}(\\xi_j - \\xi_k))^{-1}$ are computed carefully using logarithms to maintain numerical stability.\n\n#### Matrix-Free Operator\nThis operator computes the action $F(U)$ directly without forming a global matrix. It iterates through each of the $E$ elements:\n1.  For each element $e$, extract the local DOF vector $u^e$ from the global vector $U$.\n2.  Compute the volume term: $F_{\\text{vol}}^e = -a (D^T \\text{diag}(w)) u^e$.\n3.  Identify the upwind neighbor's DOF, $u_N^{e-1}$.\n4.  Add the flux contributions: subtract $a u_N^{e-1}$ from the first component of $F_{\\text{vol}}^e$, and add $a u_N^e$ to the last component.\n5.  The resulting vector is the RHS contribution from element $e$, which is stored in the corresponding segment of the global RHS vector $F(U)$.\n\n#### Assembled Matrix Operator\nThis approach explicitly constructs the global $E(N+1) \\times E(N+1)$ sparse matrix $L$ such that $F(U) = L U$.\n1.  Initialize a sparse matrix (e.g., in LIL format for efficient construction).\n2.  Iterate through each element $e$:\n    a.  **Volume part**: The local operator $-a S^{\\text{ref}} = -a D^T \\text{diag}(w)$ is a dense $(N+1) \\times (N+1)$ block. This block is added to the diagonal block of $L$ corresponding to element $e$.\n    b.  **Flux part**: The flux terms create couplings between adjacent elements. For each element $e$:\n        i.  The term $a u_N^e$ adds to the entry in $L$ at the row and column corresponding to the global index of node $N$ on element $e$.\n        ii. The term $-a u_N^{e-1}$ adds to the entry in $L$ at the row for node $0$ on element $e$ and the column for node $N$ on element $e-1$.\n3.  Convert the matrix to an efficient format for matrix-vector products (e.g., CSR).\n\n#### Verification\nFor each test case, $R$ random vectors $U_i$ are generated. The operator action is computed using both methods, yielding $y_{\\text{free},i}$ and $y_{\\text{mat},i} = L U_i$. The relative 2-norm of the difference, $\\frac{\\|y_{\\text{free},i} - y_{\\text{mat},i}\\|_2}{\\|y_{\\text{mat},i}\\|_2}$, is computed. The maximum of these norms over the $R$ vectors is reported. For the special case $a=0$, both methods yield a zero vector, so the difference is zero, and the relative error is taken to be $0$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\nfrom scipy.sparse import lil_matrix\n\ndef get_lgl_nodes_weights(N):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes and weights for a given\n    polynomial degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0])\n    if N == 1:\n        nodes = np.array([-1.0, 1.0])\n        weights = np.array([1.0, 1.0])\n        return nodes, weights\n\n    # Interior nodes are roots of P_N'(x), which are roots of Jacobi P_{N-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n\n    # Weights from the formula w_j = 2 / (N(N+1) [P_N(xi_j)]^2)\n    poly_vals = eval_legendre(N, nodes)\n    weights = 2.0 / (N * (N + 1) * poly_vals**2)\n    \n    return nodes, weights\n\ndef get_derivative_matrix(N, nodes):\n    \"\"\"\n    Computes the nodal derivative matrix D on the reference element using\n    the provided barycentric weight formula.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    D = np.zeros((N + 1, N + 1))\n    omega = np.zeros(N + 1)\n\n    # Compute barycentric weights omega_j = (product_{k!=j} (xi_j - xi_k))^{-1}\n    # This is done using logarithms to avoid numerical overflow/underflow.\n    for j in range(N + 1):\n        log_abs_prod = np.sum(np.log(np.abs(nodes[j] - np.delete(nodes, j))))\n        # The sign of the product is (-1)^(N-j) for ordered nodes.\n        # The sign of omega_j is the same.\n        sign = (-1.0)**(N - j)\n        omega[j] = sign / np.exp(log_abs_prod)\n\n    # Off-diagonal entries: D_jk = (omega_k/omega_j) / (xi_j - xi_k)\n    for j in range(N + 1):\n        for k in range(N + 1):\n            if j != k:\n                D[j, k] = (omega[k] / omega[j]) / (nodes[j] - nodes[k])\n\n    # Diagonal entries: D_jj = -sum_{k!=j} D_jk\n    for j in range(N + 1):\n        D[j, j] = -np.sum(D[j, :])\n        \n    return D\n\ndef matrix_free_operator(U, E, N, a, D, w):\n    \"\"\"\n    Computes the action of the DG operator in a matrix-free fashion.\n    \"\"\"\n    dofs = E * (N + 1)\n    rhs = np.zeros(dofs)\n    \n    if np.isclose(a, 0.0):\n        return rhs\n\n    U_mat = U.reshape((E, N + 1))\n    \n    # Reference stiffness matrix S_ref = D^T @ diag(w)\n    # This is efficiently computed by scaling columns of D^T by w.\n    S_ref = D.T * w\n\n    for e in range(E):\n        u_e = U_mat[e, :]\n        \n        # Volume term contribution\n        vol_term = -a * (S_ref @ u_e)\n        \n        # Flux term contribution (upwind for a  0)\n        e_prev = (e - 1 + E) % E\n        u_left_neighbor_val = U_mat[e_prev, N]  # u_N from element e-1\n        u_self_right_val = u_e[N]               # u_N from element e\n        \n        flux_term_at_0 = -a * u_left_neighbor_val\n        flux_term_at_N = a * u_self_right_val\n        \n        # Combine local contributions\n        rhs_e = vol_term\n        rhs_e[0] += flux_term_at_0\n        rhs_e[N] += flux_term_at_N\n        \n        # Place into global RHS vector\n        rhs[e * (N + 1):(e + 1) * (N + 1)] = rhs_e\n        \n    return rhs\n\ndef assemble_global_matrix(E, N, a, D, w):\n    \"\"\"\n    Assembles the global sparse matrix for the DG operator.\n    \"\"\"\n    dofs = E * (N + 1)\n    L_global = lil_matrix((dofs, dofs))\n\n    if np.isclose(a, 0.0):\n        return L_global.tocsr()\n\n    S_ref = D.T * w\n    local_op_block = -a * S_ref\n\n    for e in range(E):\n        start_idx = e * (N + 1)\n        end_idx = (e + 1) * (N + 1)\n        \n        # Add volume term (block diagonal part)\n        L_global[start_idx:end_idx, start_idx:end_idx] = local_op_block\n        \n        # Add flux terms (off-diagonal and diagonal-modifying part)\n        e_prev = (e - 1 + E) % E\n        \n        # Contribution from left neighbor to node j=0\n        row_idx_0 = start_idx\n        col_idx_neighbor = e_prev * (N + 1) + N\n        L_global[row_idx_0, col_idx_neighbor] += -a\n        \n        # Contribution from self to node j=N\n        row_idx_N = start_idx + N\n        col_idx_self = start_idx + N\n        L_global[row_idx_N, col_idx_self] += a\n        \n    return L_global.tocsr()\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compare operator implementations.\n    \"\"\"\n    test_cases = [\n        (1, 1, 1.0, 42, 3),\n        (4, 3, 1.0, 7, 5),\n        (8, 7, 0.5, 123, 4),\n        (10, 2, 0.0, 9, 2),\n        (3, 5, 2.0, 100, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, N, a, seed, R = case\n        \n        rel_diffs = []\n        \n        # Pre-compute DG basis components for the given degree N\n        nodes, weights = get_lgl_nodes_weights(N)\n        D = get_derivative_matrix(N, nodes)\n        \n        # Assemble the global sparse matrix for this test case\n        L_global = assemble_global_matrix(E, N, a, D, weights)\n        \n        # Use a reproducible random number generator for this case\n        rng = np.random.default_rng(seed)\n        \n        for _ in range(R):\n            U_rand = rng.random(E * (N + 1))\n            \n            y_free = matrix_free_operator(U_rand, E, N, a, D, weights)\n            y_mat = L_global @ U_rand\n            \n            diff_norm = np.linalg.norm(y_free - y_mat)\n            y_mat_norm = np.linalg.norm(y_mat)\n            \n            if y_mat_norm  1e-15:\n                rel_diff = diff_norm / y_mat_norm\n            else:\n                # If true result is zero vector, relative error is 0 if difference is also zero.\n                rel_diff = 0.0 if diff_norm  1e-15 else np.inf\n\n            rel_diffs.append(rel_diff)\n\n        results.append(max(rel_diffs))\n        \n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key strength of the Discontinuous Galerkin method lies in its handling of inter-element communication through numerical fluxes. After building a full operator, it is pedagogically vital to isolate and test this crucial component. This practice guides you to design a verification case that nullifies the volume integral term, allowing the boundary flux contributions to be studied in isolation . By comparing the computed residual against an exact analytical result, you will rigorously validate your implementation of the boundary treatment and explore its implications for the stability of the numerical scheme.",
            "id": "3398992",
            "problem": "Consider the one-dimensional linear advection equation $u_t + a u_x = 0$ posed on a single physical element of length $h$, with outward normals pointing to the left at the left boundary and to the right at the right boundary. Use a nodal Discontinuous Galerkin (DG) formulation on the reference interval $r \\in [-1,1]$ with a polynomial basis of degree $p$ constructed from Lagrange interpolants at Legendre-Gauss-Lobatto (LGL) nodes. The discretization must be implemented in a matrix-free fashion: compute the volume term by applying the differentiation matrix to nodal values, and compute boundary contributions by evaluating a consistent numerical flux and lifting it back to nodal degrees of freedom without assembling global matrices.\n\nFundamentally, start from the weak form of the conservation law and the canonical mapping between the reference and physical element, using the facts:\n- The mapping from the reference coordinate $r \\in [-1,1]$ to the physical coordinate $x$ is affine, with Jacobian $J = h/2$.\n- The Lagrange interpolant basis on LGL nodes has the Kronecker-delta property at the endpoints and yields a diagonal mass matrix under LGL quadrature.\n- The Summation By Parts (SBP) property holds for the LGL differentiation operator, ensuring interior consistency and boundary term representation via endpoint evaluations.\n- Use an upwind numerical flux at boundaries consistent with the sign of $a$.\n\nConstruct a verification case that isolates boundary contributions, by choosing trial fields for which the interior volume terms vanish exactly under the chosen collocation and quadrature, so any residual is attributable solely to the boundary treatment. Specifically, consider constant-in-element states so that the discrete volume derivative at LGL nodes is exactly zero. Use upwind inflow boundary data that differs from the interior state to generate non-zero boundary residuals at the inflow boundary only.\n\nImplement the following algorithmic components:\n- Compute $p+1$ LGL nodes and quadrature weights on $[-1,1]$ by solving for the roots of the derivative of the degree-$p$ Legendre polynomial and including endpoints, using Newton's method and exact Legendre polynomial identities.\n- Construct the differentiation matrix by barycentric interpolation formulas from the LGL nodes (do not assemble global matrices).\n- Assemble the matrix-free operator application that, for a given nodal vector $u$, advection speed $a$, element length $h$, and inflow boundary values, returns the semi-discrete residual at nodal points, composed of the volume term and the boundary flux contributions lifted to nodes.\n\nAccuracy assessment must compare the computed boundary residuals against analytically derived expectations in cases where the discrete volume term vanishes, and stability assessment must quantify an explicit time step restriction for the boundary-only homogeneous part of the operator under Forward Euler time integration. The Forward Euler method applied to a linear scalar ordinary differential equation $y'(t) = \\lambda y(t)$ is stable if and only if $|1 + \\Delta t \\lambda| \\le 1$ for real negative $\\lambda$.\n\nYour program must implement the operator and run the following test suite, returning the specified results:\n\n- Test Case A (happy path accuracy, positive advection):\n    - Parameters: $a = 1.0$, $p = 8$, $h = 1.0$, interior state $u(r) \\equiv 0.5$, left inflow value $u_{\\text{in},L} = 1.0$, right inflow value unused, consistent with upwind.\n    - Expectations: The interior residual entries must be zero to numerical precision; the left boundary residual must equal $(2/h)\\,a\\,(u_{\\text{in},L} - u_0)$, and the right boundary residual must be zero (outflow).\n    - Outputs:\n        1. The interior residual $\\ell^2$ norm over nodes $i = 1,\\dots,p-1$ as a float.\n        2. The absolute error at the left boundary node as a float.\n        3. The absolute error at the right boundary node as a float.\n\n- Test Case B (boundary neutrality, positive advection):\n    - Parameters: $a = 1.0$, $p = 12$, $h = 1.0$, interior state $u(r) \\equiv 0.3$, left inflow value $u_{\\text{in},L} = 0.3$, right inflow value unused.\n    - Expectations: All residual entries must be zero to numerical precision.\n    - Output:\n        4. The maximum absolute residual over all nodes as a float.\n\n- Test Case C (accuracy, negative advection):\n    - Parameters: $a = -2.0$, $p = 10$, $h = 0.5$, interior state $u(r) \\equiv 0.2$, right inflow value $u_{\\text{in},R} = 1.2$, left inflow value unused.\n    - Expectations: The interior residual entries must be zero; the right boundary residual must equal $(2/h)\\,a\\,(u_{\\text{in},R} - u_p)$ (note the sign from $a  0$), and the left boundary residual must be zero (outflow).\n    - Output:\n        5. The absolute error at the right boundary node as a float.\n\n- Test Case D (stability bound for homogeneous boundary operator, positive advection):\n    - Consider only the homogeneous boundary contribution at the inflow boundary for $a  0$, which, when isolated, acts as a linear scalar operator with eigenvalue $\\lambda = -(2/h)\\,a$ on the inflow boundary node.\n    - Parameters: $a = 3.0$, $h = 0.75$.\n    - Compute the critical Forward Euler step $\\Delta t_{\\max} = 2/|\\lambda| = h/a$, and test two time steps:\n        - $\\Delta t_{\\text{good}} = 0.9\\,\\Delta t_{\\max}$.\n        - $\\Delta t_{\\text{bad}} = 1.1\\,\\Delta t_{\\max}$.\n    - Outputs:\n        6. A boolean indicating that $\\Delta t_{\\text{good}}$ satisfies $|1 + \\Delta t_{\\text{good}} \\lambda| \\le 1$.\n        7. A boolean indicating that $\\Delta t_{\\text{bad}}$ violates $|1 + \\Delta t_{\\text{bad}} \\lambda| \\le 1$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6,result7]\"). The seven results must appear in the order defined above and be of types float, float, float, float, float, boolean, boolean, respectively. No physical units are required and no angles are used in this problem; all quantities are dimensionless.",
            "solution": "The starting point is the one-dimensional conservation law $u_t + a u_x = 0$ posed on a single element of physical length $h$. Let $r \\in [-1,1]$ denote the reference coordinate, with the affine mapping $x(r) = x_c + (h/2)\\,r$, so the Jacobian is $J = h/2$ and $u_x = (2/h)\\,u_r$.\n\nWe adopt a nodal Discontinuous Galerkin discretization with Lagrange interpolants built on the Legendre-Gauss-Lobatto (LGL) nodes $\\{r_i\\}_{i=0}^p$ of degree $p$. Let $\\{\\ell_i(r)\\}_{i=0}^p$ be the Lagrange basis functions satisfying $\\ell_i(r_j) = \\delta_{ij}$, and let $u(r) \\approx \\sum_{j=0}^p u_j \\ell_j(r)$ with nodal values $u_j = u(r_j)$. Under LGL collocation and quadrature, the mass matrix is diagonal, $M = \\operatorname{diag}(w_0,\\dots,w_p)$ with positive weights $\\{w_i\\}$, and the differentiation operator $D \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ satisfies the Summation By Parts (SBP) property:\n$$\nW D + D^\\top W = B, \\quad W = \\operatorname{diag}(w_0,\\dots,w_p), \\quad B = \\operatorname{diag}(-1, 0, \\dots, 0, 1),\n$$\nwhich ensures consistent representation of boundary terms through endpoint evaluations. Here $W$ is the mass matrix on the reference element and $B$ encodes endpoint contributions.\n\nStarting from the weak form on the reference element,\n$$\n\\int_{-1}^1 \\ell_i(r)\\,u_t(r,t)\\,dr + \\frac{a}{J} \\int_{-1}^1 \\ell_i'(r)\\,u(r,t)\\,dr - \\frac{a}{J}\\left[\\ell_i(r)\\,u(r,t)\\right]_{r=-1}^{r=1} = 0,\n$$\nwe replace the physical flux $a\\,u$ at boundaries with a numerical flux $g$ that is consistent and upwind with respect to the sign of $a$. Using LGL quadrature and exploiting the fact that $\\ell_i$ are interpolatory and that $\\ell_i(\\pm 1) = \\delta_{i,0}$ or $\\delta_{i,p}$ at endpoints, we obtain a semi-discrete system\n$$\nW\\,\\frac{d\\mathbf{u}}{dt} = -\\frac{a}{J}\\,W D\\,\\mathbf{u} + \\frac{a}{J}\\,\\left( \\mathbf{e}_0\\,u_L^{*} - \\mathbf{e}_p\\,u_R^{*} \\right),\n$$\nwhere $\\mathbf{u} = (u_0,\\dots,u_p)^\\top$, $\\mathbf{e}_0$ and $\\mathbf{e}_p$ are the standard basis vectors corresponding to the left and right endpoints, and $u_L^{*}$, $u_R^{*}$ denote the numerical flux states at the left and right boundaries, respectively. In a matrix-free strong form, dividing by $W$ component-wise reduces to the collocated residual\n$$\n\\mathbf{R}(\\mathbf{u}) = -\\frac{a}{J}\\,D\\,\\mathbf{u} + \\frac{a}{J}\\,\\left( \\mathbf{e}_0\\,(u_L^{*} - u_0) + \\mathbf{e}_p\\,(u_R^{*} - u_p) \\right),\n$$\nbecause the diagonal mass matrix cancels in the collocation at nodes when lifting endpoint contributions back to the degrees of freedom. This form is achieved algorithmically without assembling global matrices: the volume term is the application of $D$ to $\\mathbf{u}$, scaled by $(a/J)$, and the boundary contributions are two scalars added to the first and last entries of the residual.\n\nUpwind numerical flux for linear advection is determined by the sign of $a$. If $a  0$, the left boundary is inflow and the right boundary is outflow; we take $u_L^{*} = u_{\\text{in},L}$ and $u_R^{*} = u_p$. If $a  0$, the right boundary is inflow and the left boundary is outflow; we take $u_R^{*} = u_{\\text{in},R}$ and $u_L^{*} = u_0$. In both cases, consistency ensures that outflow uses the interior state at the boundary.\n\nTo isolate boundary contributions, we choose a constant interior state $u(r) \\equiv c$ on the element. At LGL nodes, this discretization yields exactly $D\\,\\mathbf{u} = \\mathbf{0}$ for the constant vector $\\mathbf{u} = (c,\\dots,c)^\\top$, by the exactness of the Lagrange interpolant on constants and the definition of $D$ as the derivative of the interpolant. Thus the residual collapses to\n$$\n\\mathbf{R}(\\mathbf{u}) = \\frac{a}{J}\\,\\left( \\mathbf{e}_0\\,(u_L^{*} - c) + \\mathbf{e}_p\\,(u_R^{*} - c) \\right).\n$$\nIn the case $a  0$ with $u_R^{*} = c$, only the left boundary node receives a non-zero contribution, $\\mathbf{R}_0 = \\frac{a}{J}(u_{\\text{in},L} - c)$ and $\\mathbf{R}_p = 0$. In the case $a  0$ with $u_L^{*} = c$, only the right boundary node receives a non-zero contribution, $\\mathbf{R}_p = \\frac{a}{J}(u_{\\text{in},R} - c)$ and $\\mathbf{R}_0 = 0$. Since $J = h/2$, these take the form\n$$\n\\mathbf{R}_0 = \\frac{2}{h}\\,a\\,(u_{\\text{in},L} - c) \\quad \\text{for } a  0,\\qquad\n\\mathbf{R}_p = \\frac{2}{h}\\,a\\,(u_{\\text{in},R} - c) \\quad \\text{for } a  0.\n$$\nThese expressions provide the analytic benchmark for accuracy assessment in the verification cases.\n\nFor stability assessment of the boundary-only homogeneous operator under Forward Euler, we consider the linear map that acts on the inflow boundary node in the $a  0$ case. With homogeneous inflow (i.e., no external injection), the boundary-only contribution reduces to a scalar ordinary differential equation on the inflow node,\n$$\n\\frac{d u_0}{dt} = \\lambda\\,u_0, \\quad \\lambda = -\\frac{2}{h}\\,a.\n$$\nFor Forward Euler, a step is bounded if $|1 + \\Delta t\\,\\lambda| \\le 1$ for real negative $\\lambda$, which yields the critical bound $\\Delta t_{\\max} = 2/|\\lambda| = h/a$. Choosing $\\Delta t_{\\text{good}} = 0.9\\,\\Delta t_{\\max}$ satisfies the bound, while $\\Delta t_{\\text{bad}} = 1.1\\,\\Delta t_{\\max}$ violates it.\n\nAlgorithmic implementation details:\n- Compute LGL nodes by solving for the $p-1$ interior roots of $P_p'(r)$ via Newton's method. Use the Legendre polynomial recurrence\n$$\nP_{k+1}(x) = \\frac{(2k+1)\\,x\\,P_k(x) - k\\,P_{k-1}(x)}{k+1}\n$$\nand the identities\n$$\nP_p'(x) = \\frac{p}{x^2 - 1}\\left(x\\,P_p(x) - P_{p-1}(x)\\right),\\qquad\nP_p''(x) = \\frac{2x\\,P_p'(x) - p(p+1)\\,P_p(x)}{1 - x^2}.\n$$\nInitialize Newton iterates at $x_k^{(0)} = \\cos\\left(\\frac{\\pi k}{p}\\right)$ for $k=1,\\dots,p-1$. Include endpoints $-1$ and $1$.\n- Compute LGL quadrature weights by\n$$\nw_i = \\frac{2}{p(p+1)\\,[P_p(r_i)]^2}.\n$$\n- Build the differentiation matrix $D$ by barycentric formulas: compute barycentric weights $\\beta_j = \\left(\\prod_{m\\ne j}(r_j - r_m)\\right)^{-1}$, then set\n$$\nD_{ij} = \\begin{cases}\n\\frac{\\beta_j}{\\beta_i}\\frac{1}{r_i - r_j},  i\\ne j,\\\\\n-\\sum_{m\\ne i} D_{im},  i=j.\n\\end{cases}\n$$\n- Apply the matrix-free operator by computing the volume term $-(a/J)D\\mathbf{u}$ and adding boundary contributions at nodes $0$ and $p$ using the upwind states, resulting in the residual $\\mathbf{R}$.\n\nThe test suite specified in the problem statement exercises:\n- Interior cancellation and left inflow accuracy for $a0$ (Test Case A).\n- Boundary neutrality when inflow equals interior (Test Case B).\n- Interior cancellation and right inflow accuracy for $a0$ (Test Case C).\n- Explicit Forward Euler stability bound for the homogeneous boundary-only operator in the $a0$ case (Test Case D).\n\nThe program computes:\n1. The $\\ell^2$ norm of interior residuals for Test Case A.\n2. The absolute error in the left boundary residual for Test Case A.\n3. The absolute error in the right boundary residual for Test Case A.\n4. The maximum absolute residual for Test Case B.\n5. The absolute error in the right boundary residual for Test Case C.\n6. A boolean for stability of $\\Delta t_{\\text{good}}$ in Test Case D.\n7. A boolean for instability of $\\Delta t_{\\text{bad}}$ in Test Case D.\n\nFinally, the program prints these seven results in a single line as a comma-separated list enclosed in square brackets, in the exact order described.",
            "answer": "```python\nimport numpy as np\nfrom math import cos, pi, sqrt\n\ndef legendre_and_prev(n, x):\n    \"\"\"\n    Compute P_n(x) and P_{n-1}(x) via recurrence.\n    \"\"\"\n    if n == 0:\n        return 1.0, 0.0\n    P_nm1 = 1.0\n    P_n = x\n    if n == 1:\n        return P_n, P_nm1\n    for k in range(1, n):\n        P_np1 = ((2*k + 1) * x * P_n - k * P_nm1) / (k + 1)\n        P_nm1, P_n = P_n, P_np1\n    return P_n, P_nm1\n\ndef legendre_derivatives(n, x):\n    \"\"\"\n    Compute P_n(x), P_n'(x), P_n''(x).\n    Uses identities:\n    P_n'(x) = n/(x^2 - 1) * (x P_n(x) - P_{n-1}(x))\n    P_n''(x) = (2 x P_n'(x) - n(n+1) P_n(x)) / (1 - x^2)\n    \"\"\"\n    Pn, Pnm1 = legendre_and_prev(n, x)\n    # Handle singularity at x = ±1 carefully: use limiting expressions.\n    # However, Newton iteration seeds avoid exactly ±1 for interior roots.\n    denom = x*x - 1.0\n    dp = n/denom * (x*Pn - Pnm1)\n    ddp = (2.0*x*dp - n*(n+1)*Pn) / (1.0 - x*x)\n    return Pn, dp, ddp\n\ndef lgl_nodes_weights(p, tol=1e-14, maxit=50):\n    \"\"\"\n    Compute LGL nodes and weights for polynomial degree p (p+1 nodes).\n    \"\"\"\n    # Endpoints\n    nodes = [-1.0]\n    # Interior nodes: roots of P_p'(x)\n    for k in range(1, p):\n        x = cos(pi * k / p)  # good initial guess\n        for _ in range(maxit):\n            Pn, dp, ddp = legendre_derivatives(p, x)\n            dx = -dp / ddp\n            x_new = x + dx\n            if abs(dx)  tol:\n                x = x_new\n                break\n            x = x_new\n        nodes.append(x)\n    nodes.append(1.0)\n    nodes = np.array(nodes)\n    # Weights: w_i = 2 / (p(p+1) [P_p(x_i)]^2)\n    weights = np.zeros(p+1)\n    for i, xi in enumerate(nodes):\n        Pn, _ = legendre_and_prev(p, xi)\n        weights[i] = 2.0 / (p * (p + 1) * (Pn**2))\n    return nodes, weights\n\ndef barycentric_weights(nodes):\n    \"\"\"\n    Compute barycentric weights for general nodes.\n    beta_j = 1 / prod_{m != j} (x_j - x_m)\n    \"\"\"\n    n = len(nodes)\n    beta = np.ones(n)\n    for j in range(n):\n        prod = 1.0\n        xj = nodes[j]\n        for m in range(n):\n            if m != j:\n                prod *= (xj - nodes[m])\n        beta[j] = 1.0 / prod\n    return beta\n\ndef differentiation_matrix(nodes):\n    \"\"\"\n    Construct differentiation matrix via barycentric formula.\n    D_ij = beta_j / beta_i / (x_i - x_j) for i != j\n    D_ii = -sum_{j != i} D_ij\n    \"\"\"\n    n = len(nodes)\n    beta = barycentric_weights(nodes)\n    D = np.zeros((n, n))\n    for i in range(n):\n        xi = nodes[i]\n        for j in range(n):\n            if i != j:\n                D[i, j] = beta[j] / beta[i] / (xi - nodes[j])\n        D[i, i] = -np.sum(D[i, np.arange(n) != i])\n    return D\n\ndef apply_matrix_free_operator(u, a, h, D, u_in_left=None, u_in_right=None):\n    \"\"\"\n    Apply the strong-form DG operator for 1D advection on a single element:\n    R = -(2/h) * a * D @ u + (2/h) * a * [e0*(u*_L - u0) + ep*(u*_R - up)]\n    Upwind flux selection:\n    - If a  0: u*_L = u_in_left, u*_R = u[-1] (outflow)\n    - If a  0: u*_L = u[0] (outflow), u*_R = u_in_right\n    \"\"\"\n    J_inv = 2.0 / h\n    R = -J_inv * a * (D @ u)\n    # Upwind flux\n    if a  0:\n        u_star_L = u_in_left if u_in_left is not None else u[0]\n        u_star_R = u[-1]\n    else:\n        u_star_L = u[0]\n        u_star_R = u_in_right if u_in_right is not None else u[-1]\n    # Boundary lift\n    R[0] += J_inv * a * (u_star_L - u[0])\n    R[-1] += J_inv * a * (u_star_R - u[-1])\n    return R\n\ndef solve():\n    results = []\n\n    # Test Case A: a=1.0, p=8, h=1.0, u=0.5, u_in_left=1.0\n    aA, pA, hA = 1.0, 8, 1.0\n    nodesA, weightsA = lgl_nodes_weights(pA)\n    DA = differentiation_matrix(nodesA)\n    uA = np.full(pA + 1, 0.5)\n    RA = apply_matrix_free_operator(uA, aA, hA, DA, u_in_left=1.0, u_in_right=None)\n    # Interior L2 norm\n    interiorA = RA[1:-1]\n    interior_L2 = float(np.linalg.norm(interiorA))\n    # Expected boundary residuals\n    expected_left_A = (2.0 / hA) * aA * (1.0 - uA[0])\n    expected_right_A = 0.0\n    err_left_A = float(abs(RA[0] - expected_left_A))\n    err_right_A = float(abs(RA[-1] - expected_right_A))\n    results.extend([interior_L2, err_left_A, err_right_A])\n\n    # Test Case B: a=1.0, p=12, h=1.0, u=0.3, u_in_left=0.3 - residual should be zero\n    aB, pB, hB = 1.0, 12, 1.0\n    nodesB, weightsB = lgl_nodes_weights(pB)\n    DB = differentiation_matrix(nodesB)\n    uB = np.full(pB + 1, 0.3)\n    RB = apply_matrix_free_operator(uB, aB, hB, DB, u_in_left=0.3, u_in_right=None)\n    maxabs_B = float(np.max(np.abs(RB)))\n    results.append(maxabs_B)\n\n    # Test Case C: a=-2.0, p=10, h=0.5, u=0.2, u_in_right=1.2\n    aC, pC, hC = -2.0, 10, 0.5\n    nodesC, weightsC = lgl_nodes_weights(pC)\n    DC = differentiation_matrix(nodesC)\n    uC = np.full(pC + 1, 0.2)\n    RC = apply_matrix_free_operator(uC, aC, hC, DC, u_in_left=None, u_in_right=1.2)\n    expected_right_C = (2.0 / hC) * aC * (1.2 - uC[-1])  # note a0\n    err_right_C = float(abs(RC[-1] - expected_right_C))\n    results.append(err_right_C)\n\n    # Test Case D: Stability for boundary-only homogeneous operator, a=3.0, h=0.75\n    aD, hD = 3.0, 0.75\n    lam = -(2.0 / hD) * aD  # eigenvalue at inflow boundary node\n    dt_max = hD / aD  # 2/|lam| simplifies to h/a\n    dt_good = 0.9 * dt_max\n    dt_bad = 1.1 * dt_max\n    amp_good = abs(1.0 + dt_good * lam)\n    amp_bad = abs(1.0 + dt_bad * lam)\n    stable_good = amp_good = 1.0\n    stable_bad = amp_bad  1.0\n    results.extend([stable_good, stable_bad])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The true power and flexibility of matrix-free, element-local operators become apparent in complex, dynamic simulations, such as those involving moving or deforming meshes. This advanced practice addresses the critical concept of free-stream preservation within an Arbitrary Lagrangian-Eulerian (ALE) framework. You will implement a high-order operator that must satisfy the Geometric Conservation Law (GCL) to ensure a constant flow field remains constant on a moving mesh . Successfully completing this exercise demonstrates a mastery of operator construction for time-dependent geometries, a cornerstone of advanced computational fluid dynamics.",
            "id": "3398913",
            "problem": "Consider the one-dimensional linear advection equation on a periodic domain with mesh motion in an Arbitrary Lagrangian-Eulerian (ALE) frame. The physical conservation law is given by $\\,\\partial_t u + a\\,\\partial_x u = 0\\,$ with constant advection speed $\\,a \\in \\mathbb{R}\\,$. Under a time-dependent mapping from the reference coordinate $\\,\\xi \\in [-1,1]\\,$ to the physical coordinate $\\,x(\\xi,t)\\,$ with Jacobian $\\,J(\\xi,t) = \\partial x / \\partial \\xi\\,$ and mesh velocity $\\,w(\\xi,t) = \\partial_t x(\\xi,t)\\,$, the ALE form in reference space is the conservative equation\n$$\n\\partial_t \\big(J(\\xi,t)\\,u(\\xi,t)\\big) + \\partial_\\xi \\big( F(u,w) \\big) = 0,\n$$\nwhere the ALE flux is $\\,F(u,w) = u\\,(a - w)\\,$. Free-stream preservation requires that an exact constant solution $\\,u(\\xi,t) \\equiv c\\,$ remain constant for all times if discretization and geometry treatment are consistent. In particular, the Geometric Conservation Law (GCL) states\n$$\n\\partial_t J(\\xi,t) - \\partial_\\xi w(\\xi,t) = 0,\n$$\nwhich must hold in the discrete sense for free-stream preservation.\n\nYou are to validate free-stream preservation in a matrix-free high-order Discontinuous Galerkin Spectral Element Method (DGSEM) by tracking an exact constant solution through the operator pipeline. Use Gauss-Lobatto-Legendre (GLL) nodes for interpolation and quadrature with the Summation-By-Parts (SBP) property, and a strong-form DGSEM discretization on each element. Do not assemble any global matrices; the implementation must apply elemental operators directly (matrix-free in the global sense). Angles in all trigonometric functions must be in radians.\n\nStarting from the fundamental base of conservation form, reference mapping, and the GCL:\n- Conservation law: $\\,\\partial_t u + \\partial_x f(u) = 0\\,$ with $\\,f(u) = a u\\,$.\n- ALE conservative form: $\\,\\partial_t(J u) + \\partial_\\xi \\big( u (a - w) \\big) = 0\\,$.\n- Geometric Conservation Law: $\\,\\partial_t J - \\partial_\\xi w = 0\\,$.\n- Discrete SBP property on GLL nodes and collocation.\n\nDiscretize the reference domain by $\\,E \\in \\mathbb{N}\\,$ elements, each isoparametrically mapped from $\\,\\xi \\in [-1,1]\\,$ to a global, periodic parametric coordinate $\\,s \\in [0,E]\\,$ via $\\,s = e + (\\xi+1)/2\\,$ for element index $\\,e \\in \\{0,1,\\dots,E-1\\}\\,$, and define a smooth periodic mesh motion through a global mapping $\\,x(s,t) = s + \\gamma \\sin\\!\\big(2\\pi s / E\\big)\\,\\sin(\\Omega t)\\,$ with amplitude $\\,\\gamma \\in \\mathbb{R}\\,$ and frequency $\\,\\Omega \\in \\mathbb{R}\\,$. The mesh velocity is $\\,w(s,t) = \\partial_t x(s,t) = \\gamma\\,\\Omega \\cos(\\Omega t)\\,\\sin\\!\\big(2\\pi s / E\\big)\\,$. The Jacobian with respect to $\\,\\xi\\,$ is $\\,J(\\xi,t) = \\big(\\partial x / \\partial s\\big) \\big(\\partial s / \\partial \\xi\\big) = \\frac{1}{2}\\Big(1 + \\frac{2\\pi \\gamma}{E}\\cos\\!\\big(2\\pi s / E\\big)\\,\\sin(\\Omega t)\\Big)\\,$; ensure $\\,J(\\xi,t)  0\\,$ by choosing $\\,\\gamma\\,$ sufficiently small for each test case.\n\nImplement the following:\n- Use $\\,N+1\\,$ GLL nodes per element with polynomial degree $\\,N \\in \\mathbb{N}\\,$. Let the GLL nodes be $\\,\\{\\xi_j\\}_{j=0}^N\\,$ with quadrature weights $\\,\\{w_j\\}_{j=0}^N\\,$ and derivative matrix $\\,D \\in \\mathbb{R}^{(N+1)\\times(N+1)}\\,$ satisfying the SBP property with GLL quadrature.\n- On each element, define the strong-form DGSEM operator for any nodal flux vector $\\,\\boldsymbol{F} \\in \\mathbb{R}^{N+1}\\,$ as\n$$\n\\mathcal{L}(\\boldsymbol{F})_j = -\\sum_{k=0}^{N} D_{jk}\\,F_k \\;+\\; \\frac{1}{w_j}\\,\\Big( \\delta_{j,N}\\,\\big(F^\\ast_{R} - F_{N}^- \\big)\\;-\\;\\delta_{j,0}\\,\\big(F^\\ast_{L} - F_{0}^- \\big) \\Big),\n$$\nwhere $\\,F^\\ast_{L}\\,$ and $\\,F^\\ast_{R}\\,$ are numerical fluxes at the left and right faces, and $\\,F_0^-\\,$ and $\\,F_N^-\\,$ are the interior face values at the left and right nodes respectively. For this validation, use a consistent central numerical flux for any interface quantity $\\,q\\,$ as $\\,q^\\ast = \\tfrac{1}{2}(q^- + q^+)\\,$ with periodic coupling between neighboring elements. For the ALE flux, use $\\,F = u\\,(a - w)\\,$, and for the GCL flux, use $\\,G = -w\\,$ such that $\\,\\partial_t J = \\mathcal{L}(\\boldsymbol{G})\\,$.\n- For a constant state $\\,u \\equiv c\\,$, compute the discrete free-stream residual vector\n$$\n\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} \\;-\\; \\mathcal{L}\\big(\\boldsymbol{F}(c,a,w)\\big),\n$$\nwhere $\\,\\partial_t \\boldsymbol{J}\\,$ is approximated by applying the same DGSEM operator to $\\,\\boldsymbol{G} = -\\boldsymbol{w}\\,$, and $\\,\\boldsymbol{F}(c,a,w)\\,$ uses the nodal values of $\\,w\\,$. The free-stream is discretely preserved if $\\,\\|\\boldsymbol{R}\\|_\\infty\\,$ is small to round-off.\n\nYour task is to write a complete, runnable program that:\n- Constructs GLL nodes, weights, and derivative matrix for given $\\,N\\,$.\n- Implements the matrix-free DGSEM strong operator on each element with periodic coupling.\n- Evaluates the global mesh velocity $\\,w(s,t)\\,$ at all nodes and element faces, using angles in radians.\n- Computes the maximum absolute value of $\\,\\boldsymbol{R}\\,$ over all elements and nodes for each parameter set listed in the test suite below.\n\nTest Suite and Answer Specification:\n- Use frequency $\\,\\Omega = 1\\,$ in all test cases.\n- The parameter tuple is $\\,\\big(E,N,a,\\gamma,t,c\\big)\\,$. Use the following five cases:\n    - Case $\\,1$: $\\,E=3\\,$, $\\,N=5\\,$, $\\,a=1.0\\,$, $\\,\\gamma=0.15\\,$, $\\,t=0.37\\,$, $\\,c=2.0\\,$.\n    - Case $\\,2$: $\\,E=4\\,$, $\\,N=10\\,$, $\\,a=0.7\\,$, $\\,\\gamma=0.05\\,$, $\\,t=2.1\\,$, $\\,c=-1.0\\,$.\n    - Case $\\,3$: $\\,E=2\\,$, $\\,N=7\\,$, $\\,a=-0.5\\,$, $\\,\\gamma=0.0\\,$, $\\,t=1.23\\,$, $\\,c=1.0\\,$.\n    - Case $\\,4$: $\\,E=5\\,$, $\\,N=3\\,$, $\\,a=0.0\\,$, $\\,\\gamma=0.1\\,$, $\\,t=1.7\\,$, $\\,c=3.3\\,$.\n    - Case $\\,5$: $\\,E=1\\,$, $\\,N=1\\,$, $\\,a=1.0\\,$, $\\,\\gamma=0.02\\,$, $\\,t=3.14\\,$, $\\,c=1.0\\,$.\n- For each case, compute the scalar $\\,r = \\|\\boldsymbol{R}\\|_\\infty\\,$ as a floating-point number. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$).\n\nEnsure scientific realism by keeping $\\,\\gamma\\,$ small enough that $\\,J(\\xi,t)  0\\,$ in all cases. No physical units are required in the output. All trigonometric angles must be in radians. The output must be deterministic and not rely on any user input.",
            "solution": "The problem requires the validation of free-stream preservation for a one-dimensional linear advection equation discretized using a matrix-free high-order Discontinuous Galerkin Spectral Element Method (DGSEM) in an Arbitrary Lagrangian-Eulerian (ALE) framework. Free-stream preservation is a fundamental property of a numerical scheme, ensuring that a constant initial state remains constant over time, even on a moving or deforming mesh. Failure to preserve the free-stream introduces spurious sources or sinks, violating the basic physics of uniform flow.\n\nThe validation is performed by computing a discrete residual for a constant solution, $u(\\xi,t) = c$. If the scheme is consistent, this residual should be zero up to floating-point precision. The core of this property lies in the exact discrete cancellation of terms arising from the physical conservation law and the geometric conservation law (GCL).\n\nWe begin with the physical conservation law for advection, $\\partial_t u + a\\,\\partial_x u = 0$. Transforming this to a reference coordinate system $\\xi$ under a time-dependent mapping $x(\\xi,t)$ yields the conservative ALE form:\n$$\n\\partial_t \\big(J u\\big) + \\partial_\\xi \\big( u (a - w) \\big) = 0\n$$\nwhere $J = \\partial x / \\partial \\xi$ is the Jacobian and $w = \\partial_t x$ is the mesh velocity. This equation can be expanded using the product rule:\n$$\nu\\,\\partial_t J + J\\,\\partial_t u + \\partial_\\xi \\big( u (a - w) \\big) = 0\n$$\nFor a constant solution $u \\equiv c$, the term $J\\,\\partial_t u$ vanishes. The equation simplifies to:\n$$\nc\\,\\partial_t J + \\partial_\\xi \\big( c (a - w) \\big) = 0\n$$\nFree-stream preservation hinges on the Geometric Conservation Law (GCL), which arises from the commutation of partial derivatives, $\\partial_t (\\partial_\\xi x) = \\partial_\\xi (\\partial_t x)$, leading to:\n$$\n\\partial_t J - \\partial_\\xi w = 0 \\quad \\text{or} \\quad \\partial_t J = \\partial_\\xi w\n$$\nSubstituting $\\partial_t J = \\partial_\\xi w$ into the simplified ALE equation for a constant state gives:\n$$\nc\\,(\\partial_\\xi w) + \\partial_\\xi \\big( c (a - w) \\big) = c\\,\\partial_\\xi w + c\\,\\partial_\\xi a - c\\,\\partial_\\xi w = 0\n$$\nThis shows that the continuous equations are consistent. The crux of the problem is to verify that the chosen DGSEM discretization preserves this cancellation.\n\nThe DGSEM discretization is performed on $E$ elements, each mapped from the reference domain $\\xi \\in [-1,1]$. Within each element, the solution and geometry are represented by polynomials of degree $N$ at $N+1$ Gauss-Lobatto-Legendre (GLL) nodes. The spatial derivative operator is approximated by the strong-form DGSEM operator $\\mathcal{L}$, which combines an interior derivative (using a Summation-By-Parts derivative matrix $\\boldsymbol{D}$) with numerical fluxes at element interfaces. For a nodal flux vector $\\boldsymbol{F}$, the operator is:\n$$\n\\mathcal{L}(\\boldsymbol{F})_j = -\\sum_{k=0}^{N} D_{jk}\\,F_k \\;+\\; \\frac{1}{w_j}\\,\\Big( \\delta_{j,N}\\,\\big(F^\\ast_{R} - F_{N}^- \\big)\\;-\\;\\delta_{j,0}\\,\\big(F^\\ast_{L} - F_{0}^- \\big) \\Big)\n$$\nThis operator approximates $-\\partial_\\xi \\boldsymbol{F}$. A key property of the GLL-based derivative matrix $\\boldsymbol{D}$ is that it annihilates constant vectors, i.e., $\\boldsymbol{D}\\boldsymbol{1} = \\boldsymbol{0}$. Furthermore, for a globally constant flux, the numerical flux $F^\\ast$ equals the interior flux $F^-$, causing the boundary terms to vanish. Consequently, $\\mathcal{L}(\\text{constant}) = \\boldsymbol{0}$.\n\nThe problem defines a consistent discrete GCL. The continuous GCL $\\partial_t J = \\partial_\\xi w$ is discretized as:\n$$\n\\partial_t \\boldsymbol{J} = \\mathcal{L}(\\boldsymbol{G}) \\quad \\text{with GCL flux } \\boldsymbol{G} = -\\boldsymbol{w}\n$$\nThis is consistent because $\\mathcal{L}(\\boldsymbol{G}) = \\mathcal{L}(-\\boldsymbol{w})$ approximates $-\\partial_\\xi(-\\boldsymbol{w}) = \\partial_\\xi \\boldsymbol{w}$.\n\nThe discrete free-stream residual vector $\\boldsymbol{R}$ is defined as the discrete version of $c\\,\\partial_t J + \\partial_\\xi (c(a-w)) = 0$. Since $\\mathcal{L}$ approximates $-\\partial_\\xi$, the corresponding discrete expression is:\n$$\n\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} - \\mathcal{L}\\big(\\boldsymbol{F}(c,a,w)\\big)\n$$\nwhere $\\boldsymbol{F}(c,a,w)$ is the nodal vector of the ALE flux $u(a-w)$ with $u=c$.\nNow, we substitute the discrete GCL and the ALE flux into the residual expression:\n$$\n\\boldsymbol{R} = c\\,\\mathcal{L}(-\\boldsymbol{w}) - \\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big)\n$$\nThe operator $\\mathcal{L}$ is linear in its flux argument. Thus:\n$$\n\\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big) = \\mathcal{L}(ca - c\\boldsymbol{w}) = \\mathcal{L}(ca) - \\mathcal{L}(c\\boldsymbol{w})\n$$\nSince $ca$ is a constant, $\\mathcal{L}(ca) = \\boldsymbol{0}$. Therefore, $\\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big) = -\\mathcal{L}(c\\boldsymbol{w})$.\nThe residual becomes:\n$$\n\\boldsymbol{R} = c\\,\\mathcal{L}(-\\boldsymbol{w}) - \\big( -\\mathcal{L}(c\\boldsymbol{w}) \\big) = -c\\,\\mathcal{L}(\\boldsymbol{w}) + c\\,\\mathcal{L}(\\boldsymbol{w}) = \\boldsymbol{0}\n$$\nThe algebraic cancellation holds exactly for the discrete operators. The numerical implementation should therefore yield a residual norm $\\|\\boldsymbol{R}\\|_\\infty$ that is on the order of machine floating-point precision.\n\nThe implementation plan is as follows:\n1.  For a given polynomial degree $N$, generate the $N+1$ GLL nodes $\\xi_j$, quadrature weights $w_j$, and the $(N+1) \\times (N+1)$ SBP derivative matrix $\\boldsymbol{D}$. The nodes are the extrema of the Legendre polynomial $P_N(x)$ in $[-1,1]$, and the weights and derivative matrix are computed from standard formulae.\n2.  For each test case, define the grid of $E$ elements. Compute the global parametric coordinate $s_{ej} = e + (\\xi_j+1)/2$ for each node $j$ on each element $e$.\n3.  Evaluate the nodal mesh velocity vector $\\boldsymbol{w}$ across all elements using the provided formula: $w(s,t) = \\gamma\\,\\Omega \\cos(\\Omega t)\\,\\sin(2\\pi s / E)$.\n4.  Implement the matrix-free operator $\\mathcal{L}$. This function takes a global flux vector (an $E \\times (N+1)$ array) and returns the result of the operator application. It computes the volume term via matrix-vector products on each element and adds the surface correction terms using central fluxes and periodic boundary conditions.\n5.  Compute the discrete time derivative of the Jacobian, $\\partial_t \\boldsymbol{J} = \\mathcal{L}(-\\boldsymbol{w})$.\n6.  Compute the discrete divergence of the ALE flux, $\\mathcal{L}(\\boldsymbol{F}) = \\mathcal{L}(c(a - \\boldsymbol{w}))$.\n7.  Combine these to form the residual vector $\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} - \\mathcal{L}(\\boldsymbol{F})$.\n8.  Finally, compute the infinity norm of the global residual vector, $\\|\\boldsymbol{R}\\|_\\infty$, for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre, roots_jacobi\n\ndef get_gll_data(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes, weights, and derivative matrix.\n\n    Args:\n        N (int): Polynomial degree.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]:\n            - xi: GLL nodes of size (N+1).\n            - w: GLL quadrature weights of size (N+1).\n            - D: GLL derivative matrix of size (N+1, N+1).\n    \"\"\"\n    if not isinstance(N, int) or N  1:\n        raise ValueError(\"Polynomial degree N must be an integer = 1.\")\n\n    if N == 1:\n        xi = np.array([-1.0, 1.0])\n        w = np.array([1.0, 1.0])\n        D = np.array([[-0.5, 0.5], [-0.5, 0.5]])\n        return xi, w, D\n\n    # GLL nodes are roots of (1-x^2) * P_N'(x).\n    # The inner nodes are roots of P_N'(x), which are roots of the\n    # Jacobi polynomial P_{N-1}^{(1,1)}(x).\n    inner_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    xi = np.concatenate(([-1.0], inner_nodes, [1.0]))\n\n    # Quadrature weights: w_j = 2 / (N(N+1) * P_N(xi_j)^2)\n    p_N_at_xi = eval_legendre(N, xi)\n    w = 2.0 / (N * (N + 1) * p_N_at_xi**2)\n\n    # Derivative matrix D\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = (p_N_at_xi[i] / p_N_at_xi[j]) / (xi[i] - xi[j])\n            elif i == 0:\n                D[i, i] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[i, i] = N * (N + 1) / 4.0\n            else:  # diagonal, 0  i  N\n                D[i, i] = 0.0\n    return xi, w, D\n\ndef apply_L_operator(flux_global, E, N, D, w_gll):\n    \"\"\"\n    Applies the strong-form DGSEM operator L to a global flux vector.\n\n    Args:\n        flux_global (np.ndarray): Nodal flux values, shape (E, N+1).\n        E (int): Number of elements.\n        N (int): Polynomial degree.\n        D (np.ndarray): Derivative matrix, shape (N+1, N+1).\n        w_gll (np.ndarray): GLL weights, shape (N+1).\n\n    Returns:\n        np.ndarray: Result of operator application, shape (E, N+1).\n    \"\"\"\n    result_global = np.zeros_like(flux_global)\n\n    # Volume integral term: -D * F_e for each element e\n    # This is equivalent to `result_global = -flux_global @ D.T`\n    result_global = -np.einsum('ij,kj-ki', D, flux_global)\n\n    # Surface integral term (boundary corrections)\n    if N  0:\n        inv_w0 = 1.0 / w_gll[0]\n        inv_wN = 1.0 / w_gll[N]\n\n        for e in range(E):\n            # Left face (at node 0)\n            e_left = (e - 1 + E) % E\n            F_minus_L = flux_global[e, 0]\n            F_plus_L = flux_global[e_left, N]  # from right face of left neighbor\n            F_star_L = 0.5 * (F_minus_L + F_plus_L)\n            result_global[e, 0] += -inv_w0 * (F_star_L - F_minus_L)\n\n            # Right face (at node N)\n            e_right = (e + 1) % E\n            F_minus_R = flux_global[e, N]\n            F_plus_R = flux_global[e_right, 0] # from left face of right neighbor\n            F_star_R = 0.5 * (F_minus_R + F_plus_R)\n            result_global[e, N] += inv_wN * (F_star_R - F_minus_R)\n\n    return result_global\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute free-stream residuals.\n    \"\"\"\n    # Test cases: (E, N, a, gamma, t, c)\n    test_cases = [\n        (3, 5, 1.0, 0.15, 0.37, 2.0),\n        (4, 10, 0.7, 0.05, 2.1, -1.0),\n        (2, 7, -0.5, 0.0, 1.23, 1.0),\n        (5, 3, 0.0, 0.1, 1.7, 3.3),\n        (1, 1, 1.0, 0.02, 3.14, 1.0),\n    ]\n\n    results = []\n    Omega = 1.0\n\n    for case in test_cases:\n        E, N, a, gamma, t, c = case\n\n        # 1. Get GLL data (nodes, weights, derivative matrix)\n        xi_nodes, w_gll, D = get_gll_data(N)\n\n        # 2. Set up geometry and compute mesh velocity\n        s_global = np.zeros((E, N + 1))\n        for e in range(E):\n            s_global[e, :] = e + (xi_nodes + 1.0) / 2.0\n        \n        # Check Jacobian positivity\n        # J_min = 0.5 * (1 - 2*pi*|gamma|/E). Must be  0.\n        # This is equivalent to |gamma|  E / (2*pi).\n        if np.abs(gamma) * 2.0 * np.pi = E:\n            # This check is for robustness; problem statement confirms validity.\n            raise ValueError(f\"Jacobian may not be positive for case {case}\")\n\n        w_mesh_global = gamma * Omega * np.cos(Omega * t) * np.sin(2.0 * np.pi * s_global / E)\n\n        # 3. Compute discrete GCL term: dt_J = L(-w)\n        G_global = -w_mesh_global\n        dt_J_global = apply_L_operator(G_global, E, N, D, w_gll)\n\n        # 4. Compute discrete ALE flux term: L(F) = L(c*(a-w))\n        F_global = c * (a - w_mesh_global)\n        L_F_global = apply_L_operator(F_global, E, N, D, w_gll)\n        \n        # 5. Compute the residual vector: R = c*dt_J - L(F)\n        # As derived, this should be close to zero.\n        R_global = c * dt_J_global - L_F_global\n        \n        # 6. Compute the infinity norm of the residual\n        r = np.max(np.abs(R_global))\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.16e}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}