{
    "hands_on_practices": [
        {
            "introduction": "The core action of a limiter is to modify the local polynomial solution to restore physical properties, such as positivity or monotonicity. This exercise provides a step-by-step walkthrough of a hierarchical moment limiter, a common approach in Discontinuous Galerkin (DG) methods. By sequentially adjusting modal coefficients from the highest degree downwards, you will see how to enforce solution bounds at element interfaces, gaining a concrete understanding of the limiter's mechanism.",
            "id": "3400905",
            "problem": "Consider one space dimension and a single element of a Discontinuous Galerkin (DG) discretization mapped to the reference interval $\\xi \\in [-1,1]$. Let the local DG approximation be expanded in the standard Legendre polynomial basis $\\{P_{0}(\\xi),P_{1}(\\xi),P_{2}(\\xi),P_{3}(\\xi)\\}$:\n$$\nu_{i}(\\xi) \\;=\\; a_{0} P_{0}(\\xi) \\;+\\; a_{1} P_{1}(\\xi) \\;+\\; a_{2} P_{2}(\\xi) \\;+\\; a_{3} P_{3}(\\xi),\n$$\nwith modal vector $(a_{0},a_{1},a_{2},a_{3})$. Assume $P_{0}(\\xi)=1$, $P_{1}(\\xi)=\\xi$, $P_{2}(\\xi)=\\frac{3\\xi^{2}-1}{2}$, and $P_{3}(\\xi)=\\frac{5\\xi^{3}-3\\xi}{2}$, so that $P_{k}(1)=1$ for all $k$ and $P_{k}(-1)=(-1)^{k}$. The cell average equals $a_{0}$ because $\\int_{-1}^{1} P_{k}(\\xi)\\,\\mathrm{d}\\xi=0$ for $k\\ge 1$ and $\\int_{-1}^{1} P_{0}(\\xi)\\,\\mathrm{d}\\xi=2$.\n\nYou are given the degree-$3$ modal vector\n$$\n(a_{0},a_{1},a_{2},a_{3}) \\;=\\; (0.9,\\,0.2,\\,0.1,\\,0.15),\n$$\nand the neighbor cell averages (means)\n$$\n\\bar{u}_{i-1} \\;=\\; 0.6, \\qquad \\bar{u}_{i+1} \\;=\\; 1.1.\n$$\nDefine the admissible bounds for the right interface (at $\\xi=+1$) by\n$$\nL^{+} \\;=\\; \\min\\{\\bar{u}_{i},\\bar{u}_{i+1}\\} \\;=\\; \\min\\{a_{0},\\bar{u}_{i+1}\\}, \\qquad U^{+} \\;=\\; \\max\\{\\bar{u}_{i},\\bar{u}_{i+1}\\} \\;=\\; \\max\\{a_{0},\\bar{u}_{i+1}\\},\n$$\nand for the left interface (at $\\xi=-1$) by\n$$\nL^{-} \\;=\\; \\min\\{\\bar{u}_{i-1},\\bar{u}_{i}\\} \\;=\\; \\min\\{\\bar{u}_{i-1},a_{0}\\}, \\qquad U^{-} \\;=\\; \\max\\{\\bar{u}_{i-1},\\bar{u}_{i}\\} \\;=\\; \\max\\{\\bar{u}_{i-1},a_{0}\\}.\n$$\n\nApply a hierarchical moment limiter in the spirit of Krivodonova’s approach that enforces the interface bounds at $\\xi=\\pm 1$ as follows. For $k=3,2,1$, update $a_{k}$ while keeping all other coefficients fixed at their current values. Let $S_{+}^{\\neq k}$ denote the contribution to $u_{i}(+1)$ from all modes except $a_{k}$, and $S_{-}^{\\neq k}$ denote the contribution to $u_{i}(-1)$ from all modes except $a_{k}$, that is,\n$$\nS_{+}^{\\neq k} \\;=\\; \\sum_{m\\neq k} a_{m} P_{m}(1), \\qquad S_{-}^{\\neq k} \\;=\\; \\sum_{m\\neq k} a_{m} P_{m}(-1).\n$$\nCompute the admissible interval for $a_{k}$ from the right interface,\n$$\nI_{k}^{+} \\;=\\; \\left[\\,L^{+} - S_{+}^{\\neq k},\\; U^{+} - S_{+}^{\\neq k}\\,\\right],\n$$\nand from the left interface, using $P_{k}(-1)=(-1)^{k}$,\n$$\nI_{k}^{-} \\;=\\; \\left\\{ a_{k}\\in\\mathbb{R} \\;:\\; L^{-} \\le S_{-}^{\\neq k} + a_{k} P_{k}(-1) \\le U^{-} \\right\\}.\n$$\nEquivalently,\n$$\nI_{k}^{-} \\;=\\; \\begin{cases}\n\\left[\\,L^{-} - S_{-}^{\\neq k},\\; U^{-} - S_{-}^{\\neq k}\\,\\right],  \\text{if } P_{k}(-1)=+1, \\\\\n\\left[\\,S_{-}^{\\neq k} - U^{-},\\; S_{-}^{\\neq k} - L^{-}\\,\\right],  \\text{if } P_{k}(-1)=-1.\n\\end{cases}\n$$\nSet the limited coefficient\n$$\na_{k}^{\\text{lim}} \\;=\\; \\operatorname{clamp}\\!\\left( a_{k},\\; I_{k}^{+} \\cap I_{k}^{-} \\right),\n$$\nwhere $\\operatorname{clamp}(x,[\\ell,u])=\\min\\{\\max\\{x,\\ell\\},u\\}$ and the intersection $I_{k}^{+}\\cap I_{k}^{-}$ is assumed nonempty in this setting. Proceed hierarchically from $k=3$ down to $k=1$, updating $a_{k}$ in place at each step. Do not change $a_{0}$.\n\nCompute the limited modal vector $(a_{0}^{\\text{lim}},a_{1}^{\\text{lim}},a_{2}^{\\text{lim}},a_{3}^{\\text{lim}})$ produced by this hierarchical limiter. Provide your final answer as the vector of limited coefficients. If any arithmetic leads to multiple candidate values, select the unique value in the specified intersection. No rounding is required.",
            "solution": "The problem is first validated. The problem statement provides a clear, self-contained, and scientifically grounded description of a hierarchical moment limiting procedure used in Discontinuous Galerkin methods. All required data, definitions, and constraints are provided. The procedure is algorithmically deterministic and well-posed. There are no contradictions, ambiguities, or violations of scientific principles. Therefore, the problem is deemed valid and a solution will be furnished.\n\nThe objective is to compute the limited modal vector $(a_{0}^{\\text{lim}}, a_{1}^{\\text{lim}}, a_{2}^{\\text{lim}}, a_{3}^{\\text{lim}})$ by applying a hierarchical moment limiter to the initial modal vector $(a_{0}, a_{1}, a_{2}, a_{3}) = (0.9, 0.2, 0.1, 0.15)$. The limiter proceeds sequentially from the highest-order mode, $k=3$, down to $k=1$, updating the coefficients in place. The zeroth mode, $a_{0}$, which represents the cell average, remains unchanged.\n\nFirst, we establish the admissible bounds for the solution at the element interfaces, $\\xi=+1$ and $\\xi=-1$. The given data are:\n-   Cell average: $\\bar{u}_{i} = a_{0} = 0.9$.\n-   Left neighbor cell average: $\\bar{u}_{i-1} = 0.6$.\n-   Right neighbor cell average: $\\bar{u}_{i+1} = 1.1$.\n\nThe bounds for the right interface ($\\xi=+1$) are:\n$$\nL^{+} = \\min\\{a_{0}, \\bar{u}_{i+1}\\} = \\min\\{0.9, 1.1\\} = 0.9\n$$\n$$\nU^{+} = \\max\\{a_{0}, \\bar{u}_{i+1}\\} = \\max\\{0.9, 1.1\\} = 1.1\n$$\nSo, the solution at $\\xi=+1$ must lie in the interval $[0.9, 1.1]$.\n\nThe bounds for the left interface ($\\xi=-1$) are:\n$$\nL^{-} = \\min\\{\\bar{u}_{i-1}, a_{0}\\} = \\min\\{0.6, 0.9\\} = 0.6\n$$\n$$\nU^{-} = \\max\\{\\bar{u}_{i-1}, a_{0}\\} = \\max\\{0.6, 0.9\\} = 0.9\n$$\nSo, the solution at $\\xi=-1$ must lie in the interval $[0.6, 0.9]$.\n\nThe Legendre polynomials evaluate at the interfaces as $P_{k}(1) = 1$ and $P_{k}(-1) = (-1)^{k}$. The hierarchical limiting process begins with the initial modal vector $(a_{0}, a_{1}, a_{2}, a_{3}) = (0.9, 0.2, 0.1, 0.15)$.\n\n**Step 1: Limiting $a_{3}$ (for $k=3$)**\n\nThe current modal vector is $(0.9, 0.2, 0.1, 0.15)$. We limit $a_{3} = 0.15$.\nThe sums of contributions from other modes at the interfaces are:\n$$\nS_{+}^{\\neq 3} = \\sum_{m=0}^{2} a_{m} P_{m}(1) = a_{0} + a_{1} + a_{2} = 0.9 + 0.2 + 0.1 = 1.2\n$$\n$$\nS_{-}^{\\neq 3} = \\sum_{m=0}^{2} a_{m} P_{m}(-1) = a_{0} P_{0}(-1) + a_{1} P_{1}(-1) + a_{2} P_{2}(-1) = a_{0} - a_{1} + a_{2} = 0.9 - 0.2 + 0.1 = 0.8\n$$\nThe value of the solution at the interfaces is $u_{i}(1) = S_{+}^{\\neq 3} + a_{3} P_{3}(1) = 1.2 + a_{3}$ and $u_{i}(-1) = S_{-}^{\\neq 3} + a_{3} P_{3}(-1) = 0.8 - a_{3}$.\n\nThe admissible interval for $a_{3}$ from the right interface constraint, $L^{+} \\le u_{i}(1) \\le U^{+}$, is:\n$$\n0.9 \\le 1.2 + a_{3} \\le 1.1 \\implies -0.3 \\le a_{3} \\le -0.1\n$$\nThus, $I_{3}^{+} = [-0.3, -0.1]$.\n\nThe admissible interval for $a_{3}$ from the left interface constraint, $L^{-} \\le u_{i}(-1) \\le U^{-}$, is:\n$$\n0.6 \\le 0.8 - a_{3} \\le 0.9 \\implies -0.2 \\le -a_{3} \\le 0.1 \\implies -0.1 \\le a_{3} \\le 0.2\n$$\nThus, $I_{3}^{-} = [-0.1, 0.2]$.\n\nThe intersection of these intervals is $I_{3} = I_{3}^{+} \\cap I_{3}^{-} = [-0.3, -0.1] \\cap [-0.1, 0.2] = \\{-0.1\\}$.\nThe limited coefficient $a_{3}^{\\text{lim}}$ is found by clamping the original value $a_{3}=0.15$ to this interval:\n$$\na_{3}^{\\text{lim}} = \\operatorname{clamp}(0.15, [-0.1, -0.1]) = -0.1\n$$\nThe modal vector is updated to $(0.9, 0.2, 0.1, -0.1)$.\n\n**Step 2: Limiting $a_{2}$ (for $k=2$)**\n\nThe current modal vector is $(0.9, 0.2, 0.1, -0.1)$. We limit $a_{2} = 0.1$. The other coefficients, including the newly limited $a_{3}^{\\text{lim}}$, are held fixed.\nThe sums of contributions from other modes are:\n$$\nS_{+}^{\\neq 2} = a_{0} + a_{1} + a_{3} = 0.9 + 0.2 + (-0.1) = 1.0\n$$\n$$\nS_{-}^{\\neq 2} = a_{0} - a_{1} - a_{3} = 0.9 - 0.2 - (-0.1) = 0.8\n$$\nThe value of the solution at the interfaces is $u_{i}(1) = S_{+}^{\\neq 2} + a_{2}$ and $u_{i}(-1) = S_{-}^{\\neq 2} + a_{2}$ since $P_{2}(-1) = 1$.\n\nThe interval for $a_{2}$ from the right interface is:\n$$\n0.9 \\le 1.0 + a_{2} \\le 1.1 \\implies -0.1 \\le a_{2} \\le 0.1\n$$\nThus, $I_{2}^{+} = [-0.1, 0.1]$.\n\nThe interval for $a_{2}$ from the left interface is:\n$$\n0.6 \\le 0.8 + a_{2} \\le 0.9 \\implies -0.2 \\le a_{2} \\le 0.1\n$$\nThus, $I_{2}^{-} = [-0.2, 0.1]$.\n\nThe intersection is $I_{2} = I_{2}^{+} \\cap I_{2}^{-} = [-0.1, 0.1] \\cap [-0.2, 0.1] = [-0.1, 0.1]$.\nThe limited coefficient $a_{2}^{\\text{lim}}$ is:\n$$\na_{2}^{\\text{lim}} = \\operatorname{clamp}(0.1, [-0.1, 0.1]) = 0.1\n$$\nThe original value $a_{2}=0.1$ is already within the admissible interval, so it remains unchanged. The modal vector is still $(0.9, 0.2, 0.1, -0.1)$.\n\n**Step 3: Limiting $a_{1}$ (for $k=1$)**\n\nThe current modal vector is $(0.9, 0.2, 0.1, -0.1)$. We limit $a_{1} = 0.2$.\nThe sums of contributions from other modes are:\n$$\nS_{+}^{\\neq 1} = a_{0} + a_{2} + a_{3} = 0.9 + 0.1 + (-0.1) = 0.9\n$$\n$$\nS_{-}^{\\neq 1} = a_{0} + a_{2} - a_{3} = 0.9 + 0.1 - (-0.1) = 1.1\n$$\nThe value of the solution at the interfaces is $u_{i}(1) = S_{+}^{\\neq 1} + a_{1}$ and $u_{i}(-1) = S_{-}^{\\neq 1} - a_{1}$ since $P_{1}(-1) = -1$.\n\nThe interval for $a_{1}$ from the right interface is:\n$$\n0.9 \\le 0.9 + a_{1} \\le 1.1 \\implies 0 \\le a_{1} \\le 0.2\n$$\nThus, $I_{1}^{+} = [0, 0.2]$.\n\nThe interval for $a_{1}$ from the left interface is:\n$$\n0.6 \\le 1.1 - a_{1} \\le 0.9 \\implies -0.5 \\le -a_{1} \\le -0.2 \\implies 0.2 \\le a_{1} \\le 0.5\n$$\nThus, $I_{1}^{-} = [0.2, 0.5]$.\n\nThe intersection is $I_{1} = I_{1}^{+} \\cap I_{1}^{-} = [0, 0.2] \\cap [0.2, 0.5] = \\{0.2\\}$.\nThe limited coefficient $a_{1}^{\\text{lim}}$ is:\n$$\na_{1}^{\\text{lim}} = \\operatorname{clamp}(0.2, [0.2, 0.2]) = 0.2\n$$\nThe original value $a_{1}=0.2$ is already at the boundary of the admissible interval, so it remains unchanged. The modal vector is still $(0.9, 0.2, 0.1, -0.1)$.\n\nThe coefficient $a_{0}$ is unchanged by definition. Thus, $a_{0}^{\\text{lim}}=0.9$.\nThe final limited modal vector is $(a_{0}^{\\text{lim}}, a_{1}^{\\text{lim}}, a_{2}^{\\text{lim}}, a_{3}^{\\text{lim}})$.\nAssembling the results:\n$a_{0}^{\\text{lim}} = 0.9$\n$a_{1}^{\\text{lim}} = 0.2$\n$a_{2}^{\\text{lim}} = 0.1$\n$a_{3}^{\\text{lim}} = -0.1$\n\nThe final limited vector is $(0.9, 0.2, 0.1, -0.1)$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.9  0.2  0.1  -0.1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Before a limiter can act, it must first identify which cells are \"troubled\" and require intervention. This is the role of a troubled-cell indicator or sensor. This practice introduces the widely-used Persson-Peraire sensor, which detects under-resolved features by measuring the fraction of energy contained in the highest-degree polynomial modes. You will implement this sensor for two-dimensional triangular elements, learning how to efficiently compute it from a standard array of modal coefficients, a fundamental skill in practical DG code development.",
            "id": "3400893",
            "problem": "You are given a high-order Discontinuous Galerkin (DG) discretization on a reference triangle using a Dubiner modal basis that is orthonormal with respect to the standard $L^{2}$ inner product on the reference element. A Dubiner basis is organized by total degree: for polynomial degree $p$, the set of modal coefficients is $\\{ \\hat{u}_{i,j} \\}_{i,j \\ge 0,\\, i+j \\le p}$. Assume the coefficients are stored in a one-dimensional array ordered first by total degree $n = i + j$ ascending from $n = 0$ to $n = p$, and within each total degree $n$, by ascending $i = 0,1,\\dots,n$ with $j = n-i$. The total number of modes is $N_{p} = \\frac{(p+1)(p+2)}{2}$.\n\nThe Persson–Peraire moment-decay sensor for one-dimensional Legendre polynomials generalizes to triangles by comparing the energy carried by the highest total-degree modes to the total energy. Let the total modal energy be\n\n$$\nE_{\\mathrm{tot}} = \\sum_{i+j \\le p} \\hat{u}_{i,j}^{2},\n$$\n\nand the highest-level energy be\n\n$$\nE_{p} = \\sum_{i+j = p} \\hat{u}_{i,j}^{2}.\n$$\n\nDefine the sensor\n\n$$\nS = \\log_{10}\\!\\left( \\frac{E_{p}}{E_{\\mathrm{tot}} + \\varepsilon} \\right),\n$$\n\nwhere $\\varepsilon$ is a small positive regularization to avoid division by zero. An element is flagged as troubled if $S > \\tau$, for a chosen threshold $\\tau$. Assume $\\varepsilon = 10^{-16}$ and $\\tau = -3$.\n\nStarting only from these core definitions and the orthonormality of the Dubiner basis, do the following:\n\n1. Derive the expression for the sensor $S$ in terms of the stored modal coefficients $\\hat{u}_{i,j}$ and explain why orthonormality implies that no geometric metric factors are needed in $E_{\\mathrm{tot}}$ and $E_{p}$ on the reference triangle.\n\n2. Propose an algorithm to compute $S$ efficiently using only the stored coefficients and the known storage order, without reconstructing the solution in physical space. Your algorithm must be $ \\mathcal{O}(N_{p}) $ and must avoid explicit geometric transformations. Show how to compute the index range corresponding to the highest total degree $p$ in constant time after a precomputation that depends only on $p$.\n\n3. Explain why this sensor is sensitive to an oblique shock in the element, even when the shock is not aligned with the coordinate axes, and relate this to the population of the highest total-degree moments.\n\n4. Implement a program that computes the troubled-cell flag for each of the following test cases. In each case, construct the one-dimensional array of coefficients $[\\hat{u}_{0,0}, \\hat{u}_{1,0}, \\hat{u}_{0,1}, \\hat{u}_{2,0}, \\hat{u}_{1,1}, \\hat{u}_{0,2}, \\dots]$ according to the specified rule. For each case, compute $S$ and output $1$ if the cell is troubled and $0$ otherwise, using $\\tau = -3$ and $\\varepsilon = 10^{-16}$.\n\n   - Case A (smooth): $p = 4$. For each $(i,j)$ with $i+j \\le p$, set $\\hat{u}_{i,j} = \\alpha \\, \\rho^{\\, i + j}$ with $\\alpha = 7 \\times 10^{-1}$ and $\\rho = 2 \\times 10^{-1}$.\n\n   - Case B (shock-like algebraic decay): $p = 5$. For each $(i,j)$, set $\\hat{u}_{i,j} = \\dfrac{1}{1 + i + j}$.\n\n   - Case C (zero field): $p = 3$. For each $(i,j)$, set $\\hat{u}_{i,j} = 0$.\n\n   - Case D (oblique-shock anisotropy surrogate): $p = 5$. For each $(i,j)$, set $\\hat{u}_{i,j} = \\dfrac{1}{1 + i + 3 j}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_{A}, r_{B}, r_{C}, r_{D}]$), where $r_{\\bullet} \\in \\{0,1\\}$ is the troubled-cell flag for the corresponding test case.\n\nAll quantities in this problem are non-dimensional and require no physical units. Angles, if any, are not used. The expected per-test-case output type is an integer. The test suite is designed to cover a smooth case, a strong shock-like case, a degenerate zero-energy case, and an anisotropic oblique-shock surrogate case that loads high-degree cross-coupled moments.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the field of numerical methods for partial differential equations, specifically concerning high-order Discontinuous Galerkin (DG) methods. It is well-posed, with all necessary definitions, constants, and data provided to arrive at a unique, verifiable solution. The language is objective and precise.\n\n### 1. Derivation of the Sensor Expression and Role of Orthonormality\n\nThe solution $u(\\mathbf{x})$ within a reference triangular element $\\hat{K}$ is represented as a finite expansion in an orthonormal Dubiner modal basis $\\{\\phi_{i,j}(\\mathbf{x})\\}_{i+j \\le p}$:\n$$\nu(\\mathbf{x}) = \\sum_{i,j \\ge 0, i+j \\le p} \\hat{u}_{i,j} \\phi_{i,j}(\\mathbf{x})\n$$\nwhere $\\hat{u}_{i,j}$ are the modal coefficients and $p$ is the maximum polynomial degree. The basis is specified to be orthonormal with respect to the standard $L^2$ inner product on the reference element, $\\langle f, g \\rangle_{\\hat{K}} = \\int_{\\hat{K}} f(\\mathbf{x})g(\\mathbf{x}) d\\mathbf{x}$. This orthonormality condition is expressed as:\n$$\n\\langle \\phi_{i,j}, \\phi_{k,l} \\rangle_{\\hat{K}} = \\delta_{ik}\\delta_{jl}\n$$\nwhere $\\delta$ is the Kronecker delta.\n\nThe total energy of the solution on the reference element is its squared $L^2$-norm, $\\|u\\|_{L^2(\\hat{K})}^2$. We can express this using the modal expansion:\n$$\n\\|u\\|_{L^2(\\hat{K})}^2 = \\langle u, u \\rangle_{\\hat{K}} = \\left\\langle \\sum_{i+j \\le p} \\hat{u}_{i,j} \\phi_{i,j}, \\sum_{k+l \\le p} \\hat{u}_{k,l} \\phi_{k,l} \\right\\rangle_{\\hat{K}}\n$$\nBy the bilinearity of the inner product, this becomes:\n$$\n\\|u\\|_{L^2(\\hat{K})}^2 = \\sum_{i+j \\le p} \\sum_{k+l \\le p} \\hat{u}_{i,j} \\hat{u}_{k,l} \\langle \\phi_{i,j}, \\phi_{k,l} \\rangle_{\\hat{K}}\n$$\nSubstituting the orthonormality condition $\\langle \\phi_{i,j}, \\phi_{k,l} \\rangle_{\\hat{K}} = \\delta_{ik}\\delta_{jl}$:\n$$\n\\|u\\|_{L^2(\\hat{K})}^2 = \\sum_{i+j \\le p} \\sum_{k+l \\le p} \\hat{u}_{i,j} \\hat{u}_{k,l} \\delta_{ik}\\delta_{jl} = \\sum_{i+j \\le p} \\hat{u}_{i,j}^2\n$$\nThis is a statement of Parseval's theorem. The problem defines the total modal energy as $E_{\\mathrm{tot}} = \\sum_{i+j \\le p} \\hat{u}_{i,j}^{2}$. Therefore, $E_{\\mathrm{tot}}$ is precisely the squared $L^2$-norm of the solution, and its calculation is a simple sum of squares of the coefficients. No geometric metric factors (e.g., a Jacobian determinant from a mapping) are needed because the basis is orthonormal on the reference element $\\hat{K}$ and all calculations are performed in this reference space.\n\nThe energy carried by the highest total-degree modes, $E_p$, is the sum of squared coefficients where the total degree is exactly $p$:\n$$\nE_p = \\sum_{i+j = p} \\hat{u}_{i,j}^{2}\n$$\nThis quantity isolates the energy contribution from the highest-frequency basis functions in the chosen polynomial space.\n\nThe Persson–Peraire sensor, $S$, is then defined using these energy measures:\n$$\nS = \\log_{10}\\!\\left( \\frac{E_{p}}{E_{\\mathrm{tot}} + \\varepsilon} \\right) = \\log_{10}\\!\\left( \\frac{\\sum_{i+j = p} \\hat{u}_{i,j}^{2}}{\\sum_{k+l \\le p} \\hat{u}_{k,l}^{2} + \\varepsilon} \\right)\n$$\nwhere $\\varepsilon$ is a small regularization parameter to prevent division by zero when the solution is identically zero. This formulation relies solely on the modal coefficients.\n\n### 2. Efficient Algorithm for Sensor Computation\n\nThe goal is an $\\mathcal{O}(N_p)$ algorithm to compute $S$ from the one-dimensional array of modal coefficients, where $N_p = \\frac{(p+1)(p+2)}{2}$ is the total number of modes. The problem specifies that the coefficients are stored first by ascending total degree $n = i+j$ (from $n=0$ to $n=p$), and provides an example storage pattern `[\\hat{u}_{0,0}, \\hat{u}_{1,0}, \\hat{u}_{0,1}, \\hat{u}_{2,0}, \\hat{u}_{1,1}, \\hat{u}_{0,2}, \\dots]`. This example clearly indicates that for a given total degree $n$, the modes are ordered by descending index $i$ (from $n$ down to $0$).\n\nTo compute $S$, we need to calculate two sums: $E_{\\mathrm{tot}}$, the sum of squares of all coefficients, and $E_p$, the sum of squares of coefficients corresponding to total degree $p$.\n\nThe total number of modes with total degree less than $p$ (i.e., up to degree $p-1$) is given by $N_{p-1} = \\frac{((p-1)+1)((p-1)+2)}{2} = \\frac{p(p+1)}{2}$. In a zero-indexed array, these modes occupy indices $0, 1, \\dots, N_{p-1}-1$. Consequently, the modes of total degree $p$ begin at index $N_{p-1}$. The number of modes of degree $p$ is $p+1$.\n\nThe start index for the highest-degree modes can be computed in constant time given $p$:\n$$\n\\text{start\\_index}_p = N_{p-1} = \\frac{p(p+1)}{2}\n$$\n\nThe algorithm proceeds as follows:\n1.  Given the polynomial degree $p$ and the 1D array of coefficients, `u_coeffs`, of length $N_p$.\n2.  Compute the start index for the highest-degree modes: `idx_start_p = p * (p + 1) // 2`. This is a constant-time precomputation.\n3.  Calculate $E_p$ by summing the squares of the coefficients for the highest-degree modes. This corresponds to slicing the array from `idx_start_p` to the end:\n    `E_p = sum(c*c for c in u_coeffs[idx_start_p:])`.\n4.  Calculate $E_{\\mathrm{tot}}$ by summing the squares of all coefficients in the array:\n    `E_tot = sum(c*c for c in u_coeffs)`.\n5.  Compute the sensor value using the given formula:\n    `S = log10(E_p / (E_tot + epsilon))`.\n6.  Compare $S$ with the threshold $\\tau$ to determine if the cell is troubled.\n\nThis algorithm involves iterating through the coefficient array a constant number of times. The dominant cost is the summation for $E_{\\mathrm{tot}}$, which is linear in the number of coefficients, $N_p$. Thus, the complexity is $\\mathcal{O}(N_p)$.\n\n### 3. Sensitivity to Oblique Shocks\n\nThe Persson–Peraire sensor is effective at detecting sharp, under-resolved features like shock waves because of the spectral properties of polynomial approximations.\n- **Spectral Decay**: For a smooth (e.g., $C^\\infty$) function, the coefficients of its expansion in a polynomial basis decay faster than any algebraic power of the mode number (i.e., spectral decay). In this case, the modal energy is concentrated in the low-degree modes, and the energy in the highest-degree modes, $E_p$, is exceedingly small compared to the total energy, $E_{\\mathrm{tot}}$. This results in a very small ratio $E_p/E_{\\mathrm{tot}}$ and a large negative value for $S$, typically well below the threshold $\\tau$.\n- **Discontinuities**: When a function has a discontinuity, as with a shock wave, its spectral coefficients decay much more slowly, typically algebraically (e.g., $|\\hat{u}_k| \\sim 1/k$). This slow decay means that a significant amount of energy is required in the high-degree modes to even crudely represent the sharp feature (a manifestation of the Gibbs phenomenon). Consequently, $E_p$ will be a non-negligible fraction of $E_{\\mathrm{tot}}$. The ratio $E_p/E_{\\mathrm{tot}}$ will be relatively large (e.g., $10^{-3}$ to $10^{-1}$), leading to a value of $S$ greater than the threshold $\\tau$.\n- **Oblique Orientation**: An oblique shock is one not aligned with the natural coordinate axes of the reference element. The Dubiner basis functions, being constructed from products of 1D polynomials, have inherent directional properties related to these axes. An oblique feature cannot be efficiently represented by a subset of modes aligned with the axes and will instead project onto a wide combination of all available basis functions, including cross-terms where both $i$ and $j$ are non-zero. The sensor's definition for $E_p = \\sum_{i+j=p} \\hat{u}_{i,j}^2$ sums the energy over *all* modes of the highest degree. It is therefore isotropic in modal space; it is insensitive to *how* the energy is distributed among the $p+1$ modes of degree $p$, only to the total energy present at that degree. By capturing the total high-frequency energy content, the sensor robustly detects under-resolved features regardless of their orientation.\n\n### 4. Implementation\n\nThe following program implements the described algorithm to classify the given test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the troubled-cell flag for several test cases of DG modal coefficients\n    using the Persson–Peraire moment-decay sensor.\n    \"\"\"\n    epsilon = 1e-16\n    tau = -3.0\n\n    test_cases = [\n        {\n            \"name\": \"Case A (smooth)\",\n            \"p\": 4,\n            \"rule\": lambda i, j: 7e-1 * (2e-1)**(i + j)\n        },\n        {\n            \"name\": \"Case B (shock-like algebraic decay)\",\n            \"p\": 5,\n            \"rule\": lambda i, j: 1.0 / (1.0 + i + j)\n        },\n        {\n            \"name\": \"Case C (zero field)\",\n            \"p\": 3,\n            \"rule\": lambda i, j: 0.0\n        },\n        {\n            \"name\": \"Case D (oblique-shock anisotropy surrogate)\",\n            \"p\": 5,\n            \"rule\": lambda i, j: 1.0 / (1.0 + i + 3.0 * j)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case[\"p\"]\n        rule = case[\"rule\"]\n\n        # 1. Generate coefficients based on the specified ordering.\n        # The ordering is by total degree n = i + j, and for each n, by descending i.\n        # This follows the problem's explicit example: [u_00, u_10, u_01, u_20, ...].\n        coeffs_list = []\n        for n in range(p + 1):\n            for i in range(n, -1, -1):\n                j = n - i\n                coeffs_list.append(rule(i, j))\n        \n        u_hat = np.array(coeffs_list, dtype=np.float64)\n\n        # 2. Compute the start index for the highest-degree (p) modes.\n        # Number of modes up to degree p-1 is N_{p-1} = p*(p+1)/2.\n        start_index_p = p * (p + 1) // 2\n\n        # 3. Calculate E_p and E_tot.\n        if u_hat.size > 0:\n            u_hat_sq = u_hat**2\n            # Energy in highest-degree modes\n            E_p = np.sum(u_hat_sq[start_index_p:])\n            # Total energy\n            E_tot = np.sum(u_hat_sq)\n        else:\n            E_p = 0.0\n            E_tot = 0.0\n\n        # 4. Compute the sensor S.\n        # Use np.log10 for base-10 logarithm.\n        # The ratio is E_p / (E_tot + epsilon).\n        if E_tot + epsilon = 0: # Avoid log of non-positive\n             S = -np.inf\n        else:\n             ratio = E_p / (E_tot + epsilon)\n             if ratio = 0: # Avoid log of non-positive\n                 S = -np.inf\n             else:\n                 S = np.log10(ratio)\n\n        # 5. Determine if the cell is troubled.\n        is_troubled = 1 if S > tau else 0\n        results.append(is_troubled)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "An ideal troubled-cell indicator is both sensitive to true discontinuities and robust against \"false positives\" on features that are steep but mathematically smooth. This exercise explores this trade-off by analyzing a simpler, one-dimensional decay indicator. You will set up a numerical experiment to measure the rate of false activations on a smooth, sharp gradient and compare the results to a theoretical model. This practice demonstrates how to diagnose limiter performance and provides a clear motivation for using more sophisticated indicators, like the Persson-Peraire sensor, in production codes.",
            "id": "3400892",
            "problem": "Consider the one-dimensional Discontinuous Galerkin (DG) method on the interval $[-1,1]$ with a uniform mesh of cell width $h$, such that $N = 2/h$ is an integer. On each cell, use the mapped Legendre polynomial basis $\\{L_k(\\xi)\\}_{k=0}^p$ on the reference domain $\\xi \\in [-1,1]$, with the affine map $x = x_c + \\frac{h}{2}\\xi$ where $x_c$ is the cell center. For a manufactured smooth function with steep gradients $u(x) = \\tanh(\\alpha x)$, define the modal (moment) coefficients $a_k$ of the $L^2$-projection of $u$ onto the local polynomial space of degree $p$ by\n$$\na_k = \\frac{2k+1}{2}\\int_{-1}^1 u\\!\\left(x_c + \\frac{h}{2}\\xi\\right)L_k(\\xi)\\,d\\xi,\\quad k=0,1,\\dots,p.\n$$\nDefine a moment-based decay indicator that activates a limiter if the ratio of the highest mode to its predecessor exceeds a threshold:\n$$\n\\text{activate if}\\quad R_p = \\frac{|a_p|}{|a_{p-1}|} > \\Theta(p),\\quad \\Theta(p) = \\frac{\\eta}{p},\n$$\nwhere $\\eta > 0$ is a prescribed constant and $p \\ge 1$. For the smooth manufactured solution, any activation is by definition a false activation. The false activation rate is defined as the fraction of cells on $[-1,1]$ for which the indicator activates.\n\nStarting from the foundational facts that Legendre polynomials form an orthogonal basis on $[-1,1]$, and that for sufficiently smooth $u$ the modal coefficients $a_k$ are controlled by local derivatives of $u$ with scaling that depends on $h$, derive a tractable asymptotic model for the activation criterion in terms of the local ratio of derivatives and the mesh-size-induced scale separation. Use that for analytic $u$, the leading-order behavior of hierarchical modal ratios satisfies\n$$\nR_p(x_c) \\approx C_p\\,h\\,\\frac{|u^{(p)}(x_c)|}{|u^{(p-1)}(x_c)|},\n$$\nfor some bounded $C_p = \\mathcal{O}(1)$ independent of $h$ and $\\alpha$ for fixed $p$. For $u(x) = \\tanh(\\alpha x)$, exploit the fact that $|u'(x)| = \\alpha\\,\\operatorname{sech}^2(\\alpha x)$ and that the ratios of higher derivatives are bounded by a factor proportional to $\\alpha\\,\\operatorname{sech}^2(\\alpha x)$ up to $\\mathcal{O}(1)$ multiplicative constants. Using this structure, show that a sufficient condition for activation has the form\n$$\n\\alpha h\\,p\\,\\operatorname{sech}^2(\\alpha x_c) \\gtrsim \\eta,\n$$\nand deduce an asymptotic scaling for the false activation probability (fraction of cells activated) as a function of $t = \\alpha h p$:\n$$\n\\Phi(t,\\alpha) \\approx \n\\begin{cases}\n0,  t \\le \\eta,\\\\\n\\min\\!\\left(1,\\,\\dfrac{1}{\\alpha}\\,\\operatorname{arcosh}\\!\\sqrt{\\dfrac{t}{\\eta}}\\right),  t > \\eta,\n\\end{cases}\n$$\nwhere $\\operatorname{arcosh}$ denotes the inverse hyperbolic cosine function and the domain length is $2$. This scaling arises from measuring the set of cell centers $x_c$ satisfying the indicator inequality when $\\operatorname{sech}^2(\\alpha x_c)$ models the local steepness.\n\nYour task is to implement a complete program that:\n- Computes, for each test case $(p,h,\\alpha)$, the empirical false activation rate by:\n  - Constructing the uniform mesh of cells with width $h$ over $[-1,1]$.\n  - Computing the local modal coefficients $\\{a_k\\}_{k=0}^p$ via Gaussian quadrature sufficiently accurate for the given $p$.\n  - Applying the activation rule $R_p > \\eta/p$ on each cell to count activations.\n  - Reporting the fraction of activated cells.\n- Computes, for each test case, the asymptotic prediction $\\Phi(t,\\alpha)$ using the formula above with the same $\\eta$.\n- Aggregates the empirical and predicted values as pairs for all test cases in a single output line.\n\nUse $\\eta = 0.5$. Use Gaussian quadrature with at least $2p+5$ points per cell to approximate the integrals. Angles do not appear in this problem. There are no physical units; all quantities are dimensionless. Express all floating-point answers rounded to six decimal places.\n\nTest suite:\n- Case A: $(p,h,\\alpha) = (2, 0.05, 1)$.\n- Case B: $(p,h,\\alpha) = (2, 0.5, 1)$.\n- Case C: $(p,h,\\alpha) = (4, 0.2, 5)$.\n- Case D: $(p,h,\\alpha) = (6, 0.5, 10)$.\n- Case E: $(p,h,\\alpha) = (8, 0.2, 3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result represented as a pair $[\\text{empirical},\\text{predicted}]$, for example, $[[e_1,p_1],[e_2,p_2],\\dots]$, where each $e_i$ and $p_i$ is a float rounded to six decimal places.",
            "solution": "The objective of this problem is to analyze a moment-based limiter for the Discontinuous Galerkin (DG) method, specifically its propensity for false activation on smooth solutions. We will compute the empirical false activation rate for a manufactured solution and compare it against a derived asymptotic prediction. The process involves two main components: a numerical computation based on the DG representation and an evaluation of a theoretical formula.\n\nFirst, we address the computation of the empirical false activation rate for a given polynomial degree $p$, cell width $h$, and solution parameter $\\alpha$. The domain is the interval $[-1, 1]$, which is discretized into a uniform mesh of $N = 2/h$ cells. The cell centers are denoted by $x_c$.\n\nOn each cell, we analyze the local representation of the smooth function $u(x) = \\tanh(\\alpha x)$. The function is projected onto a basis of Legendre polynomials, $\\{L_k(\\xi)\\}_{k=0}^p$, on the reference element $\\xi \\in [-1, 1]$. The physical coordinate $x$ is related to the reference coordinate $\\xi$ via the affine mapping $x = x_c + \\frac{h}{2}\\xi$. The modal coefficients, $a_k$, of this projection are defined by the $L^2$ inner product:\n$$\na_k = \\frac{\\int_{-1}^1 u\\!\\left(x_c + \\frac{h}{2}\\xi\\right)L_k(\\xi)\\,d\\xi}{\\int_{-1}^1 (L_k(\\xi))^2\\,d\\xi} = \\frac{2k+1}{2}\\int_{-1}^1 u\\!\\left(x_c + \\frac{h}{2}\\xi\\right)L_k(\\xi)\\,d\\xi.\n$$\nThe integral is not generally tractable analytically and must be computed numerically. We employ Gaussian-Legendre quadrature, which is exact for polynomials of degree up to $2N_q - 1$ with $N_q$ quadrature points. The problem specifies using $N_q \\ge 2p+5$ points, ensuring high accuracy for the integrand, which involves a polynomial of degree $p$ and the smooth function $u$. The quadrature approximation for a generic function $f(\\xi)$ is $\\int_{-1}^1 f(\\xi)\\,d\\xi \\approx \\sum_{j=1}^{N_q} w_j f(\\xi_j)$, where $\\xi_j$ are the quadrature points (roots of $L_{N_q}(\\xi)$) and $w_j$ are the corresponding weights. The modal coefficient is thus computed as:\n$$\na_k \\approx \\frac{2k+1}{2} \\sum_{j=1}^{N_q} w_j \\tanh\\left(\\alpha \\left(x_c + \\frac{h}{2}\\xi_j\\right)\\right)L_k(\\xi_j).\n$$\nWe need to compute the coefficients $a_{p-1}$ and $a_p$ for $p \\ge 1$. The moment-based limiter is activated if the decay rate of the modal coefficients is not sufficiently fast. The indicator is given by the ratio $R_p = |a_p|/|a_{p-1}|$. Activation occurs if this ratio exceeds a degree-dependent threshold $\\Theta(p) = \\eta/p$, where $\\eta = 0.5$ is a constant. The activation condition is:\n$$\nR_p = \\frac{|a_p|}{|a_{p-1}|} > \\frac{\\eta}{p}.\n$$\nFor each cell in the mesh, we compute $a_{p-1}$ and $a_p$, evaluate this condition, and count the number of cells where it is satisfied. The empirical false activation rate is the total count of activated cells divided by the total number of cells, $N$.\n\nSecond, we compute the asymptotic prediction for this rate. The problem provides a theoretical model based on an asymptotic analysis of the modal coefficients for a smooth function. The core of this model is the relationship between the ratio of modal coefficients and the ratio of the function's derivatives at the cell center:\n$$\nR_p(x_c) \\approx C_p\\,h\\,\\frac{|u^{(p)}(x_c)|}{|u^{(p-1)}(x_c)|},\n$$\nwhere $C_p = \\mathcal{O}(1)$ is a constant dependent on the basis. For $u(x)=\\tanh(\\alpha x)$, the derivatives are spatially modulated by factors involving $\\operatorname{sech}^2(\\alpha x)$. This leads to a simplified activation condition:\n$$\n\\alpha h p \\operatorname{sech}^2(\\alpha x_c) \\gtrsim \\eta.\n$$\nLetting $t = \\alpha h p$, this inequality becomes $\\operatorname{sech}^2(\\alpha x_c) \\gtrsim \\eta/t$. For this to have a solution for $x_c$, we must have $\\eta/t  1$, or $t > \\eta$. If $t \\le \\eta$, no activation is predicted. If $t > \\eta$, solving for $x_c$ yields the activation region:\n$$\n|x_c|  \\frac{1}{\\alpha}\\operatorname{arcosh}\\left(\\sqrt{\\frac{t}{\\eta}}\\right).\n$$\nThe predicted false activation rate, $\\Phi(t, \\alpha)$, is the fraction of the domain $[-1, 1]$ covered by this activation region. The length of the activation region is $2 \\cdot \\frac{1}{\\alpha}\\operatorname{arcosh}(\\sqrt{t/\\eta})$, and the total domain length is $2$. The predicted rate is the ratio of these lengths, capped at $1$ since the activation region cannot extend beyond the domain. This yields the formula:\n$$\n\\Phi(t,\\alpha) = \n\\begin{cases}\n0,  t \\le \\eta, \\\\\n\\min\\!\\left(1,\\,\\dfrac{1}{\\alpha}\\,\\operatorname{arcosh}\\!\\sqrt{\\dfrac{t}{\\eta}}\\right),  t > \\eta.\n\\end{cases}\n$$\nOur program will implement both the empirical computation and this predictive formula for each specified test case $(p, h, \\alpha)$, and report the pair of results.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef solve():\n    \"\"\"\n    Computes and prints the empirical and predicted false activation rates\n    for a moment-based limiter in a Discontinuous Galerkin method.\n    \"\"\"\n    \n    # Test suite from the problem statement\n    test_cases = [\n        # (p, h, alpha)\n        (2, 0.05, 1),\n        (2, 0.5, 1),\n        (4, 0.2, 5),\n        (6, 0.5, 10),\n        (8, 0.2, 3),\n    ]\n\n    # Constant from the problem statement\n    eta = 0.5\n\n    results = []\n\n    for p, h, alpha in test_cases:\n        # --- 1. Empirical False Activation Rate ---\n        \n        #\n        # Setup mesh\n        #\n        # Number of cells\n        N = int(2 / h)\n        # Cell centers\n        x_c = np.linspace(-1 + h / 2, 1 - h / 2, N)\n\n        #\n        # Setup for quadrature and basis functions\n        #\n        # Number of quadrature points\n        nq = 2 * p + 5\n        # Quadrature points (xi) and weights (w) on [-1, 1]\n        xi_q, w_q = np.polynomial.legendre.leggauss(nq)\n\n        # Evaluate Legendre polynomials at quadrature points\n        Lp_vals = eval_legendre(p, xi_q)\n        Lp_minus_1_vals = eval_legendre(p - 1, xi_q)\n        \n        activated_cells = 0\n        for i in range(N):\n            # Map quadrature points to the current cell\n            x_q = x_c[i] + (h / 2) * xi_q\n            \n            # Function values at quadrature points\n            u_vals = np.tanh(alpha * x_q)\n\n            # Compute integrands for a_p and a_{p-1}\n            integrand_p = u_vals * Lp_vals\n            integrand_p_minus_1 = u_vals * Lp_minus_1_vals\n\n            # Approximate integrals using quadrature\n            integral_p = np.sum(w_q * integrand_p)\n            integral_p_minus_1 = np.sum(w_q * integrand_p_minus_1)\n            \n            # Compute modal coefficients\n            a_p = (2 * p + 1) / 2 * integral_p\n            a_p_minus_1 = (2 * (p - 1) + 1) / 2 * integral_p_minus_1\n\n            # Check for activation\n            # Denominator safety check: if a_{p-1} is effectively zero,\n            # the ratio is considered infinite and the limiter activates.\n            if abs(a_p_minus_1)  1e-16:\n                 # Only activate if numerator is non-zero, otherwise 0/0 is indeterminate\n                 if abs(a_p) > 1e-16:\n                     activated_cells += 1\n            else:\n                ratio = abs(a_p) / abs(a_p_minus_1)\n                threshold = eta / p\n                if ratio > threshold:\n                    activated_cells += 1\n        \n        empirical_rate = activated_cells / N\n\n        # --- 2. Asymptotic Prediction ---\n        \n        t = alpha * h * p\n        \n        if t = eta:\n            predicted_rate = 0.0\n        else:\n            # np.arccosh is the inverse hyperbolic cosine\n            value = (1 / alpha) * np.arccosh(np.sqrt(t / eta))\n            predicted_rate = min(1.0, value)\n\n        results.append([empirical_rate, predicted_rate])\n\n    # Format output as specified\n    output_str = \"[\" + \",\".join([f\"[{e:.6f},{p:.6f}]\" for e, p in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}