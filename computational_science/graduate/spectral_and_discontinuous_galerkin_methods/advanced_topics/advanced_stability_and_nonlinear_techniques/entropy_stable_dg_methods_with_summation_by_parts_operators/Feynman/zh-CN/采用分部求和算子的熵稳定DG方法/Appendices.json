{
    "hands_on_practices": [
        {
            "introduction": "熵稳定格式的基石是离散熵在时间演化中必须非增。这个入门练习将通过一个直接、分步的计算来验证这一基本性质。通过将一个强稳定性保持（SSP）时间积分方法应用于一个熵稳定的空间离散格式，我们可以显式地追踪熵的变化，并确认其为非正值，从而为理论概念提供一个坚实的实践基础 。",
            "id": "3384653",
            "problem": "考虑线性标量守恒律 $u_{t} + a\\,u_{x} = 0$，其定义在一个周期性区域上。该区域被划分为两个长度为 $h$ 的均匀单元，未知量为分片常数（多项式次数 $p=0$）。使用以分部求和 (SBP) 形式写出的间断 Galerkin (DG) 空间离散化，其对角质量矩阵为 $M = h I$，并通过耗散参数为 $\\alpha = |a|$ 的对称 Lax–Friedrichs (Rusanov) 通量进行界面耦合。\n\n取严格凸二次熵 $U(u) = \\tfrac{1}{2} u^{2}$ 及其相关的离散熵 $S(u) = \\tfrac{1}{2} u^{\\top} M u$。假设周期性边界条件，并采用与 $\\alpha = |a|$ 一致的迎风偏置选择，已知该选择对于二次熵能产生一个熵稳定的通量。\n\n设 $a = 1$ 且 $h = 1$。使用单元平均状态 $u_{1}^{n} = 1$ 和 $u_{2}^{n} = 0$ 进行初始化。使用三阶强保稳 Runge–Kutta 方法 (SSPRK(3)) 向前推进一个时间步：\n- $u^{(1)} = u^{n} + \\Delta t\\,L(u^{n})$,\n- $u^{(2)} = \\tfrac{3}{4} u^{n} + \\tfrac{1}{4}\\big(u^{(1)} + \\Delta t\\,L(u^{(1)})\\big)$,\n- $u^{n+1} = \\tfrac{1}{3} u^{n} + \\tfrac{2}{3}\\big(u^{(2)} + \\Delta t\\,L(u^{(2)})\\big)$,\n\n其中 $L(\\cdot)$ 表示带有熵稳定 Rusanov 通量的 SBP-DG 半离散算子。选择时间步长，使得 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = a\\,\\Delta t/h$ 等于 $\\lambda = 1$。\n\n计算在这一个 SSPRK(3) 时间步长内离散熵的变化量，\n$$\\Delta S \\equiv S(u^{n+1}) - S(u^{n}),$$\n并验证其为非正值。给出 $\\Delta S$ 的精确值（无需四舍五入）。你的最终答案必须是一个不带单位的实数。",
            "solution": "从问题定义开始：偏微分方程 (PDE)、区域、离散化。\n半离散系统为 $M \\frac{d\\vec{u}}{dt} = \\vec{L}(\\vec{u})$。\n对于 $p=0$ 的 DG 方法，这是一种有限体积法：$h_k \\frac{du_k}{dt} + f^*_{k+1/2} - f^*_{k-1/2} = 0$。\n这里，$k \\in \\{1, 2\\}$，$h_k=h$。\n区域是周期性的。对于单元 1，界面是 $1+1/2$（右侧）和 $1-1/2$（左侧）。左侧相邻单元是单元 2，右侧相邻单元也是单元 2。\n右侧界面上的状态：$u_L = u_1$，$u_R = u_2$。通量为 $f^*(u_1, u_2)$。\n左侧界面上的状态：$u_L = u_2$，$u_R = u_1$。通量为 $f^*(u_2, u_1)$。\n$u_1$ 的方程：$h \\frac{du_1}{dt} + f^*(u_1, u_2) - f^*(u_2, u_1) = 0$。\n$u_2$ 的方程：$h \\frac{du_2}{dt} + f^*(u_2, u_1) - f^*(u_1, u_2) = 0$。\n这表明 $\\frac{d}{dt}(u_1+u_2)=0$。\n对于 $f(u) = au$，数值通量是 Rusanov 通量：$f^*(u_L, u_R) = \\frac{a u_L + a u_R}{2} - \\frac{\\alpha}{2}(u_R-u_L)$。\n给定 $\\alpha = |a|$ 和 $a=1$，这变成 $f^*(u_L, u_R) = \\frac{u_L + u_R}{2} - \\frac{1}{2}(u_R-u_L) = u_L$。这是迎风通量。\n因此，$f^*(u_1, u_2) = u_1$ 且 $f^*(u_2, u_1) = u_2$。\n常微分方程组 (ODE system) 是：\n$h \\frac{du_1}{dt} + u_1 - u_2 = 0 \\implies \\frac{du_1}{dt} = \\frac{1}{h}(u_2-u_1)$。\n$h \\frac{du_2}{dt} + u_2 - u_1 = 0 \\implies \\frac{du_2}{dt} = \\frac{1}{h}(u_1-u_2)$。\n写成向量形式，$\\frac{d\\vec{u}}{dt} = L(\\vec{u})$，其中 $\\vec{u} = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix}$ 且 $L(\\vec{u}) = \\frac{1}{h} \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\vec{u}$。\n质量矩阵是 $M=hI$。问题陈述半离散方程是 SBP 形式 $M \\frac{d\\vec{u}}{dt} = \\text{...}$。我的推导是 $\\frac{d\\vec{u}}{dt} = L(\\vec{u})$，其中 $M=I$，这与问题陈述 $M=hI$ 和 $h=1$ 是一致的。我们需谨慎。标准的 DG 形式是 $\\int \\phi_i u_t ... = 0$。当 $p=0$ 时，$\\phi=1$，这得到 $h \\frac{du_k}{dt} ... = 0$。所以我的推导是正确的。问题中 $u^{n+1} = ... + \\Delta t L(...)$ 里的 $L(\\cdot)$ 必须是 $\\frac{d\\vec{u}}{dt} = L(\\vec{u})$ 的右侧项。所以我的算子 $L(\\vec{u})$ 就是要用的那个。\n\n给定参数 $a=1$，$h=1$。这得到 $L(\\vec{u}) = \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\vec{u}$。\nCFL 数 $\\lambda = a \\Delta t/h = 1 \\cdot \\Delta t/1 = 1$，所以 $\\Delta t=1$。\n初始状态：$\\vec{u}^n = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\nSSPRK(3) 的步骤：\n1. $\\vec{u}^{(1)} = \\vec{u}^n + \\Delta t L(\\vec{u}^n)$。\n   $L(\\vec{u}^n) = \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n   $\\vec{u}^{(1)} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。\n\n2. $\\vec{u}^{(2)} = \\frac{3}{4} \\vec{u}^n + \\frac{1}{4}(\\vec{u}^{(1)} + \\Delta t L(\\vec{u}^{(1)}))$。\n   $L(\\vec{u}^{(1)}) = \\begin{pmatrix} -1  1 \\\\ 1  -1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$。\n   $\\vec{u}^{(2)} = \\frac{3}{4} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\left( \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\right) = \\frac{3}{4} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{1}{4} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\n3. $\\vec{u}^{n+1} = \\frac{1}{3} \\vec{u}^n + \\frac{2}{3}(\\vec{u}^{(2)} + \\Delta t L(\\vec{u}^{(2)}))$。\n   $\\vec{u}^{(2)} = \\vec{u}^n$，所以 $L(\\vec{u}^{(2)}) = L(\\vec{u}^n) = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n   $\\vec{u}^{n+1} = \\frac{1}{3} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{2}{3} \\left( \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{3} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{2}{3} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 2/3 \\end{pmatrix}$。\n\n熵计算：\n离散熵为 $S(\\vec{u}) = \\frac{1}{2}\\vec{u}^T M \\vec{u}$。\n当 $h=1$ 时，$M=I$，所以 $S(\\vec{u}) = \\frac{1}{2} \\vec{u}^T \\vec{u} = \\frac{1}{2} (u_1^2 + u_2^2)$。\n初始熵：$S(\\vec{u}^n) = \\frac{1}{2}(1^2 + 0^2) = \\frac{1}{2}$。\n最终熵：$S(\\vec{u}^{n+1}) = \\frac{1}{2} \\left( (\\frac{1}{3})^2 + (\\frac{2}{3})^2 \\right) = \\frac{1}{2} \\left( \\frac{1}{9} + \\frac{4}{9} \\right) = \\frac{1}{2} \\frac{5}{9} = \\frac{5}{18}$。\n熵变：$\\Delta S = S(\\vec{u}^{n+1}) - S(\\vec{u}^n) = \\frac{5}{18} - \\frac{1}{2} = \\frac{5}{18} - \\frac{9}{18} = -\\frac{4}{18} = -\\frac{2}{9}$。\n结果 $\\Delta S = -2/9$ 是非正的，这与在适当的 CFL 条件下，将 SSPRK 格式应用于熵稳定的半离散化所得的熵稳定性是一致的。\n\n所有检查都已完成。逻辑合理，计算已验证。我可以写出解答了。\n题目提到了 DG-SBP 形式。我应该简要说明一下。对于 $p=0$ 的分片常数，微分算子为空。SBP 结构主要体现在边界/界面项中。半离散化 $h_k \\frac{du_k}{dt} + f^*_{k+1/2} - f^*_{k-1/2} = 0$ 是一种标准的有限体积法，它是 $p=0$ 时 DG-SBP 公式的一个特例。界面项由给定的数值通量处理。我的方法与此描述一致。\n问题陈述本身有点像现代数值方法术语（DG、SBP、SSPRK、熵稳定性）的大杂烩，但实际问题归结为一个非常简单的 $2 \\times 2$ 常微分方程组。这可能看起来有点‘故作高深’，但它是这些概念的一个有效、具体的实例，需要正确应用定义。这是一个很好的理解力测试。我认为它是有效的。\n\n最后确认所用的 SSPRK(3) 公式：\n- $u^{(1)} = u^{n} + \\Delta t\\,L(u^{n})$\n- $u^{(2)} = \\tfrac{3}{4} u^{n} + \\tfrac{1}{4}\\big(u^{(1)} + \\Delta t\\,L(u^{(1)})\\big)$\n- $u^{n+1} = \\tfrac{1}{3} u^{n} + \\tfrac{2}{3}\\big(u^{(2)} + \\Delta t\\,L(u^{(2)})\\big)$\n这是 Shu-Osher SSPRK(3,2) 的一种标准表示。让我们看看凸组合形式。... 一个 SSP 方法可以写成... 但关键是它可以写成前向欧拉步的凸组合序列。问题中的形式就是这样一种表示。我将相信问题陈述中给出的公式。我的计算完全遵循了它，并得出了与理论一致的结果，因此它很可能是正确的。这个问题是自洽的。我必须按其陈述来解决它。\n计算看起来很可靠。没有理由怀疑它。",
            "answer": "$$\n\\boxed{-\\frac{2}{9}}\n$$"
        },
        {
            "introduction": "为非线性守恒律开发稳定数值格式的一个核心挑战是如何处理非线性项，这些项可能引入导致不稳定的混叠误差。本实践旨在阐明为何“朴素”的强形式离散化方法可能无法保持熵守恒，以及一个特殊设计的熵守恒通量差分格式如何解决这个问题。通过比较两种不同体积离散化的熵产生率，我们可以用数值方式证明通量差分方法的优越性，并理解其在消除混叠误差中的关键作用 。",
            "id": "3384682",
            "problem": "考虑一维标量守恒律 $u_t + \\partial_x f(u) = 0$ 在参考区间 $[-1,1]$ 上，具有周期性边界条件。令 $f(u)$ 表示物理通量。您将研究配置形式的间断伽辽金谱元法 (DGSEM)，该方法使用分部求和 (SBP) 算子，并评估当使用两点熵守恒通量时，通量差分如何消除体积分混叠。您将比较在高斯-勒让德-洛巴托 (GLL) 和高斯-勒让德 (Gauss) 求积法则下计算的离散熵收支。\n\n使用无粘伯格斯方程，其中 $f(u) = \\frac{1}{2}u^2$。为其配备标准凸熵 $U(u) = \\frac{1}{2}u^2$、熵变量 $v(u) = U'(u) = u$、熵通量 $F(u) = \\frac{1}{3}u^3$ 和通量势 $\\psi(u) = v(u) f(u) - F(u) = \\frac{1}{6}u^3$。对于通量差分，使用两点熵守恒通量\n$$\nf^{ec}(u_L,u_R) = \\frac{1}{6}\\left(u_L^2 + u_L u_R + u_R^2\\right).\n$$\n\n在一个位于 $[-1,1]$ 上的单元谱元上进行研究。对于选定的多项式次数 $N$，构建 $N+1$ 个高斯-勒让德-洛巴托节点和权重，或 $N+1$ 个高斯-勒让德节点和权重。使用以下各项构建 SBP 算子：\n- 对角质量矩阵 $M = \\operatorname{diag}(w_1,\\dots,w_{N+1})$，其中 $w_i$ 为求积权重，\n- 与所选节点处的拉格朗日插值相关的节点微分矩阵 $D$，\n- SBP 算子 $Q = M D$。\n\n将在配置点处采样的周期性初始条件定义为\n$$\nu(x) = a \\sin(\\pi x) + b \\cos(3\\pi x),\n$$\n其中 $a$ 和 $b$ 是实数参数。对于此 $u$，使用两种不同的格式评估半离散体积项对熵收支的贡献：\n\n1. 朴素强形式体积分离散：\n$$\n\\frac{d}{dt} \\sum_{i=1}^{N+1} w_i U(u_i) \\bigg|_{\\text{naive}} = - v^T Q f(u),\n$$\n其中 $u_i = u(x_i)$，$v_i = v(u_i)$，且 $f(u_i) = \\frac{1}{2}u_i^2$。\n\n2. 使用两点熵守恒通量的通量差分体积分离散：\n$$\n\\frac{d}{dt} \\sum_{i=1}^{N+1} w_i U(u_i) \\bigg|_{\\text{fd}} = -2 \\sum_{i=1}^{N+1}\\sum_{j=1}^{N+1} v_i \\, Q_{ij} \\, f^{ec}(u_i,u_j).\n$$\n\n在周期性边界条件下，对于体积项，熵守恒的通量差分格式在精确算术下预期会产生一个恒等于零的离散熵率，而朴素强形式由于在配置点上计算非线性通量引入的混叠效应，可能会产生非零的离散熵。您将数值评估两种格式下离散熵率的量级，并比较在 GLL 和 Gauss 求积法则下的行为。\n\n在一个完整且可运行的程序中实现以下步骤：\n- 为高斯-勒让德-洛巴托求积（含 $N+1$ 个点）和高斯-勒让德求积（含 $N+1$ 个点）构建节点和权重。\n- 对给定的节点，通过重心权重计算拉格朗日节点微分矩阵 $D$。\n- 构造 $M$ 和 $Q = M D$。\n- 对每个测试用例，采样 $u(x)$ 并计算：\n  - 在 GLL 下朴素强形式离散熵率的绝对值 $| - v^T Q f(u) |$，\n  - 在 GLL 下通量差分离散熵率的绝对值 $| -2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j) |$，\n  - 在 Gauss 求积下计算的上述两个绝对值。\n\n设计一个测试套件，以探究多项式次数和非线性振幅的变化性：\n- 测试用例 1（理想情况）：$N=5$，$a=1.0$，$b=0.1$。\n- 测试用例 2（低阶边界情况）：$N=1$，$a=1.0$，$b=0.5$。\n- 测试用例 3（高阶混叠压力）：$N=12$，$a=1.0$，$b=1.0$。\n- 测试用例 4（强非线性）：$N=8$，$a=2.5$，$b=2.0$。\n\n对于每个测试用例，您的程序必须返回一个包含四个浮点数的列表：\n- 在 GLL 下的 $| - v^T Q f(u) |$，\n- 在 GLL 下的 $| -2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j) |$，\n- 在 Gauss 下的 $| - v^T Q f(u) |$，\n- 在 Gauss 下的 $| -2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j) |$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由方括号括起来的、由这些四元素列表组成的逗号分隔列表。即，最终输出必须为以下形式：\n$$\n\\texttt{[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}],[r_{41},r_{42},r_{43},r_{44}]]}\n$$\n所有条目均以标准 Python 浮点字面量形式打印。本问题不涉及任何物理单位或角度单位；所有量均为无量纲。",
            "solution": "该问题经评估有效。它在守恒律数值方法的理论上具有科学依据，是适定的，具有唯一可计算的答案，并且表述客观。所有必要的数据和定义均已提供。\n\n目标是数值研究现代间断伽辽金谱元法 (DGSEM) 的一个关键性质：通量差分在实现熵稳定性中的作用。我们比较一个标准的或“朴素的”强形式离散与一个熵守恒的通量差分格式。此比较是针对一维无粘伯格斯方程 $u_t + \\partial_x (\\frac{1}{2}u^2) = 0$ 在单个单元上进行的，该单元具有周期性边界条件，同时使用高斯-勒让德-洛巴托 (GLL) 和高斯-勒让德 (Gauss) 求积点。\n\n### 1. 连续和离散熵守恒\n\n对于标量守恒律 $u_t + f(u)_x = 0$，凸熵函数 $U(u)$ 的变化率由熵不等式 $U(u)_t + F(u)_x \\le 0$ 控制，其中 $F(u)$ 是熵通量，由 $F'(u) = U'(u)f'(u)$ 定义。对于在半离散层面考虑的光滑解，此不等式作为等式成立，$U(u)_t + F(u)_x = 0$。在区间 $[-1, 1]$ 上积分得到\n$$\n\\frac{d}{dt} \\int_{-1}^1 U(u) \\, dx = - \\int_{-1}^1 F(u)_x \\, dx = -[F(u(1)) - F(u(-1))]\n$$\n对于周期性边界条件，$u(-1) = u(1)$，这意味着 $F(u(-1)) = F(u(1))$，因此总熵是守恒的。\n\n如果一个数值格式满足此守恒性质的离散模拟，则该格式被认为是熵守恒的。我们将解近似为 $N$ 次多项式，并用其在一组 $N+1$ 个配置点 $x_i$ 上的值 $u_i$ 来表示。总离散熵为 $\\mathcal{U} = \\sum_{i=1}^{N+1} w_i U(u_i)$，其中 $w_i$ 是求积权重。\n\nDGSEM-SBP 格式使用离散微分算子 $D$ 和对角质量矩阵 $M = \\operatorname{diag}(w_i)$ 来构成一个分部求和 (SBP) 算子 $Q=MD$。这类算子的一个关键性质是 $Q+Q^T=B$，其中 $B$ 是一个边界矩阵，其非零项仅对应于区域端点。对于 GLL 节点，$B=\\operatorname{diag}(-1, 0, \\dots, 0, 1)$。对于任何 SBP 算子，我们还有 $D\\mathbf{1}=\\mathbf{0}$，这意味着 $Q\\mathbf{1}=\\mathbf{0}$。\n\n### 2. 朴素强形式离散的分析\n\n强形式的半离散化为 $\\frac{d u_h}{dt} = -D f(u_h)$，其中 $u_h$ 是节点值的向量。总离散熵的变化率为：\n$$\n\\frac{d\\mathcal{U}}{dt} = \\frac{d}{dt} \\sum_i w_i U(u_i) = \\sum_i w_i U'(u_i) \\frac{du_i}{dt} = v^T M \\frac{du_h}{dt}\n$$\n其中 $v_i = U'(u_i)$ 是熵变量。对于伯格斯方程，其中 $U(u) = \\frac{1}{2}u^2$，我们有 $v(u)=u$。代入半离散化，我们得到待评估的表达式：\n$$\n\\frac{d\\mathcal{U}}{dt} \\bigg|_{\\text{naive}} = v^T M (-D f(u_h)) = -v^T Q f(u_h)\n$$\n这种格式通常不是熵守恒的。乘积 $v^T Q f(u_h)$ 是积分 $\\int_{-1}^1 v(u) \\partial_x f(u) \\, dx$ 的离散近似。$f(u_h)$ 项涉及 $u_h$ 的一个非线性函数。如果 $u_h$ 由一个 $N$ 次多项式表示，那么 $f(u_h) = \\frac{1}{2}u_h^2$ 是一个 $2N$ 次多项式。整个表达式涉及的项的乘积，其多项式次数可能超过底层求积法则（GLL 或 Gauss）精确的次数。这种离散积分中的不精确性，即所谓的混叠，会导致非零的熵产生率，从而违反了守恒原理。\n\n### 3. 通量差分离散的分析\n\n通量差分方法重新构建了空间算子，以将守恒性质内建其中。总离散熵的变化率由下式给出：\n$$\n\\frac{d\\mathcal{U}}{dt} \\bigg|_{\\text{fd}} = -2 \\sum_{i=1}^{N+1}\\sum_{j=1}^{N+1} v_i \\, Q_{ij} \\, f^{ec}(u_i,u_j)\n$$\n其中 $f^{ec}(u_L, u_R)$ 是一个两点熵守恒通量。它是对称的，$f^{ec}(u_L, u_R) = f^{ec}(u_R, u_L)$，且是相容的，$f^{ec}(u,u) = f(u)$。最重要的是，它满足关系 $(v(u_L) - v(u_R))f^{ec}(u_L, u_R) = \\psi(u_L) - \\psi(u_R)$，其中 $\\psi(u)$ 是熵通量势。\n\n为了证明该格式是守恒的，我们对双重求和进行变换。我们使用恒等式 $2v_i = (v_i+v_j) + (v_i-v_j)$。\n$$\n\\begin{aligned}\n\\sum_{i,j} v_i Q_{ij} f^{ec}(u_i, u_j) = \\frac{1}{2} \\sum_{i,j} \\left( v_i Q_{ij} f^{ec}(u_i, u_j) + v_j Q_{ji} f^{ec}(u_j, u_i) \\right) \\quad (\\text{通过交换索引 } i,j) \\\\\n= \\frac{1}{2} \\sum_{i,j} \\left( v_i Q_{ij} + v_j Q_{ji} \\right) f^{ec}(u_i, u_j) \\quad (\\text{根据 } f^{ec} \\text{ 的对称性})\n\\end{aligned}\n$$\n对于体积项，使用适用于周期性问题的 SBP 斜对称形式性质 $Q_{ji} \\approx -Q_{ij}$，该项变为：\n$$\n\\frac{1}{2} \\sum_{i,j} (v_i-v_j) Q_{ij} f^{ec}(u_i,u_j) = \\frac{1}{2} \\sum_{i,j} Q_{ij} (v_i-v_j) f^{ec}(u_i,u_j)\n$$\n利用 EC 通量的性质 $(v_i-v_j)f^{ec}(u_i,u_j) = \\psi_i - \\psi_j$：\n$$\n= \\frac{1}{2} \\sum_{i,j} Q_{ij} (\\psi_i - \\psi_j) = \\frac{1}{2} \\left( \\sum_{i,j} Q_{ij}\\psi_i - \\sum_{i,j} Q_{ij}\\psi_j \\right)\n$$\n第一个和是 $\\sum_i \\psi_i \\left( \\sum_j Q_{ij} \\right)$。因为 $Q\\mathbf{1}=\\mathbf{0}$，所以行和 $\\sum_j Q_{ij}$ 为零。此项消失。第二个和是 $\\sum_j \\psi_j \\left( \\sum_i Q_{ij} \\right)$。这是 $\\sum_j \\psi_j (\\mathbf{1}^T Q)_j = \\psi^T (Q^T\\mathbf{1})$。根据 $Q+Q^T=B$ 和 $Q\\mathbf{1}=0$，我们有 $Q^T\\mathbf{1}=(B-Q)\\mathbf{1}=B\\mathbf{1}-Q\\mathbf{1}=B\\mathbf{1}$。\n因此，该和评估为：\n$$\n\\frac{d\\mathcal{U}}{dt} \\bigg|_{\\text{fd}} = -2 \\left( -\\frac{1}{2} \\psi^T B \\mathbf{1} \\right) = \\psi^T B \\mathbf{1}\n$$\n对于 GLL 节点，$B\\mathbf{1}$ 是向量 $[ -1, 0, \\dots, 0, 1 ]^T$。这得到 $\\psi^T B \\mathbf{1} = \\psi_{N+1} - \\psi_1$。对于基于 Gauss 的 SBP 算子，也有类似结果，其中边界算子 $B$ 提取单元边界上的值。对于周期性边界条件，$u(-1)=u(1)$，这意味着 $u_1=u_{N+1}$，因此 $\\psi_1 = \\psi_{N+1}$。边界项抵消，熵率恒等于零。这对于基于 GLL 和 Gauss 的 SBP 算子均成立，且与多项式次数无关。\n\n### 4. 实现与预期结果\n\n该实现计算了给定测试用例的这两个率。\n- **朴素率**：由于混叠效应，预期为非零，表明未能守恒熵。对于 Gauss 求积，此误差的量级可能比 GLL 小，因为 Gauss 法则对更高次多项式是精确的。\n- **通量差分率**：对于所有情况，预期为零（或在机器精度范围内），表明熵守恒格式的成功。\n\n代码将为每个测试用例执行以下操作：\n1.  为给定的次数 $N$，生成 GLL 和 Gauss 求积的节点 ($x_i$) 和权重 ($w_i$)。\n2.  为这些节点构建重心微分矩阵 $D$。\n3.  构造质量矩阵 $M=\\operatorname{diag}(w_i)$ 和 SBP 算子 $Q=MD$。\n4.  在节点处对初始条件 $u(x) = a \\sin(\\pi x) + b \\cos(3\\pi x)$ 进行采样。\n5.  计算朴素熵率 $|-v^T Q f(u)|$。\n6.  计算通量差分熵率 $|-2 \\sum_{i,j} v_i Q_{ij} f^{ec}(u_i,u_j)|$。\n7.  为每个测试用例返回这四个值（GLL 两个，Gauss 两个）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, legendre\n\ndef gll_nodes_weights(N):\n    \"\"\"\n    Computes N+1 Gauss-Legendre-Lobatto nodes and weights for polynomials of degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0])\n    \n    # Interior nodes are roots of P_N'(x), which are roots of Jacobi poly P_{N-1}^{(1,1)}(x)\n    if N > 1:\n        interior_nodes = roots_jacobi(N - 1, 1, 1)[0]\n    else: # N=1\n        interior_nodes = np.array([])\n        \n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights\n    PN_func = legendre(N)\n    weights = 2.0 / (N * (N + 1) * PN_func(nodes)**2)\n    \n    return nodes, weights\n\ndef gauss_nodes_weights(N):\n    \"\"\"\n    Computes N+1 Gauss-Legendre nodes and weights.\n    \"\"\"\n    # This rule is exact for polynomials of degree 2*(N+1)-1 = 2N+1\n    nodes, weights = np.polynomial.legendre.leggauss(N + 1)\n    return nodes, weights\n\ndef barycentric_diff_matrix(nodes):\n    \"\"\"\n    Computes the differentiation matrix for a given set of nodes using barycentric weights.\n    \"\"\"\n    n_points = len(nodes)\n    bary_weights = np.ones(n_points)\n    for j in range(n_points):\n        for k in range(n_points):\n            if k != j:\n                bary_weights[j] /= (nodes[j] - nodes[k])\n\n    D = np.zeros((n_points, n_points))\n    for i in range(n_points):\n        sum_row = 0.0\n        for j in range(n_points):\n            if i != j:\n                D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n                sum_row += D[i, j]\n        D[i, i] = -sum_row\n    return D\n\ndef calculate_entropy_rates(N, a, b, quadrature_type):\n    \"\"\"\n    Calculates the two discrete entropy rates for a given quadrature type.\n    \"\"\"\n    if quadrature_type == 'GLL':\n        nodes, weights = gll_nodes_weights(N)\n    elif quadrature_type == 'Gauss':\n        nodes, weights = gauss_nodes_weights(N)\n    else:\n        raise ValueError(\"Unknown quadrature type\")\n\n    # Construct SBP operators\n    D = barycentric_diff_matrix(nodes)\n    M = np.diag(weights)\n    Q = M @ D\n\n    # Sample the initial condition and define related quantities\n    u = a * np.sin(np.pi * nodes) + b * np.cos(3 * np.pi * nodes)\n    v = u  # Entropy variable for U(u) = u^2/2\n    f_u_vec = 0.5 * u**2  # Flux vector\n\n    # 1. Naive strong-form entropy rate\n    # rate = -v^T * Q * f(u)\n    rate_naive = -np.dot(v, Q @ f_u_vec)\n\n    # 2. Flux-differencing entropy rate\n    # rate = -2 * sum_{i,j} v_i * Q_ij * f^ec(u_i, u_j)\n    ui_col = u[:, np.newaxis]\n    uj_row = u[np.newaxis, :]\n    f_ec_matrix = (ui_col**2 + ui_col * uj_row + uj_row**2) / 6.0\n    \n    term_to_sum = v[:, np.newaxis] * Q * f_ec_matrix\n    rate_fd = -2.0 * np.sum(term_to_sum)\n    \n    return [np.abs(rate_naive), np.abs(rate_fd)]\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (5, 1.0, 0.1),\n        (1, 1.0, 0.5),\n        (12, 1.0, 1.0),\n        (8, 2.5, 2.0)\n    ]\n\n    results = []\n    for N, a, b in test_cases:\n        case_result = []\n        # GLL Quadrature\n        res_gll = calculate_entropy_rates(N, a, b, 'GLL')\n        case_result.extend(res_gll)\n        # Gauss Quadrature\n        res_gauss = calculate_entropy_rates(N, a, b, 'Gauss')\n        case_result.extend(res_gauss)\n        \n        results.append(case_result)\n\n    # Format the output string to match the required format\n    # e.g., [[r11,r12,r13,r14],[r21,r22,r23,r24],...]\n    formatted_results = []\n    for res_list in results:\n        formatted_results.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "求和分部（SBP）算子和间断Galerkin（DG）方法的威力在于其模块化特性，这使我们能够通过“拼接”简单的构建模块来为复杂几何问题构造稳定格式。本练习将熵稳定性的概念推广到网络图问题，其中多个计算域在节点处交汇。你将实现一个节点耦合条件，以保证在交汇处的熵耗散，从而展示局部耗散规则如何确保整个网络系统的全局稳定性 。",
            "id": "3384675",
            "problem": "考虑一个具有有限节点集和边集的连通度量图。每条边都被赋予一个方向、一个坐标参数和一个恒定的波速。设该图用 $\\mathcal{G} = (\\mathcal{V}, \\mathcal{E})$ 表示，其中节点集为 $\\mathcal{V}$，边集为 $\\mathcal{E}$。对每条边 $e \\in \\mathcal{E}$，引入局部坐标 $x \\in [0,L_e]$，边长 $L_e > 0$，以及恒定的平流速度 $a_e \\in \\mathbb{R} \\setminus \\{0\\}$。在每条边上，考虑标量线性守恒律\n$$\nu_t + a_e \\, u_x = 0 \\quad \\text{for } x \\in (0,L_e), \\; t > 0.\n$$\n采用二次熵 $U(u) = \\tfrac{1}{2} u^2$ 及相关的熵通量 $F(u) = a_e \\tfrac{1}{2} u^2$，两者均为逐边定义。使用对角范数分部求和 (SBP) 算子对每条边进行离散化（分部求和 (SBP) 指的是一个离散导数矩阵 $D = H^{-1} Q$，其中 $H$ 是一个对称正定对角范数矩阵，$Q$ 是一个满足 SBP 性质 $Q + Q^\\top = B$ 的矩阵，而 $B$ 代表边界提取，在一维情况下其签名为 $B = \\operatorname{diag}(-1,0,\\dots,0,1)$）。使用与熵稳定数值通量一致的同步近似项 (SAT) 罚项在图节点处耦合各边。在配备了类 SBP 微分矩阵的节点基上使用的间断伽辽金 (DG) 方法可以被置于同一框架下。\n\n从守恒律的基本熵平衡和 SBP 性质出发，可以证明图上的半离散离散熵，\n$$\n\\mathcal{E}(t) = \\sum_{e \\in \\mathcal{E}} \\frac{1}{2} u_e(t)^\\top H_e \\, u_e(t),\n$$\n满足\n$$\n\\frac{d}{dt} \\mathcal{E}(t) = \\sum_{e \\in \\mathcal{E}} \\left( -\\frac{a_e}{2} \\, u_e^\\top B_e \\, u_e \\right) + \\sum_{\\nu \\in \\mathcal{V}} \\mathcal{J}_\\nu(u|_\\nu),\n$$\n其中 $u|_\\nu$ 表示在节点 $\\nu$ 处各边端点的迹向量，$\\mathcal{J}_\\nu$ 汇集了在节点 $\\nu$ 处的 SAT 耦合贡献。对于一个熵稳定的节点耦合，节点贡献 $\\mathcal{J}_\\nu$ 必须为非正，以确保 $\\mathcal{E}(t)$ 是非增的。\n\n对于标量情况，可以通过定义单个节点状态 $w_\\nu$ 并根据特征强度使用系数惩罚与 $w_\\nu$ 的偏差，来获得一个熵耗散且守恒的节点耦合。设在节点 $\\nu$ 处的入射半边集由 $i = 1,\\dots, m_\\nu$ 索引，其带符号边速度为 $a_i \\in \\mathbb{R} \\setminus \\{0\\}$，端点状态为 $u_i \\in \\mathbb{R}$。将节点状态 $w_\\nu$ 定义为加权平均值\n$$\nw_\\nu = \\frac{\\sum_{i=1}^{m_\\nu} |a_i| \\, u_i}{\\sum_{i=1}^{m_\\nu} |a_i|}.\n$$\n则节点熵产生为\n$$\n\\mathcal{J}_\\nu(u|_\\nu) = -\\frac{1}{2} \\sum_{i=1}^{m_\\nu} |a_i| \\, (u_i - w_\\nu)^2 \\le 0,\n$$\n这是纯耗散的，并且当且仅当对于节点 $\\nu$ 处的所有入射半边都有 $u_i = w_\\nu$ 时，其值为零。对于一个没有外部边界的图（即所有边端点都连接到节点），SBP 内部贡献项会相互对消，全局熵产生简化为节点贡献项之和，而该和为非正。\n\n问题。用一种通用编程语言实现一个函数，该函数在给定一个节点及其入射的带符号速度和状态列表后，计算节点熵产生值\n$$\n\\mathcal{J}_\\nu = -\\frac{1}{2} \\sum_{i=1}^{m_\\nu} |a_i| (u_i - w_\\nu)^2,\n$$\n其中\n$$\nw_\\nu = \\frac{\\sum_{i=1}^{m_\\nu} |a_i| u_i}{\\sum_{i=1}^{m_\\nu} |a_i|}.\n$$\n如果分母 $\\sum_{i=1}^{m_\\nu} |a_i|$ 为零，按照约定返回 $\\mathcal{J}_\\nu = 0$。每个测试的输入是附于单个节点的带符号速度列表 $\\{a_i\\}_{i=1}^{m_\\nu}$ 和状态列表 $\\{u_i\\}_{i=1}^{m_\\nu}$。每个测试的输出是等于 $\\mathcal{J}_\\nu$ 的单个实数（浮点数）。\n\n程序必须为以下测试套件计算节点熵产生，并以要求的最终输出格式打印结果。\n\n测试套件：\n- 测试 $1$：$m_\\nu = 2$，速度 $[a_1, a_2] = [1.0, -2.0]$，状态 $[u_1, u_2] = [1.0, -0.5]$。预期的定性属性：严格负耗散。\n- 测试 $2$：$m_\\nu = 3$，速度 $[a_1, a_2, a_3] = [1.0, 3.0, 0.5]$，状态 $[u_1, u_2, u_3] = [2.0, -1.0, 4.0]$。预期的定性属性：严格负耗散。\n- 测试 $3$：$m_\\nu = 4$，速度 $[a_1, a_2, a_3, a_4] = [0.8, 1.2, 5.0, 3.0]$，状态 $[u_1, u_2, u_3, u_4] = [3.0, 3.0, 3.0, 3.0]$。预期的定性属性：零耗散。\n- 测试 $4$：$m_\\nu = 1$，速度 $[a_1] = [2.5]$，状态 $[u_1] = [-7.0]$。预期的定性属性：零耗散。\n- 测试 $5$：$m_\\nu = 2$，速度 $[a_1, a_2] = [1000.0, 1.0]$，状态 $[u_1, u_2] = [0.0, 10.0]$。预期的定性属性：由小权重、大偏差一侧主导的严格负耗散。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试 $1$ 到 $5$ 的顺序排列的结果，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是测试 $k$ 的等于 $\\mathcal{J}_\\nu$ 的浮点数。\n- 不应打印任何其他文本。",
            "solution": "所述问题在科学上是合理的，内容是自洽的，并且在数学上是适定的。所有前提都基于守恒律数值方法的既有理论，特别是关于网络图上分部求和 (SBP) 离散化的熵稳定性。所提供的定义和公式是该领域的标准。因此，我们可以着手求解。\n\n目标是计算度量图节点 $\\nu$ 处的节点熵产生，记为 $\\mathcal{J}_\\nu$。这个量表示由于该节点处入射边的耦合所引起的熵变率。为了使数值格式是熵稳定的（或至少是不产生熵的），该贡献必须为非正，即 $\\mathcal{J}_\\nu \\le 0$。\n\n问题为单个节点 $\\nu$ 提供了以下数据：\n1. 一组 $m_\\nu$ 条入射半边，每条都有一个带符号的平流速度 $a_i \\in \\mathbb{R} \\setminus \\{0\\}$。\n2. 连接到节点 $\\nu$ 的边端点处相应的 $m_\\nu$ 个标量状态 $u_i \\in \\mathbb{R}$。\n\n节点熵产生 $\\mathcal{J}_\\nu$ 由以下公式定义：\n$$\n\\mathcal{J}_\\nu = -\\frac{1}{2} \\sum_{i=1}^{m_\\nu} |a_i| (u_i - w_\\nu)^2\n$$\n其中 $w_\\nu$ 是一个中间节点状态，定义为入射状态的加权平均值：\n$$\nw_\\nu = \\frac{\\sum_{i=1}^{m_\\nu} |a_i| u_i}{\\sum_{i=1}^{m_\\nu} |a_i|}\n$$\n权重是速度的绝对值 $|a_i|$，可以解释为从边 $i$ 到达节点的信息的“特征强度”的度量。按照约定，如果入射边的数量为零（$m_\\nu=0$），则分母 $\\sum |a_i|$ 为零，我们定义 $\\mathcal{J}_\\nu = 0$。由于问题规定任何入射边的 $a_i \\ne 0$，因此只有在没有边存在的情况下，该分母才为零。\n\n从其定义可以明显看出 $\\mathcal{J}_\\nu$ 的非正性。由于 $|a_i| > 0$ 且 $(u_i - w_\\nu)^2 \\ge 0$，求和中的每一项都是非负的。因此整个和是非负的，乘以 $-\\frac{1}{2}$ 确保了 $\\mathcal{J}_\\nu \\le 0$。除非所有入射状态都相同，即 $u_1 = u_2 = \\dots = u_{m_\\nu}$，否则熵产生是严格为负的（耗散的）。在这种特定情况下，节点状态 $w_\\nu$ 变为：\n$$\nw_\\nu = \\frac{\\sum_{i=1}^{m_\\nu} |a_i| u_1}{\\sum_{i=1}^{m_\\nu} |a_i|} = u_1 \\frac{\\sum_{i=1}^{m_\\nu} |a_i|}{\\sum_{i=1}^{m_\\nu} |a_i|} = u_1\n$$\n这意味着对于所有的 $i$，都有 $u_i - w_\\nu = 0$，导致求和项消失，从而得到 $\\mathcal{J}_\\nu = 0$。这在物理上是一致的：如果所有连接分支上的状态已经处于平衡状态，则在连接点处不会发生耗散。这种情况的一个特例是只有一个入射边的节点（$m_\\nu = 1$），此时我们显然有 $w_\\nu = u_1$，因此 $\\mathcal{J}_\\nu = 0$。\n\n我们现在将为所提供的每个测试用例计算 $\\mathcal{J}_\\nu$ 的值。\n\n**测试 1：**\n- 速度：$a = [\\, 1.0, \\, -2.0 \\,]$\n- 状态：$u = [\\, 1.0, \\, -0.5 \\,]$\n首先，我们计算绝对速度：$|a| = [\\, 1.0, \\, 2.0 \\,]$。\n绝对速度之和为 $\\sum |a_i| = 1.0 + 2.0 = 3.0$。\n状态的加权和为 $\\sum |a_i| u_i = (1.0)(1.0) + (2.0)(-0.5) = 1.0 - 1.0 = 0.0$。\n节点状态为 $w_\\nu = \\frac{0.0}{3.0} = 0.0$。\n熵产生为：\n$$\n\\mathcal{J}_\\nu = -\\frac{1}{2} \\left[ |1.0| (1.0 - 0.0)^2 + |-2.0| (-0.5 - 0.0)^2 \\right]\n= -\\frac{1}{2} \\left[ 1.0 \\cdot (1.0)^2 + 2.0 \\cdot (-0.5)^2 \\right]\n= -\\frac{1}{2} [ 1.0 + 2.0 \\cdot 0.25 ]\n= -\\frac{1}{2} [ 1.0 + 0.5 ]\n= -0.75\n$$\n\n**测试 2：**\n- 速度：$a = [\\, 1.0, \\, 3.0, \\, 0.5 \\,]$\n- 状态：$u = [\\, 2.0, \\, -1.0, \\, 4.0 \\,]$\n绝对速度：$|a| = [\\, 1.0, \\, 3.0, \\, 0.5 \\,]$。\n绝对速度之和：$\\sum |a_i| = 1.0 + 3.0 + 0.5 = 4.5$。\n状态的加权和：$\\sum |a_i| u_i = (1.0)(2.0) + (3.0)(-1.0) + (0.5)(4.0) = 2.0 - 3.0 + 2.0 = 1.0$。\n节点状态：$w_\\nu = \\frac{1.0}{4.5} = \\frac{2}{9}$。\n熵产生：\n$$\n\\mathcal{J}_\\nu = -\\frac{1}{2} \\left[ 1.0 \\left(2 - \\frac{2}{9}\\right)^2 + 3.0 \\left(-1 - \\frac{2}{9}\\right)^2 + 0.5 \\left(4 - \\frac{2}{9}\\right)^2 \\right]\n= -\\frac{1}{2} \\left[ 1.0 \\left(\\frac{16}{9}\\right)^2 + 3.0 \\left(\\frac{-11}{9}\\right)^2 + 0.5 \\left(\\frac{34}{9}\\right)^2 \\right]\n= -\\frac{1}{2 \\cdot 81} [ 256 + 3 \\cdot 121 + 0.5 \\cdot 1156 ]\n= -\\frac{1}{162} [ 256 + 363 + 578 ]\n= -\\frac{1197}{162} = -\\frac{133}{18} \\approx -7.3888...\n$$\n\n**测试 3：**\n- 速度：$a = [\\, 0.8, \\, 1.2, \\, 5.0, \\, 3.0 \\,]$\n- 状态：$u = [\\, 3.0, \\, 3.0, \\, 3.0, \\, 3.0 \\,]$\n所有状态 $u_i$ 都等于 $3.0$。如前所述，这直接意味着 $w_\\nu = 3.0$，因此对所有 $i$ 都有 $u_i - w_\\nu = 0$。\n熵产生为 $\\mathcal{J}_\\nu = 0.0$。\n\n**测试 4：**\n- 速度：$a = [\\, 2.5 \\,]$\n- 状态：$u = [\\, -7.0 \\,]$\n只有一个入射边（$m_\\nu = 1$）。如前所述，这意味着 $w_\\nu = u_1 = -7.0$。\n熵产生为 $\\mathcal{J}_\\nu = -\\frac{1}{2} |2.5|(-7.0 - (-7.0))^2 = 0.0$。\n\n**测试 5：**\n- 速度：$a = [\\, 1000.0, \\, 1.0 \\,]$\n- 状态：$u = [\\, 0.0, \\, 10.0 \\,]$\n绝对速度：$|a| = [\\, 1000.0, \\, 1.0 \\,]$。\n绝对速度之和：$\\sum |a_i| = 1000.0 + 1.0 = 1001.0$。\n状态的加权和：$\\sum |a_i| u_i = (1000.0)(0.0) + (1.0)(10.0) = 10.0$。\n节点状态：$w_\\nu = \\frac{10.0}{1001.0}$。\n对于 $m_\\nu=2$ 的情况，可以推导出 $\\mathcal{J}_\\nu$ 的简化表达式：\n$$\n\\mathcal{J}_\\nu = -\\frac{1}{2} \\frac{|a_1| |a_2|}{|a_1| + |a_2|} (u_1 - u_2)^2\n$$\n使用这个简化式：\n$$\n\\mathcal{J}_\\nu = -\\frac{1}{2} \\frac{1000.0 \\cdot 1.0}{1000.0 + 1.0} (0.0 - 10.0)^2\n= -\\frac{1}{2} \\frac{1000.0}{1001.0} (-10.0)^2\n= -\\frac{1}{2} \\frac{1000.0}{1001.0} \\cdot 100.0\n= -\\frac{50000}{1001} \\approx -49.9500...\n$$\n计算结果证实了所有测试用例的预期定性行为。实现将遵循 $\\mathcal{J}_\\nu$ 的通用公式，以处理任意数量的入射边 $m_\\nu$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_node_entropy_production(speeds: list[float], states: list[float]) -> float:\n    \"\"\"\n    Computes the node entropy production J_nu for a set of incident edges.\n\n    Args:\n        speeds: A list of signed advection speeds [a_1, a_2, ...].\n        states: A list of scalar states [u_1, u_2, ...] at the node.\n\n    Returns:\n        The computed node entropy production value (a float).\n    \"\"\"\n    # Use numpy arrays for efficient, vectorized calculations.\n    a = np.array(speeds)\n    u = np.array(states)\n\n    if a.size == 0:\n        return 0.0\n\n    abs_a = np.abs(a)\n    sum_abs_a = np.sum(abs_a)\n\n    # Per the problem statement, if the denominator is zero, J_nu is zero.\n    # This also handles the case of an empty set of incident edges.\n    if sum_abs_a == 0:\n        return 0.0\n\n    # Calculate the weighted average nodal state w_nu.\n    # w_nu = (sum |a_i| * u_i) / (sum |a_i|)\n    weighted_sum_u = np.sum(abs_a * u)\n    w_nu = weighted_sum_u / sum_abs_a\n\n    # Calculate the sum term in the J_nu formula.\n    # sum_term = sum( |a_i| * (u_i - w_nu)^2 )\n    deviations = u - w_nu\n    sum_term = np.sum(abs_a * (deviations**2))\n    \n    # Calculate the final node entropy production J_nu.\n    J_nu = -0.5 * sum_term\n    \n    return J_nu\n\ndef solve():\n    \"\"\"\n    Runs the defined test suite and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        ([1.0, -2.0], [1.0, -0.5]),\n        # Test 2\n        ([1.0, 3.0, 0.5], [2.0, -1.0, 4.0]),\n        # Test 3\n        ([0.8, 1.2, 5.0, 3.0], [3.0, 3.0, 3.0, 3.0]),\n        # Test 4\n        ([2.5], [-7.0]),\n        # Test 5\n        ([1000.0, 1.0], [0.0, 10.0]),\n    ]\n\n    results = []\n    for speeds, states in test_cases:\n        result = compute_node_entropy_production(speeds, states)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}