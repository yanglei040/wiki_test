{
    "hands_on_practices": [
        {
            "introduction": "为了建立坚实的理解，我们从一个基础练习开始。该问题将后处理机制剥离至其本质，探讨了一个精确解是简单多项式的场景。通过解析地解决这个案例 ，您将发现其精确性原理，并亲眼见证后处理解 $u_h^\\star$ 如何完美地重构真实解，从而揭示其“超收敛”能力的来源。",
            "id": "3410138",
            "problem": "考虑在单个凸多边形单元 $K = [0,1] \\times [0,1]$ 上的稳态扩散模型问题，该问题具有恒定的扩散系数，由偏微分方程 $-\\Delta u = f$ 和狄利克雷边界条件 $u|_{\\partial K} = g$ 控制。设在 $K$ 上的精确（制造）解为 $u(x,y) = x^{2} + y^{2}$。那么，在 $\\partial K$ 上有 $f(x,y) = -\\Delta u(x,y)$ 和 $g(x,y) = u(x,y)$。\n\n令 $\\mathcal{P}_{k}(K)$ 表示在 $K$ 上总次数至多为 $k$ 的多项式空间，并设可杂交间断伽辽金 (HDG) 方法的局部空间为 $\\boldsymbol{q}_{h} \\in [\\mathcal{P}_{k}(K)]^{2}$、$u_{h} \\in \\mathcal{P}_{k}(K)$，以及在 $\\partial K$ 上的数值迹 $\\widehat{u}_{h}$（单单元设置）。假设 $k=1$ 且计算得到的 HDG 通量 $\\boldsymbol{q}_{h}$ 等于精确通量 $\\nabla u$ 到 $[\\mathcal{P}_{1}(K)]^{2}$ 上的 $L^{2}(K)$-投影。由于 $\\nabla u(x,y) = (2x,2y)$ 已经属于 $[\\mathcal{P}_{1}(K)]^{2}$，这个假设意味着在 $K$ 上有 $\\boldsymbol{q}_{h} = \\nabla u$。\n\n将标准 HDG 后处理 $u_{h}^{\\star} \\in \\mathcal{P}_{k+1}(K)$ 定义为满足以下条件的唯一多项式：对于所有 $w \\in \\mathcal{P}_{k+1}(K)$，\n$$(\\nabla u_{h}^{\\star}, \\nabla w)_{K} = (\\boldsymbol{q}_{h}, \\nabla w)_{K},$$\n以及平均值约束\n$$\\int_{K} u_{h}^{\\star} \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u \\,\\mathrm{d}\\boldsymbol{x}。$$\n此处，$(\\cdot,\\cdot)_{K}$ 表示 $L^{2}(K)$ 内积，$\\mathrm{d}\\boldsymbol{x}$ 是 $K$ 上的面积测度。\n\n从上述定义和制造数据出发，显式地导出 $u_{h}^{\\star}(x,y)$，并验证该后处理在此单单元问题上所蕴含的阶数和精确性属性。您的最终答案必须是关于 $x$ 和 $y$ 的 $u_{h}^{\\star}(x,y)$ 的单一闭式解析表达式。无需进行数值舍入。",
            "solution": "该问题是有效的，因为它是数学上适定的，在数值分析领域有其科学依据，并提供了一套完整且一致的定义和数据。\n\n任务是在单个方形单元 $K = [0,1] \\times [0,1]$ 上，导出后处理的可杂交间断伽辽金 (HDG) 解的显式形式，记为 $u_h^\\star(x,y)$。局部 HDG 空间的多项式阶数为 $k=1$。\n\n后处理解 $u_h^\\star \\in \\mathcal{P}_{k+1}(K) = \\mathcal{P}_{2}(K)$ 的定义属性由两个条件给出：\n1.  一个变分方程：\n    $$(\\nabla u_{h}^{\\star}, \\nabla w)_{K} = (\\boldsymbol{q}_{h}, \\nabla w)_{K}, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n2.  一个平均值约束：\n    $$\\int_{K} u_{h}^{\\star} \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u \\,\\mathrm{d}\\boldsymbol{x}$$\n此处，$(\\cdot, \\cdot)_{K}$ 表示域 $K$ 上的标准 $L^2$ 内积。\n\n首先，我们必须确定 HDG 通量近似 $\\boldsymbol{q}_h$。问题陈述 $\\boldsymbol{q}_h$ 是精确通量 $\\nabla u$ 到多项式空间 $[\\mathcal{P}_{k}(K)]^2$ 上的 $L^2(K)$-投影，当 $k=1$ 时，该空间为 $[\\mathcal{P}_{1}(K)]^2$。\n\n精确解为 $u(x,y) = x^2 + y^2$。\n精确通量是 $u$ 的梯度：\n$$\\nabla u(x,y) = \\left( \\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y} \\right) = (2x, 2y)$$\n向量场 $\\nabla u$ 的每个分量都是一个 1 次多项式。因此，精确通量 $\\nabla u$ 已经是投影目标空间 $[\\mathcal{P}_{1}(K)]^2$ 中的一个元素。\n一个元素到已包含该元素空间的 $L^2$-投影就是该元素本身。\n因此，我们有 $\\boldsymbol{q}_h = \\nabla u = (2x, 2y)$。\n\n现在，我们将 $\\boldsymbol{q}_h$ 的这个结果代入定义 $u_h^\\star$ 的变分方程中：\n$$(\\nabla u_{h}^{\\star}, \\nabla w)_{K} = (\\nabla u, \\nabla w)_{K}, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n根据内积的线性性质，该方程可以重写为：\n$$(\\nabla u_{h}^{\\star} - \\nabla u, \\nabla w)_{K} = 0$$\n化简为：\n$$(\\nabla (u_{h}^{\\star} - u), \\nabla w)_{K} = 0, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n让我们将后处理解的误差定义为 $e_u^\\star = u_h^\\star - u$。方程变为：\n$$(\\nabla e_u^\\star, \\nabla w)_{K} = 0, \\quad \\forall w \\in \\mathcal{P}_{2}(K)$$\n我们知道精确解 $u(x,y) = x^2+y^2$ 是一个 2 次多项式，所以 $u \\in \\mathcal{P}_{2}(K)$。后处理解 $u_h^\\star$ 也在空间 $\\mathcal{P}_{2}(K)$ 中寻找。因此，它们的差，即误差 $e_u^\\star$，也必须是 $\\mathcal{P}_{2}(K)$ 中的一个多项式。\n\n由于 $e_u^\\star \\in \\mathcal{P}_{2}(K)$，我们可以自由选择测试函数 $w$ 为 $e_u^\\star$ 本身。进行此代换，我们得到：\n$$(\\nabla e_u^\\star, \\nabla e_u^\\star)_{K} = 0$$\n这个内积是 $e_u^\\star$ 梯度的 $L^2$-范数的平方的定义：\n$$\\int_{K} |\\nabla e_u^\\star|^2 \\,\\mathrm{d}\\boldsymbol{x} = 0$$\n被积函数 $|\\nabla e_u^\\star|^2$ 是一个非负连续函数。要使其在具有正测度（面积 Area$(K)=1$）的域 $K$ 上的积分为零，被积函数必须在整个 $K$ 上恒为零。\n$$|\\nabla e_u^\\star(\\boldsymbol{x})|^2 = 0 \\quad \\forall \\boldsymbol{x} \\in K$$\n这意味着梯度本身在 $K$ 中处处为零向量：\n$$\\nabla e_u^\\star(\\boldsymbol{x}) = \\boldsymbol{0} \\quad \\forall \\boldsymbol{x} \\in K$$\n在一个连通域上梯度处处为零的函数在该域上必为常数。因此，$e_u^\\star(\\boldsymbol{x}) = C$，其中 $C$ 为某个实常数。\n回顾 $e_u^\\star$ 的定义，我们有 $u_h^\\star(\\boldsymbol{x}) - u(\\boldsymbol{x}) = C$，即 $u_h^\\star(\\boldsymbol{x}) = u(\\boldsymbol{x}) + C$。\n\n为了确定常数 $C$ 的值，我们现在应用第二个条件，即平均值约束：\n$$\\int_{K} u_{h}^{\\star} \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u \\,\\mathrm{d}\\boldsymbol{x}$$\n将 $u_h^\\star = u+C$ 代入此方程得到：\n$$\\int_{K} (u(\\boldsymbol{x}) + C) \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$$\n左侧的积分可以拆分为：\n$$\\int_{K} u(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x} + \\int_{K} C \\,\\mathrm{d}\\boldsymbol{x} = \\int_{K} u(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$$\n从两边减去 $\\int_K u(\\boldsymbol{x}) d\\boldsymbol{x}$ 剩下：\n$$\\int_{K} C \\,\\mathrm{d}\\boldsymbol{x} = 0$$\n$$C \\int_{K} \\,\\mathrm{d}\\boldsymbol{x} = 0$$\n积分 $\\int_K d\\boldsymbol{x}$ 代表域 $K = [0,1] \\times [0,1]$ 的面积，即为 $1$。\n$$C \\cdot 1 = 0 \\implies C=0$$\n由于常数 $C$ 为零，误差 $e_u^\\star$ 恒等于零。因此，后处理解与精确解相同：\n$$u_h^\\star(\\boldsymbol{x}) = u(\\boldsymbol{x})$$\n代入给定的 $u(x,y)$ 表达式：\n$$u_h^\\star(x,y) = x^2 + y^2$$\n\n最后，我们验证此结果的属性。导出的解 $u_h^\\star(x,y) = x^2 + y^2$ 是一个总次数为 2 的多项式，这与 $u_h^\\star \\in \\mathcal{P}_{k+1}(K) = \\mathcal{P}_{2}(K)$ 的要求一致。结果 $u_h^\\star=u$ 展示了 HDG 后处理在此特定情况下的精确性属性。这是一个已知的理论结果：对于单个单元，如果精确解 $u$ 是一个次数至多为 $k+1$ 的多项式（此处，$u \\in \\mathcal{P}_2$ 且 $k=1$），则后处理解 $u_h^\\star$ 是精确的。我们的推导证实了这种超收敛性质。",
            "answer": "$$\n\\boxed{x^{2} + y^{2}}\n$$"
        },
        {
            "introduction": "现实世界的问题通常具有主导性的物理效应，例如强对流，这会引入各向异性。本练习挑战您超越标准的各向同性框架，为这类场景设计一个修正的后处理算子。通过引入一个与对流场对齐的加权范数 ，您将学习如何调整后处理策略，以选择性地提高特定方向上的精度，这是高级数值模拟中的一项关键技术。",
            "id": "3410083",
            "problem": "考虑单个单元 $K \\subset \\mathbb{R}^{2}$ 上的标量对流扩散模型问题，其中对流场 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{2}$ 为常数，扩散系数 $\\epsilon > 0$。令可杂交间断伽辽金(HDG)方法在单元 $K$ 上生成一个梯度的单元局部近似，记为 $\\boldsymbol{q}_{h}$，其多项式次数为 $k$。经典的超收敛后处理通过定义 $u^{\\star} \\in \\mathcal{P}_{k+1}(K)$ 为唯一的零均值多项式，将解的次数提升到 $k+1$。该多项式满足一个梯度匹配的变分条件，该条件对 $\\mathcal{P}_{k+1}(K)$ 中所有零均值测试函数均成立。\n\n在各向异性对流扩散问题中，考虑一个由与 $\\boldsymbol{\\beta}$ 对齐的加权投影定义的修正后处理算子。引入对称正定权重矩阵\n$$\n\\mathbf{M} \\;=\\; \\mathbf{I} \\;+\\; \\gamma \\,\\frac{\\boldsymbol{\\beta}\\,\\boldsymbol{\\beta}^{\\top}}{|\\boldsymbol{\\beta}|^{2}},\n$$\n其中 $\\gamma \\geq 0$，并定义零均值的 $u^{\\star} \\in \\mathcal{P}_{k+1}(K)$，使其对每一个零均值的 $v \\in \\mathcal{P}_{k+1}(K)$ 满足：\n$$\n\\int_{K} \\big( \\mathbf{M}\\,\\nabla u^{\\star} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x} \\;=\\; \\int_{K} \\big( \\mathbf{M}\\,\\boldsymbol{q}_{h} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x}.\n$$\n从 $\\mathcal{P}_{k+1}(K)$、正交性以及加权 $L^{2}$ 投影的定义出发，推导上述算子，并将其具体化到参考单元 $K = [0,1]^{2}$ 上，其中 $\\boldsymbol{\\beta} = (1,0)^{\\top}$ 为常数，此时\n$$\n\\mathbf{M} \\;=\\; \\begin{pmatrix} 1+\\gamma  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n令 $k=1$，因此 $u^{\\star} \\in \\mathcal{P}_{2}(K)$，并假设HDG梯度近似为如下线性场：\n$$\n\\boldsymbol{q}_{h}(x,y) \\;=\\; \\begin{pmatrix} \\mu\\,x + \\nu\\,y \\\\ \\rho\\,x + \\sigma\\,y \\end{pmatrix},\n$$\n其中 $\\mu, \\nu, \\rho, \\sigma$ 为给定的实系数。将 $u^{\\star}$ 参数化为：\n$$\nu^{\\star}(x,y) \\;=\\; \\tfrac{1}{2}\\,a\\,x^{2} \\;+\\; b\\,x\\,y \\;+\\; \\tfrac{1}{2}\\,c\\,y^{2} \\;+\\; d\\,x \\;+\\; e\\,y \\;+\\; g,\n$$\n并施加零均值约束 $\\int_{K} u^{\\star}\\,\\mathrm{d}\\boldsymbol{x} = 0$ 来确定 $g$。仅使用多项式空间的基本性质、加权投影以及混合偏导数的对称性，通过最小化加权残差泛函\n$$\nJ(a,b,c,d,e) \\;=\\; \\int_{K} \\Big( \\nabla u^{\\star}(x,y) \\;-\\; \\boldsymbol{q}_{h}(x,y) \\Big)^{\\top} \\mathbf{M} \\Big( \\nabla u^{\\star}(x,y) \\;-\\; \\boldsymbol{q}_{h}(x,y) \\Big)\\,\\mathrm{d}\\boldsymbol{x}\n$$\n来推导系数 $a,b,c,d,e$ 的法方程。显式求解这些方程，并给出交叉项系数 $b$ 关于 $\\gamma$、$\\nu$ 和 $\\rho$ 的闭式解析表达式。最后，根据你的推导，就增大 $\\gamma$ 如何影响后处理误差沿着及垂直于 $\\boldsymbol{\\beta}$ 方向的各向异性提出假设。你的最终答案必须是所要求的 $b$ 作为 $\\gamma$、$\\nu$ 和 $\\rho$ 的函数表达式。",
            "solution": "用户提供了一个数值分析领域的问题，具体涉及可杂交间断伽辽金(HDG)方法的后处理技术。我将首先验证问题陈述的有效性，然后进行完整的推导。\n\n### 步骤1：提取已知条件\n- **模型问题**：单元 $K \\subset \\mathbb{R}^{2}$ 上的标量对流扩散问题。\n- **参数**：常数对流场 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{2}$，扩散系数 $\\epsilon > 0$。\n- **HDG近似**：$k$ 次多项式的单元局部梯度近似 $\\boldsymbol{q}_{h}$。\n- **后处理解**：$u^{\\star} \\in \\mathcal{P}_{k+1}(K)$，具有零均值，$\\int_K u^{\\star} \\, \\mathrm{d}\\boldsymbol{x} = 0$。\n- **权重矩阵**：$\\mathbf{M} = \\mathbf{I} + \\gamma \\frac{\\boldsymbol{\\beta}\\,\\boldsymbol{\\beta}^{\\top}}{|\\boldsymbol{\\beta}|^{2}}$，其中 $\\gamma \\geq 0$。\n- **变分形式**：对每一个零均值的 $v \\in \\mathcal{P}_{k+1}(K)$，\n$$ \\int_{K} \\big( \\mathbf{M}\\,\\nabla u^{\\star} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x} = \\int_{K} \\big( \\mathbf{M}\\,\\boldsymbol{q}_{h} \\big)\\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x}. $$\n- **最小化泛函**：$J(a,b,c,d,e) = \\int_{K} \\Big( \\nabla u^{\\star}(x,y) - \\boldsymbol{q}_{h}(x,y) \\Big)^{\\top} \\mathbf{M} \\Big( \\nabla u^{\\star}(x,y) - \\boldsymbol{q}_{h}(x,y) \\Big)\\,\\mathrm{d}\\boldsymbol{x}$。\n- **具体化**：\n    - 参考单元：$K = [0,1]^{2}$。\n    - 对流场：$\\boldsymbol{\\beta} = (1,0)^{\\top}$。\n    - 得到的权重矩阵：$\\mathbf{M} = \\begin{pmatrix} 1+\\gamma  0 \\\\ 0  1 \\end{pmatrix}$。\n    - 多项式次数：$k=1$，因此 $u^{\\star} \\in \\mathcal{P}_{2}(K)$。\n- **参数化**：\n    - HDG梯度：$\\boldsymbol{q}_{h}(x,y) = \\begin{pmatrix} \\mu\\,x + \\nu\\,y \\\\ \\rho\\,x + \\sigma\\,y \\end{pmatrix}$。\n    - 后处理解：$u^{\\star}(x,y) = \\frac{1}{2}\\,a\\,x^{2} + b\\,x\\,y + \\frac{1}{2}\\,c\\,y^{2} + d\\,x + e\\,y + g$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，建立在有限元方法和逼近理论等公认的数学框架之内。HDG方法、多项式空间、加权投影和变分原理等概念是计算数学中的标准内容。该问题是适定的；它要求通过最小化一个二次泛函来推导系数，该过程会导出一个定义明确的线性方程组。其语言客观、正式且精确。没有矛盾、信息缺失或伪科学的主张。该问题是应用数学中一个有效且有意义的练习。\n\n### 步骤3：结论与行动\n问题有效。我将继续进行推导。\n\n### 推导\n问题要求通过最小化泛函 $J$ 来推导后处理解 $u^{\\star}$ 的系数的法方程，然后求解系数 $b$。所提供的变分形式是与二次泛函 $J$ 的最小化问题相关联的欧拉-拉格朗日方程。对 $J$ 关于其参数 $(a,b,c,d,e)$ 进行最小化，等价于寻找其驻点，在该点处 $J$ 对每个参数的偏导数均为零。\n\n首先，我们表示出 $u^{\\star}$ 的梯度：\n$$ \\nabla u^{\\star}(x,y) = \\begin{pmatrix} \\partial_x u^{\\star} \\\\ \\partial_y u^{\\star} \\end{pmatrix} = \\begin{pmatrix} a\\,x + b\\,y + d \\\\ b\\,x + c\\,y + e \\end{pmatrix} $$\n误差向量 $\\boldsymbol{\\delta} = \\nabla u^{\\star} - \\boldsymbol{q}_h$ 为：\n$$ \\boldsymbol{\\delta}(x,y) = \\begin{pmatrix} (a-\\mu)x + (b-\\nu)y + d \\\\ (b-\\rho)x + (c-\\sigma)y + e \\end{pmatrix} $$\n需要最小化的泛函 $J$ 是该误差的加权平方范数在定义域 $K = [0,1]^2$ 上的积分：\n$$ J = \\int_0^1 \\int_0^1 \\boldsymbol{\\delta}^{\\top} \\mathbf{M} \\boldsymbol{\\delta} \\,\\mathrm{d}x\\,\\mathrm{d}y $$\n代入 $\\boldsymbol{\\delta}$ 和 $\\mathbf{M}$ 的表达式：\n$$ J = \\int_K \\left[ (1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big)^2 + \\big((b-\\rho)x + (c-\\sigma)y + e\\big)^2 \\right] \\mathrm{d}\\boldsymbol{x} $$\n通过将 $J$ 对五个系数 $a, b, c, d, e$ 中每一个的偏导数设为零，可以得到法方程。我们利用恒等式 $\\int_0^1 \\int_0^1 x^i y^j \\,\\mathrm{d}x\\,\\mathrm{d}y = \\frac{1}{(i+1)(j+1)}$。\n\n1.  $\\frac{\\partial J}{\\partial a} = 0$:\n    $$ \\int_K 2(1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big)x \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(ax^2 + bxy + dx\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\mu x^2 + \\nu xy\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ a\\frac{1}{3} + b\\frac{1}{4} + d\\frac{1}{2} = \\mu\\frac{1}{3} + \\nu\\frac{1}{4} \\quad (1) $$\n\n2.  $\\frac{\\partial J}{\\partial c} = 0$:\n    $$ \\int_K 2\\big((b-\\rho)x + (c-\\sigma)y + e\\big)y \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(bxy + cy^2 + ey\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\rho xy + \\sigma y^2\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ b\\frac{1}{4} + c\\frac{1}{3} + e\\frac{1}{2} = \\rho\\frac{1}{4} + \\sigma\\frac{1}{3} \\quad (2) $$\n\n3.  $\\frac{\\partial J}{\\partial d} = 0$:\n    $$ \\int_K 2(1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big) \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(ax + by + d\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\mu x + \\nu y\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ a\\frac{1}{2} + b\\frac{1}{2} + d = \\mu\\frac{1}{2} + \\nu\\frac{1}{2} \\quad (3) $$\n\n4.  $\\frac{\\partial J}{\\partial e} = 0$:\n    $$ \\int_K 2\\big((b-\\rho)x + (c-\\sigma)y + e\\big) \\, \\mathrm{d}\\boldsymbol{x} = 0 $$\n    $$ \\int_K \\big(bx + cy + e\\big) \\, \\mathrm{d}\\boldsymbol{x} = \\int_K \\big(\\rho x + \\sigma y\\big) \\, \\mathrm{d}\\boldsymbol{x} $$\n    $$ b\\frac{1}{2} + c\\frac{1}{2} + e = \\rho\\frac{1}{2} + \\sigma\\frac{1}{2} \\quad (4) $$\n我们可以简化这个方程组。从(3)式中，我们解出 $d$：$d = \\frac{1}{2}(\\mu+\\nu-a-b)$。将其代入(1)式：\n$$ \\frac{a}{3} + \\frac{b}{4} + \\frac{1}{4}(\\mu+\\nu-a-b) = \\frac{\\mu}{3} + \\frac{\\nu}{4} $$\n$$ \\left(\\frac{1}{3}-\\frac{1}{4}\\right)a + \\left(\\frac{1}{4}-\\frac{1}{4}\\right)b = \\left(\\frac{1}{3}-\\frac{1}{4}\\right)\\mu + \\left(\\frac{1}{4}-\\frac{1}{4}\\right)\\nu $$\n$$ \\frac{a}{12} = \\frac{\\mu}{12} \\implies a = \\mu $$\n类似地，从(4)式中，我们解出 $e$：$e = \\frac{1}{2}(\\rho+\\sigma-b-c)$。将其代入(2)式：\n$$ \\frac{b}{4} + \\frac{c}{3} + \\frac{1}{4}(\\rho+\\sigma-b-c) = \\frac{\\rho}{4} + \\frac{\\sigma}{3} $$\n$$ \\left(\\frac{1}{4}-\\frac{1}{4}\\right)b + \\left(\\frac{1}{3}-\\frac{1}{4}\\right)c = \\left(\\frac{1}{4}-\\frac{1}{4}\\right)\\rho + \\left(\\frac{1}{3}-\\frac{1}{4}\\right)\\sigma $$\n$$ \\frac{c}{12} = \\frac{\\sigma}{12} \\implies c = \\sigma $$\n$a=\\mu$ 和 $c=\\sigma$ 这两个结果非常简洁。它们表明，后处理过程从HDG梯度近似的相应项中精确地恢复了二阶纯导数项的系数。\n\n现在我们通过计算 $\\frac{\\partial J}{\\partial b} = 0$ 来推导关于 $b$ 的方程：\n$$ \\frac{\\partial J}{\\partial b} = \\int_K \\left[ 2(1+\\gamma)\\big((a-\\mu)x + (b-\\nu)y + d\\big)y + 2\\big((b-\\rho)x + (c-\\sigma)y + e\\big)x \\right] \\mathrm{d}\\boldsymbol{x} = 0 $$\n代入 $a=\\mu$ 和 $c=\\sigma$，方程简化为：\n$$ \\int_K \\left[ (1+\\gamma)\\big((b-\\nu)y + d\\big)y + \\big((b-\\rho)x + e\\big)x \\right] \\mathrm{d}\\boldsymbol{x} = 0 $$\n$$ (1+\\gamma)\\int_K \\big((b-\\nu)y^2 + dy\\big)\\mathrm{d}\\boldsymbol{x} + \\int_K \\big((b-\\rho)x^2 + ex\\big)\\mathrm{d}\\boldsymbol{x} = 0 $$\n$$ (1+\\gamma)\\left( (b-\\nu)\\frac{1}{3} + d\\frac{1}{2} \\right) + \\left( (b-\\rho)\\frac{1}{3} + e\\frac{1}{2} \\right) = 0 \\quad (5) $$\n我们有 $d$ 和 $e$ 关于 $b$ 的显式表达式。当 $a=\\mu$ 时，方程(3)给出 $d = \\frac{1}{2}(\\nu-b)$。当 $c=\\sigma$ 时，方程(4)给出 $e = \\frac{1}{2}(\\rho-b)$。将这些代入(5)式：\n$$ (1+\\gamma)\\left( (b-\\nu)\\frac{1}{3} + \\frac{1}{2}\\frac{\\nu-b}{2} \\right) + \\left( (b-\\rho)\\frac{1}{3} + \\frac{1}{2}\\frac{\\rho-b}{2} \\right) = 0 $$\n$$ (1+\\gamma)\\left( \\frac{b}{3} - \\frac{\\nu}{3} + \\frac{\\nu}{4} - \\frac{b}{4} \\right) + \\left( \\frac{b}{3} - \\frac{\\rho}{3} + \\frac{\\rho}{4} - \\frac{b}{4} \\right) = 0 $$\n合并括号内的项：\n$$ (1+\\gamma)\\left( \\frac{b}{12} - \\frac{\\nu}{12} \\right) + \\left( \\frac{b}{12} - \\frac{\\rho}{12} \\right) = 0 $$\n两边乘以12：\n$$ (1+\\gamma)(b-\\nu) + (b-\\rho) = 0 $$\n$$ b + \\gamma b - \\nu - \\gamma\\nu + b - \\rho = 0 $$\n$$ b(2+\\gamma) = \\nu(1+\\gamma) + \\rho $$\n求解 $b$：\n$$ b = \\frac{(1+\\gamma)\\nu + \\rho}{2+\\gamma} $$\n\n最后，我们根据要求提出假设。系数 $b$ 代表混合偏导数 $\\partial_{xy}^2 u^{\\star}$。项 $\\nu = \\partial_y q_x$ 和 $\\rho = \\partial_x q_y$ 是来自HDG梯度 $\\boldsymbol{q}_h$ 的对应的（且通常不相等的）混合导数。$b$ 的表达式可以写成一个加权平均值：\n$$ b = \\left(\\frac{1+\\gamma}{2+\\gamma}\\right)\\nu + \\left(\\frac{1}{2+\\gamma}\\right)\\rho $$\n当 $\\gamma=0$ 时，$\\mathbf{M}=\\mathbf{I}$ (各向同性加权)，且 $b = \\frac{\\nu+\\rho}{2}$，即算术平均值。当 $\\gamma \\to \\infty$ 时，$\\nu$ 的权重趋近于1，而 $\\rho$ 的权重趋近于0，因此 $b \\to \\nu$。\n参数 $\\gamma$ 控制了投影的各向异性。项 $(1+\\gamma)$ 对平行于 $\\boldsymbol{\\beta}=(1,0)^\\top$ 的梯度分量的误差进行加权，该分量为 $\\partial_x u^\\star - q_x$。增大 $\\gamma$ 会重度惩罚该误差分量，迫使 $\\nabla u^\\star$ 更多地信任HDG梯度的x分量 $q_x$，而不是y分量 $q_y$。因此，$\\partial_x u^{\\star}$ 的性质（例如其关于 $y$ 的导数，即 $b$）被驱动去匹配 $q_x$ 的性质（其关于 $y$ 的导数为 $\\nu$）。\n假设：增大 $\\gamma$ 会通过优先减小沿对流方向 $\\boldsymbol{\\beta}$ 的误差分量（而非横向的误差分量），从而在后处理中引入各向异性。这迫使后处理解的梯度更紧密地匹配与 $\\boldsymbol{\\beta}$ 对齐的HDG梯度分量，其代价可能是与HDG梯度的横向分量产生更大的差异。这使得后处理误差本身也变得各向异性，其量值可能沿 $\\boldsymbol{\\beta}$ 方向更小，而在垂直于 $\\boldsymbol{\\beta}$ 的方向上更大。",
            "answer": "$$\\boxed{\\frac{(1+\\gamma)\\nu + \\rho}{2+\\gamma}}$$"
        },
        {
            "introduction": "在科学和工程应用中，最终目标通常不是最小化全局误差范数，而是精确计算一个特定的“目标量”，例如升力系数或平均温度。这个动手编程练习  介绍了目标导向后处理这一强大概念。您将实现一种方法，该方法利用相关*对偶问题*的信息来专门提高目标泛函的精度，展示了一种优先考虑实际结果而非抽象误差度量的先进方法。",
            "id": "3410066",
            "problem": "考虑单位区间 $[0,1]$ 上的一个一维模型问题，该问题由椭圆偏微分方程 $-u''(x) = f(x)$ 控制，并带有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。设精确解为 $u(x) = \\sin(\\pi x)$，因此源项为 $f(x) = \\pi^2 \\sin(\\pi x)$。定义目标泛函 $J(u)$ 为 $J(u) = \\int_0^1 u(x)\\,x\\,dx$，其精确值为 $J(u) = 1/\\pi$。与 $J(u)$ 相关的对偶问题（或伴随问题）定义为 $-z''(x) = x$，边界条件为 $z(0)=0$ 和 $z(1)=0$，其精确解为 $z(x) = -\\tfrac{1}{6}x^3 + \\tfrac{1}{6}x$。\n\n您必须在 $[0,1]$ 区间的 $N$ 个单元的均匀剖分上，实现一个多项式次数为 $k=0$（单元内部分片常数逼近）的可杂交间断伽辽金 (HDG) 离散化。使用一个稳定化参数 $\\tau>0$。HDG 格式基于一阶系统 $q = u'$ 和 $-q' = f$，其中混合迹未知数 $\\widehat{u}$ 定义在网格节点上。在每个单元 $K = [x_L,x_R]$ 上，求解常数 $u_h|_K = U_0^K$ 和 $q_h|_K = Q_0^K$ 以及迹 $\\widehat{u}(x_L)$、$\\widehat{u}(x_R)$，使得方程 $q - u' = 0$ 和 $-q' = f$ 的局部弱形式对常数测试函数成立，并且数值通量 $\\widehat{q}\\,n = q\\,n + \\tau(u - \\widehat{u})$ 在内部节点上是守恒的。边界迹满足 $\\widehat{u}(0)=0$ 和 $\\widehat{u}(1)=0$。通过在每个内部节点上施加通量守恒，为内部迹未知数组装全局系统。\n\n在每个单元 $K$ 上构造后处理解 $u^\\star$，方法是施加超收敛 HDG 后处理约束，即 $u^\\star$ 在每个单元上是分片线性的，其导数为 $d u^\\star/dx = q_h|_K$，并通过选择单元常数 $c_K$ 使得对偶加权矩匹配：$\\int_K z(x)\\,u^\\star(x)\\,dx = \\int_K z(x)\\,u_h(x)\\,dx$。如果权积分 $\\int_K z(x)\\,dx$ 在数值上可以忽略，则退回到使用均值保持约束 $\\int_K u^\\star(x)\\,dx = \\int_K u_h(x)\\,dx$。\n\n计算以下量：\n- 目标泛函的计算值 $J(u_h) = \\int_0^1 u_h(x)\\,x\\,dx$ 和 $J(u^\\star) = \\int_0^1 u^\\star(x)\\,x\\,dx$，以及精确值 $J(u) = 1/\\pi$。\n- 全局 $L^2$ 误差 $\\|u_h - u\\|_{L^2(0,1)}$ 和 $\\|u^\\star - u\\|_{L^2(0,1)}$。\n\n对所有非多项式积分，使用足够高阶的高斯-勒让德 (Gauss-Legendre) 法则进行数值积分。本问题不涉及角度，因此无需指定角度单位。也无需物理单位。\n\n您的程序必须为每个带有参数 $(N,\\tau)$ 的测试用例返回一个列表，其中包含：\n- 一个布尔值，指示是否 $|J(u^\\star) - J(u)| < |J(u_h) - J(u)|$。\n- 一个布尔值，指示是否 $\\|u^\\star - u\\|_{L^2(0,1)} < \\|u_h - u\\|_{L^2(0,1)}$。\n- 一个浮点数，等于目标误差的相对减小量，定义为 $\\left(|J(u_h) - J(u)| - |J(u^\\star) - J(u)|\\right)/|J(u_h) - J(u)|$。\n- 一个浮点数，等于全局 $L^2$ 误差的相对减小量，定义为 $\\left(\\|u_h - u\\|_{L^2} - \\|u^\\star - u\\|_{L^2}\\right)/\\|u_h - u\\|_{L^2}$。\n\n测试套件：\n- 用例 1：$(N,\\tau) = (10, 1.0)$。\n- 用例 2：$(N,\\tau) = (4, 5.0)$。\n- 用例 3：$(N,\\tau) = (40, 0.5)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果是按上述顺序排列的嵌套列表。例如：`\"[[True,True,0.123456,0.234567],[...],[...]]\"`。",
            "solution": "问题陈述已经过仔细审查，并被确定是有效的。这是一个数值分析领域的适定问题，具体涉及用于求解椭圆偏微分方程的可杂交间断伽辽金 (HDG) 方法。该问题是自洽的、科学上合理的，并为其求解提供了所有必要的信息。\n\n该问题要求实现一个多项式次数为 $k=0$ 的 HDG 方法来求解一维泊松方程，然后执行一个超收敛后处理步骤。其目标是在关心的积分泛函和全局 $L^2$ 范数两个方面，比较原始 HDG 解和后处理解的精度。\n\n控制方程为定义在区域 $\\Omega = [0,1]$ 上的 $-u''(x) = f(x)$，带有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。通过引入通量变量 $q(x) = u'(x)$，这个二阶方程被改写为一个一阶系统：\n$$\nq(x) - u'(x) = 0 \\\\\n-q'(x) = f(x)\n$$\n\n区域 $[0,1]$ 被剖分为 $N$ 个均匀单元 $K_j = [x_j, x_{j+1}]$（$j=0, \\dots, N-1$），每个单元的长度为 $h = 1/N$。HDG 方法寻求一个近似解 $(u_h, q_h)$，该解在每个单元上是分片常数，即 $u_h|_{K_j} = U_0^j$ 和 $q_h|_{K_j} = Q_0^j$。单元之间的耦合是通过一个混合迹变量 $\\widehat{u}_h$ 来实现的，它代表了在单元交界面（节点）上对 $u$ 的逼近。对于此问题，未知数是每个单元 $j=0, \\dots, N-1$ 的常数 $(U_0^j, Q_0^j)$，以及每个节点 $j=0, \\dots, N$ 的迹值 $\\widehat{u}_j = \\widehat{u}_h(x_j)$。边界条件施加了 $\\widehat{u}_0 = 0$ 和 $\\widehat{u}_N = 0$。\n\n在一个单元 $K_j = [x_j, x_{j+1}]$ 上，对于同样是分片常数（对于 $k=0$，$v=1, w=1$）的测试函数 $(v,w)$，局部 HDG 弱形式为：\n$$\n\\int_{K_j} q_h v \\,dx + \\int_{K_j} u_h v' \\,dx - [ \\widehat{u}_h v ]_{x_j}^{x_{j+1}} = 0 \\\\\n\\int_{K_j} q_h w' \\,dx - [ \\widehat{q}_h \\cdot n w ]_{\\partial K_j} = \\int_{K_j} f w \\,dx\n$$\n其中 $\\widehat{q}_n$ 是数值通量，定义为 $\\widehat{q}_n = q_h n + \\tau(u_h - \\widehat{u}_h)$。这里，$n$ 是指向单元边界外部的单位法向量。\n\n对于 $k=0$，测试函数为 $v=1, w=1$，所以它们的导数 $v', w'$ 为零。$K_j$ 上的局部方程简化为：\n1. 从 $q-u'=0$ 得到：$\\int_{x_j}^{x_{j+1}} Q_0^j \\cdot 1 \\,dx - (\\widehat{u}_{j+1} \\cdot 1 - \\widehat{u}_j \\cdot 1) = 0 \\implies Q_0^j h = \\widehat{u}_{j+1} - \\widehat{u}_j$。\n2. 从 $-q'=f$ 得到，其弱形式为 $-\\int_{\\partial K_j} \\widehat{q}_n w \\, ds = \\int_{K_j} f w \\, dx$。当 $w=1$ 时，这变为 $-(\\widehat{q}_n(x_{j+1}) + \\widehat{q}_n(x_j)) = \\int_{K_j} f(x) \\,dx$。在 $x_{j+1}$ 处的外法向为 $n=+1$，在 $x_j$ 处为 $n=-1$。数值通量为 $\\widehat{q}_n(x_{j+1}) = Q_0^j + \\tau(U_0^j - \\widehat{u}_{j+1})$ 和 $\\widehat{q}_n(x_j) = -Q_0^j + \\tau(U_0^j - \\widehat{u}_j)$。代入弱形式，得到 $- ( (Q_0^j + \\tau(U_0^j - \\widehat{u}_{j+1})) + (-Q_0^j + \\tau(U_0^j - \\widehat{u}_j)) ) = \\int_{K_j} f(x) \\,dx$，这简化为 $-2\\tau U_0^j + \\tau(\\widehat{u}_{j+1}+\\widehat{u}_j) = \\int_{K_j} f(x) \\,dx$。\n\n这两个局部方程使我们能够将局部未知数 $(U_0^j, Q_0^j)$ 完全用迹变量 $\\widehat{u}_j, \\widehat{u}_{j+1}$ 和源项来表示：\n$$\nQ_0^j = \\frac{\\widehat{u}_{j+1} - \\widehat{u}_j}{h} \\\\\nU_0^j = \\frac{\\widehat{u}_j + \\widehat{u}_{j+1}}{2} - \\frac{1}{2\\tau} \\int_{K_j} f(x) \\,dx\n$$\n\n全局系统是通过在每个内部节点 $x_j$（$j=1, \\dots, N-1$）上施加通量守恒来形成的。条件是来自相邻单元 $K_{j-1}$ 和 $K_j$ 的数值通量之和必须为零：$\\widehat{q}_n(x_j)|_{K_{j-1}} + \\widehat{q}_n(x_j)|_{K_j}=0$。\n来自 $K_{j-1}=[x_{j-1}, x_j]$ 在 $x_j$ 处的通量为 $\\widehat{q}_n(x_j)|_{K_{j-1}} = Q_0^{j-1} + \\tau(U_0^{j-1} - \\widehat{u}_j)$。\n来自 $K_j=[x_j, x_{j+1}]$ 在 $x_j$ 处的通量为 $\\widehat{q}_n(x_j)|_{K_j} = -Q_0^j + \\tau(U_0^j - \\widehat{u}_j)$。\n将它们相加并设为零，然后代入 $U_0$ 和 $Q_0$ 的表达式，便可得到关于未知迹值 $\\widehat{u}_j$ 的一个三点格式：\n$$\n\\left(-\\frac{1}{h} + \\frac{\\tau}{2}\\right) \\widehat{u}_{j-1} + \\left(\\frac{2}{h} - \\tau\\right) \\widehat{u}_j + \\left(-\\frac{1}{h} + \\frac{\\tau}{2}\\right) \\widehat{u}_{j+1} = \\frac{1}{2} \\left( \\int_{K_{j-1}} f(x) \\,dx + \\int_{K_j} f(x) \\,dx \\right)\n$$\n该方程对 $j=1, \\dots, N-1$ 成立。结合边界条件 $\\widehat{u}_0=0$ 和 $\\widehat{u}_N=0$，这构成一个 $(N-1) \\times (N-1)$ 的对称三对角线性系统，可以求解出内部迹未知数 $\\{\\widehat{u}_j\\}_{j=1}^{N-1}$。\n\n一旦 $\\widehat{u}_j$ 已知，就可以为所有单元计算出其上的常数解 $U_0^j$ 和 $Q_0^j$。这样就完成了 HDG 解 $(u_h, q_h)$ 的求解。\n\n接下来，构造后处理解 $u^\\star$。在每个单元 $K_j$ 上，$u^\\star$ 是一个线性函数，其导数是常数 HDG 通量 $Q_0^j$：$u^\\star(x) = Q_0^j x + C_j$。积分常数 $C_j$ 通过将 $u^\\star$ 的对偶加权矩与 $u_h$ 的对偶加权矩进行匹配来确定：\n$$\n\\int_{K_j} z(x) u^\\star(x) \\,dx = \\int_{K_j} z(x) u_h(x) \\,dx \\implies C_j = \\frac{\\int_{K_j} (U_0^j - Q_0^j x) z(x) \\,dx}{\\int_{K_j} z(x) \\,dx}\n$$\n其中 $z(x) = -\\frac{1}{6}x^3 + \\frac{1}{6}x$ 是对偶解。如果分母 $\\int_{K_j} z(x) \\,dx$ 在数值上接近于零，则使用均值保持的备用方案：$\\int_{K_j} u^\\star(x) \\,dx = \\int_{K_j} u_h(x) \\,dx$，这会得到 $C_j = U_0^j - Q_0^j (x_j + x_{j+1})/2$。\n\n最后，计算所需的量。为 $u_h$ 和 $u^\\star$ 计算目标泛函：\n$J(u_h) = \\sum_j \\int_{K_j} U_0^j x \\,dx$ 和 $J(u^\\star) = \\sum_j \\int_{K_j} (Q_0^j x + C_j) x \\,dx$。\n$L^2$ 误差计算如下：\n$\\|u_h-u\\|_{L^2}^2 = \\sum_j \\int_{K_j} (U_0^j - \\sin(\\pi x))^2 \\,dx$ 和 $\\|u^\\star-u\\|_{L^2}^2 = \\sum_j \\int_{K_j} (Q_0^j x + C_j - \\sin(\\pi x))^2 \\,dx$。\n涉及非多项式函数 $f(x)$、$u(x)$ 和 $z(x)$ 的积分使用高阶高斯-勒让德 (Gauss-Legendre) 求积法进行计算。然后计算并报告所得解的度量指标。此过程将为每个指定的测试用例实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson problem using an HDG method with k=0 polynomials,\n    applies a superconvergent post-processing step, and compares the results.\n    \"\"\"\n\n    test_cases = [\n        (10, 1.0),\n        (4, 5.0),\n        (40, 0.5),\n    ]\n\n    all_results = []\n    \n    # Use 10-point Gauss-Legendre quadrature, sufficient for smooth integrands\n    q_points, q_weights = np.polynomial.legendre.leggauss(10)\n\n    def integrate(func, a, b):\n        \"\"\"Numerically integrates a function from a to b using Gauss-Legendre.\"\"\"\n        if a == b:\n            return 0.0\n        x_mapped = 0.5 * (b - a) * q_points + 0.5 * (a + b)\n        return 0.5 * (b - a) * np.sum(q_weights * func(x_mapped))\n\n    # Define problem functions\n    pi = np.pi\n    u_exact = lambda x: np.sin(pi * x)\n    f_source = lambda x: pi**2 * np.sin(pi * x)\n    z_dual = lambda x: -x**3/6.0 + x/6.0\n    J_exact = 1.0 / pi\n\n    for N, tau in test_cases:\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        # 1. Assemble the global system for interior trace unknowns u_hat\n        num_unknowns = N - 1\n        if num_unknowns == 0:\n            all_results.append([False, False, 0.0, 0.0]) # Or handle as invalid case\n            continue\n\n        # Tridiagonal matrix A\n        ab = np.zeros((3, num_unknowns))\n        diag_val = 2.0 / h - tau\n        off_diag_val = -1.0 / h + tau / 2.0\n        ab[0, 1:] = off_diag_val\n        ab[1, :] = diag_val\n        ab[2, :-1] = off_diag_val\n\n        # RHS vector b\n        b = np.zeros(num_unknowns)\n        for j in range(1, N):\n            # Integral over K_{j-1} union K_j = [x_{j-1}, x_{j+1}]\n            b[j-1] = 0.5 * integrate(f_source, nodes[j-1], nodes[j+1])\n\n        # 2. Solve for interior u_hat values\n        u_hat_interior = solve_banded((1, 1), ab, b)\n        u_hat = np.zeros(N + 1)\n        u_hat[1:N] = u_hat_interior\n        # u_hat[0] and u_hat[N] are already 0 from BCs.\n\n        # 3. Reconstruct local solutions U_0 and Q_0 on each element\n        U0 = np.zeros(N)\n        Q0 = np.zeros(N)\n        for j in range(N):\n            x_j, x_j1 = nodes[j], nodes[j+1]\n            f_integral_Kj = integrate(f_source, x_j, x_j1)\n            \n            Q0[j] = (u_hat[j+1] - u_hat[j]) / h\n            U0[j] = 0.5 * (u_hat[j] + u_hat[j+1]) - f_integral_Kj / (2.0 * tau)\n\n        # 4. Post-process to get u_star\n        C = np.zeros(N)\n        for j in range(N):\n            x_j, x_j1 = nodes[j], nodes[j+1]\n            z_integral = integrate(z_dual, x_j, x_j1)\n            \n            if np.abs(z_integral) < 1e-14:\n                # Fallback to mean-preserving constraint\n                C[j] = U0[j] - Q0[j] * (x_j + x_j1) / 2.0\n            else:\n                # Dual-weighted moment matching\n                xz_integral = integrate(lambda x: x * z_dual(x), x_j, x_j1)\n                num = U0[j] * z_integral - Q0[j] * xz_integral\n                C[j] = num / z_integral\n        \n        # 5. Compute goal functionals and L2 errors\n        J_uh = 0.0\n        J_ustar = 0.0\n        L2_err_uh_sq = 0.0\n        L2_err_ustar_sq = 0.0\n\n        for j in range(N):\n            x_j, x_j1 = nodes[j], nodes[j+1]\n            # Goal Functional J(u) = integral(u*x, dx)\n            J_uh += U0[j] * (x_j1**2 - x_j**2) / 2.0\n            J_ustar += Q0[j] * (x_j1**3 - x_j**3) / 3.0 + C[j] * (x_j1**2 - x_j**2) / 2.0\n\n            # L2 errors\n            uh_integrand = lambda x: (U0[j] - u_exact(x))**2\n            ustar_integrand = lambda x: (Q0[j] * x + C[j] - u_exact(x))**2\n            L2_err_uh_sq += integrate(uh_integrand, x_j, x_j1)\n            L2_err_ustar_sq += integrate(ustar_integrand, x_j, x_j1)\n\n        L2_err_uh = np.sqrt(L2_err_uh_sq)\n        L2_err_ustar = np.sqrt(L2_err_ustar_sq)\n\n        # 6. Calculate final metrics\n        goal_err_uh = abs(J_uh - J_exact)\n        goal_err_ustar = abs(J_ustar - J_exact)\n        \n        is_goal_improved = goal_err_ustar < goal_err_uh\n        is_L2_improved = L2_err_ustar < L2_err_uh\n        \n        rel_redux_goal = (goal_err_uh - goal_err_ustar) / goal_err_uh if goal_err_uh > 1e-15 else 0.0\n        rel_redux_L2 = (L2_err_uh - L2_err_ustar) / L2_err_uh if L2_err_uh > 1e-15 else 0.0\n\n        all_results.append([is_goal_improved, is_L2_improved, rel_redux_goal, rel_redux_L2])\n\n    # Format the final output string without spaces\n    outer_parts = []\n    for inner_list in all_results:\n        inner_parts = []\n        for item in inner_list:\n            if isinstance(item, bool):\n                inner_parts.append(str(item))\n            else:\n                inner_parts.append(f\"{item:.6f}\") # Use standard formatting for floats\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n    \n    # As per prompt, boolean True/False is case sensitive and should not be lowercased\n    # but the format example shows `true`. However, the global rules do not mandate this.\n    # We follow Python's default `str(bool)` which is `True`/`False`. The final structure is\n    # what matters most. The example in the prompt body is \"[[True,True...]]\"\n    # which is consistent with standard python str(bool)\n    \n    # Re-generating string to strictly match format, even if it might be more verbose\n    def custom_str(item):\n        if isinstance(item, bool):\n            return str(item)\n        if isinstance(item, float):\n            return f\"{item:.6f}\" # The example doesn't specify precision, but 6 is common\n        return str(item)\n        \n    final_results_str = \",\".join([\n        \"[\" + \",\".join(map(custom_str, res)) + \"]\"\n        for res in all_results\n    ])\n    \n    # The output format is very strict. Re-checking again. It seems a direct `str(list)` is\n    # intended and then removing spaces.\n    # e.g., print(str(all_results).replace(\" \",\"\"))\n    # Let's try to match the format precisely using the f-string method.\n    case_str_list = []\n    for r in all_results:\n        # Standard string conversion for bools (True/False) and floats.\n        case_str_list.append(f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\")\n    final_str = f\"[{','.join(case_str_list)}]\".replace(\" \", \"\")\n    print(final_str)\n\nsolve()\n```"
        }
    ]
}