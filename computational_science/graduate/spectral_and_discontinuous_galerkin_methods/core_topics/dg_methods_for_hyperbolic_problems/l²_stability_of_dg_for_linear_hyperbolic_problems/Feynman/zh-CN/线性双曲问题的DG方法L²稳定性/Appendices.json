{
    "hands_on_practices": [
        {
            "introduction": "这项练习旨在奠定基础，通过它您将揭示间断Galerkin方法的一个基本性质。通过在周期性区域上进行直接推导，您将证明使用中心通量的半离散格式本质上是能量守恒的，即空间算子本身既不产生也不耗散能量。这一关键的洞察有助于我们将潜在不稳定性的来源精确定位到时间积分格式上。",
            "id": "3394335",
            "problem": "考虑周期性区域 $\\Omega = (0,L)$ 上的标量线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中 $a \\in \\mathbb{R}$ 是一个常数平流速度，且 $u(x,t)$ 足够光滑。设 $\\{I_{j}\\}_{j=1}^{N}$ 是 $\\Omega$ 的一个分割，由端点为 $\\{x_{j-\\frac{1}{2}}, x_{j+\\frac{1}{2}}\\}$ 的不重叠单元组成，并设 $V_{h}$ 是此网格上总次数至多为 $p \\geq 0$ 的分片多项式空间。半离散间断伽辽金（DG）方法按单元定义如下：求 $u_{h}(t) \\in V_{h}$，使得对于所有测试函数 $v \\in V_{h}$ 和每个单元 $I_{j}$，\n$$\n\\int_{I_{j}} u_{h,t}\\,v\\,dx \\;-\\; \\int_{I_{j}} a\\,u_{h}\\,v_{x}\\,dx \\;+\\; \\sum_{x \\in \\partial I_{j}} \\widehat{a\\,u_{h}}(x)\\,v^{-}(x)\\,n_{j}(x)\\;=\\;0,\n$$\n其中 $n_{j}(x)$ 是单元 $I_{j}$ 在界面 $x$ 处的外向单位法向量，$v^{-}(x)$ 表示从 $I_{j}$ 内部的迹，而 $\\widehat{a\\,u_{h}}$ 是数值通量。假设中心数值通量为\n$$\n\\widehat{a\\,u_{h}}(x) \\;=\\; a\\,\\{u_{h}\\}(x) \\;=\\; a\\,\\frac{u_{h}^{-}(x)+u_{h}^{+}(x)}{2},\n$$\n其中 $u_{h}^{-}(x)$ 和 $u_{h}^{+}(x)$ 分别是来自界面 $x$ 左侧和右侧的迹。在周期性区域上，按通常方式识别 $x=0$ 和 $x=L$ 处的边界界面，使得每个边界都是一个内部界面。\n\n通过取 $v=u_{h}$ 并对所有单元求和，可以得到一个全局离散能量恒等式，它由离散 $L^{2}$ 能量的时间导数和界面贡献之和（由分部积分和数值通量产生）组成。从上述公式和定义出发，仅使用第一性原理和标准微积分，推导在周期性区域上使用中心通量时，此全局恒等式中所有界面贡献的总和。\n\n你的最终答案必须是这个总和的精确值，以单个实数表示。不需要四舍五入，答案中不应包含任何单位。",
            "solution": "问题要求计算应用于周期性区域上的线性平流方程 $u_{t} + a\\,u_{x} = 0$ 的半离散间断伽辽金（DG）方法（使用中心通量）的全局能量恒等式中所有界面贡献的总和。\n\n一个单元 $I_{j}$ 的半离散 DG 公式为：\n$$\n\\int_{I_{j}} u_{h,t}\\,v\\,dx \\;-\\; \\int_{I_{j}} a\\,u_{h}\\,v_{x}\\,dx \\;+\\; \\sum_{x \\in \\partial I_{j}} \\widehat{a\\,u_{h}}(x)\\,v^{-}(x)\\,n_{j}(x)\\;=\\;0\n$$\n为获得能量恒等式，我们将测试函数 $v$ 设为解 $u_{h}$ 本身：\n$$\n\\int_{I_{j}} u_{h,t}\\,u_{h}\\,dx \\;-\\; \\int_{I_{j}} a\\,u_{h}\\,u_{h,x}\\,dx \\;+\\; \\sum_{x \\in \\partial I_{j}} \\widehat{a\\,u_{h}}(x)\\,u_{h}^{-}(x)\\,n_{j}(x)\\;=\\;0\n$$\n第一项可以重写为局部 $L^2$ 能量的时间导数：\n$$\n\\int_{I_{j}} u_{h,t}\\,u_{h}\\,dx = \\int_{I_{j}} \\frac{1}{2}\\frac{\\partial}{\\partial t}(u_{h}^{2})\\,dx = \\frac{1}{2}\\frac{d}{dt}\\int_{I_{j}} u_{h}^{2}\\,dx\n$$\n第二项是单元 $I_{j} = (x_{j-\\frac{1}{2}}, x_{j+\\frac{1}{2}})$ 上的体积积分。我们可以使用分部积分来计算此积分，或者更直接地，通过认识到 $u_{h}u_{h,x} = \\frac{1}{2}\\frac{\\partial}{\\partial x}(u_{h}^{2})$。应用微积分基本定理：\n$$\n\\int_{I_{j}} a\\,u_{h}\\,u_{h,x}\\,dx = \\int_{I_{j}} \\frac{a}{2}\\frac{\\partial}{\\partial x}(u_{h}^{2})\\,dx = \\frac{a}{2}\\left[u_{h}^{2}\\right]_{x_{j-\\frac{1}{2}}}^{x_{j+\\frac{1}{2}}} = \\frac{a}{2}\\left( (u_{h}^{-}(x_{j+\\frac{1}{2}}))^{2} - (u_{h}^{-}(x_{j-\\frac{1}{2}}))^{2} \\right)\n$$\n其中 $u_{h}^{-}(x)$ 表示从单元 $I_j$ 内部计算的 $u_{h}$ 的迹。这个边界项可以使用外向单位法向量 $n_{j}(x)$ 来表示，其中 $n_{j}(x_{j+\\frac{1}{2}}) = 1$ 且 $n_{j}(x_{j-\\frac{1}{2}}) = -1$。\n$$\n\\int_{I_{j}} a\\,u_{h}\\,u_{h,x}\\,dx = \\sum_{x \\in \\partial I_{j}} \\frac{a}{2} (u_{h}^{-}(x))^{2} n_{j}(x)\n$$\n将这些结果代回到单元 $I_{j}$ 的方程中：\n$$\n\\frac{1}{2}\\frac{d}{dt}\\int_{I_{j}} u_{h}^{2}\\,dx - \\sum_{x \\in \\partial I_{j}} \\frac{a}{2} (u_{h}^{-}(x))^{2} n_{j}(x) + \\sum_{x \\in \\partial I_{j}} \\widehat{a\\,u_{h}}(x)\\,u_{h}^{-}(x)\\,n_{j}(x) = 0\n$$\n合并界面项，我们得到单元 $I_j$ 上的能量演化：\n$$\n\\frac{1}{2}\\frac{d}{dt}\\int_{I_{j}} u_{h}^{2}\\,dx + \\sum_{x \\in \\partial I_{j}} \\left( \\widehat{a\\,u_{h}}(x)u_{h}^{-}(x) - \\frac{a}{2}(u_{h}^{-}(x))^{2} \\right) n_{j}(x) = 0\n$$\n为获得全局能量恒等式，我们对所有单元 $j=1, \\dots, N$ 求和：\n$$\n\\sum_{j=1}^{N} \\frac{1}{2}\\frac{d}{dt}\\int_{I_{j}} u_{h}^{2}\\,dx + \\sum_{j=1}^{N} \\sum_{x \\in \\partial I_{j}} \\left( \\widehat{a\\,u_{h}}(x)u_{h}^{-}(x) - \\frac{a}{2}(u_{h}^{-}(x))^{2} \\right) n_{j}(x) = 0\n$$\n第一部分是全局离散 $L^{2}$ 能量的时间导数：\n$$\n\\frac{1}{2}\\frac{d}{dt}\\int_{\\Omega} u_{h}^{2}\\,dx = \\frac{d}{dt} \\left( \\frac{1}{2}\\|u_{h}\\|_{L^{2}(\\Omega)}^{2} \\right)\n$$\n第二部分是问题所要求的量：所有界面贡献的总和。我们用 $S_{face}$ 表示这个和：\n$$\nS_{face} = \\sum_{j=1}^{N} \\sum_{x \\in \\partial I_{j}} \\left( \\widehat{a\\,u_{h}}(x)u_{h}^{-}(x) - \\frac{a}{2}(u_{h}^{-}(x))^{2} \\right) n_{j}(x)\n$$\n双重求和遍历了所有单元的所有界面。我们可以通过遍历网格中唯一界面的集合 $\\mathcal{F}_{h}$ 来重构这个求和。由于是周期性区域，所有界面，包括连接 $x=L$ 和 $x=0$ 的界面，都是内部界面。每个界面 $f \\in \\mathcal{F}_{h}$ 由两个单元共享，一个“左”单元 $I_{L}$ 和一个“右”单元 $I_{R}$。\n\n考虑一个任意界面 $f$。\n对于左单元 $I_{L}$，界面 $f$ 是其右边界。外向法向量为 $n_{L}(f)=1$。内部迹为 $u_{h}^{-}(f)$，其中问题陈述中的符号表示来自 $I_L$ 内部的迹。我们采用标准记法，其中 $u_{h}^{-}(f)$ 是来自左单元的迹，$u_{h}^{+}(f)$ 是来自右单元的迹。因此，来自 $I_L$ 的迹是 $u_{h}^{-}(f)$。\n来自 $I_{L}$ 在界面 $f$ 处的贡献为：\n$$\n\\left( \\widehat{a\\,u_{h}}(f)u_{h}^{-}(f) - \\frac{a}{2}(u_{h}^{-}(f))^{2} \\right) \\cdot (+1)\n$$\n对于右单元 $I_{R}$，界面 $f$ 是其左边界。外向法向量为 $n_{R}(f)=-1$。内部迹为 $u_{h}^{+}(f)$（来自 $I_R$ 内部的迹）。\n来自 $I_{R}$ 在界面 $f$ 处的贡献为：\n$$\n\\left( \\widehat{a\\,u_{h}}(f)u_{h}^{+}(f) - \\frac{a}{2}(u_{h}^{+}(f))^{2} \\right) \\cdot (-1)\n$$\n来自界面 $f$ 的总贡献，我们称之为 $S_f$，是这两个贡献之和：\n$$\nS_{f} = \\left( \\widehat{a\\,u_{h}}(f)u_{h}^{-}(f) - \\frac{a}{2}(u_{h}^{-}(f))^{2} \\right) - \\left( \\widehat{a\\,u_{h}}(f)u_{h}^{+}(f) - \\frac{a}{2}(u_{h}^{+}(f))^{2} \\right)\n$$\n重新整理各项：\n$$\nS_{f} = \\widehat{a\\,u_{h}}(f) \\left( u_{h}^{-}(f) - u_{h}^{+}(f) \\right) - \\frac{a}{2} \\left( (u_{h}^{-}(f))^{2} - (u_{h}^{+}(f))^{2} \\right)\n$$\n现在，我们代入中心数值通量的定义：\n$$\n\\widehat{a\\,u_{h}}(f) = a\\,\\{u_{h}\\}(f) = a\\,\\frac{u_{h}^{-}(f)+u_{h}^{+}(f)}{2}\n$$\n来自界面 $f$ 的贡献变为：\n$$\nS_{f} = a\\,\\frac{u_{h}^{-}(f)+u_{h}^{+}(f)}{2} \\left( u_{h}^{-}(f) - u_{h}^{+}(f) \\right) - \\frac{a}{2} \\left( (u_{h}^{-}(f))^{2} - (u_{h}^{+}(f))^{2} \\right)\n$$\n使用平方差公式 $A^{2}-B^{2}=(A+B)(A-B)$：\n$$\nS_{f} = \\frac{a}{2} \\left( (u_{h}^{-}(f))^{2} - (u_{h}^{+}(f))^{2} \\right) - \\frac{a}{2} \\left( (u_{h}^{-}(f))^{2} - (u_{h}^{+}(f))^{2} \\right)\n$$\n这可以简化为：\n$$\nS_{f} = 0\n$$\n由于来自任意界面 $f$ 的贡献都为零，所有界面贡献的总和 $S_{face} = \\sum_{f \\in \\mathcal{F}_h} S_f$ 也必定为零。\n$$\nS_{face} = \\sum_{f \\in \\mathcal{F}_h} 0 = 0\n$$\n这个结果表明，对于周期性区域上的线性平流方程，使用中心通量的 DG 方法是离散 $L^{2}$ 能量守恒的，因为全局能量恒等式为 $\\frac{d}{dt} \\left( \\frac{1}{2}\\|u_{h}\\|_{L^{2}(\\Omega)}^{2} \\right) = 0$。然而，问题只要求界面贡献的总和的值。\n\n总和恰好是 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "虽然中心通量在半离散层面是能量中性的，但简单的显式时间推进格式（如前向欧拉法）可能导致不稳定。本练习将探讨如何通过在数值通量中添加人工耗散来解决此问题。您将运用冯·诺依曼稳定性分析这一强大工具，精确推导为保证全离散格式的 $L^2$ 稳定性所需的最小耗散量，从而建立起数值参数与物理稳定性之间的定量联系。",
            "id": "3394373",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中 $a \\in \\mathbb{R}$ 为常数平流速度，定义在周期性域上。用宽度为 $h$ 的均匀网格单元离散空间域，并应用零次多项式（分片常数）的间断伽辽金（DG）方法，使用精确质量矩阵，使得每个单元内的单元平均值是唯一的自由度。使用时间步长为 $\\Delta t$ 的显式前向欧拉时间积分器，并假设库朗-弗里德里希-列维（CFL）数 $\\sigma := \\frac{a\\,\\Delta t}{h}$ 满足 $0  \\sigma \\leq 1$。在每个单元界面处，使用由下式定义的单参数族相容数值通量\n$$\nf^{*}\\!\\left(u^{-},u^{+}\\right) \\;=\\; a\\,\\frac{u^{-}+u^{+}}{2} \\;-\\; \\frac{\\lambda}{2}\\,\\left(u^{+}-u^{-}\\right),\n$$\n其中 $u^{-}$ 和 $u^{+}$ 分别表示界面左侧和右侧 $u$ 的内部迹，$\\lambda \\ge 0$ 是一个与 $a$ 具有相同物理单位的常数通量参数。\n\n通过假设周期性和单元索引中的单个傅里叶模，对此全离散格式进行冯·诺依曼分析。推导放大因子 $G(\\theta)$ 作为无量纲波数 $\\theta \\in [-\\pi,\\pi]$ 的函数。然后，施加条件：对于任何傅里叶模，解的离散 $L^{2}$ 范数在一个前向欧拉步中不增加，这等价于要求对于所有 $\\theta \\in [-\\pi,\\pi]$，都有 $|G(\\theta)| \\leq 1$。在给定的 CFL 约束 $0  \\sigma \\le 1$ 下，确定通量参数的最小值 $\\lambda_{\\min}$（表示为关于 $a$、$\\Delta t$ 和 $h$ 的符号解析表达式），该值保证对所有傅里叶模，$L^{2}$ 范数不增加的条件都成立。\n\n你的最终答案必须是 $\\lambda_{\\min}$ 的单个闭式解析表达式，表达式中不包含单位。",
            "solution": "本题旨在对一个全离散格式进行冯·诺依曼稳定性分析，以确定保证其$L^2$稳定性的最小耗散参数 $\\lambda$。\n\n首先，我们写出在均匀网格上对单元平均值 $u_j$ 的DG-P0半离散格式：\n$$ h \\frac{du_j}{dt} + f^*(u_j, u_{j+1}) - f^*(u_{j-1}, u_j) = 0 $$\n代入给定的数值通量 $f^{*}\\!\\left(u^{-},u^{+}\\right) = a\\,\\frac{u^{-}+u^{+}}{2} - \\frac{\\lambda}{2}\\,\\left(u^{+}-u^{-}\\right)$：\n$$ h \\frac{du_j}{dt} = - \\left( a\\,\\frac{u_{j}+u_{j+1}}{2} - \\frac{\\lambda}{2}\\,(u_{j+1}-u_j) \\right) + \\left( a\\,\\frac{u_{j-1}+u_{j}}{2} - \\frac{\\lambda}{2}\\,(u_{j}-u_{j-1}) \\right) $$\n整理各项后，方程简化为：\n$$ h \\frac{du_j}{dt} = \\frac{\\lambda-a}{2} u_{j+1} - \\lambda u_j + \\frac{\\lambda+a}{2} u_{j-1} $$\n接着，我们应用显式前向欧拉时间积分 $u_j^{n+1} = u_j^n + \\Delta t \\frac{du_j}{dt}|_n$，得到全离散格式：\n$$ u_j^{n+1} = u_j^n + \\frac{\\Delta t}{h} \\left( \\frac{\\lambda+a}{2} u_{j-1}^n - \\lambda u_j^n + \\frac{\\lambda-a}{2} u_{j+1}^n \\right) $$\n为了进行冯·诺依曼分析，我们代入傅里叶模解 $u_j^n = (G(\\theta))^n e^{ij\\theta}$，其中 $\\theta$ 是无量纲波数。代入后消去公共因子，得到放大因子 $G(\\theta)$ 的表达式：\n$$ G(\\theta) = 1 + \\frac{\\Delta t}{h} \\left( \\frac{\\lambda+a}{2} e^{-i\\theta} - \\lambda + \\frac{\\lambda-a}{2} e^{i\\theta} \\right) $$\n引入无量纲参数 $\\sigma = \\frac{a\\Delta t}{h}$ 和 $\\tilde{\\lambda} = \\frac{\\lambda\\Delta t}{h}$，并使用欧拉恒等式，可将 $G(\\theta)$ 重写为：\n$$ G(\\theta) = 1 - \\tilde{\\lambda} + \\tilde{\\lambda}\\cos\\theta - i\\sigma\\sin\\theta = (1 + \\tilde{\\lambda}(\\cos\\theta-1)) - i\\sigma\\sin\\theta $$\n$L^2$ 稳定性的条件是 $|G(\\theta)|^2 \\le 1$ 对所有 $\\theta \\in [-\\pi, \\pi]$ 成立。\n$$ |G(\\theta)|^2 = \\left(1 + \\tilde{\\lambda}(\\cos\\theta-1)\\right)^2 + \\sigma^2\\sin^2\\theta \\le 1 $$\n展开并化简，我们得到：\n$$ 2\\tilde{\\lambda}(\\cos\\theta-1) + \\tilde{\\lambda}^2(\\cos\\theta-1)^2 + \\sigma^2\\sin^2\\theta \\le 0 $$\n利用三角恒等式 $\\sin^2\\theta = (1-\\cos\\theta)(1+\\cos\\theta) = -(\\cos\\theta-1)(1+\\cos\\theta)$，并提出非正公因子 $(\\cos\\theta-1)$：\n$$ (\\cos\\theta-1) \\left[ 2\\tilde{\\lambda} + \\tilde{\\lambda}^2(\\cos\\theta-1) - \\sigma^2(1+\\cos\\theta) \\right] \\le 0 $$\n为使此不等式对所有 $\\theta \\neq 0$ 成立，方括号内的项必须为非负：\n$$ 2\\tilde{\\lambda} + \\tilde{\\lambda}^2(\\cos\\theta-1) - \\sigma^2(1+\\cos\\theta) \\ge 0 $$\n令 $y = \\cos\\theta$，这是一个关于 $y$ 在区间 $[-1, 1]$ 上的线性函数。我们只需在区间的两个端点检查该条件。\n当 $y=1$ (对应 $\\theta=0$):\n$$ 2\\tilde{\\lambda} + \\tilde{\\lambda}^2(0) - \\sigma^2(2) \\ge 0 \\implies 2\\tilde{\\lambda} - 2\\sigma^2 \\ge 0 \\implies \\tilde{\\lambda} \\ge \\sigma^2 $$\n当 $y=-1$ (对应 $\\theta=\\pm\\pi$):\n$$ 2\\tilde{\\lambda} + \\tilde{\\lambda}^2(-2) - \\sigma^2(0) \\ge 0 \\implies 2\\tilde{\\lambda} - 2\\tilde{\\lambda}^2 \\ge 0 \\implies 2\\tilde{\\lambda}(1-\\tilde{\\lambda}) \\ge 0 $$\n由于 $\\lambda \\ge 0$，因此 $\\tilde{\\lambda} \\ge 0$，所以第二个条件简化为 $\\tilde{\\lambda} \\le 1$。\n\n综合这两个条件，稳定性要求 $\\sigma^2 \\le \\tilde{\\lambda} \\le 1$。此区间非空的前提是 $\\sigma^2 \\le 1$，即 $|\\sigma| \\le 1$，这与问题给定的CFL条件 $0  \\sigma \\le 1$ 一致。\n为保证稳定性，$\\tilde{\\lambda}$ 的最小值为 $\\tilde{\\lambda}_{\\min} = \\sigma^2$。将参数的定义代回：\n$$ \\frac{\\lambda_{\\min} \\Delta t}{h} = \\left(\\frac{a \\Delta t}{h}\\right)^2 $$\n求解 $\\lambda_{\\min}$，我们得到：\n$$ \\lambda_{\\min} = a^2 \\frac{\\Delta t}{h} $$\n这是在给定条件下保证格式稳定的最小耗散参数值。",
            "answer": "$$\\boxed{a^2 \\frac{\\Delta t}{h}}$$"
        },
        {
            "introduction": "理论上的稳定性证明为我们提供了信心，但其在实践中的实现才是关键。这项动手编程练习要求您实现一个带有稳定迎风通量的DG格式，并对其 $L^2$ 稳定性进行数值验证。通过在包含“狭长”和“大纵横比”等病态三角形的挑战性网格上测试该格式，您将亲手确认，即使在几何形状远非理想的情况下，该方法的能量耗散特性依然成立。",
            "id": "3394323",
            "problem": "考虑在由三角形剖分的多边形域上定义的常系数线性平流方程：$$\\partial_t u + \\boldsymbol{a}\\cdot\\nabla u = 0,$$ 其中 $u = u(\\boldsymbol{x},t)$ 是一个被平流的标量，$\\boldsymbol{a}\\in\\mathbb{R}^2$ 是一个恒定速度矢量。我们考虑使用 0 次多项式（分片常数）的间断 Galerkin (DG) 方法，该方法与采用迎风数值通量的守恒型有限体积格式一致。我们在所有边界边上施加入流边界条件 $u_{\\text{in}}=0$，其中边界边的外法线 $\\boldsymbol{n}$ 满足 $\\boldsymbol{a}\\cdot\\boldsymbol{n}  0$。与分片常数状态 $u_h(t)$ 相关的离散 $L^2$ 能量定义为 $$E_h(t) = \\frac{1}{2}\\sum_{K} |K|\\,u_K(t)^2,$$ 其中求和遍及所有三角形单元 $K$，$|K|$ 是 $K$ 的面积，$u_K(t)$ 是 $K$ 上在时间 $t$ 的单元平均状态。\n\n您的任务是设计一个数值诊断程序，用以在包含病态形状（狭长三角形和高纵横比单元）的三角形网格上，测试采用显式时间步进的 0 次 DG 迎风通量方法的离散 $L^2$-稳定性。具体来说，请从第一性原理出发实现以下步骤：\n\n- 从积分守恒律和高斯散度定理出发，推导在每条具有单位外法线 $\\boldsymbol{n}$ 和边长 $L$ 的边上使用迎风数值通量的分片常数 DG 更新格式。对于面积为 $|K|$ 的单元 $K$，显式更新是前向欧拉类型，其时间步长 $\\Delta t$ 受到一个 Courant–Friedrichs–Lewy (CFL) 条件的约束，该条件取决于 $|K|$、其边长以及投影 $\\boldsymbol{a}\\cdot\\boldsymbol{n}$。\n- 在三个具有指定坐标和初始状态的网格上实现此更新。对于每个网格，在每个时间步 $t^n$ 计算离散能量 $E_h(t^n)$，并验证诊断准则 $$E_h(t^{n+1})\\le E_h(t^n)+\\varepsilon,$$ 其中 $\\varepsilon$ 是一个小的正容差。报告一个布尔值，指示在模拟期间的每一步，这种单调不增性是否都成立。\n\n使用以下测试套件。在每个案例中，所有坐标都以有序对 $(x,y)$ 的形式给出，三角形则通过引用坐标列表的顶点索引来指定。\n\n- 测试案例 1 (正则网格，斜向平流):\n  - 顶点: $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$。\n  - 三角形: $[0,1,3]$, $[1,2,3]$。\n  - 速度: $\\boldsymbol{a}=(0.8,0.3)$。\n  - 初始单元平均状态: $u = [1.0,\\,0.5]$，按顺序对应两个三角形。\n  - 入流边界条件: $u_{\\text{in}}=0$。\n  - CFL 因子: $\\text{CFL}=0.3$。\n  - 最终时间: $T=0.5$。\n\n- 测试案例 2 (带狭长三角形的网格；取 $\\varepsilon=10^{-3}$):\n  - 顶点: $(0.0,0.0)$, $(1.0,0.0)$, $(1.0,1.0)$, $(0.0,1.0)$, $(0.5,0.5+\\varepsilon)$, $(0.2,0.5-\\varepsilon)$。\n  - 三角形: $[0,5,4]$, $[5,1,4]$, $[4,2,3]$。\n  - 速度: $\\boldsymbol{a}=(1.0,0.0)$。\n  - 初始单元平均状态: $u = [1.0,\\,0.2,\\,0.4]$。\n  - 入流边界条件: $u_{\\text{in}}=0$。\n  - CFL 因子: $\\text{CFL}=0.2$。\n  - 最终时间: $T=0.002$。\n\n- 测试案例 3 (高纵横比网格，垂直平流):\n  - 顶点: $(0,0)$, $(2,0)$, $(2,0.1)$, $(0,0.1)$, $(1,0)$, $(1,0.1)$。\n  - 三角形: $[0,4,3]$, $[4,5,3]$, $[4,1,5]$, $[1,2,5]$。\n  - 速度: $\\boldsymbol{a}=(0.0,1.0)$。\n  - 初始单元平均状态: $u = [0.8,\\,0.3,\\,1.2,\\,0.1]$。\n  - 入流边界条件: $u_{\\text{in}}=0$。\n  - CFL 因子: $\\text{CFL}=0.4$。\n  - 最终时间: $T=0.05$。\n\n诊断规范：\n\n- 对每个测试案例，通过首先为每个单元 $K$ 确定量 $$S_K = \\sum_{e\\subset\\partial K}\\max\\{0,\\boldsymbol{a}\\cdot\\boldsymbol{n}_e\\}\\,L_e,$$ 来计算全局时间步长 $\\Delta t$，其中求和是对 $K$ 的所有边 $e$ 进行的，$L_e$ 是边 $e$ 的长度，$\\boldsymbol{n}_e$ 是 $K$ 在边 $e$ 上的单位外法线。然后设置 $$\\Delta t = \\text{CFL}\\cdot\\min_{K}\\left\\{\\frac{|K|}{S_K}\\,:\\,S_K0\\right\\},$$ 如果一个单元的 $S_K=0$，则在求最小值时忽略它（将其局部界限视为 $+\\infty$）。使用整数步数 $N=\\lceil T/\\Delta t\\rceil$，并将 $\\Delta t$ 替换为 $T/N$，以精确达到最终时间。\n- 离散能量为 $$E_h^n=\\frac{1}{2}\\sum_{K}|K|\\,u_K^n\\,u_K^n.$$ 给定案例的单调性诊断是布尔值 $$\\text{stable}=\\bigwedge_{n=0}^{N-1}\\left(E_h^{n+1}\\le E_h^n+\\varepsilon\\right),$$ 容差为 $\\varepsilon=10^{-12}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含按测试案例 1 到 3 的顺序排列的结果，形式为方括号内以逗号分隔的列表，例如，$$[v_1,v_2,v_3],$$ 其中每个 $v_i$ 是一个布尔值，指示测试案例 $i$ 的离散能量是否单调不增。\n\n您的实现必须是自包含的，不使用任何外部文件或输入，并且必须遵守最终答案中指定的执行环境。",
            "solution": "本解答分为两部分：首先，推导分片常数（DG(0)）近似的显式时间更新公式；其次，概述用于在给定网格上测试该格式的$L^2$稳定性的数值实现策略。\n\n### 1. DG(0)更新格式的推导\n\n我们从线性平流方程 $\\partial_t u + \\boldsymbol{a}\\cdot\\nabla u = 0$ 开始。在DG方法中，我们将此方程与一个测试函数 $v_h$ 相乘，并在一个单元 $K$ 上积分。对于DG(0)方法，解 $u_h$ 和测试函数 $v_h$ 在单元内部均为常数，即 $u_h(\\boldsymbol{x},t) = u_K(t)$ 和 $v_h(\\boldsymbol{x}) = 1$。\n\n弱形式为：\n$$ \\int_K (\\partial_t u_K) \\cdot 1 \\,d\\boldsymbol{x} + \\int_K (\\boldsymbol{a}\\cdot\\nabla u_K) \\cdot 1 \\,d\\boldsymbol{x} = 0 $$\n第一项变为 $|K| \\frac{d u_K}{dt}$，其中 $|K|$ 是单元 $K$ 的面积。对于第二项，我们应用散度定理，并将边界上的解替换为数值通量 $\\hat{u}_e$：\n$$ \\int_K \\boldsymbol{a}\\cdot\\nabla u_h \\,d\\boldsymbol{x} = \\int_{\\partial K} (\\boldsymbol{a} u_h) \\cdot \\boldsymbol{n} \\,dS = \\sum_{e \\subset \\partial K} \\int_e (\\boldsymbol{a}\\cdot\\boldsymbol{n}_e) \\hat{u}_e \\,dS = \\sum_{e \\subset \\partial K} L_e (\\boldsymbol{a}\\cdot\\boldsymbol{n}_e) \\hat{u}_e $$\n其中 $L_e$ 是边 $e$ 的长度，$\\boldsymbol{n}_e$ 是其单位外法向量。迎风通量 $\\hat{u}_e$ 取决于信息流动的方向：如果流动是出射的（$\\boldsymbol{a}\\cdot\\boldsymbol{n}_e > 0$），则取单元内部的值 $u_K$；如果是流入的（$\\boldsymbol{a}\\cdot\\boldsymbol{n}_e  0$），则取邻近单元的值 $u_{K'}$。\n\n因此，单元 $K$ 的半离散常微分方程（ODE）为：\n$$ |K| \\frac{d u_K}{dt} = - \\sum_{e \\subset \\partial K} L_e (\\boldsymbol{a}\\cdot\\boldsymbol{n}_e) \\hat{u}_e $$\n将流出和流入的边分开处理：\n$$ |K| \\frac{d u_K}{dt} = - \\left( u_K \\sum_{e \\text{ is outflow}} L_e (\\boldsymbol{a}\\cdot\\boldsymbol{n}_e) + \\sum_{e \\text{ is inflow}} L_e (\\boldsymbol{a}\\cdot\\boldsymbol{n}_e) u_{K'} \\right) $$\n利用问题中定义的量 $S_K = \\sum_{e\\subset\\partial K}\\max\\{0,\\boldsymbol{a}\\cdot\\boldsymbol{n}_e\\}\\,L_e$（即所有流出贡献之和），我们可以将前向欧拉更新（$u_K^{n+1} = u_K^n + \\Delta t \\frac{du_K}{dt}$）写作：\n$$ u_K^{n+1} = u_K^n - \\frac{\\Delta t}{|K|} \\left( u_K^n S_K + \\sum_{e \\text{ s.t. } \\boldsymbol{a}\\cdot\\boldsymbol{n}_e  0} L_e (\\boldsymbol{a}\\cdot\\boldsymbol{n}_e) u_{K'}^n \\right) $$\n其中 $u_{K'}^n$ 是邻近单元的状态或边界条件值（$u_{\\text{in}}=0$）。\n\n### 2. 数值实现策略\n\n每个测试案例的数值实现遵循以下步骤：\n1.  **网格处理**：解析顶点和三角形数据。计算每个三角形的面积 $|K|$，并构建一个边数据结构以识别邻居和边界。为确保法向量计算的一致性，所有三角形顶点按逆时针（CCW）顺序排列。\n2.  **几何计算**：为每个单元的每条边计算其长度 $L_e$ 和单位外法向量 $\\boldsymbol{n}_e$。\n3.  **时间步长计算**：为每个单元 $K$ 计算流出项总和 $S_K$。然后，根据指定的CFL条件确定全局时间步长 $\\Delta t$。将总步数 $N$ 调整为能精确到达最终时间 $T$ 的整数。\n4.  **时间演化**：\n    *   计算初始离散能量 $E_h^0$。\n    *   进行 $N$ 个时间步的循环：\n        *   对每个单元 $K$，使用状态 $u_h^n$ 计算ODE的右侧项。\n        *   使用上面推导的显式公式更新所有单元的状态至 $u_h^{n+1}$。\n        *   计算新的离散能量 $E_h^{n+1}$。\n        *   验证稳定性准则 $E_h^{n+1} \\le E_h^n + \\varepsilon$。若不满足，则该模拟被标记为不稳定。\n5.  **结果报告**：收集每个测试案例的布尔稳定性标志，并按要求格式化输出。迎风格式的理论性质保证了在适当的CFL条件下，离散能量是非增的，因此所有测试都应通过。以下Python代码实现了此策略。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the stability diagnostic.\n    \"\"\"\n\n    def run_case(vertices, triangles, velocity, u_initial, CFL, T, epsilon_diagnostic):\n        \"\"\"\n        Executes a single test case for the DG(0) L2-stability diagnostic.\n\n        Args:\n            vertices (list): List of (x, y) vertex coordinates.\n            triangles (list): List of [v0, v1, v2] vertex indices for each triangle.\n            velocity (tuple): The constant advection velocity (ax, ay).\n            u_initial (list): Initial cell-averaged states for each triangle.\n            CFL (float): The CFL factor.\n            T (float): The final simulation time.\n            epsilon_diagnostic (float): Tolerance for the energy non-increase check.\n\n        Returns:\n            bool: True if the discrete energy is monotonically non-increasing at all steps, False otherwise.\n        \"\"\"\n        num_cells = len(triangles)\n        verts = np.array(vertices, dtype=float)\n        velocity = np.array(velocity, dtype=float)\n        u = np.array(u_initial, dtype=float)\n\n        # 1. Mesh Pre-processing and Geometric Calculations\n        cell_areas = np.zeros(num_cells)\n        edge_to_cells = {}\n        oriented_triangles = []\n\n        for i, tri_indices in enumerate(triangles):\n            v0, v1, v2 = tri_indices\n            p0, p1, p2 = verts[v0], verts[v1], verts[v2]\n            \n            # Shoelace formula for signed area to determine winding order\n            area = 0.5 * (p0[0]*(p1[1]-p2[1]) + p1[0]*(p2[1]-p0[1]) + p2[0]*(p0[1]-p1[1]))\n            \n            # Ensure CCW winding for consistent normal calculations\n            if area  0:\n                area = -area\n                oriented_triangles.append([v0, v2, v1]) # Reverse winding to get CCW\n            else:\n                oriented_triangles.append(list(tri_indices))\n\n            cell_areas[i] = area\n            \n            # Build edge-to-cell mapping\n            for j in range(3):\n                v_start = tri_indices[j]\n                v_end = tri_indices[(j + 1) % 3]\n                edge_key = tuple(sorted((v_start, v_end)))\n                if edge_key not in edge_to_cells:\n                    edge_to_cells[edge_key] = []\n                edge_to_cells[edge_key].append(i)\n\n        # Store detailed edge information for each cell\n        cell_edges_data = [[] for _ in range(num_cells)]\n        for k in range(num_cells):\n            tri_indices = oriented_triangles[k]\n            for j in range(3):\n                v_start_idx, v_end_idx = tri_indices[j], tri_indices[(j + 1) % 3]\n                p_start, p_end = verts[v_start_idx], verts[v_end_idx]\n\n                edge_vec = p_end - p_start\n                length = np.linalg.norm(edge_vec)\n                \n                # Outward normal for CCW triangle\n                normal = np.array([edge_vec[1], -edge_vec[0]]) / length\n                \n                edge_key = tuple(sorted((v_start_idx, v_end_idx)))\n                neighbor_cells_list = edge_to_cells[edge_key]\n                \n                neighbor_k = -1 # Boundary indicator\n                if len(neighbor_cells_list) > 1:\n                    neighbor_k = neighbor_cells_list[0] if neighbor_cells_list[1] == k else neighbor_cells_list[1]\n\n                cell_edges_data[k].append({\n                    'length': length,\n                    'normal': normal,\n                    'neighbor': neighbor_k\n                })\n\n        # 2. Calculate S_K for each cell K\n        S_vals = np.zeros(num_cells)\n        for k in range(num_cells):\n            s_k = 0.0\n            for edge_data in cell_edges_data[k]:\n                a_dot_n = np.dot(velocity, edge_data['normal'])\n                s_k += max(0, a_dot_n) * edge_data['length']\n            S_vals[k] = s_k\n        \n        # 3. Calculate time step dt\n        dt_ratios = [cell_areas[k] / S_vals[k] for k in range(num_cells) if S_vals[k] > 1e-15]\n        \n        if not dt_ratios:\n            # If all S_K are zero, the solution is static. Can take one large step.\n            num_steps = 1\n            dt = T\n        else:\n            dt_cfl = CFL * min(dt_ratios)\n            if T == 0 or dt_cfl == 0:\n                num_steps, dt = 0, 0\n            else:\n                num_steps = math.ceil(T / dt_cfl)\n                dt = T / num_steps\n        \n        # 4. Time Stepping Loop and Stability Check\n        is_stable = True\n        if num_steps > 0:\n            energy_prev = 0.5 * np.sum(cell_areas * u**2)\n\n            for _ in range(num_steps):\n                rhs = np.zeros(num_cells)\n                for k in range(num_cells):\n                    # Sum over inflow edges for the update term\n                    sum_inflow_term = 0.0\n                    for edge_data in cell_edges_data[k]:\n                        a_dot_n = np.dot(velocity, edge_data['normal'])\n                        if a_dot_n  0: # Inflow edge\n                            neighbor_k = edge_data['neighbor']\n                            # Use u_in=0 for boundary edges\n                            u_neighbor = 0.0 if neighbor_k == -1 else u[neighbor_k]\n                            sum_inflow_term += edge_data['length'] * a_dot_n * u_neighbor\n                    \n                    rhs[k] = -(u[k] * S_vals[k] + sum_inflow_term)\n                \n                # Forward Euler update, avoiding division by zero area\n                u += np.divide(dt * rhs, cell_areas, out=np.zeros_like(rhs), where=cell_areas!=0)\n\n                energy_curr = 0.5 * np.sum(cell_areas * u**2)\n                \n                if energy_curr > energy_prev + epsilon_diagnostic:\n                    is_stable = False\n                    break\n                \n                energy_prev = energy_curr\n\n        return is_stable\n\n    # --- Test Cases ---\n    \n    # Test case 1\n    case1 = {\n        'vertices': [(0,0), (1,0), (1,1), (0,1)],\n        'triangles': [[0,1,3], [1,2,3]],\n        'velocity': (0.8,0.3),\n        'u_initial': [1.0, 0.5],\n        'CFL': 0.3, 'T': 0.5\n    }\n\n    # Test case 2\n    eps_geom = 1e-3\n    case2 = {\n        'vertices': [(0.0,0.0), (1.0,0.0), (1.0,1.0), (0.0,1.0), (0.5,0.5+eps_geom), (0.2,0.5-eps_geom)],\n        'triangles': [[0,5,4], [5,1,4], [4,2,3]],\n        'velocity': (1.0,0.0),\n        'u_initial': [1.0, 0.2, 0.4],\n        'CFL': 0.2, 'T': 0.002\n    }\n    \n    # Test case 3\n    case3 = {\n        'vertices': [(0,0), (2,0), (2,0.1), (0,0.1), (1,0), (1,0.1)],\n        'triangles': [[0,4,3], [4,5,3], [4,1,5], [1,2,5]],\n        'velocity': (0.0, 1.0),\n        'u_initial': [0.8, 0.3, 1.2, 0.1],\n        'CFL': 0.4, 'T': 0.05\n    }\n\n    test_cases = [case1, case2, case3]\n    epsilon_diagnostic = 1e-12\n    results = []\n\n    for case in test_cases:\n        result = run_case(\n            case['vertices'], case['triangles'], case['velocity'],\n            case['u_initial'], case['CFL'], case['T'], epsilon_diagnostic\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".lower())\n    \nsolve()\n```"
        }
    ]
}