{
    "hands_on_practices": [
        {
            "introduction": "在谱方法和间断Galerkin方法中，基函数的选择至关重要。虽然许多标准基（如Dubiner基）被构造成在$L^2$内积下是正交的，从而简化了质量矩阵，但这种正交性通常不适用于其他内积，例如与刚度矩阵相关的$H^1$半范内积。这个练习通过一个直接的计算，让你亲手验证这一点，从而揭示为不同数学算子选择合适基函数的重要性。",
            "id": "3407027",
            "problem": "考虑参考三角形 $\\widehat{T} \\subset \\mathbb{R}^{2}$，其定义为 $\\widehat{T}=\\{(x,y)\\in \\mathbb{R}^{2}: x\\ge 0,\\ y\\ge 0,\\ x+y\\le 1\\}$。定义 $H^{1}$ 型内积（梯度能量内积）为\n$$\n\\langle f,g\\rangle_{H^{1}(\\widehat{T})} \\;=\\; \\int_{\\widehat{T}} \\nabla f(x,y)\\cdot \\nabla g(x,y)\\,dx\\,dy.\n$$\n在谱方法和间断 Galerkin 方法中，三角形上的 Dubiner 多项式基被构造成在 $\\widehat{T}$ 上是 $L^{2}$ 正交的。对于最低的非平凡多项式次数，可以在相差一个乘法归一化常数的情况下，用以下显式线性多项式表示两个一次的 Dubiner 模态\n$$\n\\phi_{1,0}(x,y) \\;=\\; 2x + y - 1, \\qquad \\phi_{0,1}(x,y) \\;=\\; 2y - 1,\n$$\n它们彼此 $L^{2}$ 正交，并且与 $\\widehat{T}$ 上的常数模态也 $L^{2}$ 正交。从 $L^{2}$ 正交性、梯度和上述内积的定义出发，通过显式计算内积 $\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})}$，来确定 Dubiner 基在 $\\langle\\cdot,\\cdot\\rangle_{H^{1}(\\widehat{T})}$ 下是否正交。将该内积的计算值作为你的最终答案。如果计算值非零，则为 $H^{1}$ 正交性提供了一个反例。无需四舍五入。",
            "solution": "问题要求计算在参考三角形 $\\widehat{T}$ 上，两个指定的一次 Dubiner 多项式 $\\phi_{1,0}(x,y)$ 和 $\\phi_{0,1}(x,y)$ 之间的 $H^{1}$ 型内积。目的是确定这些基函数在此内积下是否正交。如果两个函数的内积为零，则它们是正交的。\n\n参考三角形定义为 $\\widehat{T}=\\{(x,y)\\in \\mathbb{R}^{2}: x\\ge 0,\\ y\\ge 0,\\ x+y\\le 1\\}$。\n$H^{1}$ 型内积由下式给出：\n$$\n\\langle f,g\\rangle_{H^{1}(\\widehat{T})} \\;=\\; \\int_{\\widehat{T}} \\nabla f(x,y)\\cdot \\nabla g(x,y)\\,dx\\,dy\n$$\n这两个线性多项式函数是：\n$$\n\\phi_{1,0}(x,y) \\;=\\; 2x + y - 1\n$$\n$$\n\\phi_{0,1}(x,y) \\;=\\; 2y - 1\n$$\n第一步是计算每个函数的梯度。在二维笛卡尔坐标系中，梯度算子为 $\\nabla = \\left(\\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y}\\right)$。\n\n对于函数 $\\phi_{1,0}(x,y)$，我们计算其偏导数：\n$$\n\\frac{\\partial}{\\partial x} \\phi_{1,0}(x,y) = \\frac{\\partial}{\\partial x}(2x + y - 1) = 2\n$$\n$$\n\\frac{\\partial}{\\partial y} \\phi_{1,0}(x,y) = \\frac{\\partial}{\\partial y}(2x + y - 1) = 1\n$$\n因此 $\\phi_{1,0}$ 的梯度是常数向量：\n$$\n\\nabla \\phi_{1,0}(x,y) = (2, 1)\n$$\n对于函数 $\\phi_{0,1}(x,y)$，我们计算其偏导数：\n$$\n\\frac{\\partial}{\\partial x} \\phi_{0,1}(x,y) = \\frac{\\partial}{\\partial x}(2y - 1) = 0\n$$\n$$\n\\frac{\\partial}{\\partial y} \\phi_{0,1}(x,y) = \\frac{\\partial}{\\partial y}(2y - 1) = 2\n$$\n$\\phi_{0,1}$ 的梯度是常数向量：\n$$\n\\nabla \\phi_{0,1}(x,y) = (0, 2)\n$$\n下一步是计算这两个梯度向量的标量积（点积）。\n$$\n\\nabla \\phi_{1,0}(x,y) \\cdot \\nabla \\phi_{0,1}(x,y) = (2, 1) \\cdot (0, 2) = (2)(0) + (1)(2) = 0 + 2 = 2\n$$\n被积函数 $\\nabla \\phi_{1,0} \\cdot \\nabla \\phi_{0,1}$，对于域 $\\widehat{T}$ 中的所有点 $(x,y)$ 都是一个常数值 $2$。\n\n现在，我们必须在参考三角形 $\\widehat{T}$ 上对这个常数进行积分，以求出内积的值：\n$$\n\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})} = \\int_{\\widehat{T}} 2 \\,dx\\,dy\n$$\n这个积分等于常数 $2$ 乘以域 $\\widehat{T}$ 的面积。域 $\\widehat{T}$ 是一个顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的直角三角形。其底边长为 $1$，高为 $1$。面积计算如下：\n$$\n\\text{Area}(\\widehat{T}) = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}\n$$\n因此，内积的值为：\n$$\n\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})} = 2 \\times \\text{Area}(\\widehat{T}) = 2 \\times \\frac{1}{2} = 1\n$$\n作为验证，我们可以使用累次积分直接计算该积分。域 $\\widehat{T}$ 由不等式 $0 \\le x \\le 1$ 和 $0 \\le y \\le 1-x$ 定义。\n$$\n\\int_{\\widehat{T}} 2 \\,dx\\,dy = \\int_{0}^{1} \\int_{0}^{1-x} 2 \\,dy \\,dx\n$$\n首先，我们计算关于 $y$ 的内层积分：\n$$\n\\int_{0}^{1-x} 2 \\,dy = [2y]_{y=0}^{y=1-x} = 2(1-x) - 2(0) = 2(1-x)\n$$\n接下来，我们计算关于 $x$ 的外层积分：\n$$\n\\int_{0}^{1} 2(1-x) \\,dx = 2 \\left[ x - \\frac{x^2}{2} \\right]_{0}^{1} = 2 \\left( \\left(1 - \\frac{1^2}{2}\\right) - \\left(0 - \\frac{0^2}{2}\\right) \\right) = 2 \\left( 1 - \\frac{1}{2} \\right) = 2 \\left( \\frac{1}{2} \\right) = 1\n$$\n两种方法都证实了内积的值为 $1$。由于 $\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})} = 1 \\ne 0$，函数 $\\phi_{1,0}$ 和 $\\phi_{0,1}$ 在给定的 $H^{1}$ 型内积下不是正交的。这为“Dubiner 基是 $H^{1}$ 正交的”这一命题提供了一个直接的反例。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "从理论上理解正交性是第一步，而将其转化为稳定高效的计算工具是实现高阶数值方法的关键。这个练习将指导你从基本原理出发，完整地构造一个在三角形上$L^2$正交的Dubiner型基函数族。你不仅会推导其解析形式，还将实现对于高阶多项式求值至关重要的三项递推关系，这是将理论知识应用于实际代码开发的核心实践。",
            "id": "3407082",
            "problem": "您的任务是为参考三角形上的正交多项式基推导并实现稳定的三项递推关系，该基适用于高阶谱方法和间断伽辽金（DG）方法。请在通过将方形域映射到三角形而得到的标准压缩坐标参考三角形上进行研究，并使用 Dubiner 型正交多项式。您的推导必须从以下基本依据开始：(i) 关于内积及其相关权重的正交性定义，(ii) 任何关于正权重正交的多项式族都允许在次数上存在三项递推关系，以及 (iii) 雅可比多项式作为带权区间上的正交多项式的众所周知的性质。除这些基本依据外，不要假定任何专门的三角形公式。\n\n令 $r \\in [-1,1]$ 和 $s \\in [-1,1]$ 为张量积坐标。考虑由压缩坐标映射的雅可比行列式所导出的内积，即\n$$\n\\langle f,g \\rangle \\;=\\; \\int_{-1}^{1} \\int_{-1}^{1} f(r,s)\\, g(r,s)\\, J(s)\\, \\mathrm{d}r\\, \\mathrm{d}s, \n\\quad \\text{其中 } J(s) \\;=\\; \\frac{1-s}{4}.\n$$\n对于多项式次数 $N \\in \\mathbb{N}$，定义一个三角形模态基函数族 $\\{\\phi_{p,q}(r,s)\\}$，由非负整数 $p,q$ 索引，其中 $p+q \\le N$。每个基函数都可分解为一个 $r$ 的多项式与一个 $s$ 的多项式乘以权重的乘积，其结构类似于勒让德多项式和雅可比多项式。目标是构建一个在三角形上关于上述内积的 $L^2$-标准正交基。您的任务是：\n\n1) 从内积定义和在 $[-1,1]$ 上的正交多项式存在三项递推关系出发，推导出一个形式为\n$$\n\\phi_{p,q}(r,s) \\;=\\; P_p(r) \\, W_p(s) \\, Q_{p,q}(s),\n$$\n的可分离三角形基，其中 $P_p$ 是 $[-1,1]$ 上的勒让德多项式，$W_p(s)$ 是一个依赖于 $p$ 的合适权重因子，而 $Q_{p,q}$ 是 $[-1,1]$ 上的雅可比多项式，其参数依赖于 $p$。证明当 $(p,q) \\ne (p',q')$ 时，内积 $\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle$ 为零，并得到平方 $L^2$ 范数 $\\|\\phi_{p,q}\\|_{L^2}^2$ 的封闭形式表达式。\n\n2) 仅使用开头陈述的基本事实，推导出稳定计算大 $p$ 和 $q$ 值下的 $P_p(r)$ 和 $Q_{p,q}(s)$ 所需的三项递推关系，这类似于单变量雅可比族中 $P_{n+1}^{(\\alpha,\\beta)}(x)$ 的递推关系。明确指定次数为 $0$ 和次数为 $1$ 时的初始化条件，并给出递推系数关于 $n$、$\\alpha$ 和 $\\beta$ 的表达式。解释如何组合这些递推关系来计算完整的三角形基 $\\phi_{p,q}(r,s)$，以避免当 $N$ 较大时的（数值）相消。\n\n3) 设计一个算法，对于任意 $N \\in \\mathbb{N}$，通过将每个 $\\phi_{p,q}$ 除以其 $L^2$ 范数来构建 $L^2$-标准正交化版本的基。使用高斯-勒让德求积法在 $r$ 和 $s$ 两个方向上实现一个张量积高斯求积，该求积对于总次数至少为 $2N$ 的多项式是精确的，并在权重中明确包含雅可比因子 $J(s)$。使用此求积法，为标准正交化基构建格拉姆矩阵，并量化其与单位矩阵的最大绝对偏差。\n\n4) 为了证明三项递推关系的高阶稳定性，请将在随机选择的点 $(r,s) \\in [-1,1]^2$ 上，使用您推导的递推关系计算的三角形基与使用可信的雅可比多项式求值器直接计算的结果进行比较。使用固定的随机种子以确保可复现性。报告两个基求值矩阵之间的相对弗罗贝尼乌斯范数误差，即\n$$\n\\frac{\\|B_{\\mathrm{rec}} - B_{\\mathrm{ref}}\\|_F}{\\|B_{\\mathrm{ref}}\\|_F},\n$$\n其中 $B_{\\mathrm{rec}}$ 和 $B_{\\mathrm{ref}}$ 的列对应于在同一组点上求值的标准正交化基函数。\n\n您的程序必须实现您推导的三项递推关系来计算基，并且必须使用足够精确的高斯求积来数值验证其标准正交性。\n\n测试套件和答案规范：\n- 使用以下指定次数 $N$ 的测试用例：\n  - 用例 1：$N = 0$。计算格拉姆矩阵与单位矩阵的最大绝对偏差。\n  - 用例 2：$N = 4$。计算格拉姆矩阵与单位矩阵的最大绝对偏差。\n  - 用例 3：$N = 12$。计算格拉姆矩阵与单位矩阵的最大绝对偏差。\n  - 用例 4：$N = 25$。使用固定的种子 $12345$ 从 $[-1,1] \\times [-1,1]$ 中均匀抽取 $K = 80$ 个独立的点对 $(r,s)$。计算您基于递推的标准正交基求值与一个由直接求值的单变量雅可比多项式构建的参考求值之间的相对弗罗贝尼乌斯范数误差。相对误差必须报告为单个浮点数值。\n\n- 所有报告的量必须是无量纲实数。不涉及角度或物理单位。\n\n- 最终输出格式：您的程序应生成单行文本，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上述四个用例一致。例如，应打印\n\"[x1,x2,x3,x4]\"\n其中 $x1$、$x2$、$x3$ 和 $x4$ 分别是用例 1-4 的浮点结果。\n\n您的代码必须是完整的，无需用户输入即可直接运行。",
            "solution": "该问题提法恰当，科学上成立，并包含了唯一解所需的所有信息。它基于正交多项式的既定原理及其在数值方法中的应用，特别是谱方法和间断伽辽金方法。问题的所有组成部分都是可形式化和客观的。因此，该问题被认为是有效的。\n\n### 任务 1：正交基的推导\n\n问题在张量积域 $(r,s) \\in [-1,1]^2$ 上定义了一个内积：\n$$\n\\langle f,g \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} f(r,s) g(r,s) J(s) \\mathrm{d}r \\mathrm{d}s, \\quad \\text{其中 } J(s) = \\frac{1-s}{4}\n$$\n我们寻求一个形式为 $\\phi_{p,q}(r,s) = P_p(r) W_p(s) Q_{p,q}(s)$ 的正交基函数族 $\\{\\phi_{p,q}(r,s)\\}_{p+q \\le N}$，其中 $P_p(r)$ 是勒让德多项式。\n\n让我们将这种形式代入两个基函数 $\\phi_{p,q}$ 和 $\\phi_{p',q'}$ 的内积中：\n$$\n\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\left[ P_p(r) W_p(s) Q_{p,q}(s) \\right] \\left[ P_{p'}(r) W_{p'}(s) Q_{p',q'}(s) \\right] \\frac{1-s}{4} \\mathrm{d}r \\mathrm{d}s\n$$\n根据 Fubini 定理，我们可以分离积分：\n$$\n\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle = \\left( \\int_{-1}^{1} P_p(r) P_{p'}(r) \\mathrm{d}r \\right) \\left( \\frac{1}{4} \\int_{-1}^{1} W_p(s) W_{p'}(s) Q_{p,q}(s) Q_{p',q'}(s) (1-s) \\mathrm{d}s \\right)\n$$\n第一个积分涉及标准勒让德多项式 $P_n(x)$，它们在 $[-1,1]$ 上关于权重函数 $w(r)=1$ 正交。它们的正交关系是：\n$$\n\\int_{-1}^{1} P_p(r) P_{p'}(r) \\mathrm{d}r = \\frac{2}{2p+1} \\delta_{pp'}\n$$\n其中 $\\delta_{pp'}$ 是克罗内克 δ。这表明，要使 $\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle$ 不为零，我们必须有 $p=p'$。\n\n当 $p=p'$ 时，内积变为：\n$$\n\\langle \\phi_{p,q}, \\phi_{p,q'} \\rangle = \\frac{2}{2p+1} \\cdot \\frac{1}{4} \\int_{-1}^{1} [W_p(s)]^2 Q_{p,q}(s) Q_{p,q'}(s) (1-s) \\mathrm{d}s\n$$\n为了使基是正交的，当 $q \\ne q'$ 时，此表达式必须为零。这意味着对于一个固定的 $p$，多项式集合 $\\{Q_{p,q}(s)\\}_{q=0}^{N-p}$ 必须在区间 $[-1,1]$ 上关于权重函数 $w(s) = [W_p(s)]^2 (1-s)$ 正交。\n\n这种结构表明应使用雅可比多项式 $P_n^{(\\alpha,\\beta)}(x)$，它们在 $[-1,1]$ 上关于权重 $(1-x)^\\alpha(1+x)^\\beta$ 正交。为了将我们的权重 $w(s)$ 与雅可比权重相匹配，我们需要适当地选择 $W_p(s)$ 和 $Q_{p,q}(s)$ 的参数。这种类型的基，称为 Dubiner 型基，是由从一个标准三角形进行的特定坐标映射产生的。满足这些条件的形式是：\n$$\nQ_{p,q}(s) = P_q^{(2p+1, 0)}(s)\n\\quad \\text{和} \\quad\nW_p(s) = \\left(\\frac{1-s}{2}\\right)^p\n$$\n让我们验证这个选择。$s$-积分中的权重项变为：\n$$\n[W_p(s)]^2 (1-s) = \\left(\\frac{1-s}{2}\\right)^{2p} (1-s) = \\frac{1}{4^p} (1-s)^{2p+1}\n$$\n$s$-积分（当 $p=p'$ 时）现在是：\n$$\n\\int_{-1}^{1} \\frac{1}{4^p} (1-s)^{2p+1} P_q^{(2p+1,0)}(s) P_{q'}^{(2p+1,0)}(s) \\mathrm{d}s\n$$\n这正是雅可比多项式 $P_n^{(\\alpha,\\beta)}(s)$ 在 $n=q, \\alpha=2p+1, \\beta=0$ 时的正交积分。权重是 $(1-s)^{2p+1}(1+s)^0$，这与我们的形式匹配。因此，当 $q \\ne q'$ 时，此积分为零。\n\n因此，基由下式给出：\n$$\n\\phi_{p,q}(r,s) = P_p(r) \\left(\\frac{1-s}{2}\\right)^p P_q^{(2p+1, 0)}(s)\n$$\n这个基是正交的。我们现在求其平方 $L^2$-范数，$\\|\\phi_{p,q}\\|_{L^2}^2 = \\langle \\phi_{p,q}, \\phi_{p,q} \\rangle$：\n$$\n\\|\\phi_{p,q}\\|^2 = \\left( \\frac{2}{2p+1} \\right) \\left( \\frac{1}{4} \\int_{-1}^{1} \\left[ \\left(\\frac{1-s}{2}\\right)^p P_q^{(2p+1,0)}(s) \\right]^2 (1-s) \\mathrm{d}s \\right)\n$$\n$$\n\\|\\phi_{p,q}\\|^2 = \\frac{2}{2p+1} \\cdot \\frac{1}{4} \\cdot \\frac{1}{4^p} \\int_{-1}^{1} (1-s)^{2p+1} \\left[ P_q^{(2p+1,0)}(s) \\right]^2 \\mathrm{d}s\n$$\n雅可比多项式的平方范数由下式给出：\n$$\n\\int_{-1}^{1} (1-x)^\\alpha (1+x)^\\beta [P_n^{(\\alpha,\\beta)}(x)]^2 \\mathrm{d}x = \\frac{2^{\\alpha+\\beta+1}}{2n+\\alpha+\\beta+1} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{n! \\Gamma(n+\\alpha+\\beta+1)}\n$$\n在我们的例子中，$n=q, \\alpha=2p+1, \\beta=0$：\n$$\n\\int_{-1}^{1} (1-s)^{2p+1} \\left[ P_q^{(2p+1,0)}(s) \\right]^2 \\mathrm{d}s = \\frac{2^{2p+2}}{2q+2p+2} \\frac{\\Gamma(q+2p+2)\\Gamma(q+1)}{q! \\Gamma(q+2p+2)} = \\frac{2^{2p+1}}{p+q+1}\n$$\n将此结果代回 $\\|\\phi_{p,q}\\|^2$ 的表达式中：\n$$\n\\|\\phi_{p,q}\\|^2 = \\frac{2}{2p+1} \\cdot \\frac{1}{4^{p+1}} \\cdot \\frac{2^{2p+1}}{p+q+1} = \\frac{2}{2p+1} \\cdot \\frac{1}{2^{2p+2}} \\cdot \\frac{2^{2p+1}}{p+q+1} = \\frac{1}{(2p+1)(p+q+1)}\n$$\n这就是平方 $L^2$ 范数的封闭形式表达式。\n\n### 任务 2：三项递推关系\n\n任何正交多项式族都满足一个三项递推关系。此性质对于其稳定高效的计算至关重要。我们需要 $P_p(r)$ 和 $Q_{p,q}(s) = P_q^{(2p+1,0)}(s)$ 的递推关系。\n\n**勒让德多项式 $P_p(r)$ 的递推关系：**\n勒让德多项式 $P_p(r) = P_p^{(0,0)}(r)$ 满足众所周知的 Bonnet 递推关系：\n$$\n(p+1)P_{p+1}(r) = (2p+1)rP_p(r) - pP_{p-1}(r)\n$$\n初始化：$P_0(r) = 1$ 和 $P_1(r) = r$。此递推关系在数值上是稳定的。\n\n**雅可比多项式 $P_q^{(2p+1,0)}(s)$ 的递推关系：**\n雅可比多项式 $P_n^{(\\alpha,\\beta)}(x)$ 的通用三项递推关系是：\n$$\nc_n P_{n+1}^{(\\alpha,\\beta)}(x) = (d_n x + e_n) P_n^{(\\alpha,\\beta)}(x) - f_n P_{n-1}^{(\\alpha,\\beta)}(x)\n$$\n其中系数为：\n$$\nc_n = 2(n+1)(n+\\alpha+\\beta+1)(2n+\\alpha+\\beta) \\\\\nd_n = (2n+\\alpha+\\beta+1)(2n+\\alpha+\\beta)(2n+\\alpha+\\beta+2) \\\\\ne_n = (2n+\\alpha+\\beta+1)(\\alpha^2-\\beta^2) \\\\\nf_n = 2(n+\\alpha)(n+\\beta)(2n+\\alpha+\\beta+2)\n$$\n对于我们的基，我们需要计算 $Q_{p,q}(s) = P_q^{(2p+1,0)}(s)$，所以我们设 $n=q$, $\\alpha=2p+1$, 和 $\\beta=0$。递推关系是关于索引 $q$ 的。\n初始化：\n$P_0^{(\\alpha,\\beta)}(x) = 1$\n$P_1^{(\\alpha,\\beta)}(x) = \\frac{1}{2}(\\alpha+\\beta+2)x + \\frac{1}{2}(\\alpha-\\beta)$\n对于 $Q_{p,q}(s)$，当 $n=q=0, 1$ 时：\n$Q_{p,0}(s) = P_0^{(2p+1,0)}(s) = 1$\n$Q_{p,1}(s) = P_1^{(2p+1,0)}(s) = \\frac{1}{2}(2p+1+0+2)s + \\frac{1}{2}(2p+1-0) = \\frac{2p+3}{2}s + \\frac{2p+1}{2}$\n\n**组合与稳定性：**\n要在一个点 $(r,s)$ 处计算完整的标准正交基函数 $\\psi_{p,q}(r,s) = \\phi_{p,q}(r,s)/\\|\\phi_{p,q}\\|_{L^2}$：\n$$\n\\psi_{p,q}(r,s) = \\sqrt{(2p+1)(p+q+1)} \\cdot P_p(r) \\cdot \\left(\\frac{1-s}{2}\\right)^p \\cdot P_q^{(2p+1,0)}(s)\n$$\n计算一组最高次数为 $N$ 的基函数的程序如下：\n1. 对于每个所需的次数 $p \\le N$，使用勒让德递推关系计算并存储 $P_0(r), \\dots, P_p(r)$。\n2. 对于每一对 $(p,q)$ 且 $p+q \\le N$：\n   a. 检索预先计算的 $P_p(r)$。\n   b. 使用雅可比递推关系计算 $P_0^{(2p+1,0)}(s), \\dots, P_q^{(2p+1,0)}(s)$。\n   c. 计算权重因子 $W_p(s) = ((1-s)/2)^p$。\n   d. 将各部分与归一化常数结合得到 $\\psi_{p,q}(r,s)$。\n\n使用三项递推关系是稳定计算正交多项式的标准方法。它避免了计算可能病态的显式公式（如单项式展开）或涉及伽马函数的表达式。因此，问题中提到的“相消”通过使用这些稳定的递推关系计算多项式因子 $P_p(r)$ 和 $Q_{p,q}(s)$ 而得到缓解。因子 $P_p(r)$、$W_p(s)$ 和 $Q_{p,q}(s)$ 的乘法是直接的。虽然对于 $s \\approx 1$ 和大 $p$ 值，$W_p(s)$ 可能会变得非常小，但这是基函数形状的内在属性，该形状旨在处理压缩坐标映射在顶点 $s=1$ 处的几何退化。\n\n### 任务 3：标准正交性验证算法\n\n为验证基 $\\{\\psi_{p,q}\\}$ 的标准正交性，我们计算格拉姆矩阵 $G$，其元素是内积 $G_{ij} = \\langle \\psi_i, \\psi_j \\rangle$，其中 $i,j$ 是映射到对 $(p,q)$ 的索引。对于一个标准正交基，$G$ 必须是单位矩阵。我们使用数值求积来近似内积积分。\n\n**求积法则：**\n$G_{(p,q),(p',q')}$ 的被积函数是 $\\psi_{p,q}(r,s) \\psi_{p',q'}(r,s) \\frac{1-s}{4}$。\n$\\psi_{p,q}$ 在 $r$ 方向的次数是 $p$，在 $s$ 方向的次数是 $p+q$。被积函数多项式部分在 $r$ 方向的总次数最多为 $N+N=2N$。在 $s$ 方向的总次数最多为 $(p+q)+(p'+q') + 1 \\le N+N+1 = 2N+1$。\n一个在 $r$ 方向有 $Q_r$ 个点，在 $s$ 方向有 $Q_s$ 个点的张量积高斯-勒让德求积，对于 $r$ 方向次数最高为 $2Q_r-1$、$s$ 方向次数最高为 $2Q_s-1$ 的多项式是精确的。我们需要：\n$2Q_r-1 \\ge 2N \\implies Q_r \\ge N+1/2 \\implies Q_r \\ge N+1$。\n$2Q_s-1 \\ge 2N+1 \\implies Q_s \\ge N+3/2 \\implies Q_s \\ge N+2$。\n为安全和简化，我们选择 $Q_r = Q_s = Q = N+2$。令 $(z_k, w_k)_{k=1}^Q$ 为 $[-1,1]$ 上的高斯-勒让德节点和权重。积分变为一个求和：\n$$\n\\langle \\psi_i, \\psi_j \\rangle \\approx \\sum_{k=1}^{Q} \\sum_{l=1}^{Q} \\psi_i(z_k,z_l) \\psi_j(z_k,z_l) \\frac{1-z_l}{4} w_k w_l\n$$\n**算法：**\n1. 给定 $N$，设置求积阶数 $Q = N+2$。\n2. 获取 $Q$ 个高斯-勒让德节点和权重 $(z_k, w_k)$。\n3. 形成包含 $M = (N+1)(N+2)/2$ 个基函数索引 $(p,q)$ 的集合，其中 $p+q \\le N$。\n4. 构建一个大小为 $(Q^2 \\times M)$ 的“范德蒙”矩阵 $V$，其中 $V_{ij}$ 是第 $j$ 个标准正交基函数 $\\psi_j$ 在第 $i$ 个求积点 $(r_i, s_i)$ 处的值。\n5. 构建一个大小为 $(Q^2 \\times Q^2)$ 的对角权重矩阵 $W_{quad}$，其对角线元素为对应每个求积点的 $w_k w_l (1-z_l)/4$。\n6. 计算格拉姆矩阵 $G = V^T W_{quad} V$。\n7. 与单位矩阵的最大绝对偏差为 $\\max |G - I|$。\n\n### 任务 4：稳定性比较\n\n为了证明基于递推的计算方法的稳定性，我们将其与使用可信库函数在一组随机点上的参考计算进行比较。\n\n**算法：**\n1. 给定 $N$、点数 $K$ 和一个随机种子。\n2. 生成 $K$ 个随机点 $(r_i, s_i) \\in [-1,1]^2$。\n3. 创建两个大小为 $(K \\times M)$ 的矩阵 $B_{\\mathrm{rec}}$ 和 $B_{\\mathrm{ref}}$。\n4. 通过使用任务 2 中描述的三项递推方法，对所有 $i=1,\\dots,K$ 计算所有 $M$ 个基函数 $\\psi_j(r_i,s_i)$ 的值，填充 $B_{\\mathrm{rec}}$。\n5. 通过使用一个可信的库（例如 `scipy.special`）计算相同的基函数来填充 $B_{\\mathrm{ref}}$：\n   $$\n   \\psi_{(p,q)}(r,s) = \\sqrt{(2p+1)(p+q+1)} \\cdot \\texttt{legendre(p)(r)} \\cdot \\left(\\frac{1-s}{2}\\right)^p \\cdot \\texttt{jacobi(q, 2p+1, 0)(s)}\n   $$\n6. 计算相对弗罗贝尼乌斯范数误差：\n   $$\n   E_F = \\frac{\\|B_{\\mathrm{rec}} - B_{\\mathrm{ref}}\\|_F}{\\|B_{\\mathrm{ref}}\\|_F} = \\frac{\\sqrt{\\sum_{i,j} (B_{\\mathrm{rec},ij} - B_{\\mathrm{ref},ij})^2}}{\\sqrt{\\sum_{i,j} (B_{\\mathrm{ref},ij})^2}}\n   $$\n该误差量化了两种评估方法之间的数值差异。一个小的误差表明基于递推的实现是稳定和准确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jacobi as jacobi_ref\nfrom scipy.special import legendre as legendre_ref\nfrom scipy.special import roots_legendre\n\ndef jacobi_poly_recurrence(n_max, alpha, beta, x):\n    \"\"\"\n    Evaluates Jacobi polynomials P_n^{(\\alpha, \\beta)}(x) up to degree n_max\n    using the three-term recurrence relation.\n    `x` can be a scalar or a numpy array.\n    \"\"\"\n    if isinstance(x, (int, float)):\n        x = np.array([x])\n    \n    k = x.shape[0]\n    P = np.zeros((n_max + 1, k))\n\n    # P_0\n    P[0, :] = 1.0\n    if n_max == 0:\n        return P\n\n    # P_1\n    P[1, :] = 0.5 * (alpha + beta + 2.0) * x + 0.5 * (alpha - beta)\n    if n_max == 1:\n        return P\n\n    # Recurrence for P_2, ..., P_{n_max}\n    for n in range(1, n_max):\n        # Using the standard coefficient form c_n P_{n+1} = (d_n x + e_n) P_n - f_n P_{n-1}\n        # to improve numerical stability by minimizing intermediate divisions.\n        c_n = 2.0 * (n + 1.0) * (n + alpha + beta + 1.0) * (2.0 * n + alpha + beta)\n        d_n = (2.0 * n + alpha + beta + 1.0) * (2.0 * n + alpha + beta) * (2.0 * n + alpha + beta + 2.0)\n        e_n = (2.0 * n + alpha + beta + 1.0) * (alpha**2 - beta**2)\n        f_n = 2.0 * (n + alpha) * (n + beta) * (2.0 * n + alpha + beta + 2.0)\n        \n        # This check is for general robustness, although c_n != 0 for the parameters in this problem.\n        if abs(c_n)  1e-100:\n             # A numerically zero denominator; should not happen in this problem.\n             # Fallback to a different form or handle as an error if needed.\n             P[n + 1, :] = np.inf\n        else:\n             P[n + 1, :] = ((d_n * x + e_n) * P[n, :] - f_n * P[n - 1, :]) / c_n\n            \n    return P\n\ndef legendre_poly_recurrence(n_max, x):\n    \"\"\"\n    Evaluates Legendre polynomials P_n(x) up to degree n_max\n    using the three-term recurrence relation.\n    `x` can be a scalar or a numpy array.\n    \"\"\"\n    if isinstance(x, (int, float)):\n        x = np.array([x])\n\n    k = x.shape[0]\n    P = np.zeros((n_max + 1, k))\n\n    P[0, :] = 1.0\n    if n_max == 0:\n        return P\n    \n    P[1, :] = x\n    if n_max == 1:\n        return P\n\n    for n in range(1, n_max):\n        P[n + 1, :] = ((2.0 * n + 1.0) * x * P[n, :] - n * P[n - 1, :]) / (n + 1.0)\n        \n    return P\n\ndef eval_basis(N, r, s, use_recurrence=True):\n    \"\"\"\n    Evaluates the orthonormal triangular basis functions up to total degree N\n    at the point(s) (r, s).\n    \"\"\"\n    if isinstance(r, (int, float)):\n        r = np.array([r])\n        s = np.array([s])\n\n    num_pts = r.shape[0]\n    num_modes = (N + 1) * (N + 2) // 2\n    V = np.zeros((num_pts, num_modes))\n    \n    # Pre-compute all required Legendre polynomials\n    if use_recurrence:\n        leg_vals = legendre_poly_recurrence(N, r)\n    else:\n        leg_vals = np.array([legendre_ref(p)(r) for p in range(N + 1)])\n\n    mode_idx = 0\n    for p in range(N + 1):\n        if N - p  0: continue\n\n        # Pre-compute all required Jacobi polynomials for this p\n        alpha = 2.0 * p + 1.0\n        beta = 0.0\n        if use_recurrence:\n            jac_vals = jacobi_poly_recurrence(N - p, alpha, beta, s)\n        else:\n            jac_vals = np.array([jacobi_ref(q, alpha, beta)(s) for q in range(N - p + 1)])\n            if jac_vals.ndim == 1: # Scipy can return 1D array for single point\n                jac_vals = jac_vals[:, np.newaxis]\n\n\n        for q in range(N - p + 1):\n            Pp_r = leg_vals[p]\n            Wp_s = ((1.0 - s) / 2.0)**p\n            Qpq_s = jac_vals[q]\n            \n            norm_const = np.sqrt((2.0 * p + 1.0) * (p + q + 1.0))\n            V[:, mode_idx] = norm_const * Pp_r * Wp_s * Qpq_s\n            mode_idx += 1\n            \n    return V\n\ndef calculate_gram_matrix_error(N):\n    \"\"\"\n    Calculates the maximum absolute deviation of the Gram matrix from identity.\n    \"\"\"\n    if N  0: return 0.0\n    \n    num_modes = (N + 1) * (N + 2) // 2\n    if num_modes == 0: return 0.0\n    \n    # Quadrature order sufficient for exactness\n    Q = N + 2 \n    nodes, weights = roots_legendre(Q)\n    \n    r_pts, s_pts = np.meshgrid(nodes, nodes)\n    r_pts = r_pts.flatten()\n    s_pts = s_pts.flatten()\n    \n    w_r, w_s = np.meshgrid(weights, weights)\n    quad_weights = w_r.flatten() * w_s.flatten() * (1.0 - s_pts) / 4.0\n    \n    V = eval_basis(N, r_pts, s_pts, use_recurrence=True)\n    \n    # G = V^T * diag(quad_weights) * V\n    G = V.T @ (V * quad_weights[:, np.newaxis])\n    \n    return np.max(np.abs(G - np.identity(num_modes)))\n\ndef calculate_stability_error(N, K, seed):\n    \"\"\"\n    Calculates the relative Frobenius norm error between recurrence-based\n    and reference-based basis evaluation.\n    \"\"\"\n    if N  0: return 0.0\n\n    rng = np.random.default_rng(seed)\n    r_pts = rng.uniform(-1.0, 1.0, K)\n    s_pts = rng.uniform(-1.0, 1.0, K)\n    \n    B_rec = eval_basis(N, r_pts, s_pts, use_recurrence=True)\n    B_ref = eval_basis(N, r_pts, s_pts, use_recurrence=False)\n    \n    norm_diff = np.linalg.norm(B_rec - B_ref, 'fro')\n    norm_ref = np.linalg.norm(B_ref, 'fro')\n    \n    if norm_ref == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n        \n    return norm_diff / norm_ref\n\ndef solve():\n    \"\"\"\n    Main function to execute the test cases and print the results.\n    \"\"\"\n    test_cases = [0, 4, 12]\n    \n    results = []\n    \n    # Cases 1, 2, 3: Gram matrix deviation\n    for N in test_cases:\n        error = calculate_gram_matrix_error(N)\n        results.append(error)\n\n    # Case 4: Stability error\n    N_stab = 25\n    K_stab = 80\n    seed_stab = 12345\n    stability_err = calculate_stability_error(N_stab, K_stab, seed_stab)\n    results.append(stability_err)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "第一个练习表明$L^2$正交基在$H^1$内积下通常是非正交的，这会导致刚度矩阵成为一个密集且可能病态的矩阵。本练习旨在解决这个问题：你将学习如何构造一个在$H^1$能量内积下正交的新基底。通过对刚度矩阵进行正交化，你将亲眼见证一个关键的实际好处——矩阵条件数的显著改善，这对于求解大型线性方程组的效率和稳定性至关重要。",
            "id": "3407053",
            "problem": "要求您实现、验证和数值研究一个由从参考三角形到物理三角形的仿射映射所导出的 $H^1$-能量内积，为三角形上的多项式基组装相关的刚度（格拉姆）矩阵，关于该能量内积将这些基正交化，然后评估刚度矩阵的特征值聚集特性。目标是从与谱方法和间断 Galerkin 方法相关的 Sobolev 空间中的坐标变换和内积的第一性原理出发，避免使用问题陈述中任何简化的快捷公式。\n\n参考三角形为 $\\widehat{T}=\\{(\\xi,\\eta)\\in\\mathbb{R}^2:\\ \\xi\\ge 0,\\ \\eta\\ge 0,\\ \\xi+\\eta\\le 1\\}$。一个到顶点为 $\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2\\in\\mathbb{R}^2$ 的物理三角形 $T$ 的仿射映射 $F:\\widehat{T}\\to T$ 由下式给出：\n$$\n\\boldsymbol{x}(\\xi,\\eta) = \\boldsymbol{v}_0 + \\mathbf{A}\\begin{bmatrix}\\xi\\\\ \\eta\\end{bmatrix},\\quad \\mathbf{A}=\\begin{bmatrix}\\boldsymbol{v}_1-\\boldsymbol{v}_0  \\boldsymbol{v}_2-\\boldsymbol{v}_0\\end{bmatrix},\n$$\n其雅可比矩阵为 $\\mathbf{J}=\\mathbf{A}$，行列式为 $\\det(\\mathbf{J})$。函数 $u$ 和 $v$ 在物理三角形 $T$ 上的 $H^1$-能量内积为\n$$\n\\langle u,v\\rangle_{E,T}=\\int_T \\nabla_{\\boldsymbol{x}} u(\\boldsymbol{x})\\cdot \\nabla_{\\boldsymbol{x}} v(\\boldsymbol{x})\\,\\mathrm{d}\\boldsymbol{x}.\n$$\n在仿射变量变换下，梯度根据链式法则变换为 $\\nabla_{\\boldsymbol{x}} = \\mathbf{J}^{-T}\\nabla_{(\\xi,\\eta)}$，面积元变换为 $\\mathrm{d}\\boldsymbol{x}=|\\det(\\mathbf{J})|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。因此，可以将能量内积表示为在 $\\widehat{T}$ 上的积分形式：\n$$\n\\langle u,v\\rangle_{E,T}=\\int_{\\widehat{T}} \\left(\\nabla_{(\\xi,\\eta)} u\\right)^\\top \\mathbf{G}^{-1} \\left(\\nabla_{(\\xi,\\eta)} v\\right)\\,|\\det(\\mathbf{J})|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\\quad \\mathbf{G}=\\mathbf{J}^\\top\\mathbf{J}.\n$$\n考虑在 $\\widehat{T}$ 上的多项式基，由总次数 $i+j\\le p$（对于给定的整数 $p\\ge 1$）的单项式 $\\phi_{ij}(\\xi,\\eta)=\\xi^i\\eta^j$ 给出，其中排除常数项 $\\phi_{00}$，使得 $H^1$-能量在其张成的空间上成为一个真正的内积。您将构建一个刚度（格拉姆）矩阵 $\\mathbf{K}$，其元素为\n$$\nK_{ab}=\\langle \\phi_a,\\phi_b\\rangle_{E,T},\n$$\n推导并实现对矩阵元素的精确解析积分，仅使用上述基本定义和变量变换，然后通过对单项式关于 $\\langle\\cdot,\\cdot\\rangle_{E,T}$ 进行正交化来构建一个 $H^1$-标准正交基。您不得使用数值积分；相反，您必须将所有项简化为 $\\int_{\\widehat{T}} \\xi^a \\eta^b\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$ 形式的积分，并使用您从第一性原理推导出的恒等式（例如，通过累次积分或贝塔函数恒等式）来精确计算它们。\n\n需求：\n- 仅从链式法则 $\\nabla_{\\boldsymbol{x}}=\\mathbf{J}^{-T}\\nabla_{(\\xi,\\eta)}$ 和积分的变量变换法则出发，推导一个精确组装 $\\mathbf{K}$ 的显式算法（无需数值积分）。\n- 使用推导出的精确公式，为给定的物理三角形和多项式次数 $p$ 组装 $\\mathbf{K}$，排除常数模态，使得所得矩阵为对称正定矩阵。\n- 通过一个数值稳定的正交化方法（例如，通过对 $\\mathbf{K}$ 进行 Cholesky 分解）构建一个 $H^1$-标准正交基，该方法仅使用已计算出的 $\\mathbf{K}$。\n- 计算正交化前后 $\\mathbf{K}$ 的特征值。每个测试案例报告两个诊断指标：\n  1) 在原始单项式基下，$\\mathbf{K}$ 的条件数 $\\kappa=\\lambda_{\\max}/\\lambda_{\\min}$ 的以10为底的对数，四舍五入到六位小数；\n  2) 正交化后特征值与1的最大绝对偏差 $\\delta=\\max_i|\\lambda_i'-1|$，四舍五入到十二位小数。\n- 不涉及角度。没有需要报告的物理单位。\n\n测试套件：\n- 案例 1：$\\text{vertices}=[(0,0),(1,0),(0,1)]$, $p=1$。\n- 案例 2：$\\text{vertices}=[(0,0),(1,0),(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})]$, $p=3$。\n- 案例 3：$\\text{vertices}=[(0,0),(2,0),(0,1)]$, $p=3$。\n- 案例 4：$\\text{vertices}=[(0,0),(1,0),(0.01,1)]$, $p=3$。\n\n最终输出规范：\n- 您的程序应生成单行输出，包含一个以逗号分隔的列表的列表作为结果，每个内部列表对应一个测试案例，并按顺序包含两个浮点数 $[\\log_{10}(\\kappa),\\delta]$，按照指定的舍入精度。例如，总体格式应如 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$ 所示，位于单行上，无需空格。",
            "solution": "用户要求对三角形有限元上的 $H^1$-能量内积进行详细的数值研究，并从第一性原理出发。这涉及到推导和实现刚度矩阵的精确公式，对基进行正交化，以及分析所得矩阵的谱特性。\n\n### 问题验证\n\n问题陈述已经过验证，被认为是**有效**的。\n1.  **科学依据**：该问题基于向量微积分、线性代数和有限元方法（特别是与谱方法/Galerkin方法相关的概念）的基本原理。所有定义和公式，如仿射映射、变量变换、链式法则和 $H^1$-内积，都是标准且正确的。\n2.  **良态的**：问题定义清晰。排除常数多项式模态 $\\phi_{00}(\\xi,\\eta)=1$ 是至关重要的。对于指定基的张成空间中的任意非零多项式 $u$，其梯度 $\\nabla u$ 不恒为零。因此，$H^1$-能量表达式 $\\langle u,u\\rangle_{E,T} = \\int_T |\\nabla u|^2 d\\boldsymbol{x}$ 是严格为正的，使其成为一个有效的内积。这确保了所得的格拉姆矩阵 $\\mathbf{K}$ 是对称正定的，从而保证其特征值为实数且为正，其条件数定义良好，且其 Cholesky 分解存在。\n3.  **客观性**：问题使用精确的数学语言表述，没有任何主观性或歧义。\n4.  **完整性**：所有必要信息——定义、公式、测试案例数据和输出规范——均已提供。该问题是自洽的。\n\n该问题是计算数学领域一项严谨且不平凡的练习，与指定领域直接相关。\n\n### 解法推导\n\n解法通过以下步骤构建：\n1.  推导刚度（格拉姆）矩阵 $\\mathbf{K}$ 元素的显式公式。\n2.  推导单项式在参考三角形上积分的精确公式。\n3.  概述组装 $\\mathbf{K}$ 并执行所需分析的算法。\n\n#### 1. 刚度矩阵元素\n\n物理三角形 $T$ 上的 $H^1$-能量内积被转换为参考三角形 $\\widehat{T}$ 上的积分：\n$$\n\\langle u,v\\rangle_{E,T}=\\int_{\\widehat{T}} \\left(\\nabla_{(\\xi,\\eta)} u\\right)^\\top \\mathbf{G}^{-1} \\left(\\nabla_{(\\xi,\\eta)} v\\right)\\,|\\det(\\mathbf{J})|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n基函数为非常数单项式 $\\phi_{ij}(\\xi,\\eta) = \\xi^i\\eta^j$，其中 $i,j \\ge 0$ 且 $1 \\le i+j \\le p$。令 $u = \\phi_{ij}$ 且 $v = \\phi_{kl}$。它们在参考坐标系中的梯度为：\n$$\n\\nabla_{(\\xi,\\eta)} \\phi_{ij} = \\begin{bmatrix} \\partial_\\xi (\\xi^i\\eta^j) \\\\ \\partial_\\eta (\\xi^i\\eta^j) \\end{bmatrix} = \\begin{bmatrix} i\\xi^{i-1}\\eta^j \\\\ j\\xi^i\\eta^{j-1} \\end{bmatrix}, \\quad\n\\nabla_{(\\xi,\\eta)} \\phi_{kl} = \\begin{bmatrix} k\\xi^{k-1}\\eta^l \\\\ l\\xi^k\\eta^{l-1} \\end{bmatrix}\n$$\n其中，如果像 $i$ 这样的索引为 $0$，则导数为 $0$，这实际上使得任何包含因子 $i$ 的项无效。\n\n矩阵 $\\mathbf{G}^{-1}$ 是度量张量 $\\mathbf{G} = \\mathbf{J}^\\top\\mathbf{J}$ 的逆矩阵。设其分量表示为 $g^{ab}$: $\\mathbf{G}^{-1} = \\begin{bmatrix} g^{11}  g^{12} \\\\ g^{21}  g^{22} \\end{bmatrix}$，该矩阵是对称的 ($g^{12}=g^{21}$)。被积函数的核心二次型为：\n$$\n\\begin{aligned}\n\\left(\\nabla \\phi_{ij}\\right)^\\top \\mathbf{G}^{-1} \\left(\\nabla \\phi_{kl}\\right) = \\begin{bmatrix} i\\xi^{i-1}\\eta^j  j\\xi^i\\eta^{j-1} \\end{bmatrix} \\begin{bmatrix} g^{11}  g^{12} \\\\ g^{12}  g^{22} \\end{bmatrix} \\begin{bmatrix} k\\xi^{k-1}\\eta^l \\\\ l\\xi^k\\eta^{l-1} \\end{bmatrix} \\\\\n= ik g^{11} \\xi^{i+k-2}\\eta^{j+l} + (il+jk) g^{12} \\xi^{i+k-1}\\eta^{j+l-1} + jl g^{22} \\xi^{i+k}\\eta^{j+l-2}\n\\end{aligned}\n$$\n为求得矩阵元素 $K_{(ij),(kl)} = \\langle \\phi_{ij}, \\phi_{kl} \\rangle_{E,T}$，我们必须在 $\\widehat{T}$ 上对该表达式进行积分。这需要计算形如 $\\int_{\\widehat{T}} \\xi^a \\eta^b \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$ 的积分。\n\n#### 2. 单项式的精确积分\n\n令 $I(a,b) = \\int_{\\widehat{T}} \\xi^a \\eta^b \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。参考三角形 $\\widehat{T}$ 是域 $\\{(\\xi,\\eta) \\in\\mathbb{R}^2 \\mid \\xi\\ge 0, \\eta\\ge 0, \\xi+\\eta\\le 1\\}$。我们通过累次积分来计算此积分：\n$$\nI(a,b) = \\int_{0}^{1} \\xi^a \\left( \\int_{0}^{1-\\xi} \\eta^b \\,\\mathrm{d}\\eta \\right) \\mathrm{d}\\xi\n$$\n内层积分计算结果为：\n$$\n\\int_{0}^{1-\\xi} \\eta^b \\,\\mathrm{d}\\eta = \\left[ \\frac{\\eta^{b+1}}{b+1} \\right]_0^{1-\\xi} = \\frac{(1-\\xi)^{b+1}}{b+1}\n$$\n将此结果代入外层积分得到：\n$$\nI(a,b) = \\frac{1}{b+1} \\int_{0}^{1} \\xi^a (1-\\xi)^{b+1} \\,\\mathrm{d}\\xi\n$$\n这个积分与欧拉贝塔函数 $B(x,y) = \\int_0^1 t^{x-1}(1-t)^{y-1} dt = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}$ 有关。设 $x-1=a$ 和 $y-1=b+1$，我们有 $x=a+1$ 和 $y=b+2$。对于非负整数 $a, b$，使用 $\\Gamma(n+1)=n!$，我们得到：\n$$\n\\int_{0}^{1} \\xi^a (1-\\xi)^{b+1} \\,\\mathrm{d}\\xi = B(a+1, b+2) = \\frac{\\Gamma(a+1)\\Gamma(b+2)}{\\Gamma(a+b+3)} = \\frac{a!(b+1)!}{(a+b+2)!}\n$$\n因此，积分的精确值为：\n$$\nI(a,b) = \\frac{1}{b+1} \\frac{a!(b+1)!}{(a+b+2)!} = \\frac{a!b!}{(a+b+2)!}\n$$\n此公式对整数 $a, b \\ge 0$ 有效。\n\n#### 3. 组装与分析算法\n\n综合这些结果，刚度矩阵的元素为：\n$$\nK_{(ij),(kl)} = |\\det(\\mathbf{J})| \\left[ ik g^{11} I(i+k-2, j+l) + (il+jk) g^{12} I(i+k-1, j+l-1) + jl g^{22} I(i+k, j+l-2) \\right]\n$$\n其中，如果其整数系数（$ik$ 等）为零，则任何项均视为零，这能正确处理导数消失的边界情况。\n\n整体算法如下：\n1.  对于每个测试案例（顶点 $\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\boldsymbol{v}_2$ 和次数 $p$）：\n    a. 构建雅可比矩阵 $\\mathbf{J} = [\\boldsymbol{v}_1-\\boldsymbol{v}_0 \\mid \\boldsymbol{v}_2-\\boldsymbol{v}_0]$。\n    b. 计算 $\\det(\\mathbf{J})$ 和 $\\mathbf{G}^{-1} = (\\mathbf{J}^\\top\\mathbf{J})^{-1}$。\n2.  为 $1 \\le i+j \\le p$ 生成一个有序的基函数索引列表 $(i,j)$。设此基的大小为 $N_p$。\n3.  对所有基函数对应用 $K_{(ij),(kl)}$ 的公式，组装 $N_p \\times N_p$ 矩阵 $\\mathbf{K}$。函数 $I(a,b)$ 使用阶乘实现。\n4.  使用数值稳定的算法（例如 `numpy.linalg.eigvalsh`）计算对称矩阵 $\\mathbf{K}$ 的特征值。计算条件数 $\\kappa(\\mathbf{K}) = \\lambda_{\\max}/\\lambda_{\\min}$ 并报告 $\\log_{10}(\\kappa)$。\n5.  为构建一个标准正交基 $\\{\\psi_m\\}$，我们寻求一个变换 $\\boldsymbol{\\psi} = \\boldsymbol{\\phi} \\mathbf{C}$，它关联了新基向量 $\\boldsymbol{\\psi}$ 与单项式基向量 $\\boldsymbol{\\phi}$。新基中的格拉姆矩阵为 $\\mathbf{K}' = \\mathbf{C}^\\top \\mathbf{K} \\mathbf{C}$。我们要求 $\\mathbf{K}'=\\mathbf{I}$。\n6.  $\\mathbf{K} = \\mathbf{L}\\mathbf{L}^\\top$ 的 Cholesky 分解提供了一个解。设 $\\mathbf{C} = (\\mathbf{L}^\\top)^{-1}$，可得 $(\\mathbf{L}^{-\\top})^\\top (\\mathbf{L}\\mathbf{L}^\\top) (\\mathbf{L}^{-\\top}) = \\mathbf{L}^{-1}\\mathbf{L}\\mathbf{L}^\\top(\\mathbf{L}^\\top)^{-1} = \\mathbf{I}$。\n7.  矩阵 $\\mathbf{C}$ 通过求解三角系统 $\\mathbf{L}^\\top \\mathbf{C} = \\mathbf{I}$ 来计算。\n8.  数值上形成新的格拉姆矩阵 $\\mathbf{K}' = \\mathbf{C}^\\top \\mathbf{K} \\mathbf{C}$，并计算其特征值 $\\lambda'_i$。计算与1的最大绝对偏差 $\\delta = \\max_i|\\lambda'_i-1|$，作为数值精度的度量。\n9.  收集每个测试案例的结果 $[\\log_{10}(\\kappa), \\delta]$，并按规定格式化。\n\n此过程严格遵守问题要求，使用第一性原理和精确积分来实现可验证的数值结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_triangular\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        ([(0, 0), (1, 0), (0, 1)], 1),\n        ([(0, 0), (1, 0), (1/2, math.sqrt(3)/2)], 3),\n        ([(0, 0), (2, 0), (0, 1)], 3),\n        ([(0, 0), (1, 0), (0.01, 1)], 3),\n    ]\n\n    results = []\n    for vertices, p in test_cases:\n        result = _solve_case(vertices, p)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    output_str = \"[\" + \",\".join(f\"[{r[0]},{r[1]}]\" for r in results) + \"]\"\n    print(output_str)\n\ndef _solve_case(vertices, p):\n    \"\"\"\n    Solves a single test case for a given triangle and polynomial degree.\n    \"\"\"\n    # 1. Compute geometric factors from the affine mapping.\n    v = np.array(vertices, dtype=float)\n    J = np.array([v[1] - v[0], v[2] - v[0]]).T\n    detJ = np.linalg.det(J)\n    \n    # Assert non-degenerate triangle.\n    if abs(detJ)  np.finfo(float).eps:\n        raise ValueError(\"Degenerate triangle with zero area.\")\n        \n    G = J.T @ J\n    G_inv = np.linalg.inv(G)\n    g11, g12, g22 = G_inv[0, 0], G_inv[0, 1], G_inv[1, 1]\n\n    # 2. Generate the monomial basis (excluding the constant term).\n    # The ordering is by total degree, then by decreasing power of xi.\n    basis_indices = []\n    for total_deg in range(1, p + 1):\n        for i in range(total_deg, -1, -1):\n            j = total_deg - i\n            basis_indices.append((i, j))\n    Np = len(basis_indices)\n\n    # 3. Precompute factorials for exact integration.\n    # The max argument to a factorial will be 2*p+2 for the denominator of I(a,b).\n    max_fact_arg = 2 * p + 2\n    factorials = [math.factorial(i) for i in range(max_fact_arg + 1)]\n\n    def I_exact(a, b):\n        \"\"\"Computes I(a,b) = integral of xi^a * eta^b over the reference triangle.\"\"\"\n        if a  0 or b  0:\n            # The formula works for non-negative integers. Integrals of terms with\n            # negative powers do not appear due to vanishing coefficients.\n            return 0.0\n        return factorials[a] * factorials[b] / factorials[a + b + 2]\n\n    # 4. Assemble the stiffness matrix K.\n    K = np.zeros((Np, Np))\n    for m in range(Np):\n        for n in range(m, Np): # Exploit symmetry K_mn = K_nm\n            i, j = basis_indices[m]\n            k, l = basis_indices[n]\n            \n            # First term: derivative wrt xi-xi\n            term1 = 0\n            if i > 0 and k > 0:\n                term1 = i * k * g11 * I_exact(i + k - 2, j + l)\n            \n            # Second term: mixed derivatives\n            term2 = 0\n            if (i > 0 or k > 0) and (j > 0 or l > 0):\n                term2 = (i * l + j * k) * g12 * I_exact(i + k - 1, j + l - 1)\n            \n            # Third term: derivative wrt eta-eta\n            term3 = 0\n            if j > 0 and l > 0:\n                term3 = j * l * g22 * I_exact(i + k, j + l - 2)\n            \n            K[m, n] = abs(detJ) * (term1 + term2 + term3)\n    \n    # Fill in the lower triangle due to symmetry.\n    K = K + K.T - np.diag(np.diag(K))\n\n    # 5. Analyze the original stiffness matrix K.\n    eigvals = np.linalg.eigvalsh(K)\n    # Eigvals should be positive since K is symmetric positive definite.\n    # Smallest eigenvalue can be close to zero for ill-conditioned matrices.\n    if eigvals[0] = 0:\n        kappa = np.inf\n    else:\n        kappa = eigvals[-1] / eigvals[0]\n    log10_kappa = np.log10(kappa)\n\n    # 6. Construct the orthonormal basis transformation.\n    # K = L @ L.T\n    L = np.linalg.cholesky(K)\n    # The change-of-basis matrix C is (L.T)^-1. We solve L.T @ C = I.\n    C = solve_triangular(L.T, np.identity(Np), lower=False)\n\n    # The stiffness matrix in the new basis is K' = C.T @ K @ C, which should be identity.\n    K_prime = C.T @ K @ C\n    \n    # 7. Analyze the new stiffness matrix K'.\n    eigvals_prime = np.linalg.eigvalsh(K_prime)\n    delta = np.max(np.abs(eigvals_prime - 1.0))\n    \n    return [round(log10_kappa, 6), round(delta, 12)]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}