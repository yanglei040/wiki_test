{
    "hands_on_practices": [
        {
            "introduction": "在偏微分方程的数值方法中，函数空间的选取至关重要。本练习旨在通过一个具体的计算，阐明一个核心概念：一个基底在一个内积（如 $L^2$）下的正交性，并不意味着它在另一个内积（如 $H^1$）下同样正交。通过直接计算Dubiner基函数在 $H^1$ 能量内积下的值，您将亲手验证这一重要区别。",
            "id": "3407027",
            "problem": "考虑参考三角形 $\\widehat{T} \\subset \\mathbb{R}^{2}$，其定义为 $\\widehat{T}=\\{(x,y)\\in \\mathbb{R}^{2}: x\\ge 0,\\ y\\ge 0,\\ x+y\\le 1\\}$。定义 $H^{1}$ 型内积（梯度能量内积）为\n$$\n\\langle f,g\\rangle_{H^{1}(\\widehat{T})} \\;=\\; \\int_{\\widehat{T}} \\nabla f(x,y)\\cdot \\nabla g(x,y)\\,dx\\,dy.\n$$\n在谱方法和间断 Galerkin 方法中，三角形上的 Dubiner 多项式基被构造成在 $\\widehat{T}$ 上是 $L^{2}$ 正交的。对于最低的非平凡多项式次数，可以（在相差一个乘法归一化常数的情况下）用以下显式线性多项式表示两个一次 Dubiner 模态\n$$\n\\phi_{1,0}(x,y) \\;=\\; 2x + y - 1, \\qquad \\phi_{0,1}(x,y) \\;=\\; 2y - 1,\n$$\n它们在 $\\widehat{T}$ 上彼此 $L^{2}$ 正交，且与常数模态 $L^{2}$ 正交。从 $L^{2}$ 正交性、梯度和上述内积的定义出发，通过显式计算内积 $\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})}$ 来确定 Dubiner 基在 $\\langle\\cdot,\\cdot\\rangle_{H^{1}(\\widehat{T})}$ 下是否正交。将此内积的计算值作为最终答案。如果计算值非零，则为 $H^{1}$ 正交性提供了一个反例。无需四舍五入。",
            "solution": "该问题要求计算在参考三角形 $\\widehat{T}$ 上两个指定的一次 Dubiner 多项式 $\\phi_{1,0}(x,y)$ 和 $\\phi_{0,1}(x,y)$ 之间的 $H^{1}$ 型内积。目的是确定这些基函数相对于该内积是否正交。如果两个函数的内积为零，则它们是正交的。\n\n参考三角形定义为 $\\widehat{T}=\\{(x,y)\\in \\mathbb{R}^{2}: x\\ge 0,\\ y\\ge 0,\\ x+y\\le 1\\}$。\n$H^{1}$ 型内积由下式给出：\n$$\n\\langle f,g\\rangle_{H^{1}(\\widehat{T})} \\;=\\; \\int_{\\widehat{T}} \\nabla f(x,y)\\cdot \\nabla g(x,y)\\,dx\\,dy\n$$\n这两个线性多项式函数是：\n$$\n\\phi_{1,0}(x,y) \\;=\\; 2x + y - 1\n$$\n$$\n\\phi_{0,1}(x,y) \\;=\\; 2y - 1\n$$\n第一步是计算每个函数的梯度。在二维笛卡尔坐标系中，梯度算子为 $\\nabla = \\left(\\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y}\\right)$。\n\n对于函数 $\\phi_{1,0}(x,y)$，我们计算其偏导数：\n$$\n\\frac{\\partial}{\\partial x} \\phi_{1,0}(x,y) = \\frac{\\partial}{\\partial x}(2x + y - 1) = 2\n$$\n$$\n\\frac{\\partial}{\\partial y} \\phi_{1,0}(x,y) = \\frac{\\partial}{\\partial y}(2x + y - 1) = 1\n$$\n因此，$\\phi_{1,0}$ 的梯度是常数向量：\n$$\n\\nabla \\phi_{1,0}(x,y) = (2, 1)\n$$\n对于函数 $\\phi_{0,1}(x,y)$，我们计算其偏导数：\n$$\n\\frac{\\partial}{\\partial x} \\phi_{0,1}(x,y) = \\frac{\\partial}{\\partial x}(2y - 1) = 0\n$$\n$$\n\\frac{\\partial}{\\partial y} \\phi_{0,1}(x,y) = \\frac{\\partial}{\\partial y}(2y - 1) = 2\n$$\n$\\phi_{0,1}$ 的梯度是常数向量：\n$$\n\\nabla \\phi_{0,1}(x,y) = (0, 2)\n$$\n下一步是计算这两个梯度向量的标量积（点积）。\n$$\n\\nabla \\phi_{1,0}(x,y) \\cdot \\nabla \\phi_{0,1}(x,y) = (2, 1) \\cdot (0, 2) = (2)(0) + (1)(2) = 0 + 2 = 2\n$$\n被积函数 $\\nabla \\phi_{1,0} \\cdot \\nabla \\phi_{0,1}$ 对于域 $\\widehat{T}$ 中的所有点 $(x,y)$ 都是常数值 $2$。\n\n现在，我们必须在参考三角形 $\\widehat{T}$ 上对这个常数进行积分，以求得内积的值：\n$$\n\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})} = \\int_{\\widehat{T}} 2 \\,dx\\,dy\n$$\n该积分等价于常数 $2$ 乘以域 $\\widehat{T}$ 的面积。域 $\\widehat{T}$ 是一个直角三角形，顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$。其底边长为 $1$，高为 $1$。面积计算如下：\n$$\n\\text{Area}(\\widehat{T}) = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}\n$$\n因此，内积的值为：\n$$\n\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})} = 2 \\times \\text{Area}(\\widehat{T}) = 2 \\times \\frac{1}{2} = 1\n$$\n作为验证，我们可以使用累次积分直接计算该积分。域 $\\widehat{T}$ 由不等式 $0 \\le x \\le 1$ 和 $0 \\le y \\le 1-x$ 定义。\n$$\n\\int_{\\widehat{T}} 2 \\,dx\\,dy = \\int_{0}^{1} \\int_{0}^{1-x} 2 \\,dy \\,dx\n$$\n首先，我们计算关于 $y$ 的内层积分：\n$$\n\\int_{0}^{1-x} 2 \\,dy = [2y]_{y=0}^{y=1-x} = 2(1-x) - 2(0) = 2(1-x)\n$$\n接下来，我们计算关于 $x$ 的外层积分：\n$$\n\\int_{0}^{1} 2(1-x) \\,dx = 2 \\left[ x - \\frac{x^2}{2} \\right]_{0}^{1} = 2 \\left( \\left(1 - \\frac{1^2}{2}\\right) - \\left(0 - \\frac{0^2}{2}\\right) \\right) = 2 \\left( 1 - \\frac{1}{2} \\right) = 2 \\left( \\frac{1}{2} \\right) = 1\n$$\n两种方法都证实了内积的值为 $1$。由于 $\\langle \\phi_{1,0}, \\phi_{0,1}\\rangle_{H^{1}(\\widehat{T})} = 1 \\ne 0$，函数 $\\phi_{1,0}$ 和 $\\phi_{0,1}$ 在给定的 $H^{1}$ 型内积下不是正交的。这为 Dubiner 基是 $H^{1}$ 正交的这一命题提供了一个直接的反例。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "构建高效且数值稳定的高阶方法，其关键在于能够稳定地计算正交基函数。本练习将指导您为三角形上的Dubiner型基底推导并实现三项递推关系，这是避免在高阶多项式求值中出现数值抵消误差的标准技术。完成此练习将使您掌握开发高阶谱元或DG方法代码的一项核心技能。",
            "id": "3407082",
            "problem": "您的任务是为参考三角形上的正交多项式基推导并实现稳定的三项递推关系，该基适用于高阶谱方法和间断伽辽金（DG）方法。请在通过将方形域映射到三角形而得到的标准折叠坐标参考三角形上进行操作，并使用 Dubiner 型正交多项式。您的推导必须从以下基本原理开始：(i) 关于内积及其相关权重的正交性定义，(ii) 任何关于正权重正交的多项式族都承认按阶数的三项递推关系，以及 (iii) Jacobi 多项式作为带权区间上的正交多项式的众所周知的性质。除这些基本原理外，不要假设任何专门的三角形公式。\n\n令 $r \\in [-1,1]$ 和 $s \\in [-1,1]$ 为张量积坐标。考虑由折叠坐标映射的雅可比行列式诱导的内积，即\n$$\n\\langle f,g \\rangle \\;=\\; \\int_{-1}^{1} \\int_{-1}^{1} f(r,s)\\, g(r,s)\\, J(s)\\, \\mathrm{d}r\\, \\mathrm{d}s, \n\\quad \\text{with } J(s) \\;=\\; \\frac{1-s}{4}.\n$$\n定义一个三角形模态基函数族 $\\{\\phi_{p,q}(r,s)\\}$，其索引为非负整数 $p,q$ 且满足 $p+q \\le N$（其中 $N \\in \\mathbb{N}$ 为多项式阶数），使得每个基函数都可分解为一个 $r$ 的多项式和一个 $s$ 的多项式与权重的乘积，其结构与 Legendre 和 Jacobi 多项式相关。目标是构建一个关于上述内积在三角形上的 $L^2$-标准正交基。您的任务是：\n\n1) 从内积定义和 $[-1,1]$ 上正交多项式存在三项递推关系出发，推导一个形式为\n$$\n\\phi_{p,q}(r,s) \\;=\\; P_p(r) \\, W_p(s) \\, Q_{p,q}(s),\n$$\n的可分离三角形基，其中 $P_p$ 是 $[-1,1]$ 上的 Legendre 多项式，$W_p(s)$ 是一个依赖于 $p$ 的合适权重因子，而 $Q_{p,q}$ 是 $[-1,1]$ 上的 Jacobi 多项式，其参数依赖于 $p$。证明当 $(p,q) \\ne (p',q')$ 时，内积 $\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle$ 为零，并求出 $L^2$ 范数平方 $\\|\\phi_{p,q}\\|_{L^2}^2$ 的闭式表达式。\n\n2) 仅使用开头陈述的基本事实，推导在 $p$ 和 $q$ 较大时稳定计算 $P_p(r)$ 和 $Q_{p,q}(s)$ 所需的三项递推关系，这与单变量 Jacobi 族中 $P_{n+1}^{(\\alpha,\\beta)}(x)$ 的递推关系类似。明确指定 0 阶和 1 阶的初始化，并给出用 $n$、$\\alpha$ 和 $\\beta$ 表示的递推系数。解释如何组合这些递推关系来计算完整的三角形基 $\\phi_{p,q}(r,s)$，以避免在 $N$ 较大时出现数值抵消。\n\n3) 设计一个算法，对于任意 $N \\in \\mathbb{N}$，通过将每个 $\\phi_{p,q}$ 除以其 $L^2$ 范数来构造基的 $L^2$-标准正交化版本。实现一个张量积高斯求积，该求积对总阶数至少为 $2N$ 的多项式是精确的，在 $r$ 和 $s$ 方向上均使用 Gauss–Legendre 求积，并在权重中明确包含雅可比因子 $J(s)$。使用此求积方法，为标准正交化基形成格拉姆矩阵，并量化其与单位矩阵的最大绝对偏差。\n\n4) 为证明三项递推关系的高阶稳定性，请在随机选择的点 $(r,s) \\in [-1,1]^2$ 上，将您使用推导的递推关系计算的三角形基与使用可信赖的 Jacobi 多项式求值器进行的直接计算进行比较。使用固定的随机种子以确保可复现性。报告两个基求值矩阵之间的相对弗罗贝尼乌斯范数误差，即\n$$\n\\frac{\\|B_{\\mathrm{rec}} - B_{\\mathrm{ref}}\\|_F}{\\|B_{\\mathrm{ref}}\\|_F},\n$$\n其中 $B_{\\mathrm{rec}}$ 和 $B_{\\mathrm{ref}}$ 的列对应于在同一组点上求值的标准正交化基函数。\n\n您的程序必须实现您推导的三项递推关系来计算基，并且必须使用足够精确的高斯求积来数值验证其标准正交性。\n\n测试套件和答案规范：\n- 使用以下指定阶数 $N$ 的测试用例：\n  - 用例 1：$N = 0$。计算格拉姆矩阵与单位矩阵的最大绝对偏差。\n  - 用例 2：$N = 4$。计算格拉姆矩阵与单位矩阵的最大绝对偏差。\n  - 用例 3：$N = 12$。计算格拉姆矩阵与单位矩阵的最大绝对偏差。\n  - 用例 4：$N = 25$。使用固定的种子 $12345$ 从 $[-1,1] \\times [-1,1]$ 中均匀抽取 $K = 80$ 个独立的对 $(r,s)$。计算您基于递推的标准正交基求值与直接从单变量 Jacobi 多项式构造的参考求值之间的相对弗罗贝尼乌斯范数误差。相对误差必须报告为单个浮点值。\n\n- 所有报告的量都必须是无量纲实数。不涉及角度或物理单位。\n\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为上述四个用例的结果，顺序与用例顺序一致。例如，它应打印\n“[x1,x2,x3,x4]”\n其中 $x1$、$x2$、$x3$ 和 $x4$ 分别是用例 1-4 的浮点结果。\n\n您的代码必须是完整的，无需用户输入即可按原样运行。",
            "solution": "该问题是适定的，具有科学依据，并包含唯一解所需的所有必要信息。它基于正交多项式的既定原理及其在数值方法（特别是谱方法和间断伽辽金方法）中的应用。问题的所有组成部分都是可形式化且客观的。因此，该问题被认定为有效。\n\n### 任务 1：正交基的推导\n\n问题将张量积域 $(r,s) \\in [-1,1]^2$ 上的内积定义为：\n$$\n\\langle f,g \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} f(r,s) g(r,s) J(s) \\mathrm{d}r \\mathrm{d}s, \\quad \\text{with } J(s) = \\frac{1-s}{4}\n$$\n我们寻求一个形式为 $\\phi_{p,q}(r,s) = P_p(r) W_p(s) Q_{p,q}(s)$ 的正交基函数族 $\\{\\phi_{p,q}(r,s)\\}_{p+q \\le N}$，其中 $P_p(r)$ 是 Legendre 多项式。\n\n让我们将此形式代入两个基函数 $\\phi_{p,q}$ 和 $\\phi_{p',q'}$ 的内积中：\n$$\n\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\left[ P_p(r) W_p(s) Q_{p,q}(s) \\right] \\left[ P_{p'}(r) W_{p'}(s) Q_{p',q'}(s) \\right] \\frac{1-s}{4} \\mathrm{d}r \\mathrm{d}s\n$$\n根据富比尼定理，我们可以分离积分：\n$$\n\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle = \\left( \\int_{-1}^{1} P_p(r) P_{p'}(r) \\mathrm{d}r \\right) \\left( \\frac{1}{4} \\int_{-1}^{1} W_p(s) W_{p'}(s) Q_{p,q}(s) Q_{p',q'}(s) (1-s) \\mathrm{d}s \\right)\n$$\n第一个积分涉及标准 Legendre 多项式 $P_n(x)$，它们在 $[-1,1]$ 上关于权重函数 $w(r)=1$ 正交。其正交关系为：\n$$\n\\int_{-1}^{1} P_p(r) P_{p'}(r) \\mathrm{d}r = \\frac{2}{2p+1} \\delta_{pp'}\n$$\n其中 $\\delta_{pp'}$ 是克罗内克 δ 符号。这表明要使 $\\langle \\phi_{p,q}, \\phi_{p',q'} \\rangle$ 不为零，必须有 $p=p'$。\n\n当 $p=p'$ 时，内积变为：\n$$\n\\langle \\phi_{p,q}, \\phi_{p,q'} \\rangle = \\frac{2}{2p+1} \\cdot \\frac{1}{4} \\int_{-1}^{1} [W_p(s)]^2 Q_{p,q}(s) Q_{p,q'}(s) (1-s) \\mathrm{d}s\n$$\n为使基是正交的，当 $q \\ne q'$ 时，此表达式必须为零。这意味着对于固定的 $p$，多项式集 $\\{Q_{p,q}(s)\\}_{q=0}^{N-p}$ 必须在区间 $[-1,1]$ 上关于权重函数 $w(s) = [W_p(s)]^2 (1-s)$ 正交。\n\n这种结构表明可以使用 Jacobi 多项式 $P_n^{(\\alpha,\\beta)}(x)$，它们在 $[-1,1]$ 上关于权重 $(1-x)^\\alpha(1+x)^\\beta$ 正交。为了将我们的权重 $w(s)$ 与 Jacobi 权重匹配，我们需要适当地选择 $W_p(s)$ 和 $Q_{p,q}(s)$ 的参数。这种类型的基，称为 Dubiner 型基，是由从一个标准三角形进行的特定坐标映射产生的。满足这些条件的形式是：\n$$\nQ_{p,q}(s) = P_q^{(2p+1, 0)}(s)\n\\quad \\text{and} \\quad\nW_p(s) = \\left(\\frac{1-s}{2}\\right)^p\n$$\n让我们验证这个选择。$s$-积分中的权重项变为：\n$$\n[W_p(s)]^2 (1-s) = \\left(\\frac{1-s}{2}\\right)^{2p} (1-s) = \\frac{1}{4^p} (1-s)^{2p+1}\n$$\n现在 $s$-积分（其中 $p=p'$）是：\n$$\n\\int_{-1}^{1} \\frac{1}{4^p} (1-s)^{2p+1} P_q^{(2p+1,0)}(s) P_{q'}^{(2p+1,0)}(s) \\mathrm{d}s\n$$\n这恰好是 Jacobi 多项式 $P_n^{(\\alpha,\\beta)}(s)$ 在 $n=q, \\alpha=2p+1, \\beta=0$ 时的正交积分。权重是 $(1-s)^{2p+1}(1+s)^0$，这与之一致。因此，当 $q \\ne q'$ 时，该积分为零。\n\n因此，基由以下公式给出：\n$$\n\\phi_{p,q}(r,s) = P_p(r) \\left(\\frac{1-s}{2}\\right)^p P_q^{(2p+1, 0)}(s)\n$$\n这个基是正交的。我们现在求其 $L^2$ 范数的平方，即 $\\|\\phi_{p,q}\\|_{L^2}^2 = \\langle \\phi_{p,q}, \\phi_{p,q} \\rangle$：\n$$\n\\|\\phi_{p,q}\\|^2 = \\left( \\frac{2}{2p+1} \\right) \\left( \\frac{1}{4} \\int_{-1}^{1} \\left[ \\left(\\frac{1-s}{2}\\right)^p P_q^{(2p+1,0)}(s) \\right]^2 (1-s) \\mathrm{d}s \\right)\n$$\n$$\n\\|\\phi_{p,q}\\|^2 = \\frac{2}{2p+1} \\cdot \\frac{1}{4} \\cdot \\frac{1}{4^p} \\int_{-1}^{1} (1-s)^{2p+1} \\left[ P_q^{(2p+1,0)}(s) \\right]^2 \\mathrm{d}s\n$$\nJacobi 多项式的范数平方由以下公式给出：\n$$\n\\int_{-1}^{1} (1-x)^\\alpha (1+x)^\\beta [P_n^{(\\alpha,\\beta)}(x)]^2 \\mathrm{d}x = \\frac{2^{\\alpha+\\beta+1}}{2n+\\alpha+\\beta+1} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{n! \\Gamma(n+\\alpha+\\beta+1)}\n$$\n对于我们的情况，$n=q, \\alpha=2p+1, \\beta=0$：\n$$\n\\int_{-1}^{1} (1-s)^{2p+1} \\left[ P_q^{(2p+1,0)}(s) \\right]^2 \\mathrm{d}s = \\frac{2^{2p+2}}{2q+2p+2} \\frac{\\Gamma(q+2p+2)\\Gamma(q+1)}{q! \\Gamma(q+2p+2)} = \\frac{2^{2p+1}}{p+q+1}\n$$\n将此代回 $\\|\\phi_{p,q}\\|^2$ 的表达式中：\n$$\n\\|\\phi_{p,q}\\|^2 = \\frac{2}{2p+1} \\cdot \\frac{1}{4^{p+1}} \\cdot \\frac{2^{2p+1}}{p+q+1} = \\frac{2}{2p+1} \\cdot \\frac{1}{2^{2p+2}} \\cdot \\frac{2^{2p+1}}{p+q+1} = \\frac{1}{(2p+1)(p+q+1)}\n$$\n这就是 $L^2$ 范数平方的闭式表达式。\n\n### 任务 2：三项递推关系\n\n任何正交多项式族都满足一个三项递推关系。这个性质对于它们的稳定和高效计算至关重要。我们需要 $P_p(r)$ 和 $Q_{p,q}(s) = P_q^{(2p+1,0)}(s)$ 的递推关系。\n\n**Legendre 多项式 $P_p(r)$ 的递推关系：**\nLegendre 多项式 $P_p(r) = P_p^{(0,0)}(r)$ 满足著名的 Bonnet 递推关系：\n$$\n(p+1)P_{p+1}(r) = (2p+1)rP_p(r) - pP_{p-1}(r)\n$$\n初始化：$P_0(r) = 1$ 和 $P_1(r) = r$。该递推关系是数值稳定的。\n\n**Jacobi 多项式 $P_q^{(2p+1,0)}(s)$ 的递推关系：**\nJacobi 多项式 $P_n^{(\\alpha,\\beta)}(x)$ 的通用三项递推关系是：\n$$\nc_n P_{n+1}^{(\\alpha,\\beta)}(x) = (d_n x + e_n) P_n^{(\\alpha,\\beta)}(x) - f_n P_{n-1}^{(\\alpha,\\beta)}(x)\n$$\n其中系数为：\n$$\nc_n = 2(n+1)(n+\\alpha+\\beta+1)(2n+\\alpha+\\beta) \\\\\nd_n = (2n+\\alpha+\\beta+1)(2n+\\alpha+\\beta)(2n+\\alpha+\\beta+2) \\\\\ne_n = (2n+\\alpha+\\beta+1)(\\alpha^2-\\beta^2) \\\\\nf_n = 2(n+\\alpha)(n+\\beta)(2n+\\alpha+\\beta+2)\n$$\n对于我们的基，我们需要计算 $Q_{p,q}(s) = P_q^{(2p+1,0)}(s)$，因此我们设置 $n=q$, $\\alpha=2p+1$, $\\beta=0$。递推关系是关于索引 $q$ 的。\n初始化：\n$P_0^{(\\alpha,\\beta)}(x) = 1$\n$P_1^{(\\alpha,\\beta)}(x) = \\frac{1}{2}(\\alpha+\\beta+2)x + \\frac{1}{2}(\\alpha-\\beta)$\n对于 $Q_{p,q}(s)$，当 $n=q=0, 1$ 时：\n$Q_{p,0}(s) = P_0^{(2p+1,0)}(s) = 1$\n$Q_{p,1}(s) = P_1^{(2p+1,0)}(s) = \\frac{1}{2}(2p+1+0+2)s + \\frac{1}{2}(2p+1-0) = \\frac{2p+3}{2}s + \\frac{2p+1}{2}$\n\n**组合与稳定性：**\n要在点 $(r,s)$ 处计算完整的标准正交基函数 $\\psi_{p,q}(r,s) = \\phi_{p,q}(r,s)/\\|\\phi_{p,q}\\|_{L^2}$：\n$$\n\\psi_{p,q}(r,s) = \\sqrt{(2p+1)(p+q+1)} \\cdot P_p(r) \\cdot \\left(\\frac{1-s}{2}\\right)^p \\cdot P_q^{(2p+1,0)}(s)\n$$\n计算最高阶为 $N$ 的一组基函数的步骤如下：\n1. 对于每个所需的阶数 $p \\le N$，使用 Legendre 递推关系计算并存储 $P_0(r), \\dots, P_p(r)$。\n2. 对于每一对 $(p,q)$ 且 $p+q \\le N$：\n   a. 检索预先计算的 $P_p(r)$。\n   b. 使用 Jacobi 递推关系计算 $P_0^{(2p+1,0)}(s), \\dots, P_q^{(2p+1,0)}(s)$。\n   c. 计算权重因子 $W_p(s) = ((1-s)/2)^p$。\n   d. 将各部分与归一化常数结合以获得 $\\psi_{p,q}(r,s)$。\n\n使用三项递推关系是稳定计算正交多项式的标准方法。它避免了计算可能病态的显式公式（如单项式展开）或涉及伽马函数的表达式。因此，通过对多项式因子 $P_p(r)$ 和 $Q_{p,q}(s)$ 使用这些稳定的递推关系，可以减轻问题中提到的数值抵消问题。因子 $P_p(r)$、$W_p(s)$ 和 $Q_{p,q}(s)$ 的乘法是直接的。虽然当 $s \\approx 1$ 且 $p$ 较大时，$W_p(s)$ 可能会变得非常小，但这是基函数形状的内在属性，其设计旨在处理折叠坐标映射在顶点 $s=1$ 处的几何退化。\n\n### 任务 3：正交性验证算法\n\n为了验证基 $\\{\\psi_{p,q}\\}$ 的标准正交性，我们计算格拉姆矩阵 $G$，其元素是内积 $G_{ij} = \\langle \\psi_i, \\psi_j \\rangle$，其中 $i, j$ 是映射到序对 $(p,q)$ 的索引。对于标准正交基，$G$ 必须是单位矩阵。我们使用数值求积来近似内积积分。\n\n**求积法则：**\n$G_{(p,q),(p',q')}$ 的被积函数是 $\\psi_{p,q}(r,s) \\psi_{p',q'}(r,s) \\frac{1-s}{4}$。$\\psi_{p,q}$ 关于 $r$ 的阶数是 $p$，关于 $s$ 的阶数是 $p+q$。被积函数多项式部分关于 $r$ 的总阶数最多为 $N+N=2N$。关于 $s$ 的总阶数最多为 $(p+q)+(p'+q') + 1 \\le N+N+1 = 2N+1$。\n在 $r$ 方向有 $Q_r$ 个点、在 $s$ 方向有 $Q_s$ 个点的张量积 Gauss-Legendre 求积，对于 $r$ 方向上阶数最高为 $2Q_r-1$ 和 $s$ 方向上阶数最高为 $2Q_s-1$ 的多项式是精确的。我们需要：\n$2Q_r-1 \\ge 2N \\implies Q_r \\ge N+1/2 \\implies Q_r \\ge N+1$。\n$2Q_s-1 \\ge 2N+1 \\implies Q_s \\ge N+3/2 \\implies Q_s \\ge N+2$。\n为安全和简便起见，我们选择 $Q_r = Q_s = Q = N+2$。令 $(z_k, w_k)_{k=1}^Q$ 为 $[-1,1]$ 上的 Gauss-Legendre 节点和权重。积分变为一个和式：\n$$\n\\langle \\psi_i, \\psi_j \\rangle \\approx \\sum_{k=1}^{Q} \\sum_{l=1}^{Q} \\psi_i(z_k,z_l) \\psi_j(z_k,z_l) \\frac{1-z_l}{4} w_k w_l\n$$\n**算法：**\n1. 给定 $N$，设置求积阶数 $Q = N+2$。\n2. 获取 $Q$ 个 Gauss-Legendre 节点和权重 $(z_k, w_k)$。\n3. 对 $p+q \\le N$ 形成包含 $M = (N+1)(N+2)/2$ 个基函数索引 $(p,q)$ 的集合。\n4. 构建一个大小为 $(Q^2 \\times M)$ 的“范德蒙”矩阵 $V$，其中 $V_{ij}$ 是第 $j$ 个标准正交基函数 $\\psi_j$ 在第 $i$ 个求积点 $(r_i, s_i)$ 处的值。\n5. 构建一个大小为 $(Q^2 \\times Q^2)$ 的对角权重矩阵 $W_{quad}$，其对角线元素为对应于每个求积点的 $w_k w_l (1-z_l)/4$。\n6. 计算格拉姆矩阵 $G = V^T W_{quad} V$。\n7. 与单位矩阵的最大绝对偏差为 $\\max |G - I|$。\n\n### 任务 4：稳定性比较\n\n为证明基于递推关系的计算的稳定性，我们将其与在一些随机点上使用可信赖的库函数进行的参考计算进行比较。\n\n**算法：**\n1. 给定 $N$、点数 $K$ 和一个随机种子。\n2. 生成 $K$ 个随机点 $(r_i, s_i) \\in [-1,1]^2$。\n3. 创建两个大小为 $(K \\times M)$ 的矩阵 $B_{\\mathrm{rec}}$ 和 $B_{\\mathrm{ref}}$。\n4. 通过使用任务 2 中描述的三项递推方法，计算所有 $i=1,\\dots,K$ 的所有 $M$ 个基函数 $\\psi_j(r_i,s_i)$，来填充 $B_{\\mathrm{rec}}$。\n5. 通过使用可信赖的库（例如 `scipy.special`）计算相同的基函数来填充 $B_{\\mathrm{ref}}$：\n   $$\n   \\psi_{(p,q)}(r,s) = \\sqrt{(2p+1)(p+q+1)} \\cdot \\texttt{legendre(p)(r)} \\cdot \\left(\\frac{1-s}{2}\\right)^p \\cdot \\texttt{jacobi(q, 2p+1, 0)(s)}\n   $$\n6. 计算相对弗罗贝尼乌斯范数误差：\n   $$\n   E_F = \\frac{\\|B_{\\mathrm{rec}} - B_{\\mathrm{ref}}\\|_F}{\\|B_{\\mathrm{ref}}\\|_F} = \\frac{\\sqrt{\\sum_{i,j} (B_{\\mathrm{rec},ij} - B_{\\mathrm{ref},ij})^2}}{\\sqrt{\\sum_{i,j} (B_{\\mathrm{ref},ij})^2}}\n   $$\n此误差量化了两种计算方法之间的数值差异。一个小的误差表明基于递推的实现是稳定和准确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jacobi as jacobi_ref\nfrom scipy.special import legendre as legendre_ref\nfrom scipy.special import roots_legendre\n\ndef jacobi_poly_recurrence(n_max, alpha, beta, x):\n    \"\"\"\n    Evaluates Jacobi polynomials P_n^{(\\alpha, \\beta)}(x) up to degree n_max\n    using the three-term recurrence relation.\n    `x` can be a scalar or a numpy array.\n    \"\"\"\n    if isinstance(x, (int, float)):\n        x = np.array([x])\n    \n    k = x.shape[0]\n    P = np.zeros((n_max + 1, k))\n\n    # P_0\n    P[0, :] = 1.0\n    if n_max == 0:\n        return P\n\n    # P_1\n    P[1, :] = 0.5 * (alpha + beta + 2.0) * x + 0.5 * (alpha - beta)\n    if n_max == 1:\n        return P\n\n    # Recurrence for P_2, ..., P_{n_max}\n    for n in range(1, n_max):\n        # Using the standard coefficient form c_n P_{n+1} = (d_n x + e_n) P_n - f_n P_{n-1}\n        # to improve numerical stability by minimizing intermediate divisions.\n        c_n = 2.0 * (n + 1.0) * (n + alpha + beta + 1.0) * (2.0 * n + alpha + beta)\n        d_n = (2.0 * n + alpha + beta + 1.0) * (2.0 * n + alpha + beta) * (2.0 * n + alpha + beta + 2.0)\n        e_n = (2.0 * n + alpha + beta + 1.0) * (alpha**2 - beta**2)\n        f_n = 2.0 * (n + alpha) * (n + beta) * (2.0 * n + alpha + beta + 2.0)\n        \n        # This check is for general robustness, although c_n != 0 for the parameters in this problem.\n        if abs(c_n)  1e-100:\n            # A numerically zero denominator; should not happen in this problem.\n            P[n + 1, :] = np.inf\n        else:\n            P[n + 1, :] = ((d_n * x + e_n) * P[n, :] - f_n * P[n - 1, :]) / c_n\n            \n    return P\n\ndef legendre_poly_recurrence(n_max, x):\n    \"\"\"\n    Evaluates Legendre polynomials P_n(x) up to degree n_max\n    using the three-term recurrence relation.\n    `x` can be a scalar or a numpy array.\n    \"\"\"\n    if isinstance(x, (int, float)):\n        x = np.array([x])\n\n    k = x.shape[0]\n    P = np.zeros((n_max + 1, k))\n\n    P[0, :] = 1.0\n    if n_max == 0:\n        return P\n    \n    P[1, :] = x\n    if n_max == 1:\n        return P\n\n    for n in range(1, n_max):\n        P[n + 1, :] = ((2.0 * n + 1.0) * x * P[n, :] - n * P[n - 1, :]) / (n + 1.0)\n        \n    return P\n\ndef eval_basis(N, r, s, use_recurrence=True):\n    \"\"\"\n    Evaluates the orthonormal triangular basis functions up to total degree N\n    at the point(s) (r, s).\n    \"\"\"\n    if isinstance(r, (int, float)):\n        r = np.array([r])\n        s = np.array([s])\n\n    num_pts = r.shape[0]\n    num_modes = (N + 1) * (N + 2) // 2\n    V = np.zeros((num_pts, num_modes))\n    \n    # Pre-compute all required Legendre polynomials\n    if use_recurrence:\n        leg_vals = legendre_poly_recurrence(N, r)\n    else:\n        leg_vals = np.array([legendre_ref(p)(r) for p in range(N + 1)])\n\n    mode_idx = 0\n    for p in range(N + 1):\n        if N - p  0: continue\n\n        # Pre-compute all required Jacobi polynomials for this p\n        alpha = 2.0 * p + 1.0\n        beta = 0.0\n        max_q = N - p\n        if use_recurrence:\n            jac_vals = jacobi_poly_recurrence(max_q, alpha, beta, s)\n        else:\n            jac_vals = np.array([jacobi_ref(q, alpha, beta)(s) for q in range(max_q + 1)])\n            if jac_vals.ndim == 1: # Scipy can return 1D array for single point\n                jac_vals = jac_vals[:, np.newaxis]\n\n        for q in range(max_q + 1):\n            Pp_r = leg_vals[p]\n            Wp_s = ((1.0 - s) / 2.0)**p\n            Qpq_s = jac_vals[q]\n            \n            norm_const = np.sqrt((2.0 * p + 1.0) * (p + q + 1.0))\n            V[:, mode_idx] = norm_const * Pp_r * Wp_s * Qpq_s\n            mode_idx += 1\n            \n    return V\n\ndef calculate_gram_matrix_error(N):\n    \"\"\"\n    Calculates the maximum absolute deviation of the Gram matrix from identity.\n    \"\"\"\n    if N  0: return 0.0\n    \n    num_modes = (N + 1) * (N + 2) // 2\n    if num_modes == 0: return 0.0\n    \n    # Quadrature order sufficient for exactness\n    Q = N + 2 \n    nodes, weights = roots_legendre(Q)\n    \n    r_pts, s_pts = np.meshgrid(nodes, nodes)\n    r_pts = r_pts.flatten()\n    s_pts = s_pts.flatten()\n    \n    w_r, w_s = np.meshgrid(weights, weights)\n    quad_weights = w_r.flatten() * w_s.flatten() * (1.0 - s_pts) / 4.0\n    \n    V = eval_basis(N, r_pts, s_pts, use_recurrence=True)\n    \n    # G = V^T * diag(quad_weights) * V\n    G = V.T @ (V * quad_weights[:, np.newaxis])\n    \n    if num_modes == 1:\n        return np.max(np.abs(G - 1.0))\n    return np.max(np.abs(G - np.identity(num_modes)))\n\ndef calculate_stability_error(N, K, seed):\n    \"\"\"\n    Calculates the relative Frobenius norm error between recurrence-based\n    and reference-based basis evaluation.\n    \"\"\"\n    if N  0: return 0.0\n\n    rng = np.random.default_rng(seed)\n    r_pts = rng.uniform(-1.0, 1.0, K)\n    s_pts = rng.uniform(-1.0, 1.0, K)\n    \n    B_rec = eval_basis(N, r_pts, s_pts, use_recurrence=True)\n    B_ref = eval_basis(N, r_pts, s_pts, use_recurrence=False)\n    \n    norm_diff = np.linalg.norm(B_rec - B_ref, 'fro')\n    norm_ref = np.linalg.norm(B_ref, 'fro')\n    \n    if norm_ref == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n        \n    return norm_diff / norm_ref\n\ndef solve():\n    \"\"\"\n    Main function to execute the test cases and print the results.\n    \"\"\"\n    test_cases = [0, 4, 12]\n    \n    results = []\n    \n    # Cases 1, 2, 3: Gram matrix deviation\n    for N in test_cases:\n        error = calculate_gram_matrix_error(N)\n        results.append(error)\n\n    # Case 4: Stability error\n    N_stab = 25\n    K_stab = 80\n    seed_stab = 12345\n    stability_err = calculate_stability_error(N_stab, K_stab, seed_stab)\n    results.append(stability_err)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于涉及扩散或类似二阶算子的PDE问题，$H^1$ 内积和相关的刚度矩阵是核心。本练习将理论与实践相结合，要求您为一个一般的物理三角形构建一个 $H^1$ 标准正交基。通过这种方式，您可以将刚度矩阵对角化（理想情况下变为单位阵），这将极大地改善问题的条件数并简化求解过程。",
            "id": "3407053",
            "problem": "我们要求您实现、验证和数值研究一个由从参考三角形到物理三角形的仿射映射所导出的$H^1$能量内积，为三角形上的多项式基组装相关的刚度（格拉姆）矩阵，关于该能量内积将这些基正交化，然后评估刚度矩阵的特征值聚集特性。目标是从与谱方法和间断伽辽金方法相关的索博列夫空间中的坐标变换和内积的第一性原理出发，避免使用问题陈述中的任何简化公式。\n\n参考三角形为 $\\widehat{T}=\\{(\\xi,\\eta)\\in\\mathbb{R}^2:\\ \\xi\\ge 0,\\ \\eta\\ge 0,\\ \\xi+\\eta\\le 1\\}$。一个到顶点为 $\\boldsymbol{v}_0,\\boldsymbol{v}_1,\\boldsymbol{v}_2\\in\\mathbb{R}^2$ 的物理三角形 $T$ 的仿射映射 $F:\\widehat{T}\\to T$ 由下式给出\n$$\n\\boldsymbol{x}(\\xi,\\eta) = \\boldsymbol{v}_0 + \\mathbf{A}\\begin{bmatrix}\\xi\\\\ \\eta\\end{bmatrix},\\quad \\mathbf{A}=\\begin{bmatrix}\\boldsymbol{v}_1-\\boldsymbol{v}_0  \\boldsymbol{v}_2-\\boldsymbol{v}_0\\end{bmatrix},\n$$\n其雅可比矩阵为 $\\mathbf{J}=\\mathbf{A}$，行列式为 $\\det(\\mathbf{J})$。物理三角形 $T$ 上函数 $u$ 和 $v$ 的$H^1$能量内积为\n$$\n\\langle u,v\\rangle_{E,T}=\\int_T \\nabla_{\\boldsymbol{x}} u(\\boldsymbol{x})\\cdot \\nabla_{\\boldsymbol{x}} v(\\boldsymbol{x})\\,\\mathrm{d}\\boldsymbol{x}.\n$$\n在仿射变量变换下，梯度通过链式法则变换为 $\\nabla_{\\boldsymbol{x}} = \\mathbf{J}^{-T}\\nabla_{(\\xi,\\eta)}$，面积元变换为 $\\mathrm{d}\\boldsymbol{x}=|\\det(\\mathbf{J})|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。因此，可以将能量内积表示为在 $\\widehat{T}$ 上的积分形式\n$$\n\\langle u,v\\rangle_{E,T}=\\int_{\\widehat{T}} \\left(\\nabla_{(\\xi,\\eta)} u\\right)^\\top \\mathbf{G}^{-1} \\left(\\nabla_{(\\xi,\\eta)} v\\right)\\,|\\det(\\mathbf{J})|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\\quad \\mathbf{G}=\\mathbf{J}^\\top\\mathbf{J}.\n$$\n考虑在 $\\widehat{T}$ 上的多项式基，由总次数 $i+j\\le p$ 的单项式 $\\phi_{ij}(\\xi,\\eta)=\\xi^i\\eta^j$ 给出（对于给定的整数 $p\\ge 1$），其中排除了常数项 $\\phi_{00}$，从而使得 $H^1$ 能量在其张成的空间上成为一个真正的内积。您将构建刚度（格拉姆）矩阵 $\\mathbf{K}$，其元素为\n$$\nK_{ab}=\\langle \\phi_a,\\phi_b\\rangle_{E,T},\n$$\n仅使用上述基本定义和变量替换，推导并实现元素积分的精确解析计算，然后通过对单项式关于 $\\langle\\cdot,\\cdot\\rangle_{E,T}$ 进行正交化，构建一个 $H^1$ 标准正交基。您不得使用数值积分；相反，您必须将所有项简化为 $\\int_{\\widehat{T}} \\xi^a \\eta^b\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$ 形式的积分，并使用您从第一性原理推导出的恒等式（例如，通过累次积分或beta函数恒等式）来精确计算它们。\n\n要求：\n- 仅从链式法则 $\\nabla_{\\boldsymbol{x}}=\\mathbf{J}^{-T}\\nabla_{(\\xi,\\eta)}$ 和积分的变量替换法则出发，推导一个精确组装 $\\mathbf{K}$ 的显式算法（无数值积分）。\n- 对于给定的物理三角形和多项式次数 $p$，使用推导出的精确公式组装 $\\mathbf{K}$，排除常数模态，以使所得矩阵为对称正定矩阵。\n- 通过一种仅使用已计算的 $\\mathbf{K}$ 的数值稳定的正交化方法（例如，通过 $\\mathbf{K}$ 的Cholesky分解），构建一个 $H^1$ 标准正交基。\n- 计算正交化前后 $\\mathbf{K}$ 的特征值。为每个测试案例报告两个诊断指标：\n  1) 原始单项式基中 $\\mathbf{K}$ 的条件数 $\\kappa=\\lambda_{\\max}/\\lambda_{\\min}$ 的以10为底的对数，四舍五入到六位小数；\n  2) 正交化后特征值与1的最大绝对偏差，$\\delta=\\max_i|\\lambda_i'-1|$，四舍五入到十二位小数。\n- 不涉及角度。没有需要报告的物理单位。\n\n测试套件：\n- 案例1：$\\text{vertices}=[(0,0),(1,0),(0,1)]$，$p=1$。\n- 案例2：$\\text{vertices}=[(0,0),(1,0),(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})]$，$p=3$。\n- 案例3：$\\text{vertices}=[(0,0),(2,0),(0,1)]$，$p=3$。\n- 案例4：$\\text{vertices}=[(0,0),(1,0),(0.01,1)]$，$p=3$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个内部列表对应一个测试案例，并按顺序包含两个浮点数 $[\\log_{10}(\\kappa),\\delta]$，并按指定要求进行四舍五入。例如，整体格式应类似于 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，在单行上，不需要空格。",
            "solution": "用户要求从第一性原理出发，对三角形有限元上的$H^1$能量内积进行详细的数值研究。这包括推导并实现刚度矩阵的精确公式，对基进行正交化，并分析所得矩阵的谱特性。\n\n### 问题验证\n\n问题陈述已经过验证，被认为是**有效的**。\n1.  **科学基础**：该问题基于矢量微积分、线性代数和有限元方法（特别是与谱方法/伽辽金方法相关的概念）的基本原理。所有定义和公式，如仿射映射、变量替换、链式法则和$H^1$内积，都是标准且正确的。\n2.  **适定性**：问题定义清晰。从基中排除常数多项式模态 $\\phi_{00}(\\xi,\\eta)=1$ 是至关重要的。对于指定基的张成空间中的任何非零多项式 $u$，其梯度 $\\nabla u$ 不恒为零。因此，$H^1$能量表达式 $\\langle u,u\\rangle_{E,T} = \\int_T |\\nabla u|^2 d\\boldsymbol{x}$ 是严格为正的，使其成为一个有效的内积。这确保了得到的格拉姆矩阵 $\\mathbf{K}$ 是对称正定的，保证了其特征值为实数且为正，其条件数是良定义的，并且其Cholesky分解存在。\n3.  **客观性**：问题以精确的数学语言表述，没有任何主观性或模糊性。\n4.  **完整性**：所有必要信息——定义、公式、测试案例数据和输出规范——均已提供。问题是自包含的。\n\n该问题是计算数学领域一个严谨且不平凡的练习，与指定领域直接相关。\n\n### 求解推导\n\n求解过程遵循以下步骤：\n1.  推导刚度（格拉姆）矩阵 $\\mathbf{K}$ 元素的显式公式。\n2.  推导在参考三角形上单项式积分的精确公式。\n3.  概述组装 $\\mathbf{K}$ 并执行所需分析的算法。\n\n#### 1. 刚度矩阵元素\n\n物理三角形 $T$ 上的 $H^1$ 能量内积被变换为在参考三角形 $\\widehat{T}$ 上的积分：\n$$\n\\langle u,v\\rangle_{E,T}=\\int_{\\widehat{T}} \\left(\\nabla_{(\\xi,\\eta)} u\\right)^\\top \\mathbf{G}^{-1} \\left(\\nabla_{(\\xi,\\eta)} v\\right)\\,|\\det(\\mathbf{J})|\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n基函数为非常数单项式 $\\phi_{ij}(\\xi,\\eta) = \\xi^i\\eta^j$，其中 $i,j \\ge 0$ 且 $1 \\le i+j \\le p$。设 $u = \\phi_{ij}$ 且 $v = \\phi_{kl}$。它们在参考坐标系中的梯度为：\n$$\n\\nabla_{(\\xi,\\eta)} \\phi_{ij} = \\begin{bmatrix} \\partial_\\xi (\\xi^i\\eta^j) \\\\ \\partial_\\eta (\\xi^i\\eta^j) \\end{bmatrix} = \\begin{bmatrix} i\\xi^{i-1}\\eta^j \\\\ j\\xi^i\\eta^{j-1} \\end{bmatrix}, \\quad\n\\nabla_{(\\xi,\\eta)} \\phi_{kl} = \\begin{bmatrix} k\\xi^{k-1}\\eta^l \\\\ l\\xi^k\\eta^{l-1} \\end{bmatrix}\n$$\n其中，如果像 $i$ 这样的索引为 $0$，则导数为 $0$，这实际上使得任何带有因子 $i$ 的项无效。\n\n矩阵 $\\mathbf{G}^{-1}$ 是度量张量 $\\mathbf{G} = \\mathbf{J}^\\top\\mathbf{J}$ 的逆矩阵。设其分量为 $g^{ab}$：$\\mathbf{G}^{-1} = \\begin{bmatrix} g^{11}  g^{12} \\\\ g^{21}  g^{22} \\end{bmatrix}$，该矩阵是对称的 ($g^{12}=g^{21}$)。被积函数的核心二次型为：\n$$\n\\begin{aligned}\n\\left(\\nabla \\phi_{ij}\\right)^\\top \\mathbf{G}^{-1} \\left(\\nabla \\phi_{kl}\\right) = \\begin{bmatrix} i\\xi^{i-1}\\eta^j  j\\xi^i\\eta^{j-1} \\end{bmatrix} \\begin{bmatrix} g^{11}  g^{12} \\\\ g^{12}  g^{22} \\end{bmatrix} \\begin{bmatrix} k\\xi^{k-1}\\eta^l \\\\ l\\xi^k\\eta^{l-1} \\end{bmatrix} \\\\\n= ik g^{11} \\xi^{i+k-2}\\eta^{j+l} + (il+jk) g^{12} \\xi^{i+k-1}\\eta^{j+l-1} + jl g^{22} \\xi^{i+k}\\eta^{j+l-2}\n\\end{aligned}\n$$\n为了找到矩阵元素 $K_{(ij),(kl)} = \\langle \\phi_{ij}, \\phi_{kl} \\rangle_{E,T}$，我们必须在 $\\widehat{T}$ 上对该表达式进行积分。这需要计算形如 $\\int_{\\widehat{T}} \\xi^a \\eta^b \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$ 的积分。\n\n#### 2. 单项式的精确积分\n\n设 $I(a,b) = \\int_{\\widehat{T}} \\xi^a \\eta^b \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。参考三角形 $\\widehat{T}$ 是域 $\\{(\\xi,\\eta) \\in\\mathbb{R}^2 \\mid \\xi\\ge 0, \\eta\\ge 0, \\xi+\\eta\\le 1\\}$。我们通过累次积分计算这个积分：\n$$\nI(a,b) = \\int_{0}^{1} \\xi^a \\left( \\int_{0}^{1-\\xi} \\eta^b \\,\\mathrm{d}\\eta \\right) \\mathrm{d}\\xi\n$$\n内层积分计算结果为：\n$$\n\\int_{0}^{1-\\xi} \\eta^b \\,\\mathrm{d}\\eta = \\left[ \\frac{\\eta^{b+1}}{b+1} \\right]_0^{1-\\xi} = \\frac{(1-\\xi)^{b+1}}{b+1}\n$$\n将此代入外层积分得到：\n$$\nI(a,b) = \\frac{1}{b+1} \\int_{0}^{1} \\xi^a (1-\\xi)^{b+1} \\,\\mathrm{d}\\xi\n$$\n这个积分与欧拉Beta函数有关，$B(x,y) = \\int_0^1 t^{x-1}(1-t)^{y-1} dt = \\frac{\\Gamma(x)\\Gamma(y)}{\\Gamma(x+y)}$。设 $x-1=a$ 和 $y-1=b+1$，我们有 $x=a+1$ 和 $y=b+2$。对于非负整数 $a, b$，使用 $\\Gamma(n+1)=n!$，我们得到：\n$$\n\\int_{0}^{1} \\xi^a (1-\\xi)^{b+1} \\,\\mathrm{d}\\xi = B(a+1, b+2) = \\frac{\\Gamma(a+1)\\Gamma(b+2)}{\\Gamma(a+b+3)} = \\frac{a!(b+1)!}{(a+b+2)!}\n$$\n因此，积分的精确值为：\n$$\nI(a,b) = \\frac{1}{b+1} \\frac{a!(b+1)!}{(a+b+2)!} = \\frac{a!b!}{(a+b+2)!}\n$$\n该公式对整数 $a, b \\ge 0$ 有效。\n\n#### 3. 组装与分析算法\n\n综合这些结果，刚度矩阵的元素为：\n$$\nK_{(ij),(kl)} = |\\det(\\mathbf{J})| \\left[ ik g^{11} I(i+k-2, j+l) + (il+jk) g^{12} I(i+k-1, j+l-1) + jl g^{22} I(i+k, j+l-2) \\right]\n$$\n其中，如果整数系数（$ik$等）为零，则任何项都视为零，这正确地处理了导数消失的边界情况。\n\n总体算法如下：\n1.  对于每个测试案例（顶点 $\\boldsymbol{v}_0, \\boldsymbol{v}_1, \\boldsymbol{v}_2$ 和次数 $p$）：\n    a. 构建雅可比矩阵 $\\mathbf{J} = [\\boldsymbol{v}_1-\\boldsymbol{v}_0 \\mid \\boldsymbol{v}_2-\\boldsymbol{v}_0]$。\n    b. 计算 $\\det(\\mathbf{J})$ 和 $\\mathbf{G}^{-1} = (\\mathbf{J}^\\top\\mathbf{J})^{-1}$。\n2.  为 $1 \\le i+j \\le p$ 生成基函数索引 $(i,j)$ 的有序列表。设此基的大小为 $N_p$。\n3.  对所有基函数对应用 $K_{(ij),(kl)}$ 的公式，组装 $N_p \\times N_p$ 矩阵 $\\mathbf{K}$。函数 $I(a,b)$ 使用阶乘实现。\n4.  使用数值稳定算法（例如 `numpy.linalg.eigvalsh`）计算对称矩阵 $\\mathbf{K}$ 的特征值。计算条件数 $\\kappa(\\mathbf{K}) = \\lambda_{\\max}/\\lambda_{\\min}$ 并报告 $\\log_{10}(\\kappa)$。\n5.  为了构建一个标准正交基 $\\{\\psi_m\\}$，我们寻求一个变换 $\\boldsymbol{\\psi} = \\boldsymbol{\\phi} \\mathbf{C}$，它关联新基向量 $\\boldsymbol{\\psi}$ 和单项式基向量 $\\boldsymbol{\\phi}$。新基下的格拉姆矩阵是 $\\mathbf{K}' = \\mathbf{C}^\\top \\mathbf{K} \\mathbf{C}$。我们要求 $\\mathbf{K}'=\\mathbf{I}$。\n6.  $\\mathbf{K} = \\mathbf{L}\\mathbf{L}^\\top$ 的Cholesky分解提供了一个解决方案。令 $\\mathbf{C} = (\\mathbf{L}^\\top)^{-1}$ 可得 $(\\mathbf{L}^{-\\top})^\\top (\\mathbf{L}\\mathbf{L}^\\top) (\\mathbf{L}^{-\\top}) = \\mathbf{L}^{-1}\\mathbf{L}\\mathbf{L}^\\top(\\mathbf{L}^\\top)^{-1} = \\mathbf{I}$。\n7.  矩阵 $\\mathbf{C}$ 通过求解三角系统 $\\mathbf{L}^\\top \\mathbf{C} = \\mathbf{I}$ 来计算。\n8.  数值上构造新的格拉姆矩阵 $\\mathbf{K}' = \\mathbf{C}^\\top \\mathbf{K} \\mathbf{C}$，并计算其特征值 $\\lambda'_i$。计算其与1的最大绝对偏差 $\\delta = \\max_i|\\lambda'_i-1|$，作为数值准确性的度量。\n9.  为每个测试案例收集结果 $[\\log_{10}(\\kappa), \\delta]$，并按指定格式进行格式化。\n\n此过程严格遵守了问题的要求，使用第一性原理和精确积分来获得可验证的数值结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_triangular\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        ([(0, 0), (1, 0), (0, 1)], 1),\n        ([(0, 0), (1, 0), (1/2, math.sqrt(3)/2)], 3),\n        ([(0, 0), (2, 0), (0, 1)], 3),\n        ([(0, 0), (1, 0), (0.01, 1)], 3),\n    ]\n\n    results = []\n    for vertices, p in test_cases:\n        result = _solve_case(vertices, p)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    output_str = \"[\" + \",\".join(f\"[{r[0]},{r[1]}]\" for r in results) + \"]\"\n    print(output_str)\n\ndef _solve_case(vertices, p):\n    \"\"\"\n    Solves a single test case for a given triangle and polynomial degree.\n    \"\"\"\n    # 1. Compute geometric factors from the affine mapping.\n    v = np.array(vertices, dtype=float)\n    J = np.array([v[1] - v[0], v[2] - v[0]]).T\n    detJ = np.linalg.det(J)\n    \n    # Assert non-degenerate triangle.\n    if abs(detJ)  np.finfo(float).eps:\n        raise ValueError(\"Degenerate triangle with zero area.\")\n        \n    G = J.T @ J\n    G_inv = np.linalg.inv(G)\n    g11, g12, g22 = G_inv[0, 0], G_inv[0, 1], G_inv[1, 1]\n\n    # 2. Generate the monomial basis (excluding the constant term).\n    # The ordering is by total degree, then by decreasing power of xi.\n    basis_indices = []\n    for total_deg in range(1, p + 1):\n        for i in range(total_deg, -1, -1):\n            j = total_deg - i\n            basis_indices.append((i, j))\n    Np = len(basis_indices)\n\n    # 3. Precompute factorials for exact integration.\n    # The max argument to a factorial will be 2*p+2 for the denominator of I(a,b).\n    max_fact_arg = 2 * p + 2\n    factorials = [math.factorial(i) for i in range(max_fact_arg + 1)]\n\n    def I_exact(a, b):\n        \"\"\"Computes I(a,b) = integral of xi^a * eta^b over the reference triangle.\"\"\"\n        if a  0 or b  0:\n            # The formula works for non-negative integers. Integrals of terms with\n            # negative powers do not appear due to vanishing coefficients.\n            return 0.0\n        return factorials[a] * factorials[b] / factorials[a + b + 2]\n\n    # 4. Assemble the stiffness matrix K.\n    K = np.zeros((Np, Np))\n    for m in range(Np):\n        for n in range(m, Np): # Exploit symmetry K_mn = K_nm\n            i, j = basis_indices[m]\n            k, l = basis_indices[n]\n            \n            # First term: derivative wrt xi-xi\n            term1 = 0\n            if i > 0 and k > 0:\n                term1 = i * k * g11 * I_exact(i + k - 2, j + l)\n            \n            # Second term: mixed derivatives\n            term2 = 0\n            if (i > 0 or k > 0) and (j > 0 or l > 0):\n                term2 = (i * l + j * k) * g12 * I_exact(i + k - 1, j + l - 1)\n            \n            # Third term: derivative wrt eta-eta\n            term3 = 0\n            if j > 0 and l > 0:\n                term3 = j * l * g22 * I_exact(i + k, j + l - 2)\n            \n            K[m, n] = abs(detJ) * (term1 + term2 + term3)\n    \n    # Fill in the lower triangle due to symmetry.\n    K = K + K.T - np.diag(np.diag(K))\n\n    # 5. Analyze the original stiffness matrix K.\n    eigvals = np.linalg.eigvalsh(K)\n    # Eigvals should be positive since K is symmetric positive definite.\n    # Smallest eigenvalue can be close to zero for ill-conditioned matrices.\n    if eigvals[0] = 0:\n        kappa = np.inf\n    else:\n        kappa = eigvals[-1] / eigvals[0]\n    log10_kappa = np.log10(kappa)\n\n    # 6. Construct the orthonormal basis transformation.\n    # K = L @ L.T\n    L = np.linalg.cholesky(K)\n    # The change-of-basis matrix C is (L.T)^-1. We solve L.T @ C = I.\n    C = solve_triangular(L.T, np.identity(Np), lower=False)\n\n    # The stiffness matrix in the new basis is K' = C.T @ K @ C, which should be identity.\n    K_prime = C.T @ K @ C\n    \n    # 7. Analyze the new stiffness matrix K'.\n    eigvals_prime = np.linalg.eigvalsh(K_prime)\n    delta = np.max(np.abs(eigvals_prime - 1.0))\n    \n    return [round(log10_kappa, 6), round(delta, 12)]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}