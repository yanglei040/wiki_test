{
    "hands_on_practices": [
        {
            "introduction": "在间断Galerkin (DG)方法中，单元之间的信息通过它们交界面上的数值通量来交换。提升算子 (lifting operator) 是将这些界面上的信息转化为单元内部体项的关键机制。这项练习  通过一个具体的计算来揭示这个抽象概念，并将其与基本的散度定理联系起来，加深对DG方法中通量处理的理解。",
            "id": "3366699",
            "problem": "考虑在参考三角形 $K$ 上的不连续伽辽金 (DG) 方法，其顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$。令 $\\lambda_{1}=1-x-y$、$\\lambda_{2}=x$ 和 $\\lambda_{3}=y$ 表示 $K$ 上的重心坐标。对于总次数 $n=2$，$K$ 上的Bernstein基函数由 $B^{2}_{i j k} = \\dfrac{2!}{i! j! k!} \\lambda_{1}^{i} \\lambda_{2}^{j} \\lambda_{3}^{k}$ 给出，其中 $i+j+k=2$。令 $f$ 为与 $\\lambda_{1}$ 相关顶点相对的边，因此 $f=\\{\\lambda_{1}=0\\}$ 是连接 $(1,0)$ 和 $(0,1)$ 的线段。通过 $(x(t),y(t))=(t,1-t)$ 对 $f$进行参数化，其中 $t \\in [0,1]$。\n\n在面 $f$ 上，考虑一维 $2$ 次Bernstein基函数 $b_{0}(t)=(1-t)^{2}$、$b_{1}(t)=2 t (1-t)$ 和 $b_{2}(t)=t^{2}$。通过关于 $L^{2}(K)$ 内积的Riesz表示来定义面提升算子 $L_{f}:\\mathbb{P}^{2}(f)\\to \\mathbb{P}^{2}(K)$：对于任意 $r \\in \\mathbb{P}^{2}(f)$ 和任意 $v \\in \\mathbb{P}^{2}(K)$，\n$$\n\\int_{K} L_{f}(r)\\, v \\, \\mathrm{d}x = \\int_{f} r\\, v \\, \\mathrm{d}s.\n$$\n该提升算子是支集在 $f$ 上的数值通量贡献的典范体积表示。\n\n取特定的面函数 $r=b_{1}(t)=2 t (1-t)$。仅使用上述基本定义以及关于 $K$ 和 $f$ 的标准几何事实，计算标量\n$$\n\\int_{K} L_{f}(r)\\, \\mathrm{d}x,\n$$\n并在 $L_{f}$ 的定义恒等式中选择常数测试函数 $v \\equiv 1$ 来验证相应的一致性关系，该关系可被解释为散度定理的离散对应物。您的最终答案必须是积分的精确值，以最简闭合形式表示，不得有数值舍入。",
            "solution": "该问题要求计算标量 $\\int_{K} L_{f}(r)\\, \\mathrm{d}x$ 并验证一个一致性关系。对象 $L_{f}(r)$ 是面函数 $r \\in \\mathbb{P}^{2}(f)$ 在面提升算子 $L_{f}:\\mathbb{P}^{2}(f)\\to \\mathbb{P}^{2}(K)$ 下的像。该算子通过其在弱形式中的作用来定义，具体是通过关于 $L^{2}(K)$ 内积的Riesz表示。具体来说，对于任意测试函数 $v \\in \\mathbb{P}^{2}(K)$，以下恒等式成立：\n$$\n\\int_{K} L_{f}(r)\\, v \\, \\mathrm{d}x = \\int_{f} r\\, v \\, \\mathrm{d}s\n$$\n其中 $\\mathbb{P}^{2}(K)$ 是参考三角形 $K$ 上总次数至多为 $2$ 的多项式空间。\n\n主要任务是计算 $\\int_{K} L_{f}(r)\\, \\mathrm{d}x$ 的值。我们还被要求通过选择常数测试函数 $v \\equiv 1$ 来验证一个一致性关系。这两个任务是直接相关的。我们观察到，我们需要计算的积分 $\\int_{K} L_{f}(r)\\, \\mathrm{d}x$，恰好是当测试函数 $v$ 选择为常数函数 $v(x,y) = 1$ 时 $L_{f}$ 定义恒等式的左侧。\n\n函数 $v \\equiv 1$ 是一个 $0$ 次多项式。由于 $0 \\le 2$，它是测试空间 $\\mathbb{P}^{2}(K)$ 的一个有效成员。因此，我们可以将 $v=1$ 代入定义方程。代入后得到：\n$$\n\\int_{K} L_{f}(r) \\cdot 1 \\, \\mathrm{d}x = \\int_{f} r \\cdot 1 \\, \\mathrm{d}s\n$$\n简化后为：\n$$\n\\int_{K} L_{f}(r) \\, \\mathrm{d}x = \\int_{f} r \\, \\mathrm{d}s\n$$\n这个方程就是问题中提到的一致性关系。它表明提升后函数的体积积分等于原始面函数的面积分。通过建立这个等式，我们完成了任务的验证部分。要完成此题，我们只需要计算右侧的面（边）积分。\n\n面 $f$ 是连接顶点 $(1,0)$ 和 $(0,1)$ 的线段。它通过路径 $\\vec{\\gamma}(t) = (x(t), y(t)) = (t, 1-t)$ 进行参数化，其中 $t \\in [0,1]$。微分弧长元 $\\mathrm{d}s$ 由 $||\\vec{\\gamma}'(t)|| \\, \\mathrm{d}t$ 给出。首先，我们计算路径向量的导数：\n$$\n\\vec{\\gamma}'(t) = \\frac{\\mathrm{d}}{\\mathrm{d}t}(t, 1-t) = (1, -1)\n$$\n该向量的模，即速率，沿路径为常数：\n$$\n||\\vec{\\gamma}'(t)|| = \\sqrt{1^{2} + (-1)^{2}} = \\sqrt{1+1} = \\sqrt{2}\n$$\n因此，弧长元为 $\\mathrm{d}s = \\sqrt{2} \\, \\mathrm{d}t$。\n\n要在面上积分的函数被指定为 $r = b_{1}(t) = 2t(1-t)$。我们现在可以建立并计算在面 $f$ 上的定积分：\n$$\n\\int_{f} r \\, \\mathrm{d}s = \\int_{0}^{1} b_{1}(t) \\sqrt{2} \\, \\mathrm{d}t = \\int_{0}^{1} 2t(1-t) \\sqrt{2} \\, \\mathrm{d}t\n$$\n我们将常数因子 $2\\sqrt{2}$ 移到积分符号外：\n$$\n\\int_{f} r \\, \\mathrm{d}s = 2\\sqrt{2} \\int_{0}^{1} (t-t^{2}) \\, \\mathrm{d}t\n$$\n我们计算多项式 $t-t^{2}$ 的积分：\n$$\n\\int_{0}^{1} (t-t^{2}) \\, \\mathrm{d}t = \\left[ \\frac{t^{2}}{2} - \\frac{t^{3}}{3} \\right]_{0}^{1} = \\left(\\frac{1^{2}}{2} - \\frac{1^{3}}{3}\\right) - \\left(\\frac{0^{2}}{2} - \\frac{0^{3}}{3}\\right) = \\frac{1}{2} - \\frac{1}{3} = \\frac{3-2}{6} = \\frac{1}{6}\n$$\n将此结果代回，我们得到面积分的值：\n$$\n\\int_{f} r \\, \\mathrm{d}s = 2\\sqrt{2} \\left(\\frac{1}{6}\\right) = \\frac{2\\sqrt{2}}{6} = \\frac{\\sqrt{2}}{3}\n$$\n根据前面导出的一致性关系，所求体积积分的值等于此结果。\n$$\n\\int_{K} L_{f}(r)\\, \\mathrm{d}x = \\frac{\\sqrt{2}}{3}\n$$\n计算到此结束。结果是一个最简闭合形式的精确值。",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{3}}$$"
        },
        {
            "introduction": "微分方程的离散化需要一种表示梯度等微分算子的方法。Bernstein基在这一方面提供了特别优雅和结构化的表示。这个练习  将引导你为一个特定的基函数显式地构建梯度算子，从而揭示其稀疏结构以及它与低一阶基函数之间的关系。",
            "id": "3366732",
            "problem": "考虑一个平面上的仿射三角形，其顶点为 $\\boldsymbol{v}_{1}=(2,1)$、$\\boldsymbol{v}_{2}=(5,2)$ 和 $\\boldsymbol{v}_{3}=(-1,4)$。令 $(\\lambda_{1},\\lambda_{2},\\lambda_{3})$ 表示该三角形上的重心坐标，使得三角形内的任意点 $\\boldsymbol{x}$ 满足 $\\boldsymbol{x}=\\lambda_{1}\\boldsymbol{v}_{1}+\\lambda_{2}\\boldsymbol{v}_{2}+\\lambda_{3}\\boldsymbol{v}_{3}$，且 $\\lambda_{1}+\\lambda_{2}+\\lambda_{3}=1$。在使用单纯形上的Bernstein多项式基的间断Galerkin (DG)方法中，与多重指标 $\\alpha=(\\alpha_{1},\\alpha_{2},\\alpha_{3})$（其中 $\\alpha_{1}+\\alpha_{2}+\\alpha_{3}=p$）相关的 $p$ 次Bernstein基定义为 $B_{\\alpha}^{p}(\\lambda)=\\dfrac{p!}{\\alpha_{1}!\\,\\alpha_{2}!\\,\\alpha_{3}!}\\,\\lambda_{1}^{\\alpha_{1}}\\lambda_{2}^{\\alpha_{2}}\\lambda_{3}^{\\alpha_{3}}$。从这些定义以及重心坐标和链式法则的第一性原理出发，您将：\n- 计算此三角形上 $j\\in\\{1,2,3\\}$ 的常梯度 $\\nabla \\lambda_{j}$。\n- 使用规范的 2 次Bernstein基序 $\\big\\{(2,0,0),(1,1,0),(1,0,1),(0,2,0),(0,1,1),(0,0,2)\\big\\}$，显式地组装稀疏梯度算子，该算子将单个 3 次内部系数 $c_{(1,1,1)}$（与 $B_{(1,1,1)}^{3}$ 相关）映射到梯度场的 $x$ 和 $y$ 分量的 2 次系数向量。也就是说，写出两个 6 元系数向量，它们按照所述顺序在 2 次Bernstein基中展开 $(\\nabla B_{(1,1,1)}^{3})_{x}$ 和 $(\\nabla B_{(1,1,1)}^{3})_{y}$。\n\n将您的最终答案表示为单个行向量，其前六个元素是 $x$ 分量的权重，后六个元素是 $y$ 分量的权重，形式为精确的有理数。不需要四舍五入，也不需要单位。最终答案必须是单个闭式解析表达式。",
            "solution": "用户希望在间断Galerkin (DG)方法的背景下解决一个问题，具体涉及三角形单元上的Bernstein多项式基。该问题包括两部分：首先，计算给定三角形的重心坐标的梯度；其次，确定一个特定的 3 次Bernstein基函数的梯度在 2 次Bernstein基中表示时的系数。\n\n该问题被确定为有效，因为它在计算数学方面有科学依据，是适定的（提供了所有必要信息），并且是客观表述的，没有任何歧义。\n\n第一步是计算 $j \\in \\{1,2,3\\}$ 的重心坐标 $\\lambda_j$ 的常梯度。三角形的顶点给定为 $\\boldsymbol{v}_{1}=(2,1)$、$\\boldsymbol{v}_{2}=(5,2)$ 和 $\\boldsymbol{v}_{3}=(-1,4)$。三角形中的一个点 $\\boldsymbol{x}=(x,y)$ 可以使用重心坐标 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 表示为顶点的线性组合：\n$$\n\\boldsymbol{x} = \\lambda_{1}\\boldsymbol{v}_{1}+\\lambda_{2}\\boldsymbol{v}_{2}+\\lambda_{3}\\boldsymbol{v}_{3}\n$$\n满足约束条件 $\\lambda_{1}+\\lambda_{2}+\\lambda_{3}=1$。这可以写成矩阵形式：\n$$\n\\begin{pmatrix} x \\\\ y \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} x_1  x_2  x_3 \\\\ y_1  y_2  y_3 \\\\ 1  1  1 \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\\\ \\lambda_3 \\end{pmatrix}\n$$\n代入顶点坐标 $\\boldsymbol{v}_1=(2,1)$、$\\boldsymbol{v}_2=(5,2)$、$\\boldsymbol{v}_3=(-1,4)$：\n$$\n\\begin{pmatrix} x \\\\ y \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2  5  -1 \\\\ 1  2  4 \\\\ 1  1  1 \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\\\ \\lambda_3 \\end{pmatrix}\n$$\n令 $\\mathbf{M}$ 为 $3 \\times 3$ 的顶点坐标矩阵。为了找到作为 $x$ 和 $y$ 函数的 $\\lambda_j$，我们必须对 $\\mathbf{M}$求逆。$\\mathbf{M}$ 的行列式为：\n$$\n\\det(\\mathbf{M}) = 2(2 \\cdot 1 - 4 \\cdot 1) - 5(1 \\cdot 1 - 4 \\cdot 1) + (-1)(1 \\cdot 1 - 2 \\cdot 1) = 2(-2) - 5(-3) - 1(-1) = -4 + 15 + 1 = 12\n$$\n逆矩阵 $\\mathbf{M}^{-1}$ 由 $\\frac{1}{\\det(\\mathbf{M})}\\text{adj}(\\mathbf{M})$ 给出。伴随矩阵是代数余子矩阵的转置。\n$$\n\\mathbf{M}^{-1} = \\frac{1}{12} \\begin{pmatrix} y_2-y_3  x_3-x_2  x_2 y_3 - x_3 y_2 \\\\ y_3-y_1  x_1-x_3  x_3 y_1 - x_1 y_3 \\\\ y_1-y_2  x_2-x_1  x_1 y_2 - x_2 y_1 \\end{pmatrix} = \\frac{1}{12} \\begin{pmatrix} 2-4  -1-5  5(4)-(-1)(2) \\\\ 4-1  2-(-1)  (-1)(1)-2(4) \\\\ 1-2  5-2  2(2)-5(1) \\end{pmatrix} = \\frac{1}{12} \\begin{pmatrix} -2  -6  22 \\\\ 3  3  -9 \\\\ -1  3  -1 \\end{pmatrix}\n$$\n重心坐标通过 $\\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\\\ \\lambda_3 \\end{pmatrix} = \\mathbf{M}^{-1} \\begin{pmatrix} x \\\\ y \\\\ 1 \\end{pmatrix}$ 求得：\n$$\n\\lambda_1 = \\frac{1}{12}(-2x - 6y + 22) \\\\\n\\lambda_2 = \\frac{1}{12}(3x + 3y - 9) \\\\\n\\lambda_3 = \\frac{1}{12}(-x + 3y - 1)\n$$\n$\\lambda_j$ 的梯度是 $\\nabla \\lambda_j = (\\frac{\\partial \\lambda_j}{\\partial x}, \\frac{\\partial \\lambda_j}{\\partial y})$。这些是常向量：\n$$\n\\nabla \\lambda_1 = \\frac{1}{12}(-2, -6) = \\left(-\\frac{1}{6}, -\\frac{1}{2}\\right) \\\\\n\\nabla \\lambda_2 = \\frac{1}{12}(3, 3) = \\left(\\frac{1}{4}, \\frac{1}{4}\\right) \\\\\n\\nabla \\lambda_3 = \\frac{1}{12}(-1, 3) = \\left(-\\frac{1}{12}, \\frac{1}{4}\\right)\n$$\n作为一致性检查，$\\nabla\\lambda_1 + \\nabla\\lambda_2 + \\nabla\\lambda_3 = (-\\frac{1}{6}+\\frac{1}{4}-\\frac{1}{12}, -\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{4}) = (\\frac{-2+3-1}{12}, \\frac{-2+1+1}{4}) = (0,0)$，符合预期。\n\n问题的第二部分是计算对于 $\\alpha=(1,1,1)$ 的 $p=3$ 次Bernstein基函数 $B_{\\alpha}^{3}$ 的梯度，并将其分量在 $p-1=2$ 次基中表示。Bernstein基函数 $B_{\\alpha}^{p}$ 的梯度公式为：\n$$\n\\nabla B_{\\alpha}^{p}(\\lambda) = p \\sum_{j=1}^{3} B_{\\alpha-e_j}^{p-1}(\\lambda) \\nabla\\lambda_j\n$$\n其中 $e_j$ 是标准的多重指标单位向量，求和是对所有 $\\alpha_j>0$ 的 $j$ 进行。对于 $\\alpha=(1,1,1)$ 和 $p=3$：\n$$\n\\nabla B_{(1,1,1)}^{3}(\\lambda) = 3 \\left( B_{(1,1,1)-e_1}^{2} \\nabla\\lambda_1 + B_{(1,1,1)-e_2}^{2} \\nabla\\lambda_2 + B_{(1,1,1)-e_3}^{2} \\nabla\\lambda_3 \\right) \\\\\n= 3 B_{(0,1,1)}^{2} \\nabla\\lambda_1 + 3 B_{(1,0,1)}^{2} \\nabla\\lambda_2 + 3 B_{(1,1,0)}^{2} \\nabla\\lambda_3\n$$\n这个表达式将向量场 $\\nabla B_{(1,1,1)}^{3}$ 表示为 2 次Bernstein基函数的线性组合，其中系数是常向量。我们需要找到该梯度场的 $x$ 和 $y$ 分量的标量系数，这些系数是在有序的 2 次基 $\\beta \\in \\big\\{(2,0,0),(1,1,0),(1,0,1),(0,2,0),(0,1,1),(0,0,2)\\big\\}$ 中展开的。\n\n设展开式为 $\\nabla B_{(1,1,1)}^{3} = \\sum_{|\\beta|=2} \\boldsymbol{c}_{\\beta} B_{\\beta}^{2}$。根据上面的公式，非零向量系数 $\\boldsymbol{c}_{\\beta}$ 为：\n$$\n\\boldsymbol{c}_{(0,1,1)} = 3\\nabla\\lambda_1 = 3\\left(-\\frac{1}{6}, -\\frac{1}{2}\\right) = \\left(-\\frac{1}{2}, -\\frac{3}{2}\\right) \\\\\n\\boldsymbol{c}_{(1,0,1)} = 3\\nabla\\lambda_2 = 3\\left(\\frac{1}{4}, \\frac{1}{4}\\right) = \\left(\\frac{3}{4}, \\frac{3}{4}\\right) \\\\\n\\boldsymbol{c}_{(1,1,0)} = 3\\nabla\\lambda_3 = 3\\left(-\\frac{1}{12}, \\frac{1}{4}\\right) = \\left(-\\frac{1}{4}, \\frac{3}{4}\\right)\n$$\n所有其他系数 $\\boldsymbol{c}_{(2,0,0)}, \\boldsymbol{c}_{(0,2,0)}, \\boldsymbol{c}_{(0,0,2)}$ 都是零向量。\n\n问题要求给出两个 6 元系数向量，分别对应梯度的 $x$ 和 $y$ 分量，并按照给定的基序排列。令 $x$ 分量的有序系数向量为 $\\mathbf{g}_x$，$y$ 分量的有序系数向量为 $\\mathbf{g}_y$。\n\n基的顺序是：\n1. $\\beta = (2,0,0)$: 系数为 $\\boldsymbol{c}_{(2,0,0)} = (0,0)$。\n2. $\\beta = (1,1,0)$: 系数为 $\\boldsymbol{c}_{(1,1,0)} = (-\\frac{1}{4}, \\frac{3}{4})$。\n3. $\\beta = (1,0,1)$: 系数为 $\\boldsymbol{c}_{(1,0,1)} = (\\frac{3}{4}, \\frac{3}{4})$。\n4. $\\beta = (0,2,0)$: 系数为 $\\boldsymbol{c}_{(0,2,0)} = (0,0)$。\n5. $\\beta = (0,1,1)$: 系数为 $\\boldsymbol{c}_{(0,1,1)} = (-\\frac{1}{2}, -\\frac{3}{2})$。\n6. $\\beta = (0,0,2)$: 系数为 $\\boldsymbol{c}_{(0,0,2)} = (0,0)$。\n\n收集 $x$ 分量得到向量 $\\mathbf{g}_x$：\n$$\n\\mathbf{g}_x = \\left(0, -\\frac{1}{4}, \\frac{3}{4}, 0, -\\frac{1}{2}, 0\\right)\n$$\n收集 $y$ 分量得到向量 $\\mathbf{g}_y$：\n$$\n\\mathbf{g}_y = \\left(0, \\frac{3}{4}, \\frac{3}{4}, 0, -\\frac{3}{2}, 0\\right)\n$$\n最终答案是一个包含 $\\mathbf{g}_x$ 的元素，后跟 $\\mathbf{g}_y$ 的元素的单行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  -\\frac{1}{4}  \\frac{3}{4}  0  -\\frac{1}{2}  0  0  \\frac{3}{4}  \\frac{3}{4}  0  -\\frac{3}{2}  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在许多物理模拟中，如气体动力学，保持解的正性（positivity-preserving）至关重要。Bernstein基的凸包性质是设计此类稳健格式的关键。这项动手编程练习  将指导你实现一个简单而有效的限制器 (limiter)，它在保持单元平均值的同时强制施加物理边界，这是守恒型数值方法的一个基石。",
            "id": "3366720",
            "problem": "考虑在每个单元上使用Bernstein多项式基的一维间断Galerkin (DG)离散化。在参考区间上，次数为 $p$ 的Bernstein多项式定义为 $B_i^{p}(x) = \\binom{p}{i} x^i (1-x)^{p-i}$，其中 $i = 0,1,\\dots,p$ 且 $x \\in [0,1]$。在Bernstein基中表示的局部多项式 $u(x)$ 具有形式 $u(x) = \\sum_{i=0}^{p} c_i B_i^p(x)$，其中 $c_i$ 是Bernstein系数。Bernstein基的两个基本性质是：(1) 凸包性质，即对于所有 $x \\in [0,1]$，都有 $u(x) \\in [\\min_i c_i, \\max_i c_i]$；以及 (2) 积分恒等式 $\\int_0^1 B_i^p(x)\\,dx = \\frac{1}{p+1}$，这意味着单元平均值 $\\bar{u} = \\int_0^1 u(x)\\,dx = \\frac{1}{p+1}\\sum_{i=0}^{p} c_i$。\n\n您需要实现一个在Bernstein系数空间中对每个单元独立作用的简单斜率限制器。该限制器必须对每个单元满足以下约束：\n- 它必须精确保持单元平均值 $\\bar{u}$。\n- 它必须强制执行仅由相邻单元的平均值决定的系数边界。对于索引为 $j$ 且相邻单元为 $j-1$ 和 $j+1$ 的单元，定义 $L_j = \\min(\\bar{u}_{j-1}, \\bar{u}_{j+1})$ 和 $U_j = \\max(\\bar{u}_{j-1}, \\bar{u}_{j+1})$。在缺少相邻单元的域边界处，使用该单元自身的平均值代替缺失的相邻单元。限制后的系数 $c_{j,i}^{\\text{lim}}$ 必须对所有 $i$ 满足 $L_j \\le c_{j,i}^{\\text{lim}} \\le U_j$ 以及 $\\frac{1}{p+1}\\sum_{i=0}^{p} c_{j,i}^{\\text{lim}} = \\bar{u}_j$。\n\n斜率限制器应仅使用这些约束和基本事实来构建；不要假设任何额外的简化公式。数值研究必须通过量化限制前后的过冲和平均值保持情况来分析数据中的测试间断。\n\n实现一个程序，该程序：\n1. 对于每个测试用例，从原始（未限制的）单元平均值计算基于相邻单元的边界 $L_j$ 和 $U_j$。\n2. 逐单元应用限制器，以生成保持每个单元原始平均值并满足边界条件的限制后Bernstein系数。\n3. 对测试用例的整个网格计算：\n   - 限制前的最大系数过冲幅度：$\\max_{j,i}\\left(\\max(c_{j,i}-U_j, 0), \\max(L_j - c_{j,i}, 0)\\right)$。\n   - 限制后的最大系数过冲幅度，定义方式相同，但使用 $c_{j,i}^{\\text{lim}}$。\n   - 限制后的最大绝对平均值误差：$\\max_j \\left|\\frac{1}{p_j+1}\\sum_{i=0}^{p_j} c_{j,i}^{\\text{lim}} - \\frac{1}{p_j+1}\\sum_{i=0}^{p_j} c_{j,i}\\right|$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序汇总所有测试用例的结果，每个测试用例的结果是列表 $[\\text{overshoot\\_before}, \\text{overshoot\\_after}, \\text{mean\\_error}]$。\n\n使用以下测试套件。每个测试用例指定多项式次数 $p$、单元数量 $N$ 以及每个单元的Bernstein系数数组。以下所有数字均为实数标量。\n\n- 测试用例 A（间断点附近的正常路径）：$p = 3$，$N = 6$，每个单元的Bernstein系数数组为 $[c_{j,0}, c_{j,1}, c_{j,2}, c_{j,3}]$，其中 $j = 0,1,\\dots,5$：\n  - 单元 $0$：$[0.0, 0.0, 0.0, 0.0]$。\n  - 单元 $1$：$[0.0, -0.05, 0.05, 0.0]$。\n  - 单元 $2$：$[-0.2, 0.1, 0.1, 0.0]$。\n  - 单元 $3$：$[1.3, 1.1, 0.7, 0.9]$。\n  - 单元 $4$：$[1.0, 1.0, 1.0, 1.0]$。\n  - 单元 $5$：$[1.0, 1.05, 0.95, 1.0]$。\n\n- 测试用例 B（更高次数，更强振荡）：$p = 5$，$N = 6$，每个单元的数组为 $[c_{j,0}, c_{j,1}, c_{j,2}, c_{j,3}, c_{j,4}, c_{j,5}]$：\n  - 单元 $0$：$[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$。\n  - 单元 $1$：$[0.0, -0.1, 0.0, 0.05, -0.05, 0.1]$。\n  - 单元 $2$：$[-0.3, 0.05, 0.2, 0.1, -0.05, 0.0]$。\n  - 单元 $3$：$[1.2, 1.1, 0.6, 0.9, 1.0, 1.2]$。\n  - 单元 $4$：$[1.0, 1.0, 1.0, 1.0, 1.0, 1.0]$。\n  - 单元 $5$：$[1.0, 0.95, 1.05, 1.0, 1.0, 1.0]$。\n\n- 测试用例 C（已在界内）：$p = 3$，$N = 3$：\n  - 单元 $0$：$[0.0, 0.0, 0.0, 0.0]$。\n  - 单元 $1$：$[0.4, 0.5, 0.6, 0.5]$。\n  - 单元 $2$：$[1.0, 1.0, 1.0, 1.0]$。\n\n- 测试用例 D（边界处理）：$p = 4$，$N = 2$：\n  - 单元 $0$：$[-0.1, 0.0, 0.2, -0.05, -0.05]$。\n  - 单元 $1$：$[1.1, 0.8, 1.2, 1.0, 0.9]$。\n\n您的实现应对任何 $p$、$N$ 和系数数组具有通用性，但必须在无需外部输入的情况下对这些指定的测试运行。最终输出必须是如上所述打印的单行内容。",
            "solution": "用户提供了一个偏微分方程数值方法领域的问题，具体涉及使用Bernstein多项式基为间断Galerkin (DG)方法实现斜率限制器。该任务要求验证问题陈述，根据规定的约束条件开发合适的限制算法，实现该算法，并在给定的测试用例集上评估其性能。\n\n### 问题验证\n\n根据科学性、适定性和客观性标准对问题进行评估。\n\n-   **已知条件提取**：\n    -   **基**：$[0,1]$ 上的一维Bernstein多项式，$B_i^{p}(x) = \\binom{p}{i} x^i (1-x)^{p-i}$。\n    -   **表示**：单元 $j$ 中的多项式为 $u_j(x) = \\sum_{i=0}^{p} c_{j,i} B_i^p(x)$。\n    -   **单元平均值**：$\\bar{u}_j = \\frac{1}{p+1}\\sum_{i=0}^{p} c_{j,i}$。\n    -   **限制器约束**：对于限制后的系数 $c_{j,i}^{\\text{lim}}$：\n        1.  **平均值保持**：$\\frac{1}{p+1}\\sum_{i=0}^{p} c_{j,i}^{\\text{lim}} = \\bar{u}_j$。\n        2.  **系数边界**：$L_j \\le c_{j,i}^{\\text{lim}} \\le U_j$。\n    -   **边界定义**：对于单元 $j$，$L_j = \\min(\\bar{u}_{j-1}, \\bar{u}_{j+1})$ 且 $U_j = \\max(\\bar{u}_{j-1}, \\bar{u}_{j+1})$。在边界处，使用单元自身的平均值 $\\bar{u}_j$ 代替缺失的相邻单元。\n    -   **度量指标**：限制前后的最大系数过冲，以及限制后的最大绝对平均值误差。\n    -   **测试数据**：四个测试用例（A、B、C、D），指定了多项式次数 $p$、单元数量 $N$ 和初始Bernstein系数 $c_{j,i}$。\n\n-   **验证结论**：\n    1.  **科学性**：该问题在守恒律高阶数值方法的理论中有充分依据。Bernstein多项式、DG方法和斜率限制是标准课题。所提供的性质是正确的。\n    2.  **适定性**：该问题为限制后的解定义了一组约束。解存在的一个必要条件是单元平均值 $\\bar{u}_j$ 必须位于边界 $[L_j, U_j]$ 之内。对所有提供的测试用例进行检查，确认该条件 $L_j \\le \\bar{u}_j \\le U_j$ 对每个单元都成立。因此，这些约束并不矛盾。该问题要求构建一个限制器，并且可以从约束中推导出一个标准的、有原则的算法，这使得问题是适定的。\n    3.  **客观性**：所有定义、约束和要求的输出都经过数学上的精确指定，没有主观解释的余地。\n\n该问题被判定为 **有效**。下面是一个合理的解决方案。\n\n### 解法推导\n\n目标是为每个单元 $j$ 找到一组限制后的Bernstein系数 $\\{c_{j,i}^{\\text{lim}}\\}_{i=0}^p$，使其满足两个约束：精确保持单元平均值和遵守由相邻单元平均值定义的局部边界。\n\n让我们关注单个单元 $j$。我们有原始系数 $c_{j,i}$、原始单元平均值 $\\bar{u}_j$ 和规定的边界 $L_j$ 和 $U_j$。对新系数 $c_{j,i}^{\\text{lim}}$ 的约束是：\n1.  $\\sum_{i=0}^p c_{j,i}^{\\text{lim}} = \\sum_{i=0}^p c_{j,i}$（这意味着 $\\bar{u}_j^{\\text{lim}} = \\bar{u}_j$）。\n2.  $L_j \\le c_{j,i}^{\\text{lim}} \\le U_j$ 对所有 $i \\in \\{0, \\dots, p\\}$ 成立。\n\n构建此类限制器的一种有原则的方法是缩放系数围绕单元平均值的波动。我们提出一种形式为\n$$\nc_{j,i}^{\\text{lim}} = \\bar{u}_j + \\theta_j (c_{j,i} - \\bar{u}_j)\n$$\n的变换，其中 $\\theta_j \\in [0, 1]$ 是单元 $j$ 的缩放因子。$\\theta_j = 1$ 表示不应用限制，而 $\\theta_j = 0$ 则将解平坦化为单元平均值。\n\n让我们验证此变换对于任何 $\\theta_j$ 都保持单元平均值：\n$$\n\\sum_{i=0}^p c_{j,i}^{\\text{lim}} = \\sum_{i=0}^p \\left( \\bar{u}_j + \\theta_j (c_{j,i} - \\bar{u}_j) \\right) = \\sum_{i=0}^p \\bar{u}_j + \\theta_j \\sum_{i=0}^p (c_{j,i} - \\bar{u}_j)\n$$\n$$\n= (p+1)\\bar{u}_j + \\theta_j \\left( \\left(\\sum_{i=0}^p c_{j,i}\\right) - \\sum_{i=0}^p \\bar{u}_j \\right) = (p+1)\\bar{u}_j + \\theta_j \\left( (p+1)\\bar{u}_j - (p+1)\\bar{u}_j \\right) = (p+1)\\bar{u}_j\n$$\n除以 $(p+1)$ 可证实 $\\bar{u}_j^{\\text{lim}} = \\bar{u}_j$。平均值得以保持。\n\n接下来，我们必须选择 $\\theta_j$ 以满足边界 $L_j \\le c_{j,i}^{\\text{lim}} \\le U_j$。我们需要找到所需的最严格的缩放比例。\n\n-   **上界强制**：对于任何系数 $c_{j,i}$，我们需要 $c_{j,i}^{\\text{lim}} \\le U_j$。\n    $$\n    \\bar{u}_j + \\theta_j (c_{j,i} - \\bar{u}_j) \\le U_j\n    $$\n    如果 $c_{j,i} > \\bar{u}_j$，则项 $(c_{j,i} - \\bar{u}_j)$ 为正。关于 $\\theta_j$ 的不等式为 $\\theta_j \\le \\frac{U_j - \\bar{u}_j}{c_{j,i} - \\bar{u}_j}$。为了对所有此类系数都满足此条件，我们必须根据最大系数 $c_{j,\\max} = \\max_i c_{j,i}$ 来选择 $\\theta_j$。\n    设 $\\theta_j^+ = \\frac{U_j - \\bar{u}_j}{c_{j,\\max} - \\bar{u}_j}$，如果 $c_{j,\\max} > \\bar{u}_j$；否则设 $\\theta_j^+ = \\infty$（或一个 $\\ge 1$ 的值）（因为上界不需要限制）。\n-   **下界强制**：对于任何系数 $c_{j,i}$，我们需要 $c_{j,i}^{\\text{lim}} \\ge L_j$。\n    $$\n    \\bar{u}_j + \\theta_j (c_{j,i} - \\bar{u}_j) \\ge L_j\n    $$\n    如果 $c_{j,i}  \\bar{u}_j$，则项 $(c_{j,i} - \\bar{u}_j)$ 为负。两边同除以它会反转不等号：$\\theta_j \\le \\frac{L_j - \\bar{u}_j}{c_{j,i} - \\bar{u}_j} = \\frac{\\bar{u}_j - L_j}{\\bar{u}_j - c_{j,i}}$。为了对所有此类系数都满足此条件，我们使用最小系数 $c_{j,\\min} = \\min_i c_{j,i}$。\n    设 $\\theta_j^- = \\frac{\\bar{u}_j - L_j}{\\bar{u}_j - c_{j,\\min}}$，如果 $c_{j,\\min}  \\bar{u}_j$；否则设 $\\theta_j^- = \\infty$（或一个 $\\ge 1$ 的值）。\n\n为了同时满足所有约束，我们必须选择满足所有要求的最小 $\\theta_j$，同时还要确保 $\\theta_j \\le 1$（因为我们只想减少振荡，而不是放大它们）。因此，单元 $j$ 的最终缩放因子是：\n$$\n\\theta_j = \\min(1, \\theta_j^+, \\theta_j^-)\n$$\n如果原始系数已经位于边界 $[L_j, U_j]$ 之内，则无需限制。在这种情况下，$c_{j,\\max} \\le U_j$ 且 $c_{j,\\min} \\ge L_j$。这意味着 $\\theta_j^+ \\ge 1$ 且 $\\theta_j^- \\ge 1$，因此 $\\theta_j=1$，从而正确地得到 $c_{j,i}^{\\text{lim}} = c_{j,i}$。\n\n### 度量指标计算\n限制器的性能通过整个网格上的三个度量指标进行量化：\n1.  **限制前的最大系数过冲**：这衡量了原始系数对边界的最大违反程度。\n    $$\n    \\text{overshoot}_{\\text{before}} = \\max_{j,i} \\left\\{ \\max(c_{j,i} - U_j, 0), \\max(L_j - c_{j,i}, 0) \\right\\} = \\max_{j,i} \\left\\{ \\max(c_{j,i} - U_j, L_j - c_{j,i}, 0) \\right\\}\n    $$\n2.  **限制后的最大系数过冲**：其定义相同，但针对限制后的系数 $c_{j,i}^{\\text{lim}}$。根据构造，该值应为零（或在机器精度范围内）。\n    $$\n    \\text{overshoot}_{\\text{after}} = \\max_{j,i} \\left\\{ \\max(c_{j,i}^{\\text{lim}} - U_j, L_j - c_{j,i}^{\\text{lim}}, 0) \\right\\}\n    $$\n3.  **最大绝对平均值误差**：这验证了平均值保持性质。该值也应为零（或在机器精度范围内）。\n    $$\n    \\text{mean\\_error} = \\max_j \\left| \\bar{u}_j^{\\text{lim}} - \\bar{u}_j \\right| = \\max_j \\left| \\frac{1}{p_j+1}\\sum_{i=0}^{p_j} c_{j,i}^{\\text{lim}} - \\frac{1}{p_j+1}\\sum_{i=0}^{p_j} c_{j,i} \\right|\n    $$\n\n实现将应用此逐单元限制过程，然后为每个测试用例计算这三个全局度量指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the slope limiter problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            \"p\": 3, \"N\": 6, \"coeffs\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, -0.05, 0.05, 0.0],\n                [-0.2, 0.1, 0.1, 0.0],\n                [1.3, 1.1, 0.7, 0.9],\n                [1.0, 1.0, 1.0, 1.0],\n                [1.0, 1.05, 0.95, 1.0],\n            ], dtype=float)\n        },\n        # Test Case B\n        {\n            \"p\": 5, \"N\": 6, \"coeffs\": np.array([\n                [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, -0.1, 0.0, 0.05, -0.05, 0.1],\n                [-0.3, 0.05, 0.2, 0.1, -0.05, 0.0],\n                [1.2, 1.1, 0.6, 0.9, 1.0, 1.2],\n                [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n                [1.0, 0.95, 1.05, 1.0, 1.0, 1.0],\n            ], dtype=float)\n        },\n        # Test Case C\n        {\n            \"p\": 3, \"N\": 3, \"coeffs\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.4, 0.5, 0.6, 0.5],\n                [1.0, 1.0, 1.0, 1.0],\n            ], dtype=float)\n        },\n        # Test Case D\n        {\n            \"p\": 4, \"N\": 2, \"coeffs\": np.array([\n                [-0.1, 0.0, 0.2, -0.05, -0.05],\n                [1.1, 0.8, 1.2, 1.0, 0.9],\n            ], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"p\"]\n        N = case[\"N\"]\n        coeffs = case[\"coeffs\"]\n        p_plus_1 = p + 1\n\n        # Step 1: Compute cell means and neighbor-based bounds\n        original_means = np.sum(coeffs, axis=1) / p_plus_1\n        \n        L_bounds = np.zeros(N)\n        U_bounds = np.zeros(N)\n        for j in range(N):\n            mean_prev = original_means[j-1] if j > 0 else original_means[j]\n            mean_next = original_means[j+1] if j  N - 1 else original_means[j]\n            L_bounds[j] = min(mean_prev, mean_next)\n            U_bounds[j] = max(mean_prev, mean_next)\n\n        # Step 2: Compute pre-limiter overshoot\n        overshoot_before = 0.0\n        for j in range(N):\n            overshoots_cell = np.maximum(coeffs[j] - U_bounds[j], L_bounds[j] - coeffs[j])\n            max_overshoot_in_cell = np.max(np.maximum(overshoots_cell, 0))\n            overshoot_before = max(overshoot_before, max_overshoot_in_cell)\n\n        # Step 3: Apply cell-wise limiter\n        coeffs_lim = np.copy(coeffs)\n        for j in range(N):\n            c_j = coeffs[j]\n            mean_j = original_means[j]\n            L_j, U_j = L_bounds[j], U_bounds[j]\n\n            c_min, c_max = np.min(c_j), np.max(c_j)\n\n            # Only apply limiter if bounds are violated\n            if c_min  L_j or c_max > U_j:\n                theta_plus = float('inf')\n                if c_max > mean_j:\n                    # Avoid division by zero if c_max == mean_j\n                    if not np.isclose(c_max, mean_j):\n                        theta_plus = (U_j - mean_j) / (c_max - mean_j)\n                \n                theta_minus = float('inf')\n                if c_min  mean_j:\n                    # Avoid division by zero if c_min == mean_j\n                    if not np.isclose(c_min, mean_j):\n                         theta_minus = (mean_j - L_j) / (mean_j - c_min)\n                \n                theta = min(1.0, theta_plus, theta_minus)\n                \n                coeffs_lim[j] = mean_j + theta * (c_j - mean_j)\n\n        # Step 4: Compute post-limiter metrics\n        overshoot_after = 0.0\n        for j in range(N):\n            overshoots_cell = np.maximum(coeffs_lim[j] - U_bounds[j], L_bounds[j] - coeffs_lim[j])\n            max_overshoot_in_cell = np.max(np.maximum(overshoots_cell, 0))\n            overshoot_after = max(overshoot_after, max_overshoot_in_cell)\n\n        limited_means = np.sum(coeffs_lim, axis=1) / p_plus_1\n        mean_error = np.max(np.abs(limited_means - original_means))\n        \n        results.append(f\"[{overshoot_before:.6f}, {overshoot_after:.6f}, {mean_error:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\n# This function is not executed in the final XML but is provided for reproducibility.\n# solve()\n```"
        }
    ]
}