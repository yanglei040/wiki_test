{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, we begin with a hands-on analytical exercise. This practice demystifies the one-dimensional \"warp\" component by guiding you through its construction for a low polynomial degree from first principles . By manually deriving the Gauss-Lobatto-Legendre nodes and using Lagrange polynomials to define the warp function, you will gain a concrete intuition for how an equispaced point distribution is transformed into one with superior properties for high-order approximation.",
            "id": "3427539",
            "problem": "In high-order spectral element and Discontinuous Galerkin (DG) methods on simplices, the warp-and-blend strategy constructs high-quality nodal sets by mapping equispaced edge nodes to Jacobi–Gauss–Lobatto nodes via a one-dimensional warp that is then blended into the element interior. Consider the one-dimensional edge on the interval $\\left[-1,1\\right]$. Let $\\left\\{r_{\\mathrm{eq},j}\\right\\}_{j=0}^{N}$ be the equispaced nodes $r_{\\mathrm{eq},j}=-1+\\dfrac{2j}{N}$, and let $\\left\\{r_{\\mathrm{gll},j}\\right\\}_{j=0}^{N}$ be the Gauss–Lobatto–Legendre (GLL) nodes, defined as the union of the endpoints $\\{-1,1\\}$ with the interior points given by the roots of the derivative of the Legendre polynomial $P_{N}(x)$, where $P_{N}$ denotes the Jacobi polynomial $P_{N}^{(0,0)}$. Define the equispaced Lagrange basis $\\{\\ell_{j}^{\\mathrm{eq}}(x)\\}_{j=0}^{N}$ associated with $\\{r_{\\mathrm{eq},j}\\}_{j=0}^{N}$ and the one-dimensional warp\n$$\nW(x)\\;=\\;\\sum_{j=0}^{N}\\ell_{j}^{\\mathrm{eq}}(x)\\,\\big(r_{\\mathrm{gll},j}-r_{\\mathrm{eq},j}\\big).\n$$\n\nStarting only from the standard properties of Jacobi polynomials $P_{n}^{(\\alpha,\\beta)}(x)$ on $\\left[-1,1\\right]$ with weight $(1-x)^{\\alpha}(1+x)^{\\beta}$, including that for $(\\alpha,\\beta)=(0,0)$ one recovers the Legendre polynomials $P_{n}(x)$ and that the GLL interior nodes are the roots of $P_{N}'(x)$, do the following for polynomial degree $N=3$:\n\n- Derive the interior GLL nodes explicitly by solving $P_{3}'(x)=0$.\n- Construct the equispaced nodes $\\{r_{\\mathrm{eq},j}\\}_{j=0}^{3}$.\n- Form the equispaced Lagrange polynomials $\\ell_{j}^{\\mathrm{eq}}(x)$ and evaluate $W(x)$ at $x=\\dfrac{1}{2}$.\n\nExpress your final answer for $W\\!\\left(\\dfrac{1}{2}\\right)$ in exact closed form. No rounding is required. Do not include units.",
            "solution": "The problem is well-posed and scientifically sound, set within the standard framework of numerical methods for partial differential equations. All definitions and conditions are standard and self-consistent. We proceed with the solution for the polynomial degree $N=3$.\n\nThe primary tasks are to derive the necessary components for the warp function $W(x)$ for $N=3$, and then evaluate it at $x=\\frac{1}{2}$. The warp function is defined as:\n$$\nW(x) = \\sum_{j=0}^{N} \\ell_{j}^{\\mathrm{eq}}(x) (r_{\\mathrm{gll},j} - r_{\\mathrm{eq},j})\n$$\nwhere $\\{r_{\\mathrm{eq},j}\\}$ are equispaced nodes, $\\{r_{\\mathrm{gll},j}\\}$ are Gauss–Lobatto–Legendre (GLL) nodes, and $\\{\\ell_{j}^{\\mathrm{eq}}(x)\\}$ are the Lagrange basis polynomials associated with the equispaced nodes.\n\n**Step 1: Determine the Legendre Polynomial $P_3(x)$ and its Derivative**\n\nThe Legendre polynomials $P_n(x)$ are a special case of Jacobi polynomials $P_n^{(\\alpha,\\beta)}(x)$ with $\\alpha=0$ and $\\beta=0$. The first few Legendre polynomials, satisfying the standard normalization $P_n(1)=1$, are:\n$P_0(x) = 1$\n$P_1(x) = x$\n$P_2(x) = \\frac{1}{2}(3x^2 - 1)$\nWe can find $P_3(x)$ using the Bonnet recurrence relation: $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$. For $n=2$:\n$$\n(2+1)P_3(x) = (2(2)+1)xP_2(x) - 2P_1(x)\n$$\n$$\n3P_3(x) = 5x \\left( \\frac{1}{2}(3x^2 - 1) \\right) - 2x = \\frac{15}{2}x^3 - \\frac{5}{2}x - 2x = \\frac{15}{2}x^3 - \\frac{9}{2}x\n$$\n$$\nP_3(x) = \\frac{1}{3} \\left( \\frac{15}{2}x^3 - \\frac{9}{2}x \\right) = \\frac{1}{2}(5x^3 - 3x)\n$$\nThe derivative of $P_3(x)$ is:\n$$\nP_3'(x) = \\frac{d}{dx} \\left( \\frac{1}{2}(5x^3 - 3x) \\right) = \\frac{1}{2}(15x^2 - 3)\n$$\n\n**Step 2: Derive the Gauss–Lobatto–Legendre (GLL) Nodes**\n\nFor $N=3$, the GLL nodes $\\{r_{\\mathrm{gll},j}\\}_{j=0}^3$ consist of the endpoints of the interval $[-1, 1]$ and the roots of $P_3'(x)=0$. We solve for the interior nodes:\n$$\nP_3'(x) = 0 \\implies \\frac{1}{2}(15x^2 - 3) = 0 \\implies 15x^2 = 3 \\implies x^2 = \\frac{3}{15} = \\frac{1}{5}\n$$\nThe roots are $x = \\pm\\frac{1}{\\sqrt{5}}$.\nThe full set of GLL nodes, sorted in ascending order, is:\n$r_{\\mathrm{gll},0} = -1$\n$r_{\\mathrm{gll},1} = -\\frac{1}{\\sqrt{5}}$\n$r_{\\mathrm{gll},2} = \\frac{1}{\\sqrt{5}}$\n$r_{\\mathrm{gll},3} = 1$\n\n**Step 3: Construct the Equispaced Nodes**\n\nFor $N=3$, the equispaced nodes are given by $r_{\\mathrm{eq},j} = -1 + \\frac{2j}{3}$ for $j \\in \\{0, 1, 2, 3\\}$:\n$r_{\\mathrm{eq},0} = -1 + \\frac{2(0)}{3} = -1$\n$r_{\\mathrm{eq},1} = -1 + \\frac{2(1)}{3} = -\\frac{1}{3}$\n$r_{\\mathrm{eq},2} = -1 + \\frac{2(2)}{3} = \\frac{1}{3}$\n$r_{\\mathrm{eq},3} = -1 + \\frac{2(3)}{3} = 1$\nThe set of equispaced nodes is $\\{-1, -\\frac{1}{3}, \\frac{1}{3}, 1\\}$.\n\n**Step 4: Calculate the Nodal Differences**\n\nWe compute the differences $\\Delta r_j = r_{\\mathrm{gll},j} - r_{\\mathrm{eq},j}$:\n$\\Delta r_0 = r_{\\mathrm{gll},0} - r_{\\mathrm{eq},0} = -1 - (-1) = 0$\n$\\Delta r_1 = r_{\\mathrm{gll},1} - r_{\\mathrm{eq},1} = -\\frac{1}{\\sqrt{5}} - (-\\frac{1}{3}) = \\frac{1}{3} - \\frac{1}{\\sqrt{5}}$\n$\\Delta r_2 = r_{\\mathrm{gll},2} - r_{\\mathrm{eq},2} = \\frac{1}{\\sqrt{5}} - \\frac{1}{3}$\n$\\Delta r_3 = r_{\\mathrm{gll},3} - r_{\\mathrm{eq},3} = 1 - 1 = 0$\n\n**Step 5: Evaluate the Equispaced Lagrange Basis Polynomials at $x=\\frac{1}{2}$**\n\nThe Lagrange basis polynomial $\\ell_{j}^{\\mathrm{eq}}(x)$ is defined as $\\ell_{j}^{\\mathrm{eq}}(x) = \\prod_{k=0, k\\neq j}^{3} \\frac{x-r_{\\mathrm{eq},k}}{r_{\\mathrm{eq},j}-r_{\\mathrm{eq},k}}$. We need to evaluate these at $x=\\frac{1}{2}$.\nThe equispaced nodes are $\\{r_0, r_1, r_2, r_3\\} = \\{-1, -\\frac{1}{3}, \\frac{1}{3}, 1\\}$.\n\nFor $j=0$: $\\ell_{0}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-\\frac{1}{3})(\\frac{1}{2}-1)}{(-1-(-\\frac{1}{3}))(-1-\\frac{1}{3})(-1-1)} = \\frac{(\\frac{5}{6})(\\frac{1}{6})(-\\frac{1}{2})}{(-\\frac{2}{3})(-\\frac{4}{3})(-2)} = \\frac{-5/72}{-16/9} = \\frac{5}{128}$.\n\nFor $j=1$: $\\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-\\frac{1}{3})(\\frac{1}{2}-1)}{(-\\frac{1}{3}-(-1))(-\\frac{1}{3}-\\frac{1}{3})(-\\frac{1}{3}-1)} = \\frac{(\\frac{3}{2})(\\frac{1}{6})(-\\frac{1}{2})}{(\\frac{2}{3})(-\\frac{2}{3})(-\\frac{4}{3})} = \\frac{-1/8}{16/27} = -\\frac{27}{128}$.\n\nFor $j=2$: $\\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-1)}{(\\frac{1}{3}-(-1))(\\frac{1}{3}-(-\\frac{1}{3}))(\\frac{1}{3}-1)} = \\frac{(\\frac{3}{2})(\\frac{5}{6})(-\\frac{1}{2})}{(\\frac{4}{3})(\\frac{2}{3})(-\\frac{2}{3})} = \\frac{-5/8}{-16/27} = \\frac{135}{128}$.\n\nFor $j=3$: $\\ell_{3}^{\\mathrm{eq}}(\\frac{1}{2}) = \\frac{(\\frac{1}{2}-(-1))(\\frac{1}{2}-(-\\frac{1}{3}))(\\frac{1}{2}-\\frac{1}{3})}{(1-(-1))(1-(-\\frac{1}{3}))(1-\\frac{1}{3})} = \\frac{(\\frac{3}{2})(\\frac{5}{6})(\\frac{1}{6})}{(2)(\\frac{4}{3})(\\frac{2}{3})} = \\frac{5/24}{16/9} = \\frac{15}{128}$.\n\n**Step 6: Compute $W(\\frac{1}{2})$**\n\nWe now substitute the evaluated components into the definition of $W(x)$ at $x=\\frac{1}{2}$:\n$$\nW(\\frac{1}{2}) = \\sum_{j=0}^{3} \\ell_{j}^{\\mathrm{eq}}(\\frac{1}{2}) \\Delta r_j = \\ell_{0}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_0 + \\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_1 + \\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_2 + \\ell_{3}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_3\n$$\nSince $\\Delta r_0 = 0$ and $\\Delta r_3 = 0$, the expression simplifies to:\n$$\nW(\\frac{1}{2}) = \\ell_{1}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_1 + \\ell_{2}^{\\mathrm{eq}}(\\frac{1}{2})\\Delta r_2\n$$\nSubstituting the calculated values:\n$$\nW(\\frac{1}{2}) = \\left(-\\frac{27}{128}\\right)\\left(\\frac{1}{3} - \\frac{1}{\\sqrt{5}}\\right) + \\left(\\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\nWe can factor out $(\\frac{1}{\\sqrt{5}} - \\frac{1}{3})$ as a common term by rewriting the first term:\n$$\nW(\\frac{1}{2}) = \\left(\\frac{27}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) + \\left(\\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\n$$\nW(\\frac{1}{2}) = \\left(\\frac{27}{128} + \\frac{135}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) = \\left(\\frac{162}{128}\\right)\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right)\n$$\nSimplifying the fraction $\\frac{162}{128} = \\frac{81}{64}$:\n$$\nW(\\frac{1}{2}) = \\frac{81}{64}\\left(\\frac{1}{\\sqrt{5}} - \\frac{1}{3}\\right) = \\frac{81}{64\\sqrt{5}} - \\frac{81}{64 \\cdot 3} = \\frac{81\\sqrt{5}}{64 \\cdot 5} - \\frac{27}{64} = \\frac{81\\sqrt{5}}{320} - \\frac{27}{64}\n$$\nTo combine these terms, we use a common denominator of $320$:\n$$\nW(\\frac{1}{2}) = \\frac{81\\sqrt{5}}{320} - \\frac{27 \\cdot 5}{64 \\cdot 5} = \\frac{81\\sqrt{5}}{320} - \\frac{135}{320} = \\frac{81\\sqrt{5} - 135}{320}\n$$\nFactoring out the greatest common divisor of $81$ and $135$, which is $27$:\n$$\nW(\\frac{1}{2}) = \\frac{27(3\\sqrt{5} - 5)}{320}\n$$\nThis is the final exact closed-form answer.",
            "answer": "$$\n\\boxed{\\frac{27(3\\sqrt{5} - 5)}{320}}\n$$"
        },
        {
            "introduction": "Moving from a specific analytical case to a general computational tool is a critical skill in scientific computing. This practice challenges you to implement a robust algorithm for constructing the one-dimensional warp function for an arbitrary polynomial degree $N$ . You will translate the core mathematical concepts—including polynomial recurrence relations and root-finding via Newton's method—into a functional program, with an emphasis on creating a numerically stable evaluation using barycentric interpolation.",
            "id": "3427542",
            "problem": "Implement a program that constructs the one-dimensional warp function used in the warp-and-blend strategy for node distributions on simplices in spectral and discontinuous Galerkin methods. The one-dimensional warp is defined as follows: for a fixed interpolation degree $N \\in \\mathbb{N}$, consider the equidistant nodes on the interval $[-1,1]$ given by $r^{\\mathrm{eq}}_j = -1 + \\dfrac{2j}{N}$ for $j=0,1,\\dots,N$, and the Gauss–Lobatto–Legendre nodes $r^{\\mathrm{gl}}_j$ defined as the union of the endpoints $\\{-1,1\\}$ and the $N-1$ interior roots of $(1-x^2)P'_N(x)$, where $P_N(x)$ denotes the Legendre polynomial of degree $N$. Define the nodal displacements $\\Delta_j = r^{\\mathrm{gl}}_j - r^{\\mathrm{eq}}_j$ for $j=0,1,\\dots,N$. The one-dimensional warp function $W_N(r)$ is the unique polynomial of degree at most $N$ such that $W_N(r^{\\mathrm{eq}}_j) = \\Delta_j$ for all $j=0,1,\\dots,N$. This $W_N(r)$ will later be used as the edge-warp component in higher-dimensional warp-and-blend constructions.\n\nYour program must construct $W_N(r)$ from first principles, using only the following foundational definitions and facts:\n- Legendre polynomials $\\{P_n(x)\\}_{n=0}^\\infty$ are defined by the three-term recurrence $P_0(x)=1$, $P_1(x)=x$, and $P_n(x) = \\dfrac{(2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)}{n}$ for $n \\ge 2$.\n- The Gauss–Lobatto–Legendre nodes for degree $N$ consist of $x=-1$, $x=1$, and the $N-1$ interior roots of $(1-x^2)P'_N(x)$ in $(-1,1)$.\n- The unique interpolating polynomial of degree at most $N$ through nodes $\\{x_j\\}_{j=0}^N$ with data $\\{y_j\\}_{j=0}^N$ is characterized by the Lagrange basis $\\{\\ell_j(x)\\}_{j=0}^N$ satisfying $\\ell_j(x_k)=\\delta_{jk}$. You must implement an algorithmically stable evaluation of this interpolant at arbitrary $x \\in [-1,1]$.\n\nStarting from these bases, derive and implement:\n1. A robust routine that computes the $N+1$ Gauss–Lobatto–Legendre nodes by solving for the interior roots of $(1-x^2)P'_N(x)$ using Newton’s method applied to a smooth equivalent system that avoids numerical issues at $x=\\pm 1$.\n2. The equidistant nodes on $[-1,1]$ and the displacements $\\Delta_j$.\n3. An evaluation routine for $W_N(r)$ based on the Lagrange interpolant built on the equidistant nodes with data $\\Delta_j$. Your evaluation must correctly handle the case $r=r^{\\mathrm{eq}}_j$ for some $j$.\n\nAngle units are not relevant. There are no physical units in this problem.\n\nTest Suite:\nYou must evaluate the following five test cases, each returning a single real number:\n- Test $1$: $N=1$, evaluate $|W_N(0)|$.\n- Test $2$: $N=5$, verify the interpolation property at the equidistant nodes by computing $\\max_{0\\le j \\le N} \\left| W_N\\!\\left(r^{\\mathrm{eq}}_j\\right) - \\Delta_j \\right|$.\n- Test $3$: $N=8$, compute the odd-symmetry residual $\\max_{x \\in \\{-0.9,-0.31,0.17,0.53,0.9\\}} \\left| W_N(x) + W_N(-x) \\right|$.\n- Test $4$: $N=10$, endpoint check $\\max\\left( |W_N(-1)|,\\ |W_N(1)| \\right)$.\n- Test $5$: $N=7$, central value $|W_N(0)|$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five tests above. For example, it must print a line of the form $[r_1,r_2,r_3,r_4,r_5]$, where each $r_k$ is a floating-point number computed by your program for the corresponding test.",
            "solution": "The user wants to construct the one-dimensional warp function $W_N(r)$ used in spectral and discontinuous Galerkin methods and evaluate it for several test cases. The solution requires implementing the necessary components from first principles as defined in the problem statement. This involves three main steps:\n1.  Computing the Gauss-Lobatto-Legendre (GLL) nodes.\n2.  Defining the nodal displacements.\n3.  Constructing and evaluating the warp function using stable polynomial interpolation.\n\n### Step 1: Legendre Polynomials and their Derivatives\n\nThe foundation of this problem is the Legendre polynomial, $P_N(x)$. We require not only the polynomial itself but also its first and second derivatives to find the GLL nodes using Newton's method. The polynomials are defined by the three-term recurrence relation:\n$P_0(x) = 1$\n$P_1(x) = x$\n$$P_n(x) = \\frac{(2n-1)xP_{n-1}(x) - (n-1)P_{n-2}(x)}{n}, \\quad \\text{for } n \\ge 2$$\n\nBy differentiating this recurrence relation with respect to $x$, we can obtain recurrence relations for the derivatives $P'_n(x)$ and $P''_n(x)$:\n$$n P'_n(x) = (2n-1)P_{n-1}(x) + (2n-1)xP'_{n-1}(x) - (n-1)P'_{n-2}(x)$$\n$$n P''_n(x) = 2(2n-1)P'_{n-1}(x) + (2n-1)xP''_{n-1}(x) - (n-1)P''_{n-2}(x)$$\n\nA single routine can compute $(P_N(x), P'_N(x), P''_N(x))$ by starting with the base cases for $n=0$ and $n=1$ and iteratively applying these formulas up to the desired degree $N$. For the small degrees required by the test suite ($N \\leq 10$), this method is numerically stable and efficient.\n\n### Step 2: Gauss–Lobatto–Legendre (GLL) Nodes\n\nThe GLL nodes, $r^{\\mathrm{gl}}_j$, for a degree $N$ polynomial approximation are the $N+1$ roots of the polynomial $(1-x^2)P'_N(x)$. These consist of the fixed endpoints $x=\\pm 1$ and the $N-1$ interior roots of $P'_N(x)$, which lie strictly in the interval $(-1, 1)$.\n\nTo find these interior roots, we apply Newton's method to the function $f(x) = P'_N(x)$. The iterative update rule is:\n$$x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} = x_k - \\frac{P'_N(x_k)}{P''_N(x_k)}$$\nThis requires the values of $P'_N(x)$ and $P''_N(x)$, which are provided by the function from Step 1.\n\nFor Newton's method to converge to the correct roots, good initial guesses are essential. The $N-1$ interior roots of $P'_N(x)$ are the extrema of $P_N(x)$. Well-known approximations for these locations can be used. A reliable choice for the initial guess for the $j$-th interior root (in descending order) is $x_j^{(0)} = \\cos\\left(\\frac{j\\pi}{N}\\right)$ for $j=1, 2, \\dots, N-1$.\n\nThe complete set of $N+1$ GLL nodes is then formed by combining these $N-1$ computed roots with the endpoints $-1$ and $1$, and sorting them in ascending order. Let's denote the sorted nodes by $\\{r^{\\mathrm{gl}}_j\\}_{j=0}^N$.\n\n### Step 3: Warp Function Construction and Evaluation\n\nThe warp function $W_N(r)$ is a polynomial of degree at most $N$ that maps the equidistant nodes to the GLL nodes. It is defined by the interpolation condition:\n$$W_N(r^{\\mathrm{eq}}_j) = \\Delta_j, \\quad j=0, 1, \\dots, N$$\nwhere the nodes and displacements are:\n-   **Equidistant nodes**: $r^{\\mathrm{eq}}_j = -1 + \\frac{2j}{N}$\n-   **Nodal displacements**: $\\Delta_j = r^{\\mathrm{gl}}_j - r^{\\mathrm{eq}}_j$\n\nTo evaluate this interpolating polynomial in a numerically stable manner, we use the barycentric Lagrange interpolation formula (second form):\n$$W_N(r) = \\frac{\\displaystyle\\sum_{j=0}^{N} \\frac{w_j}{r - r^{\\mathrm{eq}}_j} \\Delta_j}{\\displaystyle\\sum_{j=0}^{N} \\frac{w_j}{r - r^{\\mathrm{eq}}_j}}$$\nThis formula is particularly stable for any choice of nodes, avoiding the potential for catastrophic cancellation that can occur with a monomial basis representation.\n\nFor equidistant nodes, the barycentric weights $w_j$ can be chosen as:\n$$w_j = (-1)^j \\binom{N}{j}$$\nThese weights can be computed efficiently via the recurrence $w_0 = 1$ and $w_{j+1} = -w_j \\frac{N-j}{j+1}$ for $j=0, \\dots, N-1$.\n\nA crucial part of the implementation is handling the case where the evaluation point $r$ coincides with one of the interpolation nodes $r^{\\mathrm{eq}}_k$. In this scenario, the formula becomes an indeterminate form $0/0$. By definition of interpolation, if $r = r^{\\mathrm{eq}}_k$, the function value is simply $W_N(r^{\\mathrm{eq}}_k) = \\Delta_k$. The evaluation routine must check for this condition to avoid division by zero and return the correct value.\n\n### Analysis of Test Cases\n\nA theoretical analysis of the function's properties reveals the expected outcomes for the test cases:\n-   **Symmetry**: The GLL nodes and equidistant nodes are both symmetric with respect to the origin ($r_{N-j} = -r_j$). This implies the displacements are anti-symmetric: $\\Delta_{N-j} = -\\Delta_j$. A polynomial interpolating anti-symmetric data on symmetric points must be an odd function, i.e., $W_N(r) = -W_N(-r)$ for all $r$.\n-   **Test 1 ($N=1, |W_1(0)|$)**: For $N=1$, $r^{\\mathrm{gl}} = r^{\\mathrm{eq}} = \\{-1, 1\\}$, so $\\Delta = \\{0, 0\\}$. The interpolating polynomial is $W_1(r) \\equiv 0$, so $|W_1(0)| = 0$. In fact, for $N \\le 2$, GLL nodes are equidistant, so $W_N(r) \\equiv 0$.\n-   **Test 2 ($N=5, \\max|W_5(r^{\\mathrm{eq}}_j) - \\Delta_j|$)**: This tests the fundamental interpolation property. By construction, $W_5(r^{\\mathrm{eq}}_j) = \\Delta_j$. The result should be zero, up to machine precision.\n-   **Test 3 ($N=8, \\max|W_8(x) + W_8(-x)|$)**: This tests the odd symmetry property. Since $W_8(r)$ is an odd function, $W_8(x) + W_8(-x) = 0$. The result should be zero, up to machine precision.\n-   **Test 4 ($N=10, \\max(|W_{10}(-1)|, |W_{10}(1)|)$)**: This tests the boundary values. The endpoints $r^{\\mathrm{eq}}_0=-1$ and $r^{\\mathrm{eq}}_{10}=1$ are interpolation nodes. $W_{10}(-1) = \\Delta_0 = r^{\\mathrm{gl}}_0 - r^{\\mathrm{eq}}_0 = -1 - (-1) = 0$. Similarly, $W_{10}(1) = \\Delta_{10} = 1 - 1 = 0$. The result must be zero.\n-   **Test 5 ($N=7, |W_7(0)|$)**: Since $W_7(r)$ is an odd function, $W_7(0) = -W_7(-0) \\implies 2W_7(0)=0 \\implies W_7(0)=0$. The result is zero.\n\nAll test cases are designed to yield a result of zero, providing a stringent validation of the numerical implementation's correctness and stability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of constructing and evaluating the 1D warp function.\n    \"\"\"\n\n    class WarpAndBlend1D:\n        \"\"\"\n        Constructs and evaluates the 1D warp function W_N(r).\n        \"\"\"\n        def __init__(self, N: int):\n            if not isinstance(N, int) or N < 1:\n                raise ValueError(\"Degree N must be a positive integer.\")\n            \n            self.N = N\n            self.r_eq = np.linspace(-1.0, 1.0, N + 1)\n            \n            if N > 0:\n                self.r_gl = self._compute_gll_nodes(N)\n            else: # N=0 case, though problem implies N>=1\n                self.r_gl = np.array([-1.0])\n\n            # Ensure GLL nodes are correctly sorted for displacement calculation\n            self.r_gl.sort()\n\n            self.delta = self.r_gl - self.r_eq\n            self.weights = self._compute_barycentric_weights(N)\n\n        def _legendre_and_derivs(self, N: int, x: float):\n            \"\"\"Computes P_N(x), P'_N(x), and P''_N(x) via recurrence.\"\"\"\n            if N == 0:\n                return 1.0, 0.0, 0.0\n            \n            p_nm2, p_prime_nm2, p_double_prime_nm2 = 1.0, 0.0, 0.0\n            p_nm1, p_prime_nm1, p_double_prime_nm1 = x, 1.0, 0.0\n            \n            if N == 1:\n                return p_nm1, p_prime_nm1, p_double_prime_nm1\n\n            for n in range(2, N + 1):\n                # Recurrence for P_n(x)\n                p_n = ((2 * n - 1) * x * p_nm1 - (n - 1) * p_nm2) / n\n                \n                # Recurrence for P'_n(x)\n                p_prime_n = ((2 * n - 1) * (p_nm1 + x * p_prime_nm1) - (n - 1) * p_prime_nm2) / n\n                \n                # Recurrence for P''_n(x)\n                p_double_prime_n = ((2 * n - 1) * (2 * p_prime_nm1 + x * p_double_prime_nm1) - (n - 1) * p_double_prime_nm2) / n\n                \n                p_nm2, p_prime_nm2, p_double_prime_nm2 = p_nm1, p_prime_nm1, p_double_prime_nm1\n                p_nm1, p_prime_nm1, p_double_prime_nm1 = p_n, p_prime_n, p_double_prime_n\n            \n            return p_nm1, p_prime_nm1, p_double_prime_nm1\n\n        def _compute_gll_nodes(self, N: int):\n            \"\"\"Computes the N+1 Gauss-Lobatto-Legendre nodes for degree N.\"\"\"\n            if N == 1:\n                return np.array([-1.0, 1.0])\n\n            nodes = np.zeros(N + 1)\n            nodes[0], nodes[N] = -1.0, 1.0\n            \n            # Find N-1 interior roots of P'_N(x) using Newton's method\n            for j in range(1, N):\n                # Initial guess for the j-th root\n                x = np.cos(j * np.pi / N)\n                \n                # Newton's method iteration\n                for _ in range(20): # 20 iterations is more than enough\n                    _, p_prime, p_double_prime = self._legendre_and_derivs(N, x)\n                    if abs(p_prime) < 1e-15:\n                        break\n                    dx = p_prime / p_double_prime\n                    x -= dx\n                    if abs(dx) < 1e-15:\n                        break\n                nodes[j] = x\n            \n            return nodes\n\n        def _compute_barycentric_weights(self, N: int):\n            \"\"\"Computes barycentric weights for equidistant nodes.\"\"\"\n            weights = np.zeros(N + 1)\n            weights[0] = 1.0\n            for j in range(N):\n                weights[j + 1] = -weights[j] * (N - j) / (j + 1)\n            return weights\n\n        def evaluate(self, r_eval):\n            \"\"\"Evaluates the warp function W_N(r) at given points r.\"\"\"\n            r_eval = np.atleast_1d(r_eval)\n            results = np.zeros_like(r_eval, dtype=float)\n            \n            for i, r in enumerate(r_eval):\n                # Check if evaluation point is close to an interpolation node\n                is_node = np.isclose(r, self.r_eq)\n                if np.any(is_node):\n                    idx = np.where(is_node)[0][0]\n                    results[i] = self.delta[idx]\n                else:\n                    # Use barycentric interpolation formula\n                    terms = self.weights / (r - self.r_eq)\n                    numerator = np.sum(terms * self.delta)\n                    denominator = np.sum(terms)\n                    if denominator == 0:\n                        results[i] = 0.0 # Should not happen if check above is robust\n                    else:\n                        results[i] = numerator / denominator\n            \n            return results\n\n    # Define the test cases from the problem statement.\n    test_specs = [\n        {'N': 1, 'type': 'eval', 'points': [0.0], 'op': 'abs'},\n        {'N': 5, 'type': 'interp_check'},\n        {'N': 8, 'type': 'symmetry_check', 'points': [-0.9, -0.31, 0.17, 0.53, 0.9]},\n        {'N': 10, 'type': 'endpoint_check'},\n        {'N': 7, 'type': 'eval', 'points': [0.0], 'op': 'abs'}\n    ]\n\n    results = []\n    # Using a cache for constructed objects to avoid re-computation\n    warp_objects = {}\n\n    for spec in test_specs:\n        N = spec['N']\n        if N not in warp_objects:\n            warp_objects[N] = WarpAndBlend1D(N)\n        \n        w = warp_objects[N]\n        \n        if spec['type'] == 'eval':\n            val = w.evaluate(spec['points'])[0]\n            if spec['op'] == 'abs':\n                results.append(np.abs(val))\n        \n        elif spec['type'] == 'interp_check':\n            vals_at_nodes = w.evaluate(w.r_eq)\n            error = np.max(np.abs(vals_at_nodes - w.delta))\n            results.append(error)\n\n        elif spec['type'] == 'symmetry_check':\n            x = np.array(spec['points'])\n            residual = np.max(np.abs(w.evaluate(x) + w.evaluate(-x)))\n            results.append(residual)\n\n        elif spec['type'] == 'endpoint_check':\n            val = np.max(np.abs(w.evaluate(np.array([-1.0, 1.0]))))\n            results.append(val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes the preceding concepts into a complete two-dimensional application, demonstrating the ultimate purpose of warp-and-blend nodes. You will construct the full nodal distribution on a reference triangle and then use this custom grid to build the essential machinery of a spectral or discontinuous Galerkin method: high-order interpolation and differentiation operators . This exercise provides a direct look at how carefully designed node layouts enable the creation of powerful and accurate tools for solving complex partial differential equations.",
            "id": "3427543",
            "problem": "Construct a complete, runnable program that, for the reference two-dimensional simplex (triangle), implements a warp-and-blend nodal distribution, and then uses these nodes to build both interpolation and differentiation operators suitable for high-order Spectral and Discontinuous Galerkin methods. The program must rely only on fundamental definitions and well-tested facts and must not assume any prederived closed forms for the target operators.\n\nUse the following base definitions and requirements.\n\n1. Reference geometry, barycentric coordinates, and edges.\n   - Consider the equilateral reference triangle with vertices\n     $$\\mathbf{V}_1 = (-1, -1/\\sqrt{3}), \\quad \\mathbf{V}_2 = (1, -1/\\sqrt{3}), \\quad \\mathbf{V}_3 = (0, 2/\\sqrt{3}).$$\n   - For any point inside the triangle, let the barycentric coordinates be $$\\lambda_1, \\lambda_2, \\lambda_3 \\ge 0, \\quad \\lambda_1 + \\lambda_2 + \\lambda_3 = 1,$$ and the affine mapping\n     $$\\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) = \\lambda_1 \\mathbf{V}_1 + \\lambda_2 \\mathbf{V}_2 + \\lambda_3 \\mathbf{V}_3.$$\n   - The edges opposite to vertices are denoted by\n     $$\\text{edge } 1: \\overline{\\mathbf{V}_2 \\mathbf{V}_3}, \\quad \\text{edge } 2: \\overline{\\mathbf{V}_1 \\mathbf{V}_3}, \\quad \\text{edge } 3: \\overline{\\mathbf{V}_1 \\mathbf{V}_2}.$$\n\n2. One-dimensional Gauss–Lobatto–Legendre nodes and warping on an edge parameter.\n   - For a polynomial degree $$N \\in \\mathbb{N}_0,$$ define the one-dimensional equispaced parameterization on an edge by the parameter $$t \\in [0,1]$$ with equidistant nodes $$t_k = \\frac{k}{N}$$ for $$k=0,\\dots,N$$ (for $$N=0,$$ interpret the unique node as the edge midpoint).\n   - Let $$x^{\\mathrm{GL}}_k \\in [-1,1]$$ for $$k=0,\\dots,N$$ denote the Gauss–Lobatto–Legendre nodes, i.e., the set contains the endpoints $$-1, 1$$ and the interior nodes are the roots of the derivative of the Legendre polynomial of degree $$N$$. Define the corresponding edge parameters $$t^{\\mathrm{GL}}_k = \\frac{x^{\\mathrm{GL}}_k + 1}{2} \\in [0,1].$$\n   - Define the one-dimensional warping function $$D_N(t)$$ to be the unique polynomial of degree at most $$N$$ satisfying the interpolation conditions\n     $$D_N(t_k) = t^{\\mathrm{GL}}_k - t_k, \\quad k=0,\\dots,N.$$\n     This function encodes the displacement of the equidistant parameter along an edge required to achieve the Gauss–Lobatto–Legendre spacing.\n\n3. Warp-and-blend nodes on the triangle.\n   - Start from the equidistant barycentric lattice nodes\n     $$\\mathcal{L}_N = \\left\\{ (\\lambda_1,\\lambda_2,\\lambda_3) \\,\\middle|\\, \\lambda_i = \\frac{\\ell_i}{N}, \\ \\ell_i \\in \\mathbb{N}_0, \\ \\ell_1+\\ell_2+\\ell_3=N \\right\\}$$\n     for $$N \\ge 1,$$ and for $$N=0$$ use the single node at the centroid $$\\lambda_1=\\lambda_2=\\lambda_3=\\frac{1}{3}.$$\n   - For each node with barycentric coordinates $$\\lambda_1,\\lambda_2,\\lambda_3,$$ define for each edge a local edge parameter by projecting onto that edge:\n     $$t_1 = \\frac{\\lambda_3}{\\lambda_2+\\lambda_3} \\ \\text{on edge } 1 \\ (\\text{if } \\lambda_2+\\lambda_3>0), \\quad\n       t_2 = \\frac{\\lambda_1}{\\lambda_1+\\lambda_3} \\ \\text{on edge } 2 \\ (\\text{if } \\lambda_1+\\lambda_3>0), \\quad\n       t_3 = \\frac{\\lambda_2}{\\lambda_1+\\lambda_2} \\ \\text{on edge } 3 \\ (\\text{if } \\lambda_1+\\lambda_2>0),$$\n     and interpret $$t_i=0$$ when the corresponding denominator is zero.\n   - Define the quadratic blending factor for each edge $$i \\in \\{1,2,3\\}$$ by\n     $$B_i(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - \\lambda_i)^2.$$\n     This factor equals $$1$$ on edge $$i,$$ tends to $$0$$ when approaching the opposite vertex, and decays smoothly inside the triangle.\n   - Let the edge tangent vectors be\n     $$\\mathbf{e}_1 = \\mathbf{V}_3 - \\mathbf{V}_2, \\quad \\mathbf{e}_2 = \\mathbf{V}_3 - \\mathbf{V}_1, \\quad \\mathbf{e}_3 = \\mathbf{V}_2 - \\mathbf{V}_1.$$\n     The warped-and-blended physical coordinates are then obtained by\n     $$\\mathbf{x}_{\\mathrm{WB}} = \\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) \\;+\\; \\mathbf{e}_1 \\, B_1 \\, D_N(t_1) \\;+\\; \\mathbf{e}_2 \\, B_2 \\, D_N(t_2) \\;+\\; \\mathbf{e}_3 \\, B_3 \\, D_N(t_3).$$\n     This construction produces on each edge $$i$$ the Gauss–Lobatto–Legendre spacing because $$B_i=1$$ on edge $$i$$ and $$D_N(t)$$ realizes the required one-dimensional reparameterization, while contributions from other edges vanish at the endpoints due to $$D_N(0)=D_N(1)=0.$$\n\n4. Polynomial bases, interpolation and differentiation operators.\n   - Let $$\\mathcal{P}_N(\\mathbb{R}^2)$$ denote the space of polynomials in $$x,y$$ with total degree at most $$N.$$\n   - Use the graded set of monomials $$\\{ x^i y^j : i \\ge 0, j \\ge 0, i+j \\le N \\}$$ as a basis. If there are $$M = \\frac{(N+1)(N+2)}{2}$$ nodes $$\\{\\mathbf{x}_m\\}_{m=1}^M,$$ construct the square Vandermonde matrix $$\\mathbf{V} \\in \\mathbb{R}^{M \\times M}$$ with entries\n     $$V_{m,p} = x_m^{i_p} \\, y_m^{j_p},$$\n     where $$p$$ indexes the monomial exponents $$\\{(i_p,j_p)\\}.$$\n   - The nodal Lagrange basis evaluated at any set of target points $$\\{\\hat{\\mathbf{x}}_q\\}_{q=1}^{Q}$$ is captured by the interpolation matrix\n     $$\\mathbf{I} = \\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\}) \\, \\mathbf{V}^{-1},$$\n     where $$\\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\})$$ is the Vandermonde built at the target points.\n   - The differentiation matrices $$\\mathbf{D}_x, \\mathbf{D}_y \\in \\mathbb{R}^{M \\times M}$$ that map nodal values of a scalar field $$f$$ to nodal values of its partial derivatives are obtained by differentiating the monomial basis and projecting back to the nodal basis:\n     $$\\mathbf{D}_x = \\mathbf{V}_x \\, \\mathbf{V}^{-1}, \\quad \\mathbf{D}_y = \\mathbf{V}_y \\, \\mathbf{V}^{-1},$$\n     with entries\n     $$\\left(\\mathbf{V}_x\\right)_{m,p} = \\frac{\\partial}{\\partial x}\\left(x^{i_p} y^{j_p}\\right)\\Big|_{\\mathbf{x}_m} = i_p \\, x_m^{i_p-1} y_m^{j_p}, \\quad\n       \\left(\\mathbf{V}_y\\right)_{m,p} = \\frac{\\partial}{\\partial y}\\left(x^{i_p} y^{j_p}\\right)\\Big|_{\\mathbf{x}_m} = j_p \\, x_m^{i_p} y_m^{j_p-1},$$\n     interpreting $$x^{-1}=0$$ and $$y^{-1}=0$$ whenever the corresponding exponent is zero.\n\n5. Test suite, target points, and metrics.\n   - Use the following polynomial degrees and test functions:\n     - Case $$A$$: $$N=0,$$ scalar field $$f(\\mathbf{x}) = 3.$$ Exact gradient is identically zero.\n     - Case $$B$$: $$N=1,$$ scalar field $$f(\\mathbf{x}) = 1 + x - 2y.$$ Exact gradient is $$\\nabla f = (1, -2).$$\n     - Case $$C$$: $$N=3,$$ scalar field $$f(\\mathbf{x}) = e^{x} \\sin(y).$$ Exact gradient is $$\\nabla f = \\left(e^{x} \\sin(y), \\ e^{x} \\cos(y)\\right).$$\n   - Use the following three fixed target barycentric points for interpolation testing:\n     $$\\text{T}_1: (\\lambda_1,\\lambda_2,\\lambda_3) = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}\\right), \\quad\n       \\text{T}_2: (0.2, 0.3, 0.5), \\quad\n       \\text{T}_3: (0.8, 0.1, 0.1).$$\n     Map each to physical coordinates using the affine mapping from item $$1.$$\n   - For each case, compute:\n     - The interpolation root-mean-square error over the three targets,\n       $$E_{\\mathrm{int}} = \\sqrt{\\frac{1}{3} \\sum_{q=1}^3 \\left( \\hat{f}_q - f(\\hat{\\mathbf{x}}_q) \\right)^2 },$$\n       where $$\\hat{f}_q$$ is the interpolated value using $$\\mathbf{I}.$$\n     - The gradient root-mean-square error at the nodes,\n       $$E_{\\nabla} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left[ \\left( (\\mathbf{D}_x \\mathbf{f})_m - \\frac{\\partial f}{\\partial x}(\\mathbf{x}_m) \\right)^2 + \\left( (\\mathbf{D}_y \\mathbf{f})_m - \\frac{\\partial f}{\\partial y}(\\mathbf{x}_m) \\right)^2 \\right] },$$\n       where $$\\mathbf{f}$$ are the nodal values of $$f.$$\n\n6. Program output format.\n   - Your program must compute $$[E_{\\mathrm{int}}, E_{\\nabla}]$$ for each of the three cases $$A,B,C,$$ in that order, and produce a single line of output containing a list of these three two-element lists, as a comma-separated list enclosed in square brackets. For example, the output structure is\n     $$\\left[ [E_{\\mathrm{int}}^{(A)}, E_{\\nabla}^{(A)}], [E_{\\mathrm{int}}^{(B)}, E_{\\nabla}^{(B)}], [E_{\\mathrm{int}}^{(C)}, E_{\\nabla}^{(C)}] \\right].$$\n   - No physical units are involved, and all angles, if any appear in your own derivations, must be in radians. All numeric outputs must be real-valued scalars.\n\nYour implementation must follow the above steps starting from the stated fundamental definitions and facts, must be fully self-contained, and must require no user input. The final line printed by the program must be the list described above, on a single line, with no additional text.",
            "solution": "The problem statement is complete, scientifically sound, and well-posed. It provides a meticulous, step-by-step procedure for generating warp-and-blend nodal distributions on a reference triangle and subsequently constructing the corresponding high-order interpolation and differentiation operators. The foundations of the method, including barycentric coordinates, polynomial interpolation, Vandermonde matrices, and the specific warp-and-blend construction, are standard and well-established within the field of spectral and discontinuous Galerkin methods. The test cases are well-chosen to verify the implementation: cases with polynomial test functions of a degree that can be exactly represented by the basis ($N=0, 1$) should yield errors near machine precision, providing a strong validation check, while the case with a transcendental function ($N=3$) will test the approximation properties of the scheme. All definitions are mathematically precise, and there are no contradictions or ambiguities. Therefore, the problem is deemed valid and a solution can be constructed.\n\nThe solution proceeds by implementing the specified algorithmic steps.\n\nFirst, for a given polynomial degree $N \\in \\mathbb{N}_0$, a set of nodes is generated on the reference two-dimensional simplex. The process begins with an equidistant lattice in barycentric coordinates $(\\lambda_1, \\lambda_2, \\lambda_3)$. For $N \\ge 1$, these are the points $\\left\\{ (\\ell_1/N, \\ell_2/N, \\ell_3/N) \\mid \\ell_i \\in \\mathbb{N}_0, \\sum \\ell_i = N \\right\\}$. For $N=0$, the single node is the centroid $(1/3, 1/3, 1/3)$. These barycentric coordinates are initially mapped to physical coordinates $\\mathbf{x}(\\lambda_1, \\lambda_2, \\lambda_3) = \\lambda_1 \\mathbf{V}_1 + \\lambda_2 \\mathbf{V}_2 + \\lambda_3 \\mathbf{V}_3$, where $\\mathbf{V}_i$ are the vertices of the reference equilateral triangle.\n\nTo improve the interpolation properties and condition number of subsequent operators, these equidistant nodes are displaced using a warp-and-blend technique. This technique aims to replicate the one-dimensional Gauss-Lobatto-Legendre (GLL) node distribution along the triangle's edges. The core of this is the one-dimensional warping function, $D_N(t)$. For an equidistant parameterization $t_k = k/N$ for $k=0,\\dots,N$ on the interval $[0,1]$, and a corresponding GLL parameterization $t_k^{\\mathrm{GL}}$, the function $D_N(t)$ is defined as the unique polynomial of degree at most $N$ that interpolates the displacements: $D_N(t_k) = t_k^{\\mathrm{GL}} - t_k$. For $N=0$ and $N=1$, the GLL and equidistant points coincide, so $D_N(t) \\equiv 0$.\n\nFor each point in the triangle, a local parameter $t_i$ is computed for each edge $i \\in \\{1,2,3\\}$ by projection. The warping displacement along each edge's tangent vector $\\mathbf{e}_i$ is then calculated as $D_N(t_i)$. These edge-based displacements are combined using blending functions $B_i(\\lambda_1,\\lambda_2,\\lambda_3) = (1 - \\lambda_i)^2$, which ensure the warp is fully active on the corresponding edge (where $B_i=1$) and smoothly decays to zero at the opposite vertex and within the interior. The final warped physical coordinates are given by the sum of the initial affine position and the blended warp displacements:\n$$\n\\mathbf{x}_{\\mathrm{WB}} = \\mathbf{x}(\\lambda_1,\\lambda_2,\\lambda_3) \\;+\\; \\sum_{i=1}^{3} \\mathbf{e}_i \\, B_i(\\lambda_1,\\lambda_2,\\lambda_3) \\, D_N(t_i).\n$$\n\nSecond, with the set of $M = (N+1)(N+2)/2$ warped nodes $\\{\\mathbf{x}_m\\}_{m=1}^M$ established, we construct the operators. The basis for the space of polynomials of total degree at most $N$, $\\mathcal{P}_N(\\mathbb{R}^2)$, is chosen to be the set of graded monomials $\\{x^i y^j : i+j \\le N\\}$. The Vandermonde matrix $\\mathbf{V}$ is constructed with entries $V_{m,p} = x_m^{i_p} y_m^{j_p}$, where $m$ indexes the nodes and $p$ indexes the monomial basis functions. This matrix maps the coefficients of a polynomial in the monomial basis to its values at the nodes. Consequently, its inverse, $\\mathbf{V}^{-1}$, performs the reverse mapping: from nodal values to monomial coefficients.\n\nDifferentiation operators are derived by first differentiating the monomial basis functions with respect to $x$ and $y$, evaluating them at the nodes to form matrices $\\mathbf{V}_x$ and $\\mathbf{V}_y$, and then mapping the resulting coefficients back to nodal values. This yields the differentiation matrices:\n$$\n\\mathbf{D}_x = \\mathbf{V}_x \\mathbf{V}^{-1}, \\quad \\mathbf{D}_y = \\mathbf{V}_y \\mathbf{V}^{-1}.\n$$\nThese matrices transform a vector of function values at the nodes directly into a vector of the corresponding partial derivative values at the same nodes.\n\nSimilarly, an interpolation matrix $\\mathbf{I}$ can be created to evaluate the polynomial interpolant at an arbitrary set of target points $\\{\\hat{\\mathbf{x}}_q\\}_{q=1}^Q$. This is done by building a Vandermonde-like matrix $\\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\})$ at the target points and applying the mapping from coefficients to nodal values:\n$$\n\\mathbf{I} = \\mathbf{V}(\\{\\hat{\\mathbf{x}}_q\\}) \\mathbf{V}^{-1}.\n$$\n\nFinally, the implementation is verified using the specified test cases. For each case, the nodal values $\\mathbf{f}$ of the test function $f$ are computed at the warp-and-blend nodes. The interpolated values at the target points are calculated as $\\hat{\\mathbf{f}} = \\mathbf{I} \\mathbf{f}$ and compared against the exact values $f(\\hat{\\mathbf{x}}_q)$ to find the interpolation error $E_{\\mathrm{int}}$. The nodal values of the partial derivatives are computed via $(\\mathbf{D}_x \\mathbf{f})$ and $(\\mathbf{D}_y \\mathbf{f})$ and compared against the exact derivatives $\\frac{\\partial f}{\\partial x}(\\mathbf{x}_m)$ and $\\frac{\\partial f}{\\partial y}(\\mathbf{x}_m)$ to compute the gradient error $E_{\\nabla}$. For Cases A ($N=0$) and B ($N=1$), where the test functions are polynomials of degree $\\le N$, both errors are expected to be close to zero, confirming the correctness of the constructed operators.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi\n\ndef solve():\n    \"\"\"\n    Implements the warp-and-blend node generation for a 2D simplex, constructs\n    interpolation and differentiation operators, and evaluates their accuracy\n    on a suite of test cases.\n    \"\"\"\n\n    # 1. Reference geometry, test functions, and target points.\n    V1 = np.array([-1.0, -1.0 / np.sqrt(3.0)])\n    V2 = np.array([1.0, -1.0 / np.sqrt(3.0)])\n    V3 = np.array([0.0, 2.0 / np.sqrt(3.0)])\n    \n    E1 = V3 - V2\n    E2 = V3 - V1\n    E3 = V2 - V1\n\n    target_bary = np.array([\n        [1.0/3.0, 1.0/3.0, 1.0/3.0],\n        [0.2, 0.3, 0.5],\n        [0.8, 0.1, 0.1]\n    ])\n    \n    target_phys = target_bary @ np.array([V1, V2, V3])\n\n    test_cases = [\n        (0, lambda x, y: 3.0 + 0*x, lambda x, y: (0.0, 0.0)),\n        (1, lambda x, y: 1.0 + x - 2.0*y, lambda x, y: (1.0, -2.0)),\n        (3, lambda x, y: np.exp(x) * np.sin(y), \n         lambda x, y: (np.exp(x) * np.sin(y), np.exp(x) * np.cos(y)))\n    ]\n\n    # Helper functions for algorithm steps\n    \n    def get_gll_nodes(N):\n        \"\"\"Computes 1D Gauss-Lobatto-Legendre nodes on [-1, 1].\"\"\"\n        if N == 0:\n            return np.array([0.0])\n        if N == 1:\n            return np.array([-1.0, 1.0])\n        # Interior nodes are roots of P_N'(x), which are roots of Jacobi P_{N-1}^{(1,1)}(x)\n        roots, _ = roots_jacobi(N - 1, 1, 1)\n        return np.sort(np.concatenate(([-1.0], roots, [1.0])))\n\n    def construct_warp_poly(N):\n        \"\"\"Constructs the 1D warping polynomial D_N(t).\"\"\"\n        if N == 0: # No displacement for N=0\n            return np.poly1d([0.0])\n            \n        t_equi = np.linspace(0.0, 1.0, N + 1)\n        x_gll = get_gll_nodes(N)\n        t_gll = (x_gll + 1.0) / 2.0\n        \n        displacement = t_gll - t_equi\n\n        if np.allclose(displacement, 0):\n            return np.poly1d([0.0])\n\n        # Solve Vandermonde system for polynomial coefficients\n        V = np.vander(t_equi, N + 1, increasing=True)\n        coeffs = np.linalg.solve(V, displacement)\n        return np.poly1d(coeffs[::-1])\n\n    def get_equidistant_bary_nodes(N):\n        \"\"\"Generates the equidistant barycentric lattice.\"\"\"\n        if N == 0:\n            return np.array([[1.0/3.0, 1.0/3.0, 1.0/3.0]])\n        \n        nodes = []\n        for i in range(N + 1):\n            for j in range(N - i + 1):\n                k = N - i - j\n                nodes.append([k/N, j/N, i/N]) # Order to match common literature (l3,l2,l1)\n        return np.array(nodes)\n        \n    def get_warp_and_blend_nodes(N, warp_poly):\n        \"\"\"Computes the final 2D warped node coordinates.\"\"\"\n        bary_nodes = get_equidistant_bary_nodes(N)\n        phys_nodes_equi = bary_nodes @ np.array([V1, V2, V3])\n        \n        if N == 0: # No warping for N=0 case.\n            return phys_nodes_equi\n\n        displacements = np.zeros_like(phys_nodes_equi)\n\n        for i, (l1, l2, l3) in enumerate(bary_nodes):\n            # Denominators for edge parameters\n            d1 = l2 + l3\n            d2 = l1 + l3\n            d3 = l1 + l2\n\n            # Local edge parameters, with safe division\n            t1 = l3 / d1 if d1 > 1e-12 else 0.0\n            t2 = l1 / d2 if d2 > 1e-12 else 0.0\n            t3 = l2 / d3 if d3 > 1e-12 else 0.0\n           \n            # Blending factors\n            B1 = (1 - l1)**2\n            B2 = (1 - l2)**2\n            B3 = (1 - l3)**2\n            \n            # Warping displacement\n            warp1 = E1 * B1 * warp_poly(t1)\n            warp2 = E2 * B2 * warp_poly(t2)\n            warp3 = E3 * B3 * warp_poly(t3)\n            \n            displacements[i,:] = warp1 + warp2 + warp3\n        \n        return phys_nodes_equi + displacements\n\n    def get_monomial_exponents(N):\n        \"\"\"Generates exponents (i,j) for the monomial basis x^i y^j.\"\"\"\n        exponents = []\n        for i in range(N + 1):\n            for j in range(N - i + 1):\n                exponents.append((i, j))\n        return exponents\n\n    def build_vandermonde(nodes, exponents):\n        \"\"\"Builds the 2D Vandermonde matrix.\"\"\"\n        M = len(nodes)\n        P = len(exponents)\n        V = np.zeros((M, P))\n        for m in range(M):\n            for p in range(P):\n                i, j = exponents[p]\n                V[m, p] = nodes[m, 0]**i * nodes[m, 1]**j\n        return V\n\n    def build_vandermonde_derivatives(nodes, exponents):\n        \"\"\"Builds Vandermonde matrices for partial derivatives.\"\"\"\n        M = len(nodes)\n        P = len(exponents)\n        Vx = np.zeros((M, P))\n        Vy = np.zeros((M, P))\n        for m in range(M):\n            for p in range(P):\n                i, j = exponents[p]\n                # d/dx (x^i y^j) = i * x^(i-1) y^j\n                if i > 0:\n                    Vx[m, p] = i * nodes[m, 0]**(i-1) * nodes[m, 1]**j\n                # d/dy (x^i y^j) = j * x^i y^(j-1)\n                if j > 0:\n                    Vy[m, p] = j * nodes[m, 0]**i * nodes[m, 1]**(j-1)\n        return Vx, Vy\n\n    all_results = []\n    \n    # Main loop over test cases\n    for N, f, grad_f in test_cases:\n        # 2. Node Generation\n        warp_poly = construct_warp_poly(N)\n        wb_nodes = get_warp_and_blend_nodes(N, warp_poly)\n        M = len(wb_nodes)\n        \n        # 3. Operator Construction\n        exponents = get_monomial_exponents(N)\n        V = build_vandermonde(wb_nodes, exponents)\n        V_inv = np.linalg.inv(V)\n        \n        Vx, Vy = build_vandermonde_derivatives(wb_nodes, exponents)\n        Dx = Vx @ V_inv\n        Dy = Vy @ V_inv\n\n        # 4. Error Calculation\n        f_nodal = f(wb_nodes[:, 0], wb_nodes[:, 1])\n\n        # Interpolation Error\n        V_target = build_vandermonde(target_phys, exponents)\n        I = V_target @ V_inv\n        f_interp = I @ f_nodal\n        f_exact_target = f(target_phys[:, 0], target_phys[:, 1])\n        E_int = np.sqrt(np.mean((f_interp - f_exact_target)**2))\n\n        # Gradient Error\n        dfdx_num = Dx @ f_nodal\n        dfdy_num = Dy @ f_nodal\n        \n        dfdx_exact, dfdy_exact = grad_f(wb_nodes[:, 0], wb_nodes[:, 1])\n\n        err_dx_sq = (dfdx_num - dfdx_exact)**2\n        err_dy_sq = (dfdy_num - dfdy_exact)**2\n        E_nabla = np.sqrt(np.mean(err_dx_sq + err_dy_sq))\n        \n        all_results.append([E_int, E_nabla])\n\n    # Final print statement in the exact required format.\n    print(str(all_results))\n\nsolve()\n```"
        }
    ]
}