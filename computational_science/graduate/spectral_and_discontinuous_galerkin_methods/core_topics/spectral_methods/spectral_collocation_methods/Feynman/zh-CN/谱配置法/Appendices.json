{
    "hands_on_practices": [
        {
            "introduction": "在谱方法中，正确地离散化微分算子是确保数值方案稳定性和准确性的第一步。对于形如 $-(a(x) u_x)_x = f(x)$ 的变系数问题，我们可以采用不同的策略，例如直接应用微分矩阵的“强形式”，或基于积分的“弱形式”。这个练习  将指导你通过代码实现这两种方法，并比较它们生成的离散算子的关键性质，如对称性和正定性。通过这个实践，你将深刻理解为何弱形式方法在保持算子物理性质方面通常更具优势，是构建稳健谱方法的基石。",
            "id": "3416617",
            "problem": "考虑在区间 $[-1,1]$ 上的守恒形式的一维二阶椭圆算子，带有齐次 Dirichlet 边界条件，由以下微分方程定义\n$$\n-(a(x)\\, u_x)_x = f(x), \\quad x \\in [-1,1], \\quad u(-1)=u(1)=0,\n$$\n其中 $a(x)$ 是 $[-1,1]$ 上的一个严格正函数，$u(x)$ 是未知解。在使用 Legendre–Gauss–Lobatto (LGL) 点的谱配置法中，令 $N$ 表示全局插值多项式的次数，$N+1$ 表示 LGL 节点的数量，$x_j$ 表示 LGL 节点，$w_j$ 表示相应的 LGL 求积权重，$D$ 表示作用于节点值上的 LGL 微分矩阵。在离散 $L^2$ 内积下保持对称性的离散守恒弱形式刚度矩阵为\n$$\nK = D_{AI}^\\top W A D_{AI},\n$$\n其中 $A=\\mathrm{diag}(a(x_j))$，$W=\\mathrm{diag}(w_j)$，并且 $D_{AI}$ 表示 $D$ 中对应于内部自由度（不包括端点以施加齐次 Dirichlet 边界条件）的列。通过对节点乘积 $(a u_x)$ 求导得到的强形式配置矩阵是\n$$\nL_c = -\\left[ D\\, A\\, D \\right]_{II},\n$$\n即 $-D A D$ 的内部-内部子矩阵，它在内部节点上施加该算子。\n\n从以下基本原理出发：\n- LGL 点上的 Lagrange 插值的定义及其对多项式的精确性性质。\n- 具有 $N+1$ 个节点的 LGL 求积可以精确积分最高为 $2N-1$ 次的任何多项式。\n- Legendre 多项式的定义及其在构造 LGL 节点中的作用。\n- 通过分部积分导出的标准弱形式，当 $a(x)>0$ 时，它会产生一个对称正定的双线性形式。\n\n你的任务是：\n- 从第一性原理出发，推导求积被积函数所需的精确性条件，以使离散弱形式配置刚度矩阵 $K$ 与精确的 Galerkin 刚度矩阵一致，并且是对称正定 (SPD) 的。将此精确性表示为一个关于 $a(x)$ 多项式次数相对于 $N$ 的条件。\n- 实现一个程序，对于给定的 $N$ 构建 LGL 节点、权重和微分矩阵，对指定的 $a(x)$ 构建 $K$ 和 $L_c$，并通过移除边界自由度来检查在齐次 Dirichlet 边界条件下每个矩阵的对称性和正定性。\n- 当在强形式配置 $L_c$ 中，所选多项式次数 $N$ 对 $a(x)$ 的分辨不足时，识别并测试其失效情况。对于任何三角函数（如 $\\cos$），使用弧度单位。\n\n使用以下参数集 $(N, a(x), p)$ 的测试套件，其中当适用时，$p$ 是 $a(x)$ 的多项式次数，否则设为一个指示非多项式的特殊标记：\n- 情况 1：$N=8$，$a(x)=1.2 + x$，$p=1$。\n- 情况 2：$N=8$，$a(x)=1 + x^2$，$p=2$。\n- 情况 3：$N=12$，$a(x)=1 + 0.5\\cos(10 x)$ (使用弧度)，$p$ 为非多项式。\n- 情况 4：$N=8$，$a(x)=1 + 0.9\\cos(20 x)$ (使用弧度)，$p$ 为非多项式。\n\n对于每种情况，你的程序必须计算并返回一个包含五个值的列表：\n- 一个布尔值，指示 $K$ 是否对称。\n- 一个布尔值，指示 $K$ 是否对称正定 (SPD)。\n- 一个布尔值，指示 $L_c$ 是否对称。\n- 一个布尔值，指示 $L_c$ 是否对称正定 (SPD)。\n- 一个布尔值，指示为 $K$ 推导的求积精确性条件是否满足，即被积函数的次数是否至多为 $2N-1$（对于非多项式 $a(x)$，此值必须返回为“不满足”的布尔值）。\n\n你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，其中每个条目对应一个测试用例，并且本身是按上述顺序排列的五个布尔值的列表。例如，一个包含按指定顺序排列的四个测试用例的输出行应如下所示\n$$\n[\\,[b_{11},b_{12},b_{13},b_{14},b_{15}],\\,[b_{21},b_{22},b_{23},b_{24},b_{25}],\\,[b_{31},b_{32},b_{33},b_{34},b_{35}],\\,[b_{41},b_{42},b_{43},b_{44},b_{45}]\\,]\n$$\n其中每个 $b_{ij}$ 为字面量 $\\texttt{True}$ 或 $\\texttt{False}$。",
            "solution": "首先对问题陈述的科学合理性、自洽性和客观性进行验证。\n\n### 步骤 1：提取已知条件\n- **微分方程**：$-(a(x)\\, u_x)_x = f(x)$，其中 $x \\in [-1,1]$。\n- **边界条件**：齐次 Dirichlet，$u(-1)=u(1)=0$。\n- **系数函数**：$a(x)$ 是 $[-1,1]$ 上的严格正函数。\n- **离散化**：使用 Legendre–Gauss–Lobatto (LGL) 点的谱配置法。\n- **参数**：\n    - $N$：全局插值多项式的次数。\n    - $N+1$：LGL 节点的数量。\n    - $x_j$：LGL 节点，其中 $j=0, \\dots, N$。\n    - $w_j$：LGL 求积权重，其中 $j=0, \\dots, N$。\n    - $D$：$(N+1) \\times (N+1)$ 的 LGL 微分矩阵。\n- **矩阵定义**：\n    - **弱形式刚度矩阵**：$K = D_{AI}^\\top W A D_{AI}$。\n        - $A = \\mathrm{diag}(a(x_j))$。\n        - $W = \\mathrm{diag}(w_j)$。\n        - $D_{AI}$：$D$ 中对应内部节点（索引 $1, \\dots, N-1$）的列。\n    - **强形式配置矩阵**：$L_c = -\\left[ D\\, A\\, D \\right]_{II}$。\n        - $II$ 表示对应于内部-内部索引的子矩阵。\n- **基本原理**：Lagrange 插值，LGL 求积精确性（对于次数最高为 $2N-1$ 的多项式），Legendre 多项式的性质，以及通过分部积分导出的标准弱形式。\n- **测试用例**：\n    1. $N=8$, $a(x)=1.2 + x$, $p=1$。\n    2. $N=8$, $a(x)=1 + x^2$, $p=2$。\n    3. $N=12$, $a(x)=1 + 0.5\\cos(10 x)$, $p$ 为非多项式。\n    4. $N=8$, $a(x)=1 + 0.9\\cos(20 x)$, $p$ 为非多项式。\n- **要求输出**：对于每个测试用例，一个包含五个布尔值的列表：[K 是否对称, K 是否对称正定, Lc 是否对称, Lc 是否对称正定, 求积精确性条件是否满足]。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数值分析这一成熟领域，特别是在微分方程的谱方法方面，具有坚实的科学基础。算子、矩阵（$K$ 和 $L_c$）以及 LGL 离散化的定义都是标准且正确的。任务——推导条件和数值验证——是客观且适定的。所提供的测试用例使用的函数 $a(x)$ 在 $[-1,1]$ 上是严格为正的，这确保了其 underlying 连续问题的数学和物理适定性。参数是完整且一致的。基于这些原因，该问题被判定为有效。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整解答。\n\n### 解答与推导\n\n#### 第 1 部分：$K$ 的求积精确性条件的推导\n\n微分方程的连续弱形式是通过乘以一个来自合适空间（此处为 $H_0^1(-1,1)$）的测试函数 $v(x)$，然后在定义域 $[-1,1]$ 上积分得到的。\n$$ \\int_{-1}^{1} -(a(x) u_x(x))_x v(x) \\, dx = \\int_{-1}^{1} f(x) v(x) \\, dx $$\n对左侧进行分部积分可得：\n$$ \\left[-a(x) u_x(x) v(x)\\right]_{-1}^{1} + \\int_{-1}^{1} a(x) u_x(x) v_x(x) \\, dx = \\int_{-1}^{1} f(x) v(x) \\, dx $$\n考虑到解空间的齐次 Dirichlet 边界条件（$u(-1)=u(1)=0$，并且我们选择测试函数 $v$ 使得 $v(-1)=v(1)=0$），边界项为零。这给出了 Galerkin 方法的双线性形式：\n$$ B(u, v) = \\int_{-1}^{1} a(x) u_x(x) v_x(x) \\, dx $$\n精确 Galerkin 刚度矩阵的元素为 $K_{ij}^{\\text{Galerkin}} = B(\\phi_j, \\phi_i)$，其中 $\\{\\phi_i\\}$ 是一组基函数。在配置法的背景下，我们使用 Lagrange 多项式 $\\ell_j(x)$ 作为基。由于齐次边界条件，我们只考虑对应于内部节点的基函数，即 $i, j \\in \\{1, \\dots, N-1\\}$。\n$$ K_{ij}^{\\text{Galerkin}} = \\int_{-1}^{1} a(x) \\ell'_j(x) \\ell'_i(x) \\, dx $$\n离散弱形式刚度矩阵 $K = D_{AI}^\\top W A D_{AI}$ 是通过使用 LGL 求积来近似积分 $B(u,v)$ 得到的。$B(u,v)$ 的求积近似为：\n$$ B(u,v) \\approx \\sum_{k=0}^{N} w_k a(x_k) u_x(x_k) v_x(x_k) = (\\mathbf{u}_x)^\\top W A \\mathbf{v}_x $$\n其中 $\\mathbf{u}_x$ 和 $\\mathbf{v}_x$ 是在所有 LGL 节点上导数值的向量。这些导数通过微分矩阵块 $D_{AI}$ 从内部节点值 $\\mathbf{u}_I$ 和 $\\mathbf{v}_I$ 获得：$\\mathbf{u}_x = D_{AI} \\mathbf{u}_I$ 和 $\\mathbf{v}_x = D_{AI} \\mathbf{v}_I$。将这些代入求积和中，得到与矩阵 $K$ 对应的二次型：\n$$ \\mathbf{v}_I^\\top (D_{AI}^\\top W A D_{AI}) \\mathbf{u}_I = \\mathbf{v}_I^\\top K \\mathbf{u}_I $$\n当且仅当 LGL 求积法则对被积函数 $I(x) = a(x) \\ell'_j(x) \\ell'_i(x)$ 是精确的时，离散矩阵 $K$ 与精确 Galerkin 矩阵 $K^{\\text{Galerkin}}$ 一致。\n与 $N+1$ 个 LGL 节点相关的 Lagrange 基多项式 $\\ell_j(x)$ 的次数为 $N$。它们的导数 $\\ell'_j(x)$ 是次数为 $N-1$ 的多项式。因此，乘积 $\\ell'_j(x) \\ell'_i(x)$ 是一个次数至多为 $(N-1) + (N-1) = 2N-2$ 的多项式。\n令 $p$ 为系数函数 $a(x)$ 的多项式次数。被积函数的总次数为 $\\deg(I(x)) = p + 2N-2$。\n具有 $N+1$ 个节点的 LGL 求积对次数最高为 $2N-1$ 的任何多项式都是精确的。为使求积精确，我们必须有：\n$$ \\deg(I(x)) \\le 2N-1 $$\n$$ p + 2N-2 \\le 2N-1 $$\n$$ p \\le 1 $$\n因此，当且仅当 $a(x)$ 是次数至多为 1 的多项式时，离散弱形式矩阵 $K$ 才与精确 Galerkin 矩阵完全相同。\n\n#### 第 2 部分：$K$ 和 $L_c$ 的性质\n\n**$K$ 的对称性与正定性**：\n矩阵 $K = D_{AI}^\\top W A D_{AI}$ 总是对称的。矩阵 $W$ 和 $A$ 是对角矩阵，因此是对称的。\n$$ K^\\top = (D_{AI}^\\top W A D_{AI})^\\top = D_{AI}^\\top A^\\top W^\\top (D_{AI}^\\top)^\\top = D_{AI}^\\top A W D_{AI} $$\n由于对角矩阵可交换，$AW=WA$，所以 $K^\\top = D_{AI}^\\top W A D_{AI} = K$。\n为了检查正定性，考虑对于任意非零向量 $\\mathbf{v} \\in \\mathbb{R}^{N-1}$ 的二次型：\n$$ \\mathbf{v}^\\top K \\mathbf{v} = \\mathbf{v}^\\top D_{AI}^\\top W A D_{AI} \\mathbf{v} = (D_{AI}\\mathbf{v})^\\top W A (D_{AI}\\mathbf{v}) $$\n令 $\\mathbf{y} = D_{AI}\\mathbf{v}$。这是在所有节点上某个多项式的导数向量，该多项式在内部节点上的值为 $\\mathbf{v}$，在边界上为零。二次型为 $\\sum_{j=0}^{N} w_j a(x_j) y_j^2$。由于 LGL 权重 $w_j$ 为正，且 $a(x)$ 是严格正的，所以所有 $a(x_j)>0$。除非所有 $y_j=0$，否则该和为正。如果 $\\mathbf{y}=0$，则导数多项式在所有 $N+1$ 个节点上都为零。由于该导数的次数为 $N-1$，它必须恒等于零。这意味着多项式本身是一个常数。由于它在边界处为零，所以它必须是零多项式。这意味着其内部节点值 $\\mathbf{v}$ 必须为零。因此，对于 $\\mathbf{v} \\neq 0$，有 $\\mathbf{v}^\\top K \\mathbf{v} > 0$。\n结论：对于任何严格正的系数函数 $a(x)$，$K$ 都是对称正定 (SPD) 的，这与求积精确性条件无关。条件 $p \\le 1$ 确保了与*连续* Galerkin 公式的等价性，而不是*离散*系统的 SPD 性质。\n\n**$L_c$ 的对称性与正定性**：\n强形式矩阵为 $L_c = -[DAD]_{II}$。一般来说，完整的 LGL 微分矩阵 $D$ 不是对称的。因此，乘积 $DAD$ 预计不是对称的，其子矩阵 $L_c$ 也不是。一个矩阵必须是对称的才能被归类为对称正定。因此，我们预计 $L_c$ 通常既不是对称的，也不是 SPD 的。非对称性是强形式配置法在构造不仔细时的一个已知缺点。对于非恒定的 $a(x)$，对称性的失效是与弱形式矩阵 $K$ 的一个关键区别。对 $a(x)$ 的任何分辨不足（如情况 4），都会导致对算子的不良近似，但即使对于分辨良好、非恒定的 $a(x)$，其根本上的非对称性也存在。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_lgl(N):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes, weights, and \n    differentiation matrix for a given polynomial degree N.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The LGL nodes (x).\n            - np.ndarray: The LGL weights (w).\n            - np.ndarray: The LGL differentiation matrix (D).\n    \"\"\"\n    if N  1:\n        raise ValueError(\"N must be at least 1.\")\n    \n    # N+1 points, degree N polynomial\n    # Interior nodes are roots of P_N'(x)\n    PN = legendre(N)\n    PN_deriv = PN.deriv(1)\n    # The .roots method on a scipy orthopoly1d object finds the roots.\n    interior_nodes = np.sort(PN_deriv.roots)\n\n    x = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights formula: w_j = 2 / (N(N+1) [P_N(x_j)]^2)\n    PN_vals_at_nodes = PN(x)\n    w = 2.0 / (N * (N + 1) * PN_vals_at_nodes**2)\n    \n    # Differentiation matrix D formula\n    N_plus_1 = N + 1\n    D = np.zeros((N_plus_1, N_plus_1))\n\n    # Off-diagonal elements: D_ij = P_N(x_i) / (P_N(x_j) * (x_i - x_j)) for i != j\n    for i in range(N_plus_1):\n        for j in range(N_plus_1):\n            if i != j:\n                D[i, j] = PN_vals_at_nodes[i] / (PN_vals_at_nodes[j] * (x[i] - x[j]))\n    \n    # Diagonal elements\n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    for i in range(1, N):\n        D[i, i] = x[i] / (1.0 - x[i]**2)\n        \n    return x, w, D\n\ndef analyze_matrices(N, a_func, p):\n    \"\"\"\n    Constructs and analyzes matrices K and Lc for a given test case.\n\n    Args:\n        N (int): The polynomial degree.\n        a_func (callable): The function a(x).\n        p (int or str): The polynomial degree of a(x) or a nonpolynomial marker.\n\n    Returns:\n        list: A list of five boolean values:\n              [is_K_symmetric, is_K_spd, is_Lc_symmetric, is_Lc_spd, \n               is_quad_exactness_satisfied]\n    \"\"\"\n    x, w, D = get_lgl(N)\n    \n    a_vals = a_func(x)\n    if not np.all(a_vals > 0):\n        # This check is for robustness; problem statement guarantees a(x)>0\n        raise ValueError(\"a(x) must be strictly positive on [-1, 1].\")\n\n    A = np.diag(a_vals)\n    W = np.diag(w)\n    \n    # Interior indices are 1, ..., N-1. In Python slicing, this is 1:N\n    interior_slice = slice(1, N)\n    \n    # K = D_AI' * W * A * D_AI\n    # D_AI is the block of D with all rows and interior columns.\n    D_AI = D[:, interior_slice]\n    K = D_AI.T @ W @ A @ D_AI\n    \n    # Lc = -[D*A*D]_II\n    # [DAD]_II is the interior-interior block of the matrix D*A*D.\n    DAD = D @ A @ D\n    Lc = -DAD[interior_slice, interior_slice]\n    \n    tol = 1e-12\n    \n    # 1. Check if K is symmetric\n    is_K_symmetric = np.allclose(K, K.T, atol=tol)\n    \n    # 2. Check if K is SPD\n    is_K_spd = False\n    if is_K_symmetric:\n        try:\n            eigvals = np.linalg.eigvalsh(K)\n            is_K_spd = np.all(eigvals > tol)\n        except np.linalg.LinAlgError:\n            is_K_spd = False\n            \n    # 3. Check if Lc is symmetric\n    is_Lc_symmetric = np.allclose(Lc, Lc.T, atol=tol)\n    \n    # 4. Check if Lc is SPD (requires symmetry)\n    is_Lc_spd = False\n    if is_Lc_symmetric:\n        try:\n            eigvals = np.linalg.eigvalsh(Lc)\n            is_Lc_spd = np.all(eigvals > tol)\n        except np.linalg.LinAlgError:\n            is_Lc_spd = False\n\n    # 5. Check if quadrature exactness condition (p = 1) is satisfied\n    is_quad_exactness_satisfied = (isinstance(p, int) and p = 1)\n            \n    return [is_K_symmetric, is_K_spd, is_Lc_symmetric, is_Lc_spd, is_quad_exactness_satisfied]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=8, a(x)=1.2 + x, p=1\n        (8, lambda x: 1.2 + x, 1),\n        # Case 2: N=8, a(x)=1 + x^2, p=2\n        (8, lambda x: 1.0 + x**2, 2),\n        # Case 3: N=12, a(x)=1 + 0.5cos(10x), p=nonpolynomial\n        (12, lambda x: 1.0 + 0.5 * np.cos(10 * x), \"nonpolynomial\"),\n        # Case 4: N=8, a(x)=1 + 0.9cos(20x), p=nonpolynomial\n        (8, lambda x: 1.0 + 0.9 * np.cos(20 * x), \"nonpolynomial\"),\n    ]\n\n    results = []\n    for N, a_func, p in test_cases:\n        case_results = analyze_matrices(N, a_func, p)\n        results.append(case_results)\n\n    # Format the output as specified\n    # Using str() on Python booleans gives 'True' and 'False' literals,\n    # which is what the problem asks for.\n    result_str = ','.join([str(res) for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "谱方法以其对光滑函数的高精度而闻名，但在处理不连续性时会遇到困难，导致称为吉布斯现象的伪振荡。这个实践  提供了一种动手方法来解决这个问题，即通过实现一种模态滤波器。你将学习如何将解从物理（节点）空间转换到频率（模态）空间，在其中应用指数滤波器来抑制高频分量，然后转换回物理空间。这个过程能够有效减少振荡，同时保留解的主要特征，是处理非光滑解的一项基本且实用的技术。",
            "id": "3416563",
            "problem": "设 $N \\in \\mathbb{N}$，并考虑在区间 $[-1,1]$ 上的切比雪夫-高斯-洛巴托配置，其节点为 $x_j = \\cos(\\pi j / N)$，$j \\in \\{0,1,\\dots,N\\}$。定义在 $x=0$ 处有一个跳跃（不连续点）的分段常数函数如下\n$$\nu(x) = \\begin{cases}\n-1,  x  0,\\\\\n0,   x = 0,\\\\\n1,   x > 0,\n\\end{cases}\n$$\n并令节点数据为 $u_j = u(x_j)$，$j \\in \\{0,1,\\dots,N\\}$，其中在 $x=0$ 处的值为跳跃平均值 $0$。在切比雪夫配置中，次数为 $N$ 的插值多项式 $p_N(x)$ 是满足 $p_N(x_j)=u_j$（$j \\in \\{0,1,\\dots,N\\}$）的唯一多项式。将 $p_N$ 在切比雪夫多项式基 $\\{T_k\\}_{k=0}^N$ 中表示为\n$$\np_N(x) = \\sum_{k=0}^{N} a_k T_k(x),\n$$\n其中 $T_k(x)$ 是第 $k$ 阶第一类切比雪夫多项式，由 $T_0(x)=1$，$T_1(x)=x$ 和对所有 $k \\ge 1$ 成立的三项递推关系 $T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)$ 定义。\n\n你需要构建一个作用于切比雪夫系数 $\\{a_k\\}_{k=0}^N$ 的指数模态滤波器，并量化其对 $x=0$ 处不连续点引起的吉布斯振荡的影响。指数滤波器定义为\n$$\n\\sigma_k = \\exp\\!\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{p}\\right), \\quad k \\in \\{0,1,\\dots,N\\},\n$$\n其中滤波器强度参数为 $\\alpha \\ge 0$，阶数为偶数 $p \\in \\mathbb{N}$，滤波后的模态系数为 $\\tilde{a}_k = \\sigma_k a_k$。滤波后的多项式则为\n$$\n\\tilde{p}_N(x) = \\sum_{k=0}^{N} \\tilde{a}_k T_k(x).\n$$\n你的构建过程必须包括：将节点值 $\\{u_j\\}$ 变换为模态系数 $\\{a_k\\}$，在模态空间中应用滤波器 $\\{\\sigma_k\\}$，然后通过计算滤波后的多项式，变换回节点空间或得到逐点函数值。\n\n为量化对吉布斯振荡的影响，需在区间 $[-1,1]$ 上一个包含 $M=5001$ 个点的密集等距网格上计算 $p_N$ 和 $\\tilde{p}_N$ 的值，并按如下方式测量过冲幅度。定义\n$$\nA(q) = \\max\\!\\left\\{\\max_{x \\in [-1,1]} q(x) - 1,\\; -1 - \\min_{x \\in [-1,1]} q(x),\\; 0\\right\\}.\n$$\n该量度量了 $q(x)$ 超出平台水平 $\\pm 1$ 的最大偏移。计算比率\n$$\nR = \\frac{A(\\tilde{p}_N)}{A(p_N)}.\n$$\n$R=1$ 表示过冲没有减少，而 $R \\in (0,1)$ 表示有所减少。\n\n角度必须以弧度为单位进行解释。\n\n你的程序必须使用切比雪夫基 $\\{T_k\\}$ 和三项递推关系来实现从节点系数到模态系数的变换及逆变换。然后，程序必须在密集网格上计算未滤波和滤波后的多项式，并为下面测试套件中的每个测试用例计算 $R$。不提供外部输入；所有参数都将硬编码。最终输出必须为单行，其中包含一个用方括号括起来的、以逗号分隔的 $R$ 值列表。\n\n测试套件（每个测试用例是一个三元组 $(N,\\alpha,p)$）：\n- 用例 $1$：$(N,\\alpha,p) = (32, 0, 8)$。\n- 用例 $2$：$(N,\\alpha,p) = (32, 36, 8)$。\n- 用例 $3$：$(N,\\alpha,p) = (64, 36, 8)$。\n- 用例 $4$：$(N,\\alpha,p) = (64, 100, 16)$。\n- 用例 $5$：$(N,\\alpha,p) = (16, 36, 2)$。\n- 用例 $6$：$(N,\\alpha,p) = (8, 36, 8)$。\n\n最终输出格式：你的程序应生成单行输出，其中包含上述六个用例的比率 $R$ 值，以逗号分隔的列表形式呈现，四舍五入到八位小数，并用方括号括起来，例如\n$$\n[\\;r_1,\\;r_2,\\;r_3,\\;r_4,\\;r_5,\\;r_6\\;].\n$$",
            "solution": "所提出的问题是数值分析领域，特别是谱方法方面，一个有效且明确的练习。它要求实现并量化一个指数滤波器，以减轻不连续函数的切比雪夫多项式插值所产生的吉布斯现象。该问题具有科学依据、内部一致，并且解决它所需的所有要素要么已经提供，要么是该学科内的标准知识。\n\n解决方案通过一系列离散且定义明確的步骤进行：\n1.  生成节点数据。\n2.  将节点数据转换为模态（切比雪夫）系数。\n3.  在模态空间中应用指数滤波器。\n4.  在精细网格上计算原始多项式和滤波后多项式的值。\n5.  量化吉布斯现象引起的过冲以及滤波器的有效性。\n\n下面将详细介绍这些步骤中的每一步。\n\n首先，对于由参数三元组 $(N, \\alpha, p)$ 定义的每个测试用例，我们建立计算网格和数据。插值节点是 $N+1$ 个切比雪夫-高斯-洛巴托（CGL）点，由 $x_j = \\cos(\\pi j / N)$ 给出，$j \\in \\{0, 1, \\dots, N\\}$。待插值的函数是符号函数，经过修改使其在原点处为零：\n$$\nu(x) = \\begin{cases}\n-1,  x  0,\\\\\n0,   x = 0,\\\\\n1,   x > 0.\n\\end{cases}\n$$\n节点数据 $\\{u_j\\}_{j=0}^N$ 通过在 CGL 节点上计算该函数得到，$u_j = u(x_j)$。注意，对于偶数 $N$，节点 $x_{N/2} = \\cos(\\pi/2) = 0$ 存在，因此 $u_{N/2}=0$。对于奇数 $N$，没有节点位于 $0$ 处，因此所有的 $u_j$ 要么是 $1$ 要么是 $-1$。\n\n其次，我们将节点数据 $\\{u_j\\}$ 转换为插值多项式 $p_N(x) = \\sum_{k=0}^N a_k T_k(x)$ 的模态系数 $\\{a_k\\}$，其中 $T_k(x)$ 是第 $k$ 阶第一类切比雪夫多项式。对数据进行插值（即对所有 $j \\in \\{0, \\dots, N\\}$ 都有 $p_N(x_j) = u_j$）的、次数最多为 $N$ 的唯一多项式 $p_N(x)$，其切比雪夫系数由离散余弦变换给出：\n$$\na_k = \\frac{2}{N \\bar{c}_k} \\sum_{j=0}^{N} \\frac{u_j}{\\bar{c}_j} \\cos\\left(\\frac{\\pi j k}{N}\\right), \\quad k \\in \\{0, 1, \\dots, N\\},\n$$\n其中权重 $\\bar{c}_k$ 定义为 $\\bar{c}_0 = \\bar{c}_N = 2$，$j \\in \\{1, \\dots, N-1\\}$ 时 $\\bar{c}_j = 1$。该变换通过直接求和实现，其计算复杂度为 $O(N^2)$，对于测试套件中指定的 $N$ 值来说，效率足够高。\n\n第三，应用指数模态滤波器。滤波器由系数 $\\sigma_k = \\exp(-\\alpha (k/N)^p)$ 定义，其中 $\\alpha \\ge 0$ 是滤波器强度，$p$ 是其阶数。滤波操作是模态（系数）空间中的简单逐元素乘积：滤波后的系数为 $\\tilde{a}_k = \\sigma_k a_k$。这些是滤波后多项式 $\\tilde{p}_N(x) = \\sum_{k=0}^N \\tilde{a}_k T_k(x)$ 的系数。$\\alpha=0$ 的情况对应于不进行滤波（对所有 $k$ 都有 $\\sigma_k=1$），这可作为基准。\n\n第四，未滤波多项式 $p_N(x)$ 和滤波后多項式 $\\tilde{p}_N(x)$ 都在区间 $[-1, 1]$ 上一个包含 $M=5001$ 个点的密集等距网格上进行求值。为了高效地执行此求值，我们构建一个 $M \\times (N+1)$ 的类范德蒙矩阵 $V$，其中每个条目为 $V_{ik} = T_k(y_i)$，$\\{y_i\\}_{i=1}^M$ 为求值点。该矩阵的列是使用切比雪夫多项的三项递推关系生成的：$T_0(x)=1$, $T_1(x)=x$ 和 $T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)$。网格上的多项式值随后通过矩阵-向量乘积 $V \\cdot a$ 和 $V \\cdot \\tilde{a}$ 得到，其中 $a$ 和 $\\tilde{a}$ 是系数的列向量。\n\n最后，我们量化滤波器对吉布斯振荡的影响。多项式 $q(x)$ 的过冲幅度定义为\n$$\nA(q) = \\max\\!\\left\\{\\max_{x \\in [-1,1]} q(x) - 1, \\; -1 - \\min_{x \\in [-1,1]} q(x), \\; 0\\right\\},\n$$\n其中 $1$ 和 $-1$ 是原始函数 $u(x)$ 的平台值。这个度量是针对 $p_N(x)$ 和 $\\tilde{p}_N(x)$，通过在密集求值网格上取数值最大值和最小值来计算的。最终的性能度量是滤波后过冲与未滤波过冲的比率，$R = A(\\tilde{p}_N) / A(p_N)$。$R=1$ 的值意味着过冲没有减少，而 $R \\in [0,1)$ 表示成功抑制。为每个测试用例计算该比率，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying the effect of an exponential modal filter\n    on Gibbs oscillations in Chebyshev collocation.\n    \"\"\"\n    test_cases = [\n        (32, 0, 8),\n        (32, 36, 8),\n        (64, 36, 8),\n        (64, 100, 16),\n        (16, 36, 2),\n        (8, 36, 8),\n    ]\n\n    results = []\n    for N, alpha, p in test_cases:\n        # Step 1: Generate Nodal Data\n        # Chebyshev-Gauss-Lobatto nodes\n        j_nodes = np.arange(N + 1)\n        x_nodes = np.cos(np.pi * j_nodes / N)\n        \n        # Nodal values of the discontinuous function u(x)\n        # np.sign gives 1 for x>0, -1 for x0, and 0 for x=0, which matches u(x).\n        u_nodes = np.sign(x_nodes)\n\n        # Step 2: Nodal to Modal Transform (Chebyshev Coefficients)\n        c_bar = np.ones(N + 1)\n        c_bar[0] = c_bar[N] = 2.0\n        \n        a_coeffs = np.zeros(N + 1)\n        u_weighted = u_nodes / c_bar\n        \n        # Direct summation based on the discrete cosine transform formula\n        for k in range(N + 1):\n            cos_terms = np.cos(np.pi * j_nodes * k / N)\n            sum_val = np.sum(u_weighted * cos_terms)\n            a_coeffs[k] = (2.0 / (N * c_bar[k])) * sum_val\n\n        # Step 3: Apply Exponential Modal Filter\n        k_vals = np.arange(N + 1)\n        sigma = np.exp(-alpha * (k_vals / N)**p)\n        a_tilde_coeffs = sigma * a_coeffs\n\n        # Step 4: Evaluate Polynomials on a Dense Grid\n        M = 5001\n        y_grid = np.linspace(-1.0, 1.0, M)\n        \n        # Build Vandermonde-like matrix of Chebyshev polynomials T_k(y)\n        T_matrix = np.zeros((M, N + 1))\n        T_matrix[:, 0] = 1.0\n        if N > 0:\n            T_matrix[:, 1] = y_grid\n        for k_idx in range(1, N):\n            T_matrix[:, k_idx + 1] = 2.0 * y_grid * T_matrix[:, k_idx] - T_matrix[:, k_idx - 1]\n            \n        p_N_vals = T_matrix @ a_coeffs\n        p_tilde_N_vals = T_matrix @ a_tilde_coeffs\n\n        # Step 5: Compute Overshoot Amplitude\n        def calculate_A(poly_vals):\n            \"\"\"Computes the overshoot amplitude A(q).\"\"\"\n            max_val = np.max(poly_vals)\n            min_val = np.min(poly_vals)\n            return np.max([max_val - 1.0, -1.0 - min_val, 0.0])\n            \n        A_p_N = calculate_A(p_N_vals)\n        A_p_tilde_N = calculate_A(p_tilde_N_vals)\n        \n        # Step 6: Compute the Ratio R\n        # Gibbs phenomenon ensures A_p_N > 0 for N > 0.\n        # If A_p_N were 0, R=1.0 is the logical choice for alpha=0,\n        # as there's no change.\n        if A_p_N == 0.0:\n            R = 1.0\n        else:\n            R = A_p_tilde_N / A_p_N\n            \n        results.append(f\"{R:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算流体力学等领域，有效捕捉和稳定模拟激波等尖锐梯度是至关重要的挑战。这个高级练习  建立在模态分析的基础上，指导你构建一个“智能”激波传感器。该传感器通过评估解的谱系数的衰减速率来判断其局部光滑性。如果检测到高频模态中存在显著能量（表明存在激波），传感器将触发在相应计算单元中局部施加人工粘性，从而在不影响光滑区域准确性的前提下稳定数值解。这是一个将理论分析转化为自适应计算策略的绝佳范例。",
            "id": "3416549",
            "problem": "实现一个基于模态衰减的一维激波传感器。该传感器使用由勒让德-高斯-洛巴托 (Legendre–Gauss–Lobatto, LGL) 节点构建的离散勒让德变换，并基于此指示器触发单元局部的黏性。您必须在单个程序中推导、实现和测试以下内容。\n\n从以下基本定义和事实开始：\n- 设 $\\{P_k(x)\\}_{k \\ge 0}$ 表示区间 $[-1,1]$ 上的勒让德多项式，它们在标准内积下是正交的，即 $\\int_{-1}^{1} P_k(x) P_m(x) \\, dx = \\dfrac{2}{2k+1} \\delta_{km}$，其中 $\\delta_{km}$ 是克罗内克符号 (Kronecker delta)。\n- 对于固定的多项式阶数 $N$，区间 $[-1,1]$ 上的勒让德-高斯-洛巴托 (LGL) 节点 $\\{x_i\\}_{i=0}^{N}$ 是端点和 $P_N'(x)$ 的 $N-1$ 个内部根的并集，且存在正的求积权重 $\\{w_i\\}_{i=0}^{N}$，使得 LGL 求积对于次数最高为 $2N-1$ 的多项式是精确的：\n$$\\int_{-1}^{1} q(x) \\, dx = \\sum_{i=0}^{N} w_i \\, q(x_i), \\quad \\text{对于所有次数 } \\deg(q) \\le 2N-1 \\text{ 的多项式 } q。$$\n- 对于在 LGL 节点 $\\{x_i\\}_{i=0}^{N}$ 上采样得到值为 $\\{u_i\\}_{i=0}^{N}$ 的函数 $u(x)$，定义离散内积\n$$\\langle f, g \\rangle_w = \\sum_{i=0}^{N} w_i \\, f(x_i) \\, g(x_i)。$$\n离散勒让德系数 $a_k$ 通过对连续投影的求积近似得到：\n$$a_k \\approx \\frac{2k+1}{2} \\sum_{i=0}^{N} w_i \\, u_i \\, P_k(x_i), \\quad k = 0,1,\\dots,N.$$\n\n定义模态能量 $E_k = a_k^2$ 和一个高阶模态能量比\n$$R = \\frac{\\sum_{k=N-r+1}^{N} E_k}{\\sum_{k=0}^{N} E_k},$$\n其中 $r$ 是一个满足 $1 \\le r \\le N$ 的小正整数。为避免在退化情况下出现除以零的错误，使用正则化比率\n$$R_{\\mathrm{reg}} = \\frac{\\sum_{k=N-r+1}^{N} E_k + \\varepsilon}{\\sum_{k=0}^{N} E_k + \\varepsilon},$$\n其中 $\\varepsilon  0$ 是一个小的正则化参数，并定义衰减指示器\n$$S = \\log_{10} \\left( R_{\\mathrm{reg}} \\right)。$$\n\n基于 $S$ 通过一个简单的阈值斜坡函数触发单元局部的黏性 $\\nu$：\n- 给定参数 $s_0$ (阈值)、$\\Delta s$ (斜坡宽度) 和 $\\nu_{\\max}$ (最大黏性)，设置\n$$\n\\nu =\n\\begin{cases}\n0,  S \\le s_0, \\\\\n\\nu_{\\max} \\, \\min\\left(1, \\dfrac{S - s_0}{\\Delta s}\\right),  S > s_0.\n\\end{cases}\n$$\n这是局部的，因为它是在每个单元上根据该单元的节点采样计算的，并且只应用于该单元。\n\n您的程序必须：\n- 为每个指定的 $N$ 构建 LGL 节点和权重。\n- 使用带有 LGL 权重的离散内积，从节点采样 $\\{u_i\\}_{i=0}^{N}$ 计算离散勒让德系数 $\\{a_k\\}_{k=0}^{N}$。\n- 使用下面指定的固定参数 $r$、$\\varepsilon$、$s_0$、$\\Delta s$ 和 $\\nu_{\\max}$，根据上述定义计算 $S$ 和 $\\nu$。\n- 为验证选择性，将该传感器应用于具有不同平滑度和陡峭度的多个测试函数，并为每种情况报告一个布尔值，指示是否触发了黏性，以及相应的黏性值。\n\n角度单位说明：每当使用三角函数（如 $\\sin$）时，角度单位均为弧度。\n\n对指示器和黏性使用以下固定参数：\n- 多项式阶窗口 $r = 3$（必要时使用 $r = \\min(3, N)$ 以满足 $r \\le N$）。\n- 正则化参数 $\\varepsilon = 10^{-30}$。\n- 阈值 $s_0 = -2.25$。\n- 斜坡宽度 $\\Delta s = 0.75$。\n- 最大黏性 $\\nu_{\\max} = 0.2$。\n\n测试套件：\n- 情况 A (平滑)：$N = 21$，$u(x) = \\sin(5 x)$，其中 $x$ 以弧度为单位。\n- 情况 B (不连续跳跃)：$N = 21$，$u(x) = \\mathrm{sign}(x)$，其中 $\\mathrm{sign}(0) = 0$。\n- 情况 C (尖点)：$N = 21$，$u(x) = |x|$。\n- 情况 D (低阶跳跃)：$N = 7$，$u(x) = \\mathrm{sign}(x)$，其中 $\\mathrm{sign}(0) = 0$。\n- 情况 E (陡峭但连续)：$N = 21$，$u(x) = \\tanh(20 x)$。\n\n对于每种情况，计算布尔触发器 $\\mathbf{1}_{\\{\\nu0\\}}$ 和黏性值 $\\nu$。报告的黏性值需四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个扁平的、用逗号分隔的列表，并用方括号括起来。该列表按 A, B, C, D, E 的顺序串联所有情况的结果，每种情况贡献两个条目：首先是布尔值，然后是四舍五入后的黏性浮点数。例如，一个有效的输出布局是\n$[b_A, \\nu_A, b_B, \\nu_B, b_C, \\nu_C, b_D, \\nu_D, b_E, \\nu_E]$,\n其中 $b_{\\cdot} \\in \\{\\mathrm{True}, \\mathrm{False}\\}$，每个 $\\nu_{\\cdot}$ 是一个四舍五入到六位小数的浮点数。",
            "solution": "用户提供的问题陈述是适定的、有科学依据的，并包含了唯一解所需的所有必要信息。它指定了偏微分方程数值方法领域的一个清晰且标准的程序，特别是谱方法中的模态激波传感器。因此，该问题被视为**有效**的。\n\n任务是实现一个基于勒让德多项式模态系数衰减率的激波传感器。该传感器随后用于触发人工黏性，这是一种在存在不连续性或急剧梯度（激波）时稳定双曲守恒律数值解的常用技术。整个过程在单个一维单元上执行，该单元由参考区间 $[-1, 1]$ 上的一组节点表示。\n\n实现遵循一系列明确定义的数学和算法步骤：\n\n1.  **勒让德-高斯-洛巴托 (LGL) 求积点和权重**\n\n    对于给定的多项式阶数 $N$，我们必须首先在参考单元 $[-1, 1]$ 上建立计算网格。选择 LGL 网格，它由 $N+1$ 个点 $\\{x_i\\}_{i=0}^{N}$ 组成。这些点是多项式 $(1-x^2)P_N'(x)$ 的根，其中 $P_N(x)$ 是 $N$ 阶勒让德多项式。这意味着节点是端点 $x_0 = -1$ 和 $x_N = 1$，以及导数 $P_N'(x)$ 的 $N-1$ 个内部根。\n\n    相应的求积权重 $\\{w_i\\}_{i=0}^{N}$ 由以下公式定义：\n    $$w_i = \\frac{2}{N(N+1) [P_N(x_i)]^2}$$\n    该求积法则对于次数最高为 $2N-1$ 的所有多项式都是精确的。在实现中，对于给定的 $N$，使用 `scipy.special.legendre` 获得多项式 $P_N(x)$，计算其导数 $P_N'(x)$，并通过求解其根来找到内部节点。然后添加端点。权重使用上述公式计算，其中 $P_N(x_i)$ 使用 `scipy.special.eval_legendre` 进行求值。\n\n2.  **离散勒让德变换**\n\n    给定一个在 LGL 节点上采样的函数 $u(x)$，其值为 $\\{u_i = u(x_i)\\}_{i=0}^{N}$，其在勒让德基下的表示可以被近似。 $u(x)$ 的展开式为 $u(x) = \\sum_{k=0}^{\\infty} \\hat{u}_k P_k(x)$，其中连续勒让德系数由投影给出：\n    $$\\hat{u}_k = \\frac{\\int_{-1}^{1} u(x) P_k(x) \\, dx}{\\int_{-1}^{1} P_k(x)^2 \\, dx} = \\frac{2k+1}{2} \\int_{-1}^{1} u(x) P_k(x) \\, dx$$\n    问题通过用 LGL 求积和替换积分来定义离散勒让德系数（此处记为 $a_k$）：\n    $$a_k = \\frac{2k+1}{2} \\sum_{i=0}^{N} w_i \\, u_i \\, P_k(x_i), \\quad k = 0, 1, \\dots, N$$\n    这实际上是一个离散勒让德变换。对于从 $0$ 到 $N$ 的每个模态 $k$，通过在 LGL 节点 $\\{x_i\\}$ 上采样 $P_k(x)$ 的值来应用此公式。\n\n3.  **模态衰减指示器 $S$**\n\n    模态系数 $\\{a_k\\}$ 的衰减率提供了关于函数 $u(x)$ 平滑度的信息。平滑函数的系数随着 $k$ 的增加而迅速衰减，而具有不连续性或尖锐特征的函数则表现出缓慢的衰减，这意味着高频模态中存在显著的能量。\n\n    模态能量定义为 $E_k = a_k^2$。传感器通过计算最高阶模态的能量与总能量的比率来量化衰减率。使用正则化比率 $R_{\\mathrm{reg}}$：\n    $$R_{\\mathrm{reg}} = \\frac{\\sum_{k=N-r+1}^{N} E_k + \\varepsilon}{\\sum_{k=0}^{N} E_k + \\varepsilon}$$\n    在这里，$r$ 定义了最高阶模态的一个小窗口（例如，$r=3$），$\\varepsilon$ 是一个小的正则化参数（给定为 $10^{-30}$），用于在函数恒为零时防止除以零。\n\n    最终的指示器 $S$ 是该比率的以 10 为底的对数：\n    $$S = \\log_{10} (R_{\\mathrm{reg}})$$\n    - 对于平滑函数，高阶模态能量 $\\sum_{k=N-r+1}^{N} E_k$ 非常小，导致 $R_{\\mathrm{reg}}$ 很小，而 $S$ 为一个绝对值很大的负数。\n    - 对于非平滑函数，高阶模态能量很显著，使得 $R_{\\mathrm{reg}}$ 更大（接近于 $1$），而 $S$ 的负值更小（接近于 $0$）。\n\n4.  **人工黏性触发器 $\\nu$**\n\n    指示器 $S$ 用于控制应用于单元的人工黏性量 $\\nu$。采用一个简单的阈值斜坡函数。给定阈值 $s_0$、斜坡宽度 $\\Delta s$ 和最大黏性 $\\nu_{\\max}$：\n    $$\n    \\nu =\n    \\begin{cases}\n    0,  S \\le s_0, \\\\\n    \\nu_{\\max} \\, \\min\\left(1, \\dfrac{S - s_0}{\\Delta s}\\right),  S > s_0.\n    \\end{cases}\n    $$\n    如果指示器 $S$ 低于阈值 $s_0$（表示解是平滑的），则不添加黏性（$\\nu=0$）。如果 $S$ 超过阈值，则激活黏性。当 $S$ 从 $s_0$ 增加到 $s_0 + \\Delta s$ 时，黏性从 $0$ 线性增加到 $\\nu_{\\max}$，并且对于 $S \\ge s_0 + \\Delta s$ 的情况，黏性被限制在 $\\nu_{\\max}$。这将黏性局部化到失去平滑性的单元。\n\n5.  **测试套件与评估**\n\n    该算法被应用于一组具有不同平滑特性的测试函数，以验证其选择性：\n    - 情况 A：$u(x) = \\sin(5x)$ 是一个平滑（$C^{\\infty}$）函数。预期：$\\nu=0$。\n    - 情况 B：$u(x) = \\mathrm{sign}(x)$ 在 $x=0$ 处有跳跃不连续点。预期：$\\nu  0$。\n    - 情况 C：$u(x) = |x|$ 在 $x=0$ 处有一个尖点（是 $C^0$ 但不是 $C^1$）。预期：$\\nu  0$。\n    - 情况 D：$u(x) = \\mathrm{sign}(x)$，使用较低的多项式阶数 $N$。在较粗的分辨率下测试其行为。预期：$\\nu  0$。\n    - 情况 E：$u(x) = \\tanh(20x)$ 是一个陡峭但技术上平滑（$C^{\\infty}$）的函数，模拟一个激波层。预期：$\\nu  0$。\n\n    对于每种情况，报告布尔指示器 $\\mathbf{1}_{\\{\\nu0\\}}$ 和计算出的黏性值 $\\nu$（四舍五入到六位小数）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, eval_legendre\n\ndef solve():\n    \"\"\"\n    Implements and tests a one-dimensional shock sensor based on modal decay.\n    \"\"\"\n    \n    # Define fixed parameters from the problem statement.\n    r_fixed = 3\n    epsilon = 1e-30\n    s0 = -2.25\n    delta_s = 0.75\n    nu_max = 0.2\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (smooth)\n        (21, lambda x: np.sin(5 * x)),\n        # Case B (discontinuous jump)\n        (21, lambda x: np.sign(x)),\n        # Case C (cusp)\n        (21, lambda x: np.abs(x)),\n        # Case D (low-order jump)\n        (7, lambda x: np.sign(x)),\n        # Case E (steep but continuous)\n        (21, lambda x: np.tanh(20 * x)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, u_func = case\n        \n        # 1. Construct LGL nodes and weights for degree N.\n        #    The N+1 LGL nodes on [-1, 1] are the endpoints {-1, 1} and the\n        #    N-1 roots of P_N'(x), where P_N is the Legendre polynomial.\n        if N == 0:\n            # Trivial case, not used in tests, but for completeness.\n            nodes = np.array([-1.0])\n            weights = np.array([2.0])\n        elif N == 1:\n            nodes = np.array([-1.0, 1.0])\n            weights = np.array([1.0, 1.0])\n        else:\n            poly_N = legendre(N)\n            poly_N_prime = poly_N.deriv()\n            interior_nodes = np.sort(poly_N_prime.roots.real) # Use real part for robustness\n            nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n            \n            # The weights are given by w_i = 2 / (N*(N+1)*[P_N(x_i)]^2)\n            weights = 2.0 / (N * (N + 1) * (eval_legendre(N, nodes))**2)\n            \n        # 2. Compute discrete Legendre coefficients {a_k}.\n        #    a_k = (2k+1)/2 * sum(w_i * u(x_i) * P_k(x_i))\n        u_samples = u_func(nodes)\n        \n        a_k = np.zeros(N + 1)\n        for k in range(N + 1):\n            P_k_at_nodes = eval_legendre(k, nodes)\n            integral_approx = np.sum(weights * u_samples * P_k_at_nodes)\n            a_k[k] = (2 * k + 1) / 2.0 * integral_approx\n\n        # 3. Compute modal decay indicator S.\n        E_k = a_k**2\n        E_total = np.sum(E_k)\n        \n        # Use r = min(r_fixed, N) as specified for smaller N\n        r = min(r_fixed, N if N > 0 else 0)\n        \n        # Sum of high-mode energies (from k=N-r+1 to N)\n        if N > 0 and r > 0:\n            E_high = np.sum(E_k[N - r + 1:])\n        else:\n            E_high = 0.0\n            \n        # Regularized ratio and indicator S\n        R_reg = (E_high + epsilon) / (E_total + epsilon)\n        S = np.log10(R_reg)\n        \n        # 4. Compute artificial viscosity nu.\n        nu = 0.0\n        if S > s0:\n            nu = nu_max * min(1.0, (S - s0) / delta_s)\n        \n        # 5. Store results for this case.\n        triggered = nu > 0.0\n        nu_rounded = round(nu, 6)\n        \n        results.append(triggered)\n        results.append(nu_rounded)\n\n    # Final print statement in the exact required format.\n    # The map to str correctly handles Boolean and float values.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}