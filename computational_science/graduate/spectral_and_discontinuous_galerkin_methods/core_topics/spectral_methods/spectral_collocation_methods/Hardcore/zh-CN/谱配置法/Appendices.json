{
    "hands_on_practices": [
        {
            "introduction": "谱配置方法的一个核心挑战在于处理非线性项。当我们在网格上表示函数乘积时，其多项式插值结果并不等于真实乘积的插值，这种现象称为“混叠误差”。本练习  提供了一个具体的解析实例，通过使用切比雪夫多项式，揭示了高频信息如何“混叠”或伪装成低频信息。理解这一现象对于分析谱方法在求解非线性问题时的行为至关重要。",
            "id": "3416558",
            "problem": "考虑在区间 $[-1,1]$ 上由 $T_{n}(x) = \\cos(n \\arccos x)$ 定义的第一类切比雪夫多项式。令切比雪夫-洛巴托节点为 $x_{j} = \\cos\\left(\\frac{\\pi j}{N}\\right)$（其中 $j = 0,1,\\dots,N$），并定义插值算子 $\\mathcal{I}_{N}$ 为在这些节点上对给定函数进行插值的次数最多为 $N$ 的唯一多项式。设加权内积由下式给出：\n$$\\langle f,g\\rangle_{w} = \\int_{-1}^{1} f(x)\\,g(x)\\,\\frac{1}{\\sqrt{1-x^{2}}}\\,dx,$$\n其关联的加权 $L^{2}$ 范数为 $\\|f\\|_{w} = \\sqrt{\\langle f,f\\rangle_{w}}$。记 $\\mathcal{P}_{N}$ 为到次数最多为 $N$ 的多项式空间上的正交投影（关于内积 $\\langle\\cdot,\\cdot\\rangle_{w}$）。\n\n令 $u(x) = T_{6}(x)$ 和 $v(x) = T_{7}(x)$ 在 $[-1,1]$ 上，并设 $N=8$。定义 $w(x)=u(x)v(x)$。仅使用基本恒等式和定义，完成以下任务：\n- 推导 $w(x)$ 的显式切比雪夫基表示。\n- 通过分析切比雪夫多项式在切比雪夫-洛巴托网格 $\\{x_{j}\\}_{j=0}^{8}$ 上的采样行为，确定混淆节点乘积 $\\mathcal{I}_{8}(w)$。\n- 确定精确正交投影 $\\mathcal{P}_{8}(w)$。\n- 计算加权 $L^{2}$ 范数 $\\|\\mathcal{I}_{8}(w) - \\mathcal{P}_{8}(w)\\|_{w}$。\n\n请以单一的精确解析表达式形式给出最终答案。请勿对答案进行四舍五入。",
            "solution": "该问题要求计算特定函数 $w(x)$ 的插值多项式与正交投影之差的加权 $L^{2}$ 范数。我们将通过分步确定每个所需量来解决此问题。\n\n首先，我们建立函数 $w(x)$ 的显式切比雪夫基表示。该函数定义为 $u(x) = T_{6}(x)$ 和 $v(x) = T_{7}(x)$ 的乘积，其中 $T_{n}(x)$ 是次数为 $n$ 的第一类切比雪夫多项式。\n$$w(x) = u(x)v(x) = T_{6}(x)T_{7}(x)$$\n我们使用切比雪夫多项式的标准积化和差恒等式，该恒等式指出，对于任意非负整数 $m$ 和 $n$：\n$$T_{m}(x)T_{n}(x) = \\frac{1}{2}\\left(T_{m+n}(x) + T_{|m-n|}(x)\\right)$$\n将此恒等式应用于 $m=7$ 和 $n=6$，我们得到 $w(x)$ 的表达式：\n$$w(x) = T_{7}(x)T_{6}(x) = \\frac{1}{2}\\left(T_{7+6}(x) + T_{7-6}(x)\\right) = \\frac{1}{2}T_{13}(x) + \\frac{1}{2}T_{1}(x)$$\n这是 $w(x)$ 在切比雪夫基中的展开式。$w(x)$ 的次数为 $13$。\n\n其次，我们确定混淆节点乘积 $\\mathcal{I}_{8}(w)$。这是在 $N+1=9$ 个切比雪夫-洛巴托节点 $x_{j} = \\cos\\left(\\frac{\\pi j}{N}\\right) = \\cos\\left(\\frac{\\pi j}{8}\\right)$（其中 $j = 0, 1, \\dots, 8$）上对 $w(x)$ 进行插值的次数最多为 $N=8$ 的唯一多项式。插值算子 $\\mathcal{I}_{N}$ 是线性的。\n$$\\mathcal{I}_{8}(w) = \\mathcal{I}_{8}\\left(\\frac{1}{2}T_{13}(x) + \\frac{1}{2}T_{1}(x)\\right) = \\frac{1}{2}\\mathcal{I}_{8}(T_{13}) + \\frac{1}{2}\\mathcal{I}_{8}(T_{1})$$\n对于项 $T_{1}(x)$，其次数为 $1$，小于或等于 $N=8$。一个次数最多为 $N$ 的多项式，其自身的次数最多为 $N$ 的插值多项式就是它本身。因此，$\\mathcal{I}_{8}(T_{1}) = T_{1}(x)$。\n对于项 $T_{13}(x)$，其次数 $13$ 大于 $N=8$，因此会发生混淆。在切比雪夫-洛巴托网格 $\\{x_{j}\\}_{j=0}^{N}$ 上，当 $k$ 在范围 $N  < k  < 2N$ 内时，$T_{k}(x)$ 的值与 $T_{2N-k}(x)$ 的值相同。对于 $k=13$ 和 $N=8$，我们有 $8  < 13  < 16$。混淆恒等式为：\n$$T_{13}(x_{j}) = T_{13}\\left(\\cos\\left(\\frac{\\pi j}{8}\\right)\\right) = \\cos\\left(\\frac{13\\pi j}{8}\\right) = \\cos\\left(\\frac{(16-3)\\pi j}{8}\\right) = \\cos\\left(2\\pi j - \\frac{3\\pi j}{8}\\right) = \\cos\\left(\\frac{3\\pi j}{8}\\right) = T_{3}(x_{j})$$\n这对所有 $j=0, 1, \\dots, 8$ 都成立。因此，对节点值 $\\{T_{13}(x_j)\\}_{j=0}^8$ 进行插值的次数最多为 $8$ 的唯一多项式是 $T_{3}(x)$，因为其次数为 $3 \\leq 8$。所以，$\\mathcal{I}_{8}(T_{13}) = T_{3}(x)$。\n结合这些结果，混淆乘积为：\n$$\\mathcal{I}_{8}(w)(x) = \\frac{1}{2}T_{3}(x) + \\frac{1}{2}T_{1}(x)$$\n\n第三，我们确定精确正交投影 $\\mathcal{P}_{8}(w)$。这是 $w(x)$ 在加权 $L^{2}$ 范数意义下，从次数最多为 $N=8$ 的多项式空间（我们记为 $\\mathbb{P}_{8}$）中的最佳逼近。一个具有切比雪夫级数展开式 $f(x) = \\sum_{k=0}^{\\infty} a_{k}T_{k}(x)$ 的函数 $f(x)$，其到 $\\mathbb{P}_{N}$ 上的正交投影由截断级数 $\\mathcal{P}_{N}(f)(x) = \\sum_{k=0}^{N} a_{k}T_{k}(x)$ 给出。\n$w(x)$ 的切比雪夫展开式为 $w(x) = \\frac{1}{2}T_{1}(x) + \\frac{1}{2}T_{13}(x)$。将此级数在次数 $N=8$ 处截断，意味着我们只保留指数 $k \\le 8$ 的项。\n$$\\mathcal{P}_{8}(w)(x) = \\frac{1}{2}T_{1}(x)$$\n包含 $T_{13}(x)$ 的项被省略，因为 $13 > 8$。这是切比雪夫多项式关于内积 $\\langle\\cdot,\\cdot\\rangle_{w}$ 正交性的一个推论，它意味着对于所有 $k \\leq 12$（特别是对于 $k \\leq 8$），都有 $\\langle T_{13}, T_{k} \\rangle_{w} = 0$。\n\n第四，我们计算差的范数 $\\|\\mathcal{I}_{8}(w) - \\mathcal{P}_{8}(w)\\|_{w}$。插值多项式与投影之间的差为：\n$$\\mathcal{I}_{8}(w)(x) - \\mathcal{P}_{8}(w)(x) = \\left(\\frac{1}{2}T_{3}(x) + \\frac{1}{2}T_{1}(x)\\right) - \\frac{1}{2}T_{1}(x) = \\frac{1}{2}T_{3}(x)$$\n所求范数为 $\\|\\frac{1}{2}T_{3}(x)\\|_{w}$。利用范数的性质，这等于 $\\frac{1}{2}\\|T_{3}(x)\\|_{w}$。范数的平方 $\\|T_{n}\\|_{w}^{2}$ 由内积 $\\langle T_{n}, T_{n} \\rangle_{w}$ 定义。我们使用换元法 $x=\\cos(\\theta)$ 来计算该积分：\n$$ \\langle T_{n}, T_{n} \\rangle_{w} = \\int_{-1}^{1} T_{n}(x)^{2}\\,\\frac{1}{\\sqrt{1-x^{2}}}\\,dx = \\int_{\\pi}^{0} \\cos^{2}(n\\theta) \\frac{1}{\\sin(\\theta)} (-\\sin(\\theta)d\\theta) = \\int_{0}^{\\pi} \\cos^{2}(n\\theta) d\\theta$$\n对于 $n > 0$，此积分计算结果为：\n$$ \\int_{0}^{\\pi} \\frac{1+\\cos(2n\\theta)}{2} d\\theta = \\left[\\frac{\\theta}{2} + \\frac{\\sin(2n\\theta)}{4n}\\right]_{0}^{\\pi} = \\frac{\\pi}{2} $$\n对于 $n=3$，我们有 $\\|T_{3}\\|_{w}^{2} = \\langle T_{3}, T_{3} \\rangle_{w} = \\frac{\\pi}{2}$。\n因此，范数为 $\\|T_{3}\\|_{w} = \\sqrt{\\frac{\\pi}{2}}$。\n最后，差的范数为：\n$$\\|\\mathcal{I}_{8}(w) - \\mathcal{P}_{8}(w)\\|_{w} = \\frac{1}{2}\\|T_{3}\\|_{w} = \\frac{1}{2}\\sqrt{\\frac{\\pi}{2}} = \\frac{\\sqrt{\\pi}}{2\\sqrt{2}} = \\frac{\\sqrt{2\\pi}}{4}$$",
            "answer": "$$\\boxed{\\frac{\\sqrt{2\\pi}}{4}}$$"
        },
        {
            "introduction": "在理解了谱方法的一种基本误差来源后，我们将转向构建求解器的核心部分——离散算子。本实践  对比了两种离散化微分算子的常用方法：强形式和弱形式（或保守形式）。通过编程实现这两种形式并测试它们的性质，您将亲手发现为何弱形式因其固有的对称性而通常更受青睐，以及这种性质如何依赖于求积规则，这对于构建稳健的数值格式是至关重要的一课。",
            "id": "3416617",
            "problem": "考虑区间 $[-1,1]$ 上的守恒形式一维二阶椭圆算子，其齐次 Dirichlet 边界条件由以下微分方程定义\n$$\n-(a(x)\\, u_x)_x = f(x), \\quad x \\in [-1,1], \\quad u(-1)=u(1)=0,\n$$\n其中 $a(x)$ 是 $[-1,1]$ 上的严格正函数，$u(x)$ 是未知解。在使用 Legendre–Gauss–Lobatto (LGL) 点的谱配点法中，令 $N$ 表示全局插值多项式的阶数，$N+1$ 为 LGL 节点的数量，$x_j$ 为 LGL 节点，$w_j$ 为相应的 LGL 求积权重，$D$ 为作用于节点值上的 LGL 微分矩阵。在离散 $L^2$ 内积下保持对称性的离散守恒弱形式刚度矩阵为\n$$\nK = D_{AI}^\\top W A D_{AI},\n$$\n其中 $A=\\mathrm{diag}(a(x_j))$，$W=\\mathrm{diag}(w_j)$，而 $D_{AI}$ 表示 $D$ 中对应于内部自由度的列（为施加齐次 Dirichlet 边界条件，排除了端点）。通过对节点乘积 $(a u_x)$ 求导得到的强形式配点矩阵是\n$$\nL_c = -\\left[ D\\, A\\, D \\right]_{II},\n$$\n即 $-D A D$ 的内部-内部子矩阵，它在内部节点上施加算子。\n\n从以下基本原理出发：\n- 在 LGL 点上的 Lagrange 插值定义及其对多项式的精确性性质。\n- 具有 $N+1$ 个节点的 LGL 求积能精确积分最高为 $2N-1$ 阶的任何多项式的性质。\n- Legendre 多项式的定义及其在构造 LGL 节点中的作用。\n- 通过分部积分推导出的标准离散弱形式，当 $a(x)>0$ 时，其产生一个对称正定的双线性形式。\n\n您的任务是：\n- 从第一性原理出发，推导求积被积函数所需的精确性，以使离散弱形式配点刚度矩阵 $K$ 与精确的 Galerkin 刚度矩阵一致，并且是对称正定（SPD）的。将此精确性表示为关于 $a(x)$ 相对于 $N$ 的多项式阶数的条件。\n- 实现一个程序，对于给定的 $N$，构造 LGL 节点、权重和微分矩阵，为指定的 $a(x)$ 构建 $K$ 和 $L_c$，并通过移除边界自由度来检查在齐次 Dirichlet 边界条件下每个矩阵的对称性和正定性。\n- 在强形式配点 $L_c$ 中，当所选多项式阶数 $N$ 对 $a(x)$ 分辨不足时，识别并测试失效情况。对于任何三角函数（如 $\\cos$），请使用弧度单位。\n\n使用以下参数集 $(N, a(x), p)$ 的测试套件，其中 $p$ 在适用时为 $a(x)$ 的多项式阶数，否则设置为表示非多项式的特殊标记：\n- 案例 1：$N=8$, $a(x)=1.2 + x$, $p=1$。\n- 案例 2：$N=8$, $a(x)=1 + x^2$, $p=2$。\n- 案例 3：$N=12$, $a(x)=1 + 0.5\\cos(10 x)$ (使用弧度)，$p$ 为非多项式。\n- 案例 4：$N=8$, $a(x)=1 + 0.9\\cos(20 x)$ (使用弧度)，$p$ 为非多项式。\n\n对于每个案例，您的程序必须计算并返回一个包含五个值的列表：\n- 一个布尔值，指示 $K$ 是否对称。\n- 一个布尔值，指示 $K$ 是否对称正定（SPD）。\n- 一个布尔值，指示 $L_c$ 是否对称。\n- 一个布尔值，指示 $L_c$ 是否对称正定（SPD）。\n- 一个布尔值，指示为 $K$ 推导的求积精确性条件是否满足，即被积函数的阶数是否最多为 $2N-1$（对于非多项式的 $a(x)$，必须返回布尔值“不满足”）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个条目对应一个测试案例，并且本身是按上述顺序排列的五个布尔值的列表。例如，一个包含按指定顺序排列的四个测试案例的输出行应如下所示\n$$\n[\\,[b_{11},b_{12},b_{13},b_{14},b_{15}],\\,[b_{21},b_{22},b_{23},b_{24},b_{25}],\\,[b_{31},b_{32},b_{33},b_{34},b_{35}],\\,[b_{41},b_{42},b_{43},b_{44},b_{45}]\\,]\n$$\n其中每个 $b_{ij}$ 均为字面量 $\\texttt{True}$ 或 $\\texttt{False}$。",
            "solution": "### 解答与推导\n\n#### 第 1 部分：$K$ 的求积精确性条件推导\n\n微分方程的连续弱形式是通过乘以来自一个合适空间（此处为 $H_0^1(-1,1)$）的测试函数 $v(x)$ 并对定义域 $[-1,1]$ 进行积分得到的。\n$$ \\int_{-1}^{1} -(a(x) u_x(x))_x v(x) \\, dx = \\int_{-1}^{1} f(x) v(x) \\, dx $$\n对左侧进行分部积分可得：\n$$ \\left[-a(x) u_x(x) v(x)\\right]_{-1}^{1} + \\int_{-1}^{1} a(x) u_x(x) v_x(x) \\, dx = \\int_{-1}^{1} f(x) v(x) \\, dx $$\n考虑到解空间的齐次 Dirichlet 边界条件（$u(-1)=u(1)=0$，并且我们选择测试函数 $v$ 使得 $v(-1)=v(1)=0$），边界项消失。这给出了 Galerkin 方法的双线性形式：\n$$ B(u, v) = \\int_{-1}^{1} a(x) u_x(x) v_x(x) \\, dx $$\n精确的 Galerkin 刚度矩阵项为 $K_{ij}^{\\text{Galerkin}} = B(\\phi_j, \\phi_i)$，其中 $\\{\\phi_i\\}$是一组基函数。在配点法的背景下，我们使用 Lagrange 多项式 $\\ell_j(x)$ 作为基。由于齐次边界条件，我们只考虑对应于内部节点的基函数，即 $i, j \\in \\{1, \\dots, N-1\\}$。\n$$ K_{ij}^{\\text{Galerkin}} = \\int_{-1}^{1} a(x) \\ell'_j(x) \\ell'_i(x) \\, dx $$\n离散弱形式刚度矩阵 $K = D_{AI}^\\top W A D_{AI}$ 是通过使用 LGL 求积来近似积分 $B(u,v)$ 得到的。$B(u,v)$ 的求积近似为：\n$$ B(u,v) \\approx \\sum_{k=0}^{N} w_k a(x_k) u_x(x_k) v_x(x_k) = (\\mathbf{u}_x)^\\top W A \\mathbf{v}_x $$\n其中 $\\mathbf{u}_x$ 和 $\\mathbf{v}_x$ 是在所有 LGL 节点上导数值的向量。这些导数是通过微分矩阵块 $D_{AI}$ 从内部节点值 $\\mathbf{u}_I$ 和 $\\mathbf{v}_I$ 获得的：$\\mathbf{u}_x = D_{AI} \\mathbf{u}_I$ 且 $\\mathbf{v}_x = D_{AI} \\mathbf{v}_I$。将这些代入求积和中，得到与矩阵 $K$ 对应的二次型：\n$$ \\mathbf{v}_I^\\top (D_{AI}^\\top W A D_{AI}) \\mathbf{u}_I = \\mathbf{v}_I^\\top K \\mathbf{u}_I $$\n当且仅当 LGL 求积法则对被积函数 $I(x) = a(x) \\ell'_j(x) \\ell'_i(x)$ 精确时，离散矩阵 $K$ 才与精确的 Galerkin 矩阵 $K^{\\text{Galerkin}}$ 一致。\n与 $N+1$ 个 LGL 节点相关联的 Lagrange 基多项式 $\\ell_j(x)$ 的阶数为 $N$。它们的导数 $\\ell'_j(x)$ 是 $N-1$ 阶的多项式。因此，乘积 $\\ell'_j(x) \\ell'_i(x)$ 是一个最高阶为 $(N-1) + (N-1) = 2N-2$ 的多项式。\n令 $p$ 为系数函数 $a(x)$ 的多项式阶数。被积函数的总阶数为 $\\deg(I(x)) = p + 2N-2$。\n具有 $N+1$ 个节点的 LGL 求积对最高为 $2N-1$ 阶的任何多项式都是精确的。为使求积精确，我们必须有：\n$$ \\deg(I(x)) \\le 2N-1 $$\n$$ p + 2N-2 \\le 2N-1 $$\n$$ p \\le 1 $$\n因此，当且仅当 $a(x)$ 是一个最高阶为 1 的多项式时，离散弱形式矩阵 $K$ 才与精确的 Galerkin 矩阵完全相同。\n\n#### 第 2 部分：$K$ 和 $L_c$ 的性质\n\n**$K$ 的对称性与正定性**：\n矩阵 $K = D_{AI}^\\top W A D_{AI}$ 总是对称的。矩阵 $W$ 和 $A$ 是对角矩阵，因此是对称的。\n$$ K^\\top = (D_{AI}^\\top W A D_{AI})^\\top = D_{AI}^\\top A^\\top W^\\top (D_{AI}^\\top)^\\top = D_{AI}^\\top A W D_{AI} $$\n由于对角矩阵可交换，所以 $AW=WA$，因此 $K^\\top = D_{AI}^\\top W A D_{AI} = K$。\n为检验正定性，考虑对于任意非零向量 $\\mathbf{v} \\in \\mathbb{R}^{N-1}$ 的二次型：\n$$ \\mathbf{v}^\\top K \\mathbf{v} = \\mathbf{v}^\\top D_{AI}^\\top W A D_{AI} \\mathbf{v} = (D_{AI}\\mathbf{v})^\\top W A (D_{AI}\\mathbf{v}) $$\n令 $\\mathbf{y} = D_{AI}\\mathbf{v}$。这是一个多项式在所有节点上的导数向量，该多项式在内部节点上的值为 $\\mathbf{v}$，在边界上为零。二次型为 $\\sum_{j=0}^{N} w_j a(x_j) y_j^2$。由于 LGL 权重 $w_j$ 是正的，且 $a(x)$ 是严格正的，所以所有 $a(x_j)>0$。除非所有 $y_j=0$，否则该和为正。如果 $\\mathbf{y}=0$，则导数多项式在所有 $N+1$ 个节点上都为零。由于该导数是 $N-1$ 阶的，它必须恒等于零。这意味着该多项式本身是一个常数。由于它在边界处为零，它必须是零多项式。这意味着其内部节点值 $\\mathbf{v}$ 必须为零。因此，对于 $\\mathbf{v} \\neq 0$，有 $\\mathbf{v}^\\top K \\mathbf{v} > 0$。\n结论：对于任何严格正的系数函数 $a(x)$，$K$ 都是对称正定（SPD）的，这与求积精确性条件无关。条件 $p \\le 1$ 确保了与*连续* Galerkin 公式的等价性，而不是*离散*系统的 SPD 性质。\n\n**$L_c$ 的对称性与正定性**：\n强形式矩阵为 $L_c = -[DAD]_{II}$。一般而言，完整的 LGL 微分矩阵 $D$ 不是对称的。因此，乘积 $DAD$ 预计不是对称的，其子矩阵 $L_c$ 也不是。一个矩阵必须是对称的，才能被归类为对称正定。因此，我们预计 $L_c$ 在一般情况下既不是对称的，也不是 SPD 的。非对称性是强形式配点法在构造不仔细时的一个已知缺点。对于非常数 $a(x)$，对称性的失效是其与弱形式矩阵 $K$ 的一个关键区别。任何对 $a(x)$ 的分辨不足（如案例 4），都将导致对算子的不良近似，但即使对于分辨良好、非常数的 $a(x)$，也存在根本性的非对称性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_lgl(N):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes, weights, and \n    differentiation matrix for a given polynomial degree N.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The LGL nodes (x).\n            - np.ndarray: The LGL weights (w).\n            - np.ndarray: The LGL differentiation matrix (D).\n    \"\"\"\n    if N  <= 1:\n        raise ValueError(\"N must be at least 1.\")\n    \n    # N+1 points, degree N polynomial\n    # Interior nodes are roots of P_N'(x)\n    PN = legendre(N)\n    PN_deriv = PN.deriv(1)\n    # The .roots method on a scipy orthopoly1d object finds the roots.\n    interior_nodes = np.sort(PN_deriv.roots)\n\n    x = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights formula: w_j = 2 / (N(N+1) [P_N(x_j)]^2)\n    PN_vals_at_nodes = PN(x)\n    w = 2.0 / (N * (N + 1) * PN_vals_at_nodes**2)\n    \n    # Differentiation matrix D formula\n    N_plus_1 = N + 1\n    D = np.zeros((N_plus_1, N_plus_1))\n\n    # Off-diagonal elements: D_ij = P_N(x_i) / (P_N(x_j) * (x_i - x_j)) for i != j\n    for i in range(N_plus_1):\n        for j in range(N_plus_1):\n            if i != j:\n                D[i, j] = PN_vals_at_nodes[i] / (PN_vals_at_nodes[j] * (x[i] - x[j]))\n    \n    # Diagonal elements\n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    for i in range(1, N):\n        D[i, i] = x[i] / (1.0 - x[i]**2)\n        \n    return x, w, D\n\ndef analyze_matrices(N, a_func, p):\n    \"\"\"\n    Constructs and analyzes matrices K and Lc for a given test case.\n\n    Args:\n        N (int): The polynomial degree.\n        a_func (callable): The function a(x).\n        p (int or str): The polynomial degree of a(x) or a nonpolynomial marker.\n\n    Returns:\n        list: A list of five boolean values:\n              [is_K_symmetric, is_K_spd, is_Lc_symmetric, is_Lc_spd, \n               is_quad_exactness_satisfied]\n    \"\"\"\n    x, w, D = get_lgl(N)\n    \n    a_vals = a_func(x)\n    if not np.all(a_vals > 0):\n        # This check is for robustness; problem statement guarantees a(x)>0\n        raise ValueError(\"a(x) must be strictly positive on [-1, 1].\")\n\n    A = np.diag(a_vals)\n    W = np.diag(w)\n    \n    # Interior indices are 1, ..., N-1. In Python slicing, this is 1:N\n    interior_slice = slice(1, N)\n    \n    # K = D_AI' * W * A * D_AI\n    # D_AI is the block of D with all rows and interior columns.\n    D_AI = D[:, interior_slice]\n    K = D_AI.T @ W @ A @ D_AI\n    \n    # Lc = -[D*A*D]_II\n    # [DAD]_II is the interior-interior block of the matrix D*A*D.\n    DAD = D @ A @ D\n    Lc = -DAD[interior_slice, interior_slice]\n    \n    tol = 1e-12\n    \n    # 1. Check if K is symmetric\n    is_K_symmetric = np.allclose(K, K.T, atol=tol)\n    \n    # 2. Check if K is SPD\n    is_K_spd = False\n    if is_K_symmetric:\n        try:\n            eigvals = np.linalg.eigvalsh(K)\n            is_K_spd = np.all(eigvals > tol)\n        except np.linalg.LinAlgError:\n            is_K_spd = False\n            \n    # 3. Check if Lc is symmetric\n    is_Lc_symmetric = np.allclose(Lc, Lc.T, atol=tol)\n    \n    # 4. Check if Lc is SPD (requires symmetry)\n    is_Lc_spd = False\n    if is_Lc_symmetric:\n        try:\n            eigvals = np.linalg.eigvalsh(Lc)\n            is_Lc_spd = np.all(eigvals > tol)\n        except np.linalg.LinAlgError:\n            is_Lc_spd = False\n\n    # 5. Check if quadrature exactness condition (p <= 1) is satisfied\n    is_quad_exactness_satisfied = (isinstance(p, int) and p <= 1)\n            \n    return [is_K_symmetric, is_K_spd, is_Lc_symmetric, is_Lc_spd, is_quad_exactness_satisfied]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=8, a(x)=1.2 + x, p=1\n        (8, lambda x: 1.2 + x, 1),\n        # Case 2: N=8, a(x)=1 + x^2, p=2\n        (8, lambda x: 1.0 + x**2, 2),\n        # Case 3: N=12, a(x)=1 + 0.5cos(10x), p=nonpolynomial\n        (12, lambda x: 1.0 + 0.5 * np.cos(10 * x), \"nonpolynomial\"),\n        # Case 4: N=8, a(x)=1 + 0.9cos(20x), p=nonpolynomial\n        (8, lambda x: 1.0 + 0.9 * np.cos(20 * x), \"nonpolynomial\"),\n    ]\n\n    results = []\n    for N, a_func, p in test_cases:\n        case_results = analyze_matrices(N, a_func, p)\n        results.append(case_results)\n\n    # Format the output as specified\n    # Using str() on Python booleans gives 'True' and 'False' literals,\n    # which is what the problem asks for.\n    result_str = ','.join([str(res).replace(\" \",\"\") for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将探讨应用谱方法时的一个常见挑战：吉布斯现象，它在逼近不连续函数时出现。这个动手编程练习  将演示一种强大的技术——模态滤波——来抑制这些伪振荡。您将实现从节点空间到系数（模态）空间的转换、应用滤波器，并转换回物理空间的完整工作流程，从而直观并定量地观察到滤波带来的改善。",
            "id": "3416563",
            "problem": "设 $N \\in \\mathbb{N}$，并考虑在区间 $[-1,1]$ 上的 Chebyshev–Gauss–Lobatto 配置，其节点为 $x_j = \\cos(\\pi j / N)$，其中 $j \\in \\{0,1,\\dots,N\\}$。定义在 $x=0$ 处有一个跳跃（间断点）的分段常数函数为\n$$\nu(x) = \\begin{cases}\n-1,  & x  < 0,\\\\\n0,  & x = 0,\\\\\n1,  & x > 0,\n\\end{cases}\n$$\n并令节点数据为 $u_j = u(x_j)$，对所有 $j \\in \\{0,1,\\dots,N\\}$ 成立，其中在 $x=0$ 处的值为跳跃点的平均值 $0$。在 Chebyshev 配置中，次数为 $N$ 的插值多项式 $p_N(x)$ 是满足 $p_N(x_j)=u_j$（对所有 $j \\in \\{0,1,\\dots,N\\}$）的唯一多项式。将 $p_N$ 在 Chebyshev 多项式基 $\\{T_k\\}_{k=0}^N$ 中表示为\n$$\np_N(x) = \\sum_{k=0}^{N} a_k T_k(x),\n$$\n其中 $T_k(x)$ 是第 $k$ 个第一类 Chebyshev 多项式，由 $T_0(x)=1$、$T_1(x)=x$ 和对所有 $k \\ge 1$ 成立的三项递推关系 $T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)$ 定义。\n\n你的任务是构造一个作用于 Chebyshev 系数 $\\{a_k\\}_{k=0}^N$ 的指数模态滤波器，并量化其对 $x=0$ 处间断点产生的 Gibbs 振荡的影响。该指数滤波器定义为\n$$\n\\sigma_k = \\exp\\!\\left(-\\alpha \\left(\\frac{k}{N}\\right)^{p}\\right), \\quad k \\in \\{0,1,\\dots,N\\},\n$$\n其中滤波器强度参数 $\\alpha \\ge 0$ 且阶数 $p \\in \\mathbb{N}$ 为偶数，滤波后的模态系数为 $\\tilde{a}_k = \\sigma_k a_k$。滤波后的多项式则为\n$$\n\\tilde{p}_N(x) = \\sum_{k=0}^{N} \\tilde{a}_k T_k(x).\n$$\n你的构造过程必须遵循以下步骤：将节点值 $\\{u_j\\}$ 变换为模态系数 $\\{a_k\\}$，在模态空间中应用滤波器 $\\{\\sigma_k\\}$，然后通过计算滤波后多项式的值，将其变换回节点空间或逐点求值。\n\n为量化对 Gibbs 振荡的影响，需在 $[-1,1]$ 区间内一个包含 $M$ 个点的密集等距网格上（其中 $M=5001$）计算 $p_N$ 和 $\\tilde{p}_N$ 的值，并按如下方式测量过冲幅度。定义\n$$\nA(q) = \\max\\!\\left\\{\\max_{x \\in [-1,1]} q(x) - 1,\\; -1 - \\min_{x \\in [-1,1]} q(x),\\; 0\\right\\}.\n$$\n这个量用于测量 $q(x)$ 超出平台水平 $\\pm 1$ 的最大偏移。计算比率\n$$\nR = \\frac{A(\\tilde{p}_N)}{A(p_N)}.\n$$\n$R=1$ 的值表示过冲没有减小，而 $R \\in (0,1)$ 表示有所减小。\n\n角度必须以弧度为单位进行解释。\n\n你的程序必须使用 Chebyshev 基 $\\{T_k\\}$ 和三项递推关系来实现从节点系数到模态系数的变换以及逆变换。然后，程序必须在密集网格上计算未滤波和已滤波的多项式，并为下面套件中的每个测试用例计算 $R$。不提供外部输入；所有参数都应硬编码。最终输出必须是单行文本，其中包含一个用方括号括起来的、以逗号分隔的比率 $R$ 列表。\n\n测试套件（每个测试用例是一个三元组 $(N,\\alpha,p)$）:\n- 情况 $1$: $(N,\\alpha,p) = (32, 0, 8)$.\n- 情况 $2$: $(N,\\alpha,p) = (32, 36, 8)$.\n- 情况 $3$: $(N,\\alpha,p) = (64, 36, 8)$.\n- 情况 $4$: $(N,\\alpha,p) = (64, 100, 16)$.\n- 情况 $5$: $(N,\\alpha,p) = (16, 36, 2)$.\n- 情况 $6$: $(N,\\alpha,p) = (8, 36, 8)$.\n\n最终输出格式：你的程序应生成单行输出，其中包含上述六种情况的比率 $R$ 的结果，以逗号分隔列表的形式呈现，四舍五入到八位小数，并用方括号括起来，例如\n$$\n[\\;r_1,\\;r_2,\\;r_3,\\;r_4,\\;r_5,\\;r_6\\;].\n$$",
            "solution": "求解过程遵循一系列离散且定义明确的步骤：\n1.  生成节点数据。\n2.  将节点数据转换为模态（Chebyshev）系数。\n3.  在模态空间中应用指数滤波器。\n4.  在精细网格上计算原始多项式和滤波后多项式的值。\n5.  量化 Gibbs 引起的过冲以及滤波器的有效性。\n\n下文将详细介绍每个步骤。\n\n首先，对于由参数三元组 $(N, \\alpha, p)$ 定义的每个测试用例，我们建立计算网格和数据。插值节点是 $N+1$ 个 Chebyshev-Gauss-Lobatto (CGL) 点，由 $x_j = \\cos(\\pi j / N)$ 给出，其中 $j \\in \\{0, 1, \\dots, N\\}$。待插值的函数是符号函数，经修改后在原点处为零：\n$$\nu(x) = \\begin{cases}\n-1,  & x  < 0,\\\\\n0,  & x = 0,\\\\\n1,  & x > 0.\n\\end{cases}\n$$\n节点数据 $\\{u_j\\}_{j=0}^N$ 是通过在 CGL 节点上计算该函数得到的，$u_j = u(x_j)$。注意，对于偶数 $N$，节点 $x_{N/2} = \\cos(\\pi/2) = 0$ 存在，因此 $u_{N/2}=0$。对于奇数 $N$，没有节点位于 $0$ 处，所以所有的 $u_j$ 要么是 $1$ 要么是 $-1$。\n\n其次，我们将节点数据 $\\{u_j\\}$ 转换为插值多项式 $p_N(x) = \\sum_{k=0}^N a_k T_k(x)$ 的模态系数 $\\{a_k\\}$，其中 $T_k(x)$ 是第 $k$ 个第一类 Chebyshev 多项式。对数据进行插值（即对所有 $j \\in \\{0, \\dots, N\\}$ 满足 $p_N(x_j) = u_j$）的、次数最多为 $N$ 的唯一多项式 $p_N(x)$，其 Chebyshev 系数由离散余弦变换给出：\n$$\na_k = \\frac{2}{N \\bar{c}_k} \\sum_{j=0}^{N} \\frac{u_j}{\\bar{c}_j} \\cos\\left(\\frac{\\pi j k}{N}\\right), \\quad k \\in \\{0, 1, \\dots, N\\},\n$$\n其中权重 $\\bar{c}_k$ 定义为 $\\bar{c}_0 = \\bar{c}_N = 2$ 且对 $j \\in \\{1, \\dots, N-1\\}$ 有 $\\bar{c}_j = 1$。此变换通过直接求和实现，其计算复杂度为 $O(N^2)$，对于测试套件中指定的 $N$ 值而言，该效率足够高。\n\n第三，应用指数模态滤波器。该滤波器由系数 $\\sigma_k = \\exp(-\\alpha (k/N)^p)$ 定义，其中 $\\alpha \\ge 0$ 是滤波器强度，$p$ 是其阶数。滤波操作是在模态（系数）空间中的简单逐元素乘积：滤波后的系数为 $\\tilde{a}_k = \\sigma_k a_k$。这些是滤波后多项式 $\\tilde{p}_N(x) = \\sum_{k=0}^N \\tilde{a}_k T_k(x)$ 的系数。$\\alpha=0$ 的情况对应于不进行滤波（所有 $k$ 的 $\\sigma_k=1$），用作基准。\n\n第四，在区间 $[-1, 1]$ 内一个包含 $M=5001$ 个点的密集等距网格上，计算未滤波多项式 $p_N(x)$ 和滤波后多项式 $\\tilde{p}_N(x)$ 的值。为了高效地执行此计算，我们构造一个 $M \\times (N+1)$ 的类 Vandermonde 矩阵 $V$，其中每个元素为 $V_{ik} = T_k(y_i)$，而 $\\{y_i\\}_{i=1}^M$ 是求值点。该矩阵的列是使用 Chebyshev 多项式的三项递推关系生成的：$T_0(x)=1$，$T_1(x)=x$ 和 $T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)$。多项式在网格上的值随后通过矩阵-向量乘积 $V \\cdot a$ 和 $V \\cdot \\tilde{a}$ 获得，其中 $a$ 和 $\\tilde{a}$ 是系数的列向量。\n\n最后，我们量化滤波器对 Gibbs 振荡的影响。多项式 $q(x)$ 的过冲幅度定义为\n$$\nA(q) = \\max\\!\\left\\{\\max_{x \\in [-1,1]} q(x) - 1, \\; -1 - \\min_{x \\in [-1,1]} q(x), \\; 0\\right\\},\n$$\n其中 $1$ 和 $-1$ 是原始函数 $u(x)$ 的平台值。此指标是使用密集求值网格上的数值最大值和最小值，为 $p_N(x)$ 和 $\\tilde{p}_N(x)$ 两者计算的。最终的性能度量是滤波后的过冲与未滤波过冲之比，$R = A(\\tilde{p}_N) / A(p_N)$。$R=1$ 的值意味着过冲没有减小，而 $R \\in [0,1)$ 表示成功抑制。为每个测试用例计算此比率，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of quantifying the effect of an exponential modal filter\n    on Gibbs oscillations in Chebyshev collocation.\n    \"\"\"\n    test_cases = [\n        (32, 0, 8),\n        (32, 36, 8),\n        (64, 36, 8),\n        (64, 100, 16),\n        (16, 36, 2),\n        (8, 36, 8),\n    ]\n\n    results = []\n    for N, alpha, p in test_cases:\n        # Step 1: Generate Nodal Data\n        # Chebyshev-Gauss-Lobatto nodes\n        j_nodes = np.arange(N + 1)\n        x_nodes = np.cos(np.pi * j_nodes / N)\n        \n        # Nodal values of the discontinuous function u(x)\n        # np.sign gives 1 for x>0, -1 for x<0, and 0 for x=0, which matches u(x).\n        u_nodes = np.sign(x_nodes)\n\n        # Step 2: Nodal to Modal Transform (Chebyshev Coefficients)\n        c_bar = np.ones(N + 1)\n        c_bar[0] = c_bar[N] = 2.0\n        \n        a_coeffs = np.zeros(N + 1)\n        u_weighted = u_nodes / c_bar\n        \n        # Direct summation based on the discrete cosine transform formula\n        for k in range(N + 1):\n            cos_terms = np.cos(np.pi * j_nodes * k / N)\n            sum_val = np.sum(u_weighted * cos_terms)\n            a_coeffs[k] = (2.0 / (N * c_bar[k])) * sum_val\n\n        # Step 3: Apply Exponential Modal Filter\n        k_vals = np.arange(N + 1)\n        sigma = np.exp(-alpha * (k_vals / N)**p)\n        a_tilde_coeffs = sigma * a_coeffs\n\n        # Step 4: Evaluate Polynomials on a Dense Grid\n        M = 5001\n        y_grid = np.linspace(-1.0, 1.0, M)\n        \n        # Build Vandermonde-like matrix of Chebyshev polynomials T_k(y)\n        T_matrix = np.zeros((M, N + 1))\n        T_matrix[:, 0] = 1.0\n        if N > 0:\n            T_matrix[:, 1] = y_grid\n        for k_idx in range(1, N):\n            T_matrix[:, k_idx + 1] = 2.0 * y_grid * T_matrix[:, k_idx] - T_matrix[:, k_idx - 1]\n            \n        p_N_vals = T_matrix @ a_coeffs\n        p_tilde_N_vals = T_matrix @ a_tilde_coeffs\n\n        # Step 5: Compute Overshoot Amplitude\n        def calculate_A(poly_vals):\n            \"\"\"Computes the overshoot amplitude A(q).\"\"\"\n            max_val = np.max(poly_vals)\n            min_val = np.min(poly_vals)\n            return np.max([max_val - 1.0, -1.0 - min_val, 0.0])\n            \n        A_p_N = calculate_A(p_N_vals)\n        A_p_tilde_N = calculate_A(p_tilde_N_vals)\n        \n        # Step 6: Compute the Ratio R\n        # Gibbs phenomenon ensures A_p_N > 0 for N > 0.\n        # If A_p_N were 0, R=1.0 is the logical choice for alpha=0,\n        # as there's no change.\n        if A_p_N == 0.0:\n            R = 1.0\n        else:\n            R = A_p_tilde_N / A_p_N\n            \n        results.append(f\"{R:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}