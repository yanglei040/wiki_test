{
    "hands_on_practices": [
        {
            "introduction": "To begin, we explore aliasing in its most classical setting: Fourier spectral methods on a periodic domain. In these methods, a pointwise multiplication in physical space corresponds to a convolution in Fourier space. This practice provides a direct, code-based experience of how nonlinear interactions can generate wavenumbers that exceed the grid's resolution, leading to \"wrap-around\" errors that contaminate the solution, and demonstrates how zero-padding provides a straightforward and effective remedy .",
            "id": "3374811",
            "problem": "Consider a one-dimensional periodic domain with angle coordinate $x \\in [0,2\\pi)$ measured in radians. Let $N$ denote an even integer number of equispaced collocation points, and let the maximum resolvable wavenumber be $k_{\\max} = N/2$. The discrete Fourier transform (DFT) of a $2\\pi$-periodic function sampled at $N$ points is interpreted in the symmetric wavenumber band $k \\in \\{-N/2,-N/2+1,\\dots,-1,0,1,\\dots,N/2-1\\}$. The Fast Fourier Transform (FFT) is used to compute these coefficients, with normalization chosen such that the discrete Fourier coefficient at wavenumber $k$ of the sampled mode $\\exp(i k x)$ has magnitude $1$.\n\nThe convolution theorem states that pointwise multiplication in physical space corresponds to convolution in Fourier space. For a quadratic nonlinearity $u(x)^2$, triad interactions produce Fourier content at the sum wavenumber $k = k_1 + k_2$ when $u(x)$ contains Fourier modes at $k_1$ and $k_2$. In discrete sampling with $N$ points, if $|k_1 + k_2| > k_{\\max}$, the high-frequency triad cannot be represented and aliases into the lower band via modular wrap-around. Define the symmetric wrap operator\n$$\n\\operatorname{wrap}(k;N) = \\left(\\left(k + \\frac{N}{2}\\right) \\bmod N\\right) - \\frac{N}{2},\n$$\nwhich maps any integer $k$ into the band $[-N/2, N/2-1]$. The aliased wavenumber generated by a triad at $k = k_1 + k_2$ is therefore $k_{\\text{alias}} = \\operatorname{wrap}(k_1 + k_2; N)$ when $|k_1 + k_2| > k_{\\max}$.\n\nA standard dealiasing strategy is padding and truncation: compute the nonlinearity on a refined grid with $M = 2N$ points (padding), transform to Fourier space, and then set to zero (truncate) all Fourier coefficients with $|k| > k_{\\max}$ before mapping back to the original $N$-point representation. For quadratic nonlinearities, this padding level eliminates spurious aliasing (the so-called $3/2$-rule is sufficient, and $2N$ is more than sufficient).\n\nYour task is to implement a program that:\n- Constructs complex-valued signals $u(x) = \\exp(i k_1 x) + \\exp(i k_2 x)$ on grids of size $N$ and $M = 2N$.\n- Computes $f(x) = u(x)^2$ in physical space.\n- Computes the discrete Fourier coefficients $\\widehat{f}_N(k)$ via an $N$-point FFT with $1/N$ normalization, and $\\widehat{f}_M(k)$ via an $M$-point FFT with $1/M$ normalization.\n- For the unpadded computation, measures the magnitude $A_{\\text{np}}$ at $k_{\\text{alias}}$ when $|k_1 + k_2| > k_{\\max}$, or at $k_1 + k_2$ when $|k_1 + k_2| \\le k_{\\max}$.\n- For the padded-and-truncated computation, forms a truncated spectrum that keeps only modes with $|k| \\le k_{\\max}$ from $\\widehat{f}_M(k)$, measures the magnitude $A_{\\text{pad}}$ at the same target wavenumber (either $k_{\\text{alias}}$ if aliasing would occur for $N$, or $k_1 + k_2$ otherwise).\n- Decides, for each test case, a boolean result:\n  - If $|k_1 + k_2| > k_{\\max}$ (aliasing scenario), return $\\text{True}$ if $A_{\\text{pad}}  10^{-12}$ and $A_{\\text{np}}$ is within $10^{-12}$ of $2$, indicating that padding suppresses the spurious aliased triad while the unpadded computation exhibits it at the expected magnitude $2$.\n  - If $|k_1 + k_2| \\le k_{\\max}$ (non-alias scenario), return $\\text{True}$ if both $A_{\\text{np}}$ and $A_{\\text{pad}}$ are within $10^{-12}$ of $2$, indicating that padding preserves the correct triad magnitude.\n\nUse the following test suite to exercise different scenarios:\n- Case $1$ (happy path alias): $N = 32$, $k_1 = 12$, $k_2 = 10$ so that $k_1 + k_2 = 22$ and $k_{\\max} = 16$.\n- Case $2$ (near-boundary alias): $N = 32$, $k_1 = 9$, $k_2 = 8$ so that $k_1 + k_2 = 17$ and $k_{\\max} = 16$.\n- Case $3$ (negative-sum alias): $N = 32$, $k_1 = -15$, $k_2 = -5$ so that $k_1 + k_2 = -20$ and $k_{\\max} = 16$.\n- Case $4$ (no alias, preservation): $N = 48$, $k_1 = 7$, $k_2 = 8$ so that $k_1 + k_2 = 15$ and $k_{\\max} = 24$.\n\nAll angles are in radians. There are no physical units beyond this angle specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is a boolean adhering to the criteria above for the corresponding test case.",
            "solution": "This problem demonstrates the phenomenon of aliasing in Fourier pseudospectral methods and its correction via padding.\n\n1.  **Principle**: The core idea is that pointwise multiplication in physical space, such as computing $u(x)^2$, is equivalent to a convolution in Fourier space. This convolution generates new frequencies. For a signal $u(x)$ containing frequencies $k_1$ and $k_2$, the product $u(x)^2$ will contain frequencies at $2k_1$, $2k_2$, and $k_1+k_2$. On a discrete grid with $N$ points, only frequencies with magnitude up to a Nyquist limit, $k_{\\max} \\approx N/2$, can be represented.\n\n2.  **Aliasing Scenario**: When an interaction produces a frequency higher than the limit (i.e., $|k_1+k_2| > k_{\\max}$), the Discrete Fourier Transform (DFT) cannot represent this high frequency correctly. Instead, due to the periodic nature of the DFT, this energy \"wraps around\" and is incorrectly attributed to a lower-frequency mode within the representable range. This is aliasing. The code first performs an unpadded calculation on the $N$-point grid, demonstrating that a significant amplitude appears at the incorrect, aliased wavenumber $k_{\\text{alias}}$.\n\n3.  **Dealiasing Procedure**: The solution is to use a \"padding and truncation\" method.\n    -   **Padding**: The original signal's Fourier coefficients are placed in a larger array, with zeros \"padding\" the higher frequencies. An inverse transform then creates the signal $u(x)$ on a finer grid of $M$ points (here, $M=2N$). This finer grid has a higher Nyquist limit and can correctly represent the high-frequency product term at $k_1+k_2$.\n    -   **Multiplication**: The product $u(x)^2$ is computed on this fine grid.\n    -   **Truncation**: A forward transform is performed, and the resulting spectrum is truncated by setting all coefficients for frequencies $|k|>k_{\\max}$ to zero. This step effectively removes the high-frequency content that was unresolvable on the original grid.\n\n4.  **Verification**: The code verifies that after the dealiasing procedure, the energy at the aliased wavenumber $k_{\\text{alias}}$ is zero (to machine precision), confirming that the aliasing error has been eliminated. For non-aliasing cases where $|k_1+k_2| \\le k_{\\max}$, it confirms that the procedure correctly preserves the amplitude at the correct wavenumber, showing that dealiasing does not harm correctly resolved interactions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _wrap(k: int, N: int) - int:\n    \"\"\"\n    Computes the symmetric wrap-around for a wavenumber k on a grid of size N.\n    Maps k to the symmetric wavenumber band [-N/2, N/2 - 1].\n    \"\"\"\n    # The formula is ((k + N/2) mod N) - N/2.\n    # Python's % operator handles negative numbers in a way that is mathematically\n    # equivalent to floor-based modulo, which is what's required here.\n    return int(((k + N / 2) % N) - N / 2)\n\ndef _process_case(N: int, k1: int, k2: int) - bool:\n    \"\"\"\n    Processes a single test case to evaluate the dealiasing procedure.\n\n    Args:\n        N: The number of collocation points for the unpadded grid.\n        k1: Wavenumber of the first component of the signal u(x).\n        k2: Wavenumber of the second component of the signal u(x).\n\n    Returns:\n        A boolean indicating whether the dealiasing behavior meets the\n        problem's criteria.\n    \"\"\"\n    tol = 1.0e-12\n    M = 2 * N\n    k_max = N // 2\n    k_sum = k1 + k2\n\n    is_alias_scenario = abs(k_sum)  k_max\n\n    if is_alias_scenario:\n        # The wavenumber where the aliased a_np should appear.\n        k_target = _wrap(k_sum, N)\n    else:\n        # The wavenumber where the triad correctly appears.\n        k_target = k_sum\n\n    # --- 1. Unpadded Computation (N points) ---\n    x_N = 2 * np.pi * np.arange(N) / N\n    u_N = np.exp(1j * k1 * x_N) + np.exp(1j * k2 * x_N)\n    f_N = u_N**2\n    \n    # Compute normalized, shifted FFT\n    f_hat_N = np.fft.fft(f_N) / N\n    f_hat_N_shifted = np.fft.fftshift(f_hat_N)\n    \n    # The shifted wavenumbers correspond to indices k + N/2\n    idx_target_N = int(k_target + N / 2)\n    A_np = np.abs(f_hat_N_shifted[idx_target_N])\n\n    # --- 2. Padded Computation (M = 2N points) ---\n    x_M = 2 * np.pi * np.arange(M) / M\n    u_M = np.exp(1j * k1 * x_M) + np.exp(1j * k2 * x_M)\n    f_M = u_M**2\n\n    # Compute normalized, shifted FFT\n    f_hat_M = np.fft.fft(f_M) / M\n    f_hat_M_shifted = np.fft.fftshift(f_hat_M)\n    \n    # The shifted wavenumbers correspond to indices k + M/2\n    idx_target_M = int(k_target + M / 2)\n    A_pad = np.abs(f_hat_M_shifted[idx_target_M])\n\n    # --- 3. Decision Logic ---\n    if is_alias_scenario:\n        # Check if padding suppressed the spurious alias at k_target\n        # and if the unpadded calculation shows the expected artifact.\n        # The expected magnitude of the aliased quadratic product is 2.\n        padding_suppresses_alias = A_pad  tol\n        unpadded_has_alias_artifact = np.abs(A_np - 2.0)  tol\n        return padding_suppresses_alias and unpadded_has_alias_artifact\n    else:\n        # Check if both padded and unpadded calculations preserve\n        # the correct magnitude of the non-aliased product.\n        unpadded_is_correct = np.abs(A_np - 2.0)  tol\n        padded_is_correct = np.abs(A_pad - 2.0)  tol\n        return unpadded_is_correct and padded_is_correct\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k1, k2)\n        (32, 12, 10),      # Case 1 (happy path alias)\n        (32, 9, 8),        # Case 2 (near-boundary alias)\n        (32, -15, -5),     # Case 3 (negative-sum alias)\n        (48, 7, 8)         # Case 4 (no alias, preservation)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python's str() on a boolean produces 'True' or 'False' (capitalized).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Next, we translate the concept of dealiasing from global Fourier modes to the local polynomial bases used in Discontinuous Galerkin (DG) and spectral element methods. Here, a nonlinear operation on a polynomial of degree $N$ produces a higher-degree polynomial that cannot be exactly represented by the original basis, causing projection errors analogous to aliasing. This exercise demonstrates how \"padding\" by temporarily increasing the polynomial degree $M$ of the representation space allows for an exact evaluation of the nonlinearity, a fundamental technique for ensuring accuracy in modern high-order methods .",
            "id": "3374730",
            "problem": "Consider a single reference element with domain $[-1,1]$ as used in Discontinuous Galerkin (DG) methods. Let $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ denote the Legendre polynomial basis on $[-1,1]$ with the standard $L^{2}$ inner product $\\langle f,g\\rangle=\\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$, for which $\\int_{-1}^{1} P_{n}(x)P_{m}(x)\\,\\mathrm{d}x=\\dfrac{2}{2n+1}\\delta_{nm}$. Fix an integer polynomial degree $N\\ge 0$ and define a modal polynomial\n$$\nu_{N}(x)=\\sum_{k=0}^{N} a_{k}P_{k}(x),\\qquad a_{k}=\\frac{1}{k+1}.\n$$\nConsider the nonlinear source mapping $S(u)=\\exp(u)$ approximated by the truncated Taylor series of order $m$,\n$$\nS_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!},\n$$\nwhere $m\\ge 0$ is an integer. The element-wise padding-and-truncation procedure is defined as follows:\n- Choose a padding degree $M\\ge N$ and let $Q=M+1$.\n- Evaluate $u_{N}(x)$ at the $Q$-point Gauss–Legendre quadrature (GL) nodes $\\{x_{i}\\}_{i=1}^{Q}$ with weights $\\{w_{i}\\}_{i=1}^{Q}$ to obtain nodal values $\\{u_{N}(x_{i})\\}_{i=1}^{Q}$.\n- Compute nodal values of $S_{m}(u_{N})$ as $\\left\\{S_{m}(u_{N}(x_{i}))\\right\\}_{i=1}^{Q}$.\n- Project $S_{m}(u_{N})$ back to Legendre modal coefficients using the GL rule, i.e., compute\n$$\n\\widehat{c}_{n}^{(M)}=\\frac{2n+1}{2}\\sum_{i=1}^{Q} w_{i}\\,S_{m}\\!\\left(u_{N}(x_{i})\\right)P_{n}(x_{i}),\\qquad n=0,1,\\dots,N,\n$$\nand then truncate to degree $N$ by keeping only $\\left\\{\\widehat{c}_{n}^{(M)}\\right\\}_{n=0}^{N}$. This yields the padded-and-truncated coefficients up to degree $N$.\n\nFor a mathematically exact reference, define the exact degree-$N$ projection coefficients $c_{n}^{\\star}$ by\n$$\nc_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}\\!\\left(u_{N}(x)\\right)P_{n}(x)\\,\\mathrm{d}x,\\qquad n=0,1,\\dots,N,\n$$\nevaluated using a Gauss–Legendre quadrature with $Q_{\\mathrm{ref}}$ points that is exact for polynomials of degree up to $(m+1)N$, i.e., any $Q_{\\mathrm{ref}}$ satisfying $2Q_{\\mathrm{ref}}-1\\ge (m+1)N$.\n\nTask A (derivation). Starting from the facts that $u_{N}(x)$ is a polynomial of degree at most $N$ and that $u_{N}(x)^{p}$ has degree at most $pN$, derive the minimal padding degree $M$ such that the padded representation can capture $S_{m}(u_{N})$ exactly prior to truncation. Justify your result using only the degree-counting of polynomial compositions and the exactness properties of Gauss–Legendre quadrature.\n\nTask B (quantification of residual aliasing). For each triplet $(N,m,M)$ in the following test suite:\n- $(N,m,M)=(4,3,12)$,\n- $(N,m,M)=(4,3,11)$,\n- $(N,m,M)=(5,2,10)$,\n- $(N,m,M)=(5,2,9)$,\n- $(N,m,M)=(1,5,5)$,\n- $(N,m,M)=(0,7,0)$,\ncompute the maximal absolute coefficient error after truncation back to degree $N$,\n$$\nE_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|.\n$$\nUse $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$ for the exact-reference Gauss–Legendre quadrature so that the integrals defining $c_{n}^{\\star}$ are evaluated exactly.\n\nYour program must:\n- Implement the element-wise padding-and-truncation procedure described above.\n- Implement the exact-reference projection using Gauss–Legendre quadrature with $Q_{\\mathrm{ref}}$ points as specified.\n- Compute $E_{\\infty}(N,m,M)$ for each test case in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_{1},e_{2},\\dots]$), where each $e_{j}$ is a floating-point number corresponding to the $j$-th test case.\n\nAll computations are purely mathematical; no physical units appear. Angles are not involved. The only outputs are the floating-point errors $E_{\\infty}$ for the specified test cases.",
            "solution": "The problem is evaluated as scientifically grounded, well-posed, and objective, with all necessary data and definitions provided for a unique and meaningful solution. The problem statement is valid.\n\nThe solution is presented in two parts as requested: a theoretical derivation for Task A and a description of the numerical procedure for Task B.\n\n### Task A: Derivation of Minimal Padding Degree\n\nThe objective is to find the minimal padding degree, denoted as $M$, such that the padded representation of the nonlinear term $S_{m}(u_{N}(x))$ is exact.\n\nLet's analyze the properties of the functions involved.\n1.  The input polynomial, $u_{N}(x) = \\sum_{k=0}^{N} a_{k}P_{k}(x)$, is a polynomial in $x$ of degree at most $N$.\n2.  The approximated source term, $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$, is a polynomial in the variable $u$ of degree $m$.\n3.  The composition, $f(x) = S_{m}(u_{N}(x))$, is a polynomial in $x$. Since raising a polynomial of degree $N$ to the power of $p$ results in a polynomial of degree $pN$, the highest degree term in the composition comes from $(u_N(x))^m$. Therefore, the degree of $f(x)$ is exactly $mN$ (assuming $a_N \\neq 0$ and $N > 0$; if $N=0$, the degree is $0$).\n\nThe padding-and-truncation procedure involves evaluating $f(x)$ at the $Q=M+1$ nodes $\\{x_i\\}$ of a Gauss-Legendre quadrature rule. Let these nodal values be $f_i = f(x_i)$.\n\nThe \"padded representation\" refers to the unique polynomial of degree at most $M$, let's call it $\\mathcal{I}_{M}f(x)$, which passes through these $Q$ points. This is the Lagrange interpolating polynomial for the set of points $\\{(x_i, f_i)\\}_{i=1}^{Q}$.\n\nThe phrase \"to capture $S_{m}(u_{N})$ exactly\" means that this interpolating polynomial must be identical to the original function, i.e., $\\mathcal{I}_{M}f(x) \\equiv f(x)$ for all $x \\in [-1, 1]$.\n\nA fundamental theorem of polynomial interpolation states that if a function $f(x)$ is itself a polynomial of degree $D$, its interpolant $\\mathcal{I}_M f(x)$ through $M+1$ distinct points will be identical to $f(x)$ if and only if the degree of the interpolating polynomial is at least the degree of the original polynomial. That is, we must have $M \\ge D$.\n\nIn our case, the function to be captured is $f(x)=S_{m}(u_{N}(x))$, which has degree $D = mN$. Thus, for the padded representation to be exact, we must satisfy the condition:\n$$\nM \\ge mN\n$$\nThe minimal integer padding degree $M$ that satisfies this condition is therefore $M_{\\min} = mN$.\n\nWhen this condition is met ($M \\ge mN$), the set of nodal values $\\{ S_m(u_N(x_i)) \\}_{i=1}^{Q}$ uniquely defines the polynomial $S_m(u_N(x))$ over the entire interval. Consequently, any projection integral based on these nodal values (provided the quadrature is sufficiently accurate for the interpolant itself, which it is) will yield the exact projection coefficients of $S_m(u_N(x))$. The error $E_{\\infty}(N, m, M)$ will be zero (up to machine precision). If $M  mN$, the interpolating polynomial $\\mathcal{I}_{M}f(x)$ will, in general, differ from $S_{m}(u_{N}(x))$ due to aliasing, leading to a non-zero error.\n\n### Task B: Quantification of Residual Aliasing\n\nThe task is to compute the maximal absolute coefficient error $E_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|$ for a given set of test cases. This requires implementing two distinct procedures for calculating Legendre coefficients of $S_m(u_N(x))$: one using a reference high-order quadrature and one using the specified padded quadrature.\n\nThe overall algorithm is as follows for each test case $(N, m, M)$:\n\n1.  **Construct Polynomials**:\n    -   The modal polynomial $u_{N}(x)$ is constructed as $u_{N}(x)=\\sum_{k=0}^{N} \\frac{1}{k+1}P_{k}(x)$, where $P_k(x)$ is the Legendre polynomial of degree $k$.\n    -   The nonlinear function $S_{m}(u)$ is implemented as the Taylor series sum $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$.\n\n2.  **Compute Exact Reference Coefficients ($c_{n}^{\\star}$)**:\n    -   The reference coefficients are defined by the integral $c_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}(u_{N}(x))P_{n}(x)\\,\\mathrm{d}x$.\n    -   The integrand, $S_{m}(u_{N}(x))P_{n}(x)$, is a polynomial of degree at most $mN+n$. To compute all coefficients up to $n=N$, the highest degree integrand is of degree $(m+1)N$.\n    -   A Gauss-Legendre quadrature with $Q_{\\mathrm{pts}}$ points is exact for polynomials of degree up to $2Q_{\\mathrm{pts}}-1$. To guarantee exact integration, we need $2Q_{\\mathrm{pts}}-1 \\ge (m+1)N$.\n    -   The problem specifies using $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$ points, which satisfies the exactness condition.\n    -   We obtain the $Q_{\\mathrm{ref}}$ Gauss-Legendre nodes $\\{x_i^{\\mathrm{ref}}\\}$ and weights $\\{w_i^{\\mathrm{ref}}\\}$.\n    -   The coefficients are computed via numerical quadrature:\n        $$\n        c_{n}^{\\star} = \\frac{2n+1}{2}\\sum_{i=1}^{Q_{\\mathrm{ref}}} w_{i}^{\\mathrm{ref}}\\,S_{m}\\!\\left(u_{N}(x_{i}^{\\mathrm{ref}})\\right)P_{n}(x_{i}^{\\mathrm{ref}}), \\quad n=0,\\dots,N.\n        $$\n\n3.  **Compute Padded-and-Truncated Coefficients ($\\widehat{c}_{n}^{(M)}$)**:\n    -   This procedure uses a different number of quadrature points, $Q=M+1$.\n    -   We obtain the $Q$ Gauss-Legendre nodes $\\{x_j^{\\mathrm{pad}}\\}$ and weights $\\{w_j^{\\mathrm{pad}}\\}$.\n    -   The coefficients are computed similarly, but with the padded quadrature rule:\n        $$\n        \\widehat{c}_{n}^{(M)} = \\frac{2n+1}{2}\\sum_{j=1}^{Q} w_{j}^{\\mathrm{pad}}\\,S_{m}\\!\\left(u_{N}(x_{j}^{\\mathrm{pad}})\\right)P_{n}(x_{j}^{\\mathrm{pad}}), \\quad n=0,\\dots,N.\n        $$\n    -   If $M  mN$, this computation involves aliasing error because the $Q=M+1$ points are insufficient to uniquely determine the polynomial $S_m(u_N(x))$ of degree $mN$.\n\n4.  **Compute Error**:\n    -   For each test case, the maximal absolute error is found by comparing the two sets of coefficients:\n        $$\n        E_{\\infty}(N,m,M) = \\max_{0 \\le n \\le N} \\left| \\widehat{c}_{n}^{(M)} - c_{n}^{\\star} \\right|.\n        $$\n\nBased on the derivation in Task A, we expect the error to be near-zero for cases where $M \\ge mN$ and non-zero for cases where $M  mN$.\n-   $(N,m,M)=(4,3,12)$: $mN=12$. Since $M \\ge mN$, expect $E_{\\infty} \\approx 0$.\n-   $(N,m,M)=(4,3,11)$: $mN=12$. Since $M  mN$, expect $E_{\\infty} > 0$.\n-   $(N,m,M)=(5,2,10)$: $mN=10$. Since $M \\ge mN$, expect $E_{\\infty} \\approx 0$.\n-   $(N,m,M)=(5,2,9)$: $mN=10$. Since $M  mN$, expect $E_{\\infty} > 0$.\n-   $(N,m,M)=(1,5,5)$: $mN=5$. Since $M \\ge mN$, expect $E_{\\infty} \\approx 0$.\n-   $(N,m,M)=(0,7,0)$: $mN=0$. Since $M \\ge mN$, expect $E_{\\infty} \\approx 0$.\n\nThe implementation will use `numpy` for array operations, `numpy.polynomial.legendre.leggauss` for quadrature nodes and weights, and `scipy.special.eval_legendre` for evaluating Legendre polynomials.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import leggauss\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the dealiasing problem by computing the maximal absolute coefficient error\n    for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        (4, 3, 12),\n        (4, 3, 11),\n        (5, 2, 10),\n        (5, 2, 9),\n        (1, 5, 5),\n        (0, 7, 0),\n    ]\n\n    results = []\n\n    for N, m, M in test_cases:\n        \n        # 1. Define the polynomial u_N(x) and the source term S_m(u)\n\n        # Coefficients for u_N(x) are a_k = 1/(k+1)\n        u_N_coeffs = [1.0 / (k + 1) for k in range(N + 1)]\n\n        def u_N(x: np.ndarray) - np.ndarray:\n            \"\"\"Evaluates u_N(x) = sum_{k=0 to N} a_k P_k(x) at points x.\"\"\"\n            val = np.zeros_like(x, dtype=np.float64)\n            for k in range(N + 1):\n                val += u_N_coeffs[k] * eval_legendre(k, x)\n            return val\n\n        # Precompute factorials for S_m(u)\n        factorials = [math.factorial(p) for p in range(m + 1)]\n\n        def S_m(u: np.ndarray) - np.ndarray:\n            \"\"\"Evaluates S_m(u) = sum_{p=0 to m} u^p/p! at values u.\"\"\"\n            val = np.zeros_like(u, dtype=np.float64)\n            for p in range(m + 1):\n                val += (u**p) / factorials[p]\n            return val\n\n        def compute_legendre_coeffs(\n            deg_N: int, \n            func_vals: np.ndarray, \n            nodes: np.ndarray, \n            weights: np.ndarray\n        ) - np.ndarray:\n            \"\"\"\n            Computes Legendre coefficients of a function from its values at quadrature nodes.\n            \"\"\"\n            coeffs = np.zeros(deg_N + 1, dtype=np.float64)\n            for n in range(deg_N + 1):\n                P_n_vals = eval_legendre(n, nodes)\n                integral = np.sum(weights * func_vals * P_n_vals)\n                coeffs[n] = (2 * n + 1) / 2.0 * integral\n            return coeffs\n\n        # 2. Compute the exact reference coefficients c_n_star\n\n        # Determine the number of quadrature points for the reference calculation\n        # to exactly integrate a polynomial of degree up to (m+1)*N.\n        deg_to_integrate = (m + 1) * N\n        Q_ref = max(N + 1, int(np.ceil((deg_to_integrate + 1) / 2.0)))\n        \n        # Get reference quadrature nodes and weights\n        x_ref, w_ref = leggauss(Q_ref)\n\n        # Evaluate S_m(u_N(x)) at reference nodes\n        u_N_vals_ref = u_N(x_ref)\n        S_m_u_N_vals_ref = S_m(u_N_vals_ref)\n\n        # Compute reference coefficients\n        c_star = compute_legendre_coeffs(N, S_m_u_N_vals_ref, x_ref, w_ref)\n\n        # 3. Compute the padded-and-truncated coefficients c_n_hat\n\n        # Number of points for the padded representation\n        Q_pad = M + 1\n\n        # Get padded quadrature nodes and weights\n        x_pad, w_pad = leggauss(Q_pad)\n\n        # Evaluate S_m(u_N(x)) at padded nodes\n        u_N_vals_pad = u_N(x_pad)\n        S_m_u_N_vals_pad = S_m(u_N_vals_pad)\n        \n        # Compute padded coefficients\n        c_hat = compute_legendre_coeffs(N, S_m_u_N_vals_pad, x_pad, w_pad)\n        \n        # 4. Compute the maximal absolute coefficient error E_infinity\n        \n        error = np.max(np.abs(c_hat - c_star))\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Finally, we tackle a common practical challenge in DG methods: handling nonlinearities when using non-orthogonal bases, such as Bernstein polynomials, where projections and computations are more complex. This advanced practice contrasts a naive, under-integrated multiplication that generates significant aliasing error with a robust dealiasing procedure that leverages an auxiliary orthogonal basis (Legendre polynomials). By implementing both approaches and quantifying the \"aliasing residual,\" you will gain insight into a powerful strategy for developing accurate solvers and appreciate the interplay between basis choice and numerical stability .",
            "id": "3374732",
            "problem": "You are asked to study aliasing in Discontinuous Galerkin (DG) methods when using a non-orthogonal polynomial basis, specifically the Bernstein basis, and to compare a direct under-integrated multiplication against a padding-and-truncation de-aliasing procedure implemented in an orthogonal auxiliary basis. All computations are on the reference interval $[-1,1]$ and must be purely mathematical with no physical units. Angles used inside any trigonometric function must be interpreted in radians.\n\nLet $N \\in \\mathbb{N}$ denote the polynomial degree. Define the mapping from $x \\in [-1,1]$ to $t \\in [0,1]$ by $t = (x+1)/2$. The degree-$N$ Bernstein basis on $[0,1]$ is\n$$\nB_i^{N}(t) = \\binom{N}{i} t^i (1-t)^{N-i}, \\quad i = 0,\\ldots,N,\n$$\npulled back to $[-1,1]$ via $t = (x+1)/2$. The orthogonal auxiliary basis is the Legendre polynomial basis $\\{P_n(x)\\}_{n=0}^N$ on $[-1,1]$, which satisfies\n$$\n\\int_{-1}^{1} P_n(x) P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}.\n$$\nLet a polynomial $u(x)$ of degree at most $N$ be given in Bernstein coordinates by coefficients $\\{b_i\\}_{i=0}^{N}$, so that\n$$\nu(x) = \\sum_{i=0}^{N} b_i B_i^{N}\\!\\Big(\\frac{x+1}{2}\\Big).\n$$\nGiven an integer exponent $d \\in \\mathbb{N}$, define $w(x) = u(x)^d$. You will compute two approximations to the degree-$N$ projection of $w(x)$ and compare them via an $L^2$ residual.\n\nProcedure A (direct under-integrated Bernstein-based multiplication):\n- Use Gauss–Legendre quadrature with $Q_{\\text{alias}} = N+1$ nodes $\\{x_k\\}_{k=1}^{Q_{\\text{alias}}}$ and weights $\\{w_k\\}_{k=1}^{Q_{\\text{alias}}}$ on $[-1,1]$.\n- Evaluate $u(x_k)$ using the Bernstein basis and coefficients $\\{b_i\\}$.\n- Form $w_{\\text{alias}}(x_k) = \\big(u(x_k)\\big)^d$ at these quadrature nodes.\n- Let $\\{B_j^{N}\\}_{j=0}^{N}$ denote the Bernstein basis pulled back to $[-1,1]$. Compute the mass matrix entries $M_{ij} = \\sum_{k=1}^{Q_{\\text{alias}}} w_k B_i^{N}(x_k) B_j^{N}(x_k)$ and right-hand side entries $r_j = \\sum_{k=1}^{Q_{\\text{alias}}} w_k w_{\\text{alias}}(x_k)\\, B_j^{N}(x_k)$. Solve the linear system $M \\, \\hat{b}^{\\text{alias}} = r$ for the aliasing-affected Bernstein coefficients $\\hat{b}^{\\text{alias}}$. Define\n$$\n\\Pi_N^{\\text{alias}} w(x) = \\sum_{j=0}^{N} \\hat{b}^{\\text{alias}}_j B_j^{N}\\!\\Big(\\frac{x+1}{2}\\Big).\n$$\n\nProcedure B (dealiasing by padding and truncation in an orthogonal auxiliary basis):\n- First, obtain the Legendre coefficients $a_n$ of $u(x)$ by $L^2$ projection onto $\\{P_n\\}_{n=0}^{N}$ using Gauss–Legendre quadrature with $Q_u = N+1$ nodes. By orthogonality,\n$$\na_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x) \\, dx.\n$$\n- Choose a padded degree $P = d\\,N$. Use Gauss–Legendre quadrature on $[-1,1]$ with $Q_{\\text{pad}} = P+1$ nodes and weights. Evaluate $u(x)$ at these nodes, form $w_{\\text{pad}}(x) = u(x)^d$, then project $w_{\\text{pad}}$ onto Legendre polynomials up to degree $P$ by\n$$\nc_n = \\frac{2n+1}{2} \\int_{-1}^{1} w_{\\text{pad}}(x) P_n(x) \\, dx, \\quad n = 0,\\ldots,P.\n$$\n- Truncate the Legendre coefficients to degree $N$ by setting $\\tilde{c}_n = c_n$ for $n \\le N$ and $\\tilde{c}_n = 0$ for $n  N$. Define\n$$\n\\Pi_N^{\\text{dealias}} w(x) = \\sum_{n=0}^{N} \\tilde{c}_n P_n(x).\n$$\n\nDefine the aliasing residual as the $L^2$ norm of the difference between these two degree-$N$ approximations:\n$$\nR = \\left( \\int_{-1}^{1} \\left(\\Pi_N^{\\text{alias}} w(x) - \\Pi_N^{\\text{dealias}} w(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\nIn your computation of $R$, use Gauss–Legendre quadrature on $[-1,1]$ with $Q_{\\text{eval}} = 3N + 3$ points to ensure exactness for the polynomial degrees involved in the squared difference.\n\nImplement the following test suite. In each test, the input is the pair $(N,d)$ and the Bernstein coefficients $\\{b_i\\}_{i=0}^{N}$ defining $u(x)$. Angles in any trigonometric function must be in radians.\n\n- Test $1$ (happy path): $N = 3$, $d = 2$, and $b_0 = 1.0$, $b_1 = 0.5$, $b_2 = -0.25$, $b_3 = 0.125$.\n- Test $2$ (higher nonlinearity with alternating coefficients): $N = 5$, $d = 3$, and $b_i = \\frac{(-1)^i}{i+1}$ for $i = 0,\\ldots,5$.\n- Test $3$ (boundary small degree, strong nonlinearity): $N = 1$, $d = 4$, and $b_0 = 0.3$, $b_1 = -0.7$.\n- Test $4$ (higher degree, smooth coefficients): $N = 7$, $d = 2$, and $b_i = \\frac{\\sin(i+1)}{i+1}$ for $i = 0,\\ldots,7$, where the sine argument is in radians.\n\nYour program must compute $R$ for each test and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the tests, e.g., $[r_1,r_2,r_3,r_4]$. Each $r_k$ must be a floating-point number. No other output is permitted.",
            "solution": "The problem requires the computation of an aliasing residual, which quantifies the error introduced by under-sampling a nonlinear term in a projection pertinent to Discontinuous Galerkin (DG) methods. This is achieved by comparing two approximations of a projected nonlinear function, $w(x) = (u(x))^d$. The first approximation, $\\Pi_N^{\\text{alias}} w(x)$, is computed using an under-resolved quadrature rule that introduces aliasing errors. The second, $\\Pi_N^{\\text{dealias}} w(x)$, is computed using a padding and truncation technique in an orthogonal basis, designed to be alias-free and serve as a reference solution. The final quantity of interest is the $L^2$ norm of their difference. All computations are performed on the reference interval $x \\in [-1,1]$.\n\nAt the core of the methods are polynomial bases and numerical quadrature. The problem specifies a non-orthogonal Bernstein basis for the initial data and the aliased computation, and an orthogonal Legendre basis for the de-aliasing procedure.\n\nThe degree-$N$ Bernstein basis polynomials on the interval $[0,1]$ are given by\n$$\nB_i^{N}(t) = \\binom{N}{i} t^i (1-t)^{N-i}, \\quad i = 0,\\ldots,N.\n$$\nThese are mapped to the interval $[-1,1]$ by the affine transformation $t(x) = (x+1)/2$. We denote the mapped basis functions as $B_i^{N}(x)$. An input polynomial $u(x)$ of degree at most $N$ is represented as\n$$\nu(x) = \\sum_{i=0}^{N} b_i B_i^{N}\\Big(\\frac{x+1}{2}\\Big).\n$$\nThe auxiliary basis is the set of Legendre polynomials $\\{P_n(x)\\}_{n=0}^N$, which are orthogonal on $[-1,1]$:\n$$\n\\int_{-1}^{1} P_n(x) P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}.\n$$\nNumerical integrals are approximated using Gauss-Legendre quadrature. A rule with $Q$ nodes $\\{x_k\\}$ and weights $\\{w_k\\}$ is exact for any polynomial of degree up to $2Q-1$.\n\nProcedure A: Direct Under-integrated (Aliased) Projection\nThis procedure computes an approximation of the degree-$N$ projection of $w(x) = (u(x))^d$ directly in the Bernstein basis, using an insufficient number of quadrature points.\n1. An $N+1$-point Gauss-Legendre quadrature rule is established, with nodes $\\{x_k\\}_{k=1}^{N+1}$ and weights $\\{w_k\\}_{k=1}^{N+1}$. This rule is exact for polynomials of degree up to $2(N+1)-1 = 2N+1$.\n2. The polynomial $u(x)$ is evaluated at these nodes, $u(x_k)$, and the nonlinear term is formed pointwise: $w_{\\text{alias}}(x_k) = (u(x_k))^d$.\n3. The goal is to find the coefficients $\\hat{b}^{\\text{alias}}$ of the projection $\\Pi_N^{\\text{alias}} w(x) = \\sum_{j=0}^{N} \\hat{b}^{\\text{alias}}_j B_j^{N}(x)$ by enforcing the Galerkin condition with quadrature:\n$$\n\\sum_{k=1}^{N+1} w_k \\Pi_N^{\\text{alias}} w(x_k) B_j^{N}(x_k) = \\sum_{k=1}^{N+1} w_k w_{\\text{alias}}(x_k) B_j^{N}(x_k) \\quad \\text{for } j=0, \\dots, N.\n$$\nThis results in the linear system $M \\hat{b}^{\\text{alias}} = r$, where $M$ is the mass matrix and $r$ is the right-hand side vector, with entries given by:\n$$\nM_{ij} = \\sum_{k=1}^{N+1} w_k B_i^{N}(x_k) B_j^{N}(x_k) \\quad \\text{and} \\quad r_j = \\sum_{k=1}^{N+1} w_k w_{\\text{alias}}(x_k) B_j^{N}(x_k).\n$$\nThe integrand for the mass matrix entries, $B_i^{N}(x) B_j^{N}(x)$, is a polynomial of degree $2N$, so the $N+1$-point rule computes $M$ exactly. However, the integrand for the right-hand side, $w(x) B_j^{N}(x) = (u(x))^d B_j^{N}(x)$, is a polynomial of degree $dN+N$. If $dN+N > 2N+1$, which is equivalent to $(d-1)N > 1$, the quadrature is inexact, and high-frequency components of $w(x)$ are \"aliased\" into the frequency range captured by the basis, corrupting the coefficients $\\hat{b}^{\\text{alias}}$.\n\nProcedure B: De-aliasing by Padding and Truncation\nThis procedure computes a more accurate projection by using a quadrature rule with sufficient points to exactly integrate the nonlinear term. This is done in the orthogonal Legendre basis, which simplifies projections.\n1. The polynomial $u(x)$ is first represented in the Legendre basis: $u(x) = \\sum_{n=0}^{N} a_n P_n(x)$. The coefficients $a_n$ are found via $L^2$ projection, which, thanks to orthogonality, simplifies to:\n$$\na_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x) \\, dx.\n$$\nThe integral is computed with an $N+1$-point Gauss-Legendre quadrature, which is exact since the integrand has degree at most $N+N=2N \\le 2N+1$.\n2. To handle the nonlinearity $w(x)=(u(x))^d$, the polynomial degree is \"padded\" to $P=dN$. A Gauss-Legendre quadrature rule with $Q_{\\text{pad}} = P+1 = dN+1$ points is established. This rule is exact for polynomials of degree up to $2(dN+1)-1 = 2dN+1$.\n3. The polynomial $w(x)$ is projected onto the Legendre basis up to degree $P$. The coefficients $c_n$ are computed as:\n$$\nc_n = \\frac{2n+1}{2} \\int_{-1}^{1} w(x) P_n(x) \\, dx, \\quad n=0, \\dots, P.\n$$\nThe integrals are computed using the $Q_{\\text{pad}}$-point rule. The integrand $w(x)P_n(x)$ has degree at most $dN+P = 2dN$. Since $2dN \\le 2dN+1$, this computation is exact.\n4. The resulting high-degree representation is truncated to obtain the best degree-$N$ $L^2$ approximation: $\\tilde{c}_n = c_n$ for $n \\le N$, and zero otherwise. This yields the de-aliased approximation $\\Pi_N^{\\text{dealias}} w(x) = \\sum_{n=0}^{N} \\tilde{c}_n P_n(x)$.\n\nAliasing Residual Calculation\nThe final step is to quantify the discrepancy between the two approximations by computing the $L^2$ residual $R$:\n$$\nR = \\left( \\int_{-1}^{1} \\left(\\Pi_N^{\\text{alias}} w(x) - \\Pi_N^{\\text{dealias}} w(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\nThe integrand is a polynomial of degree at most $2N$. To ensure this integral is computed exactly, a high-order Gauss-Legendre quadrature with $Q_{\\text{eval}} = 3N+3$ points is used. This rule is exact for polynomials of degree up to $2(3N+3)-1 = 6N+5$, which is sufficient since $2N \\le 6N+5$ for all $N \\ge 0$. The integral is computed by evaluating both polynomial representations, $\\Pi_N^{\\text{alias}} w(x)$ (from its Bernstein coefficients) and $\\Pi_N^{\\text{dealias}} w(x)$ (from its Legendre coefficients), at the $Q_{\\text{eval}}$ quadrature nodes, and summing their squared differences weighted by the quadrature weights.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb, eval_legendre\nfrom numpy.polynomial.legendre import leggauss, legval\n\ndef bernstein_poly(N, i, x):\n    \"\"\"\n    Evaluates the i-th Bernstein polynomial of degree N at points x in [-1, 1].\n    \"\"\"\n    t = 0.5 * (x + 1.0)\n    # Clamp t to [0, 1] to avoid NaNs from small floating point errors near 0 or 1\n    t = np.clip(t, 0.0, 1.0)\n    # Using scipy.special.comb for robust binomial coefficient calculation\n    return comb(N, i) * (t**i) * ((1.0 - t)**(N-i))\n\ndef eval_poly_bernstein(coeffs, x, N):\n    \"\"\"\n    Evaluates a polynomial given in Bernstein basis at points x.\n    \"\"\"\n    val = np.zeros_like(x, dtype=float)\n    for i, b_i in enumerate(coeffs):\n        val += b_i * bernstein_poly(N, i, x)\n    return val\n\ndef compute_residual_for_case(N, d, b):\n    \"\"\"\n    Computes the aliasing residual R for a single test case.\n    \n    Args:\n        N (int): Polynomial degree.\n        d (int): Exponent of the nonlinearity.\n        b (list or np.ndarray): Bernstein coefficients of the input polynomial u(x).\n\n    Returns:\n        float: The computed aliasing residual R.\n    \"\"\"\n    # ====== Procedure A: Aliased Projection ======\n    Q_alias = N + 1\n    x_alias, w_alias = leggauss(Q_alias)\n    \n    # Evaluate u(x) at aliasing quadrature nodes\n    u_vals_alias = eval_poly_bernstein(b, x_alias, N)\n    \n    # Form w(x) = u(x)^d at these nodes\n    w_alias_vals = u_vals_alias**d\n    \n    # Compute Bernstein basis functions at nodes\n    B_alias_vals = np.array([bernstein_poly(N, i, x_alias) for i in range(N + 1)]) # Shape: (N+1, Q_alias)\n    \n    # Build and solve the linear system M * b_hat = r\n    M = B_alias_vals @ np.diag(w_alias) @ B_alias_vals.T\n    r = B_alias_vals @ (w_alias * w_alias_vals)\n    \n    b_hat_alias = np.linalg.solve(M, r)\n\n    # ====== Procedure B: Dealiased Projection ======\n    # Step 1: Project u(x) from Bernstein to Legendre basis\n    Q_u = N + 1\n    x_u, w_u = leggauss(Q_u)\n    u_vals_u = eval_poly_bernstein(b, x_u, N)\n    \n    a_coeffs = np.zeros(N + 1)\n    for n in range(N + 1):\n        P_n_vals = eval_legendre(n, x_u)\n        integral = np.sum(w_u * u_vals_u * P_n_vals)\n        a_coeffs[n] = (2.0 * n + 1.0) / 2.0 * integral\n        \n    # Step 2: Project w(x) = u(x)^d onto padded Legendre basis\n    P = d * N\n    Q_pad = P + 1\n    # For N=0, P=0, Q_pad=1, leggauss needs degree  0. Handle this edge case.\n    if Q_pad = 0:\n        x_pad, w_pad = np.array([0.0]), np.array([2.0])\n    else:\n        x_pad, w_pad = leggauss(Q_pad)\n\n    # Evaluate u(x) at padded grid using its Legendre series\n    u_vals_pad = legval(x_pad, a_coeffs)\n    w_pad_vals = u_vals_pad**d\n    \n    c_coeffs = np.zeros(P + 1)\n    for n in range(P + 1):\n        P_n_vals_pad = eval_legendre(n, x_pad)\n        integral = np.sum(w_pad * w_pad_vals * P_n_vals_pad)\n        c_coeffs[n] = (2.0 * n + 1.0) / 2.0 * integral\n        \n    # Step 3: Truncate coefficients to degree N\n    c_tilde = c_coeffs[:N+1]\n\n    # ====== Compute Residual R ======\n    Q_eval = 3 * N + 3\n    x_eval, w_eval = leggauss(Q_eval)\n    \n    # Evaluate aliased approximation\n    pi_alias_w = eval_poly_bernstein(b_hat_alias, x_eval, N)\n    \n    # Evaluate de-aliased approximation\n    pi_dealias_w = legval(x_eval, c_tilde)\n    \n    # Compute L2 norm of the difference\n    squared_diff = (pi_alias_w - pi_dealias_w)**2\n    integral_sq_diff = np.sum(w_eval * squared_diff)\n    \n    R = np.sqrt(integral_sq_diff)\n    return R\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 3, 'd': 2, 'b': np.array([1.0, 0.5, -0.25, 0.125])},\n        {'N': 5, 'd': 3, 'b': np.array([(-1.0)**i / (i + 1.0) for i in range(6)])},\n        {'N': 1, 'd': 4, 'b': np.array([0.3, -0.7])},\n        {'N': 7, 'd': 2, 'b': np.array([np.sin(i + 1.0) / (i + 1.0) for i in range(8)])}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        d = case['d']\n        b = case['b']\n        residual = compute_residual_for_case(N, d, b)\n        results.append(residual)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}