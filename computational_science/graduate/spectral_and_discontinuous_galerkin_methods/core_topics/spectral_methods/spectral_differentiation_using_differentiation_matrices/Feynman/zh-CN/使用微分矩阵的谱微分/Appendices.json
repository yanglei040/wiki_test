{
    "hands_on_practices": [
        {
            "introduction": "我们从谱方法的核心优势——谱精度——开始。本练习将引导你验证一个关键特性：对于一个能够被计算网格完全解析的函数，傅里叶谱微分在节点上给出的不是近似解，而是精确解 。理解这一理想情况是掌握谱方法威力并认识其在更复杂问题中局限性的基础。",
            "id": "3417589",
            "problem": "考虑周期区间 $[0,2\\pi]$ 和具有 $N=8$ 个节点的等距网格 $x_{j}=\\frac{2\\pi j}{N}$，$j=0,1,\\dots,7$。设节点值为 $u_{j}=\\sin(x_{j})+\\frac{1}{2}\\cos(3x_{j})$。角度以弧度为单位。在傅里叶谱方法中，一阶微分矩阵 $D$ 是作用于节点值上的线性算子，其作用定义为：通过周期函数在网格节点上的离散三角展开来表示该函数，并在谱（频率）域中应用与微分相对应的适当运算。仅使用此表示以及物理空间中的微分与谱空间中的运算之间的对应关系，执行以下操作：\n\n1. 构造傅里叶谱微分矩阵 $D$ 对向量 $u=\\{u_{j}\\}_{j=0}^{7}$ 的作用，并计算在节点上的 $Du$。\n2. 推导底层函数 $u(x)=\\sin(x)+\\frac{1}{2}\\cos(3x)$ 的精确导数 $u^{\\prime}(x)$，并计算在节点上的 $u^{\\prime}(x_{j})$。\n3. 从等距周期网格上离散傅里叶表示的基本原理出发，论证对于此 $N$ 和 $u(x)$ 的选择，$Du$ 是否必然与 $\\{u^{\\prime}(x_{j})\\}_{j=0}^{7}$ 一致。\n4. 定义离散无穷范数误差 $E=\\max_{0\\leq j\\leq 7}\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right|$ 并计算 $E$。\n\n将 $E$ 的值作为最终答案报告。如果需要数值近似，将会给出四舍五入到指定有效数字的说明；然而，对于此问题，请提供作为实数的精确值。",
            "solution": "该问题要求分析应用于等距网格上特定函数的傅里叶谱微分方法。我们必须验证该问题，如果有效，则遵循四个指定步骤来解决它，并报告最终的误差值。\n\n首先，对问题进行验证。\n**提取的已知条件：**\n- 域：周期区间 $[0, 2\\pi]$。\n- 网格：$N=8$ 个等距节点 $x_{j}=\\frac{2\\pi j}{N}$，$j=0,1,\\dots,7$。\n- 节点值：$u_{j}=\\sin(x_{j})+\\frac{1}{2}\\cos(3x_{j})$。\n- 底层函数：$u(x)=\\sin(x)+\\frac{1}{2}\\cos(3x)$。\n- 算子：一阶傅里叶谱微分矩阵，$D$。\n- 任务1：计算 $D$ 对节点值向量的作用，$Du$。\n- 任务2：计算在节点上的精确导数 $u^{\\prime}(x_j)$。\n- 任务3：论证任务1和任务2的结果是否一致。\n- 任务4：计算离散无穷范数误差 $E=\\max_{0\\leq j\\leq 7}\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right|$。\n\n**验证结论：**\n该问题具有科学依据、适定且客观。它是数值分析领域的标准问题，特别涉及谱方法。所使用的概念，如离散傅里叶变换（DFT）、谱微分和混叠，是该领域的基础。问题是自洽的，提供了得出唯一解所需的所有信息（$N$、$u(x)$、网格定义）。不存在矛盾、歧义或违反科学原理的情况。该问题被判定为**有效**。我们继续进行求解。\n\n解答是通过依次解决问题陈述的四个部分来构建的。\n\n**1. 构造傅里叶谱微分矩阵 $D$ 对 $u$ 的作用。**\n\n傅里叶谱微分算子的作用在频域中定义。首先，函数 $u(x)$ 用其傅里叶级数表示。我们使用复指数来表示 $u(x)$：\n$$u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x) = \\frac{e^{ix} - e^{-ix}}{2i} + \\frac{1}{2}\\left(\\frac{e^{i3x} + e^{-i3x}}{2}\\right)$$\n$$u(x) = -\\frac{i}{2}e^{ix} + \\frac{i}{2}e^{-ix} + \\frac{1}{4}e^{i3x} + \\frac{1}{4}e^{-i3x}$$\n这是 $u(x)$ 的连续傅里叶级数表示，它是一个三角多项式。在展开式 $u(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{ikx}$ 中，非零傅里叶系数 $c_k$ 为：\n$$c_1 = -\\frac{i}{2}, \\quad c_{-1} = \\frac{i}{2}, \\quad c_3 = \\frac{1}{4}, \\quad c_{-3} = \\frac{1}{4}$$\n所有其他系数 $c_k$ 均为零。\n\n离散值 $u_j = u(x_j)$ 在一个有 $N=8$ 个点的网格上采样。$u(x)$ 中存在的最大波数大小为 $k_{max}=3$。对于一个 $N$ 点网格，周期函数的奈奎斯特-香农采样定理表明，如果一个三角多项式的最大波数大小 $k_{max}$ 满足 $|k_{max}|  N/2$，则该多项式可以被完美解析（即没有发生混叠）。\n在我们的例子中，$N=8$，所以 $N/2 = 4$。条件是 $3  4$，这是成立的。因此，函数 $u(x)$ 在网格 $\\{x_j\\}$ 上没有发生混叠。没有混叠确保了从节点值 $\\{u_j\\}$ 计算出的离散傅里叶系数 $\\hat{u}_k$ 与所有可解析波数的连续傅里叶系数 $c_k$ 完全相同。\n\n谱微分对应于将傅里叶系数 $\\hat{u}_k$ 乘以 $ik$。设 $v(x)$ 是通过对 $u(x)$ 进行谱微分得到的函数。其傅里叶系数 $\\hat{v}_k$ 由 $\\hat{v}_k = ik\\hat{u}_k$ 给出。使用 $u(x)$ 的系数：\n$$\\hat{v}_1 = i(1)\\hat{u}_1 = i\\left(-\\frac{i}{2}\\right) = \\frac{1}{2}$$\n$$\\hat{v}_{-1} = i(-1)\\hat{u}_{-1} = (-i)\\left(\\frac{i}{2}\\right) = \\frac{1}{2}$$\n$$\\hat{v}_3 = i(3)\\hat{u}_3 = 3i\\left(\\frac{1}{4}\\right) = \\frac{3i}{4}$$\n$$\\hat{v}_{-3} = i(-3)\\hat{u}_{-3} = -3i\\left(\\frac{1}{4}\\right) = -\\frac{3i}{4}$$\n所有其他系数 $\\hat{v}_k$ 均为零。\n\n在网格点处的谱微分函数值，我们记为 $(Du)_j$，通过傅里叶逆变换得到：\n$$(Du)_j = v(x_j) = \\sum_{k} \\hat{v}_k e^{ikx_j}$$\n$$(Du)_j = \\hat{v}_{-3}e^{-i3x_j} + \\hat{v}_{-1}e^{-ix_j} + \\hat{v}_{1}e^{ix_j} + \\hat{v}_{3}e^{i3x_j}$$\n$$(Du)_j = \\left(-\\frac{3i}{4}\\right)e^{-i3x_j} + \\left(\\frac{1}{2}\\right)e^{-ix_j} + \\left(\\frac{1}{2}\\right)e^{ix_j} + \\left(\\frac{3i}{4}\\right)e^{i3x_j}$$\n将各项分组：\n$$(Du)_j = \\frac{1}{2}\\left(e^{ix_j} + e^{-ix_j}\\right) + \\frac{3i}{4}\\left(e^{i3x_j} - e^{-i3x_j}\\right)$$\n使用欧拉公式，$2\\cos(\\theta) = e^{i\\theta} + e^{-i\\theta}$ 和 $2i\\sin(\\theta) = e^{i\\theta} - e^{-i\\theta}$：\n$$(Du)_j = \\cos(x_j) + \\frac{3i}{4}(2i\\sin(3x_j))$$\n$$(Du)_j = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$$\n\n**2. 推导精确导数 $u^{\\prime}(x)$ 及其在节点上的求值。**\n\n底层函数是 $u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$。我们使用标准微积分法则计算它关于 $x$ 的一阶导数：\n$$u^{\\prime}(x) = \\frac{d}{dx}\\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)$$\n$$u^{\\prime}(x) = \\frac{d}{dx}(\\sin(x)) + \\frac{1}{2}\\frac{d}{dx}(\\cos(3x))$$\n$$u^{\\prime}(x) = \\cos(x) + \\frac{1}{2}(-\\sin(3x) \\cdot 3)$$\n$$u^{\\prime}(x) = \\cos(x) - \\frac{3}{2}\\sin(3x)$$\n在网格节点 $x_j$ 处计算此精确导数：\n$$u^{\\prime}(x_j) = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$$\n\n**3. 对 $(Du)_j$ 和 $u^{\\prime}(x_j)$ 一致性的论证。**\n\n从第1部分，我们得到 $(Du)_j = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$。\n从第2部分，我们得到 $u^{\\prime}(x_j) = \\cos(x_j) - \\frac{3}{2}\\sin(3x_j)$。\n显然，对于所有 $j=0, 1, \\dots, 7$，有 $(Du)_j = u^{\\prime}(x_j)$。\n\n从基本原理出发的论证依赖于傅里叶谱方法的性质。该方法对于任何其波数能被网格完全解析的三角多项式函数都是精确的。\n函数 $u(x)=\\sin(x)+\\frac{1}{2}\\cos(3x)$ 是一个三角多项式，其最大波数大小为 $k_{max}=3$。\n网格由 $N=8$ 个点组成。周期信号的采样定理指出，所有波数大小满足 $|k|  N/2$ 的频率分量都可以被唯一表示。对于偶数 $N$，这个条件确保不会发生混叠。\n在此问题中，$N/2=4$。条件是 $|k_{max}|  4$，即 $34$。此条件得到满足。\n因为没有混叠，采样值 $\\{u_j\\}$ 的离散傅里叶变换产生的离散傅里叶系数 $\\hat{u}_k$ 与函数 $u(x)$ 的连续傅里叶级数系数 $c_k$（在相关 $k$ 的范围内）完全相等。\n$u(x) = \\sum_k c_k e^{ikx}$ 的解析微分得到 $u'(x) = \\sum_k (ik c_k) e^{ikx}$。\n数值谱微分过程计算 $\\hat{v}_k = ik \\hat{u}_k = ik c_k$，然后通过逆变换重构导数，得到 $\\sum_k (ik c_k) e^{ikx_j}$。\n由于谱系数是精确的，因此在网格点上重构的导数与在这些相同点上计算的精确导数完全相同。因此，$(Du)_j$ 必然与 $u^{\\prime}(x_j)$ 一致。\n\n**4. 计算误差 $E$。**\n\n离散无穷范数误差定义为：\n$$E = \\max_{0\\leq j\\leq 7}\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right|$$\n正如第3部分所确立的，对于这个特定的函数和网格，谱导数和精确导数在每个网格节点上都是相同的。\n因此，对于每个 $j \\in \\{0, 1, \\dots, 7\\}$：\n$$(Du)_j - u^{\\prime}(x_j) = 0$$\n这个差的绝对值也为零：\n$$\\left| (Du)_{j}-u^{\\prime}(x_{j}) \\right| = 0$$\n一组零的最大值是零。\n$$E = \\max \\{0, 0, 0, 0, 0, 0, 0, 0\\} = 0$$\n误差恰好为 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在实际应用中，物理模型常包含非线性项，这对谱方法提出了独特的挑战。本练习将展示，在物理空间中直接计算像 $u(x)^2$ 这样的非线性项会导致“走样误差”（aliasing error），即高频分量伪装成低频分量从而污染计算结果 。你将亲手实现标准的“3/2规则”，这是一种关键的反走样技术，用以确保非线性项的计算精度。",
            "id": "3417612",
            "problem": "本题要求您在一个周期性域上实现傅里叶谱微分，其微分矩阵通过傅里叶空间中的对角化来隐式定义。您还需要通过在谱空间中补零的方式，引入三分之二法则（也称为 $3/2$ 法则）进行去混叠。您的实现必须计算一个非线性项在有和没有去混叠情况下的空间导数，并通过与在相同网格上采样的已知精确导数进行比较，来量化去混叠对误差的影响。\n\n问题设定纯粹是数学上的，并使用以下基本依据：\n- 在长度为 $L = 2\\pi$ 的周期性域上（角度以弧度为单位），一个 $N$ 点等距网格为 $x_j = j \\Delta x$，其中 $\\Delta x = L/N$。\n- 离散傅里叶变换（快速傅里叶变换(FFT)）及其逆变换通过其离散傅里叶系数来表示一个函数。网格上的傅里叶微分算子可以表示为一个微分矩阵 $\\mathbf{D}_N = \\mathbf{F}_N^{-1} \\operatorname{diag}(\\mathrm{i} k) \\mathbf{F}_N$，其中 $\\mathbf{F}_N$ 是离散傅里叶变换矩阵，$k$ 是与网格对应的角波数向量，$\\mathrm{i}$ 是虚数单位。将 $\\mathbf{D}_N$ 应用于网格上的函数值，等效于变换到谱空间，乘以 $\\mathrm{i} k$，然后再变换回来。\n- 物理空间中函数的乘积对应其傅里叶系数的卷积。在一个具有 $N$ 个模式的有限网格上，此卷积是模 $N$ 计算的，除非采取措施，否则会引起混叠。三分之二法则通过在变换到物理空间计算乘积之前，将傅里叶系数补零至 $M = \\tfrac{3}{2} N$ 的长度，然后截断回 $N$ 来减轻二次非线性的混叠。\n\n您的任务：\n1. 实现一个例程，通过傅里叶空间中的对角化隐式应用傅里叶微分矩阵 $\\mathbf{D}_N$，以计算在 $[0,2\\pi)$（弧度）上的 $N$ 点网格上给定的函数的导数。使用由适合网格和域长度 $L=2\\pi$ 的离散频率生成的标准角波数向量 $k$。\n2. 通过以下步骤，在 $N$ 点网格上实现非线性项 $g(x) = u(x)^2$ 的朴素伪谱导数：\n   - 在网格上计算 $u$ 的值，\n   - 在物理空间中形成 $g = u^2$，\n   - 将傅里叶微分矩阵应用于 $g$ 以近似 $g'(x)$。\n3. 通过以下步骤，为 $g(x) = u(x)^2$ 的导数实现三分之二法则（$3/2$ 法则）去混叠版本：\n   - 在 $N$ 网格上将 $u$ 变换到谱空间，\n   - 通过对称嵌入低频模式和适当的归一化，将谱补零至长度 $M = \\tfrac{3}{2} N$，以使在 $M$ 网格上的逆变换能再现在 $M$ 个点上采样的连续三角插值，\n   - 变换到 $M$ 网格上的物理空间，\n   - 在 $M$ 网格的物理空间中形成 $g_M = u_M^2$，\n   - 将 $g_M$ 变换回长度为 $M$ 的谱空间，\n   - 将谱截断回长度 $N$，并使用逆归一化以与 $N$ 网格保持一致，\n   - 在 $N$ 网格上将傅里叶微分矩阵应用于 $g$ 的截断谱，以获得 $N$ 网格上 $g'(x)$ 的去混叠近似。\n\n您必须使用以下测试套件，所有测试都在域 $[0,2\\pi)$ 上进行，角度以弧度为单位：\n- 情况 A（理想情况，中度非线性）：$N = 32$，定义 $u(x) = \\sin(3 x) + 0.5 \\cos(5 x)$。\n- 情况 B（高频内容接近 $N$ 上的奈奎斯特极限）：$N = 32$，定义 $u(x) = 0.7 \\sin(10 x) + 0.6 \\cos(11 x)$。\n- 情况 C（非常粗糙的网格，强混叠）：$N = 8$，定义 $u(x) = \\sin(3 x)$。\n- 情况 D（中等网格，模式接近截断）：$N = 48$，定义 $u(x) = \\sin(12 x) + 0.3 \\sin(13 x)$。\n\n对于每种情况，计算：\n- 使用精确的解析导数 $u'(x)$，通过 $g'(x) = 2 u(x) u'(x)$ 计算 $g(x) = u(x)^2$ 在网格点上的精确导数。\n- 如上所述，在 $N$ 网格上计算 $g'(x)$ 的朴素伪谱近似。\n- 如上所述，在 $N$ 网格上计算 $g'(x)$ 的去混叠（$3/2$ 法则）伪谱近似。\n\n对于每种情况，报告两个数字：\n- 朴素近似相对于精确采样导数的相对离散 $L^2$ 误差，定义为\n  $$ \\varepsilon_{\\mathrm{naive}} = \\frac{\\left( \\sum_{j=0}^{N-1} \\left| g'_{\\mathrm{naive}}(x_j) - g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}{\\left( \\sum_{j=0}^{N-1} \\left| g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}. $$\n- 去混叠近似的相对离散 $L^2$ 误差\n  $$ \\varepsilon_{3/2} = \\frac{\\left( \\sum_{j=0}^{N-1} \\left| g'_{3/2}(x_j) - g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}{\\left( \\sum_{j=0}^{N-1} \\left| g'_{\\mathrm{exact}}(x_j) \\right|^2 \\Delta x \\right)^{1/2}}. $$\n\n您的程序必须输出一行，包含所有四种情况的汇总结果，格式如下：\n- 一个包含四个条目的单一列表，每个条目对应一种情况，顺序为 A、B、C、D。\n- 每个条目本身必须是一个包含两个元素 $[\\varepsilon_{\\mathrm{naive}}, \\varepsilon_{3/2}]$（作为十进制浮点数）的列表。\n- 例如，输出应如下所示：[[eA_naive,eA_3over2],[eB_naive,eB_3over2],[eC_naive,eC_3over2],[eD_naive,eD_3over2]]。\n\n不需要用户输入。角度必须以弧度解释。除弧度外不涉及任何物理单位。程序必须是遵循所述过程的完整、可运行的实现。",
            "solution": "该问题是有效的，因为它在科学上基于数值分析和谱方法的原理，具有明确的目标且适定，并且不包含任何歧义或矛盾。\n\n任务是使用傅里叶伪谱方法，在周期性域 $[0, 2\\pi)$ 上计算二次非线性项 $g(x) = u(x)^2$ 的空间导数。我们将比较两种方法：一种是容易产生混叠误差的朴素计算，另一种是使用三分之二法则的去混叠计算。每种方法的准确性通过与精确解析导数相比的相对离散 $L^2$ 误差来量化。\n\n### 傅里叶谱微分原理\n\n在长度为 $L=2\\pi$ 的域上的周期函数 $f(x)$ 可以用傅里叶级数表示：\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{ikx}\n$$\n其中 $k$ 是整数波数，$c_k$ 是傅里叶系数。其导数则为：\n$$\nf'(x) = \\sum_{k=-\\infty}^{\\infty} ik c_k e^{ikx}\n$$\n在数值计算中，我们处理一个由 $N$ 个等距网格点 $x_j = 2\\pi j/N$（$j=0, \\dots, N-1$）组成的有限集合。函数由其在此网格上的值 $f_j = f(x_j)$ 表示。离散傅里叶变换 (DFT) 及其逆变换提供了物理空间表示 $f_j$ 和谱空间表示 $\\hat{f}_k$ 之间的映射，后者近似于缩放后的傅里叶系数 $N c_k$。可表示的整数波数集合是有限的，对于偶数 $N$，通常为 $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$。\n\n导数 $f'(x_j)$ 可以通过将 $f_j$ 变换到谱域，将每个系数 $\\hat{f}_k$ 乘以 $ik$，然后再变换回物理空间来计算：\n$$\nf'_j = \\mathcal{F}^{-1}\\{ ik \\hat{f}_k \\}_{k} \\quad \\text{where} \\quad \\hat{f}_k = \\mathcal{F}\\{f_j\\}_{j}\n$$\n此处，$\\mathcal{F}$ 表示 DFT（通过快速傅里叶变换 FFT 实现），$\\mathcal{F}^{-1}$ 是其逆变换。这个过程等效于应用一个稠密的微分矩阵 $\\mathbf{D}_N$，但在计算上以 $\\mathcal{O}(N \\log N)$ 的操作复杂度执行。\n\n### 非线性项的混叠问题\n\n在使用伪谱方法计算像 $g(x) = u(x)^2$ 这样的非线性项时，乘积是在物理空间的网格上计算的：$g_j = (u_j)^2$。如果 $u(x)$ 的傅里叶级数包含最高到波数 $k_{max}$ 的模式，那么乘积 $u(x)^2$ 将包含最高到 $2k_{max}$ 的模式。如果 $2k_{max}$ 超过了 $N$ 点网格上可表示的最高波数（对于非混叠模式是 $N/2-1$），高频内容就会“折叠”回低频，污染它们的系数。这种现象称为混叠。\n\n例如，在 $N$ 点网格上，模式 $e^{i(k+N)x_j} = e^{ikx_j}e^{iNx_j} = e^{ikx_j}e^{i2\\pi j} = e^{ikx_j}$。因此，波数 $k+N$ 与波数 $k$ 无法区分，或者说混叠到了波数 $k$。\n\n### 使用三分之二法则进行去混叠\n\n三分之二（$3/2$）法是一种无需混叠即可精确计算二次非线性的技术。其步骤如下：\n1.  从 $N$ 点网格上的函数值 $u_j$ 开始。\n2.  变换到谱空间以获得系数 $\\hat{u}_k$，其中 $|k|  N/2$。\n3.  将谱补零至更大的尺寸 $M \\ge \\frac{3}{2}N$。这将创建一个新的谱补零向量 $\\hat{u}^{(M)}_k$。原始系数被放置在更长向量中的相应位置，而新的高频位置则填充零。系数必须按因子 $M/N$进行缩放，以确保逆变换表示的是在更精细网格上采样的相同底层连续函数。\n4.  将 $\\hat{u}^{(M)}_k$ 逆变换到 $M$ 点的物理网格上，得到 $u^{(M)}_j$。这等效于在更精细的网格上评估 $u$ 的三角插值。\n5.  在这个更精细的网格上计算二次乘积：$g^{(M)}_j = (u^{(M)}_j)^2$。由于网格更精细，它可以无混叠地表示由乘积产生的高频。对于二次乘积，如果 $u$ 中的原始模式限于 $|k|  N/2$，则乘积模式限于 $|k|  N$。选择 $M \\ge \\frac{3}{2}N$ 可确保最高乘积模式（最高到 $N-1$）完全在 M 网格的非混叠范围（即 $|k|  M/2$）内。\n6.  将 $g^{(M)}_j$ 变换回谱域，得到 $\\hat{g}^{(M)}_k$。\n7.  通过丢弃由乘积产生的高频系数，将谱 $\\hat{g}^{(M)}_k$ 截断回尺寸 $N$。这将分离出可以在原始 $N$ 点网格上表示的谱部分。系数通过 $N/M$ 进行重新缩放。得到的向量 $\\hat{g}_k$ 是乘积的去混叠表示。\n8.  将谱微分算子（$ik$）应用于 $\\hat{g}_k$，并进行逆变换，以获得 $N$ 点网格上的去混叠导数。\n\n### 实现步骤\n\n对于每个测试用例，我们执行以下计算：\n1.  **网格与波数**：定义 $N$ 点网格 $x_j = 2\\pi j/N$ 和使用 `numpy.fft.fftfreq` 定义相应的整数波数向量 $k$。\n2.  **精确导数**：解析地求出 $u'(x)$，计算 $g'(x) = 2u(x)u'(x)$，并在网格 $x_j$ 上求值以得到向量 $g'_{\\mathrm{exact}}$。\n3.  **朴素导数**：\n    a. 在网格上计算 $u(x)$ 得到 $u_j$。\n    b. 计算逐元素的平方：$g_j = u_j^2$。\n    c. 计算导数 $g'_{\\mathrm{naive}, j} = \\mathcal{F}^{-1}\\{ik \\cdot \\mathcal{F}\\{g_j\\}\\}$。\n4.  **去混叠导数（$3/2$ 法则）**：\n    a. 计算 $\\hat{u}_k = \\mathcal{F}\\{u_j\\}$。\n    b. 创建一个尺寸为 $M = 3N/2$ 的零向量 $\\hat{u}^{(M)}_k$。通过从 $\\hat{u}_k$ 复制低半部分的的正负频率系数到 $\\hat{u}^{(M)}_k$ 中并按 $M/N$ 缩放来进行补零。\n    c. 计算 $u^{(M)}_j = \\mathcal{F}^{-1}\\{\\hat{u}^{(M)}_k\\}$。\n    d. 计算 $g^{(M)}_j = (u^{(M)}_j)^2$。\n    e. 计算 $\\hat{g}^{(M)}_k = \\mathcal{F}\\{g^{(M)}_j\\}$。\n    f. 通过创建一个尺寸为 $N$ 的向量 $\\hat{g}_k$，用 $\\hat{g}^{(M)}_k$ 中相应的低频系数填充它并按 $N/M$ 缩放来进行截断。\n    g. 计算导数 $g'_{3/2, j} = \\mathcal{F}^{-1}\\{ik \\cdot \\hat{g}_k\\}$。\n5.  **误差计算**：对于朴素和去混叠两种方法，计算相对离散 $L^2$ 误差：\n    $$ \\varepsilon = \\frac{\\| g'_{\\mathrm{approx}} - g'_{\\mathrm{exact}} \\|_2}{\\| g'_{\\mathrm{exact}} \\|_2} $$\n    其中 $\\|\\cdot\\|_2$ 是使用 `numpy.linalg.norm` 计算的标准欧几里得范数。\n\n此过程将应用于所有四个测试案例，并收集所得的误差对 $[\\varepsilon_{\\mathrm{naive}}, \\varepsilon_{3/2}]$。正如预期的那样，结果将表明，当发生混叠时（情况 B、C、D），朴素方法有显著误差，而 $3/2$ 法则去混叠能有效消除此误差，得到接近机器精度的结果。在情况 A 中，由于没有发生混叠，预计两种方法都将非常精确。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_case(N, u_func, u_prime_func):\n        \"\"\"\n        Computes naive and dealiased derivatives for a single test case\n        and returns their relative L2 errors.\n        \"\"\"\n        # 1. Setup grid, wavenumbers, and exact derivative\n        L = 2 * np.pi\n        x = np.linspace(0, L, N, endpoint=False)\n        k_N = np.fft.fftfreq(N) * N\n\n        u_vec = u_func(x)\n        u_prime_vec = u_prime_func(x)\n        g_prime_exact_vec = 2 * u_vec * u_prime_vec\n\n        # 2. Naive pseudo-spectral derivative\n        g_vec_naive = u_vec**2\n        g_hat_naive = np.fft.fft(g_vec_naive)\n        g_prime_hat_naive = 1j * k_N * g_hat_naive\n        g_prime_naive_vec = np.fft.ifft(g_prime_hat_naive)\n\n        # 3. 3/2-rule dealiased derivative\n        M = 3 * N // 2\n        \n        # Pad u from N to M grid\n        u_hat_N = np.fft.fft(u_vec)\n        u_hat_padded = np.zeros(M, dtype=np.complex128)\n        \n        N_half = N // 2\n        \n        # Copy low-frequency coefficients. The fft output for even N has\n        # k = 0, 1, ..., N/2-1 at indices 0..N/2-1\n        # k = -N/2, -N/2+1, ..., -1 at indices N/2..N-1\n        u_hat_padded[0:N_half] = u_hat_N[0:N_half]\n        u_hat_padded[M - (N - N_half):] = u_hat_N[N_half:]\n        \n        # Rescale coefficients for the larger transform size\n        u_hat_padded *= (M / N)\n\n        # Compute product on the padded grid\n        u_M_vec = np.fft.ifft(u_hat_padded)\n        # Taking .real to discard negligible imaginary parts from round-off\n        g_M_vec = u_M_vec.real**2\n        \n        # Truncate g from M back to N grid\n        g_hat_M = np.fft.fft(g_M_vec)\n        g_hat_N_dealiased = np.zeros(N, dtype=np.complex128)\n        \n        g_hat_N_dealiased[0:N_half] = g_hat_M[0:N_half]\n        g_hat_N_dealiased[N_half:] = g_hat_M[M - (N - N_half):]\n\n        # Rescale coefficients back to the original transform size\n        g_hat_N_dealiased *= (N / M)\n\n        # Differentiate the dealiased spectrum\n        g_prime_hat_32 = 1j * k_N * g_hat_N_dealiased\n        g_prime_32_vec = np.fft.ifft(g_prime_hat_32)\n\n        # 4. Error calculation\n        norm_exact = np.linalg.norm(g_prime_exact_vec)\n        \n        if norm_exact == 0:\n            err_naive = np.linalg.norm(g_prime_naive_vec.real - g_prime_exact_vec)\n            err_32 = np.linalg.norm(g_prime_32_vec.real - g_prime_exact_vec)\n        else:\n            err_naive = np.linalg.norm(g_prime_naive_vec.real - g_prime_exact_vec) / norm_exact\n            err_32 = np.linalg.norm(g_prime_32_vec.real - g_prime_exact_vec) / norm_exact\n\n        return [err_naive, err_32]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path, moderate nonlinearity\n        (32, lambda x: np.sin(3 * x) + 0.5 * np.cos(5 * x), \n             lambda x: 3 * np.cos(3 * x) - 2.5 * np.sin(5 * x)),\n        # Case B: High-frequency content near Nyquist limit on N\n        (32, lambda x: 0.7 * np.sin(10 * x) + 0.6 * np.cos(11 * x), \n             lambda x: 7 * np.cos(10 * x) - 6.6 * np.sin(11 * x)),\n        # Case C: Very coarse grid, strong aliasing\n        (8,  lambda x: np.sin(3 * x), \n             lambda x: 3 * np.cos(3 * x)),\n        # Case D: Moderate grid with modes near truncation\n        (48, lambda x: np.sin(12 * x) + 0.3 * np.sin(13 * x), \n             lambda x: 12 * np.cos(12 * x) + 3.9 * np.cos(13 * x))\n    ]\n\n    results = []\n    for N, u_func, u_prime_func in test_cases:\n        result = run_case(N, u_func, u_prime_func)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将应对谱方法最大的挑战之一：处理非光滑函数。本练习将向你展示在对包含跳跃间断的函数进行微分时，吉布斯现象（Gibbs phenomenon）如何产生伪振荡 。你将学习应用指数滤波器来抑制这些振荡，并通过寻找最优滤波器掌握一项处理实际问题的实用技能。",
            "id": "3417608",
            "problem": "设计并实现一个程序，该程序基于切比雪夫-洛巴托配置构建谱微分，并研究当对节点值应用指数滤波器时，吉布斯振荡对带有跳跃间断点的函数求导的影响。您的程序必须以数学上合理的方式执行以下任务，并报告指定测试套件的量化结果。\n\n从以下基本基础开始：\n- 在不同节点上使用拉格朗日基多项式 $\\ell_j(x)$，$0 \\le j \\le N$ 的拉格朗日形式多项式插值，以及插值多项式 $p_N(x)$ 在节点 $x_i$ 处满足 $p_N(x_i) = f(x_i)$ 的定义。\n- 与节点 $\\{x_j\\}_{j=0}^N$ 相关的微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 由 $D_{ij} = \\ell_j'(x_i)$ 定义，因此对于任何节点数据向量 $\\mathbf{f} = \\bigl(f(x_0),\\dots,f(x_N)\\bigr)^\\top$，插值多项式在节点处的导数由 $\\mathbf{p}_N'(x_i) = \\sum_{j=0}^N D_{ij} f(x_j)$ 给出。\n- 在 $[-1,1]$ 上的切比雪夫-洛巴托节点为 $x_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right)$，其中 $0 \\le j \\le N$。\n- 切比雪夫-洛巴托节点的重心权重为 $\\lambda_j = (-1)^j \\nu_j$，其中 $\\nu_0 = \\nu_N = \\tfrac{1}{2}$ 且对于 $1 \\le j \\le N-1$ 有 $\\nu_j = 1$；对应的$N$次插值多项式 $p_N(x)$ 的重心插值公式为\n$$\np_N(x) = \\frac{\\displaystyle \\sum_{j=0}^N \\frac{\\lambda_j}{x - x_j} f(x_j)}{\\displaystyle \\sum_{j=0}^N \\frac{\\lambda_j}{x - x_j}},\n$$\n该公式在节点处是精确的，并且对于 $x \\notin \\{x_j\\}$ 是稳定的。\n- 作用于切比雪夫模态的$p$阶指数滤波器由模态乘子 $\\sigma_k = \\exp\\!\\left(-\\alpha \\bigl(k/N\\bigr)^p\\right)$ 定义，其中 $0 \\le k \\le N$，强度 $\\alpha > 0$ 的选择使得 $\\sigma_N = \\varepsilon_{\\text{mach}}$，其中 $\\varepsilon_{\\text{mach}}$ 是双精度下的机器$\\varepsilon$。滤波的施加方式是：通过第一类离散余弦变换（DCT-I）将节点值转换为切比雪夫系数，乘以 $\\sigma_k$，然后通过逆DCT-I变换回节点值。\n\n需要实现的问任务：\n1. 对于每个给定整数 $N \\ge 2$ 的测试用例，构建 $[-1,1]$ 上的切比雪夫-洛巴托网格 $\\{x_j\\}_{j=0}^N$ 以及由上述拉格朗日基定义所蕴含的规范切比雪夫-洛巴托微分矩阵 $D$。\n2. 定义在 $x=0$ 处有跳跃间断点的不连续函数\n$$\nf(x) = \\begin{cases}\n-1,  x  0 \\\\\n1,  x \\ge 0\n\\end{cases}\n$$\n3. 给定一个候选的偶数滤波器阶数 $p \\in \\{2,4,8,16,32\\}$，以及解释为“无滤波”的基准 $p=0$，使用具有正交归一化的DCT-I对 $f(x)$ 的节点值应用$p$阶指数滤波器，以获得滤波后的节点值 $\\tilde{\\mathbf{f}}^{(p)}$。\n4. 使用 $\\tilde{\\mathbf{f}}^{(p)}$ 作为节点数据，定义相应的插值多项式 $\\tilde{p}_N^{(p)}(x)$ 及其导数 $\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)$。通过计算远离跳跃点处的导数的 $L^2$-范数量化微分中由吉布斯现象引起的误差，即\n$$\nE_p(N,\\varepsilon) \\;=\\; \\left(\\int_{-1}^{-\\varepsilon} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx \\;+\\; \\int_{\\varepsilon}^{1} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\n这里，$f(x)$ 的精确导数在 $[-1,0)$ 和 $(0,1]$ 上为零，所以上述量是在围绕间断点的一个半宽为 $\\varepsilon$ 的对称排除层之外计算的导数的 $L^2$-范数。您必须在两个子区间上分别使用 $Q$ 个点（取 $Q=200$）的高斯-勒让德求积法来近似每个积分。\n5. 对于每个测试用例，在候选阶数 $\\mathcal{P}=\\{0,2,4,8,16,32\\}$ 中，找到使 $E_p(N,\\varepsilon)$ 最小的阶数 $p^\\star \\in \\mathcal{P}$。如果在目标值上存在 $10^{-12}$ 数值容差内的平局，则报告达到最小值的最小 $p$。\n\n需要遵守的实现细节：\n- 用于求积的通用点上的微分必须是基于滤波后节点值构建的$N$次插值多项式的微分。您可以通过重心插值多项式的导数来计算。如果 $S(x) = \\sum_{j=0}^N \\frac{\\lambda_j}{x - x_j}$ 和 $T(x) = \\sum_{j=0}^N \\frac{\\lambda_j}{(x - x_j)^2}$，并且 $\\beta_j(x) = \\frac{\\lambda_j}{x - x_j}$，那么拉格朗日基的导数满足\n$$\n\\ell_j'(x) \\;=\\; \\frac{\\beta_j(x)}{S(x)^2}\\left(T(x) - \\frac{S(x)}{x - x_j}\\right),\n$$\n因此\n$$\n\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x) \\;=\\; \\sum_{j=0}^N \\tilde{f}^{(p)}_j \\, \\ell_j'(x).\n$$\n- 使用弧度作为角度度量。不涉及物理单位。\n- 使用编程语言提供的双精度机器$\\varepsilon$ $\\varepsilon_{\\text{mach}}$来设置 $\\alpha = -\\ln(\\varepsilon_{\\text{mach}})$。\n\n测试套件：\n- 情况 1: $N=16$, $\\varepsilon = \\frac{3}{N}$。\n- 情况 2: $N=15$, $\\varepsilon = \\frac{3}{N}$。\n- 情况 3: $N=64$, $\\varepsilon = \\frac{6}{N}$。\n- 情况 4: $N=8$, $\\varepsilon = 0.1$。\n\n对于每种情况，在 $\\mathcal{P}=\\{0,2,4,8,16,32\\}$ 中搜索，并返回最优阶 $p^\\star$ 和相应的最小误差 $E_{p^\\star}(N,\\varepsilon)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按上述测试用例排序，每对结果以整数 $p^\\star$ 紧跟着浮点值 $E_{p^\\star}(N,\\varepsilon)$ 的形式给出。例如，输出格式必须为\n$[p_1^\\star,E_1,p_2^\\star,E_2,p_3^\\star,E_3,p_4^\\star,E_4]$ 的形式。",
            "solution": "该问题的解决方案涉及设计一种数值算法，以研究指数滤波对不连续函数谱微分的影响。任务的核心是量化滤波如何减轻吉布斯现象，该现象表现为谱插值不连续函数的导数中的伪振荡。该方法论分解为几个独立且原理清晰的步骤：离散化、滤波、微分、误差计算和优化。\n\n首先，使用一组 $N+1$ 个切比雪夫-洛巴托节点对空间域 $[-1, 1]$ 进行离散化，节点定义为 $x_j = \\cos(\\frac{\\pi j}{N})$，其中 $j = 0, 1, \\dots, N$。这些节点是第一类$N$次切比雪夫多项式 $T_N(x)$ 的极值点，由于它们在边界附近聚集，有助于减轻龙格现象，因此特别适合多项式插值。待分析的不连续函数由下式给出\n$$\nf(x) = \\begin{cases}\n-1,  x  0 \\\\\n1,  x \\ge 0.\n\\end{cases}\n$$\n在切比雪夫节点上对该函数进行采样，生成一个节点值向量 $\\mathbf{f} = (f(x_0), f(x_1), \\dots, f(x_N))^\\top$。该向量代表了谱方法物理空间中的函数。\n\n其次，对节点数据应用指数滤波器。这是在谱空间或模态空间中执行的，该空间通过第一类离散余弦变换（DCT-I）与物理空间相关联。使用正交归一化的DCT-I将节点值向量 $\\mathbf{f}$ 转换为切比雪夫系数向量 $\\mathbf{a}$。然后，通过将系数与一组乘子 $\\sigma_k$ 进行逐元素相乘来施加滤波器。对于偶数阶滤波器 $p$，这些乘子定义为 $\\sigma_k = \\exp(-\\alpha (k/N)^p)$，其中 $k = 0, 1, \\dots, N$。参数 $\\alpha > 0$ 控制滤波器的强度，并设置为 $\\alpha = -\\ln(\\varepsilon_{\\text{mach}})$，其中 $\\varepsilon_{\\text{mach}}$ 是机器$\\varepsilon$。这一选择确保滤波器严重阻尼最高频率的模态（对应于 $k=N$），有效地将 $\\sigma_N$ 设置为接近零的值。滤波器阶数 $p$ 控制滤波器的形状：较高的阶数会产生一个更平坦的滤波器，其向零的过渡更为急剧，从而在积极切断高频模态的同时保留更多的低频模态。相乘后，滤波后的系数 $\\tilde{a}_k = \\sigma_k a_k$ 通过逆DCT-I（对于正交归一化变体，它本身就是DCT-I）变换回物理空间，得到滤波后的节点值向量 $\\tilde{\\mathbf{f}}^{(p)}$。$p=0$ 的情况对应于对所有 $k$ 都有 $\\sigma_k=1$，这意味着不应用滤波。\n\n第三，必须计算与滤波后节点值对应的插值多项式 $\\tilde{p}_N^{(p)}$ 的导数。虽然可以构建一个微分矩阵 $D$，但通过对重心插值公式求导，可以更准确、更稳定地在任意点（求积所需）上评估导数。通过滤波后数据 $\\{ (x_j, \\tilde{f}^{(p)}_j) \\}_{j=0}^N$ 的$N$次多项式插值由下式给出\n$$\n\\tilde{p}_N^{(p)}(x) = \\frac{\\displaystyle\\sum_{j=0}^{N} \\frac{\\lambda_j}{x - x_j} \\tilde{f}^{(p)}_j}{\\displaystyle\\sum_{k=0}^{N} \\frac{\\lambda_k}{x - x_k}},\n$$\n其中 $\\lambda_j$ 是切比雪夫-洛巴托节点的重心权重：$\\lambda_j = (-1)^j \\nu_j$，其中 $\\nu_0 = \\nu_N = \\frac{1}{2}$ 且对于 $1 \\le j \\le N-1$ 有 $\\nu_j = 1$。通过应用商法则，该插值多项式的导数可以表示为一种数值稳定的形式：\n$$\n\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x) = \\frac{1}{\\sum_{k=0}^{N} \\frac{\\lambda_k}{x-x_k}} \\sum_{j=0}^{N} \\frac{\\lambda_j}{(x-x_j)^2} \\left( \\tilde{p}_N^{(p)}(x) - \\tilde{f}^{(p)}_j \\right).\n$$\n此公式用于计算任何不与节点重合的点 $x$ 处的导数。\n\n第四，量化由导数中的吉布斯振荡引起的误差。$f(x)$ 的真实导数在除 $x=0$ 之外的所有地方都为零，在 $x=0$ 处它是一个狄拉克$\\delta$函数。计算出的导数 $\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)$ 在排除跳跃点周围的小区间 $[-\\varepsilon, \\varepsilon]$ 的域上的 $L^2$-范数，可作为伪振荡的度量。该误差定义为\n$$\nE_p(N,\\varepsilon) = \\left( \\int_{-1}^{-\\varepsilon} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx + \\int_{\\varepsilon}^{1} \\left(\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\n这些积分使用高斯-勒让德求积法进行数值计算。对于两个子区间 $[-1, -\\varepsilon]$ 和 $[\\varepsilon, 1]$ 中的每一个，都采用具有 $Q=200$ 个点的高阶求积法则。在每个求积点上，使用重心公式评估导数 $\\bigl(\\tilde{p}_N^{(p)}\\bigr)'(x)$。\n\n最后，对于每个测试用例 $(N, \\varepsilon)$，对每个候选滤波器阶数 $p \\in \\mathcal{P}=\\{0,2,4,8,16,32\\}$ 执行整个过程。比较得到的误差 $E_p(N,\\varepsilon)$。最优滤波器阶数 $p^\\star$ 被确定为最小化此误差的阶数。比较时使用 $10^{-12}$ 的数值容差，在出现平局的情况下，选择最小的阶数 $p$。该算法在Python中实现，利用 `numpy` 进行数组操作，利用 `scipy.fft` 进行DCT-I变换。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct, idct\n\ndef barycentric_derivative(x_eval, f_nodes, x_nodes, lambda_weights):\n    \"\"\"\n    Computes the derivative of a polynomial interpolant in barycentric form.\n\n    Args:\n        x_eval (np.ndarray): Points at which to evaluate the derivative.\n        f_nodes (np.ndarray): Function values at the interpolation nodes.\n        x_nodes (np.ndarray): Interpolation nodes.\n        lambda_weights (np.ndarray): Barycentric weights.\n\n    Returns:\n        np.ndarray: The derivative of the interpolant at x_eval points.\n    \"\"\"\n    # Vectorized computation for efficiency.\n    # The dimensions are (num_eval_points, num_nodes).\n    xdiff = np.subtract.outer(x_eval, x_nodes)\n    \n    # Add a small epsilon to denominator to avoid runtime warnings for divisions\n    # by almost zero, though in this problem x_eval points never equal x_nodes.\n    xdiff[xdiff == 0] = 1e-30\n\n    beta = lambda_weights / xdiff\n    \n    # S is the denominator of barycentric formula, shape (num_eval_points,).\n    S = np.sum(beta, axis=1)\n    \n    # U is the numerator, shape (num_eval_points,).\n    # Broadcasting f_nodes across rows of beta.\n    U = np.sum(beta * f_nodes, axis=1)\n    \n    # p_at_x is the interpolated value, p(x), shape (num_eval_points,).\n    p_at_x = U / S\n    \n    # Derivative formula: (1/S) * sum_j [lambda_j/(x-xj)^2 * (p(x) - f_j)]\n    term1 = lambda_weights / (xdiff**2)\n    # Broadcasting p_at_x and f_nodes to create a (num_eval_points, num_nodes) matrix.\n    term2 = p_at_x[:, np.newaxis] - f_nodes[np.newaxis, :]\n    summand = term1 * term2\n    \n    # Sum over j (axis=1) and divide by S.\n    derivs = np.sum(summand, axis=1) / S\n    \n    return derivs\n\n\ndef calculate_error(N, epsilon, f_tilde, x_nodes, Q, lambda_weights):\n    \"\"\"\n    Calculates the L2-norm of the derivative error away from the discontinuity.\n\n    Args:\n        N (int): Degree of the polynomial interpolant.\n        epsilon (float): Half-width of the exclusion zone around the jump.\n        f_tilde (np.ndarray): Filtered nodal values.\n        x_nodes (np.ndarray): Chebyshev nodes.\n        Q (int): Number of quadrature points.\n        lambda_weights (np.ndarray): Barycentric weights.\n\n    Returns:\n        float: The calculated L2 error.\n    \"\"\"\n    gl_nodes, gl_weights = np.polynomial.legendre.leggauss(Q)\n    total_integral = 0.0\n\n    # Integral over [-1, -epsilon]\n    a1, b1 = -1.0, -epsilon\n    if b1 > a1: # Interval is valid\n        quad_points1 = 0.5 * (b1 - a1) * gl_nodes + 0.5 * (b1 + a1)\n        deriv_vals1 = barycentric_derivative(quad_points1, f_tilde, x_nodes, lambda_weights)\n        integral1 = 0.5 * (b1 - a1) * np.sum(gl_weights * (deriv_vals1**2))\n        total_integral += integral1\n\n    # Integral over [epsilon, 1]\n    a2, b2 = epsilon, 1.0\n    if b2 > a2: # Interval is valid\n        quad_points2 = 0.5 * (b2 - a2) * gl_nodes + 0.5 * (b2 + a2)\n        deriv_vals2 = barycentric_derivative(quad_points2, f_tilde, x_nodes, lambda_weights)\n        integral2 = 0.5 * (b2 - a2) * np.sum(gl_weights * (deriv_vals2**2))\n        total_integral += integral2\n\n    return np.sqrt(total_integral) if total_integral > 0 else 0.0\n\n\ndef run_case(N, epsilon):\n    \"\"\"\n    Executes the analysis for a single test case (N, epsilon).\n\n    Args:\n        N (int): The polynomial degree.\n        epsilon (float): The exclusion half-width.\n\n    Returns:\n        tuple: (p_star, E_star) optimal filter order and corresponding error.\n    \"\"\"\n    p_candidates = [0, 2, 4, 8, 16, 32]\n    Q = 200\n    mach_eps = np.finfo(float).eps\n    alpha = -np.log(mach_eps)\n\n    # Step 1: Define grid and sample function\n    j = np.arange(N + 1)\n    x_nodes = np.cos(np.pi * j / N)\n    f_vals = np.where(x_nodes  0, -1.0, 1.0)\n    \n    # Step 2: Define barycentric weights\n    lambda_weights = (-1.0)**j\n    lambda_weights[0] *= 0.5\n    lambda_weights[N] *= 0.5\n\n    errors = {}\n    for p in p_candidates:\n        # Step 3: Apply filter\n        if p == 0:\n            f_tilde = f_vals\n        else:\n            k = np.arange(N + 1)\n            sigma = np.exp(-alpha * (k / N)**p)\n            coeffs = dct(f_vals, type=1, norm='ortho')\n            coeffs_tilde = coeffs * sigma\n            f_tilde = idct(coeffs_tilde, type=1, norm='ortho')\n        \n        # Step 4: Calculate error\n        Ep = calculate_error(N, epsilon, f_tilde, x_nodes, Q, lambda_weights)\n        errors[p] = Ep\n    \n    # Step 5: Find optimal p\n    min_error_val = min(errors.values())\n    tolerance = 1e-12\n    best_p = -1\n    min_error = float('inf')\n\n    for p in p_candidates: # p_candidates are already sorted ascendingly\n        if np.abs(errors[p] - min_error_val) = tolerance:\n            best_p = p\n            min_error = errors[p]\n            # Since we iterate in increasing p, the first match is the smallest p.\n            break\n\n    return best_p, min_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (16, 3.0/16.0),\n        (15, 3.0/15.0),\n        (64, 6.0/64.0),\n        (8, 0.1)\n    ]\n\n    results = []\n    for N, epsilon in test_cases:\n        p_star, E_star = run_case(N, epsilon)\n        results.append(p_star)\n        results.append(E_star)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}