{
    "hands_on_practices": [
        {
            "introduction": "谱方法的核心思想是，物理空间中的微分运算在变换空间中会简化为简单的乘法运算。这第一个练习将指导你使用快速傅里叶变换（FFT）来实现这一基本概念。通过处理良解析信号、混叠以及奈奎斯特频率等案例，你将为所有后续的谱计算打下坚实的基础。",
            "id": "3417201",
            "problem": "要求您设计并实现一个程序，该程序使用谱方法微分，并通过快速傅里叶变换（FFT）在变换空间中计算周期函数的一阶导数。其基本原理是，物理域中的微分对应于傅里叶域中乘以虚数单位与角波数的乘积。所有角度必须以弧度为单位。\n\n使用的基本原理如下。考虑一个在长度为 $L$ 的周期区间上、在均匀网格上采样的周期函数。设网格为 $x_j = j\\Delta x$，其中 $j = 0, 1, \\dots, N-1$，且 $\\Delta x = L/N$。离散傅里叶变换（DFT）及其逆变换定义如下（取决于库约定所选择的归一化常数）：\n$$\nU_k = \\sum_{j=0}^{N-1} u_j \\, e^{-i \\kappa_k x_j}, \\quad\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k \\, e^{i \\kappa_k x_j},\n$$\n其中 $u_j = u(x_j)$，$\\kappa_k$ 是对应于由 $k$ 索引的整数傅里叶模的角波数。对于长度为 $L$ 的周期域，连续傅里叶模为 $e^{i m (2\\pi/L) x}$（其中 $m$ 为整数），因此角波数为 $\\kappa = (2\\pi/L) m$。\n\n要使用的关键且经过充分检验的事实是，对于每个傅里叶模 $e^{i \\kappa x}$，其导数满足\n$$\n\\frac{d}{dx} \\left( e^{i \\kappa x} \\right) = i \\kappa \\, e^{i \\kappa x}.\n$$\n因此，在傅里叶域中的微分对应于乘以 $i \\kappa$。\n\n通过将DFT索引映射到与周期网格一致的整数来构建角波数数组。对于偶数 $N$，整数波数的标准排序为 $0, 1, \\dots, N/2-1, -N/2, -N/2+1, \\dots, -1$。相应的角波数为 $\\kappa_k = (2\\pi/L) \\, m_k$，其中 $m_k$ 遵循指定的排序。当 $N$ 为偶数时，才会出现 $m = N/2$ 处的奈奎斯特模；谱方法微分中的常规选择是将奈奎斯特系数的导数乘子设置为零，以保持实数输入数据在物理域中导数的实值性。\n\n您的实现必须遵循以下逻辑步骤，严格遵守上述原则，不得使用任何未经论证的快捷公式：\n1. 在 $[0, L)$ 区间上，用 $N$ 个点在等距网格 $x_j$ 上对函数 $u(x)$ 进行采样。\n2. 使用快速傅里叶变换（FFT）计算DFT系数 $U_k$。\n3. 根据给定的 $L$ 和 $N$，从DFT频率箱构建角波数数组 $\\kappa_k$，确保负频率的排序正确。对于偶数 $N$，将奈奎斯特索引处的导数乘子设置为零。\n4. 构建微分谱 $\\widehat{u'}_k = i \\, \\kappa_k \\, U_k$。\n5. 计算 $\\widehat{u'}_k$ 的逆离散傅里叶变换（inverse DFT），以获得物理域中的微分值 $u'_j$。请一致地使用您所用FFT库的约定。\n6. 提取 $u'_j$ 的实部，并根据要求报告误差或诊断值。\n\n测试套件。您的程序必须计算并汇总以下测试用例，每个用例产生一个实数。除非另有说明，否则使用 $N = 16$，角度以弧度为单位。\n\n- 用例 A（理想情况，精确可解性）：设 $L = 2\\pi$。定义 $u(x) = \\sin(3x) + 0.5 \\cos(5x)$。计算谱方法导数和解析导数 $u'(x) = 3 \\cos(3x) - 2.5 \\sin(5x)$。以浮点数形式报告最大绝对误差 $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$。\n\n- 用例 B（奈奎斯特模处理）：设 $L = 2\\pi$。定义 $u(x) = \\cos\\!\\big((N/2) x\\big) = \\cos(8x)$。计算谱方法导数，其在采样网格上应恒为零，因为导数与在 $x_j = 2\\pi j/N$ 处求值的 $\\sin\\!\\big((N/2) x\\big)$ 成正比，而后者在这些点上为零。以浮点数形式报告 $\\max_j |u'_j|$。\n\n- 用例 C（超越奈奎斯特频率的混叠）：设 $L = 2\\pi$。定义 $u(x) = \\sin(9x)$。在 $N=16$ 的离散网格上，该函数会混叠为 $-\\sin(7x)$。谱方法将返回与此混叠表示一致的导数，即在网格上约等于 $-7 \\cos(7x)$。以浮点数形式报告谱方法导数与混叠导数之间的最大绝对误差，\n$$\n\\max_j \\left| u'_j - \\left( -7 \\cos(7 x_j) \\right) \\right|,\n$$\n。\n\n- 用例 D（非单位域长度缩放）：设 $L = 4\\pi$。定义\n$$\nu(x) = \\sin\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) + 0.5 \\cos\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\n解析导数为\n$$\nu'(x) = \\left(3 \\cdot \\frac{2\\pi}{L}\\right) \\cos\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) - 0.5 \\left(5 \\cdot \\frac{2\\pi}{L}\\right) \\sin\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\n以浮点数形式报告最大绝对误差 $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$。\n\n最终输出格式。您的程序应产生单行输出，其中包含按 [用例A, 用例B, 用例C, 用例D] 顺序排列、由方括号括起来的逗号分隔的结果列表。例如，格式为“[resultA,resultB,resultC,resultD]”的一行。",
            "solution": "问题陈述已经过严格验证，并被确定为是合理的。它具有科学依据，提法恰当，客观，并为实现谱微分算法提供了一套完整且一致的要求。该问题是数值谱方法中的一个标准练习，与指定主题直接相关。因此，我们可以着手提供一个正式的解决方案。\n\n对长度为 $L$ 的域上的周期函数 $u(x)$ 进行谱微分的核心原理基于其傅里叶级数表示。任何足够平滑的周期函数都可以表示为复指数的和：\n$$\nu(x) = \\sum_{m=-\\infty}^{\\infty} \\hat{u}_m e^{i \\kappa_m x}\n$$\n其中 $\\hat{u}_m$ 是傅里叶系数，$\\kappa_m = m \\frac{2\\pi}{L}$ 是整数模 $m$ 的角波数。傅里叶基的一个关键性质是微分在此基底下是对角的。逐项对级数进行微分可得：\n$$\n\\frac{d u(x)}{dx} = \\sum_{m=-\\infty}^{\\infty} (i \\kappa_m) \\hat{u}_m e^{i \\kappa_m x}\n$$\n这表明，在傅里叶域中，函数 $u(x)$ 的微分对应于其傅里叶系数 $\\hat{u}_m$ 乘以因子 $i\\kappa_m$。\n\n对于计算实现，我们处理的是函数的离散化版本。函数 $u(x)$ 在一个包含 $N$ 个点的均匀网格上采样，$x_j = j \\Delta x$，$j=0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = L/N$。离散函数值为 $u_j = u(x_j)$。连续傅里叶级数被离散傅里叶变换（DFT）所取代，DFT将物理空间值 $u_j$ 与一组 $N$ 个离散傅里叶系数 $U_k$ 相关联。在标准数值库（如`numpy`）中实现的正向和逆向DFT对定义如下：\n$$\nU_k = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi j k / N} \\quad (\\text{FFT})\n$$\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k e^{i 2\\pi j k / N} \\quad (\\text{iFFT})\n$$\n这里，索引 $k$ 的范围从 $0$ 到 $N-1$，代表离散频率箱。为了应用微分原理，我们必须将这些索引映射到正确的物理角波数 $\\kappa_k$。在一个包含 $N$ 个点的网格上可以唯一表示的整数波数 $m$ 的集合涵盖了从负到正的值。对于偶数点数 $N$，标准约定将对应于DFT索引 $k=0, 1, \\dots, N-1$ 的整数模 $m_k$ 排列为 $m_k \\in \\{0, 1, \\dots, N/2-1, -N/2, -N/2+1, \\dots, -1\\}$。与每个DFT索引 $k$ 相关联的物理角波数则由下式给出：\n$$\n\\kappa_k = m_k \\frac{2\\pi}{L}\n$$\n这个波数数组可以通过算法生成。谱微分的一个关键方面是处理奈奎斯特频率，它对应于偶数 $N$ 时的整数模 $|m| = N/2$。根据规定，奈奎斯特模系数的导数乘子被设置为零。这种做法确保了实值函数的计算导数保持为实值，并有助于稳定数值方案。\n\n完整的谱微分算法如下：\n1.  **离散化**：给定函数 $u(x)$、域长度 $L$ 和点数 $N$，生成网格值 $u_j = u(x_j)$，其中 $x_j = j L/N$，$j=0, \\dots, N-1$。\n2.  **正向变换**：使用快速傅里叶变换（FFT）算法计算离散信号 $u_j$ 的DFT系数 $U_k = \\text{FFT}(u_j)$。\n3.  **构建波数**：构建与FFT频率箱对应的角波数数组 $\\kappa_k$。对于每个索引 $k \\in \\{0, \\dots, N-1\\}$，计算 $\\kappa_k$。如果 $N$ 是偶数，则强制执行条件 $\\kappa_{N/2} = 0$。\n4.  **在傅里叶空间中微分**：将傅里叶系数 $U_k$ 乘以 $i\\kappa_k$ 以获得导数的系数，$\\widehat{u'}_k = i \\kappa_k U_k$。\n5.  **逆变换**：计算微分后系数 $\\widehat{u'}_k$ 的逆FFT，以变换回物理空间，从而得到导数的离散值：$u'_j = \\text{iFFT}(\\widehat{u'}_k)$。\n6.  **最终结果**：对于实值输入函数 $u(x)$，计算出的导数 $u'_j$ 应该是实数。由于有限精度算术，可能会出现可忽略的虚部，通过取结果的实部将其丢弃。\n\n此过程应用于每个测试用例。\n-   **用例A** 和 **用例D** 测试了该方法对于良好解析函数（即频率远低于奈奎斯特极限的函数）的准确性，其中用例D专门测试了实现对非标准域长度 $L$ 的处理。对于此类函数，谱方法导数预计能达到机器精度。\n-   **用例B** 测试了对奈奎斯特频率的指定处理方式。在 $N=16$ 和 $L=2\\pi$ 的网格上，函数 $u(x) = \\cos(8x)$ 恰好对应奈奎斯特频率。该算法必须产生零导数，因为其解析导数 $-8\\sin(8x)$ 在所有网格点 $x_j=j\\pi/8$ 处均为零。\n-   **用例C** 测试了混叠现象。对于 $N=16$，函数 $u(x) = \\sin(9x)$ 的频率高于奈奎斯特极限。在离散网格上，它与低频函数 $-\\sin(7x)$ 无法区分（即混叠为此函数）。谱方法作用于网格数据，正确地计算了这个混叠表示的导数，即 $-7\\cos(7x)$。",
            "answer": "```python\nimport numpy as np\n\ndef spectral_derivative(u: np.ndarray, L: float) - np.ndarray:\n    \"\"\"\n    Computes the first derivative of a periodic function u on a domain of length L\n    using the Fourier spectral method.\n\n    Args:\n        u: A numpy array of function values sampled on a uniform grid.\n        L: The length of the periodic domain.\n\n    Returns:\n        A numpy array containing the values of the spectral derivative on the grid.\n    \"\"\"\n    N = len(u)\n    \n    # 1. Construct the angular wavenumber array.\n    # The sample spacing is d = L/N. np.fft.fftfreq returns frequencies in\n    # cycles per unit of d. Here, this is cycles/distance.\n    # The angular wavenumber is kappa = 2*pi*frequency.\n    # The fftfreq function correctly orders positive and negative frequencies\n    # for the DFT output.\n    freq = np.fft.fftfreq(N, d=L/N)\n    kappa = 2 * np.pi * freq\n\n    # 2. Handle the Nyquist frequency for even N.\n    # As per the problem specification, the derivative multiplier for the Nyquist\n    # coefficient must be zeroed out. This corresponds to the FFT index N//2.\n    if N % 2 == 0:\n        kappa[N//2] = 0.0\n\n    # 3. Compute the FFT of the function.\n    U = np.fft.fft(u)\n\n    # 4. Multiply by i*kappa in Fourier space to perform differentiation.\n    U_prime = 1j * kappa * U\n\n    # 5. Compute the Inverse FFT to return to physical space.\n    u_prime = np.fft.ifft(U_prime)\n\n    # 6. For a real input, the derivative is real. Return the real part\n    # to discard any imaginary noise from floating-point inaccuracies.\n    return u_prime.real\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the spectral differentiation algorithm and\n    prints the results in the specified format.\n    \"\"\"\n    # Globally specified parameter for test cases\n    N_global = 16\n\n    results = []\n\n    # Case A: Happy path, exact resolvability\n    L_A = 2.0 * np.pi\n    x_A = np.arange(N_global) * L_A / N_global\n    u_A = np.sin(3.0 * x_A) + 0.5 * np.cos(5.0 * x_A)\n    u_prime_analytic_A = 3.0 * np.cos(3.0 * x_A) - 2.5 * np.sin(5.0 * x_A)\n    u_prime_spectral_A = spectral_derivative(u_A, L_A)\n    error_A = np.max(np.abs(u_prime_spectral_A - u_prime_analytic_A))\n    results.append(error_A)\n\n    # Case B: Nyquist mode handling\n    L_B = 2.0 * np.pi\n    x_B = np.arange(N_global) * L_B / N_global\n    u_B = np.cos((N_global / 2.0) * x_B)\n    u_prime_spectral_B = spectral_derivative(u_B, L_B)\n    # The spectral derivative should be identically zero due to Nyquist handling.\n    # We report the maximum absolute value of the computed derivative.\n    error_B = np.max(np.abs(u_prime_spectral_B))\n    results.append(error_B)\n\n    # Case C: Aliasing beyond Nyquist\n    L_C = 2.0 * np.pi\n    x_C = np.arange(N_global) * L_C / N_global\n    u_C = np.sin(9.0 * x_C)\n    # On the grid, sin(9x) aliases to -sin(7x). The spectral method\n    # differentiates this aliased representation, yielding -7*cos(7x).\n    u_aliased_deriv_C = -7.0 * np.cos(7.0 * x_C)\n    u_prime_spectral_C = spectral_derivative(u_C, L_C)\n    error_C = np.max(np.abs(u_prime_spectral_C - u_aliased_deriv_C))\n    results.append(error_C)\n\n    # Case D: Non-unit domain length scaling\n    L_D = 4.0 * np.pi\n    x_D = np.arange(N_global) * L_D / N_global\n    # Fundamental wavenumber for this domain\n    k0_D = 2.0 * np.pi / L_D\n    u_D = np.sin(3.0 * k0_D * x_D) + 0.5 * np.cos(5.0 * k0_D * x_D)\n    u_prime_analytic_D = \\\n        (3.0 * k0_D) * np.cos(3.0 * k0_D * x_D) - \\\n        0.5 * (5.0 * k0_D) * np.sin(5.0 * k0_D * x_D)\n    u_prime_spectral_D = spectral_derivative(u_D, L_D)\n    error_D = np.max(np.abs(u_prime_spectral_D - u_prime_analytic_D))\n    results.append(error_D)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然对线性函数进行微分是直接的，但像乘积这样的非线性运算会引入混叠误差，即高频分量会污染计算结果。本练习通过计算一个函数乘积的导数来展示这个关键问题。你将实现并比较一种朴素方法和一种标准的去混叠技术——“三分之二规则”，从而获得处理谱模拟中非线性项的实用技能。",
            "id": "3417276",
            "problem": "考虑在区间 $[0,2\\pi)$ 的均匀周期网格上采样的 $2\\pi$-周期函数 $u(x)=\\sin(ax)$ 和 $v(x)=\\cos(bx)$，该网格有 $N$ 个点，其中 $x_j=\\frac{2\\pi j}{N}$，$j=0,1,\\dots,N-1$，角度以弧度为单位。目标是使用快速傅里叶变换 (FFT) 在变换空间中通过谱方法计算空间导数 $\\partial_x(uv)$，计算过程分为两种：一种不进行去混叠，另一种通过 $3/2$ 补零实现三分之二法则去混叠。然后，通过与从第一性原理得到的精确解析导数进行比较，来量化混叠误差。\n\n从以下基本原理出发：\n- $2\\pi$-周期函数 $f(x)$ 的傅里叶级数表示，以及通过快速傅里叶变换 (FFT) 计算的离散傅里叶变换 (DFT)。\n- 变换空间中的导数恒等式：对于每个傅里叶模式 $e^{\\mathrm{i}kx}$，成立 $\\partial_x e^{\\mathrm{i}kx}=\\mathrm{i}k e^{\\mathrm{i}kx}$。\n- 乘法法则 $\\partial_x(uv)=u_x v + u v_x$。\n\n设计一个程序，针对下述每个测试用例，执行以下任务：\n1. 在 $N$ 个网格点上计算 $w(x)=u(x)v(x)$，然后将 $w$ 变换到傅里叶空间，乘以 $\\mathrm{i}k$，再变换回来，从而计算这些点上的 $\\partial_x w$。使用与 $[0,2\\pi)$ 域一致的角波数 $k$。这是不进行去混叠的计算。\n2. 使用通过 $3/2$ 补零实现的三分之二法则进行去混叠来计算 $\\partial_x w$：将 $u$ 和 $v$ 的离散傅里叶变换从长度 $N$ 补零到长度 $M=\\frac{3N}{2}$ (确保系数被正确缩放，以便逆变换在更精细的网格上计算出相同的连续傅里叶内容)，逆变换到 $M$ 点网格，在 $M$ 点网格上逐点形成乘积 $w$，将 $w$ 变换回傅里叶空间，在分辨率为 $M$ 的情况下乘以 $\\mathrm{i}k$，将得到的频谱截断回长度 $N$ (使用逆向缩放以保留低频内容)，并逆变换回原始的 $N$ 点网格。\n3. 使用乘法法则以及 $u$ 和 $v$ 的定义，计算在 $N$ 个网格点上取值的精确解析导数 $\\partial_x(uv)$。\n4. 对于未去混叠和去混叠的计算，将其相对于精确解析导数的相对离散 $\\ell^2$ 误差量化为\n$$\nE_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是 $N$ 个采样网格点上的欧几里得范数。\n\n您的程序必须实现基于 FFT 的谱微分，其中角波数 $k$ 根据采样间距 $\\Delta x = \\frac{2\\pi}{N}$ 从 DFT 频率数组构造，以确保角波数为整数。程序还必须实现 $3/2$ 补零过程，并在填充和截断频谱时进行一致的缩放，以保持低频傅里葉模式的振幅。\n\n测试套件：\n使用以下五个测试用例来检验不同的混叠情况。每个测试用例是一个元组 $(N,a,b)$，角度单位为弧度：\n- 用例 1 (无混叠，低波数)：$(16,3,4)$。\n- 用例 2 (强混叠，高但可解析的输入，其乘积会激发出高于奈奎斯特频率的模式)：$(16,7,7)$。\n- 用例 3 (在更高分辨率下无混叠)：$(32,12,13)$。\n- 用例 4 (在分辨率极限附近出现混叠)：$(32,15,17)$。\n- 用例 5 (在中等分辨率下出现混叠)：$(24,8,10)$。\n\n答案规格：\n对于每个测试用例，计算相对 $\\ell^2$ 误差对 $[E_{\\ell^2}^{\\text{no-dealias}}, E_{\\ell^2}^{\\text{dealias}}]$。将所有五个用例的结果汇总到单行输出中，该行包含一个由五个此类误差对组成的列表。您的程序应生成单行输出，其中包含一个用逗号分隔的列表形式的结果，该列表用方括号括起来，不含空格，其中每个误差对本身也是一个用方括号括起来的逗号分隔列表。例如：`[[e11,e12],[e21,e22],[e31,e32],[e41,e42],[e51,e52]]`。所有角度必须按弧度处理。除弧度外，不涉及其他物理单位，也无需进行转换。",
            "solution": "The user wants me to solve a problem that involves computing the derivative of a product of two trigonometric functions using spectral methods and quantifying the aliasing error.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Functions**: $u(x) = \\sin(ax)$ and $v(x) = \\cos(bx)$ are $2\\pi$-periodic.\n- **Domain**: Uniform grid on $[0, 2\\pi)$ with $N$ points, $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$.\n- **Task**: Compute the spatial derivative $\\partial_x(uv)$.\n- **Method 1 (No De-aliasing)**: Compute the product $w=uv$ in physical space, transform to Fourier space using FFT, multiply each mode $\\hat{w}(k)$ by $\\mathrm{i}k$, and transform back using IFFT.\n- **Method 2 (De-aliasing via Two-Thirds Rule)**: \n    1. Pad the Fourier transforms of $u$ and $v$ from length $N$ to $M = \\frac{3N}{2}$.\n    2. Apply scaling to the padded spectra.\n    3. Inverse transform to the $M$-point grid.\n    4. Compute the product $w=uv$ on the $M$-point grid.\n    5. Transform $w$ to the $M$-dimensional Fourier space.\n    6. Multiply each mode $\\hat{w}(k)$ by $\\mathrm{i}k$ (using wavenumbers for the $M$-point grid).\n    7. Truncate the resulting spectrum back to length $N$.\n    8. Apply inverse scaling.\n    9. Inverse transform to the original $N$-point grid.\n- **Method 3 (Exact Analytical Derivative)**: Compute $\\partial_x(uv)$ using the product rule: $\\partial_x(uv) = (\\partial_x u)v + u(\\partial_x v)$.\n- **Error Metric**: The relative discrete $\\ell^2$ error, $E_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2}$, where $\\|\\cdot\\|_2$ is the Euclidean norm over the $N$ grid points.\n- **Wavenumbers**: The angular wavenumbers $k$ must be integers consistent with the domain.\n- **Test Suite**:\n    - Case 1: $(N, a, b) = (16, 3, 4)$\n    - Case 2: $(N, a, b) = (16, 7, 7)$\n    - Case 3: $(N, a, b) = (32, 12, 13)$\n    - Case 4: $(N, a, b) = (32, 15, 17)$\n    - Case 5: $(N, a, b) = (24, 8, 10)$\n- **Output Format**: A single-line string representation of a list of five pairs: `[[e1_no_dealias,e1_dealias], [e2_no_dealias,e2_dealias], ...]`.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is a standard exercise in numerical analysis, specifically within the field of spectral methods. It correctly utilizes Fourier transforms for differentiation and addresses the well-known phenomenon of aliasing. The proposed de-aliasing method (the two-thirds rule implemented via zero-padding) is a canonical technique. All principles are sound.\n- **Well-Posed**: The problem is clearly defined with specific, unambiguous algorithmic steps. All required parameters are provided in the test suite. The error metric is a standard mathematical definition. All test cases use an even integer $N$, for which $M=3N/2$ is an integer, ensuring the padding procedure is well-defined. A unique, deterministic numerical result exists for each test case.\n- **Objective**: The problem is stated using precise mathematical and algorithmic language, free of any subjectivity or ambiguity.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, well-posed, objective, complete, and poses a non-trivial challenge relevant to the specified topic.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete solution will be provided.\n\n### **Solution Development**\n\nThe core of this problem lies in understanding how differentiation and multiplication are handled in Fourier space and how the finite resolution of a discrete grid leads to aliasing errors.\n\n**1. Spectral Differentiation**\n\nA $2\\pi$-periodic function $f(x)$ can be expressed as a Fourier series:\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{\\mathrm{i}kx}\n$$\nwhere $k$ are integer angular wavenumbers and $c_k$ are the complex Fourier coefficients. Differentiating term-by-term yields:\n$$\n\\partial_x f(x) = \\sum_{k=-\\infty}^{\\infty} (\\mathrm{i}k) c_k e^{\\mathrm{i}kx}\n$$\nThis demonstrates that differentiation in physical space corresponds to multiplication by $\\mathrm{i}k$ in Fourier space.\n\nOn a discrete grid of $N$ points $x_j = 2\\pi j/N$, we use the Discrete Fourier Transform (DFT), computed efficiently by the Fast Fourier Transform (FFT). The procedure is:\n1. Compute the DFT of the sampled function $f(x_j)$ to obtain its discrete spectrum, $\\hat{f}_k$.\n2. Determine the integer wavenumber $k$ corresponding to each element of the DFT array. For a domain of length $2\\pi$, the wavenumbers are $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ for even $N$.\n3. Multiply each $\\hat{f}_k$ by $\\mathrm{i}k$.\n4. Compute the Inverse DFT (IDFT) of the resulting spectrum to obtain the derivative samples $\\partial_x f(x_j)$.\n\n**2. Aliasing in Products**\n\nThe product of two functions, $w(x) = u(x)v(x)$, corresponds to the convolution of their spectra in Fourier space. If the highest wavenumber in $u(x)$ is $k_u$ and in $v(x)$ is $k_v$, the product $w(x)$ will contain wavenumbers up to $k_u + k_v$.\n\nOn a grid of size $N$, the highest representable wavenumber without ambiguity is the Nyquist wavenumber, $k_{Nyquist} = N/2$. If $k_u + k_v  k_{Nyquist}$, the high-frequency content of the product \"aliases,\" meaning it is misrepresented as a lower-frequency mode on the grid. For a mode with wavenumber $k  k_{Nyquist}$, its alias on the grid will be $k' = k - mN$ for some integer $m$ that brings $k'$ into the resolvable range $[ -N/2, N/2-1 ]$. This corrupts the numerical result.\n\n**3. De-aliasing with the Two-Thirds Rule**\n\nTo compute the product $uv$ without aliasing, we must perform the multiplication on a grid fine enough to represent all resulting wavenumbers. If the original functions are resolved on an $N$-point grid (meaning their modes satisfy $|k|  N/2$), their product's highest mode is less than $N$. The two-thirds rule states that if we restrict the initial spectra to wavenumbers $|k|  N/3$, the product's highest mode is less than $2N/3$. This can be resolved on a padded grid of size $M$ if its Nyquist limit satisfies $M/2  2N/3$, which holds for the common choice $M = 3N/2$.\n\nThe problem specifies an algorithm that implements this idea:\n- Transform $u$ and $v$ to Fourier space.\n- Pad their spectra to a larger size $M=3N/2$. This is equivalent to interpolating the functions onto a finer grid.\n- A crucial step is scaling the spectra. To preserve the function's values when moving from an $N$-point IFFT to an $M$-point IFFT, the Fourier coefficients must be scaled by a factor of $M/N$.\n- On the fine grid, multiply the function values pointwise: $w_{padded} = u_{padded} v_{padded}$. This product is free from aliasing if the original wavenumbers were sufficiently low.\n- Transform $w_{padded}$ to the $M$-dimensional Fourier space, perform the differentiation by multiplying by $\\mathrm{i}k$ (using the wavenumbers for the $M$-grid), and then truncate the resulting spectrum back down to size $N$.\n- This truncation requires an inverse scaling factor of $N/M$ to correctly represent the continuous Fourier amplitudes in the $N$-point DFT convention.\n- The final IFFT yields the de-aliased derivative on the original grid.\n\n**4. Analytical Derivative**\n\nThe exact derivative provides the ground truth for error analysis. Using the product rule:\n$$\nw(x) = \\sin(ax)\\cos(bx)\n$$\n$$\n\\partial_x w(x) = \\frac{d}{dx}(\\sin(ax))\\cos(bx) + \\sin(ax)\\frac{d}{dx}(\\cos(bx))\n$$\n$$\n\\partial_x w(x) = a\\cos(ax)\\cos(bx) - b\\sin(ax)\\sin(bx)\n$$\nThis expression is evaluated at the grid points $x_j$ to obtain the exact reference solution.\n\n**5. Implementation Steps**\n\nThe program will loop through each test case $(N, a, b)$ and perform the following calculations:\n1. **Grid and Functions**: Define the $N$-point grid `x` and the sample arrays `u` and `v`.\n2. **Non-De-aliased Derivative**: Compute `w = u * v`, FFT to get `w_hat`, multiply by `1j * k`, and IFFT to get `dw_dx_no_dealias`. The real part of this result is used.\n3. **De-aliased Derivative**:\n    - FFT `u` and `v` to get `u_hat` and `v_hat`.\n    - Create zero arrays `u_hat_padded` and `v_hat_padded` of size $M=3N/2$.\n    - Copy the frequency components from the original spectra to the padded spectra, preserving their wavenumber positions.\n    - Scale the padded spectra by $M/N$.\n    - IFFT to get `u_padded` and `v_padded` on the fine grid.\n    - Compute the product `w_padded = u_padded * v_padded`.\n    - FFT to get `w_padded_hat`.\n    - Differentiate by multiplying by `1j * k_padded`.\n    - Truncate the resulting spectrum back to size $N$.\n    - Scale the truncated spectrum by $N/M$.\n    - IFFT to get `dw_dx_dealias`. The real part of this result is used.\n4. **Exact Derivative**: Evaluate the analytical formula for $\\partial_x w(x)$ on the grid `x`.\n5. **Error Calculation**: For both numerical methods, compute the relative $\\ell^2$ norm of the difference between the numerical and exact derivatives. The results are stored as a pair `[error_no_dealias, error_dealias]`.\nFinally, all pairs are collected and printed in the specified string format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral differentiation problem for a suite of test cases.\n    \"\"\"\n\n    def compute_errors(N, a, b):\n        \"\"\"\n        Computes the derivative of u(x)v(x) and its error for a given (N, a, b).\n\n        Args:\n            N (int): Number of grid points.\n            a (int): Wavenumber for sin(ax).\n            b (int): Wavenumber for cos(bx).\n\n        Returns:\n            list: A pair of floats [error_no_dealias, error_dealias].\n        \"\"\"\n        # 1. Grid, functions, and analytical derivative\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(a * x)\n        v = np.cos(b * x)\n        \n        # Exact analytical derivative evaluated on the grid\n        dw_dx_exact = a * np.cos(a * x) * np.cos(b * x) - b * np.sin(a * x) * np.sin(b * x)\n        norm_exact = np.linalg.norm(dw_dx_exact)\n\n        # Handle case where the exact derivative is zero to avoid division by zero.\n        if norm_exact   1e-15:\n            # If the exact derivative is zero, the absolute error is the norm of the computed one.\n            # Relative error is not well-defined, but we can check if the computed is also zero.\n            # For this problem's test cases, norm_exact is never zero.\n            pass\n\n        # 2. Method 1: No De-aliasing\n        w = u * v\n        k_N = np.fft.fftfreq(N) * N\n        dw_dx_hat_no_dealias = 1j * k_N * np.fft.fft(w)\n        dw_dx_no_dealias = np.fft.ifft(dw_dx_hat_no_dealias)\n\n        error_no_dealias = np.linalg.norm(dw_dx_no_dealias.real - dw_dx_exact) / norm_exact\n\n        # 3. Method 2: De-aliasing with 3/2 zero-padding\n        M = 3 * N // 2\n        \n        u_hat = np.fft.fft(u)\n        v_hat = np.fft.fft(v)\n        \n        # Padded spectra\n        u_hat_padded = np.zeros(M, dtype=np.complex128)\n        v_hat_padded = np.zeros(M, dtype=np.complex128)\n        \n        # Slicing indices for even N\n        # Positive frequencies (and zero) go at the beginning.\n        # Negative frequencies (including Nyquist) go at the end.\n        n_pos_freqs = N // 2\n        \n        # Copy positive frequencies\n        u_hat_padded[:n_pos_freqs] = u_hat[:n_pos_freqs]\n        v_hat_padded[:n_pos_freqs] = v_hat[:n_pos_freqs]\n\n        # Copy negative frequencies\n        u_hat_padded[M - (N - n_pos_freqs):] = u_hat[n_pos_freqs:]\n        v_hat_padded[M - (N - n_pos_freqs):] = v_hat[n_pos_freqs:]\n        \n        # Scale for IFFT to finer grid\n        u_hat_padded *= M / N\n        v_hat_padded *= M / N\n        \n        # Transform to fine grid, multiply, and transform back\n        u_padded = np.fft.ifft(u_hat_padded)\n        v_padded = np.fft.ifft(v_hat_padded)\n        w_padded = u_padded * v_padded\n        w_padded_hat = np.fft.fft(w_padded)\n        \n        # Differentiate in padded Fourier space\n        k_M = np.fft.fftfreq(M) * M\n        dw_dx_padded_hat = 1j * k_M * w_padded_hat\n        \n        # Truncate spectrum back to size N\n        dw_dx_hat_dealias = np.zeros(N, dtype=np.complex128)\n        dw_dx_hat_dealias[:n_pos_freqs] = dw_dx_padded_hat[:n_pos_freqs]\n        dw_dx_hat_dealias[n_pos_freqs:] = dw_dx_padded_hat[M - (N - n_pos_freqs):]\n\n        # Scale for IFFT to original grid\n        dw_dx_hat_dealias *= N / M\n        \n        dw_dx_dealias = np.fft.ifft(dw_dx_hat_dealias)\n        \n        error_dealias = np.linalg.norm(dw_dx_dealias.real - dw_dx_exact) / norm_exact\n        \n        return [error_no_dealias, error_dealias]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 3, 4),   # Case 1\n        (16, 7, 7),   # Case 2\n        (32, 12, 13), # Case 3\n        (32, 15, 17), # Case 4\n        (24, 8, 10),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b = case\n        errors = compute_errors(N, a, b)\n        results.append(errors)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is very close.\n    # We just need to remove spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "谱方法面临的一个关键挑战是其在处理非光滑函数时的表现，这可能导致在整个计算域内出现持续的吉布斯振荡。本练习通过求解一个阶跃函数的微分来探讨这一现象。你将实现一个模态滤波器来抑制这些伪振荡，学习如何在存在不连续性的情况下提高谱导数的准确性和稳定性。",
            "id": "3417221",
            "problem": "考虑周期区间 $[0,2\\pi)$，其中角度以弧度为单位。设 $f(x)$ 是在 $x=\\pi$ 处有单次跳跃的分段常数函数，定义为\n$$\nf(x)=\\begin{cases}\n1,  x\\in[0,\\pi),\\\\\n0,  x\\in[\\pi,2\\pi).\n\\end{cases}\n$$\n在一个包含 $N$ 个点的等距网格 $x_j=\\frac{2\\pi j}{N}$（$j=0,1,\\dots,N-1$）上，您将使用通过快速傅里叶变换（FFT）计算的离散傅里叶变换来近似 $f$ 的谱导数。这利用了物理空间中的微分对应于变换空间中乘以波数的基本性质。具体来说，请实现以下两种变体。\n1. 未滤波的谱导数：将 $f$ 变换到傅里叶空间，将每个模态系数乘以与对 $x$ 微分相对应的波数因子，然后变换回物理空间得到。\n2. 滤波后的谱导数：这是通过在傅里叶空间中对微分后的模态系数应用一个指数模态滤波器而得到的。该滤波器定义为\n$$\n\\sigma(k) = \\exp\\left(-\\left(\\alpha \\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)\\right),\n$$\n其中 $k$ 是整数波数，$k_{\\max}=\\frac{N}{2}$，$p$ 是一个正偶数（滤波器阶数），$\\alpha0$ 是用户指定的常数。在微分步骤中，将奈奎斯特模态（即当 $N$ 为偶数时 $|k|=k_{\\max}$ 的模态）设置为零，以避免在网格上表示该模态导数时的歧义。\n\n定义从一个点 $x$ 到跳跃点位置 $x=\\pi$ 的周期距离为\n$$\nd(x,\\pi) = \\min\\left(|x-\\pi|,\\, 2\\pi-|x-\\pi|\\right).\n$$\n对于给定的排除半宽 $\\varepsilon\\in(0,\\pi)$，定义网格点的外部集合\n$$\nS_\\varepsilon = \\left\\{x_j:\\ d(x_j,\\pi)\\ge \\varepsilon\\right\\}.\n$$\n通过在 $S_\\varepsilon$ 上计算以下两个度量，来量化远离跳跃点的吉布斯型过冲振幅和近似导数的 $L^2$ 范数：\n- 过冲振幅 $O = \\max_{x_j\\in S_\\varepsilon}\\left|g(x_j)\\right|$，其中 $g$ 是近似导数。\n- 离散 $L^2$ 范数 $E = \\left(\\sum_{x_j\\in S_\\varepsilon} |g(x_j)|^2\\,\\Delta x\\right)^{1/2}$，其中 $\\Delta x=\\frac{2\\pi}{N}$。\n\n对于下面的每个测试用例，计算：\n- 过冲减小比 $R = \\dfrac{O_{\\mathrm{filtered}}}{O_{\\mathrm{unfiltered}}}$。\n- 在 $S_\\varepsilon$ 上的未滤波 $L^2$ 范数 $E_{\\mathrm{unfiltered}}$。\n- 在 $S_\\varepsilon$ 上的滤波后 $L^2$ 范数 $E_{\\mathrm{filtered}}$。\n\n使用以下参数测试套件 $(N,p,\\alpha,\\varepsilon)$：\n- $(N,p,\\alpha,\\varepsilon)=(32,8,36,0.3)$,\n- $(N,p,\\alpha,\\varepsilon)=(128,8,36,0.2)$,\n- $(N,p,\\alpha,\\varepsilon)=(256,16,36,0.15)$,\n- $(N,p,\\alpha,\\varepsilon)=(256,4,18,0.15)$.\n\n您的程序必须：\n- 对于每个 $N$，在网格上构造 $f$。\n- 使用上述傅里葉微分性质和指定的指数滤波器，计算未滤波和滤波后的谱导数。\n- 对于每个测试用例，使用上述定义计算 $R$、$E_{\\mathrm{unfiltered}}$ 和 $E_{\\mathrm{filtered}}$，所有角度均以弧度为单位。\n- 生成单行输出，其中包含一个浮点数结果的扁平列表，顺序如下\n$$\n\\left[R_1,\\,E_{\\mathrm{unfiltered},1},\\,E_{\\mathrm{filtered},1},\\,R_2,\\,E_{\\mathrm{unfiltered},2},\\,E_{\\mathrm{filtered},2},\\,R_3,\\,E_{\\mathrm{unfiltered},3},\\,E_{\\mathrm{filtered},3},\\,R_4,\\,E_{\\mathrm{unfiltered},4},\\,E_{\\mathrm{filtered},4}\\right].\n$$\n该行必须严格格式化为Python列表，使用逗号分隔值，并用方括号括起来。所有答案都是无量纲的，必须以浮点数形式报告。\n\n该测试套件旨在覆盖一个低分辨率情况（$N=32$）、两个高分辨率情况（$N=128$ 和 $N=256$），以及强滤波器与弱滤波器（不同的 $p$ 和 $\\alpha$）的比较，以评估过冲减小和远离跳跃点的 $L^2$ 收敛情况。",
            "solution": "基本原理是周期函数的傅里叶表示，以及一个经过充分检验的性质：物理空间中的微分对应于傅里叶空间中乘以虚数单位和波数。设 $f(x)$ 是一个 $2\\pi$-周期函数，其傅里葉级数为 $f(x)=\\sum_{k\\in\\mathbb{Z}} c_k e^{i k x}$，$x\\in[0,2\\pi)$。那么其导数为 $f'(x)=\\sum_{k\\in\\mathbb{Z}} (i k) c_k e^{i k x}$。对于等距节点 $x_j=\\frac{2\\pi j}{N}$，对傅里叶级数进行采样并应用离散傅里葉变换（DFT），可以将样本 $\\{f(x_j)\\}$ 映射到与 $\\{c_k\\}$ 成比例的模态系数，而逆DFT则将模态系数映射回节点值。因此，网格上的谱微分算法按以下步骤进行：\n1. 使用快速傅里葉变换（FFT）算法计算 $\\{f(x_j)\\}$ 的 DFT $\\{F_k\\}$。\n2. 将每个模态乘以因子 $i k$ 来表示对 $x$ 的微分（按照惯例，对于偶数 $N$，奈奎斯特模态 $|k|=k_{\\max}=\\frac{N}{2}$ 被设置为零，以避免在网格上表示其导数时的歧义）。\n3. 应用逆DFT返回到物理空间值 $\\{g(x_j)\\}$，这些值在谱意义上近似于 $f'(x)$。\n\n由于给定的函数 $f$ 是具有单个跳跃间断点的分段常数函数，其在分布意义下的精确导数是在跳跃点位置 $x=\\pi$ 处的一个狄拉克δ函数（乘以跳跃幅度），而在其他地方为0。狄拉克δ函数不属于平方可积空间 $L^2([0,2\\pi])$，因此在整个定义域上，$g$ 对 $f'$ 的经典全局 $L^2$ 收敛是没有意义的。然而，在远离跳跃点的地方，$f$ 是光滑的（实际上是常数），谱微分应该近似于精确导数 $0$，因此在任何排除了跳跃点邻域的固定子域上，其 $L^2$ 范数应该收敛到 $0$。为了衡量这一点，我们定义了一个围绕 $x=\\pi$ 的半宽为 $\\varepsilon$ 的排除区域，并在其补集 $S_\\varepsilon$ 上评估 $g$ 的离散 $L^2$ 范数。\n\n吉布斯型振荡是由跳跃引起的，表现为谱导数在远离跳跃点处的非零振荡行为。模态滤波通过衰减高波数模态来减少这些振荡。一个阶数为 $p$、强度为 $\\alpha$ 的指数滤波器被应用于微分后的模态系数 $\\{D_k\\}$，其形式为\n$$\n\\sigma(k)=\\exp\\left(-\\left(\\alpha\\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)\\right),\\qquad D^{(\\mathrm{filtered})}_k=\\sigma(k) D_k,\\qquad k_{\\max}=\\frac{N}{2}.\n$$\n这样可以保留低阶模态，同时指数衰减主要引起吉布斯振荡的高阶模态，从而减少远离跳跃点的过冲和 $L^2$ 范数。\n\n算法设计：\n- 网格和函数：对于每个 $N$，构造 $x_j=\\frac{2\\pi j}{N}$（$j=0,\\dots,N-1$），并设置当 $x_j\\in[0,\\pi)$ 时 $f(x_j)=1$，当 $x_j\\in[\\pi,2\\pi)$ 时 $f(x_j)=0$。\n- 波数：使用由频率工具提供的标准DFT波数排序 $k\\in\\{0,1,\\dots,\\frac{N}{2},-\\frac{N}{2}+1,\\dots,-1\\}$，或者等效地，通过将归一化的DFT频率乘以 $N$ 来得到。将奈奎斯特模态 $k=\\pm \\frac{N}{2}$ 的微分因子设置为 $0$。\n- 未滤波导数：计算 $F_k=\\mathrm{FFT}(f)$，根据上述对奈奎斯特模态的处理方式形成 $D_k=(i k)F_k$，并设置 $g_{\\mathrm{unfiltered}}(x_j)=\\mathrm{Re}\\left(\\mathrm{IFFT}(D_k)\\right)$。\n- 滤波后导数：将指数滤波器 $\\sigma(k)$ 应用于 $D_k$ 得到 $D^{(\\mathrm{filtered})}_k=\\sigma(k) D_k$，然后计算 $g_{\\mathrm{filtered}}(x_j)=\\mathrm{Re}\\left(\\mathrm{IFFT}(D^{(\\mathrm{filtered})}_k)\\right)$。\n- 远离跳跃点的度量：定义周期距离 $d(x,\\pi)=\\min(|x-\\pi|,2\\pi-|x-\\pi|)$ 和外部集合 $S_\\varepsilon=\\{x_j:\\ d(x_j,\\pi)\\ge \\varepsilon\\}$。当 $\\Delta x=\\frac{2\\pi}{N}$ 时，计算：\n  - $O_{\\mathrm{unfiltered}}=\\max_{x_j\\in S_\\varepsilon} |g_{\\mathrm{unfiltered}}(x_j)|$,\n  - $O_{\\mathrm{filtered}}=\\max_{x_j\\in S_\\varepsilon} |g_{\\mathrm{filtered}}(x_j)|$,\n  - $E_{\\mathrm{unfiltered}}=\\left(\\sum_{x_j\\in S_\\varepsilon} |g_{\\mathrm{unfiltered}}(x_j)|^2\\,\\Delta x\\right)^{1/2}$,\n  - $E_{\\mathrm{filtered}}=\\left(\\sum_{x_j\\in S_\\varepsilon} |g_{\\mathrm{filtered}}(x_j)|^2\\,\\Delta x\\right)^{1/2}$,\n  - $R=\\frac{O_{\\mathrm{filtered}}}{O_{\\mathrm{unfiltered}}}$ （如果 $O_{\\mathrm{unfiltered}}=0$，则定义 $R=0$）。\n- 数值复杂度：每次FFT和逆FFT的复杂度为 $\\mathcal{O}(N\\log N)$，并且操作是向量化的。对于本测试套件，总计算成本适中。\n\n预期行为：\n- 对于固定的 $\\varepsilon$，随着 $N$ 的增加，$S_\\varepsilon$ 上的 $E_{\\mathrm{unfiltered}}$ 和 $E_{\\mathrm{filtered}}$ 都应该减小，因为谱导数能更好地解析远离跳跃点的常数区域。滤波后的版本通常比未滤波版本获得更小的过冲和 $L^2$ 误差，因此 $R$ 应该小于1，并且在大多数情况下 $E_{\\mathrm{filtered}}  E_{\\mathrm{unfiltered}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef periodic_distance(x, a, L=2*np.pi):\n    # Compute periodic distance on [0,L)\n    d = np.abs(x - a)\n    return np.minimum(d, L - d)\n\ndef spectral_derivative(values):\n    \"\"\"\n    Compute unfiltered spectral derivative on equispaced grid over [0, 2pi).\n    values: array of f(x_j) samples, length N.\n    Returns real-valued derivative approximation g(x_j).\n    \"\"\"\n    N = values.size\n    F = np.fft.fft(values)\n    # Integer wavenumbers in FFT ordering\n    k = np.fft.fftfreq(N) * N  # yields [0,1,2,...,N/2,-N/2+1,...,-1]\n    # Handle Nyquist mode for even N by zeroing its derivative\n    k = k.astype(float)\n    if N % 2 == 0:\n        k[int(N//2)] = 0.0\n    D = 1j * k * F\n    g = np.fft.ifft(D).real\n    return g\n\ndef filtered_spectral_derivative(values, p, alpha):\n    \"\"\"\n    Compute filtered spectral derivative using an exponential modal filter\n    applied to the differentiated modal coefficients.\n    p: even integer filter order\n    alpha: positive filter strength\n    \"\"\"\n    N = values.size\n    F = np.fft.fft(values)\n    k = np.fft.fftfreq(N) * N\n    k = k.astype(float)\n    if N % 2 == 0:\n        k[int(N//2)] = 0.0\n    # Differentiate in spectral space\n    D = 1j * k * F\n    # Exponential filter\n    kmax = N / 2.0\n    # Avoid division by zero at k=0\n    ksi = np.abs(k) / kmax\n    sigma = np.exp(- (alpha * (ksi ** p)))\n    # Ensure exact preservation of mean mode\n    sigma[0] = 1.0\n    Df = sigma * D\n    g = np.fft.ifft(Df).real\n    return g\n\ndef compute_metrics(N, p, alpha, eps):\n    \"\"\"\n    For given parameters, build f, compute unfiltered and filtered derivatives,\n    and compute overshoot reduction ratio and L2 norms over S_eps.\n    Returns (R, E_unf, E_fil).\n    \"\"\"\n    # Grid\n    x = np.linspace(0.0, 2*np.pi, N, endpoint=False)\n    dx = 2*np.pi / N\n    # Piecewise constant f\n    f = np.where(x  np.pi, 1.0, 0.0)\n    # Derivatives\n    g_unf = spectral_derivative(f)\n    g_fil = filtered_spectral_derivative(f, p=p, alpha=alpha)\n    # Exterior set S_eps\n    dist = periodic_distance(x, np.pi, L=2*np.pi)\n    mask = dist >= eps\n    if not np.any(mask):\n        # Degenerate case: no points outside exclusion\n        return (0.0, 0.0, 0.0)\n    # Overshoot amplitudes\n    O_unf = float(np.max(np.abs(g_unf[mask])))\n    O_fil = float(np.max(np.abs(g_fil[mask])))\n    R = 0.0 if O_unf == 0.0 else (O_fil / O_unf)\n    # Discrete L2 norms over S_eps\n    E_unf = float(np.sqrt(np.sum(np.abs(g_unf[mask])**2) * dx))\n    E_fil = float(np.sqrt(np.sum(np.abs(g_fil[mask])**2) * dx))\n    return (R, E_unf, E_fil)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, p, alpha, epsilon)\n    test_cases = [\n        (32, 8, 36.0, 0.3),\n        (128, 8, 36.0, 0.2),\n        (256, 16, 36.0, 0.15),\n        (256, 4, 18.0, 0.15),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p, alpha, eps = case\n        R, E_unf, E_fil = compute_metrics(N, p, alpha, eps)\n        results.extend([R, E_unf, E_fil])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}