{
    "hands_on_practices": [
        {
            "introduction": "数值格式的稳定性至关重要。对于应用于偏微分方程离散系统的低存储龙格-库塔（LSRK）方法，其稳定性由该方法自身的稳定区域与空间算子特征值之间的相互作用决定。这项基础练习  将引导您从第一性原理出发，推导稳定性极限。通过将一个格式的稳定性多项式的解析推导与一个简单间断伽辽金（DG）离散的特征值分析相结合，您将深刻理解 Courant-Friedrichs-Lewy ($CFL$) 条件的本质。",
            "id": "3397065",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度为正常数 $a > 0$，定义在周期性域 $x \\in [0,L]$ 上。在空间上使用间断伽辽金 (DG) 方法进行离散化，采用分片常数（多项式次数 $p=0$）、包含 $K$ 个单元的均匀网格（单元尺寸 $h = L/K$）、数值通量等于迎风通量，并在每个单元内采用标准的 $L^{2}$ 质量集中。这产生了一个半离散线方法 $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$，其矩阵 $L$ 是一个块循环矩阵。\n\n时间推进采用以下双寄存器低存储三阶段三阶格式（等价于三阶 Shu–Osher 强稳定保持 Runge–Kutta 方法），对于任意右端项 $F(\\mathbf{u})$ 写为：\n- 阶段 1：$\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$。\n- 阶段 2：$\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$。\n- 阶段 3：$\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$。\n\n您的任务是：\n1. 从 Runge–Kutta 方法应用于线性检验方程 $y'(t) = \\lambda\\,y(t)$ 的绝对稳定性函数的定义出发，推导上述低存储格式的稳定性函数 $R(z)$，其中 $z = \\lambda\\,\\Delta t$。\n2. 对于 $p=0$ 和迎风通量的 DG 半离散化，在均匀周期性网格上，通过应用傅里叶模态 ansatz 推导半离散算子 $L$ 的特征值集合 $\\Lambda(L)$。然后，使用库朗数 $C = a\\,\\Delta t/h$，将稳定性条件 $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ 表示为一个关于 $C$ 的条件，该条件涉及对傅里叶相位 $\\theta \\in [0,2\\pi]$ 的显式单变量极值化。\n3. 确定最大容许库朗数 $C_{\\max}$，使得对于所有 $\\lambda \\in \\Lambda(L)$，绝对稳定性条件都得到满足。您的最终答案必须是单个实数。将您的答案四舍五入到四位有效数字。\n\n除了上述定义和给定的格式外，不得使用任何进一步的简化或预先推导的公式。清晰地说明您所做的任何中间变换，并从线方法、迎风通量 DG 半离散化以及 Runge–Kutta 绝对稳定性函数定义的首要原则出发，论证每一步。最终答案必须是 $C_{\\max}$ 的单个数值（无单位）。",
            "solution": "用户提供了一个由三部分组成的问题，涉及间断伽辽金 (DG) 有限元法与低存储 Runge-Kutta (RK) 时间积分格式相结合，用于线性平流方程的稳定性分析。首先，必须确定问题的有效性。\n\n### 步骤 1：提取已知条件\n- **方程**：一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度为正常数 $a > 0$。\n- **定义域**：周期性域，$x \\in [0,L]$。\n- **空间离散化**：\n    - 方法：间断伽辽金 (DG) 方法。\n    - 多项式次数：$p=0$（分片常数）。\n    - 网格：均匀网格，包含 $K$ 个单元，单元尺寸 $h = L/K$。\n    - 数值通量：迎风通量。\n    - 质量矩阵：标准 $L^2$ 质量集中。\n- **半离散形式**：$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$，其中 $L$ 是一个块循环矩阵。\n- **时间积分格式**：一个双寄存器低存储三阶段三阶格式 (SSP-RK3)：\n    - 阶段 1：$\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$。\n    - 阶段 2：$\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$。\n    - 阶段 3：$\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$。\n- **定义**：库朗数 $C = a\\,\\Delta t/h$。\n- **任务**：\n    1. 对于 $z = \\lambda\\,\\Delta t$，推导该格式的稳定性函数 $R(z)$。\n    2. 推导 DG 半离散化的特征值集合 $\\Lambda(L)$，并将稳定性条件 $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ 表示为一个关于 $C$ 在傅里叶相位 $\\theta$ 上的极值化问题。\n    3. 确定最大容许库朗数 $C_{\\max}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题牢固地植根于偏微分方程数值分析领域。DG 方法、Runge-Kutta 格式和稳定性分析是标准且成熟的课题。线性平流方程是典型的模型问题。所有元素在科学上都是合理的。\n2.  **良态问题**：该问题被构造成一系列推导，最终导出一个数值。每个部分都定义清晰，并以前一部分为基础，最终得到一个唯一且有意义的解（$C_{\\max}$）。\n3.  **客观性**：问题以精确、客观的数学语言陈述。没有主观或基于观点的断言。\n4.  **完整性**：问题提供了所有必要的信息：偏微分方程、离散化细节（DG、$p=0$、迎风通量、周期性边界条件）、时间步进格式以及库朗数的定义。虽然问题将矩阵 $L$ 标记为“块循环”，但对于 $p=0$ 的情况，它是一个简单的（非块）循环矩阵。这是一个微小的术语不精确之处，但不影响可解性或造成矛盾，因为其结构完全由其他规范确定。\n5.  **其他缺陷**：该问题不是隐喻性的、琐碎的、不适定的或无法验证的。它是一个标准但详细的数值分析问题。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。下面将提供一个完整、合理的解答。\n\n### 解答\n\n按照要求，问题分三个连续部分进行解答。\n\n**第 1 部分：稳定性函数 $R(z)$ 的推导**\n\nRunge-Kutta 方法的稳定性函数 $R(z)$ 是通过将其应用于线性检验方程 $y'(t) = \\lambda y(t)$ 时得到的 $y^{n+1} = R(z) y^n$ 关系来定义的。这里，右端项函数是 $F(y) = \\lambda y$，我们定义 $z = \\lambda \\Delta t$。我们将此应用于给定的三阶段格式。\n\n对于第一阶段：\n$$y^{(1)} = y^n + \\Delta t F(y^n) = y^n + \\Delta t (\\lambda y^n) = (1 + \\lambda \\Delta t) y^n = (1+z) y^n$$\n\n对于第二阶段，我们首先计算 $F$ 的参数，即 $y^{(1)}$，然后代入 $y^{(1)}$ 的表达式：\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t F(y^{(1)}) \\right) = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t (\\lambda y^{(1)}) \\right)$$\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1 + \\lambda \\Delta t) y^{(1)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z) y^{(1)}$$\n代入 $y^{(1)} = (1+z)y^n$：\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z)(1+z) y^n = \\left[ \\frac{3}{4} + \\frac{1}{4}(1+z)^2 \\right] y^n$$\n展开 $z$ 的多项式：\n$$y^{(2)} = \\left[ \\frac{3}{4} + \\frac{1}{4}(1 + 2z + z^2) \\right] y^n = \\left[ \\frac{3}{4} + \\frac{1}{4} + \\frac{2}{4}z + \\frac{1}{4}z^2 \\right] y^n = \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) y^n$$\n\n对于第三阶段也是最后阶段：\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} \\left( y^{(2)} + \\Delta t F(y^{(2)}) \\right) = \\frac{1}{3} y^n + \\frac{2}{3} (1 + \\lambda \\Delta t) y^{(2)}$$\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} (1+z) y^{(2)}$$\n代入 $y^{(2)}$ 的表达式：\n$$y^{n+1} = \\left[ \\frac{1}{3} + \\frac{2}{3} (1+z) \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) \\right] y^n$$\n方括号中的表达式即为稳定性函数 $R(z)$。我们将其展开：\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) + z \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 + z + \\frac{1}{2}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{3}{2}z + \\frac{3}{4}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\n$$R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\n这是 $\\exp(z)$ 的泰勒级数展开到三阶项，证实了该方法的三阶精度。\n\n**第 2 部分：特征值谱与稳定性条件**\n\n我们首先推导 $p=0$ 的 DG 方法的半离散系统。在一个单元 $I_j = [x_{j-1/2}, x_{j+1/2}]$ 上的 DG 弱形式是寻找 $u_h$ 使得对于所有测试函数 $v_h$：\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx + \\int_{I_j} a \\frac{\\partial u_h}{\\partial x} v_h \\,dx = 0$$\n对第二项使用分部积分：\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{I_j} a u_h \\frac{\\partial v_h}{\\partial x} \\,dx + [a u_h^* v_h]_{x_{j-1/2}}^{x_{j+1/2}} = 0$$\n对于 $p=0$，$u_h(x,t) = u_j(t)$ 和 $v_h(x) = v_j$ 在 $I_j$ 上是常数。设 $v_j=1$。积分内的导数消失。方程变为：\n$$h \\frac{du_j}{dt} + a u^*(x_{j+1/2}) - a u^*(x_{j-1/2}) = 0$$\n问题指定了迎风通量。由于 $a>0$，风从左向右吹。界面处的数值通量 $u^*$ 是来自左侧（迎风）的值。\n在界面 $x_{j+1/2}$ 处，左侧状态为 $u_j$，右侧状态为 $u_{j+1}$。所以，$u^*(x_{j+1/2}) = u_j$。\n在界面 $x_{j-1/2}$ 处，左侧状态为 $u_{j-1}$，右侧状态为 $u_j$。所以，$u^*(x_{j-1/2}) = u_{j-1}$。\n将这些通量代入半离散方程：\n$$h \\frac{du_j}{dt} + a u_j - a u_{j-1} = 0 \\implies \\frac{du_j}{dt} = -\\frac{a}{h} (u_j - u_{j-1})$$\n这定义了算子 $L$ 的作用：$(L\\mathbf{u})_j = -\\frac{a}{h} (u_j - u_{j-1})$。\n为了找到 $L$ 的特征值 $\\lambda$，我们对网格函数 $\\mathbf{u}$ 使用傅里叶模态 ansatz，并考虑周期性。设 $u_j(t) = \\hat{u}(t) e^{i k x_j}$，其中 $x_j = j h$，$k$ 是波数。\n$$\\frac{d}{dt} (\\hat{u} e^{ikjh}) = -\\frac{a}{h} (\\hat{u} e^{ikjh} - \\hat{u} e^{ik(j-1)h})$$\n$$\\frac{d\\hat{u}}{dt} e^{ikjh} = -\\frac{a}{h} \\hat{u} e^{ikjh} (1 - e^{-ikh})$$\n$$\\frac{d\\hat{u}}{dt} = \\left[-\\frac{a}{h} (1 - e^{-ikh})\\right] \\hat{u}$$\n因此，算子 $L$ 的特征值为 $\\lambda(k) = -\\frac{a}{h} (1 - e^{-ikh})$。\n周期性域 $[0, L]$ 和网格尺寸 $h=L/K$ 要求波数满足 $kL = 2\\pi m$，其中 $m$ 是整数。因此，$k = \\frac{2\\pi m}{L} = \\frac{2\\pi m}{Kh}$。\n设 $\\theta_m = kh = \\frac{2\\pi m}{K}$ 为离散傅里叶相位，其中 $m = 0, 1, \\dots, K-1$。当单元数 $K \\to \\infty$ 时，$\\theta$ 可视为 $[0, 2\\pi]$ 中的连续变量。\n特征值为 $\\lambda(\\theta) = -\\frac{a}{h}(1 - e^{-i\\theta}) = \\frac{a}{h}(e^{-i\\theta} - 1)$。\n稳定性函数 $R(z)$ 的参数为 $z = \\Delta t \\lambda$。\n$$z(\\theta) = \\Delta t \\lambda(\\theta) = \\frac{a \\Delta t}{h} (e^{-i\\theta} - 1) = C(e^{-i\\theta} - 1)$$\n其中 $C = a \\Delta t/h$ 是库朗数。\n稳定性条件是，对于 $L$ 的所有特征值 $\\lambda$，放大因子 $|R(\\Delta t \\lambda)|$ 不得大于 $1$。在 $K \\to \\infty$ 的极限下，这成为在连续相位 $\\theta$ 上的一个极值化问题：\n$$\\max_{\\theta \\in [0, 2\\pi]} |R(z(\\theta))| \\le 1$$\n代入 $R(z)$ 和 $z(\\theta)$ 的表达式，条件为：\n$$\\max_{\\theta \\in [0, 2\\pi]} \\left| 1 + C(e^{-i\\theta}-1) + \\frac{1}{2} C^2(e^{-i\\theta}-1)^2 + \\frac{1}{6} C^3(e^{-i\\theta}-1)^3 \\right| \\le 1$$\n\n**第 3 部分：最大容许库朗数 $C_{\\max}$**\n\n对于 $\\theta \\in [0, 2\\pi]$，点集 $z(\\theta) = C(e^{-i\\theta} - 1)$ 在复平面上描绘出一个圆。记 $z = x+iy$，我们有 $x = C(\\cos\\theta - 1)$ 和 $y = -C\\sin\\theta$。由此可知 $(x+C)^2 + y^2 = C^2\\cos^2\\theta + C^2\\sin^2\\theta = C^2$。这是一个以 $-C$ 为中心、半径为 $C$ 的圆。\n\n稳定性条件要求这个完整的圆位于 RK 方法的绝对稳定区域内，该区域定义为 $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$。最大容许库朗数 $C_{\\max}$ 是 $C$ 的值，此时该圆从内部与稳定区域的边界相切。\n\n对于许多耗散数值格式，最严格的稳定性约束来自于网格上可表示的最高频率模态。对于迎风格式，这对应于 $\\theta=\\pi$，此时特征值具有最大的负实部。我们假设 $|R(z(\\theta))|$ 的最大值出现在 $\\theta=\\pi$ 处。\n在 $\\theta = \\pi$ 处，我们有 $e^{-i\\pi} = -1$。对应的 $z$ 值为：\n$$z(\\pi) = C(-1-1) = -2C$$\n该点位于负实轴上。此点的稳定性条件是 $|R(-2C)| \\leq 1$。\n对于一个实的负参数 $-x$（其中 $x > 0$），稳定性函数是实数：\n$$R(-x) = 1 - x + \\frac{1}{2}x^2 - \\frac{1}{6}x^3$$\n所以，我们需要 $|R(-2C)| \\le 1$，这等价于 $-1 \\le R(-2C) \\le 1$。我们来检查这两个不等式。\n抱歉出错。让我们用正确的多项式重新计算。\n$$R(-2C) = 1 - 2C + 2C^2 - \\frac{4}{3}C^3$$\n1. 不等式 $R(-2C) \\le 1$：\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\le 1 \\implies -2C + 2C^2 - \\frac{4}{3}C^3 \\le 0$$\n除以 $-2C$（由于 $C>0$，不等号反向）：\n$$1 - C + \\frac{2}{3}C^2 \\ge 0$$\n这个二次多项式的判别式是 $D = (-1)^2 - 4(\\frac{2}{3})(1) = 1 - \\frac{8}{3}  0$。由于首项系数为正，该二次多项式恒为正。因此，这个不等式对所有 $C$ 都成立。\n\n2. 不等式 $R(-2C) \\ge -1$：\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge -1$$\n$$2 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge 0$$\n设 $f(C) = 2 - 2C + 2C^2 - \\frac{4}{3}C^3$。我们需要找到满足 $f(C) \\ge 0$ 的最大 $C$。我们来考察其导数：\n$$f'(C) = -2 + 4C - 4C^2 = -2(1 - 2C + 2C^2)$$\n二次多项式 $1 - 2C + 2C^2$ 的判别式是 $D = (-2)^2 - 4(2)(1) = 4 - 8 = -4  0$。由于首项系数为正，该二次多项式恒为正。因此，$f'(C)$ 恒为负，所以 $f(C)$ 对所有 $C$ 都是一个严格递减的函数。\n允许的 $C$ 的最大值，记为 $C_{\\max}$，将是方程 $f(C) = 0$ 的根。\n$$2 - 2C_{\\max} + 2C_{\\max}^2 - \\frac{4}{3}C_{\\max}^3 = 0$$\n乘以 $-\\frac{3}{2}$ 以简化：\n$$2C_{\\max}^3 - 3C_{\\max}^2 + 3C_{\\max} - 3 = 0$$\n这是一个关于 $C_{\\max}$ 的三次方程。我们必须用数值方法求解。设 $g(C) = 2C^3 - 3C^2 + 3C - 3$。\n$g(1) = 2-3+3-3 = -1$。\n$g(1.5) = 2(3.375) - 3(2.25) + 3(1.5) - 3 = 6.75 - 6.75 + 4.5 - 3 = 1.5$。\n根位于 $1$ 和 $1.5$ 之间。使用数值求解器（例如，Newton 法）：\n我们以初始猜测 $C_0 = 1.2$ 开始。\n$g(1.2) = 2(1.728) - 3(1.44) + 3(1.2) - 3 = 3.456 - 4.32 + 3.6 - 3 = -0.264$。\n$g'(C) = 6C^2 - 6C + 3$。\n$g'(1.2) = 6(1.44) - 6(1.2) + 3 = 8.64 - 7.2 + 3 = 4.44$。\n$C_1 = C_0 - \\frac{g(C_0)}{g'(C_0)} = 1.2 - \\frac{-0.264}{4.44} \\approx 1.2 + 0.059459 = 1.259459$。\n进一步迭代得到根的更精确值：\n$C_{\\max} \\approx 1.2564115$。\n将答案四舍五入到四位有效数字，我们得到 $C_{\\max} = 1.256$。",
            "answer": "$$\\boxed{1.256}$$"
        },
        {
            "introduction": "除了对简单情况可以进行解析稳定性分析，但实际的高阶方法通常需要计算验证。高阶DG算子的谱特性非常复杂，其与不同时间步进格式稳定区域的相互作用，决定了所允许的最大时间步长。本练习  旨在搭建理论与应用之间的桥梁，您将通过数值计算一个高阶DG算子的特征值，来比较经典RK4格式和一种现代低存储RK格式的实际$CFL$极限，从而揭示内存效率与稳定性之间的权衡。",
            "id": "3397159",
            "problem": "考虑周期域 $[0,1]$ 上的一维线性平流初值问题，平流速度 $a = 1$，由 $u_t + a u_x = 0$ 给出。使用高阶间断 Galerkin (DG) 方法对空间域进行离散化，该方法采用均匀分区，分为 $N$ 个大小为 $h = 1/N$ 的单元。在每个单元上，使用多项式次数为 $p$ 的 Legendre–Gauss–Lobatto 点上的节点基（因此每个单元有 $p+1$ 个节点）。使用与 $a = 1$ 一致的迎风数值通量。\n\n半离散 DG 算子可以使用分部求和性质写成强形式，其中参考单元上的导数矩阵 $D$ 和求积权重矩阵 $W$ 满足 $Q = W D$ 和 $Q + Q^\\top = B$，其中 $B$ 是选择边界节点的对角矩阵。在此公式中，半离散系统的形式为 $u_t = L u$，其中 $L$ 是由单元内部的体积项以及迎风通量和周期性边界条件引起的面耦合项组装而成的全局 DG 矩阵。对于显式时间步进，应用于半离散系统 $u_t = L u$ 的单步方法的稳定性由在 $z = \\Delta t \\lambda$ 处求值的绝对稳定函数 $R(z)$ 决定，其中 $\\lambda$ 遍及 $L$ 的特征值。稳定性要求 $\\max_{\\lambda \\in \\Lambda(L)} |R(\\Delta t \\lambda)| \\le 1$。在高阶 DG 分析中，一个公认的结论是，由于逆不等式和迹估计，平流算子的谱半径按 $\\mathcal{O}(p^2/h)$ 比例缩放，这为显式 Runge–Kutta 型方法提供了形式为 $\\Delta t \\le C/(p^2 h)$ 的 Courant–Friedrichs–Lewy (CFL) 条件。\n\n您的任务是实现并比较稳定性限制的时间步长系数 $C$，当从经典的四阶 Runge–Kutta 方法 (RK4) 切换到一种五阶段、四阶的双寄存器低存储 Runge–Kutta 方法（通常称为 Carpenter–Kennedy 2N-存储低存储格式）时。经典的四阶 Runge–Kutta 方法具有已知的稳定函数，而低存储方法可以用使用两个寄存器和常数系数的阶段递归更新来表示。在所有情况下，必须针对给定 $p$ 和 $N$ 的已组装 DG 算子的完整复数谱来验证时间稳定性。\n\n请基于以下基本事实进行推导：\n- 带有迎风通量和周期性边界条件的线性平流的半离散 DG 公式产生一个线性系统 $u_t = L u$，其特征值的量级按 $\\mathcal{O}(p^2/h)$ 缩放。\n- 对于应用于 $u_t = L u$ 的显式 Runge–Kutta 方法，稳定性由稳定函数 $R(z)$ 在集合 $z = \\Delta t \\lambda$ 上的幅值决定，其中 $\\lambda$ 是 $L$ 的特征值。\n\n基于这些基础，推导出一个算法，用于在固定的 $p$ 和 $N$ 下，计算使方法保持稳定的最大 $\\Delta t$，并通过 $C = \\Delta t \\, p^2 \\, h$ 报告相应的 $C$。通过组装以下各项来实现 $L$：\n- 次数为 $p$ 的参考单元上的 Legendre–Gauss–Lobatto 节点和权重。\n- 通过重心权重在参考单元上构建的节点微分矩阵 $D$。\n- 在 $N$ 个单元上带有迎风通量和周期性边界条件的全局强形式 DG 平流算子 $L$。\n\n然后，对于每种 Runge–Kutta 格式：\n- 计算 $L$ 的特征值。\n- 通过对 $\\Delta t$ 进行单调二分法搜索来确定最大稳定 $\\Delta t$，在每一步检查 $\\max_{\\lambda} |R(\\Delta t \\lambda)| \\le 1$。\n- 计算 $C = \\Delta t \\, p^2 \\, h$。\n\n不需要角度测量，也不需要物理单位；所有量都是无量纲的。\n\n测试套件：\n- 使用 $N = 16$ 个单元，平流速度 $a = 1$ 和周期性边界条件。\n- 对 $p \\in \\{2,4,8\\}$ 评估这些格式。\n- 格式：\n  1. 经典的四阶 Runge–Kutta（用代码字符串 \"RK4\" 表示）。\n  2. 双寄存器、低存储、五阶段、四阶 Runge–Kutta（用代码字符串 \"LSRK54\" 表示）。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按 $[C_{\\mathrm{RK4}}(p{=}2), C_{\\mathrm{LSRK54}}(p{=}2), C_{\\mathrm{RK4}}(p{=}4), C_{\\mathrm{LSRK54}}(p{=}4), C_{\\mathrm{RK4}}(p{=}8), C_{\\mathrm{LSRK54}}(p{=}8)]$ 的顺序排列。",
            "solution": "用户提供了一个科学上有效且定义明确的问题。任务是为一维线性平流方程的高阶间断 Galerkin (DG) 离散化计算稳定性限制的 Courant–Friedrichs–Lewy (CFL) 系数，记为 $C$。此分析将针对两种不同的显式 Runge-Kutta 时间步进格式进行。\n\n该问题由以下初值问题控制：\n$$ u_t + a u_x = 0, \\quad x \\in [0,1], \\quad t > 0 $$\n平流速度为 $a=1$ 并带有周期性边界条件。\n\n求解过程分为几个步骤：\n1.  **构造半离散 DG 算子**：空间域被离散为 $N$ 个单元，在每个单元内使用基于 Legendre-Gauss-Lobatto (LGL) 点的次数为 $p$ 的节点多项式基。半离散系统是一个常微分方程组，形式为 $\\frac{d\\vec{U}}{dt} = L\\vec{U}$，其中 $\\vec{U}$ 是节点值的全局向量，$L$ 是全局 DG 算子。矩阵 $L$ 是通过组装来自每个单元的局部算子构建的，其中包含了体积导数和单元间的通量贡献。对于此问题，使用迎风通量。\n\n2.  **推导 DG 算子矩阵 ($L$)**：全局算子 $L$ 是一个 $N(p+1) \\times N(p+1)$ 的矩阵。\n    -   **LGL 节点和权重**：对于多项式次数 $p$，我们需要参考单元 $[-1,1]$ 上的 $p+1$ 个 LGL 节点 $\\xi_j$ 和求积权重 $w_j$。这些节点是 $(1-x^2)P_p'(x)$ 的根，其中 $P_p(x)$ 是次数为 $p$ 的 Legendre 多项式。\n    -   **微分矩阵 ($D$)**：在参考单元上构建一个微分矩阵 $D$，使得对于一个节点值向量 $\\vec{v}$，$D\\vec{v}$ 近似于节点上的导数。\n    -   **强形式算子**：应用于单元 $k$（大小为 $h=1/N$）上解 $\\vec{u}_k$ 的 DG 算子的强形式由一个体积项和一个表面通量修正项组成。单元 $k$ 上节点值 $\\vec{u}_k$ 的时间演化由下式给出：\n        $$ \\frac{d\\vec{u}_k}{dt} = -\\frac{2a}{h} D \\vec{u}_k + \\text{FluxCorrection}(\\vec{u}_k, \\vec{u}_{neighbors}) $$\n    -   **迎风通量**：对于 $a=1>0$，界面处的迎风通量是来自左侧单元的值。在单元 $k$ 的右边界（界面 $k+1/2$），数值通量等于内部迹 $u_{k,p}$，因此修正为零。在左边界（界面 $k-1/2$），数值通量是外部迹 $u_{k-1,p}$。通量修正项仅影响单元的第一个节点 $u_{k,0}$。对 $\\frac{du_{k,0}}{dt}$ 的这个修正由下式给出：\n        $$ M_0^{-1} a ( u_{k,0} - u_{k-1,p} ) = \\frac{a}{w_0 h/2} ( u_{k,0} - u_{k-1,p} ) = \\frac{2a}{h w_0} ( u_{k,0} - u_{k-1,p} ) $$\n        该项被加到右侧。\n    -   **组装 L**：全局矩阵 $L$ 通过分配这些局部贡献来组装。对于每个单元 $k$，将一个对应于 $-\\frac{2a}{h}D$ 的块放在对角线上。然后，通量修正项将一个值 $\\frac{2a}{h w_0}$ 添加到将 $u_{k,0}$ 映射到 $\\dot{u}_{k,0}$ 的矩阵项中，并将一个值 $-\\frac{2a}{h w_0}$ 添加到将 $u_{k-1,p}$ 映射到 $\\dot{u}_{k,0}$ 的项中。周期性边界条件规定，对于 $k=0$，其“前一个”单元是 $k=N-1$。\n\n3.  **分析时间稳定性**：应用于 $\\frac{d\\vec{U}}{dt} = L\\vec{U}$ 的显式 Runge-Kutta 方法的稳定性由其稳定函数 $R(z)$ 决定。当且仅当对于 $L$ 的所有特征值 $\\lambda$，都有 $|R(\\Delta t \\lambda)| \\le 1$ 时，该方法是稳定的。\n    -   **L 的特征值**：特征值 $\\lambda$ 通过数值计算得到。\n    -   **稳定函数**：\n        -   对于经典的四阶 Runge–Kutta 方法 (RK4)，稳定多项式是 $e^z$ 直到4阶的泰勒展开：\n            $$ R_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n        -   对于指定的五阶段、四阶、双寄存器低存储 Runge-Kutta 格式 (LSRK54)，稳定多项式由其递推关系构建。该格式可以写成：\n            $$ d_0 = 0, \\quad q_0 = U_n $$\n            $$ d_i = A_i d_{i-1} + \\Delta t f(q_{i-1}), \\quad q_i = q_{i-1} + B_i d_i \\quad \\text{for } i=1,\\dots,5 $$\n            $$ U_{n+1} = q_5 $$\n            将此应用于测试方程 $u'=\\lambda u$（因此 $f(u)=\\lambda u$），其中 $z = \\Delta t \\lambda$，可以递归地构造稳定多项式 $R_{\\mathrm{LSRK54}}(z) = q_5/q_0$。\n\n4.  **计算最大稳定时间步长和 C**：对于每种格式，我们必须找到维持稳定性的最大 $\\Delta t$。这等同于找到最大的 $\\Delta t$，使得缩放后的谱 $\\Delta t \\Lambda(L)$ 保持在稳定区域 $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$ 内。\n    -   对 $\\Delta t$ 执行二分搜索。对于给定的 $\\Delta t$，通过对所有 $z \\in \\Delta t \\Lambda(L)$ 计算 $|R(z)|$ 并确保最大幅值不超过 1 来检查稳定性。\n    -   一旦找到最大稳定时间步长 $\\Delta t_{\\mathrm{max}}$，就使用问题中定义的缩放关系计算稳定性限制系数 $C$：\n        $$ C = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot h^{-1} = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot N $$\n\n该实现将针对指定的参数（$N=16$, $a=1$）和多项式次数（$p \\in \\{2,4,8\\}$）执行这些步骤，并报告每种情况下的系数 $C$。",
            "answer": "```python\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the stability-limited CFL coefficient C for a DG discretization of\n    the linear advection equation using RK4 and LSRK54 time-stepping schemes.\n    \"\"\"\n\n    def leg_gauss_lobatto(p):\n        \"\"\"\n        Computes the Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n\n        Args:\n            p (int): Polynomial degree.\n\n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: LGL nodes.\n                - np.ndarray: LGL weights.\n        \"\"\"\n        if p == 0:\n            return np.array([0.0]), np.array([2.0])\n        if p == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # Nodes are -1, 1, and the roots of P_p'(x).\n        # Roots of P_p'(x) are roots of the Jacobi polynomial P_{p-1}^{(1,1)}(x).\n        roots_jacobi, _ = scipy.special.roots_jacobi(p - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], np.sort(roots_jacobi), [1.0]))\n        \n        # Weights are given by w_i = 2 / (p*(p+1) * [P_p(x_i)]^2).\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        weights = 2.0 / (p * (p + 1) * P_p_at_nodes**2)\n        \n        return nodes, weights\n\n    def diff_matrix(p, nodes):\n        \"\"\"\n        Computes the 1D nodal differentiation matrix on LGL nodes.\n\n        Args:\n            p (int): Polynomial degree.\n            nodes (np.ndarray): LGL nodes.\n\n        Returns:\n            np.ndarray: The (p+1)x(p+1) differentiation matrix.\n        \"\"\"\n        n_pts = p + 1\n        D = np.zeros((n_pts, n_pts))\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = P_p_at_nodes[i] / (P_p_at_nodes[j] * (nodes[i] - nodes[j]))\n        \n        D[0, 0] = -p * (p + 1) / 4.0\n        D[p, p] = p * (p + 1) / 4.0\n        # For i=1..p-1, D[i,i] = 0, which is the default from np.zeros.\n        \n        return D\n\n    def build_L_matrix(p, N, a, D, weights):\n        \"\"\"\n        Builds the global strong-form DG operator matrix L.\n\n        Args:\n            p (int): Polynomial degree.\n            N (int): Number of elements.\n            a (float): Advection speed.\n            D (np.ndarray): Reference element differentiation matrix.\n            weights (np.ndarray): LGL quadrature weights.\n\n        Returns:\n            np.ndarray: The global DG operator matrix.\n        \"\"\"\n        n_pts = p + 1\n        total_dofs = N * n_pts\n        L = np.zeros((total_dofs, total_dofs), dtype=np.float64)\n        h = 1.0 / N\n        w0 = weights[0]\n        \n        flux_coeff = 2.0 * a / (h * w0)\n\n        for k in range(N):\n            start_idx = k * n_pts\n            end_idx = start_idx + n_pts\n            \n            # Volume term (block diagonal part)\n            L[start_idx:end_idx, start_idx:end_idx] = - (2.0 * a / h) * D\n            \n            # Surface flux correction term (upwind for a>0)\n            # This adds to the row for u_{k,0} from u_{k,0} and u_{k-1,p}.\n            row_idx = start_idx\n            \n            # Contribution from u_{k,0}\n            L[row_idx, row_idx] += flux_coeff\n            \n            # Contribution from u_{k-1, p} (periodic boundary)\n            prev_k = (k - 1 + N) % N\n            col_idx = prev_k * n_pts + p\n            L[row_idx, col_idx] -= flux_coeff\n            \n        return L\n\n    def get_stability_poly(scheme):\n        \"\"\"\n        Returns the stability polynomial for a given RK scheme.\n        \n        Args:\n            scheme (str): The scheme identifier (\"RK4\" or \"LSRK54\").\n\n        Returns:\n            np.poly1d: The stability polynomial.\n        \"\"\"\n        if scheme == \"RK4\":\n            # R(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!\n            coeffs = [1/24.0, 1/6.0, 1/2.0, 1.0, 1.0]\n            return np.poly1d(coeffs)\n        elif scheme == \"LSRK54\":\n            # 2-register, 5-stage, 4th-order scheme (Carpenter-Kennedy)\n            # Recurrence: d_i = A_i*d_{i-1} + dt*f(q_{i-1}), q_i = q_{i-1} + B_i*d_i\n            B = np.array([0.118888066885314, 0.281111933114686, 0.5, 0.6, 1.0])\n            A = np.array([0.0, 0.0, -0.0911516952733231, -1.0911516952733231, -1.2])\n\n            z = np.poly1d([1, 0])\n            q_poly = np.poly1d([1.0])\n            d_poly = np.poly1d([0.0])\n\n            for i in range(5):\n                d_poly_new = A[i] * d_poly + q_poly\n                q_poly = q_poly + B[i] * z * d_poly_new\n                d_poly = d_poly_new\n            return q_poly\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    def find_max_dt(eigs, stability_poly):\n        \"\"\"\n        Finds the maximum stable time step using bisection.\n\n        Args:\n            eigs (np.ndarray): Eigenvalues of the DG operator.\n            stability_poly (np.poly1d): The stability polynomial.\n\n        Returns:\n            float: The maximum stable time step.\n        \"\"\"\n        def is_stable(dt):\n            if dt = 1e-12: return True\n            z = dt * eigs\n            R_z = stability_poly(z)\n            return np.max(np.abs(R_z)) = 1.000000001 # Numerical tolerance\n\n        max_eig_mag = np.max(np.abs(eigs))\n        if max_eig_mag  1e-9: return np.inf\n        \n        dt_low = 0.0\n        dt_high = 10.0 / max_eig_mag\n        \n        for _ in range(100):\n            dt_mid = (dt_low + dt_high) / 2.0\n            if is_stable(dt_mid):\n                dt_low = dt_mid\n            else:\n                dt_high = dt_mid\n        \n        return dt_low\n\n    # Problem parameters\n    N = 16\n    a = 1.0\n    p_values = [2, 4, 8]\n    schemes = [\"RK4\", \"LSRK54\"]\n    \n    results = []\n\n    for p in p_values:\n        nodes, weights = leg_gauss_lobatto(p)\n        D = diff_matrix(p, nodes)\n        L = build_L_matrix(p, N, a, D, weights)\n        \n        eigenvalues = np.linalg.eigvals(L)\n        \n        for scheme_name in schemes:\n            poly = get_stability_poly(scheme_name)\n            dt_max = find_max_dt(eigenvalues, poly)\n            h = 1.0 / N\n            C = dt_max * p**2 / h\n            results.append(f\"{C:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了稳定性，保证基本物理定律（如质量守恒）是数值格式的另一个关键特性，在长时间模拟中尤为重要。局部时间步长等高级技术，可能会无意中破坏一个原本守恒格式的离散守恒性。这项高级练习  揭示了现代高性能求解器中一个微妙但至关重要的实现挑战。通过对比一个不守恒的“朴素”实现和一个保证守恒的“内存感知”实现，您将学会如何设计鲁棒的LSRK积分器，使其在采用自适应时间步长等复杂特性时，仍能忠实于底层的物理规律。",
            "id": "3397152",
            "problem": "考虑一维标量平流方程 $u_t + a u_x = 0$，其中常数速度 $a > 0$，定义在一个划分为 $N$ 个单元的周期性域上。使用间断伽辽金（DG）方法，并采用分片常数基函数（多项式阶数 $p = 0$）。在此设置中，单元平均值 $u_e(t)$ 的半离散演化完全由界面通量驱动。设单元循环索引为 $e \\in \\{0,1,\\dots,N-1\\}$，界面 $i$ 位于单元 $e=i$ 和 $f=(i+1) \\bmod N$ 之间。当 $a>0$ 时，采用迎风格式，界面 $i$ 处的数值通量为 $\\phi_i = a u_e$，每个单元 $e$ 的半离散残差为\n$$\nL_e(u) = \\phi_{e-1} - \\phi_e = a u_{e-1} - a u_e,\n$$\n其中索引算术为模 $N$ 运算，并施加周期性边界条件。\n\n使用具有 $S$ 个阶段和系数 $\\{\\alpha_s\\}_{s=1}^S$ 与 $\\{\\beta_s\\}_{s=1}^S$ 的低存储龙格-库塔（LSRK）方法，以双寄存器形式在时间上推进解\n$$\nr^{(s)} = \\alpha_s r^{(s-1)} + L\\!\\left(w^{(s-1)}\\right), \\quad\nw^{(s)} = w^{(s-1)} + \\beta_s \\, \\gamma_s \\, \\Delta t_e \\, r^{(s)} \\quad \\text{逐单元},\n$$\n其中 $w^{(0)} = u^n$ 是时间步开始时的初始场，$r^{(0)} = 0$ 是残差缓冲区，$\\Delta t_e$ 是单元 $e$ 处的局部时间步长，$\\gamma_s$ 是一个依赖于阶段的缩放因子。此实现重复使用单个残差缓冲区 $r$，并在更新时逐单元应用局部时间步长缩放。注意，$L(w)$ 通过界面通量依赖于 $w$。\n\n总离散质量定义为\n$$\nM(t) = \\sum_{e=0}^{N-1} u_e(t).\n$$\n在周期性边界条件和内部界面通量的精确成对抵消下，半离散方法是守恒的，即 $dM/dt = 0$。然而，当 $\\Delta t_e$ 随 $e$ 变化且 $\\gamma_s$ 随 $s$ 变化时，上述 LSRK 更新会破坏离散守恒性，因为大小相等、方向相反的界面贡献在相邻单元上被不同的因子缩放。\n\n您的任务是：\n1. 实现所述的朴素 LSRK 更新方案，该方案重复使用单个残差缓冲区，并在每个阶段逐单元应用局部时间步长重缩放。\n2. 提出并实现一个内存感知的修改方案，该方案在逐单元局部时间步长和逐阶段缩放的条件下，保持跨界面的离散守恒性。该修改方案应使用一个额外的缓冲区来按界面累积界面贡献，并在每个界面上应用一个共同的成对缩放，以使对两个相邻单元的贡献在每个阶段都大小相等、方向相反。具体来说，维护一个按界面的缓冲区 $s_i$，其更新方式为\n$$\ns_i^{(s)} = \\alpha_s s_i^{(s-1)} + \\phi_i\\!\\left(w^{(s-1)}\\right),\n$$\n并使用一个共同的成对缩放 $\\widehat{\\Delta t}_i$（例如，$\\widehat{\\Delta t}_i = \\min(\\Delta t_e,\\Delta t_f)$）来更新相邻单元 $e$ 和 $f$，以确保精确抵消：\n$$\nw_e^{(s)} \\gets w_e^{(s)} - \\beta_s \\, \\gamma_s \\, \\widehat{\\Delta t}_i \\, s_i^{(s)}, \\quad\nw_f^{(s)} \\gets w_f^{(s)} + \\beta_s \\, \\gamma_s \\, \\widehat{\\Delta t}_i \\, s_i^{(s)}.\n$$\n\n使用 Carpenter–Kennedy 低存储龙格-库塔（LSRK）五阶段四阶系数\n$$\n\\alpha = \\left[\n0,\\,\n-\\frac{567301805773}{1357537059087},\\,\n-\\frac{2404267990393}{2016746695238},\\,\n-\\frac{3550918686646}{2091501179385},\\,\n-\\frac{1275806237668}{842570457699}\n\\right],\n$$\n$$\n\\beta = \\left[\n\\frac{1432997174477}{9575080441755},\\,\n\\frac{5161836677717}{13612068292357},\\,\n\\frac{1720146321549}{2090206949498},\\,\n\\frac{3134564353537}{4481467310338},\\,\n\\frac{2277821191437}{14882151754819}\n\\right],\n$$\n以及逐阶段缩放\n$$\n\\gamma = [1.0,\\, 0.9,\\, 1.1,\\, 0.95,\\, 1.05],\n$$\n编写一个程序，对于下述每个测试用例，使用朴素方案和修改后方案执行一个复合时间步（所有 $S$ 个阶段），然后为每个方案计算离散质量变化 $\\Delta M = M^{n+1} - M^n$。\n\n测试套件：\n- 用例 1（均匀局部时间步长）：$N=4$, $a=1.0$, $u^n = [1.0, 2.0, 3.0, 4.0]$, $\\Delta t = [0.1, 0.1, 0.1, 0.1]$。\n- 用例 2（非均匀局部时间步长）：$N=4$, $a=1.0$, $u^n = [1.0, 2.0, 3.0, 4.0]$, $\\Delta t = [0.10, 0.05, 0.20, 0.15]$。\n- 用例 3（单一单元，周期性）：$N=1$, $a=1.0$, $u^n = [1.23]$, $\\Delta t = [0.1]$。\n- 用例 4（多个单元，确定性可变性）：$N=20$, $a=1.0$， $u_e^n$ 由 $u_e^n = \\sin\\!\\left(2\\pi e/N\\right) + 0.5\\, e/N$ 给出（$e=0,\\dots,19$），且 $\\Delta t_e = 0.05 + 0.01\\left( (e \\bmod 5) \\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一对值，并按顺序排列。每对值是一个包含两个浮点数的列表 $[\\Delta M_{\\text{朴素}}, \\Delta M_{\\text{修改}}]$。例如，输出应如下所示\n$$\n[\\,[\\Delta M_{1,\\text{朴素}},\\Delta M_{1,\\text{修改}}],\\,[\\Delta M_{2,\\text{朴素}},\\Delta M_{2,\\text{修改}}],\\,[\\Delta M_{3,\\text{朴素}},\\Delta M_{3,\\text{修改}}],\\,[\\Delta M_{4,\\text{朴素}},\\Delta M_{4,\\text{修改}}]\\,].\n$$\n所有答案均为无量纲实数；无需物理单位。请确保单行输出与此规范完全匹配。",
            "solution": "该问题被评估为有效，因为它代表了偏微分方程数值分析领域中一个适定的、有科学依据的问题。所有参数、方程和初始条件都明确定义，从而能够得到一个唯一且可验证的解。\n\n问题的核心在于使用低存储龙格-库塔（LSRK）方法对半离散平流方程 $u_t + a u_x = 0$ 进行数值时间积分。空间离散化是通过在包含 $N$ 个单元的周期性域上使用分片常数基函数（$p=0$）的间断伽辽金（DG）方法完成的。\n\n### 半离散格式\n对于 DG($p=0$) 格式，每个单元 $e$ 内的解由其平均值 $u_e$ 表示。控制这些平均值时间演化的平流方程半离散形式由下式给出\n$$\n\\frac{du_e}{dt} = L_e(u)\n$$\n其中 $L_e(u)$ 是单元 $e$ 的残差。此残差聚合了跨单元边界的通量的净效应。问题将正平流速度 $a>0$ 时界面 $i$（位于单元 $e=i$ 和 $f=(i+1) \\bmod N$ 之间）的迎风通量定义为 $\\phi_i = a u_i$。单元 $e$ 的残差则是从界面 $e-1$ 流入的通量与在界面 $e$ 流出的通量之差：\n$$\nL_e(u) = \\phi_{e-1} - \\phi_e = a u_{e-1} - a u_e\n$$\n在此，索引取模 $N$ 以施加周期性边界条件。总离散质量定义为 $M(t) = \\sum_{e=0}^{N-1} u_e(t)$。该半离散系统是守恒的，因为在周期性条件下，所有残差之和是一个伸缩求和，其结果抵消为零：\n$$\n\\frac{dM}{dt} = \\sum_{e=0}^{N-1} \\frac{du_e}{dt} = \\sum_{e=0}^{N-1} L_e(u) = \\sum_{e=0}^{N-1} (a u_{e-1} - a u_e) = a \\left( \\sum_{e=0}^{N-1} u_{e-1} - \\sum_{e=0}^{N-1} u_e \\right) = 0\n$$\n\n### 朴素的 LSRK 实现（非守恒）\n指定的 LSRK 格式使用双寄存器形式将解从时间层 $n$ 推进到 $n+1$。这两个寄存器是解缓冲区 $w$ 和残差缓冲区 $r$。涉及 $S$ 个阶段的单个时间步的更新由下式给出：\n$$\nr^{(s)} = \\alpha_s r^{(s-1)} + L\\!\\left(w^{(s-1)}\\right) \\\\\nw^{(s)} = w^{(s-1)} + \\beta_s \\, \\gamma_s \\, \\Delta t_e \\, r^{(s)}\n$$\n初始条件为 $w^{(0)} = u^n$ 和 $r^{(0)} = 0$。关键部分是解 $w^{(s)}$ 的逐单元更新，其中单元 $e$ 的残差 $r^{(s)}$ 按其局部时间步长 $\\Delta t_e$ 进行缩放。\n\n当局部时间步长 $\\Delta t_e$ 非均匀时，此格式未能保持离散质量。在一个完整时间步内，总质量变化为 $\\Delta M = \\sum_e (w^{(S)}_e - w^{(0)}_e) = \\sum_e \\sum_{s=1}^S \\beta_s \\gamma_s \\Delta t_e r_e^{(s)}$。在每个阶段，和 $\\sum_e r_e^{(s)}$ 为零，但加权和 $\\sum_e \\Delta t_e r_e^{(s)}$ 不为零，因为非均匀的 $\\Delta t_e$ 破坏了抵消。例如，在阶段 $s=1$ 时，如果 $\\Delta t_e$ 不是常数，则 $\\sum_e \\Delta t_e r_e^{(1)} = \\sum_e \\Delta t_e L_e(u^n) = a \\sum_e \\Delta t_e (u^n_{e-1} - u^n_e) \\neq 0$。这会在第一阶段引入一个非零的质量变化，并传播到剩余的阶段。\n\n### 修改后的 LSRK 实现（守恒）\n为恢复守恒性，更新机制必须确保在每个阶段，来自任一给定界面的对其两个相邻单元的贡献都是大小相等、方向相反的。提出的修改通过引入一个按界面的残差缓冲区 $s_i$ 来实现这一点。\n界面缓冲区的更新为：\n$$\ns_i^{(s)} = \\alpha_s s_i^{(s-1)} + \\phi_i\\!\\left(w^{(s-1)}\\right)\n$$\n其中 $\\phi_i(w^{(s-1)}) = a w_i^{(s-1)}$ 是界面 $i$ 处的通量。单元 $e$ 的解更新则由其相邻界面 $e-1$ 和 $e$ 的贡献构造而成。关键在于对界面 $i$ 处的通量使用一个共同的、共享的时间步缩放 $\\widehat{\\Delta t}_i$，定义为 $\\widehat{\\Delta t}_i = \\min(\\Delta t_i, \\Delta t_{(i+1)\\bmod N})$。\n\n在阶段 $s$ 时，单元 $e$ 的更新量是来自界面 $e-1$ 的流入量和流向界面 $e$ 的流出量之和：\n$$\n\\Delta w_e^{(s)} = \\underbrace{+\\beta_s \\gamma_s \\widehat{\\Delta t}_{e-1} s_{e-1}^{(s)}}_{\\text{来自界面 } e-1 \\text{ 的流入量}} \\quad \\underbrace{-\\beta_s \\gamma_s \\widehat{\\Delta t}_{e} s_{e}^{(s)}}_{\\text{流向界面 } e \\text{ 的流出量}}\n$$\n总更新为 $w_e^{(s)} = w_e^{(s-1)} + \\Delta w_e^{(s)}$。将这些更新量对所有单元 $e$ 求和，会得到一个计算结果为零的伸缩求和：\n$$\n\\sum_{e=0}^{N-1} \\Delta w_e^{(s)} = \\sum_{e=0}^{N-1} \\beta_s \\gamma_s \\left( \\widehat{\\Delta t}_{e-1} s_{e-1}^{(s)} - \\widehat{\\Delta t}_e s_e^{(s)} \\right) = 0\n$$\n这保证了在时间积分的每个阶段，总离散质量都是守恒的，无论 $\\Delta t_e$ 是否非均匀或 $\\gamma_s$ 是否依赖于阶段。\n\n### 实现\n使用了所提供的五阶段四阶 Carpenter-Kennedy LSRK 系数 $\\{\\alpha_s\\}_{s=1}^5$、$\\{\\beta_s\\}_{s=1}^5$ 以及逐阶段缩放因子 $\\{\\gamma_s\\}_{s=1}^5$。对于每个测试用例，我们为朴素方案和修改后方案计算一个完整的时间步（所有 5 个阶段），并计算总离散质量的变化量 $\\Delta M = M^{n+1} - M^n$。\n\n- **朴素方案算法**：对于每个阶段 $s=1,\\dots,5$：\n    1. 根据当前解 $w^{(s-1)}$ 计算单元残差向量 $L$。\n    2. 更新单元残差缓冲区：$r \\leftarrow \\alpha_s r + L$。\n    3. 更新解向量：$w \\leftarrow w + (\\beta_s \\gamma_s) \\cdot (\\Delta t \\odot r)$，其中 $\\odot$ 是逐元素乘积。\n- **修改后方案算法**：对于每个阶段 $s=1,\\dots,5$：\n    1. 根据当前解 $w^{(s-1)}$ 计算界面通量向量 $\\phi$。\n    2. 更新界面残差缓冲区：$s_{intf} \\leftarrow \\alpha_s s_{intf} + \\phi$。\n    3. 计算按界面的更新项：$U_{intf} = (\\beta_s \\gamma_s) \\cdot (\\widehat{\\Delta t} \\odot s_{intf})$。\n    4. 通过通量差分更新解向量：$w \\leftarrow w + (\\text{roll}(U_{intf}, 1) - U_{intf})$。\n\n测试用例的结果将表明，对于均匀的 $\\Delta t$，两种方案都是守恒的（在机器精度范围内）。然而，对于非均匀的 $\\Delta t$，只有修改后的方案能保持离散质量。",
            "answer": "```python\nimport numpy as np\n\ndef run_case(N, a, u_initial, dt_local):\n    \"\"\"\n    Runs a single test case for both the naive and modified LSRK schemes.\n\n    Args:\n        N (int): Number of elements.\n        a (float): Advection speed.\n        u_initial (np.ndarray): Initial solution vector.\n        dt_local (np.ndarray): Vector of local time steps for each element.\n\n    Returns:\n        list: A list containing two floats: [delta_mass_naive, delta_mass_modified].\n    \"\"\"\n\n    alpha_coeffs = np.array([\n        0.0,\n        -567301805773.0 / 1357537059087.0,\n        -2404267990393.0 / 2016746695238.0,\n        -3550918686646.0 / 2091501179385.0,\n        -1275806237668.0 / 842570457699.0\n    ])\n\n    beta_coeffs = np.array([\n        1432997174477.0 / 9575080441755.0,\n        5161836677717.0 / 13612068292357.0,\n        1720146321549.0 / 2090206949498.0,\n        3134564353537.0 / 4481467310338.0,\n        2277821191437.0 / 14882151754819.0\n    ])\n    \n    gamma_coeffs = np.array([1.0, 0.9, 1.1, 0.95, 1.05])\n    \n    num_stages = 5\n    m_initial = np.sum(u_initial)\n\n    # --- Naive Scheme Implementation ---\n    w_naive = np.copy(u_initial)\n    r_naive = np.zeros(N, dtype=float)\n\n    for s in range(num_stages):\n        # Calculate residual L(w) = a * (u_{e-1} - u_e)\n        L = a * (np.roll(w_naive, 1) - w_naive)\n        \n        # Update residual buffer r\n        r_naive = alpha_coeffs[s] * r_naive + L\n        \n        # Update solution w\n        w_naive += beta_coeffs[s] * gamma_coeffs[s] * dt_local * r_naive\n\n    m_final_naive = np.sum(w_naive)\n    delta_m_naive = m_final_naive - m_initial\n\n    # --- Modified Scheme Implementation ---\n    w_mod = np.copy(u_initial)\n    s_interface = np.zeros(N, dtype=float)\n    \n    # Pairwise time step scaling at interfaces\n    # Interface i is between element i and (i+1)%N\n    dt_hat = np.minimum(dt_local, np.roll(dt_local, -1))\n\n    for s in range(num_stages):\n        # Calculate flux vector phi_i = a * w_i\n        phi = a * w_mod\n        \n        # Update interface residual buffer s\n        s_interface = alpha_coeffs[s] * s_interface + phi\n        \n        # Calculate update term for each interface\n        update_term = beta_coeffs[s] * gamma_coeffs[s] * dt_hat * s_interface\n        \n        # Apply conservative updates to elements\n        # Element e gets inflow from interface e-1 and outflow to interface e\n        delta_w = np.roll(update_term, 1) - update_term\n        w_mod += delta_w\n\n    m_final_mod = np.sum(w_mod)\n    delta_m_mod = m_final_mod - m_initial\n\n    return [delta_m_naive, delta_m_mod]\n\n\ndef solve():\n    \"\"\"\n    Sets up test cases, runs simulations, and prints the formatted results.\n    \"\"\"\n    # Test Case 1\n    case1 = {\n        \"N\": 4, \"a\": 1.0, \n        \"u_initial\": np.array([1.0, 2.0, 3.0, 4.0]),\n        \"dt_local\": np.array([0.1, 0.1, 0.1, 0.1])\n    }\n\n    # Test Case 2\n    case2 = {\n        \"N\": 4, \"a\": 1.0,\n        \"u_initial\": np.array([1.0, 2.0, 3.0, 4.0]),\n        \"dt_local\": np.array([0.10, 0.05, 0.20, 0.15])\n    }\n\n    # Test Case 3\n    case3 = {\n        \"N\": 1, \"a\": 1.0,\n        \"u_initial\": np.array([1.23]),\n        \"dt_local\": np.array([0.1])\n    }\n\n    # Test Case 4\n    N4 = 20\n    e4 = np.arange(N4)\n    u_n4 = np.sin(2 * np.pi * e4 / N4) + 0.5 * e4 / N4\n    dt4 = 0.05 + 0.01 * (e4 % 5)\n    case4 = {\n        \"N\": N4, \"a\": 1.0,\n        \"u_initial\": u_n4,\n        \"dt_local\": dt4\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        res = run_case(case[\"N\"], case[\"a\"], case[\"u_initial\"], case[\"dt_local\"])\n        results.append(res)\n    \n    # Format the final output string as specified\n    result_pairs = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_pairs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}