{
    "hands_on_practices": [
        {
            "introduction": "A fundamental step in developing any numerical method for conservation laws is to verify that it correctly preserves conserved quantities, such as the total mass $I[u]$. This first exercise provides hands-on practice in assembling a Discontinuous Galerkin (DG) residual, $R_i^{(e)}$, for the linear advection equation and numerically verifying the invariance of $I[u]$ on a periodic domain.\n\nBy implementing the strong-form residual with a central flux, you will directly observe how volume and surface contributions conspire to maintain this global invariant . Successfully completing this verification test is a crucial milestone in building confidence in a DG code's basic machinery.",
            "id": "3377756",
            "problem": "Consider the linear advection initial value problem on a periodic one-dimensional domain,\n$$\nu_t + a\\,u_x = 0 \\quad \\text{on} \\quad x \\in [0,L],\n$$\nwith periodic boundary conditions and a dimensionless constant advection speed $a$. The goal is to construct a Discontinuous Galerkin (DG) verification test showing that the discrete integral of $u$ is invariant in time under the DG residual when using a central numerical flux.\n\nWork in the nodal collocation setting with Legendre-Gauss-Lobatto (LGL) nodes. Let each element be an affine map of the reference interval $r \\in [-1,1]$ to a physical element $x \\in [x_{e}, x_{e+1}]$ of uniform length $L_e$, with Jacobian $J_e = L_e/2$. Within each element, represent $u(r,t)$ at the $N+1$ LGL nodes $\\{r_i\\}_{i=0}^N$ using Lagrange interpolation and use LGL quadrature weights $\\{w_i\\}_{i=0}^N$. Let $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ be the differentiation matrix defined by the derivatives of the Lagrange basis polynomials evaluated at the LGL nodes.\n\nDefine the strong-form DG residual for the scalar advection flux $f(u) = a\\,u$ on element $e$ and node $i$ by\n$$\nR_i^{(e)} = -\\frac{2}{L_e}\\sum_{j=0}^N D_{ij}\\,f\\!\\left(u_j^{(e)}\\right) \\;+\\; \\frac{2}{L_e\\,w_i}\n\\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f(u_N^{(e)})\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f(u_0^{(e)})\\big) \\Big),\n$$\nwhere $f^{*}_{\\text{left}}$ and $f^{*}_{\\text{right}}$ are the consistent numerical fluxes at the left and right interfaces of element $e$, respectively, and $\\delta_{i,k}$ is the Kronecker delta. Use the central numerical flux\n$$\nf^{*} = \\frac{1}{2}\\Big(f(u^{-}) + f(u^{+})\\Big) = \\frac{a}{2}\\Big(u^{-} + u^{+}\\Big),\n$$\nwhere $u^{-}$ and $u^{+}$ denote the interior and exterior traces at the interface. Enforce periodicity by taking the exterior trace at the domain boundaries from the opposite end of the mesh.\n\nDefine the discrete integral (with LGL quadrature) of the DG field $u$ as\n$$\nI[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, u_i^{(e)}.\n$$\nYour task is to implement a program that:\n1. Constructs the LGL nodes, LGL weights, and the Lagrange differentiation matrix $D$ for any polynomial degree $N \\geq 1$.\n2. Builds a periodic mesh with $E$ elements over $[0,L]$ with uniform element size $L_e = L/E$.\n3. Assembles the DG strong-form residual $R_i^{(e)}$ using the central numerical flux and evaluates the discrete time derivative of the integral as\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}.\n$$\n4. Verifies the invariance of the discrete integral by checking that $\\left|\\frac{d}{dt}I[u]\\right|$ is below a prescribed tolerance for several test cases.\n\nAll quantities are to be treated as dimensionless. Angles do not appear in this problem. Use the following test suite, which specifies the mesh, polynomial order, domain length, advection speed, and initial condition. For each case, construct the nodal values $u_i^{(e)}$ by evaluating the given initial condition at the physical coordinates of the LGL nodes.\n\nTest suite:\n- Case 1 (smooth “happy path”): $E=4$, $N=3$, $L=1$, $a=1$, $u(x)=\\sin(2\\pi x/L)$.\n- Case 2 (discontinuous profile, negative speed): $E=3$, $N=2$, $L=2$, $a=-0.7$, $u(x)=\\begin{cases}1 & \\text{if } x<L/2,\\\\ 0 & \\text{otherwise.}\\end{cases}$\n- Case 3 (single element, higher order, random nodal values): $E=1$, $N=5$, $L=1$, $a=0.3$, $u$ is pseudo-random at nodes with a fixed seed for reproducibility.\n- Case 4 (many elements, lowest order): $E=8$, $N=1$, $L=1$, $a=3$, $u$ is pseudo-random at nodes with a fixed seed for reproducibility.\n- Case 5 (smooth with different domain length): $E=5$, $N=4$, $L=\\pi$, $a=2$, $u(x)=\\cos(x)$.\n\nTolerance specification:\n- Use a tolerance of $\\varepsilon = 5\\times 10^{-12}$ for the check $\\left|\\frac{d}{dt}I[u]\\right| \\le \\varepsilon$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[result1,result2,result3]”), where each result is a boolean indicating whether the invariance condition holds for that test case.",
            "solution": "The problem requires the verification of a conservation property for a nodal Discontinuous Galerkin (DG) method applied to the one-dimensional linear advection equation, $u_t + a\\,u_x = 0$. Specifically, we must show that the discrete spatial integral of the solution, $I[u]$, is invariant in time when using the prescribed strong-form DG residual with a central numerical flux. The time derivative of the discrete integral is given by\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}\n$$\nWe will first prove analytically that this quantity is zero up to machine precision, and then implement a numerical test to verify this conclusion for the provided test cases.\n\n**Theoretical Verification of Integral Invariance**\n\nThe core of the verification lies in a careful summation of the residual contributions across all elements in the periodic domain. The time derivative of the discrete integral $I[u]$ is given by the sum of the changes within each element. Let us analyze the contribution from a single element, $e$. This contribution is $Q^{(e)} = \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}$.\n\nSubstituting the given definition of the strong-form residual $R_i^{(e)}$:\n$$\nR_i^{(e)} = -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f_N^{(e)}\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f_0^{(e)}\\big) \\Big),\n$$\nwhere we use the notation $f_j^{(e)} = f(u_j^{(e)})$ and have substituted $J_e = L_e/2$. The contribution $Q^{(e)}$ becomes:\n$$\nQ^{(e)} = \\sum_{i=0}^{N} J_e w_i \\left[ -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big) \\right]\n$$\nThe Jacobian $J_e$ cancels in both terms:\n$$\nQ^{(e)} = -\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} \\;+\\; \\sum_{i=0}^{N} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big)\n$$\nThe second term simplifies due to the Kronecker delta $\\delta_{i,k}$, which is $1$ if $i=k$ and $0$ otherwise. The sum over $i$ collapses, leaving only the terms for $i=0$ and $i=N$:\n$$\n\\sum_{i=0}^{N} \\Big( \\dots \\Big) = (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\nThe first term involves the differentiation matrix $D$ and the quadrature weights $w$. For a differentiation matrix based on Legendre-Gauss-Lobatto (LGL) nodes and the corresponding quadrature weights, they satisfy a Summation-By-Parts (SBP) property. Specifically, for any vector of nodal values $\\mathbf{g} = [g_0, \\dots, g_N]^T$ representing a polynomial of degree at most $N$, the discrete integral of its derivative is exact:\n$$\n\\sum_{i=0}^{N} w_i (D\\mathbf{g})_i = \\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij} g_j = g_N - g_0\n$$\nApplying this SBP property to our flux vector $\\mathbf{f}^{(e)}$, which represents a polynomial of degree $N$ since $f(u)=a\\,u$ is linear, we get:\n$$\n\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} = f_N^{(e)} - f_0^{(e)}\n$$\nSubstituting these results back into the expression for $Q^{(e)}$:\n$$\nQ^{(e)} = -(f_N^{(e)} - f_0^{(e)}) + (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\nThis can be rearranged to:\n$$\nQ^{(e)} = (f_0^{(e)} - f^{*}_{\\text{left}}) - (f_N^{(e)} - f^{*}_{\\text{right}})\n$$\nNow, we introduce the definition of the central numerical flux, $f^{*} = \\frac{1}{2}(f(u^{-}) + f(u^{+}))$. At the left interface of element $e$, the interior trace is $u^{-} = u_0^{(e)}$ and the exterior trace $u^{+}$ is the solution value from the right boundary of the neighboring element to the left, which we denote $u_N^{(e-1)}$. Thus,\n$$\nf^{*}_{\\text{left}} = f^{*}_{e-1/2} = \\frac{1}{2}\\Big(f(u_0^{(e)}) + f(u_N^{(e-1)})\\Big) = \\frac{1}{2}\\Big(f_0^{(e)} + f_N^{(e-1)}\\Big)\n$$\nSimilarly, at the right interface of element $e$, the interior trace is $u^{-} = u_N^{(e)}$ and the exterior trace is $u^{+} = u_0^{(e+1)}$. Thus,\n$$\nf^{*}_{\\text{right}} = f^{*}_{e+1/2} = \\frac{1}{2}\\Big(f(u_N^{(e)}) + f(u_0^{(e+1)})\\Big) = \\frac{1}{2}\\Big(f_N^{(e)} + f_0^{(e+1)}\\Big)\n$$\nSubstituting these into the expression for $Q^{(e)}$:\n$$\nQ^{(e)} = \\left(f_0^{(e)} - \\frac{1}{2}(f_0^{(e)} + f_N^{(e-1)})\\right) - \\left(f_N^{(e)} - \\frac{1}{2}(f_N^{(e)} + f_0^{(e+1)})\\right)\n$$\n$$\nQ^{(e)} = \\frac{1}{2}\\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\frac{1}{2}\\Big(f_N^{(e)} - f_0^{(e+1)}\\Big)\n$$\nThe total rate of change is the sum over all elements, $\\frac{d}{dt}I[u] = \\sum_{e=1}^{E} Q^{(e)}$. Due to the periodic domain, the element indices are taken modulo $E$.\n$$\n\\frac{d}{dt}I[u] = \\frac{1}{2} \\sum_{e=1}^{E} \\left[ \\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\Big(f_N^{(e)} - f_0^{(e+1)}\\Big) \\right]\n$$\nLet's examine the terms in this summation. The term $\\frac{1}{2}(f_0^{(e)} - f_N^{(e-1)})$ is associated with the interface between elements $e-1$ and $e$. The term $-\\frac{1}{2}(f_N^{(e)} - f_0^{(e+1)})$ is associated with the interface between elements $e$ and $e+1$. When we sum over all $e$, each interface is visited twice. For the interface between element $k$ and $k+1$, we get a contribution from $Q^{(k)}$ and $Q^{(k+1)}$:\n- From $Q^{(k)}$ (as the right interface): $-\\frac{1}{2}(f_N^{(k)} - f_0^{(k+1)})$\n- From $Q^{(k+1)}$ (as the left interface): $+\\frac{1}{2}(f_0^{(k+1)} - f_N^{(k)})$\nThese two terms are equal and opposite, summing to zero. This cancellation occurs at every interface within the domain. Because of periodicity, the interface between element $E$ and element $1$ also exhibits this cancellation. Therefore, the entire sum is a telescoping sum that evaluates to exactly zero.\n\nThis proves that for the given DG formulation with a central flux, the discrete integral is conserved regardless of the initial data. The numerical implementation should confirm this, with any non-zero result being attributable to floating-point arithmetic errors.\n\n**Algorithmic Implementation**\n\nThe numerical verification proceeds as follows:\n$1$. **LGL Utilities**: For each required polynomial degree $N$, we generate the $N+1$ Legendre-Gauss-Lobatto (LGL) nodes $\\{r_i\\}$, quadrature weights $\\{w_i\\}$, and the differentiation matrix $D$.\n    - The nodes $r_i$ are the roots of $(1-r^2)L'_N(r)$, where $L_N$ is the Legendre polynomial of degree $N$. The exterior nodes are always $r_0=-1$ and $r_N=1$. The interior nodes are the roots of $L'_N(r)$.\n    - The weights are given by the formula $w_i = \\frac{2}{N(N+1)L_N(r_i)^2}$.\n    - The off-diagonal entries of the differentiation matrix are $D_{ij} = \\frac{L_N(r_i)}{L_N(r_j)(r_i-r_j)}$ for $i \\neq j$. The diagonal entries are $D_{00} = -\\frac{N(N+1)}{4}$, $D_{NN} = \\frac{N(N+1)}{4}$, and $D_{ii}=0$ for $i \\in \\{1,\\dots,N-1\\}$.\n$2$. **Mesh and State Initialization**: A uniform periodic mesh of $E$ elements is created on $[0, L]$. The physical coordinates of all LGL nodes are determined using the affine mapping $x_i^{(e)} = x_e + (r_i+1)J_e$, where $J_e = L_e/2 = L/(2E)$. The nodal solution values $u_i^{(e)}$ are initialized by evaluating the specified initial condition function at these physical coordinates. For random cases, a pseudo-random number generator with a fixed seed is used to populate these values.\n$3$. **Residual and Integral Evaluation**: The program iterates through each element $e=1, \\dots, E$ to compute its contribution to $\\frac{d}{dt}I[u]$.\n    - For each element $e$, the nodal solution vector $\\mathbf{u}^{(e)}$ is used to form the flux vector $\\mathbf{f}^{(e)} = a\\,\\mathbf{u}^{(e)}$.\n    - The interior traces $u_0^{(e)}$ and $u_N^{(e)}$ are identified. The exterior trace values, $u_N^{(e-1)}$ and $u_0^{(e+1)}$, are retrieved from neighboring elements, respecting the mesh periodicity.\n    - The left and right numerical fluxes, $f^{*}_{\\text{left}}$ and $f^{*}_{\\text{right}}$, are computed using the central flux formula.\n    - The strong-form residual vector $\\mathbf{R}^{(e)}$ is assembled according to the provided equation.\n    - The contribution from this element to the time derivative of the integral, $Q^{(e)} = J_e \\mathbf{w}^T \\mathbf{R}^{(e)}$, is computed and added to a running total.\n$4$. **Verification**: After summing contributions from all elements, the absolute value of the total $\\frac{d}{dt}I[u]$ is compared against the specified tolerance $\\varepsilon = 5 \\times 10^{-12}$. The result for each test case is a boolean indicating whether the computed value is within this tolerance.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_lgl_basis(N):\n    \"\"\"\n    Computes LGL nodes, weights, and differentiation matrix for a given degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0]), np.array([[0.0]])\n    \n    # Nodes are roots of (1-x^2) * L_N'(x)\n    # Interior nodes are roots of L_N'(x)\n    p_N = legendre(N)\n    p_N_prime_roots = p_N.deriv().roots\n    nodes = np.concatenate(([-1.0], np.sort(p_N_prime_roots), [1.0]))\n\n    # Weights\n    weights = 2.0 / (N * (N + 1) * (p_N(nodes)**2))\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_N(nodes[i]) / (p_N(nodes[j]) * (nodes[i] - nodes[j]))\n    \n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    \n    return nodes, weights, D\n\n# Cache for LGL basis to avoid recomputation\nLGL_CACHE = {}\n\ndef get_cached_lgl_basis(N):\n    if N not in LGL_CACHE:\n        LGL_CACHE[N] = get_lgl_basis(N)\n    return LGL_CACHE[N]\n\ndef calculate_dIdt(E, N, L, a, u_func, is_random=False, rng=None):\n    \"\"\"\n    Calculates the discrete time derivative of the integral I[u] for a given test case.\n    \"\"\"\n    # 1. Construct LGL basis\n    r, w, D = get_cached_lgl_basis(N)\n    \n    # 2. Build periodic mesh and initialize solution\n    Le = L / E\n    Je = Le / 2.0\n    \n    # Element boundaries\n    x_bounds = np.linspace(0, L, E + 1)\n    \n    # Store all nodal values for easy access to neighbors\n    u_all = np.zeros((E, N + 1))\n    \n    if is_random:\n        u_all = rng.random((E, N + 1))\n    else:\n        for e in range(E):\n            x_e_start = x_bounds[e]\n            # Map reference nodes to physical nodes for this element\n            x_nodes_e = x_e_start + (r + 1) * Je\n            u_all[e, :] = u_func(x_nodes_e, L)\n\n    # 3. Assemble residual and evaluate discrete time derivative of the integral\n    dIdt = 0.0\n    \n    for e in range(E):\n        u_e = u_all[e, :]\n        f_e = a * u_e\n        \n        # Volume term contribution to the residual\n        R_vol = -(1.0 / Je) * (D @ f_e)\n        \n        # Surface term contribution (flux corrections)\n        \n        # Left interface of element e\n        u_minus_left = u_e[0]\n        # Find left neighbor (periodic)\n        e_left = (e - 1 + E) % E\n        u_plus_left = u_all[e_left, N]\n        f_star_left = (a / 2.0) * (u_minus_left + u_plus_left)\n        \n        # Right interface of element e\n        u_minus_right = u_e[N]\n        # Find right neighbor (periodic)\n        e_right = (e + 1) % E\n        u_plus_right = u_all[e_right, 0]\n        f_star_right = (a / 2.0) * (u_minus_right + u_plus_right)\n        \n        # Complete residual R for element e\n        R_e = np.copy(R_vol)\n        R_e[N] += (1.0 / (Je * w[N])) * (f_star_right - f_e[N])\n        R_e[0] -= (1.0 / (Je * w[0])) * (f_star_left - f_e[0])\n        \n        # Add element's contribution to dI/dt\n        # This is sum_{i=0 to N} J_e * w_i * R_i^(e)\n        dIdt += Je * np.dot(w, R_e)\n        \n    return dIdt\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (smooth “happy path”)\n        {'E': 4, 'N': 3, 'L': 1.0, 'a': 1.0, 'u_func': lambda x, L: np.sin(2 * np.pi * x / L)},\n        # Case 2 (discontinuous profile, negative speed)\n        {'E': 3, 'N': 2, 'L': 2.0, 'a': -0.7, 'u_func': lambda x, L: np.where(x < L / 2.0, 1.0, 0.0)},\n        # Case 3 (single element, higher order, random nodal values)\n        {'E': 1, 'N': 5, 'L': 1.0, 'a': 0.3, 'u_func': None, 'is_random': True, 'seed': 42},\n        # Case 4 (many elements, lowest order)\n        {'E': 8, 'N': 1, 'L': 1.0, 'a': 3.0, 'u_func': None, 'is_random': True, 'seed': 123},\n         # Case 5 (smooth with different domain length)\n        {'E': 5, 'N': 4, 'L': np.pi, 'a': 2.0, 'u_func': lambda x, L: np.cos(x)},\n    ]\n    \n    tolerance = 5e-12\n    results = []\n\n    for case in test_cases:\n        rng = None\n        if case.get('is_random', False):\n            rng = np.random.default_rng(seed=case['seed'])\n            \n        dIdt_val = calculate_dIdt(\n            E=case['E'], \n            N=case['N'], \n            L=case['L'], \n            a=case['a'], \n            u_func=case['u_func'],\n            is_random=case.get('is_random', False),\n            rng=rng\n        )\n        \n        results.append(abs(dIdt_val) <= tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the concept of discrete conservation, this practice explores the deep algebraic structure that underpins this property: the Summation-By-Parts (SBP) identity, $D^\\top M = - M D + R^\\top B R$. You will investigate how the choice of nodal points—specifically comparing Gauss-Lobatto-Legendre with Gauss-Legendre nodes—impacts the validity of this identity.\n\nThis exercise reveals the crucial link between the geometry of the basis and the fundamental properties of the discrete operators $D$ and $M$ . Understanding this connection is key to designing discretely conservative schemes and diagnosing unexpected non-conservation in practice.",
            "id": "3377712",
            "problem": "Investigate how the choice of nodal distribution affects operator assembly and residual evaluation in the Discontinuous Galerkin (DG) method for a one-dimensional linear advection equation. Specifically, compare Gauss–Lobatto–Legendre nodes with Gauss–Legendre nodes in terms of face–volume coupling and discrete conservation properties when assembling a strong-form DG residual from a weak-form discretization using the Summation-By-Parts (SBP) identity.\n\nConsider the one-dimensional linear advection equation\n$$\nu_t + a\\,u_x = 0\n$$\non the domain $[0,1]$ with periodic boundary conditions, where $a$ is a constant advection speed. Partition the domain into $N_e$ uniform elements of size $h = 1/N_e$, each mapped to the reference interval $[-1,1]$ via $x = x_L + \\tfrac{h}{2}(r+1)$, where $x_L$ is the left endpoint of the element and $r \\in [-1,1]$ is the reference coordinate. Let the Jacobian of the mapping be $J = h/2$.\n\nUse a nodal Lagrange polynomial basis of degree $p$ on each element with $N = p+1$ nodes. Investigate two nodal distributions:\n- Gauss–Lobatto–Legendre nodes, which include the endpoints $-1$ and $1$.\n- Gauss–Legendre nodes, which exclude the endpoints.\n\nDefine the diagonal quadrature-based mass matrix $M \\in \\mathbb{R}^{N \\times N}$ with entries given by the quadrature weights, the nodal differentiation matrix $D \\in \\mathbb{R}^{N \\times N}$ associated with the Lagrange basis, the restriction operator $R \\in \\mathbb{R}^{2 \\times N}$ that evaluates nodal polynomials at the two faces $r=-1$ and $r=1$, and the face orientation matrix $B = \\mathrm{diag}(-1,1)$. The Summation-By-Parts (SBP) identity on the reference element is\n$$\nD^\\top M = - M D + R^\\top B R.\n$$\nThis identity holds exactly for Gauss–Lobatto–Legendre collocation, but not for Gauss–Legendre collocation.\n\nStarting from the weak-form DG discretization on the reference element,\n$$\nM\\,J\\,\\dot{u} = -a\\,D^\\top M\\,u + R^\\top B\\,f^\\ast,\n$$\nwhere $f^\\ast$ is the two-component numerical flux vector at the element faces, derive the strong-form DG residual by substituting the SBP identity, yielding\n$$\n\\dot{u} = \\frac{a}{J} D\\,u + \\frac{1}{J} M^{-1} R^\\top B \\left(f^\\ast - a\\,R\\,u\\right).\n$$\nAssemble this strong-form residual element-wise using periodic boundary conditions and the upwind numerical flux for $a>0$, namely $f^\\ast = a\\,u^{-}$ on each face, where $u^{-}$ is the interior trace from the upwind side. For periodic boundaries, the left face flux of an element is taken from the right face interior trace of its left neighbor.\n\nYou must quantify:\n1. The face–volume mismatch for each nodal distribution, defined as the Frobenius norm\n$$\n\\left\\| M D + D^\\top M - R^\\top B R \\right\\|_F,\n$$\ncomputed on the reference element.\n2. The discrete conservation error induced by assembling the strong-form residual using the SBP substitution. This is defined as the absolute value of the global mass rate\n$$\n\\left|\\sum_{e=1}^{N_e} J \\sum_{i=1}^{N} w_i\\,\\dot{u}_i^{(e)}\\right|,\n$$\nwhere $w_i$ are the quadrature weights, $J$ is the element Jacobian, and $\\dot{u}_i^{(e)}$ are the nodal time derivatives in element $e$ from the strong-form residual. For periodic boundaries and the exact weak form, this quantity should be exactly zero; any nonzero value reflects a loss of discrete conservation attributable to face–volume mismatch in the strong assembly.\n\nAngle units (for trigonometric initial data) must be in radians.\n\nYour program must implement:\n- Construction of Gauss–Legendre nodes and weights.\n- Construction of Gauss–Lobatto–Legendre nodes and weights, using roots of the derivative of the Legendre polynomial $P_{N-1}'$ (equivalently, roots of the Jacobi polynomial $P_{N-2}^{(1,1)}$) for interior nodes, and exact endpoint inclusion.\n- Barycentric weights for nodal Lagrange interpolation.\n- The nodal differentiation matrix $D$ via barycentric weights.\n- The restriction operator $R$ that evaluates nodal polynomials at $r=-1$ and $r=1$ via barycentric interpolation.\n- Assembly of the strong-form DG residual using the formula above, periodic connectivity, and upwind flux for $a>0$.\n\nTest Suite:\nProvide three test cases to evaluate different aspects:\n- Case $1$ (general/happy path): $p=4$, $N_e=4$, $a=1.0$, initial condition $u(x)=\\sin(2\\pi x)$.\n- Case $2$ (single element periodic boundary): $p=5$, $N_e=1$, $a=1.0$, initial condition $u(x)$ equal to the Legendre polynomial $P_p(r)$ evaluated on each element in reference coordinates $r$.\n- Case $3$ (edge case with under-resolution): $p=2$, $N_e=3$, $a=1.0$, initial condition $u(x)=\\sin(10\\pi x)$.\n\nFor each case, compute and report four floats in the following fixed order:\n- Face–volume mismatch norm for Gauss–Lobatto–Legendre nodes.\n- Face–volume mismatch norm for Gauss–Legendre nodes.\n- Discrete conservation error (absolute global mass rate) for Gauss–Lobatto–Legendre nodes.\n- Discrete conservation error (absolute global mass rate) for Gauss–Legendre nodes.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by concatenating the four outputs for Case $1$, then Case $2$, then Case $3$:\n$$\n[\\text{C1\\_GLL\\_mismatch},\\text{C1\\_GL\\_mismatch},\\text{C1\\_GLL\\_cons\\_err},\\text{C1\\_GL\\_cons\\_err},\\text{C2\\_GLL\\_mismatch},\\text{C2\\_GL\\_mismatch},\\text{C2\\_GLL\\_cons\\_err},\\text{C2\\_GL\\_cons\\_err},\\text{C3\\_GLL\\_mismatch},\\text{C3\\_GL\\_mismatch},\\text{C3\\_GLL\\_cons\\_err},\\text{C3\\_GL\\_cons\\_err}]\n$$\nAll outputs must be real numbers (floats).",
            "solution": "The problem requires an investigation into the effects of nodal distribution—specifically, Gauss–Lobatto–Legendre (GLL) versus Gauss–Legendre (GL) nodes—on operator assembly and conservation properties in a Discontinuous Galerkin (DG) method. The analysis is performed for the one-dimensional linear advection equation, $u_t + a\\,u_x = 0$, discretized using a nodal DG approach on a reference element interval $r \\in [-1,1]$.\n\n**1. Nodal Basis and Quadrature**\n\nThe solution on each element is approximated by a polynomial of degree $p$ constructed from a Lagrange basis defined on a set of $N=p+1$ nodes.\n- **Gauss–Lobatto–Legendre (GLL) nodes:** These $N$ nodes include the endpoints $r=\\{-1, 1\\}$. The $N-2$ interior nodes are the roots of the derivative of the $p$-th degree Legendre polynomial, $P_p'(r)$, which are equivalent to the roots of the Jacobi polynomial $P_{p-2}^{(1,1)}(r)$. This choice is crucial as it leads to an exact Summation-By-Parts (SBP) property.\n- **Gauss–Legendre (GL) nodes:** These $N$ nodes are the roots of the $(p+1)$-th degree Legendre polynomial, $P_{p+1}(r)$. They are all located in the interior of the interval $(-1,1)$. This choice results in a higher-order accurate quadrature rule but does not satisfy the SBP property exactly.\n\nFor each nodal set, we define a diagonal mass matrix $M$, whose entries $M_{ii}$ are the corresponding quadrature weights $w_i$.\n\n**2. Differentiation and Restriction Operators**\n\n- **Differentiation Matrix ($D$):** The nodal differentiation matrix $D$ is constructed such that for a vector $u$ of nodal values, $D u$ gives the nodal values of the derivative of the corresponding interpolating polynomial. It is computed efficiently using barycentric interpolation weights.\n- **Restriction Operator ($R$):** The restriction operator $R \\in \\mathbb{R}^{2 \\times N}$ evaluates the polynomial at the element faces, $r=-1$ and $r=1$. For GLL nodes, which include the endpoints, $R$ is a sparse matrix of zeros with a $1$ in the columns corresponding to the endpoint nodes. For GL nodes, $R$ is dense and its entries are computed using the barycentric formula for Lagrange interpolation at $r=\\{-1, 1\\}$.\n\n**3. The Summation-By-Parts (SBP) Property and Face–Volume Mismatch**\n\nThe SBP property is a discrete analogue of integration by parts and is fundamental to proving the stability and conservation of high-order numerical schemes. For our nodal DG setting, it is expressed as:\n$$\nD^\\top M + M D = R^\\top B R\n$$\nwhere $B = \\mathrm{diag}(-1,1)$ is the face orientation matrix. This identity states that the differentiation operator is skew-symmetric up to a boundary term. A key theoretical result is that this identity holds *exactly* for GLL nodes and their corresponding quadrature rule. For GL nodes, it does not.\n\nTo quantify this, we compute the **face–volume mismatch**, defined by the Frobenius norm of the SBP error matrix:\n$$\n\\text{mismatch} = \\left\\| M D + D^\\top M - R^\\top B R \\right\\|_F\n$$\nFor GLL nodes, this norm will be zero up to machine precision. For GL nodes, it will be non-zero, indicating a discrepancy between the volume integral term (left side) and the face integral term (right side) in the discrete integration-by-parts identity.\n\n**4. Weak vs. Strong Form and the Role of SBP**\n\nThe problem provides a starting weak-form DG discretization on the reference element:\n$$\nM\\,J\\,\\dot{u} = -a\\,D^\\top M\\,u + R^\\top B\\,f^\\ast\n$$\nHere, $J$ is the Jacobian of the mapping, $\\dot{u}$ is the vector of nodal time derivatives, and $f^\\ast$ is the numerical flux vector at the element faces.\n\nA \"strong form\" can be derived by formally substituting the SBP identity ($D^\\top M = -MD + R^\\top B R$) into the weak form. This yields the expression for the residual used in the computation:\n$$\n\\dot{u} = \\frac{a}{J} D\\,u + \\frac{1}{J} M^{-1} R^\\top B \\left(f^\\ast - a\\,R\\,u\\right)\n$$\nThe term $f^\\ast - a\\,R\\,u$ represents the difference between the numerical flux and the physical flux, $f(u)=au$, traced to the element boundary. For the upwind flux ($f^\\ast = au^-$ with $a>0$) on periodic elements, this difference is non-zero only at the left face of each element, where it is proportional to the jump in the solution.\n\n**5. Discrete Conservation and its Error**\n\nThe global rate of change of mass is given by $\\frac{d}{dt} \\sum_{e} \\int_{K_e} u \\,dx$, which discretizes to $\\sum_e J \\sum_i w_i \\dot{u}_i^{(e)}$. The problem states that for the exact weak form with periodic boundaries, this quantity is zero, meaning the method is discretely conservative.\n\nWhen we compute $\\dot{u}$ using the strong form derived via the SBP substitution, we can measure the induced **discrete conservation error**:\n$$\n\\text{error} = \\left|\\sum_{e=1}^{N_e} J \\sum_{i=1}^{N} w_i\\,\\dot{u}_i^{(e)}\\right|\n$$\n- For **GLL nodes**, the SBP substitution is exact. The derived strong form is algebraically equivalent to the conservative weak form. Therefore, the computed conservation error is expected to be near zero (machine precision).\n- For **GL nodes**, the SBP substitution is inexact due to the non-zero face–volume mismatch. The derived strong form is therefore not equivalent to the original weak form. This algebraic inconsistency breaks the cancellation of terms that ensures conservation, leading to a non-zero conservation error.\n\nThe implementation systematically constructs these operators for both nodal types, assembles the strong-form residual element by element with periodic connectivity, and then computes the two specified metrics (mismatch norm and conservation error) for each test case. This quantitatively demonstrates the crucial role of the SBP property in linking operator structure to fundamental conservation laws in DG methods.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre, roots_legendre, legendre\n\ndef gauss_lobatto_legendre_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre nodes and weights for polynomial degree p.\n    Nodes are roots of (1-x^2)P_p'(x).\n    \"\"\"\n    N = p + 1\n    if N == 1:\n        return np.array([0.0]), np.array([2.0])\n    \n    # Nodes are -1, 1, and roots of P_p'(x), which are roots of Jacobi P_{p-1}^{(1,1)}(x)\n    # The degree of the Jacobi polynomial is p-1 = N-2.\n    interior_nodes = roots_jacobi(p - 1, 1, 1)[0] if p > 1 else np.array([])\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights using formula: w_i = 2 / (p*(p+1) * [P_p(x_i)]^2)\n    Pn = legendre(p)\n    weights = 2 / (p * N * Pn(nodes)**2)\n    \n    idx = np.argsort(nodes)\n    nodes = nodes[idx]\n    weights = weights[idx]\n    \n    return nodes, weights\n\ndef gauss_legendre_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Legendre nodes and weights for polynomial degree p.\n    Uses N=p+1 points. Nodes are roots of P_{p+1}(x).\n    \"\"\"\n    N = p + 1\n    nodes, weights = roots_legendre(N)\n    \n    idx = np.argsort(nodes)\n    nodes = nodes[idx]\n    weights = weights[idx]\n    \n    return nodes, weights\n\ndef barycentric_weights(nodes):\n    \"\"\"\n    Computes barycentric weights for Lagrange interpolation.\n    \"\"\"\n    N = len(nodes)\n    weights = np.ones(N)\n    for j in range(N):\n        for k in range(N):\n            if k != j:\n                weights[j] /= (nodes[j] - nodes[k])\n    return weights\n\ndef differentiation_matrix(nodes, bary_weights):\n    \"\"\"\n    Computes the nodal differentiation matrix using the barycentric formula.\n    \"\"\"\n    N = len(nodes)\n    D = np.zeros((N, N))\n    for i in range(N):\n        sum_row = 0.0\n        for j in range(N):\n            if i != j:\n                D[i, j] = (bary_weights[j] / bary_weights[i]) / (nodes[i] - nodes[j])\n                sum_row += D[i, j]\n        D[i, i] = -sum_row\n    return D\n\ndef restriction_operator(nodes, bary_weights):\n    \"\"\"\n    Computes the restriction operator R for evaluating polynomials at r=-1 and r=1.\n    \"\"\"\n    N = len(nodes)\n    R = np.zeros((2, N))\n    \n    # Evaluation at r = -1\n    # Check if -1 is a node to avoid division by zero\n    if np.any(np.isclose(nodes, -1.0)):\n        idx = np.where(np.isclose(nodes, -1.0))[0][0]\n        R[0, idx] = 1.0\n    else:\n        # Use barycentric formula for L_j(-1)\n        terms = bary_weights / (-1.0 - nodes)\n        R[0, :] = terms / np.sum(terms)\n\n    # Evaluation at r = 1\n    if np.any(np.isclose(nodes, 1.0)):\n        idx = np.where(np.isclose(nodes, 1.0))[0][0]\n        R[1, idx] = 1.0\n    else:\n        # Use barycentric formula for L_j(1)\n        terms = bary_weights / (1.0 - nodes)\n        R[1, :] = terms / np.sum(terms)\n        \n    return R\n\ndef run_case(p, Ne, a, ic_func):\n    \"\"\"\n    Runs a single test case for both GLL and GL nodes, returning a list of 4 results.\n    \"\"\"\n    N = p + 1\n    h = 1.0 / Ne\n    J = h / 2.0\n    B = np.diag([-1.0, 1.0])\n    \n    case_results = []\n    \n    # --- Process for both GLL and GL node types ---\n    node_types = ['GLL', 'GL']\n    for node_type in node_types:\n        if node_type == 'GLL':\n            nodes, weights = gauss_lobatto_legendre_nodes_weights(p)\n            R = np.zeros((2, N))\n            R[0, 0] = 1.0 # Node 0 is at -1\n            R[1, -1] = 1.0 # Node N-1 is at 1\n        else: # GL\n            nodes, weights = gauss_legendre_nodes_weights(p)\n            bary_w = barycentric_weights(nodes)\n            R = restriction_operator(nodes, bary_w)\n\n        bary_weights = barycentric_weights(nodes)\n        D = differentiation_matrix(nodes, bary_weights)\n        M = np.diag(weights)\n\n        # 1. Face-volume mismatch norm\n        mismatch_norm = np.linalg.norm(M @ D + D.T @ M - R.T @ B @ R, 'fro')\n        \n        # 2. Discrete conservation error\n        # Initialize solution vector over all elements\n        u_global = np.zeros((Ne, N))\n        for e in range(Ne):\n            x_L = e * h\n            x_phys = x_L + J * (nodes + 1.0)\n            u_global[e, :] = ic_func(x_phys)\n            \n        u_dot_global = np.zeros((Ne, N))\n        M_inv = np.diag(1.0 / weights)\n    \n        # Assemble strong-form residual for all elements\n        for e in range(Ne):\n            u_e = u_global[e, :]\n            e_minus = (e - 1 + Ne) % Ne # Periodic neighbor\n            u_e_minus = u_global[e_minus, :]\n            \n            # For a > 0, upwind flux is determined by the state on the left.\n            # Upwind value for left face of element 'e' is trace from right face of 'e_minus'.\n            u_trace_left_neighbor_right = (R @ u_e_minus)[1]\n            # Interior value for left face of element 'e'.\n            u_trace_self_left = (R @ u_e)[0]\n\n            # The flux difference term: f* - a*R*u\n            flux_diff = np.zeros(2)\n            # At left face (r=-1): a*u_minus - a*u_plus = a * (jump)\n            flux_diff[0] = a * (u_trace_left_neighbor_right - u_trace_self_left)\n            # At right face (r=+1): a*u_minus - a*u_plus = a*u_self - a*u_self = 0\n            flux_diff[1] = 0.0\n            \n            # Strong form residual calculation\n            vol_term = (a / J) * (D @ u_e)\n            surf_term = (1.0 / J) * (M_inv @ R.T @ B @ flux_diff)\n            u_dot_global[e, :] = vol_term + surf_term\n            \n        # Compute global mass rate\n        global_mass_rate = 0.0\n        for e in range(Ne):\n            global_mass_rate += J * np.sum(weights * u_dot_global[e, :])\n        cons_err = np.abs(global_mass_rate)\n        \n        case_results.extend([mismatch_norm, cons_err])\n        \n    # Reorder to match GLL_mismatch, GL_mismatch, GLL_cons_err, GL_cons_err\n    return [case_results[0], case_results[2], case_results[1], case_results[3]]\n\ndef solve():\n    # Define test cases: (p, Ne, a, initial_condition_function)\n    test_cases = [\n        # Case 1: General case\n        (4, 4, 1.0, lambda x: np.sin(2 * np.pi * x)),\n        # Case 2: Single element, polynomial IC\n        (5, 1, 1.0, lambda x: eval_legendre(5, 2 * x - 1)),\n        # Case 3: Under-resolved wave\n        (2, 3, 1.0, lambda x: np.sin(10 * np.pi * x))\n    ]\n\n    final_results = []\n    for p, Ne, a, ic_func in test_cases:\n        # returns [GLL_mismatch, GL_mismatch, GLL_cons_err, GL_cons_err]\n        case_results = run_case(p, Ne, a, ic_func)\n        final_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Practical utility depends on computational efficiency, especially for high-order methods with polynomial degree $p$ in $d$ dimensions. This exercise transitions from numerical analysis to computational science, guiding you to construct an efficient volume operator using the sum-factorization technique for tensor-product elements.\n\nYou will then apply a roofline performance model to analyze the trade-offs between peak performance $F$ and memory bandwidth $B$ . This analysis helps in understanding the computational bottlenecks of a DG code and predicting its performance on modern hardware architectures.",
            "id": "3377759",
            "problem": "Consider a scalar advection problem in the Discontinuous Galerkin (DG) method, posed on the reference hypercube $\\Omega = [-1,1]^d$. Let $\\boldsymbol{a} \\in \\mathbb{R}^d$ be a constant advection velocity. Use tensor-product polynomial bases $P_p$ with nodal points given by Legendre-Gauss-Lobatto nodes in one dimension and tensorization to $d$ dimensions. The nodal count per axis is $n = p+1$, and the total degrees of freedom per element is $n^d$.\n\nStarting from the standard strong-form volume contribution of advection, which is the divergence of the flux $f(u) = \\boldsymbol{a}\\,u$, the volume residual at the nodal points reduces to evaluating $\\boldsymbol{a}\\cdot\\nabla u$ in the reference coordinates. Construct a matrix-free tensor-product operator for the volume residual using sum-factorization. Specifically:\n\n- Build the one-dimensional Lagrange interpolation differentiation matrix $D \\in \\mathbb{R}^{n \\times n}$ at the $n$ Legendre-Gauss-Lobatto nodes $\\{x_i\\}_{i=0}^{p}$ by first finding the nodes (endpoints at $-1$ and $1$ and the $p-1$ interior roots of $P_p'(x)$) and then forming the differentiation matrix via barycentric weights. For distinct nodes $\\{x_i\\}$ with barycentric weights $\\{w_i\\}$, define $D_{ij} = \\dfrac{w_j}{w_i (x_i - x_j)}$ for $i \\neq j$ and $D_{ii} = -\\sum_{j\\neq i} D_{ij}$.\n- Use sum-factorization to evaluate $\\nabla u$ by successive one-dimensional contractions of $D$ along each axis. For each axis $k \\in \\{1,\\dots,d\\}$, apply $D$ along axis $k$ to the tensor $u \\in \\mathbb{R}^{n\\times \\cdots \\times n}$ to obtain the component $\\partial_{\\xi_k} u$ at the nodal points, and then combine the components to form the volume residual $r_{\\text{vol}} = \\boldsymbol{a}\\cdot\\nabla u$.\n- Model the arithmetic work and memory traffic per element using first-principles counts under the following assumptions:\n  1. Each matrix-vector contraction along one axis costs $2 n^2$ floating-point operations (flops) per line (counting one multiply and one add per entry), and there are $n^{d-1}$ such lines per axis. Evaluating all gradient components therefore costs $2 d n^{d+1}$ flops.\n  2. Forming $\\boldsymbol{a}\\cdot\\nabla u$ at all nodes costs an additional $d n^d$ multiplications and $(d-1) n^d$ additions, for a total of $2 d n^d$ flops.\n  3. Reading the input field $u$ and writing the output residual $r_{\\text{vol}}$ dominates memory traffic, giving $16 n^d$ bytes per element for the volume kernel.\n  4. For face residual evaluation with a constant $\\boldsymbol{a}$ and an upwind numerical flux on axis-aligned faces, assume a per-node cost of $c_{\\text{flux}}$ flops for combining interior and neighboring traces. With $2d$ faces per element and $n^{d-1}$ nodes per face, the face flops are $2 d n^{d-1} c_{\\text{flux}}$ and the memory traffic per element (read interior and neighbor value, write interior residual) is $2 d n^{d-1} \\cdot 24$ bytes.\n- Use the roofline model to determine the time per element for the volume and face kernels. Let $F$ be the peak floating-point rate in gigaflops per second (GF/s) and $B$ be the peak memory bandwidth in gigabytes per second (GB/s). Convert to flops per second and bytes per second by multiplying by $10^9$. The per-element time estimates are\n$$\nt_{\\text{vol}} = \\max\\left(\\frac{\\text{flops}_{\\text{vol}}}{F \\cdot 10^9}, \\frac{\\text{bytes}_{\\text{vol}}}{B \\cdot 10^9}\\right), \\quad\nt_{\\text{face}} = \\max\\left(\\frac{\\text{flops}_{\\text{face}}}{F \\cdot 10^9}, \\frac{\\text{bytes}_{\\text{face}}}{B \\cdot 10^9}\\right).\n$$\n\nYour program must:\n- Implement the construction of $D$ from first principles and apply the sum-factorized volume operator to a random field $u$ to produce $r_{\\text{vol}}$ for internal validation.\n- Using the model above with $c_{\\text{flux}} = 8$, compute the ratio $\\rho = t_{\\text{face}} / t_{\\text{vol}}$ for each test case. A ratio $\\rho > 1$ means the face residual evaluation dominates the volume integral in time, while $\\rho < 1$ means the volume dominates.\n\nTest Suite:\n- Case $1$: $d=2$, $p=1$, $\\boldsymbol{a} = (1,1)$, $F=100$ GF/s, $B=50$ GB/s.\n- Case $2$: $d=3$, $p=5$, $\\boldsymbol{a} = (1,1,1)$, $F=100$ GF/s, $B=50$ GB/s.\n- Case $3$: $d=3$, $p=5$, $\\boldsymbol{a} = (1,1,1)$, $F=100$ GF/s, $B=10$ GB/s.\n- Case $4$: $d=2$, $p=7$, $\\boldsymbol{a} = (1,1)$, $F=100$ GF/s, $B=200$ GB/s.\n\nFinal Output Format:\nYour program should produce a single line of output containing the four ratios $\\rho$ for the cases $1$ through $4$ as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"). No additional text should be printed.",
            "solution": "The problem requires an analysis of the computational performance of the volume and face integral kernels within a Discontinuous Galerkin (DG) method for a scalar advection problem. The performance is to be evaluated using a simple roofline model, which estimates execution time based on the balance between floating-point operations (flops) and memory traffic (bytes). The primary output is the ratio $\\rho = t_{\\text{face}} / t_{\\text{vol}}$, where $t_{\\text{face}}$ and $t_{\\text{vol}}$ are the estimated times for the face and volume kernels, respectively.\n\nThe problem is posed on a $d$-dimensional reference hypercube $\\Omega = [-1,1]^d$, using a tensor-product basis of degree $p$ polynomials. The nodal points are the tensor-product of $n=p+1$ one-dimensional Legendre-Gauss-Lobatto (LGL) nodes.\n\nThe solution proceeds in two main parts: first, outlining the numerical construction of the volume residual operator, and second, applying the provided performance model to the test cases.\n\n**1. Volume Residual Operator: Sum-Factorization**\n\nThe volume residual for the advection equation $\\nabla \\cdot (\\boldsymbol{a} u) = 0$ with constant velocity $\\boldsymbol{a}$ is $r_{\\text{vol}} = \\boldsymbol{a} \\cdot \\nabla u$. The core task is to compute the gradient $\\nabla u$ of the solution field $u$ at the $n^d$ nodal points of an element. This is achieved efficiently using a technique called sum-factorization.\n\nThe gradient $\\nabla u$ has $d$ components, $\\nabla u = (\\partial_{\\xi_1} u, \\dots, \\partial_{\\xi_d} u)$. Each component $\\partial_{\\xi_k} u$ is computed by differentiating $u$ only along axis $k$. Due to the tensor-product structure of the nodes and basis, this differentiation can be performed as a series of one-dimensional differentiations.\n\nA one-dimensional differentiation is represented by matrix-vector multiplication with the $n \\times n$ differentiation matrix $D$. To construct $D$, we first require the $n=p+1$ LGL nodes $\\{x_i\\}_{i=0}^p$ on $[-1,1]$. These are the endpoints $x_0 = -1$, $x_p = 1$, and the $p-1$ roots of $P_p'(x)$, where $P_p(x)$ is the Legendre polynomial of degree $p$. The roots of $P_p'(x)$ are equivalent to the roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(x)$.\n\nAs per the problem description, the differentiation matrix $D$ is formed using barycentric weights. For a set of distinct nodes $\\{x_i\\}$, the barycentric weights can be defined as $w_j = \\left(\\prod_{k \\neq j} (x_j - x_k)\\right)^{-1}$. The entries of the differentiation matrix are then given by:\n$$\nD_{ij} = \\frac{w_j}{w_i (x_i - x_j)} \\quad \\text{for } i \\neq j\n$$\nThe diagonal entries are determined by the property that the derivative of a constant must be zero, which implies that the rows of $D$ must sum to zero:\n$$\nD_{ii} = -\\sum_{j=0, j \\neq i}^{p} D_{ij}\n$$\nThis construction is numerically equivalent to other standard formulas for a LGL-based differentiation matrix, such as $D_{ij} = \\frac{P_p(x_i)}{P_p(x_j)(x_i-x_j)}$ for $i \\neq j$.\n\nWith the matrix $D$ established, the $k$-th component of the gradient, $\\partial_{\\xi_k} u$, is computed by applying $D$ along the $k$-th axis of the $d$-dimensional tensor $u$ representing the solution values at the nodal points. This operation is a tensor contraction. For each axis $k \\in \\{1,\\dots,d\\}$, we compute a tensor $G_k$ where $(G_k)_{i_1 \\dots i_d} = \\sum_{j=1}^n D_{i_k, j} u_{i_1 \\dots j \\dots i_d}$.\n\nFinally, the volume residual tensor $r_{\\text{vol}}$ is assembled via a dot product with the advection velocity $\\boldsymbol{a}$ at each node:\n$$\nr_{\\text{vol}} = \\sum_{k=1}^d a_k G_k\n$$\n\n**2. Performance Modeling and Ratio Calculation**\n\nThe problem provides a first-principles model for the computational cost of the volume and face kernels.\n\nFor the **volume kernel**:\nThe flop count is the sum of flops for gradient calculation and the dot product:\n$$\n\\text{flops}_{\\text{vol}} = 2 d n^{d+1} + 2 d n^d\n$$\nThe memory traffic is dominated by reading the solution tensor $u$ and writing the residual tensor $r_{\\text{vol}}$, assuming double-precision floating-point numbers (8 bytes/value):\n$$\n\\text{bytes}_{\\text{vol}} = (n^d_{\\text{read}} + n^d_{\\text{write}}) \\times 8 \\frac{\\text{bytes}}{\\text{value}} = 16 n^d \\text{ bytes}\n$$\n\nFor the **face kernel**:\nThe flop count is based on applying a numerical flux calculation at each node on the $2d$ faces of the element:\n$$\n\\text{flops}_{\\text{face}} = (2d \\text{ faces}) \\times (n^{d-1} \\frac{\\text{nodes}}{\\text{face}}) \\times (c_{\\text{flux}} \\frac{\\text{flops}}{\\text{node}}) = 2 d n^{d-1} c_{\\text{flux}}\n$$\nWith $c_{\\text{flux}} = 8$. The memory traffic involves reading the interior and neighbor trace values and writing to the residual accumulator (3 values per node):\n$$\n\\text{bytes}_{\\text{face}} = (2d \\text{ faces}) \\times (n^{d-1} \\frac{\\text{nodes}}{\\text{face}}) \\times (3 \\frac{\\text{values}}{\\text{node}}) \\times (8 \\frac{\\text{bytes}}{\\text{value}}) = 48 d n^{d-1} \\text{ bytes}\n$$\nNote the problem states $2 d n^{d-1} \\cdot 24$, which is equivalent.\n\nThe execution time for each kernel is estimated using a roofline model, where the time is limited by either the machine's peak flop rate $F$ (in GF/s) or its peak memory bandwidth $B$ (in GB/s):\n$$\nt_{\\text{kernel}} = \\max\\left(\\frac{\\text{flops}_{\\text{kernel}}}{F \\cdot 10^9}, \\frac{\\text{bytes}_{\\text{kernel}}}{B \\cdot 10^9}\\right)\n$$\n\nThe final ratio is $\\rho = t_{\\text{face}} / t_{\\text{vol}}$.\n\nLet us demonstrate for Case 1: $d=2$, $p=1$, $F=100$ GF/s, $B=50$ GB/s.\nHere, $n=p+1=2$.\n$\\text{flops}_{\\text{vol}} = 2(2)(2^{2+1}) + 2(2)(2^2) = 4 \\cdot 8 + 4 \\cdot 4 = 32 + 16 = 48$ flops.\n$\\text{bytes}_{\\text{vol}} = 16 \\cdot 2^2 = 64$ bytes.\n$\\text{flops}_{\\text{face}} = 2(2)(2^{2-1})(8) = 4 \\cdot 2 \\cdot 8 = 64$ flops.\n$\\text{bytes}_{\\text{face}} = 48(2)(2^{2-1}) = 96 \\cdot 2 = 192$ bytes.\n\nThe times are:\n$t_{\\text{vol}} = \\max\\left(\\frac{48}{100 \\cdot 10^9}, \\frac{64}{50 \\cdot 10^9}\\right) = \\max(0.48, 1.28) \\cdot 10^{-9} = 1.28 \\cdot 10^{-9}$ s.\n$t_{\\text{face}} = \\max\\left(\\frac{64}{100 \\cdot 10^9}, \\frac{192}{50 \\cdot 10^9}\\right) = \\max(0.64, 3.84) \\cdot 10^{-9} = 3.84 \\cdot 10^{-9}$ s.\n\nThe ratio is $\\rho_1 = \\frac{3.84 \\cdot 10^{-9}}{1.28 \\cdot 10^{-9}} = 3.0$.\n\nThis procedure is repeated for all test cases. The implementation of the numerical operators is included in the final code for completeness as requested, but the final output depends only on the performance model.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\n\ndef get_lgl_diff_matrix(p: int):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes and the corresponding\n    1D differentiation matrix D.\n\n    Args:\n        p: The polynomial degree.\n\n    Returns:\n        A tuple (D, x) where D is the (p+1)x(p+1) differentiation matrix\n        and x is the array of p+1 LGL nodes.\n    \"\"\"\n    n = p + 1\n    if p == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    # Get LGL nodes: endpoints and roots of P_p'(x)\n    if p > 1:\n        # Roots of P_p'(x) are roots of Jacobi polynomial P_{p-1}^{(1,1)}(x)\n        interior_nodes, _ = roots_jacobi(p - 1, 1, 1)\n        x = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    else: # p == 1\n        x = np.array([-1.0, 1.0])\n    \n    # As per the problem, construct D via barycentric weights.\n    # This is numerically equivalent to other standard formulas for LGL D-matrix.\n    # w_j = 1 / product(x_j - x_k) for k!=j\n    w = np.zeros(n)\n    for j in range(n):\n        prod = np.prod(x[j] - x[np.arange(n) != j])\n        w[j] = 1.0 / prod\n\n    D = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (w[j] / w[i]) / (x[i] - x[j])\n\n    for i in range(n):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D, x\n\ndef apply_vol_op(u_tensor: np.ndarray, a_vec: np.ndarray, D: np.ndarray):\n    \"\"\"\n    Applies the sum-factorized volume operator for advection.\n    Computes r_vol = a . grad(u) at the nodal points.\n\n    Args:\n        u_tensor: The solution field, a d-dimensional numpy array of shape (n, n, ...).\n        a_vec: The constant advection velocity vector.\n        D: The 1D differentiation matrix.\n\n    Returns:\n        The volume residual tensor, r_vol.\n    \"\"\"\n    d = u_tensor.ndim\n    n = u_tensor.shape[0]\n    \n    r_vol = np.zeros_like(u_tensor)\n    \n    # Compute gradient components using sum-factorization\n    for k in range(d):\n        # grad_k_component = D applied along axis k of u_tensor\n        # This is done via tensor contraction.\n        # np.tensordot(D, u_tensor, axes=([1], [k])) computes sum_j D[i,j] * u[...,j,...]\n        # where j is in axis k. The result has the new 'i' axis first.\n        grad_k_derivative_axis_first = np.tensordot(D, u_tensor, axes=([1], [k]))\n        # We move the new axis to its correct position k.\n        grad_k_component = np.moveaxis(grad_k_derivative_axis_first, 0, k)\n        \n        r_vol += a_vec[k] * grad_k_component\n        \n    return r_vol\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # d, p, a, F_gflops, B_gbps\n        (2, 1, np.array([1.0, 1.0]), 100.0, 50.0),\n        (3, 5, np.array([1.0, 1.0, 1.0]), 100.0, 50.0),\n        (3, 5, np.array([1.0, 1.0, 1.0]), 100.0, 10.0),\n        (2, 7, np.array([1.0, 1.0]), 100.0, 200.0),\n    ]\n\n    # Internal validation part: as requested, implement and apply the operators\n    # This part's output is not used in the final result, but its implementation is required.\n    p_val, d_val = 3, 2\n    n_val = p_val + 1\n    D_val, _ = get_lgl_diff_matrix(p_val)\n    u_rand = np.random.rand(*([n_val] * d_val))\n    a_val = np.random.rand(d_val)\n    # The following line executes the volume operator for internal validation\n    r_vol_val = apply_vol_op(u_rand, a_val, D_val)\n\n    results = []\n    c_flux = 8.0\n\n    for case in test_cases:\n        d, p, a, F_gflops, B_gbps = case\n        n = p + 1\n\n        F_sec = F_gflops * 1e9\n        B_sec = B_gbps * 1e9\n\n        # Volume kernel costs\n        flops_vol = float(2 * d * n**(d + 1) + 2 * d * n**d)\n        bytes_vol = float(16 * n**d)\n        \n        # Face kernel costs\n        flops_face = float(2 * d * n**(d - 1) * c_flux)\n        bytes_face = float(2 * d * n**(d - 1) * 24)\n\n        # Roofline model time estimates\n        t_vol = max(flops_vol / F_sec, bytes_vol / B_sec)\n        t_face = max(flops_face / F_sec, bytes_face / B_sec)\n\n        # Ratio\n        rho = t_face / t_vol if t_vol > 0 else 0.0\n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}