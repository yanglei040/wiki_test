{
    "hands_on_practices": [
        {
            "introduction": "This first practice serves as a foundational exercise, starting with the fundamental model for transport phenomena: the linear advection equation. The task demonstrates the core workflow of the Method of Manufactured Solutions while simultaneously revealing a critical pitfall in spectral methods known as aliasing. By manufacturing a simple sinusoidal solution, we can precisely predict the grid resolution required to avoid misrepresenting the solution's frequency content, a key step in designing any valid code verification study. ",
            "id": "3397583",
            "problem": "Consider the constant-coefficient linear advection equation $u_t + a\\,u_x = f$ on the periodic interval $x \\in [0,2]$ with period $2$, where $a$ is a real constant advection speed. In the method of manufactured solutions for verification of spectral and Discontinuous Galerkin (DG) discretizations, let the manufactured solution be $u(x,t) = \\cos(3\\pi x)\\,\\sin(t)$. Starting from the governing equation and the definition of the manufactured solution, derive the analytic expression for the forcing term $f(x,t)$ that makes $u(x,t)$ an exact solution. Then, discuss the aliasing implications for spectral collocation on equispaced points under periodic boundaries and outline how these considerations should enter a verification plan for both Fourier spectral collocation and modal polynomial DG discretizations. Your discussion should be rooted in fundamental definitions of aliasing and consistent with the periodic interval $[0,2]$, but it should not produce additional computed numerical outputs beyond the required forcing. Provide the final forcing $f(x,t)$ as a single closed-form analytic expression. No rounding is required for the final expression.",
            "solution": "The problem requires the derivation of a forcing term for a manufactured solution to the linear advection equation, followed by a discussion of the implications for numerical verification using spectral and Discontinuous Galerkin (DG) methods.\n\nThe governing equation is the constant-coefficient linear advection equation:\n$$\nu_t + a u_x = f\n$$\nwhere $u(x,t)$ is the solution variable, $t$ is time, $x$ is the spatial coordinate, $a$ is a constant advection speed, and $f(x,t)$ is a source or forcing term. The spatial domain is specified as the periodic interval $x \\in [0, 2]$.\n\nThe prescribed manufactured solution is:\n$$\nu(x,t) = \\cos(3\\pi x)\\sin(t)\n$$\n\nThe first step is to derive the forcing term $f(x,t)$ that makes this specified $u(x,t)$ an exact solution to the governing partial differential equation (PDE). This is accomplished by computing the partial derivatives of $u(x,t)$ and substituting them into the PDE.\n\nThe partial derivative of $u(x,t)$ with respect to time $t$ is:\n$$\nu_t = \\frac{\\partial}{\\partial t} \\left( \\cos(3\\pi x)\\sin(t) \\right) = \\cos(3\\pi x) \\frac{d}{dt}(\\sin(t)) = \\cos(3\\pi x)\\cos(t)\n$$\n\nThe partial derivative of $u(x,t)$ with respect to space $x$ is:\n$$\nu_x = \\frac{\\partial}{\\partial x} \\left( \\cos(3\\pi x)\\sin(t) \\right) = \\sin(t) \\frac{d}{dx}(\\cos(3\\pi x)) = \\sin(t) \\left( -3\\pi\\sin(3\\pi x) \\right) = -3\\pi\\sin(3\\pi x)\\sin(t)\n$$\n\nSubstituting these derivatives into the advection equation $u_t + a u_x = f$, we can solve for $f(x,t)$:\n$$\nf(x,t) = u_t + a u_x = \\left( \\cos(3\\pi x)\\cos(t) \\right) + a \\left( -3\\pi\\sin(3\\pi x)\\sin(t) \\right)\n$$\nThis simplifies to the final analytical expression for the forcing term:\n$$\nf(x,t) = \\cos(3\\pi x)\\cos(t) - 3a\\pi\\sin(3\\pi x)\\sin(t)\n$$\n\nThe second part of the task is to discuss the aliasing implications for verification using Fourier spectral collocation and modal polynomial DG methods.\n\nFor a Fourier spectral collocation method on the periodic interval $[0, L]$, where here $L=2$, we use a set of $N$ equispaced collocation points $x_j = j \\frac{L}{N}$ for $j=0, 1, \\dots, N-1$. A function can be represented on this grid without aliasing if all of its constituent Fourier modes are within the range of wavenumbers that the grid can resolve. The fundamental wavenumber for the domain $[0,2]$ is $k_{fund} = \\frac{2\\pi}{L} = \\frac{2\\pi}{2} = \\pi$. A general Fourier mode can be written as $\\exp(i m k_{fund} x) = \\exp(i m \\pi x)$ where $m$ is an integer mode number. The manufactured solution's spatial component is $\\cos(3\\pi x)$. Using Euler's formula, this can be written as:\n$$\n\\cos(3\\pi x) = \\frac{1}{2}\\left( \\exp(i3\\pi x) + \\exp(-i3\\pi x) \\right)\n$$\nThis reveals that the solution is composed of Fourier modes with integer mode numbers $m=3$ and $m=-3$.\nAccording to the Nyquist-Shannon sampling theorem for a real-valued signal, to resolve a mode with integer wavenumber $|m|$, the number of grid points $N$ must satisfy $N > 2|m|$. In this case, to resolve the mode $m=3$, we require $N > 2 \\times 3$, i.e., $N > 6$. If $N \\le 6$, aliasing will occur. For example, if we choose $N=4$ points, the mode $m=3$ will be aliased with the mode $m' = m - N = 3 - 4 = -1$. On the grid, the function $\\cos(3\\pi x)$ becomes indistinguishable from $\\cos(\\pi x)$. This corrupts the numerical representation of the solution and its derivatives, and the verification test would show a large error floor, preventing the observation of the expected spectral convergence rate.\nTherefore, a verification plan for a Fourier spectral code using this manufactured solution must ensure that the convergence study begins with a sufficient number of points, e.g., $N=8, 16, 32, \\dots$, to fully resolve the modes in both the solution $u(x,t)$ and the forcing term $f(x,t)$ (which contains the same spatial modes).\n\nFor a modal polynomial Discontinuous Galerkin (DG) method, the domain is partitioned into elements (cells) of size $h$. Within each element, the solution is approximated by a polynomial of degree up to $p$ from a basis set (e.g., Legendre polynomials). The weak formulation of the PDE involves integrals over each element. For the given problem, these integrands contain products of the basis polynomials and the non-polynomial manufactured solution, e.g., $\\int_{\\text{cell}} \\cos(3\\pi x) P_k(x) dx$, where $P_k(x)$ is a basis polynomial. These integrals are computed numerically using a quadrature rule, typically Gaussian quadrature, which is exact for polynomials up to a certain degree. Since the integrand is not a polynomial, any finite-order quadrature rule will introduce a quadrature error.\nIn a verification plan for a DG code, we typically perform an $h$-refinement study (fixing $p$ and decreasing $h$) to confirm the theoretical convergence rate of $O(h^{p+1})$ for the error in a suitable norm (e.g., $L^2$). For this rate to be observed, the error from the numerical quadrature must be smaller than the polynomial approximation error. If the quadrature rule is not accurate enough, the quadrature error will dominate, and the observed convergence rate will be polluted or stalled.\nTherefore, the verification plan for a DG method must specify a quadrature rule of sufficiently high order. A common practice is to use a rule that is exact for polynomials of degree $2p+1$ or higher. This ensures that the approximation of the non-polynomial parts of the manufactured solution is accurate enough to not interfere with the measurement of the convergence rate of the underlying DG polynomial approximation space. The plan must explicitly state this requirement on the quadrature order to ensure a valid verification test.",
            "answer": "$$\n\\boxed{\\cos(3\\pi x)\\cos(t) - 3a\\pi\\sin(3\\pi x)\\sin(t)}\n$$"
        },
        {
            "introduction": "Building upon the concept of aliasing from the previous exercise, this practice explores its more dangerous consequences in the context of nonlinear equations like the viscous Burgers' equation. Here, you will derive a forcing term for a manufactured solution and analyze how the nonlinear convective term, $\\frac{1}{2}(u^2)_x$, can generate spurious high-frequency modes that often lead to catastrophic numerical instability. This exercise illuminates the critical need for advanced techniques, such as 'split-form' discretizations, to ensure the stability and robustness of a high-order scheme when simulating complex, nonlinear physics. ",
            "id": "3397542",
            "problem": "Consider the one-dimensional viscous Burgers equation on the periodic domain $x \\in [0,1]$ and time $t \\ge 0$,\n$$\nu_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} = \\nu\\, u_{xx} + f(x,t),\n$$\nwhere $u(x,t)$ is the unknown solution, $\\nu > 0$ is a given viscosity, and $f(x,t)$ is an unknown forcing term to be determined. In the Method of Manufactured Solutions (MMS), choose the manufactured solution\n$$\nu(x,t) = \\sin\\!\\left(2\\pi x\\right)\\cos t,\n$$\nand impose periodic boundary conditions in $x$. Starting from the governing equation and the definitions of temporal and spatial derivatives, derive a closed-form expression for the forcing term $f(x,t)$ so that $u(x,t)$ is an exact solution for all $t \\ge 0$.\n\nThen, using core concepts from spectral methods and Discontinuous Galerkin (DG) methods, explain why nonlinear fluxes in MMS can suffer from aliasing errors when using polynomial bases and underintegrated quadrature, and why split-form (also called skew-symmetric or entropy-conservative) discretizations are needed to mitigate these errors. Your discussion should be rooted in first principles: how nonlinear products elevate polynomial degree, how the discrete product rule fails under collocation and underintegration, and how split forms restore a discrete analog of conservation or energy stability. You may reference the Summation-By-Parts (SBP) property and the idea of entropy-conservative two-point fluxes for Burgers, but do not assume any specific discretization details beyond standard polynomial approximation and quadrature concepts.\n\nProvide the final forcing term $f(x,t)$ in closed form as a function of $x$, $t$, and $\\nu$. No rounding is required, and no units are associated with the final answer. The final answer must be a single analytic expression.",
            "solution": "The problem is valid as it is scientifically grounded in the fields of fluid dynamics and numerical analysis, well-posed, and objective. It consists of a standard derivation in the Method of Manufactured Solutions (MMS) and a request for a conceptual explanation of established principles in high-order numerical methods.\n\nThe problem requires two distinct tasks: first, to derive the forcing term $f(x,t)$ for a given manufactured solution to the viscous Burgers' equation; second, to explain the nature of aliasing errors for nonlinear terms in polynomial-based numerical methods and the role of split-form discretizations in mitigating them.\n\n**Part 1: Derivation of the Forcing Term $f(x,t)$**\n\nThe governing equation is the one-dimensional viscous Burgers' equation:\n$$u_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} = \\nu\\, u_{xx} + f(x,t)$$\nThe forcing term $f(x,t)$ can be isolated by rearranging the equation:\n$$f(x,t) = u_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} - \\nu\\, u_{xx}$$\nThe prescribed manufactured solution is:\n$$u(x,t) = \\sin(2\\pi x)\\cos t$$\nTo find $f(x,t)$, we must compute the partial derivatives of $u(x,t)$ and substitute them into the expression for $f(x,t)$.\n\nFirst, we compute the temporal derivative, $u_t$:\n$$u_t = \\frac{\\partial}{\\partial t} \\left( \\sin(2\\pi x)\\cos t \\right) = \\sin(2\\pi x) (-\\sin t) = -\\sin(2\\pi x)\\sin t$$\n\nNext, we address the nonlinear convection term, $\\frac{1}{2}(u^2)_x$. This is equivalent to $u u_x$. We first find the spatial derivative, $u_x$:\n$$u_x = \\frac{\\partial}{\\partial x} \\left( \\sin(2\\pi x)\\cos t \\right) = \\cos(2\\pi x) \\cdot 2\\pi \\cdot \\cos t = 2\\pi \\cos(2\\pi x)\\cos t$$\nNow we can form the product $u u_x$:\n$$\\frac{1}{2}(u^2)_x = u u_x = \\left( \\sin(2\\pi x)\\cos t \\right) \\left( 2\\pi \\cos(2\\pi x)\\cos t \\right) = 2\\pi \\sin(2\\pi x)\\cos(2\\pi x)\\cos^2 t$$\nUsing the trigonometric identity $\\sin(2\\theta) = 2\\sin\\theta\\cos\\theta$ with $\\theta = 2\\pi x$, we simplify this term:\n$$\\frac{1}{2}(u^2)_x = \\pi \\left( 2\\sin(2\\pi x)\\cos(2\\pi x) \\right) \\cos^2 t = \\pi \\sin(4\\pi x)\\cos^2 t$$\n\nFinally, we compute the second spatial derivative, $u_{xx}$, for the viscous term. Starting from $u_x$:\n$$u_{xx} = \\frac{\\partial}{\\partial x} u_x = \\frac{\\partial}{\\partial x} \\left( 2\\pi \\cos(2\\pi x)\\cos t \\right) = 2\\pi \\cos t \\left( -\\sin(2\\pi x) \\cdot 2\\pi \\right)$$\n$$u_{xx} = -4\\pi^2 \\sin(2\\pi x)\\cos t$$\n\nNow we substitute all the computed derivatives into the expression for $f(x,t)$:\n$$f(x,t) = u_{t} + \\frac{1}{2}\\left(u^{2}\\right)_{x} - \\nu u_{xx}$$\n$$f(x,t) = \\left( -\\sin(2\\pi x)\\sin t \\right) + \\left( \\pi \\sin(4\\pi x)\\cos^2 t \\right) - \\nu\\left( -4\\pi^2 \\sin(2\\pi x)\\cos t \\right)$$\nCombining the terms gives the final closed-form expression for the forcing term:\n$$f(x,t) = -\\sin(2\\pi x)\\sin t + \\pi \\sin(4\\pi x)\\cos^2 t + 4\\nu\\pi^2 \\sin(2\\pi x)\\cos t$$\n\n**Part 2: Aliasing Errors and Split-Form Discretizations**\n\nThe second part of the problem asks for an explanation of why nonlinear fluxes in MMS can lead to aliasing errors in polynomial-based methods and how split-form discretizations address this issue. This explanation is rooted in the interplay between polynomial approximation, quadrature rules, and the fundamental properties of differential operators.\n\nIn high-order methods such as spectral and Discontinuous Galerkin (DG) methods, the solution $u(x)$ within the domain or an element is approximated by a polynomial $u_N(x)$ of degree at most $N$. This approximation can be written as a sum over basis functions, $u_N(x) = \\sum_{j=0}^{N} \\hat{u}_j \\phi_j(x)$, where $\\phi_j$ are polynomials of degree $j$.\n\nThe nonlinearity in the Burgers' equation is the convective flux term $F(u)=\\frac{1}{2}u^2$. When we substitute the polynomial approximation $u_N(x)$, we obtain $F(u_N) = \\frac{1}{2}u_N^2(x)$. The product of two polynomials of degree $N$ is a polynomial of degree $2N$. Thus, the discrete flux $F(u_N)$ is a polynomial of degree $2N$, which lies outside the original approximation space of polynomials of degree up to $N$.\n\nNumerical methods typically evaluate integrals or enforce the differential equation at a set of discrete points, known as quadrature or collocation points. For instance, a DG method's weak form involves integrals like $\\int_K \\nabla v_N \\cdot F(u_N) dx$, which are computed using a quadrature rule. A common choice is a Gauss quadrature rule with $Q$ points, which is exact for polynomials of degree up to $2Q-1$. In many practical implementations, particularly those aiming for computational efficiency (a concept known as \"underintegration\"), a quadrature rule that is insufficient to exactly integrate the nonlinear term is used. For example, if a rule exact only up to degree $2N-1$ is used (e.g., Gauss-Lobatto with $N+1$ points), it cannot exactly represent the polynomial $u_N^2$ which is of degree $2N$.\n\nThis inability to exactly represent the high-degree polynomial $u_N^2$ leads to **aliasing**. The energy that should be in the polynomial modes of degree $N+1$ to $2N$ is incorrectly projected, or \"aliased,\" onto the lower-degree modes from $0$ to $N$ that the numerical scheme can represent. In a collocation method, the problem is that we represent the derivative of the nonlinear term, $(u_N^2)_x$, which has degree $2N-1$, using its values at the $N+1$ collocation points. This forces a representation of a high-degree polynomial by a lower-degree one, again causing aliasing.\n\nThis phenomenon is a direct consequence of the **failure of the discrete product rule**. Continuously, the chain rule states $(u^2)_x = 2 u u_x$. Discretely, if $D$ is a differentiation matrix and pointwise multiplication is used, it is generally not true that $D(u_N \\circ u_N) = 2 u_N \\circ (D u_N)$, where $\\circ$ denotes the element-wise product of vectors of function values at grid points. The aliasing error is precisely the difference between these two expressions.\n\nThe consequence of aliasing is often catastrophic: it can lead to a spurious, non-physical transfer of energy to high-frequency modes, culminating in **nonlinear instability**. At the continuous level, for the inviscid Burgers' equation, the convective term $\\frac{1}{2}(u^2)_x$ conserves the kinetic energy $\\int u^2 dx$ over a periodic domain. This is because $\\int u \\cdot \\frac{1}{2}(u^2)_x dx = \\int \\frac{1}{3}(u^3)_x dx = 0$. Aliasing breaks this conservation property at the discrete level, allowing the discrete energy to grow without bound.\n\n**Split-form discretizations** are designed to remedy this instability. The idea is to rewrite the nonlinear term in a mathematically equivalent form which possesses superior stability properties upon discretization. For Burgers' equation, the standard 'conservation' form $\\frac{1}{2}(u^2)_x$ can be rewritten in a family of 'split forms': $\\alpha(u^2)_x + (1-\\alpha)uu_x$. A particularly important version is the skew-symmetric form $\\frac{1}{3}(u^2)_x + \\frac{2}{3}uu_x$.\n\nThe key insight is that even with aliasing, such forms can be constructed to be discretely conservative or dissipative with respect to a chosen norm (like the L2-norm, corresponding to energy or entropy). This is strongly connected to the **Summation-By-Parts (SBP)** property. An SBP operator is a discrete derivative operator that mimics the integration-by-parts property. When a skew-symmetric formulation is combined with an SBP operator, the resulting discrete convective term becomes skew-symmetric as a matrix operator, i.e., $(v, \\text{Conv}(u)) = -(\\text{Conv}(v), u)$ where $(\\cdot,\\cdot)$ is the discrete inner product. This implies that $(u, \\text{Conv}(u)) = 0$, meaning the discrete energy is exactly conserved, and nonlinear stability is restored, even in the presence of aliasing from underintegration.\n\nFrom another perspective, these stable split forms often correspond to discretizations built from **entropy-conservative two-point fluxes**. For a scalar conservation law, a numerical flux is entropy-conservative if it discretely conserves a chosen entropy function. For Burgers' equation, the natural entropy is $u^2/2$. The split form given above can be derived from such a principle. By enforcing a fundamental conservation property at the discrete level, these forms prevent the unphysical energy growth that plagues standard formulations, thereby ensuring the stability and robustness of the numerical simulation.\n\nThis approach is crucial for MMS because if the numerical scheme is nonlinearly unstable, the errors due to this instability will dominate, making it impossible to observe the expected convergence rates and correctly verify the code's implementation. Using a stable split-form discretization ensures that the observed errors are due to truncation error, as intended by the MMS procedure.",
            "answer": "$$\n\\boxed{-\\sin(2\\pi x)\\sin t + \\pi \\sin(4\\pi x)\\cos^2 t + 4\\nu\\pi^2 \\sin(2\\pi x)\\cos t}\n$$"
        },
        {
            "introduction": "This final practice transitions from theoretical analysis to a concrete coding implementation for the steady inviscid Burgers' equation, a canonical conservation law. You are tasked with building a small nodal Discontinuous Galerkin (DG) solver to observe firsthand how the choice of numerical flux at element interfaces dictates the behavior and stability of the scheme. By implementing and comparing central, Lax-Friedrichs, and Roe fluxes, you will directly compute the numerical entropy dissipation, connecting the theoretical need for stable formulations to a tangible, measurable diagnostic in your own code. ",
            "id": "3397617",
            "problem": "Consider the one-dimensional steady conservation law associated with inviscid Burgers dynamics on a periodic domain. Let the physical domain be $x \\in [0, 2\\pi]$ with periodic boundary conditions, and let the conservative partial differential equation be\n$$\n\\frac{d}{dx}\\left(\\frac{u(x)^2}{2}\\right) = s(x).\n$$\nUsing the Method of Manufactured Solutions (MMS), suppose the exact manufactured solution is $u(x) = \\sin(x)$ (arguments in radians). From fundamental definitions, the flux for inviscid Burgers is $f(u) = \\frac{u^2}{2}$. The source term $s(x)$ must be chosen so that the exact solution satisfies the steady equation. Your task is to implement a nodal Discontinuous Galerkin (DG) discretization using Legendre–Gauss collocation points on each element to evaluate:\n- a discrete steady residual at the nodes when the exact solution is inserted into the DG operator, and\n- an interface-based entropy dissipation diagnostic that depends on the numerical flux choice.\n\nThe derivation must start from the conservation law and the DG weak form on the reference element. Use the following foundational base:\n- Conservation of a scalar quantity in one dimension: $\\frac{d}{dx} f(u) = s(x)$.\n- Mapping from a reference element $\\xi \\in [-1,1]$ to a physical element $x \\in [x_L, x_R]$ via an affine map with Jacobian $J = \\frac{\\Delta x}{2}$, where $\\Delta x = \\frac{2\\pi}{K}$ for $K$ uniform elements.\n- Nodal Lagrange basis functions $\\{\\ell_i(\\xi)\\}_{i=1}^{N_p}$ at Legendre–Gauss nodes $\\{\\xi_i, w_i\\}_{i=1}^{N_p}$, with $N_p = N+1$ for polynomial degree $N$, and the standard collocation discretization of integrals by quadrature.\n- Numerical fluxes at interfaces that are two-point, consistent fluxes depending only on left and right states.\n\nDiscretization details to implement algorithmically:\n- Partition $[0, 2\\pi]$ into $K$ uniform elements, and on each element use $N_p = N+1$ Legendre–Gauss points $\\{\\xi_i, w_i\\}$ and associated Lagrange basis functions.\n- Let $x(\\xi) = x_L + J(\\xi + 1)$, where $J = \\frac{\\Delta x}{2}$ and $\\Delta x = \\frac{2\\pi}{K}$ is the element size. The metric factor is constant on each element.\n- Define $f(u) = \\frac{u^2}{2}$. Using the weak form and integration by parts on the reference element, the strong-form nodal DG collocation discretization for the steady residual at node $i$ in element $e$ is\n$$\nR_i^{(e)} = \\frac{1}{J w_i}\\left(2\\,\\ell_i(1)\\,\\widehat{f}^{(e)}_{\\text{right}} - 2\\,\\ell_i(-1)\\,\\widehat{f}^{(e)}_{\\text{left}} - 2\\sum_{j=1}^{N_p} D_{j i}\\,w_j\\,f\\left(u_j^{(e)}\\right)\\right) - s\\left(x_i^{(e)}\\right),\n$$\nwhere $D_{ji} = \\ell_i'(\\xi_j)$ is the nodal derivative matrix, $u_j^{(e)} = \\sin(x_j^{(e)})$, $x_j^{(e)} = x(\\xi_j)$, and the interface numerical fluxes $\\widehat{f}^{(e)}_{\\text{left}}$ and $\\widehat{f}^{(e)}_{\\text{right}}$ are computed using extrapolated interface values from the neighboring elements via the basis traces $\\{\\ell_i(\\pm 1)\\}_{i=1}^{N_p}$. The source term $s(x)$ must be obtained from the manufactured solution and inserted in physical units (radians for trigonometric evaluations).\n- Use periodic boundary conditions, so the left neighbor of element $0$ is element $K-1$, and the right neighbor of element $K-1$ is element $0$.\n- Define three numerical fluxes at interfaces in terms of left and right boundary extrapolated states $u_L$ and $u_R$:\n    - Central flux (conservative, zero dissipation): \n      $$\n      \\widehat{f}_{\\text{cen}}(u_L,u_R) = \\frac{1}{2}\\left(f(u_L)+f(u_R)\\right).\n      $$\n    - Local Lax–Friedrichs flux (dissipative): \n      $$\n      \\widehat{f}_{\\text{llf}}(u_L,u_R) = \\frac{1}{2}\\left(f(u_L)+f(u_R)\\right) - \\frac{1}{2}\\,\\alpha_{\\text{llf}}(u_R-u_L), \\quad \\alpha_{\\text{llf}} = \\max\\{|u_L|, |u_R|\\}.\n      $$\n    - Roe flux for Burgers (dissipative): \n      $$\n      \\widehat{f}_{\\text{roe}}(u_L,u_R) = \\frac{1}{2}\\left(f(u_L)+f(u_R)\\right) - \\frac{1}{2}\\,\\alpha_{\\text{roe}}(u_R-u_L), \\quad \\alpha_{\\text{roe}} = \\left|\\frac{u_L + u_R}{2}\\right|.\n      $$\n- As an entropy diagnostic, consider the quadratic entropy $\\eta(u)=\\frac{u^2}{2}$ with entropy variable $v(u)=u$. For the above two-point fluxes, a face-local discrete entropy dissipation can be monitored by\n$$\n\\mathcal{D}_{\\text{face}} = \\frac{1}{2}\\,\\alpha\\,(u_R - u_L)^2,\n$$\nwith $\\alpha$ the dissipation coefficient associated with the chosen numerical flux ($\\alpha_{\\text{llf}}$ or $\\alpha_{\\text{roe}}$; for the central flux, $\\alpha=0$). Aggregate the total entropy dissipation over the mesh by summing $\\mathcal{D}_{\\text{face}}$ over all unique interfaces.\n\nYour program must:\n- Compute the exact source term $s(x)$ implied by the manufactured solution $u(x)=\\sin(x)$.\n- Implement the nodal DG collocation strong form with Legendre–Gauss nodes and periodic interfaces to compute the steady residual vector for the exact solution on each element and assemble the global discrete $L^2$ norm of the residual:\n$$\n\\|R\\|_{L^2} = \\left(\\sum_{e=1}^{K} \\sum_{i=1}^{N_p} J\\,w_i \\left(R_i^{(e)}\\right)^2\\right)^{1/2}.\n$$\n- Compute the total interface entropy dissipation \n$$\n\\mathcal{D}_{\\text{total}} = \\sum_{\\text{interfaces}} \\frac{1}{2}\\,\\alpha\\,(u_R - u_L)^2,\n$$\nusing the same states and $\\alpha$ as in the numerical flux.\n- Explore the dependence on numerical flux choice by evaluating both $\\|R\\|_{L^2}$ and $\\mathcal{D}_{\\text{total}}$ for a small test suite.\n\nAngle unit requirement: all trigonometric function arguments are in radians.\n\nTest suite:\n- Case $1$: $N=3$, $K=8$, flux $=$ central.\n- Case $2$: $N=3$, $K=8$, flux $=$ local Lax–Friedrichs.\n- Case $3$: $N=3$, $K=8$, flux $=$ Roe.\n- Case $4$: $N=1$, $K=2$, flux $=$ local Lax–Friedrichs.\n- Case $5$: $N=5$, $K=16$, flux $=$ local Lax–Friedrichs.\n\nFinal output specification:\n- Your program should produce a single line of output containing a list of results for the above cases, in order. Each result is a pair $[\\|R\\|_{L^2}, \\mathcal{D}_{\\text{total}}]$ with each float rounded to $8$ decimal places.\n- The exact required format is a single line:\n$$\n[\\,[r_1,d_1],[r_2,d_2],[r_3,d_3],[r_4,d_4],[r_5,d_5]\\,]\n$$\nwith no extra spaces beyond those shown not being required; commas must separate entries. The numbers $r_i$ and $d_i$ must be plain decimal or scientific notation floats rounded to $8$ decimal places.",
            "solution": "The solution to this problem involves implementing a nodal Discontinuous Galerkin (DG) framework for a one-dimensional steady conservation law. We will compute two diagnostic quantities—the $L^2$ norm of a specially defined discrete residual and the total entropy dissipation—for a manufactured solution.\n\n**1. Preliminaries: Manufactured Solution and Source Term**\nThe governing equation is the steady inviscid Burgers' equation, a conservation law of the form $\\frac{d}{dx}f(u) = s(x)$, where the flux is $f(u) = \\frac{u^2}{2}$.\nThe problem provides a manufactured solution $u(x) = \\sin(x)$. To satisfy the governing equation exactly, the source term $s(x)$ must be equal to the derivative of the flux evaluated with the exact solution:\n$$\ns(x) = \\frac{d}{dx}f(u(x)) = \\frac{d}{dx}\\left(\\frac{\\sin^2(x)}{2}\\right) = \\frac{1}{2} \\cdot 2\\sin(x)\\cos(x) = \\sin(x)\\cos(x).\n$$\nThis function will be used in the residual calculation.\n\n**2. Nodal Discontinuous Galerkin Framework**\nThe domain $[0, 2\\pi]$ is divided into $K$ elements. On each element, the solution is approximated by a polynomial of degree $N$. The nodal DG method uses a basis of Lagrange polynomials $\\{\\ell_i(\\xi)\\}_{i=1}^{N_p}$ constructed on a set of $N_p = N+1$ nodes $\\{\\xi_i\\}_{i=1}^{N_p}$ in the reference element $[-1,1]$. For this problem, these nodes are the Legendre–Gauss quadrature points.\n\nThe core components to be implemented are:\n- **Basis Functions and Geometry:** For a given polynomial degree $N$, we need to find the $N_p$ Legendre-Gauss nodes $\\xi_i$ and weights $w_i$. We also need to evaluate the Lagrange basis functions $\\ell_i$ and their derivatives $\\ell_i'$ at various points, specifically at the element boundaries $\\xi = \\pm 1$ and at the nodes $\\xi_j$. These values are used to construct the derivative matrix and to extrapolate the solution to element interfaces.\n- **Physical Coordinates:** For each element $e$, the reference nodes $\\xi_i$ are mapped to physical coordinates $x_i^{(e)}$ using the affine mapping $x(\\xi) = x_L + J(\\xi + 1)$, where $x_L$ is the left boundary of the element and $J=\\frac{\\pi}{K}$ is the constant Jacobian.\n- **Nodal Values:** The DG solution is represented by its values at the nodes. In this MMS test, the nodal values $u_j^{(e)}$ are set to the exact solution evaluated at the physical node locations: $u_j^{(e)} = \\sin(x_j^{(e)})$.\n\n**3. Residual Calculation**\nThe problem defines a specific formula for the steady residual at each node $i$ in an element $e$:\n$$\nR_i^{(e)} = \\frac{1}{J w_i}\\left(2\\,\\ell_i(1)\\,\\widehat{f}^{(e)}_{\\text{right}} - 2\\,\\ell_i(-1)\\,\\widehat{f}^{(e)}_{\\text{left}} - 2\\sum_{j=1}^{N_p} D_{j i}\\,w_j\\,f\\left(u_j^{(e)}\\right)\\right) - s\\left(x_i^{(e)}\\right)\n$$\nThis involves three main parts:\n- **Surface (Interface) Term:** The terms with $\\widehat{f}^{(e)}_{\\text{left}}$ and $\\widehat{f}^{(e)}_{\\text{right}}$ represent the contribution from fluxes at the element boundaries. The numerical fluxes $\\widehat{f}$ depend on the states $u_L$ and $u_R$ on the left and right sides of the interface. These states are found by extrapolating the polynomial solution from the corresponding elements to the interface. For an interface between element $e-1$ and $e$, a jump $[u] = u_R - u_L$ exists, where $u_L$ is the value from element $e-1$'s polynomial at its right boundary, and $u_R$ is the value from element $e$'s polynomial at its left boundary.\n- **Volume (Integral) Term:** The summation term approximates the integral of the flux derivative within the element. The matrix $D_{ji} = \\ell_i'(\\xi_j)$ is the (transposed) nodal derivative matrix.\n- **Source Term:** The exact source term $s(x_i^{(e)})$ is subtracted.\n\nThe global $L^2$ norm of this residual, $\\|R\\|_{L^2}$, is then computed by summing the squared residuals over all nodes and elements, weighted by the quadrature weights $J w_i$.\n\n**4. Entropy Dissipation Diagnostic**\nThe total entropy dissipation $\\mathcal{D}_{\\text{total}}$ is a measure of the dissipation introduced by the numerical flux at the interfaces. It is calculated by summing the face-local dissipation $\\mathcal{D}_{\\text{face}}$ over all unique interfaces in the mesh:\n$$\n\\mathcal{D}_{\\text{total}} = \\sum_{\\text{interfaces}} \\mathcal{D}_{\\text{face}} = \\sum_{\\text{interfaces}} \\frac{1}{2}\\,\\alpha\\,(u_R - u_L)^2.\n$$\nThe dissipation coefficient $\\alpha$ is determined by the choice of numerical flux ($\\alpha=0$ for the central flux, and non-zero for LLF and Roe fluxes). As the manufactured solution is smooth, the jump $[u] = u_R - u_L$ arises solely from the fact that the polynomial interpolants on adjacent elements do not perfectly match at their common boundary. For dissipative fluxes, this non-zero jump will result in non-zero entropy dissipation.\n\n**5. Algorithm Implementation**\nThe overall algorithm proceeds as follows for each test case:\n1.  Set parameters $N$ and $K$.\n2.  Generate the required DG basis data for degree $N$: nodes $\\xi_i$, weights $w_i$, derivative matrix $D_{ji}$, and boundary extrapolated basis values $\\ell_i(\\pm 1)$.\n3.  Construct the grid of physical nodes for all $K$ elements.\n4.  Evaluate the exact solution $u(x)=\\sin(x)$ at all physical nodes to obtain the nodal coefficients for the DG approximation.\n5.  Iterate through each element $e=0, \\dots, K-1$:\n    a. Determine the nodal values for the current element and its periodic neighbors.\n    b. Compute the extrapolated states $u_L$ and $u_R$ at the left and right interfaces of element $e$.\n    c. Based on the chosen flux type, calculate the numerical fluxes $\\widehat{f}^{(e)}_{\\text{left}}$ and $\\widehat{f}^{(e)}_{\\text{right}}$ and the dissipation coefficient $\\alpha$ at the right interface.\n    d. Accumulate the entropy dissipation from the right-hand interface. Due to periodicity, this covers all interfaces exactly once.\n    e. Assemble the nodal residual vector $R^{(e)}$ using the given formula.\n    f. Accumulate the weighted sum of squared residuals.\n6.  Compute the final $L^2$ norm of the residual and the total entropy dissipation.\nThe code implementing this logic will be provided in the final answer.",
            "answer": "```python\nimport numpy as np\n\n# Cache for DG basis data to avoid recomputation\n_DG_CACHE = {}\n\ndef get_dg_basis_data(N):\n    \"\"\"\n    Computes and caches nodal DG basis data for a given polynomial degree N.\n    This includes Legendre-Gauss nodes and weights, the derivative matrix,\n    and basis function values at the element boundaries.\n    \"\"\"\n    if N in _DG_CACHE:\n        return _DG_CACHE[N]\n\n    Np = N + 1\n    # Use numpy's utility to get Legendre-Gauss nodes and weights\n    xi, w = np.polynomial.legendre.leggauss(Np)\n\n    # Helper functions for Lagrange polynomials and their derivatives\n    def lagrange_poly(nodes, j, x):\n        \"\"\"Evaluates the j-th Lagrange polynomial defined by 'nodes' at point 'x'.\"\"\"\n        val = 1.0\n        for k, node_k in enumerate(nodes):\n            if k != j:\n                val *= (x - node_k) / (nodes[j] - node_k)\n        return val\n\n    def lagrange_deriv(nodes, j, x):\n        \"\"\"Evaluates the derivative of the j-th Lagrange polynomial.\"\"\"\n        sum_val = 0.0\n        for m, node_m in enumerate(nodes):\n            if m != j:\n                prod_val = 1.0 / (nodes[j] - node_m)\n                for k, node_k in enumerate(nodes):\n                    if k != j and k != m:\n                        prod_val *= (x - node_k) / (nodes[j] - node_k)\n                sum_val += prod_val\n        return sum_val\n\n    # The problem defines D_ji = l_i'(xi_j). This matrix will be D_prob.\n    # D_prob[j, i] = l_i'(xi_j)\n    D_prob = np.zeros((Np, Np))\n    for i in range(Np):\n        for j in range(Np):\n            D_prob[j, i] = lagrange_deriv(xi, i, xi[j])\n\n    # Basis function values at reference element boundaries xi = -1 and xi = 1\n    l_minus1 = np.array([lagrange_poly(xi, i, -1.0) for i in range(Np)])\n    l_plus1 = np.array([lagrange_poly(xi, i, 1.0) for i in range(Np)])\n\n    result = (xi, w, D_prob, l_minus1, l_plus1)\n    _DG_CACHE[N] = result\n    return result\n\ndef compute_diag(N, K, flux_type):\n    \"\"\"\n    Computes the L2 norm of the steady residual and total entropy dissipation.\n    \"\"\"\n    # 1. Setup Grid and Basis\n    Np = N + 1\n    xi, w, D_prob, l_minus1, l_plus1 = get_dg_basis_data(N)\n    \n    delta_x = 2.0 * np.pi / K\n    J = delta_x / 2.0\n\n    # 2. Manufactured Solution and Source Term\n    # Create a grid of physical node locations for all K elements\n    x_nodes = np.zeros((K, Np))\n    for e in range(K):\n        x_L = e * delta_x\n        x_nodes[e, :] = x_L + J * (xi + 1.0)\n    \n    u_vals = np.sin(x_nodes)\n    f_vals = 0.5 * u_vals**2\n    s_vals = np.sin(x_nodes) * np.cos(x_nodes)\n\n    # 3. Define Numerical Fluxes\n    def get_flux(u_L, u_R, flux_choice):\n        f_L = 0.5 * u_L**2\n        f_R = 0.5 * u_R**2\n        \n        if flux_choice == 'central':\n            alpha = 0.0\n            flux = 0.5 * (f_L + f_R)\n        elif flux_choice == 'llf':\n            alpha = np.maximum(np.abs(u_L), np.abs(u_R))\n            flux = 0.5 * (f_L + f_R) - 0.5 * alpha * (u_R - u_L)\n        elif flux_choice == 'roe':\n            alpha = np.abs(0.5 * (u_L + u_R))\n            flux = 0.5 * (f_L + f_R) - 0.5 * alpha * (u_R - u_L)\n        else:\n            raise ValueError(\"Unknown flux type\")\n        return flux, alpha\n\n    # 4. Loop over elements to compute residuals and dissipation\n    total_residual_sq_sum = 0.0\n    total_dissipation = 0.0\n\n    for e in range(K):\n        # Apply periodic boundary conditions for neighbors\n        e_left = (e - 1 + K) % K\n        e_right = (e + 1) % K\n        \n        u_curr = u_vals[e, :]\n        u_left_neighbor = u_vals[e_left, :]\n        u_right_neighbor = u_vals[e_right, :]\n        \n        # Interface fluxes\n        u_L_at_left_face = np.dot(u_left_neighbor, l_plus1)\n        u_R_at_left_face = np.dot(u_curr, l_minus1)\n        fhat_left, _ = get_flux(u_L_at_left_face, u_R_at_left_face, flux_type)\n        \n        u_L_at_right_face = np.dot(u_curr, l_plus1)\n        u_R_at_right_face = np.dot(u_right_neighbor, l_plus1)\n        fhat_right, alpha_right = get_flux(u_L_at_right_face, u_R_at_right_face, flux_type)\n        \n        total_dissipation += 0.5 * alpha_right * (u_R_at_right_face - u_L_at_right_face)**2\n        \n        f_nodes_curr = f_vals[e, :]\n        \n        # Volume term: sum_j( D_ji * w_j * f_j ) for each i.\n        # This corresponds to D_prob.T @ (w * f_nodes)\n        vol_term = D_prob.T @ (w * f_nodes_curr)\n        \n        surf_term = 2.0 * l_plus1 * fhat_right - 2.0 * l_minus1 * fhat_left\n\n        R_e = (1.0 / (J * w)) * (surf_term - 2.0 * vol_term) - s_vals[e, :]\n        \n        total_residual_sq_sum += J * np.sum(w * R_e**2)\n\n    l2_residual = np.sqrt(total_residual_sq_sum)\n    return l2_residual, total_dissipation\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        (3, 8, 'central'),\n        (3, 8, 'llf'),\n        (3, 8, 'roe'),\n        (1, 2, 'llf'),\n        (5, 16, 'llf'),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, K, flux_type = case\n        res, diss = compute_diag(N, K, flux_type)\n        results.append((res, diss))\n\n    formatted_parts = [f\"[{r:.8e},{d:.8e}]\" for r, d in results]\n    final_output = f\"[{','.join(formatted_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}