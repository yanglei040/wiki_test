{
    "hands_on_practices": [
        {
            "introduction": "任何有限元方法的核心都在于单元矩阵的构建，即质量矩阵和刚度矩阵。本练习将指导您在参考单元上，针对两种常用的基函数——模态基（正交勒让德多项式）和节点基（拉格朗日多项式），推导这些基本矩阵。通过此过程，您将深入理解基函数的选择如何影响矩阵的结构（特别是质量矩阵的对角性），以及如何将这些在标准参考单元上计算的矩阵通过仿射变换映射到任意物理单元上 。",
            "id": "3378044",
            "problem": "考虑一维参考单元 $I = [-1,1]$ 和总次数最多为 $k \\in \\mathbb{N}$ 的多项式空间 $V_h^k = \\mathbb{P}^k(I)$。我们将比较 $V_h^k$ 的两种单元多项式基：由标准正交 Legendre 多项式定义的模态基，以及由通过求积节点的 Lagrange 多项式定义的节点基。背景是热方程和 Poisson 方程的间断 Galerkin (DG) 离散化，其中主要的局部双线性形式涉及单元质量矩阵和单元刚度矩阵。工作在单个单元上进行，不包括界面通量贡献。\n\n从以下基本定义、性质和构造开始：\n- 经典 Legendre 多项式 $\\{P_n(r)\\}_{n=0}^\\infty$ 在 $[-1,1]$上满足 $\\int_{-1}^{1} P_n(r) P_m(r)\\,dr = \\frac{2}{2n+1}\\,\\delta_{nm}$。\n- 标准正交 Legendre 基定义为 $\\phi_n(r) = \\sqrt{\\frac{2n+1}{2}}\\,P_n(r)$，因此对于 $0 \\le n,m \\le k$ 有 $\\int_{-1}^{1} \\phi_n(r)\\,\\phi_m(r)\\,dr = \\delta_{nm}$。\n- 给定 $N_p = k+1$ 个不同的节点 $\\{\\xi_i\\}_{i=1}^{N_p} \\subset [-1,1]$，节点 Lagrange 基 $\\{\\ell_i(r)\\}_{i=1}^{N_p}$ 由 $\\ell_i(\\xi_j) = \\delta_{ij}$ 定义，并张成 $\\mathbb{P}^k(I)$。\n- 对于 Gauss–Legendre (GL) 节点，存在正权重 $\\{w_i\\}_{i=1}^{N_p}$，使得对于所有次数最高为 $2N_p-1$ 的多项式 $f$，$\\sum_{i=1}^{N_p} w_i\\,f(\\xi_i) = \\int_{-1}^{1} f(r)\\,dr$ 精确成立。\n- 对于 Gauss–Lobatto–Legendre (GLL) 节点，存在正权重 $\\{w_i\\}_{i=1}^{N_p}$，使得对于所有次数最高为 $2N_p-3$ 的多项式 $f$，$\\sum_{i=1}^{N_p} w_i\\,f(\\xi_i) = \\int_{-1}^{1} f(r)\\,dr$ 精确成立。\n- 在从参考单元到物理单元 $K = [x_L,x_R]$ 的仿射映射下，$x(r) = x_c + \\frac{h}{2}\\,r$，其中 $x_c = \\frac{x_L+x_R}{2}$ 且 $h = x_R - x_L$，雅可比行列式为 $J = \\frac{dx}{dr} = \\frac{h}{2}$，导数变换为 $\\frac{d}{dx} = \\frac{2}{h}\\frac{d}{dr}$。\n\n任务：\n1. 仅使用上述定义和 Legendre 多项式的正交性，在模态基 $\\{\\phi_n\\}_{n=0}^{k}$ 中推导参考单元 $I$ 上的单元质量矩阵和单元刚度矩阵，其中质量内积为 $\\int_{-1}^{1} (\\cdot)\\,(\\cdot)\\,dr$，刚度内积为 $\\int_{-1}^{1} \\frac{d}{dr}(\\cdot)\\,\\frac{d}{dr}(\\cdot)\\,dr$。说明每个矩阵是否为对角矩阵，并从第一性原理出发证明你的答案。\n2. 在节点基 $\\{\\ell_i\\}_{i=1}^{N_p}$ 中对两种节点选择重复推导：Gauss–Legendre 和 Gauss–Lobatto–Legendre。使用相应求积规则的精确性来推断，在对被积函数足够精确的求积下，单元质量矩阵何时为对角矩阵。用求积点计算矩阵和权重表示质量矩阵和刚度矩阵，并解释每种情况下精确性的作用。\n3. 通过上面指定的仿射映射将您的表达式映射到物理单元 $K$，并推导将参考单元矩阵与物理单元矩阵联系起来的显式缩放因子，这些因子适用于与热方程和 Poisson 方程相关的质量和刚度双线性形式。\n\n最后，用一个封闭形式的解析表达式回答以下明确问题。在一个长度为 $h$ 的物理单元上，使用 Gauss–Legendre 节点的节点 Lagrange 基和精确的 Gauss–Legendre 求积，单元质量矩阵的每个对角线元素 $M_{ii}$ 的表达式是什么？你的最终答案必须是单个解析表达式，且不得包含任何单位。无需四舍五入。",
            "solution": "该问题被评估为有效，因为它在科学上基于偏微分方程数值方法的理论，其定义和目标清晰一致，问题表述良好，并且没有任何主观或模棱两可的语言。我们可以开始解答。\n\n解答分为三部分，对应问题陈述中列出的三个任务，最后是最终答案的推导。\n\n**1. 模态基中的分析**\n\n模态基由参考单元 $I = [-1, 1]$ 上的一组标准正交 Legendre 多项式 $\\{\\phi_n(r)\\}_{n=0}^{k}$ 给出。该基的定义性质是其关于 $L^2$ 内积的标准正交性：\n$$\n\\int_{-1}^{1} \\phi_n(r) \\phi_m(r) \\,dr = \\delta_{nm}\n$$\n其中 $\\delta_{nm}$ 是 Kronecker delta。基函数的索引从 $n=0$ 到 $k$。\n\n参考单元上的单元质量矩阵，记为 $M^I$，其元素为 $M_{nm}$，其中 $0 \\le n,m \\le k$。其元素由基函数的内积定义：\n$$\nM_{nm} = \\int_{-1}^{1} \\phi_n(r) \\phi_m(r) \\,dr\n$$\n通过直接应用基的标准正交性，我们得到：\n$$\nM_{nm} = \\delta_{nm}\n$$\n这意味着在标准正交模态基中，质量矩阵是单位矩阵，$M^I = I$。根据定义，单位矩阵是对角矩阵。\n\n参考单元上的单元刚度矩阵，记为 $S^I$，其元素 $S_{nm}$ 由基函数导数的内积定义：\n$$\nS_{nm} = \\int_{-1}^{1} \\frac{d\\phi_n}{dr}(r) \\frac{d\\phi_m}{dr}(r) \\,dr\n$$\n为确定该矩阵是否为对角矩阵，我们检查其非对角元素，其中 $n \\ne m$。基函数 $\\phi_n(r)$ 是一个 $n$ 次多项式，其导数 $\\frac{d\\phi_n}{dr}$ 是一个 $n-1$ 次多项式。Legendre 多项式 $P_n(r)$ 的奇偶性为 $(-1)^n$。由于 $\\phi_n(r)$ 是 $P_n(r)$ 的标量倍，它具有相同的奇偶性。具有给定奇偶性的函数的导数具有相反的奇偶性。因此，$\\frac{d\\phi_n}{dr}$ 的奇偶性为 $(-1)^{n-1}$。被积函数是乘积 $\\frac{d\\phi_n}{dr} \\frac{d\\phi_m}{dr}$，其奇偶性为 $(-1)^{n-1}(-1)^{m-1} = (-1)^{n+m-2}$。如果 $n$ 和 $m$ 的奇偶性不同（一个偶数，一个奇数），那么 $n+m$ 是奇数，$n+m-2$ 也是奇数，被积函数是一个奇函数。奇函数在对称区间 $[-1, 1]$ 上的积分为零。因此，如果 $n$ 和 $m$ 的奇偶性不同，则 $S_{nm} = 0$。\n\n然而，这并不能保证矩阵是对角矩阵。考虑一个非对角元素，其中 $n$ 和 $m$ 具有相同的奇偶性（例如 $n=2, m=0$ 或 $n=3, m=1$）。对于 $n=0$，$\\phi_0(r)$ 是一个常数，所以 $\\frac{d\\phi_0}{dr} = 0$。这意味着对于所有的 $n, m$，都有 $S_{0m} = S_{n0} = 0$。对于 $n,m > 0$ 且奇偶性相同、$n \\ne m$ 的情况，被积函数是一个非零偶函数，其积分通常不为零。例如，对于 $k \\ge 3$，元素 $S_{13}$ 通常不为零。因此，刚度矩阵 $S^I$ 不是对角矩阵。\n\n**2. 节点基中的分析**\n\n节点基由次数为 $k=N_p-1$ 的 Lagrange 多项式 $\\{\\ell_i(r)\\}_{i=1}^{N_p}$ 给出，它由在一组 $N_p$ 个不同节点 $\\{\\xi_j\\}_{j=1}^{N_p}$ 上满足条件 $\\ell_i(\\xi_j) = \\delta_{ij}$ 来定义。\n\n单元质量矩阵的元素为 $M_{ij} = \\int_{-1}^{1} \\ell_i(r) \\ell_j(r) \\,dr$。被积函数 $\\ell_i(r) \\ell_j(r)$ 是一个次数最多为 $k+k = 2k = 2(N_p-1) = 2N_p - 2$ 的多项式。我们使用具有节点 $\\{\\xi_p\\}_{p=1}^{N_p}$ 和权重 $\\{w_p\\}_{p=1}^{N_p}$ 的求积规则来近似这个积分：\n$$\nM_{ij} \\approx \\sum_{p=1}^{N_p} w_p \\ell_i(\\xi_p) \\ell_j(\\xi_p) = \\sum_{p=1}^{N_p} w_p \\delta_{ip} \\delta_{jp}\n$$\n仅当 $p=i$ 且 $p=j$ 时，该和才非零，这要求 $i=j$。于是得到：\n$$\nM_{ij} \\approx w_i \\delta_{ij}\n$$\n这种称为质量集中的近似方法总是产生一个对角矩阵。问题是这种结果何时是精确的。\n\n- **Gauss–Legendre (GL) 节点：** 相应的求积规则对于次数最高为 $2N_p-1$ 的多项式是精确的。由于被积函数的次数是 $2N_p-2$，小于或等于 $2N_p-1$，因此求积是精确的。因此，对于在 GL 节点上构建的节点基，单元质量矩阵是精确对角的：$M_{ij} = w_i \\delta_{ij}$，其中 $\\{w_i\\}$ 是 GL 求积权重。\n\n- **Gauss–Lobatto–Legendre (GLL) 节点：** 相应的求积规则对于次数最高为 $2N_p-3$ 的多项式是精确的。被积函数的次数是 $2N_p-2$。由于 $2N_p-2 > 2N_p-3$，求积规则对于非对角项通常不是精确的。因此，对于在 GLL 节点上构建的节点基，精确的质量矩阵不是对角的。集中质量矩阵 $M_{ij} = w_i \\delta_{ij}$（其中 $\\{w_i\\}$ 是 GLL 权重）是一个近似值。\n\n单元刚度矩阵的元素是 $S_{ij} = \\int_{-1}^{1} \\frac{d\\ell_i}{dr}(r) \\frac{d\\ell_j}{dr}(r) \\,dr$。被积函数 $\\frac{d\\ell_i}{dr} \\frac{d\\ell_j}{dr}$ 是一个次数最多为 $(k-1) + (k-1) = 2k-2 = 2N_p-4$ 的多项式。\n\n- **GL 求积：** 精确度高达 $2N_p-1$ 次。由于 $2N_p-4 \\le 2N_p-1$，求积是精确的。\n- **GLL 求积：** 精确度高达 $2N_p-3$ 次。由于 $2N_p-4 \\le 2N_p-3$，求积也是精确的。\n\n在这两种情况下，刚度矩阵都可以使用相应的求积规则精确计算：\n$$\nS_{ij} = \\sum_{p=1}^{N_p} w_p \\frac{d\\ell_i}{dr}(\\xi_p) \\frac{d\\ell_j}{dr}(\\xi_p)\n$$\n设 $D$ 是微分矩阵，其元素为 $D_{pi} = \\frac{d\\ell_i}{dr}(\\xi_p)$，$W$ 是权重对角矩阵，其元素为 $W_{pp} = w_p$。刚度矩阵可以写成 $S^I = D^T W D$。通常情况下，对于 $i \\ne p$，元素 $\\frac{d\\ell_i}{dr}(\\xi_p)$ 不为零。因此，微分矩阵 $D$ 不是对角矩阵，所以对于这两种节点选择，刚度矩阵 $S^I$ 都不是对角矩阵。\n\n**3. 映射到物理单元**\n\n设 $K=[x_L, x_R]$ 是一个长度为 $h=x_R-x_L$ 的物理单元。从参考单元 $I=[-1,1]$ 的仿射映射为 $x(r) = x_c + \\frac{h}{2}r$，其中 $x_c = \\frac{x_L+x_R}{2}$。该变换的雅可比行列式为 $J = \\frac{dx}{dr} = \\frac{h}{2}$。关于 $x$ 的导数与关于 $r$ 的导数通过 $\\frac{d}{dx} = \\frac{dr}{dx} \\frac{d}{dr} = (\\frac{h}{2})^{-1} \\frac{d}{dr} = \\frac{2}{h} \\frac{d}{dr}$ 相关联。\n\n设 $\\chi_i(r)$ 是参考单元上的基函数，$\\psi_i(x)$ 是物理单元上相应的基函数，使得 $\\psi_i(x(r)) = \\chi_i(r)$。\n\n物理单元质量矩阵 $M^K$ 的元素为：\n$$\nM_{ij}^K = \\int_{K} \\psi_i(x) \\psi_j(x) \\,dx\n$$\n将变量更改为参考坐标 $r$：\n$$\nM_{ij}^K = \\int_{-1}^{1} \\psi_i(x(r)) \\psi_j(x(r)) \\frac{dx}{dr} \\,dr = \\int_{-1}^{1} \\chi_i(r) \\chi_j(r) \\left(\\frac{h}{2}\\right) \\,dr = \\frac{h}{2} \\int_{-1}^{1} \\chi_i(r) \\chi_j(r) \\,dr\n$$\n这给出了关系 $M_{ij}^K = \\frac{h}{2} M_{ij}^I$。质量矩阵的缩放因子是 $\\frac{h}{2}$。\n\n物理单元刚度矩阵 $S^K$ 的元素为：\n$$\nS_{ij}^K = \\int_{K} \\frac{d\\psi_i}{dx}(x) \\frac{d\\psi_j}{dx}(x) \\,dx\n$$\n变量变换：\n$$\nS_{ij}^K = \\int_{-1}^{1} \\left(\\frac{2}{h} \\frac{d\\chi_i}{dr}(r)\\right) \\left(\\frac{2}{h} \\frac{d\\chi_j}{dr}(r)\\right) \\left(\\frac{h}{2}\\right) \\,dr = \\frac{4}{h^2} \\frac{h}{2} \\int_{-1}^{1} \\frac{d\\chi_i}{dr}(r) \\frac{d\\chi_j}{dr}(r) \\,dr\n$$\n这给出了关系 $S_{ij}^K = \\frac{2}{h} S_{ij}^I$。刚度矩阵的缩放因子是 $\\frac{2}{h}$。\n\n**最终答案推导**\n\n问题要求在一个长度为 $h$ 的物理单元上，使用 Gauss–Legendre 节点的节点 Lagrange 基和精确的 Gauss–Legendre 求积，给出单元质量矩阵对角元素 $M_{ii}$ 的表达式。\n\n从第 2 部分中，我们确定了对于 GL 节点上的 Lagrange 基，参考单元质量矩阵 $M^I$ 是对角的，其元素为 $M_{ij}^I = w_i \\delta_{ij}$。因此，对角元素为 $M_{ii}^I = w_i$，其中 $w_i$ 是第 $i$ 个 GL 求积权重。\n\n从第 3 部分中，我们发现物理单元质量矩阵 $M^K$ 通过缩放因子 $\\frac{h}{2}$ 与参考矩阵相关。因此，$M_{ij}^K = \\frac{h}{2} M_{ij}^I$。\n\n结合这些结果，物理质量矩阵的对角元素为：\n$$\nM_{ii}^K = \\frac{h}{2} M_{ii}^I = \\frac{h}{2} w_i\n$$\n这是每个对角元素所需的单一封闭形式解析表达式，其中 $w_i$ 表示与第 $i$ 个 Gauss-Legendre 节点相对应的第 $i$ 个求积权重。",
            "answer": "$$\\boxed{\\frac{h w_i}{2}}$$"
        },
        {
            "introduction": "在实践中，我们通常使用数值积分（求积）来计算单元矩阵的各项。求积规则的精度对离散系统的准确性至关重要，不恰当的求积会导致所谓的“混叠误差”。本练习将探讨精确组装刚度矩阵所需的最小求积精度 。您将推导出一个关键的实用准则，确保在不引入不必要积分误差的情况下，高效地计算刚度项。",
            "id": "3378064",
            "problem": "考虑在一个从参考区间 $[-1,1]$ 映射而来的单个一维仿射单元上，具有恒定扩散系数的稳态热（Poisson）方程。使用 Discontinuous Galerkin (DG) 方法和 Symmetric Interior Penalty Galerkin (SIPG) 格式，关注单元体积刚度双线性形式 $a_{E}(u,v) = \\int_{E} \\kappa \\,\\partial_{x} u \\,\\partial_{x} v \\,\\mathrm{d}x$，其中 $\\kappa$ 是常数，且从参考单元的映射是仿射的，因此雅可比因子是常数。设局部试探和检验空间为参考单元上次数最多为 $p$ 的多项式，并考虑模态单项式基 $\\{\\phi_{k}(x)\\}_{k=0}^{p}$，其中 $\\phi_{k}(x) = x^{k}$。因此，对于 $k \\geq 1$ 有 $\\partial_{x}\\phi_{k}(x) = k\\,x^{k-1}$，且 $\\partial_{x}\\phi_{0}(x) = 0$。\n\n为 $i,j \\in \\{0,1,\\dots,p\\}$ 定义精确单元刚度矩阵项 $K_{ij} = \\int_{-1}^{1} \\partial_{x}\\phi_{i}(x)\\,\\partial_{x}\\phi_{j}(x)\\,\\mathrm{d}x$。对于数值积分，在 $[-1,1]$ 上使用对次数最高为 $D$（求积精度阶数）的多项式精确的 Gauss-Legendre 求积，因此计算出的项为 $K_{ij}^{(D)} = \\sum_{\\ell=1}^{Q} w_{\\ell}\\,\\partial_{x}\\phi_{i}(x_{\\ell})\\,\\partial_{x}\\phi_{j}(x_{\\ell})$，其中 $\\{(x_{\\ell},w_{\\ell})\\}_{\\ell=1}^{Q}$ 是求積节点和权重，且 $D = 2Q - 1$。\n\n为了量化积分不足对扩散算子组装的影响，定义混叠计数\n$$A(D,p) = \\#\\left\\{(i,j)\\in\\{1,\\dots,p\\}^{2} \\,\\middle|\\, i+j-2 > D \\text{ and } i+j-2 \\text{ is even}\\right\\},$$\n该计数统计了其精确被积多项式的次数为严格大于 $D$ 的偶数（因此在 $[-1,1]$ 上的精确积分为非零值）且不会被该求积方法精确积分的刚度矩阵项的数量。\n\n从以上定义和 Gauss-Legendre 求积对其精度阶数 $D$ 以内的所有多项式都能精确积分这一基本性质出发，推导用 $p$ 和 $D$ 表示的 $A(D,p)$，然后确定最小求积精度阶数 $D_{\\min}$，使得对于所有满足 $1 \\leq i,j \\leq p$ 的数对 $(i,j)$ 都有 $A(D,p) = 0$。将 $D_{\\min}$ 的最终答案表示为关于 $p$ 的闭式解析表达式。无需四舍五入，也无需单位。",
            "solution": "该问题要求使得混叠计数 $A(D,p)$ 为零的最小求积精度阶数 $D_{\\min}$。分析从单元刚度矩阵项和数值积分方案的性质开始。\n\n在参考单元 $[-1,1]$ 上的单元刚度矩阵项由下式给出\n$$ K_{ij} = \\int_{-1}^{1} \\partial_{x}\\phi_{i}(x)\\,\\partial_{x}\\phi_{j}(x)\\,\\mathrm{d}x $$\n其中 $i,j \\in \\{0, 1, \\dots, p\\}$。基函数是单项式 $\\phi_k(x) = x^k$。它们的导数对于 $k \\ge 1$ 是 $\\partial_x \\phi_k(x) = kx^{k-1}$，且 $\\partial_x \\phi_0(x) = 0$。\n\n如果 $i=0$ 或 $j=0$，相应的导数为零，导致 $K_{ij}=0$。无论求积规则如何，这些项都能被精确计算。问题正确地聚焦于索引 $i,j \\in \\{1, \\dots, p\\}$，对于这些索引，导数是非零的。对于这些索引，被积函数为：\n$$ \\mathcal{I}_{ij}(x) = \\partial_{x}\\phi_{i}(x)\\,\\partial_{x}\\phi_{j}(x) = (ix^{i-1})(jx^{j-1}) = ijx^{i+j-2} $$\n该被积函数 $\\mathcal{I}_{ij}(x)$ 是一个关于 $x$ 的多项式，其次数为 $\\deg(\\mathcal{I}_{ij}) = i+j-2$。\n\n数值积分使用 Gauss-Legendre 求积规则进行，该规则对所有次数不超过 $D$ 的多项式都是精确的。这意味着如果被积函数的次数小于或等于 $D$，那么计算得到的刚度项 $K_{ij}^{(D)}$ 等于精确项 $K_{ij}$：\n$$ K_{ij}^{(D)} = K_{ij} \\quad \\text{if} \\quad i+j-2 \\le D $$\n如果 $i+j-2 > D$，则不保证求积规则能产生精确积分，可能会出现混叠误差。\n\n混叠计数 $A(D,p)$ 被定义为量化易受此误差影响的项的数量。其定义为：\n$$ A(D,p) = \\#\\left\\{(i,j)\\in\\{1,\\dots,p\\}^{2} \\,\\middle|\\, i+j-2 > D \\text{ and } i+j-2 \\text{ is even}\\right\\} $$\n这个定义包含了使数对 $(i,j)$ 对计数产生贡献的两个条件：\n1.  $i+j-2 > D$：被积多项式的次数超过了求积的精度阶数。这是产生潜在数值不准确性的条件。\n2.  $i+j-2$ 是偶数：精确积分 $\\int_{-1}^{1} ijx^{i+j-2} \\mathrm{d}x$ 非零，因为 $x$ 的奇次幂在对称区间 $[-1,1]$ 上的积分为零。只有当被积函数的值不为零时，积分误差才有意义。\n\n目标是找到最小的精度阶数 $D_{\\min}$，使得 $A(D,p) = 0$。要使 $A(D,p)$ 为零，满足这两个条件的数对 $(i,j)$ 集合必须为空集。\n$$ \\left\\{(i,j)\\in\\{1,\\dots,p\\}^{2} \\,\\middle|\\, i+j-2 > D \\text{ and } i+j-2 \\text{ is even}\\right\\} = \\emptyset $$\n确保此集合为空的一个充分方法是，确保第一个条件 $i+j-2 > D$ 对于指定范围内的任何数对 $(i,j)$ 都不成立。如果这个不等式永不成立，那么它与任何其他条件的合取也永不成立。\n\n因此，我们寻求一个 $D$ 值，使得对于所有的 $i,j \\in \\{1, 2, \\dots, p\\}$，以下不等式成立：\n$$ i+j-2 \\le D $$\n为了对所有可能的数对 $(i,j)$ 满足此条件，$D$ 必须大于或等于表达式 $i+j-2$ 的最大可能值。\n$$ D \\ge \\max_{i,j \\in \\{1,\\dots,p\\}} (i+j-2) $$\n表达式 $i+j-2$ 的最大值出现在 $i$ 和 $j$ 都取其最大可能值时。在集合 $\\{1, 2, \\dots, p\\}$ 中，$i$ 和 $j$ 的最大值都是 $p$。\n将 $i=p$ 和 $j=p$ 代入表达式，得到我们必须积分的任何被积多项式的最高次数：\n$$ \\max_{i,j \\in \\{1,\\dots,p\\}} (i+j-2) = p+p-2 = 2p-2 $$\n因此，为确保所有被积多项式 $\\mathcal{I}_{ij}(x)$ 的次数都小于或等于 $D$，我们必须有：\n$$ D \\ge 2p-2 $$\n满足此条件的最小整数 $D$ 值为 $D_{\\min} = 2p-2$。\n\n如果我们选择 $D = 2p-2$，那么对于任何 $(i,j) \\in \\{1,\\dots,p\\}^2$，我们有 $i+j-2 \\le p+p-2 = 2p-2 = D$。这意味着条件 $i+j-2 > D$ 永远不会被满足，因此 $A(2p-2, p) = 0$。\n\n为了确认这是最小值，考虑 $D = 2p-3$。对于此选择，我们考察数对 $(i,j) = (p,p)$。被积函数的次数是 $p+p-2 = 2p-2$。条件 $i+j-2 > D$ 变为 $2p-2 > 2p-3$，这是成立的。第二个条件，$i+j-2$ 是偶数，也成立，因为对于任何整数 $p \\ge 1$，$2p-2 = 2(p-1)$ 永远是偶数。因此，对于 $D=2p-3$，数对 $(p,p)$ 对混叠计数有贡献，所以 $A(2p-3, p) \\ge 1$。这证实了 $D = 2p-2$ 是所需的最小精度阶数。",
            "answer": "$$\\boxed{2p-2}$$"
        },
        {
            "introduction": "掌握了单元矩阵的构建和精确积分后，我们便可以将这些构建模块组装起来，解决一个完整的边值问题。本练习要求您为一个带有纯诺伊曼边界条件的泊松方程实现一个完整的间断 Galerkin 求解器，这是一个在物理和工程中常见但具有挑战性的问题，因为其解的唯一性需要施加额外约束。您将通过编程实践，比较两种经典的约束施加方法——拉格朗日乘子法和罚方法，并从数值精度和系统条件数两个角度评估它们的性能 。",
            "id": "3378015",
            "problem": "实现一维对称内部罚分片伽辽金(DG)方法，用于求解带有纯诺伊曼边界条件的泊松方程，并以两种不同的方式施加零均值约束。比较这两种方法的条件数和准确性。\n\n设域为 $[0,1]$，考虑边值问题\n$$\n- u''(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u'(0) = 0, \\quad u'(1) = 0,\n$$\n其精确解指定为 $u^\\star(x) = \\cos(2\\pi x)$。这意味着源项为 $f(x) = 4\\pi^2 \\cos(2\\pi x)$，并且边界数据满足诺伊曼问题的相容性条件。数值解 $u_h$ 的确定有一个常数差，然后通过施加全局零均值约束 $\\int_0^1 u_h \\, dx = 0$ 来唯一地确定它。\n\n从泊松方程的弱形式定义和分部积分出发，在具有 $E$ 个单元和每个单元上次数为 $p$ 的多项式基的均匀网格上，使用对称内部罚分片伽辽金公式。在每个单元上使用基于勒让德-高斯-洛巴托点的节点基，并在内部界面上采用标准的对称内部罚结构，罚项缩放与 $((p+1)^2)/h$ 成正比，其中 $h$ 是单元大小。使用固定的罚项缩放系数 $\\alpha$，因此每个内部面上的罚项为 $\\sigma = \\alpha \\, \\frac{(p+1)^2}{h}$。在边界上，以自然方式引入诺伊曼数据，不添加额外的罚项或一致性项。您必须实现以下两种全局零均值约束策略：\n\n1) 拉格朗日乘子：用一个标量拉格朗日乘子 $\\lambda$ 来增广线性系统，以精确地强制执行 $\\int_0^1 u_h \\, dx = 0$。这将产生一个大小为 $N+1$ 的方形鞍点系统，其中 $N$ 是 DG 离散化的未知数数量。\n\n2) 均值罚项：向双线性形式中添加一个秩为一的罚项 $\\tau \\left(\\int_0^1 u_h \\, dx\\right)\\left(\\int_0^1 v_h \\, dx\\right)$，其中 $\\tau > 0$ 是用户指定的参数。当 $\\tau \\to \\infty$ 时，该项近似地强制执行零均值约束。\n\n在这两种方法中，按规定组装 DG 刚度算子、对应于源项 $f(x)$ 的载荷向量以及约束。然后，对于下面的每个测试用例：\n\n- 使用直接线性代数法求解离散系统。\n- 计算 $u_h$ 相对于 $u^\\star$ 的相对分片 $L^2$ 误差，定义为\n$$\n\\frac{\\left\\|u_h - u^\\star\\right\\|_{L^2(0,1)}}{\\left\\|u^\\star\\right\\|_{L^2(0,1)}},\n$$\n其中 $L^2$ 范数通过与局部节点基一致的单元积分来计算。\n- 计算您求解的线性系统的矩阵 $2$-范数条件数：\n  - 对于拉格朗日乘子方法，计算增广鞍点矩阵的 $2$-范数条件数。\n  - 对于罚函数方法，计算带罚项的刚度矩阵的 $2$-范数条件数。\n\n在您的实现中使用以下固定选项：\n- 罚项缩放系数为 $\\alpha = 10$。\n- 体积分必须使用勒让德-高斯-洛巴托节点基和相应的单元积分。\n- 内部面上的界面罚项必须按 $\\sigma = \\alpha \\, \\frac{(p+1)^2}{h}$ 进行缩放。\n\n测试套件：\n实现您的程序，以精确运行以下四组参数集，每组由三元组 $(E,p,\\tau)$ 指定：\n- 案例 1：$(E,p,\\tau) = (8,3,10^4)$\n- 案例 2：$(E,p,\\tau) = (8,3,10^2)$\n- 案例 3：$(E,p,\\tau) = (4,2,10^4)$\n- 案例 4：$(E,p,\\tau) = (16,3,10^6)$\n\n对于每个案例，按此精确顺序计算并报告以下四个量：\n- 拉格朗日乘子方法的相对 $L^2$ 误差，\n- 拉格朗日乘子系统的 $2$-范数条件数，\n- 给定 $\\tau$ 的均值罚方法的相对 $L^2$ 误差，\n- 带罚项的刚度矩阵的 $2$-范数条件数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由 16 个浮点数组成的逗号分隔列表，这些浮点数采用科学记数法，恰好有六位有效数字，并用方括号括起来。浮点数必须按上面列出的四个案例排序。例如，输出格式必须是\n$[r_1,\\kappa_1,\\tilde r_1,\\tilde \\kappa_1,r_2,\\kappa_2,\\tilde r_2,\\tilde \\kappa_2,r_3,\\kappa_3,\\tilde r_3,\\tilde \\kappa_3,r_4,\\kappa_4,\\tilde r_4,\\tilde \\kappa_4]$,\n其中 $r_i$ 和 $\\kappa_i$ 对应于案例 $i$ 的拉格朗日乘子方法，$\\tilde r_i$ 和 $\\tilde \\kappa_i$ 对应于案例 $i$ 的均值罚方法。此问题不涉及物理单位，也不使用角度。",
            "solution": "用户希望使用对称内部罚分片伽辽金 (DG) 方法求解具有纯诺伊曼边界条件的一维泊松问题。问题表述为：\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u'(0) = 0, \\quad u'(1) = 0.\n$$\n精确解指定为 $u^\\star(x) = \\cos(2\\pi x)$，这意味着源项为 $f(x) = 4\\pi^2 \\cos(2\\pi x)$。精确解满足边界条件，源项满足相容性条件 $\\int_0^1 f(x) \\, dx = 0$。由于纯诺伊曼问题的解仅在相差一个常数的情况下是唯一的，我们对数值解 $u_h$ 施加附加约束 $\\int_0^1 u_h(x) \\, dx = 0$。\n\n将实现并比较两种施加此约束的方法：\n1.  **拉格朗日乘子**：增广线性系统以精确地施加约束。\n2.  **罚函数法**：通过向双线性形式添加一个罚项来近似地施加约束。\n\n### 分片伽辽金公式\n\n我们将域 $\\Omega = [0,1]$ 划分为 $E$ 个大小为 $h = 1/E$ 的均匀单元 $K_e$。DG 有限元空间 $V_h$ 由在每个单元 $K_e$ 上次数最高为 $p$ 的多项式函数组成。我们采用由每个单元上的 $p+1$ 个勒让德-高斯-洛巴托 (LGL) 点定义的节点基。\n\n弱形式是通过将偏微分方程乘以测试函数 $v_h \\in V_h$，在每个单元上积分，并应用分部积分得到的：\n$$\n\\sum_{e=1}^E \\int_{K_e} u'_h v'_h \\, dx - \\sum_{e=1}^E \\left[ u'_h v_h \\right]_{\\partial K_e} = \\int_\\Omega f v_h \\, dx.\n$$\n边界项被分解为来自内部面 $\\mathcal{F}_I$ 和边界面 $\\mathcal{F}_B$ 的贡献。对于对称内部罚伽辽金 (SIPG) 方法，我们定义一个双线性形式 $a_h(u_h, v_h)$ 和一个线性泛函 $l_h(v_h)$。\n\nSIPG 方法的双线性形式为：\n$$\na_h(u_h, v_h) = \\sum_{e=1}^E \\int_{K_e} u'_h v'_h \\, dx - \\sum_{j \\in \\mathcal{F}_I} \\left( \\langle\\{ u'_h \\}\\rangle [v_h] + \\langle\\{ v'_h \\}\\rangle [u_h] \\right) + \\sum_{j \\in \\mathcal{F}_I} \\sigma_j [u_h] [v_h].\n$$\n此处，对于位于单元 $K_L$ 和 $K_R$ 之间内部面上的函数 $w$，平均值为 $\\langle\\{ w \\}\\rangle = (w_L + w_R)/2$，跳跃值为 $[w] = w_L - w_R$。每个内部面上的罚参数由 $\\sigma = \\alpha \\frac{(p+1)^2}{h}$ 给出，其中 $\\alpha=10$。\n\n线性泛函 $l_h(v_h)$ 包含了源项和边界条件。来自分部积分的边界项是 $u'_h(1)v_h(1) - u'_h(0)v_h(0)$。为了自然地施加诺伊曼条件，我们将 $u'_h$ 替换为给定数据，$x=0$ 处为 $g_0=0$，$x=1$ 处为 $g_1=0$。\n$$\nl_h(v_h) = \\int_\\Omega f v_h \\, dx + g_1 v_h(1) - g_0 v_h(0) = \\int_\\Omega f v_h \\, dx.\n$$\n问题是找到 $u_h \\in V_h$ 使得对于所有 $v_h \\in V_h$ 都有 $a_h(u_h, v_h) = l_h(v_h)$。这导出一个线性系统 $A \\mathbf{u} = \\mathbf{f}$。矩阵 $A$ 是奇异的，其零空间由常数函数组成。\n\n### 零均值约束的施加\n\n将约束 $\\int_0^1 u_h \\, dx=0$ 写成矩阵形式 $C \\mathbf{u} = 0$，其中 $C$ 是一个行向量，其元素是基函数的积分。\n\n1.  **拉格朗日乘子法**：我们引入一个拉格朗日乘子 $\\lambda$ 并求解增广鞍点系统：\n    $$\n    \\begin{pmatrix} A  C^T \\\\ C  0 \\end{pmatrix}\n    \\begin{pmatrix} \\mathbf{u} \\\\ \\lambda \\end{pmatrix}\n    =\n    \\begin{pmatrix} \\mathbf{f} \\\\ 0 \\end{pmatrix}.\n    $$\n    该系统是方形的，并且在适当条件下是非奇异的。\n\n2.  **罚函数法**：我们向双线性形式添加一个罚项，得到一个修正的刚度矩阵 $A_{\\text{pen}}$：\n    $$\n    a_{\\text{pen}}(u_h, v_h) = a_h(u_h, v_h) + \\tau \\left(\\int_0^1 u_h \\, dx\\right) \\left(\\int_0^1 v_h \\, dx\\right).\n    $$\n    这对应于求解线性系统 $(A + \\tau C^T C) \\mathbf{u} = \\mathbf{f}$。对于足够大的罚参数 $\\tau > 0$，矩阵 $A + \\tau C^T C$ 是非奇异的，并且约束被近似满足。\n\n### 实现步骤\n\n1.  **LGL 基**：实现一个函数来计算 $p+1$ 个 LGL 节点和权重，以及次数为 $p$ 的拉格朗日基多项式的 $(p+1) \\times (p+1)$ 微分矩阵 $D$。\n\n2.  **矩阵组装**：组装全局刚度矩阵 $A$ 和载荷向量 $\\mathbf{f}$。\n    -   体积项 $\\sum_e \\int_{K_e} u'_h v'_h \\, dx$ 填充 $A$ 的块对角线元素。\n    -   通过遍历内部面来组装面对项。对于每个面，计算一个 $2(p+1) \\times 2(p+1)$ 的局部面矩阵，并将其加到全局矩阵中，从而耦合两个相邻单元的自由度。\n    -   使用 LGL 求积法计算 $f v_h$ 的积分来组装载荷向量 $\\mathbf{f}$。\n\n3.  **求解与分析**：\n    -   对于每种方法，使用 `numpy.linalg.solve` 构建并求解相应的线性系统。\n    -   使用 `numpy.linalg.cond` 计算系统矩阵的 $2$-范数条件数。\n    -   使用每个单元上的 LGL 求积法计算相对分片 $L^2$ 误差 $\\|u_h - u^\\star\\|_{L^2} / \\|u^\\star\\|_{L^2}$。\n\n4.  **测试执行**：对四个指定的 $(E, p, \\tau)$ 测试用例中的每一个执行上述步骤。收集计算出的误差和条件数，并为最终输出进行格式化。",
            "answer": "````python\nimport numpy as np\n\ndef get_lgl_nodes_weights_d_matrix(p):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto nodes, weights, and the differentiation matrix.\n\n    Args:\n        p (int): Polynomial degree. The number of nodes will be p + 1.\n\n    Returns:\n        tuple: A tuple containing:\n            - nodes (np.ndarray): The LGL nodes in [-1, 1].\n            - weights (np.ndarray): The LGL quadrature weights.\n            - D (np.ndarray): The (p+1)x(p+1) differentiation matrix.\n    \"\"\"\n    if p == 0:\n        return np.array([0.0]), np.array([2.0]), np.array([[0.0]])\n    \n    if p == 1:\n        nodes = np.array([-1.0, 1.0])\n    else:\n        # Interior nodes are roots of P'_p(x)\n        P_p_poly = np.polynomial.legendre.Legendre.basis(p)\n        P_p_prime_poly = P_p_poly.deriv(1)\n        interior_nodes = P_p_prime_poly.roots()\n        nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n\n    # Weights\n    P_p_poly = np.polynomial.legendre.Legendre.basis(p)\n    Pp_vals = P_p_poly(nodes)\n    weights = 2.0 / (p * (p + 1) * Pp_vals**2)\n\n    # Differentiation Matrix D_{ij} = l'_j(xi_i)\n    D = np.zeros((p + 1, p + 1))\n    for i in range(p + 1):\n        for j in range(p + 1):\n            if i != j:\n                D[i, j] = Pp_vals[i] / (Pp_vals[j] * (nodes[i] - nodes[j]))\n            else:\n                if i == 0:\n                    D[0, 0] = -p * (p + 1) / 4.0\n                elif i == p:\n                    D[p, p] = p * (p + 1) / 4.0\n                else:\n                    D[i, i] = 0.0\n    \n    return nodes, weights, D\n\ndef solve_case(E, p, tau):\n    \"\"\"\n    Solves the DG problem for a single test case (E, p, tau).\n    \"\"\"\n    # 1. Setup\n    ALPHA = 10.0\n    N_dof_per_el = p + 1\n    N_total_dof = E * N_dof_per_el\n    h = 1.0 / E\n    \n    u_exact = lambda x: np.cos(2 * np.pi * x)\n    f_source = lambda x: 4 * np.pi**2 * np.cos(2 * np.pi * x)\n\n    # 2. Reference element calculations\n    nodes_ref, weights_ref, D_ref = get_lgl_nodes_weights_d_matrix(p)\n    M_ref = np.diag(weights_ref)\n    S_ref = D_ref.T @ M_ref @ D_ref\n\n    # 3. Assemble global matrices and vectors\n    A = np.zeros((N_total_dof, N_total_dof))\n    F = np.zeros(N_total_dof)\n\n    # Volume terms and RHS\n    for e in range(E):\n        idx_start, idx_end = e * N_dof_per_el, (e + 1) * N_dof_per_el\n        A[idx_start:idx_end, idx_start:idx_end] = (2.0 / h) * S_ref\n        \n        x_nodes = (e * h) + h * (nodes_ref + 1.0) / 2.0\n        f_vals = f_source(x_nodes)\n        F[idx_start:idx_end] = (h / 2.0) * (weights_ref * f_vals)\n\n    # Face terms\n    sigma = ALPHA * (p + 1)**2 / h\n    D_at_m1 = D_ref[0, :]\n    D_at_p1 = D_ref[p, :]\n\n    for e_left in range(E - 1):\n        e_right = e_left + 1\n        \n        J_u = np.zeros(2 * N_dof_per_el)\n        J_u[p] = 1.0\n        J_u[N_dof_per_el] = -1.0\n        \n        A_u = (1.0/h) * np.concatenate((D_at_p1, D_at_m1))\n\n        M_f = -np.outer(A_u, J_u) - np.outer(J_u, A_u) + sigma * np.outer(J_u, J_u)\n\n        dofs_start = e_left * N_dof_per_el\n        dofs_end = (e_right + 1) * N_dof_per_el\n        A[dofs_start:dofs_end, dofs_start:dofs_end] += M_f\n\n    # 4. Constraint and Solve\n    C = np.tile((h / 2.0) * weights_ref, E)\n\n    # Lagrange Multiplier Method\n    A_aug = np.zeros((N_total_dof + 1, N_total_dof + 1))\n    A_aug[:N_total_dof, :N_total_dof] = A\n    A_aug[N_total_dof, :N_total_dof] = C\n    A_aug[:N_total_dof, N_total_dof] = C\n    F_aug = np.append(F, 0)\n\n    u_h_lagrange = np.linalg.solve(A_aug, F_aug)[:N_total_dof]\n    cond_lagrange = np.linalg.cond(A_aug, 2)\n\n    # Penalty Method\n    A_pen = A + tau * np.outer(C, C)\n    u_h_penalty = np.linalg.solve(A_pen, F)\n    cond_penalty = np.linalg.cond(A_pen, 2)\n\n    # 5. Error Calculation\n    l2_err_sq_lagrange, l2_err_sq_penalty, l2_norm_sq_exact = 0.0, 0.0, 0.0\n    for e in range(E):\n        idx_start, idx_end = e * N_dof_per_el, (e + 1) * N_dof_per_el\n        x_nodes = (e * h) + h * (nodes_ref + 1.0) / 2.0\n        u_exact_vals = u_exact(x_nodes)\n        \n        u_h_lagrange_vals = u_h_lagrange[idx_start:idx_end]\n        u_h_penalty_vals = u_h_penalty[idx_start:idx_end]\n        \n        l2_err_sq_lagrange += (h/2.0) * np.sum(weights_ref * (u_h_lagrange_vals - u_exact_vals)**2)\n        l2_err_sq_penalty += (h/2.0) * np.sum(weights_ref * (u_h_penalty_vals - u_exact_vals)**2)\n        l2_norm_sq_exact += (h/2.0) * np.sum(weights_ref * u_exact_vals**2)\n\n    rel_l2_err_lagrange = np.sqrt(l2_err_sq_lagrange / l2_norm_sq_exact)\n    rel_l2_err_penalty = np.sqrt(l2_err_sq_penalty / l2_norm_sq_exact)\n    \n    return rel_l2_err_lagrange, cond_lagrange, rel_l2_err_penalty, cond_penalty\n\ndef solve():\n    test_cases = [\n        (8, 3, 10**4),\n        (8, 3, 10**2),\n        (4, 2, 10**4),\n        (16, 3, 10**6),\n    ]\n\n    results = []\n    for E, p, tau in test_cases:\n        case_results = solve_case(E, p, tau)\n        results.extend(case_results)\n    \n    result_str = \",\".join(f\"{res:.6e}\" for res in results)\n    print(f\"[{result_str}]\")\n\nsolve()\n````"
        }
    ]
}