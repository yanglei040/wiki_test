{
    "hands_on_practices": [
        {
            "introduction": "傅里叶分析的一个基石是函数的光滑度与其傅里叶系数的衰减速率之间的直接关系。本练习将通过计算来探索这一基本原理。您将构建具有可控频谱衰减的周期函数，然后使用三角多项式插值和离散傅里叶变换（DFT）来数值验证这种关系，从而亲身体验频谱信息如何反映物理属性。",
            "id": "3284382",
            "problem": "要求您设计并实现一个程序，该程序根据合成周期函数的等距样本构建三角插值多项式，其中这些函数的光谱含量由一个可调的衰减参数控制。然后，程序必须通过估计傅里叶系数的衰减率来验证光滑度，并量化频谱滤波的效果。所有角度都必须以弧度为单位。\n\n将使用的基本基底和定义：\n- 一个实值、$2\\pi$-周期函数 $f$ 可以由基于 $k \\in \\mathbb{N}$ 的基 $\\{1, \\cos(kx), \\sin(kx)\\}$ 构建的三角多项式来近似。对 $N$ 个等距样本进行插值的、阶数至多为 $\\lfloor (N-1)/2 \\rfloor$ 的三角插值多项式是唯一的。\n- 使用等距节点 $x_j = 2\\pi j/N$（其中 $j = 0, 1, \\dots, N-1$），复指数基 $\\{e^{ikx}\\}$ 的离散正交性确保了可以计算离散傅里葉变换系数 $c_k$，并通过逆变换精确恢复原始样本。对于实信号，频率 $k$ 处的谐波对的振幅与复系数的模相关。\n- 周期函数的光滑度反映在其傅里叶系数的衰减上；更光滑的函数表现出谐波振幅随频率指数的增加而更快地衰减。\n\n任务：\n1. 具有受控光滑度的合成数据集生成：\n   - 对于给定的整数 $N$ 和 $K$（其中 $N \\ge 2$ 且 $1 \\le K  N$），考虑等距网格 $x_j = 2\\pi j/N$。\n   - 使用衰减参数 $p > 0$ 为 $k = 1, 2, \\dots, K$ 定义系数 $a_k$ 和 $b_k$ 为\n     $$a_k = k^{-p} + \\Delta_a(k), \\quad b_k = s_k\\left(\\tfrac{1}{2}k^{-p} + \\Delta_b(k)\\right),$$\n     其中 $s_k = (-1)^k$，且\n     $$\\Delta_a(k) = \\begin{cases} \\delta,  k \\ge k_0 \\\\ 0,  k  k_0 \\end{cases}, \\quad \\Delta_b(k) = \\begin{cases} \\tfrac{\\delta}{2},  k \\ge k_0 \\\\ 0,  k  k_0 \\end{cases}.$$\n     对 $(\\Delta_a(k), \\Delta_b(k))$ 从索引 $k_0$ 开始引入一个水平为 $\\delta \\ge 0$ 的高频平台（如果指定了 $k_0$），否则当 $\\delta = 0$ 或未提供 $k_0$ 时禁用。\n   - 构建合成周期样本\n     $$s_j = \\sum_{k=1}^{K} \\left( a_k \\cos(k x_j) + b_k \\sin(k x_j) \\right), \\quad j = 0, 1, \\dots, N-1.$$\n2. 通过离散傅里叶变换进行三角插值：\n   - 使用等距网格上的标准复指数正交性，计算样本序列 $\\{s_j\\}$ 的离散傅里叶变换系数 $c_k$（其中 $k = 0, 1, \\dots, N-1$）。\n   - 为 $k = 1, 2, \\dots, m$（其中 $m = \\lfloor N/2 \\rfloor$）定义谐波振幅包络为\n     $$A_k = \\begin{cases} 2|c_k|,  1 \\le k  m \\\\ |c_m|,  k = m \\text{ and } N \\text{ even} \\end{cases}.$$\n     此约定避免了在 $N$ 为偶数时重复计算奈奎斯特频率，并捕捉了每个正弦-余弦谐波对的振幅。\n3. 通过系数衰减进行光滑度验证：\n   - 通过对 $\\log(A_k)$ 与 $\\log(k)$ 进行最小二乘线性回归来估计衰减率 $p_{\\mathrm{est}}$，回归范围为 $A_k$ 在数值上显著的索引（排除 $A_k \\le 10^{-12}$ 的值），并在 $N$ 为偶数时排除奈奎斯特指数。具体来说，拟合\n     $$\\log(A_k) \\approx \\alpha - p_{\\mathrm{est}} \\log(k).$$\n4. 频谱滤波与误差量化：\n   - 对于给定的截止频率 $M_{\\mathrm{cut}}$（其中 $1 \\le M_{\\mathrm{cut}} \\le m$），通过将所有满足 $k > M_{\\mathrm{cut}}$ 和 $k  N - M_{\\mathrm{cut}}$ 的离散傅里叶系数 $\\{c_k\\}$ 置零，然后应用离散傅里叶逆变换来获得滤波后的样本 $\\{\\hat{s}_j\\}$，从而构建一个滤波后的重构。\n   - 计算最大绝对插值误差\n     $$E_{\\max} = \\max_{0 \\le j  N} | \\hat{s}_j - s_j |.$$\n   - 计算超出截止频率的尾部能量比\n     $$R_{\\mathrm{tail}} = \\frac{ \\sum_{k = M_{\\mathrm{cut}}+1}^{m} A_k^2 }{ \\sum_{k = 1}^{m} A_k^2 }.$$\n5. 验证逻辑：\n   - 通过/失败准则结合了衰减估计和尾部能量行为：\n     - 如果测试用例指定无平台（即预期为衰减谱），则当 $|p_{\\mathrm{est}} - p| \\le \\tau_p$ 且 $R_{\\mathrm{tail}}  \\rho$ 时，声明通过。\n     - 如果测试用例指定有平台（即预期有非衰减的高频内容），则当 $R_{\\mathrm{tail}} \\ge \\rho$ 时，声明通过。在这种平台情况下，对 $p_{\\mathrm{est}}$ 不施加条件。\n\n测试：\n提供以下测试套件，每个测试用例由一个元组 $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau})$ 定义：\n- 案例 $1$ (正常路径，平滑衰减): $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau}) = (128, 30, 2.5, 20, \\text{none}, 0.0, 0.1, 0.05, \\text{False})$。\n- 案例 $2$ (使用较小 $N$ 的边界情况): $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau}) = (32, 10, 1.0, 8, \\text{none}, 0.0, 0.2, 0.05, \\text{False})$。\n- 案例 $3$ (带高频平台的边缘情况): $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau}) = (256, 60, 2.0, 30, 40, 0.1, 0.2, 0.1, \\text{True})$。\n\n最终输出规格：\n- 对每个测试用例，生成一个子列表 $[p_{\\mathrm{est}}, E_{\\max}, R_{\\mathrm{tail}}, \\text{pass}]$，其中 $p_{\\mathrm{est}}$、$E_{\\max}$ 和 $R_{\\mathrm{tail}}$ 是四舍五入到六位小数的浮点数，$\\text{pass}$ 为 $\\text{True}$ 或 $\\text{False}$。\n- 您的程序应生成一行输出，包含一个由这些子列表组成的、以逗号分隔的列表，并用方括号括起来，不含空格。例如，三个测试用例的输出必须类似于 $[[p_1,E_1,R_1,\\text{True}],[p_2,E_2,R_2,\\text{False}],[p_3,E_3,R_3,\\text{True}]]$，其中所有浮点数都显示六位小数。",
            "solution": "用户提供的问题被评估为**有效**，因为它基于傅里叶分析和数值方法的原理，具有科学依据，是适定的，并提供了一套完整、一致且可形式化的指令。该问题要求实现一个涉及三角插值、谱分析和滤波的数值程序，这是科学计算中的一个标准课题。所有提供的定义、公式和测试用例都是一致的，并允许开发出一个唯一的、可验证的解。\n\n解决方案通过为每个测试案例实施指定步骤来进行。\n\n**1. 合成数据集生成**\n对于每个测试用例，我们得到参数 $(N, K, p, M_{\\mathrm{cut}}, k_0, \\delta, \\tau_p, \\rho, \\text{expect\\_plateau})$。我们首先在 $N$ 个点的等距网格 $x_j = \\frac{2\\pi j}{N}$（其中 $j=0, \\dots, N-1$）上构建信号 $s_j$。该信号是 $K$ 个谐波的总和：\n$$s_j = \\sum_{k=1}^{K} \\left( a_k \\cos(k x_j) + b_k \\sin(k x_j) \\right)$$\n系数 $a_k$ 和 $b_k$ 被定义为模拟具有潜在高频平台的幂律谱衰减：\n$$a_k = k^{-p} + \\Delta_a(k), \\quad b_k = (-1)^k\\left(\\tfrac{1}{2}k^{-p} + \\Delta_b(k)\\right)$$\n平台项 $\\Delta_a(k)$ 和 $\\Delta_b(k)$ 仅在提供了起始索引 $k_0$ 且 $\\delta > 0$ 时才非零。具体来说，当 $k \\ge k_0$ 时，$\\Delta_a(k) = \\delta$ 和 $\\Delta_b(k) = \\frac{\\delta}{2}$，否则为零。这种构造可以使用向量化的 NumPy 操作高效实现。\n\n**2. 离散傅里叶变换与谐波振幅**\n三角插值多项式通过计算样本 $\\{s_j\\}$ 的离散傅里叶变换（DFT）来隐式地找到。DFT 系数，我们记为 $C_k^{\\text{unnorm}} = \\sum_{j=0}^{N-1} s_j e^{-i k x_j}$，是使用 `numpy.fft.fft` 计算的。为了理论上的一致性，这些系数被归一化以获得 $c_k = \\frac{1}{N} C_k^{\\text{unnorm}}$。\n对于实值信号，第 $k$ 个谐波的振幅与 $c_k$ 的模有关。谐波振幅包络 $A_k$ 是为正频率 $k=1, \\dots, m$（其中 $m = \\lfloor N/2 \\rfloor$）定义的。由于所有测试用例都使用偶数 $N$，$m=N/2$。定义如下：\n$$A_k = \\begin{cases} 2|c_k|,  1 \\le k  m \\\\ |c_m|,  k = m \\end{cases}$$\n因子 $2$ 解释了来自正频率（$k$）和负频率（$-k \\equiv N-k$）分量的能量，它们是复共轭的。奈奎斯特频率分量（$k=m$）在唯一频率范围内没有共轭对应项，并被单独处理。由于输入信号没有直流分量（$s(x)$在一个周期内积分为零），$c_0=0$。\n一个关键的理论见解是，对于一个如上构建且 $K  N/2$ 的信号，不存在混叠，并且从样本计算出的振幅 $A_k$ 应直接与生成系数相关：对于 $k \\le K$，$A_k \\approx \\sqrt{a_k^2 + b_k^2}$；对于 $k > K$，$A_k \\approx 0$。\n\n**3. 通过衰减率估计进行光滑度验证**\n底层连续函数的光滑度与其傅里叶系数衰减的速度有关。我们通过对振幅的对数拟合一个线性模型来估计衰减指数 $p$：\n$$\\log(A_k) \\approx \\alpha - p_{\\mathrm{est}} \\log(k)$$\n这是一个 $y = \\log(A_k)$ 关于 $x = \\log(k)$ 的线性回归。估计的衰减率 $p_{\\mathrm{est}}$ 是这条线斜率的负值。拟合是使用最小二乘法（`numpy.polyfit`）在频率范围 $k=1, \\dots, m-1$ 上进行的。奈奎斯特频率被排除在外，这是一种标准做法，因为它的行为不同。为避免 $\\log(0)$ 引起的数值问题，只有振幅 $A_k > 10^{-12}$ 的值被包含在回归中。\n\n**4. 频谱滤波与误差分析**\n为了模拟低通滤波器的效果，我们截断频谱。一个滤波后的信号 $\\{\\hat{s}_j\\}$ 是通过首先将所有频率索引 $k$ 满足 $M_{\\mathrm{cut}}  k  N - M_{\\mathrm{cut}}$ 的 DFT 系数 $C_k^{\\text{unnorm}}$ 置零，然后对这个修改后的频谱应用逆 DFT（`numpy.fft.ifft`）来重构的。得到的 $\\hat{s}_j$ 是使用前 $M_{\\mathrm{cut}}$ 个谐波对 $s_j$ 的最佳逼近。\n滤波误差由最大绝对误差 $E_{\\max} = \\max_{j} | \\hat{s}_j - s_j |$ 来量化。\n因滤波而损失的能量由尾部能量比 $R_{\\mathrm{tail}}$ 来量化。根据帕塞瓦尔定理，信号域中的能量与频域中振幅平方和成正比。因此，该比率为：\n$$R_{\\mathrm{tail}} = \\frac{ \\sum_{k = M_{\\mathrm{cut}}+1}^{m} A_k^2 }{ \\sum_{k = 1}^{m} A_k^2 }$$\n这衡量了包含在截止频率 $M_{\\mathrm{cut}}$ 以上频率中的谱能量的分数。\n\n**5. 验证逻辑**\n最后一步是根据问题规范应用通过/失败准则：\n- 如果预期为平滑衰减（`expect_plateau` 为 False），则当估计的衰减率 $p_{\\mathrm{est}}$ 接近真实速率 $p$（即 $|p_{\\mathrm{est}} - p| \\le \\tau_p$）且尾部能量 $R_{\\mathrm{tail}}$ 很小（即 $R_{\\mathrm{tail}}  \\rho$）时，测试通过。\n- 如果预期有高频平台（`expect_plateau` 为 True），则当尾部能量 $R_{\\mathrm{tail}}$ 显著（即 $R_{\\mathrm{tail}} \\ge \\rho$）时，测试通过，这表明高频分量是不可忽略的。\n\n计算出的值 $p_{\\mathrm{est}}$、$E_{\\max}$ 和 $R_{\\mathrm{tail}}$ 四舍五入到六位小数，并为每种情况确定布尔值的通过/失败结果。然后将这些结果格式化为指定的字符串输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point for solving the problem. It defines the test cases,\n    processes each one, and prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, K, p, M_cut, k0, delta, tau_p, rho, expect_plateau)\n        (128, 30, 2.5, 20, None, 0.0, 0.1, 0.05, False),\n        (32, 10, 1.0, 8, None, 0.0, 0.2, 0.05, False),\n        (256, 60, 2.0, 30, 40, 0.1, 0.2, 0.1, True),\n    ]\n\n    # This list will store the sublist strings for final concatenation.\n    results_as_strings = []\n    \n    for case in test_cases:\n        N, K, p, M_cut, k0, delta, tau_p, rho, expect_plateau = case\n        \n        # 1. Synthetic dataset generation\n        x_j = (2 * np.pi / N) * np.arange(N)\n        k_vals = np.arange(1, K + 1)\n        \n        p_decay = k_vals**(-p)\n        \n        delta_a = np.zeros(K)\n        delta_b = np.zeros(K)\n        if k0 is not None and delta > 0:\n            indices_to_modify = k_vals >= k0\n            delta_a[indices_to_modify] = delta\n            delta_b[indices_to_modify] = delta / 2.0\n            \n        a_k = p_decay + delta_a\n        s_k_sign = (-1)**k_vals\n        b_k = s_k_sign * (0.5 * p_decay + delta_b)\n        \n        outer_prod = np.outer(x_j, k_vals)\n        s_j = np.cos(outer_prod) @ a_k + np.sin(outer_prod) @ b_k\n\n        # 2. Trigonometric interpolation via DFT\n        C_k_unnormalized = np.fft.fft(s_j)\n        c_k = C_k_unnormalized / N\n        \n        m = N // 2\n        \n        # Harmonic amplitude envelope A_k for k=1..m (0-indexed array)\n        A_k = np.zeros(m)\n        if m > 1: # Handles N=2 case\n            A_k[:m-1] = 2 * np.abs(c_k[1:m])\n        A_k[m-1] = np.abs(c_k[m]) # Nyquist frequency (all test cases have even N)\n\n        # 3. Smoothness validation via coefficient decay\n        k_for_fit = np.arange(1, m)\n        A_for_fit = A_k[:m-1]\n        \n        significant_mask = A_for_fit > 1e-12\n        k_reg = k_for_fit[significant_mask]\n        \n        p_est = 0.0\n        if len(k_reg) >= 2:\n            A_reg = A_for_fit[significant_mask]\n            log_k = np.log(k_reg)\n            log_A = np.log(A_reg)\n            slope, _ = np.polyfit(log_k, log_A, 1)\n            p_est = -slope\n\n        # 4. Spectral filtering and error quantification\n        C_filtered = C_k_unnormalized.copy()\n        C_filtered[M_cut + 1 : N - M_cut] = 0.0\n        \n        s_hat_j = np.real(np.fft.ifft(C_filtered))\n        E_max = np.max(np.abs(s_hat_j - s_j))\n\n        # 5. Tail energy ratio\n        numerator = np.sum(A_k[M_cut:]**2)\n        denominator = np.sum(A_k**2)\n        R_tail = numerator / denominator if denominator > 1e-15 else 0.0\n\n        # 6. Validation logic\n        if expect_plateau:\n            is_pass = R_tail >= rho\n        else:\n            is_pass = (np.abs(p_est - p) = tau_p) and (R_tail  rho)\n        \n        # Format the sublist as a string according to requirements\n        sublist_str = f\"[{p_est:.6f},{E_max:.6f},{R_tail:.6f},{is_pass}]\"\n        results_as_strings.append(sublist_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分区定义域上使用像间断伽辽金（DG）这样的高阶方法时，一个关键问题是：局部逼近能力如何转化为全局分辨率？本练习要求您将每个单元上的局部多项式次数与可以无混叠表示的全局最大傅里叶模态联系起来。通过推导这个极限，您将深入了解多单元谱方法的基本分辨率限制。",
            "id": "3387856",
            "problem": "考虑一个长度为 $L=2\\pi$ 的周期性域，它被划分为 $E=3$ 个单元，长度分别为 $h_{1}=\\frac{\\pi}{3}$，$h_{2}=\\frac{\\pi}{2}$ 和 $h_{3}=\\frac{7\\pi}{6}$，因此 $h_{1}+h_{2}+h_{3}=2\\pi$。在每个单元 $e\\in\\{1,2,3\\}$ 上，定义局部角坐标 $\\theta_{e}=2\\pi\\,(x-x_{e-1})/h_{e}\\in[0,2\\pi)$，其中 $x_{e-1}$ 是第 $e$ 个单元的左端点。局部逼近空间是复指数 $\\{\\exp(ij\\theta_{e})\\}_{j=-N_{e}}^{N_{e}}$ 的张成空间，即次数为 $N_{e}$ 的三角多项式空间，在 $\\theta_{e}$ 中的 $2N_{e}+1$ 个等距节点上进行插值。角度以弧度为单位。假设分段逼近是使用间断伽辽金（Discontinuous Galerkin, DG）方法组装的，因此在界面上不强制要求数值连续。\n\n一个全局傅里叶模式由 $u_{k}(x)=\\exp(ikx)$ 给出，其中整数波数 $k\\geq 0$。从每个单元上的三角多项式插值定义和均匀网格的采样定理出发，推导全局模式 $u_{k}$ 在每个单元上都能无混叠地表示的充分必要条件。利用这个条件，建立最大可分辨全局波数 $k_{\\star}$ 关于局部次数 $N_{e}$ 和单元长度 $h_{e}$ 的表达式，该表达式确保了无混叠，从而在单元表示中没有界面不一致性。\n\n最后，将你的表达式应用于给定的网格和次数 $N_{1}=5$，$N_{2}=3$ 和 $N_{3}=8$，并计算满足无混叠条件的最大整数 $k_{\\star}$。给出 $k_{\\star}$ 的单个值作为你的最终答案。无需四舍五入。角度以弧度为单位。",
            "solution": "该问题要求推导一个条件，以确保全局傅里叶模式 $u_{k}(x) = \\exp(ikx)$ 在间断伽辽金（DG）框架下，在非均匀网格的每个单元上都能无混叠地表示。这个条件将导出最大可分辨全局波数 $k_{\\star}$。\n\n首先，我们必须用每个单元 $e$ 的局部坐标 $\\theta_{e}$ 来表示全局函数 $u_{k}(x)$。问题将单元 $e$ 上的局部角坐标定义为 $\\theta_{e} = 2\\pi(x - x_{e-1})/h_{e}$，其中 $x_{e-1}$ 是单元的左端点，$h_e$ 是其长度。局部坐标的域是 $\\theta_{e} \\in [0, 2\\pi)$。我们可以反转这个关系，用局部坐标 $\\theta_{e}$ 来表示全局坐标 $x$：\n$$\nx = x_{e-1} + \\frac{h_{e}}{2\\pi} \\theta_{e}\n$$\n将此代入全局傅里叶模式 $u_{k}(x)$ 的表达式中，我们得到它在单元 $e$ 的局部坐标系中的表示：\n$$\nu_{k}(x(\\theta_e)) = \\exp\\left(ik \\left(x_{e-1} + \\frac{h_{e}}{2\\pi} \\theta_{e}\\right)\\right) = \\exp(ik x_{e-1}) \\exp\\left(i \\frac{kh_{e}}{2\\pi} \\theta_{e}\\right)\n$$\n项 $\\exp(ik x_{e-1})$ 在单元 $e$ 上是一个恒定的相位因子。对局部坐标的函数依赖性完全包含在项 $\\exp(i J_{e} \\theta_{e})$ 中，其中我们将单元 $e$ 上的无量纲局部波数定义为：\n$$\nJ_{e} = \\frac{kh_{e}}{2\\pi}\n$$\n单元 $e$ 上的局部逼近空间是次数为 $N_{e}$ 的三角多项式空间，是基函数 $\\{\\exp(ij\\theta_{e})\\}_{j=-N_{e}}^{N_{e}}$ 的张成空间。这个空间可以唯一表示任何频率 $j$ 在范围 $[-N_{e}, N_{e}]$ 内的三角多项式。\n\n问题陈述，逼近是通过在 $\\theta_{e}$ 中的 $2N_{e}+1$ 个等距节点上插值来构造的。根据三角多项式的采样定理，如果我们在 $2N_{e}+1$ 个等距点上对函数 $f(\\theta_e) = \\exp(iJ_{e}\\theta_{e})$进行采样，得到的三角插值多项式将是原始函数的混叠版本。当且仅当频率 $J_e$ 位于多项式空间唯一可表示频率的范围内时，插值多项式将与原始函数完全匹配。对于像 $[0, 2\\pi)$ 这样的半开区间和从 $-N_e$ 到 $N_e$ 索引的基，避免混叠的条件是：\n$$\n-N_{e} \\leq J_{e} \\leq N_{e}\n$$\n或者，更紧凑地写为 $|J_{e}| \\leq N_{e}$。由于全局波数 $k$ 是给定的非负整数（$k \\geq 0$）且单元长度 $h_{e}$ 是正的，所以局部波数 $J_{e} = kh_{e}/(2\\pi)$ 也是非负的。无混叠条件简化为：\n$$\nJ_{e} \\leq N_{e}\n$$\n代入 $J_{e}$ 的定义，我们得到在单元 $e$ 上无混叠的对全局波数 $k$ 的条件：\n$$\n\\frac{kh_{e}}{2\\pi} \\leq N_{e}\n$$\n对 $k$ 进行整理，我们得到：\n$$\nk \\leq \\frac{2\\pi N_{e}}{h_{e}}\n$$\n这个不等式给出了单个单元 $e$ 上的最大可分辨全局波数。为了使全局模式 $u_{k}(x)$ 在网格中的*每个*单元上都能无混叠地表示，这个条件必须对所有 $e \\in \\{1, 2, ..., E\\}$ 同时成立。因此，$k$ 必须小于或等于所有单元上这些上界的最小值：\n$$\nk \\leq \\min_{e \\in \\{1, \\dots, E\\}} \\left( \\frac{2\\pi N_{e}}{h_{e}} \\right)\n$$\n最大可分辨全局波数 $k_{\\star}$ 是满足此条件的最大整数 $k$。它由最小值的向下取整函数给出：\n$$\nk_{\\star} = \\left\\lfloor \\min_{e \\in \\{1, \\dots, E\\}} \\left( \\frac{2\\pi N_{e}}{h_{e}} \\right) \\right\\rfloor\n$$\n这是 $k_{\\star}$ 的通用表达式。现在，我们将此结果应用于具有 $E=3$ 个单元和指定参数的给定网格。数据如下：\n- 单元 1：$h_{1} = \\frac{\\pi}{3}$，$N_{1} = 5$\n- 单元 2：$h_{2} = \\frac{\\pi}{2}$，$N_{2} = 3$\n- 单元 3：$h_{3} = \\frac{7\\pi}{6}$，$N_{3} = 8$\n\n我们计算每个单元的最大可分辨波数：\n对于单元 1：\n$$\n\\frac{2\\pi N_{1}}{h_{1}} = \\frac{2\\pi (5)}{\\frac{\\pi}{3}} = \\frac{10\\pi}{\\frac{\\pi}{3}} = 10 \\times 3 = 30\n$$\n对于单元 2：\n$$\n\\frac{2\\pi N_{2}}{h_{2}} = \\frac{2\\pi (3)}{\\frac{\\pi}{2}} = \\frac{6\\pi}{\\frac{\\pi}{2}} = 6 \\times 2 = 12\n$$\n对于单元 3：\n$$\n\\frac{2\\pi N_{3}}{h_{3}} = \\frac{2\\pi (8)}{\\frac{7\\pi}{6}} = \\frac{16\\pi}{\\frac{7\\pi}{6}} = 16 \\times \\frac{6}{7} = \\frac{96}{7}\n$$\n现在我们求这三个值的最小值：\n$$\n\\min\\left(30, 12, \\frac{96}{7}\\right)\n$$\n为了比较这些值，我们注意到 $\\frac{96}{7} \\approx 13.714$。因此，最小值是 $12$。\n$$\n\\min\\left(30, 12, \\frac{96}{7}\\right) = 12\n$$\n可以在所有三个单元上无混叠表示的最大整数波数 $k_{\\star}$ 是这个最小值的向下取整：\n$$\nk_{\\star} = \\lfloor 12 \\rfloor = 12\n$$\n因此，在每个单元上都满足无混叠条件的最大整数全局波数是 $12$。",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "傅里叶方法不仅用于函数逼近，也为设计高效的数值算法提供了强大的工具。这个高级练习将探讨其在为区域分解预处理器构建粗网格校正子中的作用。通过实现一个在傅里叶域中交换低频信息的两层方法，您将看到谱技术如何显著改善偏微分方程迭代求解器的收敛性。",
            "id": "3387897",
            "problem": "考虑周期区间 $[0,1]$，其具有周期性边界条件，并令 $N$ 为一个偶数，表示等距网格点的数量，间距为 $h = 1/N$。在具有周期性包裹的网格上，通过模板 $(1,-2,1)/h^2$ 定义离散二阶有限差分拉普拉斯算子 $\\Delta_h$，即对于网格函数 $u \\in \\mathbb{R}^N$，\n$$\n(\\Delta_h u)_i = \\frac{u_{i-1} - 2 u_i + u_{i+1}}{h^2}, \\quad \\text{其中索引模 } N,\n$$\n并定义对称正定算子\n$$\nA u = \\beta u - \\Delta_h u\n$$\n其中 $\\beta > 0$。\n\n您将构建两个区域分解预条件子，并研究单步预条件理查森迭代的误差传播算子。迭代更新为 $u^{(n+1)} = u^{(n)} + z^{(n)}$，其中 $z^{(n)}$ 是对残差 $r^{(n)} = f - A u^{(n)}$ 的预条件校正。当 $f = 0$（齐次强迫项）时，误差 $e^{(n)} = u^{(n)}$ 的更新方式为 $e^{(n+1)} = (I - M^{-1} A) e^{(n)}$，其中 $M^{-1}$ 是线性预条件子。单步预条件理查森迭代的收敛率由谱半径量化\n$$\n\\rho(I - M^{-1} A) = \\max\\{ |\\lambda| : \\lambda \\text{ 是 } I - M^{-1} A \\text{ 的一个特征值} \\}.\n$$\n\n定义网格的一个非重叠划分为两个子域，它们之间有 $o$ 个网格点的重叠。具体来说，设第一个子域的索引集为\n$$\n\\Omega_A = \\{0,1,2,\\dots, N/2 + o - 1\\},\n$$ \n第二个子域的索引集为\n$$\n\\Omega_B = \\{N/2 - o, N/2 - o + 1, \\dots, N-1\\}.\n$$\n这些集合在 $2o$ 个索引上重叠。\n\n构建两个预条件子：\n\n1) 基于傅里叶的带截断谱交换的两层加性 Schwarz 方法。令 $R_A$ 和 $R_B$ 为限制算子，当在人工子域端点施加齐次狄利克雷边界条件时，它们提取每个子域的内部未知数。对于局部长度为 $m_A = N/2 + o$ 的子域 $\\Omega_A$，内部未知数是 $\\Omega_A$ 中除去第一个和最后一个节点的 $m_A - 2$ 个节点。对于局部长度为 $m_B = N - (N/2 - o)$ 的子域 $\\Omega_B$，内部未知数是 $\\Omega_B$ 中除去第一个和最后一个节点的 $m_B - 2$ 个节点。令 $A_A$ 和 $A_B$ 表示在这些内部未知数上由 $A$ 导出的局部离散算子，并在子域边界处具有齐次狄利克雷边界条件（即鬼点值为零）。单层加性 Schwarz 作用为\n$$\nM_{\\text{AS}}^{-1} r = R_A^\\top A_A^{-1} R_A r \\;+\\; R_B^\\top A_B^{-1} R_B r.\n$$\n用一个傅里叶粗网格校正来增强此方法，该校正仅交换全局残差的截断谱 $\\{\\hat{u}_k : |k| \\le K\\}$。用 $\\mathcal{F}$ 表示周期性网格上的离散傅里叶变换，用 $\\widehat{r}_k$ 表示整数波数 $k$ 处的傅里叶系数。定义作用于 $r$ 上的截断低模投影算子 $P_K$，它只保留 $|k| \\le K$ 的 $\\widehat{r}_k$，并将其他设为零，并定义在这些模式上的粗网格求解为\n$$\n\\widehat{z}_k = \\frac{\\widehat{r}_k}{\\beta + (2\\pi k)^2}, \\quad \\text{对于 } |k| \\le K, \\quad \\widehat{z}_k = 0 \\text{ 其他情况}.\n$$\n基于傅里叶的预条件子是\n$$\nM_K^{-1} r = M_{\\text{AS}}^{-1} r \\;+\\; \\mathcal{F}^{-1}( \\widehat{z} ),\n$$\n这可以解释为子域解通过粗网格校正仅在全局范围内交换截断谱 $\\{ \\widehat{u}_k : |k| \\le K \\}$。\n\n2) 物理空间罗宾耦合单层加性 Schwarz 方法。在每个子域上，将端点包含在局部未知量向量中，并在人工子域边界上施加齐次罗宾边界条件。对于具有局部网格未知数 $u_0,\\dots,u_{m_A-1}$ 的子域 $\\Omega_A$，其左端点和右端点的边界条件分别为\n$$\n\\frac{u_0 - u_{-1}}{h} + \\theta u_0 = 0, \\quad \\frac{u_{m_A} - u_{m_A-1}}{h} + \\theta u_{m_A-1} = 0,\n$$\n分别地；消除鬼点值 $u_{-1}$ 和 $u_{m_A}$ 以获得一个作用于所有 $m_A$ 个局部未知数的局部算子。同样的构造适用于具有其局部未知数的 $\\Omega_B$。令 $A_A^{(\\theta)}$ 和 $A_B^{(\\theta)}$ 表示这些经过罗宾修正的局部算子。罗宾耦合单层加性 Schwarz 预条件子是\n$$\nM_{\\text{Rb}(\\theta)}^{-1} r = R_A^\\top (A_A^{(\\theta)})^{-1} R_A r \\;+\\; R_B^\\top (A_B^{(\\theta)})^{-1} R_B r,\n$$\n其中现在 $R_A$ 和 $R_B$ 限制到所有子域节点，包括端点，而 $R_A^\\top$ 和 $R_B^\\top$ 通过在子域外补零来进行延拓。\n\n任务：\n\na) 实现周期性算子 $A$ 并计算误差传播算子\n$$\nE_K = I - M_K^{-1} A, \\quad E_{\\text{Rb}(\\theta)} = I - M_{\\text{Rb}(\\theta)}^{-1} A.\n$$\n使用这些算子在标准基向量上的精确线性作用来组装 $E_K$ 和 $E_{\\text{Rb}(\\theta)}$ 的稠密矩阵。\n\nb) 使用周期性网格上的离散傅里叶变换，实现 $M_K^{-1}$ 的截断谱粗网格校正。对于罗宾子域算子，通过使用离散近似\n$$\nu_{-1} = u_0 (1 + \\theta h), \\quad u_{m_A} = u_{m_A-1} (1 - \\theta h),\n$$\n来消除鬼点，从而实现齐次罗宾边界条件，并对 $\\Omega_B$ 进行类似处理。\n\nc) 为下面定义的一组测试用例计算谱半径 $\\rho(E_K)$ 和 $\\rho(E_{\\text{Rb}(\\theta)})$，这些用例改变截断水平 $K$ 和罗宾参数 $\\theta$。以浮点数形式返回谱半径。\n\n使用的基本依据和事实：\n\n- 使用周期性网格上的有限差分拉普拉斯算子，以及离散傅里叶级数可对角化周期性网格上的卷积算子这一事实。\n- 使用矩阵 $T$ 的谱半径 $\\rho(T)$ 的定义，即其特征值的最大绝对值。\n- 使用标准的区域分解预条件子构造：具有齐次狄利克雷边界条件的加性 Schwarz 方法；通过鬼点消除强制施加的罗宾边界条件；以及仅作用于低模的全局傅里叶粗网格校正。\n\n角度单位规定：任何傅里叶分析都必须以弧度处理角度。傅里叶波数 $k$ 是一个整数，角频率是每单位区间长度 $2\\pi k$ 弧度。\n\n测试套件：\n\n- 使用 $N = 64$，$\\beta = 1.0$，重叠 $o = 8$。\n- 对以下 $(K,\\theta)$ 对评估谱半径：\n  1. $(0, 0.1)$ [边界情况：无粗网格校正]\n  2. $(2, 0.1)$ [小粗糙空间对弱罗宾]\n  3. $(4, 1.0)$ [中等粗糙空间对中等罗宾]\n  4. $(8, 1.0)$ [较大粗糙空间对中等罗宾]\n  5. $(16, 10.0)$ [大粗糙空间对强罗宾]\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，条目按如下顺序排列\n$$\n[\\rho(E_K)_{(K,\\theta)_1}, \\rho(E_{\\text{Rb}(\\theta)})_{(K,\\theta)_1}, \\dots, \\rho(E_K)_{(K,\\theta)_5}, \\rho(E_{\\text{Rb}(\\theta)})_{(K,\\theta)_5}],\n$$\n其中下标表示从 1 到 5 的测试用例索引。每个条目必须是基于弧度的谱分析中的浮点数（无单位）。不应打印其他文本。",
            "solution": "该问题要求计算两种用于周期性域上算子 $A = \\beta I - \\Delta_h$ 的预条件迭代的谱半径。误差传播算子 $E = I - M^{-1}A$ 的谱半径决定了预条件理查森迭代的渐进收敛率。我们将构造算子 $A$ 和预条件子 $M_K^{-1}$ 及 $M_{\\text{Rb}(\\theta)}^{-1}$ 的稠密矩阵表示，以形成 $E_K$ 和 $E_{\\text{Rb}(\\theta)}$ 的矩阵。所有数学实体均按要求使用 LaTeX 表示。\n\n**1. 全局算子 $A$**\n算子 $A u = \\beta u - \\Delta_h u$ 定义在具有 $N$ 个点和间距 $h=1/N$ 的周期性网格上。离散拉普拉斯算子 $(\\Delta_h u)_i = (u_{i-1} - 2u_i + u_{i+1})/h^2$ 具有周期性索引（模 $N$），这意味着 $A$ 可以由一个 $N \\times N$ 的对称循环矩阵表示。矩阵 $A$ 的第 $i$ 行对应于方程：\n$$ (A u)_i = \\beta u_i - \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = -\\frac{1}{h^2} u_{i-1} + \\left(\\beta + \\frac{2}{h^2}\\right) u_i - \\frac{1}{h^2} u_{i+1} $$\n对角线元素为 $A_{ii} = \\beta + 2/h^2$，次对角线和超对角线元素为 $A_{i, i\\pm 1} = -1/h^2$。由于周期性，角点元素为 $A_{0, N-1} = A_{N-1, 0} = -1/h^2$。\n\n**2. 基于傅里叶的预条件子 $M_K^{-1}$**\n该预条件子是两个分量的和，即 $M_K^{-1} = M_{\\text{AS}}^{-1} + M_{\\text{coarse}}^{-1}$。我们为每个部分构造矩阵。\n\n**2.1. 加性 Schwarz 部分 $M_{\\text{AS}}^{-1}$**\n单层加性 Schwarz 预条件子由 $M_{\\text{AS}}^{-1} = R_A^\\top A_A^{-1} R_A + R_B^\\top A_B^{-1} R_B$ 给出。子域为 $\\Omega_A$（索引 $\\{0, ..., m_A-1\\}$）和 $\\Omega_B$（索引 $\\{N/2-o, ..., N-1\\}$），其中 $m_A = m_B = N/2+o$。对于此预条件子，局部问题在每个子域的内部节点上设置，并带有齐次狄利克雷边界条件。\n- $\\Omega_A$ 的内部由 $m_A-2$ 个节点组成，对应于全局索引 $\\{1, ..., m_A-2\\}$。\n- $\\Omega_B$ 的内部由 $m_B-2$ 个节点组成，对应于全局索引 $\\{N/2-o+1, ..., N-2\\}$。局部算子 $A_A$（以及与之相同的 $A_B$）是表示带狄利克雷条件的 $\\beta I - \\Delta_h$ 的 $(m_A-2) \\times (m_A-2)$ 三对角矩阵：对角线元素为 $\\beta+2/h^2$，非对角线元素为 $-1/h^2$。\n限制算子 $R_A$ 和 $R_B$ 提取相关的内部分量，而延拓算子 $R_A^\\top$ 和 $R_B^\\top$ 将局部解放回全局向量中，并用零填充。$M_{\\text{AS}}^{-1}$ 的矩阵是一个 $N \\times N$ 矩阵。$R^\\top (\\cdot) R$ 的作用对应于将逆局部算子矩阵 $A_{\\text{local}}^{-1}$ 嵌入到全局矩阵中与子域相对应的索引处。因此，我们通过首先计算 $A_A^{-1}$，然后将这个 $(m_A-2) \\times (m_A-2)$ 矩阵加到 $M_{\\text{AS}}^{-1}$ 中对应于 $\\Omega_A$ 内部的块中，并对 $\\Omega_B$ 做同样的操作，来形成 $M_{\\text{AS}}^{-1}$ 的矩阵。\n\n**2.2. 粗网格校正部分**\n粗网格校正定义在傅里叶空间中，即对于整数波数 $|k| \\le K$，应用谱乘子 $\\widehat{z}_k = [\\beta + (2\\pi k)^2]^{-1} \\widehat{r}_k$，否则为 $0$。此操作是一个卷积。周期性网格上卷积算子的矩阵表示是一个循环矩阵。它的第一列是将算子应用于第一个标准基向量 $e_0 = [1, 0, \\dots, 0]^\\top$ 的结果。$e_0$ 的离散傅里叶变换是一个全为 1 的向量，即对于所有波数 $k$，$\\widehat{(e_0)}_k = 1/N$（取决于DFT的归一化约定，这里假设为$1/N$）。\n因此，粗网格校正矩阵第一列的傅里叶系数是 $\\widehat{c}_k = 1/[\\beta + (2\\pi k)^2]$（对于 $|k| \\le K$）和 $0$（其他情况）。第一列本身是通过离散傅里叶逆变换得到的，$c = \\mathcal{F}^{-1}(\\widehat{c})$。粗网格校正的完整 $N \\times N$ 矩阵是由此列向量 $c$ 生成的循环矩阵。总预条件子矩阵为 $M_K^{-1} = M_{\\text{AS}}^{-1} + M_{\\text{coarse}}^{-1}$。\n\n**3. 罗宾耦合预条件子 $M_{\\text{Rb}(\\theta)}^{-1}$**\n该预条件子由 $M_{\\text{Rb}(\\theta)}^{-1} = R_A^\\top (A_A^{(\\theta)})^{-1} R_A + R_B^\\top (A_B^{(\\theta)})^{-1} R_B$ 给出。在这里，局部问题在子域 $\\Omega_A$ 和 $\\Omega_B$ 的所有节点上求解，其大小为 $m=N/2+o$。\n局部算子 $A_A^{(\\theta)}$ 和 $A_B^{(\\theta)}$ 是通过在每个子域段的两端施加罗宾边界条件来构建的。对于 $m$ 个节点 $u_0, \\dots, u_{m-1}$ 上的一个通用局部问题，离散算子方程 $(\\beta I - \\Delta_h)u = f$ 在边界处被修改。\n- 在左边界（$i=0$），方程为 $(\\beta+2/h^2)u_0 - u_{-1}/h^2 - u_1/h^2 = f_0$。使用给定条件 $u_{-1} = u_0(1+\\theta h)$ 消除鬼点 $u_{-1}$，得到修改后的方程 $(\\beta+2/h^2-1/h^2(1+\\theta h))u_0 - u_1/h^2 = f_0$，即 $(\\beta+1/h^2-\\theta/h)u_0 - u_1/h^2 = f_0$。\n- 在右边界（$i=m-1$），方程为 $(\\beta+2/h^2)u_{m-1} - u_{m-2}/h^2 - u_m/h^2 = f_{m-1}$。使用 $u_m = u_{m-1}(1-\\theta h)$ 消除鬼点 $u_m$，得到 $-u_{m-2}/h^2 + (\\beta+2/h^2-1/h^2(1-\\theta h))u_{m-1} = f_{m-1}$，即 $-u_{m-2}/h^2 + (\\beta+1/h^2+\\theta/h)u_{m-1} = f_{m-1}$。\n得到的 $m \\times m$ 局部算子矩阵，记为 $A^{(\\theta)}$，是三对角的，其角点处的对角线元素被修改。根据指令“同样的构造适用于 $\\Omega_B$”，我们对两个子域都使用这个相同的局部算子矩阵 $A^{(\\theta)}$。\n$M_{\\text{Rb}(\\theta)}^{-1}$ 的矩阵是通过计算 $(A^{(\\theta)})^{-1}$ 并将此 $m \\times m$ 块矩阵加到全局 $N \\times N$ 矩阵中对应于 $\\Omega_A$ 和 $\\Omega_B$ 索引的块中来构建的。\n\n**4. 谱半径计算**\n对于每个测试用例 $(K, \\theta)$，我们组装 $A$、$M_K^{-1}$ 和 $M_{\\text{Rb}(\\theta)}^{-1}$ 的稠密 $N \\times N$ 矩阵。然后我们计算误差传播矩阵 $E_K = I - M_K^{-1} A$ 和 $E_{\\text{Rb}(\\theta)} = I - M_{\\text{Rb}(\\theta)}^{-1} A$。通过数值计算这些矩阵的所有特征值并找到绝对值最大的那个来求得谱半径：$\\rho(E) = \\max_j |\\lambda_j(E)|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import circulant, inv\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 0.1),\n        (2, 0.1),\n        (4, 1.0),\n        (8, 1.0),\n        (16, 10.0),\n    ]\n\n    # Global parameters\n    N = 64\n    beta = 1.0\n    o = 8\n    h = 1.0 / N\n\n    # 1. Construct the global operator A\n    diag_val = beta + 2.0 / (h * h)\n    off_diag_val = -1.0 / (h * h)\n    A = np.zeros((N, N))\n    A += np.diag(np.full(N, diag_val))\n    A += np.diag(np.full(N - 1, off_diag_val), k=1)\n    A += np.diag(np.full(N - 1, off_diag_val), k=-1)\n    A[0, N - 1] = off_diag_val\n    A[N - 1, 0] = off_diag_val\n    \n    identity_N = np.eye(N)\n    \n    results = []\n    for K, theta in test_cases:\n        # 2. Construct Fourier-based preconditioner M_K^-1\n        \n        # 2.1 Additive Schwarz part (M_AS^-1)\n        m_A_int = N // 2 + o - 2  # Size of interior subdomain\n        A_local_dirichlet = np.zeros((m_A_int, m_A_int))\n        A_local_dirichlet += np.diag(np.full(m_A_int, diag_val))\n        A_local_dirichlet += np.diag(np.full(m_A_int - 1, off_diag_val), k=1)\n        A_local_dirichlet += np.diag(np.full(m_A_int - 1, off_diag_val), k=-1)\n\n        A_local_dirichlet_inv = inv(A_local_dirichlet)\n\n        M_AS_inv = np.zeros((N, N))\n        \n        idx_A_int = slice(1, 1 + m_A_int)\n        idx_B_int_start = N // 2 - o + 1\n        idx_B_int = slice(idx_B_int_start, idx_B_int_start + m_A_int)\n        \n        M_AS_inv[idx_A_int, idx_A_int] += A_local_dirichlet_inv\n        M_AS_inv[idx_B_int, idx_B_int] += A_local_dirichlet_inv\n\n        # 2.2 Coarse correction part\n        k_wave = np.fft.fftfreq(N, d=1.0/N)\n        z_hat = np.zeros(N, dtype=complex)\n        \n        # Get integer wavenumbers for the condition |k| = K\n        k_int = np.fft.fftfreq(N, d=1.0/N) / (2 * np.pi)\n        k_int = np.round(k_int).astype(int)\n\n        mask = np.abs(k_int) = K\n        \n        denom = beta + (2 * np.pi * k_wave[mask])**2\n        z_hat[mask] = 1.0 / denom\n\n        first_col = np.fft.ifft(z_hat).real\n        M_coarse_inv = circulant(first_col)\n\n        # 2.3 Total preconditioner M_K^-1 and spectral radius\n        M_K_inv = M_AS_inv + M_coarse_inv\n        E_K = identity_N - M_K_inv @ A\n        rho_K = np.max(np.abs(np.linalg.eigvals(E_K)))\n        results.append(rho_K)\n\n        # 3. Construct Robin-coupled preconditioner M_Rb(theta)^-1\n        m_full = N // 2 + o\n        A_theta = np.zeros((m_full, m_full))\n        A_theta += np.diag(np.full(m_full, diag_val))\n        A_theta += np.diag(np.full(m_full - 1, off_diag_val), k=1)\n        A_theta += np.diag(np.full(m_full - 1, off_diag_val), k=-1)\n\n        # Apply Robin boundary conditions\n        A_theta[0, 0] = beta + 1.0/(h*h) - theta / h\n        A_theta[m_full - 1, m_full - 1] = beta + 1.0/(h*h) + theta / h\n        \n        A_theta_inv = inv(A_theta)\n\n        M_Rb_inv = np.zeros((N, N))\n        \n        idx_A_full = slice(0, m_full)\n        idx_B_full_start = N // 2 - o\n        idx_B_full = slice(idx_B_full_start, idx_B_full_start + m_full)\n        \n        M_Rb_inv[idx_A_full, idx_A_full] += A_theta_inv\n        M_Rb_inv[idx_B_full, idx_B_full] += A_theta_inv\n        \n        # 3.1 Compute spectral radius for M_Rb\n        E_Rb = identity_N - M_Rb_inv @ A\n        rho_Rb = np.max(np.abs(np.linalg.eigvals(E_Rb)))\n        results.append(rho_Rb)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}