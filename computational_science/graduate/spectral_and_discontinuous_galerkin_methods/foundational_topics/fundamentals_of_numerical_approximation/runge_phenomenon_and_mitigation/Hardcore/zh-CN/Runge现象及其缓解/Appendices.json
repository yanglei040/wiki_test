{
    "hands_on_practices": [
        {
            "introduction": "本练习将深入探讨应对龙格现象最有效的经典方法之一：切比雪夫节点。我们将探索这些节点如何从一个简单的角空间均匀网格推导出来，并直观地理解为何它们在区间端点的特有聚集性能够稳定多项式插值。通过这个练习 ，你将把几何直觉与代数性质联系起来，从而巩固对谱方法稳定性的理解。",
            "id": "3413813",
            "problem": "考虑在区间 $[-1,1]$ 上的间断伽辽金（DG）方法中，使用切比雪夫多项式构成的谱元基进行多项式插值。角度必须以弧度为单位。\n\n1. 从第一类切比雪夫多项式的定义关系 $T_{k}(x) = \\cos(k \\arccos x)$ 和变量替换 $x = \\cos \\xi$（其反变换为 $\\xi = \\arccos x$）出发。推导角度变量 $\\xi$ 中的均匀网格（具体为 $\\xi_{j} = j \\pi/n$，其中 $j = 0,1,\\dots,n$）如何变换为 $x$ 中的切比雪夫-洛巴托节点集，即 $x_{j} = \\cos(j \\pi/n)$。在您的推导过程中，使用雅可比导数 $\\mathrm{d}\\xi/\\mathrm{d}x$ 来解释切比雪夫-洛巴托节点的端点聚集现象，以及为什么这种聚集现象能够减轻解析函数 $f$ 的龙格现象。\n\n2. 令 $f(x) = \\frac{1}{1 + 25 x^{2}}$。对于 $n = 6$，构建一个次数至多为 $n$ 的唯一多项式 $p_{n}(x)$，使其在切比雪夫-洛巴托节点 $x_{j} = \\cos(j \\pi/n)$（其中 $j=0,1,\\dots,n$）上插值函数 $f$。在点 $x_{\\star} = \\cos(\\pi/6)$ 處計算 $p_{6}(x)$ 的值，并将结果表示为单个精确的解析表达式。\n\n你的最终答案必须是单个解析表达式。无需进行四舍五入。",
            "solution": "该问题分为两部分。第一部分要求对切比雪夫-洛巴托节点进行推导和解释。第二部分要求构建一个特定的插值多项式并求值。\n\n### 第一部分：切比雪夫-洛巴托节点的推导和解释\n\n给定变量替换 $x = \\cos \\xi$，其中 $x \\in [-1, 1]$，这意味着 $\\xi \\in [0, \\pi]$。其反变换为 $\\xi = \\arccos x$。\n\n角度变量 $\\xi$ 中的均匀网格由点 $\\xi_{j} = \\frac{j \\pi}{n}$（$j = 0, 1, \\dots, n$）定义。将变换 $x = \\cos \\xi$ 应用于这些点，我们得到 $x$ 域中相应的网格点：\n$$\nx_{j} = \\cos(\\xi_{j}) = \\cos\\left(\\frac{j \\pi}{n}\\right) \\quad \\text{其中 } j = 0, 1, \\dots, n.\n$$\n根据定义，这些就是切比雪夫-洛巴托节点。这就完成了从 $\\xi$ 中的均匀网格到 $x$ 中指定节点集的变换推导。\n\n为了解释端点聚集现象，我们考察无穷小区间 $\\mathrm{d}x$ 和 $\\mathrm{d}\\xi$ 之间的关系。反变换 $\\xi(x)$ 的雅可比导数是：\n$$\n\\frac{\\mathrm{d}\\xi}{\\mathrm{d}x} = \\frac{\\mathrm{d}}{\\mathrm{d}x}(\\arccos x) = -\\frac{1}{\\sqrt{1 - x^2}}.\n$$\n该导数的绝对值 $\\left|\\frac{\\mathrm{d}\\xi}{\\mathrm{d}x}\\right| = \\frac{1}{\\sqrt{1 - x^2}}$ 表示 $\\xi$ 中一个区间的长度与 $x$ 中相应区间的长度的局部比率。\n\n$\\xi$ 中的均匀网格意味着恒定的间距 $\\Delta\\xi = \\xi_{j+1} - \\xi_j = \\frac{\\pi}{n}$。而 $x$ 中相应的间距 $\\Delta x_j = x_{j+1} - x_j$ 不是恒定的。我们可以通过 $\\Delta\\xi \\approx \\left|\\frac{\\mathrm{d}\\xi}{\\mathrm{d}x}\\right| |\\Delta x|$ 来关联这些间距。对 $|\\Delta x|$ 进行整理可得：\n$$\n|\\Delta x| \\approx \\left|\\frac{\\mathrm{d}x}{\\mathrm{d}\\xi}\\right| \\Delta\\xi = |\\sin(\\xi)| \\Delta\\xi = \\sqrt{1-x^2} \\Delta\\xi.\n$$\n由于 $\\Delta\\xi$ 是恒定的， $x$ 域中节点之间的间距 $|\\Delta x|$ 与 $\\sqrt{1-x^2}$ 成正比。当 $x$ 趋近于区间的端点 $x \\to \\pm 1$ 时，$\\sqrt{1-x^2}$ 项趋近于 $0$。因此，与区间中心（$x=0$ 处间距最大）相比，端点附近的间距 $|\\Delta x|$ 会变得显著更小。这种在边界处更密集的非均匀间距被称为端点聚集。\n\n这种聚集现象减轻了龙格现象。用一个次数至多为 $n$ 的多项式 $p_n(x)$ 对函数 $f(x)$ 进行多项式插值的误差由下式给出：\n$$\nf(x) - p_n(x) = \\frac{f^{(n+1)}(\\eta_x)}{(n+1)!} \\prod_{j=0}^{n} (x-x_j)\n$$\n对于某个 $\\eta_x \\in [-1, 1]$。龙格现象的特征是在端点附近出现大幅振荡，当使用等距节点时会发生这种情况，因为节点多项式 $\\omega_{n+1}(x) = \\prod_{j=0}^{n} (x-x_j)$ 在区间边界附近的幅值会变得非常大。切比雪夫-洛巴托节点通过两种方式来抵消这种效应。首先，节点聚集在端点附近对多项式施加了更多的约束，从而抑制了在最容易出现大幅振荡处的振荡。其次，与等距节点（其节点多项式 $\\omega_{n+1}(x)$ 在区间边界附近的幅值会指数增长）相比，由切比雪夫-洛巴托节点产生的节点多项式在 $[-1, 1]$ 上的最大幅值要小得多，并以 $O(2^{-n})$ 的速率随 $n$ 衰减。这一性质与切比雪夫节点的勒贝格常数 $\\Lambda_n = O(\\ln n)$ 的缓慢对数增长密切相关，后者保证了当 $n \\to \\infty$ 时，插值多项式 $p_n(x)$ 对任何解析函数 $f(x)$ 都收敛。\n\n### 第二部分：多项式插值与求值\n\n题目要求我们求函数 $f(x) = \\frac{1}{1 + 25 x^2}$ 的插值多项式 $p_6(x)$ 在点 $x_{\\star} = \\cos(\\pi/6)$ 处的值。多项式 $p_6(x)$ 的次数至多为 $n=6$，并在 $n+1=7$ 个切比雪夫-洛巴托节点上插值函数 $f(x)$。\n\n插值节点由 $x_j = \\cos(j \\pi/n)$ 给出，其中 $n=6$ 且 $j = 0, 1, \\dots, 6$。我们列出这些节点：\n- $x_0 = \\cos(0\\pi/6) = \\cos(0) = 1$\n- $x_1 = \\cos(1\\pi/6) = \\cos(\\pi/6) = \\frac{\\sqrt{3}}{2}$\n- $x_2 = \\cos(2\\pi/6) = \\cos(\\pi/3) = \\frac{1}{2}$\n- $x_3 = \\cos(3\\pi/6) = \\cos(\\pi/2) = 0$\n- $x_4 = \\cos(4\\pi/6) = \\cos(2\\pi/3) = -\\frac{1}{2}$\n- $x_5 = \\cos(5\\pi/6) = -\\frac{\\sqrt{3}}{2}$\n- $x_6 = \\cos(6\\pi/6) = \\cos(\\pi) = -1$\n\n我们必须求多项式值的点是 $x_{\\star} = \\cos(\\pi/6)$。通过与节点列表直接比较，我们观察到该求值点是插值节点之一：\n$$\nx_{\\star} = x_1 = \\frac{\\sqrt{3}}{2}.\n$$\n根据插值多项式的定义，它在任何一个插值节点上的值必须等于原函数在同一点的值。也就是说，对于一个次数至多为 $n$ 的唯一多项式 $p_n(x)$，它在 $n+1$ 个不同节点 $\\{x_j\\}_{j=0}^n$ 上插值函数 $f(x)$，那么它必须满足以下条件：\n$$\np_n(x_j) = f(x_j) \\quad \\text{对所有 } j = 0, 1, \\dots, n.\n$$\n在我们的例子中，$n=6$，我们有 $p_6(x_j) = f(x_j)$，其中 $j=0, \\dots, 6$。由于我们的求值点 $x_\\star$ 是节点 $x_1$，那么多项式的值就是函数在该节点的值：\n$$\np_6(x_{\\star}) = p_6(x_1) = f(x_1).\n$$\n因此，任务简化为计算函数 $f(x)$ 在 $x = x_1 = \\frac{\\sqrt{3}}{2}$ 处的值。\n$$\nf\\left(\\frac{\\sqrt{3}}{2}\\right) = \\frac{1}{1 + 25 \\left(\\frac{\\sqrt{3}}{2}\\right)^2} = \\frac{1}{1 + 25 \\left(\\frac{3}{4}\\right)} = \\frac{1}{1 + \\frac{75}{4}}.\n$$\n为简化此表达式，我们在分母部分通分：\n$$\nf\\left(\\frac{\\sqrt{3}}{2}\\right) = \\frac{1}{\\frac{4}{4} + \\frac{75}{4}} = \\frac{1}{\\frac{4+75}{4}} = \\frac{1}{\\frac{79}{4}}.\n$$\n将分数取倒数得到最终结果：\n$$\np_6(\\cos(\\pi/6)) = \\frac{4}{79}.\n$$\n这就是精确的解析值。无需在单项式基或任何其他基中显式地构建多项式 $p_6(x)$ 的完整表达式，因为其在指定点的值由插值条件直接确定。",
            "answer": "$$\\boxed{\\frac{4}{79}}$$"
        },
        {
            "introduction": "理论理解固然重要，但通过数值实验来亲眼验证概念能让认识更加深刻。这个实践  将指导你进行一个数值实验，通过测量不同插值格式对数据微小扰动的放大效应，来量化它们的稳定性。你将直接比较等距节点的臭名昭著的不稳定性与切比雪夫节点和分片多项式方法的稳健性。",
            "id": "3413836",
            "problem": "要求您研究谱方法和间断伽辽金方法中与多项式重构相关的灵敏度放大问题，重点关注区间端点附近的龙格现象。考虑在区间 $[-1,1]$ 上基于不同节点集构建的节点插值算子。对于给定的节点集 $\\{x_j\\}_{j=0}^{N}$ 及其相关的重心拉格朗日基函数 $\\{\\ell_j(x)\\}_{j=0}^{N}$，从节点数据 $\\{y_j\\}$ 在点 $x$ 处的重构为 $u_p(x)=\\sum_{j=0}^{N} \\ell_j(x)\\,y_j$。假设节点数据 $\\{y_j\\}$ 受到均值为零、方差为 $\\sigma^2$ 的加性独立同分布扰动的污染。点 $x$ 处的放大因子定义为重构值 $u_p(x)$ 的标准差与节点扰动标准差 $\\sigma$ 的比值，它量化了插值算子在点 $x$ 处对噪声的放大程度。\n\n使用以下基本原理：\n- 节点拉格朗日基满足 $\\ell_j(x_k)=\\delta_{jk}$ 且对于所有 $x\\in[-1,1]$ 都有 $\\sum_{j=0}^{N}\\ell_j(x)=1$。\n- 重心插值公式将 $u_p(x)$ 表示为数据 $\\{y_j\\}$ 的线性组合，因此扰动线性传播到重构中。\n- 对于方差为 $\\sigma^2$ 的独立同分布输入，在线性算子（其系数为 $\\{\\phi_j(x)\\}$）作用下的输出方差等于 $\\sigma^2\\sum_{j}\\phi_j(x)^2$。\n\n您的任务：\n1. 对于 $[-1,1]$ 上的全局插值，构建三个节点集：\n   - 等距节点：$x_j=-1+\\dfrac{2j}{N}$，其中 $j=0,1,\\dots,N$。\n   - 切比雪夫-洛巴托节点：$x_j=\\cos\\!\\left(\\dfrac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$。\n   - 在 $K$ 个均匀单元上的分片“间断伽辽金风格”重构：将 $[-1,1]$ 剖分为 $K$ 个子区间，并在每个单元上使用阶为 $p$ 的局部切比雪夫-洛巴托节点（即每个单元 $p+1$ 个节点）。全局重构在每个单元上由相应的局部节点插值局部定义，单元之间没有任何连续性约束。\n\n2. 对于每种重构，在 $[-1,1]$ 上的一个包含 $M$ 个点的均匀网格（包括端点）上计算放大因子 $A(x)$，其中 $A(x)$ 定义为 $A(x)=\\dfrac{\\sigma(u_p(x))}{\\sigma}$，而 $\\sigma(u_p(x))$ 是在方差为 $\\sigma^2$ 的独立同分布节点扰动下，重构值在 $x$ 处的标准差。利用以下事实：由于线性和独立性，$A(x)$ 等于插值形函数向量 $\\{\\ell_j(x)\\}$ 在 $x$ 处的欧几里得范数。\n\n3. 通过计算在网格上评估的 $A(x)$ 的以下标量度量，来量化端点灵敏度峰值：\n   - $A_{\\max}=\\max_{x\\in[-1,1]} A(x)$,\n   - $A_{\\text{bdry}}=\\max_{x:\\,|x|\\ge \\alpha} A(x)$，其中 $\\alpha=0.95$,\n   - $A_{\\text{ctr}}=\\max_{x:\\,|x|\\le \\beta} A(x)$，其中 $\\beta=0.5$,\n   - 比率 $R=\\dfrac{A_{\\text{bdry}}}{A_{\\text{ctr}}}$。\n\n4. 使用重心拉格朗日公式实现计算。对于切比雪夫-洛巴托节点，使用已知的稳定重心权重。对于等距节点和局部单元节点，您可以直接从节点乘积计算权重。通过强制 $\\ell_j(x)=1$ 和 $\\ell_{k\\neq j}(x)=0$ 来精确处理 $x=x_j$ 的情况。\n\n5. 提供以下参数选择的测试套件：\n   - 测试用例1：在等距节点上进行全局插值，阶数为 $N=20$，评估网格大小为 $M=1001$。\n   - 测试用例2：在切比雪夫-洛巴托节点上进行全局插值，阶数为 $N=20$，评估网格大小为 $M=1001$。\n   - 测试用例3：分片重构，包含 $K=10$ 个单元，局部阶数为 $p=3$（局部切比雪夫-洛巴托节点），评估网格大小为 $M=1001$。\n   - 测试用例4：在等距节点上进行全局插值，低阶 $N=2$，评估网格大小为 $M=1001$。\n\n6. 对于每个测试用例，输出一个包含四个浮点数的列表 $[A_{\\max},A_{\\text{bdry}},A_{\\text{ctr}},R]$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个列表。例如，输出格式应为 $[[a_{11},a_{12},a_{13},a_{14}],[a_{21},a_{22},a_{23},a_{24}],\\dots]$，所有条目均为十进制数。\n\n本任务不涉及物理单位。角度必须以弧度为单位。所有返回值必须是不带百分号的普通十进制数。您的程序必须是自包含的，不需要任何输入，并且确定性地计算所要求的量。",
            "solution": "我们从节点多项式插值和独立同分布噪声通过线性映射的线性传播的基本定义开始。设 $\\{x_j\\}_{j=0}^{N}\\subset[-1,1]$ 为互异节点。节点拉格朗日基函数 $\\{\\ell_j(x)\\}_{j=0}^{N}$ 由条件 $\\ell_j(x_k)=\\delta_{jk}$ 定义，并且它们构成单位分解 $\\sum_{j=0}^{N}\\ell_j(x)=1$（对于所有 $x\\in[-1,1]$）。次数至多为 $N$ 的节点插值多项式为 $u_p(x)=\\sum_{j=0}^{N}\\ell_j(x)\\,y_j$。\n\n重心插值公式以数值稳定的形式实现 $u_p(x)$。如果 $w_j$ 是与 $\\{x_j\\}$ 兼容的重心权重，那么对于 $x\\neq x_j$，\n$$\nu_p(x)=\\frac{\\sum_{j=0}^{N}\\dfrac{w_j}{x-x_j}\\,y_j}{\\sum_{j=0}^{N}\\dfrac{w_j}{x-x_j}},\n$$\n并且在 $x=x_j$ 处，$u_p(x)=y_j$。重要的是，这表明 $u_p(x)$ 是数据 $\\{y_j\\}$ 的一个线性泛函：\n$$\nu_p(x) = \\sum_{j=0}^{N} \\phi_j(x)\\,y_j,\\quad \\text{其中}\\quad \\phi_j(x) = \\begin{cases}\n\\dfrac{w_j/(x-x_j)}{\\sum_{k=0}^{N} w_k/(x-x_k)},  x\\neq x_j,\\\\\n1,  x=x_j\\ \\text{且索引等于}\\ j,\\\\\n0,  x=x_j\\ \\text{且索引不等于}\\ j.\n\\end{cases}\n$$\n系数 $\\{\\phi_j(x)\\}$ 是拉格朗日基函数 $\\{\\ell_j(x)\\}$ 在 $x$ 处的值。\n\n考虑数据上的加性独立同分布扰动 $y_j = \\bar{y}_j + \\varepsilon_j$，其中 $\\mathbb{E}[\\varepsilon_j]=0$ 且 $\\operatorname{Var}(\\varepsilon_j)=\\sigma^2$，并且扰动关于下标 $j$ 独立。通过线性映射的传播得到\n$$\nu_p(x) = \\sum_{j=0}^{N} \\phi_j(x)\\,\\bar{y}_j + \\sum_{j=0}^{N} \\phi_j(x)\\,\\varepsilon_j.\n$$\n因此，由扰动引起的 $u_p(x)$ 的方差是\n$$\n\\operatorname{Var}(u_p(x)) = \\mathbb{E}\\Big[\\Big(\\sum_{j=0}^{N} \\phi_j(x)\\,\\varepsilon_j\\Big)^2\\Big] = \\sum_{j=0}^{N}\\phi_j(x)^2\\,\\operatorname{Var}(\\varepsilon_j) = \\sigma^2 \\sum_{j=0}^{N}\\phi_j(x)^2,\n$$\n其中我们使用了独立性和等方差的性质。因此，放大因子（定义为输出标准差与输入标准差之比）是\n$$\nA(x) = \\frac{\\sigma(u_p(x))}{\\sigma} = \\sqrt{\\sum_{j=0}^{N}\\phi_j(x)^2}.\n$$\n因此，$A(x)$ 等于形函数向量 $\\{\\ell_j(x)\\}$ 在 $x$ 处取值后的欧几里得范数。\n\n我们现在描述节点构造方法和相应的重心权重：\n- 对于等距节点 $x_j=-1+\\dfrac{2j}{N}$，通用重心权重可取为 $w_j = \\left(\\prod_{k\\neq j}(x_j-x_k)\\right)^{-1}$；它们在一个非零标量因子内是唯一的，该因子在重心公式和 $\\{\\phi_j(x)\\}$ 的计算中会被约掉。\n- 对于切比雪夫-洛巴托节点 $x_j = \\cos\\!\\left(\\dfrac{\\pi j}{N}\\right)$，其数值稳定的权重有已知的闭式形式，$w_j = (-1)^j c_j$ 其中 $c_0=c_N=\\tfrac{1}{2}$ 且 $c_j=1$ 对于 $j=1,\\dots,N-1$。对这些权重的任何非零常数缩放都使 $\\{\\phi_j(x)\\}$ 保持不变。\n- 对于分片“间断伽辽金风格”的重构，将 $[-1,1]$ 剖分为 $K$ 个等长单元。在每个单元上，我们放置阶为 $p$ 的局部切比雪夫-洛巴托节点，即通过将参考区间 $[-1,1]$ 上的 $\\{\\cos(\\pi i/p)\\}_{i=0}^{p}$ 映射到该单元上得到的 $p+1$ 个节点。点 $x$ 处的重构仅使用该点所在局部单元的节点数据，通过局部重心公式计算。因为从完整节点数据集到 $u_p(x)$ 的映射是块局部的，所以相应的形函数向量 $\\{\\phi_j(x)\\}$ 仅在包含 $x$ 的单元上的节点处有非零项。\n\n对于每个测试用例，我们在 $[-1,1]$ 内的一个包含 $M$ 个点的均匀网格（包括端点）上评估 $A(x)$。然后我们计算以下标量：\n- $A_{\\max}=\\max_{x\\in[-1,1]} A(x)$,\n- $A_{\\text{bdry}}=\\max_{|x|\\ge \\alpha} A(x)$，其中 $\\alpha=0.95$,\n- $A_{\\text{ctr}}=\\max_{|x|\\le \\beta} A(x)$，其中 $\\beta=0.5$,\n- $R=\\dfrac{A_{\\text{bdry}}}{A_{\\text{ctr}}}$。\n\n关于龙格现象的解释：对于等距节点上的全局插值，随着阶数的增长，龙格现象表现为端点附近的大幅振荡和高灵敏度。放大因子 $A(x)$ 直接捕捉了对扰动的灵敏度；$A(x)$ 在 $x=\\pm 1$ 附近的峰值表明了剧烈的放大效应，并与等距节点的勒贝格常数的增长密切相关。切比雪夫-洛巴托节点可以减缓这种增长，从而减少端点峰值。另一种稳健的方法是使用分片低阶插值，如间断伽辽金方法；局部性使得 $A(x)$ 在整个区间（包括端点附近）上保持一致有界。\n\n算法设计：\n1. 为每种配置构建节点和重心权重。\n2. 在 $[-1,1]$ 中构建一个包含 M 个等距点的评估网格。\n3. 对每个评估点 $x$：\n   - 如果 $x$ 与某个节点重合（在严格容差范围内），则将相应的形向量设置为单位选择向量。\n   - 否则，计算重心系数 $\\{\\phi_j(x)\\}$，对于分片情况，则进行全局或局部单元计算。\n   - 计算 $A(x)=\\sqrt{\\sum_j \\phi_j(x)^2}$。\n4. 从网格上的离散 $A(x)$ 值计算 $A_{\\max}$、$A_{\\text{bdry}}$、$A_{\\text{ctr}}$ 和 $R$。\n5. 为测试套件重复以上步骤：\n   - 测试用例1：全局等距节点，$N=20$，$M=1001$。\n   - 测试用例2：全局切比雪夫-洛巴托节点，$N=20$，$M=1001$。\n   - 测试用例3：分片重构，包含 $K=10$ 个单元，局部阶数 $p=3$（局部切比雪夫-洛巴托节点），$M=1001$。\n   - 测试用例4：全局等距节点，低阶 $N=2$，$M=1001$。\n6. 输出单行：一个由四元列表组成的列表 $[A_{\\max},A_{\\text{bdry}},A_{\\text{ctr}},R]$，用于每个测试用例。\n\n通过比较不同测试用例的 $R$ 值，可以识别出端点附近的灵敏度峰值。我们预计，对于 $N=20$ 的全局等距节点，其 $R$ 值会很大；切比雪夫-洛巴托节点会大幅减小 $R$ 值；而分片重构会使 $R$ 值接近于1。低阶等距节点情况下的 $R$ 值也应该是适度的。这些观察启发我们采用稳健的拟合策略，例如使用切比雪夫-洛巴托节点进行全局插值，或采用间断伽辽金方法中典型的分片低阶重构来缓解龙格现象。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef equispaced_nodes(N: int) -> np.ndarray:\n    # N+1 nodes on [-1,1]\n    return np.linspace(-1.0, 1.0, N + 1)\n\ndef chebyshev_lobatto_nodes(N: int) -> np.ndarray:\n    # x_j = cos(pi*j/N), j=0..N\n    j = np.arange(N + 1)\n    return np.cos(np.pi * j / N)\n\ndef bary_weights_generic(nodes: np.ndarray) -> np.ndarray:\n    # Compute generic barycentric weights w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # This is O(n^2) and acceptable for moderate N.\n    n = nodes.size\n    w = np.empty(n, dtype=float)\n    for j in range(n):\n        diffs = nodes[j] - np.delete(nodes, j)\n        prod = np.prod(diffs)\n        w[j] = 1.0 / prod\n    return w\n\ndef bary_weights_cheb_lobatto(N: int) -> np.ndarray:\n    # Stable weights for Chebyshev-Lobatto nodes: w_j = (-1)^j * c_j with c_0=c_N=1/2, else 1\n    j = np.arange(N + 1)\n    w = (-1.0) ** j\n    if N >= 1:\n        w[0] *= 0.5\n        w[-1] *= 0.5\n    return w\n\ndef barycentric_phi_matrix(x_eval: np.ndarray, nodes: np.ndarray, weights: np.ndarray, tol: float = 1e-14) -> np.ndarray:\n    # Compute the matrix Phi where Phi[i,j] = phi_j(x_eval[i])\n    # Handle x equal to nodes by one-hot rows.\n    x_eval = np.asarray(x_eval)\n    nodes = np.asarray(nodes)\n    weights = np.asarray(weights)\n    m = x_eval.size\n    n = nodes.size\n    Phi = np.zeros((m, n), dtype=float)\n\n    # For vectorized computation, we will process rows where x does not coincide with any node\n    # First, detect coincidences\n    # Use broadcasting to compute |x - nodes| and check for small values\n    diff = np.abs(x_eval[:, None] - nodes[None, :])\n    row_has_hit = np.any(diff <= tol, axis=1)\n    # For rows with a hit, set one-hot\n    hit_rows = np.where(row_has_hit)[0]\n    for i in hit_rows:\n        j_hit = np.where(diff[i, :] <= tol)[0]\n        # In rare cases of multiple matches due to tolerance, pick the closest\n        if j_hit.size > 1:\n            j_closest = j_hit[np.argmin(diff[i, j_hit])]\n            j_hit = np.array([j_closest], dtype=int)\n        Phi[i, j_hit[0]] = 1.0\n\n    # For rows without hit, compute barycentric coefficients\n    reg_rows = np.where(~row_has_hit)[0]\n    if reg_rows.size > 0:\n        xx = x_eval[reg_rows][:, None]  # shape (mr,1)\n        T = 1.0 / (xx - nodes[None, :])  # shape (mr,n)\n        WT = weights[None, :] * T\n        denom = np.sum(WT, axis=1)  # shape (mr,)\n        # Avoid division by zero; denom should not be zero for valid weights/nodes\n        Phi_reg = WT / denom[:, None]\n        Phi[reg_rows, :] = Phi_reg\n\n    return Phi\n\ndef amplification_from_phi(Phi: np.ndarray) -> np.ndarray:\n    # A(x) = sqrt(sum_j phi_j(x)^2)\n    return np.sqrt(np.sum(Phi * Phi, axis=1))\n\ndef piecewise_dg_phi_matrix(x_eval: np.ndarray, K: int, p: int) -> np.ndarray:\n    # Build piecewise Chebyshev-Lobatto local interpolation on K uniform elements, degree p per element.\n    # Global nodes are discontinuous across elements; total nodes = K*(p+1).\n    # The mapping is block-local: for x in element e, only the local (p+1) nodes contribute.\n    m = x_eval.size\n    # Element boundaries\n    edges = np.linspace(-1.0, 1.0, K + 1)\n    h = edges[1] - edges[0]\n    # Build global nodes (for completeness, but we need only Phi)\n    total_nodes = K * (p + 1)\n    Phi = np.zeros((m, total_nodes), dtype=float)\n\n    # Precompute local reference nodes and weights for Chebyshev-Lobatto of degree p\n    if p == 0:\n        r_ref = np.array([0.0])\n        w_ref = np.array([1.0])\n    else:\n        r_ref = np.cos(np.pi * np.arange(p + 1) / p)\n        # Stable weights for Chebyshev-Lobatto on reference\n        w_ref = bary_weights_cheb_lobatto(p)\n\n    # For each evaluation point, find its element and compute local phi, then place into global Phi\n    # Determine element indices: e in {0, ..., K-1}\n    # Map x to element by index e = floor((x - (-1))/h), clamp to [0, K-1]; special case for x=1 assign last element.\n    t = (x_eval - (-1.0)) / h\n    e_idx = np.floor(t).astype(int)\n    e_idx = np.clip(e_idx, 0, K - 1)\n    # Correct those exactly at the rightmost boundary to last element\n    rightmost = np.isclose(x_eval, 1.0, atol=1e-14)\n    e_idx[rightmost] = K - 1\n\n    # Process each element's evaluation points in batch for efficiency\n    for e in range(K):\n        mask = (e_idx == e)\n        if not np.any(mask):\n            continue\n        x_local = x_eval[mask]\n        # Element bounds\n        xl = edges[e]\n        xr = edges[e + 1]\n        # Affine mapping from reference r in [-1,1] to physical x: x = 0.5*(xr+xl) + 0.5*(xr-xl)*r\n        # Inverse mapping r = (2*(x - 0.5*(xr+xl))) / (xr - xl)\n        r = (2.0 * (x_local - 0.5 * (xr + xl))) / (xr - xl)\n\n        # Compute local phi on reference nodes\n        Phi_loc = barycentric_phi_matrix(r, r_ref, w_ref)\n\n        # Insert into global Phi at the block corresponding to element e\n        col_start = e * (p + 1)\n        col_end = col_start + (p + 1)\n        Phi[np.where(mask)[0][:, None], np.arange(col_start, col_end)[None, :]] = Phi_loc\n\n    return Phi\n\ndef compute_metrics_from_A(x_eval: np.ndarray, A: np.ndarray, alpha: float = 0.95, beta: float = 0.5):\n    # Compute A_max, A_bdry (|x|>=alpha), A_ctr (|x|<=beta), ratio\n    A_max = float(np.max(A))\n    bdry_mask = np.abs(x_eval) >= alpha\n    ctr_mask = np.abs(x_eval) <= beta\n    A_bdry = float(np.max(A[bdry_mask])) if np.any(bdry_mask) else float('nan')\n    A_ctr = float(np.max(A[ctr_mask])) if np.any(ctr_mask) else float('nan')\n    R = float(A_bdry / A_ctr) if (A_ctr != 0.0 and np.isfinite(A_bdry) and np.isfinite(A_ctr)) else float('nan')\n    return [A_max, A_bdry, A_ctr, R]\n\ndef run_test_cases():\n    results = []\n\n    # Common evaluation grid size\n    M = 1001\n    x_eval = np.linspace(-1.0, 1.0, M)\n\n    # Test case 1: Global equispaced nodes, N=20\n    N1 = 20\n    nodes1 = equispaced_nodes(N1)\n    w1 = bary_weights_generic(nodes1)\n    Phi1 = barycentric_phi_matrix(x_eval, nodes1, w1)\n    A1 = amplification_from_phi(Phi1)\n    metrics1 = compute_metrics_from_A(x_eval, A1, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics1])\n\n    # Test case 2: Global Chebyshev-Lobatto nodes, N=20\n    N2 = 20\n    nodes2 = chebyshev_lobatto_nodes(N2)\n    w2 = bary_weights_cheb_lobatto(N2)\n    Phi2 = barycentric_phi_matrix(x_eval, nodes2, w2)\n    A2 = amplification_from_phi(Phi2)\n    metrics2 = compute_metrics_from_A(x_eval, A2, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics2])\n\n    # Test case 3: Piecewise DG-style, K=10 elements, local degree p=3\n    K3 = 10\n    p3 = 3\n    Phi3 = piecewise_dg_phi_matrix(x_eval, K=K3, p=p3)\n    A3 = amplification_from_phi(Phi3)\n    metrics3 = compute_metrics_from_A(x_eval, A3, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics3])\n\n    # Test case 4: Global equispaced nodes, low degree N=2\n    N4 = 2\n    nodes4 = equispaced_nodes(N4)\n    w4 = bary_weights_generic(nodes4)\n    Phi4 = barycentric_phi_matrix(x_eval, nodes4, w4)\n    A4 = amplification_from_phi(Phi4)\n    metrics4 = compute_metrics_from_A(x_eval, A4, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics4])\n\n    return results\n\ndef solve():\n    results = run_test_cases()\n    # Final print statement in the exact required format.\n    # Print a single line: list of lists with 4 floats each.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了精心选择节点外，我们还可以通过直接约束逼近多项式的行为来抑制振荡。本练习  探讨的就是这样一种策略，我们通过在端点施加零斜率的约束来抑制虚假的过冲。这种方法引出了一个关键的权衡：在强制施加期望的性质与保持逼近的高阶精度之间需要做出选择。",
            "id": "3413852",
            "problem": "考虑在区间 $[-1,1]$ 上关于标准勒贝格测度的最小二乘逼近。设 $f(x) = \\frac{1}{1+\\kappa^{2} x^{2}}$，其中 $\\kappa > 0$ 为一个固定参数。为了减轻全局多项式逼近中与龙格（Runge）现象相关的端点过冲问题，我们在右端点施加一个斜率钳位约束，以抑制 $x=1$ 附近的振荡。\n\n定义约束最小二乘问题：求一个次数 $\\leq 2$ 的多项式 $p \\in \\mathbb{P}_{2}$，使其最小化\n$$\n\\int_{-1}^{1} \\bigl(f(x) - p(x)\\bigr)^{2} \\, dx\n$$\n并满足端点条件 $p'(1)=0$。此处 $\\mathbb{P}_{2}$ 由勒让德（Legendre）多项式 $\\{P_{0}(x),P_{1}(x),P_{2}(x)\\}$ 张成，其中 $P_{0}(x)=1$，$P_{1}(x)=x$，$P_{2}(x)=\\frac{1}{2}(3x^{2}-1)$。\n\n从勒让德多项式的正交性和最小二乘投影的定义出发，推导约束极小化子，其形式为\n$$\np(x) \\;=\\; \\alpha_{0} P_{0}(x) \\;+\\; \\beta \\bigl(P_{2}(x) - 3 P_{1}(x)\\bigr),\n$$\n并获得系数 $\\beta$ 作为 $\\kappa$ 函数的闭式解析表达式。\n\n然后，基于凸优化和正交投影的基本原理，简要分析约束 $p'(1)=0$ 的可行性，并解释对于解析目标函数 $f$，施加固定有限数量的此类线性端点约束（与多项式次数无关）是否会改变关于 $N$ 的渐近谱精度。你的推理必须从 $L^{2}$-投影和正交多项式基的标准性质出发，并且不得假定任何预先推导的约束投影公式。\n\n请给出 $\\beta(\\kappa)$ 的显式解析表达式作为最终答案。不需要进行数值计算，也不允许四舍五入。请仅使用 $\\kappa$ 的初等函数，以其最简精确形式表示最终答案。",
            "solution": "该问题要求确定一个约束多项式逼近并分析此类约束。我们首先验证问题的有效性，然后进行求解。\n\n### 问题验证\n该问题是适定的。它涉及在有限维空间 $\\mathbb{P}_2$ 中寻找一个多项式 $p(x)$，该多项式在一个线性约束条件下，最小化一个严格凸的泛函，即 $L^2$-范数的平方误差。这是一个标准的约束二次优化问题，保证了解的存在性和唯一性。函数 $f(x)$ 是逼近论中使用的经典例子（龙格函数）。在 $[-1, 1]$ 上使用勒让德多项式进行最小二乘逼近是标准做法。所提出的问题是精确的，并基于数值分析和逼近论中已建立的数学原理。所有必要的数据和定义均已提供。因此，该问题是有效的。\n\n### 约束极小化子的推导\n设多项式 $p(x) \\in \\mathbb{P}_{2}$ 在勒让德多项式基中表示为：\n$$\np(x) = c_{0} P_{0}(x) + c_{1} P_{1}(x) + c_{2} P_{2}(x)\n$$\n其中 $P_{0}(x)=1$，$P_{1}(x)=x$，$P_{2}(x)=\\frac{1}{2}(3x^2-1)$。系数 $c_0, c_1, c_2$ 是待确定的实常数。\n\n问题对 $p(x)$ 在端点 $x=1$ 处的导数施加了一个约束：\n$$\np'(1) = 0\n$$\n$p(x)$ 的导数是：\n$$\np'(x) = c_{0} P_{0}'(x) + c_{1} P_{1}'(x) + c_{2} P_{2}'(x)\n$$\n使用给定的形式，我们求得导数：$P_{0}'(x)=0$，$P_{1}'(x)=1$，$P_{2}'(x) = \\frac{1}{2}(6x) = 3x$。\n在 $x=1$ 处求值：$P_{0}'(1)=0$，$P_{1}'(1)=1$，$P_{2}'(1)=3$。\n约束方程变为：\n$$\np'(1) = c_{1}(1) + c_{2}(3) = c_{1} + 3c_{2} = 0\n$$\n这给出了系数之间的线性关系：$c_{1} = -3c_{2}$。\n\n将此关系代回 $p(x)$ 的表达式中：\n$$\np(x) = c_{0} P_{0}(x) + (-3c_{2}) P_{1}(x) + c_{2} P_{2}(x) = c_{0} P_{0}(x) + c_{2} \\bigl(P_{2}(x) - 3P_{1}(x)\\bigr)\n$$\n通过辨识 $\\alpha_0 = c_0$ 和 $\\beta=c_2$，此表达式与目标形式 $p(x) = \\alpha_{0} P_{0}(x) + \\beta \\bigl(P_{2}(x) - 3 P_{1}(x)\\bigr)$ 相匹配。\n现在问题变为求使泛函...最小化的系数 $c_0, c_2$。\n$$\nJ(c_{0}, c_{2}) = \\int_{-1}^{1} \\Biggl(f(x) - \\Bigl(c_{0} P_{0}(x) + c_{2} \\bigl(P_{2}(x) - 3P_{1}(x)\\bigr)\\Bigr) \\Biggr)^{2} \\, dx\n$$\n这是一个标准的最小二乘问题，其解法是将函数 $f(x)$ 投影到由基函数 $\\psi_{0}(x) = P_{0}(x)$ 和 $\\psi_{1}(x) = P_{2}(x) - 3P_{1}(x)$ 张成的 $\\mathbb{P}_2$ 子空间上。系数的法方程为：\n$$\n\\begin{pmatrix} \\langle \\psi_{0}, \\psi_{0} \\rangle  \\langle \\psi_{0}, \\psi_{1} \\rangle \\\\ \\langle \\psi_{1}, \\psi_{0} \\rangle  \\langle \\psi_{1}, \\psi_{1} \\rangle \\end{pmatrix} \\begin{pmatrix} c_{0} \\\\ c_{2} \\end{pmatrix} = \\begin{pmatrix} \\langle f, \\psi_{0} \\rangle \\\\ \\langle f, \\psi_{1} \\rangle \\end{pmatrix}\n$$\n其中 $\\langle g, h \\rangle = \\int_{-1}^{1} g(x)h(x) \\, dx$ 是 $[-1,1]$ 上的标准 $L^2$ 内积。\n\n我们利用勒让德多项式的正交性：$\\langle P_j, P_k \\rangle = \\frac{2}{2k+1} \\delta_{jk}$。\n格拉姆（Gram）矩阵的非对角项为：\n$$\n\\langle \\psi_{0}, \\psi_{1} \\rangle = \\langle P_{0}, P_{2} - 3P_{1} \\rangle = \\langle P_{0}, P_{2} \\rangle - 3 \\langle P_{0}, P_{1} \\rangle = 0 - 3(0) = 0\n$$\n由于基 $\\{\\psi_0, \\psi_1\\}$ 是正交的，格拉姆矩阵是对角的，系数的方程解耦为：\n$$\nc_{0} \\langle \\psi_{0}, \\psi_{0} \\rangle = \\langle f, P_{0} \\rangle \\implies c_{0} = \\frac{\\langle f, P_{0} \\rangle}{\\langle P_{0}, P_{0} \\rangle}\n$$\n$$\nc_{2} \\langle \\psi_{1}, \\psi_{1} \\rangle = \\langle f, \\psi_{1} \\rangle \\implies c_{2} = \\beta = \\frac{\\langle f, P_{2} - 3P_{1} \\rangle}{\\langle P_{2} - 3P_{1}, P_{2} - 3P_{1} \\rangle}\n$$\n我们需要计算 $\\beta$ 表达式中的各项。\n\n分母是：\n$$\n\\langle P_{2} - 3P_{1}, P_{2} - 3P_{1} \\rangle = \\langle P_{2}, P_{2} \\rangle - 6 \\langle P_{2}, P_{1} \\rangle + 9 \\langle P_{1}, P_{1} \\rangle\n$$\n利用正交性，$\\langle P_{2}, P_{1} \\rangle = 0$。使用范数公式，$\\langle P_{k}, P_{k} \\rangle = \\frac{2}{2k+1}$：\n$$\n\\langle P_{2}, P_{2} \\rangle = \\frac{2}{2(2)+1} = \\frac{2}{5} \\quad \\text{和} \\quad \\langle P_{1}, P_{1} \\rangle = \\frac{2}{2(1)+1} = \\frac{2}{3}\n$$\n所以，分母是 $\\frac{2}{5} + 9 \\left(\\frac{2}{3}\\right) = \\frac{2}{5} + 6 = \\frac{32}{5}$。\n\n分子是：\n$$\n\\langle f, P_{2} - 3P_{1} \\rangle = \\langle f, P_{2} \\rangle - 3 \\langle f, P_{1} \\rangle\n$$\n函数 $f(x) = \\frac{1}{1+\\kappa^2 x^2}$ 是关于 $x$ 的偶函数。多项式 $P_{1}(x)=x$ 是奇函数。因此，乘积 $f(x)P_{1}(x)$ 是奇函数，其在对称区间 $[-1, 1]$ 上的积分为零：\n$$\n\\langle f, P_{1} \\rangle = \\int_{-1}^{1} \\frac{x}{1+\\kappa^2 x^2} \\, dx = 0\n$$\n因此，分子简化为 $\\langle f, P_{2} \\rangle$：\n$$\n\\langle f, P_{2} \\rangle = \\int_{-1}^{1} \\frac{1}{1+\\kappa^2 x^2} \\cdot \\frac{1}{2}(3x^2-1) \\, dx\n$$\n被积函数是偶函数，所以我们可以将积分写为：\n$$\n\\langle f, P_{2} \\rangle = 2 \\int_{0}^{1} \\frac{3x^2-1}{2(1+\\kappa^2 x^2)} \\, dx = \\int_{0}^{1} \\frac{3x^2-1}{1+\\kappa^2 x^2} \\, dx\n$$\n我们分解被积函数：\n$$\n\\frac{3x^2-1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2}\\frac{\\kappa^2 x^2}{1+\\kappa^2 x^2} - \\frac{1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2}\\frac{1+\\kappa^2 x^2-1}{1+\\kappa^2 x^2} - \\frac{1}{1+\\kappa^2 x^2}\n$$\n$$\n= \\frac{3}{\\kappa^2}\\left(1 - \\frac{1}{1+\\kappa^2 x^2}\\right) - \\frac{1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2} - \\left(\\frac{3}{\\kappa^2} + 1\\right)\\frac{1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^2}\\frac{1}{1+\\kappa^2 x^2}\n$$\n从 $0$ 到 $1$ 积分：\n$$\n\\int_{0}^{1} \\left( \\frac{3}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^2}\\frac{1}{1+\\kappa^2 x^2} \\right) dx = \\left[ \\frac{3x}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^2} \\frac{\\arctan(\\kappa x)}{\\kappa} \\right]_{0}^{1}\n$$\n$$\n= \\left( \\frac{3}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^3} \\arctan(\\kappa) \\right) - (0 - 0) = \\frac{3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)}{\\kappa^3}\n$$\n最后，我们组合出 $\\beta$ 的表达式：\n$$\n\\beta = \\frac{\\text{Numerator}}{\\text{Denominator}} = \\frac{\\frac{3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)}{\\kappa^3}}{\\frac{32}{5}} = \\frac{5}{32\\kappa^3} \\bigl(3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)\\bigr)\n$$\n\n### 约束可行性与渐近精度分析\n\n**约束的可行性：**\n约束 $p'(1)=0$ 是关于多项式 $p(x)$ 系数的一个线性方程。对于任意多项式次数 $N$，集合 $V_N = \\{p \\in \\mathbb{P}_N \\mid p'(1)=0\\}$ 是 $\\mathbb{P}_N$ 的一个仿射子空间。该子空间非空；例如，对于 $N \\ge 0$，任何常数多项式 $p(x)=c$ 都属于 $V_N$。最小二乘问题是在非空、闭、凸集 $V_N$ 上对一个严格凸泛函 $\\|f-p\\|_{L^2}^2$ 的最小化。根据凸优化的标准原理，保证存在唯一的极小化子。因此，该约束总是可行的。\n\n**对渐近精度的影响：**\n施加固定有限数量的线性约束，例如 $p'(1)=0$，会从根本上改变对解析函数 $f$ 的逼近的渐近收敛行为。谱精度，其特征是误差随多项式次数 $N$ 呈指数衰减（即 $\\|f-p_N\\|_{L^2} \\sim \\exp(-cN)$），将会丧失。\n\n为了从第一性原理理解这一点，设 $p_N$ 是 $f$ 到 $\\mathbb{P}_N$ 上的无约束 $L^2$-投影，$p_N^c$ 是约束投影。约束解可以使用拉格朗日乘子 $\\lambda$ 求得。约束系数 $c_j$ 是对无约束系数 $\\hat{f}_j$ 的一个扰动：\n$$\nc_j = \\hat{f}_j - \\frac{\\lambda}{2} \\frac{P_j'(1)}{\\|P_j\\|^2}\n$$\n约束逼近与无约束逼近之差为 $p_N - p_N^c = \\frac{\\lambda}{2} \\sum_{j=0}^N \\frac{P_j'(1)}{\\|P_j\\|^2} P_j(x)$。约束逼近的误差可以使用正交性分解为：\n$$\n\\|f - p_N^c\\|_{L^2}^2 = \\|f - p_N\\|_{L^2}^2 + \\|p_N - p_N^c\\|_{L^2}^2\n$$\n第一项 $\\|f - p_N\\|_{L^2}^2$ 是无约束谱投影的误差，对于解析函数 $f$，该项呈指数衰减。第二项代表了施加约束所带来的惩罚。可以证明它等于 $(p_N'(1))^2 / D_N$，其中 $p_N'(1)$ 是无约束逼近在 $x=1$ 处的导数（当 $N\\to\\infty$ 时收敛于 $f'(1)$），且 $D_N = \\sum_{j=1}^N \\frac{(P_j'(1))^2}{\\|P_j\\|^2}$。\n使用已知性质 $P_j'(1) = j(j+1)/2$ 和 $\\|P_j\\|^2 = 2/(2j+1)$，可以证明和 $D_N$ 随 $N$ 呈多项式增长，具体为 $D_N \\sim O(N^6)$。\n\n因此，附加的误差项 $\\|p_N - p_N^c\\|_{L^2}^2$ 呈多项式衰减，阶数为 $O(N^{-6})$。总误差是一个指数衰减项和一个多项式衰减项之和。对于大的 $N$，多项式项占主导地位。因此，总体的收敛率不再是指数级的，而是代数级的。施加这样的约束会用慢得多的多项式收敛率取代谱精度。",
            "answer": "$$\n\\boxed{\\frac{5}{32\\kappa^3} \\bigl(3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)\\bigr)}\n$$"
        }
    ]
}