{
    "hands_on_practices": [
        {
            "introduction": "要有效抑制龙格现象，我们必须首先理解插值节点排布的关键作用。本练习  将引导您从一个简单的均匀角度网格出发，完成切比雪夫-洛巴托（Chebyshev-Lobatto）节点的经典推导。通过分析这一变换，您将揭示节点在端点处聚集的几何根源，并从根本上理解这种非均匀分布是如何抑制高阶多项式插值中的剧烈振荡的。",
            "id": "3413813",
            "problem": "考虑在区间 $[-1,1]$ 上，于间断 Galerkin (DG) 方法中采用 Chebyshev 多项式谱元基进行多项式插值。角度必须以弧度为单位。\n\n1. 从第一类 Chebyshev 多项式的定义关系 $T_{k}(x) = \\cos(k \\arccos x)$ 和变量替换 $x = \\cos \\xi$（其反函数为 $\\xi = \\arccos x$）出发。推导角度变量 $\\xi$ 中的均匀网格（具体为 $\\xi_{j} = j \\pi/n$，$j = 0,1,\\dots,n$）如何变换为 $x$ 中的 Chebyshev–Lobatto 节点集（即 $x_{j} = \\cos(j \\pi/n)$）。在推导过程中，使用雅可比导数 $\\mathrm{d}\\xi/\\mathrm{d}x$ 解释 Chebyshev–Lobatto 节点的端点聚集现象，并说明为何这种聚集能够缓解解析函数 $f$ 的 Runge 现象。\n\n2. 令 $f(x) = \\frac{1}{1 + 25 x^{2}}$。对于 $n = 6$，构造一个次数至多为 $n$ 的唯一多项式 $p_{n}(x)$，它在 Chebyshev–Lobatto 节点 $x_{j} = \\cos(j \\pi/n)$（$j=0,1,\\dots,n$）处插值函数 $f$。在点 $x_{\\star} = \\cos(\\pi/6)$ 处计算 $p_{6}(x)$ 的值，并将结果表示为单个精确的解析表达式。\n\n你的最终答案必须是单个解析表达式。无需进行四舍五入。",
            "solution": "问题分为两部分。第一部分要求对 Chebyshev-Lobatto 节点进行推导和解释。第二部分要求构造并计算一个特定的插值多项式。\n\n### 第一部分：Chebyshev-Lobatto 节点的推导与解释\n\n给定变量替换 $x = \\cos \\xi$（对于 $x \\in [-1, 1]$），这意味着 $\\xi \\in [0, \\pi]$。其逆变换为 $\\xi = \\arccos x$。\n\n角度变量 $\\xi$ 中的一个均匀网格由点 $\\xi_{j} = \\frac{j \\pi}{n}$（其中 $j = 0, 1, \\dots, n$）定义。将变换 $x = \\cos \\xi$ 应用于这些点，我们得到 $x$ 域中相应的网格点：\n$$\nx_{j} = \\cos(\\xi_{j}) = \\cos\\left(\\frac{j \\pi}{n}\\right) \\quad \\text{其中 } j = 0, 1, \\dots, n.\n$$\n根据定义，这些就是 Chebyshev-Lobatto 节点。这就完成了从 $\\xi$ 中的均匀网格到 $x$ 中指定节点集的变换推导。\n\n为解释端点聚集现象，我们考察无穷小区间 $\\mathrm{d}x$ 和 $\\mathrm{d}\\xi$ 之间的关系。逆变换 $\\xi(x)$ 的雅可比导数即为：\n$$\n\\frac{\\mathrm{d}\\xi}{\\mathrm{d}x} = \\frac{\\mathrm{d}}{\\mathrm{d}x}(\\arccos x) = -\\frac{1}{\\sqrt{1 - x^2}}.\n$$\n该导数的绝对值 $\\left|\\frac{\\mathrm{d}\\xi}{\\mathrm{d}x}\\right| = \\frac{1}{\\sqrt{1 - x^2}}$ 表示 $\\xi$ 中一个区间的长度与 $x$ 中相应区间的长度的局部比率。\n\n$\\xi$ 中的均匀网格意味着间距是恒定的，即 $\\Delta\\xi = \\xi_{j+1} - \\xi_j = \\frac{\\pi}{n}$。而 $x$ 中的相应间距 $\\Delta x_j = x_{j+1} - x_j$ 不是恒定的。我们可以通过 $\\Delta\\xi \\approx \\left|\\frac{\\mathrm{d}\\xi}{\\mathrm{d}x}\\right| |\\Delta x|$ 来关联这些间距。整理得到 $|\\Delta x|$：\n$$\n|\\Delta x| \\approx \\left|\\frac{\\mathrm{d}x}{\\mathrm{d}\\xi}\\right| \\Delta\\xi = |\\sin(\\xi)| \\Delta\\xi = \\sqrt{1-x^2} \\Delta\\xi.\n$$\n由于 $\\Delta\\xi$ 是常数，$x$ 域中节点间的间距 $|\\Delta x|$ 与 $\\sqrt{1-x^2}$ 成正比。当 $x$ 趋近于区间的端点，即 $x \\to \\pm 1$ 时，$\\sqrt{1-x^2}$ 这一项趋近于 0。因此，与区间中心（$x=0$ 处间距最大）相比，端点附近的间距 $|\\Delta x|$ 变得显著更小。这种在边界处更密集的非均匀间距被称为端点聚集。\n\n这种聚集缓解了 Runge 现象。用一个次数至多为 $n$ 的多项式 $p_n(x)$ 对函数 $f(x)$ 进行多项式插值的误差由下式给出：\n$$\nf(x) - p_n(x) = \\frac{f^{(n+1)}(\\eta_x)}{(n+1)!} \\prod_{j=0}^{n} (x-x_j)\n$$\n对于某个 $\\eta_x \\in [-1, 1]$。Runge 现象的特征是在端点附近出现大幅振荡，它在使用等距节点时发生，因为节点多项式 $\\omega_{n+1}(x) = \\prod_{j=0}^{n} (x-x_j)$ 在区间边界附近的幅值变得非常大。Chebyshev-Lobatto 节点通过两种方式来抵消这一点。首先，节点聚集在端点附近对多项式施加了更多约束，从而在振荡趋于最大的地方抑制了振荡。其次，与等距节点相比，由 Chebyshev-Lobatto 节点得到的节点多项式在 $[-1, 1]$ 上的最大幅值要小得多。$|\\omega_{n+1}(x)|$ 的最大值量级为 $O(2^{-n})$，而对于等距节点，它呈指数级增长。这一性质与 Chebyshev 节点的 Lebesgue 常数 $\\Lambda_n = O(\\ln n)$ 的缓慢对数增长密切相关，这保证了当 $n \\to \\infty$ 时，插值多项式 $p_n(x)$ 对任何解析函数 $f(x)$ 的收敛性。\n\n### 第二部分：多项式插值与求值\n\n我们需要求解函数 $f(x) = \\frac{1}{1 + 25 x^2}$ 的插值多项式 $p_6(x)$ 在点 $x_{\\star} = \\cos(\\pi/6)$ 处的值。多项式 $p_6(x)$ 的次数至多为 $n=6$，并在 $n+1=7$ 个 Chebyshev-Lobatto 节点上插值 $f(x)$。\n\n插值节点由 $x_j = \\cos(j \\pi/n)$ 给出，其中 $n=6$ 且 $j = 0, 1, \\dots, 6$。我们列出这些节点：\n- $x_0 = \\cos(0\\pi/6) = \\cos(0) = 1$\n- $x_1 = \\cos(1\\pi/6) = \\cos(\\pi/6) = \\frac{\\sqrt{3}}{2}$\n- $x_2 = \\cos(2\\pi/6) = \\cos(\\pi/3) = \\frac{1}{2}$\n- $x_3 = \\cos(3\\pi/6) = \\cos(\\pi/2) = 0$\n- $x_4 = \\cos(4\\pi/6) = \\cos(2\\pi/3) = -\\frac{1}{2}$\n- $x_5 = \\cos(5\\pi/6) = -\\frac{\\sqrt{3}}{2}$\n- $x_6 = \\cos(6\\pi/6) = \\cos(\\pi) = -1$\n\n我们必须计算多项式值的点是 $x_{\\star} = \\cos(\\pi/6)$。通过与节点列表直接比较，我们发现该求值点是插值节点之一：\n$$\nx_{\\star} = x_1 = \\frac{\\sqrt{3}}{2}.\n$$\n根据插值多项式的定义，其在任何一个插值节点上的值必须等于原始函数在同一节点上的值。也就是说，对于一个在 $n+1$ 个不同节点 $\\{x_j\\}_{j=0}^n$ 上插值函数 $f(x)$ 的、次数至多为 $n$ 的唯一多项式 $p_n(x)$，它必须满足以下条件：\n$$\np_n(x_j) = f(x_j) \\quad \\text{对于所有 } j = 0, 1, \\dots, n.\n$$\n在我们 $n=6$ 的情况下，对于 $j=0, \\dots, 6$，有 $p_6(x_j) = f(x_j)$。由于我们的求值点 $x_\\star$ 就是节点 $x_1$，因此多项式在该点的值就是函数在该节点的值：\n$$\np_6(x_{\\star}) = p_6(x_1) = f(x_1).\n$$\n因此，任务简化为计算函数 $f(x)$ 在 $x = x_1 = \\frac{\\sqrt{3}}{2}$ 处的值。\n$$\nf\\left(\\frac{\\sqrt{3}}{2}\\right) = \\frac{1}{1 + 25 \\left(\\frac{\\sqrt{3}}{2}\\right)^2} = \\frac{1}{1 + 25 \\left(\\frac{3}{4}\\right)} = \\frac{1}{1 + \\frac{75}{4}}.\n$$\n为简化此表达式，我们对分母部分进行通分：\n$$\nf\\left(\\frac{\\sqrt{3}}{2}\\right) = \\frac{1}{\\frac{4}{4} + \\frac{75}{4}} = \\frac{1}{\\frac{4+75}{4}} = \\frac{1}{\\frac{79}{4}}.\n$$\n将分数取倒数得到最终结果：\n$$\np_6(\\cos(\\pi/6)) = \\frac{4}{79}.\n$$\n这是精确的解析值。没有必要在单项式基或任何其他基中显式地构造多项式 $p_6(x)$ 的完整表达式，因为其在指定点的值由插值条件直接确定。",
            "answer": "$$\\boxed{\\frac{4}{79}}$$"
        },
        {
            "introduction": "虽然我们已经知道切比雪夫节点表现更优，但如何才能定量地衡量这种改进呢？本计算练习  引入了“噪声放大因子”这一概念，它是一个评估任何插值格式稳定性的强大工具。通过为等距节点、切比雪夫节点和分片单元节点编写代码并进行分析，您将获得诊断龙格现象背后数值病态的实践经验，并深刻体会分片DG（Discontinuous Galerkin）格式的稳健性。",
            "id": "3413836",
            "problem": "要求您研究谱方法和间断 Galerkin 方法中与多项式重构相关的敏感性放大问题，重点关注区间端点附近的 Runge 现象。考虑在区间 $[-1,1]$ 上基于不同节点集构建的节点插值算子。对于给定的节点集 $\\{x_j\\}_{j=0}^{N}$ 及其相关的重心 Lagrange 基函数 $\\{\\ell_j(x)\\}_{j=0}^{N}$，从节点数据 $\\{y_j\\}$ 在点 $x$ 处的重构为 $u_p(x)=\\sum_{j=0}^{N} \\ell_j(x)\\,y_j$。假设节点数据 $\\{y_j\\}$ 受到均值为零、方差为 $\\sigma^2$ 的附加独立同分布扰动的污染。点 $x$ 处的放大因子定义为重构值 $u_p(x)$ 的标准差与节点扰动标准差 $\\sigma$ 之比，它量化了噪声在点 $x$ 处被插值算子放大的程度。\n\n使用以下基本依据：\n- 节点 Lagrange 基满足 $\\ell_j(x_k)=\\delta_{jk}$ 且对于所有 $x\\in[-1,1]$ 都有 $\\sum_{j=0}^{N}\\ell_j(x)=1$。\n- 重心插值公式将 $u_p(x)$ 表示为数据 $\\{y_j\\}$ 的线性组合，因此扰动会线性传播到重构结果中。\n- 对于方差为 $\\sigma^2$ 的独立同分布输入，在线性算子（系数为 $\\{\\phi_j(x)\\}$）作用下的输出方差等于 $\\sigma^2\\sum_{j}\\phi_j(x)^2$。\n\n您的任务：\n1. 对于 $[-1,1]$ 上的全局插值，构造三种节点集：\n   - 等距节点：$x_j=-1+\\frac{2j}{N}$，其中 $j=0,1,\\dots,N$。\n   - Chebyshev–Lobatto 节点：$x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$。\n   - 在 $K$ 个均匀单元上的分段“间断 Galerkin 风格”重构：将 $[-1,1]$ 划分成 $K$ 个子区间，在每个单元上使用 $p$ 次的局部 Chebyshev–Lobatto 节点（即每个单元 $p+1$ 个节点）。全局重构在每个单元上由相应的局部节点插值局部定义，单元之间没有任何连续性约束。\n\n2. 对于每种重构，在 $[-1,1]$（包括端点）的 $M$ 个点的均匀网格上计算放大因子 $A(x)$，其中 $A(x)$ 定义为 $A(x)=\\frac{\\sigma(u_p(x))}{\\sigma}$，而 $\\sigma(u_p(x))$ 是在方差为 $\\sigma^2$ 的独立同分布节点扰动下，点 $x$ 处重构值的标准差。利用这样一个事实：由于线性和独立性，$A(x)$ 等于插值形函数向量 $\\{\\ell_j(x)\\}$ 在点 $x$ 处的欧几里得范数。\n\n3. 通过计算在网格上评估的 $A(x)$ 的以下标量度量来量化端点敏感性尖峰：\n   - $A_{\\max}=\\max_{x\\in[-1,1]} A(x)$,\n   - $A_{\\text{bdry}}=\\max_{x:\\,|x|\\ge \\alpha} A(x)$，其中 $\\alpha=0.95$,\n   - $A_{\\text{ctr}}=\\max_{x:\\,|x|\\le \\beta} A(x)$，其中 $\\beta=0.5$,\n   - 比率 $R=\\dfrac{A_{\\text{bdry}}}{A_{\\text{ctr}}}$。\n\n4. 使用重心 Lagrange 公式实现计算。对于 Chebyshev–Lobatto 节点，使用已知的稳定重心权。对于等距节点和局部单元节点，您可以直接从节点乘积计算权重。通过强制 $\\ell_j(x)=1$ 和 $\\ell_{k\\neq j}(x)=0$ 来精确处理 $x=x_j$ 的情况。\n\n5. 提供以下参数选择的测试套件：\n   - 测试用例 1：在等距节点上进行全局插值，次数 $N=20$，评估网格大小 $M=1001$。\n   - 测试用例 2：在 Chebyshev–Lobatto 节点上进行全局插值，次数 $N=20$，评估网格大小 $M=1001$。\n   - 测试用例 3：分段重构，包含 $K=10$ 个单元，局部次数 $p=3$（局部 Chebyshev–Lobatto 节点），评估网格大小 $M=1001$。\n   - 测试用例 4：在等距节点上进行全局插值，低次 $N=2$，评估网格大小 $M=1001$。\n\n6. 对于每个测试用例，输出一个包含四个浮点数 $[A_{\\max},A_{\\text{bdry}},A_{\\text{ctr}},R]$ 的列表。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个列表。例如，输出格式应为 $[[a_{11},a_{12},a_{13},a_{14}],[a_{21},a_{22},a_{23},a_{24}],\\dots]$ 的形式，所有条目均为十进制数。\n\n此任务不涉及物理单位。角度必须以弧度为单位。所有返回值必须是不带百分号的普通十进制数。您的程序必须是自包含的，不需要任何输入，并且确定性地计算所要求的量。",
            "solution": "我们从节点多项式插值和独立同分布噪声通过线性映射进行线性传播的基本定义开始。设 $\\{x_j\\}_{j=0}^{N}\\subset[-1,1]$ 为互异节点。节点 Lagrange 基函数 $\\{\\ell_j(x)\\}_{j=0}^{N}$ 由条件 $\\ell_j(x_k)=\\delta_{jk}$ 定义，它们构成一个单位分解，即对于所有 $x\\in[-1,1]$ 都有 $\\sum_{j=0}^{N}\\ell_j(x)=1$。次数至多为 $N$ 的节点插值多项式为 $u_p(x)=\\sum_{j=0}^{N}\\ell_j(x)\\,y_j$。\n\n重心插值公式以数值稳定的形式实现 $u_p(x)$。如果 $w_j$ 是与 $\\{x_j\\}$ 兼容的重心权，则对于 $x\\neq x_j$，\n$$\nu_p(x)=\\frac{\\sum_{j=0}^{N}\\dfrac{w_j}{x-x_j}\\,y_j}{\\sum_{j=0}^{N}\\dfrac{w_j}{x-x_j}},\n$$\n而在 $x=x_j$ 处，$u_p(x)=y_j$。重要的是，这表明 $u_p(x)$ 是数据 $\\{y_j\\}$ 的一个线性泛函：\n$$\nu_p(x) = \\sum_{j=0}^{N} \\phi_j(x)\\,y_j,\\quad \\text{其中}\\quad \\phi_j(x) = \\begin{cases}\n\\dfrac{w_j/(x-x_j)}{\\sum_{k=0}^{N} w_k/(x-x_k)},  & x\\neq x_j,\\\\\n1,  & x=x_j\\ \\text{且索引等于}\\ j,\\\\\n0,  & x=x_j\\ \\text{且索引不等于}\\ j.\n\\end{cases}\n$$\n系数 $\\{\\phi_j(x)\\}$ 是 Lagrange 基函数 $\\{\\ell_j(x)\\}$ 在点 $x$ 处的值。\n\n考虑数据上的附加独立同分布扰动 $y_j = \\bar{y}_j + \\varepsilon_j$，其中 $\\mathbb{E}[\\varepsilon_j]=0$ 且 $\\operatorname{Var}(\\varepsilon_j)=\\sigma^2$，并且关于 $j$ 独立。通过该线性映射的传播得出\n$$\nu_p(x) = \\sum_{j=0}^{N} \\phi_j(x)\\,\\bar{y}_j + \\sum_{j=0}^{N} \\phi_j(x)\\,\\varepsilon_j.\n$$\n因此，由扰动引起的 $u_p(x)$ 的方差为\n$$\n\\operatorname{Var}(u_p(x)) = \\mathbb{E}\\Big[\\Big(\\sum_{j=0}^{N} \\phi_j(x)\\,\\varepsilon_j\\Big)^2\\Big] = \\sum_{j=0}^{N}\\phi_j(x)^2\\,\\operatorname{Var}(\\varepsilon_j) = \\sigma^2 \\sum_{j=0}^{N}\\phi_j(x)^2,\n$$\n这里我们使用了独立性和同方差性。因此，放大因子（定义为输出标准差与输入标准差之比）为\n$$\nA(x) = \\frac{\\sigma(u_p(x))}{\\sigma} = \\sqrt{\\sum_{j=0}^{N}\\phi_j(x)^2}.\n$$\n因此，$A(x)$ 等于在点 $x$ 处求值的形函数向量 $\\{\\ell_j(x)\\}$ 的欧几里得范数。\n\n现在我们描述节点构造和相应的重心权：\n- 对于等距节点 $x_j=-1+\\frac{2j}{N}$，通用重心权可取为 $w_j = \\left(\\prod_{k\\neq j}(x_j-x_k)\\right)^{-1}$；这些权重在相差一个非零标量因子的意义下是唯一的，该因子在重心公式和 $\\{\\phi_j(x)\\}$ 的计算中会被消去。\n- 对于 Chebyshev–Lobatto 节点 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其数值稳定的权重有已知的闭合形式，$w_j = (-1)^j c_j$，其中 $c_0=c_N=\\frac{1}{2}$ 且对于 $j=1,\\dots,N-1$ 有 $c_j=1$。对这些权重进行任何非零常数缩放，$\\{\\phi_j(x)\\}$ 均保持不变。\n- 对于分段“间断 Galerkin 风格”重构，将 $[-1,1]$ 划分成 $K$ 个等长单元。在每个单元上，我们放置 $p$ 次的局部 Chebyshev–Lobatto 节点，即通过将参考区间 $[-1,1]$ 上的 $\\{\\cos(\\pi i/p)\\}_{i=0}^{p}$ 映射到该单元上得到的 $p+1$ 个节点。点 $x$ 处的重构仅使用局部单元的节点数据，通过局部重心公式计算。因为从完整节点数据集到 $u_p(x)$ 的映射是块局部的，所以对应的形函数向量 $\\{\\phi_j(x)\\}$ 仅在包含 $x$ 的单元上的节点处有非零项。\n\n对于每个测试用例，我们在 $[-1,1]$ 上的一个包含 $M$ 个点的均匀网格（包括端点）上评估 $A(x)$。然后我们计算以下标量：\n- $A_{\\max}=\\max_{x\\in[-1,1]} A(x)$,\n- $A_{\\text{bdry}}=\\max_{|x|\\ge \\alpha} A(x)$，其中 $\\alpha=0.95$,\n- $A_{\\text{ctr}}=\\max_{|x|\\le \\beta} A(x)$，其中 $\\beta=0.5$,\n- $R=\\dfrac{A_{\\text{bdry}}}{A_{\\text{ctr}}}$。\n\n关于 Runge 现象的解释：对于等距节点上的全局插值，当次数增长时，Runge 现象表现为在端点附近出现大幅振荡和高度敏感性。放大因子 $A(x)$ 直接反映了对扰动的敏感性；$A(x)$ 在 $x=\\pm 1$ 附近的尖峰表明存在剧烈的放大，并且这与等距节点的 Lebesgue 函数的增长密切相关。Chebyshev–Lobatto 节点减缓了这种增长，从而减少了端点尖峰。另一种稳健的方法是使用分段低次插值，如在间断 Galerkin 方法中那样；局部性使得 $A(x)$ 在整个区间（包括端点附近）上保持一致有界。\n\n算法设计：\n1. 为每种配置构造节点和重心权。\n2. 在 $[-1,1]$ 中建立一个包含 $M$ 个等距点的评估网格。\n3. 对于每个评估点 $x$：\n   - 如果 $x$ 与某个节点重合（在紧密容差范围内），则将相应的形函数向量设置为单位选择向量。\n   - 否则，计算重心系数 $\\{\\phi_j(x)\\}$，对于分段情况，则在单元上进行全局或局部计算。\n   - 计算 $A(x)=\\sqrt{\\sum_j \\phi_j(x)^2}$。\n4. 从网格上的离散 $A(x)$ 值计算 $A_{\\max}$、$A_{\\text{bdry}}$、$A_{\\text{ctr}}$ 和 $R$。\n5. 对测试套件重复以上步骤：\n   - 测试用例 1：全局等距节点，$N=20$，$M=1001$。\n   - 测试用例 2：全局 Chebyshev–Lobatto 节点，$N=20$，$M=1001$。\n   - 测试用例 3：分段重构，包含 $K=10$ 个单元，局部次数 $p=3$（局部 Chebyshev–Lobatto 节点），$M=1001$。\n   - 测试用例 4：全局等距节点，低次 $N=2$，$M=1001$。\n6. 输出单行结果：为每个测试用例输出一个包含四个元素的列表 $[A_{\\max},A_{\\text{bdry}},A_{\\text{ctr}},R]$。\n\n通过比较不同测试用例的 $R$ 值，可以识别出端点附近的敏感性尖峰。我们预计，对于 $N=20$ 的全局等距节点，会表现出较大的 $R$ 值；Chebyshev–Lobatto 节点会大幅减小 $R$ 值；而分段重构会使 $R$ 值接近于 1。低次等距节点情况也应该有适中的 $R$ 值。这些观察启发了我们采用稳健的拟合策略，例如使用 Chebyshev–Lobatto 节点进行全局插值，或采用间断 Galerkin 方法中典型的分段低次重构，以减缓 Runge 现象。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef equispaced_nodes(N: int) -> np.ndarray:\n    # N+1 nodes on [-1,1]\n    return np.linspace(-1.0, 1.0, N + 1)\n\ndef chebyshev_lobatto_nodes(N: int) -> np.ndarray:\n    # x_j = cos(pi*j/N), j=0..N\n    j = np.arange(N + 1)\n    return np.cos(np.pi * j / N)\n\ndef bary_weights_generic(nodes: np.ndarray) -> np.ndarray:\n    # Compute generic barycentric weights w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # This is O(n^2) and acceptable for moderate N.\n    n = nodes.size\n    w = np.empty(n, dtype=float)\n    for j in range(n):\n        diffs = nodes[j] - np.delete(nodes, j)\n        prod = np.prod(diffs)\n        w[j] = 1.0 / prod\n    return w\n\ndef bary_weights_cheb_lobatto(N: int) -> np.ndarray:\n    # Stable weights for Chebyshev-Lobatto nodes: w_j = (-1)^j * c_j with c_0=c_N=1/2, else 1\n    j = np.arange(N + 1)\n    w = (-1.0) ** j\n    if N >= 1:\n        w[0] *= 0.5\n        w[-1] *= 0.5\n    return w\n\ndef barycentric_phi_matrix(x_eval: np.ndarray, nodes: np.ndarray, weights: np.ndarray, tol: float = 1e-14) -> np.ndarray:\n    # Compute the matrix Phi where Phi[i,j] = phi_j(x_eval[i])\n    # Handle x equal to nodes by one-hot rows.\n    x_eval = np.asarray(x_eval)\n    nodes = np.asarray(nodes)\n    weights = np.asarray(weights)\n    m = x_eval.size\n    n = nodes.size\n    Phi = np.zeros((m, n), dtype=float)\n\n    # For vectorized computation, we will process rows where x does not coincide with any node\n    # First, detect coincidences\n    # Use broadcasting to compute |x - nodes| and check for small values\n    diff = np.abs(x_eval[:, None] - nodes[None, :])\n    row_has_hit = np.any(diff < tol, axis=1)\n    # For rows with a hit, set one-hot\n    hit_rows = np.where(row_has_hit)[0]\n    for i in hit_rows:\n        j_hit = np.where(diff[i, :] < tol)[0]\n        # In rare cases of multiple matches due to tolerance, pick the closest\n        if j_hit.size > 1:\n            j_closest = j_hit[np.argmin(diff[i, j_hit])]\n            j_hit = np.array([j_closest], dtype=int)\n        Phi[i, j_hit[0]] = 1.0\n\n    # For rows without hit, compute barycentric coefficients\n    reg_rows = np.where(~row_has_hit)[0]\n    if reg_rows.size > 0:\n        xx = x_eval[reg_rows][:, None]  # shape (mr,1)\n        T = 1.0 / (xx - nodes[None, :])  # shape (mr,n)\n        WT = weights[None, :] * T\n        denom = np.sum(WT, axis=1)  # shape (mr,)\n        # Avoid division by zero; denom should not be zero for valid weights/nodes\n        Phi_reg = WT / denom[:, None]\n        Phi[reg_rows, :] = Phi_reg\n\n    return Phi\n\ndef amplification_from_phi(Phi: np.ndarray) -> np.ndarray:\n    # A(x) = sqrt(sum_j phi_j(x)^2)\n    return np.sqrt(np.sum(Phi * Phi, axis=1))\n\ndef piecewise_dg_phi_matrix(x_eval: np.ndarray, K: int, p: int) -> np.ndarray:\n    # Build piecewise Chebyshev-Lobatto local interpolation on K uniform elements, degree p per element.\n    # Global nodes are discontinuous across elements; total nodes = K*(p+1).\n    # The mapping is block-local: for x in element e, only the local (p+1) nodes contribute.\n    m = x_eval.size\n    # Element boundaries\n    edges = np.linspace(-1.0, 1.0, K + 1)\n    h = edges[1] - edges[0]\n    # Build global nodes (for completeness, but we need only Phi)\n    total_nodes = K * (p + 1)\n    Phi = np.zeros((m, total_nodes), dtype=float)\n\n    # Precompute local reference nodes and weights for Chebyshev-Lobatto of degree p\n    if p == 0:\n        r_ref = np.array([0.0])\n        w_ref = np.array([1.0])\n    else:\n        r_ref = np.cos(np.pi * np.arange(p + 1) / p)\n        # Stable weights for Chebyshev-Lobatto on reference\n        w_ref = bary_weights_cheb_lobatto(p)\n\n    # For each evaluation point, find its element and compute local phi, then place into global Phi\n    # Determine element indices: e in {0, ..., K-1}\n    # Map x to element by index e = floor((x - (-1))/h), clamp to [0, K-1]; special case for x=1 assign last element.\n    t = (x_eval - (-1.0)) / h\n    e_idx = np.floor(t).astype(int)\n    e_idx = np.clip(e_idx, 0, K - 1)\n    # Correct those exactly at the rightmost boundary to last element\n    rightmost = np.isclose(x_eval, 1.0, atol=1e-14)\n    e_idx[rightmost] = K - 1\n\n    # Process each element's evaluation points in batch for efficiency\n    for e in range(K):\n        mask = (e_idx == e)\n        if not np.any(mask):\n            continue\n        x_local = x_eval[mask]\n        # Element bounds\n        xl = edges[e]\n        xr = edges[e + 1]\n        # Affine mapping from reference r in [-1,1] to physical x: x = 0.5*(xr+xl) + 0.5*(xr-xl)*r\n        # Inverse mapping r = (2*(x - 0.5*(xr+xl))) / (xr - xl)\n        r = (2.0 * (x_local - 0.5 * (xr + xl))) / (xr - xl)\n\n        # Compute local phi on reference nodes\n        Phi_loc = barycentric_phi_matrix(r, r_ref, w_ref)\n\n        # Insert into global Phi at the block corresponding to element e\n        col_start = e * (p + 1)\n        col_end = col_start + (p + 1)\n        Phi[np.where(mask)[0][:, None], np.arange(col_start, col_end)[None, :]] = Phi_loc\n\n    return Phi\n\ndef compute_metrics_from_A(x_eval: np.ndarray, A: np.ndarray, alpha: float = 0.95, beta: float = 0.5):\n    # Compute A_max, A_bdry (|x|>=alpha), A_ctr (|x|<=beta), ratio\n    A_max = float(np.max(A))\n    bdry_mask = np.abs(x_eval) >= alpha\n    ctr_mask = np.abs(x_eval) <= beta\n    A_bdry = float(np.max(A[bdry_mask])) if np.any(bdry_mask) else float('nan')\n    A_ctr = float(np.max(A[ctr_mask])) if np.any(ctr_mask) else float('nan')\n    R = float(A_bdry / A_ctr) if (A_ctr != 0.0 and np.isfinite(A_bdry) and np.isfinite(A_ctr)) else float('nan')\n    return [A_max, A_bdry, A_ctr, R]\n\ndef run_test_cases():\n    results = []\n\n    # Common evaluation grid size\n    M = 1001\n    x_eval = np.linspace(-1.0, 1.0, M)\n\n    # Test case 1: Global equispaced nodes, N=20\n    N1 = 20\n    nodes1 = equispaced_nodes(N1)\n    w1 = bary_weights_generic(nodes1)\n    Phi1 = barycentric_phi_matrix(x_eval, nodes1, w1)\n    A1 = amplification_from_phi(Phi1)\n    metrics1 = compute_metrics_from_A(x_eval, A1, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics1])\n\n    # Test case 2: Global Chebyshev-Lobatto nodes, N=20\n    N2 = 20\n    nodes2 = chebyshev_lobatto_nodes(N2)\n    w2 = bary_weights_cheb_lobatto(N2)\n    Phi2 = barycentric_phi_matrix(x_eval, nodes2, w2)\n    A2 = amplification_from_phi(Phi2)\n    metrics2 = compute_metrics_from_A(x_eval, A2, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics2])\n\n    # Test case 3: Piecewise DG-style, K=10 elements, local degree p=3\n    K3 = 10\n    p3 = 3\n    Phi3 = piecewise_dg_phi_matrix(x_eval, K=K3, p=p3)\n    A3 = amplification_from_phi(Phi3)\n    metrics3 = compute_metrics_from_A(x_eval, A3, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics3])\n\n    # Test case 4: Global equispaced nodes, low degree N=2\n    N4 = 2\n    nodes4 = equispaced_nodes(N4)\n    w4 = bary_weights_generic(nodes4)\n    Phi4 = barycentric_phi_matrix(x_eval, nodes4, w4)\n    A4 = amplification_from_phi(Phi4)\n    metrics4 = compute_metrics_from_A(x_eval, A4, alpha=0.95, beta=0.5)\n    results.append([float(f\"{v:.12g}\") for v in metrics4])\n\n    return results\n\ndef solve():\n    results = run_test_cases()\n    # Final print statement in the exact required format.\n    # Print a single line: list of lists with 4 floats each.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了优化节点布局，我们能否通过直接约束多项式的行为来抑制振荡？本练习  探讨了这样一种策略，它构建了一个带约束的最小二乘问题，强制多项式在端点的导数为零以抑制过冲。这个练习是关于数值方法中权衡取舍的重要一课：通过严谨的分析，您将发现这种看似直观的修正会破坏方法的谱精度，而谱精度正是谱方法的核心优势之一，这个代价是极其高昂的。",
            "id": "3413852",
            "problem": "考虑区间 $[-1,1]$ 上关于标准勒贝格测度的最小二乘逼近。设 $f(x) = \\frac{1}{1+\\kappa^{2} x^{2}}$，其中 $\\kappa > 0$ 是一个固定参数。为了减轻全局多项式逼近中与龙格现象相关的端点过冲，我们在右端点施加一个斜率钳制约束，以抑制 $x=1$ 附近的振荡。\n\n定义约束最小二乘问题：求次数 $\\leq 2$ 的多项式 $p \\in \\mathbb{P}_{2}$，使其最小化\n$$\n\\int_{-1}^{1} \\bigl(f(x) - p(x)\\bigr)^{2} \\, dx\n$$\n并满足端点条件 $p'(1)=0$。此处 $\\mathbb{P}_{2}$ 由勒让德多项式 $\\{P_{0}(x),P_{1}(x),P_{2}(x)\\}$ 张成，其中 $P_{0}(x)=1$, $P_{1}(x)=x$, 以及 $P_{2}(x)=\\frac{1}{2}(3x^{2}-1)$。\n\n从勒让德多项式的正交性和最小二乘投影的定义出发，推导出约束最小化子，其形式为\n$$\np(x) \\;=\\; \\alpha_{0} P_{0}(x) \\;+\\; \\beta \\bigl(P_{2}(x) - 3 P_{1}(x)\\bigr),\n$$\n并获得系数 $\\beta$ 作为 $\\kappa$ 的函数的闭式解析表达式。\n\n然后，基于凸优化和正交投影的基本原理，简要分析约束 $p'(1)=0$ 的可行性，并解释对于解析目标函数 $f$，施加固定有限数量的此类线性端点约束（与多项式次数无关）是否会改变关于 $N$ 的渐近谱精度。你的推理必须从 $L^{2}$-投影和正交多项式基的标准性质出发，并且不得假设任何预先推导出的约束投影公式。\n\n请给出 $\\beta(\\kappa)$ 的显式解析表达式作为最终答案。不需要数值计算，也不允许四舍五入。请仅使用 $\\kappa$ 的初等函数，以最简精确形式表示最终答案。",
            "solution": "该问题要求确定一个带约束的多项式逼近，并对此类约束进行分析。我们首先验证问题的有效性，然后进行求解。\n\n### 问题验证\n该问题是适定的。它涉及在有限维空间 $\\mathbb{P}_2$ 中寻找一个多项式 $p(x)$，该多项式在满足一个线性约束的条件下，最小化一个严格凸泛函，即 $L^2$-范数的平方误差。这是一个标准的约束二次优化问题，保证了解的存在性和唯一性。函数 $f(x)$ 是逼近论中使用的经典例子（龙格函数）。使用勒让德多项式是在 $[-1, 1]$ 上进行最小二乘逼近的标准方法。所提出的问题是精确的，并基于数值分析和逼近论的既定数学原理。所有必要的数据和定义都已提供。因此，该问题是有效的。\n\n### 约束最小化子的推导\n设多项式 $p(x) \\in \\mathbb{P}_{2}$ 在勒让德多项式基中表示为：\n$$\np(x) = c_{0} P_{0}(x) + c_{1} P_{1}(x) + c_{2} P_{2}(x)\n$$\n其中 $P_{0}(x)=1$, $P_{1}(x)=x$, 且 $P_{2}(x)=\\frac{1}{2}(3x^2-1)$。系数 $c_0, c_1, c_2$ 是待确定的实常数。\n\n问题对 $p(x)$ 在端点 $x=1$ 处的导数施加了约束：\n$$\np'(1) = 0\n$$\n$p(x)$ 的导数为：\n$$\np'(x) = c_{0} P_{0}'(x) + c_{1} P_{1}'(x) + c_{2} P_{2}'(x)\n$$\n使用给定的形式，我们求得导数：$P_{0}'(x)=0$, $P_{1}'(x)=1$, 以及 $P_{2}'(x) = \\frac{1}{2}(6x) = 3x$。\n在 $x=1$ 处求值：$P_{0}'(1)=0$, $P_{1}'(1)=1$, $P_{2}'(1)=3$。\n约束方程变为：\n$$\np'(1) = c_{1}(1) + c_{2}(3) = c_{1} + 3c_{2} = 0\n$$\n这给出了系数之间的线性关系：$c_{1} = -3c_{2}$。\n\n将此关系代回 $p(x)$ 的表达式中：\n$$\np(x) = c_{0} P_{0}(x) + (-3c_{2}) P_{1}(x) + c_{2} P_{2}(x) = c_{0} P_{0}(x) + c_{2} \\bigl(P_{2}(x) - 3P_{1}(x)\\bigr)\n$$\n此表达式与目标形式 $p(x) = \\alpha_{0} P_{0}(x) + \\beta \\bigl(P_{2}(x) - 3 P_{1}(x)\\bigr)$ 相匹配，只需令 $\\alpha_0 = c_0$ 且 $\\beta=c_2$。\n问题现在是找到系数 $c_0, c_2$ 来最小化泛函\n$$\nJ(c_{0}, c_{2}) = \\int_{-1}^{1} \\Biggl(f(x) - \\Bigl(c_{0} P_{0}(x) + c_{2} \\bigl(P_{2}(x) - 3P_{1}(x)\\bigr)\\Bigr) \\Biggr)^{2} \\, dx\n$$\n这是一个标准的最小二乘问题，通过将函数 $f(x)$ 投影到由基函数 $\\psi_{0}(x) = P_{0}(x)$ 和 $\\psi_{1}(x) = P_{2}(x) - 3P_{1}(x)$ 张成的 $\\mathbb{P}_2$ 子空间上来解决。系数的法方程为：\n$$\n\\begin{pmatrix} \\langle \\psi_{0}, \\psi_{0} \\rangle  \\langle \\psi_{0}, \\psi_{1} \\rangle \\\\ \\langle \\psi_{1}, \\psi_{0} \\rangle  \\langle \\psi_{1}, \\psi_{1} \\rangle \\end{pmatrix} \\begin{pmatrix} c_{0} \\\\ c_{2} \\end{pmatrix} = \\begin{pmatrix} \\langle f, \\psi_{0} \\rangle \\\\ \\langle f, \\psi_{1} \\rangle \\end{pmatrix}\n$$\n其中 $\\langle g, h \\rangle = \\int_{-1}^{1} g(x)h(x) \\, dx$ 是 $[-1,1]$ 上的标准 $L^2$ 内积。\n\n我们利用勒让德多项式的正交性：$\\langle P_j, P_k \\rangle = \\frac{2}{2k+1} \\delta_{jk}$。\nGram 矩阵的非对角项为：\n$$\n\\langle \\psi_{0}, \\psi_{1} \\rangle = \\langle P_{0}, P_{2} - 3P_{1} \\rangle = \\langle P_{0}, P_{2} \\rangle - 3 \\langle P_{0}, P_{1} \\rangle = 0 - 3(0) = 0\n$$\n由于基 $\\{\\psi_0, \\psi_1\\}$ 是正交的，Gram 矩阵是对角矩阵，系数方程解耦：\n$$\nc_{0} \\langle \\psi_{0}, \\psi_{0} \\rangle = \\langle f, \\psi_{0} \\rangle \\implies c_{0} = \\frac{\\langle f, P_{0} \\rangle}{\\langle P_{0}, P_{0} \\rangle}\n$$\n$$\nc_{2} \\langle \\psi_{1}, \\psi_{1} \\rangle = \\langle f, \\psi_{1} \\rangle \\implies c_{2} = \\beta = \\frac{\\langle f, P_{2} - 3P_{1} \\rangle}{\\langle P_{2} - 3P_{1}, P_{2} - 3P_{1} \\rangle}\n$$\n我们需要计算 $\\beta$ 表达式中的各项。\n\n分母是：\n$$\n\\langle P_{2} - 3P_{1}, P_{2} - 3P_{1} \\rangle = \\langle P_{2}, P_{2} \\rangle - 6 \\langle P_{2}, P_{1} \\rangle + 9 \\langle P_{1}, P_{1} \\rangle\n$$\n利用正交性，$\\langle P_{2}, P_{1} \\rangle = 0$。利用范数公式，$\\langle P_{k}, P_{k} \\rangle = \\frac{2}{2k+1}$：\n$$\n\\langle P_{2}, P_{2} \\rangle = \\frac{2}{2(2)+1} = \\frac{2}{5} \\quad \\text{和} \\quad \\langle P_{1}, P_{1} \\rangle = \\frac{2}{2(1)+1} = \\frac{2}{3}\n$$\n所以，分母是 $\\frac{2}{5} + 9 \\left(\\frac{2}{3}\\right) = \\frac{2}{5} + 6 = \\frac{32}{5}$。\n\n分子是：\n$$\n\\langle f, P_{2} - 3P_{1} \\rangle = \\langle f, P_{2} \\rangle - 3 \\langle f, P_{1} \\rangle\n$$\n函数 $f(x) = \\frac{1}{1+\\kappa^2 x^2}$ 是关于 $x$ 的偶函数。多项式 $P_{1}(x)=x$ 是奇函数。因此，乘积 $f(x)P_{1}(x)$ 是一个奇函数，其在对称区间 $[-1, 1]$ 上的积分为零：\n$$\n\\langle f, P_{1} \\rangle = \\int_{-1}^{1} \\frac{x}{1+\\kappa^2 x^2} \\, dx = 0\n$$\n因此分子简化为 $\\langle f, P_{2} \\rangle$：\n$$\n\\langle f, P_{2} \\rangle = \\int_{-1}^{1} \\frac{1}{1+\\kappa^2 x^2} \\cdot \\frac{1}{2}(3x^2-1) \\, dx\n$$\n被积函数是偶函数，所以我们可以将积分写为：\n$$\n\\langle f, P_{2} \\rangle = 2 \\int_{0}^{1} \\frac{3x^2-1}{2(1+\\kappa^2 x^2)} \\, dx = \\int_{0}^{1} \\frac{3x^2-1}{1+\\kappa^2 x^2} \\, dx\n$$\n我们分解被积函数：\n$$\n\\frac{3x^2-1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2}\\frac{\\kappa^2 x^2}{1+\\kappa^2 x^2} - \\frac{1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2}\\frac{1+\\kappa^2 x^2-1}{1+\\kappa^2 x^2} - \\frac{1}{1+\\kappa^2 x^2}\n$$\n$$\n= \\frac{3}{\\kappa^2}\\left(1 - \\frac{1}{1+\\kappa^2 x^2}\\right) - \\frac{1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2} - \\left(\\frac{3}{\\kappa^2} + 1\\right)\\frac{1}{1+\\kappa^2 x^2} = \\frac{3}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^2}\\frac{1}{1+\\kappa^2 x^2}\n$$\n从 $0$ 到 $1$ 积分：\n$$\n\\int_{0}^{1} \\left( \\frac{3}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^2}\\frac{1}{1+\\kappa^2 x^2} \\right) dx = \\left[ \\frac{3x}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^2} \\frac{\\arctan(\\kappa x)}{\\kappa} \\right]_{0}^{1}\n$$\n$$\n= \\left( \\frac{3}{\\kappa^2} - \\frac{3+\\kappa^2}{\\kappa^3} \\arctan(\\kappa) \\right) - (0 - 0) = \\frac{3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)}{\\kappa^3}\n$$\n最后，我们组合出 $\\beta$ 的表达式：\n$$\n\\beta = \\frac{\\text{分子}}{\\text{分母}} = \\frac{\\frac{3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)}{\\kappa^3}}{\\frac{32}{5}} = \\frac{5}{32\\kappa^3} \\bigl(3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)\\bigr)\n$$\n\n### 约束可行性与渐近精度分析\n\n**约束的可行性:**\n约束 $p'(1)=0$ 是一个关于多项式 $p(x)$ 系数的线性方程。对于任意多项式次数 $N$，集合 $V_N = \\{p \\in \\mathbb{P}_N \\mid p'(1)=0\\}$ 是 $\\mathbb{P}_N$ 的一个仿射子空间。该子空间非空；例如，对于 $N \\ge 0$，任何常数多项式 $p(x)=c$ 都属于 $V_N$。最小二乘问题是在非空、闭、凸集 $V_N$ 上最小化一个严格凸泛函 $\\|f-p\\|_{L^2}^2$。根据凸优化的标准原理，保证存在唯一的最小化子。因此，该约束始终是可行的。\n\n**对渐近精度的影响:**\n对于解析函数 $f$，施加固定有限数量的线性约束（如 $p'(1)=0$）会从根本上改变逼近的渐近收敛行为。谱精度，其特征是误差随多项式次数 $N$ 呈指数级衰减（即 $\\|f-p_N\\|_{L^2} \\sim \\exp(-cN)$），将会丧失。\n\n为了从第一性原理理解这一点，令 $p_N$ 为 $f$ 到 $\\mathbb{P}_N$ 上的无约束 $L^2$-投影，$p_N^c$ 为有约束投影。可以使用拉格朗日乘子 $\\lambda$ 找到约束解。约束系数 $c_j$ 是无约束系数 $\\hat{f}_j$ 的一个扰动：\n$$\nc_j = \\hat{f}_j - \\frac{\\lambda}{2} \\frac{P_j'(1)}{\\|P_j\\|^2}\n$$\n有约束和无约束逼近之间的差值为 $p_N - p_N^c = \\frac{\\lambda}{2} \\sum_{j=0}^N \\frac{P_j'(1)}{\\|P_j\\|^2} P_j(x)$。有约束逼近的误差可以使用正交性分解为：\n$$\n\\|f - p_N^c\\|_{L^2}^2 = \\|f - p_N\\|_{L^2}^2 + \\|p_N - p_N^c\\|_{L^2}^2\n$$\n第一项 $\\|f - p_N\\|_{L^2}^2$ 是无约束谱投影的误差，对于解析函数 $f$，该项呈指数级衰减。第二项代表施加约束所带来的惩罚。可以证明它等于 $(p_N'(1))^2 / D_N$，其中 $p_N'(1)$ 是无约束逼近在 $x=1$ 处的导数（当 $N\\to\\infty$ 时收敛到 $f'(1)$），且 $D_N = \\sum_{j=1}^N \\frac{(P_j'(1))^2}{\\|P_j\\|^2}$。\n利用已知性质 $P_j'(1) = j(j+1)/2$ 和 $\\|P_j\\|^2 = 2/(2j+1)$，可以证明和 $D_N$ 随 $N$ 呈多项式增长，具体为 $D_N \\sim O(N^6)$。\n\n因此，额外的误差项 $\\|p_N - p_N^c\\|_{L^2}^2$ 以 $O(N^{-6})$ 的速度多项式衰减。总误差是一个指数衰减项和一个多项式衰减项之和。对于大的 $N$，多项式项占主导地位。因此，整体收敛率不再是指数级的，而是代数级的。施加这样的约束会用慢得多的多项式收敛率取代谱精度。",
            "answer": "$$\n\\boxed{\\frac{5}{32\\kappa^3} \\bigl(3\\kappa - (3+\\kappa^2)\\arctan(\\kappa)\\bigr)}\n$$"
        }
    ]
}