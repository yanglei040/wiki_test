{
    "hands_on_practices": [
        {
            "introduction": "虽然 Clenshaw-Curtis 求积的权重可以通过求解一个范德蒙德线性系统来确定，但当节点数 $n$ 很大时，这种方法的计算成本高昂且数值上不稳定。一个更优越的方法利用了切比雪夫多项式和离散余弦变换 (DCT) 之间的深刻联系，从而能够以 $O(n \\log n)$ 的复杂度高效地计算权重。这个实践  将指导你推导并实现这种现代算法，从而掌握构建 Clenshaw-Curtis 求积规则的核心技术。",
            "id": "3371402",
            "problem": "设 $n \\in \\mathbb{N}_0$ 并考虑在区间 $[-1,1]$ 上的 Clenshaw–Curtis 求积法则，当 $n \\ge 1$ 时有 $n+1$ 个节点 $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$（$j = 0,1,\\dots,n$），当 $n=0$ 时只有一个节点 $x_0=1$。目标是计算求积权重 $w_j$，使得对于合适的函数 $f$，近似值 $\\sum_{j=0}^n w_j f(x_j)$ 接近于 $\\int_{-1}^1 f(x)\\,dx$。您的任务是，从第一性原理出发，推导出一个复杂度为 $O(n\\log n)$ 的算法，通过利用余弦展开和第一类离散余弦变换（DCT-I）来计算权重 $w_j$，包括对端点缩放的正确处理。所有角度必须以弧度为单位。\n\n从以下基本原理开始：\n- 第一类切比雪夫多项式满足 $T_k(\\cos \\theta) = \\cos(k\\theta)$，适用于所有整数 $k \\ge 0$ 和实数 $\\theta$。\n- 对于 $k \\ge 0$，切比雪夫多项式在 $[-1,1]$ 上的精确积分为\n$$\n\\int_{-1}^1 T_k(x)\\,dx =\n\\begin{cases}\n2  \\text{若 } k = 0, \\\\\n0  \\text{若 } k \\text{ 是奇数}, \\\\\n\\dfrac{2}{1-k^2}  \\text{若 } k \\text{ 是偶数且 } k \\ge 2.\n\\end{cases}\n$$\n- 在切比雪夫网格 $\\theta_j = \\frac{\\pi j}{n}$ 上的离散余弦正交性涉及带撇和 $\\sum_{j=0}^n{}'$，其中端点 $j=0$ 和 $j=n$ 的权重为 $1/2$，即 $\\sum_{j=0}^n{}' a_j := \\frac{1}{2}a_0 + \\sum_{j=1}^{n-1} a_j + \\frac{1}{2} a_n$。未经归一化的第一类离散余弦变换（DCT-I）的特征是\n$$\n\\operatorname{DCT\\!I}[v]_k \\;=\\; 2 \\sum_{j=0}^n{}' v_j \\cos\\!\\left(\\frac{\\pi j k}{n}\\right), \\quad k=0,1,\\dots,n,\n$$\n其逆变换对于长度为 $n+1$ 的向量满足 $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$。\n\n仅使用上述基本原理，推导为什么 Clenshaw–Curtis 权重 $w_j$ 可以通过对由精确积分 $\\int_{-1}^1 T_k(x)\\,dx$ 构成的向量应用逆 DCT-I 得到，并确定从逆变换中恢复 $w_j$ 所需的精确缩放和端点处理方法。您的推导必须清楚地解释为什么最终算法的复杂度为 $O(n \\log n)$。\n\n然后，将推导出的算法在一个程序中实现。该程序对于给定的 $n$，通过适当地对奇数切比雪夫模式进行零填充，并正确缩放输出来考虑带撇和，从而在 $O(n\\log n)$ 时间内使用 DCT-I 构建权重 $w_j$。\n\n角度必须以弧度为单位。不涉及物理单位。\n\n您的程序必须评估以下测试套件并输出指定的聚合结果：\n- 测试 1（边界情况）：$n=0$。将计算出的权重与参考权重 $[2]$ 进行比较，并以浮点数形式报告最大绝对差。\n- 测试 2（小规模情况）：$n=1$。与参考权重 $[1,1]$ 进行比较，并以浮点数形式报告最大绝对差。\n- 测试 3（小规模情况）：$n=2$。与参考权重 $\\left[\\frac{1}{3},\\frac{4}{3},\\frac{1}{3}\\right]$ 进行比较，并以浮点数形式报告最大绝对差。\n- 测试 4（多项式上的精确性）：$n=7$。对于每个整数 $m$（$0 \\le m \\le 7$），评估离散矩 $\\sum_{j=0}^7 w_j T_m(x_j)$ 并将其与上面给出的精确积分 $\\int_{-1}^1 T_m(x)\\,dx$ 进行比较。以浮点数形式报告在 $m=0,1,\\dots,7$ 上的最大绝对误差。\n- 测试 5（非多项式函数）：$n=32$。使用该求积方法近似计算 $\\int_{-1}^1 e^x\\,dx$ 并与精确值 $2\\sinh(1)$ 进行比较。以浮点数形式报告绝对误差。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，“[result1,result2,result3,result4,result5]”。结果必须按顺序对应于测试 1 到 5。所有角度必须以弧度为单位。",
            "solution": "用户希望推导并实现一个 $O(n \\log n)$ 算法，用于计算具有 $n+1$ 个节点 $x_j=\\cos(\\frac{\\pi j}{n})$ 的 Clenshaw-Curtis 求积权重 $w_j$。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 求积节点：$x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$，其中 $j = 0,1,\\dots,n$，且 $n \\in \\mathbb{N}_0$。对于 $n=0$，指定单个节点 $x_0=1$。\n- 求积法则：$\\int_{-1}^1 f(x)\\,dx \\approx \\sum_{j=0}^n w_j f(x_j)$。\n- 切比雪夫多项式：$T_k(\\cos \\theta) = \\cos(k\\theta)$。\n- 切比雪夫多项式的精确积分：\n$$\nI_k := \\int_{-1}^1 T_k(x)\\,dx =\n\\begin{cases}\n2  \\text{若 } k = 0 \\\\\n0  \\text{若 } k \\text{ 是奇数} \\\\\n\\dfrac{2}{1-k^2}  \\text{若 } k \\text{ 是偶数且 } k \\ge 2\n\\end{cases}\n$$\n- 带撇和：$\\sum_{j=0}^n{}' a_j := \\frac{1}{2}a_0 + \\sum_{j=1}^{n-1} a_j + \\frac{1}{2}a_n$。\n- 第一类离散余弦变换（DCT-I）：$\\operatorname{DCT\\!I}[v]_k = 2 \\sum_{j=0}^n{}' v_j \\cos\\left(\\frac{\\pi j k}{n}\\right)$，其中 $k=0,1,\\dots,n$。\n- 逆 DCT-I 关系：对于长度为 $n+1$ 的向量 $v$，有 $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法明确且客观。它是数值分析中的一个标准问题，特别是在谱方法领域。提供的所有定义和公式都是标准且正确的。该问题是自包含的，并为其解决方案提供了所有必要信息。对于 $n=0$ 的特殊定义是明确的，并且与提供的测试用例一致。该问题不违反任何无效性标准。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### 推导与算法\n\nClenshaw-Curtis 求积法则是为了对最高 $n$ 次的多项式精确而构建的。这是通过在切比雪夫节点 $x_j$ 处用其唯一的最高 $n$ 次多项式插值 $p_n(x)$ 来近似被积函数 $f(x)$，然后精确地对 $p_n(x)$ 进行积分来实现的。如果 $f(x)$ 本身是一个最高 $n$ 次的多项式，那么 $p_n(x) = f(x)$，求积必须是精确的。\n\n因此，对于所有的切比雪夫多项式 $T_m(x)$（$m=0, 1, \\dots, n$），求积法则必须是精确的，因为 $T_m(x)$ 是一个 $m$ 次多项式。这个条件为未知权重 $w_j$ 建立了一个方程组：\n$$\n\\sum_{j=0}^n w_j T_m(x_j) = \\int_{-1}^1 T_m(x)\\,dx = I_m, \\quad \\text{对于 } m = 0, 1, \\dots, n.\n$$\n为了使该方程组与所提供的 DCT-I 的结构对齐，我们引入一个修正后的权重向量 $w'$，其中端点被缩放：$w'_0 = 2w_0$，$w'_n = 2w_n$，且当 $j=1, \\dots, n-1$ 时 $w'_j = w_j$。\n使用带撇和 $\\sum'$ 的定义，精确性条件变为：\n$$\n\\sum_{j=0}^n{}' w'_j T_m(x_j) = I_m, \\quad \\text{对于 } m = 0, 1, \\dots, n.\n$$\n代入恒等式 $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$ 和 $T_m(x_j) = \\cos\\left(\\frac{\\pi j m}{n}\\right)$：\n$$\n\\sum_{j=0}^n{}' w'_j \\cos\\left(\\frac{\\pi j m}{n}\\right) = I_m, \\quad \\text{对于 } m = 0, 1, \\dots, n.\n$$\n我们现在将其与给定的 DCT-I 定义联系起来：$\\operatorname{DCT\\!I}[v]_k = 2 \\sum_{j=0}^n{}' v_j \\cos\\left(\\frac{\\pi j k}{n}\\right)$。\n将此变换应用于我们的向量 $w'$（长度为 $n+1$），我们对每个分量 $m=0, \\dots, n$ 得到：\n$$\n(\\operatorname{DCT\\!I}[w'])_m = 2 \\sum_{j=0}^n{}' w'_j \\cos\\left(\\frac{\\pi j m}{n}\\right) = 2 I_m.\n$$\n设 $c$ 为一个长度为 $n+1$ 的向量，其元素为 $c_m = 2I_m$。上述关系为 $c = \\operatorname{DCT-I}[w']$。为了找到所求的权重 $w'$，我们必须对 $c$ 应用逆变换。问题提供了逆关系 $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$，这意味着逆 DCT-I 算子就是 DCT-I 算子本身，然后按 $1/(2n)$ 进行缩放。\n因此，我们可以通过以下方式找到 $w'$：\n$$\nw' = \\operatorname{IDCT-I}(c) = \\frac{\\operatorname{DCT-I}(c)}{2n}.\n$$\n让我们写出向量 $w'$ 的分量 $w'_j$：\n$$\nw'_j = \\frac{1}{2n} (\\operatorname{DCT-I}[c])_j = \\frac{1}{2n} \\left( 2 \\sum_{k=0}^n{}' c_k \\cos\\left(\\frac{\\pi j k}{n}\\right) \\right).\n$$\n代入 $c_k = 2I_k$：\n$$\nw'_j = \\frac{1}{2n} \\left( 2 \\sum_{k=0}^n{}' (2I_k) \\cos\\left(\\frac{\\pi j k}{n}\\right) \\right) = \\frac{2}{n} \\sum_{k=0}^n{}' I_k \\cos\\left(\\frac{\\pi j k}{n}\\right).\n$$\n展开关于 $k$ 的带撇和：\n$$\nw'_j = \\frac{2}{n} \\left[ \\frac{1}{2}I_0 + \\sum_{k=1}^{n-1} I_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + \\frac{1}{2}I_n \\cos\\left(\\pi j\\right) \\right] = \\frac{1}{n} \\left[ I_0 + 2\\sum_{k=1}^{n-1} I_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + I_n (-1)^j \\right].\n$$\n这个表达式可以被高效计算。`scipy.fft` 库提供了一个第一类逆 DCT，即 `idct(..., type=1)`，当使用 `norm='backward'`（默认值）时，对于一个长度为 $N=n+1$ 的输入向量 $Y$，它计算：\n$$\nX_j = \\frac{1}{2n} \\left[ Y_0 + 2\\sum_{k=1}^{n-1} Y_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + Y_n (-1)^j \\right].\n$$\n将其与我们关于 $w'_j$ 的表达式进行比较，我们看到如果将输入向量 $Y$ 设置为我们的积分向量 $I$（其中 $Y_k=I_k$），那么 $w'_j = 2 \\times X_j$。\n这提供了一个直接而高效的算法：\n1.  对于给定的 $n \\ge 1$，构建长度为 $n+1$ 的向量 $I$，其中 $I_k = \\int_{-1}^1 T_k(x)\\,dx$。奇数索引的元素 $I_k$ 将为零，这对应于问题中提到的“对奇数切比雪夫模式进行零填充”。\n2.  通过对 $I$ 应用逆 DCT-I 并进行缩放来计算向量 $w'$：$w' = 2 \\times \\operatorname{idct}(I, \\text{type=1})$。\n3.  通过撤销对端点的初始缩放来恢复最终的求积权重 $w_j$：$w_0 = w'_0/2$，$w_n = w'_n/2$，并且当 $j=1, \\dots, n-1$ 时 $w_j=w'_j$。\n\n特殊情况 $n=0$ 涉及一个节点 $x_0=1$。最简单的求积法则 $w_0 f(x_0)$ 应该对 $T_0(x)=1$ 精确。这要求 $w_0 T_0(1) = \\int_{-1}^1 T_0(x)dx \\implies w_0 \\cdot 1 = 2$，因此 $w_0=2$。\n\n该算法的复杂度主要由 `idct` 计算决定。DCT/IDCT 的快速实现，如 `scipy` 中的实现，基于快速傅里叶变换（FFT）算法。对于大小为 $N=n+1$ 的输入，复杂度为 $O(N \\log N)$，即 $O(n \\log n)$。所有其他步骤都是 $O(n)$，因此总体复杂度为 $O(n \\log n)$。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\nimport math\n\ndef solve():\n    \"\"\"\n    推导 Clenshaw-Curtis 权重并运行问题中指定的测试。\n    \"\"\"\n\n    def compute_weights(n: int) -> np.ndarray:\n        \"\"\"\n        在 O(n log n) 时间内为 n+1 个节点计算 Clenshaw-Curtis 求积权重。\n        \n        参数:\n            n: 求积法则的阶数，对应 n+1 个节点。\n        \n        返回:\n            一个包含 n+1 个求积权重的 numpy 数组。\n        \"\"\"\n        if not isinstance(n, int) or n  0:\n            raise ValueError(\"n 必须是非负整数。\")\n\n        if n == 0:\n            return np.array([2.0])\n\n        # 1. 构建切比雪夫多项式 T_k 精确积分的向量 I。\n        k = np.arange(n + 1)\n        Ivec = np.zeros(n + 1, dtype=float)\n\n        # 对于偶数 k，I_k = 2 / (1 - k^2)。对于奇数 k，I_k = 0。\n        # I_0 = 2 可由公式处理，因为 1 - 0^2 = 1。\n        even_indices = k[k % 2 == 0]\n        Ivec[even_indices] = 2.0 / (1.0 - even_indices**2)\n\n        # 2. 使用第一类逆 DCT 计算修正后的权重 w'。\n        # 根据推导，w'_j = 2 * idct(Ivec, type=1)_j。\n        # norm='backward' 选项提供了所需的 1/(2n) 缩放因子。\n        w_prime = 2 * fft.idct(Ivec, type=1, norm='backward')\n\n        # 3. 通过将 w' 的端点值减半来恢复最终权重 w。\n        w = w_prime\n        w[0] /= 2.0\n        w[-1] /= 2.0\n        \n        return w\n\n    # --- 测试套件 ---\n    \n    # 测试 1（边界情况）：n=0\n    n0 = 0\n    w0 = compute_weights(n0)\n    ref_w0 = np.array([2.0])\n    res1 = np.max(np.abs(w0 - ref_w0))\n\n    # 测试 2（小规模情况）：n=1\n    n1 = 1\n    w1 = compute_weights(n1)\n    ref_w1 = np.array([1.0, 1.0])\n    res2 = np.max(np.abs(w1 - ref_w1))\n\n    # 测试 3（小规模情况）：n=2\n    n2 = 2\n    w2 = compute_weights(n2)\n    ref_w2 = np.array([1/3.0, 4/3.0, 1/3.0])\n    res3 = np.max(np.abs(w2 - ref_w2))\n\n    # 测试 4（多项式上的精确性）：n=7\n    n7 = 7\n    w7 = compute_weights(n7)\n    errors7 = []\n    for m in range(n7 + 1):\n        # 节点 x_j = cos(pi*j/n)\n        nodes = np.cos(math.pi * np.arange(n7 + 1) / n7)\n        # T_m(x_j) 在节点处的值\n        Tm_at_nodes = np.cos(m * math.pi * np.arange(n7 + 1) / n7)\n        # 求积和\n        discrete_moment = np.sum(w7 * Tm_at_nodes)\n        \n        # T_m(x) 的精确积分\n        if m == 0:\n            exact_integral = 2.0\n        elif m % 2 != 0:\n            exact_integral = 0.0\n        else: # m 是偶数且 >= 2\n            exact_integral = 2.0 / (1 - m**2)\n            \n        errors7.append(np.abs(discrete_moment - exact_integral))\n    res4 = np.max(errors7)\n\n    # 测试 5（非多项式函数）：n=32\n    n32 = 32\n    w32 = compute_weights(n32)\n    nodes_32 = np.cos(math.pi * np.arange(n32 + 1) / n32)\n    f_vals = np.exp(nodes_32)\n    quadrature_approx = np.sum(w32 * f_vals)\n    exact_integral_exp = math.exp(1.0) - math.exp(-1.0) # 2*sinh(1)\n    res5 = np.abs(quadrature_approx - exact_integral_exp)\n\n    results = [res1, res2, res3, res4, res5]\n    \n    # 最终的打印语句，采用所需的确切格式。\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在数值计算中，为特定问题选择最合适的工具是一项关键技能。本练习  将 Clenshaw-Curtis 求积法与另一种高精度求积的“黄金标准”——高斯-勒让德求积法——进行直接比较。通过对一系列不同性质的函数（例如光滑函数、非光滑函数及高振荡函数）进行测试，你将对这两种方法的性能特点和适用场景建立起深刻的直观认识。",
            "id": "2378822",
            "problem": "考虑使用两种在近似理论和计算物理学中至关重要的求积法则族，对闭区间 $[-1,1]$ 上的定积分进行数值近似：基于切比雪夫节点的 Clenshaw–Curtis 求积法和基于勒让德多项式根的 Gauss–Legendre 求积法。\n\n定义：\n- 对于正整数 $m \\ge 2$，定义 $m$ 个 Chebyshev–Lobatto 节点集为 $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{m-1}\\right)$，其中 $k=0,1,\\dots,m-1$。$m$ 阶 Clenshaw–Curtis 求积法定义为在这些节点上对被积函数进行插值的、次数至多为 $m-1$ 的唯一多项式在 $[-1,1]$ 上的精确积分。\n- 对于正整数 $m \\ge 1$，$[-1,1]$ 上的 $m$ 点 Gauss–Legendre 求积法是一种具有 $m$ 个节点和正权重的求积法则，它可以精确地对次数至多为 $2m-1$ 的所有多项式进行积分。\n\n任务：\n1. 对于下面列出的每个被积函数 $f(x)$ 和指定的节点数 $m$，计算定积分 $\\int_{-1}^{1} f(x)\\,dx$ 的两种近似值：一种使用 $m$ 阶 Clenshaw–Curtis 求积法，另一种使用 $m$ 点 Gauss–Legendre 求积法。\n2. 对于每种情况，还需计算每种近似值相对于精确积分值的绝对误差。\n3. 所有三角函数中的角度必须以弧度为单位。\n\n测试集：\n- 情况 A: $f(x) = x^8 - 3x^3 + 2$，使用 $m=5$。精确积分：$\\displaystyle \\int_{-1}^{1} \\left(x^8 - 3x^3 + 2\\right)\\,dx = \\dfrac{38}{9}$。\n- 情况 B: $f(x) = |x|$，使用 $m=17$。精确积分：$\\displaystyle \\int_{-1}^{1} |x|\\,dx = 1$。\n- 情况 C: $f(x) = \\sqrt{1 - x^2}$，使用 $m=17$。精确积分：$\\displaystyle \\int_{-1}^{1} \\sqrt{1 - x^2}\\,dx = \\dfrac{\\pi}{2}$。\n- 情况 D: $f(x) = \\sin(50x)$，使用 $m=65$。精确积分：$\\displaystyle \\int_{-1}^{1} \\sin(50x)\\,dx = 0$。角度以弧度为单位。\n- 情况 E: $f(x) = e^{x}$，使用 $m=9$。精确积分：$\\displaystyle \\int_{-1}^{1} e^{x}\\,dx = e - e^{-1}$。\n\n程序要求输出：\n- 对于每种情况，按 A, B, C, D, E 的顺序，计算 Clenshaw–Curtis 近似的绝对误差和 Gauss–Legendre 近似的绝对误差。\n- 您的程序应生成单行输出，其中包含这 $10$ 个浮点数，以逗号分隔列表的形式并用方括号括起来，顺序为\n$[\\text{err}_{\\mathrm{CC,A}},\\text{err}_{\\mathrm{GL,A}},\\text{err}_{\\mathrm{CC,B}},\\text{err}_{\\mathrm{GL,B}},\\text{err}_{\\mathrm{CC,C}},\\text{err}_{\\mathrm{GL,C}},\\text{err}_{\\mathrm{CC,D}},\\text{err}_{\\mathrm{GL,D}},\\text{err}_{\\mathrm{CC,E}},\\text{err}_{\\mathrm{GL,E}}]$。",
            "solution": "问题陈述已经过严格验证，被认为是完整、一致且科学合理的。该问题定义明确，为获得唯一且有意义的解提供了所有必要的数据和定义。此问题涉及数值分析中的基本方法——Clenshaw–Curtis 和 Gauss–Legendre 求积法——这些是计算物理学的核心课题。因此，我们可以开始求解。\n\n任务是使用两种不同的求积法则，每种法则都使用指定数量的节点 $m$，来近似几个函数的定积分 $I[f] = \\int_{-1}^{1} f(x)\\,dx$，并计算每种近似的绝对误差。\n\n**Gauss–Legendre 求积法**\n\n$m$ 点 Gauss–Legendre (GL) 求积法是一种高斯型求积法，旨在实现尽可能高的代数精度。求积和由下式给出：\n$$ \\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{m} w_i f(x_i) $$\n对于给定的节点数 $m$，节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$ 都经过优化选择。节点 $x_i$ 是 $m$ 次勒让德多项式 $P_m(x)$ 的根，这些根都是实的、互不相同且位于区间 $(-1, 1)$ 内。相应的权重 $w_i$ 都是正的，其选择使得该法则对所有次数最高为 $2m-1$ 的多项式都是精确的。这种高精确度使得 Gauss–Legendre 求积法对于解析函数异常高效。\n\n在计算中，节点和权重不是从第一性原理计算得出，而是从预先计算好的值或可靠的数值库中获取。在本例中，我们使用 `scipy.special.roots_legendre` 函数，该函数为节点和权重提供了高精度的值。\n\n**Clenshaw–Curtis 求积法**\n\nClenshaw–Curtis (CC) 求积法是一种基于函数在切比雪夫多项式级数中展开的插值型求积法则。其节点选择为 Chebyshev–Lobatto 点，即 $m-1$ 次切比雪夫多项式 $T_{m-1}(x)$ 的极值点：\n$$ x_k = \\cos\\left(\\frac{k\\pi}{m-1}\\right) \\quad \\text{for } k = 0, 1, \\dots, m-1 $$\n该方法的工作原理是构造一个次数至多为 $m-1$ 的唯一多项式 $p_{m-1}(x)$，该多项式在这 $m$ 个节点上对函数 $f(x)$ 进行插值。然后用该插值多项式的精确积分来近似 $f(x)$ 的积分：\n$$ \\int_{-1}^{1} f(x)\\,dx \\approx \\int_{-1}^{1} p_{m-1}(x)\\,dx $$\n插值多项式 $p_{m-1}(x)$ 可以表示为切比雪夫多项式的有限和：\n$$ p_{m-1}(x) = \\sum_{j=0}^{m-1} a_j T_j(x) $$\n系数 $\\{a_j\\}$ 可以通过节点处的函数值 $\\{f(x_k)\\}$ 高效地确定，`numpy.polynomial.chebyshev.chebfit` 例程适用于此目的。一旦系数已知，便可利用已知的切比雪夫多项式解析积分来计算积分：\n$$ \\int_{-1}^{1} T_j(x)\\,dx = \\begin{cases} \\frac{2}{1-j^2}  \\text{if } j \\text{ is even} \\\\ 0  \\text{if } j \\text{ is odd} \\end{cases} $$\n将此代入级数的积分中，得到 Clenshaw–Curtis 近似值：\n$$ I_{CC} = \\int_{-1}^{1} \\sum_{j=0}^{m-1} a_j T_j(x)\\,dx = \\sum_{j=0, \\, j \\text{ even}}^{m-1} a_j \\frac{2}{1-j^2} $$\n$m$ 阶 CC 法则的代数精度为 $m-1$。虽然对于相同的 $m$，这低于 GL 求积法，但 CC 具有其他优点，例如其节点的嵌套特性以及通过基于快速傅里叶变换 (FFT) 的方法实现的高效率。\n\n**计算步骤**\n\n对于指定的五个测试用例中的每一个：\n1.  **定义输入**：定义函数 $f(x)$、节点数 $m$ 以及积分的精确值 $I_{exact}$。\n2.  **Gauss–Legendre 近似**：\n    a. 使用 `scipy.special.roots_legendre(m)` 获取 $m$ 个 GL 节点和权重。\n    b. 计算近似积分 $I_{GL} = \\sum_{i=0}^{m-1} w_i f(x_i)$。\n    c. 计算绝对误差 $\\text{err}_{GL} = |I_{GL} - I_{exact}|$。\n3.  **Clenshaw–Curtis 近似**：\n    a. 生成 $m$ 个 CC 节点 $x_k = \\cos(k\\pi/(m-1))$。\n    b. 在这些节点上计算函数值，得到 $y_k = f(x_k)$。\n    c. 使用 `numpy.polynomial.chebyshev.chebfit` 计算次数为 $m-1$ 的插值多项式的切比雪夫系数 $\\{a_j\\}$。\n    d. 通过对偶数索引的系数求和来计算近似积分 $I_{CC}$。\n    e. 计算绝对误差 $\\text{err}_{CC} = |I_{CC} - I_{exact}|$。\n4.  **整理结果**：将每种情况的两个误差值 $\\text{err}_{CC}$ 和 $\\text{err}_{GL}$ 按指定顺序存储。\n\n**预期性能分析**\n-   **情况 A ($f(x) = x^8 - 3x^3 + 2, m=5$)**：被积函数是一个 8 次多项式。5 点 GL 法则对次数最高为 $2(5)-1=9$ 的多项式是精确的。因此，误差 $\\text{err}_{GL}$ 预计为零（在机器精度范围内）。5 阶 CC 法则对次数最高为 4 的多项式是精确的，因此 $\\text{err}_{CC}$ 将不为零。\n-   **情况 B ($f(x) = |x|, m=17$)**：该函数在 $x=0$ 处存在导数不连续点，这限制了两种方法的收敛速度。高阶精度会丢失。\n-   **情况 C ($f(x) = \\sqrt{1 - x^2}, m=17$)**：该函数在端点 $x=\\pm 1$ 处有导数奇异点。变量替换 $x=\\cos\\theta$（这在 CC 的公式中是隐含的）将被积函数转换为一个光滑的周期函数 $\\sin^2\\theta$。预计 CC 对这种情况会异常精确。\n-   **情况 D ($f(x) = \\sin(50x), m=65$)**：这是一个高振荡的解析函数。两种方法都应能提供良好的近似，但高频率需要足够多的点来解析振荡。对于此类光滑函数，GL 通常更优越。\n-   **情况 E ($f(x) = e^x, m=9$)**：被积函数是一个整函数（处处解析）。两种方法都将表现出快速（指数级）收敛。对于给定的 $m$，由于其更高的代数精度，GL 预计会显著更准确。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom numpy.polynomial.chebyshev import chebfit\n\ndef solve():\n    \"\"\"\n    Computes and compares the accuracy of Clenshaw-Curtis and Gauss-Legendre\n    quadratures for a suite of test integrals.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"func\": lambda x: x**8 - 3*x**3 + 2,\n            \"m\": 5,\n            \"exact\": 38.0 / 9.0\n        },\n        {\n            \"name\": \"B\",\n            \"func\": lambda x: np.abs(x),\n            \"m\": 17,\n            \"exact\": 1.0\n        },\n        {\n            \"name\": \"C\",\n            \"func\": lambda x: np.sqrt(1 - x**2),\n            \"m\": 17,\n            \"exact\": np.pi / 2.0\n        },\n        {\n            \"name\": \"D\",\n            \"func\": lambda x: np.sin(50 * x),\n            \"m\": 65,\n            \"exact\": 0.0\n        },\n        {\n            \"name\": \"E\",\n            \"func\": lambda x: np.exp(x),\n            \"m\": 9,\n            \"exact\": np.e - 1.0/np.e\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f = case[\"func\"]\n        m = case[\"m\"]\n        exact_val = case[\"exact\"]\n\n        # --- Gauss-Legendre Quadrature ---\n        # The scipy function returns nodes and weights for the m-point rule.\n        gl_nodes, gl_weights = roots_legendre(m)\n        \n        # Approximate the integral by summing f(x_i) * w_i\n        gl_approx = np.sum(gl_weights * f(gl_nodes))\n        \n        # Calculate the absolute error.\n        err_gl = np.abs(gl_approx - exact_val)\n\n        # --- Clenshaw-Curtis Quadrature ---\n        # Get the m Chebyshev-Lobatto nodes.\n        # These are the extrema of the Chebyshev polynomial T_{m-1}(x).\n        cc_nodes = np.cos(np.arange(m) * np.pi / (m - 1))\n        \n        # Evaluate the function at the nodes.\n        cc_vals = f(cc_nodes)\n        \n        # Compute the coefficients of the Chebyshev series that interpolates\n        # the function at the nodes. The degree of interpolant is m-1.\n        # `chebfit` is used for this purpose.\n        # For interpolation at Chebyshev nodes, least squares fit is equivalent to interpolation.\n        coeffs = chebfit(cc_nodes, cc_vals, m - 1)\n        \n        # Integrate the Chebyshev series expansion.\n        # The integral of a Chebyshev polynomial T_j(x) over [-1, 1] is\n        # 2/(1-j^2) for j even, and 0 for j odd.\n        cc_approx = 0.0\n        for j in range(0, m, 2):\n            cc_approx += coeffs[j] * (2.0 / (1.0 - j**2))\n            \n        # Calculate the absolute error.\n        err_cc = np.abs(cc_approx - exact_val)\n\n        results.extend([err_cc, err_gl])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上完美的数学公式在实际应用中可能会因有限精度的浮点运算而出错。本练习  旨在解决实施求积法则时一个关键但常被忽视的问题：由下溢和舍入误差引起的精度损失。你将学习如何通过预缩放和补偿求和等技巧来构建一个数值稳健的求积程序，以确保即使在极端情况下也能获得准确的结果。",
            "id": "3260837",
            "problem": "您的任务是实现一个数值稳定的克伦肖-柯蒂斯（Clenshaw–Curtis）求积程序，以逼近函数在区间 $[-1,1]$ 上的定积分。需要解决的核心数值问题是，经典的克伦肖-柯蒂斯权重公式会产生在端点附近非常小的值，当被积函数额外乘以一个极小的因子时，单个项的贡献在浮点运算中可能因下溢而变为零，而真实的积分值仍然是可表示的。您的实现必须包含对系数和乘数进行原则性的预缩放，以使所有中间贡献保持可表示，并且最终的聚合在数值上是稳健的。\n\n从以下基础出发：\n- 定积分定义 $\\int_{-1}^{1} f(x)\\,dx$ 以及多项式插值的思想。\n- 第一类切比雪夫多项式 $T_k(x)$，定义为 $T_k(\\cos\\theta) = \\cos(k\\theta)$。\n- 余弦函数在网格点 $\\theta_k = \\pi k / n$（$k=0,1,\\ldots,n$）上的离散正交性，以及在切比雪夫节点上对函数进行插值会得到插值多项式的截断切比雪夫级数这一事实。\n- 切比雪夫多项式在 $[-1,1]$ 上的精确积分：$\\int_{-1}^{1} T_0(x)\\,dx = 2$，当 $k$ 为奇数时 $\\int_{-1}^{1} T_k(x)\\,dx = 0$，当 $k\\ge 2$ 为偶数时 $\\int_{-1}^{1} T_k(x)\\,dx = \\dfrac{2}{1-k^2}$。\n\n设计要求：\n1. 基于这些原则，推导出一个算法，该算法能够：\n   - 在切比雪夫节点 $x_k = \\cos(\\pi k / n)$ 上对 $f$ 进行采样。\n   - 计算第一类离散余弦变换，以获得插值多项式 $p_n(x) \\approx f(x)$ 的切比雪夫系数 $A_m$，使得 $p_n(\\cos\\theta) = \\sum_{m=0}^n A_m \\cos(m\\theta)$，其综合规则在端点处减半：$p_n(\\cos\\theta_k) = \\frac{A_0}{2} + \\sum_{m=1}^{n-1} A_m \\cos(m\\theta_k) + \\frac{A_n}{2}\\cos(n\\theta_k)$。\n   - 使用 $T_k(x)$ 的精确积分来构造求积近似值 $\\int_{-1}^{1} f(x)\\,dx \\approx \\frac{A_0}{2}\\cdot 2 + \\sum_{\\substack{m=2 \\\\ m\\ \\text{even}}}^{n-2} A_m \\cdot \\frac{2}{1-m^2} + \\mathbf{1}_{\\{n\\ \\text{even}\\}} \\cdot \\frac{A_n}{2} \\cdot \\frac{2}{1-n^2}$，其中 $\\mathbf{1}_{\\{n\\ \\text{even}\\}}$ 在 $n$ 为偶数时为 $1$，否则为 $0$。\n\n2. 实现一个数值稳定策略，以防止下溢并提高求和精度：\n   - 预缩放积分乘数 $\\mu_m$，定义为 $\\mu_0 = 2$，当 $m\\ge 2$ 为偶数时 $\\mu_m = \\dfrac{2}{1-m^2}$，$m$ 为奇数时 $\\mu_m = 0$，若 $n$ 为偶数则 $\\mu_n = \\dfrac{2}{1-n^2}$，否则 $\\mu_n = 0$。具体而言，在与 $A_m$ 相乘之前，将所有 $\\mu_m$ 除以一个公共尺度 $s = \\max_m |\\mu_m|$，累加缩放后的贡献，然后将最终的和乘以 $s$。这可以使中间乘积保持在可表示的范围内，并降低下溢的风险。\n   - 在累加各项时应用补偿求和（例如，Kahan 求和）以减少相消产生的舍入误差。\n   - 如果指定了外部被积函数缩放因子 $\\alpha$，不要在计算切比雪夫系数之前将其应用于函数值。而应在最后将最终的积分近似值乘以 $\\alpha$。这可以避免中间步骤过早出现下溢，同时保持积分的正确缩放。\n\n3. 程序必须是自包含的，并为以下测试套件生成结果。每个测试用例是一个元组 $(n, f, \\alpha)$，其中 $n$ 是决定 $n+1$ 个切比雪夫节点的子区间整数数量，$f$ 是在 $[-1,1]$ 上定义的被积函数，$\\alpha$ 是应用于最终积分的正实数缩放因子：\n   - 案例 1（正常路径）：$(n=32, f(x) = e^{x}, \\alpha = 1.0)$。精确值为 $\\int_{-1}^{1} e^{x}\\,dx = e - e^{-1}$。\n   - 案例 2（光滑有理函数）：$(n=64, f(x) = \\dfrac{1}{1+x^2}, \\alpha = 1.0)$。精确值为 $\\int_{-1}^{1} \\dfrac{1}{1+x^2}\\,dx = \\arctan(1) - \\arctan(-1) = \\dfrac{\\pi}{2}$。\n   - 案例 3（高振荡但有界）：$(n=1024, f(x) = \\cos(100 x), \\alpha = 1.0)$。精确值为 $\\int_{-1}^{1} \\cos(100 x)\\,dx = \\dfrac{\\sin(100)}{100} - \\left(-\\dfrac{\\sin(100)}{100}\\right) = \\dfrac{2\\sin(100)}{100}$，角度以弧度为单位。\n   - 案例 4（端点消失）：$(n=128, f(x) = (1-x^2)^{10}, \\alpha = 1.0)$。该函数是解析的并在端点处为零，展示了该方法对于光滑代数衰减的稳定性。\n   - 案例 5（通过外部缩放进行下溢压力测试）：$(n=1024, f(x) = e^{0.5 x}, \\alpha = 10^{-320})$。此案例强制使用极小的缩放比例，可能导致朴素实现中端点附近的节点-权重乘积下溢；您的预缩放策略必须保持中间贡献的可表示性，并仅在最后应用该小因子。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个条目必须是一个浮点数（采用标准十进制或科学记数法），对应于相应案例的稳定克伦肖-柯蒂斯近似值，并按上述顺序列出。例如：`\"[result1,result2,result3,result4,result5]\"`。\n- 输出中无需报告任何物理单位或角度，但任何三角函数都应以弧度进行计算。\n\n约束条件：\n- 仅使用 Python 标准库和指定版本的 NumPy 库进行数组和基本数值运算。\n- 实现必须对中间乘积的下溢具有稳健性，并通过补偿求和减少舍入误差。",
            "solution": "该问题要求实现一个数值稳定的克伦肖-柯蒂斯(Clenshaw-Curtis)求积程序。下面将介绍问题的验证和后续的解决方案。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n问题陈述提供了以下信息：\n-   **待逼近积分**：$\\int_{-1}^{1} f(x)\\,dx$。\n-   **方法论**：基于在切比雪夫节点上进行多项式插值的求积法。\n-   **基础**：\n    -   第一类切比雪夫多项式：$T_k(x)$，定义为 $T_k(\\cos\\theta) = \\cos(k\\theta)$。\n    -   插值节点：$x_k = \\cos(\\pi k / n)$，其中 $k=0,1,\\ldots,n$。\n    -   插值多项式表示：$p_n(\\cos\\theta) = \\sum_{m=0}^n A_m \\cos(m\\theta)$，在节点上的求值由综合规则 $p_n(\\cos\\theta_k) = \\frac{A_0}{2} + \\sum_{m=1}^{n-1} A_m \\cos(m\\theta_k) + \\frac{A_n}{2}\\cos(n\\theta_k)$ 给出。\n    -   切比雪夫系数计算：通过第一类离散余弦变换 (DCT-I)。\n    -   切比雪夫多项式的精确积分：$\\int_{-1}^{1} T_0(x)\\,dx = 2$；当 $k \\ge 1$ 为奇数时 $\\int_{-1}^{1} T_k(x)\\,dx = 0$；当 $k \\ge 2$ 为偶数时 $\\int_{-1}^{1} T_k(x)\\,dx = \\dfrac{2}{1-k^2}$。\n    -   建议的求积公式：$\\int_{-1}^{1} f(x)\\,dx \\approx \\frac{A_0}{2}\\cdot 2 + \\sum_{\\substack{m=2 \\\\ m\\ \\text{even}}}^{n-2} A_m \\cdot \\frac{2}{1-m^2} + \\mathbf{1}_{\\{n\\ \\text{even}\\}} \\cdot \\frac{A_n}{2} \\cdot \\frac{2}{1-n^2}$。\n-   **数值稳定性要求**：\n    1.  用 $s = \\max_m |\\mu_m|$ 对积分乘数 $\\mu_m$ 进行预缩放。\n    2.  使用补偿求和（例如 Kahan 求和）来累加各项。\n    3.  将任何外部被积函数缩放因子 $\\alpha$ 应用于最终计算出的积分，而不是一开始就应用于函数值。\n-   **测试套件**：由 $(n, f, \\alpha)$ 定义的五个测试用例集：\n    1.  $(n=32, f(x) = e^{x}, \\alpha = 1.0)$\n    2.  $(n=64, f(x) = \\dfrac{1}{1+x^2}, \\alpha = 1.0)$\n    3.  $(n=1024, f(x) = \\cos(100 x), \\alpha = 1.0)$\n    4.  $(n=128, f(x) = (1-x^2)^{10}, \\alpha = 1.0)$\n    5.  $(n=1024, f(x) = e^{0.5 x}, \\alpha = 10^{-320})$\n-   **输出格式**：一个单行的、以逗号分隔的浮点数结果列表，用方括号括起来：`\"[result1,result2,result3,result4,result5]\"`。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据标准验证准则对问题陈述进行评估。\n1.  **科学性与事实合理性**：该问题基于数值分析的既定理论，特别是谱方法和求积法。切比雪夫插值的原理、切比雪夫多项式的性质、它们与离散余弦变换的关系以及引用的积分公式在事实上都是正确的。所描述的数值问题（下溢、舍入误差）和建议的补救措施（缩放、补偿求和）是科学计算中的标准关注点和技术。\n2.  **完整性与一致性**：问题提供了构建解决方案所需的所有必要信息。它定义了节点、求系数的方法、基函数的积分以及稳定策略。在示例求积公式的求和上限（$\\sum^{n-2}$）上存在一个微小的不精确之处，这个上限对于偶数和奇数 $n$ 并非普遍正确。然而，问题明确指示要“基于这些原则，推导出一个算法……”，这要求从提供的坚实基础原则中推导出正确的公式。这一指令取代了那个略有瑕疵的示例，使得问题规范连贯且可按预期解决。核心原则是一致和完整的。\n3.  **适定性与客观性**：问题是适定的；对于每个测试用例，都期望得到一个唯一的数值答案。任务是客观且精确定义的，没有模糊性或主观因素。测试用例是具体的，用于验证实现的不同方面（准确性、稳定性、对振荡和下溢的处理）。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。这是一个在数值方法领域中定义明确的问题，具有科学合理性、内部一致性和完整性。我现在将着手解决该问题。\n\n### 算法推导与实现策略\n\n克伦肖-柯蒂斯求积法通过对插值于被积函数 $f(x)$ 的多项式 $p_n(x)$ 在特定点集上进行积分来逼近定积分 $\\int_{-1}^{1} f(x)\\,dx$。\n\n**1. 切比雪夫插值**\n次数至多为 $n$ 的插值多项式 $p_n(x)$ 被构造成在 $n+1$ 个切比雪夫-高斯-洛巴托节点上与函数 $f(x)$ 匹配，这些节点是 $n$ 次切比雪夫多项式 $T_n(x)$ 的极值点：\n$$x_k = \\cos\\left(\\frac{\\pi k}{n}\\right) \\quad \\text{for} \\quad k=0, 1, \\ldots, n$$\n该多项式 $p_n(x)$ 可以表示为一个有限切比雪夫级数：\n$$p_n(x) = \\sum_{m=0}^{n} '' c_m T_m(x)$$\n其中双撇号表示和的第一项和最后一项减半：$c_0/2$ 和 $c_n/2$。\n\n**2. 切比雪夫系数的计算**\n插值多项式的切比雪夫级数系数 $c_m$ 由在节点上求值的函数值 $f(x_k)$ 的第一类离散余弦变换（DCT-I）确定：\n$$c_m = \\frac{2}{n} \\sum_{k=0}^{n} '' f(x_k) \\cos\\left(\\frac{m k \\pi}{n}\\right) = \\frac{2}{n} \\left[ \\frac{f(x_0)}{2} + \\sum_{k=1}^{n-1} f(x_k) \\cos\\left(\\frac{m k \\pi}{n}\\right) + \\frac{(-1)^m f(x_n)}{2} \\right]$$\n在问题的表示法中，这些系数被标记为 $A_m$。我们将遵循此表示法，并计算 $A_m=c_m$，其中 $m=0, \\ldots, n$。\n\n**3. 插值多项式的积分**\n$f(x)$ 的积分通过 $p_n(x)$ 的精确积分来逼近：\n$$\\int_{-1}^{1} f(x)\\,dx \\approx \\int_{-1}^{1} p_n(x)\\,dx = \\int_{-1}^{1} \\left( \\sum_{m=0}^{n} '' A_m T_m(x) \\right) dx$$\n根据积分的线性性质，这变为：\n$$\\int_{-1}^{1} p_n(x)\\,dx = \\sum_{m=0}^{n} '' A_m \\int_{-1}^{1} T_m(x)\\,dx = \\frac{A_0}{2}\\int_{-1}^{1} T_0(x)\\,dx + \\sum_{m=1}^{n-1} A_m \\int_{-1}^{1} T_m(x)\\,dx + \\frac{A_n}{2}\\int_{-1}^{1} T_n(x)\\,dx$$\n代入已知的切比雪夫多项式的精确积分：\n-   $\\int_{-1}^{1} T_0(x)\\,dx = 2$\n-   当 $m \\ge 1$ 为奇数时 $\\int_{-1}^{1} T_m(x)\\,dx = 0$\n-   当 $m \\ge 2$ 为偶数时 $\\int_{-1}^{1} T_m(x)\\,dx = \\frac{2}{1-m^2}$\n\n和式简化为：\n$$I \\approx \\frac{A_0}{2}(2) + \\sum_{\\substack{m=2 \\\\ m \\text{ even}}}^{n-1} A_m \\frac{2}{1-m^2} + \\begin{cases} \\frac{A_n}{2} \\cdot \\frac{2}{1-n^2}  \\text{if } n \\text{ is even} \\\\ 0  \\text{if } n \\text{ is odd} \\end{cases}$$\n合并各项，积分近似值由对偶数索引 $m$ 的求和给出：\n$$I \\approx A_0 + \\sum_{\\substack{m=2 \\\\ m \\text{ even}}}^{n} A_m \\frac{2}{1-m^2} \\quad (\\text{if } n \\text{ is even, the } m=n \\text{ term is } A_n \\frac{2}{1-n^2})$$\n这个公式可以通过定义一个与每个 $A_m$ 对应的积分系数向量 $w_m$ 来紧凑地表示：\n-   $w_0 = 1$\n-   当 $m \\ge 1$ 为奇数时 $w_m = 0$\n-   当 $m \\ge 2$ 为偶数时 $w_m = \\frac{2}{1-m^2}$\n积分则为 $I \\approx \\sum_{m=0}^n A_m w_m$。这与问题中的示例公式略有不同；这个推导出的版本对所有 $n$ 都正确，并将被实现。每个 $A_m$ 的贡献是 $A_m \\cdot w_m$。\n\n**4. 数值稳定性**\n实现必须解决潜在的浮点不精确问题。\n\n-   **处理外部缩放**：对于给定的缩放因子 $\\alpha$，使用恒等式 $\\int \\alpha f(x) dx = \\alpha \\int f(x) dx$。首先计算 $f(x)$ 的积分，然后将最终结果乘以 $\\alpha$。这可以防止在 $\\alpha$ 非常小的情况下函数值 $f(x_k)$ 下溢为零，从而破坏 DCT 并导致错误的积分为零。\n\n-   **预缩放与补偿求和**：要求和的项是 $A_m w_m$。对于大的偶数 $m$，权重 $w_m = \\frac{2}{1-m^2}$ 会变得非常小，它们与 $A_m$ 的乘积可能会下溢。为防止这种情况，我们对乘积进行缩放。问题建议缩放乘数，这里表示为 $w_m$。缩放因子是 $s = \\max_m |w_m|$。观察值 $w_0=1, w_2=-2/3, w_4=-2/15, \\ldots$，最大绝对值显然是 $s=1$。然而，问题陈述使用了基于公式结构 $\\sum c_m \\mu_m$ 的不同乘数定义。让我们严格遵循为乘数提供的原则。相加的项形式为 $(\\text{系数}) \\times (\\text{基函数的积分})$。基函数是 $T_m(x)$，它们的积分是 $\\mu_m^* = \\int T_m(x)dx$。级数的系数是 $c_m^{\\text{series}} = A_m$ 对于 $1 \\le m \\le n-1$，以及 $c_0^{\\text{series}}=A_0/2$, $c_n^{\\text{series}}=A_n/2$。和是 $\\sum_{m=0}^n c_m^{\\text{series}} \\mu_m^*$。这些乘数的缩放因子是 $s = \\max_m |\\mu_m^*| = |\\mu_0^*| = 2$。\n因此，数值稳健的求和是：\n$$I = s \\cdot \\sum_{m=0}^{n} \\left( c_m^{\\text{series}} \\cdot \\frac{\\mu_m^*}{s} \\right)$$\n求和本身将使用 Kahan 补偿求和算法来最小化舍入误差，特别是在加法中数字量级不同时。Kahan 求和为每次加法中丢失的低位比特维持一个运行补偿项。\n\n最终算法是：\n1.  给定 $(n, f, \\alpha)$，计算节点 $x_k$ 和函数值 $f(x_k)$。\n2.  从 $f(x_k)$ 计算 $m=0, \\ldots, n$ 的 DCT-I 系数 $A_m$。\n3.  通过将 $A_0$ 和 $A_n$ 减半来形成级数系数 $c_m^{\\text{series}}$。\n4.  定义积分乘数 $\\mu_m^* = \\int_{-1}^1 T_m(x) dx$。\n5.  设置缩放因子 $s=2$。\n6.  使用 Kahan 求和计算 $S = \\sum_{m=0}^n c_m^{\\text{series}} \\cdot (\\mu_m^*/s)$。\n7.  积分为 $I = s \\cdot S$。\n8.  最终结果是 $\\alpha \\cdot I$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _clenshaw_curtis_stable(n: int, f, alpha: float) -> float:\n    \"\"\"\n    Computes the definite integral of f(x) from -1 to 1 using a numerically\n    stabilized Clenshaw-Curtis quadrature routine.\n\n    Args:\n        n: The number of subintervals, determining n+1 Chebyshev nodes.\n        f: The integrand, a callable function.\n        alpha: A final scaling factor for the integral.\n\n    Returns:\n        The approximate value of alpha * integral(f(x), -1, 1).\n    \"\"\"\n    if n == 0:\n        # The integral of a constant f(0) over [-1, 1] is 2 * f(0).\n        return alpha * 2.0 * f(1.0) # node is x_0=cos(0)=1\n\n    # Step 1: Evaluate function at Chebyshev-Gauss-Lobatto nodes\n    k = np.arange(n + 1, dtype=float)\n    nodes = np.cos(np.pi * k / n)\n    f_values = f(nodes)\n\n    # Step 2: Compute Chebyshev coefficients A_m using a direct DCT-I sum\n    # This is equivalent to `scipy.fft.dct(f_values, type=1)` but avoids the dependency.\n    # The formula is A_m = (2/n) * sum_{k=0 to n}'' f(x_k) cos(m*k*pi/n)\n    f_values_halved = f_values.copy()\n    f_values_halved[0] /= 2.0\n    f_values_halved[-1] /= 2.0\n    \n    A_m = np.zeros(n + 1)\n    # Vectorized computation for all m\n    m_grid, k_grid = np.meshgrid(np.arange(n + 1), np.arange(n + 1))\n    cos_matrix = np.cos(np.pi * m_grid * k_grid / n)\n    A_m = (2.0 / n) * np.dot(cos_matrix, f_values_halved)\n\n    # Step 3: Form the coefficients for the Chebyshev series expansion\n    # p_n(x) = sum_{m=0 to n}'' A_m T_m(x)\n    # The series coefficients c_m are A_m with endpoints halved.\n    c_m = A_m.copy()\n    c_m[0] /= 2.0\n    c_m[n] /= 2.0\n    \n    # Step 4: Define integration multipliers mu*_m = integral(T_m(x), -1, 1)\n    mu_star = np.zeros(n + 1)\n    mu_star[0] = 2.0\n    even_indices = np.arange(2, n + 1, 2)\n    mu_star[even_indices] = 2.0 / (1.0 - even_indices**2)\n\n    # Step 5-7: Perform scaled, compensated summation\n    # The terms to sum are c_m * mu_star.\n    # Scale factor s = max(|mu_star|) = |mu_star[0]| = 2.0\n    s_scale = 2.0\n    \n    terms_to_sum = c_m * (mu_star / s_scale)\n    \n    # Kahan summation\n    k_sum = 0.0\n    k_compensation = 0.0\n    for term in terms_to_sum:\n        y = term - k_compensation\n        t = k_sum + y\n        k_compensation = (t - k_sum) - y\n        k_sum = t\n\n    # Step 8: Compute the unscaled integral\n    integral = s_scale * k_sum\n    \n    # Step 9: Apply the external scaling factor alpha\n    return alpha * integral\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, lambda x: np.exp(x), 1.0),\n        (64, lambda x: 1.0 / (1.0 + x**2), 1.0),\n        (1024, lambda x: np.cos(100.0 * x), 1.0),\n        (128, lambda x: (1.0 - x**2)**10, 1.0),\n        (1024, lambda x: np.exp(0.5 * x), 1e-320)\n    ]\n\n    results = []\n    for n, func, alpha in test_cases:\n        result = _clenshaw_curtis_stable(n, func, alpha)\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}