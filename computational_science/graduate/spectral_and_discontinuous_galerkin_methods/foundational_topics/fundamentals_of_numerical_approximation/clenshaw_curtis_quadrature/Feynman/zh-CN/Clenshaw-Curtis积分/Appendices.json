{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你从第一性原理出发，构建一个 Clenshaw–Curtis 求积法则。通过强制要求该求积法则必须精确积分一组简单的多项式，你将通过求解一个线性方程组来推导出求积权重 。这个实践过程将加深你对插值型求积法则及其精度阶概念的理解。",
            "id": "3405824",
            "problem": "您的任务是构建一个基于 Chebyshev–Lobatto 点的插值型求积法则，该法则常用于谱方法和间断 Galerkin (DG) 方法中，在参考单元上进行多项式逼近。目标是计算在区间 $[-1,1]$ 上，具有 $N=5$ 个节点的 Clenshaw–Curtis 求积法则的权重，并凭经验确定该法则能精确积分的最高多项式次数（精度阶）。\n\n基本原理：\n- 区间 $[-1,1]$ 上的一个求积法则由节点 $\\{x_k\\}_{k=0}^{N-1} \\subset [-1,1]$ 和权重 $\\{w_k\\}_{k=0}^{N-1}$ 定义，使得\n$$\nQ_N[f] \\equiv \\sum_{k=0}^{N-1} w_k\\, f(x_k) \\approx \\int_{-1}^{1} f(x)\\, dx.\n$$\n- Chebyshev–Lobatto 节点（也称为 Chebyshev 多项式的极值点）定义为\n$$\nx_k = \\cos\\left(\\frac{\\pi k}{N-1}\\right), \\quad k=0,1,\\dots,N-1,\n$$\n这些点位于 $[-1,1]$ 内，并包括端点 $\\pm 1$。\n- 由节点 $\\{x_k\\}_{k=0}^{N-1}$ 决定的插值型求积法则，其唯一特征是要求对所有次数直到 $N-1$ 的单项式都精确成立，即\n$$\n\\sum_{k=0}^{N-1} w_k\\, x_k^m \\;=\\; \\int_{-1}^{1} x^m \\, dx \\quad \\text{对于所有 } m=0,1,\\dots,N-1,\n$$\n其中矩为\n$$\n\\int_{-1}^{1} x^m \\, dx =\n\\begin{cases}\n0,  \\text{若 } m \\text{ 为奇数},\\\\\n\\dfrac{2}{m+1},  \\text{若 } m \\text{ 为偶数}。\n\\end{cases}\n$$\n- 求积法则的精度阶 $d$ 是指该法则能精确积分所有次数 $\\deg(p)\\le d$ 的多项式 $p(x)$ 的最大整数，即对于每个次数至多为 $d$ 的多项式 $p$，都有 $\\sum_{k=0}^{N-1} w_k\\, p(x_k) = \\int_{-1}^{1} p(x)\\, dx$。\n\n任务：\n1. 使用上述定义，通过对单项式 $\\{1, x, x^2, x^3, x^4\\}$ 强制精确性，构建在 $[-1,1]$ 上 $N=5$ 个节点的 Clenshaw–Curtis 求积权重 $\\{w_k\\}_{k=0}^{4}$。\n2. 通过从 $m=0,1,2,\\dots$ 开始依次测试单项式 $x^m$，直到首次出现不精确的情况，凭经验确定此 $N=5$ 求积法则能精确积分的最高多项式次数。精确性必须以与解析矩的绝对误差在 $10^{-12}$ 内为标准来判断。\n3. 在谱方法和间断 Galerkin (DG) 方法的背景下，评论 Chebyshev–Lobatto 节点的选择如何与最小化 Runge 现象以及促进稳定的插值和求积相关联。\n\n测试套件和输出规范：\n- 您的程序必须执行以下测试用例，每个用例由一对 $(N, M_{\\max})$ 指定，其中 $N$ 是 Chebyshev–Lobatto 节点的数量，$M_{\\max}$ 是要测试精确性的最大单项式次数：\n    - 测试用例 1 (正常路径): $(N, M_{\\max}) = (5, 12)$。\n    - 测试用例 2 (边界情况): $(N, M_{\\max}) = (2, 6)$。\n    - 测试用例 3 (奇数 $N$ 的边缘情况，节点数超过五个): $(N, M_{\\max}) = (7, 16)$。\n- 对于每个测试用例，通过求解次数直到 $N-1$ 的单项式的精确性条件来构建插值型求积权重，通过检查次数直到 $M_{\\max}$ 的单项式来评估经验精度阶，并以包含以下内容的列表形式返回结果：\n    - 整数 $N$,\n    - 与节点 $\\{x_k\\}_{k=0}^{N-1}$ 自然顺序对应的 $N$ 个浮点数权重列表,\n    - 整数经验精度阶 $d$。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，格式化为不含空格、用方括号括起来的逗号分隔列表。例如：\n$$\n\\text{输出: }[[N_1,[w_{1,0},\\dots,w_{1,N_1-1}],d_1],[N_2,[w_{2,0},\\dots,w_{2,N_2-1}],d_2],[N_3,[w_{3,0},\\dots,w_{3,N_3-1}],d_3]]。\n$$\n此问题不涉及物理单位，也不需要角度单位。",
            "solution": "提出的问题是针对给定节点数 $N$，构建并分析基于 Chebyshev–Lobatto 节点的 Clenshaw–Curtis 求积法则。这个过程涉及两个主要的计算任务：计算求积权重和凭经验确定该法则的精度阶。此外，还需要定性解释这些特定节点在数值方法中所扮演的角色。\n\n首先，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **求积法则：** $Q_N[f] \\equiv \\sum_{k=0}^{N-1} w_k\\, f(x_k) \\approx \\int_{-1}^{1} f(x)\\, dx$。\n- **节点：** Chebyshev–Lobatto 点，$x_k = \\cos\\left(\\frac{\\pi k}{N-1}\\right)$，其中 $k=0,1,\\dots,N-1$。\n- **权重计算：** 该法则是插值型的，意味着它对次数最高为 $N-1$ 的单项式是精确的。这导出了线性系统 $\\sum_{k=0}^{N-1} w_k\\, x_k^m = \\int_{-1}^{1} x^m \\, dx$，其中 $m=0,1,\\dots,N-1$。\n- **单项式的矩：** $\\int_{-1}^{1} x^m \\, dx$ 对于奇数 $m$ 为 $0$，对于偶数 $m$ 为 $\\frac{2}{m+1}$。\n- **精度阶 ($d$)：** 使该法则对所有次数至多为 $d$ 的多项式都精确成立的最大整数。\n- **具体任务：** 确定 $N=5$ 时的权重。使用 $10^{-12}$ 的容差凭经验找出 $N=5$ 时的精度阶。\n- **背景任务：** 评论 Chebyshev-Lobatto 节点对于稳定插值和求积的好处。\n- **测试用例：** $(N, M_{\\max}) = (5, 12)$，$(N, M_{\\max}) = (2, 6)$，$(N, M_{\\max}) = (7, 16)$。\n- **输出规范：** 对于每个测试用例，输出一个形式为 $[N, [\\text{权重}], d]$ 的列表的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上植根于数值分析的既定理论，特别是数值求积和多项式逼近。所有定义，包括求积法则、Chebyshev-Lobatto 节点以及确定权重的方法，都是标准的且数学上正确的。该问题是适定的；对于一组 $N$ 个不同的节点，其 $N \\times N$ 的 Vandermonde 矩阵是可逆的，从而保证了一组唯一的权重。对于 $N \\ge 2$，Chebyshev-Lobatto 节点在区间 $[-1, 1]$ 上是不同的。指令清晰、明确、自成体系，没有内部矛盾。这是一个计算数学中标准的、可解的问题。\n\n### 步骤 3：结论与行动\n问题有效。将构建一个解决方案。\n\n### 解法推导\n\n#### 求积权重的计算\n\n插值型求积法则由一组节点 $\\{x_k\\}_{k=0}^{N-1}$ 定义，并被构造成对于次数至多为 $N-1$ 的多项式空间的一个基是精确的。这个基的一个常用选择是单项式集合 $\\{1, x, x^2, \\dots, x^{N-1}\\}$。对每个单项式 $x^m$ 的精确性条件可转化为一个线性方程：\n$$\n\\sum_{k=0}^{N-1} w_k x_k^m = \\int_{-1}^{1} x^m \\, dx, \\quad m=0, 1, \\dots, N-1.\n$$\n\n这构成了一个关于 $N$ 个未知权重 $\\{w_k\\}_{k=0}^{N-1}$ 的 $N$ 个线性方程组。写成矩阵形式为 $V \\mathbf{w} = \\mathbf{b}$，其中：\n- $\\mathbf{w} = [w_0, w_1, \\dots, w_{N-1}]^T$ 是未知权重向量。\n- $V$ 是由节点定义的 Vandermonde 矩阵，其元素为 $V_{mk} = (x_k)^m$，其中 $m, k \\in \\{0, 1, \\dots, N-1\\}$。\n- $\\mathbf{b}$ 是单项式的矩向量，其元素为 $b_m = \\int_{-1}^{1} x^m \\, dx$。其解析值为：\n$$\nb_m =\n\\begin{cases}\n\\frac{2}{m+1}  \\text{若 } m \\text{ 为偶数} \\\\\n0  \\text{若 } m \\text{ 为奇数}\n\\end{cases}\n$$\n\n指定的节点是 Chebyshev–Lobatto 点，由 $x_k = \\cos\\left(\\frac{\\pi k}{N-1}\\right)$ 给出，其中 $k=0, 1, \\dots, N-1$。这些节点关于 $x=0$ 对称，并包含端点 $-1$ 和 $1$。只要 $N \\ge 2$，这些节点就是不同的，这确保了 Vandermonde 矩阵 $V$ 是非奇异的。因此，系统 $V \\mathbf{w} = \\mathbf{b}$ 对权重有唯一的解，可以通过数值求解这个线性系统得到。\n\n#### 经验精度阶\n\n求积法则的精度阶 $d$ 是使该法则对所有次数至多为 $d$ 的多项式都精确成立的最大整数。根据构造，一个 $N$ 点的插值型法则的精度阶至少为 $N-1$。对于 Clenshaw–Curtis 求积，其精度阶恰好是 $N-1$。我们的经验性研究应该能证实这个结果。\n\n为了凭经验确定 $d$，我们对单项式 $x^m$（其中整数幂次 $m=0, 1, 2, \\dots, M_{\\max}$ 依次递增）测试该法则的精确性。\n\n对于每个 $m$，我们计算积分的数值近似：\n$$\nQ_N[x^m] = \\sum_{k=0}^{N-1} w_k x_k^m\n$$\n并将其与精确的解析值 $I[x^m] = \\int_{-1}^{1} x^m \\, dx = b_m$ 进行比较。精确性的检验是看绝对误差是否在指定的容差 $\\epsilon = 10^{-12}$ 内：\n$$\n|Q_N[x^m] - I[x^m]| \\le \\epsilon\n$$\n精度阶 $d$ 是使此条件对从 $0$ 到 $m$ 的所有整数都成立的最大整数 $m$。在实践中，我们找到第一个使求积失败的单项式次数，比如说 $m^*$。那么精度阶就是 $d = m^* - 1$。如果该法则对所有测试到 $M_{\\max}$ 的单项式都精确，则报告的经验精度阶为 $M_{\\max}$。\n\n#### 关于 Chebyshev-Lobatto 节点在谱方法/DG方法中的评述\n\n在谱方法和间断 Galerkin (DG) 方法中，用于多项式插值和求积的节点选择至关重要。选择 Chebyshev-Lobatto 节点是基于其几个确保数值稳定性和准确性的关键特性：\n\n1.  **最小化 Runge 现象：** 当使用高阶多项式插值时，等距节点会导致区间边界附近出现剧烈振荡，这种行为被称为 Runge 现象。Chebyshev-Lobatto 节点不是等距的；它们在端点 $\\pm 1$ 附近聚集。这种特定的点分布在某种意义上是最佳的，因为它在所有可能的节点集类别中，最小化了多项式插值的最大误差（由 Lebesgue 常数衡量）。对于 Chebyshev 点，Lebesgue 常数随多项式次数 $N$ 对数增长，即 $\\Lambda_N \\sim \\log N$，而对于等距点，它呈指数增长，$\\Lambda_N \\sim 2^N/N\\log N$。Chebyshev 点的缓慢增长确保了对于足够光滑的函数，当 $N \\rightarrow \\infty$ 时，插值过程是稳定且收敛的。\n\n2.  **稳定和精确的求积：** 有利的插值特性直接转化为求积的优势。因为 Clenshaw-Curtis 法则是基于一个精确的多项式插值，所以得到的求积也非常精确。其权重总是正的，这有助于积分方案的数值稳定性。\n\n3.  **DG 方法中的边界条件和单元耦合：** 在 DG 方法中，域被分解成更小的单元，解在每个单元上用一个多项式来逼近（通常是一个像 $[-1, 1]$ 这样的参考单元，映射到物理单元）。Chebyshev-Lobatto 点集包含端点 $\\pm 1$ 这一点特别有利。它允许直接在单元上施加边界条件，并便于计算单元界面处的数值通量，这对于耦合相邻单元和定义全局离散问题至关重要。\n\n总而言之，Chebyshev-Lobatto 节点通过保证稳定的多项式插值和产生精确的正权重求积法则，为高阶谱方法和 DG 方法提供了坚实的基础，同时也简化了对单元边界的处理。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs Clenshaw-Curtis quadrature rules based on Chebyshev-Lobatto nodes,\n    determines their empirical degree of precision, and formats the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, 12),  # Test case 1 (happy path)\n        (2, 6),   # Test case 2 (boundary case)\n        (7, 16),  # Test case 3 (odd N edge case)\n    ]\n\n    results = []\n    TOLERANCE = 1e-12\n\n    for N, M_max in test_cases:\n        # Step 1: Generate Chebyshev-Lobatto nodes.\n        # x_k = cos(pi*k / (N-1)) for k = 0, ..., N-1\n        k_vals = np.arange(N)\n        nodes = np.cos(np.pi * k_vals / (N - 1))\n        # Ensure that nodes that should be exactly 0 are not affected by floating point inaccuracies.\n        nodes = np.where(np.abs(nodes)  1e-15, 0, nodes)\n\n\n        # Step 2: Construct the Vandermonde matrix V such that V[m, k] = nodes[k]**m.\n        # This sets up the linear system V @ w = b.\n        V = np.vander(nodes, N, increasing=True).T\n\n        # Step 3: Construct the moment vector b, where b[m] = integral of x^m from -1 to 1.\n        m_vals = np.arange(N)\n        moments = np.zeros(N)\n        # Integral is 2/(m+1) for even m, and 0 for odd m.\n        moments[::2] = 2.0 / (m_vals[::2] + 1)\n\n        # Step 4: Solve the linear system V @ w = b for the weights w.\n        try:\n            weights = np.linalg.solve(V, moments)\n        except np.linalg.LinAlgError:\n            # This should not happen for N >= 2 as nodes are distinct.\n            # Handle potential error gracefully if it occurs.\n            results.append([N, [], -1])\n            continue\n            \n        # Step 5: Empirically determine the degree of precision.\n        # The degree of precision is the largest integer d such that the rule\n        # is exact for all monomials x^m where m = d.\n        degree_of_precision = -1\n        for m in range(M_max + 1):\n            numerical_integral = np.sum(weights * (nodes**m))\n            \n            if m % 2 == 0:\n                exact_integral = 2.0 / (m + 1)\n            else:\n                exact_integral = 0.0\n\n            if np.abs(numerical_integral - exact_integral) > TOLERANCE:\n                degree_of_precision = m - 1\n                break\n        \n        # If the loop completes without breaking, the rule is exact for all tested monomials.\n        if degree_of_precision == -1:\n            degree_of_precision = M_max\n\n        # Store the results for this test case.\n        # The weights are converted to a standard Python list for formatting.\n        results.append([N, list(weights), degree_of_precision])\n\n    # Format the final output string as per the problem specification.\n    # We build the string manually to avoid spaces introduced by str(list).\n    result_strings = []\n    for res in results:\n        N_val, weights_list, d_val = res\n        weights_str = f\"[{','.join(f'{w:.15f}' for w in weights_list)}]\"\n        result_strings.append(f\"[{N_val},{weights_str},{d_val}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "理论是一回事，但实际性能是另一回事。本练习将 Clenshaw–Curtis 求积与高效的高斯-勒让德求积进行直接比较 。通过将这两种方法应用于从光滑多项式到具有奇点或快速振荡的各种函数，你将对每种方法的相对优缺点获得宝贵的直觉。",
            "id": "2378822",
            "problem": "考虑在闭区间 $[-1,1]$ 上的定积分数值逼近，使用两种在逼近理论和计算物理中至关重要的求积法则族：基于 Chebyshev 节点的 Clenshaw–Curtis 求积法和基于 Legendre 多项式根的 Gauss–Legendre 求积法。\n\n定义：\n- 对于正整数 $m \\ge 2$，定义 $m$ 个 Chebyshev–Lobatto 节点集为 $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{m-1}\\right)$，其中 $k=0,1,\\dots,m-1$。m 阶 Clenshaw–Curtis 求积定义为在 $[-1,1]$ 上对一个唯一多项式的精确积分，该多项式次数至多为 $m-1$ 且在这些节点上对被积函数进行插值。\n- 对于正整数 $m \\ge 1$，$[-1,1]$ 上的 $m$ 点 Gauss–Legendre 求积是一种具有 $m$ 个节点和正权重的求积法则，它能精确积分所有次数至多为 $2m-1$ 的多项式。\n\n任务：\n1. 对于下面列出的每个被积函数 $f(x)$ 和指定的节点数 $m$，计算定积分 $\\int_{-1}^{1} f(x)\\,dx$ 的两种近似值：一种使用 m 阶 Clenshaw–Curtis 求积法，另一种使用 m 点 Gauss–Legendre 求积法。\n2. 对于每种情况，也计算每种近似值相对于精确积分值的绝对误差。\n3. 所有三角函数中的角度必须以弧度为单位。\n\n测试用例：\n- 情况 A：$f(x) = x^8 - 3x^3 + 2$，其中 $m=5$。精确积分：$$ \\displaystyle \\int_{-1}^{1} \\left(x^8 - 3x^3 + 2\\right)\\,dx = \\dfrac{38}{9} $$。\n- 情况 B：$f(x) = |x|$，其中 $m=17$。精确积分：$$ \\displaystyle \\int_{-1}^{1} |x|\\,dx = 1 $$。\n- 情况 C：$f(x) = \\sqrt{1 - x^2}$，其中 $m=17$。精确积分：$$ \\displaystyle \\int_{-1}^{1} \\sqrt{1 - x^2}\\,dx = \\dfrac{\\pi}{2} $$。\n- 情况 D：$f(x) = \\sin(50x)$，其中 $m=65$。精确积分：$$ \\displaystyle \\int_{-1}^{1} \\sin(50x)\\,dx = 0 $$。角度以弧度为单位。\n- 情况 E：$f(x) = e^{x}$，其中 $m=9$。精确积分：$$ \\displaystyle \\int_{-1}^{1} e^{x}\\,dx = e - e^{-1} $$。\n\n要求的程序输出：\n- 对于每种情况，按 A、B、C、D、E 的顺序，计算 Clenshaw–Curtis 近似的绝对误差和 Gauss–Legendre 近似的绝对误差。\n- 您的程序应生成单行输出，其中包含这 $10$ 个浮点数，形式为用方括号括起来的逗号分隔列表，顺序为\n$[\\text{err}_{\\mathrm{CC,A}},\\text{err}_{\\mathrm{GL,A}},\\text{err}_{\\mathrm{CC,B}},\\text{err}_{\\mathrm{GL,B}},\\text{err}_{\\mathrm{CC,C}},\\text{err}_{\\mathrm{GL,C}},\\text{err}_{\\mathrm{CC,D}},\\text{err}_{\\mathrm{GL,D}},\\text{err}_{\\mathrm{CC,E}},\\text{err}_{\\mathrm{GL,E}}]$。",
            "solution": "问题陈述已经过严格验证，被认为是完整、一致且科学上可靠的。问题是适定的，为获得唯一且有意义的解提供了所有必要的数据和定义。该问题涉及数值分析中的基本方法——Clenshaw–Curtis 和 Gauss–Legendre 求积法——这些是计算物理学的核心课题。因此，我们可以着手求解。\n\n任务是使用两种不同的求积法则，每种法则都使用指定数量的节点 $m$，来逼近几个函数的定积分 $I[f] = \\int_{-1}^{1} f(x)\\,dx$，并计算每种近似的绝对误差。\n\n**Gauss–Legendre 求积**\n\nm 点 Gauss–Legendre (GL) 求积法是 Gauss 求积的一种形式，旨在实现可能达到的最高代数精度。求积和由下式给出：\n$$ \\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{m} w_i f(x_i) $$\n对于给定的节点数 $m$，节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$ 都经过最优选择。节点 $x_i$ 是 m 次 Legendre 多项式 $P_m(x)$ 的根，这些根都是实的、互不相同且位于区间 $(-1, 1)$ 内。相应的权重 $w_i$ 都是正的，其选择使得该法则对所有次数高达 $2m-1$ 的多项式都是精确的。这种高精度阶使得 Gauss–Legendre 求积法对于解析函数的计算异常高效。\n\n出于计算目的，节点和权重不是从第一性原理计算得出，而是从预先计算好的值或可靠的数值库中获取。在本例中，我们使用 `scipy.special.roots_legendre` 函数，该函数为节点和权重都提供了高精度的值。\n\n**Clenshaw–Curtis 求积**\n\nClenshaw–Curtis (CC) 求积是一种插值型求积法则，它基于函数在 Chebyshev 多项式级数中的展开。节点选择为 Chebyshev–Lobatto 点，即 $m-1$ 次 Chebyshev 多项式 $T_{m-1}(x)$ 的极值点：\n$$ x_k = \\cos\\left(\\frac{k\\pi}{m-1}\\right) \\quad \\text{其中 } k = 0, 1, \\dots, m-1 $$\n该方法通过构建一个次数至多为 $m-1$ 的唯一多项式 $p_{m-1}(x)$，该多项式在这 $m$ 个节点上对函数 $f(x)$ 进行插值。然后，$f(x)$ 的积分通过这个插值多项式的精确积分来近似：\n$$ \\int_{-1}^{1} f(x)\\,dx \\approx \\int_{-1}^{1} p_{m-1}(x)\\,dx $$\n插值多项式 $p_{m-1}(x)$ 可以表示为 Chebyshev 多项式的有限和：\n$$ p_{m-1}(x) = \\sum_{j=0}^{m-1} a_j T_j(x) $$\n系数 $\\{a_j\\}$ 可以通过节点处的函数值 $\\{f(x_k)\\}$ 高效地确定，对此 `numpy.polynomial.chebyshev.chebfit` 函数是合适的。一旦系数已知，便可通过利用已知的 Chebyshev 多项式的解析积分来计算积分：\n$$ \\int_{-1}^{1} T_j(x)\\,dx = \\begin{cases} \\frac{2}{1-j^2}  \\text{若 } j \\text{ 为偶数} \\\\ 0  \\text{若 } j \\text{ 为奇数} \\end{cases} $$\n将此代入级数的积分中，得到 Clenshaw–Curtis 近似值：\n$$ I_{CC} = \\int_{-1}^{1} \\sum_{j=0}^{m-1} a_j T_j(x)\\,dx = \\sum_{j=0, \\, j \\text{ 为偶数}}^{m-1} a_j \\frac{2}{1-j^2} $$\nm 阶 CC 法则的精度阶为 $m-1$。虽然对于相同的 $m$，这低于 GL 求积法，但 CC 有其他优点，例如其嵌套节点特性以及通过基于快速傅里叶变换 (FFT) 的方法所实现的高效率。\n\n**计算步骤**\n\n对于指定的五个测试用例中的每一个：\n1.  **定义输入**：定义函数 $f(x)$、节点数 $m$ 以及积分的精确值 $I_{exact}$。\n2.  **Gauss–Legendre 近似**：\n    a. 使用 `scipy.special.roots_legendre(m)` 获取 $m$ 个 GL 节点和权重。\n    b. 计算近似积分 $I_{GL} = \\sum_{i=0}^{m-1} w_i f(x_i)$。\n    c. 计算绝对误差 $\\text{err}_{GL} = |I_{GL} - I_{exact}|$。\n3.  **Clenshaw–Curtis 近似**：\n    a. 生成 $m$ 个 CC 节点 $x_k = \\cos(k\\pi/(m-1))$。\n    b. 在这些节点上计算函数值以获得 $y_k = f(x_k)$。\n    c. 使用 `numpy.polynomial.chebyshev.chebfit` 计算次数为 $m-1$ 的插值多项式的 Chebyshev 系数 $\\{a_j\\}$。\n    d. 通过对偶数索引的系数求和来计算近似积分 $I_{CC}$。\n    e. 计算绝对误差 $\\text{err}_{CC} = |I_{CC} - I_{exact}|$。\n4.  **整理结果**：将每种情况的两个误差值 $\\text{err}_{CC}$ 和 $\\text{err}_{GL}$ 按指定顺序存储。\n\n**预期性能分析**\n-   **情况 A ($f(x) = x^8 - 3x^3 + 2, m=5$)**：被积函数是 8 次多项式。5 点 GL 法则对次数高达 $2(5)-1=9$ 的多项式是精确的。因此，误差 $\\text{err}_{GL}$ 预计为零（在机器精度范围内）。5 阶 CC 法则对次数高达 4 的多项式是精确的，因此 $\\text{err}_{CC}$ 将不为零。\n-   **情况 B ($f(x) = |x|, m=17$)**：该函数在 $x=0$ 处有导数不连续性，这限制了两种方法的收敛速度。高阶精度会丧失。\n-   **情况 C ($f(x) = \\sqrt{1 - x^2}, m=17$)**：该函数在端点 $x=\\pm 1$ 处有导数奇点。在 CC 的公式构建中所隐含的变量代换 $x=\\cos\\theta$ 将被积函数转换为一个光滑周期函数 $\\sin^2\\theta$。预计 CC 在这种情况下将异常精确。\n-   **情况 D ($f(x) = \\sin(50x), m=65$)**：这是一个高振荡解析函数。两种方法都应能提供良好的近似，但高频率要求有足够数量的点来分辨这些振荡。对于此类光滑函数，GL 通常更优越。\n-   **情况 E ($f(x) = e^x, m=9$)**：被积函数是一个整函数（处处解析）。两种方法都将表现出快速（指数级）收敛。对于给定的 $m$，由于其更高的精度阶，预计 GL 将显著更精确。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom numpy.polynomial.chebyshev import chebfit\n\ndef solve():\n    \"\"\"\n    Computes and compares the accuracy of Clenshaw-Curtis and Gauss-Legendre\n    quadratures for a suite of test integrals.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"func\": lambda x: x**8 - 3*x**3 + 2,\n            \"m\": 5,\n            \"exact\": 38.0 / 9.0\n        },\n        {\n            \"name\": \"B\",\n            \"func\": lambda x: np.abs(x),\n            \"m\": 17,\n            \"exact\": 1.0\n        },\n        {\n            \"name\": \"C\",\n            \"func\": lambda x: np.sqrt(1 - x**2),\n            \"m\": 17,\n            \"exact\": np.pi / 2.0\n        },\n        {\n            \"name\": \"D\",\n            \"func\": lambda x: np.sin(50 * x),\n            \"m\": 65,\n            \"exact\": 0.0\n        },\n        {\n            \"name\": \"E\",\n            \"func\": lambda x: np.exp(x),\n            \"m\": 9,\n            \"exact\": np.e - 1.0/np.e\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f = case[\"func\"]\n        m = case[\"m\"]\n        exact_val = case[\"exact\"]\n\n        # --- Gauss-Legendre Quadrature ---\n        # The scipy function returns nodes and weights for the m-point rule.\n        gl_nodes, gl_weights = roots_legendre(m)\n        \n        # Approximate the integral by summing f(x_i) * w_i\n        gl_approx = np.sum(gl_weights * f(gl_nodes))\n        \n        # Calculate the absolute error.\n        err_gl = np.abs(gl_approx - exact_val)\n\n        # --- Clenshaw-Curtis Quadrature ---\n        # Get the m Chebyshev-Lobatto nodes.\n        # These are the extrema of the Chebyshev polynomial T_{m-1}(x).\n        cc_nodes = np.cos(np.arange(m) * np.pi / (m - 1))\n        \n        # Evaluate the function at the nodes.\n        cc_vals = f(cc_nodes)\n        \n        # Compute the coefficients of the Chebyshev series that interpolates\n        # the function at the nodes. The degree of interpolant is m-1.\n        # `chebfit` is used for this purpose.\n        # For interpolation at Chebyshev nodes, least squares fit is equivalent to interpolation.\n        coeffs = chebfit(cc_nodes, cc_vals, m - 1)\n        \n        # Integrate the Chebyshev series expansion.\n        # The integral of a Chebyshev polynomial T_j(x) over [-1, 1] is\n        # 2/(1-j^2) for j even, and 0 for j odd.\n        cc_approx = 0.0\n        for j in range(0, m, 2):\n            cc_approx += coeffs[j] * (2.0 / (1.0 - j**2))\n            \n        # Calculate the absolute error.\n        err_cc = np.abs(cc_approx - exact_val)\n\n        results.extend([err_cc, err_gl])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Clenshaw–Curtis 求积的一个主要优点是其能够进行极快速计算。虽然通过求解线性方程组来构建权重在概念上很简单，但对于大量的节点来说，其计算成本很高。这个高级实践揭示了 Clenshaw–Curtis 求积与离散余弦变换 (DCT) 之间的联系，引导你推导并实现一个高效的 $O(n \\log n)$ 算法来计算权重 。",
            "id": "3371402",
            "problem": "设 $n \\in \\mathbb{N}_0$ 并考虑区间 $[-1,1]$ 上的 Clenshaw–Curtis 求积法则，当 $n \\ge 1$ 时，其节点为 $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$，共 $n+1$ 个（其中 $j = 0,1,\\dots,n$）；当 $n=0$ 时，只有一个节点 $x_0=1$。目标是计算求积权重 $w_j$，使得对于合适的函数 $f$，近似值 $\\sum_{j=0}^n w_j f(x_j)$ 接近于 $\\int_{-1}^1 f(x)\\,dx$。您的任务是，从第一性原理出发，通过利用余弦展开和I型离散余弦变换 (DCT-I)，推导出一个复杂度为 $O(n\\log n)$ 的算法来计算权重 $w_j$，其中包括对端点的正确缩放处理。所有角度必须以弧度为单位。\n\n从以下基本依据开始：\n- 第一类 Chebyshev 多项式满足 $T_k(\\cos \\theta) = \\cos(k\\theta)$，其中 $k \\ge 0$ 为任意整数，$\\theta$ 为任意实数。\n- 对于 $k \\ge 0$，Chebyshev 多项式在 $[-1,1]$ 上的精确积分为\n$$\n\\int_{-1}^1 T_k(x)\\,dx =\n\\begin{cases}\n2,  \\text{若 } k = 0, \\\\\n0,  \\text{若 } k \\text{ 为奇数}, \\\\\n\\dfrac{2}{1-k^2},  \\text{若 } k \\text{ 为偶数且 } k \\ge 2.\n\\end{cases}\n$$\n- 在 Chebyshev 网格点 $\\theta_j = \\frac{\\pi j}{n}$ 上的离散余弦正交性涉及带撇求和 $\\sum_{j=0}^n{}'$，其中端点 $j=0$ 和 $j=n$ 的权重为 $1/2$，即 $$ \\sum_{j=0}^n{}' a_j := \\frac{1}{2}a_0 + \\sum_{j=1}^{n-1} a_j + \\frac{1}{2} a_n $$。无归一化的I型离散余弦变换 (DCT-I) 的特征是\n$$\n\\operatorname{DCT\\!I}[v]_k \\;=\\; 2 \\sum_{j=0}^n{}' v_j \\cos\\!\\left(\\frac{\\pi j k}{n}\\right), \\quad k=0,1,\\dots,n,\n$$\n其逆变换对于长度为 $n+1$ 的向量满足 $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$。\n\n仅使用上述基本依据，推导为什么 Clenshaw–Curtis 权重 $w_j$ 可以通过对一个由精确积分 $\\int_{-1}^1 T_k(x)\\,dx$ 构成的向量应用I型离散余弦逆变换得到，并确定从逆变换中恢复 $w_j$ 所需的精确缩放和端点处理方法。您的推导必须清楚地解释为什么最终算法的复杂度是 $O(n \\log n)$。\n\n然后，在一个程序中实现所推导的算法，对于给定的 $n$，该程序通过对奇数阶 Chebyshev 模式进行适当的零填充，并正确缩放输出来考虑带撇求和的影响，从而在 $O(n\\log n)$ 时间内使用 DCT-I 构造权重 $w_j$。\n\n角度必须以弧度为单位。不涉及物理单位。\n\n您的程序必须评估以下测试套件，并输出指定的聚合结果：\n- 测试 1 (边界情况): $n=0$。将计算出的权重与参考权重 $[2]$ 进行比较，并以浮点数形式报告最大绝对差。\n- 测试 2 (小规模情况): $n=1$。与参考权重 $[1,1]$ 进行比较，并以浮点数形式报告最大绝对差。\n- 测试 3 (小规模情况): $n=2$。与参考权重 $\\left[\\frac{1}{3},\\frac{4}{3},\\frac{1}{3}\\right]$ 进行比较，并以浮点数形式报告最大绝对差。\n- 测试 4 (多项式精确性): $n=7$。对于每个整数 $m$ ($0 \\le m \\le 7$)，计算离散矩 $\\sum_{j=0}^7 w_j T_m(x_j)$ 并将其与上面给出的精确积分 $\\int_{-1}^1 T_m(x)\\,dx$ 进行比较。以浮点数形式报告在 $m=0,1,\\dots,7$ 范围内的最大绝对误差。\n- 测试 5 (非多项式函数): $n=32$。使用该求积法则近似计算 $\\int_{-1}^1 e^x\\,dx$，并与精确值 $2\\sinh(1)$ 进行比较。以浮点数形式报告绝对误差。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如，“[result1,result2,result3,result4,result5]”。结果必须按顺序对应测试 1 到 5。所有角度必须以弧度为单位。",
            "solution": "用户希望推导并实现一个复杂度为 $O(n \\log n)$ 的算法，用于计算 $n+1$ 个节点 $x_j=\\cos(\\frac{\\pi j}{n})$ 的 Clenshaw-Curtis 求积权重 $w_j$。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 求积节点: $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$，其中 $j = 0,1,\\dots,n$，$n \\in \\mathbb{N}_0$。对于 $n=0$，指定一个节点 $x_0=1$。\n- 求积法则: $\\int_{-1}^1 f(x)\\,dx \\approx \\sum_{j=0}^n w_j f(x_j)$。\n- Chebyshev 多项式: $T_k(\\cos \\theta) = \\cos(k\\theta)$。\n- Chebyshev 多项式的精确积分:\n$$\nI_k := \\int_{-1}^1 T_k(x)\\,dx =\n\\begin{cases}\n2,  \\text{若 } k = 0 \\\\\n0,  \\text{若 } k \\text{ 为奇数} \\\\\n\\dfrac{2}{1-k^2},  \\text{若 } k \\text{ 为偶数且 } k \\ge 2\n\\end{cases}\n$$\n- 带撇求和: $\\sum_{j=0}^n{}' a_j := \\frac{1}{2}a_0 + \\sum_{j=1}^{n-1} a_j + \\frac{1}{2}a_n$。\n- I型离散余弦变换 (DCT-I): $\\operatorname{DCT\\!I}[v]_k = 2 \\sum_{j=0}^n{}' v_j \\cos\\left(\\frac{\\pi j k}{n}\\right)$，其中 $k=0,1,\\dots,n$。\n- I型离散余弦逆变换关系: 对于长度为 $n+1$ 的向量 $v$，$v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它是数值分析中的一个标准问题，特别是在谱方法领域。所提供的所有定义和公式都是标准且正确的。该问题是自洽的，并为其解决提供了所有必要信息。对于 $n=0$ 的特殊定义是明确的，并与所提供的测试用例一致。该问题没有违反任何无效性标准。\n\n**步骤3：结论与行动**\n问题有效。将提供一个完整的解决方案。\n\n### 推导与算法\n\nClenshaw-Curtis 求积法则的构造使其对最高为 $n$ 次的多项式是精确的。这是通过在 Chebyshev 节点 $x_j$ 处，用其唯一的最高为 $n$ 次的插值多项式 $p_n(x)$ 来近似被积函数 $f(x)$，然后精确地对 $p_n(x)$ 进行积分来实现的。如果 $f(x)$ 本身是最高为 $n$ 次的多项式，则 $p_n(x) = f(x)$，求积必须是精确的。\n\n因此，该求积法则对于所有 $m=0, 1, \\dots, n$ 的 Chebyshev 多项式 $T_m(x)$ 都必须是精确的，因为 $T_m(x)$ 是一个 $m$ 次多项式。这个条件为未知权重 $w_j$ 建立了一个方程组：\n$$\n\\sum_{j=0}^n w_j T_m(x_j) = \\int_{-1}^1 T_m(x)\\,dx = I_m, \\quad \\text{对于 } m = 0, 1, \\dots, n.\n$$\n为了使该方程组与所提供的 DCT-I 结构保持一致，我们引入一个修正的权重向量 $w'$，其中端点被缩放：\n$w'_0 = 2w_0$，$w'_n = 2w_n$，对于 $j=1, \\dots, n-1$，$w'_j = w_j$。\n使用带撇求和 $\\sum'$ 的定义，精确性条件变为：\n$$\n\\sum_{j=0}^n{}' w'_j T_m(x_j) = I_m, \\quad \\text{对于 } m = 0, 1, \\dots, n.\n$$\n代入恒等式 $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$ 和 $T_m(x_j) = \\cos\\left(\\frac{\\pi j m}{n}\\right)$：\n$$\n\\sum_{j=0}^n{}' w'_j \\cos\\left(\\frac{\\pi j m}{n}\\right) = I_m, \\quad \\text{对于 } m = 0, 1, \\dots, n.\n$$\n我们现在将其与给定的 DCT-I 定义联系起来：$\\operatorname{DCT\\!I}[v]_k = 2 \\sum_{j=0}^n{}' v_j \\cos\\left(\\frac{\\pi j k}{n}\\right)$。\n将此变换应用于我们的向量 $w'$（长度为 $n+1$），我们得到对于每个分量 $m=0, \\dots, n$：\n$$\n(\\operatorname{DCT\\!I}[w'])_m = 2 \\sum_{j=0}^n{}' w'_j \\cos\\left(\\frac{\\pi j m}{n}\\right) = 2 I_m.\n$$\n设 $c$ 是一个长度为 $n+1$ 的向量，其元素为 $c_m = 2I_m$。上述关系为 $c = \\operatorname{DCT-I}[w']$。为了找到所求的权重 $w'$，我们必须对 $c$ 应用逆变换。问题提供了逆变换关系 $v = \\operatorname{DCT\\!I}(\\operatorname{DCT\\!I}(v)) / (2n)$，这意味着I型离散余弦逆变换算子就是 DCT-I 算子本身，然后再乘以一个缩放因子 $1/(2n)$。\n因此，我们可以通过以下方式找到 $w'$：\n$$\nw' = \\operatorname{IDCT-I}(c) = \\frac{\\operatorname{DCT-I}(c)}{2n}.\n$$\n让我们写出向量 $w'$ 的分量 $w'_j$：\n$$\nw'_j = \\frac{1}{2n} (\\operatorname{DCT-I}[c])_j = \\frac{1}{2n} \\left( 2 \\sum_{k=0}^n{}' c_k \\cos\\left(\\frac{\\pi j k}{n}\\right) \\right).\n$$\n代入 $c_k = 2I_k$：\n$$\nw'_j = \\frac{1}{2n} \\left( 2 \\sum_{k=0}^n{}' (2I_k) \\cos\\left(\\frac{\\pi j k}{n}\\right) \\right) = \\frac{2}{n} \\sum_{k=0}^n{}' I_k \\cos\\left(\\frac{\\pi j k}{n}\\right).\n$$\n展开关于 $k$ 的带撇求和：\n$$\nw'_j = \\frac{2}{n} \\left[ \\frac{1}{2}I_0 + \\sum_{k=1}^{n-1} I_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + \\frac{1}{2}I_n \\cos\\left(\\pi j\\right) \\right] = \\frac{1}{n} \\left[ I_0 + 2\\sum_{k=1}^{n-1} I_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + I_n (-1)^j \\right].\n$$\n这个表达式可以被高效地计算。`scipy.fft` 库提供了一种I型离散余弦逆变换 `idct(..., type=1)`，当使用 `norm='backward'`（默认值）时，它对一个长度为 $N=n+1$ 的输入向量 $Y$ 计算：\n$$\nX_j = \\frac{1}{2n} \\left[ Y_0 + 2\\sum_{k=1}^{n-1} Y_k \\cos\\left(\\frac{\\pi j k}{n}\\right) + Y_n (-1)^j \\right].\n$$\n将此与我们关于 $w'_j$ 的表达式进行比较，我们发现如果我们将输入向量 $Y$ 设置为我们的积分向量 $I$（其中 $Y_k=I_k$），那么 $w'_j = 2 \\times X_j$。\n这提供了一个直接且高效的算法：\n1.  对于给定的 $n \\ge 1$，构造一个长度为 $n+1$ 的向量 $I$，其中 $I_k = \\int_{-1}^1 T_k(x)\\,dx$。奇数索引的元素 $I_k$ 将为零，这对应于问题中提到的“对奇数阶 Chebyshev 模式进行零填充”。\n2.  通过对 $I$ 应用I型离散余弦逆变换并进行缩放来计算向量 $w'$：$w' = 2 \\times \\operatorname{idct}(I, \\text{type=1})$。\n3.  通过撤销端点的初始缩放来恢复最终的求积权重 $w_j$：$w_0 = w'_0/2$，$w_n = w'_n/2$，对于 $j=1, \\dots, n-1$，$w_j=w'_j$。\n\n特殊情况 $n=0$ 涉及一个节点 $x_0=1$。最简单的求积法则 $w_0 f(x_0)$ 应该对 $T_0(x)=1$ 是精确的。这要求 $w_0 T_0(1) = \\int_{-1}^1 T_0(x)dx \\implies w_0 \\cdot 1 = 2$，所以 $w_0=2$。\n\n该算法的复杂度主要由 `idct` 计算决定。DCT/IDCT 的快速实现（如 `scipy` 中的实现）是基于快速傅里叶变换 (FFT) 算法。对于大小为 $N=n+1$ 的输入，其复杂度为 $O(N \\log N)$，即 $O(n \\log n)$。所有其他步骤的复杂度都是 $O(n)$，因此总体复杂度为 $O(n \\log n)$。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\nimport math\n\ndef solve():\n    \"\"\"\n    Derives Clenshaw-Curtis weights and runs tests specified in the problem.\n    \"\"\"\n\n    def compute_weights(n: int) -> np.ndarray:\n        \"\"\"\n        Computes Clenshaw-Curtis quadrature weights for n+1 nodes in O(n log n) time.\n        \n        Args:\n            n: The order of the quadrature rule, corresponding to n+1 nodes.\n        \n        Returns:\n            A numpy array of n+1 quadrature weights.\n        \"\"\"\n        if not isinstance(n, int) or n  0:\n            raise ValueError(\"n must be a non-negative integer.\")\n\n        if n == 0:\n            return np.array([2.0])\n\n        # 1. Construct the vector I of exact integrals of Chebyshev polynomials T_k.\n        k = np.arange(n + 1)\n        Ivec = np.zeros(n + 1, dtype=float)\n\n        # For even k, I_k = 2 / (1 - k^2). For odd k, I_k = 0.\n        # I_0 = 2 is handled by the formula since 1 - 0^2 = 1.\n        even_indices = k[k % 2 == 0]\n        Ivec[even_indices] = 2.0 / (1.0 - even_indices**2)\n\n        # 2. Compute the modified weights w' using the inverse DCT of type 1.\n        # From the derivation, w'_j = 2 * idct(Ivec, type=1)_j.\n        # The norm='backward' option provides the required 1/(2n) scaling factor.\n        w_prime = 2 * fft.idct(Ivec, type=1, norm='backward')\n\n        # 3. Recover the final weights w by halving the endpoint values of w'.\n        w = w_prime\n        w[0] /= 2.0\n        w[-1] /= 2.0\n        \n        return w\n\n    # --- Test Suite ---\n    \n    # Test 1 (boundary case): n=0\n    n0 = 0\n    w0 = compute_weights(n0)\n    ref_w0 = np.array([2.0])\n    res1 = np.max(np.abs(w0 - ref_w0))\n\n    # Test 2 (small case): n=1\n    n1 = 1\n    w1 = compute_weights(n1)\n    ref_w1 = np.array([1.0, 1.0])\n    res2 = np.max(np.abs(w1 - ref_w1))\n\n    # Test 3 (small case): n=2\n    n2 = 2\n    w2 = compute_weights(n2)\n    ref_w2 = np.array([1/3.0, 4/3.0, 1/3.0])\n    res3 = np.max(np.abs(w2 - ref_w2))\n\n    # Test 4 (exactness on polynomials): n=7\n    n7 = 7\n    w7 = compute_weights(n7)\n    errors7 = []\n    for m in range(n7 + 1):\n        # Nodes x_j = cos(pi*j/n)\n        nodes = np.cos(math.pi * np.arange(n7 + 1) / n7)\n        # Values of T_m(x_j) at nodes\n        Tm_at_nodes = np.cos(m * math.pi * np.arange(n7 + 1) / n7)\n        # Quadrature sum\n        discrete_moment = np.sum(w7 * Tm_at_nodes)\n        \n        # Exact integral of T_m(x)\n        if m == 0:\n            exact_integral = 2.0\n        elif m % 2 != 0:\n            exact_integral = 0.0\n        else: # m is even and >= 2\n            exact_integral = 2.0 / (1 - m**2)\n            \n        errors7.append(np.abs(discrete_moment - exact_integral))\n    res4 = np.max(errors7)\n\n    # Test 5 (nonpolynomial function): n=32\n    n32 = 32\n    w32 = compute_weights(n32)\n    nodes_32 = np.cos(math.pi * np.arange(n32 + 1) / n32)\n    f_vals = np.exp(nodes_32)\n    quadrature_approx = np.sum(w32 * f_vals)\n    exact_integral_exp = math.exp(1.0) - math.exp(-1.0) # 2*sinh(1)\n    res5 = np.abs(quadrature_approx - exact_integral_exp)\n\n    results = [res1, res2, res3, res4, res5]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}