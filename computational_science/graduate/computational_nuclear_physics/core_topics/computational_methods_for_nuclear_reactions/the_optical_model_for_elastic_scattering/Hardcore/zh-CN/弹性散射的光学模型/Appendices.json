{
    "hands_on_practices": [
        {
            "introduction": "数值求解薛定谔方程是光学模型计算的核心。然而，由于光学势包含一个复数的吸收部分，直接数值积分会带来独特的挑战。本练习旨在探讨在使用对数微分等方法求解方程时出现的数值不稳定性问题，特别是在强吸收势的情况下。通过这个实践，你将学习如何量化这种不稳定性，并设计一种自适应步长控制策略，以确保求解过程的准确性和稳定性。",
            "id": "3605853",
            "problem": "考虑一个由光学模型描述的核子从原子核的径向弹性散射，其中中心势具有实部和吸收性虚部。设约化质量近似为核子质量，使得比值 $\\hbar^2 / (2\\mu)$ 是一个常数 $20.735$，单位为 $\\mathrm{MeV \\cdot fm^2}$。对于轨道角动量为 $\\ell$ 的分波，其约化径向波函数 $u(r)$ 的径向薛定谔方程为\n$$\n\\frac{d^2 u(r)}{dr^2} + K(r)\\,u(r) = 0,\n$$\n其中\n$$\nK(r) = \\frac{2\\mu E}{\\hbar^2} - \\frac{2\\mu V(r)}{\\hbar^2} - \\frac{\\ell(\\ell+1)}{r^2},\n$$\n其中 $E$ 是实验室能量（单位为 $\\mathrm{MeV}$），$r$ 是径向坐标（单位为 $\\mathrm{fm}$），$\\ell$ 是一个整数，$V(r)$ 是复光学势（单位为 $\\mathrm{MeV}$）。中心势采用 Woods–Saxon 形式\n$$\nV(r) = V_{\\mathrm{r}}\\,f(r) - i\\,W\\,f(r), \\quad f(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)},\n$$\n其中 $V_{\\mathrm{r}}$ 是实势阱深度（单位为 $\\mathrm{MeV}$），$W$ 是虚势阱深度（一个正值，单位为 $\\mathrm{MeV}$），$R = r_0 A^{1/3}$ 是原子核半径（单位为 $\\mathrm{fm}$），$A$ 为质量数，$a$ 是弥散度（单位为 $\\mathrm{fm}$）。\n\n定义对数导数 $Y(r) = \\frac{u'(r)}{u(r)}$。该对数导数满足 Riccati 方程\n$$\n\\frac{dY(r)}{dr} = -K(r) - Y(r)^2.\n$$\n一种常见的数值方法是在一个小步长 $h$ 上传播 $Y(r)$，通过假设 $K(r)$ 在该步长内为常数，这将局部方程简化为 $u''(r) + K\\,u(r) = 0$，其中 $K$ 为常数。令 $\\kappa = \\sqrt{K}$ 为 $K$ 的主平方根。在大小为 $h$ 的一步内，对数导数的精确常数 $K$ 更新是一个 Möbius 变换\n$$\nY_{+} = \\frac{Y_{-}\\cos(\\kappa h) - \\kappa \\sin(\\kappa h)}{\\cos(\\kappa h) + \\frac{Y_{-}}{\\kappa}\\sin(\\kappa h)},\n$$\n其中 $Y_{-}$ 和 $Y_{+}$ 分别是步长开始和结束时的对数导数值。更新相对于 $Y_{-}$ 的敏感性（条件数）由导数的模 $\\left|\\frac{\\partial Y_{+}}{\\partial Y_{-}}\\right|$ 来量化。在对应于出射波的不动点 $Y = +\\,i\\,\\kappa$ 处求值，它简化为闭合形式\n$$\n\\left|\\frac{\\partial Y_{+}}{\\partial Y_{-}}\\right| = \\left|e^{i\\,\\kappa h}\\right|^{-2} = \\exp\\left(2\\,\\mathrm{Im}(\\kappa)\\,h\\right).\n$$\n此表达式表明，强吸收（产生 $\\mathrm{Im}(\\kappa) > 0$）会导致每一步的数值扰动被指数级放大，使得随着 $h$ 的增大，传播的条件越来越差。一种强制施加条件数上限 $c_{\\max} > 1$ 的步长控制缓解措施是要求\n$$\n\\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right) \\le c_{\\max}\n\\quad\\Rightarrow\\quad\nh \\le \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa(r))},\n$$\n对每个 $\\mathrm{Im}(\\kappa(r)) > 0$ 的 $r$ 逐点应用。\n\n你的任务是实现一个程序，对于一组给定的光学模型参数和一个以 $\\mathrm{fm}$ 为单位的均匀步长 $h$，计算条件数剖面\n$$\nC(r; h) = \\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right),\n$$\n在径向区间 $[r_{\\min}, r_{\\max}]$ 上，并报告：\n- 最大条件数值 $C_{\\max}(h) = \\max_{r \\in [r_{\\min}, r_{\\max}]} C(r; h)$，作为一个浮点数，以及\n- 推荐步长 $h_{\\mathrm{rec}}$（单位为 $\\mathrm{fm}$），它保证对于所有 $r \\in [r_{\\min}, r_{\\max}]$ 都有 $C(r; h) \\le c_{\\max}$，通过以下公式计算\n$$\nh_{\\mathrm{rec}} = \\min\\left(\\min_{r \\in [r_{\\min}, r_{\\max}],\\,\\mathrm{Im}(\\kappa(r))>0} \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa(r))},\\, h_{\\mathrm{cap}}\\right),\n$$\n其中 $h_{\\mathrm{cap}}$ 是用户施加的上限（单位为 $\\mathrm{fm}$），以确保即使在没有吸收的情况下也能解析势的变化。使用 $h_{\\mathrm{cap}} = 0.5 \\, \\mathrm{fm}$，$r_{\\min} = 0.2 \\, \\mathrm{fm}$ 和 $r_{\\max} = 15.0 \\, \\mathrm{fm}$。如果没有吸收，使得对所有 $r$ 都有 $\\mathrm{Im}(\\kappa(r)) \\approx 0$，则 $h_{\\mathrm{rec}} = h_{\\mathrm{cap}}$。\n\n必须遵守物理单位：所有能量的单位是 $\\mathrm{MeV}$，所有长度的单位是 $\\mathrm{fm}$，步长必须以 $\\mathrm{fm}$ 报告。不使用角度。你的程序应实现以下测试案例集并生成指定的输出：\n- 案例 1（正常情况，中等吸收）：$A = 40$，$E = 50$，$V_{\\mathrm{r}} = 50$，$W = 5$，$\\ell = 0$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n- 案例 2（离心势垒影响）：$A = 208$，$E = 30$，$V_{\\mathrm{r}} = 60$，$W = 20$，$\\ell = 6$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n- 案例 3（强吸收，势刚度）：$A = 208$，$E = 10$，$V_{\\mathrm{r}} = 50$，$W = 50$，$\\ell = 0$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n- 案例 4（无吸收边界情况）：$A = 40$，$E = 80$，$V_{\\mathrm{r}} = 40$，$W = 0$，$\\ell = 0$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n\n对每个案例，计算如上定义的 $C_{\\max}(h)$ 和 $h_{\\mathrm{rec}}$。你的程序应生成单行输出，其中包含结果，形式为方括号括起来的逗号分隔列表，格式如下\n$$\n[\\;C_{\\max}^{(1)},\\,h_{\\mathrm{rec}}^{(1)},\\,C_{\\max}^{(2)},\\,h_{\\mathrm{rec}}^{(2)},\\,C_{\\max}^{(3)},\\,h_{\\mathrm{rec}}^{(3)},\\,C_{\\max}^{(4)},\\,h_{\\mathrm{rec}}^{(4)}\\;],\n$$\n其中每个条目都是一个使用标准十进制表示法的浮点数。",
            "solution": "问题陈述已被验证并确定为是合理的。它在科学上基于计算核物理的原理，特别是弹性散射的光学模型。所有参数、定义和约束都定义明确、自洽且物理上合理，使得该问题是适定且可解的。因此，我们可以继续推导和实现解决方案。\n\n问题的核心是分析在使用对数导数法积分径向薛定谔方程时的数值条件。条件数与局域波数 $\\kappa(r)$ 的虚部有关。我们的任务是为几组参数计算两个量：在固定步长 $h$ 下，径向区间上的最大条件因子 $C_{\\max}(h)$，以及为使条件数低于指定阈值 $c_{\\max}$ 的推荐步长 $h_{\\mathrm{rec}}$。\n\n算法流程如下：\n\n首先，我们将所有相关物理量定义为径向坐标 $r$ 的函数。给定常数比值 $\\frac{\\hbar^2}{2\\mu}$ 为 $c_0 = 20.735 \\, \\mathrm{MeV \\cdot fm^2}$。\n\n描述核势形状的 Woods-Saxon 形状因子 $f(r)$ 由下式给出：\n$$\nf(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}\n$$\n其中原子核半径 $R$ 由质量数 $A$ 和半径参数 $r_0$ 确定，即 $R = r_0 A^{1/3}$。参数 $a$ 是弥散度。\n\n复光学势 $V(r)$ 是深度为 $V_{\\mathrm{r}}$ 的实部（折射部分）和深度为 $W$ 的虚部（吸收部分）之和：\n$$\nV(r) = V_{\\mathrm{r}}f(r) - i\\,W f(r)\n$$\n$W$ 的正值对应于吸收，这是核反应理论中的标准。\n\n根据势，我们构建了出现在径向薛定谔方程中的、与位置相关的波数平方 $K(r)$。其定义为：\n$$\nK(r) = \\frac{2\\mu E}{\\hbar^2} - \\frac{2\\mu V(r)}{\\hbar^2} - \\frac{\\ell(\\ell+1)}{r^2}\n$$\n使用给定的常数 $c_0$，上式变为：\n$$\nK(r) = \\frac{E - V(r)}{c_0} - \\frac{\\ell(\\ell+1)}{r^2}\n$$\n这里，$E$ 是动能，涉及轨道角动量 $\\ell$ 的项是离心势。$K(r)$ 是一个复值函数。\n\n那么，局域波数是 $K(r)$ 的主平方根：\n$$\n\\kappa(r) = \\sqrt{K(r)}\n$$\n由于 $K(r)$ 是复数，$\\kappa(r)$ 也将是复数，形式为 $\\kappa(r) = \\mathrm{Re}(\\kappa(r)) + i\\,\\mathrm{Im}(\\kappa(r))$。其虚部 $\\mathrm{Im}(\\kappa(r))$ 是这个问题的核心。如果 $\\mathrm{Im}(\\kappa(r)) > 0$，波函数会表现出指数行为，这在数值积分的背景下会导致误差的放大。\n\n问题将步长为 $h$ 的条件数剖面 $C(r; h)$ 定义为：\n$$\nC(r; h) = \\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right)\n$$\n\n为了找到最大条件因子 $C_{\\max}(h)$ 和推荐步长 $h_{\\mathrm{rec}}$，我们必须在指定的径向区间 $[r_{\\min}, r_{\\max}] = [0.2, 15.0]$ 上计算这些函数。由于这些是连续函数，我们采用一种数值方法，将该区间离散化为一个精细的点网格 $\\{r_j\\}$。我们将使用一个包含 $15000$ 个点的网格以确保高分辨率。\n\n计算每个测试案例所需输出的算法如下：\n\n1.  **离散化域**：生成一个从 $r_{\\min} = 0.2 \\, \\mathrm{fm}$ 到 $r_{\\max} = 15.0 \\, \\mathrm{fm}$ 的径向点数组 $r_j$。\n2.  **在网格上计算函数值**：对于网格中的每个点 $r_j$，计算序列值：$f(r_j)$、$V(r_j)$、$K(r_j)$，最后计算 $\\kappa(r_j) = \\sqrt{K(r_j)}$。这将产生一个相应的复数 $\\kappa_j$ 值的网格。\n3.  **计算 $C_{\\max}(h)$**：a. 提取每个 $\\kappa_j$ 值的虚部，得到一个数组 $\\mathrm{Im}(\\kappa_j)$。b. 使用给定的步长 $h$，计算每个网格点上的条件数值：$C_j = \\exp\\left(2 \\cdot \\mathrm{Im}(\\kappa_j) \\cdot h\\right)$。c. 最大条件因子是 $C_j$ 数组中的最大值：$C_{\\max}(h) = \\max_j \\{C_j\\}$。\n4.  **计算 $h_{\\mathrm{rec}}$**：a. 识别所有满足 $\\mathrm{Im}(\\kappa_j)$ 大于零（在处理浮点伪影的小数值容差内）的网格点 $r_j$。b. 如果不存在这样的点（即，对于一个 $K(r)$ 始终为正的纯实势），问题规定 $h_{\\mathrm{rec}} = h_{\\mathrm{cap}}$，其中 $h_{\\mathrm{cap}} = 0.5 \\, \\mathrm{fm}$。c. 如果存在 $\\mathrm{Im}(\\kappa_j) > 0$ 的点，为每个这样的点计算局部步长限制：\n    $$\n    h_{\\mathrm{lim}, j} = \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa_j)}\n    $$\n    d. 找到这些限制的最小值：$h_{\\mathrm{lim}}^{\\min} = \\min_j \\{h_{\\mathrm{lim}, j}\\}$。这个值是由吸收势施加的最严格的步长约束。e. 推荐步长 $h_{\\mathrm{rec}}$ 是这个最小值和全局上限 $h_{\\mathrm{cap}}$ 中的较小者：\n    $$\n    h_{\\mathrm{rec}} = \\min(h_{\\mathrm{lim}}^{\\min}, h_{\\mathrm{cap}})\n    $$\n\n为所提供的四个测试案例中的每一个都执行此过程，并将所得的 $(C_{\\max}(h), h_{\\mathrm{rec}})$ 对收集起来并按指定格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the conditioning profile and recommended step size for the optical model\n    of elastic scattering as described in the problem statement.\n    \"\"\"\n    # Define the physical constant\n    HBAR2_OVER_2MU = 20.735  # MeV * fm^2\n\n    # Define the test suite of cases\n    # Each case is a tuple: (A, E, V_r, W, l, r_0, a, h, c_max)\n    test_cases = [\n        # Case 1 (happy path, moderate absorption)\n        (40, 50, 50, 5, 0, 1.25, 0.65, 0.05, 10),\n        # Case 2 (centrifugal barrier influence)\n        (208, 30, 60, 20, 6, 1.25, 0.65, 0.05, 10),\n        # Case 3 (strong absorption, potential stiffness)\n        (208, 10, 50, 50, 0, 1.25, 0.65, 0.05, 10),\n        # Case 4 (no absorption boundary)\n        (40, 80, 40, 0, 0, 1.25, 0.65, 0.05, 10),\n    ]\n\n    # Fixed parameters for the calculation\n    R_MIN = 0.2  # fm\n    R_MAX = 15.0  # fm\n    H_CAP = 0.5  # fm\n    NUM_POINTS = 15000  # Number of points in the radial grid\n\n    # Generate the radial grid for numerical evaluation\n    r_grid = np.linspace(R_MIN, R_MAX, NUM_POINTS)\n    \n    # List to store all final results\n    all_results = []\n\n    for case in test_cases:\n        A, E, V_r, W, l, r0, a, h, c_max = case\n\n        # Calculate the nuclear radius a.k.a. R\n        R_nuc = r0 * A**(1/3)\n\n        # Calculate the Woods-Saxon form factor f(r) over the grid\n        f_of_r = 1.0 / (1.0 + np.exp((r_grid - R_nuc) / a))\n\n        # Calculate the complex optical potential V(r)\n        V_of_r = V_r * f_of_r - 1j * W * f_of_r\n\n        # Calculate the centrifugal term. r_grid does not contain 0, so this is safe.\n        centrifugal_term = l * (l + 1) / (r_grid**2)\n\n        # Calculate the K(r) function\n        # K(r) = ( E - V(r) ) / (hbar^2/2mu) - l(l+1)/r^2\n        K_of_r = (E - V_of_r) / HBAR2_OVER_2MU - centrifugal_term\n\n        # Calculate kappa(r) = sqrt(K(r)) using the principal square root\n        kappa_of_r = np.sqrt(K_of_r)\n\n        # Extract the imaginary part of kappa(r)\n        im_kappa = np.imag(kappa_of_r)\n        \n        # --- Task 1: Compute C_max(h) ---\n        # C(r; h) = exp(2 * Im(kappa(r)) * h)\n        conditioning_profile = np.exp(2 * im_kappa * h)\n        C_max_val = np.max(conditioning_profile)\n        \n        # --- Task 2: Compute h_rec ---\n        # Find indices where Im(kappa) > 0 using a small tolerance\n        pos_im_kappa_indices = np.where(im_kappa > 1e-15)\n        \n        if pos_im_kappa_indices[0].size == 0:\n            # If no absorption, h_rec is capped by the user-defined maximum\n            h_rec_val = H_CAP\n        else:\n            # Filter for positive imaginary parts of kappa\n            im_kappa_positive = im_kappa[pos_im_kappa_indices]\n            \n            # h_allowed = ln(c_max) / (2 * Im(kappa(r)))\n            h_allowed = np.log(c_max) / (2 * im_kappa_positive)\n            \n            # Find the most restrictive (minimum) step size\n            h_min_allowed = np.min(h_allowed)\n            \n            # h_rec is the minimum of the calculated limit and the user cap\n            h_rec_val = min(h_min_allowed, H_CAP)\n            \n        all_results.append(C_max_val)\n        all_results.append(h_rec_val)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "光学势并非一个随意的函数；其能量依赖的实部和虚部由物理上的因果律紧密联系在一起。这种基本联系在数学上表现为 Kramers–Kronig 色散关系，它将描述吸收的虚部势 $ \\Im U(E) $ 与描述折射的实部势 $ \\Re U(E) $ 联系起来。本练习提供了一个动手实践的机会，通过数值计算来验证一个模型势的色散关系，从而加深对吸收如何决定折射势能量依赖性的理解。",
            "id": "3605865",
            "problem": "你的任务是通过数值方法检验一个依赖于能量的光学势的实部与虚部之间的 Kramers–Kronig 关系，从而验证弹性散射的色散光学模型的一致性。该验证将针对一个在复能量平面的上半平面解析的模型光学势进行，从而确保因果性。\n\n从一个基本的出发点开始：因果响应函数 $U(E)$ 在上半平面是解析的，这意味着它的实部和虚部通过 Kramers–Kronig 关系相互关联。为了确保在无穷远处衰减不够快的函数能够收敛，我们使用在减除点 $E_0$ 处的减除色散关系：\n$$\n\\Re U(E) - \\Re U(E_0)\n= \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{-\\infty}^{+\\infty} \\Im U(E')\n\\left[\n\\frac{1}{E' - E} - \\frac{1}{E' - E_0}\n\\right]\\,\\mathrm{d}E' ,\n$$\n其中 $\\mathcal{P}$ 表示 Cauchy 主值。在计算中，该积分将在一个有限的能量窗口 $[E_{\\min}, E_{\\max}]$ 上进行近似，如果 $\\Im U(E)$ 足够局域化，以至于窗口外的尾部可以忽略不计，那么这种近似就是合理的。\n\n为了进行具有可量化基准真相的数值测试，使用以下解析光学势模型：\n$$\nU(E) = \\frac{A}{E - E_c + i\\,\\Gamma},\n$$\n其中 $A$ 是一个单位为 $\\mathrm{MeV}^2$ 的正常数，$E_c$ 是一个单位为 $\\mathrm{MeV}$ 的中心能量，$\\Gamma$ 是一个单位为 $\\mathrm{MeV}$ 的宽度参数。这得到：\n$$\n\\Re U(E) = A\\,\\frac{E - E_c}{(E - E_c)^2 + \\Gamma^2},\n\\qquad\n\\Im U(E) = -A\\,\\frac{\\Gamma}{(E - E_c)^2 + \\Gamma^2},\n$$\n两者的单位均为 $\\mathrm{MeV}$。根据解析性，上述减除 Kramers–Kronig 关系对于无限积分限必须精确成立；在数值上，你将检验当主值积分被截断到 $[E_{\\min},E_{\\max}]$ 时，该关系是否在微小误差范围内成立。\n\n你的程序必须：\n- 实现上述给定解析模型的 $\\Im U(E)$ 和 $\\Re U(E)$。\n- 对每个测试用例，在积分窗口内的一组能量 $E$ 上计算减除色散关系的预测值\n$$\nD(E;E_0) \\equiv \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\Im U(E')\n\\left[\n\\frac{1}{E' - E} - \\frac{1}{E' - E_0}\n\\right]\\,\\mathrm{d}E'\n$$\n并将其与精确差值 $\\Re U(E) - \\Re U(E_0)$ 进行比较。\n- 对点 $E$ 和 $E_0$ 处的积分使用 Cauchy 主值定义。\n- 对每个测试用例，报告一个等于在所提供的 $E$ 网格上的最大绝对偏差的单个标量结果：\n$$\n\\max_{E\\in \\mathcal{E}} \\left| \\left(\\Re U(E) - \\Re U(E_0)\\right) - D(E;E_0) \\right|,\n$$\n以 $\\mathrm{MeV}$ 为单位表示。\n\n所有能量、宽度和势值都必须以 $\\mathrm{MeV}$ 为单位处理。你最终打印的输出必须是以 $\\mathrm{MeV}$ 为单位的浮点数。\n\n测试套件：\n- 情况 1 (一般情况)：\n  - $A = 150\\,\\mathrm{MeV}^2$, $E_c = 40\\,\\mathrm{MeV}$, $\\Gamma = 8\\,\\mathrm{MeV}$。\n  - 减除点 $E_0 = 30\\,\\mathrm{MeV}$。\n  - 积分窗口 $[E_{\\min},E_{\\max}] = [-160\\,\\mathrm{MeV},\\,240\\,\\mathrm{MeV}]$。\n  - 计算集 $\\mathcal{E} = \\{10,\\,20,\\,30,\\,40,\\,50,\\,60,\\,80\\}\\,\\mathrm{MeV}$。\n- 情况 2 (边界情况，$E_0$ 等于一个计算能量)：\n  - $A = 80\\,\\mathrm{MeV}^2$, $E_c = 50\\,\\mathrm{MeV}$, $\\Gamma = 12\\,\\mathrm{MeV}$。\n  - 减除点 $E_0 = 50\\,\\mathrm{MeV}$。\n  - 积分窗口 $[E_{\\min},E_{\\max}] = [-250\\,\\mathrm{MeV},\\,350\\,\\mathrm{MeV}]$。\n  - 计算集 $\\mathcal{E} = \\{20,\\,40,\\,50,\\,60,\\,80,\\,100\\}\\,\\mathrm{MeV}$。\n- 情况 3 (边缘情况，宽度非常窄)：\n  - $A = 100\\,\\mathrm{MeV}^2$, $E_c = 10\\,\\mathrm{MeV}$, $\\Gamma = 0.5\\,\\mathrm{MeV}$。\n  - 减除点 $E_0 = 0\\,\\mathrm{MeV}$。\n  - 积分窗口 $[E_{\\min},E_{\\max}] = [-100\\,\\mathrm{MeV},\\,120\\,\\mathrm{MeV}]$。\n  - 计算集 $\\mathcal{E} = \\{5,\\,9.5,\\,10.0,\\,10.5,\\,20,\\,40\\}\\,\\mathrm{MeV}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含三个结果，形式为用方括号括起来的逗号分隔列表，单位为 $\\mathrm{MeV}$，每个结果四舍五入到六位小数。例如，输出应如下所示：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$",
            "solution": "该问题要求对弹性散射理论中使用的模型光学势 $U(E)$ 的减除 Kramers–Kronig (KK) 色散关系进行数值验证。验证过程涉及将解析已知的势的实部与通过对其虚部进行积分计算出的值进行比较。\n\n基本原理是因果性。在物理学中，一个因果响应函数（即结果不先于原因）在数学上被表示为一个在复频率（或能量）平面的上半平面解析的函数。由 Titchmarsh 定理确立的这种解析性的一个直接推论是，函数的实部和虚部不是独立的，而是通过 Kramers–Kronig 关系相关联。对于当 $|E| \\to \\infty$ 时衰减不够快的光学势 $U(E)$，使用减除形式的色散关系来确保积分收敛。在选定的减除能量 $E_0$ 处，该关系为：\n$$\n\\Re U(E) - \\Re U(E_0) = \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{-\\infty}^{+\\infty} \\Im U(E') \\left[ \\frac{1}{E' - E} - \\frac{1}{E' - E_0} \\right]\\,\\mathrm{d}E'\n$$\n其中 $\\mathcal{P}$ 表示积分的 Cauchy 主值。\n\n问题为该势提供了一个特定的解析模型，该模型在下半平面有一个单极点，从而满足因果性要求。该势由以下公式给出：\n$$\nU(E) = \\frac{A}{E - E_c + i\\,\\Gamma}\n$$\n其中 $A$ 是一个单位为 $\\mathrm{MeV}^2$ 的强度参数，$E_c$ 是一个单位为 $\\mathrm{MeV}$ 的共振能量，$\\Gamma$ 是一个单位为 $\\mathrm{MeV}$ 的宽度参数，且 $\\Gamma > 0$。该势的实部和虚部分别为：\n$$\n\\Re U(E) = A\\,\\frac{E - E_c}{(E - E_c)^2 + \\Gamma^2}\n$$\n$$\n\\Im U(E) = -A\\,\\frac{\\Gamma}{(E - E_c)^2 + \\Gamma^2}\n$$\n\n任务是在一个有限的积分窗口 $[E_{\\min}, E_{\\max}]$ 上数值计算 KK 关系的右侧，记作 $D(E; E_0)$：\n$$\nD(E;E_0) \\equiv \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\Im U(E') \\left[ \\frac{1}{E' - E} - \\frac{1}{E' - E_0} \\right]\\,\\mathrm{d}E'\n$$\n并量化其相对于解析已知的左侧 $\\Re U(E) - \\Re U(E_0)$ 的偏差。在一组给定的计算能量 $\\mathcal{E}$ 上的最大绝对偏差是每个测试用例的最终结果。\n\n数值计算的挑战在于 Cauchy 主值积分的计算。被积函数在 $E' = E$ 和 $E' = E_0$ 处有奇点。$D(E; E_0)$ 的积分可以分解为两个独立的主值积分：\n$$\nD(E; E_0) = \\frac{1}{\\pi} \\left( \\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\frac{\\Im U(E')}{E' - E}\\,\\mathrm{d}E' - \\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\frac{\\Im U(E')}{E' - E_0}\\,\\mathrm{d}E' \\right)\n$$\n每个积分都具有 $\\mathcal{P}\\int_a^b \\frac{g(x)}{x-c}\\,\\mathrm{d}x$ 的形式。这类积分可以使用专门的数值求积例程进行稳健计算。Python 的 SciPy 库中的 `scipy.integrate.quad` 函数非常适合此任务，它提供了一个 `weight='cauchy'` 选项，该选项接受函数 $g(x)$ 和奇点位置 $c$（作为 `wvar`）作为参数来计算主值。\n\n总体算法如下：\n1.  对每个测试用例，定义参数 $(A, E_c, \\Gamma)$、减除点 $E_0$、积分窗口 $[E_{\\min}, E_{\\max}]$ 和计算能量集合 $\\mathcal{E}$。\n2.  根据解析公式实现计算 $\\Re U(E)$ 和 $\\Im U(E)$ 的函数。\n3.  一个循环遍历每个计算能量 $E \\in \\mathcal{E}$。\n4.  在循环内部，对每个 $E$：\n    a. 直接计算“精确”差值 $\\Delta_{\\text{exact}} = \\Re U(E) - \\Re U(E_0)$。\n    b. 计算色散积分项 $D(E; E_0)$。如果 $E = E_0$，被积函数恒为零，因此 $D(E_0; E_0) = 0$。否则，使用带有 Cauchy 权重的 `scipy.integrate.quad` 计算两个主值积分，并将其差值乘以 $1/\\pi$。\n    c. 计算绝对偏差 $|\\Delta_{\\text{exact}} - D(E; E_0)|$。\n5.  在所有 $E \\in \\mathcal{E}$ 中找到这些偏差的最大值，并将其作为该测试用例的结果存储。这个小的非零结果量化了主要由将无限积分范围截断到 $[E_{\\min}, E_{\\max}]$ 所引入的误差，因为模型函数 $\\Im U(E')$ 的尾部延伸至 $\\pm\\infty$。\n6.  对所有三个指定的测试用例重复此过程，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It verifies the dispersive optical model consistency by checking the\n    Kramers-Kronig relation for a model potential.\n    \"\"\"\n\n    def Re_U(E, A, Ec, Gamma):\n        \"\"\"\n        Calculates the real part of the model optical potential.\n        \n        Args:\n            E (float): Energy in MeV.\n            A (float): Strength parameter in MeV^2.\n            Ec (float): Centroid energy in MeV.\n            Gamma (float): Width parameter in MeV.\n        \n        Returns:\n            float: Real part of the potential in MeV.\n        \"\"\"\n        return A * (E - Ec) / ((E - Ec)**2 + Gamma**2)\n\n    def Im_U(E_prime, A, Ec, Gamma):\n        \"\"\"\n        Calculates the imaginary part of the model optical potential.\n\n        Args:\n            E_prime (float): Integration variable for energy in MeV.\n            A (float): Strength parameter in MeV^2.\n            Ec (float): Centroid energy in MeV.\n            Gamma (float): Width parameter in MeV.\n        \n        Returns:\n            float: Imaginary part of the potential in MeV.\n        \"\"\"\n        return -A * Gamma / ((E_prime - Ec)**2 + Gamma**2)\n\n    def calculate_dispersion_integral(E, E0, Emin, Emax, A, Ec, Gamma):\n        \"\"\"\n        Calculates the subtracted dispersion integral D(E; E0) using a\n        Cauchy principal value numerical integration.\n        D(E;E0) = (1/pi) * P.V. integral[Im_U(E') * (1/(E'-E) - 1/(E'-E0))] dE'\n        \"\"\"\n        # If the evaluation energy is the same as the subtraction point,\n        # the integrand is zero everywhere, so the integral is zero.\n        if E == E0:\n            return 0.0\n\n        # The function passed to quad should be Im_U(E'). The (1/(E'-c)) part\n        # is handled by the 'cauchy' weight.\n        args_for_Im_U = (A, Ec, Gamma)\n\n        # Calculate the first principal value integral, with singularity at E.\n        integral_1, _ = quad(Im_U, Emin, Emax, args=args_for_Im_U, weight='cauchy', wvar=E)\n        \n        # Calculate the second principal value integral, with singularity at E0.\n        integral_2, _ = quad(Im_U, Emin, Emax, args=args_for_Im_U, weight='cauchy', wvar=E0)\n\n        # Combine results according to the dispersion relation formula.\n        D_E_E0 = (1.0 / np.pi) * (integral_1 - integral_2)\n        return D_E_E0\n\n    def solve_case(params):\n        \"\"\"\n        Solves a single test case.\n        \n        Args:\n            params (dict): A dictionary containing all parameters for the case.\n            \n        Returns:\n            float: The maximum absolute deviation in MeV.\n        \"\"\"\n        A = params['A']\n        Ec = params['Ec']\n        Gamma = params['Gamma']\n        E0 = params['E0']\n        Emin, Emax = params['window']\n        E_set = params['E_set']\n        \n        max_deviation = 0.0\n\n        for E_eval in E_set:\n            # Calculate the expected difference from the analytic formula for Re(U).\n            exact_diff = Re_U(E_eval, A, Ec, Gamma) - Re_U(E0, A, Ec, Gamma)\n            \n            # Calculate the difference from the numerical dispersion integral.\n            numerical_D = calculate_dispersion_integral(E_eval, E0, Emin, Emax, A, Ec, Gamma)\n            \n            # Calculate the absolute deviation.\n            deviation = np.abs(exact_diff - numerical_D)\n            \n            # Update the maximum deviation found so far.\n            if deviation > max_deviation:\n                max_deviation = deviation\n                \n        return max_deviation\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": 150.0, \"Ec\": 40.0, \"Gamma\": 8.0,\n            \"E0\": 30.0,\n            \"window\": [-160.0, 240.0],\n            \"E_set\": [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 80.0]\n        },\n        {\n            \"A\": 80.0, \"Ec\": 50.0, \"Gamma\": 12.0,\n            \"E0\": 50.0,\n            \"window\": [-250.0, 350.0],\n            \"E_set\": [20.0, 40.0, 50.0, 60.0, 80.0, 100.0]\n        },\n        {\n            \"A\": 100.0, \"Ec\": 10.0, \"Gamma\": 0.5,\n            \"E0\": 0.0,\n            \"window\": [-100.0, 120.0],\n            \"E_set\": [5.0, 9.5, 10.0, 10.5, 20.0, 40.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats with 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}