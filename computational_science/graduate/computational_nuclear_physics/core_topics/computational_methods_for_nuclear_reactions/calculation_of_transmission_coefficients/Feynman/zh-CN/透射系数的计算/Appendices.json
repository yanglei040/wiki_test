{
    "hands_on_practices": [
        {
            "introduction": "在核散射理论中，散射矩阵（S矩阵）包含了散射过程的全部信息。透射系数 $T_l$ 直接从S矩阵的模推导得出，它量化了发生非弹性反应的概率。这项练习  将引导你完成一个基础但至关重要的计算，将一个给定的S矩阵元素与可观测的反应截面直接联系起来，从而加深对通量守恒和光学模型基本原理的理解。",
            "id": "3548631",
            "problem": "在核子-原子核散射的光学模型描述中，角动量为$l$、能量为$E$的分波散射矩阵（S矩阵）可以写成$S_{l}(E)=\\eta_{l}(E)\\exp\\!\\big(2 i \\delta_{l}(E)\\big)$，其中$0 \\le \\eta_{l}(E) \\le 1$表示非弹性，$\\delta_{l}(E)$是一个实相移。透射系数$T_{l}(E)$表示在第$l$个分波中发生反应（非弹性过程）的概率，并受流守恒的约束。单个分波$l$对反应截面$\\Delta \\sigma_{\\text{reac}}$的贡献取决于$T_{l}(E)$和波数$k$。\n\n对于一个复光学势的数值计算，在波数$k=1.0\\ \\text{fm}^{-1}$和$l=2$时，得到$S_{l}(E)=0.7\\,\\exp(2 i \\tau)$，其中$\\tau$是一个实数。从标准的分波幺正性和流守恒原理出发，确定该分波的透射系数$T_{l}(E)$以及相应的单分波对反应截面的贡献$\\Delta \\sigma_{\\text{reac}}$。将$\\Delta \\sigma_{\\text{reac}}$以毫靶为单位表示，使用$1\\ \\text{barn}=100\\ \\text{fm}^{2}$和$1\\ \\text{millibarn}=10^{-3}\\ \\text{barn}$。将反应截面贡献四舍五入到四位有效数字。以两个值的形式提供最终结果：$T_{l}(E)$和$\\Delta \\sigma_{\\text{reac}}$（单位为毫靶）。",
            "solution": "该问题经核实具有科学依据、良定且客观。它展示了量子散射理论和核光学模型框架内的一个标准计算。所有提供的信息都是一致的，并且足以得到唯一解。\n\n该问题要求计算特定分波的两个量：透射系数$T_{l}(E)$和对反应截面的贡献$\\Delta \\sigma_{\\text{reac}}$。我们已知角动量$l=2$、波数$k=1.0\\ \\text{fm}^{-1}$时的分波散射矩阵元$S_{l}(E)$。\n\n散射矩阵元的一般形式为$S_{l}(E)=\\eta_{l}(E)\\exp\\!\\big(2 i \\delta_{l}(E)\\big)$，其中$\\eta_{l}(E)$是非弹性参数，$\\delta_{l}(E)$是实相移。数值计算提供的值为$S_{l=2}(E)=0.7\\,\\exp(2 i \\tau)$，其中$\\tau$是一个实数。通过比较一般形式与给定值，我们可以确定此特定分波和能量下的非弹性参数：\n$$\n\\eta_{l=2}(E) = |S_{l=2}(E)| = |0.7\\,\\exp(2 i \\tau)| = 0.7\n$$\n条件$0 \\le \\eta_{l}(E) \\le 1$得到满足，因为$0 \\le 0.7 \\le 1$。小于$1$的非弹性参数表示弹性通道存在通量损失，这对应于反应（非弹性过程）的发生。\n\n透射系数$T_{l}(E)$表示分波$l$中的入射粒子发生反应的概率。根据流守恒原理（S矩阵的幺正性），入射粒子的总概率必须为1。粒子可以弹性散射或发生反应。对于给定的分波，弹性散射的概率由$|S_{l}(E)|^2$给出。因此，反应的概率必须是剩余的部分：\n$$\nT_{l}(E) = 1 - |S_{l}(E)|^2\n$$\n使用关系式$|S_{l}(E)| = \\eta_{l}(E)$，上式可以写成：\n$$\nT_{l}(E) = 1 - \\eta_{l}(E)^2\n$$\n对于给定的分波$l=2$，我们有$\\eta_{l=2}(E) = 0.7$。将此值代入透射系数的方程中：\n$$\nT_{l=2}(E) = 1 - (0.7)^2 = 1 - 0.49 = 0.51\n$$\n这是第一个所求的量。\n\n第二个所求的量是该单分波对总反应截面的贡献，记为$\\Delta \\sigma_{\\text{reac}}$。分波反应截面的标准公式为：\n$$\n\\Delta \\sigma_{\\text{reac}} = \\sigma_{\\text{reac}, l} = \\frac{\\pi}{k^2} (2l+1) T_{l}(E)\n$$\n我们已知波数$k=1.0\\ \\text{fm}^{-1}$，角动量量子数$l=2$，并且我们刚刚计算出透射系数$T_{l=2}(E) = 0.51$。将这些值代入公式：\n$$\n\\Delta \\sigma_{\\text{reac}} = \\frac{\\pi}{(1.0\\ \\text{fm}^{-1})^2} (2(2)+1) (0.51)\n$$\n$$\n\\Delta \\sigma_{\\text{reac}} = \\frac{\\pi}{1.0\\ \\text{fm}^{-2}} (5) (0.51)\n$$\n$$\n\\Delta \\sigma_{\\text{reac}} = 2.55 \\pi\\ \\text{fm}^2\n$$\n现在，我们必须将此结果转换为要求的单位毫靶（mb）。给定的转换因子是：\n$1\\ \\text{barn} = 100\\ \\text{fm}^2$\n$1\\ \\text{millibarn} = 10^{-3}\\ \\text{barn}$\n\n由此，我们可以推导出$\\text{fm}^2$和$\\text{mb}$之间的直接转换关系：\n$$\n1\\ \\text{mb} = 10^{-3} \\times (100\\ \\text{fm}^2) = 10^{-1}\\ \\text{fm}^2 = 0.1\\ \\text{fm}^2\n$$\n因此，要从$\\text{fm}^2$转换为$\\text{mb}$，我们必须乘以因子$10$：\n$$\n1\\ \\text{fm}^2 = 10\\ \\text{mb}\n$$\n将此转换应用于我们对$\\Delta \\sigma_{\\text{reac}}$的结果：\n$$\n\\Delta \\sigma_{\\text{reac}} = (2.55 \\pi\\ \\text{fm}^2) \\times \\left(\\frac{10\\ \\text{mb}}{1\\ \\text{fm}^2}\\right) = 25.5 \\pi\\ \\text{mb}\n$$\n计算其数值：\n$$\n\\Delta \\sigma_{\\text{reac}} \\approx 25.5 \\times 3.14159265... \\text{ mb} \\approx 80.110612... \\text{ mb}\n$$\n问题要求将此值四舍五入到四位有效数字。前四位有效数字是$8$、$0$、$1$和$1$。第五位是$0$，所以我们不向上取整。\n$$\n\\Delta \\sigma_{\\text{reac}} \\approx 80.11\\ \\text{mb}\n$$\n最终的两个值为$T_{l=2}(E) = 0.51$和$\\Delta \\sigma_{\\text{reac}} = 80.11\\ \\text{mb}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.51  80.11 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "传递矩阵法是求解给定势垒下量子散射问题的核心数值算法。这项练习  要求你从第一性原理出发，为一个双势垒模型编写一个完整的计算程序。通过这个实践，你不仅能掌握传递矩阵法的实现细节，还能直观地观察到共振隧穿和相干相消等关键量子现象，这些现象在理解核裂变等过程中至关重要。",
            "id": "3548674",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序计算通过一个对称双势垒势的一维量子透射系数，该势垒作为一个两步核裂变的玩具模型。该模型应能捕捉到跨越中间势阱的相干干涉，并揭示相消干涉抑制隧穿效应的条件。严格在自然单位制下工作，其中$\\hbar^2/(2m)=1$，因此能量、长度和波数都是无量纲的。透射系数是无量纲的，必须以小数形式报告。角度必须以弧度解释。\n\n从稳态一维薛定谔方程 $-\\dfrac{d^2\\psi}{dx^2}+V(x)\\psi=E\\psi$ 出发，利用波函数及其空间导数在界面上的连续性，推导出一个算法来计算由平面层构成的分段常数势的透射系数 $T(E)$。您的实现必须支持经典禁区的复波数，并跟踪每个区域的相位累积。\n\n构建一个对称双势垒势，其中有两个相同的高度为 $V_0$、宽度为 $a$ 的矩形势垒，由一个宽度为 $b$、势为 $V_w$ 的中心势阱隔开。左右引线区是 $V=0$ 的自由区域。在所选单位制中，所有量都是无量纲的。\n\n您的程序必须实现一个基于薛定谔方程基本边界条件的、数值稳定的通用传输方法。该算法应能接受任意连续层 $(V_j,d_j)$ 的列表，并通过在所有界面上匹配平面波解来计算 $T(E)$，形成一个从左引线区到右引线区的总传输算符，并利用引线区中的通量归一化来获得透射系数。不要使用任何预先制表的特例公式；直接从连续性和平面波推导您的关系。\n\n测试套件。使用以下参数集和能量。按确切顺序计算并汇总指定的输出。所有给出的数字都是无量纲的。\n\n- 集合 $\\mathrm{S1}$ (对称双势垒): $V_0=5.0$, $a=1.0$, $V_w=0.0$, $b=4.0$。在两个能量点进行评估：\n  - $E_{\\mathrm{S1},d}=3.853981633974483$。\n  - $E_{\\mathrm{S1},c}=2.4674011002723395$。\n  对于 $\\mathrm{S1}$，报告：\n  - $T(E_{\\mathrm{S1},d})$。\n  - $T(E_{\\mathrm{S1},c})$。\n  - 一个布尔值，指示 $T(E_{\\mathrm{S1},d})/T(E_{\\mathrm{S1},c})  0.01$ 是否成立。\n\n- 集合 $\\mathrm{S2}$ (势垒合并极限): $V_0=5.0$, $a=1.0$, $V_w=0.0$, $b=1.0\\times 10^{-6}$。在能量 $E=1.0$ 时，计算：\n  - $T_{\\mathrm{dbl}}$，对称双势垒在 $b=1.0\\times 10^{-6}$ 时的透射系数。\n  - $T_{\\mathrm{sgl}}$，在相同引线区之间，高度为 $V_0=5.0$、宽度为 $2a=2.0$ 的单个矩形势垒的透射系数。\n  报告一个布尔值，指示 $\\lvert T_{\\mathrm{dbl}}-T_{\\mathrm{sgl}}\\rvert  10^{-6}$ 是否成立。\n\n- 集合 $\\mathrm{S3}$ (使用 $\\mathrm{S1}$ 几何结构的高能极限): 当 $V_0=5.0$, $a=1.0$, $V_w=0.0$, $b=4.0$ 且能量 $E=50.0$ 时，报告 $T(50.0)$。\n\n- 集合 $\\mathrm{S4}$ (抬高的中间势阱): $V_0=5.0$, $a=1.0$, $V_w=1.0$, $b=4.0$。在能量 $E_{\\mathrm{S4},d}=4.853981633974483$ 时，报告 $T(E_{\\mathrm{S4},d})$。\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中按顺序包含以下条目：\n- $T(E_{\\mathrm{S1},d})$,\n- $T(E_{\\mathrm{S1},c})$,\n- $\\mathrm{S1}$ 中抑制效应的布尔值,\n- 势垒合并极限 $\\mathrm{S2}$ 的布尔值,\n- $\\mathrm{S3}$ 的 $T(50.0)$,\n- $\\mathrm{S4}$ 的 $T(E_{\\mathrm{S4},d})$。\n\n例如，输出格式必须类似于 $[x_1,x_2,\\mathrm{True},\\mathrm{False},x_5,x_6]$，其中 $x_j$ 的位置应为实际的浮点数值。\n\n要报告的量是无量纲的；不要附加单位。内部使用的所有角度都以弧度为单位。最终程序必须是自包含的，不得读取输入文件或需要用户交互。最终打印的行必须严格符合指定的方括号列表格式。",
            "solution": "该问题要求设计并实现一个算法，用于计算能量为 $E$ 的粒子入射到一维分段常数势上的量子力学透射系数 $T(E)$。该方法必须从第一性原理推导，即不含时薛定谔方程以及波函数及其导数的连续性。我们在 $\\hbar^2/(2m)=1$ 的自然单位制下工作。\n\n对于质量为 $m$、能量为 $E$ 的粒子在势 $V(x)$ 中的运动，其一维不含时薛定谔方程为：\n$$-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)$$\n在指定的单位制下，该方程简化为：\n$$-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x) \\quad \\implies \\quad \\frac{d^2\\psi(x)}{dx^2} = -(E - V(x))\\psi(x)$$\n\n对于分段常数势，空间域被划分为多个区域，在每个区域中 $V(x)$ 为一个常数，记为 $V_j$。在这样的区域 $j$ 内部，方程变为：\n$$\\frac{d^2\\psi_j(x)}{dx^2} = -k_j^2 \\psi_j(x)$$\n其中波数 $k_j$ 定义为 $k_j = \\sqrt{E - V_j}$。如果 $E  V_j$，$k_j$ 是一个纯虚数，$k_j = i\\kappa_j$，其中 $\\kappa_j = \\sqrt{V_j - E}$。为了统一处理所有情况，我们将 $k_j$ 视为一个复数。区域 $j$ 中的通解是前向和后向传播平面波的叠加：\n$$\\psi_j(x) = A_j e^{ik_j x} + B_j e^{-ik_j x}$$\n\n指定算法的核心是传输矩阵法。该方法将波函数在空间中两个不同点的状态——由其值及其空间导数构成的向量 $\\mathbf{S}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}$——关联起来。\n\n考虑一个从 $x_{j-1}$ 到 $x_j$ 的单个势垒层 $j$，其势为常数 $V_j$，宽度为 $d_j = x_j - x_{j-1}$。我们可以建立该层起始点和结束点状态向量之间的矩阵关系。\n该层内任意点 $x$ 的状态向量可以用系数 $A_j$ 和 $B_j$ 表示（使用局部坐标 $x' = x-x_{j-1}$）：\n$$\\psi_j(x') = A_j e^{ik_j x'} + B_j e^{-ik_j x'}$$\n$$\\psi'_j(x') = ik_j(A_j e^{ik_j x'} - B_j e^{-ik_j x'})$$\n\n通过代数操作，我们可以用在 $x' = 0$ 处的状态向量来表示在 $x' = d_j$ 处的状态向量：\n$$\\psi_j(d_j) = \\psi_j(0) \\cos(k_j d_j) + \\psi'_j(0) \\frac{\\sin(k_j d_j)}{k_j}$$\n$$\\psi'_j(d_j) = -\\psi_j(0) k_j \\sin(k_j d_j) + \\psi'_j(0) \\cos(k_j d_j)$$\n这可以写成矩阵形式：\n$$\\begin{pmatrix} \\psi(x_j) \\\\ \\psi'(x_j) \\end{pmatrix} = \\mathbf{M}_j \\begin{pmatrix} \\psi(x_{j-1}) \\\\ \\psi'(x_{j-1}) \\end{pmatrix}$$\n其中 $\\mathbf{M}_j$ 是层 $j$ 的传输矩阵：\n$$\\mathbf{M}_j = \\begin{pmatrix} \\cos(k_j d_j)  \\frac{\\sin(k_j d_j)}{k_j} \\\\ -k_j \\sin(k_j d_j)  \\cos(k_j d_j) \\end{pmatrix}$$\n这种形式是数值稳定且通用的。对于 $E=V_j$ 的特殊情况，有 $k_j=0$。在此极限下，$\\cos(k_j d_j) \\to 1$，且 $\\sin(k_j d_j)/k_j \\to d_j$，得到矩阵 $\\mathbf{M}_j = \\begin{pmatrix} 1  d_j \\\\ 0  1 \\end{pmatrix}$，这对应于 $\\psi''=0$ 的解。$\\mathbf{M}_j$ 的行列式始终为 $1$。\n\n对于一个由 $N$ 个连续层组成、从 $x=0$ 开始到 $x=L$ 结束的势，总传输矩阵 $\\mathbf{M}_{\\mathrm{total}}$ 是各个层矩阵的乘积：\n$$\\mathbf{M}_{\\mathrm{total}} = \\mathbf{M}_N \\mathbf{M}_{N-1} \\cdots \\mathbf{M}_1$$\n这个总矩阵将结构起始点 ($x=0$) 的状态向量与结束点 ($x=L$) 的状态向量关联起来：\n$$\\begin{pmatrix} \\psi(L) \\\\ \\psi'(L) \\end{pmatrix} = \\mathbf{M}_{\\mathrm{total}} \\begin{pmatrix} \\psi(0) \\\\ \\psi'(0) \\end{pmatrix}$$\n\n为了求得透射系数 $T$，我们在引线区（其中 $V=0$）应用边界条件。假设势结构被限制在 $x=0$ 和 $x=L$ 之间。\n- 对于 $x0$（左引线区），波函数是入射波（振幅 $A_0=1$）和反射波（振幅 $B_0$）的和：\n  $\\psi_{L}(x) = e^{ik_0 x} + B_0 e^{-ik_0 x}$，其中 $k_0 = \\sqrt{E}$。\n- 对于 $x>L$（右引线区），由于粒子从左侧入射，只有透射波（振幅 $C_N$）：\n  $\\psi_{R}(x) = C_N e^{ik_0 (x-L)}$。\n\n在边界处，状态向量为：\n- 在 $x=0$ 处：$\\psi(0) = 1 + B_0$，$\\psi'(0) = ik_0(1-B_0)$。\n- 在 $x=L$ 处：$\\psi(L) = C_N$，$\\psi'(L) = ik_0 C_N$。\n\n为了求得透射振幅 $t=C_N/A_0 = C_N$，使用逆关系更为方便：\n$$\\begin{pmatrix} \\psi(0) \\\\ \\psi'(0) \\end{pmatrix} = \\mathbf{M}_{\\mathrm{total}}^{-1} \\begin{pmatrix} \\psi(L) \\\\ \\psi'(L) \\end{pmatrix}$$\n由于 $\\det(\\mathbf{M}_{\\mathrm{total}})=1$，其逆矩阵很简单。设 $\\mathbf{M}_{\\mathrm{total}} = \\begin{pmatrix} M_{11}  M_{12} \\\\ M_{21}  M_{22} \\end{pmatrix}$，则 $\\mathbf{M}_{\\mathrm{total}}^{-1} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix}$。\n代入边界条件：\n$$\\begin{pmatrix} 1+B_0 \\\\ ik_0(1-B_0) \\end{pmatrix} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix} \\begin{pmatrix} C_N \\\\ ik_0 C_N \\end{pmatrix}$$\n这得到两个方程：\n$1+B_0 = (M_{22} - ik_0 M_{12})C_N$\n$ik_0(1-B_0) = (-M_{21} + ik_0 M_{11})C_N$\n将第一个方程乘以 $ik_0$ 后加到第二个方程上以消去 $B_0$：\n$ik_0(1+B_0) + ik_0(1-B_0) = ik_0(M_{22} - ik_0 M_{12})C_N + (-M_{21} + ik_0 M_{11})C_N$\n$2ik_0 = [ik_0 M_{22} + k_0^2 M_{12} - M_{21} + ik_0 M_{11}]C_N$\n解出透射振幅 $t = C_N$：\n$$t = \\frac{2ik_0}{(k_0^2 M_{12} - M_{21}) + i k_0 (M_{11} + M_{22})}$$\n透射系数是振幅的模平方，$T = |t|^2$：\n$$T(E) = \\frac{4 k_0^2}{|(k_0^2 M_{12} - M_{21}) + i k_0 (M_{11} + M_{22})|^2} = \\frac{4 k_0^2}{(k_0^2 M_{12} - M_{21})^2 + k_0^2 (M_{11} + M_{22})^2}$$\n\n这提供了一个通用的算法。对于每个测试用例，我们定义层的序列 $(V_j, d_j)$，构建总传输矩阵 $\\mathbf{M}_{\\mathrm{total}}$，然后使用最终公式计算 $T(E)$。整个计算过程使用复数算术处理 $k_j$ 和矩阵元素，以确保通用性。提供的测试用例探究了特定的物理现象：共振隧穿（$T(E_{\\mathrm{S1},c})$）、相消干涉（$T(E_{\\mathrm{S1},d})$, $T(E_{\\mathrm{S4},d})$）、势垒的合并（$S2$）和高能极限（$S3$）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum transmission problem for various potential configurations.\n    \"\"\"\n\n    def compute_transmission(energy, layers):\n        \"\"\"\n        Computes the transmission coefficient T(E) for a given energy and potential.\n\n        Args:\n            energy (float): The energy of the incident particle.\n            layers (list of tuples): A list of (potential, width) for each layer.\n\n        Returns:\n            float: The transmission coefficient T.\n        \"\"\"\n        # Ensure energy is a float to avoid type issues.\n        E = float(energy)\n\n        # Wave number in the leads (V=0)\n        # Use complex argument in sqrt to handle E0 if necessary, though problem uses E>0.\n        k0 = np.sqrt(E + 0j)\n        if E == 0:\n            return 0.0\n\n        # Initialize total transfer matrix as identity\n        M_total = np.identity(2, dtype=complex)\n\n        # Multiply transfer matrices for each layer\n        for V, d in layers:\n            # Wave number in the layer\n            # Added 0j to ensure complex result for E  V\n            k = np.sqrt(E - V + 0j)\n\n            # Handle the case E = V where k = 0\n            if np.isclose(k, 0):\n                M_layer = np.array([[1, d],\n                                    [0, 1]], dtype=complex)\n            else:\n                cos_val = np.cos(k * d)\n                sin_over_k = np.sin(k * d) / k\n                \n                M_layer = np.array([[cos_val, sin_over_k],\n                                    [-k * np.sin(k * d), cos_val]], dtype=complex)\n\n            # Note the order of multiplication: new matrix is on the left\n            M_total = M_layer @ M_total\n\n        M11, M12 = M_total[0, 0], M_total[0, 1]\n        M21, M22 = M_total[1, 0], M_total[1, 1]\n        \n        # From the derivation in the solution text\n        denominator = (k0**2 * M12 - M21) + 1j * k0 * (M11 + M22)\n        \n        # Avoid division by zero\n        if np.isclose(abs(denominator), 0):\n            return np.inf\n\n        t_amplitude = (2 * 1j * k0) / denominator\n        \n        # Transmission coefficient T = |t|^2\n        T = np.abs(t_amplitude)**2\n        return T\n\n    results = []\n\n    # --- Test Case S1: Symmetric Double Barrier ---\n    V0_s1, a_s1, Vw_s1, b_s1 = 5.0, 1.0, 0.0, 4.0\n    layers_s1 = [(V0_s1, a_s1), (Vw_s1, b_s1), (V0_s1, a_s1)]\n    \n    E_s1_d = 3.853981633974483\n    E_s1_c = 2.4674011002723395\n    \n    T_s1_d = compute_transmission(E_s1_d, layers_s1)\n    T_s1_c = compute_transmission(E_s1_c, layers_s1)\n    \n    results.append(T_s1_d)\n    results.append(T_s1_c)\n    \n    # Check for suppression\n    suppression_s1 = (T_s1_d / T_s1_c  0.01) if T_s1_c > 1e-9 else False\n    results.append(suppression_s1)\n\n    # --- Test Case S2: Barrier Merging Limit ---\n    V0_s2, a_s2, Vw_s2, b_s2 = 5.0, 1.0, 0.0, 1.0e-6\n    E_s2 = 1.0\n    \n    # Double barrier with a tiny well\n    layers_s2_dbl = [(V0_s2, a_s2), (Vw_s2, b_s2), (V0_s2, a_s2)]\n    T_dbl = compute_transmission(E_s2, layers_s2_dbl)\n\n    # Single merged barrier\n    layers_s2_sgl = [(V0_s2, 2 * a_s2)]\n    T_sgl = compute_transmission(E_s2, layers_s2_sgl)\n\n    # Check for merging\n    merging_s2 = abs(T_dbl - T_sgl)  1e-6\n    results.append(merging_s2)\n\n    # --- Test Case S3: High-Energy Limit ---\n    # Use S1 geometry\n    E_s3 = 50.0\n    T_s3 = compute_transmission(E_s3, layers_s1)\n    results.append(T_s3)\n    \n    # --- Test Case S4: Raised Intermediate Well ---\n    V0_s4, a_s4, Vw_s4, b_s4 = 5.0, 1.0, 1.0, 4.0\n    layers_s4 = [(V0_s4, a_s4), (Vw_s4, b_s4), (V0_s4, a_s4)]\n    E_s4_d = 4.853981633974483\n    \n    T_s4_d = compute_transmission(E_s4_d, layers_s4)\n    results.append(T_s4_d)\n\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res))\n        else:\n            # Use a format that avoids scientific notation for most values but is precise.\n            formatted_results.append(f\"{res:.8f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在处理实际的、连续变化的复杂光学势时，直接应用传递矩阵法会遇到数值不稳定的挑战，特别是在存在倏逝波的区域。这项高级练习  旨在揭示这种数值陷阱，并引导你实现一种基于QR分解的稳定化算法。掌握这种技术对于在计算物理学中进行精确可靠的模拟至关重要。",
            "id": "3548698",
            "problem": "考虑一个质量为 $m_p$ 的质子从一个由复光学势模拟的有限厚核物质平板上的一维定态散射。质子从左侧（$x  0$）入射到一个势场随空间变化且为复数的区域 $0 \\le x \\le L$，然后进入自由空间（$x  L$）。使用一维不含时薛定谔方程，\n$$\n-\\frac{\\hbar^2}{2 m_p} \\frac{d^2 \\psi(x)}{dx^2} + U(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其中 $E$ 是实验室坐标系下的动能，$U(x)$ 是复核光学势，$\\psi(x)$ 是波函数。采用自然单位制，其中 $c = 1$，并明确使用 $\\hbar c$，所有能量单位为 $\\mathrm{MeV}$，所有长度单位为 $\\mathrm{fm}$。该平板势是一个具有排斥实部和吸收虚部的 Woods–Saxon 形式，\n$$\nU(x) = \\frac{V_0}{1 + \\exp\\!\\left(\\frac{x - L/2}{a}\\right)} - i\\,\\frac{W_0}{1 + \\exp\\!\\left(\\frac{x - L/2}{a}\\right)},\n$$\n其中 $V_0  0$ 且 $W_0  0$。这种形式模拟了一个有效排斥势垒（例如，质子的库仑贡献）以及相互作用区域内的吸收性核损失。\n\n通过分段常数切片来近似 $U(x)$：将区间 $[0,L]$ 划分为 $N$ 个均匀切片，每个切片的厚度为 $d = L/N$。在每个中点为 $x_j$ 的切片 $j$ 中，取 $U_j = U(x_j)$ 为常数。令左右渐近区域（$x0$ 和 $xL$）的 $U(x)=0$。定义复局域波数\n$$\nk_j = \\sqrt{\\frac{2 m_p \\left(E - U_j\\right)}{\\hbar^2}},\n$$\n在渐近区域中 $k_0 = k_R = \\sqrt{\\frac{2 m_p E}{\\hbar^2}}$，对 $k_j$ 使用复数平方根的主分支。\n\n实现传递矩阵形式，该形式在每个切片界面处强制要求 $\\psi(x)$ 和 $d\\psi/dx$ 的连续性。对于一个厚度为 $d$、波数为 $k$ 的分段常数区域，有一个传播矩阵；对于每个从波数 $k_{\\mathrm{in}}$ 到 $k_{\\mathrm{out}}$ 的界面，有一个界面匹配矩阵。通过将这些 $2\\times 2$ 矩阵跨所有切片和界面相乘，得到总传递矩阵，该矩阵将左侧的入射和反射振幅映射到右侧的透射和从右侧入射的振幅。从总传递矩阵中，计算透射系数 $T(E)$，其定义为透射通量与入射通量之比，表示为一个无量纲的十进制数。\n\n您的程序必须使用两种算法计算三种测试能量下的 $T(E)$：\n- 一种朴素算法，通过直接从左到右乘以 $2\\times 2$ 矩阵来构成完整的传递矩阵。\n- 一种稳定算法，在每个乘法步骤中使用通过 $QR$ 分解的重复正交化来防止由于倏逝波增长引起的数值溢出，然后仔细地重新缩放以重构完整的传递矩阵。\n\n通过计算每种能量下的朴素和稳定透射系数，展示由倏逝波增长引起的数值不稳定性及其通过 $QR$ 稳定化的缓解方法。使用以下固定的物理和数值参数：\n- $m_p = 938.2720813~\\mathrm{MeV}$，\n- $\\hbar c = 197.3269804~\\mathrm{MeV\\,fm}$，\n- $L = 20.0~\\mathrm{fm}$，\n- $a = 0.6~\\mathrm{fm}$，\n- $V_0 = 40.0~\\mathrm{MeV}$，\n- $W_0 = 20.0~\\mathrm{MeV}$，\n- $N = 800$ (因此 $d = L/N$)。\n\n使用以下入射能量测试集，单位均为 $\\mathrm{MeV}$：\n- $E_1 = 5.0$ (远低于势垒且有显著吸收)，\n- $E_2 = 40.0$ (接近排斥势垒顶部)，\n- $E_3 = 200.0$ (远高于势垒)。\n\n对于每种能量 $E_i$，计算两个浮点数：朴素透射系数和稳定透射系数。您的程序应生成单行输出，其中包含六个结果，按以下顺序以逗号分隔列表的形式并用方括号括起来\n$$\n[T_{\\mathrm{naive}}(E_1), T_{\\mathrm{stab}}(E_1), T_{\\mathrm{naive}}(E_2), T_{\\mathrm{stab}}(E_2), T_{\\mathrm{naive}}(E_3), T_{\\mathrm{stab}}(E_3)].\n$$\n所有数字必须是无量纲的十进制数。任何中间指数中的角度必须以弧度处理。确保实现的科学真实性，并在整个过程中一致地使用复数算术。",
            "solution": "用户提供的问题是计算量子力学中一个有效且适定的练习，专门关注通过复光学势的一维散射问题。它要求实现传递矩阵法来求解不含时薛定谔方程，并强调了倏逝波不稳定性这一关键数值问题，该问题通过 QR 稳定化算法得到解决。所有物理参数、数值规格和理论模型在核物理领域都是科学合理且标准的。\n\n解决方案首先为分段常数势建立传递矩阵法的理论框架。随后，开发了两种计算算法：一种是朴素的直接乘法方法，另一种是使用 QR 分解的数值稳定方法。\n\n### 理论框架\n\n问题由一维不含时薛定谔方程支配：\n$$\n-\\frac{\\hbar^2}{2 m_p} \\frac{d^2 \\psi(x)}{dx^2} + U(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n对于每个势为常数的区域，该方程可以重写为简谐振子方程的形式：\n$$\n\\frac{d^2 \\psi(x)}{dx^2} + k^2 \\psi(x) = 0\n$$\n其中 $k$ 是复波数，定义为：\n$$\nk(x) = \\sqrt{\\frac{2 m_p (E - U(x))}{\\hbar^2}} = \\sqrt{\\frac{2 m_p (E - U(x))}{(\\hbar c)^2}}\n$$\n为方便起见，我们使用常数因子 $\\alpha = 2 m_p / (\\hbar c)^2 \\approx 0.0482936~\\mathrm{MeV}^{-1}\\mathrm{fm}^{-2}$。势 $U(x)$ 被离散化为 $N$ 个厚度为 $d=L/N$ 的切片。在第 $j$ 个切片（$j \\in \\{1, \\dots, N\\}$）中，势为常数 $U_j = U(x_j)$，其中 $x_j = (j - 1/2)d$。这导致每个切片都有一个恒定的复波数 $k_j$。在渐近区域 $x0$ 和 $x>L$ 中，势 $U=0$，波数为 $k_0 = \\sqrt{\\alpha E}$，这是一个实数。\n\n对于每个切片 $j$，波函数的一般解是前向传播波和后向传播波的叠加：\n$$\n\\psi_j(x) = A_j e^{i k_j (x - x_{j-1})} + B_j e^{-i k_j (x - x_{j-1})}\n$$\n其中 $A_j$ 和 $B_j$ 是复振幅，$x_{j-1} = (j-1)d$ 是切片的左边界。系统的状态可以用这些振幅的向量表示，$\\mathbf{c}_j = \\begin{pmatrix} A_j \\\\ B_j \\end{pmatrix}$。\n\n传递矩阵法通过在每个界面处强制要求波函数 $\\psi(x)$ 及其导数 $d\\psi/dx$ 的连续性，来连接相邻区域的振幅向量。在一个波数为 $k_j$ 的区域和一个波数为 $k_{j+1}$ 的区域之间的界面 $x=x_j$ 处，这种连续性条件导致一个矩阵关系：\n$$\n\\begin{pmatrix} A_{j+1} \\\\ B_{j+1} \\end{pmatrix} = T^{(j)} \\begin{pmatrix} A_j \\\\ B_j \\end{pmatrix}\n$$\n矩阵 $T^{(j)}$ 是界面矩阵 $I_{j+1 \\leftarrow j}$ 和传播矩阵 $P'_j$ 的乘积：\n$$\nT^{(j)} = I_{j+1 \\leftarrow j} P'_j = \\frac{1}{2} \\begin{pmatrix} 1+\\frac{k_j}{k_{j+1}}  1-\\frac{k_j}{k_{j+1}} \\\\ 1-\\frac{k_j}{k_{j+1}}  1+\\frac{k_j}{k_{j+1}} \\end{pmatrix} \\begin{pmatrix} e^{ik_j d}  0 \\\\ 0  e^{-ik_j d} \\end{pmatrix}\n$$\n通过组合所有 $N$ 个切片和 $x=0$ 处的初始界面的这些矩阵，我们得到总传递矩阵 $M_{\\text{tot}}$，它关联了入射区域（$x0$）和最终透射区域（$x>L$）的振幅：\n$$\n\\begin{pmatrix} A_{\\text{out}} \\\\ B_{\\text{out}} \\end{pmatrix} = M_{\\text{tot}} \\begin{pmatrix} A_{\\text{in}} \\\\ B_{\\text{in}} \\end{pmatrix} \\quad \\text{其中} \\quad M_{\\text{tot}} = T^{(N)} T^{(N-1)} \\cdots T^{(1)} T^{(0)}\n$$\n这里，$T^{(0)}$ 是 $x=0$ 处第一个界面的矩阵（它没有前面的传播部分），而 $j \\in \\{1, \\dots, N\\}$ 的 $T^{(j)}$ 是后续切片的矩阵。\n\n对于一个散射问题，我们设置入射振幅 $A_{\\text{in}}=1$，并要求没有从右边入射的波，因此 $B_{\\text{out}}=0$。设 $M_{\\text{tot}} = \\begin{pmatrix} m_{00}  m_{01} \\\\ m_{10}  m_{11} \\end{pmatrix}$。条件 $B_{\\text{out}}=0$ 得出 $0 = m_{10}(1) + m_{11}B_{\\text{in}}$，由此得到反射振幅为 $B_{\\text{in}} = -m_{10}/m_{11}$。透射振幅为 $A_{\\text{out}} = m_{00}(1) + m_{01}B_{\\text{in}} = (m_{00}m_{11} - m_{01}m_{10})/m_{11} = \\det(M_{\\text{tot}})/m_{11}$。此公式的一个关键特性是 $\\det(M_{\\text{tot}})=1$，因此透射振幅就是 $t = A_{\\text{out}} = 1/m_{11}$。\n\n透射系数 $T(E)$ 是透射概率通量与入射概率通量之比。对于平面波，这简化为 $T = |t|^2 = |1/m_{11}|^2$。\n\n### 数值算法\n\n#### 朴素算法\n该算法通过直接乘以 $N+1$ 个单步矩阵序列 $T^{(j)}$ 来计算 $M_{\\text{tot}}$。虽然直接，但这种方法容易出现数值不稳定性。在能量 $E$ 小于势 $V(x)$ 实部的区域（经典禁区），波数 $k_j$ 有一个显著的正虚部，$\\text{Im}(k_j) = \\gamma_j  0$。传播矩阵 $P'_j$ 包含一个呈指数增长的项 $e^{-ik_j d} = e^{\\gamma_j d} e^{-i\\text{Re}(k_j)d}$。重复乘以包含这些大指数因子的矩阵，会导致结果矩阵 $M_{\\text{tot}}$ 的一列比另一列增长得快得多。这导致了一个数值奇异（病态）的矩阵，其中较小的分量由于有限的浮点精度而丢失。计算出的 $m_{11}$ 值变得不可靠，常常导致溢出、下溢或显著误差，使得计算出的透射系数毫无意义。\n\n#### 使用 QR 分解的稳定算法\n为了规避这种不稳定性，我们必须防止在乘法过程中矩阵列的量级发散。一个稳健的方法是在每一步应用 QR 分解。乘积 $M_{\\text{tot}} = A_N A_{N-1} \\cdots A_0$ 是迭代计算的。\n设矩阵序列为 $\\{A_j\\}_{j=0}^N$。\n1.  通过分解第一个矩阵进行初始化：$A_0 = Q_0 R_0$。\n2.  在随后的每一步 $j=1, \\dots, N$，计算中间矩阵 $C_j = A_j Q_{j-1}$。\n3.  分解这个中间矩阵：$C_j = Q_j R_j$。\n4.  到这一步为止的总矩阵是 $A_j \\cdots A_0 = (A_j Q_{j-1})(R_{j-1} \\cdots R_0) = (Q_j R_j)(R_{j-1} \\cdots R_0) = Q_j (R_j R_{j-1} \\cdots R_0)$。\n\n在遍历所有矩阵后，最终的传递矩阵由 $M_{\\text{tot}} = Q_N R_{\\text{prod}}$ 给出，其中 $R_{\\text{prod}} = R_N R_{N-1} \\cdots R_0$。$Q_j$ 矩阵是酉矩阵，因此是良态的。大的指数增长被隔离到上三角矩阵 $R_j$ 中。这些 $R_j$ 矩阵的乘积可以计算而不会损失精度。最终的重构 $M_{\\text{tot}} = Q_N R_{\\text{prod}}$ 仅在最后执行一次。虽然这最后一步仍然可能涉及大数，但它避免了重复乘以病态矩阵所带来的复合精度损失。该方法为 $m_{11}$ 从而为透射系数 $T$ 提供了一个数值稳定的结果。\n\n提供的 Python 代码实现了这两种算法，展示了朴素方法的失败和稳定 QR 方法的成功，尤其是在波函数呈强倏逝性的低能情况（$E_1=5.0~\\mathrm{MeV}$）下。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    # Physical and numerical parameters\n    m_p = 938.2720813  # Proton mass in MeV/c^2\n    hbar_c = 197.3269804  # h-bar * c in MeV fm\n    L = 20.0  # Slab thickness in fm\n    a = 0.6  # Diffuseness parameter in fm\n    V0 = 40.0  # Real potential strength in MeV\n    W0 = 20.0  # Imaginary potential strength in MeV\n    N = 800   # Number of slices\n    d = L / N # Slice thickness in fm\n\n    # Pre-calculate constant factor for wave number calculation\n    alpha = 2 * m_p / hbar_c**2\n\n    # Test suite of incident energies in MeV\n    energies = [5.0, 40.0, 200.0]\n\n    # Function to define the complex optical potential U(x)\n    def potential(x, L_val, a_val, V0_val, W0_val):\n        return (V0_val - 1j * W0_val) / (1 + np.exp((x - L_val / 2) / a_val))\n\n    # Calculate midpoints of the N slices for potential calculation\n    x_slices = (np.arange(N) + 0.5) * d\n    \n    # Pre-calculate potentials for all slices as they are energy-independent\n    U_slices = potential(x_slices, L, a, V0, W0)\n\n    def get_step_matrices(E, alpha_val, U_slices_val, d_val, N_val):\n        \"\"\"\n        Generates the sequence of transfer matrices for each step.\n        Returns a list of N+1 matrices [A_0, A_1, ..., A_N].\n        Note: The problem description has a slightly ambiguous matrix definition.\n        Here we define A_0 = I_{1-0}, A_j = I_{j+1-j} @ P'_j for j=1..N.\n        Total matrix M_tot = A_N @ ... @ A_1 @ A_0.\n        \"\"\"\n        # Asymptotic wave number (in regions with U=0)\n        k0 = np.sqrt(alpha_val * E + 0j)\n        \n        # Wave numbers inside the slices\n        k_slices = np.sqrt(alpha_val * (E - U_slices_val) + 0j)\n        \n        # Full array of wave numbers: k_left=k0, k_1, ..., k_N, k_right=k0\n        k_all = np.concatenate(([k0], k_slices, [k0]))\n        \n        matrices = []\n        \n        # A_0: Matrix for the first interface (x=0) from region 0 to slice 1\n        k_in, k_out = k_all[0], k_all[1]\n        term = k_in / k_out\n        interface_matrix_0 = 0.5 * np.array([\n            [1 + term, 1 - term],\n            [1 - term, 1 + term]\n        ], dtype=np.complex128)\n        matrices.append(interface_matrix_0)\n        \n        # A_1 to A_N: Matrices for prop. through slice j and interface to j+1\n        for i in range(1, N_val + 1):\n            # Propagate through slice j (k_all[i]) and interface to slice j+1 (k_all[i+1])\n            k_prop = k_all[i]\n            k_in = k_all[i]\n            k_out = k_all[i + 1]\n            \n            # Propagation matrix P'_j\n            prop_matrix = np.array([\n                [np.exp(1j * k_prop * d_val), 0],\n                [0, np.exp(-1j * k_prop * d_val)]\n            ], dtype=np.complex128)\n            \n            # Interface matrix I_{j+1 - j}\n            term = k_in / k_out\n            interface_matrix = 0.5 * np.array([\n                [1 + term, 1 - term],\n                [1 - term, 1 + term]\n            ], dtype=np.complex128)\n\n            # Combined step matrix A_j = I_{j+1 - j} @ P'_j\n            step_matrix = interface_matrix @ prop_matrix\n            matrices.append(step_matrix)\n            \n        return matrices\n\n    results = []\n    \n    for E in energies:\n        # Get the list of N+1 matrices to be multiplied\n        # M_total = A_N @ ... @ A_1 @ A_0\n        step_matrices = get_step_matrices(E, alpha, U_slices, d, N)\n        \n        # --- Naive Algorithm ---\n        m_naive = np.identity(2, dtype=np.complex128)\n        for mat in reversed(step_matrices):\n            m_naive = mat @ m_naive\n        \n        # Calculate transmission coefficient T = 1 / |m_11|^2 (0-indexed)\n        m11_naive = m_naive[1, 1]\n        if np.isinf(np.abs(m11_naive)) or np.isclose(np.abs(m11_naive), 0):\n            t_naive = 0.0\n        else:\n            t_naive = 1.0 / np.abs(m11_naive)**2\n        results.append(t_naive)\n        \n        # --- Stabilized Algorithm (QR Decomposition) ---\n        # M_total = A_N @ ... @ A_0\n        \n        # Initialize with the first matrix A_0\n        Q_accum, R_prod = qr(step_matrices[0])\n        \n        # Loop through the remaining matrices A_1 to A_N\n        for i in range(1, N + 1):\n            C = step_matrices[i] @ Q_accum\n            Q_accum, R_step = qr(C)\n            R_prod = R_step @ R_prod\n\n        # Reconstruct the full, stable matrix M_stab = Q_accum @ R_prod\n        m_stab = Q_accum @ R_prod\n        \n        # Calculate transmission coefficient from the stabilized matrix\n        m11_stab = m_stab[1, 1]\n        t_stab = 1.0 / np.abs(m11_stab)**2\n        results.append(t_stab)\n        \n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}