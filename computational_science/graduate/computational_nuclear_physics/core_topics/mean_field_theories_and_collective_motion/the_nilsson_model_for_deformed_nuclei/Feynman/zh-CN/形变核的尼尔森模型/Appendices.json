{
    "hands_on_practices": [
        {
            "introduction": "原子核的形变可以用多种方式来描述，Nilsson模型使用一个与势场各向异性相关的参数 $\\epsilon_2$，而集体模型则使用几何参数 $\\beta_2$。本练习通过从第一性原理出发，推导这两个参数之间的关系，为您在这两种描述之间建立起一座关键的桥梁，从而加深对形变物理内涵的理解。",
            "id": "3604825",
            "problem": "在用于形变原子核的尼尔森模型（Nilsson model）中，通过一个各向异性谐振子势引入了轴对称四极形变。考虑对一个具有相同粒子数 $A$ 和相同尺寸标度 $R_0$ 的原子核的两种描述：\n\n1. 一个具有轴对称四极形变表面的均匀锐利边界液滴，在小形变极限下其表面由 $R(\\theta) = R_0 \\left[1 + \\beta_2 Y_{20}(\\theta)\\right]$ 描述，其中 $Y_{20}(\\theta) = \\sqrt{\\frac{5}{16\\pi}}\\left(3\\cos^2\\theta - 1\\right)$。\n2. 一种体积守恒的各向异性谐振子密度（代表尼尔森平均场），其轴向频率 $\\omega_{\\perp}$ 和 $\\omega_z$ 在一个小的无量纲尼尔森形变参数 $\\varepsilon_2$ 的线性阶上满足关系式 $\\omega_{\\perp} = \\omega_0\\left(1 + \\frac{\\varepsilon_2}{3}\\right)$ 和 $\\omega_z = \\omega_0\\left(1 - \\frac{2\\varepsilon_2}{3}\\right)$。\n\n仅使用第一性原理，通过在小形变极限下令两种描述的内禀质量四极矩相等，推导尼尔森形变参数 $\\varepsilon_2$ 和集体形变参数 $\\beta_2$ 之间的线性关系。在以下框架内进行推导：\n\n- 将内禀质量四极矩定义为 $Q_0^{(m)} = \\int \\rho(\\mathbf{r})\\left(2 z^2 - x^2 - y^2\\right)\\,d^3 r$。\n- 对于均匀液滴，仅使用关于均匀椭球体和小形变表面 $R(\\theta)$ 的基本几何事实。\n- 对于谐振子密度，利用以下事实：在半经典托马斯-费米（Thomas–Fermi, TF）近似中，密度是标度坐标 $u_x = \\sqrt{\\omega_{\\perp}}\\,x$、$u_y = \\sqrt{\\omega_{\\perp}}\\,y$、$u_z = \\sqrt{\\omega_z}\\,z$ 的球对称函数（不计一个雅可比行列式因子），并且半径为 $R_0$ 的均匀球体在球形极限下的均方半径为 $\\langle r^2\\rangle = \\frac{3}{5} R_0^2$。\n- 假设在线性阶上具有轴对称性和体积守恒。\n\n展示从这些原理到闭式关系 $\\varepsilon_2 = C\\,\\beta_2$ 的所有步骤，其中常数 $C$ 必须被精确确定。将你的最终答案表示为 $\\varepsilon_2$ 关于 $\\beta_2$ 的单一精确解析表达式。最终表达式中不需要数值舍入，也不应包含单位。",
            "solution": "用户希望我验证以下问题，如果问题有效，则提供一个解。\n\n### 第1步：提取已知条件\n- **模型1：均匀锐利边界液滴**\n  - 表面：$R(\\theta) = R_0 \\left[1 + \\beta_2 Y_{20}(\\theta)\\right]$，小 $\\beta_2$。\n  - 球谐函数：$Y_{20}(\\theta) = \\sqrt{\\frac{5}{16\\pi}}\\left(3\\cos^2\\theta - 1\\right)$。\n  - 密度：均匀，$\\rho_0$。\n  - 尺寸标度：$R_0$。\n  - 粒子数：$A$。\n\n- **模型2：各向异性谐振子**\n  - 轴向频率：$\\omega_{\\perp} = \\omega_0\\left(1 + \\frac{\\varepsilon_2}{3}\\right)$ 和 $\\omega_z = \\omega_0\\left(1 - \\frac{2\\varepsilon_2}{3}\\right)$，小 $\\varepsilon_2$。\n  - 密度性质：半经典托马斯-费米密度是标度坐标 $u_x = \\sqrt{\\omega_{\\perp}}\\,x$，$u_y = \\sqrt{\\omega_{\\perp}}\\,y$，$u_z = \\sqrt{\\omega_z}\\,z$ 的球对称函数。\n  - 体积守恒：$\\omega_\\perp^2 \\omega_z = \\text{const}$（由频率关系在线性阶上所蕴含）。\n  - 尺寸标度：$R_0$。\n  - 粒子数：$A$。\n\n- **定义和约束**\n  - 内禀质量四极矩：$Q_0^{(m)} = \\int \\rho(\\mathbf{r})\\left(2 z^2 - x^2 - y^2\\right)\\,d^3 r$。\n  - 球形极限均方半径：$\\langle r^2\\rangle_{sphere} = \\frac{3}{5} R_0^2$。\n  - 任务：通过令两个模型的内禀质量四极矩相等来关联 $\\varepsilon_2$ 和 $\\beta_2$。\n  - 框架：使用第一性原理，假设轴对称性，并在小形变极限下进行计算。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地建立在尼尔森模型的背景下，该模型是描述形变原子核的核结构物理学的基石。液滴模型和各向异性谐振子都是标准的、成熟的物理模型。所引用的所有定义和原理都是该领域的标准。该问题在科学上是合理的。\n2.  **适定性：** 该问题提供了推导所需关系的所有必要定义、常数和关系式。它指定了要使用的确切方法（令四极矩相等）。目标明确定义（求 $\\varepsilon_2 = C\\beta_2$ 中的常数 $C$）。在给定的框架下，预期会有一个唯一解。该问题是适定的。\n3.  **客观性：** 语言精确、定量，没有偏见或主观论断。所有参数和模型都经过了形式化定义。该问题是客观的。\n4.  **完整性和一致性：** 提供了所有必需的信息。在指定的线性近似内，已知条件是内部一致的。例如，体积守恒条件 $\\omega_\\perp^2 \\omega_z = \\omega_0^3$ 在 $\\varepsilon_2$ 的一阶上成立。\n5.  **其他缺陷：** 该问题没有表现出任何其他缺陷，如不可形式化、过于琐碎或不可验证。这是一个标准的、尽管详细的理论物理推导。\n\n### 第3步：结论和行动\n该问题是**有效的**。我将继续进行求解。\n\n为了推导 $\\varepsilon_2$ 和 $\\beta_2$ 之间的关系，我们将为两种原子核描述分别计算内禀质量四极矩 $Q_0^{(m)}$，然后令它们相等。给出的定义是：\n$$\nQ_0^{(m)} = \\int \\rho(\\mathbf{r})\\left(2 z^2 - x^2 - y^2\\right)\\,d^3 r\n$$\n对于一个轴对称系统，$x^2+y^2=r_\\perp^2$，因此被积函数是 $(2z^2 - r_\\perp^2)$。在球坐标系中，$z = r\\cos\\theta$ 且 $r_\\perp = r\\sin\\theta$。该项变为 $2(r\\cos\\theta)^2 - (r\\sin\\theta)^2 = r^2(2\\cos^2\\theta - \\sin^2\\theta) = r^2(3\\cos^2\\theta-1)$。这与球谐函数 $Y_{20}(\\theta)$ 成正比：\n$$\n3\\cos^2\\theta - 1 = \\sqrt{\\frac{16\\pi}{5}} Y_{20}(\\theta)\n$$\n因此，四极矩可以表示为：\n$$\nQ_0^{(m)} = \\sqrt{\\frac{16\\pi}{5}} \\int \\rho(\\mathbf{r}) r^2 Y_{20}(\\theta) \\,d^3 r\n$$\n\n**1. 均匀液滴的四极矩 ($Q_{0, \\text{droplet}}^{(m)}$)**\n\n对于均匀液滴，密度 $\\rho(\\mathbf{r})$ 在由表面 $R(\\theta) = R_0 [1 + \\beta_2 Y_{20}(\\theta)]$ 定义的体积内部是一个常数 $\\rho_0$，在外部为零。球坐标系中的体积元是 $d^3r = r^2 \\sin\\theta \\,dr\\,d\\theta\\,d\\phi$。\n$$\nQ_{0, \\text{droplet}}^{(m)} = \\rho_0 \\sqrt{\\frac{16\\pi}{5}} \\int_0^{2\\pi} d\\phi \\int_0^\\pi \\sin\\theta \\, Y_{20}(\\theta) \\left( \\int_0^{R(\\theta)} r^4 \\,dr \\right) d\\theta\n$$\n对 $r$ 的积分得到 $\\frac{1}{5}[R(\\theta)]^5$。对 $\\phi$ 的积分得到 $2\\pi$。\n$$\nQ_{0, \\text{droplet}}^{(m)} = \\frac{2\\pi\\rho_0}{5} \\sqrt{\\frac{16\\pi}{5}} \\int_0^\\pi [R(\\theta)]^5 Y_{20}(\\theta) \\sin\\theta \\,d\\theta\n$$\n我们处于小形变极限（$\\beta_2 \\ll 1$），因此我们展开 $[R(\\theta)]^5$：\n$$\n[R(\\theta)]^5 = R_0^5 [1 + \\beta_2 Y_{20}(\\theta)]^5 \\approx R_0^5 [1 + 5\\beta_2 Y_{20}(\\theta) + O(\\beta_2^2)]\n$$\n将此代入积分：\n$$\nQ_{0, \\text{droplet}}^{(m)} \\approx \\frac{2\\pi\\rho_0 R_0^5}{5} \\sqrt{\\frac{16\\pi}{5}} \\int_0^\\pi [1 + 5\\beta_2 Y_{20}(\\theta)] Y_{20}(\\theta) \\sin\\theta \\,d\\theta\n$$\n积分分为两部分：\n$$\n\\int_0^\\pi Y_{20}(\\theta) \\sin\\theta \\,d\\theta + 5\\beta_2 \\int_0^\\pi [Y_{20}(\\theta)]^2 \\sin\\theta \\,d\\theta\n$$\n第一个积分为零，这是因为勒让德多项式的正交性（$P_2$ 和 $P_0$，因为 $Y_{20} \\propto P_2$ 且 $1 \\propto P_0$）。第二个积分与球谐函数的归一化有关：$\\int_0^{2\\pi}d\\phi \\int_0^\\pi [Y_{lm}(\\theta,\\phi)]^2 \\sin\\theta \\, d\\theta = 1$。由于 $Y_{20}$ 与 $\\phi$ 无关，这给出 $2\\pi \\int_0^\\pi [Y_{20}(\\theta)]^2 \\sin\\theta\\,d\\theta = 1$，因此该积分为 $1/(2\\pi)$。\n$$\nQ_{0, \\text{droplet}}^{(m)} \\approx \\frac{2\\pi\\rho_0 R_0^5}{5} \\sqrt{\\frac{16\\pi}{5}} \\left( 5\\beta_2 \\cdot \\frac{1}{2\\pi} \\right) = \\rho_0 R_0^5 \\beta_2 \\sqrt{\\frac{16\\pi}{5}} = 4\\rho_0 R_0^5 \\beta_2 \\sqrt{\\frac{\\pi}{5}}\n$$\n原子核的总质量是 $M = \\rho_0 V_0 = \\rho_0 \\frac{4\\pi}{3}R_0^3$。我们可以将 $\\rho_0$ 表示为 $\\rho_0 = \\frac{3M}{4\\pi R_0^3}$。\n$$\nQ_{0, \\text{droplet}}^{(m)} = 4 \\left( \\frac{3M}{4\\pi R_0^3} \\right) R_0^5 \\beta_2 \\sqrt{\\frac{\\pi}{5}} = \\frac{3M R_0^2}{\\pi} \\sqrt{\\frac{\\pi}{5}} \\beta_2 = \\frac{3}{\\sqrt{5\\pi}} M R_0^2 \\beta_2\n$$\n\n**2. 各向异性谐振子的四极矩 ($Q_{0, \\text{HO}}^{(m)}$)**\n\n问题指出，密度 $\\rho(\\mathbf{r})$ 是标度坐标 $u_x = \\sqrt{\\omega_{\\perp}}x$，$u_y = \\sqrt{\\omega_{\\perp}}y$，$u_z = \\sqrt{\\omega_{z}}z$ 的球对称函数。我们将其表示为 $\\rho(\\mathbf{r}) = g(u_x^2+u_y^2+u_z^2) = g(\\omega_\\perp r_\\perp^2 + \\omega_z z^2)$。\n四极矩是 $Q_{0, \\text{HO}}^{(m)} = M (2\\langle z^2 \\rangle - \\langle r_\\perp^2 \\rangle) = M(2\\langle z^2 \\rangle - 2\\langle x^2 \\rangle)$，其中 $\\langle \\cdot \\rangle$ 表示对密度分布的平均值。\n让我们计算均方值：\n$$\nM\\langle z^2 \\rangle = \\int \\rho(\\mathbf{r}) z^2 \\,d^3r \\quad \\text{和} \\quad M\\langle x^2 \\rangle = \\int \\rho(\\mathbf{r}) x^2 \\,d^3r\n$$\n我们进行变量替换，换到标度坐标 $\\mathbf{u}$。雅可比行列式是 $d^3r = (\\omega_\\perp \\sqrt{\\omega_z})^{-1} d^3u$。体积守恒条件 $\\omega_\\perp^2 \\omega_z = \\omega_0^3$（在 $\\varepsilon_2$ 的一阶上有效）给出 $\\omega_\\perp \\sqrt{\\omega_z} = \\omega_0^{3/2}$。\n$$\nM\\langle z^2 \\rangle = \\int g(u^2) \\left(\\frac{u_z^2}{\\omega_z}\\right) \\frac{d^3u}{\\omega_0^{3/2}} = \\frac{1}{\\omega_z \\omega_0^{3/2}} \\int g(u^2) u_z^2 \\,d^3u\n$$\n$$\nM\\langle x^2 \\rangle = \\int g(u^2) \\left(\\frac{u_x^2}{\\omega_\\perp}\\right) \\frac{d^3u}{\\omega_0^{3/2}} = \\frac{1}{\\omega_\\perp \\omega_0^{3/2}} \\int g(u^2) u_x^2 \\,d^3u\n$$\n由于 $g(u^2)$ 在 $\\mathbf{u}$-空间中是球对称的，积分 $\\int g(u^2) u_z^2 d^3u$ 和 $\\int g(u^2) u_x^2 d^3u$ 相等。设这个积分为 $I$。\n因此，我们有关系 $\\langle z^2 \\rangle \\propto 1/\\omega_z$ 和 $\\langle x^2 \\rangle \\propto 1/\\omega_\\perp$。\n设 $M\\langle z^2 \\rangle = C/\\omega_z$ 和 $M\\langle x^2 \\rangle = C/\\omega_\\perp$，其中 $C$ 是某个常数。\n为了求出 $C$，我们考虑球形极限（$\\varepsilon_2=0$），此时 $\\omega_z = \\omega_\\perp = \\omega_0$。\n在此极限下的均方半径为 $\\langle r^2 \\rangle_0 = \\langle x^2 \\rangle_0 + \\langle y^2 \\rangle_0 + \\langle z^2 \\rangle_0 = 3C/(M\\omega_0)$。\n问题规定，这应与均匀球体的值相匹配：$\\langle r^2 \\rangle_0 = \\frac{3}{5}R_0^2$。\n$$\n\\frac{3C}{M\\omega_0} = \\frac{3}{5}R_0^2 \\implies C = \\frac{1}{5} M\\omega_0 R_0^2\n$$\n现在我们计算形变情况下的四极矩：\n$$\nQ_{0, \\text{HO}}^{(m)} = M(2\\langle z^2 \\rangle - 2\\langle x^2 \\rangle) = 2C \\left(\\frac{1}{\\omega_z} - \\frac{1}{\\omega_\\perp}\\right)\n$$\n代入 $\\omega_z$ 和 $\\omega_\\perp$ 的关系式，并展开到 $\\varepsilon_2$ 的一阶：\n$$\n\\frac{1}{\\omega_z} = \\frac{1}{\\omega_0(1-2\\varepsilon_2/3)} \\approx \\frac{1}{\\omega_0}(1+\\frac{2\\varepsilon_2}{3})\n$$\n$$\n\\frac{1}{\\omega_\\perp} = \\frac{1}{\\omega_0(1+\\varepsilon_2/3)} \\approx \\frac{1}{\\omega_0}(1-\\frac{\\varepsilon_2}{3})\n$$\n它们的差是：\n$$\n\\frac{1}{\\omega_z} - \\frac{1}{\\omega_\\perp} \\approx \\frac{1}{\\omega_0} \\left( (1+\\frac{2\\varepsilon_2}{3}) - (1-\\frac{\\varepsilon_2}{3}) \\right) = \\frac{\\varepsilon_2}{\\omega_0}\n$$\n将此结果和常数 $C$ 代入 $Q_{0, \\text{HO}}^{(m)}$ 的表达式中：\n$$\nQ_{0, \\text{HO}}^{(m)} \\approx 2 \\left(\\frac{1}{5} M\\omega_0 R_0^2\\right) \\frac{\\varepsilon_2}{\\omega_0} = \\frac{2}{5} M R_0^2 \\varepsilon_2\n$$\n\n**3. 令四极矩相等**\n\n最后，我们令四极矩的两个表达式相等，以找到 $\\varepsilon_2$ 和 $\\beta_2$ 之间的关系：\n$$\nQ_{0, \\text{droplet}}^{(m)} = Q_{0, \\text{HO}}^{(m)}\n$$\n$$\n\\frac{3}{\\sqrt{5\\pi}} M R_0^2 \\beta_2 = \\frac{2}{5} M R_0^2 \\varepsilon_2\n$$\n因子 $M R_0^2$ 在两边消去。我们求解 $\\varepsilon_2$：\n$$\n\\varepsilon_2 = \\frac{5}{2} \\cdot \\frac{3}{\\sqrt{5\\pi}} \\beta_2 = \\frac{15}{2\\sqrt{5\\pi}} \\beta_2\n$$\n化简常数：\n$$\n\\frac{15}{2\\sqrt{5}\\sqrt{\\pi}} = \\frac{3\\cdot 5}{2\\sqrt{5}\\sqrt{\\pi}} = \\frac{3\\sqrt{5}}{2\\sqrt{\\pi}} = \\frac{3}{2}\\sqrt{\\frac{5}{\\pi}}\n$$\n因此，推导出的关系是：\n$$\n\\varepsilon_2 = \\frac{3}{2}\\sqrt{\\frac{5}{\\pi}} \\beta_2\n$$",
            "answer": "$$\n\\boxed{\\varepsilon_2 = \\frac{3}{2}\\sqrt{\\frac{5}{\\pi}} \\beta_2}\n$$"
        },
        {
            "introduction": "求解Nilsson模型的薛定谔方程通常需要对角化一个大型的哈密顿量矩阵，这在计算上是相当昂贵的。本练习将向您展示如何利用轴对称形变原子核的基本对称性，例如宇称($\\pi$)和总角动量在对称轴上的投影($\\Omega$)，来显著降低计算成本。通过量化计算速度的提升和内存的节省，您将获得关于对称性原理在计算物理中实践力量的深刻洞见。",
            "id": "3604804",
            "problem": "考虑轴对称形变核的单粒子尼尔森（Nilsson）哈密顿量，其中形变保持一个对称轴。该哈密顿量由一个形变的各向异性谐振子加上自旋-轨道项和轨道项构成。在轴对称情况下，哈密顿量 $\\hat{H}$ 与总角动量在对称轴上的投影 $\\hat{J}_z$ 以及宇称算符 $\\hat{\\Pi}$ 对易，即 $[\\hat{H},\\hat{J}_z]=0$ 和 $[\\hat{H},\\hat{\\Pi}]=0$。因此，量子数 $\\Omega$（$\\hat{J}_z$ 的本征值，以 $\\hbar$ 为单位）和 $\\pi$（$\\hat{\\Pi}$ 的本征值，等于 $+1$ 或 $-1$）是守恒的。这使得在由 $(\\Omega,\\pi)$ 标记的态基中表示的哈密顿矩阵可以被重组为独立的块，每个块对应一个 $(\\Omega,\\pi)$ 分区。瑞利-里兹（Rayleigh-Ritz）变分原理确保，只要基矢遵守守恒量子数，对角化每个块所得到的本征值与对角化完整哈密顿量得到的本征值相同。\n\n你的任务是形式化一个利用 $(\\Omega,\\pi)$ 守恒的块对角化策略，并估算计算量随基矢大小和形变数量的标度关系。使用以下基础理论：\n- 厄米性与对称性：如果对于某个算符 $\\hat{A}$ 有 $[\\hat{H},\\hat{A}]=0$，那么 $\\hat{H}$ 和 $\\hat{A}$ 共享一个共同的本征基，这意味着在按 $\\hat{A}$ 的本征值组织的 $\\hat{H}$ 表示中存在块结构。\n- 稠密厄米本征值问题的复杂度：对于一个稠密的 $n \\times n$ 厄米矩阵，广泛使用的算法进行完全对角化的计算复杂度与 $n^3$ 次浮点运算成正比，而存储该矩阵的内存使用量与 $n^2$ 成正比。\n\n为 $D$ 个不同形变（例如，由通常记为 $\\beta$ 的参数的不同值所表征的各种四极形变）的计算定义以下量：\n- 设总基矢维度为 $N$，其值通过对所有块的大小 $n_k$ 求和得到，其中每个块由一对 $(\\Omega,\\pi)$ 标识，并包含所有具有这些守恒量子数的基矢态。\n- 对角化一个稠密厄米矩阵的成本对于每个形变来说与 $N^3$ 成正比，因此不利用对称性时的总参考成本与 $D N^3$ 成正比。\n- 采用块对角化后，每个形变的成本与 $\\sum_{k} n_k^3$ 成正比，而 $D$ 个形变的总成本与 $D \\sum_{k} n_k^3$ 成正比。\n- 存储完整矩阵所需的内存与 $N^2$ 成正比，而块表示所需的内存与 $\\sum_k n_k^2$ 成正比。\n\n实现一个程序，对下面的每个测试用例，计算：\n1. 加速因子 $S$，定义为 $S = \\dfrac{D N^3}{D \\sum_k n_k^3} = \\dfrac{N^3}{\\sum_k n_k^3}$。\n2. 内存缩减因子 $M$，定义为 $M = \\dfrac{N^2}{\\sum_k n_k^2}$。\n\n你的程序应假设比例常数为1，即在计算 $S$ 和 $M$ 时，将成本和内存标度视为精确值。你的程序的输入通过下面给出的测试套件隐式提供。对于每个测试用例，你将得到一个块大小列表 $\\{n_k\\}$（每个都是正整数）和形变数量 $D$（一个正整数）。程序必须为每个测试用例计算 $S$ 和 $M$ 作为实数，并将其结果四舍五入到六位小数。\n\n测试套件：\n- 情况 $1$（在多个 $(\\Omega,\\pi)$ 分区中均衡的块）：$\\{n_k\\} = [\\,12,12,13,13,12,12,13,13\\,]$，$D=5$。此处，$N=100$。\n- 情况 $2$（未利用对称性，单个块）：$\\{n_k\\} = [\\,100\\,]$，$D=5$。此处，$N=100$。\n- 情况 $3$（$(\\Omega,\\pi)$ 分区分布极不均匀）：$\\{n_k\\} = [\\,64,16,16,8,8,8,4,4\\,]$，$D=10$。此处，$N=128$。\n- 情况 $4$（许多小块）：$\\{n_k\\} = [\\,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4\\,]$，$D=3$。此处，$N=96$。\n- 情况 $5$（仅按宇称分裂的块）：$\\{n_k\\} = [\\,60,60\\,]$，$D=4$。此处，$N=120$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含每个情况的 $(S,M)$ 对。具体来说，输出应为 $[S_1,M_1,S_2,M_2,S_3,M_3,S_4,M_4,S_5,M_5]$，其中每个 $S_i$ 和 $M_i$ 都四舍五入到六位小数。不应打印任何其他文本。",
            "solution": "该问题要求分析在轴对称形变核的单粒子尼尔森（Nilsson）哈密顿量中利用对称性所带来的计算优势。核心原理是，如果一个哈密顿算符 $\\hat{H}$ 与另一个算符 $\\hat{A}$ 对易，即 $[\\hat{H}, \\hat{A}] = 0$，那么它们共享一套共同的本征态。这使得哈密顿矩阵可以被组织成块对角形式，其中每个块对应于 $\\hat{A}$ 的一个特定本征值。\n\n在轴对称尼尔森模型的背景下，哈密顿量 $\\hat{H}$ 同时与总角动量在对称轴上的投影算符 $\\hat{J}_z$ 和宇称算符 $\\hat{\\Pi}$ 对易。这些算符的本征值，分别为 $\\Omega$ 和 $\\pi$，是守恒量子数。因此，任何基矢态都可以用一对 $(\\Omega, \\pi)$ 来标记，并且哈密顿矩阵在连接不同 $(\\Omega, \\pi)$ 对的态之间不会有任何非零矩阵元。\n\n设基矢空间的总维度为 $N$。如果我们忽略对称性，我们将构建一个大小为 $N \\times N$ 的单个大哈密顿矩阵。对角化一个大小为 $n \\times n$ 的稠密厄米矩阵的计算成本与其维度的立方成正比，即与 $n^3$ 成正比。因此，对于 $D$ 个不同的核形变，找到完整的 $N \\times N$ 矩阵的本征值和本征矢量的总计算成本将与 $D N^3$ 成正比。存储此矩阵所需的内存与其元素数量 $N^2$ 成正比。\n\n通过利用 $(\\Omega, \\pi)$ 对称性，基矢可以被划分为更小的集合，每个集合包含具有相同 $(\\Omega, \\pi)$ 值的态。假设有 $k$ 个这样的块，并且第 $k$ 个块的大小（即具有特定 $(\\Omega, \\pi)$ 组合的基矢态的数量）为 $n_k$。总基矢大小是各块大小之和：$N = \\sum_k n_k$。完整的哈密顿矩阵变为块对角形式，其块的维度为 $n_k \\times n_k$。\n\n对角化一个块对角矩阵等价于独立地对角化每个块。对于一个形变，总计算成本是每个块成本的总和：$\\sum_k n_k^3$。对于 $D$ 个形变，总成本与 $D \\sum_k n_k^3$ 成正比。类似地，所需内存是每个块内存的总和，与 $\\sum_k n_k^2$ 成正比。\n\n为了量化计算增益，我们定义了加速因子 $S$ 和内存缩减因子 $M$。按照指示假设比例常数为单位1，这些因子是没有对称性时的成本与有对称性时的成本之比。\n\n加速因子 $S$ 定义为：\n$$\nS = \\frac{\\text{Cost without symmetry}}{\\text{Cost with symmetry}} = \\frac{D N^3}{D \\sum_k n_k^3} = \\frac{N^3}{\\sum_k n_k^3}\n$$\n形变数量 $D$ 被消去，表明相对加速与计算的形变点数量无关。\n\n内存缩减因子 $M$ 定义为：\n$$\nM = \\frac{\\text{Memory without symmetry}}{\\text{Memory with symmetry}} = \\frac{N^2}{\\sum_k n_k^2}\n$$\n\n解决该问题的算法如下：对于每个测试用例，给定一个块大小列表 $\\{n_k\\}$：\n1.  通过对块大小求和来计算总基矢维度 $N$：$N = \\sum_k n_k$。\n2.  计算块大小的立方和：$\\sum_k n_k^3$。\n3.  计算块大小的平方和：$\\sum_k n_k^2$。\n4.  使用公式 $S = N^3 / (\\sum_k n_k^3)$ 计算加速因子 $S$。\n5.  使用公式 $M = N^2 / (\\sum_k n_k^2)$ 计算内存缩减因子 $M$。\n6.  按要求报告每个情况的结果，四舍五入到六位小数。\n此过程将应用于所提供的五个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes speedup and memory reduction factors for block-diagonalization\n    of a Hamiltonian matrix based on symmetry principles.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each inner list represents the sizes {n_k} of the Hamiltonian matrix blocks.\n    test_cases = [\n        # Case 1: balanced blocks across multiple (Omega,pi) sectors\n        [12, 12, 13, 13, 12, 12, 13, 13],\n        # Case 2: no symmetry exploited, single block\n        [100],\n        # Case 3: highly uneven distribution of (Omega,pi) sectors\n        [64, 16, 16, 8, 8, 8, 4, 4],\n        # Case 4: many small blocks\n        [2]*16 + [4]*16,\n        # Case 5: parity-only block split\n        [60, 60]\n    ]\n\n    results = []\n    for block_sizes in test_cases:\n        # Use numpy arrays for efficient computation.\n        # Use a floating-point dtype to prevent potential integer overflow with large N.\n        n_k = np.array(block_sizes, dtype=np.float64)\n\n        # Calculate the total basis size N.\n        N = np.sum(n_k)\n\n        # Calculate the sum of squares and cubes of block sizes.\n        sum_n_k_squared = np.sum(np.power(n_k, 2))\n        sum_n_k_cubed = np.sum(np.power(n_k, 3))\n\n        # Calculate N^2 and N^3.\n        N_squared = np.power(N, 2)\n        N_cubed = np.power(N, 3)\n\n        # Compute the speedup factor S.\n        # This is the ratio of computational cost without symmetry (N^3)\n        # to the cost with symmetry (sum of n_k^3).\n        # Check for division by zero, although not expected for this problem's constraints.\n        if sum_n_k_cubed == 0:\n            S = 1.0 if N_cubed == 0 else np.inf\n        else:\n            S = N_cubed / sum_n_k_cubed\n\n        # Compute the memory reduction factor M.\n        # This is the ratio of memory usage without symmetry (N^2)\n        # to the usage with symmetry (sum of n_k^2).\n        if sum_n_k_squared == 0:\n            M = 1.0 if N_squared == 0 else np.inf\n        else:\n            M = N_squared / sum_n_k_squared\n\n        # Append the formatted results to the list.\n        results.append(f\"{S:.6f}\")\n        results.append(f\"{M:.6f}\")\n\n    # Final print statement in the exact required format.\n    # The output is a single line containing a comma-separated list of\n    # S and M values for all test cases, enclosed in square brackets.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "Nilsson模型的一个关键输出是Nilsson图，它展示了单粒子能级如何随形变演化。本练习旨在解决一个重要挑战：如何正确追踪这些能级，尤其是在能级“避开交叉”的区域，即具有相同对称性的能级相互排斥的地方。您将实现一个稳健的算法来保持每个量子态的物理身份，这是正确解释形变核结构的一项至关重要的技能。",
            "id": "3604776",
            "problem": "给定一个与参数相关的厄米矩阵族，旨在以一种简化且计算上易于处理的方式，模拟形变核的 Nilsson 模型中单粒子态随轴向四极形变参数的演化。目标是建立并实现一个算法准则，该准则同时使用态与态之间的交叠和选定算符的期望值，以便在避免交叉处对状态进行一致性的重新标记，从而使渐近标签随形变平滑演化。该算法必须是通用的、数学上明确定义的，并且必须最大限度地减少在避免交叉附近的虚假标签交换。\n\n从以下基本基础开始：\n- 一个依赖于参数的厄米哈密顿量 $H(\\lambda)$，在每个固定的参数值 $\\lambda$ 下，都有一套完备的标准正交本征态 $\\{ \\lvert \\psi_j(\\lambda) \\rangle \\}_{j=1}^{n}$，其对应的本征值为 $\\{ E_j(\\lambda) \\}_{j=1}^{n}$。这些本征态和本征值可以通过求解矩阵本征值问题 $H(\\lambda) \\mathbf{v}_j(\\lambda) = E_j(\\lambda) \\mathbf{v}_j(\\lambda)$ 得到。\n- 两个归一化态 $\\lvert \\phi \\rangle$ 和 $\\lvert \\chi \\rangle$ 之间的内积（交叠）是 $\\langle \\phi \\mid \\chi \\rangle$，两个态之间的保真度交叠是 $\\left\\lvert \\langle \\phi \\mid \\chi \\rangle \\right\\rvert^2 \\in [0,1]$。\n- 一个厄米算符 $\\hat{O}$ 在态 $\\lvert \\psi \\rangle$ 中的期望值是 $\\langle \\psi \\rvert \\hat{O} \\lvert \\psi \\rangle$。\n- 当 $\\lambda$ 发生微小变化时，如果演化是平滑的，并且对于相同的量子数没有发生精确的能级交叉，那么由态 $\\lvert \\psi_j(\\lambda) \\rangle$ 张成的子空间应在变化的尺度上是 $\\lambda$ 的连续函数，并且变化缓慢或渐近守恒的算符的期望值应平滑变化。\n\n在下面的计算设置中，非绝热渐近基表示 Nilsson 模型的渐近态 $\\lvert \\chi_i \\rangle$（例如，渐近的 $\\lvert N n_z \\Lambda \\Sigma \\rangle$ 类基态），一个选定的对角算符 $\\hat{O}$ 通过其本征值编码一个渐近标签（例如，近似的 $\\langle n_z \\rangle$ 或 $\\langle \\Lambda \\rangle$）。\n\n您的任务：\n- 对于一个具有小增量的离散网格 $\\{ \\lambda_k \\}_{k=0}^{K-1}$，推导、论证并实现一个准则。该准则通过结合保真度交叠 $\\left\\lvert \\langle \\psi_i(\\lambda_{k-1}) \\mid \\psi_j(\\lambda_k) \\rangle \\right\\rvert^2$ 和期望值 $\\langle \\psi(\\lambda) \\rvert \\hat{O} \\lvert \\psi(\\lambda) \\rangle$ 的平滑变化，在 $\\lambda_{k-1}$ 的本征态与 $\\lambda_{k}$ 的本征态之间建立一个一对一的指派。最终的指派应重新标记状态，以使标签在避免交叉处平滑演化。问题明确要求同时使用交叠和期望值来定义一个用于指派的待最小化的代价，并以一种可普遍实现的方式表达。\n- 在给定的哈密顿量族测试套件上，实现以下两种方案：\n  1. 一种基于在每个 $\\lambda_k$ 处独立地按能量递增顺序对本征态进行排序的朴素标记方案。\n  2. 您的算法准则，该准则使用交叠和期望值，在每一步建立并解决一个最小代价指派问题，以将标签从 $\\lambda_{k-1}$ 延续到 $\\lambda_k$。\n- 对于每种方案，计算一个由下式定义的定量平滑度度量\n  $$ D \\equiv \\sum_{k=1}^{K-1} \\sum_{i=1}^{n} \\left( \\langle \\psi_i(\\lambda_k) \\rvert \\hat{O} \\lvert \\psi_i(\\lambda_k) \\rangle - \\langle \\psi_i(\\lambda_{k-1}) \\rvert \\hat{O} \\lvert \\psi_i(\\lambda_{k-1}) \\rangle \\right)^2, $$\n  其中，对于算法方案，索引 $i$ 追踪由您的指派准则传播的标签；对于朴素方案， $i$ 是在每个 $\\lambda_k$ 处按能量排序的固定索引。较小的 $D$ 值表示渐近标签的演化更平滑。\n\n哈密顿量族和算符定义：\n- 所有矩阵都在固定的非绝热基 $\\{ \\lvert \\chi_i \\rangle \\}_{i=1}^{n}$ 上定义，其形式为 $H(\\lambda) = D(\\lambda) + V(\\lambda)$，其中 $D(\\lambda)$ 是对角矩阵，对角元为 $e_i(\\lambda)$，$V(\\lambda)$ 是实对称矩阵，具有选定的非对角耦合 $v_{ij}(\\lambda)$，这些耦合被建模为局域化的高斯耦合以引发避免交叉。算符 $\\hat{O}$ 在非绝热基中是对角的，其本征值为 $o_i$。\n\n提供以下三个测试用例：\n- 测试用例 #1（两能级避免交叉）：\n  - 维度 $n = 2$。\n  - 非绝热能量 $e_1(\\lambda) = -a\\,\\lambda$, $e_2(\\lambda) = +a\\,\\lambda$，其中 $a = 1.0$。\n  - 耦合 $v_{12}(\\lambda) = v_0 \\exp\\!\\left( - (\\lambda - \\lambda_0)^2 / (2 \\sigma^2) \\right)$，其中 $v_0 = 0.15$, $\\lambda_0 = 0.0$, $\\sigma = 0.2$；并且 $v_{21}(\\lambda) = v_{12}(\\lambda)$。\n  - 所有其他 $v_{ij}(\\lambda) = 0$。\n  - 算符 $\\hat{O}$ 具有 $o_1 = 0.0$, $o_2 = 1.0$。\n  - 网格 $\\lambda \\in [-2.0, 2.0]$，以步长 $\\Delta \\lambda = 0.05$ 均匀采样。\n- 测试用例 #2（三能级、两个分离的避免交叉）：\n  - 维度 $n = 3$。\n  - 非绝热能量 $e_1(\\lambda) = -1.0 + 0.5\\,\\lambda$, $e_2(\\lambda) = 0.0$, $e_3(\\lambda) = +1.0 - 0.5\\,\\lambda$。\n  - 耦合：\n    - $v_{12}(\\lambda) = v_{0,12} \\exp\\!\\left( - (\\lambda - \\lambda_{12})^2 / (2 \\sigma_{12}^2) \\right)$，其中 $v_{0,12} = 0.12$, $\\lambda_{12} = -0.5$, $\\sigma_{12} = 0.15$。\n    - $v_{23}(\\lambda) = v_{0,23} \\exp\\!\\left( - (\\lambda - \\lambda_{23})^2 / (2 \\sigma_{23}^2) \\right)$，其中 $v_{0,23} = 0.12$, $\\lambda_{23} = +0.5$, $\\sigma_{23} = 0.15$。\n    - $v_{13}(\\lambda) = v_{31}(\\lambda) = 0.0$。\n    - 对称性 $v_{ij}(\\lambda) = v_{ji}(\\lambda)$ 成立。\n  - 算符 $\\hat{O}$ 具有 $o_1 = 0.0$, $o_2 = 1.0$, $o_3 = 2.0$。\n  - 网格 $\\lambda \\in [-1.5, 1.5]$，以步长 $\\Delta \\lambda = 0.05$ 均匀采样。\n- 测试用例 #3（三能级精确交叉）：\n  - 维度 $n = 3$。\n  - 非绝热能量 $e_1(\\lambda) = -0.3\\,\\lambda$, $e_2(\\lambda) = +0.3\\,\\lambda$, $e_3(\\lambda) = 1.2$。\n  - 对于所有 $i \\neq j$，所有耦合 $v_{ij}(\\lambda) = 0.0$。\n  - 算符 $\\hat{O}$ 具有 $o_1 = 0.0$, $o_2 = 1.0$, $o_3 = 2.0$。\n  - 网格 $\\lambda \\in [-1.0, 1.0]$，以步长 $\\Delta \\lambda = 0.05$ 均匀采样。\n\n实现和输出要求：\n- 在每个网格点实现 $H(\\lambda)$ 的对角化，以获得所有 $k$ 的本征对 $\\{ E_j(\\lambda_k), \\lvert \\psi_j(\\lambda_k) \\rangle \\}$。\n- 实现按能量排序的朴素标记方案，并按规定计算 $D_{\\text{naive}}$。\n- 使用交叠和期望值推导您的算法准则，实现它以生成在 $\\lambda_{k-1}$ 和 $\\lambda_k$ 之间使合适的总代价最小化的分步状态指派，并按规定计算 $D_{\\text{algo}}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，具有以下嵌套列表结构：\n  - 对于测试用例 #1、#2、#3，按顺序输出配对 $\\left[D_{\\text{naive}}, D_{\\text{algo}}\\right]$。\n  - 将它们聚合为 $\\left[ [D_{\\text{naive}}^{(1)}, D_{\\text{algo}}^{(1)}], [D_{\\text{naive}}^{(2)}, D_{\\text{algo}}^{(2)}], [D_{\\text{naive}}^{(3)}, D_{\\text{algo}}^{(3)}] \\right]$。\n- 所有量都是无量纲的；不需要物理单位。不使用角度。为保证可复现性，最终打印的数字应四舍五入到 $10^{-6}$ 的精度。",
            "solution": "该问题陈述已经过严谨验证，并被确定为有效的。它在科学上植根于量子力学原理，特别是对参数依赖系统中的避免交叉的研究，这是分子物理与核物理的基石。该问题是适定的，所有参数、模型和目标都得到了清晰明确的定义。它提出了计算物理学中一个标准的、非平凡的挑战：开发和实现一个鲁棒的状态追踪算法。\n\n问题的核心是设计一种方法，在系统参数 $\\lambda$ 变化时对量子态进行一致的标记。在避免交叉附近，哈密顿量 $H(\\lambda)$ 的本征态的特性会发生迅速变化。一个朴素的标记方案，即在每个 $\\lambda$ 值处按能量 $E_j(\\lambda)$ 对状态进行排序，将导致标签在状态之间交换。这会导致与给定标签相关的物理可观测量发生不连续的演化，从而掩盖了状态潜在的平滑或“非绝热”性质。\n\n任务是实现并比较两种标记方案。第一种是朴素的能量排序方案。第二种是一种复杂的算法方案，它通过最小化一个既考虑态矢量几何交叠又考虑所选可观测量期望值平滑演化的代价函数来追踪状态的同一性。每种方案的性能由一个平滑度度量 $D$ 来量化。\n\n首先，我们形式化计算设置。哈密顿量 $H(\\lambda)$ 和一个算符 $\\hat{O}$ 在一个固定的、不随时间变化的“非绝热”基 $\\{ \\lvert \\chi_i \\rangle \\}_{i=1}^n$ 中表示为 $n \\times n$ 矩阵。在网格上的每个离散点 $\\lambda_k$，我们求解不含时薛定谔方程，其形式为矩阵本征值问题：\n$$\nH(\\lambda_k) \\lvert \\psi_j(\\lambda_k) \\rangle = E_j(\\lambda_k) \\lvert \\psi_j(\\lambda_k) \\rangle\n$$\n这在计算上通过对角化 $H(\\lambda_k)$ 的矩阵表示来解决。求解得到一组 $n$ 个本征值 $\\{E_j(\\lambda_k)\\}$ 和一套相应的标准正交本征矢 $\\{\\lvert \\psi_j(\\lambda_k) \\rangle\\}$。算符 $\\hat{O}$ 在非绝热基中是对角的，本征值为 $\\{o_i\\}$。一个本征矢 $\\lvert \\psi_j \\rangle$ 是非绝热基态的线性组合，$\\lvert \\psi_j \\rangle = \\sum_i c_{ji} \\lvert \\chi_i \\rangle$。它对 $\\hat{O}$ 的期望值为 $\\langle \\psi_j \\rvert \\hat{O} \\lvert \\psi_j \\rangle = \\sum_i \\lvert c_{ji} \\rvert^2 o_i$。\n\n朴素标记方案很简单。在每个 $\\lambda_k$ 处，本征态按其能量本征值 $E_j(\\lambda_k)$ 的升序进行索引 $j=1, \\dots, n$。然后，平滑度度量 $D_{\\text{naive}}$ 计算如下：\n$$\nD_{\\text{naive}} = \\sum_{k=1}^{K-1} \\sum_{i=1}^{n} \\left( \\langle \\psi_i^{\\text{naive}}(\\lambda_k) \\rvert \\hat{O} \\lvert \\psi_i^{\\text{naive}}(\\lambda_k) \\rangle - \\langle \\psi_i^{\\text{naive}}(\\lambda_{k-1}) \\rvert \\hat{O} \\lvert \\psi_i^{\\text{naive}}(\\lambda_{k-1}) \\rangle \\right)^2\n$$\n其中 $\\lvert \\psi_i^{\\text{naive}}(\\lambda_k) \\rangle$ 是在 $\\lambda_k$ 处按能量排序列表中的第 $i$ 个状态。对于具有避免交叉的系统，该度量预计会很大，因为第 $i$ 个能量本征态的特性会突然改变。\n\n为了开发更鲁棒的算法方案，我们建立一个准则，用于将从步骤 $\\lambda_{k-1}$ 标记的状态连接到在 $\\lambda_k$ 处新计算的、初始未标记的本征态。基本原理是，对于足够小的步长 $\\Delta \\lambda = \\lambda_k - \\lambda_{k-1}$，一个物理状态应该演化成一个在希尔伯特空间中与其“接近”且其性质变化最小的状态。这提示了一种代价最小化的方法。设 $\\{\\lvert \\psi_i^{\\text{old}} \\rangle\\}_{i=1}^n$ 是来自步骤 $\\lambda_{k-1}$ 的已标记状态集合，设 $\\{\\lvert \\phi_j^{\\text{new}} \\rangle\\}_{j=1}^n$ 是在 $\\lambda_k$ 处新的、按能量排序的本征态集合。我们寻求一个一对一的指派（一个置换）$i \\to j=\\pi(i)$ 来最小化总代价。\n\n必须制定将旧标签 $i$ 指派给新状态 $j$ 的代价 $C_{ij}$。问题要求结合两个独立的准则：\n1.  保真度交叠：两个状态之间的相似性由保真度 $F_{ij} = \\left\\lvert \\langle \\psi_i^{\\text{old}} \\mid \\phi_j^{\\text{new}} \\rangle \\right\\rvert^2$ 来衡量。可以将代价定义为 $1 - F_{ij}$，当状态几乎相同时该代价很小，当它们几乎正交时该代价很大。\n2.  期望值平滑度：代表近似量子数的算符 $\\hat{O}$ 的期望值应该平滑演化。平方差 $(\\langle \\phi_j^{\\text{new}} \\rvert \\hat{O} \\lvert \\phi_j^{\\text{new}} \\rangle - \\langle \\psi_i^{\\text{old}} \\rvert \\hat{O} \\lvert \\psi_i^{\\text{old}} \\rangle)^2$ 惩罚那些导致该量发生大跳跃的指派。\n\n为了将这些项组合成一个单一的、平衡的、无量纲的代价，我们使用加权和。期望值项通过期望值的最大可能范围 $\\Delta O_{\\text{max}} = \\max(o_l) - \\min(o_l)$ 进行归一化，以确保其与保真度项的量级相当。得到的代价矩阵元素 $C_{ij}$ 为：\n$$\nC_{ij} = w \\left(1 - \\left\\lvert \\langle \\psi_i^{\\text{old}} \\mid \\phi_j^{\\text{new}} \\rangle \\right\\rvert^2\\right) + (1-w) \\left( \\frac{\\langle \\phi_j^{\\text{new}} \\rvert \\hat{O} \\lvert \\phi_j^{\\text{new}} \\rangle - \\langle \\psi_i^{\\text{old}} \\rvert \\hat{O} \\lvert \\psi_i^{\\text{old}} \\rangle}{\\Delta O_{\\text{max}}} \\right)^2\n$$\n权重因子 $w=0.5$ 是一个平衡的选择，给予两个准则同等的重要性。寻找标签最佳指派的问题就变成了寻找最小化总代价 $\\sum_{i=1}^n C_{i, \\pi(i)}$ 的置换 $\\pi$。这是著名的线性总和指派问题，可以使用标准算法（如匈牙利算法）高效解决。\n\n算法流程如下：\n1. 在 $\\lambda_0$ 处，对角化 $H(\\lambda_0)$ 并根据能量顺序为本征态分配初始标签。设此集合为 $\\{\\lvert \\psi_i(\\lambda_0) \\rangle\\}$。\n2. 对于随后的每一步 $k = 1, \\dots, K-1$：\n    a. 设 $\\{\\lvert \\psi_i(\\lambda_{k-1}) \\rangle\\}$ 是上一步的已标记状态。\n    b. 对角化 $H(\\lambda_k)$ 以获得一组新的按能量排序的本征态 $\\{\\lvert \\phi_j(\\lambda_k) \\rangle\\}$。\n    c. 构建 $n \\times n$ 的代价矩阵 $C$，其元素 $C_{ij}$ 如上定义。\n    d. 在 $C$ 上解决线性总和指派问题，以找到将旧标签 $i$ 映射到新索引 $j$ 的最优置换 $\\pi$。\n    e. 新标记的状态为 $\\{\\lvert \\psi_i(\\lambda_k) \\rangle = \\lvert \\phi_{\\pi(i)}(\\lambda_k) \\rangle\\}$。存储它们的属性。\n3. 所有步骤完成后，使用追踪的期望值计算平滑度度量 $D_{\\text{algo}}$。\n\n该算法方案旨在追踪状态的非绝热特性，防止在避免交叉处的标签交换，因此与朴素方案相比，会产生一个更小的平滑度度量 $D$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef run_test_case(n, e_funcs, v_funcs, o_diag, lambda_range, d_lambda):\n    \"\"\"\n    Runs a single test case for state tracking.\n\n    Args:\n        n (int): Dimension of the Hilbert space.\n        e_funcs (list): List of lambda functions for diagonal energies e_i(lambda).\n        v_funcs (dict): Dictionary of lambda functions for off-diagonal couplings v_ij(lambda).\n        o_diag (list): List of diagonal elements of the operator O.\n        lambda_range (tuple): Start and end of the lambda grid.\n        d_lambda (float): Step size for the lambda grid.\n\n    Returns:\n        tuple: A pair of floats (D_naive, D_algo).\n    \"\"\"\n    lambdas = np.arange(lambda_range[0], lambda_range[1] + d_lambda / 2.0, d_lambda)\n    K = len(lambdas)\n    O_diag_np = np.array(o_diag)\n\n    # Pre-calculate all energy-sorted eigenpairs\n    evals_sorted = np.zeros((K, n))\n    evecs_sorted = np.zeros((K, n, n), dtype=np.float64)\n\n    for k, lmbda in enumerate(lambdas):\n        H = np.zeros((n, n), dtype=np.float64)\n        for i in range(n):\n            H[i, i] = e_funcs[i](lmbda)\n        for (i, j), func in v_funcs.items():\n            val = func(lmbda)\n            H[i, j] = val\n            H[j, i] = val\n        \n        evals, evecs = np.linalg.eigh(H)\n        evals_sorted[k, :] = evals\n        evecs_sorted[k, :, :] = evecs\n\n    # Expectation values of O for energy-sorted states\n    exp_vals_sorted = np.sum(evecs_sorted**2 * O_diag_np[np.newaxis, :, np.newaxis], axis=1)\n\n    # 1. Naive Labeling Scheme\n    diff_sq_naive = (exp_vals_sorted[1:, :] - exp_vals_sorted[:-1, :])**2\n    D_naive = np.sum(diff_sq_naive)\n\n    # 2. Algorithmic Labeling Scheme\n    labeled_evecs = np.zeros_like(evecs_sorted)\n    labeled_exp_vals = np.zeros_like(exp_vals_sorted)\n\n    labeled_evecs[0, :, :] = evecs_sorted[0, :, :]\n    labeled_exp_vals[0, :] = exp_vals_sorted[0, :]\n\n    delta_O_max = np.max(O_diag_np) - np.min(O_diag_np)\n    if delta_O_max  1e-9:\n        delta_O_max = 1.0\n    \n    w = 0.5  # Weighting factor for the cost function\n\n    for k in range(1, K):\n        old_vecs = labeled_evecs[k - 1, :, :]\n        old_exp_vals = labeled_exp_vals[k - 1, :]\n        \n        new_vecs_sorted_k = evecs_sorted[k, :, :]\n        new_exp_vals_sorted_k = exp_vals_sorted[k, :]\n        \n        # Build cost matrix: old states are rows (i), new states are columns (j)\n        overlaps_sq = np.abs(old_vecs.T.conj() @ new_vecs_sorted_k)**2\n        cost_overlap = 1.0 - overlaps_sq\n        \n        exp_val_diff = new_exp_vals_sorted_k[np.newaxis, :] - old_exp_vals[:, np.newaxis]\n        cost_exp = (exp_val_diff / delta_O_max)**2\n\n        cost_matrix = w * cost_overlap + (1 - w) * cost_exp\n\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        labeled_evecs[k, :, :] = new_vecs_sorted_k[:, col_ind]\n        labeled_exp_vals[k, :] = new_exp_vals_sorted_k[col_ind]\n\n    diff_sq_algo = (labeled_exp_vals[1:, :] - labeled_exp_vals[:-1, :])**2\n    D_algo = np.sum(diff_sq_algo)\n    \n    return D_naive, D_algo\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    results_list = []\n\n    # Test Case #1\n    case1_params = {\n        \"n\": 2,\n        \"e_funcs\": [lambda l: -1.0 * l, lambda l: 1.0 * l],\n        \"v_funcs\": {(0, 1): lambda l: 0.15 * np.exp(-(l - 0.0)**2 / (2 * 0.2**2))},\n        \"o_diag\": [0.0, 1.0],\n        \"lambda_range\": (-2.0, 2.0),\n        \"d_lambda\": 0.05\n    }\n    D_naive1, D_algo1 = run_test_case(**case1_params)\n    results_list.append([round(D_naive1, 6), round(D_algo1, 6)])\n\n    # Test Case #2\n    case2_params = {\n        \"n\": 3,\n        \"e_funcs\": [lambda l: -1.0 + 0.5 * l, lambda l: 0.0, lambda l: 1.0 - 0.5 * l],\n        \"v_funcs\": {\n            (0, 1): lambda l: 0.12 * np.exp(-(l - (-0.5))**2 / (2 * 0.15**2)),\n            (1, 2): lambda l: 0.12 * np.exp(-(l - 0.5)**2 / (2 * 0.15**2)),\n        },\n        \"o_diag\": [0.0, 1.0, 2.0],\n        \"lambda_range\": (-1.5, 1.5),\n        \"d_lambda\": 0.05\n    }\n    D_naive2, D_algo2 = run_test_case(**case2_params)\n    results_list.append([round(D_naive2, 6), round(D_algo2, 6)])\n\n    # Test Case #3\n    case3_params = {\n        \"n\": 3,\n        \"e_funcs\": [lambda l: -0.3 * l, lambda l: 0.3 * l, lambda l: 1.2],\n        \"v_funcs\": {},\n        \"o_diag\": [0.0, 1.0, 2.0],\n        \"lambda_range\": (-1.0, 1.0),\n        \"d_lambda\": 0.05\n    }\n    D_naive3, D_algo3 = run_test_case(**case3_params)\n    results_list.append([round(D_naive3, 6), round(D_algo3, 6)])\n    \n    print(str(results_list).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}