{
    "hands_on_practices": [
        {
            "introduction": "Our exploration of the BCS gap equation begins with a foundational exercise in a simplified, yet powerful, model system. In this practice , we move away from the continuum of momentum space to a discrete set of single-particle energy levels. This \"picket-fence\" model allows us to focus directly on the heart of the BCS problem: the coupled, non-linear equations for the chemical potential $\\mu$ and the pairing gap $\\Delta$ that must be solved self-consistently to conserve particle number and establish the pairing correlation.",
            "id": "3594622",
            "problem": "You are given an even-even fermionic system at zero temperature modeled by a reduced pairing Hamiltonian with constant pairing strength $G$ acting within an energy window around a reference energy. The single-particle spectrum is discrete, equally spaced, and symmetric about the reference energy, with energies $ \\epsilon_n = n \\delta $ for integer $n$ satisfying $ |\\epsilon_n| \\leq E_c $, where $ \\delta $ is the level spacing and $ E_c $ is the pairing window cutoff. Each level carries a time-reversed (two-fold) degeneracy. The task is to determine the chemical potential $ \\mu $ and the pairing gap $ \\Delta $ that self-consistently describe the system in the zero-temperature mean-field approximation while conserving the specified total particle number $ N $ in the grand-canonical ensemble.\n\nStarting from the reduced pairing model and the zero-temperature mean-field framework for paired fermions, derive the necessary self-consistent conditions that determine the quasiparticle spectrum and occupation amplitudes. From these conditions, formulate the coupled nonlinear equations that determine $ \\mu $ and $ \\Delta $. Your derivation must ensure that the solution respects the constraint on the average particle number $ N $ for an even-even system.\n\nThen, implement a numerical solver for the coupled nonlinear equations for $ \\mu $ and $ \\Delta $ for a set of specified parameter values. You must ensure that the numerical method enforces $ \\Delta  0 $, handles discrete sums over the pairing window $ |\\epsilon_n| \\leq E_c $, and produces a solution even when the non-interacting Fermi level lies close to one of the discrete levels. Provide a robust initial guess and a fallback strategy if needed to ensure convergence.\n\nAll energies must be expressed in mega-electronvolts (MeV). The output values of $ \\mu $ and $ \\Delta $ must be reported in MeV, each rounded to six decimal places.\n\nUse the following test suite of parameter sets $ (\\delta, E_c, G, N) $ in MeV and particle count:\n- Test case 1 (general case): $ \\delta = 0.2 $, $ E_c = 5.0 $, $ G = 0.4 $, $ N = 40 $.\n- Test case 2 (near-empty filling): $ \\delta = 0.5 $, $ E_c = 4.0 $, $ G = 0.6 $, $ N = 2 $.\n- Test case 3 (high filling): $ \\delta = 0.1 $, $ E_c = 3.0 $, $ G = 0.25 $, $ N = 80 $.\n- Test case 4 (small model space, near full): $ \\delta = 0.5 $, $ E_c = 1.0 $, $ G = 0.8 $, $ N = 8 $.\n- Test case 5 (weak pairing): $ \\delta = 0.3 $, $ E_c = 3.0 $, $ G = 0.15 $, $ N = 20 $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list $ [\\mu, \\Delta] $ with both entries rounded to six decimal places in MeV. For example: $ [[\\mu_1,\\Delta_1],[\\mu_2,\\Delta_2],\\dots] $.\n\nNote: All trigonometric or angular quantities, if any arise in your derivation or numerical method, must be handled in radians. The final numerical answers must be provided as floats in MeV with the specified rounding, and no units or additional text should appear in the output line other than the list structure.",
            "solution": "### Step 1: Theoretical Derivation of the BCS Equations\n\nThe system is described by a reduced pairing Hamiltonian within a specified model space. We work in the grand-canonical ensemble, introducing the chemical potential $\\mu$ to fix the average particle number $N$. The Hamiltonian is $K = H - \\mu N$.\n\nThe pairing Hamiltonian is given by:\n$$\nH = \\sum_{n, \\sigma} \\epsilon_n a_{n\\sigma}^\\dagger a_{n\\sigma} - G \\sum_{n, n'} a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}'\\downarrow} a_{n' \\uparrow}\n$$\nwhere $a_{n\\sigma}^\\dagger$ creates a fermion in state $n$ with spin projection $\\sigma$. In the context of nuclei, these represent time-reversed states. Each level $n$ has energy $\\epsilon_n$ and a two-fold degeneracy corresponding to the state $|n\\rangle$ and its time-reversed partner $|\\bar{n}\\rangle$. $G$ is the constant pairing strength.\n\nIn the BCS mean-field approximation, the four-fermion interaction term is linearized. We define the pairing gap parameter $\\Delta$ as:\n$$\n\\Delta = G \\sum_{n'} \\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle\n$$\nThe expectation value is taken with respect to the BCS ground state. By choosing a suitable phase, $\\Delta$ can be taken as a real, positive quantity, $\\Delta  0$. The mean-field grand-canonical Hamiltonian $K_{MF} = H_{MF} - \\mu N$ becomes:\n$$\nK_{MF} = \\sum_{n} (\\epsilon_n - \\mu) (a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow}) - \\sum_n \\left( \\Delta a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger + \\Delta a_{\\bar{n}\\downarrow} a_{n\\uparrow} \\right) + \\frac{\\Delta^2}{G}\n$$\nThis Hamiltonian is quadratic in fermion operators and can be diagonalized using the Bogoliubov transformation, which introduces quasiparticle operators $\\alpha$:\n$$\n\\alpha_{n\\uparrow} = u_n a_{n\\uparrow} - v_n a_{\\bar{n}\\downarrow}^\\dagger\n$$\n$$\n\\alpha_{\\bar{n}\\downarrow} = u_n a_{\\bar{n}\\downarrow} + v_n a_{n\\uparrow}^\\dagger\n$$\nThe coefficients $u_n$ and $v_n$ are real and satisfy the normalization condition $u_n^2 + v_n^2 = 1$. This transformation is canonical and diagonalizes $K_{MF}$ into the form:\n$$\nK_{MF} = E_0 + \\sum_n E_n (\\alpha_{n\\uparrow}^\\dagger \\alpha_{n\\uparrow} + \\alpha_{\\bar{n}\\downarrow}^\\dagger \\alpha_{\\bar{n}\\downarrow})\n$$\nwhere $E_0$ is the ground-state energy and $E_n$ is the quasiparticle energy for level $n$:\n$$\nE_n = \\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}\n$$\nThe BCS ground state $|\\Psi_{BCS}\\rangle$ is the vacuum of these quasiparticles, i.e., $\\alpha_{n\\sigma} |\\Psi_{BCS}\\rangle = 0$ for all $n, \\sigma$. The coefficients $u_n$ and $v_n$ are determined by the diagonalization procedure:\n$$\nu_n^2 = \\frac{1}{2} \\left( 1 + \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\n$$\nv_n^2 = \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\nThe coefficient $v_n^2$ represents the probability of the pair state $(n\\uparrow, \\bar{n}\\downarrow)$ being occupied in the ground state, while $u_n^2 = 1 - v_n^2$ is the probability of it being empty.\n\nTwo self-consistent equations are derived from this framework.\n\n**1. The Number Conservation Equation:**\nThe average number of particles $N$ in the ground state is fixed. Each level $n$ can hold two particles (a time-reversed pair). The total particle number is the sum of the occupation probabilities over all levels:\n$$\nN = \\sum_n \\langle a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow} \\rangle = \\sum_n (v_n^2 + v_n^2) = \\sum_n 2 v_n^2\n$$\nSubstituting the expression for $v_n^2$:\n$$\nN = \\sum_n 2 \\cdot \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right) = \\sum_n \\left( 1 - \\frac{\\epsilon_n - \\mu}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}} \\right)\n$$\nThis is the first equation, which relates $\\mu$ and $\\Delta$ to the total particle number $N$.\n\n**2. The Gap Equation:**\nThe second equation comes from the self-consistent definition of $\\Delta$. The expectation value $\\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle$ can be calculated in the quasiparticle vacuum, yielding $u_{n'}v_{n'}$.\n$$\n\\Delta = G \\sum_{n'} u_{n'}v_{n'}\n$$\nWe can express $u_n v_n$ as:\n$$\nu_n v_n = \\sqrt{u_n^2 v_n^2} = \\sqrt{\\frac{1}{4} \\left( 1 - \\left(\\frac{\\epsilon_n - \\mu}{E_n}\\right)^2 \\right)} = \\sqrt{\\frac{1}{4} \\frac{E_n^2 - (\\epsilon_n - \\mu)^2}{E_n^2}} = \\sqrt{\\frac{\\Delta^2}{4E_n^2}} = \\frac{\\Delta}{2E_n}\n$$\nwhere we have used $\\Delta  0$. Substituting this back into the definition of $\\Delta$:\n$$\n\\Delta = G \\sum_n \\frac{\\Delta}{2E_n}\n$$\nFor a non-trivial pairing solution ($\\Delta  0$), we can divide by $\\Delta$ to obtain the gap equation:\n$$\n1 = \\frac{G}{2} \\sum_n \\frac{1}{E_n} \\implies \\frac{2}{G} = \\sum_n \\frac{1}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}}\n$$\nThis is the second self-consistent equation.\n\nThe summations $\\sum_n$ are over the discrete set of single-particle levels within the pairing window. The levels are given by $\\epsilon_n = n \\delta$ for integer $n$ satisfying $|n\\delta| \\leq E_c$. This implies $n$ ranges from $n_{min} = -\\lfloor E_c/\\delta \\rfloor$ to $n_{max} = \\lfloor E_c/\\delta \\rfloor$.\n\n### Step 2: Numerical Implementation\n\nThe task is to solve the following coupled system of nonlinear equations for the variables $(\\mu, \\Delta)$:\n$$\nf_1(\\mu, \\Delta) = N - \\sum_{n=n_{min}}^{n_{max}} \\left( 1 - \\frac{n\\delta - \\mu}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} \\right) = 0\n$$\n$$\nf_2(\\mu, \\Delta) = \\frac{2}{G} - \\sum_{n=n_{min}}^{n_{max}} \\frac{1}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} = 0\n$$\nThis system will be solved using a numerical root-finding algorithm, specifically `scipy.optimize.root`.\n\n**Algorithm Design:**\n1.  **Model Space Definition**: For a given set of parameters $(\\delta, E_c, G, N)$, first determine the range of single-particle levels. The maximum integer index is $n_{max} = \\lfloor E_c/\\delta \\rfloor$. The set of levels is an array of energies $\\epsilon_n = n\\delta$ for $n \\in \\{-n_{max}, -n_{max}+1, \\dots, n_{max}\\}$.\n\n2.  **Equation System**: A Python function is defined that takes a vector `[mu, delta]` and returns the values `[f1(mu, delta), f2(mu, delta)]`. The sums are computed over the pre-calculated array of level energies. Note that the equations depend on $\\Delta^2$. Consequently, if $(\\mu, \\Delta)$ is a solution, so is $(\\mu, -\\Delta)$. The physical pairing gap is positive by convention, so we take the absolute value of the $\\Delta$ found by the solver.\n\n3.  **Initial Guess**: A good initial guess is crucial for the convergence and stability of the root-finding algorithm.\n    *   **For $\\mu$**: The chemical potential $\\mu$ in the paired system is typically close to the Fermi level $\\epsilon_F$ of the non-interacting system. For the given symmetric spectrum, we fill the lowest $N/2$ levels. The last occupied level has index $n_{occ} = N/2 - n_{max} - 1$ and the first unoccupied has index $n_{unocc} = N/2 - n_{max}$. The initial guess $\\mu_0$ is set to the midpoint: $\\mu_0 = (\\epsilon_{n_{occ}} + \\epsilon_{n_{unocc}})/2 = (N/2 - n_{max} - 0.5)\\delta$. This avoids placing $\\mu_0$ exactly on a level, improving robustness.\n    *   **For $\\Delta$**: The pairing strength $G$ itself provides a reasonable order-of-magnitude estimate for the gap $\\Delta$. Thus, we choose an initial guess $\\Delta_0 = G$.\n\n4.  **Solver Execution**: We employ the `scipy.optimize.root` function with the `hybr` method, a well-established and robust algorithm for systems of nonlinear equations. The solver is called with the equation function and the initial guess `[mu_0, delta_0]`. If the primary guess fails to converge, a fallback is implemented by trying a smaller initial guess for the gap, such as $\\Delta_0 = 0.1 G$, to handle cases of weaker pairing.\n\n5.  **Output Formatting**: The final solution vector `[mu, delta]` is extracted. The absolute value of `delta` is taken, and both values are rounded to six decimal places as required. This process is repeated for each test case, and the results are aggregated into the specified list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the BCS equations for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (delta, Ec, G, N) in MeV and particle count.\n    test_cases = [\n        (0.2, 5.0, 0.4, 40),   # Test case 1 (general case)\n        (0.5, 4.0, 0.6, 2),    # Test case 2 (near-empty filling)\n        (0.1, 3.0, 0.25, 80),  # Test case 3 (high filling)\n        (0.5, 1.0, 0.8, 8),    # Test case 4 (small model space, near full)\n        (0.3, 3.0, 0.15, 20),  # Test case 5 (weak pairing)\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_sol, delta_sol = solve_bcs(*case)\n        results.append([round(mu_sol, 6), round(delta_sol, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_bcs(delta_e, Ec, G, N):\n    \"\"\"\n    Solves the coupled BCS equations for mu and delta for a single parameter set.\n\n    Args:\n        delta_e (float): Single-particle level spacing in MeV.\n        Ec (float): Pairing window cutoff energy in MeV.\n        G (float): Pairing strength in MeV.\n        N (int): Total even number of particles.\n\n    Returns:\n        tuple[float, float]: The solved chemical potential (mu) and pairing gap (delta).\n    \"\"\"\n\n    # 1. Define the model space\n    n_max = int(np.floor(Ec / delta_e))\n    eps_levels = np.arange(-n_max, n_max + 1) * delta_e\n\n    # 2. Define the system of equations for the root finder\n    def bcs_equations(variables):\n        mu, delta_gap = variables\n        \n        # Use delta_gap^2 in equations to handle potential negative values during iteration.\n        delta_gap_sq = delta_gap**2\n        \n        # Add a small epsilon to the denominator to prevent any potential sqrt(0) issues,\n        # though with floating point arithmetic it's highly unlikely.\n        quasiparticle_energies = np.sqrt((eps_levels - mu)**2 + delta_gap_sq)\n\n        # Equation 1: Number conservation\n        # N = sum_{n} (1 - (eps_n - mu) / E_n)\n        # We compute the residual: f1 = N - sum(...)\n        eq1 = N - np.sum(1.0 - (eps_levels - mu) / quasiparticle_energies)\n\n        # Equation 2: Gap equation\n        # 2/G = sum_{n} 1 / E_n\n        # We compute the residual: f2 = 2/G - sum(...)\n        # For G=0 this would be a problem, but G0 in all test cases.\n        eq2 = 2.0 / G - np.sum(1.0 / quasiparticle_energies)\n\n        return [eq1, eq2]\n\n    # 3. Determine a robust initial guess\n    # For mu: non-interacting Fermi level, placed between the last occupied\n    # and first unoccupied levels.\n    mu_0 = (N / 2.0 - n_max - 0.5) * delta_e\n    \n    # For delta: The pairing strength G is a reasonable order-of-magnitude estimate.\n    delta_0 = G\n\n    # 4. Call the solver\n    solution = root(bcs_equations, [mu_0, delta_0], method='hybr', tol=1e-9)\n    \n    # Optional: Implement fallback strategy as mentioned in the problem description.\n    # If the first attempt fails, try a smaller initial delta.\n    if not solution.success:\n        solution = root(bcs_equations, [mu_0, 0.1 * G], method='hybr', tol=1e-9)\n        # If it still fails, the problem might be ill-conditioned. For this problem set,\n        # we assume one of these initial guesses will lead to convergence.\n        if not solution.success:\n            # This indicates a failure to converge, return NaNs or raise an error.\n            # In this contest, the problem is well-posed, so this path is not expected.\n            return (np.nan, np.nan)\n\n    mu_sol, delta_sol = solution.x\n    \n    # 5. Finalize the result\n    # The physical pairing gap Delta is positive. Since the equations depend on Delta^2,\n    # the solver might converge to a negative value. We take the absolute value.\n    delta_sol = abs(delta_sol)\n    \n    # Handle the trivial solution case for weak pairing\n    # if the gap equation cannot be satisfied for any Delta  0.\n    # This can be checked by evaluating the gap equation at Delta=0.\n    # If 2/G  sum(1/|eps-mu|), then Delta=0 is the only solution.\n    # However, the problem formulation implies a paired solution (Delta0) exists.\n    # The numerical value of delta_sol will be very close to zero in this case.\n\n    return mu_sol, delta_sol\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Having mastered the basic mechanics of the BCS equations, we now confront a deeper issue central to modern physics: renormalization. In this practice , you will work with a contact interaction in the momentum-space continuum, which introduces an ultraviolet divergence that must be regularized with a momentum cutoff $\\Lambda$. The exercise guides you through the process of renormalization, where the unphysical \"bare\" coupling constant $g$ is systematically adjusted with the cutoff to keep a low-energy physical observable—the scattering length $a_s$—fixed. By doing so, you will verify a profound principle: the predicted pairing gap $\\Delta$, a many-body observable, becomes independent of the arbitrary cutoff scale, demonstrating how to extract physical predictions from a regularized theory.",
            "id": "3594665",
            "problem": "You are asked to implement and verify the renormalization of a three-dimensional zero-range (contact) interaction in the zero-temperature Bardeen–Cooper–Schrieffer (BCS) theory for a homogeneous Fermi system, using a momentum cutoff. Work exclusively in natural units where $\\hbar = 1$ and $2m = 1$, which implies $\\varepsilon_k = k^2$ and all quantities are dimensionless. In this setting, momenta are measured in inverse lengths, energies in squared momenta, and the $s$-wave scattering length $a_s$ has units of length. The core objective is to fit the bare coupling to a target scattering length and then demonstrate that the resulting BCS gap at the Fermi momentum is independent of the momentum cutoff.\n\nFundamental base and definitions:\n- The contact interaction is defined as $V = -g$, where $g$ is a positive constant to be determined by renormalization.\n- In the two-body sector, the zero-energy on-shell $T$-matrix relates to the scattering length $a_s$ and must be used to fit the cutoff-dependent bare coupling to the target $a_s$ when a sharp momentum cutoff $k \\leq \\Lambda$ is imposed. The derivation must start from the Lippmann–Schwinger equation and the zero-energy scattering amplitude definition; do not use any shortcut formulas.\n- In the many-body sector at zero temperature, the homogeneous isotropic $s$-wave Bardeen–Cooper–Schrieffer (BCS) gap satisfies a self-consistent integral equation over momentum with a sharp cutoff $k \\leq \\Lambda$. The quasiparticle energy is $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$ with $\\varepsilon_k = k^2$. The chemical potential $\\mu$ must be set equal to the free Fermi energy $\\varepsilon_F = k_F^2$, appropriate for weak-coupling Fermi systems. The gap parameter $\\Delta$ is momentum-independent for a contact interaction in the $s$-wave channel. The gap equation involves the density-of-states factor in three dimensions.\n\nTasks:\n1) Starting from the Lippmann–Schwinger equation for a zero-range interaction with a sharp momentum cutoff $k \\leq \\Lambda$ at zero energy, derive the relation that expresses the cutoff-dependent bare coupling $g(\\Lambda)$ in terms of the target scattering length $a_s$ in the chosen units.\n2) Using the zero-temperature Bardeen–Cooper–Schrieffer (BCS) gap equation specialized to a contact interaction with sharp cutoff $k \\leq \\Lambda$, implement a numerical solver for $\\Delta$ at fixed Fermi momentum $k_F$, using $\\mu = k_F^2$.\n3) For each test case below, compute the gap $\\Delta$ for each listed cutoff $\\Lambda$ using the $g(\\Lambda)$ obtained from step $1$, and then verify that the set of $\\Delta$ values is invariant with respect to $\\Lambda$ within the specified tolerance. Invariance here means that the maximum relative deviation from the mean gap, $\\max_i \\left|\\Delta_i - \\overline{\\Delta}\\right|/\\overline{\\Delta}$, is less than or equal to the given tolerance.\n\nNumerical and implementation requirements:\n- All calculations must be performed in the units specified above, which are dimensionless in this problem statement.\n- The momentum integral in the Bardeen–Cooper–Schrieffer (BCS) gap equation must be computed with sufficient numerical accuracy. Pay particular attention to the integrable peak in the integrand near $k = k_F$ when $\\Delta$ is small.\n- The root-finding for the gap must be robustly bracketed and converge to $\\Delta  0$.\n- No external input is allowed. All parameters are given below and must be hard-coded.\n\nTest suite:\nFor each test case, you are given $(k_F, a_s, [\\Lambda\\ \\text{values}], \\text{tolerance})$. Compute the gap $\\Delta$ for each $\\Lambda$ in the order listed, then compute the invariance boolean as described above using that tolerance.\n\n- Test case $1$ (happy path): $k_F = 1.0$, $a_s = -0.5$, $\\Lambda \\in \\{2.0, 3.0, 4.0\\}$, tolerance $= 0.05$.\n- Test case $2$ (boundary, low cutoffs): $k_F = 0.75$, $a_s = -1.0$, $\\Lambda \\in \\{1.5, 2.0, 3.0\\}$, tolerance $= 0.08$.\n- Test case $3$ (edge, large cutoffs and weak coupling): $k_F = 1.25$, $a_s = -0.3$, $\\Lambda \\in \\{3.0, 6.0, 9.0\\}$, tolerance $= 0.06$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must concatenate, in order, for each test case: the three computed gaps (as floating-point numbers) in the order of the provided $\\Lambda$ values, followed by a boolean indicating whether invariance holds within the provided tolerance. Therefore, the final output must contain exactly $12$ entries in the following order:\n$[\\Delta^{(1)}(\\Lambda_1), \\Delta^{(1)}(\\Lambda_2), \\Delta^{(1)}(\\Lambda_3), \\text{invariant}^{(1)}, \\Delta^{(2)}(\\Lambda_1), \\Delta^{(2)}(\\Lambda_2), \\Delta^{(2)}(\\Lambda_3), \\text{invariant}^{(2)}, \\Delta^{(3)}(\\Lambda_1), \\Delta^{(3)}(\\Lambda_2), \\Delta^{(3)}(\\Lambda_3), \\text{invariant}^{(3)}]$.",
            "solution": "**1. Renormalization of the Coupling Constant**\n\nThe relationship between the bare coupling constant $g$ and the physical $s$-wave scattering length $a_s$ is established through the two-body scattering problem. We start with the Lippmann-Schwinger equation for the $T$-matrix in the center-of-mass frame:\n$$ T(E) = V + V G_0(E) T(E) $$\nwhere $V$ is the interaction potential and $G_0(E)$ is the free two-particle propagator. For a zero-range contact interaction, the potential matrix element is momentum-independent, $\\langle \\mathbf{k}' | V | \\mathbf{k} \\rangle = -g$, where $g0$ for an attractive potential. Consequently, the $T$-matrix is also momentum-independent, $T(E)$. The Lippmann-Schwinger equation becomes an algebraic equation for $T(E)$:\n$$ \\frac{1}{T(E)} = -\\frac{1}{g} - \\int \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2\\varepsilon_q + i\\eta} $$\nIn the specified units where $2m=1$ and $\\hbar=1$, the single-particle energy is $\\varepsilon_q = q^2$. The integral is ultraviolet divergent and is regularized using a sharp momentum cutoff $\\Lambda$:\n$$ \\frac{1}{T(E)} = -\\frac{1}{g(\\Lambda)} - \\int_{q \\le \\Lambda} \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2q^2 + i\\eta} $$\nThe scattering length $a_s$ is related to the zero-energy on-shell $T$-matrix. A standard convention in low-energy physics, consistent with an attractive potential ($a_s0$) not supporting a bound state, relates the on-shell $T$-matrix to $a_s$ via $T_{phys} = \\frac{4\\pi \\hbar^2 a_s}{m}$. In our units, this gives $T(E=0) = 8\\pi a_s$. Substituting $E=0$ into the equation for $T(E)$:\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} - \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{(2\\pi)^3} \\frac{1}{-2q^2} $$\nEvaluating the integral:\n$$ \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{8\\pi^3} \\frac{1}{-2q^2} = -\\frac{1}{4\\pi^2} \\int_0^\\Lambda dq = -\\frac{\\Lambda}{4\\pi^2} $$\nSubstituting this result back gives:\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} + \\frac{\\Lambda}{4\\pi^2} $$\nSolving for the cutoff-dependent bare coupling constant $1/g(\\Lambda)$:\n$$ \\frac{1}{g(\\Lambda)} = \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} $$\nFor the given test cases, $a_s  0$, which ensures $1/g(\\Lambda)  0$ and thus $g(\\Lambda)  0$, consistent with an attractive interaction required for BCS pairing.\n\n**2. The BCS Gap Equation**\n\nAt zero temperature, the self-consistent BCS gap equation for a momentum-independent gap $\\Delta$ arising from a contact interaction is:\n$$ 1 = g(\\Lambda) \\sum_{\\mathbf{k}}' \\frac{1}{2E_k} $$\nwhere the sum is over momentum states up to the cutoff $\\Lambda$, and $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$ is the quasiparticle energy. We are instructed to use the weak-coupling approximation for the chemical potential, $\\mu \\approx \\varepsilon_F = k_F^2$. The sum is converted to an integral:\n$$ \\sum_{\\mathbf{k}}' \\to \\int_{k \\le \\Lambda} \\frac{d^3 k}{(2\\pi)^3} = \\int_0^\\Lambda \\frac{4\\pi k^2 dk}{(2\\pi)^3} = \\frac{1}{2\\pi^2} \\int_0^\\Lambda k^2 dk $$\nThe gap equation becomes:\n$$ 1 = g(\\Lambda) \\frac{1}{2\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{2\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nSolving for $1/g(\\Lambda)$:\n$$ \\frac{1}{g(\\Lambda)} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nBy equating the two expressions for $1/g(\\Lambda)$ from the two-body and many-body sectors, we obtain a single equation for the gap $\\Delta$:\n$$ \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nMultiplying by $4\\pi^2$ yields the final equation to be solved for $\\Delta$:\n$$ \\Lambda - \\frac{\\pi}{2a_s} = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\nThis equation relates the many-body observable $\\Delta$ to the two-body observable $a_s$ and the Fermi momentum $k_F$, regularized by the cutoff $\\Lambda$. The core of the problem is to show that the solution $\\Delta$ to this equation is approximately independent of $\\Lambda$ for $\\Lambda \\gg k_F$.\n\n**3. Numerical Strategy**\n\nThe problem of finding $\\Delta$ is now a root-finding problem. We define a function $H(\\Delta)$ such that its root gives the desired gap value:\n$$ H(\\Delta) = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} - \\Lambda + \\frac{\\pi}{2a_s} $$\nWe need to find $\\Delta  0$ for which $H(\\Delta) = 0$.\nThe properties of $H(\\Delta)$ are analyzed to guide the numerical method:\n- **Monotonicity**: The derivative $\\frac{\\partial H}{\\partial \\Delta} = -\\Delta \\int_0^\\Lambda \\frac{k^2 dk}{[(k^2 - k_F^2)^2 + \\Delta^2]^{3/2}}$ is strictly negative for $\\Delta  0$. Thus, $H(\\Delta)$ is a monotonically decreasing function of $\\Delta$, which guarantees a unique root if one exists.\n- **Asymptotic Behavior**:\n  - As $\\Delta \\to 0^+$, the integral diverges logarithmically at $k=k_F$, so $H(\\Delta \\to 0^+) \\to +\\infty$.\n  - As $\\Delta \\to \\infty$, the integrand approaches $0$, so the integral tends to $0$. Thus, $H(\\Delta \\to \\infty) \\to -\\Lambda + \\frac{\\pi}{2a_s}$. Since $a_s  0$ in all test cases, this limit is always negative.\n\nSince $H(\\Delta)$ is continuous, monotonic, and changes sign from positive to negative over the domain $\\Delta \\in (0, \\infty)$, there must be a unique positive root $\\Delta$.\nThis structure is ideal for a bracketing root-finding algorithm like the Brent-Dekker method. The numerical implementation proceeds as follows:\n1. For each test case $(k_F, a_s, \\Lambda)$, define the function $H(\\Delta)$ as above.\n2. The integral within $H(\\Delta)$ is computed numerically using a robust quadrature routine, `scipy.integrate.quad`. The point $k=k_F$ is a region of rapid change in the integrand, so it is specified as a point of interest to the integrator to improve accuracy.\n3. The root of $H(\\Delta)=0$ is found using `scipy.optimize.root_scalar` with the `brentq` method, which is efficient and reliable for a bracketed, monotonic function. A suitable bracket is found based on the asymptotic analysis, for instance $[\\delta_{min}, \\delta_{max}]$ where $\\delta_{min}$ is a small positive number and $\\delta_{max}$ is on the order of $k_F^2$.\n4. This procedure is repeated for all $\\Lambda$ values within a test case to obtain a set of gap values $\\{\\Delta_i\\}$.\n5. The cutoff invariance is checked by computing the maximum relative deviation from the mean gap, $\\max_i |\\Delta_i - \\overline{\\Delta}| / |\\overline{\\Delta}|$, and comparing it to the specified tolerance.\nThe final program implements this strategy for each test case and formats the output as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the BCS gap equation for a series of test cases and verifies\n    the cutoff independence of the gap parameter.\n    \"\"\"\n    test_cases = [\n        {'kF': 1.0, 'a_s': -0.5, 'Lambdas': [2.0, 3.0, 4.0], 'tolerance': 0.05},\n        {'kF': 0.75, 'a_s': -1.0, 'Lambdas': [1.5, 2.0, 3.0], 'tolerance': 0.08},\n        {'kF': 1.25, 'a_s': -0.3, 'Lambdas': [3.0, 6.0, 9.0], 'tolerance': 0.06},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kF = case['kF']\n        a_s = case['a_s']\n        Lambdas = case['Lambdas']\n        tolerance = case['tolerance']\n\n        delta_values = []\n        for Lambda in Lambdas:\n            # -------------------------------------------------------------\n            # Define the function H(delta) whose root is the BCS gap.\n            # The equation to solve is H(delta) = 0, where:\n            # H(delta) = integral - (Lambda - pi / (2*a_s)) = 0\n            # -------------------------------------------------------------\n            target_integral_val = Lambda - np.pi / (2.0 * a_s)\n\n            def integrand(k, delta):\n                # The integrand of the gap equation.\n                denominator = np.sqrt((k**2 - kF**2)**2 + delta**2)\n                # Avoid division by zero if delta is exactly zero, although\n                # root finder will use small positive numbers.\n                if denominator == 0:\n                    return np.inf\n                return k**2 / denominator\n\n            def H(delta):\n                # The function to find the root of.\n                \n                # Specify points of interest for the integrator if they are\n                # inside the integration interval. The integrand is sharply\n                # peaked at k=kF.\n                integration_points = []\n                if 0  kF  Lambda:\n                    integration_points.append(kF)\n\n                # Use quad for numerical integration.\n                integral_val, _ = quad(\n                    integrand, 0, Lambda, args=(delta,), points=integration_points\n                )\n                \n                return integral_val - target_integral_val\n\n            # -------------------------------------------------------------\n            # Find the root of H(delta) using a bracketing method.\n            # -------------------------------------------------------------\n            # Based on asymptotic analysis, a root is guaranteed to exist\n            # for delta  0.\n            # Lower bound: a small positive number (delta - 0, H - +inf)\n            delta_min = 1e-8 * kF**2\n            # Upper bound: a value on the scale of the Fermi energy\n            # (delta - inf, H - -inf)\n            delta_max = 5.0 * kF**2\n\n            # Ensure the bracket is valid before calling the solver.\n            # This should not be an issue given the function's monotonic nature.\n            try:\n                if H(delta_max)  0:\n                    # The chosen upper bound is too small, increase it.\n                    # This is unlikely but handled for robustness.\n                    delta_max *= 10\n            except (ValueError, OverflowError):\n                 delta_max *= 10\n                 \n            # Find the root using Brent's method.\n            sol = root_scalar(H, bracket=[delta_min, delta_max], method='brentq')\n            delta_values.append(sol.root)\n        \n        # -------------------------------------------------------------\n        # Verify the invariance of the calculated gap values.\n        # -------------------------------------------------------------\n        mean_delta = np.mean(delta_values)\n        if mean_delta == 0:\n            # This case is unlikely, but if it happens, deviation is 0.\n            max_rel_dev = 0.0\n        else:\n            deviations = np.abs(np.array(delta_values) - mean_delta)\n            max_rel_dev = np.max(deviations) / np.abs(mean_delta)\n        \n        is_invariant = max_rel_dev = tolerance\n\n        # Append the results for this test case to the final list.\n        results.extend(delta_values)\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format.\n    # Format: [d_11, d_12, d_13, inv_1, d_21, d_22, d_23, inv_2, ...]\n    formatted_results = []\n    for item in results:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(f\"{item:.10f}\") # Use sufficient precision\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the physical framework of the regularized BCS equation established, we now turn to the art and science of its numerical solution. The momentum-space integral in the gap equation presents a classic computational challenge due to the integrand's sharp, near-singular behavior at the Fermi momentum $k_F$, especially in the weak-coupling limit where $\\Delta$ is small. This practice  is dedicated to mastering this integral, requiring you to implement and compare the performance of different numerical quadrature methods. By contrasting a standard Gauss-Legendre quadrature with more specialized techniques, you will gain critical insight into how the choice of numerical algorithm directly impacts the accuracy and efficiency of your results.",
            "id": "3594669",
            "problem": "Consider an isotropic, zero-temperature Bardeen–Cooper–Schrieffer (BCS) pairing problem in infinite, homogeneous nuclear matter in natural units where $\\hbar^2/(2m_N)=1$. Let the single-particle energy be $\\varepsilon(k)=k^{2}$, the Fermi momentum be $k_{F}$, and the chemical potential be $\\mu=\\varepsilon(k_{F})=k_{F}^{2}$. Adopt an $s$-wave, separable pairing interaction with a finite energy window of half-width $\\Omega$ around the Fermi surface, such that the gap function is isotropic and constant within this window, denoted by $\\Delta$. Within the standard Bardeen–Cooper–Schrieffer (BCS) mean-field theory at zero temperature, the isotropic gap satisfies a scalar non-linear equation that involves a momentum integral over the window where $|\\varepsilon(k)-\\mu|\\le \\Omega$. The quasiparticle energy is $E(k)=\\sqrt{(\\varepsilon(k)-\\mu)^{2}+\\Delta^{2}}$.\n\nYour task is to:\n- Derive a numerically stable discretization of the momentum-space integral that defines the scalar equation for $\\Delta$ starting from the above physical definitions, without appealing to any closed-form “shortcut” expressions. Use spherical symmetry and the free-gas dispersion $\\varepsilon(k)=k^{2}$.\n- Implement three different quadrature choices to approximate the $k$-integral:\n  1. Gauss–Legendre on the interval $[k_{-},k_{+}]$, where $k_{\\pm}=\\sqrt{\\max(\\mu\\pm\\Omega,0)}$ are the momentum bounds implied by the energy window.\n  2. Gauss–Chebyshev of the first kind via a linear map from $[-1,1]$ to $[k_{-},k_{+}]$, taking proper account of the Gauss–Chebyshev weight to approximate an unweighted integral over $k$.\n  3. A Stieltjes-type change-of-variables quadrature tailored to interior logarithmic features near $k=k_{F}$: split the integral at $k_{F}$ into $[k_{-},k_{F}]$ and $[k_{F},k_{+}]$, and on each subinterval apply the nonlinear mapping $k=k_{-}+(k_{F}-k_{-})u^{2}$ and $k=k_{F}+(k_{+}-k_{F})u^{2}$, respectively, with $u\\in[0,1]$, followed by Gauss–Legendre in $u$. This change of variables concentrates nodes near $k_{F}$, where the integrand exhibits logarithmic sensitivity in $\\Delta$.\n- For a given dimensionless coupling constant $g0$, solve the resulting scalar non-linear equation for $\\Delta$ by robust bracketing on $\\Delta\\in[\\Delta_{\\min},\\Delta_{\\max}]$, where $\\Delta_{\\min}0$ is small and $\\Delta_{\\max}$ is chosen large enough to ensure bracketing. Use the same $\\Delta$-solver for all quadrature choices.\n\nScientific and numerical details to enforce:\n- Use the three-dimensional momentum integral in spherical coordinates with measure $k^{2}\\,dk$, restricted to the window defined by $|\\varepsilon(k)-\\mu|\\le \\Omega$. Do not replace the momentum integral by any analytic energy-space closed form. Your derivation must start from the definitions above.\n- The numerical integral you approximate must be of the form $\\int_{k_{-}}^{k_{+}} F(k,\\Delta)\\,dk$ with $F$ constructed from the physical definitions provided in this problem statement and the stated model assumptions.\n- All energies, including $\\mu$, $\\Omega$, and the gap $\\Delta$, must be expressed in the natural energy unit defined by $\\hbar^2/(2m_N)=1$. Momenta are in the corresponding inverse-length unit. The final outputs for the gap must be in this energy unit.\n- Angles do not appear explicitly; no angle units are required.\n\nTest suite and required outputs:\n- For each parameter tuple $(k_{F},\\Omega,g;N_{\\mathrm{GL}},N_{\\mathrm{GC}},N_{\\mathrm{S}})$ below, compute a high-accuracy reference value $\\Delta_{\\mathrm{ref}}$ using a high-precision adaptive integrator for the same momentum integral and the same non-linear equation in $\\Delta$. Then compute $\\Delta_{\\mathrm{GL}}$, $\\Delta_{\\mathrm{GC}}$, and $\\Delta_{\\mathrm{S}}$ using the three quadrature choices above with $N_{\\mathrm{GL}}$, $N_{\\mathrm{GC}}$, and $N_{\\mathrm{S}}$ nodes, respectively. Finally, report the absolute errors $|\\Delta_{\\mathrm{GL}}-\\Delta_{\\mathrm{ref}}|$, $|\\Delta_{\\mathrm{GC}}-\\Delta_{\\mathrm{ref}}|$, and $|\\Delta_{\\mathrm{S}}-\\Delta_{\\mathrm{ref}}|$.\n- Use the following three test cases:\n  1. $k_{F}=1.33$, $\\Omega=0.50$, $g=15.0$, $N_{\\mathrm{GL}}=64$, $N_{\\mathrm{GC}}=64$, $N_{\\mathrm{S}}=64$.\n  2. $k_{F}=1.33$, $\\Omega=0.10$, $g=10.0$, $N_{\\mathrm{GL}}=64$, $N_{\\mathrm{GC}}=64$, $N_{\\mathrm{S}}=64$.\n  3. $k_{F}=1.33$, $\\Omega=1.00$, $g=40.0$, $N_{\\mathrm{GL}}=32$, $N_{\\mathrm{GC}}=32$, $N_{\\mathrm{S}}=32$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a three-element list for the corresponding test case. The inner lists must be ordered as $[\\ |\\Delta_{\\mathrm{GL}}-\\Delta_{\\mathrm{ref}}|\\ ,\\ |\\Delta_{\\mathrm{GC}}-\\Delta_{\\mathrm{ref}}|\\ ,\\ |\\Delta_{\\mathrm{S}}-\\Delta_{\\mathrm{ref}}|\\ ]$. For example, the final line must look like $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],[x_{3},y_{3},z_{3}]]$ with floating-point numbers.",
            "solution": "The derivation begins with the general BCS gap equation at zero temperature ($T=0$):\n$$\n\\Delta_{\\mathbf{k}} = - \\sum_{\\mathbf{k}'} V_{\\mathbf{k},\\mathbf{k}'} \\frac{\\Delta_{\\mathbf{k}'}}{2E(\\mathbf{k}')}\n$$\nwhere $\\Delta_{\\mathbf{k}}$ is the momentum-dependent gap function, $V_{\\mathbf{k},\\mathbf{k}'}$ is the pairing interaction matrix element, and $E(\\mathbf{k}) = \\sqrt{(\\varepsilon(\\mathbf{k})-\\mu)^2 + \\Delta_{\\mathbf{k}}^2}$ is the quasiparticle energy. The single-particle energy is given as $\\varepsilon(k) = k^2$ in natural units where $\\hbar^2/(2m_N)=1$, and the chemical potential is $\\mu = \\varepsilon(k_F) = k_F^2$.\n\nThe problem specifies an $s$-wave, separable pairing interaction that is constant within a defined energy window:\n$$\nV_{\\mathbf{k},\\mathbf{k}'} = \\begin{cases} -g  \\text{if } |\\varepsilon(k)-\\mu| \\le \\Omega \\text{ and } |\\varepsilon(k')-\\mu| \\le \\Omega \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nwhere $g  0$ is the dimensionless coupling constant. Due to the constant nature of the interaction within the active window, the gap function $\\Delta_{\\mathbf{k}}$ is also constant for momenta within this window, so we can write $\\Delta_{\\mathbf{k}} = \\Delta$. For momenta outside the window, the gap is zero.\n\nThe sum over discrete momentum states $\\sum_{\\mathbf{k}'}$ is replaced by an integral over a continuous momentum space for infinite matter: $\\sum_{\\mathbf{k}'} \\to \\int \\frac{d^3k'}{(2\\pi)^3}$. The gap equation becomes:\n$$\n\\Delta = - \\int_{|\\varepsilon(k')-\\mu| \\le \\Omega} \\frac{d^3k'}{(2\\pi)^3} (-g) \\frac{\\Delta}{2E(k')}\n$$\nAssuming a non-trivial solution ($\\Delta \\ne 0$), we can divide both sides by $\\Delta$:\n$$\n1 = \\frac{g}{2} \\int_{|\\varepsilon(k')-\\mu| \\le \\Omega} \\frac{d^3k'}{(2\\pi)^3 E(k')}\n$$\nThe integral is performed in spherical coordinates, where the volume element is $d^3k' = 4\\pi (k')^2 dk'$. The integral over angles yields a factor of $4\\pi$ due to the isotropy of the integrand.\n$$\n1 = \\frac{g}{2} \\int_{k_-}^{k_+} \\frac{4\\pi (k')^2 dk'}{(2\\pi)^3 \\sqrt{(\\varepsilon(k')-\\mu)^2 + \\Delta^2}}\n$$\nThe integration limits $k_-$ and $k_+$ are determined by the energy window condition $|\\varepsilon(k) - \\mu| \\le \\Omega$, which with $\\varepsilon(k) = k^2$ and $\\mu=k_F^2$ becomes $|k^2 - \\mu| \\le \\Omega$. This implies $\\mu - \\Omega \\le k^2 \\le \\mu + \\Omega$. We thus have $k_{-} = \\sqrt{\\max(\\mu-\\Omega, 0)}$ and $k_{+} = \\sqrt{\\mu+\\Omega}$. Simplifying the constant factor $\\frac{g}{2} \\frac{4\\pi}{(2\\pi)^3} = \\frac{g}{4\\pi^2}$, we arrive at the scalar non-linear equation for the gap $\\Delta$:\n$$\n1 = \\frac{g}{4\\pi^2} \\int_{k_{-}}^{k_{+}} \\frac{k^2 dk}{\\sqrt{(k^2-\\mu)^2 + \\Delta^2}}\n$$\nTo solve for $\\Delta$, we seek the root of the function $f(\\Delta)$:\n$$\nf(\\Delta) = 1 - \\frac{g}{4\\pi^2} \\int_{k_{-}}^{k_{+}} \\frac{k^2 dk}{\\sqrt{(k^2-\\mu)^2 + \\Delta^2}} = 0\n$$\nThe integral term is a monotonically decreasing function of $\\Delta$ for $\\Delta  0$. Consequently, $f(\\Delta)$ is a monotonically increasing function. For sufficiently large coupling $g$, $f(\\Delta \\to 0^+)  0$ and $f(\\Delta \\to \\infty) = 1  0$, guaranteeing a unique positive solution for $\\Delta$ that can be found using a bracketing root-finding algorithm like Brent's method.\n\nThe core of the numerical task is to approximate the integral $I(\\Delta) = \\int_{k_{-}}^{k_{+}} F(k, \\Delta) dk$, where the integrand is $F(k, \\Delta) = \\frac{k^2}{\\sqrt{(k^2-\\mu)^2 + \\Delta^2}}$. Three quadrature methods are specified.\n\n1.  **Gauss–Legendre (GL) Quadrature**: The integral over $[k_{-}, k_{+}]$ is transformed to the standard interval $[-1, 1]$ using the linear mapping $k(x) = \\frac{k_{+}-k_{-}}{2}x + \\frac{k_{+}+k_{-}}{2}$, with Jacobian $dk = \\frac{k_{+}-k_{-}}{2}dx$. The integral is approximated by the sum:\n    $$\n    I_{GL}(\\Delta) \\approx \\frac{k_{+}-k_{-}}{2} \\sum_{i=1}^{N_{GL}} w_i F(k(x_i), \\Delta)\n    $$\n    where $\\{x_i, w_i\\}$ are the $N_{GL}$-point Gauss-Legendre nodes and weights on $[-1, 1]$.\n\n2.  **Gauss–Chebyshev (GC) Quadrature of the First Kind**: This method approximates integrals of the form $\\int_{-1}^{1} \\frac{h(x)}{\\sqrt{1-x^2}}dx$. To approximate the unweighted integral $I(\\Delta)$, we again use the linear map $k(x)$ and recast the integral as:\n    $$\n    I(\\Delta) = \\int_{k_{-}}^{k_{+}} F(k) dk = \\int_{-1}^{1} \\left( F(k(x)) \\frac{k_{+}-k_{-}}{2} \\sqrt{1-x^2} \\right) \\frac{dx}{\\sqrt{1-x^2}}\n    $$\n    The term in parentheses is identified as $h(x)$. The GC quadrature approximation with nodes $x_i$ and constant weights $w_i = \\pi/N_{GC}$ is:\n    $$\n    I_{GC}(\\Delta) \\approx \\sum_{i=1}^{N_{GC}} w_i h(x_i) = \\frac{\\pi}{N_{GC}}\\frac{k_{+}-k_{-}}{2} \\sum_{i=1}^{N_{GC}} F(k(x_i), \\Delta) \\sqrt{1-x_i^2}\n    $$\n    where $x_i = \\cos(\\frac{2i-1}{2N_{GC}}\\pi)$ are the roots of the Chebyshev polynomial $T_{N_{GC}}(x)$.\n\n3.  **Stieltjes-type (S) Quadrature**: This method is tailored to the integrand's behavior near the Fermi surface ($k=k_F$). The integral is split: $I(\\Delta) = \\int_{k_{-}}^{k_F} F(k, \\Delta) dk + \\int_{k_F}^{k_+} F(k, \\Delta) dk$.\n    - For the first subinterval $[k_{-}, k_{F}]$, the change of variables $k(u) = k_{-} + (k_{F}-k_{-})u^2$ for $u \\in [0, 1]$ is applied. The Jacobian is $dk = 2(k_F - k_{-})u \\, du$.\n    - For the second subinterval $[k_{F}, k_{+}]$, the mapping is $k(u) = k_{F} + (k_{+}-k_{F})u^2$ for $u \\in [0, 1]$, with Jacobian $dk = 2(k_+ - k_{F})u \\, du$.\n    Each resulting integral in $u$ over $[0,1]$ is computed using Gauss-Legendre quadrature, with half of the total nodes ($N_S/2$) allocated to each subinterval. This requires mapping the GL nodes from $[-1,1]$ to $[0,1]$.\n\nA high-accuracy reference solution, $\\Delta_{\\text{ref}}$, is computed by solving the same equation $f(\\Delta)=0$, but evaluating the integral using a robust adaptive quadrature routine (`scipy.integrate.quad`). The absolute errors of the three specified methods are then calculated with respect to this reference value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\nfrom scipy import optimize\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the BCS gap equation for three test cases using different quadrature\n    rules and reports the absolute errors against a high-accuracy reference.\n    \"\"\"\n    test_cases = [\n        # (kF, Omega, g, N_GL, N_GC, N_S)\n        (1.33, 0.50, 15.0, 64, 64, 64),\n        (1.33, 0.10, 10.0, 64, 64, 64),\n        (1.33, 1.00, 40.0, 32, 32, 32),\n    ]\n\n    all_results = []\n    \n    # Bracketing interval for the root finder\n    DELTA_MIN = 1e-12 \n\n    for case in test_cases:\n        kF, Omega, g, N_GL, N_GC, N_S = case\n        \n        # Physical parameters\n        mu = kF**2\n        k_minus = np.sqrt(np.maximum(mu - Omega, 0.0))\n        k_plus = np.sqrt(mu + Omega)\n        \n        DELTA_MAX = 2 * g  # A safe upper bound for the gap\n\n        # Integrand of the gap equation\n        def integrand(k, mu_val, delta_val):\n            # Add a small epsilon to denominator to handle delta=0 case if needed,\n            # though solver stays in delta  0 domain.\n            denom = np.sqrt((k**2 - mu_val)**2 + delta_val**2)\n            return (k**2) / denom\n\n        # --- Quadrature Implementations ---\n\n        def integrate_gl(delta, N):\n            nodes, weights = special.roots_legendre(N)\n            # Map nodes from [-1, 1] to [k_minus, k_plus]\n            k_nodes = 0.5 * (k_plus - k_minus) * nodes + 0.5 * (k_plus + k_minus)\n            f_vals = integrand(k_nodes, mu, delta)\n            integral = 0.5 * (k_plus - k_minus) * np.dot(weights, f_vals)\n            return integral\n\n        def integrate_gc(delta, N):\n            nodes, _ = special.roots_chebyt(N) # Weights are all pi/N\n            weights = np.full(N, np.pi / N)\n            # Map nodes from [-1, 1] to [k_minus, k_plus]\n            k_nodes = 0.5 * (k_plus - k_minus) * nodes + 0.5 * (k_plus + k_minus)\n            h_vals = integrand(k_nodes, mu, delta) * np.sqrt(1 - nodes**2)\n            integral = 0.5 * (k_plus - k_minus) * np.dot(weights, h_vals)\n            return integral\n\n        def integrate_s(delta, N):\n            if N % 2 != 0:\n                raise ValueError(\"N_S must be an even number.\")\n            N_sub = N // 2\n            \n            nodes_v, weights_w = special.roots_legendre(N_sub)\n            # Map nodes from [-1, 1] to [0, 1] for variable u\n            u_nodes = 0.5 * (nodes_v + 1.0)\n            \n            # Sub-integral 1: [k_minus, kF]\n            # k(u) = k_minus + (kF - k_minus) * u^2\n            # dk = 2 * (kF - k_minus) * u * du\n            k1_nodes = k_minus + (kF - k_minus) * u_nodes**2\n            integrand1_vals = integrand(k1_nodes, mu, delta)\n            G1_vals = integrand1_vals * 2.0 * (kF - k_minus) * u_nodes\n            # The integral over u is on [0,1], map from GL on [-1,1] adds factor 0.5\n            integral1 = 0.5 * np.dot(weights_w, G1_vals)\n\n            # Sub-integral 2: [kF, k_plus]\n            # k(u) = kF + (k_plus - kF) * u^2\n            # dk = 2 * (k_plus - kF) * u * du\n            k2_nodes = kF + (k_plus - kF) * u_nodes**2\n            integrand2_vals = integrand(k2_nodes, mu, delta)\n            G2_vals = integrand2_vals * 2.0 * (k_plus - kF) * u_nodes\n            integral2 = 0.5 * np.dot(weights_w, G2_vals)\n\n            return integral1 + integral2\n            \n        def integrate_ref(delta):\n            # High-precision adaptive quadrature\n            result, _ = integrate.quad(integrand, k_minus, k_plus, args=(mu, delta))\n            return result\n\n        # --- Nonlinear Solver ---\n\n        def solve_gap_equation(integrator_func, N_nodes=None):\n            def f_gap(delta):\n                if N_nodes:\n                    integral_val = integrator_func(delta, N_nodes)\n                else:\n                    integral_val = integrator_func(delta)\n                return 1.0 - (g / (4.0 * np.pi**2)) * integral_val\n\n            # Use Brent's method for robust root finding\n            try:\n                solution = optimize.brentq(f_gap, DELTA_MIN, DELTA_MAX)\n            except ValueError:\n                # This can happen if f(a) and f(b) don't have opposite signs\n                # which can indicate no solution in the bracket or poor bracket choice.\n                # For this problem's parameters, a solution should exist.\n                # For robustness, expand bracket if it fails.\n                solution = optimize.brentq(f_gap, DELTA_MIN, DELTA_MAX * 5)\n\n            return solution\n\n        # --- Calculations ---\n        \n        delta_ref = solve_gap_equation(integrate_ref)\n        delta_gl = solve_gap_equation(integrate_gl, N_GL)\n        delta_gc = solve_gap_equation(integrate_gc, N_GC)\n        delta_s = solve_gap_equation(integrate_s, N_S)\n        \n        err_gl = abs(delta_gl - delta_ref)\n        err_gc = abs(delta_gc - delta_ref)\n        err_s = abs(delta_s - delta_ref)\n        \n        all_results.append([err_gl, err_gc, err_s])\n\n    # Final print statement in the exact required format.\n    # The output format requires a list of lists.\n    formatted_results = [f\"[{e_gl},{e_gc},{e_s}]\" for e_gl, e_gc, e_s in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}