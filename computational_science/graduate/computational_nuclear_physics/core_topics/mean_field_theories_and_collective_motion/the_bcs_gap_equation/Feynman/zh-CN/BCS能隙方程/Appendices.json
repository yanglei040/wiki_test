{
    "hands_on_practices": [
        {
            "introduction": "我们的实践始于一个基本但至关重要的问题：在有限的、离散的能级系统中求解BCS方程。这种情景直接对应于原子核壳模型中的配对问题，是理解复杂系统配对现象的基石。通过这项练习 ，你将推导并数值求解决定化学势 $\\mu$ 和配对能隙 $\\Delta$ 的耦合非线性方程组，并确保粒子数守恒，从而掌握求解自洽方程的基本计算技能。",
            "id": "3594622",
            "problem": "给定一个零温下的偶偶费米子系统，该系统由一个简化的配对哈密顿量描述。此哈密顿量具有恒定的配对强度 $G$，作用于围绕一个参考能量的能量窗口内。单粒子谱是离散的、等间距的，并且关于参考能量对称，其能量为 $ \\epsilon_n = n \\delta $，其中整数 $n$ 满足 $ |\\epsilon_n| \\leq E_c $，$ \\delta $ 是能级间距，$ E_c $ 是配对窗口的截断能量。每个能级都具有时间反演（二重）简并。任务是，在巨正则系综中，确定能够自洽地描述该系统的化学势 $ \\mu $ 和配对能隙 $ \\Delta $，同时在零温平均场近似下保持指定的总粒子数 $ N $。\n\n从简化的配对模型和配对费米子的零温平均场框架出发，推导确定准粒子谱和占据振幅所需的自洽条件。根据这些条件，构建确定 $ \\mu $ 和 $ \\Delta $ 的耦合非线性方程组。您的推导必须确保解满足对偶偶系统的平均粒子数 $ N $ 的约束。\n\n然后，针对一组指定的参数值，为求解 $ \\mu $ 和 $ \\Delta $ 的耦合非线性方程组实现一个数值求解器。您必须确保数值方法强制 $ \\Delta > 0 $，能处理配对窗口 $ |\\epsilon_n| \\leq E_c $ 上的离散求和，并且即使在无相互作用的费米能级接近某个离散能级时也能产生解。如有需要，请提供一个鲁棒的初始猜测和一个后备策略，以确保收敛。\n\n所有能量必须以兆电子伏特（MeV）为单位表示。输出的 $ \\mu $ 和 $ \\Delta $ 值必须以 MeV 为单位报告，并四舍五入到六位小数。\n\n在 MeV 和粒子数单位下，使用以下参数集测试套件 $ (\\delta, E_c, G, N) $：\n- 测试用例 1 (一般情况): $ \\delta = 0.2 $, $ E_c = 5.0 $, $ G = 0.4 $, $ N = 40 $.\n- 测试用例 2 (接近空填充): $ \\delta = 0.5 $, $ E_c = 4.0 $, $ G = 0.6 $, $ N = 2 $.\n- 测试用例 3 (高填充): $ \\delta = 0.1 $, $ E_c = 3.0 $, $ G = 0.25 $, $ N = 80 $.\n- 测试用例 4 (小模型空间，接近满填充): $ \\delta = 0.5 $, $ E_c = 1.0 $, $ G = 0.8 $, $ N = 8 $.\n- 测试用例 5 (弱配对): $ \\delta = 0.3 $, $ E_c = 3.0 $, $ G = 0.15 $, $ N = 20 $.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个列表 $ [\\mu, \\Delta] $，两个条目都以 MeV 为单位四舍五入到六位小数。例如：$ [[\\mu_1,\\Delta_1],[\\mu_2,\\Delta_2],\\dots] $。\n\n注意：在您的推导或数值方法中出现的任何三角量或角度量，都必须以弧度处理。最终的数值答案必须以 MeV 为单位，按指定的舍入要求提供为浮点数，并且除了列表结构外，输出行中不应出现任何单位或其他文本。",
            "solution": "用户希望在一个简化的零温 Bardeen-Cooper-Schrieffer (BCS) 模型中，求解一个偶偶费米子系统的化学势 $\\mu$ 和配对能隙 $\\Delta$。这需要推导耦合的自洽 BCS 方程并进行数值求解。\n\n### 步骤 1：BCS 方程的理论推导\n\n该系统由一个在指定模型空间内的简化配对哈密顿量描述。我们在巨正则系综中进行研究，引入化学势 $\\mu$ 来固定平均粒子数 $N$。哈密顿量为 $K = H - \\mu N$。\n\n配对哈密顿量由下式给出：\n$$\nH = \\sum_{n, \\sigma} \\epsilon_n a_{n\\sigma}^\\dagger a_{n\\sigma} - G \\sum_{n, n'} a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}'\\downarrow} a_{n' \\uparrow}\n$$\n其中 $a_{n\\sigma}^\\dagger$ 在自旋投影为 $\\sigma$ 的态 $n$ 上创建一个费米子。在原子核的背景下，这些代表时间反演态。每个能级 $n$ 的能量为 $\\epsilon_n$，并具有二重简并，对应于态 $|n\\rangle$ 及其时间反演伴侣 $|\\bar{n}\\rangle$。$G$ 是恒定的配对强度。\n\n在 BCS 平均场近似中，四费米子相互作用项被线性化。我们将配对能隙参数 $\\Delta$ 定义为：\n$$\n\\Delta = G \\sum_{n'} \\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle\n$$\n期望值是相对于 BCS 基态计算的。通过选择合适的相位，$\\Delta$ 可以被视为一个实的正值，即 $\\Delta > 0$。平均场巨正则哈密顿量 $K_{MF} = H_{MF} - \\mu N$ 变为：\n$$\nK_{MF} = \\sum_{n} (\\epsilon_n - \\mu) (a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow}) - \\sum_n \\left( \\Delta a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger + \\Delta a_{\\bar{n}\\downarrow} a_{n\\uparrow} \\right) + \\frac{\\Delta^2}{G}\n$$\n该哈密顿量是费米子算符的二次型，可以使用 Bogoliubov 变换进行对角化，该变换引入了准粒子算符 $\\alpha$：\n$$\n\\alpha_{n\\uparrow} = u_n a_{n\\uparrow} - v_n a_{\\bar{n}\\downarrow}^\\dagger\n$$\n$$\n\\alpha_{\\bar{n}\\downarrow} = u_n a_{\\bar{n}\\downarrow} + v_n a_{n\\uparrow}^\\dagger\n$$\n系数 $u_n$ 和 $v_n$ 是实数，并满足归一化条件 $u_n^2 + v_n^2 = 1$。此变换是正则的，并将 $K_{MF}$ 对角化为以下形式：\n$$\nK_{MF} = E_0 + \\sum_n E_n (\\alpha_{n\\uparrow}^\\dagger \\alpha_{n\\uparrow} + \\alpha_{\\bar{n}\\downarrow}^\\dagger \\alpha_{\\bar{n}\\downarrow})\n$$\n其中 $E_0$ 是基态能量，$E_n$ 是能级 $n$ 的准粒子能量：\n$$\nE_n = \\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}\n$$\nBCS 基态 $|\\Psi_{BCS}\\rangle$ 是这些准粒子的真空态，即对于所有 $n, \\sigma$ 都有 $\\alpha_{n\\sigma} |\\Psi_{BCS}\\rangle = 0$。系数 $u_n$ 和 $v_n$ 由对角化过程确定：\n$$\nu_n^2 = \\frac{1}{2} \\left( 1 + \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\n$$\nv_n^2 = \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\n系数 $v_n^2$ 表示对态 $(n\\uparrow, \\bar{n}\\downarrow)$ 在基态中被占据的概率，而 $u_n^2 = 1 - v_n^2$ 是其为空的概率。\n\n从此框架中可以推导出两个自洽方程。\n\n**1. 粒子数守恒方程：**\n基态中的平均粒子数 $N$ 是固定的。每个能级 $n$ 可以容纳两个粒子（一个时间反演对）。总粒子数是所有能级上占据概率的总和：\n$$\nN = \\sum_n \\langle a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow} \\rangle = \\sum_n (v_n^2 + v_n^2) = \\sum_n 2 v_n^2\n$$\n代入 $v_n^2$ 的表达式：\n$$\nN = \\sum_n 2 \\cdot \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right) = \\sum_n \\left( 1 - \\frac{\\epsilon_n - \\mu}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}} \\right)\n$$\n这是第一个方程，它将 $\\mu$ 和 $\\Delta$ 与总粒子数 $N$ 联系起来。\n\n**2. 能隙方程：**\n第二个方程来自 $\\Delta$ 的自洽定义。期望值 $\\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle$ 可以在准粒子真空中计算，得到 $u_{n'}v_{n'}$。\n$$\n\\Delta = G \\sum_{n'} u_{n'}v_{n'}\n$$\n我们可以将 $u_n v_n$ 表示为：\n$$\nu_n v_n = \\sqrt{u_n^2 v_n^2} = \\sqrt{\\frac{1}{4} \\left( 1 - \\left(\\frac{\\epsilon_n - \\mu}{E_n}\\right)^2 \\right)} = \\sqrt{\\frac{1}{4} \\frac{E_n^2 - (\\epsilon_n - \\mu)^2}{E_n^2}} = \\sqrt{\\frac{\\Delta^2}{4E_n^2}} = \\frac{\\Delta}{2E_n}\n$$\n其中我们使用了 $\\Delta > 0$。将其代回 $\\Delta$ 的定义中：\n$$\n\\Delta = G \\sum_n \\frac{\\Delta}{2E_n}\n$$\n对于非平庸配对解（$\\Delta > 0$），我们可以两边同除以 $\\Delta$ 得到能隙方程：\n$$\n1 = \\frac{G}{2} \\sum_n \\frac{1}{E_n} \\implies \\frac{2}{G} = \\sum_n \\frac{1}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}}\n$$\n这是第二个自洽方程。\n\n求和 $\\sum_n$ 是对配对窗口内离散的单粒子能级集进行的。能级由 $\\epsilon_n = n \\delta$ 给出，其中整数 $n$ 满足 $|n\\delta| \\leq E_c$。这意味着 $n$ 的范围是从 $n_{min} = -\\lfloor E_c/\\delta \\rfloor$ 到 $n_{max} = \\lfloor E_c/\\delta \\rfloor$。\n\n### 步骤 2：数值实现\n\n任务是求解以下关于变量 $(\\mu, \\Delta)$ 的耦合非线性方程组：\n$$\nf_1(\\mu, \\Delta) = N - \\sum_{n=n_{min}}^{n_{max}} \\left( 1 - \\frac{n\\delta - \\mu}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} \\right) = 0\n$$\n$$\nf_2(\\mu, \\Delta) = \\frac{2}{G} - \\sum_{n=n_{min}}^{n_{max}} \\frac{1}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} = 0\n$$\n该系统将使用数值求根算法求解，具体是 `scipy.optimize.root`。\n\n**算法设计：**\n1.  **模型空间定义**：对于给定的参数集 $(\\delta, E_c, G, N)$，首先确定单粒子能级的范围。最大整数索引为 $n_{max} = \\lfloor E_c/\\delta \\rfloor$。能级集是一个能量数组 $\\epsilon_n = n\\delta$，其中 $n \\in \\{-n_{max}, -n_{max}+1, \\dots, n_{max}\\}$。\n\n2.  **方程组**：定义一个 Python 函数，该函数接受一个向量 `[mu, delta]` 并返回 `[f1(mu, delta), f2(mu, delta)]` 的值。求和是在预先计算好的能级能量数组上进行的。请注意，方程依赖于 $\\Delta^2$。因此，如果 $(\\mu, \\Delta)$ 是一个解，那么 $(\\mu, -\\Delta)$ 也是一个解。按照惯例，物理配对能隙是正的，所以我们取求解器找到的 $\\Delta$ 的绝对值。\n\n3.  **初始猜测**：一个好的初始猜测对于求根算法的收敛性和稳定性至关重要。\n    *   **对于 $\\mu$**：无相互作用系统的费米能级 $\\epsilon_F$ 是一个很好的初始猜测。对于给定的对称谱，我们填充最低的 $N/2$ 个能级。最后一个被占据能级的索引是 $n_{occ} = N/2 - n_{max} - 1$，第一个未占据能级的索引是 $n_{unocc} = N/2 - n_{max}$。初始猜测 $\\mu_0$ 设置为中点：$\\mu_0 = (\\epsilon_{n_{occ}} + \\epsilon_{n_{unocc}})/2 = (N/2 - n_{max} - 0.5)\\delta$。这样可以避免将 $\\mu_0$ 精确地放在一个能级上，从而提高鲁棒性。\n    *   **对于 $\\Delta$**：配对强度 $G$ 本身为能隙 $\\Delta$ 提供了一个合理的量级估计。因此，我们选择初始猜测 $\\Delta_0 = G$。\n\n4.  **求解器执行**：我们使用 `scipy.optimize.root` 函数及其 `hybr` 方法，这是一种用于非线性方程组的成熟且鲁棒的算法。使用方程函数和初始猜测 `[mu_0, delta_0]` 调用求解器。如果主要猜测未能收敛，则实施一个后备策略，尝试一个更小的能隙初始猜测，例如 $\\Delta_0 = 0.1 G$，以处理弱配对的情况。\n\n5.  **输出格式化**：提取最终的解向量 `[mu, delta]`。取 `delta` 的绝对值，并按要求将两个值四舍五入到六位小数。对每个测试用例重复此过程，并将结果汇总成指定的列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the BCS equations for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (delta, Ec, G, N) in MeV and particle count.\n    test_cases = [\n        (0.2, 5.0, 0.4, 40),   # Test case 1 (general case)\n        (0.5, 4.0, 0.6, 2),    # Test case 2 (near-empty filling)\n        (0.1, 3.0, 0.25, 80),  # Test case 3 (high filling)\n        (0.5, 1.0, 0.8, 8),    # Test case 4 (small model space, near full)\n        (0.3, 3.0, 0.15, 20),  # Test case 5 (weak pairing)\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_sol, delta_sol = solve_bcs(*case)\n        results.append([round(mu_sol, 6), round(delta_sol, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_bcs(delta_e, Ec, G, N):\n    \"\"\"\n    Solves the coupled BCS equations for mu and delta for a single parameter set.\n\n    Args:\n        delta_e (float): Single-particle level spacing in MeV.\n        Ec (float): Pairing window cutoff energy in MeV.\n        G (float): Pairing strength in MeV.\n        N (int): Total even number of particles.\n\n    Returns:\n        tuple[float, float]: The solved chemical potential (mu) and pairing gap (delta).\n    \"\"\"\n\n    # 1. Define the model space\n    n_max = int(np.floor(Ec / delta_e))\n    eps_levels = np.arange(-n_max, n_max + 1) * delta_e\n\n    # 2. Define the system of equations for the root finder\n    def bcs_equations(variables):\n        mu, delta_gap = variables\n        \n        # Use delta_gap^2 in equations to handle potential negative values during iteration.\n        delta_gap_sq = delta_gap**2\n        \n        # Add a small epsilon to the denominator to prevent any potential sqrt(0) issues,\n        # though with floating point arithmetic it's highly unlikely.\n        quasiparticle_energies = np.sqrt((eps_levels - mu)**2 + delta_gap_sq)\n\n        # Equation 1: Number conservation\n        # N = sum_{n} (1 - (eps_n - mu) / E_n)\n        # We compute the residual: f1 = N - sum(...)\n        eq1 = N - np.sum(1.0 - (eps_levels - mu) / quasiparticle_energies)\n\n        # Equation 2: Gap equation\n        # 2/G = sum_{n} 1 / E_n\n        # We compute the residual: f2 = 2/G - sum(...)\n        # For G=0 this would be a problem, but G>0 in all test cases.\n        eq2 = 2.0 / G - np.sum(1.0 / quasiparticle_energies)\n\n        return [eq1, eq2]\n\n    # 3. Determine a robust initial guess\n    # For mu: non-interacting Fermi level, placed between the last occupied\n    # and first unoccupied levels.\n    mu_0 = (N / 2.0 - n_max - 0.5) * delta_e\n    \n    # For delta: The pairing strength G is a reasonable order-of-magnitude estimate.\n    delta_0 = G\n\n    # 4. Call the solver\n    solution = root(bcs_equations, [mu_0, delta_0], method='hybr', tol=1e-9)\n    \n    # Optional: Implement fallback strategy as mentioned in the problem description.\n    # If the first attempt fails, try a smaller initial delta.\n    if not solution.success:\n        solution = root(bcs_equations, [mu_0, 0.1 * G], method='hybr', tol=1e-9)\n        # If it still fails, the problem might be ill-conditioned. For this problem set,\n        # we assume one of these initial guesses will lead to convergence.\n        if not solution.success:\n            # This indicates a failure to converge, return NaNs or raise an error.\n            # In this contest, the problem is well-posed, so this path is not expected.\n            return (np.nan, np.nan)\n\n    mu_sol, delta_sol = solution.x\n    \n    # 5. Finalize the result\n    # The physical pairing gap Delta is positive. Since the equations depend on Delta^2,\n    # the solver might converge to a negative value. We take the absolute value.\n    delta_sol = abs(delta_sol)\n    \n    # Handle the trivial solution case for weak pairing\n    # if the gap equation cannot be satisfied for any Delta > 0.\n    # This can be checked by evaluating the gap equation at Delta=0.\n    # If 2/G > sum(1/|eps-mu|), then Delta=0 is the only solution.\n    # However, the problem formulation implies a paired solution (Delta>0) exists.\n    # The numerical value of delta_sol will be very close to zero in this case.\n\n    return mu_sol, delta_sol\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "从离散能级过渡到无限物质的连续谱，我们需要处理动量积分，这带来了新的数值挑战。本练习  专注于精确计算BCS能隙方程中的积分，特别是处理费米面附近被积函数的尖锐行为。你将实现并比较不同的数值积分方法（quadrature methods），从而深入理解它们在处理这类物理问题时的效率和准确性，这是连续谱计算中的一项关键技能。",
            "id": "3594669",
            "problem": "考虑一个无限、均匀核物质中的各向同性、零温 Bardeen–Cooper–Schrieffer (BCS) 配对问题，使用自然单位制，其中 $\\hbar^{2}/(2m_{N})=1$。设单粒子能量为 $\\varepsilon(k)=k^{2}$，费米动量为 $k_{F}$，化学势为 $\\mu=\\varepsilon(k_{F})=k_{F}^{2}$。采用 $s$ 波、可分离的配对相互作用，在费米面周围有一个半宽为 $\\Omega$ 的有限能量窗，使得能隙函数在此窗内是各向同性且恒定的，记为 $\\Delta$。在零温下的标准 Bardeen–Cooper–Schrieffer (BCS) 平均场理论中，各向同性能隙满足一个标量非线性方程，该方程涉及在 $|\\varepsilon(k)-\\mu|\\le \\Omega$ 窗口上的动量积分。准粒子能量为 $E(k)=\\sqrt{(\\varepsilon(k)-\\mu)^{2}+\\Delta^{2}}$。\n\n您的任务是：\n- 从上述物理定义出发，推导一个用于定义 $\\Delta$ 标量方程的动量空间积分的数值稳定离散化方法，不得借助任何封闭形式的“捷径”表达式。利用球对称性和自由气体色散关系 $\\varepsilon(k)=k^{2}$。\n- 实现三种不同的求积方法来近似 $k$ 积分：\n  1. 在区间 $[k_{-},k_{+}]$ 上使用 Gauss–Legendre 求积，其中 $k_{\\pm}=\\sqrt{\\max(\\mu\\pm\\Omega,0)}$ 是由能量窗所确定的动量边界。\n  2. 通过从 $[-1,1]$到 $[k_{-},k_{+}]$ 的线性映射使用第一类 Gauss–Chebyshev 求积，并适当考虑 Gauss–Chebyshev 权重来近似关于 $k$ 的无权积分。\n  3. 一种针对 $k=k_{F}$ 附近内部对数特征定制的 Stieltjes 型变量替换求积法：在 $k_{F}$ 处将积分分割为 $[k_{-},k_{F}]$ 和 $[k_{F},k_{+}]$，并分别在每个子区间上应用非线性映射 $k=k_{-}+(k_{F}-k_{-})u^{2}$ 和 $k=k_{F}+(k_{+}-k_{F})u^{2}$（其中 $u\\in[0,1]$），然后对变量 $u$ 使用 Gauss–Legendre 求积。这种变量替换将节点集中在 $k_{F}$ 附近，在此处被积函数对 $\\Delta$ 表现出对数敏感性。\n- 对于给定的无量纲耦合常数 $g>0$，通过在 $\\Delta\\in[\\Delta_{\\min},\\Delta_{\\max}]$ 上进行稳健的区间套定（bracketing）来求解得到的关于 $\\Delta$ 的标量非线性方程，其中 $\\Delta_{\\min}>0$ 是一个小数，而 $\\Delta_{\\max}$ 选择得足够大以确保区间套定。对所有求积选择使用相同的 $\\Delta$ 求解器。\n\n需要实施的科学和数值细节：\n- 在球坐标系中使用三维动量积分，测度为 $k^{2}\\,dk$，并限制在由 $|\\varepsilon(k)-\\mu|\\le \\Omega$ 定义的窗口内。不要用任何解析的能量空间封闭形式替换动量积分。您的推导必须从上述定义开始。\n- 您所近似的数值积分必须是 $\\int_{k_{-}}^{k_{+}} F(k,\\Delta)\\,dk$ 的形式，其中 $F$ 是根据本问题陈述中提供的物理定义和所述模型假设构造的。\n- 所有能量，包括 $\\mu$、$\\Omega$ 和能隙 $\\Delta$，都必须用由 $\\hbar^{2}/(2m_{N})=1$ 定义的自然能量单位表示。动量则使用相应的逆长度单位。能隙的最终输出必须采用此能量单位。\n- 角度不显式出现；不需要角度单位。\n\n测试套件和要求的输出：\n- 对于下面的每个参数元组 $(k_{F},\\Omega,g;N_{\\mathrm{GL}},N_{\\mathrm{GC}},N_{\\mathrm{S}})$，使用高精度自适应积分器对相同的动量积分和相同的关于 $\\Delta$ 的非线性方程计算一个高精度的参考值 $\\Delta_{\\mathrm{ref}}$。然后，分别使用上述三种求积选择，并采用 $N_{\\mathrm{GL}}$、$N_{\\mathrm{GC}}$ 和 $N_{\\mathrm{S}}$ 个节点，计算 $\\Delta_{\\mathrm{GL}}$、$\\Delta_{\\mathrm{GC}}$ 和 $\\Delta_{\\mathrm{S}}$。最后，报告绝对误差 $|\\Delta_{\\mathrm{GL}}-\\Delta_{\\mathrm{ref}}|$、 $|\\Delta_{\\mathrm{GC}}-\\Delta_{\\mathrm{ref}}|$ 和 $|\\Delta_{\\mathrm{S}}-\\Delta_{\\mathrm{ref}}|$。\n- 使用以下三个测试用例：\n  1. $k_{F}=1.33$, $\\Omega=0.50$, $g=15.0$, $N_{\\mathrm{GL}}=64$, $N_{\\mathrm{GC}}=64$, $N_{\\mathrm{S}}=64$。\n  2. $k_{F}=1.33$, $\\Omega=0.10$, $g=10.0$, $N_{\\mathrm{GL}}=64$, $N_{\\mathrm{GC}}=64$, $N_{\\mathrm{S}}=64$。\n  3. $k_{F}=1.33$, $\\Omega=1.00$, $g=40.0$, $N_{\\mathrm{GL}}=32$, $N_{\\mathrm{GC}}=32$, $N_{\\mathrm{S}}=32$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的一个三元素列表。内部列表必须按 $[\\ |\\Delta_{\\mathrm{GL}}-\\Delta_{\\mathrm{ref}}|\\ ,\\ |\\Delta_{\\mathrm{GC}}-\\Delta_{\\mathrm{ref}}|\\ ,\\ |\\Delta_{\\mathrm{S}}-\\Delta_{\\mathrm{ref}}|\\ ]$ 的顺序列出。例如，最后一行必须看起来像 $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],[x_{3},y_{3},z_{3}]]$，其中包含浮点数。",
            "solution": "该问题要求对一个无限、均匀核物质的简化模型，求解零温 Bardeen–Cooper–Schrieffer (BCS) 能隙方程。解必须从第一性原理推导，并使用三种不同的数值求积方案实现。\n\n推导从零温（$T=0$）下的一般 BCS 能隙方程开始：\n$$\n\\Delta_{\\mathbf{k}} = - \\sum_{\\mathbf{k}'} V_{\\mathbf{k},\\mathbf{k}'} \\frac{\\Delta_{\\mathbf{k}'}}{2E(\\mathbf{k}')}\n$$\n其中 $\\Delta_{\\mathbf{k}}$ 是依赖于动量的能隙函数，$V_{\\mathbf{k},\\mathbf{k}'}$ 是配对相互作用矩阵元，$E(\\mathbf{k}) = \\sqrt{(\\varepsilon(\\mathbf{k})-\\mu)^2 + \\Delta_{\\mathbf{k}}^2}$ 是准粒子能量。在自然单位制（$\\hbar^2/(2m_N)=1$）下单粒子能量为 $\\varepsilon(k) = k^2$，化学势为 $\\mu = \\varepsilon(k_F) = k_F^2$。\n\n问题指定了一个 $s$ 波、可分离的配对相互作用，它在一个定义的能量窗内是恒定的：\n$$\nV_{\\mathbf{k},\\mathbf{k}'} = \\begin{cases} -g  \\text{if } |\\varepsilon(k)-\\mu| \\le \\Omega \\text{ and } |\\varepsilon(k')-\\mu| \\le \\Omega \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n其中 $g > 0$ 是无量纲耦合常数。由于在该活动窗内相互作用的常数性质，能隙函数 $\\Delta_{\\mathbf{k}}$ 对于此窗内的动量也是恒定的，因此我们可以写成 $\\Delta_{\\mathbf{k}} = \\Delta$。对于窗外的动量，能隙为零。\n\n对于无限物质，对离散动量态的求和 $\\sum_{\\mathbf{k}'}$ 被替换为对连续动量空间的积分：$\\sum_{\\mathbf{k}'} \\to \\int \\frac{d^3k'}{(2\\pi)^3}$。能隙方程变为：\n$$\n\\Delta = - \\int_{|\\varepsilon(k')-\\mu| \\le \\Omega} \\frac{d^3k'}{(2\\pi)^3} (-g) \\frac{\\Delta}{2E(k')}\n$$\n假设存在非平凡解（$\\Delta \\ne 0$），我们可以将两边同除以 $\\Delta$：\n$$\n1 = \\frac{g}{2} \\int_{|\\varepsilon(k')-\\mu| \\le \\Omega} \\frac{d^3k'}{(2\\pi)^3 E(k')}\n$$\n该积分在球坐标系中进行，其中体积元为 $d^3k' = 4\\pi (k')^2 dk'$。由于被积函数的各向同性，对角度的积分产生一个 $4\\pi$ 的因子。\n$$\n1 = \\frac{g}{2} \\int_{k_-}^{k_+} \\frac{4\\pi (k')^2 dk'}{(2\\pi)^3 \\sqrt{(\\varepsilon(k')-\\mu)^2 + \\Delta^2}}\n$$\n积分上下限 $k_-$ 和 $k_+$ 由能量窗条件 $|\\varepsilon(k) - \\mu| \\le \\Omega$ 决定，代入 $\\varepsilon(k) = k^2$ 和 $\\mu=k_F^2$ 后变为 $|k^2 - \\mu| \\le \\Omega$。这意味着 $\\mu - \\Omega \\le k^2 \\le \\mu + \\Omega$。因此我们有 $k_{-} = \\sqrt{\\max(\\mu-\\Omega, 0)}$ 和 $k_{+} = \\sqrt{\\mu+\\Omega}$。简化常数因子 $\\frac{g}{2} \\frac{4\\pi}{(2\\pi)^3} = \\frac{g}{4\\pi^2}$，我们得到关于能隙 $\\Delta$ 的标量非线性方程：\n$$\n1 = \\frac{g}{4\\pi^2} \\int_{k_{-}}^{k_{+}} \\frac{k^2 dk}{\\sqrt{(k^2-\\mu)^2 + \\Delta^2}}\n$$\n为了求解 $\\Delta$，我们寻找函数 $f(\\Delta)$ 的根：\n$$\nf(\\Delta) = 1 - \\frac{g}{4\\pi^2} \\int_{k_{-}}^{k_{+}} \\frac{k^2 dk}{\\sqrt{(k^2-\\mu)^2 + \\Delta^2}} = 0\n$$\n对于 $\\Delta > 0$，积分项是 $\\Delta$ 的单调递减函数。因此，$f(\\Delta)$ 是一个单调递增函数。对于足够大的耦合 $g$，$f(\\Delta \\to 0^+) < 0$ 且 $f(\\Delta \\to \\infty) = 1 > 0$，这保证了 $\\Delta$ 存在唯一的正解，该解可以使用像 Brent 方法这样的区间套定求根算法找到。\n\n数值任务的核心是近似积分 $I(\\Delta) = \\int_{k_{-}}^{k_{+}} F(k, \\Delta) dk$，其中被积函数为 $F(k, \\Delta) = \\frac{k^2}{\\sqrt{(k^2-\\mu)^2 + \\Delta^2}}$。问题指定了三种求积方法。\n\n1.  **Gauss–Legendre (GL) 求积法**：通过使用线性映射 $k(x) = \\frac{k_{+}-k_{-}}{2}x + \\frac{k_{+}+k_{-}}{2}$（雅可比行列式为 $dk = \\frac{k_{+}-k_{-}}{2}dx$），将 $[k_{-}, k_{+}]$ 上的积分变换到标准区间 $[-1, 1]$ 上。该积分由以下求和近似：\n    $$\n    I_{GL}(\\Delta) \\approx \\frac{k_{+}-k_{-}}{2} \\sum_{i=1}^{N_{GL}} w_i F(k(x_i), \\Delta)\n    $$\n    其中 $\\{x_i, w_i\\}$ 是 $[-1, 1]$ 上的 $N_{GL}$ 点 Gauss-Legendre 节点和权重。\n\n2.  **第一类 Gauss–Chebyshev (GC) 求积法**：此方法用于近似形如 $\\int_{-1}^{1} \\frac{h(x)}{\\sqrt{1-x^2}}dx$ 的积分。为了近似无权积分 $I(\\Delta)$，我们再次使用线性映射 $k(x)$ 并将积分重写为：\n    $$\n    I(\\Delta) = \\int_{k_{-}}^{k_{+}} F(k) dk = \\int_{-1}^{1} \\left( F(k(x)) \\frac{k_{+}-k_{-}}{2} \\sqrt{1-x^2} \\right) \\frac{dx}{\\sqrt{1-x^2}}\n    $$\n    括号中的项被识别为 $h(x)$。使用节点 $x_i$ 和常数权重 $w_i = \\pi/N_{GC}$ 的 GC 求积近似为：\n    $$\n    I_{GC}(\\Delta) \\approx \\sum_{i=1}^{N_{GC}} w_i h(x_i) = \\frac{\\pi}{N_{GC}}\\frac{k_{+}-k_{-}}{2} \\sum_{i=1}^{N_{GC}} F(k(x_i), \\Delta) \\sqrt{1-x_i^2}\n    $$\n    其中 $x_i = \\cos(\\frac{2i-1}{2N_{GC}}\\pi)$ 是 Chebyshev 多项式 $T_{N_{GC}}(x)$ 的根。\n\n3.  **Stieltjes 型 (S) 求积法**：此方法针对被积函数在费米面（$k=k_F$）附近的行为进行了优化。积分被分割为：$I(\\Delta) = \\int_{k_{-}}^{k_F} F(k, \\Delta) dk + \\int_{k_F}^{k_+} F(k, \\Delta) dk$。\n    - 对于第一个子区间 $[k_{-}, k_{F}]$，应用变量替换 $k(u) = k_{-} + (k_{F}-k_{-})u^2$（其中 $u \\in [0, 1]$）。雅可比行列式为 $dk = 2(k_F - k_{-})u \\, du$。\n    - 对于第二个子区间 $[k_{F}, k_{+}]$，映射为 $k(u) = k_{F} + (k_{+}-k_{F})u^2$（其中 $u \\in [0, 1]$），雅可比行列式为 $dk = 2(k_+ - k_{F})u \\, du$。\n    每个在 $[0,1]$ 区间上关于 $u$ 的积分都使用 Gauss-Legendre 求积法计算，每个子区间分配总节点数的一半（$N_S/2$）。这需要将 GL 节点从 $[-1,1]$ 映射到 $[0,1]$。\n\n通过求解相同的方程 $f(\\Delta)=0$ 来计算高精度参考解 $\\Delta_{\\text{ref}}$，但积分的计算使用了一个稳健的自适应求积例程（`scipy.integrate.quad`）。然后，计算三种指定方法相对于此参考值的绝对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\nfrom scipy import optimize\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the BCS gap equation for three test cases using different quadrature\n    rules and reports the absolute errors against a high-accuracy reference.\n    \"\"\"\n    test_cases = [\n        # (kF, Omega, g, N_GL, N_GC, N_S)\n        (1.33, 0.50, 15.0, 64, 64, 64),\n        (1.33, 0.10, 10.0, 64, 64, 64),\n        (1.33, 1.00, 40.0, 32, 32, 32),\n    ]\n\n    all_results = []\n    \n    # Bracketing interval for the root finder\n    DELTA_MIN = 1e-12 \n\n    for case in test_cases:\n        kF, Omega, g, N_GL, N_GC, N_S = case\n        \n        # Physical parameters\n        mu = kF**2\n        k_minus = np.sqrt(np.maximum(mu - Omega, 0.0))\n        k_plus = np.sqrt(mu + Omega)\n        \n        DELTA_MAX = 2 * g  # A safe upper bound for the gap\n\n        # Integrand of the gap equation\n        def integrand(k, mu_val, delta_val):\n            # Add a small epsilon to denominator to handle delta=0 case if needed,\n            # though solver stays in delta > 0 domain.\n            denom = np.sqrt((k**2 - mu_val)**2 + delta_val**2)\n            return (k**2) / denom\n\n        # --- Quadrature Implementations ---\n\n        def integrate_gl(delta, N):\n            nodes, weights = special.roots_legendre(N)\n            # Map nodes from [-1, 1] to [k_minus, k_plus]\n            k_nodes = 0.5 * (k_plus - k_minus) * nodes + 0.5 * (k_plus + k_minus)\n            f_vals = integrand(k_nodes, mu, delta)\n            integral = 0.5 * (k_plus - k_minus) * np.dot(weights, f_vals)\n            return integral\n\n        def integrate_gc(delta, N):\n            nodes, _ = special.roots_chebyt(N) # Weights are all pi/N\n            weights = np.full(N, np.pi / N)\n            # Map nodes from [-1, 1] to [k_minus, k_plus]\n            k_nodes = 0.5 * (k_plus - k_minus) * nodes + 0.5 * (k_plus + k_minus)\n            h_vals = integrand(k_nodes, mu, delta) * np.sqrt(1 - nodes**2)\n            integral = 0.5 * (k_plus - k_minus) * np.dot(weights, h_vals)\n            return integral\n\n        def integrate_s(delta, N):\n            if N % 2 != 0:\n                raise ValueError(\"N_S must be an even number.\")\n            N_sub = N // 2\n            \n            nodes_v, weights_w = special.roots_legendre(N_sub)\n            # Map nodes from [-1, 1] to [0, 1] for variable u\n            u_nodes = 0.5 * (nodes_v + 1.0)\n            \n            # Sub-integral 1: [k_minus, kF]\n            # k(u) = k_minus + (kF - k_minus) * u^2\n            # dk = 2 * (kF - k_minus) * u * du\n            k1_nodes = k_minus + (kF - k_minus) * u_nodes**2\n            integrand1_vals = integrand(k1_nodes, mu, delta)\n            G1_vals = integrand1_vals * 2.0 * (kF - k_minus) * u_nodes\n            # The integral over u is on [0,1], map from GL on [-1,1] adds factor 0.5\n            integral1 = 0.5 * np.dot(weights_w, G1_vals)\n\n            # Sub-integral 2: [kF, k_plus]\n            # k(u) = kF + (k_plus - kF) * u^2\n            # dk = 2 * (k_plus - kF) * u * du\n            k2_nodes = kF + (k_plus - kF) * u_nodes**2\n            integrand2_vals = integrand(k2_nodes, mu, delta)\n            G2_vals = integrand2_vals * 2.0 * (k_plus - kF) * u_nodes\n            integral2 = 0.5 * np.dot(weights_w, G2_vals)\n\n            return integral1 + integral2\n            \n        def integrate_ref(delta):\n            # High-precision adaptive quadrature\n            result, _ = integrate.quad(integrand, k_minus, k_plus, args=(mu, delta))\n            return result\n\n        # --- Nonlinear Solver ---\n\n        def solve_gap_equation(integrator_func, N_nodes=None):\n            def f_gap(delta):\n                if N_nodes:\n                    integral_val = integrator_func(delta, N_nodes)\n                else:\n                    integral_val = integrator_func(delta)\n                return 1.0 - (g / (4.0 * np.pi**2)) * integral_val\n\n            # Use Brent's method for robust root finding\n            try:\n                solution = optimize.brentq(f_gap, DELTA_MIN, DELTA_MAX)\n            except ValueError:\n                # This can happen if f(a) and f(b) don't have opposite signs\n                # which can indicate no solution in the bracket or poor bracket choice.\n                # For this problem's parameters, a solution should exist.\n                # For robustness, expand bracket if it fails.\n                solution = optimize.brentq(f_gap, DELTA_MIN, DELTA_MAX * 5)\n\n            return solution\n\n        # --- Calculations ---\n        \n        delta_ref = solve_gap_equation(integrate_ref)\n        delta_gl = solve_gap_equation(integrate_gl, N_GL)\n        delta_gc = solve_gap_equation(integrate_gc, N_GC)\n        delta_s = solve_gap_equation(integrate_s, N_S)\n        \n        err_gl = abs(delta_gl - delta_ref)\n        err_gc = abs(delta_gc - delta_ref)\n        err_s = abs(delta_s - delta_ref)\n        \n        all_results.append([err_gl, err_gc, err_s])\n\n    # Final print statement in the exact required format.\n    # The output format requires a list of lists.\n    formatted_results = [f\"[{e_gl},{e_gc},{e_s}]\" for e_gl, e_gc, e_s in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将引导你探索现代物理学中的一个深刻概念：重整化。你将学习如何处理理想化的“接触”相互作用所引起的紫外发散，方法是将裸耦合常数与一个物理可观测量（散射长度）联系起来。通过求解这个使用重整化后相互作用的能隙方程 ，你将通过计算验证一个重要物理原理：像配对能隙这样的物理结果，不应该依赖于计算中引入的人为截断。",
            "id": "3594665",
            "problem": "要求您在零温 Bardeen–Cooper–Schrieffer (BCS) 理论中，对均匀费米系统中的三维零程（接触）相互作用，使用动量截断方法，实现并验证其重整化。仅在自然单位制下进行计算，其中 $\\hbar = 1$ 且 $2m = 1$，这意味着 $\\varepsilon_k = k^2$，并且所有量都是无量纲的。在此设定下，动量以长度的倒数度量，能量以动量的平方度量，s波散射长度 $a_s$ 的单位是长度。核心目标是根据目标散射长度拟合裸耦合常数，然后证明在费米动量处的BCS能隙与动量截断无关。\n\n基本依据与定义：\n- 接触相互作用定义为 $V = -g$，其中 $g$ 是一个待由重整化确定的正常数。\n- 在两体问题部分，零能壳上 $T$ 矩阵与散射长度 $a_s$ 相关，当施加锐利动量截断 $k \\leq \\Lambda$ 时，必须用它来将依赖于截断的裸耦合常数拟合到目标 $a_s$。推导必须从 Lippmann–Schwinger 方程和零能散射振幅定义开始；不要使用任何快捷公式。\n- 在零温多体问题部分，均匀各向同性s波 Bardeen–Cooper–Schrieffer (BCS) 能隙满足一个带有锐利动量截断 $k \\leq \\Lambda$ 的自洽积分方程。准粒子能量为 $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$，其中 $\\varepsilon_k = k^2$。化学势 $\\mu$ 必须设置为等于自由费米能量 $\\varepsilon_F = k_F^2$，这适用于弱耦合费米系统。对于s波通道中的接触相互作用，能隙参数 $\\Delta$ 与动量无关。能隙方程包含三维空间中的态密度因子。\n\n任务：\n1) 从零能量下带有锐利动量截断 $k \\leq \\Lambda$ 的零程相互作用的 Lippmann–Schwinger 方程出发，推导出在所选单位制下，用目标散射长度 $a_s$ 表示依赖于截断的裸耦合常数 $g(\\Lambda)$ 的关系式。\n2) 使用针对具有锐利截断 $k \\leq \\Lambda$ 的接触相互作用的零温 Bardeen–Cooper–Schrieffer (BCS) 能隙方程，实现一个在固定费米动量 $k_F$ 和 $\\mu = k_F^2$ 条件下求解 $\\Delta$ 的数值求解器。\n3) 对于下面的每个测试用例，使用从步骤1中得到的 $g(\\Lambda)$，为每个列出的截断 $\\Lambda$ 计算能隙 $\\Delta$，然后验证这组 $\\Delta$ 值在指定容差内相对于 $\\Lambda$ 是不变的。此处的不变性意味着与平均能隙的最大相对偏差 $\\max_i \\left|\\Delta_i - \\overline{\\Delta}\\right|/\\overline{\\Delta}$ 小于或等于给定的容差。\n\n数值与实现要求：\n- 所有计算必须在上述指定的单位制下进行，在本问题陈述中这些单位是无量纲的。\n- Bardeen–Cooper–Schrieffer (BCS) 能隙方程中的动量积分必须以足够的数值精度计算。当 $\\Delta$ 很小时，要特别注意被积函数在 $k = k_F$ 附近的可积峰。\n- 能隙的求根过程必须能稳健地确定区间并收敛到 $\\Delta > 0$。\n- 不允许外部输入。所有参数均在下方给出，并且必须硬编码。\n\n测试套件：\n对于每个测试用例，给定 $(k_F, a_s, [\\Lambda\\ \\text{值}], \\text{容差})$。按所列顺序为每个 $\\Lambda$ 计算能隙 $\\Delta$，然后使用该容差计算如上所述的不变性布尔值。\n\n- 测试用例1（正常路径）：$k_F = 1.0$，$a_s = -0.5$，$\\Lambda \\in \\{2.0, 3.0, 4.0\\}$，容差 $= 0.05$。\n- 测试用例2（边界情况，低截断）：$k_F = 0.75$，$a_s = -1.0$，$\\Lambda \\in \\{1.5, 2.0, 3.0\\}$，容差 $= 0.08$。\n- 测试用例3（边缘情况，大截断和弱耦合）：$k_F = 1.25$，$a_s = -0.3$，$\\Lambda \\in \\{3.0, 6.0, 9.0\\}$，容差 $= 0.06$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序串联每个测试用例的结果：按照提供的 $\\Lambda$ 值的顺序排列的三个计算出的能隙（作为浮点数），后跟一个表示不变性是否在给定容差内成立的布尔值。因此，最终输出必须严格包含以下顺序的12个条目：\n$[\\Delta^{(1)}(\\Lambda_1), \\Delta^{(1)}(\\Lambda_2), \\Delta^{(1)}(\\Lambda_3), \\text{invariant}^{(1)}, \\Delta^{(2)}(\\Lambda_1), \\Delta^{(2)}(\\Lambda_2), \\Delta^{(2)}(\\Lambda_3), \\text{invariant}^{(2)}, \\Delta^{(3)}(\\Lambda_1), \\Delta^{(3)}(\\Lambda_2), \\Delta^{(3)}(\\Lambda_3), \\text{invariant}^{(3)}]$.",
            "solution": "该问题经评估具有科学依据、适定、客观且内部一致。它提出了计算多体物理学中的一个标准但非平凡的任务：接触相互作用的重整化及其在 Bardeen–Cooper–Schrieffer (BCS) 能隙方程中的应用。所提供的参数和条件在物理上是合理的，在数学上是严谨的。因此，有必要提供一个完整的解法。\n\n解法分三部分呈现：首先，推导正则化的耦合常数 $g(\\Lambda)$；其次，推导待求解的 BCS 能隙方程；第三，求解此方程并验证所需截断无关性的数值策略。\n\n**1. 耦合常数的重整化**\n\n裸耦合常数 $g$ 与物理s波散射长度 $a_s$ 之间的关系通过两体散射问题建立。我们从质心系中的 $T$ 矩阵的 Lippmann-Schwinger 方程开始：\n$$ T(E) = V + V G_0(E) T(E) $$\n其中 $V$ 是相互作用势，$G_0(E)$ 是自由两粒子传播子。对于零程接触相互作用，势矩阵元与动量无关，$\\langle \\mathbf{k}' | V | \\mathbf{k} \\rangle = -g$，对于吸引势，$g>0$。因此，$T$ 矩阵也与动量无关，记为 $T(E)$。Lippmann-Schwinger 方程变为关于 $T(E)$ 的代数方程：\n$$ \\frac{1}{T(E)} = -\\frac{1}{g} - \\int \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2\\varepsilon_q + i\\eta} $$\n在 $2m=1$ 和 $\\hbar=1$ 的指定单位制中，单粒子能量为 $\\varepsilon_q = q^2$。该积分是紫外发散的，并使用锐利动量截断 $\\Lambda$ 进行正则化：\n$$ \\frac{1}{T(E)} = -\\frac{1}{g(\\Lambda)} - \\int_{q \\le \\Lambda} \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2q^2 + i\\eta} $$\n散射长度 $a_s$ 与零能壳上 $T$ 矩阵相关。在低能物理中，一个与不支持束缚态的吸引势 ($a_s < 0$) 一致的标准约定，通过 $T_{phys} = \\frac{4\\pi \\hbar^2 a_s}{m}$ 将壳上 $T$ 矩阵与 $a_s$ 联系起来。在我们的单位制中，这得到 $T(E=0) = 8\\pi a_s$。将 $E=0$ 代入 $T(E)$ 的方程：\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} - \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{(2\\pi)^3} \\frac{1}{-2q^2} $$\n计算该积分：\n$$ \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{8\\pi^3} \\frac{1}{-2q^2} = -\\frac{1}{4\\pi^2} \\int_0^\\Lambda dq = -\\frac{\\Lambda}{4\\pi^2} $$\n将此结果代回得到：\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} + \\frac{\\Lambda}{4\\pi^2} $$\n求解依赖于截断的裸耦合常数 $1/g(\\Lambda)$：\n$$ \\frac{1}{g(\\Lambda)} = \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} $$\n对于给定的测试用例，$a_s < 0$，这确保了 $1/g(\\Lambda) > 0$，因此 $g(\\Lambda) > 0$，与 BCS 配对所需的吸引相互作用一致。\n\n**2. BCS 能隙方程**\n\n在零温下，由接触相互作用产生的、与动量无关的能隙 $\\Delta$ 的自洽 BCS 能隙方程为：\n$$ 1 = g(\\Lambda) \\sum_{\\mathbf{k}}' \\frac{1}{2E_k} $$\n其中求和遍及动量截断 $\\Lambda$ 以内的所有动量态，而 $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$ 是准粒子能量。我们被要求对化学势使用弱耦合近似，即 $\\mu \\approx \\varepsilon_F = k_F^2$。求和被转换为积分：\n$$ \\sum_{\\mathbf{k}}' \\to \\int_{k \\le \\Lambda} \\frac{d^3 k}{(2\\pi)^3} = \\int_0^\\Lambda \\frac{4\\pi k^2 dk}{(2\\pi)^3} = \\frac{1}{2\\pi^2} \\int_0^\\Lambda k^2 dk $$\n能隙方程变为：\n$$ 1 = g(\\Lambda) \\frac{1}{2\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{2\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n求解 $1/g(\\Lambda)$：\n$$ \\frac{1}{g(\\Lambda)} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n通过令两体问题和多体问题部分得到的两个 $1/g(\\Lambda)$ 表达式相等，我们获得了一个关于能隙 $\\Delta$ 的单一方程：\n$$ \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n两边乘以 $4\\pi^2$ 得到待求解 $\\Delta$ 的最终方程：\n$$ \\Lambda - \\frac{\\pi}{2a_s} = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n该方程将多体可观测量 $\\Delta$ 与两体可观测量 $a_s$ 以及费米动量 $k_F$ 联系起来，并通过截断 $\\Lambda$ 进行正则化。问题的核心是证明当 $\\Lambda \\gg k_F$ 时，此方程的解 $\\Delta$ 近似地与 $\\Lambda$ 无关。\n\n**3. 数值策略**\n\n寻找 $\\Delta$ 的问题现在是一个求根问题。我们定义一个函数 $H(\\Delta)$，使其根给出所需的能隙值：\n$$ H(\\Delta) = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} - \\Lambda + \\frac{\\pi}{2a_s} $$\n我们需要找到使 $H(\\Delta) = 0$ 的 $\\Delta > 0$。\n分析 $H(\\Delta)$ 的性质以指导数值方法的选择：\n- **单调性**：导数 $\\frac{\\partial H}{\\partial \\Delta} = -\\Delta \\int_0^\\Lambda \\frac{k^2 dk}{[(k^2 - k_F^2)^2 + \\Delta^2]^{3/2}}$ 对于 $\\Delta > 0$ 是严格为负的。因此，$H(\\Delta)$ 是 $\\Delta$ 的单调递减函数，这保证了如果存在根，则根是唯一的。\n- **渐近行为**：\n  - 当 $\\Delta \\to 0^+$ 时，积分在 $k=k_F$ 处对数发散，所以 $H(\\Delta \\to 0^+) \\to +\\infty$。\n  - 当 $\\Delta \\to \\infty$ 时，被积函数趋近于0，所以积分趋于0。因此，$H(\\Delta \\to \\infty) \\to -\\Lambda + \\frac{\\pi}{2a_s}$。由于在所有测试用例中 $a_s < 0$，该极限值总是负的。\n\n由于 $H(\\Delta)$ 在定义域 $\\Delta \\in (0, \\infty)$ 上是连续、单调的，并且从正值变为负值，因此必须存在一个唯一的正根 $\\Delta$。\n这种结构非常适合使用像 Brent-Dekker 方法这样的区间求根算法。数值实现过程如下：\n1. 对于每个测试用例 $(k_F, a_s, \\Lambda)$，如上定义函数 $H(\\Delta)$。\n2. $H(\\Delta)$ 中的积分使用一个稳健的求积程序 `scipy.integrate.quad` 进行数值计算。点 $k=k_F$ 是被积函数快速变化的区域，因此将其指定为积分器的关注点以提高精度。\n3. 使用 `scipy.optimize.root_scalar` 和 `brentq` 方法找到 $H(\\Delta)=0$ 的根，该方法对于有界的单调函数是高效且可靠的。基于渐近分析找到一个合适的区间，例如 $[\\delta_{min}, \\delta_{max}]$，其中 $\\delta_{min}$ 是一个很小的正数，$\\delta_{max}$ 与 $k_F^2$ 在同一量级。\n4. 对一个测试用例中的所有 $\\Lambda$ 值重复此过程，以获得一组能隙值 $\\{\\Delta_i\\}$。\n5. 通过计算与平均能隙的最大相对偏差 $\\max_i |\\Delta_i - \\overline{\\Delta}| / |\\overline{\\Delta}|$，并将其与指定的容差进行比较，来检查截断不变性。\n最终程序为每个测试用例实现此策略，并按要求格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the BCS gap equation for a series of test cases and verifies\n    the cutoff independence of the gap parameter.\n    \"\"\"\n    test_cases = [\n        {'kF': 1.0, 'a_s': -0.5, 'Lambdas': [2.0, 3.0, 4.0], 'tolerance': 0.05},\n        {'kF': 0.75, 'a_s': -1.0, 'Lambdas': [1.5, 2.0, 3.0], 'tolerance': 0.08},\n        {'kF': 1.25, 'a_s': -0.3, 'Lambdas': [3.0, 6.0, 9.0], 'tolerance': 0.06},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kF = case['kF']\n        a_s = case['a_s']\n        Lambdas = case['Lambdas']\n        tolerance = case['tolerance']\n\n        delta_values = []\n        for Lambda in Lambdas:\n            # -------------------------------------------------------------\n            # Define the function H(delta) whose root is the BCS gap.\n            # The equation to solve is H(delta) = 0, where:\n            # H(delta) = integral - (Lambda - pi / (2*a_s)) = 0\n            # -------------------------------------------------------------\n            target_integral_val = Lambda - np.pi / (2.0 * a_s)\n\n            def integrand(k, delta):\n                # The integrand of the gap equation.\n                denominator = np.sqrt((k**2 - kF**2)**2 + delta**2)\n                # Avoid division by zero if delta is exactly zero, although\n                # root finder will use small positive numbers.\n                if denominator == 0:\n                    return np.inf\n                return k**2 / denominator\n\n            def H(delta):\n                # The function to find the root of.\n                \n                # Specify points of interest for the integrator if they are\n                # inside the integration interval. The integrand is sharply\n                # peaked at k=kF.\n                integration_points = []\n                if 0  kF  Lambda:\n                    integration_points.append(kF)\n\n                # Use quad for numerical integration.\n                integral_val, _ = quad(\n                    integrand, 0, Lambda, args=(delta,), points=integration_points\n                )\n                \n                return integral_val - target_integral_val\n\n            # -------------------------------------------------------------\n            # Find the root of H(delta) using a bracketing method.\n            # -------------------------------------------------------------\n            # Based on asymptotic analysis, a root is guaranteed to exist\n            # for delta  0.\n            # Lower bound: a small positive number (delta - 0, H - +inf)\n            delta_min = 1e-8 * kF**2\n            # Upper bound: a value on the scale of the Fermi energy\n            # (delta - inf, H - -inf)\n            delta_max = 5.0 * kF**2\n\n            # Ensure the bracket is valid before calling the solver.\n            # This should not be an issue given the function's monotonic nature.\n            try:\n                if H(delta_max) > 0:\n                    # The chosen upper bound is too small, increase it.\n                    # This is unlikely but handled for robustness.\n                    delta_max *= 10\n            except (ValueError, OverflowError):\n                 delta_max *= 10\n                 \n            # Find the root using Brent's method.\n            sol = root_scalar(H, bracket=[delta_min, delta_max], method='brentq')\n            delta_values.append(sol.root)\n        \n        # -------------------------------------------------------------\n        # Verify the invariance of the calculated gap values.\n        # -------------------------------------------------------------\n        mean_delta = np.mean(delta_values)\n        if mean_delta == 0:\n            # This case is unlikely, but if it happens, deviation is 0.\n            max_rel_dev = 0.0\n        else:\n            deviations = np.abs(np.array(delta_values) - mean_delta)\n            max_rel_dev = np.max(deviations) / np.abs(mean_delta)\n        \n        is_invariant = max_rel_dev = tolerance\n\n        # Append the results for this test case to the final list.\n        results.extend(delta_values)\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format.\n    # Format: [d_11, d_12, d_13, inv_1, d_21, d_22, d_23, inv_2, ...]\n    formatted_results = []\n    for item in results:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(f\"{item:.10f}\") # Use sufficient precision\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}