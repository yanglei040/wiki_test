{
    "hands_on_practices": [
        {
            "introduction": "在有效场论中，一个核心原则是将物理现象按能量尺度分离。长程物理，如单光子交换，具有必须被保留的特定解析结构。此练习旨在通过一个简化的玻恩近似模型，探讨如何设计只作用于相互作用短程部分的调节子，从而检验不同调节方案对保留由色散关系决定的长程物理解析性质的影响。",
            "id": "3586286",
            "problem": "您将设计并测试一个在动量空间中用于两体核相互作用的正则化子，该正则化子需保留与长程单π介子交换相关的解析结构，特别是由动量转移色散关系中π介子极点所编码的左手割线。背景设定为动量空间中的低能非相对论性双核子散射。长程部分由单π介子交换 (OPE) 建模，短程部分由一个与动量无关的接触项建模。您的任务是实现两种正则化方案，并测试在用玻恩项近似散射 $T$ 矩阵时，正则化子的选择是否保留了由解析性和交叉对称性通过色散关系固定的 $t$-道中π介子极点的留数。\n\n基本原理：\n- 在非相对论性势散射中，散射振幅的主导玻恩项等于动量空间中的相互作用。在动量转移表示下，长程OPE势具有以下形式\n$$\nV_{\\pi}(q^2) \\equiv -\\frac{g^2}{q^2 + m_{\\pi}^2},\n$$\n其中 $q$ 是三维动量转移的大小，$m_{\\pi}$ 是π介子质量。这种 $t$-道结构对应于 $q^2 = - m_{\\pi}^2$（当 $t \\equiv -q^2$ 时，等效于 $t = m_{\\pi}^2$）处的一个单极点，并产生一个具有正谱密度（左手割线）的谱表示。\n- 色散关系约束意味着 $t$-道中π介子极点的留数由耦合常数 $g^2$ 固定，与短程细节无关，因为它源于单π介子交换。因此，任何保留长程部分解析性质的正则化子都不能修改这个留数。\n- Lippmann–Schwinger (LS) 方程定义了完整的 $T$ 矩阵，但在足够小的 $g$ 值下，其玻恩近似 $T \\approx V$ 为探测 $t$-道奇点结构提供了一个可控的方法。本问题限定在该主导近似下，以分离出长程解析约束。\n\n需实现的正则化子：\n- 在动量转移空间中定义未正则化的势\n$$\nV(q^2) = V_{\\pi}(q^2) + C_0,\n$$\n其中 $C_0$ 是一个短程接触相互作用。\n- 方案 A (朴素)：通过一个关于动量转移平方的光滑乘法函数来正则化整个势，\n$$\nR_{\\text{naive}}(q^2;\\Lambda,n) \\equiv \\exp\\!\\left[-\\left(\\frac{q^2}{\\Lambda^2}\\right)^n\\right],\n$$\n并设置 $V^{(A)}(q^2) \\equiv \\left(V_{\\pi}(q^2) + C_0\\right) R_{\\text{naive}}(q^2;\\Lambda,n)$。\n- 方案 B (仅短程，半局域)：仅用相同的函数正则化接触相互作用，保持 $V_{\\pi}$ 不变，\n$$\nV^{(B)}(q^2) \\equiv V_{\\pi}(q^2) + C_0 \\, R_{\\text{naive}}(q^2;\\Lambda,n).\n$$\n\n色散关系检验：\n- 玻恩 $T$ 矩阵的长程部分在 $q^2 = - m_{\\pi}^2$ 处有一个单极点。如果正则化子保留了OPE贡献的解析性质，其留数必须为 $-g^2$。对于给定方案 $S \\in \\{A,B\\}$，将 $t$-道中玻恩振幅的长程部分定义为\n$$\nT^{(S)}_{\\text{LR}}(q^2) \\equiv \\begin{cases}\n-\\dfrac{g^2}{q^2 + m_{\\pi}^2} \\, R_{\\text{naive}}(q^2;\\Lambda,n),  S = A \\\\ \\\\\n-\\dfrac{g^2}{q^2 + m_{\\pi}^2},  S = B\n\\end{cases}\n$$\n- 使用复极限数值估计π介子极点处的留数\n$$\n\\operatorname{Res}\\left[T^{(S)}_{\\text{LR}}, -m_{\\pi}^2\\right] \\equiv \\lim_{\\varepsilon \\to 0^+} \\left(q^2 + m_{\\pi}^2\\right) T^{(S)}_{\\text{LR}}(q^2) \\Big|_{q^2 = -m_{\\pi}^2 + i \\varepsilon}.\n$$\n- 如果数值计算出的留数与 $-g^2$ 的绝对偏差不大于指定的容差，则该方案通过色散关系约束检验。\n\n数值参数说明：\n- 在所有计算中使用 $m_{\\pi} = 138$ MeV，并设置 $g^2 = 1$（无量纲）和 $C_0 = 0$。所有动量和截断值都必须以兆电子伏特 (MeV) 为单位进行解释，$q^2$ 的单位为 $\\text{MeV}^2$。不需要其他物理单位。\n- 在整个计算中均使用 $n = 2$。为估计复极限，对在三个小的虚数偏移量 $\\varepsilon_k \\in \\{10^{-6} m_{\\pi}^2, 3 \\cdot 10^{-6} m_{\\pi}^2, 10^{-5} m_{\\pi}^2\\}$ 处计算的结果进行平均。\n- 留数检验使用 $\\tau = 10^{-6}$ 的绝对容差，即如果 $\\left|\\operatorname{Res} + g^2\\right| \\le \\tau$，则判定为通过。\n\n测试组：\n提供以下六个参数集 $(\\text{方案}, \\Lambda)$，其中 $n=2$ 保持不变：\n- 情况 1：朴素，$\\Lambda = 300$ MeV。\n- 情况 2：半局域，$\\Lambda = 300$ MeV。\n- 情况 3：朴素，$\\Lambda = 10000$ MeV。\n- 情况 4：半局域，$\\Lambda = 10000$ MeV。\n- 情况 5：朴素，$\\Lambda = 400$ MeV。\n- 情况 6：半局域，$\\Lambda = 400$ MeV。\n\n对于每种情况，计算一个布尔结果，指示在该方案下，玻恩 $T$ 矩阵的长程部分是否满足关于π介子极点留数的色散关系约束。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔整数列表，按上述六种情况的顺序列出结果，用 $1$ 表示通过，用 $0$ 表示失败。例如，输出可能看起来像“[1,0,1,1,0,1]”。",
            "solution": "该问题要求分析动量空间中一个简化的双核子势的两种不同正则化方案。核心任务是验证哪种方案保留了长程核力的一个基本解析性质，即与单π介子交换 (OPE) 相关的极点的留数。该测试在玻恩近似下进行，其中散射 $T$ 矩阵由势本身近似，$T \\approx V$。\n\n### 原理和理论框架\n\n在低能核物理中，两个核子之间的相互作用由一个有效势建模。该势由一个长程部分和一个短程部分组成，长程部分由最轻的介子（π介子）的交换主导，短程部分通过接触相互作用参数化所有未解决的高能物理过程。\n\n在动量转移表示下，长程OPE势由下式给出\n$$\nV_{\\pi}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2}\n$$\n其中 $q$ 是动量转移的大小，$m_{\\pi}$ 是π介子质量，$g$ 是π介子-核子耦合常数。该表达式的一个关键特征是其在复 $q^2$ 平面上的解析结构。它在 $q^2 = -m_{\\pi}^2$ 处有一个单极点。这个极点对应于单个π介子的 $t$-道交换，并导致分波散射振幅中所谓的左手割线，这是由因果性和幺正性等基本原理决定的特征，并被色散关系所描述。\n\n色散理论规定，该极点的留数由耦合常数 $g^2$ 和π介子质量 $m_{\\pi}$ 固定。任何物理上合理的模型都必须保留这种长程结构。在引入正则化来处理相互作用短程部分的发散时，正则化函数不能改变OPE势的解析性质。\n\n该问题要求我们根据这一原则测试两种正则化方案。总的未正则化势是OPE势和一个与动量无关的接触项 $C_0$ 的和：\n$$\nV(q^2) = V_{\\pi}(q^2) + C_0\n$$\n对于这个问题，我们被指示设置接触项强度 $C_0=0$。这简化了表达式，但并未使测试变得无意义，因为测试完全专注于OPE贡献在正则化下的情况。\n\n### 正则化方案与留数检验\n\n该检验涉及计算方案 $S$ 的玻恩 $T$ 矩阵长程部分 $T^{(S)}_{\\text{LR}}(q^2)$ 在π介子极点 $q^2 = -m_{\\pi}^2$ 处的留数。留数由以下极限定义：\n$$\n\\operatorname{Res}\\left[T^{(S)}_{\\text{LR}}, -m_{\\pi}^2\\right] = \\lim_{q^2 \\to -m_{\\pi}^2} \\left(q^2 + m_{\\pi}^2\\right) T^{(S)}_{\\text{LR}}(q^2)\n$$\n色散关系约束要求该留数恰好为 $-g^2$。我们将通过在 $q^2 = -m_{\\pi}^2 + i\\varepsilon$（其中 $\\varepsilon$ 为小的正数）处求值来数值估计此极限。问题指定正则化子指数 $n=2$，并提供物理参数 $m_{\\pi} = 138 \\, \\text{MeV}$、$g^2=1$ 和 $C_0=0$。\n\n正则化函数是动量转移平方的高斯函数：\n$$\nR_{\\text{naive}}(q^2;\\Lambda,n) = \\exp\\left[-\\left(\\frac{q^2}{\\Lambda^2}\\right)^n\\right]\n$$\n\n#### 方案A：朴素正则化\n\n在此方案中，整个势乘以正则化函数。因为我们设置了 $C_0=0$，正则化后的势为 $V^{(A)}(q^2) = V_{\\pi}(q^2) R_{\\text{naive}}(q^2;\\Lambda,n)$。玻恩振幅的长程部分被确定为：\n$$\nT^{(A)}_{\\text{LR}}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n)\n$$\n我们现在解析地计算留数：\n$$\n\\operatorname{Res}\\left[T^{(A)}_{\\text{LR}}, -m_{\\pi}^2\\right] = \\lim_{q^2 \\to -m_{\\pi}^2} (q^2 + m_{\\pi}^2) \\left( -\\frac{g^2}{q^2 + m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n) \\right)\n$$\n$$\n\\operatorname{Res}\\left[T^{(A)}_{\\text{LR}}, -m_{\\pi}^2\\right] = -g^2 \\lim_{q^2 \\to -m_{\\pi}^2} R_{\\text{naive}}(q^2;\\Lambda,n) = -g^2 R_{\\text{naive}}(-m_{\\pi}^2;\\Lambda,n)\n$$\n将 $q^2 = -m_{\\pi}^2$ 和 $n=2$ 代入正则化子：\n$$\nR_{\\text{naive}}(-m_{\\pi}^2;\\Lambda,2) = \\exp\\left[-\\left(\\frac{-m_{\\pi}^2}{\\Lambda^2}\\right)^2\\right] = \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right]\n$$\n因此，方案A的留数为：\n$$\n\\operatorname{Res}\\left[T^{(A)}_{\\text{LR}}, -m_{\\pi}^2\\right] = -g^2 \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right]\n$$\n对于任何有限的截断 $\\Lambda$，此结果不等于 $-g^2$。正则化子扭曲了OPE势的解析结构。与正确值的偏差为 $\\left| -g^2 \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right] + g^2 \\right| = g^2 \\left(1 - \\exp\\left[-\\frac{m_{\\pi}^4}{\\Lambda^4}\\right]\\right)$。该偏差仅在 $\\Lambda \\to \\infty$ 时趋于零。对于有限的 $\\Lambda$，此方案将无法通过测试，除非 $\\Lambda$ 足够大，以至于偏差小于容差 $\\tau = 10^{-6}$。\n\n#### 方案B：半局域正则化\n\n在此方案中，正则化子仅应用于短程接触项。正则化后的势为 $V^{(B)}(q^2) = V_{\\pi}(q^2) + C_0 R_{\\text{naive}}(q^2;\\Lambda,n)$。当 $C_0=0$ 时，这简化为 $V^{(B)}(q^2) = V_{\\pi}(q^2)$。因此，玻恩振幅的长程部分为：\n$$\nT^{(B)}_{\\text{LR}}(q^2) = -\\frac{g^2}{q^2 + m_{\\pi}^2}\n$$\n留数计算如下：\n$$\n\\operatorname{Res}\\left[T^{(B)}_{\\text{LR}}, -m_{\\pi}^2\\right] = \\lim_{q^2 \\to -m_{\\pi}^2} (q^2 + m_{\\pi}^2) \\left( -\\frac{g^2}{q^2 + m_{\\pi}^2} \\right) = -g^2\n$$\n留数恰好为 $-g^2$，与截断标度 $\\Lambda$ 无关。根据构造，该方案正确地保留了OPE势的解析结构。因此，它应该能通过任何 $\\Lambda$ 值的留数检验。\n\n### 数值实现与算法\n\n该算法将为六个指定情况中的每一个实施留数检验。\n\n1.  设置物理常数：$m_{\\pi} = 138$，$g^2 = 1$，$n = 2$，以及容差 $\\tau = 10^{-6}$。\n2.  定义用于数值极限的虚数偏移量集合：$\\varepsilon \\in \\{10^{-6} m_{\\pi}^2, 3 \\cdot 10^{-6} m_{\\pi}^2, 10^{-5} m_{\\pi}^2\\}$。\n3.  对于每个测试用例 $(\\text{方案}, \\Lambda)$：\n    a. 初始化一个空列表以存储三个留数估计值。\n    b. 对于偏移量集合中的每个 $\\varepsilon_k$：\n        i.  计算复数求值点 $q^2_{\\text{eval}} = -m_{\\pi}^2 + i\\varepsilon_k$。\n        ii. 计算留数估计值。在求值点，项 $(q^2 + m_{\\pi}^2)$ 变为 $i\\varepsilon_k$，与OPE势的分母相消。\n        iii. 对于方案 A，留数估计值为 $\\operatorname{Res}_k = -g^2 \\exp\\left[-\\left(\\frac{q^2_{\\text{eval}}}{\\Lambda^2}\\right)^n\\right]$。\n        iv. 对于方案 B，留数估计值就是 $\\operatorname{Res}_k = -g^2$。\n        v. 将 $\\operatorname{Res}_k$ 附加到列表中。\n    c. 计算三个留数估计值的平均值：$\\overline{\\operatorname{Res}} = \\frac{1}{3} \\sum_{k=1}^3 \\operatorname{Res}_k$。\n    d. 计算与期望值的绝对偏差：$\\Delta = \\left| \\overline{\\operatorname{Res}} + g^2 \\right|$。\n    e. 将偏差与容差 $\\tau$ 进行比较。如果 $\\Delta \\le \\tau$，则测试通过（结果为 $1$）。否则，测试失败（结果为 $0$）。\n4.  将所有六种情况的布尔结果（$1$ 或 $0$）收集到一个列表中，并按指定格式输出。\n\n此过程将从数值上证实我们的分析结果：方案 B 将始终通过，而方案 A 对于“硬”（低）截断将失败，仅在正则化子在极点处的影响变得可以忽略不计的“软”（非常高）截断下才能通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear physics regularization problem by testing two schemes\n    against a dispersion-relation constraint on the pion-pole residue.\n    \"\"\"\n\n    # Numerical specifications from the problem statement\n    m_pi = 138.0  # Pion mass in MeV\n    g_sq = 1.0    # Pion-nucleon coupling squared (dimensionless)\n    C_0 = 0.0     # Contact term strength (set to zero)\n    n = 2         # Regulator exponent\n    tau = 1.0e-6  # Absolute tolerance for the residue test\n\n    m_pi_sq = m_pi**2\n    \n    # Epsilon values for numerical limit estimation\n    epsilons = [1.0e-6 * m_pi_sq, 3.0e-6 * m_pi_sq, 1.0e-5 * m_pi_sq]\n\n    # Test suite from the problem statement\n    test_cases = [\n        ('naive', 300.0),   # Case 1\n        ('semi', 300.0),    # Case 2\n        ('naive', 10000.0), # Case 3\n        ('semi', 10000.0),  # Case 4\n        ('naive', 400.0),   # Case 5\n        ('semi', 400.0),    # Case 6\n    ]\n\n    results = []\n    \n    for scheme, Lambda in test_cases:\n        residue_estimates = []\n        \n        # The pole is at q^2 = -m_pi^2\n        pole_q2 = -m_pi_sq\n        \n        for eps in epsilons:\n            # Evaluate near the pole in the complex plane\n            q2_eval = pole_q2 + 1j * eps\n            \n            # The residue is lim_{q^2 -> pole} (q^2 - pole) * T(q^2).\n            # Numerically, this is ((pole + i*eps) - pole) * T(pole + i*eps)\n            # = i*eps * T(pole + i*eps).\n            # For T(q^2) = -g^2/(q^2+m_pi^2) * R(q^2), this simplifies to\n            # i*eps * (-g^2 / (i*eps)) * R(q^2_eval) = -g^2 * R(q^2_eval).\n            \n            residue_val = 0.0\n            if scheme == 'naive':\n                # Scheme A: Regulate the entire potential\n                # V_A = (V_pi + C0) * R. With C0=0, V_A = V_pi * R.\n                # The residue is modified by the regulator.\n                Lambda_sq = Lambda**2\n                regulator = np.exp(-((q2_eval / Lambda_sq)**n))\n                residue_val = -g_sq * regulator\n            \n            elif scheme == 'semi':\n                # Scheme B: Regulate only the contact term\n                # V_B = V_pi + C0 * R. With C0=0, V_B = V_pi.\n                # The residue is Unaffected.\n                residue_val = -g_sq\n            \n            residue_estimates.append(residue_val)\n            \n        # Average the results from the different epsilon values\n        avg_residue = np.mean(residue_estimates)\n        \n        # The expected residue is -g^2. Test if the numerical result is close enough.\n        # Test condition: |Res_numerical + g^2| = tau\n        deviation = np.abs(avg_residue + g_sq)\n        \n        if deviation = tau:\n            results.append(1)  # Pass\n        else:\n            results.append(0)  # Fail\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从基本原则转向完整的非微扰计算，本练习要求解一个包含可分离接触相互作用的Lippmann-Schwinger方程。您将通过数值方法实现重整化条件，即调整“裸”耦合常数$C(\\Lambda)$以精确再现一个物理可观测量（散射长度$a_{0}$）。这个过程将具体展示“跑动耦合常数”的概念，并让您熟悉求解散射方程和检验数值收敛性的核心计算技术。",
            "id": "3586306",
            "problem": "您的任务是设计、实现并测试一种两体$s$波Lippmann–Schwinger (LS) 方程的动量空间离散化方案。该方案需在使用尖锐紫外动量截断 $\\Lambda$ 和正则化的接触相互作用时保持重整化。您的程序必须计算一个重整化的低能可观测量，并分析当网格大小 $N$ 以及求积方法的族和阶数变化时数值的收敛情况。\n\n出发点是带有尖锐截断 $\\Lambda$ 的半离壳跃迁矩阵 $T(k',k;E)$ 的动量空间$s$波LS方程：\n$$\nT(k',k;E) = V(k',k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E),\n$$\n其中，$k$ 和 $k'$ 是相对动量，$E$ 是质心能量，$G_{0}(E,q) = (E - q^{2}/(2\\mu) + i0)^{-1}$ 是折合质量为 $\\mu$ 的自由预解算符。使用 $\\hbar = 1$ 的单位制，以使能量和动量在量纲上保持一致；下面要求的所有输出都是无量纲数（不需要物理单位）。\n\n考虑一个正则化的、可分离的接触相互作用，\n$$\nV(k',k) = C(\\Lambda) g(k') g(k),\\quad g(k) = \\exp\\big(- (k/\\Lambda)^{2} \\big),\n$$\n其中 $C(\\Lambda)$ 是一个通过重整化调整的、依赖于截断的低能常数。由于相互作用是可分离的，LS方程允许可分离形式的解 $T(k',k;E) = g(k') \\tau(E) g(k)$，其中约化振幅 $\\tau(E)$ 满足\n$$\n\\tau(E) = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)},\n\\quad\nI(E,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q).\n$$\n\n在零能量 $E=0$ 处，对于所选的LS归一化，我们施加$s$波在壳跃迁矩阵与散射长度 $a_{0}$ 之间的标准阈值关系，\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_{0}.\n$$\n通过可分离拟设 $T(0,0;0) = \\tau(0)$，这确定了 $\\tau(0)$ 的值。然后，重整化条件给出一个跑动耦合 $C(\\Lambda)$，使得低能可观测量 $a_{0}$ 在连续极限下被精确地再现。\n\n您的任务：\n\n1) 从LS方程和可分离拟设出发，推导在动量网格 $\\{q_{i}, w_{i}\\}_{i=1}^{N}$ 上的 $I(0,\\Lambda)$ 的离散近似。该网格旨在通过 $\\sum_{i=1}^{N} w_{i} f(q_{i})$ 来近似 $\\int_{0}^{\\Lambda} dq\\, f(q)$。明确证明当 $E=0$ 时，自由预解算符简化了被积函数，使得\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2},\n\\quad\nI_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i} g(q_{i})^{2}.\n$$\n然后，将离散约化振幅表示为\n$$\n\\tau_{N}(0) = \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)}.\n$$\n\n2) 使用阈值关系 $T(0,0;0) = - 2\\pi a_{0}/\\mu$ 和可分离形式，确定阈值处的 $\\tau(0)$，并用它来构建 $C(\\Lambda)$ 的重整化条件，\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda).\n$$\n对于调节因子 $g(k)=\\exp\\big(- (k/\\Lambda)^{2} \\big)$，将 $I(0,\\Lambda)$ 解析地计算为 $\\mu$ 和 $\\Lambda$ 的函数。使用此解析结果来获得能在连续极限下再现目标 $a_{0}$ 的 $C(\\Lambda)$。然后，必须在离散化方案中使用此 $C(\\Lambda)$ 来测试当 $N$ 和求积方法选择变化时，离散化是否保持重整化。\n\n3) 为动量积分 $q\\in[0,\\Lambda]$ 实现两种求积族：\n- 带有 $N$ 个点（包括端点）的均匀网格上的梯形法则（记为TRAP）。\n- 从 $[-1,1]$ 映射到 $[0,\\Lambda]$ 的 $N$ 阶高斯-勒让德（GL）求积。\n\n对于给定的 $(\\mu, a_{0}, \\Lambda, N, \\text{family})$，计算散射长度的离散估计值，\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0),\n$$\n以及绝对相对误差 $\\varepsilon = \\lvert (\\hat{a}_{0}^{(N,\\text{family})} - a_{0})/a_{0} \\rvert$。\n\n4) 设计您的程序，使其生成一行输出，该行输出以方括号括起来的逗号分隔列表形式，汇总了下面给出的测试套件的结果。对于所有计算，使用 $\\mu = 1.0$（无量纲），$\\hbar = 1$（无量纲），以及指定的 $g(k)$。所有输出都是没有单位的纯数字。\n\n测试套件：\n- 情况1（理想路径，GL的准确性）：$a_{0} = 5.0$，$\\Lambda = 6.0$，GL求积，$N = 16$。以浮点数形式输出绝对相对误差 $\\varepsilon$。\n- 情况2（相同参数，TRAP与GL的比较）：$a_{0} = 5.0$，$\\Lambda = 6.0$，TRAP求积，$N = 16$。输出 $\\varepsilon$。\n- 情况3（小截断，适中的$N$）：$a_{0} = 5.0$，$\\Lambda = 2.0$，GL求积，$N = 8$。输出 $\\varepsilon$。\n- 情况4（小截断，TRAP）：$a_{0} = 5.0$，$\\Lambda = 2.0$，TRAP求积，$N = 8$。输出 $\\varepsilon$。\n- 情况5（跨截断的重整化不变性）：$a_{0} = 5.0$，GL求积，$N = 24$，比较 $\\Lambda_{1} = 3.0$ 和 $\\Lambda_{2} = 9.0$ 的结果。以浮点数形式输出绝对差 $\\Delta = \\lvert \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{1}) - \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{2}) \\rvert$。\n- 情况6（边界情况，大截断，较小的散射长度）：$a_{0} = 0.5$，$\\Lambda = 20.0$，GL求积，$N = 64$。输出 $\\varepsilon$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，\"[r1,r2,r3,r4,r5,r6]\"），其中每个 $r_{i}$ 是上述相应情况指定的浮点数。不应打印任何额外的文本。",
            "solution": "用户提供的问题是计算核物理领域一个有效且适定的练习，特别关注Lippmann-Schwinger方程的数值解以及重整化原理。该问题具有科学依据，内部逻辑一致，并且需要应用量子散射理论和数值分析中的标准且不平凡的技术。我们将给出一个完整的、有理有据的解答。\n\n### 1. 阈值处离散Lippmann-Schwinger方程的推导\n\n出发点是带有紫外动量截断 $\\Lambda$ 的半离壳跃迁矩阵 $T(k',k;E)$ 的$s$波Lippmann-Schwinger (LS) 方程：\n$$\nT(k',k;E) = V(k',k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E)\n$$\n势 $V(k',k)$ 是一种正则化的、可分离的接触相互作用，形式为 $V(k',k) = C(\\Lambda) g(k') g(k)$，其中 $g(k) = \\exp(-(k/\\Lambda)^2)$。势的这种可分离形式意味着T矩阵也存在可分离解 $T(k',k;E) = g(k') \\tau(E) g(k)$。将 $V$ 和 $T$ 的可分离形式代入LS方程，得到：\n$$\ng(k') \\tau(E) g(k) = C(\\Lambda) g(k') g(k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} [C(\\Lambda) g(k') g(q)] G_{0}(E,q) [g(q) \\tau(E) g(k)]\n$$\n我们可以从所有项中消去公因子 $g(k')g(k)$（假设它们不为零），从而得到一个关于约化振幅 $\\tau(E)$ 的代数方程：\n$$\n\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) \\left[ \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q) \\right]\n$$\n将圈图积分 $I(E,\\Lambda)$ 定义为\n$$\nI(E,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q),\n$$\n$\\tau(E)$ 的方程变为 $\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) I(E,\\Lambda)$。求解 $\\tau(E)$：\n$$\n\\tau(E) (1 - C(\\Lambda)I(E,\\Lambda)) = C(\\Lambda) \\implies \\tau(E) = \\frac{C(\\Lambda)}{1 - C(\\Lambda)I(E,\\Lambda)} = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)}\n$$\n这就是问题描述中给出的表达式。\n\n对于任务1，我们必须在零能量 $E=0$ 处计算这个表达式。自由预解算符 $G_{0}(E,q) = (E - q^2/(2\\mu) + i0)^{-1}$ 简化为：\n$$\nG_{0}(0,q) = \\left( -\\frac{q^2}{2\\mu} \\right)^{-1} = -\\frac{2\\mu}{q^2}\n$$\n将此结果代入 $E=0$ 时的圈图积分 $I(E, \\Lambda)$ 的表达式中：\n$$\nI(0,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\left(-\\frac{2\\mu}{q^2}\\right) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2}\n$$\n这证实了 $I(0,\\Lambda)$ 所需的表达式。\n\n为了离散化这个积分，我们采用一个由一组动量网格点 $\\{q_i\\}_{i=1}^N$ 和相应权重 $\\{w_i\\}_{i=1}^N$ 定义的数值求积方案。该积分通过加权和来近似：\n$$\n\\int_{0}^{\\Lambda} dq\\, f(q) \\approx \\sum_{i=1}^{N} w_{i} f(q_{i})\n$$\n将此方法应用于我们对 $I(0,\\Lambda)$ 的表达式，我们得到其离散近似 $I_{N}(0,\\Lambda)$：\n$$\nI_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i}\\, g(q_{i})^{2}\n$$\n相应的离散约化振幅 $\\tau_N(0)$ 是通过在 $\\tau(E)$ 的公式中用其离散对应物 $I_N(0,\\Lambda)$ 替换连续积分 $I(0,\\Lambda)$ 而得到的：\n$$\n\\tau_{N}(0) = \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)}\n$$\n\n### 2. 重整化条件与解析计算\n\n任务2要求我们通过施加一个物理条件来确定依赖于截断的耦合常数 $C(\\Lambda)$。我们将理论锚定在再现一个已知的低能可观测量，即$s$波散射长度 $a_0$。在壳T矩阵在零能量处与 $a_0$ 之间的关系给出如下：\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_0\n$$\n使用我们的可分离T矩阵拟设，$T(k',k;E) = g(k')\\tau(E)g(k)$，在 $k=k'=E=0$ 处，我们有：\n$$\nT(0,0;0) = g(0) \\tau(0) g(0)\n$$\n对于调节因子 $g(k) = \\exp(-(k/\\Lambda)^2)$，我们有 $g(0)=\\exp(0)=1$。因此，$T(0,0;0) = \\tau(0)$。将两个在壳T矩阵的表达式相等，可以得到阈值处的约化振幅的物理值：\n$$\n\\tau(0) = -\\frac{2\\pi a_0}{\\mu}\n$$\n这作为我们的重整化条件。我们要求我们的连续理论能够精确再现 $\\tau(0)$ 的这个值。通过对 $\\tau(0)$ 的表达式求逆，我们得到对跑动耦合 $C(\\Lambda)$ 的条件：\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda) \\implies C(\\Lambda)^{-1} = \\frac{1}{\\tau(0)} + I(0,\\Lambda)\n$$\n代入 $\\tau(0) = -2\\pi a_0/\\mu$，我们得到：\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} + I(0,\\Lambda)\n$$\n为了获得 $C(\\Lambda)$ 的完全解析表达式，我们必须为特定的调节因子 $g(q)^2 = \\exp(-2(q/\\Lambda)^2)$ 计算积分 $I(0,\\Lambda)$：\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, e^{-2(q/\\Lambda)^2}\n$$\n我们进行变量替换。令 $u = \\sqrt{2} q/\\Lambda$，这意味着 $dq = (\\Lambda/\\sqrt{2}) du$。积分限从 $[0, \\Lambda]$ 变为 $[0, \\sqrt{2}]$。\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\sqrt{2}} e^{-u^2} \\frac{\\Lambda}{\\sqrt{2}} du = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\int_{0}^{\\sqrt{2}} e^{-u^2} du\n$$\n该积分与误差函数 $\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt$ 相关，因此 $\\int_0^x e^{-t^2} dt = \\frac{\\sqrt{\\pi}}{2}\\mathrm{erf}(x)$。\n$$\nI(0,\\Lambda) = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\left( \\frac{\\sqrt{\\pi}}{2} \\mathrm{erf}(\\sqrt{2}) \\right) = -\\frac{2\\mu\\Lambda}{\\sqrt{2\\pi}} \\mathrm{erf}(\\sqrt{2}) = -\\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\n最后，将这个解析结果代回到 $C(\\Lambda)^{-1}$ 的表达式中：\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} - \\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\n该表达式定义了在任何截断 $\\Lambda$ 下，为在连续理论中精确再现散射长度 $a_0$ 所需的耦合 $C(\\Lambda)$ 的值。在我们的离散计算中必须使用这个耦合来测试离散化是否保持了这一性质。\n\n### 3. 数值实现与求积方案\n\n目标是计算散射长度的数值估计值 $\\hat{a}_{0}^{(N,\\text{family})}$，并将其与目标值 $a_0$ 进行比较。估计的散射长度由离散约化振幅 $\\tau_N(0)$ 获得：\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0) = -\\frac{\\mu}{2\\pi} \\left( \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)} \\right)\n$$\n数值任务的核心是为两种不同的求积族计算离散圈图积分 $I_{N}(0, \\Lambda)$。\n\n- **均匀网格上的梯形法则 (TRAP)：**\n对于包含端点 $0$ 和 $\\Lambda$ 的 $N$ 个点的网格，步长为 $h = \\Lambda/(N-1)$。网格点为 $q_i = (i-1)h$，其中 $i=1, ..., N$。梯形法则将积分近似为权重为 $w_1 = h/2$，$w_N = h/2$ 且对于 $i=2, ..., N-1$ 有 $w_i = h$ 的和。\n\n- **高斯-勒让德 (GL) 求积：**\n此方法通常定义在区间 $[-1, 1]$ 上。我们使用线性变换将标准的GL节点 $x_i \\in [-1, 1]$ 和权重 $w_i^{\\text{GL}}$ 映射到动量区间 $q \\in [0, \\Lambda]$。\n变换为 $q(x) = \\frac{\\Lambda}{2}(x+1)$，其微分为 $dq = \\frac{\\Lambda}{2}dx$。积分变为：\n$$\n\\int_0^\\Lambda f(q) dq = \\int_{-1}^1 f\\left( \\frac{\\Lambda}{2}(x+1) \\right) \\frac{\\Lambda}{2} dx \\approx \\sum_{i=1}^N \\frac{\\Lambda}{2} w_i^{\\text{GL}} f\\left( \\frac{\\Lambda}{2}(x_i+1) \\right)\n$$\n因此，我们的动量网格的求积点和权重是：\n$$\nq_i = \\frac{\\Lambda}{2}(x_i+1), \\quad w_i = \\frac{\\Lambda}{2}w_i^{\\text{GL}}\n$$\n\n每个测试用例的总体算法如下：\n1.  给定参数 $(\\mu, a_{0}, \\Lambda, N, \\text{family})$，首先使用第2节中推导的公式计算逆耦合 $C(\\Lambda)^{-1}$ 的解析值。\n2.  为指定的族（TRAP或GL）、大小 $N$ 和范围 $[0, \\Lambda]$ 生成求积点 $\\{q_i\\}$ 和权重 $\\{w_i\\}$ 集合。\n3.  在网格上计算调节函数值 $g(q_i)^2 = \\exp(-2(q_i/\\Lambda)^2)$。\n4.  计算离散圈图积分 $I_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i} g(q_i)^2$。\n5.  计算离散约化振幅 $\\tau_N(0) = (C(\\Lambda)^{-1} - I_{N}(0,\\Lambda))^{-1}$。\n6.  计算估计的散射长度 $\\hat{a}_{0} = -\\mu/(2\\pi) \\tau_N(0)$。\n7.  最后，计算指定的输出度量：绝对相对误差 $\\varepsilon = \\lvert (\\hat{a}_{0} - a_{0})/a_{0} \\rvert$ 或两次计算之间的绝对差 $\\Delta$。\n\n此过程测试了给定的离散化方案（求积规则和网格大小）在多大程度上近似了连续极限，在连续极限中 $\\hat{a}_0$ 将完全等于 $a_0$。误差 $\\varepsilon$ 量化了数值近似的准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    Designs, implements, and tests a momentum-space discretization of the\n    two-body s-wave Lippmann–Schwinger equation.\n    \"\"\"\n\n    # --- Problem constants ---\n    MU = 1.0  # Reduced mass (dimensionless)\n\n    def get_quadrature(Lambda, N, family):\n        \"\"\"\n        Generates quadrature points and weights for the integral from 0 to Lambda.\n\n        Args:\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' for Gauss-Legendre, 'TRAP' for Trapezoidal).\n\n        Returns:\n            tuple: A tuple containing:\n                - q (np.ndarray): The momentum grid points.\n                - w (np.ndarray): The corresponding quadrature weights.\n        \"\"\"\n        if family == 'GL':\n            # Gauss-Legendre quadrature mapped from [-1, 1] to [0, Lambda]\n            x_gl, w_gl = np.polynomial.legendre.leggauss(N)\n            q = 0.5 * Lambda * (x_gl + 1.0)\n            w = 0.5 * Lambda * w_gl\n        elif family == 'TRAP':\n            # Trapezoidal rule on a uniform grid\n            if N  2:\n                if N == 1:\n                    return np.array([0.0]), np.array([Lambda])\n                else: # N=0\n                    return np.array([]), np.array([])\n            q = np.linspace(0.0, Lambda, N)\n            h = Lambda / (N - 1.0)\n            w = np.full(N, h)\n            w[0] = h / 2.0\n            w[-1] = h / 2.0\n        else:\n            raise ValueError(f\"Unknown quadrature family: {family}\")\n        return q, w\n\n    def compute_scattering_length(a0, Lambda, N, family):\n        \"\"\"\n        Computes the discrete estimate of the scattering length.\n\n        Args:\n            a0 (float): The target scattering length for renormalization.\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' or 'TRAP').\n\n        Returns:\n            float: The computed estimate of the scattering length, a0_hat.\n        \"\"\"\n        # Regulator function g(k)^2\n        g2 = lambda k: np.exp(-2.0 * (k / Lambda)**2)\n\n        # 1. Analytically determine the inverse coupling C(Lambda)^-1\n        # This is the renormalization condition.\n        # I(0, Lambda) = - (4*mu/pi) * integral(g(q)^2 dq, 0, Lambda)\n        # integral = (Lambda * sqrt(pi)) / (2*sqrt(2)) * erf(sqrt(2))\n        I_continuum = -MU * Lambda * np.sqrt(2.0 / np.pi) * erf(np.sqrt(2.0))\n        \n        # C(Lambda)^-1 = 1/tau(0) + I(0, Lambda), with tau(0) = -2*pi*a0/mu\n        C_inv = -MU / (2.0 * np.pi * a0) + I_continuum\n\n        # 2. Generate quadrature points and weights\n        q, w = get_quadrature(Lambda, N, family)\n\n        # 3. Compute the discrete loop integral I_N(0, Lambda)\n        integrand_vals = g2(q)\n        I_discrete = - (4.0 * MU / np.pi) * np.sum(w * integrand_vals)\n\n        # 4. Compute the discrete reduced amplitude tau_N_0\n        tau_N_0 = 1.0 / (C_inv - I_discrete)\n\n        # 5. Compute the estimated scattering length a0_hat\n        a0_hat = -MU / (2.0 * np.pi) * tau_N_0\n        \n        return a0_hat\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: a0=5.0, Lambda=6.0, GL, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'GL', 'type': 'error'},\n        # Case 2: a0=5.0, Lambda=6.0, TRAP, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'TRAP', 'type': 'error'},\n        # Case 3: a0=5.0, Lambda=2.0, GL, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'GL', 'type': 'error'},\n        # Case 4: a0=5.0, Lambda=2.0, TRAP, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'TRAP', 'type': 'error'},\n        # Case 5: a0=5.0, GL, N=24. Compare Lambda1=3.0 and Lambda2=9.0. Output abs diff.\n        {'a0': 5.0, 'N': 24, 'family': 'GL', 'Lambda1': 3.0, 'Lambda2': 9.0, 'type': 'diff'},\n        # Case 6: a0=0.5, Lambda=20.0, GL, N=64. Output epsilon.\n        {'a0': 0.5, 'Lambda': 20.0, 'N': 64, 'family': 'GL', 'type': 'error'},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'error':\n            a0 = case['a0']\n            a0_hat = compute_scattering_length(\n                a0=a0,\n                Lambda=case['Lambda'],\n                N=case['N'],\n                family=case['family']\n            )\n            error = np.abs((a0_hat - a0) / a0)\n            results.append(error)\n        \n        elif case['type'] == 'diff':\n            a0_hat1 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda1'],\n                N=case['N'],\n                family=case['family']\n            )\n            a0_hat2 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda2'],\n                N=case['N'],\n                family=case['family']\n            )\n            diff = np.abs(a0_hat1 - a0_hat2)\n            results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "核物理中的许多相互作用，特别是张量力，会导致奇异势。本练习将复杂度提升到更接近真实物理的场景，要求您处理这类奇异相互作用的非微扰重整化。通过引入K矩阵方法，您将学习如何将一个反常项（counterterm）拟合到一个参考数据点，然后利用此理论预测另一个物理可观测量，这体现了有效场论的预测能力。",
            "id": "3586377",
            "problem": "你需要通过将非耦合三重态 $P$-波 $\\,^{3}P_{0}$ 建模为一个吸引性长程张量诱导相互作用外加一个领头阶抵消项，来研究奇异张量通道中的非微扰重整化。采用自然单位制，其中 $\\hbar = 1$ 且 $2\\mu = 1$，因此两体质心系能量为 $E = k^2$，所有量均为无量纲。完全在动量空间和单个分波中进行计算。\n\n基本基础和模型：\n- 从单个通道中分波反应（K-）矩阵的 Lippmann–Schwinger 方程出发，\n$$\nK(p,p';E) \\;=\\; V(p,p') \\;+\\; \\frac{2}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{0}^{\\infty} dq\\, \\frac{q^2\\, V(p,q)\\, K(q,p';E)}{E - q^2}\\,,\n$$\n其中 $\\mathcal{P}$ 表示柯西主值。\n- 将 $\\,^{3}P_{0}$ 通道的正规化领头阶势建模为代表张量力的长程可分离项与一个领头阶 $P$-波抵消项之和，\n$$\nV(p,p';\\Lambda) \\;=\\; R_{\\Lambda}(p)\\, R_{\\Lambda}(p')\\left[\\,-\\,g\\, \\frac{p}{p^2+\\beta^2}\\, \\frac{p'}{{p'}^2+\\beta^2} \\;+\\; C(\\Lambda)\\, p\\,p' \\right]\\,,\n$$\n使用高斯型正规子\n$$\nR_{\\Lambda}(p) \\;=\\; \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right].\n$$\n此处 $g  0$ 是长程部分的固定耦合，$ \\beta  0$ 设定了一个有限程标度，$C(\\Lambda)$ 是一个跑动抵消项，需在每个截断 $\\Lambda$ 下进行拟合。\n\n可观测量与重整化方案：\n- 将在壳反应矩阵元定义为 $P$-波中的 $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$。你将通过以下非微扰重整化方案评估正规子无关性：\n  1. 对于给定的 $\\Lambda$，通过对数据点\n     $$\n     K_1(k_{\\mathrm{ref}};\\Lambda) \\;=\\; K_{\\mathrm{ref}},\n     $$\n     在下文指定的参考动量 $k_{\\mathrm{ref}}$ 和目标值 $K_{\\mathrm{ref}}$ 处进行重新拟合，来确定 $C(\\Lambda)$。\n  2. 在已拟合的 $C(\\Lambda)$ 固定的情况下，预测在测试动量 $k_{\\mathrm{test}}$ 处的 $K_1(k_{\\mathrm{test}};\\Lambda)$。\n  3. 比较当 $\\Lambda$ 变化时 $K_1(k_{\\mathrm{test}};\\Lambda)$ 的预测值。重新拟合后的正规子无关性对应于这些值在 $\\Lambda$ 增加时趋于一个共同的极限。\n\n计算要求：\n- 通过在 $q = k$ 处分割积分域，并排除奇点周围的一个无穷小邻域，来数值处理主值积分。将积分上限截断为一个有限的 $Q_{\\max}$（由正规子证明其合理性），并确保数值收敛。\n- 你不能使用微扰理论；必须非微扰地求解该积分方程。如果你能从第一性原理推导，可以利用模型势的可分离性将积分方程简化为一个有限维代数系统。\n\n参数值和单位：\n- 使用 $g = 5.0$ 和 $\\beta = 1.0$。\n- 使用 $k_{\\mathrm{ref}} = 1.0$ 和 $K_{\\mathrm{ref}} = -0.4$。\n- 使用 $k_{\\mathrm{test}} = 1.5$。\n- 由于选择了 $\\hbar = 1$ 和 $2\\mu = 1$，所有量都是无量纲的。\n\n测试组：\n- 对以下截断值，评估 $K_1(k_{\\mathrm{test}};\\Lambda)$ 的预测值：\n  - 边缘情况的小截断：$\\Lambda = 2.0$。\n  - 中等截断：$\\Lambda = 4.0$。\n  - 大截断：$\\Lambda = 8.0$。\n  - 非常大的截断：$\\Lambda = 16.0$。\n- 另外，作为边界敏感性探针，加入 $\\Lambda = 1.5$。\n\n最终输出规格：\n- 对于列表 $[\\;1.5,\\;2.0,\\;4.0,\\;8.0,\\;16.0\\;]$ 中的每个 $\\Lambda$，你的程序必须在将 $C(\\Lambda)$ 在 $k_{\\mathrm{ref}}$ 处重新拟合到数据点 $K_{\\mathrm{ref}}$ 后，计算 $K_1(k_{\\mathrm{test}};\\Lambda)$ 的值。\n- 程序必须输出一行，其中包含这五个结果，形式为方括号内以逗号分隔的列表，顺序与上述 $\\Lambda$ 的顺序相同。每个数字必须是小数点后保留六位的小数。例如，\n$$\n[\\;x_1,\\;x_2,\\;x_3,\\;x_4,\\;x_5\\;]\n$$\n其中每个 $x_i$ 是一个小数点后恰好有六位数字的浮点数。",
            "solution": "该问题要求在存在奇异势的情况下，非微扰地求解分波反应矩阵 $K$ 的 Lippmann-Schwinger (LS) 方程。指定的重整化程序包括将一个抵消项拟合到参考能标下的单个数据点，然后预测在不同能标下的一个可观测量。该预测相对于正规子截断 $\\Lambda$ 的稳定性是衡量重整化是否成功的标准。\n\n首先，我们验证问题陈述。\n\n**步骤1：提取给定信息**\n- Lippmann-Schwinger 方程：$K(p,p';E) = V(p,p') + \\frac{2}{\\pi}\\,\\mathcal{P}\\int_{0}^{\\infty} dq\\, \\frac{q^2\\, V(p,q)\\, K(q,p';E)}{E - q^2}$。\n- 势模型：$V(p,p';\\Lambda) = R_{\\Lambda}(p)\\, R_{\\Lambda}(p')\\left[\\,-\\,g\\, \\frac{p}{p^2+\\beta^2}\\, \\frac{p'}{{p'}^2+\\beta^2} + C(\\Lambda)\\, p\\,p' \\right]$。\n- 正规子：$R_{\\Lambda}(p) = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right]$。\n- 单位与运动学：$\\hbar = 1$，$2\\mu = 1$，所以 $E = k^2$。\n- 可观测量：在壳反应矩阵元 $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$。\n- 重整化条件：$K_1(k_{\\mathrm{ref}};\\Lambda) = K_{\\mathrm{ref}}$。\n- 参数：$g = 5.0$，$\\beta = 1.0$，$k_{\\mathrm{ref}} = 1.0$，$K_{\\mathrm{ref}} = -0.4$，$k_{\\mathrm{test}} = 1.5$。\n- 测试组：$\\Lambda \\in \\{\\;1.5,\\;2.0,\\;4.0,\\;8.0,\\;16.0\\;\\}$。\n\n**步骤2：使用提取的给定信息进行验证**\n该问题具有科学依据，植根于标准的量子散射理论和有效场论原理。该势是一个秩为2的可分离势，这是一个常见且被充分理解的模型。LS 方程是该领域的一个基本方程。重整化方案是在截断框架下处理不可重整化相互作用的标准程序。所有参数和函数都已明确定义，使得问题自洽且适定。该任务是一个虽然不平凡但计算上可行的数值练习。没有矛盾、歧义或事实错误。\n\n**步骤3：结论与行动**\n问题有效。我们继续求解。\n\n非微扰求解该积分方程的关键在于利用势能 $V(p,p';\\Lambda)$ 的可分离性。我们可以将势能表示为矩阵形式：\n$$\nV(p,p';\\Lambda) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{G}(\\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\n其中 $\\mathbf{v}(p, \\Lambda)$ 是一个表示势能动量依赖部分的列向量，而 $\\mathbf{G}(\\Lambda)$ 是一个耦合常数矩阵。我们定义基向量为：\n$$\nv_1(p, \\Lambda) = R_{\\Lambda}(p) \\frac{p}{p^2+\\beta^2} \\quad \\text{和} \\quad v_2(p, \\Lambda) = R_{\\Lambda}(p) p\n$$\n使得 $\\mathbf{v}(p, \\Lambda) = \\begin{pmatrix} v_1(p, \\Lambda) \\\\ v_2(p, \\Lambda) \\end{pmatrix}$。耦合矩阵 $\\mathbf{G}(\\Lambda)$ 是对角的：\n$$\n\\mathbf{G}(\\Lambda) = \\begin{pmatrix} -g  0 \\\\ 0  C(\\Lambda) \\end{pmatrix}\n$$\n势的可分离形式意味着 K-矩阵 $K(p,p';E)$ 在同一基底下也是可分离的：\n$$\nK(p,p';E) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{M}(E, \\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\n其中 $\\mathbf{M}(E, \\Lambda)$ 是一个待定的 $2 \\times 2$ 矩阵。将此假设代入 LS 方程，得到一个关于 $\\mathbf{M}(E, \\Lambda)$ 的代数方程：\n$$\n\\mathbf{M}(E, \\Lambda) = \\mathbf{G}(\\Lambda) + \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\mathbf{M}(E, \\Lambda)\n$$\n这里，$\\mathbf{I}(E, \\Lambda)$ 是一个 $2 \\times 2$ 矩阵，其元素是主值积分：\n$$\nI_{ij}(E, \\Lambda) = \\frac{2}{\\pi} \\mathcal{P}\\!\\!\\int_0^\\infty dq\\, \\frac{q^2\\, v_i(q, \\Lambda)\\, v_j(q, \\Lambda)}{E-q^2}\n$$\n通过矩阵求逆解出 $\\mathbf{M}$ 的代数方程，得到非微扰解：\n$$\n\\mathbf{M}(E, \\Lambda) = \\left[ \\mathbf{1} - \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\right]^{-1} \\mathbf{G}(\\Lambda) \\equiv \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(E, \\Lambda) \\right]^{-1}\n$$\n我们关心的可观测量是在壳 K-矩阵元 $K_1(k; \\Lambda) = K(k,k;E=k^2)$:\n$$\nK_1(k; \\Lambda) = \\mathbf{v}(k, \\Lambda)^T \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) \\right]^{-1} \\mathbf{v}(k, \\Lambda)\n$$\n需要求逆的矩阵是：\n$$\n\\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) = \\begin{pmatrix} -1/g - I_{11}(k^2, \\Lambda)  -I_{12}(k^2, \\Lambda) \\\\ -I_{12}(k^2, \\Lambda)  1/C(\\Lambda) - I_{22}(k^2, \\Lambda) \\end{pmatrix}\n$$\n这里使用了对称性 $I_{12}=I_{21}$。求逆并随后乘以 $\\mathbf{v}(k, \\Lambda)$ 可以得到一个用积分 $I_{ij}$ 和抵消项 $C(\\Lambda)$ 表示的 $K_1(k; \\Lambda)$ 的封闭形式表达式。\n\n数值计算的挑战在于计算积分 $I_{ij}(E, \\Lambda)$。正规子 $R_\\Lambda(p)$ 确保积分收敛，因此我们可以在一个上限 $Q_{\\max}$ 处截断积分，在该处被积函数变得可以忽略不计（例如 $Q_{\\max} = 10\\Lambda$）。柯西主值使用减去法处理。令 $k=\\sqrt{E}$ 和 $F(q) = q^2 v_i(q) v_j(q)$。积分为：\n$$\n\\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} dq \\frac{F(q)}{k^2-q^2} = \\int_0^{Q_{\\max}} dq \\frac{F(q) - F(k)}{k^2-q^2} + F(k) \\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2}\n$$\n第一项的被积函数在 $q=k$ 处是正则的，可以用标准的数值求积法计算。第二项是解析的：\n$$\nF(k) \\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2} = F(k) \\frac{1}{2k} \\ln\\left|\\frac{Q_{\\max}+k}{Q_{\\max}-k}\\right|\n$$\n整体算法如下：\n1.  对于每个给定的截断 $\\Lambda$：\n    a. **拟合 $C(\\Lambda)$**：设置 $k = k_{\\mathrm{ref}} = 1.0$。计算必要的积分 $I_{ij}(k_{\\mathrm{ref}}^2, \\Lambda)$。将 $K_1(k_{\\mathrm{ref}}; \\Lambda)$ 的表达式（其对 $1/C(\\Lambda)$ 是线性的）反解，以求解满足 $K_1(k_{\\mathrm{ref}}; \\Lambda) = K_{\\mathrm{ref}} = -0.4$ 的 $C(\\Lambda)$ 值。\n    b. **预测 $K_1(k_{\\mathrm{test}})$**：设置 $k = k_{\\mathrm{test}} = 1.5$。计算积分 $I_{ij}(k_{\\mathrm{test}}^2, \\Lambda)$。使用上一步拟合得到的 $C(\\Lambda)$ 值，计算可观测量 $K_1(k_{\\mathrm{test}}; \\Lambda)$ 的预测值。\n2.  收集所有 $\\Lambda$ 的预测值，并按指定格式输出。\n此过程在以下 Python 代码中实现，使用 `numpy` 进行数组操作，使用 `scipy.integrate.quad` 进行数值积分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\n# Problem parameters are defined globally for clarity.\nG_COUPLING = 5.0\nBETA = 1.0\nK_REF = 1.0\nK_REF_VAL = -0.4\nK_TEST = 1.5\n\ndef regulator(p, cutoff_lambda):\n    \"\"\"Gaussian-type regulator function R_Lambda(p).\"\"\"\n    if cutoff_lambda = 0:\n        return 0.0\n    return np.exp(- (p / cutoff_lambda)**4)\n\ndef v1(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_1(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p / (p**2 + BETA**2)\n\ndef v2(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_2(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p\n\ndef principal_value_integral(F, k, q_max):\n    \"\"\"\n    Computes the Cauchy Principal Value of the integral of F(q)/(k^2-q^2)\n    from 0 to q_max using the subtraction method.\n    \"\"\"\n    if k = 0 or k >= q_max:\n        raise ValueError(\"Pole k must be in (0, q_max) for this PV method.\")\n\n    F_at_k = F(k)\n\n    def integrand_subtracted(q):\n        # This integrand has a removable singularity at q=k.\n        # scipy.integrate.quad can handle this robustly.\n        if np.isclose(q, k):\n            # A direct hit is highly unlikely. Let quad handle it.\n            # Providing a Taylor expansion limit could be faster but is not necessary.\n            return 0.0\n        return (F(q) - F_at_k) / (k**2 - q**2)\n\n    integral_part, _ = integrate.quad(integrand_subtracted, 0, q_max, limit=100)\n    log_part = F_at_k * (1.0 / (2.0 * k)) * np.log((q_max + k) / (q_max - k))\n    \n    return integral_part + log_part\n\ndef compute_integrals(k, cutoff_lambda):\n    \"\"\"\n    Computes the three unique elements of the integral matrix I(k^2).\n    \"\"\"\n    q_max = 10.0 * cutoff_lambda\n\n    # Define the functions F(q) = q^2 * v_i(q) * v_j(q) for each integral.\n    def F11(q): return q**2 * v1(q, cutoff_lambda)**2\n    def F12(q): return q**2 * v1(q, cutoff_lambda) * v2(q, cutoff_lambda)\n    def F22(q): return q**2 * v2(q, cutoff_lambda)**2\n\n    I11 = (2.0 / np.pi) * principal_value_integral(F11, k, q_max)\n    I12 = (2.0 / np.pi) * principal_value_integral(F12, k, q_max)\n    I22 = (2.0 / np.pi) * principal_value_integral(F22, k, q_max)\n\n    return I11, I12, I22\n\ndef solve():\n    \"\"\"\n    Main function to perform renormalization and prediction for each cutoff.\n    \"\"\"\n    cutoffs = [1.5, 2.0, 4.0, 8.0, 16.0]\n    results = []\n\n    for cutoff_lambda in cutoffs:\n        # --- Step 1: Fit C(Lambda) using the reference datum ---\n        # Calculate integrals at the reference momentum k_ref.\n        I11_ref, I12_ref, I22_ref = compute_integrals(K_REF, cutoff_lambda)\n\n        # Evaluate basis vectors at k_ref.\n        v1_ref = v1(K_REF, cutoff_lambda)\n        v2_ref = v2(K_REF, cutoff_lambda)\n\n        # Solve for 1/C(Lambda) algebraically from K1(k_ref) = K_REF_VAL\n        # K_ref = (D_ref*v1^2 - 2B_ref*v1v2 + A_ref*v2^2) / (A_ref*D_ref - B_ref^2)\n        # where A=-1/g-I11, B=-I12, D=1/C-I22.\n        # This is a linear equation for D_ref (and thus for 1/C).\n        A_ref = -1.0/G_COUPLING - I11_ref\n        B_ref = -I12_ref\n        \n        num_D = K_REF_VAL * B_ref**2 + (-2 * B_ref * v1_ref * v2_ref + A_ref * v2_ref**2)\n        den_D = K_REF_VAL * A_ref - v1_ref**2\n        \n        if np.isclose(den_D, 0):\n            raise RuntimeError(f\"Denominator for D_ref is zero at Lambda={cutoff_lambda}\")\n        \n        D_ref = num_D / den_D\n        one_over_C = D_ref + I22_ref\n        \n        # --- Step 2: Predict K1 at the test momentum k_test ---\n        # Calculate integrals at the test momentum k_test.\n        I11_test, I12_test, I22_test = compute_integrals(K_TEST, cutoff_lambda)\n        \n        # Evaluate basis vectors at k_test.\n        v1_test = v1(K_TEST, cutoff_lambda)\n        v2_test = v2(K_TEST, cutoff_lambda)\n        \n        # Calculate K1(k_test) using the fitted C(Lambda).\n        A = -1.0/G_COUPLING - I11_test\n        B = -I12_test\n        D = one_over_C - I22_test\n        \n        det = A * D - B**2\n        \n        if np.isclose(det, 0):\n            raise RuntimeError(f\"Matrix is singular at Lambda={cutoff_lambda}\")\n            \n        k1_predicted = (D * v1_test**2 - 2 * B * v1_test * v2_test + A * v2_test**2) / det\n        results.append(k1_predicted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}