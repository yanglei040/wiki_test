{
    "hands_on_practices": [
        {
            "introduction": "在进行复杂的计算物理研究之前，建立一个一致且可靠的单位框架至关重要。在核物理学中，研究人员通常在“自然单位制”和更为实用的“MeV-fm”单位制之间切换。\n\n本练习将从相空间计数的微观第一性原理出发，推导并巩固对核子数密度 $n$、费米动量 $k_F$ 和费米能 $E_F$ 之间基本关系的理解。\n\n通过编程实现并验证不同单位系统之间的转换，你将掌握一项防止计算错误的实用核心技能，并加深对这些核心概念背后量纲分析的理解 。",
            "id": "3599442",
            "problem": "实现一个程序，该程序对核物质的理想无相互作用费米气体模型，在自然单位制和混合的兆电子伏特-费米（MeV-fm）单位制之间的单位转换进行基准测试，并验证计算输出的量纲一致性。自然单位制的定义是将约化普朗克常数、光速和玻尔兹曼常数均设为1，即 $\\hbar=c=k_B=1$。混合的兆电子伏特-费米（MeV–fm）单位制用兆电子伏特（megaelectronvolts）表示能量和温度，用费米（femtometers）表示长度。您的程序必须使用以下给定的物理常数：约化普朗克常数乘以光速 $\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$，以及核子静止质量 $m_N = 939.56542052\\,\\mathrm{MeV}$。由于在自然单位制中 $k_B=1$，温度必须通过玻尔兹曼常数作为能量来处理，因此温度 $T$ 在两种单位制中均以 $\\mathrm{MeV}$ 为单位。\n\n从相空间计数和经典力学的基本原理出发：\n- 动量空间中的单粒子态数由相空间元尺寸为 $(2\\pi\\hbar)^3$ 和动量空间中球体的体积得出。\n- 零温下的费米动量 $k_F$ 定义为填充所有动量大小在 $k_F$ 以内的单粒子态。\n- 数密度 $n$ 是单位体积 $V$ 内的总粒子数。\n- 在非相对论动能极限下，单粒子动能为 $E = p^2/(2m_N)$，其中 $p$ 是动量。\n\n使用这些基本事实，推导、实现并使用所需的关系式，以完成以下任务：\n1. 从给定的费米动量 $k_F$ 和自旋-同位旋简并度 $g$ 计算数密度 $n$。\n2. 从给定的数密度 $n$ 和 $g$ 计算费米动量 $k_F$。\n3. 从 $k_F$ 和 $m_N$ 计算零温费米能 $E_F$。\n4. 从 $E_F$ 和 $m_N$ 计算 $k_F$。\n5. 对所有的 $n$、$k_F$、$E_F$ 和 $T$ 进行单位制转换。\n\n您的转换必须从单位的定义和常数 $\\hbar c$ 推导得出：\n- 在自然单位制中，动量、能量和温度都具有相同的量纲，长度的量纲是能量的倒数。因此，$k_F$ 的单位是 $\\mathrm{MeV}$，$E_F$ 的单位是 $\\mathrm{MeV}$，$T$ 的单位是 $\\mathrm{MeV}$，$n$ 的单位是 $\\mathrm{MeV}^3$。\n- 在 MeV–fm 单位制中，$k_F$ 的单位是 $\\mathrm{fm^{-1}}$，$E_F$ 的单位是 $\\mathrm{MeV}$，$T$ 的单位是 $\\mathrm{MeV}$，$n$ 的单位是 $\\mathrm{fm^{-3}}$。\n- 使用 $\\hbar c$ 在长度和能量之间进行转换：$1\\,\\mathrm{fm}^{-1}$ 对应于 $(\\hbar c)\\,\\mathrm{MeV}$，$1\\,\\mathrm{fm}^{-3}$ 对应于 $(\\mathrm{MeV}/\\hbar c)^3$。\n\n量纲一致性验证：\n- 对于每个测试用例，将为您提供一个单位制标志、$n$、$k_F$ 或 $E_F$ 中的一个已知主量、简并度 $g$ 以及以 $\\mathrm{MeV}$ 为单位的温度 $T$。\n- 仅使用上述基本原理，在测试用例的原生单位制中计算出完整的集合 $(n,k_F,E_F,T)$。\n- 将该集合转换到另一种单位制，然后再转换回原生单位制。将两个数 $x$ 和 $y$ 的相对差异定义为\n$$\n\\delta(x,y) \\equiv \\frac{|x-y|}{\\max(1,|x|,|y|)}.\n$$\n- 检查两个条件：(i) 连接 $n$ 和 $k_F$ 的费米气体关系式在原生单位制中成立；(ii) $n$、$k_F$、$E_F$ 和 $T$ 中每一个量的往返转换差异都低于容差 $\\epsilon = 10^{-12}$。当且仅当两个条件都满足时，测试用例才算通过。\n\n所有数值输出中使用的单位：数密度 $n$ 的单位为 $\\mathrm{fm^{-3}}$ 或 $\\mathrm{MeV^3}$，与所选系统一致；费米动量 $k_F$ 的单位为 $\\mathrm{fm^{-1}}$ 或 $\\mathrm{MeV}$，与所选系统一致；费米能 $E_F$ 在两种系统中单位均为 $\\mathrm{MeV}$；温度 $T$ 在两种系统中单位均为 $\\mathrm{MeV}$。\n\n测试套件：\n- 用例 1：单位制 MeV–fm，已知主量 $n = 0.16\\,\\mathrm{fm^{-3}}$，简并度 $g = 4$，温度 $T = 0\\,\\mathrm{MeV}$。\n- 用例 2：单位制 MeV–fm，已知主量 $k_F = 0.05\\,\\mathrm{fm^{-1}}$，简并度 $g = 2$，温度 $T = 5\\,\\mathrm{MeV}$。\n- 用例 3：单位制 自然单位制，已知主量 $k_F = 262.444883932\\,\\mathrm{MeV}$，简并度 $g = 4$，温度 $T = 15\\,\\mathrm{MeV}$。该值对应于 $1.33\\,\\mathrm{fm^{-1}}$ 乘以 $\\hbar c$。\n- 用例 4：单位制 自然单位制，已知主量 $E_F = 37\\,\\mathrm{MeV}$，简并度 $g = 4$，温度 $T = 1\\,\\mathrm{MeV}$。\n\n您的程序必须：\n- 硬编码上述物理常数和测试套件。\n- 对于每个测试用例，计算如上定义的通过或失败的布尔值。\n- 生成一行输出，其中包含四个布尔结果，以逗号分隔并用方括号括起来，例如 $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$。\n\n最终打印的输出必须是所描述格式的单行文本。",
            "solution": "该问题要求实现并验证核物质无相互作用费米气体模型的单位转换。任务涉及推导基本关系式，处理两种不同的单位制（自然单位制和 MeV-fm 单位制），并为一组测试用例执行往返转换基准测试。解决方案必须在科学上严谨且在算法上精确。\n\n### 第 1 部分：费米气体模型的理论框架\n\n我们首先从问题中陈述的原理推导出基本方程。该模型假设在零温或非零温下存在一种无相互作用的费米子（核子）气体。\n\n**1.1. 数密度和费米动量**\n\n在相空间体积元 $d^3r d^3p$ 内的单粒子态数为 $d^3r d^3p / (2\\pi\\hbar)^3$。对于空间体积为 $V$ 的均匀气体，动量大小不大于 $p$ 的态数通过对半径为 $p$ 的动量空间球进行积分得到：\n$$ N_{states}(p) = \\frac{V}{(2\\pi\\hbar)^3} \\int_0^p 4\\pi p'^2 dp' = \\frac{V \\cdot 4\\pi p^3}{3(2\\pi\\hbar)^3} = \\frac{V p^3}{6\\pi^2\\hbar^3} $$\n核子是费米子，具有自旋-同位旋简并因子 $g$。对于对称核物质（质子和中子数量相等，自旋向上和向下），$g=4$。对于纯中子物质，$g=2$。在零温（$T=0$）下，所有动量大小不大于费米动量 $p_F$ 的态都被填充。因此，总粒子数 $N$ 是动量大小不大于 $p_F$ 的态数的 $g$ 倍：\n$$ N = g \\cdot N_{states}(p_F) = \\frac{g V p_F^3}{6\\pi^2\\hbar^3} $$\n数密度 $n$ 定义为 $n = N/V$。通过代入 $p_F = \\hbar k_F$（其中 $k_F$ 是费米波矢，在此上下文中通常称为费米动量），我们得到数密度和费米动量之间的关系：\n$$ n = \\frac{g (\\hbar k_F)^3}{6\\pi^2\\hbar^3} = \\frac{g k_F^3}{6\\pi^2} $$\n只要 $n$ 和 $k_F$ 的单位是一致的，这个方程就成立，与单位制无关。反转此关系式，我们可以从给定的 $n$ 计算出 $k_F$：\n$$ k_F = \\left( \\frac{6\\pi^2 n}{g} \\right)^{1/3} $$\n\n**1.2. 费米能和费米动量**\n\n问题指定了质量为 $m_N$、动量为 $p$ 的核子的动能的非相对论近似：$E = p^2 / (2m_N)$。费米能 $E_F$ 是位于费米面上的核子的动能，即动量为 $p_F = \\hbar k_F$。\n$$ E_F = \\frac{p_F^2}{2m_N} = \\frac{(\\hbar k_F)^2}{2m_N} $$\n该关系式允许从 $k_F$ 计算 $E_F$。从 $E_F$ 求 $k_F$ 的逆关系式为：\n$$ k_F = \\frac{\\sqrt{2m_N E_F}}{\\hbar} $$\n温度 $T$ 以能量单位（MeV）给出，这与玻尔兹曼常数 $k_B=1$ 的自然单位制约定一致。\n\n### 第 2 部分：单位制和转换\n\n正确处理单位至关重要。问题定义了两个单位制和转换因子 $\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$。我们将此常数记为 $HC$。核子质量 $m_N$ 以 MeV 为单位给出，代表其静止能量 $m_N c^2 = 939.56542052\\,\\mathrm{MeV}$。\n\n**2.1. MeV–fm 单位制**\n这是一个适用于核物理计算的混合单位制。\n-   长度：费米 (fm)\n-   能量 / 温度：兆电子伏特 (MeV)\n-   数密度 $n$：$\\mathrm{fm^{-3}}$\n-   费米动量 $k_F$：$\\mathrm{fm^{-1}}$\n-   费米能 $E_F$：$\\mathrm{MeV}$\n\n在此系统中，$\\hbar$ 不为 1。$E_F$ 的公式必须显式地包含 $\\hbar$。为保持正确的量纲，我们用 $\\hbar c$ 来表示 $\\hbar$：$\\hbar = \\hbar c / c$。能量方程变为 $E_F = (\\hbar c)^2 k_F^2 / (2 m_N c^2)$。使用 $m_N$ 代表静止能量 $m_N c^2$，实用公式为：\n$$ E_F = \\frac{(HC)^2 k_F^2}{2 m_N} $$\n相应的逆关系式是：\n$$ k_F = \\frac{\\sqrt{2m_N E_F}}{HC} $$\n关系式 $n = g k_F^3 / (6\\pi^2)$ 仍然有效，因为其各分量在该系统内量纲一致。\n\n**2.2. 自然单位制**\n在此系统中，$\\hbar=c=k_B=1$。所有量（能量、质量、动量、长度的倒数）都用单一单位表示，我们选用 MeV。\n-   长度：$\\mathrm{MeV^{-1}}$\n-   能量 / 温度：$\\mathrm{MeV}$\n-   数密度 $n$：$\\mathrm{MeV^{3}}$\n-   费米动量 $k_F$：$\\mathrm{MeV}$\n-   费米能 $E_F$：$\\mathrm{MeV}$\n\n由于 $\\hbar=1$，关系式简化为：\n$$ n = \\frac{g k_F^3}{6\\pi^2} $$\n$$ E_F = \\frac{k_F^2}{2m_N} $$\n$$ k_F = \\sqrt{2m_N E_F} $$\n\n**2.3. 转换公式**\n常数 $HC$ 提供了桥梁：$1 = \\frac{HC}{\\mathrm{MeV \\cdot fm}}$，这意味着 $1\\,\\mathrm{fm}^{-1} = HC\\,\\mathrm{MeV}$。\n设 MeV-fm 单位制中的量以下标 $M$ 表示，自然单位制中的量以下标 $N$ 表示。\n\n-   **动量 ($k_F$)**：$k_{F, M} \\,[\\mathrm{fm}^{-1}]$ 变为 $k_{F, N} \\,[\\mathrm{MeV}]$。转换关系为 $k_{F, N} = k_{F, M} \\cdot HC$。\n-   **数密度 ($n$)**：$n_{M} \\,[\\mathrm{fm}^{-3}]$ 变为 $n_{N} \\,[\\mathrm{MeV^3}]$。由于 $1\\,\\mathrm{fm}^{-3} \\leftrightarrow (HC\\,\\mathrm{MeV})^3$，转换关系为 $n_N = n_M \\cdot (HC)^3$。\n-   **能量 ($E_F$) 和温度 ($T$)**：在两个系统中它们都以 MeV 为单位，因此不需要转换：$E_{F, N} = E_{F, M}$ 且 $T_N = T_M$。\n\n### 第 3 部分：验证算法\n\n对于每个测试用例，我们执行一系列计算来确定一个单一的布尔通过/失败结果。\n\n**3.1. 在原生单位制中计算**\n给定一个主量（$n$、$k_F$ 或 $E_F$），我们计算另外两个量，以在测试用例的原生单位制中建立一个完整的集合 $(n, k_F, E_F, T)$。根据单位制的不同，使用第 2.1 或 2.2 部分的公式。\n\n**3.2. 物理关系验证**\n问题要求检查计算出的集合是否满足费米气体关系。这可作为我们计算的自洽性检查。我们验证两个关系式：\n1.  $n$ 和 $k_F$ 之间的关系：我们计算一个检查值 $n_{check} = g k_F^3 / (6\\pi^2)$，并验证相对差异 $\\delta(n, n_{check})$ 小于容差 $\\epsilon = 10^{-12}$。\n2.  $E_F$ 和 $k_F$ 之间的关系：我们使用适用于该单位制的相应公式从 $k_F$ 计算 $E_{F, check}$，并验证 $\\delta(E_F, E_{F, check})  \\epsilon$。\n只有当两个检查都满足时，测试用例才通过此阶段。\n差异函数定义为：\n$$ \\delta(x,y) \\equiv \\frac{|x-y|}{\\max(1,|x|,|y|)} $$\n\n**3.3. 往返转换和差异检查**\n量集合 $(n, k_F, E_F, T)$ 从其原生系统转换到另一个系统，然后立即转换回来。理论上，这次往返应该能恢复原始值。浮点运算可能会引入微小误差。我们检查这些误差是否可以忽略不计。\n1.  **转换**：应用第 2.3 部分的转换公式将原生集合转换为备用单位制。\n2.  **转换回来**：应用逆转换公式返回到原生单位制。\n3.  **检查差异**：对于四个量（$n, k_F, E_F, T$）中的每一个，计算原始原生值和往返值之间的相对差异 $\\delta$。\n只有当所有四个差异都低于容差 $\\epsilon = 10^{-12}$ 时，测试用例才通过此阶段。\n\n**3.4. 最终裁定**\n当且仅当一个测试用例同时通过物理关系验证（步骤 3.2）和往返转换检查（步骤 3.3）时，它才会获得 `True` 的最终裁定。否则，裁定为 `False`。程序将对所有测试用例执行此逻辑，并报告布尔结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants and tolerance as defined in the problem.\nHBAR_C_MEV_FM = 197.3269804  # MeV*fm\nNUCLEON_MASS_MEV = 939.56542052  # MeV\nTOLERANCE = 1e-12\n\ndef delta(x, y):\n    \"\"\"\n    Calculates the relative discrepancy between two numbers x and y.\n    The normalization is max(1, |x|, |y|) to handle values close to zero.\n    \"\"\"\n    return np.abs(x - y) / np.max([1.0, np.abs(x), np.abs(y)])\n\ndef compute_native_set(is_mev_fm, known_var, val, g):\n    \"\"\"\n    Computes the full set of (n, kF, EF) from a single known quantity\n    in the specified native unit system.\n    \"\"\"\n    n, kf, ef = 0.0, 0.0, 0.0\n    pi_squared = np.pi**2\n    \n    if is_mev_fm:  # MeV-fm unit system\n        if known_var == 'n':\n            n = val\n            kf = (6 * pi_squared * n / g)**(1/3)\n            ef = (HBAR_C_MEV_FM * kf)**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'kF':\n            kf = val\n            n = g * kf**3 / (6 * pi_squared)\n            ef = (HBAR_C_MEV_FM * kf)**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'eF':\n            ef = val\n            kf = np.sqrt(2 * NUCLEON_MASS_MEV * ef) / HBAR_C_MEV_FM\n            n = g * kf**3 / (6 * pi_squared)\n    else:  # Natural unit system\n        if known_var == 'n':\n            n = val\n            kf = (6 * pi_squared * n / g)**(1/3)\n            ef = kf**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'kF':\n            kf = val\n            n = g * kf**3 / (6 * pi_squared)\n            ef = kf**2 / (2 * NUCLEON_MASS_MEV)\n        elif known_var == 'eF':\n            ef = val\n            kf = np.sqrt(2 * NUCLEON_MASS_MEV * ef)\n            n = g * kf**3 / (6 * pi_squared)\n            \n    return {'n': n, 'kf': kf, 'ef': ef}\n\ndef verify_relations(state, g, is_mev_fm):\n    \"\"\"\n    Verifies that the fundamental Fermi gas relations hold for the given state.\n    \"\"\"\n    n, kf, ef = state['n'], state['kf'], state['ef']\n    \n    # Check n -> kF relation\n    n_check = g * kf**3 / (6 * np.pi**2)\n    pass_n_kf = delta(n, n_check)  TOLERANCE\n\n    # Check eF -> kF relation, using the appropriate formula for the unit system\n    if is_mev_fm:\n        ef_check = (HBAR_C_MEV_FM * kf)**2 / (2 * NUCLEON_MASS_MEV)\n    else:\n        ef_check = kf**2 / (2 * NUCLEON_MASS_MEV)\n    pass_ef_kf = delta(ef, ef_check)  TOLERANCE\n\n    return pass_n_kf and pass_ef_kf\n    \ndef mevfm_to_natural(state):\n    \"\"\"Converts a state from MeV-fm units to natural units.\"\"\"\n    hc3 = HBAR_C_MEV_FM**3\n    return {\n        'n': state['n'] * hc3,\n        'kf': state['kf'] * HBAR_C_MEV_FM,\n        'ef': state['ef'],\n        't': state['t']\n    }\n\ndef natural_to_mevfm(state):\n    \"\"\"Converts a state from natural units to MeV-fm units.\"\"\"\n    hc3 = HBAR_C_MEV_FM**3\n    return {\n        'n': state['n'] / hc3,\n        'kf': state['kf'] / HBAR_C_MEV_FM,\n        'ef': state['ef'],\n        't': state['t']\n    }\n\ndef verify_roundtrip(native_set, round_trip_set):\n    \"\"\"\n    Checks the discrepancies between an original and a round-trip converted state.\n    \"\"\"\n    d_n = delta(native_set['n'], round_trip_set['n'])\n    d_kf = delta(native_set['kf'], round_trip_set['kf'])\n    d_ef = delta(native_set['ef'], round_trip_set['ef'])\n    d_t = delta(native_set['t'], round_trip_set['t'])\n    \n    return (d_n  TOLERANCE and\n            d_kf  TOLERANCE and\n            d_ef  TOLERANCE and\n            d_t  TOLERANCE)\n\ndef process_case(is_mev_fm, known_var, val, g, T):\n    \"\"\"\n    Runs a single test case through the full validation procedure.\n    \"\"\"\n    # 1. Compute the full set of physical quantities in the native unit system.\n    native_set = compute_native_set(is_mev_fm, known_var, val, g)\n    native_set['t'] = T\n\n    # 2. Verify that the Fermi gas relations hold for the computed set.\n    pass_relations = verify_relations(native_set, g, is_mev_fm)\n\n    # 3. Perform a round-trip conversion and verify negligible discrepancies.\n    if is_mev_fm:\n        converted_set = mevfm_to_natural(native_set)\n        round_trip_set = natural_to_mevfm(converted_set)\n    else:  # is_natural\n        converted_set = natural_to_mevfm(native_set)\n        round_trip_set = mevfm_to_natural(converted_set)\n\n    pass_roundtrip = verify_roundtrip(native_set, round_trip_set)\n    \n    return pass_relations and pass_roundtrip\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (is_mev_fm, known_var, value, degeneracy g, temperature T in MeV)\n        (True, 'n', 0.16, 4, 0.0),            # Case 1\n        (True, 'kF', 0.05, 2, 5.0),           # Case 2\n        (False, 'kF', 262.444883932, 4, 15.0), # Case 3\n        (False, 'eF', 37.0, 4, 1.0)            # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        is_mev_fm, known_var, val, g, T = case\n        result = process_case(is_mev_fm, known_var, val, g, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The boolean values are converted to string format 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在建立了零温基态的图像后，下一步自然是探索温度对系统的影响。描述系统如何响应热量输入的一个关键物理量是其热容 $C_V$。\n\n本练习通过计算费米气体在有限温度下的热容，深入研究其热力学性质。这需要对费米-狄拉克积分进行数值计算，并求解随温度变化的化学势以保持系统粒子数密度恒定。\n\n通过将精确的数值计算结果与著名的低温索末菲展开（Sommerfeld expansion）进行比较，你将定量地理解为何简并费米气体的热容与温度呈线性关系，以及当系统简并度降低时这种行为如何偏离 。",
            "id": "3599424",
            "problem": "考虑一个在核物质的费米气体模型下的三维、非相对论性、无相互作用的核子系统。设单粒子能量为 $\\varepsilon = p^{2}/(2m)$，并假设系统处于温度为 $T$ 的热平衡状态，其化学势 $\\mu(T)$ 由固定的粒子数密度决定。单粒子态的占据概率由费米-狄拉克分布 (FD) 给出，定义为 $f(\\varepsilon;\\mu,T) = \\left(1 + \\exp\\left((\\varepsilon - \\mu)/(k_{B}T)\\right)\\right)^{-1}$，其中 $k_{B}$ 是玻尔兹曼常数。在三维空间中，一个非相对论性粒子的单位体积内的态密度与 $\\varepsilon^{1/2}$ 成正比；在下文考虑的所有比率中，比例常数都会被消去。通过 $k_{B}T_{F} = \\varepsilon_{F}$ 引入费米温度 $T_{F}$，其中 $\\varepsilon_{F}$ 是给定密度下的零温费米能。定义简并参数 $\\theta = T/T_{F}$ 和约化化学势 $\\eta = \\mu/(k_{B}T)$。定义无量纲积分 $I_{\\alpha}(\\eta) = \\int_{0}^{\\infty} \\frac{x^{\\alpha}}{1 + \\exp(x - \\eta)} \\, dx$，其中指数 $\\alpha \\in \\{1/2, 3/2\\}$，且 $x = \\varepsilon/(k_{B}T)$。\n\n您的任务是：\n- 从 FD 分布和态密度出发，推导用 $\\theta$ 和 $\\eta$ 表示的固定密度约束条件，以及在有限温度 $T$ 下单个粒子内能 $E/A$ 作为 $I_{3/2}(\\eta)$ 和 $I_{1/2}(\\eta)$ 函数的表达式。\n- 仅使用这些基本关系，设计一种计算方法，用于评估在固定密度路径（恒定 $T_{F}$）上单个粒子的定容热容 $C_{V}/A$，并以 $k_{B}$ 为单位表示，即无量纲量 $(C_{V}/A)/k_{B}$。您必须通过对 $E/A$ 关于 $T$ 求导来数值计算 $(C_{V}/A)/k_{B}$，同时强制执行固定密度约束以获得每个 $T$ 对应的 $\\eta(T)$。\n- 为在低温下进行比较，还需计算著名的 Sommerfeld 展开给出的 $(C_{V}/A)/k_{B}$ 的低温估算主导项，该项是 $T/T_{F}$ 的线性函数，并通过报告归一化差异 $(\\text{数值} - \\text{Sommerfeld})/(\\text{Sommerfeld})$ 来量化中等简并度下的偏差。\n\n物理和数值单位及输出：\n- 将 $(C_{V}/A)$ 以 $k_{B}$ 为单位表示，即报告无量纲数 $(C_{V}/A)/k_{B}$。输出中不需要其他物理单位。\n- 对于每个测试用例，报告四个值：输入 $\\theta = T/T_{F}$、计算出的 $(C_{V}/A)/k_{B}$、在相同 $\\theta$ 下从 Sommerfeld 展开得到的低温线性估算值，以及归一化偏差 $(\\text{数值} - \\text{Sommerfeld})/(\\text{Sommerfeld})$。\n- 将所有报告的浮点数四舍五入到六位小数。\n\n测试套件：\n- 为以下简并参数 $\\theta$ 评估您的程序：$0.05$、$0.20$、$0.50$、$1.00$、$2.00$ 和 $5.00$。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个由逗号分隔的列表组成的列表，其中每个内部列表的形式为 $[\\theta, (C_{V}/A)/k_{B}, \\text{Sommerfeld}(\\theta), \\text{偏差}]$。例如，$[[\\theta_{1},c_{1},s_{1},d_{1}],[\\theta_{2},c_{2},s_{2},d_{2}],\\dots]$。不应打印任何额外文本。",
            "solution": "问题已经过验证。\n\n### 步骤 1：提取已知条件\n-   系统：三维、非相对论性、无相互作用的核子系统（费米气体）。\n-   单粒子能量：$\\varepsilon = p^{2}/(2m)$。\n-   平衡条件：温度 $T$，化学势 $\\mu(T)$。\n-   约束：固定的粒子数密度。\n-   占据概率：费米-狄拉克 (FD) 分布，$f(\\varepsilon;\\mu,T) = \\left(1 + \\exp\\left((\\varepsilon - \\mu)/(k_{B}T)\\right)\\right)^{-1}$。\n-   常数：玻尔兹曼常数 $k_{B}$。\n-   单位体积内的态密度：$g(\\varepsilon) \\propto \\varepsilon^{1/2}$。比例常数在比率中消去。\n-   定义：\n    -   费米温度：$T_{F}$，其中 $k_{B}T_{F} = \\varepsilon_{F}$，$\\varepsilon_{F}$ 为零温费米能。\n    -   简并参数：$\\theta = T/T_{F}$。\n    -   约化化学势：$\\eta = \\mu/(k_{B}T)$。\n    -   无量纲积分：$I_{\\alpha}(\\eta) = \\int_{0}^{\\infty} \\frac{x^{\\alpha}}{1 + \\exp(x - \\eta)} \\, dx$，其中 $x = \\varepsilon/(k_{B}T)$。\n-   任务：\n    1.  推导关联 $\\theta$ 和 $\\eta$ 的固定密度约束。\n    2.  推导单个粒子内能 $E/A$ 用 $I_{3/2}(\\eta)$ 和 $I_{1/2}(\\eta)$ 表示的表达式。\n    3.  设计一种计算方法，通过对 $E/A$ 关于 $T$ 进行数值微分，来评估单个粒子的定容热容 $(C_{V}/A)/k_{B}$。\n    4.  计算 $(C_{V}/A)/k_{B}$ 的 Sommerfeld 展开估算主导项。\n    5.  计算归一化差异 $(\\text{数值} - \\text{Sommerfeld})/(\\text{Sommerfeld})$。\n-   输出要求：\n    -   对于每个 $\\theta \\in \\{0.05, 0.20, 0.50, 1.00, 2.00, 5.00\\}$，报告一个包含 $[\\theta, (C_{V}/A)/k_{B}, \\text{Sommerfeld}(\\theta), \\text{偏差}]$ 的列表。\n    -   所有浮点数必须四舍五入到六位小数。\n    -   最终输出是包含这些列表的单行、逗号分隔的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是统计力学中的一个标准练习，将费米气体模型应用于核物质。该模型虽然是简化模型，但却是核物理的基石之一。所有原理和定义都是公认的。该问题在科学上是合理的。\n2.  **适定性**：该问题提供了所有必要的定义和关系，为求解建立了清晰的路径。任务具体，对每个输入参数都能导出一个唯一的、可计算的结果。\n3.  **客观性**：语言精确、技术性强，没有主观性或模糊性。\n4.  **完整性**：问题是自洽的。所提供的信息足以推导所需的表达式并实现数值解。\n5.  **未检测到其他缺陷**：该问题并非无关紧要、不切实际、自相矛盾或不适定。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 基于原理的求解设计\n\n求解过程分两个阶段：首先，分析推导必要的物理关系；其次，基于这些关系设计计算算法。\n\n**1. 分析推导**\n\n设单位体积内的单粒子态密度为 $g(\\varepsilon) = C \\varepsilon^{1/2}$，其中 $C$ 是一个包含自旋简并度和基本常数的常数。\n\n**固定密度约束：**\n粒子数密度 $n = A/V$ 通过对态密度和费米-狄拉克分布的乘积在所有能量上积分得到：\n$$n = \\int_{0}^{\\infty} g(\\varepsilon) f(\\varepsilon; \\mu, T) d\\varepsilon = C \\int_{0}^{\\infty} \\frac{\\varepsilon^{1/2}}{1 + \\exp((\\varepsilon - \\mu)/(k_{B}T))} d\\varepsilon$$\n在绝对零度（$T=0$）时，FD 分布是一个阶跃函数（当 $\\varepsilon  \\varepsilon_{F}$ 时 $f=1$，当 $\\varepsilon > \\varepsilon_{F}$ 时 $f=0$），其中 $\\varepsilon_{F}$ 是费米能。因此密度 $n$ 为：\n$$n = C \\int_{0}^{\\varepsilon_{F}} \\varepsilon^{1/2} d\\varepsilon = C \\frac{2}{3} \\varepsilon_{F}^{3/2}$$\n由于粒子密度 $n$ 是固定的，因此费米能 $\\varepsilon_{F}$ 对该系统而言是一个常数。\n\n在有限温度 $T > 0$ 下，我们引入无量纲变量 $x = \\varepsilon/(k_{B}T)$ 和约化化学势 $\\eta = \\mu/(k_{B}T)$。$n$ 的积分变为：\n$$n = C \\int_{0}^{\\infty} \\frac{(x k_{B} T)^{1/2}}{1 + \\exp(x - \\eta)} (k_{B}T \\, dx) = C (k_{B}T)^{3/2} \\int_{0}^{\\infty} \\frac{x^{1/2}}{1 + \\exp(x - \\eta)} dx = C (k_{B}T)^{3/2} I_{1/2}(\\eta)$$\n令 $T=0$ 和 $T0$ 时固定密度 $n$ 的表达式相等：\n$$C \\frac{2}{3} \\varepsilon_{F}^{3/2} = C (k_{B}T)^{3/2} I_{1/2}(\\eta)$$\n常数 $C$ 被消去。使用定义 $k_B T_F = \\varepsilon_F$ 和 $\\theta = T/T_F$：\n$$\\frac{2}{3} (k_B T_F)^{3/2} = (k_B T_F \\theta)^{3/2} I_{1/2}(\\eta)$$\n$$\\frac{2}{3} = \\theta^{3/2} I_{1/2}(\\eta)$$\n这就是固定密度约束。它隐式地将约化化学势 $\\eta$ 定义为简并参数 $\\theta$ 的函数。对于任何给定的 $\\theta$，必须求解此方程以找到相应的 $\\eta$。\n\n**单个粒子内能：**\n内能密度 $E/V$ 由下式给出：\n$$ \\frac{E}{V} = \\int_{0}^{\\infty} \\varepsilon g(\\varepsilon) f(\\varepsilon; \\mu, T) d\\varepsilon = C \\int_{0}^{\\infty} \\frac{\\varepsilon^{3/2}}{1 + \\exp((\\varepsilon - \\mu)/(k_{B}T))} d\\varepsilon $$\n用无量纲变量 $x$ 表示：\n$$ \\frac{E}{V} = C \\int_{0}^{\\infty} \\frac{(x k_{B} T)^{3/2}}{1 + \\exp(x - \\eta)} (k_{B}T \\, dx) = C (k_{B}T)^{5/2} I_{3/2}(\\eta) $$\n单个粒子内能 $E/A$ 是能量密度与粒子数密度的比值：\n$$ \\frac{E}{A} = \\frac{E/V}{n} = \\frac{C (k_{B}T)^{5/2} I_{3/2}(\\eta)}{C (k_{B}T)^{3/2} I_{1/2}(\\eta)} = k_{B}T \\frac{I_{3/2}(\\eta)}{I_{1/2}(\\eta)} $$\n\n**2. 计算方法**\n\n**热容 $(C_V/A)/k_B$：**\n单个粒子的定容热容定义为 $C_V/A = \\frac{1}{A}(\\frac{\\partial E}{\\partial T})_V = \\frac{\\partial (E/A)}{\\partial T}$。我们需要计算其无量纲值 $(C_V/A)/k_B$。\n$$ \\frac{C_V/A}{k_B} = \\frac{1}{k_B} \\frac{\\partial}{\\partial T}\\left(k_B T \\frac{I_{3/2}(\\eta)}{I_{1/2}(\\eta)}\\right) = \\frac{\\partial}{\\partial T}\\left(T \\frac{I_{3/2}(\\eta)}{I_{1/2}(\\eta)}\\right) $$\n为进行数值计算，我们使用中心差分近似来计算导数。设 $U(T) = (E/A)/k_B = T \\frac{I_{3/2}(\\eta(T))}{I_{1/2}(\\eta(T))}$。注意 $T_F$ 是一个常数，因此不失一般性地可以将其设为 1，从而使得 $T = \\theta$。\n$$ \\frac{C_V/A}{k_B} \\approx \\frac{U(\\theta + h) - U(\\theta - h)}{2h} $$\n其中 $h$ 是 $\\theta$ 的一个小步长。对于给定的 $\\theta$，计算过程如下：\n1.  选择一个小步长 $h$（例如，$h = 10^{-6}\\theta$）。\n2.  定义 $\\theta_1 = \\theta - h$ 和 $\\theta_2 = \\theta + h$。\n3.  对于 $\\theta_1$，数值求解约束方程 $I_{1/2}(\\eta_1) = \\frac{2}{3}\\theta_1^{-3/2}$ 以得到 $\\eta_1$。这需要一个作用于 $I_{1/2}$ 数值积分程序上的求根算法。\n4.  使用 $\\eta_1$ 计算 $U(\\theta_1)$：$U(\\theta_1) = \\theta_1 \\frac{I_{3/2}(\\eta_1)}{I_{1/2}(\\eta_1)}$，其中 $I_{3/2}(\\eta_1)$ 也通过数值积分计算。\n5.  对 $\\theta_2$ 重复步骤 3-4，以找到 $\\eta_2$ 和 $U(\\theta_2)$。\n6.  计算热容为 $(C_V/A)/k_B = (U(\\theta_2) - U(\\theta_1))/(2h)$。\n\n**Sommerfeld 低温近似：**\n对于低温（$\\theta \\ll 1$），热容可以由 Sommerfeld 展开的主导项近似，该项与温度成线性关系：\n$$ \\frac{C_V}{A k_B} \\approx \\frac{\\pi^2}{2} \\frac{k_B T}{\\varepsilon_F} = \\frac{\\pi^2}{2} \\frac{T}{T_F} = \\frac{\\pi^2}{2} \\theta $$\n\n**归一化偏差：**\n数值计算值与低温近似值之间的相对差异计算如下：\n$$ \\text{偏差} = \\frac{(C_V/A)_{\\text{数值}} - (C_V/A)_{\\text{Sommerfeld}}}{(C_V/A)_{\\text{Sommerfeld}}} $$\n\n实现将利用 `scipy.integrate.quad` 进行费米-狄拉克积分，并利用 `scipy.optimize.root_scalar` 求解约化化学势 $\\eta$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\n# A cache to store results of the expensive Fermi-Dirac integral calculations,\n# which are frequently called by the root-finding algorithm.\n_integral_cache = {}\n\ndef fermi_dirac_integral(alpha, eta):\n    \"\"\"\n    Computes the dimensionless Fermi-Dirac integral I_alpha(eta).\n    \n    I_alpha(eta) = integral from 0 to inf of x^alpha / (1 + exp(x - eta)) dx.\n    \"\"\"\n    # Use tuple (alpha, eta) as the dictionary key.\n    if (alpha, eta) in _integral_cache:\n        return _integral_cache[(alpha, eta)]\n    \n    # The integrand function.\n    integrand = lambda x: np.power(x, alpha) / (1.0 + np.exp(x - eta))\n    \n    # For alpha > 0, the integrand is well-behaved at x=0.\n    # The original condition `alpha  0` was syntactically incorrect and the\n    # `points` argument is not strictly necessary for alpha=1/2 or 3/2.\n    # It is kept here for robustness in case of future generalization, with corrected syntax.\n    points_of_interest = [0] if alpha > 0 else None\n    \n    # Numerically integrate using SciPy's quad function.\n    # The upper limit can be set to a large number like eta + 50 for efficiency,\n    # as the integrand decays exponentially for x > eta. Inf is also fine.\n    upper_bound = np.inf\n    result, _ = integrate.quad(integrand, 0, upper_bound, points=points_of_interest)\n    \n    _integral_cache[(alpha, eta)] = result\n    return result\n\ndef find_eta_for_theta(theta):\n    \"\"\"\n    Solves the fixed-density constraint equation to find the reduced chemical\n    potential 'eta' for a given degeneracy parameter 'theta'.\n    \n    The constraint is: I_{1/2}(eta) = (2/3) * theta^(-3/2).\n    \"\"\"\n    target_value = (2.0 / 3.0) * np.power(theta, -1.5)\n    \n    def root_function(eta):\n        \"\"\" The function whose root needs to be found: f(eta) = I_{1/2}(eta) - C = 0. \"\"\"\n        return fermi_dirac_integral(0.5, eta) - target_value\n        \n    # Use a robust root-finding algorithm (Brent's method) with a wide, safe bracket.\n    # For low theta, eta is large positive. For high theta, eta is negative.\n    # The bracket [-40, 400] is sufficiently large to contain the root for all test cases.\n    try:\n        sol = optimize.root_scalar(root_function, bracket=[-40, 400], method='brentq')\n        return sol.root\n    except ValueError:\n        # This may happen if the root is not in the bracket, which indicates a problem.\n        # For this well-behaved function, it is not expected.\n        print(f\"Error: Root not found for theta = {theta}\")\n        return np.nan\n\ndef get_energy_per_particle_div_kb(theta):\n    \"\"\"\n    Calculates the internal energy per particle in units of k_B, (E/A)/k_B.\n    \n    (E/A)/k_B = T * I_{3/2}(eta) / I_{1/2}(eta)\n    With T_F=1, this is theta * I_{3/2}(eta) / I_{1/2}(eta).\n    \"\"\"\n    if theta = 0:\n        return 0.0\n\n    eta = find_eta_for_theta(theta)\n    \n    # Get the integral values.\n    i_3_2 = fermi_dirac_integral(1.5, eta)\n    i_1_2 = fermi_dirac_integral(0.5, eta) # This could also be replaced by target_value from find_eta\n    \n    if i_1_2 == 0:\n        return 0.0 # Avoid division by zero\n        \n    return theta * i_3_2 / i_1_2\n\ndef calculate_numerical_cv(theta):\n    \"\"\"\n    Computes the dimensionless heat capacity (C_V/A)/k_B by numerically\n    differentiating the energy per particle with respect to temperature.\n    \"\"\"\n    # Use a central difference formula for the derivative, with a small relative step size.\n    h = 1e-6 * theta\n    \n    # Ensure h is not too small to cause floating point precision issues.\n    h = max(h, 1e-9)\n\n    energy_plus_h = get_energy_per_particle_div_kb(theta + h)\n    energy_minus_h = get_energy_per_particle_div_kb(theta - h)\n    \n    # Derivative is dU/dT. With T_F=1, T=theta. So dU/d(theta)\n    cv_numerical = (energy_plus_h - energy_minus_h) / (2.0 * h)\n    \n    return cv_numerical\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [0.05, 0.20, 0.50, 1.00, 2.00, 5.00]\n    \n    results = []\n    \n    for theta in test_cases:\n        # Clear the cache for each new theta value to avoid excessive memory usage\n        # in a more extensive calculation.\n        global _integral_cache\n        _integral_cache.clear()\n        \n        # 1. Compute the heat capacity numerically.\n        cv_numerical = calculate_numerical_cv(theta)\n        \n        # 2. Compute the low-temperature Sommerfeld approximation.\n        cv_sommerfeld = (np.pi**2 / 2.0) * theta\n        \n        # 3. Compute the normalized deviation.\n        if cv_sommerfeld != 0:\n            deviation = (cv_numerical - cv_sommerfeld) / cv_sommerfeld\n        else:\n            deviation = np.nan # Should not happen for theta > 0\n\n        # Assemble the results for this test case, rounding to six decimal places.\n        results.append([\n            round(theta, 6),\n            round(cv_numerical, 6),\n            round(cv_sommerfeld, 6),\n            round(deviation, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    # The conversion to string handles list formatting automatically.\n    # Joining with ',' creates the comma-separated list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "简单的单组分费米气体模型是一种理想化情况。真实的核物质由两种组分构成：质子和中子。由于中子和质子数量不对称而导致的能量代价是核物理学中的一个关键概念。\n\n本练习将费米气体模型扩展到双组分系统，以探索动能对称能 $S_{\\text{kin}}$ 的物理起源。该物理量是总对称能的动能部分，它决定了非对称核物质以及中子星的性质。\n\n通过计算单粒子能量随同位旋不对称度 $\\delta$ 的变化，并从中提取二次项系数 $S_{\\text{kin}}$，你将通过数值方法推导核物质状态方程中最重要的参数之一 。这项实践将理想化的费米气体模型与真实、复杂的核系统应用联系起来。",
            "id": "3599449",
            "problem": "考虑一个由中子和质子组成的双组分、非相对论费米气体核物质模型，两者的裸核子质量相等。令总数密度为 $\\rho$（单位为 $\\mathrm{fm}^{-3}$），并定义同位旋不对称度 $\\delta$ 为 $\\delta=(\\rho_n-\\rho_p)/\\rho$，其中 $\\rho_n$ 和 $\\rho_p$ 分别是中子和质子数密度。假设每个组分的自旋简并度为 $g=2$ 并忽略相互作用（自由气体）。使用的单位制中，能量以兆电子伏特（$\\mathrm{MeV}$）度量，长度以飞米（$\\mathrm{fm}$）度量，其中 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$，裸核子质量 $m=939.0\\,\\mathrm{MeV}$。温度 $T$ 以 $\\mathrm{MeV}$ 为单位，因此 $k_B T$ 已被吸收到 $T$ 中。\n\n从第一性原理出发，即：\n- 在化学势为 $\\mu$ 和温度为 $T$ 时，费米子的费米-狄拉克分布函数为 $f(E,\\mu,T)=\\left[1+\\exp\\left((E-\\mu)/T\\right)\\right]^{-1}$（其零温极限由费米能量处的亥维赛阶跃函数给出），\n- 动量空间中自由气体的数密度和动能密度的定义，\n推导计算给定 $\\rho$ 和 $T$ 下每核子总动能 $E/A(\\delta)$ 的表达式。所有量都用波数 $k$ （单位为 $\\mathrm{fm}^{-1}$）表示，其中单粒子动能为 $E(k)=\\hbar^2 k^2/(2m)$，且测量由标准态计数设定：\n$$\n\\rho_i(\\mu_i,T)=\\frac{g}{2\\pi^2}\\int_0^{\\infty} k^2\\, f\\!\\left(E(k),\\mu_i,T\\right)\\, dk,\n$$\n$$\n\\varepsilon_i(\\mu_i,T)=\\frac{g}{2\\pi^2}\\int_0^{\\infty} k^2\\, E(k)\\, f\\!\\left(E(k),\\mu_i,T\\right)\\, dk,\n$$\n对于 $i\\in\\{n,p\\}$，而每核子总动能为 $E/A(\\delta)=\\left[\\varepsilon_n+\\varepsilon_p\\right]/\\rho$。在零温下，使用分布的零温极限和相应的精确积分。\n\n将动能对称能 $S_{\\mathrm{kin}}(\\rho,T)$ 定义为 $E/A(\\delta)$ 在 $\\delta=0$ 附近展开式中 $\\delta^2$ 的系数：\n$$\nE/A(\\delta) = E/A(0) + S_{\\mathrm{kin}}(\\rho,T)\\,\\delta^2 + \\mathcal{O}(\\delta^4).\n$$\n您必须通过在一个围绕 $0$ 的小的、对称的 $\\delta$ 值网格上计算 $E/A(\\delta)$，并对偶次多项式基 $\\{1,\\delta^2\\}$ 进行最小二乘拟合来数值确定 $S_{\\mathrm{kin}}(\\rho,T)$，以提取二次项系数。在零温下，从相同的第一性原理出发，解析推导 $S_{\\mathrm{kin}}(\\rho,T)$ 的精确零温极限，并数值验证您的拟合值与解析结果是否一致。\n\n算法说明：\n- 对于给定的总密度 $\\rho$ 和不对称度 $\\delta$，分配 $\\rho_n=\\rho(1+\\delta)/2$ 和 $\\rho_p=\\rho(1-\\delta)/2$。\n- 当 $T=0$ 时，使用分布的零温极限和对波数 $k$ 直到费米波数的精确积分来计算 $E/A(\\delta)$。当 $T0$ 时，对于每个组分 $i$，通过数值求解 $\\rho_i(\\mu_i,T)=\\rho_i$ 来确定 $\\mu_i$（使用一个稳健的、单调的根的区间法），然后计算 $\\varepsilon_i(\\mu_i,T)$。\n- 使用对称网格 $\\delta\\in\\{-0.4,-0.2,0.0,0.2,0.4\\}$ 来拟合 $E/A(\\delta)$ 并从对 $\\{1,\\delta^2\\}$ 的最小二乘拟合中提取 $\\delta^2$ 的系数作为 $S_{\\mathrm{kin}}(\\rho,T)$。\n- 所有计算出的能量必须以 $\\mathrm{MeV}$ 表示。报告浮点数时四舍五入到小数点后六位。\n\n测试用例：\n- 情况1：$\\rho=0.16\\,\\mathrm{fm}^{-3}$，$T=0\\,\\mathrm{MeV}$；返回拟合的 $S_{\\mathrm{kin}}(\\rho,T)$ 以及一个布尔值，说明其是否在 $10^{-3}\\,\\mathrm{MeV}$ 的绝对容差内与解析推导的零温极限相匹配。\n- 情况2：$\\rho=0.08\\,\\mathrm{fm}^{-3}$，$T=0\\,\\mathrm{MeV}$；返回拟合的 $S_{\\mathrm{kin}}(\\rho,T)$ 以及一个布尔值，说明其是否在 $10^{-3}\\,\\mathrm{MeV}$ 的绝对容差内与解析推导的零温极限相匹配。\n- 情况3：$\\rho=0.16\\,\\mathrm{fm}^{-3}$，$T=5\\,\\mathrm{MeV}$；返回拟合的 $S_{\\mathrm{kin}}(\\rho,T)$。\n- 情况4：$\\rho=0.16\\,\\mathrm{fm}^{-3}$，$T=20\\,\\mathrm{MeV}$；返回拟合的 $S_{\\mathrm{kin}}(\\rho,T)$。\n- 情况5：$\\rho=10^{-6}\\,\\mathrm{fm}^{-3}$，$T=5\\,\\mathrm{MeV}$；返回拟合的 $S_{\\mathrm{kin}}(\\rho,T)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须按顺序包含：情况1的浮点数、情况1验证的布尔值、情况2的浮点数、情况2验证的布尔值、情况3的浮点数、情况4的浮点数和情况5的浮点数。例如：$[x_1,\\mathrm{True},x_2,\\mathrm{False},x_3,x_4,x_5]$，其中每个 $x_i$ 是一个四舍五入到小数点后六位并以 $\\mathrm{MeV}$ 表示的浮点数。",
            "solution": "该问题具有科学依据，提法明确，并包含推导唯一解所需的所有信息。我们首先概述非相对论自由费米气体模型的理论框架，然后详述零温和有限温下的计算策略，最后解释提取动能对称能的步骤。\n\n**1. 理论框架：自由费米气体模型**\n\n该系统是由质量为 $m$ 的不相互作用的中子（$n$）和质子（$p$）组成的双组分气体。系统的状态由总核子数密度 $\\rho = \\rho_n + \\rho_p$ 和温度 $T$ 决定。中子和质子的相对比例由同位旋不对称度 $\\delta = (\\rho_n - \\rho_p)/\\rho$ 给出，这意味着 $\\rho_n = \\rho(1+\\delta)/2$ 和 $\\rho_p = \\rho(1-\\delta)/2$。\n\n波数为 $k$ 的核子的单粒子动能是非相对论的：\n$$E(k) = \\frac{\\hbar^2 k^2}{2m}$$\n其中我们使用常数 $\\frac{\\hbar^2}{2m} = \\frac{(\\hbar c)^2}{2mc^2}$。给定 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$ 和 $m \\equiv mc^2 = 939.0\\,\\mathrm{MeV}$，该常数约等于 $20.7337\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^2$。\n\n粒子遵循费米-狄拉克分布，该分布给出了能量为 $E$ 的态被占据的概率：\n$$f(E, \\mu, T) = \\frac{1}{1 + \\exp\\left(\\frac{E-\\mu}{T}\\right)}$$\n这里，$\\mu$ 是粒子种类的化学势，$T$ 是以 $\\mathrm{MeV}$ 为单位的温度。\n\n每个种类 $i \\in \\{n,p\\}$ 的数密度 $\\rho_i$ 和动能密度 $\\varepsilon_i$ 通过对所有动量态进行积分得到，自旋简并因子为 $g=2$：\n$$ \\rho_i(\\mu_i, T) = \\frac{g}{2\\pi^2} \\int_0^{\\infty} k^2 f(E(k), \\mu_i, T) dk $$\n$$ \\varepsilon_i(\\mu_i, T) = \\frac{g}{2\\pi^2} \\int_0^{\\infty} k^2 E(k) f(E(k), \\mu_i, T) dk $$\n每核子总动能 $E/A$ 是动能密度之和除以总数密度：\n$$ E/A(\\delta) = \\frac{\\varepsilon_n + \\varepsilon_p}{\\rho} $$\n\n**2. 零温情况 ($T=0\\,\\mathrm{MeV}$)**\n\n在零温下，费米-狄拉克分布变为亥维赛阶跃函数，$f(E,\\mu,0) = \\Theta(\\mu - E)$，其中化学势 $\\mu(T=0)$ 即为费米能 $E_{F_i}$。积分在费米波数 $k_{F_i}$ 处被截断，其中 $E(k_{F_i}) = E_{F_i}$。\n\n数密度积分变为：\n$$ \\rho_i = \\frac{g}{2\\pi^2} \\int_0^{k_{F_i}} k^2 dk = \\frac{g}{6\\pi^2} k_{F_i}^3 $$\n当 $g=2$ 时，我们有 $\\rho_i = k_{F_i}^3 / (3\\pi^2)$，这给出了费米波数为 $k_{F_i} = (3\\pi^2 \\rho_i)^{1/3}$。\n\n动能密度积分变为：\n$$ \\varepsilon_i = \\frac{g}{2\\pi^2} \\int_0^{k_{F_i}} k^2 \\left(\\frac{\\hbar^2 k^2}{2m}\\right) dk = \\frac{g\\hbar^2}{4\\pi^2 m} \\frac{k_{F_i}^5}{5} $$\n代入 $k_{F_i}$ 和 $g=2$，我们可以用 $\\rho_i$ 表示 $\\varepsilon_i$：\n$$ \\varepsilon_i = \\frac{\\hbar^2}{10\\pi^2 m} (3\\pi^2 \\rho_i)^{5/3} = \\frac{3\\hbar^2(3\\pi^2)^{2/3}}{10m} \\rho_i^{5/3} $$\n那么每核子总动能为：\n$$ E/A(\\delta) = \\frac{1}{\\rho} \\left( \\varepsilon_n + \\varepsilon_p \\right) = \\frac{3\\hbar^2(3\\pi^2)^{2/3}}{10m\\rho} \\left[ \\rho_n^{5/3} + \\rho_p^{5/3} \\right] $$\n代入 $\\rho_n = \\rho(1+\\delta)/2$ 和 $\\rho_p = \\rho(1-\\delta)/2$：\n$$ E/A(\\delta) = \\frac{3\\hbar^2(3\\pi^2\\rho)^{2/3}}{10m \\cdot 2^{5/3}} \\left[ (1+\\delta)^{5/3} + (1-\\delta)^{5/3} \\right] $$\n\n动能对称能 $S_{\\mathrm{kin}}$ 是 $E/A(\\delta)$ 在 $\\delta=0$ 附近泰勒展开式中 $\\delta^2$ 的系数。我们展开括号中的项：$(1+x)^p \\approx 1 + px + \\frac{p(p-1)}{2}x^2 + \\dots$。对于 $x=\\pm\\delta$ 和 $p=5/3$：\n$$ (1+\\delta)^{5/3} + (1-\\delta)^{5/3} \\approx \\left(1 + \\frac{5}{3}\\delta + \\frac{10}{9}\\delta^2\\right) + \\left(1 - \\frac{5}{3}\\delta + \\frac{10}{9}\\delta^2\\right) = 2 + \\frac{20}{9}\\delta^2 + \\mathcal{O}(\\delta^4) $$\n将此代入 $E/A(\\delta)$ 的表达式中得到：\n$$ E/A(\\delta) = E/A(0) \\left(1 + \\frac{5}{9}\\delta^2 + \\dots\\right) \\quad \\text{其中} \\quad E/A(0) = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m} = \\frac{3}{5} E_F(\\rho) $$\n这里 $k_F = (3\\pi^2\\rho/2)^{1/3}$ 是对称（$\\delta=0$）物质的费米波数。因此，展开式为：\n$$ E/A(\\delta) = \\frac{3}{5}E_F(\\rho) + \\frac{1}{3}E_F(\\rho)\\delta^2 + \\mathcal{O}(\\delta^4) $$\n因此，在 $T=0$ 时动能对称能的解析表达式为：\n$$ S_{\\mathrm{kin}}(\\rho, T=0) = \\frac{1}{3} E_F(\\rho) = \\frac{1}{3} \\frac{\\hbar^2}{2m} \\left(\\frac{3\\pi^2\\rho}{2}\\right)^{2/3} $$\n此公式用于验证数值拟合的值。\n\n**3. 有限温情况 ($T0\\,\\mathrm{MeV}$)**\n\n在有限温度下，费米-狄拉克分布是一个平滑函数，积分必须进行数值计算。对于给定的 $(\\rho, \\delta, T)$，计算 $E/A(\\delta)$ 的步骤如下：\n1.  计算 $\\rho_n = \\rho(1+\\delta)/2$ 和 $\\rho_p = \\rho(1-\\delta)/2$。\n2.  对于每个种类 $i \\in \\{n, p\\}$，如果 $\\rho_i  0$，通过数值求解非线性方程 $\\rho_i = \\rho_i(\\mu_i, T)$ 来确定化学势 $\\mu_i$。这是一个关于 $\\mu_i$ 的求根问题。由于 $\\rho_i(\\mu_i, T)$ 是 $\\mu_i$ 的单调递增函数，像 Brent 方法这样稳健的根的区间法是合适的。$\\rho_i(\\mu_i,T)$ 的积分使用数值积分程序计算。\n3.  一旦 $\\mu_i$ 已知，动能密度 $\\varepsilon_i = \\varepsilon_i(\\mu_i, T)$ 通过对其定义表达式进行数值积分来计算。\n4.  然后，每核子总动能计算为 $E/A(\\delta) = (\\varepsilon_n+\\varepsilon_p)/\\rho$。\n\n**4. 对称能的数值提取**\n\n问题要求从展开式 $E/A(\\delta) \\approx E/A(0) + S_{\\mathrm{kin}}(\\rho,T)\\delta^2$ 中确定 $S_{\\mathrm{kin}}(\\rho,T)$。这是一个关于 $\\delta$ 的二次拟合，或者等效地，一个关于 $\\delta^2$ 的线性拟合。\n1.  对于给定的 $(\\rho, T)$，对指定网格 $\\{-0.4, -0.2, 0.0, 0.2, 0.4\\}$ 中的每个 $\\delta_j$ 计算量 $E/A(\\delta_j)$。\n2.  我们对模型 $y_j = c_0 + c_1 x_j$ 进行线性最小二乘拟合，其中自变量为 $x_j = \\delta_j^2$，因变量为 $y_j = E/A(\\delta_j)$。\n3.  这对应于在最小二乘意义上求解线性系统 $A\\mathbf{c} = \\mathbf{b}$，其中 $\\mathbf{b}$ 是计算出的 $E/A(\\delta_j)$ 值的向量，$\\mathbf{c} = [c_0, c_1]^T$ 是待求系数的向量，而 $A$ 是设计矩阵：\n    $$A = \\begin{pmatrix} 1  \\delta_1^2 \\\\ 1  \\delta_2^2 \\\\ \\vdots  \\vdots \\\\ 1  \\delta_5^2 \\end{pmatrix} = \\begin{pmatrix} 1  0.16 \\\\ 1  0.04 \\\\ 1  0.00 \\\\ 1  0.04 \\\\ 1  0.16 \\end{pmatrix}$$\n4.  拟合系数 $c_1$ 是动能对称能 $S_{\\mathrm{kin}}(\\rho,T)$ 的数值估计。\n\n这种综合方法将 $T=0$ 情况的解析推导与 $T0$ 情况的稳健数值策略相结合，最终形成一个明确定义的提取动能对称能的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the Fermi gas model problem for the specified test cases.\n    \"\"\"\n\n    # Constants\n    HBARC = 197.3269804  # MeV fm\n    M_N = 939.0          # MeV (bare nucleon mass as mc^2)\n    HBARC2_2M = HBARC**2 / (2 * M_N) # MeV fm^2\n    G = 2.0              # Spin degeneracy\n    PI = np.pi\n\n    # --- T=0 Analytical Calculations ---\n\n    def s_kin_analytic_t0(rho):\n        \"\"\"Calculates the analytical kinetic symmetry energy at T=0.\"\"\"\n        term1 = HBARC2_2M / 3.0\n        term2 = (3.0 * PI**2 * rho / 2.0)**(2.0/3.0)\n        return term1 * term2\n\n    def get_e_per_a_t0(rho, delta):\n        \"\"\"Calculates the kinetic energy per particle at T=0.\"\"\"\n        rho_n = rho * (1.0 + delta) / 2.0\n        rho_p = rho * (1.0 - delta) / 2.0\n\n        # E/A(delta) = (3/10) * (hbar^2/m) * (3*pi^2)^(2/3) * (rho_n^(5/3)+rho_p^(5/3))/rho\n        constant = (2.0 * HBARC2_2M) * (3.0/10.0) * (3.0 * PI**2)**(2.0/3.0)\n        \n        term_n = rho_n**(5.0/3.0) if rho_n > 0 else 0.0\n        term_p = rho_p**(5.0/3.0) if rho_p > 0 else 0.0\n        \n        e_per_a = constant * (term_n + term_p) / rho if rho > 0 else 0.0\n        return e_per_a\n\n    # --- T>0 Numerical Calculations ---\n\n    # Integrands for number density and energy density\n    def integrand_rho(k, mu, T):\n        arg = (HBARC2_2M * k**2 - mu) / T\n        # Avoid overflow for large positive arguments\n        if arg > 700:\n            return 0.0\n        return k**2 / (1.0 + np.exp(arg))\n\n    def integrand_eps(k, mu, T):\n        arg = (HBARC2_2M * k**2 - mu) / T\n        if arg > 700:\n            return 0.0\n        return HBARC2_2M * k**4 / (1.0 + np.exp(arg))\n\n    # Function to calculate number density for a given chemical potential\n    def calculate_rho(mu, T):\n        integral, _ = quad(integrand_rho, 0, np.inf, args=(mu, T), epsabs=1e-12, epsrel=1e-12)\n        # Prefactor is G / (2*pi^2) = 1/pi^2\n        return (1.0 / PI**2) * integral\n\n    # Root-finding function to determine chemical potential\n    def find_mu(rho_i, T):\n        if rho_i = 1e-20:  # Effectively zero density\n            return -np.inf\n        \n        def root_function(mu):\n            return calculate_rho(mu, T) - rho_i\n        \n        # A robust bracket for mu in MeV\n        mu_min, mu_max = -500.0, 500.0\n        try:\n            mu = brentq(root_function, mu_min, mu_max, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This can happen if the root is outside the bracket, e.g., low density\n            # Let's try to search for the bracket\n             a, b = mu_min, mu_max\n             fa, fb = root_function(a), root_function(b)\n             while fa * fb > 0:\n                 if abs(fa)  abs(fb):\n                     a -= 200\n                     fa = root_function(a)\n                 else:\n                     b += 200\n                     fb = root_function(b)\n             mu = brentq(root_function, a, b, xtol=1e-12, rtol=1e-12)\n        return mu\n\n    # Function to calculate kinetic energy density\n    def calculate_eps(mu, T):\n        if not np.isfinite(mu):\n            return 0.0\n        integral, _ = quad(integrand_eps, 0, np.inf, args=(mu, T), epsabs=1e-12, epsrel=1e-12)\n        return (1.0 / PI**2) * integral\n\n    # Main function to get E/A at T>0\n    def get_e_per_a_t_gt_0(rho, delta, T):\n        rho_n = rho * (1.0 + delta) / 2.0\n        rho_p = rho * (1.0 - delta) / 2.0\n        \n        mu_n = find_mu(rho_n, T)\n        eps_n = calculate_eps(mu_n, T)\n        \n        mu_p = find_mu(rho_p, T)\n        eps_p = calculate_eps(mu_p, T)\n        \n        return (eps_n + eps_p) / rho if rho > 0 else 0.0\n\n    # --- Main Loop for Test Cases ---\n\n    test_cases = [\n        {'rho': 0.16, 'T': 0.0},\n        {'rho': 0.08, 'T': 0.0},\n        {'rho': 0.16, 'T': 5.0},\n        {'rho': 0.16, 'T': 20.0},\n        {'rho': 1e-6, 'T': 5.0},\n    ]\n    \n    delta_grid = np.array([-0.4, -0.2, 0.0, 0.2, 0.4])\n    results = []\n    \n    for case in test_cases:\n        rho = case['rho']\n        T = case['T']\n        \n        e_per_a_values = []\n        for delta in delta_grid:\n            if T == 0.0:\n                e_val = get_e_per_a_t0(rho, delta)\n            else:\n                e_val = get_e_per_a_t_gt_0(rho, delta, T)\n            e_per_a_values.append(e_val)\n            \n        # Least-squares fit to y = c0 + c1*x where x=delta^2\n        delta_sq = delta_grid**2\n        A = np.vstack([np.ones_like(delta_sq), delta_sq]).T\n        b = np.array(e_per_a_values)\n        \n        coeffs, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        s_kin_fit = coeffs[1]\n        \n        results.append(f\"{s_kin_fit:.6f}\")\n        \n        if T == 0.0:\n            s_kin_analytic = s_kin_analytic_t0(rho)\n            is_match = np.isclose(s_kin_fit, s_kin_analytic, atol=1e-3)\n            results.append(str(is_match))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}