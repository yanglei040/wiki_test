{
    "hands_on_practices": [
        {
            "introduction": "在原子和核物理中，三个球谐函数的积分（即高恩特系数）是一项常见的计算，它代表了矩阵元素的角度部分。这个练习揭示了这些积分与维格纳 3j 符号之间的深刻联系，展示了角动量代数框架如何为具体计算提供强大工具。通过完成这个推导和计算 ，你将巩固对选择定则和 3j 符号起源的理解。",
            "id": "3611568",
            "problem": "在单个核子的球面平均场描述中，角动量耦合通过球谐函数和张量算符来处理。考虑由 $T^{(2)}_{\\mu} = e\\, r^{2} Y_{2 \\mu}(\\Omega)$ 定义的单体电四极矩算符，其中 $Y_{l m}(\\Omega)$ 是标准的 Condon–Shortley 球谐函数，其归一化条件为 $\\int Y_{l m}^{*}(\\Omega) Y_{l' m'}(\\Omega)\\, d\\Omega = \\delta_{l l'} \\delta_{m m'}$。$T^{(2)}_{\\mu}$ 矩阵元的角向依赖性可以分解为 Gaunt 系数，对于整数 $l_{1}, l_{2}, l_{3}$ 和 $m_{1}, m_{2}, m_{3}$，其定义为\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\int Y_{l_{1} m_{1}}(\\Omega)\\, Y_{l_{2} m_{2}}(\\Omega)\\, Y_{l_{3} m_{3}}(\\Omega)\\, d\\Omega.\n$$\n从球谐函数的定义、其正交性以及 Wigner–Eckart 定理（WET）的陈述出发，推导 Gaunt 系数用 Wigner $3j$ 符号和整体归一化表示的表达式，然后显式计算积分\n$$\nI = \\int Y_{1,0}(\\Omega)\\, Y_{2,0}(\\Omega)\\, Y_{1,0}(\\Omega)\\, d\\Omega.\n$$\n解释你使用的任何选择定则，并将最终结果以无数值近似的闭合形式解析表达式给出。最终答案无需单位。不要对答案进行四舍五入。",
            "solution": "该问题是有效的。它在科学上基于角动量的量子理论，问题陈述清晰，提供了足够的信息以获得唯一解，并且表述客观。所有定义和要求在理论和计算物理学中都是标准的。\n\n该问题要求完成两个主要任务：首先，推导 Gaunt 系数用 Wigner $3j$ 符号表示的一般表达式；其次，利用该表达式计算一个具体积分。\n\n**第一部分：Gaunt 系数表达式**\n\nGaunt 系数 $G(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3})$ 是三个球谐函数乘积的全空间积分。通过应用旋转群的表示理论（即 Wigner-Eckart 定理的推论），可以证明该积分与 Wigner 3j 符号有直接的解析关系。其标准表达式为：\n$$\nG(l_{1} m_{1}; l_{2} m_{2}; l_{3} m_{3}) = \\int Y_{l_{1} m_{1}} Y_{l_{2} m_{2}} Y_{l_{3} m_{3}} d\\Omega = \\sqrt{\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\pi}} \\begin{pmatrix} l_1  l_2  l_3 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} l_1  l_2  l_3 \\\\ m_1  m_2  m_3 \\end{pmatrix}\n$$\n这个表达式系统地包含了所有决定积分是否为零的选择定则：\n1.  **磁量子数守恒**：$m_1 + m_2 + m_3 = 0$。这是由第二个 3j 符号非零的条件所要求的。\n2.  **三角不等式**：三个角动量 $(l_1, l_2, l_3)$ 必须能构成一个三角形，即任意两数之和大于等于第三数。\n3.  **宇称选择定则**：角动量之和 $l_1 + l_2 + l_3$ 必须为偶数。这是由第一个 3j 符号 $\\begin{pmatrix} l_1  l_2  l_3 \\\\ 0  0  0 \\end{pmatrix}$ 非零的条件决定的。\n\n**第二部分：具体积分计算**\n\n我们需要计算积分 $I = \\int Y_{1,0}(\\Omega)\\, Y_{2,0}(\\Omega)\\, Y_{1,0}(\\Omega)\\, d\\Omega$。\n这对应于 Gaunt 系数，其中 $l_1=1, m_1=0$; $l_2=2, m_2=0$; $l_3=1, m_3=0$。\n我们首先检查选择定则：\n1.  磁量子数和：$0+0+0=0$。满足。\n2.  三角不等式：对于 $(1, 2, 1)$，我们有 $|1-2|=1 \\le 1 \\le 1+2=3$。满足。\n3.  宇称：$1+2+1=4$，是偶数。满足。\n由于所有选择定则都满足，积分非零。我们将这些值代入上述公式：\n$$\nI = \\sqrt{\\frac{(2 \\cdot 1+1)(2 \\cdot 2+1)(2 \\cdot 1+1)}{4\\pi}} \\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix} = \\sqrt{\\frac{3 \\cdot 5 \\cdot 3}{4\\pi}} \\left[ \\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix} \\right]^2\n$$\n从标准表格或计算可知，Wigner 3j 符号 $\\begin{pmatrix} 1  2  1 \\\\ 0  0  0 \\end{pmatrix}$ 的值为 $\\sqrt{\\frac{2}{15}}$。\n因此，积分的值为：\n$$\nI = \\sqrt{\\frac{45}{4\\pi}} \\left( \\sqrt{\\frac{2}{15}} \\right)^2 = \\sqrt{\\frac{45}{4\\pi}} \\cdot \\frac{2}{15} = \\frac{3\\sqrt{5}}{2\\sqrt{\\pi}} \\cdot \\frac{2}{15} = \\frac{3\\sqrt{5}}{\\sqrt{\\pi}} \\cdot \\frac{1}{15} = \\frac{\\sqrt{5}}{5\\sqrt{\\pi}}\n$$\n将结果整理为根号下的形式：\n$$\nI = \\frac{\\sqrt{5}}{\\sqrt{25\\pi}} = \\sqrt{\\frac{5}{25\\pi}} = \\sqrt{\\frac{1}{5\\pi}}\n$$\n这就是最终的解析结果。",
            "answer": "$$\\boxed{\\sqrt{\\frac{1}{5\\pi}}}$$"
        },
        {
            "introduction": "在真实的核壳模型计算中，我们经常处理作用于多粒子态上的算符，这需要对不同的角动量进行重新耦合。这项实践  指导你计算一个二体算符的矩阵元，这是多体物理学中的一项核心任务。它展示了维格纳 9j 符号作为一个系统性工具，在处理从单粒子到双粒子系统的复杂角动量重新耦合问题时的强大威力。",
            "id": "3611519",
            "problem": "在一个计算核物理壳模型的计算中，考虑一个双核子系统，该系统由一个处于总角动量为 $j_{p} = \\frac{3}{2}$ 的单粒子轨道上的质子和一个处于总角动量为 $j_{n} = \\frac{5}{2}$ 的单粒子轨道上的中子组成。这个两体算符由一个定义在单粒子空间上的 $k$ 阶一体球张量 $t^{(k)}$ 构建而成，形式为一个耦合张量积，\n$$\nO^{(K)} \\equiv \\left[t^{(k)}(p) \\otimes t^{(k)}(n)\\right]^{(K)},\n$$\n其中 $K$ 是两体算符在总角动量空间中的合成阶，标记 $(p)$ 和 $(n)$ 分别指定了其作用于质子和中子。假设一体约化矩阵元\n$$\nq_{p} \\equiv \\left\\langle j_{p} \\left\\| t^{(k)} \\right\\| j_{p} \\right\\rangle, \\qquad q_{n} \\equiv \\left\\langle j_{n} \\left\\| t^{(k)} \\right\\| j_{n} \\right\\rangle\n$$\n是有限且非零的。\n\n从量子力学中角动量耦合的第一性原理出发，特别是利用球张量算符的性质、Clebsch–Gordan系数和Wigner–Eckart定理，推导约化矩阵元\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle\n$$\n在双粒子耦合态 $\\left|(j_{p} j_{n}) J M\\right\\rangle$ 和 $\\left|(j_{p} j_{n}) J' M'\\right\\rangle$ 之间的解析表达式。然后，将该表达式具体化到物理上允许的情形，即 $k = 2$，$K = 2$，$J = 4$ 和 $J' = 2$，并将最终结果用 $q_{p}$、$q_{n}$ 和一个单一的角动量重耦合系数明确表示。你的最终答案必须是一个单一的闭合形式解析表达式。不需要进行数值取整，最终表达式中也不应包含任何物理单位。",
            "solution": "该问题是有效的，因为它在科学上基于量子角动量理论，问题陈述清晰且提供了所有必要信息，并且在数学上是一致的。因此，我们可以进行推导。\n\n目标是推导两体张量算符 $O^{(K)}$ 在耦合的双核子态之间的约化矩阵元的表达式。该算符定义为两个一体球张量算符 $t^{(k)}(p)$ 和 $t^{(k)}(n)$ 的耦合张量积，它们分别作用于质子和中子空间：\n$$\nO^{(K)} \\equiv \\left[t^{(k)}(p) \\otimes t^{(k)}(n)\\right]^{(K)}\n$$\n这些态是形式为 $\\left|(j_{p} j_{n}) J M\\right\\rangle$ 的耦合态。我们需要求解约化矩阵元 $\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle$。\n\n这是角动量代数应用中的一个标准问题。一个作用于耦合态 $\\left|(j_1 j_2) J\\right\\rangle$ 和 $\\left|(j'_1 j'_2) J'\\right\\rangle$ 之间的耦合张量算符 $X^{(K)} = [T^{(k_1)}(1) \\otimes T^{(k_2)}(2)]^{(K)}$ 的约化矩阵元由一个包含Wigner 9j符号的公认公式给出。此公式是Wigner-Eckart定理和角动量重耦合规则的直接推论。通用公式为：\n$$\n\\left\\langle (j_1 j_2) J \\left\\| \\left[T^{(k_1)}(1) \\otimes T^{(k_2)}(2)\\right]^{(K)} \\right\\| (j'_1 j'_2) J' \\right\\rangle = \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_1   j_2   J \\\\ j'_1   j'_2   J' \\\\ k_1   k_2   K \\end{Bmatrix} \\left\\langle j_1 \\left\\| T^{(k_1)} \\right\\| j'_1 \\right\\rangle \\left\\langle j_2 \\left\\| T^{(k_2)} \\right\\| j'_2 \\right\\rangle\n$$\n在此表达式中，量 $\\left\\langle j \\left\\| T^{(k)} \\right\\| j' \\right\\rangle$ 是一体算符的约化矩阵元。\n\n我们将此通用公式应用于当前问题的具体情况。对应关系如下：\n- 两个子系统是质子（$1 \\to p$）和中子（$2 \\to n$）。\n- 单粒子角动量为 $j_1=j'_1=j_p$ 和 $j_2=j'_2=j_n$，因为我们计算的是在单粒子空间中对角的矩阵元。\n- 一体张量算符是相同的，$T^{(k_1)} = T^{(k_2)} = t^{(k)}$，所以它们的阶相等，$k_1=k_2=k$。\n- 两体算符是 $O^{(K)}$，耦合态是 $\\left|(j_p j_n) J\\right\\rangle$ 和 $\\left|(j_p j_n) J'\\right\\rangle$。\n\n将这些代入通用公式，我们得到：\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle = \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_p   j_n   J \\\\ j_p   j_n   J' \\\\ k   k   K \\end{Bmatrix} \\left\\langle j_p \\left\\| t^{(k)} \\right\\| j_p \\right\\rangle \\left\\langle j_n \\left\\| t^{(k)} \\right\\| j_n \\right\\rangle\n$$\n题目将一体约化矩阵元定义为 $q_{p} \\equiv \\left\\langle j_{p} \\left\\| t^{(k)} \\right\\| j_{p} \\right\\rangle$ 和 $q_{n} \\equiv \\left\\langle j_{n} \\left\\| t^{(k)} \\right\\| j_{n} \\right\\rangle$。代入这些定义，可得到所求两体约化矩阵元的通用解析表达式：\n$$\n\\left\\langle (j_{p} j_{n}) J \\left\\| O^{(K)} \\right\\| (j_{p} j_{n}) J' \\right\\rangle = q_p q_n \\sqrt{(2J+1)(2J'+1)(2K+1)} \\begin{Bmatrix} j_p   j_n   J \\\\ j_p   j_n   J' \\\\ k   k   K \\end{Bmatrix}\n$$\n这样就完成了推导的第一部分。\n\n接下来，我们将此结果具体化到题目给定的特定值：\n- 质子角动量：$j_p = \\frac{3}{2}$\n- 中子角动量：$j_n = \\frac{5}{2}$\n- 一体张量算符的阶：$k = 2$\n- 两体算符的总阶：$K = 2$\n- 初始总角动量：$J = 4$\n- 最终总角动量：$J' = 2$\n\n我们将这些值代入我们推导出的表达式中。首先，我们计算包含角动量量子数的前置因子：\n$$\n\\sqrt{(2J+1)(2J'+1)(2K+1)} = \\sqrt{(2(4)+1)(2(2)+1)(2(2)+1)} = \\sqrt{(9)(5)(5)} = \\sqrt{225} = 15\n$$\nWigner 9j符号变为：\n$$\n\\begin{Bmatrix}\nj_p   j_n   J \\\\ j_p   j_n   J' \\\\ k   k   K\n\\end{Bmatrix}\n=\n\\begin{Bmatrix}\n\\frac{3}{2}   \\frac{5}{2}   4 \\\\\n\\frac{3}{2}   \\frac{5}{2}   2 \\\\\n2   2   2\n\\end{Bmatrix}\n$$\n这些量子数的有效性可以通过三角不等式来验证。对于耦合：\n- $(j_p, j_n) \\to J, J'$: $|\\frac{5}{2} - \\frac{3}{2}| = 1 \\le \\{2, 4\\} \\le \\frac{5}{2} + \\frac{3}{2} = 4$。此条件满足。\n- $(J', K) \\to J$: $|2 - 2| = 0 \\le 4 \\le 2 + 2 = 4$。此条件满足。\n- $(k,k) \\to K$: $|2-2|=0 \\le 2 \\le 2+2=4$。此条件满足。\n\n结合前置因子和特定的9j符号，具体化的约化矩阵元的最终表达式为：\n$$\n\\left\\langle \\left(j_{p}=\\frac{3}{2}, j_{n}=\\frac{5}{2}\\right) J=4 \\left\\| O^{(K=2)} \\right\\| \\left(j_{p}=\\frac{3}{2}, j_{n}=\\frac{5}{2}\\right) J'=2 \\right\\rangle = 15 \\, q_p \\, q_n \\begin{Bmatrix} \\frac{3}{2}   \\frac{5}{2}   4 \\\\ \\frac{3}{2}   \\frac{5}{2}   2 \\\\ 2   2   2 \\end{Bmatrix}\n$$\n该表达式按照要求，用给定的量 $q_p$、$q_n$ 和一个单一的角动量重耦合系数（Wigner 9j符号）表示。9j符号是一个基本量，代表了一个闭合形式的解析表达式。",
            "answer": "$$ \\boxed{15 \\, q_p \\, q_n \\begin{Bmatrix} \\frac{3}{2}   \\frac{5}{2}   4 \\\\ \\frac{3}{2}   \\frac{5}{2}   2 \\\\ 2   2   2 \\end{Bmatrix}} $$"
        },
        {
            "introduction": "大规模计算物理代码依赖于角动量耦合规则的正确实现；这些规则中的错误可能导致难以发现的隐蔽程序错误。这最后一个练习  将你从理论计算带入实际代码开发，挑战你构建一个能自动验证耦合方案的诊断工具。这项实践强调了将理论约束转化为稳健算法的重要性，这是任何计算物理学家都必须掌握的关键技能。",
            "id": "3611517",
            "problem": "构建一个程序，实现一个用于诊断角动量重耦合链的工具，该耦合链通过 Wigner $6j$ 和 Wigner $9j$ 符号表示。程序必须接受一个由离散步骤组成的规范，其中每个步骤是两种类型之一：Wigner $6j$ 符号或 Wigner $9j$ 符号。目标是在每个中间耦合处自动检查角动量三角形条件，并在出现非法耦合时建议最小修正。\n\n从基本基础开始：角动量相加的规则以及相关的 Clebsch-Gordan 系数的非零条件。在此基础上，允许的耦合受到三角形条件的约束。对于表示 $j_{1}$ 和 $j_{2}$ 耦合到合成角动量 $j_{3}$ 的任何三元组 $(j_{1}, j_{2}, j_{3})$，三角形条件为：\n- 三角不等式：$$|j_{1} - j_{2}| \\leq j_{3} \\leq j_{1} + j_{2}.$$\n- 宇称（整数性）条件：$$j_{1} + j_{2} + j_{3} \\in \\mathbb{Z}.$$\n\n为避免半整数角动量中的浮点歧义，将每个角动量 $j$ 表示为整数 $2j$。因此，每个 $j$ 由一个非负整数 $n = 2j$ 表示。三角形条件随后变为：\n- $$|n_{1} - n_{2}| \\leq n_{3} \\leq n_{1} + n_{2},$$\n- $$n_{1} + n_{2} + n_{3} \\equiv 0 \\pmod{2}.$$\n\n对于写为\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f\n\\end{array}\\right\\}$$\n的 Wigner $6j$ 符号，其非零条件意味着四个不同的三角形条件必须同时成立：\n- $$(a, b, c),$$\n- $$(a, e, f),$$\n- $$(d, b, f),$$\n- $$(d, e, c),$$\n这意味着这些三元组中的每一个都必须满足上述的三角不等式和宇稱条件。\n\n对于写为\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f \\\\\ng  h  i\n\\end{array}\\right\\}$$\n的 Wigner $9j$ 符号，其非零条件意味着六个不同的三角形条件必须同时成立：所有三行和所有三列都必须形成有效的耦合三元组：\n- 行三角形：$$(a, b, c),\\quad (d, e, f),\\quad (g, h, i),$$\n- 列三角形：$$(a, d, g),\\quad (b, e, h),\\quad (c, f, i).$$\n\n在此问题中，每个步骤为 $6j$ 或 $9j$ 符号中的条目提供整数标签。一个全局映射为每个标签分配一个整数值 $n = 2j$。一些标签是初级（外部）角动量，而其他标签是由耦合产生的中间量；但是，您的检查过程仅需要当前值来验证三角形并提出修正。在每个三角形中，将第三个条目视为最小修正的目标，这是耦合 $(j_{1}, j_{2}) \\to j_{3}$ 的标准约定。\n\n最小修正规则：对于无效三角形 $(n_{1}, n_{2}, n_{3})$，为 $n_{3}$ 提出一个修正，使得绝对变化 $|n_{3}^{\\text{new}} - n_{3}|$ 最小化，并满足以下约束条件：\n- $$|n_{1} - n_{2}| \\leq n_{3}^{\\text{new}} \\leq n_{1} + n_{2},$$\n- $$n_{1} + n_{2} + n_{3}^{\\text{new}} \\equiv 0 \\pmod{2}.$$\n如果最小绝对变化出现相等的情况（两个候选值同样接近），则选择较小的 $n_{3}^{\\text{new}}$。\n\n您的程序必须：\n- 确定性地编码测试用例。\n- 对于每个测试用例，验证符号链所隐含的所有三角形。\n- 对于每个无效三角形，根据上述规则为三元组的第三个条目建议一个最小修正。\n- 将每个测试用例的结果汇总到下面指定的最终输出格式中。\n\n如上所述，用其两倍的整数 $n = 2j$ 表示每个角动量。没有需要报告的物理单位。\n\n测试套件：\n提供以下测试用例。在每个用例中，映射指定了标签标识符到值的对应关系，步骤指定了检查序列。所有标签和参数都是表示 $2j$ 的整数。\n\n- 测试用例 $1$（有效的 $6j$）：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 4$, $5 \\mapsto 3$, $6 \\mapsto 2$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n- 测试用例 $2$（边界上的有效 $6j$）：\n  - 标签映射：$1 \\mapsto 4$, $2 \\mapsto 2$, $3 \\mapsto 4$, $4 \\mapsto 5$, $5 \\mapsto 1$, $6 \\mapsto 3$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n- 测试用例 $3$（因合成角动量宇称无效的 $6j$）：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 2$, $4 \\mapsto 4$, $5 \\mapsto 3$, $6 \\mapsto 2$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n- 测试用例 $4$（有效的 $9j$）：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 1$, $5 \\mapsto 3$, $6 \\mapsto 4$, $7 \\mapsto 2$, $8 \\mapsto 3$, $9 \\mapsto 5$。\n  - 步骤：一个 $9j$ 步骤，矩阵行为 $[1,2,3]$, $[4,5,6]$, $[7,8,9]$。\n\n- 测试用例 $5$（具有冲突三角形的无效 $9j$）：\n  - 标签映射：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 3$, $4 \\mapsto 1$, $5 \\mapsto 3$, $6 \\mapsto 4$, $7 \\mapsto 2$, $8 \\mapsto 2$, $9 \\mapsto 5$。\n  - 步骤：一个 $9j$ 步骤，矩阵行为 $[1,2,3]$, $[4,5,6]$, $[7,8,9]$。\n\n- 测试用例 $6$（合成角动量超出范围的无效 $6j$）：\n  - 标签映射：$1 \\mapsto 2$, $2 \\mapsto 1$, $3 \\mapsto 1$, $4 \\mapsto 3$, $5 \\mapsto 2$, $6 \\mapsto 5$。\n  - 步骤：一个 $6j$ 步骤，条目为 $(1,2,3;4,5,6)$。\n\n最终输出格式：\n对于每个测试用例，生成一个列表结果\n$$[\\text{valid}, V, F],$$\n其中 $\\text{valid}$ 是一个布尔值，指示链中的所有三角形是否有效（$\\text{True}$ 或 $\\text{False}$），$V$ 是违反条件的三角形的整数计数，而 $F$ 是一个包含对 $[\\,\\ell, n_{\\text{new}}\\,]$ 的列表，每个对代表一个违反条件的三角形，其中 $\\ell$ 是标签标识符，$n_{\\text{new}}$ 是根据最小修正规则为该标签建议的修正值。如果多个三角形建议对同一个标签进行修正，则按其在链中出现的顺序列出每个建议。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来、无空格的逗号分隔列表形式的结果，例如\n$$[r_{1},r_{2},\\dots],$$\n其中每个 $r_{k}$ 是测试用例 $k$ 的列表，同样以无空格的方式序列化。与上述测试套件对应的输出必须严格按照此序列化形式打印。",
            "solution": "该问题要求构建一个计算工具，用于验证量子角动量理论中的耦合方案，特别是涉及 Wigner $6j$ 和 $9j$ 符号的方案。此任务的核心在于重复应用支配角动量相加的基本三角形条件。\n\n一个角动量耦合，表示为 $\\vec{J} = \\vec{J}_1 + \\vec{J}_2$，其中 $J$、$J_1$ 和 $J_2$ 是相应算符的量子数，仅当这三个量子数 $(j_1, j_2, j)$ 构成的三元组满足特定条件时才被允许。这些条件确保 Clebsch-Gordan 系数 $\\langle j_1, m_1; j_2, m_2 | j, m \\rangle$ 不为零。量子数 $j$ 必须是非负整数或半整数。为了统一处理这两种情况并避免浮点运算，标准做法是将每个角动量 $j$ 用非负整数 $n \\equiv 2j$ 来表示。在此变换下，有效耦合三元组 $(n_1, n_2, n_3)$ 的条件变为：\n1. 三角不等式：$|n_1 - n_2| \\leq n_3 \\leq n_1 + n_2$。这确保了矢量的大小可以构成一个闭合三角形。\n2. 宇称条件：$n_1 + n_2 + n_3 \\equiv 0 \\pmod{2}$。这等效于条件 $j_1 + j_2 + j_3$ 必须为整数，该条件保持了波函数的旋转性质。\n\nWigner $6j$ 和 $9j$ 符号是在多个角动量重耦合中出现的标量。它们的非零性取决于是否同时满足若干个这样的三角形条件。\n\n对于一个 Wigner $6j$ 符号，\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f\n\\end{array}\\right\\}$$\n其中每个条目都是一个 $j$ 量子数，有四个相关的耦合三元组必须全部有效。这些三元组代表与 $6j$ 符号相关的四面体图中的四个耦合。用 $n=2j$ 整数表示，它们是：$(n_a, n_b, n_c)$、$(n_a, n_e, n_f)$、$(n_d, n_b, n_f)$ 和 $(n_d, n_e, n_c)$。\n\n对于一个 Wigner $9j$ 符号，\n$$\\left\\{\\begin{array}{ccc}\na  b  c \\\\\nd  e  f \\\\\ng  h  i\n\\end{array}\\right\\}$$\n它描述了四个角动量的两种不同耦合方案之间的转换，其非零条件是每一行和每一列都必须形成一个有效的耦合三元组。这导致需要验证六个三元组：\n- 行：$(n_a, n_b, n_c)$、$(n_d, n_e, n_f)$、$(n_g, n_h, n_i)$。\n- 列：$(n_a, n_d, n_g)$、$(n_b, n_e, n_h)$、$(n_c, n_f, n_i)$。\n\n解决该问题的算法实现如下：\n首先，定义一个 `check_triangle` 函数来验证单个三元组 $(n_1, n_2, n_3)$。它检查三角不等式和宇称条件是否都满足。如果三元组无效，则根据问题的规范，继续为第三个元素 $n_3$ 寻找一个“最小修正”。\n\n最小修正逻辑被封装在 `find_minimal_fix` 函数中。对于给定的配对 $(n_1, n_2)$ 和一个无效的 $n_3$，该函数确定新第三元素 $n_3^{\\text{new}}$ 的所有可能允许值的集合。一个整数 $k$ 是允许值，如果它满足 $|n_1 - n_2| \\leq k \\leq n_1 + n_2$ 并且 $n_1 + n_2 + k \\equiv 0 \\pmod{2}$。然后，该函数遍历此允许值集合，找到一个值 $n_{3,\\text{best}}^{\\text{new}}$，它能最小化绝对差 $|n_3^{\\text{new}} - n_3|$。如果出现相等的情况，即两个允许值与 $n_3$ 等距，则选择两者中较小的一个。\n\n主程序逻辑遍历一系列测试用例。对于每个用例，它从提供的映射中将整数标签解析为其对应的 $n=2j$ 值。然后，它识别要检查的符号类型（$6j$ 或 $9j$）。\n\n- 如果一个 $6j$ 符号由标签 $(l_a,l_b,l_c; l_d,l_e,l_f)$ 指定，程序会形成四个所需的值三元组 $(n_a, n_b, n_c)$、$(n_a, n_e, n_f)$、$(n_d, n_b, n_f)$ 和 $(n_d, n_e, n_c)$。它对每个三元组调用 `check_triangle`，并为每个三元组的第三个元素传递适当的目标标签（分别为 $l_c$、$l_f$、$l_f$、$l_c$）。\n\n- 如果指定了 $9j$ 符号，程序会形成对应于三行三列的六个三元组。然后它会顺序地为每个三元组调用 `check_triangle`。对于行三元组 $(n_1, n_2, n_3)$，目标是第三个元素的标签。类似地，对于列三元組 $(n_1, n_2, n_3)$，目标是其第三个元素的标签。\n\n对于每个测试用例，程序汇总结果：一个指示所有三元组是否有效的布尔标志、违规总数以及所有建议的最小修正的列表。使用自定义序列化函数将这些结果格式化为所需的精确字符串表示形式，确保没有多余的空格，并将布尔值转换为指定的 `True` 或 `False`。这种系统性的、基于原则的方法确保了诊断工具的正确性和稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_minimal_fix(n1, n2, n3):\n    \"\"\"\n    Calculates the minimal fix for n3 in the invalid triangle (n1, n2, n3).\n\n    Args:\n        n1 (int): 2*j1\n        n2 (int): 2*j2\n        n3 (int): The original, incorrect 2*j3\n\n    Returns:\n        int: The corrected value n3_new that minimizes |n3_new - n3|.\n    \"\"\"\n    n_min = np.abs(n1 - n2)\n    n_max = n1 + n2\n    \n    required_parity = (n1 + n2) % 2\n    \n    candidates = []\n    current_n = n_min\n    if current_n % 2 != required_parity:\n        current_n += 1\n    \n    while current_n = n_max:\n        candidates.append(current_n)\n        current_n += 2\n        \n    if not candidates:\n        return None \n        \n    min_delta = float('inf')\n    best_n3_new = -1\n    \n    for cand in candidates:\n        delta = np.abs(cand - n3)\n        if delta  min_delta:\n            min_delta = delta\n            best_n3_new = cand\n        elif delta == min_delta:\n            best_n3_new = min(best_n3_new, cand)\n            \n    return best_n3_new\n\ndef check_triangle(triangle_values, target_label_id):\n    \"\"\"\n    Validates a single triangle and returns a fix if invalid.\n    \n    Args:\n        triangle_values (tuple): A tuple of three integers (n1, n2, n3).\n        target_label_id (int): The label of the third element, n3.\n        \n    Returns:\n        tuple: A pair (is_valid, fix_suggestion). \n               fix_suggestion is None if valid, or a list [label, n_new] if invalid.\n    \"\"\"\n    n1, n2, n3 = triangle_values\n    \n    is_inequality_ok = (np.abs(n1 - n2) = n3) and (n3 = n1 + n2)\n    is_parity_ok = ((n1 + n2 + n3) % 2) == 0\n    \n    if is_inequality_ok and is_parity_ok:\n        return (True, None)\n    else:\n        n3_new = find_minimal_fix(n1, n2, n3)\n        return (False, [target_label_id, n3_new])\n\ndef serialize_result(data):\n    \"\"\"\n    Serializes test case results into the specified string format.\n    \"\"\"\n    if isinstance(data, bool):\n        return 'True' if data else 'False'\n    if isinstance(data, (int, np.integer)):\n        return str(data)\n    if isinstance(data, list):\n        return f\"[{','.join(map(serialize_result, data))}]\"\n    return str(data)\n    \ndef solve():\n    \"\"\"\n    Main function to run the diagnostic tool on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 4, 5: 3, 6: 2},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 4, 2: 2, 3: 4, 4: 5, 5: 1, 6: 3},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 2, 4: 4, 5: 3, 6: 2},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 1, 5: 3, 6: 4, 7: 2, 8: 3, 9: 5},\n            \"steps\": [(\"9j\", ((1, 2, 3), (4, 5, 6), (7, 8, 9)))]\n        },\n        {\n            \"label_map\": {1: 3, 2: 2, 3: 3, 4: 1, 5: 3, 6: 4, 7: 2, 8: 2, 9: 5},\n            \"steps\": [(\"9j\", ((1, 2, 3), (4, 5, 6), (7, 8, 9)))]\n        },\n        {\n            \"label_map\": {1: 2, 2: 1, 3: 1, 4: 3, 5: 2, 6: 5},\n            \"steps\": [(\"6j\", (1, 2, 3, 4, 5, 6))]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        label_map = case[\"label_map\"]\n        steps = case[\"steps\"]\n\n        is_overall_valid = True\n        violated_count = 0\n        fixes = []\n\n        for step_type, labels in steps:\n            if step_type == \"6j\":\n                l_a, l_b, l_c, l_d, l_e, l_f = labels\n                v_a, v_b, v_c, v_d, v_e, v_f = (label_map[l] for l in labels)\n                \n                triangles_to_check = [\n                    ((v_a, v_b, v_c), l_c),\n                    ((v_a, v_e, v_f), l_f),\n                    ((v_d, v_b, v_f), l_f),\n                    ((v_d, v_e, v_c), l_c)\n                ]\n            \n            elif step_type == \"9j\":\n                l_a, l_b, l_c = labels[0]\n                l_d, l_e, l_f = labels[1]\n                l_g, l_h, l_i = labels[2]\n                \n                v_a, v_b, v_c = (label_map[l] for l in labels[0])\n                v_d, v_e, v_f = (label_map[l] for l in labels[1])\n                v_g, v_h, v_i = (label_map[l] for l in labels[2])\n                \n                triangles_to_check = [\n                    # Rows\n                    ((v_a, v_b, v_c), l_c), ((v_d, v_e, v_f), l_f), ((v_g, v_h, v_i), l_i),\n                    # Columns\n                    ((v_a, v_d, v_g), l_g), ((v_b, v_e, v_h), l_h), ((v_c, v_f, v_i), l_i)\n                ]\n\n            for tri_values, target_label in triangles_to_check:\n                is_valid, fix = check_triangle(tri_values, target_label)\n                if not is_valid:\n                    is_overall_valid = False\n                    violated_count += 1\n                    fixes.append(fix)\n        \n        all_results.append([is_overall_valid, violated_count, fixes])\n\n    # Final print statement in the exact required format.\n    output_str = f\"[{','.join(map(serialize_result, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}