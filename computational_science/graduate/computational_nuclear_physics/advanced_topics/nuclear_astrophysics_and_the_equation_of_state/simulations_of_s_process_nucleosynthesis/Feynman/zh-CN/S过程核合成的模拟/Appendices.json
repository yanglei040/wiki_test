{
    "hands_on_practices": [
        {
            "introduction": "核合成网络通常由一组刚性常微分方程 (ODEs) 描述，这要求使用隐式数值方法来求解。本练习将指导您实现一个后向欧拉格式的求解器，这是一个基础而强大的隐式方法。通过使用牛顿-拉弗森方法求解由此产生的代数方程组，您将掌握计算核天体物理中的一项核心技能 。",
            "id": "3591040",
            "problem": "考虑一个代表核天体物理学中慢中子俘获过程（s-过程）片段的最小反应网络，该网络由两种粒子组成，并存在单向流动：$Y_1 \\xrightarrow{\\lambda_{n\\gamma}} Y_2 \\xrightarrow{\\lambda_{\\beta}} \\emptyset$。此处，$Y_1$ 表示种子同位素的每重子摩尔丰度，$Y_2$ 表示中子俘获产物的每重子摩尔丰度，$\\lambda_{n\\gamma}$ 表示有效中子俘获率（单位为 $\\mathrm{s}^{-1}$），$\\lambda_{\\beta}$ 表示β衰变率（单位为 $\\mathrm{s}^{-1}$）。假设在时间步长内这两个率都为常数。控制丰度的常微分方程（ODE; Ordinary Differential Equation）为\n$$\n\\frac{dY_1}{dt} = -\\lambda_{n\\gamma} Y_1,\\quad\n\\frac{dY_2}{dt} = \\lambda_{n\\gamma} Y_1 - \\lambda_{\\beta} Y_2.\n$$\n设时间步长为 $\\Delta t$（单位为秒），并用 $Y_1^n$ 和 $Y_2^n$ 表示在时间 $t^n$ 时的丰度，而 $Y_1^{n+1}$ 和 $Y_2^{n+1}$ 是在时间 $t^{n+1} = t^n + \\Delta t$ 时的未知数。使用后向欧拉法，对于一个通用常微分方程 $d\\mathbf{Y}/dt = \\mathbf{f}(\\mathbf{Y})$，其形式为 $\\mathbf{Y}^{n+1} = \\mathbf{Y}^{n} + \\Delta t\\, \\mathbf{f}(\\mathbf{Y}^{n+1})$。将关于 $Y_1^{n+1}$ 和 $Y_2^{n+1}$ 的隐式非线性系统表示为一个残差函数 $\\mathbf{R}(\\mathbf{U}) = \\mathbf{0}$，其中 $\\mathbf{U} = [Y_1^{n+1}, Y_2^{n+1}]^\\top$。推导该双粒子链的残差向量 $\\mathbf{R}(\\mathbf{U})$ 及其雅可比矩阵 $\\mathbf{J}(\\mathbf{U}) = \\partial \\mathbf{R}/\\partial \\mathbf{U}$。设计一个牛顿-拉弗森（NR）迭代法来求解 $\\mathbf{U}$，并基于残差范数和相对步长定义一个数学上精确的收敛判据。用牛顿-拉弗森法实现单步后向欧拉法，并将其应用于下方的测试套件。\n\n科学和数值要求：\n- 从上述反应率常微分方程出发。使用后向欧拉法进行时间离散化，并构建残差 $\\mathbf{R}(\\mathbf{U})$。解析地计算雅可比矩阵。\n- 使用牛顿-拉弗森求解器：对于迭代索引 $k$，更新 $\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\Delta \\mathbf{U}^{(k)}$，其中 $\\mathbf{J}(\\mathbf{U}^{(k)})\\, \\Delta \\mathbf{U}^{(k)} = -\\mathbf{R}(\\mathbf{U}^{(k)})$。\n- 收敛判据：当 $||\\mathbf{R}(\\mathbf{U}^{(k)})||_2 \\le \\varepsilon_{\\mathrm{res}}$ 和 $||\\Delta \\mathbf{U}^{(k)}||_2 / \\max\\{||\\mathbf{U}^{(k)}||_2, 1\\} \\le \\varepsilon_{\\mathrm{step}}$ 同时满足时，终止牛顿-拉弗森迭代。容差为 $\\varepsilon_{\\mathrm{res}} = 10^{-12}$ 和 $\\varepsilon_{\\mathrm{step}} = 10^{-12}$。\n- 如果 $\\Delta t = 0$，定义该步返回 $\\mathbf{U} = [Y_1^{n}, Y_2^{n}]^\\top$。\n- 单位：$\\lambda_{n\\gamma}$ 和 $\\lambda_{\\beta}$ 的单位是 $\\mathrm{s}^{-1}$，$\\Delta t$ 的单位是 $\\mathrm{s}$，丰度 $Y_1$ 和 $Y_2$ 是无量纲的。将输出的丰度表示为无量纲的浮点数。\n\n测试套件：\n- 情况1：$Y_1^n = 0.7$, $Y_2^n = 0.3$, $\\lambda_{n\\gamma} = 10^{-7}\\ \\mathrm{s}^{-1}$, $\\lambda_{\\beta} = 5\\times 10^{-8}\\ \\mathrm{s}^{-1}$, $\\Delta t = 10^{5}\\ \\mathrm{s}$。\n- 情况2：$Y_1^n = 1.0$, $Y_2^n = 0.0$, $\\lambda_{n\\gamma} = 10^{-5}\\ \\mathrm{s}^{-1}$, $\\lambda_{\\beta} = 10^{-5}\\ \\mathrm{s}^{-1}$, $\\Delta t = 10^{6}\\ \\mathrm{s}$。\n- 情况3（边界情况）：$Y_1^n = 0.5$, $Y_2^n = 0.5$, $\\lambda_{n\\gamma} = 10^{-3}\\ \\mathrm{s}^{-1}$, $\\lambda_{\\beta} = 10^{-3}\\ \\mathrm{s}^{-1}$, $\\Delta t = 0\\ \\mathrm{s}$。\n- 情况4（边缘情况，无β衰变）：$Y_1^n = 0.8$, $Y_2^n = 0.2$, $\\lambda_{n\\gamma} = 2\\times 10^{-6}\\ \\mathrm{s}^{-1}$, $\\lambda_{\\beta} = 0\\ \\mathrm{s}^{-1}$, $\\Delta t = 10^{6}\\ \\mathrm{s}$。\n- 情况5（边缘情况，无俘获）：$Y_1^n = 0.6$, $Y_2^n = 0.4$, $\\lambda_{n\\gamma} = 0\\ \\mathrm{s}^{-1}$, $\\lambda_{\\beta} = 10^{-7}\\ \\mathrm{s}^{-1}$, $\\Delta t = 10^{7}\\ \\mathrm{s}$。\n\n你的程序必须：\n- 使用推导出的残差和雅可比矩阵，实现带牛顿-拉弗森法的后向欧拉步。\n- 将其应用于测试套件中的五个情况，并为每个情况收集输出，格式为列表 $[Y_1^{n+1}, Y_2^{n+1}]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个包含两个浮点数的列表，顺序为 $[Y_1^{n+1}, Y_2^{n+1}]$。例如，一个包含两个用例的有效输出应如 $[[a,b],[c,d]]$。",
            "solution": "目标是使用后向欧拉法为一个由两个耦合常微分方程（ODE）组成的系统计算一个时间步。所得到的隐式代数方程组将使用牛顿-拉弗森（NR）迭代方案进行求解。\n\n控制丰度 $Y_1(t)$ 和 $Y_2(t)$ 的常微分方程系统由以下公式给出：\n$$\n\\frac{dY_1}{dt} = -\\lambda_{n\\gamma} Y_1\n$$\n$$\n\\frac{dY_2}{dt} = \\lambda_{n\\gamma} Y_1 - \\lambda_{\\beta} Y_2\n$$\n这可以写成向量形式 $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{f}(\\mathbf{Y})$，其中 $\\mathbf{Y} = [Y_1, Y_2]^\\top$，函数 $\\mathbf{f}(\\mathbf{Y})$ 为：\n$$\n\\mathbf{f}(\\mathbf{Y}) = \\begin{bmatrix} -\\lambda_{n\\gamma} Y_1 \\\\ \\lambda_{n\\gamma} Y_1 - \\lambda_{\\beta} Y_2 \\end{bmatrix}\n$$\n后向欧拉法将此常微分方程系统离散化为：\n$$\n\\mathbf{Y}^{n+1} = \\mathbf{Y}^{n} + \\Delta t\\, \\mathbf{f}(\\mathbf{Y}^{n+1})\n$$\n其中 $\\mathbf{Y}^n = [Y_1^n, Y_2^n]^\\top$ 表示在时间 $t^n$ 时的已知丰度，而 $\\mathbf{Y}^{n+1} = [Y_1^{n+1}, Y_2^{n+1}]^\\top$ 表示在时间 $t^{n+1} = t^n + \\Delta t$ 时的未知丰度。\n\n为了求解 $\\mathbf{Y}^{n+1}$，我们将问题构建为寻找残差函数 $\\mathbf{R}(\\mathbf{U}) = \\mathbf{0}$ 的根，其中 $\\mathbf{U} = \\mathbf{Y}^{n+1}$。残差通过重新排列后向欧拉方程来定义：\n$$\n\\mathbf{R}(\\mathbf{U}) = \\mathbf{U} - \\mathbf{Y}^n - \\Delta t\\, \\mathbf{f}(\\mathbf{U}) = \\mathbf{0}\n$$\n代入 $\\mathbf{f}(\\mathbf{U})$ 的具体形式，残差向量 $\\mathbf{R}(\\mathbf{U}) = [R_1(\\mathbf{U}), R_2(\\mathbf{U})]^\\top$ 的分量为：\n$$\nR_1(U_1, U_2) = U_1 - Y_1^n - \\Delta t (-\\lambda_{n\\gamma} U_1) = (1 + \\Delta t \\lambda_{n\\gamma}) U_1 - Y_1^n\n$$\n$$\nR_2(U_1, U_2) = U_2 - Y_2^n - \\Delta t (\\lambda_{n\\gamma} U_1 - \\lambda_{\\beta} U_2) = -\\Delta t \\lambda_{n\\gamma} U_1 + (1 + \\Delta t \\lambda_{\\beta}) U_2 - Y_2^n\n$$\n牛顿-拉弗森法需要雅可比矩阵 $\\mathbf{J}(\\mathbf{U}) = \\partial \\mathbf{R} / \\partial \\mathbf{U}$。雅可比矩阵的分量是残差分量关于 $\\mathbf{U}$ 各分量的偏导数：\n$$\n\\mathbf{J}(\\mathbf{U}) = \\begin{bmatrix} \\frac{\\partial R_1}{\\partial U_1} & \\frac{\\partial R_1}{\\partial U_2} \\\\ \\frac{\\partial R_2}{\\partial U_1} & \\frac{\\partial R_2}{\\partial U_2} \\end{bmatrix}\n$$\n计算这些导数可得：\n$$\n\\frac{\\partial R_1}{\\partial U_1} = 1 + \\Delta t \\lambda_{n\\gamma} \\quad , \\quad \\frac{\\partial R_1}{\\partial U_2} = 0\n$$\n$$\n\\frac{\\partial R_2}{\\partial U_1} = -\\Delta t \\lambda_{n\\gamma} \\quad , \\quad \\frac{\\partial R_2}{\\partial U_2} = 1 + \\Delta t \\lambda_{\\beta}\n$$\n因此，雅可比矩阵为：\n$$\n\\mathbf{J} = \\begin{bmatrix} 1 + \\Delta t \\lambda_{n\\gamma} & 0 \\\\ -\\Delta t \\lambda_{n\\gamma} & 1 + \\Delta t \\lambda_{\\beta} \\end{bmatrix}\n$$\n请注意，由于原始的常微分方程系统是线性的，雅可比矩阵 $\\mathbf{J}$ 是常数，不依赖于 $\\mathbf{U}$。这意味着从后向欧拉法导出的代数系统也是线性的。牛顿-拉弗森法应用于线性系统时，会在单次迭代中收敛到精确解。\n\n牛顿-拉弗森迭代方案由以下更新规则定义：\n$$\n\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\Delta \\mathbf{U}^{(k)}\n$$\n其中 $\\mathbf{U}^{(k)}$ 是第 $k$ 次迭代的解，更新向量 $\\Delta \\mathbf{U}^{(k)}$ 通过求解以下线性系统获得：\n$$\n\\mathbf{J}(\\mathbf{U}^{(k)}) \\Delta \\mathbf{U}^{(k)} = -\\mathbf{R}(\\mathbf{U}^{(k)})\n$$\n该过程从一个初始猜测开始，通常是前一个时间步的解，即 $\\mathbf{U}^{(0)} = \\mathbf{Y}^n$。迭代持续进行，直到满足收敛判据。该判据基于残差的L2范数和相对更新步长的L2范数：\n$$\n||\\mathbf{R}(\\mathbf{U}^{(k)})||_2 \\le \\varepsilon_{\\mathrm{res}} \\quad \\text{and} \\quad \\frac{||\\Delta \\mathbf{U}^{(k)}||_2}{\\max(||\\mathbf{U}^{(k)}||_2, 1)} \\le \\varepsilon_{\\mathrm{step}}\n$$\n给定容差 $\\varepsilon_{\\mathrm{res}} = 10^{-12}$ 和 $\\varepsilon_{\\mathrm{step}} = 10^{-12}$。对于非零时间步长 $\\Delta t > 0$，第一次迭代（$k=0$）将计算出一个更新量 $\\Delta \\mathbf{U}^{(0)}$，使得 $\\mathbf{U}^{(1)} = \\mathbf{U}^{(0)} + \\Delta \\mathbf{U}^{(0)}$ 是该线性系统的精确解。第二次迭代（$k=1$）将会发现残差 $\\mathbf{R}(\\mathbf{U}^{(1)})$ 和后续的更新量 $\\Delta \\mathbf{U}^{(1)}$ 均为零（在机器精度范围内），从而满足收敛判据并终止循环。\n\n对于 $\\Delta t = 0$ 的特殊情况，后向欧拉方案变为 $\\mathbf{Y}^{n+1} = \\mathbf{Y}^n$，因此解就是初始状态 $[Y_1^n, Y_2^n]^\\top$。\n\n实现将包括一个函数，该函数接收初始丰度 $\\mathbf{Y}^n$ 和系统参数 $\\lambda_{n\\gamma}$、$\\lambda_{\\beta}$ 和 $\\Delta t$。它将单独处理 $\\Delta t=0$ 的情况。否则，它将初始化 $\\mathbf{U}^{(0)} = \\mathbf{Y}^n$ 并进入NR循环。在循环内部，它将计算 $\\mathbf{R}$ 和 $\\mathbf{J}$，求解 $\\Delta\\mathbf{U}$，并在应用更新以进行下一次迭代之前检查收敛性。此过程将应用于所提供的测试套件中的每个案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_step_with_newton(Yn, l_ng, l_b, dt):\n    \"\"\"\n    Computes a single backward Euler step for the 2-species reaction network\n    using a Newton-Raphson solver for the implicit system.\n\n    Args:\n        Yn (list or tuple): Initial abundances [Y1, Y2] at time t^n.\n        l_ng (float): Neutron-capture rate lambda_n,gamma in 1/s.\n        l_b (float): Beta-decay rate lambda_beta in 1/s.\n        dt (float): Timestep Delta t in s.\n\n    Returns:\n        list: Final abundances [Y1, Y2] at time t^{n+1}.\n    \"\"\"\n    # Define convergence tolerances and maximum iterations\n    eps_res = 1e-12\n    eps_step = 1e-12\n    max_iter = 10\n\n    # Handle the boundary case where the timestep is zero, as specified.\n    if dt == 0.0:\n        return list(Yn)\n\n    # Initial guess for U = [Y1(n+1), Y2(n+1)] is the value at t^n.\n    U = np.array(Yn, dtype=np.float64)\n    Yn_arr = np.array(Yn, dtype=np.float64)\n\n    # The Jacobian matrix is constant for this linear ODE system.\n    # J = [[1 + dt*l_ng,        0],\n    #      [-dt*l_ng,     1 + dt*l_b]]\n    J = np.array([\n        [1.0 + dt * l_ng, 0.0],\n        [-dt * l_ng, 1.0 + dt * l_b]\n    ], dtype=np.float64)\n\n    # Newton-Raphson iteration loop\n    for k in range(max_iter):\n        # Calculate the residual R(U) for the current iterate U.\n        # R(U) = U - Yn - dt*f(U)\n        # R1 = U1 - Y1n - dt*(-l_ng*U1) = (1 + dt*l_ng)*U1 - Y1n\n        # R2 = U2 - Y2n - dt*(l_ng*U1 - l_b*U2) = -dt*l_ng*U1 + (1 + dt*l_b)*U2 - Y2n\n        R1 = (1.0 + dt * l_ng) * U[0] - Yn_arr[0]\n        R2 = (-dt * l_ng) * U[0] + (1.0 + dt * l_b) * U[1] - Yn_arr[1]\n        R = np.array([R1, R2], dtype=np.float64)\n        \n        res_norm = np.linalg.norm(R)\n\n        # Solve the linear system J * delta_U = -R for the update vector delta_U.\n        delta_U = np.linalg.solve(J, -R)\n        \n        # Calculate the relative step size for convergence check.\n        # The norm is relative to the norm of the current solution vector U.\n        delta_U_norm = np.linalg.norm(delta_U)\n        U_norm = np.linalg.norm(U)\n        # Use max(U_norm, 1.0) to avoid division by zero if U is the zero vector.\n        step_norm = delta_U_norm / max(U_norm, 1.0)\n\n        # The problem asks to check convergence based on R(U^k) and delta_U^k.\n        # If both conditions are met, the loop terminates.\n        if res_norm = eps_res and step_norm = eps_step:\n            break\n            \n        # Update the solution vector for the next iteration.\n        U = U + delta_U\n    \n    return U.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Y1n, Y2n, lambda_ng, lambda_beta, dt)\n        (0.7, 0.3, 1e-7, 5e-8, 1e5),\n        (1.0, 0.0, 1e-5, 1e-5, 1e6),\n        (0.5, 0.5, 1e-3, 1e-3, 0.0),\n        (0.8, 0.2, 2e-6, 0.0, 1e6),\n        (0.6, 0.4, 0.0, 1e-7, 1e7),\n    ]\n\n    results = []\n    for case in test_cases:\n        Yn = [case[0], case[1]]\n        l_ng, l_b, dt = case[2], case[3], case[4]\n        \n        Y_next = solve_step_with_newton(Yn, l_ng, l_b, dt)\n        results.append(Y_next)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces, e.g., [[a,b],[c,d]].\n    # str(list) in Python adds spaces, so we build the string carefully.\n    formatted_results = ','.join(str(res).replace(' ', '') for res in results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在开发任何模拟代码之后，验证其正确性是至关重要的一步。本练习介绍“人造解验证法”(Method of Manufactured Solutions)，这是一种严格验证代码收敛阶数的标准技术。通过确认您的求解器能够达到其理论精度，您将为后续更复杂的物理模拟建立可靠的基础 。",
            "id": "3591084",
            "problem": "为与计算核物理中慢中子俘获过程 (s-过程) 核合成模拟相关的俘获-衰变网络积分器，设计并实现一种数值收敛性的人造解验证。使用以下具有物理动机的基础和假设。\n\n基础方程和定义：考虑一个由含时丰度 $Y_1(t)$ 和 $Y_2(t)$ 构成的最小双同位素俘获-衰变网络，其演化由以下方程组决定：\n$$\n\\frac{dY_1}{dt} \\;=\\; -k_c \\, Y_1 \\;+\\; S_1(t),\n$$\n$$\n\\frac{dY_2}{dt} \\;=\\; k_c \\, Y_1 \\;-\\; \\lambda_\\beta \\, Y_2 \\;+\\; S_2(t),\n$$\n其中 $k_c$ 是中子俘获率 (单位为 $\\mathrm{s^{-1}}$)，$\\lambda_\\beta$ 是β衰变率 (单位为 $\\mathrm{s^{-1}}$)，$S_i(t)$ 是人造源项 (单位为 $\\mathrm{s^{-1}}$)，其构造方式使得选定的解析丰度轨迹 $(Y_1(t), Y_2(t))$ 成为该系统的精确解。初始条件为 $Y_i(0)$ 等于选定的解析解在 $t=0$ 时的值。三角函数中的角度必须以弧度为单位。\n\n人造解方法：选择光滑的严格正函数 $Y_1(t)$ 和 $Y_2(t)$，并定义\n$$\nS_1(t) \\;=\\; \\frac{dY_1}{dt} \\;+\\; k_c \\, Y_1,\\qquad\nS_2(t) \\;=\\; \\frac{dY_2}{dt} \\;-\\; k_c \\, Y_1 \\;+\\; \\lambda_\\beta \\, Y_2,\n$$\n以使所选的 $Y_i(t)$ 精确求解该网络。此构造必须在代码中直接实现。\n\n待验证的数值积分器：实现\n- 一阶显式向前欧拉法，以及\n- 二阶显式 Heun (改进欧拉) Runge-Kutta 法。\n两种方法都使用上述源项 $S_i(t)$、恒定速率 $k_c$ 和 $\\lambda_\\beta$ 以及步长 $h$，通过系统的右端项从 $t_n$ 推进到 $t_{n+1}=t_n+h$。定义单步右端项为\n$$\n\\mathbf{f}(t, \\mathbf{Y}) \\;=\\; \\begin{bmatrix}\n-k_c Y_1 + S_1(t) \\\\\nk_c Y_1 - \\lambda_\\beta Y_2 + S_2(t)\n\\end{bmatrix}.\n$$\n向前欧拉更新：$\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\, \\mathbf{f}(t_n, \\mathbf{Y}_n)$。\nHeun 更新：$\\mathbf{K}_1=\\mathbf{f}(t_n, \\mathbf{Y}_n)$，$\\mathbf{K}_2=\\mathbf{f}(t_n+h, \\mathbf{Y}_n + h \\mathbf{K}_1)$，$\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + \\frac{h}{2}(\\mathbf{K}_1+\\mathbf{K}_2)$。\n\n误差与观测精度阶：对于固定的最终时间 $T$ 和步长 $h_1$、$h_2$ (其中 $h_2 = h_1/2$)，定义步长为 $h$ 时的最终时刻全局误差为\n$$\nE(h) \\;=\\; \\max\\left(\\,\\left|Y_1^{\\text{num}}(T;h) - Y_1^{\\text{true}}(T)\\right|,\\,\\left|Y_2^{\\text{num}}(T;h) - Y_2^{\\text{true}}(T)\\right|\\,\\right).\n$$\n通过 Richardson 公式估计观测阶 $p$\n$$\np \\;=\\; \\frac{\\ln\\!\\left(\\frac{E(h_1)}{E(h_2)}\\right)}{\\ln\\!\\left(\\frac{h_1}{h_2}\\right)}.\n$$\n\n人造解与测试套件：使用以下两对解析丰度，所有三角函数角度均以弧度为单位。\n- 解析对 A：\n$$\nY_1^{A}(t)= e^{-0.3\\, t} \\;+\\; 0.1 \\,\\sin\\!\\left(2\\pi t\\right),\\qquad\nY_2^{A}(t)= 0.5\\, e^{-0.1\\, t} \\;+\\; 0.05 \\,\\cos\\!\\left(2\\pi t\\right).\n$$\n- 解析对 B：\n$$\nY_1^{B}(t)= 0.8\\, e^{-0.5\\, t} \\;+\\; 0.05 \\,\\sin\\!\\left(3 t\\right),\\qquad\nY_2^{B}(t)= 0.3\\, e^{-0.2\\, t} \\;+\\; 0.02 \\,\\cos\\!\\left(4 t\\right).\n$$\n\n在每个测试用例中，根据指定的 $k_c$ 和 $\\lambda_\\beta$ 以及每一对解析解构造 $S_1(t)$ 和 $S_2(t)$。对于每个用例，使用 $t=0$ 时的精确初始条件进行初始化。\n\n提供一个程序，为以下四个用例计算观测阶 $p$：\n- 用例1 (向前欧拉法，非刚性)：$k_c=0.2\\,\\mathrm{s^{-1}}$，$\\lambda_\\beta=0.4\\,\\mathrm{s^{-1}}$，$T=1.0\\,\\mathrm{s}$，$h_1=0.01\\,\\mathrm{s}$，$h_2=0.005\\,\\mathrm{s}$，解析对 A。\n- 用例2 (Heun法，非刚性)：$k_c=0.2\\,\\mathrm{s^{-1}}$，$\\lambda_\\beta=0.4\\,\\mathrm{s^{-1}}$，$T=1.0\\,\\mathrm{s}$，$h_1=0.01\\,\\mathrm{s}$，$h_2=0.005\\,\\mathrm{s}$，解析对 A。\n- 用例3 (向前欧拉法，中度刚性但在给定步长下稳定)：$k_c=2.0\\,\\mathrm{s^{-1}}$，$\\lambda_\\beta=5.0\\,\\mathrm{s^{-1}}$，$T=0.5\\,\\mathrm{s}$，$h_1=\\frac{0.5}{800}\\,\\mathrm{s}$，$h_2=\\frac{0.5}{1600}\\,\\mathrm{s}$，解析对 B。\n- 用例4 (Heun法，中度刚性)：$k_c=2.0\\,\\mathrm{s^{-1}}$，$\\lambda_\\beta=5.0\\,\\mathrm{s^{-1}}$，$T=0.5\\,\\mathrm{s}$，$h_1=\\frac{0.5}{800}\\,\\mathrm{s}$，$h_2=\\frac{0.5}{1600}\\,\\mathrm{s}$，解析对 B。\n\n单位约定：时间 $t$ 的单位是秒，速率 $k_c$ 和 $\\lambda_\\beta$ 的单位是 $\\mathrm{s^{-1}}$，丰度 $Y_i$ 是无量纲的，观测阶 $p$ 也是无量纲的。\n\n最终输出规范：您的程序应生成单行输出，其中包含四个观测阶，按用例1到4的顺序排列，形式为逗号分隔的列表并用方括号括起来，例如 $\\left[\\;p_1,p_2,p_3,p_4\\;\\right]$。输出必须是实数 (浮点数)。不得打印任何额外文本。",
            "solution": "该问题是有效的。它基于人造解方法提出了一个清晰、自洽且科学上合理的任务，该方法是计算物理学中的一种标准验证技术。所有参数、方程和步骤都得到了明确的定义。\n\n解决方案的设计过程是：首先实现人造解的数学构造，然后实现数值积分器，最后组织验证测试套件以计算每个指定用例的观测精度阶。\n\n**1. 数学表述与人造解**\n\n问题的核心是描述丰度 $Y_1(t)$ 和 $Y_2(t)$ 的两个耦合常微分方程 (ODE) 组成的系统：\n$$\n\\frac{d\\mathbf{Y}}{dt} \\;=\\; \\mathbf{f}(t, \\mathbf{Y}), \\quad \\text{其中} \\quad \\mathbf{Y}(t) = \\begin{bmatrix} Y_1(t) \\\\ Y_2(t) \\end{bmatrix}.\n$$\n右端项函数 $\\mathbf{f}(t, \\mathbf{Y})$ 定义为：\n$$\n\\mathbf{f}(t, \\mathbf{Y}) \\;=\\; \\begin{bmatrix}\n-k_c \\, Y_1(t) \\;+\\; S_1(t) \\\\\nk_c \\, Y_1(t) \\;-\\; \\lambda_\\beta \\, Y_2(t) \\;+\\; S_2(t)\n\\end{bmatrix}.\n$$\n人造解方法要求构造源项 $S_1(t)$ 和 $S_2(t)$，使得一个选定的解析函数 $\\mathbf{Y}^{\\text{true}}(t)$ 成为精确解。这通过将 $\\mathbf{Y}^{\\text{true}}(t)$ 代入常微分方程系统并求解源项来实现：\n$$\nS_1(t) \\;=\\; \\frac{dY_1^{\\text{true}}}{dt} \\;+\\; k_c \\, Y_1^{\\text{true}}(t),\n$$\n$$\nS_2(t) \\;=\\; \\frac{dY_2^{\\text{true}}}{dt} \\;-\\; k_c \\, Y_1^{\\text{true}}(t) \\;+\\; \\lambda_\\beta \\, Y_2^{\\text{true}}(t).\n$$\n为了实现这一点，我们需要解析解及其时间导数。\n\n对于解析对 A：\n$$\nY_1^{A}(t) = e^{-0.3t} + 0.1 \\sin(2\\pi t), \\qquad \\frac{dY_1^{A}}{dt} = -0.3 e^{-0.3t} + 0.2\\pi \\cos(2\\pi t).\n$$\n$$\nY_2^{A}(t) = 0.5 e^{-0.1t} + 0.05 \\cos(2\\pi t), \\qquad \\frac{dY_2^{A}}{dt} = -0.05 e^{-0.1t} - 0.1\\pi \\sin(2\\pi t).\n$$\n\n对于解析对 B：\n$$\nY_1^{B}(t) = 0.8 e^{-0.5t} + 0.05 \\sin(3t), \\qquad \\frac{dY_1^{B}}{dt} = -0.4 e^{-0.5t} + 0.15 \\cos(3t).\n$$\n$$\nY_2^{B}(t) = 0.3 e^{-0.2t} + 0.02 \\cos(4t), \\qquad \\frac{dY_2^{B}}{dt} = -0.06 e^{-0.2t} - 0.08 \\sin(4t).\n$$\n这些函数及其导数被实现，以便在任何时间 $t$ 动态计算源项 $S_1(t)$ 和 $S_2(t)$。\n\n**2. 数值积分器**\n\n使用两种显式数值方法求解从 t=0 到最终时间 T 的常微分方程系统。该系统以大小为 h 的离散时间步长向前推进。\n\n一阶向前欧拉法将解从第 $n$ 步更新到第 $n+1$ 步：\n$$\n\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\, \\mathbf{f}(t_n, \\mathbf{Y}_n).\n$$\n\n二阶 Heun 方法 (一种显式 Runge-Kutta 方法) 使用预估-校正方法来提高精度：\n$$\n\\mathbf{K}_1 = \\mathbf{f}(t_n, \\mathbf{Y}_n),\n$$\n$$\n\\mathbf{K}_2 = \\mathbf{f}(t_{n+1}, \\mathbf{Y}_n + h \\mathbf{K}_1), \\quad \\text{其中 } t_{n+1} = t_n+h,\n$$\n$$\n\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + \\frac{h}{2}(\\mathbf{K}_1 + \\mathbf{K}_2).\n$$\n两种方法都在一个通用的求解器函数中实现，可供任何测试用例调用。\n\n**3. 验证过程与精度阶**\n\n目标是验证所实现的积分器是否达到其理论精度阶。观测精度阶 $p$ 是通过对两次模拟的误差使用 Richardson 外推法计算得出的。\n\n对于每个测试用例，使用两种不同的步长 $h_1$ 和一个更精细的步长 $h_2 = h_1/2$ 来计算数值解，直至最终时间 $T$。对于给定的步长 $h$，在最终时间 $T$ 的全局误差定义为数值解与真实解析解之间的最大绝对差：\n$$\nE(h) = \\max\\left(\\,\\left|Y_1^{\\text{num}}(T;h) - Y_1^{\\text{true}}(T)\\right|,\\,\\left|Y_2^{\\text{num}}(T;h) - Y_2^{\\text{true}}(T)\\right|\\,\\right).\n$$\n这等价于误差向量的无穷范数，$\\|\\mathbf{Y}^{\\text{num}}(T;h) - \\mathbf{Y}^{\\text{true}}(T)\\|_\\infty$。\n\n然后使用以下公式估算观测精度阶 $p$：\n$$\np = \\frac{\\ln(E(h_1) / E(h_2))}{\\ln(h_1 / h_2)}.\n$$\n由于所有测试用例中 $h_1/h_2 = 2$，这可以简化为 $p = \\log_2(E(h_1) / E(h_2))$。像向前欧拉这样的一阶方法预期会得到 $p \\approx 1$，而像 Heun 法这样的二阶方法应该得到 $p \\approx 2$。\n\n**4. 算法结构**\n\n程序的结构旨在封装不同的数学组件，并方便执行测试套件。\n- **解析函数**：单独的函数为解析对A和B计算真实的丰度向量 $\\mathbf{Y}^{\\text{true}}(t)$ 及其导数 $d\\mathbf{Y}^{\\text{true}}/dt$。\n- **源项与右端项函数**：一个 `source_terms` 函数计算向量 $[S_1(t), S_2(t)]^T$。然后，`rhs` 函数使用此结果为给定的状态 $(t, \\mathbf{Y})$ 计算 $\\mathbf{f}(t, \\mathbf{Y})$。\n- **积分器**：一个 `integrate` 函数接收积分方法 ('euler' or 'heun')、问题参数 ($k_c, \\lambda_\\beta$) 和积分参数 ($T, h$) 作为输入。它用 t=0 时的真实值初始化解，即 $\\mathbf{Y}_0 = \\mathbf{Y}^{\\text{true}}(0)$，并迭代应用所选的更新规则 `int(round(T/h))` 步，以找到 $\\mathbf{Y}^{\\text{num}}(T;h)$。\n- **主循环**：程序的主体部分定义了四个测试用例。它遍历每个用例，运行积分器两次（分别针对 $h_1$ 和 $h_2$），计算误差 $E(h_1)$ 和 $E(h_2)$，计算观测阶 $p$，并存储结果。最后，它以要求的格式打印所有四个计算出的阶数。\n这种模块化设计确保了清晰性、正确性并遵守了问题规范。",
            "answer": "```python\nimport numpy as np\n\ndef true_solutions(t, pair_id):\n    \"\"\"Computes the true analytic solutions Y(t) for a given pair.\"\"\"\n    if pair_id == 'A':\n        y1 = np.exp(-0.3 * t) + 0.1 * np.sin(2.0 * np.pi * t)\n        y2 = 0.5 * np.exp(-0.1 * t) + 0.05 * np.cos(2.0 * np.pi * t)\n    elif pair_id == 'B':\n        y1 = 0.8 * np.exp(-0.5 * t) + 0.05 * np.sin(3.0 * t)\n        y2 = 0.3 * np.exp(-0.2 * t) + 0.02 * np.cos(4.0 * t)\n    else:\n        raise ValueError(\"Invalid pair_id\")\n    return np.array([y1, y2])\n\ndef true_derivatives(t, pair_id):\n    \"\"\"Computes the time derivatives dY/dt of the true solutions.\"\"\"\n    if pair_id == 'A':\n        dy1_dt = -0.3 * np.exp(-0.3 * t) + 0.2 * np.pi * np.cos(2.0 * np.pi * t)\n        dy2_dt = -0.05 * np.exp(-0.1 * t) - 0.1 * np.pi * np.sin(2.0 * np.pi * t)\n    elif pair_id == 'B':\n        dy1_dt = -0.4 * np.exp(-0.5 * t) + 0.15 * np.cos(3.0 * t)\n        dy2_dt = -0.06 * np.exp(-0.2 * t) - 0.08 * np.sin(4.0 * t)\n    else:\n        raise ValueError(\"Invalid pair_id\")\n    return np.array([dy1_dt, dy2_dt])\n\ndef source_terms(t, kc, lbeta, pair_id):\n    \"\"\"Computes the manufactured source terms S(t).\"\"\"\n    y_true = true_solutions(t, pair_id)\n    dy_dt_true = true_derivatives(t, pair_id)\n    s1 = dy_dt_true[0] + kc * y_true[0]\n    s2 = dy_dt_true[1] - kc * y_true[0] + lbeta * y_true[1]\n    return np.array([s1, s2])\n\ndef rhs(t, y, kc, lbeta, pair_id):\n    \"\"\"Computes the right-hand side f(t, Y) of the ODE system.\"\"\"\n    s_vec = source_terms(t, kc, lbeta, pair_id)\n    f1 = -kc * y[0] + s_vec[0]\n    f2 = kc * y[0] - lbeta * y[1] + s_vec[1]\n    return np.array([f1, f2])\n\ndef integrate(method, kc, lbeta, T, h, pair_id):\n    \"\"\"\n    Integrates the ODE system from t=0 to T with step size h.\n    \"\"\"\n    y = true_solutions(0.0, pair_id)\n    t = 0.0\n    # Use round() to prevent floating point inaccuracies in step counting\n    num_steps = int(round(T / h))\n\n    for _ in range(num_steps):\n        if method == 'euler':\n            y = y + h * rhs(t, y, kc, lbeta, pair_id)\n        elif method == 'heun':\n            k1 = rhs(t, y, kc, lbeta, pair_id)\n            k2 = rhs(t + h, y + h * k1, kc, lbeta, pair_id)\n            y = y + (h / 2.0) * (k1 + k2)\n        t += h\n    return y\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute observed orders.\n    \"\"\"\n    test_cases = [\n        # Case 1: Forward Euler, non-stiff\n        {'method': 'euler', 'kc': 0.2, 'lbeta': 0.4, 'T': 1.0, 'h1': 0.01, 'h2': 0.005, 'pair_id': 'A'},\n        # Case 2: Heun, non-stiff\n        {'method': 'heun',  'kc': 0.2, 'lbeta': 0.4, 'T': 1.0, 'h1': 0.01, 'h2': 0.005, 'pair_id': 'A'},\n        # Case 3: Forward Euler, stiff\n        {'method': 'euler', 'kc': 2.0, 'lbeta': 5.0, 'T': 0.5, 'h1': 0.5/800.0, 'h2': 0.5/1600.0, 'pair_id': 'B'},\n        # Case 4: Heun, stiff\n        {'method': 'heun',  'kc': 2.0, 'lbeta': 5.0, 'T': 0.5, 'h1': 0.5/800.0, 'h2': 0.5/1600.0, 'pair_id': 'B'}\n    ]\n\n    results = []\n    for case in test_cases:\n        method = case['method']\n        kc = case['kc']\n        lbeta = case['lbeta']\n        T = case['T']\n        h1 = case['h1']\n        h2 = case['h2']\n        pair_id = case['pair_id']\n        \n        # Integrate with step size h1\n        y_num_h1 = integrate(method, kc, lbeta, T, h1, pair_id)\n        \n        # Integrate with step size h2\n        y_num_h2 = integrate(method, kc, lbeta, T, h2, pair_id)\n\n        # Get the true solution at final time T\n        y_true_at_T = true_solutions(T, pair_id)\n        \n        # Calculate final-time global errors\n        error_h1 = np.max(np.abs(y_num_h1 - y_true_at_T))\n        error_h2 = np.max(np.abs(y_num_h2 - y_true_at_T))\n        \n        # Calculate the observed order of accuracy, p\n        # p = log(E(h1)/E(h2)) / log(h1/h2)\n        # Since h1/h2 = 2, this simplifies to log2(E(h1)/E(h2))\n        order_p = np.log(error_h1 / error_h2) / np.log(h1 / h2)\n        \n        results.append(order_p)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "拥有一个经过验证的求解器后，我们便可以探索真实的s-过程天体物理情景。本练习模拟一个s-过程分支点在脉冲中子流下的行为，这是理解中子俘获与β衰变竞争的关键。您将研究中子密度如何改变核合成路径，并学会从物理角度诊断数值解的质量，例如确保丰度的非负性以及最终产物的单调性 。",
            "id": "3591044",
            "problem": "考虑一个用于慢中子俘获核合成（s-过程）的最小反应网络片段，该片段代表一个单一的分支点。设该网络由四种核素组成，其丰度分别为 $Y_A(t)$、$Y_B(t)$、$Y_C(t)$ 和 $Y_D(t)$，其中，核素 $B$ 是分支核，由核素 $A$ 俘获中子生成，它可以进行中子俘获转变为 $C$，或发生 beta 衰变转变为 $D$。在均匀环境的假设下，丰度的时间演化遵循一级反应动力学：\n\n$$\n\\frac{dY_A}{dt} = -\\lambda_{Ac}(t)\\, Y_A,\n$$\n$$\n\\frac{dY_B}{dt} = \\lambda_{Ac}(t)\\, Y_A - \\left[\\lambda_{Bc}(t) + \\lambda_{\\beta}\\right]\\, Y_B,\n$$\n$$\n\\frac{dY_C}{dt} = \\lambda_{Bc}(t)\\, Y_B,\n$$\n$$\n\\frac{dY_D}{dt} = \\lambda_{\\beta}\\, Y_B,\n$$\n\n其中 $\\lambda_{\\beta}$ 是 $B$ 的 beta 衰变率，$\\lambda_{Ac}(t)$ 和 $\\lambda_{Bc}(t)$ 分别是 $A$ 和 $B$ 的随时间变化的中子俘获率。这些率由中子数密度 $n_n(t)$ 和对应的麦克斯韦平均截面乘以热速度 $\\langle \\sigma v \\rangle$ 决定：\n\n$$\n\\lambda_{Ac}(t) = n_n(t)\\, \\langle \\sigma v \\rangle_A, \\quad \\lambda_{Bc}(t) = n_n(t)\\, \\langle \\sigma v \\rangle_B.\n$$\n\n假设 s-过程体系中符合物理实际的常数：\n- $\\langle \\sigma v \\rangle_A = 5\\times 10^{-20}\\ \\text{cm}^3/\\text{s}$，\n- $\\langle \\sigma v \\rangle_B = 1\\times 10^{-19}\\ \\text{cm}^3/\\text{s}$，\n- $\\lambda_{\\beta} = \\ln(2)/10^6\\ \\text{s}^{-1}$，对应于 $10^6\\ \\text{s}$ 的半衰期。\n\n假设 $t=0$ 时的初始丰度为：\n$$\nY_A(0)=1,\\quad Y_B(0)=0,\\quad Y_C(0)=0,\\quad Y_D(0)=0,\n$$\n在该网络下，总丰度 $Y_{\\text{tot}} = Y_A + Y_B + Y_C + Y_D$ 是守恒的。\n\n将瞬时中子数密度 $n_n(t)$（单位为 $\\text{cm}^{-3}$）定义为一个分段常数函数，它可以发生突变以模拟中子脉冲的开始。对于一个给定的测试案例，指定一个基准密度 $n_{\\text{base}}$、一个高密度水平 $n_{\\text{high}}$、一个脉冲开始时间 $t_{\\text{start}}$（单位为秒）、一个脉冲结束时间 $t_{\\text{end}}$（单位为秒）以及一个总积分结束时间 $T_{\\text{end}}$（单位为秒）如下：\n$$\nn_n(t) = \n\\begin{cases}\nn_{\\text{base}},  0 \\le t  t_{\\text{start}}, \\\\\nn_{\\text{high}},  t_{\\text{start}} \\le t  t_{\\text{end}}, \\\\\nn_{\\text{base}},  t_{\\text{end}} \\le t \\le T_{\\text{end}}.\n\\end{cases}\n$$\n\n计算任务是使用数值稳定的方案积分上述常微分方程刚性系统，并评估当 $n_n(t)$ 发生突变时，积分器是否能正确捕捉分支的激活。分支激活可以通过最终导向 $C$ 的分支比来诊断：\n$$\nF_C = \\frac{Y_C(T_{\\text{end}})}{Y_C(T_{\\text{end}}) + Y_D(T_{\\text{end}})},\n$$\n这是一个无量纲的量。一个行为正确的积分器应该在脉冲将 $n_n(t)$ 充分提高时，能够增加 $F_C$ 的值，且不会在解中引入虚假的振荡。\n\n为了量化虚假振荡的不存在，对求解器按时间采样的输出进行以下数值诊断评估：\n1. 非负性：所有丰度在很小的容差范围内保持 $\\ge 0$。\n2. 累积产物的单调性：$Y_C(t)$ 和 $Y_D(t)$ 在很小的容差范围内随时间非递减。\n3. 分支核的单峰性：时间序列 $Y_B(t)$ 是单峰的，即其离散时间导数的符号最多改变一次（忽略接近零的微小数值波动）。\n\n在采样的输出上严格执行这些诊断，并使用明确定义的容差。\n\n使用适合这些方程和不连续输入的刚性积分器。所有时间量使用秒，数值与上述定义的单位保持一致。Beta 衰变率和中子俘获率的单位必须是 $\\text{s}^{-1}$。\n\n测试套件：\n为以下四个旨在探究一系列行为的测试案例提供结果：\n- 案例 1（基准，无激活）：$n_{\\text{base}}=5\\times 10^8$, $n_{\\text{high}}=5\\times 10^8$, $t_{\\text{start}}=0$, $t_{\\text{end}}=0$, $T_{\\text{end}}=3\\times 10^6$。\n- 案例 2（阶跃至持续高密度）：$n_{\\text{base}}=5\\times 10^8$, $n_{\\text{high}}=5\\times 10^{12}$, $t_{\\text{start}}=10^6$, $t_{\\text{end}}=3\\times 10^6$, $T_{\\text{end}}=3\\times 10^6$。\n- 案例 3（有限时长脉冲）：$n_{\\text{base}}=5\\times 10^8$, $n_{\\text{high}}=5\\times 10^{12}$, $t_{\\text{start}}=10^6$, $t_{\\text{end}}=1.1\\times 10^6$, $T_{\\text{end}}=3\\times 10^6$。\n- 案例 4（短促突变脉冲）：$n_{\\text{base}}=5\\times 10^8$, $n_{\\text{high}}=5\\times 10^{12}$, $t_{\\text{start}}=10^6$, $t_{\\text{end}}=1.005\\times 10^6$, $T_{\\text{end}}=3\\times 10^6$。\n\n对每个案例，计算并返回一个双元素结果：\n- 最终分支比 $F_C$，作为一个浮点数。\n- 一个布尔值，指示是否通过了振荡诊断。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的四个案例结果列表，每个案例结果本身是一个双元素列表，顺序为 $[F_C, \\text{diagnostic\\_pass}]$。例如：\"[[0.123,True],[0.456,True],[0.078,True],[0.012,True]]\"。",
            "solution": "该问题提出了一个核天体物理领域的计算任务，具体是模拟一个简化的 s-过程核合成反应网络。对问题陈述的严格验证证实了其科学基础扎实、提法恰当、目标明确且信息完整。它基于标准的核素丰度 Bateman 方程，使用了符合物理实际的 s-过程参数，并设定了一个清晰、可验证的计算目标。该方程组被正确定性为潜在刚性系统，并且使用分段常数函数来表示中子密度是在恒星环境中模拟脉冲中子照射的一种有效且常见的简化方法。因此，该问题被认为是有效的，可以构建一个解。\n\n问题的核心是求解一个关于丰度 $Y_A(t)$、$Y_B(t)$、$Y_C(t)$ 和 $Y_D(t)$ 的包含四个耦合、一阶、线性常微分方程（ODE）的方程组。该系统可以表示为矩阵形式：\n$$\n\\frac{d\\vec{Y}}{dt} = \\mathbf{M}(t)\\vec{Y}(t)\n$$\n其中 $\\vec{Y}(t) = [Y_A(t), Y_B(t), Y_C(t), Y_D(t)]^T$ 是丰度向量，$\\mathbf{M}(t)$ 是反应矩阵。根据给定的反应网络，矩阵 $\\mathbf{M}(t)$ 为：\n$$\n\\mathbf{M}(t) = \n\\begin{pmatrix}\n-\\lambda_{Ac}(t)  0  0  0 \\\\\n\\lambda_{Ac}(t)  -(\\lambda_{Bc}(t) + \\lambda_{\\beta})  0  0 \\\\\n0  \\lambda_{Bc}(t)  0  0 \\\\\n0  \\lambda_{\\beta}  0  0\n\\end{pmatrix}\n$$\n矩阵的时间依赖性源于中子俘获率 $\\lambda_{Ac}(t) = n_n(t)\\langle \\sigma v \\rangle_A$ 和 $\\lambda_{Bc}(t) = n_n(t)\\langle \\sigma v \\rangle_B$，它们是随时间变化的中子数密度 $n_n(t)$ 的函数。\n\n函数 $n_n(t)$ 被定义为分段常数函数，这意味着矩阵 $\\mathbf{M}(t)$ 也是分段常数的。$n_n(t)$ 在 $t_{\\text{start}}$ 和 $t_{\\text{end}}$ 处的突变会给 $\\vec{Y}(t)$ 的导数带来不连续点。为了精确地积分该系统，必须将这些时间点作为边界处理。积分将在区间 $[0, t_{\\text{start}}]$、$[t_{\\text{start}}, t_{\\text{end}}]$ 和 $[t_{\\text{end}}, T_{\\text{end}}]$ 上依次进行。一个区间的最终状态向量将作为下一个区间的初始条件。这能确保数值积分器不会尝试跨越不连续点，否则可能导致巨大误差或失败。\n\n问题正确地指出该系统可能是刚性的。当系统的特征时间尺度（与矩阵 $\\mathbf{M}$ 特征值实部的倒数相关）相差悬殊时，就会出现刚性问题。在这里，beta 衰变率 $\\lambda_{\\beta} = \\ln(2)/10^6 \\approx 6.93 \\times 10^{-7}\\ \\text{s}^{-1}$ 定义了一个时间尺度，而中子俘获率则可能变化很大。在低密度（$n_n=5 \\times 10^8\\ \\text{cm}^{-3}$）下，俘获率非常小（$\\sim 10^{-11}\\ \\text{s}^{-1}$），与 beta 衰变时间尺度之间产生了巨大的差异。这就需要使用专为刚性 ODE 设计的数值积分器。隐式方法，如后向分化公式（`BDF`）或隐式 Runge-Kutta 方法（如 `Radau`），都是合适的选择。我们将采用 `scipy.integrate.solve_ivp` 中提供的 `Radau` 方法，因为它阶数高且对刚性问题具有鲁棒性。\n\n在积分到最终时间 $T_{\\text{end}}$ 后，我们必须对时间采样的解执行指定的数值诊断。选择一个容差 $\\epsilon = 10^{-12}$ 来区分数值噪声和真正的算法缺陷。\n1.  **非负性**：在所有采样时间点 $t_j$，所有丰度 $Y_i(t_j)$ 都必须满足 $Y_i(t_j) \\ge -\\epsilon$。\n2.  **累积产物的单调性**：最终稳定产物的丰度 $Y_C(t)$ 和 $Y_D(t)$ 是由不可逆反应产生的，它们应该是非递减的。我们验证对于所有相邻的时间点 $t_j, t_{j+1}$，$Y_C(t_{j+1}) \\ge Y_C(t_j) - \\epsilon$ 且 $Y_D(t_{j+1}) \\ge Y_D(t_j) - \\epsilon$。\n3.  **分支核的单峰性**：中间核素 $Y_B(t)$ 预计会先生成后消耗，形成一条单峰曲线（一个峰值）。我们通过检查离散时间导数 $\\Delta Y_B / \\Delta t$ 的符号来验证这一点。通过忽略小于 $\\epsilon$ 的变化来考虑数值噪声，这些差值的符号序列最多只能改变一次（从正到负）。\n\n这三个诊断检查的逻辑与（AND）运算结果决定了最终的布尔值 `diagnostic_pass`。最终分支比 $F_C$ 根据最终丰度计算得出，$F_C = Y_C(T_{\\text{end}}) / (Y_C(T_{\\text{end}}) + Y_D(T_{\\text{end}}))$。如果分母为零（对于 $T_{\\text{end}}  0$ 的情况这是不预期的），则 $F_C$ 定义为 $0$。然后为所提供的四个测试案例分别计算求解。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the s-process network for the given test cases.\n    \"\"\"\n    # Define physical constants from the problem statement\n    SIGMA_V_A = 5e-20  # cm^3/s\n    SIGMA_V_B = 1e-19  # cm^3/s\n    LAMBDA_BETA = np.log(2) / 1e6  # s^-1\n    \n    # Numerical tolerance for diagnostics\n    TOLERANCE = 1e-12\n\n    def run_diagnostics(y_solution):\n        \"\"\"\n        Runs the three numerical diagnostics on the solution array.\n        y_solution is an array of shape (N_points, 4).\n        \"\"\"\n        # 1. Non-negativity check\n        non_negativity_passed = np.all(y_solution >= -TOLERANCE)\n\n        # 2. Monotonicity of build-up products (Y_C and Y_D)\n        diff_yc = np.diff(y_solution[:, 2])\n        diff_yd = np.diff(y_solution[:, 3])\n        monotonicity_passed = np.all(diff_yc >= -TOLERANCE) and np.all(diff_yd >= -TOLERANCE)\n\n        # 3. Unimodality of the branching nucleus (Y_B)\n        diff_yb = np.diff(y_solution[:, 1])\n        # Filter out insignificant fluctuations around zero derivative\n        significant_diffs = diff_yb[np.abs(diff_yb) > TOLERANCE]\n        if len(significant_diffs)  2:\n            unimodality_passed = True\n        else:\n            signs = np.sign(significant_diffs)\n            num_sign_changes = np.sum(signs[:-1] != signs[1:])\n            unimodality_passed = num_sign_changes = 1\n\n        return non_negativity_passed and monotonicity_passed and unimodality_passed\n\n    def get_ode_system(n_n):\n        \"\"\"\n        Returns the ODE function dy/dt = f(t, y) for a given constant neutron density n_n.\n        \"\"\"\n        lambda_ac = n_n * SIGMA_V_A\n        lambda_bc = n_n * SIGMA_V_B\n        \n        def ode_system(t, y):\n            y_a, y_b, y_c, y_d = y\n            dya_dt = -lambda_ac * y_a\n            dyb_dt = lambda_ac * y_a - (lambda_bc + LAMBDA_BETA) * y_b\n            dyc_dt = lambda_bc * y_b\n            dyd_dt = LAMBDA_BETA * y_b\n            return [dya_dt, dyb_dt, dyc_dt, dyd_dt]\n            \n        return ode_system\n\n    def solve_case(params):\n        \"\"\"\n        Solves the ODE system for a single test case's parameters.\n        \"\"\"\n        n_base, n_high, t_start, t_end, T_end = params\n        y0 = np.array([1.0, 0.0, 0.0, 0.0])\n        \n        # Define integration time points, ensuring to break at discontinuities\n        t_breaks = sorted(list(set([0, t_start, t_end, T_end])))\n        \n        y_current = y0\n        \n        # Store solution parts from all segments for post-processing diagnostics\n        t_solution_parts = []\n        y_solution_parts = []\n        \n        for i in range(len(t_breaks) - 1):\n            t_span_start, t_span_end = t_breaks[i], t_breaks[i+1]\n            \n            if t_span_start >= t_span_end:\n                continue\n            \n            # Determine the constant neutron density for this interval\n            t_midpoint = (t_span_start + t_span_end) / 2\n            n_n = n_high if t_start = t_midpoint  t_end else n_base\n                \n            ode_func = get_ode_system(n_n)\n\n            # Integrate over the segment using a stiff solver\n            sol = solve_ivp(\n                fun=ode_func,\n                t_span=(t_span_start, t_span_end),\n                y0=y_current,\n                method='Radau'\n            )\n            \n            # Append solution parts, avoiding duplication of break points\n            if not t_solution_parts:\n                 t_solution_parts.append(sol.t)\n                 y_solution_parts.append(sol.y)\n            else:\n                 t_solution_parts.append(sol.t[1:])\n                 y_solution_parts.append(sol.y[:, 1:])\n\n            y_current = sol.y[:, -1]\n\n        if not t_solution_parts:\n            final_y = y0\n            diagnostics_passed = True\n        else:    \n            # Concatenate results and perform diagnostics\n            full_y_solution = np.concatenate(y_solution_parts, axis=1).T\n            final_y = y_current\n            diagnostics_passed = run_diagnostics(full_y_solution)\n\n        # Calculate final branching fraction F_C\n        y_c_final, y_d_final = final_y[2], final_y[3]\n        denominator = y_c_final + y_d_final\n        f_c = y_c_final / denominator if denominator > 0 else 0.0\n            \n        return [f_c, diagnostics_passed]\n\n    # Define the test suite from the problem statement\n    test_cases = [\n        # (n_base, n_high, t_start, t_end, T_end)\n        (5e8, 5e8, 0, 0, 3e6),\n        (5e8, 5e12, 1e6, 3e6, 3e6),\n        (5e8, 5e12, 1e6, 1.1e6, 3e6),\n        (5e8, 5e12, 1e6, 1.005e6, 3e6),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format and print the final results as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}