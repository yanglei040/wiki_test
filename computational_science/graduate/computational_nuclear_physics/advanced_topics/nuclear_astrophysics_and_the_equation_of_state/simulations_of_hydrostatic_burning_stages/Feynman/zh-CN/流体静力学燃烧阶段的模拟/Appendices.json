{
    "hands_on_practices": [
        {
            "introduction": "由于核反应速率对温度具有极端的敏感性，描述核燃烧的方程通常是“刚性”的，这要求我们使用隐式数值方法进行稳定积分。本实践聚焦于任何隐式求解器的核心：处理单个后向欧拉时间步产生的非线性代数方程。通过为一个恒星壳层的温度演化  实现一个鲁棒的求解器，您将为模拟静力学燃烧阶段建立一项基本技能。",
            "id": "3590322",
            "problem": "考虑一个在静水压条件下演化的零维 (0D) 恒星壳层，其质量密度 $\\rho$ 固定，定压比热 $c_P(T)$ 依赖于温度。在短时间步长内的热演化由能量方程决定，该方程源自热力学第一定律和核能生成。在没有宏观功且成分参数固定的情况下，该方程可以写成如下的常微分方程 (ODE)\n$$\n\\frac{dT}{dt} = \\frac{\\varepsilon(T,Y) - \\epsilon_\\nu(T,\\rho)}{c_P(T)},\n$$\n其中，$T$ 是以开尔文为单位的温度，$t$ 是以秒为单位的时间，$\\varepsilon(T,Y)$ 是单位质量的核能生成率（单位为 $\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$），是温度 $T$ 和成分参数 $Y$ 的函数，$\\epsilon_\\nu(T,\\rho)$ 是单位质量的中微子能量损失率（单位为 $\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$），是 $T$ 和 $\\rho$ 的函数。定压比热 $c_P(T)$ 的单位是 $\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{K}^{-1}$。\n\n你将通过求解隐式更新方程，计算从 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的单个向后欧拉时间步，其中 $T_n = T(t_n)$ 是给定的。\n$$\nT_{n+1} = T_n + \\Delta t\\,\\frac{\\varepsilon(T_{n+1},Y) - \\epsilon_\\nu(T_{n+1},\\rho)}{c_P(T_{n+1})}.\n$$\n这是一个关于 $T_{n+1}$ 的非线性方程，必须精确且稳健地求解。你必须实现一个基于第一性原理和数值分析考虑的求解器，并且该求解器需适用于在静水压燃烧阶段遇到的刚性区域。\n\n为在保持计算易处理性的同时确保科学真实性，请使用以下本构模型：\n- 定义归一化温度 $T_9$ 为 $T_9 \\equiv T / 10^9\\,\\mathrm{K}$。\n- 单位质量的核能生成：\n$$\n\\varepsilon(T,Y) = A\\,\\rho\\,Y\\,T_9^n\\,\\exp\\!\\left(-\\frac{B}{T_9^{1/3}}\\right),\n$$\n其中常数 $A = 1.0\\times 10^{14}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$，$n=5$，以及 $B=5$。\n- 单位质量的中微子能量损失：\n$$\n\\epsilon_\\nu(T,\\rho) = C\\left(\\frac{\\rho}{\\rho_0}\\right)^\\alpha T_9^9,\n$$\n其中常数 $C = 1.0\\times 10^{17}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$，$\\rho_0 = 10^6\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}$，以及 $\\alpha = 0.1$。\n- 定压比热：\n$$\nc_P(T) = c_0 + c_1 T_9^2,\n$$\n其中常数 $c_0 = 1.0\\times 10^{8}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{K}^{-1}$ 和 $c_1 = 2.0\\times 10^{8}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{K}^{-1}$。\n\n你的任务是：\n- 从第一性原理推导为何向后欧拉离散化适用于此刚性常微分方程，并构建需求解的关于 $T_{n+1}$ 的非线性残差。\n- 设计并实现一个稳健的非线性求解策略，该策略能在强温度依赖性存在的情况下保证收敛性和稳定性。你的求解器必须强制执行物理约束 $T_{n+1} > 0$，并应有防止在大的 $\\Delta t$ 下发散的保护措施。\n- 为以下每个测试用例计算 $T_{n+1}$。将每个最终温度以 $\\mathrm{K}$ 为单位表示，并四舍五入到六位小数。\n\n测试套件（每个元组为 $(\\rho\\,\\mathrm{[g/cm^3]}, Y\\,\\mathrm{[无量纲]}, T_n\\,\\mathrm{[K]}, \\Delta t\\,\\mathrm{[s]})$）：\n1. $(10^6,\\;0.5,\\;7.0\\times 10^8,\\;1.0\\times 10^{-4})$。\n2. $(10^6,\\;0.3,\\;1.0\\times 10^9,\\;1.0\\times 10^{-2})$。\n3. $(10^6,\\;0.5,\\;2.0\\times 10^8,\\;1.0\\times 10^{-1})$。\n4. $(10^6,\\;0.01,\\;8.0\\times 10^8,\\;1.0\\times 10^{-5})$。\n5. $(10^8,\\;0.5,\\;5.0\\times 10^8,\\;1.0\\times 10^{-6})$。\n\n最终输出格式要求：你的程序应生成单行输出，包含五个结果，形式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是对应测试用例计算出的 $T_{n+1}$ 值（单位为 $\\mathrm{K}$），四舍五入到六位小数，无任何额外文本。",
            "solution": "该问题要求计算恒星壳层热演化的单个时间步。该演化由一个刚性常微分方程 (ODE) 描述。解决方案涉及确定一个合适的数值积分器和一个稳健的方法来求解由此产生的非线性代数方程。\n\n### 问题验证\n\n**第 1 步：提取的已知条件**\n- **控制性常微分方程**: $\\frac{dT}{dt} = \\frac{\\varepsilon(T,Y) - \\epsilon_\\nu(T,\\rho)}{c_P(T)}$\n- **离散化方案**: 向后欧拉法，得到隐式更新方程 $T_{n+1} = T_n + \\Delta t\\,\\frac{\\varepsilon(T_{n+1},Y) - \\epsilon_\\nu(T_{n+1},\\rho)}{c_P(T_{n+1})}$。\n- **归一化温度**: $T_9 \\equiv T / 10^9\\,\\mathrm{K}$。\n- **核能生成率**: $\\varepsilon(T,Y) = A\\,\\rho\\,Y\\,T_9^n\\,\\exp\\!\\left(-\\frac{B}{T_9^{1/3}}\\right)$，其中常数 $A = 1.0\\times 10^{14}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$，$n=5$，以及 $B=5$。\n- **中微子能量损失率**: $\\epsilon_\\nu(T,\\rho) = C\\left(\\frac{\\rho}{\\rho_0}\\right)^\\alpha T_9^9$，其中常数 $C = 1.0\\times 10^{17}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$，$\\rho_0 = 10^6\\,\\mathrm{g}\\,\\mathrm{cm}^{-3}$，以及 $\\alpha = 0.1$。\n- **比热**: $c_P(T) = c_0 + c_1 T_9^2$，其中常数 $c_0 = 1.0\\times 10^{8}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{K}^{-1}$ 和 $c_1 = 2.0\\times 10^{8}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{K}^{-1}$。\n- **物理约束**: $T_{n+1} > 0$。\n- **测试用例**: 提供了五个 $(\\rho, Y, T_n, \\Delta t)$ 元组：\n    1. $(10^6\\,\\mathrm{g/cm^3}, 0.5, 7.0\\times 10^8\\,\\mathrm{K}, 1.0\\times 10^{-4}\\,\\mathrm{s})$\n    2. $(10^6\\,\\mathrm{g/cm^3}, 0.3, 1.0\\times 10^9\\,\\mathrm{K}, 1.0\\times 10^{-2}\\,\\mathrm{s})$\n    3. $(10^6\\,\\mathrm{g/cm^3}, 0.5, 2.0\\times 10^8\\,\\mathrm{K}, 1.0\\times 10^{-1}\\,\\mathrm{s})$\n    4. $(10^6\\,\\mathrm{g/cm^3}, 0.01, 8.0\\times 10^8\\,\\mathrm{K}, 1.0\\times 10^{-5}\\,\\mathrm{s})$\n    5. $(10^8\\,\\mathrm{g/cm^3}, 0.5, 5.0\\times 10^8\\,\\mathrm{K}, 1.0\\times 10^{-6}\\,\\mathrm{s})$\n\n**第 2 步：已知条件的验证**\n该问题具有科学依据。控制性常微分方程代表了静态壳层的热力学第一定律，这是恒星天体物理学中的一个标准模型。$\\varepsilon$、$\\epsilon_\\nu$ 和 $c_P$ 的本构关系是简化的，但却是天体物理学代码中常用的、有物理动机的幂律和指数形式。该问题是适定的，提供了寻找数值解所需的所有必要常数、初始条件和函数形式。语言客观而精确。该问题未违反任何无效性标准。\n\n**第 3 步：结论与行动**\n问题有效。将提供一个完整的解决方案。\n\n### 基于原理的解决方案设计\n\n**1. 向后欧拉方法的合理性**\n\n常微分方程 $dT/dt = f(T)$ 被定性为“刚性”的。当系统具有差异巨大的时间尺度时，就会出现刚性。在这里，净能量生成率 $f(T) = (\\varepsilon - \\epsilon_\\nu)/c_P$ 是温度的一个极其敏感的函数。核能生成率 $\\varepsilon$ 通过高次幂律 ($T_9^n$) 和一个指数项依赖于温度，这是热核反应的特征。中微子损失率 $\\epsilon_\\nu$ 与 $T_9^9$ 成正比。因此，右侧的雅可比矩阵 $J = df/dT$ 可以取很大的正值或负值，这意味着特征时间尺度 $\\tau \\sim |J|^{-1}$ 非常短。\n\n显式数值方法，如前向欧拉法，有稳定性约束，形式为 $\\Delta t  C/|J_{\\max}|$，其中 $C$ 是一个数量级为 1 的常数。这将迫使时间步长 $\\Delta t$ 远小于我们感兴趣的演化时间尺度，从而使得模拟在计算上变得不切实际。\n\n向后欧拉法是一种隐式方法。其更新规则 $T_{n+1} = T_n + \\Delta t f(T_{n+1})$ 是 A-稳定的。这意味着其绝对稳定域包含了整个复数左半平面，这是稳定物理系统特征值的域。A-稳定性保证了对于任何时间步长 $\\Delta t > 0$，数值解都将保持有界，无论常微分方程的刚性有多强。因此，时间步长可以根据精度要求而不是稳定性来选择，这使其对于刚性问题效率更高。\n\n**2. 非线性残差方程的构建**\n\n必须求解向后欧拉更新方程以获得未知温度 $T_{n+1}$。为简化符号，我们用变量 $T$ 表示 $T_{n+1}$。方程为\n$$\nT = T_n + \\Delta t\\,\\frac{\\varepsilon(T,Y) - \\epsilon_\\nu(T,\\rho)}{c_P(T)}\n$$\n这是一个关于 $T$ 的非线性代数方程。为了数值求解它，我们通过定义一个残差函数 $R(T)$ 将其构建为一个求根问题，使得我们寻求满足 $R(T)=0$ 的 $T$。一个合适的残差函数是\n$$\nR(T) = T - T_n - \\Delta t \\left( \\frac{\\varepsilon(T) - \\epsilon_\\nu(T)}{c_P(T)} \\right) = 0\n$$\n\n**3. 非线性求解器的设计：牛顿-拉夫森方法 (Newton-Raphson Method)**\n\n当函数导数可解析获得时，牛顿法（或牛顿-拉夫森方法）是求解形如 $R(T)=0$ 的非线性方程的标准且最高效的算法。其在根附近的二次收敛性质确保了快速而准确的解。\n\n牛顿法的迭代公式为：\n$$\nT^{(k+1)} = T^{(k)} - \\frac{R(T^{(k)})}{R'(T^{(k)})}\n$$\n其中 $T^{(k)}$ 是第 $k$ 次迭代时根的近似值，$R'(T) = dR/dT$ 是残差函数关于 $T$ 的导数。\n\n$R'(T)$ 的导数计算如下：\n$$\nR'(T) = \\frac{d}{dT} \\left[ T - T_n - \\Delta t \\frac{\\varepsilon(T) - \\epsilon_\\nu(T)}{c_P(T)} \\right]\n$$\n$$\nR'(T) = 1 - \\Delta t \\, \\frac{d}{dT} \\left[ \\frac{\\varepsilon(T) - \\epsilon_\\nu(T)}{c_P(T)} \\right]\n$$\n使用商法则，我们得到：\n$$\nR'(T) = 1 - \\Delta t \\left( \\frac{(\\varepsilon'(T) - \\epsilon'_\\nu(T))c_P(T) - (\\varepsilon(T) - \\epsilon_\\nu(T))c'_P(T)}{[c_P(T)]^2} \\right)\n$$\n其中 $\\varepsilon'(T)$、$\\epsilon'_\\nu(T)$ 和 $c'_P(T)$ 分别是相应函数关于 $T$ 的导数。这些导数使用链式法则，并结合 $T_9 = T/10^9$ 和 $dT/dT_9 = 10^9$ 推导得出：\n\n- **比热的导数, $c'_P(T)$**:\n$c_P(T) = c_0 + c_1 T_9^2$.\n$c'_P(T) = \\frac{dc_P}{dT_9} \\frac{dT_9}{dT} = (2c_1 T_9) \\left(\\frac{1}{10^9}\\right) = \\frac{2c_1 T_9^2}{T} = \\frac{2(c_P(T)-c_0)}{T}$.\n\n- **中微子损失的导数, $\\epsilon'_\\nu(T)$**:\n$\\epsilon_\\nu(T) = K_\\nu T_9^9$，其中 $K_\\nu = C(\\rho/\\rho_0)^\\alpha$。\n$\\epsilon'_\\nu(T) = \\frac{d\\epsilon_\\nu}{dT_9} \\frac{dT_9}{dT} = (9 K_\\nu T_9^8) \\left(\\frac{1}{10^9}\\right) = \\frac{9 K_\\nu T_9^9}{T} = \\frac{9 \\epsilon_\\nu(T)}{T}$.\n\n- **核能生成的导数, $\\varepsilon'(T)$**:\n$\\varepsilon(T) = K_\\varepsilon T_9^n \\exp(-B/T_9^{1/3})$，其中 $K_\\varepsilon = A \\rho Y$。\n$\\frac{d\\varepsilon}{dT_9} = K_\\varepsilon \\left[ n T_9^{n-1} \\exp\\left(-\\frac{B}{T_9^{1/3}}\\right) + T_9^n \\exp\\left(-\\frac{B}{T_9^{1/3}}\\right) \\left(\\frac{B}{3} T_9^{-4/3}\\right) \\right]$。\n提取公因式 $\\varepsilon(T)$，我们找到一个更紧凑的关于 $T$ 的导数形式：\n$\\varepsilon'(T) = \\frac{1}{10^9} \\frac{d\\varepsilon}{dT_9} = \\frac{\\varepsilon(T)}{T} \\left( n + \\frac{B}{3T_9^{1/3}} \\right)$。\n\n**4. 求解器的稳健实现**\n\n牛顿法的稳健实现需要考虑几个方面：\n- **初始猜测值**: 前一时间步的温度 $T_n$ 是新温度的自然且极佳的初始猜测值，$T^{(0)} = T_n$。这对应于一个零阶保持。\n- **收敛准则**: 迭代持续进行，直到解的相对变化和残差的绝对值都低于指定的容差 $\\tau_{\\text{tol}}$（例如 $10^{-12}$）。\n$$\n\\left|\\frac{T^{(k+1)} - T^{(k)}}{T^{(k+1)}}\\right|  \\tau_{\\text{tol}} \\quad \\text{和} \\quad |R(T^{(k+1)})|  \\tau_{\\text{tol}}\n$$\n- **保护措施**: 为确保在可能较差的初始猜测值下仍能稳健收敛，并强制执行物理约束，保护措施是必要的。\n    - **正值约束**: 温度必须保持为正值，$T > 0$。如果牛顿更新会导致非正温度，则必须对其进行阻尼。\n    - **步长阻尼（线搜索）**: 如果一个完整的牛顿步（$\\lambda=1$）导致非物理状态（例如 $T \\le 0$）或增加了残差的绝对值，则步长将通过一个因子 $\\lambda \\in (0, 1]$ 进行缩减，即 $T^{(k+1)} = T^{(k)} - \\lambda \\frac{R(T^{(k)})}{R'(T^{(k)})}$。一种简单的回溯法，即相继将 $\\lambda$ 减半，是有效的。\n- **最大迭代次数**: 设置迭代总次数的上限，以防止在不收敛的情况下出现无限循环。\n\n通过将 A-稳定的向后欧拉方法与带保护措施的牛顿-拉夫森求解器相结合，我们构建了一个稳健而精确的数值方案，能够处理静水压核燃烧问题中固有的刚性和强非线性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a single backward Euler timestep for the thermal evolution of a\n    stellar shell by solving the resulting nonlinear equation using a\n    safeguarded Newton-Raphson method.\n    \"\"\"\n    \n    # Constants from the problem statement\n    A_NUC = 1.0e14  # erg g^-1 s^-1\n    N_NUC = 5.0\n    B_NUC = 5.0\n    C_NEU = 1.0e17  # erg g^-1 s^-1\n    RHO_0 = 1.0e6   # g cm^-3\n    ALPHA_NEU = 0.1\n    C0_CP = 1.0e8   # erg g^-1 K^-1\n    C1_CP = 2.0e8   # erg g^-1 K^-1\n    T_9_SCALE = 1.0e9 # K\n\n    test_cases = [\n        (1.0e6, 0.5, 7.0e8, 1.0e-4),\n        (1.0e6, 0.3, 1.0e9, 1.0e-2),\n        (1.0e6, 0.5, 2.0e8, 1.0e-1),\n        (1.0e6, 0.01, 8.0e8, 1.0e-5),\n        (1.0e8, 0.5, 5.0e8, 1.0e-6),\n    ]\n\n    results = []\n\n    def eps_nuc(T, rho, Y):\n        \"\"\"Nuclear energy generation rate.\"\"\"\n        if T == 0: return 0.0\n        T9 = T / T_9_SCALE\n        return A_NUC * rho * Y * T9**N_NUC * np.exp(-B_NUC / (T9**(1./3.)))\n\n    def d_eps_nuc_dT(T, rho, Y):\n        \"\"\"Derivative of nuclear energy generation rate w.r.t. T.\"\"\"\n        if T == 0: return 0.0\n        T9 = T / T_9_SCALE\n        eps = eps_nuc(T, rho, Y)\n        return eps / T * (N_NUC + B_NUC / (3. * T9**(1./3.)))\n\n    def eps_neu(T, rho):\n        \"\"\"Neutrino energy loss rate.\"\"\"\n        if T == 0: return 0.0\n        T9 = T / T_9_SCALE\n        return C_NEU * (rho / RHO_0)**ALPHA_NEU * T9**9\n\n    def d_eps_neu_dT(T, rho):\n        \"\"\"Derivative of neutrino loss rate w.r.t. T.\"\"\"\n        if T == 0: return 0.0\n        return 9. * eps_neu(T, rho) / T\n\n    def c_p(T):\n        \"\"\"Specific heat at constant pressure.\"\"\"\n        if T == 0: return C0_CP # Avoid division by zero, return sensible limit\n        T9 = T / T_9_SCALE\n        return C0_CP + C1_CP * T9**2\n\n    def d_cp_dT(T):\n        \"\"\"Derivative of specific heat w.r.t. T.\"\"\"\n        if T == 0: return 0.0\n        return 2. * (c_p(T) - C0_CP) / T\n\n    def compute_timestep(rho, Y, T_n, dt):\n        \"\"\"Solves the implicit backward Euler step using Newton's method.\"\"\"\n        T_k = T_n  # Initial guess\n        \n        max_iter = 100\n        tol = 1.0e-12\n\n        for _ in range(max_iter):\n            # Calculate residual function R(T_k)\n            eps_nuc_k = eps_nuc(T_k, rho, Y)\n            eps_neu_k = eps_neu(T_k, rho)\n            c_p_k = c_p(T_k)\n            \n            if c_p_k == 0: # Avoid division by zero\n                # This should not happen since c_p >= c_0 > 0\n                raise ValueError(\"c_p is zero.\")\n\n            R = T_k - T_n - dt * (eps_nuc_k - eps_neu_k) / c_p_k\n\n            # Check for residual convergence\n            if abs(R)  tol:\n                return T_k\n\n            # Calculate derivative of residual R'(T_k)\n            d_eps_nuc_dT_k = d_eps_nuc_dT(T_k, rho, Y)\n            d_eps_neu_dT_k = d_eps_neu_dT(T_k, rho)\n            d_cp_dT_k = d_cp_dT(T_k)\n\n            # Numerator of the derivative of the source term\n            num_d_source = (d_eps_nuc_dT_k - d_eps_neu_dT_k) * c_p_k - \\\n                           (eps_nuc_k - eps_neu_k) * d_cp_dT_k\n            \n            R_prime = 1.0 - dt * num_d_source / (c_p_k**2)\n\n            if R_prime == 0:\n                # Stagnation, cannot proceed\n                raise RuntimeError(\"Newton's method failed: derivative is zero.\")\n\n            # Calculate Newton step\n            delta_T = -R / R_prime\n            \n            # Damping/safeguarding to ensure positivity\n            lam = 1.0\n            T_next = T_k + lam * delta_T\n            while T_next = 0:\n                lam /= 2.0\n                T_next = T_k + lam * delta_T\n                if lam  1.0e-8:\n                     raise RuntimeError(\"Newton's method failed: step safeguard failed.\")\n            \n            # Check for step size convergence\n            if abs((T_next - T_k) / T_next)  tol:\n                return T_next\n            \n            T_k = T_next\n            \n        raise RuntimeError(\"Newton's method did not converge within max iterations.\")\n\n    for case in test_cases:\n        rho, Y, T_n, dt = case\n        T_np1 = compute_timestep(rho, Y, T_n, dt)\n        results.append(T_np1)\n        \n    # Format the final output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了单方程求解器的基础上，我们现在来处理一个完整的核反应网络，其中多种核素的丰度是相互耦合的。一个鲁棒的数值格式不仅必须是稳定的，还必须遵守物理学的基本守恒律。本练习  将指导您为一个碳燃烧网络实现一个隐式积分步，并关键性地量化该格式在多大程度上保持了重子数和电荷的守恒，从而确保您模拟结果的物理保真度。",
            "id": "3590327",
            "problem": "您需要为一个简化的流体静力学碳燃烧网络实现一个单步隐式积分，然后量化该步骤对重子数和电荷的线性守恒约束的保持程度。使用数丰度形式，其中核素 $i$ 的丰度为 $Y_i \\equiv n_i/(\\rho N_A)$，这里 $n_i$ 是数密度，$\\rho$ 是质量密度，$N_A$ 是阿伏伽德罗常数。在这种形式下，重子数守恒要求 $\\sum_i A_i Y_i = 1$，并且在没有弱相互作用的情况下，电荷守恒要求 $\\sum_i Z_i Y_i = Y_e$，其中 $A_i$ 和 $Z_i$ 分别是质量数和质子数，$Y_e$ 是电子分数。\n\n考虑单一入口通道 $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}$，其有三个出口分支：\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{20}\\mathrm{Ne}+\\alpha$，分支比为 $b_\\alpha$，\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{23}\\mathrm{Na}+\\mathrm{p}$，分支比为 $b_p$，\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{24}\\mathrm{Mg}+\\gamma$，分支比为 $b_\\gamma$，\n其中 $b_\\alpha+b_p+b_\\gamma=1$。设物质种类集合为 $i\\in\\{^{12}\\mathrm{C},^{20}\\mathrm{Ne},^{23}\\mathrm{Na},^{24}\\mathrm{Mg},\\alpha,\\mathrm{p}\\}$，其 $(A,Z)$ 分别等于 $(12,6)$、$(20,10)$、$(23,11)$、$(24,12)$、$(4,2)$ 和 $(1,1)$。\n\n假设在流体静力学条件下，$\\rho$ 和温度 $T$ 恒定。在 $Y$-形式下，相同反应物的速率定律给出了常微分方程组 (ODEs)：\n- $\\dfrac{dY_{^{12}\\mathrm{C}}}{dt} = - k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{20}\\mathrm{Ne}}}{dt} = \\dfrac{1}{2} b_\\alpha\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{\\alpha}}{dt} = \\dfrac{1}{2} b_\\alpha\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{23}\\mathrm{Na}}}{dt} = \\dfrac{1}{2} b_p\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{\\mathrm{p}}}{dt} = \\dfrac{1}{2} b_p\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{24}\\mathrm{Mg}}}{dt} = \\dfrac{1}{2} b_\\gamma\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n其中，比速率 $k(T,\\rho)$ 是 $k(T,\\rho)=\\rho\\, \\mathcal{R}(T_9)$ 的组合，其中 $T_9 \\equiv T/(10^9\\,\\mathrm{K})$，而 $\\mathcal{R}(T_9)$ 是常用的、以 $\\mathrm{cm^3\\,mol^{-1}\\,s^{-1}}$ 为单位列表的摩尔速率系数 $N_A\\langle \\sigma v \\rangle$。对于此问题，采用经过充分检验的 Caughlan and Fowler 1988 (CF88) 风格的拟合公式\n$$\n\\mathcal{R}(T_9)= 4.27\\times 10^{26}\\, T_9^{-2/3}\\, \\exp\\!\\left(-\\dfrac{84.165}{T_9^{1/3}} - 2.12\\times 10^{-3}\\, T_9^2\\right)\\,\n\\left[1 + 0.0489\\,T_9^{1/3} + 0.265\\,T_9^{2/3} + 0.270\\,T_9 + 0.017\\,T_9^{4/3} + 0.330\\,T_9^{5/3}\\right].\n$$\n\n使用大小为 $\\Delta t$ 的单步后向欧拉法推进系统：\n$$\nY_i^{n+1} = Y_i^{n} + \\Delta t\\, \\left.\\dfrac{dY_i}{dt}\\right|_{Y^{n+1}},\n$$\n从质量分数为 $X_{^{12}\\mathrm{C}}^0=1$ 且所有其他物质为零的初始状态开始。回顾关系式 $X_i = A_i Y_i$，因此 $Y_{^{12}\\mathrm{C}}^0=1/12$ 且 $Y_e^0=\\sum_i Z_i Y_i^0 = 1/2$。您可以使用任何正确的方法求解 $Y_{^{12}\\mathrm{C}}^{n+1}$ 的标量隐式方程；使用在 $Y_{^{12}\\mathrm{C}}^{n+1}$ 处计算的后向欧拉右端项来计算产物。\n\n在隐式步之后，计算绝对守恒残差\n$$\nr_A = \\left|\\sum_i A_i Y_i^{n+1} - 1\\right|,\\qquad\nr_Z = \\left|\\sum_i Z_i Y_i^{n+1} - Y_e^0\\right|.\n$$\n基于浮点舍入分析和尺度考虑，提出绝对容差 $\\tau_A$ 和 $\\tau_Z$，这些容差足以断定此步骤中守恒的物理保真度。您的提议应结合机器epsilon的倍数和一个最小的工程下限来容纳求和误差，并且可以是整个测试套件中的一个固定值。\n\n实现一个程序，对于下面的每个测试用例，执行一个后向欧拉步，并按顺序输出四元组 $(r_A,r_Z,\\tau_A,\\tau_Z)$ 作为浮点数。将所有用例聚合到所需输出格式的单个扁平列表中。\n\n单位和常数：\n- $\\rho$ 的单位为 $\\mathrm{g\\,cm^{-3}}$，$T_9$ 无量纲，$\\Delta t$ 的单位为 $\\mathrm{s}$。\n- 丰度 $Y_i$、电子分数 $Y_e$ 以及残差 $r_A$、$r_Z$ 均为无量纲。\n\n测试套件（每个用例指定 $(T_9,\\rho,\\Delta t)$ 和一个共同的分支比 $(b_\\alpha,b_p,b_\\gamma)$）：\n- 用例 1：$(T_9=\\;0.8,\\;\\rho=\\;10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;10^{-4}\\;\\mathrm{s})$，$(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n- 用例 2：$(T_9=\\;0.8,\\;\\rho=\\;10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;0\\;\\mathrm{s})$，$(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n- 用例 3：$(T_9=\\;1.0,\\;\\rho=\\;2\\times 10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;1\\;\\mathrm{s})$，$(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n- 用例 4：$(T_9=\\;0.5,\\;\\rho=\\;10^8\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;10^3\\;\\mathrm{s})$，$(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为\n$[r_A^{(1)},r_Z^{(1)},\\tau_A^{(1)},\\tau_Z^{(1)},r_A^{(2)},r_Z^{(2)},\\tau_A^{(2)},\\tau_Z^{(2)},r_A^{(3)},r_Z^{(3)},\\tau_A^{(3)},\\tau_Z^{(3)},r_A^{(4)},r_Z^{(4)},\\tau_A^{(4)},\\tau_Z^{(4)}]$。\n所有数字都应以普通浮点数（十进制或科学记数法）形式打印。残差 $r_A$ 和 $r_Z$ 是无量纲的，容差 $\\tau_A$ 和 $\\tau_Z$ 是无量纲的绝对容差。",
            "solution": "问题陈述经评估为**有效**。它在科学上植根于核天体物理学和反应网络理论的既定原理。该问题是适定的，提供了一套完整且自洽的定义、物理常数、初始条件和控制方程，足以确定唯一解。在流体静力学条件下的碳燃烧场景是计算天体物理学中的一个标准且物理上现实的问题。该数值任务涉及对一个刚性系统进行后向欧拉积分步，并随后验证守恒律，这是科学计算中一个相关且重要的练习。\n\n该问题的核心是为流体静力学碳燃烧建立一个简化的反应网络模型。涉及的物质种类是 $i\\in\\{^{12}\\mathrm{C},^{20}\\mathrm{Ne},^{23}\\mathrm{Na},^{24}\\mathrm{Mg},\\alpha,\\mathrm{p}\\}$。该过程由 $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}$ 聚变反应引发，该反应分支成三个不同的通道。物质丰度 $Y_i$ 的演化由一个耦合常微分方程组 (ODEs) 描述。对于一个通用物质 $j$，其变化率由下式给出：\n$$\n\\frac{dY_j}{dt} = f_j(Y_{^{12}\\mathrm{C}}) = c_j \\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2\n$$\n其中 $k(T,\\rho)$ 是反应速率系数，$c_j$ 是化学计量系数。具体来说，$c_{^{12}\\mathrm{C}} = -1$，$c_{^{20}\\mathrm{Ne}} = c_{\\alpha} = \\frac{1}{2}b_\\alpha$，$c_{^{23}\\mathrm{Na}} = c_{\\mathrm{p}} = \\frac{1}{2}b_p$，以及 $c_{^{24}\\mathrm{Mg}} = \\frac{1}{2}b_\\gamma$。产物生成中的因子 $\\frac{1}{2}$ 源于相同反应物的反应速率定义。\n\n必须遵守两个基本物理定律：重子数守恒和电荷守恒。在数丰度形式中，这些定律表示为对丰度的线性约束：\n$$\n\\sum_i A_i Y_i = 1 \\quad (\\text{重子数守恒})\n$$\n$$\n\\sum_i Z_i Y_i = Y_e \\quad (\\text{电荷守恒})\n$$\n其中 $A_i$ 和 $Z_i$ 分别是核素 $i$ 的质量数和质子数，$Y_e$ 是电子分数。给定核反应的化学计量对于 $A_i$ 和 $Z_i$ 都是平衡的。例如，对于 α 通道，$2 A_{^{12}\\mathrm{C}} = A_{^{20}\\mathrm{Ne}} + A_{\\alpha}$ 且 $2 Z_{^{12}\\mathrm{C}} = Z_{^{20}\\mathrm{Ne}} + Z_{\\alpha}$。一个关键的推论是，该常微分方程组拥有线性不变量。对守恒和式对时间求导，得到：\n$$\n\\frac{d}{dt} \\sum_i A_i Y_i = \\sum_i A_i \\frac{dY_i}{dt} = k Y_{^{12}\\mathrm{C}}^2 \\sum_i A_i c_i = k Y_{^{12}\\mathrm{C}}^2 \\left( -A_{^{12}\\mathrm{C}} + \\sum_{\\text{products } j} A_j c_j \\right)\n$$\n使用化学计量关系以及 $b_\\alpha+b_p+b_\\gamma=1$ 这一事实，括号中的项计算结果为零。因此，$\\frac{d}{dt}\\sum_i A_i Y_i = 0$。同样的论证表明 $\\frac{d}{dt}\\sum_i Z_i Y_i = 0$。结论是，常微分方程组的精确解完美地保持重子数和电荷守恒。\n\n问题要求使用隐式后向欧拉法，将系统在一个时间步长 $\\Delta t$ 内从初始状态 $Y^n$ 推进到新状态 $Y^{n+1}$：\n$$\nY_i^{n+1} = Y_i^{n} + \\Delta t\\, \\left.\\dfrac{dY_i}{dt}\\right|_{Y^{n+1}} = Y_i^{n} + \\Delta t\\, c_i\\, k\\, (Y_{^{12}\\mathrm{C}}^{n+1})^2\n$$\n对于 $^{12}\\mathrm{C}$ ($c_{^{12}\\mathrm{C}}=-1$)，这变成了一个关于 $Y_{^{12}\\mathrm{C}}^{n+1}$ 的非线性代数方程：\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = Y_{^{12}\\mathrm{C}}^{n} - \\Delta t\\, k\\, (Y_{^{12}\\mathrm{C}}^{n+1})^2\n$$\n重新整理得到关于 $y \\equiv Y_{^{12}\\mathrm{C}}^{n+1}$ 的标准二次方程：\n$$\n(\\Delta t\\,k) y^2 + y - Y_{^{12}\\mathrm{C}}^{n} = 0\n$$\n物理上有意义的解必须是正的，对应于以下根：\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = \\frac{-1 + \\sqrt{1 + 4\\,\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}}}{2\\,\\Delta t\\,k}\n$$\n对于无量纲参数 $\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}$ 的小值，这个公式容易出现灾难性相消。一个通过分子有理化推导出的数值稳定替代形式被用于实现：\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = \\frac{2\\,Y_{^{12}\\mathrm{C}}^{n}}{1 + \\sqrt{1 + 4\\,\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}}}\n$$\n一旦求出 $Y_{^{12}\\mathrm{C}}^{n+1}$，所有产物物质的丰度就可以显式计算出来。\n\n后向欧拉法的一个关键特性是它能精确地保持常微分方程组的线性不变量。为了证明这一点，设 $\\delta_Y \\equiv \\Delta t\\,k\\,(Y_{^{12}\\mathrm{C}}^{n+1})^2$。更新方程为 $Y_{^{12}\\mathrm{C}}^{n+1} = Y_{^{12}\\mathrm{C}}^{n} - \\delta_Y$ 以及产物 $j$ 的 $Y_{j}^{n+1} = Y_{j}^{n} + c_j \\delta_Y$。对步骤 n+1 的所有物质求重子数守恒定律的和：\n$$\n\\sum_i A_i Y_i^{n+1} = A_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^{n+1} + \\sum_{\\text{products } j} A_j Y_j^{n+1}\n= A_{^{12}\\mathrm{C}}(Y_{^{12}\\mathrm{C}}^{n} - \\delta_Y) + \\sum_{j} A_j(Y_j^n + c_j \\delta_Y)\n$$\n$$\n= \\left(A_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^{n} + \\sum_{j} A_j Y_j^n\\right) - \\delta_Y \\left( A_{^{12}\\mathrm{C}} - \\sum_{j} A_j c_j \\right) = \\sum_i A_i Y_i^n\n$$\n乘以 $\\delta_Y$ 的项为零，这是因为与连续情况中所证明的化学计量平衡相同。因此，$\\sum_i A_i Y_i^{n+1} = \\sum_i A_i Y_i^n$。在开始时，$\\sum_i A_i Y_i^0 = A_{^{12}\\mathrm{C}} Y_{^{12}\\mathrm{C}}^0 = 12 \\times (1/12) = 1$。该方法因此将此和精确地保持为 $1$。电荷守恒也是如此，其中 $\\sum_i Z_i Y_i^0 = Z_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^0 = 6 \\times (1/12) = 0.5$。\n\n守恒残差定义为 $r_A = |\\sum_i A_i Y_i^{n+1} - 1|$ 和 $r_Z = |\\sum_i Z_i Y_i^{n+1} - Y_e^0|$。根据以上分析，$r_A$ 和 $r_Z$ 的解析值精确为零。在数值实现中获得的任何非零值都完全源于计算丰度及其加权和时的浮点舍入误差。\n\n绝对容差 $\\tau_A$ 和 $\\tau_Z$ 反映了最大可接受的数值误差。鉴于守恒量 $\\sum A_i Y_i$ 和 $\\sum Z_i Y_i$ 的量级分别为 $1$ 和 $0.5$，舍入误差预期会与机器epsilon（对于IEEE 754双精度，$\\epsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16}$）成比例。对 $N$ 个量级为 $\\mathcal{O}(1)$ 的浮点数求和，可以累积 $\\mathcal{O}(N \\times \\epsilon_{\\text{mach}})$ 的误差。对于我们这个包含 $6$ 种物质的系统，一个保守而严格的容差是合适的。我们提议一个固定的绝对容差 $\\tau_A = \\tau_Z = 10^{-14}$。这个值比机器epsilon大几个数量级，提供了一个稳健的下限来考虑多个浮点运算中的误差累积，同时又足够小，可以确认守恒律被高精度地维持。\n\n对于每个测试用例，算法流程如下：\n1.  使用提供的 $\\mathcal{R}(T_9)$ 公式计算速率系数 $k(T,\\rho)$。\n2.  设置初始丰度：$Y_{^{12}\\mathrm{C}}^0 = 1/12$ 且所有其他 $Y_i^0 = 0$。\n3.  如果 $\\Delta t = 0$，丰度不变，残差精确为 $0$。\n4.  如果 $\\Delta t > 0$，使用数值稳定形式求解二次方程来计算 $Y_{^{12}\\mathrm{C}}^{n+1}$。\n5.  使用在 $Y_{^{12}\\mathrm{C}}^{n+1}$ 处计算的后向欧拉公式计算新的产物丰度 $Y_{j}^{n+1}$。\n6.  计算和式 $\\sum_i A_i Y_i^{n+1}$ 和 $\\sum_i Z_i Y_i^{n+1}$。\n7.  计算绝对残差 $r_A$ 和 $r_Z$ 并将它们与提议的容差 $\\tau_A$ 和 $\\tau_Z$ 配对。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_R(T9):\n    \"\"\"\n    Calculates the molar rate coefficient R(T9) using the CF88-style fit.\n    T9 is temperature in 10^9 K.\n    \"\"\"\n    if T9 == 0:\n        return 0.0\n\n    T9_1_3 = T9**(1.0/3.0)\n    T9_2_3 = T9_1_3**2\n    T9_4_3 = T9_1_3**4\n    T9_5_3 = T9_1_3**5\n\n    poly_term = (1.0 + 0.0489 * T9_1_3 + 0.265 * T9_2_3 + 0.270 * T9 +\n                 0.017 * T9_4_3 + 0.330 * T9_5_3)\n\n    exp_term_val = -84.165 / T9_1_3 - 2.12e-3 * T9**2\n    \n    # Handle potential underflow in exp\n    if exp_term_val  -700: # np.exp(-709) is ~1e-308, below that is 0\n        exp_term = 0.0\n    else:\n        exp_term = np.exp(exp_term_val)\n\n    R = (4.27e26 * T9**(-2.0/3.0) * exp_term * poly_term)\n    return R\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    \n    # Species in the network: C-12, Ne-20, Na-23, Mg-24, alpha, proton\n    A_vals = np.array([12, 20, 23, 24, 4, 1], dtype=np.float64)\n    Z_vals = np.array([6, 10, 11, 12, 2, 1], dtype=np.float64)\n\n    # Test cases: (T9, rho, dt, (b_alpha, b_p, b_gamma))\n    test_cases = [\n        (0.8, 1e9, 1e-4, (0.60, 0.39, 0.01)),\n        (0.8, 1e9, 0.0, (0.60, 0.39, 0.01)),\n        (1.0, 2e9, 1.0, (0.60, 0.39, 0.01)),\n        (0.5, 1e8, 1e3, (0.60, 0.39, 0.01)),\n    ]\n\n    results = []\n    \n    # Initial conditions from X_C12 = 1\n    Y0_C12 = 1.0 / A_vals[0]\n    Y0 = np.zeros(len(A_vals), dtype=np.float64)\n    Y0[0] = Y0_C12\n    Ye0 = np.sum(Z_vals * Y0) # = 0.5\n\n    # Proposed absolute tolerances for conservation checks\n    tau_A = 1.0e-14\n    tau_Z = 1.0e-14\n\n    for case in test_cases:\n        T9, rho, dt, (b_alpha, b_p, b_gamma) = case\n        \n        # If timestep is zero, no change occurs.\n        if dt == 0.0:\n            Y1 = Y0.copy()\n        else:\n            # Calculate the rate coefficient k = rho * R(T9)\n            R = calculate_R(T9)\n            k = rho * R\n            # The rate k has units of cm^3 / (g * s)\n\n            # Solve for Y_C12 at step n+1 using the backward Euler method.\n            # This yields a quadratic equation for Y1_C12. We use the\n            # numerically stable solution.\n            arg_sqrt = 1.0 + 4.0 * dt * k * Y0_C12\n            Y1_C12 = (2.0 * Y0_C12) / (1.0 + np.sqrt(arg_sqrt))\n\n            # Calculate the abundances of the products at step n+1\n            dt_k_Y1_C12_sq = dt * k * Y1_C12**2\n            \n            Y1_Ne20 = 0.0 + 0.5 * b_alpha * dt_k_Y1_C12_sq\n            Y1_alpha = 0.0 + 0.5 * b_alpha * dt_k_Y1_C12_sq\n            Y1_Na23 = 0.0 + 0.5 * b_p * dt_k_Y1_C12_sq\n            Y1_p = 0.0 + 0.5 * b_p * dt_k_Y1_C12_sq\n            Y1_Mg24 = 0.0 + 0.5 * b_gamma * dt_k_Y1_C12_sq\n\n            Y1 = np.array([Y1_C12, Y1_Ne20, Y1_Na23, Y1_Mg24, Y1_alpha, Y1_p], dtype=np.float64)\n\n        # Compute conservation sums at step n+1\n        sum_AY1 = np.sum(A_vals * Y1)\n        sum_ZY1 = np.sum(Z_vals * Y1)\n\n        # Compute absolute residuals\n        # Initial baryon number sum is 1.0\n        r_A = np.abs(sum_AY1 - 1.0)\n        # Initial electron fraction is Ye0\n        r_Z = np.abs(sum_ZY1 - Ye0)\n\n        results.extend([r_A, r_Z, tau_A, tau_Z])\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在恒星中，核反应与局部热力学状态内在地耦合在一起，其过程遵循热力学第一定律和状态方程 (EOS)。本实践将我们的模型提升到一个更完整的物理图像，来描述一个在恒定压力下燃烧的恒星区域。通过整合一个与实际状态方程耦合的氖燃烧网络，您将执行一项至关重要的验证测试 ：确认恒星内部能量的变化与核反应产生的总能量减去中微子损失精确匹配，从而验证模拟的核心物理过程。",
            "id": "3590315",
            "problem": "给定一个简化的、但在科学上一致的流体静力学轨迹模型，该模型描述了在大质量恒星中经历氖燃烧的单个拉格朗日质量区。目标是在等压燃烧算子下验证全局能量守恒，通过将时间积分的比核加热减去中微子冷却与沿等压路径的比内能变化进行比较来实现。此验证在流体静力学燃烧阶段的计算核物理背景下进行。\n\n基本原理包括以下几个支柱：\n- 拉格朗日流体元的热力学第一定律：$d u = \\dot{\\epsilon}_{\\mathrm{nuc}}\\,dt - \\epsilon_{\\nu}\\,dt - P\\,d(1/\\rho)$，其中 $u$ 是比内能，$\\dot{\\epsilon}_{\\mathrm{nuc}}$ 是单位质量单位时间的核加热率，$\\epsilon_{\\nu}$ 是单位时间的比中微子冷却率，$P$ 是压强，$\\rho$ 是密度。\n- 在流体静力学环境中，对短时间间隔应用等压燃烧算子时，力学弛豫是分开处理的。在燃烧子步中，热能更新时忽略了力学功项 $P\\,d(1/\\rho)$，并通过状态方程 (EOS) 强制执行约束 $P=\\mathrm{const}$。因此，热能更新简化为 $d u = \\dot{\\epsilon}_{\\mathrm{nuc}}\\,dt - \\epsilon_{\\nu}\\,dt$，而随着温度 $T$ 的演化，$\\rho$ 由恒定 $P$ 下的状态方程得出。\n- 完全电离的理想气体加辐射的状态方程 (EOS) 为 $P(\\rho,T) = \\rho \\,k_B T / (\\mu m_u) + (1/3)\\,a\\,T^4$，假设每粒子的平均分子量 $\\mu$（包括离子和电子）为常数。其中 $k_B$ 是玻尔兹曼常数，$m_u$ 是原子质量单位，$a$ 是辐射常数。比内能为 $u(\\rho,T) = (3/2)\\,k_B T/(\\mu m_u) + a T^4/\\rho$。\n- 压强约束 $P=\\mathrm{const}$ 通过状态方程隐式地提供了 $\\rho(T)$：$\\rho(T) = \\alpha \\,[P - (a/3)\\,T^4]/T$，其中 $\\alpha \\equiv \\mu m_u/k_B$。\n- 核能的产生由一个具有强温度依赖性的单一有效通道表示：$\\dot{\\epsilon}_{\\mathrm{nuc}}(T,\\rho,X_{\\mathrm{Ne}}) = Q_{\\mathrm{mass}} \\,\\lambda_0\\,\\rho^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}$，其中 $Q_{\\mathrm{mass}}$ 是每单位质量消耗的氖所释放的能量，$\\lambda_0$ 是一个速率系数，$\\alpha_\\rho$ 是密度指数，$T_9 \\equiv T/(10^9\\,\\mathrm{K})$，$n$ 是温度指数，$T^\\star$ 是一个特征温标，$X_{\\mathrm{Ne}}$ 是氖质量分数。\n- 在这些温度下，中微子冷却主要由电子-正电子对过程主导，并近似为 $\\epsilon_{\\nu}(T) = C_\\nu\\,T_9^9$。\n\n你必须编写一个完整、可运行的程序，该程序：\n1. 通过从状态方程中表达 $\\rho(T)$ 来实现等压约束 $P=\\mathrm{const}$。\n2. 使用与简化的热力学第一定律 $d u/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_\\nu$ 一致的常微分方程 (ODE) 系统来演化温度 $T(t)$ 和氖质量分数 $X_{\\mathrm{Ne}}(t)$，其中 $u(\\rho(T),T)$ 如上定义。\n3. 对净加热 $H(t) \\equiv \\dot{\\epsilon}_{\\mathrm{nuc}}(t) - \\epsilon_\\nu(t)$ 随时间积分以获得 $\\int_0^{t_{\\mathrm{end}}} H(t)\\,dt$，并在 $X_{\\mathrm{Ne}}$ 下降到指定目标 $X_{\\mathrm{end}}$ 时停止积分。\n4. 计算比内能的变化 $\\Delta u = u(\\rho(T_{\\mathrm{end}}),T_{\\mathrm{end}}) - u(\\rho(T_0),T_0)$。\n5. 通过比较 $\\int_0^{t_{\\mathrm{end}}} H(t)\\,dt$ 和 $\\Delta u$ 来验证能量守恒，并为每个测试用例返回一个布尔值，指示其相对差异是否在规定的容差范围内。\n\n所有物理和数值单位必须遵守：\n- 压强 $P$ 单位为 $\\mathrm{dyn}\\,\\mathrm{cm}^{-2}$。\n- 密度 $\\rho$ 单位为 $\\mathrm{g}\\,\\mathrm{cm}^{-3}$。\n- 温度 $T$ 单位为 $\\mathrm{K}$。\n- 时间 $t$ 单位为 $\\mathrm{s}$。\n- 比能量量 $u$、$\\dot{\\epsilon}_{\\mathrm{nuc}}$、$\\epsilon_\\nu$ 及其积分的单位为 $\\mathrm{erg}\\,\\mathrm{g}^{-1}$ 和 $\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$。\n- 平均分子量 $\\mu$ 被视为常数且无量纲。\n- 输出的布尔值指示 $|\\int H\\,dt - \\Delta u|/\\max(|\\Delta u|, \\delta) \\leq \\tau$ 是否成立，其中 $\\delta$ 是一个小的下限值，$\\tau$ 是容差。\n\n从第一性原理推导沿等压路径的温度演化：\n- 在 $u(T) = (3/2)\\,k_B T/(\\mu m_u) + a T^4/\\rho(T)$ 和 $\\rho(T) = \\alpha\\, [P - (a/3)T^4]/T$ 的条件下，定义沿等压线的有效比热 $c_{\\mathrm{eff}}(T) \\equiv du/dT$。\n- 使用简化的热力学第一定律写出 $dT/dt = [\\dot{\\epsilon}_{\\mathrm{nuc}}(T,\\rho(T),X_{\\mathrm{Ne}}) - \\epsilon_\\nu(T)]/c_{\\mathrm{eff}}(T)$ 和 $dX_{\\mathrm{Ne}}/dt = -\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}$。\n- 引入辅助积分状态 $E(t)$，其满足 $dE/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_\\nu$，以累积时间积分。\n\n使用的常数：\n- 玻尔兹曼常数 $k_B = 1.380649 \\times 10^{-16}\\,\\mathrm{erg}\\,\\mathrm{K}^{-1}$。\n- 原子质量单位 $m_u = 1.66053906660 \\times 10^{-24}\\,\\mathrm{g}$。\n- 辐射常数 $a = 7.5657 \\times 10^{-15}\\,\\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{K}^{-4}$。\n- 平均分子量 $\\mu = 0.6$。\n- 密度指数 $\\alpha_\\rho = 1$。\n- 温度指数 $n = 10$。\n- 特征温度 $T^\\star = 1.0 \\times 10^9\\,\\mathrm{K}$。\n- 每单位消耗的氖质量分数所释放的比能量 $Q_{\\mathrm{mass}} = 3.0 \\times 10^{17}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}$。\n- 容差 $\\tau = 5.0 \\times 10^{-4}$ 和下限值 $\\delta = 1.0 \\times 10^{-12}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}$。\n\n测试套件规范：\n提供以下测试用例，每个用例为一个元组 $(P, T_0, X_0, X_{\\mathrm{end}}, \\lambda_0, C_\\nu, t_{\\mathrm{max}})$：\n- 用例 A (正常路径，气体压强主导的等压过程): $(1.0 \\times 10^{23}, 1.30 \\times 10^{9}, 0.50, 0.40, 1.0 \\times 10^{-9}, 8.0 \\times 10^{13}, 500.0)$。\n- 用例 B (中微子冷却主导): $(1.0 \\times 10^{23}, 1.30 \\times 10^{9}, 0.50, 0.45, 2.0 \\times 10^{-9}, 5.0 \\times 10^{14}, 2000.0)$。\n- 用例 C (接近辐射压强边界): $(1.50 \\times 10^{22}, 1.30 \\times 10^{9}, 0.40, 0.35, 1.0 \\times 10^{-8}, 5.0 \\times 10^{13}, 500.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中每个 $r_i$ 是一个布尔值，指示相应测试用例的相对差异 $|\\int H\\,dt - \\Delta u|/\\max(|\\Delta u|, \\delta)$ 是否小于或等于容差 $\\tau$。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在计算核天体物理学领域提出了一个自洽、科学上一致且适定的问题。该场景描述了一个用于算子分裂流体动力学代码的标准数值验证测试，其目标是在指定的简化假设下，确认热能演化的数值积分与热力学第一定律相符。所有必需的方程、常数和初始条件均已提供，不存在任何矛盾或事实错误。\n\n解决方案基于流体元的热力学第一定律，在问题的等压（$P=\\mathrm{const}$）燃烧算子近似下，该定律简化为：\n$$\n\\frac{du}{dt} = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}\n$$\n其中 $u$ 是比内能，$\\dot{\\epsilon}_{\\mathrm{nuc}}$ 是比核加热率，$\\epsilon_{\\nu}$ 是比中微子冷却率。\n\n目标是数值验证比内能的总变化量 $\\Delta u = u_{\\mathrm{end}} - u_0$ 等于净比加热率的时间积分 $\\int_0^{t_{\\mathrm{end}}} (\\dot{\\epsilon}_{\\mathrm{nuc}}(t) - \\epsilon_{\\nu}(t)) dt$。这需要随时间演化系统的热力学状态——特别是其温度 $T$ 和组分（氖质量分数 $X_{\\mathrm{Ne}}$）。此演化由一个常微分方程（ODE）系统控制。\n\n系统的状态可以用一个向量 $\\vec{y}(t) = [T(t), X_{\\mathrm{Ne}}(t), E(t)]^T$ 来描述，其中 $E(t)$ 是一个辅助状态变量，代表累积的净加热：\n$$\nE(t) = \\int_0^t (\\dot{\\epsilon}_{\\mathrm{nuc}}(t') - \\epsilon_{\\nu}(t')) dt'\n$$\n$E$ 相应的常微分方程就是 $dE/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}$。\n\n为了推导温度的常微分方程，我们对简化的热力学第一定律的左侧应用链式法则：\n$$\n\\frac{du}{dt} = \\frac{du}{dT} \\bigg|_{P=\\mathrm{const}} \\frac{dT}{dt}\n$$\n我们将沿等压线的有效比热容定义为 $c_{\\mathrm{eff}}(T) \\equiv \\frac{du}{dT}|_{P=\\mathrm{const}}$。这使我们能够将温度演化方程写为：\n$$\n\\frac{dT}{dt} = \\frac{\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}}{c_{\\mathrm{eff}}(T)}\n$$\n$c_{\\mathrm{eff}}(T)$ 的推导至关重要。在等压约束下，比内能 $u$ 和密度 $\\rho$ 是温度 $T$ 的函数。给定的状态方程为 $P = \\rho k_B T / (\\mu m_u) + (1/3) a T^4$。定义常数 $\\alpha \\equiv \\mu m_u/k_B$，我们可以将密度表达为温度的函数：\n$$\n\\rho(T) = \\frac{\\alpha}{T} \\left(P - \\frac{1}{3} a T^4\\right)\n$$\n比内能由 $u(\\rho,T) = (3/2) k_B T/(\\mu m_u) + a T^4/\\rho$ 给出。代入 $\\rho(T)$ 即可得到沿等压线 $u$ 仅作为 $T$ 的函数：\n$$\nu(T) = \\frac{3}{2\\alpha}T + \\frac{a T^4}{\\frac{\\alpha}{T}(P - \\frac{1}{3} a T^4)} = \\frac{3}{2\\alpha}T + \\frac{a T^5}{\\alpha(P - \\frac{1}{3} a T^4)}\n$$\n通过商法则对 $u(T)$ 求关于 $T$ 的导数，得到 $c_{\\mathrm{eff}}(T)$ 的表达式：\n$$\nc_{\\mathrm{eff}}(T) = \\frac{du}{dT} = \\frac{3P^2 + 8PaT^4 - \\frac{1}{3}a^2T^8}{2\\alpha \\left(P - \\frac{1}{3}aT^4\\right)^2}\n$$\n氖质量分数 $X_{\\mathrm{Ne}}$ 的演化由反应动力学给出。问题将破坏率定义为：\n$$\n\\frac{dX_{\\mathrm{Ne}}}{dt} = -\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}\n$$\n其中 $T_9 = T / (10^9\\,\\mathrm{K})$。根据给定的公式，这与核能生成率 $\\dot{\\epsilon}_{\\mathrm{nuc}} = -Q_{\\mathrm{mass}} (dX_{\\mathrm{Ne}}/dt)$ 一致。\n\n需要求解的完整 ODE 系统是：\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} T \\\\ X_{\\mathrm{Ne}} \\\\ E \\end{pmatrix}\n=\n\\begin{pmatrix}\n(\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}) / c_{\\mathrm{eff}}(T) \\\\\n-\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}} \\\\\n\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}\n\\end{pmatrix}\n$$\n这个初值问题使用数值常微分方程积分器（例如 `scipy.integrate.solve_ivp`）来求解，从初始状态 $[T_0, X_0, 0]$ 开始。积分被配置为当 $X_{\\mathrm{Ne}}$ 达到指定的最终质量分数 $X_{\\mathrm{end}}$ 时终止，这是通过求解器的事件检测功能实现的。\n\n在时间 $t_{\\mathrm{end}}$ 终止时，求解器返回最终状态 $[T_{\\mathrm{end}}, X_{\\mathrm{end}}, E_{\\mathrm{integrated}}]$。项 $E_{\\mathrm{integrated}}$ 是 $\\int H dt$ 的数值计算值。比内能的变化量 $\\Delta u$ 使用初始和最终状态独立计算：\n$$\n\\Delta u = u(\\rho(T_{\\mathrm{end}}), T_{\\mathrm{end}}) - u(\\rho(T_0), T_0)\n$$\n最后，通过检查这两个量之间的相对差异是否在规定的容差 $\\tau$ 范围内来验证能量守恒：\n$$\n\\frac{|\\Delta u - E_{\\mathrm{integrated}}|}{\\max(|\\Delta u|, \\delta)} \\le \\tau\n$$\n提供的 Python 程序实现了这一逻辑，定义了用于计算 $\\rho(T)$、 $u(\\rho, T)$ 和 $c_{\\mathrm{eff}}(T)$ 的辅助函数，然后遍历每个测试用例以求解 ODE 并执行验证。采用高精度求解器方法（`Radau`）和严格的容差，以最小化数值积分误差，并确保检查能正确验证模型实现的物理和数学一致性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Physical and numerical constants\nk_B_val = 1.380649e-16  # erg K^-1\nm_u_val = 1.66053906660e-24  # g\na_val = 7.5657e-15  # erg cm^-3 K^-4\nmu_val = 0.6\nalpha_rho_val = 1.0\nn_val = 10.0\nT_star_val = 1.0e9  # K\nQ_mass_val = 3.0e17  # erg g^-1\ntau_val = 5.0e-4\ndelta_val = 1.0e-12  # erg g^-1\n\nalpha_val = mu_val * m_u_val / k_B_val  # g K erg^-1\n\ndef get_rho(T, P):\n    \"\"\"Calculates density on the isobar given T and P.\"\"\"\n    rad_pressure_part = (a_val / 3.0) * T**4\n    if P = rad_pressure_part:\n        return np.nan\n    return alpha_val * (P - rad_pressure_part) / T\n\ndef get_u(T, rho):\n    \"\"\"Calculates specific internal energy given T and rho.\"\"\"\n    if rho = 0:\n        return np.nan\n    # u = (3/2) * k_B * T / (mu * m_u) + a * T**4 / rho\n    # (k_B / (mu * m_u)) is 1/alpha\n    return (3.0 / 2.0) * T / alpha_val + a_val * T**4 / rho\n\ndef get_c_eff(T, P):\n    \"\"\"Calculates effective specific heat capacity along the isobar.\"\"\"\n    rad_pressure_part = (a_val / 3.0) * T**4\n    denom_factor = P - rad_pressure_part\n    if denom_factor = 0:\n        return np.nan\n\n    P_sq = P**2\n    a_sq = a_val**2\n    T_4 = T**4\n    T_8 = T_4**2\n    \n    numerator = 3.0 * P_sq + 8.0 * P * a_val * T_4 - (1.0 / 3.0) * a_sq * T_8\n    denominator = 2.0 * alpha_val * denom_factor**2\n    return numerator / denominator\n\ndef ode_rhs(t, y, P, lambda0, C_nu):\n    \"\"\"Right-hand side of the ODE system dy/dt = f(t, y).\"\"\"\n    T, X_Ne, _ = y\n    \n    if T = 0:\n        return [0.0, 0.0, 0.0]\n\n    T9 = T / 1.0e9\n    \n    rho = get_rho(T, P)\n    if np.isnan(rho) or rho = 0:\n        return [0.0, 0.0, 0.0]\n\n    # Reaction rate factor\n    rate_factor = lambda0 * rho**alpha_rho_val * T9**n_val * np.exp(-T_star_val / T)\n    \n    eps_nuc = Q_mass_val * rate_factor * X_Ne\n    eps_nu = C_nu * T9**9\n    net_heating = eps_nuc - eps_nu\n    \n    c_eff = get_c_eff(T, P)\n    if np.isnan(c_eff) or c_eff = 0:\n        return [0.0, 0.0, 0.0]\n\n    dT_dt = net_heating / c_eff\n    dX_Ne_dt = -rate_factor * X_Ne\n    dE_dt = net_heating\n    \n    return [dT_dt, dX_Ne_dt, dE_dt]\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # (P, T0, X0, X_end, lambda0, C_nu, t_max)\n        (1.0e23, 1.30e9, 0.50, 0.40, 1.0e-9, 8.0e13, 500.0),\n        (1.0e23, 1.30e9, 0.50, 0.45, 2.0e-9, 5.0e14, 2000.0),\n        (1.50e22, 1.30e9, 0.40, 0.35, 1.0e-8, 5.0e13, 500.0),\n    ]\n\n    results = []\n    for P, T0, X0, X_end, lambda0, C_nu, t_max in test_cases:\n        rho0 = get_rho(T0, P)\n        u0 = get_u(T0, rho0)\n        y0 = [T0, X0, 0.0]\n\n        def stop_event(t, y, P, lambda0, C_nu):\n            return y[1] - X_end\n        stop_event.terminal = True\n        \n        sol = solve_ivp(\n            fun=ode_rhs,\n            t_span=[0, t_max],\n            y0=y0,\n            args=(P, lambda0, C_nu),\n            events=stop_event,\n            dense_output=True,\n            method='Radau',\n            rtol=1e-9,\n            atol=1e-9\n        )\n\n        if not sol.t_events or not sol.t_events[0] or sol.status == -1:\n            results.append(False)\n            continue\n            \n        y_end = sol.y_events[0].flatten()\n        T_end, _, E_integrated = y_end\n        \n        rho_end = get_rho(T_end, P)\n        u_end = get_u(T_end, rho_end)\n        \n        Delta_u = u_end - u0\n        \n        discrepancy = abs(E_integrated - Delta_u)\n        denominator = max(abs(Delta_u), delta_val)\n        \n        if denominator == 0:\n             is_conserved = (discrepancy == 0)\n        else:\n            relative_discrepancy = discrepancy / denominator\n            is_conserved = relative_discrepancy = tau_val\n            \n        results.append(is_conserved)\n\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```"
        }
    ]
}