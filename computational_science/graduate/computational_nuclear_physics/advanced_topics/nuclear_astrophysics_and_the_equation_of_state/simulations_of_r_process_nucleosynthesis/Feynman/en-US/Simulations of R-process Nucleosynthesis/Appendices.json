{
    "hands_on_practices": [
        {
            "introduction": "The waiting-point approximation (WPA) is a foundational concept in r-process theory, simplifying complex reaction networks by assuming a state of nuclear statistical equilibrium is achieved within isotopic chains. This practice provides a direct, quantitative test of the WPA's validity by comparing its predictions against a full kinetic simulation across various astrophysical conditions. By implementing this comparison, you will develop a concrete intuition for the temperature and density regimes where this crucial approximation holds and where it breaks down .",
            "id": "3590848",
            "problem": "Construct a program that quantitatively tests the validity of the waiting-point approximation for a single isotopic chain in rapid neutron-capture process (r-process) nucleosynthesis by scanning neutron number density and temperature pairs and comparing the resulting waiting-point distribution to the solution of the full linear reaction-kinetics system over a finite time. The model must be fully specified and internally consistent, starting from detailed balance and nuclear statistical equilibrium within an isotopic chain.\n\nYou must assume a fixed isotopic chain of five consecutive isotopes labeled by an index $i \\in \\{0,1,2,3,4\\}$ that represent increasing mass number within a fixed proton number $Z$ chain. Let the neutron separation energy sequence (in megaelectronvolts) be\n$S_n(0)=3.5$, $S_n(1)=3.0$, $S_n(2)=2.5$, $S_n(3)=2.2$, $S_n(4)=1.8$,\nwhich is a plausible decreasing trend with increasing neutron number in neutron-rich isotopes. Assume the following physically motivated modeling choices and constants.\n\n- The neutron capture rate from isotope $i$ to isotope $i+1$ is $r^{\\mathrm{cap}}_i = n_n \\langle \\sigma v \\rangle$, with $r^{\\mathrm{cap}}_{4}=0$, where $n_n$ is the free neutron number density (in $\\mathrm{cm}^{-3}$) and $\\langle \\sigma v \\rangle = \\sigma_0 v_{\\mathrm{th}}$ with a constant effective capture cross section $\\sigma_0 = 5\\times 10^{-24}\\ \\mathrm{cm}^2$ and thermal relative speed $v_{\\mathrm{th}} = \\sqrt{\\frac{8 k_B T}{\\pi m_n}}$ in $\\mathrm{cm/s}$. Here $k_B$ is the Boltzmann constant and $m_n$ is the neutron mass.\n- The photodisintegration rate that removes one neutron from isotope $i$ back to isotope $i-1$ is $\\lambda^{\\gamma n}_i$ with $\\lambda^{\\gamma n}_0=0$. Enforce detailed balance with the capture channel under nuclear statistical equilibrium by requiring\n$$\n\\lambda^{\\gamma n}_i \\;=\\; \\langle \\sigma v \\rangle \\times \\frac{2 G_{i-1}}{G_i} \\times n_Q \\times \\exp\\!\\left(-\\frac{S_n(i)}{k_B T}\\right) \\quad \\text{for } i\\ge 1,\n$$\nwhere $G_i$ is the normalized internal partition function of isotope $i$, take $G_i=1$ for all $i$, and $n_Q$ is the neutron quantum concentration defined by\n$$\nn_Q \\;=\\; \\left( \\frac{m_n k_B T}{2\\pi \\hbar^2} \\right)^{3/2}.\n$$\nHere $\\hbar$ is the reduced Planck constant.\n- All physical constants must be used with self-consistent units. The temperature input $T$ is given in gigakelvin and must be converted to kelvin as $T_{\\mathrm{K}} = T \\times 10^9$. The neutron density $n_n$ is in $\\mathrm{cm}^{-3}$. Compute $v_{\\mathrm{th}}$ using $T_{\\mathrm{K}}$ and convert it to $\\mathrm{cm/s}$. Compute $n_Q$ in $\\mathrm{m}^{-3}$ and convert it to $\\mathrm{cm}^{-3}$ by dividing by $10^6$. For Boltzmann factors $\\exp(-S_n/k_BT)$ and $\\exp(S_n/k_BT)$, use $k_B T$ in the same energy units as $S_n$, namely megaelectronvolts; you must therefore use $k_B = 8.617333262\\times 10^{-11}\\ \\mathrm{MeV/K}$ for those exponentials.\n\nDefine the full linear reaction-kinetics system for the abundance vector $\\mathbf{Y}(t) = (Y_0(t),\\dots,Y_4(t))^\\top$ with the inflow/outflow structure induced by single-neutron capture and single-neutron photodisintegration within the chain:\n- For $i=0$,\n$$\n\\frac{dY_0}{dt} \\;=\\; - r^{\\mathrm{cap}}_0 Y_0 \\;+\\; \\lambda^{\\gamma n}_1 Y_1.\n$$\n- For $0i4$,\n$$\n\\frac{dY_i}{dt} \\;=\\; r^{\\mathrm{cap}}_{i-1} Y_{i-1} \\;-\\; \\left( r^{\\mathrm{cap}}_i + \\lambda^{\\gamma n}_i \\right) Y_i \\;+\\; \\lambda^{\\gamma n}_{i+1} Y_{i+1}.\n$$\n- For $i=4$,\n$$\n\\frac{dY_4}{dt} \\;=\\; r^{\\mathrm{cap}}_{3} Y_{3} \\;-\\; \\lambda^{\\gamma n}_4 Y_4.\n$$\nThese equations can be written as $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M}\\,\\mathbf{Y}$ with a tri-diagonal rate matrix $\\mathbf{M}$ determined by $\\{r^{\\mathrm{cap}}_i\\}$ and $\\{\\lambda^{\\gamma n}_i\\}$. Use the initial condition $Y_2(0)=1$ and $Y_i(0)=0$ for all $i\\neq 2$, which represents all initial abundance localized at the central isotope $i=2$. Evolve to a specified final time $t_{\\mathrm{final}}$ (in seconds) to obtain $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$, the kinetic solution. Ensure that any small numerical negative components in $\\mathbf{Y}^{\\mathrm{kin}}$ are clipped to zero and renormalize so that $\\sum_i Y_i=1$ within machine precision.\n\nDefine the waiting-point approximation (nuclear statistical equilibrium within the isotopic chain) distribution $\\mathbf{Y}^{\\mathrm{WPA}}$ as the chain determined by the Saha-like ratios between adjacent isotopes,\n$$\n\\frac{Y^{\\mathrm{WPA}}_{i}}{Y^{\\mathrm{WPA}}_{i-1}} \\;=\\; n_n\\,\\Theta\\,\\frac{G_i}{2 G_{i-1}}\\;\\exp\\!\\left(\\frac{S_n(i)}{k_B T}\\right) \\quad \\text{for } i=1,2,3,4,\n$$\nwith $\\Theta = n_Q^{-1}$ and $G_i=1$. Construct $\\mathbf{Y}^{\\mathrm{WPA}}$ up to normalization by taking $Y^{\\mathrm{WPA}}_0=1$ and $Y^{\\mathrm{WPA}}_i = Y^{\\mathrm{WPA}}_{i-1}\\times \\left[n_n \\Theta \\times \\frac{1}{2} \\times \\exp\\left(\\frac{S_n(i)}{k_B T}\\right)\\right]$ for $i\\ge 1$, and then normalize so that $\\sum_i Y^{\\mathrm{WPA}}_i = 1$.\n\nQuantify the deviation between the kinetic solution at finite time and the waiting-point approximation by the total variation distance\n$$\n\\Delta \\;=\\; \\frac{1}{2} \\sum_{i=0}^{4} \\left| Y^{\\mathrm{kin}}_i(t_{\\mathrm{final}}) - Y^{\\mathrm{WPA}}_i \\right|.\n$$\nThis deviation is dimensionless and satisfies $0 \\le \\Delta \\le 1$.\n\nYour program must implement the model and compute $\\Delta$ for the following test suite of neutron density, temperature, and evolution time triplets:\n- Case A (typical r-process conditions with fast equilibration): $(n_n, T, t_{\\mathrm{final}}) = (10^{25}\\ \\mathrm{cm}^{-3},\\ 1.5\\ \\mathrm{GK},\\ 10^{-3}\\ \\mathrm{s})$.\n- Case B (slower kinetics at lower neutron density and shorter time): $(10^{20}\\ \\mathrm{cm}^{-3},\\ 1.0\\ \\mathrm{GK},\\ 10^{-6}\\ \\mathrm{s})$.\n- Case C (higher temperature with strong photodisintegration but long time): $(10^{24}\\ \\mathrm{cm}^{-3},\\ 2.0\\ \\mathrm{GK},\\ 5\\times 10^{-4}\\ \\mathrm{s})$.\n- Case D (low temperature, low neutron density, short time leading to freeze-out): $(10^{18}\\ \\mathrm{cm}^{-3},\\ 0.5\\ \\mathrm{GK},\\ 10^{-5}\\ \\mathrm{s})$.\n\nAll physical constants must be used in their standard values:\n- $k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ for kinematic speeds and $k_B = 8.617333262\\times 10^{-11}\\ \\mathrm{MeV/K}$ in Boltzmann factors.\n- $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J\\,s}$.\n- $m_n = 1.67492749804\\times 10^{-27}\\ \\mathrm{kg}$.\n\nThe required final output format is a single line containing the four deviations $\\Delta$ for Cases A, B, C, and D in that order, formatted as a comma-separated list enclosed in square brackets with no spaces, each as scientific notation with six significant figures (for example, `[1.234560e-03,7.890000e-02,...]`). Your program must produce exactly this single line as its only output. Since $\\Delta$ is dimensionless, no physical unit is required in the output.",
            "solution": "The problem requires a quantitative comparison between two models for describing nuclear abundances in an isotopic chain under conditions relevant to the rapid neutron-capture (r-) process: a full time-dependent reaction kinetics model and the waiting-point approximation (WPA). The comparison is to be performed by calculating the total variation distance between the abundance distributions predicted by each model at a specified final time for several sets of astrophysical conditions (neutron number density $n_n$, temperature $T$, and evolution time $t_{\\mathrm{final}}$).\n\nFirst, we establish the physical and mathematical framework based on the provided specifications. The system consists of five isotopes of a single element (fixed proton number $Z$), indexed by $i \\in \\{0, 1, 2, 3, 4\\}$, corresponding to increasing mass and neutron numbers. The primary reactions considered are single-neutron capture, $(n, \\gamma)$, and its inverse, photodisintegration, $(\\gamma, n)$.\n\nThe rate of neutron capture on isotope $i$, producing isotope $i+1$, is denoted by $r^{\\mathrm{cap}}_i$. This rate is proportional to the free neutron number density $n_n$ and the thermally-averaged rate coefficient $\\langle \\sigma v \\rangle$:\n$$\nr^{\\mathrm{cap}}_i = n_n \\langle \\sigma v \\rangle\n$$\nThe rate coefficient is modeled as $\\langle \\sigma v \\rangle = \\sigma_0 v_{\\mathrm{th}}$, where $\\sigma_0 = 5 \\times 10^{-24}\\ \\mathrm{cm}^2$ is a constant effective cross section, and $v_{\\mathrm{th}} = \\sqrt{\\frac{8 k_B T}{\\pi m_n}}$ is the mean relative speed between neutrons and nuclei at temperature $T$. The capture chain terminates at isotope $i=4$, so $r^{\\mathrm{cap}}_4 = 0$.\n\nThe reverse reaction, photodisintegration of isotope $i$ into isotope $i-1$ and a neutron, occurs at a rate $\\lambda^{\\gamma n}_i$. This rate is not an independent parameter but is linked to the capture rate via the principle of detailed balance, which must hold in nuclear statistical equilibrium. The provided relation is:\n$$\n\\lambda^{\\gamma n}_i = \\langle \\sigma v \\rangle \\frac{2 G_{i-1}}{G_i} n_Q \\exp\\left(-\\frac{S_n(i)}{k_B T}\\right) \\quad \\text{for } i \\ge 1\n$$\nHere, $G_i$ is the partition function of nucleus $i$ (taken as $G_i=1$), $S_n(i)$ is the neutron separation energy for nucleus $i$, and $n_Q$ is the neutron quantum concentration:\n$$\nn_Q = \\left( \\frac{m_n k_B T}{2\\pi \\hbar^2} \\right)^{3/2}\n$$\nThe factor of $2$ accounts for the spin degeneracy of the free neutron. The exponential term is the standard Boltzmann factor governing the thermodynamics of the reaction, where $k_B T$ must be in the same energy units as $S_n$ (megaelectronvolts, MeV). Photodisintegration is not possible for the lightest isotope, so $\\lambda^{\\gamma n}_0=0$.\n\nWith these rates, we can formulate the two models for the abundance vector $\\mathbf{Y}(t) = (Y_0(t), Y_1(t), Y_2(t), Y_3(t), Y_4(t))^\\top$.\n\n**1. The Full Reaction-Kinetics Model**\n\nThis model describes the time evolution of abundances via a system of coupled linear ordinary differential equations, representing the net flow into and out of each isotopic state. The system is written as $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M} \\mathbf{Y}$, where the rate matrix $\\mathbf{M}$ is constructed from the capture and photodisintegration rates. The explicit equations are:\n$$\n\\frac{dY_0}{dt} = -r^{\\mathrm{cap}}_0 Y_0 + \\lambda^{\\gamma n}_1 Y_1\n$$\n$$\n\\frac{dY_i}{dt} = r^{\\mathrm{cap}}_{i-1} Y_{i-1} - (r^{\\mathrm{cap}}_i + \\lambda^{\\gamma n}_i) Y_i + \\lambda^{\\gamma n}_{i+1} Y_{i+1} \\quad \\text{for } i \\in \\{1, 2, 3\\}\n$$\n$$\n\\frac{dY_4}{dt} = r^{\\mathrm{cap}}_3 Y_3 - \\lambda^{\\gamma n}_4 Y_4\n$$\nThis defines a $5 \\times 5$ tridiagonal matrix $\\mathbf{M}$. For a given initial abundance vector $\\mathbf{Y}(0)$, the solution at time $t_{\\mathrm{final}}$ is given by the action of the matrix exponential on the initial vector:\n$$\n\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}}) = \\exp(\\mathbf{M} t_{\\mathrm{final}}) \\mathbf{Y}(0)\n$$\nThe problem specifies the initial condition as all material being in the state $i=2$, i.e., $\\mathbf{Y}(0) = (0, 0, 1, 0, 0)^\\top$. The calculation of the matrix exponential $\\exp(\\mathbf{M} t_{\\mathrm{final}})$ is a standard numerical linear algebra task, for which we use `scipy.linalg.expm`. After evolution, the resulting vector $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$ is processed by clipping any small negative values arising from numerical error to zero and renormalizing such that $\\sum_i Y^{\\mathrm{kin}}_i = 1$.\n\n**2. The Waiting-Point Approximation (WPA)**\n\nThe WPA assumes that the reactions are so fast compared to other timescales (like beta-decay, which is not considered here) that a state of nuclear statistical equilibrium is reached and maintained within the isotopic chain. In this equilibrium, the net flow for each reaction link is zero:\n$$\nr^{\\mathrm{cap}}_{i-1} Y_{i-1} = \\lambda^{\\gamma n}_i Y_i \\quad \\text{for each } i \\in \\{1, 2, 3, 4\\}\n$$\nThis leads to a set of Saha-like equations for the ratios of adjacent abundances:\n$$\n\\frac{Y^{\\mathrm{WPA}}_i}{Y^{\\mathrm{WPA}}_{i-1}} = \\frac{r^{\\mathrm{cap}}_{i-1}}{\\lambda^{\\gamma n}_i} = \\frac{n_n \\langle \\sigma v \\rangle}{\\langle \\sigma v \\rangle \\frac{2 G_{i-1}}{G_i} n_Q \\exp\\left(-\\frac{S_n(i)}{k_B T}\\right)} = n_n n_Q^{-1} \\frac{G_i}{2 G_{i-1}} \\exp\\left(\\frac{S_n(i)}{k_B T}\\right)\n$$\nGiven $G_i=1$, this simplifies the ratio. The WPA abundance distribution $\\mathbf{Y}^{\\mathrm{WPA}}$ is constructed by setting $Y^{\\mathrm{WPA}}_0 = 1$, calculating the subsequent unnormalized abundances $Y^{\\mathrm{WPA}}_i$ using these ratios, and finally normalizing the entire vector so that $\\sum_i Y^{\\mathrm{WPA}}_i = 1$. The WPA distribution is stationary and depends only on $n_n$ and $T$, not on time or the initial state.\n\n**3. The Comparison Metric**\n\nThe quantitative difference between the time-evolved kinetic solution $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$ and the equilibrium WPA solution $\\mathbf{Y}^{\\mathrm{WPA}}$ is measured by the total variation distance, $\\Delta$:\n$$\n\\Delta = \\frac{1}{2} \\sum_{i=0}^{4} \\left| Y^{\\mathrm{kin}}_i(t_{\\mathrm{final}}) - Y^{\\mathrm{WPA}}_i \\right|\n$$\nThis metric ranges from $\\Delta=0$ for identical distributions to $\\Delta=1$ for completely disjoint distributions. A small value of $\\Delta$ indicates that the system has had sufficient time for the given conditions to relax to the equilibrium state predicted by the WPA. A large value indicates that the system is far from equilibrium at $t_{\\mathrm{final}}$.\n\nThe implementation will proceed by first defining all physical constants with the specified precision and units. For each test case $(n_n, T, t_{\\mathrm{final}})$, the code will compute the necessary rates, construct the rate matrix $\\mathbf{M}$ for the kinetic model, solve for $\\mathbf{Y}^{\\mathrm{kin}}(t_{\\mathrm{final}})$, compute the equilibrium distribution $\\mathbf{Y}^{\\mathrm{WPA}}$, and finally calculate $\\Delta$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the deviation between a kinetic reaction network solution and the\n    waiting-point approximation for an r-process isotopic chain.\n    \"\"\"\n\n    # Physical Constants\n    KB_J_K = 1.380649e-23  # Boltzmann constant in J/K\n    KB_MEV_K = 8.617333262e-11 # Boltzmann constant in MeV/K\n    HBAR_JS = 1.054571817e-34 # Reduced Planck constant in J*s\n    M_N_KG = 1.67492749804e-27 # Neutron mass in kg\n\n    # Model Parameters\n    SIGMA0_CM2 = 5e-24  # Neutron capture cross section in cm^2\n    S_N_MEV = np.array([3.5, 3.0, 2.5, 2.2, 1.8]) # Neutron separation energies in MeV\n    NUM_ISOTOPES = 5\n\n    def calculate_deviation(n_n_cm3, T_GK, t_final_s):\n        \"\"\"\n        Calculates the total variation distance for a given set of conditions.\n        \n        Args:\n            n_n_cm3 (float): Neutron number density in cm^-3.\n            T_GK (float): Temperature in Gigakelvin.\n            t_final_s (float): Final evolution time in seconds.\n\n        Returns:\n            float: The total variation distance Delta.\n        \"\"\"\n        # --- Unit Conversions and Basic Quantities ---\n        T_K = T_GK * 1e9  # Temperature in Kelvin\n        kBT_MeV = KB_MEV_K * T_K # Thermal energy in MeV\n\n        # --- Calculate Rates ---\n\n        # Thermal velocity v_th in cm/s\n        v_th_ms = np.sqrt((8 * KB_J_K * T_K) / (np.pi * M_N_KG))\n        v_th_cms = v_th_ms * 100.0\n\n        # Rate coefficient sigma v in cm^3/s\n        sigma_v_cm3_s = SIGMA0_CM2 * v_th_cms\n        \n        # Neutron capture rates r_cap in s^-1\n        r_cap = np.zeros(NUM_ISOTOPES)\n        r_cap[:-1] = n_n_cm3 * sigma_v_cm3_s\n\n        # Neutron quantum concentration n_Q in cm^-3\n        n_q_m3 = ((M_N_KG * KB_J_K * T_K) / (2 * np.pi * HBAR_JS**2))**1.5\n        n_q_cm3 = n_q_m3 * 1e-6\n        \n        # Photodisintegration rates lambda_gn in s^-1\n        lambda_gn = np.zeros(NUM_ISOTOPES)\n        # G_i = 1 for all i, so G_i-1/G_i = 1\n        # Factor 2 is for neutron spin degeneracy\n        for i in range(1, NUM_ISOTOPES):\n            # Using S_n(i) for photodisintegration from isotope i\n            lambda_gn[i] = sigma_v_cm3_s * 2.0 * n_q_cm3 * np.exp(-S_N_MEV[i] / kBT_MeV)\n\n        # --- 1. Kinetic Model Solution ---\n\n        # Construct the rate matrix M (5x5)\n        M = np.zeros((NUM_ISOTOPES, NUM_ISOTOPES))\n        \n        # Diagonal elements: -(total loss rate)\n        M.flat[::NUM_ISOTOPES+1] = -(r_cap + lambda_gn)\n        \n        # Super-diagonal elements: M[i, i+1] (flow from i+1 to i via photodisintegration)\n        for i in range(NUM_ISOTOPES - 1):\n            M[i, i+1] = lambda_gn[i+1]\n            \n        # Sub-diagonal elements: M[i, i-1] (flow from i-1 to i via capture)\n        for i in range(1, NUM_ISOTOPES):\n            M[i, i-1] = r_cap[i-1]\n\n        # Initial condition: Y(0) = [0, 0, 1, 0, 0]\n        Y0 = np.zeros(NUM_ISOTOPES)\n        Y0[2] = 1.0\n\n        # Evolve: Y(t_final) = exp(M * t_final) * Y(0)\n        M_t = M * t_final_s\n        exp_M_t = expm(M_t)\n        Y_kin = exp_M_t @ Y0\n\n        # Post-process: clip negatives and re-normalize\n        Y_kin[Y_kin  0] = 0.0\n        norm_kin = np.sum(Y_kin)\n        if norm_kin  0:\n            Y_kin /= norm_kin\n\n        # --- 2. Waiting-Point Approximation (WPA) Solution ---\n\n        Y_wpa = np.zeros(NUM_ISOTOPES)\n        Y_wpa[0] = 1.0 # Set initial reference abundance\n        \n        # Calculate ratios Y[i]/Y[i-1]\n        for i in range(1, NUM_ISOTOPES):\n            # G_i=1 implies G_i/G_i-1 = 1\n            ratio = (n_n_cm3 / n_q_cm3) * (1.0 / 2.0) * np.exp(S_N_MEV[i] / kBT_MeV)\n            Y_wpa[i] = Y_wpa[i-1] * ratio\n\n        # Normalize WPA distribution\n        norm_wpa = np.sum(Y_wpa)\n        if norm_wpa  0:\n            Y_wpa /= norm_wpa\n            \n        # --- 3. Calculate Deviation ---\n\n        delta = 0.5 * np.sum(np.abs(Y_kin - Y_wpa))\n        \n        return delta\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (n_n, T, t_final)\n        (1e25, 1.5, 1e-3),\n        # Case B\n        (1e20, 1.0, 1e-6),\n        # Case C\n        (1e24, 2.0, 5e-4),\n        # Case D\n        (1e18, 0.5, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_n, T, t_final = case\n        result = calculate_deviation(n_n, T, t_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Robust nucleosynthesis simulations must rigorously maintain physical consistency, as numerical integration schemes can introduce errors that violate fundamental laws like the conservation of baryon number and charge. This exercise focuses on implementing the essential diagnostic and correction mechanisms to ensure a simulation remains physically valid over time. You will code procedures to enforce the principle of detailed balance between forward and reverse reactions and project the evolving abundances back onto the conserved quantity manifold, which are core skills for developing any stable and accurate reaction network code .",
            "id": "3590825",
            "problem": "You are tasked with implementing diagnostic tests and automatic correction procedures for a simplified reaction network representative of rapid neutron-capture process (r-process) nucleosynthesis. The network comprises four species: free neutrons $n$ with mass number $A_n = 1$ and charge number $Z_n = 0$, free protons $p$ with $A_p = 1$ and $Z_p = 1$, a heavy seed nucleus $X$ with mass number $A$ and charge number $Z$, and its neutron-captured successor $X^+$ with mass number $A+1$ and charge number $Z$. The only reaction in the network is radiative neutron capture and its inverse photodissociation:\n$$\nX + n \\leftrightarrow X^+ + \\gamma.\n$$\nThe forward capture rate per unit volume is given by\n$$\nR_f = n_n \\, n_X \\, \\langle \\sigma v \\rangle,\n$$\nwhere $n_n$ and $n_X$ are the number densities of neutrons and $X$, respectively, and $\\langle \\sigma v \\rangle$ is the thermally averaged product of cross section and relative velocity, expressed in $\\mathrm{m^3/s}$. The reverse photodissociation rate per unit volume is given by\n$$\nR_r = \\lambda_{\\gamma n} \\, n_{X^+},\n$$\nwhere $\\lambda_{\\gamma n}$ is the photodissociation rate per $X^+$ nucleus, expressed in $\\mathrm{s^{-1}}$, and $n_{X^+}$ is the number density of $X^+$. The abundances $Y_i$ are defined per baryon, so that $n_i = Y_i \\, n_b$ for each species $i$, with $n_b = \\rho / m_u$, where $\\rho$ is the mass density in $\\mathrm{kg/m^3}$ and $m_u$ is the atomic mass unit in $\\mathrm{kg}$.\n\nThe time evolution of the abundances under this reaction is governed by\n$$\n\\frac{dY_n}{dt} = -\\frac{R_f}{n_b} + \\frac{R_r}{n_b}, \\quad\n\\frac{dY_X}{dt} = -\\frac{R_f}{n_b} + \\frac{R_r}{n_b}, \\quad\n\\frac{dY_{X^+}}{dt} = \\frac{R_f}{n_b} - \\frac{R_r}{n_b}, \\quad\n\\frac{dY_p}{dt} = 0,\n$$\nwhich follow from counting the changes in particle numbers per unit volume and dividing by $n_b$. These equations exactly conserve total baryon number and charge if evaluated with consistent rates.\n\nThe principle of detailed balance under Nuclear Statistical Equilibrium (NSE) states that the reverse rate $\\lambda_{\\gamma n}$ must be related to the forward rate and thermodynamic quantities via\n$$\n\\lambda_{\\gamma n}^{\\mathrm{db}}(T, n_n) = \\langle \\sigma v \\rangle \\, n_n \\, \\left( \\frac{2 \\pi \\hbar^2}{m_n k_B T} \\right)^{3/2} \\, \\frac{G_A}{2 G_{A+1}} \\, \\exp\\left( - \\frac{S_n}{k_B T} \\right),\n$$\nwhere $T$ is the temperature in $\\mathrm{K}$, $\\hbar$ is the reduced Planck constant in $\\mathrm{J \\cdot s}$, $m_n$ is the neutron mass in $\\mathrm{kg}$, $k_B$ is the Boltzmann constant in $\\mathrm{J/K}$, $G_A$ and $G_{A+1}$ are the nuclear partition functions of $X$ and $X^+$ (dimensionless), and $S_n$ is the neutron separation energy for $X^+$ in $\\mathrm{J}$. This formula is a well-tested statement of microreversibility for radiative neutron capture and photodissociation.\n\nYour program must implement:\n- A numerical integrator that advances the abundances $Y_n$, $Y_p$, $Y_X$, and $Y_{X^+}$ through time using an explicit Euler method with a specified timestep.\n- A diagnostic test for detailed balance violation at each step, which evaluates the relative deviation\n$$\nD = \\frac{\\left| \\lambda_{\\gamma n}^{\\mathrm{actual}} - \\lambda_{\\gamma n}^{\\mathrm{db}} \\right|}{\\max\\left( \\lambda_{\\gamma n}^{\\mathrm{db}}, \\varepsilon \\right)},\n$$\nwith a prescribed threshold $\\tau$ and a very small positive $\\varepsilon$ to avoid division by zero (use $\\varepsilon = 10^{-300}$). If $D  \\tau$, a violation is counted and your correction procedure must set $\\lambda_{\\gamma n}^{\\mathrm{used}} = \\lambda_{\\gamma n}^{\\mathrm{db}}$ for the step. Otherwise, use $\\lambda_{\\gamma n}^{\\mathrm{used}} = \\lambda_{\\gamma n}^{\\mathrm{actual}}$.\n- A diagnostic test for conservation of baryon number and charge after each integration step. The invariants to be maintained are\n$$\n\\sum_i A_i Y_i = 1, \\quad \\sum_i Z_i Y_i = Y_e,\n$$\nwhere $Y_e$ is the electron fraction. Because explicit integration and numerical roundoff can introduce small violations, design and implement an automatic correction that projects the abundance vector $\\mathbf{Y}$ back onto the constraint manifold defined by these two linear equalities while minimally perturbing $\\mathbf{Y}$ in the least-squares sense. Use the following procedure:\n  1. Form the residuals\n  $$\n  \\Delta_B = 1 - \\sum_i A_i Y_i, \\quad \\Delta_Q = Y_e - \\sum_i Z_i Y_i.\n  $$\n  2. Compute the correction of the form $\\delta Y_i = \\alpha A_i + \\beta Z_i$ by solving\n  $$\n  \\begin{bmatrix}\n  \\sum_i A_i^2  \\sum_i A_i Z_i \\\\\n  \\sum_i A_i Z_i  \\sum_i Z_i^2\n  \\end{bmatrix}\n  \\begin{bmatrix}\n  \\alpha \\\\ \\beta\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  \\Delta_B \\\\ \\Delta_Q\n  \\end{bmatrix}.\n  $$\n  3. Update $Y_i \\leftarrow Y_i + \\delta Y_i$ for all species $i$.\n  4. Enforce non-negativity by setting any $Y_i  0$ to $0$, then recompute the residuals and reproject using the same method for up to $2$ additional iterations.\nThis correction guarantees that, in the limit of small residuals, the constraint violations are reduced to machine precision while favoring minimal changes.\n\nYour code must:\n- Use the atomic mass unit $m_u$ as $1.660\\,539\\,066\\,60 \\times 10^{-27} \\, \\mathrm{kg}$, the neutron mass $m_n$ as $1.674\\,927\\,498\\,04 \\times 10^{-27} \\, \\mathrm{kg}$, the Boltzmann constant $k_B$ as $1.380\\,649 \\times 10^{-23} \\, \\mathrm{J/K}$, and the reduced Planck constant $\\hbar$ as $1.054\\,571\\,817 \\times 10^{-34} \\, \\mathrm{J \\cdot s}$.\n- Interpret all quantities in the following units: temperature in $\\mathrm{K}$, density in $\\mathrm{kg/m^3}$, separation energy in $\\mathrm{J}$, reaction rate prefactor $\\langle \\sigma v \\rangle$ in $\\mathrm{m^3/s}$, time in $\\mathrm{s}$, and abundances $Y_i$ dimensionless per baryon.\n- Start with provided initial abundances and parameters for each test case and integrate for the given number of steps and step size.\n\nTest suite:\nImplement the algorithm for the following four test cases. For each case, compute the initial detailed balance rate $\\lambda_{\\gamma n}^{\\mathrm{db}}(t=0)$ and set the actual rate as $\\lambda_{\\gamma n}^{\\mathrm{actual}} = f \\, \\lambda_{\\gamma n}^{\\mathrm{db}}(t=0)$ with a given factor $f$, which remains constant during integration unless corrected by the detailed balance procedure. The partition functions are dimensionless.\n\n- Case $1$ (happy path):\n  - $A = 80$, $Z = 30$, $T = 1.0 \\times 10^{9} \\, \\mathrm{K}$, $\\rho = 1.0 \\times 10^{3} \\, \\mathrm{kg/m^3}$, $Y_e = 0.25$,\n  - $Y_n(0) = 0.347$, $Y_p(0) = 0.01$, $Y_X(0) = 0.005$, $Y_{X^+}(0) = 0.003$,\n  - $\\langle \\sigma v \\rangle = 1.0 \\times 10^{-30} \\, \\mathrm{m^3/s}$, $S_n = 3.20436 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $2.0 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 1.2$,\n  - Steps $= 1000$, $\\Delta t = 1.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\n- Case $2$ (large detailed balance violation):\n  - $A = 130$, $Z = 50$, $T = 1.5 \\times 10^{9} \\, \\mathrm{K}$, $\\rho = 5.0 \\times 10^{2} \\, \\mathrm{kg/m^3}$, $Y_e = 0.10$,\n  - $Y_n(0) = 0.7795$, $Y_p(0) = 0.025$, $Y_X(0) = 0.001$, $Y_{X^+}(0) = 0.0005$,\n  - $\\langle \\sigma v \\rangle = 5.0 \\times 10^{-31} \\, \\mathrm{m^3/s}$, $S_n = 2.40327 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $1.5 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 5.0$,\n  - Steps $= 800$, $\\Delta t = 2.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\n- Case $3$ (edge case with exact detailed balance at $t=0$):\n  - $A = 60$, $Z = 25$, $T = 5.0 \\times 10^{8} \\, \\mathrm{K}$, $\\rho = 5.0 \\times 10^{1} \\, \\mathrm{kg/m^3}$, $Y_e = 0.35$,\n  - $Y_n(0) = 0.544$, $Y_p(0) = 0.275$, $Y_X(0) = 0.002$, $Y_{X^+}(0) = 0.001$,\n  - $\\langle \\sigma v \\rangle = 1.0 \\times 10^{-31} \\, \\mathrm{m^3/s}$, $S_n = 4.80654 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $3.0 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 1.0$,\n  - Steps $= 1200$, $\\Delta t = 1.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\n- Case $4$ (negative abundance initialization to test correction robustness):\n  - $A = 90$, $Z = 35$, $T = 8.0 \\times 10^{8} \\, \\mathrm{K}$, $\\rho = 8.0 \\times 10^{2} \\, \\mathrm{kg/m^3}$, $Y_e = 0.20$,\n  - $Y_n(0) = 0.580056$, $Y_p(0) = 0.060035$, $Y_X(0) = 0.004$, $Y_{X^+}(0) = -1.0 \\times 10^{-6}$,\n  - $\\langle \\sigma v \\rangle = 2.0 \\times 10^{-31} \\, \\mathrm{m^3/s}$, $S_n = 3.52496 \\times 10^{-13} \\, \\mathrm{J}$ (corresponding to $2.2 \\, \\mathrm{MeV}$),\n  - $G_A = 1.0$, $G_{A+1} = 1.0$, $f = 0.5$,\n  - Steps $= 900$, $\\Delta t = 1.0 \\times 10^{-2} \\, \\mathrm{s}$, threshold $\\tau = 0.05$.\n\nFor each test case, your program must compute and return the following outputs after completing the integration:\n- The integer count of steps where the detailed balance violation metric $D$ exceeded the threshold $\\tau$ and therefore triggered correction.\n- The final absolute baryon conservation error $\\left| \\sum_i A_i Y_i - 1 \\right|$ as a floating-point number, in dimensionless abundance units.\n- The final absolute charge conservation error $\\left| \\sum_i Z_i Y_i - Y_e \\right|$ as a floating-point number, in dimensionless abundance units.\n- The maximum relative detailed balance deviation after correction across all steps, defined as $\\max \\left( \\frac{ \\left| \\lambda_{\\gamma n}^{\\mathrm{used}} - \\lambda_{\\gamma n}^{\\mathrm{db}} \\right| }{ \\max\\left( \\lambda_{\\gamma n}^{\\mathrm{db}}, \\varepsilon \\right) } \\right)$, as a floating-point number, in dimensionless units.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the four cases as a comma-separated list of lists enclosed in square brackets, for example `[[c_1,b_1,q_1,m_1],[c_2,b_2,q_2,m_2],[c_3,b_3,q_3,m_3],[c_4,b_4,q_4,m_4]]`, where each $c_i$ is an integer and each $b_i$, $q_i$, and $m_i$ are floating-point numbers.",
            "solution": "The user has provided a valid problem statement. The problem is scientifically grounded in the principles of nuclear reaction network theory, mathematically well-posed, and provides a complete and unambiguous specification of the task. The task is to implement a numerical simulation of a simplified r-process network, including diagnostic tests and correction procedures for ensuring physical consistency. The provided initial conditions and parameters are sufficient and consistent for a numerical solution. We will proceed to develop the solution as specified.\n\nThe core of the problem is to simulate the time evolution of a system of four chemical species—neutrons ($n$), protons ($p$), a heavy seed nucleus ($X$), and its neutron-capture product ($X^+$)—undergoing the reaction $X + n \\leftrightarrow X^+ + \\gamma$. The abundances of these species, denoted by $Y_i$ (fraction of total baryons), evolve according to a set of ordinary differential equations (ODEs). The simulation must be performed using an explicit Euler method, while incorporating two critical numerical procedures: one to enforce detailed balance and another to maintain the conservation of baryon number and charge.\n\nFirst, we define the state of the system by the abundance vector $\\mathbf{Y} = [Y_n, Y_p, Y_X, Y_{X^+}]^T$. The mass and charge numbers for the species are given by the vectors $\\mathbf{A} = [A_n, A_p, A_X, A_{X^+}]^T = [1, 1, A, A+1]^T$ and $\\mathbf{Z} = [Z_n, Z_p, Z_X, Z_{X^+}]^T = [0, 1, Z, Z]^T$, respectively.\n\nThe time evolution of the abundances is governed by the net reaction flow. The forward rate per unit volume (neutron capture) is $R_f = n_n \\, n_X \\, \\langle \\sigma v \\rangle$, and the reverse rate per unit volume (photodissociation) is $R_r = \\lambda_{\\gamma n} \\, n_{X^+}$. Expressing number densities $n_i$ in terms of abundances $Y_i$ via $n_i = Y_i \\, n_b$, where $n_b = \\rho/m_u$ is the total baryon number density, the rate equations become:\n$$\n\\frac{dY_n}{dt} = \\frac{dY_X}{dt} = -\\frac{R_f}{n_b} + \\frac{R_r}{n_b} = - \\Phi\n$$\n$$\n\\frac{dY_{X^+}}{dt} = \\frac{R_f}{n_b} - \\frac{R_r}{n_b} = \\Phi\n$$\n$$\n\\frac{dY_p}{dt} = 0\n$$\nwhere the net reaction flow per baryon, $\\Phi$, is given by:\n$$\n\\Phi = \\frac{R_f - R_r}{n_b} = \\langle \\sigma v \\rangle \\frac{\\rho}{m_u} Y_n Y_X - \\lambda_{\\gamma n} Y_{X^+}\n$$\nThe system of ODEs is integrated numerically using the explicit Euler method:\n$$\n\\mathbf{Y}(t + \\Delta t) = \\mathbf{Y}(t) + \\Delta t \\frac{d\\mathbf{Y}}{dt}\\bigg|_t\n$$\n\nA critical aspect of physical consistency is adherence to the principle of detailed balance, which connects the forward and reverse rates at thermodynamic equilibrium. The photodissociation rate $\\lambda_{\\gamma n}$ that satisfies this principle is given by:\n$$\n\\lambda_{\\gamma n}^{\\mathrm{db}}(T, n_n) = \\langle \\sigma v \\rangle \\, n_n \\, \\left( \\frac{2 \\pi \\hbar^2}{m_n k_B T} \\right)^{3/2} \\, \\frac{G_A}{2 G_{A+1}} \\, \\exp\\left( - \\frac{S_n}{k_B T} \\right)\n$$\nwhere $n_n = Y_n \\rho / m_u$, and all other quantities are provided physical parameters. In a numerical simulation, the provided \"actual\" rate $\\lambda_{\\gamma n}^{\\mathrm{actual}}$ may violate this principle. A diagnostic test measures the relative deviation:\n$$\nD = \\frac{\\left| \\lambda_{\\gamma n}^{\\mathrm{actual}} - \\lambda_{\\gamma n}^{\\mathrm{db}} \\right|}{\\max\\left( \\lambda_{\\gamma n}^{\\mathrm{db}}, \\varepsilon \\right)}\n$$\nIf $D$ exceeds a threshold $\\tau$, the rate used in the calculation for that step, $\\lambda_{\\gamma n}^{\\mathrm{used}}$, must be set to $\\lambda_{\\gamma n}^{\\mathrm{db}}$ to restore physical consistency. Otherwise, $\\lambda_{\\gamma n}^{\\mathrm{used}} = \\lambda_{\\gamma n}^{\\mathrm{actual}}$. The count of these correction events is one of the required outputs.\n\nThe second crucial procedure is the enforcement of conservation laws. The total baryon number and charge per baryon must be conserved throughout the simulation. These are expressed as two linear constraints on the abundance vector:\n$$\n\\sum_i A_i Y_i = 1 \\quad \\text{(Baryon number conservation)}\n$$\n$$\n\\sum_i Z_i Y_i = Y_e \\quad \\text{(Charge conservation)}\n$$\nNumerical methods, particularly explicit schemes, do not automatically preserve such invariants, leading to gradual or catastrophic drift. To counteract this, a projection method is applied after each integration step. Given an updated abundance vector $\\mathbf{Y}'$ that violates the constraints, we seek a minimal correction $\\delta \\mathbf{Y}$ such that $\\mathbf{Y}'' = \\mathbf{Y}' + \\delta \\mathbf{Y}$ satisfies them. The problem specifies the correction form $\\delta Y_i = \\alpha A_i + \\beta Z_i$, which constitutes a projection onto the subspace spanned by the constraint vectors $\\mathbf{A}$ and $\\mathbf{Z}$. The unknown coefficients $\\alpha$ and $\\beta$ are found by solving the linear system derived from substituting $\\delta \\mathbf{Y}$ into the constraint equations:\n$$\n\\sum_i A_i (Y'_i + \\alpha A_i + \\beta Z_i) = 1 \\implies \\alpha \\sum_i A_i^2 + \\beta \\sum_i A_i Z_i = 1 - \\sum_i A_i Y'_i = \\Delta_B\n$$\n$$\n\\sum_i Z_i (Y'_i + \\alpha A_i + \\beta Z_i) = Y_e \\implies \\alpha \\sum_i A_i Z_i + \\beta \\sum_i Z_i^2 = Y_e - \\sum_i Z_i Y'_i = \\Delta_Q\n$$\nThis yields the matrix equation:\n$$\n\\begin{bmatrix}\n\\sum_i A_i^2  \\sum_i A_i Z_i \\\\\n\\sum_i A_i Z_i  \\sum_i Z_i^2\n\\end{bmatrix}\n\\begin{bmatrix}\n\\alpha \\\\ \\beta\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\Delta_B \\\\ \\Delta_Q\n\\end{bmatrix}\n$$\nSolving this $2 \\times 2$ system for $\\alpha$ and $\\beta$ provides the correction $\\delta Y_i$. After updating the abundances, non-negativity ($Y_i \\geq 0$) is enforced. The problem requires this correction process (residual calculation, solving for correction, updating, enforcing non-negativity) to be repeated up to three times to handle potentially large initial errors or negative abundances produced by the correction itself. This entire correction procedure is applied to the initial state to ensure it is valid before integration begins, and after each subsequent timestep.\n\nThe overall algorithm for each test case is as follows:\n1.  Initialize physical constants, parameters, and the initial abundance vector $\\mathbf{Y}$.\n2.  Apply the iterative conservation correction to the initial $\\mathbf{Y}$ to ensure it satisfies constraints and non-negativity.\n3.  Calculate the initial detailed balance rate $\\lambda_{\\gamma n}^{\\mathrm{db}}(t=0)$ and set the constant `actual` rate $\\lambda_{\\gamma n}^{\\mathrm{actual}} = f \\cdot \\lambda_{\\gamma n}^{\\mathrm{db}}(t=0)$.\n4.  Begin the time-stepping loop for the specified number of steps:\n    a. Calculate the current $\\lambda_{\\gamma n}^{\\mathrm{db}}$ using the current state.\n    b. Evaluate the deviation $D$ and determine $\\lambda_{\\gamma n}^{\\mathrm{used}}$ based on the threshold $\\tau$. Record any correction event and the post-correction deviation.\n    c. Compute the reaction flow $\\Phi$ using $\\lambda_{\\gamma n}^{\\mathrm{used}}$.\n    d. Calculate the abundance derivatives $d\\mathbf{Y}/dt$.\n    e. Perform one explicit Euler step: $\\mathbf{Y} \\leftarrow \\mathbf{Y} + \\Delta t \\cdot d\\mathbf{Y}/dt$.\n    f. Apply the iterative conservation correction procedure to the new $\\mathbf{Y}$.\n5.  After the loop finishes, compute the final absolute errors in baryon and charge conservation and report them along with the total count of detailed balance corrections and the maximum post-correction detailed balance deviation observed during the simulation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Physical Constants\n    M_U = 1.66053906660e-27  # kg\n    M_N = 1.67492749804e-27  # kg\n    K_B = 1.380649e-23        # J/K\n    H_BAR = 1.054571817e-34   # J s\n    EPSILON = 1e-300          # Small number to avoid division by zero\n\n    constants = {'m_u': M_U, 'm_n': M_N, 'k_B': K_B, 'hbar': H_BAR, 'epsilon': EPSILON}\n\n    # Test Cases\n    test_cases = [\n        # Case 1\n        {'A': 80, 'Z': 30, 'T': 1.0e9, 'rho': 1.0e3, 'Ye': 0.25,\n         'Y0': [0.347, 0.01, 0.005, 0.003],\n         'sv': 1.0e-30, 'Sn': 3.20436e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 1.2,\n         'steps': 1000, 'dt': 1.0e-2, 'tau': 0.05},\n        # Case 2\n        {'A': 130, 'Z': 50, 'T': 1.5e9, 'rho': 5.0e2, 'Ye': 0.10,\n         'Y0': [0.7795, 0.025, 0.001, 0.0005],\n         'sv': 5.0e-31, 'Sn': 2.40327e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 5.0,\n         'steps': 800, 'dt': 2.0e-2, 'tau': 0.05},\n        # Case 3\n        {'A': 60, 'Z': 25, 'T': 5.0e8, 'rho': 5.0e1, 'Ye': 0.35,\n         'Y0': [0.544, 0.275, 0.002, 0.001],\n         'sv': 1.0e-31, 'Sn': 4.80654e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 1.0,\n         'steps': 1200, 'dt': 1.0e-2, 'tau': 0.05},\n        # Case 4\n        {'A': 90, 'Z': 35, 'T': 8.0e8, 'rho': 8.0e2, 'Ye': 0.20,\n         'Y0': [0.580056, 0.060035, 0.004, -1.0e-6],\n         'sv': 2.0e-31, 'Sn': 3.52496e-13, 'GA': 1.0, 'GA_plus_1': 1.0, 'f': 0.5,\n         'steps': 900, 'dt': 1.0e-2, 'tau': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case, constants)\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(params, consts):\n    \"\"\"\n    Runs a single simulation case.\n    \"\"\"\n    A_val, Z_val = params['A'], params['Z']\n    T, rho, Ye = params['T'], params['rho'], params['Ye']\n    sv, Sn = params['sv'], params['Sn']\n    GA, GA_plus_1 = params['GA'], params['GA_plus_1']\n    f, steps, dt, tau = params['f'], params['steps'], params['dt'], params['tau']\n\n    m_u, m_n = consts['m_u'], consts['m_n']\n    k_B, hbar = consts['k_B'], consts['hbar']\n    epsilon = consts['epsilon']\n\n    # Species vectors: n, p, X, X+\n    A_vec = np.array([1.0, 1.0, A_val, A_val + 1.0])\n    Z_vec = np.array([0.0, 1.0, Z_val, Z_val])\n\n    # Initial abundances\n    Y = np.array(params['Y0'], dtype=np.float64)\n\n    # Pre-simulation state correction\n    Y = correct_conservation(Y, A_vec, Z_vec, Ye)\n\n    n_b = rho / m_u\n\n    # Calculate initial detailed balance rate to set lambda_actual\n    lambda_db_initial = calculate_lambda_db(Y[0], T, rho, sv, Sn, GA, GA_plus_1, m_u, m_n, k_B, hbar)\n    lambda_actual = f * lambda_db_initial\n\n    db_violations = 0\n    max_db_dev = 0.0\n\n    # Main integration loop\n    for _ in range(steps):\n        # 1. Detailed Balance Diagnostic and Correction\n        n_n = Y[0] * n_b\n        lambda_db_current = calculate_lambda_db(Y[0], T, rho, sv, Sn, GA, GA_plus_1, m_u, m_n, k_B, hbar)\n\n        deviation = abs(lambda_actual - lambda_db_current) / max(lambda_db_current, epsilon)\n\n        if deviation  tau:\n            db_violations += 1\n            lambda_used = lambda_db_current\n        else:\n            lambda_used = lambda_actual\n\n        # Track max deviation after correction\n        dev_after_corr = abs(lambda_used - lambda_db_current) / max(lambda_db_current, epsilon)\n        max_db_dev = max(max_db_dev, dev_after_corr)\n\n        # 2. Calculate derivatives\n        R_f = n_n * (Y[2] * n_b) * sv\n        R_r = lambda_used * (Y[3] * n_b)\n        Phi = (R_f - R_r) / n_b\n\n        dY_dt = np.array([-Phi, 0.0, -Phi, Phi])\n\n        # 3. Euler Step\n        Y = Y + dt * dY_dt\n\n        # 4. Conservation Correction\n        Y = correct_conservation(Y, A_vec, Z_vec, Ye)\n\n    # Final metrics\n    baryon_error = abs(1.0 - np.sum(A_vec * Y))\n    charge_error = abs(Ye - np.sum(Z_vec * Y))\n\n    return [db_violations, baryon_error, charge_error, max_db_dev]\n\ndef calculate_lambda_db(Yn, T, rho, sv, Sn, GA, GA_plus_1, m_u, m_n, k_B, hbar):\n    \"\"\"\n    Calculates the photodissociation rate consistent with detailed balance.\n    \"\"\"\n    if Yn = 0.0:\n        return 0.0\n    n_n = Yn * rho / m_u\n    \n    # Pre-compute parts of the formula for clarity\n    thermal_term = (2.0 * np.pi * hbar**2) / (m_n * k_B * T)\n    partition_ratio = GA / (2.0 * GA_plus_1)\n    boltzmann_factor = np.exp(-Sn / (k_B * T))\n\n    lambda_db = sv * n_n * (thermal_term**1.5) * partition_ratio * boltzmann_factor\n    return lambda_db\n\ndef correct_conservation(Y, A_vec, Z_vec, Ye):\n    \"\"\"\n    Applies an iterative projection method to enforce baryon and charge conservation.\n    \"\"\"\n    Y_corrected = np.copy(Y)\n    \n    # Matrix M = C * C^T\n    M = np.array([\n        [np.sum(A_vec**2), np.sum(A_vec * Z_vec)],\n        [np.sum(A_vec * Z_vec), np.sum(Z_vec**2)]\n    ])\n    \n    # Iterative correction\n    for _ in range(3):\n        # Compute residuals\n        delta_B = 1.0 - np.sum(A_vec * Y_corrected)\n        delta_Q = Ye - np.sum(Z_vec * Y_corrected)\n\n        # Early exit if conserved\n        if abs(delta_B)  1e-15 and abs(delta_Q)  1e-15:\n            break\n            \n        # Solve for Lagrange multipliers alpha, beta\n        residuals = np.array([delta_B, delta_Q])\n        try:\n            alpha_beta = np.linalg.solve(M, residuals)\n        except np.linalg.LinAlgError:\n            # This should not happen if A_vec and Z_vec are linearly independent.\n            alpha_beta = np.zeros(2)\n\n        # Apply correction\n        delta_Y = alpha_beta[0] * A_vec + alpha_beta[1] * Z_vec\n        Y_corrected += delta_Y\n\n        # Enforce non-negativity\n        Y_corrected[Y_corrected  0] = 0.0\n\n    return Y_corrected\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Realistic r-process simulations can involve thousands of isotopes, making the size of the reaction network a significant computational bottleneck. A common and practical optimization strategy is to prune the network by removing isotopes that have a negligible impact on the overall abundance flow. This practice guides you through the process of quantifying the error introduced by such a truncation, using a physically motivated \"throughput\" metric to identify and remove unimportant species, thereby equipping you with a technique to balance computational cost and simulation accuracy .",
            "id": "3590823",
            "problem": "You will implement a self-contained computational experiment to quantify the robustness of rapid neutron capture process (r-process) nucleosynthesis simulations to reaction network truncation by pruning low-flux isotopes. Your task is to derive, implement, and evaluate an error metric defined as the one-norm difference between final abundance distributions of a full network and a pruned network, as a function of a pruning threshold. The experiment must be entirely contained within a single program, produce numerical answers without external input, and print the results in the specified format.\n\nStart from the foundational definition of a nuclear reaction network as a system of coupled ordinary differential equations for species abundances. Let $Y_i(t)$ denote the abundance per baryon of isotope $i$ at time $t$, so that $Y_i(t) \\ge 0$ and $\\sum_i Y_i(t) = 1$ in a mass-conserving closed network. In a reaction network under constant thermodynamic conditions and one-body reactions with constant effective rates, the evolution can be written as a linear system\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M}\\,\\mathbf{Y},\n$$\nwhere $\\mathbf{Y}$ is the abundance vector and $\\mathbf{M}$ is a constant matrix assembled from reaction rates and stoichiometry. For this problem, consider a minimal, physically plausible r-process-inspired network under constant neutron density and temperature conditions, restricted to single-neutron captures and beta decays along a short chain. The tracked species are $7$ isotopes:\n- $i=0$: $S80$ (a stable seed with mass number $A=80$),\n- $i=1$: $U81$ (unstable, captures and beta decays),\n- $i=2$: $U82$ (unstable, captures and beta decays),\n- $i=3$: $U83$ (unstable, beta decays only),\n- $i=4$: $D81$ (stable beta-decay daughter of $U81$),\n- $i=5$: $D82$ (stable beta-decay daughter of $U82$),\n- $i=6$: $D83$ (stable beta-decay daughter of $U83$).\n\nAssume the following reaction channels with constant effective rates (in $\\mathrm{s}^{-1}$):\n- Neutron captures: $S80 \\xrightarrow{\\lambda_0} U81$, $U81 \\xrightarrow{\\lambda_1} U82$, $U82 \\xrightarrow{\\lambda_2} U83$.\n- Beta decays: $U81 \\xrightarrow{\\beta_1} D81$, $U82 \\xrightarrow{\\beta_2} D82$, $U83 \\xrightarrow{\\beta_3} D83$.\nThere is no further capture from $U83$, so the set is closed by decay of $U83$.\n\nFrom stoichiometry and the definition of one-body reaction flows, the ordinary differential equations are:\n$$\n\\begin{aligned}\n\\frac{dY_{S80}}{dt} = -\\lambda_0\\,Y_{S80},\\\\\n\\frac{dY_{U81}}{dt} = +\\lambda_0\\,Y_{S80} - (\\lambda_1+\\beta_1)\\,Y_{U81},\\\\\n\\frac{dY_{U82}}{dt} = +\\lambda_1\\,Y_{U81} - (\\lambda_2+\\beta_2)\\,Y_{U82},\\\\\n\\frac{dY_{U83}}{dt} = +\\lambda_2\\,Y_{U82} - \\beta_3\\,Y_{U83},\\\\\n\\frac{dY_{D81}}{dt} = +\\beta_1\\,Y_{U81},\\\\\n\\frac{dY_{D82}}{dt} = +\\beta_2\\,Y_{U82},\\\\\n\\frac{dY_{D83}}{dt} = +\\beta_3\\,Y_{U83}.\n\\end{aligned}\n$$\n\nUse the following fixed numerical values:\n- Initial condition at $t=0$: $Y_{S80}(0)=1$, $Y_{U81}(0)=0$, $Y_{U82}(0)=0$, $Y_{U83}(0)=0$, $Y_{D81}(0)=0$, $Y_{D82}(0)=0$, $Y_{D83}(0)=0$.\n- Effective capture and decay rates: $\\lambda_0=2.0$, $\\lambda_1=1.0$, $\\lambda_2=0.5$, $\\beta_1=0.2$, $\\beta_2=0.1$, $\\beta_3=0.05$ (all in $\\mathrm{s}^{-1}$).\n- Integrate from $t=0$ to $t_{\\text{end}}=10.0$ seconds.\n\nDefine the time-integrated absolute through-throughput for each isotope $i$ as\n$$\nF_i = \\int_{0}^{t_{\\text{end}}} \\left|\\frac{dY_i}{dt}\\right|\\,dt,\n$$\nwhich is a dimensionless measure of total abundance turnover experienced by isotope $i$ over the trajectory. For a given pruning threshold $\\theta \\in [0,1]$, define the kept set of isotopes as those with $F_i \\ge \\theta \\,\\max_j F_j$. The pruned network is obtained by removing all isotopes not in the kept set and dropping any reaction terms that would produce removed isotopes; consumption terms for kept isotopes that flow into removed isotopes remain, which makes the pruned network non-conservative and intentionally models the truncation error. Let the full-network final abundances at $t_{\\text{end}}$ be $\\mathbf{X}_{\\text{full}} = \\mathbf{Y}(t_{\\text{end}})$ and the pruned-network final abundances be $\\mathbf{X}_{\\text{pruned}}$ on the reduced state. For comparison, embed $\\mathbf{X}_{\\text{pruned}}$ into the full space by placing zeros in the removed components, yielding a full-length vector $\\tilde{\\mathbf{X}}_{\\text{pruned}}$. The error metric is\n$$\n\\epsilon(\\theta) = \\left\\|\\mathbf{X}_{\\text{full}} - \\tilde{\\mathbf{X}}_{\\text{pruned}}\\right\\|_1 = \\sum_{i} \\left|X_{\\text{full},i} - \\tilde{X}_{\\text{pruned},i}\\right|.\n$$\n\nImplement a program that:\n- Integrates the full network to obtain $\\mathbf{Y}(t)$ and $\\mathbf{X}_{\\text{full}}$.\n- Computes $F_i$ by numerical quadrature of $\\left|\\frac{dY_i}{dt}\\right|$ over $[0,t_{\\text{end}}]$ using a sufficiently resolved time grid.\n- For each pruning threshold $\\theta$, constructs and integrates the pruned network as defined above to obtain $\\tilde{\\mathbf{X}}_{\\text{pruned}}$, and computes $\\epsilon(\\theta)$.\n\nAll final reported errors are dimensionless. The numerical integration must use seconds for time. Your program must evaluate the following pruning thresholds as the test suite:\n- $\\theta$ in the set $\\{0.0, 0.05, 0.2, 0.5, 0.9, 1.0\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the errors in the same order as the thresholds and each value rounded to exactly six digits after the decimal point, for example `[0.000000,0.001234,0.056789,...]`.",
            "solution": "The user has provided a valid, well-posed problem in computational nuclear physics. The task is to implement a numerical experiment to study the error introduced by truncating a simplified r-process reaction network. The solution will be derived and implemented following a principled, step-by-step approach.\n\nThe core of the problem is a system of first-order linear ordinary differential equations (ODEs) with constant coefficients, which describes the time evolution of isotopic abundances. This system is expressed as $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M}\\mathbf{Y}$, where $\\mathbf{Y}(t)$ is the vector of abundances and $\\mathbf{M}$ is the constant reaction rate matrix.\n\nThe species involved are indexed as follows for mathematical representation:\n$0$: $S80$, $1$: $U81$, $2$: $U82$, $3$: $U83$, $4$: $D81$, $5$: $D82$, $6$: $D83$.\nThe abundance vector is a $7$-element column vector, $\\mathbf{Y}(t) = [Y_0(t), Y_1(t), \\dots, Y_6(t)]^T$.\n\nThe provided system of $7$ coupled ODEs defines the entries of the $7 \\times 7$ matrix $\\mathbf{M}$. Given the reaction channels and their rates ($\\lambda_0=2.0$, $\\lambda_1=1.0$, $\\lambda_2=0.5$, $\\beta_1=0.2$, $\\beta_2=0.1$, $\\beta_3=0.05$, all in units of $\\mathrm{s}^{-1}$), the matrix $\\mathbf{M}$ is constructed as:\n$$\n\\mathbf{M} =\n\\begin{pmatrix}\n-\\lambda_0  0  0  0  0  0  0 \\\\\n\\lambda_0  -(\\lambda_1+\\beta_1)  0  0  0  0  0 \\\\\n0  \\lambda_1  -(\\lambda_2+\\beta_2)  0  0  0  0 \\\\\n0  0  \\lambda_2  -\\beta_3  0  0  0 \\\\\n0  \\beta_1  0  0  0  0  0 \\\\\n0  0  \\beta_2  0  0  0  0 \\\\\n0  0  0  \\beta_3  0  0  0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-2.0  0  0  0  0  0  0 \\\\\n2.0   -1.2  0  0  0  0  0 \\\\\n0     1.0   -0.6  0  0  0  0 \\\\\n0     0     0.5   -0.05  0  0  0 \\\\\n0     0.2   0  0  0  0  0 \\\\\n0     0     0.1   0  0  0  0 \\\\\n0     0     0     0.05  0  0  0\n\\end{pmatrix}\n$$\n\nThe computational procedure to solve the problem is structured into four main parts:\n\n1.  **Full Network Simulation:**\n    The full ODE system $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{M}\\mathbf{Y}$ is solved numerically over the time interval $[0, t_{\\text{end}}]$, where $t_{\\text{end}} = 10.0\\,\\mathrm{s}$. The initial condition is $\\mathbf{Y}(0) = [1, 0, 0, 0, 0, 0, 0]^T$, representing a pure seed of $S80$. A robust numerical ODE solver, specifically `scipy.integrate.solve_ivp`, is employed. The solution is evaluated on a fine time grid (e.g., $1001$ points) to facilitate accurate numerical integration in the next step. The final abundance vector from this simulation, $\\mathbf{X}_{\\text{full}} = \\mathbf{Y}(t_{\\text{end}})$, serves as the ground truth.\n\n2.  **Throughput Calculation:**\n    The pruning criterion is based on the time-integrated absolute through-throughput for each isotope, defined as $F_i = \\int_{0}^{t_{\\text{end}}} \\left|\\frac{dY_i}{dt}\\right|\\,dt$. To compute this, we first calculate the derivative $\\frac{d\\mathbf{Y}}{dt}(t_k) = \\mathbf{M}\\mathbf{Y}(t_k)$ at each time point $t_k$ from the solved full-network trajectory. The integral for each $F_i$ is then numerically approximated using the trapezoidal rule (`scipy.integrate.trapezoid`) on the dense time grid. Finally, the maximum throughput, $F_{\\max} = \\max_i F_i$, is determined, which serves as the reference for pruning.\n\n3.  **Pruned Network Analysis:**\n    This procedure is iterated for each specified pruning threshold $\\theta \\in \\{0.0, 0.05, 0.2, 0.5, 0.9, 1.0\\}$. For each $\\theta$, the set of isotopes to be kept is determined by the condition $F_i \\ge \\theta F_{\\max}$. Let the set of indices for these kept isotopes be $I_{\\text{kept}}$. A new, smaller ODE system is constructed for the pruned network. The state vector for this system, $\\mathbf{Y}_{\\text{pruned}}$, includes only the abundances of the kept isotopes. The corresponding rate matrix, $\\mathbf{M}_{\\text{pruned}}$, is the submatrix of $\\mathbf{M}$ containing only the rows and columns indexed by $I_{\\text{kept}}$. This correctly implements the rule that consumption terms for kept isotopes remain, even if they flow to pruned isotopes. The initial condition for the pruned system is the subvector of $\\mathbf{Y}(0)$ corresponding to the kept indices. This pruned system, $\\frac{d\\mathbf{Y}_{\\text{pruned}}}{dt} = \\mathbf{M}_{\\text{pruned}}\\mathbf{Y}_{\\text{pruned}}$, is solved to find its final state, $\\mathbf{X}_{\\text{pruned}} = \\mathbf{Y}_{\\text{pruned}}(t_{\\text{end}})$.\n\n4.  **Error Calculation:**\n    The final abundance vector from the pruned simulation, $\\mathbf{X}_{\\text{pruned}}$, which exists in a reduced-dimension space, is embedded back into the full $7$-dimensional space to form $\\tilde{\\mathbf{X}}_{\\text{pruned}}$. This is achieved by placing the computed abundances at their original indices and filling the positions of the pruned isotopes with zeros. The error, $\\epsilon(\\theta)$, is then computed as the one-norm of the difference between the full and pruned final abundance vectors:\n    $$\n    \\epsilon(\\theta) = \\left\\|\\mathbf{X}_{\\text{full}} - \\tilde{\\mathbf{X}}_{\\text{pruned}}\\right\\|_1 = \\sum_{i=0}^{6} \\left|X_{\\text{full},i} - \\tilde{X}_{\\text{pruned},i}\\right|\n    $$\nThis error quantification is performed for each $\\theta$, and the resulting values are collected for the final output. As a fundamental check, for $\\theta=0.0$, all active isotopes should be kept, making the \"pruned\" network identical to the full one, resulting in an error $\\epsilon(0.0) = 0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, trapezoid\n\ndef solve():\n    \"\"\"\n    Implements a computational experiment to quantify the robustness of r-process\n    simulations to reaction network truncation.\n    \"\"\"\n    # Define problem constants as specified in the problem statement.\n    L0, L1, L2 = 2.0, 1.0, 0.5  # Neutron capture rates in s^-1\n    B1, B2, B3 = 0.2, 0.1, 0.05 # Beta-decay rates in s^-1\n    T_END = 10.0  # Integration end time in seconds\n    THETAS = [0.0, 0.05, 0.2, 0.5, 0.9, 1.0] # Pruning thresholds\n\n    # Define species indices for clarity in matrix construction.\n    # 0:S80, 1:U81, 2:U82, 3:U83, 4:D81, 5:D82, 6:D83\n    N_SPECIES = 7\n\n    # Construct the full network matrix M based on the ODE system.\n    M = np.zeros((N_SPECIES, N_SPECIES))\n    # S80 - U81 (capture)\n    M[0, 0] -= L0\n    M[1, 0] += L0\n    # U81 - U82 (capture), D81 (beta decay)\n    M[1, 1] -= (L1 + B1)\n    M[2, 1] += L1\n    M[4, 1] += B1\n    # U82 - U83 (capture), D82 (beta decay)\n    M[2, 2] -= (L2 + B2)\n    M[3, 2] += L2\n    M[5, 2] += B2\n    # U83 - D83 (beta decay)\n    M[3, 3] -= B3\n    M[6, 3] += B3\n\n    # Define the ODE system function for the integrator.\n    def ode_system(t, y, matrix):\n        return matrix @ y\n\n    # --- Part 1: Solve the full network ---\n    y0_full = np.zeros(N_SPECIES)\n    y0_full[0] = 1.0\n    t_span = [0, T_END]\n    # Use a dense time grid for accurate numerical quadrature of the throughput.\n    t_eval = np.linspace(t_span[0], t_span[1], 1001)\n\n    sol_full = solve_ivp(\n        lambda t, y: ode_system(t, y, M),\n        t_span,\n        y0_full,\n        t_eval=t_eval,\n        method='RK45',\n        rtol=1e-8,\n        atol=1e-10\n    )\n    Y_full_t = sol_full.y\n    X_full = Y_full_t[:, -1]\n\n    # --- Part 2: Calculate time-integrated throughput F_i for each isotope ---\n    dYdt_full_t = M @ Y_full_t\n    F = trapezoid(np.abs(dYdt_full_t), x=t_eval, axis=1)\n    F_max = np.max(F)\n\n    # --- Part 3  4: Loop over thresholds, solve pruned networks, and calculate errors ---\n    errors = []\n    for theta in THETAS:\n        # Determine the set of kept isotopes based on the throughput criterion.\n        if F_max == 0:\n            kept_indices = np.arange(N_SPECIES) # Should not occur in this problem.\n        else:\n            kept_indices = np.where(F = theta * F_max)[0]\n\n        if len(kept_indices) == 0:\n            # If no isotopes are kept, the final abundance is all zero.\n            X_pruned_tilde = np.zeros(N_SPECIES)\n        else:\n            # Construct the pruned system (matrix and initial conditions).\n            M_pruned = M[np.ix_(kept_indices, kept_indices)]\n            y0_pruned = y0_full[kept_indices]\n            \n            # Solve the pruned ODE system. Only the final point is needed.\n            sol_pruned = solve_ivp(\n                lambda t, y: ode_system(t, y, M_pruned),\n                t_span,\n                y0_pruned,\n                method='RK45',\n                rtol=1e-8,\n                atol=1e-10\n            )\n            # The solver returns initial and final points; we need the last one.\n            X_pruned_final = sol_pruned.y[:, -1]\n            \n            # Embed the pruned final abundances back into the full-dimensional space.\n            X_pruned_tilde = np.zeros(N_SPECIES)\n            X_pruned_tilde[kept_indices] = X_pruned_final\n\n        # Calculate the 1-norm error between full and pruned final abundances.\n        error = np.sum(np.abs(X_full - X_pruned_tilde))\n        errors.append(error)\n\n    # Format the results to exactly six decimal places and print in the required format.\n    # Note: The problem asks for \"for example [0.000000,0.001234,0.056789,...]\",\n    # which I interpret as a request for f-string formatting, not `e` notation.\n    formatted_results = [f\"{err:.6f}\" for err in errors]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}