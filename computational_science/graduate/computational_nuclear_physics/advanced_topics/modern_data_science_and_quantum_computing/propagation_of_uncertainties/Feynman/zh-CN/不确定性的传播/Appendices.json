{
    "hands_on_practices": [
        {
            "introduction": "泰勒级数展开是分析不确定性传播的基石，通过将模型线性化，我们可以推导出不确定性如何从输入参数传递到输出观测量。本练习  旨在通过一个简单的非线性函数 $y=x^2$ 来具体展示这一过程，您将比较一阶和二阶泰勒近似的结果与精确解。这有助于您直观地理解线性化误差的来源，以及高阶项在修正均值（偏差）和方差中的重要作用。",
            "id": "3581693",
            "problem": "在计算核物理的不确定性量化中，通常需要将模型参数的不确定性传播到导出的可观测量。考虑一个由 $y=f(x)=x^{2}$ 定义的简化代理可观测量，其中标量参数 $x$ 代表输运响应模型中的一个无量綱校准缩放因子，并被建模为一个高斯随机变量 $x \\sim \\mathcal{N}(\\mu,\\sigma^{2})$。设 $\\mu=1.2$ 且 $\\sigma=0.15$。\n\n从期望和方差的定义出发，并利用高斯分布的已知矩，推导 $y$ 的均值 $\\mathbb{E}[y]$ 和方差 $\\mathrm{Var}(y)$ 的精确表达式。然后，使用 $f$ 在 $x=\\mu$ 附近的泰勒展开进行不确定性传播：\n\n- 一阶传播：在关于 $\\mu$ 的泰勒展开中保留线性项。\n- 二阶传播：在关于 $\\mu$ 的泰勒展开中保留直到二次项的项。\n\n对于这两种近似，分别求出 $y$ 的近似均值和方差。为量化近似的质量，定义无量纲相对误差（分别对应均值和方差）为\n$$\\epsilon_{\\text{mean}}=\\frac{|\\mathbb{E}_{\\text{approx}}[y]-\\mathbb{E}[y]|}{\\mathbb{E}[y]}, \\quad \\epsilon_{\\text{var}}=\\frac{|\\mathrm{Var}_{\\text{approx}}(y)-\\mathrm{Var}(y)|}{\\mathrm{Var}(y)}.$$\n\n使用给定的 $\\mu$ 和 $\\sigma$ 数值，分别计算对应于均值和方差的一阶和二阶近似的四个相对误差。将你的最终答案表示为一个单行向量，其中包含按顺序排列的这四个数字\n$$\\big(\\epsilon_{\\text{mean, 1st}},\\,\\epsilon_{\\text{mean, 2nd}},\\,\\epsilon_{\\text{var, 1st}},\\,\\epsilon_{\\text{var, 2nd}}\\big),$$\n并四舍五入到六位有效数字。最终答案是无量纲的。",
            "solution": "用户希望我解决一个不确定性传播问题。这是我的计划：\n\n1.  **验证问题：**\n    *   **提取已知条件：** 列出所有提供的信息：函数 `y = f(x) = x^2`，`x` 的分布为高斯分布 `x ~ N(μ, σ^2)`，数值 `μ = 1.2` 和 `σ = 0.15`，相对误差 `ε_mean` 和 `ε_var` 的定义，以及要求的输出格式。\n    *   **验证：** 检查科学合理性、适定性、客观性、完整性等。\n        *   **科学依据：** 该问题涉及标准概率论和统计学（随机变量的矩，用于不确定性传播的泰勒展开）。这是应用数学和物理学中一个成熟的方法。“计算核物理”的背景只是一个框架，核心问题是一个标准的统计计算。它在科学上是合理的。\n        *   **适定性：** 问题定义明确。它要求进行特定的计算（精确矩，使用泰勒级数的近似矩）和比较。存在唯一解。\n        *   **客观性：** 语言精确且数学化。没有主观陈述。\n        *   **完整性：** 所有必要的信息（`f(x)`，`x`的分布，参数`μ`、`σ`，误差公式）都已提供。\n        *   **真实性：** 数值 `μ = 1.2` 和 `σ = 0.15` 对于一个缩放因子是合理的。\n        *   **其他缺陷：** 该问题不平凡，不是同义反复，并且是可验证的。\n\n    *   **结论：** 问题有效。\n\n2.  **解决问题（如果有效）：**\n\n    *   **第1部分：精确均值和方差**\n        *   可观测量是 `y = x^2`。\n        *   `x` 是一个高斯随机变量：`x ~ N(μ, σ^2)`。\n        *   **精确均值 `E[y]`：**\n            *   `E[y] = E[x^2]`。\n            *   我知道方差、均值和二阶矩之间的关系：`Var(x) = E[x^2] - (E[x])^2`。\n            *   对于高斯分布 `x ~ N(μ, σ^2)`，我们有 `E[x] = μ` 和 `Var(x) = σ^2`。\n            *   因此，`E[x^2] = Var(x) + (E[x])^2 = σ^2 + μ^2`。\n            *   所以，精确均值是 `E[y] = μ^2 + σ^2`。\n\n        *   **精确方差 `Var(y)`：**\n            *   `Var(y) = Var(x^2) = E[(x^2)^2] - (E[x^2])^2 = E[x^4] - (μ^2 + σ^2)^2`。\n            *   我需要高斯分布的四阶矩 `E[x^4]`。\n            *   中心化高斯分布 `z ~ N(0, σ^2)` 的矩为：当 `n` 为奇数时 `E[z^n] = 0`，当 `n` 为偶数时 `E[z^n] = (n-1)!! σ^n`。\n            *   设 `x = μ + z`，其中 `z ~ N(0, σ^2)`。\n            *   `E[x^4] = E[(μ + z)^4] = E[μ^4 + 4μ^3z + 6μ^2z^2 + 4μz^3 + z^4]`。\n            *   使用期望的线性性质：`E[x^4] = μ^4 + 4μ^3E[z] + 6μ^2E[z^2] + 4μE[z^3] + E[z^4]`。\n            *   我知道 `E[z] = 0`，`E[z^2] = σ^2`，`E[z^3] = 0`，以及 `E[z^4] = 3!! σ^4 = 3σ^4`。\n            *   所以，`E[x^4] = μ^4 + 6μ^2σ^2 + 3σ^4`。\n            *   现在，将此代回方差公式：\n                `Var(y) = (μ^4 + 6μ^2σ^2 + 3σ^4) - (μ^2 + σ^2)^2`\n                `Var(y) = (μ^4 + 6μ^2σ^2 + 3σ^4) - (μ^4 + 2μ^2σ^2 + σ^4)`\n                `Var(y) = 4μ^2σ^2 + 2σ^4`。\n            *   所以，精确方差是 `Var(y) = 2σ^2(2μ^2 + σ^2)`。\n\n    *   **第2部分：一阶近似**\n        *   将 `f(x) = x^2` 在 `x = μ` 附近进行泰勒展开：`f(x) ≈ f(μ) + f'(μ)(x - μ)`。\n        *   `f(μ) = μ^2`。\n        *   `f'(x) = 2x`，所以 `f'(μ) = 2μ`。\n        *   `y` 的一阶近似是 `y_{1} = μ^2 + 2μ(x - μ)`。\n        *   **近似均值 `E_approx[y]` (一阶):**\n            *   `E[y_1] = E[μ^2 + 2μ(x - μ)] = μ^2 + 2μE[x - μ]`。\n            *   因为 `E[x] = μ`，所以 `E[x - μ] = E[x] - μ = 0`。\n            *   所以，`E_{approx, 1st}[y] = μ^2`。\n        *   **近似方差 `Var_approx(y)` (一阶):**\n            *   `Var(y_1) = Var(μ^2 + 2μ(x - μ))`。\n            *   使用方差性质 `Var(a + bX) = b^2 Var(X)`：\n            *   `Var(y_1) = Var(2μx - 2μ^2 + μ^2) = Var(2μx - μ^2) = (2μ)^2 Var(x) = 4μ^2σ^2`。\n            *   所以，`Var_{approx, 1st}(y) = 4μ^2σ^2`。\n\n    *   **第3部分：二阶近似**\n        *   将 `f(x) = x^2` 在 `x = μ` 附近泰勒展开至二阶项：`f(x) ≈ f(μ) + f'(μ)(x - μ) + (1/2)f''(μ)(x - μ)^2`。\n        *   `f''(x) = 2`，所以 `f''(μ) = 2`。\n        *   `y` 的二阶近似是 `y_{2} = μ^2 + 2μ(x - μ) + (1/2)(2)(x - μ)^2 = μ^2 + 2μ(x - μ) + (x - μ)^2`。\n        *   **近似均值 `E_approx[y]` (二阶):**\n            *   `E[y_2] = E[μ^2 + 2μ(x - μ) + (x - μ)^2]`。\n            *   `E[y_2] = μ^2 + 2μE[x - μ] + E[(x - μ)^2]`。\n            *   我们知道 `E[x - μ] = 0` 并且 `E[(x - μ)^2]` 是方差的定义，即 `Var(x) = σ^2`。\n            *   所以，`E_{approx, 2nd}[y] = μ^2 + σ^2`。\n            *   注意这与精确均值相同。\n\n        *   **近似方差 `Var_approx(y)` (二阶):**\n            *   我们来简化 `y_2`：`y_2 = μ^2 + 2μx - 2μ^2 + x^2 - 2μx + μ^2 = x^2`。\n            *   `f(x) = x^2` 的二阶泰勒展开*恰好*就是 `f(x)`。这是因为 `f(x)` 是一个二次多项式，其二阶（或更高阶）泰勒级数就是该多项式本身。所有更高阶的导数都为零。\n            *   因此，“近似” `y_2` 实际上就是精确函数 `y`。\n            *   `y_2 = x^2`。\n            *   `E_{approx, 2nd}[y] = E[x^2] = μ^2 + σ^2`。（与我之前的计算相符）。\n            *   `Var_{approx, 2nd}(y) = Var(x^2) = 4μ^2σ^2 + 2σ^4`。（与精确方差相符）。\n            *   这是一个特殊情况。泰勒展开是精确的。\n\n    *   **第4部分：计算相对误差**\n        *   **给定值：** `μ = 1.2`， `σ = 0.15`。\n        *   `μ^2 = (1.2)^2 = 1.44`。\n        *   `σ^2 = (0.15)^2 = 0.0225`。\n\n        *   **精确值：**\n            *   `E[y] = μ^2 + σ^2 = 1.44 + 0.0225 = 1.4625`。\n            *   `Var(y) = 4μ^2σ^2 + 2σ^4 = 4(1.44)(0.0225) + 2(0.0225)^2`。\n                *   `4 * 1.44 * 0.0225 = 0.1296`。\n                *   `2 * (0.0225)^2 = 2 * 0.00050625 = 0.0010125`。\n                *   `Var(y) = 0.1296 + 0.0010125 = 0.1306125`。\n\n        *   **近似值（一阶）：**\n            *   `E_{approx, 1st}[y] = μ^2 = 1.44`。\n            *   `Var_{approx, 1st}(y) = 4μ^2σ^2 = 4(1.44)(0.0225) = 0.1296`。\n\n        *   **近似值（二阶）：**\n            *   `E_{approx, 2nd}[y] = μ^2 + σ^2 = 1.44 + 0.0225 = 1.4625`。（这是精确值）。\n            *   `Var_{approx, 2nd}(y) = 4μ^2σ^2 + 2σ^4 = 0.1306125`。（这是精确值）。\n\n        *   **误差计算：**\n            *   `ε_mean, 1st`:\n                `|E_{approx, 1st}[y] - E[y]| / E[y] = |1.44 - 1.4625| / 1.4625 = |-0.0225| / 1.4625 = 0.0225 / 1.4625 = 0.015384615...`\n                四舍五入到六位有效数字：`1.53846 \\times 10^{-2}`。\n\n            *   `ε_mean, 2nd`:\n                `|E_{approx, 2nd}[y] - E[y]| / E[y] = |1.4625 - 1.4625| / 1.4625 = 0 / 1.4625 = 0`。\n                用六位有效数字表示，即 `0.000000`。\n\n            *   `ε_var, 1st`:\n                `|Var_{approx, 1st}(y) - Var(y)| / Var(y) = |0.1296 - 0.1306125| / 0.1306125 = |-0.0010125| / 0.1306125 = 0.0010125 / 0.1306125`。\n                `0.0010125 / 0.1306125 = 0.0077519379...`\n                四舍五入到六位有效数字：`7.75194 \\times 10^{-3}`。\n\n            *   `ε_var, 2nd`:\n                `|Var_{approx, 2nd}(y) - Var(y)| / Var(y) = |0.1306125 - 0.1306125| / 0.1306125 = 0 / 0.1306125 = 0`。\n                用六位有效数字表示，即 `0.000000`。\n\n    *   **最终答案格式化：**\n        *   一个单行向量：`(ε_mean, 1st, ε_mean, 2nd, ε_var, 1st, ε_var, 2nd)`。\n        *   顺序正确。\n        *   数值四舍五入到六位有效数字。\n        *   `ε_mean, 1st = 0.0153846`\n        *   `ε_mean, 2nd = 0.000000`\n        *   `ε_var, 1st = 0.00775194`\n        *   `ε_var, 2nd = 0.000000`\n整个逻辑是合理的。我现在将写出最终解。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.0153846  0.000000  0.00775194  0.000000\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然解析方法富有洞察力，但对于复杂的计算模型，它们往往难以实施，此时蒙特卡洛方法提供了一种功能强大且通用的数值替代方案。在本练习  中，您不仅将通过随机抽样来传播不确定性，还将学习一项关键技能：评估蒙特卡洛模拟结果本身的统计不确定性。这是确保计算工作严谨性的重要环节，并能帮助您确定获得可靠结果所需的样本数量。",
            "id": "3581694",
            "problem": "考虑一个用于计算核物理中子增殖的单参数无限介质玩具模型。微观吸收截面被建模为一个对数正态随机变量，其参数在对数尺度上定义：如果 $\\sigma$ 表示以靶恩（barns）为单位的截面，那么 $\\ln \\sigma \\sim \\mathcal{N}(\\mu,\\tau^2)$，其中 $\\mu \\in \\mathbb{R}$ 和 $\\tau^2 \\in (0,\\infty)$ 是已知的。有效中子增殖因子被建模为截面的确定性函数，$k_{\\mathrm{eff}} = g(\\sigma)$，其中\n$$\ng(\\sigma) = k_0 \\exp(-\\alpha \\sigma),\n$$\n其中 $k_0 \\in (0,\\infty)$ 是无量纲的，$\\alpha \\in (0,\\infty)$ 的单位是反靶恩。映射 $g$ 是严格递减的，并将 $\\sigma \\in (0,\\infty)$ 映射到 $k_{\\mathrm{eff}} \\in (0,k_0)$。\n\n您的任务是实现从 $\\sigma$ 到 $k_{\\mathrm{eff}}$ 的蒙特卡洛不确定性传播，然后使用 $N$ 个独立同分布的样本来估计 $k_{\\mathrm{eff}}$ 在水平 $0.95$ 上的等尾置信区间，并为每个端点提供一个误差棒，以量化由于有限的 $N$ 引起的蒙特卡洛抽样不确定性。\n\n您必须从基本定义开始：\n- 对数正态分布的密度源于对 $\\ln \\sigma$ 上的正态分布进行变量变换。\n- $k_{\\mathrm{eff}}$ 的分布是通过 $g$ 对对数正态分布进行前推（pushforward）得到的。\n- 水平 $0.95$ 的等尾置信区间是传播后样本在概率 $0.025$ 和 $0.975$ 处的经验分位数之间的区间。\n- 每个端点的误差棒必须是根据独立同分布样本的经验分位数的渐近行为推导出的单标准误估计，用相应真实分位数处的概率密度函数（PDF）表示。您必须通过将变量变换公式应用于已知的 $\\sigma$ 的对数正态PDF来获得 $k_{\\mathrm{eff}}$ 的PDF，然后在代入的经验分位数处对其进行求值。\n\n物理单位和数值约定：\n- 将 $\\sigma$ 以靶恩表示，$\\alpha$ 以反靶恩表示，$k_{\\mathrm{eff}}$ 为无量纲。\n- 此问题中不出现角度。\n- 置信水平 $0.95$ 必须被视为 $(0,1)$ 内的概率，而不是百分比。\n- 为确保确定性结果，对所有模拟使用等于 $12345$ 的固定随机种子。\n\n实现要求：\n- 从指定的对数正态分布中抽取 $N$ 个 $\\sigma$ 的独立同分布样本。\n- 将每个样本通过 $g$ 传播，以获得 $k_{\\mathrm{eff}}$ 的样本。\n- 计算 $k_{\\mathrm{eff}}$ 在概率 $0.025$ 和 $0.975$ 处的经验分位数，以构成估计的置信区间 $[\\hat{q}_{0.025}, \\hat{q}_{0.975}]$。\n- 使用 $\\sigma$ 的解析PDF和在 $g$ 下的变量变换公式，计算 $k_{\\mathrm{eff}}$ 在 $y=\\hat{q}_{0.025}$ 和 $y=\\hat{q}_{0.975}$ 处的PDF。使用这些值为具有 $N$ 个样本、在 $p=0.025$ 和 $p=0.975$ 处的分位数构建渐近单标准误估计。\n- 将每个测试用例的结果报告为一个列表 $[\\hat{q}_{0.025}, \\hat{q}_{0.975}, s_{0.025}, s_{0.975}]$，其中 $s_{p}$ 是经验 $p$-分位数的单标准误。\n\n测试套件：\n实现您的程序以按顺序运行以下四个测试用例。对于每个用例，使用提供的元组 $(\\mu,\\tau,\\alpha,k_0,N)$：\n- 用例 $1$：$(\\ln(1.5), 0.25, 0.05, 1.0, 40000)$\n- 用例 $2$：$(\\ln(2.5), 0.60, 0.08, 1.0, 60000)$\n- 用例 $3$：$(0.0, 0.05, 0.03, 1.0, 5000)$\n- 用例 $4$：$(\\ln(0.5), 0.40, 0.10, 0.98, 30000)$\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含四个用例的结果，这些结果聚合在单个列表的列表中，不含空格，其中每个内部列表为对应于该用例的 $[\\hat{q}_{0.025},\\hat{q}_{0.975},s_{0.025},s_{0.975}]$。\n- 每个浮点值必须四舍五入到小数点后恰好 $6$ 位。\n- 例如，语法形式必须类似于 $[[a,b,c,d],[e,f,g,h],[i,j,k,l],[m,n,o,p]]$，其中每个字母代表一个小数点后恰好有 $6$ 位的浮点数。",
            "solution": "目标是执行从对数正态分布的微观吸收截面 $\\sigma$ 到有效中子增殖因子 $k_{\\mathrm{eff}}$ 的蒙特卡洛不确定性传播，并估计 $k_{\\mathrm{eff}}$ 的 $0.95$ 等尾置信区间及其端点的标准误。该过程依赖于概率论和统计学的基本原理，包括概率分布的变量变换公式和样本分位数的渐近性质。\n\n让我们从建立所需的概率密度函数（PDF）开始。\n\n**1. 截面 $\\sigma$ 的概率密度函数**\n问题指出，截面的自然对数 $\\ln \\sigma$ 服从正态分布，$\\ln \\sigma \\sim \\mathcal{N}(\\mu, \\tau^2)$。令 $X = \\ln \\sigma$。$X$ 的PDF由下式给出：\n$$f_X(x) = \\frac{1}{\\tau \\sqrt{2\\pi}} \\exp\\left(-\\frac{(x - \\mu)^2}{2\\tau^2}\\right)$$\n截面 $\\sigma$ 通过变换 $\\sigma = \\exp(X)$ 与 $X$ 相关。为了求出 $\\sigma$ 的PDF，记为 $f_\\Sigma(\\sigma)$，我们应用变量变换公式：\n$$f_\\Sigma(\\sigma) = f_X(\\ln \\sigma) \\left| \\frac{d(\\ln \\sigma)}{d\\sigma} \\right| = f_X(\\ln \\sigma) \\cdot \\frac{1}{\\sigma}$$\n代入 $f_X(x)$ 的表达式，我们得到对数正态分布的PDF：\n$$f_\\Sigma(\\sigma) = \\frac{1}{\\sigma\\tau\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln \\sigma - \\mu)^2}{2\\tau^2}\\right) \\quad \\text{for } \\sigma > 0$$\n\n**2. 增殖因子 $k_{\\mathrm{eff}}$ 的概率密度函数**\n有效增殖因子 $k_{\\mathrm{eff}}$ 是 $\\sigma$ 的一个确定性函数：$k_{\\mathrm{eff}} = g(\\sigma) = k_0 \\exp(-\\alpha \\sigma)$。我们将增殖因子的随机变量表示为 $Y$，因此 $Y = g(\\sigma)$。为了求出其PDF $f_Y(y)$，我们再次使用变量变换公式。首先，我们需要反函数 $\\sigma = g^{-1}(y)$：\n$$y = k_0 \\exp(-\\alpha \\sigma) \\implies \\frac{y}{k_0} = \\exp(-\\alpha \\sigma) \\implies \\ln\\left(\\frac{y}{k_0}\\right) = -\\alpha \\sigma$$\n$$\\sigma = g^{-1}(y) = -\\frac{1}{\\alpha}\\ln\\left(\\frac{y}{k_0}\\right) = \\frac{1}{\\alpha}\\ln\\left(\\frac{k_0}{y}\\right)$$\n函数 $g$ 将 $\\sigma \\in (0, \\infty)$ 映射到 $y \\in (0, k_0)$。反函数在此范围内定义。接下来，我们计算反函数关于 $y$ 的导数：\n$$\\frac{d\\sigma}{dy} = \\frac{d}{dy}\\left[\\frac{1}{\\alpha}\\left(\\ln k_0 - \\ln y\\right)\\right] = -\\frac{1}{\\alpha y}$$\n变量变换法则表明 $f_Y(y) = f_\\Sigma(g^{-1}(y)) \\left|\\frac{d(g^{-1}(y))}{dy}\\right|$。代入 $g^{-1}(y)$、其导数和 $f_\\Sigma(\\sigma)$ 的表达式：\n$$f_Y(y) = f_\\Sigma\\left(\\frac{1}{\\alpha}\\ln\\left(\\frac{k_0}{y}\\right)\\right) \\cdot \\left|-\\frac{1}{\\alpha y}\\right|$$\n令 $\\sigma(y) = \\frac{1}{\\alpha}\\ln(\\frac{k_0}{y})$。则PDF $f_Y(y)$ 为：\n$$f_Y(y) = \\frac{1}{\\sigma(y)\\tau\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln(\\sigma(y)) - \\mu)^2}{2\\tau^2}\\right) \\cdot \\frac{1}{\\alpha y}$$\n将 $\\sigma(y)$ 代入表达式中，得到对于 $y \\in (0, k_0)$ 的最终形式：\n$$f_Y(y) = \\frac{1}{\\left(\\frac{1}{\\alpha}\\ln\\frac{k_0}{y}\\right)\\tau\\sqrt{2\\pi}} \\exp\\left(-\\frac{\\left(\\ln\\left(\\frac{1}{\\alpha}\\ln\\frac{k_0}{y}\\right) - \\mu\\right)^2}{2\\tau^2}\\right) \\cdot \\frac{1}{\\alpha y}$$\n该表达式可以简化为：\n$$f_Y(y) = \\frac{1}{y \\ln(k_0/y) \\tau\\sqrt{2\\pi}} \\exp\\left(-\\frac{\\left(\\ln\\left(\\frac{1}{\\alpha}\\ln\\frac{k_0}{y}\\right) - \\mu\\right)^2}{2\\tau^2}\\right)$$\n\n**3. 蒙特卡洛模拟与置信区间估计**\n任务的核心是蒙特卡洛模拟。该过程包括以下步骤：\n1.  从正态分布 $\\mathcal{N}(\\mu, \\tau^2)$ 生成 $N$ 个独立同分布（i.i.d.）样本 $\\{x_i\\}_{i=1}^N$。\n2.  变换这些样本以获得 $N$ 个截面样本：$\\sigma_i = \\exp(x_i)$。\n3.  将截面样本通过模型传播，以获得 $N$ 个增殖因子样本：$y_i = k_0 \\exp(-\\alpha \\sigma_i)$。\n4.  $k_{\\mathrm{eff}}$ 的 $0.95$ 等尾置信区间通过样本集 $\\{y_i\\}$ 的经验分位数来估计。该区间为 $[\\hat{q}_{0.025}, \\hat{q}_{0.975}]$，其中 $\\hat{q}_p$ 是经验 $p$-分位数。这些分位数通常通过对排序后的 $k_{\\mathrm{eff}}$ 样本进行相邻样本间的线性插值来计算。\n\n**4. 分位数估计的标准误**\n经验分位数 $\\hat{q}_p$ 作为真实分位数 $q_p$ 的估计量的精度，可以通过其标准误来量化。对于大样本量 $N$，$\\hat{q}_p$ 的分布近似为正态分布。标准误 $s_p$ 是该近似分布的标准差，由以下渐近公式给出：\n$$s_p = \\sqrt{\\mathrm{Var}(\\hat{q}_p)} \\approx \\frac{\\sqrt{p(1-p)}}{\\sqrt{N} f_Y(q_p)}$$\n由于真实分位数 $q_p$ 以及 $f_Y(q_p)$ 是未知的，我们使用“代入”估计量，即用经验分位数 $\\hat{q}_p$ 替代 $q_p$：\n$$\\hat{s}_p = \\frac{\\sqrt{p(1-p)}}{\\sqrt{N} f_Y(\\hat{q}_p)}$$\n我们将为下分位数（$p_1=0.025$）和上分位数（$p_2=0.975$）计算此标准误。对于两者，分子 $\\sqrt{p(1-p)}$ 是相同的：$\\sqrt{0.025(1-0.025)} = \\sqrt{0.975(1-0.975)} = \\sqrt{0.024375}$。\n\n实现将为每个测试用例遵循以下步骤：生成 $k_{\\mathrm{eff}}$ 的样本，计算分位数 $\\hat{q}_{0.025}$ 和 $\\hat{q}_{0.975}$，在这些分位数处评估导出的PDF $f_Y(y)$，最后计算标准误 $\\hat{s}_{0.025}$ 和 $\\hat{s}_{0.975}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Per the problem, use a fixed random seed for deterministic results.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (mu, tau, alpha, k0, N)\n    test_cases = [\n        (np.log(1.5), 0.25, 0.05, 1.0, 40000),\n        (np.log(2.5), 0.60, 0.08, 1.0, 60000),\n        (0.0, 0.05, 0.03, 1.0, 5000),\n        (np.log(0.5), 0.40, 0.10, 0.98, 30000)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        mu, tau, alpha, k0, N = case\n        result = process_case(mu, tau, alpha, k0, N, rng)\n        all_results.append(result)\n\n    # Format the output as a single list of lists string with no spaces and\n    # each float rounded to 6 decimal places.\n    formatted_inner_lists = []\n    for res in all_results:\n        # res is [q_low, q_high, s_low, s_high]\n        formatted_inner_lists.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{res[3]:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_inner_lists)}]\"\n    print(final_output_string)\n\n\ndef process_case(mu, tau, alpha, k0, N, rng):\n    \"\"\"\n    Performs the full calculation for a single test case.\n\n    Args:\n        mu (float): Log-scale mean of the cross section.\n        tau (float): Log-scale standard deviation of the cross section.\n        alpha (float): Parameter in the g(sigma) function.\n        k0 (float): Parameter in the g(sigma) function.\n        N (int): Number of Monte Carlo samples.\n        rng (numpy.random.Generator): Random number generator instance.\n\n    Returns:\n        list: A list containing [q_low, q_high, s_low, s_high].\n    \"\"\"\n    # 1. Generate N samples of sigma from the lognormal distribution.\n    #    This is done by generating from a normal distribution and exponentiating.\n    ln_sigma_samples = rng.normal(loc=mu, scale=tau, size=N)\n    sigma_samples = np.exp(ln_sigma_samples)\n\n    # 2. Propagate samples through g(sigma) to get k_eff samples.\n    k_eff_samples = k0 * np.exp(-alpha * sigma_samples)\n\n    # 3. Compute the empirical quantiles for the 0.95 credible interval.\n    p_low = 0.025\n    p_high = 0.975\n    q_low = np.quantile(k_eff_samples, p_low)\n    q_high = np.quantile(k_eff_samples, p_high)\n\n    # 4. Define the analytical PDF of k_eff, f_Y(y).\n    def pdf_k_eff(y):\n        # The support for y is (0, k0). Outside this, PDF is 0.\n        # Quantiles from samples will be within this range.\n        if not (0  y  k0):\n            return 0.0\n        \n        # This term corresponds to sigma = g_inv(y)\n        ln_k0_over_y = np.log(k0 / y)\n        sigma_val = (1.0 / alpha) * ln_k0_over_y\n        \n        # This term corresponds to ln(sigma)\n        ln_sigma_val = np.log(sigma_val)\n        \n        # Numerator of the exponent term in the PDF\n        exp_num = -((ln_sigma_val - mu)**2)\n        # Denominator of the exponent term\n        exp_den = 2 * tau**2\n        \n        # Overall multiplicative factor for the PDF of k_eff\n        # This factor is 1 / (y * ln(k0/y) * tau * sqrt(2*pi))\n        factor = 1.0 / (y * ln_k0_over_y * tau * np.sqrt(2 * np.pi))\n        \n        pdf = factor * np.exp(exp_num / exp_den)\n        return pdf\n\n    # 5. Evaluate the PDF at the estimated quantiles.\n    pdf_at_q_low = pdf_k_eff(q_low)\n    pdf_at_q_high = pdf_k_eff(q_high)\n\n    # 6. Compute the standard error for each quantile estimate.\n    # The numerator sqrt(p*(1-p)) is the same for p=0.025 and p=0.975.\n    numerator = np.sqrt(p_low * (1 - p_low))\n    \n    s_low = numerator / (np.sqrt(N) * pdf_at_q_low)\n    s_high = numerator / (np.sqrt(N) * pdf_at_q_high)\n\n    return [q_low, q_high, s_low, s_high]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "当您的工具箱中同时拥有解析近似和数值模拟方法时，一个关键问题便随之而来：应如何选择？最后的这个练习  旨在弥合这两种方法之间的鸿沟。通过实现一个数值诊断程序，您将学会如何通过分析模型相对于输入不确定性的局部曲率来建立一个定量标准，以判断泰勒级数近似是否足够可靠，还是模型的非线性强度已使得必须采用更稳健的蒙特卡洛模拟。",
            "id": "3581708",
            "problem": "考虑一个来自计算核物理的可观测量，其定义为对反应率的麦克斯韦平均单共振贡献。设该标量可观测量为积分 $$R(A,E_r,\\Gamma;kT) = \\int_{0}^{\\infty} y e^{-y} \\frac{A}{\\big(kT\\,y - E_r\\big)^2 + \\big(\\Gamma/2\\big)^2}\\,dy,$$ 其中 $A$ 是一个尺度参数（单位为靶恩），$E_r$ 是共振能量（单位为兆电子伏），$\\Gamma$ 是总共振宽度（单位为兆电子伏），$kT$ 是热能（单位为兆电子伏）。权重函数 $y e^{-y}$ 源于麦克斯韦-玻尔兹曼谱在进行变量替换 $y = E/(kT)$ 之后的形式，这种替换保持了量纲一致性，并确保 $R$ 是一个具有物理意义的类反应率可观测量。\n\n假设参数矢量 $$\\boldsymbol{\\theta} = \\begin{bmatrix} A \\\\ E_r \\\\ \\Gamma \\end{bmatrix}$$ 被建模为一个多元正态随机变量，其均值为 $$\\boldsymbol{\\mu} = \\begin{bmatrix} \\mu_A \\\\ \\mu_{E_r} \\\\ \\mu_{\\Gamma} \\end{bmatrix}$$，协方差矩阵为 $$\\mathbf{C} \\in \\mathbb{R}^{3\\times 3}$$。任务是实现一个用于不确定性传播的诊断工具，该工具为每个指定的测试用例确定，是应该采用高阶（二阶泰勒）传播，还是由于非线性而必须采用蒙特卡洛（随机抽样）传播。\n\n从多变量标量函数的泰勒展开和多元正态分布的性质出发，您必须：\n- 使用中心有限差分，推导并实现梯度 $$\\mathbf{g} = \\nabla_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu};kT)$$ 和海森矩阵 $$\\mathbf{H} = \\nabla^2_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu};kT)$$ 的数值近似。使用逐维步长 $$h_i = \\varepsilon \\max\\big(|\\mu_i|, 1\\big)$$，其中 $$\\varepsilon = 10^{-4}$$。\n- 使用量 $$\\mathbf{g}$$ 和 $$\\mathbf{H}$$ 以及协方差 $$\\mathbf{C}$$，计算：\n  1. 主导（线性）方差贡献 $$V_1$$，归因于梯度和协方差。\n  2. 主导曲率诱导（二阶）方差修正 $$V_2$$，归因于海森矩阵和协方差。\n  3. 曲率诱导的均值偏移（偏差）$$b_2$$，归因于海森矩阵和协方差。\n- 定义诊断度量：\n  - 曲率分数 $$\\kappa_{\\mathrm{var}} = V_2 / V_1$$。\n  - 归一化偏差 $$\\kappa_{\\mathrm{bias}} = |b_2| / \\sqrt{V_1}$$。\n- 决策规则：对于每个测试用例，如果 $$\\kappa_{\\mathrm{var}} \\leq 0.25$$ 和 $$\\kappa_{\\mathrm{bias}} \\leq 0.25$$ 同时满足，则判定高阶传播（二阶泰勒）是合理的；否则判定蒙特卡洛（随机抽样）传播是合理的。将决策报告为整数，高阶传播为 $$0$$，蒙特卡洛传播为 $$1$$。\n\n完全按照给定形式实现积分，使用在 $$y \\in [0,\\infty)$$ 上的数值积分法。此问题不涉及角度，因此不需要角度单位。所有能量单位必须理解为兆电子伏，振幅 $$A$$ 的单位必须理解为靶恩；但是，要求的输出是无单位整数，因此您只需报告每个测试用例的决策。\n\n测试套件：\n- 用例 $$1$$ (理想情况，曲率温和):\n  - $$kT = 0.5.$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,1.5,\\,0.4].$$\n  - $$\\mathbf{C} = \\mathrm{diag}\\big([0.2^2,\\,0.05^2,\\,0.04^2]\\big) = \\mathrm{diag}([0.04,\\,0.0025,\\,0.0016]).$$\n- 用例 $$2$$ (近共振，中等曲率，弱相关):\n  - $$kT = 0.5.$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,0.7,\\,0.2].$$\n  - 标准差为 $$[0.5,\\,0.07,\\,0.02]$$，$$E_r$$ 与 $$\\Gamma$$ 之间的相关性等于 $$0.3$$。因此 $$\\mathbf{C}$$ 的对角线元素为 $$[0.25,\\,0.0049,\\,0.0004]$$，非对角线元素为 $$C_{E_r,\\Gamma} = C_{\\Gamma,E_r} = 0.3 \\cdot 0.07 \\cdot 0.02 = 0.00042$$，其他非对角线元素为零。\n- 用例 $$3$$ (较强曲率，强相关):\n  - $$kT = 0.4.$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,0.52,\\,0.05].$$\n  - 标准差为 $$[1.0,\\,0.08,\\,0.02]$$，$$E_r$$ 与 $$\\Gamma$$ 之间的相关性等于 $$0.8$$。因此 $$\\mathbf{C}$$ 的对角线元素为 $$[1.0,\\,0.0064,\\,0.0004]$$，非对角线元素为 $$C_{E_r,\\Gamma} = C_{\\Gamma,E_r} = 0.8 \\cdot 0.08 \\cdot 0.02 = 0.00128$$，其他非对角线元素为零。\n- 用例 $$4$$ (共振处窄宽度，非线性边缘，负相关):\n  - $$kT = 0.6.$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,0.5,\\,0.02].$$\n  - 标准差为 $$[0.1,\\,0.005,\\,0.004]$$，$$E_r$$ 与 $$\\Gamma$$ 之间的相关性等于 $$-0.6$$。因此 $$\\mathbf{C}$$ 的对角线元素为 $$[0.01,\\,2.5\\times 10^{-5},\\,1.6\\times 10^{-5}]$$，非对角线元素为 $$C_{E_r,\\Gamma} = C_{\\Gamma,E_r} = -0.6 \\cdot 0.005 \\cdot 0.004 = -1.2\\times 10^{-5}$$，其他非对角线元素为零。\n\n您的程序应生成单行输出，其中包含四个用例的决策，形式为方括号括起来的逗号分隔列表（例如，$$[0,1,0,1]$$）。输出元素必须是整数 $$0$$ 或 $$1$$。",
            "solution": "问题陈述已经过评估，被认为是有效的。其科学基础在于核反应理论和统计不确定性传播的原理。该问题是适定的，提供了所有必要的数据、定义和约束，从而允许唯一解。其语言客观且数学上精确。因此，我们可以着手求解。\n\n问题的核心是在从多元正态分布 $\\boldsymbol{\\theta} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$ 传播不确定性的背景下，评估函数 $R(\\boldsymbol{\\theta})$ 相对于其参数 $\\boldsymbol{\\theta} = [A, E_r, \\Gamma]^T$ 的非线性程度。诊断工具源自于函数 $R(\\boldsymbol{\\theta})$ 在均值参数矢量 $\\boldsymbol{\\mu}$ 周围的二阶泰勒级数展开。\n\n泰勒展开由下式给出：\n$$ R(\\boldsymbol{\\theta}) \\approx R(\\boldsymbol{\\mu}) + (\\boldsymbol{\\theta} - \\boldsymbol{\\mu})^T \\mathbf{g} + \\frac{1}{2} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu})^T \\mathbf{H} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}) $$\n其中 $\\mathbf{g} = \\nabla_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu})$ 是梯度矢量，$\\mathbf{H} = \\nabla^2_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu})$ 是在均值 $\\boldsymbol{\\mu}$ 处求值的 $R$ 的海森矩阵。梯度和海森矩阵的分量分别是偏导数 $g_i = \\partial R / \\partial \\theta_i$ 和 $H_{ij} = \\partial^2 R / (\\partial \\theta_i \\partial \\theta_j)$。\n\n从这个展开式，我们可以求得 $R(\\boldsymbol{\\theta})$ 分布的近似矩。\n$R$ 的期望值（均值）可以通过对展开式求期望得到。设 $\\boldsymbol{\\delta} = \\boldsymbol{\\theta} - \\boldsymbol{\\mu}$。根据定义，$\\mathbb{E}[\\boldsymbol{\\delta}] = \\mathbf{0}$，协方差为 $\\mathbb{E}[\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T] = \\mathbf{C}$。\n$$ \\mathbb{E}[R(\\boldsymbol{\\theta})] \\approx \\mathbb{E}[R(\\boldsymbol{\\mu}) + \\mathbf{g}^T\\boldsymbol{\\delta} + \\frac{1}{2}\\boldsymbol{\\delta}^T\\mathbf{H}\\boldsymbol{\\delta}] $$\n$$ \\mathbb{E}[R(\\boldsymbol{\\theta})] \\approx R(\\boldsymbol{\\mu}) + \\mathbf{g}^T\\mathbb{E}[\\boldsymbol{\\delta}] + \\frac{1}{2}\\mathbb{E}[\\boldsymbol{\\delta}^T\\mathbf{H}\\boldsymbol{\\delta}] $$\n$$ \\mathbb{E}[R(\\boldsymbol{\\theta})] \\approx R(\\boldsymbol{\\mu}) + \\frac{1}{2}\\mathbb{E}[\\text{Tr}(\\mathbf{H}\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T)] = R(\\boldsymbol{\\mu}) + \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbb{E}[\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T]) = R(\\boldsymbol{\\mu}) + \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbf{C}) $$\n项 $b_2 = \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbf{C})$ 是由函数 $R$ 的曲率引起的二阶偏差或均值偏移。\n\n$R$ 的方差更为复杂。到一阶，我们只考虑线性项：\n$$ R(\\boldsymbol{\\theta}) \\approx R(\\boldsymbol{\\mu}) + \\mathbf{g}^T\\boldsymbol{\\delta} $$\n方差则为：\n$$ \\text{Var}(R) \\approx \\text{Var}(\\mathbf{g}^T\\boldsymbol{\\delta}) = \\mathbb{E}[(\\mathbf{g}^T\\boldsymbol{\\delta})(\\mathbf{g}^T\\boldsymbol{\\delta})^T] = \\mathbb{E}[\\mathbf{g}^T\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T\\mathbf{g}] = \\mathbf{g}^T\\mathbb{E}[\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T]\\mathbf{g} = \\mathbf{g}^T\\mathbf{C}\\mathbf{g} $$\n这是对方法差的主导线性贡献，记为 $V_1 = \\mathbf{g}^T\\mathbf{C}\\mathbf{g}$。\n\n对方法差的次主导贡献来自泰勒展开中的二次项。对于多元正态输入，二次型 $\\frac{1}{2}\\boldsymbol{\\delta}^T\\mathbf{H}\\boldsymbol{\\delta}$ 的方差由 $\\frac{1}{2}\\text{Tr}((\\mathbf{H}\\mathbf{C})^2)$ 给出。线性和二次部分之间也存在一个协方差项，但对于像正态分布这样的对称分布，如果三阶中心矩为零，则该项为零。因此，主导的曲率诱导方差修正是 $V_2 = \\frac{1}{2}\\text{Tr}((\\mathbf{H}\\mathbf{C})^2)$。\n\n求解策略如下：\n1.  对于任何给定的参数矢量 $\\boldsymbol{\\theta}$ 和热能 $kT$，数值计算可观测量 $R(\\boldsymbol{\\theta}; kT)$。该积分是在半无限域上进行的，这建议使用专门的数值积分程序，例如 `scipy.integrate.quad`。被积函数为 $f(y; \\boldsymbol{\\theta}, kT) = y e^{-y} A \\left[ (kT\\,y - E_r)^2 + (\\Gamma/2)^2 \\right]^{-1}$。\n2.  按照要求，使用中心有限差分法在 $\\boldsymbol{\\theta} = \\boldsymbol{\\mu}$ 处数值近似梯度 $\\mathbf{g}$ 和海森矩阵 $\\mathbf{H}$。对于函数 $R(\\boldsymbol{\\theta})$，其导数为：\n    - 梯度分量：$g_i \\approx \\frac{R(\\boldsymbol{\\mu} + h_i\\mathbf{e}_i) - R(\\boldsymbol{\\mu} - h_i\\mathbf{e}_i)}{2h_i}$\n    - 海森矩阵对角分量：$H_{ii} \\approx \\frac{R(\\boldsymbol{\\mu} + h_i\\mathbf{e}_i) - 2R(\\boldsymbol{\\mu}) + R(\\boldsymbol{\\mu} - h_i\\mathbf{e}_i)}{h_i^2}$\n    - 海森矩阵非对角分量：$H_{ij} \\approx \\frac{R(\\boldsymbol{\\mu}+h_i\\mathbf{e}_i+h_j\\mathbf{e}_j) - R(\\boldsymbol{\\mu}+h_i\\mathbf{e}_i-h_j\\mathbf{e}_j) - R(\\boldsymbol{\\mu}-h_i\\mathbf{e}_i+h_j\\mathbf{e}_j) + R(\\boldsymbol{\\mu}-h_i\\mathbf{e}_i-h_j\\mathbf{e}_j)}{4h_i h_j}$\n    其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基矢量， $h_i = \\varepsilon \\max(|\\mu_i|, 1)$ 是步长，$\\varepsilon = 10^{-4}$。\n3.  对于每个测试用例，构建均值矢量 $\\boldsymbol{\\mu}$ 和协方差矩阵 $\\mathbf{C}$。\n4.  计算量 $V_1 = \\mathbf{g}^T\\mathbf{C}\\mathbf{g}$、$b_2 = \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbf{C})$ 和 $V_2 = \\frac{1}{2}\\text{Tr}((\\mathbf{H}\\mathbf{C})^2)$。\n5.  计算诊断度量 $\\kappa_{\\mathrm{var}} = V_2/V_1$ 和 $\\kappa_{\\mathrm{bias}} = |b_2|/\\sqrt{V_1}$。\n6.  应用决策规则：如果 $\\kappa_{\\mathrm{var}} \\leq 0.25$ 且 $\\kappa_{\\mathrm{bias}} \\leq 0.25$，则决策为高阶传播（编码为 $0$）。否则，蒙特卡洛是合理的（编码为 $1$）。\n\n对所提供的四个测试用例中的每一个都实施此过程。该实现需要仔细处理数值精度和正确应用矩阵代数。最终输出将是一个整数列表，代表每个用例的决策。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty propagation diagnostic problem for all test cases.\n    \"\"\"\n\n    def R_integrand(y, A, Er, Gamma, kT):\n        \"\"\"The integrand for the observable R.\"\"\"\n        denominator = (kT * y - Er)**2 + (Gamma / 2)**2\n        # A small constant is added to avoid potential division by zero if Gamma and (kT*y-Er) are both zero.\n        # This is physically unlikely but good for numerical stability.\n        if denominator == 0:\n            return 0.0  # The peak is infinitely narrow and contributes zero to the integral\n        return y * np.exp(-y) * A / denominator\n\n    def R_func(theta, kT):\n        \"\"\"\n        Computes the observable R for a given parameter vector theta and thermal energy kT.\n        \n        Args:\n            theta (np.ndarray): Parameter vector [A, Er, Gamma].\n            kT (float): Thermal energy.\n        \n        Returns:\n            float: The value of the integral R.\n        \"\"\"\n        A, Er, Gamma = theta\n        # All parameters must be physically meaningful, e.g., A > 0, Gamma > 0.\n        if A = 0 or Gamma = 0:\n            return np.nan\n\n        # Use scipy.integrate.quad for the semi-infinite integral.\n        # The integral converges rapidly due to the exp(-y) term.\n        result, _ = quad(R_integrand, 0, np.inf, args=(A, Er, Gamma, kT))\n        return result\n\n    def compute_gradient(func, mu, kT, epsilon=1e-4):\n        \"\"\"\n        Computes the gradient of func using central finite differences.\n        \"\"\"\n        n = len(mu)\n        g = np.zeros(n)\n        h_vec = epsilon * np.maximum(np.abs(mu), 1.0)\n        \n        for i in range(n):\n            h_i = h_vec[i]\n            mu_plus = mu.copy()\n            mu_plus[i] += h_i\n            mu_minus = mu.copy()\n            mu_minus[i] -= h_i\n            g[i] = (func(mu_plus, kT) - func(mu_minus, kT)) / (2 * h_i)\n            \n        return g\n\n    def compute_hessian(func, mu, kT, epsilon=1e-4):\n        \"\"\"\n        Computes the Hessian of func using central finite differences.\n        \"\"\"\n        n = len(mu)\n        H = np.zeros((n, n))\n        h_vec = epsilon * np.maximum(np.abs(mu), 1.0)\n\n        f0 = func(mu, kT)\n\n        # Diagonal elements\n        for i in range(n):\n            h_i = h_vec[i]\n            mu_plus = mu.copy()\n            mu_plus[i] += h_i\n            mu_minus = mu.copy()\n            mu_minus[i] -= h_i\n            f_plus = func(mu_plus, kT)\n            f_minus = func(mu_minus, kT)\n            H[i, i] = (f_plus - 2 * f0 + f_minus) / (h_i**2)\n\n        # Off-diagonal elements\n        for i in range(n):\n            for j in range(i + 1, n):\n                h_i = h_vec[i]\n                h_j = h_vec[j]\n                \n                mu_pp = mu.copy()\n                mu_pp[i] += h_i\n                mu_pp[j] += h_j\n                f_pp = func(mu_pp, kT)\n\n                mu_pm = mu.copy()\n                mu_pm[i] += h_i\n                mu_pm[j] -= h_j\n                f_pm = func(mu_pm, kT)\n\n                mu_mp = mu.copy()\n                mu_mp[i] -= h_i\n                mu_mp[j] += h_j\n                f_mp = func(mu_mp, kT)\n\n                mu_mm = mu.copy()\n                mu_mm[i] -= h_i\n                mu_mm[j] -= h_j\n                f_mm = func(mu_mm, kT)\n                \n                H[i, j] = (f_pp - f_pm - f_mp + f_mm) / (4 * h_i * h_j)\n                H[j, i] = H[i, j]\n                \n        return H\n\n    # Define test cases\n    test_cases = [\n        # Case 1\n        {\n            \"kT\": 0.5,\n            \"mu\": np.array([5.0, 1.5, 0.4]),\n            \"C\": np.diag([0.04, 0.0025, 0.0016])\n        },\n        # Case 2\n        {\n            \"kT\": 0.5,\n            \"mu\": np.array([5.0, 0.7, 0.2]),\n            \"C\": np.array([\n                [0.25, 0, 0],\n                [0, 0.0049, 0.00042],\n                [0, 0.00042, 0.0004]\n            ])\n        },\n        # Case 3\n        {\n            \"kT\": 0.4,\n            \"mu\": np.array([5.0, 0.52, 0.05]),\n            \"C\": np.array([\n                [1.0, 0, 0],\n                [0, 0.0064, 0.00128],\n                [0, 0.00128, 0.0004]\n            ])\n        },\n        # Case 4\n        {\n            \"kT\": 0.6,\n            \"mu\": np.array([5.0, 0.5, 0.02]),\n            \"C\": np.array([\n                [0.01, 0, 0],\n                [0, 2.5e-5, -1.2e-5],\n                [0, -1.2e-5, 1.6e-5]\n            ])\n        }\n    ]\n\n    decisions = []\n    for case in test_cases:\n        kT = case[\"kT\"]\n        mu = case[\"mu\"]\n        C = case[\"C\"]\n\n        # Compute gradient and Hessian\n        g = compute_gradient(R_func, mu, kT)\n        H = compute_hessian(R_func, mu, kT)\n\n        # Compute V1, b2, V2\n        V1 = g.T @ C @ g\n        HC = H @ C\n        b2 = 0.5 * np.trace(HC)\n        V2 = 0.5 * np.trace(HC @ HC)\n\n        # Compute diagnostic metrics\n        if V1 == 0:\n            # This indicates a flat function or numerical instability.\n            # If V1 is zero, any non-zero curvature implies MC is needed.\n            kappa_var = np.inf if V2 > 0 else 0\n            kappa_bias = np.inf if abs(b2) > 0 else 0\n        else:\n            kappa_var = V2 / V1\n            kappa_bias = abs(b2) / np.sqrt(V1)\n            \n        # Apply decision rule\n        if kappa_var = 0.25 and kappa_bias = 0.25:\n            decision = 0  # Higher-order Taylor is warranted\n        else:\n            decision = 1  # Monte Carlo is warranted\n            \n        decisions.append(decision)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, decisions))}]\")\n\nsolve()\n```"
        }
    ]
}