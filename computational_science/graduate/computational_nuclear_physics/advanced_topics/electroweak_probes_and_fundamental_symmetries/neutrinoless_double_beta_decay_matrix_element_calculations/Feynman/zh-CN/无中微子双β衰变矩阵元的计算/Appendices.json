{
    "hands_on_practices": [
        {
            "introduction": "无中微子双贝塔衰变矩阵元的计算，其核心步骤之一是处理中微子交换产生的势。这个势通常在动量空间中定义，并通过傅里叶-贝塞尔变换转换到坐标空间，这涉及到复杂的数值积分。因此，精确且高效地执行这些积分是整个计算的基石。本练习  将指导你实现并检验高斯-勒让德 (Gauss-Legendre) 和高斯-拉盖尔 (Gauss-Laguerre) 等标准正交积分方法，这些是处理此类物理问题时不可或缺的数值工具。",
            "id": "3572950",
            "problem": "您的任务是为中微子势中的动量空间积分实现数值积分，这些积分出现在无中微子双贝塔衰变矩阵元的计算中。中微子势可以表示为涉及球贝塞尔函数和动量转移核的径向变换。您的程序必须为特定的测试积分实现高斯-勒让德积分（GLQ）和高斯-拉盖尔积分（GLagQ），并以解析结果和高分辨率网格积分为基准来评估其准确性。\n\n基本原理：\n- 在闭合近似中，径向中微子势由傅里叶-贝塞尔变换生成，该变换将动量空间核映射到坐标空间，产生以下通用类型的积分：\n$$\nH_K(r) = \\int_0^\\infty dq\\, \\mathcal{K}_K(q)\\, j_0(q r),\n$$\n其中 $j_0(x)$ 是 $0$ 阶球贝塞尔函数，$\\mathcal{K}_K(q)$ 是源于中微子传播子和核形状因子的动量空间核。该表示源于三维中的各向同性傅里叶变换与角度积分的结合。\n- 高斯-勒让德积分用于在有限区间上积分函数，它基于勒让德多项式在 $[-1,1]$ 上的正交性。\n- 高斯-拉盖尔积分用于在 $[0,\\infty)$ 上对带有指数权重的函数进行积分，它利用了拉盖尔多项式在权重为 $e^{-x}$ 时的正交性。\n\n您将实现并测试以下积分，每个积分都以纯数学形式给出，以确保其通用性。本问题中的所有量都是无量纲的；不需要物理单位。\n\n1. 拉盖尔加权的球贝塞尔变换：\n计算\n$$\nI_L(r) = \\int_0^\\infty dq\\, e^{-q}\\, j_0(q r),\n$$\n对于指定的 $r$ 值。该积分存在一个解析解，您必须用它来进行基准测试：\n$$\nI_L(r) = \\frac{\\arctan(r)}{r}.\n$$\n用 $N_L$ 个节点实现高斯-拉盖尔积分来近似 $I_L(r)$，并报告与解析结果的绝对误差。\n\n2. 基于勒让德的有限区间变换：\n计算\n$$\nI_G(r, Q) = \\int_0^{Q} dq\\, q^2\\, j_0(q r),\n$$\n对于指定的 $(r,Q)$ 对。该积分存在一个解析解，您必须用它来进行基准测试：\n$$\nI_G(r, Q) = \\frac{\\sin(Q r) - Q r \\cos(Q r)}{r^3}.\n$$\n在 $[0,Q]$ 上用 $N_G$ 个节点实现高斯-勒让德积分来近似 $I_G(r,Q)$，并报告与解析结果的绝对误差。\n\n3. 类中微子势的正则化积分：\n计算\n$$\nH(r;\\bar{E},\\Lambda) = \\int_0^\\infty dq\\, e^{-q/\\Lambda}\\, \\frac{q}{q+\\bar{E}}\\, j_0(q r),\n$$\n对于指定的三元组 $(r,\\bar{E},\\Lambda)$，其中 $\\bar{E}$ 是一个闭合能标，$\\Lambda$ 是一个正则化标度。该积分通常没有闭式解析解。通过进行变量代换 $q = \\Lambda x$ 以匹配拉盖尔权重 $e^{-x}$，使用高斯-拉盖尔积分对其进行求值，并与使用复合辛普森法则在一个截断区间 $[0,q_{\\max}]$（其中 $q_{\\max} = \\alpha \\Lambda$，$\\alpha$ 是一个大的正数）上的高分辨率网格积分进行基准比较。报告高斯-拉盖尔结果与网格结果之间的绝对差值。\n\n算法与数学要求：\n- 在对形如 $\\int_0^\\infty dx\\, e^{-x}\\, f(x)$ 的积分使用高斯-拉盖尔积分时，使用节点 $x_i$ 和权重 $w_i$ 通过 $\\sum_i w_i f(x_i)$ 来近似该积分。\n- 在对区间 $[a,b]$ 上的积分使用高斯-勒让德积分时，使用节点 $t_i \\in [-1,1]$ 和权重 $w_i$，并通过 $q_i = \\frac{b-a}{2} t_i + \\frac{b+a}{2}$ 和 $W_i = \\frac{b-a}{2} w_i$ 进行变换，使得 $\\int_a^b f(q)\\, dq \\approx \\sum_i W_i f(q_i)$。\n- 对于正则化积分 $H(r;\\bar{E},\\Lambda)$，使用代换 $q=\\Lambda x$ 将其写为\n$$\nH(r;\\bar{E},\\Lambda) = \\Lambda \\int_0^\\infty dx\\, e^{-x}\\, \\frac{\\Lambda x}{\\Lambda x + \\bar{E}}\\, j_0(\\Lambda x\\, r),\n$$\n这种形式适合使用高斯-拉盖尔积分。\n\n测试套件与参数：\n- 高斯-拉盖尔积分使用 $N_L = 64$ 个节点，高斯-勒让德积分使用 $N_G = 128$ 个节点。\n- 对于拉盖尔加权的变换 $I_L(r)$，在 $r \\in \\{10^{-3}, 0.5, 1.0, 5.0, 10.0\\}$ 处求值。\n- 对于有限区间变换 $I_G(r,Q)$，在 $(r,Q) \\in \\{(10^{-3},10^{-2}), (0.1,1.0), (1.0,10.0), (3.0,50.0)\\}$ 处求值。\n- 对于正则化积分 $H(r;\\bar{E},\\Lambda)$，在 $(r,\\bar{E},\\Lambda) \\in \\{(0.5,1.0,1.0), (2.0,0.1,1.0), (5.0,10.0,0.5), (0.1,0.01,2.0)\\}$ 处求值。对于辛普森法则，在 $[0,q_{\\max}]$ 上使用 $\\alpha = 40$ 和一个包含 $N_{\\text{grid}} = 20001$ 个点的均匀高分辨率网格。\n- 所有结果均为无量纲实数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 该列表必须按以下顺序包含 $13$ 个浮点数：\n    1.  按给定顺序，在指定的 $r$ 值下 $I_L(r)$ 的五个绝对误差。\n    2.  按给定顺序，在指定的 $(r,Q)$ 对下 $I_G(r,Q)$ 的四个绝对误差。\n    3.  按给定顺序，在指定的三元组下 $H(r;\\bar{E},\\Lambda)$ 的高斯-拉盖尔积分与高分辨率网格积分之间的四个绝对差值。",
            "solution": "通过实现并评估已有的数值积分技术，我们解决了中微子势中动量空间积分的计算问题。该解决方案分为三个部分，每个部分对应于一个指定的积分。方案的核心依赖于高斯积分，这是一种强大的数值积分方法，能够用相对较少的函数求值次数提供高精度。\n\n高斯积分的基本原理是通过在特定点（称为节点）对被积函数的值进行加权求和来近似积分。对于形式为 $\\int_a^b W(x) f(x) dx$ 的积分，其中 $W(x)$ 是一个权重函数，其近似值由下式给出：\n$$\n\\int_a^b W(x) f(x) dx \\approx \\sum_{i=1}^{N} w_i f(x_i)\n$$\n选择节点 $x_i$ 和权重 $w_i$ 的方式是为了使结果对于最高 $2N-1$ 次的多项式是精确的。节点和权重的具体选择取决于权重函数 $W(x)$ 和积分区间 $[a,b]$，它们共同定义了一个正交多项式族。本实现利用 `numpy` 库进行数值数组操作，并利用 `scipy` 库的特殊函数和高精度积分例程。\n\n1.  **拉盖尔加权的球贝塞尔变换：$I_L(r)$**\n\n    第一个要计算的积分是\n    $$\n    I_L(r) = \\int_0^\\infty dq\\, e^{-q}\\, j_0(q r)\n    $$\n    该积分与高斯-拉盖尔积分（GLagQ）的标准形式 $\\int_0^\\infty e^{-x} f(x) dx$ 相匹配，其中积分变量为 $q=x$，函数为 $f(q) = j_0(q r)$。因此，积分法则是 GLagQ 公式的直接应用：\n    $$\n    I_L(r) \\approx \\sum_{i=1}^{N_L} w_i j_0(q_i r)\n    $$\n    这里，$\\{q_i\\}$ 和 $\\{w_i\\}$ 是用于 GLagQ 的 $N_L = 64$ 个节点和权重，它们通过 `scipy.special.roots_laguerre` 函数获得。零阶球贝塞尔函数 $j_0(x) = \\sin(x)/x$ 使用数值稳定的 `scipy.special.spherical_jn` 函数计算。通过计算与所提供的解析解 $I_L(r) = \\frac{\\arctan(r)}{r}$ 的绝对误差，来对数值结果的准确性进行基准测试。\n\n2.  **基于勒让德的有限区间变换：$I_G(r, Q)$**\n\n    第二个积分定义在一个有限区间 $[0, Q]$ 上：\n    $$\n    I_G(r, Q) = \\int_0^{Q} dq\\, q^2\\, j_0(q r)\n    $$\n    这种形式适合于高斯-勒让德积分（GLQ），该积分定义在标准区间 $[-1,1]$ 上。需要进行线性变量代换，将标准节点 $t_i \\in [-1,1]$ 和权重 $w_i$ 映射到区间 $[0, Q]$。变换如下：\n    $$\n    q_i = \\frac{Q}{2}(t_i + 1), \\quad W_i = \\frac{Q}{2}w_i\n    $$\n    然后，该积分近似为在变换后的节点和权重上的求和：\n    $$\n    I_G(r, Q) \\approx \\sum_{i=1}^{N_G} W_i q_i^2 j_0(q_i r)\n    $$\n    用于 $N_G = 128$ 个点的标准节点 $\\{t_i\\}$ 和权重 $\\{w_i\\}$ 从 `scipy.special.roots_legendre` 获得。为了进行基准测试，将数值结果与解析公式 $I_G(r, Q) = \\frac{\\sin(Q r) - Q r \\cos(Q r)}{r^3}$ 进行比较。一个关键的实现细节是处理当参数 $x = Qr$ 很小时的解析公式。直接计算可能会遭受灾难性抵消。为确保高精度，当 $|Qr|$ 很小时，使用泰勒级数展开 $\\frac{\\sin(x) - x\\cos(x)}{x^3} = \\frac{1}{3} - \\frac{x^2}{30} + O(x^4)$。\n\n3.  **类中微子势的正则化积分：$H(r;\\bar{E},\\Lambda)$**\n\n    第三个积分更为复杂，且缺乏简单的解析解：\n    $$\n    H(r;\\bar{E},\\Lambda) = \\int_0^\\infty dq\\, e^{-q/\\Lambda}\\, \\frac{q}{q+\\bar{E}}\\, j_0(q r)\n    $$\n    该积分使用两种不同的方法进行求值，并对它们的结果进行比较。\n\n    **a) 高斯-拉盖尔积分：**\n    为了应用 GLagQ，指数项 $e^{-q/\\Lambda}$ 必须转换为标准权重 $e^{-x}$。这通过代换 $q = \\Lambda x$ 实现，从而得到 $dq = \\Lambda dx$。积分变换为：\n    $$\n    H(r;\\bar{E},\\Lambda) = \\Lambda \\int_0^\\infty dx\\, e^{-x}\\, \\left(\\frac{\\Lambda x}{\\Lambda x + \\bar{E}}\\right)\\, j_0(\\Lambda x\\, r)\n    $$\n    这现在是标准的 GLagQ 形式，被积函数为 $f(x) = \\left(\\frac{\\Lambda x}{\\Lambda x + \\bar{E}}\\right)\\, j_0(\\Lambda x\\, r)$。该积分近似为 $\\Lambda \\sum_i w_i f(x_i)$，使用 $N_L=64$ 个 GLagQ 节点和权重。\n\n    **b) 高分辨率网格积分（基准）：**\n    作为基准，该积分使用复合辛普森法则进行计算，这是一种在网格上进行数值积分的稳健方法。无限积分区间被截断为有限区间 $[0, q_{\\max}]$，其中 $q_{\\max} = \\alpha \\Lambda$，$\\alpha=40$ 被选得足够大，以使由于指数因子 $e^{-q/\\Lambda}$ 的存在，尾部的贡献可以忽略不计。在此区间上构建一个包含 $N_{\\text{grid}} = 20001$ 个点的均匀网格。在每个网格点上计算原始被积函数，并使用 `scipy.integrate.simpson` 函数从这些离散值计算积分。\n\n    此部分最终报告的值是 GLagQ 方法的结果与辛普森法则基准之间的绝对差值，它为这种类型的正则化积分提供了 GLagQ 方法准确性的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, integrate\n\ndef solve():\n    \"\"\"\n    Main function to perform all calculations and print the final result.\n    \"\"\"\n\n    # --- Helper Functions ---\n\n    def j0(x):\n        \"\"\"Numerically stable spherical Bessel function of order 0, j_0(x) = sin(x)/x.\"\"\"\n        return special.spherical_jn(0, x)\n\n    # --- Part 1: Laguerre-weighted spherical Bessel transform ---\n\n    def calculate_IL(r, N_L):\n        \"\"\"\n        Computes I_L(r) = integral(0, inf) dq exp(-q) j_0(q*r) using Gauss-Laguerre quadrature\n        and compares it to the analytic result arctan(r)/r.\n        \"\"\"\n        # Get Gauss-Laguerre nodes and weights for N_L points\n        nodes, weights = special.roots_laguerre(N_L)\n        \n        # The integrand for GLagQ is f(q) = j_0(q*r).\n        # The approximation is sum(w_i * f(q_i)).\n        integrand_values = j0(nodes * r)\n        numerical_result = np.sum(weights * integrand_values)\n        \n        # Analytic result: arctan(r)/r. For r=0, the limit is 1.\n        if r == 0.0:\n            analytic_result = 1.0\n        else:\n            analytic_result = np.arctan(r) / r\n            \n        return np.abs(numerical_result - analytic_result)\n\n    # --- Part 2: Legendre-based finite-interval transform ---\n\n    def calculate_IG(r, Q, N_G):\n        \"\"\"\n        Computes I_G(r, Q) = integral(0, Q) dq q^2 j_0(q*r) using Gauss-Legendre quadrature\n        and compares it to the analytic result (sin(Qr)-Qr*cos(Qr))/r^3.\n        \"\"\"\n        # Get standard Gauss-Legendre nodes and weights on [-1, 1]\n        t_nodes, t_weights = special.roots_legendre(N_G)\n        \n        # Transform nodes and weights for the interval [0, Q]\n        q_nodes = 0.5 * Q * (t_nodes + 1.0)\n        W_weights = 0.5 * Q * t_weights\n        \n        # Integrand f(q) = q^2 * j_0(q*r)\n        integrand_values = q_nodes**2 * j0(q_nodes * r)\n        numerical_result = np.sum(W_weights * integrand_values)\n        \n        # Analytic result. A Taylor expansion is used for small |Qr| to avoid catastrophic cancellation.\n        # f(x) = (sin(x)-x*cos(x))/x^3 = 1/3 - x^2/30 + O(x^4)\n        x = Q * r\n        if np.abs(x)  1e-4:\n            analytic_result = (Q**3 / 3.0) * (1.0 - x**2 / 10.0) # This is (Q^3/3 - Q^5 r^2 / 30)\n        else:\n            analytic_result = (np.sin(x) - x * np.cos(x)) / r**3\n            \n        return np.abs(numerical_result - analytic_result)\n\n    #--- Part 3: Neutrino-potential-like regulated integral comparison ---\n\n    def calculate_H_glag(r, E_bar, Lambda, N_L):\n        \"\"\"\n        Computes H(r; E_bar, Lambda) with Gauss-Laguerre quadrature after a change of variables q = Lambda*x.\n        \"\"\"\n        # Get Gauss-Laguerre nodes and weights\n        x_nodes, weights = special.roots_laguerre(N_L)\n        \n        # Integrand for GLagQ f(x) = (Lambda*x)/(Lambda*x + E_bar) * j_0(Lambda*x*r)\n        # Total integral is Lambda * sum(w_i * f(x_i))\n        numerator = Lambda * x_nodes\n        denominator = Lambda * x_nodes + E_bar\n        j0_arg = Lambda * x_nodes * r\n        \n        integrand_values = (numerator / denominator) * j0(j0_arg)\n        \n        numerical_result = Lambda * np.sum(weights * integrand_values)\n        return numerical_result\n\n    def calculate_H_simpson(r, E_bar, Lambda, alpha, N_grid):\n        \"\"\"\n        Computes H(r; E_bar, Lambda) using Simpson's rule on a high-resolution grid as a benchmark.\n        \"\"\"\n        # Define integration range [0, q_max] and grid\n        q_max = alpha * Lambda\n        q_grid = np.linspace(0, q_max, N_grid)\n        \n        # The original integrand g(q) = exp(-q/Lambda) * (q/(q+E_bar)) * j_0(q*r)\n        # Since E_bar > 0 in test cases, direct evaluation is safe. The term with q is 0 at q=0.\n        integrand_values = np.exp(-q_grid / Lambda) * (q_grid / (q_grid + E_bar)) * j0(q_grid * r)\n\n        # Compute integral using Simpson's rule\n        numerical_result = integrate.simpson(integrand_values, q_grid)\n        return numerical_result\n\n    # --- Main Execution Logic ---\n\n    # Define parameters from problem statement\n    N_L = 64\n    N_G = 128\n    alpha = 40.0\n    N_grid = 20001\n    \n    # Define test cases\n    test_cases_L = [1e-3, 0.5, 1.0, 5.0, 10.0]\n    test_cases_G = [(1e-3, 1e-2), (0.1, 1.0), (1.0, 10.0), (3.0, 50.0)]\n    test_cases_H = [(0.5, 1.0, 1.0), (2.0, 0.1, 1.0), (5.0, 10.0, 0.5), (0.1, 0.01, 2.0)]\n    \n    results = []\n    \n    # Run Part 1\n    for r_val in test_cases_L:\n        error = calculate_IL(r_val, N_L)\n        results.append(error)\n        \n    # Run Part 2\n    for r_val, Q_val in test_cases_G:\n        error = calculate_IG(r_val, Q_val, N_G)\n        results.append(error)\n        \n    # Run Part 3\n    for r_val, E_bar_val, Lambda_val in test_cases_H:\n        res_glag = calculate_H_glag(r_val, E_bar_val, Lambda_val, N_L)\n        res_simpson = calculate_H_simpson(r_val, E_bar_val, Lambda_val, alpha, N_grid)\n        diff = np.abs(res_glag - res_simpson)\n        results.append(diff)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在处理对中间核态的求和时，闭合近似 (closure approximation) 是一种广泛使用且极为重要的简化方法，它用一个平均能量代替了所有中间态的能量。虽然这种近似大大简化了计算，但理解其引入的偏差和适用范围至关重要。本练习  构建了一个简化的模型，让你能够分别在闭合近似和非闭合方案下计算矩阵元，通过直接比较两者结果，你将深入理解闭合近似的物理本质及其对最终结果的影响。",
            "id": "3572951",
            "problem": "考虑一个简化但科学上可靠的无中微子双贝塔衰变（NDBD）核矩阵元计算模型。该模型在一个非闭合方案中分离出总角动量和宇称为 $J^\\pi = 0^+$ 和 $J^\\pi = 1^+$ 的中间态的贡献，并将其与闭合近似进行比较。目标是设计并实现一个程序，基于第一性原理（振幅的线性、中间态的可加性，以及通过能量分母对中间态激发能的依赖性）来计算和比较这些贡献。\n\n基本基础和模型设置：\n- 在二阶弱过程中，对中间态的求和源于时间排序微扰理论，能量分母编码了虚态的传播。在非闭合方案中，每个具有激发能的中间态都以其自身的能量分母作出贡献。在闭合近似（CA）中，能量分母被一个单一的有效闭合能量所近似，这消除了对单个中间态能量的显式依赖，同时保留了对各态的可加性。\n- 我们将多体结构因子分解为约化的无量纲强度 $s_k^{(J)}$，它编码了到多极矩为 $J$ 的中间态 $k$ 的径向和自旋-同位旋交叠。动量转移的依赖性通过一个中微子势积分来编码，此处以无量纲形式进行近似，以消除单位依赖性，同时保留对能量分母的定性函数依赖关系。\n\n定义：\n- 令 $x$ 表示一个无量纲动量变量，令 $d$ 表示一个无量纲能量分母。两者都通过一个公共正尺度 $\\Lambda$ 对物理动量 $q$ 和能量分母 $\\Delta$ 进行缩放来定义，即 $x = q/\\Lambda$ 和 $d = \\Delta/\\Lambda$。上限 $x_{\\max} = q_{\\max}/\\Lambda$ 控制积分的数值范围。\n- 定义一个偶极型调节子 $F(x) = \\left(1 + x^2\\right)^{-2}$ 来模拟有限尺寸和形状因子效应。定义无量纲中微子势积分\n$$\nI(d) = \\int_{0}^{x_{\\max}} \\frac{x^2}{x + d}\\,F(x)\\,dx = \\int_{0}^{x_{\\max}} \\frac{x^2}{(x+d)\\left(1+x^2\\right)^2}\\,dx,\n$$\n其中 $d  0$ 且 $x_{\\max}  0$。对于任何正的 $d$ 和 $x_{\\max}$，该积分都是有限的。\n- 两个多极的约化非闭合贡献定义为\n$$\nM_{0^+}^{\\mathrm{non}} = g_V^2 \\sum_{k=1}^{N_{0^+}} s_k^{(0^+)}\\,I\\!\\left(d_k^{(0^+)}\\right),\\quad\nM_{1^+}^{\\mathrm{non}} = g_A^2 \\sum_{k=1}^{N_{1^+}} s_k^{(1^+)}\\,I\\!\\left(d_k^{(1^+)}\\right),\n$$\n其中 $g_V$ 和 $g_A$ 分别是矢量和轴矢量耦合常数， $d_k^{(J)}$ 是对应于多极矩为 $J$ 的第 $k$ 个中间态的无量纲分母。\n- 在闭合近似中，\n$$\nM_{0^+}^{\\mathrm{cl}} = g_V^2\\left(\\sum_{k=1}^{N_{0^+}} s_k^{(0^+)}\\right) I\\!\\left(\\bar{d}_{0^+}\\right),\\quad\nM_{1^+}^{\\mathrm{cl}} = g_A^2\\left(\\sum_{k=1}^{N_{1^+}} s_k^{(1^+)}\\right) I\\!\\left(\\bar{d}_{1^+}\\right),\n$$\n其中 $\\bar{d}_{J}$ 是为多极矩 $J$ 选择的有效闭合分母。\n\n分母的构建：\n- 对于多极矩为 $J$ 的每个中间态 $k$，通过 $d_k^{(J)} = \\left(E_0 + \\epsilon_k^{(J)}\\right)/\\Lambda$ 定义无量纲分母，其中 $E_0$ 是一个考虑了平均运动学的偏移量，$\\epsilon_k^{(J)}$ 是中间态的激发能。闭合分母由 $\\bar{d}_{J} = \\bar{E}_J/\\Lambda$ 定义。\n\n任务：\n- 实现一个程序，对下面列出的每个测试用例，数值计算 $I(d)$ 并计算 $M_{0^+}^{\\mathrm{non}}$、$M_{1^+}^{\\mathrm{non}}$、$M_{0^+}^{\\mathrm{cl}}$ 和 $M_{1^+}^{\\mathrm{cl}}$。\n- 对每个测试用例，生成三个浮点数：\n  - $\\Delta M_{0^+} = M_{0^+}^{\\mathrm{non}} - M_{0^+}^{\\mathrm{cl}}$，\n  - $\\Delta M_{1^+} = M_{1^+}^{\\mathrm{non}} - M_{1^+}^{\\mathrm{cl}}$，\n  - $\\Delta M_{\\mathrm{tot}} = \\left(M_{0^+}^{\\mathrm{non}} + M_{1^+}^{\\mathrm{non}}\\right) - \\left(M_{0^+}^{\\mathrm{cl}} + M_{1^+}^{\\mathrm{cl}}\\right)$。\n- 所有输出都应报告为无量纲数。\n\n数值积分要求：\n- 使用可靠的数值求积方法来计算每个所需的 $d  0$ 对应的 $I(d)$，至少达到适度的绝对容差。由于 $d  0$ 且 $x \\in [0,x_{\\max}]$（其中 $x_{\\max}  0$），被积函数在积分区间上没有奇点。\n\n所有测试中使用的常量：\n- 矢量耦合 $g_V = 1.0$（无量纲）。\n- 轴矢量耦合 $g_A = 1.27$（无量纲）。\n- 尺度 $\\Lambda = 850.0$（单位与能量相同）。\n- 最大动量 $q_{\\max} = 2000.0$（单位与能量相同），因此 $x_{\\max} = q_{\\max}/\\Lambda$。\n- 输出是无量纲的。\n\n测试套件：\n- 测试用例 1（具有混合符号和非简并分母的一般情况）：\n  - 偏移量 $E_0 = 10.0$。\n  - 对于 $J^\\pi = 0^+$：三个态，强度 $s^{(0^+)} = \\{0.6,\\,0.3,\\,-0.1\\}$，激发能 $\\epsilon^{(0^+)} = \\{2.0,\\,5.0,\\,8.0\\}$。闭合能量 $\\bar{E}_{0^+} = 12.0$。\n  - 对于 $J^\\pi = 1^+$：四个态，强度 $s^{(1^+)} = \\{0.5,\\,-0.2,\\,0.4,\\,0.1\\}$，激发能 $\\epsilon^{(1^+)} = \\{1.0,\\,3.0,\\,6.0,\\,9.0\\}$。闭合能量 $\\bar{E}_{1^+} = 13.0$。\n- 测试用例 2（如果使用相同的闭合能量，简并分母会产生精确的闭合等效性）：\n  - 偏移量 $E_0 = 10.0$。\n  - 对于 $J^\\pi = 0^+$：四个态，强度 $s^{(0^+)} = \\{0.3,\\,0.4,\\,-0.1,\\,0.2\\}$，激发能 $\\epsilon^{(0^+)} = \\{4.0,\\,4.0,\\,4.0,\\,4.0\\}$。闭合能量 $\\bar{E}_{0^+} = 14.0$。\n  - 对于 $J^\\pi = 1^+$：五个态，强度 $s^{(1^+)} = \\{0.5,\\,-0.2,\\,0.2,\\,0.1,\\,0.3\\}$，激发能 $\\epsilon^{(1^+)} = \\{4.0,\\,4.0,\\,4.0,\\,4.0,\\,4.0\\}$。闭合能量 $\\bar{E}_{1^+} = 14.0$。\n- 测试用例 3（强度和为零使闭合值消失，但非闭合值通常不为零）：\n  - 偏移量 $E_0 = 10.0$。\n  - 对于 $J^\\pi = 0^+$：两个态，强度 $s^{(0^+)} = \\{1.0,\\,-1.0\\}$，激发能 $\\epsilon^{(0^+)} = \\{2.0,\\,10.0\\}$。闭合能量 $\\bar{E}_{0^+} = 12.0$。\n  - 对于 $J^\\pi = 1^+$：四个态，强度 $s^{(1^+)} = \\{0.8,\\,-0.8,\\,0.5,\\,-0.5\\}$，激发能 $\\epsilon^{(1^+)} = \\{1.0,\\,4.0,\\,7.0,\\,10.0\\}$。闭合能量 $\\bar{E}_{1^+} = 11.0$。\n\n角度单位不适用，并且由于模型被构造成无量纲的，输出中不报告任何物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的所有结果，形式为单个用方括号括起来的逗号分隔列表。顺序如下：\n  - 第一个测试用例：$\\Delta M_{0^+}$、$\\Delta M_{1^+}$、$\\Delta M_{\\mathrm{tot}}$，\n  - 第二个测试用例：$\\Delta M_{0^+}$、$\\Delta M_{1^+}$、$\\Delta M_{\\mathrm{tot}}$，\n  - 第三个测试用例：$\\Delta M_{0^+}$、$\\Delta M_{1^+}$、$\\Delta M_{\\mathrm{tot}}$。\n- 例如，程序必须打印一行形式为 $[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5,\\text{v}_6,\\text{v}_7,\\text{v}_8,\\text{v}_9]$ 的内容，其中每个 $\\text{v}_i$ 是一个浮点数。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、提法明确且内容独立的。它提出了一个简化但可靠的计算模型，用于评估和比较基于非闭合方案和闭合近似的无中微子双贝塔衰变核矩阵元。所有参数和定义均已提供，任务是一个清晰、可形式化的计算过程。\n\n解决方案首先实现核心数学对象，然后将它们组装成一个完整的算法来处理指定的测试用例。\n\n基本的计算核心是无量纲中微子势积分，定义为：\n$$\nI(d) = \\int_{0}^{x_{\\max}} \\frac{x^2}{(x+d)\\left(1+x^2\\right)^2}\\,dx\n$$\n其中 $d  0$ 是无量纲能量分母，$x_{\\max}  0$ 是无量纲动量截断。对于 $x \\in [0, x_{\\max}]$ 和 $d  0$，被积函数是一个光滑、非奇异的有理函数。该积分将使用稳健的求积算法进行数值计算。`scipy.integrate.quad` 函数实现了一种自适应求积方案，是实现此目的的绝佳选择，可提供高精度。定义积分范围的常量是 $q_{\\max} = 2000.0$ 和 $\\Lambda = 850.0$，得出的积分上限为 $x_{\\max} = q_{\\max}/\\Lambda \\approx 2.3529$。\n\n总体算法的结构是处理每个测试用例，通过计算所需的多极矩 $J^\\pi=0^+$ 和 $J^\\pi=1^+$ 的矩阵元。对于一个通用的多极矩 $J$，非闭合矩阵元 $M_J^{\\mathrm{non}}$ 通过对每个中间态 $k$ 的贡献求和来计算：\n$$\nM_{J}^{\\mathrm{non}} = g_J^2 \\sum_{k=1}^{N_J} s_k^{(J)}\\,I\\!\\left(d_k^{(J)}\\right)\n$$\n此处，$g_J$ 是耦合常数（对于 $J=0^+$，$g_V=1.0$；对于 $J=1^+$，$g_A=1.27$），$s_k^{(J)}$ 是第 $k$ 个态的约化强度，而 $d_k^{(J)}$ 是其无量纲能量分母。每个态的分母由给定的偏移量 $E_0$ 和激发能 $\\epsilon_k^{(J)}$ 计算得出：\n$$\nd_k^{(J)} = \\frac{E_0 + \\epsilon_k^{(J)}}{\\Lambda}\n$$\n计算过程包括：对于给定的多极矩，遍历中间态列表，为每个态计算 $d_k^{(J)}$，数值计算 $I(d_k^{(J)})$，乘以相应的强度 $s_k^{(J)}$，并累加求和。然后将此和乘以相应耦合常数的平方进行缩放。\n\n相应的闭合近似矩阵元 $M_J^{\\mathrm{cl}}$ 的计算方法是：首先对所有强度求和，然后乘以在单个有效闭合分母 $\\bar{d}_J$ 处计算的势积分：\n$$\nM_{J}^{\\mathrm{cl}} = g_J^2\\left(\\sum_{k=1}^{N_J} s_k^{(J)}\\right) I\\!\\left(\\bar{d}_{J}\\right)\n$$\n闭合分母 $\\bar{d}_J$ 由给定的有效闭合能量 $\\bar{E}_J$ 确定：\n$$\n\\bar{d}_{J} = \\frac{\\bar{E}_J}{\\Lambda}\n$$\n实现将首先计算总强度和 $\\sum_k s_k^{(J)}$。如果此和非零，则将计算 $\\bar{d}_J$，评估 $I(\\bar{d}_J)$，然后计算 $M_J^{\\mathrm{cl}}$。如果强度和为零，则 $M_J^{\\mathrm{cl}}$ 必然为零。\n\n对于每个测试用例和每个多极矩（$J=0^+, 1^+$），我们计算差值 $\\Delta M_J = M_J^{\\mathrm{non}} - M_J^{\\mathrm{cl}}$。最后，总差值计算为各个差值之和：$\\Delta M_{\\mathrm{tot}} = \\Delta M_{0^+} + \\Delta M_{1^+}$。程序将被构造成处理一系列测试用例，每个用例包含参数（$E_0$、强度 $s_k$ 和激发能 $\\epsilon_k$ 的列表，以及闭合能量 $\\bar{E}_J$）。对于每个用例，它将执行上述逻辑以找到 $(\\Delta M_{0^+}, \\Delta M_{1^+}, \\Delta M_{\\mathrm{tot}})$，并将所有测试用例的这些三元组收集到一个单一的扁平列表中。该列表将被格式化为所需的字符串输出。实现将使用 `NumPy` 进行高效的数组操作，并使用 `SciPy` 进行数值积分，同时遵循指定的执行环境。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the neutrinoless double beta decay matrix element problem.\n    \"\"\"\n    # Define global constants given in the problem statement.\n    G_V = 1.0\n    G_A = 1.27\n    LAMBDA = 850.0\n    Q_MAX = 2000.0\n    X_MAX = Q_MAX / LAMBDA\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"E0\": 10.0,\n            \"0+\": {\n                \"s\": [0.6, 0.3, -0.1],\n                \"eps\": [2.0, 5.0, 8.0],\n                \"E_bar\": 12.0\n            },\n            \"1+\": {\n                \"s\": [0.5, -0.2, 0.4, 0.1],\n                \"eps\": [1.0, 3.0, 6.0, 9.0],\n                \"E_bar\": 13.0\n            }\n        },\n        {\n            # Test case 2 (degenerate denominators)\n            \"E0\": 10.0,\n            \"0+\": {\n                \"s\": [0.3, 0.4, -0.1, 0.2],\n                \"eps\": [4.0, 4.0, 4.0, 4.0],\n                \"E_bar\": 14.0\n            },\n            \"1+\": {\n                \"s\": [0.5, -0.2, 0.2, 0.1, 0.3],\n                \"eps\": [4.0, 4.0, 4.0, 4.0, 4.0],\n                \"E_bar\": 14.0\n            }\n        },\n        {\n            # Test case 3 (zero-sum strengths)\n            \"E0\": 10.0,\n            \"0+\": {\n                \"s\": [1.0, -1.0],\n                \"eps\": [2.0, 10.0],\n                \"E_bar\": 12.0\n            },\n            \"1+\": {\n                \"s\": [0.8, -0.8, 0.5, -0.5],\n                \"eps\": [1.0, 4.0, 7.0, 10.0],\n                \"E_bar\": 11.0\n            }\n        }\n    ]\n\n    # Memoization cache for the integral function to avoid re-computation.\n    integral_cache = {}\n\n    def integrand(x, d):\n        \"\"\"The integrand for the neutrino potential integral I(d).\"\"\"\n        return (x**2) / ((x + d) * (1 + x**2)**2)\n\n    def I(d):\n        \"\"\"Numerically evaluates the neutrino potential integral I(d).\"\"\"\n        if d in integral_cache:\n            return integral_cache[d]\n        \n        # Using quad for high-precision numerical integration.\n        # The absolute error tolerance ensures sufficient accuracy.\n        result, _ = quad(integrand, 0, X_MAX, args=(d,), epsabs=1e-12)\n        integral_cache[d] = result\n        return result\n\n    def calculate_matrix_elements(E0, multipole_data, g_coupling):\n        \"\"\"\n        Calculates non-closure and closure matrix elements for a single multipole.\n        \"\"\"\n        strengths = np.array(multipole_data[\"s\"])\n        excitations = np.array(multipole_data[\"eps\"])\n        closure_energy = multipole_data[\"E_bar\"]\n\n        # Non-closure calculation\n        m_non = 0.0\n        for s_k, eps_k in zip(strengths, excitations):\n            d_k = (E0 + eps_k) / LAMBDA\n            m_non += s_k * I(d_k)\n        \n        m_non *= g_coupling**2\n\n        # Closure calculation\n        sum_s = np.sum(strengths)\n        d_bar = closure_energy / LAMBDA\n        m_cl = sum_s * I(d_bar)\n        m_cl *= g_coupling**2\n        \n        return m_non, m_cl\n\n    results = []\n    for case in test_cases:\n        # Process J^pi = 0+ multipole\n        m_non_0, m_cl_0 = calculate_matrix_elements(case[\"E0\"], case[\"0+\"], G_V)\n        delta_m_0 = m_non_0 - m_cl_0\n        \n        # Process J^pi = 1+ multipole\n        m_non_1, m_cl_1 = calculate_matrix_elements(case[\"E0\"], case[\"1+\"], G_A)\n        delta_m_1 = m_non_1 - m_cl_1\n        \n        # Total difference\n        delta_m_tot = delta_m_0 + delta_m_1\n        \n        results.extend([delta_m_0, delta_m_1, delta_m_tot])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何大规模数值计算的结果都不可避免地受到模型空间截断、基矢参数选择和数值方法近似等因素带来的不确定性。对这些不确定性的来源进行系统性分析和量化，是确保计算结果可靠性的关键环节。本练习  将引导你针对一个基于谐振子基的模型，系统地研究矩阵元 $M^{0\\nu}$ 如何随模型空间大小、基矢参数和径向积分格点数的变化而收敛，并最终构建一个完整的误差预算。这项实践将锻炼你进行严谨的收敛性测试和不确定度分析的能力，这是任何严肃的计算物理研究都必须具备的核心技能。",
            "id": "3572952",
            "problem": "您的任务是实现一项关于无中微子双贝塔衰变核矩阵元（记为 $M^{0\\nu}$）的自包含数值研究，以评估其相对于三个独立数值控制参数的系统收敛性，并报告一份误差预算。该研究必须在一个简化但科学上合理的模型下，使用基于第一性原理和物理动机的定义来进行。\n\n从计算核物理中以下这些基本且经过充分检验的基础出发：\n\n- 在闭合近似下，无量纲核矩阵元 $M^{0\\nu}$ 可以通过中微子交换势与单粒子径向密度耦合的径向积分来构建。对于球谐振子 (HO) 基，单粒子径向波函数为\n$$\nR_{nl}(r) = \\mathcal{N}_{nl} \\left(\\frac{r}{b}\\right)^l e^{-\\frac{r^2}{2b^2}} L_{n}^{l+\\frac{1}{2}}\\!\\left(\\frac{r^2}{b^2}\\right),\n$$\n其中 $n$ 是径向量子数，$l$ 是轨道角动量，$b$ 是谐振子长度，$L_{n}^{\\alpha}(x)$ 是广义拉盖尔多项式，而 $\\mathcal{N}_{nl}$ 是归一化因子，其选择需满足 $\\int_{0}^{\\infty} r^2 \\left|R_{nl}(r)\\right|^2 dr = 1$。归一化因子为\n$$\n\\mathcal{N}_{nl} = \\sqrt{\\frac{2\\,\\Gamma(n+1)}{b^3\\,\\Gamma\\!\\left(n + l + \\frac{3}{2}\\right)}},\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。谐振子长度为\n$$\nb = \\frac{\\hbar}{\\sqrt{m_N \\hbar\\omega}},\n$$\n以自然核物理单位表示，其中 $\\hbar$ 的单位是 $\\mathrm{MeV}\\cdot\\mathrm{fm}$，$m_N$ 的单位是 $\\mathrm{MeV}$，$\\hbar\\omega$ 的单位是 $\\mathrm{MeV}$。\n\n- 一种广泛使用的、能产生无量纲矩阵元的屏蔽中微子势近似是\n$$\nH(r) = \\frac{R\\,e^{-\\mu r}}{r},\n$$\n其中 $R = r_0 A^{1/3}$ 是核半径，$r_0$ 是一个常数，$A$ 是质量数，$\\mu$ 是一个逆长度屏蔽参数。当乘以无量纲密度因子 $r^2 \\left|R_{nl}(r)\\right|^2$ 时，被积函数在 $r=0$ 处是可积的。\n\n- 通过谐振子主壳层量子数 $K = 2n + l$ 来定义模型空间截断，并包含直到 $K \\leq N_{\\max}$ 的所有态。为模拟由对关联驱动的占据数和简并度，用以下权重对每个态进行加权\n$$\nw_{nl} = D_l\\,g_{nl}, \\quad D_l = 2l + 1, \\quad g_{nl} = g_0\\,e^{-\\alpha (2n + l)},\n$$\n其中 $D_l$ 是磁简并度，$g_0$ 和 $\\alpha$ 是正常数。\n\n根据这些定义，构建\n$$\nI_{nl} = \\int_{0}^{r_{\\max}} r^2 \\left[R_{nl}(r)\\right]^2 H(r)\\,dr,\n$$\n以及\n$$\nM^{0\\nu}(N_{\\max}, \\hbar\\omega, N_r) = \\sum_{\\substack{l \\ge 0 \\\\ 2n + l \\le N_{\\max}}} \\sum_{n \\ge 0} w_{nl}\\,I_{nl},\n$$\n其中径向积分需要在 $[0, r_{\\max}]$ 区间上使用包含 $N_r$ 个点的均匀网格，通过辛普森法则进行数值计算，并且 $r_{\\max} = \\beta b$，其中 $\\beta$ 是一个为每个测试用例设定的无量纲因子。所有长度必须以飞米 ($\\mathrm{fm}$) 为单位处理，所有能量以兆电子伏 ($\\mathrm{MeV}$) 为单位，最终的 $M^{0\\nu}$ 是无量纲的。使用 $\\hbar = 197.326\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$，$m_N = 939.0\\,\\mathrm{MeV}$ 以及 $r_0 = 1.2\\,\\mathrm{fm}$。\n\n按如下方式执行系统性收敛测试：\n\n1. 模型空间大小敏感性：在一个给定集合中改变 $N_{\\max}$，并将模型空间截断误差定义为，在中心振荡器频率和最精细网格下计算得到的、最大的两个 $N_{\\max}$ 值对应的 $M^{0\\nu}$ 之间的绝对差。\n2. 振荡器频率敏感性：在一个给定集合中改变 $\\hbar\\omega$，并将频率误差定义为，在最大 $N_{\\max}$ 和最精细网格下计算得到的、该集合中 $M^{0\\nu}$ 值范围（最大值减最小值）的一半。\n3. 径向网格敏感性：在一个给定集合中改变 $N_r$，并将网格误差定义为，在最大 $N_{\\max}$ 和中心 $\\hbar\\omega$ 下计算得到的、最大的两个 $N_r$ 值对应的 $M^{0\\nu}$ 之间的绝对差。\n\n将中心值定义为在最大 $N_{\\max}$、中心 $\\hbar\\omega$（给定集合的中位数；如果只给出一个值，则使用该值）和最精细网格 $N_r$ 下计算的 $M^{0\\nu}$。总误差必须是这三个分量误差的平方和的平方根。\n\n使用以下固定常数实现上述计算：$g_0 = 1$ 和 $\\alpha = 0.4$，并使用每个测试用例提供的屏蔽中微子参数 $\\mu$。如果辛普森法则要求奇数个采样点，则在内部将 $N_r$ 调整为最接近的较大奇数，同时保持测试用例的意图。在 $r=0$ 处，通过其极限行为来评估被积函数，并通过在网格原点处将被积函数取为 $0$ 来确保数值稳定性。\n\n您的程序必须为以下测试套件执行该研究：\n\n- 测试用例 1：$A = 76$，$\\mu = 0.5\\,\\mathrm{fm}^{-1}$，$N_{\\max} \\in \\{4, 6, 8\\}$，$\\hbar\\omega \\in \\{10, 12, 14\\}\\,\\mathrm{MeV}$，$N_r \\in \\{200, 400\\}$，$\\beta = 8.0$。\n- 测试用例 2：$A = 136$，$\\mu = 0.45\\,\\mathrm{fm}^{-1}$，$N_{\\max} \\in \\{6, 8, 10\\}$，$\\hbar\\omega \\in \\{8, 10, 12\\}\\,\\mathrm{MeV}$，$N_r \\in \\{300, 600\\}$，$\\beta = 9.0$。\n- 测试用例 3：$A = 48$，$\\mu = 0.5\\,\\mathrm{fm}^{-1}$，$N_{\\max} \\in \\{2, 4\\}$，$\\hbar\\omega \\in \\{12\\}\\,\\mathrm{MeV}$，$N_r \\in \\{50, 100\\}$，$\\beta = 6.0$。\n\n对于每个测试用例，计算并返回一个列表 $[M_{\\mathrm{central}}, \\Delta_{\\mathrm{model}}, \\Delta_{\\omega}, \\Delta_{\\mathrm{mesh}}, \\Delta_{\\mathrm{total}}]$，其中所有条目都是无单位的无量纲十进制浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个这样的列表，并保持顺序。例如，输出必须类似于 $[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],[z_1,z_2,z_3,z_4,z_5]]$，其中 $x_i$、$y_i$ 和 $z_i$ 是为三个测试用例计算出的浮点数。",
            "solution": "该问题要求在一个简化但有物理基础的模型内，实现一个数值研究来计算无中微子双贝塔衰变核矩阵元（记为 $M^{0\\nu}$）。该研究涉及评估 $M^{0\\nu}$ 相对于三个关键数值参数的收敛性：模型空间大小（$N_{\\max}$）、谐振子频率（$\\hbar\\omega$）和径向积分网格大小（$N_r$）。\n\n方法论途径分为两个主要部分：首先是用于在给定一组物理和数值参数下计算 $M^{0\\nu}$ 的核心算法；其次是一个用于系统地改变这些参数以计算中心值和误差预算的框架。\n\n**1. 核矩阵元 $M^{0\\nu}$ 的核心计算**\n\n$M^{0\\nu}(N_{\\max}, \\hbar\\omega, N_r)$ 的计算在一个单一、可重用的函数中实现。该函数封装了问题描述中规定的物理和数值方法。对于给定的一组输入（$A, \\mu, N_{\\max}, \\hbar\\omega, N_r, \\beta$），其过程如下：\n\n- **参数推导**：首先，从输入计算相关的物理参数。谐振子长度 $b$ 由振荡器能量 $\\hbar\\omega$ 和核子质量 $m_N$ 使用公式 $b = \\hbar/\\sqrt{m_N \\hbar\\omega}$ 确定。核半径 $R$ 计算为 $R = r_0 A^{1/3}$。然后将径向积分的上限设置为 $r_{\\max} = \\beta b$。\n\n- **数值网格设置**：为数值积分建立一个均匀的径向网格，范围从 $r=0$ 到 $r=r_{\\max}$。该网格包含 $N_r'$ 个点，其中 $N_r'$ 被调整为大于或等于输入 $N_r$ 的最小奇数。此调整确保了用于数值积分的辛普森法则的有效性，该法则要求偶数个区间。\n\n- **对态求和**：总矩阵元 $M^{0\\nu}$ 是对所有允许的单粒子态 $(n,l)$ 贡献的总和，其中 $n$ 是径向量子数，$l$ 是轨道角动量。模型空间由主壳层量子数 $K = 2n+l$ 截断，因此只包括满足 $2n+l \\le N_{\\max}$ 的态。算法遍历所有满足此条件的有效 $(n,l)$ 对。\n\n- **态的贡献**：对于每个态 $(n,l)$，其对总矩阵元的贡献是权重因子 $w_{nl}$ 和径向积分 $I_{nl}$ 的乘积。\n    - 权重 $w_{nl}$ 计算为 $w_{nl} = (2l+1) g_0 e^{-\\alpha(2n+l)}$，它结合了磁亚态简并度 $D_l = 2l+1$ 和一个唯象占据因子 $g_{nl}$。\n    - 径向积分 $I_{nl}$ 由 $I_{nl} = \\int_{0}^{r_{\\max}} r^2 \\left[R_{nl}(r)\\right]^2 H(r)\\,dr$ 给出。被积函数按以下方式构建：\n        - 谐振子径向波函数 $R_{nl}(r)$ 根据其定义构建：$R_{nl}(r) = \\mathcal{N}_{nl} (r/b)^l e^{-r^2/(2b^2)} L_{n}^{l+1/2}(r^2/b^2)$。归一化因子 $\\mathcal{N}_{nl} = \\sqrt{2\\,\\Gamma(n+1) / (b^3\\,\\Gamma(n + l + 3/2))}$ 使用 `scipy.special` 中的伽马函数 $\\Gamma(\\cdot)$ 计算。广义拉盖尔多项式 $L_{n}^{l+1/2}(x)$ 使用 `scipy.special.genlaguerre` 进行求值。\n        - 中微子势为 $H(r) = R e^{-\\mu r} / r$。\n        - 完整的被积函数简化为 $r \\cdot |R_{nl}(r)|^2 \\cdot R e^{-\\mu r}$。这种形式在数值上是有利的，因为它在 $r=0$ 处是良定义的，其极限为 $0$。计算在整个径向网格上进行了向量化，在 $r=0$ 处的值正确地计算为 $0$。\n    - 然后使用 `scipy.integrate.simpson` 中的辛普森法则实现在径向网格上对构建的被积函数值进行数值积分，从而计算出积分 $I_{nl}$。\n\n- **累加**：将加权贡献 $w_{nl}I_{nl}$ 对所有 $(n,l)$ 对求和，以得出 $M^{0\\nu}$ 的最终值。\n\n**2. 收敛性分析和误差估计**\n\n实现的第二部分协调对核心计算函数的调用，为每个测试用例执行指定的收敛性研究。\n\n- **中心值 ($M_{\\mathrm{central}}$)**：矩阵元的中心值被定义为使用最大模型空间大小（$N_{\\max}^{\\text{largest}}$）、中心振荡器频率（$\\hbar\\omega_{\\text{central}}$，取为给定集合的中位数）和最精细径向网格（$N_r^{\\text{largest}}$）获得的结果。\n\n- **误差分量**：量化了三个数值误差来源：\n    1.  **模型空间误差 ($\\Delta_{\\mathrm{model}}$)**：其计算方式为 $|M^{0\\nu}(N_{\\max}^{\\text{largest}}, \\dots) - M^{0\\nu}(N_{\\max}^{\\text{second-largest}}, \\dots)|$ 的绝对差，其中 $\\hbar\\omega$ 和 $N_r$ 分别固定在其中心值和最精细值。\n    2.  **频率误差 ($\\Delta_{\\omega}$)**：其计算方式为，在保持 $N_{\\max}$ 和 $N_r$ 为最大值的情况下，通过在给定集合中改变 $\\hbar\\omega$ 所获得的 $M^{0\\nu}$ 值范围（最大值减去最小值）的一半。如果只提供一个 $\\hbar\\omega$ 值，则此误差为零。\n    3.  **网格误差 ($\\Delta_{\\mathrm{mesh}}$)**：其计算方式为 $|M^{0\\nu}(\\dots, N_r^{\\text{largest}}) - M^{0\\nu}(\\dots, N_r^{\\text{second-largest}})|$ 的绝对差，其中 $N_{\\max}$ 和 $\\hbar\\omega$ 分别固定在其最大值和中心值。\n\n- **总误差 ($\\Delta_{\\mathrm{total}}$)**：将各个误差分量通过平方和再开方的方式组合，以估计总的数值不确定度：$\\Delta_{\\mathrm{total}} = \\sqrt{\\Delta_{\\mathrm{model}}^2 + \\Delta_{\\omega}^2 + \\Delta_{\\mathrm{mesh}}^2}$。\n\n**3. 实现策略**\n\n为优化收敛性研究中固有的大量重复计算，核心函数 `calculate_M0nu` 使用了记忆化缓存 (`functools.lru_cache`) 进行装饰。这确保了任何具有相同参数集的调用都不会被重新计算，而是其结果会立即从内存中检索，从而显著提高性能。最终的程序遍历预定义的测试用例，对每个用例执行完整的分析，并将得到的包含五个值的列表（$M_{\\mathrm{central}}, \\Delta_{\\mathrm{model}}, \\Delta_{\\omega}, \\Delta_{\\mathrm{mesh}}, \\Delta_{\\mathrm{total}}$）格式化为所要求的确切字符串格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, genlaguerre\nfrom scipy.integrate import simpson\nfrom functools import lru_cache\n\n# Physical constants in specified units\nHBAR_C = 197.326  # MeV*fm\nM_N = 939.0       # MeV\nR0 = 1.2          # fm\nG0 = 1.0\nALPHA = 0.4\n\n@lru_cache(maxsize=None)\ndef calculate_M0nu(A, mu, N_max, hw, Nr, beta):\n    \"\"\"\n    Calculates the neutrinoless double beta decay nuclear matrix element M^0nu\n    for a given set of model parameters.\n\n    Args:\n        A (int): Mass number.\n        mu (float): Screening parameter (fm^-1).\n        N_max (int): HO major-shell truncation.\n        hw (float): HO frequency (MeV).\n        Nr (int): Number of radial mesh points.\n        beta (float): Dimensionless factor for r_max.\n\n    Returns:\n        float: The dimensionless nuclear matrix element M^0nu.\n    \"\"\"\n    # 1. Derived physical and numerical parameters\n    R_nuc = R0 * A**(1.0/3.0)\n    b = HBAR_C / np.sqrt(M_N * hw)\n    r_max = beta * b\n\n    # Adjust Nr to be odd for Simpson's rule\n    Nr_adj = Nr if Nr % 2 != 0 else Nr + 1\n    r_mesh = np.linspace(0, r_max, Nr_adj)\n\n    M0nu_total = 0.0\n\n    # 2. Iterate over all allowed (n, l) quantum states\n    for K in range(N_max + 1):\n        for l in range(K + 1):\n            if (K - l) % 2 == 0:\n                n = (K - l) // 2\n                # Valid state (n,l) with 2n+l = K\n\n                # a. Calculate state weight w_nl\n                w_nl = (2 * l + 1) * G0 * np.exp(-ALPHA * K)\n\n                # b. Calculate radial integral I_nl\n                # Normalization factor for the HO wave function\n                norm_factor_sq = (2.0 * gamma(n + 1)) / (b**3 * gamma(n + l + 1.5))\n                \n                # Generalized Laguerre polynomial L_n^(l+0.5)\n                laguerre_poly = genlaguerre(n, l + 0.5)\n\n                # Vectorized calculation of the integrand on the mesh\n                # Integrand is r * |R_nl(r)|^2 * R_nuc * exp(-mu*r)\n                r_over_b = r_mesh / b\n                r_over_b_sq = r_over_b**2\n                \n                # np.power(0, 0) is 1, which is correct for l=0 at r=0\n                r_term = np.power(r_over_b, 2 * l)\n                exp_term = np.exp(-r_over_b_sq)\n                laguerre_term_sq = np.power(laguerre_poly(r_over_b_sq), 2)\n\n                R_nl_sq = norm_factor_sq * r_term * exp_term * laguerre_term_sq\n                \n                # The leading r_mesh factor ensures the integrand is 0 at r=0\n                integrand = r_mesh * R_nl_sq * R_nuc * np.exp(-mu * r_mesh)\n\n                # Numerical integration using Simpson's rule\n                I_nl = simpson(integrand, x=r_mesh)\n                \n                # c. Accumulate weighted contribution\n                M0nu_total += w_nl * I_nl\n\n    return M0nu_total\n\ndef solve():\n    \"\"\"\n    Main function to run the convergence study for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, mu, N_max_set, hw_set, Nr_set, beta)\n        {'A': 76, 'mu': 0.5, 'N_max_set': [4, 6, 8], 'hw_set': [10, 12, 14], 'Nr_set': [200, 400], 'beta': 8.0},\n        {'A': 136, 'mu': 0.45, 'N_max_set': [6, 8, 10], 'hw_set': [8, 10, 12], 'Nr_set': [300, 600], 'beta': 9.0},\n        {'A': 48, 'mu': 0.5, 'N_max_set': [2, 4], 'hw_set': [12], 'Nr_set': [50, 100], 'beta': 6.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        A, mu, beta = case['A'], case['mu'], case['beta']\n        N_max_set = sorted(case['N_max_set'])\n        hw_set = sorted(case['hw_set'])\n        Nr_set = sorted(case['Nr_set'])\n\n        # Identify key parameter points for the study\n        N_max_large = N_max_set[-1]\n        N_max_second_large = N_max_set[-2] if len(N_max_set) > 1 else N_max_large\n        \n        hw_central = float(np.median(hw_set))\n        \n        Nr_large = Nr_set[-1]\n        Nr_second_large = Nr_set[-2] if len(Nr_set) > 1 else Nr_large\n\n        # 1. Central value calculation\n        M_central = calculate_M0nu(A, mu, N_max_large, hw_central, Nr_large, beta)\n\n        # 2. Model-space truncation error\n        M_at_Nmax_second = calculate_M0nu(A, mu, N_max_second_large, hw_central, Nr_large, beta)\n        delta_model = abs(M_central - M_at_Nmax_second)\n\n        # 3. Oscillator frequency error\n        if len(hw_set) > 1:\n            m_values_hw = [calculate_M0nu(A, mu, N_max_large, hw, Nr_large, beta) for hw in hw_set]\n            delta_hw = 0.5 * (max(m_values_hw) - min(m_values_hw))\n        else:\n            delta_hw = 0.0\n\n        # 4. Radial mesh error\n        M_at_Nr_second = calculate_M0nu(A, mu, N_max_large, hw_central, Nr_second_large, beta)\n        delta_mesh = abs(M_central - M_at_Nr_second)\n\n        # 5. Total error\n        delta_total = np.sqrt(delta_model**2 + delta_hw**2 + delta_mesh**2)\n\n        all_results.append([M_central, delta_model, delta_hw, delta_mesh, delta_total])\n\n    # Format the output as a string representing a list of lists.\n    formatted_results = [f\"[{','.join(map(str, res_list))}]\" for res_list in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}