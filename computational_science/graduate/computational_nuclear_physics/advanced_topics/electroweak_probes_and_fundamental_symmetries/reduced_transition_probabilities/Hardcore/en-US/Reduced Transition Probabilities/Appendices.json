{
    "hands_on_practices": [
        {
            "introduction": "The calculation of any transition probability begins with understanding the fundamental symmetries that govern the process. Electric dipole ($E1$) transitions are constrained by strict selection rules for angular momentum and parity. This exercise, , provides a powerful hands-on test of these principles by exploring a physically realistic scenario where parity is weakly violated, allowing you to compute the strength of an otherwise forbidden transition. By implementing these rules, you will gain a profound understanding of how fundamental symmetries shape nuclear observables.",
            "id": "3585982",
            "problem": "Consider an electric dipole transition in a nucleus treated within a spherical-tensor formalism. The electric dipole operator is a rank-one spherical tensor, denoted by $T^{(E1)}$, and has odd parity. The reduced transition probability from an initial to a final state is defined by the standard nuclear structure convention in terms of the reduced matrix element of the operator. The global physical requirements for electric multipole radiation of rank $L$ are: angular momentum coupling governed by spherical tensor algebra and parity transformation properties of the operator. For electric dipole radiation ($L=1$), angular momentum coupling is restricted by the triangle inequality for spherical tensors and the parity property of the operator. In addition, the rank-one tensor does not connect states with $J_i=0$ and $J_f=0$.\n\nWe introduce weak interaction-induced parity violation that mixes basis states of the same total angular momentum and opposite parity. Let the physical initial and final states be\n$$\n|\\tilde{i}\\rangle = |i\\rangle + \\alpha_i |i'\\rangle, \\quad |\\tilde{f}\\rangle = |f\\rangle + \\alpha_f |f'\\rangle,\n$$\nwhere $|i\\rangle$ has angular momentum $J_i$ and parity $\\pi_i$, $|i'\\rangle$ has the same angular momentum $J_i$ and parity $-\\pi_i$, and similarly $|f\\rangle$ has angular momentum $J_f$ and parity $\\pi_f$, while $|f'\\rangle$ has the same $J_f$ and parity $-\\pi_f$. The mixing amplitudes $\\alpha_i$ and $\\alpha_f$ are small, dimensionless quantities produced by the weak interaction matrix elements $V_i$ and $V_f$ with nearby opposite-parity states, and energy spacings $\\Delta_i$ and $\\Delta_f$. In a first-order two-state mixing model, \n$$\n\\alpha_i = \\frac{V_i}{\\Delta_i}, \\quad \\alpha_f = \\frac{V_f}{\\Delta_f}.\n$$\n\nUsing the general properties of spherical tensors and parity, the total reduced matrix element connecting the physical states to first order in the mixing amplitudes is\n$$\n\\langle \\tilde{f} \\| T^{(E1)} \\| \\tilde{i} \\rangle \\approx \\langle f \\| T^{(E1)} \\| i \\rangle + \\alpha_i \\langle f \\| T^{(E1)} \\| i' \\rangle + \\alpha_f \\langle f' \\| T^{(E1)} \\| i \\rangle,\n$$\nwith each term subject to the tensor coupling constraints for a rank-one operator and the parity transformation property of $T^{(E1)}$. Specifically:\n- Angular momentum selection rule: the reduced matrix element of a rank-one spherical tensor is only nonzero if $|J_f - J_i| \\le 1 \\le J_i + J_f$, and the case $J_i=J_f=0$ is excluded for rank one.\n- Parity selection rule for electric dipole: since $T^{(E1)}$ has odd intrinsic parity, the reduced matrix element between basis states is only nonzero if $\\pi_f = -\\pi_i$ for the pair of states connected by the operator in that term.\n\nThe reduced transition probability for electric dipole radiation is\n$$\nB(E1; J_i \\to J_f) = \\frac{1}{2J_i+1}\\left|\\langle \\tilde{f} \\| T^{(E1)} \\| \\tilde{i} \\rangle \\right|^2,\n$$\nwhere the operator rank is one and the matrix element is built from the sum above, constrained term-by-term by the selection rules. All reduced matrix elements $\\langle \\cdot \\| T^{(E1)} \\| \\cdot \\rangle$ are provided in units of $e \\cdot \\mathrm{fm}$, so $B(E1)$ must be expressed in $e^2 \\mathrm{fm}^2$.\n\nImplement a program that computes $B(E1)$ under these rules for the following test suite. Each test case is defined by the tuple of parameters:\n- $(J_i, \\pi_i, J_f, \\pi_f)$: quantum numbers of the primary initial and final states, with $\\pi \\in \\{+1,-1\\}$ denoting parity.\n- $M_{fi}$: the reduced matrix element $\\langle f \\| T^{(E1)} \\| i \\rangle$ in $e \\cdot \\mathrm{fm}$.\n- $(J_i', \\pi_i')$ and $(J_f', \\pi_f')$: quantum numbers of the opposite-parity partner states for the initial and final configurations.\n- $M_{fi'}$: the reduced matrix element $\\langle f \\| T^{(E1)} \\| i' \\rangle$ in $e \\cdot \\mathrm{fm}$.\n- $M_{f'i}$: the reduced matrix element $\\langle f' \\| T^{(E1)} \\| i \\rangle$ in $e \\cdot \\mathrm{fm}$.\n- $(V_i, \\Delta_i)$ and $(V_f, \\Delta_f)$: weak mixing matrix element and energy spacing in $\\mathrm{MeV}$ for the initial and final mixing amplitudes.\n\nFor each test case, the program must:\n- Compute $\\alpha_i = V_i / \\Delta_i$ and $\\alpha_f = V_f / \\Delta_f$.\n- Construct the physical reduced matrix element by summing the allowed contributions, where each contribution is included only if both the angular momentum and parity constraints are satisfied for the pair of states in that term.\n- Enforce the angular momentum rule for rank one and exclude the $J_i=J_f=0$ case in all terms.\n- Compute $B(E1)$ using the physical reduced matrix element and express the final answer in $e^2\\,\\mathrm{fm}^2$.\n\nUse the following scientifically consistent test suite:\n- Test 1 (allowed $E1$ with $\\Delta J = 1$ and opposite parity):\n  $J_i=2$, $\\pi_i=+1$; $J_f=1$, $\\pi_f=-1$; $M_{fi}=0.800$; $J_i'=2$, $\\pi_i'=-1$; $J_f'=1$, $\\pi_f'=+1$; $M_{fi'}=0.000$; $M_{f'i}=0.000$; $V_i=0.000\\,\\mathrm{MeV}$, $\\Delta_i=1.000\\,\\mathrm{MeV}$; $V_f=0.000\\,\\mathrm{MeV}$, $\\Delta_f=1.000\\,\\mathrm{MeV}$.\n- Test 2 (allowed $E1$ with $\\Delta J = 0$ and opposite parity):\n  $J_i=1$, $\\pi_i=+1$; $J_f=1$, $\\pi_f=-1$; $M_{fi}=0.300$; $J_i'=1$, $\\pi_i'=-1$; $J_f'=1$, $\\pi_f'=+1$; $M_{fi'}=0.000$; $M_{f'i}=0.000$; $V_i=0.000\\,\\mathrm{MeV}$, $\\Delta_i=1.000\\,\\mathrm{MeV}$; $V_f=0.000\\,\\mathrm{MeV}$, $\\Delta_f=1.000\\,\\mathrm{MeV}$.\n- Test 3 (forbidden by angular momentum: $\\Delta J = 2$ for rank-one):\n  $J_i=2$, $\\pi_i=+1$; $J_f=0$, $\\pi_f=-1$; $M_{fi}=1.000$; $J_i'=2$, $\\pi_i'=-1$; $J_f'=0$, $\\pi_f'=+1$; $M_{fi'}=0.000$; $M_{f'i}=0.000$; $V_i=0.000\\,\\mathrm{MeV}$, $\\Delta_i=1.000\\,\\mathrm{MeV}$; $V_f=0.000\\,\\mathrm{MeV}$, $\\Delta_f=1.000\\,\\mathrm{MeV}$.\n- Test 4 (same parity initial and final, induced $E1$ through mixing):\n  $J_i=2$, $\\pi_i=+1$; $J_f=1$, $\\pi_f=+1$; $M_{fi}=0.000$; $J_i'=2$, $\\pi_i'=-1$; $J_f'=1$, $\\pi_f'=-1$; $M_{fi'}=0.400$; $M_{f'i}=-0.200$; $V_i=2.0\\times 10^{-6}\\,\\mathrm{MeV}$, $\\Delta_i=1.000\\,\\mathrm{MeV}$; $V_f=5.0\\times 10^{-6}\\,\\mathrm{MeV}$, $\\Delta_f=1.000\\,\\mathrm{MeV}$.\n- Test 5 (excluded $J_i=J_f=0$ case even with opposite parity and mixing present):\n  $J_i=0$, $\\pi_i=+1$; $J_f=0$, $\\pi_f=-1$; $M_{fi}=0.500$; $J_i'=0$, $\\pi_i'=-1$; $J_f'=0$, $\\pi_f'=+1$; $M_{fi'}=0.700$; $M_{f'i}=-0.600$; $V_i=1.0\\times 10^{-6}\\,\\mathrm{MeV}$, $\\Delta_i=1.000\\,\\mathrm{MeV}$; $V_f=1.0\\times 10^{-6}\\,\\mathrm{MeV}$, $\\Delta_f=1.000\\,\\mathrm{MeV}$.\n\nAll reduced matrix elements are in $e \\cdot \\mathrm{fm}$ and all weak interaction parameters are in $\\mathrm{MeV}$. Express the final reduced transition probabilities $B(E1)$ in $e^2\\,\\mathrm{fm}^2$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[r_1,r_2,r_3,r_4,r_5]`). Use decimal notation, and you may use scientific notation where appropriate. Round each result to twelve significant digits to ensure numerical clarity.",
            "solution": "This problem requires the calculation of the reduced transition probability, $B(E1)$, for an electric dipole transition between physical states $|\\tilde{i}\\rangle$ and $|\\tilde{f}\\rangle$. These states are superpositions of basis states with opposite parities, a consequence of weak interaction-induced parity violation.\n\nThe first step is to construct the total reduced matrix element for the $E1$ operator, $T^{(E1)}$, between the physical states. To first order in the small mixing amplitudes $\\alpha_i$ and $\\alpha_f$, this is given by:\n$$\nM_{total} = \\langle \\tilde{f} \\| T^{(E1)} \\| \\tilde{i} \\rangle \\approx \\langle f \\| T^{(E1)} \\| i \\rangle + \\alpha_i \\langle f \\| T^{(E1)} \\| i' \\rangle + \\alpha_f \\langle f' \\| T^{(E1)} \\| i \\rangle\n$$\nThe calculation of $M_{total}$ involves summing three distinct contributions, where the provided values are $M_{fi} = \\langle f \\| T^{(E1)} \\| i \\rangle$, $M_{fi'} = \\langle f \\| T^{(E1)} \\| i' \\rangle$, and $M_{f'i} = \\langle f' \\| T^{(E1)} \\| i \\rangle$. The mixing amplitudes are $\\alpha_i = V_i/\\Delta_i$ and $\\alpha_f = V_f/\\Delta_f$.\n\nEach of these three terms is non-zero only if it satisfies the fundamental selection rules for a rank-1 spherical tensor operator with odd parity ($E1$ operator):\n1.  **Angular Momentum Rule**: For a transition between an initial state of angular momentum $J_{initial}$ and a final state of angular momentum $J_{final}$, the condition $|J_{initial} - J_{final}| \\le 1$ must be met. Furthermore, the case where $J_{initial}=0$ and $J_{final}=0$ is strictly forbidden for any rank-1 operator.\n2.  **Parity Rule**: The operator $T^{(E1)}$ has odd intrinsic parity. Therefore, it can only connect states of opposite parity. For a transition from a state with parity $\\pi_{initial}$ to one with parity $\\pi_{final}$, the condition $\\pi_{final} = -\\pi_{initial}$ must be satisfied.\n\nThe computational procedure is to evaluate each of the three terms in the expression for $M_{total}$ separately, including each term in the sum only if it satisfies both the angular momentum and parity selection rules.\n\nA function `is_allowed(J_init, p_init, J_fin, p_fin)` can implement these two rules, returning true if a transition is allowed and false otherwise. The total reduced matrix element is thus constructed as follows:\n$M_{total} = 0$\n- **Term 1**: If `is_allowed`($J_i, \\pi_i, J_f, \\pi_f$) is true, add $M_{fi}$ to $M_{total}$.\n- **Term 2**: If `is_allowed`($J_i', \\pi_i', J_f, \\pi_f$) is true, add $\\alpha_i \\cdot M_{fi'}$ to $M_{total}$.\n- **Term 3**: If `is_allowed`($J_i, \\pi_i, J_f', \\pi_f'$) is true, add $\\alpha_f \\cdot M_{f'i}$ to $M_{total}$.\n\nOnce $M_{total}$ is computed in units of $e \\cdot \\mathrm{fm}$, the reduced transition probability $B(E1)$ is calculated using its definition:\n$$\nB(E1; J_i \\to J_f) = \\frac{1}{2J_i+1} |M_{total}|^2\n$$\nThe resulting $B(E1)$ value will have units of $e^2\\,\\mathrm{fm}^2$. The factor $(2J_i+1)^{-1}$ correctly averages over the initial magnetic substates. The implementation will apply this logic to each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the reduced transition probability B(E1) for electric dipole\n    transitions between parity-mixed nuclear states.\n    \"\"\"\n\n    # Test cases defined by the tuple of parameters:\n    # (Ji, pi, Jf, pf, M_fi, Ji', pi', Jf', pf', M_fi_prime, M_f_prime_i, \n    #  Vi, delta_i, Vf, delta_f)\n    test_cases = [\n        # Test 1 (allowed E1 with Delta J = 1 and opposite parity)\n        (2, +1, 1, -1, 0.800, 2, -1, 1, +1, 0.000, 0.000, 0.000, 1.000, 0.000, 1.000),\n        # Test 2 (allowed E1 with Delta J = 0 and opposite parity)\n        (1, +1, 1, -1, 0.300, 1, -1, 1, +1, 0.000, 0.000, 0.000, 1.000, 0.000, 1.000),\n        # Test 3 (forbidden by angular momentum: Delta J = 2 for rank-one)\n        (2, +1, 0, -1, 1.000, 2, -1, 0, +1, 0.000, 0.000, 0.000, 1.000, 0.000, 1.000),\n        # Test 4 (same parity initial and final, induced E1 through mixing)\n        (2, +1, 1, +1, 0.000, 2, -1, 1, -1, 0.400, -0.200, 2.0e-6, 1.000, 5.0e-6, 1.000),\n        # Test 5 (excluded J=0 to J=0 case even with mixing)\n        (0, +1, 0, -1, 0.500, 0, -1, 0, +1, 0.700, -0.600, 1.0e-6, 1.000, 1.0e-6, 1.000),\n    ]\n\n    results = []\n\n    def is_allowed(j_initial, p_initial, j_final, p_final):\n        \"\"\"\n        Checks if a transition is allowed by E1 selection rules.\n        \"\"\"\n        # Angular momentum selection rule for a rank-1 operator\n        am_allowed = abs(j_initial - j_final) <= 1 and not (j_initial == 0 and j_final == 0)\n        \n        # Parity selection rule for an E1 operator (odd parity)\n        parity_allowed = p_final == -p_initial\n        \n        return am_allowed and parity_allowed\n\n    for case in test_cases:\n        (j_i, p_i, j_f, p_f, m_fi, j_i_prime, p_i_prime, j_f_prime, p_f_prime, \n         m_fi_prime, m_f_prime_i, v_i, delta_i, v_f, delta_f) = case\n\n        # Calculate mixing amplitudes\n        alpha_i = v_i / delta_i if delta_i != 0 else 0\n        alpha_f = v_f / delta_f if delta_f != 0 else 0\n\n        # Calculate total reduced matrix element\n        m_total = 0.0\n\n        # Term 1: <f || T(E1) || i>\n        if is_allowed(j_i, p_i, j_f, p_f):\n            m_total += m_fi\n\n        # Term 2: alpha_i * <f || T(E1) || i'>\n        if is_allowed(j_i_prime, p_i_prime, j_f, p_f):\n            m_total += alpha_i * m_fi_prime\n\n        # Term 3: alpha_f * <f' || T(E1) || i>\n        if is_allowed(j_i, p_i, j_f_prime, p_f_prime):\n            m_total += alpha_f * m_f_prime_i\n\n        # Calculate B(E1)\n        if (2 * j_i + 1) > 0:\n            b_e1 = (1 / (2 * j_i + 1)) * (m_total**2)\n        else: # Should not happen for physical J >= 0\n            b_e1 = 0.0\n\n        # Format result to 12 significant digits in scientific notation\n        results.append(\"{:.11e}\".format(b_e1))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond selection rules, quantitative prediction of transition strengths is a central goal of nuclear theory. Within the configuration-interaction shell model, a complex many-body observable is systematically constructed from simpler, one-body building blocks. This practice, , guides you through the derivation and implementation of a formula for the reduced transition probability $B(E2)$ from One-Body Transition Densities (OBTDs) and single-particle matrix elements, scaled by effective charges. Mastering this procedure is essential for connecting microscopic shell-model calculations to experimental data.",
            "id": "3585971",
            "problem": "Consider a nonrelativistic nuclear many-body system described within the configuration-interaction shell model. The electric quadrupole transition operator of rank $L$ between many-body states is built from one-body operators acting on single-nucleon orbitals, differentiated by proton and neutron subspaces and scaled by effective charges to account for missing correlations. In a computational setting, the reduced transition probability for an electric multipole transition of rank $L$ between an initial state with angular momentum $J_i$ and a final state with angular momentum $J_f$ is defined in terms of a many-body reduced matrix element, and the latter can be assembled from one-body building blocks and effective charges. Your task is to derive, from first principles, how to compute the reduced transition probability $B(EL; J_i \\rightarrow J_f)$ using the Wigner–Eckart theorem, second quantization with one-body operators, and a decomposition of the many-body reduced matrix element in terms of One-Body Transition Densities (OBTDs) and single-particle reduced matrix elements, then implement the resulting expression in code to evaluate a specified test suite.\n\nUse the following fundamental starting points only:\n- The Wigner–Eckart theorem for spherical tensor operators of rank $L$ acting between angular momentum eigenstates.\n- The definition of a reduced transition probability $B(EL; J_i \\rightarrow J_f)$ in terms of reduced matrix elements.\n- The structure of one-body operators in second quantization and their action on many-body states.\n- The concept of effective charges $e_p$ and $e_n$ entering the definition of the electric multipole operator as proton and neutron weighted sums, respectively.\n\nYou must not assume or use any pre-quoted final computational formulae that explicitly express $B(EL)$ in terms of the quantities below; instead, you must derive the computational expression starting from the fundamental principles listed above.\n\nIn the provided computational model, the inputs are:\n- The initial and final angular momenta $J_i$ and $J_f$.\n- The operator rank $L$, here fixed to the electric quadrupole case $L = 2$.\n- The proton effective charge $e_p$ and the neutron effective charge $e_n$ (dimensionless multipliers).\n- For protons and neutrons separately, lists of terms. Each term consists of an OBTD value and a corresponding single-particle reduced matrix element of the electric multipole operator of rank $L$, already including angular-momentum reduction on the single-particle space. An OBTD is a scalar coefficient that encodes the many-body structure change due to creating a particle in one orbital and annihilating it in another, reduced to rank $L$. The single-particle reduced matrix element associated to a term is given in units of $\\mathrm{fm}^L$, here $\\mathrm{fm}^2$ for $L=2$.\n\nThe output you must produce is the reduced transition probability values $B(E2; J_i \\rightarrow J_f)$, in units of $e^2\\,\\mathrm{fm}^4$, for each of the following test cases. Each test case is fully specified by:\n- $J_i$, $J_f$\n- $e_p$, $e_n$\n- A list of proton terms $\\{(\\text{OBTD}_p^{(k)}, \\text{SPME}_p^{(k)})\\}$ where each single-particle reduced matrix element $\\text{SPME}$ is in $\\mathrm{fm}^2$.\n- A list of neutron terms $\\{(\\text{OBTD}_n^{(k)}, \\text{SPME}_n^{(k)})\\}$ where each single-particle reduced matrix element $\\text{SPME}$ is in $\\mathrm{fm}^2$.\n\nCompute $B(E2)$ for the following five cases, ensuring numerical stability and correct handling of signs:\n\n- Case $1$ (single-species, single-term proton-only):\n  - $J_i = 2$, $J_f = 0$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - Proton terms: $\\{(0.8, 5.0)\\}$\n  - Neutron terms: $\\{\\}$\n\n- Case $2$ (both species, multi-term):\n  - $J_i = 4$, $J_f = 2$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - Proton terms: $\\{(0.25, 6.0), (0.10, 4.0)\\}$\n  - Neutron terms: $\\{(0.40, 5.0), (0.15, 3.0)\\}$\n\n- Case $3$ (destructive interference via signs):\n  - $J_i = 2$, $J_f = 2$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - Proton terms: $\\{(0.50, 7.0), (0.20, -2.0)\\}$\n  - Neutron terms: $\\{(-0.80, 6.0)\\}$\n\n- Case $4$ (boundary with zero One-Body Transition Densities):\n  - $J_i = 6$, $J_f = 4$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - Proton terms: $\\{(0.0, 10.0), (0.0, -7.0)\\}$\n  - Neutron terms: $\\{\\}$\n\n- Case $5$ (boundary with $J_i = 0$ so the statistical factor is unity):\n  - $J_i = 0$, $J_f = 2$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - Proton terms: $\\{(-0.30, 8.0)\\}$\n  - Neutron terms: $\\{(0.20, 6.0)\\}$\n\nRequirements:\n- Derive the computational expression for $B(E2; J_i \\rightarrow J_f)$ from the fundamental principles listed above, explicitly showing the steps connecting the one-body operator structure, One-Body Transition Densities, and effective charges to the many-body reduced matrix element.\n- Implement the derived expression as a complete, runnable program that evaluates all five cases.\n- Express each final result in units of $e^2\\,\\mathrm{fm}^4$, rounded to exactly $6$ decimal places.\n- Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, `[result_1,result_2,result_3]`).",
            "solution": "This problem requires the derivation and implementation of a formula for the reduced transition probability, $B(E2; J_i \\rightarrow J_f)$, within the nuclear shell model framework. The derivation starts from fundamental principles.\n\n**1. Definition of the Reduced Transition Probability**\n\nThe reduced transition probability, $B(EL; J_i \\rightarrow J_f)$, for a transition of multipolarity $L$ driven by an operator $\\hat{O}(EL)$, is defined as:\n$$\nB(EL; J_i \\rightarrow J_f) = \\frac{1}{2J_i + 1} |\\langle \\Psi_f || \\hat{O}(EL) || \\Psi_i \\rangle|^2\n$$\nHere, $\\langle \\Psi_f || \\hat{O}(EL) || \\Psi_i \\rangle$ is the many-body reduced matrix element (MBRME), which is independent of magnetic quantum numbers per the Wigner–Eckart theorem. For this problem, $L=2$ (electric quadrupole).\n\n**2. Structure of the Electric Quadrupole Operator**\n\nThe $\\hat{O}(E2)$ operator is a one-body operator, which can be expressed as a sum over individual nucleons. In the shell model, we account for core polarization effects by introducing effective charges, $e_p$ and $e_n$. The operator is separated into proton and neutron contributions:\n$$\n\\hat{O}(E2) = e \\left( e_p \\sum_{k \\in \\text{protons}} \\hat{o}_k(E2) + e_n \\sum_{k \\in \\text{neutrons}} \\hat{o}_k(E2) \\right)\n$$\nwhere $\\hat{o}_k(E2)$ is the operator for a single nucleon (e.g., $r_k^2 Y_{2M}(\\hat{r}_k)$), and the elementary charge $e$ is factored out. By convention, the final $B(E2)$ is quoted in units of $e^2 \\cdot \\text{length}^4$.\n\n**3. The Many-Body Reduced Matrix Element (MBRME)**\n\nDue to the operator's linear structure, the MBRME is a coherent sum of proton and neutron parts:\n$$\n\\langle \\Psi_f || \\hat{O}(E2) || \\Psi_i \\rangle = e \\left( e_p \\langle \\Psi_f || \\hat{O}_p(E2) || \\Psi_i \\rangle_M + e_n \\langle \\Psi_f || \\hat{O}_n(E2) || \\Psi_i \\rangle_M \\right)\n$$\nwhere $\\hat{O}_{p,n}$ are the sums over only protons or neutrons, and the subscript $M$ on the matrix elements denotes the purely mechanical part (without charge).\n\nThe shell model provides a way to compute these MBRMEs from simpler components. The MBRME of any one-body operator can be expanded as a sum over all single-particle transitions:\n$$\n\\langle \\Psi_f || \\hat{O}_p(E2) || \\Psi_i \\rangle_M = \\sum_{\\alpha, \\beta} \\text{OBTD}_{p, \\alpha\\beta} \\cdot \\langle \\alpha || \\hat{o}(E2) || \\beta \\rangle_p\n$$\nIn this expression:\n- $\\langle \\alpha || \\hat{o}(E2) || \\beta \\rangle_p$ is the single-particle reduced matrix element (SPME) for a proton transition between orbitals.\n- $\\text{OBTD}_{p, \\alpha\\beta}$ is the One-Body Transition Density for protons. This scalar quantity encapsulates the many-body physics, representing the amplitude for the transition $|\\Psi_i\\rangle \\to |\\Psi_f\\rangle$ to proceed via the single-particle jump $\\beta \\to \\alpha$.\n\nThe problem provides pre-calculated lists of non-zero terms, simplifying the sum. We define proton and neutron sums, $S_p$ and $S_n$:\n$$ S_p = \\sum_{k} \\text{OBTD}_{p}^{(k)} \\cdot \\text{SPME}_{p}^{(k)} \\quad \\text{and} \\quad S_n = \\sum_{j} \\text{OBTD}_{n}^{(j)} \\cdot \\text{SPME}_{n}^{(j)} $$\nThe units of $S_p$ and $S_n$ are $\\mathrm{fm}^2$, as OBTDs are dimensionless and SPMEs are given in $\\mathrm{fm}^2$.\n\nThe total MBRME, which we denote as $M_{total}$, becomes:\n$$ M_{total} = e_p S_p + e_n S_n $$\nThis value has units of $\\mathrm{fm}^2$.\n\n**4. Final Computational Formula**\n\nSubstituting this expression back into the definition of $B(E2)$ yields the final formula. The full physical RME is $e \\cdot M_{total}$.\n$$\nB(E2; J_i \\rightarrow J_f) = \\frac{1}{2J_i+1} |e \\cdot M_{total}|^2 = \\frac{(M_{total})^2}{2J_i+1} \\quad [e^2\\,\\mathrm{fm}^4]\n$$\nThe derived formula to be implemented is:\n$$\nB(E2; J_i \\rightarrow J_f) = \\frac{1}{2J_i + 1} \\left( e_p \\sum_{k} (\\text{OBTD}_{p}^{(k)} \\cdot \\text{SPME}_{p}^{(k)}) + e_n \\sum_{j} (\\text{OBTD}_{n}^{(j)} \\cdot \\text{SPME}_{n}^{(j)}) \\right)^2\n$$\nThis expression is a direct consequence of the fundamental principles outlined. The computation for each test case involves summing the products within the proton and neutron lists, scaling by effective charges, adding these two contributions, squaring the result, and finally dividing by the statistical factor $(2J_i + 1)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and calculates the reduced transition probability B(E2) for a set of test cases\n    within the nuclear shell model framework.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"Ji\": 2, \"Jf\": 0, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.8, 5.0)],\n            \"neutron_terms\": []\n        },\n        {\n            \"name\": \"Case 2\",\n            \"Ji\": 4, \"Jf\": 2, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.25, 6.0), (0.10, 4.0)],\n            \"neutron_terms\": [(0.40, 5.0), (0.15, 3.0)]\n        },\n        {\n            \"name\": \"Case 3\",\n            \"Ji\": 2, \"Jf\": 2, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.50, 7.0), (0.20, -2.0)],\n            \"neutron_terms\": [(-0.80, 6.0)]\n        },\n        {\n            \"name\": \"Case 4\",\n            \"Ji\": 6, \"Jf\": 4, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.0, 10.0), (0.0, -7.0)],\n            \"neutron_terms\": []\n        },\n        {\n            \"name\": \"Case 5\",\n            \"Ji\": 0, \"Jf\": 2, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(-0.30, 8.0)],\n            \"neutron_terms\": [(0.20, 6.0)]\n        }\n    ]\n\n    results = []\n    \n    # The derived computational formula for B(E2) is:\n    # B(E2) = (1 / (2*Ji + 1)) * (ep * sum(OBTD_p * SPME_p) + en * sum(OBTD_n * SPME_n))^2\n\n    for case in test_cases:\n        # Calculate the sum of (OBTD * SPME) for protons\n        sum_p = 0.0\n        for obtd_p, spme_p in case[\"proton_terms\"]:\n            sum_p += obtd_p * spme_p\n\n        # Calculate the sum of (OBTD * SPME) for neutrons\n        sum_n = 0.0\n        for obtd_n, spme_n in case[\"neutron_terms\"]:\n            sum_n += obtd_n * spme_n\n\n        # Calculate the total many-body transition amplitude M\n        # M = ep * S_p + en * S_n\n        total_amplitude = case[\"ep\"] * sum_p + case[\"en\"] * sum_n\n\n        # Retrieve the initial angular momentum Ji\n        Ji = case[\"Ji\"]\n        \n        # Calculate the statistical factor. Handle Ji=0 case correctly, though algebra is the same.\n        if 2 * Ji + 1 == 0:\n            # This case is physically impossible for non-zero J, but as a safeguard.\n            b_e2 = 0.0\n        else:\n            statistical_factor = 1.0 / (2 * Ji + 1)\n            # Calculate B(E2)\n            b_e2 = statistical_factor * (total_amplitude ** 2)\n\n        results.append(b_e2)\n\n    # Format results to 6 decimal places and create the final output string.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the shell model provides a microscopic, discrete view, nuclear transitions can also be described using continuous charge and current densities, which are often the output of collective or mean-field models. The reduced transition probability $B(E\\lambda)$ is directly connected to the radial integral of a transition density. In this exercise, , you will derive this connection and tackle the practical task of numerically evaluating the integral for various physically motivated density profiles, developing crucial skills in numerical quadrature for computational physics.",
            "id": "3585886",
            "problem": "You are given a computational task rooted in electromagnetic transitions in atomic nuclei. Start from the definition of the electric multipole operator and the reduced matrix element to establish how the reduced transition probability for an electric multipole of order $\\lambda$, denoted $B(E\\lambda)$, can be expressed in terms of a radial transition density. Treat the nuclear system as spherically symmetric and focus on the scalar (radial) content of the transition density. From first principles, derive the expression that isolates the purely radial contribution by integrating over the angles, and show that the numerical evaluation of the reduced transition probability amounts to computing a single radial integral of the transition density weighted by an appropriate power of the radius.\n\nYou must then implement a program to numerically evaluate the reduced transition probability $B(E\\lambda)$ for a set of prescribed test cases by performing the required radial integral over $r \\in [0,\\infty)$. The transition density $\\delta\\rho_\\lambda(r)$ has the physical dimension of $\\mathrm{fm}^{-3}$, and the integral must be performed over the radial coordinate $r$ expressed in $\\text{fm}$. The resulting $B(E\\lambda)$ must be expressed in units of $e^2\\,\\mathrm{fm}^{2\\lambda}$, with the understanding that the effective charge is unity so that the numerical values reported are in $\\mathrm{fm}^{2\\lambda}$ and the factor $e^2$ is implicit. Angles, if any appear in intermediate derivations, must be in radians and fully integrated out in the radial reduction. Your numerical outputs must be reported as floats, and your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[x_1,x_2,x_3]`).\n\nYour implementation must address the numerical quadrature over an infinite interval and the weight $r^{\\lambda+2}$ multiplying the transition density. Discuss, in your solution, algorithmic choices for numerical quadrature that are robust for decaying, slowly decaying, and mildly oscillatory transition densities, including potential cancellation errors and step-size control. You must ensure scientific realism by choosing physically plausible functions for $\\delta\\rho_\\lambda(r)$ that are regular at the origin and integrable at infinity.\n\nTest Suite:\nEvaluate $B(E\\lambda)$ for the following four cases. For each case, use the specified parameters. All radii $r$ are in $\\text{fm}$; any wavenumber $k$ is in $\\mathrm{fm}^{-1}$.\n\n- Case A (general, decaying density): $\\lambda=2$, $\\delta\\rho_\\lambda(r) = \\rho_0 \\exp(-r/a)$ with $\\rho_0 = 0.02$ and $a = 1.2$.\n- Case B (boundary condition with $\\lambda=0$): $\\lambda=0$, $\\delta\\rho_\\lambda(r) = \\rho_0 \\exp(-r/a)$ with $\\rho_0 = 0.02$ and $a = 1.2$.\n- Case C (oscillatory, damped density): $\\lambda=3$, $\\delta\\rho_\\lambda(r) = \\rho_0 j_0(k r)\\exp(-r/R)$ with $\\rho_0 = 0.01$, $k = 1.0$, and $R=5.0$, where $j_0(x)$ is the spherical Bessel function $j_0(x)=\\sin(x)/x$ with $j_0(0)=1$.\n- Case D (slowly decaying algebraic tail): $\\lambda=1$, $\\delta\\rho_\\lambda(r) = \\rho_0 \\left(1+(r/R)^6\\right)^{-1}$ with $\\rho_0 = 0.03$ and $R=3.0$.\n\nFor each case, your program must compute the quantity obtained by the radial integral over $r$ and then square its absolute value to produce $B(E\\lambda)$, reported as a float in $\\mathrm{fm}^{2\\lambda}$. Your program may use any scientifically sound numerical quadrature method suitable for $[0,\\infty)$ that ensures convergence with controlled error tolerances. The final output must be a single line showing the four results in order A, B, C, D, formatted as `[B_A,B_B,B_C,B_D]`, with each $B$ a float.\n\nYour derivation must begin from the following foundations:\n- The electric multipole operator of rank $\\lambda$ built from the charge density.\n- The reduced matrix element definition and the Wigner–Eckart theorem to separate angular and radial contributions.\n- The definition of the radial transition density consistent with spherical symmetry and regularity at the origin.\n\nDo not quote or assume any pre-derived target formula for $B(E\\lambda)$; derive it from these bases. Then implement the computational evaluation faithful to the derived radial integral. Explicitly state and justify your numerical quadrature strategy and discuss possible numerical issues, such as behavior near $r=0$, the infinite upper limit, oscillatory integrands, cancellation, and adaptive tolerance selection.\n\nYour program must produce only the single line in the required format. No other text should be printed. The numerical outputs must be floats representing $B(E\\lambda)$ in $\\mathrm{fm}^{2\\lambda}$.",
            "solution": "This problem requires the derivation of the formula for the reduced electric transition probability, $B(E\\lambda)$, in terms of a radial transition density, and its subsequent numerical evaluation.\n\n### Derivation of the $B(E\\lambda)$ Formula\n\n1.  **Electric Multipole Operator**: The electric multipole operator of rank $\\lambda$ and projection $\\mu$, $\\hat{O}(E\\lambda, \\mu)$, is defined in terms of the nuclear charge density operator, $\\hat{\\rho}(\\vec{r})$:\n    $$\n    \\hat{O}(E\\lambda, \\mu) = \\int \\hat{\\rho}(\\vec{r}) r^\\lambda Y_{\\lambda\\mu}(\\hat{r}) \\, d^3r\n    $$\n    where $Y_{\\lambda\\mu}(\\hat{r})$ are the spherical harmonics. The operator has units of charge times length$^\\lambda$ (e.g., $e \\cdot \\mathrm{fm}^\\lambda$).\n\n2.  **Reduced Transition Probability**: The intrinsic strength of a transition from an initial state $|J_i\\rangle$ to a final state $|J_f\\rangle$ is captured by the reduced transition probability, $B(E\\lambda)$, defined via the reduced matrix element (RME):\n    $$\n    B(E\\lambda; J_i \\to J_f) = \\frac{1}{2J_i+1} |\\langle J_f || \\hat{O}(E\\lambda) || J_i \\rangle|^2\n    $$\n    The charge $e$ is conventionally factored out, such that the final units are $e^2 \\cdot \\mathrm{fm}^{2\\lambda}$.\n\n3.  **Radial Transition Density**: The matrix element of the operator involves an integral over the transition charge density, $\\rho_{tr}(\\vec{r}) = \\langle J_f M_f | \\hat{\\rho}(\\vec{r}) | J_i M_i \\rangle$. In nuclear models, the angular dependence is often separated, leaving a radial transition density, $\\delta\\rho_\\lambda(r)$. This function is defined such that the RME is given by a single radial integral:\n    $$\n    \\langle J_f || \\hat{O}(E\\lambda) || J_i \\rangle = \\int_0^\\infty \\delta\\rho_\\lambda(r) r^\\lambda r^2 \\, dr = \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr\n    $$\n    This relation arises from formally carrying out the angular integration in the expression for the matrix element, which projects out the component of the correct multipolarity.\n\n4.  **Final Expression for Computation**: The problem asks for the evaluation of the squared absolute value of the radial integral itself, implying that the geometric factor $(2J_i+1)^{-1}$ is considered to be unity. Thus, the quantity to be calculated is:\n    $$\n    B(E\\lambda) = \\left| \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr \\right|^2\n    $$\n    The units are consistent: $\\delta\\rho_\\lambda(r)$ is in $\\mathrm{fm}^{-3}$, so the integrand has units of $\\mathrm{fm}^{\\lambda-1}$. The integral over $dr$ yields a result in $\\mathrm{fm}^{\\lambda}$. Squaring this gives units of $\\mathrm{fm}^{2\\lambda}$, matching the numerical part of the required units $e^2\\,\\mathrm{fm}^{2\\lambda}$.\n\n### Numerical Quadrature Strategy\n\nThe core task is to compute the integral $I_\\lambda = \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr$ for each test case. The `scipy.integrate.quad` function is an excellent choice for this task.\n\n1.  **Infinite Interval**: `quad` natively supports infinite integration limits by using a variable transformation to map $[0, \\infty)$ to a finite interval, where standard adaptive quadrature techniques are effective. This is suitable for integrands that decay sufficiently fast, a condition met by all test cases.\n\n2.  **Integrand Behavior**:\n    -   **Near $r=0$**: The term $r^{\\lambda+2}$ ensures that the integrand smoothly approaches zero as $r \\to 0$ for all cases (since $\\lambda \\geq 0$), preventing numerical issues at the lower bound.\n    -   **As $r \\to \\infty$**:\n        -   Cases A and B show exponential decay, which is handled very efficiently by `quad`.\n        -   Case C features a damped oscillatory term. The exponential damping ensures the oscillations die out, and the adaptive nature of `quad` will increase the density of evaluation points in the oscillatory region to maintain accuracy.\n        -   Case D has a power-law tail ($\\sim r^{-6}$). The overall integrand behaves as $r^{-3}$ for large $r$. This integral converges, and `quad`'s algorithm for infinite intervals is well-suited for this type of decay.\n\n3.  **Accuracy and Error Control**: The `quad` function provides adaptive subdivision of the integration interval to achieve specified absolute and relative error tolerances. Using the default tolerances is generally sufficient for the precision required in physics problems. This strategy is robust and applicable to all the varied forms of transition densities provided in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Derives and computes the reduced transition probability B(Eλ)\n    for a set of test cases based on a radial transition density.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary with parameters for lambda and the transition density.\n    test_cases = [\n        {\n            \"case_id\": \"A\",\n            \"lambda\": 2,\n            \"density_func\": lambda r, p: p['rho0'] * np.exp(-r / p['a']),\n            \"params\": {\"rho0\": 0.02, \"a\": 1.2}\n        },\n        {\n            \"case_id\": \"B\",\n            \"lambda\": 0,\n            \"density_func\": lambda r, p: p['rho0'] * np.exp(-r / p['a']),\n            \"params\": {\"rho0\": 0.02, \"a\": 1.2}\n        },\n        {\n            \"case_id\": \"C\",\n            \"lambda\": 3,\n            \"density_func\": lambda r, p: p['rho0'] * spherical_jn(0, p['k'] * r) * np.exp(-r / p['R']),\n            \"params\": {\"rho0\": 0.01, \"k\": 1.0, \"R\": 5.0} \n        },\n        {\n            \"case_id\": \"D\",\n            \"lambda\": 1,\n            \"density_func\": lambda r, p: p['rho0'] / (1 + (r / p['R'])**6),\n            \"params\": {\"rho0\": 0.03, \"R\": 3.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        lam = case[\"lambda\"]\n        density_func = case[\"density_func\"]\n        params = case[\"params\"]\n\n        # The integrand for the radial integral is δρ_λ(r) * r^(λ+2)\n        integrand = lambda r: density_func(r, params) * (r**(lam + 2))\n\n        # Perform the numerical quadrature over r from 0 to infinity.\n        # quad returns a tuple (integral_value, estimated_error).\n        # We only need the integral value.\n        radial_integral_val, _ = quad(integrand, 0, np.inf)\n\n        # The reduced transition probability B(Eλ) is the square of the\n        # absolute value of this radial integral.\n        # The units are implicitly e^2 fm^(2λ).\n        b_e_lambda = np.abs(radial_integral_val)**2\n        \n        results.append(b_e_lambda)\n\n    # Final print statement in the exact required format.\n    # The output format is a single line with a comma-separated list of floats\n    # enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}