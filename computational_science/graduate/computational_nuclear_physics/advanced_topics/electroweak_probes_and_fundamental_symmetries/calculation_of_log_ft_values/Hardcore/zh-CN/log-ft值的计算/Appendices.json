{
    "hands_on_practices": [
        {
            "introduction": "计算$\\log_{10}ft$值的核心在于准确评估相空间因子$f$。该因子通过一个在允许的电子能量范围内的积分来定义。然而，对于低$Q$值衰变，积分区间变得极小，被积函数在积分下限附近表现出数值刚性，直接的数值计算会面临精度损失和不稳定的挑战。本练习  旨在通过变量替换和对被积函数的项进行重组，引导你掌握处理此类数值难题的关键技术，为更复杂的计算打下坚实的基础。",
            "id": "3547408",
            "problem": "你的任务是实现一个计算程序，用于评估容许β-衰变的比较半衰期量值，具体来说，是计算统计速率函数与分半衰期乘积的常用对数（通常称为“log-ft”值）。你的程序必须解决在低终端能量衰变中出现的数值刚性问题，并且必须在一系列多样化的测试用例中产生数值稳定的输出。\n\n从费米黄金定则和容许近似出发，衰变率可以表示为一个核结构因子和一个轻子相空间因子的乘积。比较半衰期分离出了相空间分量。在以电子静止能量（即 $m_{e} c^{2}$）为标度的无量纲电子能量单位中（即 $W \\equiv E_{e}/(m_{e} c^{2})$），定义终端点 $W_{0}$ 为 $W_{0} = 1 + Q/(m_{e} c^{2})$，其中 $Q$ 是Q值。对于一个容许跃迁（形状因子等于1），统计速率函数 $f$ 由轻子相空间积分给出\n$$\nf(Z,Q) = \\int_{1}^{W_{0}} F(Z,W)\\, p\\, W\\, (W_{0} - W)^{2} \\, dW,\n$$\n其中 $p = \\sqrt{W^{2}-1}$ 是以 $m_{e} c$ 为单位的电子动量，$F(Z,W)$ 是针对电荷为 $Z$ 的子核进行β-发射的库仑修正（费米函数）。为了模拟库仑畸变，使用经过充分检验的近似\n$$\nF(Z,W) \\approx \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\eta \\equiv \\frac{\\alpha Z W}{p},\n$$\n其中 $\\alpha$ 是精细结构常数，$e$ 是自然对数的底。以数值稳定的方式实现此表达式，特别是在小 $p$ 的情况下，通过直接计算组合项 $p\\,F(Z,W)$ 来避免因相消而导致的有效数字损失。使用以千电子伏特为单位的电子静止能量 $m_{e} c^{2} = 510.99895\\,\\text{keV}$ 和精细结构常数 $\\alpha = 1/137.035999084$。\n\n给定统计速率函数 $f$ 和半衰期 $t_{1/2}$，将比较半衰期定义为 $f\\,t_{1/2}/b$，其中 $b$ 是跃迁的分支比，表示为0到1之间的纯小数。你的任务是计算\n$$\n\\log_{10}\\!\\left( f(Z,Q)\\,\\frac{t_{1/2}}{b} \\right).\n$$\n你必须设计一个鲁棒的计算方法，以应对在电子静止能量阈值附近的低 $Q$ 值情况，此时积分域 $[1,W_{0}]$ 变得非常小，被积函数呈现数值刚性。为此，你必须执行变量变换，将积分映射到固定区间，并解析地分离出小的尺度因子。此外，你必须使用一种代数上等价但数值上稳定的形式来计算 $p\\,F(Z,W)$，该形式在 $p \\to 0^{+}$ 时保持有限。\n\n请精确实现以下要求：\n- 使用变量代换 $W = 1 + (W_{0}-1)\\,x$，$x \\in [0,1]$，从而\n$$\nf(Z,Q) = (W_{0}-1)^{3}\\int_{0}^{1} \\left[ p(W)\\,F(Z,W) \\right]\\, W\\, (1-x)^{2}\\, dx,\n$$\n其中 $W = 1 + (W_{0}-1)\\,x$ 且 $p(W) = \\sqrt{W^{2}-1}$，以此将积分正则化到固定域上，并解析地捕捉 $(W_{0}-1)$ 的小量特性。\n- 使用\n$$\np(W)\\,F(Z,W) = \\frac{2\\pi\\,\\alpha\\,Z\\,W}{1 - \\exp\\!\\left(-2\\pi\\,\\alpha\\,Z\\,W/p(W)\\right)},\n$$\n来计算 $p(W)\\,F(Z,W)$，并对小自变量情况，通过函数 $\\operatorname{expm1}$ 对分母进行数值稳定的实现。在 $Z=0$ 的特殊情况下，设 $F(Z,W)=1$，因此 $p(W)\\,F(Z,W)=p(W)$。\n- 将所有Q值视为以千电子伏特（keV）为单位，所有半衰期视为以秒为单位，分支比视为无量纲小数。输出必须是 $\\log_{10}(f\\,t_{1/2}/b)$，不带单位。\n- 使用双精度浮点运算。对于典型情况，你的数值积分必须至少精确到约 $10^{-9}$ 的相对容差；对于近阈值情况，使用适当的绝对容差处理。\n\n测试套件。你的程序必须计算以下五个案例的输出：\n- 案例A（典型容许，中等 $Z$）：$Z = 20$, $Q = 3000.0\\,\\text{keV}$, $t_{1/2} = 10.0\\,\\text{s}$, $b = 1.0$。\n- 案例B（低 $Q$ 容许，类氚）：$Z = 1$, $Q = 18.6\\,\\text{keV}$, $t_{1/2} = 3.888\\times 10^{8}\\,\\text{s}$, $b = 1.0$。\n- 案例C（低 $Q$ 压力测试，玩具容许模型）：$Z = 30$, $Q = 100.0\\,\\text{keV}$, $t_{1/2} = 1.0\\times 10^{6}\\,\\text{s}$, $b = 1.0$。\n- 案例D（近阈值刚性，玩具容许模型）：$Z = 50$, $Q = 1.0\\,\\text{keV}$, $t_{1/2} = 1.0\\times 10^{12}\\,\\text{s}$, $b = 1.0$。\n- 案例E（高 $Z$ 库仑效应）：$Z = 82$, $Q = 1000.0\\,\\text{keV}$, $t_{1/2} = 1.0\\times 10^{4}\\,\\text{s}$, $b = 0.5$。\n\n最终输出规范：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上述案例相同。每个值必须四舍五入到六位小数。例如，一个包含三个值的输出应如下所示：$[4.321000,5.432100,6.543210]$。",
            "solution": "该问题是有效的。它提出了一个适定的、有科学依据的核物理计算任务。所有必需的物理量、常数和计算约束都得到了清晰的定义并且是自洽的。该问题解决了一个真正的数值挑战——评估β衰变相空间积分，特别是在低能区——并指定了标准的、适当的技术来确保解决方案的稳定性和准确性。\n\n目标是计算比较半衰期的对数，即log-ft值，定义为 $\\log_{10}(f t_{1/2}/b)$。问题的核心是计算统计速率函数 $f(Z, Q)$，它表示发射出的电子和反中微子可用的积分相空间，该相空间受到电子与子核之间库仑相互作用的调制。\n\n对于容许的β-衰变，统计速率函数由以下积分给出：\n$$\nf(Z,Q) = \\int_{1}^{W_{0}} F(Z,W)\\, p\\, W\\, (W_{0} - W)^{2} \\, dW\n$$\n这里，所有与能量相关的量都通过电子静止能量 $m_e c^2 \\approx 510.99895\\,\\text{keV}$ 进行缩放，从而无量纲化。电子的总能量是 $W$，其动量是 $p = \\sqrt{W^2 - 1}$，其最大可能能量（终端点）是 $W_0 = 1 + Q/(m_e c^2)$，其中 $Q$ 是衰变能。函数 $F(Z,W)$ 是费米函数，用于修正电荷为 $Z$ 的子核对电子波函数的库仑畸变。这里使用了一个常用且精确的 $F(Z,W)$ 近似：\n$$\nF(Z,W) \\approx \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\text{其中} \\quad \\eta = \\frac{\\alpha Z W}{p}\n$$\n并且 $\\alpha \\approx 1/137.035999084$ 是精细结构常数。\n\n在计算此积分时出现了两个主要的数值挑战：\n1.  **缩小的积分域**：对于低Q值，终端点 $W_0$ 非常接近1，使得积分区间 $[1, W_0]$ 变得极小。这可能导致标准数值积分程序的精度损失。为缓解此问题，采用了变量代换：$W = 1 + (W_0 - 1)x$。这将缩小的区间 $[1, W_0]$ 映射到新积分变量 $x$ 的固定区间 $[0, 1]$。微分变为 $dW = (W_0 - 1)dx$，动能项变为 $(W_0 - W)^2 = (W_0 - 1)^2 (1 - x)^2$。相空间的小量特性随后被一个前置因子 $(W_0 - 1)^3$ 解析地捕捉，从而得到正则化积分：\n    $$\n    f(Z,Q) = (W_{0}-1)^{3}\\int_{0}^{1} \\left[ p(W)\\,F(Z,W) \\right]\\, W\\, (1-x)^{2}\\, dx\n    $$\n2.  **被积函数的数值稳定性**：项 $p F(Z,W)$ 的计算可能不稳定。当 $W \\to 1$（或 $x \\to 0$）时，动量 $p \\to 0$，导致费米函数中的项 $\\eta$ 发散。为避免除零错误并保持精度，乘积 $p F(Z,W)$ 被代数上重排成一个稳定形式：\n    $$\n    p(W)\\,F(Z,W) = p(W) \\frac{2\\pi \\frac{\\alpha Z W}{p(W)}}{1 - \\exp\\left(-2\\pi \\frac{\\alpha Z W}{p(W)}\\right)} = \\frac{2\\pi\\alpha Z W}{1 - \\exp\\left(-2\\pi\\alpha Z W / p(W)\\right)}\n    $$\n    在极限 $p \\to 0$ 时，此表达式正确且稳定地趋近于有限值 $2\\pi\\alpha Z W$。此外，对于大 $p$，指数的参数 $y = 2\\pi\\alpha Z W / p$ 可能变得很小。直接计算 $1 - e^{-y}$ 可能会遭受灾难性抵消。这个问题通过使用库函数 $\\operatorname{expm1}(x)$ 来解决，该函数能为小的 $|x|$ 精确计算 $e^x - 1$。分母被计算为 $-(\\exp(-y) - 1) = -\\operatorname{expm1}(-y)$。\n\n计算步骤如下：\n1.  定义物理常数 $m_e c^2$ 和 $\\alpha$。\n2.  对于每个测试用例 $(Z, Q, t_{1/2}, b)$，计算无量纲的终端点能量 $W_0$。\n3.  基于变换后的积分，定义一个关于变量 $x$ 的被积函数。该函数计算 $W(x)$、动量 $p(W)$ 以及使用上述数值稳定方法计算的项 $p(W)F(Z,W)$。它能正确处理 $Z=0$ 的特殊情况和 $x=0$ ($p=0$) 的极限。\n4.  使用一个高精度的数值求积程序（`scipy.integrate.quad`）来计算该函数在区间 $[0, 1]$ 上的积分。设置适当的绝对和相对误差容差（$epsabs=10^{-15}$, $epsrel=10^{-10}$）以确保准确性，特别是对于积分值很小的近阈值情况。\n5.  通过将积分结果乘以 $(W_0 - 1)^3$ 来计算最终的统计速率函数 $f(Z,Q)$。\n6.  将 $f(Z,Q)$ 与分半衰期 $t_{1/2}/b$ 相乘来计算ft值。\n7.  取结果的以10为底的对数，即 $\\log_{10}(ft)$，并将其格式化为六位小数。\n\n该方法论实现了所有要求，为一系列物理场景提供了log-ft值的鲁棒且准确的计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import expm1\n\ndef solve():\n    \"\"\"\n    Calculates and prints log-ft values for a set of beta-minus decay test cases.\n    \"\"\"\n    # Define physical constants as specified in the problem statement.\n    M_E_C2_KEV = 510.99895\n    ALPHA = 1.0 / 137.035999084\n\n    def integrand_func(x, Z, W0):\n        \"\"\"\n        Computes the value of the integrand for the transformed phase-space integral.\n        The integration variable is x, which ranges from 0 to 1.\n        \n        Args:\n            x (float): The integration variable.\n            Z (int): The charge of the daughter nucleus.\n            W0 (float): The dimensionless endpoint energy.\n        \n        Returns:\n            float: The value of the integrand at x.\n        \"\"\"\n        # At the upper integration limit x=1, the (1-x)^2 term makes the integrand zero.\n        if x == 1.0:\n            return 0.0\n\n        # Apply the change of variables: W(x) = 1 + (W0 - 1) * x\n        delta_W = W0 - 1.0\n        W = 1.0 + delta_W * x\n\n        # Handle the lower integration limit x=0 where momentum p=0.\n        if x == 0.0:\n            if Z == 0:\n                # If there's no Coulomb interaction, the integrand is zero at p=0.\n                return 0.0\n            # The limiting value of p*F(Z,W) as p-0 is 2*pi*alpha*Z*W.\n            # At x=0, W=1.\n            pF_limit = 2.0 * np.pi * ALPHA * Z\n            # The full integrand is pF * W * (1-x)^2.\n            return pF_limit * 1.0 * (1.0)**2\n\n        # For x  0:\n        # Calculate electron momentum p = sqrt(W^2 - 1) using a numerically stable form.\n        p_squared = (W - 1.0) * (W + 1.0)\n        p = np.sqrt(p_squared)\n\n        # Calculate the product p * F(Z, W) using the specified numerically stable expression.\n        if Z == 0:\n            p_times_F = p\n        else:\n            # For 1 - exp(-y), use -expm1(-y) to maintain precision when y is small.\n            # y = 2*pi*alpha*Z*W / p\n            numerator = 2.0 * np.pi * ALPHA * Z * W\n            arg_exp = -numerator / p\n            denominator = -expm1(arg_exp)\n            p_times_F = numerator / denominator\n        \n        # The full integrand expression is [p*F] * W * (1-x)^2.\n        return p_times_F * W * (1.0 - x)**2\n\n    def calculate_log_ft(Z, Q, t_half, b):\n        \"\"\"\n        Calculates the log-ft value for a single beta decay case.\n        \"\"\"\n        # Beta decay is energetically forbidden if Q = 0.\n        if Q = 0:\n            return np.nan\n\n        # Dimensionless endpoint energy.\n        W0 = 1.0 + Q / M_E_C2_KEV\n        delta_W = W0 - 1.0\n        \n        # Numerically evaluate the transformed integral.\n        integral_val, _ = quad(\n            integrand_func,\n            0,\n            1,\n            args=(Z, W0),\n            epsabs=1e-15,  # Small absolute tolerance for near-threshold cases.\n            epsrel=1e-10   # High relative tolerance for accuracy.\n        )\n        \n        # Calculate the statistical rate function f(Z,Q) = (W0 - 1)^3 * Integral.\n        f_val = (delta_W**3) * integral_val\n        \n        # The branching fraction must be positive.\n        if b = 0:\n            return np.nan\n        \n        # The ft value is f * t_partial, where t_partial = t_half / b.\n        ft_value = f_val * (t_half / b)\n        \n        # The log is only defined for positive ft values.\n        if ft_value = 0:\n            return np.nan\n            \n        return np.log10(ft_value)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Z_daughter, Q_keV, t_half_s, branching_fraction)\n        (20, 3000.0, 10.0, 1.0),      # Case A\n        (1, 18.6, 3.888e8, 1.0),      # Case B\n        (30, 100.0, 1.0e6, 1.0),      # Case C\n        (50, 1.0, 1.0e12, 1.0),       # Case D\n        (82, 1000.0, 1.0e4, 0.5),     # Case E\n    ]\n    \n    results = []\n    for case in test_cases:\n        Z, Q, t_half, b = case\n        log_ft = calculate_log_ft(Z, Q, t_half, b)\n        results.append(f\"{log_ft:.6f}\")\n        \n    # Print the results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了允许跃迁的相空间积分计算之后，我们可以将此框架扩展到描述禁戒跃迁。与允许跃迁不同，禁戒跃迁中出射的轻子对会带走轨道角动量，这导致相空间分布发生改变，需要引入一个能量依赖的形状因子$C(W)$来描述。本练习  将指导你如何将适用于唯一禁戒跃迁的特定形状因子纳入积分计算中，从而让你体会到相空间积分形式在描述不同衰变类型时的普适性与灵活性。",
            "id": "3547481",
            "problem": "您的任务是实现一个程序，用于计算比较半衰期（通常称为 log-ft 值）的以10为底的对数。这些比较半衰期是针对在计算核物理学中被视为单禁戒跃迁的β衰变跃迁。计算必须从费米β衰变理论出发，通过推导适用于单禁戒跃迁的无量纲相空间积分，然后将其与分支半衰期结合以获得最终量。所有数学实体必须用电子静止质量能量和精细结构常数一致地表示，并且程序必须在一系列具有科学意义的测试用例中产生数值稳定的结果。\n\n从以下基本原理开始。单位电子总能量 $W$（以电子静止质量能量 $m_e c^2$ 为单位）的β衰变能谱率由下式给出\n$$\n\\frac{d\\lambda}{dW} \\propto p \\, W \\, (W_0 - W)^2 \\, F(Z, W)\\, C(W),\n$$\n其中 $p$ 是以 $m_e c$ 为单位的电子动量，$W$ 是以 $m_e c^2$ 为单位的电子总能量，$W_0$ 是同样以 $m_e c^2$ 为单位的终点能量，$Z$ 是子核的原子序数，$F(Z,W)$ 是考虑了出射电子波函数库仑畸变的费米函数，$C(W)$ 是由核跃迁类型决定的形状因子。电子动量为 $p = \\sqrt{W^2 - 1}$，对于近似无质量的反中微子，中微子动量取为 $q = W_0 - W$。终点能量为 $W_0 = 1 + Q/(m_e c^2)$，其中 $Q$ 是以兆电子伏特为单位的β衰变 $Q$ 值。\n\n比较半衰期采用由积分定义的无量纲相空间因子 $f$\n$$\nf(Z, Q; \\text{type}) = \\int_{W=1}^{W_0} p \\, W \\, (W_0 - W)^2 \\, F(Z, W) \\, C(W; \\text{type}) \\, dW.\n$$\n然后，以10为底的 log-ft 值为\n$$\n\\log_{10} f t = \\log_{10} \\left( f(Z, Q; \\text{type}) \\times t_p \\right),\n$$\n其中分支半衰期 $t_p$ 通过 $t_p = t_{1/2}/B$ 与总半衰期 $t_{1/2}$ 和分支比 $B$ 相关联。量 $\\log_{10} f t$ 是无量纲的，但 $t_{1/2}$ 和 $t_p$ 必须以秒为单位提供，$Q$ 必须以兆电子伏特为单位提供。分支比 $B$ 必须以小数形式提供。\n\n对于费米函数，使用广泛采用的近似\n$$\nF(Z, W) = \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\eta = \\alpha Z \\frac{W}{p},\n$$\n其中 $\\alpha$ 是精细结构常数。这个近似适用于忽略了有限核尺寸修正和屏蔽修正的β⁻衰变，对于当前的计算练习是可以接受的。\n\n处理以下跃迁类型及相关的形状因子：\n- 容许跃迁（$\\text{type} = \\text{U0}$），其形状因子为\n$$\nC(W; \\text{U0}) = 1.\n$$\n- 单一番禁戒跃迁（$\\text{type} = \\text{U1}$），其形状因子为\n$$\nC(W; \\text{U1}) = p^2 + q^2.\n$$\n- 单二禁戒跃迁（$\\text{type} = \\text{U2}$），其形状因子为\n$$\nC(W; \\text{U2}) = p^4 + \\frac{10}{3} p^2 q^2 + q^4.\n$$\n\n使用稳健的求积方法实现 $f(Z, Q; \\text{type})$ 在 $W \\in [1, W_0]$ 上的数值积分。确保在边界 $W = 1$（此时 $p \\to 0$）和 $W = W_0$（此时 $q \\to 0$）处的数值稳定性，并确保在 $p$ 很小时稳定地处理库仑因子。程序必须为一系列科学上合理的测试用例计算 $\\log_{10} f t$ 并打印结果。\n\n使用的常数和单位：\n- 电子静止质量能量 $m_e c^2 = 0.51099895 \\, \\text{MeV}$。\n- 精细结构常数 $\\alpha = 1/137.035999084$。\n- 所有半衰期 $t_{1/2}$ 以秒为单位，所有分支比 $B$ 以小数形式提供，所有 $Q$ 值以兆电子伏特为单位。\n\n测试用例参数值：\n- 案例1（一般单一番禁戒跃迁，中等 $Z$ 和 $Q$）：$Z = 26$, $A = 59$, $Q = 1.823 \\, \\text{MeV}$, $t_{1/2} = 44.5 \\, \\text{s}$, $B = 0.85$, $\\text{type} = \\text{U1}$。\n- 案例2（边界低 $Q$ 值单一番禁戒跃迁，高 $Z$）：$Z = 50$, $A = 115$, $Q = 0.120 \\, \\text{MeV}$, $t_{1/2} = 3.0 \\times 10^{7} \\, \\text{s}$, $B = 1.0$, $\\text{type} = \\text{U1}$。\n- 案例3（单二禁戒跃迁，高 $Z$）：$Z = 82$, $A = 214$, $Q = 2.000 \\, \\text{MeV}$, $t_{1/2} = 1.0 \\times 10^{5} \\, \\text{s}$, $B = 0.6$, $\\text{type} = \\text{U2}$。\n- 案例4（容许跃迁，用于比较，低 $Z$）：$Z = 8$, $A = 14$, $Q = 3.000 \\, \\text{MeV}$, $t_{1/2} = 70.0 \\, \\text{s}$, $B = 1.0$, $\\text{type} = \\text{U0}$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是对应案例计算出的 $\\log_{10} f t$ 值，按上述顺序列出，并四舍五入到六位小数。例如，它应该打印一个形式为 $[\\ell_1,\\ell_2,\\ell_3,\\ell_4]$ 的字符串，其中每个 $\\ell_i$ 是一个小数点后有六位数的小数。",
            "solution": "β衰变比较半衰期的计算基于 Fermi 理论，其中微分衰变率 $\\frac{d\\lambda}{dW}$ 取决于可用相空间以及被子核库仑场畸变的轻子波函数。基础表达式\n$$\n\\frac{d\\lambda}{dW} \\propto p \\, W \\, (W_0 - W)^2 \\, F(Z, W)\\, C(W),\n$$\n源自费米黄金定则和对出射轻子的相对论处理。此处 $W$ 是以 $m_e c^2$ 为单位的电子总能量，$p = \\sqrt{W^2 - 1}$ 是以 $m_e c$ 为单位的电子动量，而 $q = W_0 - W$ 是在中微子质量可忽略不计的近似下的中微子动量。终点能量 $W_0 = 1 + Q/(m_e c^2)$ 直接由能量守恒得出，其中 $Q$ 是以兆电子伏特为单位的β衰变能量。\n\n无量纲相空间积分\n$$\nf(Z, Q; \\text{type}) = \\int_{1}^{W_0} p \\, W \\, (W_0 - W)^2 \\, F(Z, W)\\, C(W; \\text{type}) \\, dW\n$$\n汇集了运动学效应、库仑效应以及由核跃迁算符引起的光谱畸变。费米函数 $F(Z, W)$ 体现了发射的电子与子核之间的库仑吸引力。虽然精确处理涉及带有有限核尺寸修正的 Dirac 方程的解，但一个适用于计算目的、被广泛使用且稳定的近似是\n$$\nF(Z, W) = \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}, \\quad \\eta = \\alpha Z \\frac{W}{p},\n$$\n其中 $\\alpha$ 是精细结构常数。在阈值 $W \\to 1$ 附近，$p \\to 0$，$\\eta$ 变得很大，使得 $F \\approx 2\\pi \\eta$；因此乘积 $p F \\approx 2\\pi \\alpha Z W$ 保持有限，确保了积分的良好数值行为。\n\n能谱形状因子 $C(W)$ 取决于核跃迁类型。对于容许跃迁，轻子对不携带轨道角动量，可得 $C(W; \\text{U0}) = 1$。对于单禁戒跃迁，一个阶数等于禁戒度的单一核算符决定了能谱；形状因子成为一个关于 $p^2$ 和 $q^2$ 的多项式，其系数由角动量耦合和相对论流结构确定。对于单一番禁戒跃迁，我们得到\n$$\nC(W; \\text{U1}) = p^2 + q^2,\n$$\n而对于单二禁戒跃迁，形状因子为\n$$\nC(W; \\text{U2}) = p^4 + \\frac{10}{3} p^2 q^2 + q^4.\n$$\n这些表达式源于弱相互作用哈密顿量的多极展开，并要求轻子系统携带的轨道角动量与核算符的阶数相匹配，且与总自旋转移一致地耦合。\n\n比较半衰期是通过将运动学积分与分支半衰期 $t_p = t_{1/2}/B$ 结合而构建的，其中 $t_{1/2}$ 是以秒为单位的总半衰期，$B$ 是以小数形式提供的分支比。常规量\n$$\n\\log_{10} f t = \\log_{10} \\left( f(Z, Q; \\text{type}) \\times t_p \\right)\n$$\n是无量纲的。尽管在完整的理论中，$t_p$ 也依赖于核矩阵元的平方和耦合常数，但 $\\log_{10} f t$ 的定义有意地分离出运动学积分，以便于对不同跃迁进行经验比较。\n\n算法设计：\n- 定义常数 $m_e c^2 = 0.51099895 \\, \\text{MeV}$ 和 $\\alpha = 1/137.035999084$。\n- 对于给定的 $Z$、$Q$ 和跃迁类型，计算 $W_0 = 1 + Q/(m_e c^2)$。\n- 实现被积函数 $I(W) = p \\, W \\, (W_0 - W)^2 \\, F(Z, W) \\, C(W; \\text{type})$，其中 $p = \\sqrt{W^2 - 1}$ 且 $q = W_0 - W$。\n- 实现 $F(Z,W)$ 为 $F = \\frac{2\\pi \\eta}{1 - e^{-2\\pi \\eta}}$，其中 $\\eta = \\alpha Z \\frac{W}{p}$。为避免当 $p$ 极小时出现除零错误，在计算 $\\eta$ 时，通过将其替换为 $p_\\epsilon = \\max(p, \\epsilon)$ 来限制 $p$ 的值，其中 $\\epsilon$ 是一个小的正数，例如 $\\epsilon = 10^{-12}$。这样做可以保持正确的极限行为，因为 $p F$ 保持有限。\n- 使用具有适当绝对和相对容差的自适应求积法，对 $I(W)$ 在 $W \\in [1, W_0]$ 区间上进行数值积分。由于 $(W_0 - W)^2$ 因子的存在，被积函数在 $W = W_0$ 处为零；如上所述，在 $W = 1$ 附近，被积函数保持有限。\n- 计算以秒为单位的 $t_p = t_{1/2}/B$，然后使用以10为底的对数计算 $\\log_{10} f t$。\n- 对最终输出应用四舍五入，保留六位小数。\n\n测试用例注意事项：\n- 案例1测试一个具有中等 $Z$ 和 $Q$ 值的一般单一番禁戒跃迁。\n- 案例2测试低 $Q$ 值的边界情况，此时相空间受到严重限制，并检查在短积分范围和显著库仑畸变下的数值稳定性。\n- 案例3测试一个高 $Z$ 值的单二禁戒跃迁，检验多项式形状因子和库仑增强效应。\n- 案例4提供一个容许跃迁用于比较，以验证当 $C(W) = 1$ 时，代码能简化为典型的容许谱形状。\n\n程序将计算并以 $[\\ell_1,\\ell_2,\\ell_3,\\ell_4]$ 的格式单行打印结果，其中每个 $\\ell_i$ 是对应案例计算出的 $\\log_{10} f t$ 值，四舍五入到六位小数，以确保输出简洁且可测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Constants\nME_MEV = 0.51099895  # electron rest mass energy in MeV\nALPHA = 1.0 / 137.035999084  # fine-structure constant\n\ndef fermi_function(Z: float, W: float, p: float) - float:\n    \"\"\"\n    Coulomb Fermi function approximation:\n    F(Z, W) = 2*pi*eta / (1 - exp(-2*pi*eta)), eta = alpha*Z*W/p\n    Uses a small-clamp for p in eta to avoid division by zero at threshold.\n    \"\"\"\n    p_eff = max(p, 1e-12)\n    eta = ALPHA * Z * W / p_eff\n    # For large eta, exp(-2*pi*eta) underflows to 0, which is fine.\n    denom = 1.0 - np.exp(-2.0 * np.pi * eta)\n    # Avoid potential numerical issue if denom is 0 (should not happen for eta  0)\n    if denom == 0.0:\n        return 2.0 * np.pi * eta\n    return (2.0 * np.pi * eta) / denom\n\ndef shape_factor(W: float, W0: float, p: float, transition_type: str) - float:\n    \"\"\"\n    Shape factor C(W) for specified transition type:\n    - U0: Allowed, C = 1\n    - U1: Unique first-forbidden, C = p^2 + q^2\n    - U2: Unique second-forbidden, C = p^4 + (10/3) p^2 q^2 + q^4\n    \"\"\"\n    q = W0 - W\n    if transition_type == 'U0':\n        return 1.0\n    elif transition_type == 'U1':\n        return p**2 + q**2\n    elif transition_type == 'U2':\n        return p**4 + (10.0/3.0) * (p**2) * (q**2) + q**4\n    else:\n        raise ValueError(f\"Unsupported transition type: {transition_type}\")\n\ndef phase_space_integral(Z: float, Q_mev: float, transition_type: str) - float:\n    \"\"\"\n    Compute the dimensionless phase-space factor f(Z, Q; type):\n    f = ∫_{W=1}^{W0} p W (W0 - W)^2 F(Z,W) C(W;type) dW\n    \"\"\"\n    W0 = 1.0 + Q_mev / ME_MEV\n\n    def integrand(W: float) - float:\n        p = np.sqrt(max(W*W - 1.0, 0.0))\n        q = W0 - W\n        F = fermi_function(Z, W, p)\n        C = shape_factor(W, W0, p, transition_type)\n        return p * W * (q**2) * F * C\n\n    # Integrate with adaptive quadrature. Handle narrow ranges robustly.\n    result, err = quad(integrand, 1.0, W0, epsabs=1e-10, epsrel=1e-8, limit=200)\n    return result\n\ndef logft(Z: float, Q_mev: float, t_half_s: float, branch: float, transition_type: str) - float:\n    \"\"\"\n    Compute log10(ft) = log10( f(Z,Q;type) * t_p ), t_p = t_half / branch\n    \"\"\"\n    f_val = phase_space_integral(Z, Q_mev, transition_type)\n    t_p = t_half_s / branch\n    # Avoid log of zero if somehow f_val is numerically zero (should not occur for Q0).\n    ft = max(f_val * t_p, np.finfo(float).tiny)\n    return float(np.log10(ft))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (Z, A, Q [MeV], t_half [s], branch [decimal], transition_type)\n    test_cases = [\n        (26, 59, 1.823, 44.5, 0.85, 'U1'),     # Case 1\n        (50, 115, 0.120, 3.0e7, 1.0, 'U1'),    # Case 2\n        (82, 214, 2.000, 1.0e5, 0.6, 'U2'),    # Case 3\n        (8, 14, 3.000, 70.0, 1.0, 'U0'),       # Case 4\n    ]\n\n    results = []\n    for Z, A, Q_mev, t_half_s, branch, transition_type in test_cases:\n        val = logft(float(Z), float(Q_mev), float(t_half_s), float(branch), transition_type)\n        # Round to six decimal places\n        results.append(f\"{val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "我们计算的准确性不仅取决于数值方法的稳定性，还深刻地依赖于我们所采用的物理模型的精度。在前面的练习中，我们使用了费米函数的标准近似形式，它在许多情况下是有效的。然而，为了实现高精度的$\\log_{10}ft$值计算，尤其是在处理中重核时，必须采用更精确的、源自狄拉克方程的相对论库仑波函数来描述出射电子。本练习  要求你实现这种更复杂的费米函数，并将其结果与标准近似进行比较，从而量化物理模型精度对最终$\\log_{10}ft$值的影响。",
            "id": "3547446",
            "problem": "实现一个完整且可运行的程序，该程序以高数值精度计算核贝塔衰变的统计速率函数（也称为相空间因子），\n$$\nf = \\int_{1}^{W_0} p\\,W\\,(W_0 - W)^2\\,F(Z,W)\\,C(W)\\,dW,\n$$\n其中，$W$ 是以电子静止能量 $m_e c^2$ 为单位的带电轻子总能量，$p=\\sqrt{W^2-1}$ 是以相同单位表示的带电轻子动量，$W_0$ 是以 $m_e c^2$ 为单位的端点总能量，$Z$ 是子核的电荷数，$F(Z,W)$ 是用于说明核场对轻子波函数扭曲效应的库仑函数，$C(W)$ 是形状因子。假设为容許跃迁，因此 $C(W)=1$。目标是：\n- 使用从在核半径处求值的精确狄拉克 (Dirac) 波函数推导出的相对论性库仑函数 $F(Z,W)$ 来计算 $f$（即在锐球半径下进行有限尺寸归一化的点核库仑-狄拉克解）。\n- 使用教科书中的非相对论性费米 (Fermi) (伽莫夫 (Gamow)) 函数再次计算 $f$。\n- 通过报告 $\\Delta \\log ft = \\log_{10} f_{\\mathrm{Dirac}} - \\log_{10} f_{\\mathrm{Gamow}}$ 来量化对比较半衰期量 $\\log ft$ 的影响，其中分支半衰期 $t$ 在差值中被抵消。\n\n您必须使用的基础理论：\n- 从贝塔衰变的费米 (Fermi) 黄金定則以及由上述积分给出的统计速率函数 $f$ 的定义出发。\n- 使用从点库仑场中的狄拉克 (Dirac) 波函数获得、并在核半径处求值的相对论性库仑函数。您必须实现由狄拉克-库仑解所蕴含的、以精细结构常数和伽马 (Gamma) 函数表示的精确闭合形式表达式，不得引入唯象拟合公式。\n- 使用教科书中的非相对论性伽莫夫 (Gamow) 因子进行 $F(Z,W)$ 的比较。\n\n需要使用的定义、单位和常数：\n- 将 $W$ 和 $W_0$ 视为无量纲量，以 $m_e c^2$ 为单位。动量 $p=\\sqrt{W^2-1}$ 也是无量纲的。\n- 对于负贝塔衰变（$\\beta^-$），库仑参数为吸引符号；对于正贝塔衰变（$\\beta^+$），符号相反。在库仑因子中使用子核电荷 $Z$。\n- 使用精细结构常数 $\\alpha = 1/137.035999084$。\n- 使用锐球核半径 $R = r_0 A^{1/3}$，其中 $r_0 = 1.2\\,\\mathrm{fm}$。将 $R$ 除以电子康普顿 (Compton) 波长 $\\lambda_C \\approx 386.1592676\\,\\mathrm{fm}$，从而将其转换为无量纲单位，以便在狄拉克-库仑因子中使用的 $R$ 是以电子康普顿波长为单位的。\n- 假设对于所有能量 $W$，$C(W)=1$。\n\n高精度数值要求：\n- 计算 $f$ 的积分时，绝对容差低于 $10^{-12}$，相对容差低于 $10^{-9}$。\n- 确保在阈值 $W \\to 1$ 附近以及对于大的 $Z$ 值时数值的稳定性。\n- 对于狄拉克情形和伽莫夫情形的函数 $F(Z,W)$，必须在整个积分域内以数值稳定的方式实现。\n\n要实现和计算的测试套件：\n- 每个测试用例都是一个元组 $(Z,A,W_0,\\mathrm{polarity})$，其中 $\\mathrm{polarity}$ 是 $\\beta^-$ 或 $\\beta^+$ 之一，并且 $C(W)=1$。\n- 使用以下科学上合理且多样的案例：\n    1. $(Z,A,W_0,\\mathrm{polarity}) = (26,60,4.0,\\beta^-)$\n    2. $(Z,A,W_0,\\mathrm{polarity}) = (82,214,2.5,\\beta^-)$\n    3. $(Z,A,W_0,\\mathrm{polarity}) = (28,58,2.2,\\beta^+)$\n    4. $(Z,A,W_0,\\mathrm{polarity}) = (8,16,1.1,\\beta^-)$\n    5. $(Z,A,W_0,\\mathrm{polarity}) = (20,40,10.0,\\beta^-)$\n\n对于每个测试用例，计算：\n- $f_{\\mathrm{Dirac}}$，使用来自狄拉克波函数的相对论性库仑函数。\n- $f_{\\mathrm{Gamow}}$，使用教科书中的非相对论性伽莫夫因子。\n- $\\Delta \\log ft = \\log_{10} f_{\\mathrm{Dirac}} - \\log_{10} f_{\\mathrm{Gamow}}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含结果。结果是一个由方括号括起来的三元组的逗号分隔列表，每个测试用例对应一个三元组，顺序与指定顺序相同。每个三元组本身是一个方括号括起来的逗号分隔列表 $[f_{\\mathrm{Dirac}},f_{\\mathrm{Gamow}},\\Delta \\log ft]$。\n- 所有浮点数必须精确到小数点后八位。\n- 例如，您的输出必须如下所示：\n$$\n[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4],[x_5,y_5,z_5]]\n$$\n不含多余的空格或文本。\n\n科学真实性与约束条件：\n- 所有计算必须使用上述定义进行。统计速率函数 $f$ 是无量纲的；报告的所有值均为不带单位的纯数。\n- 程序必须是自包含的，不得读取任何输入，并且必须逐字使用所提供的测试套件。",
            "solution": "该问题要求为一组测试用例计算核贝塔衰变的统计速率函数（或称相空间因子）$f$。此计算必须使用两种不同的库仑修正函数 $F(Z,W)$ 模型来执行：一种是基于狄拉克 (Dirac) 波函数的复杂相对论模型，另一种是更简单的非相对论伽莫夫 (Gamow) 因子。目标是量化这两种模型导致的比较半衰期 $\\log ft$ 的差异。\n\n统计速率函数 $f$ 由以下积分定义：\n$$\nf = \\int_{1}^{W_0} p\\,W\\,(W_0 - W)^2\\,F(Z,W)\\,C(W)\\,dW\n$$\n被积函数的各组成部分定义如下：\n- $W$ 是发射出的轻子（$\\beta^-$ 或 $\\beta^+$）的总能量，以电子静止质量能量 $m_e c^2$ 为单位。\n- $W_0$ 是轻子可能的最大能量，也以 $m_e c^2$ 为单位。它由衰变的 $Q$ 值决定。\n- $p = \\sqrt{W^2-1}$ 是轻子的动量，以 $m_e c$ 为单位。\n- $Z$ 是子核的电荷数。\n- $F(Z,W)$ 是库仑函数（或费米函数），它修正了子核库仑场对轻子波函数的扭曲效应。\n- $C(W)$ 是形状因子，它取决于核矩阵元。对于此处假设的容许跃迁，$C(W)=1$。\n\n$f$ 的积分范围从轻子的最小可能能量（$W=1$，对应零动能）到最大能量（$W=W_0$）。将使用数值积分法进行计算。\n\n问题的核心在于实现 $F(Z,W)$ 的两种指定形式。\n\n**1. 非相对论伽莫夫因子 $F_{\\mathrm{Gamow}}(Z,W)$**\n\n这是库仑修正的教科书近似，源于非相对论量子力学。其表达式为：\n$$\nF_{\\mathrm{Gamow}}(Z,W) = \\frac{2\\pi\\eta}{1 - e^{-2\\pi\\eta}}\n$$\n其中 $\\eta$ 是索末菲 (Sommerfeld) 参数，定义为：\n$$\n\\eta = \\frac{Z_{\\mathrm{eff}}\\alpha W}{p} = \\frac{Z_{\\mathrm{eff}}\\alpha W}{\\sqrt{W^2-1}}\n$$\n- $\\alpha \\approx 1/137.036$ 是精细结构常数。\n- $Z_{\\mathrm{eff}}$ 是轻子感受到的有效电荷。对于 $\\beta^-$ 衰变（电子发射），库仑力是吸引力，因此我们使用子核电荷，$Z_{\\mathrm{eff}}=Z$。对于 $\\beta^+$ 衰变（正电子发射），库仑力是排斥力，因此我们使用 $Z_{\\mathrm{eff}}=-Z$。\n\n一个关键的数值考虑因素是此函数的行为。当 $W \\to 1$ 时，$p \\to 0$，导致 $|\\eta| \\to \\infty$。\n- 对于 $\\beta^-$ 衰变 ($Z_{\\mathrm{eff}}0$)，$\\eta \\to +\\infty$。在此极限下，$e^{-2\\pi\\eta} \\to 0$ 且 $F_{\\mathrm{Gamow}} \\approx 2\\pi\\eta \\propto 1/p$。因此，被积项 $p \\cdot F_{\\mathrm{Gamow}}$ 趋于一个有限常数。\n- 对于 $\\beta^+$ 衰变 ($Z_{\\mathrm{eff}}0$)，$\\eta \\to -\\infty$。在此极限下，$F_{\\mathrm{Gamow}} \\approx -2\\pi\\eta \\, e^{2\\pi\\eta}$，该值迅速趋近于 $0$。在 $W=1$ 处，被积函数为零。\n当 $\\eta \\to 0$ 时（如果 $Z=0$ 则会发生），泰勒 (Taylor) 展开显示 $F_{\\mathrm{Gamow}} \\to 1$。\n\n**2. 相对论狄拉克-库仑因子 $F_{\\mathrm{Dirac}}(Z,W)$**\n\n该因子通过使用库仑势中轻子的狄拉克方程解，提供了一个精确得多的描述。问题指定了一种标准公式，该公式通过在核表面对波函数解进行求值，包含了对原子核有限尺寸的修正。其表达式为：\n$$\nF_{\\mathrm{Dirac}}(Z,W) = 2(1+\\gamma_1) (2pR')^{2(\\gamma_1-1)} \\frac{|\\Gamma(\\gamma_1 + i y)|^2}{(\\Gamma(2\\gamma_1 + 1))^2} e^{\\pi y}\n$$\n此公式中的参数为：\n- $y = \\eta = \\frac{Z_{\\mathrm{eff}}\\alpha W}{p}$。\n- $\\gamma_1 = \\sqrt{1 - (\\alpha Z)^2}$。此处，$Z$ 是子核电荷的绝对值。对于所有已知原子核（$Z \\le 118$），此参数为实数。\n- $R'$ 是无量綱的核半径，通过将物理半径 $R$ 除以电子康普顿 (Compton) 波长 $\\lambda_C \\approx 386.159\\,\\mathrm{fm}$ 得到。物理半径 $R$ 使用锐球模型计算：$R = r_0 A^{1/3}$，其中 $r_0 = 1.2\\,\\mathrm{fm}$，$A$ 是子核的质量数。\n- $\\Gamma(z)$ 是复伽马函数。$|\\Gamma(\\gamma_1 + i y)|^2$ 项需要计算复变元的伽马函数值。\n\n$F_{\\mathrm{Dirac}}$ 在 $W \\to 1$ ($p \\to 0$) 时的数值行为至关重要。由于 $\\gamma_1  1$，指数 $2(\\gamma_1-1)$为负。当 $p \\to 0$ 时，$(2pR')^{2(\\gamma_1-1)}$ 项发散。利用复伽马函数在大 $|y|$ 时的渐近行为 $|\\Gamma(x+iy)|^2 \\approx 2\\pi |y|^{2x-1}e^{-\\pi|y|}$，可以证明 $F_{\\mathrm{Dirac}} \\propto 1/p$。与伽莫夫情形类似，被积函数中的因子 $p$ 消除了这个奇点，使得在积分边界 $W=1$ 处得到一个有限值。这确保了积分是良态的，并且可以使用标准数值积分库（如 `scipy.integrate.quad`）精确计算。\n\n**3. 算法实现与计算**\n\n解决方案将使用 Python 中的 `numpy` 和 `scipy` 库来实现。总体算法如下：\n1. 定义物理常数：$\\alpha$, $r_0$, $\\lambda_C$。\n2. 对于每个测试用例 $(Z, A, W_0, \\mathrm{polarity})$：\n   a. 根据衰变极性确定 $Z_{\\mathrm{eff}}$。\n   b. 定义两个被积函数，一个使用 $F_{\\mathrm{Gamow}}$，另一个使用 $F_{\\mathrm{Dirac}}$。这些函数以 $W$ 为积分变量，并以用例参数（$Z, A, W_0$ 等）为参数。\n   c. 使用 `scipy.integrate.quad` 计算 $f_{\\mathrm{Gamow}}$ 从 $W=1$到 $W=W_0$ 的积分。将使用指定的高精度容差（`epsabs=1e-12`, `epsrel=1e-9`）。\n   d. 类似地，计算 $f_{\\mathrm{Dirac}}$ 的积分。$F_{\\mathrm{Dirac}}$ 的实现需要使用 `scipy.special.gamma` 处理复变元。\n   e. 计算最终量 $\\Delta \\log ft = \\log_{10}(f_{\\mathrm{Dirac}}) - \\log_{10}(f_{\\mathrm{Gamow}})$。该量直接衡量了相对论效应和有限尺寸效应对提取的 $ft$ 值的影响。\n3. 整理所有测试用例计算出的三元组 $[f_{\\mathrm{Dirac}}, f_{\\mathrm{Gamow}}, \\Delta \\log ft]$。\n4. 按照规定格式将最终结果格式化为单个字符串：一个三元组列表，每个数字格式化为八位小数，并将其打印到标准输出。\n这种结构化的方法确保了问题的所有物理和数值要求都得到满足，从而产生精确且可验证的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\nfrom scipy import special\n\n# Set up constants based on the problem statement.\nALPHA = 1 / 137.035999084\nR0_FM = 1.2\nLAMBDA_C_FM = 386.1592676\n\ndef F_gamow(W, Z_eff):\n    \"\"\"\n    Computes the non-relativistic Gamow factor.\n    \"\"\"\n    # For Z_eff = 0, F should be 1. The formula handles this limit.\n    if Z_eff == 0:\n        return 1.0\n\n    # The integrand p * F has a finite limit at W=1, so we do not need special handling here,\n    # as scipy.integrate.quad can handle integrable singularities at endpoints.\n    # We must avoid division by zero if W=1 is ever passed directly.\n    if W == 1.0:\n        return np.inf if Z_eff > 0 else 0.0\n\n    p = np.sqrt(W**2 - 1)\n    if p == 0:\n        return np.inf if Z_eff > 0 else 0.0\n\n    eta = Z_eff * ALPHA * W / p\n    x = 2 * np.pi * eta\n\n    # For small x, use Taylor series expansion to avoid 0/0.\n    # x / (1 - exp(-x)) -> 1 + x/2 + ...\n    if abs(x)  1e-8:\n        return 1.0\n    \n    # Standard formula\n    return x / (1 - np.exp(-x))\n\ndef F_dirac(W, Z_daughter, Z_eff, A):\n    \"\"\"\n    Computes the relativistic Dirac-Coulomb factor.\n    \"\"\"\n    if Z_daughter == 0:\n        return 1.0\n\n    # The integrand p * F has a finite limit at W=1.\n    if W == 1.0:\n        return np.inf\n\n    p = np.sqrt(W**2 - 1)\n    if p == 0:\n        return np.inf\n\n    # Dimensionless nuclear radius\n    R_prime = (R0_FM * A**(1/3)) / LAMBDA_C_FM\n    \n    az_sq = (ALPHA * Z_daughter)**2\n    # This check is for robustness; not expected for test cases.\n    if az_sq >= 1.0:\n      raise ValueError(\"Invalid Z: (alpha*Z)^2 >= 1\")\n    gamma1 = np.sqrt(1.0 - az_sq)\n    \n    # Sommerfeld-like parameter for the Dirac case\n    y = Z_eff * ALPHA * W / p\n\n    # Evaluate the components of the F_dirac formula\n    term1 = 2 * (1 + gamma1)\n    term2 = (2 * p * R_prime)**(2 * (gamma1 - 1))\n    \n    # Gamma function terms. scipy.special.gamma handles complex args.\n    g_complex_arg = gamma1 + 1j * y\n    g_complex = special.gamma(g_complex_arg)\n    abs_g_sq = np.real(g_complex)**2 + np.imag(g_complex)**2\n    \n    g_real_arg = 2 * gamma1 + 1\n    g_real = special.gamma(g_real_arg)\n    \n    term3 = abs_g_sq / (g_real**2)\n    term4 = np.exp(np.pi * y)\n    \n    return term1 * term2 * term3 * term4\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print results for all test cases.\n    \"\"\"\n    # Test suite as specified in the problem statement\n    test_cases = [\n        # (Z_daughter, A_daughter, W0, polarity)\n        (26, 60, 4.0, 'beta-'),\n        (82, 214, 2.5, 'beta-'),\n        (28, 58, 2.2, 'beta+'),\n        (8, 16, 1.1, 'beta-'),\n        (20, 40, 10.0, 'beta-'),\n    ]\n\n    results = []\n    \n    # Numerical integration tolerances\n    epsabs = 1e-12\n    epsrel = 1e-9\n\n    for case in test_cases:\n        Z_daughter, A, W0, polarity = case\n        Z_eff = Z_daughter if polarity == 'beta-' else -Z_daughter\n\n        # Integrand using the Gamow factor\n        def integrand_gamow(W, Z_eff, W0):\n            if W = 1.0 or W >= W0: return 0.0\n            p = np.sqrt(W**2 - 1)\n            F = F_gamow(W, Z_eff)\n            return p * W * (W0 - W)**2 * F\n        \n        # Integrand using the Dirac factor\n        def integrand_dirac(W, Z_daughter, Z_eff, A, W0):\n            if W = 1.0 or W >= W0: return 0.0\n            p = np.sqrt(W**2 - 1)\n            F = F_dirac(W, Z_daughter, Z_eff, A)\n            return p * W * (W0 - W)**2 * F\n\n        # Perform numerical integration for both models\n        f_gamow, _ = integrate.quad(integrand_gamow, 1, W0, args=(Z_eff, W0), epsabs=epsabs, epsrel=epsrel)\n        f_dirac, _ = integrate.quad(integrand_dirac, 1, W0, args=(Z_daughter, Z_eff, A, W0), epsabs=epsabs, epsrel=epsrel)\n        \n        # Calculate the difference in log(ft)\n        delta_log_ft = np.log10(f_dirac) - np.log10(f_gamow)\n        \n        results.append([f_dirac, f_gamow, delta_log_ft])\n        \n    # Format the output as per the problem specification\n    results_as_strings = [\n        f\"[{res[0]:.8f},{res[1]:.8f},{res[2]:.8f}]\" for res in results\n    ]\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}