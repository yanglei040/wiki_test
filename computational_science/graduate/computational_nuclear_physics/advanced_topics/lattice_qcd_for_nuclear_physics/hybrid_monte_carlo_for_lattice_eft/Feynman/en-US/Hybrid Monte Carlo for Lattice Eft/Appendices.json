{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of using Monte Carlo methods for theories with fermions is that the fermion determinant, which arises from integrating out the Grassmann fields, must be a positive real number to be interpreted as a probability weight. For theories like nuclear EFT, this property is guaranteed by symmetries that pair fermion species. This first practice  offers a direct, hands-on calculation with a minimal $2 \\times 2$ matrix to demonstrate exactly how this works, solidifying your understanding of this foundational concept.",
            "id": "3563899",
            "problem": "Consider a minimal illustration of the fermion matrix structure used in Hybrid Monte Carlo (HMC) for Lattice Effective Field Theory (EFT) with two degenerate spin-isospin species on a one-dimensional spatial lattice. Start from the Euclidean lattice path integral for nonrelativistic nucleons with a static background Hubbard-Stratonovich (HS) auxiliary field, where Grassmann integration of a quadratic fermion action produces a fermion determinant. On a spatial lattice of $L = 2$ sites with periodic boundary conditions and a single Euclidean time slice, take the single-species fermion matrix to be the site-space matrix\n$$\nM(\\kappa,\\lambda) \\equiv \\mathbb{1} - \\kappa H - i \\lambda D,\n$$\nwhere $H$ encodes nearest-neighbor hopping and $D$ encodes a site-diagonal HS field configuration. Let\n$$\nH \\equiv \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad D \\equiv \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}.\n$$\nFor two degenerate spin-isospin species related by time-reversal (or equivalently a complex-conjugation symmetry of the quadratic form), the second species has the complex-conjugate single-species matrix $M(\\kappa,\\lambda)^{*}$, so that the combined two-species fermion matrix in site-space is the block-diagonal matrix\n$$\n\\mathcal{M}(\\kappa,\\lambda) \\equiv \\begin{pmatrix} M(\\kappa,\\lambda) & 0 \\\\ 0 & M(\\kappa,\\lambda)^{*} \\end{pmatrix}.\n$$\nUsing only the above definitions and the fact that Grassmann integration of a quadratic fermion action yields the determinant of the fermion matrix as the weight, construct explicitly $\\mathcal{M}(\\kappa,\\lambda)$ for the parameter choice $\\kappa = \\frac{1}{2}$ and $\\lambda = 1$, identify the eigenvalues of $M(\\kappa,\\lambda)$ to demonstrate complex-conjugate pairing, and compute the determinant of the two-species matrix $\\det \\mathcal{M}(\\kappa,\\lambda)$. Express the final result for $\\det \\mathcal{M}(\\kappa,\\lambda)$ as an exact rational number with no units. Provide only the numerical value as your final answer, with no rounding required.",
            "solution": "The problem asks for the explicit construction of a two-species fermion matrix $\\mathcal{M}(\\kappa,\\lambda)$, an analysis of the eigenvalues of its constituent single-species matrix $M(\\kappa,\\lambda)$, and the computation of the determinant of $\\mathcal{M}(\\kappa,\\lambda)$ for specific parameter values.\n\nThe single-species fermion matrix is defined as:\n$$\nM(\\kappa,\\lambda) \\equiv \\mathbb{1} - \\kappa H - i \\lambda D\n$$\nwhere $\\mathbb{1}$ is the $2 \\times 2$ identity matrix, and $H$ and $D$ are given by:\n$$\nH \\equiv \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad D \\equiv \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\n$$\nThe problem specifies the parameter values $\\kappa = \\frac{1}{2}$ and $\\lambda = 1$. Substituting these values, we first construct the matrix $M(\\frac{1}{2}, 1)$.\n\n$$\nM\\left(\\frac{1}{2}, 1\\right) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} - i(1) \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\n$$\n$$\nM\\left(\\frac{1}{2}, 1\\right) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 0 & \\frac{1}{2} \\\\ \\frac{1}{2} & 0 \\end{pmatrix} - \\begin{pmatrix} i & 0 \\\\ 0 & -i \\end{pmatrix}\n$$\n$$\nM\\left(\\frac{1}{2}, 1\\right) = \\begin{pmatrix} 1 - 0 - i & 0 - \\frac{1}{2} - 0 \\\\ 0 - \\frac{1}{2} - 0 & 1 - 0 - (-i) \\end{pmatrix} = \\begin{pmatrix} 1 - i & -\\frac{1}{2} \\\\ -\\frac{1}{2} & 1 + i \\end{pmatrix}\n$$\n\nThe two-species fermion matrix $\\mathcal{M}(\\kappa,\\lambda)$ is defined as a block-diagonal matrix involving $M(\\kappa,\\lambda)$ and its complex conjugate $M(\\kappa,\\lambda)^{*}$.\n$$\nM\\left(\\frac{1}{2}, 1\\right)^{*} = \\left( \\begin{pmatrix} 1 - i & -\\frac{1}{2} \\\\ -\\frac{1}{2} & 1 + i \\end{pmatrix} \\right)^{*} = \\begin{pmatrix} 1 + i & -\\frac{1}{2} \\\\ -\\frac{1}{2} & 1 - i \\end{pmatrix}\n$$\nThus, the explicit construction of $\\mathcal{M}(\\frac{1}{2}, 1)$ is:\n$$\n\\mathcal{M}\\left(\\frac{1}{2}, 1\\right) = \\begin{pmatrix} M(\\frac{1}{2}, 1) & 0 \\\\ 0 & M(\\frac{1}{2}, 1)^{*} \\end{pmatrix} = \\begin{pmatrix} 1 - i & -\\frac{1}{2} & 0 & 0 \\\\ -\\frac{1}{2} & 1 + i & 0 & 0 \\\\ 0 & 0 & 1 + i & -\\frac{1}{2} \\\\ 0 & 0 & -\\frac{1}{2} & 1 - i \\end{pmatrix}\n$$\n\nNext, we identify the eigenvalues of $M(\\frac{1}{2}, 1)$ to demonstrate complex-conjugate pairing. The eigenvalues $z$ are the roots of the characteristic equation $\\det(M(\\frac{1}{2}, 1) - z \\mathbb{1}) = 0$.\n$$\n\\det \\begin{pmatrix} 1 - i - z & -\\frac{1}{2} \\\\ -\\frac{1}{2} & 1 + i - z \\end{pmatrix} = 0\n$$\n$$\n(1 - i - z)(1 + i - z) - \\left(-\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) = 0\n$$\nThis can be rewritten as:\n$$\n((1 - z) - i)((1 - z) + i) - \\frac{1}{4} = 0\n$$\n$$\n(1 - z)^{2} - i^{2} - \\frac{1}{4} = 0\n$$\n$$\n(1 - z)^{2} + 1 - \\frac{1}{4} = 0\n$$\n$$\n(1 - z)^{2} + \\frac{3}{4} = 0\n$$\n$$\n(1 - z)^{2} = -\\frac{3}{4}\n$$\nTaking the square root of both sides gives:\n$$\n1 - z = \\pm \\sqrt{-\\frac{3}{4}} = \\pm i \\frac{\\sqrt{3}}{2}\n$$\nSolving for $z$, we find the two eigenvalues:\n$$\nz = 1 \\mp i \\frac{\\sqrt{3}}{2}\n$$\nThe eigenvalues are $z_{1} = 1 - i \\frac{\\sqrt{3}}{2}$ and $z_{2} = 1 + i \\frac{\\sqrt{3}}{2}$. These two eigenvalues form a complex-conjugate pair, with $z_{2} = z_{1}^{*}$, as required.\n\nFinally, we compute the determinant of the two-species matrix, $\\det \\mathcal{M}(\\frac{1}{2}, 1)$. Since $\\mathcal{M}$ is a block-diagonal matrix, its determinant is the product of the determinants of its diagonal blocks:\n$$\n\\det \\mathcal{M} = \\det(M) \\det(M^{*})\n$$\nThe determinant of a matrix is the product of its eigenvalues. For $M(\\frac{1}{2}, 1)$, we have:\n$$\n\\det(M) = z_{1} z_{2} = \\left(1 - i \\frac{\\sqrt{3}}{2}\\right)\\left(1 + i \\frac{\\sqrt{3}}{2}\\right) = 1^{2} - \\left(i \\frac{\\sqrt{3}}{2}\\right)^{2} = 1 - \\left(i^{2} \\frac{3}{4}\\right) = 1 - \\left(-\\frac{3}{4}\\right) = 1 + \\frac{3}{4} = \\frac{7}{4}\n$$\nFor the complex-conjugate matrix $M^{*}$, we use the property that $\\det(A^{*}) = (\\det A)^{*}$.\n$$\n\\det(M^{*}) = (\\det M)^{*} = \\left(\\frac{7}{4}\\right)^{*} = \\frac{7}{4}\n$$\nsince $\\det(M)$ is a real number.\nTherefore, the determinant of the two-species matrix is:\n$$\n\\det \\mathcal{M}\\left(\\frac{1}{2}, 1\\right) = \\det(M) \\det(M^{*}) = \\left(\\frac{7}{4}\\right) \\left(\\frac{7}{4}\\right) = \\frac{49}{16}\n$$\nThis result is real and positive, which is a necessary feature for the validity of the Monte Carlo simulation, as the fermion determinant appears as a weight in the path integral.",
            "answer": "$$\\boxed{\\frac{49}{16}}$$"
        },
        {
            "introduction": "With the theoretical underpinning of a positive-definite weight secured, the next challenge is to implement the molecular dynamics evolution of the Hybrid Monte Carlo algorithm. This requires computing the \"force\" that the fermion determinant exerts on the auxiliary fields. This practice  guides you through a core coding task: calculating this pseudofermion force by numerically solving the required sparse linear system using the Conjugate Gradient algorithm, the computational heart of any HMC simulation.",
            "id": "3563810",
            "problem": "Consider a spinless fermion auxiliary-field formulation used in Hybrid Monte Carlo (HMC) for Lattice Effective Field Theory (EFT). The pseudofermion representation of the determinant yields the pseudofermion action $S_{\\mathrm{pf}}$ defined by $S_{\\mathrm{pf}} = \\boldsymbol{\\phi}^{\\dagger} \\left(M^{\\dagger} M\\right)^{-1} \\boldsymbol{\\phi}$, where $M[\\boldsymbol{\\sigma}]$ is the fermion matrix depending on the auxiliary field configuration $\\boldsymbol{\\sigma}$ and $\\boldsymbol{\\phi}$ is a fixed pseudofermion field. The HMC force component associated with the auxiliary field degree of freedom at a lattice site is the negative gradient of the total action with respect to that field; for the pseudofermion part alone this leads to a force component $F_i$ at site $i$ given by $F_i = \\boldsymbol{\\chi}^{\\dagger} \\left(\\frac{\\partial}{\\partial \\sigma_i} \\left(M^{\\dagger} M\\right)\\right) \\boldsymbol{\\chi}$, where $\\boldsymbol{\\chi}$ solves the linear system $\\left(M^{\\dagger} M\\right)\\boldsymbol{\\chi} = \\boldsymbol{\\phi}$. You are to compute the numerical value of a single force component $F_x$ at a specified site on a small lattice using Conjugate Gradient on the Normal Equations (CGNE).\n\nThe lattice is a four-dimensional hypercubic lattice of size $2^3 \\times 2$, i.e., spatial extents $N_x = 2$, $N_y = 2$, $N_z = 2$ and temporal extent $N_t = 2$ with periodic boundary conditions in all four directions. The total number of lattice sites is $N = 16$. Use a canonical site indexing $i = i(x,y,z,t)$ that uniquely maps coordinates $(x,y,z,t)$ with $x,y,z \\in \\{0,1\\}$ and $t \\in \\{0,1\\}$ to an integer index $i \\in \\{0,1,\\dots,15\\}$ via $i = x + 2 y + 4 z + 8 t$.\n\nDefine the fermion matrix $M[\\boldsymbol{\\sigma}] \\in \\mathbb{R}^{N \\times N}$ by\n$$\nM_{ij}[\\boldsymbol{\\sigma}] = \\delta_{ij} + g\\,\\sigma_i\\,\\delta_{ij} - \\kappa \\sum_{\\mu \\in \\{x,y,z,t\\}} \\left(\\delta_{j, i+\\hat{\\mu}} + \\delta_{j, i-\\hat{\\mu}}\\right),\n$$\nwhere $\\kappa$ is a nearest-neighbor hopping parameter, $g$ is the coupling to the auxiliary field, $\\sigma_i$ is the value of the auxiliary field at site $i$, $\\delta_{ij}$ is the Kronecker delta, and $i \\pm \\hat{\\mu}$ denote the nearest neighbors of site $i$ in the positive/negative $\\mu$ direction with periodic boundary conditions. The dependence on $\\boldsymbol{\\sigma}$ is strictly diagonal and linear, so $\\frac{\\partial M}{\\partial \\sigma_i} = g E_i$, with $E_i$ the diagonal matrix having a $1$ at position $(i,i)$ and zeros elsewhere. From this, the derivative of the normal matrix satisfies\n$$\n\\frac{\\partial}{\\partial \\sigma_i} \\left(M^{\\dagger} M\\right) = g \\left(E_i M + M^{\\dagger} E_i\\right).\n$$\n\nLet the auxiliary field configuration be specified deterministically by\n$$\n\\sigma(x,y,z,t) = 0.2\\,(-1)^{x+y+z+t} + 0.05\\,(x - y),\n$$\nwhich, via the indexing rule, defines $\\sigma_i$ for all $i \\in \\{0,\\dots,15\\}$. Let the pseudofermion field $\\boldsymbol{\\phi} \\in \\mathbb{R}^N$ be specified component-wise by\n$$\n\\phi_i = \\cos\\left(0.37\\,(i+1)\\right) + 0.1\\,\\sin\\left(0.13\\,(i+1)\\right), \\quad i = 0,1,\\dots,15.\n$$\n\nYou must compute the pseudofermion force component $F_x$ at the single site with coordinates $(x,y,z,t) = (1,0,0,1)$, i.e., at index $i_x = i(1,0,0,1) = 9$, defined by\n$$\nF_x \\equiv F_{i_x} = \\boldsymbol{\\chi}^{\\dagger} \\left(\\frac{\\partial}{\\partial \\sigma_{i_x}} \\left(M^{\\dagger} M\\right)\\right) \\boldsymbol{\\chi} = g \\left(\\boldsymbol{\\chi}^{\\dagger} E_{i_x} M \\boldsymbol{\\chi} + \\boldsymbol{\\chi}^{\\dagger} M^{\\dagger} E_{i_x} \\boldsymbol{\\chi}\\right) = 2g\\,\\mathrm{Re}\\left(\\overline{\\chi_{i_x}} \\,(M\\boldsymbol{\\chi})_{i_x}\\right),\n$$\nwhere $\\boldsymbol{\\chi}$ is the solution of $\\left(M^{\\dagger} M\\right)\\boldsymbol{\\chi} = \\boldsymbol{\\phi}$ obtained numerically using Conjugate Gradient on the Normal Equations with a relative residual tolerance of $\\varepsilon = 10^{-12}$ and a maximum of $1000$ iterations. All computations are real-valued here, so $\\mathrm{Re}$ reduces to the identity.\n\nImplement a program that constructs $M[\\boldsymbol{\\sigma}]$ from the given data, solves for $\\boldsymbol{\\chi}$ using CGNE, and computes $F_x$ as above for each of the following parameter sets $(\\kappa,g)$:\n\n- Test case $1$ (general case): $\\kappa = 0.08$, $g = 0.30$.\n- Test case $2$ (diagonal limit): $\\kappa = 0.00$, $g = 0.30$.\n- Test case $3$ (no coupling limit): $\\kappa = 0.08$, $g = 0.00$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each $F_x$ reported as a floating point number rounded to $8$ decimal places, in the order of the test cases above. For example, the output format must be exactly like $[f_1,f_2,f_3]$, where $f_j$ are the computed numerical values for test case $j$.\n\nNo physical units are involved; all quantities are dimensionless. Angles, where present in trigonometric functions, are in radians. The final numerical outputs must be floats. The solution must use Conjugate Gradient on the Normal Equations to compute $\\boldsymbol{\\chi}$ for each test case independently.",
            "solution": "The problem statement is assessed to be valid. It is scientifically sound, well-posed, objective, and contains all necessary information to proceed with a unique, verifiable solution. The problem lies within the established framework of computational nuclear physics, specifically addressing algorithm implementation for Hybrid Monte Carlo simulations on a lattice.\n\nThe primary objective is to compute the pseudofermion force component, $F_x$, at a specific lattice site $i_x$, for three distinct sets of physical parameters $(\\kappa, g)$. The force $F_x$ is derived from the pseudofermion action $S_{\\mathrm{pf}} = \\boldsymbol{\\phi}^{\\dagger} \\left(M^{\\dagger} M\\right)^{-1} \\boldsymbol{\\phi}$, and its component at site $i$ is given by $F_i = -\\frac{\\partial S_{\\mathrm{pf}}}{\\partial \\sigma_i}$. This computation involves several well-defined steps.\n\nFirst, we define the computational domain, which is a four-dimensional hypercubic lattice of size $N_x \\times N_y \\times N_z \\times N_t = 2 \\times 2 \\times 2 \\times 2$, resulting in a total of $N=16$ sites. Periodic boundary conditions are applied in all four dimensions. A canonical mapping from site coordinates $(x,y,z,t)$ (with $x,y,z,t \\in \\{0,1\\}$) to a single integer index $i \\in \\{0, 1, \\dots, 15\\}$ is given by $i = x + 2y + 4z + 8t$.\n\nThe core of the model is the real-valued fermion matrix $M[\\boldsymbol{\\sigma}] \\in \\mathbb{R}^{N \\times N}$, defined by its elements:\n$$\nM_{ij}[\\boldsymbol{\\sigma}] = (1 + g\\,\\sigma_i)\\delta_{ij} - \\kappa \\sum_{\\mu \\in \\{x,y,z,t\\}} \\left(\\delta_{j, i+\\hat{\\mu}} + \\delta_{j, i-\\hat{\\mu}}\\right)\n$$\nHere, $\\delta_{ij}$ is the Kronecker delta, $g$ is a coupling constant, $\\kappa$ is the hopping parameter, and $\\boldsymbol{\\sigma}$ is a background auxiliary field. The term $i\\pm\\hat{\\mu}$ indicates the nearest neighbor of site $i$ in the $\\pm\\mu$ direction. The auxiliary field $\\boldsymbol{\\sigma}$ and the pseudofermion field $\\boldsymbol{\\phi}$ are specified deterministically for all sites $i$:\n$$\n\\sigma_i = \\sigma(x,y,z,t) = 0.2\\,(-1)^{x+y+z+t} + 0.05\\,(x - y)\n$$\n$$\n\\phi_i = \\cos\\left(0.37\\,(i+1)\\right) + 0.1\\,\\sin\\left(0.13\\,(i+1)\\right)\n$$\n\nThe force calculation requires an intermediate vector, $\\boldsymbol{\\chi}$, which is determined by solving the linear system of normal equations:\n$$\n\\left(M^{\\dagger} M\\right)\\boldsymbol{\\chi} = \\boldsymbol{\\phi}\n$$\nSince $M$ is a real matrix, $M^{\\dagger} = M^T$. The matrix $A = M^T M$ is symmetric and positive definite (for the given parameters where $M$ is invertible), making the standard Conjugate Gradient (CG) algorithm an appropriate and efficient solver. The problem specifies a relative residual tolerance of $\\varepsilon = 10^{-12}$ and a maximum of $1000$ iterations for the CG solver. The CG algorithm iteratively finds the solution $\\boldsymbol{\\chi}$ starting from an initial guess $\\boldsymbol{\\chi}_0 = \\mathbf{0}$.\n\nOnce $\\boldsymbol{\\chi}$ is found, the force component $F_x$ at the target site $i_x=i(1,0,0,1)=9$ is computed. The general formula for the force is $F_i = \\boldsymbol{\\chi}^{\\dagger} (\\frac{\\partial}{\\partial \\sigma_i} (M^{\\dagger} M)) \\boldsymbol{\\chi}$. Using the provided derivative $\\frac{\\partial}{\\partial \\sigma_i} (M^{\\dagger} M) = g (E_i M + M^{\\dagger} E_i)$, where $E_i$ is a matrix with a single non-zero element $(E_i)_{ii}=1$, the force simplifies. Since all quantities are real, we have:\n$$\nF_{i_x} = \\boldsymbol{\\chi}^T \\left( g(E_{i_x} M + M^T E_{i_x}) \\right) \\boldsymbol{\\chi} = g (\\boldsymbol{\\chi}^T E_{i_x} M \\boldsymbol{\\chi} + \\boldsymbol{\\chi}^T M^T E_{i_x} \\boldsymbol{\\chi})\n$$\nRecognizing that $E_{i_x}$ projects onto the component $i_x$, this becomes:\n$$\nF_{i_x} = g (\\chi_{i_x} (M\\boldsymbol{\\chi})_{i_x} + (M^T\\boldsymbol{\\chi})_{i_x} \\chi_{i_x})\n$$\nSince $\\boldsymbol{\\chi}^T M^T E_{i_x} \\boldsymbol{\\chi}$ is a scalar, it equals its transpose, $(\\boldsymbol{\\chi}^T E_{i_x} M \\boldsymbol{\\chi})^T = \\boldsymbol{\\chi}^T M^T E_{i_x}^T \\boldsymbol{\\chi}$. As $E_{i_x}$ is diagonal, $E_{i_x}^T = E_{i_x}$. Thus, the two terms are identical. The final expression for the force is:\n$$\nF_x \\equiv F_{i_x} = 2g\\,\\chi_{i_x}\\,(M\\boldsymbol{\\chi})_{i_x}\n$$\nThis calculation is performed for each of the three test cases:\n1.  $(\\kappa, g) = (0.08, 0.30)$: The general case requiring the full numerical procedure.\n2.  $(\\kappa, g) = (0.00, 0.30)$: The hopping term vanishes, making $M$ a diagonal matrix. The solution $\\boldsymbol{\\chi}$ can be found analytically, $\\chi_i = \\phi_i / (1+g\\sigma_i)^2$, which serves as a check for the CG solver's result.\n3.  $(\\kappa, g) = (0.08, 0.00)$: The coupling $g$ is zero. The force expression $F_x = 2g\\,\\dots$ immediately implies $F_x=0$, providing a trivial but important sanity check.\n\nThe implementation will construct the matrix $M$ and fields $\\boldsymbol{\\sigma}, \\boldsymbol{\\phi}$ for each case, solve for $\\boldsymbol{\\chi}$ using a custom CG solver, and then compute $F_x$ according to the derived formula.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the pseudofermion force component F_x for three sets of parameters.\n    \"\"\"\n    # Define lattice dimensions and target site for force calculation.\n    NX, NY, NZ, NT = 2, 2, 2, 2\n    N = NX * NY * NZ * NT\n    ix_coords = (1, 0, 0, 1)\n\n    # Define the three test cases as tuples of (kappa, g).\n    test_cases = [\n        (0.08, 0.30),\n        (0.00, 0.30),\n        (0.08, 0.00),\n    ]\n\n    # Helper functions for mapping between coordinates and linear index.\n    def coords_to_index(c):\n        x, y, z, t = c\n        return x + NX * (y + NY * (z + NZ * t))\n\n    def index_to_coords(i):\n        t = i // (NX * NY * NZ)\n        i %= (NX * NY * NZ)\n        z = i // (NX * NY)\n        i %= (NX * NY)\n        y = i // NX\n        x = i % NX\n        return (x, y, z, t)\n    \n    # Get the linear index of the target site.\n    ix = coords_to_index(ix_coords)\n\n    # Pre-calculate neighbor indices for all sites to build M efficiently.\n    neighbors = np.zeros((N, 8), dtype=int)\n    for i in range(N):\n        x, y, z, t = index_to_coords(i)\n        # Neighbors in +x, -x, +y, -y, +z, -z, +t, -t directions.\n        neighbors[i, 0] = coords_to_index(((x + 1) % NX, y, z, t))\n        neighbors[i, 1] = coords_to_index(((x - 1 + NX) % NX, y, z, t))\n        neighbors[i, 2] = coords_to_index((x, (y + 1) % NY, z, t))\n        neighbors[i, 3] = coords_to_index((x, (y - 1 + NY) % NY, z, t))\n        neighbors[i, 4] = coords_to_index((x, y, (z + 1) % NZ, t))\n        neighbors[i, 5] = coords_to_index((x, y, (z - 1 + NZ) % NZ, t))\n        neighbors[i, 6] = coords_to_index((x, y, z, (t + 1) % NT))\n        neighbors[i, 7] = coords_to_index((x, y, z, (t - 1 + NT) % NT))\n\n    # Pre-calculate auxiliary field sigma and pseudofermion field phi.\n    # These are independent of the test case parameters.\n    sigma = np.zeros(N)\n    for i in range(N):\n        x, y, z, t = index_to_coords(i)\n        sigma[i] = 0.2 * (-1)**(x + y + z + t) + 0.05 * (x - y)\n\n    phi = np.zeros(N)\n    for i in range(N):\n        phi[i] = np.cos(0.37 * (i + 1)) + 0.1 * np.sin(0.13 * (i + 1))\n\n    results = []\n    for kappa, g in test_cases:\n        # Trivial case: if g=0, the force is zero.\n        if g == 0.0:\n            results.append(f\"{0.0:.8f}\")\n            continue\n\n        # Construct the fermion matrix M.\n        M = np.zeros((N, N), dtype=float)\n        for i in range(N):\n            M[i, i] = 1.0 + g * sigma[i]\n            if kappa != 0.0:\n                for neighbor_idx in neighbors[i]:\n                    M[i, neighbor_idx] -= kappa\n\n        # Define the system A*chi = b for the CG solver.\n        # A = M^T * M, b = phi.\n        A = M.T @ M\n        b = phi\n\n        # Solve for chi using Conjugate Gradient.\n        chi = cg_solver(A, b, tol=1e-12, max_iter=1000)\n\n        # Calculate the force F_x = 2 * g * chi_ix * (M*chi)_ix.\n        M_chi = M @ chi\n        force = 2.0 * g * chi[ix] * M_chi[ix]\n        results.append(f\"{force:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef cg_solver(A, b, tol, max_iter):\n    \"\"\"\n    Solves the linear system A*x = b using the Conjugate Gradient algorithm.\n    A must be a symmetric positive-definite matrix.\n    \"\"\"\n    x = np.zeros_like(b, dtype=float)\n    r = b - A @ x\n    p = r.copy()\n    rs_old = np.dot(r, r)\n\n    # Calculate norm of b for relative residual check.\n    b_norm = np.linalg.norm(b)\n    if b_norm == 0.0:\n        return x # Trivial solution\n\n    for _ in range(max_iter):\n        Ap = A @ p\n        p_Ap = np.dot(p, Ap)\n        \n        # If curvature is zero or negative, CG might fail.\n        # For a positive definite matrix, this should not happen with non-zero p.\n        if p_Ap <= 0:\n            break\n\n        alpha = rs_old / p_Ap\n        x += alpha * p\n        r -= alpha * Ap\n        rs_new = np.dot(r, r)\n\n        # Convergence check using relative residual norm.\n        if np.sqrt(rs_new) / b_norm < tol:\n            break\n\n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n\n    return x\n\nsolve()\n```"
        },
        {
            "introduction": "Having implemented the force calculation, how can we be certain it is correct? Subtle bugs in the force term can silently corrupt a simulation, so rigorous verification is not optional. This final practice  introduces the gold standard for code validation: the finite-difference force check. You will derive the analytic force for a toy model and then write code to verify it against a numerical approximation, a critical skill for developing reliable scientific software.",
            "id": "3563928",
            "problem": "You are asked to implement and validate a finite-difference force check for a small one-dimensional lattice field theory toy model representative of Hybrid Monte Carlo (HMC) used in lattice Effective Field Theory (EFT). The validation must compare central finite-difference estimates of the gradient of the Euclidean action with the analytic gradient derived from first principles of matrix calculus and variational differentiation.\n\nConsider a one-dimensional periodic lattice with $N$ sites and a real auxiliary field vector $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{N}$. Define the periodic nearest-neighbor lattice Laplacian matrix $\\mathbf{L} \\in \\mathbb{R}^{N \\times N}$ by $(\\mathbf{L}\\boldsymbol{v})_{i} = 2 v_{i} - v_{i+1} - v_{i-1}$, with indices taken modulo $N$. The Euclidean action is\n$$\nS(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\,\\boldsymbol{\\sigma}^{\\top}\\,\\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma} + \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4} \\;-\\; \\log\\det\\mathbf{M}(\\boldsymbol{\\sigma}),\n$$\nwhere the bosonic kernel is $\\mathbf{K}_{\\text{bos}} = m^{2}\\,\\mathbf{I} + \\kappa\\,\\mathbf{L}$ and the fermion matrix is\n$$\n\\mathbf{M}(\\boldsymbol{\\sigma}) = \\mathbf{I} + a\\,\\mathrm{diag}\\!\\left(\\exp(\\beta\\,\\boldsymbol{\\sigma})\\right) + t\\,\\mathbf{L}.\n$$\nAll quantities are dimensionless. Assume parameters are such that $\\mathbf{M}(\\boldsymbol{\\sigma})$ is symmetric positive definite for all field configurations considered.\n\nTasks to implement:\n\n1. Derive the analytic gradient $\\nabla S(\\boldsymbol{\\sigma}) \\in \\mathbb{R}^{N}$ starting from the definitions above using only fundamental rules of calculus and linear algebra. You must not assume any shortcut formulas that are not derivable from these bases. The final expression must be correct for arbitrary $N$ and the given action.\n\n2. Implement a numerical central finite-difference approximation to the gradient with component-wise steps. For a given step scale $h>0$, use component-wise steps $\\,\\varepsilon_i = h\\,\\big(1 + |\\sigma_i|\\big)\\,$ and\n$$\n\\big(\\nabla S\\big)^{\\text{FD}}_{i}(\\boldsymbol{\\sigma}) \\;=\\; \\frac{S\\big(\\boldsymbol{\\sigma} + \\varepsilon_i\\,\\mathbf{e}_i\\big) - S\\big(\\boldsymbol{\\sigma} - \\varepsilon_i\\,\\mathbf{e}_i\\big)}{2\\,\\varepsilon_i},\n$$\nwhere $\\mathbf{e}_i$ is the $i$-th standard basis vector.\n\n3. For each test case, estimate a tolerance directly from observed agreement between the analytic and finite-difference gradients over a small training set of random fields. Use the following deterministic procedure:\n   - Generate $N_{\\text{train}} = 5$ independent training configurations $\\boldsymbol{\\sigma}$ with components sampled from a standard normal distribution using a fixed seed $s_{\\text{train}}$ specific to each test case (see Test Suite below). For each configuration, compute the training discrepancy\n     $$\n     d = \\left\\|\\nabla S(\\boldsymbol{\\sigma}) - \\big(\\nabla S\\big)^{\\text{FD}}(\\boldsymbol{\\sigma})\\right\\|_{\\infty}.\n     $$\n     Collect the set $\\{d_j\\}_{j=1}^{N_{\\text{train}}}$.\n   - Compute a scale proxy $s = 1 + \\mathrm{median}\\big(\\{\\|\\nabla S(\\boldsymbol{\\sigma}_j)\\|_{\\infty}\\}_{j=1}^{N_{\\text{train}}}\\big)$.\n   - Set the tolerance to\n     $$\n     \\mathrm{tol} = 10 \\cdot \\mathrm{median}\\left(\\{d_j\\}\\right) + 10^{-12}\\,s.\n     $$\n   This defines a tolerance based solely on observed agreement between finite differences and analytic gradients on the training set.\n\n4. Using an independent test set of $N_{\\text{test}} = 3$ random configurations generated with a fixed seed $s_{\\text{test}}$ per test case, declare the test case to pass if and only if every test configuration satisfies\n$$\n\\left\\|\\nabla S(\\boldsymbol{\\sigma}) - \\big(\\nabla S\\big)^{\\text{FD}}(\\boldsymbol{\\sigma})\\right\\|_{\\infty} \\le \\mathrm{tol}.\n$$\n\nYour program must implement the above for the following test suite of parameter sets. For each case, report a boolean indicating pass or fail according to the rule in item $4$.\n\nTest Suite (each tuple is $(N, m, \\kappa, \\lambda, a, \\beta, t, h, s_{\\text{train}}, s_{\\text{test}})$):\n- Case A (happy path): $(4,\\, 0.5,\\, 1.0,\\, 0.1,\\, 0.7,\\, 0.6,\\, 0.2,\\, 10^{-6},\\, 12345,\\, 54321)$\n- Case B (minimal lattice, diagonal fermion): $(2,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.25,\\, 0.8,\\, 0.0,\\, 10^{-6},\\, 22345,\\, 64321)$\n- Case C (strong nearest-neighbor fermion, larger $N$): $(8,\\, 0.1,\\, 2.0,\\, 0.0,\\, 0.5,\\, 1.0,\\, 0.5,\\, 10^{-6},\\, 32345,\\, 74321)$\n- Case D (quartic interaction and very small finite-difference step): $(6,\\, 1.2,\\, 0.5,\\, 0.5,\\, 1.0,\\, 1.2,\\, 0.3,\\, 10^{-8},\\, 42345,\\, 84321)$\n\nAngle units are not applicable. There are no physical units; all quantities are dimensionless.\n\nFinal output format: Your program should produce a single line of output containing a list of booleans for the four cases in the order A, B, C, D, printed as a Python-style list, for example, \"[True,False,True,True]\".",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded, well-posed, self-contained, and computationally feasible. It presents a standard and meaningful task in computational physics: the verification of an analytically derived force term against a numerical finite-difference approximation in the context of a lattice field theory model.\n\nThe solution proceeds in two stages. First, the analytic gradient (force) of the Euclidean action is derived from first principles. Second, an algorithm implementing the specified numerical validation procedure is outlined.\n\n### 1. Analytic Gradient of the Euclidean Action\n\nThe Euclidean action $S(\\boldsymbol{\\sigma})$ is given by:\n$$\nS(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\,\\boldsymbol{\\sigma}^{\\top}\\,\\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma} + \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4} \\;-\\; \\log\\det\\mathbf{M}(\\boldsymbol{\\sigma})\n$$\nWe compute the gradient $\\nabla S(\\boldsymbol{\\sigma})$, whose $k$-th component is $\\frac{\\partial S}{\\partial \\sigma_k}$, by considering each term separately.\n\n#### 1.1. Gradient of the Bosonic Term\n\nThe first term is the quadratic bosonic action, $S_{\\text{bos}}(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\,\\boldsymbol{\\sigma}^{\\top}\\,\\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma}$.\nThe bosonic kernel is $\\mathbf{K}_{\\text{bos}} = m^{2}\\,\\mathbf{I} + \\kappa\\,\\mathbf{L}$. The identity matrix $\\mathbf{I}$ is symmetric. The lattice Laplacian $\\mathbf{L}$, defined by $(\\mathbf{L}\\boldsymbol{v})_{i} = 2 v_{i} - v_{i+1} - v_{i-1}$ with periodic boundary conditions, is a real symmetric matrix. Specifically, its elements are $L_{ii}=2$, $L_{i,i\\pm 1}=-1$ (indices modulo $N$), and $L_{ij}=0$ otherwise. Consequently, $\\mathbf{K}_{\\text{bos}}$ is a symmetric matrix.\n\nFor a general quadratic form $f(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ with a symmetric matrix $\\mathbf{A}$, the gradient is $\\nabla f(\\mathbf{x}) = \\mathbf{A}\\mathbf{x}$. Applying this rule, the gradient of the bosonic term is:\n$$\n\\nabla S_{\\text{bos}}(\\boldsymbol{\\sigma}) = \\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma}\n$$\n\n#### 1.2. Gradient of the Interaction Term\n\nThe second term is the quartic self-interaction, $S_{\\text{int}}(\\boldsymbol{\\sigma}) = \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4}$.\nTo find the $k$-th component of the gradient, we differentiate with respect to $\\sigma_k$:\n$$\n\\frac{\\partial S_{\\text{int}}}{\\partial \\sigma_k} = \\frac{\\partial}{\\partial \\sigma_k} \\left( \\frac{\\lambda}{4}\\sum_{i=0}^{N-1}\\sigma_i^{4} \\right) = \\frac{\\lambda}{4} \\cdot (4\\sigma_k^3) = \\lambda\\sigma_k^3\n$$\nThis can be expressed in vector form using the element-wise (Hadamard) power operation, denoted by $\\circ 3$:\n$$\n\\nabla S_{\\text{int}}(\\boldsymbol{\\sigma}) = \\lambda\\,\\boldsymbol{\\sigma}^{\\circ 3}\n$$\n\n#### 1.3. Gradient of the Fermionic Term\n\nThe third term is the fermionic determinant term, $S_{\\text{ferm}}(\\boldsymbol{\\sigma}) = -\\log\\det\\mathbf{M}(\\boldsymbol{\\sigma})$.\nWe use the chain rule and Jacobi's formula for the differential of a determinant. For an invertible matrix $\\mathbf{A}$, $d(\\log\\det\\mathbf{A}) = \\mathrm{tr}(\\mathbf{A}^{-1}d\\mathbf{A})$. Applying this to our term:\n$$\nd S_{\\text{ferm}} = -d(\\log\\det\\mathbf{M}) = -\\mathrm{tr}(\\mathbf{M}^{-1}d\\mathbf{M})\n$$\nThe fermion matrix $\\mathbf{M}(\\boldsymbol{\\sigma}) = \\mathbf{I} + a\\,\\mathrm{diag}\\!\\left(\\exp(\\beta\\,\\boldsymbol{\\sigma})\\right) + t\\,\\mathbf{L}$ depends on $\\boldsymbol{\\sigma}$ only through the diagonal matrix $\\mathbf{D}(\\boldsymbol{\\sigma}) = a\\,\\mathrm{diag}\\!\\left(\\exp(\\beta\\,\\boldsymbol{\\sigma})\\right)$. The differential $d\\mathbf{M}$ is therefore equal to $d\\mathbf{D}$.\n\nThe components of $\\mathbf{D}$ are $D_{ij}(\\boldsymbol{\\sigma}) = a \\exp(\\beta\\sigma_i) \\delta_{ij}$. The partial derivative with respect to $\\sigma_k$ is:\n$$\n\\frac{\\partial D_{ij}}{\\partial \\sigma_k} = a \\frac{\\partial}{\\partial \\sigma_k} (\\exp(\\beta\\sigma_i)\\delta_{ij}) = a \\beta \\exp(\\beta\\sigma_i) \\delta_{ik} \\delta_{ij}\n$$\nThis is non-zero only when $i=j=k$. The matrix $\\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k} = \\frac{\\partial \\mathbf{D}}{\\partial \\sigma_k}$ thus has only one non-zero entry at position $(k,k)$:\n$$\n\\left(\\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k}\\right)_{kk} = a \\beta \\exp(\\beta\\sigma_k)\n$$\nThis can be written using the standard basis vector $\\mathbf{e}_k$ as $\\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k} = a \\beta \\exp(\\beta\\sigma_k) \\mathbf{e}_k \\mathbf{e}_k^{\\top}$.\n\nThe total differential $d\\mathbf{M}$ is $d\\mathbf{M} = \\sum_{k=0}^{N-1} \\frac{\\partial \\mathbf{M}}{\\partial \\sigma_k} d\\sigma_k$. Substituting this into the trace expression:\n$$\nd S_{\\text{ferm}} = -\\mathrm{tr}\\left(\\mathbf{M}^{-1} \\sum_{k=0}^{N-1} a \\beta \\exp(\\beta\\sigma_k) \\mathbf{e}_k \\mathbf{e}_k^{\\top} d\\sigma_k\\right)\n$$\nBy linearity of the trace, we can move the summation outside:\n$$\nd S_{\\text{ferm}} = -\\sum_{k=0}^{N-1} a \\beta \\exp(\\beta\\sigma_k) \\mathrm{tr}(\\mathbf{M}^{-1} \\mathbf{e}_k \\mathbf{e}_k^{\\top}) d\\sigma_k\n$$\nUsing the cyclic property of the trace, $\\mathrm{tr}(\\mathbf{A}\\mathbf{B}) = \\mathrm{tr}(\\mathbf{B}\\mathbf{A})$, we have $\\mathrm{tr}(\\mathbf{M}^{-1} \\mathbf{e}_k \\mathbf{e}_k^{\\top}) = \\mathrm{tr}(\\mathbf{e}_k^{\\top}\\mathbf{M}^{-1}\\mathbf{e}_k)$. The term $\\mathbf{e}_k^{\\top}\\mathbf{M}^{-1}\\mathbf{e}_k$ is a $1 \\times 1$ matrix (a scalar) corresponding to the $k$-th diagonal element of $\\mathbf{M}^{-1}$, which we denote as $(\\mathbf{M}^{-1})_{kk}$.\nThe differential becomes:\n$$\nd S_{\\text{ferm}} = -\\sum_{k=0}^{N-1} a \\beta \\exp(\\beta\\sigma_k) (\\mathbf{M}^{-1})_{kk} d\\sigma_k\n$$\nBy definition, $d S_{\\text{ferm}} = \\sum_{k=0}^{N-1} (\\nabla S_{\\text{ferm}})_k d\\sigma_k$. Comparing coefficients yields the $k$-th component of the gradient:\n$$\n(\\nabla S_{\\text{ferm}})_k = -a \\beta \\exp(\\beta\\sigma_k) (\\mathbf{M}^{-1})_{kk}\n$$\nIn vector form, this is an element-wise product:\n$$\n\\nabla S_{\\text{ferm}}(\\boldsymbol{\\sigma}) = -a\\beta \\exp(\\beta\\boldsymbol{\\sigma}) \\circ \\mathrm{diag}(\\mathbf{M}(\\boldsymbol{\\sigma})^{-1})\n$$\nwhere $\\mathrm{diag}(\\mathbf{A}^{-1})$ denotes the vector of diagonal elements of the matrix $\\mathbf{A}^{-1}$.\n\n#### 1.4. Total Analytic Gradient\n\nCombining the gradients of the three terms gives the final expression for the analytic gradient of the action:\n$$\n\\nabla S(\\boldsymbol{\\sigma}) = \\mathbf{K}_{\\text{bos}}\\,\\boldsymbol{\\sigma} + \\lambda\\,\\boldsymbol{\\sigma}^{\\circ 3} - a \\beta \\exp(\\beta\\,\\boldsymbol{\\sigma}) \\circ \\mathrm{diag}(\\mathbf{M}(\\boldsymbol{\\sigma})^{-1})\n$$\n\n### 2. Algorithmic Design and Validation\n\nThe validation procedure involves implementing the derived analytic gradient and comparing it against a numerical finite-difference approximation.\n\n1.  **Matrix Construction**: For a given lattice size $N$, the periodic Laplacian matrix $\\mathbf{L}$ is constructed. Its elements are $L_{ii}=2$, $L_{i, (i-1+N)\\%N}=-1$, and $L_{i, (i+1)\\%N}=-1$. The bosonic kernel $\\mathbf{K}_{\\text{bos}}$ and fermion matrix $\\mathbf{M}(\\boldsymbol{\\sigma})$ are then built according to their definitions.\n\n2.  **Action and Gradient Implementation**: Three functions are implemented:\n    *   `action(sigma, ...)`: Computes $S(\\boldsymbol{\\sigma})$. The $\\log\\det\\mathbf{M}$ term is calculated using `numpy.linalg.slogdet`, which is numerically robust.\n    *   `analytic_gradient(sigma, ...)`: Computes $\\nabla S(\\boldsymbol{\\sigma})$ using the formula derived above. This requires computing the inverse of $\\mathbf{M}(\\boldsymbol{\\sigma})$ to extract its diagonal elements.\n    *   `fd_gradient(sigma, ...)`: Computes the central finite-difference gradient $(\\nabla S)^{\\text{FD}}$. For each component $i$, it perturbs $\\sigma_i$ by $\\pm \\varepsilon_i$, where $\\varepsilon_i = h(1 + |\\sigma_i|)$, recalculates the full action $S$ at $\\boldsymbol{\\sigma} \\pm \\varepsilon_i \\mathbf{e}_i$, and applies the standard central difference formula.\n\n3.  **Validation Protocol**: For each test case specified in the problem:\n    *   **Tolerance Estimation**: A tolerance `tol` is determined. A set of $N_{\\text{train}} = 5$ random field configurations are generated from a standard normal distribution using the seed $s_{\\text{train}}$. For each configuration, the discrepancy $d = \\|\\nabla S - (\\nabla S)^{\\text{FD}}\\|_{\\infty}$ and the analytic gradient norm $\\|\\nabla S\\|_{\\infty}$ are computed. The tolerance is set to $\\mathrm{tol} = 10 \\cdot \\mathrm{median}(\\{d_j\\}) + 10^{-12} \\cdot (1 + \\mathrm{median}(\\{\\|\\nabla S_j\\|_{\\infty}\\}))$.\n    *   **Testing**: An independent set of $N_{\\text{test}} = 3$ configurations are generated using the seed $s_{\\text{test}}$. The test case is marked as `Pass` (True) if and only if the discrepancy $d$ for all three test configurations is less than or equal to the computed tolerance `tol`. Otherwise, it is marked as `Fail` (False).\n\nThis comprehensive procedure ensures a robust verification of the analytic gradient implementation against a trusted numerical standard.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the validation tests for the lattice EFT model's action gradient.\n    \"\"\"\n\n    test_cases = [\n        # (N, m, kappa, lambda, a, beta, t, h, s_train, s_test)\n        (4, 0.5, 1.0, 0.1, 0.7, 0.6, 0.2, 1e-6, 12345, 54321),\n        (2, 3.0, 0.0, 0.0, 0.25, 0.8, 0.0, 1e-6, 22345, 64321),\n        (8, 0.1, 2.0, 0.0, 0.5, 1.0, 0.5, 1e-6, 32345, 74321),\n        (6, 1.2, 0.5, 0.5, 1.0, 1.2, 0.3, 1e-8, 42345, 84321),\n    ]\n\n    results = []\n    \n    for case_params in test_cases:\n        result = process_case(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case: calculates tolerance and performs validation.\n    \"\"\"\n    N, m, kappa, lamb, a, beta, t, h, s_train, s_test = params\n    \n    # Pre-compute the static part of matrices\n    L = build_laplacian(N)\n    K_bos = m**2 * np.eye(N) + kappa * L\n\n    # Helper function to pass static matrices\n    def get_action(sigma):\n        return action(sigma, N, lamb, a, beta, t, L, K_bos)\n    \n    def get_analytic_grad(sigma):\n        return analytic_gradient(sigma, N, lamb, a, beta, t, L, K_bos)\n\n    def get_fd_grad(sigma):\n        return fd_gradient(sigma, h, get_action)\n\n    # --- Task 3: Tolerance Estimation ---\n    N_train = 5\n    rng_train = np.random.default_rng(s_train)\n    \n    discrepancies_train = []\n    grad_norms_train = []\n\n    for _ in range(N_train):\n        sigma = rng_train.standard_normal(N)\n        \n        grad_analytic = get_analytic_grad(sigma)\n        grad_fd = get_fd_grad(sigma)\n        \n        d = np.linalg.norm(grad_analytic - grad_fd, ord=np.inf)\n        discrepancies_train.append(d)\n        \n        grad_norm = np.linalg.norm(grad_analytic, ord=np.inf)\n        grad_norms_train.append(grad_norm)\n        \n    median_d = np.median(discrepancies_train)\n    median_grad_norm = np.median(grad_norms_train)\n    scale_proxy = 1.0 + median_grad_norm\n    tol = 10.0 * median_d + 1e-12 * scale_proxy\n\n    # --- Task 4: Validation ---\n    N_test = 3\n    rng_test = np.random.default_rng(s_test)\n    case_passed = True\n    \n    for _ in range(N_test):\n        sigma = rng_test.standard_normal(N)\n        \n        grad_analytic = get_analytic_grad(sigma)\n        grad_fd = get_fd_grad(sigma)\n        \n        d_test = np.linalg.norm(grad_analytic - grad_fd, ord=np.inf)\n\n        if d_test > tol:\n            case_passed = False\n            break\n            \n    return case_passed\n\ndef build_laplacian(N):\n    \"\"\"Constructs the 1D periodic nearest-neighbor lattice Laplacian matrix L.\"\"\"\n    eye_N = np.eye(N)\n    # L = 2I - P_f - P_b, where P_f is forward shift and P_b is backward shift\n    # np.roll(eye, 1, axis=0) is P_f\n    # np.roll(eye, -1, axis=0) is P_b\n    L = 2 * eye_N - np.roll(eye_N, 1, axis=0) - np.roll(eye_N, -1, axis=0)\n    return L\n\ndef action(sigma, N, lamb, a, beta, t, L, K_bos):\n    \"\"\"Computes the Euclidean action S(sigma).\"\"\"\n    # Bosonic term\n    s_bos = 0.5 * sigma.T @ K_bos @ sigma\n    \n    # Quartic interaction term\n    s_int = (lamb / 4.0) * np.sum(sigma**4)\n    \n    # Fermionic term\n    M = np.eye(N) + a * np.diag(np.exp(beta * sigma)) + t * L\n    \n    # M must be SPD as per problem statement, so sign of det is +1\n    sign, logdet = np.linalg.slogdet(M) \n    if sign != 1:\n        # This should not happen with the given problem parameters\n        # but is good practice to check.\n        return np.inf\n    \n    s_ferm = -logdet\n    \n    return s_bos + s_int + s_ferm\n\ndef analytic_gradient(sigma, N, lamb, a, beta, t, L, K_bos):\n    \"\"\"Computes the analytic gradient of the action, nabla S(sigma).\"\"\"\n    # Gradient of bosonic term\n    grad_bos = K_bos @ sigma\n    \n    # Gradient of quartic interaction term\n    grad_int = lamb * (sigma**3)\n    \n    # Gradient of fermionic term\n    M = np.eye(N) + a * np.diag(np.exp(beta * sigma)) + t * L\n    M_inv = np.linalg.inv(M)\n    diag_M_inv = np.diag(M_inv)\n    \n    grad_ferm = -a * beta * np.exp(beta * sigma) * diag_M_inv\n    \n    return grad_bos + grad_int + grad_ferm\n\ndef fd_gradient(sigma, h, action_func):\n    \"\"\"Computes the central finite-difference approximation of the gradient.\"\"\"\n    N = len(sigma)\n    grad_fd = np.zeros(N)\n    \n    for i in range(N):\n        sigma_i = sigma[i]\n        eps_i = h * (1.0 + np.abs(sigma_i))\n        \n        sigma_plus = sigma.copy()\n        sigma_plus[i] += eps_i\n        \n        sigma_minus = sigma.copy()\n        sigma_minus[i] -= eps_i\n        \n        s_plus = action_func(sigma_plus)\n        s_minus = action_func(sigma_minus)\n        \n        grad_fd[i] = (s_plus - s_minus) / (2.0 * eps_i)\n        \n    return grad_fd\n\n# Run the solver\nsolve()\n```"
        }
    ]
}