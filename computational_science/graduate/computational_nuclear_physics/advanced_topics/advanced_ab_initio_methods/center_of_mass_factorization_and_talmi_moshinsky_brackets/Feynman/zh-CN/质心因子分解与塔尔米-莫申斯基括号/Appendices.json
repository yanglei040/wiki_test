{
    "hands_on_practices": [
        {
            "introduction": "对 Talmi-Moshinsky (TM) 变换的任何深入研究都始于对其基本数学性质的理解。这个练习将指导您从第一性原理出发，针对一个简单但至关重要的物理场景——谐振子势中两个等质量粒子——推导出 TM 系数。通过亲手实现并数值验证这些变换的正交性 ，您将为后续更复杂的应用打下坚实的计算与理论基础。",
            "id": "3549194",
            "problem": "您的任务是，在两个等质量粒子处于各向同性谐振子中且限制在总轨道角动量为零的分区（也称为 $s$ 波分区）的特殊情况下，推导、实现并数值验证 Talmi-Moshinsky (TM) 变换矩阵的正交性和完备性关系。TM 变换连接了双粒子单粒子基矢与相对坐标和质心 (COM) 坐标基矢。在 $s$ 波分区中，该变换保持总振子量子数不变，并由约束条件 $2n + l + 2N + L = N_{\\text{tot}}$ 下的量子数 $(n,l,N,L)$ 来表征。\n\n从以下适合该情境的基本出发点开始：\n- 对于质量相等、振子频率相同的双粒子各向同性谐振子，其哈密顿量 $H = H_1 + H_2$ 在正交坐标变换 $\\boldsymbol{r} = (\\boldsymbol{r}_1 - \\boldsymbol{r}_2)/\\sqrt{2}$ 和 $\\boldsymbol{R} = (\\boldsymbol{r}_1 + \\boldsymbol{r}_2)/\\sqrt{2}$ 下可分离为相对坐标部分和质心部分，其相关的升降算符也同样如此，$a_r^\\dagger = (a_1^\\dagger - a_2^\\dagger)/\\sqrt{2}$ 和 $a_R^\\dagger = (a_1^\\dagger + a_2^\\dagger)/\\sqrt{2}$。\n- 在 $s$ 波分区（总轨道角动量为零）中，基矢态分别由相对坐标分区和质心分区的径向量子数 $n$ 和 $N$ 表征，且 $l = L = 0$。能量计数条件变为 $2n + 2N = N_{\\text{tot}}$，因此在该分区中 $N_{\\text{tot}}$ 必须是偶数。\n\n您的目标是：\n1. 在 $s$ 波分区，对于固定的 $N_{\\text{tot}} = 2n + 2N = 2n_1 + 2n_2$，从升降算符关系推导出单粒子数态基矢 $\\{|n_1, n_2\\rangle\\}$ 与相对/质心数态基矢 $\\{|n, N\\rangle\\}$ 之间的显式线性变换系数。证明这些系数源于一个正交变量变换，因此在固定的 $N_{\\text{tot}}$ 的子空间上是幺正的。\n2. 实现一个数值程序，用于在给定的偶数 $N_{\\text{tot}}$ 下为 $s$ 波分区构建 TM 变换矩阵 $U$。枚举所有满足 $l=L=0$ 和 $2n + 2N = N_{\\text{tot}}$ 的允许的 $(n,l,N,L)$，以及所有满足 $2n_1 + 2n_2 = N_{\\text{tot}}$ 的相应单粒子对 $(n_1, n_2)$。矩阵 $U$ 必须在固定的 $N_{\\text{tot}}$ 下将相对/质心基矢映射到单粒子基矢。\n3. 通过计算 $U^\\dagger U$ 并检查其与单位矩阵 $\\mathbb{1}$ 的相等性，在 $10^{-12}$ 的绝对容差内数值验证其正交性和完备性。\n\n约束和规范：\n- 限制在 $s$ 波分区，即 $l = L = 0$，因此 $N_{\\text{tot}}$ 必须是偶数。枚举所有满足 $2n + 2N = N_{\\text{tot}}$ 的允许的 $(n,N)$ 对。\n- 推导并使用一个由玻色子升降算符恒等式和二项式展开得出的变换系数公式。不要假定任何预先推导好的 TM 括号表。\n- 最终的数值验证中不出现任何物理单位；所有计算都是谐振子代数下的纯无量纲重叠。\n- 测试套件包含以下 $N_{\\text{tot}}$ 值：$0$、$2$、$4$ 和 $6$。对于每种情况，构建 $U$，计算 $U^\\dagger U$，并检查与单位矩阵的最大绝对偏差。每个测试用例的结果必须是一个布尔值，指示 $U^\\dagger U$ 是否在 $10^{-12}$ 的容差内等于 $\\mathbb{1}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”），其中每个结果是对应于 $N_{\\text{tot}} = 0, 2, 4, 6$ 顺序的一个测试用例的布尔值。",
            "solution": "该问题要求推导、实现并验证 Talmi-Moshinsky (TM) 变换在一个特殊情况下的性质：两个等质量粒子处于各向同性谐振子中，并限制在总轨道角动量为零的 $s$ 波分区。\n\n该变换连接了单粒子 (SP) 基矢（记为 $|n_1, l_1=0; n_2, l_2=0\\rangle$）与相对坐标和质心 (COM) 基矢（记为 $|n, l=0; N, L=0\\rangle$）。量子数 $n_1, n_2, n, N$ 是径向量子数。为简单起见，我们将这些态简写为 $|n_1, n_2\\rangle$ 和 $|n, N\\rangle$。总振子量子数 $N_{\\text{tot}}$ 是一个守恒量。对于 s 波态，能量与 $2n_{rad} + 3/2$ 成正比，因此量子数为 $2n_{rad}$。守恒条件因此为 $N_{\\text{tot}} = 2n_1 + 2n_2 = 2n + 2N$，这意味着 $N_{\\text{tot}}$ 必须是偶数。令 $M = N_{\\text{tot}}/2$。守恒定律简化为 $M = n_1 + n_2 = n + N$。这个数学结构与一维谐振子中双粒子系统的结构相同，其中 $M$ 是总量子数。因此，正如所提供的升降算符关系所建议的，推导将使用一维谐振子的形式体系进行。\n\n变换矩阵 $U$ 将一个正交归一基矢映射到另一个正交归一基矢，因此是幺正的。由于系数是实数，它是一个正交矩阵，满足 $U^\\dagger U = U^T U = \\mathbb{1}$。$U$ 的元素是重叠积分，即 Talmi-Moshinsky 括号，$U_{ij} = \\langle \\text{sp}_i | \\text{rel-COM}_j \\rangle$。问题规定 $U$ 将相对/质心基矢映射到单粒子基矢，即 $|\\text{sp}_i\\rangle = \\sum_j U_{ij} |\\text{rel-COM}_j\\rangle$。这意味着 $U_{ij} = \\langle \\text{rel-COM}_j | \\text{sp}_i \\rangle$。我们将让索引 $i$ 对应于 $n_1=i$（因此 $n_2=M-i$）的单粒子态，索引 $j$ 对应于 $n=j$（且 $N=M-j$）的相对/质心态，其中 $i,j \\in \\{0, 1, \\dots, M\\}$。\n\n推导从升降算符之间的关系开始。从单粒子坐标 $(\\boldsymbol{r}_1, \\boldsymbol{r}_2)$ 到相对/质心坐标 $(\\boldsymbol{r}, \\boldsymbol{R})$ 的变换是正交的。这导致了产生和湮灭算符的相应正交变换。对于一维情况：\n$$ a_r^\\dagger = \\frac{1}{\\sqrt{2}}(a_1^\\dagger - a_2^\\dagger) \\quad ; \\quad a_R^\\dagger = \\frac{1}{\\sqrt{2}}(a_1^\\dagger + a_2^\\dagger) $$\n逆变换是：\n$$ a_1^\\dagger = \\frac{1}{\\sqrt{2}}(a_R^\\dagger + a_r^\\dagger) \\quad ; \\quad a_2^\\dagger = \\frac{1}{\\sqrt{2}}(a_R^\\dagger - a_r^\\dagger) $$\nSP 基矢中的一个态是通过将这些产生算符作用于真空态 $|0,0\\rangle$ 来构建的：\n$$ |n_1, n_2\\rangle = \\frac{(a_1^\\dagger)^{n_1}}{\\sqrt{n_1!}} \\frac{(a_2^\\dagger)^{n_2}}{\\sqrt{n_2!}} |0,0\\rangle $$\n代入 $a_1^\\dagger$ 和 $a_2^\\dagger$ 的表达式：\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\left( \\frac{a_R^\\dagger + a_r^\\dagger}{\\sqrt{2}} \\right)^{n_1} \\left( \\frac{a_R^\\dagger - a_r^\\dagger}{\\sqrt{2}} \\right)^{n_2} |0,0\\rangle $$\n由于相对坐标算符和质心算符作用于独立的空间，$[a_r^\\dagger, a_R^\\dagger] = 0$。我们可以使用二项式定理展开这些项：\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{(n_1+n_2)/2}} \\left( \\sum_{k_1=0}^{n_1} \\binom{n_1}{k_1} (a_R^\\dagger)^{n_1-k_1} (a_r^\\dagger)^{k_1} \\right) \\left( \\sum_{k_2=0}^{n_2} \\binom{n_2}{k_2} (a_R^\\dagger)^{n_2-k_2} (-a_r^\\dagger)^{k_2} \\right) |0,0\\rangle $$\n合并求和并重新整理各项：\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{k_1=0}^{n_1} \\sum_{k_2=0}^{n_2} \\binom{n_1}{k_1} \\binom{n_2}{k_2} (-1)^{k_2} (a_R^\\dagger)^{n_1+n_2-k_1-k_2} (a_r^\\dagger)^{k_1+k_2} |0,0\\rangle $$\n我们希望将其表示为相对/质心基矢态 $|n, N\\rangle = \\frac{(a_r^\\dagger)^n}{\\sqrt{n!}} \\frac{(a_R^\\dagger)^N}{\\sqrt{N!}}|0,0\\rangle$ 的叠加。这意味着我们认定 $n = k_1+k_2$ 和 $N = n_1+n_2-k_1-k_2 = M-n$。未归一化的态是 $(a_R^\\dagger)^N (a_r^\\dagger)^n |0,0\\rangle = \\sqrt{n!N!} |n,N\\rangle$。\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{n=0}^{M} \\left( \\sum_{\\substack{k_1+k_2=n \\\\ 0\\le k_1 \\le n_1 \\\\ 0\\le k_2 \\le n_2}} \\binom{n_1}{k_1} \\binom{n_2}{k_2} (-1)^{k_2} \\right) \\sqrt{n!(M-n)!} |n, M-n\\rangle $$\n在此展开式中 $|n, N\\rangle$ 的系数是 TM 括号 $\\langle n, N | n_1, n_2 \\rangle$。设 $k_2 = n-k_1$，则求和是对 $k_1$ 进行的。$k_1$ 的求和范围是 $\\max(0, n-n_2) \\le k_1 \\le \\min(n, n_1)$。\n$$ \\langle n, N | n_1, n_2 \\rangle = \\frac{\\sqrt{n!N!}}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{k_1=\\max(0,n-n_2)}^{\\min(n,n_1)} \\binom{n_1}{k_1} \\binom{n_2}{n-k_1} (-1)^{n-k_1} $$\n这就是变换系数的公式，其中 $n_1+n_2=n+N=M$。\n\n为了进行数值实现，我们为给定的 $N_{\\text{tot}} = 2M$ 构建 $(M+1) \\times (M+1)$ 矩阵 $U$。行由 $i=n_1 \\in \\{0, \\dots, M\\}$ 索引，列由 $j=n \\in \\{0, \\dots, M\\}$ 索引。矩阵元素 $U_{ij} = \\langle n=j, N=M-j | n_1=i, n_2=M-i \\rangle$ 是：\n$$ U_{ij} = \\frac{\\sqrt{j!(M-j)!}}{\\sqrt{i!(M-i)!}} \\frac{1}{2^{M/2}} \\sum_{k=\\max(0,i+j-M)}^{\\min(i,j)} (-1)^{j-k} \\binom{i}{k} \\binom{M-i}{j-k} $$\n算法如下：\n1. 对于测试套件 $\\{0, 2, 4, 6\\}$ 中的每个 $N_{\\text{tot}}$，计算 $M=N_{\\text{tot}}/2$。\n2. 创建一个 $(M+1) \\times (M+1)$ 的矩阵 $U$。\n3. 对于每一行 $i \\in \\{0, \\dots, M\\}$ 和每一列 $j \\in \\{0, \\dots, M\\}$，使用推导出的公式计算元素 $U_{ij}$。阶乘和二项式系数使用 `scipy.special` 计算。\n4. 构建 $U$ 后，计算乘积 $P = U^T U$。由于 $U$ 是实数，所以 $U^\\dagger = U^T$。\n5. 计算 $P$ 与同维度单位矩阵 $\\mathbb{1}$ 之间的最大绝对差：$\\max(|\\mathbb{1} - P|)$。\n6. 如果此差值小于容差 $10^{-12}$，则该 $N_{\\text{tot}}$ 的验证成功 (True)，否则失败 (False)。\n7. 收集所有测试用例的布尔结果，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import factorial, binom\n\ndef calculate_tm_matrix(M: int) -> np.ndarray:\n    \"\"\"\n    Constructs the Talmi-Moshinsky transformation matrix for the s-wave sector.\n\n    Args:\n        M: The total number of oscillator quanta pairs, M = N_tot / 2.\n\n    Returns:\n        The (M+1)x(M+1) Talmi-Moshinsky transformation matrix U.\n        The element U_ij ="
        },
        {
            "introduction": "虽然等质量体系是理解 TM 变换的理想起点，但真实的核物理系统，例如超核，通常涉及质量不等的粒子。这个练习将挑战您将 TM 变换推广到更普遍的非对称质量情景，并探索质量比 $\\alpha = m_1/m_2$ 如何影响变换系数 。通过分析对称性破缺如何导致在等质量情况下为零的变换系数变为非零，您将更深刻地理解该变换的结构及其与系统物理参数的内在联系。",
            "id": "3549238",
            "problem": "考虑一个在三维各向同性谐振子中的两体系统，其中单粒子坐标被解耦为相对坐标和质心坐标。在每个笛卡尔方向上，从单粒子坐标到相对坐标和质心坐标的变换可以表示为无量纲变量空间中的一个正交旋转。塔尔米-莫申斯基 (TM) 括号作为此基变换的系数出现，该变换将单粒子谐振子态的乘积转换为相对坐标和质心坐标谐振子态的乘积。在等质量系统中，粒子交换对称性会产生特殊的选择定则，这意味着某些 TM 括号会消失。在超核系统中，粒子质量通常不相等，这种不对称性破坏了等质量情况下的某些抵消效应。\n\n从以下基本原理和定义出发：\n- 无量纲单粒子坐标定义为 $\\xi_i = x_i / b_i$，其中 $x_i$ 是粒子 $i$ 的粒子坐标，$b_i = \\sqrt{\\hbar / (m_i \\omega)}$ 是与质量 $m_i$ 和频率 $\\omega$ 相关联的谐振子长度。\n- 在无量纲坐标下的正交变换中，谐振子基中的高斯因子保持不变。\n- 到无量纲质心和相对坐标的正交变换为 $\\Xi = \\cos \\theta \\, \\xi_1 + \\sin \\theta \\, \\xi_2$ 和 $\\varrho = -\\sin \\theta \\, \\xi_1 + \\cos \\theta \\, \\xi_2$，其中 $\\cos \\theta = \\sqrt{m_1/(m_1+m_2)}$ 和 $\\sin \\theta = \\sqrt{m_2/(m_1+m_2)}$，这是从保持正交归一性的质量加权组合中推导出来的。\n- 物理学家埃尔米特多项式 $H_n(\\xi)$ 满足生成函数 $\\exp\\left(-t^2 + 2 t \\xi\\right) = \\sum_{n=0}^{\\infty} H_n(\\xi) \\, t^n / n!$。\n\n任务：\n1. 从埃尔米特多项式的生成函数和上述定义的正交旋转出发，推导连接单粒子谐振子本征态乘积与质心和相对坐标本征态乘积的一维 TM 括号 $\\mathcal{M}(N,n;n_1,n_2;\\theta)$。证明除非 $N+n = n_1 + n_2$，否则该括号为零，并用二项式求和与阶乘给出 $\\mathcal{M}(N,n;n_1,n_2;\\theta)$ 的显式表达式。\n2. 将此括号推广到由质量比 $\\alpha = m_1/m_2$ 参数化的不等质量情况。用 $\\alpha$ 明确表示 $\\cos \\theta$ 和 $\\sin \\theta$。\n3. 实现一个程序，用于计算给定整数量子数 $n_1, n_2, N, n$ 和质量比 $\\alpha$ 时的 $\\mathcal{M}(N,n;n_1,n_2;\\alpha)$。对二项式系数和阶乘使用精确整数算术，并结合浮点算术计算 $\\cos \\theta$ 和 $\\sin \\theta$ 的幂。\n4. 通过将不等质量括号与 $\\alpha = 1$ 时的相应等质量值进行比较，量化与等质量选择定则的偏差。特别是，对于因对称性而在 $\\alpha = 1$ 时消失的构型，计算绝对偏差 $\\delta(\\alpha) = \\left|\\mathcal{M}(N,n;n_1,n_2;\\alpha) - \\mathcal{M}(N,n;n_1,n_2;1)\\right| = \\left|\\mathcal{M}(N,n;n_1,n_2;\\alpha)\\right|$。\n5. 对于固定的 $n_1, n_2$，通过检查 $\\sum_{N=0}^{n_1+n_2} \\left[\\mathcal{M}\\left(N,n_1+n_2-N;n_1,n_2;\\alpha\\right)\\right]^2 = 1$ 在数值容差范围内是否成立来验证正交归一性，这表示了两个基之间旋转的幺正性。\n\n使用以下测试套件来验证您的实现和分析。这些案例包括等质量对称性检查、实际的超核质量比、极端质量比以及一个选择定则违背的边界案例。对于每个测试案例，计算所述的括号 $\\mathcal{M}$ 和偏差 $\\delta$。\n\n- 测试案例 1 (等质量对称性抵消，正常路径)：$ \\alpha = 1.0 $, $ n_1 = 1 $, $ n_2 = 1 $, $ N = 1 $, $ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 以及选择定则 $ N+n = n_1+n_2 $ 是否满足（布尔值）。\n- 测试案例 2 (实际的超核质量比)：$ \\alpha = 1.19 $, $ n_1 = 1 $, $ n_2 = 1 $, $ N = 1 $, $ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 以及选择定则布尔值。\n- 测试案例 3 (极端质量比)：$ \\alpha = 10.0 $, $ n_1 = 1 $, $ n_2 = 1 $, $ N = 1 $, $ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 以及选择定则布尔值。\n- 测试案例 4 (另一个等质量对称性抵消)：$ \\alpha = 1.0 $, $ n_1 = 2 $, $ n_2 = 2 $, $ N = 3 $, $ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 以及选择定则布尔值。\n- 测试案例 5 (不等质量破坏抵消)：$ \\alpha = 1.19 $, $ n_1 = 2 $, $ n_2 = 2 $, $ N = 3 $, $ n = 1 $。报告 $ \\mathcal{M} $、$ \\delta $ 以及选择定则布尔值。\n- 测试案例 6 (选择定则违背的边界条件)：$ \\alpha = 2.5 $, $ n_1 = 0 $, $ n_2 = 1 $, $ N = 0 $, $ n = 0 $。报告 $ \\mathcal{M} $、与 $ \\alpha = 1.0 $ 相比的偏差，以及选择定则布尔值。\n- 测试案例 7 (正交归一性检查)：$ \\alpha = 1.19 $, $ n_1 = 1 $, $ n_2 = 1 $。计算 $ \\sum_{N=0}^{2} \\left[\\mathcal{M}\\left(N,2-N;1,1;\\alpha\\right)\\right]^2 $ 并报告其是否在 $ 10^{-12} $ 的容差内等于 $ 1 $（布尔值）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，列表用方括号括起来（例如，\"[result1,result2,...]\"）。每个结果应为浮点数、布尔值或包含浮点数和布尔值的列表，顺序与每个测试案例中指定的顺序相同。不应打印任何附加文本。此问题中不需要物理单位，因为所有量在构造上都是无量纲的。",
            "solution": "该问题要求推导并实现谐振子势中两体系统的一维塔尔米-莫申斯基 (TM) 括号，特别是针对质量不等的粒子。\n\n### 任务 1：塔尔米-莫申斯基括号的推导\n\n对于量子数为 $n_i$ 的粒子 $i$，其一维谐振子本征态由 $\\psi_{n_i}(\\xi_i) = \\mathcal{N}_{n_i} H_{n_i}(\\xi_i) \\exp(-\\xi_i^2/2)$ 给出，其中 $\\xi_i = x_i/b_i$ 是无量纲坐标，$H_{n_i}$ 是埃尔米特多项式，$\\mathcal{N}_{n_i} = (2^{n_i} n_i! \\sqrt{\\pi})^{-1/2}$ 是归一化常数。两个此类单粒子态的乘积 $\\psi_{n_1}(\\xi_1)\\psi_{n_2}(\\xi_2)$ 可以在对应于质心和相对坐标的态 $\\Psi_N(\\Xi)\\Psi_n(\\varrho)$ 的基中展开。此展开的系数即为塔尔米-莫申斯基括号，$\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\langle N, n | n_1, n_2 \\rangle_\\theta$。\n$$\n\\psi_{n_1}(\\xi_1)\\psi_{n_2}(\\xi_2) = \\sum_{N,n} \\mathcal{M}(N,n;n_1,n_2;\\theta) \\Psi_N(\\Xi)\\Psi_n(\\varrho)\n$$\n到无量纲质心 ($\\Xi$) 和相对 ($\\varrho$) 坐标的变换是一个正交旋转：\n$$\n\\begin{pmatrix} \\Xi \\\\ \\varrho \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\xi_1 \\\\ \\xi_2 \\end{pmatrix}\n$$\n其逆变换为：\n$$\n\\begin{pmatrix} \\xi_1 \\\\ \\xi_2 \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\Xi \\\\ \\varrho \\end{pmatrix}\n$$\n由于此变换是正交的，平方和是不变的：$\\xi_1^2 + \\xi_2^2 = \\Xi^2 + \\varrho^2$。这意味着乘积态中的高斯因子 $\\exp(-(\\xi_1^2+\\xi_2^2)/2)$ 等于 $\\exp(-(\\Xi^2+\\varrho^2)/2)$，后者是质心和相对坐标态的高斯因子。因此，变换简化为波函数多项式部分之间的关系。\n\n物理学家埃尔米特多项式 $H_k(z)$ 的生成函数为：\n$$\n\\exp(-t^2 + 2t z) = \\sum_{k=0}^{\\infty} H_k(z) \\frac{t^k}{k!}\n$$\n我们使用两个变量 $s$ 和 $t$ 来构造两个埃尔米特多项式 $H_{n_1}(\\xi_1)H_{n_2}(\\xi_2)$ 乘积的生成函数：\n$$\n\\sum_{n_1=0}^{\\infty} \\sum_{n_2=0}^{\\infty} H_{n_1}(\\xi_1)H_{n_2}(\\xi_2) \\frac{s^{n_1}}{n_1!} \\frac{t^{n_2}}{n_2!} = \\exp(-s^2 + 2s\\xi_1) \\exp(-t^2 + 2t\\xi_2)\n$$\n将 $\\xi_1 = \\Xi\\cos\\theta - \\varrho\\sin\\theta$ 和 $\\xi_2 = \\Xi\\sin\\theta + \\varrho\\cos\\theta$ 代入指数中：\n$$\n2s\\xi_1 + 2t\\xi_2 = 2s(\\Xi\\cos\\theta - \\varrho\\sin\\theta) + 2t(\\Xi\\sin\\theta + \\varrho\\cos\\theta) = (2s\\cos\\theta + 2t\\sin\\theta)\\Xi + (-2s\\sin\\theta + 2t\\cos\\theta)\\varrho\n$$\n我们定义新的生成函数变量 $S = s\\cos\\theta + t\\sin\\theta$ 和 $T = -s\\sin\\theta + t\\cos\\theta$。指数变为 $2S\\Xi + 2T\\varrho$。指数的二次项部分 $-s^2-t^2$ 在此旋转下是不变的：$S^2+T^2 = (s\\cos\\theta + t\\sin\\theta)^2 + (-s\\sin\\theta + t\\cos\\theta)^2 = s^2+t^2$。\n因此，生成函数恒等式变为：\n$$\n\\exp(-s^2 - t^2 + 2s\\xi_1 + 2t\\xi_2) = \\exp(-S^2 - T^2 + 2S\\Xi + 2T\\varrho) = \\exp(-S^2+2S\\Xi)\\exp(-T^2+2T\\varrho)\n$$\n这是 $H_N(\\Xi)$ 和 $H_n(\\varrho)$ 生成函数的乘积：\n$$\n\\sum_{n_1,n_2} \\frac{s^{n_1}t^{n_2}}{n_1!n_2!} H_{n_1}(\\xi_1)H_{n_2}(\\xi_2) = \\left( \\sum_N \\frac{S^N}{N!} H_N(\\Xi) \\right) \\left( \\sum_n \\frac{T^n}{n!} H_n(\\varrho) \\right) = \\sum_{N,n} \\frac{S^N T^n}{N!n!} H_N(\\Xi)H_n(\\varrho)\n$$\n归一化波函数之间的关系意味着埃尔米特多项式之间存在由归一化因子缩放的关系。当 $N+n=n_1+n_2$ 时，我们有：\n$$\n\\frac{H_{n_1}(\\xi_1)H_{n_2}(\\xi_2)}{\\sqrt{n_1!n_2!}} = \\sum_{N,n} \\mathcal{M}(N,n; n_1, n_2; \\theta) \\frac{H_N(\\Xi)H_n(\\varrho)}{\\sqrt{N!n!}}\n$$\n为了找到括号 $\\mathcal{M}$，我们在生成函数恒等式的右侧提取 $s^{n_1}t^{n_2} / (n_1!n_2!)$ 的系数。这涉及到使用二项式定理展开 $S^N T^n$：\n$$\nS^N T^n = (s\\cos\\theta + t\\sin\\theta)^N (-s\\sin\\theta + t\\cos\\theta)^n\n$$\n包含 $s^{n_1}t^{n_2}$ 的项对应于 $s$ 的总幂次为 $n_1$，$t$ 的总幂次为 $n_2$。$s$ 和 $t$ 的多项式总次数为 $N+n$。因此，必须有 $N+n = n_1+n_2$，这是振子量子数守恒的基本选择定则。如果不满足此条件，则括号为零。\n\n令 $[s^{n_1} t^{n_2}]P(s,t)$ 为多项式 $P(s,t)$ 中 $s^{n_1}t^{n_2}$ 项的系数。\n$$\n[s^{n_1} t^{n_2}] (S^N T^n) = [s^{n_1} t^{n_2}] \\left(\\sum_{k_1=0}^N \\binom{N}{k_1} (s c)^ {k_1} (t s)^{N-k_1}\\right) \\left(\\sum_{k_2=0}^n \\binom{n}{k_2} (-s s)^{k_2} (t c)^{n-k_2}\\right)\n$$\n其中 $c=\\cos\\theta, s=\\sin\\theta$。收集 $s$ 和 $t$ 的幂次：\n$$\n= [s^{n_1} t^{n_2}] \\sum_{k_1, k_2} \\binom{N}{k_1} \\binom{n}{k_2} (-1)^{k_2} s^{k_1+k_2} t^{N-k_1+n-k_2} c^{k_1+n-k_2} s^{N-k_1+k_2}\n$$\n我们需要 $k_1+k_2=n_1$ 和 $N-k_1+n-k_2=n_2$。将这两个方程相加得到 $N+n=n_1+n_2$。代入 $k_2=n_1-k_1$，我们可以对 $k_1$（现在我们称之为 $k$）求和：\n$$\nC(N,n,n_1) = \\sum_{k} (-1)^{n_1-k} \\binom{N}{k} \\binom{n}{n_1-k} (\\cos\\theta)^{k+n-(n_1-k)} (\\sin\\theta)^{N-k+(n_1-k)}\n$$\n$$\nC(N,n,n_1) = \\sum_{k=\\max(0, n_1-n)}^{\\min(N, n_1)} (-1)^{n_1-k} \\binom{N}{k} \\binom{n}{n_1-k} (\\cos\\theta)^{n-n_1+2k} (\\sin\\theta)^{N+n_1-2k}\n$$\n关联展开式：\n$$\n\\frac{H_{n_1}H_{n_2}}{n_1!n_2!} = \\sum_{N+n=n_1+n_2} \\frac{H_N H_n}{N!n!} C(N,n,n_1) \\implies H_{n_1}H_{n_2} = \\sum_{N+n=n_1+n_2} \\frac{n_1!n_2!}{N!n!} C(N,n,n_1) H_N H_n\n$$\n将此与以括号 $\\mathcal{M}$ 表示的展开式进行比较：\n$$\n\\mathcal{M}(N,n; n_1, n_2; \\theta) = \\sqrt{\\frac{n_1!n_2!}{N!n!}} \\frac{n_1!n_2!}{N!n!} C(N,n,n_1) \\frac{\\sqrt{N!n!}}{\\sqrt{n_1!n_2!}}\n$$\n这似乎过于复杂了。让我们直接对齐系数：\n$H_{n_1} H_{n_2} \\frac{1}{\\sqrt{n_1! n_2!}} = \\sum \\mathcal{M} \\frac{H_N H_n}{\\sqrt{N! n!}}$。\n生成函数展开式中 $\\frac{s^{n_1} t^{n_2}}{\\sqrt{n_1! n_2!}}$ 的系数必须匹配。\n从 $\\sum_{n_1,n_2} \\frac{s^{n_1} t^{n_2}}{n_1! n_2!} H_{n_1}H_{n_2} = \\sum_{N,n} \\frac{S^N T^n}{N!n!} H_N H_n$，我们得到 $H_{n_1}H_{n_2} = n_1! n_2! \\sum_{N,n} \\frac{H_N H_n}{N!n!} [s^{n_1}t^{n_2}](S^N T^n)$。\n将此代入括号关系中：\n$\\frac{n_1! n_2!}{\\sqrt{n_1! n_2!}} \\sum \\dots = \\sqrt{n_1! n_2!} \\sum_{N,n} \\dots$ 与 $\\sum \\mathcal{M} \\frac{H_N H_n}{\\sqrt{N!n!}}$ 匹配。\n因此 $\\mathcal{M} \\frac{1}{\\sqrt{N! n!}} = \\sqrt{n_1! n_2!} \\frac{1}{N!n!} C(N,n,n_1)$。\n$$\n\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\sqrt{\\frac{n_1!n_2!}{N!n!}} C(N,n,n_1)\n$$\n这得到了 TM 括号的最终表达式：\n$$\n\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\delta_{N+n, n_1+n_2} \\sqrt{\\frac{n_1!n_2!}{N!n!}} \\sum_{k=\\max(0, n_1-n)}^{\\min(N, n_1)} (-1)^{n_1-k} \\binom{N}{k}\\binom{n}{n_1-k} (\\cos\\theta)^{n-n_1+2k} (\\sin\\theta)^{N+n_1-2k}\n$$\n\n### 任务 2：推广到不等质量情况\n角度 $\\theta$ 由 $\\cos\\theta = \\sqrt{m_1/(m_1+m_2)}$ 和 $\\sin\\theta = \\sqrt{m_2/(m_1+m_2)}$ 定义。使用质量比 $\\alpha = m_1/m_2$，我们可以将其重新表示为：\n$$\n\\cos\\theta = \\sqrt{\\frac{m_1/m_2}{(m_1/m_2)+1}} = \\sqrt{\\frac{\\alpha}{\\alpha+1}}\n$$\n$$\n\\sin\\theta = \\sqrt{\\frac{1}{(m_1/m_2)+1}} = \\sqrt{\\frac{1}{\\alpha+1}}\n$$\n将这些表达式代入 $\\mathcal{M}$ 的公式中，即可得到作为质量比 $\\alpha$ 函数的括号。\n\n### 任务 3, 4, 5：实现与验证\n推导出的公式在一个 Python 函数中实现。它首先检查一个必要条件，即选择定则 $N+n=n_1+n_2$。如果不满足，括号为 $0$。否则，它计算关于索引 $k$ 的和。阶乘和二ionic系数使用 `scipy.special.factorial` 和 `scipy.special.comb` 进行计算，以获得良好的数值稳定性和精度，因为它们能很好地处理大数。$\\cos\\theta$ 和 $\\sin\\theta$ 的幂则使用浮点算术进行计算。\n偏差 $\\delta(\\alpha)$ 通过取给定 $\\alpha$ 下的括号值与其在等质量情况 $\\alpha=1$ 下的值之差的绝对值来计算。对于因对称性而在 $\\alpha=1$ 时括号为零的情况，这简化为 $|\\mathcal{M}(\\alpha)|$。\n变换的正交归一性是其幺正性的结果，表示为 $\\sum_{N,n} |\\langle N,n|n_1,n_2 \\rangle|^2 = 1$，其中求和是对固定初态的所有末态进行的。对于固定的总量子数 $E=n_1+n_2$，这变为 $\\sum_{N=0}^{E} [\\mathcal{M}(N, E-N; n_1, n_2; \\alpha)]^2 = 1$。实现中验证了这个和是否在很小的数值容差内等于 $1$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import comb, factorial\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the Talmi-Moshinsky bracket problem for the given test cases.\n    \"\"\"\n\n    memo_factorial = {}\n    def fact(k):\n        \"\"\"Memoized factorial for integer inputs.\"\"\"\n        if k not in memo_factorial:\n            memo_factorial[k] = factorial(k, exact=True)\n        return memo_factorial[k]\n\n    memo_comb = {}\n    def nCr_exact(n, r):\n        \"\"\"Memoized exact binomial coefficient.\"\"\"\n        if r < 0 or r > n:\n            return 0\n        if (n, r) not in memo_comb:\n            memo_comb[(n, r)] = comb(n, r, exact=True)\n        return memo_comb[(n, r)]\n\n    def compute_m(N, n, n1, n2, alpha):\n        \"\"\"\n        Computes the one-dimensional Talmi-Moshinsky bracket M(N, n; n1, n2; alpha).\n        \n        Args:\n            N (int): Center-of-mass quantum number.\n            n (int): Relative motion quantum number.\n            n1 (int): Particle 1 quantum number.\n            n2 (int): Particle 2 quantum number.\n            alpha (float): Mass ratio m1/m2.\n        \n        Returns:\n            float: The value of the Talmi-Moshinsky bracket.\n        \"\"\"\n        # Task 1: Selection rule\n        if N + n != n1 + n2:\n            return 0.0\n\n        # Task 2: Parameterization with alpha\n        cos_theta = np.sqrt(alpha / (alpha + 1.0))\n        sin_theta = np.sqrt(1.0 / (alpha + 1.0))\n\n        # Task 1: Summation for the bracket formula\n        k_min = max(0, n1 - n)\n        k_max = min(N, n1)\n\n        total_sum = 0.0\n        for k in range(k_min, k_max + 1):\n            # Using integer arithmetic for binomials and signs\n            term_coeff = ((-1)**(n1 - k)) * nCr_exact(N, k) * nCr_exact(n, n1 - k)\n            \n            # Floating point for powers\n            term_powers = (cos_theta**(n - n1 + 2 * k)) * (sin_theta**(N + n1 - 2 * k))\n            \n            total_sum += float(term_coeff) * term_powers\n\n        # Prefactor\n        try:\n            prefactor_int = fact(n1) * fact(n2) / (fact(N) * fact(n))\n        except (ValueError, OverflowError):\n            # Fallback to log-gamma for large numbers if needed, though not for these test cases\n            log_prefactor = (math.lgamma(n1 + 1) + math.lgamma(n2 + 1) - \n                             math.lgamma(N + 1) - math.lgamma(n + 1))\n            prefactor = np.exp(0.5 * log_prefactor)\n        else:\n            prefactor = np.sqrt(float(prefactor_int))\n\n        return prefactor * total_sum\n\n    test_cases = [\n        # alpha, n1, n2, N, n\n        (1.0, 1, 1, 1, 1),\n        (1.19, 1, 1, 1, 1),\n        (10.0, 1, 1, 1, 1),\n        (1.0, 2, 2, 3, 1),\n        (1.19, 2, 2, 3, 1),\n        (2.5, 0, 1, 0, 0),\n    ]\n\n    results = []\n\n    # Process test cases 1-6\n    for i, case in enumerate(test_cases):\n        alpha, n1, n2, N, n = case\n        \n        # Task 3: Compute bracket M\n        m_val = compute_m(N, n, n1, n2, alpha)\n        \n        # Task 4: Compute deviation delta\n        m_val_equal_mass = compute_m(N, n, n1, n2, 1.0)\n        delta = abs(m_val - m_val_equal_mass)\n        \n        # Selection rule check\n        rule_satisfied = (N + n == n1 + n2)\n        \n        results.append([m_val, delta, rule_satisfied])\n\n    # Process test case 7 (Orthonormality)\n    alpha_ortho, n1_ortho, n2_ortho = 1.19, 1, 1\n    total_q = n1_ortho + n2_ortho\n    ortho_sum = 0.0\n    for N_loop in range(total_q + 1):\n        n_loop = total_q - N_loop\n        m_val = compute_m(N_loop, n_loop, n1_ortho, n2_ortho, alpha_ortho)\n        ortho_sum += m_val**2\n    \n    ortho_check = abs(ortho_sum - 1.0) < 1e-12\n    results.append(ortho_check)\n\n    # Final output formatting\n    # The str() function on a list neatly formats it as '[item1, item2, ...]'\n    # and on a boolean as 'True' or 'False'. This matches the implied format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在大型核结构计算中，TM 变换和质心运动分离为何如此重要？根本原因在于有限模型空间中的基矢截断。这个练习将引导您运用所学知识，通过一个简化的模型来研究不同的基矢截断方案如何破坏质心运动的可分离性 。通过量化由于不恰当的单粒子基截断而引入的赝质心激发，您将直接体会到在实际计算中保证平移不变性的重要性，并掌握诊断和理解这类计算问题的核心技能。",
            "id": "3549211",
            "problem": "您将通过在一个一维（$1$D）双相同粒子谐振子模型中完全进行操作，来研究不同基截断下的质心分解。使用一维设置是为了使 Talmi-Moshinsky 变换精确且计算轻量，同时保留质心分解与截断赝象之间也出现在三维中的基本逻辑。\n\n定义单粒子谐振子数态 $\\lvert n_1 \\rangle \\otimes \\lvert n_2 \\rangle$，其中 $n_1$ 和 $n_2$ 为非负整数；并定义相对坐标与质心 (c.m.) 振子数态 $\\lvert n \\rangle_{\\text{rel}} \\otimes \\lvert N \\rangle_{\\text{cm}}$，其中 $n$ 和 $N$ 也为非负整数。在此一维设置中，Talmi-Moshinsky 变换是由产生算符的线性模式旋转所引起的幺正基变换，\n$$\na_{\\text{r}}^\\dagger = \\frac{a_1^\\dagger - a_2^\\dagger}{\\sqrt{2}}, \\quad\na_{\\text{c}}^\\dagger = \\frac{a_1^\\dagger + a_2^\\dagger}{\\sqrt{2}},\n$$\n它在双粒子单粒子基与相对/质心基之间进行映射。这两个基之间的交叠（一维 Talmi-Moshinsky 括号）为\n$$\n\\langle n, N \\vert n_1, n_2 \\rangle \\equiv U(n_1,n_2;n,N) =\n2^{-\\frac{n_1+n_2}{2}}\n\\sqrt{\\frac{n!\\,N!}{n_1!\\,n_2!}}\n\\sum_{k=k_{\\min}}^{k_{\\max}}\n\\binom{n_1}{k}\\binom{n_2}{n-k}(-1)^{n-k},\n$$\n受选择定则 $n+N=n_1+n_2$ 的约束，且 $k_{\\min}=\\max(0,n-n_2)$，$k_{\\max}=\\min(n,n_1)$。所有阶乘和二项式系数都采用它们对非负整数的标准定义，并且此变换在无限空间中是正交归一的。\n\n考虑一个目标内禀（仅相对坐标）态，它与处于振子基态的质心精确分解，\n$$\n\\lvert \\Psi \\rangle = \\left(\\sum_{n=0}^{n_{\\max}} c_n \\,\\lvert n \\rangle_{\\text{rel}}\\right) \\otimes \\lvert 0 \\rangle_{\\text{cm}},\n$$\n其中 $c_n \\in \\mathbb{R}$ 且 $\\sum_{n=0}^{n_{\\max}} c_n^2 = 1$。在完整的、未截断的空间中，此态具有精确的质心分解，质心处于 $0s$ 子空间（$N=0$）。在单粒子基中，幅值为\n$$\nA(n_1,n_2) = \\sum_{n=0}^{n_{\\max}} c_n \\, U(n_1,n_2;n,0),\n$$\n且无限空间变换保证了质心坐标中的分布精确地保持在 $N=0$。\n\n现在，在单粒子空间中施加一个基截断，并通过丢弃截断外的基分量来形成截断态：\n- 单粒子截断 $e_{\\max}$：仅保留 $n_1 \\leq n_{\\max}^{\\text{sp}}$ 和 $n_2 \\leq n_{\\max}^{\\text{sp}}$ 的分量，其中 $n_{\\max}^{\\text{sp}}$ 是允许的最大单粒子振子量子数。这是单粒子 $e_{\\max}$ 截断的一维模拟。\n- 总量子数截断 $N_{\\max}$：仅保留 $n_1 + n_2 \\leq N_{\\max}$ 的分量。这是无核壳模型 $N_{\\max}$ 截断的一维模拟。\n\n设截断、归一化的双粒子态为\n$$\n\\lvert \\Psi_{\\text{tr}} \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\lvert n_1,n_2 \\rangle,\n\\quad \\text{其中} \\quad\n\\mathcal{N} = \\sum_{\\text{kept }(n_1,n_2)} \\left|A(n_1,n_2)\\right|^2.\n$$\n将此截断态投影回相对坐标与质心基，以获得幅值\n$$\nB(n,N) = \\sum_{\\text{kept }(n_1,n_2)} U(n_1,n_2;n,N)\\,\\frac{A(n_1,n_2)}{\\sqrt{\\mathcal{N}}},\n$$\n并将处于质心振子量子数 $N$ 的概率定义为\n$$\nP(N) = \\sum_{n=0}^{S_{\\max}} \\left| B(n,N) \\right|^2,\n$$\n其中 $S_{\\max}$ 是一个对 $n+N$ 的整数上界，其值至少与保留的 $(n_1,n_2)$ 对中最大的 $n_1+n_2$ 一样大。最后，通过以下方式量化质心分解：\n- 质心量子数的期望值，\n$$\n\\langle N_{\\text{cm}} \\rangle = \\sum_{N=0}^{S_{\\max}} N \\, P(N),\n$$\n- 与 $0s$ 质心子空间的交叠，\n$$\n\\mathcal{O}_{0s} = P(0).\n$$\n\n您的任务是实现一个程序，该程序能够精确地构造上述变换，应用指定的截断，并为每个测试用例计算 $\\langle N_{\\text{cm}} \\rangle$ 和 $\\mathcal{O}_{0s}$。所有量都是无量纲的。不使用角度。不需要物理单位。\n\n实现以下测试套件。在所有情况下，输入的内禀态系数 $\\{c_n\\}$ 都是明确指定的，并且在使用前必须重新归一化以满足 $\\sum_n c_n^2 = 1$。\n- 测试用例 1（基准 $N_{\\max}$ 分解）：截断类型 $N_{\\max}$，其中 $N_{\\max}=3$；对于 $n=0,1,2,3$，系数分别为 $[1.0,\\,0.7,\\,0.5,\\,0.2]$。\n- 测试用例 2（单粒子 $e_{\\max}$ 违背）：截断类型为单粒子，其中 $n_{\\max}^{\\text{sp}}=1$；系数与测试用例 1 相同。\n- 测试用例 3（单粒子大 $e_{\\max}$ 恢复分解）：截断类型为单粒子，其中 $n_{\\max}^{\\text{sp}}=3$；系数与测试用例 1 相同。\n- 测试用例 4（小 $N_{\\max}$ 截断移除较高的内禀分量但保留质心）：截断类型 $N_{\\max}$，其中 $N_{\\max}=1$；系数与测试用例 1 相同。\n- 测试用例 5（具有单个内禀激发的边缘情况）：截断类型为单粒子，其中 $n_{\\max}^{\\text{sp}}=1$；对于 $n=0,1,2$，系数分别为 $[0.0,\\,0.0,\\,1.0]$。\n\n您的程序必须：\n- 使用所述公式精确地构造 $U(n_1,n_2;n,N)$。\n- 从内禀系数和 $U(n_1,n_2;n,0)$ 构建 $A(n_1,n_2)$。\n- 应用指定的截断。\n- 归一化并投影回去获得 $B(n,N)$，然后计算 $\\langle N_{\\text{cm}} \\rangle$ 和 $\\mathcal{O}_{0s}$。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的展平的实数列表，顺序为\n$$\n\\big[\\langle N_{\\text{cm}}\\rangle_1,\\ \\mathcal{O}_{0s,1},\\ \\langle N_{\\text{cm}}\\rangle_2,\\ \\mathcal{O}_{0s,2},\\ \\ldots,\\ \\langle N_{\\text{cm}}\\rangle_5,\\ \\mathcal{O}_{0s,5}\\big].\n$$\n例如，一个包含三个测试用例的结果将如下所示：$\\big[0.0,1.0,\\,0.375,0.8125,\\,0.0,1.0\\big]$。您的程序不得读取任何输入，也不得打印任何其他内容。",
            "solution": "用户提供的问题已经过严格验证，并被确定为 **有效** 的。该问题在科学上合理、适定且客观，提出了一个计算核物理中清晰且可形式化的任务。该问题探讨了基截断对双粒子系统质心 (c.m.) 和相对运动分解的影响，这是核结构理论中的一个基本概念。\n\n该解决方案从第一性原理出发，按规定实现必要的变换和计算。\n\n**1. Talmi-Moshinsky 变换**\n\n该问题定义在一个一维、双粒子谐振子系统中。双粒子态可以用两个等价的基来描述：单粒子 (s.p.) 基 $\\lvert n_1, n_2 \\rangle = \\lvert n_1 \\rangle \\otimes \\lvert n_2 \\rangle$，以及相对/质心基 $\\lvert n, N \\rangle = \\lvert n \\rangle_{\\text{rel}} \\otimes \\lvert N \\rangle_{\\text{cm}}$。这里，$n_1, n_2, n, N$ 是非负整数量子数。\n\n这些基之间的变换由 Talmi-Moshinsky 括号 (TMB) 给出，$U(n_1,n_2;n,N) = \\langle n, N \\vert n_1, n_2 \\rangle$。提供的公式为：\n$$\nU(n_1,n_2;n,N) = 2^{-\\frac{n_1+n_2}{2}} \\sqrt{\\frac{n!\\,N!}{n_1!\\,n_2!}} \\sum_{k=k_{\\min}}^{k_{\\max}} \\binom{n_1}{k}\\binom{n_2}{n-k}(-1)^{n-k}\n$$\n只有在振子量子总数守恒的情况下，即满足选择定则 $n_1+n_2 = n+N$ 时，此变换才非零。求和极限为 $k_{\\min}=\\max(0,n-n_2)$ 和 $k_{\\max}=\\min(n,n_1)$。将实现一个函数来计算此括号，利用数值库精确计算阶乘和二项式系数。由于对相同参数的重复调用，该函数将进行记忆化处理以提高计算效率。\n\n**2. 态的构造与初始变换**\n\n目标态 $\\lvert \\Psi \\rangle$ 被定义为完全分解的，其质心处于基态（$N=0$）：\n$$\n\\lvert \\Psi \\rangle = \\left(\\sum_{n=0}^{n_{\\max}} c_n \\,\\lvert n \\rangle_{\\text{rel}}\\right) \\otimes \\lvert 0 \\rangle_{\\text{cm}}\n$$\n提供的系数 $\\{c_n\\}$ 首先被归一化，使得 $\\sum_{n=0}^{n_{\\max}} c_n^2 = 1$。\n\n为了分析单粒子基中截断的影响，我们首先在此基中表示 $\\lvert \\Psi \\rangle$。幅值 $A(n_1,n_2) = \\langle n_1, n_2 \\vert \\Psi \\rangle$ 由下式给出：\n$$\nA(n_1,n_2) = \\sum_{n=0}^{n_{\\max}} c_n \\, \\langle n_1, n_2 \\vert n, 0 \\rangle = \\sum_{n=0}^{n_{\\max}} c_n \\, U(n_1,n_2;n,0)\n$$\n根据选择定则 $n_1+n_2=n+N$，项 $U(n_1,n_2;n,0)$ 仅在 $n = n_1+n_2$ 时非零。这将和简化为单项。如果 $n_1+n_2 \\le n_{\\max}$，幅值为：\n$$\nA(n_1,n_2) = c_{n_1+n_2} \\, U(n_1,n_2; n_1+n_2, 0)\n$$\n如果 $n_1+n_2 > n_{\\max}$，则 $A(n_1,n_2) = 0$。\n\n**3. 基截断与重归一化**\n\n接下来，对单粒子基施加截断。考虑两种方案：\n- **总量子数截断 ($N_{\\max}$)**：仅保留满足 $n_1 + n_2 \\leq N_{\\max}$ 的基态 $\\lvert n_1, n_2 \\rangle$。\n- **单粒子截断 ($e_{\\max}$)**：仅保留同时满足 $n_1 \\leq n_{\\max}^{\\text{sp}}$ 和 $n_2 \\leq n_{\\max}^{\\text{sp}}$ 的基态 $\\lvert n_1, n_2 \\rangle$。\n\n丢弃截断窗口外的基态后，得到的态不再是归一化的。通过对“保留”的对 $(n_1,n_2)$ 求和并进行重归一化来构造截断态 $\\lvert \\Psi_{\\text{tr}} \\rangle$：\n$$\n\\lvert \\Psi_{\\texttr} \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\lvert n_1,n_2 \\rangle\n$$\n其中归一化常数为 $\\mathcal{N} = \\sum_{\\text{kept }(n_1,n_2)} |A(n_1,n_2)|^2$。\n\n**4. 投影与可观测量计算**\n\n为了量化截断对质心分解的影响，将截断态 $\\lvert \\Psi_{\\text{tr}} \\rangle$ 投影回相对/质心基。新的幅值 $B(n,N) = \\langle n,N \\vert \\Psi_{\\text{tr}} \\rangle$ 为：\n$$\nB(n,N) = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\langle n,N \\vert n_1, n_2 \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} U(n_1,n_2;n,N)A(n_1,n_2)\n$$\n系统具有 $N$ 个质心激发量子的概率是所有可能的相对量子数 $n$ 的幅值平方和：\n$$\nP(N) = \\sum_{n=0}^{S_{\\max}} \\left| B(n,N) \\right|^2\n$$\n这里，$S_{\\max}$ 被选为截断空间内 $n_1+n_2$ 的最大可能值，以确保所有有贡献的态都被包括在内。\n\n最后，计算两个关键的可观测量来衡量质心分解的程度：\n- 质心激发数的期望值：$\\langle N_{\\text{cm}} \\rangle = \\sum_{N=0}^{S_{\\max}} N \\, P(N)$。\n- 与质心基态 ($0s$) 子空间的交叠：$\\mathcal{O}_{0s} = P(0)$。\n\n对于一个完全分解且无质心激发的态，我们会发现 $\\langle N_{\\text{cm}} \\rangle = 0$ 且 $\\mathcal{O}_{0s} = 1$。与这些值的偏差表明了由基截断引入的赝质心激发。该算法遍历每个测试用例，执行这些计算以产生所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb, factorial\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'N_max', 'limit': 3, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 1, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 3, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'N_max', 'limit': 1, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 1, 'coeffs': [0.0, 0.0, 1.0]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N_cm_exp, O_0s = compute_observables(\n            case['type'], case['limit'], case['coeffs']\n        )\n        results.extend([N_cm_exp, O_0s])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n@lru_cache(maxsize=None)\ndef talmi_moshinsky_bracket(n1, n2, n, N):\n    \"\"\"\n    Computes the 1D Talmi-Moshinsky bracket U(n1, n2; n, N).\n    Memoization is used to cache results for efficiency.\n    \"\"\"\n    if n1 + n2 != n + N:\n        return 0.0\n\n    # quantum numbers are small, direct computation is safe and exact.\n    # Check for impossible arguments for factorials.\n    if any(q < 0 for q in [n1, n2, n, N]):\n        return 0.0\n\n    try:\n        # Pre-factor calculation\n        prefactor = (2.0**(-0.5 * (n1 + n2))) * np.sqrt(\n            factorial(n) * factorial(N) / (factorial(n1) * factorial(n2))\n        )\n    except (ValueError, ZeroDivisionError):\n        # Handles cases like factorial of negative or division by zero from factorial(negative)\n        return 0.0\n\n    # Summation part\n    k_min = max(0, n - n2)\n    k_max = min(n, n1)\n\n    sum_val = 0.0\n    for k in range(k_min, k_max + 1):\n        term = comb(n1, k, exact=False) * comb(n2, n - k, exact=False) * ((-1)**(n - k))\n        sum_val += term\n\n    return prefactor * sum_val\n\ndef compute_observables(trunc_type, trunc_limit, coeffs_raw):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    # 1. Normalize initial coefficients\n    coeffs_raw = np.array(coeffs_raw, dtype=float)\n    norm = np.linalg.norm(coeffs_raw)\n    coeffs = coeffs_raw / norm if norm > 0 else coeffs_raw\n    n_max_coeffs = len(coeffs) - 1\n\n    # 2. Determine max quanta for this case's loops and generate \"kept\" (n1, n2) pairs\n    if trunc_type == 'N_max':\n        S_max = trunc_limit\n    else:  # single-particle\n        S_max = 2 * trunc_limit\n    \n    kept_pairs = []\n    for n1 in range(S_max + 1):\n        for n2 in range(S_max - n1 + 1):\n            is_kept = False\n            if trunc_type == 'N_max':\n                if n1 + n2 <= trunc_limit:\n                    is_kept = True\n            else:  # single-particle\n                if n1 <= trunc_limit and n2 <= trunc_limit:\n                    is_kept = True\n            \n            if is_kept:\n                kept_pairs.append((n1, n2))\n    \n    # 3. Calculate amplitudes A(n1, n2) and normalization factor N\n    A = {}\n    norm_sq = 0.0\n    \n    for n1, n2 in kept_pairs:\n        total_quanta = n1 + n2\n        if total_quanta > n_max_coeffs:\n            A[(n1, n2)] = 0.0\n        else:\n            u_val = talmi_moshinsky_bracket(n1, n2, total_quanta, 0)\n            A[(n1, n2)] = coeffs[total_quanta] * u_val\n        \n        norm_sq += A[(n1, n2)]**2\n\n    if norm_sq < 1e-15:\n        return 0.0, 0.0\n\n    norm_val = np.sqrt(norm_sq)\n\n    # 4. Project back to get B(n,N)\n    B = np.zeros((S_max + 1, S_max + 1), dtype=float)\n    for n_rel in range(S_max + 1):\n        for N_cm in range(S_max - n_rel + 1):\n            b_val = 0.0\n            for n1, n2 in kept_pairs:\n                if (n1, n2) in A:\n                    u_val = talmi_moshinsky_bracket(n1, n2, n_rel, N_cm)\n                    b_val += u_val * A[(n1, n2)]\n            \n            B[n_rel, N_cm] = b_val / norm_val\n\n    # 5. Calculate probabilities P(N)\n    P = np.zeros(S_max + 1, dtype=float)\n    for N_cm in range(S_max + 1):\n        P[N_cm] = np.sum(B[:, N_cm]**2)\n\n    # 6. Compute final observables\n    O_0s = P[0]\n    \n    N_vector = np.arange(S_max + 1)\n    N_cm_exp = np.sum(N_vector * P)\n        \n    return N_cm_exp, O_0s\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}