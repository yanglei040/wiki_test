{
    "hands_on_practices": [
        {
            "introduction": "Modern *ab initio* calculations often begin by pre-processing the nuclear Hamiltonian to improve the convergence of many-body solvers. The Similarity Renormalization Group (SRG) provides a powerful method for this, evolving the Hamiltonian via a unitary flow to suppress off-diagonal couplings that arise from short-range repulsion . This practice will guide you through the numerical implementation of the SRG flow equation, allowing you to directly observe the decoupling process and verify the crucial property of spectral invariance.",
            "id": "3541264",
            "problem": "Consider an ab initio description of light nuclei in a truncated basis where the many-body Hamiltonian is represented by a finite, real, symmetric matrix. The Similarity Renormalization Group (SRG) is a unitary transformation designed to continuously evolve the Hamiltonian to suppress off-diagonal couplings while preserving the spectrum. Starting from the nonrelativistic Hamiltonian and the principle that unitary similarity transformations preserve eigenvalues, one can define a flow with a generator constructed from a fixed reference operator. In this problem, take the generator to be the commutator of the kinetic energy operator with the evolving Hamiltonian.\n\nFundamental base:\n- Let $H_s$ denote the Hamiltonian at flow parameter $s$. The SRG flow is generated by an anti-Hermitian operator $\\eta_s$ satisfying the ordinary differential equation (ODE) $$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$ where $[\\cdot,\\cdot]$ denotes the commutator.\n- Choose the generator $\\eta_s$ to be $$\\eta_s = [T, H_s],$$ where $T$ is the fixed kinetic energy operator (diagonal in the chosen basis).\n- The flow is unitary and thus preserves the eigenvalues of $H_s$ for all $s$, provided the ODE is integrated exactly.\n\nTask:\n- Implement the SRG ODE in matrix form for given $T$ and initial Hamiltonian $H_0 = H_{s=0}$: $$\\frac{dH_s}{ds} = [[T, H_s], H_s].$$\n- Numerically integrate the ODE from $s=0$ to $s_{\\text{end}}$ for each specified test case.\n- For each test case, compute two quantities at $s_{\\text{end}}$:\n  1. The maximum absolute difference between the sorted eigenvalues of $H_0$ and $H_{s_{\\text{end}}}$, denoted $d_{\\text{spec}}$, expressed in mega-electron volts (MeV). Compute $$d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|,$$ where the eigenvalues are sorted in ascending order.\n  2. The Frobenius norm of the off-diagonal part of $H_{s_{\\text{end}}}$, denoted $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$, expressed in mega-electron volts (MeV). Compute $$\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}.$$\n\nScientific realism:\n- $T$ is diagonal with entries corresponding to single-particle kinetic energies in mega-electron volts (MeV). The initial Hamiltonian $H_0$ includes both kinetic and potential contributions and is real symmetric.\n- The flow parameter $s$ has units of $\\text{MeV}^{-2}$. All energies are in MeV.\n\nNumerical and output requirements:\n- Use a robust ODE integrator to solve for $H_s$ up to $s_{\\text{end}}$ with sufficient precision to demonstrate spectral invariance numerically.\n- Round each reported float to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). For each test case, output in order the two floats $d_{\\text{spec}}$ and $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$, so that the final output aggregates all test cases sequentially.\n\nTest suite:\n- Test case $1$ (two-level, nondegenerate kinetic energies; moderate flow): \n  - $$T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.02 \\text{ MeV}^{-2}.$$\n- Test case $2$ (boundary case, zero flow):\n  - $$T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0 \\text{ MeV}^{-2}.$$\n- Test case $3$ (degenerate kinetic energies; generator vanishes):\n  - $$T = \\begin{pmatrix} 10 & 0 \\\\ 0 & 10 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 12 & 4 \\\\ 4 & 9 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.2 \\text{ MeV}^{-2}.$$\n- Test case $4$ (three-level, widely spaced kinetic energies; noticeable decoupling):\n  - $$T = \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 15 & 0 \\\\ 0 & 0 & 40 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 4 & 3 & -2 \\\\ 3 & 17 & 4 \\\\ -2 & 4 & 37 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.05 \\text{ MeV}^{-2}.$$\n- Test case $5$ (three-level, near-degenerate pair; stronger flow):\n  - $$T = \\begin{pmatrix} 20 & 0 & 0 \\\\ 0 & 20.1 & 0 \\\\ 0 & 0 & 60 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 20.5 & 5 & -4 \\\\ 5 & 19.9 & 3 \\\\ -4 & 3 & 58.5 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.1 \\text{ MeV}^{-2}.$$\n\nAnswer specification:\n- The program must output a list of $10$ floats (two per test case), each rounded to six decimal places, expressed in MeV, in the exact order: $[d_{\\text{spec}}^{(1)}, \\|H_{\\text{off}}^{(1)}\\|_F, d_{\\text{spec}}^{(2)}, \\|H_{\\text{off}}^{(2)}\\|_F, \\dots, d_{\\text{spec}}^{(5)}, \\|H_{\\text{off}}^{(5)}\\|_F]$.",
            "solution": "The problem as stated is subjected to validation.\n\n### Step 1: Extract Givens\n- **Governing Equation (SRG ODE)**: The Hamiltonian $H_s$ at flow parameter $s$ evolves according to the ordinary differential equation (ODE):\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n- **Generator Choice**: The generator $\\eta_s$ is chosen as the commutator of the kinetic energy operator $T$ with the evolving Hamiltonian $H_s$:\n$$\n\\eta_s = [T, H_s]\n$$\n- **Combined ODE**: Substituting the generator into the SRG ODE gives the specific flow equation to be solved:\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s]\n$$\n- **Initial Condition**: Integration starts from an initial Hamiltonian $H_0 = H_{s=0}$.\n- **Properties**: $H_s$ is a real, symmetric matrix. $T$ is a real, diagonal matrix. The eigenvalues of $H_s$ are preserved for all $s$ under exact integration.\n- **Quantities to Compute at $s_{\\text{end}}$**:\n    1.  **Spectral Deviation ($d_{\\text{spec}}$)**: $d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|$, where eigenvalues $\\lambda_i$ are sorted in ascending order. Units are MeV.\n    2.  **Off-Diagonal Frobenius Norm ($\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$)**: $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}$. Units are MeV.\n- **Units**: All energies ($T$, $H$) are in MeV. The flow parameter $s$ has units of $\\text{MeV}^{-2}$.\n- **Numerical Requirements**: Use a robust ODE integrator. Round final float values to six decimal places.\n- **Test Cases**:\n    - **Case 1**: $T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix}$, $s_{\\text{end}} = 0.02$.\n    - **Case 2**: $T = \\begin{pmatrix} 5 & 0 \\\\ 0 & 25 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 2 & 8 \\\\ 8 & 24 \\end{pmatrix}$, $s_{\\text{end}} = 0$.\n    - **Case 3**: $T = \\begin{pmatrix} 10 & 0 \\\\ 0 & 10 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 12 & 4 \\\\ 4 & 9 \\end{pmatrix}$, $s_{\\text{end}} = 0.2$.\n    - **Case 4**: $T = \\begin{pmatrix} 5 & 0 & 0 \\\\ 0 & 15 & 0 \\\\ 0 & 0 & 40 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 4 & 3 & -2 \\\\ 3 & 17 & 4 \\\\ -2 & 4 & 37 \\end{pmatrix}$, $s_{\\text{end}} = 0.05$.\n    - **Case 5**: $T = \\begin{pmatrix} 20 & 0 & 0 \\\\ 0 & 20.1 & 0 \\\\ 0 & 0 & 60 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 20.5 & 5 & -4 \\\\ 5 & 19.9 & 3 \\\\ -4 & 3 & 58.5 \\end{pmatrix}$, $s_{\\text{end}} = 0.1$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the Similarity Renormalization Group, a standard and well-established method in computational nuclear physics for decoupling Hamiltonians. The choice of generator $\\eta_s = [T, H_s]$ is a common one, designed to drive the Hamiltonian towards a band-diagonal or diagonal form in the basis of the kinetic energy operator. The mathematical formulation involving commutators and unitary transformations is fundamental to quantum mechanics. The problem is a direct application of these principles.\n- **Well-Posed**: The problem is an initial value problem for a system of first-order ODEs. For a finite-dimensional matrix $H_s$ of size $N \\times N$, the governing equation represents a system of $N^2$ coupled ODEs for its elements. The right-hand side, $f(H_s) = [[T, H_s], H_s]$, involves matrix multiplications and additions, which are polynomials in the elements of $H_s$. This function is smooth and globally Lipschitz on any compact domain, guaranteeing the existence and uniqueness of a solution for a given initial condition $H_0$. The task is computationally well-defined.\n- **Objective**: The problem is defined with precise mathematical objects (matrices, ODEs, norms) and specific numerical values for all test cases. There is no ambiguity or subjective language.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a scientifically sound, well-posed, and objective computational task. A solution will be provided.\n\n### Solution\n\nThe problem requires the numerical integration of a matrix-valued ordinary differential equation that describes the Similarity Renormalization Group (SRG) flow of a nuclear Hamiltonian. The goal is to evolve an initial Hamiltonian $H_0$ to a final Hamiltonian $H_{s_{\\text{end}}}$ and analyze the properties of the result.\n\nThe core of the problem lies in solving the initial value problem:\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s], \\quad H(s=0) = H_0\n$$\nwhere $T$ is the kinetic energy matrix, $H_s$ is the Hamiltonian matrix at flow parameter $s$, and $[A, B] = AB - BA$ is the matrix commutator.\n\nThis equation represents a system of $N^2$ coupled nonlinear first-order ODEs, where $N$ is the dimension of the matrices. To solve this system numerically, we employ a standard ODE solver, such as one provided by the `scipy.integrate` library. These solvers operate on one-dimensional state vectors. Therefore, the $N \\times N$ matrix $H_s$ must be flattened into a vector of length $N^2$ to serve as the state variable for the solver.\n\nThe implementation consists of the following steps:\n\n1.  **Define the ODE System Function**: We must create a function, say `f(s, y)`, that computes the time derivative of the state vector `y`. In our case, `y` is the flattened representation of the Hamiltonian matrix $H_s$. The function will:\n    a.  Accept the current flow parameter $s$ and the flattened Hamiltonian vector `y`. It will also require the constant kinetic energy matrix $T$ and the matrix dimension $N$ as auxiliary arguments.\n    b.  Reshape the input vector `y` (length $N^2$) into an $N \\times N$ matrix, which we identify as $H_s$.\n    c.  Compute the derivative $\\frac{dH_s}{ds}$ by evaluating the double commutator:\n        i.  First, calculate the inner commutator, which acts as the generator: $\\eta_s = [T, H_s] = T H_s - H_s T$.\n        ii. Second, calculate the outer commutator, which gives the derivative: $\\frac{dH_s}{ds} = [\\eta_s, H_s] = \\eta_s H_s - H_s \\eta_s$.\n    d.  Flatten the resulting $N \\times N$ matrix $\\frac{dH_s}{ds}$ back into a one-dimensional vector of length $N^2$ and return it.\n\n2.  **Integrate the ODE for Each Test Case**: For each provided test case $(T, H_0, s_{\\text{end}})$:\n    a.  Handle trivial-flow cases: If $s_{\\text{end}}=0$ (as in Test Case 2) or if the generator $[T, H_s]$ is identically zero, the Hamiltonian does not evolve, so $H_{s_{\\text{end}}} = H_0$. The generator is identically zero if $T$ is a scalar multiple of the identity matrix (i.e., all its diagonal elements are equal, as in Test Case 3), since it would commute with any $H_s$. In these cases, we bypass the numerical integration.\n    b.  For non-trivial flows, call a numerical ODE solver (e.g., `scipy.integrate.solve_ivp`) with the function defined in step 1, the integration interval $[0, s_{\\text{end}}]$, the flattened initial Hamiltonian $H_0$, and high-precision tolerances (e.g., `rtol=1e-8`, `atol=1e-11`) to accurately capture the near-perfect conservation of eigenvalues.\n    c.  Extract the solution at $s_{\\text{end}}$ and reshape it back into the $N \\times N$ matrix $H_{s_{\\text{end}}}$.\n\n3.  **Compute Final Quantities**: Once $H_{s_{\\text{end}}}$ is obtained, calculate the two required metrics:\n    a.  **Spectral Deviation, $d_{\\text{spec}}$**: This quantity measures the numerical error of the integration, as the eigenvalues must be conserved under an exact unitary transformation.\n        i.  Compute the eigenvalues of the initial Hamiltonian $H_0$, denoted $\\{\\lambda_i(H_0)\\}$. Since $H_0$ is real and symmetric, a specialized algorithm (`numpy.linalg.eigvalsh`) is used for efficiency and stability.\n        ii. Compute the eigenvalues of the final Hamiltonian $H_{s_{\\text{end}}}$, denoted $\\{\\lambda_i(H_{s_{\\text{end}})\\}$.\n        iii. Sort both sets of eigenvalues in ascending order.\n        iv. Calculate the maximum of the absolute differences between corresponding eigenvalues: $d_{\\text{spec}} = \\max_i |\\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}})|$.\n    b.  **Off-Diagonal Frobenius Norm, $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$**: This quantity measures how much the Hamiltonian has been decoupled (driven towards a diagonal or band-diagonal form). The flow is designed to suppress off-diagonal matrix elements.\n        i.  Construct the off-diagonal part of the final Hamiltonian, $H_{\\text{off}}(s_{\\text{end}})$, by setting its diagonal elements to zero: $H_{\\text{off}} = H_{s_{\\text{end}}} - \\text{diag}(\\text{diag}(H_{s_{\\text{end}}'}))$.\n        ii. Compute the Frobenius norm of this matrix: $\\|H_{\\text{off}}\\|_F = \\sqrt{\\sum_{i \\neq j} (H_{s_{\\text{end}},ij})^2}$. This can be done directly using `numpy.linalg.norm`.\n\n4.  **Format Output**: The calculated values for $d_{\\text{spec}}$ and $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$ for each test case are rounded to six decimal places and aggregated into a single comma-separated list as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the SRG ODE for a series of test cases and computes specified metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.02,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.0,\n        },\n        {\n            \"T\": np.array([[10.0, 0.0], [0.0, 10.0]]),\n            \"H0\": np.array([[12.0, 4.0], [4.0, 9.0]]),\n            \"s_end\": 0.2,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0, 0.0], [0.0, 15.0, 0.0], [0.0, 0.0, 40.0]]),\n            \"H0\": np.array([[4.0, 3.0, -2.0], [3.0, 17.0, 4.0], [-2.0, 4.0, 37.0]]),\n            \"s_end\": 0.05,\n        },\n        {\n            \"T\": np.array([[20.0, 0.0, 0.0], [0.0, 20.1, 0.0], [0.0, 0.0, 60.0]]),\n            \"H0\": np.array([[20.5, 5.0, -4.0], [5.0, 19.9, 3.0], [-4.0, 3.0, 58.5]]),\n            \"s_end\": 0.1,\n        },\n    ]\n\n    results = []\n\n    def srg_flow_ode(s, h_flat, T, n):\n        \"\"\"\n        Computes the RHS of the SRG ODE: dH/ds = [[T, H], H].\n        The state vector h_flat is the flattened Hamiltonian matrix.\n        \"\"\"\n        H = h_flat.reshape((n, n))\n        \n        # Generator: eta = [T, H]\n        eta = T @ H - H @ T\n        \n        # Derivative: dH/ds = [eta, H]\n        dHds = eta @ H - H @ eta\n        \n        return dHds.flatten()\n\n    for case in test_cases:\n        T = case[\"T\"]\n        H0 = case[\"H0\"]\n        s_end = case[\"s_end\"]\n        n = T.shape[0]\n\n        # Since H is real and symmetric, we use eigvalsh for stability and performance.\n        eigvals0 = np.sort(np.linalg.eigvalsh(H0))\n\n        # Check for trivial flow cases:\n        # 1. Integration time s_end is 0.\n        # 2. T is a scalar multiple of identity, so [T, H] = 0 for any H.\n        #    Since T is given as diagonal, we just check if all diagonal elements are equal.\n        diag_T = np.diag(T)\n        is_T_scalar_multiple = np.allclose(diag_T, diag_T[0])\n\n        if s_end == 0.0 or is_T_scalar_multiple:\n            H_end = H0\n        else:\n            # Numerically integrate the ODE\n            sol = solve_ivp(\n                srg_flow_ode,\n                t_span=[0, s_end],\n                y0=H0.flatten(),\n                args=(T, n),\n                method='RK45',  # A robust standard choice\n                rtol=1e-9,    # Relative tolerance for high precision\n                atol=1e-12    # Absolute tolerance for high precision\n            )\n            H_end = sol.y[:, -1].reshape((n, n))\n        \n        # Compute the spectral deviation d_spec\n        eigvals_end = np.sort(np.linalg.eigvalsh(H_end))\n        d_spec = np.max(np.abs(eigvals0 - eigvals_end))\n\n        # Compute the Frobenius norm of the off-diagonal part of H(s_end)\n        H_off = H_end - np.diag(np.diag(H_end))\n        norm_H_off = np.linalg.norm(H_off, 'fro')\n\n        # Append rounded results to the list\n        results.append(round(d_spec, 6))\n        results.append(round(norm_H_off, 6))\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After preparing an appropriate Hamiltonian, the next step is to solve the many-body Schrödinger equation. The No-Core Shell Model (NCSM) is a powerful variational method for this task, but its results are inherently dependent on the finite basis truncation, controlled by $N_{\\max}$ and the oscillator frequency $\\hbar\\Omega$ . This exercise provides a practical guide to a crucial aspect of NCSM calculations: performing an extrapolation to the infinite basis limit ($N_{\\max} \\to \\infty$) by fitting results to a physically motivated exponential convergence model, thereby extracting a reliable prediction for the ground-state energy.",
            "id": "3541307",
            "problem": "Consider the No-Core Shell Model (NCSM) description of the ground-state energy of the alpha particle $^{4}\\mathrm{He}$ computed using a harmonic oscillator single-particle basis characterized by frequency $\\hbar\\Omega$ and a truncation parameter $N_{\\max}$ that limits the total number of excitation quanta. The nuclear Hamiltonian $\\hat{H}$ in an ab initio approach contains realistic two-nucleon and possibly three-nucleon interactions, and the ground state solves the Schrödinger equation $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$. The variational principle ensures that, for a fixed $\\hbar\\Omega$ and increasing $N_{\\max}$, the computed ground-state energy $E(N_{\\max};\\hbar\\Omega)$ monotonically approaches the true energy $E_{\\infty}$ from above.\n\nA widely used, scientifically sound convergence ansatz for sufficiently large $N_{\\max}$ is an exponential approach,\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}},\n$$\nwith $c(\\hbar\\Omega) > 0$ and $d(\\hbar\\Omega) > 0$ depending on the basis frequency $\\hbar\\Omega$. This ansatz encodes the expectation that truncation errors decay exponentially with increasing $N_{\\max}$ due to the short-range character of nuclear interactions and the spectral properties of $\\hat{H}$.\n\nYour task is to design and implement an extrapolation strategy that, given sets of $(N_{\\max}, E)$ points for several $\\hbar\\Omega$ values, fits the model above to estimate $E_{\\infty}$ and then selects the $\\hbar\\Omega$ that minimizes the estimated truncation bias at the largest available $N_{\\max}$ for that set. Define the truncation bias at the largest $N_{\\max}$ as\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}},\n$$\nwhere $N_{\\max}^{\\mathrm{max}}$ is the maximum $N_{\\max}$ used for that $\\hbar\\Omega$. The optimal extrapolation strategy is to choose the $\\hbar\\Omega$ that yields the smallest $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ and report the corresponding extrapolated energy $E_{\\infty}$.\n\nImplement a complete, runnable program that performs the following, strictly in the order given:\n\n- Fit, for each $\\hbar\\Omega$ dataset, the parameters $\\{E_{\\infty}, c, d\\}$ in the model $E(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$ via nonlinear least squares, enforcing $c>0$ and $d>0$ and $E_{\\infty} < \\min_{N_{\\max}} E(N_{\\max};\\hbar\\Omega)$ to remain consistent with the variational upper-bound property.\n- Compute $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ from the fitted $c$ and $d$ at the largest $N_{\\max}$ in the dataset.\n- Select the $\\hbar\\Omega$ that minimizes $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ and record its $\\hbar\\Omega$ and the corresponding fitted $E_{\\infty}$.\n- Repeat the above steps for each scenario in the test suite described below.\n\nUse the following scientifically plausible test suite of synthetic $^{4}\\mathrm{He}$ convergence datasets, generated by the model with known underlying $E_{\\infty}$ and frequency-dependent parameters, without statistical noise. Energies and frequencies must be treated in mega-electron-volts (MeV). The integer values $N_{\\max}$ are dimensionless. For each scenario, the program must construct the datasets and then perform the fits and selection.\n\n- Scenario A (happy path, multiple frequencies, ample data):\n  - True asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$.\n  - Frequencies and parameters:\n    - $\\hbar\\Omega = 12.0\\,\\mathrm{MeV}$ with $c = 10.0\\,\\mathrm{MeV}$ and $d = 0.35$.\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$ with $c = 7.0\\,\\mathrm{MeV}$ and $d = 0.50$.\n    - $\\hbar\\Omega = 20.0\\,\\mathrm{MeV}$ with $c = 5.0\\,\\mathrm{MeV}$ and $d = 0.60$.\n    - $\\hbar\\Omega = 24.0\\,\\mathrm{MeV}$ with $c = 6.5\\,\\mathrm{MeV}$ and $d = 0.45$.\n  - Truncations: $N_{\\max} \\in \\{4, 6, 8, 10, 12\\}$.\n\n- Scenario B (boundary condition, fewer points per frequency):\n  - True asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$.\n  - Frequencies and parameters:\n    - $\\hbar\\Omega = 10.0\\,\\mathrm{MeV}$ with $c = 12.0\\,\\mathrm{MeV}$ and $d = 0.30$.\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$ with $c = 8.0\\,\\mathrm{MeV}$ and $d = 0.40$.\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$ with $c = 6.0\\,\\mathrm{MeV}$ and $d = 0.50$.\n  - Truncations: $N_{\\max} \\in \\{4, 6, 8\\}$.\n\n- Scenario C (edge case, slow convergence):\n  - True asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$.\n  - Frequencies and parameters:\n    - $\\hbar\\Omega = 14.0\\,\\mathrm{MeV}$ with $c = 9.0\\,\\mathrm{MeV}$ and $d = 0.25$.\n    - $\\hbar\\Omega = 18.0\\,\\mathrm{MeV}$ with $c = 7.0\\,\\mathrm{MeV}$ and $d = 0.28$.\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$ with $c = 5.0\\,\\mathrm{MeV}$ and $d = 0.33$.\n  - Truncations: $N_{\\max} \\in \\{6, 8, 10, 12, 14\\}$.\n\nFor each scenario, the program must output the selected optimal $\\hbar\\Omega$ in $\\mathrm{MeV}$ and the corresponding extrapolated $E_{\\infty}$ in $\\mathrm{MeV}$, both rounded to three decimal places. The final output format must be a single line containing a comma-separated list of six floating-point values enclosed in square brackets:\n$[\\hbar\\Omega_{\\mathrm{opt}}^{A}, E_{\\infty}^{A}, \\hbar\\Omega_{\\mathrm{opt}}^{B}, E_{\\infty}^{B}, \\hbar\\Omega_{\\mathrm{opt}}^{C}, E_{\\infty}^{C}]$.\nNo additional text is permitted in the output line.",
            "solution": "The problem presented is a valid and well-posed task in computational nuclear physics. It requires the implementation of a standard data analysis procedure for extrapolating results from *ab initio* No-Core Shell Model (NCSM) calculations to the infinite model space limit. The problem is scientifically grounded, employing a widely accepted exponential convergence ansatz, and provides a clear, objective procedure for determining an optimal basis parameter and the corresponding extrapolated energy. All required data and constraints are fully specified. We will therefore proceed with a complete solution.\n\nThe fundamental goal is to determine the ground-state energy $E_0$ of the alpha particle, ${}^{4}\\text{He}$, by solving the many-body Schrödinger equation, $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$. In the NCSM framework, the nuclear Hamiltonian $\\hat{H}$ is diagonalized in a basis of many-body states constructed from single-particle harmonic oscillator wavefunctions. The basis is necessarily truncated for computational feasibility. This truncation is controlled by the parameter $N_{\\max}$, which limits the total number of harmonic oscillator excitation quanta allowed in a basis state. The single-particle basis itself is defined by the harmonic oscillator frequency $\\hbar\\Omega$.\n\nThe calculated ground-state energy, denoted $E(N_{\\max};\\hbar\\Omega)$, depends on both truncation parameters. The variational principle guarantees that this energy is an upper bound on the true energy, $E(N_{\\max};\\hbar\\Omega) \\ge E_0$. As $N_{\\max}$ increases towards infinity, the calculated energy is expected to converge to the true energy for a fixed $\\hbar\\Omega$. For sufficiently large $N_{\\max}$, this convergence is well-described by the exponential model:\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}}\n$$\nHere, $E_{\\infty}$ represents the extrapolated ground-state energy in the infinite basis limit ($N_{\\max} \\to \\infty$). The parameters $c(\\hbar\\Omega) > 0$ and $d(\\hbar\\Omega) > 0$ are positive, frequency-dependent constants that characterize the rate of convergence.\n\nThe task is to analyze synthetic datasets of $(N_{\\max}, E)$ points generated by this model for several choices of $\\hbar\\Omega$. For each scenario provided, we must identify the optimal $\\hbar\\Omega$ and the corresponding extrapolated energy $E_{\\infty}$. The criterion for optimality is the minimization of the truncation bias at the largest available $N_{\\max}$, denoted $N_{\\max}^{\\mathrm{max}}$. This bias is defined as the difference between the energy at $N_{\\max}^{\\mathrm{max}}$ and the extrapolated asymptote:\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = E(N_{\\max}^{\\mathrm{max}};\\hbar\\Omega) - E_{\\infty} = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}}\n$$\nA smaller $\\Delta_{\\mathrm{trunc}}$ indicates a faster convergence and thus a more reliable extrapolation for a given computational effort (i.e., a given $N_{\\max}^{\\mathrm{max}}$).\n\nThe algorithmic procedure is as follows:\n\n1.  **Data Generation**: For each scenario and each specified $\\hbar\\Omega$, we first construct the synthetic dataset. Using the provided true asymptote $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$, the frequency-specific parameters $c$ and $d$, and the set of $N_{\\max}$ values, we calculate the energy points $E(N_{\\max}) = E_{\\infty}^{\\mathrm{true}} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$.\n\n2.  **Constrained Nonlinear Least-Squares Fitting**: For each dataset corresponding to a single $\\hbar\\Omega$, we fit the parameters $\\{E_{\\infty}, c, d\\}$ of the exponential model. This fitting is performed using the `curve_fit` function from the `scipy.optimize` library. To ensure the physical soundness of the fit, the following constraints are strictly enforced via the `bounds` argument of the function:\n    *   $E_{\\infty} < \\min_{i} E(N_{\\max,i};\\hbar\\Omega)$: The extrapolated energy must be lower than any calculated data point, consistent with the variational principle.\n    *   $c > 0$: The convergence must be from above.\n    *   $d > 0$: The energy must converge as $N_{\\max}$ increases.\n    Since the datasets are generated from the model without noise, the fitting procedure is expected to recover the exact parameters $\\{E_{\\infty}^{\\mathrm{true}}, c, d\\}$ used in the data generation step. Nevertheless, performing the fit is a crucial part of demonstrating the full workflow.\n\n3.  **Truncation Bias Calculation**: With the fitted parameters $\\{E_{\\infty}^{\\mathrm{fit}}, c^{\\mathrm{fit}}, d^{\\mathrm{fit}}\\}$ for each $\\hbar\\Omega$, we compute the truncation bias $\\Delta_{\\mathrm{trunc}} = c^{\\mathrm{fit}}\\,\\mathrm{e}^{-d^{\\mathrm{fit}}\\,N_{\\max}^{\\mathrm{max}}}$, where $N_{\\max}^{\\mathrm{max}}$ is the largest value of $N_{\\max}$ in the respective dataset.\n\n4.  **Optimal Parameter Selection**: Within each scenario, we compare the calculated $\\Delta_{\\mathrm{trunc}}$ values across all available $\\hbar\\Omega$ frequencies. The optimal frequency, $\\hbar\\Omega_{\\mathrm{opt}}$, is identified as the one corresponding to the minimum $\\Delta_{\\mathrm{trunc}}$. The final result for the scenario consists of this $\\hbar\\Omega_{\\mathrm{opt}}$ and its associated extrapolated energy, $E_{\\infty}^{\\mathrm{fit}}$.\n\nThis procedure is repeated for each of the three scenarios (A, B, and C). The final output aggregates the optimal frequency and extrapolated energy pairs from all scenarios into a single formatted string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements an extrapolation strategy for No-Core Shell Model calculations.\n    For each scenario, it fits an exponential convergence model to synthetic\n    data sets for several basis frequencies, selects the optimal frequency\n    based on minimum truncation bias, and reports the corresponding\n    extrapolated energy.\n    \"\"\"\n\n    def exponential_model(n_max, e_inf, c, d):\n        \"\"\"\n        Calculates energy based on the exponential convergence ansatz.\n        E(N_max) = E_inf + c * exp(-d * N_max)\n        \"\"\"\n        return e_inf + c * np.exp(-d * n_max)\n\n    scenarios = {\n        'A': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8, 10, 12],\n            'frequencies': [\n                {'hw': 12.0, 'c': 10.0, 'd': 0.35},\n                {'hw': 16.0, 'c': 7.0, 'd': 0.50},\n                {'hw': 20.0, 'c': 5.0, 'd': 0.60},\n                {'hw': 24.0, 'c': 6.5, 'd': 0.45},\n            ]\n        },\n        'B': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8],\n            'frequencies': [\n                {'hw': 10.0, 'c': 12.0, 'd': 0.30},\n                {'hw': 16.0, 'c': 8.0, 'd': 0.40},\n                {'hw': 22.0, 'c': 6.0, 'd': 0.50},\n            ]\n        },\n        'C': {\n            'e_true': -28.30,\n            'n_max': [6, 8, 10, 12, 14],\n            'frequencies': [\n                {'hw': 14.0, 'c': 9.0, 'd': 0.25},\n                {'hw': 18.0, 'c': 7.0, 'd': 0.28},\n                {'hw': 22.0, 'c': 5.0, 'd': 0.33},\n            ]\n        }\n    }\n\n    final_results = []\n    \n    # Iterate through scenarios in alphabetical order of keys to ensure consistent output\n    for scenario_key in sorted(scenarios.keys()):\n        scenario_data = scenarios[scenario_key]\n        e_true = scenario_data['e_true']\n        n_max_values = np.array(scenario_data['n_max'], dtype=float)\n        n_max_max = np.max(n_max_values)\n        \n        scenario_fit_results = []\n\n        for freq_params in scenario_data['frequencies']:\n            hw = freq_params['hw']\n            c_true = freq_params['c']\n            d_true = freq_params['d']\n\n            # Step 1: Generate synthetic data\n            e_values = exponential_model(n_max_values, e_true, c_true, d_true)\n\n            # Step 2: Perform constrained nonlinear least-squares fit\n            # Initial guess for the parameters [e_inf, c, d]\n            p0 = [e_values[-1] - 1.0, e_values[0] - e_values[-1], 0.5]\n            \n            # Define bounds: [E_inf, c, d]\n            # E_inf must be < min(E_values), c > 0, d > 0\n            lower_bounds = [-np.inf, 0, 0]\n            upper_bounds = [np.min(e_values), np.inf, np.inf]\n            bounds = (lower_bounds, upper_bounds)\n\n            try:\n                popt, _ = curve_fit(\n                    exponential_model,\n                    n_max_values,\n                    e_values,\n                    p0=p0,\n                    bounds=bounds,\n                    method='trf'\n                )\n                e_inf_fit, c_fit, d_fit = popt\n            except RuntimeError:\n                # In case of fit failure, we would handle it here.\n                # For this problem with perfect data, it's not expected.\n                e_inf_fit, c_fit, d_fit = np.nan, np.nan, np.nan\n\n            # Step 3: Compute truncation bias\n            delta_trunc = c_fit * np.exp(-d_fit * n_max_max)\n            \n            scenario_fit_results.append({\n                'hw': hw,\n                'e_inf': e_inf_fit,\n                'delta_trunc': delta_trunc\n            })\n\n        # Step 4: Select the optimal hw based on minimum truncation bias\n        best_fit = min(scenario_fit_results, key=lambda x: x['delta_trunc'])\n        \n        final_results.append(best_fit['hw'])\n        final_results.append(best_fit['e_inf'])\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join(f'{v:.3f}' for v in final_results) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of *ab initio* theory is to make precise predictions for physical observables. The single-nucleon momentum distribution, $n(p)$, is particularly insightful as its high-momentum tail is a direct probe of short-range correlations within the nucleus . This practice explores the connection between the underlying physics and the computational artifacts, such as the regulators used to soften nuclear interactions, by having you analyze a synthetic momentum distribution and determine its asymptotic scaling behavior.",
            "id": "3541315",
            "problem": "Consider the momentum distribution $n(p)$ of a light nucleus such as $^{4}\\mathrm{He}$, defined by the Fourier transform of the one-body density matrix. Fundamentally, short-range correlations in a finite, self-bound Fermi system generate power-law behavior in the high-momentum tail of $n(p)$, while regulators introduced in realistic ab initio interactions modify the ultraviolet behavior. In this problem you will construct a controlled synthetic model for $n(p)$ that isolates regulator artifacts and estimate the local scaling exponent of the high-$p$ tail.\n\nStarting point (fundamental base and modeling assumptions):\n- The one-body momentum distribution $n(p)$ is related to the one-body density matrix by a Fourier transform. For systems with short-range correlations, the tail of $n(p)$ exhibits power-law scaling at sufficiently large $p$.\n- We model the unregulated “true” tail by a finite-range, short-distance-dominated form\n$$\nn_{\\mathrm{true}}(p) \\equiv \\frac{C}{\\left(1 + \\left(\\frac{p}{p_{0}}\\right)^{2}\\right)^{2}},\n$$\nwhich has the correct qualitative approach to a power law at large $p$, with $C$ a normalization constant and $p_{0}$ a momentum scale setting the onset of the asymptotic regime.\n- A regulator $R(p;\\Lambda,\\nu)$ mimics the effect of regularized nuclear interactions or operators in momentum space. You will consider two choices:\n  1. A rational (soft) regulator: \n  $$\n  R_{\\mathrm{rat}}(p;\\Lambda,\\nu) \\equiv \\frac{1}{1 + \\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}},\n  $$\n  where $\\Lambda$ is a cutoff scale and $\\nu$ controls the smoothness.\n  2. An exponential (Gaussian-like) regulator:\n  $$\n  R_{\\exp}(p;\\Lambda,\\nu) \\equiv \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}\\right].\n  $$\n- The regulated distribution is then\n$$\nn_{\\mathrm{reg}}(p;\\Lambda,\\nu,\\mathrm{kind}) \\equiv n_{\\mathrm{true}}(p) \\times R(p;\\Lambda,\\nu),\n$$\nwith $\\mathrm{kind}\\in\\{\\mathrm{rat},\\exp\\}$ indicating the regulator family.\n\nTask:\n- For each specified test case, construct $n_{\\mathrm{reg}}(p)$ on a linearly spaced momentum grid $p \\in [p_{\\min},p_{\\max}]$ with $N = 200$ points. Use $C = 1$ (dimensionless) and $p_{0} = 0.5$ in inverse femtometers. All momenta $p$, $p_{\\min}$, $p_{\\max}$, $\\Lambda$, and $p_{0}$ must be treated in inverse femtometers ($\\mathrm{fm}^{-1}$).\n- Estimate the local power-law exponent $\\alpha$ of the tail by a least-squares linear fit of $\\ln n_{\\mathrm{reg}}(p)$ versus $\\ln p$ over the grid. If $\\ln n_{\\mathrm{reg}}(p)$ becomes numerically ill-defined for any $p$ in the window (e.g., due to underflow), replace $n_{\\mathrm{reg}}(p)$ by $\\max\\!\\left(n_{\\mathrm{reg}}(p),\\varepsilon\\right)$ with $\\varepsilon = 10^{-300}$ before taking the logarithm. Define the fitted exponent by\n$$\n\\alpha \\equiv -\\frac{d\\,\\ln n_{\\mathrm{reg}}(p)}{d\\,\\ln p}\n$$\nas obtained from the slope of the best-fit line.\n- For each test case, return the single fitted value of $\\alpha$ (dimensionless) rounded to three decimal places.\n\nTest suite (each line is one test case specifying $(\\mathrm{kind},\\Lambda,\\nu,p_{\\min},p_{\\max})$):\n- Case $1$: $(\\mathrm{rat},\\,20.0,\\,2,\\,4.0,\\,8.0)$\n- Case $2$: $(\\mathrm{rat},\\,2.5,\\,2,\\,4.0,\\,6.0)$\n- Case $3$: $(\\mathrm{rat},\\,3.5,\\,1,\\,2.5,\\,3.5)$\n- Case $4$: $(\\exp,\\,2.0,\\,1,\\,3.0,\\,4.0)$\n\nAll momenta are in $\\mathrm{fm}^{-1}$, and the output $\\alpha$ values are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right]$), with each $\\alpha_{i}$ rounded to three decimal places and no additional text. Angles do not appear in this problem. Do not include any units in the numeric output; report only the rounded numbers.\n\nScientific realism and self-consistency:\n- The model $n_{\\mathrm{true}}(p)$ captures a finite-range approach to a power-law tail consistent with short-range correlations in nuclei.\n- The regulator families $R_{\\mathrm{rat}}$ and $R_{\\exp}$ represent commonly used smooth regulators in ab initio nuclear theory, with expected ultraviolet suppression that can alter the apparent scaling in the tail.\n- The exponent extraction via a log-log slope is a standard method to quantify power-law behavior in numerical data.\n\nFinal output format:\n- A single line containing the list $\\left[\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right]$ where each $\\alpha_{i}$ is a float rounded to three decimals, corresponding to Cases $1$ through $4$ in order.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of nuclear physics, mathematically well-posed, and presented with objective, unambiguous specifications. We may therefore proceed with a solution.\n\nThe objective is to calculate the effective power-law exponent, $\\alpha$, for the high-momentum tail of a synthetic nuclear momentum distribution, $n_{\\mathrm{reg}}(p)$, over a specified momentum range. This distribution models the behavior in a finite Fermi system, including the effects of regulators commonly used in ab initio calculations. The exponent $\\alpha$ is defined by the relation $n(p) \\propto p^{-\\alpha}$ and is extracted from a linear least-squares fit in a log-log representation.\n\nThe procedure involves three main steps: ($1$) constructing the regulated momentum distribution $n_{\\mathrm{reg}}(p)$ for each test case, ($2$) transforming the data to a logarithmic scale, and ($3$) performing a linear regression to find the slope, from which $\\alpha$ is determined.\n\nFirst, we define the components of the model. The \"true\" underlying momentum distribution, before any regulation, is given by:\n$$\nn_{\\mathrm{true}}(p) \\equiv \\frac{C}{\\left(1 + \\left(\\frac{p}{p_{0}}\\right)^{2}\\right)^{2}}\n$$\nThis form correctly captures the qualitative behavior of short-range correlations, which lead to a power-law tail. For large momentum $p \\gg p_0$, $n_{\\mathrm{true}}(p)$ asymptotically approaches $\\frac{C p_0^4}{p^4}$, implying a power-law exponent of $4$. The problem specifies the dimensionless constant $C=1$ and the momentum scale $p_0=0.5\\,\\mathrm{fm}^{-1}$.\n\nNext, we introduce a regulator function, $R(p;\\Lambda,\\nu)$, which models the ultraviolet suppression from regularized nuclear interactions. Two types of regulators are considered:\n1. A rational regulator:\n$$\nR_{\\mathrm{rat}}(p;\\Lambda,\\nu) \\equiv \\frac{1}{1 + \\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}}\n$$\n2. An exponential regulator:\n$$\nR_{\\exp}(p;\\Lambda,\\nu) \\equiv \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}\\right]\n$$\nHere, $\\Lambda$ is the cutoff momentum scale, and $\\nu$ is a parameter controlling the smoothness of the cutoff. The regulated momentum distribution is the product of the true distribution and the regulator:\n$$\nn_{\\mathrm{reg}}(p;\\Lambda,\\nu,\\mathrm{kind}) \\equiv n_{\\mathrm{true}}(p) \\times R(p;\\Lambda,\\nu)\n$$\nwhere `kind` specifies either the rational (`rat`) or exponential (`exp`) form.\n\nTo estimate the exponent $\\alpha$, we analyze the logarithmic form of the distribution. Assuming a local power-law behavior $n_{\\mathrm{reg}}(p) \\approx A p^{-\\alpha}$ over a certain range, we can write:\n$$\n\\ln n_{\\mathrm{reg}}(p) \\approx \\ln A - \\alpha \\ln p\n$$\nThis shows that $\\ln n_{\\mathrm{reg}}(p)$ is approximately a linear function of $\\ln p$. The slope of this linear relationship is equal to $-\\alpha$. Therefore, the exponent $\\alpha$ can be determined as the negative of the slope of a best-fit line to the points $(\\ln p, \\ln n_{\\mathrm{reg}}(p))$.\n\nFor each test case, we are given the regulator type (`kind`), the parameters $\\Lambda$ and $\\nu$, and a momentum window $[p_{\\min}, p_{\\max}]$. The numerical procedure is as follows:\n1. Generate a discrete momentum grid of $N=200$ points, $p_i$, linearly spaced between $p_{\\min}$ and $p_{\\max}$.\n2. For each point $p_i$ on the grid, calculate the value of the regulated distribution, $n_{\\mathrm{reg}}(p_i)$, using the specified parameters for that test case.\n3. To handle potential numerical underflow when taking the logarithm of very small numbers, we apply a floor value. We compute $n'_{\\mathrm{reg}}(p_i) = \\max(n_{\\mathrm{reg}}(p_i), \\varepsilon)$, where $\\varepsilon=10^{-300}$.\n4. Create two arrays of data for the linear fit: $x_i = \\ln p_i$ and $y_i = \\ln n'_{\\mathrm{reg}}(p_i)$.\n5. Perform a linear least-squares regression on the data points $(x_i, y_i)$ to find the slope $m$. The formula for the slope is:\n$$\nm = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\nwhere $\\bar{x}$ and $\\bar{y}$ are the mean values of the respective data arrays. This calculation is readily implemented using standard numerical libraries.\n6. The desired local scaling exponent is then $\\alpha = -m$.\n7. The final result for each case is rounded to three decimal places.\n\nThis procedure is applied to each of the four test cases specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the local power-law exponent of a regulated nuclear momentum\n    distribution for a set of test cases.\n    \"\"\"\n    # Define constants and parameters from the problem statement.\n    C = 1.0  # Dimensionless normalization constant\n    p0 = 0.5  # Momentum scale in fm^-1\n    N = 200   # Number of points in the momentum grid\n    epsilon = 1e-300 # Floor value for numerical stability\n\n    # Test suite: (kind, Lambda, nu, p_min, p_max)\n    # Momenta are in fm^-1.\n    test_cases = [\n        ('rat', 20.0, 2, 4.0, 8.0),  # Case 1\n        ('rat', 2.5, 2, 4.0, 6.0),   # Case 2\n        ('rat', 3.5, 1, 2.5, 3.5),   # Case 3\n        ('exp', 2.0, 1, 3.0, 4.0),   # Case 4\n    ]\n\n    results = []\n    \n    # Define the model components as functions for clarity.\n    def n_true(p, c_val, p0_val):\n        \"\"\"Calculates the 'true' momentum distribution.\"\"\"\n        return c_val / (1 + (p / p0_val)**2)**2\n\n    def r_rat(p, lambda_val, nu_val):\n        \"\"\"Calculates the rational regulator.\"\"\"\n        return 1.0 / (1 + (p / lambda_val)**(2 * nu_val))\n\n    def r_exp(p, lambda_val, nu_val):\n        \"\"\"Calculates the exponential regulator.\"\"\"\n        return np.exp(-(p / lambda_val)**(2 * nu_val))\n        \n    for case in test_cases:\n        kind, Lambda, nu, p_min, p_max = case\n\n        # Step 1: Generate the momentum grid.\n        p_grid = np.linspace(p_min, p_max, N)\n\n        # Step 2: Construct the regulated distribution n_reg(p).\n        nt = n_true(p_grid, C, p0)\n        \n        if kind == 'rat':\n            R = r_rat(p_grid, Lambda, nu)\n        elif kind == 'exp':\n            R = r_exp(p_grid, Lambda, nu)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown regulator kind: {kind}\")\n            \n        n_reg = nt * R\n\n        # Step 3: Apply floor for numerical stability before taking the logarithm.\n        n_reg_stable = np.maximum(n_reg, epsilon)\n\n        # Step 4: Transform data to log-log scale.\n        log_p = np.log(p_grid)\n        log_n_reg = np.log(n_reg_stable)\n\n        # Step 5: Perform a linear least-squares fit to find the slope.\n        # np.polyfit with deg=1 returns [slope, intercept].\n        slope, _ = np.polyfit(log_p, log_n_reg, 1)\n\n        # Step 6: The exponent alpha is the negative of the slope.\n        alpha = -slope\n\n        # Step 7: Round to three decimal places and store the result.\n        results.append(round(alpha, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}