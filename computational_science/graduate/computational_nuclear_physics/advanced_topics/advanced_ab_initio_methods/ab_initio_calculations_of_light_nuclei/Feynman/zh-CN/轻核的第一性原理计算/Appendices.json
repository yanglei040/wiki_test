{
    "hands_on_practices": [
        {
            "introduction": "由于其“硬”的短程成分，现实的核相互作用为多体计算带来了巨大的挑战。相似性重整化群 (SRG) 是一种强大的幺正变换，它通过演化哈密顿量来抑制非对角耦合，从而“驯服”这些相互作用。在此实践中 ，您将通过数值方法实现 SRG 流方程，以直接观察这种解耦效应，并验证该方法的一个基石——哈密顿量谱的守恒性。",
            "id": "3541264",
            "problem": "考虑在一个截断基中对轻核进行从头算描述，其中多体哈密顿量由一个有限的实对称矩阵表示。相似性重整化群 (Similarity Renormalization Group, SRG) 是一种幺正变换，旨在通过连续演化哈密顿量来抑制非对角耦合，同时保持其谱不变。从非相对论哈密顿量和幺正相似变换保持本征值不变的原理出发，可以定义一个由固定参考算符构造的生成元所产生的流。在本问题中，取生成元为动能算符与演化中的哈密顿量的对易子。\n\n基本原理：\n- 令 $H_s$ 表示流参数为 $s$ 时的哈密顿量。SRG 流由一个满足常微分方程 (ODE) 的反厄米算符 $\\eta_s$ 生成：$$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$ 其中 $[\\cdot,\\cdot]$ 表示对易子。\n- 选择生成元 $\\eta_s$为：$$\\eta_s = [T, H_s],$$ 其中 $T$ 是固定的动能算符（在所选基中为对角矩阵）。\n- 只要 ODE 被精确积分，该流就是幺正的，因此对所有 $s$ 都保持 $H_s$ 的本征值不变。\n\n任务：\n- 对于给定的 $T$ 和初始哈密顿量 $H_0 = H_{s=0}$，以矩阵形式实现 SRG ODE：$$\\frac{dH_s}{ds} = [[T, H_s], H_s].$$\n- 对每个指定的测试用例，将 ODE 从 $s=0$ 数值积分到 $s=s_{\\text{end}}$。\n- 对每个测试用例，在 $s=s_{\\text{end}}$ 时计算两个量：\n  1. $H_0$ 和 $H_{s_{\\text{end}}}$ 的排序后本征值之间的最大绝对差，记为 $d_{\\text{spec}}$，以兆电子伏特 (MeV) 为单位。计算公式为：$$d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|,$$ 其中本征值按升序排列。\n  2. $H_{s_{\\text{end}}}$ 的非对角部分的弗罗贝尼乌斯范数，记为 $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$，以兆电子伏特 (MeV) 为单位。计算公式为：$$\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}.$$\n\n科学真实性：\n- $T$ 是对角矩阵，其对角元对应于以兆电子伏特 (MeV) 为单位的单粒子动能。初始哈密顿量 $H_0$ 包括动能和势能贡献，并且是实对称的。\n- 流参数 $s$ 的单位是 $\\text{MeV}^{-2}$。所有能量都以 MeV 为单位。\n\n数值和输出要求：\n- 使用一个鲁棒的 ODE 积分器求解 $H_s$ 直至 $s_{\\text{end}}$，精度需足以在数值上展示谱的不变性。\n- 将每个报告的浮点数四舍五入到六位小数。\n- 您的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”）。对于每个测试用例，按顺序输出两个浮点数 $d_{\\text{spec}}$ 和 $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$，最终输出按顺序汇总所有测试用例的结果。\n\n测试套件：\n- 测试用例 1（两能级，非简并动能；中等强度的流）：\n  - $$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.02 \\text{ MeV}^{-2}.$$\n- 测试用例 2（边界情况，零流）：\n  - $$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0 \\text{ MeV}^{-2}.$$\n- 测试用例 3（简并动能；生成元为零）：\n  - $$T = \\begin{pmatrix} 10  0 \\\\ 0  10 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 12  4 \\\\ 4  9 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.2 \\text{ MeV}^{-2}.$$\n- 测试用例 4（三能级，动能间隔大；可观察到的解耦）：\n  - $$T = \\begin{pmatrix} 5  0  0 \\\\ 0  15  0 \\\\ 0  0  40 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 4  3  -2 \\\\ 3  17  4 \\\\ -2  4  37 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.05 \\text{ MeV}^{-2}.$$\n- 测试用例 5（三能级，近简并对；更强的流）：\n  - $$T = \\begin{pmatrix} 20  0  0 \\\\ 0  20.1  0 \\\\ 0  0  60 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 20.5  5  -4 \\\\ 5  19.9  3 \\\\ -4  3  58.5 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.1 \\text{ MeV}^{-2}.$$\n\n答案规格：\n- 程序必须输出一个包含 10 个浮点数的列表（每个测试用例两个），每个浮点数四舍五入到六位小数，以 MeV 为单位，并严格按照以下顺序：$[d_{\\text{spec}}^{(1)}, \\|H_{\\text{off}}^{(1)}\\|_F, d_{\\text{spec}}^{(2)}, \\|H_{\\text{off}}^{(2)}\\|_F, \\dots, d_{\\text{spec}}^{(5)}, \\|H_{\\text{off}}^{(5)}\\|_F]$。",
            "solution": "所述问题已经过验证。\n\n### 步骤1：提取给定信息\n- **控制方程 (SRG ODE)**：流参数为 $s$ 时的哈密顿量 $H_s$ 根据常微分方程 (ODE) 演化：\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n- **生成元选择**：生成元 $\\eta_s$ 被选为动能算符 $T$ 与演化中的哈密顿量 $H_s$ 的对易子：\n$$\n\\eta_s = [T, H_s]\n$$\n- **组合后的 ODE**：将生成元代入 SRG ODE，得到需要求解的特定流方程：\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s]\n$$\n- **初始条件**：积分从初始哈密顿量 $H_0 = H_{s=0}$ 开始。\n- **性质**：$H_s$ 是一个实对称矩阵。$T$ 是一个实对角矩阵。在精确积分下，$H_s$ 的本征值对所有 $s$ 都保持不变。\n- **在 $s=s_{\\text{end}}$ 处需要计算的量**：\n    1.  **谱偏差 ($d_{\\text{spec}}$)**：$d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|$，其中本征值 $\\lambda_i$ 按升序排列。单位为 MeV。\n    2.  **非对角弗罗贝尼乌斯范数 ($\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$)**：$\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}$。单位为 MeV。\n- **单位**：所有能量（$T$，$H$）都以 MeV 为单位。流参数 $s$ 的单位为 $\\text{MeV}^{-2}$。\n- **数值要求**：使用鲁棒的 ODE 积分器。将最终的浮点数值四舍五入到六位小数。\n- **测试用例**：\n    - **用例 1**：$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix}$，$H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix}$，$s_{\\text{end}} = 0.02$。\n    - **用例 2**：$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix}$，$H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix}$，$s_{\\text{end}} = 0$。\n    - **用例 3**：$T = \\begin{pmatrix} 10  0 \\\\ 0  10 \\end{pmatrix}$，$H_0 = \\begin{pmatrix} 12  4 \\\\ 4  9 \\end{pmatrix}$，$s_{\\text{end}} = 0.2$。\n    - **用例 4**：$T = \\begin{pmatrix} 5  0  0 \\\\ 0  15  0 \\\\ 0  0  40 \\end{pmatrix}$，$H_0 = \\begin{pmatrix} 4  3  -2 \\\\ 3  17  4 \\\\ -2  4  37 \\end{pmatrix}$，$s_{\\text{end}} = 0.05$。\n    - **用例 5**：$T = \\begin{pmatrix} 20  0  0 \\\\ 0  20.1  0 \\\\ 0  0  60 \\end{pmatrix}$，$H_0 = \\begin{pmatrix} 20.5  5  -4 \\\\ 5  19.9  3 \\\\ -4  3  58.5 \\end{pmatrix}$，$s_{\\text{end}} = 0.1$。\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学基础**：该问题基于相似性重整化群，这是计算核物理学中用于解耦哈密顿量的一种标准且成熟的方法。生成元 $\\eta_s = [T, H_s]$ 的选择是一种常见选择，旨在驱动哈密顿量在动能算符的基中趋向于带状对角或对角形式。涉及对易子和幺正变换的数学表述是量子力学的基础。该问题是这些原理的直接应用。\n- **问题良置性**：该问题是一个一阶常微分方程组的初值问题。对于一个大小为 $N \\times N$ 的有限维矩阵 $H_s$，控制方程代表其元素的一个包含 $N^2$ 个耦合 ODE 的系统。右侧项 $f(H_s) = [[T, H_s], H_s]$ 涉及矩阵乘法和加法，是 $H_s$ 元素的多项式。该函数在任何紧致域上都是光滑且全局利普希茨的，保证了对于给定的初始条件 $H_0$，解的存在性和唯一性。该任务在计算上是明确定义的。\n- **客观性**：问题是用精确的数学对象（矩阵、ODE、范数）和所有测试用例的具体数值来定义的。没有歧义或主观语言。\n\n### 步骤3：结论与行动\n该问题是有效的。它是一个科学上合理、良置且客观的计算任务。将提供解决方案。\n\n### 解决方案\n\n该问题要求数值积分一个矩阵值的常微分方程，该方程描述了核哈密顿量的相似性重整化群 (SRG) 流。目标是将一个初始哈密顿量 $H_0$ 演化为一个最终哈密顿量 $H_{s_{\\text{end}}}$，并分析其结果的性质。\n\n问题的核心在于求解以下初值问题：\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s], \\quad H(s=0) = H_0\n$$\n其中 $T$ 是动能矩阵，$H_s$ 是流参数为 $s$ 时的哈密顿矩阵，$[A, B] = AB - BA$ 是矩阵对易子。\n\n该方程代表了一个包含 $N^2$ 个耦合非线性一阶 ODE 的系统，其中 $N$ 是矩阵的维度。为了数值求解这个系统，我们采用标准的 ODE 求解器，例如 `scipy.integrate` 库提供的求解器。这些求解器作用于一维状态向量。因此，必须将 $N \\times N$ 的矩阵 $H_s$ 展平为一个长度为 $N^2$ 的向量，作为求解器的状态变量。\n\n实现包括以下步骤：\n\n1.  **定义 ODE 系统函数**：我们必须创建一个函数，例如 `f(s, y)`，来计算状态向量 `y` 的时间导数。在我们的例子中，`y` 是哈密顿矩阵 $H_s$ 的展平表示。该函数将：\n    a.  接受当前流参数 `s` 和展平的哈密顿向量 `y`。它还需要恒定的动能矩阵 $T$ 和矩阵维度 $N$ 作为辅助参数。\n    b.  将输入向量 `y` (长度 $N^2$)重塑为一个 $N \\times N$ 的矩阵，我们将其识别为 $H_s$。\n    c.  通过计算双重对易子来计算导数 $\\frac{dH_s}{ds}$：\n        i.  首先，计算内层对易子，它作为生成元：$\\eta_s = [T, H_s] = T H_s - H_s T$。\n        ii. 其次，计算外层对易子，得到导数：$\\frac{dH_s}{ds} = [\\eta_s, H_s] = \\eta_s H_s - H_s \\eta_s$。\n    d.  将得到的 $N \\times N$ 导数矩阵 $\\frac{dH_s}{ds}$ 展平回一个长度为 $N^2$ 的一维向量并返回。\n\n2.  **为每个测试用例积分 ODE**：对于每个给定的测试用例 $(T, H_0, s_{\\text{end}})$：\n    a.  处理平凡流的情况：如果 $s_{\\text{end}}=0$ (如测试用例 2) 或者生成元 $[T, H_s]$ 恒为零，哈密顿量不会演化，因此 $H_{s_{\\text{end}}} = H_0$。如果 $T$ 是单位矩阵的标量倍（即其所有对角元素都相等，如测试用例 3），则生成元恒为零，因为它会与任何 $H_s$ 对易。在这些情况下，我们跳过数值积分。\n    b.  对于非平凡流，使用一个数值 ODE 求解器 (例如, `scipy.integrate.solve_ivp`)，传入步骤 1 中定义的函数、积分区间 $[0, s_{\\text{end}}]$、展平的初始哈密顿量 $H_0$ 以及高精度容差 (例如, `rtol=1e-8`, `atol=1e-11`)，以精确捕捉几乎完美的本征值守恒。\n    c.  提取在 $s_{\\text{end}}$ 处的解，并将其重塑回 $N \\times N$ 的矩阵 $H_{s_{\\text{end}}}$。\n\n3.  **计算最终量**：一旦获得 $H_{s_{\\text{end}}}$，计算两个所需的度量：\n    a.  **谱偏差，$d_{\\text{spec}}$**：这个量衡量积分的数值误差，因为在精确的幺正变换下，本征值必须守恒。\n        i.  计算初始哈密顿量 $H_0$ 的本征值，记为 $\\{\\lambda_i(H_0)\\}$。由于 $H_0$是实对称的，为了效率和稳定性，使用专门的算法 (`numpy.linalg.eigvalsh`)。\n        ii. 计算最终哈密顿量 $H_{s_{\\text{end}}}$ 的本征值，记为 $\\{\\lambda_i(H_{s_{\\text{end}}})\\}$。\n        iii. 将两组本征值按升序排序。\n        iv. 计算相应本征值之间绝对差的最大值：$d_{\\text{spec}} = \\max_i |\\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}})|$。\n    b.  **非对角弗罗贝尼乌斯范数, $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$**：这个量衡量哈密顿量被解耦的程度（即被驱动至对角或带状对角形式的程度）。该流旨在抑制非对角矩阵元。\n        i.  通过将其对角元素设为零来构造最终哈密顿量的非对角部分 $H_{\\text{off}}(s_{\\text{end}})$：$H_{\\text{off}} = H_{s_{\\text{end}}} - \\text{diag}(\\text{diag}(H_{s_{\\text{end}}}'))$。\n        ii. 计算该矩阵的弗罗贝尼乌斯范数：$\\|H_{\\text{off}}\\|_F = \\sqrt{\\sum_{i \\neq j} (H_{s_{\\text{end}},ij})^2}$。这可以直接使用 `numpy.linalg.norm` 完成。\n\n4.  **格式化输出**：每个测试用例计算出的 $d_{\\text{spec}}$ 和 $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$ 值被四舍五入到六位小数，并按规定汇总到一个逗号分隔的列表中。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the SRG ODE for a series of test cases and computes specified metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.02,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.0,\n        },\n        {\n            \"T\": np.array([[10.0, 0.0], [0.0, 10.0]]),\n            \"H0\": np.array([[12.0, 4.0], [4.0, 9.0]]),\n            \"s_end\": 0.2,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0, 0.0], [0.0, 15.0, 0.0], [0.0, 0.0, 40.0]]),\n            \"H0\": np.array([[4.0, 3.0, -2.0], [3.0, 17.0, 4.0], [-2.0, 4.0, 37.0]]),\n            \"s_end\": 0.05,\n        },\n        {\n            \"T\": np.array([[20.0, 0.0, 0.0], [0.0, 20.1, 0.0], [0.0, 0.0, 60.0]]),\n            \"H0\": np.array([[20.5, 5.0, -4.0], [5.0, 19.9, 3.0], [-4.0, 3.0, 58.5]]),\n            \"s_end\": 0.1,\n        },\n    ]\n\n    results = []\n\n    def srg_flow_ode(s, h_flat, T, n):\n        \"\"\"\n        Computes the RHS of the SRG ODE: dH/ds = [[T, H], H].\n        The state vector h_flat is the flattened Hamiltonian matrix.\n        \"\"\"\n        H = h_flat.reshape((n, n))\n        \n        # Generator: eta = [T, H]\n        eta = T @ H - H @ T\n        \n        # Derivative: dH/ds = [eta, H]\n        dHds = eta @ H - H @ eta\n        \n        return dHds.flatten()\n\n    for case in test_cases:\n        T = case[\"T\"]\n        H0 = case[\"H0\"]\n        s_end = case[\"s_end\"]\n        n = T.shape[0]\n\n        # Since H is real and symmetric, we use eigvalsh for stability and performance.\n        eigvals0 = np.sort(np.linalg.eigvalsh(H0))\n\n        # Check for trivial flow cases:\n        # 1. Integration time s_end is 0.\n        # 2. T is a scalar multiple of identity, so [T, H] = 0 for any H.\n        #    Since T is given as diagonal, we just check if all diagonal elements are equal.\n        diag_T = np.diag(T)\n        is_T_scalar_multiple = np.allclose(diag_T, diag_T[0])\n\n        if s_end == 0.0 or is_T_scalar_multiple:\n            H_end = H0\n        else:\n            # Numerically integrate the ODE\n            sol = solve_ivp(\n                srg_flow_ode,\n                t_span=[0, s_end],\n                y0=H0.flatten(),\n                args=(T, n),\n                method='RK45',  # A robust standard choice\n                rtol=1e-9,    # Relative tolerance for high precision\n                atol=1e-12    # Absolute tolerance for high precision\n            )\n            H_end = sol.y[:, -1].reshape((n, n))\n        \n        # Compute the spectral deviation d_spec\n        eigvals_end = np.sort(np.linalg.eigvalsh(H_end))\n        d_spec = np.max(np.abs(eigvals0 - eigvals_end))\n\n        # Compute the Frobenius norm of the off-diagonal part of H(s_end)\n        H_off = H_end - np.diag(np.diag(H_end))\n        norm_H_off = np.linalg.norm(H_off, 'fro')\n\n        # Append rounded results to the list\n        results.append(round(d_spec, 6))\n        results.append(round(norm_H_off, 6))\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "像无核芯壳模型 (NCSM) 这样的“从头算”方法必须在有限的、被截断的基矢空间中求解多体薛定谔方程。因此，诸如基态能量之类的计算结果会依赖于基矢参数（例如截断参数 $N_{\\max}$ 和振子频率 $\\hbar\\Omega$）。本实践  将指导您完成一项关键任务：将这些在有限空间下的计算结果外推至无限模型空间的极限，这是做出精确且具有物理意义的预测所必需的步骤。",
            "id": "3541307",
            "problem": "考虑使用谐振子单粒子基描述α粒子 $^{4}\\mathrm{He}$ 的基态能量的无核壳模型（NCSM）。该单粒子基由频率 $\\hbar\\Omega$ 和截断参数 $N_{\\max}$ 表征，$N_{\\max}$ 限制了总激发量子数。在从头计算方法中，原子核哈密顿量 $\\hat{H}$ 包含现实的两核子以及可能的三核子相互作用，其基态满足薛定谔方程 $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$。变分原理确保，对于固定的 $\\hbar\\Omega$ 和递增的 $N_{\\max}$，计算出的基态能量 $E(N_{\\max};\\hbar\\Omega)$ 从上方单调趋近于真实能量 $E_{\\infty}$。\n\n对于足够大的 $N_{\\max}$，一个广泛使用且科学合理的收敛拟设是指数趋近形式：\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}},\n$$\n其中 $c(\\hbar\\Omega) > 0$ 和 $d(\\hbar\\Omega) > 0$ 取决于基频率 $\\hbar\\Omega$。这个拟设体现了这样一种预期：由于核相互作用的短程特性和 $\\hat{H}$ 的谱特性，截断误差会随着 $N_{\\max}$ 的增加而指数衰减。\n\n您的任务是设计并实现一个外推策略。该策略给定几组不同 $\\hbar\\Omega$ 值下的 $(N_{\\max}, E)$ 数据点，通过拟合上述模型来估计 $E_{\\infty}$，然后选择一个 $\\hbar\\Omega$，使得在该组数据可用的最大 $N_{\\max}$ 处的估计截断偏差最小。将最大 $N_{\\max}$ 处的截断偏差定义为\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}},\n$$\n其中 $N_{\\max}^{\\mathrm{max}}$ 是该 $\\hbar\\Omega$ 值下使用的最大 $N_{\\max}$。最佳外推策略是选择产生最小 $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ 的 $\\hbar\\Omega$，并报告相应的外推能量 $E_{\\infty}$。\n\n请实现一个完整的、可运行的程序，严格按照以下顺序执行操作：\n\n- 对每个 $\\hbar\\Omega$ 数据集，通过非线性最小二乘法拟合模型 $E(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$ 中的参数 $\\{E_{\\infty}, c, d\\}$，强制要求 $c>0$ 和 $d>0$ 以及 $E_{\\infty}  \\min_{N_{\\max}} E(N_{\\max};\\hbar\\Omega)$，以保持与变分上界性质的一致性。\n- 根据拟合得到的 $c$ 和 $d$，计算在数据集最大 $N_{\\max}$ 处的 $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$。\n- 选择使 $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ 最小的 $\\hbar\\Omega$，并记录其 $\\hbar\\Omega$ 值和相应的拟合 $E_{\\infty}$。\n- 对下述测试套件中的每个场景重复上述步骤。\n\n使用以下科学上合理的合成 $^{4}\\mathrm{He}$ 收敛数据集测试套件。这些数据集由模型生成，具有已知的底层 $E_{\\infty}$ 和依赖于频率的参数，不含统计噪声。能量和频率必须以兆电子伏特（MeV）为单位处理。整数值 $N_{\\max}$ 是无量纲的。对于每个场景，程序必须先构建数据集，然后执行拟合和选择。\n\n- 场景A（理想情况，多个频率，充足数据）：\n  - 真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$。\n  - 频率和参数：\n    - $\\hbar\\Omega = 12.0\\,\\mathrm{MeV}$，其中 $c = 10.0\\,\\mathrm{MeV}$，$d = 0.35$。\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$，其中 $c = 7.0\\,\\mathrm{MeV}$，$d = 0.50$。\n    - $\\hbar\\Omega = 20.0\\,\\mathrm{MeV}$，其中 $c = 5.0\\,\\mathrm{MeV}$，$d = 0.60$。\n    - $\\hbar\\Omega = 24.0\\,\\mathrm{MeV}$，其中 $c = 6.5\\,\\mathrm{MeV}$，$d = 0.45$。\n  - 截断值：$N_{\\max} \\in \\{4, 6, 8, 10, 12\\}$。\n\n- 场景B（边界条件，每个频率的点较少）：\n  - 真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$。\n  - 频率和参数：\n    - $\\hbar\\Omega = 10.0\\,\\mathrm{MeV}$，其中 $c = 12.0\\,\\mathrm{MeV}$，$d = 0.30$。\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$，其中 $c = 8.0\\,\\mathrm{MeV}$，$d = 0.40$。\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$，其中 $c = 6.0\\,\\mathrm{MeV}$，$d = 0.50$。\n  - 截断值：$N_{\\max} \\in \\{4, 6, 8\\}$。\n\n- 场景C（边缘情况，收敛缓慢）：\n  - 真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$。\n  - 频率和参数：\n    - $\\hbar\\Omega = 14.0\\,\\mathrm{MeV}$，其中 $c = 9.0\\,\\mathrm{MeV}$，$d = 0.25$。\n    - $\\hbar\\Omega = 18.0\\,\\mathrm{MeV}$，其中 $c = 7.0\\,\\mathrm{MeV}$，$d = 0.28$。\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$，其中 $c = 5.0\\,\\mathrm{MeV}$，$d = 0.33$。\n  - 截断值：$N_{\\max} \\in \\{6, 8, 10, 12, 14\\}$。\n\n对于每个场景，程序必须输出所选的最佳 $\\hbar\\Omega$（单位为 MeV）和相应的外推 $E_{\\infty}$（单位为 MeV），两者均四舍五入到三位小数。最终输出格式必须是单行，包含一个由方括号括起来的、逗号分隔的六个浮点值列表：\n$[\\hbar\\Omega_{\\mathrm{opt}}^{A}, E_{\\infty}^{A}, \\hbar\\Omega_{\\mathrm{opt}}^{B}, E_{\\infty}^{B}, \\hbar\\Omega_{\\mathrm{opt}}^{C}, E_{\\infty}^{C}]$。\n输出行中不允许有任何其他文本。",
            "solution": "所提出的问题是计算核物理领域一个有效且适定的任务。它要求实现一个标准的数据分析流程，用于将*从头计算*的无核壳模型（NCSM）计算结果外推至无限模型空间极限。该问题具有科学依据，采用了广泛接受的指数收敛拟设，并为确定最佳基参数及相应的外推能量提供了清晰、客观的程序。所有必需的数据和约束条件都已完全指定。因此，我们将着手提供一个完整的解决方案。\n\n根本目标是通过求解多体薛定谔方程 $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$ 来确定α粒子 ${}^{4}\\text{He}$ 的基态能量 $E_0$。在 NCSM 框架中，原子核哈密顿量 $\\hat{H}$ 在一个由单粒子谐振子波函数构建的多体态基中进行对角化。出于计算可行性的考虑，这个基必须被截断。该截断由参数 $N_{\\max}$ 控制，它限制了基态中允许的谐振子激发量子总数。单粒子基本身由谐振子频率 $\\hbar\\Omega$ 定义。\n\n计算出的基态能量，记为 $E(N_{\\max};\\hbar\\Omega)$，依赖于这两个截断参数。变分原理保证该能量是真实能量的上界，即 $E(N_{\\max};\\hbar\\Omega) \\ge E_0$。当 $N_{\\max}$ 趋于无穷大时，对于固定的 $\\hbar\\Omega$，计算出的能量预期会收敛到真实能量。对于足够大的 $N_{\\max}$，这种收敛可以很好地由以下指数模型描述：\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}}\n$$\n此处，$E_{\\infty}$ 代表在无限基极限下（$N_{\\max} \\to \\infty$）外推得到的基态能量。参数 $c(\\hbar\\Omega)  0$ 和 $d(\\hbar\\Omega)  0$ 是正的、依赖于频率的常数，它们表征了收敛的速率。\n\n任务是分析为几个 $\\hbar\\Omega$ 选项生成的 $(N_{\\max}, E)$ 点的合成数据集。对于所提供的每个场景，我们必须确定最佳的 $\\hbar\\Omega$ 和相应的外推能量 $E_{\\infty}$。最优性判据是在可用的最大 $N_{\\max}$（记为 $N_{\\max}^{\\mathrm{max}}$）下，截断偏差的最小化。该偏差定义为在 $N_{\\max}^{\\mathrm{max}}$ 处的能量与外推渐近值之差：\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = E(N_{\\max}^{\\mathrm{max}};\\hbar\\Omega) - E_{\\infty} = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}}\n$$\n一个较小的 $\\Delta_{\\mathrm{trunc}}$ 表明收敛更快，因此对于给定的计算成本（即给定的 $N_{\\max}^{\\mathrm{max}}$），外推更为可靠。\n\n算法流程如下：\n\n1.  **数据生成**：对于每个场景和每个指定的 $\\hbar\\Omega$，我们首先构建合成数据集。使用所提供的真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$、特定于频率的参数 $c$ 和 $d$，以及 $N_{\\max}$ 值集合，我们计算能量点 $E(N_{\\max}) = E_{\\infty}^{\\mathrm{true}} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$。\n\n2.  **约束性非线性最小二乘拟合**：对于每个对应于单个 $\\hbar\\Omega$ 的数据集，我们拟合指数模型的参数 $\\{E_{\\infty}, c, d\\}$。此拟合使用 `scipy.optimize` 库中的 `curve_fit` 函数执行。为确保拟合的物理合理性，通过函数的 `bounds` 参数严格执行以下约束：\n    *   $E_{\\infty}  \\min_{i} E(N_{\\max,i};\\hbar\\Omega)$：外推能量必须低于任何计算数据点，这与变分原理一致。\n    *   $c  0$：收敛必须从上方发生。\n    *   $d  0$：能量必须随着 $N_{\\max}$ 的增加而收敛。\n    由于数据集是由无噪声模型生成的，拟合过程预期将恢复出数据生成步骤中使用的精确参数 $\\{E_{\\infty}^{\\mathrm{true}}, c, d\\}$。尽管如此，执行拟合是展示完整工作流程的关键部分。\n\n3.  **截断偏差计算**：对于每个 $\\hbar\\Omega$，使用拟合出的参数 $\\{E_{\\infty}^{\\mathrm{fit}}, c^{\\mathrm{fit}}, d^{\\mathrm{fit}}\\}$，我们计算截断偏差 $\\Delta_{\\mathrm{trunc}} = c^{\\mathrm{fit}}\\,\\mathrm{e}^{-d^{\\mathrm{fit}}\\,N_{\\max}^{\\mathrm{max}}}$，其中 $N_{\\max}^{\\mathrm{max}}$ 是相应数据集中的最大 $N_{\\max}$ 值。\n\n4.  **最佳参数选择**：在每个场景内，我们比较所有可用的 $\\hbar\\Omega$ 频率计算出的 $\\Delta_{\\mathrm{trunc}}$ 值。最佳频率 $\\hbar\\Omega_{\\mathrm{opt}}$ 被确定为对应于最小 $\\Delta_{\\mathrm{trunc}}$ 的那个。该场景的最终结果包括这个 $\\hbar\\Omega_{\\mathrm{opt}}$ 及其相关的外推能量 $E_{\\infty}^{\\mathrm{fit}}$。\n\n此过程对三个场景（A、B 和 C）中的每一个都重复进行。最终输出将所有场景的最佳频率和外推能量对汇总成一个格式化的字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements an extrapolation strategy for No-Core Shell Model calculations.\n    For each scenario, it fits an exponential convergence model to synthetic\n    data sets for several basis frequencies, selects the optimal frequency\n    based on minimum truncation bias, and reports the corresponding\n    extrapolated energy.\n    \"\"\"\n\n    def exponential_model(n_max, e_inf, c, d):\n        \"\"\"\n        Calculates energy based on the exponential convergence ansatz.\n        E(N_max) = E_inf + c * exp(-d * N_max)\n        \"\"\"\n        return e_inf + c * np.exp(-d * n_max)\n\n    scenarios = {\n        'A': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8, 10, 12],\n            'frequencies': [\n                {'hw': 12.0, 'c': 10.0, 'd': 0.35},\n                {'hw': 16.0, 'c': 7.0, 'd': 0.50},\n                {'hw': 20.0, 'c': 5.0, 'd': 0.60},\n                {'hw': 24.0, 'c': 6.5, 'd': 0.45},\n            ]\n        },\n        'B': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8],\n            'frequencies': [\n                {'hw': 10.0, 'c': 12.0, 'd': 0.30},\n                {'hw': 16.0, 'c': 8.0, 'd': 0.40},\n                {'hw': 22.0, 'c': 6.0, 'd': 0.50},\n            ]\n        },\n        'C': {\n            'e_true': -28.30,\n            'n_max': [6, 8, 10, 12, 14],\n            'frequencies': [\n                {'hw': 14.0, 'c': 9.0, 'd': 0.25},\n                {'hw': 18.0, 'c': 7.0, 'd': 0.28},\n                {'hw': 22.0, 'c': 5.0, 'd': 0.33},\n            ]\n        }\n    }\n\n    final_results = []\n    \n    # Iterate through scenarios in alphabetical order of keys to ensure consistent output\n    for scenario_key in sorted(scenarios.keys()):\n        scenario_data = scenarios[scenario_key]\n        e_true = scenario_data['e_true']\n        n_max_values = np.array(scenario_data['n_max'], dtype=float)\n        n_max_max = np.max(n_max_values)\n        \n        scenario_fit_results = []\n\n        for freq_params in scenario_data['frequencies']:\n            hw = freq_params['hw']\n            c_true = freq_params['c']\n            d_true = freq_params['d']\n\n            # Step 1: Generate synthetic data\n            e_values = exponential_model(n_max_values, e_true, c_true, d_true)\n\n            # Step 2: Perform constrained nonlinear least-squares fit\n            # Initial guess for the parameters [e_inf, c, d]\n            p0 = [e_values[-1] - 1.0, e_values[0] - e_values[-1], 0.5]\n            \n            # Define bounds: [E_inf, c, d]\n            # E_inf must be  min(E_values), c > 0, d > 0\n            lower_bounds = [-np.inf, 0, 0]\n            upper_bounds = [np.min(e_values), np.inf, np.inf]\n            bounds = (lower_bounds, upper_bounds)\n\n            try:\n                popt, _ = curve_fit(\n                    exponential_model,\n                    n_max_values,\n                    e_values,\n                    p0=p0,\n                    bounds=bounds,\n                    method='trf'\n                )\n                e_inf_fit, c_fit, d_fit = popt\n            except RuntimeError:\n                # In case of fit failure, we would handle it here.\n                # For this problem with perfect data, it's not expected.\n                e_inf_fit, c_fit, d_fit = np.nan, np.nan, np.nan\n\n            # Step 3: Compute truncation bias\n            delta_trunc = c_fit * np.exp(-d_fit * n_max_max)\n            \n            scenario_fit_results.append({\n                'hw': hw,\n                'e_inf': e_inf_fit,\n                'delta_trunc': delta_trunc\n            })\n\n        # Step 4: Select the optimal hw based on minimum truncation bias\n        best_fit = min(scenario_fit_results, key=lambda x: x['delta_trunc'])\n        \n        final_results.append(best_fit['hw'])\n        final_results.append(best_fit['e_inf'])\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join(f'{v:.3f}' for v in final_results) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "除了能量，“从头算”方法还能计算丰富的其他物理可观测量，例如核子动量分布 $n(p)$。$n(p)$ 的高动量尾部为我们提供了观察原子核内部短程关联的窗口，但它也受到现代核力中固有调节子的影响。这项动手练习  让您能够探索这种相互作用，量化不同调节子如何改变动量分布的渐近行为，并帮助您批判性地评估可观测量的理论预测。",
            "id": "3541315",
            "problem": "考虑一个轻核（如 $^{4}\\mathrm{He}$）的动量分布 $n(p)$，它由单体密度矩阵的傅里叶变换定义。从根本上说，一个有限、自束缚的费米系统中的短程关联会在 $n(p)$ 的高动量尾部产生幂律行为，而在真实的从头计算（ab initio）相互作用中引入的正则化子会改变其紫外行为。在本问题中，您将为 $n(p)$ 构建一个受控的综合模型，该模型能分离出正则化子所带来的效应，并估计高动量（高 $p$）尾部的局域标度指数。\n\n起点（基本依据和建模假设）：\n- 单体动量分布 $n(p)$ 通过傅里叶变换与单体密度矩阵相关。对于具有短程关联的系统，当 $p$ 足够大时，$n(p)$ 的尾部表现出幂律标度行为。\n- 我们通过一个有限程、短程主导的形式来对未经正则化的“真实”尾部进行建模：\n$$\nn_{\\mathrm{true}}(p) \\equiv \\frac{C}{\\left(1 + \\left(\\frac{p}{p_{0}}\\right)^{2}\\right)^{2}},\n$$\n该形式在 $p$ 较大时具有正确的定性幂律趋近行为，其中 $C$ 是一个归一化常数，$p_{0}$ 是一个动量标度，用于设定渐近区域的起始点。\n- 正则化子 $R(p;\\Lambda,\\nu)$ 模拟了动量空间中正则化的核相互作用或算符的效果。您将考虑两种选择：\n  1. 一种有理（软）正则化子：\n  $$\n  R_{\\mathrm{rat}}(p;\\Lambda,\\nu) \\equiv \\frac{1}{1 + \\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}},\n  $$\n  其中 $\\Lambda$ 是一个截断标度，$\\nu$ 控制光滑度。\n  2. 一种指数（类高斯）正则化子：\n  $$\n  R_{\\exp}(p;\\Lambda,\\nu) \\equiv \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}\\right].\n  $$\n- 正则化后的分布则为\n$$\nn_{\\mathrm{reg}}(p;\\Lambda,\\nu,\\mathrm{kind}) \\equiv n_{\\mathrm{true}}(p) \\times R(p;\\Lambda,\\nu),\n$$\n其中 $\\mathrm{kind}\\in\\{\\mathrm{rat},\\exp\\}$ 表示正则化子族。\n\n任务：\n- 对每个指定的测试用例，在一个具有 $N$ 个点（其中 $N = 200$）的线性等间距动量网格 $p \\in [p_{\\min},p_{\\max}]$ 上构建 $n_{\\mathrm{reg}}(p)$。使用 $C = 1$（无量纲）和 $p_{0} = 0.5$（单位为反费米）。所有动量 $p$、$p_{\\min}$、$p_{\\max}$、$\\Lambda$ 和 $p_{0}$ 都必须以反费米（$\\mathrm{fm}^{-1}$）为单位处理。\n- 通过对网格上的 $\\ln n_{\\mathrm{reg}}(p)$ 与 $\\ln p$ 进行最小二乘线性拟合，来估计尾部的局域幂律指数 $\\alpha$。如果在窗口中的任何 $p$ 值处，$\\ln n_{\\mathrm{reg}}(p)$ 变得数值上病态（例如，由于下溢），则在取对数之前，用 $\\max\\!\\left(n_{\\mathrm{reg}}(p),\\varepsilon\\right)$（其中 $\\varepsilon = 10^{-300}$）替换 $n_{\\mathrm{reg}}(p)$。拟合指数定义为\n$$\n\\alpha \\equiv -\\frac{d\\,\\ln n_{\\mathrm{reg}}(p)}{d\\,\\ln p}\n$$\n该值由最佳拟合线的斜率得到。\n- 对每个测试用例，返回拟合得到的单一 $\\alpha$ 值（无量纲），并四舍五入到三位小数。\n\n测试套件（每行为一个测试用例，指定了 $(\\mathrm{kind},\\Lambda,\\nu,p_{\\min},p_{\\max})$）：\n- 用例 $1$：$(\\mathrm{rat},\\,20.0,\\,2,\\,4.0,\\,8.0)$\n- 用例 $2$：$(\\mathrm{rat},\\,2.5,\\,2,\\,4.0,\\,6.0)$\n- 用例 $3$：$(\\mathrm{rat},\\,3.5,\\,1,\\,2.5,\\,3.5)$\n- 用例 $4$：$(\\exp,\\,2.0,\\,1,\\,3.0,\\,4.0)$\n\n所有动量单位均为 $\\mathrm{fm}^{-1}$，输出的 $\\alpha$ 值为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right]$），每个 $\\alpha_{i}$ 都四舍五入到三位小数，且不含任何额外文本。本问题不涉及角度。请勿在数值输出中包含任何单位；仅报告四舍五入后的数字。\n\n科学真实性与自洽性：\n- 模型 $n_{\\mathrm{true}}(p)$ 捕捉了与原子核中短程关联一致的、向幂律尾部的有限程趋近行为。\n- 正则化子族 $R_{\\mathrm{rat}}$ 和 $R_{\\exp}$ 代表了从头计算核理论中常用的光滑正则化子，它们具有预期的紫外抑制效应，可能会改变尾部的表观标度行为。\n- 通过对数-对数斜率提取指数是量化数值数据中幂律行为的标准方法。\n\n最终输出格式：\n- 单行输出，包含列表 $\\left[\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right]$，其中每个 $\\alpha_{i}$ 是一个四舍五入到三位小数的浮点数，按顺序对应于用例1到4。",
            "solution": "此问题是有效的，因为它在科学上基于核物理原理，在数学上是适定的，并且其说明客观、无歧义。因此，我们可以着手求解。\n\n目标是计算一个在指定动量范围内的人工合成核动量分布 $n_{\\mathrm{reg}}(p)$ 在高动量尾部的有效幂律指数 $\\alpha$。该分布模拟了有限费米系统中的行为，包括了在从头计算中常用的正则化子的效应。指数 $\\alpha$ 由关系式 $n(p) \\propto p^{-\\alpha}$ 定义，并通过在对数-对数表示中进行线性最小二乘拟合来提取。\n\n该过程包括三个主要步骤：（1）为每个测试用例构建正则化后的动量分布 $n_{\\mathrm{reg}}(p)$；（2）将数据转换到对数标度；（3）执行线性回归以找到斜率，并由此确定 $\\alpha$。\n\n首先，我们定义模型的各个组成部分。“真实”的、未经任何正则化的底层动量分布由下式给出：\n$$\nn_{\\mathrm{true}}(p) \\equiv \\frac{C}{\\left(1 + \\left(\\frac{p}{p_{0}}\\right)^{2}\\right)^{2}}\n$$\n该形式正确地捕捉了导致幂律尾部的短程关联的定性行为。对于大动量 $p \\gg p_0$，$n_{\\mathrm{true}}(p)$ 渐近趋近于 $\\frac{C p_0^4}{p^4}$，这意味着幂律指数为4。问题指定了无量纲常数 $C=1$ 和动量标度 $p_0=0.5\\,\\mathrm{fm}^{-1}$。\n\n接下来，我们引入一个正则化子函数 $R(p;\\Lambda,\\nu)$，它模拟了来自正则化核相互作用的紫外抑制。考虑了两种类型的正则化子：\n1. 一种有理正则化子：\n$$\nR_{\\mathrm{rat}}(p;\\Lambda,\\nu) \\equiv \\frac{1}{1 + \\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}}\n$$\n2. 一种指数正则化子：\n$$\nR_{\\exp}(p;\\Lambda,\\nu) \\equiv \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}\\right]\n$$\n此处，$\\Lambda$ 是截断动量标度，$\\nu$ 是控制截断光滑度的参数。正则化后的动量分布是真实分布与正则化子的乘积：\n$$\nn_{\\mathrm{reg}}(p;\\Lambda,\\nu,\\mathrm{kind}) \\equiv n_{\\mathrm{true}}(p) \\times R(p;\\Lambda,\\nu)\n$$\n其中 `kind` 指定了有理（`rat`）或指数（`exp`）形式。\n\n为了估计指数 $\\alpha$，我们分析分布的对数形式。假设在某个范围内存在局域幂律行为 $n_{\\mathrm{reg}}(p) \\approx A p^{-\\alpha}$，我们可以写出：\n$$\n\\ln n_{\\mathrm{reg}}(p) \\approx \\ln A - \\alpha \\ln p\n$$\n这表明 $\\ln n_{\\mathrm{reg}}(p)$ 近似为 $\\ln p$ 的线性函数。这个线性关系的斜率等于 $-\\alpha$。因此，指数 $\\alpha$ 可以通过对点集 $(\\ln p, \\ln n_{\\mathrm{reg}}(p))$ 进行最佳拟合所得直线的斜率的负值来确定。\n\n对于每个测试用例，我们都给定了正则化子类型（`kind`）、参数 $\\Lambda$ 和 $\\nu$ 以及一个动量窗口 $[p_{\\min}, p_{\\max}]$。数值计算步骤如下：\n1. 在 $p_{\\min}$ 和 $p_{\\max}$ 之间生成一个由 $N=200$ 个点组成的离散动量网格 $p_i$，这些点是线性等间距的。\n2. 对于网格上的每个点 $p_i$，使用该测试用例指定的参数计算正则化分布的值 $n_{\\mathrm{reg}}(p_i)$。\n3. 为了处理对极小数取对数时可能出现的数值下溢问题，我们施加一个下限值。我们计算 $n'_{\\mathrm{reg}}(p_i) = \\max(n_{\\mathrm{reg}}(p_i), \\varepsilon)$，其中 $\\varepsilon=10^{-300}$。\n4. 为线性拟合创建两个数据数组：$x_i = \\ln p_i$ 和 $y_i = \\ln n'_{\\mathrm{reg}}(p_i)$。\n5. 对数据点 $(x_i, y_i)$ 执行线性最小二乘回归以找到斜率 $m$。斜率的计算公式为：\n$$\nm = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\n其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是对应数据数组的平均值。这个计算可以使用标准数值库轻松实现。\n6. 于是，所求的局域标度指数为 $\\alpha = -m$。\n7. 每个用例的最终结果四舍五入到三位小数。\n\n将此过程应用于问题陈述中指定的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the local power-law exponent of a regulated nuclear momentum\n    distribution for a set of test cases.\n    \"\"\"\n    # Define constants and parameters from the problem statement.\n    C = 1.0  # Dimensionless normalization constant\n    p0 = 0.5  # Momentum scale in fm^-1\n    N = 200   # Number of points in the momentum grid\n    epsilon = 1e-300 # Floor value for numerical stability\n\n    # Test suite: (kind, Lambda, nu, p_min, p_max)\n    # Momenta are in fm^-1.\n    test_cases = [\n        ('rat', 20.0, 2, 4.0, 8.0),  # Case 1\n        ('rat', 2.5, 2, 4.0, 6.0),   # Case 2\n        ('rat', 3.5, 1, 2.5, 3.5),   # Case 3\n        ('exp', 2.0, 1, 3.0, 4.0),   # Case 4\n    ]\n\n    results = []\n    \n    # Define the model components as functions for clarity.\n    def n_true(p, c_val, p0_val):\n        \"\"\"Calculates the 'true' momentum distribution.\"\"\"\n        return c_val / (1 + (p / p0_val)**2)**2\n\n    def r_rat(p, lambda_val, nu_val):\n        \"\"\"Calculates the rational regulator.\"\"\"\n        return 1.0 / (1 + (p / lambda_val)**(2 * nu_val))\n\n    def r_exp(p, lambda_val, nu_val):\n        \"\"\"Calculates the exponential regulator.\"\"\"\n        return np.exp(-(p / lambda_val)**(2 * nu_val))\n        \n    for case in test_cases:\n        kind, Lambda, nu, p_min, p_max = case\n\n        # Step 1: Generate the momentum grid.\n        p_grid = np.linspace(p_min, p_max, N)\n\n        # Step 2: Construct the regulated distribution n_reg(p).\n        nt = n_true(p_grid, C, p0)\n        \n        if kind == 'rat':\n            R = r_rat(p_grid, Lambda, nu)\n        elif kind == 'exp':\n            R = r_exp(p_grid, Lambda, nu)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown regulator kind: {kind}\")\n            \n        n_reg = nt * R\n\n        # Step 3: Apply floor for numerical stability before taking the logarithm.\n        n_reg_stable = np.maximum(n_reg, epsilon)\n\n        # Step 4: Transform data to log-log scale.\n        log_p = np.log(p_grid)\n        log_n_reg = np.log(n_reg_stable)\n\n        # Step 5: Perform a linear least-squares fit to find the slope.\n        # np.polyfit with deg=1 returns [slope, intercept].\n        slope, _ = np.polyfit(log_p, log_n_reg, 1)\n\n        # Step 6: The exponent alpha is the negative of the slope.\n        alpha = -slope\n\n        # Step 7: Round to three decimal places and store the result.\n        results.append(round(alpha, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}