{
    "hands_on_practices": [
        {
            "introduction": "在解决复杂的物理问题之前，至关重要的是要理解我们的数值近似如何影响结果。这项练习  将指导你对收敛性进行系统性研究。你将实现一个简化的法捷耶夫核，并研究当改变动量截断、网格密度和分波截断时，可观测量如何变化，从而为可靠的计算工作奠定基础。",
            "id": "3599004",
            "problem": "要求您为一个动量空间中三个全同玻色子的 Faddeev 积分方程简化模型，设计并实现一个自洽的数值收敛性研究。其目标是量化三个离散化控制参数——动量截断、网格密度和分波截断——如何影响从一个模型 Faddeev 核的主导本征模式（主导本征值及其关联的本征函数）中提取的特定可观测量的精度。在本问题中，通过采用将普朗克常数和粒子质量设为1的自然单位制，所有量均被视为无量纲。\n\n请从少体量子力学和散射理论的以下基本依据和模型假设出发：\n\n- 三体束缚态问题的 Faddeev 分解可简化为动量空间中旁观者振幅 (spectator amplitudes) 的一组耦合积分方程。在存在可分离的两体相互作用并投影到分波上之后，每个旁观者振幅都满足一个齐次本征值问题形式的积分方程，该方程由一个积分核定义，此核包含自由三体格林函数、置换几何和相互作用形状因子。\n- 在两体子系统的一级玻恩近似下（即，为此收敛性研究之目的，用势核本身替代两体跃迁矩阵），并保留秩一可分势和分波投影，可以得到一个易于处理的、经过角度平均的类 Faddeev 积分核。\n\n考虑一个轨道角动量量子数为 $l$ 的通道中的积分核的具体模型如下：\n\n1. 将负的三体能量固定为 $E_0 = -1$（无量纲）。将正参数 $|E_0| = 1$ 引入自由格林函数分母中，以避免在零能量处的奇异性。\n\n2. 定义分波 $l$ 的可分形状因子为\n$$\ng_l(k) = \\frac{k^l}{\\left(k^2 + \\beta^2\\right)^{l+1}}, \\quad \\beta = 1.5,\n$$\n以及分波耦合强度为\n$$\n\\lambda_l = \\frac{\\lambda_0}{(l+1)^2}, \\quad \\lambda_0 = 2.0.\n$$\n\n3. 对于给定的旁观者动量 $p$ 和伙伴动量 $q$ 以及它们之间夹角的余弦 $\\mu \\in [-1,1]$，定义几何因子\n$$\nr_1(p,q,\\mu) = \\sqrt{\\frac{p^2}{4} + q^2 + p q \\mu}, \\quad\nr_2(p,q,\\mu) = \\sqrt{p^2 + \\frac{q^2}{4} + p q \\mu},\n$$\n和自由传播子分母\n$$\nD(p,q,\\mu) = |E_0| + p^2 + q^2 + p q \\mu.\n$$\n\n4. 令 $P_l(\\mu)$ 为 $l$ 阶勒让德多项式。角度平均、玻恩近似、分波对角的模型核为\n$$\nK_l(p,q) = \\frac{2}{\\pi}\\,\\lambda_l \\int_{-1}^{1} \\frac{P_l(\\mu)\\, g_l\\!\\left(r_1(p,q,\\mu)\\right)\\, g_l\\!\\left(r_2(p,q,\\mu)\\right)}{D(p,q,\\mu)} \\, d\\mu.\n$$\n\n5. 截断至分波截断值 $L_{\\max}$ 的总核为\n$$\nK_{\\le L_{\\max}}(p,q) = \\sum_{l=0}^{L_{\\max}} K_l(p,q).\n$$\n\n令 $\\Lambda$ 为动量截断， $N$ 为 $p$ 和 $q$ 的求积点数。使用具有 $N$ 个节点的高斯求积和不变测度 $q^2 \\, dq$，在 $[0,\\Lambda]$ 上对旁观者函数 $\\chi(p)$ 的积分方程进行离散化，以获得一个 $N \\times N$ 的矩阵表示\n$$\n\\left[\\mathbb{K}(\\Lambda,N,L_{\\max})\\right]_{ij} = w_j \\, q_j^2 \\, K_{\\le L_{\\max}}(p_i, q_j),\n$$\n其中 $\\{(p_i,w_i)\\}_{i=1}^N$ 是映射到 $[0,\\Lambda]$ 上的求积节点和权重。将主导可观测量定义为谱半径\n$$\n\\rho(\\Lambda,N,L_{\\max}) = \\max \\left\\{ |\\lambda| : \\lambda \\in \\mathrm{spec}\\left( \\mathbb{K}(\\Lambda,N,L_{\\max}) \\right) \\right\\}.\n$$\n令 $\\mathbf{v}(\\Lambda,N,L_{\\max})$ 为对应的右本征向量（与最大模的本征值相关联），并根据求积测度进行归一化，使得\n$$\n\\sum_{i=1}^N w_i \\, p_i^2 \\, \\left| v_i \\right|^2 = 1.\n$$\n\n定义第二个可观测量，用于探测主导本征函数在低动量域的形状。对于一个固定的低动量标度 $p_0 = 2.0$，定义\n$$\nP_{\\mathrm{low}}(\\Lambda,N,L_{\\max}) = \\sum_{\\{i \\, | \\, p_i \\le \\min(p_0,\\Lambda)\\}} w_i \\, p_i^2 \\, \\left| v_i \\right|^2.\n$$\n\n为量化收敛性，定义一个在\n$$\n\\Lambda_{\\mathrm{ref}} = 30.0, \\quad N_{\\mathrm{ref}} = 80, \\quad L_{\\max}^{\\mathrm{ref}} = 4,\n$$\n处计算的高精度参考值，它产生参考可观测量 $\\rho_{\\mathrm{ref}}$ 和 $P_{\\mathrm{low,ref}}$。\n\n您的任务：\n\n- 完全按照规定实现上述模型和离散化，对动量使用 $[0,\\Lambda]$ 上的高斯求积，对 $\\mu$ 的角度积分使用 $[-1,1]$ 上的高斯求积。角度积分必须使用至少 $16$ 个高斯节点。所有量都是无量纲的；无需进行物理单位转换。\n- 对于下面测试套件中的每个参数集，构建 $\\mathbb{K}(\\Lambda,N,L_{\\max})$，计算 $\\rho(\\Lambda,N,L_{\\max})$ 和归一化的本征向量，求出 $P_{\\mathrm{low}}(\\Lambda,N,L_{\\max})$，然后计算绝对误差\n$$\n\\varepsilon_{\\rho} = \\left| \\rho(\\Lambda,N,L_{\\max}) - \\rho_{\\mathrm{ref}} \\right|,\\quad\n\\varepsilon_{P} = \\left| P_{\\mathrm{low}}(\\Lambda,N,L_{\\max}) - P_{\\mathrm{low,ref}} \\right|.\n$$\n\n测试套件（每个元组为 $(\\Lambda, N, L_{\\max})$）：\n\n- $(5.0, 16, 0)$,\n- $(10.0, 24, 1)$,\n- $(10.0, 40, 2)$,\n- $(20.0, 40, 1)$,\n- $(20.0, 64, 3)$,\n- $(8.0, 16, 2)$.\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含每个测试用例的 $\\varepsilon_{\\rho}$，然后是 $\\varepsilon_{P}$。例如，输出格式必须为\n$[e_{\\rho,1},e_{P,1},e_{\\rho,2},e_{P,2},\\dots,e_{\\rho,6},e_{P,6}]$，\n其中每个列表元素都是一个无量纲单位的浮点数。\n\n科学真实性和约束条件：\n\n- 该模型是一个简化的、可分的、经过角度平均的版本，旨在用于计算收敛性评估。请勿引入除所述内容之外的任何额外物理假设。\n- 实现必须严格遵循积分定义和归一化约定。角度变量以弧度为单位，并按规定在 $\\mu \\in [-1,1]$ 上进行积分。",
            "solution": "用户提供的问题要求对一个三玻色子系统的简化类 Faddeev 积分方程进行数值收敛性研究。该任务涉及将积分方程离散化，求解所得的矩阵本征值问题，并计算两个特定可观测量——核的谱半径和主导旁观者函数的低动量概率——相对于三个控制参数（动量截断 $\\Lambda$、求积点数 $N$ 和分波截断 $L_{\\mathrm{max}}$）的收敛情况。\n\n该问题在科学上是适定的，为一次有效的计算物理练习提供了完整且一致的定义和参数集。该模型虽然经过简化，但其基础是少体量子散射理论的原理。所有组成部分都经过了形式化定义，从而可以进行直接且明确的实现。此问题被视为有效。\n\n解决方案通过以下基于原理的步骤实现：\n\n**1. 积分方程的离散化**\n\n问题的核心是关于旁观者函数 $\\chi(p)$ 的第二类齐次 Fredholm 积分方程，表示为本征值问题：\n$$\n\\eta \\, \\chi(p) = \\int_0^{\\Lambda} K_{\\le L_{\\max}}(p, q) \\, \\chi(q) \\, q^2 dq\n$$\n其中 $\\eta$ 是一个本征值。通过应用数值求积法则，此积分方程被转换为矩阵本征值问题。我们对区间 $[0, \\Lambda]$ 上的动量积分使用高斯求积。\n\n给定标准区间 $[-1, 1]$ 上的一组 $N$ 个求积节点 $\\{x_k'\\}$ 和权重 $\\{w_k'\\}$，它们按如下方式映射到动量区间 $[0, \\Lambda]$：\n- 动量节点：$p_k = \\frac{\\Lambda}{2}(x_k' + 1)$\n- 动量权重：$w_k = \\frac{\\Lambda}{2} w_k'$\n\n应用此求积法则，积分方程变为一个线性方程组：\n$$\n\\eta \\, \\chi(p_i) \\approx \\sum_{j=1}^{N} K_{\\le L_{\\max}}(p_i, q_j) \\, \\chi(q_j) \\, q_j^2 \\, w_j\n$$\n其中 $p_i$ 和 $q_j$ 均取自同一组 $N$ 个动量节点。令 $v_i = \\chi(p_i)$ 为旁观者函数在各节点上的值的向量，我们得到 $N \\times N$ 矩阵本征值问题：\n$$\n\\eta \\, \\mathbf{v} = \\mathbb{K} \\mathbf{v}\n$$\n矩阵 $\\mathbb{K} = \\mathbb{K}(\\Lambda, N, L_{\\max})$ 的矩阵元按规定定义为：\n$$\n[\\mathbb{K}]_{ij} = w_j \\, q_j^2 \\, K_{\\le L_{\\max}}(p_i, q_j)\n$$\n\n**2. 核的构建**\n\n总核 $K_{\\le L_{\\max}}(p,q)$ 是分波贡献 $K_l(p,q)$ 在截断值 $L_{\\max}$ 内的求和：\n$$\nK_{\\le L_{\\max}}(p,q) = \\sum_{l=0}^{L_{\\max}} K_l(p,q)\n$$\n每个分波核 $K_l(p,q)$ 由对夹角余弦 $\\mu$ 的积分定义：\n$$\nK_l(p,q) = \\frac{2\\lambda_l}{\\pi} \\int_{-1}^{1} \\frac{P_l(\\mu)\\, g_l(r_1(p,q,\\mu))\\, g_l(r_2(p,q,\\mu))}{D(p,q,\\mu)} \\, d\\mu\n$$\n该积分也使用高斯求积（节点数 $N_\\mu \\ge 16$）计算。被积函数的各组成部分定义如下：\n- 耦合强度：$\\lambda_l = \\frac{\\lambda_0}{(l+1)^2}$，其中 $\\lambda_0 = 2.0$。\n- 形状因子：$g_l(k) = \\frac{k^l}{(k^2 + \\beta^2)^{l+1}}$，其中 $\\beta = 1.5$。\n- 勒让德多项式：$P_l(\\mu)$。\n- 传播子分母：$D(p,q,\\mu) = |E_0| + p^2 + q^2 + p q \\mu$，其中 $|E_0| = 1$。\n- 运动学因子：$r_1(p,q,\\mu) = \\sqrt{\\frac{p^2}{4} + q^2 + p q \\mu}$ 和 $r_2(p,q,\\mu) = \\sqrt{p^2 + \\frac{q^2}{4} + p q \\mu}$。\n\n数值实现利用矢量化操作（`numpy`）通过数组广播对 $\\mu$ 和 $l$ 进行求和，从而高效地计算整个 $N \\times N$ 矩阵 $K_{\\le L_{\\max}}(p_i, q_j)$。\n\n**3. 本征系统求解与可观测量计算**\n\n构建矩阵 $\\mathbb{K}$ 后，使用标准的数值本征求解器（`scipy.linalg.eig`）来找到其本征值 $\\lambda_k$ 和对应的右本征向量 $\\mathbf{v}'_k$。\n\n- **谱半径 $\\rho$**：第一个可观测量是谱半径，即主导本征值（绝对值最大的本征值）的模：\n$$\n\\rho(\\Lambda,N,L_{\\max}) = \\max_k |\\lambda_k|\n$$\n令 $\\mathbf{v}'$ 为与此主导本征值相关联的本征向量。\n\n- **本征向量归一化**：本征向量 $\\mathbf{v}'$ 必须根据指定的求积测度进行归一化：\n$$\n\\sum_{i=1}^N w_i \\, p_i^2 \\, |v'_i|^2 = C^2\n$$\n归一化后的本征向量为 $\\mathbf{v} = \\mathbf{v}' / C$。\n\n- **低动量概率 $P_{\\mathrm{low}}$**：第二个可观测量是在低动量区域找到旁观者粒子的概率，该区域由动量标度 $p_0 = 2.0$ 定义。它是根据归一化本征向量计算得出的：\n$$\nP_{\\mathrm{low}}(\\Lambda,N,L_{\\max}) = \\sum_{\\{i \\, | \\, p_i \\le \\min(p_0,\\Lambda)\\}} w_i \\, p_i^2 \\, |v_i|^2\n$$\n根据其构造，$P_{\\mathrm{low}}$ 是一个介于 $0$ 和 $1$ 之间的值。\n\n**4. 收敛性分析**\n\n为量化数值收敛性，首先使用参数 $(\\Lambda_{\\mathrm{ref}}, N_{\\mathrm{ref}}, L_{\\max}^{\\mathrm{ref}}) = (30.0, 80, 4)$ 计算一个高精度参考解。这会得到参考可观测量 $\\rho_{\\mathrm{ref}}$ 和 $P_{\\mathrm{low,ref}}$。\n\n对于测试套件中的每个参数集 $(\\Lambda, N, L_{\\max})$，计算可观测量 $\\rho$ 和 $P_{\\mathrm{low}}$。然后计算绝对误差：\n$$\n\\varepsilon_{\\rho} = |\\rho - \\rho_{\\mathrm{ref}}|\n$$\n$$\n\\varepsilon_{P} = |P_{\\mathrm{low}} - P_{\\mathrm{low,ref}}|\n$$\n每个测试用例的这些误差值被收集起来并在最终输出中呈现。整个算法提供了一种系统性的方法，用以评估离散化参数的选择如何影响从 Faddeev 模型中导出的物理相关可观测量的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, legendre\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Main function to run the Faddeev model convergence study.\n    \"\"\"\n    # Define physical and numerical constants from the problem statement.\n    BETA = 1.5\n    LAMBDA_0 = 2.0\n    E0_ABS = 1.0\n    P0 = 2.0\n    N_MU = 16  # Number of angular quadrature points\n\n    # Define the parameter sets for the convergence study.\n    test_cases = [\n        (5.0, 16, 0),\n        (10.0, 24, 1),\n        (10.0, 40, 2),\n        (20.0, 40, 1),\n        (20.0, 64, 3),\n        (8.0, 16, 2),\n    ]\n\n    # Define the reference parameter set.\n    ref_params = {'Lambda': 30.0, 'N': 80, 'L_max': 4}\n    \n    # Pre-compute Legendre polynomial objects for efficiency.\n    max_l_needed = max([case[2] for case in test_cases] + [ref_params['L_max']])\n    legendre_polys = [legendre(l) for l in range(max_l_needed + 1)]\n    \n    # Pre-compute angular quadrature nodes and weights.\n    mu_nodes, mu_weights = roots_legendre(N_MU)\n    \n    def g_l(k, l):\n        \"\"\"Computes the separable form factor g_l(k).\"\"\"\n        # Using np.power is safe for k=0 and l=0.\n        return np.power(k, l) / np.power(k**2 + BETA**2, l + 1)\n\n    def lambda_l(l):\n        \"\"\"Computes the partial-wave coupling strength lambda_l.\"\"\"\n        return LAMBDA_0 / (l + 1)**2\n\n    def _compute_observables(Lambda, N, L_max):\n        \"\"\"\n        Computes the observables rho and P_low for a given set of parameters.\n        \"\"\"\n        # 1. Generate momentum quadrature grid for [0, Lambda].\n        mom_nodes_base, mom_weights_base = roots_legendre(N)\n        mom_nodes = Lambda / 2.0 * (mom_nodes_base + 1.0)\n        mom_weights = Lambda / 2.0 * mom_weights_base\n\n        # 2. Vectorized construction of the total kernel K_total(p, q).\n        # Set up broadcastable arrays for p, q, and mu.\n        p_bc = mom_nodes[:, np.newaxis, np.newaxis]  # Shape (N, 1, 1)\n        q_bc = mom_nodes[np.newaxis, :, np.newaxis]  # Shape (1, N, 1)\n        mu_bc = mu_nodes[np.newaxis, np.newaxis, :]  # Shape (1, 1, N_mu)\n\n        # Calculate geometry and propagator factors, all with shape (N, N, N_mu).\n        r1_sq = p_bc**2 / 4.0 + q_bc**2 + p_bc * q_bc * mu_bc\n        r2_sq = p_bc**2 + q_bc**2 / 4.0 + p_bc * q_bc * mu_bc\n        \n        # Ensure arguments to sqrt are non-negative to avoid NaNs from float precision errors.\n        r1 = np.sqrt(np.maximum(0, r1_sq))\n        r2 = np.sqrt(np.maximum(0, r2_sq))\n        \n        D = E0_ABS + p_bc**2 + q_bc**2 + p_bc * q_bc * mu_bc\n\n        # Sum partial wave contributions K_l to get the total kernel matrix.\n        K_total_matrix = np.zeros((N, N))\n        for l in range(L_max + 1):\n            g1 = g_l(r1, l)\n            g2 = g_l(r2, l)\n            pl_mu = legendre_polys[l](mu_bc)\n            \n            integrand = pl_mu * g1 * g2 / D\n            \n            # Perform mu-integration via weighted sum over the last axis.\n            K_l_matrix = (2.0 / np.pi) * lambda_l(l) * np.sum(integrand * mu_weights[np.newaxis, np.newaxis, :], axis=2)\n            K_total_matrix += K_l_matrix\n\n        # 3. Construct the final discretized matrix for the eigenvalue problem.\n        # [K]_{ij} = w_j * q_j^2 * K_total(p_i, q_j)\n        K_matrix_final = K_total_matrix * (mom_weights * mom_nodes**2)[np.newaxis, :]\n\n        # 4. Solve the matrix eigenvalue problem.\n        eigvals, eigvecs = eig(K_matrix_final)\n\n        # 5. Find the spectral radius and the corresponding eigenvector.\n        idx_dom = np.argmax(np.abs(eigvals))\n        rho = np.abs(eigvals[idx_dom])\n        v_unnormalized = eigvecs[:, idx_dom]\n\n        # 6. Normalize the eigenvector according to the quadrature measure.\n        norm_sq = np.sum(mom_weights * mom_nodes**2 * np.abs(v_unnormalized)**2)\n        v_normalized = v_unnormalized / np.sqrt(norm_sq)\n\n        # 7. Compute the low-momentum probability P_low.\n        low_momentum_mask = mom_nodes = min(P0, Lambda)\n        P_low_integrand = mom_weights[low_momentum_mask] * mom_nodes[low_momentum_mask]**2 * np.abs(v_normalized[low_momentum_mask])**2\n        P_low = np.sum(P_low_integrand)\n\n        return rho, P_low\n\n    # Calculate reference observables.\n    rho_ref, P_low_ref = _compute_observables(**ref_params)\n\n    # Process test cases and compute errors.\n    results = []\n    for Lambda, N, L_max in test_cases:\n        rho_case, P_low_case = _compute_observables(Lambda, N, L_max)\n        \n        error_rho = abs(rho_case - rho_ref)\n        error_P_low = abs(P_low_case - P_low_ref)\n        \n        results.extend([error_rho, error_P_low])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的核相互作用通常在有效理论框架中表述，需要使用紫外调节子来处理高动量行为。这项实践  旨在探讨这一选择的实际后果。通过在一个类法捷耶夫模型中比较不同的调节子函数，你将量化它们对旁观者动量分布的影响，从而深入理解理论预测的模型依赖性。",
            "id": "3598952",
            "problem": "您需要从第一性原理出发，执行一项计算比较，研究在通过法捷耶夫方法（Faddeev approach）和短程对相互作用（short-range pairwise interactions）构建的三体束缚态问题中，旁观者动量分布（spectator momentum distributions）的差异。工作应在一个无量纲、非相对论的框架内进行，普朗克约化常数设为1，粒子质量被吸收到动量和能量尺度中，使得所有量均为无量纲。三体束缚态旁观者振幅被建模为旁观者动量变量的齐次一维积分方程的解。该模型反映了S波（S-wave）秩一可分离对相互作用，并引入了一个紫外调节子（ultraviolet regulator）。您将比较不同的调节子选择，并量化旁观者动量分布高动量尾部（high-momentum tail）的调节子赝象（regulator artifacts）。\n\n使用的基本原理：\n- 对于具有S波相互作用的全同粒子，三体法捷耶夫方程在角度平均后，可简化为关于旁观者振幅的一维齐次积分方程。对于秩一可分离二体势，此方程简化为一个积分方程，其核函数（kernel）为正且动量对称，包含自由三体预解式（free three-body resolvent）和形状因子（form factor）。\n- S波动量空间测度为 $ \\mathrm{d}^3 p = 4\\pi\\, p^2 \\mathrm{d}p $，从而得到形式为 $ \\int_0^\\infty \\mathrm{d}p\\, p^2\\,(\\cdots) $ 的径向积分。\n- 通过将形状因子乘以一个调节函数 $ r_\\Lambda(p) $ 来引入紫外正则化（Ultraviolet regularization），该函数抑制超过尺度 $ \\Lambda $ 的高动量。\n\n需实现的模型规范：\n1. 使用旁观者振幅 $ \\phi(p) $ 的齐次积分方程，\n   $$\n   \\phi(p) \\;=\\; C \\int_0^{\\infty} \\mathrm{d}q\\, q^2\\, K_\\Lambda(p,q)\\, \\phi(q),\n   $$\n   核函数为\n   $$\n   K_\\Lambda(p,q) \\;=\\; \\frac{r_\\Lambda(p)\\, g(p)\\; r_\\Lambda(q)\\, g(q)}{p^2 + q^2 + \\kappa^2}.\n   $$\n   此处 $ g(p) $ 是一个秩一形状因子，$ \\kappa $ 是一个正尺度，模拟自由三体传播子中出现的束缚动量。常数 $ C $ 代表有效核的总耦合强度。\n\n2. 使用 Yamaguchi 型形状因子\n   $$\n   g(p) \\;=\\; \\frac{1}{p^2 + \\beta^2},\n   $$\n   其中 $ \\beta = 1 $，并设置 $ \\kappa = 1 $。\n\n3. 实现三种调节子选择：\n   - 锐截止：\n     $$\n     r_\\Lambda^{\\mathrm{sharp}}(p) \\;=\\; \\Theta(\\Lambda - p),\n     $$\n     其中 $ \\Theta(x) $ 是赫维赛德阶跃函数 (Heaviside step function)。\n   - 高斯型：\n     $$\n     r_\\Lambda^{\\mathrm{gauss}}(p) \\;=\\; \\exp\\!\\Big(-\\big(\\tfrac{p}{\\Lambda}\\big)^2\\Big).\n     $$\n   - 阶数为 $ n $ 的指数型（整数 $ n \\ge 2 $）：\n     $$\n     r_\\Lambda^{\\mathrm{exp}(n)}(p) \\;=\\; \\exp\\!\\Big(-\\big(\\tfrac{p}{\\Lambda}\\big)^n\\Big).\n     $$\n\n4. 通过在 $ [0,p_{\\max}] $ 上使用具有 $ N $ 个节点的求积法（quadrature）将积分方程离散化。将节点记为 $ \\{p_i\\}_{i=1}^N $，权重记为 $ \\{w_i\\}_{i=1}^N $。近似为\n   $$\n   \\phi(p_i) \\;\\approx\\; C \\sum_{j=1}^N w_j\\, q_j^2\\, K_\\Lambda(p_i,q_j)\\, \\phi(q_j),\n   $$\n   这是一个齐次矩阵特征值问题。令 $ M_\\Lambda $ 为一个 $ N \\times N $ 矩阵，其元素为\n   $$\n   (M_\\Lambda)_{ij} \\;=\\; w_j\\, q_j^2\\, \\frac{r_\\Lambda(p_i)\\, g(p_i)\\; r_\\Lambda(q_j)\\, g(q_j)}{p_i^2 + q_j^2 + \\kappa^2}.\n   $$\n   于是积分方程变为 $ \\boldsymbol{\\phi} = C\\, M_\\Lambda\\, \\boldsymbol{\\phi} $。$ M_\\Lambda $ 的主特征值（最大特征值）决定了在给定 $ C $ 值下是否存在非平凡解。\n\n5. 通过对一个参考调节子选择进行校准来确定耦合强度 $ C $，使得对于该选择，主特征值等于1。具体而言，对于参考调节子 $ r_{\\Lambda_{\\mathrm{ref}}}^{\\mathrm{gauss}} $（其中 $ \\Lambda_{\\mathrm{ref}} = 15 $），计算当 $ C=1 $ 时 $ M_{\\Lambda_{\\mathrm{ref}}} $ 的最大特征值 $ \\lambda_{\\mathrm{ref}} $，并设置\n   $$\n   C_{\\mathrm{ref}} \\;=\\; \\frac{1}{\\lambda_{\\mathrm{ref}}}.\n   $$\n   在计算其他调节子选择的旁观者振幅时，使用相同的 $ C_{\\mathrm{ref}} $；这可以在固定的低动量校准下分离出调节子赝象。\n\n6. 对于每种调节子选择，提取 $ C_{\\mathrm{ref}} M_\\Lambda $ 的主右特征向量 $ \\boldsymbol{\\phi} $，并根据S波测度将其归一化为单位概率：\n   $$\n   \\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi(p_i)|^2 \\;=\\; 1.\n   $$\n   定义旁观者动量分布\n   $$\n   n(p_i) \\;=\\; |\\phi(p_i)|^2.\n   $$\n\n7. 定义一个尾部区域 $ p \\in [p_{\\mathrm{tail,min}}, p_{\\mathrm{tail,max}}] $，其中 $ p_{\\mathrm{tail,min}} = 8 $，$ p_{\\mathrm{tail,max}} = 15 $。通过计算与高斯参考调节子计算出的参考分布 $ n_{\\mathrm{ref}}(p) $ 相比，在尾部区域的相对加权 $ L^2 $ 误差，来量化给定调节子的调节子赝象：\n   $$\n   \\varepsilon_{\\mathrm{tail}} \\;=\\; \\frac{\\Big(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, \\big[n(p_i) - n_{\\mathrm{ref}}(p_i)\\big]^2\\Big)^{1/2}}{\\Big(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, n_{\\mathrm{ref}}(p_i)^2\\Big)^{1/2}},\n   $$\n   其中 $ \\mathcal{T} $ 是尾部区间中节点 $ p_i $ 的索引。\n\n使用的实现细节：\n- 使用 $ N = 160 $ 和 $ p_{\\max} = 20 $ 的高斯-勒让德求积法（Gauss–Legendre quadrature）在 $ [0,p_{\\max}] $ 上进行计算。\n- 使用 $ \\beta = 1 $ 和 $ \\kappa = 1 $。\n- 通过幂迭代法（power iteration scheme）计算主导特征值和特征向量，相对容差为 $ 10^{-10} $，最大迭代次数为 $ 2000 $。\n\n测试套件：\n您必须为以下每个调节子参数集计算 $ \\varepsilon_{\\mathrm{tail}} $。每个集合是一个三元组 $ (\\mathrm{type}, \\Lambda, n) $，其中对于非指数类型，$ n $ 被忽略。\n\n- $ (\\text{sharp}, 3, 0) $\n- $ (\\text{sharp}, 6, 0) $\n- $ (\\text{gauss}, 3, 0) $\n- $ (\\text{exp}, 3, 4) $\n- $ (\\text{exp}, 6, 4) $\n- $ (\\text{gauss}, 10, 0) $\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个尾部误差，格式为方括号内的逗号分隔列表，每个数字使用科学记数法表示，小数点后保留六位数字（例如，$[1.234567\\mathrm{e}{-}03,2.345678\\mathrm{e}{-}02,\\dots]$）。此问题中没有物理单位；所有量在构造上都是无量纲的。角度没有显式出现，也无需指定任何单位。",
            "solution": "该问题要求在一个简化的三体束缚态模型中，对紫外调节子对旁观者动量分布的影响进行数值研究。该模型基于法捷耶夫方程（Faddeev equations）。对于具有S波相互作用和秩一可分离势的全同粒子，该方程可简化为一维齐次积分方程。我们将离散化此方程，将其作为矩阵特征值问题求解，并量化不同调节子选择下解的高动量尾部的差异。\n\n出发点是旁观者振幅 $ \\phi(p) $ 的齐次积分方程：\n$$\n\\phi(p) \\;=\\; C \\int_0^{\\infty} \\mathrm{d}q\\, q^2\\, K_\\Lambda(p,q)\\, \\phi(q)\n$$\n仅当耦合常数 $ C $ 取特定值时，才存在非平凡解 $ \\phi(p) \\neq 0 $。核函数 $ K_\\Lambda(p,q) $ 定义为：\n$$\nK_\\Lambda(p,q) \\;=\\; \\frac{r_\\Lambda(p)\\, g(p)\\; r_\\Lambda(q)\\, g(q)}{p^2 + q^2 + \\kappa^2}\n$$\n此处，$ g(p) $ 是二体相互作用的形状因子，$ r_\\Lambda(p) $ 是一个抑制动量超过尺度 $ \\Lambda $ 的调节函数，$ \\kappa $ 是一个与三体束缚能相关的常数。给定 Yamaguchi 形状因子 $ g(p) = \\frac{1}{p^2 + \\beta^2} $，其中 $ \\beta = 1 $，并设置 $ \\kappa = 1 $。\n\n提供的调节函数是：\n1.  锐截止：$ r_\\Lambda^{\\mathrm{sharp}}(p) = \\Theta(\\Lambda - p) $，其中 $ \\Theta $ 是赫维赛德阶跃函数（Heaviside step function）。\n2.  高斯型：$ r_\\Lambda^{\\mathrm{gauss}}(p) = \\exp\\!\\left(-\\left(\\frac{p}{\\Lambda}\\right)^2\\right) $。\n3.  指数型：$ r_\\Lambda^{\\mathrm{exp}(n)}(p) = \\exp\\!\\left(-\\left(\\frac{p}{\\Lambda}\\right)^n\\right) $。\n\n为了数值求解该积分方程，我们使用求积法则将其离散化。我们将在动量区间 $ [0, p_{\\max}] $（其中 $ p_{\\max}=20 $）上使用具有 $ N = 160 $ 个点的高斯-勒让德求积法（Gauss-Legendre quadrature）。设 $ \\{x_k'\\}_{k=1}^N $ 和 $ \\{w_k'\\}_{k=1}^N $ 为 $ [-1, 1] $ 上的标准高斯-勒让德节点和权重。我们将它们映射到我们的区间 $ [0, p_{\\max}] $ 上，以获得节点 $ p_i $ 和权重 $ w_i $：\n$$\np_i = \\frac{p_{\\max}}{2}(1 + x_i'), \\quad w_i = w_i' \\frac{p_{\\max}}{2}\n$$\n然后，积分方程近似为一个矩阵方程：\n$$\n\\phi(p_i) \\;\\approx\\; C \\sum_{j=1}^N w_j\\, p_j^2\\, K_\\Lambda(p_i,p_j)\\, \\phi(p_j)\n$$\n这是一个齐次矩阵特征值问题 $ \\boldsymbol{\\phi} = C M_\\Lambda \\boldsymbol{\\phi} $，其中 $ \\boldsymbol{\\phi} $ 是一个分量为 $ \\phi_i = \\phi(p_i) $ 的向量，$ M_\\Lambda $ 是一个 $ N \\times N $ 矩阵，其元素为：\n$$\n(M_\\Lambda)_{ij} \\;=\\; w_j\\, p_j^2\\, K_\\Lambda(p_i, p_j) \\;=\\; w_j\\, p_j^2\\, \\frac{r_\\Lambda(p_i)\\, g(p_i)\\; r_\\Lambda(p_j)\\, g(p_j)}{p_i^2 + p_j^2 + \\kappa^2}\n$$\n如果 $ C $ 是 $ M_\\Lambda $ 的某个特征值的倒数，则存在非平凡解。具有物理意义的束缚态对应于与 $ M_\\Lambda $ 的最大正特征值 $ \\lambda_{\\max} $ 相关联的特征向量。因此，我们必须有 $ C = 1 / \\lambda_{\\max} $。\n\n问题指定了一个校准程序。我们首先使用一个参考案例来确定耦合常数 $ C_{\\mathrm{ref}} $：一个 $ \\Lambda_{\\mathrm{ref}} = 15 $ 的高斯调节子。我们构建矩阵 $ M_{\\Lambda_{\\mathrm{ref}}} $，找到其最大特征值 $ \\lambda_{\\mathrm{ref}} $，并设置 $ C_{\\mathrm{ref}} = 1/\\lambda_{\\mathrm{ref}} $。然后，对于所有其他调节子选择，该耦合常数保持不变。此过程确保所有模型都校准到相同的低能物理，从而可以公平地比较它们的高动量（紫外）行为。\n\n为了找到最大特征值及其对应的特征向量，我们采用幂迭代法（power iteration method）。从一个随机向量 $ \\boldsymbol{v}^{(0)} $ 开始，我们进行迭代：\n$$\n\\boldsymbol{v}^{(k+1)} = \\frac{A \\boldsymbol{v}^{(k)}}{||A \\boldsymbol{v}^{(k)}||}\n$$\n其中 $ A $ 是我们感兴趣的矩阵（校准时为 $ M_\\Lambda $，其他情况下为 $ C_{\\mathrm{ref}}M_\\Lambda $），范数可以是任何向量范数。特征向量序列 $ \\boldsymbol{v}^{(k)} $ 收敛于主特征向量，而特征值可以从缩放因子中估计。我们迭代直到特征值的相对变化低于 $ 10^{-10} $ 的容差。\n\n对于测试套件中的每个调节子，我们执行以下步骤：\n1.  构建矩阵 $ M_\\Lambda $。\n2.  使用幂迭代法找到矩阵 $ C_{\\mathrm{ref}} M_\\Lambda $ 的主右特征向量 $ \\boldsymbol{\\phi} $。\n3.  得到的特征向量 $ \\boldsymbol{\\phi} $ 必须根据S波概率测度进行归一化。归一化条件是总概率为1：\n    $$\n    \\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi(p_i)|^2 = 1\n    $$\n    设 $ \\boldsymbol{\\phi}_{\\mathrm{unnorm}} $ 为从幂迭代法得到的特征向量。归一化后的特征向量为 $ \\boldsymbol{\\phi} = \\boldsymbol{\\phi}_{\\mathrm{unnorm}} / \\mathcal{N} $，其中归一化常数为 $ \\mathcal{N} = \\sqrt{\\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi_{\\mathrm{unnorm}}(p_i)|^2} $。\n4.  然后，旁观者动量分布由 $ n(p_i) = |\\phi(p_i)|^2 $ 给出。\n\n最后，我们量化每个计算出的分布 $ n(p) $ 与参考分布 $ n_{\\mathrm{ref}}(p) $（使用参考调节子获得）之间的偏差。误差度量是在尾部区域（定义为动量 $ p \\in [p_{\\mathrm{tail,min}}, p_{\\mathrm{tail,max}}] $，其中 $ p_{\\mathrm{tail,min}} = 8 $，$ p_{\\mathrm{tail,max}} = 15 $）的相对加权 $ L^2 $ 范数差：\n$$\n\\varepsilon_{\\mathrm{tail}} \\;=\\; \\frac{\\left(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, \\left[n(p_i) - n_{\\mathrm{ref}}(p_i)\\right]^2\\right)^{1/2}}{\\left(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, n_{\\mathrm{ref}}(p_i)^2\\right)^{1/2}}\n$$\n其中 $ \\mathcal{T} $ 是使得 $ p_i \\in [8, 15] $ 的索引集合。该度量衡量了旁观者振幅高动量部分的调节子赝象。\n\n整个过程通过计算实现。首先，通过参考计算确定 $ C_{\\mathrm{ref}} $ 和 $ n_{\\mathrm{ref}}(p) $。然后，对于每个测试用例，使用这个固定的 $ C_{\\mathrm{ref}} $ 计算相应的 $ n(p) $，并计算误差 $ \\varepsilon_{\\mathrm{tail}} $。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the three-body problem as specified, calculating regulator artifacts.\n    \"\"\"\n    # --- Problem Parameters ---\n    N = 160\n    P_MAX = 20.0\n    BETA = 1.0\n    KAPPA = 1.0\n    \n    # --- Calibration Parameters ---\n    LAMBDA_REF = 15.0\n    REG_REF_TYPE = 'gauss'\n    \n    # --- Power Iteration Parameters ---\n    TOL = 1e-10\n    MAX_ITER = 2000\n    \n    # --- Tail Region Parameters ---\n    P_TAIL_MIN = 8.0\n    P_TAIL_MAX = 15.0\n\n    # --- Test Suite ---\n    test_cases = [\n        ('sharp', 3, 0),\n        ('sharp', 6, 0),\n        ('gauss', 3, 0),\n        ('exp', 3, 4),\n        ('exp', 6, 4),\n        ('gauss', 10, 0),\n    ]\n\n    # --- Numerical Setup: Gauss-Legendre Quadrature ---\n    # Scipy returns nodes x in [-1, 1] and weights w.\n    x_gl, w_gl = roots_legendre(N)\n    # Transform to interval [0, P_MAX]\n    p_nodes = P_MAX * (1.0 + x_gl) / 2.0\n    p_weights = P_MAX * w_gl / 2.0\n\n    # --- Model Functions ---\n    def form_factor_g(p, beta):\n        return 1.0 / (p**2 + beta**2)\n\n    def regulator_r(p, reg_type, lam, n=0):\n        if reg_type == 'sharp':\n            return np.where(p = lam, 1.0, 0.0)\n        elif reg_type == 'gauss':\n            return np.exp(-(p / lam)**2)\n        elif reg_type == 'exp':\n            if n  2:\n                raise ValueError(\"Order n must be >= 2 for exponential regulator.\")\n            return np.exp(-(p / lam)**n)\n        else:\n            raise ValueError(f\"Unknown regulator type: {reg_type}\")\n\n    # --- Power Iteration for Principal Eigenvalue/Eigenvector ---\n    def power_iteration(matrix):\n        \"\"\"Finds the largest eigenvalue and corresponding eigenvector of a matrix.\"\"\"\n        # Start with a random vector\n        vec = np.random.rand(matrix.shape[1])\n        vec /= np.linalg.norm(vec)\n        \n        lambda_val = 0.0\n        for _ in range(MAX_ITER):\n            # Matrix-vector product\n            mat_vec = matrix @ vec\n            \n            # Estimate eigenvalue\n            lambda_new = np.linalg.norm(mat_vec)\n            \n            # Normalize eigenvector\n            vec = mat_vec / lambda_new\n            \n            # Check for convergence\n            if abs(lambda_new - lambda_val) / lambda_new  TOL:\n                return lambda_new, vec\n            \n            lambda_val = lambda_new\n            \n        raise RuntimeError(\"Power iteration did not converge.\")\n\n    # --- Main Calculation Logic ---\n    def get_distribution(reg_type, lam, n, coupling_c):\n        \"\"\"\n        Constructs the matrix, solves the eigenvalue problem, and returns\n        the normalized momentum distribution. Also returns eigenvalue if C=1.\n        \"\"\"\n        # Evaluate functions at quadrature nodes\n        g_p = form_factor_g(p_nodes, BETA)\n        r_p = regulator_r(p_nodes, reg_type, lam, n)\n        \n        # Combined momentum-dependent part of the kernel\n        G_p = r_p * g_p\n        \n        # Construct the non-symmetric matrix M\n        # Using broadcasting for efficiency\n        # p_i -> column vector, p_j -> row vector\n        p_i = p_nodes[:, np.newaxis]\n        p_j = p_nodes[np.newaxis, :]\n        G_i = G_p[:, np.newaxis]\n        G_j = G_p[np.newaxis, :]\n        w_j_qj2 = p_weights[np.newaxis, :] * p_j**2\n        \n        numerator = G_i * G_j\n        denominator = p_i**2 + p_j**2 + KAPPA**2\n        \n        M_lambda = (numerator / denominator) * w_j_qj2\n\n        # In calibration phase, we need lambda_ref for M_lambda (C=1)\n        if coupling_c == 1.0:\n            lambda_max, phi_unnorm = power_iteration(M_lambda)\n            return lambda_max, phi_unnorm\n        \n        # For test cases, solve eigenvalue problem for C_ref * M_lambda\n        full_matrix = coupling_c * M_lambda\n        _, phi_unnorm = power_iteration(full_matrix)\n        \n        # Normalize the eigenvector phi\n        # The eigenvector components are all positive -> abs() is not strictly needed\n        norm_sq = np.sum(p_weights * p_nodes**2 * phi_unnorm**2)\n        phi_norm = phi_unnorm / np.sqrt(norm_sq)\n        \n        # Calculate momentum distribution n(p) = |phi(p)|^2\n        n_p = phi_norm**2\n        return n_p\n\n    # --- Step 1: Calibration to find C_ref and n_ref ---\n    lambda_ref, _ = get_distribution(REG_REF_TYPE, LAMBDA_REF, 0, 1.0)\n    C_ref = 1.0 / lambda_ref\n    \n    n_ref = get_distribution(REG_REF_TYPE, LAMBDA_REF, 0, C_ref)\n    \n    # --- Step 2: Loop through test cases and compute errors ---\n    results = []\n    \n    # Identify indices for the tail region\n    tail_mask = (p_nodes >= P_TAIL_MIN)  (p_nodes = P_TAIL_MAX)\n    p_tail = p_nodes[tail_mask]\n    w_tail = p_weights[tail_mask]\n    n_ref_tail = n_ref[tail_mask]\n\n    for reg_type, lam, n in test_cases:\n        # Get the momentum distribution for the current test case\n        n_p = get_distribution(reg_type, lam, n, C_ref)\n        n_p_tail = n_p[tail_mask]\n\n        # Calculate the weighted L2 error in the tail\n        numerator_sq = np.sum(w_tail * p_tail**2 * (n_p_tail - n_ref_tail)**2)\n        denominator_sq = np.sum(w_tail * p_tail**2 * n_ref_tail**2)\n        \n        if denominator_sq == 0:\n            # Handle case of zero denominator, though unlikely here\n            error_tail = np.inf if numerator_sq > 0 else 0.0\n        else:\n            error_tail = np.sqrt(numerator_sq / denominator_sq)\n            \n        results.append(error_tail)\n\n    # --- Final Output ---\n    output_str = \",\".join([f\"{res:.6e}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现在，我们将运用所学技能解决核物理学中的一个基石问题：计算氚核的束缚能。这项综合性练习  要求你使用一个实际的可分离势来求解束缚态的动量空间法捷耶夫方程。你将实现整套计算流程，包括寻找使核的最高本征值为1的能量，并确定束缚能相对于所包含分波数的收敛性。",
            "id": "3598966",
            "problem": "您需要设计并实现一个完整的计算研究，以在受控且科学可靠的近似范围内，确定将氚核三体束缚态能量（结合能）收敛到 $10$ 千电子伏特（$10$ keV）以内所需的分波最小数量。该研究必须基于三体问题的 Faddeev 形式体系，并使用由分波投影的秩-1 可分离势表示的现实核子-核子（$NN$）相互作用。您的程序必须生成单一行，其中包含一个整数列表，每个整数是在给定测试案例下，为达到指定的 $10$ keV 收敛精度所需的最小 $L_{\\max}$（分波展开中包含的最大轨道角动量量子数）。程序必须在没有任何外部输入的情况下执行所有计算，并且必须使用下文指定的适用于核物理的国际单位制（SI）导出单位。\n\n推导和计算中使用的基本依据和模型假设：\n- 带有对偶相互作用的非相对论性三体薛定谔方程通过 Faddeev 方程分解为对应于每个相互作用对的分量。全同费米子的 Faddeev 束缚态方程被重铸在动量空间中，并投影到轨道角动量分波 $L$上。\n- 每个分波 $L$ 中的核子-核子相互作用由一个秩-1 可分离形式建模\n$$V_L(k, k') = -\\lambda_L\\, g_L(k)\\, g_L(k'),$$\n其中 $k$ 和 $k'$ 是相互作用对中的相对动量，$\\lambda_L$ 是一个强度参数，$g_L(k)$ 是一个形状因子，它编码了短程物理和正确的阈值行为。在可分离模型中，一个广泛使用的类似现实势的形状因子选择是\n$$g_L(k) = \\frac{k^L}{\\left(k^2 + \\beta_L^2\\right)^{\\frac{L+1}{2}}},$$\n其中力程参数 $\\beta_L0$ 随 $L$ 温和增加，以模拟较高分波中减小的力程。这个选择再现了正确的离心阈值行为，并提供了与现实势一致的紫外正规化。\n- Faddeev 核中的自由三体格林函数在对-旁观者雅可比动量上进行角平均，以获得一个数值上易于处理的核，该核保留了正确的能量和动量标度。设旁观者动量为 $p$，对动量为 $q$，三体结合能为 $B0$（定义为三体能量 $E=-B$），角平均传播子模型为\n$$G_0(B; p, q) = \\frac{1}{B + \\alpha \\left(p^2 + q^2 + \\frac{p q}{2}\\right)},$$\n其中 $\\alpha = \\frac{(\\hbar c)^2}{m_N}$，$m_N$ 是核子质量。这种角平均是一种标准的数值近似，它产生一个正核，并捕捉了对 $p$、$q$ 和 $B$ 的主要依赖关系。\n- 分波基下的 Faddeev 齐次积分方程使用高斯求积在 $q \\in [0, q_{\\max}]$ 上进行离散化，并使用正确的积分测度 $q^2 \\, dq$。离散化产生一个块矩阵核，耦合了所包含的分波 $L \\in \\{0,2,4,\\dots,L_{\\max}\\}$（只有偶数 $L$ 对正宇称氚核基态有贡献）。分波之间的耦合源于 Faddeev 排列中的角动量重耦合以及现实的张量力诱导的混合；它由一个有效的对称强度矩阵 $\\lambda_{L L'}$ 参数化，该矩阵在对角线上简化为 $\\lambda_L$，并且根据物理混合模式，当 $L \\neq L'$ 时被抑制。\n- 由此产生的离散化齐次方程具有形式结构\n$$\\mathbf{f} = \\mathbf{K}(B; L_{\\max})\\, \\mathbf{f},$$\n其中 $\\mathbf{K}(B; L_{\\max})$ 是依赖于 $B$ 和所包含的直至 $L_{\\max}$ 的分波集合的块核矩阵。当谱半径（最大特征值）$\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)$ 等于 $1$ 时，存在束缚态。结合能 $B$ 通过求解唯一的 $B0$ 使得 $\\rho=1$ 来得到；随着 $B$ 的增加，核的各项单调减小，使得 $\\rho$ 成为 $B$ 的严格递减函数，因此适合使用二分法。\n\n算法要求：\n- 使用 $[0, q_{\\max}]$ 上的高斯求积节点 $\\{q_j\\}$ 和权重 $\\{w_j\\}$ 对动量进行离散化。在积分中使用测度 $q_j^2 w_j$，从而产生核的黎曼和表示。对应于分波 $L$ 和 $L'$ 之间耦合的核块是\n$$K^{(L,L')}_{i j}(B) = 2\\, \\lambda_{L L'}\\, g_L(p_i)\\, g_{L'}(q_j)\\, G_0(B; p_i, q_j)\\, q_j^2\\, w_j,$$\n因子 $2$ 解释了三个全同费米子的 Faddeev 分解中的两个非平凡排列。\n- 通过将所有 $K^{(L,L')}(B)$ 块组装成一个单一矩阵，作用于每个所包含分波的离散化振幅的堆叠向量，来构建完整的核 $\\mathbf{K}(B; L_{\\max})$。通过幂迭代法计算谱半径 $\\rho$，该方法对于满足 Perron-Frobenius 条件的正矩阵是稳健的。\n- 通过区间限定与二分法找到 $B(L_{\\max})$：确定 $B$ 使得 $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)=1$，绝对容差对应于 $10$ keV（$0.01$ MeV）。能量必须以兆电子伏特（MeV）表示。\n- 定义参考能量 $B_{\\mathrm{ref}}$ 为 $B(L_{\\mathrm{ref}})$，其中 $L_{\\mathrm{ref}}=8$（即分波 $L\\in\\{0,2,4,6,8\\}$）。对于每个测试案例，确定最小的偶数 $L_{\\max}\\in\\{0,2,4,6,8\\}$，使得 $\\left|B(L_{\\max}) - B_{\\mathrm{ref}}\\right|  0.01$ MeV。\n\n物理常数和单位：\n- 使用 $\\hbar c = 197.3269804$ MeV$\\cdot$fm 和 $m_N = 939.0$ MeV$/c^2$。\n- 动量 $p$ 和 $q$ 的单位是逆费米（fm$^{-1}$）。能量的单位是兆电子伏特（MeV）。动能标度 $\\alpha = (\\hbar c)^2/m_N$ 的单位是 MeV$\\cdot$fm$^2$ 除以 fm$^2$，得到 MeV。\n\n测试套件规范：\n实现三个测试案例，以探究不同的物理区域和混合模式。对于每个案例，仅使用直至 $L_{\\max}$ 的偶数分波。\n\n对于所有案例：\n- 使用在 $[0, q_{\\max}]$ 上的 $N=80$ 个节点的高斯求积。\n- 选择 $q_{\\max} = 5.0$ fm$^{-1}$。\n- 定义 $\\beta_L = \\beta_0\\left(1 + r \\cdot \\frac{L}{2}\\right)$。\n- 定义对角耦合 $\\lambda_{L L} = \\lambda_0 / (1+L)^2$。\n- 定义当 $L \\neq L'$ 时的非对角混合为 $\\lambda_{L L'} = \\lambda_{\\mathrm{mix}} \\sqrt{\\lambda_{L L} \\lambda_{L' L'}} \\exp\\left(-\\frac{|L-L'|}{2}\\right)$。\n\n案例 A（基准“理想路径”）：\n- $\\beta_0 = 1.5$ fm$^{-1}$，$r = 0.4$，$\\lambda_0 = 600.0$，$\\lambda_{\\mathrm{mix}} = 0.30$。\n\n案例 B（强张量混合）：\n- $\\beta_0 = 1.2$ fm$^{-1}$，$r = 0.3$，$\\lambda_0 = 800.0$，$\\lambda_{\\mathrm{mix}} = 0.50$。\n\n案例 C（较短力程，更快的高-$L$ 压低）：\n- $\\beta_0 = 1.8$ fm$^{-1}$，$r = 0.5$，$\\lambda_0 = 450.0$，$\\lambda_{\\mathrm{mix}} = 0.20$。\n\n要求的输出格式：\n您的程序应生成单一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。每个结果必须是最小的偶数整数 $L_{\\max}\\in\\{0,2,4,6,8\\}$，对于相应的测试案例，其结合能相对于 $L_{\\mathrm{ref}}=8$ 的收敛精度在 $10$ keV 以内。\n\n角度单位没有出现在此问题中。不使用百分比。所有能量必须以 MeV 为单位处理和比较。最终输出列表的值是无单位的整数。",
            "solution": "我们从全同核子与对偶相互作用的非相对论性三体薛定谔方程开始。Faddeev 形式体系将三体波函数分解为满足耦合齐次积分方程的分量，每个相互作用对对应一个方程。在动量空间中并经过轨道角动量 $L$ 的分波投影后，束缚态齐次 Faddeev 方程涉及对旁观者动量 $p$ 和对动量 $q$ 的积分，其核函数包含自由格林函数和每个分波中的两体相互作用。\n\n为了获得一个保留了短程 $NN$ 力和分波混合基本物理的数值上易于处理的近似，我们在每个分波 $L$ 中采用秩-1 可分离势，\n$$V_L(k,k') = -\\lambda_L\\, g_L(k)\\, g_L(k'),$$\n其中 $\\lambda_L$ 是强度，$g_L(k)$ 是一个具有正确阈值行为和紫外衰减的形状因子。形式\n$$g_L(k) = \\frac{k^L}{\\left(k^2 + \\beta_L^2\\right)^{\\frac{L+1}{2}}}$$\n被广泛使用，并确保势是短程的，有效力程参数为 $\\beta_L$。多极阈值因子 $k^L$ 在 $k\\to 0$ 附近强制执行离心势垒。当为了计算便利而将现实相互作用简化为低秩近似时，这种可分离表示是常见的。\n\n自由三体格林函数取决于总的三体能量和雅可比动量。对于一个 $E=-B$ 且 $B0$ 的束缚态，我们采用一个角平均表示\n$$G_0(B; p, q) = \\frac{1}{B + \\alpha \\left(p^2 + q^2 + \\frac{p q}{2}\\right)}, \\quad \\alpha = \\frac{(\\hbar c)^2}{m_N},$$\n它捕捉了对 $p$、$q$ 和结合能 $B$ 的主要依赖关系，同时使得核的块可分离数值构建成为可能。角平均是一种标准的近似方法，它能产生一个正核，并遵循谱半径随 $B$ 增加而单调衰减的特性。\n\n将 Faddeev 方程投影到偶数分波集合 $L\\in\\{0,2,4,\\dots,L_{\\max}\\}$（正宇称氚核基态）上，并使用高斯求积节点 $\\{q_j\\}$ 和权重 $\\{w_j\\}$ 对对动量积分 $\\int_0^{q_{\\max}} dq\\, q^2$ 进行离散化，我们得到齐次线性系统\n$$f_L(p_i) = \\sum_{L'} \\sum_{j} K^{(L,L')}_{i j}(B)\\, f_{L'}(q_j),$$\n其块核为\n$$K^{(L,L')}_{i j}(B) = 2\\, \\lambda_{L L'}\\, g_L(p_i)\\, g_{L'}(q_j)\\, G_0(B; p_i, q_j)\\, q_j^2\\, w_j.$$\n因子 $2$ 解释了相互作用对的两个非平凡 Faddeev 排列。对称耦合系数 $\\lambda_{L L'}$ 包含了分波之间的现实混合，主要由张量力诱导的 $S$–$D$ 混合主导，并且对于大的 $|L-L'|$ 被抑制。一个合理的、物理上合理的选择是\n$$\\lambda_{L L} = \\frac{\\lambda_0}{(1+L)^2}, \\quad \\lambda_{L L'} = \\lambda_{\\mathrm{mix}} \\sqrt{\\lambda_{L L}\\, \\lambda_{L' L'}} \\exp\\left(-\\frac{|L-L'|}{2}\\right)\\quad (L\\neq L'),$$\n这确保了较高的分波逐渐变弱，非对角耦合随 $|L-L'|$ 衰减，同时保持了对称性和正性。\n\n将离散化振幅 $f_L(p_i)$ 堆叠成单个向量 $\\mathbf{f}$，并将所有块 $K^{(L,L')}(B)$ 组装起来，得到全局核矩阵 $\\mathbf{K}(B; L_{\\max})$。齐次方程变为\n$$\\mathbf{f} = \\mathbf{K}(B; L_{\\max})\\, \\mathbf{f}.$$\n根据 Perron–Frobenius 定理（对于正矩阵），当最大特征值（谱半径）满足 $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)=1$ 时，存在非平凡解。由于所有核项都随 $B$ 的增加而单调减小（$G_0$ 中的分母随 $B$ 增长），谱半径是 $B$ 的严格递减函数，这使得能够稳健地使用二分法找到解 $\\rho=1$ 的唯一结合能 $B$，达到任何期望的精度。我们通过幂迭代法计算 $\\rho$，对于正核，该方法收敛迅速。\n\n数值设置：\n- 选择 $q_{\\max}=5.0$ fm$^{-1}$，$N=80$ 个在 $[0,q_{\\max}]$ 上的高斯节点，以及通过权重 $q_j^2 w_j$ 编码的测度 $q^2\\, dq$。\n- 使用相同的求积节点上的 $p$ 来构造核的行 $p_i$。这种对称性简化了 $\\mathbf{K}$ 的组装。\n- 采用 $\\beta_L = \\beta_0\\left(1 + r \\cdot \\frac{L}{2}\\right)$ 来捕捉较高分波中相互作用力程的逐渐减小。\n\n结合能搜索：\n- 对于固定的 $L_{\\max}$，通过扫描 $B\\in[0.1, B_{\\mathrm{max}}]$ MeV 来限定 $\\rho(B)-1=0$ 的根，直到 $\\rho(B_{\\mathrm{low}})1$ 和 $\\rho(B_{\\mathrm{high}})1$；取足够大的 $B_{\\mathrm{max}}$（例如 $500$ MeV）以保证谱半径降至 $1$ 以下。\n- 使用二分法找到 $B(L_{\\max})$，绝对容差为 $10^{-2}$ MeV（对应于 $10$ keV）。\n- 定义 $B_{\\mathrm{ref}} = B(8)$ 为包含直至 $L_{\\mathrm{ref}}=8$ 分波的能量。\n- 确定最小的偶数 $L_{\\max}\\in\\{0,2,4,6,8\\}$，使得 $\\left|B(L_{\\max}) - B_{\\mathrm{ref}}\\right|  0.01$ MeV。\n\n测试套件和预期行为：\n- 案例 A 代表一个典型场景，具有中等张量混合和基准力程，提供了一条“理想路径”，其中用少量分波即可实现收敛。\n- 案例 B 增加了张量混合，由于更强的非对角耦合，可能需要 $L_{\\max} \\ge 4$ 或 $6$ 才能达到 $10$ keV 的收敛。\n- 案例 C 增加了较高 $L$ 的力程参数，更强烈地抑制了它们的贡献，并倾向于用更少的分波收敛。\n\n最终程序遵循此推导，构建核，通过幂迭代计算谱半径，为每个 $L_{\\max}$ 找到结合能，与 $B_{\\mathrm{ref}}$ 比较，并输出包含三个案例的最小 $L_{\\max}$ 值列表的单行。能量始终以 MeV 为单位，动量以 fm$^{-1}$ 为单位，动能标度由 $\\alpha = (\\hbar c)^2/m_N$ 处理。使用可分离势和角平均传播子与经过充分检验的计算核物理实践是一致的，这些实践用于探索关于分波截断的收敛性。",
            "answer": "```python\nimport numpy as np\n\n# Constants for units: energies in MeV, momenta in fm^-1.\nHBARC = 197.3269804  # MeV*fm\nM_N = 939.0  # MeV/c^2\nALPHA = (HBARC**2) / M_N  # MeV * fm^2 / fm^2 = MeV\n\ndef gauss_legendre_quadrature(n, a, b):\n    # Returns nodes x and weights w for Gauss-Legendre on [a,b]\n    x, w = np.polynomial.legendre.leggauss(n)\n    # Affine transform from [-1,1] to [a,b]\n    t = 0.5 * (x + 1.0)\n    nodes = a + (b - a) * t\n    weights = 0.5 * (b - a) * w\n    return nodes, weights\n\ndef form_factor(L, k, beta_L):\n    # g_L(k) = k^L / (k^2 + beta_L^2)^{(L+1)/2}\n    # Handle k=0 for L>0: k^L is zero-safe\n    denom = (k**2 + beta_L**2)**((L + 1) / 2.0)\n    numer = (k**L)\n    return numer / denom\n\ndef coupling_matrix_entry(L, Lp, lambda0, lambda_mix):\n    # Diagonal: lambda_LL = lambda0 / (1+L)^2\n    # Off-diag: lambda_LL' = lambda_mix * sqrt(lambda_LL * lambda_L'L') * exp(-|L-L'|/2)\n    lam_LL = lambda0 / ((1 + L)**2)\n    lam_LpLp = lambda0 / ((1 + Lp)**2)\n    if L == Lp:\n        return lam_LL\n    else:\n        return lambda_mix * np.sqrt(lam_LL * lam_LpLp) * np.exp(-abs(L - Lp) / 2.0)\n\ndef build_kernel(B, L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix):\n    # Build the full kernel matrix K(B; Lmax)\n    # p_nodes and w_nodes are 1D arrays of length N over [0, qmax]\n    # Integration measure: q^2 dq -> encoded via weights w_nodes and q_nodes^2\n    q_nodes = p_nodes\n    q_weights = w_nodes\n    N = p_nodes.shape[0]\n    nL = len(L_vals)\n    dim = N * nL\n    K = np.zeros((dim, dim), dtype=np.float64)\n\n    # Precompute g_L(p_i) and g_L(q_j) and betas for each L\n    g_p = {}\n    g_q = {}\n    beta_L_map = {}\n    for L in L_vals:\n        beta_L = beta0 * (1.0 + r_growth * (L / 2.0))\n        beta_L_map[L] = beta_L\n        g_p[L] = form_factor(L, p_nodes, beta_L)\n        g_q[L] = form_factor(L, q_nodes, beta_L)\n\n    # Assemble blocks\n    # Index mapping: block for L index a (0..nL-1), row i (0..N-1) maps to row idx = a*N + i\n    # Similarly for columns: L' index b, col j -> col idx = b*N + j\n    # K^{(L,L')}_{i j} = 2 * lambda_{L,L'} * g_L(p_i) * g_{L'}(q_j) * G0(B; p_i, q_j) * q_j^2 * w_j\n    # G0(B;p,q) = 1 / (B + ALPHA * (p^2 + q^2 + 0.5*p*q))\n    # We'll vectorize over j for each i to fill rows efficiently.\n    for a, L in enumerate(L_vals):\n        gp = g_p[L]  # length N\n        for b, Lp in enumerate(L_vals):\n            lam = coupling_matrix_entry(L, Lp, lambda0, lambda_mix)\n            gq = g_q[Lp]  # length N\n            # Precompute denominator contributions that depend on p_i and q_j\n            # We'll broadcast: for each i, denom = B + ALPHA * (p_i^2 + q^2 + 0.5*p_i*q)\n            for i in range(N):\n                p_i = p_nodes[i]\n                denom = B + ALPHA * (p_i**2 + q_nodes**2 + 0.5 * p_i * q_nodes)\n                G0 = 1.0 / denom\n                row_idx = a * N + i\n                # Column block indices for Lp span b*N .. b*N + N-1\n                cols_start = b * N\n                # Contribution vector to this row from block (L,Lp)\n                contrib = 2.0 * lam * gp[i] * gq * G0 * (q_nodes**2) * q_weights\n                K[row_idx, cols_start:cols_start + N] += contrib\n\n    return K\n\ndef spectral_radius_power_iteration(K, max_iter=200, tol=1e-10):\n    # Power iteration for largest eigenvalue of a positive matrix K\n    n = K.shape[0]\n    v = np.ones(n, dtype=np.float64)\n    v /= np.linalg.norm(v)\n    lambda_old = 0.0\n    for _ in range(max_iter):\n        w = K @ v\n        norm_w = np.linalg.norm(w)\n        if norm_w == 0.0:\n            return 0.0\n        v = w / norm_w\n        # Rayleigh quotient\n        Kv = K @ v\n        lam = float(np.dot(v, Kv))\n        if abs(lam - lambda_old)  tol * max(1.0, abs(lam)):\n            return lam\n        lambda_old = lam\n    return lambda_old\n\ndef find_binding_energy(L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix,\n                        B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=10.0):\n    # Find B s.t. spectral radius rho(K(B)) = 1 within tolerance corresponding to 10 keV -> 0.01 MeV\n    # Bracketing: ensure rho(B_low) > 1, rho(B_high)  1\n    # If needed, adjust B_high upward.\n    # Return B in MeV\n    # Compute kernel and rho at initial bounds\n    def rho_at_B(B):\n        K = build_kernel(B, L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix)\n        return spectral_radius_power_iteration(K)\n\n    B_low = B_low_init\n    rho_low = rho_at_B(B_low)\n    # Ensure lower bracket is above 1; if not, try smaller B (closer to threshold)\n    if rho_low  1.0:\n        # Try reducing B_low\n        for factor in [0.05, 0.02, 0.01]:\n            B_low_candidate = B_low * factor\n            rho_candidate = rho_at_B(B_low_candidate)\n            if rho_candidate > 1.0:\n                B_low = B_low_candidate\n                rho_low = rho_candidate\n                break\n        else:\n            # If still not bracketed, return NaN to signal no bound state\n            return np.nan\n\n    B_high = B_high_init\n    rho_high = rho_at_B(B_high)\n    # Increase B_high until rho_high  1 or reach B_max_scan\n    while rho_high >= 1.0 and B_high  B_max_scan:\n        B_high *= 1.5\n        rho_high = rho_at_B(B_high)\n    if rho_high >= 1.0:\n        return np.nan\n\n    # Bisection\n    tol_MeV = tol_keV / 1000.0  # 10 keV in MeV\n    max_steps = 80\n    for _ in range(max_steps):\n        B_mid = 0.5 * (B_low + B_high)\n        rho_mid = rho_at_B(B_mid)\n        if abs(rho_mid - 1.0)  1e-6:\n            # close enough in rho, now ensure B within energy tol\n            if abs(B_high - B_low)  tol_MeV:\n                return B_mid\n        if rho_mid > 1.0:\n            B_low = B_mid\n        else:\n            B_high = B_mid\n        if abs(B_high - B_low)  tol_MeV:\n            return 0.5 * (B_low + B_high)\n    return 0.5 * (B_low + B_high)\n\ndef minimal_Lmax_for_convergence(params, L_ref=8, qmax=5.0, N=80, tol_keV=10.0):\n    # params: dict with beta0, r_growth, lambda0, lambda_mix\n    # Construct quadrature\n    p_nodes, w_nodes = gauss_legendre_quadrature(N, 0.0, qmax)\n    # Even L values up to L_ref\n    L_all = [L for L in range(0, L_ref + 1, 2)]\n    # Compute B_ref with L_ref\n    B_ref = find_binding_energy(L_all, p_nodes, w_nodes,\n                                params['beta0'], params['r_growth'],\n                                params['lambda0'], params['lambda_mix'],\n                                B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=tol_keV)\n    if np.isnan(B_ref):\n        # No bound state found; define convergence as requiring Lmax=0 (degenerate case)\n        return 0\n    # Now test progressively increasing Lmax\n    for Lmax in L_all:\n        L_vals = [L for L in range(0, Lmax + 1, 2)]\n        B_curr = find_binding_energy(L_vals, p_nodes, w_nodes,\n                                     params['beta0'], params['r_growth'],\n                                     params['lambda0'], params['lambda_mix'],\n                                     B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=tol_keV)\n        if np.isnan(B_curr):\n            # If this truncation loses the bound state, it certainly does not converge; continue\n            continue\n        if abs(B_curr - B_ref)  (tol_keV / 1000.0):\n            return Lmax\n    # If none satisfy, return L_ref\n    return L_ref\n\ndef solve():\n    # Define the test cases as specified\n    test_cases = [\n        # Case A: baseline \"happy path\"\n        {'beta0': 1.5, 'r_growth': 0.4, 'lambda0': 600.0, 'lambda_mix': 0.30},\n        # Case B: strong tensor mixing\n        {'beta0': 1.2, 'r_growth': 0.3, 'lambda0': 800.0, 'lambda_mix': 0.50},\n        # Case C: shorter range, faster high-L suppression\n        {'beta0': 1.8, 'r_growth': 0.5, 'lambda0': 450.0, 'lambda_mix': 0.20},\n    ]\n\n    results = []\n    for params in test_cases:\n        Lmax_min = minimal_Lmax_for_convergence(params, L_ref=8, qmax=5.0, N=80, tol_keV=10.0)\n        results.append(int(Lmax_min))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}