{
    "hands_on_practices": [
        {
            "introduction": "计算三体束缚态（如氚核 $^3$H）的性质是核物理学中的一个经典基准问题。法捷耶夫方程为解决这类量子三体问题提供了严谨的理论框架。本练习  将引导您亲手实践，通过在一个简化的现实模型中求解氚核的束缚能，来深入理解法捷耶夫方程的数值实现。通过研究计算结果随分波截断的变化，您将具体地体会到理论近似如何影响物理可观测量（如结合能）的计算精度。",
            "id": "3598966",
            "problem": "要求您设计并实现一个完整的计算研究，在一个受控且科学可靠的近似下，确定将氚核三体束缚态能量（结合能）收敛到 $10$ 千电子伏特 ($10$ keV) 以内所需的最小分波数。该研究必须基于用于三体问题的 Faddeev 形式体系，并使用一个由分波投影的秩-1 可分离势表示的现实核子-核子 ($NN$) 相互作用。您的程序必须生成一行包含整数列表的输出，其中每个整数是对于给定的测试用例，达到指定的 $10$ keV 收敛精度所需的最小 $L_{\\max}$（分波展开中包含的最大轨道角动量量子数）。程序必须在没有任何外部输入的情况下执行所有计算，并且必须使用下面指定的适用于核物理的国际单位制 (SI) 导出单位。\n\n在推导和计算中使用的基本基础和建模假设：\n- 具有对偶相互作用的非相对论性三体薛定谔方程通过 Faddeev 方程分解为对应于每个相互作用对的分量。相同费米子的 Faddeev 束缚态方程被重写在动量空间中，并投影到轨道角动量分波 $L$ 上。\n- 每个分波 $L$ 中的核子-核子相互作用由一个秩-1 可分离形式建模\n$$V_L(k, k') = -\\lambda_L\\, g_L(k)\\, g_L(k'),$$\n其中 $k$ 和 $k'$ 是相互作用对中的相对动量，$\\lambda_L$ 是一个强度参数，$g_L(k)$ 是一个形状因子，它编码了短程物理和正确的阈值行为。在可分离模型中，一个广泛使用的类似现实的形状因子选择是\n$$g_L(k) = \\frac{k^L}{\\left(k^2 + \\beta_L^2\\right)^{\\frac{L+1}{2}}},$$\n其中力程参数 $\\beta_L>0$ 随 $L$ 轻微增加，以模拟较高分波中力程的减小。这个选择再现了正确的离心阈值行为，并提供了与现实势相一致的紫外正则化。\n- Faddeev 核中的自由三体格林函数在对-旁观者 Jacobi 动量上进行角度平均，以获得一个数值上易于处理的核，同时保留正确的能量和动量标度。设旁观者动量为 $p$，对动量为 $q$，三体结合能为 $B>0$（定义为三体能量 $E=-B$），则角度平均的传播子模型为\n$$G_0(B; p, q) = \\frac{1}{B + \\alpha \\left(p^2 + q^2 + \\frac{p q}{2}\\right)},$$\n其中 $\\alpha = \\frac{(\\hbar c)^2}{m_N}$，$m_N$ 是核子质量。这种角度平均是一种标准的数值近似，它产生一个正核，并捕捉了对 $p$、$q$ 和 $B$ 的主导依赖性。\n- 分波基下的 Faddeev 齐次积分方程使用高斯求积在 $q \\in [0, q_{\\max}]$ 上进行离散化，并使用正确的积分测度 $q^2 \\, dq$。离散化产生一个块矩阵核，耦合了所包含的分波 $L \\in \\{0,2,4,\\dots,L_{\\max}\\}$（只有偶数 $L$ 对正宇称的氚核基态有贡献）。分波之间的耦合源于 Faddeev 置换中的角动量重耦合以及现实的张量力引起的混合；它由一个有效的对称强度矩阵 $\\lambda_{L L'}$ 参数化，该矩阵在对角线上简化为 $\\lambda_L$，并且根据物理混合模式，当 $L \\neq L'$ 时受到抑制。\n- 由此产生的离散化齐次方程具有形式结构\n$$\\mathbf{f} = \\mathbf{K}(B; L_{\\max})\\, \\mathbf{f},$$\n其中 $\\mathbf{K}(B; L_{\\max})$ 是依赖于 $B$ 和所包含的直到 $L_{\\max}$ 的分波集合的块核矩阵。当谱半径（最大特征值）$\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)$ 等于 $1$ 时，存在束缚态。结合能 $B$ 通过求解唯一的 $B>0$ 使得 $\\rho=1$ 来得到；随着 $B$ 的增加，核的各项单调减小，使得 $\\rho$ 成为 $B$ 的严格递减函数，因此适合使用二分法。\n\n算法要求：\n- 使用 $[0, q_{\\max}]$ 上的高斯求积节点 $\\{q_j\\}$ 和权重 $\\{w_j\\}$ 对动量进行离散化。在积分中使用测度 $q_j^2 w_j$，从而产生核的黎曼和表示。耦合分波 $L$ 和 $L'$ 之间的核块为\n$$K^{(L,L')}_{i j}(B) = 2\\, \\lambda_{L L'}\\, g_L(p_i)\\, g_{L'}(q_j)\\, G_0(B; p_i, q_j)\\, q_j^2\\, w_j,$$\n因子 $2$ 解释了三个相同费米子的 Faddeev 分解中的两个非平凡置换。\n- 通过将所有 $K^{(L,L')}(B)$ 块组装成一个单一矩阵来构造完整的核 $\\mathbf{K}(B; L_{\\max})$，该矩阵作用于每个包含分波的离散化振幅的堆叠向量。通过幂迭代法计算谱半径 $\\rho$，该方法对于满足 Perron-Frobenius 条件的正矩阵是稳健的。\n- 通过区间划定和二分法找到 $B(L_{\\max})$：确定 $B$ 使得 $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)=1$，绝对容差对应于 $10$ keV（$0.01$ MeV）。能量必须以兆电子伏特 (MeV) 表示。\n- 定义参考能量 $B_{\\mathrm{ref}}$ 为 $B(L_{\\mathrm{ref}})$，其中 $L_{\\mathrm{ref}}=8$（即分波 $L\\in\\{0,2,4,6,8\\}$）。对于每个测试用例，确定最小的偶数 $L_{\\max}\\in\\{0,2,4,6,8\\}$，使得 $|B(L_{\\max}) - B_{\\mathrm{ref}}| \\le 0.01$ MeV。\n\n物理常数和单位：\n- 使用 $\\hbar c = 197.3269804$ MeV$\\cdot$fm 和 $m_N = 939.0$ MeV$/c^2$。\n- 动量 $p$ 和 $q$ 的单位是反费米 (fm$^{-1}$)。能量单位是兆电子伏特 (MeV)。动能标度为 $\\alpha = (\\hbar c)^2/m_N$，单位是 MeV$\\cdot$fm$^2$ 除以 fm$^2$，得到 MeV。\n\n测试套件规范：\n实现三个测试用例，以探测不同的物理区域和混合模式。对于每个用例，仅使用直到 $L_{\\max}$ 的偶数分波。\n\n对于所有用例：\n- 使用在 $[0, q_{\\max}]$ 上的 $N=80$ 个节点的高斯求积。\n- 选择 $q_{\\max} = 5.0$ fm$^{-1}$。\n- 定义 $\\beta_L = \\beta_0\\left(1 + r \\cdot \\frac{L}{2}\\right)$。\n- 定义对角耦合 $\\lambda_{L L} = \\lambda_0 / (1+L)^2$。\n- 定义 $L \\neq L'$ 时的非对角混合为 $\\lambda_{L L'} = \\lambda_{\\mathrm{mix}} \\sqrt{\\lambda_{L L} \\lambda_{L' L'}} \\exp\\left(-\\frac{|L-L'|}{2}\\right)$。\n\n用例 A (基准“理想情况”)：\n- $\\beta_0 = 1.5$ fm$^{-1}$，$r = 0.4$，$\\lambda_0 = 600.0$，$\\lambda_{\\mathrm{mix}} = 0.30$。\n\n用例 B (强张量混合)：\n- $\\beta_0 = 1.2$ fm$^{-1}$，$r = 0.3$，$\\lambda_0 = 800.0$，$\\lambda_{\\mathrm{mix}} = 0.50$。\n\n用例 C (较短力程，更快的高-$L$ 抑制)：\n- $\\beta_0 = 1.8$ fm$^{-1}$，$r = 0.5$，$\\lambda_0 = 450.0$，$\\lambda_{\\mathrm{mix}} = 0.20$。\n\n要求的输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"）。每个结果必须是最小的偶数整数 $L_{\\max}\\in\\{0,2,4,6,8\\}$，对于相应的测试用例，其结合能相对于 $L_{\\mathrm{ref}}=8$ 的收敛精度在 $10$ keV 以内。\n\n角度单位未在此问题中出现。不使用百分比。所有能量必须以 MeV 为单位处理和比较。最终输出列表的值是无单位的整数。",
            "solution": "我们从相同核子具有对偶相互作用的非相对论性三体薛定谔方程开始。Faddeev 形式体系将三体波函数分解为满足耦合齐次积分方程的分量，每个分量对应一个相互作用对。在动量空间中，经过分波投影到轨道角动量 $L$ 后，束缚态齐次 Faddeev 方程涉及对旁观者动量 $p$ 和对动量 $q$ 的积分，其核包含自由格林函数和每个分波中的两体相互作用。\n\n为获得一个数值上易于处理且保留短程 $NN$ 力和分波混合基本物理的近似，我们在每个分波 $L$ 中采用秩-1 可分离势，\n$$V_L(k,k') = -\\lambda_L\\, g_L(k)\\, g_L(k'),$$\n其中 $\\lambda_L$ 是强度，$g_L(k)$ 是具有正确阈值行为和紫外截断的形状因子。形式\n$$g_L(k) = \\frac{k^L}{\\left(k^2 + \\beta_L^2\\right)^{\\frac{L+1}{2}}}$$\n被广泛使用，并确保势是短程的，有效力程参数为 $\\beta_L$。多极阈值因子 $k^L$ 在 $k\\to 0$ 附近强制实现离心势垒。当为计算便利而将现实相互作用简化为低秩近似时，这种可分离表示是常见的。\n\n自由三体格林函数取决于总三体能量和 Jacobi 动量。对于 $E=-B$ 且 $B>0$ 的束缚态，我们采用角度平均表示\n$$G_0(B; p, q) = \\frac{1}{B + \\alpha \\left(p^2 + q^2 + \\frac{p q}{2}\\right)}, \\quad \\alpha = \\frac{(\\hbar c)^2}{m_N},$$\n这捕捉了对 $p$、$q$ 和结合能 $B$ 的主导依赖性，同时使核的块可分离数值构造成为可能。角度平均是一种标准近似，它产生一个正核，并遵循谱半径随 $B$ 增加而单调衰减的特性。\n\n将 Faddeev 方程投影到偶数分波集合 $L\\in\\{0,2,4,\\dots,L_{\\max}\\}$（正宇称氚核基态），并使用高斯求积节点 $\\{q_j\\}$ 和权重 $\\{w_j\\}$ 对对动量积分 $\\int_0^{q_{\\max}} dq\\, q^2$ 进行离散化，我们得到齐次线性系统\n$$f_L(p_i) = \\sum_{L'} \\sum_{j} K^{(L,L')}_{i j}(B)\\, f_{L'}(q_j),$$\n其块核为\n$$K^{(L,L')}_{i j}(B) = 2\\, \\lambda_{L L'}\\, g_L(p_i)\\, g_{L'}(q_j)\\, G_0(B; p_i, q_j)\\, q_j^2\\, w_j.$$\n因子 $2$ 解释了相互作用对的两个非平凡 Faddeev 置换。对称耦合系数 $\\lambda_{L L'}$ 包含了分波之间的现实混合，主要由张量引起的 $S$–$D$ 混合主导，并且对于大的 $|L-L'|$ 会被抑制。一个合理的、物理上合理的选择是\n$$\\lambda_{L L} = \\frac{\\lambda_0}{(1+L)^2}, \\quad \\lambda_{L L'} = \\lambda_{\\mathrm{mix}} \\sqrt{\\lambda_{L L}\\, \\lambda_{L' L'}} \\exp\\left(-\\frac{|L-L'|}{2}\\right)\\quad (L\\neq L'),$$\n这确保了较高的分波逐渐减弱，非对角耦合随 $|L-L'|$ 衰减，同时保持对称性和正性。\n\n将离散振幅 $f_L(p_i)$ 堆叠成单个向量 $\\mathbf{f}$，并将所有块 $K^{(L,L')}(B)$ 组装起来，得到全局核矩阵 $\\mathbf{K}(B; L_{\\max})$。齐次方程变为\n$$\\mathbf{f} = \\mathbf{K}(B; L_{\\max})\\, \\mathbf{f}.$$\n根据 Perron–Frobenius 定理，对于正矩阵，当最大特征值（谱半径）满足 $\\rho\\big(\\mathbf{K}(B; L_{\\max})\\big)=1$ 时，存在非平凡解。由于所有核项都随 $B$ 的增加而单调减小（$G_0$ 中的分母随 $B$ 增大），谱半径是 $B$ 的严格递减函数，这使得能够稳健地使用二分法找到满足 $\\rho=1$ 的唯一结合能 $B$，达到任何期望的精度。我们通过幂迭代法计算 $\\rho$，对于正核，该方法收敛迅速。\n\n数值设置：\n- 选择 $q_{\\max}=5.0$ fm$^{-1}$，$N=80$ 个高斯节点在 $[0,q_{\\max}]$ 上，并通过权重 $q_j^2 w_j$ 编码测度 $q^2\\, dq$。\n- 使用相同的求积节点上的 $p$ 来构造核的行 $p_i$。这种对称性简化了 $\\mathbf{K}$ 的组装。\n- 采用 $\\beta_L = \\beta_0\\left(1 + r \\cdot \\frac{L}{2}\\right)$ 来捕捉较高分波中相互作用力程的逐渐减小。\n\n结合能搜索：\n- 对于固定的 $L_{\\max}$，通过扫描 $B\\in[0.1, B_{\\mathrm{max}}]$ MeV 来划定 $\\rho(B)-1=0$ 的根区间，直到 $\\rho(B_{\\mathrm{low}})>1$ 和 $\\rho(B_{\\mathrm{high}})1$；取足够大的 $B_{\\mathrm{max}}$（例如 $500$ MeV）以保证谱半径降至 $1$ 以下。\n- 使用二分法找到 $B(L_{\\max})$，绝对容差为 $10^{-2}$ MeV（对应于 $10$ keV）。\n- 定义 $B_{\\mathrm{ref}} = B(8)$ 为包含直到 $L_{\\mathrm{ref}}=8$ 的分波时的能量。\n- 确定最小的偶数 $L_{\\max}\\in\\{0,2,4,6,8\\}$，使得 $|B(L_{\\max}) - B_{\\mathrm{ref}}| \\le 0.01$ MeV。\n\n测试套件和预期行为：\n- 用例 A 代表一个典型场景，具有中等张量混合和基准力程，提供了一个“理想情况”，其中用少量分波即可实现收敛。\n- 用例 B 增加了张量混合，由于更强的非对角耦合，可能需要 $L_{\\max} \\ge 4$ 或 $6$ 才能达到 $10$ keV 的收敛精度。\n- 用例 C 增加了较高 $L$ 的力程参数，从而更强地抑制了它们的贡献，并倾向于用更少的分波收敛。\n\n最终的程序遵循此推导，构造核，通过幂迭代计算谱半径，为每个 $L_{\\max}$ 找到结合能，与 $B_{\\mathrm{ref}}$ 比较，并输出一行包含三个用例的最小 $L_{\\max}$ 值的列表。能量始终以 MeV 为单位，动量以 fm$^{-1}$ 为单位，动能标度由 $\\alpha = (\\hbar c)^2/m_N$ 处理。使用可分离势和角度平均传播子与经过充分检验的计算核物理实践是一致的，这些实践用于探索关于分波截断的收敛性。",
            "answer": "```python\nimport numpy as np\n\n# Constants for units: energies in MeV, momenta in fm^-1.\nHBARC = 197.3269804  # MeV*fm\nM_N = 939.0  # MeV/c^2\nALPHA = (HBARC**2) / M_N  # MeV * fm^2 / fm^2 = MeV\n\ndef gauss_legendre_quadrature(n, a, b):\n    # Returns nodes x and weights w for Gauss-Legendre on [a,b]\n    x, w = np.polynomial.legendre.leggauss(n)\n    # Affine transform from [-1,1] to [a,b]\n    t = 0.5 * (x + 1.0)\n    nodes = a + (b - a) * t\n    weights = 0.5 * (b - a) * w\n    return nodes, weights\n\ndef form_factor(L, k, beta_L):\n    # g_L(k) = k^L / (k^2 + beta_L^2)^{(L+1)/2}\n    # Handle k=0 for L>0: k^L is zero-safe\n    denom = (k**2 + beta_L**2)**((L + 1) / 2.0)\n    numer = (k**L)\n    return numer / denom\n\ndef coupling_matrix_entry(L, Lp, lambda0, lambda_mix):\n    # Diagonal: lambda_LL = lambda0 / (1+L)^2\n    # Off-diag: lambda_LL' = lambda_mix * sqrt(lambda_LL * lambda_L'L') * exp(-|L-L'|/2)\n    lam_LL = lambda0 / ((1 + L)**2)\n    lam_LpLp = lambda0 / ((1 + Lp)**2)\n    if L == Lp:\n        return lam_LL\n    else:\n        return lambda_mix * np.sqrt(lam_LL * lam_LpLp) * np.exp(-abs(L - Lp) / 2.0)\n\ndef build_kernel(B, L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix):\n    # Build the full kernel matrix K(B; Lmax)\n    # p_nodes and w_nodes are 1D arrays of length N over [0, qmax]\n    # Integration measure: q^2 dq -> encoded via weights w_nodes and q_nodes^2\n    q_nodes = p_nodes\n    q_weights = w_nodes\n    N = p_nodes.shape[0]\n    nL = len(L_vals)\n    dim = N * nL\n    K = np.zeros((dim, dim), dtype=np.float64)\n\n    # Precompute g_L(p_i) and g_L(q_j) and betas for each L\n    g_p = {}\n    g_q = {}\n    beta_L_map = {}\n    for L in L_vals:\n        beta_L = beta0 * (1.0 + r_growth * (L / 2.0))\n        beta_L_map[L] = beta_L\n        g_p[L] = form_factor(L, p_nodes, beta_L)\n        g_q[L] = form_factor(L, q_nodes, beta_L)\n\n    # Assemble blocks\n    # Index mapping: block for L index a (0..nL-1), row i (0..N-1) maps to row idx = a*N + i\n    # Similarly for columns: L' index b, col j -> col idx = b*N + j\n    # K^{(L,L')}_{i j} = 2 * lambda_{L,L'} * g_L(p_i) * g_{L'}(q_j) * G0(B; p_i, q_j) * q_j^2 * w_j\n    # G0(B;p,q) = 1 / (B + ALPHA * (p^2 + q^2 + 0.5*p*q))\n    # We'll vectorize over j for each i to fill rows efficiently.\n    for a, L in enumerate(L_vals):\n        gp = g_p[L]  # length N\n        for b, Lp in enumerate(L_vals):\n            lam = coupling_matrix_entry(L, Lp, lambda0, lambda_mix)\n            gq = g_q[Lp]  # length N\n            # Precompute denominator contributions that depend on p_i and q_j\n            # We'll broadcast: for each i, denom = B + ALPHA * (p_i^2 + q^2 + 0.5*p_i*q)\n            for i in range(N):\n                p_i = p_nodes[i]\n                denom = B + ALPHA * (p_i**2 + q_nodes**2 + 0.5 * p_i * q_nodes)\n                G0 = 1.0 / denom\n                row_idx = a * N + i\n                # Column block indices for Lp span b*N .. b*N + N-1\n                cols_start = b * N\n                # Contribution vector to this row from block (L,Lp)\n                contrib = 2.0 * lam * gp[i] * gq * G0 * (q_nodes**2) * q_weights\n                K[row_idx, cols_start:cols_start + N] += contrib\n\n    return K\n\ndef spectral_radius_power_iteration(K, max_iter=200, tol=1e-10):\n    # Power iteration for largest eigenvalue of a positive matrix K\n    n = K.shape[0]\n    v = np.ones(n, dtype=np.float64)\n    v /= np.linalg.norm(v)\n    lambda_old = 0.0\n    for _ in range(max_iter):\n        w = K @ v\n        norm_w = np.linalg.norm(w)\n        if norm_w == 0.0:\n            return 0.0\n        v = w / norm_w\n        # Rayleigh quotient\n        Kv = K @ v\n        lam = float(np.dot(v, Kv))\n        if abs(lam - lambda_old)  tol * max(1.0, abs(lam)):\n            return lam\n        lambda_old = lam\n    return lambda_old\n\ndef find_binding_energy(L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix,\n                        B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=10.0):\n    # Find B s.t. spectral radius rho(K(B)) = 1 within tolerance corresponding to 10 keV -> 0.01 MeV\n    # Bracketing: ensure rho(B_low) > 1, rho(B_high)  1\n    # If needed, adjust B_high upward.\n    # Return B in MeV\n    # Compute kernel and rho at initial bounds\n    def rho_at_B(B):\n        K = build_kernel(B, L_vals, p_nodes, w_nodes, beta0, r_growth, lambda0, lambda_mix)\n        return spectral_radius_power_iteration(K)\n\n    B_low = B_low_init\n    rho_low = rho_at_B(B_low)\n    # Ensure lower bracket is above 1; if not, try smaller B (closer to threshold)\n    if rho_low  1.0:\n        # Try reducing B_low\n        for factor in [0.05, 0.02, 0.01]:\n            B_low_candidate = B_low * factor\n            rho_candidate = rho_at_B(B_low_candidate)\n            if rho_candidate > 1.0:\n                B_low = B_low_candidate\n                rho_low = rho_candidate\n                break\n        else:\n            # If still not bracketed, return NaN to signal no bound state\n            return np.nan\n\n    B_high = B_high_init\n    rho_high = rho_at_B(B_high)\n    # Increase B_high until rho_high  1 or reach B_max_scan\n    while rho_high >= 1.0 and B_high  B_max_scan:\n        B_high *= 1.5\n        rho_high = rho_at_B(B_high)\n    if rho_high >= 1.0:\n        return np.nan\n\n    # Bisection\n    tol_MeV = tol_keV / 1000.0  # 10 keV in MeV\n    max_steps = 80\n    for _ in range(max_steps):\n        B_mid = 0.5 * (B_low + B_high)\n        rho_mid = rho_at_B(B_mid)\n        if abs(rho_mid - 1.0)  1e-6:\n            # close enough in rho, now ensure B within energy tol\n            if abs(B_high - B_low)  tol_MeV:\n                return B_mid\n        if rho_mid > 1.0:\n            B_low = B_mid\n        else:\n            B_high = B_mid\n        if abs(B_high - B_low)  tol_MeV:\n            return 0.5 * (B_low + B_high)\n    return 0.5 * (B_low + B_high)\n\ndef minimal_Lmax_for_convergence(params, L_ref=8, qmax=5.0, N=80, tol_keV=10.0):\n    # params: dict with beta0, r_growth, lambda0, lambda_mix\n    # Construct quadrature\n    p_nodes, w_nodes = gauss_legendre_quadrature(N, 0.0, qmax)\n    # Even L values up to L_ref\n    L_all = [L for L in range(0, L_ref + 1, 2)]\n    # Compute B_ref with L_ref\n    B_ref = find_binding_energy(L_all, p_nodes, w_nodes,\n                                params['beta0'], params['r_growth'],\n                                params['lambda0'], params['lambda_mix'],\n                                B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=tol_keV)\n    if np.isnan(B_ref):\n        # No bound state found; define convergence as requiring Lmax=0 (degenerate case)\n        return 0\n    # Now test progressively increasing Lmax\n    for Lmax in L_all:\n        L_vals = [L for L in range(0, Lmax + 1, 2)]\n        B_curr = find_binding_energy(L_vals, p_nodes, w_nodes,\n                                     params['beta0'], params['r_growth'],\n                                     params['lambda0'], params['lambda_mix'],\n                                     B_low_init=0.1, B_high_init=20.0, B_max_scan=500.0, tol_keV=tol_keV)\n        if np.isnan(B_curr):\n            # If this truncation loses the bound state, it certainly does not converge; continue\n            continue\n        if abs(B_curr - B_ref) = (tol_keV / 1000.0):\n            return Lmax\n    # If none satisfy, return L_ref\n    return L_ref\n\ndef solve():\n    # Define the test cases as specified\n    test_cases = [\n        # Case A: baseline \"happy path\"\n        {'beta0': 1.5, 'r_growth': 0.4, 'lambda0': 600.0, 'lambda_mix': 0.30},\n        # Case B: strong tensor mixing\n        {'beta0': 1.2, 'r_growth': 0.3, 'lambda0': 800.0, 'lambda_mix': 0.50},\n        # Case C: shorter range, faster high-L suppression\n        {'beta0': 1.8, 'r_growth': 0.5, 'lambda0': 450.0, 'lambda_mix': 0.20},\n    ]\n\n    results = []\n    for params in test_cases:\n        Lmax_min = minimal_Lmax_for_convergence(params, L_ref=8, qmax=5.0, N=80, tol_keV=10.0)\n        results.append(int(Lmax_min))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了束缚态问题，法捷耶夫形式主义（特别是其AGS形式）在描述三体散射过程中也至关重要。任何有效的散射理论都必须遵守概率守恒，这一基本原理在数学上体现为散射矩阵（S矩阵）的幺正性，并导出了著名的光学定理。本练习  将您的关注点从束缚态转向散射现象，要求您通过数值计算来验证光学定理。通过从给定的相移和非弹性参数出发计算弹性散射和破裂散射截面，您将亲手确认这一基本守恒定律，并加深对抽象理论原理如何转化为具体、可验证的物理可观测量之间关系的理解。",
            "id": "3599037",
            "problem": "考虑在质心系中，对于全同无自旋粒子，Faddeev-Alt-Grassberger-Sandhas (Faddeev-AGS) 形式体系下的三体问题中的量子散射。在固定的在壳入射雅可比动量大小 $k$（单位为 $\\mathrm{fm}^{-1}$）下，假设弹性道中的散射由 $s$ 波和低阶分波主导，并且有效的在壳道幺正性可以通过一组形式为 $S_\\ell = \\eta_\\ell \\exp(2 i \\delta_\\ell)$ 的复分波道散射矩阵元 $S_\\ell$ 来描述。其中 $\\delta_\\ell$ 是实数相移（单位为弧度），$\\eta_\\ell \\in [0,1]$ 是一个实数非弹性参数，概括了对于给定的分波 $\\ell$，从弹性道到破裂道的净概率损失。关于束流轴的球对称性意味着散射振幅仅依赖于极角 $\\theta$（通过 $\\mu \\equiv \\cos \\theta$）。\n\n使用以下基本依据：\n- 散射矩阵的量子力学幺正性，$S^\\dagger S = I$。\n- 光学定理，$\\sigma_{\\mathrm{tot}} = \\frac{4 \\pi}{k} \\,\\mathrm{Im}\\, f(0)$，其中 $f(\\theta)$ 是弹性散射振幅。\n- 弹性散射振幅的分波展开式，$f(\\theta) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right) P_\\ell(\\cos \\theta)$，其中 $P_\\ell(\\mu)$ 是勒让德多项式。\n- 积分弹性截面的定义为微分截面的角积分：$\\sigma_{\\mathrm{el}} = \\int \\mathrm{d}\\Omega\\, |f(\\theta)|^2 = 2 \\pi \\int_{-1}^{1} \\mathrm{d}\\mu\\, |f(\\mu)|^2$。\n- 每个分波的破裂（反应）截面，由道幺正性导出，与弹性道中的通量亏损成正比：对于每个 $\\ell$，亏损因子为 $1 - |S_\\ell|^2 = 1 - \\eta_\\ell^2$。\n\n你的任务是实现一个独立的程序，该程序能够：\n1. 根据指定的实数 $\\delta_\\ell$ 和 $\\eta_\\ell$，为 $\\ell = 0,1,\\dots,\\ell_{\\max}$ 构建复弹性道分波散射矩阵元 $S_\\ell$。\n2. 使用光学定理和前向方向 $\\theta = 0$ 计算总截面 $\\sigma_{\\mathrm{tot}}$。\n3. 使用具有指定节点数 $N_\\mu$ 的高斯-勒让德求积法，在 $\\mu \\in [-1,1]$ 上通过对 $|f(\\theta)|^2$ 进行数值积分来计算弹性截面 $\\sigma_{\\mathrm{el}}$。该积分为轴对称，因此只需要对 $\\mu$ 进行积分，方位角积分贡献一个因子 $2 \\pi$。\n4. 使用道幺正性中的通量亏损定义和给定的 $S_\\ell$ 值计算破裂截面 $\\sigma_{\\mathrm{break}}$。\n5. 对于每个测试用例，在指定的数值容差 $\\varepsilon$（单位为 $\\mathrm{fm}^2$）内验证 $|\\sigma_{\\mathrm{tot}} - (\\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}})| \\le \\varepsilon$ 是否成立，并以布尔值的形式报告结果。\n\n所有截面必须以 $\\mathrm{fm}^2$ 报告，角度以弧度报告。使用满足常规归一化条件 $P_\\ell(1) = 1$ 的勒让德多项式 $P_\\ell(\\mu)$。你的程序必须生成单行输出，其中包含所有测试用例的结果，格式为方括号内由逗号分隔的列表，例如，“[$\\mathrm{result}_1$, $\\mathrm{result}_2$, $\\mathrm{result}_3$]”。\n\n实现并评估以下测试套件，其设计旨在检验计算的不同方面：\n\n- 测试用例 A (一般“理想路径”)：\n  - 入射动量大小: $k = 1.0$ $\\mathrm{fm}^{-1}$。\n  - 分波: $\\ell = 0,1,2,3,4$。\n  - 相移: $(\\delta_0,\\delta_1,\\delta_2,\\delta_3,\\delta_4) = (0.3, -0.15, 0.2, -0.05, 0.08)$ 弧度。\n  - 非弹性参数: $(\\eta_0,\\eta_1,\\eta_2,\\eta_3,\\eta_4) = (0.9, 0.85, 0.7, 1.0, 0.6)$。\n  - 高斯-勒让德节点数: $N_\\mu = 200$。\n  - 容差: $\\varepsilon = 10^{-7}$ $\\mathrm{fm}^2$。\n\n- 测试用例 B (边界条件：纯弹性散射)：\n  - 入射动量大小: $k = 0.7$ $\\mathrm{fm}^{-1}$。\n  - 分波: $\\ell = 0,1,2,3$。\n  - 相移: $(\\delta_0,\\delta_1,\\delta_2,\\delta_3) = (0.25, -0.35, 0.1, -0.28)$ 弧度。\n  - 非弹性参数: $(\\eta_0,\\eta_1,\\eta_2,\\eta_3) = (1.0, 1.0, 1.0, 1.0)$。\n  - 高斯-勒让德节点数: $N_\\mu = 180$。\n  - 容差: $\\varepsilon = 10^{-8}$ $\\mathrm{fm}^2$。\n\n- 测试用例 C (强破裂分量)：\n  - 入射动量大小: $k = 1.8$ $\\mathrm{fm}^{-1}$。\n  - 分波: $\\ell = 0,1,2,3,4,5,6$。\n  - 相移: $(\\delta_0,\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5,\\delta_6) = (0.1, -0.2, 0.05, 0.3, -0.15, 0.22, -0.12)$ 弧度。\n  - 非弹性参数: $(\\eta_0,\\eta_1,\\eta_2,\\eta_3,\\eta_4,\\eta_5,\\eta_6) = (0.3, 0.2, 0.5, 0.4, 0.6, 0.7, 0.5)$。\n  - 高斯-勒让德节点数: $N_\\mu = 500$。\n  - 容差: $\\varepsilon = 10^{-7}$ $\\mathrm{fm}^2$。\n\n- 测试用例 D (考验数值求积分辨率的边缘情况)：\n  - 入射动量大小: $k = 1.2$ $\\mathrm{fm}^{-1}$。\n  - 分波: 从 $\\ell = 0$ 到 $\\ell = 20$ 的所有整数 $\\ell$。\n  - 相移：对于每个 $\\ell$，$\\delta_\\ell = 0.2 \\sin(0.4 \\ell)$ 弧度。\n  - 非弹性参数：对于每个 $\\ell$，$\\eta_\\ell = \\max\\{0, \\min\\{1, 0.9 - 0.03 \\ell\\}\\}$。\n  - 高斯-勒让德节点数: $N_\\mu = 12$。\n  - 容差: $\\varepsilon = 10^{-6}$ $\\mathrm{fm}^2$。\n\n你的程序必须实现以上要求，以规定的输出格式为每个测试用例生成布尔验证结果，并遵守执行环境的限制。不允许用户输入；程序必须能直接运行，并且只打印最终的结果行。",
            "solution": "验证的核心在于散射矩阵的幺正性和光学定理。在用于三体散射的 Faddeev-Alt-Grassberger-Sandhas 形式体系中，弹性道和破裂道通过跃迁算符耦合，这些算符在投影到在壳时，定义了一个跨通道的 $S$ 矩阵。对于给定的入射态和分波截断，弹性道对角元为 $S_\\ell = \\eta_\\ell \\exp(2 i \\delta_\\ell)$，其中 $0 \\le \\eta_\\ell \\le 1$ 参数化了净非弹性（流入破裂道和其他非弹性道的概率流），而 $\\delta_\\ell$ 是弹性相移。幺正性条件 $S^\\dagger S = I$ 强制要求所有末态道的概率总和为一。\n\n为了关联可观测量，我们使用弹性散射振幅的标准分波展开，\n$$\nf(\\theta) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right) P_\\ell(\\cos \\theta),\n$$\n其中 $P_\\ell(\\mu)$ 是勒让德多项式，$k$ 是入射雅可比动量大小。此展开适用于质心系中具有束流轴对称性的散射。\n\n根据光学定理，总截面为\n$$\n\\sigma_{\\mathrm{tot}} = \\frac{4 \\pi}{k} \\,\\mathrm{Im}\\, f(0).\n$$\n因为 $P_\\ell(1) = 1$，我们有\n$$\nf(0) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right).\n$$\n记 $S_\\ell = a_\\ell + i b_\\ell$，其中 $a_\\ell = \\mathrm{Re}\\, S_\\ell$，$b_\\ell = \\mathrm{Im}\\, S_\\ell$。那么\n$$\n\\mathrm{Im}\\left(\\frac{S_\\ell - 1}{2 i k}\\right) = \\frac{1 - \\mathrm{Re} \\, S_\\ell}{2 k},\n$$\n所以\n$$\n\\sigma_{\\mathrm{tot}} = \\frac{4 \\pi}{k} \\sum_{\\ell=0}^{\\ell_{\\max}} \\frac{(2 \\ell + 1)}{2 k}\\left(1 - \\mathrm{Re} \\, S_\\ell\\right) = \\frac{2 \\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\left(1 - \\mathrm{Re} \\, S_\\ell\\right).\n$$\n\n弹性截面是微分截面的角积分。在轴对称情况下，$f(\\theta)$ 仅通过 $\\mu = \\cos \\theta$ 依赖于 $\\theta$，我们有\n$$\n\\sigma_{\\mathrm{el}} = \\int \\mathrm{d}\\Omega\\, |f(\\theta)|^2 = 2 \\pi \\int_{-1}^{1} \\mathrm{d}\\mu\\, |f(\\mu)|^2.\n$$\n在数值上，我们通过在 $\\mu \\in [-1,1]$ 上使用高斯-勒让德求积法来近似该积分。具体来说，我们选择 $N_\\mu$ 个节点 $\\{\\mu_i\\}$ 和权重 $\\{w_i\\}$，使得\n$$\n\\sigma_{\\mathrm{el}} \\approx 2 \\pi \\sum_{i=1}^{N_\\mu} w_i \\, \\left| f(\\mu_i) \\right|^2.\n$$\n数值不确定度随 $N_\\mu$ 迅速减小，但对于大的 $\\ell_{\\max}$， $|f(\\mu)|^2$ 可能表现出高阶多项式行为，因此粗糙的 $N_\\mu$ 会引入显著的求积误差。\n\n对于破裂截面，我们使用限制在弹性道及其补集上的 $S$ 矩阵的幺正性。对于每个分波，\n$$\n1 - |S_\\ell|^2 = 1 - \\eta_\\ell^2,\n$$\n表示由于跃迁到破裂道（以及归入非弹性参数中的任何其他非弹性道）而产生的弹性通量亏损。从此亏损中提取的积分破裂截面为\n$$\n\\sigma_{\\mathrm{break}} = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - |S_\\ell|^2\\right) = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - \\eta_\\ell^2\\right).\n$$\n\n综合以上内容，利用勒让德多项式的正交性，可以解析地证明\n$$\n\\sigma_{\\mathrm{el}} = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left| S_\\ell - 1 \\right|^2,\n$$\n因为 $|S_\\ell - 1|^2 = 1 + |S_\\ell|^2 - 2 \\mathrm{Re}\\, S_\\ell$。于是\n$$\n\\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}} = \\frac{\\pi}{k^2} \\sum_{\\ell} (2 \\ell + 1) \\left( 1 + |S_\\ell|^2 - 2 \\mathrm{Re}\\, S_\\ell + 1 - |S_\\ell|^2 \\right)\n= \\frac{2 \\pi}{k^2} \\sum_{\\ell} (2 \\ell + 1) \\left(1 - \\mathrm{Re}\\, S_\\ell\\right) = \\sigma_{\\mathrm{tot}}.\n$$\n因此，恒等式 $\\sigma_{\\mathrm{tot}} = \\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}}$ 是由 $S^\\dagger S = I$ 推导出来的。我们的数值验证在实践中检验了这个恒等式，方法是通过光学定理和 $f(0)$ 计算 $\\sigma_{\\mathrm{tot}}$，通过对 $|f(\\mu)|^2$ 进行数值求积计算 $\\sigma_{\\mathrm{el}}$，并使用指定的 $S_\\ell$ 从 $1 - |S_\\ell|^2$ 计算 $\\sigma_{\\mathrm{break}}$。\n\n每个测试用例的算法步骤：\n1. 构建 $\\ell = 0,1,\\dots,\\ell_{\\max}$ 的 $(\\delta_\\ell, \\eta_\\ell)$ 列表，并计算 $S_\\ell = \\eta_\\ell \\exp(2 i \\delta_\\ell)$。\n2. 在高斯-勒让德节点 $\\mu_i$ 上使用以下公式计算 $f(\\mu)$\n$$\nf(\\mu_i) = \\frac{1}{2 i k} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1)\\,\\left(S_\\ell - 1\\right) P_\\ell(\\mu_i).\n$$\n3. 计算 $\\sigma_{\\mathrm{el}} \\approx 2 \\pi \\sum_i w_i |f(\\mu_i)|^2$。\n4. 计算 $\\sigma_{\\mathrm{tot}} = \\frac{2 \\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - \\mathrm{Re}\\, S_\\ell\\right)$。\n5. 计算 $\\sigma_{\\mathrm{break}} = \\frac{\\pi}{k^2} \\sum_{\\ell=0}^{\\ell_{\\max}} (2 \\ell + 1) \\left(1 - \\eta_\\ell^2\\right)$。\n6. 评估布尔值 $|\\sigma_{\\mathrm{tot}} - (\\sigma_{\\mathrm{el}} + \\sigma_{\\mathrm{break}})| \\le \\varepsilon$。\n\n单位：$k$ 必须以 $\\mathrm{fm}^{-1}$ 为单位，所有截面必须以 $\\mathrm{fm}^2$ 报告，角度以弧度报告。指定的测试套件涵盖了一般情况、纯弹性边界情况、强破裂情景，以及一个具有大 $\\ell_{\\max}$ 和粗糙求积分辨率的数值挑战性案例，这突出了数值积分误差的影响。最终输出为单行格式 \"[$\\mathrm{result}_\\mathrm{A}$,$\\mathrm{result}_\\mathrm{B}$,$\\mathrm{result}_\\mathrm{C}$,$\\mathrm{result}_\\mathrm{D}$]\"。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_polynomials(l_max, x):\n    \"\"\"\n    Evaluate Legendre polynomials P_l(x) for l = 0..l_max at points x.\n    Returns an array of shape (l_max+1, len(x)).\n    \"\"\"\n    # Use numpy.polynomial.legendre.Legendre basis for stable evaluation\n    P = np.empty((l_max + 1, x.size), dtype=float)\n    for l in range(l_max + 1):\n        poly = np.polynomial.legendre.Legendre.basis(l)\n        P[l, :] = poly(x)\n    return P\n\ndef scattering_amplitude(mu, k, S, P_vals):\n    \"\"\"\n    Compute f(mu) = (1/(2 i k)) sum_{l} (2l+1) (S_l - 1) P_l(mu)\n    mu: array of cos(theta) values\n    k: incident momentum magnitude [fm^-1]\n    S: array of complex S_l values, length L\n    P_vals: array of shape (L, len(mu)) with P_l(mu)\n    Returns complex array f(mu).\n    \"\"\"\n    l_indices = np.arange(S.size)\n    weights = (2 * l_indices + 1).astype(float)\n    # Broadcast weights and S-1 over mu samples\n    coeff = weights * (S - 1.0)\n    # Sum over l with P_l(mu)\n    sum_over_l = np.dot(coeff, P_vals)  # shape (len(mu),)\n    f_mu = sum_over_l / (2j * k)\n    return f_mu\n\ndef sigma_elastic(k, S, P_vals, nodes, weights):\n    \"\"\"\n    Compute elastic cross section via Gauss-Legendre quadrature:\n    sigma_el = 2 pi \\int_{-1}^1 dmu |f(mu)|^2\n    \"\"\"\n    f_mu = scattering_amplitude(nodes, k, S, P_vals)\n    integrand = np.abs(f_mu) ** 2\n    sigma_el = 2.0 * np.pi * np.sum(weights * integrand)\n    return sigma_el\n\ndef sigma_total_optical(k, S):\n    \"\"\"\n    Compute total cross section via optical theorem in partial waves:\n    sigma_tot = (2 pi / k^2) sum_l (2l+1) [1 - Re S_l]\n    \"\"\"\n    l_indices = np.arange(S.size)\n    weights = (2 * l_indices + 1).astype(float)\n    sigma_tot = (2.0 * np.pi / (k ** 2)) * np.sum(weights * (1.0 - np.real(S)))\n    return sigma_tot\n\ndef sigma_breakup(k, etas, l_max):\n    \"\"\"\n    Compute breakup cross section via flux deficit:\n    sigma_break = (pi / k^2) sum_l (2l+1) [1 - eta_l^2]\n    \"\"\"\n    l_indices = np.arange(l_max + 1)\n    weights = (2 * l_indices + 1).astype(float)\n    sigma_br = (np.pi / (k ** 2)) * np.sum(weights * (1.0 - etas ** 2))\n    return sigma_br\n\ndef build_S_from_params(deltas, etas):\n    \"\"\"\n    Construct S_l = eta_l * exp(2 i delta_l)\n    deltas and etas are arrays for l = 0..l_max\n    \"\"\"\n    deltas = np.asarray(deltas, dtype=float)\n    etas = np.asarray(etas, dtype=float)\n    S = etas * np.exp(2j * deltas)\n    return S\n\ndef gauss_legendre_nodes_weights(N):\n    \"\"\"\n    Return nodes and weights for Gauss-Legendre quadrature over [-1,1].\n    \"\"\"\n    nodes, weights = np.polynomial.legendre.leggauss(N)\n    return nodes, weights\n\ndef run_test_case(k, deltas, etas, Nmu, tol):\n    \"\"\"\n    Run a single test case:\n    - Build S_l\n    - Compute sigma_tot via optical theorem\n    - Compute sigma_el via quadrature of |f(mu)|^2\n    - Compute sigma_break from flux deficit\n    - Return boolean of |sigma_tot - (sigma_el + sigma_break)| = tol\n    \"\"\"\n    deltas = np.asarray(deltas, dtype=float)\n    etas = np.asarray(etas, dtype=float)\n    l_max = deltas.size - 1\n    # Build S_l\n    S = build_S_from_params(deltas, etas)\n    # Gauss-Legendre quadrature nodes and weights\n    nodes, weights = gauss_legendre_nodes_weights(Nmu)\n    # Precompute Legendre polynomials P_l(mu)\n    P_vals = legendre_polynomials(l_max, nodes)\n    # Compute cross sections\n    sigma_el = sigma_elastic(k, S, P_vals, nodes, weights)\n    sigma_tot = sigma_total_optical(k, S)\n    sigma_br = sigma_breakup(k, etas, l_max)\n    # Compare within tolerance\n    diff = abs(sigma_tot - (sigma_el + sigma_br))\n    return diff = tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Test Case A\n    k_A = 1.0\n    deltas_A = [0.3, -0.15, 0.2, -0.05, 0.08]\n    etas_A = [0.9, 0.85, 0.7, 1.0, 0.6]\n    Nmu_A = 200\n    tol_A = 1e-7\n\n    # Test Case B (pure elastic)\n    k_B = 0.7\n    deltas_B = [0.25, -0.35, 0.1, -0.28]\n    etas_B = [1.0, 1.0, 1.0, 1.0]\n    Nmu_B = 180\n    tol_B = 1e-8\n\n    # Test Case C (strong breakup)\n    k_C = 1.8\n    deltas_C = [0.1, -0.2, 0.05, 0.3, -0.15, 0.22, -0.12]\n    etas_C = [0.3, 0.2, 0.5, 0.4, 0.6, 0.7, 0.5]\n    Nmu_C = 500\n    tol_C = 1e-7\n\n    # Test Case D (numerically challenging)\n    k_D = 1.2\n    l_max_D = 20\n    deltas_D = [0.2 * np.sin(0.4 * l) for l in range(l_max_D + 1)]\n    etas_D = [max(0.0, min(1.0, 0.9 - 0.03 * l)) for l in range(l_max_D + 1)]\n    Nmu_D = 12\n    tol_D = 1e-6\n\n    test_cases = [\n        (k_A, deltas_A, etas_A, Nmu_A, tol_A),\n        (k_B, deltas_B, etas_B, Nmu_B, tol_B),\n        (k_C, deltas_C, etas_C, Nmu_C, tol_C),\n        (k_D, deltas_D, etas_D, Nmu_D, tol_D),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, deltas, etas, Nmu, tol = case\n        result = run_test_case(k, deltas, etas, Nmu, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在求解动量空间积分方程（如法捷耶夫方程）时，特别是当相互作用势在高动量下不会自然衰减时，必须引入紫外调节子（regulator）以保证积分收敛。原则上，调节子的选择是任意的，物理可观测量在经过恰当的重整化后不应依赖于此选择。本练习  深入探讨了计算量子物理中一个更为精细但至关重要的方面：调节子的作用。通过在一个简化的法捷耶夫模型中比较不同调节函数（如夏普截断、高斯函数）产生的结果，您将直接观察到非物理的调节子“赝象”（artifact）是如何在计算出的波函数中出现的，尤其是在其高动量部分。这一实践有助于您深刻理解有效理论的概念，并认识到在模型构建中理解和控制系统不确定性的重要性。",
            "id": "3598952",
            "problem": "您需要从第一性原理出发，实现一个计算比较。该比较针对的是一个通过 Faddeev 方法和短程对偶相互作用构建的三体束缚态问题中所出现的旁观者动量分布。工作应在无量纲、非相对论框架下进行，其中约化普朗克常数设为1，粒子质量被吸收到动量和能量尺度中，从而使所有量均为无量纲。三体束缚态的旁观者振幅被建模为关于旁观者动量变量的一个齐次一维积分方程的解。该模型反映了S波秩一可分离对偶相互作用，并引入了一个紫外调节子。您将比较不同的调节子选择，并量化旁观者动量分布在高动量尾部的调节子人为效应。\n\n使用的基本原理：\n- 对于具有S波相互作用的全同粒子，三体 Faddeev 方程在角向平均后，可简化为关于旁观者振幅的一维齐次积分方程。对于秩一可分离二体势，此方程简化为一个积分方程，其核是一个包含自由三体预解式和形因子的、正定且动量对称的函数。\n- S波的动量空间测度为 $ \\mathrm{d}^3 p = 4\\pi\\, p^2 \\mathrm{d}p $，由此产生的径向积分为 $ \\int_0^\\infty \\mathrm{d}p\\, p^2\\,(\\cdots) $ 的形式。\n- 通过将形因子乘以一个调节函数 $ r_\\Lambda(p) $ 来引入紫外正则化，该函数抑制了超过尺度 $ \\Lambda $ 的高动量。\n\n需要实现的模型规格：\n1. 使用旁观者振幅 $ \\phi(p) $ 的齐次积分方程，\n   $$\n   \\phi(p) \\;=\\; C \\int_0^{\\infty} \\mathrm{d}q\\, q^2\\, K_\\Lambda(p,q)\\, \\phi(q),\n   $$\n   其核为\n   $$\n   K_\\Lambda(p,q) \\;=\\; \\frac{r_\\Lambda(p)\\, g(p)\\; r_\\Lambda(q)\\, g(q)}{p^2 + q^2 + \\kappa^2}.\n   $$\n   此处 $ g(p) $ 是一个秩一形因子，$ \\kappa $ 是一个模拟自由三体传播子中出现的束缚动量的正常数。常数 $ C $ 代表有效核的总耦合强度。\n\n2. 使用 Yamaguchi 型形因子\n   $$\n   g(p) \\;=\\; \\frac{1}{p^2 + \\beta^2},\n   $$\n   其中 $ \\beta = 1 $，并设置 $ \\kappa = 1 $。\n\n3. 实现三种调节子选择：\n   - 锐截止：\n     $$\n     r_\\Lambda^{\\mathrm{sharp}}(p) \\;=\\; \\Theta(\\Lambda - p),\n     $$\n     其中 $ \\Theta(x) $ 是 Heaviside 阶跃函数。\n   - 高斯型：\n     $$\n     r_\\Lambda^{\\mathrm{gauss}}(p) \\;=\\; \\exp\\!\\Big(-\\big(\\tfrac{p}{\\Lambda}\\big)^2\\Big).\n     $$\n   - $n$ 阶指数型（$n$ 为整数且 $n \\ge 2$）：\n     $$\n     r_\\Lambda^{\\mathrm{exp}(n)}(p) \\;=\\; \\exp\\!\\Big(-\\big(\\tfrac{p}{\\Lambda}\\big)^n\\Big).\n     $$\n\n4. 使用在 $ [0,p_{\\max}] $ 上的 $ N $ 个节点的求积法离散化该积分方程。将节点记为 $ \\{p_i\\}_{i=1}^N $，权重记为 $ \\{w_i\\}_{i=1}^N $。近似为\n   $$\n   \\phi(p_i) \\;\\approx\\; C \\sum_{j=1}^N w_j\\, q_j^2\\, K_\\Lambda(p_i,q_j)\\, \\phi(q_j),\n   $$\n   这是一个齐次矩阵本征值问题。令 $ M_\\Lambda $ 为一个 $ N \\times N $ 矩阵，其元素为\n   $$\n   (M_\\Lambda)_{ij} \\;=\\; w_j\\, q_j^2\\, \\frac{r_\\Lambda(p_i)\\, g(p_i)\\; r_\\Lambda(q_j)\\, g(q_j)}{p_i^2 + q_j^2 + \\kappa^2}.\n   $$\n   于是积分方程变为 $ \\boldsymbol{\\phi} = C\\, M_\\Lambda\\, \\boldsymbol{\\phi} $。$ M_\\Lambda $ 的主（最大）本征值决定了在给定 $ C $ 值下是否存在非平庸解。\n\n5. 通过校准一个参考调节子选择来确定耦合常数 $ C $，使得对于该选择，主本征值等于1。具体来说，对于参考调节子 $ r_{\\Lambda_{\\mathrm{ref}}}^{\\mathrm{gauss}} $（其中 $ \\Lambda_{\\mathrm{ref}} = 15 $），计算当 $ C=1 $ 时 $ M_{\\Lambda_{\\mathrm{ref}}} $ 的最大本征值 $ \\lambda_{\\mathrm{ref}} $，并设置\n   $$\n   C_{\\mathrm{ref}} \\;=\\; \\frac{1}{\\lambda_{\\mathrm{ref}}}.\n   $$\n   在计算其他调节子选择的旁观者振幅时，使用相同的 $ C_{\\mathrm{ref}} $；这可以在固定的低动量校准下分离出调节子人为效应。\n\n6. 对于每种调节子选择，提取 $ C_{\\mathrm{ref}} M_\\Lambda $ 的主右本征矢 $ \\boldsymbol{\\phi} $，并根据S波测度将其归一化至单位概率：\n   $$\n   \\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi(p_i)|^2 \\;=\\; 1.\n   $$\n   定义旁观者动量分布\n   $$\n   n(p_i) \\;=\\; |\\phi(p_i)|^2.\n   $$\n\n7. 定义一个尾部区域 $ p \\in [p_{\\mathrm{tail,min}}, p_{\\mathrm{tail,max}}] $，其中 $ p_{\\mathrm{tail,min}} = 8 $，$ p_{\\mathrm{tail,max}} = 15 $。对于给定的调节子，通过其尾部与使用高斯参考调节子计算出的参考分布 $ n_{\\mathrm{ref}}(p) $ 之间的相对加权 $ L^2 $ 误差来量化调节子人为效应：\n   $$\n   \\varepsilon_{\\mathrm{tail}} \\;=\\; \\frac{\\Big(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, \\big[n(p_i) - n_{\\mathrm{ref}}(p_i)\\big]^2\\Big)^{1/2}}{\\Big(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, n_{\\mathrm{ref}}(p_i)^2\\Big)^{1/2}},\n   $$\n   其中 $ \\mathcal{T} $ 是尾部区间内节点 $ p_i $ 的索引集。\n\n使用的实现细节：\n- 使用 $ N = 160 $ 和 $ p_{\\max} = 20 $ 的 Gauss–Legendre 求积法处理区间 $ [0,p_{\\max}] $。\n- 使用 $ \\beta = 1 $ 和 $ \\kappa = 1 $。\n- 通过幂迭代法计算主导本征值和本征矢，相对容差为 $ 10^{-10} $，最大迭代次数为 $ 2000 $。\n\n测试套件：\n您必须为以下每一组调节子参数计算 $ \\varepsilon_{\\mathrm{tail}} $。每组参数是一个三元组 $ (\\mathrm{type}, \\Lambda, n) $，其中对于非指数类型，$ n $ 被忽略。\n\n- $ (\\text{sharp}, 3, 0) $\n- $ (\\text{sharp}, 6, 0) $\n- $ (\\text{gauss}, 3, 0) $\n- $ (\\text{exp}, 3, 4) $\n- $ (\\text{exp}, 6, 4) $\n- $ (\\text{gauss}, 10, 0) $\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个尾部误差，格式为方括号内由逗号分隔的列表，每个数字使用科学记数法表示，并保留小数点后六位数字（例如，$[1.234567\\mathrm{e}{-}03,2.345678\\mathrm{e}{-}02,\\dots]$）。此问题中没有物理单位；通过构造，所有量都是无量纲的。角度没有显式出现，也无需指定任何单位。",
            "solution": "该问题要求在一个简化的三体束缚态模型中，对紫外调节子对旁观者动量分布的影响进行数值研究。该模型基于 Faddeev 方程，对于具有S波相互作用和秩一可分离势的全同粒子，该方程可简化为一维齐次积分方程。我们将离散化此方程，将其作为矩阵本征值问题求解，并量化不同调节子选择下解的高动量尾部的差异。\n\n出发点是旁观者振幅 $ \\phi(p) $ 的齐次积分方程：\n$$\n\\phi(p) \\;=\\; C \\int_0^{\\infty} \\mathrm{d}q\\, q^2\\, K_\\Lambda(p,q)\\, \\phi(q)\n$$\n仅当耦合常数 $ C $ 取特定值时，才存在非平庸解 $ \\phi(p) \\neq 0 $。核 $ K_\\Lambda(p,q) $ 定义为：\n$$\nK_\\Lambda(p,q) \\;=\\; \\frac{r_\\Lambda(p)\\, g(p)\\; r_\\Lambda(q)\\, g(q)}{p^2 + q^2 + \\kappa^2}\n$$\n此处，$ g(p) $ 是二体相互作用的形因子，$ r_\\Lambda(p) $ 是一个抑制动量超过尺度 $ \\Lambda $ 的调节函数，$ \\kappa $ 是一个与三体束缚能相关的常数。给定 Yamaguchi 形因子 $ g(p) = \\frac{1}{p^2 + \\beta^2} $，其中 $ \\beta = 1 $，并设置 $ \\kappa = 1 $。\n\n提供的调节函数有：\n1.  锐截止：$ r_\\Lambda^{\\mathrm{sharp}}(p) = \\Theta(\\Lambda - p) $，其中 $ \\Theta $ 是 Heaviside 阶跃函数。\n2.  高斯型：$ r_\\Lambda^{\\mathrm{gauss}}(p) = \\exp\\!\\left(-\\left(\\frac{p}{\\Lambda}\\right)^2\\right) $。\n3.  指数型：$ r_\\Lambda^{\\mathrm{exp}(n)}(p) = \\exp\\!\\left(-\\left(\\frac{p}{\\Lambda}\\right)^n\\right) $。\n\n为数值求解该积分方程，我们使用求积法则将其离散化。我们将使用包含 $ N = 160 $ 个点的 Gauss-Legendre 求积法处理动量区间 $ [0, p_{\\max}] $，其中 $ p_{\\max}=20 $。设 $ \\{x_k'\\}_{k=1}^N $ 和 $ \\{w_k'\\}_{k=1}^N $ 为 $ [-1, 1] $ 上的标准 Gauss-Legendre 节点和权重。我们将它们映射到我们的区间 $ [0, p_{\\max}] $ 以获得节点 $ p_i $ 和权重 $ w_i $：\n$$\np_i = \\frac{p_{\\max}}{2}(1 + x_i'), \\quad w_i = w_i' \\frac{p_{\\max}}{2}\n$$\n该积分方程随后被近似为一个矩阵方程：\n$$\n\\phi(p_i) \\;\\approx\\; C \\sum_{j=1}^N w_j\\, p_j^2\\, K_\\Lambda(p_i,p_j)\\, \\phi(p_j)\n$$\n这是一个齐次矩阵本征值问题 $ \\boldsymbol{\\phi} = C M_\\Lambda \\boldsymbol{\\phi} $，其中 $ \\boldsymbol{\\phi} $ 是一个分量为 $ \\phi_i = \\phi(p_i) $ 的向量，$ M_\\Lambda $ 是一个 $ N \\times N $ 矩阵，其元素为：\n$$\n(M_\\Lambda)_{ij} \\;=\\; w_j\\, p_j^2\\, K_\\Lambda(p_i, p_j) \\;=\\; w_j\\, p_j^2\\, \\frac{r_\\Lambda(p_i)\\, g(p_i)\\; r_\\Lambda(p_j)\\, g(p_j)}{p_i^2 + p_j^2 + \\kappa^2}\n$$\n如果 $ C $ 是 $ M_\\Lambda $ 某个本征值的倒数，则存在非平庸解。具有物理意义的束缚态对应于与 $ M_\\Lambda $ 的最大正本征值 $ \\lambda_{\\max} $ 相关联的本征矢。因此，我们必须有 $ C = 1 / \\lambda_{\\max} $。\n\n问题指定了一个校准程序。我们首先使用一个参考案例来确定耦合常数 $ C_{\\mathrm{ref}} $：一个 $ \\Lambda_{\\mathrm{ref}} = 15 $ 的高斯型调节子。我们构建矩阵 $ M_{\\Lambda_{\\mathrm{ref}}} $，找到其最大本征值 $ \\lambda_{\\mathrm{ref}} $，并设置 $ C_{\\mathrm{ref}} = 1/\\lambda_{\\mathrm{ref}} $。此耦合常数随后对所有其他调节子选择保持不变。该程序确保所有模型都校准到相同的低能物理，从而可以公平地比较它们的高动量（紫外）行为。\n\n为找到最大本征值及其对应的本征矢，我们采用幂迭代法。从一个随机向量 $ \\boldsymbol{v}^{(0)} $ 开始，我们进行迭代：\n$$\n\\boldsymbol{v}^{(k+1)} = \\frac{A \\boldsymbol{v}^{(k)}}{||A \\boldsymbol{v}^{(k)}||}\n$$\n其中 $ A $ 是我们感兴趣的矩阵（校准时为 $ M_\\Lambda $，其他情况下为 $ C_{\\mathrm{ref}}M_\\Lambda $），范数可以是任何向量范数。本征矢序列 $ \\boldsymbol{v}^{(k)} $ 收敛到主本征矢，本征值可以从缩放因子中估计。我们迭代直到本征值的相对变化低于 $ 10^{-10} $ 的容差。\n\n对于测试套件中的每个调节子，我们执行以下步骤：\n1.  构建矩阵 $ M_\\Lambda $。\n2.  使用幂迭代法找到矩阵 $ C_{\\mathrm{ref}} M_\\Lambda $ 的主右本征矢 $ \\boldsymbol{\\phi} $。\n3.  得到的本征矢 $ \\boldsymbol{\\phi} $ 必须根据S波概率测度进行归一化。归一化条件是总概率为1：\n    $$\n    \\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi(p_i)|^2 = 1\n    $$\n    设 $ \\boldsymbol{\\phi}_{\\mathrm{unnorm}} $ 为从幂迭代法得到的本征矢。归一化后的本征矢为 $ \\boldsymbol{\\phi} = \\boldsymbol{\\phi}_{\\mathrm{unnorm}} / \\mathcal{N} $，其中归一化常数是 $ \\mathcal{N} = \\sqrt{\\sum_{i=1}^N w_i\\, p_i^2\\, |\\phi_{\\mathrm{unnorm}}(p_i)|^2} $。\n4.  旁观者动量分布则由 $ n(p_i) = |\\phi(p_i)|^2 $ 给出。\n\n最后，我们量化每个计算出的分布 $ n(p) $ 与参考分布 $ n_{\\mathrm{ref}}(p) $（使用参考调节子获得）之间的偏差。误差度量是在尾部区域的差异的相对加权 $ L^2 $ 范数，该区域定义为动量 $ p \\in [p_{\\mathrm{tail,min}}, p_{\\mathrm{tail,max}}] $，其中 $ p_{\\mathrm{tail,min}} = 8 $，$ p_{\\mathrm{tail,max}} = 15 $：\n$$\n\\varepsilon_{\\mathrm{tail}} \\;=\\; \\frac{\\left(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, \\left[n(p_i) - n_{\\mathrm{ref}}(p_i)\\right]^2\\right)^{1/2}}{\\left(\\sum_{i \\in \\mathcal{T}} w_i\\, p_i^2\\, n_{\\mathrm{ref}}(p_i)^2\\right)^{1/2}}\n$$\n其中 $ \\mathcal{T} $ 是使得 $ p_i \\in [8, 15] $ 的索引 $ i $ 的集合。该度量衡量了旁观者振幅高动量部分的调节子人为效应。\n\n整个过程通过计算实现。首先，通过参考计算确定 $ C_{\\mathrm{ref}} $ 和 $ n_{\\mathrm{ref}}(p) $。然后，对于每个测试案例，使用这个固定的 $ C_{\\mathrm{ref}} $ 计算相应的 $ n(p) $，并计算误差 $ \\varepsilon_{\\mathrm{tail}} $。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the three-body problem as specified, calculating regulator artifacts.\n    \"\"\"\n    # --- Problem Parameters ---\n    N = 160\n    P_MAX = 20.0\n    BETA = 1.0\n    KAPPA = 1.0\n    \n    # --- Calibration Parameters ---\n    LAMBDA_REF = 15.0\n    REG_REF_TYPE = 'gauss'\n    \n    # --- Power Iteration Parameters ---\n    TOL = 1e-10\n    MAX_ITER = 2000\n    \n    # --- Tail Region Parameters ---\n    P_TAIL_MIN = 8.0\n    P_TAIL_MAX = 15.0\n\n    # --- Test Suite ---\n    test_cases = [\n        ('sharp', 3, 0),\n        ('sharp', 6, 0),\n        ('gauss', 3, 0),\n        ('exp', 3, 4),\n        ('exp', 6, 4),\n        ('gauss', 10, 0),\n    ]\n\n    # --- Numerical Setup: Gauss-Legendre Quadrature ---\n    # Scipy returns nodes x in [-1, 1] and weights w.\n    x_gl, w_gl = roots_legendre(N)\n    # Transform to interval [0, P_MAX]\n    p_nodes = P_MAX * (1.0 + x_gl) / 2.0\n    p_weights = P_MAX * w_gl / 2.0\n\n    # --- Model Functions ---\n    def form_factor_g(p, beta):\n        return 1.0 / (p**2 + beta**2)\n\n    def regulator_r(p, reg_type, lam, n=0):\n        if reg_type == 'sharp':\n            return np.where(p = lam, 1.0, 0.0)\n        elif reg_type == 'gauss':\n            return np.exp(-(p / lam)**2)\n        elif reg_type == 'exp':\n            if n  2:\n                raise ValueError(\"Order n must be >= 2 for exponential regulator.\")\n            return np.exp(-(p / lam)**n)\n        else:\n            raise ValueError(f\"Unknown regulator type: {reg_type}\")\n\n    # --- Power Iteration for Principal Eigenvalue/Eigenvector ---\n    def power_iteration(matrix):\n        \"\"\"Finds the largest eigenvalue and corresponding eigenvector of a matrix.\"\"\"\n        # Start with a random vector\n        vec = np.random.rand(matrix.shape[1])\n        vec /= np.linalg.norm(vec)\n        \n        lambda_val = 0.0\n        for _ in range(MAX_ITER):\n            # Matrix-vector product\n            mat_vec = matrix @ vec\n            \n            # Estimate eigenvalue\n            lambda_new = np.linalg.norm(mat_vec)\n            \n            # Normalize eigenvector\n            vec = mat_vec / lambda_new\n            \n            # Check for convergence\n            if abs(lambda_new - lambda_val) / lambda_new  TOL:\n                return lambda_new, vec\n            \n            lambda_val = lambda_new\n            \n        raise RuntimeError(\"Power iteration did not converge.\")\n\n    # --- Main Calculation Logic ---\n    def get_distribution(reg_type, lam, n, coupling_c):\n        \"\"\"\n        Constructs the matrix, solves the eigenvalue problem, and returns\n        the normalized momentum distribution. Also returns eigenvalue if C=1.\n        \"\"\"\n        # Evaluate functions at quadrature nodes\n        g_p = form_factor_g(p_nodes, BETA)\n        r_p = regulator_r(p_nodes, reg_type, lam, n)\n        \n        # Combined momentum-dependent part of the kernel\n        G_p = r_p * g_p\n        \n        # Construct the non-symmetric matrix M\n        # Using broadcasting for efficiency\n        # p_i -> column vector, p_j -> row vector\n        p_i = p_nodes[:, np.newaxis]\n        p_j = p_nodes[np.newaxis, :]\n        G_i = G_p[:, np.newaxis]\n        G_j = G_p[np.newaxis, :]\n        w_j_qj2 = p_weights[np.newaxis, :] * p_j**2\n        \n        numerator = G_i * G_j\n        denominator = p_i**2 + p_j**2 + KAPPA**2\n        \n        M_lambda = (numerator / denominator) * w_j_qj2\n\n        # In calibration phase, we need lambda_ref for M_lambda (C=1)\n        if coupling_c == 1.0:\n            lambda_max, phi_unnorm = power_iteration(M_lambda)\n            return lambda_max, phi_unnorm\n        \n        # For test cases, solve eigenvalue problem for C_ref * M_lambda\n        full_matrix = coupling_c * M_lambda\n        _, phi_unnorm = power_iteration(full_matrix)\n        \n        # Normalize the eigenvector phi\n        # The eigenvector components are all positive -> abs() is not strictly needed\n        norm_sq = np.sum(p_weights * p_nodes**2 * phi_unnorm**2)\n        phi_norm = phi_unnorm / np.sqrt(norm_sq)\n        \n        # Calculate momentum distribution n(p) = |phi(p)|^2\n        n_p = phi_norm**2\n        return n_p\n\n    # --- Step 1: Calibration to find C_ref and n_ref ---\n    lambda_ref, _ = get_distribution(REG_REF_TYPE, LAMBDA_REF, 0, 1.0)\n    C_ref = 1.0 / lambda_ref\n    \n    n_ref = get_distribution(REG_REF_TYPE, LAMBDA_REF, 0, C_ref)\n    \n    # --- Step 2: Loop through test cases and compute errors ---\n    results = []\n    \n    # Identify indices for the tail region\n    tail_mask = (p_nodes >= P_TAIL_MIN)  (p_nodes = P_TAIL_MAX)\n    p_tail = p_nodes[tail_mask]\n    w_tail = p_weights[tail_mask]\n    n_ref_tail = n_ref[tail_mask]\n\n    for reg_type, lam, n in test_cases:\n        # Get the momentum distribution for the current test case\n        n_p = get_distribution(reg_type, lam, n, C_ref)\n        n_p_tail = n_p[tail_mask]\n\n        # Calculate the weighted L2 error in the tail\n        numerator_sq = np.sum(w_tail * p_tail**2 * (n_p_tail - n_ref_tail)**2)\n        denominator_sq = np.sum(w_tail * p_tail**2 * n_ref_tail**2)\n        \n        if denominator_sq == 0:\n            # Handle case of zero denominator, though unlikely here\n            error_tail = np.inf if numerator_sq > 0 else 0.0\n        else:\n            error_tail = np.sqrt(numerator_sq / denominator_sq)\n            \n        results.append(error_tail)\n\n    # --- Final Output ---\n    output_str = \",\".join([f\"{res:.6e}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        }
    ]
}