{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。本章提供了一系列动手练习，旨在将约束路径蒙特卡洛方法的抽象概念转化为具体的计算技能。这些练习将引导你从构建基本算法，到诊断其行为，再到优化其性能，从而全面掌握这一强大的计算工具。\n\n我们从一个基础但极具启发性的练习开始。这个练习将指导你为一个精确可解的两站点哈伯德模型实现一个单步辅助场量子蒙特卡洛 (AFQMC) 的计算。由于系统规模很小，我们可以精确地遍历所有辅助场构型，从而让你能专注于传播子、约束条件和混合估计量等核心逻辑，而无需担心统计采样带来的噪声。通过将计算结果与精确解进行比较，你将对约束路径近似的有效性和局限性建立起直观的认识。",
            "id": "3551579",
            "problem": "考虑一个在自旋旋转下不变的一维双格点Hubbard模型，它在自旋空间中表现出2度特殊酉群(SU(2))对称性。设格点由 $i \\in \\{1,2\\}$ 标记，自旋由 $\\sigma \\in \\{\\uparrow,\\downarrow\\}$ 标记。哈密顿量为\n$$\n\\hat{H} = \\hat{K} + \\hat{V},\n$$\n其中动能项为\n$$\n\\hat{K} = -t \\sum_{\\sigma} \\left( \\hat{c}_{1\\sigma}^{\\dagger} \\hat{c}_{2\\sigma} + \\hat{c}_{2\\sigma}^{\\dagger} \\hat{c}_{1\\sigma} \\right),\n$$\n在位相互作用项为\n$$\n\\hat{V} = U \\sum_{i=1}^{2} \\hat{n}_{i\\uparrow} \\hat{n}_{i\\downarrow},\n$$\n其中 $t > 0$ 且 $U \\ge 0$，$\\hat{c}_{i\\sigma}^{\\dagger}$ 和 $\\hat{c}_{i\\sigma}$ 是费米子产生和湮灭算符，$\\hat{n}_{i\\sigma} = \\hat{c}_{i\\sigma}^{\\dagger} \\hat{c}_{i\\sigma}$ 是粒子数算符。在半填充条件下进行计算，系统包含两个费米子，每个自旋方向各一个。\n\n这个双格点系统在半填充时的基态能量是精确已知的，可以通过在自旋单态子空间中直接对角化得到。将其记为 $E_0(U,t)$。对于该模型，其表达式为：\n$$\nE_0(U,t) = \\frac{U}{2} - \\sqrt{\\left( \\frac{U}{2} \\right)^2 + 4 t^2 }.\n$$\n\n您将实现一个采用约束路径近似的辅助场量子蒙特卡洛(AFQMC)投影算符。AFQMC投影算符使用单个时间片上的Trotter-Suzuki分解来近似虚时演化算符：\n$$\ne^{-\\Delta \\tau \\hat{H}} \\approx e^{-\\Delta \\tau \\hat{K}} e^{-\\Delta \\tau \\hat{V}}.\n$$\n相互作用项使用离散的Hirsch Hubbard-Stratonovich变换进行解耦：\n$$\ne^{-\\Delta \\tau U \\hat{n}_{i\\uparrow} \\hat{n}_{i\\downarrow}} = \\frac{1}{2} e^{-\\Delta \\tau U / 2} \\sum_{s_i=\\pm 1} e^{\\lambda s_i (\\hat{n}_{i\\uparrow} - \\hat{n}_{i\\downarrow})},\n$$\n其中 $\\lambda$ 的选择满足 $\\cosh(\\lambda) = e^{\\Delta \\tau U / 2}$，即\n$$\n\\lambda = \\operatorname{arccosh}\\left( e^{\\Delta \\tau U / 2} \\right).\n$$\n\n在格点基中，将单体传播子表示为 $2 \\times 2$ 矩阵。动能矩阵为\n$$\nK = \\begin{pmatrix} 0  -t \\\\ -t  0 \\end{pmatrix},\n$$\n其单时间片传播子为 $B_K = e^{-\\Delta \\tau K}$ (矩阵指数)。解耦后的相互作用为每个自旋产生一个对角势：\n$$\nD_{\\sigma}(\\mathbf{s}) = \\operatorname{diag}\\left( e^{\\sigma \\lambda s_1}, e^{\\sigma \\lambda s_2} \\right),\n$$\n其中自旋向上$\\sigma = +1$，自旋向下$\\sigma = -1$，$\\mathbf{s} = (s_1,s_2)$ 表示单个时间片上两个格点的Hubbard-Stratonovich伊辛场。\n\n使用由每个自旋的成键轨道构建的试探斯莱特行列式 $|\\Psi_T\\rangle$：\n$$\n|\\phi_T\\rangle = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix},\n$$\n因此每个自旋部分的试探态是单粒子态 $|\\phi_T\\rangle$。该试探态在无相互作用极限 $U=0$ 时包含了精确的费米子节面。对于单个时间片，在场构型 $\\mathbf{s}$ 下，自旋为 $\\sigma$ 的行走波函数轨道经过传播后为：\n$$\n|\\phi_{\\sigma}(\\mathbf{s})\\rangle = B_K \\, D_{\\sigma}(\\mathbf{s}) \\, |\\phi_T\\rangle.\n$$\n\n将自旋为 $\\sigma$ 的态与试探态的交叠定义为\n$$\nO_{\\sigma}(\\mathbf{s}) = \\langle \\phi_T | \\phi_{\\sigma}(\\mathbf{s}) \\rangle,\n$$\n总交叠为 $O(\\mathbf{s}) = O_{\\uparrow}(\\mathbf{s}) \\, O_{\\downarrow}(\\mathbf{s})$。约束路径近似通过舍弃任何使得 $O(\\mathbf{s}) \\le 0$ 的场构型 $\\mathbf{s}$ 来强制保持试探态交叠的符号。\n\n对于每个允许的构型 $\\mathbf{s}$，将自旋为 $\\sigma$ 的混合单体格林函数定义为\n$$\nG_{\\sigma}(\\mathbf{s}) = \\frac{|\\phi_{\\sigma}(\\mathbf{s})\\rangle \\langle \\phi_T |}{O_{\\sigma}(\\mathbf{s})},\n$$\n由此可得动能的混合估计量\n$$\nE_K(\\mathbf{s}) = \\sum_{\\sigma} \\operatorname{Tr}\\left[ K \\, G_{\\sigma}(\\mathbf{s}) \\right],\n$$\n以及相互作用能的混合估计量\n$$\nE_U(\\mathbf{s}) = U \\sum_{i=1}^{2} \\left( G_{\\uparrow}(\\mathbf{s}) \\right)_{ii} \\left( G_{\\downarrow}(\\mathbf{s}) \\right)_{ii}.\n$$\n局域能量为 $E_L(\\mathbf{s}) = E_K(\\mathbf{s}) + E_U(\\mathbf{s})$。\n\n在时间步长 $\\Delta \\tau$ 下，单个时间片的约束路径能量是所有允许构型的交叠加权平均值：\n$$\nE_{\\text{CP}}(\\Delta \\tau) = \\frac{\\sum_{\\mathbf{s} \\in \\mathcal{A}} O(\\mathbf{s}) \\, E_L(\\mathbf{s})}{\\sum_{\\mathbf{s} \\in \\mathcal{A}} O(\\mathbf{s})},\n$$\n其中 $\\mathcal{A}$ 是所有满足 $O(\\mathbf{s}) > 0$ 的 $\\mathbf{s}$ 的集合。Hubbard-Stratonovich变换中的常数前因子在此比率中被消去，因此无需包含在权重中。\n\n从虚时薛定谔方程以及上述分解和解耦出发，实现算法来计算给定模型的 $E_{\\text{CP}}(\\Delta \\tau)$，并将其与精确基态能量 $E_0(U,t)$ 进行比较。使用以下测试套件，固定 $t=1$ 且单个时间片 $L=1$：\n\n- 情况1 (理想情况，无相互作用，粗步长): $U=0$, $\\Delta \\tau = 0.5$。\n- 情况2 (无相互作用，细步长): $U=0$, $\\Delta \\tau = 0.05$。\n- 情况3 (有相互作用，粗步长): $U=4$, $\\Delta \\tau = 0.5$。\n- 情况4 (有相互作用，中等步长): $U=4$, $\\Delta \\tau = 0.2$。\n- 情况5 (有相互作用，细步长): $U=4$, $\\Delta \\tau = 0.05$。\n\n对于每种情况，计算并以浮点数形式返回约束路径能量 $E_{\\text{CP}}(\\Delta \\tau)$。此外，对于情况1和2，返回一个布尔值，指示当试探波函数包含正确节面时，约束路径近似是否精确；即，$|E_{\\text{CP}}(\\Delta \\tau) - E_0(U,t)|  10^{-10}$ 是否成立。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按此顺序包含七个条目：\n$$\n\\left[ E_{\\text{CP}}(0.5; U{=}0), E_{\\text{CP}}(0.05; U{=}0), E_{\\text{CP}}(0.5; U{=}4), E_{\\text{CP}}(0.2; U{=}4), E_{\\text{CP}}(0.05; U{=}4), \\text{ExactCase1}, \\text{ExactCase2} \\right],\n$$\n其中最后两项是布尔值。能量值不需要物理单位。",
            "solution": "### 步骤1：提取已知条件\n问题为一维双格点Hubbard模型在半填充（两个费米子，一个自旋向上，一个自旋向下）情况下提供了以下数据和定义：\n\n1.  **哈密顿量**: $\\hat{H} = \\hat{K} + \\hat{V}$\n    *   动能项: $\\hat{K} = -t \\sum_{\\sigma} \\left( \\hat{c}_{1\\sigma}^{\\dagger} \\hat{c}_{2\\sigma} + \\hat{c}_{2\\sigma}^{\\dagger} \\hat{c}_{1\\sigma} \\right)$\n    *   相互作用项: $\\hat{V} = U \\sum_{i=1}^{2} \\hat{n}_{i\\uparrow} \\hat{n}_{i\\downarrow}$\n    *   参数: $t > 0$, $U \\ge 0$。\n\n2.  **精确基态能量**: $E_0(U,t) = \\frac{U}{2} - \\sqrt{\\left( \\frac{U}{2} \\right)^2 + 4 t^2 }$。\n\n3.  **AFQMC投影算符（单时间片 $\\Delta \\tau$）**:\n    *   Trotter-Suzuki分解: $e^{-\\Delta \\tau \\hat{H}} \\approx e^{-\\Delta \\tau \\hat{K}} e^{-\\Delta \\tau \\hat{V}}$。\n    *   相互作用项的Hirsch离散Hubbard-Stratonovich变换:\n        $$\n        e^{-\\Delta \\tau U \\hat{n}_{i\\uparrow} \\hat{n}_{i\\downarrow}} = \\frac{1}{2} e^{-\\Delta \\tau U / 2} \\sum_{s_i=\\pm 1} e^{\\lambda s_i (\\hat{n}_{i\\uparrow} - \\hat{n}_{i\\downarrow})}\n        $$\n    *   Hubbard-Stratonovich参数: $\\lambda = \\operatorname{arccosh}\\left( e^{\\Delta \\tau U / 2} \\right)$。\n\n4.  **单体表示（格点基）**:\n    *   动能矩阵: $K = \\begin{pmatrix} 0  -t \\\\ -t  0 \\end{pmatrix}$。\n    *   动能传播子: $B_K = e^{-\\Delta \\tau K}$ (矩阵指数)。\n    *   相互作用势矩阵（对于HS场 $\\mathbf{s} = (s_1, s_2)$ 和自旋 $\\sigma$）:\n        $$\n        D_{\\sigma}(\\mathbf{s}) = \\operatorname{diag}\\left( e^{\\sigma \\lambda s_1}, e^{\\sigma \\lambda s_2} \\right)\n        $$\n        其中自旋向上 $\\sigma = +1$，自旋向下 $\\sigma = -1$。\n\n5.  **试探波函数与传播**:\n    *   试探轨道（对每个自旋）: $|\\phi_T\\rangle = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n    *   传播后的行走波函数轨道: $|\\phi_{\\sigma}(\\mathbf{s})\\rangle = B_K \\, D_{\\sigma}(\\mathbf{s}) \\, |\\phi_T\\rangle$。\n\n6.  **可观测量与约束**:\n    *   自旋分辨交叠: $O_{\\sigma}(\\mathbf{s}) = \\langle \\phi_T | \\phi_{\\sigma}(\\mathbf{s}) \\rangle$。\n    *   总交叠: $O(\\mathbf{s}) = O_{\\uparrow}(\\mathbf{s}) \\, O_{\\downarrow}(\\mathbf{s})$。\n    *   约束路径条件: 保留 $O(\\mathbf{s}) > 0$ 的构型 $\\mathbf{s}$。\n    *   混合单体格林函数: $G_{\\sigma}(\\mathbf{s}) = \\frac{|\\phi_{\\sigma}(\\mathbf{s})\\rangle \\langle \\phi_T |}{O_{\\sigma}(\\mathbf{s})}$。\n    *   混合动能估计量: $E_K(\\mathbf{s}) = \\sum_{\\sigma} \\operatorname{Tr}\\left[ K \\, G_{\\sigma}(\\mathbf{s}) \\right]$。\n    *   混合相互作用能估计量: $E_U(\\mathbf{s}) = U \\sum_{i=1}^{2} \\left( G_{\\uparrow}(\\mathbf{s}) \\right)_{ii} \\left( G_{\\downarrow}(\\mathbf{s}) \\right)_{ii}$。\n    *   局域能量: $E_L(\\mathbf{s}) = E_K(\\mathbf{s}) + E_U(\\mathbf{s})$。\n\n7.  **最终约束路径能量**:\n    *   $E_{\\text{CP}}(\\Delta \\tau) = \\frac{\\sum_{\\mathbf{s} \\in \\mathcal{A}} O(\\mathbf{s}) \\, E_L(\\mathbf{s})}{\\sum_{\\mathbf{s} \\in \\mathcal{A}} O(\\mathbf{s})}$，其中 $\\mathcal{A} = \\{\\mathbf{s} | O(\\mathbf{s}) > 0\\}$。HS变换的常数前因子被消掉，可以忽略。\n\n8.  **测试套件**：固定 $t=1$，单时间片。\n    *   情况1: $U=0$, $\\Delta \\tau = 0.5$。\n    *   情况2: $U=0$, $\\Delta \\tau = 0.05$。\n    *   情况3: $U=4$, $\\Delta \\tau = 0.5$。\n    *   情况4: $U=4$, $\\Delta \\tau = 0.2$。\n    *   情况5: $U=4$, $\\Delta \\tau = 0.05$。\n    *   对于情况1和2，还需返回一个布尔值表示 $|E_{\\text{CP}}(\\Delta \\tau) - E_0(U,t)|  10^{-10}$ 是否成立。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学基础**：该问题牢固地植根于标准的多体量子力学和计算物理学。Hubbard模型、辅助场量子蒙特卡洛(AFQMC)、Trotter-Suzuki分解和Hirsch-Hubbard-Stratonovich变换都是该领域的基石概念。所提供的方程是这些概念在指定模型下的正确表示。双格点Hubbard模型的精确解是一个众所周知的基准。\n2.  **适定性**：问题是适定的。它要求对一个确定性算法计算一个特定量 $E_{\\text{CP}}(\\Delta \\tau)$。由于系统只有两个格点，对Hubbard-Stratonovich场 $\\mathbf{s}$ 的求和不是蒙特卡洛抽样，而是对 $2^2=4$ 种构型的精确枚举。所有必要的公式、参数和初始状态都已明确提供，从而为每个测试用例导出一个唯一的、可计算的解。\n3.  **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n4.  **完整性和一致性**：问题是自洽的。它提供了计算所需的所有组成部分，从哈密顿量到最终的能量公式。没有缺失的定义或矛盾的约束。\n5.  **相关性**：该问题直接切合*计算核物理学*（以及更广泛的计算量子物理学）领域中*蒙特卡洛中的约束路径近似*这一主题。\n\n问题没有任何诸如科学上不健全、信息缺失或含糊不清等缺陷。\n\n### 步骤3：结论与行动\n问题有效。将提供一个完整的解决方案。\n\n### 基于原理的设计与求解\n核心任务是计算单个虚时间步的约束路径能量估计量 $E_{\\text{CP}}(\\Delta \\tau)$。这涉及到对所有可能的辅助场构型 $\\mathbf{s}$ 上的局域能量 $E_L(\\mathbf{s})$ 进行平均，并以其对应的交叠 $O(\\mathbf{s})$ 作为权重。由于我们对整个辅助场空间（该空间很小，$2^2=4$ 种构型）进行求和，因此该计算是确定性的。\n\n对于每个测试用例 $(U, \\Delta\\tau)$，算法按以下步骤进行：\n\n1.  **初始化**：定义模型的物理参数。跃迁强度固定为 $t=1$。构建单体动能矩阵 $K$ 和试探轨道 $|\\phi_T\\rangle$。$|\\phi_T\\rangle$ 是无相互作用系统 ($U=0$) 的基态，即成键轨道。\n    $$\n    K = \\begin{pmatrix} 0  -1 \\\\ -1  0 \\end{pmatrix}, \\quad |\\phi_T\\rangle = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n    $$\n\n2.  **计算与步长相关的参数**：\n    *   Hubbard-Stratonovich参数 $\\lambda$ 取决于 $U$ 和 $\\Delta\\tau$。对于 $U=0$，我们有 $e^{\\Delta \\tau U / 2} = 1$，且 $\\lambda = \\operatorname{arccosh}(1) = 0$，这正确地消除了传播子中的相互作用部分。对于 $U > 0$，$\\lambda > 0$。\n    *   单体动能传播子 $B_K$ 是 $-\\Delta\\tau K$ 的矩阵指数。这可以数值计算或解析计算。对于 $K=\\begin{pmatrix} 0  -t \\\\ -t  0 \\end{pmatrix}$，解析解为 $B_K = e^{-\\Delta\\tau K} = \\begin{pmatrix} \\cosh(\\Delta\\tau t)  \\sinh(\\Delta\\tau t) \\\\ \\sinh(\\Delta\\tau t)  \\cosh(\\Delta\\tau t) \\end{pmatrix}$。\n\n3.  **遍历辅助场**：计算需要对离散Hubbard-Stratonovich场 $\\mathbf{s} = (s_1, s_2)$ 的所有四种可能构型进行求和，其中 $s_i \\in \\{+1, -1\\}$。构型集合为 $\\{(1,1), (1,-1), (-1,1), (-1,-1)\\}$。对于每种构型 $\\mathbf{s}$：\n\n    a.  **构建相互作用传播子**：对于自旋 $\\sigma=+1$（上）和 $\\sigma=-1$（下），定义对角矩阵 $D_{\\sigma}(\\mathbf{s})$，它表示在给定场构型下相互作用项的作用。\n        $$\n        D_{\\uparrow}(\\mathbf{s}) = \\operatorname{diag}(e^{\\lambda s_1}, e^{\\lambda s_2}), \\quad D_{\\downarrow}(\\mathbf{s}) = \\operatorname{diag}(e^{-\\lambda s_1}, e^{-\\lambda s_2})\n        $$\n\n    b.  **传播行走波函数并计算交叠**：试探轨道 $|\\phi_T\\rangle$ 在虚时间中向前传播一步，受到动能项和特定相互作用构型 $\\mathbf{s}$ 的影响。\n        $$\n        |\\phi_{\\sigma}(\\mathbf{s})\\rangle = B_K D_{\\sigma}(\\mathbf{s}) |\\phi_T\\rangle\n        $$\n        计算每个自旋的传播后行走波函数与原始试探态的交叠 $O_{\\sigma}(\\mathbf{s}) = \\langle \\phi_T |\\phi_{\\sigma}(\\mathbf{s})\\rangle$。总交叠权重是乘积 $O(\\mathbf{s}) = O_{\\uparrow}(\\mathbf{s}) O_{\\downarrow}(\\mathbf{s})$。因为我们的试探轨道是成键轨道（所有分量均为正），并且传播子 $B_K$ 和 $D_\\sigma$ 由正指数函数构成，因此得到的传播后的行走波函数轨道 $|\\phi_{\\sigma}(\\mathbf{s})\\rangle$ 的所有分量都将是正的。因此，交叠 $O(\\mathbf{s})$ 将始终为正。约束路径条件 $O(\\mathbf{s}) > 0$ 总是满足的，允许的构型集合 $\\mathcal{A}$ 包括所有四种可能性。\n\n    c.  **计算局域能量**：如果构型是允许的（所有构型都允许），则计算局域能量 $E_L(\\mathbf{s})$。这首先需要混合单体格林函数：\n        $$\n        G_{\\sigma}(\\mathbf{s}) = \\frac{|\\phi_{\\sigma}(\\mathbf{s})\\rangle \\langle \\phi_T |}{O_{\\sigma}(\\mathbf{s})}\n        $$\n        从这些函数中，可以找到动能和势能估计量：\n        $$\n        E_K(\\mathbf{s}) = \\operatorname{Tr}[K G_{\\uparrow}(\\mathbf{s})] + \\operatorname{Tr}[K G_{\\downarrow}(\\mathbf{s})]\n        $$\n        $$\n        E_U(\\mathbf{s}) = U \\left( (G_{\\uparrow}(\\mathbf{s}))_{11} (G_{\\downarrow}(\\mathbf{s}))_{11} + (G_{\\uparrow}(\\mathbf{s}))_{22} (G_{\\downarrow}(\\mathbf{s}))_{22} \\right)\n        $$\n        总局域能量为 $E_L(\\mathbf{s}) = E_K(\\mathbf{s}) + E_U(\\mathbf{s})$。\n\n    d.  **累积结果**：将加权能量 $O(\\mathbf{s}) E_L(\\mathbf{s})$ 和权重 $O(\\mathbf{s})$ 添加到运行总和中。\n\n4.  **最终能量计算**：遍历所有四个场构型后，最终的约束路径能量计算为累积总和的比率：\n    $$\n    E_{\\text{CP}}(\\Delta \\tau) = \\frac{\\sum_{\\mathbf{s}} O(\\mathbf{s}) E_L(\\mathbf{s})}{\\sum_{\\mathbf{s}} O(\\mathbf{s})}\n    $$\n\n5.  **特殊情况分析 ($U=0$)**：对于无相互作用情况 ($U=0$)，我们得到 $\\lambda=0$。这使得 $D_{\\sigma}(\\mathbf{s})$ 对所有 $\\mathbf{s}$ 都是单位矩阵。行走波函数的传播变得与 $\\mathbf{s}$ 无关，局域能量 $E_L$ 对所有构型都为常数。由于 $|\\phi_T\\rangle$ 是 $K$ 的本征态，本征值为 $-t$，粒子-空穴对称的试探波函数是无相互作用哈密顿量 $\\hat{K}$ 的本征态，能量为 $2 \\times (-t) = -2t$。当试探态是哈密顿量的本征态时，混合估计量方法会得到精确的本征值。因此，对于 $U=0$ 和 $t=1$，我们期望 $E_{\\text{CP}} = -2$。这与精确基态能量 $E_0(0,1) = -2$ 相符。因此，检查 $|E_{\\text{CP}} - E_0|  10^{-10}$ 应该为真，这反映了当试探波函数具有基态的正确节面时（对于$U=0$的情况即是如此），约束路径近似是精确的。在这种特殊情况下，Trotter误差也消失了，因为 $|\\phi_T\\rangle$ 是 $\\hat{K}$ 的一个本征态。\n\n实现将为每个提供的测试用例精确地遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the single-slice constrained-path AFQMC energy for a two-site Hubbard model.\n    \"\"\"\n    \n    test_cases = [\n        # (U, delta_tau)\n        (0.0, 0.5), # Case 1\n        (0.0, 0.05), # Case 2\n        (4.0, 0.5), # Case 3\n        (4.0, 0.2), # Case 4\n        (4.0, 0.05), # Case 5\n    ]\n\n    results_ecp = []\n\n    t = 1.0\n    for U, dtau in test_cases:\n        \n        # Define matrices and trial wavefunction\n        K = np.array([[0, -t], \n                      [-t, 0]], dtype=float)\n        phi_T = (1.0 / np.sqrt(2.0)) * np.array([1.0, 1.0], dtype=float)\n\n        # Calculate step-dependent parameters\n        arg_arccosh = np.exp(dtau * U / 2.0)\n        lambda_val = 0.0 if np.isclose(arg_arccosh, 1.0) else np.arccosh(arg_arccosh)\n        \n        # Kinetic propagator matrix\n        B_K = expm(-dtau * K)\n\n        total_weight = 0.0\n        total_energy_times_weight = 0.0\n\n        # Iterate over all 2^2 = 4 auxiliary field configurations\n        s_fields = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        \n        for s1, s2 in s_fields:\n            s_vec = np.array([s1, s2])\n\n            # 1. Construct interaction propagators D_sigma(s)\n            D_up = np.diag(np.exp(lambda_val * s_vec))\n            D_dn = np.diag(np.exp(-lambda_val * s_vec))\n\n            # 2. Propagate walkers\n            phi_up_s = B_K @ D_up @ phi_T\n            phi_dn_s = B_K @ D_dn @ phi_T\n            \n            # 3. Compute overlaps\n            O_up_s = phi_T.T @ phi_up_s\n            O_dn_s = phi_T.T @ phi_dn_s\n            O_s = O_up_s * O_dn_s\n            \n            # 4. Constrained-path approximation check (O_s>0)\n            if O_s > 0:\n                # 5. Compute Green's functions\n                G_up_s = np.outer(phi_up_s, phi_T) / O_up_s\n                G_dn_s = np.outer(phi_dn_s, phi_T) / O_dn_s\n                \n                # 6. Compute local energies\n                E_K_s = np.trace(K @ G_up_s) + np.trace(K @ G_dn_s)\n                \n                G_up_ii = np.diag(G_up_s)\n                G_dn_ii = np.diag(G_dn_s)\n                E_U_s = U * np.sum(G_up_ii * G_dn_ii)\n                \n                E_L_s = E_K_s + E_U_s\n\n                # 7. Accumulate weighted energy and weight\n                total_energy_times_weight += O_s * E_L_s\n                total_weight += O_s\n        \n        # Calculate final E_CP\n        E_CP = total_energy_times_weight / total_weight if total_weight != 0 else 0\n        results_ecp.append(E_CP)\n\n    # Exactness checks\n    E0_case1 = 0.0 / 2.0 - np.sqrt((0.0 / 2.0)**2 + 4 * t**2)\n    exact_case1 = np.abs(results_ecp[0] - E0_case1)  1e-10\n\n    E0_case2 = 0.0 / 2.0 - np.sqrt((0.0 / 2.0)**2 + 4 * t**2)\n    exact_case2 = np.abs(results_ecp[1] - E0_case2)  1e-10\n\n    final_results = results_ecp + [exact_case1, exact_case2]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实现了基本的约束路径算法后，一个关键问题随之而来：我们施加的约束效果如何？这个练习旨在回答这一问题。我们通过一个简化的朗之万漂移-扩散模型来模拟“行走点”(walkers) 在节点曲面附近的行为，从而让你能专注于约束动力学的核心。你的任务是实现一个重要的诊断工具——“泄漏概率” $p_{\\text{leak}}(\\tau)$，它量化了在没有约束的情况下行走点穿越节点曲面的频率。这个量可以有效地评估约束的“强度”或“侵略性”，并帮助我们理解其对模拟结果的影响。",
            "id": "3551590",
            "problem": "考虑一个用于辅助场量子蒙特卡洛 (AFQMC) 中行走子的简化虚时传播模型，其中采用约束路径近似，通过禁止穿越节面来防止符号不稳定性。位形坐标是一维的，节面是位于 $x = 0$ 的超平面。行走子根据朗之万形式的漂移-扩散进行演化，这是虚时传播中福克-普朗克动力学的一种标准表示：对于位置 $x(t)$，\n$$\ndx(t) = \\mu\\,dt + \\sqrt{2D}\\,dW_t,\n$$\n其中 $dW_t$ 是标准维纳过程的一个增量，$D \\ge 0$ 是扩散系数，$\\mu$ 是一个恒定的漂移。时间步是离散的，步长为 $\\Delta\\tau$，因此在第 $n$ 步的提议移动形式为\n$$\nx_{n+1}^{\\text{prop}} = x_n + \\mu\\,\\Delta\\tau + \\sqrt{2D\\Delta\\tau}\\,\\eta_n,\n$$\n其中 $\\eta_n \\sim \\mathcal{N}(0,1)$ 是独立的。带有侵略性参数 $\\delta \\ge 0$ 的约束路径近似强制规定，任何提议的位置 $x_{n+1}^{\\text{prop}}  \\delta$ 都被拒绝，且该行走子被杀死（从系综中移除）。当 $\\delta = 0$ 时，这简化为仅当提议的位置穿越节面时才杀死行走子；更大的 $\\delta$ 通过杀死那些接近但未穿越节面的行走子来增加侵略性。\n\n我们将稀有事件穿越诊断定义为单位时间泄露概率 $p_{\\text{leak}}(\\tau)$，它是在没有约束的情况下，提议移动会穿越节面 $x=0$ 的速率（每单位虚时），该值是通过在边界附近进行分裂（克隆），从有约束的模拟中估计得出的。该估计量必须是无偏的。设单个提议移动的指示函数为\n$$\nI = \\begin{cases}\n1,  \\text{if } x_{n+1}^{\\text{prop}}  0,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n设 $C_{\\text{total}}$ 为在所有提议移动和所有时间步上累积的穿越指示函数的总加权计数，设 $A_{\\text{total}}$ 为总存活时间度量，\n$$\nA_{\\text{total}} = \\sum_{n} N_{\\text{alive}}(n)\\,\\Delta\\tau,\n$$\n其中 $N_{\\text{alive}}(n)$ 是在第 $n$ 步开始时存活的行走子数量。单位时间泄露概率由下式估计：\n$$\np_{\\text{leak}}(\\tau) = \\frac{C_{\\text{total}}}{A_{\\text{total}}}.\n$$\n\n因为当漂移方向远离节面或扩散很小时，穿越是稀有事件，所以使用分裂方法来增强统计性。分裂（克隆）仅在约束区域附近作为一种测量手段执行，以保持传播的无偏性。具体来说，如果一个行走子的当前位置 $x_n$ 落在区间 $[\\delta,\\,\\delta+\\varepsilon)$ 内，我们抽取 $K$ 个独立的提议移动 $x_{n+1}^{\\text{prop},(j)}$（其中 $j \\in \\{1,\\dots,K\\}$），并以 $1/K$ 的权重累积穿越指示函数，\n$$\nC_{\\text{total}} \\leftarrow C_{\\text{total}} + \\frac{1}{K}\\sum_{j=1}^{K}\\mathbf{1}\\{x_{n+1}^{\\text{prop},(j)}0\\},\n$$\n然后从这 $K$ 个提议移动中均匀选择一个，作为该行走子实际传播后的位置（需满足约束条件 $x_{n+1} \\ge \\delta$）。这种选择确保了实现的路径仍然是来自正确提议分布的一个无偏单一采样，而平均化的指示函数则为穿越概率提供了一个无偏估计量。对于位置 $x_n \\ge \\delta+\\varepsilon$ 的行走子，只抽取一个提议移动并以单位权重计数；对于已被杀死的行走子，不进行任何提议移动。\n\n您必须实现一个程序，对于下面提供的每个测试用例，该程序初始化 $N_0$ 个行走子，其位置从限制在 $x \\ge \\delta$ 的截断正态分布中抽取（抽取 $x \\sim \\mathcal{N}(m_0,s_0^2)$，如果 $x\\delta$，则设 $x=\\delta$），然后使用上述约束路径动力学和分裂规则，将它们演化总计 $T_{\\text{total}}$ 的虚时。使用独立同分布的正态变量作为提议移动的增量。在每个时间步，通过加上 $N_{\\text{alive}}(n)\\,\\Delta\\tau$ 来更新 $A_{\\text{total}}$。每当 $x_{n+1}^{\\text{prop}}0$ 时，就为一个提议移动计算一个穿越指示函数，无论施加约束后传播的位置是被杀死还是被接受，因为该指示函数衡量的是无约束的穿越趋势。\n\n在每个测试用例结束时，使用 $p_{\\text{leak}}(\\tau) = C_{\\text{total}}/A_{\\text{total}}$ 计算并记录 $p_{\\text{leak}}(\\tau)$。如果 $A_{\\text{total}}=0$，则定义 $p_{\\text{leak}}(\\tau)=0$。\n\n将 $p_{\\text{leak}}(\\tau)$ 以逆虚时单位（即模拟中所用时间变量的单位的倒数）表示，并作为浮点数输出。\n\n测试套件：\n对于以下每一组参数，运行模拟并输出得到的 $p_{\\text{leak}}(\\tau)$。以下所有数值均为与上述定义一致的无量纲单位。\n\n- 用例 $1$：$\\mu=0.35$, $D=0.12$, $\\Delta\\tau=0.005$, $T_{\\text{total}}=2.0$, $N_0=8000$, $\\delta=0.0$, $\\varepsilon=0.04$, $K=8$, $m_0=0.8$, $s_0=0.3$, seed $=12345$。\n- 用例 $2$：$\\mu=-0.25$, $D=0.20$, $\\Delta\\tau=0.01$, $T_{\\text{total}}=2.5$, $N_0=6000$, $\\delta=0.0$, $\\varepsilon=0.05$, $K=12$, $m_0=0.6$, $s_0=0.25$, seed $=54321$。\n- 用例 $3$：$\\mu=0.20$, $D=0.08$, $\\Delta\\tau=0.005$, $T_{\\text{total}}=2.0$, $N_0=9000$, $\\delta=0.03$, $\\varepsilon=0.03$, $K=20$, $m_0=0.7$, $s_0=0.2$, seed $=67890$。\n- 用例 $4$：$\\mu=0.10$, $D=10^{-6}$, $\\Delta\\tau=0.01$, $T_{\\text{total}}=1.5$, $N_0=5000$, $\\delta=0.0$, $\\varepsilon=0.02$, $K=10$, $m_0=0.9$, $s_0=0.15$, seed $=13579$。\n- 用例 $5$：$\\mu=-0.90$, $D=0.30$, $\\Delta\\tau=0.005$, $T_{\\text{total}}=1.5$, $N_0=7000$, $\\delta=0.05$, $\\varepsilon=0.04$, $K=16$, $m_0=0.8$, $s_0=0.2$, seed $=24680$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是用例 $i$ 的 $p_{\\text{leak}}(\\tau)$，以逆虚时单位表示的浮点数。",
            "solution": "用户提供的问题是有效的。它在计算量子物理学的原理，特别是辅助场量子蒙特卡洛 (AFQMC) 方法上具有科学依据。该问题是适定的，所有必要的参数、初始条件和算法规则都已明确定义。其语言客观且无歧义，描述了一个标准的（尽管是简化的）数值模拟。\n\n该问题要求实现一个模拟，用以计算“泄露概率”（$p_{\\text{leak}}$），这是约束路径QMC中的一个诊断量。此量度量了在没有为控制费米子符号问题而施加的约束时，代表量子粒子的行走子穿越节面的速率。\n\n解决方案是通过对经历一维漂移-扩散过程的行走子布居进行蒙特卡洛模拟来实现的。\n\n**1. 物理和数学模型**\n\n模拟的核心是行走子的虚时传播，其位置 $x$ 根据朗之万方程演化。对于单个时间步长 $\\Delta\\tau$ 的离散形式由一个提议移动给出：\n$$\nx_{n+1}^{\\text{prop}} = x_n + \\mu\\,\\Delta\\tau + \\sqrt{2D\\Delta\\tau}\\,\\eta_n\n$$\n此处，$x_n$ 是行走子在时间步 $n$ 的位置，$\\mu$ 是漂移速度，$D$ 是扩散系数，$\\eta_n$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的随机数。该方程模拟了行走子的漂移和随机扩散。\n\n约束路径近似是一个关键要素。节面定义在 $x=0$ 处。为了防止行走子穿越该表面（这会在完整的AFQMC计算中导致符号问题不稳定性），任何落入禁区 $x  \\delta$ 的提议移动 $x_{n+1}^{\\text{prop}}$ 都会导致该行走子被“杀死”或从模拟中移除。参数 $\\delta \\ge 0$ 定义了这个禁区的边界。\n\n**2. 模拟算法与可观测量**\n\n模拟按以下步骤进行：\n初始化一个包含 $N_0$ 个行走子的布居。它们的初始位置从正态分布 $\\mathcal{N}(m_0, s_0^2)$ 中抽取，任何小于 $\\delta$ 的位置 $x$ 都被设置为 $x = \\delta$。\n\n模拟在总虚时 $T_{\\text{total}}$ 内进行演化，对应于 $N_{\\text{steps}} = T_{\\text{total}}/\\Delta\\tau$ 个离散步。在每一步 $n$，更新两个主要量：\n\n1.  **总存活时间 ($A_{\\text{total}}$)**：这是所有行走子在模拟中度过的积分“时间”。它通过对每个时间步的贡献求和来计算：\n    $$\n    A_{\\text{total}} = \\sum_{n=0}^{N_{\\text{steps}}-1} N_{\\text{alive}}(n)\\,\\Delta\\tau\n    $$\n    其中 $N_{\\text{alive}}(n)$ 是在第 $n$ 步开始时存活的行走子数量。该量作为泄露率的归一化因子。\n\n2.  **总穿越计数 ($C_{\\text{total}}$)**：它度量了穿越节面 $x=0$ 的提议移动的总加权数。它是无约束穿越趋势的一个估计量。单个提议移动穿越的指示函数是 $\\mathbf{1}\\{x_{n+1}^{\\text{prop}}  0\\}$。\n\n最终的可观测量，即单位时间泄露概率，是这两个量的比值：\n$$\np_{\\text{leak}}(\\tau) = \\frac{C_{\\text{total}}}{A_{\\text{total}}}\n$$\n定义了一个特殊情况，即如果 $A_{\\text{total}}=0$，那么 $p_{\\text{leak}}(\\tau)=0$。\n\n**3. 用于方差缩减的分裂估计量**\n\n因为穿越 $x=0$ 表面可能是稀有事件（例如，当漂移 $\\mu$ 为大正数时），对 $C_{\\text{total}}$ 的直接估计会有很高的统计方差。为解决此问题，采用分裂（或克隆）方法作为一种方差缩减技术。\n\n行走子根据其位置 $x_n$ 被划分为两组：\n\n-   **普通区域 ($x_n \\ge \\delta + \\varepsilon$)**：对于远离约束边界的行走子，使用标准传播。生成单个提议移动 $x_{n+1}^{\\text{prop}}$。穿越指示函数 $\\mathbf{1}\\{x_{n+1}^{\\text{prop}}  0\\}$ 以权重 $1$ 添加到 $C_{\\text{total}}$。\n\n-   **分裂区域 ($x_n \\in [\\delta, \\delta+\\varepsilon)$)**：对于边界附近的行走子，统计量被放大。对于该区域中的每个行走子，从相同位置 $x_n$ 生成 $K$ 个独立的提议移动 $\\{x_{n+1}^{\\text{prop},(j)}\\}_{j=1}^K$。对 $C_{\\text{total}}$ 的贡献是这 $K$ 个提议移动的指示函数的平均值：\n    $$\n    \\Delta C_{\\text{total}} = \\frac{1}{K}\\sum_{j=1}^{K}\\mathbf{1}\\{x_{n+1}^{\\text{prop},(j)}0\\}\n    $$\n    这会从位置 $x_n$ 产生一个更稳定、方差更低的穿越概率估计值。\n\n为确保行走子的实际路径保持为原始动力学的一个无偏样本，从 $K$ 个提议移动中随机均匀地选择一个作为该行走子的“真实”提议。然后将这个选定的提议移动置于约束规则下：如果它小于 $\\delta$，行走子被杀死；否则，其位置被更新。\n\n**4. 实现**\n\n该算法使用 Python 的 `numpy` 库实现，以进行高效的向量化操作。为每个测试用例运行一个单独的模拟。\n- 对于每个用例，使用指定的种子实例化一个新的随机数生成器 `numpy.random.default_rng`，以确保可复现性。\n- 行走子布居存储在一个 NumPy 数组中。一个布尔掩码数组 `alive_mask` 跟踪哪些行走子是活跃的。\n- 在每个时间步中，使用布尔索引将行走子划分为“分裂”组和“普通”组。\n- 使用向量化算术同时为每组中的所有行走子生成提议移动。\n- 更新估计量 $A_{\\text{total}}$ 和 $C_{\\text{total}}$。\n- 根据约束提议的结果更新 `alive_mask` 和行走子位置数组。\n- 如果所有行走子都被杀死或在完成 $N_{\\text{steps}}$ 步后，循环终止。\n- 最后，计算并存储 $p_{\\text{leak}}(\\tau)$。然后将所有测试用例的结果按要求格式化并打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    def run_simulation(mu, D, delta_tau, T_total, N0, delta, epsilon, K, m0, s0, seed):\n        \"\"\"\n        Runs a single test case of the constrained-path Monte Carlo simulation.\n        \n        Args:\n            mu (float): Drift coefficient.\n            D (float): Diffusion coefficient.\n            delta_tau (float): Time step size.\n            T_total (float): Total simulation time.\n            N0 (int): Initial number of walkers.\n            delta (float): Constraint boundary.\n            epsilon (float): Width of the splitting region.\n            K (int): Splitting factor.\n            m0 (float): Mean of the initial normal distribution.\n            s0 (float): Standard deviation of the initial normal distribution.\n            seed (int): Seed for the random number generator.\n            \n        Returns:\n            float: The calculated leakage probability per unit time, p_leak.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        # Simulation parameters\n        try:\n            num_steps = int(round(T_total / delta_tau))\n        except ZeroDivisionError:\n            num_steps = 0\n            \n        prop_std_dev = np.sqrt(2 * D * delta_tau)\n\n        # Initialize walkers\n        # Draw from N(m0, s0^2) and apply truncation: if x  delta, set x = delta.\n        walkers_x = rng.normal(loc=m0, scale=s0, size=N0)\n        walkers_x[walkers_x  delta] = delta\n\n        alive_mask = np.ones(N0, dtype=bool)\n\n        # Accumulators\n        C_total = 0.0\n        A_total = 0.0\n\n        # Main simulation loop\n        for _ in range(num_steps):\n            N_alive = np.sum(alive_mask)\n            if N_alive == 0:\n                break\n            \n            A_total += N_alive * delta_tau\n\n            # Get indices and positions of alive walkers\n            alive_indices = np.where(alive_mask)[0]\n            x_n = walkers_x[alive_indices]\n\n            # Partition alive walkers into splitting and normal regions\n            # Splitting region: [delta, delta + epsilon)\n            split_region_mask = (x_n >= delta)  (x_n  delta + epsilon)\n            # Normal region: [delta + epsilon, infinity)\n            normal_region_mask = ~split_region_mask\n\n            # Get global indices for each group\n            split_indices_global = alive_indices[split_region_mask]\n            normal_indices_global = alive_indices[normal_region_mask]\n\n            # --- Process splitting group ---\n            num_split = len(split_indices_global)\n            if num_split > 0:\n                x_split = walkers_x[split_indices_global]\n                \n                # Generate K proposals for each walker\n                eta_split = rng.standard_normal(size=(num_split, K))\n                x_prop_split = x_split[:, np.newaxis] + mu * delta_tau + prop_std_dev * eta_split\n\n                # Update C_total with weighted indicators (crossing x=0)\n                C_total += np.sum(x_prop_split  0) / K\n\n                # Uniformly select one proposal per walker for propagation\n                chosen_indices = rng.integers(0, K, size=num_split)\n                x_next_prop_split = x_prop_split[np.arange(num_split), chosen_indices]\n\n                # Apply constraint (killing if x  delta) and update walker states\n                killed_mask_local = x_next_prop_split  delta\n                survived_mask_local = ~killed_mask_local\n                \n                # Update alive_mask for killed walkers\n                killed_indices_global = split_indices_global[killed_mask_local]\n                if killed_indices_global.size > 0:\n                    alive_mask[killed_indices_global] = False\n\n                # Update positions for surviving walkers\n                survived_indices_global = split_indices_global[survived_mask_local]\n                if survived_indices_global.size > 0:\n                    walkers_x[survived_indices_global] = x_next_prop_split[survived_mask_local]\n\n            # --- Process normal group ---\n            num_normal = len(normal_indices_global)\n            if num_normal > 0:\n                x_normal = walkers_x[normal_indices_global]\n\n                # Generate 1 proposal per walker\n                eta_normal = rng.standard_normal(size=num_normal)\n                x_prop_normal = x_normal + mu * delta_tau + prop_std_dev * eta_normal\n\n                # Update C_total with unit-weighted indicators\n                C_total += np.sum(x_prop_normal  0)\n\n                # Apply constraint and update walker states\n                killed_mask_local = x_prop_normal  delta\n                survived_mask_local = ~killed_mask_local\n\n                # Update alive_mask for killed walkers\n                killed_indices_global = normal_indices_global[killed_mask_local]\n                if killed_indices_global.size > 0:\n                    alive_mask[killed_indices_global] = False\n\n                # Update positions for surviving walkers\n                survived_indices_global = normal_indices_global[survived_mask_local]\n                if survived_indices_global.size > 0:\n                    walkers_x[survived_indices_global] = x_prop_normal[survived_mask_local]\n\n        if A_total == 0:\n            return 0.0\n        \n        p_leak = C_total / A_total\n        return p_leak\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (mu, D, delta_tau, T_total, N0, delta, epsilon, K, m0, s0, seed)\n        (0.35, 0.12, 0.005, 2.0, 8000, 0.0, 0.04, 8, 0.8, 0.3, 12345),\n        (-0.25, 0.20, 0.01, 2.5, 6000, 0.0, 0.05, 12, 0.6, 0.25, 54321),\n        (0.20, 0.08, 0.005, 2.0, 9000, 0.03, 0.03, 20, 0.7, 0.2, 67890),\n        (0.10, 1e-6, 0.01, 1.5, 5000, 0.0, 0.02, 10, 0.9, 0.15, 13579),\n        (-0.90, 0.30, 0.005, 1.5, 7000, 0.05, 0.04, 16, 0.8, 0.2, 24680),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习将我们带到一个更高级的主题：优化约束路径方法的性能。实际应用中，简单的“硬”约束（例如，当重叠积分小于零时完全丢弃行走点）并非总是最优选择。本练习引入了“软”约束的概念，其强度可以通过一个指数 $\\gamma$ 来调节，从而在系统性误差（偏差）和统计误差（方差）之间寻找最佳平衡。通过分析一个控制良好的数学模型，你将学习如何量化均方误差 (MSE) 并找到最优的 $\\gamma$ 值。这个练习揭示了在开发和调试高级蒙特卡洛算法时，偏差-方差权衡这一核心统计学原理的实际应用。",
            "id": "3551580",
            "problem": "考虑一个用于计算核物理的辅助场量子蒙特卡洛 (AFQMC) 中所使用的路径约束近似的简化模型，其中一个独立随机行走子系综携带与选定的试探波函数之间的交叠相位。设行走子与试探波函数的交叠相位角为 $\\,\\Delta \\theta \\in [-\\pi,\\pi]\\,$（单位为弧度），并定义 $\\,c=\\cos \\Delta \\theta\\,$。施加于每个行走子的软约束权重定义为 $\\,w(c;\\gamma)=\\max(0,c)^\\gamma\\,$，其中 $\\,\\gamma \\ge 0\\,$ 是一个可调指数。目标是通过直方图 $\\,P(c)\\,$ 来诊断 $\\,c\\,$ 的分布，然后调节 $\\,\\gamma\\,$ 以平衡标量可观测量加权比率估计量中的偏差和方差。\n\n基本和核心定义：\n- 在使用路径约束或无相位近似的 AFQMC 中，复数交叠会引起相位涨落 $\\,\\Delta \\theta\\,$，而 $\\,c=\\cos \\Delta \\theta\\,$ 编码了它们的实投影。路径约束软权重 $\\,w(c;\\gamma)\\,$ 抑制了 $\\,c\\,$ 值小或为负的贡献，以控制方差，其代价是引入偏差。\n- 一个标量可观测量 $\\,\\mu\\,$ 的标准蒙特卡洛加权比率估计量使用 $\\,\\hat{\\mu}(\\gamma)=\\dfrac{\\sum_{i=1}^N w_i(\\gamma)L_i}{\\sum_{i=1}^N w_i(\\gamma)}\\,$，其中 $\\,L_i\\,$ 是每个行走子的局域能量估计值。对于大的 $\\,N\\,$ 和独立的行走子，$\\,\\hat{\\mu}(\\gamma)\\,$ 集中在 $\\,\\dfrac{\\mathbb{E}[w L]}{\\mathbb{E}[w]}\\,$ 附近，并允许一个由 $\\,\\mathrm{Var}(w L)\\,$、$\\,\\mathrm{Var}(w)\\,$ 和 $\\,\\mathrm{Cov}(w L, w)\\,$ 构建的 delta 方法方差近似。\n- 为了使问题自洽且纯数学化，假设一个生成模型，其中局域能量与 $\\,c\\,$ 线性相关，并具有独立的加性噪声：$\\,L=\\mu+\\kappa_L c+\\eta\\,$，其中 $\\,\\eta\\,$ 是一个均值为零、方差为 $\\,\\sigma^2\\,$ 的噪声项，且独立于 $\\,c\\,$。\n\n需要实现的任务：\n1.  为每个测试用例生成 $\\,N\\,$ 个独立的 $\\,\\Delta \\theta\\,$ 样本（单位为弧度），计算 $\\,c=\\cos \\Delta \\theta\\,$，并在区间 $\\,[-1,1]\\,$ 上使用 $\\,M\\,$ 个等间距的箱构建一个归一化直方图 $\\,P(c)\\,$。该直方图必须产生离散的箱中心 $\\,\\{c_j\\}_{j=1}^M\\,$ 和概率 $\\,\\{p_j\\}_{j=1}^M\\,$，且满足 $\\,\\sum_{j=1}^M p_j=1\\,$。\n2.  对于一个 $\\,\\gamma\\,$ 值的网格，仅使用基于直方图的矩近似来计算比率估计量的偏差和方差。对于任何固定的 $\\,\\gamma\\,$ 并使用离散分布 $\\,\\{(c_j,p_j)\\}\\,$，定义\n    $$w_j(\\gamma)=\\max(0,c_j)^\\gamma,\\quad \\mathbb{E}[w]=\\sum_{j=1}^M p_j\\,w_j,\\quad \\mathbb{E}[wc]=\\sum_{j=1}^M p_j\\,w_j\\,c_j,$$\n    $$\\mathbb{E}[wL]=\\mu\\,\\mathbb{E}[w]+\\kappa_L\\,\\mathbb{E}[wc],$$\n    $$\\mathbb{E}[w^2]=\\sum_{j=1}^M p_j\\,w_j^2,\\quad \\mathbb{E}[w^2L]=\\sum_{j=1}^M p_j\\,w_j^2\\left(\\mu+\\kappa_L c_j\\right),$$\n    $$\\mathbb{E}[w^2L^2]=\\sum_{j=1}^M p_j\\,w_j^2\\left[\\left(\\mu+\\kappa_L c_j\\right)^2+\\sigma^2\\right].$$\n    那么，偏差和方差的近似为\n    $$\\mathrm{bias}(\\gamma)=\\frac{\\mathbb{E}[wL]}{\\mathbb{E}[w]}-\\mu=\\kappa_L\\frac{\\mathbb{E}[wc]}{\\mathbb{E}[w]},$$\n    $$\\mathrm{Var}(wL)=\\mathbb{E}[w^2L^2]-\\left(\\mathbb{E}[wL]\\right)^2,\\quad \\mathrm{Var}(w)=\\mathbb{E}[w^2]-\\left(\\mathbb{E}[w]\\right)^2,$$\n    $$\\mathrm{Cov}(wL,w)=\\mathbb{E}[w^2L]-\\mathbb{E}[wL]\\,\\mathbb{E}[w].$$\n    对比率估计量使用 delta 方法，其中 $\\,A=\\frac{1}{N}\\sum w_i L_i\\,$ 且 $\\,B=\\frac{1}{N}\\sum w_i\\,$，而 $\\,a=\\mathbb{E}[wL]\\,$ 且 $\\,b=\\mathbb{E}[w]\\,$，方差近似为\n    $$\\mathrm{Var}\\left(\\hat{\\mu}(\\gamma)\\right)\\approx \\frac{1}{N}\\left[\\frac{\\mathrm{Var}(wL)}{b^2}+\\frac{a^2}{b^4}\\mathrm{Var(w)}-\\frac{2a}{b^3}\\mathrm{Cov}(wL,w)\\right].$$\n    均方误差则为\n    $$\\mathrm{MSE}(\\gamma)=\\left[\\mathrm{bias}(\\gamma)\\right]^2+\\mathrm{Var}\\left(\\hat{\\mu}(\\gamma)\\right).$$\n3.  对于每个测试用例，在指定的网格上扫描 $\\,\\gamma\\,$，并选择使 $\\,\\mathrm{MSE}(\\gamma)\\,$ 最小化的值。如果在数值精度范围内，有多个 $\\,\\gamma\\,$ 值产生相同的最小 $\\,\\mathrm{MSE}(\\gamma)\\,$，则选择其中最小的 $\\,\\gamma\\,$。\n4.  角度必须以弧度处理。输出没有物理单位，但最终的 $\\,\\gamma\\,$ 值必须表示为四舍五入到两位小数的浮点数。\n\n测试套件和参数：\n- 用例 $\\,1\\,$ (理想情况，中等集中的相位)：$\\,N=200000\\,$ 个行走子；$\\,\\Delta \\theta\\,$ 从均值为 $\\,0\\,$、集中度为 $\\,\\kappa_\\theta=8.0\\,$ 的 von Mises 分布中抽样；$\\,\\mu=1.5\\,$；$\\,\\kappa_L=0.8\\,$；$\\,\\sigma=0.7\\,$；$\\,M=200\\,$ 个箱；$\\,\\gamma\\,$ 从 $\\,0.0\\,$ 扫描到 $\\,6.0\\,$，步长为 $\\,0.25\\,$。\n- 用例 $\\,2\\,$ (边缘情况，均匀相位)：$\\,N=200000\\,$ 个行走子；$\\,\\Delta \\theta\\,$ 在 $\\,[-\\pi,\\pi]\\,$ 上均匀分布；$\\,\\mu=0.0\\,$；$\\,\\kappa_L=0.5\\,$；$\\,\\sigma=1.5\\,$；$\\,M=200\\,$ 个箱；$\\,\\gamma\\,$ 从 $\\,0.0\\,$ 扫描到 $\\,6.0\\,$，步长为 $\\,0.25\\,$。\n- 用例 $\\,3\\,$ (高噪声，弱相关)：$\\,N=200000\\,$ 个行走子；$\\,\\Delta \\theta\\,$ 从均值为 $\\,0\\,$、集中度为 $\\,\\kappa_\\theta=1.5\\,$ 的 von Mises 分布中抽样；$\\,\\mu=2.0\\,$；$\\,\\kappa_L=0.3\\,$；$\\,\\sigma=3.0\\,$；$\\,M=200\\,$ 个箱；$\\,\\gamma\\,$ 从 $\\,0.0\\,$ 扫描到 $\\,6.0\\,$，步长为 $\\,0.25\\,$。\n- 用例 $\\,4\\,$ (符号具有挑战性的相关性)：$\\,N=200000\\,$ 个行走子；$\\,\\Delta \\theta\\,$ 在 $\\,[-\\pi,\\pi]\\,$ 上均匀分布；$\\,\\mu=-1.0\\,$；$\\,\\kappa_L=-0.6\\,$；$\\,\\sigma=1.0\\,$；$\\,M=200\\,$ 个箱；$\\,\\gamma\\,$ 从 $\\,0.0\\,$ 扫描到 $\\,6.0\\,$，步长为 $\\,0.25\\,$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含四个测试用例的最优指数 $\\,\\gamma^\\star\\,$，以逗号分隔的列表形式，并用方括号括起来，每个值四舍五入到两位小数，例如 $\\,\\left[\\gamma^\\star_1,\\gamma^\\star_2,\\gamma^\\star_3,\\gamma^\\star_4\\right]\\,$。输出中没有物理单位。",
            "solution": "该问题要求找到最优的软约束指数（记为 $\\,\\gamma^\\star\\,$），以最小化在一个简化的辅助场量子蒙特卡洛 (AFQMC) 模型中标量可观测量的加权比率估计量的均方误差 (MSE)。MSE 代表总误差，它结合了估计量的偏差平方和方差。优化过程涉及一个权衡：增加 $\\,\\gamma\\,$ 通常通过抑制噪声贡献来降低方差，但可能会引入系统偏差。\n\n对于每个测试用例，解决方案按部就班地遵循指定的任务：\n1.  生成底层统计分布。\n2.  使用离散直方图表示来计算统计矩。\n3.  为一系列 $\\,\\gamma\\,$ 值计算偏差、方差和 MSE。\n4.  确定最小化 MSE 的最优 $\\,\\gamma^\\star\\,$。\n\n**步骤 1：模拟与直方图构建**\n\n第一步是对行走子-试探波函数交叠投影 $\\,c = \\cos \\Delta \\theta\\,$ 的分布进行建模。对于每个测试用例，我们从其指定的分布（von Mises 分布或均匀分布）中生成 $\\,N\\,$ 个相位角 $\\,\\Delta \\theta\\,$ 的样本。\n- 对于均值为 $\\,\\mu_\\theta=0\\,$ 且集中度为 $\\,\\kappa_\\theta\\,$ 的 von Mises 分布，样本从 $\\,\\mathrm{VM}(0, \\kappa_\\theta)\\,$ 中抽取。\n- 对于均匀分布，样本从 $\\,\\mathrm{Unif}[-\\pi, \\pi]\\,$ 中抽取。\n\n从这 $\\,N\\,$ 个 $\\,\\Delta \\theta_i\\,$ 样本中，我们计算 $\\,c_i = \\cos \\Delta \\theta_i\\,$。为了使用 $\\,c\\,$ 的概率分布（记为 $\\,P(c)\\,$）的离散表示，我们构建一个归一化直方图。区间 $\\,[-1, 1]\\,$ 被划分为 $\\,M\\,$ 个等间距的箱。直方图产生一组箱中心 $\\,\\{c_j\\}_{j=1}^M\\,$ 及其对应的概率 $\\,\\{p_j\\}_{j=1}^M\\,$。概率 $\\,p_j\\,$ 是 $\\,N\\,$ 个样本中落入第 $\\,j\\,$ 个箱的比例。根据构造，$\\,\\sum_{j=1}^M p_j = 1\\,$。\n\n**步骤 2：基于直方图的矩的计算**\n\n分析的核心在于使用离散概率分布 $\\,\\{(c_j, p_j)\\}_{j=1}^M\\,$ 计算各种期望值（矩）。这些矩是指数 $\\,\\gamma\\,$ 的函数。每个箱中心 $\\,c_j\\,$ 的软约束权重定义为 $\\,w_j(\\gamma) = \\max(0, c_j)^\\gamma\\,$。注意，对于 $\\,\\gamma=0\\,$，使用约定 $\\,0^0=1\\,$，使得对于所有 $\\,j\\,$，$\\,w_j(0) = 1\\,$。\n\n使用离散分布，任何期望 $\\,\\mathbb{E}[f(c)]\\,$ 都通过求和 $\\,\\sum_{j=1}^M p_j f(c_j)\\,$ 来近似。我们计算偏差和方差公式所需的以下矩：\n- $\\,\\mathbb{E}[w] = \\sum_{j=1}^M p_j w_j(\\gamma)\\,$\n- $\\,\\mathbb{E}[wc] = \\sum_{j=1}^M p_j w_j(\\gamma) c_j\\,$\n- $\\,\\mathbb{E}[w^2] = \\sum_{j=1}^M p_j \\left(w_j(\\gamma)\\right)^2\\,$\n\n局域能量 $\\,L\\,$ 被建模为 $\\,L = \\mu + \\kappa_L c + \\eta\\,$，其中 $\\,\\eta\\,$ 是具有 $\\,\\mathbb{E}[\\eta]=0\\,$ 和 $\\,\\mathbb{E}[\\eta^2]=\\sigma^2\\,$ 的独立噪声。涉及 $\\,L\\,$ 的矩是通过利用 $\\,\\eta\\,$ 独立于 $\\,c\\,$（因此也独立于 $\\,w\\,$）的性质导出的：\n- $\\,\\mathbb{E}[wL] = \\mathbb{E}[w(\\mu + \\kappa_L c + \\eta)] = \\mu\\mathbb{E}[w] + \\kappa_L\\mathbb{E}[wc] + \\mathbb{E}[w]\\mathbb{E}[\\eta] = \\mu\\mathbb{E}[w] + \\kappa_L\\mathbb{E}[wc]\\,$.\n- $\\,\\mathbb{E}[w^2L] = \\mathbb{E}[w^2(\\mu + \\kappa_L c + \\eta)] = \\mu\\mathbb{E}[w^2] + \\kappa_L\\mathbb{E}[w^2c]\\,$, 其中 $\\,\\mathbb{E}[w^2c] = \\sum_{j=1}^M p_j (w_j(\\gamma))^2 c_j\\,$.\n- $\\,\\mathbb{E}[w^2L^2] = \\mathbb{E}[w^2(\\mu + \\kappa_L c + \\eta)^2] = \\mathbb{E}[w^2((\\mu + \\kappa_L c)^2 + 2\\eta(\\mu+\\kappa_L c) + \\eta^2)]\\,$. 取期望并使用 $\\,\\mathbb{E}[\\eta]=0\\,$ 将此简化为 $\\,\\mathbb{E}[w^2((\\mu + \\kappa_L c)^2 + \\sigma^2)]\\,$。在我们的离散形式中，这变为 $\\,\\mathbb{E}[w^2L^2] = \\sum_{j=1}^M p_j (w_j(\\gamma))^2 \\left[ (\\mu + \\kappa_L c_j)^2 + \\sigma^2 \\right]\\,$。\n\n**步骤 3：偏差、方差和 MSE 的计算**\n\n在为给定的 $\\,\\gamma\\,$ 计算出必要的矩之后，我们现在可以评估比率估计量 $\\,\\hat{\\mu}(\\gamma)\\,$ 的偏差和方差。\n\n偏差由以下公式给出：\n$$\n\\mathrm{bias}(\\gamma) = \\frac{\\mathbb{E}[wL]}{\\mathbb{E}[w]} - \\mu = \\kappa_L \\frac{\\mathbb{E}[wc]}{\\mathbb{E}[w]}\n$$\n该项量化了由加权方案引入的系统误差。\n\n估计量的方差 $\\,\\mathrm{Var}(\\hat{\\mu}(\\gamma))\\,$，使用 delta 方法对两个随机变量 $\\,A = \\frac{1}{N}\\sum w_i L_i\\,$ 和 $\\,B = \\frac{1}{N}\\sum w_i\\,$ 的比率进行近似。首先，我们计算底层量 $\\,w\\,$ 和 $\\,wL\\,$ 的方差和协方差：\n- $\\,\\mathrm{Var}(w) = \\mathbb{E}[w^2] - (\\mathbb{E}[w])^2\\,$\n- $\\,\\mathrm{Var}(wL) = \\mathbb{E}[w^2L^2] - (\\mathbb{E}[wL])^2\\,$\n- $\\,\\mathrm{Cov}(wL, w) = \\mathbb{E}[w^2L] - \\mathbb{E}[wL]\\mathbb{E}[w]\\,$\n\n令 $\\,a = \\mathbb{E}[wL]\\,$ 和 $\\,b = \\mathbb{E}[w]\\,$，估计量方差为：\n$$\n\\mathrm{Var}(\\hat{\\mu}(\\gamma)) \\approx \\frac{1}{N} \\left[ \\frac{\\mathrm{Var}(wL)}{b^2} + \\frac{a^2}{b^4}\\mathrm{Var}(w) - \\frac{2a}{b^3}\\mathrm{Cov}(wL, w) \\right]\n$$\n该项量化了估计量的统计不确定性（噪声）。\n\n最后，均方误差 (MSE) 是偏差平方和方差之和：\n$$\n\\mathrm{MSE}(\\gamma) = \\left[\\mathrm{bias}(\\gamma)\\right]^2 + \\mathrm{Var}(\\hat{\\mu}(\\gamma))\n$$\n\n**步骤 4：指数 $\\,\\gamma\\,$ 的优化**\n\n对于每个测试用例，流程是在指定的网格上（从 $\\,0.0\\,$ 到 $\\,6.0\\,$，步长为 $\\,0.25\\,$）为每个 $\\,\\gamma\\,$ 值计算 $\\,\\mathrm{MSE}(\\gamma)\\,$。然后，我们确定产生最小 MSE 的值 $\\,\\gamma^\\star\\,$。根据问题的平局决胜规则，如果多个 $\\,\\gamma\\,$ 值产生相同的最小 MSE，则选择其中最小的值作为 $\\,\\gamma^\\star\\,$。对所有四个测试用例重复此过程，并收集得到的最优指数。该实现利用 `numpy` 对直方图数据进行高效的向量化操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import vonmises\n\ndef solve():\n    \"\"\"\n    Solves the AFQMC constrained-path approximation problem for four test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 200000, \"dist\": \"vonmises\", \"kappa_theta\": 8.0,\n            \"mu\": 1.5, \"kappa_L\": 0.8, \"sigma\": 0.7, \"M\": 200,\n            \"gamma_min\": 0.0, \"gamma_max\": 6.0, \"gamma_step\": 0.25\n        },\n        {\n            \"N\": 200000, \"dist\": \"uniform\", \"kappa_theta\": None,\n            \"mu\": 0.0, \"kappa_L\": 0.5, \"sigma\": 1.5, \"M\": 200,\n            \"gamma_min\": 0.0, \"gamma_max\": 6.0, \"gamma_step\": 0.25\n        },\n        {\n            \"N\": 200000, \"dist\": \"vonmises\", \"kappa_theta\": 1.5,\n            \"mu\": 2.0, \"kappa_L\": 0.3, \"sigma\": 3.0, \"M\": 200,\n            \"gamma_min\": 0.0, \"gamma_max\": 6.0, \"gamma_step\": 0.25\n        },\n        {\n            \"N\": 200000, \"dist\": \"uniform\", \"kappa_theta\": None,\n            \"mu\": -1.0, \"kappa_L\": -0.6, \"sigma\": 1.0, \"M\": 200,\n            \"gamma_min\": 0.0, \"gamma_max\": 6.0, \"gamma_step\": 0.25\n        },\n    ]\n\n    optimal_gammas = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        M = case[\"M\"]\n        mu = case[\"mu\"]\n        kappa_L = case[\"kappa_L\"]\n        sigma = case[\"sigma\"]\n\n        # Step 1: Generate samples and construct histogram\n        if case[\"dist\"] == \"vonmises\":\n            delta_theta = vonmises.rvs(kappa=case[\"kappa_theta\"], loc=0, size=N)\n        elif case[\"dist\"] == \"uniform\":\n            delta_theta = np.random.uniform(-np.pi, np.pi, size=N)\n        \n        c = np.cos(delta_theta)\n        \n        counts, bin_edges = np.histogram(c, bins=M, range=(-1.0, 1.0))\n        p_j = counts / N\n        c_j = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n        \n        min_mse = np.inf\n        optimal_gamma = -1.0\n        \n        gamma_grid = np.arange(case[\"gamma_min\"], case[\"gamma_max\"] + case[\"gamma_step\"], case[\"gamma_step\"])\n\n        # Steps 2  3: Iterate through gamma grid, calculate MSE\n        for gamma in gamma_grid:\n            # Calculate weights w_j\n            w_j = np.maximum(0, c_j)**gamma\n\n            # Calculate moments\n            E_w = np.sum(p_j * w_j)\n            \n            # If E[w] is zero, this gamma is invalid, continue.\n            if E_w == 0:\n                continue\n\n            E_wc = np.sum(p_j * w_j * c_j)\n            \n            E_w2 = np.sum(p_j * w_j**2)\n            E_w2c = np.sum(p_j * w_j**2 * c_j)\n            \n            # Moments involving L\n            E_wL = mu * E_w + kappa_L * E_wc\n            E_w2L = mu * E_w2 + kappa_L * E_w2c\n            \n            Lj_part_sq = (mu + kappa_L * c_j)**2\n            E_w2L2 = np.sum(p_j * w_j**2 * (Lj_part_sq + sigma**2))\n\n            # Calculate bias\n            bias_gamma = kappa_L * (E_wc / E_w)\n            \n            # Calculate variances and covariance\n            Var_w = E_w2 - E_w**2\n            Var_wL = E_w2L2 - E_wL**2\n            Cov_wL_w = E_w2L - E_wL * E_w\n\n            # Calculate variance of the estimator using delta method\n            a = E_wL\n            b = E_w\n            \n            # To avoid division by zero if b (E[w]) is extremely small\n            if b  1e-15: continue\n            \n            var_mu_hat_term1 = Var_wL / b**2\n            var_mu_hat_term2 = (a**2 / b**4) * Var_w\n            var_mu_hat_term3 = (2 * a / b**3) * Cov_wL_w\n            \n            var_mu_hat = (1/N) * (var_mu_hat_term1 + var_mu_hat_term2 - var_mu_hat_term3)\n\n            # Calculate MSE\n            mse = bias_gamma**2 + var_mu_hat\n            \n            # Step 4: Find optimal gamma\n            if mse  min_mse:\n                min_mse = mse\n                optimal_gamma = gamma\n\n        optimal_gammas.append(optimal_gamma)\n\n    # Format the final output\n    formatted_results = [f\"{g:.2f}\" for g in optimal_gammas]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}