{
    "hands_on_practices": [
        {
            "introduction": "在深入研究含时哈特里-福克（TDHF）理论的动力学之前，我们必须首先牢固掌握其静态基础。TDHF的核心思想是使用单个斯莱特行列式来近似描述一个多体量子系统。这项基础练习将指导您从构成斯莱特行列式的单粒子轨道出发，推导出单体密度矩阵和局域粒子密度等关键物理量，这是理解多体波函数与可观测量之间联系的基石。",
            "id": "3609611",
            "problem": "考虑一个由 $A$ 个核子组成的系统，在含时哈特里-福克 (TDHF) 理论的描述下，其在给定时间的多体状态由一个单一的斯莱特行列式近似，该行列式由 $A$ 个正交归一的自旋-同位旋轨道 $\\{\\phi_{i}(\\mathbf{r}\\sigma\\tau)\\}_{i=1}^{A}$ 构建。这里 $\\mathbf{r} \\in \\mathbb{R}^{3}$ 是空间坐标，$\\sigma \\in \\{\\uparrow,\\downarrow\\}$ 是自旋投影，$\\tau \\in \\{p,n\\}$ 是同位旋标记（质子或中子）。这些轨道满足正交归一性条件\n$$\n\\sum_{\\sigma,\\tau}\\int d^{3}r\\, \\phi_{i}^{*}(\\mathbf{r}\\sigma\\tau)\\,\\phi_{j}(\\mathbf{r}\\sigma\\tau) \\;=\\; \\delta_{ij}.\n$$\n  \n从全同费米子的反对称化公设和第一量子化中斯莱特行列式的定义出发，构建归一化的 $A$ 体波函数 $\\Psi(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{A})$，其中 $\\mathbf{x}\\equiv(\\mathbf{r},\\sigma,\\tau)$。使用第一量子化中单体密度矩阵的基本定义，\n$$\n\\rho(\\mathbf{x},\\mathbf{x}') \\;=\\; A \\sum_{\\sigma_{2},\\tau_{2}}\\cdots \\sum_{\\sigma_{A},\\tau_{A}} \\int d^{3}r_{2}\\cdots d^{3}r_{A}\\;\\Psi(\\mathbf{x},\\mathbf{x}_{2},\\ldots,\\mathbf{x}_{A})\\,\\Psi^{*}(\\mathbf{x}',\\mathbf{x}_{2},\\ldots,\\mathbf{x}_{A}),\n$$\n推导单体密度矩阵 $\\rho(\\mathbf{r}\\sigma\\tau,\\mathbf{r}'\\sigma'\\tau')$ 以占据轨道 $\\{\\phi_{i}\\}$ 表示的闭式表达式。然后求出局域粒子密度\n$$\nn(\\mathbf{r}) \\;=\\; \\sum_{\\sigma,\\tau}\\,\\rho(\\mathbf{r}\\sigma\\tau,\\mathbf{r}\\sigma\\tau),\n$$\n以 $\\{\\phi_{i}\\}$ 表示的闭式表达式。将两个结果都表示为解析表达式；不需要进行数值计算。最终答案必须以解析表达式的形式给出，并且不需要单位。",
            "solution": "问题陈述在多体量子力学框架内，特别是在使用哈特里-福克近似的非相对论核结构理论中，是一个适定且标准的推导。所有给定条件在科学上都是合理的，并且是相互一致的。诸如斯莱特行列式、单体密度矩阵和粒子密度等概念是该领域的基础。未发现任何缺陷。因此，该问题是有效的，我将进行完整的推导。\n\n问题要求推导一个由 $A$ 个核子组成的系统的单体密度矩阵 $\\rho$ 和局域粒子密度 $n(\\mathbf{r})$。该系统的波函数由一个斯莱特行列式近似，该行列式由一组 $A$ 个正交归一的单粒子轨道 $\\{\\phi_{i}(\\mathbf{x})\\}_{i=1}^{A}$ 构建。复合坐标 $\\mathbf{x}$ 定义为 $\\mathbf{x} \\equiv (\\mathbf{r},\\sigma,\\tau)$，其中 $\\mathbf{r}$ 是空间位置，$\\sigma$ 是自旋投影，$\\tau$ 是同位旋投影。\n\n我们将对这个复合坐标的积分定义为 $\\int d\\mathbf{x} \\equiv \\sum_{\\sigma,\\tau}\\int d^{3}r$。这样，轨道的正交归一性条件可以紧凑地写为：\n$$\n\\int \\phi_{i}^{*}(\\mathbf{x})\\phi_{j}(\\mathbf{x}) \\, d\\mathbf{x} = \\delta_{ij}\n$$\n\n第一步是构建经过恰当反对称化和归一化的 $A$ 体波函数 $\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A})$。在第一量子化中，这由占据的单粒子轨道的斯莱特行列式给出：\n$$\n\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}}\n\\begin{vmatrix}\n\\phi_{1}(\\mathbf{x}_{1})  \\phi_{2}(\\mathbf{x}_{1})  \\cdots  \\phi_{A}(\\mathbf{x}_{1}) \\\\\n\\phi_{1}(\\mathbf{x}_{2})  \\phi_{2}(\\mathbf{x}_{2})  \\cdots  \\phi_{A}(\\mathbf{x}_{2}) \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\phi_{1}(\\mathbf{x}_{A})  \\phi_{2}(\\mathbf{x}_{A})  \\cdots  \\phi_{A}(\\mathbf{x}_{A})\n\\end{vmatrix}\n$$\n因子 $1/\\sqrt{A!}$ 确保波函数归一化为1，即 $\\int |\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A})|^2 d\\mathbf{x}_{1}\\cdots d\\mathbf{x}_{A} = 1$，这是轨道 $\\{\\phi_i\\}$ 正交归一性的直接结果。该行列式可以用对称群 $S_A$ 中所有置换 $P$ 的和来表示：\n$$\n\\Psi(\\mathbf{x}_{1}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}} \\sum_{P \\in S_A} \\text{sgn}(P) \\prod_{i=1}^{A} \\phi_{P(i)}(\\mathbf{x}_{i})\n$$\n其中 $\\text{sgn}(P)$ 是置换 $P$ 的符号。\n\n接下来，我们推导单体密度矩阵 $\\rho(\\mathbf{x}, \\mathbf{x}')$。给出的定义是：\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = A \\int \\Psi(\\mathbf{x}, \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) \\Psi^{*}(\\mathbf{x}', \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) \\, d\\mathbf{x}_{2} \\cdots d\\mathbf{x}_{A}\n$$\n我们将斯莱特行列式表达式代入 $\\Psi$ 和 $\\Psi^*$。注意 $\\Psi$ 的自变量是 $(\\mathbf{x}, \\mathbf{x}_2, \\ldots, \\mathbf{x}_A)$，而 $\\Psi^*$ 的自变量是 $(\\mathbf{x}', \\mathbf{x}_2, \\ldots, \\mathbf{x}_A)$。\n$$\n\\Psi(\\mathbf{x}, \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}} \\sum_{P \\in S_A} \\text{sgn}(P) \\, \\phi_{P(1)}(\\mathbf{x}) \\prod_{i=2}^{A} \\phi_{P(i)}(\\mathbf{x}_{i})\n$$\n$$\n\\Psi^{*}(\\mathbf{x}', \\mathbf{x}_{2}, \\ldots, \\mathbf{x}_{A}) = \\frac{1}{\\sqrt{A!}} \\sum_{Q \\in S_A} \\text{sgn}(Q) \\, \\phi_{Q(1)}^{*}(\\mathbf{x}') \\prod_{j=2}^{A} \\phi_{Q(j)}^{*}(\\mathbf{x}_{j})\n$$\n将这些代入 $\\rho(\\mathbf{x}, \\mathbf{x}')$ 的定义中：\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = \\frac{A}{A!} \\sum_{P, Q \\in S_A} \\text{sgn}(P)\\text{sgn}(Q) \\, \\phi_{P(1)}(\\mathbf{x}) \\phi_{Q(1)}^{*}(\\mathbf{x}') \\int \\left( \\prod_{i=2}^{A} \\phi_{P(i)}(\\mathbf{x}_{i}) \\right) \\left( \\prod_{j=2}^{A} \\phi_{Q(j)}^{*}(\\mathbf{x}_{j}) \\right) d\\mathbf{x}_{2} \\cdots d\\mathbf{x}_{A}\n$$\n积分可以对每个粒子坐标分开：\n$$\n\\int \\cdots d\\mathbf{x}_{2} \\cdots d\\mathbf{x}_{A} = \\int \\phi_{P(2)}(\\mathbf{x}_{2})\\phi_{Q(2)}^{*}(\\mathbf{x}_{2}) d\\mathbf{x}_{2} \\cdots \\int \\phi_{P(A)}(\\mathbf{x}_{A})\\phi_{Q(A)}^{*}(\\mathbf{x}_{A}) d\\mathbf{x}_{A}\n$$\n利用轨道的正交归一性，$\\int \\phi_{k}^{*}(\\mathbf{z})\\phi_{l}(\\mathbf{z}) d\\mathbf{z} = \\delta_{kl}$，这个积分的乘积变为：\n$$\n\\delta_{P(2), Q(2)} \\delta_{P(3), Q(3)} \\cdots \\delta_{P(A), Q(A)} = \\prod_{k=2}^{A} \\delta_{P(k), Q(k)}\n$$\n只有当轨道指标序列 $(P(2), P(3), \\ldots, P(A))$ 与序列 $(Q(2), Q(3), \\ldots, Q(A))$ 完全相同时，这个乘积才非零（等于 $1$）。由于 $P$ 和 $Q$ 都是集合 $\\{1, 2, \\ldots, A\\}$ 的置换，这个条件意味着剩余的指标也必须相等，即 $P(1) = Q(1)$。因此，对 $P$ 和 $Q$ 的双重求和简化为 $P = Q$ 的单个求和。当 $P = Q$ 时，我们也有 $\\text{sgn}(P) = \\text{sgn}(Q)$，因此 $\\text{sgn}(P)\\text{sgn}(Q) = (\\text{sgn}(P))^2 = 1$。\n\n密度矩阵的表达式简化为：\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = \\frac{A}{A!} \\sum_{P \\in S_A} \\phi_{P(1)}(\\mathbf{x}) \\phi_{P(1)}^{*}(\\mathbf{x}')\n$$\n求和是对所有 $A!$ 个置换 $P$ 进行的。我们可以重新组织这个求和，首先对指标 $k = P(1)$ 的可能取值（可以是从 $1$到 $A$ 的任意整数）进行求和，然后对所有具有这个特定首元素的置换进行求和。对于任何固定的选择 $k \\in \\{1, \\ldots, A\\}$，存在 $(A-1)!$ 个置换 $P$ 使得 $P(1) = k$。对于所有这 $(A-1)!$ 个置换，项 $\\phi_{P(1)}(\\mathbf{x}) \\phi_{P(1)}^{*}(\\mathbf{x}')$ 都是相同的，即 $\\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}')$。\n所以我们可以写成：\n$$\n\\sum_{P \\in S_A} \\phi_{P(1)}(\\mathbf{x}) \\phi_{P(1)}^{*}(\\mathbf{x}') = \\sum_{k=1}^{A} \\sum_{\\substack{P \\in S_A \\\\ P(1)=k}} \\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}') = \\sum_{k=1}^{A} (A-1)! \\, \\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}')\n$$\n将此代回 $\\rho(\\mathbf{x}, \\mathbf{x}')$ 的表达式中：\n$$\n\\rho(\\mathbf{x}, \\mathbf{x}') = \\frac{A}{A!} (A-1)! \\sum_{k=1}^{A} \\phi_{k}(\\mathbf{x}) \\phi_{k}^{*}(\\mathbf{x}')\n$$\n由于 $A! = A \\times (A-1)!$，前置因子为 $\\frac{A(A-1)!}{A!} = 1$。单体密度矩阵的最终表达式为：\n$$\n\\rho(\\mathbf{r}\\sigma\\tau, \\mathbf{r}'\\sigma'\\tau') = \\sum_{i=1}^{A} \\phi_{i}(\\mathbf{r}\\sigma\\tau) \\phi_{i}^{*}(\\mathbf{r}'\\sigma'\\tau')\n$$\n\n最后，我们计算局域粒子密度 $n(\\mathbf{r})$，其定义为：\n$$\nn(\\mathbf{r}) = \\sum_{\\sigma,\\tau} \\rho(\\mathbf{r}\\sigma\\tau, \\mathbf{r}\\sigma\\tau)\n$$\n这需要将 $\\rho$ 中的坐标设置为相等，即 $\\mathbf{r}'=\\mathbf{r}$，$\\sigma'=\\sigma$，$\\tau'=\\tau$，并对自旋和同位旋自由度求和。\n$$\n\\rho(\\mathbf{r}\\sigma\\tau, \\mathbf{r}\\sigma\\tau) = \\sum_{i=1}^{A} \\phi_{i}(\\mathbf{r}\\sigma\\tau) \\phi_{i}^{*}(\\mathbf{r}\\sigma\\tau) = \\sum_{i=1}^{A} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2\n$$\n将此代入 $n(\\mathbf{r})$ 的定义中：\n$$\nn(\\mathbf{r}) = \\sum_{\\sigma,\\tau} \\left( \\sum_{i=1}^{A} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2 \\right)\n$$\n通过交换有限求和的顺序，我们得到局域粒子密度的最终表达式：\n$$\nn(\\mathbf{r}) = \\sum_{i=1}^{A} \\sum_{\\sigma,\\tau} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2\n$$\n这个结果表明，在点 $\\mathbf{r}$ 处的总粒子密度是所有占据轨道在该点的概率密度的非相干和，并对所有可能的自旋和同位旋态求和。\n\n所要求的两个结果是单体密度矩阵和局域粒子密度的解析表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\sum_{i=1}^{A} \\phi_{i}(\\mathbf{r}\\sigma\\tau) \\phi_{i}^{*}(\\mathbf{r}'\\sigma'\\tau') & \\sum_{i=1}^{A} \\sum_{\\sigma, \\tau} |\\phi_{i}(\\mathbf{r}\\sigma\\tau)|^2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "对核反应的真实模拟通常涉及粒子被系统射出的过程。简单的周期性或硬壁边界条件的数值网格无法正确模拟这类“开放”量子系统，因为它们会导致非物理性的波函数反射。本练习将介绍一种强大且常用的解决方案：复吸收势（Complex Absorbing Potential, CAP）。通过实现一个复吸收势，您将学会如何有效吸收出射的波包，防止虚假反射，从而能够模拟非束缚态的动力学过程。",
            "id": "3609650",
            "problem": "实现并验证用于一维出射单粒子波包的吸收边界条件，该波包出现在时间相关的 Hartree-Fock (TDHF) 理论的单粒子方程中。在独立粒子极限下，每个已占据的单粒子轨道根据带有自洽平均场哈密顿量的类含时薛定谔方程进行演化。在本问题中，你将考虑一个在自由空间中传播的轨道，并通过添加一个复吸收势 (Complex Absorbing Potential, CAP) 来实现吸收边界条件。该复吸收势表现为一个纯虚势，在靠近空间边界的层内衰减波函数。\n\n从基本出发点开始：一维空间中单个轨道的含时薛定谔方程，\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = \\left[ -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x) \\right] \\psi(x,t),\n$$\n其中 $m$ 是粒子质量，$V(x)$ 是一个势。在时间相关的 Hartree-Fock (TDHF) 理论的独立粒子极限下，每个已占据的单粒子轨道都遵循这个带有平均场哈密顿量的方程。为了本次计算测试的目的，采用自由平均场，使得 $V(x)$ 的实部为零，并通过复吸收势 $V_{\\mathrm{CAP}}(x) = -i \\eta(x)$ 来实现吸收边界条件，其中 $\\eta(x) \\ge 0$ 仅在边界层内非零。\n\n在自然单位制中进行计算，设 $\\hbar = 1$ 和 $m = 1$。将空间离散化到 $N$ 个点的均匀网格 $x \\in [-L,L]$ 上，并在端点处强制施加 Dirichlet 边界值。使用均匀时间步长 $\\Delta t$ 将时间离散化。使用从第一性原理推导出的时间步进格式（例如，应用于哈密顿算符的 Crank–Nicolson 格式）来传播波函数，该格式在没有吸收的情况下是无条件稳定且范数守恒的。空间二阶导数必须用均匀网格上的标准中心有限差分模板表示。复吸收势必须实现为一个纯虚势，在靠近每个边界的宽度为 $w$ 的层内平滑地开启：\n$$\n\\eta(x) = \\begin{cases}\n\\eta_0 \\left(\\dfrac{|x| - (L - w)}{w}\\right)^m,  \\text{if } |x| > L - w, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中参数 $\\eta_0 \\ge 0$，$w \\ge 0$，平滑指数 $m \\in \\{1,2,3,\\dots\\}$。如果 $w = 0$，则设 $\\eta(x) \\equiv 0$。\n\n初始化一个具有指定动能 $E_0$ 的归一化向右移动高斯波包：\n$$\n\\psi(x,0) \\propto \\exp\\!\\left(-\\frac{(x-x_0)^2}{4\\sigma^2} + i p_0 x \\right), \\quad p_0 = \\sqrt{2 E_0},\n$$\n其平均位置 $x_0$ 严格位于区域内部，宽度为 $\\sigma$，平均动量为正值 $p_0$。选择参数，使得波包向右传播，与右边界的吸收层相互作用，并且任何反射分量都能在模拟时间窗内返回其初始位置附近。在端点使用 Dirichlet 条件。\n\n定义一个以 $x_0$ 为中心、半宽为 $\\delta$ 的监视窗，并使用以下定量诊断方法来测量反射：\n$$\nR \\equiv \\frac{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,0)|^2 \\, dx},\n$$\n其中 $T$ 是最终时间，其选择要足够大，以使任何来自右边界的显著反射都有时间返回到 $x_0$ 附近。量 $R$ 是无量纲的。\n\n实现该算法，并为以下吸收层参数测试套件生成 $R$ 的数值，所有测试均在相同的波包能量下进行：\n- 空间区域半长 $L = 4$，点数 $N = 512$，时间步长 $\\Delta t = 0.002$，总时间 $T = 10.0$。\n- 初始波包参数：$x_0 = -1.0$，$\\sigma = 0.3$，$E_0 = 0.5$（因此 $p_0 = \\sqrt{2 E_0}$），监视窗半宽 $\\delta = 0.25$。\n- 吸收体参数集 $(\\eta_0, w, m)$:\n    1. $(0.0, 0.0, 2)$,\n    2. $(0.5, 1.0, 2)$,\n    3. $(2.0, 1.5, 3)$,\n    4. $(10.0, 0.25, 1)$.\n\n你的程序必须：\n- 使用应用于带有复吸收势的自由哈密顿量的 Crank-Nicolson 更新的第一性原理推导，将波包从 $t=0$ 离散化并传播到 $t=T$。\n- 对于每个吸收体参数集，计算如上定义的 $R$。\n- 生成单行输出，其中包含值 $[R_1,R_2,R_3,R_4]$，格式为小数点后六位的十进制浮点数，并严格按照测试套件的顺序排列。\n\n最终输出格式必须是严格的一行，内容为一个 Python 风格的列表字面量，包含四个逗号分隔的浮点数，例如，“[0.123456,0.234567,0.345678,0.456789]”。",
            "solution": "我们从一维含时薛定谔方程开始，\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = \\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x) \\right]\\psi(x,t),\n$$\n我们在自然单位制中进行计算，设 $\\hbar = 1$ 和 $m = 1$。在时间相关的 Hartree-Fock (TDHF) 理论的独立粒子图像中，每个已占据的单粒子轨道都遵循这种形式的方程，其中包含一个自洽平均场势。这里，为了分离出边界处理，我们将平均场势的实部设为零，并将吸收边界实现为复吸收势 (CAP)，$V_{\\mathrm{CAP}}(x) = -i \\eta(x)$，其中 $\\eta(x) \\ge 0$ 仅在区域边界附近有支撑（即非零）。\n\n我们选择一个均匀网格 $x_j = -L + j \\Delta x$，$j=0,1,\\dots,N-1$，其中 $\\Delta x = 2L/(N-1)$，并施加 Dirichlet 边界条件 $\\psi(x_0,t) = \\psi(x_{N-1},t) = 0$。对于内部点，空间二阶导数由二阶中心差分近似，\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2}(x_j,t) \\approx \\frac{\\psi_{j+1}(t) - 2 \\psi_j(t) + \\psi_{j-1}(t)}{(\\Delta x)^2}, \\quad j = 1,2,\\dots,N-2.\n$$\n作用于内部值的哈密顿量可以写成一个三对角算符，\n$$\n(H \\psi)_j = -\\frac{1}{2}\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2} + V_j \\psi_j, \\quad V_j = -i \\eta(x_j),\n$$\n其中边界值固定为零 $\\psi_0 = \\psi_{N-1} = 0$。\n\n对于时间演化，我们采用 Crank–Nicolson 格式，该格式由应用于薛定谔方程的时间梯形法则推导得出：\n$$\n\\left(I + \\frac{i \\Delta t}{2} H \\right)\\psi^{n+1} = \\left(I - \\frac{i \\Delta t}{2} H \\right)\\psi^n,\n$$\n其中 $\\psi^n$ 是在时间 $t_n = n \\Delta t$ 的波函数。该格式在没有虚势的情况下是无条件稳定且精确范数守恒的；在有复吸收势的情况下，它将在吸收区域内减小范数。\n\n让我们用三对角矩阵来表示 $H$ 在内部节点上的作用。使用 $m = 1$ 和 $\\hbar = 1$，动能算符提供了系数为 $-1/(2 (\\Delta x)^2)$ 的相邻耦合，而对角动能贡献 $+1/(\\Delta x)^2$ 源于 $-2\\psi_j$ 项。因此，对于内部指标 $j=1,\\dots,N-2$，\n- 非对角动能项贡献 $\\pm \\left(-\\frac{1}{2(\\Delta x)^2}\\right) \\psi_{j\\pm 1}$，\n- 对角动能项贡献 $+\\left(\\frac{1}{(\\Delta x)^2}\\right)\\psi_j$，\n- 对角势能项贡献 $+ V_j \\psi_j$，\n所以 $H$ 的对角元是 $H_{jj} = \\frac{1}{(\\Delta x)^2} + V_j$，非对角元是 $H_{j,j\\pm 1} = -\\frac{1}{2(\\Delta x)^2}$。\n\n将此三对角结构代入 Crank–Nicolson 更新式，我们得到两个三对角矩阵：\n$$\nA \\equiv I + \\frac{i \\Delta t}{2} H, \\quad B \\equiv I - \\frac{i \\Delta t}{2} H,\n$$\n更新式为 $A \\psi^{n+1} = B \\psi^n$。具体来说，对于内部点，\n- 对于 $A$，对角元为\n$$\nA_{jj} = 1 + \\frac{i \\Delta t}{2}\\left(\\frac{1}{(\\Delta x)^2} + V_j\\right),\n$$\n非对角元为\n$$\nA_{j,j\\pm 1} = \\frac{i \\Delta t}{2}\\left(-\\frac{1}{2(\\Delta x)^2}\\right) = - i \\frac{\\Delta t}{4 (\\Delta x)^2}.\n$$\n- 对于 $B$，对角元为\n$$\nB_{jj} = 1 - \\frac{i \\Delta t}{2}\\left(\\frac{1}{(\\Delta x)^2} + V_j\\right),\n$$\n非对角元为\n$$\nB_{j,j\\pm 1} = -\\frac{i \\Delta t}{2}\\left(-\\frac{1}{2(\\Delta x)^2}\\right) = + i \\frac{\\Delta t}{4 (\\Delta x)^2}.\n$$\n\n由于 $\\psi_0 = \\psi_{N-1} = 0$，更新方程仅耦合内部向量 $\\mathbf{\\psi}_{\\mathrm{int}}^n = (\\psi_1^n,\\dots,\\psi_{N-2}^n)^\\top$。设 $n_{\\mathrm{int}} = N - 2$。在向量形式中，我们通过构建 $\\mathbf{d}^n = B \\mathbf{\\psi}^n_{\\mathrm{int}}$，然后求解三对角线性系统 $A \\mathbf{\\psi}^{n+1}_{\\mathrm{int}} = \\mathbf{d}^n$ 来计算每一步。因为对于固定的 $\\eta(x)$，$A$ 是不含时的，所以这个系统可以在每个时间步使用带有预计算的前向消元分解的 Thomas 算法高效求解。\n\n复吸收势设置为\n$$\n\\eta(x) = \\begin{cases}\n\\eta_0 \\left(\\dfrac{|x| - (L - w)}{w}\\right)^m,  \\text{if } |x| > L - w, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n它从内边界 $|x| = L - w$ 处的零平滑地开启，到边界 $|x| = L$ 处达到最大值。平滑指数 $m$ 控制势增长的平缓程度；较大的 $m$ 通过更平滑地匹配导数来减少伪反射，但代价是需要更宽的层才能达到相同的衰减效果。\n\n我们初始化一个动能为 $E_0$、平均动量为 $p_0 = \\sqrt{2 E_0}$ 的向右移动的高斯波包，\n$$\n\\psi(x,0) = \\mathcal{N} \\exp\\!\\left(-\\frac{(x-x_0)^2}{4 \\sigma^2} + i p_0 x \\right),\n$$\n其中 $\\mathcal{N}$ 是一个归一化常数，通过数值方法确定以确保 $\\int |\\psi(x,0)|^2 dx = 1$。当 $x_0$ 严格在区域内部且 $p_0 > 0$ 时，波包以群速度 $v = p_0/m = p_0$（在我们的单位制中）向右传播，到达右边界层，并根据 CAP 参数被吸收或部分反射。\n\n为了量化吸收的质量，我们定义一个以 $x_0$ 为中心、半宽为 $\\delta$ 的监视窗，并测量反射比\n$$\nR = \\frac{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{x_0 - \\delta}^{x_0 + \\delta} |\\psi(x,0)|^2 \\, dx}.\n$$\n最终时间 $T$ 的选择要保证，在没有吸收的情况下，反射波有时间从右边界返回到初始区域；在良好吸收的情况下，$R$ 将会很小。该积分通过监视窗内网格点上的离散和 $\\int f(x)\\,dx \\approx \\Delta x \\sum_j f(x_j)$ 进行数值计算。\n\n算法步骤：\n1. 设置物理和数值参数：$L$, $N$, $\\Delta t$, $T$, $x_0$, $\\sigma$, $E_0$, $\\delta$。\n2. 构建网格 $x_j$ 并初始化 $\\psi(x,0)$，然后对其进行归一化。\n3. 对于每个 CAP 参数集 $(\\eta_0,w,m)$：\n   - 在网格上构建 $\\eta(x)$。\n   - 构建 $V_j = -i \\eta(x_j)$ 并为内部点构成三对角矩阵 $A$ 和 $B$。\n   - 预计算与 $A$ 相关的 Thomas 算法的前向消元系数。\n   - 通过重复计算 $\\mathbf{d}^n = B \\mathbf{\\psi}^n_{\\mathrm{int}}$ 并求解 $A \\mathbf{\\psi}^{n+1}_{\\mathrm{int}} = \\mathbf{d}^n$，从 $t=0$ 步进到 $t=T$。\n   - 使用在 $t=0$ 和 $t=T$ 的监视区域计算 $R$。\n4. 在单行中输出指定测试套件的反射比 $[R_1,R_2,R_3,R_4]$。\n\n在整个测试套件中的预期定性行为：\n- 对于 $(\\eta_0,w,m) = (0,0,2)$，不存在吸收，Dirichlet 边界就像一堵硬墙；反射波返回，导致较大的 $R$。\n- 对于弱但有限的吸收体 $(\\eta_0,w,m) = (0.5,1.0,2)$，会发生一些衰减，但反射仍然很显著；相对于没有吸收体的情况，$R$ 会减小。\n- 对于平滑且足够强的吸收体 $(\\eta_0,w,m) = (2.0,1.5,3)$，反射被强烈抑制，$R$ 很小。\n- 对于过强且非常薄的吸收体 $(\\eta_0,w,m) = (10.0,0.25,1)$，突兀的开启会导致显著的伪反射；$R$ 会再次增大。\n\n由于选择了 $\\hbar = 1$ 和 $m = 1$，这里所有的量都是无量纲的。最终程序计算四个 $R$ 值，并以要求的小数点后六位的单行列表格式打印它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_precompute(a, b, c):\n    \"\"\"\n    Precompute coefficients for the Thomas algorithm (tridiagonal solver).\n    a: lower diagonal (length n-1), entries a[i] corresponds to row i+1\n    b: main diagonal (length n)\n    c: upper diagonal (length n-1), entries c[i] corresponds to row i\n    Returns:\n        cp: modified upper diagonal coefficients (length n-1)\n        inv_denom: inverse of the modified main diagonal (length n)\n    \"\"\"\n    n = b.size\n    cp = np.zeros(n - 1, dtype=np.complex128)\n    inv_denom = np.zeros(n, dtype=np.complex128)\n\n    inv_denom[0] = 1.0 / b[0]\n    if n - 1 > 0:\n        cp[0] = c[0] * inv_denom[0]\n    for i in range(1, n - 1):\n        denom = b[i] - a[i - 1] * cp[i - 1]\n        inv_denom[i] = 1.0 / denom\n        cp[i] = c[i] * inv_denom[i]\n    if n > 1:\n        denom_last = b[-1] - a[-1] * cp[-1]\n        inv_denom[-1] = 1.0 / denom_last\n    return cp, inv_denom\n\ndef thomas_solve(a, b, c, cp, inv_denom, d):\n    \"\"\"\n    Solve A x = d for tridiagonal A with precomputed cp and inv_denom.\n    a: lower diagonal (length n-1)\n    b: main diagonal (length n) (not used directly here, but kept for signature consistency)\n    c: upper diagonal (length n-1)\n    cp: precomputed modified upper diagonal (length n-1)\n    inv_denom: precomputed inverse denominators (length n)\n    d: right-hand side (length n)\n    Returns:\n        x: solution vector (length n)\n    \"\"\"\n    n = d.size\n    dp = np.empty(n, dtype=np.complex128)\n    # Forward substitution using precomputed inv_denom\n    dp[0] = d[0] * inv_denom[0]\n    for i in range(1, n):\n        dp[i] = (d[i] - a[i - 1] * dp[i - 1]) * inv_denom[i]\n    # Back substitution using cp\n    x = np.empty(n, dtype=np.complex128)\n    x[-1] = dp[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = dp[i] - cp[i] * x[i + 1]\n    return x\n\ndef build_cap(x, L, eta0, w, m_order):\n    \"\"\"\n    Build the complex absorbing potential strength eta(x) over the grid x.\n    If w = 0 or eta0 == 0, returns zeros.\n    \"\"\"\n    eta = np.zeros_like(x, dtype=np.float64)\n    if eta0 == 0.0 or w == 0.0:\n        return eta\n    # Distance beyond inner edge of absorber\n    inner_edge = L - w\n    dist = np.abs(x) - inner_edge\n    dist = np.where(dist > 0.0, dist, 0.0)\n    s = dist / w\n    # Avoid numerical issues exactly at boundary\n    s = np.clip(s, 0.0, 1.0)\n    eta = eta0 * (s ** m_order)\n    return eta\n\ndef run_case(eta0, w, m_order, params):\n    \"\"\"\n    Run one simulation case and return reflection ratio R.\n    params: dict with keys L, N, dt, T, x0, sigma, E0, delta\n    \"\"\"\n    L = params[\"L\"]\n    N = params[\"N\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    x0 = params[\"x0\"]\n    sigma = params[\"sigma\"]\n    E0 = params[\"E0\"]\n    delta = params[\"delta\"]\n\n    # Grid\n    x = np.linspace(-L, L, N, endpoint=True)\n    dx = x[1] - x[0]\n\n    # Initial Gaussian wave packet\n    p0 = np.sqrt(2.0 * E0)\n    psi = np.exp(-((x - x0) ** 2) / (4.0 * sigma ** 2) + 1j * p0 * x).astype(np.complex128)\n    # Enforce Dirichlet at the endpoints\n    psi[0] = 0.0 + 0.0j\n    psi[-1] = 0.0 + 0.0j\n    # Normalize\n    norm0 = np.sqrt(np.sum(np.abs(psi) ** 2) * dx)\n    psi /= norm0\n\n    # Build CAP and potential\n    eta = build_cap(x, L, eta0, w, m_order)\n    V = -1j * eta  # purely imaginary potential\n\n    # Crank–Nicolson matrices for interior points\n    n_int = N - 2\n    # Constants\n    inv_dx2 = 1.0 / (dx * dx)\n    off_fac = dt / (4.0 * dx * dx)\n    # Diagonals for A and B (interior)\n    V_int = V[1:-1]\n    # A = I + i dt/2 H\n    bA = (1.0 + 1j * (dt / 2.0) * (inv_dx2 + V_int)).astype(np.complex128)\n    aA = (-1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    cA = (-1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    # B = I - i dt/2 H\n    bB = (1.0 - 1j * (dt / 2.0) * (inv_dx2 + V_int)).astype(np.complex128)\n    aB = (1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n    cB = (1j * off_fac) * np.ones(n_int - 1, dtype=np.complex128)\n\n    # Precompute Thomas algorithm coefficients for A\n    cp, inv_denom = thomas_precompute(aA, bA, cA)\n\n    # Prepare time stepping\n    steps = int(np.round(T / dt))\n    # Monitor region mask\n    mask = (x >= (x0 - delta))  (x = (x0 + delta))\n    # Initial monitor probability\n    P_init = np.sum((np.abs(psi) ** 2) * mask) * dx\n\n    # Time propagation\n    psi_int = psi[1:-1].copy()\n    for _ in range(steps):\n        # Compute d = B * psi_int (tri-diagonal multiplication)\n        d = bB * psi_int\n        # Lower diagonal contribution (from j-1): rows 1..n_int-1\n        d[1:] += aB * psi_int[:-1]\n        # Upper diagonal contribution (from j+1): rows 0..n_int-2\n        d[:-1] += cB * psi_int[1:]\n        # Solve A * psi_next_int = d\n        psi_int = thomas_solve(aA, bA, cA, cp, inv_denom, d)\n\n    # Assemble full psi at final time\n    psi_final = np.zeros_like(psi)\n    psi_final[0] = 0.0 + 0.0j\n    psi_final[-1] = 0.0 + 0.0j\n    psi_final[1:-1] = psi_int\n\n    P_final = np.sum((np.abs(psi_final) ** 2) * mask) * dx\n    # Reflection ratio\n    R = P_final / P_init if P_init > 0 else 0.0\n    return float(np.real_if_close(R))\n\ndef solve():\n    # Define global parameters and test suite as specified in the problem statement.\n    params = {\n        \"L\": 4.0,       # half-length of the spatial domain\n        \"N\": 512,       # number of grid points\n        \"dt\": 0.002,    # time step\n        \"T\": 10.0,      # total propagation time\n        \"x0\": -1.0,     # initial center position\n        \"sigma\": 0.3,   # initial packet width\n        \"E0\": 0.5,      # kinetic energy of the packet\n        \"delta\": 0.25,  # monitor half-width\n    }\n\n    # Test suite: (eta0, w, m_order)\n    test_cases = [\n        (0.0, 0.0, 2),     # No absorber: expect large reflection\n        (0.5, 1.0, 2),     # Weak absorber: partial reflection\n        (2.0, 1.5, 3),     # Smooth, strong absorber: low reflection\n        (10.0, 0.25, 1),   # Very strong, thin absorber: spurious reflections\n    ]\n\n    results = []\n    for eta0, w, m_order in test_cases:\n        R = run_case(eta0, w, m_order, params)\n        results.append(R)\n\n    # Final print statement in the exact required format with six decimals.\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}