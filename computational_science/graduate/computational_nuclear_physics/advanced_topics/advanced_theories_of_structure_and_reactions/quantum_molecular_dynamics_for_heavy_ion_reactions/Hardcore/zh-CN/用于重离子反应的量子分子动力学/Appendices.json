{
    "hands_on_practices": [
        {
            "introduction": "量子分子动力学（QMD）模型的核心是利用有效平均场来描述核子的运动。该平均场源于一个能量密度泛函，它编码了核子间的复杂相互作用。本练习将指导你从一个给定的、类似Skyrme相互作用的能量密度泛函出发，推导并计算单个核子所受到的平均场力 。通过这个实践，你将深刻理解在QMD模拟中驱动核系统时间演化的力的来源，并将抽象的理论概念与具体的物理量联系起来。",
            "id": "3584132",
            "problem": "在重离子反应的量子分子动力学（QMD）描述中，单粒子平均场势源于一个有效的类Skyrme能量密度泛函，该泛函依赖于局域核子密度及其梯度。考虑对称核物质，其密度分布沿 $x$ 方向是一维的，在横向方向上是均匀的，由下式给出\n$$\\rho(x) = \\rho_{0}\\left[1 + \\delta \\tanh\\!\\left(\\frac{x}{a}\\right)\\right],$$\n其中 $\\rho_{0}$ 是饱和密度，$\\delta$ 是一个无量纲小振幅，$a$ 是一个特征弥散长度。\n\n假设相互作用能量密度是局域类Skyrme部分和表面梯度项之和，\n$$\\varepsilon(\\rho,\\nabla \\rho) = \\frac{\\alpha}{2}\\,\\frac{\\rho^{2}}{\\rho_{0}} + \\frac{\\beta}{\\gamma + 1}\\,\\frac{\\rho^{\\gamma + 1}}{\\rho_{0}^{\\gamma}} + \\frac{C_{s}}{2}\\,|\\nabla \\rho|^{2},$$\n其中 $\\alpha$、$\\beta$、$\\gamma$ 和 $C_{s}$ 是常数参数。单粒子平均场势定义为总相互作用能量关于 $\\rho$ 的泛函导数，对于带梯度的局域泛函，该导数可简化为\n$$U(x) = \\frac{\\partial \\varepsilon}{\\partial \\rho}\\bigg|_{\\rho=\\rho(x)} - \\nabla \\cdot \\left(\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)}\\bigg|_{\\nabla \\rho=\\nabla \\rho(x)}\\right)。$$\n作用在核子上的平均场力为 $-\\nabla U(x)$。忽略所有动量依赖的贡献和任何时间依赖性。\n\n仅使用这些定义和链式法则，推导平均场力的 $x$ 分量 $F_{x} = -\\partial U/\\partial x$ 在 $x=0$ 处的闭式表达式，该表达式用 $\\alpha$、$\\beta$、$\\gamma$、$C_{s}$、$\\rho_{0}$、$\\delta$ 和 $a$ 表示，并适用于上面给出的密度分布 $\\rho(x)$。然后，使用以下参数，对 $F_{x}$ 在 $x=0$ 处进行数值计算：\n- $\\alpha = -356$ MeV,\n- $\\beta = 303$ MeV,\n- $\\gamma = \\frac{7}{6}$,\n- $C_{s} = 30$ MeV fm$^{5}$,\n- $\\rho_{0} = 0.16$ fm$^{-3}$,\n- $\\delta = 0.3$,\n- $a = 2.0$ fm.\n\n将 $F_{x}$ 的最终结果以 MeV/fm 为单位表示，并四舍五入到三位有效数字。",
            "solution": "我们从给定的相互作用能量密度出发，\n$$\\varepsilon(\\rho,\\nabla \\rho) = \\frac{\\alpha}{2}\\,\\frac{\\rho^{2}}{\\rho_{0}} + \\frac{\\beta}{\\gamma + 1}\\,\\frac{\\rho^{\\gamma + 1}}{\\rho_{0}^{\\gamma}} + \\frac{C_{s}}{2}\\,|\\nabla \\rho|^{2}。$$\n对于一个带梯度的局域泛函，单粒子平均场势由标准的Euler–Lagrange泛函导数给出，\n$$U(x) = \\frac{\\partial \\varepsilon}{\\partial \\rho} - \\nabla \\cdot \\left(\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)}\\right)。$$\n我们计算偏导数：\n- 局域部分得到\n$$\\frac{\\partial \\varepsilon}{\\partial \\rho} = \\alpha \\frac{\\rho}{\\rho_{0}} + \\beta \\frac{\\rho^{\\gamma}}{\\rho_{0}^{\\gamma}} = \\alpha \\left(\\frac{\\rho}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma}。$$\n- 梯度项给出\n$$\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)} = C_{s}\\,\\nabla \\rho,$$\n因此\n$$\\nabla \\cdot \\left(\\frac{\\partial \\varepsilon}{\\partial (\\nabla \\rho)}\\right) = C_{s}\\,\\nabla \\cdot (\\nabla \\rho) = C_{s}\\,\\nabla^{2} \\rho。$$\n因此，\n$$U(x) = \\alpha \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right)^{\\gamma} - C_{s}\\,\\nabla^{2} \\rho(x)。$$\n在一维情况下（仅依赖于 $x$），$\\nabla \\to \\partial/\\partial x$ 且 $\\nabla^{2} \\to \\partial^{2}/\\partial x^{2}$，所以\n$$U(x) = \\alpha \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho(x)}{\\rho_{0}}\\right)^{\\gamma} - C_{s}\\,\\frac{\\partial^{2} \\rho(x)}{\\partial x^{2}}。$$\n力是 $-\\nabla U(x)$，在一维情况下，$x$ 分量是\n$$F_{x}(x) = -\\frac{\\partial U}{\\partial x} = -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\alpha \\left(\\frac{\\rho}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma}\\right] + C_{s}\\,\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\partial^{2} \\rho}{\\partial x^{2}}\\right)。$$\n根据链式法则，\n$$\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\alpha \\left(\\frac{\\rho}{\\rho_{0}}\\right) + \\beta \\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma}\\right] = \\left[\\frac{\\alpha}{\\rho_{0}} + \\frac{\\beta \\gamma}{\\rho_{0}}\\left(\\frac{\\rho}{\\rho_{0}}\\right)^{\\gamma - 1}\\right]\\frac{\\mathrm{d}\\rho}{\\mathrm{d}x}。$$\n最后一项是三阶导数，\n$$\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\partial^{2} \\rho}{\\partial x^{2}}\\right) = \\frac{\\partial^{3} \\rho}{\\partial x^{3}}。$$\n因此，\n$$F_{x}(x) = -\\left[\\frac{\\alpha}{\\rho_{0}} + \\frac{\\beta \\gamma}{\\rho_{0}}\\left(\\frac{\\rho(x)}{\\rho_{0}}\\right)^{\\gamma - 1}\\right]\\frac{\\mathrm{d}\\rho(x)}{\\mathrm{d}x} + C_{s}\\,\\frac{\\partial^{3} \\rho(x)}{\\partial x^{3}}。$$\n\n现在我们对给定的密度分布在 $x=0$ 处进行求值，\n$$\\rho(x) = \\rho_{0}\\left[1 + \\delta \\tanh\\!\\left(\\frac{x}{a}\\right)\\right], \\quad u \\equiv \\frac{x}{a}。$$\n所需的导数是\n$$\\frac{\\mathrm{d}\\rho}{\\mathrm{d}x} = \\rho_{0}\\,\\delta\\,\\frac{1}{a}\\,\\mathrm{sech}^{2}(u),$$\n$$\\frac{\\mathrm{d}^{2}\\rho}{\\mathrm{d}x^{2}} = \\rho_{0}\\,\\delta\\,\\frac{1}{a}\\,\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\mathrm{sech}^{2}(u)\\right] = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{2}}\\,\\mathrm{sech}^{2}(u)\\,\\tanh(u),$$\n$$\\frac{\\mathrm{d}^{3}\\rho}{\\mathrm{d}x^{3}} = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{2}}\\,\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left[\\mathrm{sech}^{2}(u)\\,\\tanh(u)\\right] = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{3}}\\left[-2\\,\\mathrm{sech}^{2}(u)\\,\\tanh^{2}(u) + \\mathrm{sech}^{4}(u)\\right]。$$\n在 $x=0$ 处，我们有 $u=0$，$\\tanh(0)=0$，以及 $\\mathrm{sech}(0)=1$，所以\n$$\\rho(0) = \\rho_{0}, \\quad \\frac{\\mathrm{d}\\rho}{\\mathrm{d}x}\\bigg|_{x=0} = \\rho_{0}\\,\\delta\\,\\frac{1}{a}, \\quad \\frac{\\mathrm{d}^{3}\\rho}{\\mathrm{d}x^{3}}\\bigg|_{x=0} = -2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{3}}。$$\n此外，\n$$\\left(\\frac{\\rho(0)}{\\rho_{0}}\\right)^{\\gamma - 1} = 1^{\\gamma - 1} = 1。$$\n因此，\n$$F_{x}(0) = -\\left[\\frac{\\alpha}{\\rho_{0}} + \\frac{\\beta \\gamma}{\\rho_{0}}\\cdot 1\\right]\\left(\\rho_{0}\\,\\delta\\,\\frac{1}{a}\\right) + C_{s}\\left(-2\\,\\rho_{0}\\,\\delta\\,\\frac{1}{a^{3}}\\right)。$$\n化简得，\n$$F_{x}(0) = -\\left[\\alpha + \\beta \\gamma\\right]\\frac{\\delta}{a} - 2\\,C_{s}\\,\\rho_{0}\\,\\frac{\\delta}{a^{3}}。$$\n\n这就是所要求的闭式表达式。现在代入数值：\n- $\\alpha = -356$ MeV,\n- $\\beta = 303$ MeV,\n- $\\gamma = \\frac{7}{6}$，所以 $\\beta \\gamma = 303 \\times \\frac{7}{6} = 353.5$ MeV,\n- 因此，$\\alpha + \\beta \\gamma = -356 + 353.5 = -2.5$ MeV。\n- $\\delta = 0.3$,\n- $a = 2.0$ fm，所以 $a^{3} = 8.0$ fm$^{3}$,\n- $C_{s} = 30$ MeV fm$^{5}$,\n- $\\rho_{0} = 0.16$ fm$^{-3}$。\n\n计算两部分的贡献：\n$$-\\left[\\alpha + \\beta \\gamma\\right]\\frac{\\delta}{a} = -\\left[-2.5\\right]\\frac{0.3}{2.0} = 2.5 \\times 0.15 = 0.375 \\text{ MeV/fm},$$\n$$- 2\\,C_{s}\\,\\rho_{0}\\,\\frac{\\delta}{a^{3}} = -2 \\times 30 \\times 0.16 \\times \\frac{0.3}{8.0} = -\\frac{2.88}{8.0} = -0.36 \\text{ MeV/fm}。$$\n求和得，\n$$F_{x}(0) = 0.375 - 0.36 = 0.015 \\text{ MeV/fm}。$$\n\n四舍五入到三位有效数字并以 MeV/fm 为单位表示，结果是 $0.0150$ MeV/fm。",
            "answer": "$$\\boxed{0.0150}$$"
        },
        {
            "introduction": "除了平滑的平均场，QMD模型还包含一个至关重要的两体碰撞项，用以处理短程关联和系统热化。碰撞的频率由介质中的核子-核子散射截面决定。本练习将探讨该散射截面如何受到核介质环境的影响，并计算由此产生的核子平均自由程 。完成此计算有助于理解QMD模型的随机部分，以及诸如泡利阻塞等密度依赖效应是如何调节重离子碰撞动力学的。",
            "id": "3584140",
            "problem": "在用于重离子反应的量子分子动力学（QMD）输运中，核子之间的随机二元碰撞是使用介质内有效截面来建模的。考虑这样一个模型，其中介质内核子-核子截面根据一个指定的、在实验室动能 $E_{\\mathrm{lab}}$ 下的自由空间值 $\\sigma_{\\mathrm{free}}(E_{\\mathrm{lab}})$，作为密度函数 $\\sigma(\\rho)$ 进行标度。根据动力学理论，平均自由程 $\\lambda$ 由局域数密度 $\\rho$ 和总截面 $\\sigma(\\rho)$ 定义。\n\n假设给定以下基本输入，并将其用作推导和实现的基础：\n- 总截面的介质内标度是密度 $\\rho$ 和参数 $\\eta$ 的函数 $\\sigma(\\rho)$，其中 $\\eta$ 是无量纲的，并且该标度使得对于正的 $\\eta$，截面随密度增加而减小。\n- 平均自由程被定义为均匀介质中单位速度的碰撞率的倒数，表示为 $\\rho$ 和 $\\sigma(\\rho)$ 的函数。\n- 核饱和密度为 $\\rho_0 = 0.16\\,\\mathrm{fm}^{-3}$。\n- 对于 $E_{\\mathrm{lab}} = 100\\,\\mathrm{MeV}$ 的质子-质子散射，一个经过充分检验的代表性自由空间总截面是 $\\sigma_{\\mathrm{free}} = 40\\,\\mathrm{mb}$。\n- 所需的单位换算为：$1\\,\\mathrm{b} = 10^{-28}\\,\\mathrm{m}^2$， $1\\,\\mathrm{mb} = 10^{-3}\\,\\mathrm{b} = 10^{-31}\\,\\mathrm{m}^2$ 和 $1\\,\\mathrm{fm}^2 = 10^{-30}\\,\\mathrm{m}^2$。因此，$1\\,\\mathrm{mb} = 0.1\\,\\mathrm{fm}^2$。\n\n任务：\n- 从上述定义出发，实现介质内截面标度模型，并计算在 $\\rho=\\rho_0$ 时、$E_{\\mathrm{lab}}=100\\,\\mathrm{MeV}$ 的质子的平均自由程。\n- 使用物理有效域条件，即标度的分母必须保持为正，即确保 $1+\\eta\\,\\rho/\\rho_0 > 0$。\n- 以飞米（femtometer）表示最终的平均自由程值。\n\n你的程序必须：\n- 使用上述单位关系，将 $\\sigma_{\\mathrm{free}}$ 从毫靶（millibarn）转换为 $\\mathrm{fm}^2$。\n- 对于无量纲介质内参数 $\\eta$ 的一组测试参数值，在 $\\rho=\\rho_0$ 处计算平均自由程。\n- 将结果输出为单行，内容是用方括号括起来的逗号分隔列表，其中每个条目都四舍五入到六位小数，单位为飞米。\n\n测试集：\n- 使用以下 $\\eta$ 值列表：$[-0.5, 0.0, 0.5, 1.0, 9.0, -0.99]$。\n- 这些情况涵盖：截面增强（$\\eta < 0$）、自由空间极限（$\\eta=0$）、中度减小（$\\eta=0.5$）、强度减小（$\\eta=1.0$）、极端减小（$\\eta=9.0$），以及从上方接近物理边界的近奇异行为（$\\eta=-0.99$）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,\\dots]$，其中每个 $x_i$ 是以 $\\mathrm{fm}$ 为单位并四舍五入到六位小数的平均自由程。",
            "solution": "解决方案首先建立理论框架，然后将其应用于所提供的具体参数。\n\n**1. 理论基础**\n\n问题的核心在于来自运动学理论和核物理的两个基本概念：平均自由程和核子-核子截面的介质内修正。\n\n**原理1：平均自由程**\n介质中一个粒子的平均自由程 $\\lambda$ 是它在连续碰撞之间行进的平均距离。在运动学理论中，它被定义为靶粒子数密度 $\\rho$ 和总碰撞截面 $\\sigma$ 乘积的倒数。\n$$\n\\lambda = \\frac{1}{\\rho \\sigma}\n$$\n在这个问题中，截面 $\\sigma$ 不是一个常数，而是取决于局域核子密度 $\\rho$，所以我们写作 $\\sigma(\\rho)$，并因此有 $\\lambda(\\rho)$。\n\n**原理2：介质内截面标度**\n在自由空间中，核子-核子截面 $\\sigma_{\\mathrm{free}}$ 取决于碰撞能量。在致密的核介质内部，由于泡利阻塞和核子有效质量变化等效应，该截面会受到修正。问题描述了这种标度的一个唯象模型：\n- 介质内截面 $\\sigma(\\rho)$ 是局域密度 $\\rho$ 和一个无量纲参数 $\\eta$ 的函数。\n- 对于 $\\eta > 0$，$\\sigma(\\rho)$ 随 $\\rho$ 的增加而减小。\n- 该模型的定义域受条件 $1+\\eta(\\rho/\\rho_0) > 0$ 的约束，其中 $\\rho_0$ 是核饱和密度。\n\n满足这些条件的最简单、最常见的函数形式是：\n$$\n\\sigma(\\rho) = \\frac{\\sigma_{\\mathrm{free}}}{1 + \\eta \\frac{\\rho}{\\rho_0}}\n$$\n这种形式在许多QMD和输运模型中是标准的。分母项 $1 + \\eta (\\rho/\\rho_0)$ 直接实现了指定的标度行为和定义域约束。我们将使用这个既定公式继续进行。\n\n**2. 针对特定情况的推导**\n\n任务是计算核饱和密度下，即 $\\rho = \\rho_0$ 时的平均自由程 $\\lambda$。\n\n首先，我们将 $\\sigma(\\rho)$ 的标度模型代入 $\\lambda(\\rho)$ 的定义中：\n$$\n\\lambda(\\rho) = \\frac{1}{\\rho \\sigma(\\rho)} = \\frac{1}{\\rho \\left( \\frac{\\sigma_{\\mathrm{free}}}{1 + \\eta \\frac{\\rho}{\\rho_0}} \\right)} = \\frac{1 + \\eta \\frac{\\rho}{\\rho_0}}{\\rho \\sigma_{\\mathrm{free}}}\n$$\n接下来，我们在 $\\rho = \\rho_0$ 处计算此表达式。这将比率 $\\rho/\\rho_0$ 简化为 1：\n$$\n\\lambda(\\rho_0) = \\frac{1 + \\eta \\frac{\\rho_0}{\\rho_0}}{\\rho_0 \\sigma_{\\mathrm{free}}} = \\frac{1 + \\eta}{\\rho_0 \\sigma_{\\mathrm{free}}}\n$$\n这是用于计算的最终解析表达式。\n\n**3. 数值计算**\n\n我们给定以下数值：\n- 核饱和密度：$\\rho_0 = 0.16\\,\\mathrm{fm}^{-3}$\n- 自由空间 p-p 截面：在 $E_{\\mathrm{lab}}=100\\,\\mathrm{MeV}$ 时，$\\sigma_{\\mathrm{free}} = 40\\,\\mathrm{mb}$。\n\n第一步是确保单位一致。最终结果的期望单位是飞米（$\\mathrm{fm}$）。因此，我们必须将 $\\sigma_{\\mathrm{free}}$ 从毫靶（$\\mathrm{mb}$）转换为平方飞米（$\\mathrm{fm}^2$）。问题提供了必要的换算关系：$1\\,\\mathrm{mb} = 0.1\\,\\mathrm{fm}^2$。\n$$\n\\sigma_{\\mathrm{free}} = 40\\,\\mathrm{mb} \\times \\frac{0.1\\,\\mathrm{fm}^2}{1\\,\\mathrm{mb}} = 4.0\\,\\mathrm{fm}^2\n$$\n现在，我们可以计算 $\\lambda(\\rho_0)$ 表达式的分母：\n$$\n\\rho_0 \\sigma_{\\mathrm{free}} = (0.16\\,\\mathrm{fm}^{-3}) \\times (4.0\\,\\mathrm{fm}^2) = 0.64\\,\\mathrm{fm}^{-1}\n$$\n平均自由程的表达式简化为：\n$$\n\\lambda(\\rho_0) = \\frac{1 + \\eta}{0.64}\\,\\mathrm{fm}\n$$\n我们将此公式应用于测试集 $[-0.5, 0.0, 0.5, 1.0, 9.0, -0.99]$ 中的每个 $\\eta$ 值。\n\n- 对于 $\\eta = -0.5$：$\\lambda(\\rho_0) = \\frac{1 - 0.5}{0.64} = \\frac{0.5}{0.64} = 0.78125\\,\\mathrm{fm}$\n- 对于 $\\eta = 0.0$：$\\lambda(\\rho_0) = \\frac{1 + 0.0}{0.64} = \\frac{1.0}{0.64} = 1.5625\\,\\mathrm{fm}$ （这是在密度为 $\\rho_0$ 的介质中的自由空间平均自由程）。\n- 对于 $\\eta = 0.5$：$\\lambda(\\rho_0) = \\frac{1 + 0.5}{0.64} = \\frac{1.5}{0.64} = 2.34375\\,\\mathrm{fm}$\n- 对于 $\\eta = 1.0$：$\\lambda(\\rho_0) = \\frac{1 + 1.0}{0.64} = \\frac{2.0}{0.64} = 3.125\\,\\mathrm{fm}$\n- 对于 $\\eta = 9.0$：$\\lambda(\\rho_0) = \\frac{1 + 9.0}{0.64} = \\frac{10.0}{0.64} = 15.625\\,\\mathrm{fm}$\n- 对于 $\\eta = -0.99$：$\\lambda(\\rho_0) = \\frac{1 - 0.99}{0.64} = \\frac{0.01}{0.64} = 0.015625\\,\\mathrm{fm}$\n\n将这些结果四舍五入到六位小数，然后格式化为所需的输出字符串。其物理解释是，正的 $\\eta$ 会减小介质内截面，导致更长的平均自由程；而负的 $\\eta$ 会增强截面，缩短平均自由程。$\\eta=-0.99$ 的值使系统接近一个具有非常大截面和因此非常短平均自由程的奇点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the nucleon mean free path in nuclear matter at saturation density\n    based on a QMD-inspired in-medium cross-section scaling model.\n    \"\"\"\n\n    # Define the foundational inputs from the problem statement.\n    \n    # Nuclear saturation density in fm^-3\n    RHO_0 = 0.16\n    \n    # Free-space proton-proton total cross-section in millibarns (mb)\n    SIGMA_FREE_MB = 40.0\n    \n    # Conversion factor from millibarns (mb) to square femtometers (fm^2)\n    # 1 mb = 10^-31 m^2; 1 fm^2 = 10^-30 m^2 => 1 mb = 0.1 fm^2\n    MB_TO_FM2 = 0.1\n    \n    # The test suite of dimensionless in-medium parameter eta\n    test_cases = [-0.5, 0.0, 0.5, 1.0, 9.0, -0.99]\n    eta_values = np.array(test_cases)\n    \n    # --- Step 1: Convert units ---\n    # Convert the free-space cross-section to fm^2 to have consistent units.\n    sigma_free_fm2 = SIGMA_FREE_MB * MB_TO_FM2\n    \n    # --- Step 2: Implement the mean free path formula ---\n    # The mean free path is given by lambda = 1 / (rho * sigma_in_medium).\n    # The in-medium cross-section is sigma_in_medium = sigma_free / (1 + eta * (rho/rho_0)).\n    # At rho = rho_0, this simplifies to:\n    # lambda(rho_0) = 1 / (rho_0 * (sigma_free / (1 + eta))) = (1 + eta) / (rho_0 * sigma_free)\n    \n    # Pre-calculate the denominator product for efficiency\n    product_rho_sigma = RHO_0 * sigma_free_fm2\n    \n    # --- Step 3: Compute results for the test suite ---\n    # Use numpy's vectorized capabilities to compute all results at once.\n    # The condition 1 + eta > 0 is met for all test cases.\n    lambda_values = (1 + eta_values) / product_rho_sigma\n    \n    # --- Step 4: Format the output ---\n    # Round each result to six decimal places and format as a string.\n    results_str = [f\"{val:.6f}\" for val in lambda_values]\n    \n    # Final print statement in the exact required format: [x1,x2,...]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "QMD模拟的最终输出是所有核子在相空间中的坐标和动量。为了提取如碎片产额等物理可观测量，必须首先从这些最终状态的核子中识别出形成的原子核碎片。本练习要求你实现一个标准的相空间凝聚算法，通过设定空间和动量上的截断，将核子组合成束缚的碎片 。这是一项非常实用的计算任务，它模拟了计算核物理研究中关键的数据分析步骤，让你亲身体验如何从原始模拟数据中提取出如碎片电荷分布这样的可观测量。",
            "id": "3584083",
            "problem": "要求您从第一性原理出发，实现一种在重离子反应的量子分子动力学（QMD）模拟中常用的相空间聚类程序。在此程序中（在QMD社群中常被称为最小生成树（MST）方法），核子通过在坐标空间和动量空间中的成对截断被分组为碎片。您的任务是为一个模拟金-金中心碰撞末期快照的合成数据集实现此程序，并计算碎片电荷分布。\n\n基本定义：\n- 在量子分子动力学（QMD）中，每个核子由一个质心位置矢量 $\\mathbf{r}_i$（单位为 $\\mathrm{fm}$）和一个质心动量矢量 $\\mathbf{p}_i$（单位为 $\\mathrm{MeV}/c$）表示。\n- 定义核子 $i$ 和 $j$ 之间的欧几里得空间距离为 $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$（单位为 $\\mathrm{fm}$）。\n- 定义核子 $i$ 和 $j$ 之间的欧几里得动量距离为 $\\Delta p_{ij} = \\lVert \\mathbf{p}_i - \\mathbf{p}_j \\rVert_2$（单位为 $\\mathrm{MeV}/c$）。\n- 给定截断值 $R_c$ 和 $P_c$，当且仅当 $d_{ij} \\le R_c$ 且 $\\Delta p_{ij} \\le P_c$ 时，在 $i$ 和 $j$ 之间绘制一条无向边。\n- 团簇（碎片）是该无向图的连通分量。\n- 每个核子都有一个类型 $t_i \\in \\{\\text{p}, \\text{n}\\}$，表示质子（$\\text{p}$）或中子（$\\text{n}$）。一个碎片 $C$ 的电荷数是 $Z(C) = \\sum_{i \\in C} \\mathbb{1}[t_i = \\text{p}]$。\n- 带电碎片的电荷分布 $P(Z)$ 定义为 $P(Z) = N_Z / N_{\\text{frag}}$，其中 $N_Z$ 是电荷为 $Z \\ge 1$ 的碎片数量，而 $N_{\\text{frag}}$ 是电荷为 $Z \\ge 1$ 的碎片总数。电荷为 $Z=0$ 的碎片（仅由中子组成的团簇）被排除在 $P(Z)$ 之外。如果某个测试用例中不存在带电碎片，则返回一个空列表。\n\n对所有测试用例使用以下参数：\n- 空间截断值 $R_c = 3\\,\\mathrm{fm}$。\n- 动量截断值 $P_c = 250\\,\\mathrm{MeV}/c$。\n- 边界是包含性的：$d_{ij} = R_c$ 且 $\\Delta p_{ij} = P_c$ 的核子对被视为相连。\n\n仅使用图连通性实现上述过程；不要使用任何能量最小化或此处定义之外的额外物理学。\n\n为以下每个合成测试用例计算 $P(Z)$。每个测试用例提供一个核子类型、位置（单位为 $\\mathrm{fm}$）和动量（单位为 $\\mathrm{MeV}/c$）的列表。位置和动量以有序三元组的形式给出。您的实现必须将这些列表视为事件中核子的完整集合，并且不得引入任何额外的粒子。\n\n测试套件：\n- 测试用例 A（两个分离良好的碎片和一个自由中子）：\n  - 类型 $[t_i]$: $[\\text{p}, \\text{p}, \\text{p}, \\text{n}, \\text{n}, \\text{n}, \\text{p}, \\text{p}, \\text{n}, \\text{n}, \\text{n}]$。\n  - 位置 $\\mathbf{r}_i$（单位 $\\mathrm{fm}$）：\n    - 团簇 1: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(1.0, 0.5, 0.0\\right)$, $\\left(-0.8, -0.2, 0.3\\right)$, $\\left(0.5, -0.7, 0.2\\right)$, $\\left(-1.2, 0.6, -0.4\\right)$, $\\left(0.2, 1.0, -0.5\\right)$。\n    - 团簇 2: $\\left(10.0, 0.0, 0.0\\right)$, $\\left(10.5, -0.3, 0.7\\right)$, $\\left(9.2, 0.4, -0.6\\right)$, $\\left(11.0, 0.8, 0.1\\right)$。\n    - 自由中子: $\\left(30.0, 30.0, 0.0\\right)$。\n  - 动量 $\\mathbf{p}_i$（单位 $\\mathrm{MeV}/c$）：\n    - 团簇 1: $\\left(100.0, 5.0, -10.0\\right)$, $\\left(95.0, -10.0, 0.0\\right)$, $\\left(110.0, 0.0, 15.0\\right)$, $\\left(105.0, 5.0, 0.0\\right)$, $\\left(90.0, -5.0, -5.0\\right)$, $\\left(100.0, 10.0, 5.0\\right)$。\n    - 团簇 2: $\\left(-50.0, 50.0, 0.0\\right)$, $\\left(-55.0, 45.0, 10.0\\right)$, $\\left(-60.0, 55.0, -5.0\\right)$, $\\left(-45.0, 40.0, 5.0\\right)$。\n    - 自由中子: $\\left(300.0, -200.0, 100.0\\right)$。\n- 测试用例 B（空间紧凑集合，动量分离的核子；每对都违反动量截断条件）：\n  - 类型 $[t_i]$: $[\\text{p}, \\text{p}, \\text{n}, \\text{n}]$。\n  - 位置 $\\mathbf{r}_i$（单位 $\\mathrm{fm}$）: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(0.5, 0.5, 0.0\\right)$, $\\left(-0.4, 0.2, -0.1\\right)$, $\\left(0.3, -0.6, 0.2\\right)$。\n  - 动量 $\\mathbf{p}_i$（单位 $\\mathrm{MeV}/c$）: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(500.0, 0.0, 0.0\\right)$, $\\left(0.0, 800.0, 0.0\\right)$, $\\left(0.0, 0.0, 1000.0\\right)$。\n- 测试用例 C（边界连通性，恰好为 $R_c$ 和 $P_c$；测试包含性阈值和传递性）：\n  - 类型 $[t_i]$: $[\\text{p}, \\text{n}, \\text{p}]$。\n  - 位置 $\\mathbf{r}_i$（单位 $\\mathrm{fm}$）: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(3.0, 0.0, 0.0\\right)$, $\\left(6.0, 0.0, 0.0\\right)$。\n  - 动量 $\\mathbf{p}_i$（单位 $\\mathrm{MeV}/c$）: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(250.0, 0.0, 0.0\\right)$, $\\left(500.0, 0.0, 0.0\\right)$。\n- 测试用例 D（链式连通性；端点远超截断值，但通过中间体连接）：\n  - 类型 $[t_i]$: $[\\text{p}, \\text{n}, \\text{p}, \\text{n}, \\text{p}]$。\n  - 位置 $\\mathbf{r}_i$（单位 $\\mathrm{fm}$）: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(2.5, 0.0, 0.0\\right)$, $\\left(5.0, 0.0, 0.0\\right)$, $\\left(7.5, 0.0, 0.0\\right)$, $\\left(10.0, 0.0, 0.0\\right)$。\n  - 动量 $\\mathbf{p}_i$（单位 $\\mathrm{MeV}/c$）: $\\left(0.0, 0.0, 0.0\\right)$, $\\left(200.0, 0.0, 0.0\\right)$, $\\left(400.0, 0.0, 0.0\\right)$, $\\left(600.0, 0.0, 0.0\\right)$, $\\left(800.0, 0.0, 0.0\\right)$。\n\n计算和输出要求：\n- 根据定义实现图，使用 $R_c = 3\\,\\mathrm{fm}$ 和 $P_c = 250\\,\\mathrm{MeV}/c$，并使用包含性不等式。\n- 对于每个测试用例，计算列表 $[P(1), P(2), \\dots, P(Z_{\\max})]$，其中 $Z_{\\max}$ 是观测到的 $Z \\ge 1$ 的最大碎片电荷。将概率表示为小数点后六位四舍五入的小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表的每个元素本身就是一个对应于一个测试用例的、用方括号括起来的逗号分隔列表，顺序与上文相同。例如，一个有效的输出格式是 $\\left[\\left[a,b\\right],\\left[c\\right],\\left[d,e\\right]\\right]$，其中每个符号都替换为小数点后六位的小数。\n\n不应读取任何输入；所有数据必须在程序内定义。确保所有距离单位为 $\\mathrm{fm}$，所有动量单位为 $\\mathrm{MeV}/c$。不使用角度。概率必须以小数形式打印，而非分数。通过严格遵守上述阈值和定义来确保科学真实性。",
            "solution": "该问题旨在从核子的相空间分布中识别核碎片，这是一个经典的图论问题。其核心原则是，属于同一碎片的核子在坐标空间和动量空间中同时彼此“接近”。该原则被形式化为一个图连通性问题。\n\n解决方案分四个阶段实现：\n\n1.  **图的构建**：将 $N$ 个核子的集合建模为无向图中的 $N$ 个顶点。当且仅当任意两个顶点 $i$ 和 $j$ 的空间距离 $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$ 和动量距离 $\\Delta p_{ij} = \\lVert \\mathbf{p}_i - \\mathbf{p}_j \\rVert_2$ 同时满足条件 $d_{ij} \\le R_c$ 和 $\\Delta p_{ij} \\le P_c$ 时，在它们之间建立一条边。通过遍历所有核子对并应用此规则来构建邻接表。\n\n2.  **团簇识别**：根据定义，碎片是所构建图的连通分量。我们采用标准的图遍历算法，如深度优先搜索（DFS），来找到这些分量。一个大小为 $N$ 的布尔数组 `visited` 用于跟踪已分配到团簇的核子。算法遍历每个核子。如果某个核子尚未被访问，则从该核子开始一个新的DFS遍历，系统地探索所有可达的核子，并将它们收集到单个团簇中。此团簇中的所有核子都被标记为 `visited`。重复此过程，直到所有核子都分配到一个团簇中。\n\n3.  **碎片电荷计算**：对于每个识别出的团簇（碎片），通过计算该团簇内的质子数量来确定其总电荷数 $Z$。\n\n4.  **电荷分布分析**：最后一步是计算碎片集合的电荷分布 $P(Z)$。根据问题定义，首先将电荷为零的团簇（即仅由中子组成的团簇）从分析中排除。剩余（带电）碎片的总数记为 $N_{\\text{frag}}$。如果 $N_{\\text{frag}} = 0$，则分布未定义，表示为空列表。否则，对带电碎片集合中存在的每个电荷值 $Z \\ge 1$ 进行频率计数 $N_Z$。然后，每个电荷 $Z$ 的概率计算为 $P(Z) = N_Z / N_{\\text{frag}}$。结果被编译成一个列表 $[P(1), P(2), \\dots, P(Z_{\\max})]$，其中 $Z_{\\max}$ 是在碎片中观察到的最大电荷。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a phase-space clusterization procedure for nucleons and\n    computes the fragment charge distribution for several test cases.\n    \"\"\"\n\n    # Define the global parameters from the problem statement.\n    R_c = 3.0  # Spatial cutoff in fm\n    P_c = 250.0 # Momentum cutoff in MeV/c\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"types\": ['p', 'p', 'p', 'n', 'n', 'n', 'p', 'p', 'n', 'n', 'n'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (1.0, 0.5, 0.0), (-0.8, -0.2, 0.3),\n                (0.5, -0.7, 0.2), (-1.2, 0.6, -0.4), (0.2, 1.0, -0.5),\n                (10.0, 0.0, 0.0), (10.5, -0.3, 0.7), (9.2, 0.4, -0.6),\n                (11.0, 0.8, 0.1), (30.0, 30.0, 0.0)\n            ]),\n            \"momenta\": np.array([\n                (100.0, 5.0, -10.0), (95.0, -10.0, 0.0), (110.0, 0.0, 15.0),\n                (105.0, 5.0, 0.0), (90.0, -5.0, -5.0), (100.0, 10.0, 5.0),\n                (-50.0, 50.0, 0.0), (-55.0, 45.0, 10.0), (-60.0, 55.0, -5.0),\n                (-45.0, 40.0, 5.0), (300.0, -200.0, 100.0)\n            ])\n        },\n        # Test Case B\n        {\n            \"types\": ['p', 'p', 'n', 'n'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (0.5, 0.5, 0.0), \n                (-0.4, 0.2, -0.1), (0.3, -0.6, 0.2)\n            ]),\n            \"momenta\": np.array([\n                (0.0, 0.0, 0.0), (500.0, 0.0, 0.0),\n                (0.0, 800.0, 0.0), (0.0, 0.0, 1000.0)\n            ])\n        },\n        # Test Case C\n        {\n            \"types\": ['p', 'n', 'p'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (3.0, 0.0, 0.0), (6.0, 0.0, 0.0)\n            ]),\n            \"momenta\": np.array([\n                (0.0, 0.0, 0.0), (250.0, 0.0, 0.0), (500.0, 0.0, 0.0)\n            ])\n        },\n        # Test Case D\n        {\n            \"types\": ['p', 'n', 'p', 'n', 'p'],\n            \"positions\": np.array([\n                (0.0, 0.0, 0.0), (2.5, 0.0, 0.0), (5.0, 0.0, 0.0), \n                (7.5, 0.0, 0.0), (10.0, 0.0, 0.0)\n            ]),\n            \"momenta\": np.array([\n                (0.0, 0.0, 0.0), (200.0, 0.0, 0.0), (400.0, 0.0, 0.0), \n                (600.0, 0.0, 0.0), (800.0, 0.0, 0.0)\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        types = case[\"types\"]\n        positions = case[\"positions\"]\n        momenta = case[\"momenta\"]\n        num_nucleons = len(types)\n        \n        # 1. Graph Construction: Build adjacency list\n        adj = {i: [] for i in range(num_nucleons)}\n        for i in range(num_nucleons):\n            for j in range(i + 1, num_nucleons):\n                d_ij = np.linalg.norm(positions[i] - positions[j])\n                dp_ij = np.linalg.norm(momenta[i] - momenta[j])\n                \n                # Check connectivity conditions (inclusive)\n                if d_ij = R_c and dp_ij = P_c:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # 2. Cluster Identification: Find connected components using DFS\n        clusters = []\n        visited = [False] * num_nucleons\n        for i in range(num_nucleons):\n            if not visited[i]:\n                current_cluster = []\n                stack = [i]\n                visited[i] = True\n                while stack:\n                    u = stack.pop()\n                    current_cluster.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            stack.append(v)\n                clusters.append(sorted(current_cluster))\n        \n        # 3. Fragment Charge Calculation\n        cluster_charges = []\n        for cluster in clusters:\n            charge = sum(1 for nucleon_idx in cluster if types[nucleon_idx] == 'p')\n            cluster_charges.append(charge)\n            \n        # 4. Charge Distribution Analysis\n        charged_fragment_charges = [z for z in cluster_charges if z > 0]\n        \n        if not charged_fragment_charges:\n            all_results.append([])\n            continue\n            \n        n_frag = len(charged_fragment_charges)\n        z_max = max(charged_fragment_charges)\n        \n        charge_counts = {}\n        for z in charged_fragment_charges:\n            charge_counts[z] = charge_counts.get(z, 0) + 1\n            \n        p_z = [0.0] * z_max\n        for z, count in charge_counts.items():\n            if z > 0:\n                p_z[z - 1] = count / n_frag\n        \n        all_results.append(p_z)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_list in all_results:\n        formatted_list = [f\"{x:.6f}\" for x in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}