{
    "hands_on_practices": [
        {
            "introduction": "费米气体模型的函数形式并非任意得来，它源于统计力学中对费米子系统能量分配方式的计数。本实践通过一个简化的整数划分模型来模拟这一过程，旨在从第一性原理出发，通过计算状态数来构建能级密度，并验证其微正则熵 $S(U)$ 与激发能 $U$ 的平方根之间标志性的线性关系，即 $S(U) \\propto \\sqrt{U}$。这个练习有助于从微观层面建立对能级密度标度律的直观理解。",
            "id": "3601156",
            "problem": "构建一个完整的程序，通过将受约束的整数划分映射到激发能的状态数，来模拟Gilbert-Cameron能级密度模型中的微正则能级密度。其目标是近似计算微正则熵，并将其标度行为与费米气体分支的趋势进行比较。请使用以下科学依据：(i) 微正则系综定义 $\\displaystyle S(U)=\\ln \\rho(U)$，其中 $\\rho(U)$ 是激发能为 $U$ 时的能级密度；(ii) 费米气体渐近趋势，即在平均场近似下，对于足够大的激发能，熵的标度行为近似为 $\\displaystyle S(U)\\approx 2\\sqrt{a\\,U}$，其中 $a$ 是能级密度参数，单位为 $\\mathrm{MeV}^{-1}$。请勿假设任何其他专门的公式。\n\n按如下方式对单粒子平均场进行建模：\n- 费米能以上的单粒子谱近似为一个均匀间隔的阶梯，间距为 $\\displaystyle d$（单位 $\\mathrm{MeV}$）。\n- 只有费米能以上的 $\\displaystyle K$ 个阶梯是可及的，因此可用的单粒子激发量子为 $\\displaystyle \\{d,2d,\\dots,Kd\\}$。\n- 每个阶梯具有自旋简并度 $\\displaystyle g$（即每个阶梯的不同状态数），且根据泡利不相容原理，一个多体构型中最多只能出现 $\\displaystyle g$ 个大小相同的量子。\n- 一个构型中的总激发量子数上限为 $\\displaystyle M_{\\max}$，代表费米能附近有限的单粒子态池。\n\n将多体激发能映射为一个受约束的整数划分问题：\n- 对于激发能 $\\displaystyle U$（单位 $\\mathrm{MeV}$），定义 $\\displaystyle n=U/d$，并限制测试值使得 $\\displaystyle n$ 为整数。\n- 一个多体构型是一个整数的多重集 $\\displaystyle \\{i\\}$，其中 $\\displaystyle i\\in\\{1,2,\\dots,K\\}$，并满足以下条件：(i) 任何整数 $\\displaystyle i$ 的重数最多为 $\\displaystyle g$，(ii) 整数的总数最多为 $\\displaystyle M_{\\max}$，以及 (iii) 整数之和等于 $\\displaystyle n$。\n- 令 $\\displaystyle P(n;K,g,M_{\\max})$ 为此类受约束划分的数量。\n- 通过归一化 $\\displaystyle \\rho(U)=P(n;K,g,M_{\\max})/d$（单位 $\\mathrm{MeV}^{-1}$）来定义近似能级密度 $\\displaystyle \\rho(U)$。\n- 定义微正则熵 $\\displaystyle S(U)=\\ln \\rho(U)$，此为无量纲量。\n\n算法任务：\n- 对于下方的每个测试用例，计算每个指定 $\\displaystyle U$ 对应的 $\\displaystyle P(n;K,g,M_{\\max})$，得到 $\\displaystyle \\rho(U)$ 和 $\\displaystyle S(U)$，然后对 $\\displaystyle S(U)$ 与 $\\displaystyle \\sqrt{U}$ 进行最小二乘线性拟合，以获得斜率 $\\displaystyle s$ 和截距 $\\displaystyle b$。计算费米气体斜率预测值 $\\displaystyle s_{\\mathrm{FG}}=2\\sqrt{a}$。\n- 对于每个测试用例，还需通过检查布尔判据 $\\displaystyle \\left|s-s_{\\mathrm{FG}}\\right|/s_{\\mathrm{FG}}\\le \\tau$（容差 $\\displaystyle \\tau=0.25$）来评估斜率是否与费米气体趋势紧密匹配。\n\n所有能量均以 $\\mathrm{MeV}$ 表示，能级密度参数以 $\\mathrm{MeV}^{-1}$ 表示。斜率 $\\displaystyle s$ 和 $\\displaystyle s_{\\mathrm{FG}}$ 的单位为 $\\displaystyle \\mathrm{MeV}^{-1/2}$。在最终输出中，将每个斜率值四舍五入到 $\\displaystyle 6$ 位小数。\n\n测试套件：\n- 用例A（理想情况）：$\\displaystyle d=0.5\\ \\mathrm{MeV}$，$\\displaystyle K=12$，$\\displaystyle g=2$，$\\displaystyle M_{\\max}=30$，$\\displaystyle a=10\\ \\mathrm{MeV}^{-1}$，激发能 $\\displaystyle U\\in\\{5.0,6.0,7.5,9.0,10.0,12.0,14.0\\}\\ \\mathrm{MeV}$。\n- 用例B（边界情况，不同划分）：$\\displaystyle d=1.0\\ \\mathrm{MeV}$，$\\displaystyle K=10$，$\\displaystyle g=1$，$\\displaystyle M_{\\max}=25$，$\\displaystyle a=12\\ \\mathrm{MeV}^{-1}$，激发能 $\\displaystyle U\\in\\{4.0,6.0,8.0,10.0,12.0,14.0,16.0\\}\\ \\mathrm{MeV}$。\n- 用例C（边缘情况，紧凑窗口和上限）：$\\displaystyle d=1.0\\ \\mathrm{MeV}$，$\\displaystyle K=5$，$\\displaystyle g=2$，$\\displaystyle M_{\\max}=10$，$\\displaystyle a=8\\ \\mathrm{MeV}^{-1}$，激发能 $\\displaystyle U\\in\\{5.0,6.0,7.0,8.0,9.0,10.0\\}\\ \\mathrm{MeV}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。\n- 每个测试用例的结果必须是一个形如 $\\displaystyle [s,s_{\\mathrm{FG}},\\text{flag}]$ 的列表，其中 $\\displaystyle s$ 和 $\\displaystyle s_{\\mathrm{FG}}$ 是四舍五入到 $\\displaystyle 6$ 位小数的浮点数，$\\displaystyle \\text{flag}$ 是如上定义的布尔值。\n- 例如，整体输出必须类似于 $\\displaystyle [[s_A,s_{\\mathrm{FG},A},\\text{flag}_A],[s_B,s_{\\mathrm{FG},B},\\text{flag}_B],[s_C,s_{\\mathrm{FG},C},\\text{flag}_C]]$，不含任何额外文本。",
            "solution": "用户提供了一个计算核物理领域中有效且适定的问题。任务是使用简化的核激发表示来模拟微正则能级密度 $\\rho(U)$，计算相应的熵 $S(U)$，并将其标度行为与已建立的费米气体模型预测进行比较。\n\n### 1. 理论框架与问题形式化\n\n该问题基于统计力学中的微正则系综，其中系统在确定能量 $U$ 下的熵 $S$ 由态密度 $\\rho(U)$ 的对数给出：\n$$S(U) = \\ln \\rho(U)$$\n在核物理中，对于足够高的激发能，费米气体模型预测熵与激发能的平方根成正比：\n$$S(U) \\approx 2\\sqrt{aU}$$\n其中 $a$ 是能级密度参数。目标是在一个特定定义的组合模型内检验此标度律。\n\n### 2. 核激发的组合模型\n\n该模型将原子核复杂的的多体系统简化为一个计算受约束整数划分的问题。\n- 费米能级以上的单粒子态被建模为一个能量间距为 $d$ 的均匀阶梯。能量为 $E_i$ 的激发对应一个整数量子 $i = E_i/d$。\n- 给定K个可及的阶梯，因此可用的整数量子来自集合 $\\{1, 2, \\dots, K\\}$。\n- 每个阶梯的简并度为 $g$，由于泡利不相容原理，这限制了任何单个量子 $i$ 的使用次数最多为 $g$ 次。\n- 一个全局约束将总激发粒子（量子）数限制在 $M_{\\max}$ 以内。\n- 总激发能为 $U$ 的多体状态对应于整数 $n = U/d$ 的一个划分，该划分为一个整数多重集。此类状态的数量表示为 $P(n; K, g, M_{\\max})$。\n\n因此，问题的核心是计算 $P(n; K, g, M_{\\max})$，即整数 $n$ 的划分数，其划分部分来自集合 $\\{1, 2, \\dots, K\\}$，每个部分出现次数最多为 $g$ 次，且部分总数最多为 $M_{\\max}$。\n\n### 3. 算法解决方案：动态规划\n\n这个组合计数问题可以使用动态规划高效解决。我们定义一个三维状态 $DP(i, j, m)$，表示使用 $m$ 个部分形成和为 $j$ 的方式数量，其中每个部分是来自集合 $\\{1, 2, \\dots, i\\}$ 的整数，且每个部分的重数最多为 $g$。\n\n状态转移通过考虑最大可能的部分 $i$ 来构建。一个在 $DP(i, j, m)$ 中计数的划分可以通过使用部分 $i$ 若干次（设为 $c$ 次，其中 $0 \\le c \\le g$）来形成。如果我们总共使用部分 $i$ 了 $c$ 次，则剩余的和为 $j - c \\cdot i$，这个和必须由 $m - c$ 个部分组成，这些部分都小于或等于 $i-1$。这导出了递推关系：\n$$DP(i, j, m) = \\sum_{c=0}^{\\min(g, m, \\lfloor j/i \\rfloor)} DP(i-1, j - c \\cdot i, m - c)$$\n\n递推的基本情况是，用0个部分形成和为0的方式有一种（即空划分）：$DP(0, 0, 0) = 1$。所有其他的 $DP(0, j, m)$ 均为 $0$。\n\nDP表通过迭代填充，其中 $i$ 从 $1$ 到 $K$，$j$ 从 $0$ 到 $n_{\\max}$，$m$ 从 $0$ 到 $M_{\\max}$。对于给定的和 $n$，最终的划分数通过对所有可能的总部分数 $m$ 求和得到：\n$$P(n; K, g, M_{\\max}) = \\sum_{m=0}^{M_{\\max}} DP(K, n, m)$$\n\n为了处理可能非常大的划分数，DP表元素存储为64位浮点数（`np.float64`）。\n\n### 4. 分析与验证\n\n对于每个测试用例，执行以下步骤：\n1.  **计算划分**：针对所需的最大 $n$ 值，一次性计算出DP表。\n2.  **计算熵**：对于每个给定的能量 $U$，确定相应的整数 $n = U/d$。从DP导出的结果中检索划分数 $P(n)$。然后计算能级密度 $\\rho(U) = P(n)/d$ 和熵 $S(U) = \\ln \\rho(U)$。\n3.  **线性回归**：收集数据对 $(\\sqrt{U}, S(U))$。使用 `numpy.polyfit` 进行最小二乘线性回归，以找到 $S(U)$ 对 $\\sqrt{U}$ 的最佳拟合线的斜率 $s$。\n4.  **比较**：将斜率 $s$ 与理论上的费米气体斜率 $s_{\\mathrm{FG}} = 2\\sqrt{a}$ 进行比较。\n5.  **验证**：如果经验斜率与理论斜率之间的相对差异在指定的容差 $\\tau = 0.25$ 之内，则布尔标志设置为真：\n    $$\\left| \\frac{s - s_{\\mathrm{FG}}}{s_{\\mathrm{FG}}} \\right| \\le \\tau$$\n实现封装了此逻辑，处理所有测试用例，并按要求格式化最终输出，即一个单行列表，其中包含每个用例的四舍五入后的斜率和布尔标志。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_partitions(n_max, K, g, M_max):\n    \"\"\"\n    Calculates the number of constrained integer partitions using dynamic programming.\n\n    Let dp[i, j, m] be the number of ways to form sum j with m parts,\n    each part from {1, ..., i} with multiplicity at most g.\n\n    Recurrence:\n    dp[i, j, m] = sum_{c=0 to g} dp[i-1, j - c*i, m-c]\n\n    Args:\n        n_max (int): The maximum integer to partition.\n        K (int): The maximum value of a part.\n        g (int): The maximum multiplicity of any part.\n        M_max (int): The maximum total number of parts.\n\n    Returns:\n        numpy.ndarray: The filled 3D DP table.\n    \"\"\"\n    dp = np.zeros((K + 1, n_max + 1, M_max + 1), dtype=np.float64)\n\n    # Base case: one way to form sum 0 with 0 parts (the empty set).\n    # This is true for any set of allowed parts {1..i}.\n    dp[0, 0, 0] = 1.0\n\n    # Fill the DP table\n    for i in range(1, K + 1):  # For each part value available {1, ..., K}\n        for j in range(n_max + 1):  # For each target sum {0, ..., n_max}\n            for m in range(M_max + 1):  # For each number of parts {0, ..., M_max}\n                # Sum over the number of times 'c' the part 'i' is used\n                for c in range(g + 1):\n                    if m - c >= 0 and j - c * i >= 0:\n                        dp[i, j, m] += dp[i - 1, j - c * i, m - c]\n    return dp\n\ndef process_case(d, K, g, M_max, a, U_values, tau):\n    \"\"\"\n    Processes a single test case according to a problem description.\n    \"\"\"\n    # Find the maximum n needed for the DP table\n    n_max = int(max(U_values) / d) if U_values else 0\n\n    # Pre-compute all partition numbers\n    dp_table = calculate_partitions(n_max, K, g, M_max)\n\n    sqrt_U_vals = []\n    S_U_vals = []\n\n    for U in U_values:\n        n = int(U / d)\n        \n        # Total partitions P(n) is the sum over all possible numbers of parts m\n        if n = n_max:\n            P_n = np.sum(dp_table[K, n, :M_max + 1])\n        else:\n            P_n = 0\n\n        # Calculate entropy S(U) if partitions exist\n        if P_n > 0:\n            rho_U = P_n / d\n            S_U = np.log(rho_U)\n            sqrt_U_vals.append(np.sqrt(U))\n            S_U_vals.append(S_U)\n\n    # Perform linear fit if there are enough data points\n    if len(sqrt_U_vals)  2:\n        s = 0.0 # Cannot determine slope\n    else:\n        s, _ = np.polyfit(sqrt_U_vals, S_U_vals, 1)\n\n    # Calculate Fermi-gas slope prediction\n    s_FG = 2 * np.sqrt(a)\n\n    # Check the boolean criterion, handle division by zero\n    if s_FG == 0:\n        flag = (s == 0)\n    else:\n        flag = (np.abs(s - s_FG) / s_FG) = tau\n\n    # Round slopes to 6 decimal places per problem requirement\n    s_rounded = round(s, 6)\n    s_FG_rounded = round(s_FG, 6)\n    \n    return [s_rounded, s_FG_rounded, bool(flag)]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    tau = 0.25\n\n    test_cases = [\n        # Case A (happy path)\n        {\n            \"d\": 0.5, \"K\": 12, \"g\": 2, \"M_max\": 30, \"a\": 10.0,\n            \"U\": [5.0, 6.0, 7.5, 9.0, 10.0, 12.0, 14.0]\n        },\n        # Case B (boundary, distinct partitions)\n        {\n            \"d\": 1.0, \"K\": 10, \"g\": 1, \"M_max\": 25, \"a\": 12.0,\n            \"U\": [4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0]\n        },\n        # Case C (edge, tight window and cap)\n        {\n            \"d\": 1.0, \"K\": 5, \"g\": 2, \"M_max\": 10, \"a\": 8.0,\n            \"U\": [5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"d\"], case[\"K\"], case[\"g\"], case[\"M_max\"],\n                              case[\"a\"], case[\"U\"], tau)\n        results.append(result)\n\n    # Format the final output string to match [[s_A,s_FG_A,flag_A],...]\n    # with no spaces around commas.\n    list_of_strs = []\n    for res_list in results:\n        # res_list is [float, float, bool]\n        s_str = f\"{res_list[0]:.6f}\"\n        s_fg_str = f\"{res_list[1]:.6f}\"\n        # Python's str() on a bool is 'True' or 'False' (capitalized)\n        flag_str = str(res_list[2])\n        list_of_strs.append(f\"[{s_str},{s_fg_str},{flag_str}]\")\n        \n    print(f\"[{','.join(list_of_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "完整的吉尔伯特-卡梅伦(GC)模型是一个混合模型，它在低能区使用恒温(CT)模型，在高能区使用费米气体(FG)模型。这个练习将指导您实现这一混合结构，并通过与实验可观测量进行比较来验证模型的有效性。您将学习如何将模型的低能部分与已知的离散能级数进行对比，以及如何将高能部分与中子共振数据联系起来，这是核数据评估中的标准实践。",
            "id": "3601162",
            "problem": "您需要通过将两个能量区域内的积分能级密度与独立的参考量进行比较，来实现并验证 Gilbert–Cameron 能级密度模型的计算实现。Gilbert–Cameron 构造在低激发能下使用恒温 (CT) 形式，在较高激发能下使用费米气体 (FG) 形式，并引入背移以考虑对关联。您的任务是从第一性原理推导出所需的数学表达式，然后将它们编码到单个程序中，为一组测试用例计算指定的验证指标。\n\n从以下基本依据开始：\n- 直到激发能 $U$ 的量子能级累积数为 $N(U)=\\int_0^{U}\\rho(U')\\,dU'$，其中 $\\rho(U)$ 是能级密度，单位为逆兆电子伏特 (MeV$^{-1}$)。\n- 恒温模型源于一个正则系综，在低激发能下具有近似恒定的核温度，并且必须从正则配分函数以及微正则系综和正则系综之间的关系来构建。\n- 费米气体模型源于带有鞍点近似（Bethe 公式）的微正则多费米子计数，并且必须包含一个具有物理动机的背移，以表示低激发能下的对关联。\n- 在中子分离能 $S_n$ 处，平均 s 波共振间距 $D_0$（单位为电子伏特，eV）可以通过由自旋截止参数 $\\sigma$ 表征的态的自旋分布，转换为总能级密度的估计值。对于给定的总自旋 $J$，必须使用自旋分布将共振间距与在 $U=S_n$ 附近具有相关自旋的所有可用复合核态的密度联系起来。\n\n为每个测试用例实现以下验证计算：\n1. 计算积分 $\\int_0^{U_m} \\rho_{\\mathrm{CT}}(U)\\,dU$，并将其与提供的直到 $U_m$ 的已知分立能级数 $N_d$ 进行比较。报告定义为 $\\delta_{\\mathrm{low}}=\\left(\\int_0^{U_m} \\rho_{\\mathrm{CT}}(U)\\,dU - N_d\\right)/N_d$ 的分数偏差。\n2. 计算积分 $\\int_{U_m}^{S_n} \\rho_{\\mathrm{FG}}(U)\\,dU$，并将其与从共振数据中估计的有效共振数进行比较。为构建此参考计数，首先通过 $D_0^{\\mathrm{MeV}} = D_0^{\\mathrm{eV}}\\times 10^{-6}$ 将 $D_0$ 从电子伏特转换为兆电子伏特。然后，对于 s 波俘获，使用带有截止参数 $\\sigma$ 的自旋分布和靶核自旋 $I$ 来计算在 $U=S_n$ 处的总能级密度，其中可及的复合核自旋为 $J_+=I+\\tfrac{1}{2}$ 和 $J_-=I-\\tfrac{1}{2}$（仅包括非负的 $J$）。使用正则自旋分布获得总密度因子 $g(J,\\sigma)$，然后定义 $\\rho_{\\mathrm{res}}(S_n)=\\left[D_0^{\\mathrm{MeV}}\\left(g(J_+,\\sigma)+g(J_-,\\sigma)\\right)\\right]^{-1}$。通过假设此密度在该区间内具有代表性来形成一个有效参考计数，$N_{\\mathrm{ref}}=\\rho_{\\mathrm{res}}(S_n)\\,\\left(S_n - U_m\\right)$，并报告分数偏差 $\\delta_{\\mathrm{high}}=\\left(\\int_{U_m}^{S_n} \\rho_{\\mathrm{FG}}(U)\\,dU - N_{\\mathrm{ref}}\\right)/N_{\\mathrm{ref}}$。\n\n对通过/失败标志采用以下容差标准：\n- 低能 CT 验证在 $\\left|\\delta_{\\mathrm{low}}\\right|\\le \\tau_{\\mathrm{CT}}$ 时通过，其中 $\\tau_{\\mathrm{CT}}=0.1$。\n- 高能 FG 验证在 $\\left|\\delta_{\\mathrm{high}}\\right|\\le \\tau_{\\mathrm{FG}}$ 时通过，其中 $\\tau_{\\mathrm{FG}}=0.3$。\n\n必须严格使用的单位和定义：\n- 能量 $U$、$U_m$、$S_n$、$E_0$ 和 $\\delta$ 必须以兆电子伏特 (MeV) 为单位处理。\n- 能级密度 $\\rho(U)$ 必须以逆兆电子伏特 (MeV$^{-1}$) 为单位。\n- 共振间距 $D_0$ 以电子伏特 (eV) 提供，且必须使用 $1\\,\\mathrm{eV}=10^{-6}\\,\\mathrm{MeV}$ 转换为兆电子伏特 (MeV)。\n- 能级密度参数 $a$ 必须以 $\\mathrm{MeV}^{-1}$ 为单位处理。\n- 自旋 $I$ 和 $J$ 是无量纲的。自旋截止参数 $\\sigma$ 是无量纲的。\n- 不出现角度；无需角度单位。\n- 所有输出必须是指定的无量纲数或布尔值。\n\n您的程序必须：\n- 仅基于上述基本依据，推导并实现恒温和费米气体形式，而不依赖于问题陈述中提供的快捷公式。\n- 以数值稳定和科学合理的方式执行所需的积分。\n- 对于每个测试用例，生成一个包含四个条目的列表，顺序为 $[\\delta_{\\mathrm{low}},\\delta_{\\mathrm{high}},\\mathrm{pass}_{\\mathrm{low}},\\mathrm{pass}_{\\mathrm{high}}]$，其中前两个是浮点值，后两个是布尔值。\n- 最终输出必须是单行，包含一个用逗号分隔的、针对每个案例的列表的列表，并用方括号括起来，例如 $[\\,[x_1,y_1,\\mathrm{True},\\mathrm{False}],[x_2,y_2,\\mathrm{True},\\mathrm{True}]\\,]$。\n\n测试套件（每个案例按以下顺序列出参数：质量数 $A$、恒温参数 $T_{\\mathrm{CT}}$ 和 $E_0$、费米气体参数 $a$ 和 $\\delta$、匹配能量 $U_m$、中子分离能 $S_n$、分立能级数 $N_d$、靶核自旋 $I$、自旋截止参数 $\\sigma$、平均 s 波共振间距 $D_0$）：\n- 案例 1：$A=60$, $T_{\\mathrm{CT}}=0.9\\,\\mathrm{MeV}$, $E_0=1.5\\,\\mathrm{MeV}$, $a=7.5\\,\\mathrm{MeV}^{-1}$, $\\delta=1.0\\,\\mathrm{MeV}$, $U_m=4.5\\,\\mathrm{MeV}$, $S_n=8.0\\,\\mathrm{MeV}$, $N_d=28$, $I=0$, $\\sigma=3.0$, $D_0=500\\,\\mathrm{eV}$。\n- 案例 2：$A=95$, $T_{\\mathrm{CT}}=0.7\\,\\mathrm{MeV}$, $E_0=2.0\\,\\mathrm{MeV}$, $a=12.0\\,\\mathrm{MeV}^{-1}$, $\\delta=1.1\\,\\mathrm{MeV}$, $U_m=6.0\\,\\mathrm{MeV}$, $S_n=6.2\\,\\mathrm{MeV}$, $N_d=300$, $I=1.5$, $\\sigma=4.0$, $D_0=200\\,\\mathrm{eV}$。\n- 案例 3：$A=200$, $T_{\\mathrm{CT}}=0.6\\,\\mathrm{MeV}$, $E_0=1.0\\,\\mathrm{MeV}$, $a=25.0\\,\\mathrm{MeV}^{-1}$, $\\delta=1.5\\,\\mathrm{MeV}$, $U_m=2.5\\,\\mathrm{MeV}$, $S_n=5.5\\,\\mathrm{MeV}$, $N_d=12$, $I=0.5$, $\\sigma=6.0$, $D_0=5.0\\,\\mathrm{eV}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用逗号分隔的、用方括号括起来的结果列表，每个测试用例按上述顺序贡献一个列表。例如，输出必须严格遵循以下格式：$[[\\delta_{\\mathrm{low}}^{(1)},\\delta_{\\mathrm{high}}^{(1)},\\mathrm{pass}_{\\mathrm{low}}^{(1)},\\mathrm{pass}_{\\mathrm{high}}^{(1)}],[\\delta_{\\mathrm{low}}^{(2)},\\delta_{\\mathrm{high}}^{(2)},\\mathrm{pass}_{\\mathrm{low}}^{(2)},\\mathrm{pass}_{\\mathrm{high}}^{(2)}],[\\delta_{\\mathrm{low}}^{(3)},\\delta_{\\mathrm{high}}^{(3)},\\mathrm{pass}_{\\mathrm{low}}^{(3)},\\mathrm{pass}_{\\mathrm{high}}^{(3)}]]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上植根于核统计力学的原理，特别是 Gilbert-Cameron 能级密度模型。该问题是良定的，提供了所有必要的参数以及清晰、客观的计算和验证程序。它没有矛盾和歧义，并要求推导和应用标准的、可验证的物理模型。因此，我们可以着手解答。\n\n解答需要推导和实现核能级密度理论的三个核心组成部分：恒温模型、费米气体模型以及核能级的自旋分布。\n\n**1. 模型推导**\n\n**1.1. 恒温 (CT) 模型**\nCT 模型适用于低激发能情况，此时原子核表现出类似于具有恒定温度的宏观物体的性质。其形式由熵 $S$ 和激发能 $U$ 之间的基本热力学关系 $dS/dU = 1/T$ 推导得出，其中 $T$ 是核温度。熵通过 Boltzmann 公式与能级密度 $\\rho(U)$ 相关联：$S(U) = k_B \\ln(\\Omega(U))$，其中 $\\Omega(U)$ 是在 $U$ 附近一个小的能量间隔 $\\Delta E$ 内的态数，即 $\\Omega(U) = \\rho(U)\\Delta E$。为了我们的目的，我们可以使用定义 $S(U) \\approx \\ln(\\rho(U))$，并将常数吸收。\n\n如果假设温度 $T$ 是恒定的，即 $T=T_{\\mathrm{CT}}$，我们可以对热力学关系进行积分：\n$$\n\\frac{dS}{dU} = \\frac{1}{T_{\\mathrm{CT}}} \\implies S(U) = \\frac{U}{T_{\\mathrm{CT}}} + C\n$$\n其中 $C$ 是一个积分常数。代入 $S(U) = \\ln(\\rho(U))$：\n$$\n\\ln(\\rho_{\\mathrm{CT}}(U)) = \\frac{U}{T_{\\mathrm{CT}}} + C \\implies \\rho_{\\mathrm{CT}}(U) = e^C e^{U/T_{\\mathrm{CT}}}\n$$\n这显示了能级密度对能量的指数依赖关系。为了说明该模型不应直接应用于基态 ($U=0$)，引入了一个能量位移参数 $E_0$。此参数有效地移动了能量标度，代表了恒温区域开始的能量。形式变为 $\\rho_{\\mathrm{CT}}(U) \\propto \\exp((U-E_0)/T_{\\mathrm{CT}})$。按照惯例，归一化被设定为能级密度的积分给出累积能级数。能级密度的一个常见且简单的形式是：\n$$\n\\rho_{\\mathrm{CT}}(U) = \\frac{1}{T_{\\mathrm{CT}}} \\exp\\left(\\frac{U - E_0}{T_{\\mathrm{CT}}}\\right)\n$$\n这是我们将要使用的函数形式。\n\n**1.2. 费米气体 (FG) 模型**\n在较高激发能下，原子核更好地被描述为占据单粒子能级的无相互作用费米子（质子和中子）气体。能级密度是通过对该系统应用统计力学推导出来的。起点是计算将激发能 $U$ 分配给核子的方式数量。使用鞍点近似来评估连接配分函数与态密度（Bethe 公式）的拉普拉斯逆变换，可以得到总能级密度的以下表达式：\n$$\n\\rho(U') = \\frac{\\sqrt{\\pi}}{12 a^{1/4} (U')^{5/4}} \\exp(2\\sqrt{aU'})\n$$\n这里，$a$ 是能级密度参数，它与费米面处的单粒子能级密度成正比，$U'$ 是有效激发能。为了考虑在低能量下显著并减少可用态数的对关联，激发能 $U$ 通过一个背移参数 $\\delta$ 进行校正。有效能量变为 $U' = U - \\delta$。此位移有效地将费米气体模型的基态设置在比真实核基态高出能量 $\\delta$ 的位置。背移费米气体 (BSFG) 模型的最终形式是：\n$$\n\\rho_{\\mathrm{FG}}(U) = \\frac{\\sqrt{\\pi}}{12 a^{1/4} (U - \\delta)^{5/4}} \\exp(2\\sqrt{a(U - \\delta)})\n$$\n此公式在 $U  \\delta$ 时有效。\n\n**1.3. 自旋分布与共振密度**\n$\\rho_{\\mathrm{CT}}(U)$ 和 $\\rho_{\\mathrm{FG}}(U)$ 的表达式代表了总能级密度，是对所有可能的总角动量 $J$ 和两种宇称求和的结果。具有特定自旋 $J$ 的能级密度由 $\\rho(U, J) = \\rho(U) f(J, \\sigma)$ 给出，其中 $f(J, \\sigma)$ 是自旋分布函数。对于球形核，假设单个核子角动量的投影不相关且呈正态分布，则自旋分布由下式给出：\n$$\nf(J, \\sigma) = \\frac{2J+1}{2\\sigma^2} \\exp\\left(-\\frac{(J+1/2)^2}{2\\sigma^2}\\right)\n$$\n问题要求一个函数 $g(J, \\sigma)$，我们将其等同于 $f(J, \\sigma)$。量 $\\sigma$ 是自旋截止参数，它表征了自旋分布的宽度并且是能量依赖的，但对于本问题，它被视为在 $S_n$ 处评估的常数参数。\n\n在中子分离能 $S_n$ 处，来自慢中子共振的实验数据提供了能级密度的一种度量。对于轰击自旋为 $I$ 的靶核的 s 波 ($l=0$) 中子，形成的复合核的总自旋可以是 $J_+ = I + 1/2$ 和 $J_- = |I - 1/2|$（或者对于 $I \\ge 1/2$ 仅为 $J_- = I-1/2$）。实验观测到的这些共振的平均间距 $D_0$ 是具有这些特定自旋的能级密度的倒数：\n$$\n\\frac{1}{D_0^{\\mathrm{MeV}}} = \\sum_{J \\in \\{J_+, J_-\\}, J \\ge 0} \\rho(S_n, J) = \\rho(S_n) \\sum_{J \\in \\{J_+, J_-\\}, J \\ge 0} g(J, \\sigma)\n$$\n由此，可以从共振数据推断出在 $S_n$ 处的总能级密度：\n$$\n\\rho_{\\mathrm{res}}(S_n) = \\frac{1}{D_0^{\\mathrm{MeV}} \\left( \\sum_{J \\in \\{J_+, J_-\\}, J \\ge 0} g(J, \\sigma) \\right)}\n$$\n请注意，对于自旋为 $I=0$ 的靶核，$J_+=1/2$ 且 $J_-=-1/2$。由于自旋必须为非负，因此只考虑 $J=1/2$ 的态。\n\n**2. 验证计算**\n\n对于每个测试用例，我们执行两次验证计算。\n\n**2.1. 低能验证 ($\\delta_{\\mathrm{low}}$)**\n我们计算 CT 模型预测的直到匹配能量 $U_m$ 的累积能级数，并将其与已知的离散能级数 $N_d$ 进行比较。预测的能级数是 CT 密度的积分：\n$$\nN_{\\mathrm{CT}} = \\int_0^{U_m} \\rho_{\\mathrm{CT}}(U) \\, dU = \\int_0^{U_m} \\frac{1}{T_{\\mathrm{CT}}} \\exp\\left(\\frac{U - E_0}{T_{\\mathrm{CT}}}\\right) \\, dU\n$$\n该积分是解析的：\n$$\nN_{\\mathrm{CT}} = \\left[ \\exp\\left(\\frac{U - E_0}{T_{\\mathrm{CT}}}\\right) \\right]_0^{U_m} = \\exp\\left(\\frac{U_m - E_0}{T_{\\mathrm{CT}}}\\right) - \\exp\\left(\\frac{-E_0}{T_{\\mathrm{CT}}}\\right)\n$$\n然后计算分数偏差为 $\\delta_{\\mathrm{low}} = (N_{\\mathrm{CT}} - N_d) / N_d$。如果 $|\\delta_{\\mathrm{low}}| \\le \\tau_{\\mathrm{CT}} = 0.1$，则验证通过。\n\n**2.2. 高能验证 ($\\delta_{\\mathrm{high}}$)**\n我们使用 FG 模型计算从 $U_m$ 到 $S_n$ 能量范围内的能级数，并将其与从共振数据导出的参考计数进行比较。FG 模型给出的能级数是：\n$$\nN_{\\mathrm{FG}} = \\int_{U_m}^{S_n} \\rho_{\\mathrm{FG}}(U) \\, dU = \\int_{U_m}^{S_n} \\frac{\\sqrt{\\pi}}{12 a^{1/4} (U - \\delta)^{5/4}} \\exp(2\\sqrt{a(U - \\delta)}) \\, dU\n$$\n该积分必须进行数值计算。参考计数是通过首先使用提供的参数 $D_0$、$I$ 和 $\\sigma$ 计算如上所述的 $\\rho_{\\mathrm{res}}(S_n)$ 来构建的。然后，通过假设此密度代表了区间 $[U_m, S_n]$ 上的平均密度来估计一个有效参考计数 $N_{\\mathrm{ref}}$：\n$$\nN_{\\mathrm{ref}} = \\rho_{\\mathrm{res}}(S_n) \\times (S_n - U_m)\n$$\n分数偏差为 $\\delta_{\\mathrm{high}} = (N_{\\mathrm{FG}} - N_{\\mathrm{ref}}) / N_{\\mathrm{ref}}$。如果 $|\\delta_{\\mathrm{high}}| \\le \\tau_{\\mathrm{FG}} = 0.3$，则验证通过。\n\n现在将遵循这些推导出的公式和计算步骤进行实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Implements and validates the Gilbert-Cameron level density model.\n    \"\"\"\n    \n    # Test cases: A, T_CT, E0, a, delta, Um, Sn, Nd, I, sigma, D0\n    test_cases = [\n        # Case 1: A=60, T_CT=0.9, E0=1.5, a=7.5, delta=1.0, Um=4.5, Sn=8.0, Nd=28, I=0.0, sigma=3.0, D0=500.0\n        (60, 0.9, 1.5, 7.5, 1.0, 4.5, 8.0, 28, 0.0, 3.0, 500.0),\n        # Case 2: A=95, T_CT=0.7, E0=2.0, a=12.0, delta=1.1, Um=6.0, Sn=6.2, Nd=300, I=1.5, sigma=4.0, D0=200\n        (95, 0.7, 2.0, 12.0, 1.1, 6.0, 6.2, 300, 1.5, 4.0, 200.0),\n        # Case 3: A=200, T_CT=0.6, E0=1.0, a=25.0, delta=1.5, Um=2.5, Sn=5.5, Nd=12, I=0.5, sigma=6.0, D0=5.0\n        (200, 0.6, 1.0, 25.0, 1.5, 2.5, 5.5, 12, 0.5, 6.0, 5.0),\n    ]\n\n    results = []\n    \n    # Tolerance criteria\n    tau_ct = 0.1\n    tau_fg = 0.3\n\n    def g_spin_dist(J, sigma):\n        \"\"\"\n        Calculates the spin distribution factor g(J, sigma).\n        \"\"\"\n        if sigma = 0:\n            return 0.0\n        return (2 * J + 1) / (2 * sigma**2) * np.exp(-(J + 0.5)**2 / (2 * sigma**2))\n\n    def rho_fg(U, a, delta):\n        \"\"\"\n        Calculates the Fermi Gas level density rho_FG(U).\n        \"\"\"\n        U_eff = U - delta\n        if U_eff = 0:\n            # Below the effective ground state, density is zero.\n            return 0.0\n        \n        numerator = np.exp(2 * np.sqrt(a * U_eff)) * np.sqrt(np.pi)\n        denominator = 12 * (a**0.25) * (U_eff**1.25)\n        \n        if denominator == 0:\n            return np.inf\n\n        return numerator / denominator\n\n    for case in test_cases:\n        A, T_CT, E0, a, delta, Um, Sn, Nd, I, sigma, D0 = case\n\n        # 1. Low-energy validation (CT model)\n        # Analytically integrated level count from the CT model\n        N_ct = np.exp((Um - E0) / T_CT) - np.exp(-E0 / T_CT)\n        \n        # Fractional deviation\n        if Nd == 0:\n            delta_low = np.inf if N_ct != 0 else 0.0\n        else:\n            delta_low = (N_ct - Nd) / Nd\n        \n        pass_low = abs(delta_low) = tau_ct\n\n        # 2. High-energy validation (FG model)\n        # Numerically integrate FG density\n        N_fg, _ = integrate.quad(rho_fg, Um, Sn, args=(a, delta))\n\n        # Construct reference count from resonance data\n        # Convert D0 from eV to MeV\n        D0_mev = D0 * 1e-6\n        \n        # Calculate sum of spin distribution factors\n        J_plus = I + 0.5\n        J_minus = I - 0.5\n        \n        g_sum = g_spin_dist(J_plus, sigma)\n        if J_minus >= 0:\n            g_sum += g_spin_dist(J_minus, sigma)\n            \n        # Calculate total level density at Sn from resonance data\n        if D0_mev = 0 or g_sum = 0:\n            rho_res_sn = np.inf\n        else:\n            rho_res_sn = 1.0 / (D0_mev * g_sum)\n        \n        # Estimate reference count\n        N_ref = rho_res_sn * (Sn - Um)\n\n        # Fractional deviation\n        if N_ref == 0:\n            delta_high = np.inf if N_fg != 0 else 0.0\n        else:\n            delta_high = (N_fg - N_ref) / N_ref\n            \n        pass_high = abs(delta_high) = tau_fg\n        \n        results.append([delta_low, delta_high, pass_low, pass_high])\n\n    # Final print statement in the exact required format.\n    print('[' + ','.join([str(r).replace(' ', '') for r in results]) + ']')\n\nsolve()\n```"
        },
        {
            "introduction": "标准的吉尔伯特-卡梅伦模型在恒温模型和费米气体模型的连接点处，其导数存在不连续性，这会导致如微正则热容等导出物理量出现非物理行为。本高级实践旨在解决这一问题，通过引入双曲正切平滑函数来构建一个更符合物理实际的连续模型。在此基础上，您将进一步探索微正则热容 $C(U)$ 这一关键的热力学性质，并量化平滑处理对移除不连续性的效果。",
            "id": "3601178",
            "problem": "您需要实现、分析和量化 Gilbert–Cameron 混合能级密度模型中的微正则热容，方法是融合恒温（Constant-Temperature）和费米气体（Fermi-Gas）区域的斜率。所有数学符号、变量、函数、运算符和数字都必须按照通常的物理意义进行解释。能量单位使用兆电子伏特 (MeV)，温度单位使用兆电子伏特 (MeV)，玻尔兹曼常数设为1，因此微正则热容是无量纲的。\n\n出发点与定义：\n- 微正则熵定义为 $S(U)=\\ln \\rho(U)$，其中 $\\rho(U)$ 是作为激发能 $U$ 函数的能级密度。\n- 微正则温度定义为 $T_{\\mu}(U)=\\left(\\dfrac{dS}{dU}\\right)^{-1}$。\n- 微正则热容定义为 $C(U)=\\dfrac{dU}{dT_{\\mu}(U)}$。\n- 在恒温（CT）分支中，取 $S_{\\mathrm{CT}}(U)=\\dfrac{U-E_{0}}{T_{c}}+\\mathrm{const}$，其中 $T_{c}0$ 是常数，$E_{0}$ 是一个不影响导数的偏移量。\n- 在具有背移 $\\Delta$ 和能级密度参数 $a0$ 的费米气体（FG）分支中，使用经过充分检验的熵的前导渐近表达式，\n$$\nS_{\\mathrm{FG}}(U)=2\\sqrt{a\\,(U-\\Delta)}-\\frac{5}{4}\\ln(U-\\Delta)+\\mathrm{const}\\quad \\text{for } U\\Delta,\n$$\n该表达式给出的斜率（微正则逆温度）在 $U\\Delta$ 时是良好定义的。\n\n按如下方式构建 Gilbert–Cameron (GC) 混合模型：\n- 设混合过渡（匹配）能为 $U_{x}$，且 $U_{x}\\Delta$。通过在 $U_{x}$ 以下使用 CT 斜率，在 $U_{x}$ 以上使用 FG 斜率，来分段定义未平滑的混合斜率（微正则逆温度）$\\beta_{\\mathrm{hyb}}(U)=\\dfrac{dS}{dU}$，并通过选择 $T_{c}$ 来保证斜率在 $U_{x}$ 处的连续性：\n$$\n\\beta_{\\mathrm{CT}}=\\frac{1}{T_{c}},\\quad \\beta_{\\mathrm{FG}}(U)=\\frac{dS_{\\mathrm{FG}}}{dU},\\quad \\beta_{\\mathrm{hyb}}(U)=\n\\begin{cases}\n\\beta_{\\mathrm{CT}},  U\\le U_{x},\\\\\n\\beta_{\\mathrm{FG}}(U),  UU_{x},\n\\end{cases}\n$$\n其中 $T_{c}=\\left[\\beta_{\\mathrm{FG}}(U_{x})\\right]^{-1}$，从而使得 $\\beta_{\\mathrm{CT}}=\\beta_{\\mathrm{FG}}(U_{x})$。\n- 平滑斜率 $\\beta_{\\mathrm{sm}}(U)$ 通过在宽度参数 $\\Delta_{U}0$ 范围内对斜率进行双曲正切混合来构建：\n$$\nw(U)=\\frac{1}{2}\\left[1-\\tanh\\!\\left(\\frac{U-U_{x}}{\\Delta_{U}}\\right)\\right],\\qquad\n\\beta_{\\mathrm{sm}}(U)=w(U)\\,\\beta_{\\mathrm{CT}}+\\left[1-w(U)\\right]\\beta_{\\mathrm{FG}}(U).\n$$\n\n任务：\n1) 基于上述基础，推导用 $\\beta(U)=\\dfrac{dS}{dU}$ 及其导数 $\\beta'(U)=\\dfrac{d^{2}S}{dU^{2}}$ 表示的 $T_{\\mu}(U)$ 和 $C(U)$ 的公式，并实现未平滑混合与平滑（tanh混合）两种情况。所有能量单位必须为 $\\mathrm{MeV}$，所有温度单位必须为 $\\mathrm{MeV}$；将热容报告为无量纲值。\n2) 对于 FG 分支，从上面给出的 $S_{\\mathrm{FG}}(U)$ 出发，解析地计算 $U\\Delta$ 时的 $\\beta_{\\mathrm{FG}}(U)$ 和 $\\beta'_{\\mathrm{FG}}(U)$。使用这些结果来定义未平滑和已平滑的混合模型。对于 CT 分支，注意 $\\beta_{\\mathrm{CT}}$ 是常数，其导数为零。\n3) 使用一个包含 $N$ 个点的均匀能量网格 $U\\in[U_{x}-W,\\,U_{x}+W]$（其中 $N$ 是正整数，$W0$ 根据测试用例选择），评估以下用于衡量平滑处理对不连续性消除效果的定量诊断指标：\n   - 过渡点处未平滑混合模型的导数跳变，\n     $$\n     J_{1}=\\left|\\beta'_{\\mathrm{hyb}}(U_{x}^{-})-\\beta'_{\\mathrm{hyb}}(U_{x}^{+})\\right|.\n     $$\n   - 过渡点处相应的平滑混合模型的单边导数不匹配，由一个小的对称偏移量 $\\varepsilon0$ 近似，\n     $$\n     J_{2}=\\left|\\beta'_{\\mathrm{sm}}(U_{x}-\\varepsilon)-\\beta'_{\\mathrm{sm}}(U_{x}+\\varepsilon)\\right|.\n     $$\n   - 一个布尔值，指示在网格上未平滑混合模型的任何微正则热容值是否为非有限值（使用精确的解析导数；如果出现除以零的情况，则视为非有限值）。\n   - 一个布尔值，指示在网格上平滑混合模型的任何微正则热容值是否为非有限值。\n   - 网格上平滑微正则热容的绝对值的最大值，仅限于有限值。\n   - 过渡点处未平滑混合模型的微正则温度连续性误差，\n     $$\n     \\Delta T=\\left|T_{\\mu}(U_{x}-\\varepsilon)-T_{\\mu}(U_{x}+\\varepsilon)\\right|.\n     $$\n   使用与 $\\Delta_{U}$ 和 $W$ 相比很小的 $\\varepsilon$。\n4) 您的实现必须在所有测试用例中使用以下固定的数值设置以确保评估的一致性：在窗口内均匀选择 $N=2001$ 个点，并设置 $\\varepsilon=10^{-6}\\,\\mathrm{MeV}$。所有计算都必须以 $\\mathrm{MeV}$ 为单位进行。\n5) 对下面的每个测试用例，按上述顺序计算并返回包含六个诊断指标的列表。将所有用例的结果汇总到一个列表中。\n\n测试套件（每个元组为 $(a,\\Delta,U_{x},\\Delta_{U},W)$，所有能量单位为 $\\mathrm{MeV}$，$a$ 的单位为 $\\mathrm{MeV}^{-1}$）：\n- 用例 A: $(12.5,\\,1.0,\\,8.0,\\,0.5,\\,3.0)$。\n- 用例 B: $(20.0,\\,1.2,\\,6.0,\\,0.4,\\,2.0)$。\n- 用例 C: $(5.0,\\,1.8,\\,3.0,\\,0.3,\\,0.9)$。\n- 用例 D: $(25.0,\\,0.8,\\,12.0,\\,0.8,\\,4.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是按 $[J_{1},J_{2},\\text{any\\_inf\\_unsmoothed},\\text{any\\_inf\\_smoothed},\\max|C|_{\\mathrm{smoothed}},\\Delta T]$ 顺序排列的列表。例如，两个用例的有效输出应类似于 $[[x_{1},x_{2},b_{1},b_{2},x_{3},x_{4}],[y_{1},y_{2},b_{3},b_{4},y_{3},y_{4}]]$，其中 $x_{i},y_{i}$ 是实数，$b_{i}$ 是布尔值。",
            "solution": "该问题要求在 Gilbert-Cameron (GC) 混合能级密度模型内实现和分析微正则热容 $C(U)$。这涉及推导物理量的表达式，构建模型的未平滑版本和平滑版本，并为给定的参数集计算一组诊断指标。\n\n**任务1：温度和热容的通用公式**\n\n微正则熵由 $S(U) = \\ln \\rho(U)$ 给出，其中 $\\rho(U)$ 是激发能为 $U$ 时的能级密度。微正则逆温度 $\\beta(U)$ 是熵的斜率：\n$$\n\\beta(U) = \\frac{dS}{dU}\n$$\n根据此定义，可立即得到微正则温度 $T_{\\mu}(U)$ 为：\n$$\nT_{\\mu}(U) = \\left(\\frac{dS}{dU}\\right)^{-1} = \\frac{1}{\\beta(U)}\n$$\n微正则热容定义为 $C(U) = \\frac{dU}{dT_{\\mu}(U)}$。为了用 $\\beta(U)$ 及其导数 $\\beta'(U) = \\frac{d\\beta}{dU}$ 来表示它，我们首先使用链式法则计算 $T_{\\mu}(U)$ 对 $U$ 的导数：\n$$\n\\frac{dT_{\\mu}}{dU} = \\frac{d}{dU}\\left(\\frac{1}{\\beta(U)}\\right) = -\\frac{1}{\\beta(U)^2} \\frac{d\\beta}{dU} = -\\frac{\\beta'(U)}{\\beta(U)^2}\n$$\n热容是该量的倒数：\n$$\nC(U) = \\left(\\frac{dT_{\\mu}}{dU}\\right)^{-1} = -\\frac{\\beta(U)^2}{\\beta'(U)}\n$$\n只要模型中的 $\\beta(U)$ 及其导数 $\\beta'(U)$ 已知，这个基本关系式就允许计算热容。\n\n**任务2：费米气体（FG）模型的解析导数**\n\n对于 $U  \\Delta$，费米气体（FG）的熵由下式给出：\n$$\nS_{\\mathrm{FG}}(U) = 2\\sqrt{a(U-\\Delta)} - \\frac{5}{4}\\ln(U-\\Delta) + \\mathrm{const}\n$$\n其中 $a  0$ 是能级密度参数，$\\Delta$ 是背移。\n\n一阶导数 $\\beta_{\\mathrm{FG}}(U) = \\frac{dS_{\\mathrm{FG}}}{dU}$ 通过对 $U$ 求导得到：\n$$\n\\beta_{\\mathrm{FG}}(U) = \\frac{d}{dU} \\left[ 2\\sqrt{a}(U-\\Delta)^{1/2} - \\frac{5}{4}\\ln(U-\\Delta) \\right]\n$$\n$$\n\\beta_{\\mathrm{FG}}(U) = 2\\sqrt{a} \\cdot \\frac{1}{2}(U-\\Delta)^{-1/2} - \\frac{5}{4}(U-\\Delta)^{-1} = \\sqrt{\\frac{a}{U-\\Delta}} - \\frac{5}{4(U-\\Delta)}\n$$\n二阶导数 $\\beta'_{\\mathrm{FG}}(U) = \\frac{d\\beta_{\\mathrm{FG}}}{dU}$ 通过对 $\\beta_{\\mathrm{FG}}(U)$ 求导得到：\n$$\n\\beta'_{\\mathrm{FG}}(U) = \\frac{d}{dU} \\left[ \\sqrt{a}(U-\\Delta)^{-1/2} - \\frac{5}{4}(U-\\Delta)^{-1} \\right]\n$$\n$$\n\\beta'_{\\mathrm{FG}}(U) = \\sqrt{a} \\left(-\\frac{1}{2}\\right)(U-\\Delta)^{-3/2} - \\frac{5}{4}(-1)(U-\\Delta)^{-2} = -\\frac{\\sqrt{a}}{2(U-\\Delta)^{3/2}} + \\frac{5}{4(U-\\Delta)^2}\n$$\n对于恒温（CT）分支，熵为 $S_{\\mathrm{CT}}(U) = \\frac{U-E_0}{T_c} + \\mathrm{const}$。逆温度是常数，$\\beta_{\\mathrm{CT}} = \\frac{1}{T_c}$，其导数为零，$\\beta'_{\\mathrm{CT}} = 0$。\n\n**混合模型构建**\n\n该问题基于这些组件指定了两种混合模型。\n\n*   **未平滑混合模型：** 逆温度 $\\beta_{\\mathrm{hyb}}(U)$ 是分段定义的。对于 $U \\le U_x$，它使用 CT 形式；对于 $U  U_x$，它使用 FG 形式。通过设置 $\\beta_{\\mathrm{CT}} = \\beta_{\\mathrm{FG}}(U_x)$ 来强制实现 $\\beta(U)$ 在匹配能量 $U_x$ 处的连续性。因此，其导数 $\\beta'_{\\mathrm{hyb}}(U)$ 是不连续的：\n    $$\n    \\beta'_{\\mathrm{hyb}}(U) = \\begin{cases} \\beta'_{\\mathrm{CT}} = 0,  U  U_{x} \\\\ \\beta'_{\\mathrm{FG}}(U),  U  U_{x} \\end{cases}\n    $$\n    在 $U=U_x$ 处，由于跳变，导数未定义。\n\n*   **平滑混合模型：** 为了消除导数的不连续性，引入了双曲正切平滑。平滑的逆温度 $\\beta_{\\mathrm{sm}}(U)$ 是 CT 和 FG 斜率的加权平均值：\n    $$\n    \\beta_{\\mathrm{sm}}(U) = w(U)\\beta_{\\mathrm{CT}} + [1-w(U)]\\beta_{\\mathrm{FG}}(U)\n    $$\n    其中权重函数为 $w(U) = \\frac{1}{2}\\left[1-\\tanh\\left(\\frac{U-U_x}{\\Delta_U}\\right)\\right]$。其导数为 $w'(U) = -\\frac{1}{2\\Delta_U}\\text{sech}^2\\left(\\frac{U-U_x}{\\Delta_U}\\right)$。\n    使用乘法法则，导数 $\\beta'_{\\mathrm{sm}}(U)$ 为：\n    $$\n    \\beta'_{\\mathrm{sm}}(U) = \\frac{d}{dU}\\left(w(U)\\beta_{\\mathrm{CT}} + [1-w(U)]\\beta_{\\mathrm{FG}}(U)\\right)\n    $$\n    $$\n    \\beta'_{\\mathrm{sm}}(U) = w'(U)\\beta_{\\mathrm{CT}} - w'(U)\\beta_{\\mathrm{FG}}(U) + [1-w(U)]\\beta'_{\\mathrm{FG}}(U)\n    $$\n    $$\n    \\beta'_{\\mathrm{sm}}(U) = w'(U)[\\beta_{\\mathrm{CT}} - \\beta_{\\mathrm{FG}}(U)] + [1-w(U)]\\beta'_{\\mathrm{FG}}(U)\n    $$\n    只要 $U  \\Delta$，该表达式处处连续且良好定义。\n\n**任务3-5：诊断计算**\n\n对于每个测试用例 $(a, \\Delta, U_x, \\Delta_U, W)$，在一个包含 $N=2001$ 个点且使用 $\\varepsilon=10^{-6}\\,\\mathrm{MeV}$ 的均匀能量网格 $U \\in [U_x - W, U_x + W]$ 上计算以下六个诊断指标。\n\n1.  **$J_1$：未平滑导数跳变：** 该指标衡量 $\\beta'_{\\mathrm{hyb}}(U)$ 在 $U_x$ 处不连续性的幅度。\n    $$\n    J_1 = |\\beta'_{\\mathrm{hyb}}(U_x^{-}) - \\beta'_{\\mathrm{hyb}}(U_x^{+})| = |0 - \\beta'_{\\mathrm{FG}}(U_x)| = |\\beta'_{\\mathrm{FG}}(U_x)|\n    $$\n    我们使用 $\\beta'_{\\mathrm{FG}}(U)$ 的解析公式来计算它。\n\n2.  **$J_2$：平滑导数不匹配：** 该指标近似了平滑导数在 $U_x$ 附近变化的剧烈程度。\n    $$\n    J_2 = |\\beta'_{\\mathrm{sm}}(U_x - \\varepsilon) - \\beta'_{\\mathrm{sm}}(U_x + \\varepsilon)|\n    $$\n    我们使用在两个指定点上求值的 $\\beta'_{\\mathrm{sm}}(U)$ 的解析公式来计算它。\n\n3.  **未平滑混合模型中的非有限 $C(U)$：** 未平滑热容为 $C_{\\mathrm{hyb}}(U) = -\\beta_{\\mathrm{hyb}}(U)^2 / \\beta'_{\\mathrm{hyb}}(U)$。对于整个 CT 分支 ($U \\le U_x$)，$\\beta'_{\\mathrm{hyb}}(U) = 0$。由于能量网格包含该区域，将会发生除以零的情况。因此，该诊断指标将始终为 `True`。\n\n4.  **平滑混合模型中的非有限 $C(U)$：** 平滑热容为 $C_{\\mathrm{sm}}(U) = -\\beta_{\\mathrm{sm}}(U)^2 / \\beta'_{\\mathrm{sm}}(U)$。如果 $\\beta'_{\\mathrm{sm}}(U)$ 在网格上的任何一点变为零，就会出现非有限值。这通过在整个网格上计算 $C_{\\mathrm{sm}}(U)$ 并检查是否存在 `inf` 或 `nan` 值来进行数值检验。\n\n5.  **最大绝对平滑热容：** 这是在所有 $C_{\\mathrm{sm}}(U)$ 为有限值的网格点上计算的 $\\max|C_{\\mathrm{sm}}(U)|$。\n\n6.  **$\\Delta T$：温度连续性误差：** 该指标衡量未平滑模型在 $U_x$ 附近一个小区间 $2\\varepsilon$ 内的温度变化。\n    $$\n    \\Delta T = |T_{\\mu}(U_x - \\varepsilon) - T_{\\mu}(U_x + \\varepsilon)|\n    $$\n    对于未平滑混合模型，$T_{\\mu}(U_x - \\varepsilon) = 1/\\beta_{\\mathrm{hyb}}(U_x - \\varepsilon) = 1/\\beta_{\\mathrm{CT}}$ 且 $T_{\\mu}(U_x + \\varepsilon) = 1/\\beta_{\\mathrm{hyb}}(U_x + \\varepsilon) = 1/\\beta_{\\mathrm{FG}}(U_x+\\varepsilon)$。由于 $\\beta_{\\mathrm{CT}} = \\beta_{\\mathrm{FG}}(U_x)$，这变为：\n    $$\n    \\Delta T = \\left|\\frac{1}{\\beta_{\\mathrm{FG}}(U_x)} - \\frac{1}{\\beta_{\\mathrm{FG}}(U_x+\\varepsilon)}\\right|\n    $$\n    该值使用 $\\beta_{\\mathrm{FG}}(U)$ 的公式直接计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes the microcanonical heat capacity in the\n    Gilbert-Cameron hybrid level-density model.\n    \"\"\"\n\n    # Helper functions for Fermi-Gas (FG) model quantities\n    def beta_fg(U, a, delta):\n        \"\"\"Calculates beta_FG(U) = dS_FG/dU.\"\"\"\n        term = U - delta\n        # Ensure term > 0 for physical validity\n        safe_term = np.where(term > 0, term, np.nan)\n        return np.sqrt(a / safe_term) - (5.0 / 4.0) / safe_term\n\n    def beta_prime_fg(U, a, delta):\n        \"\"\"Calculates beta'_FG(U) = d^2S_FG/dU^2.\"\"\"\n        term = U - delta\n        # Ensure term > 0 for physical validity\n        safe_term = np.where(term > 0, term, np.nan)\n        return -0.5 * np.sqrt(a) * safe_term**(-1.5) + (5.0 / 4.0) * safe_term**(-2.0)\n\n    # Helper functions for the smoothed model\n    def w_func(U, Ux, delta_U):\n        \"\"\"Calculates the smoothing weight function w(U).\"\"\"\n        return 0.5 * (1.0 - np.tanh((U - Ux) / delta_U))\n\n    def w_prime_func(U, Ux, delta_U):\n        \"\"\"Calculates the derivative of the weight function w'(U).\"\"\"\n        arg = (U - Ux) / delta_U\n        return -0.5 / delta_U * (1.0 / np.cosh(arg))**2\n\n    def beta_sm(U, Ux, delta_U, a, delta, beta_ct):\n        \"\"\"Calculates the smoothed inverse temperature beta_sm(U).\"\"\"\n        w = w_func(U, Ux, delta_U)\n        b_fg = beta_fg(U, a, delta)\n        return w * beta_ct + (1.0 - w) * b_fg\n\n    def beta_prime_sm(U, Ux, delta_U, a, delta, beta_ct):\n        \"\"\"Calculates the derivative of the smoothed inverse temperature beta'_sm(U).\"\"\"\n        w = w_func(U, Ux, delta_U)\n        w_p = w_prime_func(U, Ux, delta_U)\n        b_fg = beta_fg(U, a, delta)\n        b_p_fg = beta_prime_fg(U, a, delta)\n        return w_p * (beta_ct - b_fg) + (1.0 - w) * b_p_fg\n\n    # Fixed numerical settings\n    N = 2001\n    epsilon = 1.0e-6\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, delta, Ux, delta_U, W)\n        (12.5, 1.0, 8.0, 0.5, 3.0),  # Case A\n        (20.0, 1.2, 6.0, 0.4, 2.0),  # Case B\n        (5.0, 1.8, 3.0, 0.3, 0.9),   # Case C\n        (25.0, 0.8, 12.0, 0.8, 4.0), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        a, delta, Ux, delta_U, W = case\n\n        # --- Diagnostic 1: J1 (Unsmoothed derivative jump) ---\n        # J1 = |beta'_hyb(Ux-) - beta'_hyb(Ux+)| = |0 - beta'_fg(Ux)|\n        beta_p_fg_at_Ux = beta_prime_fg(Ux, a, delta)\n        J1 = np.abs(beta_p_fg_at_Ux)\n\n        # --- Diagnostic 2: J2 (Smoothed derivative mismatch) ---\n        # J2 = |beta'_sm(Ux - eps) - beta'_sm(Ux + eps)|\n        beta_ct = beta_fg(Ux, a, delta)\n        beta_p_sm_minus = beta_prime_sm(Ux - epsilon, Ux, delta_U, a, delta, beta_ct)\n        beta_p_sm_plus = beta_prime_sm(Ux + epsilon, Ux, delta_U, a, delta, beta_ct)\n        J2 = np.abs(beta_p_sm_minus - beta_p_sm_plus)\n\n        # --- Diagnostic 3: any_inf_unsmoothed ---\n        # C_unsmoothed = -beta_hyb^2 / beta'_hyb. For U = Ux, beta'_hyb is 0.\n        # The grid always contains points = Ux, causing division by zero.\n        any_inf_unsmoothed = True\n\n        # --- Diagnostics 4  5: Smoothed heat capacity analysis ---\n        U_grid = np.linspace(Ux - W, Ux + W, N)\n        \n        # Calculate smoothed beta and its derivative on the grid\n        b_sm_grid = beta_sm(U_grid, Ux, delta_U, a, delta, beta_ct)\n        b_p_sm_grid = beta_prime_sm(U_grid, Ux, delta_U, a, delta, beta_ct)\n        \n        # Calculate smoothed heat capacity, ignoring division by zero warnings\n        with np.errstate(divide='ignore', invalid='ignore'):\n            C_sm_grid = -np.square(b_sm_grid) / b_p_sm_grid\n            \n        # Diagnostic 4: any_inf_smoothed\n        any_inf_smoothed = not np.all(np.isfinite(C_sm_grid))\n        \n        # Diagnostic 5: max|C|_smoothed\n        finite_C_sm = C_sm_grid[np.isfinite(C_sm_grid)]\n        if finite_C_sm.size > 0:\n            max_abs_C_smoothed = np.max(np.abs(finite_C_sm))\n        else:\n            max_abs_C_smoothed = 0.0\n\n        # --- Diagnostic 6: Delta T (Temperature continuity error) ---\n        # Delta T = |T_mu(Ux - eps) - T_mu(Ux + eps)| for unsmoothed hybrid\n        # T_mu(U) = 1/beta_hyb(U). T_mu(Ux - eps) = 1/beta_ct\n        T_mu_minus = 1.0 / beta_ct \n        # T_mu(Ux + eps) = 1/beta_fg(Ux + eps)\n        T_mu_plus = 1.0 / beta_fg(Ux + epsilon, a, delta)\n        delta_T = np.abs(T_mu_minus - T_mu_plus)\n        \n        # Assemble results for the current test case\n        case_results = [J1, J2, any_inf_unsmoothed, any_inf_smoothed, max_abs_C_smoothed, delta_T]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print('[' + ','.join([str(r).replace(' ', '') for r in results]) + ']')\n\nsolve()\n```"
        }
    ]
}