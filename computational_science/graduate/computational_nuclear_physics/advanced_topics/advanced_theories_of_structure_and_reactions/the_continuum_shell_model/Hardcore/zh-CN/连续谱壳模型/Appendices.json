{
    "hands_on_practices": [
        {
            "introduction": "在进行任何大规模的连续谱壳模型（CSM）计算之前，首要且基础的一步是明确定义多体模型的希尔伯特空间。这个练习将引导你亲手构建一个简化的双中子系统的模型空间，并计算其维度。通过这个过程，你将加深对Berggren基如何构成——即束缚态、共振态和离散化的散射连续谱态如何共同构成单粒子基础，以及泡利不相容原理如何决定最终多体基矢数量的理解。",
            "id": "3597504",
            "problem": "考虑连续谱壳模型（CSM），也称为 Gamow 壳模型（GSM），对于一个惰性核心外的 $2$ 个价中子系统。假设平均场是球对称的，因此单粒子态由轨道角动量 $l$、总角动量 $j$ 及其投影 $m$ 标记。单粒子基是在 Berggren 集合中构建的，截至单粒子能量截断 $E_{\\max}$，该截断包括了以下分波在 $E_{\\max}$ 以下的所有极点态（束缚态或共振态）：$s_{1/2}$、$p_{1/2}$、$p_{3/2}$、$d_{3/2}$ 和 $d_{5/2}$。具体来说，在此截断内，有 $1$ 个 $s_{1/2}$ 束缚极点、$1$ 个 $d_{5/2}$ 束缚极点和 $1$ 个 $p_{3/2}$ 共振极点；在所列出的通道中，$E_{\\max}$ 以下没有其他极点。每个所列分波的非共振散射连续谱都沿着一条围道离散化为恰好 $N_c$ 个径向散射态，每个分波的离散化方式相同。一个 $(l,j)$ 通道中的每个径向态都具有其完整的磁简并度 $(2j+1)$。\n\n忽略质心考虑以及对双中子系统的总角动量或宇称的任何限制。使用上述空间中的所有单粒子态，为这 $2$ 个中子构建反对称化斯莱特行列式（Slater determinants）的多体 $M$-方案基。从泡利不相容原理和单粒子磁亚态的基本计数出发，推导总基矢维度 $D(N_c)$ 作为 $N_c$ 函数的闭式表达式。你的最终答案必须是单一的解析表达式。不要进行任何数值近似或四舍五入；不需要单位。",
            "solution": "该问题要求在连续谱壳模型框架内，根据给定的特定单粒子空间，推导双中子多体 M-方案基的总维度的闭式表达式。\n\n验证问题陈述的有效性是必须的第一步。\n\n### 步骤 1：提取给定信息\n- 系统：惰性核心外的 $2$ 个价中子。\n- 模型：连续谱壳模型 (CSM) / Gamow 壳模型 (GSM)。\n- 平均场：球对称。\n- 单粒子态由 $(l, j, m)$ 标记。\n- 单粒子基：Berggren 集合，截至能量截断 $E_{\\max}$。\n- 包含的分波：$s_{1/2}$、$p_{1/2}$、$p_{3/2}$、$d_{3/2}$ 和 $d_{5/2}$。\n- $E_{\\max}$ 以下的极点态：\n  - $1$ 个 $s_{1/2}$ 束缚极点。\n  - $1$ 个 $d_{5/2}$ 束缚极点。\n  - $1$ 个 $p_{3/2}$ 共振极点。\n- 非共振连续谱态：\n  - 对于每个所列分波，离散化为恰好 $N_c$ 个径向散射态。\n- 简并度：一个 $(l,j)$ 通道中的每个径向态具有 $(2j+1)$ 的磁简并度。\n- 多体基：针对 $2$ 个中子的反对称化斯莱特行列式 (M-方案)。\n- 忽略的约束：质心考虑、对总角动量和宇称的限制。\n- 目标：推导总基矢维度 $D(N_c)$ 的闭式表达式。\n\n### 步骤 2：使用提取的信息进行验证\n根据既定标准对问题进行评估。\n- **科学基础**：该问题设置在连续谱壳模型（或 Gamow 壳模型）的标准理论框架内，这是一种计算核物理学中用于描述弱束缚和非束缚原子核的成熟方法。Berggren 集合、单粒子态、极点态（束缚态和共振态）、离散化连续谱、M-方案基和斯莱特行列式等概念都是基础且科学合理的。\n- **适定性**：问题定义清晰。它指定了粒子数（$2$ 个中子）、构建多体基所依据的完整单粒子空间，以及构建基的方法（M-方案）。目标是找到总维度，这是一个唯一定义的量。所有必要信息都已提供。\n- **客观性**：问题使用核物理领域通用的精确技术语言进行陈述。没有主观或含糊的术语。\n\n该问题没有表现出任何科学不合理、不完整、矛盾或含糊不清等缺陷。它代表了核结构理论中一个标准的、尽管是简化的组合问题。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个合理的解答。\n\n问题要求计算一个由 $N=2$ 个相同费米子（中子）组成的系统的 M-方案基的总维度。多体基是由一组跨越特定模型空间的单粒子态构建的。在 M-方案中，一个基矢态是通过占据一组唯一的单粒子态而形成的斯莱特行列式。这种态的总数，即多体空间的维度，等于从可用的单粒子态总数 $N_{sp}$ 中选择 $N$ 个不同单粒子态的方式数。\n\n这是一个经典的组合问题，维度 $D$ 由二项式系数给出：\n$$\nD = \\binom{N_{sp}}{N}\n$$\n鉴于我们有 $N=2$ 个中子，维度为：\n$$\nD(N_c) = \\binom{N_{sp}}{2} = \\frac{N_{sp}(N_{sp}-1)}{2}\n$$\n核心任务是确定单粒子态的总数 $N_{sp}$，作为 $N_c$ 的函数。单粒子空间由极点态和离散化的连续谱态组成。每个态都由其量子数表征，包括磁投影量子数 $m$，对于总角动量为 $j$ 的态， $m$ 可以取 $2j+1$ 个值。\n\n首先，我们计算由极点态贡献的磁亚态数量。\n- $1$ 个 $s_{1/2}$ 束缚极点：对于此态，$j=1/2$。磁亚态的数量为 $2j+1 = 2(1/2) + 1 = 2$。\n- $1$ 个 $d_{5/2}$ 束缚极点：对于此态，$j=5/2$。磁亚态的数量为 $2j+1 = 2(5/2) + 1 = 6$。\n- $1$ 个 $p_{3/2}$ 共振极点：对于此态，$j=3/2$。磁亚态的数量为 $2j+1 = 2(3/2) + 1 = 4$。\n\n来自极点态的单粒子态总数 $N_{\\text{poles}}$ 是这些简并度的总和：\n$$\nN_{\\text{poles}} = 2 + 6 + 4 = 12\n$$\n接下来，我们计算由离散化的非共振连续谱贡献的磁亚态数量。问题陈述，对于每个指定的分波，有 $N_c$ 个径向散射态。我们必须对所有这些分波的贡献求和。\n- $s_{1/2}$ 连续谱：$j=1/2$，因此每个径向态的简并度为 $2j+1=2$。总态数：$N_c \\times 2 = 2N_c$。\n- $p_{1/2}$ 连续谱：$j=1/2$，因此每个径向态的简并度为 $2j+1=2$。总态数：$N_c \\times 2 = 2N_c$。\n- $p_{3/2}$ 连续谱：$j=3/2$，因此每个径向态的简并度为 $2j+1=4$。总态数：$N_c \\times 4 = 4N_c$。\n- $d_{3/2}$ 连续谱：$j=3/2$，因此每个径向态的简并度为 $2j+1=4$。总态数：$N_c \\times 4 = 4N_c$。\n- $d_{5/2}$ 连续谱：$j=5/2$，因此每个径向态的简并度为 $2j+1=6$。总态数：$N_c \\times 6 = 6N_c$。\n\n来自连续谱的单粒子态总数 $N_{\\text{cont}}$ 是这些贡献的总和：\n$$\nN_{\\text{cont}} = 2N_c + 2N_c + 4N_c + 4N_c + 6N_c = (2+2+4+4+6)N_c = 18N_c\n$$\n单粒子态的总数 $N_{sp}$ 是极点态和连续谱态贡献的总和：\n$$\nN_{sp} = N_{\\text{poles}} + N_{\\text{cont}} = 12 + 18N_c\n$$\n现在我们可以将这个 $N_{sp}$ 的表达式代入双粒子维度 $D(N_c)$ 的公式中：\n$$\nD(N_c) = \\frac{N_{sp}(N_{sp}-1)}{2} = \\frac{(12 + 18N_c)((12 + 18N_c) - 1)}{2}\n$$\n$$\nD(N_c) = \\frac{(12 + 18N_c)(11 + 18N_c)}{2}\n$$\n我们可以从分子的第一项中提出一个因子 $2$：\n$$\nD(N_c) = \\frac{2(6 + 9N_c)(11 + 18N_c)}{2} = (6 + 9N_c)(11 + 18N_c)\n$$\n展开这个乘积，得到维度的最终多项式表达式：\n$$\nD(N_c) = 6 \\cdot 11 + 6 \\cdot (18N_c) + (9N_c) \\cdot 11 + (9N_c) \\cdot (18N_c)\n$$\n$$\nD(N_c) = 66 + 108N_c + 99N_c + 162N_c^2\n$$\n合并同类项并按 $N_c$ 的幂次排序，我们得到闭式表达式：\n$$\nD(N_c) = 162N_c^2 + 207N_c + 66\n$$\n这个表达式表示了可以从给定的单粒子 Berggren 基构建的双中子斯莱特行列式的总数，它是每个分波的离散化连续谱态数 $N_c$ 的函数。",
            "answer": "$$\n\\boxed{162N_c^2 + 207N_c + 66}\n$$"
        },
        {
            "introduction": "连续谱壳模型的核心优势在于其对开放量子系统中非束缚态的精确处理，而这依赖于对复动量平面上积分轮廓的数值实现。这个实践练习将带你深入CSM计算的核心技术，通过编写代码来数值求解一个单粒子束缚态问题，并研究其结果如何随轮廓离산化的精度收敛。完成此练习将使你掌握处理Berggren基中连续谱部分的基本数值方法，这是所有CSM应用不可或缺的一项技能。",
            "id": "3597500",
            "problem": "考虑一个在连续谱壳模型框架下的单体哈密顿量，它在动量表象中表述，并针对单个分波（s-波）采用 $\\hbar^2/(2\\mu) = 1$ 的单位约定。动能算符为 $T$，其本征值为 $k^2$。相互作用是一个秩一可分离势 $V(k,k') = -\\lambda\\, g(k)\\, g(k')$，其中 $g(k) = \\frac{1}{k^2 + \\beta^2}$，且 $\\lambda > 0$ 和 $\\beta > 0$ 是固定参数。在伽莫夫壳模型（GSM）中，连续谱通过 Berggren 系综来处理，其中散射态沿着复 $k$ 平面中的一条复动量围道 $L^+$ 进行积分。\n\n通过求解齐次动量空间薛定谔方程，可以构建一个能量为 $E  0$ 的束缚态解。假设一个与势结构兼容的可分离拟设，并使用 s-波 Berggren 度规（即复对称积或 c-积，不含复共轭），束缚态能量条件简化为一个关于衰变常数 $\\kappa  0$ 的自洽方程，该常数通过 $E = -\\kappa^2$ 定义。该自洽方程涉及围道积分\n$$\nJ(\\kappa) = \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)}.\n$$\n方程 $1 - \\lambda J(\\kappa) = 0$ 的一个解 $\\kappa$ 会产生一个能量为 $E = -\\kappa^2$ 的束缚态。相应的（未归一化的）动量空间波函数正比于\n$$\n\\phi(k) \\propto \\frac{g(k)}{E - k^2} = -\\frac{1}{\\left(k^2 + \\beta^2\\right)\\left(\\kappa^2 + k^2\\right)}.\n$$\n在 Berggren 度规中，这个未归一化态的范数是\n$$\nS(\\kappa) = \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)^2},\n$$\n这是一个无量纲量。数值计算通过离散化 $L^+$ 并用求积法近似积分来进行。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n1.  在复动量平面中构建一个双段 Berggren 围道 $L^+$：\n    *   段 1：沿实轴从 $k = 0$ 到 $k = k_{\\mathrm{peak}}$。\n    *   段 2：沿一条从 $k = k_{\\mathrm{peak}}$ 开始的直线，其终点为 $k = k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$，其中 $\\theta$ 是向下半平面的旋转角度（以度为单位指定）。\n2.  用高斯-勒让德求积法离散化每个段，并包含每段参数化对应的雅可比（Jacobian）导数 $\\mathrm{d}k/\\mathrm{d}s$。\n3.  对于给定的一组参数，在实区间上使用求根算法求解 $\\kappa$，使得 $1 - \\lambda J(\\kappa) = 0$ 成立，其中 $J(\\kappa)$ 是使用上述离散化沿 $L^+$ 计算的。\n4.  使用相同的围道离散化方法，计算束缚态能量 $E = -\\kappa^2$ 和未归一化的 Berggren 范数 $S(\\kappa)$。\n5.  生成最终输出，形式为一行包含指定测试套件的结果列表，其中每个结果是一个由浮点数组成的二元列表 $[E, S]$。\n\n基本出发点：\n- 动量空间薛定谔方程 $(E - k^2) \\phi(k) = \\int \\mathrm{d}k' \\, k'^2 \\, V(k,k') \\, \\phi(k')$，其中 s-波动能为 $k^2$。\n- 秩一可分离势 $V(k,k') = -\\lambda g(k) g(k')$，其中 $g(k) = \\frac{1}{k^2 + \\beta^2}$。\n- s-波的 Berggren 系综完备性与 c-积，这使得使用复围道 $L^+$ 积分处理散射贡献和伽莫夫态是合理的。\n\n角度单位说明：旋转角 $\\theta$ 必须按度解释。\n\n单位：\n- 所有动量 $k$、衰变常数 $\\kappa$ 以及参数 $\\beta$、$k_{\\mathrm{peak}}$、$k_{\\max}$ 均采用与 $\\hbar^2/(2\\mu) = 1$ 一致的逆长度单位。\n- 能量 $E$ 必须以这些相同的自然单位表示，输出应将能量值呈现为浮点数。\n- 范数 $S$ 是无量纲的，应呈现为浮点数。\n\n测试套件：\n在所有测试中，对相互作用和围道形状使用以下固定参数：\n- $\\lambda = 10.0$（无量纲耦合强度）。\n- $\\beta = 1.0$（逆长度单位）。\n- $k_{\\mathrm{peak}} = 2.0$（逆长度单位）。\n- $\\theta = 30$（度）。\n\n改变离散化密度和 $k_{\\max}$ 来展示收敛性：\n- 测试用例 A：总求积点数 $N = 40$， $k_{\\max} = 4.0$。\n- 测试用例 B：总求积点数 $N = 80$， $k_{\\max} = 8.0$。\n- 测试用例 C：总求积点数 $N = 160$， $k_{\\max} = 12.0$。\n- 测试用例 D：总求积点数 $N = 160$， $k_{\\max} = 8.0$。\n- 测试用例 E：总求积点数 $N = 80$， $k_{\\max} = 12.0$。\n\n算法要求：\n- 高斯-勒让德节点 $s_i \\in [-1,1]$ 和权重 $w_i$ 必须通过 $k(s) = \\frac{z_1 + z_0}{2} + \\frac{z_1 - z_0}{2} s$ 映射到每个围道段，其中 $z_0$ 和 $z_1$ 是段的复数端点，复雅可比（Jacobian）导数为 $\\frac{\\mathrm{d}k}{\\mathrm{d}s} = \\frac{z_1 - z_0}{2}$。\n- $L^+$ 上的积分通过对所有段求和 $\\sum_i w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s} f(k(s_i))$ 来近似，并保留复数权重。为确保能量解为实值，在构建 $J(\\kappa)$ 和 $S(\\kappa)$ 时，应取计算所得积分的实部，因为离散化会引入微小的数值虚部。\n\n最终输出：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个条目，每个条目本身是一个二元列表 $[E, S]$。例如：\n\"[[E_A,S_A],[E_B,S_B],[E_C,S_C],[E_D,S_D],[E_E,S_E]]\"\n其中每个 $E$ 是计算出的自然单位下的束缚态能量，每个 $S$ 是无量纲的未归一化 Berggren 范数。\n\n该程序必须是自包含的，并且不得读取任何输入；它必须使用上面提供的参数，计算五个测试用例的结果，并严格按照指定格式打印最终列表。",
            "solution": "我们从动量空间薛定谔方程出发，该方程针对单个 s-波分量，并采用 $\\hbar^2/(2\\mu) = 1$ 的单位制：\n$$\n(E - k^2) \\phi(k) = \\int_0^\\infty \\mathrm{d}k'\\, k'^2 \\, V(k,k') \\, \\phi(k').\n$$\n我们使用一个秩一可分离势 $V(k,k') = -\\lambda g(k) g(k')$，其中 $g(k) = \\frac{1}{k^2 + \\beta^2}$，且 $\\lambda0$ 和 $\\beta0$ 是固定参数。对于一个能量为 $E  0$ 的束缚态，采用与该势兼容的可分离拟设：\n$$\n\\phi(k) = A \\frac{g(k)}{E - k^2},\n$$\n将其代入齐次方程得到：\n$$\nA = -\\lambda A \\int_0^\\infty \\mathrm{d}k' \\, k'^2 \\, \\frac{g^2(k')}{E - k'^2}.\n$$\n假设 $A \\neq 0$，能量条件为：\n$$\n1 = -\\lambda \\int_0^\\infty \\mathrm{d}k'\\, k'^2 \\frac{g^2(k')}{E - k'^2}.\n$$\n对于束缚态，令 $E = -\\kappa^2$，其中 $\\kappa0$。那么 $E - k'^2 = -(\\kappa^2 + k'^2)$，积分变为：\n$$\n\\int_0^\\infty \\mathrm{d}k' \\, k'^2 \\frac{g^2(k')}{E - k'^2} = -\\int_0^\\infty \\mathrm{d}k' \\, \\frac{k'^2}{(k'^2 + \\beta^2)^2 (\\kappa^2 + k'^2)}.\n$$\n因此，束缚态条件是：\n$$\n1 = \\lambda \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)} \\equiv \\lambda J(\\kappa),\n$$\n这里我们定义了\n$$\nJ(\\kappa) = \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)}.\n$$\n在伽莫夫壳模型（GSM）中，散射态和伽莫夫态通过 Berggren 系综处理，将实轴积分替换为复 $k$ 平面中的一条围道 $L^+$。该围道包含一段沿实轴延伸至 $k_{\\mathrm{peak}}$ 的路径，然后是一段旋转进入复平面的直线段，终点为 $k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$（$\\theta0$）。这里使用 c-积（复对称内积），因此在计算范数或矩阵元时，积分中不进行复共轭。在满足解析性和衰减性的条件下，沿 $L^+$ 的积分等于原始的实轴积分，但我们在数值上通过离散化 $L^+$ 来近似这些量：\n$$\nJ(\\kappa) \\approx \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)},\n$$\n其中每个段由 $k(s) = \\frac{z_1 + z_0}{2} + \\frac{z_1 - z_0}{2} s$ 参数化，其中 $s \\in [-1,1]$，端点为 $z_0$ 和 $z_1$，高斯-勒让德节点和权重为 $s_i$ 和 $w_i$。雅可比因子 $\\frac{\\mathrm{d}k}{\\mathrm{d}s} = \\frac{z_1 - z_0}{2}$ 对于旋转段是复数。虽然对于 $\\kappa0$ 的精确积分是实数，但沿复围道的离散化会引入微小的虚部；取求积和的实部可以得到一个实值近似，适用于求根：\n$$\n\\operatorname{Re}\\, J(\\kappa) \\approx \\operatorname{Re}\\left( \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)} \\right).\n$$\n我们通过求解标量非线性方程来找到 $\\kappa$：\n$$\nf(\\kappa) \\equiv 1 - \\lambda\\, \\operatorname{Re}\\, J(\\kappa) = 0,\n$$\n在一个区间上求解，例如 $\\kappa \\in [\\kappa_{\\min}, \\kappa_{\\max}]$，其中 $\\kappa_{\\min} \\ll 1$ 且 $\\kappa_{\\max}$ 足够大（例如，与 $k_{\\max}$ 同量级）。被积函数在 $k=0$ 处表现良好，并在 $k$ 很大时按 $k^{-4}$ 衰减，确保了收敛性。\n\n一旦求得 $\\kappa$，束缚态能量即为 $E = -\\kappa^2$。为评估态归一化的收敛性，我们计算未归一化的 Berggren 范数：\n$$\nS(\\kappa) \\equiv \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)^2} \\approx \\operatorname{Re}\\left( \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)^2} \\right),\n$$\n这是一个无量纲量。如果通过选择一个前置因子 $A$ 使得在 c-积中 $\\int_{L^+} \\mathrm{d}k\\, k^2\\, \\phi(k)^2 = 1$ 来归一化该态，那么 $A = 1/\\sqrt{S(\\kappa)}$。然而，这里我们直接报告 $S(\\kappa)$ 以展示数值收敛行为。\n\n算法步骤：\n1.  构建具有两段的围道 $L^+$：\n    *   段 1：$z_0^{(1)} = 0$，$z_1^{(1)} = k_{\\mathrm{peak}}$（均为实数）。\n    *   段 2：$z_0^{(2)} = k_{\\mathrm{peak}}$，$z_1^{(2)} = k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$，其中 $\\theta$ 以度为单位，需转换为弧度。\n2.  对于一个给定的总求积点数 $N$，将其分为段 1 上的 $N_1 = \\lfloor N/2 \\rfloor$ 个点和段 2 上的 $N_2 = N - N_1$ 个点。对每个段，获取高斯-勒让德节点和权重 $\\{s_i,w_i\\}$，并将其映射到复动量 $k_i$ 和复权重 $W_i = w_i\\, \\frac{z_1 - z_0}{2}$。\n3.  将函数 $J(\\kappa)$ 和 $S(\\kappa)$ 定义为相应被积函数的复加权和，并取其实部。\n4.  对 $f(\\kappa) = 1 - \\lambda \\operatorname{Re} J(\\kappa)$ 使用一个稳健的区间求根方法，区间可选为 $[\\kappa_{\\min}, \\kappa_{\\max}] = [10^{-6}, k_{\\max}]$；对于吸引势且 $\\lambda$ 足够大（如所提供的测试参数），确保 $f(\\kappa_{\\min})  0$ 且 $f(\\kappa_{\\max})  0$。\n5.  计算 $E = -\\kappa^2$，并计算 $S(\\kappa)$。\n6.  对每个具有不同 $N$ 和 $k_{\\max}$ 的测试用例重复步骤 2-5，以展示随着离散化密度和 $k_{\\max}$ 变化时 $E$ 和 $S$ 的收敛行为。\n\n解析参考：\n对于所选的可分离形式，沿实轴的积分 $J(\\kappa)$ 可以通过部分分式分解得到一个闭合形式表达式：\n$$\nJ(\\kappa) = \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)}\n= \\frac{\\pi}{2\\beta} \\frac{\\kappa^2}{(\\kappa^2 - \\beta^2)^2} - \\frac{\\pi}{4\\beta} \\frac{1}{\\kappa^2 - \\beta^2} - \\frac{\\pi}{2} \\frac{\\kappa}{(\\kappa^2 - \\beta^2)^2},\n$$\n这可用于通过在实轴上求解 $1 = \\lambda J(\\kappa)$ 来验证数值解。在实践中，随着点数和 $k_{\\max}$ 的增加，此处使用的复围道离散化方法会再现此结果。\n\n输出：\n对于每个测试用例 A-E，程序输出一对 $[E,S]$，其中 $E$ 是自然单位下的束缚态能量， $S$ 是无量纲的未归一化 Berggren 范数。最终输出为单行：\n\"[[E_A,S_A],[E_B,S_B],[E_C,S_C],[E_D,S_D],[E_E,S_E]]\"。\n\n此设计将基础的薛定谔方程与 Berggren 系综离散化相结合，以展示在连续谱壳模型框架下的收敛行为。",
            "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.optimize import root_scalar\n\ndef build_contour(k_peak, k_max, theta_deg, N_total):\n    \"\"\"\n    Construct L^+ with two segments:\n      Segment 1: 0 - k_peak (real axis)\n      Segment 2: k_peak - k_peak + (k_max - k_peak) * exp(-i * theta)\n    Returns arrays of complex k points and complex quadrature weights W_i.\n    \"\"\"\n    # Convert angle to radians\n    theta = np.deg2rad(theta_deg)\n\n    # Segment endpoints\n    z0_1 = 0.0 + 0.0j\n    z1_1 = complex(k_peak, 0.0)\n    z0_2 = complex(k_peak, 0.0)\n    z1_2 = complex(k_peak, 0.0) + (k_max - k_peak) * np.exp(-1j * theta)\n\n    # Split total points between segments\n    N1 = N_total // 2\n    N2 = N_total - N1\n    if N1  2:  # minimal points per segment to avoid pathological quadrature\n        N1 = 2\n        N2 = max(2, N_total - N1)\n\n    # Gauss-Legendre nodes and weights on [-1,1]\n    s1, w1 = leggauss(N1)\n    s2, w2 = leggauss(N2)\n\n    # Map nodes to segment 1\n    dkds_1 = (z1_1 - z0_1) / 2.0\n    k1 = (z1_1 + z0_1) / 2.0 + dkds_1 * s1\n    W1 = w1 * dkds_1\n\n    # Map nodes to segment 2\n    dkds_2 = (z1_2 - z0_2) / 2.0\n    k2 = (z1_2 + z0_2) / 2.0 + dkds_2 * s2\n    W2 = w2 * dkds_2\n\n    # Concatenate\n    k_points = np.concatenate([k1, k2])\n    weights = np.concatenate([W1, W2])\n\n    return k_points, weights\n\ndef J_discrete(kappa, beta, k_points, weights):\n    \"\"\"\n    Compute J(kappa) = ∫_{L+} dk k^2/[(k^2+beta^2)^2 (kappa^2 + k^2)]\n    using complex quadrature along L^+.\n    Returns the real part of the quadrature sum to mitigate small numerical Im parts.\n    \"\"\"\n    k = k_points\n    W = weights\n    k2 = k * k\n    denom1 = (k2 + beta**2)\n    integrand = (k2) / (denom1 * denom1 * (kappa**2 + k2))\n    val = np.sum(W * integrand)\n    return float(np.real(val))\n\ndef S_discrete(kappa, beta, k_points, weights):\n    \"\"\"\n    Compute S(kappa) = ∫_{L+} dk k^2/[(k^2+beta^2)^2 (kappa^2 + k^2)^2]\n    using complex quadrature along L^+.\n    Returns the real part of the quadrature sum.\n    \"\"\"\n    k = k_points\n    W = weights\n    k2 = k * k\n    denom1 = (k2 + beta**2)\n    integrand = (k2) / (denom1 * denom1 * (kappa**2 + k2) * (kappa**2 + k2))\n    val = np.sum(W * integrand)\n    return float(np.real(val))\n\ndef solve_case(N_total, k_max, lambda_cpl, beta, k_peak, theta_deg):\n    \"\"\"\n    For given discretization and contour parameters, solve for kappa via\n    1 - lambda * J(kappa) = 0, then compute energy E = -kappa^2 and norm S(kappa).\n    \"\"\"\n    # Build contour points and weights\n    k_points, weights = build_contour(k_peak, k_max, theta_deg, N_total)\n\n    # Define objective function f(kappa) = 1 - lambda * J(kappa)\n    def f(kappa):\n        return 1.0 - lambda_cpl * J_discrete(kappa, beta, k_points, weights)\n\n    # Choose a bracket [kappa_min, kappa_max] with f(kappa_min)  0 and f(kappa_max)  0\n    # For attractive potential and sufficient strength, this holds with small kappa_min and larger kappa_max.\n    kappa_min = 1e-6\n    kappa_max_bracket = max(2.0 * beta, k_max)  # ensure upper bound reasonably large\n    # Ensure bracket signs; if not, expand kappa_max_bracket multiplicatively\n    fmin = f(kappa_min)\n    fmax = f(kappa_max_bracket)\n    expand_factor = 2.0\n    attempts = 0\n    while fmin = 0.0 and attempts  10:\n        # If f(kappa_min) is not negative, reduce it further\n        kappa_min *= 0.1\n        fmin = f(kappa_min)\n        attempts += 1\n    attempts = 0\n    while fmax = 0.0 and attempts  10:\n        kappa_max_bracket *= expand_factor\n        fmax = f(kappa_max_bracket)\n        attempts += 1\n\n    # Root finding\n    root = root_scalar(f, bracket=[kappa_min, kappa_max_bracket], method='brentq')\n    if not root.converged:\n        # Fallback: try different bracket if needed\n        kappa_guess = beta\n        root = root_scalar(f, x0=kappa_guess, x1=kappa_guess*1.5, method='secant')\n\n    kappa = float(root.root)\n    E = -kappa**2\n\n    # Compute unnormalized Berggren norm S(kappa)\n    S_val = S_discrete(kappa, beta, k_points, weights)\n\n    return E, S_val\n\ndef solve():\n    # Fixed interaction and contour parameters across test cases\n    lambda_cpl = 10.0\n    beta = 1.0\n    k_peak = 2.0\n    theta_deg = 30.0\n\n    # Test suite: (N_total, k_max)\n    test_cases = [\n        (40, 4.0),    # A: coarse N, small k_max\n        (80, 8.0),    # B: medium N, medium k_max\n        (160, 12.0),  # C: fine N, large k_max\n        (160, 8.0),   # D: fine N, medium k_max\n        (80, 12.0),   # E: medium N, large k_max\n    ]\n\n    results = []\n    for N_total, k_max in test_cases:\n        E, S_val = solve_case(N_total, k_max, lambda_cpl, beta, k_peak, theta_deg)\n        # Append as [E, S] floats\n        results.append([E, S_val])\n\n    # Print as a single line in the exact required format\n    # Ensure default float string representation\n    formatted = \"[\" + \",\".join(f\"[{r[0]},{r[1]}]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "CSM计算的输出是一系列复数能量，它们包含了关于系统能量和寿命的丰富信息，但诠释这些结果需要物理直觉。本练习通过一个简化的双能级非厄米玩具模型，模拟了粒子发射阈值附近的状态混合与能量“反交叉”现象。通过拟合模型与“GSM-like”数据，你将学习如何从复能量谱的演化中提取关键的物理信息，例如态之间的有效耦合强度，从而架起理论计算与物理现象之间的桥梁。",
            "id": "3597518",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用一个双能级非厄米玩具模型，在连续谱壳模型中模拟粒子发射阈值附近的通道耦合与组态混合。本任务的重点是推导非厄米性为何以及如何从与粒子连续谱的耦合中产生，它如何在复能量平面上产生避免交叉，以及如何将一个简单模型拟合到代表 Gamow 壳模型 (GSM; Gamow Shell Model (GSM)) 的合成复能量数据。\n\n从 Feshbach 投影形式主义出发，该形式主义可以在内禀（闭合）空间中得到一个依赖于能量的有效非厄米哈密顿量。其标准形式如下：\n$$\nH_{\\text{eff}}(E) \\equiv H_{PP} + V_{PQ} \\frac{1}{E^+ - H_{QQ}} V_{QP},\n$$\n其中，$H_{PP}$ 作用于内禀空间，$H_{QQ}$ 作用于连续谱（散射）空间，而 $V_{PQ}$ 将两者耦合起来。虚部描述了向连续谱的不可逆衰变，并在发射阈值以下为零。在单粒子阈值附近，耗散宽度可以通过线性化的阈值定律来近似，而主值色散位移可以通过局部线性斜率来近似，由此得到以下针对控制参数 $\\lambda$ 的双能级、在窗口内能量无关的参数化模型：\n$$\nH(\\lambda) = \n\\begin{pmatrix}\nE_1 + \\Delta_1(\\lambda) - \\dfrac{i}{2}\\Gamma_1(\\lambda)  V_{12} \\\\\nV_{12}  E_2 + \\Delta_2(\\lambda) - \\dfrac{i}{2}\\Gamma_2(\\lambda)\n\\end{pmatrix},\n$$\n其中\n$$\n\\Gamma_i(\\lambda) = \\gamma_i \\max(\\lambda - \\lambda_{\\text{th},i}, 0), \\qquad \n\\Delta_i(\\lambda) = \\alpha_i \\left(\\lambda - \\lambda_{\\text{th},i}\\right),\n$$\n以及一个复数的、与 $\\lambda$ 无关的非对角耦合\n$$\nV_{12} \\equiv v_r + i v_i.\n$$\n假设有效哈密顿量是复对称的，因此有 $H_{12} = H_{21} = V_{12}$，这对于时间反演不变的开放量子系统是一个标准近似。可观测的本征值是 $H(\\lambda)$ 的复极点 $z_\\pm(\\lambda)$，记作 $z \\equiv E - \\dfrac{i}{2}\\Gamma$，其中 $E$ 是能量，单位为兆电子伏特 (MeV)，$\\Gamma$ 是衰变宽度，单位为兆电子伏特 (MeV)。\n\n您的程序必须：\n- 实现上述模型，并计算作为 $\\lambda$ 连续函数的两个复本征值分支，通过追踪分支以避免在复平面上的避免交叉处发生错误标记。应通过沿递增的 $\\lambda$ 逐点匹配本征值来强制实现连续性，以最小化相邻参数点之间的总复距离。\n- 通过对指定的“真实”参数集和控制参数网格进行模型对角化，生成合成的“类 GSM”数据集。不考虑测量噪声。\n- 对每个数据集，仅使用非线性最小二乘法对复数非对角耦合 $V_{12} = v_r + i v_i$ 进行拟合，以最小化模型预测分支与合成数据分支之间的复数残差平方和。所有其他参数均为已知且固定。每个 $\\lambda$ 点的复数残差必须通过堆叠两个分支的实部和虚部来构成。\n- 对每个数据集，报告拟合得到的模 $\\lvert V_{12} \\rvert = \\sqrt{v_r^2 + v_i^2}$，以兆电子伏特 (MeV) 为单位，并以浮点数形式表示。最终输出结果以 MeV 为单位。\n\n使用以下三个数据集（每个数据集定义一个完整的测试用例）。在所有数据集中，控制参数 $\\lambda$ 是无量纲的，所有能量单位均为兆电子伏特 (MeV)。\n\n数据集 A（在一个阈值之上存在清晰的避免交叉）：\n- 固定参数：\n  - $E_1 = 0.00$, $E_2 = 0.35$\n  - $\\lambda_{\\text{th},1} = 0.05$, $\\lambda_{\\text{th},2} = 0.25$\n  - $\\alpha_1 = 0.20$, $\\alpha_2 = 0.15$\n  - $\\gamma_1 = 0.40$, $\\gamma_2 = 0.70$\n- 真实耦合：\n  - $V_{12}^{(\\text{true})} = 0.045 - i\\,0.008$\n- 控制网格：\n  - $\\lambda \\in \\{-0.05, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45\\}$\n\n数据集 B（混合消失的边界情况）：\n- 固定参数：\n  - $E_1 = 0.10$, $E_2 = 0.30$\n  - $\\lambda_{\\text{th},1} = 0.05$, $\\lambda_{\\text{th},2} = 0.15$\n  - $\\alpha_1 = 0.10$, $\\alpha_2 = 0.10$\n  - $\\gamma_1 = 0.30$, $\\gamma_2 = 0.30$\n- 真实耦合：\n  - $V_{12}^{(\\text{true})} = 0.000 + i\\,0.000$\n- 控制网格：\n  - $\\lambda \\in \\{0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40\\}$\n\n数据集 C（阈值附近存在近简并和较大宽度）：\n- 固定参数：\n  - $E_1 = 0.12$, $E_2 = 0.14$\n  - $\\lambda_{\\text{th},1} = 0.11$, $\\lambda_{\\text{th},2} = 0.09$\n  - $\\alpha_1 = 0.25$, $\\alpha_2 = 0.20$\n  - $\\gamma_1 = 0.90$, $\\gamma_2 = 0.60$\n- 真实耦合：\n  - $V_{12}^{(\\text{true})} = 0.030 - i\\,0.020$\n- 控制网格：\n  - $\\lambda \\in \\{0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22\\}$\n\n数值与输出要求：\n- 不涉及角度。所有能量都必须以兆电子伏特 (MeV) 为单位进行处理和报告。\n- 通过堆叠实部和虚部，使用适用于复数残差的最小二乘法程序。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。具体来说，它必须打印 $[\\lvert V_{12}^{(A)}\\rvert,\\lvert V_{12}^{(B)}\\rvert,\\lvert V_{12}^{(C)}\\rvert]$，每个值都以 MeV 为单位，表示为四舍五入到小数点后六位的小数浮点数，例如 $[0.123456,0.000000,0.036789]$。\n\n测试套件与覆盖范围说明：\n- 数据集 A 是一个一般情况，当 $\\lambda$ 超过一个阈值时，在复平面上出现可见的避免交叉，用于测试稳健的分支追踪能力以及对非零复数耦合的敏感性。\n- 数据集 B 是一个没有混合的边界条件，以确保拟合器能正确返回一个接近于零的耦合模。\n- 数据集 C 是一个阈值附近能级近简并且宽度较大的边缘情况，用于测试拟合的稳定性以及解释由连续谱耦合主导的复数避免交叉的能力。\n\n您的最终程序必须是完整的、自包含的，不需要任何输入，并且必须完全按照上述规定实现模型、数据生成、拟合和最终报告。唯一允许使用的外部库是 Numerical Python (NumPy) 和 Scientific Python (SciPy)。最终输出必须是单行，包含上述列表，其值以 MeV 为单位，并四舍五入到小数点后六位。",
            "solution": "所提出的问题是计算核物理领域的一个有效练习，具体涉及衰变阈值附近的开放量子系统的建模。它在科学上基于 Feshbach 投影形式主义以及由此产生的非厄米有效哈密顿量，这些是描述共振态和连续谱耦合的标准理论工具。这个问题是适定的，为实现、数据生成和参数拟合提供了完整的参数集和明确的目标。它是客观的、可数学形式化的，并且在计算上是可行的。因此，有必要提供一个完整的解决方案。\n\n该问题的理论基础是描述一组离散的量子态（内禀或模型空间 $P$）与一个连续的散射态谱（空间 $Q$）之间的耦合。在形式上消除了 $Q$ 空间后，支配 $P$ 空间内动力学的有效哈密顿量变得非厄米且依赖于能量。其一般形式为：\n$$\nH_{\\text{eff}}(E) = H_{PP} + V_{PQ} \\frac{1}{E^+ - H_{QQ}} V_{QP}\n$$\n在此，$H_{PP}$ 是孤立内禀态的哈密顿量，$H_{QQ}$ 描述连续谱，$V_{PQ}$ 代表两个空间之间的耦合。项 $E^+ = E + i\\epsilon$（其中 $\\epsilon \\to 0^+$）确保了正确的因果边界条件。第二项，即自能 $\\Sigma(E) = V_{PQ} (E^+ - H_{QQ})^{-1} V_{QP}$，是复数。其反厄米部分 $-i\\text{Im}(\\Sigma(E))$ 产生衰变宽度，表示从 $P$ 空间到 $Q$ 空间的不可逆通量损失。\n\n该问题为这个有效哈密顿量提供了一个简化的、能量无关的参数化模型，该模型在一个围绕控制参数 $\\lambda$ 的小能量窗口内有效。我们考虑一个双能级系统（$P$ 空间维度为 2），得到一个 $2 \\times 2$ 矩阵：\n$$\nH(\\lambda) = \n\\begin{pmatrix}\nE_1 + \\Delta_1(\\lambda) - \\dfrac{i}{2}\\Gamma_1(\\lambda)  V_{12} \\\\\nV_{12}  E_2 + \\Delta_2(\\lambda) - \\dfrac{i}{2}\\Gamma_2(\\lambda)\n\\end{pmatrix}\n$$\n对角元素 $H_{ii}(\\lambda) = E_i + \\Delta_i(\\lambda) - \\frac{i}{2}\\Gamma_i(\\lambda)$ 是未耦合的“非绝热”态的复能量。$E_i$ 是基准能量。$\\Delta_i(\\lambda)$ 和 $\\Gamma_i(\\lambda)$ 这两项分别是由自能引起的依赖于能量的色散位移和衰变宽度。它们对控制参数 $\\lambda$ 的依赖性在粒子发射阈值 $\\lambda_{\\text{th},i}$ 附近被线性建模为：\n$$\n\\Gamma_i(\\lambda) = \\gamma_i \\max(\\lambda - \\lambda_{\\text{th},i}, 0)\n$$\n$$\n\\Delta_i(\\lambda) = \\alpha_i \\left(\\lambda - \\lambda_{\\text{th},i}\\right)\n$$\n宽度 $\\Gamma_i$ 仅在阈值之上（$\\lambda  \\lambda_{\\text{th},i}$）才非零，这反映了衰变只有在能量上允许时才可能发生。非对角元素 $V_{12} = v_r + i v_i$ 代表了两个态之间的有效耦合，由于通过连续谱的“间接”耦合，它本身也可能是复数。对于具有时间反演不变性的系统，假设矩阵是复对称的（$H_{12}=H_{21}$）是标准做法。\n\n物理上可观测的量是 $H(\\lambda)$ 的复本征值，它们对应于 S 矩阵的极点。我们将其表示为 $z(\\lambda) = E_{\\text{res}} - \\frac{i}{2}\\Gamma_{\\text{width}}$。一个通用的复对称 $2 \\times 2$ 矩阵的本征值 $z_\\pm$ 由标准二次公式给出：\n$$\nz_\\pm(\\lambda) = \\frac{H_{11}(\\lambda) + H_{22}(\\lambda)}{2} \\pm \\frac{1}{2}\\sqrt{(H_{11}(\\lambda) - H_{22}(\\lambda))^2 + 4V_{12}^2}\n$$\n随着 $\\lambda$ 的变化，这两个本征值在复能量平面上描绘出连续的分支。当非绝热能量 $H_{11}(\\lambda)$ 和 $H_{22}(\\lambda)$ 相互接近时，本征值表现出“避免交叉”。此时分支间的最小间距由耦合 $V_{12}$ 决定。\n\n计算任务的第一部分是为给定的一组参数和 $\\lambda$ 值的网格计算这些本征值分支。在每个 $\\lambda$ 点使用数值对角化程序（如 `numpy.linalg.eigvals`）会得到一对本征值。然而，它们的默认排序是任意的。为了构建连续的分支，我们必须在每一步 $\\lambda_k$ 对本征值进行排序，以匹配前一步 $\\lambda_{k-1}$ 的排序。这可以通过最小化连续步骤中本征值之间的复数距离之和来实现。给定分支 $z_1(\\lambda_{k-1})$ 和 $z_2(\\lambda_{k-1})$，以及在 $\\lambda_k$ 处新计算出的无序本征值 $z'_a$ 和 $z'_b$，我们比较两种可能的分配方式：\n1. $d_1 = |z_1(\\lambda_{k-1}) - z'_a| + |z_2(\\lambda_{k-1}) - z'_b|$\n2. $d_2 = |z_1(\\lambda_{k-1}) - z'_b| + |z_2(\\lambda_{k-1}) - z'_a|$\n如果 $d_1  d_2$，则分配为 $z_1(\\lambda_k)=z'_a$ 和 $z_2(\\lambda_k)=z'_b$。否则，交换分配。这个过程确保了在任何避免交叉中对状态的正确追踪。\n\n任务的第二部分是执行参数拟合。我们首先通过使用一组已知的“真实”参数（包括一个真实的耦合 $V_{12}^{(\\text{true})}$）计算本征值分支，来生成一个合成的“实验”数据集。然后，假设除了 $V_{12}$ 之外的所有参数都是已知的，我们必须通过将我们的模型拟合到这个合成数据来确定 $V_{12}$。待确定的参数是耦合的实部和虚部，$v_r$ 和 $v_i$。\n\n这是一个非线性最小二乘问题。我们定义一个残差函数，它量化了模型预测（对于一组试验参数 $p = [v_r, v_i]$）与合成数据之间的差异。对于一个试验的 $V_{12} = v_r+iv_i$，模型预测是一组本征值分支 $\\{z_{1}^{\\text{model}}(\\lambda_j; p), z_{2}^{\\text{model}}(\\lambda_j; p)\\}$。复数残差为：\n$$\n\\delta_k(\\lambda_j; p) = z_{k}^{\\text{model}}(\\lambda_j; p) - z_{k}^{\\text{data}}(\\lambda_j), \\quad k \\in \\{1, 2\\}\n$$\n对于控制网格中的每个点 $\\lambda_j$。为了与像 `scipy.optimize.least_squares` 这样操作实值向量的标准优化器一起使用，我们通过堆叠所有复数残差的实部和虚部来构造一个单一的残差向量：\n$$\n\\vec{R}(p) = [ \\dots, \\text{Re}(\\delta_1(\\lambda_j)), \\text{Im}(\\delta_1(\\lambda_j)), \\text{Re}(\\delta_2(\\lambda_j)), \\text{Im}(\\delta_2(\\lambda_j)), \\dots ]\n$$\n优化器随后找到参数 $p = [v_r, v_i]$，以最小化此向量元素的平方和 $\\sum_k R_k^2$，这等同于最小化总复数误差平方和 $\\sum_{j,k} |\\delta_k(\\lambda_j; p)|^2$。一旦找到最优的 $v_r$ 和 $v_i$，所需的输出就是模 $|V_{12}| = \\sqrt{v_r^2 + v_i^2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets.\n    \"\"\"\n\n    # Dataset A (clear avoided crossing above one threshold)\n    case_A = {\n        \"fixed_params\": {\n            \"E1\": 0.00, \"E2\": 0.35,\n            \"lambda_th1\": 0.05, \"lambda_th2\": 0.25,\n            \"alpha1\": 0.20, \"alpha2\": 0.15,\n            \"gamma1\": 0.40, \"gamma2\": 0.70,\n        },\n        \"true_V12\": 0.045 - 0.008j,\n        \"lambda_mesh\": np.array([-0.05, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45]),\n    }\n\n    # Dataset B (boundary case with vanishing mixing)\n    case_B = {\n         \"fixed_params\": {\n            \"E1\": 0.10, \"E2\": 0.30,\n            \"lambda_th1\": 0.05, \"lambda_th2\": 0.15,\n            \"alpha1\": 0.10, \"alpha2\": 0.10,\n            \"gamma1\": 0.30, \"gamma2\": 0.30,\n        },\n        \"true_V12\": 0.000 + 0.000j,\n        \"lambda_mesh\": np.array([0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40]),\n    }\n\n    # Dataset C (near-degeneracy near threshold with larger widths)\n    case_C = {\n        \"fixed_params\": {\n            \"E1\": 0.12, \"E2\": 0.14,\n            \"lambda_th1\": 0.11, \"lambda_th2\": 0.09,\n            \"alpha1\": 0.25, \"alpha2\": 0.20,\n            \"gamma1\": 0.90, \"gamma2\": 0.60,\n        },\n        \"true_V12\": 0.030 - 0.020j,\n        \"lambda_mesh\": np.array([0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22]),\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    results = []\n\n    for case in test_cases:\n        # Generate synthetic data using the true parameters\n        data_branches = calculate_branches(case[\"lambda_mesh\"], case[\"fixed_params\"], case[\"true_V12\"])\n        \n        # Define the residual function for the least-squares fit\n        def residuals(p, lambda_mesh, fixed_params, data_b1, data_b2):\n            \"\"\"\n            Calculates the residual vector for the least-squares fit.\n            p: array [v_r, v_i] of parameters to fit.\n            \"\"\"\n            v_r, v_i = p\n            trial_V12 = v_r + 1j * v_i\n            \n            model_b1, model_b2 = calculate_branches(lambda_mesh, fixed_params, trial_V12)\n            \n            # Calculate complex differences\n            diff1 = model_b1 - data_b1\n            diff2 = model_b2 - data_b2\n\n            # Stack real and imaginary parts into a 1D array\n            return np.concatenate([diff1.real, diff1.imag, diff2.real, diff2.imag])\n\n        # Initial guess for the fit\n        p0 = [0.0, 0.0]\n        \n        # Perform the non-linear least-squares fit\n        fit_result = least_squares(\n            residuals,\n            p0,\n            args=(case[\"lambda_mesh\"], case[\"fixed_params\"], data_branches[0], data_branches[1]),\n            method='lm' # Levenberg-Marquardt is robust for this type of problem\n        )\n        \n        # Extract fitted parameters\n        v_r_fit, v_i_fit = fit_result.x\n        \n        # Calculate the magnitude of the fitted V12\n        v12_magnitude = np.sqrt(v_r_fit**2 + v_i_fit**2)\n        results.append(v12_magnitude)\n\n    # Format and print the final output\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef calculate_branches(lambda_mesh, fixed_params, V12):\n    \"\"\"\n    Calculates the two complex eigenvalue branches for a given lambda mesh.\n    Enforces continuity by minimizing complex distance between points.\n    \"\"\"\n    fp = fixed_params\n    num_lambda = len(lambda_mesh)\n    branch1 = np.zeros(num_lambda, dtype=complex)\n    branch2 = np.zeros(num_lambda, dtype=complex)\n    \n    H = np.zeros((2, 2), dtype=complex)\n    \n    for i, lam in enumerate(lambda_mesh):\n        # Calculate diagonal elements of the Hamiltonian H(lambda)\n        delta1 = fp[\"alpha1\"] * (lam - fp[\"lambda_th1\"])\n        gamma1 = fp[\"gamma1\"] * max(lam - fp[\"lambda_th1\"], 0.0)\n        H[0, 0] = fp[\"E1\"] + delta1 - 0.5j * gamma1\n        \n        delta2 = fp[\"alpha2\"] * (lam - fp[\"lambda_th2\"])\n        gamma2 = fp[\"gamma2\"] * max(lam - fp[\"lambda_th2\"], 0.0)\n        H[1, 1] = fp[\"E2\"] + delta2 - 0.5j * gamma2\n        \n        # Set off-diagonal elements\n        H[0, 1] = H[1, 0] = V12\n        \n        # Get eigenvalues\n        eigvals = np.linalg.eigvals(H)\n        \n        if i == 0:\n            # For the first point, sort by real part as an initial condition\n            if eigvals[0].real  eigvals[1].real:\n                branch1[i] = eigvals[0]\n                branch2[i] = eigvals[1]\n            else:\n                branch1[i] = eigvals[1]\n                branch2[i] = eigvals[0]\n        else:\n            # For subsequent points, sort to maintain continuity\n            prev_b1 = branch1[i-1]\n            prev_b2 = branch2[i-1]\n            \n            # Two possible assignments for the new eigenvalues\n            e1, e2 = eigvals[0], eigvals[1]\n            \n            # Calculate sum of squared distances for both assignments\n            dist_noswap = abs(e1 - prev_b1) + abs(e2 - prev_b2)\n            dist_swap = abs(e2 - prev_b1) + abs(e1 - prev_b2)\n            \n            if dist_noswap  dist_swap:\n                branch1[i] = e1\n                branch2[i] = e2\n            else:\n                branch1[i] = e2\n                branch2[i] = e1\n                \n    return branch1, branch2\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}