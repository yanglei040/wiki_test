{
    "hands_on_practices": [
        {
            "introduction": "The backbone of any BUU simulation is the Vlasov equation, which describes the collisionless evolution of nucleons in a smooth mean-field potential. A fundamental check on any numerical transport solver is its ability to conserve fundamental quantities like energy, momentum, and particle number. This exercise  guides you through a \"conservation audit\" for a semi-Lagrangian solver in a harmonic oscillator potential, where exact trajectories are known, allowing you to isolate and quantify numerical errors.",
            "id": "3544900",
            "problem": "Implement a collisionless Boltzmann-Uehling-Uhlenbeck (BUU) transport solver in one spatial dimension and one momentum dimension that performs a conserved-quantity audit under a scan of time-step $\\,\\Delta t\\,$ and grid resolution $\\,\\Delta x\\,$. Your task is to derive and implement a semi-Lagrangian solver for the Vlasov limit of the BUU equation with a harmonic-oscillator mean-field potential and to monitor conservation of total energy, total momentum, and particle number over long-time integration. Use dimensionless units throughout.\n\nStart from the following foundational base:\n- The Boltzmann-Uehling-Uhlenbeck (BUU) transport equation for the one-body phase-space density $\\,f(x,p,t)\\,$ is\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{p}{m}\\frac{\\partial f}{\\partial x} - \\frac{\\partial U}{\\partial x}\\frac{\\partial f}{\\partial p} = I_{\\mathrm{coll}}[f] ,\n$$\nwhere $\\,m\\,$ is the mass, $\\,U(x)\\,$ is the mean-field potential, and $\\,I_{\\mathrm{coll}}[f]\\,$ is the collision integral with Pauli blocking. In the collisionless (Vlasov) limit, set $\\,I_{\\mathrm{coll}}[f]=0\\,$.\n- For a harmonic oscillator mean field,\n$$\nU(x) = \\tfrac{1}{2} k x^2 , \\quad \\omega \\equiv \\sqrt{k/m} .\n$$\n- The characteristics of the collisionless flow follow Hamilton’s equations,\n$$\n\\dot{x} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial U}{\\partial x} = -k x = -m \\omega^2 x.\n$$\n- The following integrals are conserved exactly by the continuous dynamics:\n  - Particle number $\\,N = \\iint f(x,p,t)\\, dx\\, dp\\,$.\n  - Total momentum $\\,P = \\iint p\\, f(x,p,t)\\, dx\\, dp\\,$.\n  - Total energy $\\,E = \\iint \\left( \\frac{p^2}{2m} + \\tfrac{1}{2} k x^2 \\right) f(x,p,t)\\, dx\\, dp\\,$.\n\nYour numerical model must adhere to the following design:\n- Use the exact characteristic mapping of the harmonic oscillator for time stepping. Over one time step $\\,\\Delta t\\,$, the exact backtracing map from $\\,t^{n+1}\\,$ to $\\,t^n\\,$ is\n$$\n\\begin{pmatrix} x^{\\star} \\\\ p^{\\star} \\end{pmatrix}\n= \\begin{pmatrix}\n\\cos(\\omega \\Delta t) & -\\frac{1}{m \\omega}\\sin(\\omega \\Delta t) \\\\\nm \\omega \\sin(\\omega \\Delta t) & \\cos(\\omega \\Delta t)\n\\end{pmatrix}\n\\begin{pmatrix} x \\\\ p \\end{pmatrix} ,\n$$\nand then set $\\, f^{n+1}(x,p) = f^n(x^{\\star},p^{\\star})\\,$ using bilinear interpolation on a uniform phase-space grid.\n- Use uniform grids $\\,x \\in [x_{\\min}, x_{\\max}]\\,$ and $\\,p \\in [p_{\\min}, p_{\\max}]\\,$ with $\\,N_x\\,$ and $\\,N_p\\,$ cells, respectively, and cell-centered values for $\\,f\\,$. Choose $\\,x_{\\min}=-L_x\\,$, $\\,x_{\\max}=+L_x\\,$, $\\,p_{\\min}=-L_p\\,$, $\\,p_{\\max}=+L_p\\,$ with $\\,L_x=L_p\\,$ sufficiently large so that boundary effects are negligible for the chosen initial condition and simulation time.\n- Initialize $\\,f(x,p,0)\\,$ as a normalized Gaussian in phase space,\n$$\nf(x,p,0) = \\frac{1}{2\\pi \\sigma_x \\sigma_p} \\exp\\!\\left( -\\frac{x^2}{2\\sigma_x^2} - \\frac{p^2}{2\\sigma_p^2} \\right),\n$$\nwith $\\,\\sigma_x = 1\\,$ and $\\,\\sigma_p = 1\\,$.\n- Set $\\,m=1\\,$, $\\,k=1\\,$ so that $\\,\\omega=1\\,$. Evolve to a final time $\\,T_{\\mathrm{end}} = T_{\\mathrm{per}}\\times 2\\pi\\,$ corresponding to $\\,T_{\\mathrm{per}}\\,$ oscillation periods. Use $\\,T_{\\mathrm{per}}=8\\,$. Use $\\,L_x=L_p=6\\,$ so that boundary truncation error is exponentially small for the Gaussian initial data.\n\nConservation audit:\n- At every time step $\\,t_n\\,$, compute\n$$\nN(t_n) = \\sum_{i,j} f_{ij}(t_n)\\, \\Delta x\\, \\Delta p,\\quad\nP(t_n) = \\sum_{i,j} p_j\\, f_{ij}(t_n)\\, \\Delta x\\, \\Delta p,\\quad\nE(t_n) = \\sum_{i,j} \\left( \\frac{p_j^2}{2m} + \\frac{1}{2} k x_i^2 \\right) f_{ij}(t_n)\\, \\Delta x\\, \\Delta p .\n$$\n- Let $\\,N_0, P_0, E_0\\,$ be the initial values. Define running deviations\n$$\n\\delta N(t_n) = |N(t_n)-N_0|,\\quad\n\\delta P(t_n) = |P(t_n)-P_0|,\\quad\n\\delta E(t_n) = |E(t_n)-E_0|.\n$$\n- Report the maxima over the run:\n$$\n\\delta N_{\\max} = \\max_n \\delta N(t_n),\\quad\n\\delta P_{\\max} = \\max_n \\delta P(t_n),\\quad\n\\delta E_{\\max} = \\max_n \\delta E(t_n).\n$$\n- For dimensionless relative audits, compute\n$$\nr_N = \\frac{\\delta N_{\\max}}{\\max(|N_0|,\\varepsilon)},\\quad\nr_P = \\frac{\\delta P_{\\max}}{\\max(|P_0|,\\varepsilon)},\\quad\nr_E = \\frac{\\delta E_{\\max}}{\\max(|E_0|,\\varepsilon)},\n$$\nwith $\\,\\varepsilon = 10^{-12}\\,$ to avoid division by zero. The stability criterion of interest is $\\,r_E < 10^{-3}\\,$.\n\nPhysical and numerical units:\n- Use a fully dimensionless system with $\\,m=1\\,$, $\\,k=1\\,$, $\\,\\omega=1\\,$, $\\,\\sigma_x=1\\,$, $\\,\\sigma_p=1\\,$, $\\,L_x=L_p=6\\,$, and $\\,T_{\\mathrm{per}}=8\\,$. All outputs must be pure decimals (unitless).\n\nTest suite and required output:\n- For each parameter triple $\\, (N_x, N_p, \\Delta t)\\,$ below, run the simulation and evaluate whether the energy audit passes $\\,r_E < 10^{-3}\\,$:\n  1. $\\, (N_x=32, N_p=32, \\Delta t=0.10)\\,$\n  2. $\\, (N_x=32, N_p=32, \\Delta t=0.05)\\,$\n  3. $\\, (N_x=24, N_p=24, \\Delta t=0.10)\\,$\n  4. $\\, (N_x=64, N_p=64, \\Delta t=0.10)\\,$\n  5. $\\, (N_x=24, N_p=24, \\Delta t=0.20)\\,$\n  6. $\\, (N_x=48, N_p=48, \\Delta t=0.15)\\,$\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, where each entry is a boolean indicating whether $\\,r_E < 10^{-3}\\,$. For example, an output like $\\, [\\mathrm{True},\\mathrm{False},\\dots]\\,$.\n\nYour program must be self-contained, require no user input, and follow exactly the execution environment and library constraints given. The numerical design should be scientifically sound and must implement the audit as specified. All angles are in radians. All reported quantities must be decimals with no units.",
            "solution": "The problem requires the implementation of a semi-Lagrangian solver for the collisionless Boltzmann-Uehling-Uhlenbeck (BUU) equation, also known as the Vlasov equation, in one spatial dimension and one momentum dimension. The system is subject to a harmonic oscillator mean-field potential. The core task is to monitor the conservation of particle number, momentum, and energy over a long-time simulation and audit the numerical accuracy for various grid resolutions and time steps.\n\nThe governing equation for the one-body phase-space distribution function $f(x, p, t)$ is the Vlasov equation:\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{p}{m}\\frac{\\partial f}{\\partial x} - \\frac{\\partial U(x)}{\\partial x}\\frac{\\partial f}{\\partial p} = 0\n$$\nwhere $m$ is the particle mass, $x$ is position, $p$ is momentum, and $U(x)$ is the mean-field potential. For this problem, the potential is that of a simple harmonic oscillator, $U(x) = \\frac{1}{2} k x^2$, where $k$ is the spring constant. The force on a particle is $F_x = -\\frac{\\partial U}{\\partial x} = -k x$. The characteristic curves of this partial differential equation are the classical trajectories of particles in phase space, governed by Hamilton's equations:\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial x} = -k x\n$$\nwhere the Hamiltonian is $H(x,p) = \\frac{p^2}{2m} + U(x)$. Liouville's theorem, a direct consequence of the Vlasov equation, states that the distribution function $f$ is constant along these characteristics. That is, if $(x(t), p(t))$ is a particle trajectory, then $f(x(t), p(t), t)$ is constant.\n\nThe numerical solution is constructed using a semi-Lagrangian method, which leverages Liouville's theorem. To find the value of the distribution function $f^{n+1}(x, p)$ at a grid point $(x, p)$ at time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time by one step $\\Delta t$ to find its departure point $(x^\\star, p^\\star)$ at time $t^n$. The value of the distribution function is then updated as $f^{n+1}(x, p) = f^n(x^\\star, p^\\star)$.\n\nFor the harmonic oscillator, the solution to Hamilton's equations provides an exact mapping for the characteristics. A particle at phase-space coordinate $(x, p)$ at time $t^{n+1}$ originated from $(x^\\star, p^\\star)$ at time $t^n$, where $(x^\\star, p^\\star)$ is found by evolving $(x, p)$ backward in time by $\\Delta t$. This operation is a linear transformation (a rotation in a scaled phase space) given by the matrix specified in the problem:\n$$\n\\begin{pmatrix} x^{\\star} \\\\ p^{\\star} \\end{pmatrix}\n= \\begin{pmatrix}\n\\cos(\\omega \\Delta t) & -\\frac{1}{m \\omega}\\sin(\\omega \\Delta t) \\\\\nm \\omega \\sin(\\omega \\Delta t) & \\cos(\\omega \\Delta t)\n\\end{pmatrix}\n\\begin{pmatrix} x \\\\ p \\end{pmatrix}\n$$\nwhere $\\omega = \\sqrt{k/m}$ is the natural frequency of the oscillator.\n\nThe departure point $(x^\\star, p^\\star)$ will not, in general, coincide with a point on the discrete phase-space grid at time $t^n$. Therefore, the value $f^n(x^\\star, p^\\star)$ must be estimated by interpolating the values of $f^n$ known at the grid points. The problem specifies bilinear interpolation for this task. This interpolation step is the primary source of numerical error and dissipation in the scheme, causing the numerically computed conserved quantities to drift from their true, constant values.\n\nThe implementation follows these steps. First, we define a uniform, cell-centered phase-space grid with $N_x \\times N_p$ points covering the domain $[-L_x, L_x] \\times [-L_p, L_p]$. The grid spacings are $\\Delta x = 2L_x/N_x$ and $\\Delta p = 2L_p/N_p$. The initial distribution function $f(x, p, 0)$ is set to a normalized Gaussian on this grid. We set the physical parameters to dimensionless values $m=1$, $k=1$, which implies $\\omega=1$.\n\nThe main loop iterates over a number of time steps sufficient to cover the total simulation time $T_{\\mathrm{end}} = T_{\\mathrm{per}} \\times 2\\pi = 16\\pi$. In each step:\n$1$. The entire grid of destination points $(x_{i}, p_{j})$ for the new time step $t^{n+1}$ is considered.\n$2$. For each point, the corresponding departure point $(x^\\star_{ij}, p^\\star_{ij})$ at time $t^n$ is calculated using the vectorized backtracing matrix transformation.\n$3$. A two-dimensional interpolator, `scipy.interpolate.RegularGridInterpolator`, is constructed from the grid values of $f^n$. It is configured to perform bilinear interpolation and to return $0$ for any points traced from outside the simulation domain, which is a reasonable physical assumption for a localized initial distribution.\n$4$. This interpolator is queried at all departure points $(x^\\star_{ij}, p^\\star_{ij})$ to obtain the new distribution $f^{n+1}$.\n\nAt every time step, a conservation audit is performed. The total particle number $N$, total momentum $P$, and total energy $E$ are computed via numerical quadrature (a discrete sum) over the phase-space grid:\n$$\nN(t_n) = \\sum_{i,j} f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n$$\nP(t_n) = \\sum_{i,j} p_j\\, f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n$$\nE(t_n) = \\sum_{i,j} \\left( \\frac{p_j^2}{2m} + \\frac{1}{2} k x_i^2 \\right) f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\nThe initial values $N_0$, $P_0$, and $E_0$ are computed from the initial distribution $f(x, p, 0)$. For the given symmetric Gaussian, the analytical values are $N_0=1$, $P_0=0$, and $E_0 = \\frac{\\sigma_p^2}{2m} + \\frac{k\\sigma_x^2}{2} = 1$. The maximum absolute deviations $\\delta N_{\\max}$, $\\delta P_{\\max}$, and $\\delta E_{\\max}$ are tracked throughout the simulation. Finally, the relative error in energy, $r_E = \\delta E_{\\max} / \\max(|E_0|, \\varepsilon)$, is calculated and compared against the tolerance of $10^{-3}$ to determine if the simulation passes the conservation audit. This procedure is repeated for each parameter set in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef run_simulation(Nx, Np, dt):\n    \"\"\"\n    Runs a single Vlasov simulation for a given set of numerical parameters.\n\n    Args:\n        Nx (int): Number of grid points in the x-dimension.\n        Np (int): Number of grid points in the p-dimension.\n        dt (float): Time step size.\n\n    Returns:\n        bool: True if the relative energy error is less than 1e-3, False otherwise.\n    \"\"\"\n    # 1. Define physical and numerical constants\n    m, k = 1.0, 1.0\n    omega = np.sqrt(k / m)\n    sigma_x, sigma_p = 1.0, 1.0\n    Lx, Lp = 6.0, 6.0\n    T_per = 8.0\n    T_end = T_per * 2.0 * np.pi\n    eps = 1e-12\n\n    # 2. Set up the phase-space grid\n    dx = (2.0 * Lx) / Nx\n    dp = (2.0 * Lp) / Np\n    x_coords = np.linspace(-Lx + dx / 2.0, Lx - dx / 2.0, Nx)\n    p_coords = np.linspace(-Lp + dp / 2.0, Lp - dp / 2.0, Np)\n    XX, PP = np.meshgrid(x_coords, p_coords, indexing='ij')\n\n    # 3. Initialize the phase-space distribution function\n    f = (1.0 / (2.0 * np.pi * sigma_x * sigma_p)) * \\\n        np.exp(-XX**2 / (2.0 * sigma_x**2) - PP**2 / (2.0 * sigma_p**2))\n\n    # 4. Compute initial conserved quantities for the audit\n    dV = dx * dp\n    N0 = np.sum(f) * dV\n    P0 = np.sum(PP * f) * dV\n    E_grid = (PP**2 / (2.0 * m)) + (k * XX**2 / 2.0)\n    E0 = np.sum(E_grid * f) * dV\n\n    dev_N_list, dev_P_list, dev_E_list = [], [], []\n\n    # 5. Set up the time evolution loop\n    num_steps = int(np.ceil(T_end / dt))\n    \n    # Pre-calculate trigonometric factors for the backtracing map\n    c = np.cos(omega * dt)\n    s = np.sin(omega * dt)\n\n    f_current = f.copy()\n\n    for _ in range(num_steps):\n        # a. Create an interpolator for the current distribution f^n\n        interpolator = RegularGridInterpolator((x_coords, p_coords), f_current,\n                                               method='linear',\n                                               bounds_error=False,\n                                               fill_value=0.0)\n\n        # b. Calculate backtraced coordinates for the entire grid\n        #    (x*, p*) = R(-dt) * (x, p), where R is the rotation matrix\n        XX_star = c * XX - (s / (m * omega)) * PP\n        PP_star = (m * omega * s) * XX + c * PP\n\n        # c. Query the interpolator at all backtraced points to get f^(n+1)\n        points_to_query = np.stack([XX_star.ravel(), PP_star.ravel()], axis=-1)\n        f_new_flat = interpolator(points_to_query)\n        f_current = f_new_flat.reshape((Nx, Np))\n\n        # d. Perform conservation audit for the new time step\n        N_n = np.sum(f_current) * dV\n        P_n = np.sum(PP * f_current) * dV\n        E_n = np.sum(E_grid * f_current) * dV\n\n        dev_N_list.append(np.abs(N_n - N0))\n        dev_P_list.append(np.abs(P_n - P0))\n        dev_E_list.append(np.abs(E_n - E0))\n\n    # 6. Finalize the audit by calculating relative error\n    if dev_E_list:\n        delta_E_max = np.max(dev_E_list)\n    else:  # Handles the case where num_steps might be 0\n        delta_E_max = 0.0\n\n    r_E = delta_E_max / np.max([np.abs(E0), eps])\n\n    # 7. Return the boolean result based on the energy conservation criterion\n    return r_E < 1e-3\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 32, 0.10),\n        (32, 32, 0.05),\n        (24, 24, 0.10),\n        (64, 64, 0.10),\n        (24, 24, 0.20),\n        (48, 48, 0.15),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Np, dt = case\n        result = run_simulation(Nx, Np, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python bool is 'True' or 'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The mean-field potential $U$ in the BUU equation is not arbitrary; it is self-consistently generated from the nuclear density and derived from the underlying nuclear Equation of State (EoS). This practice  illuminates the crucial principle of thermodynamic consistency by having you verify that two distinct physical definitions of pressure—one from the potential and one from the EoS—yield identical results. Successfully completing this exercise is essential for understanding how to correctly implement and interpret mean-field models in transport simulations.",
            "id": "3544854",
            "problem": "Consider nonrelativistic, homogeneous, isospin-symmetric nuclear matter modeled within the Boltzmann-Uehling-Uhlenbeck (BUU) transport framework. Adopt the following physically standard foundations: (i) the energy-momentum tensor for a nonrelativistic many-body system connects the pressure to the momentum flux, and for an ideal Fermi gas at zero temperature the kinetic contribution to the pressure equals two-thirds of the kinetic energy density; (ii) the thermodynamic pressure can be computed from the derivative of the energy density with respect to the particle number density; and (iii) in a mean-field description, the single-particle potential is the functional derivative of the interaction energy density with respect to the density.\n\nLet the baryon number density be $\\rho$ in $\\mathrm{fm}^{-3}$, and the spin-isospin degeneracy be $g=4$. Let the nonrelativistic nucleon mass be $m_{N}=939.0$ MeV, and Planck’s constant times the speed of light be $\\hbar c=197.3269804 \\text{ MeV} \\cdot \\text{fm}$. In symmetric matter at zero temperature, the Fermi momentum is\n$$\nk_{F}(\\rho)=\\left(\\frac{6\\pi^{2}\\rho}{g}\\right)^{1/3},\n$$\nand the Fermi energy is\n$$\nE_{F}(\\rho)=\\frac{\\hbar^{2}k_{F}(\\rho)^{2}}{2m_{N}},\n$$\nwith $\\hbar=\\hbar c$ in natural units where $c=1$. The kinetic energy density is\n$$\n\\epsilon_{\\mathrm{kin}}(\\rho)=\\frac{3}{5}E_{F}(\\rho)\\rho,\n$$\nand the corresponding kinetic pressure contribution is\n$$\nP_{\\mathrm{kin}}(\\rho)=\\frac{2}{3}\\epsilon_{\\mathrm{kin}}(\\rho).\n$$\n\nModel the interaction energy density by a Skyrme-like equation of state parameterization that depends on the reference saturation density $\\rho_{0}=0.16 \\text{ fm}^{-3}$ and parameters $A=-356.0$ MeV, $B=303.0$ MeV, and $\\sigma=7/6$. Define\n$$\n\\epsilon_{\\mathrm{int}}(\\rho)=\\frac{A}{2\\rho_{0}}\\rho^{2}+\\frac{B}{(\\sigma+1)\\rho_{0}^{\\sigma}}\\rho^{\\sigma+1}.\n$$\nThe mean-field single-particle potential is generated by the functional derivative,\n$$\nU(\\rho)=\\frac{\\partial \\epsilon_{\\mathrm{int}}}{\\partial \\rho}=\\frac{A}{\\rho_{0}}\\rho+\\frac{B}{\\rho_{0}^{\\sigma}}\\rho^{\\sigma}.\n$$\n\nUsing these foundations, construct two independent computations of the pressure:\n\n1. The BUU virial route, which combines the kinetic contribution and the interaction virial via the mean-field potential,\n$$\nP_{\\mathrm{virial}}(\\rho)=P_{\\mathrm{kin}}(\\rho)+\\rho\\,U(\\rho)-\\epsilon_{\\mathrm{int}}(\\rho).\n$$\n\n2. The thermodynamic route from the equation of state (EoS), using the total energy density $\\epsilon(\\rho)=\\epsilon_{\\mathrm{kin}}(\\rho)+\\epsilon_{\\mathrm{int}}(\\rho)$,\n$$\nP_{\\mathrm{EoS}}(\\rho)=\\rho\\,\\frac{\\partial \\epsilon(\\rho)}{\\partial \\rho}-\\epsilon(\\rho).\n$$\n\nYou must verify thermodynamic consistency by scanning over a set of densities and quantifying the relative mismatch\n$$\n\\frac{\\Delta P}{P_{\\mathrm{ref}}}=\\frac{\\left|P_{\\mathrm{virial}}(\\rho)-P_{\\mathrm{EoS}}(\\rho)\\right|}{P_{\\mathrm{ref}}(\\rho)},\n$$\nwhere $P_{\\mathrm{ref}}(\\rho)=\\max\\left(\\left|P_{\\mathrm{EoS}}(\\rho)\\right|,\\,\\varepsilon\\right)$ with a small positive floor $\\varepsilon=10^{-14} \\text{ MeV/fm}^3$ to avoid division by zero. If both $\\left|P_{\\mathrm{virial}}(\\rho)\\right|<\\varepsilon$ and $\\left|P_{\\mathrm{EoS}}(\\rho)\\right|<\\varepsilon$, define $\\Delta P/P_{\\mathrm{ref}}=0.0$.\n\nFor the kinetic derivative needed in $P_{\\mathrm{EoS}}(\\rho)$, use the known nonrelativistic zero-temperature Fermi-gas scaling $\\epsilon_{\\mathrm{kin}}(\\rho)\\propto \\rho^{5/3}$ to obtain\n$$\n\\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho}(\\rho)=\\frac{5}{3}\\frac{\\epsilon_{\\mathrm{kin}}(\\rho)}{\\rho}\n$$\nfor $\\rho>0$, and $\\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho}(0)=0$.\n\nPhysical units: express all pressures and energy densities internally in $\\mathrm{MeV/fm^{3}}$; the final mismatch values $\\Delta P/P_{\\mathrm{ref}}$ are dimensionless decimals. Angles do not appear in this problem.\n\nTest suite: evaluate the mismatch for the following densities (in $\\mathrm{fm}^{-3}$):\n- $\\rho=0.0$,\n- $\\rho=1.0\\times 10^{-12}$,\n- $\\rho=0.08$,\n- $\\rho=0.16$,\n- $\\rho=0.30$,\n- $\\rho=0.50$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}\\right]$). Output each mismatch value as a floating-point number rounded to ten decimal places.",
            "solution": "The problem requires the verification of thermodynamic consistency for a given model of nuclear matter. This consistency is established by demonstrating that two independent methods for calculating the pressure, $P(\\rho)$, yield the same result. The first route is the virial pressure, $P_{\\mathrm{virial}}(\\rho)$, derived from the momentum flux in a transport equation framework. The second is the thermodynamic pressure, $P_{\\mathrm{EoS}}(\\rho)$, derived from the energy density as an equation of state.\n\nAnalytically, these two pressures must be identical for a thermodynamically consistent theory. We first demonstrate this identity. The total energy density is the sum of kinetic and interaction contributions: $\\epsilon(\\rho) = \\epsilon_{\\mathrm{kin}}(\\rho) + \\epsilon_{\\mathrm{int}}(\\rho)$.\n\nThe thermodynamic pressure is defined as:\n$$\nP_{\\mathrm{EoS}}(\\rho) = \\rho\\,\\frac{\\partial \\epsilon(\\rho)}{\\partial \\rho}-\\epsilon(\\rho)\n$$\nSubstituting the expression for $\\epsilon(\\rho)$:\n$$\nP_{\\mathrm{EoS}}(\\rho) = \\rho\\,\\frac{\\partial}{\\partial \\rho}\\left(\\epsilon_{\\mathrm{kin}}(\\rho) + \\epsilon_{\\mathrm{int}}(\\rho)\\right) - \\left(\\epsilon_{\\mathrm{kin}}(\\rho) + \\epsilon_{\\mathrm{int}}(\\rho)\\right)\n$$\nThis expression can be separated into kinetic and interaction parts:\n$$\nP_{\\mathrm{EoS}}(\\rho) = \\left(\\rho\\,\\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho} - \\epsilon_{\\mathrm{kin}}(\\rho)\\right) + \\left(\\rho\\,\\frac{\\partial \\epsilon_{\\mathrm{int}}}{\\partial \\rho} - \\epsilon_{\\mathrm{int}}(\\rho)\\right)\n$$\nFor a nonrelativistic Fermi gas at zero temperature, the kinetic energy density scales as $\\epsilon_{\\mathrm{kin}}(\\rho) \\propto \\rho^{5/3}$. The problem provides the derivative based on this scaling: $\\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho} = \\frac{5}{3}\\frac{\\epsilon_{\\mathrm{kin}}(\\rho)}{\\rho}$. Substituting this into the kinetic part of $P_{\\mathrm{EoS}}$ gives:\n$$\n\\rho\\left(\\frac{5}{3}\\frac{\\epsilon_{\\mathrm{kin}}(\\rho)}{\\rho}\\right) - \\epsilon_{\\mathrm{kin}}(\\rho) = \\frac{5}{3}\\epsilon_{\\mathrm{kin}}(\\rho) - \\epsilon_{\\mathrm{kin}}(\\rho) = \\frac{2}{3}\\epsilon_{\\mathrm{kin}}(\\rho)\n$$\nThis is precisely the definition of the kinetic pressure, $P_{\\mathrm{kin}}(\\rho)$, given in the problem. The single-particle potential $U(\\rho)$ is defined as the functional derivative of the interaction energy density, $U(\\rho) = \\frac{\\partial \\epsilon_{\\mathrm{int}}}{\\partial \\rho}$. Substituting these results back into the expression for $P_{\\mathrm{EoS}}(\\rho)$:\n$$\nP_{\\mathrm{EoS}}(\\rho) = P_{\\mathrm{kin}}(\\rho) + \\rho U(\\rho) - \\epsilon_{\\mathrm{int}}(\\rho)\n$$\nThis resulting expression is identical to the definition of the virial pressure provided in the problem statement:\n$$\nP_{\\mathrm{virial}}(\\rho) = P_{\\mathrm{kin}}(\\rho) + \\rho U(\\rho) - \\epsilon_{\\mathrm{int}}(\\rho)\n$$\nThus, we have analytically proven that $P_{\\mathrm{EoS}}(\\rho) = P_{\\mathrm{virial}}(\\rho)$. The task is to verify this identity numerically, where any non-zero mismatch will arise from the limitations of floating-point arithmetic and the distinct order of operations in the two computational paths.\n\nThe computational procedure is as follows:\nFor each given density $\\rho$ from the test suite:\n\n1.  **Handle the $\\rho=0$ case:** At zero density, all energy densities and pressures are zero. Both $|P_{\\mathrm{virial}}(0)|$ and $|P_{\\mathrm{EoS}}(0)|$ are smaller than the floor $\\varepsilon$. Following the problem's rule, the mismatch is defined as $0.0$.\n\n2.  **Calculate Kinetic Quantities (for $\\rho > 0$):**\n    The Fermi momentum $k_F(\\rho)$, Fermi energy $E_F(\\rho)$, kinetic energy density $\\epsilon_{\\mathrm{kin}}(\\rho)$, kinetic pressure $P_{\\mathrm{kin}}(\\rho)$, and the derivative $\\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho}$ are computed sequentially using the provided formulas.\n    $$\n    k_F(\\rho) = \\left(\\frac{6\\pi^{2}\\rho}{g}\\right)^{1/3} \\quad \\implies \\quad E_F(\\rho) = \\frac{(\\hbar c)^2 k_F(\\rho)^2}{2m_N}\n    $$\n    $$\n    \\epsilon_{\\mathrm{kin}}(\\rho) = \\frac{3}{5}E_F(\\rho)\\rho \\quad \\implies \\quad P_{\\mathrm{kin}}(\\rho) = \\frac{2}{3}\\epsilon_{\\mathrm{kin}}(\\rho) \\quad \\text{and} \\quad \\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho} = \\frac{5}{3}\\frac{\\epsilon_{\\mathrm{kin}}(\\rho)}{\\rho}\n    $$\n\n3.  **Calculate Interaction Quantities (for $\\rho > 0$):**\n    The interaction energy density $\\epsilon_{\\mathrm{int}}(\\rho)$ and the single-particle potential $U(\\rho)$ are computed from their Skyrme-like parameterizations. Note that $U(\\rho)$ is also $\\frac{\\partial \\epsilon_{\\mathrm{int}}}{\\partial \\rho}$.\n    $$\n    \\epsilon_{\\mathrm{int}}(\\rho)=\\frac{A}{2\\rho_{0}}\\rho^{2}+\\frac{B}{(\\sigma+1)\\rho_{0}^{\\sigma}}\\rho^{\\sigma+1}\n    $$\n    $$\n    U(\\rho) = \\frac{\\partial \\epsilon_{\\mathrm{int}}}{\\partial \\rho} = \\frac{A}{\\rho_{0}}\\rho+\\frac{B}{\\rho_{0}^{\\sigma}}\\rho^{\\sigma}\n    $$\n\n4.  **Assemble Pressures:**\n    The two pressures are computed using their distinct formulas, without any cross-substitution of intermediate steps, to preserve their computational independence.\n    $$\n    P_{\\mathrm{virial}}(\\rho) = P_{\\mathrm{kin}}(\\rho)+\\rho\\,U(\\rho)-\\epsilon_{\\mathrm{int}}(\\rho)\n    $$\n    $$\n    P_{\\mathrm{EoS}}(\\rho) = \\rho\\left(\\frac{\\partial \\epsilon_{\\mathrm{kin}}}{\\partial \\rho} + \\frac{\\partial \\epsilon_{\\mathrm{int}}}{\\partial \\rho}\\right) - (\\epsilon_{\\mathrm{kin}}(\\rho) + \\epsilon_{\\mathrm{int}}(\\rho))\n    $$\n\n5.  **Compute Mismatch:**\n    The relative mismatch $\\frac{\\Delta P}{P_{\\mathrm{ref}}}$ is calculated according to the specified rules. For very small densities, the pressures may fall below the floor $\\varepsilon$, triggering the special condition where the mismatch is set to $0.0$. Otherwise, the relative difference is computed using $P_{\\mathrm{ref}}(\\rho) = \\max(|P_{\\mathrm{EoS}}(\\rho)|, \\varepsilon)$.\n\nThis algorithm is implemented for the provided test suite of densities. The results are formatted to ten decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the thermodynamic consistency mismatch for a nuclear matter model.\n    \"\"\"\n    # Define the constants from the problem statement.\n    g = 4.0\n    m_N = 939.0  # MeV\n    hbar_c = 197.3269804  # MeV fm\n    hbar_c_sq = hbar_c**2\n    rho_0 = 0.16  # fm^-3\n    A = -356.0  # MeV\n    B = 303.0  # MeV\n    sigma = 7.0 / 6.0\n    epsilon_floor = 1e-14  # MeV/fm^3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1.0e-12,\n        0.08,\n        0.16,\n        0.30,\n        0.50,\n    ]\n\n    results = []\n    for rho in test_cases:\n        # Per the problem, for rho=0, all energy densities and pressures are zero.\n        # This falls under the special case |P_virial| < eps and |P_EoS| < eps, so mismatch = 0.0.\n        if rho == 0.0:\n            results.append(0.0)\n            continue\n\n        # --- Kinetic Quantities ---\n        # k_F(rho)^2 = (6 * pi^2 * rho / g)^(2/3)\n        k_F_sq = ((6.0 * np.pi**2 * rho) / g)**(2.0/3.0)\n        # E_F(rho) = hbar^2 * k_F^2 / (2*m_N)\n        E_F = hbar_c_sq * k_F_sq / (2.0 * m_N)\n        # eps_kin(rho) = (3/5) * E_F * rho\n        eps_kin = (3.0/5.0) * E_F * rho\n        # P_kin(rho) = (2/3) * eps_kin\n        P_kin = (2.0/3.0) * eps_kin\n        # d(eps_kin)/d(rho) = (5/3) * eps_kin / rho for rho > 0\n        d_eps_kin_d_rho = (5.0/3.0) * eps_kin / rho\n\n        # --- Interaction Quantities ---\n        # eps_int(rho) = A/(2*rho_0)*rho^2 + B/((sigma+1)*rho_0^sigma)*rho^(sigma+1)\n        term_A_eps_int = (A / (2.0 * rho_0)) * rho**2.0\n        term_B_eps_int = (B / ((sigma + 1.0) * rho_0**sigma)) * rho**(sigma + 1.0)\n        eps_int = term_A_eps_int + term_B_eps_int\n\n        # U(rho) = d(eps_int)/d(rho) = A/rho_0*rho + B/rho_0^sigma*rho^sigma\n        term_A_U = (A / rho_0) * rho\n        term_B_U = (B / rho_0**sigma) * rho**sigma\n        U = term_A_U + term_B_U\n        d_eps_int_d_rho = U\n\n        # --- Pressure Calculation 1: Virial Route ---\n        # P_virial(rho) = P_kin(rho) + rho*U(rho) - eps_int(rho)\n        P_virial = P_kin + rho * U - eps_int\n\n        # --- Pressure Calculation 2: EoS Route ---\n        # P_EoS(rho) = rho * d(eps)/d(rho) - eps(rho)\n        eps_total = eps_kin + eps_int\n        d_eps_total_d_rho = d_eps_kin_d_rho + d_eps_int_d_rho\n        P_eos = rho * d_eps_total_d_rho - eps_total\n\n        # --- Mismatch Calculation ---\n        # Special condition: if both pressures are near zero, mismatch is zero.\n        if abs(P_virial) < epsilon_floor and abs(P_eos) < epsilon_floor:\n            mismatch = 0.0\n        else:\n            # Reference pressure with a floor to prevent division by zero.\n            P_ref = max(abs(P_eos), epsilon_floor)\n            # Relative mismatch\n            delta_P = abs(P_virial - P_eos)\n            mismatch = delta_P / P_ref\n        \n        results.append(mismatch)\n\n    # Format the final output as a comma-separated list of floating-point numbers\n    # with ten decimal places, enclosed in square brackets.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice  adds the essential physics of two-body scattering, the \"Uehling-Uhlenbeck\" part of the BUU equation, which drives the system toward thermal equilibrium. You will build a stochastic collision algorithm from the first principles of kinetic theory, translating the abstract collision integral into a concrete Monte Carlo simulation step. This exercise is key to understanding how to implement the crucial ingredients of realistic BUU codes, such as collision probabilities, test-particle scaling, and the quantum-mechanical Pauli exclusion principle.",
            "id": "3544841",
            "problem": "Design and implement a self-contained program that realizes a stochastic binary-collision module consistent with the Boltzmann-Uehling-Uhlenbeck (BUU) transport framework using discrete time cells. Begin from the foundational kinetic-theory statement that, in a dilute gas of quasiparticles, the number of binary encounters in a small spacetime element is given by the incident flux multiplied by the microscopic cross-sectional area and the duration of exposure. Incorporate fermionic effects via the Uehling-Uhlenbeck occupancy factors, and the standard test-particle scaling used in numerical implementations.\n\nYour derivation and algorithm must start from first principles of kinetic theory and quantum statistics without assuming a target formula. Specifically, use only the following as foundational bases:\n- The binary-collision picture in kinetic theory: collisions arise from the relative flux of two bodies encountering an effective interaction area over a time interval.\n- The cross section as an effective area controlling the frequency of reactions at a given relative flux.\n- The Pauli-exclusion principle for fermions realized as occupancy-limiting factors for final states in scattering.\n- The test-particle method in transport theory, where the microscopic cross section is scaled to keep the mean free path invariant with respect to the number of test particles.\n\nYou must produce a program that, for a list of prescribed test cells and particle sets, computes the sum of pairwise collision acceptance probabilities in a single time step. For each unordered pair inside a cell, the acceptance probability must be computed from the pair’s relative speed, the effective cross section including test-particle scaling, the time-step duration, the cell volume, and the final-state occupation factors. Your implementation must enforce that at most one collision can occur for a given pair within one time step by capping any pairwise geometric acceptance probability at $1$ before applying occupancy suppression.\n\nModeling assumptions to be used consistently across all test cases:\n- Use nonrelativistic relative speed defined by the Euclidean norm of the velocity difference. For two velocity vectors $\\mathbf{v}_1$ and $\\mathbf{v}_2$, the relative speed is $v_{\\text{rel}} = \\lVert \\mathbf{v}_1 - \\mathbf{v}_2 \\rVert$.\n- Use test-particle scaling given by $\\sigma_{\\text{eff}} = \\sigma / N_{\\text{test}}$, where $\\sigma$ is the microscopic cross section and $N_{\\text{test}}$ is the number of test particles per physical nucleon.\n- Impose fermionic occupancy suppression as a multiplicative factor $(1 - f_3)(1 - f_4)$ applied to the capped geometric acceptance for a pair, where $f_3$ and $f_4$ are the final-state phase-space occupation probabilities of the scattered particles projected to their would-be post-collision states. Treat the provided $f_3$ and $f_4$ values as given inputs per pair in the test suite.\n- Treat all given particles in a test case as residing in the same spatial cell and being simultaneously eligible for collisions during the time step; consider all unordered distinct pairs within the cell.\n\nPhysical and numerical units:\n- Use natural units with speed of light set to unity. Express distances in femtometres ($\\text{fm}$), time in $\\text{fm}$, cross sections in $\\text{fm}^2$, volumes in $\\text{fm}^3$, and velocities as dimensionless numbers in units of $c$.\n- The program’s numerical answers must be provided as dimensionless floats.\n\nTasks for the program:\n1. For each test case, generate all unordered pairs of particles in the cell.\n2. For each pair $(i,j)$, compute the capped geometric acceptance and then apply occupancy suppression to obtain a per-pair acceptance probability $P_{ij}$ for that time step.\n3. Sum $P_{ij}$ over all unordered pairs in the cell to obtain $S$ for that test case.\n4. Output the list $[S_1,S_2,S_3,S_4,S_5]$ as a single line, where $S_k$ is the sum for test case $k$, formatted to six digits after the decimal point.\n\nTest suite (each test case is independent and self-contained; all velocities are in units of $c$, cross sections in $\\text{fm}^2$, time in $\\text{fm}$, and volume in $\\text{fm}^3$):\n- Test case $1$ (happy path, no Pauli suppression):\n  - Cell: $\\Delta V = 125$.\n  - Time step: $\\Delta t = 0.5$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.2, 0, 0)$, particle $2$: $(-0.1, 0, 0)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.0, 0.0)$.\n- Test case $2$ (with Pauli suppression):\n  - Cell: $\\Delta V = 125$.\n  - Time step: $\\Delta t = 0.5$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.2, 0, 0)$, particle $2$: $(-0.1, 0, 0)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.7, 0.6)$.\n- Test case $3$ (multiple pairs, test-particle scaling, mixed Pauli factors):\n  - Cell: $\\Delta V = 64$.\n  - Time step: $\\Delta t = 1.0$.\n  - Cross section: $\\sigma = 2.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 50$.\n  - Velocities: particle $1$: $(0.2, 0, 0)$, particle $2$: $(0, 0.3, 0)$, particle $3$: $(-0.1, 0, 0.1)$.\n  - Final-state occupations, listed in the order of unordered pairs $(1,2)$, $(1,3)$, $(2,3)$:\n    - $(f_3, f_4) = (0.2, 0.1)$ for $(1,2)$,\n    - $(f_3, f_4) = (0.5, 0.6)$ for $(1,3)$,\n    - $(f_3, f_4) = (0.0, 0.0)$ for $(2,3)$.\n- Test case $4$ (geometric probability exceeds one before capping; checks capping behavior):\n  - Cell: $\\Delta V = 10$.\n  - Time step: $\\Delta t = 5.0$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.8, 0, 0)$, particle $2$: $(0, 0.6, 0)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.0, 0.0)$.\n- Test case $5$ (zero relative speed; probability must vanish):\n  - Cell: $\\Delta V = 125$.\n  - Time step: $\\Delta t = 0.5$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.2, 0.1, 0.1)$, particle $2$: $(0.2, 0.1, 0.1)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.0, 0.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[S_1,S_2,S_3,S_4,S_5]$, each $S_k$ formatted with exactly six digits after the decimal point, for example, $[0.123456,0.000000,0.314159,1.000000,0.271828]$.",
            "solution": "### Derivation and Algorithmic Design\n\nWe derive the pairwise collision probability from first principles as specified.\n\n1.  **Geometric Collision Probability**:\n    In kinetic theory, the collision rate for two particles, $i$ and $j$, within a volume $\\Delta V$ is given by the product of their relative speed $v_{\\text{rel}, ij}$, the collision cross section $\\sigma$, and the probability density of finding the other particle, which is $1/\\Delta V$ for a single particle in the volume. The collision rate for a specific pair $(i,j)$ is thus $R_{ij} = \\frac{\\sigma v_{\\text{rel},ij}}{\\Delta V}$. The probability of a collision occurring within a small time interval $\\Delta t$ is approximated by the rate multiplied by the time duration:\n    $$P_{ij}^{\\text{raw}} = R_{ij} \\Delta t = \\frac{\\sigma v_{\\text{rel},ij} \\Delta t}{\\Delta V}$$\n    This expression represents the probability that particle $i$, sweeping out an interaction volume $\\sigma v_{\\text{rel},ij} \\Delta t$ over the time step, encounters particle $j$, which is assumed to be uniformly distributed in the cell volume $\\Delta V$.\n\n2.  **Test-Particle Scaling**:\n    In many-body transport simulations, each physical particle (e.g., a nucleon) is often represented by $N_{\\text{test}}$ \"test particles\" to improve statistical sampling of the phase-space distribution function. To ensure that the physical collision rate is preserved, the cross section for interactions between test particles, $\\sigma_{\\text{eff}}$, must be scaled. The physical mean free path, $\\lambda \\propto 1/(n\\sigma)$, where $n$ is the physical particle density, must remain invariant. The test particle density is $n_{\\text{test}} = N_{\\text{test}} n$. Requiring the mean free path for a test particle to be the same as for a physical particle, $\\lambda \\propto 1/(n_{\\text{test}}\\sigma_{\\text{eff}})$, implies $n\\sigma = n_{\\text{test}}\\sigma_{\\text{eff}} = (N_{\\text{test}}n)\\sigma_{\\text{eff}}$. This yields the scaling relation:\n    $$\\sigma_{\\text{eff}} = \\frac{\\sigma}{N_{\\text{test}}}$$\n    Substituting this into our probability expression gives the geometric probability for a pair of test particles:\n    $$P_{ij}^{\\text{geom}} = \\frac{\\sigma_{\\text{eff}} v_{\\text{rel},ij} \\Delta t}{\\Delta V} = \\frac{\\sigma v_{\\text{rel},ij} \\Delta t}{N_{\\text{test}} \\Delta V}$$\n\n3.  **Probability Capping**:\n    The expression for $P_{ij}^{\\text{geom}}$ is derived from a rate and is linear in $\\Delta t$. For a sufficiently large time step or high-density environment, this value can exceed $1$, which is unphysical for a probability. To rectify this, and to enforce the condition that a given pair can collide at most once per time step, the geometric probability is capped at $1$.\n    $$P_{ij}^{\\text{capped}} = \\min\\left(1, P_{ij}^{\\text{geom}}\\right)$$\n\n4.  **Pauli Blocking (Uehling-Uhlenbeck Factor)**:\n    The interacting particles are fermions, which must obey the Pauli exclusion principle. A scattering event $i, j \\to i', j'$ is only permitted if the final phase-space states, $i'$ and $j'$, are unoccupied. In a statistical description, the probability of a state being available is $(1-f)$, where $f$ is the phase-space occupation number. Assuming the final state occupancies $f_{i'}$ and $f_{j'}$ are independent, the probability that both final states are available is given by the Uehling-Uhlenbeck factor:\n    $$B_{ij} = (1-f_{i'}) (1-f_{j'})$$\n    The problem provides the values of these final-state occupations, denoted as $f_3$ and $f_4$, for each colliding pair.\n\n5.  **Final Pairwise Acceptance Probability**:\n    Combining the capped geometric probability with the Pauli blocking factor, we obtain the final acceptance probability for a collision between test particles $i$ and $j$ in the time step $\\Delta t$:\n    $$P_{ij} = P_{ij}^{\\text{capped}} \\times B_{ij} = \\min\\left(1, \\frac{\\sigma v_{\\text{rel},ij} \\Delta t}{N_{\\text{test}} \\Delta V}\\right) (1-f_3)(1-f_4)$$\n    where $v_{\\text{rel},ij} = \\lVert \\mathbf{v}_i - \\mathbf{v}_j \\rVert$.\n\n6.  **Total Collision Sum**:\n    The final quantity of interest for each test case is the sum of these probabilities over all unique, unordered pairs of particles within the cell:\n    $$S = \\sum_{i<j} P_{ij}$$\n    This quantity represents the expected number of collisions in the cell during the time step $\\Delta t$.\n\nThis completes the derivation. The algorithm for the program will directly implement these steps for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the BUU collision probability problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a dictionary containing all necessary parameters.\n    test_cases = [\n        # Test case 1 (happy path, no Pauli suppression)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([-0.1, 0.0, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 2 (with Pauli suppression)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([-0.1, 0.0, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.7, \"f4\": 0.6},\n            },\n        },\n        # Test case 3 (multiple pairs, test-particle scaling, mixed Pauli factors)\n        {\n            \"delta_V\": 64.0,\n            \"delta_t\": 1.0,\n            \"sigma\": 2.0,\n            \"N_test\": 50,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([0.0, 0.3, 0.0])},\n                2: {\"v\": np.array([-0.1, 0.0, 0.1])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.2, \"f4\": 0.1},\n                (0, 2): {\"f3\": 0.5, \"f4\": 0.6},\n                (1, 2): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 4 (geometric probability exceeds one before capping)\n        {\n            \"delta_V\": 10.0,\n            \"delta_t\": 5.0,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.8, 0.0, 0.0])},\n                1: {\"v\": np.array([0.0, 0.6, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 5 (zero relative speed)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.1, 0.1])},\n                1: {\"v\": np.array([0.2, 0.1, 0.1])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_V = case[\"delta_V\"]\n        delta_t = case[\"delta_t\"]\n        sigma = case[\"sigma\"]\n        N_test = case[\"N_test\"]\n        particles = case[\"particles\"]\n        pauli_factors_map = case[\"pauli_factors\"]\n\n        # Calculate effective cross section\n        sigma_eff = sigma / N_test\n        \n        # Initialize the sum of probabilities for the current test case\n        s_total = 0.0\n\n        # Generate all unique, unordered pairs of particle indices\n        particle_indices = list(particles.keys())\n        for i, j in combinations(particle_indices, 2):\n            # Fetch particle velocities\n            v_i = particles[i][\"v\"]\n            v_j = particles[j][\"v\"]\n\n            # 1. Calculate relative speed\n            v_rel = np.linalg.norm(v_i - v_j)\n\n            # If relative speed is zero, collision probability is zero\n            if v_rel == 0.0:\n                p_ij = 0.0\n            else:\n                # 2. Calculate the geometric probability\n                p_geom = (sigma_eff * v_rel * delta_t) / delta_V\n\n                # 3. Cap the geometric probability at 1.0\n                p_capped = min(1.0, p_geom)\n\n                # 4. Fetch the final-state occupation factors for the pair\n                # The pair (i,j) is always ordered (i < j) by itertools.combinations\n                f3 = pauli_factors_map[(i, j)][\"f3\"]\n                f4 = pauli_factors_map[(i, j)][\"f4\"]\n                \n                # 5. Calculate the Pauli blocking (Uehling-Uhlenbeck) factor\n                pauli_suppression = (1.0 - f3) * (1.0 - f4)\n                \n                # 6. Calculate the final acceptance probability for the pair\n                p_ij = p_capped * pauli_suppression\n\n            # 7. Add the pair's probability to the total sum for the cell\n            s_total += p_ij\n        \n        results.append(s_total)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}