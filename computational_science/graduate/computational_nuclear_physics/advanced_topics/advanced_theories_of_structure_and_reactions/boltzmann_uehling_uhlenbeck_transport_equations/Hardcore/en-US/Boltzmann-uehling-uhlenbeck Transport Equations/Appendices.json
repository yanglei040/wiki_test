{
    "hands_on_practices": [
        {
            "introduction": "The heart of the Boltzmann-Uehling-Uhlenbeck model lies in its collision integral, which simulates two-body scattering and drives the system towards thermal equilibrium. This practice guides you through constructing a stochastic collision module from first principles, translating kinetic theory into a concrete probabilistic algorithm. By implementing the collision probability, including essential ingredients like test-particle scaling and Pauli-blocking factors, you will gain a foundational understanding of how dissipation is modeled in transport simulations .",
            "id": "3544841",
            "problem": "Design and implement a self-contained program that realizes a stochastic binary-collision module consistent with the Boltzmann-Uehling-Uhlenbeck (BUU) transport framework using discrete time cells. Begin from the foundational kinetic-theory statement that, in a dilute gas of quasiparticles, the number of binary encounters in a small spacetime element is given by the incident flux multiplied by the microscopic cross-sectional area and the duration of exposure. Incorporate fermionic effects via the Uehling-Uhlenbeck occupancy factors, and the standard test-particle scaling used in numerical implementations.\n\nYour derivation and algorithm must start from first principles of kinetic theory and quantum statistics without assuming a target formula. Specifically, use only the following as foundational bases:\n- The binary-collision picture in kinetic theory: collisions arise from the relative flux of two bodies encountering an effective interaction area over a time interval.\n- The cross section as an effective area controlling the frequency of reactions at a given relative flux.\n- The Pauli-exclusion principle for fermions realized as occupancy-limiting factors for final states in scattering.\n- The test-particle method in transport theory, where the microscopic cross section is scaled to keep the mean free path invariant with respect to the number of test particles.\n\nYou must produce a program that, for a list of prescribed test cells and particle sets, computes the sum of pairwise collision acceptance probabilities in a single time step. For each unordered pair inside a cell, the acceptance probability must be computed from the pair’s relative speed, the effective cross section including test-particle scaling, the time-step duration, the cell volume, and the final-state occupation factors. Your implementation must enforce that at most one collision can occur for a given pair within one time step by capping any pairwise geometric acceptance probability at $1$ before applying occupancy suppression.\n\nModeling assumptions to be used consistently across all test cases:\n- Use nonrelativistic relative speed defined by the Euclidean norm of the velocity difference. For two velocity vectors $\\mathbf{v}_1$ and $\\mathbf{v}_2$, the relative speed is $v_{\\text{rel}} = \\lVert \\mathbf{v}_1 - \\mathbf{v}_2 \\rVert$.\n- Use test-particle scaling given by $\\sigma_{\\text{eff}} = \\sigma / N_{\\text{test}}$, where $\\sigma$ is the microscopic cross section and $N_{\\text{test}}$ is the number of test particles per physical nucleon.\n- Impose fermionic occupancy suppression as a multiplicative factor $(1 - f_3)(1 - f_4)$ applied to the capped geometric acceptance for a pair, where $f_3$ and $f_4$ are the final-state phase-space occupation probabilities of the scattered particles projected to their would-be post-collision states. Treat the provided $f_3$ and $f_4$ values as given inputs per pair in the test suite.\n- Treat all given particles in a test case as residing in the same spatial cell and being simultaneously eligible for collisions during the time step; consider all unordered distinct pairs within the cell.\n\nPhysical and numerical units:\n- Use natural units with speed of light set to unity. Express distances in femtometers (fm), time in fm, cross sections in fm$^2$, volumes in fm$^3$, and velocities as dimensionless numbers in units of $c$.\n- The program’s numerical answers must be provided as dimensionless floats.\n\nTasks for the program:\n1. For each test case, generate all unordered pairs of particles in the cell.\n2. For each pair $(i,j)$, compute the capped geometric acceptance and then apply occupancy suppression to obtain a per-pair acceptance probability $P_{ij}$ for that time step.\n3. Sum $P_{ij}$ over all unordered pairs in the cell to obtain $S$ for that test case.\n4. Output the list $[S_1,S_2,S_3,S_4,S_5]$ as a single line, where $S_k$ is the sum for test case $k$, formatted to six digits after the decimal point.\n\nTest suite (each test case is independent and self-contained; all velocities are in units of $c$, cross sections in fm$^2$, time in fm, and volume in fm$^3$):\n- Test case $1$ (happy path, no Pauli suppression):\n  - Cell: $\\Delta V = 125$.\n  - Time step: $\\Delta t = 0.5$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.2, 0, 0)$, particle $2$: $(-0.1, 0, 0)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.0, 0.0)$.\n- Test case $2$ (with Pauli suppression):\n  - Cell: $\\Delta V = 125$.\n  - Time step: $\\Delta t = 0.5$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.2, 0, 0)$, particle $2$: $(-0.1, 0, 0)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.7, 0.6)$.\n- Test case $3$ (multiple pairs, test-particle scaling, mixed Pauli factors):\n  - Cell: $\\Delta V = 64$.\n  - Time step: $\\Delta t = 1.0$.\n  - Cross section: $\\sigma = 2.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 50$.\n  - Velocities: particle $1$: $(0.2, 0, 0)$, particle $2$: $(0, 0.3, 0)$, particle $3$: $(-0.1, 0, 0.1)$.\n  - Final-state occupations, listed in the order of unordered pairs $(1,2)$, $(1,3)$, $(2,3)$:\n    - $(f_3, f_4) = (0.2, 0.1)$ for $(1,2)$,\n    - $(f_3, f_4) = (0.5, 0.6)$ for $(1,3)$,\n    - $(f_3, f_4) = (0.0, 0.0)$ for $(2,3)$.\n- Test case $4$ (geometric probability exceeds one before capping; checks capping behavior):\n  - Cell: $\\Delta V = 10$.\n  - Time step: $\\Delta t = 5.0$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.8, 0, 0)$, particle $2$: $(0, 0.6, 0)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.0, 0.0)$.\n- Test case $5$ (zero relative speed; probability must vanish):\n  - Cell: $\\Delta V = 125$.\n  - Time step: $\\Delta t = 0.5$.\n  - Cross section: $\\sigma = 4.0$.\n  - Test particles per nucleon: $N_{\\text{test}} = 1$.\n  - Velocities: particle $1$: $(0.2, 0.1, 0.1)$, particle $2$: $(0.2, 0.1, 0.1)$.\n  - Final-state occupations for the pair $(1,2)$: $(f_3, f_4) = (0.0, 0.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[S_1,S_2,S_3,S_4,S_5]$, each $S_k$ formatted with exactly six digits after the decimal point, for example, $[0.123456,0.000000,0.314159,1.000000,0.271828]$.",
            "solution": "The problem requires the design and implementation of a stochastic binary-collision module for a Boltzmann-Uehling-Uhlenbeck (BUU) transport model. The task is to compute the sum of pairwise collision probabilities for several test cases, starting from fundamental principles of kinetic theory and quantum statistics.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Foundational Principles**:\n  - Kinetic theory: Collision frequency is determined by relative flux and cross-sectional area.\n  - Cross section $\\sigma$: An effective area for interaction.\n  - Pauli exclusion principle: Realized via final-state occupancy factors $(1 - f_3)(1 - f_4)$.\n  - Test-particle method: Microscopic cross section is scaled as $\\sigma_{\\text{eff}} = \\sigma / N_{\\text{test}}$.\n\n- **Modeling Assumptions**:\n  - All particles in a test case reside in a single spatial cell of volume $\\Delta V$.\n  - All pairs are simultaneously eligible for collision during a time step $\\Delta t$.\n  - Relative speed: Nonrelativistic, $v_{\\text{rel}} = \\lVert \\mathbf{v}_1 - \\mathbf{v}_2 \\rVert$.\n  - Pairwise geometric acceptance probability is capped at $1$ before applying occupancy suppression.\n  - Final-state occupations $f_3$ and $f_4$ are given for each pair.\n\n- **Units**:\n  - Natural units with $c=1$.\n  - Distance in femtometers (fm).\n  - Time in fm.\n  - Cross sections in fm$^2$.\n  - Volumes in fm$^3$.\n  - Velocities are dimensionless.\n\n- **Task**:\n  1. For each test case, iterate over all unordered pairs of particles $(i,j)$.\n  2. Compute the pairwise acceptance probability $P_{ij}$.\n  3. Sum all $P_{ij}$ to get a total $S = \\sum_{ij} P_{ij}$ for the test case.\n  4. Output a list of $S$ values for all test cases, formatted to six decimal places.\n\n- **Test Suite Data**: Five test cases are provided, each specifying $\\Delta V$, $\\Delta t$, $\\sigma$, $N_{\\text{test}}$, particle velocities, and final-state occupation factors for relevant pairs.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is firmly rooted in the principles of statistical mechanics and computational nuclear physics. The BUU equation is a standard transport model for heavy-ion collisions. The derivation from kinetic theory, the use of test-particle scaling, and the inclusion of Pauli blocking via Uehling-Uhlenbeck factors are all standard and scientifically correct procedures in this field.\n- **Well-Posed**: The problem is well-posed. All necessary parameters ($\\Delta V$, $\\Delta t$, $\\sigma$, $N_{\\text{test}}$, velocities, and occupation factors) are provided for each test case. The objective—to calculate the sum of pairwise collision probabilities—is clearly defined. The provided formulas and constraints lead to a unique, stable, and meaningful numerical solution for each case.\n- **Objective**: The problem is stated in precise, objective language. There are no subjective claims or ambiguities.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is valid. It is scientifically sound, well-posed, self-contained, and objective. I will proceed with a full solution.\n\n### Derivation and Algorithmic Design\n\nWe derive the pairwise collision probability from first principles as specified.\n\n1.  **Geometric Collision Probability**:\n    In kinetic theory, the collision rate for two particles, $i$ and $j$, within a volume $\\Delta V$ is given by the product of their relative speed $v_{\\text{rel}, ij}$, the collision cross section $\\sigma$, and the probability density of finding the other particle, which is $1/\\Delta V$ for a single particle in the volume. The collision rate for a specific pair $(i,j)$ is thus $R_{ij} = \\frac{\\sigma v_{\\text{rel},ij}}{\\Delta V}$. The probability of a collision occurring within a small time interval $\\Delta t$ is approximated by the rate multiplied by the time duration:\n    $$P_{ij}^{\\text{raw}} = R_{ij} \\Delta t = \\frac{\\sigma v_{\\text{rel},ij} \\Delta t}{\\Delta V}$$\n    This expression represents the probability that particle $i$, sweeping out an interaction volume $\\sigma v_{\\text{rel},ij} \\Delta t$ over the time step, encounters particle $j$, which is assumed to be uniformly distributed in the cell volume $\\Delta V$.\n\n2.  **Test-Particle Scaling**:\n    In many-body transport simulations, each physical particle (e.g., a nucleon) is often represented by $N_{\\text{test}}$ \"test particles\" to improve statistical sampling of the phase-space distribution function. To ensure that the physical collision rate is preserved, the cross section for interactions between test particles, $\\sigma_{\\text{eff}}$, must be scaled. The physical mean free path, $\\lambda \\propto 1/(n\\sigma)$, where $n$ is the physical particle density, must remain invariant. The test particle density is $n_{\\text{test}} = N_{\\text{test}} n$. Requiring the mean free path for a test particle to be the same as for a physical particle, $\\lambda \\propto 1/(n_{\\text{test}}\\sigma_{\\text{eff}})$, implies $n\\sigma = n_{\\text{test}}\\sigma_{\\text{eff}} = (N_{\\text{test}}n)\\sigma_{\\text{eff}}$. This yields the scaling relation:\n    $$\\sigma_{\\text{eff}} = \\frac{\\sigma}{N_{\\text{test}}}$$\n    Substituting this into our probability expression gives the geometric probability for a pair of test particles:\n    $$P_{ij}^{\\text{geom}} = \\frac{\\sigma_{\\text{eff}} v_{\\text{rel},ij} \\Delta t}{\\Delta V} = \\frac{\\sigma v_{\\text{rel},ij} \\Delta t}{N_{\\text{test}} \\Delta V}$$\n\n3.  **Probability Capping**:\n    The expression for $P_{ij}^{\\text{geom}}$ is derived from a rate and is linear in $\\Delta t$. For a sufficiently large time step or high-density environment, this value can exceed $1$, which is unphysical for a probability. To rectify this, and to enforce the condition that a given pair can collide at most once per time step, the geometric probability is capped at $1$.\n    $$P_{ij}^{\\text{capped}} = \\min\\left(1, P_{ij}^{\\text{geom}}\\right)$$\n\n4.  **Pauli Blocking (Uehling-Uhlenbeck Factor)**:\n    The interacting particles are fermions, which must obey the Pauli exclusion principle. A scattering event $i, j \\to i', j'$ is only permitted if the final phase-space states, $i'$ and $j'$, are unoccupied. In a statistical description, the probability of a state being available is $(1-f)$, where $f$ is the phase-space occupation number. Assuming the final state occupancies $f_{i'}$ and $f_{j'}$ are independent, the probability that both final states are available is given by the Uehling-Uhlenbeck factor:\n    $$B_{ij} = (1-f_{i'}) (1-f_{j'})$$\n    The problem provides the values of these final-state occupations, denoted as $f_3$ and $f_4$, for each colliding pair.\n\n5.  **Final Pairwise Acceptance Probability**:\n    Combining the capped geometric probability with the Pauli blocking factor, we obtain the final acceptance probability for a collision between test particles $i$ and $j$ in the time step $\\Delta t$:\n    $$P_{ij} = P_{ij}^{\\text{capped}} \\times B_{ij} = \\min\\left(1, \\frac{\\sigma v_{\\text{rel},ij} \\Delta t}{N_{\\text{test}} \\Delta V}\\right) (1-f_3)(1-f_4)$$\n    where $v_{\\text{rel},ij} = \\lVert \\mathbf{v}_i - \\mathbf{v}_j \\rVert$.\n\n6.  **Total Collision Sum**:\n    The final quantity of interest for each test case is the sum of these probabilities over all unique, unordered pairs of particles within the cell:\n    $$S = \\sum_{ij} P_{ij}$$\n    This quantity represents the expected number of collisions in the cell during the time step $\\Delta t$.\n\nThis completes the derivation. The algorithm for the program will directly implement these steps for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the BUU collision probability problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a dictionary containing all necessary parameters.\n    test_cases = [\n        # Test case 1 (happy path, no Pauli suppression)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([-0.1, 0.0, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 2 (with Pauli suppression)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([-0.1, 0.0, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.7, \"f4\": 0.6},\n            },\n        },\n        # Test case 3 (multiple pairs, test-particle scaling, mixed Pauli factors)\n        {\n            \"delta_V\": 64.0,\n            \"delta_t\": 1.0,\n            \"sigma\": 2.0,\n            \"N_test\": 50,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.0, 0.0])},\n                1: {\"v\": np.array([0.0, 0.3, 0.0])},\n                2: {\"v\": np.array([-0.1, 0.0, 0.1])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.2, \"f4\": 0.1},\n                (0, 2): {\"f3\": 0.5, \"f4\": 0.6},\n                (1, 2): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 4 (geometric probability exceeds one before capping)\n        {\n            \"delta_V\": 10.0,\n            \"delta_t\": 5.0,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.8, 0.0, 0.0])},\n                1: {\"v\": np.array([0.0, 0.6, 0.0])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n        # Test case 5 (zero relative speed)\n        {\n            \"delta_V\": 125.0,\n            \"delta_t\": 0.5,\n            \"sigma\": 4.0,\n            \"N_test\": 1,\n            \"particles\": {\n                0: {\"v\": np.array([0.2, 0.1, 0.1])},\n                1: {\"v\": np.array([0.2, 0.1, 0.1])},\n            },\n            \"pauli_factors\": {\n                (0, 1): {\"f3\": 0.0, \"f4\": 0.0},\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_V = case[\"delta_V\"]\n        delta_t = case[\"delta_t\"]\n        sigma = case[\"sigma\"]\n        N_test = case[\"N_test\"]\n        particles = case[\"particles\"]\n        pauli_factors_map = case[\"pauli_factors\"]\n\n        # Calculate effective cross section\n        sigma_eff = sigma / N_test\n        \n        # Initialize the sum of probabilities for the current test case\n        s_total = 0.0\n\n        # Generate all unique, unordered pairs of particle indices\n        particle_indices = list(particles.keys())\n        for i, j in combinations(particle_indices, 2):\n            # Fetch particle velocities\n            v_i = particles[i][\"v\"]\n            v_j = particles[j][\"v\"]\n\n            # 1. Calculate relative speed\n            v_rel = np.linalg.norm(v_i - v_j)\n\n            # If relative speed is zero, collision probability is zero\n            if v_rel == 0.0:\n                p_ij = 0.0\n            else:\n                # 2. Calculate the geometric probability\n                p_geom = (sigma_eff * v_rel * delta_t) / delta_V\n\n                # 3. Cap the geometric probability at 1.0\n                p_capped = min(1.0, p_geom)\n\n                # 4. Fetch the final-state occupation factors for the pair\n                # The pair (i,j) is always ordered (i  j) by itertools.combinations\n                f3 = pauli_factors_map[(i, j)][\"f3\"]\n                f4 = pauli_factors_map[(i, j)][\"f4\"]\n                \n                # 5. Calculate the Pauli blocking (Uehling-Uhlenbeck) factor\n                pauli_suppression = (1.0 - f3) * (1.0 - f4)\n                \n                # 6. Calculate the final acceptance probability for the pair\n                p_ij = p_capped * pauli_suppression\n\n            # 7. Add the pair's probability to the total sum for the cell\n            s_total += p_ij\n        \n        results.append(s_total)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Before incorporating collisions, it is crucial to accurately model the collisionless dynamics governed by the mean-field potential, a behavior described by the Vlasov equation. This exercise involves implementing a semi-Lagrangian solver for particles in a harmonic potential, a classic testbed for Vlasov codes. Performing a conserved-quantity audit will demonstrate the critical importance of code verification and reveal how numerical errors can accumulate and violate fundamental physical laws like the conservation of energy and momentum .",
            "id": "3544900",
            "problem": "Implement a collisionless Boltzmann-Uehling-Uhlenbeck (BUU) transport solver in one spatial dimension and one momentum dimension that performs a conserved-quantity audit under a scan of time-step $\\Delta t$ and grid resolution $\\Delta x$. Your task is to derive and implement a semi-Lagrangian solver for the Vlasov limit of the BUU equation with a harmonic-oscillator mean-field potential and to monitor conservation of total energy, total momentum, and particle number over long-time integration. Use dimensionless units throughout.\n\nStart from the following foundational base:\n- The Boltzmann-Uehling-Uhlenbeck (BUU) transport equation for the one-body phase-space density $f(x,p,t)$ is\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{p}{m}\\frac{\\partial f}{\\partial x} - \\frac{\\partial U}{\\partial x}\\frac{\\partial f}{\\partial p} = I_{\\mathrm{coll}}[f] ,\n$$\nwhere $m$ is the mass, $U(x)$ is the mean-field potential, and $I_{\\mathrm{coll}}[f]$ is the collision integral with Pauli blocking. In the collisionless (Vlasov) limit, set $I_{\\mathrm{coll}}[f]=0$.\n- For a harmonic oscillator mean field,\n$$\nU(x) = \\tfrac{1}{2} k x^2 , \\quad \\omega \\equiv \\sqrt{k/m} .\n$$\n- The characteristics of the collisionless flow follow Hamilton’s equations,\n$$\n\\dot{x} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial U}{\\partial x} = -k x = -m \\omega^2 x.\n$$\n- The following integrals are conserved exactly by the continuous dynamics:\n  - Particle number $N = \\iint f(x,p,t)\\, dx\\, dp$.\n  - Total momentum $P = \\iint p\\, f(x,p,t)\\, dx\\, dp$.\n  - Total energy $E = \\iint \\left( \\frac{p^2}{2m} + \\tfrac{1}{2} k x^2 \\right) f(x,p,t)\\, dx\\, dp$.\n\nYour numerical model must adhere to the following design:\n- Use the exact characteristic mapping of the harmonic oscillator for time stepping. Over one time step $\\Delta t$, the exact backtracing map from $t^{n+1}$ to $t^n$ is\n$$\n\\begin{pmatrix} x^{\\star} \\\\ p^{\\star} \\end{pmatrix}\n= \\begin{pmatrix}\n\\cos(\\omega \\Delta t)  -\\frac{1}{m \\omega}\\sin(\\omega \\Delta t) \\\\\nm \\omega \\sin(\\omega \\Delta t)  \\cos(\\omega \\Delta t)\n\\end{pmatrix}\n\\begin{pmatrix} x \\\\ p \\end{pmatrix} ,\n$$\nand then set $f^{n+1}(x,p) = f^n(x^{\\star},p^{\\star})$ using bilinear interpolation on a uniform phase-space grid.\n- Use uniform grids $x \\in [x_{\\min}, x_{\\max}]$ and $p \\in [p_{\\min}, p_{\\max}]$ with $N_x$ and $N_p$ cells, respectively, and cell-centered values for $f$. Choose $x_{\\min}=-L_x$, $x_{\\max}=+L_x$, $p_{\\min}=-L_p$, $p_{\\max}=+L_p$ with $L_x=L_p$ sufficiently large so that boundary effects are negligible for the chosen initial condition and simulation time.\n- Initialize $f(x,p,0)$ as a normalized Gaussian in phase space,\n$$\nf(x,p,0) = \\frac{1}{2\\pi \\sigma_x \\sigma_p} \\exp\\!\\left( -\\frac{x^2}{2\\sigma_x^2} - \\frac{p^2}{2\\sigma_p^2} \\right),\n$$\nwith $\\sigma_x = 1$ and $\\sigma_p = 1$.\n- Set $m=1$, $k=1$ so that $\\omega=1$. Evolve to a final time $T_{\\mathrm{end}} = T_{\\mathrm{per}}\\times 2\\pi$ corresponding to $T_{\\mathrm{per}}$ oscillation periods. Use $T_{\\mathrm{per}}=8$. Use $L_x=L_p=6$ so that boundary truncation error is exponentially small for the Gaussian initial data.\n\nConservation audit:\n- At every time step $t_n$, compute\n$$\nN(t_n) = \\sum_{i,j} f_{ij}(t_n)\\, \\Delta x\\, \\Delta p,\\quad\nP(t_n) = \\sum_{i,j} p_j\\, f_{ij}(t_n)\\, \\Delta x\\, \\Delta p,\\quad\nE(t_n) = \\sum_{i,j} \\left( \\frac{p_j^2}{2m} + \\frac{1}{2} k x_i^2 \\right) f_{ij}(t_n)\\, \\Delta x\\, \\Delta p .\n$$\n- Let $N_0, P_0, E_0$ be the initial values. Define running deviations\n$$\n\\delta N(t_n) = |N(t_n)-N_0|,\\quad\n\\delta P(t_n) = |P(t_n)-P_0|,\\quad\n\\delta E(t_n) = |E(t_n)-E_0|.\n$$\n- Report the maxima over the run:\n$$\n\\delta N_{\\max} = \\max_n \\delta N(t_n),\\quad\n\\delta P_{\\max} = \\max_n \\delta P(t_n),\\quad\n\\delta E_{\\max} = \\max_n \\delta E(t_n).\n$$\n- For dimensionless relative audits, compute\n$$\nr_N = \\frac{\\delta N_{\\max}}{\\max(|N_0|,\\varepsilon)},\\quad\nr_P = \\frac{\\delta P_{\\max}}{\\max(|P_0|,\\varepsilon)},\\quad\nr_E = \\frac{\\delta E_{\\max}}{\\max(|E_0|,\\varepsilon)},\n$$\nwith $\\varepsilon = 10^{-12}$ to avoid division by zero. The stability criterion of interest is $r_E  10^{-3}$.\n\nPhysical and numerical units:\n- Use a fully dimensionless system with $m=1$, $k=1$, $\\omega=1$, $\\sigma_x=1$, $\\sigma_p=1$, $L_x=L_p=6$, and $T_{\\mathrm{per}}=8$. All outputs must be pure decimals (unitless).\n\nTest suite and required output:\n- For each parameter triple $(N_x, N_p, \\Delta t)$ below, run the simulation and evaluate whether the energy audit passes $r_E  10^{-3}$:\n  1. ($N_x=32$, $N_p=32$, $\\Delta t=0.10$)\n  2. ($N_x=32$, $N_p=32$, $\\Delta t=0.05$)\n  3. ($N_x=24$, $N_p=24$, $\\Delta t=0.10$)\n  4. ($N_x=64$, $N_p=64$, $\\Delta t=0.10$)\n  5. ($N_x=24$, $N_p=24$, $\\Delta t=0.20$)\n  6. ($N_x=48$, $N_p=48$, $\\Delta t=0.15$)\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, where each entry is a boolean indicating whether $r_E  10^{-3}$. For example, an output like $[True,False,...]$.\n\nYour program must be self-contained, require no user input, and follow exactly the execution environment and library constraints given. The numerical design should be scientifically sound and must implement the audit as specified. All angles are in radians. All reported quantities must be decimals with no units.",
            "solution": "The problem requires the implementation of a semi-Lagrangian solver for the collisionless Boltzmann-Uehling-Uhlenbeck (BUU) equation, also known as the Vlasov equation, in one spatial dimension and one momentum dimension. The system is subject to a harmonic oscillator mean-field potential. The core task is to monitor the conservation of particle number, momentum, and energy over a long-time simulation and audit the numerical accuracy for various grid resolutions and time steps.\n\nThe governing equation for the one-body phase-space distribution function $f(x, p, t)$ is the Vlasov equation:\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{p}{m}\\frac{\\partial f}{\\partial x} - \\frac{\\partial U(x)}{\\partial x}\\frac{\\partial f}{\\partial p} = 0\n$$\nwhere $m$ is the particle mass, $x$ is position, $p$ is momentum, and $U(x)$ is the mean-field potential. For this problem, the potential is that of a simple harmonic oscillator, $U(x) = \\frac{1}{2} k x^2$, where $k$ is the spring constant. The force on a particle is $F_x = -\\frac{\\partial U}{\\partial x} = -k x$. The characteristic curves of this partial differential equation are the classical trajectories of particles in phase space, governed by Hamilton's equations:\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\qquad \\dot{p} = -\\frac{\\partial H}{\\partial x} = -k x\n$$\nwhere the Hamiltonian is $H(x,p) = \\frac{p^2}{2m} + U(x)$. Liouville's theorem, a direct consequence of the Vlasov equation, states that the distribution function $f$ is constant along these characteristics. That is, if $(x(t), p(t))$ is a particle trajectory, then $f(x(t), p(t), t)$ is constant.\n\nThe numerical solution is constructed using a semi-Lagrangian method, which leverages Liouville's theorem. To find the value of the distribution function $f^{n+1}(x, p)$ at a grid point $(x, p)$ at time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time by one step $\\Delta t$ to find its departure point $(x^\\star, p^\\star)$ at time $t^n$. The value of the distribution function is then updated as $f^{n+1}(x, p) = f^n(x^\\star, p^\\star)$.\n\nFor the harmonic oscillator, the solution to Hamilton's equations provides an exact mapping for the characteristics. A particle at phase-space coordinate $(x, p)$ at time $t^{n+1}$ originated from $(x^\\star, p^\\star)$ at time $t^n$, where $(x^\\star, p^\\star)$ is found by evolving $(x, p)$ backward in time by $\\Delta t$. This operation is a linear transformation (a rotation in a scaled phase space) given by the matrix specified in the problem:\n$$\n\\begin{pmatrix} x^{\\star} \\\\ p^{\\star} \\end{pmatrix}\n= \\begin{pmatrix}\n\\cos(\\omega \\Delta t)  -\\frac{1}{m \\omega}\\sin(\\omega \\Delta t) \\\\\nm \\omega \\sin(\\omega \\Delta t)  \\cos(\\omega \\Delta t)\n\\end{pmatrix}\n\\begin{pmatrix} x \\\\ p \\end{pmatrix}\n$$\nwhere $\\omega = \\sqrt{k/m}$ is the natural frequency of the oscillator.\n\nThe departure point $(x^\\star, p^\\star)$ will not, in general, coincide with a point on the discrete phase-space grid at time $t^n$. Therefore, the value $f^n(x^\\star, p^\\star)$ must be estimated by interpolating the values of $f^n$ known at the grid points. The problem specifies bilinear interpolation for this task. This interpolation step is the primary source of numerical error and dissipation in the scheme, causing the numerically computed conserved quantities to drift from their true, constant values.\n\nThe implementation follows these steps. First, we define a uniform, cell-centered phase-space grid with $N_x \\times N_p$ points covering the domain $[-L_x, L_x] \\times [-L_p, L_p]$. The grid spacings are $\\Delta x = 2L_x/N_x$ and $\\Delta p = 2L_p/N_p$. The initial distribution function $f(x, p, 0)$ is set to a normalized Gaussian on this grid. We set the physical parameters to dimensionless values $m=1$, $k=1$, which implies $\\omega=1$.\n\nThe main loop iterates over a number of time steps sufficient to cover the total simulation time $T_{\\mathrm{end}} = T_{\\mathrm{per}} \\times 2\\pi = 16\\pi$. In each step:\n$1$. The entire grid of destination points $(x_{i}, p_{j})$ for the new time step $t^{n+1}$ is considered.\n$2$. For each point, the corresponding departure point $(x^\\star_{ij}, p^\\star_{ij})$ at time $t^n$ is calculated using the vectorized backtracing matrix transformation.\n$3$. A two-dimensional interpolator, `scipy.interpolate.RegularGridInterpolator`, is constructed from the grid values of $f^n$. It is configured to perform bilinear interpolation and to return $0$ for any points traced from outside the simulation domain, which is a reasonable physical assumption for a localized initial distribution.\n$4$. This interpolator is queried at all departure points $(x^\\star_{ij}, p^\\star_{ij})$ to obtain the new distribution $f^{n+1}$.\n\nAt every time step, a conservation audit is performed. The total particle number $N$, total momentum $P$, and total energy $E$ are computed via numerical quadrature (a discrete sum) over the phase-space grid:\n$$\nN(t_n) = \\sum_{i,j} f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n$$\nP(t_n) = \\sum_{i,j} p_j\\, f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\n$$\nE(t_n) = \\sum_{i,j} \\left( \\frac{p_j^2}{2m} + \\frac{1}{2} k x_i^2 \\right) f_{ij}(t_n)\\, \\Delta x\\, \\Delta p\n$$\nThe initial values $N_0$, $P_0$, and $E_0$ are computed from the initial distribution $f(x, p, 0)$. For the given symmetric Gaussian, the analytical values are $N_0=1$, $P_0=0$, and $E_0 = \\frac{\\sigma_p^2}{2m} + \\frac{k\\sigma_x^2}{2} = 1$. The maximum absolute deviations $\\delta N_{\\max}$, $\\delta P_{\\max}$, and $\\delta E_{\\max}$ are tracked throughout the simulation. Finally, the relative error in energy, $r_E = \\delta E_{\\max} / \\max(|E_0|, \\varepsilon)$, is calculated and compared against the tolerance of $10^{-3}$ to determine if the simulation passes the conservation audit. This procedure is repeated for each parameter set in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef run_simulation(Nx, Np, dt):\n    \"\"\"\n    Runs a single Vlasov simulation for a given set of numerical parameters.\n\n    Args:\n        Nx (int): Number of grid points in the x-dimension.\n        Np (int): Number of grid points in the p-dimension.\n        dt (float): Time step size.\n\n    Returns:\n        bool: True if the relative energy error is less than 1e-3, False otherwise.\n    \"\"\"\n    # 1. Define physical and numerical constants\n    m, k = 1.0, 1.0\n    omega = np.sqrt(k / m)\n    sigma_x, sigma_p = 1.0, 1.0\n    Lx, Lp = 6.0, 6.0\n    T_per = 8.0\n    T_end = T_per * 2.0 * np.pi\n    eps = 1e-12\n\n    # 2. Set up the phase-space grid\n    dx = (2.0 * Lx) / Nx\n    dp = (2.0 * Lp) / Np\n    x_coords = np.linspace(-Lx + dx / 2.0, Lx - dx / 2.0, Nx)\n    p_coords = np.linspace(-Lp + dp / 2.0, Lp - dp / 2.0, Np)\n    XX, PP = np.meshgrid(x_coords, p_coords, indexing='ij')\n\n    # 3. Initialize the phase-space distribution function\n    f = (1.0 / (2.0 * np.pi * sigma_x * sigma_p)) * \\\n        np.exp(-XX**2 / (2.0 * sigma_x**2) - PP**2 / (2.0 * sigma_p**2))\n\n    # 4. Compute initial conserved quantities for the audit\n    dV = dx * dp\n    N0 = np.sum(f) * dV\n    P0 = np.sum(PP * f) * dV\n    E_grid = (PP**2 / (2.0 * m)) + (k * XX**2 / 2.0)\n    E0 = np.sum(E_grid * f) * dV\n\n    dev_N_list, dev_P_list, dev_E_list = [], [], []\n\n    # 5. Set up the time evolution loop\n    num_steps = int(np.ceil(T_end / dt))\n    \n    # Pre-calculate trigonometric factors for the backtracing map\n    c = np.cos(omega * dt)\n    s = np.sin(omega * dt)\n\n    f_current = f.copy()\n\n    for _ in range(num_steps):\n        # a. Create an interpolator for the current distribution f^n\n        interpolator = RegularGridInterpolator((x_coords, p_coords), f_current,\n                                               method='linear',\n                                               bounds_error=False,\n                                               fill_value=0.0)\n\n        # b. Calculate backtraced coordinates for the entire grid\n        #    (x*, p*) = R(-dt) * (x, p), where R is the rotation matrix\n        XX_star = c * XX - (s / (m * omega)) * PP\n        PP_star = (m * omega * s) * XX + c * PP\n\n        # c. Query the interpolator at all backtraced points to get f^(n+1)\n        points_to_query = np.stack([XX_star.ravel(), PP_star.ravel()], axis=-1)\n        f_new_flat = interpolator(points_to_query)\n        f_current = f_new_flat.reshape((Nx, Np))\n\n        # d. Perform conservation audit for the new time step\n        N_n = np.sum(f_current) * dV\n        P_n = np.sum(PP * f_current) * dV\n        E_n = np.sum(E_grid * f_current) * dV\n\n        dev_N_list.append(np.abs(N_n - N0))\n        dev_P_list.append(np.abs(P_n - P0))\n        dev_E_list.append(np.abs(E_n - E0))\n\n    # 6. Finalize the audit by calculating relative error\n    if dev_E_list:\n        delta_E_max = np.max(dev_E_list)\n    else:  # Handles the case where num_steps might be 0\n        delta_E_max = 0.0\n\n    r_E = delta_E_max / np.max([np.abs(E0), eps])\n\n    # 7. Return the boolean result based on the energy conservation criterion\n    return r_E  1e-3\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 32, 0.10),\n        (32, 32, 0.05),\n        (24, 24, 0.10),\n        (64, 64, 0.10),\n        (24, 24, 0.20),\n        (48, 48, 0.15),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Np, dt = case\n        result = run_simulation(Nx, Np, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a Python bool is 'True' or 'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A full BUU simulation requires combining the smooth evolution under the mean field (drift) with the stochastic scattering events (collisions), which are governed by operators that do not commute. This practice introduces operator splitting, specifically the second-order Strang splitting scheme, as a robust method for integrating the complete equation. By applying this technique to a simplified model, you will learn how to manage the different timescales and stability requirements of the drift and collision substeps, a key skill for developing a full-fledged transport code .",
            "id": "3544851",
            "problem": "Consider the Boltzmann-Uehling-Uhlenbeck (BUU) transport equation for the single-particle phase-space occupation $f(x,p,t)$ under the assumption of one spatial dimension and a single fixed momentum mode $p$ so that the drift velocity $v$ is constant in time and space. In this simplified setting with no mean-field force, the BUU equation reduces to the linear advection-relaxation equation\n$$\n\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = -\\frac{1}{\\tau}\\left(f - f_{\\mathrm{eq}}\\right),\n$$\nwhere $v = p/m$, $m$ is the particle mass, $\\tau$ is the relaxation time, and $f_{\\mathrm{eq}}$ is a constant Fermi-Dirac equilibrium occupation (here treated as a fixed number in the range $[0,1]$). Units must be consistently used as follows: position $x$ in femtometers (fm), momentum $p$ in megaelectronvolt per speed of light (MeV/$c$), mass $m$ in megaelectronvolt per speed of light squared (MeV/$c^2$), and time $t$ in femtometer per speed of light (fm/$c$). Under these units, the speed $v = p/m$ is dimensionless in units of the speed of light $c$, and the advection term is consistent.\n\nYou are to design and implement a Strang splitting (named after Gilbert Strang) scheme to integrate this equation in time. Let the collision operator be denoted by $\\mathcal{C}[f] = -\\frac{1}{\\tau}(f - f_{\\mathrm{eq}})$ and the drift operator by $\\mathcal{D}[f] = -v \\frac{\\partial f}{\\partial x}$. The Strang splitting time step of size $\\Delta t$ over $[t^n, t^{n+1}]$ is defined as the composition\n$$\nf^{n+1} = \\exp\\left(\\frac{\\Delta t}{2}\\mathcal{C}\\right)\\exp\\left(\\Delta t \\mathcal{D}\\right)\\exp\\left(\\frac{\\Delta t}{2}\\mathcal{C}\\right)f^n,\n$$\napplied on a periodic spatial domain of length $L$ discretized by a uniform grid. Implement the collision substep exactly (analytical relaxation) so that for a half-step of size $\\Delta t/2$,\n$$\nf \\leftarrow f_{\\mathrm{eq}} + \\left(f - f_{\\mathrm{eq}}\\right)\\exp\\left(-\\frac{\\Delta t}{2\\tau}\\right),\n$$\nand implement the drift substep over a full-step $\\Delta t$ using the Lax-Wendroff scheme for linear advection with periodic boundary conditions,\n$$\nf_i^{*} = f_i^n - \\frac{\\alpha}{2}\\left(f_{i+1}^n - f_{i-1}^n\\right) + \\frac{\\alpha^2}{2}\\left(f_{i+1}^n - 2 f_i^n + f_{i-1}^n\\right),\n$$\nwhere $\\alpha = v \\Delta t/\\Delta x$ is the Courant number and $\\Delta x = L/N$ for $N$ grid points.\n\nFrom first principles, you must derive and analyze:\n- What mathematical object the Strang splitting is approximating (operator exponential), why this composition achieves second-order accuracy in time, and the constraints required by the Courant-Friedrichs-Lewy (CFL) condition for the Lax-Wendroff step to be stable.\n- Why exact integration of the collision substep removes stiffness constraints from $\\tau$, and what positivity constraints are expected for $f$ given the chosen initial data.\n\nAnalytical reference solution for verification: for the given model, the exact solution with periodic boundary conditions and constant $v$ and $f_{\\mathrm{eq}}$ is\n$$\nf(x,t) = f_{\\mathrm{eq}} + \\left(f_0\\big((x - v t)\\pmod L\\big) - f_{\\mathrm{eq}}\\right)\\exp\\left(-\\frac{t}{\\tau}\\right),\n$$\nwhere $f_0(x)$ is the initial condition. Use the smooth initial condition\n$$\nf_0(x) = f_{\\mathrm{eq}} + A \\sin\\left(\\frac{2\\pi x}{L}\\right),\n$$\nwith amplitude $A$ satisfying $0  A  1$ to maintain $f \\in [0,1]$ in the continuous model.\n\nYour program must implement the Strang splitting scheme as specified above and evaluate its empirical order of accuracy and stability on the following test suite. For each case, run two simulations at a fixed Courant number $\\alpha$ with a coarse grid and a fine grid (doubling $N$ and halving $\\Delta x$), using $\\Delta t$ chosen to keep the target $\\alpha$ for each resolution. At final time $T$, compute the spatial root-mean-square (RMS) error against the exact solution. Then compute the observed order of accuracy defined as\n$$\np_{\\text{obs}} = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log\\left(\\Delta t_{\\text{coarse}}/\\Delta t_{\\text{fine}}\\right)},\n$$\nwhere $E_{\\mathrm{coarse}}$ and $E_{\\mathrm{fine}}$ are the RMS errors at $T$ for the coarse and fine runs, respectively. Also report two boolean diagnostics per case: whether the positivity constraint $0 \\le f \\le 1$ is satisfied pointwise at $T$, and whether the actual Courant numbers used satisfy the stability constraint $\\alpha \\le 1$.\n\nUse the following test suite, where each parameter is given with its physical unit:\n\n- Case $1$ (happy path, moderate Courant number): $L = 20$ fm, $N_{\\text{coarse}} = 256$, $N_{\\text{fine}} = 512$, $m = 938$ MeV/$c^2$, $p = 300$ MeV/$c$, $\\tau = 5$ fm/$c$, $f_{\\text{eq}} = 0.5$, $A = 0.1$, target $\\alpha = 0.5$, final time $T = 10$ fm/$c$.\n- Case $2$ (near-CFL boundary): $L = 20$ fm, $N_{\\text{coarse}} = 256$, $N_{\\text{fine}} = 512$, $m = 938$ MeV/$c^2$, $p = 300$ MeV/$c$, $\\tau = 5$ fm/$c$, $f_{\\text{eq}} = 0.5$, $A = 0.1$, target $\\alpha = 0.99$, final time $T = 10$ fm/$c$.\n- Case $3$ (stiff collision, exact relaxation): $L = 20$ fm, $N_{\\text{coarse}} = 256$, $N_{\\text{fine}} = 512$, $m = 938$ MeV/$c^2$, $p = 300$ MeV/$c$, $\\tau = 0.2$ fm/$c$, $f_{\\text{eq}} = 0.5$, $A = 0.1$, target $\\alpha = 0.5$, final time $T = 4$ fm/$c$.\n\nNumerical details:\n- Compute $v = p/m$.\n- For each resolution, set $\\Delta x = L/N$ and choose $\\Delta t$ such that $\\alpha = v \\Delta t/\\Delta x$ equals the target value. Use periodic boundary conditions in $x$.\n- To ensure the final time $T$ is attained by an integer number of time steps, adjust $\\Delta t$ to $\\Delta t^{\\star} = T/\\lfloor T/\\Delta t \\rceil$ (nearest-integer rounding), and use this adjusted $\\Delta t^{\\star}$ in both the Strang scheme and the diagnostic computations. Report the actual Courant numbers $\\alpha^{\\star} = v\\Delta t^{\\star}/\\Delta x$ against the constraint $\\alpha^{\\star} \\le 1$.\n\nOutput specification:\n- For each case, compute and output the $5$ values [$E_{\\mathrm{coarse}}$, $E_{\\mathrm{fine}}$, $p_{\\mathrm{obs}}$, positivity_ok, cfl_ok], where the errors are dimensionless (occupations), $p_{\\mathrm{obs}}$ is a float, and the two diagnostics are booleans.\n- Your program should produce a single line of output containing the results for all three cases in a comma-separated list enclosed in square brackets, in the order of cases $1$, $2$, $3$, concatenated, that is\n$$\n\\big[ E^{(1)}_{\\text{coarse}}, E^{(1)}_{\\text{fine}}, p^{(1)}_{\\text{obs}}, \\text{positivity\\_ok}^{(1)}, \\text{cfl\\_ok}^{(1)}, E^{(2)}_{\\text{coarse}}, E^{(2)}_{\\text{fine}}, p^{(2)}_{\\text{obs}}, \\text{positivity\\_ok}^{(2)}, \\text{cfl\\_ok}^{(2)}, E^{(3)}_{\\text{coarse}}, E^{(3)}_{\\text{fine}}, p^{(3)}_{\\text{obs}}, \\text{positivity\\_ok}^{(3)}, \\text{cfl\\_ok}^{(3)} \\big].\n$$\nNo additional text should be printed.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and all necessary parameters and conditions for its solution are provided. It represents a valid and formalizable problem in computational physics.\n\n### Analytical Derivation and Analysis\n\nThe problem requires a derivation and analysis of several aspects of the proposed numerical scheme.\n\n**1. Strang Splitting: Approximation and Accuracy**\n\nThe governing equation is a non-homogeneous partial differential equation of the form $\\frac{\\partial f}{\\partial t} = \\mathcal{D}[f] + \\mathcal{C}[f]$, where $\\mathcal{D}[f] = -v \\frac{\\partial f}{\\partial x}$ is the drift operator and $\\mathcal{C}[f] = -\\frac{1}{\\tau}(f - f_{\\mathrm{eq}})$ is the collision operator. The formal solution over a time step $\\Delta t$ can be written using an evolution operator $\\Phi_{\\Delta t}^{\\text{exact}}$ such that $f(t+\\Delta t) = \\Phi_{\\Delta t}^{\\text{exact}}[f(t)]$.\n\nOperator splitting methods approximate this combined evolution by composing the evolutions of the individual sub-problems, $\\frac{\\partial f}{\\partial t} = \\mathcal{D}[f]$ and $\\frac{\\partial f}{\\partial t} = \\mathcal{C}[f]$. Let $\\Phi_{\\Delta t}^{\\mathcal{D}}$ and $\\Phi_{\\Delta t}^{\\mathcal{C}}$ be the exact flow operators for the drift and collision parts, respectively.\n\nStrang splitting provides a second-order accurate approximation to the true evolution by a symmetric composition:\n$$\n\\Phi_{\\Delta t}^{\\text{Strang}} = \\Phi_{\\Delta t/2}^{\\mathcal{C}} \\circ \\Phi_{\\Delta t}^{\\mathcal{D}} \\circ \\Phi_{\\Delta t/2}^{\\mathcal{C}}\n$$\nWhile the full proof involves the Baker-Campbell-Hausdorff (BCH) formula for non-commuting operators, the second-order accuracy can be understood intuitively by analyzing the Taylor series expansion of the operators. A simple first-order splitting, e.g., Godunov splitting $\\Phi_{\\Delta t}^{\\mathcal{D}} \\circ \\Phi_{\\Delta t}^{\\mathcal{C}}$, has a local truncation error of order $O(\\Delta t^2)$. The symmetric composition in Strang splitting causes the error terms of order $\\Delta t^2$ to cancel, resulting in a local truncation error of order $O(\\Delta t^3)$. When integrated over a fixed time interval $T = N \\Delta t$, the accumulation of local errors leads to a global error of order $O(\\Delta t^2)$, making the scheme second-order accurate in time. This holds even though the operator $\\mathcal{C}$ is affine, as the splitting is applied to the flows (the solutions of the sub-problems), not just the operators themselves. The numerical implementation replaces the exact flow $\\Phi_{\\Delta t}^{\\mathcal{D}}$ with a numerical approximation (Lax-Wendroff), which itself is second-order in space and time for the advection equation. As long as the spatial error does not dominate, the overall scheme's temporal accuracy is dictated by the splitting.\n\n**2. CFL Condition for Lax-Wendroff Stability**\n\nThe stability of the Lax-Wendroff step for the linear advection equation $\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = 0$ is analyzed using the von Neumann stability analysis. We seek solutions of the form $f_j^n = g(k)^n e^{i k j \\Delta x}$, where $f_j^n$ is the numerical solution at grid point $j$ and time step $n$, $k$ is the wavenumber, and $g(k)$ is the amplification factor. Stability requires $|g(k)| \\le 1$ for all $k$.\n\nSubstituting this form into the Lax-Wendroff update formula:\n$$\nf_j^{n+1} = f_j^n - \\frac{\\alpha}{2}\\left(f_{j+1}^n - f_{j-1}^n\\right) + \\frac{\\alpha^2}{2}\\left(f_{j+1}^n - 2 f_j^n + f_{j-1}^n\\right)\n$$\nwhere $\\alpha = v \\Delta t / \\Delta x$, yields the amplification factor $g$ as a function of the dimensionless wavenumber $\\theta = k \\Delta x$:\n$$\ng(\\theta) = 1 - \\frac{\\alpha}{2}(e^{i\\theta} - e^{-i\\theta}) + \\frac{\\alpha^2}{2}(e^{i\\theta} - 2 + e^{-i\\theta})\n$$\nUsing Euler's formula, this simplifies to:\n$$\ng(\\theta) = 1 - i\\alpha\\sin\\theta + \\alpha^2(\\cos\\theta - 1)\n$$\nThe squared magnitude of the amplification factor is:\n$$\n|g(\\theta)|^2 = (1 + \\alpha^2(\\cos\\theta - 1))^2 + (-\\alpha\\sin\\theta)^2 = 1 - 4\\alpha^2(1-\\alpha^2)\\sin^4(\\theta/2)\n$$\nFor stability, we require $|g(\\theta)|^2 \\le 1$. Since $\\sin^4(\\theta/2) \\ge 0$ and $\\alpha^2 \\ge 0$, this condition is satisfied if and only if $1 - \\alpha^2 \\ge 0$. This leads to the Courant-Friedrichs-Lewy (CFL) condition for the Lax-Wendroff scheme:\n$$\n|\\alpha| = \\left| \\frac{v \\Delta t}{\\Delta x} \\right| \\le 1\n$$\n\n**3. Stiffness of the Collision Term**\n\nThe collision term relaxes the occupation number towards equilibrium via the ordinary differential equation $\\frac{df}{dt} = -\\frac{1}{\\tau}(f - f_{\\mathrm{eq}})$. If this equation were discretized using a simple explicit method, such as Forward Euler, the update would be $f^{n+1} = f^n - \\frac{\\Delta t}{\\tau}(f^n - f_{\\mathrm{eq}})$. The stability of this explicit scheme requires $|1 - \\Delta t/\\tau| \\le 1$, which imposes the severe time step constraint $\\Delta t \\le 2\\tau$.\n\nWhen the relaxation time $\\tau$ is very small (a \"stiff\" system), this constraint would force an impractically small $\\Delta t$, likely much smaller than the one required by the CFL condition for the advection part. The problem cleverly bypasses this issue by mandating the use of the exact analytical solution for the collision substep:\n$$\nf(t+\\Delta t/2) = f_{\\mathrm{eq}} + \\left(f(t) - f_{\\mathrm{eq}}\\right)\\exp\\left(-\\frac{\\Delta t}{2\\tau}\\right)\n$$\nSince $\\exp(-\\Delta t/(2\\tau))$ is a positive value less than $1$ for any $\\Delta t > 0$ and $\\tau > 0$, this update is unconditionally stable. The update correctly and stably drives $f$ towards $f_{\\mathrm{eq}}$, regardless of the size of the ratio $\\Delta t/\\tau$. This removes the stiffness constraint entirely, allowing the time step $\\Delta t$ to be chosen based solely on the accuracy requirements and the CFL stability condition of the non-stiff advection solver.\n\n**4. Positivity Constraints**\n\nThe single-particle occupation number $f$ for fermions is physically bound to the interval $[0, 1]$ by the Pauli exclusion principle. The provided initial condition $f_0(x) = f_{\\mathrm{eq}} + A \\sin(2\\pi x/L)$ with $f_{\\mathrm{eq}}=0.5$ and $A=0.1$ satisfies this, as $f_0(x) \\in [0.4, 0.6]$. The analytical solution maintains these bounds for all time since the sinusoidal amplitude decays.\n\nIn the numerical scheme:\n- **Collision Step**: The update $f_{\\text{new}} = f_{\\mathrm{eq}} + (f_{\\text{old}} - f_{\\mathrm{eq}}) e^{-\\Delta t/(2\\tau)}$ is a contraction mapping towards $f_{\\mathrm{eq}}$. If $f_{\\text{old}} \\in [0, 1]$, then $f_{\\text{new}}$ will also be in $[0, 1]$ and, in fact, will be closer to $f_{\\mathrm{eq}}$ than $f_{\\text{old}}$ was. This step is therefore positivity- and bound-preserving.\n- **Drift Step (Lax-Wendroff)**: This scheme is linear and is not guaranteed to be positivity-preserving. It is known to produce spurious oscillations (overshoots and undershoots) near sharp gradients or for Courant numbers approaching the stability limit. Although the initial condition is smooth, these dispersive errors can still lead to values of $f$ falling outside the physical range $[0, 1]$. This is a known limitation of higher-order linear advection schemes, and more complex methods (e.g., equipped with flux limiters) are needed to strictly enforce such bounds. The problem asks to diagnose this potential failure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lax_wendroff_step(f, alpha):\n    \"\"\"\n    Applies a single Lax-Wendroff step for linear advection with periodic boundaries.\n    The update formula is:\n    f_i* = f_i - (alpha/2)(f_{i+1}-f_{i-1}) + (alpha^2/2)(f_{i+1}-2f_i+f_{i-1})\n    \"\"\"\n    f_p1 = np.roll(f, -1)  # f_{i+1}\n    f_m1 = np.roll(f, 1)   # f_{i-1}\n    \n    term1 = (alpha / 2.0) * (f_p1 - f_m1)\n    term2 = (alpha**2 / 2.0) * (f_p1 - 2.0 * f + f_m1)\n    \n    return f - term1 + term2\n\ndef collision_step(f, dt_half, tau, feq):\n    \"\"\"\n    Applies the exact solution of the collision term for a half time step dt_half.\n    This corresponds to the operator exp(dt_half * C).\n    \"\"\"\n    return feq + (f - feq) * np.exp(-dt_half / tau)\n\ndef analytical_solution(x, t, L, v, tau, feq, A):\n    \"\"\"\n    Computes the exact analytical solution for verification.\n    \"\"\"\n    # Advect the initial profile backwards in time by x - v*t\n    # The modulo operator handles periodic boundary conditions correctly\n    x_shifted = (x - v * t) % L\n    f0_shifted = feq + A * np.sin(2.0 * np.pi * x_shifted / L)\n    \n    # Apply the exponential decay from the relaxation term\n    return feq + (f0_shifted - feq) * np.exp(-t / tau)\n\ndef run_simulation(N, L, v, tau, feq, A, target_alpha, T):\n    \"\"\"\n    Runs a single simulation for a given grid resolution and parameters.\n    Returns the RMS error, final state f, adjusted time step, and adjusted Courant number.\n    \"\"\"\n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # Determine the ideal time step for the target Courant number\n    dt_target = target_alpha * dx / v\n    if dt_target = 0:\n        raise ValueError(\"Target time step must be positive.\")\n\n    # Adjust dt to hit the final time T exactly, using an integer number of steps\n    num_steps = int(np.rint(T / dt_target))\n    if num_steps == 0:\n        num_steps = 1 # Ensure at least one step for very small T or large dt_target\n    dt_star = T / num_steps\n    alpha_star = v * dt_star / dx\n\n    # Set initial condition\n    f = feq + A * np.sin(2.0 * np.pi * x / L)\n\n    # Time evolution using the Strang splitting scheme\n    for _ in range(num_steps):\n        # 1. Half collision step\n        f = collision_step(f, dt_star / 2.0, tau, feq)\n        # 2. Full drift step using Lax-Wendroff\n        f = lax_wendroff_step(f, alpha_star)\n        # 3. Half collision step\n        f = collision_step(f, dt_star / 2.0, tau, feq)\n    \n    f_numerical_final = f\n    f_exact_final = analytical_solution(x, T, L, v, tau, feq, A)\n    \n    # Compute the spatial Root-Mean-Square (RMS) error\n    rms_error = np.sqrt(np.mean((f_numerical_final - f_exact_final)**2))\n\n    return rms_error, f_numerical_final, dt_star, alpha_star\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case, running simulations on coarse and fine grids\n    and computing the required output metrics.\n    \"\"\"\n    L = case_params['L']\n    N_coarse = case_params['N_coarse']\n    N_fine = case_params['N_fine']\n    m = case_params['m']\n    p = case_params['p']\n    tau = case_params['tau']\n    feq = case_params['f_eq']\n    A = case_params['A']\n    target_alpha = case_params['target_alpha']\n    T = case_params['T']\n    \n    # Calculate drift velocity (dimensionless in units of c)\n    v = p / m\n\n    # Coarse grid simulation\n    E_coarse, f_final_coarse, dt_coarse, alpha_coarse = run_simulation(\n        N_coarse, L, v, tau, feq, A, target_alpha, T)\n\n    # Fine grid simulation\n    E_fine, f_final_fine, dt_fine, alpha_fine = run_simulation(\n        N_fine, L, v, tau, feq, A, target_alpha, T)\n        \n    # Calculate observed order of accuracy\n    # p_obs = log(E_coarse/E_fine) / log(dt_coarse/dt_fine)\n    # Since dt is proportional to dx, this is approximately log(E_c/E_f)/log(2)\n    # Using the actual adjusted time steps is more precise.\n    ratio_dt = dt_coarse / dt_fine\n    if E_coarse = 0 or E_fine = 0 or ratio_dt = 1:\n        p_obs = np.nan # Avoid division by zero or log of non-positive\n    else:\n        p_obs = np.log(E_coarse / E_fine) / np.log(ratio_dt)\n    \n    # Check physical and numerical constraints for the case\n    # Positivity: 0 = f = 1 must hold for all grid points at final time T\n    positivity_ok_coarse = np.all((f_final_coarse >= 0.0)  (f_final_coarse = 1.0))\n    positivity_ok_fine = np.all((f_final_fine >= 0.0)  (f_final_fine = 1.0))\n    positivity_ok = positivity_ok_coarse and positivity_ok_fine\n    \n    # CFL stability: actual Courant number alpha* = 1\n    cfl_ok_coarse = alpha_coarse = 1.0\n    cfl_ok_fine = alpha_fine = 1.0\n    cfl_ok = cfl_ok_coarse and cfl_ok_fine\n    \n    return [E_coarse, E_fine, p_obs, positivity_ok, cfl_ok]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path, moderate Courant number\n        {'L': 20.0, 'N_coarse': 256, 'N_fine': 512, 'm': 938.0, 'p': 300.0,\n         'tau': 5.0, 'f_eq': 0.5, 'A': 0.1, 'target_alpha': 0.5, 'T': 10.0},\n        # Case 2: Near CFL boundary\n        {'L': 20.0, 'N_coarse': 256, 'N_fine': 512, 'm': 938.0, 'p': 300.0,\n         'tau': 5.0, 'f_eq': 0.5, 'A': 0.1, 'target_alpha': 0.99, 'T': 10.0},\n        # Case 3: Stiff collision term\n        {'L': 20.0, 'N_coarse': 256, 'N_fine': 512, 'm': 938.0, 'p': 300.0,\n         'tau': 0.2, 'f_eq': 0.5, 'A': 0.1, 'target_alpha': 0.5, 'T': 4.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = process_case(case)\n        results.extend(case_results)\n\n    # Format the final output string as specified\n    # map(str, ...) handles conversion of floats and booleans to strings\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}