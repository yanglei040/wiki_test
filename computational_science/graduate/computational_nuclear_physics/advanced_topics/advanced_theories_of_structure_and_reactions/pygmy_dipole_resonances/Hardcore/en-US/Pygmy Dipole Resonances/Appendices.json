{
    "hands_on_practices": [
        {
            "introduction": "Theoretical calculations in nuclear structure often produce a discrete spectrum of transition strengths and energies. A primary task for a physicist is to distill meaningful observables from this raw output. This exercise provides foundational practice in this skill by focusing on how to quantify the contribution of the Pygmy Dipole Resonance (PDR) from a given electric dipole ($E1$) strength distribution. You will implement the definition of the energy-weighted sum rule ($m_1$) to calculate the fraction of the total strength that resides in the low-energy PDR region, a key metric for comparing theoretical predictions with experimental data. ",
            "id": "3582897",
            "problem": "You are given a discrete electric dipole ($E1$) spectrum represented by excitation energies $E_{\\nu}$ (in $\\mathrm{MeV}$) and reduced transition probabilities $B(E1;0\\rightarrow\\nu)$ (in $e^{2}\\ \\mathrm{fm}^{2}$). In linear response theory, the $E1$ strength function can be modeled as a sum over discrete states, and the energy-weighted sum rule of order $k$, denoted $m_{k}$, is defined on the discrete spectrum by the fundamental definition $m_{k}=\\sum_{\\nu} E_{\\nu}^{k}\\, B(E1;0\\rightarrow\\nu)$. The case $k=1$ gives the energy-weighted sum rule $m_{1}$. The fraction of $m_{1}$ exhausted by the pygmy dipole resonance (PDR) up to a cutoff energy $E_{c}$ is defined as the ratio of the energy-weighted strength carried by states with $E_{\\nu}\\leq E_{c}$ to the total energy-weighted strength over all states. Your task is to design and implement a computation, starting from these definitions alone, to evaluate this fraction for several test spectra and cutoff energies.\n\nUse the following base principles and definitions:\n- The discrete strength function can be expressed as $S(E)=\\sum_{\\nu} B(E1;0\\rightarrow\\nu)\\,\\delta(E-E_{\\nu})$.\n- The energy-weighted sum $m_{1}$ of the discrete spectrum is given by $m_{1}=\\int_{0}^{\\infty} E\\,S(E)\\,dE=\\sum_{\\nu} E_{\\nu}\\, B(E1;0\\rightarrow\\nu)$.\n- The PDR fraction up to $E_{c}$, denoted $f(E_{c})$, is given by the ratio $f(E_{c})=\\dfrac{\\sum_{E_{\\nu}\\leq E_{c}} E_{\\nu}\\,B(E1;0\\rightarrow\\nu)}{\\sum_{\\nu} E_{\\nu}\\,B(E1;0\\rightarrow\\nu)}$.\n\nAlgorithmic requirements:\n- Implement a function that, given arrays of $E_{\\nu}$ and $B(E1;0\\rightarrow\\nu)$ and a cutoff $E_{c}$, computes $f(E_{c})$ using the inclusive condition $E_{\\nu}\\leq E_{c}$.\n- The result is dimensionless; ensure the program outputs floating-point values rounded to $6$ decimal places.\n- All energies $E_{\\nu}$ are in $\\mathrm{MeV}$, and all $B(E1;0\\rightarrow\\nu)$ values are in $e^{2}\\ \\mathrm{fm}^{2}$. The final fraction $f(E_{c})$ has no unit.\n\nTest suite:\nCompute $f(E_{c})$ for each of the following parameter sets. Each test case is a triple $(\\{E_{\\nu}\\},\\{B_{\\nu}\\},E_{c})$ where $\\{E_{\\nu}\\}$ is the list of excitation energies and $\\{B_{\\nu}\\}$ is the list of corresponding $B(E1;0\\rightarrow\\nu)$ values in the same order. The cutoff $E_{c}$ is given in $\\mathrm{MeV}$.\n\n- Test case $1$ (general case with low-energy PDR states and higher-energy giant dipole strength):\n  - $\\{E_{\\nu}\\}=\\{5.2,\\ 6.8,\\ 7.4,\\ 8.1,\\ 9.5,\\ 14.8,\\ 15.3,\\ 16.7,\\ 17.2\\}\\ \\mathrm{MeV}$\n  - $\\{B_{\\nu}\\}=\\{0.023,\\ 0.017,\\ 0.015,\\ 0.012,\\ 0.010,\\ 0.450,\\ 0.380,\\ 0.300,\\ 0.280\\}\\ e^{2}\\ \\mathrm{fm}^{2}$\n  - $E_{c}=10.0\\ \\mathrm{MeV}$\n- Test case $2$ (boundary case with $E_{c}$ below the smallest excitation energy):\n  - $\\{E_{\\nu}\\}=\\{5.2,\\ 6.8,\\ 7.4,\\ 8.1,\\ 9.5,\\ 14.8,\\ 15.3,\\ 16.7,\\ 17.2\\}\\ \\mathrm{MeV}$\n  - $\\{B_{\\nu}\\}=\\{0.023,\\ 0.017,\\ 0.015,\\ 0.012,\\ 0.010,\\ 0.450,\\ 0.380,\\ 0.300,\\ 0.280\\}\\ e^{2}\\ \\mathrm{fm}^{2}$\n  - $E_{c}=4.0\\ \\mathrm{MeV}$\n- Test case $3$ (boundary case with $E_{c}$ above the largest excitation energy):\n  - $\\{E_{\\nu}\\}=\\{5.2,\\ 6.8,\\ 7.4,\\ 8.1,\\ 9.5,\\ 14.8,\\ 15.3,\\ 16.7,\\ 17.2\\}\\ \\mathrm{MeV}$\n  - $\\{B_{\\nu}\\}=\\{0.023,\\ 0.017,\\ 0.015,\\ 0.012,\\ 0.010,\\ 0.450,\\ 0.380,\\ 0.300,\\ 0.280\\}\\ e^{2}\\ \\mathrm{fm}^{2}$\n  - $E_{c}=25.0\\ \\mathrm{MeV}$\n- Test case $4$ (edge case testing inclusion when $E_{c}$ equals an excitation energy and presence of zero-strength states):\n  - $\\{E_{\\nu}\\}=\\{4.0,\\ 6.0,\\ 10.0,\\ 12.0\\}\\ \\mathrm{MeV}$\n  - $\\{B_{\\nu}\\}=\\{0.000,\\ 0.005,\\ 0.020,\\ 0.300\\}\\ e^{2}\\ \\mathrm{fm}^{2}$\n  - $E_{c}=10.0\\ \\mathrm{MeV}$\n\nOutput specification:\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets. For example, the format must be $[r_{1},r_{2},r_{3},r_{4}]$, where each $r_{i}$ is $f(E_{c})$ for the corresponding test case, rounded to $6$ decimal places.",
            "solution": "The problem is assessed to be **valid**. It is scientifically grounded in the established principles of nuclear physics, specifically the theory of nuclear giant resonances and sum rules. The definitions provided for the energy-weighted sum rule ($m_1$) and the fraction of strength ($f(E_c)$) are standard in the field. The problem is well-posed, providing all necessary data, clear definitions, and a unique, computable objective. The data in the test cases are physically plausible. There are no contradictions, ambiguities, or factual inaccuracies.\n\nThe objective is to compute the fraction of the electric dipole ($E1$) energy-weighted sum rule ($m_1$) that is exhausted by discrete states up to a cutoff energy $E_c$. This fraction, $f(E_c)$, is a key observable for quantifying the strength of low-energy resonance structures like the pygmy dipole resonance (PDR). The problem provides the fundamental formula for this computation:\n$$\nf(E_{c})=\\dfrac{\\sum_{E_{\\nu}\\leq E_{c}} E_{\\nu}\\,B(E1;0\\rightarrow\\nu)}{\\sum_{\\nu} E_{\\nu}\\,B(E1;0\\rightarrow\\nu)}\n$$\nwhere $\\{E_{\\nu}\\}$ is the set of discrete excitation energies and $\\{B(E1;0\\rightarrow\\nu)\\}$ is the set of corresponding reduced transition probabilities.\n\nThe design of the algorithm directly follows from this mathematical definition. The computation can be decomposed into three primary steps:\n\n1.  **Computation of the Total Energy-Weighted Sum ($m_1$)**: The denominator of the expression for $f(E_c)$ is the total energy-weighted sum, $m_1 = \\sum_{\\nu} E_{\\nu}\\,B(E1;0\\rightarrow\\nu)$. This is computed by first taking the element-wise product of the input arrays for energies, $E_{\\nu}$, and transition probabilities, $B(E1;0\\rightarrow\\nu)$. The sum of all elements of this resulting product array gives the total $m_1$. Given an array of energies $\\mathbf{E} = [E_1, E_2, \\dots, E_N]$ and an array of transition probabilities $\\mathbf{B} = [B_1, B_2, \\dots, B_N]$, this step corresponds to calculating $\\sum_{i=1}^{N} E_i B_i$.\n\n2.  **Computation of the Partial Energy-Weighted Sum up to $E_c$**: The numerator is the portion of the energy-weighted sum contributed by states with energy $E_{\\nu}$ less than or equal to the cutoff $E_c$. This is defined as $\\sum_{E_{\\nu}\\leq E_{c}} E_{\\nu}\\,B(E1;0\\rightarrow\\nu)$. Algorithmically, this is achieved by filtering the states based on the condition $E_{\\nu} \\leq E_c$. We identify all indices $\\nu$ for which this condition holds. Then, we sum the corresponding energy-weighted products $E_{\\nu}B(E1;0\\rightarrow\\nu)$ only for these selected indices.\n\n3.  **Computation of the Fraction $f(E_c)$**: The final step is to compute the ratio of the partial sum (from Step 2) to the total sum (from Step 1). A special case must be considered: if the total sum $m_1$ is zero (which would happen if all $B(E1)$ values were zero), the fraction is undefined. However, in any physical system with an $E1$ response, $m_1  0$. For the test cases provided, $m_1$ is strictly positive. If $m_1=0$, the numerator must also be $0$, and the physically meaningful result for the fraction is $0$. The implementation will handle this by returning $0.0$ if the calculated denominator is $0$.\n\nThe implementation will use the `numpy` library, which is highly optimized for numerical operations on arrays.\n- The input lists of energies and transition probabilities will be converted to `numpy` arrays, let's call them `E_arr` and `B_arr`.\n- The element-wise product $E_{\\nu} B(E1;0\\rightarrow\\nu)$ is efficiently computed as `ew_strength = E_arr * B_arr`.\n- The total sum $m_1$ is then simply `np.sum(ew_strength)`.\n- To compute the numerator, a boolean mask is created: `mask = E_arr = E_c`. This mask identifies the elements in `E_arr` satisfying the energy cutoff condition.\n- The partial sum is then computed by applying this mask to the `ew_strength` array and summing the result: `np.sum(ew_strength[mask])`.\n- Finally, the ratio is calculated and rounded to $6$ decimal places as required by the problem specification.\n\nThis approach provides a direct, efficient, and robust translation of the physical definition into a computational algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pygmy dipole resonance fraction problem for the given test cases.\n    \"\"\"\n\n    # Test suite from the problem statement.\n    # Each case is a tuple: (list of energies, list of B(E1) values, cutoff energy).\n    test_cases = [\n        (\n            [5.2, 6.8, 7.4, 8.1, 9.5, 14.8, 15.3, 16.7, 17.2],\n            [0.023, 0.017, 0.015, 0.012, 0.010, 0.450, 0.380, 0.300, 0.280],\n            10.0\n        ),\n        (\n            [5.2, 6.8, 7.4, 8.1, 9.5, 14.8, 15.3, 16.7, 17.2],\n            [0.023, 0.017, 0.015, 0.012, 0.010, 0.450, 0.380, 0.300, 0.280],\n            4.0\n        ),\n        (\n            [5.2, 6.8, 7.4, 8.1, 9.5, 14.8, 15.3, 16.7, 17.2],\n            [0.023, 0.017, 0.015, 0.012, 0.010, 0.450, 0.380, 0.300, 0.280],\n            25.0\n        ),\n        (\n            [4.0, 6.0, 10.0, 12.0],\n            [0.000, 0.005, 0.020, 0.300],\n            10.0\n        )\n    ]\n\n    def compute_pdr_fraction(energies, b_values, e_cutoff):\n        \"\"\"\n        Computes the fraction of the m1 sum rule up to a cutoff energy.\n\n        Args:\n            energies (list or np.ndarray): Excitation energies E_nu in MeV.\n            b_values (list or np.ndarray): Reduced transition probabilities B(E1) in e^2 fm^2.\n            e_cutoff (float): The cutoff energy E_c in MeV.\n\n        Returns:\n            float: The dimensionless fraction f(E_c).\n        \"\"\"\n        E_arr = np.array(energies)\n        B_arr = np.array(b_values)\n\n        # Calculate the energy-weighted strength for each state: E_nu * B(E1)\n        energy_weighted_strengths = E_arr * B_arr\n\n        # Calculate the total energy-weighted sum (denominator)\n        m1_total = np.sum(energy_weighted_strengths)\n\n        # If total sum rule is zero, the fraction is also zero.\n        if m1_total == 0.0:\n            return 0.0\n\n        # Create a boolean mask for states with energy = e_cutoff\n        mask = E_arr = e_cutoff\n\n        # Calculate the partial energy-weighted sum (numerator)\n        # by summing the strengths of states that satisfy the condition\n        m1_pdr = np.sum(energy_weighted_strengths[mask])\n        \n        # Compute the fraction\n        fraction = m1_pdr / m1_total\n        \n        return fraction\n\n    # Process each test case and store the formatted results\n    results = []\n    for E_nu, B_nu, E_c in test_cases:\n        result = compute_pdr_fraction(E_nu, B_nu, E_c)\n        # Format the result to 6 decimal places as required.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Before drawing physical conclusions from any large-scale computation, it is imperative to perform validation checks against known theoretical constraints. For the $E1$ response, the energy-weighted sum rule offers a powerful and nearly model-independent anchor. This practice introduces the celebrated Thomas-Reiche-Kuhn (TRK) sum rule, which, when enhanced by corrections from the nuclear interaction, provides a robust benchmark for the total integrated $E1$ strength. By comparing the sum from a discrete spectrum to the analytical TRK value, you will learn how to perform a critical consistency test on the output of a nuclear model, a vital step in computational physics. ",
            "id": "3582935",
            "problem": "You are validating a Quasiparticle Random Phase Approximation (QRPA) implementation for Pygmy Dipole Resonance (PDR) and isovector Giant Dipole Resonance (GDR) response using the energy-weighted sum rule. Starting from the linear response definition, the energy-weighted sum of discrete transition strengths is the first moment of the strength function, defined as $m_1 = \\sum_i E_i B_i$, where $E_i$ are excitation energies and $B_i$ are reduced electric dipole transition probabilities. The analytic benchmark for the isovector electric dipole energy-weighted sum, derived from the double-commutator sum rule, is the Thomas-Reiche-Kuhn (TRK) value with enhancement due to velocity-dependent terms, given by $m_1^{\\mathrm{TRK}} = \\frac{9}{4\\pi} \\frac{\\hbar^2}{2 m_N} \\frac{N Z}{A} (1 + \\kappa)$. Here, $\\hbar^2/(2 m_N)$ is a standard constant for the nucleon mass, and $\\kappa$ is a dimensionless enhancement factor originating from the chosen energy density functional.\n\nImplement a program that:\n- Computes the discrete energy-weighted sum $m_1 = \\sum_i E_i B_i$ from provided QRPA-like state lists.\n- Computes the analytic benchmark $m_1^{\\mathrm{TRK}}$ for the same nucleus using $m_1^{\\mathrm{TRK}} = \\frac{9}{4\\pi} \\frac{\\hbar^2}{2 m_N} \\frac{N Z}{A} (1 + \\kappa)$ with $\\hbar^2/(2 m_N) = 20.735$ in units of MeV fm$^2$.\n- Compares the two using a specified tolerance and outputs a boolean indicating whether the computed $m_1$ is within the allowed deviation from $m_1^{\\mathrm{TRK}}$.\n\nScientific and numerical details and requirements:\n- All excitation energies $E_i$ must be provided in MeV.\n- All reduced transition probabilities $B_i$ must be provided in $e^2\\,\\mathrm{fm}^2$.\n- The sum $m_1$ is thus in $e^2\\,\\mathrm{fm}^2\\,\\mathrm{MeV}$.\n- The tolerance is a relative bound $\\delta$; the test passes if $\\lvert m_1 - m_1^{\\mathrm{TRK}} \\rvert \\le \\delta\\, m_1^{\\mathrm{TRK}}$ for cases where $m_1^{\\mathrm{TRK}}  0$. For cases with $m_1^{\\mathrm{TRK}} = 0$, use an absolute tolerance $\\epsilon$ and require $\\lvert m_1 \\rvert \\le \\epsilon$.\n\nUse the following test suite of nuclei and discrete state sets. Each test case is a tuple $(N,Z,A,\\kappa,\\{E_i\\},\\{B_i\\})$ with the tolerance parameters $\\delta = 0.05$ and $\\epsilon = 10^{-9}$:\n\n1. Case A (happy path, near-complete collection): $N=82$, $Z=50$, $A=132$, $\\kappa=0.2$, $E=\\,[7.8,\\,8.5,\\,9.2,\\,14.5,\\,15.8,\\,17.2,\\,18.5,\\,20.0]$, $B=\\,[0.35,\\,0.40,\\,0.45,\\,6.0,\\,8.0,\\,7.5,\\,5.0,\\,5.4171]$.\n2. Case B (under-collection, incomplete model space): $N=40$, $Z=28$, $A=68$, $\\kappa=0.25$, $E=\\,[7.7,\\,8.2,\\,9.0,\\,15.0,\\,16.5,\\,18.0]$, $B=\\,[0.5,\\,0.6,\\,0.4,\\,6.0,\\,6.5,\\,4.0]$.\n3. Case C (over-collection, contamination or double counting): $N=126$, $Z=82$, $A=208$, $\\kappa=0.1$, $E=\\,[7.5,\\,8.0,\\,8.6,\\,13.0,\\,14.8,\\,16.2,\\,17.5]$, $B=\\,[0.2,\\,0.3,\\,0.35,\\,14.0,\\,16.0,\\,15.0,\\,13.0]$.\n4. Case D (zero benchmark, no isovector E1 sum): $N=0$, $Z=1$, $A=1$, $\\kappa=0.0$, $E=\\,[\\,]$ (empty list), $B=\\,[\\,]$ (empty list).\n5. Case E (near-complete collection with small deficit): $N=70$, $Z=50$, $A=120$, $\\kappa=0.2$, $E=\\,[7.9,\\,8.3,\\,9.1,\\,14.2,\\,15.7,\\,17.0,\\,18.3,\\,19.2]$, $B=\\,[0.4,\\,0.45,\\,0.5,\\,5.5,\\,7.0,\\,6.5,\\,4.5,\\,6.0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above. Each element is a boolean indicating whether the case passes the validation, for example, $[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$.",
            "solution": "The validation method is grounded in the energy-weighted sum rule derived from linear response theory and the double-commutator identity. For an operator $F$ and Hamiltonian $H$, one has the general identity\n$$\nm_1(F) = \\frac{1}{2} \\langle 0 | [F,[H,F]] | 0 \\rangle,\n$$\nwhere $|0\\rangle$ denotes the ground state. In the discrete spectral representation of the strength function, the first energy-weighted sum rule is\n$$\nm_1 = \\sum_i E_i B_i,\n$$\nwhere $E_i$ are excitation energies and $B_i$ are reduced transition probabilities, both extracted from Quasiparticle Random Phase Approximation (QRPA) calculations.\n\nFor the isovector electric dipole operator associated with the dipole response in nuclei, the analytic benchmark is the Thomas-Reiche-Kuhn (TRK) sum rule. In an independent-particle model with a kinetic-energy Hamiltonian, the double commutator yields the TRK sum without enhancement. However, in realistic energy density functionals containing velocity-dependent and exchange terms, the sum is enhanced by a factor $(1+\\kappa)$, where $\\kappa$ is a dimensionless parameter that encapsulates these additional contributions. The resulting analytic benchmark is\n$$\nm_1^{\\mathrm{TRK}} = \\frac{9}{4\\pi} \\frac{\\hbar^2}{2 m_N} \\frac{N Z}{A} (1 + \\kappa).\n$$\nThe constant $\\hbar^2/(2 m_N)$ is a well-known value for the nucleon mass, which in practical computations is taken as $\\hbar^2/(2 m_N) = 20.735$ in units of MeV fm$^2$ so that $m_1^{\\mathrm{TRK}}$ is in $e^2\\,\\mathrm{fm}^2\\,\\mathrm{MeV}$ when $B_i$ are in $e^2\\,\\mathrm{fm}^2$ and $E_i$ in MeV.\n\nAlgorithmic steps for the program:\n1. For each test case $(N,Z,A,\\kappa,\\{E_i\\},\\{B_i\\})$, compute\n$$\nm_1 = \\sum_i E_i B_i.\n$$\n2. Compute the analytic benchmark\n$$\nm_1^{\\mathrm{TRK}} = \\frac{9}{4\\pi} \\cdot \\left( \\frac{\\hbar^2}{2 m_N} \\right) \\cdot \\left( \\frac{N Z}{A} \\right) \\cdot (1 + \\kappa),\n$$\nwith $\\frac{\\hbar^2}{2 m_N} = 20.735$ MeV fm$^2$.\n3. Apply the pass/fail criterion. Use the relative tolerance $\\delta = 0.05$ for cases with $m_1^{\\mathrm{TRK}}  0$:\n$$\n\\text{pass if } \\lvert m_1 - m_1^{\\mathrm{TRK}} \\rvert \\le \\delta\\, m_1^{\\mathrm{TRK}}.\n$$\nFor $m_1^{\\mathrm{TRK}} = 0$, use an absolute tolerance $\\epsilon = 10^{-9}$:\n$$\n\\text{pass if } \\lvert m_1 \\rvert \\le \\epsilon.\n$$\n\nScientific rationale tied to Pygmy Dipole Resonance (PDR):\n- The PDR manifests as low-energy dipole strength, typically fragmented below the main GDR peak. In QRPA, this is captured by discrete transitions at lower energies with smaller $B(E1)$ values. The energy-weighted sum $m_1$ collects contributions from both PDR and GDR regions.\n- A well-implemented QRPA should recover the TRK sum rule (with the appropriate $(1+\\kappa)$ enhancement) within a reasonable tolerance when the configuration space and residual interactions are adequate. Under-collection indicates missing configurations or insufficient model space; over-collection suggests contamination such as center-of-mass spuriosity or double counting.\n\nSanity checks over the provided test suite:\n- Case A ($N=82$, $Z=50$, $A=132$, $\\kappa=0.2$): The discrete list has low-energy PDR-like transitions and several GDR-like transitions chosen so that $m_1$ is very close to $m_1^{\\mathrm{TRK}}$, hence expected to pass.\n- Case B ($N=40$, $Z=28$, $A=68$, $\\kappa=0.25$): The discrete sum is intentionally below the benchmark (roughly several percent deficit), expected to fail under $\\delta = 0.05$.\n- Case C ($N=126$, $Z=82$, $A=208$, $\\kappa=0.1$): The discrete sum is intentionally above the benchmark (over-collection), expected to fail.\n- Case D ($N=0$, $Z=1$, $A=1$, $\\kappa=0.0$): The benchmark is zero since $\\frac{N Z}{A} = 0$, and the discrete spectrum is empty, yielding $m_1 = 0$, expected to pass under the absolute tolerance.\n- Case E ($N=70$, $Z=50$, $A=120$, $\\kappa=0.2$): The discrete sum is slightly below the benchmark but within the $5\\%$ relative tolerance, expected to pass.\n\nThe program outputs a single line with a list of booleans indicating pass/fail for Cases A through E, in order. This directly operationalizes the energy-weighted sum rule validation for QRPA implementations against the TRK benchmark with enhancement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_m1_discrete(energies, strengths):\n    # Energies in MeV, strengths in e^2 fm^2; result in e^2 fm^2 MeV\n    if len(energies) == 0:\n        return 0.0\n    e = np.array(energies, dtype=float)\n    b = np.array(strengths, dtype=float)\n    return float(np.dot(e, b))\n\ndef compute_m1_trk(N, Z, A, kappa):\n    # m1_TRK = (9/(4*pi)) * (hbar^2/(2 m_N)) * (N*Z/A) * (1 + kappa)\n    hbar2_over_2mN = 20.735  # MeV fm^2\n    prefactor = 9.0 / (4.0 * np.pi)\n    if A == 0:\n      return 0.0\n    return float(prefactor * hbar2_over_2mN * (N * Z / A) * (1.0 + kappa))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, Z, A, kappa, energies_list, strengths_list)\n    test_cases = [\n        # Case A: 132Sn, near-complete collection\n        (82, 50, 132, 0.2,\n         [7.8, 8.5, 9.2, 14.5, 15.8, 17.2, 18.5, 20.0],\n         [0.35, 0.40, 0.45, 6.0, 8.0, 7.5, 5.0, 5.4171]),\n        # Case B: 68Ni, under-collection\n        (40, 28, 68, 0.25,\n         [7.7, 8.2, 9.0, 15.0, 16.5, 18.0],\n         [0.5, 0.6, 0.4, 6.0, 6.5, 4.0]),\n        # Case C: 208Pb, over-collection\n        (126, 82, 208, 0.1,\n         [7.5, 8.0, 8.6, 13.0, 14.8, 16.2, 17.5],\n         [0.2, 0.3, 0.35, 14.0, 16.0, 15.0, 13.0]),\n        # Case D: 1H, zero TRK benchmark, empty spectrum\n        (0, 1, 1, 0.0,\n         [], []),\n        # Case E: 120Sn, small deficit within tolerance\n        (70, 50, 120, 0.2,\n         [7.9, 8.3, 9.1, 14.2, 15.7, 17.0, 18.3, 19.2],\n         [0.4, 0.45, 0.5, 5.5, 7.0, 6.5, 4.5, 6.0]),\n    ]\n\n    # Tolerances\n    rel_tol = 0.05  # relative tolerance for nonzero TRK\n    abs_tol = 1e-9  # absolute tolerance for zero TRK\n\n    results = []\n    for (N, Z, A, kappa, energies, strengths) in test_cases:\n        m1_disc = compute_m1_discrete(energies, strengths)\n        m1_trk = compute_m1_trk(N, Z, A, kappa)\n        if m1_trk > 0.0:\n            passes = abs(m1_disc - m1_trk) = rel_tol * m1_trk\n        else:\n            passes = abs(m1_disc) = abs_tol\n        results.append(passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having learned to analyze and validate a given strength distribution, we now turn to the task of generating one from a microscopic theoretical framework. This advanced practice guides you through the implementation of a simplified but self-consistent Quasiparticle Random Phase Approximation (QRPA) model, a workhorse of modern nuclear structure theory for describing collective excitations. By building collective states as coherent superpositions of elementary quasiparticle excitations, the QRPA framework reveals how complex phenomena like the PDR emerge from the underlying single-particle structure and the residual nucleon-nucleon interaction. This exercise will provide you with a deep, hands-on understanding of the microscopic origins of nuclear collectivity. ",
            "id": "3582916",
            "problem": "You are asked to design, implement, and execute a computational proxy for the small-amplitude linear response of a finite nucleus relevant to pygmy dipole resonances, based on a simplified but self-consistent scheme tied to an energy density functional viewpoint. The physical target is the low-energy electric dipole strength in the neutron-rich nucleus $^{68}\\mathrm{Ni}$, quantified as the fraction of the energy-weighted sum rule exhausted in the window $[5,10]$ MeV. Your implementation must be a complete program that constructs a spherical quasiparticle basis with pairing, builds a separable isovector electric dipole residual interaction, solves the quasiparticle random-phase approximation (QRPA), and computes the requested fraction.\n\nStart from the following fundamental base:\n- Time-dependent Hartree-Fock-Bogoliubov (TDHFB) theory linearized around the ground state yields the Quasiparticle Random Phase Approximation (QRPA), which can be stated as a small-amplitude equation-of-motion problem for two-quasiparticle superpositions.\n- The Bardeen-Cooper-Schrieffer (BCS) approximation provides quasiparticle energies and occupation amplitudes from single-particle energies and pairing gaps, with $u^2+v^2=1$.\n- The electric dipole operator must be center-of-mass corrected via effective charges for protons and neutrons in a finite nucleus, with $e_p = N/A$ and $e_n = -Z/A$ for the isovector dipole operator, where $Z$ is the proton number, $N$ is the neutron number, and $A=Z+N$.\n- The energy-weighted sum rule (EWSR) for the electric dipole operator can be obtained from the double commutator with the Hamiltonian, establishing a global benchmark for collectivity, though you will compute the fraction directly from the QRPA strength distribution.\n\nImplement the following algorithmic specification without using any external data:\n1. Fix the nucleus to $^{68}\\mathrm{Ni}$, so $Z=28$, $N=40$, and $A=68$. Use a spherical, equidistant single-particle spectrum for each species (protons and neutrons) around a chemical potential at $0$ such that hole levels have energies $\\epsilon_h0$ and particle levels have energies $\\epsilon_p0$. For a given level spacing $d$ and integers $L_h$ and $L_p$, take\n   - hole energies $\\epsilon_h = -d\\,(k-1/2)$ for $k=1,\\dots,L_h$,\n   - particle energies $\\epsilon_p = +d\\,(k-1/2)$ for $k=1,\\dots,L_p$.\n2. For each species $s\\in\\{p,n\\}$, apply Bardeen-Cooper-Schrieffer (BCS) pairing with a constant pairing gap $\\Delta_s$. For each single-particle energy $\\epsilon$, define the quasiparticle energy $E=\\sqrt{\\epsilon^2+\\Delta_s^2}$ and the occupation amplitudes $u=\\sqrt{(1+\\epsilon/E)/2}$ and $v=\\sqrt{(1-\\epsilon/E)/2}$.\n3. Form the two-quasiparticle space by combining a hole state and a particle state of the same species into a configuration with energy $E_{2\\mathrm{qp}}=E_p+E_h$. Associate to each configuration a reduced matrix element factor from the electric dipole operator. Use $e_s$ for the effective charge, with $e_p=N/A$ and $e_n=-Z/A$. Use a smooth radial form factor that depends on the energy difference $\\Delta\\epsilon=\\epsilon_p-\\epsilon_h$, namely $R(\\Delta\\epsilon)=1/\\left(1+\\left(\\Delta\\epsilon/\\Lambda\\right)^2\\right)$, where $\\Lambda$ is a positive energy-scale parameter. For the BCS quasiparticle coherence, use the standard particle-hole combination factor $C_{ph}=u_p v_h - v_p u_h$. Define the one-body coupling amplitude for the configuration as $D_i=e_s\\,R(\\Delta\\epsilon)\\,C_{ph}$.\n4. Adopt a separable isovector dipole residual interaction that is attractive in the channel generated by the same one-body field as the probe operator. In the two-quasiparticle basis, this leads to a QRPA matrix of the form\n   - $A_{ij}=\\delta_{ij}\\,E_{2\\mathrm{qp},i}+\\kappa_R\\,D_i D_j$,\n   - $B_{ij}=\\kappa_R\\,D_i D_j$,\n   where $\\kappa_R$ is a positive real coupling strength controlling collectivity. Assemble the QRPA Hamiltonian matrix as the real $2M\\times 2M$ block matrix\n   $$H_{\\mathrm{QRPA}}=\\begin{pmatrix}A  B \\\\ -B  -A\\end{pmatrix},$$\n   where $M$ is the number of two-quasiparticle configurations and $A$ and $B$ are real symmetric $M\\times M$ matrices.\n5. Solve the QRPA eigenproblem for $H_{\\mathrm{QRPA}}$ to obtain eigenvalues $\\omega_\\nu$ and eigenvectors $(X^{(\\nu)},Y^{(\\nu)})$. Retain eigenmodes with positive energies $\\omega_\\nu0$ and negligible imaginary parts (treat any imaginary components smaller than a small tolerance as numerical noise). Normalize each mode to satisfy $X^{T}X-Y^{T}Y=1$ by rescaling the eigenvector.\n6. Compute the reduced electric dipole transition amplitude for each QRPA mode as $T_\\nu=\\sum_{i=1}^{M}D_i\\,(X_i^{(\\nu)}+Y_i^{(\\nu)})$. The discrete reduced transition probability is then $B_\\nu = \\left|T_\\nu\\right|^2$. The discrete energy-weighted sum is $m_1^{\\mathrm{(QRPA)}}=\\sum_{\\nu}\\omega_\\nu\\,B_\\nu$ and the low-energy contribution in the window $[5,10]$ MeV is $m_1^{\\mathrm{(low)}}=\\sum_{\\nu,\\,\\omega_\\nu\\in[5,10]}\\omega_\\nu\\,B_\\nu$.\n7. Define the requested fraction as the dimensionless ratio $f=m_1^{\\mathrm{(low)}}/m_1^{\\mathrm{(QRPA)}}$. This fraction is universal, independent of the overall normalization of the one-body field, provided the same field is used in both the residual interaction and the probe. Report $f$ rounded to six decimal places for each test case.\n\nAngle units are not applicable. All energies must be expressed in MeV. The final requested results are dimensionless real numbers in decimal form.\n\nTest Suite:\nImplement your program to evaluate the fraction $f$ for the following four parameter sets. For each case, use $Z=28$, $N=40$, $A=68$, and the electric dipole window $[5,10]$ MeV. Each tuple specifies $(d, L_h, L_p, \\Delta_n, \\Delta_p, \\kappa_R, \\Lambda)$, where all energies are in MeV.\n- Case $1$: $(1.5, 6, 6, 1.2, 1.0, 0.08, 5.0)$\n- Case $2$: $(1.5, 6, 6, 1.2, 1.0, 0.18, 5.0)$\n- Case $3$: $(2.0, 5, 5, 0.0, 0.0, 0.05, 5.0)$\n- Case $4$: $(2.5, 5, 5, 0.5, 0.5, 0.00, 5.0)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases listed above, with each entry rounded to six decimal places, for example, $[x_1,x_2,x_3,x_4]$ where each $x_i$ is the computed fraction $f$ for case $i$ rounded to six decimal places. No other text should be printed.",
            "solution": "The problem is assessed to be valid. It is a well-posed, self-contained, and scientifically-grounded computational problem in nuclear structure physics. It requests the implementation of a simplified Quasiparticle Random Phase Approximation (QRPA) model to calculate a specific physical observable, the low-energy fraction of the electric dipole energy-weighted sum rule, for the nucleus $^{68}\\mathrm{Ni}$. The model, while simplified, adheres to the fundamental principles of many-body quantum mechanics as applied to atomic nuclei. All parameters, definitions, and procedures are explicitly provided, leading to a unique and verifiable solution for each test case.\n\nThe solution proceeds by implementing the algorithmic steps detailed in the problem statement.\n\n1.  **Nuclear and Model Space Setup:** The calculation is for the nucleus $^{68}\\mathrm{Ni}$, which has $Z=28$ protons and $N=40$ neutrons, for a total of $A=Z+N=68$ nucleons. The single-particle space is modeled by a set of equidistant energy levels for both protons and neutrons. For a given level spacing $d$, the energies of hole states (occupied in the mean-field ground state) are $\\epsilon_h = -d(k-1/2)$ for $k=1,\\dots,L_h$, and particle states (unoccupied) are $\\epsilon_p = +d(k-1/2)$ for $k=1,\\dots,L_p$. The chemical potential is implicitly set to zero, separating hole and particle states.\n\n2.  **Quasiparticle Transformation:** Nuclear pairing correlations are incorporated via the Bardeen-Cooper-Schrieffer (BCS) formalism. For each single-particle level $\\epsilon$ of a given species $s \\in \\{p,n\\}$ with a pairing gap $\\Delta_s$, we define a quasiparticle. The quasiparticle energy is $E = \\sqrt{\\epsilon^2 + \\Delta_s^2}$. The transformation from particle states to quasiparticle states involves the Bogoliubov amplitudes $u$ and $v$, given by $u = \\sqrt{(1+\\epsilon/E)/2}$ and $v = \\sqrt{(1-\\epsilon/E)/2}$, which satisfy the normalization $u^2+v^2=1$. In the limiting case of no pairing ($\\Delta_s=0$), a particle state ($\\epsilon0$) corresponds to $u=1, v=0$, and a hole state ($\\epsilon0$) to $u=0, v=1$.\n\n3.  **Two-Quasiparticle Basis Construction:** The elementary excitations of the system are modeled as superpositions of two-quasiparticle (2qp) configurations. In this model, we consider only particle-hole type 2qp states, formed by combining a particle and a hole state of the same species. The unperturbed energy of such a 2qp configuration $i$ is the sum of the two quasiparticle energies involved, $E_{2\\mathrm{qp},i} = E_p + E_h$.\n\n4.  **Operators and Interaction:**\n    The system is probed by the isovector electric dipole operator, for which the effective charges are $e_p = N/A$ and $e_n = -Z/A$ to ensure the spurious center-of-mass motion does not contribute to the intrinsic excitation strength.\n    The coupling of this operator to a 2qp configuration $i$ is given by the amplitude $D_i$. This amplitude is a product of three factors: the effective charge $e_s$, a form factor $R(\\Delta\\epsilon) = 1/(1+(\\Delta\\epsilon/\\Lambda)^2)$ that depends on the particle-hole energy gap $\\Delta\\epsilon = \\epsilon_p - \\epsilon_h$, and the BCS coherence factor $C_{ph} = u_p v_h - v_p u_h$, which accounts for the quasiparticle nature of the states.\n    The residual interaction between quasiparticles is a vital component for describing collective motion. A separable interaction is chosen, of the form $V = \\kappa_R \\hat{D}^\\dagger \\hat{D}$, where $\\hat{D}$ is the one-body operator associated with the transition amplitudes $D_i$ and $\\kappa_R$ is the interaction strength. This self-consistent choice (using the same operator for the probe and interaction) simplifies the QRPA matrix structure significantly.\n\n5.  **QRPA Matrix Formulation and Solution:** The Time-Dependent Hartree-Fock-Bogoliubov (TDHFB) equations, when linearized, lead to the QRPA equations. For a separable interaction, these equations reduce to a matrix eigenvalue problem. The QRPA matrix is constructed in the 2qp basis of dimension $M$. It is a $2M \\times 2M$ matrix of the form:\n    $$H_{\\mathrm{QRPA}}=\\begin{pmatrix}A  B \\\\ -B  -A\\end{pmatrix}$$\n    Here, $A$ and $B$ are real, symmetric $M \\times M$ matrices defined as:\n    $$A_{ij}=\\delta_{ij}\\,E_{2\\mathrm{qp},i}+\\kappa_R\\,D_i D_j$$\n    $$B_{ij}=\\kappa_R\\,D_i D_j$$\n    The eigenvalues $\\omega_\\nu$ of $H_{\\mathrm{QRPA}}$ represent the energies of the collective excited states (phonons). The corresponding eigenvectors $(\\boldsymbol{X}^{(\\nu)}, \\boldsymbol{Y}^{(\\nu)})$ contain the amplitudes of the 2qp configurations in the phonon state. Physical solutions correspond to real, positive eigenvalues $\\omega_\\nu  0$. The eigenvectors for these physical states are normalized according to the condition $\\boldsymbol{X}^{(\\nu)T}\\boldsymbol{X}^{(\\nu)} - \\boldsymbol{Y}^{(\\nu)T}\\boldsymbol{Y}^{(\\nu)} = 1$. This eigenvalue problem is solved numerically using standard linear algebra libraries.\n\n6.  **Calculation of Observables:** For each collective state $\\nu$ with energy $\\omega_\\nu$, the reduced transition probability $B(E1)_\\nu$ is calculated. It is proportional to the square of the transition amplitude $T_\\nu$, which is given by:\n    $$T_\\nu=\\sum_{i=1}^{M}D_i\\,(X_i^{(\\nu)}+Y_i^{(\\nu)})$$\n    The strength is then $B_\\nu = |T_\\nu|^2$. The total energy-weighted sum rule (EWSR) within the model is $m_1^{\\mathrm{(QRPA)}}=\\sum_{\\nu}\\omega_\\nu\\,B_\\nu$. We are interested in the fraction of this sum rule that lies in the low-energy (\"pygmy\") region, here defined as the energy window $[5, 10]$ MeV. This contribution is $m_1^{\\mathrm{(low)}}=\\sum_{\\nu, \\, \\omega_\\nu\\in[5,10]}\\omega_\\nu\\,B_\\nu$. The final result is the dimensionless ratio $f = m_1^{\\mathrm{(low)}} / m_1^{\\mathrm{(QRPA)}}$. This procedure is repeated for each parameter set provided in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_fraction(d, Lh, Lp, delta_n, delta_p, kappa_R, Lambda):\n    \"\"\"\n    Calculates the pygmy dipole resonance fraction of the energy-weighted sum rule\n    based on a simplified, self-consistent QRPA model.\n\n    The function implements the step-by-step procedure outlined in the problem:\n    1. Sets up the nuclear properties and single-particle basis.\n    2. Applies BCS theory to obtain a quasiparticle basis.\n    3. Constructs the two-quasiparticle (2qp) basis and operator matrix elements.\n    4. Builds the separable QRPA matrices A and B.\n    5. Solves the QRPA eigenvalue problem.\n    6. Computes transition strengths and the energy-weighted sum rule.\n    7. Calculates the fraction of the sum rule in the specified energy window.\n    \"\"\"\n    # 1. Constants and nucleus properties\n    Z, N = 28, 40\n    A = Z + N\n    e_p, e_n = N / A, -Z / A\n    E_min, E_max = 5.0, 10.0\n\n    # 2. Single-particle spectrum generation\n    eps_h = [-d * (k - 0.5) for k in range(1, Lh + 1)]\n    eps_p = [+d * (k - 0.5) for k in range(1, Lp + 1)]\n\n    # Helper function for BCS quantities (quasiparticle energy and amplitudes)\n    def get_bcs(eps, delta):\n        if np.abs(delta)  1e-12:  # Handle the no-pairing case\n            E = np.abs(eps)\n            if eps > 0:\n                u, v = 1.0, 0.0\n            else:  # eps  0\n                u, v = 0.0, 1.0\n        else:\n            E = np.sqrt(eps**2 + delta**2)\n            # Add a small value to E in denominator to prevent division by zero if eps=0.\n            # Not strictly necessary here since eps is never zero.\n            u = np.sqrt(0.5 * (1 + eps / (E + 1e-15)))\n            v = np.sqrt(0.5 * (1 - eps / (E + 1e-15)))\n        return E, u, v\n\n    # 3. Two-quasiparticle basis construction\n    configs = []\n    \n    # Proton 2qp configurations\n    for ep_val in eps_p:\n        for eh_val in eps_h:\n            Ep, up, vp = get_bcs(ep_val, delta_p)\n            Eh, uh, vh = get_bcs(eh_val, delta_p)\n            \n            E2qp = Ep + Eh\n            delta_eps = ep_val - eh_val\n            R = 1.0 / (1.0 + (delta_eps / Lambda)**2)\n            Cph = up * vh - vp * uh\n            D_i = e_p * R * Cph\n            configs.append({'E2qp': E2qp, 'D': D_i})\n\n    # Neutron 2qp configurations\n    for ep_val in eps_p:\n        for eh_val in eps_h:\n            Ep, up, vp = get_bcs(ep_val, delta_n)\n            Eh, uh, vh = get_bcs(eh_val, delta_n)\n            \n            E2qp = Ep + Eh\n            delta_eps = ep_val - eh_val\n            R = 1.0 / (1.0 + (delta_eps / Lambda)**2)\n            Cph = up * vh - vp * uh\n            D_i = e_n * R * Cph\n            configs.append({'E2qp': E2qp, 'D': D_i})\n    \n    M = len(configs)\n    if M == 0:\n        return 0.0\n\n    # 4. QRPA matrices A and B\n    E2qp_vec = np.array([c['E2qp'] for c in configs])\n    D_vec = np.array([c['D'] for c in configs])\n    \n    A = np.diag(E2qp_vec) + kappa_R * np.outer(D_vec, D_vec)\n    B = kappa_R * np.outer(D_vec, D_vec)\n\n    # 5. QRPA Hamiltonian solution\n    H_qrpa = np.block([[A, B], [-B, -A]])\n    eigvals, eigvecs = np.linalg.eig(H_qrpa)\n\n    # 6. Compute strength distribution\n    strength_dist = []\n    tolerance = 1e-9\n    for i in range(2 * M):\n        omega = eigvals[i]\n        \n        # Filter for physical solutions (positive real energy)\n        if np.real(omega) > tolerance and np.abs(np.imag(omega))  tolerance:\n            omega_real = np.real(omega)\n            \n            # Eigenvectors for real eigenvalues of real matrices can be chosen as real\n            vec = np.real(eigvecs[:, i])\n            X = vec[:M]\n            Y = vec[M:]\n            \n            # Normalization condition for QRPA modes\n            norm_sq = X.T @ X - Y.T @ Y\n            \n            if norm_sq > tolerance:\n                norm_factor = 1.0 / np.sqrt(norm_sq)\n                X_norm = X * norm_factor\n                Y_norm = Y * norm_factor\n                \n                # Transition amplitude and strength\n                T_nu = D_vec.T @ (X_norm + Y_norm)\n                B_nu = T_nu**2\n                strength_dist.append((omega_real, B_nu))\n\n    # 7. Calculate the fraction of the EWSR in the specified window\n    m1_total = sum(w * b for w, b in strength_dist)\n    m1_low = sum(w * b for w, b in strength_dist if E_min = w = E_max)\n\n    if m1_total  1e-12:  # Avoid division by zero for cases with no strength\n        return 0.0\n        \n    fraction = m1_low / m1_total\n    return fraction\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, Lh, Lp, delta_n, delta_p, kappa_R, Lambda)\n        (1.5, 6, 6, 1.2, 1.0, 0.08, 5.0),\n        (1.5, 6, 6, 1.2, 1.0, 0.18, 5.0),\n        (2.0, 5, 5, 0.0, 0.0, 0.05, 5.0),\n        (2.5, 5, 5, 0.5, 0.5, 0.00, 5.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        d, Lh, Lp, delta_n, delta_p, kappa_R, Lambda = case\n        fraction = calculate_fraction(d, Lh, Lp, delta_n, delta_p, kappa_R, Lambda)\n        results.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}