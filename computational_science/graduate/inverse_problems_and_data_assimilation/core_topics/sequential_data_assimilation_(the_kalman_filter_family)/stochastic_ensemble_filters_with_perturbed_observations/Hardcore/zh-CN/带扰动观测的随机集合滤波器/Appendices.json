{
    "hands_on_practices": [
        {
            "introduction": "本练习侧重于预测步骤，这是任何序贯数据同化系统的核心。在随机集合滤波器中，我们通过根据模型动力学推进每个集合成员并添加代表模型误差的扰动来传播不确定性。本练习  将指导您实现这一基本过程，并数值验证所得集合协方差与理论预测相符，为您的代码实现提供关键的健全性检查。",
            "id": "3422911",
            "problem": "考虑一个离散时间的状态维度为 $d$ 的线性高斯状态演化模型，由 $x_{k} = \\Phi x_{k-1} + w_{k}$ 给出，其中 $\\Phi \\in \\mathbb{R}^{d \\times d}$ 是一个已知的预报算子，而 $w_{k} \\sim \\mathcal{N}(0, Q)$ 是协方差为 $Q \\in \\mathbb{R}^{d \\times d}$（对称正定）的高斯过程噪声。在随机集合滤波（例如，集合卡尔曼滤波器 (EnKF)）中，第 $k$ 步的预报集合是通过将每个分析集合成员通过 $\\Phi$ 进行映射，并加上一个从 $\\mathcal{N}(0, Q)$ 中抽取的独立扰动 $w_{k}^{(i)}$ 来获得的。一个对 $w_{k}^{(i)}$ 进行采样的数值稳定方法是计算 Cholesky 分解 $Q = L L^{\\top}$，其中 $L$ 是下三角矩阵，然后设置 $w_{k}^{(i)} = L \\xi^{(i)}$，其中 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{d})$ 在集合成员间是独立的。\n\n从以下基本事实出发：\n- 如果 $x_{a}^{(i)} \\sim \\mathcal{N}(m^{a}, P^{a})$ 是独立的分析集合成员，并且 $w^{(i)} \\sim \\mathcal{N}(0, Q)$ 独立于 $x_{a}^{(i)}$，那么 $x_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}$ 是从 $\\mathcal{N}(\\Phi m^{a}, \\Phi P^{a} \\Phi^{\\top} + Q)$ 中进行的独立抽样。\n- 对于真实协方差为 $\\Sigma \\in \\mathbb{R}^{d \\times d}$ 的独立同分布高斯样本，由 $N$ 个样本计算出的无偏样本协方差 $S$ 满足 $(N-1) S \\sim \\mathcal{W}_{d}(\\Sigma, N-1)$（Wishart 分布），且 $\\mathbb{E}[S] = \\Sigma$。对于如上的 $S$，$S$ 的逐分量方差遵循 $\\operatorname{Var}(S_{ij}) = \\frac{1}{N-1}\\left(\\Sigma_{ij}^{2} + \\Sigma_{ii}\\Sigma_{jj}\\right)$，这意味着\n$$\n\\mathbb{E}\\left[\\lVert S - \\Sigma \\rVert_{F}^{2}\\right] = \\frac{1}{N-1}\\left(\\lVert \\Sigma \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma)^{2}\\right).\n$$\n\n您的任务是使用基于 Cholesky 的采样来实现随机预报步骤，并验证从预报集合计算出的经验预报协方差 $\\hat{P}^{f}$ 与理论预报协方差 $\\Sigma_{f} = \\Phi P^{a} \\Phi^{\\top} + Q$ 在采样误差范围内是一致的，该误差由上述公式量化。具体来说，对于每个测试用例：\n1. 生成一个分析集合 $\\{x_{a}^{(i)}\\}_{i=1}^{N}$，其中 $x_{a}^{(i)} \\sim \\mathcal{N}(m^{a}, P^{a})$，并且 $m^{a} = 0$ 是适当维度的零向量。\n2. 通过 $w^{(i)} = L \\xi^{(i)}$ 采样独立的过程噪声 $w^{(i)}$，其中 $Q = L L^{\\top}$ 是 Cholesky 分解，且 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{d})$。\n3. 构建预报集合成员 $x_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}$。\n4. 计算预报集合的无偏样本协方差，\n$$\n\\hat{P}^{f} = \\frac{1}{N-1}\\sum_{i=1}^{N}\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)^{\\top}, \\quad \\bar{x}_{f} = \\frac{1}{N}\\sum_{i=1}^{N} x_{f}^{(i)}.\n$$\n5. 计算理论预报协方差 $\\Sigma_{f} = \\Phi P^{a} \\Phi^{\\top} + Q$。\n6. 计算 Frobenius 范数差异 $\\Delta = \\lVert \\hat{P}^{f} - \\Sigma_{f} \\rVert_{F}$ 和由 Wishart 理论预测的均方根 (RMS) 采样误差，\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{\\lVert \\Sigma_{f} \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma_{f})^{2}}{N-1}}.\n$$\n如果 $\\Delta \\leq c \\, \\varepsilon_{\\mathrm{RMS}}$ 且 $c = 3$，则声明该测试用例通过。\n\n所有量均为无量纲；不需要物理单位。\n\n实现您的程序以评估以下测试套件。对于每个用例，$d$ 是状态维度，$N$ 是集合大小，矩阵被明确给出。在每个用例中，取 $m^{a} = 0$：\n- 用例 1（正常路径，中等维度和集合大小）：\n  - $d = 3$, $N = 400$,\n  - $\\Phi = \\begin{bmatrix} 0.9  0.1  0.0 \\\\ 0.0  0.7  0.2 \\\\ 0.0  0.0  0.8 \\end{bmatrix}$,\n  - $P^{a} = \\begin{bmatrix} 0.5  0.1  0.0 \\\\ 0.1  0.4  0.05 \\\\ 0.0  0.05  0.3 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 0.2  0.05  0.0 \\\\ 0.05  0.1  0.02 \\\\ 0.0  0.02  0.15 \\end{bmatrix}$。\n- 用例 2（边界情况，标量系统）：\n  - $d = 1$, $N = 200$,\n  - $\\Phi = [1.2]$,\n  - $P^{a} = [0.25]$,\n  - $Q = [0.5]$。\n- 用例 3（更高维度，大集合大小）：\n  - $d = 5$, $N = 2000$,\n  - $\\Phi = \\begin{bmatrix} 0.6  0.2  0.0  0.0  0.0 \\\\ 0.0  0.7  0.1  0.0  0.0 \\\\ 0.0  0.0  0.5  0.2  0.0 \\\\ 0.0  0.0  0.0  0.65  0.1 \\\\ 0.0  0.0  0.0  0.0  0.55 \\end{bmatrix}$,\n  - $P^{a} = \\begin{bmatrix} 1.0  0.1  0.0  0.0  0.0 \\\\ 0.1  0.8  0.0  0.0  0.0 \\\\ 0.0  0.0  0.6  0.05  0.0 \\\\ 0.0  0.0  0.05  0.7  0.0 \\\\ 0.0  0.0  0.0  0.0  0.9 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 0.3  0.04  0.0  0.0  0.0 \\\\ 0.04  0.25  0.03  0.0  0.0 \\\\ 0.0  0.03  0.2  0.02  0.0 \\\\ 0.0  0.0  0.02  0.15  0.01 \\\\ 0.0  0.0  0.0  0.01  0.35 \\end{bmatrix}$。\n- 用例 4（边缘情况，小集合大小）：\n  - $d = 4$, $N = 30$,\n  - $\\Phi = \\begin{bmatrix} 0.85  0.1  0.0  0.0 \\\\ 0.0  0.75  0.15  0.0 \\\\ 0.0  0.0  0.65  0.1 \\\\ 0.0  0.0  0.0  0.7 \\end{bmatrix}$,\n  - $P^{a} = \\begin{bmatrix} 0.6  0.05  0.0  0.0 \\\\ 0.05  0.5  0.04  0.0 \\\\ 0.0  0.04  0.4  0.03 \\\\ 0.0  0.0  0.03  0.45 \\end{bmatrix}$,\n  - $Q = \\begin{bmatrix} 0.25  0.03  0.0  0.0 \\\\ 0.03  0.2  0.02  0.0 \\\\ 0.0  0.02  0.18  0.01 \\\\ 0.0  0.0  0.01  0.22 \\end{bmatrix}$。\n\n为保证可复现性，随机数生成必须是确定性的；为每个用例使用固定的种子。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目都是一个布尔值，指示测试用例是否通过（例如，“[True,False,True,True]”）。",
            "solution": "该问题要求在一个基于集合的数据同化框架中实现并验证随机预报步骤。这涉及根据一个线性随机动力学模型，推进一个代表系统状态概率分布的状态向量集合。任务的核心是确认所得预报集合的样本协方差与模型预测的理论预报误差协方差在统计上是一致的。\n\n系统的状态演化由离散时间线性高斯模型描述：\n$$\nx_{k} = \\Phi x_{k-1} + w_{k}\n$$\n此处，$x_{k} \\in \\mathbb{R}^{d}$ 是时间步 $k$ 的状态向量，$\\Phi \\in \\mathbb{R}^{d \\times d}$ 是确定性预报算子（或转移矩阵），而 $w_{k} \\in \\mathbb{R}^{d}$ 是一个随机过程噪声向量。假设噪声是从一个零均值多元高斯分布 $w_{k} \\sim \\mathcal{N}(0, Q)$ 中抽取的，其协方差矩阵 $Q \\in \\mathbb{R}^{d \\times d}$ 已知且为对称正定。\n\n在一个集合滤波器中，状态的概率分布由一个有限的样本集合（即集合）表示。设第 $k-1$ 步的分析集合为 $\\{x_{a}^{(i)}\\}_{i=1}^{N}$，其中 $N$ 是集合大小。假设每个成员 $x_{a}^{(i)}$ 都是从分析分布中独立抽取的样本，该分布是高斯的：$x_{a}^{(i)} \\sim \\mathcal{N}(m^{a}, P^{a})$。对于本问题，分析均值被指定为零向量，$m^{a} = 0$。\n\n预报步骤将每个分析集合成员传播到下一个时间步 $k$。每个成员都通过算子 $\\Phi$ 进行变换，并被一个独立的过程噪声实现所扰动：\n$$\nx_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}\n$$\n其中每个 $w^{(i)} \\sim \\mathcal{N}(0, Q)$ 都是独立抽取的。得到的集合 $\\{x_{f}^{(i)}\\}_{i=1}^{N}$ 就是预报集合。\n\n预报状态的理论分布可以从高斯随机向量的仿射变换性质中推导出来。预报分布的均值是：\n$$\n\\mathbb{E}[x_{f}] = \\mathbb{E}[\\Phi x_{a} + w] = \\Phi \\mathbb{E}[x_{a}] + \\mathbb{E}[w] = \\Phi m^{a} + 0 = \\Phi m^{a}\n$$\n由于 $m^{a} = 0$，预报均值也为 $0$。预报分布的协方差（我们记为 $\\Sigma_{f}$）是：\n$$\n\\Sigma_{f} = \\operatorname{Cov}(\\Phi x_{a} + w)\n$$\n因为分析状态 $x_{a}$ 和过程噪声 $w$ 是独立的，所以它们和的协方差等于它们协方差的和：\n$$\n\\Sigma_{f} = \\operatorname{Cov}(\\Phi x_{a}) + \\operatorname{Cov}(w) = \\Phi \\operatorname{Cov}(x_{a}) \\Phi^{\\top} + Q = \\Phi P^{a} \\Phi^{\\top} + Q\n$$\n这个矩阵 $\\Sigma_{f}$ 是精确的或理论的预报误差协方差。因此，预报集合成员 $x_{f}^{(i)}$ 是从分布 $\\mathcal{N}(0, \\Sigma_{f})$ 中抽取的独立样本。\n\n将要实现的算法遵循一系列定义明确的步骤，以通过数值模拟来验证这一理论结果。\n\n1.  **生成分析集合 $\\{x_{a}^{(i)}\\}_{i=1}^{N}$**：要从 $\\mathcal{N}(0, P^{a})$ 中抽取样本，我们首先找到一个矩阵 $L_{a}$ 使得 $P^{a} = L_{a} L_{a}^{\\top}$。如果 $P^{a}$ 是对称正定的，Cholesky 分解可以提供这样一个下三角矩阵 $L_{a}$。然后我们从标准多元正态分布 $\\zeta^{(i)} \\sim \\mathcal{N}(0, I_{d})$ 中生成 $N$ 个独立样本 $\\zeta^{(i)}$，其中 $I_{d}$ 是 $d \\times d$ 的单位矩阵。每个分析集合成员则通过变换 $x_{a}^{(i)} = L_{a} \\zeta^{(i)}$ 形成。\n\n2.  **采样过程噪声 $\\{w^{(i)}\\}_{i=1}^{N}$**：此步骤与第一步类似。我们计算过程噪声协方差矩阵的 Cholesky 分解 $Q = L_{q} L_{q}^{\\top}$。然后我们生成另一组 $N$ 个独立的标准正态向量 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{d})$，并计算噪声样本为 $w^{(i)} = L_{q} \\xi^{(i)}$。\n\n3.  **构建预报集合 $\\{x_{f}^{(i)}\\}_{i=1}^{N}$**：通过将模型动力学应用于相应的分析成员来计算每个预报成员：$x_{f}^{(i)} = \\Phi x_{a}^{(i)} + w^{(i)}$。\n\n4.  **计算经验预报协方差 $\\hat{P}^{f}$**：根据生成的预报集合，我们估计其协方差。无偏样本协方差矩阵由下式给出：\n    $$\n    \\hat{P}^{f} = \\frac{1}{N-1}\\sum_{i=1}^{N}\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)\\left(x_{f}^{(i)} - \\bar{x}_{f}\\right)^{\\top}\n    $$\n    其中 $\\bar{x}_{f} = \\frac{1}{N}\\sum_{i=1}^{N} x_{f}^{(i)}$ 是预报集合的样本均值。\n\n5.  **计算理论预报协方差 $\\Sigma_{f}$**：这使用推导出的公式 $\\Sigma_{f} = \\Phi P^{a} \\Phi^{\\top} + Q$ 直接从给定的矩阵计算得出。\n\n6.  **比较经验与理论结果**：样本协方差 $\\hat{P}^{f}$ 和真实协方差 $\\Sigma_{f}$ 之间的差异是采样误差的结果。该误差通过两种方式量化。首先，直接差异通过差值的 Frobenius 范数来衡量：$\\Delta = \\lVert \\hat{P}^{f} - \\Sigma_{f} \\rVert_{F}$。其次，基于样本协方差所服从的 Wishart 分布的性质，计算均方根 (RMS) 采样误差的理论估计。期望平方误差由 $\\mathbb{E}\\left[\\lVert \\hat{P}^{f} - \\Sigma_{f} \\rVert_{F}^{2}\\right] = \\frac{1}{N-1}\\left(\\lVert \\Sigma_{f} \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma_{f})^{2}\\right)$ 给出。RMS 误差是此数量的平方根：\n    $$\n    \\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{\\lVert \\Sigma_{f} \\rVert_{F}^{2} + (\\operatorname{tr}\\Sigma_{f})^{2}}{N-1}}\n    $$\n    如果观测到的差异 $\\Delta$ 在这个期望统计误差的合理倍数之内，则认为测试用例通过。问题将此标准指定为 $\\Delta \\leq c \\, \\varepsilon_{\\mathrm{RMS}}$，容忍因子 $c = 3$，这类似于一个“3-sigma”置信区间。此检查确认了模拟的行为与统计理论的预测相符。为保证可复现性，伪随机数生成器在每个测试用例中都使用固定的种子值进行初始化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the stochastic forecast step verification.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"d\": 3, \"N\": 400, \"seed\": 0,\n            \"Phi\": np.array([\n                [0.9, 0.1, 0.0],\n                [0.0, 0.7, 0.2],\n                [0.0, 0.0, 0.8]\n            ]),\n            \"Pa\": np.array([\n                [0.5, 0.1, 0.0],\n                [0.1, 0.4, 0.05],\n                [0.0, 0.05, 0.3]\n            ]),\n            \"Q\": np.array([\n                [0.2, 0.05, 0.0],\n                [0.05, 0.1, 0.02],\n                [0.0, 0.02, 0.15]\n            ])\n        },\n        {\n            \"d\": 1, \"N\": 200, \"seed\": 1,\n            \"Phi\": np.array([[1.2]]),\n            \"Pa\": np.array([[0.25]]),\n            \"Q\": np.array([[0.5]])\n        },\n        {\n            \"d\": 5, \"N\": 2000, \"seed\": 2,\n            \"Phi\": np.array([\n                [0.6, 0.2, 0.0, 0.0, 0.0],\n                [0.0, 0.7, 0.1, 0.0, 0.0],\n                [0.0, 0.0, 0.5, 0.2, 0.0],\n                [0.0, 0.0, 0.0, 0.65, 0.1],\n                [0.0, 0.0, 0.0, 0.0, 0.55]\n            ]),\n            \"Pa\": np.array([\n                [1.0, 0.1, 0.0, 0.0, 0.0],\n                [0.1, 0.8, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.6, 0.05, 0.0],\n                [0.0, 0.0, 0.05, 0.7, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.9]\n            ]),\n            \"Q\": np.array([\n                [0.3, 0.04, 0.0, 0.0, 0.0],\n                [0.04, 0.25, 0.03, 0.0, 0.0],\n                [0.0, 0.03, 0.2, 0.02, 0.0],\n                [0.0, 0.0, 0.02, 0.15, 0.01],\n                [0.0, 0.0, 0.0, 0.01, 0.35]\n            ])\n        },\n        {\n            \"d\": 4, \"N\": 30, \"seed\": 3,\n            \"Phi\": np.array([\n                [0.85, 0.1, 0.0, 0.0],\n                [0.0, 0.75, 0.15, 0.0],\n                [0.0, 0.0, 0.65, 0.1],\n                [0.0, 0.0, 0.0, 0.7]\n            ]),\n            \"Pa\": np.array([\n                [0.6, 0.05, 0.0, 0.0],\n                [0.05, 0.5, 0.04, 0.0],\n                [0.0, 0.04, 0.4, 0.03],\n                [0.0, 0.0, 0.03, 0.45]\n            ]),\n            \"Q\": np.array([\n                [0.25, 0.03, 0.0, 0.0],\n                [0.03, 0.2, 0.02, 0.0],\n                [0.0, 0.02, 0.18, 0.01],\n                [0.0, 0.0, 0.01, 0.22]\n            ])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        d, N, seed = case[\"d\"], case[\"N\"], case[\"seed\"]\n        Phi, Pa, Q = case[\"Phi\"], case[\"Pa\"], case[\"Q\"]\n        ma = np.zeros(d)\n        \n        # Initialize the random number generator with a fixed seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Generate an analysis ensemble {x_a^(i)} from N(0, Pa)\n        La = np.linalg.cholesky(Pa)\n        zeta = rng.standard_normal(size=(d, N))\n        xa_ensemble = La @ zeta # Each column is a sample x_a^(i)\n\n        # 2. Sample independent process noises {w^(i)} from N(0, Q)\n        Lq = np.linalg.cholesky(Q)\n        xi = rng.standard_normal(size=(d, N))\n        w_ensemble = Lq @ xi # Each column is a sample w^(i)\n\n        # 3. Form forecast ensemble members\n        xf_ensemble = Phi @ xa_ensemble + w_ensemble\n\n        # 4. Compute the unbiased sample covariance of the forecast ensemble\n        # np.cov computes the unbiased covariance by default (ddof=1)\n        P_f_hat = np.cov(xf_ensemble)\n\n        # 5. Compute the theoretical forecast covariance\n        Sigma_f = Phi @ Pa @ Phi.T + Q\n\n        # 6. Compute discrepancy and RMS sampling error\n        # Frobenius-norm discrepancy\n        Delta = np.linalg.norm(P_f_hat - Sigma_f, 'fro')\n\n        # RMS sampling error predicted by Wishart theory\n        norm_Sigma_f_sq = np.linalg.norm(Sigma_f, 'fro')**2\n        tr_Sigma_f_sq = np.trace(Sigma_f)**2\n        eps_rms = np.sqrt((norm_Sigma_f_sq + tr_Sigma_f_sq) / (N - 1))\n\n        # Declare pass if Delta is within 3 * eps_rms\n        c = 3\n        passes = (Delta = c * eps_rms)\n        results.append(passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在之前练习的基础上，我们现在探讨处理观测扰动时的另一个微妙之处：误差相关性。在实践中，观测误差通常是相关的，这一特性由误差协方差矩阵 $R$ 的非对角元素捕捉。本练习  采用直接的解析方法，来论证为何这些扰动的方差必须精确匹配指定的观测误差方差，并揭示不正确的缩放如何导致对分析不确定性的有偏估计。",
            "id": "3422877",
            "problem": "考虑一个在一维空间中具有线性观测算子的线性高斯数据同化情景。先验（预报）状态是一个标量随机变量，其分布为 $\\mathcal{N}(m^{f},P^{f})$，观测由 $y = H x + v$ 给出，其中 $H$ 是一个已知的标量，观测误差 $v$ 服从分布 $\\mathcal{N}(0,R)$，且与先验状态无关。我们使用带有扰动观测的集合卡尔曼滤波（EnKF）。每个分析集合成员应用仿射更新\n$$\nx^{a} = x^{f} + K\\bigl(y + \\epsilon - H x^{f}\\bigr),\n$$\n其中 $K$ 是根据预报协方差和指定的观测误差协方差计算出的卡尔曼增益，预报 $x^{f}$ 是从 $\\mathcal{N}(m^{f},P^{f})$ 中抽取的一个样本，扰动 $\\epsilon$ 是从 $\\mathcal{N}(0,\\alpha^{2} R)$ 中独立抽取的，其中 $\\alpha \\neq 1$ 是一个固定的标量。\n\n仅从更新映射的线性性以及高斯随机变量的独立性和二阶矩性质出发，通过计算将 $\\bigl(x^{f},\\epsilon\\bigr)$ 映射到 $x^{a}$ 的仿射变换的协方差，推导期望分析协方差作为 $K$、$H$、$P^{f}$、$R$ 和 $\\alpha$ 的函数。然后，使用具体数值 $H=1$、$P^{f}=2$、$R=1$ 和 $\\alpha = \\tfrac{6}{5}$，计算标量偏差\n$$\n\\Delta \\equiv \\operatorname{Var}(x^{a}\\,|\\,\\alpha) - \\operatorname{Var}(x^{a}\\,|\\,\\alpha=1),\n$$\n其中 $\\operatorname{Var}(x^{a}\\,|\\,\\alpha)$ 表示由扰动观测被 $\\alpha$ 缩放的随机EnKF所产生的期望分析方差。卡尔曼增益 $K$ 需要从 $P^{f}$、$H$ 和 $R$ 计算得出。\n\n请将您的最终答案表示为一个实数，并将结果四舍五入到六位有效数字。",
            "solution": "首先验证问题，以确保其在科学上是合理的、适定的，并且提供了所有必要的信息。\n\n### 步骤 1：提取已知条件\n- 先验状态分布：$x \\sim \\mathcal{N}(m^{f}, P^{f})$\n- 观测模型：$y = H x + v$\n- 观测误差分布：$v \\sim \\mathcal{N}(0, R)$\n- 先验状态和观测误差是独立的。\n- 集合卡尔曼滤波 (EnKF) 对每个成员的分析更新：$x^{a} = x^{f} + K\\bigl(y + \\epsilon - H x^{f}\\bigr)$\n- 预报集合成员：$x^{f}$ 是从 $\\mathcal{N}(m^{f}, P^{f})$ 中抽取的一个样本\n- 观测扰动：$\\epsilon \\sim \\mathcal{N}(0, \\alpha^{2} R)$，其中 $\\alpha \\neq 1$\n- 扰动 $\\epsilon$ 与预报成员 $x^f$ 独立。\n- 卡尔曼增益 $K$ 由 $P^{f}$、$H$ 和 $R$ 计算得出。\n- 数值：$H=1$、$P^{f}=2$、$R=1$、$\\alpha = \\frac{6}{5}$。\n- 目标是计算偏差 $\\Delta \\equiv \\operatorname{Var}(x^{a}\\,|\\,\\alpha) - \\operatorname{Var}(x^{a}\\,|\\,\\alpha=1)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题设定在线性高斯数据同化和集合卡尔曼滤波的标准框架内，这是一种在统计估计中成熟的方法。问题陈述是自洽的，为得到唯一解提供了所有必要的定义、关系和数值。该模型是教学和研究中使用的一种简化但科学上有效的表示。所用术语精确且客观。不存在矛盾、缺失数据或违反数学或科学原理的情况。该问题被认为是有效的。\n\n### 步骤 3：结论与行动\n问题有效。将继续进行求解。\n\n### 求解推导\n第一步是推导期望分析协方差的通用表达式，在这个一维案例中，即为分析方差 $\\operatorname{Var}(x^{a})$。分析状态 $x^{a}$ 作为随机变量 $x^{f}$ 和 $\\epsilon$ 的仿射变换给出。我们可以重写更新方程来组合这些随机变量：\n$$\nx^{a} = x^{f} - K H x^{f} + K y + K \\epsilon = (1 - KH)x^{f} + K\\epsilon + Ky\n$$\n在这个针对给定分析步骤的表达式中，卡尔曼增益 $K$、观测算子 $H$ 和观测值 $y$ 都是常数。$x^{a}$ 的随机性来源于预报集合成员 $x^{f}$ 和随机扰动 $\\epsilon$。\n\n$x^{a}$ 的方差是使用方差的性质计算的。对于独立随机变量 $Z_1$ 和 $Z_2$ 以及常数 $A$、$B$ 和 $C$，它们的线性组合的方差为 $\\operatorname{Var}(A Z_1 + B Z_2 + C) = A^2 \\operatorname{Var}(Z_1) + B^2 \\operatorname{Var}(Z_2)$。\n将此应用于 $x^{a}$ 的表达式：\n$$\n\\operatorname{Var}(x^a) = \\operatorname{Var}\\bigl( (1 - KH)x^{f} + K\\epsilon + Ky \\bigr)\n$$\n由于 $x^f$ 和 $\\epsilon$ 是独立的，并且 $Ky$ 是一个不影响方差的常数项：\n$$\n\\operatorname{Var}(x^a) = \\operatorname{Var}\\bigl( (1 - KH)x^{f} \\bigr) + \\operatorname{Var}(K\\epsilon)\n$$\n$$\n\\operatorname{Var}(x^a) = (1 - KH)^2 \\operatorname{Var}(x^f) + K^2 \\operatorname{Var}(\\epsilon)\n$$\n已知 $\\operatorname{Var}(x^f) = P^f$ 且 $\\operatorname{Var}(\\epsilon) = \\alpha^2 R$。将这些代入方程，得到作为模型参数函数的期望分析方差：\n$$\n\\operatorname{Var}(x^{a}\\,|\\,\\alpha) = (1 - KH)^2 P^f + K^2 \\alpha^2 R\n$$\n这就完成了问题的第一部分。现在，我们进行数值计算。\n\n首先，我们计算卡尔曼增益 $K$。对于一个标量系统，公式为：\n$$\nK = P^f H (H^2 P^f + R)^{-1} = \\frac{P^f H}{H^2 P^f + R}\n$$\n代入给定的数值 $H=1$、$P^f=2$ 和 $R=1$：\n$$\nK = \\frac{(2)(1)}{(1)^2(2) + 1} = \\frac{2}{2+1} = \\frac{2}{3}\n$$\n现在我们可以使用 $K$、$H$、$P^f$ 和 $R$ 的数值来写出 $\\operatorname{Var}(x^{a}\\,|\\,\\alpha)$ 的表达式：\n$$\n\\operatorname{Var}(x^{a}\\,|\\,\\alpha) = \\left(1 - \\frac{2}{3} \\cdot 1\\right)^2 (2) + \\left(\\frac{2}{3}\\right)^2 \\alpha^2 (1)\n$$\n$$\n\\operatorname{Var}(x^{a}\\,|\\,\\alpha) = \\left(\\frac{1}{3}\\right)^2 (2) + \\frac{4}{9} \\alpha^2 = \\frac{1}{9}(2) + \\frac{4}{9}\\alpha^2 = \\frac{2}{9} + \\frac{4}{9}\\alpha^2\n$$\n问题要求在 $\\alpha = \\frac{6}{5}$ 的特定情况下计算偏差 $\\Delta = \\operatorname{Var}(x^{a}\\,|\\,\\alpha) - \\operatorname{Var}(x^{a}\\,|\\,\\alpha=1)$。\n\n首先，我们计算 $\\operatorname{Var}(x^{a}\\,|\\,\\alpha=\\frac{6}{5})$：\n$$\n\\operatorname{Var}\\left(x^{a}\\,\\Big|\\,\\alpha=\\frac{6}{5}\\right) = \\frac{2}{9} + \\frac{4}{9}\\left(\\frac{6}{5}\\right)^2 = \\frac{2}{9} + \\frac{4}{9}\\left(\\frac{36}{25}\\right) = \\frac{2}{9} + \\frac{144}{225}\n$$\n为了将这些分数相加，我们找到一个公分母，即 $225$：\n$$\n\\operatorname{Var}\\left(x^{a}\\,\\Big|\\,\\alpha=\\frac{6}{5}\\right) = \\frac{2 \\cdot 25}{9 \\cdot 25} + \\frac{144}{225} = \\frac{50}{225} + \\frac{144}{225} = \\frac{194}{225}\n$$\n接下来，我们计算 $\\operatorname{Var}(x^a\\,|\\,\\alpha=1)$。这对应于标准的随机EnKF，其中扰动与观测误差具有相同的方差。\n$$\n\\operatorname{Var}(x^{a}\\,|\\,\\alpha=1) = \\frac{2}{9} + \\frac{4}{9}(1)^2 = \\frac{2}{9} + \\frac{4}{9} = \\frac{6}{9} = \\frac{2}{3}\n$$\n最后，我们计算偏差 $\\Delta$：\n$$\n\\Delta = \\operatorname{Var}\\left(x^{a}\\,\\Big|\\,\\alpha=\\frac{6}{5}\\right) - \\operatorname{Var}(x^{a}\\,|\\,\\alpha=1) = \\frac{194}{225} - \\frac{2}{3}\n$$\n再次使用公分母 $225$：\n$$\n\\Delta = \\frac{194}{225} - \\frac{2 \\cdot 75}{3 \\cdot 75} = \\frac{194}{225} - \\frac{150}{225} = \\frac{194 - 150}{225} = \\frac{44}{225}\n$$\n为了以一个四舍五入到六位有效数字的实数形式提供最终答案，我们进行除法运算：\n$$\n\\Delta = \\frac{44}{225} \\approx 0.1955555...\n$$\n四舍五入到六位有效数字得到 $0.195556$。",
            "answer": "$$\\boxed{0.195556}$$"
        },
        {
            "introduction": "在之前练习的基础上，我们现在探讨处理观测扰动时的另一个微妙之处：误差相关性。在实践中，观测误差通常是相关的，这一特性由误差协方差矩阵 $R$ 的非对角元素捕捉。本练习  展示了忽略这些相关性这一常见错误的后果，说明了它如何导致对新息协方差的有偏估计，并最终导致次优的分析结果。",
            "id": "3422876",
            "problem": "考虑一个用于带扰动观测的随机集合卡尔曼滤波器 (EnKF) 的二维线性高斯数据同化设置。设观测算子为单位矩阵，$H = I_{2}$，并假设预报集合的离散度为零，即对于所有集合成员 $i$ 都有 $x_{f}^{(i)} = \\bar{x}_{f}$，因此预报集合异常恒为零。设观测误差服从零均值高斯分布，其非对角协方差为\n$$\nR = \\begin{pmatrix} 2  1.2 \\\\ 1.2  1 \\end{pmatrix}\n$$\n在带扰动观测的随机 EnKF 中，每个集合成员的新息是通过使用一个合成观测扰动 $\\eta^{(i)}$ 形成的。无偏情况要求通过一个矩阵 $L$（例如，Cholesky 因子）将标准正态噪声 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{2})$ 进行线性变换来抽取 $\\eta^{(i)}$，使得 $L L^{\\top} = R$。一个常见的错误做法是忽略 $R$ 的非对角线元素，并使用 $D = \\mathrm{diag}(\\sqrt{2}, 1)$ 来抽取 $\\eta^{(i)} = D \\xi^{(i)}$，从而使得 $\\mathrm{cov}(\\eta^{(i)}) = \\mathrm{diag}(2, 1)$。\n\n仅使用协方差的基本定义、高斯随机向量线性变换的性质，以及使用因子 $1/(N-1)$ 的无偏样本协方差是总体协方差的无偏估计量这一事实，推导在上述错误实践下集合新息协方差的期望 $(1,2)$ 元素，并计算其相对于由 $R$ 隐含的正确 $(1,2)$ 元素的偏差。\n\n将您的最终答案表示为 $(1,2)$ 元素的期望偏差（错误值减去正确值），作为一个实数，四舍五入到四位有效数字。将该量视为无单位的。",
            "solution": "本题要求计算由于在随机集合卡尔曼滤波器 (EnKF) 中生成观测扰动的错误过程所导致的集合新息协方差矩阵 $(1,2)$ 元素的偏差。偏差定义为错误元素的期望值减去正确值。\n\n首先，我们对所涉及的量进行形式化。数据同化在二维空间中进行。观测算子是单位矩阵 $H = I_{2}$。真实的观测误差协方差由矩阵\n$$\nR = \\begin{pmatrix} 2  1.2 \\\\ 1.2  1 \\end{pmatrix}\n$$\n给出。一个关键条件是预报集合的离散度为零，即所有集合成员都与集合均值相同：对于所有成员 $i = 1, \\dots, N$，有 $x_{f}^{(i)} = \\bar{x}_{f}$。这意味着预报集合异常 $x_{f}^{(i)} - \\bar{x}_{f}$ 都是零向量，因此，预报集合协方差矩阵 $P_{f}^{e}$ 是零矩阵，$P_{f}^{e} = 0$。\n\n在带扰动观测的随机 EnKF 中，每个集合成员都使用一个合成观测 $y^{(i)}$ 进行更新，该合成观测是通过将一个随机扰动 $\\eta^{(i)}$ 添加到实际观测 $y$ 中创建的。因此，$y^{(i)} = y + \\eta^{(i)}$。第 $i$ 个集合成员的新息 $d^{(i)}$ 定义为其合成观测与其投影预报之间的差：\n$$\nd^{(i)} = y^{(i)} - H x_{f}^{(i)}.\n$$\n给定 $H = I_{2}$ 和 $x_{f}^{(i)} = \\bar{x}_{f}$，上式变为：\n$$\nd^{(i)} = (y + \\eta^{(i)}) - I_{2} \\bar{x}_{f} = y - \\bar{x}_{f} + \\eta^{(i)}.\n$$\n集合新息协方差，我们记为 $S^e$，是这些新息向量的样本协方差。其计算公式为：\n$$\nS^e = \\frac{1}{N-1} \\sum_{i=1}^{N} (d^{(i)} - \\bar{d})(d^{(i)} - \\bar{d})^T,\n$$\n其中 $\\bar{d}$ 是新息集合的均值。均值新息为：\n$$\n\\bar{d} = \\frac{1}{N} \\sum_{i=1}^{N} d^{(i)} = \\frac{1}{N} \\sum_{i=1}^{N} (y - \\bar{x}_{f} + \\eta^{(i)}) = y - \\bar{x}_{f} + \\frac{1}{N} \\sum_{i=1}^{N} \\eta^{(i)} = y - \\bar{x}_{f} + \\bar{\\eta},\n$$\n其中 $\\bar{\\eta}$ 是扰动的样本均值。\n\n现在，我们可以找到成员 $i$ 的新息异常：\n$$\nd^{(i)} - \\bar{d} = (y - \\bar{x}_{f} + \\eta^{(i)}) - (y - \\bar{x}_{f} + \\bar{\\eta}) = \\eta^{(i)} - \\bar{\\eta}.\n$$\n将此代回 $S^e$ 的公式，我们发现由于预报离散度为零，集合新息协方差恰好是观测扰动的样本协方差：\n$$\nS^e = \\frac{1}{N-1} \\sum_{i=1}^{N} (\\eta^{(i)} - \\bar{\\eta})(\\eta^{(i)} - \\bar{\\eta})^T.\n$$\n题目要求计算该矩阵 $(1,2)$ 元素的期望值 $E[(S^e)_{1,2}]$。由于期望是一个线性算子，这等于 $(E[S^e])_{1,2}$。题目陈述中给出了一个事实，即用因子 $1/(N-1)$ 计算的样本协方差是总体协方差的无偏估计量。因此，样本协方差矩阵 $S^e$ 的期望值是随机向量 $\\eta^{(i)}$ 的总体协方差：\n$$\nE[S^e] = \\mathrm{cov}(\\eta^{(i)}).\n$$\n所描述的“错误实践”在于从一个忽略 $R$ 非对角线元素的分布中抽取扰动 $\\eta^{(i)}$。具体来说，$\\eta^{(i)} = D \\xi^{(i)}$，其中 $\\xi^{(i)} \\sim \\mathcal{N}(0, I_{2})$ 且 $D = \\mathrm{diag}(\\sqrt{2}, 1)$。这些错误扰动的协方差为：\n$$\n\\mathrm{cov}(\\eta^{(i)}) = E[\\eta^{(i)}(\\eta^{(i)})^T] = E[D \\xi^{(i)} (\\xi^{(i)})^T D^T] = D E[\\xi^{(i)}(\\xi^{(i)})^T] D^T = D I_{2} D^T = D^2.\n$$\n计算 $D^2$：\n$$\nD^2 = \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n因此，在错误实践下，期望的集合新息协方差为：\n$$\nE[S^{e}_{\\text{incorrect}}] = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}.\n$$\n因此，期望的 $(1,2)$ 元素为 $(E[S^{e}_{\\text{incorrect}}])_{1,2} = 0$。\n\n接下来，我们确定“由 $R$ 隐含的正确 $(1,2)$ 元素”。在 EnKF 中，集合新息协方差 $S^e$ 用作理论新息协方差 $S_{\\text{theory}} = H P_f H^T + R$ 的估计，其中 $P_f$ 是真实的预报误差协方差。鉴于预报集合的离散度为零（$P_f^e = 0$），预报误差协方差 $P_f$ 实际上为零。因此，$S_{\\text{theory}} = R$。一个正确的实现会从 $\\mathcal{N}(0,R)$ 中生成扰动，所得 $S^e$ 的期望值将为 $R$。因此，期望新息协方差的 $(1,2)$ 元素的正确值是 $R$ 的 $(1,2)$ 元素。\n根据 $R$ 的定义，正确值为 $R_{1,2} = 1.2$。\n\n最后，我们计算偏差，定义为错误值减去正确值：\n$$\n\\text{Bias} = (E[S^{e}_{\\text{incorrect}}])_{1,2} - R_{1,2} = 0 - 1.2 = -1.2.\n$$\n题目要求答案四舍五入到四位有效数字。数值 $-1.2$ 以四位有效数字表示为 $-1.200$。",
            "answer": "$$\\boxed{-1.200}$$"
        }
    ]
}