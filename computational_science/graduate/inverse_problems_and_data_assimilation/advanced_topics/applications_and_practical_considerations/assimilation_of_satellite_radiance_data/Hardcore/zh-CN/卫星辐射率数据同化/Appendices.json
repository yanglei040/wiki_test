{
    "hands_on_practices": [
        {
            "introduction": "数据同化系统，特别是四维变分同化（4D-Var），依赖于对复杂的非线性物理模型（如辐射传输模型）进行线性化。本练习将引导您检验切线性近似的有效性，这是构建任何可靠同化系统之前的关键第一步。通过一个简化的、基于物理的大气模型，您将亲手量化由线性化引入的误差，并理解其与扰动大小和模型非线性程度的关系。",
            "id": "3365135",
            "problem": "考虑在地表上方一个水平均匀、晴空、等温的湿层上，对来自单一光谱通道的卫星天底视角热红外辐射亮度进行同化。设观测算子使用以下基于物理的要素，将大气状态映射到大气层顶（TOA）的单色辐射亮度：\n\n1. 沿视线路径吸收的比尔-朗伯定律。对于天底几何（天顶角余弦等于$1$），该层的透射率为\n$$\n\\tau(q) = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right),\n$$\n其中 $q$ 是比湿，单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$；$\\kappa_\\nu$ 是水汽在该通道波数下的质量吸收系数，单位为 $\\mathrm{m}^2\\,\\mathrm{kg}^{-1}$；$M_{\\text{air}}$ 是该层单位面积的空气质量，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-2}$。\n\n2. 关于绝对温度的光谱辐射亮度的普朗克定律，写在波数域（单位波数的光谱辐射亮度）：\n$$\nB_{\\tilde{\\nu}}(T) = \\frac{2 h c^2 \\tilde{\\nu}^3}{\\exp\\!\\left(\\frac{h c \\tilde{\\nu}}{k_B T}\\right) - 1},\n$$\n其中 $h$ 是普朗克常数，单位为 $\\mathrm{J}\\,\\mathrm{s}$；$c$ 是光速，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$；$k_B$ 是波兹曼常数，单位为 $\\mathrm{J}\\,\\mathrm{K}^{-1}$；$\\tilde{\\nu}$ 是波数，单位为 $\\mathrm{m}^{-1}$；$T$ 是温度，单位为 $\\mathrm{K}$。$B_{\\tilde{\\nu}}$ 的单位是 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,(\\mathrm{m}^{-1})^{-1}$。\n\n3. 地表是一个朗伯发射体，其发射率为 $\\varepsilon_s$（无因次），地表温度为 $T_s$；气层为等温层，温度为 $T_\\ell$。对于天底视角和晴空条件，大气层顶的单色辐射亮度为\n$$\nH(q) = \\varepsilon_s \\, B_{\\tilde{\\nu}}(T_s)\\, \\tau(q) + \\left(1 - \\tau(q)\\right) B_{\\tilde{\\nu}}(T_\\ell).\n$$\n\n现要求您在有限扰动实验中，检验观测算子的切线线性（TL）近似的有效性。设背景场比湿为 $q_b$。对于一个扰动 $\\delta q$，将 $H$ 在 $q_b$ 附近的 TL 线性化定义为\n$$\nH(q_b + \\delta q) \\approx H(q_b) + K\\, \\delta q,\n$$\n其中 $K$ 是 TL 算子（即 $H$ 对 $q$ 的导数在 $q_b$ 处的值）。您的任务是：\n\n- 严格根据上述定义和标准微分法则，推导出在 $q_b$ 处的 $K$ 的解析表达式，并以给定的物理参数表示。除了已陈述的假设外，不要引入任何非物理的近似。\n\n- 对于每个扰动 $\\delta q$，计算非线性指标（相对 TL 误差）\n$$\n\\mathcal{E}_{\\text{rel}}(\\delta q) = \\frac{\\left|H(q_b+\\delta q) - H(q_b) - K\\,\\delta q\\right|}{\\left|H(q_b+\\delta q) - H(q_b)\\right|},\n$$\n并约定如果分母为零，则 $\\mathcal{E}_{\\text{rel}}(\\delta q)$ 定义为 $0$。\n\n- 对于下方的每个测试案例，返回该案例提供的扰动列表中 $\\mathcal{E}_{\\text{rel}}(\\delta q)$ 的最大值，该值为一个纯量。\n\n物理常数和单位：\n- 使用 $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$，$c = 2.99792458\\times 10^{8}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，以及 $k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$。\n- 使用单一通道，其波数为 $\\tilde{\\nu} = 1000\\ \\mathrm{cm}^{-1} = 100000\\ \\mathrm{m}^{-1}$。\n- 所有温度必须以 $\\mathrm{K}$ 表示，比湿 $q$ 及其扰动 $\\delta q$ 以 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$ 表示，质量吸收系数 $\\kappa_\\nu$ 以 $\\mathrm{m}^2\\,\\mathrm{kg}^{-1}$ 表示，层质量 $M_{\\text{air}}$ 以 $\\mathrm{kg}\\,\\mathrm{m}^{-2}$ 表示，辐射亮度以 $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}\\,(\\mathrm{m}^{-1})^{-1}$ 表示。\n\n测试套件：\n- 案例 $1$：$q_b = 0.005$, $T_\\ell = 280$, $T_s = 290$, $\\kappa_\\nu = 0.04$, $M_{\\text{air}} = 4000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-6},\\,10^{-5},\\,10^{-4},\\,5\\times 10^{-4}\\}$。\n- 案例 $2$：$q_b = 0.015$, $T_\\ell = 270$, $T_s = 300$, $\\kappa_\\nu = 0.05$, $M_{\\text{air}} = 4000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-5},\\,10^{-4},\\,10^{-3},\\,2\\times 10^{-3}\\}$。\n- 案例 $3$：$q_b = 0.020$, $T_\\ell = 295$, $T_s = 305$, $\\kappa_\\nu = 0.06$, $M_{\\text{air}} = 5000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{-10^{-4},\\,-5\\times 10^{-4},\\,5\\times 10^{-4},\\,2\\times 10^{-3}\\}$。\n- 案例 $4$：$q_b = 0.025$, $T_\\ell = 260$, $T_s = 270$, $\\kappa_\\nu = 0.07$, $M_{\\text{air}} = 6000$, $\\varepsilon_s = 0.98$, $\\delta q \\in \\{10^{-3},\\,3\\times 10^{-3},\\,5\\times 10^{-3}\\}$。\n\n数值与输出要求：\n- 对于每个测试案例，计算其所有 $\\delta q$ 值中的最大相对 TL 误差，并四舍五入至 $6$ 位小数。\n- 您的程序应产生单行输出，其中包含一个由方括​​号括起来的逗号分隔列表，按四个案例的顺序排列结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是四舍五入到 $6$ 位小数的浮点数。",
            "solution": "该问题是有效的，因为它基于大气辐射传输的既定原理，具有科学依据，在数学上是适定的，并且为求得唯一解提供了所有必要的参数和常数。我们着手解决此问题。\n\n解题过程包括两个主要部分：首先，切线线性（TL）算子 $K$ 的解析推导；其次，为给定测试案例计算相对 TL 误差的数值实现。\n\n**1. 切线线性算子的解析推导**\n\n切线线性算子 $K$ 定义为观测算子 $H(q)$ 对状态变量 $q$ 的一阶导数，在背景状态 $q_b$ 处取值。\n$$K = \\frac{dH}{dq}\\bigg|_{q=q_b}$$\n大气层顶（TOA）单色辐射亮度的观测算子 $H(q)$ 由下式给出：\n$$H(q) = \\varepsilon_s \\, B_{\\tilde{\\nu}}(T_s)\\, \\tau(q) + \\left(1 - \\tau(q)\\right) B_{\\tilde{\\nu}}(T_\\ell)$$\n其中 $\\varepsilon_s$ 是地表发射率，$T_s$ 是地表温度，$T_\\ell$ 是气层温度，$B_{\\tilde{\\nu}}(T)$ 是在波数 $\\tilde{\\nu}$ 和温度 $T$ 下的普朗克辐射亮度函数。对比湿 $q$ 的依赖完全是通过气层透射率 $\\tau(q)$ 来体现的。\n\n为了使微分更清晰，我们可以重排 $H(q)$ 的表达式：\n$$H(q) = \\tau(q) \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] + B_{\\tilde{\\nu}}(T_\\ell)$$\n普朗克函数值 $B_{\\tilde{\\nu}}(T_s)$ 和 $B_{\\tilde{\\nu}}(T_\\ell)$ 相对于 $q$ 是常数。我们应用链式法则对 $H(q)$ 关于 $q$ 进行微分：\n$$\\frac{dH}{dq} = \\frac{d}{dq} \\left( \\tau(q) \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] + B_{\\tilde{\\nu}}(T_\\ell) \\right)$$\n$$\\frac{dH}{dq} = \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] \\frac{d\\tau}{dq}$$\n接下来，我们求透射率 $\\tau(q)$ 的导数，它由比尔-朗伯定律定义：\n$$\\tau(q) = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n其中 $\\kappa_\\nu$ 是质量吸收系数，$M_{\\text{air}}$ 是层的单位面积空气质量。对 $\\tau(q)$ 关于 $q$ 微分：\n$$\\frac{d\\tau}{dq} = \\frac{d}{dq} \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n对指数函数使用链式法则，其中指数的参数是 $q$ 的线性函数：\n$$\\frac{d\\tau}{dq} = \\exp\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right) \\cdot \\frac{d}{dq}\\left(- \\kappa_\\nu \\, q \\, M_{\\text{air}}\\right)$$\n$$\\frac{d\\tau}{dq} = \\tau(q) \\cdot (-\\kappa_\\nu M_{\\text{air}})$$\n将此结果代回 $\\frac{dH}{dq}$ 的表达式中：\n$$\\frac{dH}{dq} = \\left[ \\varepsilon_s B_{\\tilde{\\nu}}(T_s) - B_{\\tilde{\\nu}}(T_\\ell) \\right] \\cdot \\left[ -\\kappa_\\nu M_{\\text{air}} \\tau(q) \\right]$$\n该表达式可以重排为：\n$$\\frac{dH}{dq} = \\kappa_\\nu M_{\\text{air}} \\, \\tau(q) \\, \\left[ B_{\\tilde{\\nu}}(T_\\ell) - \\varepsilon_s B_{\\tilde{\\nu}}(T_s) \\right]$$\n切线线性算子 $K$ 是此导数在背景场比湿 $q_b$ 处的值：\n$$K = \\frac{dH}{dq}\\bigg|_{q=q_b} = \\kappa_\\nu M_{\\text{air}} \\, \\tau(q_b) \\, \\left[ B_{\\tilde{\\nu}}(T_\\ell) - \\varepsilon_s B_{\\tilde{\\nu}}(T_s) \\right]$$\n其中 $\\tau(q_b) = \\exp\\left(- \\kappa_\\nu \\, q_b \\, M_{\\text{air}}\\right)$。这就是 $K$ 的最终解析表达式。\n\n**2. 数值计算的算法步骤**\n\n对于每个测试案例，我们在一系列扰动 $\\{\\delta q_i\\}$ 上计算最大相对切线线性误差 $\\mathcal{E}_{\\text{rel}}(\\delta q)$。相对误差定义为：\n$$\\mathcal{E}_{\\text{rel}}(\\delta q) = \\frac{\\left|H(q_b+\\delta q) - H(q_b) - K\\,\\delta q\\right|}{\\left|H(q_b+\\delta q) - H(q_b)\\right|}$$\n算法步骤如下：\n1.  设定物理常数：$h = 6.62607015\\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$，$c = 2.99792458\\times 10^{8}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$，$k_B = 1.380649\\times 10^{-23}\\ \\mathrm{J}\\,\\mathrm{K}^{-1}$，以及波数 $\\tilde{\\nu} = 100000\\ \\mathrm{m}^{-1}$。\n2.  对于每个测试案例及其特定的参数集（$q_b, T_\\ell, T_s, \\kappa_\\nu, M_{\\text{air}}, \\varepsilon_s$）和扰动列表 $\\{\\delta q_i\\}$：\n    a.  使用普朗克函数公式计算气层的普朗克辐射亮度 $B_\\ell = B_{\\tilde{\\nu}}(T_\\ell)$ 和地表的普朗克辐射亮度 $B_s = B_{\\tilde{\\nu}}(T_s)$：\n        $$B_{\\tilde{\\nu}}(T) = \\frac{2 h c^2 \\tilde{\\nu}^3}{\\exp\\!\\left(\\frac{h c \\tilde{\\nu}}{k_B T}\\right) - 1}$$\n    b.  使用观测算子公式计算背景辐射亮度 $H_b = H(q_b)$。\n    c.  使用推导出的解析公式在 $q_b$ 处计算切线线性算子 $K$。\n    d.  初始化一个空列表以存储当前案例的误差。\n    e.  对于列表 $\\{\\delta q_i\\}$ 中的每个扰动 $\\delta q$：\n        i.  计算扰动后状态 $q_p = q_b + \\delta q$。\n        ii. 计算真实的扰动后辐射亮度 $H_p = H(q_p)$。\n        iii. 计算误差项的分子：$N = |H_p - H_b - K \\cdot \\delta q|$。\n        iv. 计算误差项的分母：$D = |H_p - H_b|$。\n        v. 如果 $D$ 为零，则相对误差 $\\mathcal{E}_{\\text{rel}}(\\delta q)$ 为 $0$。否则，计算误差为 $\\mathcal{E}_{\\text{rel}}(\\delta q) = N / D$。\n        vi. 将计算出的误差附加到列表中。\n    f.  从计算出的误差列表中确定最大值。\n    g.  将此最大误差四舍五入至 $6$ 位小数，并将其记录为该测试案例的结果。\n3.  将所有测试案例的结果合并到一个列表中，并按要求格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem by calculating the maximum relative \n    Tangent-Linear error for a set of test cases in satellite radiance assimilation.\n    \"\"\"\n\n    # Physical constants\n    H = 6.62607015e-34    # Planck's constant in J.s\n    C = 2.99792458e8      # Speed of light in m/s\n    KB = 1.380649e-23     # Boltzmann's constant in J/K\n    NU_TILDE = 100000.    # Wavenumber in m^-1 (from 1000 cm^-1)\n\n    # Pre-calculate constant parts of the Planck function for efficiency\n    C1 = 2 * H * C**2 * NU_TILDE**3\n    C2 = H * C * NU_TILDE / KB\n\n    def planck(T):\n        \"\"\"\n        Calculates the spectral radiance using Planck's law.\n        :param T: Temperature in Kelvin.\n        :return: Spectral radiance in W m^-2 sr^-1 (m^-1)^-1.\n        \"\"\"\n        # The argument to exp can be large, but temperatures are reasonable.\n        return C1 / (np.exp(C2 / T) - 1)\n\n    def transmittance(q, kappa_nu, M_air):\n        \"\"\"\n        Calculates the layer transmittance using the Beer-Lambert law.\n        :param q: Specific humidity in kg/kg.\n        :param kappa_nu: Mass absorption coefficient in m^2/kg.\n        :param M_air: Layer air mass per unit area in kg/m^2.\n        :return: Transmittance (dimensionless).\n        \"\"\"\n        optical_depth = kappa_nu * q * M_air\n        return np.exp(-optical_depth)\n\n    def H_operator(q, B_ell, B_s, kappa_nu, M_air, eps_s):\n        \"\"\"\n        The observation operator H(q).\n        :param q: Specific humidity in kg/kg.\n        :param B_ell: Pre-calculated layer Planck radiance.\n        :param B_s: Pre-calculated surface Planck radiance.\n        :param kappa_nu, M_air, eps_s: Other physical parameters.\n        :return: Top Of Atmosphere (TOA) radiance.\n        \"\"\"\n        tau = transmittance(q, kappa_nu, M_air)\n        return eps_s * B_s * tau + (1 - tau) * B_ell\n\n    def K_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s):\n        \"\"\"\n        The Tangent-Linear operator K = dH/dq at q_b.\n        :param q_b: Background specific humidity.\n        :param B_ell, B_s: Pre-calculated Planck radiances.\n        :param kappa_nu, M_air, eps_s: Other physical parameters.\n        :return: Value of the Tangent-Linear operator K.\n        \"\"\"\n        tau_b = transmittance(q_b, kappa_nu, M_air)\n        # B_diff = eps_s * B_s - B_ell\n        # dtau_dq = -kappa_nu * M_air * tau_b\n        # return B_diff * dtau_dq\n        # Alternative form from derivation:\n        return kappa_nu * M_air * tau_b * (B_ell - eps_s * B_s)\n\n    def calculate_max_error(params):\n        \"\"\"\n        Calculates the maximum relative TL error for a single test case.\n        :param params: A tuple containing all parameters for the case.\n        :return: The maximum relative error, rounded to 6 decimal places.\n        \"\"\"\n        q_b, T_ell, T_s, kappa_nu, M_air, eps_s, delta_q_list = params\n        \n        # Pre-calculate Planck radiances for the case\n        B_ell = planck(T_ell)\n        B_s = planck(T_s)\n        \n        # Calculate H for background state and the K operator\n        H_b = H_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s)\n        K = K_operator(q_b, B_ell, B_s, kappa_nu, M_air, eps_s)\n        \n        errors = []\n        for delta_q in delta_q_list:\n            q_p = q_b + delta_q  # Perturbed state\n            \n            # Full non-linear model for perturbed state\n            H_p = H_operator(q_p, B_ell, B_s, kappa_nu, M_air, eps_s)\n            \n            # Numerator of the relative error formula: |H_p - (H_b + K*dq)|\n            numerator = abs(H_p - H_b - K * delta_q)\n            \n            # Denominator of the relative error formula: |H_p - H_b|\n            denominator = abs(H_p - H_b)\n            \n            if denominator == 0.0:\n                # Per problem spec, if denominator is 0, error is 0.\n                rel_error = 0.0\n            else:\n                rel_error = numerator / denominator\n            \n            errors.append(rel_error)\n            \n        max_error = max(errors) if errors else 0.0\n        return round(max_error, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (q_b, T_ell, T_s, kappa_nu, M_air, eps_s, [delta_q values])\n        (0.005, 280, 290, 0.04, 4000, 0.98, [1e-6, 1e-5, 1e-4, 5e-4]),\n        (0.015, 270, 300, 0.05, 4000, 0.98, [1e-5, 1e-4, 1e-3, 2e-3]),\n        (0.020, 295, 305, 0.06, 5000, 0.98, [-1e-4, -5e-4, 5e-4, 2e-3]),\n        (0.025, 260, 270, 0.07, 6000, 0.98, [1e-3, 3e-3, 5e-3]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_max_error(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了模型之后，下一步是在分析步骤中有效地使用它。数据同化的分析过程通过最优地加权观测信息来修正背景场，而权重由观测误差协方差矩阵 $R$ 决定。本练习将带您超越通常假设观测误差不相关的简化情景，深入探究通道间的误差相关性如何改变分析增益（即卡尔曼增益），并最终影响我们对不同卫星通道重要性的评估。",
            "id": "3365144",
            "problem": "考虑一个贝叶斯线性高斯设定下的线性化卫星辐射率同化问题。未知状态向量 $x \\in \\mathbb{R}^n$ 代表四个层级的温度（单位：开尔文）。观测向量 $y \\in \\mathbb{R}^m$ 代表由卫星仪器测量的五个红外亮度温度通道（单位：开尔文）。观测算子 $H \\in \\mathbb{R}^{m \\times n}$ 是从状态到辐射率的辐射传输映射的雅可比矩阵，假定在背景场附近为线性。背景误差协方差 $B \\in \\mathbb{R}^{n \\times n}$ 是对称正定的，观测误差协方差 $R \\in \\mathbb{R}^{m \\times m}$ 也是对称正定的。\n\n基本依据：\n- 先验分布为高斯分布，$x \\sim \\mathcal{N}(x_b, B)$，其中 $x_b$ 是背景状态。\n- 观测模型为 $y = H x + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, R)$。\n- 后验分布通过应用贝叶斯法则获得，它在线性高斯分析中产生一个最优线性估计器，该估计器在给定协方差下最小化二次贝叶斯代价函数。\n- 在线性高斯情况下，卡尔曼滤波器（KF）是结合 $B$、$H$ 和 $R$ 形成分析更新的标准框架。\n\n您必须在纯数学公式的框架下进行操作，不使用外部数据。所有状态和观测量均以开尔文为单位，以确保卡尔曼增益是无量纲的（开尔文/开尔文）。不使用角度。不需要百分比。\n\n设置：\n- 维度：$n = 4$（状态）和 $m = 5$（通道）。\n- 观测算子 $H$（无量纲灵敏度，开尔文/开尔文）：\n$$\nH = \\begin{bmatrix}\n0.6  0.3  0.1  0.0 \\\\\n0.2  0.5  0.3  0.0 \\\\\n0.1  0.2  0.5  0.2 \\\\\n0.0  0.1  0.4  0.5 \\\\\n0.0  0.0  0.3  0.7\n\\end{bmatrix}.\n$$\n- 背景误差协方差 $B$（单位：开尔文$^2$），由物理上合理的相邻层之间指数衰减相关性构建：\n    - 层标准差 $s = [1.0, 0.9, 0.7, 0.6]$（单位：开尔文）。\n    - 背景相关参数 $r_b = 0.6$。\n    - 相关矩阵 $C^{(n)} \\in \\mathbb{R}^{n \\times n}$，其元素为 $C^{(n)}_{ij} = r_b^{|i-j|}$。\n    - 则 $B_{ij} = s_i s_j C^{(n)}_{ij}$。\n- 观测误差协方差 $R$ 取决于每个通道的标准差 $\\sigma_i$（单位：开尔文）和通道间相关参数 $\\rho$，通过一个托普利茨（Toeplitz）结构实现：\n    - 相关矩阵 $C^{(m)} \\in \\mathbb{R}^{m \\times m}$，其元素为 $C^{(m)}_{ij} = \\rho^{|i-j|}$。\n    - 对于对角（不相关）误差，设置 $\\rho = 0$，因此 $C^{(m)}$ 成为单位矩阵，且 $R = \\mathrm{diag}(\\sigma_1^2, \\dots, \\sigma_m^2)$。\n    - 对于相关误差，使用托普利茨结构 $R_{ij} = \\sigma_i \\sigma_j C^{(m)}_{ij} = \\sigma_i \\sigma_j \\rho^{|i-j|}$。\n\n任务：\n1. 从线性高斯贝叶斯公式和代价函数最小化原理出发，推导出以 $B$、$H$ 和 $R$ 表示的分析增益矩阵 $K_a \\in \\mathbb{R}^{n \\times m}$。针对对角矩阵 $R$（$\\rho=0$）和相关的托普利茨矩阵 $R$（具有指定的 $\\rho$），实现一个数值稳定的 $K_a$ 计算方法。\n2. 将通道 $i$ 的通道影响分数定义为 $K_a$ 第 $i$ 列的欧几里得范数，即 $s_i = \\lVert K_a[:, i] \\rVert_2$。使用从零开始的通道索引，通过按 $s_i$ 的降序对通道进行排序来确定通道影响排名，若出现平局则按通道索引的升序排列。\n3. 通过弗罗贝尼乌斯范数差 $\\Delta = \\lVert K_a^{(\\mathrm{toeplitz})} - K_a^{(\\mathrm{diag})} \\rVert_F$ 来量化通道间相关性的影响，在开尔文单位设置下该范数差是无量纲的。\n\n测试集：\n对于每组参数，使用与上述相同的 $H$ 和 $B$，并使用给定的 $\\sigma$ 和 $\\rho$ 值构建 $R$。\n\n- 情况 A (标准情况)：$\\sigma = [0.5, 0.6, 0.4, 0.7, 0.5]$ 开尔文, $\\rho = 0.5$。\n- 情况 B (边界，无相关性)：$\\sigma = [0.5, 0.6, 0.4, 0.7, 0.5]$ 开尔文, $\\rho = 0.0$。\n- 情况 C (极端，强正相关)：$\\sigma = [0.8, 0.8, 0.8, 0.8, 0.8]$ 开尔文, $\\rho = 0.9$。\n- 情况 D (极端，负相关)：$\\sigma = [0.5, 0.7, 0.9, 0.7, 0.5]$ 开尔文, $\\rho = -0.3$。\n\n程序要求：\n- 对每个测试用例，计算：\n    1. 使用对角矩阵 $R$（具有相同的 $\\sigma$ 但 $\\rho=0$）计算的 $K_a$ 与使用指定的托普利茨矩阵 $R$ 计算的 $K_a$ 之间的无量纲弗罗贝尼乌斯范数差 $\\Delta$。\n    2. 对角矩阵 $R$ 的通道排名列表（从零开始的索引）。\n    3. 托普利茨矩阵 $R$ 的通道排名列表（从零开始的索引）。\n    4. 每个通道的排名变化列表，其中通道 $i$ 的变化等于其在托普利茨排名中的位置减去其在对角排名中的位置。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是一个形式为 $[\\Delta, \\text{diag\\_rank}, \\text{toeplitz\\_rank}, \\text{rank\\_shift}]$ 的列表，其中 $\\text{diag\\_rank}$、$\\text{toeplitz\\_rank}$ 和 $\\text{rank\\_shift}$ 是整数列表。最终输出必须将四个测试用例聚合到一个外部列表中，例如：\n$[[\\Delta_A,[\\dots],[\\dots],[\\dots]],[\\Delta_B,[\\dots],[\\dots],[\\dots]],[\\Delta_C,[\\dots],[\\dots],[\\dots]],[\\Delta_D,[\\dots],[\\dots],[\\dots]]]$。",
            "solution": "所提出的问题是线性高斯数据同化的一个典型例子，具体来说是卡尔曼滤波器的分析步骤。我们的任务是给定一个观测向量 $y \\in \\mathbb{R}^m$（代表卫星亮度温度），确定状态向量 $x \\in \\mathbb{R}^n$（代表大气层温度）的最优估计。该问题在贝叶斯框架内进行描述，其中状态的先验知识与来自观测的新信息相结合，以产生更新的（即后验）估计。\n\n基本组成部分是：\n1.  状态的先验分布，$x \\sim \\mathcal{N}(x_b, B)$，其中 $x_b$ 是背景（先验均值）状态，$B \\in \\mathbb{R}^{n \\times n}$ 是背景误差协方差矩阵。\n2.  线性观测模型，$y = Hx + \\varepsilon$，其中 $H \\in \\mathbb{R}^{m \\times n}$ 是观测算子（或正向模型），观测误差 $\\varepsilon$ 来自零均值高斯分布 $\\varepsilon \\sim \\mathcal{N}(0, R)$，$R \\in \\mathbb{R}^{m \\times m}$ 是观测误差协方差矩阵。\n\n目标是找到分析状态 $x_a$，使其后验概率密度最大化，在高斯情况下，这等同于最小化二次代价函数 $J(x)$。该代价函数衡量候选状态 $x$ 与背景信息和观测值之间的失配度，并由它们各自的误差协方差进行加权。\n\n代价函数 $J(x)$ 是背景项 $J_b(x)$ 和观测项 $J_o(x)$ 的和：\n$$ J(x) = J_b(x) + J_o(x) = \\frac{1}{2}(x - x_b)^T B^{-1} (x - x_b) + \\frac{1}{2}(y - Hx)^T R^{-1} (y - Hx) $$\n为了找到最小化 $J(x)$ 的分析状态 $x_a$，我们计算 $J(x)$ 关于 $x$ 的梯度并将其设为零。梯度为：\n$$ \\nabla_x J(x) = B^{-1}(x - x_b) - H^T R^{-1}(y - Hx) $$\n为最优状态 $x_a$ 设定 $\\nabla_x J(x_a) = 0$ 可得：\n$$ B^{-1}(x_a - x_b) - H^T R^{-1}(y - Hx_a) = 0 $$\n重新整理各项以求解 $x_a$：\n$$ (B^{-1} + H^T R^{-1}H)x_a = B^{-1}x_b + H^T R^{-1}y $$\n这导出了分析状态的逆形式解：\n$$ x_a = (B^{-1} + H^T R^{-1}H)^{-1} (B^{-1}x_b + H^T R^{-1}y) $$\n虽然这个形式是正确的，但它通常不适用于数值计算，因为它可能需要多次矩阵求逆，包括对通常很大的背景误差协方差矩阵 $B$ 的求逆。\n\n一个更常用且数值上更稳定的形式是增益形式，它将分析状态表示为对背景状态的更新：\n$$ x_a = x_b + K_a(y - Hx_b) $$\n这里，$K_a \\in \\mathbb{R}^{n \\times m}$ 是分析增益矩阵，通常称为卡尔曼增益。项 $(y - Hx_b)$ 是新息（innovation）或离差（departure），代表观测提供的新信息。增益矩阵 $K_a$ 将这些新信息最优地分配到状态向量的各个分量上。\n\n为了推导 $K_a$ 的表达式，我们将 $x_a$ 的两种形式相等。通过比较 $y$ 的系数，我们可以确定 $K_a$ 的表达式。从逆形式解中，与 $y$ 相乘的项是 $(B^{-1} + H^T R^{-1}H)^{-1} H^T R^{-1}$。因此，\n$$ K_a = (B^{-1} + H^T R^{-1}H)^{-1} H^T R^{-1} $$\n应用 Woodbury 矩阵恒等式 $(A+UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}$，其中 $A=B^{-1}$，$U=H^T$，$C=R^{-1}$，$V=H$，我们可以变换 $(B^{-1} + H^T R^{-1}H)^{-1}$ 项以获得一个更稳定的 $K_a$ 表达式：\n$$ K_a = [B - BH^T(R+HBH^T)^{-1}HB] H^T R^{-1} $$\n$$ K_a = BH^T R^{-1} - BH^T(R+HBH^T)^{-1}HBH^T R^{-1} $$\n$$ K_a = BH^T (R+HBH^T)^{-1} [ (R+HBH^T) - HBH^T ] R^{-1} $$\n$$ K_a = BH^T (R+HBH^T)^{-1} R R^{-1} $$\n这个简化过程得出了卡尔曼增益的标准且数值计算上更优的表达式：\n$$ K_a = B H^T (R + H B H^T)^{-1} $$\n这个公式的优点在于它需要对矩阵 $(R + H B H^T)$ 求逆，该矩阵的维度是 $m \\times m$。在许多实际应用中，观测数量 $m$ 远小于状态变量数量 $n$，这使得该求逆运算在计算上更廉价。在我们的例子中，$n=4$，$m=5$，所以维度是可比的，但这种形式避免了直接对 $B$ 和 $R$ 求逆。\n\n解决该问题的算法步骤如下：\n1.  **构建协方差矩阵**：\n    -   背景误差协方差 $B$ 构建为 $B_{ij} = s_i s_j r_b^{|i-j|}$，其中 $s$ 是层标准差向量，$r_b$ 是背景相关参数。\n    -   观测误差协方差 $R$ 构建为 $R_{ij} = \\sigma_i \\sigma_j \\rho^{|i-j|}$，其中 $\\sigma$ 是通道标准差向量，$\\rho$ 是通道间相关参数。对于对角情况，我们设置 $\\rho=0$。\n2.  **计算增益矩阵**：对于每个测试用例，我们计算两个增益矩阵：$K_a^{(\\mathrm{toeplitz})}$ 使用指定的 $\\rho$，以及 $K_a^{(\\mathrm{diag})}$ 使用相同的 $\\sigma$ 但 $\\rho=0$。计算遵循推导出的公式 $K_a = B H^T (R + H B H^T)^{-1}$。\n3.  **计算通道影响并排名**：观测通道 $i$ 的影响由增益矩阵第 $i$ 列的欧几里得范数量化，即 $s_i = \\lVert K_a[:, i] \\rVert_2$。然后按其影响分数 $s_i$ 的降序对通道进行排名，平局则按通道索引升序排列。此操作对 $K_a^{(\\mathrm{toeplitz})}$ 和 $K_a^{(\\mathrm{diag})}$ 都进行。\n4.  **量化相关效应**：\n    -   由相关性引起的增益矩阵总体变化通过差值的弗罗贝尼乌斯范数来衡量：$\\Delta = \\lVert K_a^{(\\mathrm{toeplitz})} - K_a^{(\\mathrm{diag})} \\rVert_F$。\n    -   每个通道的排名变化计算为其在托普利茨-R 排名中的位置与在对角-R 排名中的位置之差。\n\n指定的单位（温度和标准差使用开尔文）确保了雅可比矩阵 $H$ 和最终的增益矩阵 $K_a$ 是无量纲的，因为 $[K_a] = [B][H^T][(R + H B H^T)^{-1}] = \\text{K}^2 \\cdot (\\text{K}/\\text{K}) \\cdot (\\text{K}^2)^{-1} = \\text{无量纲}$。因此，影响分数 $s_i$ 和范数差 $\\Delta$ 也是无量纲的。\n实现将通过对所提供的四个测试用例系统地应用这些步骤来进行。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz\n\ndef solve():\n    \"\"\"\n    Solves the satellite radiance assimilation problem for the given test cases.\n    \"\"\"\n    \n    # --- Givens (fixed for all cases) ---\n    # State dimension n=4, observation dimension m=5\n    n = 4\n    m = 5\n    \n    # Observation operator H\n    H = np.array([\n        [0.6, 0.3, 0.1, 0.0],\n        [0.2, 0.5, 0.3, 0.0],\n        [0.1, 0.2, 0.5, 0.2],\n        [0.0, 0.1, 0.4, 0.5],\n        [0.0, 0.0, 0.3, 0.7]\n    ])\n\n    # Background error covariance B parameters\n    s_b = np.array([1.0, 0.9, 0.7, 0.6])\n    r_b = 0.6\n\n    # Test suite parameters\n    test_cases = [\n        # Case A\n        {'sigma': np.array([0.5, 0.6, 0.4, 0.7, 0.5]), 'rho': 0.5},\n        # Case B\n        {'sigma': np.array([0.5, 0.6, 0.4, 0.7, 0.5]), 'rho': 0.0},\n        # Case C\n        {'sigma': np.array([0.8, 0.8, 0.8, 0.8, 0.8]), 'rho': 0.9},\n        # Case D\n        {'sigma': np.array([0.5, 0.7, 0.9, 0.7, 0.5]), 'rho': -0.3}\n    ]\n\n    # --- Helper Functions ---\n    def build_B(s_dev, corr_param):\n        \"\"\"Constructs the background error covariance matrix B.\"\"\"\n        dim = len(s_dev)\n        corr_col = np.power(corr_param, np.arange(dim))\n        C = toeplitz(corr_col)\n        D = np.diag(s_dev)\n        B_matrix = D @ C @ D\n        return B_matrix\n\n    def build_R(s_dev, corr_param):\n        \"\"\"Constructs the observation error covariance matrix R.\"\"\"\n        dim = len(s_dev)\n        # Handle the case rho=0 for diagonal R\n        if corr_param == 0.0:\n            return np.diag(s_dev**2)\n        \n        corr_col = np.power(corr_param, np.arange(dim))\n        C = toeplitz(corr_col)\n        D = np.diag(s_dev)\n        R_matrix = D @ C @ D\n        return R_matrix\n\n    def compute_kalman_gain(H_op, B_cov, R_cov):\n        \"\"\"Computes the Kalman gain K_a using the numerically stable formula.\"\"\"\n        H_T = H_op.T\n        S = R_cov + H_op @ B_cov @ H_T  # Innovation covariance\n        S_inv = np.linalg.inv(S)\n        K = B_cov @ H_T @ S_inv\n        return K\n\n    def compute_channel_ranking(K_gain):\n        \"\"\"Computes channel impact scores and returns the ranked channel indices.\"\"\"\n        num_channels = K_gain.shape[1]\n        # Calculate impact score (Euclidean norm of each column)\n        impact_scores = [np.linalg.norm(K_gain[:, i]) for i in range(num_channels)]\n        \n        # Create pairs of (score, channel_index) for sorting\n        # Tie-breaking: ascending channel index\n        score_index_pairs = list(zip(impact_scores, range(num_channels)))\n        \n        # Sort by score descending (-score ascending), then by index ascending\n        score_index_pairs.sort(key=lambda x: (-x[0], x[1]))\n        \n        # Extract the ranked channel indices\n        ranked_indices = [index for score, index in score_index_pairs]\n        return ranked_indices\n    \n    # --- Main Calculation Loop ---\n    \n    # B is constant across test cases\n    B = build_B(s_b, r_b)\n    \n    all_results = []\n    \n    for case in test_cases:\n        sigma_o = case['sigma']\n        rho_o = case['rho']\n        \n        # 1. Compute R for Toeplitz and Diagonal cases\n        R_toeplitz = build_R(sigma_o, rho_o)\n        R_diag = build_R(sigma_o, 0.0) # rho=0 gives diagonal R\n        \n        # 2. Compute gain matrices\n        K_toeplitz = compute_kalman_gain(H, B, R_toeplitz)\n        K_diag = compute_kalman_gain(H, B, R_diag)\n        \n        # 3. Compute Frobenius norm difference\n        delta = np.linalg.norm(K_toeplitz - K_diag, 'fro')\n        \n        # 4. Compute channel rankings\n        diag_rank = compute_channel_ranking(K_diag)\n        toeplitz_rank = compute_channel_ranking(K_toeplitz)\n        \n        # 5. Compute rank shifts\n        # Create maps from channel index to rank position\n        diag_pos_map = {channel: pos for pos, channel in enumerate(diag_rank)}\n        toeplitz_pos_map = {channel: pos for pos, channel in enumerate(toeplitz_rank)}\n        \n        rank_shift = [toeplitz_pos_map[i] - diag_pos_map[i] for i in range(m)]\n        \n        # 6. Aggregate results for the current case\n        case_result = [delta, diag_rank, toeplitz_rank, rank_shift]\n        all_results.append(case_result)\n\n    # --- Format and Print Final Output ---\n    # The output format must exactly match the problem statement, including no spaces after commas.\n    result_strings = []\n    for res in all_results:\n        # Convert each result item to string representation and remove spaces\n        res_str = str(res).replace(\" \", \"\")\n        result_strings.append(res_str)\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "数据同化产生的分析场并非真实大气状态的完美重现，而是通过观测系统获得的一个平滑后的估计。平均核矩阵（averaging kernel matrix）$A$ 是一个强大的诊断工具，它将分析场与真实状态联系起来，揭示了同化系统固有的平滑特性和分辨率。在本练习中，您将计算该核函数，并用它来量化分析结果的垂直分辨率，从而理解背景误差协方差 $B$ 中的先验假设如何决定最终产品的信息含量。",
            "id": "3365149",
            "problem": "考虑一个一维垂直气柱状态向量 $x \\in \\mathbb{R}^n$，表示在离散高度上的大气温度扰动，单位为开尔文（K）。红外卫星辐射观测围绕一个背景态进行线性化，其关系为 $y = K x + \\varepsilon$，其中 $y \\in \\mathbb{R}^m$ 是通道亮度温度扰动，单位为开尔文（K）；$K \\in \\mathbb{R}^{m \\times n}$ 是观测算子的雅可比矩阵（也称为权重函数）；$\\varepsilon \\sim \\mathcal{N}(0, R)$ 是观测误差，其协方差为 $R \\in \\mathbb{R}^{m \\times m}$，单位为 $\\text{K}^2$。背景误差 $e_b = x - x_b$ 满足 $e_b \\sim \\mathcal{N}(0, B)$，其协方差为 $B \\in \\mathbb{R}^{n \\times n}$，单位为 $\\text{K}^2$。\n\n从线性高斯数据同化的基本原理和高斯假设下的最小方差线性估计器出发，推导平均核矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的表达式。该矩阵将真实状态 $x$ 映射到分析场 $x_a$，并编码了分析场的垂直分辨率。你的推导必须从高斯先验和线性观测模型的条件开始，并逻辑地推导出分析算子及其对真实状态的敏感度。在没有证明的情况下，不要假设任何快捷恒等式。\n\n然后，实施一个数值实验，比较不同的垂直背景协方差结构 $B$ 如何影响从 $A$ 推断出的分析场的垂直分辨率。使用具有以下规格的科学上一致的离散化和通道配置。\n\n- 垂直网格：\n    - 设 $z_i$ 为高度，单位为公里（km），其中 $i = 0, 1, \\dots, n-1$，$n = 31$ 个点从 $z_0 = 0\\,\\text{km}$ 到 $z_{30} = 15\\,\\text{km}$ 均匀分布。\n    - 定义 $\\Delta z = 0.5\\,\\text{km}$。\n\n- 红外观测权重函数（K的行）：\n    - 使用 $m = 6$ 个通道，其中心为 $z_{c,j} \\in \\{1, 3, 5, 7, 9, 12\\}\\,\\text{km}$，其中 $j = 1, \\dots, 6$。\n    - 对于每个通道 $j$，定义一个高斯权重函数 $w_j(z) = \\exp\\left(-\\frac{(z - z_{c,j})^2}{2 \\sigma_w^2}\\right)$，其中 $\\sigma_w = 0.8\\,\\text{km}$。\n    - 通过 $K_{j,i} = \\frac{w_j(z_i)\\,\\Delta z}{\\sum_{p=0}^{n-1} w_j(z_p)\\,\\Delta z}$ 来离散化 $K$，使得每个通道在整层气柱上的积分为1。在这种归一化下，$K$ 是无量纲的。\n\n- 背景协方差 $B$ 的选择：\n    - 指数核（也称为平滑度为 $\\nu = \\tfrac{1}{2}$ 的 Matérn 核）：对于相关长度 $L_z$（公里）和方差 $\\sigma_b^2$（$\\text{K}^2$），定义 $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|z_i - z_j|}{L_z}\\right)$。\n    - 平滑度为 $\\nu > 0$ 的 Matérn 核，相关长度 $L_z$（公里）和方差 $\\sigma_b^2$（$\\text{K}^2$）：对于 $i \\neq j$，\n      $$B_{ij} = \\sigma_b^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\frac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right)^\\nu K_\\nu\\left(\\frac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right),$$\n      其中 $\\Gamma(\\cdot)$ 是伽马函数，$K_\\nu(\\cdot)$ 是第二类修正贝塞尔函数。对所有 $i$ 设置 $B_{ii} = \\sigma_b^2$。\n\n- 观测误差协方差 $R$：\n    - 使用对角阵 $R = \\operatorname{diag}(\\sigma_{y}^2, \\dots, \\sigma_{y}^2)$，单位为 $\\text{K}^2$。\n\n从推导出的 $A$ 出发，按如下方式在每个高度层 $z_i$ 定义一个定量的垂直分辨率度量。设 $a_i$ 为 $A$ 的第 $i$ 行。通过对 $a_i$ 的绝对值进行归一化来计算权重 $u_i$，\n$$u_{i,p} = \\frac{|a_{i,p}|}{\\sum_{q=0}^{n-1} |a_{i,q}|}, \\quad p = 0, \\dots, n-1.$$\n定义质心 $\\bar{z}_i = \\sum_{p=0}^{n-1} u_{i,p} z_p$ 和二阶中心矩 $M_i = \\sum_{p=0}^{n-1} u_{i,p} (z_p - \\bar{z}_i)^2$。在高度层 $z_i$ 的有效垂直分辨率宽度为 $W_i = 2 \\sqrt{M_i}$，单位为公里。为保证数值稳定性，将满足 $\\sum_{p=0}^{n-1} |a_{i,p}| \\le 10^{-12}$ 的高度层从汇总统计中排除；如果在某个测试案例中所有高度层都被排除，则返回总网格跨度 $z_{30} - z_0$ 作为该案例的分辨率度量。通过计算所有包含的高度层上 $\\{W_i\\}$ 的中位数，为每个实验汇总一个单一的分辨率度量，单位为公里。\n\n构建以下参数集测试套件，以探究问题的不同方面：\n- 案例1（基线指数）：指数型 $B$，其中 $L_z = 1.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例2（短程指数）：指数型 $B$，其中 $L_z = 0.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例3（Matérn 中等平滑度）：Matérn 型 $B$，其中 $\\nu = 1.5$，$L_z = 1.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例4（Matérn 更高平滑度和更长相关性）：Matérn 型 $B$，其中 $\\nu = 3.0$，$L_z = 2.0\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 0.25\\,\\text{K}^2$。\n- 案例5（Matérn 大观测误差）：Matérn 型 $B$，其中 $\\nu = 1.5$，$L_z = 1.5\\,\\text{km}$，$\\sigma_b^2 = 1.0\\,\\text{K}^2$，以及对角阵 $R$，其中 $\\sigma_y^2 = 4.0\\,\\text{K}^2$。\n\n你的程序必须：\n- 使用 $B$、$K$ 和 $R$ 实现根据推导得出的 $A$ 的公式。\n- 如上所定义，为五个案例中的每一个计算有效垂直分辨率宽度的中位数，单位为公里。\n- 最终数值答案以公里为单位表示，并四舍五入到三位小数。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[w_1,w_2,w_3,w_4,w_5]$），其中每个 $w_k$ 是案例 $k$ 的中位数宽度，单位为公里。\n\n不允许用户输入或外部文件；所有常量和参数均已指定。角度未出现，因此不需要角度单位。百分比未出现，因此不需要百分比格式。该问题专注于与卫星红外辐射数据的反问题和数据同化相一致的纯数学和算法推导。",
            "solution": "起点是线性高斯数据同化框架，其中状态 $x \\in \\mathbb{R}^n$ 和观测 $y \\in \\mathbb{R}^m$ 满足 $y = K x + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, R)$。背景态 $x_b$ 是一个先验估计，其误差为 $e_b = x - x_b \\sim \\mathcal{N}(0, B)$。在这些假设下，最小化期望平方估计误差的分析场 $x_a$ 是线性最小方差估计器，它可以通过对联合高斯后验进行配方法，或等效地通过使用线性观测算子的标准 Kalman 滤波分析获得。\n\n分析增量由下式给出\n$$x_a - x_b = G \\left(y - K x_b\\right),$$\n其中增益 $G \\in \\mathbb{R}^{n \\times m}$ 为\n$$G = B K^\\top \\left(K B K^\\top + R\\right)^{-1}.$$\n该表达式源于对二次型 $(x - x_b)^\\top B^{-1} (x - x_b) + (y - K x)^\\top R^{-1} (y - K x)$ 关于 $x$ 进行最小化，得到正规方程 $(B^{-1} + K^\\top R^{-1} K) x = B^{-1} x_b + K^\\top R^{-1} y$，再经过代数操作和应用矩阵求逆引理后，得到解 $x_a = x_b + G (y - K x_b)$。\n\n分析场 $x_a$ 对真实状态 $x$ 的敏感度由平均核矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 捕捉，该矩阵定义为雅可比矩阵 $\\frac{\\partial x_a}{\\partial x}$。在线性设置 $y = K x + \\varepsilon$ 中，对 $x_a$ 关于 $x$ 求导得到\n$$\\frac{\\partial x_a}{\\partial x} = G K.$$\n结合 $G$ 的表达式，平均核为\n$$A = B K^\\top \\left(K B K^\\top + R\\right)^{-1} K.$$\n在为 $K$ 选择的归一化下，该矩阵是无量纲的，并编码了分析场固有的垂直平滑：$A$ 的第 $i$ 行给出了真实廓线分量对高度层 $z_i$ 处的分析场做出贡献的权重。\n\n为量化垂直分辨率，我们需要一个逐层的标量宽度度量，以反映每个平均核行在其中心周围的集中程度。由于平均核行可能具有振荡或变号结构，我们从行的绝对值构造非负权重以避免抵消：\n- 对于第 $i$ 行 $a_i \\in \\mathbb{R}^n$，定义 $u_{i,p} = \\frac{|a_{i,p}|}{\\sum_{q=0}^{n-1} |a_{i,q}|}$。\n- 质心为 $\\bar{z}_i = \\sum_{p=0}^{n-1} u_{i,p} z_p$。\n- 二阶中心矩为 $M_i = \\sum_{p=0}^{n-1} u_{i,p} (z_p - \\bar{z}_i)^2$。\n- 有效宽度为 $W_i = 2 \\sqrt{M_i}$，单位为公里。因子 $2$ 对应于两倍标准差宽度，这是一个不假设高斯性但能随展宽变化的稳健度量。\n\n我们从汇总统计中排除满足 $\\sum_p |a_{i,p}| \\le 10^{-12}$ 的高度层（数值上可忽略的敏感度）。如果没有高度层剩下，该度量默认为整个网格跨度 $z_{n-1} - z_0$。\n\n数值构建细节：\n- 垂直网格 $z_i$ 从 $0\\,\\text{km}$ 到 $15\\,\\text{km}$ 均匀分布，有 $n = 31$ 个点，$\\Delta z = 0.5\\,\\text{km}$。\n- 权重函数 $w_j(z)$ 是高斯函数，中心为 $z_{c,j} \\in \\{1, 3, 5, 7, 9, 12\\}\\,\\text{km}$，展宽为 $\\sigma_w = 0.8\\,\\text{km}$。每行 $K_{j,\\cdot}$ 通过 $K_{j,i} = \\frac{w_j(z_i)\\,\\Delta z}{\\sum_p w_j(z_p)\\,\\Delta z}$ 进行归一化，使其积分为1。\n- 背景协方差 $B$ 使用指数核 $B_{ij} = \\sigma_b^2 \\exp\\left(-\\frac{|z_i - z_j|}{L_z}\\right)$（平稳、正定）或 Matérn 核构建\n$$B_{ij} = \\begin{cases}\n\\sigma_b^2,  i = j, \\\\\n\\sigma_b^2 \\dfrac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\dfrac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right)^\\nu K_\\nu\\left(\\dfrac{\\sqrt{2\\nu}\\,|z_i - z_j|}{L_z}\\right),  i \\ne j,\n\\end{cases}$$\n后者对于 $\\nu > 0$ 也是平稳和正定的。对角线元素 $B_{ii}=\\sigma_b^2$ 匹配了零间距处的正确方差（Matérn 极限）。\n- 观测误差协方差为 $R = \\operatorname{diag}(\\sigma_y^2, \\dots, \\sigma_y^2)$。\n\n每个测试案例的算法步骤：\n1. 在指定的网格上构建 $K$。\n2. 使用所选的核类型和参数 $(\\sigma_b^2, L_z, \\nu)$ 构建 $B$。\n3. 使用 $\\sigma_y^2$ 构建 $R$。\n4. 计算 $S = K B K^\\top + R$，然后求解 $S X = K$ 得到 $X$。\n5. 计算 $A = B K^\\top X$。\n6. 对于每个高度层 $i$，使用绝对值归一化的行权重和二阶中心矩计算 $W_i$；排除敏感度可忽略的高度层。\n7. 报告 $\\{W_i\\}$ 的中位数，单位为公里，四舍五入到三位小数。\n\n定性预期：\n- $B$ 中较大的相关长度 $L_z$ 会加宽背景相关性，通常会增加平均核的宽度，从而降低垂直分辨率（即 $W_i$ 更大）。\n- Matérn 核中更高的平滑度 $\\nu$ 会产生更平滑的相关性，对于相同的 $L_z$，与指数核相比，通常会加宽平均核。\n- 较大的观测误差方差 $\\sigma_y^2$ 会增加对背景的依赖，这倾向于加宽 $A$ 并增加宽度度量，同样表明分辨率降低。\n\n程序精确地实现了这些计算，并输出一行，其中包含五个用逗号分隔的浮点数，单位为公里，每个对应一个测试案例，并用方括号括起来。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import kv as besselk, gamma\n\ndef build_vertical_grid(n=31, zmin=0.0, zmax=15.0):\n    z = np.linspace(zmin, zmax, n)\n    dz = z[1] - z[0]\n    return z, dz\n\ndef build_K(z, centers, sigma_w, dz):\n    m = len(centers)\n    n = len(z)\n    K = np.zeros((m, n))\n    for j, zc in enumerate(centers):\n        w = np.exp(-0.5 * ((z - zc) / sigma_w) ** 2)\n        w_int = w * dz\n        s = np.sum(w_int)\n        if s == 0.0:\n            # Avoid division by zero; unlikely with positive Gaussian\n            K[j, :] = 0.0\n        else:\n            K[j, :] = w_int / s\n    return K\n\ndef build_B_exponential(z, sigma_b2, Lz):\n    # Exponential kernel: B_ij = sigma_b2 * exp(-|z_i - z_j| / Lz)\n    D = np.abs(z[:, None] - z[None, :])\n    B = sigma_b2 * np.exp(-D / Lz)\n    return B\n\ndef build_B_matern(z, sigma_b2, Lz, nu):\n    # Matérn kernel:\n    # For i != j:\n    # B_ij = sigma_b2 * (2^(1-nu) / Gamma(nu)) * (sqrt(2nu) h / Lz)^nu * K_nu(sqrt(2nu) h / Lz)\n    # For i == j: B_ii = sigma_b2\n    D = np.abs(z[:, None] - z[None, :])\n    B = np.zeros_like(D)\n    # Diagonal\n    np.fill_diagonal(B, sigma_b2)\n    # Off-diagonal\n    mask = D > 0\n    h = D[mask]\n    arg = np.sqrt(2.0 * nu) * h / Lz\n    const = sigma_b2 * (2.0 ** (1.0 - nu)) / gamma(nu)\n    # besselk(nu, arg) is modified Bessel function of the second kind\n    B[mask] = const * (arg ** nu) * besselk(nu, arg)\n    return B\n\ndef build_R(m, sigma_y2):\n    return np.eye(m) * sigma_y2\n\ndef averaging_kernel(B, K, R):\n    # Compute A = B K^T (K B K^T + R)^{-1} K\n    S = K @ B @ K.T + R\n    # Solve S X = K for X\n    X = np.linalg.solve(S, K)\n    A = B @ K.T @ X\n    return A\n\ndef effective_resolution(A, z, eps=1e-12):\n    widths = []\n    for i in range(A.shape[0]):\n        row = A[i, :]\n        w = np.abs(row)\n        s = np.sum(w)\n        if s = eps:\n            continue\n        wn = w / s\n        zbar = np.sum(wn * z)\n        var = np.sum(wn * (z - zbar) ** 2)\n        width = 2.0 * np.sqrt(var)\n        widths.append(width)\n    if len(widths) == 0:\n        return float(z[-1] - z[0])\n    return float(np.median(np.array(widths)))\n\ndef run_case(case_type, params, z, dz, K):\n    sigma_b2 = params[\"sigma_b2\"]\n    sigma_y2 = params[\"sigma_y2\"]\n    if case_type == \"exp\":\n        Lz = params[\"Lz\"]\n        B = build_B_exponential(z, sigma_b2, Lz)\n    elif case_type == \"matern\":\n        Lz = params[\"Lz\"]\n        nu = params[\"nu\"]\n        B = build_B_matern(z, sigma_b2, Lz, nu)\n    else:\n        raise ValueError(\"Unknown case type\")\n    R = build_R(K.shape[0], sigma_y2)\n    A = averaging_kernel(B, K, R)\n    width = effective_resolution(A, z)\n    return width\n\ndef solve():\n    # Grid and weighting functions setup\n    z, dz = build_vertical_grid(n=31, zmin=0.0, zmax=15.0)\n    centers = [1.0, 3.0, 5.0, 7.0, 9.0, 12.0]\n    sigma_w = 0.8\n    K = build_K(z, centers, sigma_w, dz)\n\n    # Define test cases\n    test_cases = [\n        (\"exp\", {\"Lz\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),          # Case 1\n        (\"exp\", {\"Lz\": 0.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),          # Case 2\n        (\"matern\", {\"Lz\": 1.5, \"nu\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),  # Case 3\n        (\"matern\", {\"Lz\": 2.0, \"nu\": 3.0, \"sigma_b2\": 1.0, \"sigma_y2\": 0.25}),  # Case 4\n        (\"matern\", {\"Lz\": 1.5, \"nu\": 1.5, \"sigma_b2\": 1.0, \"sigma_y2\": 4.0}),   # Case 5\n    ]\n\n    results = []\n    for case_type, params in test_cases:\n        width = run_case(case_type, params, z, dz, K)\n        results.append(f\"{width:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}