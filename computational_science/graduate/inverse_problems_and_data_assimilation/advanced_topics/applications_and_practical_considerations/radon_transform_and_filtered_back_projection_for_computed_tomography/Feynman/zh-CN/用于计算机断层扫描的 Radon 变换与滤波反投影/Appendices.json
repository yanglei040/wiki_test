{
    "hands_on_practices": [
        {
            "introduction": "在将连续的 Radon 变换和重建过程转化为计算机可执行的算法之前，我们必须首先理解离散化采样策略的理论基础。本练习将指导您从第一性原理出发，推导为避免混叠伪影所必须满足的探测器间距和角度步长的采样条件。理解这些以 Nyquist 准则为基础的约束，是设计任何有效的计算机断层扫描（CT）系统的关键第一步。",
            "id": "3416093",
            "problem": "考虑对一个紧支撑物体 $f(x,y)$ 进行平行束二维计算机断层扫描采集，其中当 $x^{2}+y^{2}>R^{2}$ 时 $f(x,y)=0$，且 $R>0$ 是已知的物体支撑半径。令 $p(s,\\theta)$ 表示 $f(x,y)$ 的Radon变换，其中 $s$ 是沿投影线的带符号探测器坐标，$\\theta \\in [0,\\pi)$ 是投影角度。假设采用滤波反投影重建，该方法使用一个在已知角空间频率截止值 $\\omega_{c}>0$（单位：弧度/单位长度）处截断的斜坡滤波器，这意味着投影数据在对 $s$ 进行变换时，在探测器坐标上有效地带限于 $|\\omega|\\leq \\omega_{c}$。\n\n从Radon变换和二维傅里叶变换的定义出发，并引用由Nyquist准则体现的概念上适当的采样要求，推导在所有投影角度 $\\theta$ 和所有径向频率 $|\\omega|\\leq \\omega_{c}$ 下，为避免滤波反投影中出现混叠所需的最大允许探测器单元宽度 $\\Delta s_{\\max}$ 和最大允许角采样步长 $\\Delta \\theta_{\\max}$。最终的探测器单元宽度以毫米表示，最终的角采样步长以弧度表示。以包含 $R$ 和 $\\omega_{c}$ 的两个闭式解析表达式的形式提供您的最终答案。\n\n最终答案必须是一个单行矩阵，其两个条目分别为 $\\Delta s_{\\max}$ 和 $\\Delta \\theta_{\\max}$，矩阵中不包含单位。",
            "solution": "该问题要求推导二维计算机断层扫描系统中为避免混叠所需的最大允许探测器单元宽度 $\\Delta s_{\\max}$ 和最大允许角采样步长 $\\Delta \\theta_{\\max}$。推导将基于应用于正弦图数据 $p(s, \\theta)$ 的空间和角度维度的Nyquist-Shannon采样定理。\n\n待成像的物体 $f(x,y)$ 在半径为 $R>0$ 的圆盘上是紧支撑的，即当 $x^{2}+y^{2}>R^{2}$ 时，$f(x,y)=0$。投影数据 $p(s, \\theta)$ 是 $f(x,y)$ 的线积分，其中 $s$ 是探测器坐标，$\\theta \\in [0, \\pi)$ 是投影角度。重建过程涉及一个在最大角空间频率 $\\omega_c > 0$ 处截断的斜坡滤波器。这意味着对于任何给定的角度 $\\theta$，投影数据 $p(s, \\theta)$ 在空间坐标 $s$ 上有效地带限于频率区间 $[-\\omega_c, \\omega_c]$。\n\n**最大探测器单元宽度 $\\Delta s_{\\max}$ 的推导**\n\n探测器坐标 $s$ 的采样要求由投影 $p(s, \\theta)$ 关于 $s$ 的带宽决定。令 $\\omega$ 为与 $s$ 共轭的角频率变量。问题指出，数据是有效带限的，因此其关于 $s$ 的傅里叶变换（记作 $P(\\omega, \\theta)$）在 $|\\omega| > \\omega_c$ 时为零。因此，信号 $p(s, \\theta)$ 中存在的最大角频率为 $\\omega_{\\max} = \\omega_c$。\n\nNyquist-Shannon采样定理指出，为了完美重构一个带限信号，采样频率必须严格大于其最大频率的两倍。用角频率表示，采样频率 $\\omega_s$ 必须满足 $\\omega_s \\ge 2 \\omega_{\\max}$ 以避免混叠（等号代表极限情况）。\n\n空间域的采样间隔是探测器单元宽度 $\\Delta s$。角采样频率 $\\omega_s$ 与 $\\Delta s$ 的关系为 $\\omega_s = \\frac{2\\pi}{\\Delta s}$。\n\n应用Nyquist准则：\n$$ \\omega_s \\ge 2 \\omega_c $$\n$$ \\frac{2\\pi}{\\Delta s} \\ge 2 \\omega_c $$\n求解 $\\Delta s$，我们得到探测器单元宽度的约束条件：\n$$ \\Delta s \\le \\frac{\\pi}{\\omega_c} $$\n最大允许探测器单元宽度是该不等式的上界。\n$$ \\Delta s_{\\max} = \\frac{\\pi}{\\omega_c} $$\n如果 $\\omega_c$ 的单位是弧度/毫米，那么 $\\Delta s_{\\max}$ 的单位将是毫米，符合要求。\n\n**最大角采样步长 $\\Delta \\theta_{\\max}$ 的推导**\n\n投影角度 $\\theta$ 的采样要求更为精细。它取决于投影数据 $p(s, \\theta)$ 作为 $\\theta$ 的函数变化的速度。这个变化率由物体 $R$ 的空间范围和所考虑的空间频率 $\\omega$ 决定。最快变化，也即最严格的采样要求，发生在最高空间频率 $\\omega_c$ 处，以及位于物体边缘（半径 $R$ 处）的特征上。\n\n我们利用傅里叶切片定理，它将投影的一维傅里叶变换 $P(\\omega, \\theta)$ 与物体的二维傅里叶变换 $F(k_x, k_y)$ 联系起来：\n$$ P(\\omega, \\theta) = F(k_x, k_y) \\quad \\text{其中} \\quad k_x = \\omega \\cos\\theta, \\; k_y = \\omega \\sin\\theta $$\n为了找到信号关于 $\\theta$ 的带宽，我们分析在固定 $\\omega = \\omega_c$ 时 $P(\\omega, \\theta)$ 的行为。“最坏情况”的信号，即随 $\\theta$ 变化最快的信号，对应于一个在其外围具有点状特征的物体。我们可以用一个位于支撑圆盘边缘的delta函数来模拟这种情况，例如，$f(x,y) = \\delta(x-R, y-0)$。\n\n该物体的Radon变换是：\n$$ p(s,\\theta) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\delta(x'-R, y'-0) \\delta(s - x'\\cos\\theta - y'\\sin\\theta) \\,dx'dy' = \\delta(s - R\\cos\\theta) $$\n该投影关于 $s$ 的一维傅里叶变换是：\n$$ P(\\omega, \\theta) = \\int_{-\\infty}^{\\infty} \\delta(s - R\\cos\\theta) e^{-i\\omega s} \\,ds = \\exp(-i\\omega R\\cos\\theta) $$\n我们关心的是在最高径向频率 $\\omega = \\omega_c$ 时，该信号作为 $\\theta$ 的函数的频率成分。令该信号为 $g(\\theta) = P(\\omega_c, \\theta) = \\exp(-i\\omega_c R\\cos\\theta)$。\n\n为了找到 $g(\\theta)$ 的频率成分，我们将其表示为变量 $\\theta$ 的傅里叶级数。我们使用Jacobi-Anger展开式：\n$$ \\exp(iz\\cos\\theta) = \\sum_{n=-\\infty}^{\\infty} i^n J_n(z) e^{in\\theta} $$\n其中 $J_n(z)$ 是第一类 $n$ 阶贝塞尔函数。\n对于我们的信号 $g(\\theta)$，我们令 $z = -\\omega_c R$。展开式为：\n$$ g(\\theta) = \\sum_{n=-\\infty}^{\\infty} i^n J_n(-\\omega_c R) e^{in\\theta} $$\n整数 $n$ 代表级数中每个分量的角频率（谐波数）。贝塞尔函数的一个基本性质是，当 $|n| > |z|$ 时，$J_n(z)$ 的值变得可以忽略不计。这意味着信号 $g(\\theta)$ 在角域上是有效带限的，其最大有效谐波（角频率）为：\n$$ n_{\\max} \\approx |\\omega_c R| = \\omega_c R $$\n这个最大频率 $n_{\\max}$ 代表了在 $2\\pi$ 弧度的角度区间内的振荡次数。为了在对 $\\theta$ 进行采样时避免混叠，Nyquist准则要求在 $2\\pi$ 区间内的采样点数 $N_{2\\pi}$ 必须大于最高频率分量的两倍：$N_{2\\pi} > 2 n_{\\max}$。\n\n采样点数与角采样步长 $\\Delta\\theta$ 的关系为 $N_{2\\pi} = \\frac{2\\pi}{\\Delta\\theta}$。将此关系和 $n_{\\max}$ 代入Nyquist准则：\n$$ \\frac{2\\pi}{\\Delta\\theta} > 2 (\\omega_c R) $$\n求解 $\\Delta\\theta$：\n$$ \\Delta\\theta  \\frac{\\pi}{\\omega_c R} $$\n因此，最大允许角采样步长是其上界：\n$$ \\Delta\\theta_{\\max} = \\frac{\\pi}{\\omega_c R} $$\n该表达式给出的角采样步长单位为弧度，因为乘积 $\\omega_c R$ 是无量纲的（单位为 `(弧度/长度) * 长度 = 弧度`，而弧度本身是无量纲的）。\n\n结合这两个结果，我们得到了探测器间距和投影角度的最大允许采样间隔。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{\\pi}{\\omega_c}  \\frac{\\pi}{\\omega_c R} \\end{pmatrix} } $$"
        },
        {
            "introduction": "在掌握了采样的理论要求后，下一步便是动手实现 Radon 变换及其重要伴随算子——反投影算子的离散版本。本实践将引导您深入研究数值积分和插值等实现细节，并引入“伴随检验”这一强大工具来验证您代码的正确性。这是将连续的数学模型转化为可靠的计算工具的核心环节。",
            "id": "3416112",
            "problem": "您需要实现一个用于平行束二维计算机断层扫描的 Radon 变换及其伴随的全离散模型，以及一个斜坡滤波反投影映射。您将使用此离散模型执行两项验证任务：伴随测试和可微性测试。伴随测试在数值上验证了在指定的内积下，离散反投影是离散 Radon 变换的伴随。可微性测试验证了滤波反投影算子的 Fréchet 可微性。\n\n从以下基础出发：\n- Radon 变换将一个二维的紧支可积图像函数（表示为 $f(\\mathbf{x})$，其中 $\\mathbf{x} \\in \\mathbb{R}^2$）映射到其线积分，这些线积分由角度 $\\theta \\in [0,\\pi)$ 和距原点的有符号距离 $s \\in \\mathbb{R}$ 索引，定义为 $f$ 在直线 $\\{\\mathbf{x} \\in \\mathbb{R}^2 : \\mathbf{x} \\cdot \\boldsymbol{\\nu}(\\theta) = s\\}$ 上的积分，其中 $\\boldsymbol{\\nu}(\\theta) = (\\cos \\theta, \\sin \\theta)$。\n- 滤波反投影将在探测器空间中与斜坡核进行的一维卷积与跨角度的反投影相结合，以从正弦图数据中获得重建。\n- 伴随算子由内积的等式 $\\langle A x, y \\rangle = \\langle x, A^{\\ast} y \\rangle$ 定义，对于相应希尔伯特空间中的所有元素 $x$ 和 $y$，其中 $A^{\\ast}$ 表示 $A$ 的伴随，$\\langle \\cdot, \\cdot \\rangle$ 表示内积。\n\n您必须遵循以下要求实现这些算子的离散近似，不得使用任何闭式反演公式作为捷径：\n\n1. 离散图像网格和坐标。\n   - 在一个大小为 $N \\times N$ 的方形图像网格上工作，该网格表示定义在方形区域 $[-1,1] \\times [-1,1]$ 上的一个紧支函数。\n   - 使用位于坐标 $x_i = -1 + \\left(i + \\tfrac{1}{2}\\right)\\Delta$, $y_j = -1 + \\left(j + \\tfrac{1}{2}\\right)\\Delta$ 的像素中心，其中 $i,j \\in \\{0,\\dots,N-1\\}$，$\\Delta = \\tfrac{2}{N}$。\n\n2. 投影几何和采样。\n   - 使用 $K$ 个投影角度，这些角度在 $[0,\\pi)$ 弧度范围内均匀分布，即 $\\theta_k = \\tfrac{k \\pi}{K}$，其中 $k \\in \\{0,\\dots,K-1\\}$。\n   - 使用 $M$ 个探测器单元，其有符号距离 $s_m$ 均匀分布在 $[-L,L]$ 范围内，其中 $L = \\sqrt{2}$，即 $s_m = -L + \\tfrac{2 L m}{M-1}$，其中 $m \\in \\{0,\\dots,M-1\\}$。\n   - 通过沿线上坐标 $v \\in [-L,L]$ 进行数值积分来近似每个在 $(\\theta_k, s_m)$ 处的线积分，使用 $N_v$ 个等间距样本 $v_n = -L + \\tfrac{2 L n}{N_v-1}$，其中 $n \\in \\{0,\\dots,N_v-1\\}$，步长为 $\\mathrm{d}v = \\tfrac{2 L}{N_v-1}$。\n\n3. 坐标变换和插值。\n   - 使用由 $u = x \\cos \\theta + y \\sin \\theta$ 和 $v = - x \\sin \\theta + y \\cos \\theta$ 定义的旋转坐标系 $(u,v)$。对于固定的角度 $\\theta_k$ 和探测器坐标 $s_m$，该直线由 $u = s_m$ 和 $v \\in [-L,L]$ 参数化。通过 $x = u \\cos \\theta - v \\sin \\theta$ 和 $y = u \\sin \\theta + v \\cos \\theta$ 转换回笛卡尔坐标。\n   - 在图像网格上使用双线性插值来评估网格外的点 $(x,y)$ 处的图像值。仅包括位于图像方形区域 $[-1,1] \\times [-1,1]$ 内的 $(x,y)$ 的贡献。\n   - 通过将 $(\\theta_k, s_m)$ 的每个线积分近似为双线性样本乘以 $\\mathrm{d}v$ 后对 $v_n$ 求和，来定义离散 Radon 变换 $R$。\n\n4. 离散伴随。\n   - 将离散反投影 $B$ 定义为针对 $R$ 所描述的实现，在离散化空间上关于标准欧几里得内积的精确算法转置。也就是说，它必须通过反转累加过程来实现：$R$ 从图像读取并写入正弦图，而 $B$ 必须从正弦图读取并使用相同的双线性权重和相同的 $\\mathrm{d}v$ 因子写入图像。这确保了在精确算术下，当使用下面定义的标准欧几里得内积时，对于所有离散化的 $f$ 和 $y$，$\\langle R f, y \\rangle = \\langle f, B y \\rangle$ 均成立。\n\n5. 内积。\n   - 在图像网格上使用标准欧几里得内积：对于图像 $x,z \\in \\mathbb{R}^{N \\times N}$，$\\langle x,z \\rangle_{\\mathrm{img}} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} x_{ij} z_{ij}$。\n   - 在正弦图上使用标准欧几里得内积：对于正弦图 $p,q \\in \\mathbb{R}^{K \\times M}$，$\\langle p,q \\rangle_{\\mathrm{sin}} = \\sum_{k=0}^{K-1} \\sum_{m=0}^{M-1} p_{km} q_{km}$。\n\n6. 滤波反投影算子。\n   - 定义一个离散斜坡滤波器 $H$，它独立地作用于每个角度的探测器坐标上。具体方法是将每个角度的探测器样本的离散傅里叶变换乘以一个离散斜坡 $|\\omega|$，然后进行逆变换。您可以使用离散傅里叶变换；角度以弧度为单位，不需要物理单位。\n   - 通过 $F(y) = B(H(y))$ 定义滤波反投影映射 $F$。\n\n7. 需要计算的验证任务。\n   - 伴随测试。对于给定的图像 $f$ 和正弦图 $y$，计算相对伴随失配\n     $$E_{\\mathrm{adj}} = \\frac{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} - \\langle f, B y \\rangle_{\\mathrm{img}} \\right|}{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} \\right| + \\left|\\langle f, B y \\rangle_{\\mathrm{img}} \\right| + 10^{-12}}.$$\n   - 可微性测试。对于给定的基准正弦图 $y_0$、一个方向 $v$ 和一个步长 $\\varepsilon$，计算 $F$ 的相对线性化误差：\n     $$E_{\\mathrm{diff}} = \\frac{\\left\\| F(y_0 + \\varepsilon v) - F(y_0) - \\varepsilon F(v) \\right\\|_F}{\\left\\| \\varepsilon F(v) \\right\\|_F + 10^{-16}},$$\n     其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n\n角度必须以弧度为单位。不需要物理单位。\n\n测试套件。您的程序必须使用指定的参数和伪随机种子，为以下三个测试用例中的每一个计算上述两种误差。对于所有随机抽样，请使用零均值和单位方差的独立标准正态随机变量。\n- 用例 A（一般情况）：$N = 32$, $K = 30$, $M = 45$, $N_v = 201$, $\\varepsilon = 10^{-5}$，此用例中所有随机对象的随机种子为 $1$。\n- 用例 B（单角度的边界几何）：$N = 16$, $K = 1$, $M = 23$, $N_v = 121$, $\\varepsilon = 10^{-5}$，此用例中所有随机对象的随机种子为 $2$。\n- 用例 C（更粗糙的采样，非方形尺寸）：$N = 28$, $K = 19$, $M = 29$, $N_v = 151$, $\\varepsilon = 10^{-5}$，此用例中所有随机对象的随机种子为 $3$。\n\n对于每个用例：\n- 对于伴随测试，使用指定的种子生成 $f \\in \\mathbb{R}^{N \\times N}$，并使用相同的种子生成 $y \\in \\mathbb{R}^{K \\times M}$。\n- 对于可微性测试，使用相同的种子和给定参数生成 $y_0 \\in \\mathbb{R}^{K \\times M}$ 和方向 $v \\in \\mathbb{R}^{K \\times M}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$[E_{\\mathrm{adj}}^{A}, E_{\\mathrm{diff}}^{A}, E_{\\mathrm{adj}}^{B}, E_{\\mathrm{diff}}^{B}, E_{\\mathrm{adj}}^{C}, E_{\\mathrm{diff}}^{C}],$$\n其中上标 $A,B,C$ 分别指代用例 A、B 和 C。输出必须是实值浮点数。角度以弧度为单位，输出不需要单位。",
            "solution": "该问题要求实现并验证一个用于二维平行束计算机断层扫描（CT）的离散模型。核心组件是离散 Radon 变换、其伴随（反投影算子）以及斜坡滤波反投影算子。该实现通过一个伴随测试和一个可微性测试进行验证。\n\n连续问题的离散化过程如下。图像由函数 $f(\\mathbf{x})$ 表示，定义在方形区域 $\\mathbf{x} \\in [-1, 1] \\times [-1, 1]$ 上，并在一个 $N \\times N$ 像素的网格上采样。对于 $i,j \\in \\{0, \\dots, N-1\\}$，像素 $(i, j)$ 的中心位于笛卡尔坐标 $(x_i, y_j)$，其中 $x_i = -1 + (i + \\frac{1}{2})\\Delta$ 且 $y_j = -1 + (j + \\frac{1}{2})\\Delta$，像素尺寸为 $\\Delta = \\frac{2}{N}$。正弦图数据在 $K$ 个投影角度 $\\theta_k = \\frac{k \\pi}{K}$（其中 $k \\in \\{0, \\dots, K-1\\}$）和 $M$ 个探测器单元（距原点的有符号距离）$s_m$ 处采样，$s_m$ 在 $[-L, L]$ 内均匀分布，其中 $L = \\sqrt{2}$ 是图像域的半对角线长度。具体来说，$s_m = -L + \\frac{2Lm}{M-1}$，其中 $m \\in \\{0, \\dots, M-1\\}$。\n\n离散 Radon 变换（由算子 $R$ 表示）将一个 $N \\times N$ 的离散图像 $f$ 映射到一个 $K \\times M$ 的正弦图 $p$。正弦图的每个元素 $p_{km}$ 是图像函数沿直线 $\\mathbf{x} \\cdot \\boldsymbol{\\nu}(\\theta_k) = s_m$ 的线积分的近似值，其中 $\\boldsymbol{\\nu}(\\theta_k) = (\\cos \\theta_k, \\sin \\theta_k)$。该直线由坐标 $v \\in [-L, L]$ 参数化，使得直线上的一个点 $\\mathbf{x}$ 由 $\\mathbf{x} = s_m \\boldsymbol{\\nu}(\\theta_k) + v \\boldsymbol{\\nu}(\\theta_k)^{\\perp}$ 给出，其中 $\\boldsymbol{\\nu}(\\theta_k)^{\\perp} = (-\\sin\\theta_k, \\cos\\theta_k)$。该积分通过沿直线的 $N_v$ 个点 $v_n$ 的黎曼和来近似，步长为 $\\mathrm{d}v = \\frac{2L}{N_v-1}$。在沿直线的每个点 $(x(v_n), y(v_n))$，图像值通过离散图像网格上最近的四个像素值进行双线性插值计算。在 $(\\theta_k, s_m)$ 处的正弦图值由下式给出：\n$$\np_{km} = (R f)_{km} \\approx \\sum_{n=0}^{N_v-1} f_{\\text{interp}}(s_m \\cos\\theta_k - v_n \\sin\\theta_k, s_m \\sin\\theta_k + v_n \\cos\\theta_k) \\cdot \\mathrm{d}v\n$$\n其中 $f_{\\text{interp}}$ 代表双线性插值过程。只有当点 $(x,y)$ 位于图像域 $[-1,1]^2$ 内时，其贡献才被包括在内。\n\n反投影算子（由 $B$ 表示）被定义为 Radon 变换算子 $R$ 在图像和正弦图空间上的标准欧几里得内积下的伴随。伴随关系由 $\\langle R f, y \\rangle_{\\mathrm{sin}} = \\langle f, B y \\rangle_{\\mathrm{img}}$ 给出，适用于任何离散图像 $f$ 和正弦图 $y$。此属性决定了 $B$ 的算法实现。算子 $R$ 可以被看作是一个“收集”操作，其中对于每个正弦图点，从图像网格中读取并加权值。因此，伴随算子 $B$ 是一个“散布”或“溅射”操作。对于每个正弦图值 $y_{km}$，其贡献 $y_{km} \\cdot \\mathrm{d}v$ 被沿相同的积分线分布回图像网格。在线上的每个点，该值使用与前向投影中相同的双线性权重分布到最近的四个像素。\n\n滤波反投影算子 $F$ 从其正弦图中重建图像。它由复合 $F(y) = B(H(y))$ 定义，其中 $H$ 是一个斜坡滤波算子。斜坡滤波器 $H$ 独立地作用于正弦图的每一行（即对于每个固定的角度 $\\theta_k$）。它在傅里叶域中实现，方法是对探测器样本应用一维离散傅里叶变换 ($\\mathcal{F}$)，乘以离散斜坡函数 $|\\omega|$，然后应用逆离散傅里叶变换 ($\\mathcal{F}^{-1}$)。频率变量 $\\omega$ 对应于沿探测器坐标 $s$ 的空间频率。对于正弦图的单行 $y_k(s)$ 的操作是 $H(y_k) = \\mathcal{F}^{-1}\\{|\\omega| \\mathcal{F}\\{y_k(s)\\}\\}$。\n\n执行两个验证任务。第一个是伴随测试，它数值上验证了所实现的算子 $R$ 和 $B$ 之间的伴随关系。相对伴随失配，\n$$\nE_{\\mathrm{adj}} = \\frac{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} - \\langle f, B y \\rangle_{\\mathrm{img}} \\right|}{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} \\right| + \\left|\\langle f, B y \\rangle_{\\mathrm{img}} \\right| + 10^{-12}}\n$$\n是为随机生成的 $f$ 和 $y$ 计算的。由于 $B$ 的构造是 $R$ 的精确算法转置，该误差预计在机器浮点精度的数量级。\n\n第二个任务是滤波反投影算子 $F$ 的可微性测试。由于斜坡滤波器 $H$ 和反投影 $B$ 都是线性算子，它们的复合 $F = B \\circ H$ 也是线性的。对于线性算子，Fréchet 导数就是算子本身。这通过计算相对线性化误差来验证：\n$$\nE_{\\mathrm{diff}} = \\frac{\\left\\| F(y_0 + \\varepsilon v) - F(y_0) - \\varepsilon F(v) \\right\\|_F}{\\left\\| \\varepsilon F(v) \\right\\|_F + 10^{-16}}\n$$\n对于一个完美的线性实现，分子 $F(y_0 + \\varepsilon v) - F(y_0) - \\varepsilon F(v) = (F(y_0) + \\varepsilon F(v)) - F(y_0) - \\varepsilon F(v)$ 将为零。因此，$E_{\\mathrm{diff}}$ 也预计接近机器精度，从而证实实现的线性性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a discrete 2D Radon transform model.\n    \"\"\"\n\n    class TomographyModel:\n        \"\"\"\n        Encapsulates the discrete operators for parallel-beam tomography.\n        \"\"\"\n        def __init__(self, N: int, K: int, M: int, N_v: int):\n            self.N, self.K, self.M, self.N_v = N, K, M, N_v\n            \n            self.L = np.sqrt(2.0)\n            self.delta = 2.0 / N\n\n            self.thetas = np.linspace(0, np.pi, K, endpoint=False)\n            self.s_coords = np.linspace(-self.L, self.L, M) if M > 1 else np.array([0.0])\n            self.v_coords = np.linspace(-self.L, self.L, N_v) if N_v > 1 else np.array([0.0])\n            \n            self.dv = (2 * self.L) / (N_v - 1) if N_v > 1 else 2 * self.L\n\n        def _get_pixel_value(self, img: np.ndarray, i: int, j: int) -> float:\n            if 0 = i  self.N and 0 = j  self.N:\n                return img[i, j]\n            return 0.0\n\n        def radon(self, img: np.ndarray) -> np.ndarray:\n            \"\"\"Discrete Radon Transform (Forward Projection).\"\"\"\n            sino = np.zeros((self.K, self.M))\n\n            for k, theta in enumerate(self.thetas):\n                ct, st = np.cos(theta), np.sin(theta)\n                for m, s in enumerate(self.s_coords):\n                    line_integral = 0.0\n                    for v in self.v_coords:\n                        x = s * ct - v * st\n                        y = s * st + v * ct\n\n                        if abs(x) > 1.0 or abs(y) > 1.0:\n                            continue\n\n                        ix = (x + 1.0) / self.delta - 0.5\n                        iy = (y + 1.0) / self.delta - 0.5\n                        \n                        ix0 = int(np.floor(ix))\n                        iy0 = int(np.floor(iy))\n                        \n                        tx = ix - ix0\n                        ty = iy - iy0\n\n                        v00 = self._get_pixel_value(img, iy0, ix0)\n                        v01 = self._get_pixel_value(img, iy0, ix0 + 1)\n                        v10 = self._get_pixel_value(img, iy0 + 1, ix0)\n                        v11 = self._get_pixel_value(img, iy0 + 1, ix0 + 1)\n                        \n                        interp_val = (v00 * (1 - tx) * (1 - ty) +\n                                      v01 * tx * (1 - ty) +\n                                      v10 * (1 - tx) * ty +\n                                      v11 * tx * ty)\n                        \n                        line_integral += interp_val\n                    \n                    sino[k, m] = line_integral * self.dv\n            return sino\n\n        def back_project(self, sino: np.ndarray) -> np.ndarray:\n            \"\"\"Discrete Back-Projection (Adjoint of Radon).\"\"\"\n            recon = np.zeros((self.N, self.N))\n            \n            for k, theta in enumerate(self.thetas):\n                ct, st = np.cos(theta), np.sin(theta)\n                for m, s in enumerate(self.s_coords):\n                    val_to_add = sino[k, m] * self.dv\n                    if val_to_add == 0:\n                        continue\n\n                    for v in self.v_coords:\n                        x = s * ct - v * st\n                        y = s * st + v * ct\n\n                        if abs(x) > 1.0 or abs(y) > 1.0:\n                            continue\n\n                        ix = (x + 1.0) / self.delta - 0.5\n                        iy = (y + 1.0) / self.delta - 0.5\n                        \n                        ix0 = int(np.floor(ix))\n                        iy0 = int(np.floor(iy))\n                        \n                        tx = ix - ix0\n                        ty = iy - iy0\n                        \n                        w00 = (1 - tx) * (1 - ty)\n                        w01 = tx * (1 - ty)\n                        w10 = (1 - tx) * ty\n                        w11 = tx * ty\n\n                        ix1 = ix0 + 1\n                        iy1 = iy0 + 1\n                        \n                        if 0 = iy0  self.N and 0 = ix0  self.N: recon[iy0, ix0] += w00 * val_to_add\n                        if 0 = iy0  self.N and 0 = ix1  self.N: recon[iy0, ix1] += w01 * val_to_add\n                        if 0 = iy1  self.N and 0 = ix0  self.N: recon[iy1, ix0] += w10 * val_to_add\n                        if 0 = iy1  self.N and 0 = ix1  self.N: recon[iy1, ix1] += w11 * val_to_add\n            return recon\n\n        def filter_sinogram(self, sino: np.ndarray) -> np.ndarray:\n            \"\"\"Ramp filtering of the sinogram.\"\"\"\n            if self.M = 1:\n                return np.zeros_like(sino)\n\n            ds = (2 * self.L) / (self.M - 1)\n            omega = np.fft.fftfreq(self.M, d=ds)\n            ramp = np.abs(omega)\n            \n            filtered_sino = np.zeros_like(sino, dtype=float)\n            for k in range(self.K):\n                row_fft = np.fft.fft(sino[k, :])\n                filtered_row_fft = row_fft * ramp\n                filtered_row = np.fft.ifft(filtered_row_fft)\n                filtered_sino[k, :] = np.real(filtered_row)\n                \n            return filtered_sino\n\n        def fbp(self, sino: np.ndarray) -> np.ndarray:\n            \"\"\"Filtered Back-Projection.\"\"\"\n            return self.back_project(self.filter_sinogram(sino))\n\n    test_cases = [\n        {'N': 32, 'K': 30, 'M': 45, 'N_v': 201, 'eps': 1e-5, 'seed': 1},\n        {'N': 16, 'K': 1, 'M': 23, 'N_v': 121, 'eps': 1e-5, 'seed': 2},\n        {'N': 28, 'K': 19, 'M': 29, 'N_v': 151, 'eps': 1e-5, 'seed': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        N, K, M, N_v = case['N'], case['K'], case['M'], case['N_v']\n        eps, seed = case['eps'], case['seed']\n        \n        model = TomographyModel(N, K, M, N_v)\n        rng = np.random.default_rng(seed)\n\n        # 1. Adjoint Test\n        f = rng.standard_normal(size=(N, N))\n        y = rng.standard_normal(size=(K, M))\n        \n        Rf = model.radon(f)\n        By = model.back_project(y)\n        \n        inner_prod_sin = np.sum(Rf * y)\n        inner_prod_img = np.sum(f * By)\n        \n        E_adj_num = np.abs(inner_prod_sin - inner_prod_img)\n        E_adj_den = np.abs(inner_prod_sin) + np.abs(inner_prod_img) + 1e-12\n        E_adj = E_adj_num / E_adj_den\n        results.append(E_adj)\n\n        # 2. Differentiability Test\n        y0 = rng.standard_normal(size=(K, M))\n        v = rng.standard_normal(size=(K, M))\n\n        Fy0 = model.fbp(y0)\n        F_y0_eps_v = model.fbp(y0 + eps * v)\n        Fv = model.fbp(v)\n        \n        numerator = np.linalg.norm(F_y0_eps_v - Fy0 - eps * Fv)\n        denominator = np.linalg.norm(eps * Fv) + 1e-16\n        E_diff = numerator / denominator\n        results.append(E_diff)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的测量总是不可避免地受到噪声的干扰，因此理解这些噪声对最终重建图像的影响至关重要。本练习将建立在滤波反投影（FBP）算法之上，探索不确定性量化这一高级主题。您将学习如何通过重建算子传播测量噪声的统计特性，并使用蒙特卡洛模拟来验证理论预测的像素级不确定性图。",
            "id": "3416055",
            "problem": "给定一个基于 Radon 变换和平行束几何下滤波反投影 (FBP) 的线性图像重建设定。设未知图像是一个定义在方形区域 $[-1,1]\\times[-1,1]$ 上的实值函数 $f(x,y)$。Radon 变换 $R f(\\theta,s)$（在角度 $\\theta$ 和带符号的探测器坐标 $s$ 处）通过对 $f$ 沿垂直于单位方向 $\\boldsymbol{n}(\\theta) = (\\cos\\theta,\\sin\\theta)$ 的直线进行积分来定义：\n$$\nR f(\\theta,s) = \\int_{\\mathbb{R}^2} f(x,y)\\,\\delta\\big(s - x\\cos\\theta - y\\sin\\theta\\big)\\,dx\\,dy,\n$$\n其中 $\\delta(\\cdot)$ 表示 Dirac delta 分布。滤波反投影 (FBP) 通过首先对每个固定的 $\\theta$ 沿 $s$ 方向对 $R f(\\theta,\\cdot)$ 应用一维高通滤波器，然后进行角度反投影，来重建 $f(x,y)$ 的一个近似 $\\hat{f}(x,y)$。在离散设定中，我们在 $[0,\\pi)$（弧度）范围内均匀采样角度 $\\{\\theta_k\\}_{k=0}^{K-1}$，并在 $[-s_{\\max}, s_{\\max}]$ 范围内均匀覆盖探测器坐标 $\\{s_j\\}_{j=0}^{D-1}$。离散化的正弦图是一个数组 $g_{k,j} \\approx R f(\\theta_k, s_j)$。\n\n假设离散化正弦图上存在加性、零均值的高斯测量噪声，其协方差已知。设测量数据为 $m_{k,j} = g_{k,j} + \\eta_{k,j}$，其中 $\\mathbb{E}[\\eta_{k,j}] = 0$，协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{(K D)\\times(K D)}$。从 $m$ 到重建图像 $\\hat{f}$ 的 FBP 映射是线性的，可以写成一个从向量化的正弦图到向量化的图像的单一线性算子。\n\n你的任务是推导、实现并验证 FBP 中的不确定性传播，具体包括：\n- 从第一性原理出发，推导测量协方差 $\\Sigma$ 如何通过 FBP 线性算子传播，从而得到重建图像 $\\hat{f}$ 的逐像素方差图。\n- 实现一个离散 FBP，其沿探测器坐标使用斜坡状高通滤波器，对每个角度使用基于离散傅里叶变换的滤波，并在反投影时使用周期性插值。\n- 通过将已知的测量协方差在已实现的离散 FBP 算子中传播，来预测逐像素方差图。\n- 通过使用独立的高斯噪声实现进行重复的 FBP 重建，并计算每个像素的样本方差，来对照 Monte Carlo 重建结果验证预测的逐像素方差图。使用量化指标比较预测和经验方差图。\n\n所有计算中的角度单位必须是弧度。离散化和几何细节：\n- 使用大小为 $N\\times N$ 的方形图像网格，其中 $N$ 由每个测试用例指定，均匀覆盖坐标 $(x,y)\\in[-1,1]\\times[-1,1]$。\n- 使用 $K$ 个均匀间隔的角度 $\\theta_k = k\\,\\pi/K$，其中 $k\\in\\{0,1,\\dots,K-1\\}$。\n- 使用 $D$ 个探测器样本，覆盖 $[-s_{\\max}, s_{\\max}]$，其中 $s_{\\max} = 1$，均匀间隔为 $\\Delta s = 2 s_{\\max}/(D-1)$。\n- 在将滤波后的投影反投影到像素时，在探测器索引空间中使用周期性插值。\n\n需要使用的噪声模型：\n- 在所有 $(k,j)$ 上独立同分布 (i.i.d.) 的高斯噪声，方差为 $\\sigma^2$。\n- 角度相关的异方差高斯噪声，其方差 $\\sigma_k^2$ 随 $\\theta_k$ 变化，但在固定的 $k$ 下，对所有探测器索引 $j$ 保持不变。\n- 零噪声的边界情况。\n\n你必须使用以下具有固定参数的测试套件：\n- 测试用例 1 (正常路径): $N=32$, $K=18$, $D=64$, $\\sigma^2 = 10^{-4}$, Monte Carlo 重复次数 $M=200$。\n- 测试用例 2 (异方差): $N=32$, $K=18$, $D=64$, 角度相关方差 $\\sigma_k^2 = 10^{-4}\\,\\big(1 + 0.5\\,\\sin\\theta_k\\big)$, Monte Carlo 重复次数 $M=200$。\n- 测试用例 3 (边界情况): $N=32$, $K=18$, $D=64$, $\\sigma^2 = 0$, Monte Carlo 重复次数 $M=50$。\n\n为追求科学真实性，实现一个非平凡的体模 $f(x,y)$（例如，高斯凸起的总和）来为 Monte Carlo 重建生成基准正弦图 $g_{k,j}\\approx R f(\\theta_k,s_j)$。但是，请注意，对于线性 FBP 算子和加性零均值噪声，$\\hat{f}$ 的逐像素方差仅取决于噪声统计和算子，而与体模无关。\n\n你的程序必须：\n- 隐式地构建离散 FBP 算子，并通过该算子传播测量协方差来预测逐像素方差图，避免形成不必要的大型稠密矩阵。\n- 如前所述，通过 Monte Carlo 模拟验证预测结果，为每个测试用例计算两个指标：所有 $N^2$ 个像素上预测和经验逐像素方差之间的均方根差 (RMSD)，以及最大绝对差 (MAXD)。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[\\text{RMSD}_1,\\text{MAXD}_1,\\text{RMSD}_2,\\text{MAXD}_2,\\text{RMSD}_3,\\text{MAXD}_3]$，其中下标对应于测试用例编号。\n\n所有答案均为纯数值。角度必须以弧度为单位，并且没有需要报告的物理单位。最终程序必须是自包含的，并且可以按原样执行。",
            "solution": "本问题要求推导和实现计算机断层扫描中滤波反投影 (FBP) 算法的不确定性传播。我们首先将推导通过线性 FBP 算子传播测量噪声协方差以获得逐像素方差图的理论框架。随后，我们将对照 Monte Carlo 模拟的经验结果来验证这一理论预测。\n\n### 1. 方差传播的理论推导\n\n滤波反投影 (FBP) 算法是一个线性过程。设离散的、测量的正弦图由一个向量化的列向量 $\\mathbf{m} \\in \\mathbb{R}^{KD}$ 表示，其中 $K$ 是投影角度的数量，$D$ 是每个角度的探测器单元数量。类似地，设重建图像由一个向量化的向量 $\\hat{\\mathbf{f}} \\in \\mathbb{R}^{N^2}$ 表示，其中图像大小为 $N \\times N$。FBP 的线性特性允许我们将重建过程表示为矩阵-向量乘积：\n$$\n\\hat{\\mathbf{f}} = \\mathbf{L} \\mathbf{m}\n$$\n其中 $\\mathbf{L} \\in \\mathbb{R}^{N^2 \\times KD}$ 是表示整个 FBP 流程（滤波和反投影）的线性算子。\n\n测量模型被设定为加性、零均值的高斯噪声：\n$$\n\\mathbf{m} = \\mathbf{g} + \\mathbf{\\eta}\n$$\n其中 $\\mathbf{g}$ 是真实的、无噪声的正弦图，$\\mathbf{\\eta}$ 是噪声向量，满足 $\\mathbb{E}[\\mathbf{\\eta}] = \\mathbf{0}$。测量噪声的协方差由矩阵 $\\Sigma_m = \\mathbb{E}[\\mathbf{\\eta}\\mathbf{\\eta}^T] \\in \\mathbb{R}^{KD \\times KD}$ 给出。\n\n重建图像可以表示为真实正弦图和噪声的函数：\n$$\n\\hat{\\mathbf{f}} = \\mathbf{L}(\\mathbf{g} + \\mathbf{\\eta}) = \\mathbf{L}\\mathbf{g} + \\mathbf{L}\\mathbf{\\eta}\n$$\n项 $\\mathbf{L}\\mathbf{g}$ 表示从无噪声数据得到的理想重建，我们可以将其表示为 $\\mathbf{f}_{\\text{ideal}}$。项 $\\mathbf{L}\\mathbf{\\eta}$ 表示重建图像中的噪声分量。重建的期望值为 $\\mathbb{E}[\\hat{\\mathbf{f}}] = \\mathbf{L}\\mathbf{g} + \\mathbf{L}\\mathbb{E}[\\mathbf{\\eta}] = \\mathbf{f}_{\\text{ideal}}$。\n\n重建图像的协方差 $\\Sigma_f \\in \\mathbb{R}^{N^2 \\times N^2}$ 推导如下：\n$$\n\\Sigma_f = \\mathbb{E}\\left[ (\\hat{\\mathbf{f}} - \\mathbb{E}[\\hat{\\mathbf{f}}]) (\\hat{\\mathbf{f}} - \\mathbb{E}[\\hat{\\mathbf{f}}])^T \\right] = \\mathbb{E}\\left[ (\\mathbf{L}\\mathbf{\\eta}) (\\mathbf{L}\\mathbf{\\eta})^T \\right]\n$$\n$$\n\\Sigma_f = \\mathbb{E}\\left[ \\mathbf{L}\\mathbf{\\eta}\\mathbf{\\eta}^T\\mathbf{L}^T \\right] = \\mathbf{L} \\mathbb{E}\\left[\\mathbf{\\eta}\\mathbf{\\eta}^T\\right] \\mathbf{L}^T\n$$\n这得到了线性协方差传播的核心公式：\n$$\n\\Sigma_f = \\mathbf{L} \\Sigma_m \\mathbf{L}^T\n$$\n我们的目标是计算重建的逐像素方差，这对应于图像协方差矩阵 $\\Sigma_f$ 的对角元素。设 $p$ 是向量化图像中像素的索引，范围从 $0$ 到 $N^2-1$。第 $p$ 个像素的方差是 $(\\Sigma_f)_{pp}$。\n\n问题中指定的噪声模型（独立同分布和角度相关）导致测量协方差矩阵 $\\Sigma_m$ 是一个对角矩阵。设 $\\sigma_{k,j}^2$ 是在角度 $\\theta_k$ 和探测器位置 $s_j$ 处的测量方差。则 $\\Sigma_m = \\text{diag}(\\{\\sigma_{k,j}^2\\})$，其中方差的排序与正弦图的向量化方式一致。\n\n第 $p$ 个像素的方差是：\n$$\n\\text{Var}(\\hat{f}_p) = (\\mathbf{L} \\Sigma_m \\mathbf{L}^T)_{pp} = \\sum_{i=0}^{KD-1} \\sum_{j=0}^{KD-1} L_{pi} (\\Sigma_m)_{ij} L_{pj}\n$$\n由于 $\\Sigma_m$ 是对角矩阵，$(\\Sigma_m)_{ij} = \\sigma_i^2 \\delta_{ij}$（使用单个索引 $i$ 代表 $(k,j)$）。该表达式简化为：\n$$\n\\text{Var}(\\hat{f}_p) = \\sum_{i=0}^{KD-1} L_{pi}^2 \\sigma_i^2\n$$\n为清晰起见，恢复使用双索引 $(k,j)$，其中 $i$ 对应于 $(k,j)$：\n$$\n\\text{Var}(\\hat{f}_p) = \\sum_{k=0}^{K-1} \\sum_{j=0}^{D-1} \\left(L_{p, (k,j)}\\right)^2 \\sigma_{k,j}^2\n$$\n其中 $L_{p, (k,j)}$ 是算子 $\\mathbf{L}$ 的元素，它将 $(k,j)$ 处的正弦图值映射到图像像素 $p$。\n\n### 2. 方差预测的算法实现\n\n构建完整的矩阵 $\\mathbf{L}$ 在计算上是不可行的。需要一种更实用的“无矩阵”方法。$\\text{Var}(\\hat{f}_p)$ 的表达式可以从算法上进行解释。令 $\\mathbf{c}_{k,j} = \\mathbf{L}\\boldsymbol{\\delta}_{k,j}$ 为矩阵 $\\mathbf{L}$ 的第 $(k,j)$ 列。这个列向量恰好是将 FBP 算法应用于“delta 正弦图”所获得的重建图像——该正弦图在投影角度 $\\theta_k$ 和探测器位置 $s_j$ 处的值为 1，在其他所有位置均为 0。该向量的元素为 $(c_{k,j})_p = L_{p, (k,j)}$。\n\n将此代入方差公式，像素方差变为对所有正弦图单元的求和：\n$$\n\\text{Var}(\\hat{f}_p) = \\sum_{k=0}^{K-1} \\sum_{j=0}^{D-1} \\sigma_{k,j}^2 \\left( (c_{k,j})_p \\right)^2\n$$\n这个公式提供了一个直接计算整个方差图 $\\mathbf{V}$ 的算法，其中 $V_p = \\text{Var}(\\hat{f}_p)$：\n1. 初始化一个大小为 $N \\times N$ 的方差图 $\\mathbf{V}$，所有元素均为零。\n2. 对每个正弦图单元 $(k,j)$（其中 $k=0, \\dots, K-1$ 且 $j=0, \\dots, D-1$）进行遍历：\n    a. 创建一个大小为 $K \\times D$ 的 delta 正弦图 $\\boldsymbol{\\delta}_{k,j}$。\n    b. 对 $\\boldsymbol{\\delta}_{k,j}$ 应用 FBP 重建算法以获得图像 $\\mathbf{c}_{k,j}$。\n    c. 对该图像进行逐元素平方：$\\mathbf{c}_{k,j} \\odot \\mathbf{c}_{k,j}$。\n    d. 乘以相应的噪声方差 $\\sigma_{k,j}^2$ 并将结果累加到总方差图中：$\\mathbf{V} \\leftarrow \\mathbf{V} + \\sigma_{k,j}^2 (\\mathbf{c}_{k,j} \\odot \\mathbf{c}_{k,j})$。\n\n此过程无需存储算子 $\\mathbf{L}$ 即可计算出精确的理论方差图，满足了问题的约束。\n\n### 3. FBP 与 Monte Carlo 验证\n\n实现将包含以下几个部分：\n- **FBP 算法**：一个函数，输入一个 $K \\times D$ 的正弦图，返回一个 $N \\times N$ 的图像。\n    - **滤波**：对 $K$ 个投影中的每一个，应用一个一维高通斜坡滤波器。这可以通过使用快速傅里叶变换 (FFT) 在傅里叶域中高效实现。该滤波器在频率空间中定义为与频率的绝对值成正比，即 $|\\nu|$。\n    - **反投影**：然后将滤波后的投影反投影到图像网格上。对于每个像素 $(x,y)$ 和角度 $\\theta_k$，计算相应的探测器坐标 $s' = x\\cos\\theta_k + y\\sin\\theta_k$。如问题指定，使用在探测器索引上的周期性线性插值来找到 $s'$ 处的滤波投影值。对每个像素，将来自所有角度的贡献相加，最后乘以一个归一化常数（我们使用 $\\pi/(2K)$）。\n- **方差预测**：实现第 2 节中推导的算法，该算法会重复调用 FBP 函数。\n- **Monte Carlo 验证**：为了验证预测的方差，我们执行 Monte Carlo 模拟。\n    1. 从一个解析体模（高斯函数的和，其 Radon 变换也是高斯函数的和）生成一个无噪声的“基准真相”正弦图 $\\mathbf{g}$。\n    2. 根据指定的噪声协方差 $\\Sigma_m$，生成大量（$M$ 个）独立的噪声实现 $\\mathbf{\\eta}^{(i)}$。\n    3. 对每次实现，创建一个带噪声的正弦图 $\\mathbf{m}^{(i)} = \\mathbf{g} + \\mathbf{\\eta}^{(i)}$。\n    4. 使用相同的 FBP 算法对每个 $\\mathbf{m}^{(i)}$ 进行重建，得到一组 $M$ 个重建图像 $\\{\\hat{\\mathbf{f}}^{(i)}\\}_{i=1}^M$。\n    5. 对每个像素，计算这 $M$ 次重建的样本方差。这会产生一个经验方差图。\n- **比较**：使用均方根差 (RMSD) 和最大绝对差 (MAXD) 作为度量，将理论预测的方差图与 Monte Carlo 模拟得到的经验方差图进行比较。零噪声测试用例作为一个关键的健全性检查，其中预测方差和经验方差都应恒为零。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for FBP uncertainty propagation.\n    \"\"\"\n\n    def get_fbp_reconstruction(sinogram, N, K, D):\n        \"\"\"\n        Performs Filtered Back-Projection (FBP) reconstruction.\n        \n        Args:\n            sinogram (np.ndarray): The input sinogram of shape (K, D).\n            N (int): The side length of the square output image.\n            K (int): The number of projection angles.\n            D (int): The number of detector bins.\n        \n        Returns:\n            np.ndarray: The reconstructed image of shape (N, N).\n        \"\"\"\n        # Define image and sinogram coordinates\n        image_coords = np.linspace(-1.0, 1.0, N)\n        xx, yy = np.meshgrid(image_coords, image_coords)\n        \n        thetas = np.linspace(0.0, np.pi, K, endpoint=False)\n        detector_spacing = 2.0 / (D - 1) if D > 1 else 0\n\n        # Create ramp filter in Fourier domain\n        # A simple |f| filter. Normalization is handled by using the same FBP\n        # for prediction and MC.\n        ramp_filter = np.abs(np.fft.rfftfreq(D))\n        \n        # Filter projections\n        filtered_sinogram = np.zeros_like(sinogram)\n        for i in range(K):\n            projection = sinogram[i, :]\n            projection_fft = np.fft.rfft(projection)\n            filtered_projection_fft = projection_fft * ramp_filter\n            filtered_sinogram[i, :] = np.fft.irfft(filtered_projection_fft, n=D)\n            \n        # Back-project\n        reconstructed_image = np.zeros((N, N), dtype=np.float64)\n        detector_indices = np.arange(D)\n        \n        for i in range(K):\n            theta = thetas[i]\n            # Coordinates in the detector space for each pixel\n            s_coords = xx * np.cos(theta) + yy * np.sin(theta)\n            \n            # Map s_coords to fractional detector indices for interpolation\n            # s = -1 + j * ds => j = (s + 1) / ds\n            if detector_spacing > 0:\n                j_float = (s_coords + 1.0) / detector_spacing\n            else:\n                j_float = np.full((N,N), (D-1)/2.0)\n\n            # Periodic interpolation\n            interpolated_projection = np.interp(\n                j_float.ravel(),\n                detector_indices,\n                filtered_sinogram[i, :],\n                period=D\n            ).reshape(N, N)\n            \n            reconstructed_image += interpolated_projection\n\n        # Normalization constant for FBP\n        reconstructed_image *= np.pi / (2.0 * K)\n            \n        return reconstructed_image\n\n    def predict_variance(noise_variances, N, K, D):\n        \"\"\"\n        Predicts the per-pixel variance map using the derived formula.\n        \n        Args:\n            noise_variances (np.ndarray): Per-measurement variance, shape (K, D).\n            N (int): Image size.\n            K (int): Number of angles.\n            D (int): Number of detector bins.\n        \n        Returns:\n            np.ndarray: The predicted variance map of shape (N, N).\n        \"\"\"\n        total_variance_map = np.zeros((N, N), dtype=np.float64)\n        \n        for k_in in range(K):\n            for j_in in range(D):\n                if noise_variances[k_in, j_in] == 0:\n                    continue\n                \n                # Create a delta sinogram\n                delta_sino = np.zeros((K, D))\n                delta_sino[k_in, j_in] = 1.0\n                \n                # Reconstruct the image from the delta sinogram -> column of L\n                img_c_kj = get_fbp_reconstruction(delta_sino, N, K, D)\n                \n                # Accumulate variance\n                total_variance_map += noise_variances[k_in, j_in] * (img_c_kj ** 2)\n                \n        return total_variance_map\n\n    def create_phantom_sinogram(K, D):\n        \"\"\"\n        Generates a ground-truth sinogram from an analytical phantom.\n        The phantom is a sum of two Gaussian bumps.\n        \n        Args:\n            K (int): Number of angles.\n            D (int): Number of detector bins.\n        \n        Returns:\n            np.ndarray: The ground-truth sinogram of shape (K, D).\n        \"\"\"\n        thetas = np.linspace(0.0, np.pi, K, endpoint=False)\n        s_coords = np.linspace(-1.0, 1.0, D)\n        \n        # Phantom parameters: (Amplitude, x0, y0, sigma)\n        gaussians = [\n            (1.0, 0.3, 0.2, 0.1),\n            (0.5, -0.5, 0.4, 0.08)\n        ]\n        \n        sinogram = np.zeros((K, D))\n        \n        for A, x0, y0, sigma in gaussians:\n            for i, theta in enumerate(thetas):\n                s0_theta = x0 * np.cos(theta) + y0 * np.sin(theta)\n                # Radon transform of an isotropic Gaussian\n                projection = A * np.sqrt(2 * np.pi) * sigma * np.exp(-(s_coords - s0_theta)**2 / (2 * sigma**2))\n                sinogram[i, :] += projection\n\n        return sinogram\n\n    def run_monte_carlo(base_sinogram, noise_variances, M, N, K, D):\n        \"\"\"\n        Runs Monte Carlo simulation to find the empirical variance map.\n        \n        Args:\n            base_sinogram (np.ndarray): Ground-truth sinogram.\n            noise_variances (np.ndarray): Per-measurement variance.\n            M (int): Number of Monte Carlo replicates.\n            N, K, D (int): Geometry parameters.\n        \n        Returns:\n            np.ndarray: The empirical variance map of shape (N, N).\n        \"\"\"\n        if M == 0 or np.all(noise_variances == 0):\n            return np.zeros((N, N))\n\n        reconstructions = np.zeros((M, N, N))\n        noise_stds = np.sqrt(noise_variances)\n        \n        # for reproducible results\n        rng = np.random.default_rng(seed=42)\n\n        for i in range(M):\n            noise = rng.normal(0.0, noise_stds, size=(K, D))\n            noisy_sinogram = base_sinogram + noise\n            reconstructions[i, :, :] = get_fbp_reconstruction(noisy_sinogram, N, K, D)\n            \n        empirical_variance_map = np.var(reconstructions, axis=0, ddof=1)\n        return empirical_variance_map\n\n    test_cases = [\n        # (N, K, D, M, noise_params, case_type)\n        (32, 18, 64, 200, {'sigma_sq': 1e-4}, 'iid'),\n        (32, 18, 64, 200, {}, 'heteroskedastic'),\n        (32, 18, 64, 50,  {'sigma_sq': 0.0}, 'zero_noise')\n    ]\n\n    results = []\n    \n    # Pre-calculate base sinogram\n    base_sinogram = create_phantom_sinogram(test_cases[0][1], test_cases[0][2])\n\n    for N, K, D, M, params, case_type in test_cases:\n        thetas = np.linspace(0.0, np.pi, K, endpoint=False)\n        \n        if case_type == 'iid':\n            noise_variances = np.full((K, D), params['sigma_sq'])\n        elif case_type == 'heteroskedastic':\n            # Angle-dependent variance: sigma_k^2 = 1e-4 * (1 + 0.5 * sin(theta_k))\n            var_k = 1e-4 * (1.0 + 0.5 * np.sin(thetas))\n            noise_variances = np.tile(var_k[:, np.newaxis], (1, D))\n        elif case_type == 'zero_noise':\n            noise_variances = np.full((K, D), params['sigma_sq'])\n\n        # Predict variance\n        predicted_var = predict_variance(noise_variances, N, K, D)\n        \n        # Run Monte Carlo to get empirical variance\n        empirical_var = run_monte_carlo(base_sinogram, noise_variances, M, N, K, D)\n\n        # Calculate metrics\n        diff = predicted_var - empirical_var\n        rmsd = np.sqrt(np.mean(diff**2))\n        maxd = np.max(np.abs(diff))\n        \n        results.extend([rmsd, maxd])\n        \n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}