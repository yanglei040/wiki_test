{
    "hands_on_practices": [
        {
            "introduction": "While electronic structure codes often use complex spherical harmonics $Y_{\\ell}^{m}(\\theta, \\phi)$ for mathematical efficiency, chemists and materials scientists typically visualize and interpret bonding using real-valued cubic harmonics such as $p_x$, $p_y$, and $d_{x^2-y^2}$. This exercise bridges this gap by having you implement the linear transformation from the complex to the real representation. By numerically verifying the shapes and transformation properties of these orbitals under cubic symmetry, you will gain a practical understanding of how the abstract quantum numbers $\\ell$ and $m$ give rise to the familiar orbital shapes and their behavior in a crystal environment .",
            "id": "3433597",
            "problem": "In computational materials science, electronic structure codes typically represent atomic angular basis functions using complex spherical harmonics $Y_{\\ell}^{m}$, where $\\ell$ is the orbital angular momentum quantum number and $m$ is its projection. For analysis under crystal symmetries, it is often necessary to convert these to real cubic harmonics aligned with Cartesian axes, such as the familiar $p$ and $d$ orbitals in a cubic crystal environment. Starting from the separation of variables of the time-independent Schrödinger equation in spherical coordinates, which yields angular solutions as spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ on the unit sphere, implement a post-processing tool that maps the complex spherical harmonics to real cubic harmonics and verifies the mapping both by reproducing expected Cartesian shapes on the unit sphere and by demonstrating the correct degeneracy structure under cubic symmetry operations.\n\nFundamental base:\n- The complex spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ form an orthonormal basis on the unit sphere for fixed $\\ell$, with $m$ ranging from $- \\ell$ to $+\\ell$.\n- Real cubic harmonics are obtained as specific real linear combinations of the complex spherical harmonics for a given $\\ell$, chosen to align with Cartesian polynomial shapes on the unit sphere.\n- Rotations in three-dimensional space act on functions on the sphere by transforming their arguments: a rotation $R$ maps a function $f(x,y,z)$ to $f(R^{-1}\\cdot(x,y,z))$.\n- Under cubic symmetry, the $\\ell = 2$ manifold decomposes into a doublet and a triplet subspace, corresponding to two-dimensional and three-dimensional irreducible representations.\n\nYour program must:\n1. Derive and implement the conversion from complex spherical harmonics $Y_{\\ell}^{m}$, with $\\ell = 1$ and $\\ell = 2$, to the standard real cubic harmonics aligned with Cartesian axes on the unit sphere. Use angles in radians.\n2. Numerically verify that the resulting real cubic harmonics reproduce the expected Cartesian shapes restricted to the unit sphere by computing the correlation coefficient between each computed harmonic $h$ and its target Cartesian polynomial shape $t$:\n   $$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}},$$\n   where $\\Omega_k$ are $N$ sample points uniformly distributed on the unit sphere, with $N$ specified in the test suite. The target shapes on the unit sphere should be taken as $p_x \\sim x$, $p_y \\sim y$, $p_z \\sim z$, $d_{x^2-y^2} \\sim x^2 - y^2$, $d_{xy} \\sim x y$, $d_{xz} \\sim x z$, $d_{yz} \\sim y z$, and $d_{z^2} \\sim 3 z^2 - 1$, all evaluated at $(x,y,z)$ on the unit sphere.\n3. Demonstrate the correct degeneracy structure of the $\\ell = 2$ set under cubic symmetry by constructing the representation of specific cubic rotations on the $d$-orbital basis and showing block structure corresponding to a two-dimensional subspace and a three-dimensional subspace. For each rotation $R$, compute the $5 \\times 5$ representation matrix $C_R$ defined by expanding each rotated basis function in the original basis using the discrete inner product over the sample points. Verify that the off-block mixing between the two-dimensional and three-dimensional subspaces is numerically negligible.\n\nTest suite and parameters:\n- Use three sets of sample sizes:\n  - For $\\ell = 1$ shape verification: $N = 4096$.\n  - For $\\ell = 2$ shape verification: $N = 8192$.\n  - For degeneracy checks: $N = 6000$.\n- Use the following cubic rotations (angles in radians):\n  - $R_z(\\pi/2)$: rotation by $\\pi/2$ about the $z$-axis.\n  - $R_x(\\pi/2)$: rotation by $\\pi/2$ about the $x$-axis.\n  - $R_y(\\pi/2)$: rotation by $\\pi/2$ about the $y$-axis.\n- For each rotation, compute the maximum absolute value of the coefficients in the off-blocks of $C_R$ that mix the two-dimensional subspace $\\{d_{z^2}, d_{x^2-y^2}\\}$ and the three-dimensional subspace $\\{d_{xy}, d_{yz}, d_{xz}\\}$, and report whether this maximum is less than a tolerance $\\epsilon = 10^{-6}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order:\n  - The three correlation coefficients for $\\ell = 1$: $[\\mathrm{corr}(p_x), \\mathrm{corr}(p_y), \\mathrm{corr}(p_z)]$ as floats.\n  - The five correlation coefficients for $\\ell = 2$: $[\\mathrm{corr}(d_{x^2-y^2}), \\mathrm{corr}(d_{xy}), \\mathrm{corr}(d_{xz}), \\mathrm{corr}(d_{yz}), \\mathrm{corr}(d_{z^2})]$ as floats.\n  - Three booleans indicating whether the degeneracy off-block mixing is below $\\epsilon$ for $R_z(\\pi/2)$, $R_x(\\pi/2)$, and $R_y(\\pi/2)$, respectively.\n- For example, the output format should be: $[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{boolean},\\text{boolean},\\text{boolean}]$.",
            "solution": "The problem statement is scientifically sound, well-posed, and provides all necessary information to proceed with a solution. It addresses a standard and important task in computational materials science: the transformation between different representations of atomic orbitals and the verification of their properties.\n\nThe solution is implemented in three stages: first, the derivation and implementation of the real cubic harmonics from complex spherical harmonics for orbital angular momentum quantum numbers $\\ell=1$ and $\\ell=2$. Second, the numerical verification of the correspondence between these computed real harmonics and their well-known Cartesian polynomial forms on the unit sphere. Third, a demonstration of the transformation properties of the $\\ell=2$ harmonics under cubic symmetry operations, which reveals their degenerate subspace structure.\n\n**1. From Complex Spherical to Real Cubic Harmonics**\n\nThe angular part of the time-independent Schrödinger equation for a central potential is solved by the complex spherical harmonics, $Y_{\\ell}^{m}(\\theta, \\phi)$. These functions form an orthonormal basis on the surface of a sphere for a given quantum number $\\ell$, with the magnetic quantum number $m$ ranging from $-\\ell$ to $+\\ell$. They are given by:\n$$Y_{\\ell}^{m}(\\theta, \\phi) = \\sqrt{\\frac{(2\\ell+1)}{4\\pi}\\frac{(\\ell-m)!}{(\\ell+m)!}} P_{\\ell}^{m}(\\cos\\theta) e^{im\\phi}$$\nwhere $P_{\\ell}^{m}$ are the associated Legendre polynomials and the phase factor $e^{im\\phi}$ makes them complex for $m \\neq 0$. The Condon-Shortley phase convention, which includes a factor of $(-1)^m$ for $m>0$, is commonly used and is the standard in `scipy.special.sph_harm`. A key property under this convention is $Y_{\\ell}^{-m} = (-1)^m (Y_{\\ell}^{m})^*$, where $*$ denotes complex conjugation.\n\nWhile $Y_{\\ell}^{m}$ are eigenfunctions of the $L_z$ operator, they are not convenient for visualizing electron density in Cartesian space, as chemical bonds align with axes. Real-valued harmonics are constructed via linear combinations of $Y_{\\ell}^{m}$ and $Y_{\\ell}^{-m}$ that eliminate the imaginary parts. The real cubic harmonics are a specific set of such real orbitals chosen to transform according to the irreducible representations of the cubic point group, matching the familiar shapes of $p$- and $d$-orbitals.\n\nFor a given $\\ell$ and $m > 0$, two real, orthonormal functions can be formed:\n$$u_{\\ell,m} \\propto \\Re(Y_{\\ell}^{m})$$\n$$v_{\\ell,m} \\propto \\Im(Y_{\\ell}^{m})$$\nFor $m=0$, $Y_{\\ell}^{0}$ is already real. We select specific combinations and signs to match the conventional Cartesian polynomial forms $x, y, z, xy, yz, xz, x^2-y^2, 3z^2-1$, evaluated on the unit sphere ($r=1$). Using the `scipy` implementation of $Y_{\\ell}^{m}$, the following definitions yield functions that correlate positively with the target polynomials:\nFor $\\ell=1$ ($p$-orbitals):\n- $p_z = Y_1^0 \\propto \\cos\\theta \\equiv z$\n- $p_x = -\\sqrt{2} \\Re(Y_1^1) \\propto \\sin\\theta\\cos\\phi \\equiv x$\n- $p_y = -\\sqrt{2} \\Im(Y_1^1) \\propto \\sin\\theta\\sin\\phi \\equiv y$\n\nFor $\\ell=2$ ($d$-orbitals):\n- $d_{z^2} = Y_2^0 \\propto 3\\cos^2\\theta-1 \\equiv 3z^2-1$\n- $d_{x^2-y^2} = \\sqrt{2} \\Re(Y_2^2) \\propto \\sin^2\\theta\\cos(2\\phi) \\equiv x^2-y^2$\n- $d_{xy} = \\sqrt{2} \\Im(Y_2^2) \\propto \\sin^2\\theta\\sin(2\\phi) \\equiv 2xy$\n- $d_{xz} = -\\sqrt{2} \\Re(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\cos\\phi \\equiv xz$\n- $d_{yz} = -\\sqrt{2} \\Im(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\sin\\phi \\equiv yz$\n\n**2. Numerical Shape Verification**\n\nTo verify that these constructed functions, $h$, reproduce the target Cartesian polynomial shapes, $t$, we compute their correlation coefficient over a set of $N$ sample points, $\\Omega_k$, uniformly distributed on the unit sphere. For a robust and deterministic sampling, a Fibonacci lattice is employed. The correlation coefficient is defined as the cosine similarity between the vectors of function values evaluated at the sample points:\n$$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}}$$\nA value close to $1.0$ confirms that the computed harmonic has the correct shape and orientation. This check is performed for the $p$-orbitals with $N=4096$ points and for the $d$-orbitals with $N=8192$ points.\n\n**3. Degeneracy Structure under Cubic Symmetry**\n\nThe five $d$-orbitals are degenerate in a spherically symmetric environment but split into distinct sets of degenerate orbitals under the lower symmetry of a crystal. In a cubic crystal field, they split into a two-dimensional doublet, labeled $e_g$ (spanning $\\{d_{z^2}, d_{x^2-y^2}\\}$), and a three-dimensional triplet, labeled $t_{2g}$ (spanning $\\{d_{xy}, d_{yz}, d_{xz}\\}$). This means that any symmetry operation of the cube will only transform an $e_g$ orbital into a linear combination of other $e_g$ orbitals, and likewise for $t_{2g}$ orbitals. There is no mixing between the two subspaces.\n\nWe verify this property computationally. A rotation $R$ acts on a function $f(\\vec{r})$ by transforming its argument: the rotated function is $f'(\\vec{r}) = f(R^{-1}\\vec{r})$. We can express this rotated function $f'_j$ as a linear combination of the original basis functions $\\{f_i\\}$:\n$$f'_j = \\sum_{i} (C_R)_{ij} f_i$$\nThe matrix $C_R$ is the representation of the rotation $R$ in the basis $\\{f_i\\}$. Its coefficients are found by projecting $f'_j$ onto each $f_i$ using a discrete inner product over $N=6000$ sample points: $\\langle g, h \\rangle = \\sum_k g(\\Omega_k)h(\\Omega_k)$. This leads to the matrix equation $B = G C_R$, where $G_{im} = \\langle f_i, f_m \\rangle$ is the Gram matrix and $B_{ij} = \\langle f_i, f'_j \\rangle$. The representation is then $C_R = G^{-1}B$.\n\nFor our basis ordered as $\\{d_{z^2}, d_{x^2-y^2}, d_{xy}, d_{yz}, d_{xz}\\}$, the matrix $C_R$ should be block-diagonal, with a $2 \\times 2$ block for the $e_g$ subspace and a $3 \\times 3$ block for the $t_{2g}$ subspace.\n$$ C_R \\approx \\begin{pmatrix}\nC_{e_g} & \\mathbf{0}_{2\\times3} \\\\\n\\mathbf{0}_{3\\times2} & C_{t_{2g}}\n\\end{pmatrix} $$\nWe compute $C_R$ for rotations of $\\pi/2$ about the $x$, $y$, and $z$ axes. We then find the maximum absolute value of the elements in the off-diagonal blocks (the $2 \\times 3$ and $3 \\times 2$ zero-blocks) and verify that this value is numerically negligible (less than a tolerance $\\epsilon = 10^{-6}$), confirming the expected degeneracy structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef solve():\n    \"\"\"\n    Main function to perform all calculations and print the finale result.\n    \"\"\"\n    \n    # ------------------ Helper Functions ------------------\n    \n    def get_fibonacci_sphere_points(n_points):\n        \"\"\"\n        Generates uniformly distributed points on a unit sphere using a Fibonacci lattice.\n        \n        Args:\n            n_points (int): The number of points to generate.\n            \n        Returns:\n            tuple: Arrays for (theta, phi, x, y, z) coordinates of the points.\n        \"\"\"\n        indices = np.arange(0, n_points, dtype=float) + 0.5\n        \n        # Golden ratio\n        phi_const = (1 + np.sqrt(5)) / 2\n        \n        # Spherical coordinates\n        theta = np.arccos(1 - 2 * indices / n_points)\n        phi = (2 * np.pi * indices / phi_const) % (2 * np.pi)\n        \n        # Cartesian coordinates\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        \n        return theta, phi, x, y, z\n\n    def get_real_harmonics(l_val, theta, phi):\n        \"\"\"\n        Calculates real cubic harmonics from complex spherical harmonics.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            theta (np.ndarray): Array of polar angles.\n            phi (np.ndarray): Array of azimuthal angles.\n            \n        Returns:\n            dict: A dictionary mapping orbital names to their evaluated values.\n        \"\"\"\n        Y = {}\n        for m_val in range(-l_val, l_val + 1):\n            Y[m_val] = sph_harm(m_val, l_val, phi, theta)\n            \n        real_harmonics = {}\n        if l_val == 1:\n            real_harmonics['px'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['py'] = -np.sqrt(2) * Y[1].imag\n            real_harmonics['pz'] = Y[0].real\n        elif l_val == 2:\n            # Order for correlation check: d_x2-y2, d_xy, d_xz, d_yz, d_z2\n            real_harmonics['d_z2'] = Y[0].real\n            real_harmonics['d_x2-y2'] = np.sqrt(2) * Y[2].real\n            real_harmonics['d_xy'] = np.sqrt(2) * Y[2].imag\n            real_harmonics['d_xz'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['d_yz'] = -np.sqrt(2) * Y[1].imag\n        return real_harmonics\n\n    def get_target_polynomials(l_val, x, y, z):\n        \"\"\"\n        Evaluates the target Cartesian polynomial shapes on the unit sphere.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            x, y, z (np.ndarray): Cartesian coordinates of sample points.\n            \n        Returns:\n            dict: A dictionary mapping target names to their evaluated values.\n        \"\"\"\n        targets = {}\n        if l_val == 1:\n            targets['px'] = x\n            targets['py'] = y\n            targets['pz'] = z\n        elif l_val == 2:\n            targets['d_z2'] = 3 * z**2 - 1\n            targets['d_x2-y2'] = x**2 - y**2\n            targets['d_xy'] = x * y\n            targets['d_xz'] = x * z\n            targets['d_yz'] = y * z\n        return targets\n\n    def calculate_correlation(h, t):\n        \"\"\"\n        Computes the correlation coefficient between two vectors of function values.\n        \n        Args:\n            h (np.ndarray): Values of the computed harmonic.\n            t (np.ndarray): Values of the target polynomial.\n            \n        Returns:\n            float: The correlation coefficient.\n        \"\"\"\n        return np.dot(h, t) / (np.linalg.norm(h) * np.linalg.norm(t))\n\n    def get_rotation_matrix(axis, angle):\n        \"\"\"\n        Constructs a 3D rotation matrix.\n        \n        Args:\n            axis (str): The axis of rotation ('x', 'y', or 'z').\n            angle (float): The angle of rotation in radians.\n        \n        Returns:\n            np.ndarray: The 3x3 rotation matrix.\n        \"\"\"\n        c, s = np.cos(angle), np.sin(angle)\n        if axis == 'x':\n            return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        elif axis == 'y':\n            return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        elif axis == 'z':\n            return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def cartesian_to_spherical(x, y, z):\n        \"\"\"\n        Converts Cartesian coordinates to spherical coordinates (ignoring radius).\n        \n        Args:\n            x, y, z (np.ndarray): Cartesian coordinate arrays.\n        \n        Returns:\n            tuple: Arrays for (theta, phi) angles.\n        \"\"\"\n        theta = np.arccos(np.clip(z, -1.0, 1.0))\n        phi = np.arctan2(y, x)\n        return theta, phi\n\n    # ------------------ Main Logic ------------------\n\n    results = []\n    \n    # Part 1: l=1 Shape Verification\n    N1 = 4096\n    theta1, phi1, x1, y1, z1 = get_fibonacci_sphere_points(N1)\n    real_harmonics_l1 = get_real_harmonics(1, theta1, phi1)\n    target_polys_l1 = get_target_polynomials(1, x1, y1, z1)\n    \n    p_orbitals_order = ['px', 'py', 'pz']\n    for orbital in p_orbitals_order:\n        corr = calculate_correlation(real_harmonics_l1[orbital], target_polys_l1[orbital])\n        results.append(corr)\n\n    # Part 2: l=2 Shape Verification\n    N2 = 8192\n    theta2, phi2, x2, y2, z2 = get_fibonacci_sphere_points(N2)\n    real_harmonics_l2 = get_real_harmonics(2, theta2, phi2)\n    target_polys_l2 = get_target_polynomials(2, x2, y2, z2)\n    \n    d_orbitals_corr_order = ['d_x2-y2', 'd_xy', 'd_xz', 'd_yz', 'd_z2']\n    for orbital in d_orbitals_corr_order:\n        corr = calculate_correlation(real_harmonics_l2[orbital], target_polys_l2[orbital])\n        results.append(corr)\n\n    # Part 3: l=2 Degeneracy Structure Verification\n    N3 = 6000\n    TOLERANCE = 1e-6\n    theta3, phi3, x3, y3, z3 = get_fibonacci_sphere_points(N3)\n    \n    # Basis order for degeneracy check: e_g {d_z2, d_x2-y2}, t_2g {d_xy, d_yz, d_xz}\n    d_degen_order = ['d_z2', 'd_x2-y2', 'd_xy', 'd_yz', 'd_xz']\n    harmonics_l2_degen = get_real_harmonics(2, theta3, phi3)\n    \n    f_basis = np.array([harmonics_l2_degen[orb] for orb in d_degen_order]).T\n\n    # Gram matrix G = F^T F\n    G = f_basis.T @ f_basis\n    G_inv = np.linalg.inv(G)\n\n    initial_coords = np.vstack([x3, y3, z3])\n\n    rot_matrices = {\n        'Rz': get_rotation_matrix('z', np.pi/2),\n        'Rx': get_rotation_matrix('x', np.pi/2),\n        'Ry': get_rotation_matrix('y', np.pi/2),\n    }\n\n    for R_matrix in rot_matrices.values():\n        R_inv = R_matrix.T\n        rotated_coords = R_inv @ initial_coords\n        rx, ry, rz = rotated_coords[0,:], rotated_coords[1,:], rotated_coords[2,:]\n        \n        r_theta, r_phi = cartesian_to_spherical(rx, ry, rz)\n        \n        rot_d_harmonics = get_real_harmonics(2, r_theta, r_phi)\n        f_prime_basis = np.array([rot_d_harmonics[orb] for orb in d_degen_order]).T\n\n        # Matrix B = F^T F'\n        B = f_basis.T @ f_prime_basis\n        \n        # Representation matrix C_R = G^-1 B\n        C_R = G_inv @ B\n\n        # Check off-block elements\n        off_block_eg_t2g = C_R[0:2, 2:5]\n        off_block_t2g_eg = C_R[2:5, 0:2]\n\n        max_off_diag = max(np.abs(off_block_eg_t2g).max(), np.abs(off_block_t2g_eg).max())\n        results.append(max_off_diag < TOLERANCE)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A primary task in computational materials science is to analyze and interpret the nature of electronic states, particularly localized states arising from defects or interfaces. This practice demonstrates how to quantify the angular momentum character of a given wavefunction by projecting it onto an atomic orbital basis. Leveraging the orthonormality of spherical harmonics, you will decompose a model defect state into its constituent $(\\ell, m)$ components, revealing its underlying $s, p,$ or $d$ character. This exercise  provides a powerful tool for wavefunction analysis and shows how an external stimulus like pressure can be used to tune the electronic structure of a material.",
            "id": "3433580",
            "problem": "In computational materials science, localized electronic states near point defects in wide-band-gap oxides can be characterized by their angular momentum content when expanded in an atomic-like basis. Assume a single-particle Kohn–Sham (KS) defect state, localized around the defect site, is probed within a chosen spherical region of radius $R$ centered on the defect. The angular dependence of the state can be represented in the spherical harmonic basis $Y_{\\ell m}(\\theta,\\phi)$, while the radial component is modeled with pressure-dependent decaying functions. Use the orthonormality of spherical harmonics as the fundamental base and the separation of variables of the time-independent Schrödinger equation in spherical coordinates to derive a projection scheme that identifies the dominant local $(\\ell,m)$ character of the defect state inside the sphere and tracks its evolution under hydrostatic pressure.\n\nYou are given a synthetic but physically motivated model wavefunction inside the sphere:\n$$\n\\psi(\\mathbf{r};P) \\equiv \\psi(r,\\theta,\\phi;P) = \\sum_{\\ell=0}^{2} A_{\\ell 0}(P)\\, f_{\\ell}(r;P)\\, Y_{\\ell 0}(\\theta,\\phi),\n$$\nwith only $m=0$ components retained to represent a symmetry-preserving defect along the $z$ axis. The radial functions are\n$$\nf_0(r;P) = N_0(P)\\, e^{-r/a(P)},\\quad\nf_1(r;P) = N_1(P)\\, r\\, e^{-r/a(P)},\\quad\nf_2(r;P) = N_2(P)\\, r^2\\, e^{-r/a(P)},\n$$\nwhere the pressure-dependent decay length is\n$$\na(P) = \\frac{a_0}{1+\\beta P}.\n$$\nTake $a_0 = 1.5$ angstrom and $\\beta = 0.02$ per gigapascal so that $P$ is in gigapascal and $a(P)$ is in angstrom. The normalization constants $N_{\\ell}(P)$ are chosen so that the radial measure integrates to unity over all space for each channel,\n$$\n\\int_{0}^{\\infty} r^2\\, f_{\\ell}(r;P)\\, dr = 1,\n$$\nwhich implies\n$$\nN_0(P) = \\frac{1}{2\\,a(P)^3},\\quad N_1(P) = \\frac{1}{6\\,a(P)^4},\\quad N_2(P) = \\frac{1}{24\\,a(P)^5}.\n$$\nThe unnormalized pressure-dependent angular amplitudes are\n$$\n\\tilde{A}_{00}(P) = \\cos\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{10}(P) = \\sin\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{20}(P) = \\gamma \\max(P,0),\n$$\nwith\n$$\n\\theta(P) = \\theta_0 + k P,\\quad \\theta_0 = \\frac{\\pi}{8},\\quad k = \\frac{\\pi}{90},\\quad \\gamma = 0.03,\n$$\nwhere angles are in radians and pressure $P$ is in gigapascal. The amplitudes are then normalized to unit norm,\n$$\nA_{\\ell 0}(P) = \\frac{\\tilde{A}_{\\ell 0}(P)}{\\sqrt{\\sum_{\\ell'=0}^{2} \\tilde{A}_{\\ell' 0}(P)^2}}.\n$$\n\nStarting from the orthonormality of spherical harmonics,\n$$\n\\int Y_{\\ell m}^{*}(\\theta,\\phi)\\, Y_{\\ell' m'}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{m m'},\n$$\nderive the expression for the projection coefficient inside a finite sphere of radius $R$,\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 \\sin\\theta\\, d\\theta\\, d\\phi\\, dr,\n$$\nand show how it reduces to a product of an angular amplitude and a radial integral due to the orthonormality in angle. For the given $f_{\\ell}$, compute the radial accumulation factors\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr,\n$$\nand use them to evaluate\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P).\n$$\nDefine the channel weights inside the sphere as\n$$\nw_{\\ell 0}(R,P) = \\frac{\\left|C_{\\ell 0}(R,P)\\right|^2}{\\sum_{\\ell'=0}^{2}\\left|C_{\\ell' 0}(R,P)\\right|^2}.\n$$\nYour task is to implement a program that, for each specified test case $(R,P)$, computes the normalized weights $w_{00}(R,P)$, $w_{10}(R,P)$, $w_{20}(R,P)$ and identifies the dominant $(\\ell,m)$ channel by maximum weight. Round the reported weights to $6$ decimal places. Report the dominant pair as integers $(\\ell,m)$.\n\nPhysical units: input pressures $P$ are in gigapascal and radii $R$ are in angstrom. The computed weights are dimensionless.\n\nAngle unit: radians must be used for all trigonometric functions.\n\nTest suite to cover diverse conditions:\n- Case $1$: $R=4.0$ angstrom, $P=0$ gigapascal.\n- Case $2$: $R=4.0$ angstrom, $P=10$ gigapascal.\n- Case $3$: $R=4.0$ angstrom, $P=20$ gigapascal.\n- Case $4$: $R=2.0$ angstrom, $P=10$ gigapascal.\n- Case $5$: $R=4.0$ angstrom, $P=-5$ gigapascal.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is a list of the form $[\\ell_{\\mathrm{dom}},m_{\\mathrm{dom}},w_{00},w_{10},w_{20}]$ with the weights in the order $[\\ell=0,\\ell=1,\\ell=2]$. For example, a valid output format is\n$[[0,0,0.750000,0.200000,0.050000],[\\dots],\\dots]$.",
            "solution": "The problem statement has been critically validated and is deemed to be self-contained, scientifically grounded, and well-posed. All provided data, definitions, and constraints are consistent and physically meaningful within the context of computational materials science and quantum mechanics. The task is to derive and implement a projection scheme to analyze a model defect-state wavefunction.\n\n### Derivation of the Projection Coefficient $C_{\\ell 0}(R,P)$\n\nThe projection coefficient, $C_{\\ell 0}(R,P)$, quantifies the contribution of the $(\\ell, m=0)$ angular momentum channel to the total wavefunction, $\\psi(\\mathbf{r};P)$, within a sphere of radius $R$. It is defined by the inner product of the wavefunction with the corresponding spherical harmonic, $Y_{\\ell 0}(\\theta,\\phi)$, integrated over the volume of the sphere.\n\nThe definition is given as:\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\nwhere the differential solid angle is $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$.\n\nThe model wavefunction provided is a linear combination of basis functions, each being a product of a radial part $f_{\\ell'}(r;P)$ and an angular part $Y_{\\ell' 0}(\\theta,\\phi)$:\n$$\n\\psi(r,\\theta,\\phi;P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi)\n$$\nSubstituting this expression for $\\psi$ into the definition of $C_{\\ell 0}(R,P)$:\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\left( \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi) \\right) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\nSince the integral and sum operators are linear, their order can be interchanged. The coefficients $A_{\\ell' 0}(P)$ and the radial functions $f_{\\ell'}(r;P)$ are independent of the angular variables $(\\theta,\\phi)$ and can be factored out of the angular integral:\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\left( \\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega \\right) dr\n$$\nThe core of the derivation rests on the orthonormality property of the spherical harmonics:\n$$\n\\int_{\\Omega} Y_{\\ell' m'}(\\theta,\\phi) Y_{\\ell m}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{mm'}\n$$\nIn our case, $m=m'=0$, so the integral simplifies to:\n$$\n\\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\n$$\n(Note that for $m=0$, the spherical harmonics are real, so $Y_{\\ell 0}^{*} = Y_{\\ell 0}$.)\n\nSubstituting the Kronecker delta $\\delta_{\\ell\\ell'}$ back into the expression for $C_{\\ell 0}(R,P)$:\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\delta_{\\ell\\ell'} dr\n$$\nThe Kronecker delta is non-zero (equal to $1$) only when $\\ell'=\\ell$. This property collapses the summation over $\\ell'$ to a single term corresponding to the specific $\\ell$ of the projection:\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\int_{0}^{R} f_{\\ell}(r;P)\\, r^2 dr\n$$\nThe remaining integral is precisely the definition of the radial accumulation factor, $S_{\\ell}(R,P)$:\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr\n$$\nThus, we arrive at the final expression for the projection coefficient, which separates the angular and radial contributions:\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P)\n$$\nThis demonstrates that the projection operation effectively isolates the channel-specific amplitude $A_{\\ell 0}(P)$ and weights it by the fraction of the radial density $r^2|f_\\ell(r;P)|$ contained within the sphere of radius $R$.\n\n### Derivation of the Radial Accumulation Factors $S_{\\ell}(R,P)$\n\nThe radial accumulation factor $S_{\\ell}(R,P)$ for each channel $\\ell \\in \\{0, 1, 2\\}$ must be calculated. The radial functions are $f_0(r;P) = N_0(P) e^{-r/a(P)}$, $f_1(r;P) = N_1(P) r e^{-r/a(P)}$, and $f_2(r;P) = N_2(P) r^2 e^{-r/a(P)}$.\nLet's introduce the variable $x = r/a(P)$, where $a(P)$ is the pressure-dependent decay length. The integral for $S_{\\ell}(R,P)$ can be expressed in terms of $x$.\n\nFor $\\ell=0$:\n$$S_0(R,P) = \\int_{0}^{R} r^2 N_0(P) e^{-r/a(P)} dr = N_0(P) \\int_{0}^{R} r^2 e^{-r/a(P)} dr$$\nWith $N_0(P) = 1/(2a(P)^3)$ and substituting $r=xa(P)$, $dr=a(P)dx$:\n$$S_0(R,P) = \\frac{1}{2a(P)^3} \\int_{0}^{R/a(P)} (xa(P))^2 e^{-x} a(P)dx = \\frac{1}{2} \\int_{0}^{R/a(P)} x^2 e^{-x} dx$$\nThis integral is related to the lower incomplete gamma function, $\\gamma(s,z) = \\int_0^z t^{s-1}e^{-t}dt$. Here, $s=3$ and $z=R/a(P)$. The integral is $\\gamma(3, R/a(P))$. The corresponding regularized lower incomplete gamma function is $P(s,z) = \\gamma(s,z)/\\Gamma(s)$. Since $\\Gamma(3)=2! = 2$, we have $S_0(R,P) = P(3, R/a(P))$.\n\nSimilarly, for $\\ell=1$ and $\\ell=2$, we integrate $r^3$ and $r^4$ respectively:\n$$S_1(R,P) = \\frac{1}{6} \\int_{0}^{R/a(P)} x^3 e^{-x} dx = \\frac{\\gamma(4, R/a(P))}{\\Gamma(4)} = P(4, R/a(P))$$\n$$S_2(R,P) = \\frac{1}{24} \\int_{0}^{R/a(P)} x^4 e^{-x} dx = \\frac{\\gamma(5, R/a(P))}{\\Gamma(5)} = P(5, R/a(P))$$\nFor integer $s$, $P(s,z) = 1 - e^{-z}\\sum_{k=0}^{s-1} \\frac{z^k}{k!}$. Letting $z=R/a(P)$, we obtain the explicit formulas:\n$$S_0(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2}\\right)$$\n$$S_1(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}\\right)$$\n$$S_2(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)$$\nThese formulas can be implemented directly or by using a standard library function for the regularized incomplete gamma function.\n\n### Computational Strategy\n\nThe overall algorithm to compute the channel weights for a given pair of inputs $(R,P)$ is as follows:\n1.  Define the physical constants $a_0=1.5$, $\\beta=0.02$, $\\theta_0=\\pi/8$, $k=\\pi/90$, and $\\gamma=0.03$.\n2.  Calculate the pressure-dependent decay length $a(P) = a_0 / (1+\\beta P)$.\n3.  Calculate the pressure-dependent angle $\\theta(P) = \\theta_0 + kP$.\n4.  Compute the unnormalized angular amplitudes: $\\tilde{A}_{00}(P) = \\cos(\\theta(P))$, $\\tilde{A}_{10}(P) = \\sin(\\theta(P))$, and $\\tilde{A}_{20}(P) = \\gamma \\max(P,0)$.\n5.  Normalize the amplitudes: $A_{\\ell 0}(P) = \\tilde{A}_{\\ell 0}(P) / \\sqrt{\\sum_{\\ell'} \\tilde{A}_{\\ell' 0}(P)^2}$.\n6.  Calculate the dimensionless variable $z = R/a(P)$.\n7.  Compute the radial accumulation factors $S_0(R,P)$, $S_1(R,P)$, and $S_2(R,P)$ using the formulas derived above (or equivalent library functions).\n8.  Calculate the projection coefficients $C_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\times S_{\\ell}(R,P)$ for $\\ell \\in \\{0, 1, 2\\}$.\n9.  Compute the squared magnitudes of the coefficients, $|C_{\\ell 0}(R,P)|^2$.\n10. Calculate the channel weights $w_{\\ell 0}(R,P) = |C_{\\ell 0}(R,P)|^2 / \\sum_{\\ell'} |C_{\\ell' 0}(R,P)|^2$.\n11. Identify the dominant channel $(\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}})$ by finding the index $\\ell$ that maximizes the weight $w_{\\ell 0}$. The magnetic quantum number $m$ is fixed at $m_{\\mathrm{dom}}=0$.\n12. Format the results as requested: $[\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}}, w_{00}, w_{10}, w_{20}]$, with weights rounded to $6$ decimal places.\n\nThis procedure will be implemented for each test case specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammainc\n\ndef solve():\n    \"\"\"\n    Computes and identifies the dominant angular momentum channel for a model\n    defect state under varying pressure and analysis radius.\n    \"\"\"\n    \n    # Define physical constants and parameters from the problem statement.\n    a0 = 1.5      # angstrom\n    beta = 0.02   # per GPa\n    theta0 = np.pi / 8.0\n    k = np.pi / 90.0\n    gamma = 0.03\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R in angstrom, P in gigapascal)\n        (4.0, 0.0),\n        (4.0, 10.0),\n        (4.0, 20.0),\n        (2.0, 10.0),\n        (4.0, -5.0),\n    ]\n\n    results_str = []\n    for R, P in test_cases:\n        # Step 1: Calculate pressure-dependent parameters\n        a_P = a0 / (1.0 + beta * P)\n        theta_P = theta0 + k * P\n\n        # Step 2: Calculate unnormalized angular amplitudes\n        A_tilde_00 = np.cos(theta_P)\n        A_tilde_10 = np.sin(theta_P)\n        A_tilde_20 = gamma * max(P, 0.0)\n        \n        # Step 3: Normalize the angular amplitudes\n        amplitudes_tilde = np.array([A_tilde_00, A_tilde_10, A_tilde_20])\n        norm_A = np.sqrt(np.sum(np.square(amplitudes_tilde)))\n        amplitudes_A = amplitudes_tilde / norm_A if norm_A > 0 else np.zeros(3)\n\n        # Step 4: Calculate radial accumulation factors S_l(R,P)\n        # These are regularized lower incomplete gamma functions P(s, z)\n        # where s = l + n + 1 and z = R/a(P).\n        # For f_l(r) ~ r^l, the integral is over r^2 * f_l(r) ~ r^(l+2).\n        # So we have integrals over r^2, r^3, r^4 corresponding to s=3,4,5.\n        z = R / a_P\n        S_factors = np.array([\n            gammainc(3, z),  # S_0(R,P) for l=0\n            gammainc(4, z),  # S_1(R,P) for l=1\n            gammainc(5, z)   # S_2(R,P) for l=2\n        ])\n\n        # Step 5: Calculate projection coefficients C_l0(R,P)\n        coeffs_C = amplitudes_A * S_factors\n\n        # Step 6: Calculate channel weights w_l0(R,P)\n        squared_C = np.square(coeffs_C)\n        sum_squared_C = np.sum(squared_C)\n        \n        if sum_squared_C > 1e-12: # Avoid division by zero\n            weights = squared_C / sum_squared_C\n        else:\n            weights = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0]) # Degenerate case, e.g. R=0\n\n        w00, w10, w20 = weights\n        \n        # Step 7: Identify the dominant channel\n        l_dom = np.argmax(weights)\n        m_dom = 0\n        \n        # Step 8: Format the output for the current case\n        result_str = f\"[{l_dom},{m_dom},{w00:.6f},{w10:.6f},{w20:.6f}]\"\n        results_str.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of modern electronic structure methods, such as the Projector-Augmented Wave (PAW) method, depends critically on the completeness of the local basis sets used within atomic augmentation spheres. This exercise explores the convergence of calculated properties, like total energy and forces, with respect to the angular momentum cutoff, $l_{\\max}$, of this local expansion. The core principle is that the interaction energy arises from multipole interactions, and truncating the basis at a low $l_{\\max}$ introduces a tangible error by neglecting higher-order terms. By performing this convergence study , you will develop an essential skill: the ability to critically assess and validate the numerical parameters that control the accuracy of your simulations.",
            "id": "3433593",
            "problem": "A computational materials science calculation using an augmented basis inside a spherical region approximates the all-electron density by a truncated series of spherical harmonics. Consider an augmentation sphere of radius $R$ centered at the origin whose localized pseudo-density is modeled as a finite spherical harmonic expansion,\n$$\n\\rho(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{L_{\\text{tot}}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi),\n$$\nwhere $r$ is the radial coordinate, $\\theta$ is the polar angle, and $\\phi$ is the azimuthal angle (all angles measured in radians). The functions $Y_{l}^{m}(\\theta,\\phi)$ denote real-valued spherical harmonics constructed from the complex spherical harmonics by taking $\\sqrt{2}\\,\\mathrm{Re}\\{Y_{l}^{m}\\}$ for $m>0$, $\\sqrt{2}\\,\\mathrm{Im}\\{Y_{l}^{|m|}\\}$ for $m<0$, and $Y_{l}^{0}$ for $m=0$. The coefficients $a_{l m}$ are real constants. In a convergence study of the augmentation sphere’s angular momentum cutoff $l_{\\max}$, one freezes the plane-wave cutoff and the $\\mathbf{k}$-mesh and varies only $l_{\\max}$, which truncates the density to\n$$\n\\rho^{(l_{\\max})}(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{l_{\\max}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi).\n$$\n\nThe total energy contribution from the augmentation sphere under an externally imposed analytic potential $V_{\\text{ext}}(\\mathbf{r})$ is defined by\n$$\nE\\left[l_{\\max}\\right] \\equiv \\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr,\n$$\nand the corresponding force vector is\n$$\n\\mathbf{F}\\left[l_{\\max}\\right] \\equiv -\\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, \\nabla V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr.\n$$\n\nYour objective is to design and implement a convergence study that isolates the effect of the augmentation sphere’s $l_{\\max}$ on $E\\left[l_{\\max}\\right]$ and $\\mathbf{F}\\left[l_{\\max}\\right]$ by freezing all other numerical parameters (plane-wave cutoff and $\\mathbf{k}$-mesh are conceptually fixed and do not enter the computation). Interpret the residual errors as arising from missing multipole moments $Y_{l}^{m}(\\hat{\\mathbf{r}})$ beyond the chosen $l_{\\max}$.\n\nUse the following fixed, scientifically plausible parameter set for the model:\n- Augmentation sphere radius $R = 1.5$.\n- Radial decay parameter $\\alpha = 3.0$.\n- Nonzero real spherical harmonic coefficients $a_{l m}$ given for the subset $\\{(l,m)\\}$:\n  - $(0,0): a_{00} = 1.0$,\n  - $(1,0): a_{10} = 0.6$, $(1,1): a_{11} = 0.3$,\n  - $(2,0): a_{20} = 0.4$, $(2,2): a_{22} = 0.25$,\n  - $(3,0): a_{30} = 0.35$, $(3,3): a_{33} = 0.20$,\n  - $(4,0): a_{40} = 0.30$,\n  - $(5,0): a_{50} = 0.25$.\n- External potential is a finite combination of solid harmonics (polynomials in Cartesian coordinates $(x,y,z)$ with $x = r\\sin\\theta\\cos\\phi$, $y = r\\sin\\theta\\sin\\phi$, $z = r\\cos\\theta$):\n  $$\n  V_{\\text{ext}}(\\mathbf{r}) = A_{1}\\, z + A_{2}\\, \\left(3 z^{2} - r^{2}\\right) + A_{3}\\, xyz + A_{4}\\, \\left(x^{3} - 3 x y^{2}\\right) + A_{5}\\, \\left(35 z^{4} - 30 z^{2} r^{2} + 3 r^{4}\\right) + A_{6}\\, \\left(x^{5} - 10 x^{3} y^{2} + 5 x y^{4}\\right),\n  $$\n  with fixed amplitudes $A_{1} = 0.2$, $A_{2} = 0.05$, $A_{3} = 0.01$, $A_{4} = 0.02$, $A_{5} = 0.005$, $A_{6} = 0.003$.\n\nThe program must compute $E\\left[l_{\\max}\\right]$ and $\\mathbf{F}\\left[l_{\\max}\\right]$ by numerical integration over the sphere using separable quadrature:\n- Radial integral over $r \\in [0,R]$ using Gauss–Legendre quadrature with $N_{r}$ points.\n- Polar integral via the substitution $u = \\cos\\theta \\in [-1,1]$ using Gauss–Legendre quadrature with $N_{\\theta}$ points, so that $r^{2}\\sin\\theta\\, d\\theta$ becomes $r^{2}\\, du$.\n- Azimuthal integral over $\\phi \\in [0,2\\pi)$ using a uniform $N_{\\phi}$-point trapezoidal rule.\n\nSet $N_{r} = 48$, $N_{\\theta} = 48$, and $N_{\\phi} = 48$.\n\nLet the fully converged reference correspond to $L_{\\text{tot}} = 5$. For each $l_{\\max}$ in the given test suite, compute the truncated energy $E\\left[l_{\\max}\\right]$ and force $\\mathbf{F}\\left[l_{\\max}\\right]$, and report the residual errors defined by\n$$\n\\Delta E\\left[l_{\\max}\\right] \\equiv E\\left[L_{\\text{tot}}\\right] - E\\left[l_{\\max}\\right], \\quad\n\\Delta F\\left[l_{\\max}\\right] \\equiv \\left\\|\\mathbf{F}\\left[L_{\\text{tot}}\\right] - \\mathbf{F}\\left[l_{\\max}\\right]\\right\\|_{2}.\n$$\n\nInterpretation requirement: The program design must make clear, through the selection of $V_{\\text{ext}}(\\mathbf{r})$ and the angular structure of $\\rho(r,\\theta,\\phi)$, that any nonzero $\\Delta E\\left[l_{\\max}\\right]$ and $\\Delta F\\left[l_{\\max}\\right]$ arise from omitted multipole components $Y_{l}^{m}$ with $l > l_{\\max}$ that couple to the corresponding solid harmonic components of $V_{\\text{ext}}(\\mathbf{r})$ or its gradient.\n\nTest suite:\n- Evaluate the residuals for $l_{\\max} \\in \\{0,1,2,3,4,5\\}$.\n\nAngle unit specification: All angular quantities are to be treated in radians.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is a two-element list containing $\\Delta E\\left[l_{\\max}\\right]$ and $\\Delta F\\left[l_{\\max}\\right]$. For example, the printed output must look like\n$$\n\\left[ [\\Delta E(0), \\Delta F(0)], [\\Delta E(1), \\Delta F(1)], \\dots, [\\Delta E(5), \\Delta F(5)] \\right].\n$$\nNo physical units are required; treat all reported values as dimensionless model quantities.",
            "solution": "The user wants me to solve a computational problem.\n\n### **Problem Validation**\n\nI will begin by validating the problem statement as per the required protocol.\n\n#### **Step 1: Extract Givens**\n\n*   **Pseudo-density model ($\\rho$)**:\n    $$\n    \\rho(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{L_{\\text{tot}}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi)\n    $$\n    with $L_{\\text{tot}} = 5$. The $Y_{l}^{m}$ are real-valued spherical harmonics.\n*   **Truncated pseudo-density ($\\rho^{(l_{\\max})}$)**:\n    $$\n    \\rho^{(l_{\\max})}(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{l_{\\max}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi)\n    $$\n*   **Energy ($E$) and Force ($\\mathbf{F}$)**:\n    $$\n    E\\left[l_{\\max}\\right] \\equiv \\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr\n    $$\n    $$\n    \\mathbf{F}\\left[l_{\\max}\\right] \\equiv -\\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, \\nabla V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr\n    $$\n*   **Residual Errors ($\\Delta E, \\Delta F$)**:\n    $$\n    \\Delta E\\left[l_{\\max}\\right] \\equiv E\\left[L_{\\text{tot}}\\right] - E\\left[l_{\\max}\\right]\n    $$\n    $$\n    \\Delta F\\left[l_{\\max}\\right] \\equiv \\left\\|\\mathbf{F}\\left[L_{\\text{tot}}\\right] - \\mathbf{F}\\left[l_{\\max}\\right]\\right\\|_{2}\n    $$\n*   **Model Parameters**:\n    *   Augmentation radius: $R = 1.5$.\n    *   Radial decay parameter: $\\alpha = 3.0$.\n    *   Nonzero coefficients $a_{l m}$: $\\{(0,0): 1.0; (1,0): 0.6; (1,1): 0.3; (2,0): 0.4; (2,2): 0.25; (3,0): 0.35; (3,3): 0.20; (4,0): 0.30; (5,0): 0.25\\}$.\n*   **External Potential ($V_{\\text{ext}}$)**:\n    $$\n    V_{\\text{ext}}(\\mathbf{r}) = A_{1}z + A_{2}(3z^{2}-r^{2}) + A_{3}xyz + A_{4}(x^{3}-3xy^{2}) + A_{5}(35z^{4}-30z^{2}r^{2}+3r^{4}) + A_{6}(x^{5}-10x^{3}y^{2}+5xy^{4})\n    $$\n    *   Amplitudes: $A_{1}=0.2, A_{2}=0.05, A_{3}=0.01, A_{4}=0.02, A_{5}=0.005, A_{6}=0.003$.\n*   **Numerical Integration**:\n    *   Radial ($r \\in [0,R]$): $N_{r}=48$ point Gauss–Legendre quadrature.\n    *   Polar ($u=\\cos\\theta \\in [-1,1]$): $N_{\\theta}=48$ point Gauss–Legendre quadrature.\n    *   Azimuthal ($\\phi \\in [0,2\\pi)$): $N_{\\phi}=48$ point trapezoidal rule.\n*   **Test Suite**: $l_{\\max} \\in \\{0, 1, 2, 3, 4, 5\\}$.\n*   **Angle Units**: Radians.\n\n#### **Step 2: Validate Using Extracted Givens**\n\n1.  **Scientifically Grounded**: The problem is rooted in standard methods of computational materials science, particularly density functional theory implementations like the Projector-Augmented Wave (PAW) method. The use of spherical harmonic expansions for charge densities and solid harmonics for potentials is fundamental to the field. This is scientifically sound.\n2.  **Well-Posed**: The problem provides all necessary functions, parameters, and numerical procedures to arrive at a unique, computable solution. The task is to evaluate well-defined definite integrals numerically. This is well-posed.\n3.  **Objective**: The problem is stated using precise mathematical definitions and objective language, with no room for subjective interpretation. This is objective.\n4.  **Incomplete or Contradictory Setup**: All constants and functions are fully specified. The definition of real spherical harmonics is provided and is a standard convention. The numerical integration scheme is explicitly described. There are no contradictions.\n5.  **Unrealistic or Infeasible**: The physical parameters are of a plausible magnitude. The computational task, a three-dimensional numerical quadrature on a $48 \\times 48 \\times 48$ grid, is computationally feasible.\n\n#### **Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined, scientifically sound problem in computational physics that can be solved algorithmically. I will proceed with the solution.\n\n### **Solution Design**\n\nThe core of the problem is to compute the energy $E[l_{\\max}]$ and force $\\mathbf{F}[l_{\\max}]$ by numerically integrating the products of the pseudo-density $\\rho^{(l_{\\max})}$ with the potential $V_{\\text{ext}}$ and its gradient $\\nabla V_{\\text{ext}}$, respectively, over a spherical volume. The convergence of these quantities with respect to the angular momentum cutoff $l_{\\max}$ is then analyzed.\n\n#### **1. Mathematical Formulation**\n\nThe integrals for energy and force are defined in spherical coordinates $(r, \\theta, \\phi)$. The volume element is $d\\tau = r^2 \\sin\\theta \\, dr d\\theta d\\phi$. The problem specifies a separable numerical quadrature scheme.\n\n*   **Radial Integral**: For a function $f(r)$ over $[0, R]$, we use Gauss-Legendre quadrature. The standard interval is $[-1, 1]$. A linear mapping $r(t) = \\frac{R}{2}(t+1)$ for $t \\in [-1, 1]$ gives $dr = \\frac{R}{2}dt$. If $\\{t_i, w_i^{\\text{GL}}\\}$ are the standard Gauss-Legendre points and weights, the integral is approximated as:\n    $$\n    \\int_0^R f(r) dr \\approx \\sum_{i=1}^{N_r} f\\left(\\frac{R}{2}(t_i+1)\\right) \\frac{R}{2} w_i^{\\text{GL}}\n    $$\n*   **Polar Integral**: For a function $g(\\theta)$ over $[0, \\pi]$, the specified substitution is $u = \\cos\\theta$, so $du = -\\sin\\theta d\\theta$. The integral becomes $\\int_{-1}^{1} g(\\arccos u) du$. This is directly suitable for Gauss-Legendre quadrature:\n    $$\n    \\int_0^\\pi g(\\theta) \\sin\\theta d\\theta = \\int_{-1}^1 g(\\arccos u) du \\approx \\sum_{j=1}^{N_\\theta} g(\\arccos u_j) w_j^{\\text{GL}}\n    $$\n*   **Azimuthal Integral**: For a function $h(\\phi)$ over $[0, 2\\pi]$, the $N_\\phi$-point trapezoidal rule uses uniform points $\\phi_k = k \\frac{2\\pi}{N_\\phi}$ for $k=0, \\dots, N_\\phi-1$, with constant weight $\\Delta\\phi = \\frac{2\\pi}{N_\\phi}$.\n    $$\n    \\int_0^{2\\pi} h(\\phi) d\\phi \\approx \\sum_{k=0}^{N_\\phi-1} h(\\phi_k) \\Delta\\phi\n    $$\n\nCombining these, a full 3D integral becomes a triple summation over the grid points $(r_i, \\theta_j, \\phi_k)$ with a composite weight.\n$$\n\\text{Integral} \\approx \\sum_{i,j,k} \\text{Integrand}(r_i, \\theta_j, \\phi_k) \\cdot \\left(r_i^2 \\cdot \\left(\\frac{R}{2} w_i^{\\text{GL}}\\right) \\cdot w_j^{\\text{GL}} \\cdot \\left(\\frac{2\\pi}{N_\\phi}\\right)\\right)\n$$\n\n#### **2. Algorithmic Implementation**\n\nA vectorized approach using NumPy will be highly efficient.\n\n1.  **Grid Generation**:\n    *   Generate 1D arrays for the quadrature points and weights for each coordinate:\n        *   `r_pts`, `r_w`: radial points and weights, from transformed Gauss-Legendre.\n        *   `u_pts`, `theta_w`: polar cosines and weights, from Gauss-Legendre. `theta_pts` is $\\arccos(u_{pts})$.\n        *   `phi_pts`, `phi_w`: azimuthal angles and weights, from the trapezoidal rule.\n    *   Create 3D grids for coordinates (`R_grid`, `Theta_grid`, `Phi_grid`) and weights (`Wr_grid`, `Wtheta_grid`, `Wphi_grid`) using `numpy.meshgrid`.\n\n2.  **Function Evaluation on Grid**:\n    *   Compute Cartesian coordinate grids `X`, `Y`, `Z` from the spherical coordinate grids.\n    *   Evaluate $V_{\\text{ext}}$ and its gradient components $(\\partial_x V_{\\text{ext}}, \\partial_y V_{\\text{ext}}, \\partial_z V_{\\text{ext}})$ on the Cartesian grid. The gradient must be derived analytically first.\n        $$ \\nabla V_{\\text{ext}} = \\sum_{k=1}^6 A_k \\nabla(\\text{Term}_k) $$\n        These derivatives are straightforward, albeit tedious, polynomial differentiations.\n    *   Implement a function for real spherical harmonics $Y_l^m(\\theta, \\phi)$ as specified, using `scipy.special.sph_harm` as a backend.\n    *   For each angular momentum shell $l \\in [0, L_{\\text{tot}}]$, calculate its contribution to the density, $\\rho_l(r, \\theta, \\phi) = \\sum_m a_{lm} r^l e^{-\\alpha r} Y_l^m(\\theta, \\phi)$, on the 3D grid. Store these contributions.\n\n3.  **Main Calculation Loop**:\n    *   Loop through $l_{\\max} \\in \\{0, 1, 2, 3, 4, 5\\}$.\n    *   For each $l_{\\max}$, construct the truncated density $\\rho^{(l_{\\max})}$ by summing the pre-calculated contributions $\\rho_l$ for $l=0, \\dots, l_{\\max}$.\n    *   Compute the combined volume element grid `dV_grid = R_grid**2 * Wr_grid * Wtheta_grid * Wphi_grid`.\n    *   Calculate the energy $E[l_{\\max}]$ and force vector $\\mathbf{F}[l_{\\max}]$ via vectorized summation:\n        $$ E[l_{\\max}] = \\sum_{\\text{grid}} \\rho^{(l_{\\max})} \\cdot V_{\\text{ext}} \\cdot dV $$\n        $$ \\mathbf{F}[l_{\\max}] = -\\sum_{\\text{grid}} \\rho^{(l_{\\max})} \\cdot \\nabla V_{\\text{ext}} \\cdot dV $$\n    *   Store the resulting energy (a scalar) and force (a 3-vector) for each $l_{\\max}$.\n\n4.  **Post-processing and Output**:\n    *   After computing for all $l_{\\max}$, the results for $l_{\\max} = L_{\\text{tot}} = 5$ serve as the reference values $E_{\\text{ref}}$ and $\\mathbf{F}_{\\text{ref}}$.\n    *   For each $l_{\\max}$, compute the residuals $\\Delta E = E_{\\text{ref}} - E[l_{\\max}]$ and $\\Delta F = ||\\mathbf{F}_{\\text{ref}} - \\mathbf{F}[l_{\\max}]||_2$.\n    *   Format the list of $[\\Delta E, \\Delta F]$ pairs into the specified string format and print.\n\nThis design directly implements the problem statement while leveraging numerical libraries for efficiency. It correctly interprets the physics of multipole interactions, as the numerical results will demonstrate that the error $\\Delta E[l_{\\max}]$ decreases significantly only when an $l > l_{\\max}$ is included for which both the density coefficient $a_{lm}$ and the potential coefficient $C_{lm}$ are non-zero. A similar logic applies to the force.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm, roots_legendre\n\n# language: Python\n# version: 3.12\n# libraries:\n#     - name: numpy\n#       version: 1.23.5\n#     - name: scipy\n#       version: 1.11.4\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem as specified.\n    \"\"\"\n    # ------------------- GIVENS AND PARAMETERS -------------------\n    R = 1.5\n    ALPHA = 3.0\n    L_TOT = 5\n    TEST_CASES = list(range(L_TOT + 1))\n\n    # Coefficients for the pseudo-density\n    A_COEFFS = {\n        (0, 0): 1.0, (1, 0): 0.6, (1, 1): 0.3, (2, 0): 0.4,\n        (2, 2): 0.25, (3, 0): 0.35, (3, 3): 0.20, (4, 0): 0.30, (5, 0): 0.25\n    }\n\n    # Coefficients for the external potential\n    V_COEFFS = {\n        'A1': 0.2, 'A2': 0.05, 'A3': 0.01,\n        'A4': 0.02, 'A5': 0.005, 'A6': 0.003\n    }\n\n    # Numerical integration grid parameters\n    NR, NTHETA, NPHI = 48, 48, 48\n\n    # ------------------- HELPER FUNCTIONS -------------------\n\n    def real_sph_harm(m, l, phi, theta):\n        \"\"\"\n        Computes real-valued spherical harmonics based on the problem's definition.\n        \"\"\"\n        if m == 0:\n            # sph_harm for m=0 is real, but has a complex dtype.\n            return np.real(sph_harm(0, l, phi, theta))\n        elif m > 0:\n            # Y_{l,m} = sqrt(2) * Re(Y_l^m)\n            return np.sqrt(2.0) * np.real(sph_harm(m, l, phi, theta))\n        else:  # m < 0\n            # Y_{l,m} = sqrt(2) * Im(Y_l^|m|)\n            return np.sqrt(2.0) * np.imag(sph_harm(-m, l, phi, theta))\n\n    def get_V_ext(x, y, z, r_sq):\n        \"\"\"Computes the external potential V_ext on a grid.\"\"\"\n        A = V_COEFFS\n        term1 = A['A1'] * z\n        term2 = A['A2'] * (3 * z**2 - r_sq)\n        term3 = A['A3'] * x * y * z\n        term4 = A['A4'] * (x**3 - 3 * x * y**2)\n        term5 = A['A5'] * (35 * z**4 - 30 * z**2 * r_sq + 3 * r_sq**2)\n        term6 = A['A6'] * (x**5 - 10 * x**3 * y**2 + 5 * x * y**4)\n        return term1 + term2 + term3 + term4 + term5 + term6\n\n    def get_grad_V_ext(x, y, z, r_sq):\n        \"\"\"Computes the gradient of V_ext on a grid.\"\"\"\n        A = V_COEFFS\n        # Term 1: grad(A1*z)\n        grad_v1 = (np.zeros_like(x), np.zeros_like(y), A['A1'] * np.ones_like(z))\n        \n        # Term 2: grad(A2*(3*z^2 - r^2)) = grad(A2*(2*z^2 - x^2 - y^2))\n        grad_v2 = (A['A2'] * (-2 * x), A['A2'] * (-2 * y), A['A2'] * (4 * z))\n        \n        # Term 3: grad(A3*x*y*z)\n        grad_v3 = (A['A3'] * y * z, A['A3'] * x * z, A['A3'] * x * y)\n        \n        # Term 4: grad(A4*(x^3 - 3*x*y^2))\n        grad_v4 = (A['A4'] * (3 * x**2 - 3 * y**2), A['A4'] * (-6 * x * y), np.zeros_like(z))\n        \n        # Term 5: grad(A5*(35*z^4 - 30*z^2*r^2 + 3*r^4))\n        grad_v5_x = A['A5'] * x * (12 * r_sq - 60 * z**2)\n        grad_v5_y = A['A5'] * y * (12 * r_sq - 60 * z**2)\n        grad_v5_z = A['A5'] * (140 * z**3 - 60 * z * r_sq)\n        grad_v5 = (grad_v5_x, grad_v5_y, grad_v5_z)\n        \n        # Term 6: grad(A6*(x^5 - 10*x^3*y^2 + 5*x*y^4))\n        grad_v6_x = A['A6'] * (5 * x**4 - 30 * x**2 * y**2 + 5 * y**4)\n        grad_v6_y = A['A6'] * (-20 * x**3 * y + 20 * x * y**3)\n        grad_v6 = (grad_v6_x, grad_v6_y, np.zeros_like(z))\n\n        grad_vx = grad_v1[0] + grad_v2[0] + grad_v3[0] + grad_v4[0] + grad_v5[0] + grad_v6[0]\n        grad_vy = grad_v1[1] + grad_v2[1] + grad_v3[1] + grad_v4[1] + grad_v5[1] + grad_v6[1]\n        grad_vz = grad_v1[2] + grad_v2[2] + grad_v3[2] + grad_v4[2] + grad_v5[2] + grad_v6[2]\n        \n        return grad_vx, grad_vy, grad_vz\n\n    # ------------------- NUMERICAL GRID SETUP -------------------\n    # Radial grid (Gauss-Legendre on [0, R])\n    t_pts, t_w = roots_legendre(NR)\n    r_pts = R * (t_pts + 1.0) / 2.0\n    r_w = R * t_w / 2.0\n\n    # Polar grid (Gauss-Legendre on u=cos(theta) in [-1, 1])\n    u_pts, u_w = roots_legendre(NTHETA)\n    theta_pts = np.arccos(u_pts)\n\n    # Azimuthal grid (Trapezoidal rule on [0, 2pi])\n    phi_pts = np.linspace(0, 2 * np.pi, NPHI, endpoint=False)\n    phi_w = (2 * np.pi / NPHI) * np.ones(NPHI)\n    \n    # Create 3D grids for coordinates and weights\n    R_grid, Theta_grid, Phi_grid = np.meshgrid(r_pts, theta_pts, phi_pts, indexing='ij')\n    Wr_grid, Wtheta_grid, Wphi_grid = np.meshgrid(r_w, u_w, phi_w, indexing='ij')\n    \n    # Cartesian coordinates on the grid\n    X = R_grid * np.sin(Theta_grid) * np.cos(Phi_grid)\n    Y = R_grid * np.sin(Theta_grid) * np.sin(Phi_grid)\n    Z = R_grid * np.cos(Theta_grid)\n    R_sq_grid = R_grid**2\n\n    # ------------------- PRE-COMPUTATION -------------------\n    # Pre-compute potential and its gradient on the grid\n    V_grid = get_V_ext(X, Y, Z, R_sq_grid)\n    grad_Vx_grid, grad_Vy_grid, grad_Vz_grid = get_grad_V_ext(X, Y, Z, R_sq_grid)\n\n    # Pre-compute density contributions for each l-shell\n    rho_l_contributions = {}\n    for l in range(L_TOT + 1):\n        l_contribution = np.zeros_like(R_grid)\n        if any(key[0] == l for key in A_COEFFS):\n            radial_part = (R_grid**l) * np.exp(-ALPHA * R_grid)\n            for m in range(-l, l + 1):\n                if (l, m) in A_COEFFS:\n                    alm = A_COEFFS[(l, m)]\n                    Ylm_grid = real_sph_harm(m, l, Phi_grid, Theta_grid)\n                    l_contribution += alm * radial_part * Ylm_grid\n        rho_l_contributions[l] = l_contribution\n\n    # ------------------- MAIN CALCULATION -------------------\n    all_results = {}\n    current_rho_grid = np.zeros_like(R_grid)\n    \n    # Differential volume element\n    dV_grid = R_sq_grid * Wr_grid * Wtheta_grid * Wphi_grid\n\n    for l_max in TEST_CASES:\n        # Incrementally build the density\n        current_rho_grid += rho_l_contributions[l_max]\n\n        # Calculate Energy\n        E = np.sum(current_rho_grid * V_grid * dV_grid)\n        \n        # Calculate Force\n        Fx = -np.sum(current_rho_grid * grad_Vx_grid * dV_grid)\n        Fy = -np.sum(current_rho_grid * grad_Vy_grid * dV_grid)\n        Fz = -np.sum(current_rho_grid * grad_Vz_grid * dV_grid)\n        F_vec = np.array([Fx, Fy, Fz])\n        \n        all_results[l_max] = {'E': E, 'F': F_vec}\n\n    # ------------------- POST-PROCESSING AND OUTPUT -------------------\n    E_ref = all_results[L_TOT]['E']\n    F_ref = all_results[L_TOT]['F']\n    \n    output_list = []\n    for l_max in TEST_CASES:\n        dE = E_ref - all_results[l_max]['E']\n        dF_vec = F_ref - all_results[l_max]['F']\n        dF_norm = np.linalg.norm(dF_vec)\n        output_list.append([dE, dF_norm])\n        \n    # Format the final output string exactly as requested\n    formatted_results = [f'[{e[0]:.8e}, {f[0]:.8e}]' for e, f in zip(np.array(output_list), np.array(output_list)[:, 1:])]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}