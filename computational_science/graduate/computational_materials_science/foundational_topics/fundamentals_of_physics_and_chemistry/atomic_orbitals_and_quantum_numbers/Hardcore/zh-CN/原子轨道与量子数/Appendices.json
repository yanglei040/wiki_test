{
    "hands_on_practices": [
        {
            "introduction": "虽然复数球谐函数 $Y_l^m$ 是球坐标下薛定谔方程的自然解，但实数形式的原子轨道（如 $p_x$ 和 $d_{xy}$）在化学和材料科学中对于理解和可视化化学键更为直观。本练习将指导您实现这一关键变换，将抽象的复数球谐函数转换为与笛卡尔轴对齐的实数立方谐函数，并验证其对称性，从而连接数学形式与化学直觉。",
            "id": "3433597",
            "problem": "在计算材料科学中，电子结构代码通常使用复球谐函数 $Y_{\\ell}^{m}$ 来表示原子角向基函数，其中 $\\ell$ 是轨道角动量量子数，$m$ 是其投影。为了在晶体对称性下进行分析，通常需要将这些复球谐函数转换为与笛卡尔坐标轴对齐的实立方谐函数，例如立方晶体环境中的常见 $p$ 和 $d$ 轨道。从球坐标系中不含时薛定谔方程的变量分离出发（该方法在单位球面上产生球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 作为角向解），实现一个后处理工具，将复球谐函数映射到实立方谐函数，并通过以下两种方式验证该映射：一是在单位球面上再现预期的笛卡尔形状，二是在立方对称操作下展示正确的简并结构。\n\n基本原理：\n- 对于固定的 $\\ell$，复球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 在单位球面上构成一个标准正交基，其中 $m$ 的取值范围为 $- \\ell$ 到 $+\\ell$。\n- 实立方谐函数是通过对给定 $\\ell$ 的复球谐函数进行特定的实线性组合得到的，其选择是为了与单位球面上的笛卡爾-多项式形状对齐。\n- 三维空间中的旋转通过变换球面函数的自变量来作用于函数：一个旋转 $R$ 将函数 $f(x,y,z)$ 映射为 $f(R^{-1}\\cdot(x,y,z))$。\n- 在立方对称性下，$\\ell = 2$ 流形分解为一个二重态和一个三重态子空间，分别对应于二维和三维的不可约表示。\n\n您的程序必须：\n1. 推导并实现从复球谐函数 $Y_{\\ell}^{m}$（其中 $\\ell = 1$ 和 $\\ell = 2$）到与单位球面上的笛卡尔坐标轴对齐的标准实立方谐函数的转换。角度使用弧度制。\n2. 通过计算每个计算出的谐函数 $h$ 与其目标笛卡尔-多项式形状 $t$ 之间的相关系数，数值验证所得到的实立方谐函数能够在限制于单位球面上时再现预期的笛卡尔形状：\n   $$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}},$$\n   其中 $\\Omega_k$ 是均匀分布在单位球面上的 $N$ 个采样点， $N$ 在测试套件中指定。单位球面上的目标形状应取为 $p_x \\sim x$、$p_y \\sim y$、$p_z \\sim z$、$d_{x^2-y^2} \\sim x^2 - y^2$、$d_{xy} \\sim x y$、$d_{xz} \\sim x z$、$d_{yz} \\sim y z$ 和 $d_{z^2} \\sim 3 z^2 - 1$，所有这些都在单位球面上的 $(x,y,z)$ 处求值。\n3. 通过在 $d$-轨道基上构建特定立方旋转的表示，并展示对应于一个二维子空间和一个三维子空间的块结构，来证明 $\\ell = 2$ 轨道集在立方对称性下的正确简并结构。对于每次旋转 $R$，计算 $5 \\times 5$ 的表示矩阵 $C_R$。该矩阵通过在采样点上使用离散内积，将每个旋转后的基函数在原始基上展开来定义。验证二维子空间和三维子空间之间的非块区混合在数值上可以忽略不计。\n\n测试套件和参数：\n- 使用三组样本大小：\n  - 对于 $\\ell = 1$ 形状验证：$N = 4096$。\n  - 对于 $\\ell = 2$ 形状验证：$N = 8192$。\n  - 对于简并性检查：$N = 6000$。\n- 使用以下立方旋转（角度单位为弧度）：\n  - $R_z(\\pi/2)$：绕 $z$ 轴旋转 $\\pi/2$。\n  - $R_x(\\pi/2)$：绕 $x$ 轴旋转 $\\pi/2$。\n  - $R_y(\\pi/2)$：绕 $y$ 轴旋转 $\\pi/2$。\n- 对于每次旋转，计算 $C_R$ 中混合二维子空间 $\\{d_{z^2}, d_{x^2-y^2}\\}$ 和三维子空间 $\\{d_{xy}, d_{yz}, d_{xz}\\}$ 的非块区中系数的最大绝对值，并报告该最大值是否小于容差 $\\epsilon = 10^{-6}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含：\n  - $\\ell = 1$ 的三个相关系数：$[\\mathrm{corr}(p_x), \\mathrm{corr}(p_y), \\mathrm{corr}(p_z)]$，格式为浮点数。\n  - $\\ell = 2$ 的五个相关系数：$[\\mathrm{corr}(d_{x^2-y^2}), \\mathrm{corr}(d_{xy}), \\mathrm{corr}(d_{xz}), \\mathrm{corr}(d_{yz}), \\mathrm{corr}(d_{z^2})]$，格式为浮点数。\n  - 三个布尔值，分别表示对于 $R_z(\\pi/2)$、$R_x(\\pi/2)$ 和 $R_y(\\pi/2)$，简并性非块区混合是否低于 $\\epsilon$。\n- 例如，输出格式应为：$[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{boolean},\\text{boolean},\\text{boolean}]$。",
            "solution": "问题陈述在科学上是合理的、定义明确的，并提供了进行求解所需的所有必要信息。它解决的是计算材料科学中的一个标准且重要的任务：原子轨道不同表示之间的转换及其性质的验证。\n\n解决方案分三个阶段实施：首先，针对轨道角动量量子数 $\\ell=1$ 和 $\\ell=2$，从复球谐函数推导并实现实立方谐函数。其次，对计算出的实谐函数与其在单位球面上的著名笛卡尔-多项式形式之间的一致性进行数值验证。第三，展示 $\\ell=2$ 谐函数在立方对称操作下的变换性质，从而揭示其简并子空间结构。\n\n**1. 从复球谐函数到实立方谐函数**\n\n中心势场不含时薛定谔方程的角向部分由复球谐函数 $Y_{\\ell}^{m}(\\theta, \\phi)$ 求解。对于给定的量子数 $\\ell$，这些函数在球面上构成一个标准正交基，其中磁量子数 $m$ 的取值范围为 $-\\ell$ 到 $+\\ell$。它们由以下公式给出：\n$$Y_{\\ell}^{m}(\\theta, \\phi) = \\sqrt{\\frac{(2\\ell+1)}{4\\pi}\\frac{(\\ell-m)!}{(\\ell+m)!}} P_{\\ell}^{m}(\\cos\\theta) e^{im\\phi}$$\n其中 $P_{\\ell}^{m}$ 是缔合勒让德多项式，相位因子 $e^{im\\phi}$ 使其在 $m \\neq 0$ 时为复数。Condon-Shortley 相位约定（对于 $m0$ 包含因子 $(-1)^m$）被普遍使用，并且是 `scipy.special.sph_harm` 中的标准。在此约定下，一个关键性质是 $Y_{\\ell}^{-m} = (-1)^m (Y_{\\ell}^{m})^*$，其中 $*$ 表示复共轭。\n\n尽管 $Y_{\\ell}^{m}$ 是 $L_z$ 算符的本征函数，但它们在笛卡尔空间中不便于可视化电子密度，因为化学键是沿坐标轴排列的。实值谐函数是通过对 $Y_{\\ell}^{m}$ 和 $Y_{\\ell}^{-m}$ 进行线性组合来构造的，以消除虚部。实立方谐函数是这样一组特定的实轨道，它们被选择用来根据立方点群的不可约表示进行变换，从而匹配熟悉的 $p$ 轨道和 $d$ 轨道的形状。\n\n对于给定的 $\\ell$ 和 $m  0$，可以形成两个实的、标准正交的函数：\n$$u_{\\ell,m} \\propto \\Re(Y_{\\ell}^{m})$$\n$$v_{\\ell,m} \\propto \\Im(Y_{\\ell}^{m})$$\n对于 $m=0$，$Y_{\\ell}^{0}$ 已经是实数。我们选择特定的组合和符号来匹配在单位球面（$r=1$）上求值的常规笛卡尔-多项式形式 $x, y, z, xy, yz, xz, x^2-y^2, 3z^2-1$。使用 `scipy` 中 $Y_{\\ell}^{m}$ 的实现，以下定义产生的函数与目标多项式正相关：\n对于 $\\ell=1$（$p$-轨道）：\n- $p_z = Y_1^0 \\propto \\cos\\theta \\equiv z$\n- $p_x = -\\sqrt{2} \\Re(Y_1^1) \\propto \\sin\\theta\\cos\\phi \\equiv x$\n- $p_y = -\\sqrt{2} \\Im(Y_1^1) \\propto \\sin\\theta\\sin\\phi \\equiv y$\n\n对于 $\\ell=2$（$d$-轨道）：\n- $d_{z^2} = Y_2^0 \\propto 3\\cos^2\\theta-1 \\equiv 3z^2-1$\n- $d_{x^2-y^2} = \\sqrt{2} \\Re(Y_2^2) \\propto \\sin^2\\theta\\cos(2\\phi) \\equiv x^2-y^2$\n- $d_{xy} = \\sqrt{2} \\Im(Y_2^2) \\propto \\sin^2\\theta\\sin(2\\phi) \\equiv 2xy$\n- $d_{xz} = -\\sqrt{2} \\Re(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\cos\\phi \\equiv xz$\n- $d_{yz} = -\\sqrt{2} \\Im(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\sin\\phi \\equiv yz$\n\n**2. 数值形状验证**\n\n为了验证这些构造的函数 $h$ 能够再现目标笛卡尔-多项式形状 $t$，我们在单位球面上均匀分布的一组 $N$ 个采样点 $\\Omega_k$ 上计算它们的相关系数。为了进行稳健且确定性的采样，我们采用斐波那契格点。相关系数定义为在采样点上求值的函数值向量之间的余弦相似度：\n$$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}}$$\n接近 $1.0$ 的值证实了计算出的谐函数具有正确的形状和方向。对 $p$-轨道使用 $N=4096$ 个点进行此项检查，对 $d$-轨道使用 $N=8192$ 个点进行检查。\n\n**3. 立方对称性下的简并结构**\n\n五个 $d$-轨道在球对称环境中是简并的，但在晶体的较低对称性下会分裂成不同的简并轨道集。在立方晶体场中，它们分裂成一个二维二重态，标记为 $e_g$（由 $\\{d_{z^2}, d_{x^2-y^2}\\}$ 张成），和一个三维三重态，标记为 $t_{2g}$（由 $\\{d_{xy}, d_{yz}, d_{xz}\\}$ 张成）。这意味着立方体的任何对称操作只会将一个 $e_g$ 轨道变换为其他 $e_g$ 轨道的线性组合，$t_{2g}$ 轨道也是如此。这两个子空间之间没有混合。\n\n我们通过计算来验证此性质。一个旋转 $R$ 通过变换其自变量来作用于函数 $f(\\vec{r})$：旋转后的函数为 $f'(\\vec{r}) = f(R^{-1}\\vec{r})$。我们可以将这个旋转后的函数 $f'_j$ 表示为原始基函数 $\\{f_i\\}$ 的线性组合：\n$$f'_j = \\sum_{i} (C_R)_{ij} f_i$$\n矩阵 $C_R$ 是旋转 $R$ 在基 $\\{f_i\\}$ 中的表示。其系数是通过在 $N=6000$ 个采样点上使用离散内积将 $f'_j$ 投影到每个 $f_i$ 上来找到的：$\\langle g, h \\rangle = \\sum_k g(\\Omega_k)h(\\Omega_k)$。这导出了矩阵方程 $B = G C_R$，其中 $G_{im} = \\langle f_i, f_m \\rangle$ 是格拉姆矩阵 (Gram matrix)，而 $B_{ij} = \\langle f_i, f'_j \\rangle$。那么表示矩阵就是 $C_R = G^{-1}B$。\n\n对于我们按 $\\{d_{z^2}, d_{x^2-y^2}, d_{xy}, d_{yz}, d_{xz}\\}$ 排序的基，矩阵 $C_R$ 应该是块对角矩阵，其中包含一个用于 $e_g$ 子空间的 $2 \\times 2$ 块和一个用于 $t_{2g}$ 子空间的 $3 \\times 3$ 块。\n$$ C_R \\approx \\begin{pmatrix}\nC_{e_g}  \\mathbf{0}_{2\\times3} \\\\\n\\mathbf{0}_{3\\times2}  C_{t_{2g}}\n\\end{pmatrix} $$\n我们计算绕 $x、y$ 和 $z$ 轴旋转 $\\pi/2$ 时的 $C_R$。然后，我们找到非对角块（$2 \\times 3$ 和 $3 \\times 2$ 的零块）中元素的最大绝对值，并验证该值在数值上是可忽略的（小于容差 $\\epsilon = 10^{-6}$），从而证实了预期的简并结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef solve():\n    \"\"\"\n    Main function to perform all calculations and print the finale result.\n    \"\"\"\n    \n    # ------------------ Helper Functions ------------------\n    \n    def get_fibonacci_sphere_points(n_points):\n        \"\"\"\n        Generates uniformly distributed points on a unit sphere using a Fibonacci lattice.\n        \n        Args:\n            n_points (int): The number of points to generate.\n            \n        Returns:\n            tuple: Arrays for (theta, phi, x, y, z) coordinates of the points.\n        \"\"\"\n        indices = np.arange(0, n_points, dtype=float) + 0.5\n        \n        # Golden ratio\n        phi_const = (1 + np.sqrt(5)) / 2\n        \n        # Spherical coordinates\n        theta = np.arccos(1 - 2 * indices / n_points)\n        phi = (2 * np.pi * indices / phi_const) % (2 * np.pi)\n        \n        # Cartesian coordinates\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        \n        return theta, phi, x, y, z\n\n    def get_real_harmonics(l_val, theta, phi):\n        \"\"\"\n        Calculates real cubic harmonics from complex spherical harmonics.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            theta (np.ndarray): Array of polar angles.\n            phi (np.ndarray): Array of azimuthal angles.\n            \n        Returns:\n            dict: A dictionary mapping orbital names to their evaluated values.\n        \"\"\"\n        Y = {}\n        for m_val in range(-l_val, l_val + 1):\n            Y[m_val] = sph_harm(m_val, l_val, phi, theta)\n            \n        real_harmonics = {}\n        if l_val == 1:\n            real_harmonics['px'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['py'] = -np.sqrt(2) * Y[1].imag\n            real_harmonics['pz'] = Y[0].real\n        elif l_val == 2:\n            # Order for correlation check: d_x2-y2, d_xy, d_xz, d_yz, d_z2\n            real_harmonics['d_z2'] = Y[0].real\n            real_harmonics['d_x2-y2'] = np.sqrt(2) * Y[2].real\n            real_harmonics['d_xy'] = np.sqrt(2) * Y[2].imag\n            real_harmonics['d_xz'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['d_yz'] = -np.sqrt(2) * Y[1].imag\n        return real_harmonics\n\n    def get_target_polynomials(l_val, x, y, z):\n        \"\"\"\n        Evaluates the target Cartesian polynomial shapes on the unit sphere.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            x, y, z (np.ndarray): Cartesian coordinates of sample points.\n            \n        Returns:\n            dict: A dictionary mapping target names to their evaluated values.\n        \"\"\"\n        targets = {}\n        if l_val == 1:\n            targets['px'] = x\n            targets['py'] = y\n            targets['pz'] = z\n        elif l_val == 2:\n            targets['d_z2'] = 3 * z**2 - 1\n            targets['d_x2-y2'] = x**2 - y**2\n            targets['d_xy'] = x * y\n            targets['d_xz'] = x * z\n            targets['d_yz'] = y * z\n        return targets\n\n    def calculate_correlation(h, t):\n        \"\"\"\n        Computes the correlation coefficient between two vectors of function values.\n        \n        Args:\n            h (np.ndarray): Values of the computed harmonic.\n            t (np.ndarray): Values of the target polynomial.\n            \n        Returns:\n            float: The correlation coefficient.\n        \"\"\"\n        return np.dot(h, t) / (np.linalg.norm(h) * np.linalg.norm(t))\n\n    def get_rotation_matrix(axis, angle):\n        \"\"\"\n        Constructs a 3D rotation matrix.\n        \n        Args:\n            axis (str): The axis of rotation ('x', 'y', or 'z').\n            angle (float): The angle of rotation in radians.\n        \n        Returns:\n            np.ndarray: The 3x3 rotation matrix.\n        \"\"\"\n        c, s = np.cos(angle), np.sin(angle)\n        if axis == 'x':\n            return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        elif axis == 'y':\n            return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        elif axis == 'z':\n            return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def cartesian_to_spherical(x, y, z):\n        \"\"\"\n        Converts Cartesian coordinates to spherical coordinates (ignoring radius).\n        \n        Args:\n            x, y, z (np.ndarray): Cartesian coordinate arrays.\n        \n        Returns:\n            tuple: Arrays for (theta, phi) angles.\n        \"\"\"\n        theta = np.arccos(np.clip(z, -1.0, 1.0))\n        phi = np.arctan2(y, x)\n        return theta, phi\n\n    # ------------------ Main Logic ------------------\n\n    results = []\n    \n    # Part 1: l=1 Shape Verification\n    N1 = 4096\n    theta1, phi1, x1, y1, z1 = get_fibonacci_sphere_points(N1)\n    real_harmonics_l1 = get_real_harmonics(1, theta1, phi1)\n    target_polys_l1 = get_target_polynomials(1, x1, y1, z1)\n    \n    p_orbitals_order = ['px', 'py', 'pz']\n    for orbital in p_orbitals_order:\n        corr = calculate_correlation(real_harmonics_l1[orbital], target_polys_l1[orbital])\n        results.append(corr)\n\n    # Part 2: l=2 Shape Verification\n    N2 = 8192\n    theta2, phi2, x2, y2, z2 = get_fibonacci_sphere_points(N2)\n    real_harmonics_l2 = get_real_harmonics(2, theta2, phi2)\n    target_polys_l2 = get_target_polynomials(2, x2, y2, z2)\n    \n    d_orbitals_corr_order = ['d_x2-y2', 'd_xy', 'd_xz', 'd_yz', 'd_z2']\n    for orbital in d_orbitals_corr_order:\n        corr = calculate_correlation(real_harmonics_l2[orbital], target_polys_l2[orbital])\n        results.append(corr)\n\n    # Part 3: l=2 Degeneracy Structure Verification\n    N3 = 6000\n    TOLERANCE = 1e-6\n    theta3, phi3, x3, y3, z3 = get_fibonacci_sphere_points(N3)\n    \n    # Basis order for degeneracy check: e_g {d_z2, d_x2-y2}, t_2g {d_xy, d_yz, d_xz}\n    d_degen_order = ['d_z2', 'd_x2-y2', 'd_xy', 'd_yz', 'd_xz']\n    harmonics_l2_degen = get_real_harmonics(2, theta3, phi3)\n    \n    f_basis = np.array([harmonics_l2_degen[orb] for orb in d_degen_order]).T\n\n    # Gram matrix G = F^T F\n    G = f_basis.T @ f_basis\n    G_inv = np.linalg.inv(G)\n\n    initial_coords = np.vstack([x3, y3, z3])\n\n    rot_matrices = {\n        'Rz': get_rotation_matrix('z', np.pi/2),\n        'Rx': get_rotation_matrix('x', np.pi/2),\n        'Ry': get_rotation_matrix('y', np.pi/2),\n    }\n\n    for R_matrix in rot_matrices.values():\n        R_inv = R_matrix.T\n        rotated_coords = R_inv @ initial_coords\n        rx, ry, rz = rotated_coords[0,:], rotated_coords[1,:], rotated_coords[2,:]\n        \n        r_theta, r_phi = cartesian_to_spherical(rx, ry, rz)\n        \n        rot_d_harmonics = get_real_harmonics(2, r_theta, r_phi)\n        f_prime_basis = np.array([rot_d_harmonics[orb] for orb in d_degen_order]).T\n\n        # Matrix B = F^T F'\n        B = f_basis.T @ f_prime_basis\n        \n        # Representation matrix C_R = G^-1 B\n        C_R = G_inv @ B\n\n        # Check off-block elements\n        off_block_eg_t2g = C_R[0:2, 2:5]\n        off_block_t2g_eg = C_R[2:5, 0:2]\n\n        max_off_diag = max(np.abs(off_block_eg_t2g).max(), np.abs(off_block_t2g_eg).max())\n        results.append(max_off_diag  TOLERANCE)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "理解材料中点缺陷的电子结构是调控其宏观性质的关键。本练习将演示一种强大的分析技术：通过将复杂的缺陷波函数投影到原子轨道基组上，来定量分析其角动量成分。我们将通过一个物理动机明确的假设模型，探索外部压力如何改变缺陷态的轨道特性，这在计算材料设计中是一个常见的分析任务。",
            "id": "3433580",
            "problem": "在计算材料科学中，宽带隙氧化物中点缺陷附近的局域电子态，可以通过在类原子基组中展开，依据其角动量成分来表征。假设一个单粒子 Kohn–Sham (KS) 缺陷态，局域在缺陷位置周围，并在以缺陷为中心、半径为 $R$ 的选定球形区域内进行探测。该态的角向依赖关系可以在球谐函数基 $Y_{\\ell m}(\\theta,\\phi)$ 中表示，而径向分量则用随压力变化的衰减函数建模。利用球谐函数的正交归一性作为基本依据，并结合球坐标下不含时薛定谔方程的变量分离法，推导出一个投影方案，用于识别球内缺陷态的主要局域 $(\\ell,m)$ 特征，并追踪其在静水压下的演化。\n\n给定球内一个综合但具有物理动机的模型波函数：\n$$\n\\psi(\\mathbf{r};P) \\equiv \\psi(r,\\theta,\\phi;P) = \\sum_{\\ell=0}^{2} A_{\\ell 0}(P)\\, f_{\\ell}(r;P)\\, Y_{\\ell 0}(\\theta,\\phi),\n$$\n仅保留 $m=0$ 的分量，以表示沿 $z$ 轴的对称性保持缺陷。径向函数为\n$$\nf_0(r;P) = N_0(P)\\, e^{-r/a(P)},\\quad\nf_1(r;P) = N_1(P)\\, r\\, e^{-r/a(P)},\\quad\nf_2(r;P) = N_2(P)\\, r^2\\, e^{-r/a(P)},\n$$\n其中，随压力变化的衰减长度为\n$$\na(P) = \\frac{a_0}{1+\\beta P}.\n$$\n取 $a_0 = 1.5$ 埃（angstrom），$\\beta = 0.02$ 每吉帕斯卡（per gigapascal），因此 $P$ 的单位是吉帕斯卡，$a(P)$ 的单位是埃。归一化常数 $N_{\\ell}(P)$ 的选择使得每个通道的径向测度在全空间上的积分为1，\n$$\n\\int_{0}^{\\infty} r^2\\, f_{\\ell}(r;P)\\, dr = 1,\n$$\n这意味着\n$$\nN_0(P) = \\frac{1}{2\\,a(P)^3},\\quad N_1(P) = \\frac{1}{6\\,a(P)^4},\\quad N_2(P) = \\frac{1}{24\\,a(P)^5}.\n$$\n未归一化的、随压力变化的角向振幅为\n$$\n\\tilde{A}_{00}(P) = \\cos\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{10}(P) = \\sin\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{20}(P) = \\gamma \\max(P,0),\n$$\n其中\n$$\n\\theta(P) = \\theta_0 + k P,\\quad \\theta_0 = \\frac{\\pi}{8},\\quad k = \\frac{\\pi}{90},\\quad \\gamma = 0.03,\n$$\n角度单位为弧度，压力 $P$ 的单位为吉帕斯卡。然后将振幅归一化为单位范数，\n$$\nA_{\\ell 0}(P) = \\frac{\\tilde{A}_{\\ell 0}(P)}{\\sqrt{\\sum_{\\ell'=0}^{2} \\tilde{A}_{\\ell' 0}(P)^2}}.\n$$\n\n从球谐函数的正交归一性出发，\n$$\n\\int Y_{\\ell m}^{*}(\\theta,\\phi)\\, Y_{\\ell' m'}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{m m'},\n$$\n推导在半径为 $R$ 的有限球体内的投影系数表达式，\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 \\sin\\theta\\, d\\theta\\, d\\phi\\, dr,\n$$\n并展示由于角度上的正交归一性，该表达式如何简化为一个角向振幅与一个径向积分的乘积。对于给定的 $f_{\\ell}$，计算径向累积因子\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr,\n$$\n并用它们来计算\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P).\n$$\n将球内的通道权重定义为\n$$\nw_{\\ell 0}(R,P) = \\frac{\\left|C_{\\ell 0}(R,P)\\right|^2}{\\sum_{\\ell'=0}^{2}\\left|C_{\\ell' 0}(R,P)\\right|^2}.\n$$\n您的任务是实现一个程序，对于每个指定的测试用例 $(R,P)$，计算归一化权重 $w_{00}(R,P)$、$w_{10}(R,P)$、$w_{20}(R,P)$，并通过最大权重确定主导的 $(\\ell,m)$ 通道。将报告的权重四舍五入到 $6$ 位小数。将主导的量子数对报告为整数 $(\\ell,m)$。\n\n物理单位：输入压力 $P$ 的单位是吉帕斯卡（gigapascal），半径 $R$ 的单位是埃（angstrom）。计算出的权重是无量纲的。\n\n角度单位：所有三角函数必须使用弧度。\n\n用于覆盖不同条件的测试套件：\n- 案例 1：$R=4.0$ 埃, $P=0$ 吉帕斯卡。\n- 案例 2：$R=4.0$ 埃, $P=10$ 吉帕斯卡。\n- 案例 3：$R=4.0$ 埃, $P=20$ 吉帕斯卡。\n- 案例 4：$R=2.0$ 埃, $P=10$ 吉帕斯卡。\n- 案例 5：$R=4.0$ 埃, $P=-5$ 吉帕斯卡。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表，每个结果是一个形式为 $[\\ell_{\\mathrm{dom}},m_{\\mathrm{dom}},w_{00},w_{10},w_{20}]$ 的列表，权重按 $[\\ell=0,\\ell=1,\\ell=2]$ 的顺序排列。例如，一个有效的输出格式是\n$[[0,0,0.750000,0.200000,0.050000],[\\dots],\\dots]$。",
            "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且定义明确的。所有提供的数据、定义和约束在计算材料科学和量子力学的背景下都是一致且具有物理意义的。任务是推导并实现一个投影方案，以分析一个模型缺陷态波函数。\n\n### 投影系数 $C_{\\ell 0}(R,P)$ 的推导\n\n投影系数 $C_{\\ell 0}(R,P)$ 量化了 $(\\ell, m=0)$ 角动量通道对半径为 $R$ 的球内总波函数 $\\psi(\\mathbf{r};P)$ 的贡献。它的定义是波函数与相应的球谐函数 $Y_{\\ell 0}(\\theta,\\phi)$ 的内积，并在球的体积上积分。\n\n定义如下：\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\n其中立体角元为 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$。\n\n提供的模型波函数是基函数的线性组合，每个基函数都是径向部分 $f_{\\ell'}(r;P)$ 和角向部分 $Y_{\\ell' 0}(\\theta,\\phi)$ 的乘积：\n$$\n\\psi(r,\\theta,\\phi;P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi)\n$$\n将这个 $\\psi$ 的表达式代入 $C_{\\ell 0}(R,P)$ 的定义中：\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\left( \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi) \\right) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\n由于积分和求和算符是线性的，它们的顺序可以互换。系数 $A_{\\ell' 0}(P)$ 和径向函数 $f_{\\ell'}(r;P)$ 与角变量 $(\\theta,\\phi)$ 无关，可以从角向积分中提出来：\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\left( \\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega \\right) dr\n$$\n推导的核心在于球谐函数的正交归一性：\n$$\n\\int_{\\Omega} Y_{\\ell' m'}(\\theta,\\phi) Y_{\\ell m}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{mm'}\n$$\n在我们的情况下，$m=m'=0$，因此积分简化为：\n$$\n\\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\n$$\n（注意，当 $m=0$ 时，球谐函数是实数，所以 $Y_{\\ell 0}^{*} = Y_{\\ell 0}$。）\n\n将克罗内克 δ 符号 $\\delta_{\\ell\\ell'}$ 代回 $C_{\\ell 0}(R,P)$ 的表达式中：\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\delta_{\\ell\\ell'} dr\n$$\n克罗内克 δ 仅在 $\\ell'=\\ell$ 时非零（等于1）。此性质将对 $\\ell'$ 的求和简化为对应于投影特定 $\\ell$ 的单个项：\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\int_{0}^{R} f_{\\ell}(r;P)\\, r^2 dr\n$$\n剩余的积分正是径向累积因子 $S_{\\ell}(R,P)$ 的定义：\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr\n$$\n因此，我们得到了投影系数的最终表达式，它将角向和径向的贡献分离开来：\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P)\n$$\n这表明投影操作有效地分离出了特定通道的振幅 $A_{\\ell 0}(P)$，并通过半径为 $R$ 的球体内包含的径向密度 $r^2|f_\\ell(r;P)|$ 的分数对其进行加权。\n\n### 径向累积因子 $S_{\\ell}(R,P)$ 的推导\n\n必须计算每个通道 $\\ell \\in \\{0, 1, 2\\}$ 的径向累积因子 $S_{\\ell}(R,P)$。径向函数为 $f_0(r;P) = N_0(P) e^{-r/a(P)}$，$f_1(r;P) = N_1(P) r e^{-r/a(P)}$ 和 $f_2(r;P) = N_2(P) r^2 e^{-r/a(P)}$。\n让我们引入变量 $x = r/a(P)$，其中 $a(P)$ 是随压力变化的衰减长度。$S_{\\ell}(R,P)$ 的积分可以用 $x$ 来表示。\n\n对于 $\\ell=0$：\n$$S_0(R,P) = \\int_{0}^{R} r^2 N_0(P) e^{-r/a(P)} dr = N_0(P) \\int_{0}^{R} r^2 e^{-r/a(P)} dr$$\n已知 $N_0(P) = 1/(2a(P)^3)$ 并代入 $r=xa(P)$, $dr=a(P)dx$：\n$$S_0(R,P) = \\frac{1}{2a(P)^3} \\int_{0}^{R/a(P)} (xa(P))^2 e^{-x} a(P)dx = \\frac{1}{2} \\int_{0}^{R/a(P)} x^2 e^{-x} dx$$\n这个积分与下不完全伽玛函数 $\\gamma(s,z) = \\int_0^z t^{s-1}e^{-t}dt$ 有关。这里，$s=3$ 且 $z=R/a(P)$。该积分为 $\\gamma(3, R/a(P))$。对应的正则化下不完全伽玛函数是 $P(s,z) = \\gamma(s,z)/\\Gamma(s)$。由于 $\\Gamma(3)=2! = 2$，我们得到 $S_0(R,P) = P(3, R/a(P))$。\n\n类似地，对于 $\\ell=1$ 和 $\\ell=2$，我们分别对 $r^3$ 和 $r^4$ 进行积分：\n$$S_1(R,P) = \\frac{1}{6} \\int_{0}^{R/a(P)} x^3 e^{-x} dx = \\frac{\\gamma(4, R/a(P))}{\\Gamma(4)} = P(4, R/a(P))$$\n$$S_2(R,P) = \\frac{1}{24} \\int_{0}^{R/a(P)} x^4 e^{-x} dx = \\frac{\\gamma(5, R/a(P))}{\\Gamma(5)} = P(5, R/a(P))$$\n对于整数 $s$，$P(s,z) = 1 - e^{-z}\\sum_{k=0}^{s-1} \\frac{z^k}{k!}$。令 $z=R/a(P)$，我们得到显式公式：\n$$S_0(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2}\\right)$$\n$$S_1(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}\\right)$$\n$$S_2(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)$$\n这些公式可以直接实现，也可以使用标准库中的正则化不完全伽玛函数来实现。\n\n### 计算策略\n\n计算给定输入对 $(R,P)$ 的通道权重的总体算法如下：\n1.  定义物理常数 $a_0=1.5$, $\\beta=0.02$, $\\theta_0=\\pi/8$, $k=\\pi/90$ 和 $\\gamma=0.03$。\n2.  计算随压力变化的衰减长度 $a(P) = a_0 / (1+\\beta P)$。\n3.  计算随压力变化的角度 $\\theta(P) = \\theta_0 + kP$。\n4.  计算未归一化的角向振幅：$\\tilde{A}_{00}(P) = \\cos(\\theta(P))$, $\\tilde{A}_{10}(P) = \\sin(\\theta(P))$ 和 $\\tilde{A}_{20}(P) = \\gamma \\max(P,0)$。\n5.  归一化振幅：$A_{\\ell 0}(P) = \\tilde{A}_{\\ell 0}(P) / \\sqrt{\\sum_{\\ell'} \\tilde{A}_{\\ell' 0}(P)^2}$。\n6.  计算无量纲变量 $z = R/a(P)$。\n7.  使用上面推导的公式（或等效的库函数）计算径向累积因子 $S_0(R,P)$、$S_1(R,P)$ 和 $S_2(R,P)$。\n8.  计算投影系数 $C_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\times S_{\\ell}(R,P)$，其中 $\\ell \\in \\{0, 1, 2\\}$。\n9.  计算系数的模平方 $|C_{\\ell 0}(R,P)|^2$。\n10. 计算通道权重 $w_{\\ell 0}(R,P) = |C_{\\ell 0}(R,P)|^2 / \\sum_{\\ell'} |C_{\\ell' 0}(R,P)|^2$。\n11. 通过找到使权重 $w_{\\ell 0}$ 最大化的索引 $\\ell$ 来确定主导通道 $(\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}})$。磁量子数 $m$ 固定为 $m_{\\mathrm{dom}}=0$。\n12. 按要求格式化结果：$[\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}}, w_{00}, w_{10}, w_{20}]$，权重四舍五入到6位小数。\n\n将为问题陈述中指定的每个测试用例实施此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammainc\n\ndef solve():\n    \"\"\"\n    Computes and identifies the dominant angular momentum channel for a model\n    defect state under varying pressure and analysis radius.\n    \"\"\"\n    \n    # Define physical constants and parameters from the problem statement.\n    a0 = 1.5      # angstrom\n    beta = 0.02   # per GPa\n    theta0 = np.pi / 8.0\n    k = np.pi / 90.0\n    gamma = 0.03\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R in angstrom, P in gigapascal)\n        (4.0, 0.0),\n        (4.0, 10.0),\n        (4.0, 20.0),\n        (2.0, 10.0),\n        (4.0, -5.0),\n    ]\n\n    results_str = []\n    for R, P in test_cases:\n        # Step 1: Calculate pressure-dependent parameters\n        a_P = a0 / (1.0 + beta * P)\n        theta_P = theta0 + k * P\n\n        # Step 2: Calculate unnormalized angular amplitudes\n        A_tilde_00 = np.cos(theta_P)\n        A_tilde_10 = np.sin(theta_P)\n        A_tilde_20 = gamma * max(P, 0.0)\n        \n        # Step 3: Normalize the angular amplitudes\n        amplitudes_tilde = np.array([A_tilde_00, A_tilde_10, A_tilde_20])\n        norm_A = np.sqrt(np.sum(np.square(amplitudes_tilde)))\n        amplitudes_A = amplitudes_tilde / norm_A if norm_A > 0 else np.zeros(3)\n\n        # Step 4: Calculate radial accumulation factors S_l(R,P)\n        # These are regularized lower incomplete gamma functions P(s, z)\n        # where s = l + n + 1 and z = R/a(P).\n        # For f_l(r) ~ r^l, the integral is over r^2 * f_l(r) ~ r^(l+2).\n        # So we have integrals over r^2, r^3, r^4 corresponding to s=3,4,5.\n        z = R / a_P\n        S_factors = np.array([\n            gammainc(3, z),  # S_0(R,P) for l=0\n            gammainc(4, z),  # S_1(R,P) for l=1\n            gammainc(5, z)   # S_2(R,P) for l=2\n        ])\n\n        # Step 5: Calculate projection coefficients C_l0(R,P)\n        coeffs_C = amplitudes_A * S_factors\n\n        # Step 6: Calculate channel weights w_l0(R,P)\n        squared_C = np.square(coeffs_C)\n        sum_squared_C = np.sum(squared_C)\n        \n        if sum_squared_C > 1e-12: # Avoid division by zero\n            weights = squared_C / sum_squared_C\n        else:\n            weights = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0]) # Degenerate case, e.g. R=0\n\n        w00, w10, w20 = weights\n        \n        # Step 7: Identify the dominant channel\n        l_dom = np.argmax(weights)\n        m_dom = 0\n        \n        # Step 8: Format the output for the current case\n        result_str = f\"[{l_dom},{m_dom},{w00:.6f},{w10:.6f},{w20:.6f}]\"\n        results_str.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代电子结构计算方法（如投影缀加波，PAW）的准确性在很大程度上取决于所用原子轨道基函数的质量。本练习提供了一个简化而深刻的视角，揭示了在原子核周围的缀加区域内，径向“分波”基函数的选择如何影响基组的完备性。您将亲手实践并观察到这些选择如何直接影响对关键材料性质（如态密度和磁矩）的计算结果。",
            "id": "3433603",
            "problem": "你的任务是为单个角动量通道实现一个简化但有原则的投影缀加波 (projector augmented-wave) 缀加方案，以研究分波的数量和径向形状如何影响轨道分辨的物理量。你的实现必须基于量子力学的第一性原理和电子结构理论中使用的标准定义，并且必须以纯粹的数学和算法术语来表达。\n\n物理和数学背景如下。在原子周围半径为 $r_{c}$ 的缀加球面内，电子结构代码通过用一组局域分波缀加一个光滑的赝波函数来表示全电子波函数。对于给定的角动量通道 $l$，定义一个由 $n \\in \\{1,\\dots,N\\}$ 索引的包含 $N$ 个径向分波 $R_{n l}(r)$ 的族，其定义域为 $r \\in [0,r_{c}]$。假设在缀加球面内具有球对称性，并且仅处理通道 $l$ 的径向部分。令目标 $l$ 通道的参考径向振幅为一个归一化函数 $\\psi_{l}(r)$，代表球面内的全电子特性。\n\n计算任务如下：\n\n1. 将每个分波定义为 $R_{n l}(r) = \\mathcal{N}_{n l} \\, r^{l} e^{-\\alpha_{n} r^{2}}$，定义域为 $r \\in [0,r_{c}]$，其中 $\\alpha_{n}  0$ 控制径向形状，$\\mathcal{N}_{n l}$ 是归一化因子，其选择需满足 $\\int_{0}^{r_{c}} r^{2} \\left|R_{n l}(r)\\right|^{2} \\, \\mathrm{d}r = 1$。对于下面的测试套件，你将使用规则 $\\alpha_{n} = \\alpha_{\\mathrm{base}} \\cdot n$，其中给定 $\\alpha_{\\mathrm{base}}  0$。\n\n2. 构建双正交投影函数 $p_{n l}(r)$，使得对于所有 $n,m \\in \\{1,\\dots,N\\}$，满足 $\\int_{0}^{r_{c}} r^{2} R_{n l}(r) \\, p_{m l}(r) \\, \\mathrm{d}r = \\delta_{n m}$。你必须通过对有限重叠矩阵 $S_{n m} = \\int_{0}^{r_{c}} r^{2} R_{n l}(r) \\, R_{m l}(r) \\, \\mathrm{d}r$ 求逆，并构造线性组合 $p_{n l}(r) = \\sum_{m=1}^{N} \\left(S^{-1}\\right)_{n m} R_{m l}(r)$ 来获得 $p_{n l}(r)$。\n\n3. 将 $l$ 通道的归一化参考径向振幅定义为 $\\psi_{l}(r) = \\mathcal{N}^{\\mathrm{ref}}_{l} \\, r^{l} e^{-\\alpha_{\\mathrm{ref}} r^{2}}$，并满足 $\\int_{0}^{r_{c}} r^{2} \\left|\\psi_{l}(r)\\right|^{2} \\, \\mathrm{d}r = 1$。\n\n4. 计算投影系数 $a_{n} = \\int_{0}^{r_{c}} r^{2} \\, p_{n l}(r) \\, \\psi_{l}(r) \\, \\mathrm{d}r$ 和重构投影 $\\psi^{\\mathrm{proj}}_{l}(r) = \\sum_{n=1}^{N} a_{n} R_{n l}(r)$。\n\n5. 将 $l$ 通道径向振幅的捕获分数 $f$ 定义为 $f = \\int_{0}^{r_{c}} r^{2} \\left|\\psi^{\\mathrm{proj}}_{l}(r)\\right|^{2} \\, \\mathrm{d}r$。此量度量了所选分波在多大程度上完整地张成了球面内的参考 $l$ 通道特性。根据构造，$0 \\le f \\le 1$。\n\n6. 将过渡金属氧化物中的简化 $3d$ 态流形（$l = 2$）建模为五个分立能级：三个能量为 $E_{t}$ 的 $t_{2 g}$ 能级和两个能量为 $E_{e}$ 的 $e_{g}$ 能级。通过将自旋向上和自旋向下的能量移动 $\\pm \\Delta/2$ 来引入共线自旋极化，使得自旋向上的能量为 $E_{t}^{\\uparrow} = E_{t} - \\Delta/2$（三重简并）和 $E_{e}^{\\uparrow} = E_{e} - \\Delta/2$（二重简并），自旋向下的能量为 $E_{t}^{\\downarrow} = E_{t} + \\Delta/2$（三重简并）和 $E_{e}^{\\downarrow} = E_{e} + \\Delta/2$（二重简并）。令 $E_{F}$ 表示费米能级。\n\n7. 定义一个宽度参数为 $\\eta  0$ 的高斯展宽函数 $G(x;\\eta) = \\frac{1}{\\eta \\sqrt{\\pi}} \\exp\\left(-\\frac{x^{2}}{\\eta^{2}}\\right)$。费米能级处的 $d$ 通道、自旋分辨的态密度模型为\n$$\nD^{\\sigma}_{d}(E_{F}) = f \\sum_{i \\in \\text{levels of spin } \\sigma} G\\left(E_{F} - E_{i}^{\\sigma}; \\eta\\right),\n$$\n其中 $\\sigma \\in \\{\\uparrow,\\downarrow\\}$，求和遍及五个 $d$ 能级，包含它们各自的简并度和自旋为 $\\sigma$ 时的能量。将 $D^{\\sigma}_{d}(E_{F})$ 以态/电子伏特 (eV$^{-1}$) 为单位表示。\n\n8. 通过计算 $E_{F}$ 处的占据数并按捕获分数 $f$ 进行缩放，确定轨道分辨的 $d$ 通道磁矩（以玻尔磁子为单位）：\n$$\n\\mu_{d} = \\mu_{B} \\left( f \\, N_{\\uparrow} - f \\, N_{\\downarrow} \\right),\n$$\n其中 $N_{\\sigma}$ 是满足 $E_{i}^{\\sigma} \\le E_{F}$ 的自旋为 $\\sigma$ 的 $d$ 能级数，$\\mu_{B}$ 表示玻尔磁子。在这个简化模型中，取 $\\mu_{B} = 1$，因此 $\\mu_{d}$ 直接以玻尔磁子为单位报告，作为一个无量纲浮点数。\n\n所有径向积分必须在 $r \\in [0,r_{c}]$ 上使用测度 $r^{2} \\, \\mathrm{d}r$ 进行计算。由于在缀加球面内假定了球对称性，角度不参与计算。径向距离必须以玻尔半径为单位，能量以电子伏特为单位，态密度以态/电子伏特为单位，磁矩以玻尔磁子为单位。\n\n你的程序必须实现上述方案，并将其应用于以下测试套件。对于每个测试用例，参数以元组 $\\left(l, r_{c}, N, \\alpha_{\\mathrm{base}}, \\alpha_{\\mathrm{ref}}, E_{t}, E_{e}, \\Delta, E_{F}, \\eta \\right)$ 的形式给出：\n\n- 测试用例 1 (正常路径): $\\left(2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2 \\right)$。\n- 测试用例 2 (完备性降低): $\\left(2, 2.0, 1, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2 \\right)$。\n- 测试用例 3 (形状失配): $\\left(2, 2.0, 4, 5.0, 1.0, -1.0, 0.5, 1.5, 0.0, 0.2 \\right)$。\n- 测试用例 4 (非磁性边界): $\\left(2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 0.0, 0.0, 0.2 \\right)$。\n\n对于每个测试用例，计算并返回三元组 $\\left[D^{\\uparrow}_{d}(E_{F}), D^{\\downarrow}_{d}(E_{F}), \\mu_{d}\\right]$，其中 $D^{\\uparrow}_{d}(E_{F})$ 和 $D^{\\downarrow}_{d}(E_{F})$ 是以 eV$^{-1}$ 为单位的浮点数，$\\mu_{d}$ 是以玻尔磁子为单位的浮点数。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个按上述顺序排列的列表。例如，输出应类似于 $\\left[ [x_{1}, y_{1}, z_{1}], [x_{2}, y_{2}, z_{2}], [x_{3}, y_{3}, z_{3}], [x_{4}, y_{4}, z_{4}] \\right]$，其中 $x_{i}$、$y_{i}$ 和 $z_{i}$ 是实际的数值浮点数。",
            "solution": "该问题要求实现一个简化的投影缀加波 (PAW) 方案来计算轨道分辨的性质。该问题是有效的，因为它在科学上基于量子力学和电子结构理论的原理，在数学上是适定的，并且所有参数和过程都得到了客观和完整的定义。解决方案通过执行指定的步骤来进行。\n\n问题的核心涉及将一个参考径向波函数 $\\psi_{l}(r)$ 投影到一个由 $N$ 个分波组成的有限基组 $\\{R_{n l}(r)\\}_{n=1}^{N}$ 上。所有函数都在半径为 $r_{c}$ 的缀加球面内定义。\n\n首先，我们为给定的角动量通道 $l$ 定义未归一化的径向分波和参考波的函数形式：\n$$\n\\tilde{R}_{n l}(r) = r^{l} e^{-\\alpha_{n} r^{2}}\n$$\n$$\n\\tilde{\\psi}_{l}(r) = r^{l} e^{-\\alpha_{\\mathrm{ref}} r^{2}}\n$$\n其中 $n \\in \\{1, \\dots, N\\}$，衰减参数由 $\\alpha_{n} = \\alpha_{\\mathrm{base}} \\cdot n$ 给出。这些函数的定义域为区间 $r \\in [0, r_{c}]$。\n\n归一化函数 $R_{n l}(r)$ 和 $\\psi_{l}(r)$ 是通过要求其相对于使用测度 $r^2 dr$ 定义的内积具有单位范数来获得的：\n$$\n\\int_{0}^{r_{c}} r^{2} |R_{n l}(r)|^{2} \\, \\mathrm{d}r = 1 \\quad \\text{和} \\quad \\int_{0}^{r_{c}} r^{2} |\\psi_{l}(r)|^{2} \\, \\mathrm{d}r = 1\n$$\n这确定了归一化常数 $\\mathcal{N}_{n l}$ 和 $\\mathcal{N}^{\\mathrm{ref}}_{l}$，使得 $R_{n l}(r) = \\mathcal{N}_{n l} \\tilde{R}_{n l}(r)$ 且 $\\psi_l(r) = \\mathcal{N}^{\\mathrm{ref}}_{l} \\tilde{\\psi}_l(r)$。对于形式为 $f(r) = r^l e^{-Ar^2}$ 的函数，其归一化积分为：\n$$\n\\int_{0}^{r_{c}} r^{2} |f(r)|^{2} \\, \\mathrm{d}r = \\int_{0}^{r_{c}} r^{2l+2} e^{-2Ar^2} \\, \\mathrm{d}r\n$$\n该积分可以使用下不完全伽玛函数 $\\gamma(s, x) = \\int_0^x t^{s-1} e^{-t} dt$ 进行解析计算。通过代换 $t = 2Ar^2$，我们发现该积分等于：\n$$\nI(A, l) = \\frac{1}{2(2A)^{(2l+3)/2}} \\gamma\\left(\\frac{2l+3}{2}, 2Ar_c^2\\right)\n$$\n归一化常数则为 $\\mathcal{N} = 1/\\sqrt{I(A,l)}$。\n\n第二，我们构建双正交投影函数 $p_{nl}(r)$。分波 $\\{R_{nl}(r)\\}$ 并非相互正交。它们的重叠由重叠矩阵 $S$ 量化：\n$$\nS_{nm} = \\int_{0}^{r_{c}} r^{2} R_{n l}(r) R_{m l}(r) \\, \\mathrm{d}r\n$$\n矩阵元 $S_{nm}$ 的积分具有相似的形式：\n$$\n\\int_{0}^{r_{c}} r^{2} (\\mathcal{N}_{nl} r^l e^{-\\alpha_n r^2}) (\\mathcal{N}_{ml} r^l e^{-\\alpha_m r^2}) \\, \\mathrm{d}r = \\mathcal{N}_{nl}\\mathcal{N}_{ml} \\int_{0}^{r_{c}} r^{2l+2} e^{-(\\alpha_n+\\alpha_m)r^2} \\, \\mathrm{d}r\n$$\n该积分也可以使用上面积分表达式 $I$ 的推广形式来计算。双正交投影函数是分波的线性组合，即 $p_{n l}(r) = \\sum_{m=1}^{N} (S^{-1})_{nm} R_{m l}(r)$，其中 $S^{-1}$ 是矩阵 $S$ 的逆。根据构造，这些投影函数满足双正交条件 $\\int_{0}^{r_{c}} r^{2} p_{n l}(r) R_{m l}(r) \\, \\mathrm{d}r = \\delta_{nm}$。\n\n第三，我们将参考波 $\\psi_l(r)$ 投影到分波基组上。投影波为 $\\psi^{\\mathrm{proj}}_{l}(r) = \\sum_{n=1}^{N} a_{n} R_{n l}(r)$，其中系数 $a_n$ 计算如下：\n$$\na_{n} = \\int_{0}^{r_{c}} r^{2} p_{n l}(r) \\psi_{l}(r) \\, \\mathrm{d}r = \\sum_{m=1}^{N} (S^{-1})_{nm} \\int_{0}^{r_{c}} r^{2} R_{m l}(r) \\psi_{l}(r) \\, \\mathrm{d}r\n$$\n让我们定义参考波与分波之间的重叠向量 $\\mathbf{b}$，其分量为 $b_m = \\int_{0}^{r_{c}} r^{2} R_{m l}(r) \\psi_{l}(r) \\, \\mathrm{d}r$。投影系数向量则由 $\\mathbf{a} = S^{-1}\\mathbf{b}$ 给出。\n\n第四，我们计算捕获分数 $f$，它衡量了投影的保真度。它是投影波的范数平方：\n$$\nf = \\int_{0}^{r_{c}} r^{2} |\\psi^{\\mathrm{proj}}_{l}(r)|^{2} \\, \\mathrm{d}r = \\int_{0}^{r_{c}} r^{2} \\left( \\sum_n a_n R_{nl}(r) \\right) \\left( \\sum_m a_m R_{ml}(r) \\right) \\, \\mathrm{d}r\n$$\n$$\nf = \\sum_{n,m} a_n a_m S_{nm} = \\mathbf{a}^T S \\mathbf{a}\n$$\n代入 $\\mathbf{a} = S^{-1}\\mathbf{b}$，并注意到 $S$ 是对称的（$S^T = S$），我们得到一个计算上方便的形式：\n$$\nf = (S^{-1}\\mathbf{b})^T S (S^{-1}\\mathbf{b}) = \\mathbf{b}^T (S^{-1})^T S S^{-1} \\mathbf{b} = \\mathbf{b}^T S^{-1} \\mathbf{b} = \\mathbf{b} \\cdot \\mathbf{a}\n$$\n这个分数 $f$ 缩放了 $d$ 通道对可观测量的贡献。\n\n第五，我们将此方案应用于固体中的 $3d$ 态流形（$l=2$）的物理模型。三重简并的 $t_{2g}$ 能级和二重简并的 $e_g$ 能级的能量因自旋极化而分裂：\n$$\nE_{t}^{\\uparrow} = E_{t} - \\Delta/2, \\quad E_{e}^{\\uparrow} = E_{e} - \\Delta/2\n$$\n$$\nE_{t}^{\\downarrow} = E_{t} + \\Delta/2, \\quad E_{e}^{\\downarrow} = E_{e} + \\Delta/2\n$$\n费米能级 $E_F$ 处的自旋分辨态密度（DOS）通过对以这些能级为中心的高斯函数求和来计算，并按其简并度和捕获分数 $f$ 进行加权：\n$$\nD^{\\sigma}_{d}(E_{F}) = f \\sum_{i \\in \\text{levels of spin } \\sigma} G\\left(E_{F} - E_{i}^{\\sigma}; \\eta\\right)\n$$\n其中 $\\sigma \\in \\{\\uparrow, \\downarrow\\}$ 且 $G(x;\\eta) = (\\eta\\sqrt{\\pi})^{-1} \\exp(-x^2/\\eta^2)$。对于 $d$ 通道，具体为：\n$$\nD^{\\uparrow}_{d}(E_{F}) = f \\left[ 3 G(E_F - E_t^\\uparrow; \\eta) + 2 G(E_F - E_e^\\uparrow; \\eta) \\right]\n$$\n$$\nD^{\\downarrow}_{d}(E_{F}) = f \\left[ 3 G(E_F - E_t^\\downarrow; \\eta) + 2 G(E_F - E_e^\\downarrow; \\eta) \\right]\n$$\n最后，通过计算每个自旋通道的占据态数并按 $f$ 缩放来计算磁矩 $\\mu_d$：\n$$\n\\mu_d = f(N_\\uparrow - N_\\downarrow)\n$$\n其中 $N_\\sigma$ 是能量小于或等于 $E_F$ 的自旋为 $\\sigma$ 的态的总数。具体来说，$N_{\\uparrow} = 3 \\cdot \\mathbb{I}(E_t^\\uparrow \\le E_F) + 2 \\cdot \\mathbb{I}(E_e^\\uparrow \\le E_F)$ 以及 $N_{\\downarrow} = 3 \\cdot \\mathbb{I}(E_t^\\downarrow \\le E_F) + 2 \\cdot \\mathbb{I}(E_e^\\downarrow \\le E_F)$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。玻尔磁子 $\\mu_B$ 取为 1。\n\n该算法包括通过使用数值库进行矩阵运算和特殊函数计算，实现推导出的公式，从而为每个测试用例计算这些物理量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\ndef solve():\n    \"\"\"\n    Implements a simplified projector augmented-wave scheme to compute\n    orbital-resolved physical properties for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (l, r_c, N, alpha_base, alpha_ref, E_t, E_e, Delta, E_F, eta)\n        (2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2), # Test case 1\n        (2, 2.0, 1, 2.0, 1.2, -1.0, 0.5, 1.5, 0.0, 0.2), # Test case 2\n        (2, 2.0, 4, 5.0, 1.0, -1.0, 0.5, 1.5, 0.0, 0.2), # Test case 3\n        (2, 2.0, 3, 2.0, 1.2, -1.0, 0.5, 0.0, 0.0, 0.2), # Test case 4\n    ]\n\n    results = []\n\n    def integral_helper(A, k, rc_val):\n        \"\"\"\n        Calculates the integral of r^k * exp(-A * r^2) from 0 to rc_val.\n        This is used for all radial integrals.\n        \"\"\"\n        if A == 0:\n            # This case should not be reached with the given alpha > 0.\n            return 0.0\n        \n        # Power for the gamma function and A\n        power = (k + 1) / 2\n        # Argument for the incomplete gamma function\n        arg = A * rc_val**2\n        \n        # The integral is related to the lower incomplete gamma function, gamma(s, x).\n        # gamma(s,x) = Gamma(s) * P(s,x)\n        # where P(s,x) is the regularized lower incomplete gamma function (gammainc).\n        incomplete_gamma_val = gamma(power) * gammainc(power, arg)\n        \n        # Final expression for the integral\n        return incomplete_gamma_val / (2 * A**power)\n\n    for case in test_cases:\n        l, r_c, N, alpha_base, alpha_ref, E_t, E_e, Delta, E_F, eta = case\n\n        # Set of alpha parameters for the partial waves\n        alphas = [alpha_base * (n + 1) for n in range(N)]\n        \n        # The power of r in the integrands for normalization and overlap\n        k = 2 * l + 2\n        \n        # 1.  3. Calculate normalization constants for partial waves and reference wave\n        # The integral for normalization of a wave ~ r^l * exp(-alpha * r^2) is\n        # integral_helper(2 * alpha, 2*l + 2, r_c).\n        norm_consts_sq_inv = [integral_helper(2 * alpha, k, r_c) for alpha in alphas]\n        norm_consts = [1.0 / np.sqrt(nci) for nci in norm_consts_sq_inv]\n\n        norm_ref_sq_inv = integral_helper(2 * alpha_ref, k, r_c)\n        norm_ref = 1.0 / np.sqrt(norm_ref_sq_inv)\n        \n        # 2. Construct the overlap matrix S\n        S = np.zeros((N, N))\n        for i in range(N):\n            for j in range(i, N):\n                val = norm_consts[i] * norm_consts[j] * integral_helper(alphas[i] + alphas[j], k, r_c)\n                S[i, j] = val\n                S[j, i] = val\n        \n        S_inv = np.linalg.inv(S)\n        \n        # 4. Compute the overlap vector b between the reference wave and partial waves\n        b = np.zeros(N)\n        for i in range(N):\n            b[i] = norm_consts[i] * norm_ref * integral_helper(alphas[i] + alpha_ref, k, r_c)\n\n        # 5. Compute the captured fraction f = b^T * S^-1 * b\n        f = np.dot(b, np.dot(S_inv, b))\n        \n        # 6. Define the spin-polarized energy levels\n        Et_up, Ee_up = E_t - Delta / 2, E_e - Delta / 2\n        Et_down, Ee_down = E_t + Delta / 2, E_e + Delta / 2\n\n        # 7. Compute the spin-resolved density of states at E_F\n        def gaussian(x, eta_val):\n            return (1.0 / (eta_val * np.sqrt(np.pi))) * np.exp(-(x**2) / (eta_val**2))\n\n        dos_up = f * (3 * gaussian(E_F - Et_up, eta) + 2 * gaussian(E_F - Ee_up, eta))\n        dos_down = f * (3 * gaussian(E_F - Et_down, eta) + 2 * gaussian(E_F - Ee_down, eta))\n        \n        # 8. Determine the orbital-resolved magnetic moment\n        N_up = (3 if Et_up = E_F else 0) + (2 if Ee_up = E_F else 0)\n        N_down = (3 if Et_down = E_F else 0) + (2 if Ee_down = E_F else 0)\n        mu_d = f * (N_up - N_down)\n\n        results.append([dos_up, dos_down, mu_d])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}