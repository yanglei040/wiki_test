{
    "hands_on_practices": [
        {
            "introduction": "The accuracy of numerical simulations often hinges on the precise calculation of derivatives, which represent physical quantities like fluxes or forces. This exercise delves into the heart of finite difference methods, guiding you through the derivation of a high-order stencil from first principles. By systematically using Taylor series expansions, you will not only construct a fourth-order accurate formula but also quantify its error, a fundamental skill for developing and analyzing numerical solvers in materials science .",
            "id": "3471358",
            "problem": "In a one-dimensional phase-field simulation of microstructural evolution in computational materials science, the conserved order parameter field $u(x)$ is defined on a uniform grid with spacing $h$. Accurate evaluation of the spatial derivative $u'(x)$ is required to compute diffusive fluxes that enforce mass conservation and minimize numerical dispersion. Starting from the Taylor series definition around a point $x$, derive a fourth-order accurate central difference stencil for approximating $u'(x)$ that uses the values $u(x-2h)$, $u(x-h)$, $u(x+h)$, and $u(x+2h)$ only. Explicitly compute the leading truncation error term of this stencil in terms of $u^{(5)}(x)$ and $h$. Express your final result as symbolic analytical expressions. No numerical rounding is required for the final answer, and no physical units are needed since the expressions are dimensionless with respect to the variables involved.",
            "solution": "The problem as stated is valid. It is a well-posed mathematical derivation task, grounded in the standard principles of numerical analysis as applied in scientific computing, such as computational materials science. The terminology is precise, and the objective is clear and achievable. All necessary information is provided.\n\nWe are tasked with deriving a fourth-order accurate central difference stencil for the first derivative, $u'(x)$, using the function values at points $x-2h$, $x-h$, $x+h$, and $x+2h$. We must also find the leading term of the truncation error.\n\nLet the approximation of $u'(x)$ be denoted by $D_h[u](x)$. We seek a linear combination of the given function values:\n$$\nD_h[u](x) = A u(x-2h) + B u(x-h) + C u(x+h) + D u(x+2h)\n$$\nThe problem specifies a central difference stencil, which implies symmetry. For a first-derivative approximation, this symmetry manifests as antisymmetry in the coefficients: $D = -A$ and $C = -B$. The stencil does not use the point $u(x)$, which is satisfied by this formulation.\n\nTo determine the coefficients $A$, $B$, $C$, and $D$, we expand each term $u(x+kh)$ in a Taylor series around the point $x$. We require the final expression to approximate $u'(x)$ with a truncation error of order $\\mathcal{O}(h^4)$. We expand up to the fifth derivative to find the leading error term.\n\nThe Taylor series expansions are:\n$$\nu(x+h) = u(x) + h u'(x) + \\frac{h^2}{2!} u''(x) + \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) + \\frac{h^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nu(x-h) = u(x) - h u'(x) + \\frac{h^2}{2!} u''(x) - \\frac{h^3}{3!} u'''(x) + \\frac{h^4}{4!} u^{(4)}(x) - \\frac{h^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nu(x+2h) = u(x) + (2h) u'(x) + \\frac{(2h)^2}{2!} u''(x) + \\frac{(2h)^3}{3!} u'''(x) + \\frac{(2h)^4}{4!} u^{(4)}(x) + \\frac{(2h)^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n$$\nu(x-2h) = u(x) - (2h) u'(x) + \\frac{(2h)^2}{2!} u''(x) - \\frac{(2h)^3}{3!} u'''(x) + \\frac{(2h)^4}{4!} u^{(4)}(x) - \\frac{(2h)^5}{5!} u^{(5)}(x) + \\mathcal{O}(h^6)\n$$\n\nSubstitute these expansions into the expression for $D_h[u](x)$ and group terms by derivatives of $u(x)$:\n\\begin{align*}\nD_h[u](x) = u(x)  (A+B+C+D) \\\\\n+ u'(x)  h(-2A-B+C+2D) \\\\\n+ u''(x)  \\frac{h^2}{2}(4A+B+C+4D) \\\\\n+ u'''(x)  \\frac{h^3}{6}(-8A-B+C+8D) \\\\\n+ u^{(4)}(x)  \\frac{h^4}{24}(16A+B+C+16D) \\\\\n+ u^{(5)}(x)  \\frac{h^5}{120}(-32A-B+C+32D) + \\mathcal{O}(h^6)\n\\end{align*}\n\nFor $D_h[u](x)$ to be a consistent approximation of $u'(x)$, the coefficient of $u'(x)$ must be $1$, and the coefficients of other derivatives (up to the desired order of accuracy) must be $0$.\n\n1.  Coefficient of $u(x)$: $A+B+C+D = 0$. With $D=-A$ and $C=-B$, this is $A+B-B-A=0$, which is automatically satisfied.\n2.  Coefficient of $u'(x)$: $h(-2A-B+C+2D) = 1$. Using symmetry, $h(-2A-B-B-2A) = h(-4A-2B)=1$. So, $4A+2B = -1/h$.\n3.  Coefficient of $u''(x)$: $\\frac{h^2}{2}(4A+B+C+4D) = \\frac{h^2}{2}(4A+B-B-4A)=0$. This is also automatically satisfied by the symmetry conditions.\n4.  Coefficient of $u'''(x)$: We want the scheme to be at least second-order accurate, so this term's coefficient must be zero. $\\frac{h^3}{6}(-8A-B+C+8D) = \\frac{h^3}{6}(-8A-B-B-8A) = \\frac{h^3}{6}(-16A-2B) = 0$. This gives $16A+2B=0$.\n5.  Coefficient of $u^{(4)}(x)$: $\\frac{h^4}{24}(16A+B+C+16D) = \\frac{h^4}{24}(16A+B-B-16A)=0$. This term also vanishes due to symmetry. This means that if we eliminate the $u'''(x)$ term, the method will automatically be fourth-order accurate.\n\nWe now solve the system of two linear equations for $A$ and $B$:\n$$\n\\begin{cases}\n4A+2B = -1/h \\\\\n16A+2B = 0\n\\end{cases}\n$$\nFrom the second equation, $2B = -16A$, which implies $B = -8A$.\nSubstituting this into the first equation:\n$$\n4A + 2(-8A) = -1/h \\implies 4A - 16A = -1/h \\implies -12A = -1/h \\implies A = \\frac{1}{12h}\n$$\nNow we find the other coefficients:\n$$\nB = -8A = -8\\left(\\frac{1}{12h}\\right) = -\\frac{8}{12h} = -\\frac{2}{3h}\n$$\n$$\nC = -B = \\frac{2}{3h}\n$$\n$$\nD = -A = -\\frac{1}{12h}\n$$\nSubstituting these coefficients back into the formula for $D_h[u](x)$:\n$$\nD_h[u](x) = \\frac{1}{12h}u(x-2h) - \\frac{2}{3h}u(x-h) + \\frac{2}{3h}u(x+h) - \\frac{1}{12h}u(x+2h)\n$$\nThis can be written more compactly as:\n$$\nD_h[u](x) = \\frac{-u(x+2h) + 8u(x+h) - 8u(x-h) + u(x-2h)}{12h}\n$$\nThis is the desired fourth-order central difference stencil for $u'(x)$.\n\nNow, we compute the leading truncation error term. The truncation error $T(h)$ is defined as $T(h) = D_h[u](x) - u'(x)$. The leading term of this error comes from the first non-zero term in the Taylor expansion after the $u'(x)$ term. We have constructed the stencil to make the coefficients of $u(x)$, $u''(x)$, $u'''(x)$, and $u^{(4)}(x)$ equal to zero. The next term is from $u^{(5)}(x)$. The leading error term is thus:\n$$\nT_{lead} = \\left(\\text{coefficient of } u^{(5)}(x) \\text{ in the expansion of } D_h[u](x)\\right) \\times u^{(5)}(x)\n$$\n$$\nT_{lead} = \\frac{h^5}{120}(-32A-B+C+32D) u^{(5)}(x)\n$$\nSubstitute the values for $A, B, C, D$:\n$$\nT_{lead} = \\frac{h^5}{120} \\left(-32\\left(\\frac{1}{12h}\\right) - \\left(-\\frac{8}{12h}\\right) + \\left(\\frac{8}{12h}\\right) + 32\\left(-\\frac{1}{12h}\\right)\\right) u^{(5)}(x)\n$$\n$$\nT_{lead} = \\frac{h^5}{120 \\cdot 12h} (-32 + 8 + 8 - 32) u^{(5)}(x)\n$$\n$$\nT_{lead} = \\frac{h^4}{1440} (-48) u^{(5)}(x) = -\\frac{48}{1440} h^4 u^{(5)}(x)\n$$\nSimplifying the fraction $\\frac{48}{1440} = \\frac{4}{120} = \\frac{1}{30}$.\nThus, the leading truncation error term is:\n$$\nT_{lead} = -\\frac{1}{30}h^4 u^{(5)}(x)\n$$\nThe order of accuracy is indeed $\\mathcal{O}(h^4)$, as required. The full approximation is $D_h[u](x) = u'(x) - \\frac{1}{30} h^4 u^{(5)}(x) + \\mathcal{O}(h^6)$.\n\nThe problem asks for symbolic analytical expressions for the final result, which consists of the stencil and the leading truncation error term.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{-u(x+2h) + 8u(x+h) - 8u(x-h) + u(x-2h)}{12h}  -\\frac{1}{30}h^4 u^{(5)}(x) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Many properties in materials science, such as the total electron count within an atomic sphere, are calculated by integrating a field over a specific volume. This practice demonstrates a crucial bridge between the physics of a problem and its numerical solution. You will learn how to transform a three-dimensional integral in spherical coordinates into a one-dimensional integral on a standard interval, preparing it for highly efficient numerical quadrature methods like Gauss-Legendre quadrature .",
            "id": "3471289",
            "problem": "In atom-centered numerical integration that arises in computational materials science, for example in evaluating the electron number enclosed within a muffin-tin sphere in Kohn–Sham density functional theory (DFT), one frequently reduces a three-dimensional integral over a spherically symmetric field to a one-dimensional radial integral. Let the spherically symmetric density be $\\,\\rho(r)\\,$, and define the enclosed amount\n$$\nN(R) \\equiv \\int_{|\\mathbf{r}|\\le R} \\rho(|\\mathbf{r}|)\\, d^3 r \\, .\n$$\nBy spherical symmetry this equals\n$$\nN(R) = 4\\pi \\int_{0}^{R} r^2 \\rho(r)\\, dr \\, .\n$$\nYou wish to approximate $\\,N(R)\\,$ using an $\\,N$-point Gauss–Legendre quadrature on the interval $\\,[-1,1]\\,$ by applying the change of variables $\\,r=\\phi(t)\\,$ with $\\,\\phi(t)=\\frac{R}{2}(1+t)\\,$. Starting only from the change-of-variables theorem for integrals and the definition of the spherical-coordinate volume element, derive the explicit expression for the transformed quadrature weight that multiplies the function value $\\,\\rho(\\phi(t_i))\\,$ at a Gauss–Legendre node $\\,t_i\\,$ with canonical Gauss–Legendre weight $\\,w_i\\,$. Express your final result as a single closed-form expression in terms of $\\,R\\,$, $\\,t_i\\,$, and $\\,w_i\\,$. Do not perform any numerical approximation. The final answer must be a single symbolic expression.",
            "solution": "The objective is to derive the transformed quadrature weight for the numerical evaluation of the enclosed amount, $N(R)$, of a spherically symmetric field $\\rho(r)$. The evaluation involves transforming a one-dimensional radial integral to the canonical interval $[-1, 1]$ for Gauss–Legendre quadrature.\n\nWe begin with the fundamental definition of the enclosed amount $N(R)$ as a volume integral over a sphere of radius $R$:\n$$\nN(R) = \\int_{|\\mathbf{r}|\\le R} \\rho(|\\mathbf{r}|)\\, d^3 r\n$$\nThe problem specifies that the derivation must start from the definition of the spherical-coordinate volume element. In spherical coordinates $(r, \\theta, \\phi)$, the position vector is $\\mathbf{r}$ and its magnitude is $|\\mathbf{r}| = r$. The infinitesimal volume element is $d^3 r = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$. The density $\\rho$ is a function of $r$ only. The integral becomes:\n$$\nN(R) = \\int_{0}^{R} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\rho(r) r^2 \\sin\\theta \\, d\\phi \\, d\\theta \\, dr\n$$\nSince the integrand is independent of $\\phi$ and $\\theta$, the angular integrals can be evaluated separately:\n$$\n\\int_{0}^{2\\pi} d\\phi = 2\\pi\n$$\n$$\n\\int_{0}^{\\pi} \\sin\\theta \\, d\\theta = [-\\cos\\theta]_{0}^{\\pi} = -(\\cos\\pi - \\cos0) = -(-1-1) = 2\n$$\nThe product of these angular integrals is $4\\pi$. Substituting this result, the three-dimensional integral correctly reduces to the one-dimensional radial integral provided in the problem statement:\n$$\nN(R) = 4\\pi \\int_{0}^{R} r^2 \\rho(r)\\, dr\n$$\nThe next step is to apply the change of variables to transform the integration interval from $[0, R]$ to $[-1, 1]$. The specified transformation is:\n$$\nr = \\phi(t) = \\frac{R}{2}(1+t)\n$$\nAccording to the change of variables theorem for integrals, we must find the derivative of this transformation, which is the Jacobian of the mapping:\n$$\n\\frac{dr}{dt} = \\frac{d\\phi}{dt} = \\frac{d}{dt} \\left( \\frac{R}{2}(1+t) \\right) = \\frac{R}{2}\n$$\nThis implies that the differential element transforms as $dr = \\frac{R}{2} dt$. We must also transform the limits of integration.\nFor the lower limit, $r=0$:\n$$\n0 = \\frac{R}{2}(1+t) \\implies 1+t = 0 \\implies t = -1\n$$\nFor the upper limit, $r=R$:\n$$\nR = \\frac{R}{2}(1+t) \\implies 2 = 1+t \\implies t = 1\n$$\nThe new integration interval is indeed $[-1, 1]$, which is the domain for the canonical Gauss–Legendre quadrature.\n\nSubstituting $r=\\phi(t)$, $\\rho(r) = \\rho(\\phi(t))$, and $dr = \\frac{R}{2} dt$ into the expression for $N(R)$:\n$$\nN(R) = 4\\pi \\int_{-1}^{1} [\\phi(t)]^2 \\rho(\\phi(t)) \\left( \\frac{R}{2} \\right) dt\n$$\nNow, we substitute the explicit form of $\\phi(t)$:\n$$\nN(R) = 4\\pi \\int_{-1}^{1} \\left( \\frac{R}{2}(1+t) \\right)^2 \\rho(\\phi(t)) \\left( \\frac{R}{2} \\right) dt\n$$\nLet us group the constant factors and the terms depending on $t$:\n$$\nN(R) = 4\\pi \\left( \\frac{R^2}{4} \\right) \\left( \\frac{R}{2} \\right) \\int_{-1}^{1} (1+t)^2 \\rho(\\phi(t)) \\, dt\n$$\n$$\nN(R) = \\frac{4\\pi R^3}{8} \\int_{-1}^{1} (1+t)^2 \\rho(\\phi(t)) \\, dt\n$$\n$$\nN(R) = \\frac{\\pi R^3}{2} \\int_{-1}^{1} (1+t)^2 \\rho(\\phi(t)) \\, dt\n$$\nThis is the transformed integral. To approximate it numerically, we use an $N$-point Gauss–Legendre quadrature rule, which has the form:\n$$\n\\int_{-1}^{1} f(t) \\, dt \\approx \\sum_{i=1}^{N} w_i f(t_i)\n$$\nwhere $t_i$ are the quadrature nodes (the roots of the $N$-th Legendre polynomial) and $w_i$ are the corresponding canonical weights. In our case, the function to be integrated is $f(t) = (1+t)^2 \\rho(\\phi(t))$.\n\nApplying the quadrature rule to our transformed integral, we obtain the approximation for $N(R)$:\n$$\nN(R) \\approx \\frac{\\pi R^3}{2} \\sum_{i=1}^{N} w_i \\left( (1+t_i)^2 \\rho(\\phi(t_i)) \\right)\n$$\nThe problem asks for the transformed quadrature weight that multiplies the function value $\\rho(\\phi(t_i))$. To identify this, we rearrange the sum as:\n$$\nN(R) \\approx \\sum_{i=1}^{N} \\left[ \\frac{\\pi R^3}{2} w_i (1+t_i)^2 \\right] \\rho(\\phi(t_i))\n$$\nThis is a weighted sum of the function values $\\rho(\\phi(t_i))$ evaluated at the transformed nodes. The term in the square brackets is the complete coefficient for $\\rho(\\phi(t_i))$ at a specific node $t_i$. This is, by definition, the transformed quadrature weight. Denoting this weight as $W_i^{\\text{trans}}$, we have:\n$$\nW_i^{\\text{trans}} = \\frac{\\pi R^3}{2} w_i (1+t_i)^2\n$$\nThis expression is the final result, expressed in terms of the sphere radius $R$, the canonical Gauss-Legendre node $t_i$, and the canonical Gauss-Legendre weight $w_i$.",
            "answer": "$$\n\\boxed{\\frac{\\pi R^{3}}{2} w_i (1+t_i)^{2}}\n$$"
        },
        {
            "introduction": "Calculating thermodynamic properties like pressure often requires differentiating a complex energy expression with respect to volume. This advanced exercise uncovers a subtle but critical challenge: standard finite difference methods can fail when the function's definition involves cutoffs that depend on the differentiation variable. You will compare the traditional finite-difference approach with the more robust and elegant complex-step method, revealing why the latter is a powerful tool for obtaining accurate derivatives in complex simulation codes like those using Ewald summation .",
            "id": "3471273",
            "problem": "You are given a neutral, periodically replicated, cubic crystal containing two point charges in reduced, dimensionless units. The charges are $q_1=+1$ and $q_2=-1$. Their fractional positions in the unit cell are fixed at $\\mathbf{s}_1=(0,0,0)$ and $\\mathbf{s}_2=(0.5,0,0)$, so that their Cartesian positions are $\\mathbf{r}_i=\\mathbf{s}_i L$ where $L$ is the cubic box length. Consider the Ewald-split configurational free energy (which equals the potential energy at zero temperature), denoted $F(V)$ with $V=L^3$, with conducting boundary conditions. The total energy is given by the standard, well-tested Ewald decomposition into a real-space sum, a reciprocal-space sum, and the self term:\n$$\nF(V)=\\frac{1}{2}\\sum_{i=1}^N\\sum_{j=1}^N\\sum_{\\mathbf{n}\\in\\mathbb{Z}^3}^{\\prime} \\frac{q_i q_j\\,\\operatorname{erfc}(\\alpha \\lVert \\mathbf{r}_{ij}+\\mathbf{n}L\\rVert)}{\\lVert \\mathbf{r}_{ij}+\\mathbf{n}L\\rVert} + \\frac{1}{2V}\\sum_{\\mathbf{k}\\neq \\mathbf{0}} \\frac{4\\pi}{\\lVert \\mathbf{k}\\rVert^2}e^{-\\lVert \\mathbf{k}\\rVert^2/(4\\alpha^2)} \\left|\\sum_{j=1}^N q_j e^{i\\mathbf{k}\\cdot \\mathbf{r}_j}\\right|^2 - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2,\n$$\nwhere $\\mathbf{r}_{ij}=\\mathbf{r}_j-\\mathbf{r}_i$, $\\alpha$ is the Ewald splitting parameter, and the prime on the lattice sum indicates omission of the $\\mathbf{n}=\\mathbf{0}$ term when $i=j$. The reciprocal-space vectors are $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{m}$ with $\\mathbf{m}\\in\\mathbb{Z}^3\\setminus\\{\\mathbf{0}\\}$.\n\nYour task is to compute the volume derivative of the free energy at fixed fractional coordinates, which defines the mechanical pressure via $P=-\\partial F/\\partial V$, using two numerical differentiation strategies:\n- Complex-step differentiation: approximate $\\partial F/\\partial V$ by $\\operatorname{Im}\\left(F(V+i h_c)\\right)/h_c$ for a very small positive $h_c$, treating $L=(V)^{1/3}$ as a complex variable when evaluating $F$.\n- Central finite differences: approximate $\\partial F/\\partial V$ by $\\left(F(V+h_f)-F(V-h_f)\\right)/(2h_f)$ for a small positive $h_f$.\n\nIn practical Ewald implementations, the real and reciprocal sums are truncated. To study how the analytic differentiation interacts with truncation and long-range corrections, implement two truncation policies for each of the two sums:\n\n- For the reciprocal-space sum:\n  1. Index-space truncation: include all integer triplets $\\mathbf{m}=(m_x,m_y,m_z)$ with $\\max(|m_x|,|m_y|,|m_z|)\\le n_k$ and exclude $\\mathbf{m}=\\mathbf{0}$. This set is independent of $L$.\n  2. Absolute wavevector truncation: include all $\\mathbf{m}$ such that $\\lVert \\mathbf{k}\\rVert=\\frac{2\\pi}{L}\\lVert \\mathbf{m}\\rVert \\le k_{\\mathrm{cut}}$. This set depends on $L$.\n\n- For the real-space sum:\n  1. Index-space truncation: include all lattice triplets $\\mathbf{n}=(n_x,n_y,n_z)$ with $\\max(|n_x|,|n_y|,|n_z|)\\le n_r$, excluding the self $\\mathbf{n}=\\mathbf{0}$ when $i=j$. This set is independent of $L$.\n  2. Absolute distance truncation: include only terms with $\\lVert \\mathbf{r}_{ij}+\\mathbf{n}L\\rVert\\le r_{\\mathrm{cut}}$. This set depends on $L$.\n\nWhen applying complex-step differentiation with absolute cutoffs, make the inclusion decisions for the truncation sets using the real value of $L$ (that is, the set selection must not depend on the imaginary part), but evaluate the energy contributions using the complex $L$; for index-space truncations the sets are independent of $L$. This models the usual code-path analyticity and isolates the interaction of analytic differentiation with set changes.\n\nWork in reduced, dimensionless units throughout; do not convert to any physical units. Hold the fractional coordinates $\\mathbf{s}_i$ fixed when varying $V$.\n\nImplement the above for the fixed parameter $\\alpha=4$. Use the following test suite of parameter sets, where each test case is a tuple $(L, \\text{k-policy}, \\text{k-parameter}, \\text{r-policy}, \\text{r-parameter}, h_f, h_c)$:\n- Test $1$: $(1.4,\\ \\text{index},\\ n_k=2,\\ \\text{index},\\ n_r=2,\\ 10^{-6},\\ 10^{-20})$.\n- Test $2$: $(1.55,\\ \\text{abs},\\ k_{\\mathrm{cut}}=7.0,\\ \\text{abs},\\ r_{\\mathrm{cut}}=1.6,\\ 10^{-6},\\ 10^{-20})$.\n- Test $3$: $(1.59,\\ \\text{abs},\\ k_{\\mathrm{cut}}=7.0,\\ \\text{index},\\ n_r=2,\\ 10^{-6},\\ 10^{-20})$.\n- Test $4$: $(1.30,\\ \\text{index},\\ n_k=2,\\ \\text{abs},\\ r_{\\mathrm{cut}}=1.6,\\ 10^{-6},\\ 10^{-20})$.\n\nFor each test case:\n- Compute $V=L^3$.\n- Compute $\\partial F/\\partial V$ using complex-step with step $h_c$ and central differences with step $h_f$, under the specified truncation policies.\n- Return, for each test case, the absolute value of the difference between the two approximations, namely $\\left|\\left(\\partial F/\\partial V\\right)_{\\mathrm{cs}}-\\left(\\partial F/\\partial V\\right)_{\\mathrm{fd}}\\right|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the floating-point result for test $i$ in the order given above. No additional text should be printed.",
            "solution": "The user's request is a valid scientific problem.\n\n### Step 1: Extract Givens\n- **System**: A neutral, cubic crystal with a single unit cell.\n- **Particles**: Two point charges, $N=2$.\n- **Charges**: $q_1 = +1$, $q_2 = -1$.\n- **Fractional Positions**: $\\mathbf{s}_1 = (0,0,0)$, $\\mathbf{s}_2 = (0.5,0,0)$.\n- **Cartesian Positions**: $\\mathbf{r}_i = \\mathbf{s}_i L$, where $L$ is the cubic box length.\n- **Volume**: $V = L^3$.\n- **Free Energy**: $F(V)$ is given by the Ewald summation formula under conducting boundary conditions:\n$$\nF(V)=\\frac{1}{2}\\sum_{i=1}^N\\sum_{j=1}^N\\sum_{\\mathbf{n}\\in\\mathbb{Z}^3}^{\\prime} \\frac{q_i q_j\\,\\operatorname{erfc}(\\alpha \\lVert \\mathbf{r}_{ij}+\\mathbf{n}L\\rVert)}{\\lVert \\mathbf{r}_{ij}+\\mathbf{n}L\\rVert} + \\frac{1}{2V}\\sum_{\\mathbf{k}\\neq \\mathbf{0}} \\frac{4\\pi}{\\lVert \\mathbf{k}\\rVert^2}e^{-\\lVert \\mathbf{k}\\rVert^2/(4\\alpha^2)} \\left|\\sum_{j=1}^N q_j e^{i\\mathbf{k}\\cdot \\mathbf{r}_j}\\right|^2 - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2\n$$\n- **Reciprocal Vectors**: $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{m}$ with $\\mathbf{m}\\in\\mathbb{Z}^3\\setminus\\{\\mathbf{0}\\}$.\n- **Ewald Parameter**: $\\alpha = 4$.\n- **Task**: Compute $\\partial F/\\partial V$ at fixed fractional coordinates using two methods.\n    1.  **Complex-Step Differentiation (CS)**: $\\frac{\\operatorname{Im}\\left(F(V+i h_c)\\right)}{h_c}$.\n    2.  **Central Finite-Differences (FD)**: $\\frac{F(V+h_f)-F(V-h_f)}{2h_f}$.\n- **Truncation Policies**:\n    - Reciprocal Sum:\n        1.  `index`: $\\max(|m_x|,|m_y|,|m_z|) \\le n_k$.\n        2.  `abs`: $\\lVert \\mathbf{k}\\rVert \\le k_{\\mathrm{cut}}$.\n    - Real-Space Sum:\n        1.  `index`: $\\max(|n_x|,|n_y|,|n_z|) \\le n_r$.\n        2.  `abs`: $\\lVert \\mathbf{r}_{ij}+\\mathbf{n}L\\rVert\\le r_{\\mathrm{cut}}$.\n- **Special Rule**: For complex-step differentiation with `abs` cutoffs, the set of terms included in the sum is determined by the real part of $L$, while the energy evaluation uses the full complex $L$.\n- **Test Cases**:\n    1.  $(L=1.4, \\text{k-policy}=\\text{'index'}, n_k=2, \\text{r-policy}=\\text{'index'}, n_r=2, h_f=10^{-6}, h_c=10^{-20})$\n    2.  $(L=1.55, \\text{k-policy}=\\text{'abs'}, k_{\\mathrm{cut}}=7.0, \\text{r-policy}=\\text{'abs'}, r_{\\mathrm{cut}}=1.6, h_f=10^{-6}, h_c=10^{-20})$\n    3.  $(L=1.59, \\text{k-policy}=\\text{'abs'}, k_{\\mathrm{cut}}=7.0, \\text{r-policy}=\\text{'index'}, n_r=2, h_f=10^{-6}, h_c=10^{-20})$\n    4.  $(L=1.30, \\text{k-policy}=\\text{'index'}, n_k=2, \\text{r-policy}=\\text{'abs'}, r_{\\mathrm{cut}}=1.6, h_f=10^{-6}, h_c=10^{-20})$\n- **Output**: For each test case, compute and return the absolute difference $|\\left(\\partial F/\\partial V\\right)_{\\mathrm{cs}}-\\left(\\partial F/\\partial V\\right)_{\\mathrm{fd}}|$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically and mathematically sound.\n- **Scientifically Grounded**: The problem uses the standard Ewald summation method, a cornerstone of molecular simulation for calculating long-range electrostatic interactions in periodic systems. The formula and context are correct.\n- **Well-Posed**: The problem is well-defined. It asks for a specific numerical calculation based on a complete set of provided parameters and clear instructions. A unique numerical solution exists for each test case.\n- **Objective**: The problem is stated in precise, objective language without ambiguity.\n- **Self-Contained and Consistent**: All necessary constants, equations, boundary conditions (implicitly, via the Ewald formula for conducting boundaries), and parameters for each test case are provided. There are no contradictions.\n- **Not Ill-Posed**: The core of the problem is to highlight the different behaviors of complex-step and finite-difference methods when applied to functions whose definitions (truncation sets) depend on the variable of differentiation. This is a subtle but important topic in numerical analysis and computational science. The `abs` cutoff policies introduce discontinuities in the truncated energy's derivative, which the finite-difference method handles poorly, while the complex-step method (with the specified rule) correctly yields the derivative of the function within a contiguous analytic region. The expected large difference between the two methods for `abs` policies is the point of the exercise.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Principle-Based Design\n\nThe task is to compute the volume derivative of the Ewald free energy, $\\partial F/\\partial V$, using two distinct numerical methods: complex-step and central finite differences. The core challenge lies in the implementation of the Ewald summation with four different truncation schemes, two for the real-space sum and two for the reciprocal-space sum.\n\nThe Ewald energy $F(V)$ is a function of the volume $V = L^3$. Its derivative can be found via the chain rule, but the problem requests a direct numerical differentiation with respect to $V$. We must therefore express all $L$-dependent terms as functions of $V^{1/3}$.\n\nA central function, `_compute_F`, will be designed to calculate the Ewald energy $F$ for a given volume $V$, which can be a real or complex number. This function encapsulates the three components of the Ewald energy: the self-interaction term ($F_{\\text{self}}$), the real-space sum ($F_{\\text{real}}$), and the reciprocal-space sum ($F_{\\text{recip}}$).\n\n1.  **Complex-Step (CS) Derivative**: This method leverages the Cauchy-Riemann equations. For an analytic function $f(z)$, the derivative $f'(x)$ at a real point $x$ can be approximated to machine precision by $\\operatorname{Im}[f(x+ih)]/h$ for a very small step $h$. We will compute $F(V+ih_c)$, where $V$ is the real volume and $h_c$ is a small imaginary perturbation. The function `_compute_F` must correctly handle complex arguments for $V$, and consequently for $L=V^{1/3}$. Libraries like `numpy` and `scipy` provide complex-aware versions of necessary functions (e.g., `sqrt`, `exp`, `erfc`).\n\n2.  **Central Finite-Difference (FD) Derivative**: This is a standard numerical approximation, $\\frac{F(V+h_f) - F(V-h_f)}{2h_f}$. It involves evaluating the function at two real points bracketing $V$. This method is susceptible to subtractive cancellation errors for small $h_f$ and truncation errors for large $h_f$.\n\nThe critical aspect of the implementation is handling the specified truncation policies, especially the `abs` (absolute cutoff) policies.\n\n-   **`index` policies**: The summation is over a fixed set of integer vectors ($\\mathbf{m}$ or $\\mathbf{n}$) determined by $n_k$ or $n_r$. The set of terms is independent of $L$ (and thus $V$). The truncated energy function is analytic with respect to $V$. For this policy, the CS and FD methods are expected to yield very similar results, with the difference limited by the FD truncation error ($O(h_f^2)$) and machine precision.\n\n-   **`abs` policies**: The summation is over terms whose inclusion depends on a cutoff distance ($r_{\\text{cut}}$ or $k_{\\text{cut}}$) and the box length $L$. For instance, the reciprocal-space sum includes vectors $\\mathbf{m}$ such that $\\frac{2\\pi}{L}\\lVert \\mathbf{m}\\rVert \\le k_{\\mathrm{cut}}$. As $L$ changes, the set of included $\\mathbf{m}$ vectors can change. This makes the truncated energy function piecewise, with discontinuities in its derivative at values of $L$ where terms are added or removed.\n    -   When using FD, the evaluations at $V+h_f$ and $V-h_f$ may use different sets of summed terms if a boundary is crossed, leading to a large, unphysical derivative approximation.\n    -   The problem specifies a crucial rule for CS with `abs` cutoffs: the decision to include a term is based on $\\operatorname{Re}(L)$, but the term's value is computed with the full complex $L$. This ensures that for the infinitesimal imaginary step $ih_c$, the set of included terms remains fixed, making the function analytic along the imaginary axis. The CS method thus correctly computes the derivative of the energy function *within* one of the piecewise segments, avoiding the pathology seen by the FD method.\n\nThe implementation will therefore feature a main loop over the test cases. For each case, it will call `_compute_F` with the appropriate arguments to obtain the CS and FD derivatives and then compute their absolute difference. The `_compute_F` function will calculate all three energy terms, carefully implementing the logic for the four truncation policies and the special rule for complex-step with absolute cutoffs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nimport itertools\n\ndef _compute_F(V, alpha, q_charges, s_positions, k_policy, k_param, r_policy, r_param):\n    \"\"\"\n    Computes the truncated Ewald free energy F(V).\n    The input V can be real or complex. The implementation is designed to handle\n    the special rules for complex-step differentiation with absolute cutoffs.\n    \n    Args:\n        V (float or complex): The volume of the unit cell.\n        alpha (float): The Ewald splitting parameter.\n        q_charges (np.ndarray): Array of point charges.\n        s_positions (np.ndarray): Array of fractional coordinates.\n        k_policy (str): Reciprocal-space truncation policy ('index' or 'abs').\n        k_param (float): Reciprocal-space truncation parameter (n_k or k_cut).\n        r_policy (str): Real-space truncation policy ('index' or 'abs').\n        r_param (float): Real-space truncation parameter (n_r or r_cut).\n\n    Returns:\n        complex: The complex-valued Ewald energy.\n    \"\"\"\n    # Ensure V is a complex number to allow for unified complex arithmetic\n    V = complex(V)\n    L = V**(1/3.0)\n    L_real = L.real\n    N_particles = len(q_charges)\n\n    # --- Self-energy Term (F_self) ---\n    # This term is constant with respect to V.\n    E_self = -alpha / np.sqrt(np.pi) * np.sum(q_charges**2)\n\n    # --- Reciprocal-space Term (F_recip) ---\n    E_recip = 0.0 + 0.0j\n    \n    # Determine reciprocal-space loop bounds based on the policy\n    if k_policy == 'index':\n        m_max = int(k_param)\n    elif k_policy == 'abs':\n        # Choose a safe upper bound for m indices to ensure all vectors\n        # within the k_cut sphere are checked.\n        m_max = int(np.ceil(L_real * k_param / (2 * np.pi)))\n    else:\n        raise ValueError(f\"Unknown k-policy: {k_policy}\")\n\n    m_indices = range(-m_max, m_max + 1)\n    \n    for mx, my, mz in itertools.product(m_indices, repeat=3):\n        if mx == 0 and my == 0 and mz == 0:\n            continue\n        \n        m_vec = np.array([mx, my, mz], dtype=float)\n        m_sq = np.dot(m_vec, m_vec)\n        \n        # For 'abs' policy, check if the k-vector is within the cutoff sphere.\n        # As per problem, this inclusion decision uses the REAL part of L.\n        if k_policy == 'abs':\n            k_sq_check = m_sq * (2 * np.pi / L_real)**2\n            if k_sq_check  k_param**2 or k_sq_check == 0:\n                continue\n\n        # Compute structure factor S(k) = sum_j q_j * exp(i*k.r_j)\n        # k.r_j = (2*pi/L * m) . (s_j * L) = 2*pi * (m . s_j)\n        # The evaluation of the exponential must use the complex L via L in k.r_j.\n        k_dot_r_j_arg = 2j * np.pi * np.dot(s_positions, m_vec)\n        S_k = np.sum(q_charges * np.exp(k_dot_r_j_arg))\n        \n        # Compute the energy term using the full COMPLEX L.\n        k_sq_complex = m_sq * (2 * np.pi / L)**2\n        term_recip = (4 * np.pi / k_sq_complex) * np.exp(-k_sq_complex / (4 * alpha**2))\n        E_recip += term_recip * (S_k * S_k.conj()).real  # |S(k)|^2 is always real\n\n    E_recip /= (2.0 * V)\n\n    # --- Real-space Term (F_real) ---\n    E_real = 0.0 + 0.0j\n\n    # Determine real-space loop bounds based on the policy\n    if r_policy == 'index':\n        n_max = int(r_param)\n    elif r_policy == 'abs':\n        # Choose a safe upper bound for n indices. Max fractional dist |s_ij| is 0.5.\n        s_ij_max_norm = 0.5 \n        n_max = int(np.ceil(r_param / L_real + s_ij_max_norm)) + 1\n    else:\n        raise ValueError(f\"Unknown r-policy: {r_policy}\")\n        \n    n_indices = range(-n_max, n_max + 1)\n    \n    # Sum over particle pairs (i, j)\n    for i in range(N_particles):\n        for j in range(N_particles):\n            s_ij = s_positions[j] - s_positions[i]\n            \n            # Sum over lattice vectors n\n            for nx, ny, nz in itertools.product(n_indices, repeat=3):\n                # Omit n=0 for i=j self-interaction term\n                if i == j and nx == 0 and ny == 0 and nz == 0:\n                    continue\n                \n                n_vec = np.array([nx, ny, nz], dtype=float)\n                disp_frac = s_ij + n_vec\n                disp_frac_norm = np.linalg.norm(disp_frac)\n                \n                # For 'abs' policy, check cutoff using the REAL part of L.\n                if r_policy == 'abs':\n                    dist_real_check = disp_frac_norm * L_real\n                    if dist_real_check  r_param:\n                        continue\n                \n                # If term is included, evaluate its contribution using the full COMPLEX L.\n                dist_norm_complex = disp_frac_norm * L\n                \n                if abs(dist_norm_complex)  1e-12: # Avoid division by zero\n                    term_real = erfc(alpha * dist_norm_complex) / dist_norm_complex\n                    E_real += q_charges[i] * q_charges[j] * term_real\n\n    E_real *= 0.5\n\n    return E_real + E_recip + E_self\n\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print the results for all test cases.\n    \"\"\"\n    # Fixed parameters for the Ewald summation from the problem statement\n    ALPHA = 4.0\n    Q_CHARGES = np.array([1.0, -1.0])\n    S_POSITIONS = np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0]])\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, k-policy, k-parameter, r-policy, r-parameter, h_f, h_c)\n        (1.4, 'index', 2, 'index', 2, 1e-6, 1e-20),\n        (1.55, 'abs', 7.0, 'abs', 1.6, 1e-6, 1e-20),\n        (1.59, 'abs', 7.0, 'index', 2, 1e-6, 1e-20),\n        (1.30, 'index', 2, 'abs', 1.6, 1e-6, 1e-20),\n    ]\n\n    results = []\n    for L_val, k_policy, k_param, r_policy, r_param, h_f, h_c in test_cases:\n        V = L_val**3\n\n        # --- Compute Complex-Step Derivative ---\n        # Evaluate F at V + i*h_c\n        V_c = V + 1j * h_c\n        F_c = _compute_F(V_c, ALPHA, Q_CHARGES, S_POSITIONS, k_policy, k_param, r_policy, r_param)\n        dFdV_cs = F_c.imag / h_c\n\n        # --- Compute Central Finite-Difference Derivative ---\n        # Evaluate F at V + h_f and V - h_f (real-valued arguments)\n        V_plus = V + h_f\n        V_minus = V - h_f\n        F_plus = _compute_F(V_plus, ALPHA, Q_CHARGES, S_POSITIONS, k_policy, k_param, r_policy, r_param)\n        F_minus = _compute_F(V_minus, ALPHA, Q_CHARGES, S_POSITIONS, k_policy, k_param, r_policy, r_param)\n        dFdV_fd = (F_plus.real - F_minus.real) / (2 * h_f)\n\n        # Calculate the absolute difference between the two derivative approximations\n        diff = abs(dFdV_cs - dFdV_fd)\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}