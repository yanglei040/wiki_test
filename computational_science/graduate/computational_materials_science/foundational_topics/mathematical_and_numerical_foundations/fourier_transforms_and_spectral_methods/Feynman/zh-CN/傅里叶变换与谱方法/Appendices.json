{
    "hands_on_practices": [
        {
            "introduction": "掌握谱方法的第一步是理解其如何处理导数。这个练习将通过一个基础但至关重要的任务来指导你：使用快速傅里叶变换（FFT）计算一个周期函数的导数。通过将物理空间中的微分操作转换成傅里叶空间中的简单乘法，你将亲身体验到谱方法在计算光滑函数导数时无与伦比的精度。",
            "id": "3387455",
            "problem": "考虑在区间 $[0,2\\pi)$ 上的一个周期性网格，由 $x_j = \\frac{2\\pi j}{N}$ 定义，其中 $j \\in \\{0,1,\\dots,N-1\\}$，$N \\in \\mathbb{N}$，且角度以弧度为单位。设所有网格点上的值为 $u_j = \\sin(5 x_j)$。目标是使用快速傅里叶变换 (FFT) 计算离散导数 $v = D u$，其中 $D$ 表示作用于 $2\\pi$ 周期函数网格值上的傅里叶微分矩阵。推导和计算必须基于第一性原理：从等距网格上的 $2\\pi$ 周期三角插值多项式的离散傅里叶变换的定义出发，并且仅使用傅里叶级数和线性算子的基本性质。本问题不允许使用任何预先推导的微分公式。\n\n你的任务是编写一个完整的、可运行的程序，该程序能够：\n- 构建网格 $x_j = \\frac{2\\pi j}{N}$ 和数据 $u_j = \\sin(5 x_j)$。\n- 通过将 $u$ 变换到傅里叶空间，在该基中应用与周期性设置一致的微分算子，然后变换回物理空间，来计算傅里叶微分矩阵 $D$ 对 $u$ 的作用。\n- 数值上验证所计算的离散导数 $v_j$ 在机器精度内等于解析导数 $5 \\cos(5 x_j)$，并报告每个测试用例的最大绝对误差 $\\max_j |v_j - 5\\cos(5 x_j)|$。\n\n角度使用弧度。不涉及物理单位。答案必须表示为实值浮点数。\n\n测试套件：\n- 使用网格大小集合 $N \\in \\{11, 12, 64, 128, 1001\\}$ 来测试不同的情况，包括允许的最小网格 ($N=11$)、具有奈奎斯特模式的偶数网格 ($N=12$) 以及分辨率较高的大网格 ($N=64$、$N=128$、$N=1001$) 。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试套件的最大绝对误差，格式为方括号括起来的逗号分隔列表。例如，输出必须采用 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_5]$ 的形式，其中每个 $\\text{result}_i$ 是按顺序 $[11,12,64,128,1001]$ 对应的 $N$ 值的最大绝对误差。",
            "solution": "该问题被评估为有效。它在科学上基于傅里叶分析和谱方法的原理，问题提法清晰且提供了所有必要信息，并且表述客观。解法如下。\n\n问题的核心是使用傅里叶谱方法在周期性网格上计算函数 $u(x)$ 的导数。该方法依赖于用三角多项式来表示函数，然后在频域中执行微分，在频域中微分运算简化为乘法运算。该过程包括三个主要步骤：将函数从物理域变换到频域，在频域中应用微分算子，以及将结果变换回物理域。\n\n设定义域为区间 $[0, 2\\pi)$，由 $N$ 个等距点 $x_j = \\frac{2\\pi j}{N}$（$j \\in \\{0, 1, \\dots, N-1\\}$）进行离散化。该网格上的函数值为 $u_j = u(x_j)$。对于本问题，$u(x) = \\sin(5x)$，因此 $u_j = \\sin(5x_j)$。\n\n**原理1：三角插值**\n\n这 $N$ 个数据点 $(x_j, u_j)$ 唯一确定一个阶数至多为 $\\lfloor N/2 \\rfloor$ 的三角插值多项式 $p(x)$，使得对所有 $j$ 都有 $p(x_j) = u_j$。该插值多项式可以表示为一个有限复傅里叶级数：\n$$\np(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx}\n$$\n其中 $\\mathbb{K}_N$ 是适用于大小为 $N$ 的网格的整数波数集合。\n当 $N$ 为奇数时，$\\mathbb{K}_N = \\{-(N-1)/2, \\dots, (N-1)/2\\}$。\n当 $N$ 为偶数时，$\\mathbb{K}_N = \\{-N/2+1, \\dots, N/2\\}$。模式 $k=-N/2$ 在网格上与 $k=N/2$ 发生混叠，它们通常被合并成一个单一的余弦项。\n\n复傅里叶系数 $\\hat{u}_k$ 通过离散傅里叶变换 (DFT) 与网格值 $u_j$ 相关联。标准定义为：\n$$\n\\hat{u}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-ikx_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-i k \\frac{2\\pi j}{N}}\n$$\n\n**原理2：傅里叶域中的微分**\n\n傅里叶表示法的关键优势在于，函数在物理空间中的微分对应于其傅里叶系数在频域中与 $ik$ 的简单乘法。将插值多项式 $p(x)$ 对 $x$ 求导可得：\n$$\nv(x) = p'(x) = \\frac{d}{dx} \\left( \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx} \\right)\n$$\n根据线性性质，我们可以交换微分和求和的顺序：\n$$\nv(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k \\frac{d}{dx} (e^{ikx}) = \\sum_{k \\in \\mathbb{K}_N} (ik) \\hat{u}_k e^{ikx}\n$$\n这表明导数的傅里叶系数（记为 $\\hat{v}_k$）由下式给出：\n$$\n\\hat{v}_k = ik \\hat{u}_k\n$$\n网格上导数的值 $v_j = v(x_j)$，可以通过计算这个新的级数来找到，这等价于对系数 $\\hat{v}_k$ 执行逆离散傅里叶变换 (IDFT)。\n\n**使用快速傅里叶变换 (FFT) 的算法实现**\n\nDFT 和 IDFT 可以使用 FFT 算法高效地计算。流程如下：\n\n1.  **正变换**：给定函数值向量 $u = [u_0, u_1, \\dots, u_{N-1}]$，使用 FFT 算法计算其 DFT。设结果为 $\\hat{U} = \\text{fft}(u)$。像 NumPy 这样的标准数值库计算 $\\hat{U}_m = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi mj / N}$，其中 $m \\in \\{0, \\dots, N-1\\}$。这与我们的物理系数的关系是 $\\hat{u}_k = \\frac{1}{N}\\hat{U}_k$，其中 FFT 索引 $m$ 映射到物理波数 $k$。\n\n2.  **波数向量**：必须构建与 FFT 输出排序相对应的物理波数向量 $k$。对于一个 $N$ 点 FFT，当 $N$ 为偶数时，波数为 $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$；当 $N$ 为奇数时，波数为 $k \\in \\{0, 1, \\dots, (N-1)/2, -(N-1)/2, \\dots, -1\\}$。这个向量可以很容易地使用像 `numpy.fft.fftfreq(N) * N` 这样的库函数生成。\n\n3.  **应用微分算子**：导数的傅里叶系数 $\\hat{v}_k$ 通过逐元素乘法计算：$\\hat{v}_k = ik \\hat{u}_k$。用 FFT 未归一化的系数表示，即为 $\\hat{V}_k = ik \\hat{U}_k$。当 $N$ 为偶数时，在奈奎斯特频率处会出现一个特殊情况，该频率对应于波数 $k=N/2$（或根据约定为 $k=-N/2$）。一个实值信号在网格上的插值多项式对于该模式仅包含 $\\cos((N/2)x)$ 分量。这个余弦函数的导数 $-(N/2)\\sin((N/2)x)$ 在所有网格点 $x_j$ 上均为零。因此，为了得到一个稳健的微分算法，奈奎斯特频率系数的乘子必须设置为 $0$。\n\n4.  **逆变换**：网格上的导数值 $v = [v_0, v_1, \\dots, v_{N-1}]$ 是通过对修改后的系数 $\\hat{V}$ 应用逆 FFT 得到的：$v = \\text{ifft}(\\hat{V})$。由于实函数的导数是实数，结果中任何残留的虚部都是由浮点误差引起的，应当被舍弃。\n\n**验证**\n计算出的离散导数 $v_j$ 与 $u(x) = \\sin(5x)$ 的解析导数 $u'(x) = 5\\cos(5x)$ 进行比较。计算最大绝对误差 $\\max_j |v_j - 5\\cos(5x_j)|$。由于函数 $\\sin(5x)$ 是带限的，其波数为 $k=5$，并且所有测试用例都使用 $N > 2k = 10$，因此三角插值多项式与函数本身完全相同。因此，傅里叶微分的结果应该在机器精度内是精确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the derivative of u(x) = sin(5x) on a periodic grid\n    using the Fourier spectral method for a suite of grid sizes N,\n    and reports the maximum absolute error against the analytical derivative.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [11, 12, 64, 128, 1001]\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the grid and the function data.\n        # Grid points on [0, 2*pi).\n        x = 2 * np.pi * np.arange(N) / N\n        \n        # Function values on the grid for u(x) = sin(5x).\n        u = np.sin(5 * x)\n        \n        # Analytical derivative u'(x) = 5*cos(5x) on the grid for verification.\n        u_analytic_deriv = 5 * np.cos(5 * x)\n        \n        # Step 2: Transform to Fourier space using FFT.\n        # This gives the un-normalized Fourier coefficients.\n        u_hat = np.fft.fft(u)\n        \n        # Step 3: Apply the differentiation operator in Fourier space.\n        \n        # Generate the vector of physical wavenumbers corresponding to the FFT output array.\n        # np.fft.fftfreq(N) returns frequencies f_k = k/N.\n        # Multiplying by N gives the integer wavenumbers k.\n        wavenumbers = np.fft.fftfreq(N) * N\n        \n        # The differentiation operator in Fourier space is multiplication by ik.\n        d_hat = 1j * wavenumbers\n        \n        # For even N, the Nyquist frequency component requires special handling.\n        # The derivative of the cos(N/2 * x) basis function is zero on the grid points.\n        # Therefore, the corresponding multiplier must be set to 0.\n        # In numpy's fftfreq, the Nyquist frequency corresponds to index N//2.\n        if N % 2 == 0:\n            d_hat[N // 2] = 0.0\n            \n        # Apply the differentiation operator.\n        v_hat = d_hat * u_hat\n        \n        # Step 4: Transform back to physical space using inverse FFT.\n        v = np.fft.ifft(v_hat)\n        \n        # The result should be real. We take the real part to discard\n        # any small imaginary noise from floating-point inaccuracies.\n        v_real = v.real\n        \n        # Step 5: Verify the result by comparing with the analytical derivative.\n        # Calculate the maximum absolute error across all grid points.\n        max_error = np.max(np.abs(v_real - u_analytic_deriv))\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # The map function converts each float error into a string for joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本导数运算后，我们将这一概念应用于计算材料科学中的一个核心物理量：动能。这个练习要求你验证一个标量场的动能在实空间（通过谱方法计算梯度）和倒易空间（通过傅里叶系数求和）中的表达式是等价的。这不仅是帕萨瓦尔定理（Parseval's theorem）在数值计算中的直接体现，也是确保物理模拟守恒性的关键验证步骤。",
            "id": "3453307",
            "problem": "考虑一个标量场 $\\psi(\\mathbf{r})$，该场定义在一个边长为 $L$ 的三维周期性立方体上，并具有周期性边界条件。设体积为 $V = L^3$，且该场在均匀网格上采样，每个维度的点数分别为 $N_x$、$N_y$ 和 $N_z$，因此总网格点数为 $N = N_x N_y N_z$，网格间距为 $d_x = L/N_x$，$d_y = L/N_y$，$d_z = L/N_z$。将每个维度的离散角倒易晶格矢量定义为\n$$\nG_x(m_x) = \\frac{2\\pi m_x}{L},\\quad G_y(m_y) = \\frac{2\\pi m_y}{L},\\quad G_z(m_z) = \\frac{2\\pi m_z}{L},\n$$\n其中 $m_x$、$m_y$ 和 $m_z$ 是与离散傅里叶变换网格索引相关的整数。对应的三维波矢为 $\\mathbf{G} = \\left(G_x, G_y, G_z\\right)$，其大小为 $|\\mathbf{G}| = \\sqrt{G_x^2+G_y^2+G_z^2}$。\n\n设傅里叶级数系数定义为\n$$\n\\tilde{\\psi}(\\mathbf{G}) = \\frac{1}{V}\\int_V \\psi(\\mathbf{r})\\,e^{-i\\mathbf{G}\\cdot \\mathbf{r}}\\,d\\mathbf{r},\n$$\n傅里叶表示为\n$$\n\\psi(\\mathbf{r}) = \\sum_{\\mathbf{G}} \\tilde{\\psi}(\\mathbf{G})\\,e^{i\\mathbf{G}\\cdot \\mathbf{r}}.\n$$\n在数值实践中，通过网格上的黎曼和来近似积分，并使用快速傅里叶变换 (FFT) 计算离散变换。全文使用无量纲单位；$L$、$\\mathbf{G}$ 和能量均被视为无量纲量。\n\n你的任务是验证在平面波截断下，场的动能在实空间和倒易空间中表达式的一致性。具体而言：\n\n1. 通过仅为满足 $|\\mathbf{G}| \\le G_{\\text{cut}}$ 的 $\\mathbf{G}$ 指定其傅里叶系数 $\\tilde{\\psi}(\\mathbf{G})$，并将其余系数 $\\tilde{\\psi}(\\mathbf{G})$ 设为 0，来构造一个复数场 $\\psi(\\mathbf{r})$。为保证可复现性，使用固定的随机种子生成非零系数作为独立的复随机值。\n\n2. 通过以下公式将 FFT 输出 $\\Psi(\\mathbf{G})$ 与傅里叶级数系数关联起来\n$$\n\\tilde{\\psi}(\\mathbf{G}) \\approx \\frac{1}{N}\\,\\Psi(\\mathbf{G}),\n$$\n这与均匀网格上的积分离散化以及逆 FFT 包含 $1/N$ 因子的 FFT 归一化约定相一致。\n\n3. 通过谱梯度法计算实空间动能：\n   - 分别通过对 $i G_x \\Psi(\\mathbf{G})$、$i G_y \\Psi(\\mathbf{G})$ 和 $i G_z \\Psi(\\mathbf{G})$ 进行逆 FFT 来计算梯度分量，从而得到 $\\partial_x \\psi(\\mathbf{r})$、$\\partial_y \\psi(\\mathbf{r})$ 和 $\\partial_z \\psi(\\mathbf{r})$。\n   - 通过求和来近似积分：\n   $$\n   E_{\\text{real}} \\approx dV \\sum_{\\text{grid}} \\left|\\nabla \\psi(\\mathbf{r})\\right|^2 = dV \\sum_{\\text{grid}} \\left(\\left|\\partial_x \\psi\\right|^2 + \\left|\\partial_y \\psi\\right|^2 + \\left|\\partial_z \\psi\\right|^2\\right),\n   $$\n   其中 $dV = V/N$。\n\n4. 使用离散系数和截断值计算倒易空间动能：\n   $$\n   E_{\\text{recip}} \\approx V \\sum_{|\\mathbf{G}|\\le G_{\\text{cut}}} |\\mathbf{G}|^2\\,\\left|\\tilde{\\psi}(\\mathbf{G})\\right|^2 = V \\sum_{|\\mathbf{G}|\\le G_{\\text{cut}}} |\\mathbf{G}|^2\\,\\frac{\\left|\\Psi(\\mathbf{G})\\right|^2}{N^2}.\n   $$\n\n对于每个测试用例，报告其相对差异\n$$\n\\delta = \n\\begin{cases}\n\\frac{\\left|E_{\\text{real}} - E_{\\text{recip}}\\right|}{E_{\\text{real}}}   \\text{if } E_{\\text{real}} > 0, \\\\\n0   \\text{if } E_{\\text{real}} = 0 \\text{ and } E_{\\text{recip}} = 0, \\\\\n\\text{undefined}   \\text{otherwise},\n\\end{cases}\n$$\n其中未定义的情况不会在提供的测试套件中出现。\n\n实现一个程序，对以下测试套件执行此验证，其中每个测试用例以 $(L, N_x, N_y, N_z, G_{\\text{cut}}, \\text{seed})$ 的形式给出：\n\n- $(7.5, 32, 32, 32, 6.0, 123)$\n- $(5.0, 24, 20, 18, 8.0, 456)$\n- $(12.0, 16, 16, 16, 1.0, 789)$\n- $(9.0, 40, 36, 28, 20.0, 101112)$\n- $(10.0, 30, 30, 30, 0.0, 42)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5]”）。每个结果必须是表示相应测试用例的 $\\delta$ 值的浮点数。全文使用无量纲单位，不要打印任何额外文本。",
            "solution": "问题陈述是有效的。它提出了一个来自计算材料科学领域的适定且有科学依据的任务，即验证计算标量场动能的两种方法在数值上的等效性。这种等效性是帕塞瓦尔定理应用于离散傅里叶变换及其关于导数的性质的直接结果。该问题没有矛盾、歧义和事实错误。\n\n解决方案是通过为每个测试用例实现指定的计算来推进的。任务的核心是一个数值验证，其结果应显示两个能量值 $E_{\\text{real}}$ 和 $E_{\\text{recip}}$ 之间的差异接近于零，仅受浮点精度限制。\n\n**1. 倒易空间网格生成**\n\n首先，我们建立与实空间离散化相对应的离散倒易空间网格。对于在 $N_x \\times N_y \\times N_z$ 网格上采样的边长为 $L$ 的周期性立方体，倒易空间波矢 $\\mathbf{G} = (G_x, G_y, G_z)$ 的分量由下式给出：\n$$\nG_u(m_u) = \\frac{2\\pi m_u}{L} \\quad \\text{for } u \\in \\{x,y,z\\}\n$$\n其中 $m_u$ 是表示离散傅里叶变换 (DFT) 频率索引的整数。对于大小为 $N_u$ 的网格，索引 $m_u$ 通常按 $m_u = 0, 1, \\dots, N_u/2-1, -N_u/2, \\dots, -1$ 的顺序排列。在实现中，这些整数索引是使用 `numpy.fft.fftfreq(Nu) * Nu` 生成的。然后，使用 meshgrid 将这些一维波矢分量数组提升为三维数组 $G_x, G_y, G_z$。由此，可以计算出倒易网格中每个点的平方大小 $|\\mathbf{G}|^2 = G_x^2 + G_y^2 + G_z^2$。\n\n**2. 在倒易空间中构造场**\n\n问题指定通过定义傅里叶系数 $\\tilde{\\psi}(\\mathbf{G})$ 来构造一个复标量场 $\\psi(\\mathbf{r})$。对于离散网格，我们使用 DFT 系数 $\\Psi(\\mathbf{G})$，它通过 $\\tilde{\\psi}(\\mathbf{G}) \\approx \\Psi(\\mathbf{G})/N$ 与 $\\tilde{\\psi}(\\mathbf{G})$ 相关联，其中 $N=N_x N_y N_z$。\n\n该场的构造方式使其傅里叶表示仅包含波矢大小直到某个截断值 $|\\mathbf{G}| \\le G_{\\text{cut}}$ 的分量。这通过以下步骤实现：\n- 初始化一个大小为 $N_x \\times N_y \\times N_z$ 的复值三维数组 $\\Psi(\\mathbf{G})$，并用零填充。\n- 创建一个布尔掩码，以识别所有满足条件 $|\\mathbf{G}| \\le G_{\\text{cut}}$ 的网格点。\n- 为所有网格点生成独立的复随机数。\n- 仅在掩码指示的位置用这些随机数填充数组 $\\Psi(\\mathbf{G})$。\n\n为确保可复现性，每个案例都使用固定的随机种子。由于问题指定了一个复数场 $\\psi(\\mathbf{r})$，因此无需强制执行纯实值场所需的厄米共轭对称性 $\\Psi(-\\mathbf{G}) = \\Psi^*(\\mathbf{G})$。\n\n**3. 倒易空间动能计算**\n\n倒易空间中的动能由所有波矢的加权和给出，权重为其大小的平方：\n$$\nE_{\\text{recip}} = V \\sum_{\\mathbf{G}} |\\mathbf{G}|^2 |\\tilde{\\psi}(\\mathbf{G})|^2\n$$\n使用离散近似 $\\tilde{\\psi}(\\mathbf{G}) \\approx \\Psi(\\mathbf{G})/N$ 并注意到对于 $|\\mathbf{G}| > G_{\\text{cut}}$ 时 $\\Psi(\\mathbf{G})=0$，表达式变为：\n$$\nE_{\\text{recip}} \\approx V \\sum_{|\\mathbf{G}| \\le G_{\\text{cut}}} |\\mathbf{G}|^2 \\frac{|\\Psi(\\mathbf{G})|^2}{N^2} = \\frac{V}{N^2} \\sum_{\\mathbf{G}} |\\mathbf{G}|^2 |\\Psi(\\mathbf{G})|^2\n$$\n这是通过将预先计算的 $|\\mathbf{G}|^2$ 数组与 $|\\Psi(\\mathbf{G})|^2$ 进行逐元素相乘，对结果在整个网格上求和，并按因子 $V/N^2$ 进行缩放来计算的。\n\n**4. 实空间动能计算**\n\n实空间中的动能是梯度大小平方的体积积分：\n$$\nE_{\\text{real}} = \\int_V |\\nabla \\psi(\\mathbf{r})|^2 d\\mathbf{r}\n$$\n谱方法利用傅里叶微分定理来计算梯度分量，该定理指出实空间中的微分对应于倒易空间中乘以 $i\\mathbf{G}$。\n$$\n\\nabla \\psi(\\mathbf{r}) = \\mathcal{F}^{-1}[i\\mathbf{G} \\Psi(\\mathbf{G})]\n$$\n其中 $\\mathcal{F}^{-1}$ 表示逆 FFT。算法如下：\n- 计算每个梯度分量的傅里叶表示：$iG_x\\Psi(\\mathbf{G})$、$iG_y\\Psi(\\mathbf{G})$ 和 $iG_z\\Psi(\\mathbf{G})$。\n- 对其中每一个应用逆三维 FFT，以获得实空间网格上的梯度分量 $\\partial_x\\psi$、$\\partial_y\\psi$ 和 $\\partial_z\\psi$。\n- 通过对网格点求和来近似积分：\n$$\nE_{\\text{real}} \\approx dV \\sum_{\\text{grid}} |\\nabla \\psi(\\mathbf{r})|^2 = \\frac{V}{N} \\sum_{\\text{grid}} \\left( |\\partial_x\\psi|^2 + |\\partial_y\\psi|^2 + |\\partial_z\\psi|^2 \\right)\n$$\n这是通过取每个梯度分量数组的绝对值的平方，将它们相加，对结果在所有网格点上求和，并乘以实空间体积元 $dV=V/N$ 来计算的。\n\n**5. 通过帕塞瓦尔定理进行验证**\n\nDFT 的帕塞瓦尔定理指出，信号大小平方的和与其变换大小平方的和成正比。对于 `numpy` FFT 约定，$\\sum_n |x_n|^2 = \\frac{1}{N} \\sum_k |X_k|^2$。将此应用于 $E_{\\text{real}}$ 的表达式：\n$$\n\\sum_{\\text{grid}} |\\partial_x\\psi|^2 = \\frac{1}{N} \\sum_{\\mathbf{G}} |\\mathcal{F}[\\partial_x\\psi]|^2 = \\frac{1}{N} \\sum_{\\mathbf{G}} |iG_x\\Psi(\\mathbf{G})|^2 = \\frac{1}{N} \\sum_{\\mathbf{G}} G_x^2 |\\Psi(\\mathbf{G})|^2\n$$\n将此代入 $E_{\\text{real}}$ 的方程：\n$$\nE_{\\text{real}} \\approx \\frac{V}{N} \\left( \\frac{1}{N} \\sum_{\\mathbf{G}} (G_x^2+G_y^2+G_z^2) |\\Psi(\\mathbf{G})|^2 \\right) = \\frac{V}{N^2} \\sum_{\\mathbf{G}} |\\mathbf{G}|^2 |\\Psi(\\mathbf{G})|^2\n$$\n这个最终表达式在代数上与 $E_{\\text{recip}}$ 的表达式相同。因此，两个计算值应该在浮点精度误差范围内是相同的。\n\n**6. 相对差异**\n\n相对差异 $\\delta$ 按问题陈述中的定义计算。对于 $G_{\\text{cut}}=0$ 的特殊情况，只有 $\\mathbf{G}=0$ 模式可以非零。由于此模式下 $|\\mathbf{G}|^2=0$，因此 $E_{\\text{real}}$ 和 $E_{\\text{recip}}$ 都将恰好为 $0$，相应地 $\\delta$ 也取为 $0$。对于所有其他情况，$E_{\\text{real}}$ 将为正，相对差异可作为数值精度的度量。我们预期 $\\delta$ 的数量级与机器ε（约 $10^{-16}$）相当。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying the consistency between real-space and \n    reciprocal-space kinetic energy calculations for a scalar field.\n    \"\"\"\n    \n    test_cases = [\n        (7.5, 32, 32, 32, 6.0, 123),\n        (5.0, 24, 20, 18, 8.0, 456),\n        (12.0, 16, 16, 16, 1.0, 789),\n        (9.0, 40, 36, 28, 20.0, 101112),\n        (10.0, 30, 30, 30, 0.0, 42)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, Nx, Ny, Nz, G_cut, seed = case\n        \n        # 1. Define constants and grid parameters\n        V = L**3\n        N = Nx * Ny * Nz\n        dV = V / N\n        \n        # Set the random seed for reproducibility\n        np.random.seed(seed)\n\n        # 2. Generate Reciprocal Space Grid (G-vectors)\n        # The integer frequency indices m_u for the DFT\n        mx = np.fft.fftfreq(Nx) * Nx\n        my = np.fft.fftfreq(Ny) * Ny\n        mz = np.fft.fftfreq(Nz) * Nz\n        \n        # Angular wavevector components: G_u = 2*pi*m_u/L\n        Gx_1d = (2 * np.pi / L) * mx\n        Gy_1d = (2 * np.pi / L) * my\n        Gz_1d = (2 * np.pi / L) * mz\n\n        # Create 3D grid of wavevectors\n        Gx, Gy, Gz = np.meshgrid(Gx_1d, Gy_1d, Gz_1d, indexing='ij')\n\n        # Calculate the squared magnitude |G|^2 and magnitude |G| for each grid point\n        G_squared = Gx**2 + Gy**2 + Gz**2\n        G_mag = np.sqrt(G_squared)\n\n        # 3. Construct the field in Reciprocal Space (Psi)\n        # Create a mask for the spherical cutoff\n        mask = G_mag = G_cut\n        \n        shape = (Nx, Ny, Nz)\n        # Generate independent complex random values\n        random_coeffs = np.random.rand(*shape) + 1j * np.random.rand(*shape)\n        \n        # Initialize the field in Fourier space and apply the cutoff mask\n        Psi = np.zeros(shape, dtype=complex)\n        Psi[mask] = random_coeffs[mask]\n        \n        # 4. Calculate Reciprocal Space Kinetic Energy (E_recip)\n        # E_recip is defined as V * sum(|G|^2 * |psi_tilde|^2)\n        # where psi_tilde = Psi / N.\n        # So, E_recip = V * sum(|G|^2 * |Psi|^2 / N^2)\n        E_recip = (V / (N**2)) * np.sum(G_squared * np.abs(Psi)**2)\n\n        # 5. Calculate Real Space Kinetic Energy (E_real)\n        # Compute gradient components using the spectral method via inverse FFT\n        grad_x_psi = np.fft.ifftn(1j * Gx * Psi)\n        grad_y_psi = np.fft.ifftn(1j * Gy * Psi)\n        grad_z_psi = np.fft.ifftn(1j * Gz * Psi)\n\n        # Sum the squared magnitudes of the gradient components at each real-space grid point\n        grad_psi_sq_mag = np.abs(grad_x_psi)**2 + np.abs(grad_y_psi)**2 + np.abs(grad_z_psi)**2\n        \n        # Approximate the energy integral by summing over the grid and multiplying by dV\n        E_real = dV * np.sum(grad_psi_sq_mag)\n        \n        # 6. Calculate the relative difference delta\n        if E_real > 0:\n            delta = np.abs(E_real - E_recip) / E_real\n        elif E_real == 0 and E_recip == 0:\n            delta = 0.0\n        else:\n            # This case is stated not to occur. It could only arise from significant floating point error\n            # where one value is zero and the other is a small non-zero artifact.\n            # We assign NaN for robustness, though it won't appear in the final output for the given tests.\n            delta = np.nan\n        \n        results.append(delta)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的物理系统很少是纯线性的，因此处理非线性项是谱方法应用中的一个关键挑战。这个练习将揭示在计算如 $\\phi(x)^3$ 这样的非线性项时，朴素的伪谱方法为何会因“混叠”（aliasing）效应而产生错误。你将学习并实现一种标准的“去混叠”（de-aliasing）技术——零填充法（zero-padding），这是确保非线性模拟结果可靠性的重要实践技能。",
            "id": "3453340",
            "problem": "考虑一个长度为 $2\\pi$ 的一维周期性域，其中有一个由有限傅里叶级数表示的实值场 $\\phi(x)$。在伪谱离散化中，非线性项在实空间中逐点求值，然后使用快速傅里叶变换（FFT）变换回傅里叶空间。FFT 是计算离散傅里叶变换（DFT）的一种高效算法。当乘积涉及非线性幂（例如三次项 $N(x) = \\phi(x)^3$）时，傅里叶模态的离散卷积会产生新的模态，其波数可能超过所选网格的奈奎斯特极限。这会导致混叠现象，即无法分辨的高频模态的贡献会折叠回低频，从而污染所表示的谱。\n\n您的任务是实现并比较三种计算三次非线性项 $N(x) = \\phi(x)^3$ 的策略：\n- 一种朴素伪谱方法，它在 $N$ 个点的粗网格上计算 $\\phi(x)^3$，并使用 DFT 将结果变换回傅里叶空间。\n- 一种填充因子为 $3/2$ 的补零法，其中粗网格上 $\\phi$ 的傅里叶系数被对称地填充到长度 $N_{\\mathrm{pad}} = \\frac{3}{2}N$，变换到实空间，在实空间中相乘，然后变换回傅里叶空间并截断至原始的 $N$ 个模态。\n- 一种填充因子为 $2$ 的补零法，其过程与前述方法相同，但使用 $N_{\\mathrm{pad}} = 2N$。\n\n该问题的理论基础是 DFT 的卷积定理：实空间中乘积的 DFT 是傅里叶空间中 DFT 系数的离散卷积。对于三次非线性，一个最大波数为 $K_{\\max}$ 的有限带宽场会产生高达 $3K_{\\max}$ 的谱内容。在一个有 $N$ 个点的网格上，奈奎斯特波数为 $N/2$（对于一个 $2\\pi$ 周期域，以整数模态计数），因此如果 $3K_{\\max} > N/2$，朴素计算中将会发生混叠。\n\n定义离散空间点为 $x_j = \\frac{2\\pi j}{N}$，其中 $j = 0,1,\\dots,N-1$。设场 $\\phi(x)$ 由具有整数波数的正弦和余弦的有限和构成：\n$$\n\\phi(x) = \\sum_{m} a_m \\cos(k_m x) + \\sum_{n} b_n \\sin(q_n x),\n$$\n其中 $k_m$ 和 $q_n$ 是非负整数。对于每个测试用例，根据其模态规格直接在实空间中构造 $\\phi(x)$。\n\n为了评估混叠和去混叠的准确性，需要为 $N(x) = \\phi(x)^3$ 定义一个参考谱。该谱通过在一个足够精细的、包含 $N_{\\mathrm{ref}}$ 个点的网格上对 $\\phi(x)$ 进行采样来获得。选择 $N_{\\mathrm{ref}}$ 的值，使得 $\\phi(x)^3$ 中预期的最高波数严格低于参考网格的奈奎斯特频率。一个充分条件是 $N_{\\mathrm{ref}} \\ge 2 \\cdot 3K_{\\max} + 2$。在这个精细网格上计算 $\\phi(x)^3$ 的 DFT，用 $N_{\\mathrm{ref}}$ 进行归一化，然后投影到粗网格可分辨的傅里叶波数上（即对应于从 $-N/2$ 到 $N/2-1$ 的整数波数的中央 $N$ 个模态）。将这个投影后的谱视为粗网格的无混叠参考。\n\n对于这三种方法（朴素法、3/2 补零法和 2 倍补零法）中的每一种，计算 $N(x) = \\phi(x)^3$ 的归一化 DFT 系数（将 FFT 结果除以该方法使用的网格长度），将其重排为中心化的谱，并提取中央的 $N$ 个系数。将参考系数记为 $\\hat{N}_{\\mathrm{ref}}$，方法计算出的系数记为 $\\hat{N}_{\\mathrm{method}}$。对于每种方法和每个测试用例，计算相对误差\n$$\n\\varepsilon = \\frac{\\left\\|\\hat{N}_{\\mathrm{method}} - \\hat{N}_{\\mathrm{ref}}\\right\\|_2}{\\left\\|\\hat{N}_{\\mathrm{ref}}\\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 表示复系数向量上的欧几里得范数。\n\n在一个单一程序中实现上述过程，并将其应用于以下测试套件，其中每个用例指定了粗网格大小 $N$ 和 $\\phi(x)$ 的模态：\n- 用例 1 (易混叠的混合模态): $N = 64$，$\\phi(x) = 1.0\\cos(21x) + 0.5\\cos(7x) + 0.3\\sin(5x)$。\n- 用例 2 (无混叠的低阶模态): $N = 64$，$\\phi(x) = 1.0\\cos(5x) + 0.3\\sin(3x)$。\n- 用例 3 (小网格，严重混叠): $N = 32$，$\\phi(x) = 0.8\\cos(10x) + 0.6\\sin(9x)$。\n- 用例 4 (近奈奎斯特的混合模态): $N = 96$，$\\phi(x) = 1.0\\cos(31x) + 0.4\\cos(30x)$。\n\n对于每个用例，计算三个浮点数：朴素方法的相对误差、3/2 补零方法的相对误差和 2 倍补零方法的相对误差。您的程序应生成单行输出，其中包含四个用例的所有结果。这些结果应按用例和方法的顺序列出，展平为一个列表，并以逗号分隔，置于方括号内。将每个浮点数四舍五入到六位小数。例如，输出格式必须严格如下所示\n[$e_{1,\\mathrm{naive}}$, $e_{1,3/2}$, $e_{1,2}$, $e_{2,\\mathrm{naive}}$, $e_{2,3/2}$, $e_{2,2}$, $e_{3,\\mathrm{naive}}$, $e_{3,3/2}$, $e_{3,2}$, $e_{4,\\mathrm{naive}}$, $e_{4,3/2}$, $e_{4,2}$]，其中符号被数值替换。\n\n此问题不涉及物理单位；所有量均为无量纲。角度以弧度为单位。程序必须是自包含的，不得读取输入；运行时应打印指定的单行输出。",
            "solution": "本问题要求对三种伪谱方法进行比较分析，这些方法用于计算长度为 $2\\pi$ 的一维周期域上三次非线性项 $N(x) = \\phi(x)^3$ 的傅里叶变换。问题的核心是量化由非线性项引起的混叠误差，并评估基于补零的去混叠技术的有效性。\n\n伪谱方法的理论基础是离散傅里叶变换（DFT）和卷积定理。在一个包含 $N$ 个点的均匀网格（$x_j = 2\\pi j/N$，其中 $j=0, 1, \\dots, N-1$）上离散化的函数 $\\phi(x)$，可以用其 DFT 系数 $\\hat{\\phi}_k$ 来表示，这些系数对应于一组有限的整数波数。对于偶数个网格点 $N$，这些波数通常取为 $k \\in \\{-N/2, \\dots, N/2 - 1\\}$。\n\n实空间中函数的乘积对应于傅里叶空间中其系数的卷积。具体来说，乘积 $\\phi(x)^3$ 的 DFT 等效于谱 $\\hat{\\phi}_k$ 与自身的三重离散卷积：\n$$\n\\widehat{\\phi^3}_k = (\\hat{\\phi} \\star \\hat{\\phi} \\star \\hat{\\phi})_k = \\sum_{p+q+r=k \\pmod N} \\hat{\\phi}_p \\hat{\\phi}_q \\hat{\\phi}_r\n$$\n如果场 $\\phi(x)$ 包含最高达 $K_{\\max}$ 的波数，则三次乘积 $\\phi(x)^3$ 将会产生高达 $3K_{\\max}$ 的新波数。如果 $3K_{\\max}$ 超过网格的奈奎斯特波数 $k_{\\mathrm{Nyq}} = N/2$，来自这些不可分辨的高波数的能量会被错误地“折叠回”较低的可分辨波数上。这种现象称为混叠，它会污染计算出的谱。\n\n解决方案通过为四个不同的测试用例实现并比较三种指定方法与一个高保真度参考解来进行。\n\n**1. 参考谱 ($\\hat{N}_{\\mathrm{ref}}$)**\n为了建立一个未被混叠污染的基准真相，函数 $\\phi(x)^3$ 在一个显著更精细的网格上进行求值。选择一个大小为 $N_{\\mathrm{ref}}$ 的参考网格，使其奈奎斯特频率大于由非线性产生的最高可能波数，即 $N_{\\mathrm{ref}}/2 \\ge 3K_{\\max}$。问题给出了充分条件 $N_{\\mathrm{ref}} \\ge 6K_{\\max} + 2$。我们选择 $N_{\\mathrm{ref}}=512$，这个值对所有测试用例都足够。步骤如下：\n- 在包含 $N_{\\mathrm{ref}}$ 个点的精细网格上构造场 $\\phi(x)$。\n- 在此精细网格上逐点计算三次项 $\\phi(x)^3$。\n- 计算其 DFT 并用网格大小 $N_{\\mathrm{ref}}$进行归一化，以获得精细谱 $\\hat{N}_{\\mathrm{fine}}$。\n- 通过从 $\\hat{N}_{\\mathrm{fine}}$ 中提取与粗网格可分辨波数（即 $k \\in \\{-N/2, \\dots, N/2 - 1\\}$）相对应的 $N$ 个系数，来获得粗网格的无混叠参考谱 $\\hat{N}_{\\mathrm{ref}}$。\n\n**2. 朴素伪谱方法**\n这是最直接但可能不准确的方法。\n- 在包含 $N$ 个点的粗网格上构造场 $\\phi(x)$。\n- 逐点计算三次项 $\\phi(x)^3$。\n- 得到的混叠谱 $\\hat{N}_{\\mathrm{naive}}$ 是该乘积的 DFT，并用 $N$ 进行归一化。\n每当 $3K_{\\max} > N/2$ 时，该方法都会遭受混叠。\n\n**3. 补零（去混叠）法**\n该方法通过在一个更大的、“填充的”实空间网格中执行乘法来减轻混叠，这对应于在傅里叶空间中为高频模态插入零。\n- 首先，计算粗网格上 $\\phi(x)$ 的 DFT，即 $\\hat{\\phi}$。\n- 创建一个新的、更大的、长度为 $N_{\\mathrm{pad}}$ 的傅里叶系数数组，其中 $N_{\\mathrm{pad}} = \\text{int}(f \\cdot N)$，$f$ 是填充因子（$1.5$ 或 $2$）。将 $\\hat{\\phi}$ 中的原始系数复制到新数组中对应的低波数位置，剩余的高波数位置用零填充。\n- 对这个填充后的谱执行逆 DFT。为了保持场的振幅，结果需要按网格大小的比率 $N_{\\mathrm{pad}}/N$进行缩放。这会在一个包含 $N_{\\mathrm{pad}}$ 个点的更精细网格上产生 $\\phi(x)$ 的一个插值版本。\n- 在这个填充的网格上逐点计算三次项 $\\phi(x)^3$。\n- 计算该乘积的 DFT，并用 $N_{\\mathrm{pad}}$ 进行归一化。\n- 最后，将得到的谱截断回原始的 $N$ 个模态，以得到去混叠的谱 $\\hat{N}_{\\mathrm{method}}$。\n\n对于三次非线性，谱理论表明，只要输入场 $\\phi(x)$ 在原始网格上被完全分辨，填充因子 $f=2$（即将网格点数加倍到 $2N$）就足以完全消除混叠。而因子 $f=3/2$ 虽然是二次非线性的标准配置，但对于三次项通常是不够的，并且在 $3K_{\\max} > (3/2)N/2 = 3N/4$ 的情况下，预计会显示出残余的混叠误差。\n\n**4. 误差度量**\n对于每种方法，其准确性通过方法计算出的谱（$\\hat{N}_{\\mathrm{method}}$）与参考谱（$\\hat{N}_{\\mathrm{ref}}$）之间的 $L_2$（欧几里得）范数相对误差 $\\varepsilon$ 来量化：\n$$\n\\varepsilon = \\frac{\\left\\| \\hat{N}_{\\mathrm{method}} - \\hat{N}_{\\mathrm{ref}} \\right\\|_2}{\\left\\| \\hat{N}_{\\mathrm{ref}} \\right\\|_2}\n$$\n该度量提供了一个单一值，表示计算出的谱与无混叠的理想谱之间的总体偏差。实现将为四个测试用例中的每一个计算朴素法、3/2 补零法和 2 倍补零法的这个误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Implements and compares three pseudo-spectral methods for evaluating the cubic\n    nonlinearity phi^3, calculating the relative error of each against a\n    high-resolution reference to assess aliasing and de-aliasing effectiveness.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, [(1.0, 'cos', 21), (0.5, 'cos', 7), (0.3, 'sin', 5)]),\n        (64, [(1.0, 'cos', 5), (0.3, 'sin', 3)]),\n        (32, [(0.8, 'cos', 10), (0.6, 'sin', 9)]),\n        (96, [(1.0, 'cos', 31), (0.4, 'cos', 30)])\n    ]\n\n    all_results = []\n\n    def build_phi(x_grid, modes):\n        \"\"\"Constructs the real-valued field phi(x) on a given grid.\"\"\"\n        phi = np.zeros_like(x_grid, dtype=float)\n        for amp, func_type, k in modes:\n            if func_type == 'cos':\n                phi += amp * np.cos(k * x_grid)\n            elif func_type == 'sin':\n                phi += amp * np.sin(k * x_grid)\n        return phi\n\n    for N, modes in test_cases:\n        # ---- 1. Determine Parameters and Grids ----\n        K_max = max(k for _, _, k in modes) if modes else 0\n        \n        # Reference grid must resolve wavenumbers up to 3*K_max.\n        # Required: N_ref >= 6*K_max + 2.\n        # Max K_max is 31 (case 4), so N_ref must be >= 6*31 + 2 = 188.\n        # Let's choose a safe, large power of 2 sufficient for all cases.\n        N_ref = 512\n        x_ref = (2 * np.pi / N_ref) * np.arange(N_ref)\n        \n        x_coarse = (2 * np.pi / N) * np.arange(N)\n        half_N = N // 2\n        \n        # ---- 2. Compute Reference Spectrum ----\n        phi_ref = build_phi(x_ref, modes)\n        N_ref_real = phi_ref**3\n        N_hat_ref_full = fft.fft(N_ref_real) / N_ref\n        \n        # Project onto the coarse grid's wavenumbers by truncation\n        N_hat_ref = np.zeros(N, dtype=complex)\n        N_hat_ref[0:half_N] = N_hat_ref_full[0:half_N]\n        N_hat_ref[half_N:] = N_hat_ref_full[N_ref - half_N:]\n\n        # ---- 3. Naive Method ----\n        phi_coarse = build_phi(x_coarse, modes)\n        N_naive_real = phi_coarse**3\n        N_hat_naive = fft.fft(N_naive_real) / N\n        \n        norm_ref = np.linalg.norm(N_hat_ref)\n        if norm_ref == 0: # Avoid division by zero for null fields\n            norm_ref = 1.0\n\n        err_naive = np.linalg.norm(N_hat_naive - N_hat_ref) / norm_ref\n        all_results.append(f\"{err_naive:.6f}\")\n\n        # ---- 4. Padded Methods ----\n        phi_hat_coarse = fft.fft(phi_coarse)\n\n        for pad_factor in [1.5, 2.0]:\n            N_pad = int(N * pad_factor)\n            \n            # Pad Fourier coefficients with zeros for high frequencies\n            phi_hat_padded = np.zeros(N_pad, dtype=complex)\n            phi_hat_padded[0:half_N] = phi_hat_coarse[0:half_N]\n            phi_hat_padded[N_pad - half_N:] = phi_hat_coarse[half_N:]\n\n            # Transform to padded real space, compute cube, transform back\n            # The scaling factor restores the amplitude of the interpolated signal.\n            phi_padded = fft.ifft(phi_hat_padded) * (N_pad / N)\n            \n            # The signal phi is real, so its IFFT should be real.\n            # We take np.real to discard small imaginary parts from numerical error.\n            N_padded_real = np.real(phi_padded)**3\n            \n            N_hat_padded_full = fft.fft(N_padded_real) / N_pad\n            \n            # Truncate back to the coarse grid size\n            N_hat_padded = np.zeros(N, dtype=complex)\n            N_hat_padded[0:half_N] = N_hat_padded_full[0:half_N]\n            N_hat_padded[half_N:] = N_hat_padded_full[N_pad - half_N:]\n\n            err_padded = np.linalg.norm(N_hat_padded - N_hat_ref) / norm_ref\n            all_results.append(f\"{err_padded:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}