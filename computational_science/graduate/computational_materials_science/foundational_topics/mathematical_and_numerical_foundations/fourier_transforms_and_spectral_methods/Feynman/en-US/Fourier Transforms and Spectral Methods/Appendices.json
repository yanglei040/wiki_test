{
    "hands_on_practices": [
        {
            "introduction": "This first practice demonstrates the core principle of spectral methods: the transformation of differential operators into simple algebraic multiplication in Fourier space. By computing the derivative of a simple trigonometric function, you will see firsthand the remarkable accuracy and efficiency of this approach, a cornerstone of spectral simulations. This exercise will build your intuition for how functions are represented and manipulated in the frequency domain. ",
            "id": "3387455",
            "problem": "Consider a periodic grid on the interval $[0,2\\pi)$ defined by $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0,1,\\dots,N-1\\}$, where $N \\in \\mathbb{N}$ and angles are measured in radians. Let $u_j = \\sin(5 x_j)$ for all grid points. The goal is to compute the discrete derivative $v = D u$ using the Fast Fourier Transform (FFT), where $D$ denotes the Fourier differentiation matrix acting on grid values of a $2\\pi$-periodic function. The derivation and computation must be based on first principles: start from the definition of the discrete Fourier transform of a $2\\pi$-periodic trigonometric interpolant on the equispaced grid, and use only foundational properties of Fourier series and linear operators. No pre-derived differentiation formulas are permitted in the problem statement.\n\nYour task is to write a complete, runnable program that:\n- Constructs the grid $x_j = \\frac{2\\pi j}{N}$ and the data $u_j = \\sin(5 x_j)$.\n- Computes the action of the Fourier differentiation matrix $D$ on $u$ by transforming $u$ to Fourier space, applying the differentiation operator in that basis consistent with the periodic setting, and transforming back to physical space.\n- Verifies numerically that the computed discrete derivative $v_j$ equals the analytical derivative $5 \\cos(5 x_j)$ to machine precision, and reports the maximum absolute error $\\max_j |v_j - 5\\cos(5 x_j)|$ for each test case.\n\nUse angles in radians. No physical units are involved. The answers must be expressed as real-valued floating-point numbers.\n\nTest Suite:\n- Use the set of grid sizes $N \\in \\{11, 12, 64, 128, 1001\\}$ to exercise different regimes, including the smallest allowed grid ($N=11$), even grids with a Nyquist mode ($N=12$), and larger grids where resolution is high ($N=64$, $N=128$, $N=1001$).\n\nFinal Output Format:\n- Your program should produce a single line of output containing the maximum absolute errors for the test suite as a comma-separated list enclosed in square brackets. For example, the output must be of the form $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_5]$, where each $\\text{result}_i$ is the maximum absolute error for the corresponding $N$ in the order $[11,12,64,128,1001]$.",
            "solution": "The problem is evaluated as valid. It is scientifically grounded in the principles of Fourier analysis and spectral methods, is well-posed with all necessary information provided, and is formulated objectively. The solution proceeds as follows.\n\nThe core of the problem is to compute the derivative of a function $u(x)$ on a periodic grid using Fourier spectral methods. This method relies on representing the function by a trigonometric polynomial and then performing differentiation in the frequency domain, where it simplifies to a multiplication operation. The process involves three main steps: transforming the function from the physical domain to the frequency domain, applying the differentiation operator in the frequency domain, and transforming the result back to the physical domain.\n\nLet the domain be the interval $[0, 2\\pi)$, discretized by $N$ equispaced points $x_j = \\frac{2\\pi j}{N}$ for $j \\in \\{0, 1, \\dots, N-1\\}$. The function values on this grid are given by $u_j = u(x_j)$. For this problem, $u(x) = \\sin(5x)$, so $u_j = \\sin(5x_j)$.\n\n**Principle 1: Trigonometric Interpolation**\n\nThe set of $N$ data points $(x_j, u_j)$ uniquely defines a trigonometric polynomial interpolant, $p(x)$, of degree at most $\\lfloor N/2 \\rfloor$, such that $p(x_j) = u_j$ for all $j$. This interpolant can be expressed as a finite complex Fourier series:\n$$\np(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx}\n$$\nwhere $\\mathbb{K}_N$ is the set of integer wavenumbers appropriate for a grid of size $N$.\nFor $N$ odd, $\\mathbb{K}_N = \\{-(N-1)/2, \\dots, (N-1)/2\\}$.\nFor $N$ even, $\\mathbb{K}_N = \\{-N/2+1, \\dots, N/2\\}$. The mode $k=-N/2$ is aliased with $k=N/2$ on the grid, and they are typically combined into a single cosine term.\n\nThe complex Fourier coefficients $\\hat{u}_k$ are related to the grid values $u_j$ by the Discrete Fourier Transform (DFT). The standard definition is:\n$$\n\\hat{u}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-ikx_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-i k \\frac{2\\pi j}{N}}\n$$\n\n**Principle 2: Differentiation in the Fourier Domain**\n\nThe key advantage of the Fourier representation is that differentiation of the function in physical space corresponds to a simple multiplication of its Fourier coefficients by $ik$ in the frequency domain. Differentiating the interpolant $p(x)$ with respect to $x$ yields:\n$$\nv(x) = p'(x) = \\frac{d}{dx} \\left( \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx} \\right)\n$$\nBy linearity, we can interchange differentiation and summation:\n$$\nv(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k \\frac{d}{dx} (e^{ikx}) = \\sum_{k \\in \\mathbb{K}_N} (ik) \\hat{u}_k e^{ikx}\n$$\nThis demonstrates that the Fourier coefficients of the derivative, denoted $\\hat{v}_k$, are given by:\n$$\n\\hat{v}_k = ik \\hat{u}_k\n$$\nThe values of the derivative on the grid, $v_j = v(x_j)$, are then found by evaluating this new series, which is equivalent to performing an Inverse Discrete Fourier Transform (IDFT) on the coefficients $\\hat{v}_k$.\n\n**Algorithmic Implementation using the Fast Fourier Transform (FFT)**\n\nThe DFT and IDFT can be computed efficiently using the FFT algorithm. The procedure is as follows:\n\n1.  **Forward Transform**: Given the vector of function values $u = [u_0, u_1, \\dots, u_{N-1}]$, compute its DFT using an FFT algorithm. Let the result be $\\hat{U} = \\text{fft}(u)$. Standard numerical libraries like NumPy compute $\\hat{U}_m = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi mj / N}$ for $m \\in \\{0, \\dots, N-1\\}$. The relationship to our physical coefficients is $\\hat{u}_k = \\frac{1}{N}\\hat{U}_k$, where the FFT index $m$ is mapped to the physical wavenumber $k$.\n\n2.  **Wavenumber Vector**: It is necessary to construct the vector of physical wavenumbers $k$ that corresponds to the ordering of the FFT output. For an $N$-point FFT, the wavenumbers are $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ for even $N$, and $k \\in \\{0, 1, \\dots, (N-1)/2, -(N-1)/2, \\dots, -1\\}$ for odd $N$. This vector can be readily generated using library functions such as `numpy.fft.fftfreq(N) * N`.\n\n3.  **Applying the Differentiator**: The Fourier coefficients of the derivative, $\\hat{v}_k$, are computed by element-wise multiplication: $\\hat{v}_k = ik \\hat{u}_k$. In terms of the un-normalized coefficients from the FFT, this is $\\hat{V}_k = ik \\hat{U}_k$.\n    A special case arises for even $N$ at the Nyquist frequency, which corresponds to the wavenumber $k=N/2$ (or $k=-N/2$ depending on convention). A real-valued signal's interpolant on the grid contains only the $\\cos((N/2)x)$ component for this mode. The derivative of this cosine, $-(N/2)\\sin((N/2)x)$, is zero at all grid points $x_j$. Therefore, for a robust differentiation algorithm, the multiplier for the Nyquist frequency coefficient must be set to $0$.\n\n4.  **Inverse Transform**: The derivative values on the grid, $v = [v_0, v_1, \\dots, v_{N-1}]$, are obtained by applying the inverse FFT to the modified coefficients $\\hat{V}$: $v = \\text{ifft}(\\hat{V})$. Since the derivative of a real function is real, any residual imaginary part in the result is due to floating-point error and should be discarded.\n\n**Verification**\nThe computed discrete derivative $v_j$ is compared to the analytical derivative of $u(x) = \\sin(5x)$, which is $u'(x) = 5\\cos(5x)$. The maximum absolute error, $\\max_j |v_j - 5\\cos(5x_j)|$, is calculated. Since the function $\\sin(5x)$ is band-limited with wavenumber $k=5$, and all test cases use $N > 2k = 10$, the trigonometric interpolant is identical to the function itself. Consequently, the Fourier differentiation should be exact up to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the derivative of u(x) = sin(5x) on a periodic grid\n    using the Fourier spectral method for a suite of grid sizes N,\n    and reports the maximum absolute error against the analytical derivative.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [11, 12, 64, 128, 1001]\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the grid and the function data.\n        # Grid points on [0, 2*pi).\n        x = 2 * np.pi * np.arange(N) / N\n        \n        # Function values on the grid for u(x) = sin(5x).\n        u = np.sin(5 * x)\n        \n        # Analytical derivative u'(x) = 5*cos(5x) on the grid for verification.\n        u_analytic_deriv = 5 * np.cos(5 * x)\n        \n        # Step 2: Transform to Fourier space using FFT.\n        # This gives the un-normalized Fourier coefficients.\n        u_hat = np.fft.fft(u)\n        \n        # Step 3: Apply the differentiation operator in Fourier space.\n        \n        # Generate the vector of physical wavenumbers corresponding to the FFT output array.\n        # np.fft.fftfreq(N) returns frequencies f_k = k/N.\n        # Multiplying by N gives the integer wavenumbers k.\n        wavenumbers = np.fft.fftfreq(N) * N\n        \n        # The differentiation operator in Fourier space is multiplication by ik.\n        d_hat = 1j * wavenumbers\n        \n        # For even N, the Nyquist frequency component requires special handling.\n        # The derivative of the cos(N/2 * x) basis function is zero on the grid points.\n        # Therefore, the corresponding multiplier must be set to 0.\n        # In numpy's fftfreq, the Nyquist frequency corresponds to index N//2.\n        if N % 2 == 0:\n            d_hat[N // 2] = 0.0\n            \n        # Apply the differentiation operator.\n        v_hat = d_hat * u_hat\n        \n        # Step 4: Transform back to physical space using inverse FFT.\n        v = np.fft.ifft(v_hat)\n        \n        # The result should be real. We take the real part to discard\n        # any small imaginary noise from floating-point inaccuracies.\n        v_real = v.real\n        \n        # Step 5: Verify the result by comparing with the analytical derivative.\n        # Calculate the maximum absolute error across all grid points.\n        max_error = np.max(np.abs(v_real - u_analytic_deriv))\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # The map function converts each float error into a string for joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon the concept of spectral differentiation, this exercise applies the technique to a physically meaningful quantity in materials science: kinetic energy. You will verify the numerical equivalence of calculating the kinetic energy integral in real space versus summing squared mode contributions in reciprocal space, a direct consequence of Parseval's theorem. This practice is fundamental for code verification and understanding energy conservation in plane-wave-based simulations. ",
            "id": "3453307",
            "problem": "Consider a scalar field $\\psi(\\mathbf{r})$ defined on a three-dimensional periodic cube of side length $L$ with periodic boundary conditions. Let the volume be $V = L^3$ and let the field be sampled on a uniform grid with $N_x$, $N_y$, and $N_z$ points per dimension, so the total number of grid points is $N = N_x N_y N_z$ and the grid spacing is $d_x = L/N_x$, $d_y = L/N_y$, $d_z = L/N_z$. Define the discrete angular reciprocal lattice vectors for each dimension as\n$$\nG_x(m_x) = \\frac{2\\pi m_x}{L},\\quad G_y(m_y) = \\frac{2\\pi m_y}{L},\\quad G_z(m_z) = \\frac{2\\pi m_z}{L},\n$$\nwhere $m_x$, $m_y$, and $m_z$ are integers associated with the discrete Fourier transform grid indexing. The corresponding three-dimensional wavevector is $\\mathbf{G} = \\left(G_x, G_y, G_z\\right)$ and its magnitude is $|\\mathbf{G}| = \\sqrt{G_x^2+G_y^2+G_z^2}$.\n\nLet the Fourier series coefficients be defined by\n$$\n\\tilde{\\psi}(\\mathbf{G}) = \\frac{1}{V}\\int_V \\psi(\\mathbf{r})\\,e^{-i\\mathbf{G}\\cdot \\mathbf{r}}\\,d\\mathbf{r},\n$$\nand the Fourier representation be\n$$\n\\psi(\\mathbf{r}) = \\sum_{\\mathbf{G}} \\tilde{\\psi}(\\mathbf{G})\\,e^{i\\mathbf{G}\\cdot \\mathbf{r}}.\n$$\nIn numerical practice, approximate the integral by a Riemann sum on the grid and compute discrete transforms using the Fast Fourier Transform (FFT). Use dimensionless units throughout; $L$, $\\mathbf{G}$, and energy are treated as dimensionless quantities.\n\nYou are to verify the consistency between the real-space and reciprocal-space expressions for the kinetic energy of the field under a plane-wave cutoff. Specifically:\n\n1. Construct a complex field $\\psi(\\mathbf{r})$ by specifying its Fourier coefficients $\\tilde{\\psi}(\\mathbf{G})$ only for those $\\mathbf{G}$ satisfying $|\\mathbf{G}| \\le G_{\\text{cut}}$ and setting $\\tilde{\\psi}(\\mathbf{G}) = 0$ otherwise. Generate the nonzero coefficients as independent complex random values with a fixed random seed for reproducibility.\n\n2. Relate the FFT output $\\Psi(\\mathbf{G})$ to the Fourier series coefficients by\n$$\n\\tilde{\\psi}(\\mathbf{G}) \\approx \\frac{1}{N}\\,\\Psi(\\mathbf{G}),\n$$\nconsistent with the discretization of the integral on the uniform grid and the FFT normalization convention where the inverse FFT includes the $1/N$ factor.\n\n3. Compute the real-space kinetic energy by the spectral gradient method:\n   - Compute the gradient components via inverse FFTs of $i G_x \\Psi(\\mathbf{G})$, $i G_y \\Psi(\\mathbf{G})$, and $i G_z \\Psi(\\mathbf{G})$ to obtain $\\partial_x \\psi(\\mathbf{r})$, $\\partial_y \\psi(\\mathbf{r})$, and $\\partial_z \\psi(\\mathbf{r})$ respectively.\n   - Approximate the integral by a sum:\n   $$\n   E_{\\text{real}} \\approx dV \\sum_{\\text{grid}} \\left|\\nabla \\psi(\\mathbf{r})\\right|^2 = dV \\sum_{\\text{grid}} \\left(\\left|\\partial_x \\psi\\right|^2 + \\left|\\partial_y \\psi\\right|^2 + \\left|\\partial_z \\psi\\right|^2\\right),\n   $$\n   where $dV = V/N$.\n\n4. Compute the reciprocal-space kinetic energy using the discrete coefficients and the cutoff:\n   $$\n   E_{\\text{recip}} \\approx V \\sum_{|\\mathbf{G}|\\le G_{\\text{cut}}} |\\mathbf{G}|^2\\,\\left|\\tilde{\\psi}(\\mathbf{G})\\right|^2 = V \\sum_{|\\mathbf{G}|\\le G_{\\text{cut}}} |\\mathbf{G}|^2\\,\\frac{\\left|\\Psi(\\mathbf{G})\\right|^2}{N^2}.\n   $$\n\nFor each test case, report the relative difference\n$$\n\\delta = \n\\begin{cases}\n\\frac{\\left|E_{\\text{real}} - E_{\\text{recip}}\\right|}{E_{\\text{real}}}, & \\text{if } E_{\\text{real}} > 0, \\\\\n0, & \\text{if } E_{\\text{real}} = 0 \\text{ and } E_{\\text{recip}} = 0, \\\\\n\\text{undefined}, & \\text{otherwise},\n\\end{cases}\n$$\nwhere the undefined case will not occur in the provided test suite.\n\nImplement a program that performs this verification for the following test suite, where each test case is given as $(L, N_x, N_y, N_z, G_{\\text{cut}}, \\text{seed})$:\n\n- $(7.5, 32, 32, 32, 6.0, 123)$\n- $(5.0, 24, 20, 18, 8.0, 456)$\n- $(12.0, 16, 16, 16, 1.0, 789)$\n- $(9.0, 40, 36, 28, 20.0, 101112)$\n- $(10.0, 30, 30, 30, 0.0, 42)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result must be a floating-point number representing $\\delta$ for the corresponding test case. Use dimensionless units throughout and do not print any additional text.",
            "solution": "The problem statement is valid. It presents a well-posed, scientifically grounded task from computational materials science, which is to verify the numerical equivalence of two methods for calculating the kinetic energy of a scalar field. This equivalence is a direct consequence of Parseval's theorem as applied to the discrete Fourier transform and its properties concerning derivatives. The problem is free of contradictions, ambiguities, and factual errors.\n\nThe solution proceeds by implementing the specified calculations for each test case. The core of the task is a numerical verification that should yield a difference between the two energy values, $E_{\\text{real}}$ and $E_{\\text{recip}}$, that is close to zero, limited only by floating-point precision.\n\n**1. Reciprocal-Space Grid Generation**\n\nFirst, we establish the discrete reciprocal-space grid corresponding to the real-space discretization. For a periodic cube of side length $L$ sampled on an $N_x \\times N_y \\times N_z$ grid, the components of the reciprocal-space wavevectors $\\mathbf{G} = (G_x, G_y, G_z)$ are given by:\n$$\nG_u(m_u) = \\frac{2\\pi m_u}{L} \\quad \\text{for } u \\in \\{x,y,z\\}\n$$\nwhere $m_u$ are integers representing the frequency indices of the Discrete Fourier Transform (DFT). For a grid of size $N_u$, the indices $m_u$ are typically ordered as $m_u = 0, 1, \\dots, N_u/2-1, -N_u/2, \\dots, -1$. In the implementation, these integer indices are generated using `numpy.fft.fftfreq(Nu) * Nu`. Then, these 1D arrays of wavevector components are promoted to 3D arrays $G_x, G_y, G_z$ using a meshgrid. From these, the squared magnitude $|\\mathbf{G}|^2 = G_x^2 + G_y^2 + G_z^2$ is computed for each point in the reciprocal grid.\n\n**2. Field Construction in Reciprocal Space**\n\nThe problem specifies constructing a complex scalar field $\\psi(\\mathbf{r})$ by defining its Fourier coefficients $\\tilde{\\psi}(\\mathbf{G})$. For a discrete grid, we work with the DFT coefficients $\\Psi(\\mathbf{G})$, which are related to $\\tilde{\\psi}(\\mathbf{G})$ by $\\tilde{\\psi}(\\mathbf{G}) \\approx \\Psi(\\mathbf{G})/N$, where $N=N_x N_y N_z$.\n\nThe field is constructed such that its Fourier representation contains only components with wavevector magnitudes up to a certain cutoff, $|\\mathbf{G}| \\le G_{\\text{cut}}$. This is achieved by:\n- Initializing a complex-valued 3D array $\\Psi(\\mathbf{G})$ of size $N_x \\times N_y \\times N_z$ with zeros.\n- Creating a boolean mask identifying all grid points where the condition $|\\mathbf{G}| \\le G_{\\text{cut}}$ is met.\n- Generating independent complex random numbers for all grid points.\n- Populating the array $\\Psi(\\mathbf{G})$ with these random numbers only at the locations indicated by the mask.\n\nA fixed random seed is used for each case to ensure reproducibility. Since the problem specifies a complex field $\\psi(\\mathbf{r})$, there is no need to enforce the Hermitian symmetry $\\Psi(-\\mathbf{G}) = \\Psi^*(\\mathbf{G})$ that would be required for a purely real-valued field.\n\n**3. Reciprocal-Space Kinetic Energy Calculation**\n\nThe kinetic energy in reciprocal space is given by the sum over all wavevectors, weighted by their squared magnitude:\n$$\nE_{\\text{recip}} = V \\sum_{\\mathbf{G}} |\\mathbf{G}|^2 |\\tilde{\\psi}(\\mathbf{G})|^2\n$$\nUsing the discrete approximation $\\tilde{\\psi}(\\mathbf{G}) \\approx \\Psi(\\mathbf{G})/N$ and noting that $\\Psi(\\mathbf{G})=0$ for $|\\mathbf{G}| > G_{\\text{cut}}$, the expression becomes:\n$$\nE_{\\text{recip}} \\approx V \\sum_{|\\mathbf{G}| \\le G_{\\text{cut}}} |\\mathbf{G}|^2 \\frac{|\\Psi(\\mathbf{G})|^2}{N^2} = \\frac{V}{N^2} \\sum_{\\mathbf{G}} |\\mathbf{G}|^2 |\\Psi(\\mathbf{G})|^2\n$$\nThis is computed by element-wise multiplication of the pre-computed $|\\mathbf{G}|^2$ array with $|\\Psi(\\mathbf{G})|^2$, summing the result over the entire grid, and scaling by the factor $V/N^2$.\n\n**4. Real-Space Kinetic Energy Calculation**\n\nThe kinetic energy in real space is the volume integral of the squared gradient magnitude:\n$$\nE_{\\text{real}} = \\int_V |\\nabla \\psi(\\mathbf{r})|^2 d\\mathbf{r}\n$$\nThe spectral method computes the gradient components by leveraging the Fourier differentiation theorem, which states that differentiation in real space corresponds to multiplication by $i\\mathbf{G}$ in reciprocal space.\n$$\n\\nabla \\psi(\\mathbf{r}) = \\mathcal{F}^{-1}[i\\mathbf{G} \\Psi(\\mathbf{G})]\n$$\nwhere $\\mathcal{F}^{-1}$ denotes the inverse FFT. The algorithm is:\n- Compute the Fourier representation of each gradient component: $iG_x\\Psi(\\mathbf{G})$, $iG_y\\Psi(\\mathbf{G})$, and $iG_z\\Psi(\\mathbf{G})$.\n- Apply the inverse 3D FFT to each of these to obtain the gradient components $\\partial_x\\psi$, $\\partial_y\\psi$, and $\\partial_z\\psi$ on the real-space grid.\n- Approximate the integral by a sum over the grid points:\n$$\nE_{\\text{real}} \\approx dV \\sum_{\\text{grid}} |\\nabla \\psi(\\mathbf{r})|^2 = \\frac{V}{N} \\sum_{\\text{grid}} \\left( |\\partial_x\\psi|^2 + |\\partial_y\\psi|^2 + |\\partial_z\\psi|^2 \\right)\n$$\nThis is computed by taking the squared absolute value of each gradient component array, summing them, summing the result over all grid points, and multiplying by the real-space volume element $dV=V/N$.\n\n**5. Verification via Parseval's Theorem**\n\nParseval's theorem for the DFT states that the sum of the squared magnitudes of a signal is proportional to the sum of the squared magnitudes of its transform. For the `numpy` FFT convention, $\\sum_n |x_n|^2 = \\frac{1}{N} \\sum_k |X_k|^2$. Applying this to the expression for $E_{\\text{real}}$:\n$$\n\\sum_{\\text{grid}} |\\partial_x\\psi|^2 = \\frac{1}{N} \\sum_{\\mathbf{G}} |\\mathcal{F}[\\partial_x\\psi]|^2 = \\frac{1}{N} \\sum_{\\mathbf{G}} |iG_x\\Psi(\\mathbf{G})|^2 = \\frac{1}{N} \\sum_{\\mathbf{G}} G_x^2 |\\Psi(\\mathbf{G})|^2\n$$\nSubstituting this into the equation for $E_{\\text{real}}$:\n$$\nE_{\\text{real}} \\approx \\frac{V}{N} \\left( \\frac{1}{N} \\sum_{\\mathbf{G}} (G_x^2+G_y^2+G_z^2) |\\Psi(\\mathbf{G})|^2 \\right) = \\frac{V}{N^2} \\sum_{\\mathbf{G}} |\\mathbf{G}|^2 |\\Psi(\\mathbf{G})|^2\n$$\nThis final expression is algebraically identical to the one for $E_{\\text{recip}}$. Therefore, the two computed values should be identical up to floating-point precision errors.\n\n**6. Relative Difference**\n\nThe relative difference $\\delta$ is computed as defined in the problem statement. For the special case where $G_{\\text{cut}}=0$, only the $\\mathbf{G}=0$ mode can be non-zero. Since $|\\mathbf{G}|^2=0$ for this mode, both $E_{\\text{real}}$ and $E_{\\text{recip}}$ will be exactly $0$, and $\\delta$ is accordingly taken as $0$. For all other cases, $E_{\\text{real}}$ will be positive, and the relative difference serves as a measure of numerical precision. We expect $\\delta$ to be on the order of machine epsilon (approx. $10^{-16}$).",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying the consistency between real-space and \n    reciprocal-space kinetic energy calculations for a scalar field.\n    \"\"\"\n    \n    test_cases = [\n        (7.5, 32, 32, 32, 6.0, 123),\n        (5.0, 24, 20, 18, 8.0, 456),\n        (12.0, 16, 16, 16, 1.0, 789),\n        (9.0, 40, 36, 28, 20.0, 101112),\n        (10.0, 30, 30, 30, 0.0, 42)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, Nx, Ny, Nz, G_cut, seed = case\n        \n        # 1. Define constants and grid parameters\n        V = L**3\n        N = Nx * Ny * Nz\n        dV = V / N\n        \n        # Set the random seed for reproducibility\n        np.random.seed(seed)\n\n        # 2. Generate Reciprocal Space Grid (G-vectors)\n        # The integer frequency indices m_u for the DFT\n        mx = np.fft.fftfreq(Nx) * Nx\n        my = np.fft.fftfreq(Ny) * Ny\n        mz = np.fft.fftfreq(Nz) * Nz\n        \n        # Angular wavevector components: G_u = 2*pi*m_u/L\n        Gx_1d = (2 * np.pi / L) * mx\n        Gy_1d = (2 * np.pi / L) * my\n        Gz_1d = (2 * np.pi / L) * mz\n\n        # Create 3D grid of wavevectors\n        Gx, Gy, Gz = np.meshgrid(Gx_1d, Gy_1d, Gz_1d, indexing='ij')\n\n        # Calculate the squared magnitude |G|^2 and magnitude |G| for each grid point\n        G_squared = Gx**2 + Gy**2 + Gz**2\n        G_mag = np.sqrt(G_squared)\n\n        # 3. Construct the field in Reciprocal Space (Psi)\n        # Create a mask for the spherical cutoff\n        mask = G_mag = G_cut\n        \n        shape = (Nx, Ny, Nz)\n        # Generate independent complex random values\n        random_coeffs = np.random.rand(*shape) + 1j * np.random.rand(*shape)\n        \n        # Initialize the field in Fourier space and apply the cutoff mask\n        Psi = np.zeros(shape, dtype=complex)\n        Psi[mask] = random_coeffs[mask]\n        \n        # 4. Calculate Reciprocal Space Kinetic Energy (E_recip)\n        # E_recip is defined as V * sum(|G|^2 * |psi_tilde|^2)\n        # where psi_tilde = Psi / N.\n        # So, E_recip = V * sum(|G|^2 * |Psi|^2 / N^2)\n        E_recip = (V / (N**2)) * np.sum(G_squared * np.abs(Psi)**2)\n\n        # 5. Calculate Real Space Kinetic Energy (E_real)\n        # Compute gradient components using the spectral method via inverse FFT\n        grad_x_psi = np.fft.ifftn(1j * Gx * Psi)\n        grad_y_psi = np.fft.ifftn(1j * Gy * Psi)\n        grad_z_psi = np.fft.ifftn(1j * Gz * Psi)\n\n        # Sum the squared magnitudes of the gradient components at each real-space grid point\n        grad_psi_sq_mag = np.abs(grad_x_psi)**2 + np.abs(grad_y_psi)**2 + np.abs(grad_z_psi)**2\n        \n        # Approximate the energy integral by summing over the grid and multiplying by dV\n        E_real = dV * np.sum(grad_psi_sq_mag)\n        \n        # 6. Calculate the relative difference delta\n        if E_real > 0:\n            delta = np.abs(E_real - E_recip) / E_real\n        elif E_real == 0 and E_recip == 0:\n            delta = 0.0\n        else:\n            # This case is stated not to occur. It could only arise from significant floating point error\n            # where one value is zero and the other is a small non-zero artifact.\n            # We assign NaN for robustness, though it won't appear in the final output for the given tests.\n            delta = np.nan\n        \n        results.append(delta)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world physical models often involve nonlinear terms, which present a unique challenge for spectral methods known as aliasing. This exercise confronts this issue head-on by having you compute a cubic nonlinearity and observe how unresolvable high-frequency modes can corrupt the solution. By implementing and comparing naive and padded de-aliasing strategies, you will gain practical skills for ensuring the accuracy of pseudo-spectral simulations of nonlinear systems. ",
            "id": "3453340",
            "problem": "Consider a one-dimensional periodic domain of length $2\\pi$ with a real-valued field $\\phi(x)$ represented by a finite Fourier series. In a pseudo-spectral discretization, nonlinear terms are evaluated pointwise in real space and transformed back to Fourier space using the Fast Fourier Transform (FFT), which is an efficient algorithm to compute the Discrete Fourier Transform (DFT). When the product involves nonlinear powers, such as the cubic term $N(x) = \\phi(x)^3$, discrete convolution of the Fourier modes can produce new modes whose wavenumbers exceed the Nyquist limit of the chosen grid. This results in aliasing, where contributions from unresolvable high-frequency modes fold back into lower frequencies and corrupt the represented spectrum. \n\nYour task is to implement and compare three computational strategies for evaluating the cubic nonlinear term $N(x) = \\phi(x)^3$:\n- A naive pseudo-spectral method that computes $\\phi(x)^3$ on the coarse grid of $N$ points and transforms the result back to Fourier space using the DFT.\n- A zero-padding method with a padding factor of $3/2$, where the Fourier coefficients of $\\phi$ on the coarse grid are padded symmetrically to length $N_{\\mathrm{pad}} = \\frac{3}{2}N$, transformed to real space, multiplied in real space, and then transformed back to Fourier space and truncated to the original $N$ modes.\n- A zero-padding method with a padding factor of $2$, with the same procedure but using $N_{\\mathrm{pad}} = 2N$.\n\nThe foundational base for this problem is the convolution theorem for the DFT: the DFT of a product in real space is a discrete convolution of DFT coefficients in Fourier space. For a cubic nonlinearity, a finite-band field with maximum wavenumber $K_{\\max}$ generates spectral content up to $3K_{\\max}$. On a grid of $N$ points, the Nyquist wavenumber is $N/2$ (in integer mode counts for a $2\\pi$-periodic domain), so if $3K_{\\max}  N/2$, aliasing will occur in the naive computation.\n\nDefine the discrete spatial points by $x_j = \\frac{2\\pi j}{N}$ for $j = 0,1,\\dots,N-1$. Let the field $\\phi(x)$ be constructed as a finite sum of sines and cosines with integer wavenumbers:\n$$\n\\phi(x) = \\sum_{m} a_m \\cos(k_m x) + \\sum_{n} b_n \\sin(q_n x),\n$$\nwhere $k_m$ and $q_n$ are nonnegative integers. For each test case, construct $\\phi(x)$ directly in real space from its modal specification. \n\nTo assess aliasing and de-aliasing accuracy, define a reference spectrum for $N(x) = \\phi(x)^3$ by sampling $\\phi(x)$ on a sufficiently fine grid of $N_{\\mathrm{ref}}$ points with $N_{\\mathrm{ref}}$ chosen so that the highest expected wavenumber in $\\phi(x)^3$ is strictly below the Nyquist frequency of the reference grid. A sufficient condition is $N_{\\mathrm{ref}} \\ge 2 \\cdot 3K_{\\max} + 2$. Compute the DFT of $\\phi(x)^3$ on this fine grid, normalize by $N_{\\mathrm{ref}}$, and then project onto the coarse-grid resolvable Fourier wavenumbers (the central $N$ modes corresponding to integer wavenumbers from $-N/2$ to $N/2-1$). Treat this projected spectrum as the alias-free reference for the coarse grid.\n\nFor each of the three methods (naive, $3/2$-padded, and $2$-padded), compute the normalized DFT coefficients (divide the FFT by the grid length used in that method) for $N(x) = \\phi(x)^3$, reorder as a centered spectrum, and extract the central $N$ coefficients. Denote the reference coefficients by $\\hat{N}_{\\mathrm{ref}}$ and the method coefficients by $\\hat{N}_{\\mathrm{method}}$. For each method and test case, compute the relative error\n$$\n\\varepsilon = \\frac{\\left\\|\\hat{N}_{\\mathrm{method}} - \\hat{N}_{\\mathrm{ref}}\\right\\|_2}{\\left\\|\\hat{N}_{\\mathrm{ref}}\\right\\|_2},\n$$\nwhere $\\|\\cdot\\|_2$ denotes the Euclidean norm over the complex coefficient vector.\n\nImplement the above in a single program and apply it to the following test suite, where each case specifies the coarse grid size $N$ and the modes of $\\phi(x)$:\n- Case 1 (alias-prone mixed modes): $N = 64$, $\\phi(x) = 1.0\\cos(21x) + 0.5\\cos(7x) + 0.3\\sin(5x)$.\n- Case 2 (alias-free low modes): $N = 64$, $\\phi(x) = 1.0\\cos(5x) + 0.3\\sin(3x)$.\n- Case 3 (small grid, severe aliasing): $N = 32$, $\\phi(x) = 0.8\\cos(10x) + 0.6\\sin(9x)$.\n- Case 4 (near-Nyquist mixed modes): $N = 96$, $\\phi(x) = 1.0\\cos(31x) + 0.4\\cos(30x)$.\n\nFor each case, compute three floats: the relative error for the naive method, the relative error for the $3/2$-padded method, and the relative error for the $2$-padded method. Your program should produce a single line of output containing all results for the four cases, flattened into one list in the order of cases and methods, as a comma-separated list enclosed in square brackets. Round each float to six decimal places. For example, the output format must be exactly like\n$[$$e_{1,\\mathrm{naive}}$$,$$e_{1,3/2}$$,$$e_{1,2}$$,$$e_{2,\\mathrm{naive}}$$,$$e_{2,3/2}$$,$$e_{2,2}$$,$$e_{3,\\mathrm{naive}}$$,$$e_{3,3/2}$$,$$e_{3,2}$$,$$e_{4,\\mathrm{naive}}$$,$$e_{4,3/2}$$,$$e_{4,2}$$$]$ with numerical values replacing the symbols.\n\nNo physical units are involved in this problem; all quantities are dimensionless. Angles are in radians. The program must be self-contained and must not read input; it should print the single specified output line when run.",
            "solution": "The present problem requires a comparative analysis of three pseudo-spectral methods for computing the Fourier transform of a cubic nonlinearity, $N(x) = \\phi(x)^3$, on a one-dimensional periodic domain of length $2\\pi$. The core of the problem is to quantify the aliasing error that arises from the nonlinear term and to assess the effectiveness of de-aliasing techniques based on zero-padding.\n\nThe theoretical foundation of pseudo-spectral methods rests on the Discrete Fourier Transform (DFT) and the convolution theorem. A function $\\phi(x)$ discretized on a uniform grid of $N$ points, $x_j = 2\\pi j/N$ for $j=0, 1, \\dots, N-1$, can be represented by its DFT coefficients, $\\hat{\\phi}_k$, which correspond to a finite set of integer wavenumbers. For an even number of grid points $N$, these wavenumbers are typically taken as $k \\in \\{-N/2, \\dots, N/2 - 1\\}$.\n\nThe product of functions in real space corresponds to a convolution of their coefficients in Fourier space. Specifically, the DFT of the product $\\phi(x)^3$ is equivalent to the triple discrete convolution of the spectrum $\\hat{\\phi}_k$ with itself:\n$$\n\\widehat{\\phi^3}_k = (\\hat{\\phi} \\star \\hat{\\phi} \\star \\hat{\\phi})_k = \\sum_{p+q+r=k \\pmod N} \\hat{\\phi}_p \\hat{\\phi}_q \\hat{\\phi}_r\n$$\nIf the field $\\phi(x)$ contains wavenumbers up to a maximum of $K_{\\max}$, the cubic product $\\phi(x)^3$ will generate new wavenumbers up to $3K_{\\max}$. If $3K_{\\max}$ exceeds the Nyquist wavenumber of the grid, $k_{\\mathrm{Nyq}} = N/2$, the energy from these unresolvable high wavenumbers is erroneously \"folded back\" onto the lower, resolvable wavenumbers. This phenomenon is termed aliasing and it contaminates the computed spectrum.\n\nThe solution proceeds by implementing and comparing the three specified methods against a high-fidelity reference solution for four distinct test cases.\n\n**1. Reference Spectrum ($\\hat{N}_{\\mathrm{ref}}$)**\nTo establish a ground truth uncontaminated by aliasing, the function $\\phi(x)^3$ is evaluated on a significantly finer grid. A reference grid of size $N_{\\mathrm{ref}}$ is chosen such that its Nyquist frequency is greater than the highest possible wavenumber generated by the nonlinearity, i.e., $N_{\\mathrm{ref}}/2 \\ge 3K_{\\max}$. The problem provides the sufficient condition $N_{\\mathrm{ref}} \\ge 6K_{\\max} + 2$. A value of $N_{\\mathrm{ref}}=512$ is selected, which is adequate for all test cases. The procedure is as follows:\n- Construct the field $\\phi(x)$ on the fine grid of $N_{\\mathrm{ref}}$ points.\n- Compute the cubic term $\\phi(x)^3$ pointwise on this fine grid.\n- Compute its DFT and normalize by the grid size $N_{\\mathrm{ref}}$ to obtain the fine-grained spectrum, $\\hat{N}_{\\mathrm{fine}}$.\n- The alias-free reference spectrum for the coarse grid, $\\hat{N}_{\\mathrm{ref}}$, is obtained by extracting the $N$ coefficients from $\\hat{N}_{\\mathrm{fine}}$ that correspond to the wavenumbers resolvable by the coarse grid, i.e., $k \\in \\{-N/2, \\dots, N/2 - 1\\}$.\n\n**2. Naive Pseudo-Spectral Method**\nThis is the most direct but potentially inaccurate method.\n- Construct the field $\\phi(x)$ on the coarse grid of $N$ points.\n- Compute the cubic term $\\phi(x)^3$ pointwise.\n- The resulting aliased spectrum, $\\hat{N}_{\\mathrm{naive}}$, is the DFT of this product, normalized by $N$.\nThis method will suffer from aliasing whenever $3K_{\\max}  N/2$.\n\n**3. Zero-Padding (De-aliasing) Method**\nThis method mitigates aliasing by performing the multiplication in a larger, \"padded\" real space grid, which corresponds to inserting zeros for high-frequency modes in Fourier space.\n- First, the DFT of $\\phi(x)$ on the coarse grid, $\\hat{\\phi}$, is computed.\n- A new, larger array of Fourier coefficients of length $N_{\\mathrm{pad}}$ is created, where $N_{\\mathrm{pad}} = \\text{int}(f \\cdot N)$ and $f$ is the padding factor ($1.5$ or $2$). The original coefficients from $\\hat{\\phi}$ are copied to the corresponding low-wavenumber locations in the new array, and the remaining high-wavenumber slots are filled with zeros.\n- An inverse DFT is performed on this padded spectrum. To preserve the amplitude of the field, the result is scaled by the ratio of grid sizes, $N_{\\mathrm{pad}}/N$. This yields an interpolated version of $\\phi(x)$ on a finer grid of $N_{\\mathrm{pad}}$ points.\n- The cubic term $\\phi(x)^3$ is computed pointwise on this padded grid.\n- The DFT of this product is computed and normalized by $N_{\\mathrm{pad}}$.\n- Finally, the resulting spectrum is truncated back to the original $N$ modes to yield the de-aliased spectrum, $\\hat{N}_{\\mathrm{method}}$.\n\nFor a cubic nonlinearity, spectral theory indicates that a padding factor of $f=2$ (i.e., doubling the grid points to $2N$) is sufficient to completely eliminate aliasing, provided the input field $\\phi(x)$ was fully resolved on the original grid. A factor of $f=3/2$, while standard for quadratic nonlinearities, is generally insufficient for cubic terms and is expected to show residual aliasing error in cases where $3K_{\\max}  (3/2)N/2 = 3N/4$.\n\n**4. Error Metric**\nFor each method, the accuracy is quantified by the relative error $\\varepsilon$ in the $L_2$ (Euclidean) norm between the method's computed spectrum ($\\hat{N}_{\\mathrm{method}}$) and the reference spectrum ($\\hat{N}_{\\mathrm{ref}}$):\n$$\n\\varepsilon = \\frac{\\left\\| \\hat{N}_{\\mathrm{method}} - \\hat{N}_{\\mathrm{ref}} \\right\\|_2}{\\left\\| \\hat{N}_{\\mathrm{ref}} \\right\\|_2}\n$$\nThis metric provides a single value representing the overall deviation of the computed spectrum from the alias-free ideal. The implementation will calculate this error for the naive, $3/2$-padded, and $2$-padded methods for each of the four test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Implements and compares three pseudo-spectral methods for evaluating the cubic\n    nonlinearity phi^3, calculating the relative error of each against a\n    high-resolution reference to assess aliasing and de-aliasing effectiveness.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, [(1.0, 'cos', 21), (0.5, 'cos', 7), (0.3, 'sin', 5)]),\n        (64, [(1.0, 'cos', 5), (0.3, 'sin', 3)]),\n        (32, [(0.8, 'cos', 10), (0.6, 'sin', 9)]),\n        (96, [(1.0, 'cos', 31), (0.4, 'cos', 30)])\n    ]\n\n    all_results = []\n\n    def build_phi(x_grid, modes):\n        \"\"\"Constructs the real-valued field phi(x) on a given grid.\"\"\"\n        phi = np.zeros_like(x_grid, dtype=float)\n        for amp, func_type, k in modes:\n            if func_type == 'cos':\n                phi += amp * np.cos(k * x_grid)\n            elif func_type == 'sin':\n                phi += amp * np.sin(k * x_grid)\n        return phi\n\n    for N, modes in test_cases:\n        # ---- 1. Determine Parameters and Grids ----\n        K_max = max(k for _, _, k in modes) if modes else 0\n        \n        # Reference grid must resolve wavenumbers up to 3*K_max.\n        # Required: N_ref >= 6*K_max + 2.\n        # Max K_max is 31 (case 4), so N_ref must be >= 6*31 + 2 = 188.\n        # Let's choose a safe, large power of 2 sufficient for all cases.\n        N_ref = 512\n        x_ref = (2 * np.pi / N_ref) * np.arange(N_ref)\n        \n        x_coarse = (2 * np.pi / N) * np.arange(N)\n        half_N = N // 2\n        \n        # ---- 2. Compute Reference Spectrum ----\n        phi_ref = build_phi(x_ref, modes)\n        N_ref_real = phi_ref**3\n        N_hat_ref_full = fft.fft(N_ref_real) / N_ref\n        \n        # Project onto the coarse grid's wavenumbers by truncation\n        N_hat_ref = np.zeros(N, dtype=complex)\n        N_hat_ref[0:half_N] = N_hat_ref_full[0:half_N]\n        N_hat_ref[half_N:] = N_hat_ref_full[N_ref - half_N:]\n\n        # ---- 3. Naive Method ----\n        phi_coarse = build_phi(x_coarse, modes)\n        N_naive_real = phi_coarse**3\n        N_hat_naive = fft.fft(N_naive_real) / N\n        \n        norm_ref = np.linalg.norm(N_hat_ref)\n        if norm_ref == 0: # Avoid division by zero for null fields\n            norm_ref = 1.0\n\n        err_naive = np.linalg.norm(N_hat_naive - N_hat_ref) / norm_ref\n        all_results.append(f\"{err_naive:.6f}\")\n\n        # ---- 4. Padded Methods ----\n        phi_hat_coarse = fft.fft(phi_coarse)\n\n        for pad_factor in [1.5, 2.0]:\n            N_pad = int(N * pad_factor)\n            \n            # Pad Fourier coefficients with zeros for high frequencies\n            phi_hat_padded = np.zeros(N_pad, dtype=complex)\n            phi_hat_padded[0:half_N] = phi_hat_coarse[0:half_N]\n            phi_hat_padded[N_pad - half_N:] = phi_hat_coarse[half_N:]\n\n            # Transform to padded real space, compute cube, transform back\n            # The scaling factor restores the amplitude of the interpolated signal.\n            phi_padded = fft.ifft(phi_hat_padded) * (N_pad / N)\n            \n            # The signal phi is real, so its IFFT should be real.\n            # We take np.real to discard small imaginary parts from numerical error.\n            N_padded_real = np.real(phi_padded)**3\n            \n            N_hat_padded_full = fft.fft(N_padded_real) / N_pad\n            \n            # Truncate back to the coarse grid size\n            N_hat_padded = np.zeros(N, dtype=complex)\n            N_hat_padded[0:half_N] = N_hat_padded_full[0:half_N]\n            N_hat_padded[half_N:] = N_hat_padded_full[N_pad - half_N:]\n\n            err_padded = np.linalg.norm(N_hat_padded - N_hat_ref) / norm_ref\n            all_results.append(f\"{err_padded:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}