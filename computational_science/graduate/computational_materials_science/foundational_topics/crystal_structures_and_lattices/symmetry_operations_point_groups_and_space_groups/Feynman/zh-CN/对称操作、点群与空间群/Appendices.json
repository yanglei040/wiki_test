{
    "hands_on_practices": [
        {
            "introduction": "本节练习将作为热身，它将晶格的抽象定义与其几何性质联系起来。我们将从一组给定的晶格参数出发，通过运用晶体学基本原理，确定其对应的布拉维晶格类型。这项练习旨在强化对晶体结构进行分类的基本技能，并为理解晶格矢量与对称性之间的关系打下坚实的基础 。",
            "id": "3491341",
            "problem": "一种晶体固体的晶格参数 $(a,b,c,\\alpha,\\beta,\\gamma)$ 满足 $a=b\\neq c$，$\\alpha=\\beta=90^{\\circ}$，以及 $\\gamma=120^{\\circ}$，其中所有角度均以度为单位。从布拉维晶格、晶系、惯用晶胞与原胞的核心定义，以及晶胞体积作为由平移矢量张成的平行六面体体积的几何定义出发，完成以下任务：\n\n- 使用度规约束，从第一性原理出发确定晶系和布拉维晶格类型。\n- 判断此布拉维晶格的惯用晶胞是原胞还是心式晶胞，并使用对称性和度规论据阐述理由。\n- 在一个右手笛卡尔坐标系中，构建一组与给定度规约束一致的原胞平移矢量，其中 $c$ 轴沿 $\\hat{\\mathbf{z}}$ 方向，基面由 $\\hat{\\mathbf{x}}$ 和 $\\hat{\\mathbf{y}}$ 张成。\n- 仅使用通过标量三重积的体积几何定义，从您构建的原胞平移矢量推导出原胞体积 $V_{p}$，并简化结果。\n\n作为最终答案，提供无量纲比值 $V_{p}/(a^{2}c)$ 的精确值。不要对答案进行近似；请以精确的闭合形式给出。此无量纲比值无需单位。最终答案必须是单个表达式。",
            "solution": "对问题陈述的分析始于对其前提和约束条件的验证。给定的晶格参数为 $(a,b,c,\\alpha,\\beta,\\gamma)$，约束条件为 $a=b\\neq c$，$\\alpha=\\beta=90^{\\circ}$，以及 $\\gamma=120^{\\circ}$。这些约束是自洽的，并对应于晶体学中标准晶系的定义。该问题具有科学依据，提法恰当且客观，并提供了获得唯一解所需的所有信息。因此，该问题是有效的，我们可以着手求解。\n\n第一个任务是根据给定的度规约束确定晶系和布拉维晶格类型。晶系的分类是基于描述晶格几何所需的最小对称性，这反映在对惯用晶胞轴和角度的约束上。给定的约束是 $a=b \\neq c$，$\\alpha=\\beta=90^{\\circ}$，以及 $\\gamma=120^{\\circ}$。存在一个独特轴（$c$轴，因为 $c \\neq a, b$）垂直于一个基面（因为 $\\alpha = \\beta = 90^{\\circ}$），且该基面上的二维晶格有两个等长但夹角非 $90^{\\circ}$ 的轴（$a=b, \\gamma=120^{\\circ}$），这是六方晶系的特征。六方晶格拥有一个6次或3次旋转对称轴。特定的 $\\gamma=120^{\\circ}$ 角意味着存在一个6次或3次轴，这是六方晶族的定义性对称元素。所提供的约束定义了**六方**晶系的惯用晶胞。对于六方晶系，只有一个布拉维晶格：**六方简单**晶格，用符号P表示。\n\n第二个任务是判断此布拉维晶格的惯用晶胞是原胞还是心式晶胞。一个原胞恰好包含一个格点。六方布拉维晶格的惯用晶胞仅在其顶点处有格点。按照惯例，晶胞顶点的格点由交于该顶点的8个晶胞共享，因此8个顶点每个对该晶胞贡献1/8个格点。因此，每个六方惯用晶胞的总格点数为 $8 \\times (1/8) = 1$。由于惯用晶胞恰好包含一个格点，根据定义，它是一个**原胞**。描述该晶格不需要任何心式矢量。重要的是要将其与菱方晶格区分开，后者可以由一个非原胞（心式）的六方晶胞来描述。然而，问题陈述的约束条件直接定义了六方简单布拉维晶格。\n\n第三个任务是构建一组原胞平移矢量。由于惯用晶胞是原胞，我们可以使用其晶格矢量。我们将按照规定定义一个右手笛卡尔坐标系，其中$c$轴沿$\\hat{\\mathbf{z}}$方向。原胞平移矢量记为$\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$。\n它们的模长为$|\\mathbf{a}_1|=a$, $|\\mathbf{a}_2|=b=a$, 和 $|\\mathbf{a}_3|=c$。\n它们之间的夹角为$\\angle(\\mathbf{a}_2, \\mathbf{a}_3) = \\alpha = 90^{\\circ}$，$\\angle(\\mathbf{a}_1, \\mathbf{a}_3) = \\beta = 90^{\\circ}$，以及$\\angle(\\mathbf{a}_1, \\mathbf{a}_2) = \\gamma = 120^{\\circ}$。\n\n我们在笛卡尔坐标系 $(x,y,z)$ 中建立这些矢量：\n1.  将矢量 $\\mathbf{a}_3$ 与笛卡尔 $\\hat{\\mathbf{z}}$ 轴对齐：\n    $$ \\mathbf{a}_3 = (0, 0, c) $$\n2.  由于 $\\alpha = \\beta = 90^{\\circ}$，$\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 都必须位于 $xy$ 平面内。我们将 $\\mathbf{a}_1$ 与笛卡尔 $\\hat{\\mathbf{x}}$ 轴对齐：\n    $$ \\mathbf{a}_1 = (a, 0, 0) $$\n3.  矢量 $\\mathbf{a}_2$ 的模长必须为 $a$，并与 $\\mathbf{a}_1$ 形成 $\\gamma=120^{\\circ}$ 的夹角。它在 $xy$ 平面内的分量是：\n    $$ \\mathbf{a}_2 = (a \\cos(120^{\\circ}), a \\sin(120^{\\circ}), 0) $$\n    使用三角函数值 $\\cos(120^{\\circ}) = -1/2$ 和 $\\sin(120^{\\circ}) = \\sqrt{3}/2$，我们得到：\n    $$ \\mathbf{a}_2 = \\left(-\\frac{a}{2}, \\frac{a\\sqrt{3}}{2}, 0\\right) $$\n最终得到的原胞平移矢量组是：\n$$ \\mathbf{a}_1 = (a, 0, 0) $$\n$$ \\mathbf{a}_2 = \\left(-\\frac{a}{2}, \\frac{a\\sqrt{3}}{2}, 0\\right) $$\n$$ \\mathbf{a}_3 = (0, 0, c) $$\n\n第四个任务是使用这些矢量的标量三重积来推导原胞体积 $V_p$。体积由 $V_p = |\\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)|$ 给出，这可以计算为以这些矢量分量为行的矩阵的行列式的绝对值。\n$$ V_p = \\left| \\det \\begin{pmatrix} a & 0 & 0 \\\\ -a/2 & a\\sqrt{3}/2 & 0 \\\\ 0 & 0 & c \\end{pmatrix} \\right| $$\n我们可以沿第一行展开行列式：\n$$ V_p = \\left| a \\det \\begin{pmatrix} a\\sqrt{3}/2 & 0 \\\\ 0 & c \\end{pmatrix} - 0 + 0 \\right| $$\n$$ V_p = \\left| a \\left( \\left(\\frac{a\\sqrt{3}}{2}\\right)(c) - (0)(0) \\right) \\right| $$\n$$ V_p = \\left| a \\left( \\frac{a c \\sqrt{3}}{2} \\right) \\right| = \\frac{\\sqrt{3}}{2} a^2 c $$\n体积为正，证实了所构建的矢量组是右手的。原胞体积为 $V_p = \\frac{\\sqrt{3}}{2} a^2 c$。\n\n最后，要求我们提供无量纲比值 $V_p / (a^2 c)$ 的精确值。\n$$ \\frac{V_p}{a^2 c} = \\frac{\\frac{\\sqrt{3}}{2} a^2 c}{a^2 c} $$\n$a^2$ 和 $c$ 项相互抵消，留下简化后的表达式。\n$$ \\frac{V_p}{a^2 c} = \\frac{\\sqrt{3}}{2} $$\n这就是最终以精确闭合形式表示的无量纲比值。",
            "answer": "$$\\boxed{\\frac{\\sqrt{3}}{2}}$$"
        },
        {
            "introduction": "回顾了几何基础之后，我们现在转向对称性的抽象代数本质。这项练习要求您不仅将对称操作视为几何变换，更要将其视为一个有限群的元素。您将从一个常见点群的最小生成元集出发，通过算法推导出所有群元素，并通过共轭类来探索群的内部结构，这是理解光谱选择定则和其他物理性质的关键概念 。",
            "id": "3491365",
            "problem": "在计算材料科学中，二维方格网的点群对称性是晶格动力学、电子结构取样和空间群构建中约束条件的基础。考虑平面上一个完美正方形的点群，它由绕平面外轴旋转 $90^\\circ$ 的旋转操作和穿过正方形中心的垂直线的镜像反射操作生成。将这些生成元分别表示为 $C_{4}$ 和 $\\sigma_{v}$。仅使用欧几里得等距同构复合下的群操作基本定义、将 $C_{4}$ 自身复合四次得到单位元的事实、任何镜像与其自身复合得到单位元的事实，以及用一个镜像对一个旋转进行共轭会反转其旋转方向的事实，执行以下任务：\n- 通过复合和求逆运算的闭包，算法化地枚举出由 $\\{C_{4},\\sigma_{v}\\}$ 生成的群的所有不同元素。\n- 在共轭运算 $g : x \\mapsto g x g^{-1}$ 下，将所得元素划分为共轭类，并为每个类提供至少一个代表元。\n- 根据你的枚举结果，确定该群的阶。\n\n仅提供最终的群阶作为答案。不要包含任何单位。不要四舍五入。最终答案必须是一个数字。",
            "solution": "用户提供了一个问题，要求枚举由两个特定对称操作生成的有限群中的元素，将这些元素划分为共轭类，并确定该群的阶。\n\n### 第1步：问题验证\n\n**1.1. 提取已知条件**\n- **系统**：二维平面中完美正方形的点群。\n- **生成元**：$C_4$（绕中心旋转 $90^\\circ$）和 $\\sigma_v$（穿过中心的垂直线的镜像反射）。\n- **公理化性质**：\n    - 群操作是欧几里得等距同构的复合。\n    - $C_4^4 = E$，其中 $E$ 是单位元。\n    - 对于任何镜像反射 $\\sigma$，有 $\\sigma^2 = E$。特别是 $\\sigma_v^2 = E$，这意味着 $\\sigma_v^{-1} = \\sigma_v$。\n    - 用镜像对旋转进行共轭会反转其旋转方向：$\\sigma C_n \\sigma^{-1} = C_n^{-1}$。对于本问题，其形式为 $\\sigma_v C_4 \\sigma_v^{-1} = C_4^{-1}$。\n- **任务**：\n    - 枚举由 $\\{C_4, \\sigma_v\\}$ 生成的所有不同元素。\n    - 将元素划分为共轭类。\n    - 确定群的阶。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题在有限群的数学理论（特别是点群）中有坚实的基础，这是物理学、化学和材料科学中的一个基本概念。所描述的群是二面体群 $D_4$，在晶体学符号中也称为点群 $4mm$。为生成元给出的性质是该群的正确定义关系。\n- **适定性**：该问题是适定的。生成元及其关系足以唯一地定义一个有限群。枚举元素、划分为共轭类以及求阶是群论中具有唯一解的标准程序。\n- **客观性**：问题陈述完全客观，并使用了精确的数学术语。\n\n**1.3. 结论与行动**\n该问题是有效的。它在科学上是合理的、适定的和客观的。没有缺陷、矛盾或缺失的信息。我将继续进行完整解答。\n\n### 第2步：求解推导\n\n群 $G$ 由元素集合 $\\{C_4, \\sigma_v\\}$ 生成。我们已知以下关系：\n1. $C_4^4 = E$\n2. $\\sigma_v^2 = E$\n3. $\\sigma_v C_4 \\sigma_v^{-1} = C_4^{-1}$\n\n由于 $\\sigma_v^2 = E$，我们有 $\\sigma_v^{-1} = \\sigma_v$。第三个关系可以重写为 $\\sigma_v C_4 \\sigma_v = C_4^{-1}$。在右侧乘以 $\\sigma_v$ 得到对易关系：\n$$\n\\sigma_v C_4 = C_4^{-1} \\sigma_v = C_4^3 \\sigma_v\n$$\n这个规则是关键，因为它允许我们将任何生成元的乘积重写为一种规范形式，通常是 $C_4^k \\sigma_v^m$ 的形式。\n\n**2.1. 群元素的枚举**\n\n我们从单位元 $E$ 开始，通过重复应用生成元来算法化地生成所有不同的元素，直到元素集合在复合运算下闭合。\n\n首先，考虑由 $C_4$ 生成的循环子群：\n- $C_4^0 = E$ (单位元)\n- $C_4^1 = C_4$ (旋转 $90^\\circ$)\n- $C_4^2 = C_2$ (旋转 $180^\\circ$)\n- $C_4^3 = C_4^{-1}$ (旋转 $270^\\circ$)\n- $C_4^4 = E$ (闭合)\n这给出了四个不同旋转元素的集合：$\\{E, C_4, C_2, C_4^3\\}$。这是循环群 $C_4$。\n\n接下来，我们引入第二个生成元 $\\sigma_v$，并通过将其与 $C_4$ 子群的现有元素复合来形成新元素。我们可以构成陪集 $C_4 \\sigma_v = \\{g\\sigma_v | g \\in C_4\\}$：\n- $E \\sigma_v = \\sigma_v$。这是初始的垂直反射。\n- $C_4 \\sigma_v$。我们来识别这个操作。使用中心为 $(0,0)$ 的坐标系，$C_4$ 将 $(x, y)$ 映射到 $(-y, x)$，而 $\\sigma_v$（关于 $y$ 轴的反射）将 $(x, y)$ 映射到 $(-x, y)$。复合操作 $C_4 \\sigma_v$ 将 $(x, y) \\xrightarrow{\\sigma_v} (-x, y) \\xrightarrow{C_4} (-y, -x)$。这是关于直线 $y = -x$ 的反射。我们将其记为 $\\sigma_{d'}$。\n- $C_2 \\sigma_v$。复合操作 $C_2 \\sigma_v$ 将 $(x, y) \\xrightarrow{\\sigma_v} (-x, y) \\xrightarrow{C_2} (-(-x), -y) = (x, -y)$。这是关于 $x$ 轴的反射，我们记为 $\\sigma_h$。\n- $C_4^3 \\sigma_v$。复合操作 $C_4^3 \\sigma_v$ 将 $(x, y) \\xrightarrow{\\sigma_v} (-x, y) \\xrightarrow{C_4^3} (y, x)$。这是关于直线 $y=x$ 的反射。我们将其记为 $\\sigma_d$。\n\n所有元素的集合是旋转子群及其陪集的并集：\n$$\nG = \\{E, C_4, C_2, C_4^3\\} \\cup \\{\\sigma_v, \\sigma_h, \\sigma_d, \\sigma_{d'}\\}\n$$\n$8$ 个不同元素的完整列表是：\n$G = \\{E, C_4, C_2, C_4^3, \\sigma_v, \\sigma_h, \\sigma_d, \\sigma_{d'}\\}$。\n该群是闭合的。从此集合中任意两个元素的乘积都将得到集合内的另一个元素，这可以使用对易关系 $\\sigma_v C_4 = C_4^3 \\sigma_v$ 和基本关系进行验证。例如，$\\sigma_h \\sigma_d = (C_2 \\sigma_v)(C_4^3 \\sigma_v) = C_2 (\\sigma_v C_4^3) \\sigma_v = C_2 (C_4 \\sigma_v) \\sigma_v = C_2 C_4 \\sigma_v^2 = C_2 C_4 E = C_4^2 C_4 = C_4^3$。\n\n群的阶，记作 $|G|$，是不同元素总数。通过枚举，我们得到 $|G| = 8$。\n\n**2.2. 划分为共轭类**\n\n元素 $x \\in G$ 的共轭类是集合 $Cl(x) = \\{gxg^{-1} | g \\in G\\}$。\n\n1.  **$E$ 的类**：对于任意 $g \\in G$，$gEg^{-1} = gg^{-1} = E$。因此，$Cl(E) = \\{E\\}$。\n2.  **$C_2$ 的类**：\n    - 对于任意旋转 $g = C_4^k$：$C_4^k C_2 (C_4^k)^{-1} = C_4^k C_4^2 C_4^{-k} = C_2$，因为旋转操作构成一个阿贝尔子群。\n    - 对于任意反射 $g = \\sigma$：$\\sigma C_2 \\sigma^{-1} = C_2^{-1} = C_2$。\n    因此，$C_2$ 只与自身共轭。$Cl(C_2) = \\{C_2\\}$。\n3.  **$C_4$ 的类**：\n    - 对于任意旋转 $g = C_4^k$：$C_4^k C_4 (C_4^k)^{-1} = C_4$。\n    - 对于任意反射 $g = \\sigma$：$\\sigma C_4 \\sigma^{-1} = C_4^{-1} = C_4^3$。\n    因此，$C_4$ 与 $C_4^3$ 共轭。$Cl(C_4) = \\{C_4, C_4^3\\}$。\n4.  **$\\sigma_v$ 的类**：\n    - $C_4 \\sigma_v C_4^{-1} = C_4 \\sigma_v C_4^3$。使用关系式 $\\sigma_v C_4 = C_4^3 \\sigma_v$，我们有 $C_4 \\sigma_v = \\sigma_v C_4^3$。这是不正确的。正确的关系是 $C_4 \\sigma_v = (\\sigma_v C_4^{-1})^{-1}$，但这没有用处。\n    - 让我们使用对易关系 $\\sigma_v C_4 = C_4^3 \\sigma_v$。那么 $C_4 \\sigma_v C_4^3 = (C_4 \\sigma_v) C_4^3 = (\\sigma_v^{-1} C_4^3) C_4^3 = \\sigma_v C_4^6 = \\sigma_v C_2 = C_2 \\sigma_v = \\sigma_h$。这似乎过于复杂。\n    - 关系式 $\\sigma_v C_4 = C_4^3 \\sigma_v$ 给出 $C_4 \\sigma_v = \\sigma_v C_4^3$。\n    - 让我们重新考虑 $C_4 \\sigma_v C_4^{-1} = C_4 \\sigma_v C_4^3$。我们之前推导出 $\\sigma_h = C_2 \\sigma_v$ 并且 $\\sigma_v$ 和 $C_2$ 可交换。所以 $C_4 \\sigma_v C_4^{-1} = C_4 (\\sigma_v C_4^3) = C_4 (C_4 \\sigma_v) = C_2 \\sigma_v = \\sigma_h$。\n    - 用 $C_4$ 对 $\\sigma_v$ 进行共轭得到 $\\sigma_h$。因此，$\\sigma_v$ 和 $\\sigma_h$ 在同一个类中。\n    - 让我们用 $\\sigma_d = C_4^3 \\sigma_v$ 对 $\\sigma_v$ 进行共轭。$ \\sigma_d \\sigma_v \\sigma_d^{-1} = (C_4^3 \\sigma_v) \\sigma_v (C_4^3 \\sigma_v)^{-1} = C_4^3 \\sigma_v^2 \\sigma_v^{-1} (C_4^3)^{-1} = C_4^3 E \\sigma_v^{-1} C_4 = C_4^3 \\sigma_v C_4 = C_4^3 (C_4^3 \\sigma_v) = C_4^6 \\sigma_v = C_2 \\sigma_v = \\sigma_h$。\n    - 这证实了反射 $\\sigma_v$ 和 $\\sigma_h$ 构成一个单一的共轭类。$Cl(\\sigma_v) = \\{\\sigma_v, \\sigma_h\\}$。\n5.  **$\\sigma_d$ 的类**：\n    - 剩下的元素是 $\\sigma_d$ 和 $\\sigma_{d'}$。它们必须构成最后一个类。我们来验证一下：\n    - 用 $C_4$ 对 $\\sigma_d$ 进行共轭：$C_4 \\sigma_d C_4^{-1} = C_4 (C_4^3 \\sigma_v) C_4^3 = C_4^4 \\sigma_v C_4^3 = E \\sigma_v C_4^3 = \\sigma_v C_4^3 = C_4 \\sigma_v = \\sigma_{d'}$。\n    - 因此，$Cl(\\sigma_d) = \\{\\sigma_d, \\sigma_{d'}\\}$。\n\n共轭类是：\n- $\\{E\\}$ (大小为 $1$)\n- $\\{C_2\\}$ (大小为 $1$)\n- $\\{C_4, C_4^3\\}$ (大小为 $2$)\n- $\\{\\sigma_v, \\sigma_h\\}$ (大小为 $2$)\n- $\\{\\sigma_d, \\sigma_{d'}\\}$ (大小为 $2$)\n这些类的大小之和是 $1 + 1 + 2 + 2 + 2 = 8$，这等于群的阶，为我们的枚举提供了一个必要的一致性检查。\n\n**2.3. 群的阶**\n基于对由 $\\{C_4, \\sigma_v\\}$ 生成的所有不同元素的枚举，该群包含 $8$ 个元素。\n因此，该群的阶为 $8$。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "在这最后一个计算练习中，理论与现实相遇，它解决了现代材料模拟中的一个核心任务：如何通过算法确定给定原子结构的空间群。您将实现一个程序，通过使用位置容差来解决计算数据中固有的数值不精确性问题。这项实践为了解对称性分析中的实际挑战提供了一个窗口，例如区分真实对称性与“赝对称性”（即结构接近但不完全对称的情况）。",
            "id": "3491404",
            "problem": "实现一个程序，该程序在给定作用于周期性晶体原子分数坐标上的一组有限的候选对称操作的情况下，遍历一个位置容差列表，在每个容差下从一个固定的目录中指派最对称的空间群，量化该指派在不同容差下的稳定性，并通过识别指派群的复杂性首次严格增加时的容差来检测赝对称性。该问题必须在以下基于晶体学对称性核心定义的严格数学规范下解决。\n\n一个晶体由以下部分表示：\n- 一个晶格矩阵 $\\mathbf{L}\\in\\mathbb{R}^{3\\times 3}$，其列向量为实空间基矢 $\\mathbf{a},\\mathbf{b},\\mathbf{c}$，单位为埃（Angstrom，记为 $\\text{\\AA}$），以及\n- 一组 $N$ 个分数坐标 $\\{\\mathbf{f}_i\\in [0,1)^3\\}_{i=1}^N$ 及其物种标签（对于本问题，所有原子使用单一物种）。分数坐标到笛卡尔坐标的映射为 $\\mathbf{r}=\\mathbf{L}\\,\\mathbf{f}$，其中 $\\mathbf{f}$ 是一个列向量。\n\n在本问题中，对称操作被限制为零平移的同构操作（symmorphic），并由一个整数正交旋转（或旋转反射）矩阵 $\\mathbf{R}\\in\\mathrm{O}(3,\\mathbb{Z})$ 表示。如果在位置容差 $\\varepsilon$（单位为 $\\text{\\AA}$）下，变换后的分数坐标集合 $\\{\\mathbf{f}'_i=\\mathbf{R}\\mathbf{f}_i\\ \\mathrm{mod}\\ 1\\}$ 与原始集合 $\\{\\mathbf{f}_j\\}$ 之间存在一一对应关系，使得每一对匹配原子的距离在最小像度量下都在 $\\varepsilon$ 之内，则称结构满足操作 $\\mathbf{R}$：对于每对匹配，其笛卡尔距离\n$$\nd_{ij} \\equiv \\min_{\\mathbf{n}\\in\\mathbb{Z}^3} \\left\\| \\mathbf{L}\\left(\\mathbf{f}'_i-\\mathbf{f}_j+\\mathbf{n}\\right) \\right\\|_2 \\le \\varepsilon,\n$$\n其中 $\\|\\cdot\\|_2$ 为欧几里得范数。最小像搜索必须通过检查所有分量在 $\\{-1,0,1\\}$ 内的整数平移 $\\mathbf{n}$ 并选择最小范数来精确执行。\n\n给定一个固定的候选操作目录，每个操作由其关于原点的矩阵 $\\mathbf{R}$ 指定（以下所有角度均以度为单位）：\n- 恒等操作 $E$：$\\mathbf{R}=\\mathrm{diag}(1,1,1)$。\n- 反演操作 $I$：$\\mathbf{R}=\\mathrm{diag}(-1,-1,-1)$。\n- 绕 $z$ 轴的二重旋转 $C_{2z}$：$\\mathbf{R}=\\mathrm{diag}(-1,-1,1)$。\n- 绕 $z$ 轴的四重旋转 $C_{4z}$：\n$$\n\\mathbf{R}=\\begin{bmatrix}\n0  -1  0\\\\\n1  0  0\\\\\n0  0  1\n\\end{bmatrix}.\n$$\n- 过 $x=0$ 平面的镜面反映 $m_x$：$\\mathbf{R}=\\mathrm{diag}(-1,1,1)$。\n- 过 $y=0$ 平面的镜面反映 $m_y$：$\\mathbf{R}=\\mathrm{diag}(1,-1,1)$。\n- 过 $z=0$ 平面的镜面反映 $m_z$：$\\mathbf{R}=\\mathrm{diag}(1,1,-1)$。\n\n定义以下空间群代理目录（每个由一个整数代码和一组最小必需的已满足操作来标识）。在给定容差下，被指派的群是其所有必需操作均被满足的群中，拥有最多必需操作数量的那个；若存在平局，则由较大的代码打破：\n- 代码 $1$：$P1$，要求 $\\{E\\}$。\n- 代码 $2$：$P\\bar{1}$，要求 $\\{E,I\\}$。\n- 代码 $3$：$P2(z)$，要求 $\\{E,C_{2z}\\}$。\n- 代码 $4$：$Pm(x)$，要求 $\\{E,m_x\\}$。\n- 代码 $5$：$P4$，要求 $\\{E,C_{4z},C_{2z}\\}$。\n- 代码 $6$：$P4/m$，要求 $\\{E,C_{4z},C_{2z},m_z\\}$。\n- 代码 $7$：$Pmm$，要求 $\\{E,m_x,m_y\\}$。\n- 代码 $8$：$P4mm$，要求 $\\{E,C_{4z},C_{2z},m_x,m_y\\}$。\n\n给定一个容差列表 $\\{\\varepsilon_k\\}_{k=1}^K$（单位为 $\\text{\\AA}$），定义指派序列 $\\{G_k\\}_{k=1}^K$，其中 $G_k$ 是在 $\\varepsilon_k$ 处指派的群代码。令 $c(G)$ 表示群 $G$ 所需操作的数量（例如，$c(8)=5$）。如果在最小的索引 $k^\\star\\in\\{2,\\dots,K\\}$ 处有 $c(G_{k^\\star})>c(G_{k^\\star-1})$，则称在 $k^\\star$ 处发生赝对称性跳变。令 $\\varepsilon^\\star=\\varepsilon_{k^\\star}$，$G=G_{k^\\star-1}$，以及 $H=G_{k^\\star}$。如果不存在这样的索引，则没有跳变。\n\n定义稳定性得分 $s$ 为多数群（在 $\\{G_k\\}$ 中出现最频繁的代码；通过选择具有较大 $c(G)$ 的群来打破平局，然后通过较大的代码来打破平局）在容差列表中出现的比例。\n\n仅使用指定的操作和群，并遵循这些核心定义来实现上述功能。所有角度必须以度处理，所有位置容差以 $\\text{\\AA}$ 处理，所有晶格长度以 $\\text{\\AA}$ 处理。\n\n输入数据通过以下测试套件嵌入程序中（无用户输入）。晶格矩阵 $\\mathbf{L}$ 将使用标准的三斜晶系约定，以列向量为晶格矢量，从长度和角度构建：\n- 结构 $S_1$（近四重对称，有轻微各向异性；赝对称）：\n    - 晶格参数：$a=b=3.5\\,\\text{\\AA}$，$c=10.0\\,\\text{\\AA}$，$\\alpha=\\beta=\\gamma=90^\\circ$。\n    - 分数坐标：四个原子位于 $(0.5+u,0.5,0)$、$(0.5-u,0.5,0)$、$(0.5,0.5+v,0)$、$(0.5,0.5-v,0)$，其中 $u=0.2$，$v=0.196$。\n- 结构 $S_2$（通用斜方，除恒等操作外无对称性）：\n    - 晶格参数：$a=3.2\\,\\text{\\AA}$，$b=4.7\\,\\text{\\AA}$，$c=12.0\\,\\text{\\AA}$，$\\alpha=90^\\circ$，$\\beta=90^\\circ$，$\\gamma=80^\\circ$。\n    - 分数坐标：三个原子位于 $(0.1,0.2,0.0)$、$(0.33,0.73,0.0)$、$(0.81,0.27,0.0)$。\n- 结构 $S_3$（完美的四重对称）：\n    - 晶格参数：与 $S_1$ 相同。\n    - 分数坐标：四个原子位于 $(0.5+u,0.5,0)$、$(0.5-u,0.5,0)$、$(0.5,0.5+v,0)$、$(0.5,0.5-v,0)$，其中 $u=0.2$，$v=0.2$。\n\n容差扫描（单位为 $\\text{\\AA}$）固定为 $\\{\\varepsilon_k\\}=\\{0.0005,\\,0.005,\\,0.02,\\,0.05\\}$。\n\n您的程序必须：\n- 对于每个结构和每个容差 $\\varepsilon_k$，确定已满足的操作集，根据上述规则从目录中指派群代码 $G_k$，并生成序列 $\\{G_k\\}$。\n- 计算赝对称性标志 $p$，如果发生跳变则等于 $1$，否则为 $0$。\n- 计算首次跳变容差 $\\varepsilon^\\star$（单位为 $\\text{\\AA}$），四舍五入到四位小数；若无跳变，则输出 $-1.0$。\n- 计算跳变对 $(G,H)$（整数形式）；若无跳变，则输出 $(-1,-1)$。\n- 计算稳定性得分 $s$（一个在 $[0,1]$ 范围内的十进制数），四舍入到三位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含 $S_1$、$S_2$ 和 $S_3$ 的结果，形式为用方括号括起来的逗号分隔列表，每个测试用例的结果是列表 $[p,\\varepsilon^\\star,G,H,s]$。例如，语法模板为 $[[p_1,\\varepsilon^\\star_1,G_1,H_1,s_1],[p_2,\\varepsilon^\\star_2,G_2,H_2,s_2],[p_3,\\varepsilon^\\star_3,G_3,H_3,s_3]]$。角度必须以度为单位，距离和容差必须以 $\\text{\\AA}$ 为单位。",
            "solution": "该问题要求实现一个计算流程，用以分析三维周期性晶体结构的对称性。这包括确定一个结构在指定的位置容差 $\\varepsilon$ 内满足给定目录中的哪些对称操作，基于这些满足的操作指派一个空间群代理，并分析此指派如何随容差的变化而改变。最终输出包括对赝对称性的表征和对指派稳定性的度量。\n\n该方法论遵循问题描述中提供的精确数学定义。\n\n首先，我们建立晶体的几何表示。晶格由三个基矢 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义。根据给定的晶格参数——长度 $a$、$b$、$c$ 和角度 $\\alpha$、$\\beta$、$\\gamma$——我们构建晶格矩阵 $\\mathbf{L} = \\begin{bmatrix} \\mathbf{a} & \\mathbf{b} & \\mathbf{c} \\end{bmatrix}$。该矩阵通过线性变换 $\\mathbf{r} = \\mathbf{L}\\mathbf{f}$ 将分数坐标 $\\mathbf{f} \\in [0,1)^3$ 转换为笛卡尔坐标 $\\mathbf{r} \\in \\mathbb{R}^3$。此构造使用标准的三斜晶系约定，将角度从度转换为弧度以进行三角计算。\n\n分析的核心是确定由整数正交矩阵 $\\mathbf{R}$ 表示的给定对称操作是否在位置容差 $\\varepsilon$ 内被晶体结构所遵守。如果可以在原始原子分数坐标集 $\\{\\mathbf{f}_j\\}$ 和变换后的坐标集 $\\{\\mathbf{f}'_i = \\mathbf{R}\\mathbf{f}_i \\pmod 1\\}$ 之间建立一一对应关系（一个排列组合），则认为该操作被满足。模 $1$ 操作确保变换后的坐标被映射回主晶胞内。为了使对应关系有效，每对匹配原子 $(\\mathbf{f}'_i, \\mathbf{f}_j)$ 之间的笛卡尔距离不得超过 $\\varepsilon$。此距离使用最小像约定来计算，以考虑晶体的周期性。该距离定义为 $d_{ij} = \\min_{\\mathbf{n}\\in\\{-1,0,1\\}^3} \\| \\mathbf{L}(\\mathbf{f}'_i - \\mathbf{f}_j + \\mathbf{n}) \\|_2$。通过检查所有分量在 $\\{-1, 0, 1\\}$ 内的 $27$ 个整数平移向量 $\\mathbf{n}$ 来精确地执行最小值搜索。\n\n为了找到原子位置之间的一一映射，我们将其构建为一个线性分配问题（或最小权重二分图匹配问题）。我们构建一个大小为 $N \\times N$ 的成本矩阵 $\\mathbf{D}$，其中 $D_{ij}$ 是第 $i$ 个变换后的原子 $\\mathbf{f}'_i$ 和第 $j$ 个原始原子 $\\mathbf{f}_j$ 之间的最小像距离。通过 `scipy.optimize.linear_sum_assignment` 提供的匈牙利算法被用来寻找最小化总距离的原子排列。一旦找到这个最优配对，当且仅当该最优分配中的每个距离都小于或等于容差 $\\varepsilon$ 时，操作 $\\mathbf{R}$ 才被视为满足。\n\n通过此程序，对于给定列表中的每个容差 $\\varepsilon_k$，我们可以确定目录中所有已满足的操作的完整集合。下一步是指派一个空间群代理。问题提供了一个包含八个群代理的目录，每个代理由一个代码、一个名称和一组最小必需的对称操作定义。在给定的容差下，我们从目录中找到所有其必需操作都存在于我们已满足操作集合中的群代理。在这些有效候选者中，我们选择拥有最多必需操作数量的那个，记为 $c(G)$。任何平局都通过选择具有较大整数代码的群来解决。\n\n对扫描中的每个容差 $\\varepsilon_k$ 重复此过程，生成一组群指派序列 $\\{G_k\\}$。然后分析此序列以提取两个关键指标：一个赝对称性指示符和一个稳定性得分。\n\n如果在容差扫描的某个点，指派群的复杂性（由 $c(G)$ 度量）严格增加，则检测到赝对称性跳变。我们识别出第一个索引 $k^\\star \\in \\{2, \\dots, K\\}$，在此处 $c(G_{k^\\star}) > c(G_{k^\\star-1})$。如果存在这样的跳变，我们报告一个标志 $p=1$，跳变发生的容差 $\\varepsilon^\\star = \\varepsilon_{k^\\star}$，以及参与转变的一对群代码 $(G, H) = (G_{k^\\star-1}, G_{k^\\star})$。如果没有找到这样的跳变，我们报告 $p=0$ 和占位符值。\n\n稳定性得分 $s$ 量化了对称性指派的稳健性。它被计算为“多数群”被指派的容差所占的比例。多数群是在序列 $\\{G_k\\}$ 中出现最频繁的群。如果频率出现平局，则通过选择具有更高复杂性 $c(G)$ 的群来打破平局。如果仍然存在平局，则通过选择具有更高代码的群来打破。\n\n最终的实现封装了这整个逻辑，通过容差扫描处理三个给定的晶体结构（$S_1, S_2, S_3$），并计算五个所需的输出值：赝对称性标志 $p$、跳变容差 $\\varepsilon^\\star$、跳变对 $(G,H)$ 和稳定性得分 $s$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to perform symmetry analysis on a suite of test structures.\n    \"\"\"\n\n    def get_lattice_matrix(a, b, c, alpha, beta, gamma):\n        \"\"\"\n        Constructs the lattice matrix L from lattice parameters a, b, c, alpha, beta, gamma.\n        The columns of L are the lattice vectors a, b, c in Cartesian space.\n        \"\"\"\n        alpha_rad = np.deg2rad(alpha)\n        beta_rad = np.deg2rad(beta)\n        gamma_rad = np.deg2rad(gamma)\n\n        cos_a, cos_b, cos_g = np.cos(alpha_rad), np.cos(beta_rad), np.cos(gamma_rad)\n        sin_g = np.sin(gamma_rad)\n\n        # Volume term, handle case of sin_g=0 if gamma is 0 or 180\n        vol_sq_term = 1.0 - cos_a**2 - cos_b**2 - cos_g**2 + 2.0 * cos_a * cos_b * cos_g\n        if vol_sq_term  0: vol_sq_term = 0 # handle minor floating point issues\n        \n        # Standard triclinic cell construction\n        # a is along x\n        # b is in xy plane\n        # c is general\n        ax, ay, az = a, 0.0, 0.0\n        bx, by, bz = b * cos_g, b * sin_g, 0.0\n        cx = c * cos_b\n        cy = c * (cos_a - cos_b * cos_g) / sin_g if sin_g != 0 else 0.0\n        cz = c * np.sqrt(vol_sq_term) / sin_g if sin_g != 0 else 0.0\n\n        return np.array([[ax, bx, cx], [ay, by, cy], [az, bz, cz]])\n\n    def is_op_satisfied(L, f_coords, R, epsilon):\n        \"\"\"\n        Checks if a symmetry operation R is satisfied for a given structure and tolerance.\n        \"\"\"\n        num_atoms = f_coords.shape[0]\n        # Transform coordinates: f' = R * f (mod 1)\n        f_prime = (R @ f_coords.T).T\n        f_prime = f_prime - np.floor(f_prime)\n\n        # Build distance matrix D_ij = d(f'_i, f_j) using minimum image convention\n        dist_matrix = np.zeros((num_atoms, num_atoms))\n        \n        # Pre-generate the 27 shift vectors n\n        shifts = np.array([\n            (i, j, k) for i in [-1, 0, 1] for j in [-1, 0, 1] for k in [-1, 0, 1]\n        ])\n\n        for i in range(num_atoms):\n            for j in range(num_atoms):\n                delta_f = f_prime[i] - f_coords[j]\n                \n                # Minimum image distance calculation\n                # Add all 27 shifts to delta_f and find coord with minimum norm\n                all_shifted_f = delta_f + shifts\n                cart_coords = all_shifted_f @ L.T\n                dists_sq = np.sum(cart_coords**2, axis=1)\n                min_dist_sq = np.min(dists_sq)\n                dist_matrix[i, j] = np.sqrt(min_dist_sq)\n\n        # Use Hungarian algorithm to find the optimal one-to-one mapping\n        row_ind, col_ind = linear_sum_assignment(dist_matrix)\n        \n        # Check if all pairs in the optimal assignment are within tolerance\n        max_dist_in_mapping = np.max(dist_matrix[row_ind, col_ind])\n        \n        return max_dist_in_mapping = epsilon\n\n    # Static data as defined in the problem\n    test_suite = [\n        {\n            \"name\": \"S1\",\n            \"lattice_params\": {\"a\": 3.5, \"b\": 3.5, \"c\": 10.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"frac_coords\": np.array([\n                [0.5 + 0.2, 0.5, 0.0], [0.5 - 0.2, 0.5, 0.0],\n                [0.5, 0.5 + 0.196, 0.0], [0.5, 0.5 - 0.196, 0.0]\n            ])\n        },\n        {\n            \"name\": \"S2\",\n            \"lattice_params\": {\"a\": 3.2, \"b\": 4.7, \"c\": 12.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 80.0},\n            \"frac_coords\": np.array([[0.1, 0.2, 0.0], [0.33, 0.73, 0.0], [0.81, 0.27, 0.0]])\n        },\n        {\n            \"name\": \"S3\",\n            \"lattice_params\": {\"a\": 3.5, \"b\": 3.5, \"c\": 10.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"frac_coords\": np.array([\n                [0.5 + 0.2, 0.5, 0.0], [0.5 - 0.2, 0.5, 0.0],\n                [0.5, 0.5 + 0.2, 0.0], [0.5, 0.5 - 0.2, 0.0]\n            ])\n        }\n    ]\n    tolerances = [0.0005, 0.005, 0.02, 0.05]\n    ops_catalog = {\n        'E': np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype=int),\n        'I': np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]], dtype=int),\n        'C2z': np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]], dtype=int),\n        'C4z': np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]], dtype=int),\n        'mx': np.array([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype=int),\n        'my': np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]], dtype=int),\n        'mz': np.array([[1, 0, 0], [0, 1, 0], [0, 0, -1]], dtype=int)\n    }\n    space_groups_catalog = {\n        1: {'reqs': {'E'}}, 2: {'reqs': {'E', 'I'}},\n        3: {'reqs': {'E', 'C2z'}}, 4: {'reqs': {'E', 'mx'}},\n        5: {'reqs': {'E', 'C4z', 'C2z'}}, 6: {'reqs': {'E', 'C4z', 'C2z', 'mz'}},\n        7: {'reqs': {'E', 'mx', 'my'}}, 8: {'reqs': {'E', 'C4z', 'C2z', 'mx', 'my'}}\n    }\n    for code in space_groups_catalog:\n        space_groups_catalog[code]['c'] = len(space_groups_catalog[code]['reqs'])\n\n    final_results = []\n    \n    for structure in test_suite:\n        lattice_matrix = get_lattice_matrix(**structure[\"lattice_params\"])\n        frac_coords = structure[\"frac_coords\"]\n        \n        G_sequence = []\n        for eps in tolerances:\n            satisfied_ops = {op_name for op_name, R in ops_catalog.items()\n                             if is_op_satisfied(lattice_matrix, frac_coords, R, eps)}\n\n            best_group_code = -1\n            max_ops = -1\n            for code, group_data in sorted(space_groups_catalog.items()):\n                if group_data['reqs'].issubset(satisfied_ops):\n                    if group_data['c'] > max_ops:\n                        max_ops = group_data['c']\n                        best_group_code = code\n                    elif group_data['c'] == max_ops:\n                        best_group_code = max(best_group_code, code)\n            G_sequence.append(best_group_code)\n\n        # Analyze G_sequence\n        p, eps_star, G, H = 0, -1.0, -1, -1\n        for k in range(1, len(G_sequence)):\n            c_prev = space_groups_catalog[G_sequence[k-1]]['c']\n            c_curr = space_groups_catalog[G_sequence[k]]['c']\n            if c_curr > c_prev:\n                p = 1\n                eps_star = tolerances[k]\n                G, H = G_sequence[k-1], G_sequence[k]\n                break\n        \n        # Stability score calculation\n        if not G_sequence:\n            s = 0.0\n        else:\n            counts = Counter(G_sequence)\n            max_freq = max(counts.values())\n            candidates = [code for code, freq in counts.items() if freq == max_freq]\n            \n            if len(candidates) == 1:\n                majority_group_code = candidates[0]\n            else:\n                # Tie-breaking: higher complexity c(G), then higher code\n                candidates.sort(key=lambda code: (space_groups_catalog[code]['c'], code), reverse=True)\n                majority_group_code = candidates[0]\n\n            s = counts[majority_group_code] / len(G_sequence)\n\n        # Format results as specified\n        result = [p, round(eps_star, 4), G, H, round(s, 3)]\n        final_results.append(result)\n\n    # Print final result in specified format\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}