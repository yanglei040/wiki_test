{
    "hands_on_practices": [
        {
            "introduction": "在催化、薄膜生长和半导体制造等领域，晶体表面结构，特别是邻近于低指数晶面的高指数“邻切”(vicinal)表面，扮演着至关重要的角色。这个练习将带你解决一个“正向问题”：如何利用米勒指数，不仅仅是作为一个标签，而是作为一个定量工具，来预测具体的物理形貌，如原子台阶的宽度和扭折(kink)的密度。通过这个实践，你将把抽象的晶体学符号与真实的表面结构联系起来。",
            "id": "3442343",
            "problem": "考虑一个简单立方布拉维晶格，晶格参数 $a$ 的单位为埃。一个晶面由其密勒指数 $(h,k,l)$ 表示，在立方晶体中，其向外的单位法向量平行于 $(h,k,l)$ 方向。$(111)$ 晶面的单位法向量平行于 $(1,1,1)$。一个邻近 $(111)$ 晶面的倾斜表面可以由 $(h,h,l)$（其中 $h,l \\in \\mathbb{Z}^{+}$）参数化，其错切角 $\\alpha$ 是 $(h,h,l)$ 和 $(111)$ 法向量之间的锐角。对于立方晶系，晶面间距满足经过充分检验的关系式 $1/d_{hkl}^{2} = (h^{2}+k^{2}+l^{2})/a^{2}$。\n\n您的任务是编写一个完整的、可运行的程序，对于每个指定的 $(h,h,l)$ 倾斜表面：\n- 根据单位法向量之间夹角的几何定义，推导出以弧度为单位的错切角 $\\alpha$。\n- 使用立方晶系的晶面间距关系式计算晶面间距 $d_{111}$。\n- 根据直角三角形几何关系计算台面宽度 $w$，其中台阶高度等于 $d_{111}$，斜率由错切角 $\\alpha$ 决定。\n- 通过选取两个最短的平面内晶格平移，从简单立方三维晶格构建 $(111)$ 晶面的二维表面晶格，并将它们投影到两个正交的平面内方向上：沿 $[1\\;\\overline{1}\\;0]$ 的台阶边缘方向 $\\hat{\\mathbf{u}}_{\\parallel}$ 和沿 $[1\\;1\\;\\overline{2}]$ 的错切方向 $\\hat{\\mathbf{u}}_{\\perp}$。利用这些，将平面内行间距 $s_{\\perp}$ 定义为平面内基向量的任意非零整数组合在 $\\hat{\\mathbf{u}}_{\\perp}$ 上的最小正投影，并类似地将 $s_{\\parallel}$ 定义为在 $\\hat{\\mathbf{u}}_{\\parallel}$ 上的最小正投影。所有投影都必须以埃为单位计算。\n- 形成比率 $r = w/s_{\\perp}$，并通过 $r$ 的简单连分数的渐进分数计算 $r$ 的最佳有理逼近 $p/q$，其约束条件为最大分母 $q \\leq Q_{\\max}$（给定整数界限 $Q_{\\max}$）。如果 $\\alpha = 0$，则定义 $w$ 为 $+\\infty$ 并设置 $p=q=0$。\n- 预测台阶密度为 $\\delta_{\\text{step}} = 1/w$（单位为 $\\text{\\AA}^{-1}$，约定当 $w=+\\infty$ 时 $\\delta_{\\text{step}}=0$）。\n- 使用有理逼近预测沿台阶边缘的扭折线密度为 $\\delta_{\\text{kink}} = p/(q\\,s_{\\parallel})$（单位为 $\\text{\\AA}^{-1}$，并定义当 $q=0$ 时 $\\delta_{\\text{kink}}=0$）。\n\n您必须使用的基本依据和定义：\n- 在立方晶体中，$(h,k,l)$ 晶面的单位法向量与 $(h,k,l)$ 成正比。\n- 两个单位向量 $\\hat{\\mathbf{n}}_{1}$ 和 $\\hat{\\mathbf{n}}_{2}$ 之间的夹角由它们的点积决定：$\\cos \\alpha = \\hat{\\mathbf{n}}_{1}\\cdot \\hat{\\mathbf{n}}_{2}$。\n- 立方晶体的晶面间距关系式为 $1/d_{hkl}^{2} = (h^{2}+k^{2}+l^{2})/a^{2}$。\n- $(111)$ 二维晶格可由位于 $(111)$ 平面内且在简单立方晶格中满足 $x+y+z=0$ 的最短非零晶格平移生成；一对方便的向量是 $\\mathbf{t}_{1} = a(1,-1,0)$ 和 $\\mathbf{t}_{2} = a(1,0,-1)$，它们张成了六方表面网格。\n- 正交平面内方向：$\\hat{\\mathbf{u}}_{\\parallel} \\parallel (1,-1,0)$ 和 $\\hat{\\mathbf{u}}_{\\perp} \\parallel (1,1,-2)$，要求进行精确归一化，使它们成为 $(111)$ 平面内的单位向量。\n\n角度单位和物理单位：\n- 所有角度均以弧度表示。\n- 所有长度均以埃表示。\n- 所有密度（台阶密度和扭折密度）均以埃的倒数表示。\n\n数值输出规范：\n- 对于每个测试用例，输出一个包含七个条目的列表 $[\\alpha, d_{111}, w, \\delta_{\\text{step}}, p, q, \\delta_{\\text{kink}}]$，其中 $\\alpha$、 $d_{111}$、 $w$、 $\\delta_{\\text{step}}$ 和 $\\delta_{\\text{kink}}$ 是浮点数， $p$、 $q$ 是整数。如果 $w=+\\infty$，则将其打印为浮点数无穷大，并设置 $\\delta_{\\text{step}}=0$ 和 $\\delta_{\\text{kink}}=0$。\n- 将所有有限浮点数量四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的七元组列表，并用方括号括起来，例如：$[[\\dots],[\\dots],\\dots]$。\n\n测试套件：\n- 用例 A（一般倾斜面）：$a = 3.600$ 埃，$(h,h,l)=(1,1,3)$，$Q_{\\max} = 20$。\n- 用例 B（中等倾斜面）：$a = 4.050$ 埃，$(h,h,l)=(2,2,3)$，$Q_{\\max} = 50$。\n- 用例 C（边界 $(111)$）：$a = 5.430$ 埃，$(h,h,l)=(1,1,1)$，$Q_{\\max} = 20$。\n- 用例 D（小错切角）：$a = 3.520$ 埃，$(h,h,l)=(10,10,11)$，$Q_{\\max} = 200$。\n\n最终输出格式：\n- 您的程序必须精确打印一行：一个包含四个列表（每个测试用例一个）的单一数组，每个列表为 $[\\alpha, d_{111}, w, \\delta_{\\text{step}}, p, q, \\delta_{\\text{kink}}]$，其中浮点数四舍五入到六位小数，整数不进行四舍五入，例如：$[[\\alpha_{A},d_{111,A},w_{A},\\delta_{\\text{step},A},p_{A},q_{A},\\delta_{\\text{kink},A}],[\\alpha_{B},\\dots],\\dots]$。",
            "solution": "用户提供的问题是计算材料科学领域中一个适定的计算任务，具体涉及倾斜表面的晶体学。该问题具有科学依据，内部一致，并包含获得唯一解所需的所有信息。因此，该问题被认为是**有效的**。\n\n解决方案通过为每个给定的测试用例实现问题陈述中指定的计算序列来进行。一个测试用例由简单立方晶格参数 $a$、倾斜晶面的指数 $(h,h,l)$ 以及用于有理逼近的最大分母 $Q_{\\max}$ 定义。\n\n所需的量推导如下：\n\n1.  **错切角 ($\\alpha$)**: 错切角 $\\alpha$ 是倾斜晶面 $(h,h,l)$ 的法向量与参考晶面 $(111)$ 的法向量之间的锐角。对于立方晶体，晶面 $(h,k,l)$ 的法线是 $[h,k,l]$ 方向。设 $\\mathbf{n}_v = (h,h,l)$ 和 $\\mathbf{n}_r = (1,1,1)$ 为法向量。它们之间的夹角使用点积公式求得：\n    $$ \\cos \\alpha = \\frac{\\mathbf{n}_v \\cdot \\mathbf{n}_r}{\\|\\mathbf{n}_v\\| \\|\\mathbf{n}_r\\|} = \\frac{(h)(1) + (h)(1) + (l)(1)}{\\sqrt{h^2+h^2+l^2} \\sqrt{1^2+1^2+1^2}} = \\frac{2h+l}{\\sqrt{2h^2+l^2}\\sqrt{3}} $$\n    角度则为 $\\alpha = \\arccos\\left(\\frac{2h+l}{\\sqrt{3(2h^2+l^2)}}\\right)$。对于晶面本身就是 $(111)$ 的特殊情况（即 $h=l$），分子变为 $3h$，分母变为 $\\sqrt{3(3h^2)} = 3h$，所以 $\\cos \\alpha = 1$ 且 $\\alpha=0$。\n\n2.  **晶面间距 ($d_{111}$)**: 对于晶格参数为 $a$ 的立方晶体，晶面间距 $d_{hkl}$ 由 $1/d_{hkl}^2 = (h^2+k^2+l^2)/a^2$ 给出。对于 $(111)$ 晶面，这得到：\n    $$ \\frac{1}{d_{111}^2} = \\frac{1^2+1^2+1^2}{a^2} = \\frac{3}{a^2} \\implies d_{111} = \\frac{a}{\\sqrt{3}} $$\n    该值代表了倾斜表面上单个原子台阶的高度。\n\n3.  **台面宽度 ($w$) 和台阶密度 ($\\delta_{\\text{step}}$)**: 倾斜表面可以被看作一个阶梯，其中台面是原子级平坦的 $(111)$ 晶面，而台阶是高度为 $d_{111}$ 的原子台阶。错切角 $\\alpha$ 通过简单的三角学将台阶高度和台面宽度 $w$ 联系起来：\n    $$ \\tan \\alpha = \\frac{\\text{台阶高度}}{\\text{台面宽度}} = \\frac{d_{111}}{w} $$\n    因此，台面宽度为 $w = d_{111} / \\tan \\alpha$。如果 $\\alpha = 0$，表面是完全平坦的，所以 $w = \\infty$。台阶密度是台面宽度的倒数，$\\delta_{\\text{step}} = 1/w$。如果 $w=\\infty$，则 $\\delta_{\\text{step}}=0$。\n\n4.  **平面内行间距 ($s_{\\parallel}, s_{\\perp}$)**: 问题在 $(111)$ 表面上定义了两个正交的平面内方向：$\\hat{\\mathbf{u}}_{\\parallel}$ 平行于 $[1\\;\\overline{1}\\;0]$，$\\hat{\\mathbf{u}}_{\\perp}$ 平行于 $[1\\;1\\;\\overline{2}]$。它们的归一化形式是：\n    $$ \\hat{\\mathbf{u}}_{\\parallel} = \\frac{1}{\\sqrt{2}}(1, -1, 0) \\quad \\text{和} \\quad \\hat{\\mathbf{u}}_{\\perp} = \\frac{1}{\\sqrt{6}}(1, 1, -2) $$\n    二维表面晶格由基向量 $\\mathbf{t}_1 = a(1,-1,0)$ 和 $\\mathbf{t}_2 = a(1,0,-1)$ 的整数组合（$m, n \\in \\mathbb{Z}$）生成。一个通用的表面晶格向量是 $\\mathbf{T} = m\\mathbf{t}_1 + n\\mathbf{t}_2 = a(m+n, -m, -n)$。\n    $\\mathbf{T}$ 在 $\\hat{\\mathbf{u}}_{\\parallel}$ 上的投影是 $P_{\\parallel} = \\mathbf{T} \\cdot \\hat{\\mathbf{u}}_{\\parallel} = \\frac{a}{\\sqrt{2}}(2m+n)$。由于 $m$ 和 $n$ 是整数，$2m+n$ 可以是任意整数。最小正投影对应 $2m+n=1$，因此 $s_{\\parallel} = a/\\sqrt{2}$。\n    $\\mathbf{T}$ 在 $\\hat{\\mathbf{u}}_{\\perp}$ 上的投影是 $P_{\\perp} = \\mathbf{T} \\cdot \\hat{\\mathbf{u}}_{\\perp} = \\frac{a}{\\sqrt{6}}(3n) = \\frac{a\\sqrt{3}}{\\sqrt{2}}n$。最小正投影对应 $n=1$，因此 $s_{\\perp} = a\\sqrt{3}/\\sqrt{2}$。\n\n5.  **有理逼近 ($p/q$)**: 计算比率 $r = w/s_{\\perp}$。代入 $w$ 和 $s_{\\perp}$ 的表达式：\n    $$ r = \\frac{w}{s_{\\perp}} = \\frac{d_{111}/\\tan\\alpha}{a\\sqrt{3}/\\sqrt{2}} = \\frac{(a/\\sqrt{3})/\\tan\\alpha}{a\\sqrt{3}/\\sqrt{2}} = \\frac{a}{\\sqrt{3}\\tan\\alpha} \\cdot \\frac{\\sqrt{2}}{a\\sqrt{3}} = \\frac{\\sqrt{2}}{3\\tan\\alpha} $$\n    使用连分数算法找到 $r$ 的最佳有理逼近 $p/q$，约束条件是分母 $q$ 不超过 $Q_{\\max}$。这可以通过标准库函数高效处理。对于 $\\alpha=0$ 的情况，问题明确定义 $p=0$ 和 $q=0$。\n\n6.  **扭折密度 ($\\delta_{\\text{kink}}$)**: 沿台阶边缘的扭折线密度由 $\\delta_{\\text{kink}} = p/(q s_{\\parallel})$ 给出。如果 $q=0$，则 $\\delta_{\\text{kink}}=0$。\n\n这些步骤在一个 Python 程序中实现，该程序遍历提供的测试用例，执行计算，并按规定格式化输出。",
            "answer": "```python\nimport numpy as np\nfrom fractions import Fraction\n\ndef calculate_properties(a, h_idx, l_idx, Q_max):\n    \"\"\"\n    Calculates crystallographic properties for a vicinal surface.\n    \n    Args:\n        a (float): Lattice parameter in angstroms.\n        h_idx (int): The 'h' index for the (h,h,l) plane.\n        l_idx (int): The 'l' index for the (h,h,l) plane.\n        Q_max (int): Maximum denominator for rational approximation.\n        \n    Returns:\n        list: A list of 7 calculated properties.\n    \"\"\"\n    \n    # 1. Miscut Angle (alpha)\n    # The normal to (h,h,l) is (h,h,l). The normal to (1,1,1) is (1,1,1).\n    if h_idx == l_idx:\n        # This is the (111) plane direction, so miscut is zero.\n        alpha = 0.0\n    else:\n        # cos(alpha) = (v1 . v2) / (|v1| |v2|)\n        cos_alpha_num = 2 * h_idx + l_idx\n        cos_alpha_den = np.sqrt(3 * (2 * h_idx**2 + l_idx**2))\n        # Clamp to handle potential floating point errors for arguments near 1.0\n        cos_alpha_arg = np.clip(cos_alpha_num / cos_alpha_den, -1.0, 1.0)\n        alpha = np.arccos(cos_alpha_arg)\n\n    # 2. Interplanar Spacing (d111) for the (111) plane\n    d111 = a / np.sqrt(3)\n\n    # 3. Terrace Width (w) and Step Density (delta_step)\n    if alpha  1e-12: # Treat very small angles as zero\n        w = np.inf\n        delta_step = 0.0\n    else:\n        tan_alpha = np.tan(alpha)\n        w = d111 / tan_alpha\n        delta_step = 1.0 / w\n\n    # 4. In-plane Row Spacings (s_parallel, s_perp)\n    s_parallel = a / np.sqrt(2)\n    s_perp = a * np.sqrt(3) / np.sqrt(2)\n\n    # 5. Best Rational Approximant (p/q)\n    if w == np.inf:\n        # Special case as defined in the problem\n        p, q = 0, 0\n    else:\n        r = w / s_perp\n        # Use standard library's Fraction to find the best rational approximant\n        rational_approx = Fraction(r).limit_denominator(Q_max)\n        p = rational_approx.numerator\n        q = rational_approx.denominator\n\n    # 6. Kink Linear Density (delta_kink)\n    if q == 0:\n        # By definition, if q is 0, kink density is 0.\n        delta_kink = 0.0\n    else:\n        delta_kink = p / (q * s_parallel)\n\n    return [alpha, d111, w, delta_step, p, q, delta_kink]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (a, h, l, Q_max) corresponding to (h,h,l) planes\n        (3.600, 1, 3, 20),      # Case A: (1,1,3)\n        (4.050, 2, 3, 50),      # Case B: (2,2,3)\n        (5.430, 1, 1, 20),      # Case C: (1,1,1)\n        (3.520, 10, 11, 200),   # Case D: (10,10,11)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        a, h_idx, l_idx, Q_max = case\n        result = calculate_properties(a, h_idx, l_idx, Q_max)\n        all_results.append(result)\n\n    def format_value(v):\n        \"\"\"Formats a single value according to the output specification.\"\"\"\n        if isinstance(v, float):\n            if np.isinf(v):\n                return 'inf'\n            # Format to 6 decimal places, f-string handles rounding.\n            return f'{v:.6f}'\n        # Integers p and q are returned as strings.\n        return str(v)\n\n    def format_result_list(result_list):\n        \"\"\"Formats a list of results into the required string format.\"\"\"\n        return f\"[{','.join(format_value(v) for v in result_list)}]\"\n\n    # Generate the final output string\n    formatted_strings = [format_result_list(res) for res in all_results]\n    print(f\"[{','.join(formatted_strings)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "在解决了从指数预测结构的“正向问题”后，我们自然会面对“逆向问题”：在实际实验中，我们如何从测量数据中确定米勒指数？例如，在电子背散射衍射(EBSD)或透射电子显微镜(TEM)实验中，我们测量的是晶体的取向，并需要反推出对应的晶面指数。这个任务常常因为实验噪声和异常值的存在而变得复杂。本练习将介绍一种稳健的计算方法来应对这一挑战，它融合了晶体学知识和统计数据分析技术。",
            "id": "3442251",
            "problem": "给定三维笛卡尔坐标系中的一组有限的、经过测量的单位法线方向，以及一个定义了Miller指数和晶面法线之间晶体学关系的倒易点阵基矢。基本依据包括倒易点阵矢量和Miller指数的定义，以及一个几何关系：Miller指数为 $(hkl)$ 的晶面，其法线方向平行于倒易点阵矢量 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$。其中，$\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 是倒易点阵基矢，满足 $\\mathbf{b}_i \\cdot \\mathbf{a}_j = 2\\pi \\delta_{ij}$，而 $\\mathbf{a}_j$ 是正点阵基矢。在笛卡尔坐标系中，可观测的晶面法线方向与 $\\mathbf{G}$ 共线，并且其方向在符号翻转 $\\mathbf{G} \\mapsto -\\mathbf{G}$ 下保持不变。\n\n您的任务是编写一个完整、可运行的程序，根据测量的单位法线方向 $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$ 来推断某个晶面的互质整数Miller指数 $(h,k,l) \\in \\mathbb{Z}^3$，并能稳健地处理离群值。该推断必须基于最小化测量方向与候选倒易矢量方向 $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$ 之间的角偏差的稳健聚合值。每次测量的角偏差由以弧度为单位的角度定义\n$$\n\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big),\n$$\n该定义强制了对于 $\\hat{\\mathbf{G}}$ 符号的不变性。稳健性必须通过使用参数为 $\\delta  0$ 的Huber损失函数来聚合偏差实现，\n$$\n\\rho_\\delta(\\varphi) = \\begin{cases}\n\\frac{1}{2}\\varphi^2,  |\\varphi| \\le \\delta,\\\\\n\\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right),  |\\varphi|  \\delta,\n\\end{cases}\n$$\n（可选地）在裁剪掉最大的一部分（比例为 $\\tau \\in [0,1)$）的 $\\{\\varphi_i\\}$ 以剔除离群值之后。待最小化的目标是剩余角度的Huber损失的裁剪后总和。\n\n整数约束条件如下：\n- $(h,k,l) \\in \\mathbb{Z}^3$，\n- $(h,k,l) \\neq (0,0,0)$，\n- $\\gcd(|h|,|k|,|l|) = 1$ (互质整数约束)，\n- 对于给定的界限 $H_{\\max} \\in \\mathbb{N}$，有 $|h|,|k|,|l| \\le H_{\\max}$。\n\n由于不应使用通用混合整数求解器，程序必须在界限 $H_{\\max}$ 内对所有候选者进行精确枚举，并选择使稳健目标最小化的那个。如果目标值出现平局，则按以下顺序应用确定性决胜规则：\n- 优先选择 $\\|\\mathbf{G}\\|$ 较小的候选者，\n- 其次优先选择其第一个非零指数为正的候选者（规范符号约定），\n- 接着优先选择绝对值元组 $(|h|,|k|,|l|)$ 字典序较小的候选者，\n- 最后在规范符号约定下，优先选择带符号元组 $(h,k,l)$ 字典序较小的候选者。\n\n所有角度必须以弧度计算。每个测试用例的最终答案必须表示为整数三元组 $[h,k,l]$。\n\n请实现程序以解决以下测试套件，并严格按照提供的参数和数据进行。对于每个案例，倒易基矢矩阵 $\\mathbf{B} \\in \\mathbb{R}^{3 \\times 3}$ 以其列向量 $\\mathbf{b}_1,\\mathbf{b}_2,\\mathbf{b}_3$ 的形式给出，并且测量的单位法线被明确列出。$\\mathbf{B}$ 的单位是长度的倒数，但在目标函数中仅使用方向。\n\n- 测试用例1（简单立方，目标接近 $(1,1,0)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。\n  - 测量的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.71, 0.70, 0.00)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.69, 0.72, 0.02)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.73, 0.68, -0.01)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.71, -0.70, 0.00)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 0.00, 1.00)$,\n    - $\\hat{\\mathbf{n}}_6 = (0.70, 0.71, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$, $\\tau = 0.17$, $H_{\\max} = 3$。\n\n- 测试用例2（简单立方，目标接近 $(1,1,1)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。\n  - 测量的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.58, 0.58, 0.58)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.60, 0.61, 0.51)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.55, 0.56, 0.65)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.58, -0.58, -0.58)$,\n    - $\\hat{\\mathbf{n}}_5 = (1.00, 0.00, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$, $\\tau = 0.20$, $H_{\\max} = 3$。\n\n- 测试用例3（正交倒易基矢，目标接近 $(2,1,1)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} \\frac{1}{3}  0  0 \\\\ 0  \\frac{1}{4}  0 \\\\ 0  0  \\frac{1}{5} \\end{bmatrix}$ （列向量为 $\\left(\\frac{1}{3},0,0\\right)$, $\\left(0,\\frac{1}{4},0\\right)$, $\\left(0,0,\\frac{1}{5}\\right)$）。\n  - 测量的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.90, 0.34, 0.27)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.89, 0.35, 0.29)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.92, 0.33, 0.26)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.90, -0.34, -0.27)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$, $\\tau = 0.20$, $H_{\\max} = 4$。\n\n- 测试用例4（指数中含零的边界情况，目标接近 $(0,0,1)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。\n  - 测量的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.00, 0.01, 0.9999)$,\n    - $\\hat{\\mathbf{n}}_2 = (-0.01, 0.00, 0.9998)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.02, -0.01, 0.9997)$,\n    - $\\hat{\\mathbf{n}}_4 = (1.00, 0.00, 0.00)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$, $\\tau = 0.40$, $H_{\\max} = 2$。\n\n您的程序必须实现候选者的精确枚举、以弧度为单位的稳健目标值计算、按 $\\tau$ 比例进行裁剪以及指定的决胜规则。最终输出必须是单行，包含四个测试用例推断出的指数三元组的逗号分隔列表，并用方括号括起来，例如 $[\\,[h_1,k_1,l_1],\\,[h_2,k_2,l_2],\\,[h_3,k_3,l_3],\\,[h_4,k_4,l_4]\\,]$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，格式与下述完全一致：\n$$\n[[h_1,k_1,l_1],[h_2,k_2,l_2],[h_3,k_3,l_3],[h_4,k_4,l_4]].\n$$",
            "solution": "### 问题验证\n\n已根据指定标准对问题陈述进行了严格评估。\n\n**步骤1：提取给定信息**\n\n*   **目标**：从一组 $N$ 个测量的单位法线方向 $\\{\\hat{\\mathbf{n}}_i\\}$ 中推断出互质整数Miller指数 $(h,k,l) \\in \\mathbb{Z}^3$。\n*   **物理模型**：具有Miller指数 $(h,k,l)$ 的晶面，其法线方向平行于倒易点阵矢量 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$。该方向在符号翻转 $\\mathbf{G} \\mapsto -\\mathbf{G}$ 下保持不变。\n*   **倒易基矢**：对于每个测试用例，向量 $\\mathbf{b}_i$ 作为矩阵 $\\mathbf{B}$ 的列向量提供。\n*   **优化准则**：最小化角偏差的Huber损失的裁剪后总和。\n*   **角偏差**：$\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big)$，其中 $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$。\n*   **Huber损失**：定义了一个带有参数 $\\delta$ 的稳健损失函数 $\\rho_\\delta(\\varphi)$。\n    $$\n    \\rho_\\delta(\\varphi) = \\begin{cases}\n    \\frac{1}{2}\\varphi^2,  |\\varphi| \\le \\delta,\\\\\n    \\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right),  |\\varphi|  \\delta.\n    \\end{cases}\n    $$\n*   **裁剪**：在聚合之前，将角偏差 $\\{\\varphi_i\\}$ 中最大的一部分（比例为 $\\tau$）作为离群值丢弃。\n*   **搜索空间约束**：\n    1.  $(h,k,l)$ 为整数。\n    2.  $(h,k,l) \\neq (0,0,0)$。\n    3.  $\\gcd(|h|,|k|,|l|) = 1$。\n    4.  $|h|,|k|,|l| \\le H_{\\max}$。\n*   **求解方法**：对搜索空间内的所有有效候选者进行精确枚举。\n*   **决胜规则（按应用顺序）**：\n    1.  优先选择较小的目标值。\n    2.  优先选择较小的矢量范数 $\\|\\mathbf{G}\\|$。\n    3.  优先选择第一个非零指数为正的候选者。\n    4.  优先选择绝对值元组 $(|h|,|k|,|l|)$ 字典序较小的候选者。\n    5.  优先选择带符号元组 $(h,k,l)$ 字典序较小的候选者。\n*   **测试数据**：提供了四个具体的测试用例，每个用例都包含一个倒易基矢矩阵 $\\mathbf{B}$、一组测量的法线 $\\{\\hat{\\mathbf{n}}_i\\}$ 以及参数 $\\delta$、$\\tau$ 和 $H_{\\max}$。\n\n**步骤2：使用提取的给定信息进行验证**\n\n对问题的有效性进行分析：\n*   **科学上成立**：该问题从根本上基于固态物理学和晶体学的既定原理，特别是Miller指数和倒易点阵矢量之间的关系。所采用的统计方法（稳健损失函数、离群值裁剪）是标准的，适合分析带有噪声的实验数据。\n*   **适定性**：该问题是适定的。目标函数有明确定义，搜索空间是有限的，并且全面、确定性的决胜规则确保了唯一解的存在且可以被找到。\n*   **客观性**：问题以精确、正式的语言陈述，没有歧义或主观论断。\n*   **完整性**：为每个测试用例提供了所有必要信息——基矢、测量数据和所有模型参数。\n*   **可行性**：指定的搜索界限 $H_{\\max}$ 产生的搜索空间对于所要求的精确枚举方法而言，在计算上是易于处理的。对于最大的界限 $H_{\\max} = 4$，需要检查的候选者数量为 $(2 \\cdot 4 + 1)^3 - 1 = 728$，这完全在现代处理器的可行范围内。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。它在计算材料科学领域是一个定义明确、科学合理且计算上可行的任务。将开发并呈现一个解决方案。\n\n### 求解方法论\n\n此任务旨在通过在离散搜索空间上执行约束优化，为一组测量的晶面法线确定最可能的Miller指数 $(h,k,l)$。该方法论包括三个主要部分：候选者生成、目标函数评估以及带有确定性决胜规则的系统搜索。\n\n**1. 候选者生成与约束**\n\n解空间由整数三元组 $(h,k,l)$ 组成。对所有满足 $|h| \\le H_{\\max}$、 $|k| \\le H_{\\max}$ 和 $|l| \\le H_{\\max}$ 的候选者进行穷举搜索。每个生成的候选者 $(h,k,l)$ 都需要通过两个主要的晶体学约束进行验证：\n*   **非平凡性**：指数不能是零向量，即 $(h,k,l) \\neq (0,0,0)$。\n*   **互质性**：指数必须互质，即 $\\gcd(|h|,|k|,|l|) = 1$。这确保了指数代表一个唯一的晶面族，并且是其最低整数形式。最大公约数计算为 $\\gcd(\\text{abs}(h), \\gcd(\\text{abs}(k), \\text{abs}(l)))$。\n\n**2. 目标函数评估**\n\n对于每个有效的候选者 $(h,k,l)$，计算一个稳健的目标值，以量化其与测量数据 $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$ 的一致性。该过程包括几个步骤：\n*   **倒易矢量计算**：使用提供的倒易基矢矩阵 $\\mathbf{B} = [\\mathbf{b}_1 | \\mathbf{b}_2 | \\mathbf{b}_3]$ 计算相应的倒易点阵矢量 $\\mathbf{G}$。令 $\\mathbf{m} = [h,k,l]^T$，通过矩阵-向量乘法找到该矢量：$\\mathbf{G} = \\mathbf{B} \\mathbf{m}$。\n*   **角偏差**：将矢量 $\\mathbf{G}$ 归一化以获得单位方向 $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$。对于每个测量的法线 $\\hat{\\mathbf{n}}_i$，其角偏差 $\\varphi_i$ 计算为 $\\varphi_i = \\arccos(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|)$。使用绝对值 $|\\cdot|$ 正确地考虑了晶面法线与其相反方向在物理上的等效性。\n*   **稳健聚合**：为减轻离群值的影响，执行一个两阶段的稳健聚合。\n    1.  **裁剪**：对计算出的 $N$ 个角度 $\\{\\varphi_i\\}$ 集合进行排序，并丢弃其中最大的 $\\lfloor \\tau N \\rfloor$ 个角度，其中 $\\tau$ 是裁剪比例。\n    2.  **Huber损失**：对于每个剩余的角度 $\\varphi$，计算其Huber损失 $\\rho_\\delta(\\varphi)$。此函数对于小偏差（$|\\varphi| \\le \\delta$）呈二次方关系，惩罚较轻；对于大偏差（$|\\varphi|  \\delta$）呈线性关系，从而减少了残差的影响。\n*   **总目标**：候选者 $(h,k,l)$ 的最终目标值是裁剪后角度集合上所有Huber损失的总和。\n\n**3. 优化与决胜**\n\n算法遍历所有有效的候选者，并为每个候选者计算目标值。它会记录迄今为止找到的“最佳”候选者。如果新候选者的目标值严格低于当前最佳值，则替换当前最佳者。在目标值出现平局的情况下，会调用一个多阶段、确定性的决胜程序以确保唯一解：\n\n1.  **矢量范数**：优先选择具有较小倒易矢量范数 $\\|\\mathbf{G}\\|$ 的候选者。这倾向于选择具有更大晶面间距的晶面，这是一种常见的物理偏好。\n2.  **规范符号**：如果仍然平局，则选择第一个非零指数（从 $h$ 到 $k$ 再到 $l$ 读取）为正的候选者。\n3.  **绝对值字典序**：如果仍然平局，则按字典序比较候选者的绝对指数 $(|h|,|k|,|l|)$。优先选择较小者。\n4.  **带符号字典序**：作为最后的决胜规则，按字典序比较带符号指数 $(h,k,l)$。选择较小的元组。\n\n这种结构化的搜索和决胜协议保证了为所提供的每个测试用例都能识别出唯一的最优Miller指数集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases for Miller index inference.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.71, 0.70, 0.00],\n                [0.69, 0.72, 0.02],\n                [0.73, 0.68, -0.01],\n                [-0.71, -0.70, 0.00],\n                [0.00, 0.00, 1.00],\n                [0.70, 0.71, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.17,\n            \"H_max\": 3\n        },\n        # Test Case 2\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.58, 0.58, 0.58],\n                [0.60, 0.61, 0.51],\n                [0.55, 0.56, 0.65],\n                [-0.58, -0.58, -0.58],\n                [1.00, 0.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 3\n        },\n        # Test Case 3\n        {\n            \"B\": np.array([[1/3, 0, 0], [0, 1/4, 0], [0, 0, 1/5]]),\n            \"normals\": np.array([\n                [0.90, 0.34, 0.27],\n                [0.89, 0.35, 0.29],\n                [0.92, 0.33, 0.26],\n                [-0.90, -0.34, -0.27],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 4\n        },\n        # Test Case 4\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.00, 0.01, 0.9999],\n                [-0.01, 0.00, 0.9998],\n                [0.02, -0.01, 0.9997],\n                [1.00, 0.00, 0.00],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.40,\n            \"H_max\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Before passing normals, ensure they are unit vectors\n        norm_of_normals = np.linalg.norm(case[\"normals\"], axis=1, keepdims=True)\n        # Avoid division by zero for zero vectors, though not expected here\n        norm_of_normals[norm_of_normals == 0] = 1.0\n        unit_normals = case[\"normals\"] / norm_of_normals\n        \n        best_hkl = find_best_hkl(case[\"B\"], unit_normals, case[\"delta\"], case[\"tau\"], case[\"H_max\"])\n        results.append(list(best_hkl))\n    \n    # Format output precisely as requested: [[h1,k1,l1],[h2,k2,l2],...]\n    inner_results_str = [f\"[{h},{k},{l}]\" for h, k, l in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\n\ndef huber_loss(phi, delta):\n    \"\"\"Calculates the Huber loss for a given angle phi and parameter delta.\"\"\"\n    if abs(phi) = delta:\n        return 0.5 * phi**2\n    else:\n        return delta * (abs(phi) - 0.5 * delta)\n\ndef first_nonzero_is_positive(h, k, l):\n    \"\"\"Checks if the first non-zero element of (h,k,l) is positive.\"\"\"\n    if h > 0: return True\n    if h  0: return False\n    if k > 0: return True\n    if k  0: return False\n    if l > 0: return True\n    # l  0 is the only remaining case, as (0,0,0) is excluded\n    return False\n\ndef find_best_hkl(B, normals, delta, tau, H_max):\n    \"\"\"\n    Finds the best Miller indices (h,k,l) by minimizing the robust objective function.\n    \"\"\"\n    best_candidate = {\n        \"hkl\": None,\n        \"objective\": float('inf'),\n        \"norm_G\": float('inf'),\n    }\n\n    n_normals = normals.shape[0]\n    num_to_trim = int(math.floor(tau * n_normals))\n\n    for h in range(-H_max, H_max + 1):\n        for k in range(-H_max, H_max + 1):\n            for l in range(-H_max, H_max + 1):\n                \n                # Constraint 1: Not (0,0,0)\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                # Constraint 2: Coprime\n                if math.gcd(abs(h), math.gcd(abs(k), abs(l))) != 1:\n                    continue\n                \n                hkl_vec = np.array([h, k, l])\n                \n                # Calculate objective\n                G = B @ hkl_vec\n                norm_G = np.linalg.norm(G)\n                \n                if norm_G == 0: # Should not happen with valid B and non-zero hkl\n                    continue\n                \n                G_hat = G / norm_G\n                \n                dot_products = np.abs(normals @ G_hat)\n                # Clamp to avoid domain errors with arccos due to float precision\n                dot_products = np.clip(dot_products, -1.0, 1.0)\n                angles = np.arccos(dot_products)\n                \n                sorted_angles = np.sort(angles)\n                \n                if num_to_trim > 0:\n                    trimmed_angles = sorted_angles[:-num_to_trim]\n                else:\n                    trimmed_angles = sorted_angles\n                \n                objective = sum(huber_loss(phi, delta) for phi in trimmed_angles)\n                \n                # Comparison and tie-breaking\n                is_better = False\n                if objective  best_candidate[\"objective\"]:\n                    is_better = True\n                elif objective == best_candidate[\"objective\"]:\n                    if norm_G  best_candidate[\"norm_G\"]:\n                        is_better = True\n                    elif norm_G == best_candidate[\"norm_G\"]:\n                        new_is_pos = first_nonzero_is_positive(h, k, l)\n                        best_is_pos = first_nonzero_is_positive(*best_candidate[\"hkl\"])\n                        if new_is_pos and not best_is_pos:\n                            is_better = True\n                        elif new_is_pos == best_is_pos:\n                            abs_new = (abs(h), abs(k), abs(l))\n                            abs_best = tuple(abs(x) for x in best_candidate[\"hkl\"])\n                            if abs_new  abs_best:\n                                is_better = True\n                            elif abs_new == abs_best:\n                                if hkl_vec.tolist()  best_candidate[\"hkl\"]:\n                                    is_better = True\n\n                if is_better:\n                    best_candidate[\"hkl\"] = [h, k, l]\n                    best_candidate[\"objective\"] = objective\n                    best_candidate[\"norm_G\"] = norm_G\n                    \n    return tuple(best_candidate[\"hkl\"])\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "本章的最后一个练习将综合运用多种核心概念。衍射图谱的标定是材料表征的基石，而本练习聚焦于其中至关重要的一步：验证标定结果的自洽性。一个正确的晶面指数标定必须同时满足两个独立的物理原则：由晶格几何决定的间距关系（通过度规张量计算）和由波的干涉决定的系统消光规律（由结构因子决定）。这个实践将展示如何构建一个基于第一性原理的、全面的自洽性检查程序，从而将晶格的几何学和物理学紧密地结合起来。",
            "id": "3442267",
            "problem": "您的任务是为一个晶体材料的衍射峰指认实现一个一致性检查。该检查必须同时强制执行两条基于第一性原理的独立约束：(i) 由晶格定心所引出的结构因子消光规律，以及 (ii) 从晶格几何导出的度规间距。您的程序必须对每个提供的测试用例进行验证，判断所有已指认的衍射峰是否在指定的绝对容差内同时满足这两个约束条件。\n\n基本原理和定义：\n- 一个 Bravais 晶格由其正点阵参数 $a$、$b$、$c$（单位为 $\\mathrm{\\AA}$）和轴间角 $\\alpha$、$\\beta$、$\\gamma$（单位为度）来表征。\n- 正点阵度规张量 $G$ 由 $G_{ij} = \\mathbf{a}_i \\cdot \\mathbf{a}_j$ 定义，其中 $\\mathbf{a}_1$、$\\mathbf{a}_2$、$\\mathbf{a}_3$ 为基矢。对于一个普遍的三斜晶格，它可以写作\n$$\nG = \\begin{bmatrix}\na^2  ab\\cos\\gamma  ac\\cos\\beta \\\\\nab\\cos\\gamma  b^2  bc\\cos\\alpha \\\\\nac\\cos\\beta  bc\\cos\\alpha  c^2\n\\end{bmatrix}.\n$$\n- 倒易点阵度规张量 $G^\\star$ 满足 $G^\\star = G^{-1}$。\n- 对于一个米勒指数 $\\mathbf{H} = (h,k,l)$，晶面间距 $d$ 通过以下公式与倒易度规相关联\n$$\n\\frac{1}{d^2} = \\mathbf{H}^\\mathsf{T} \\, G^\\star \\, \\mathbf{H}.\n$$\n- 晶格定心通过结构因子对衍射施加系统性消光条件。对于以下 Bravais 晶格定心类型，一个衍射 $(h,k,l)$ 成为可见衍射（结构因子不为零）的必要条件是：\n  1. 简单（P）：所有 $(h,k,l) \\neq (0,0,0)$ 均为可见衍射。\n  2. 体心（I）：$h + k + l$ 必须为偶数。\n  3. 面心（F）：$h$、$k$ 和 $l$ 必须全为偶数或全为奇数。\n  4. 底心（C）：$h + k$ 必须为偶数。\n这些规律源于对所有定心平移 $\\mathbf{t}$ 求相位因子 $\\exp\\!\\left(2\\pi i\\, \\mathbf{H}\\cdot\\mathbf{t}\\right)$ 的和，并要求满足所述的整数奇偶性约束。\n\n一致性检查规范：\n- 给定一组已指认的衍射峰，每个峰由一个测量间距 $d_{\\text{meas}}$（单位为 $\\mathrm{\\AA}$）和一个米勒指数三元组 $(h,k,l)$ 定义。当且仅当对于每个衍射峰，以下条件都成立时，该指认才是一致的：\n  1. 对于给定的定心类型，其消光规律被 $(h,k,l)$ 满足，且 $(h,k,l)\\neq (0,0,0)$。\n  2. 从 $G^\\star$ 计算出的度规导出间距 $d_{\\text{pred}}$ 满足 $\\left| d_{\\text{pred}} - d_{\\text{meas}} \\right| \\le \\Delta$，其中 $\\Delta$ 是所提供的绝对容差（单位为 $\\mathrm{\\AA}$）。\n如果任何一个衍射峰未能满足任一条件，则整个测试用例被标记为不一致。\n\n角度单位要求：所有角度 $\\alpha$、$\\beta$、$\\gamma$ 都以度为单位提供，并且必须按度处理。\n\n物理单位要求：所有长度 $a$、$b$、$c$ 和间距 $d_{\\text{meas}}$ 都必须以 $\\mathrm{\\AA}$ 为单位处理。\n\n您的程序必须实现上述逻辑并评估以下测试套件。每个测试用例都以一个元组的形式提供，包含晶格参数、定心类型、容差和衍射峰列表。对每个测试用例，输出一个布尔值，指示所有已指认的衍射峰是否同时与消光规律和度规导出间距在容差范围内保持一致。\n\n测试套件：\n1. 面心立方（FCC）晶格：$a = 3.6\\,\\mathrm{\\AA}$，$b = 3.6\\,\\mathrm{\\AA}$，$c = 3.6\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"F\"，容差 $\\Delta = 0.001\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 2.07846\\,\\mathrm{\\AA}$，$(h,k,l) = (1,1,1)$，\n   - $d_{\\text{meas}} = 1.7998\\,\\mathrm{\\AA}$，$(h,k,l) = (2,0,0)$，\n   - $d_{\\text{meas}} = 1.2728\\,\\mathrm{\\AA}$，$(h,k,l) = (2,2,0)$。\n2. 体心立方（BCC）晶格：$a = 3.0\\,\\mathrm{\\AA}$，$b = 3.0\\,\\mathrm{\\AA}$，$c = 3.0\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"I\"，容差 $\\Delta = 0.002\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 3.0\\,\\mathrm{\\AA}$，$(h,k,l) = (1,0,0)$，\n   - $d_{\\text{meas}} = 2.1213\\,\\mathrm{\\AA}$，$(h,k,l) = (1,1,0)$。\n3. 简单三斜晶格：$a = 4.2\\,\\mathrm{\\AA}$，$b = 5.1\\,\\mathrm{\\AA}$，$c = 6.0\\,\\mathrm{\\AA}$，$\\alpha = 94^\\circ$，$\\beta = 102^\\circ$，$\\gamma = 88^\\circ$，定心类型 \"P\"，容差 $\\Delta = 0.001\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 2.40\\,\\mathrm{\\AA}$，$(h,k,l) = (1,0,1)$，\n   - $d_{\\text{meas}} = 2.85\\,\\mathrm{\\AA}$，$(h,k,l) = (0,1,1)$。\n4. 底心正交（C-心）晶格：$a = 4.0\\,\\mathrm{\\AA}$，$b = 6.0\\,\\mathrm{\\AA}$，$c = 5.0\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"C\"，容差 $\\Delta = 0.002\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 2.000\\,\\mathrm{\\AA}$，$(h,k,l) = (2,0,0)$，\n   - $d_{\\text{meas}} = 3.324\\,\\mathrm{\\AA}$，$(h,k,l) = (1,1,0)$，\n   - $d_{\\text{meas}} = 3.121\\,\\mathrm{\\AA}$，$(h,k,l) = (1,0,1)$。\n5. 简单四方晶格：$a = 3.9\\,\\mathrm{\\AA}$，$b = 3.9\\,\\mathrm{\\AA}$，$c = 5.2\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"P\"，容差 $\\Delta = 0.0006\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 1.8916\\,\\mathrm{\\AA}$，$(h,k,l) = (1,1,2)$。\n6. 带有无效指数的简单立方晶格：$a = 4.0\\,\\mathrm{\\AA}$，$b = 4.0\\,\\mathrm{\\AA}$，$c = 4.0\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"P\"，容差 $\\Delta = 0.01\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 1.000\\,\\mathrm{\\AA}$，$(h,k,l) = (0,0,0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是一个布尔值）。不应打印任何其他文本。",
            "solution": "该问题要求根据一组晶体学参数验证已指认的衍射峰。对于每个给定的测试用例，其中包括晶格参数、Bravais 定心类型、一个容差和一系列测量的衍射峰，我们必须确定所有衍射峰是否同时满足两个基本约束：几何（度规）约束和结构因子消光规律。当且仅当每个已指认的衍射峰都满足这两个约束时，该测试用例才被视为一致。\n\n每个测试用例的验证过程如下进行。一个测试用例由正点阵参数 $a$、$b$、$c$，轴间角 $\\alpha$、$\\beta$、$\\gamma$，定心类型（P、I、F 或 C），一个绝对容差 $\\Delta$，以及一个衍射峰列表定义。每个衍射峰由其测量的晶面间距 $d_{\\text{meas}}$ 及其指认的米勒指数 $\\mathbf{H} = (h,k,l)$ 指定。\n\n首先，我们处理度规约束。晶格的几何形状完全由正点阵度规张量 $G$ 描述。对于一个普遍的三斜晶系，$G$ 是一个 $3 \\times 3$ 的对称矩阵，其元素为 $G_{ij} = \\mathbf{a}_i \\cdot \\mathbf{a}_j$，其中 $\\mathbf{a}_i$ 是正点阵基矢。根据给定的晶格参数，$G$ 的构造如下：\n$$\nG = \\begin{bmatrix}\na^2  ab\\cos\\gamma  ac\\cos\\beta \\\\\nab\\cos\\gamma  b^2  bc\\cos\\alpha \\\\\nac\\cos\\beta  bc\\cos\\alpha  c^2\n\\end{bmatrix}\n$$\n计算三角函数 $\\cos\\alpha$、$\\cos\\beta$ 和 $\\cos\\gamma$ 需要将输入的角度从度转换为弧度，因为标准数学库以弧度为单位进行运算。\n\n对于具有米勒指数 $\\mathbf{H}=(h,k,l)$ 的一组晶面，其晶面间距 $d$ 在倒易空间中计算最为方便。倒易点阵度规张量 $G^\\star$ 是正点阵度规张量 $G$ 的逆，即 $G^\\star = G^{-1}$。到点 $(h,k,l)$ 的倒易空间距离的平方由二次型 $Q = \\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}$ 给出。该量等于晶面间距平方的倒数：\n$$\n\\frac{1}{d^2} = Q = \\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}\n$$\n由此，我们可以为任何给定的米勒指数 $\\mathbf{H}$ 计算出预测的晶面间距 $d_{\\text{pred}}$：\n$$\nd_{\\text{pred}} = \\frac{1}{\\sqrt{\\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}}}\n$$\n然后，通过比较 $d_{\\text{pred}}$ 和实验测量值 $d_{\\text{meas}}$ 来检查单个衍射峰的度规一致性。如果绝对差在指定的容差 $\\Delta$ 内，则该峰被认为是度规一致的：\n$$\n|d_{\\text{pred}} - d_{\\text{meas}}| \\le \\Delta\n$$\n\n其次，我们处理结构因子消光规律。这些规律规定了哪些衍射 $(h,k,l)$ 由于晶胞中定心矢量引起的相消干涉而系统性地缺失（即强度为零）。如果一个衍射不违反这些规律，则被认为是“可见的”。对于指定的 Bravais 定心类型，其规律如下：\n- **简单（P）**：所有米勒指数 $(h,k,l) \\neq (0,0,0)$ 均为可见衍射。\n- **体心（I）**：指数之和 $h+k+l$ 必须为偶数。\n- **面心（F）**：指数 $h$、$k$ 和 $l$ 必须全为偶数或全为奇数（即具有相同的奇偶性）。\n- **底心（C）**：前两个指数之和 $h+k$ 必须为偶数。\n\n单个测试用例的总体验证算法包括遍历其每个已指认的衍射峰。对于每个峰 $(d_{\\text{meas}}, \\mathbf{H}=(h,k,l))$：\n1. 验证米勒指数不是平凡的，即 $\\mathbf{H} \\neq (0,0,0)$。指数 $(0,0,0)$ 对应于透射束，而非衍射峰，因此是无效的。\n2. 检查指数 $\\mathbf{H}$ 是否满足给定定心类型的消光规律。\n3. 使用上述度规张量方法计算 $d_{\\text{pred}}$，并验证 $|d_{\\text{pred}} - d_{\\text{meas}}| \\le \\Delta$。\n\n如果列表中的任何一个衍射峰未能通过这三项检查中的任何一项，整个测试用例将立即被宣告为不一致。如果列表中的所有衍射峰都通过了所有检查，则该测试用例被宣告为一致。此过程将应用于套件中提供的每个测试用例，以生成最终的布尔结果序列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_consistent(case_data):\n    \"\"\"\n    Validates a set of diffraction peaks against crystallographic constraints.\n    \n    Args:\n        case_data (tuple): A tuple containing lattice parameters, centering, \n                           tolerance, and a list of peaks.\n    \n    Returns:\n        bool: True if all peaks are consistent, False otherwise.\n    \"\"\"\n    a, b, c, alpha_deg, beta_deg, gamma_deg, centering, tolerance, peaks = case_data\n\n    # Convert angles from degrees to radians for trigonometric functions\n    alpha, beta, gamma = np.deg2rad([alpha_deg, beta_deg, gamma_deg])\n\n    # Calculate cosines of the angles\n    cos_a, cos_b, cos_g = np.cos(alpha), np.cos(beta), np.cos(gamma)\n\n    # Construct the direct lattice metric tensor G\n    G = np.array([\n        [a**2, a*b*cos_g, a*c*cos_b],\n        [a*b*cos_g, b**2, b*c*cos_a],\n        [a*c*cos_b, b*c*cos_a, c**2]\n    ])\n\n    # Calculate the reciprocal lattice metric tensor G* by inverting G\n    # A singular matrix would indicate linearly dependent lattice vectors,\n    # which is physically unrealistic for a 3D lattice.\n    try:\n        G_star = np.linalg.inv(G)\n    except np.linalg.LinAlgError:\n        # This case is unlikely with valid lattice parameters but is a robust check.\n        return False\n\n    for peak in peaks:\n        d_meas, hkl = peak\n        h, k, l = hkl\n        H = np.array(hkl, dtype=np.float64)\n\n        # 1. Check for non-zero Miller index\n        if h == 0 and k == 0 and l == 0:\n            return False\n\n        # 2. Check extinction rules based on centering type\n        is_allowed = False\n        if centering == 'P':\n            is_allowed = True\n        elif centering == 'I': # Body-centered\n            if (h + k + l) % 2 == 0:\n                is_allowed = True\n        elif centering == 'F': # Face-centered\n            # Parities must be all even or all odd\n            parities = [h % 2, k % 2, l % 2]\n            if sum(parities) == 0 or sum(parities) == 3:\n                is_allowed = True\n        elif centering == 'C': # Base-centered\n            if (h + k) % 2 == 0:\n                is_allowed = True\n        \n        if not is_allowed:\n            return False\n\n        # 3. Check metric-derived spacing against measured spacing\n        # Calculate 1/d^2 = H^T * G* * H\n        inv_d_sq = H.T @ G_star @ H\n        \n        # Avoid division by zero or negative values\n        if inv_d_sq = 0:\n             return False # Physically impossible spacing\n\n        d_pred = 1.0 / np.sqrt(inv_d_sq)\n\n        if abs(d_pred - d_meas) > tolerance:\n            return False\n            \n    # If all peaks pass all checks, the case is consistent\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3.6, 3.6, 3.6, 90.0, 90.0, 90.0, \"F\", 0.001, [\n            (2.07846, (1, 1, 1)), (1.7998, (2, 0, 0)), (1.2728, (2, 2, 0))]),\n        (3.0, 3.0, 3.0, 90.0, 90.0, 90.0, \"I\", 0.002, [\n            (3.0, (1, 0, 0)), (2.1213, (1, 1, 0))]),\n        (4.2, 5.1, 6.0, 94.0, 102.0, 88.0, \"P\", 0.001, [\n            (2.40, (1, 0, 1)), (2.85, (0, 1, 1))]),\n        (4.0, 6.0, 5.0, 90.0, 90.0, 90.0, \"C\", 0.002, [\n            (2.000, (2, 0, 0)), (3.324, (1, 1, 0)), (3.121, (1, 0, 1))]),\n        (3.9, 3.9, 5.2, 90.0, 90.0, 90.0, \"P\", 0.0006, [\n            (1.8916, (1, 1, 2))]),\n        (4.0, 4.0, 4.0, 90.0, 90.0, 90.0, \"P\", 0.01, [\n            (1.000, (0, 0, 0))])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_consistent(case)\n        results.append(result)\n\n    # Format output as a comma-separated list of booleans in brackets.\n    # The str() of a boolean is 'True' or 'False' (with capital T/F), which\n    # is a valid representation. JSON standard uses lowercase. The problem\n    # does not specify case, so default Python str() is acceptable.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}