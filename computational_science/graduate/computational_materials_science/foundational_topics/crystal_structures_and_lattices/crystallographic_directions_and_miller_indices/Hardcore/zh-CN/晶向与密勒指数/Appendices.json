{
    "hands_on_practices": [
        {
            "introduction": "在实际的实验测量中，数据总是伴随着噪声和异常值。当我们测量晶面的法线方向时，我们如何从这些不完美的数据中准确地推断出其对应的密勒指数？本练习将指导你构建一个稳健的优化框架来解决这个实际的逆问题，让你学会如何将物理模型与统计稳健性相结合，从而从含噪数据中提取出可靠的晶体学信息。",
            "id": "3442251",
            "problem": "给定一个在三维笛卡尔坐标系下测得的单位法线方向的有限集合，以及一个定义了密勒指数与晶面法线之间晶体学关系的倒易晶格基。其基本原理包括倒易晶格矢量和密勒指数的定义，以及一个几何关系：密勒指数为 $(hkl)$ 的晶面，其法线方向平行于倒易晶格矢量 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$。其中，$\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 是倒易晶格基矢量。在笛卡尔坐标系中，可观测的晶面法线方向与 $\\mathbf{G}$ 共线，并且其方向在符号翻转 $\\mathbf{G} \\mapsto -\\mathbf{G}$ 下保持不变。\n\n您的任务是编写一个完整、可运行的程序，从测得的单位法线方向 $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$ 中推断出晶面的互质整数密勒指数 $(h,k,l) \\in \\mathbb{Z}^3$，并能稳健地处理离群值。该推断必须基于最小化一个稳健的聚合角度偏差，该偏差是测量方向与候选倒易矢量方向 $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$ 之间的偏差。每次测量的角度偏差定义为以弧度为单位的角度\n$$\n\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big),\n$$\n该定义确保了对于 $\\hat{\\mathbf{G}}$ 符号的不变性。必须通过使用参数为 $\\delta > 0$ 的 Huber 损失函数来聚合偏差以实现稳健性，\n$$\n\\rho_\\delta(\\varphi) = \\begin{cases}\n\\frac{1}{2}\\varphi^2, & |\\varphi| \\le \\delta,\\\\\n\\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right), & |\\varphi| > \\delta,\n\\end{cases}\n$$\n可以选择在聚合前，先截尾（trimming）掉最大的一部分（比例为 $\\tau \\in [0,1)$）$\\{\\varphi_i\\}$ 以剔除离群值。需要最小化的目标是剩余角度上 Huber 损失的截尾和。\n\n整数约束条件如下：\n- $(h,k,l) \\in \\mathbb{Z}^3$，\n- $(h,k,l) \\neq (0,0,0)$，\n- $\\gcd(|h|,|k|,|l|) = 1$（互质整数约束），\n- $|h|,|k|,|l| \\le H_{\\max}$，其中 $H_{\\max} \\in \\mathbb{N}$ 为给定的界限。\n\n由于不使用通用的混合整数规划求解器，程序必须在界限 $H_{\\max}$ 内对候选解进行精确枚举，并选出使稳健目标函数最小化的解。如果目标函数值出现平局，则按以下顺序应用确定性的决胜规则：\n- 优先选择 $\\|\\mathbf{G}\\|$ 较小的候选解，\n- 然后优先选择第一个非零指数为正的候选解（规范符号约定），\n- 接着优先选择绝对值元组 $(|h|,|k|,|l|)$ 字典序较小的候选解，\n- 最后在规范符号约定下优先选择带符号元组 $(h,k,l)$ 字典序较小的候选解。\n\n所有角度必须以弧度计算。每个测试用例的最终答案必须表示为整数三元组 $[h,k,l]$。\n\n请实现程序以解决以下测试套件，并严格按照提供的方式使用指定的参数和数据。对于每个用例，倒易基矩阵 $\\mathbf{B} \\in \\mathbb{R}^{3 \\times 3}$ 由其列向量 $\\mathbf{b}_1,\\mathbf{b}_2,\\mathbf{b}_3$ 给出，测得的单位法线被明确列出。$\\mathbf{B}$ 的单位是长度的倒数，但目标函数中仅使用方向。\n\n- 测试用例 1（简单立方，目标接近 $(1,1,0)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$。\n  - 测得的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.71, 0.70, 0.00)$，\n    - $\\hat{\\mathbf{n}}_2 = (0.69, 0.72, 0.02)$，\n    - $\\hat{\\mathbf{n}}_3 = (0.73, 0.68, -0.01)$，\n    - $\\hat{\\mathbf{n}}_4 = (-0.71, -0.70, 0.00)$，\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 0.00, 1.00)$，\n    - $\\hat{\\mathbf{n}}_6 = (0.70, 0.71, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$，$\\tau = 0.17$，$H_{\\max} = 3$。\n\n- 测试用例 2（简单立方，目标接近 $(1,1,1)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$。\n  - 测得的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.58, 0.58, 0.58)$，\n    - $\\hat{\\mathbf{n}}_2 = (0.60, 0.61, 0.51)$，\n    - $\\hat{\\mathbf{n}}_3 = (0.55, 0.56, 0.65)$，\n    - $\\hat{\\mathbf{n}}_4 = (-0.58, -0.58, -0.58)$，\n    - $\\hat{\\mathbf{n}}_5 = (1.00, 0.00, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$，$\\tau = 0.20$，$H_{\\max} = 3$。\n\n- 测试用例 3（正交倒易基，目标接近 $(2,1,1)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} \\frac{1}{3} & 0 & 0 \\\\ 0 & \\frac{1}{4} & 0 \\\\ 0 & 0 & \\frac{1}{5} \\end{bmatrix}$ （列向量为 $\\left(\\frac{1}{3},0,0\\right)$、$\\left(0,\\frac{1}{4},0\\right)$、$\\left(0,0,\\frac{1}{5}\\right)$）。\n  - 测得的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.90, 0.34, 0.27)$，\n    - $\\hat{\\mathbf{n}}_2 = (0.89, 0.35, 0.29)$，\n    - $\\hat{\\mathbf{n}}_3 = (0.92, 0.33, 0.26)$，\n    - $\\hat{\\mathbf{n}}_4 = (-0.90, -0.34, -0.27)$，\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$，$\\tau = 0.20$，$H_{\\max} = 4$。\n\n- 测试用例 4（指数中包含零的边界情况，目标接近 $(0,0,1)$）：\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$。\n  - 测得的法线 $\\{\\hat{\\mathbf{n}}_i\\}$：\n    - $\\hat{\\mathbf{n}}_1 = (0.00, 0.01, 0.9999)$，\n    - $\\hat{\\mathbf{n}}_2 = (-0.01, 0.00, 0.9998)$，\n    - $\\hat{\\mathbf{n}}_3 = (0.02, -0.01, 0.9997)$，\n    - $\\hat{\\mathbf{n}}_4 = (1.00, 0.00, 0.00)$，\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$。\n  - 稳健性参数：$\\delta = 0.10$，$\\tau = 0.40$，$H_{\\max} = 2$。\n\n您的程序必须实现候选解的精确枚举、以弧度为单位的稳健目标函数计算、按 $\\tau$ 进行的截尾以及指定的决胜规则。最终输出必须为单行，其中包含四个测试用例推断出的指数三元组的逗号分隔列表，并用方括号括起来，例如 $[\\,[h_1,k_1,l_1],\\,[h_2,k_2,l_2],\\,[h_3,k_3,l_3],\\,[h_4,k_4,l_4]\\,]$。您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，严格遵循以下格式：\n$$\n[[h_1,k_1,l_1],[h_2,k_2,l_2],[h_3,k_3,l_3],[h_4,k_4,l_4]].\n$$",
            "solution": "### 问题验证\n\n问题陈述已根据指定标准进行了严格评估。\n\n**步骤 1：提取给定信息**\n\n*   **目标**：从一组 $N$ 个测量的单位法线方向 $\\{\\hat{\\mathbf{n}}_i\\}$ 中推断出互质整数密勒指数 $(h,k,l) \\in \\mathbb{Z}^3$。\n*   **物理模型**：具有密勒指数 $(h,k,l)$ 的晶面，其法线方向平行于倒易晶格矢量 $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$。该方向在符号翻转 $\\mathbf{G} \\mapsto -\\mathbf{G}$ 下保持不变。\n*   **倒易基**：对于每个测试用例，矢量 $\\mathbf{b}_i$ 作为矩阵 $\\mathbf{B}$ 的列向量提供。\n*   **优化准则**：最小化角度偏差的截尾 Huber 损失和。\n*   **角度偏差**：$\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big)$，其中 $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$。\n*   **Huber 损失**：一个稳健的损失函数 $\\rho_\\delta(\\varphi)$，由参数 $\\delta$ 定义。\n    $$\n    \\rho_\\delta(\\varphi) = \\begin{cases}\n    \\frac{1}{2}\\varphi^2, & |\\varphi| \\le \\delta,\\\\\n    \\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right), & |\\varphi| > \\delta.\n    \\end{cases}\n    $$\n*   **截尾**：在聚合之前，将最大的一部分（比例为 $\\tau$）角度偏差 $\\{\\varphi_i\\}$ 作为离群值丢弃。\n*   **搜索空间约束**：\n    1.  $(h,k,l)$ 是整数。\n    2.  $(h,k,l) \\neq (0,0,0)$。\n    3.  $\\gcd(|h|,|k|,|l|) = 1$。\n    4.  $|h|,|k|,|l| \\le H_{\\max}$。\n*   **求解方法**：对搜索空间内的所有有效候选解进行精确枚举。\n*   **决胜规则（按应用顺序）**：\n    1.  优先选择更小的目标值。\n    2.  优先选择更小的矢量范数 $\\|\\mathbf{G}\\|$。\n    3.  优先选择第一个非零指数为正的候选解。\n    4.  优先选择字典序更小的绝对值元组 $(|h|,|k|,|l|)$。\n    5.  优先选择字典序更小的带符号元组 $(h,k,l)$。\n*   **测试数据**：提供了四个具体的测试用例，每个用例都包含一个倒易基矩阵 $\\mathbf{B}$、一组测量的法线 $\\{\\hat{\\mathbf{n}}_i\\}$ 以及参数 $\\delta$、$\\tau$ 和 $H_{\\max}$。\n\n**步骤 2：使用提取的信息进行验证**\n\n对问题的有效性进行分析：\n*   **科学依据**：该问题从根本上基于固态物理学和晶体学的既定原理，特别是密勒指数和倒易晶格矢量之间的关系。所采用的统计方法（稳健损失函数、离群值截尾）是分析含噪声实验数据的标准且合适的方法。\n*   **适定性**：问题是适定的。目标函数有明确定义，搜索空间是有限的，全面且确定性的决胜规则确保了唯一解的存在且可被找到。\n*   **客观性**：问题以精确、正式的语言陈述，没有歧义或主观论断。\n*   **完整性**：每个测试用例都提供了所有必要信息——基矢量、测量数据以及所有模型参数。\n*   **可行性**：指定的搜索界限 $H_{\\max}$ 产生的搜索空间对于所要求的精确枚举方法而言，计算上是可行的。对于最大界限 $H_{\\max} = 4$，需要检查的候选解数量为 $(2 \\cdot 4 + 1)^3 - 1 = 728$，这对于现代处理器来说完全在可行范围内。\n\n**步骤 3：结论与行动**\n\n此问题是**有效的**。这是一个在计算材料科学领域内定义明确、科学合理且计算上可行的任务。将开发并给出解决方案。\n\n### 求解方法论\n\n任务是通过在离散搜索空间上执行约束优化，来确定一组测量晶面法线最可能的密勒指数 $(h,k,l)$。该方法论包含三个主要部分：候选解生成、目标函数评估，以及带确定性决胜规则的系统搜索。\n\n**1. 候选解生成与约束**\n\n解空间由整数三元组 $(h,k,l)$ 构成。对所有满足 $|h| \\le H_{\\max}$、 $|k| \\le H_{\\max}$ 和 $|l| \\le H_{\\max}$ 的候选解进行穷举搜索。每个生成的候选解 $(h,k,l)$ 都需要通过两个主要的晶体学约束进行验证：\n*   **非平凡性**：指数不能是零矢量，即 $(h,k,l) \\neq (0,0,0)$。\n*   **互质性**：指数必须互质，即 $\\gcd(|h|,|k|,|l|) = 1$。这确保了指数代表唯一的晶面族，并且是其最低整数形式。最大公约数计算为 $\\gcd(\\text{abs}(h), \\gcd(\\text{abs}(k), \\text{abs}(l)))$。\n\n**2. 目标函数评估**\n\n对于每个有效的候选解 $(h,k,l)$，计算一个稳健的目标值，以量化其与测量数据 $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$ 的符合程度。此过程包括以下几个步骤：\n*   **倒易矢量计算**：使用提供的倒易基矩阵 $\\mathbf{B} = [\\mathbf{b}_1 | \\mathbf{b}_2 | \\mathbf{b}_3]$ 计算相应的倒易晶格矢量 $\\mathbf{G}$。令 $\\mathbf{m} = [h,k,l]^T$，通过矩阵-矢量乘法求得该矢量：$\\mathbf{G} = \\mathbf{B} \\mathbf{m}$。\n*   **角度偏差**：将矢量 $\\mathbf{G}$ 归一化以获得单位方向 $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$。对于每个测量的法线 $\\hat{\\mathbf{n}}_i$，其角度偏差 $\\varphi_i$ 计算为 $\\varphi_i = \\arccos(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|)$。使用绝对值 $|\\cdot|$ 正确地考虑了晶面法线与其相反方向在物理上的等效性。\n*   **稳健聚合**：为了减轻离群值的影响，执行一个两阶段的稳健聚合。\n    1.  **截尾**：对计算出的 $N$ 个角度 $\\{\\varphi_i\\}$ 进行排序，并舍弃最大的 $\\lfloor \\tau N \\rfloor$ 个角度，其中 $\\tau$ 是截尾分数。\n    2.  **Huber 损失**：对于每个剩余的角度 $\\varphi$，计算 Huber 损失 $\\rho_\\delta(\\varphi)$。此函数对小偏差（$|\\varphi| \\le \\delta$）呈二次方关系，惩罚较轻；对大偏差（$|\\varphi| > \\delta$）呈线性关系，从而减小了残余误差的影响。\n*   **总目标值**：候选解 $(h,k,l)$ 的最终目标值是截尾后角度集合上 Huber 损失的总和。\n\n**3. 优化与决胜**\n\n算法遍历所有有效的候选解，计算每个解的目标值。它会记录迄今为止找到的“最佳”候选解。如果新候选解的目标值严格更低，则它将取代当前的最佳解。在目标值相同（平局）的情况下，将调用一个多阶段、确定性的决胜程序以确保唯一解：\n\n1.  **矢量范数**：优先选择倒易矢量范数 $\\|\\mathbf{G}\\|$ 较小的候选解。这倾向于选择具有更大晶面间距的晶面，这是一种常见的物理偏好。\n2.  **规范符号**：如果仍然平局，则选择其第一个非零指数（从 $h$ 到 $k$ 到 $l$ 读取）为正的候选解。\n3.  **绝对值字典序**：如果仍未决出胜负，则对候选解的绝对值指数 $(|h|,|k|,|l|)$ 进行字典序比较。选择较小者。\n4.  **带符号字典序**：作为最终的决胜局，对带符号的指数 $(h,k,l)$ 进行字典序比较。选择较小的元组。\n\n这种结构化的搜索和决胜协议保证了为每个提供的测试用例都能找到唯一的最优密勒指数集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases for Miller index inference.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.71, 0.70, 0.00],\n                [0.69, 0.72, 0.02],\n                [0.73, 0.68, -0.01],\n                [-0.71, -0.70, 0.00],\n                [0.00, 0.00, 1.00],\n                [0.70, 0.71, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.17,\n            \"H_max\": 3\n        },\n        # Test Case 2\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.58, 0.58, 0.58],\n                [0.60, 0.61, 0.51],\n                [0.55, 0.56, 0.65],\n                [-0.58, -0.58, -0.58],\n                [1.00, 0.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 3\n        },\n        # Test Case 3\n        {\n            \"B\": np.array([[1/3, 0, 0], [0, 1/4, 0], [0, 0, 1/5]]),\n            \"normals\": np.array([\n                [0.90, 0.34, 0.27],\n                [0.89, 0.35, 0.29],\n                [0.92, 0.33, 0.26],\n                [-0.90, -0.34, -0.27],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 4\n        },\n        # Test Case 4\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.00, 0.01, 0.9999],\n                [-0.01, 0.00, 0.9998],\n                [0.02, -0.01, 0.9997],\n                [1.00, 0.00, 0.00],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.40,\n            \"H_max\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Before passing normals, ensure they are unit vectors\n        norm_of_normals = np.linalg.norm(case[\"normals\"], axis=1, keepdims=True)\n        # Avoid division by zero for zero vectors, though not expected here\n        norm_of_normals[norm_of_normals == 0] = 1.0\n        unit_normals = case[\"normals\"] / norm_of_normals\n        \n        best_hkl = find_best_hkl(case[\"B\"], unit_normals, case[\"delta\"], case[\"tau\"], case[\"H_max\"])\n        results.append(list(best_hkl))\n    \n    # Format output precisely as requested: [[h1,k1,l1],[h2,k2,l2],...]\n    inner_results_str = [f\"[{h},{k},{l}]\" for h, k, l in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\n\ndef huber_loss(phi, delta):\n    \"\"\"Calculates the Huber loss for a given angle phi and parameter delta.\"\"\"\n    if abs(phi) = delta:\n        return 0.5 * phi**2\n    else:\n        return delta * (abs(phi) - 0.5 * delta)\n\ndef first_nonzero_is_positive(h, k, l):\n    \"\"\"Checks if the first non-zero element of (h,k,l) is positive.\"\"\"\n    if h > 0: return True\n    if h  0: return False\n    if k > 0: return True\n    if k  0: return False\n    if l > 0: return True\n    # l  0 is the only remaining case, as (0,0,0) is excluded\n    return False\n\ndef find_best_hkl(B, normals, delta, tau, H_max):\n    \"\"\"\n    Finds the best Miller indices (h,k,l) by minimizing the robust objective function.\n    \"\"\"\n    best_candidate = {\n        \"hkl\": None,\n        \"objective\": float('inf'),\n        \"norm_G\": float('inf'),\n    }\n\n    n_normals = normals.shape[0]\n    num_to_trim = int(math.floor(tau * n_normals))\n\n    for h in range(-H_max, H_max + 1):\n        for k in range(-H_max, H_max + 1):\n            for l in range(-H_max, H_max + 1):\n                \n                # Constraint 1: Not (0,0,0)\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                # Constraint 2: Coprime\n                if math.gcd(abs(h), math.gcd(abs(k), abs(l))) != 1:\n                    continue\n                \n                hkl_vec = np.array([h, k, l])\n                \n                # Calculate objective\n                G = B @ hkl_vec\n                norm_G = np.linalg.norm(G)\n                \n                if norm_G == 0: # Should not happen with valid B and non-zero hkl\n                    continue\n                \n                G_hat = G / norm_G\n                \n                dot_products = np.abs(normals @ G_hat)\n                # Clamp to avoid domain errors with arccos due to float precision\n                dot_products = np.clip(dot_products, -1.0, 1.0)\n                angles = np.arccos(dot_products)\n                \n                sorted_angles = np.sort(angles)\n                \n                if num_to_trim > 0:\n                    trimmed_angles = sorted_angles[:-num_to_trim]\n                else:\n                    trimmed_angles = sorted_angles\n                \n                objective = sum(huber_loss(phi, delta) for phi in trimmed_angles)\n                \n                # Comparison and tie-breaking\n                is_better = False\n                if objective  best_candidate[\"objective\"]:\n                    is_better = True\n                elif objective == best_candidate[\"objective\"]:\n                    if norm_G  best_candidate[\"norm_G\"]:\n                        is_better = True\n                    elif norm_G == best_candidate[\"norm_G\"]:\n                        new_is_pos = first_nonzero_is_positive(h, k, l)\n                        best_is_pos = first_nonzero_is_positive(*best_candidate[\"hkl\"])\n                        if new_is_pos and not best_is_pos:\n                            is_better = True\n                        elif new_is_pos == best_is_pos:\n                            abs_new = (abs(h), abs(k), abs(l))\n                            abs_best = tuple(abs(x) for x in best_candidate[\"hkl\"])\n                            if abs_new  abs_best:\n                                is_better = True\n                            elif abs_new == abs_best:\n                                if hkl_vec.tolist()  best_candidate[\"hkl\"]:\n                                    is_better = True\n\n                if is_better:\n                    best_candidate[\"hkl\"] = [h, k, l]\n                    best_candidate[\"objective\"] = objective\n                    best_candidate[\"norm_G\"] = norm_G\n                    \n    return tuple(best_candidate[\"hkl\"])\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "为一组衍射峰指定了密勒指数后，我们如何验证这一标定是否物理上合理？本练习将实现一个关键的一致性检查。它要求我们同时满足两个独立的约束条件：由晶格度规张量导出的几何约束，以及由结构因子消光规律施加的物理约束。通过这个实践，你将深刻理解晶体几何与衍射物理定律之间的内在联系。",
            "id": "3442267",
            "problem": "您的任务是为晶体材料的衍射峰标定实现一致性检查。该检查必须同时强制执行两条基于第一性原理的独立约束：(i) 由晶格定心决定的结构因子消光规律，以及 (ii) 源于晶格几何的度规衍生间距。您的程序必须为每个提供的测试用例验证所有已标定的衍射峰是否在指定的绝对公差范围内同时满足这两个约束。\n\n基本原理和定义：\n- 布拉维晶格由其正点阵参数 $a$、$b$、$c$（单位为 $\\mathrm{\\AA}$）和轴间角 $\\alpha$、$\\beta$、$\\gamma$（单位为度）来表征。\n- 正点阵度规张量 $G$ 由基矢 $\\mathbf{a}_1$、$\\mathbf{a}_2$、$\\mathbf{a}_3$ 定义为 $G_{ij} = \\mathbf{a}_i \\cdot \\mathbf{a}_j$，对于一个一般的三斜晶格，它可以写成\n$$\nG = \\begin{bmatrix}\na^2  ab\\cos\\gamma  ac\\cos\\beta \\\\\nab\\cos\\gamma  b^2  bc\\cos\\alpha \\\\\nac\\cos\\beta  bc\\cos\\alpha  c^2\n\\end{bmatrix}.\n$$\n- 倒易点阵度规张量 $G^\\star$ 满足 $G^\\star = G^{-1}$。\n- 对于一个密勒指数 $\\mathbf{H} = (h,k,l)$，晶面间距 $d$ 通过倒易度规与以下关系式相关联\n$$\n\\frac{1}{d^2} = \\mathbf{H}^\\mathsf{T} \\, G^\\star \\, \\mathbf{H}.\n$$\n- 晶格定心通过结构因子对衍射施加系统性消光条件。对于以下布拉维晶格定心类型，一个衍射 $(h,k,l)$ 被允许（结构因子非零）的必要条件是：\n  1. 简单（P）：所有 $(h,k,l) \\neq (0,0,0)$ 均被允许。\n  2. 体心（I）：$h + k + l$ 必须为偶数。\n  3. 面心（F）：$h$、$k$ 和 $l$ 必须全为偶数或全为奇数。\n  4. 底心（C）：$h + k$ 必须为偶数。\n这些规律源于对定心平移向量 $\\mathbf{t}$ 的相位因子 $\\exp\\!\\left(2\\pi i\\, \\mathbf{H}\\cdot\\mathbf{t}\\right)$ 求和，并要求满足所述的整数奇偶性约束。\n\n一致性检查规范：\n- 给定一组已标定的衍射峰，每个峰由一个测量的间距 $d_{\\text{meas}}$（单位为 $\\mathrm{\\AA}$）和一个密勒指数三元组 $(h,k,l)$ 定义，当且仅当对于每个峰，以下条件均成立时，该标定是一致的：\n  1. 给定定心类型的消光规律对 $(h,k,l)$ 成立，且 $(h,k,l)\\neq (0,0,0)$。\n  2. 从 $G^\\star$ 计算出的度规衍生间距 $d_{\\text{pred}}$ 满足 $\\left| d_{\\text{pred}} - d_{\\text{meas}} \\right| \\le \\Delta$，其中 $\\Delta$ 是提供的绝对公差（单位为 $\\mathrm{\\AA}$）。\n如果任何一个峰未能满足任一条件，则整个测试用例被标记为不一致。\n\n角度单位要求：所有角度 $\\alpha$、$\\beta$、$\\gamma$ 均以度为单位提供，并且必须按度处理。\n\n物理单位要求：所有长度 $a$、$b$、$c$ 和间距 $d_{\\text{meas}}$ 必须以 $\\mathrm{\\AA}$ 为单位处理。\n\n您的程序必须实现上述逻辑并评估以下测试套件。每个测试用例以晶格参数、定心类型、公差和衍射峰列表的元组形式提供。对于每个测试用例，输出一个布尔值，指示所有已标定的峰是否同时与消光规律和度规衍生间距在公差范围内保持一致。\n\n测试套件：\n1. 面心立方（FCC）晶格：$a = 3.6\\,\\mathrm{\\AA}$，$b = 3.6\\,\\mathrm{\\AA}$，$c = 3.6\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"F\"，公差 $\\Delta = 0.001\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 2.07846\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,1,1)$，\n   - $d_{\\text{meas}} = 1.7998\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (2,0,0)$，\n   - $d_{\\text{meas}} = 1.2728\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (2,2,0)$。\n2. 体心立方（BCC）晶格：$a = 3.0\\,\\mathrm{\\AA}$，$b = 3.0\\,\\mathrm{\\AA}$，$c = 3.0\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"I\"，公差 $\\Delta = 0.002\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 3.0\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,0,0)$，\n   - $d_{\\text{meas}} = 2.1213\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,1,0)$。\n3. 简单三斜晶格：$a = 4.2\\,\\mathrm{\\AA}$，$b = 5.1\\,\\mathrm{\\AA}$，$c = 6.0\\,\\mathrm{\\AA}$，$\\alpha = 94^\\circ$，$\\beta = 102^\\circ$，$\\gamma = 88^\\circ$，定心类型 \"P\"，公差 $\\Delta = 0.001\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 2.40\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,0,1)$，\n   - $d_{\\text{meas}} = 2.85\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (0,1,1)$。\n4. 底心正交（C-centered）晶格：$a = 4.0\\,\\mathrm{\\AA}$，$b = 6.0\\,\\mathrm{\\AA}$，$c = 5.0\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"C\"，公差 $\\Delta = 0.002\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 2.000\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (2,0,0)$，\n   - $d_{\\text{meas}} = 3.324\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,1,0)$，\n   - $d_{\\text{meas}} = 3.121\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,0,1)$。\n5. 简单四方晶格：$a = 3.9\\,\\mathrm{\\AA}$，$b = 3.9\\,\\mathrm{\\AA}$，$c = 5.2\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"P\"，公差 $\\Delta = 0.0006\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 1.8916\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (1,1,2)$。\n6. 带无效指数的简单立方晶格：$a = 4.0\\,\\mathrm{\\AA}$，$b = 4.0\\,\\mathrm{\\AA}$，$c = 4.0\\,\\mathrm{\\AA}$，$\\alpha = 90^\\circ$，$\\beta = 90^\\circ$，$\\gamma = 90^\\circ$，定心类型 \"P\"，公差 $\\Delta = 0.01\\,\\mathrm{\\AA}$。衍射峰：\n   - $d_{\\text{meas}} = 1.000\\,\\mathrm{\\AA}$，指数为 $(h,k,l) = (0,0,0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是一个布尔值）。不应打印任何其他文本。",
            "solution": "该问题要求根据一组晶体学参数验证已标定的衍射峰。对于每个给定的测试用例（包括晶格参数、布拉维定心类型、公差和测量的衍射峰列表），我们必须确定是否所有衍射峰都同时符合两个基本约束：几何（度规）约束和结构因子消光规律。当且仅当每个已标定的峰都满足这两个约束时，测试用例才被视为一致。\n\n每个测试用例的验证过程如下。一个测试用例由正点阵参数 $a$、$b$、$c$，轴间角 $\\alpha$、$\\beta$、$\\gamma$，定心类型（P、I、F 或 C），绝对公差 $\\Delta$ 以及一个衍射峰列表定义。每个峰由其测量的晶面间距 $d_{\\text{meas}}$ 和其标定的密勒指数 $\\mathbf{H} = (h,k,l)$ 指定。\n\n首先，我们处理度规约束。晶格的几何形状由正点阵度规张量 $G$ 完全描述。对于一般的三斜晶系，$G$ 是一个 $3 \\times 3$ 的对称矩阵，其元素为 $G_{ij} = \\mathbf{a}_i \\cdot \\mathbf{a}_j$，其中 $\\mathbf{a}_i$ 是正点阵基矢。根据给定的晶格参数，$G$ 构建如下：\n$$\nG = \\begin{bmatrix}\na^2  ab\\cos\\gamma  ac\\cos\\beta \\\\\nab\\cos\\gamma  b^2  bc\\cos\\alpha \\\\\nac\\cos\\beta  bc\\cos\\alpha  c^2\n\\end{bmatrix}\n$$\n三角函数 $\\cos\\alpha$、$\\cos\\beta$ 和 $\\cos\\gamma$ 的计算需要将输入角度从度转换为弧度，因为标准数学库以弧度进行运算。\n\n具有密勒指数 $\\mathbf{H}=(h,k,l)$ 的一组晶面的晶面间距 $d$ 在倒易空间中计算最为方便。倒易点阵度规张量 $G^\\star$ 是正点阵度规张量的逆，即 $G^\\star = G^{-1}$。到点 $(h,k,l)$ 的倒易空间距离平方由二次型 $Q = \\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}$ 给出。这个量等于晶面间距平方的倒数：\n$$\n\\frac{1}{d^2} = Q = \\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}\n$$\n由此，我们可以为任意给定的密勒指数 $\\mathbf{H}$ 计算预测的晶面间距 $d_{\\text{pred}}$：\n$$\nd_{\\text{pred}} = \\frac{1}{\\sqrt{\\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}}}\n$$\n然后，通过将 $d_{\\text{pred}}$ 与实验测量值 $d_{\\text{meas}}$进行比较来检查单个峰的度规一致性。如果绝对差在指定的公差 $\\Delta$ 范围内，则该峰被认为是度规一致的：\n$$\n|d_{\\text{pred}} - d_{\\text{meas}}| \\le \\Delta\n$$\n\n其次，我们处理结构因子消光规律。这些规律规定了哪些衍射 $(h,k,l)$ 由于晶胞中定心矢量引起的相消干涉而系统性地缺失（即强度为零）。如果一个衍射不违反这些规律，则被认为是“允许的”。指定布拉维定心类型的规律如下：\n- **简单（P）**：所有密勒指数 $(h,k,l) \\neq (0,0,0)$ 均被允许。\n- **体心（I）**：指数之和 $h+k+l$ 必须是偶数。\n- **面心（F）**：指数 $h$、$k$ 和 $l$ 必须全部为偶数或全部为奇数（即具有相同的奇偶性）。\n- **底心（C）**：前两个指数之和 $h+k$ 必须是偶数。\n\n单个测试用例的整体验证算法包括遍历其每个已标定的峰。对于每个峰 $(d_{\\text{meas}}, \\mathbf{H}=(h,k,l))$：\n1.  验证密勒指数是否为非平凡的，即 $\\mathbf{H} \\neq (0,0,0)$。指数 $(0,0,0)$ 对应于透射束，而不是衍射峰，因此是无效的。\n2.  检查指数 $\\mathbf{H}$ 是否满足给定定心类型的消光规律。\n3.  使用上述度规张量方法计算 $d_{\\text{pred}}$，并验证 $|d_{\\text{pred}} - d_{\\text{meas}}| \\le \\Delta$。\n\n如果列表中的任何一个峰未能通过这三项检查中的任何一项，整个测试用例将立即被声明为不一致。如果列表中的所有峰都通过了所有检查，则该测试用例被声明为一致。此过程应用于套件中提供的每个测试用例，以生成最终的布尔结果序列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_consistent(case_data):\n    \"\"\"\n    Validates a set of diffraction peaks against crystallographic constraints.\n    \n    Args:\n        case_data (tuple): A tuple containing lattice parameters, centering, \n                           tolerance, and a list of peaks.\n    \n    Returns:\n        bool: True if all peaks are consistent, False otherwise.\n    \"\"\"\n    a, b, c, alpha_deg, beta_deg, gamma_deg, centering, tolerance, peaks = case_data\n\n    # Convert angles from degrees to radians for trigonometric functions\n    alpha, beta, gamma = np.deg2rad([alpha_deg, beta_deg, gamma_deg])\n\n    # Calculate cosines of the angles\n    cos_a, cos_b, cos_g = np.cos(alpha), np.cos(beta), np.cos(gamma)\n\n    # Construct the direct lattice metric tensor G\n    G = np.array([\n        [a**2, a*b*cos_g, a*c*cos_b],\n        [a*b*cos_g, b**2, b*c*cos_a],\n        [a*c*cos_b, b*c*cos_a, c**2]\n    ])\n\n    # Calculate the reciprocal lattice metric tensor G* by inverting G\n    # A singular matrix would indicate linearly dependent lattice vectors,\n    # which is physically unrealistic for a 3D lattice.\n    try:\n        G_star = np.linalg.inv(G)\n    except np.linalg.LinAlgError:\n        # This case is unlikely with valid lattice parameters but is a robust check.\n        return False\n\n    for peak in peaks:\n        d_meas, hkl = peak\n        h, k, l = hkl\n        H = np.array(hkl, dtype=np.float64)\n\n        # 1. Check for non-zero Miller index\n        if h == 0 and k == 0 and l == 0:\n            return False\n\n        # 2. Check extinction rules based on centering type\n        is_allowed = False\n        if centering == 'P':\n            is_allowed = True\n        elif centering == 'I': # Body-centered\n            if (h + k + l) % 2 == 0:\n                is_allowed = True\n        elif centering == 'F': # Face-centered\n            # Parities must be all even or all odd\n            parities = [h % 2, k % 2, l % 2]\n            if sum(parities) == 0 or sum(parities) == 3:\n                is_allowed = True\n        elif centering == 'C': # Base-centered\n            if (h + k) % 2 == 0:\n                is_allowed = True\n        \n        if not is_allowed:\n            return False\n\n        # 3. Check metric-derived spacing against measured spacing\n        # Calculate 1/d^2 = H^T * G* * H\n        inv_d_sq = H.T @ G_star @ H\n        \n        # Avoid division by zero if H is (0,0,0), though already checked.\n        if inv_d_sq = 0:\n             return False # Physically impossible spacing\n\n        d_pred = 1.0 / np.sqrt(inv_d_sq)\n\n        if abs(d_pred - d_meas) > tolerance:\n            return False\n            \n    # If all peaks pass all checks, the case is consistent\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3.6, 3.6, 3.6, 90.0, 90.0, 90.0, \"F\", 0.001, [\n            (2.07846, (1, 1, 1)), (1.7998, (2, 0, 0)), (1.2728, (2, 2, 0))]),\n        (3.0, 3.0, 3.0, 90.0, 90.0, 90.0, \"I\", 0.002, [\n            (3.0, (1, 0, 0)), (2.1213, (1, 1, 0))]),\n        (4.2, 5.1, 6.0, 94.0, 102.0, 88.0, \"P\", 0.001, [\n            (2.40, (1, 0, 1)), (2.85, (0, 1, 1))]),\n        (4.0, 6.0, 5.0, 90.0, 90.0, 90.0, \"C\", 0.002, [\n            (2.000, (2, 0, 0)), (3.324, (1, 1, 0)), (3.121, (1, 0, 1))]),\n        (3.9, 3.9, 5.2, 90.0, 90.0, 90.0, \"P\", 0.0006, [\n            (1.8916, (1, 1, 2))]),\n        (4.0, 4.0, 4.0, 90.0, 90.0, 90.0, \"P\", 0.01, [\n            (1.000, (0, 0, 0))])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_consistent(case)\n        results.append(result)\n\n    # Format output as a comma-separated list of booleans in brackets.\n    # The str() of a boolean is 'True' or 'False' (with capital T/F), which\n    # is a valid representation. JSON standard uses lowercase. The problem\n    # does not specify case, so default Python str() is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在进行计算材料学研究时，我们常常需要探索不同晶面或表面的性质。与其随机挑选，我们如何能生成一个完整且无冗余的、代表所有不等价晶面族的集合？本练习将深入探讨点群对称性的作用，展示如何运用群论的概念来系统地枚举出在给定复杂度内的所有不等价晶面。这是构建材料数据库或设置高通量模拟流程的一项基本技能。",
            "id": "3442333",
            "problem": "给定一个三维正布拉菲晶格，由一个基矢矩阵 $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ 指定，其列向量为固定笛卡尔坐标系中的正晶格基矢；以及一组以旋转矩阵 $\\{\\mathbf{R}_i\\}$ 形式给出的点群操作，其中 $\\mathbf{R}_i \\in \\mathrm{SO}(3)$ 作用于笛卡尔向量。晶格中的一个晶面族由一个米勒指数三元组 $\\mathbf{h} = (h,k,l) \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ 指定，该三元组被约化为互质整数。相应的倒易晶格基矢与正晶格基矢的关系为 $\\mathbf{B}^{\\ast} = (\\mathbf{A}^{-1})^{\\mathsf{T}}$，因此倒易空间中的晶面法线为 $\\mathbf{G}(\\mathbf{h}) = \\mathbf{B}^{\\ast}\\,\\mathbf{h}$。如果存在一个点群旋转 $\\mathbf{R}$，使得两个米勒指数三元组 $\\mathbf{h}$ 和 $\\mathbf{h}'$ 的倒易法线通过无向量等价性关联，那么它们被认为是等价的，\n$$\n\\mathbf{G}(\\mathbf{h}') \\propto \\pm\\,\\mathbf{R}\\,\\mathbf{G}(\\mathbf{h}),\n$$\n即法线的方向在对称性和总体符号变换下是相同的，这反映了晶面没有方向箭头。等价地，使用 $\\mathbf{h}' = \\mathbf{M}(\\mathbf{R})\\,\\mathbf{h}$，其中\n$$\n\\mathbf{M}(\\mathbf{R}) \\equiv \\left(\\mathbf{B}^{\\ast}\\right)^{-1}\\,\\mathbf{R}\\,\\mathbf{B}^{\\ast} = \\mathbf{A}^{\\mathsf{T}}\\,\\mathbf{R}\\,(\\mathbf{A}^{-1})^{\\mathsf{T}},\n$$\n如果 $\\mathbf{h}'$ 位于由整数幺模变换 $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ 和总体符号改变所生成的轨道中，则两个米勒指数三元组 $\\mathbf{h}$ 和 $\\mathbf{h}'$ 是等价的。假设所有提供的点群旋转都是晶格的真实对称性，因此每个 $\\mathbf{M}(\\mathbf{R}_i)$ 都是一个整数幺模矩阵。\n\n您的任务是设计并实现一个算法，通过利用倒易晶格表示和点群对称性来避免重复，从而枚举所有不同晶面族，直至达到一个最大指数范数界。指数范数界定义为米勒指数的欧几里得范数界，\n$$\n\\|\\mathbf{h}\\|_2 \\equiv \\sqrt{h^2 + k^2 + l^2} \\le H,\n$$\n对于给定的正整数 $H$。只考虑本原米勒指数（即 $\\gcd(|h|,|k|,|l|)=1$）。相差一个整数因子的两个三元组代表同一个族，必须作为重复项处理。\n\n为每个等价类定义一个典范代表，规则如下。对于任何候选整数三元组 $\\mathbf{v} = (v_1,v_2,v_3)$，首先应用符号归一化：如果 $\\mathbf{v}$ 的第一个非零分量为负，则将 $\\mathbf{v}$ 替换为 $-\\mathbf{v}$；否则保持 $\\mathbf{v}$ 不变。在对给定本原指数 $\\mathbf{h}$ 应用所有对称性 $\\mathbf{M}(\\mathbf{R}_i)$ 得到的所有符号归一化图像中，选择字典序最小的三元组（首先比较 $v_1$，然后是 $v_2$，最后是 $v_3$）作为包含 $\\mathbf{h}$ 的等价类的典范代表。\n\n您的程序必须仅从上述基本定义出发，实现以下内容。\n\n- 从 $\\mathbf{A}$ 构建 $\\mathbf{B}^{\\ast}$，并用它来推导 $\\mathbf{M}(\\mathbf{R}) = \\mathbf{A}^{\\mathsf{T}}\\,\\mathbf{R}\\,(\\mathbf{A}^{-1})^{\\mathsf{T}}$。\n- 枚举所有满足 $\\|\\mathbf{h}\\|_2 \\le H$ 的本原米勒指数三元组 $\\mathbf{h} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$。\n- 对于每个 $\\mathbf{h}$，计算其在由 $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ 和无向符号等价性生成的群下的等价轨道，并为每个等价类仅将一个典范代表插入到输出集中。\n- 将最终的典范代表集合按字典序排序。\n\n科学真实性约束和单位：最终答案中不需要物理单位。用于构建旋转矩阵的角度必须以度为单位指定和解释。\n\n测试套件。您的程序必须在以下三个测试用例上执行并汇总输出。\n\n- 测试用例1（理想情况，高对称性）：正晶格 $\\mathbf{A} = \\mathrm{diag}(1.0,1.0,1.0)$。点群是立方体的全真旋转对称群（八面体群），即所有行列式为 $+1$ 的 $3 \\times 3$ 整数正交矩阵；通过枚举所有产生行列式 $+1$ 的坐标轴置换和符号选择来算法化地构建此集合。使用指数范数界 $H=2$。\n- 测试用例2（各向异性但对称）：正晶格 $\\mathbf{A} = \\mathrm{diag}(1.0,1.0,1.5)$。点群是关于 $z$ 轴的四重对称性的真旋转二面体群，由绕 $z$ 轴旋转 $90^{\\circ}$ 的旋转 $\\mathbf{R}_z$ 和绕 $x$ 轴旋转 $180^{\\circ}$ 的旋转 $\\mathbf{R}_x$ 生成，角度均以度为单位给出。通过矩阵乘法下的闭包构建完整的群。使用指数范数界 $H=2$。\n- 测试用例3（边界情况，无对称性）：正晶格\n$$\n\\mathbf{A} = \\begin{bmatrix}\n1.0  0.3  0.2\\\\\n0.0  1.1  0.4\\\\\n0.0  0.0  0.9\n\\end{bmatrix}.\n$$\n点群仅包含单位旋转。使用指数范数界 $H=1$。\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素按顺序对应一个测试用例，并且本身是一个按字典序排序的典范代表列表，每个代表是一个整数列表 $[h,k,l]$。例如，一个有效的总体格式是\n$[[[h_{11},k_{11},l_{11}],\\dots],[[h_{21},k_{21},l_{21}],\\dots],[[h_{31},k_{31},l_{31}],\\dots]]$\n不含附加文本。所有提及的角度必须以度为单位解释，所有答案都是纯整数；不需要物理单位。",
            "solution": "用户希望针对不同的晶格对称性和范数界，找出晶面族的典范代表。\n\n### 基于原理的设计\n\n该问题要求在晶格点群对称性定义的等价关系下，枚举由其米勒指数 $\\mathbf{h} = (h,k,l)$ 表示的唯一晶面族。如果两个米勒指数对应的倒易晶格矢量通过一个点群旋转相关联（不计符号），则它们是等价的。这种物理等价性转化为对米勒指数本身的数学变换。\n\n算法的核心将围绕以下原理构建：\n\n1.  **倒易空间与对称变换**：晶面由倒易空间中的一个法向量定义。与米勒指数 $\\mathbf{h} = (h,k,l)$ 对应的倒易晶格矢量 $\\mathbf{G}$ 由 $\\mathbf{G}(\\mathbf{h}) = \\mathbf{B}^{\\ast}\\,\\mathbf{h}$ 给出，其中 $\\mathbf{B}^{\\ast}$ 是倒易晶格基矢。基矢 $\\mathbf{B}^{\\ast}$ 与正晶格基矢 $\\mathbf{A}$ 的关系为 $\\mathbf{B}^{\\ast} = (\\mathbf{A}^{-1})^{\\mathsf{T}}$。实空间中的对称操作（由旋转矩阵 $\\mathbf{R}$ 表示）将米勒指数 $\\mathbf{h}$ 变换为一个等价集合 $\\mathbf{h}'$。这些协变指数的变换规则是 $\\mathbf{h}' = \\mathbf{M}(\\mathbf{R})\\,\\mathbf{h}$，其中变换矩阵 $\\mathbf{M}(\\mathbf{R})$ 推导为 $\\mathbf{M}(\\mathbf{R}) = (\\mathbf{B}^{\\ast})^{-1} \\mathbf{R} \\mathbf{B}^{\\ast}$。代入 $\\mathbf{B}^{\\ast}$ 的定义，我们得到 $\\mathbf{M}(\\mathbf{R}) = \\mathbf{A}^{\\mathsf{T}} \\mathbf{R} (\\mathbf{A}^{-1})^{\\mathsf{T}}$。这就是问题陈述中提供的公式。对于晶格的任何点群对称性 $\\mathbf{R}$，该矩阵 $\\mathbf{M}(\\mathbf{R})$ 必须是一个行列式为 $\\pm 1$ 的整数矩阵（幺模矩阵），以确保它将整数三元组映射到整数三元组。\n\n2.  **等价类与轨道**：与给定 $\\mathbf{h}$ 等价的所有米勒指数的集合构成一个等价类，或称轨道。该轨道通过应用所有对称变换矩阵 $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ 并考虑符号变化（因为晶面是无方向的，$(h,k,l)$ 和 $(-h,-k,-l)$ 是等价的）生成。任务是为每个这样的轨道找到一个唯一的代表。\n\n3.  **典范代表**：定义典范代表以唯一地标识每个等价类。问题指定了一个两步过程：\n    a. **符号归一化**：如果三元组 $\\mathbf{v}$ 的第一个非零分量为负，则通过翻转其符号来进行归一化。这确保了等价对 $\\{\\mathbf{v}, -\\mathbf{v}\\}$ 映射到单一的归一化形式。\n    b. **字典序最小值**：对于一个给定的本原米勒指数三元组 $\\mathbf{h}$，我们生成其完整轨道。然后我们对轨道中的每个三元组进行符号归一化。$\\mathbf{h}$ 族的典范代表是所有这些归一化形式中字典序最小的三元组。\n\n4.  **枚举算法**：整个算法是一个枚举过程，然后归约为典范形式。\n    a. **生成候选者**：系统地生成所有在指定欧几里得范数界 $\\|\\mathbf{h}\\|_2 \\le H$ 内的本原整数三元组 $\\mathbf{h}=(h,k,l)$。如果 $\\gcd(|h|,|k|,|l|) = 1$，则三元组是本原的。\n    b. **识别唯一族**：对于每个本原候选者 $\\mathbf{h}$，我们计算其典范代表。为避免重复计算，我们维护一个已处理三元组的集合。如果一个候选者 $\\mathbf{h}$ 尚未被处理，我们计算其完整轨道，找到其典范代表，将此代表添加到我们的最终结果集中，并标记轨道中的所有三元组为已处理。\n    c. **最终输出**：将收集到的唯一典范代表集合转换为列表并按字典序排序，以生成最终结果。\n\n### 实现步骤\n\n实现将通过以下步骤处理每个测试用例：\n\n1.  **群的生成**：为每个测试用例生成相应的点群旋转矩阵集合 $\\{\\mathbf{R}_i\\}$。\n    -   *情况1（立方）*：八面体群 $O$ 由所有24个行列式为+1的带符号置换矩阵组成。这些矩阵通过算法生成。\n    -   *情况2（四方）*：二面体群 $D_4$ 是通过给定生成元（$R_z(90^\\circ)$ 和 $R_x(180^\\circ)$）在矩阵乘法下的闭包生成的。\n    -   *情况3（三斜）*：该群是平凡群，仅包含单位矩阵。\n\n2.  **对称矩阵计算**：对于每个旋转 $\\mathbf{R}_i$，计算相应的米勒指数变换矩阵 $\\mathbf{M}(\\mathbf{R}_i) = \\mathbf{A}^{\\mathsf{T}}\\mathbf{R}_i(\\mathbf{A}^{-1})^{\\mathsf{T}}$。由于计算涉及浮点运算，但结果必须是整数矩阵，因此计算出的 $\\mathbf{M}$ 的元素被四舍五入到最接近的整数。\n\n3.  **枚举与归约**：主循环遍历从 $-H$ 到 $H$ 的整数 $h, k, l$。\n    -   它过滤掉超出范数界的三元组、零向量、非本原三元组以及任何已处理过的三元组。\n    -   对于一个新的本原三元组，它计算完整轨道 $\\{\\pm \\mathbf{M}(\\mathbf{R}_i)\\mathbf{h}\\}$，通过找到符号归一化轨道成员的字典序最小值来确定典范代表，并将其添加到结果中。然后将轨道的所有成员标记为已处理。\n\n4.  **排序与格式化**：将最终的典范代表集合进行排序，并格式化为指定的字符串表示形式。\n\n这种系统化的方法保证了在范数限制内的每个可能的晶面族都被恰好考虑一次，并且每个族的代表都是根据问题中给出的精确规则选择的。",
            "answer": "```python\nimport numpy as np\nimport math\nimport itertools\n\ndef gcd_three(a: int, b: int, c: int) -> int:\n    \"\"\"Computes the greatest common divisor of three integers.\"\"\"\n    return math.gcd(math.gcd(abs(a), abs(b)), abs(c))\n\ndef generate_cubic_group() -> list[np.ndarray]:\n    \"\"\"\n    Generates the 24 rotation matrices of the proper cubic point group (Octahedral group O).\n    These are the 3x3 signed permutation matrices with determinant +1.\n    \"\"\"\n    matrices = []\n    identity = np.identity(3, dtype=int)\n    for p in itertools.permutations([0, 1, 2]):\n        for s in itertools.product([1, -1], repeat=3):\n            R = np.zeros((3, 3), dtype=int)\n            R[:, 0] = s[0] * identity[:, p[0]]\n            R[:, 1] = s[1] * identity[:, p[1]]\n            R[:, 2] = s[2] * identity[:, p[2]]\n            if int(round(np.linalg.det(R))) == 1:\n                matrices.append(R)\n    return matrices\n\ndef generate_d4_group() -> list[np.ndarray]:\n    \"\"\"\n    Generates the 8 rotation matrices of the D4 point group by closure.\n    Generators are a 90-degree rotation about z and a 180-degree rotation about x.\n    \"\"\"\n    theta_z = np.deg2rad(90)\n    Rz = np.array([\n        [np.cos(theta_z), -np.sin(theta_z), 0],\n        [np.sin(theta_z), np.cos(theta_z), 0],\n        [0, 0, 1]\n    ])\n    theta_x = np.deg2rad(180)\n    Rx = np.array([\n        [1, 0, 0],\n        [0, np.cos(theta_x), -np.sin(theta_x)],\n        [0, np.sin(theta_x), np.cos(theta_x)]\n    ])\n\n    Rz_int = np.round(Rz).astype(int)\n    Rx_int = np.round(Rx).astype(int)\n    \n    group_tuples = {tuple(map(tuple, np.identity(3, dtype=int)))}\n    generators = [Rz_int, Rx_int]\n    \n    while True:\n        current_size = len(group_tuples)\n        new_ops = set()\n        for op1_tup in group_tuples:\n            op1 = np.array(op1_tup)\n            for gen in generators:\n                new_op = np.dot(op1, gen)\n                new_ops.add(tuple(map(tuple, new_op)))\n        group_tuples.update(new_ops)\n        if len(group_tuples) == current_size:\n            break\n\n    return [np.array(m) for m in group_tuples]\n\ndef find_canonical_representatives(A: np.ndarray, R_matrices: list[np.ndarray], H: int) -> list[list[int]]:\n    \"\"\"\n    Enumerates canonical representatives for Miller indices up to norm H for a given\n    lattice A and point group rotations R_matrices.\n    \"\"\"\n    try:\n        A_inv_T = np.linalg.inv(A).T\n    except np.linalg.LinAlgError:\n        return []\n\n    M_matrices = [np.round(A.T @ R @ A_inv_T).astype(int) for R in R_matrices]\n\n    canonical_reps = set()\n    processed_hkls = set()\n    \n    H_sq = H**2\n    for h in range(-H, H + 1):\n        for k in range(-H, H + 1):\n            for l in range(-H, H + 1):\n                if h**2 + k**2 + l**2 > H_sq:\n                    continue\n                \n                hkl_tuple = (h, k, l)\n\n                if hkl_tuple in processed_hkls or hkl_tuple == (0, 0, 0):\n                    continue\n\n                if gcd_three(h, k, l) != 1:\n                    continue\n                \n                hkl_vec = np.array(hkl_tuple)\n                \n                orbit = set()\n                for M in M_matrices:\n                    orbit.add(tuple(M @ hkl_vec))\n                \n                full_orbit_signed = set()\n                for v in orbit:\n                    full_orbit_signed.add(v)\n                    full_orbit_signed.add(tuple(-x for x in v))\n                \n                orbit_normalized = set()\n                for v_tuple in full_orbit_signed:\n                    v_list = list(v_tuple)\n                    \n                    first_nonzero_idx = -1\n                    for i in range(3):\n                        if v_list[i] != 0:\n                            first_nonzero_idx = i\n                            break\n                    \n                    if first_nonzero_idx != -1 and v_list[first_nonzero_idx]  0:\n                        v_tuple_norm = tuple(-x for x in v_list)\n                    else:\n                        v_tuple_norm = v_tuple\n                    orbit_normalized.add(v_tuple_norm)\n                \n                canonical_rep = min(orbit_normalized)\n                canonical_reps.add(canonical_rep)\n                \n                processed_hkls.update(full_orbit_signed)\n\n    return sorted([list(rep) for rep in canonical_reps])\n\ndef solve():\n    \"\"\"\n    Executes the three test cases and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.identity(3),\n            \"R_matrices\": generate_cubic_group(),\n            \"H\": 2\n        },\n        {\n            \"A\": np.diag([1.0, 1.0, 1.5]),\n            \"R_matrices\": generate_d4_group(),\n            \"H\": 2\n        },\n        {\n            \"A\": np.array([[1.0, 0.3, 0.2], [0.0, 1.1, 0.4], [0.0, 0.0, 0.9]]),\n            \"R_matrices\": [np.identity(3, dtype=int)],\n            \"H\": 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        reps = find_canonical_representatives(case[\"A\"], case[\"R_matrices\"], case[\"H\"])\n        results.append(reps)\n\n    # Format output string without using external libraries like json\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}