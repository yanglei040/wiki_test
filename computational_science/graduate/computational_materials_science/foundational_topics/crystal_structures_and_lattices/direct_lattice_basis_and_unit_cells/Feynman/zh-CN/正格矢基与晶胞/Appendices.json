{
    "hands_on_practices": [
        {
            "introduction": "此练习将指导您完成一项基础任务：将一个约定俗成的晶胞 (conventional cell) 转换为一个原胞 (primitive cell)。通过处理一个底心正交晶格，您将直接应用晶格矢量和晶胞体积的定义来证明这两种晶胞类型之间的关系，这是理解晶体结构的一项关键技能。这个练习 () 强调了如何从第一性原理出发，通过向量代数验证晶格的基本性质。",
            "id": "3445092",
            "problem": "考虑一个底心正交常规晶胞（C-心），其正格矢为 $\\mathbf{a} = a\\,\\hat{\\mathbf{x}}$、$\\mathbf{b} = b\\,\\hat{\\mathbf{y}}$ 和 $\\mathbf{c} = c\\,\\hat{\\mathbf{z}}$，其中 $a$、$b$ 和 $c$ 是正实数，而 $\\hat{\\mathbf{x}}$、$\\hat{\\mathbf{y}}$ 和 $\\hat{\\mathbf{z}}$ 是标准正交的Cartesian单位矢量。相对于 $(\\mathbf{a},\\mathbf{b},\\mathbf{c})$，该常规晶胞在分数坐标 $(0,0,0)$ 和 $\\left(\\frac{1}{2},\\frac{1}{2},0\\right)$ 处有格点。\n\n仅使用Bravais格子（原胞基矢的整数线性组合）和正空间中晶胞体积的基本定义，通过提出一组三个线性无关的原胞基矢 $\\{\\mathbf{p}_{1},\\mathbf{p}_{2},\\mathbf{p}_{3}\\}$ 来构造一个原胞，该原胞生成的格子与C-心正交常规晶胞相同。然后，计算该原胞的体积，并将其与常规晶胞的体积进行比较。\n\n你的最终任务是确定比值 $V_{\\mathrm{p}}/V_{\\mathrm{c}}$ 的精确值，其中 $V_{\\mathrm{p}}$ 是原胞的体积，$V_{\\mathrm{c}}$ 是常规晶胞的体积。将最终比值表示为一个精确的最简分数。无需四舍五入，最终答案中不应包含单位。",
            "solution": "我们从正空间中Bravais格子的定义开始：一组格点由一组三个线性无关的原胞基矢 $\\{\\mathbf{p}_{1},\\mathbf{p}_{2},\\mathbf{p}_{3}\\}$ 的所有整数线性组合生成。原胞是由这样一组基矢张成的、且恰好包含一个格点的任何晶胞。在正空间中，由矢量 $\\mathbf{u}$、$\\mathbf{v}$ 和 $\\mathbf{w}$ 张成的晶胞的体积由标量三重积 $|\\mathbf{u}\\cdot(\\mathbf{v}\\times\\mathbf{w})|$ 给出。\n\n对于底心正交常规晶胞（C-心），其正格子通常由 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 描述，并在分数坐标 $\\left(\\frac{1}{2},\\frac{1}{2},0\\right)$ 处有额外的格点。常规晶胞的体积为\n$$\nV_{\\mathrm{c}} = |\\mathbf{a}\\cdot(\\mathbf{b}\\times\\mathbf{c})| = a\\,b\\,c,\n$$\n因为 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 是正交的，并与Cartesian坐标轴对齐。\n\n为了构造C-心格子的原胞，我们提出以下原胞基矢：\n$$\n\\mathbf{p}_{1} = \\frac{1}{2}\\left(\\mathbf{a} + \\mathbf{b}\\right),\\qquad\n\\mathbf{p}_{2} = \\frac{1}{2}\\left(-\\mathbf{a} + \\mathbf{b}\\right),\\qquad\n\\mathbf{p}_{3} = \\mathbf{c}.\n$$\n我们验证这些基矢生成的格子与C-心常规描述相同：\n- 首先，它们是线性无关的，因为 $\\mathbf{p}_{3}$ 与由 $\\mathbf{p}_{1}$ 和 $\\mathbf{p}_{2}$ 张成的平面正交，并且 $\\{\\mathbf{p}_{1},\\mathbf{p}_{2}\\}$ 在 $\\mathbf{a}$–$\\mathbf{b}$ 平面内显然是无关的。\n- 其次，它们可以重现常规的晶格平移。用 $\\mathbf{p}_{1}$ 和 $\\mathbf{p}_{2}$ 求解 $\\mathbf{a}$ 和 $\\mathbf{b}$：\n$$\n\\mathbf{p}_{1} + \\mathbf{p}_{2} = \\frac{1}{2}\\left(\\mathbf{a} + \\mathbf{b}\\right) + \\frac{1}{2}\\left(-\\mathbf{a} + \\mathbf{b}\\right) = \\mathbf{b},\n$$\n$$\n\\mathbf{p}_{1} - \\mathbf{p}_{2} = \\frac{1}{2}\\left(\\mathbf{a} + \\mathbf{b}\\right) - \\frac{1}{2}\\left(-\\mathbf{a} + \\mathbf{b}\\right) = \\mathbf{a}.\n$$\n因此，$\\mathbf{a}$ 和 $\\mathbf{b}$ 是 $\\mathbf{p}_{1}$ 和 $\\mathbf{p}_{2}$ 的整数线性组合，并且 $\\mathbf{c} = \\mathbf{p}_{3}$ 是直接的。此外，中心矢量 $\\left(\\frac{1}{2},\\frac{1}{2},0\\right)$ 的Cartesian形式是 $\\frac{1}{2}\\left(\\mathbf{a}+\\mathbf{b}\\right) = \\mathbf{p}_{1}$，它本身在原胞基矢下是一个系数为 $(1,0,0)$ 的整数组合。因此，$\\{\\mathbf{p}_{1},\\mathbf{p}_{2},\\mathbf{p}_{3}\\}$ 生成的格点集合与C-心常规晶胞相同。\n\n现在我们计算原胞的体积：\n$$\nV_{\\mathrm{p}} = \\left|\\mathbf{p}_{1}\\cdot\\left(\\mathbf{p}_{2}\\times\\mathbf{p}_{3}\\right)\\right|.\n$$\n使用 $\\mathbf{a} = a\\,\\hat{\\mathbf{x}}$、$\\mathbf{b} = b\\,\\hat{\\mathbf{y}}$ 和 $\\mathbf{c} = c\\,\\hat{\\mathbf{z}}$ 将这些矢量写成Cartesian分量形式：\n$$\n\\mathbf{p}_{1} = \\left(\\frac{a}{2},\\,\\frac{b}{2},\\,0\\right),\\qquad\n\\mathbf{p}_{2} = \\left(-\\frac{a}{2},\\,\\frac{b}{2},\\,0\\right),\\qquad\n\\mathbf{p}_{3} = \\left(0,\\,0,\\,c\\right).\n$$\n计算叉积：\n\n$$\n\\mathbf{p}_{2}\\times\\mathbf{p}_{3} =\n\\begin{vmatrix}\n\\hat{\\mathbf{x}} & \\hat{\\mathbf{y}} & \\hat{\\mathbf{z}} \\\\\n-\\frac{a}{2} & \\frac{b}{2} & 0 \\\\\n0 & 0 & c\n\\end{vmatrix}\n= \\left(\\frac{b}{2}\\,c\\right)\\hat{\\mathbf{x}} + \\left(\\frac{a}{2}\\,c\\right)\\hat{\\mathbf{y}} + 0\\,\\hat{\\mathbf{z}}.\n$$\n\n那么标量三重积为\n\n$$\n\\mathbf{p}_{1}\\cdot\\left(\\mathbf{p}_{2}\\times\\mathbf{p}_{3}\\right)\n= \\left(\\frac{a}{2}\\right)\\left(\\frac{b}{2}\\,c\\right) + \\left(\\frac{b}{2}\\right)\\left(\\frac{a}{2}\\,c\\right) + 0\n= \\frac{abc}{4} + \\frac{abc}{4}\n= \\frac{abc}{2}.\n$$\n\n因此，\n$$\nV_{\\mathrm{p}} = \\frac{a\\,b\\,c}{2}.\n$$\n由于 $V_{\\mathrm{c}} = a\\,b\\,c$，该比值为\n$$\n\\frac{V_{\\mathrm{p}}}{V_{\\mathrm{c}}} = \\frac{\\frac{a\\,b\\,c}{2}}{a\\,b\\,c} = \\frac{1}{2}.\n$$\n这证实了底心正交格子的原胞体积是常规晶胞体积的一半，这与C-心结构中每个常规晶胞包含两个格点的情况相符。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "在原胞概念的基础上，这个练习 () 探索了一个对称性更低的单斜晶格。您不仅需要构建原胞，还将利用格拉姆矩阵 (Gram matrix) 来分析其几何特性，这为您提供了一种更强大、更通用的处理非正交晶格矢量的方法。通过这种方式，您可以深化对晶格几何和计算工具的理解。",
            "id": "3445079",
            "problem": "考虑一个在标准单斜设置中描述的正格子，其唯一轴为 $\\mathbf{b}$。设其传统（可能为非原胞）晶胞由以下基矢给出\n- $\\mathbf{a}_{\\mathrm{c}} = a\\,\\hat{\\mathbf{x}}$，\n- $\\mathbf{b}_{\\mathrm{c}} = b\\,\\hat{\\mathbf{y}}$，\n- $\\mathbf{c}_{\\mathrm{c}} = c\\cos\\beta\\,\\hat{\\mathbf{x}} + c\\sin\\beta\\,\\hat{\\mathbf{z}}$，\n其中 $a>0$，$b>0$，$c>0$，且 $0 < \\beta < \\pi$ 是 $\\mathbf{a}_{\\mathrm{c}}$ 和 $\\mathbf{c}_{\\mathrm{c}}$ 之间的单斜轴间角（假设 $\\beta$ 以弧度为单位测量）。该传统晶胞是底心（$C$-centered）的，定心平移为 $\\tfrac{1}{2}(\\mathbf{a}_{\\mathrm{c}}+\\mathbf{b}_{\\mathrm{c}})$。\n\n- 仅使用正格子、原胞和平行六面体体积（由标量三重积的绝对值给出）的基本定义，为该底心单斜格子构建一组明确的正格子原胞基矢 $\\{\\mathbf{p}_{1},\\mathbf{p}_{2},\\mathbf{p}_{3}\\}$。\n- 从第一性原理出发，推导传统晶胞和所构建原胞的格拉姆矩阵，并用它们来计算各自的体积、所有原胞边长 $|\\mathbf{p}_{i}|$ 以及 $\\mathbf{p}_{i}$ 之间的所有轴间角。\n- 通过将原胞边长和原胞轴间角的余弦用 $a$、$b$、$c$ 和 $\\beta$ 明确表示出来，比较传统描述与原胞描述。\n\n作为您唯一需要报告的结果，请给出比值 $R = V_{\\mathrm{conv}}/V_{\\mathrm{prim}}$。不需要进行数值取整。将 $R$ 报告为单个无单位的实数。",
            "solution": "底心单斜格子的传统晶胞由以下基矢定义：\n$\\mathbf{a}_{\\mathrm{c}} = a\\,\\hat{\\mathbf{x}}$\n$\\mathbf{b}_{\\mathrm{c}} = b\\,\\hat{\\mathbf{y}}$\n$\\mathbf{c}_{\\mathrm{c}} = c\\cos\\beta\\,\\hat{\\mathbf{x}} + c\\sin\\beta\\,\\hat{\\mathbf{z}}$\n在笛卡尔坐标系中，这些矢量为：\n$$\n\\mathbf{a}_{\\mathrm{c}} = \\begin{pmatrix} a \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{b}_{\\mathrm{c}} = \\begin{pmatrix} 0 \\\\ b \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{c}_{\\mathrm{c}} = \\begin{pmatrix} c\\cos\\beta \\\\ 0 \\\\ c\\sin\\beta \\end{pmatrix}\n$$\n晶格参数给定为 $a>0$，$b>0$，$c>0$，以及单斜角 $0 < \\beta < \\pi$。\n\n传统晶胞的体积 $V_{\\mathrm{conv}}$ 由其基矢的标量三重积的绝对值给出。\n$$\nV_{\\mathrm{conv}} = |\\mathbf{a}_{\\mathrm{c}} \\cdot (\\mathbf{b}_{\\mathrm{c}} \\times \\mathbf{c}_{\\mathrm{c}})| = \\left| \\det \\begin{pmatrix} a & 0 & c\\cos\\beta \\\\ 0 & b & 0 \\\\ 0 & 0 & c\\sin\\beta \\end{pmatrix} \\right|\n$$\n计算行列式可得：\n$$\nV_{\\mathrm{conv}} = |a(b \\cdot c\\sin\\beta - 0) - 0 + c\\cos\\beta(0-0)| = |abc\\sin\\beta|\n$$\n已知 $a, b, c > 0$ 且 $0 < \\beta < \\pi$，我们有 $\\sin\\beta > 0$。因此，\n$$\nV_{\\mathrm{conv}} = abc\\sin\\beta\n$$\n传统晶胞的格拉姆矩阵 $G_{\\mathrm{c}}$ 的元素为 $G_{ij} = \\mathbf{v}_i \\cdot \\mathbf{v}_j$，其中 $\\{\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\} = \\{\\mathbf{a}_{\\mathrm{c}}, \\mathbf{b}_{\\mathrm{c}}, \\mathbf{c}_{\\mathrm{c}}\\}$。\n$g_{11} = \\mathbf{a}_{\\mathrm{c}} \\cdot \\mathbf{a}_{\\mathrm{c}} = a^2$\n$g_{22} = \\mathbf{b}_{\\mathrm{c}} \\cdot \\mathbf{b}_{\\mathrm{c}} = b^2$\n$g_{33} = \\mathbf{c}_{\\mathrm{c}} \\cdot \\mathbf{c}_{\\mathrm{c}} = (c\\cos\\beta)^2 + (c\\sin\\beta)^2 = c^2(\\cos^2\\beta + \\sin^2\\beta) = c^2$\n$g_{12} = \\mathbf{a}_{\\mathrm{c}} \\cdot \\mathbf{b}_{\\mathrm{c}} = 0$\n$g_{13} = \\mathbf{a}_{\\mathrm{c}} \\cdot \\mathbf{c}_{\\mathrm{c}} = a(c\\cos\\beta) = ac\\cos\\beta$\n$g_{23} = \\mathbf{b}_{\\mathrm{c}} \\cdot \\mathbf{c}_{\\mathrm{c}} = 0$\n格拉姆矩阵为：\n$$\nG_{\\mathrm{c}} = \\begin{pmatrix} a^2 & 0 & ac\\cos\\beta \\\\ 0 & b^2 & 0 \\\\ ac\\cos\\beta & 0 & c^2 \\end{pmatrix}\n$$\n体积的平方是格拉姆矩阵的行列式：\n$V_{\\mathrm{conv}}^2 = \\det(G_{\\mathrm{c}}) = a^2(b^2c^2 - 0) - 0 + ac\\cos\\beta(0 - b^2ac\\cos\\beta) = a^2b^2c^2 - a^2b^2c^2\\cos^2\\beta = a^2b^2c^2(1-\\cos^2\\beta) = a^2b^2c^2\\sin^2\\beta$。\n$V_{\\mathrm{conv}} = \\sqrt{a^2b^2c^2\\sin^2\\beta} = abc\\sin\\beta$，这证实了前面的结果。\n\n一个底心（$C$-centered）格子在传统晶胞的顶点处以及由 $\\mathbf{a}_{\\mathrm{c}}$ 和 $\\mathbf{b}_{\\mathrm{c}}$ 张成的面的中心处有格点。所有格点的集合由 $\\mathbf{R} = n_1\\mathbf{a}_{\\mathrm{c}} + n_2\\mathbf{b}_{\\mathrm{c}} + n_3\\mathbf{c}_{\\mathrm{c}}$ 和 $\\mathbf{R} + \\frac{1}{2}(\\mathbf{a}_{\\mathrm{c}} + \\mathbf{b}_{\\mathrm{c}})$ 给出，其中 $n_1, n_2, n_3$ 为任意整数。一组原胞基矢 $\\{\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$ 必须通过整系数线性组合生成所有这些点，并且只能生成这些点。对于一个底心格子，一种标准的选择是：\n$\\mathbf{p}_1 = \\frac{1}{2}(\\mathbf{a}_{\\mathrm{c}} + \\mathbf{b}_{\\mathrm{c}})$\n$\\mathbf{p}_2 = \\frac{1}{2}(-\\mathbf{a}_{\\mathrm{c}} + \\mathbf{b}_{\\mathrm{c}})$\n$\\mathbf{p}_3 = \\mathbf{c}_{\\mathrm{c}}$\n这些是到合法格点的矢量，并且它们不共面。它们的任意整系数线性组合 $\\mathbf{R}_p = m_1\\mathbf{p}_1 + m_2\\mathbf{p}_2 + m_3\\mathbf{p}_3$ 可以用传统基矢表示为 $\\mathbf{R}_p = \\frac{m_1-m_2}{2}\\mathbf{a}_{\\mathrm{c}} + \\frac{m_1+m_2}{2}\\mathbf{b}_{\\mathrm{c}} + m_3\\mathbf{c}_{\\mathrm{c}}$。$\\mathbf{a}_{\\mathrm{c}}$ 和 $\\mathbf{b}_{\\mathrm{c}}$ 的系数之和为 $\\frac{m_1-m_2}{2} + \\frac{m_1+m_2}{2} = m_1$，是一个整数。这是底心格子的条件。在笛卡尔坐标系中：\n$$\n\\mathbf{p}_1 = \\begin{pmatrix} a/2 \\\\ b/2 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{p}_2 = \\begin{pmatrix} -a/2 \\\\ b/2 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{p}_3 = \\begin{pmatrix} c\\cos\\beta \\\\ 0 \\\\ c\\sin\\beta \\end{pmatrix}\n$$\n原胞的体积 $V_{\\mathrm{prim}}$ 为：\n$$\nV_{\\mathrm{prim}} = |\\mathbf{p}_1 \\cdot (\\mathbf{p}_2 \\times \\mathbf{p}_3)| = \\left| \\det \\begin{pmatrix} a/2 & -a/2 & c\\cos\\beta \\\\ b/2 & b/2 & 0 \\\\ 0 & 0 & c\\sin\\beta \\end{pmatrix} \\right|\n$$\n$$\nV_{\\mathrm{prim}} = |c\\sin\\beta \\left( \\frac{a}{2} \\frac{b}{2} - (-\\frac{a}{2})\\frac{b}{2} \\right)| = |c\\sin\\beta \\left( \\frac{ab}{4} + \\frac{ab}{4} \\right)| = \\left| \\frac{abc\\sin\\beta}{2} \\right|\n$$\n因为 $a,b,c,\\sin\\beta$ 均为正数，所以 $V_{\\mathrm{prim}} = \\frac{1}{2}abc\\sin\\beta$。\n\n接下来，我们构建原胞的格拉姆矩阵 $G_{\\mathrm{p}}$，其元素为 $G_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j$。\n$g_{11} = \\mathbf{p}_1 \\cdot \\mathbf{p}_1 = (\\frac{a}{2})^2 + (\\frac{b}{2})^2 = \\frac{a^2+b^2}{4}$\n$g_{22} = \\mathbf{p}_2 \\cdot \\mathbf{p}_2 = (-\\frac{a}{2})^2 + (\\frac{b}{2})^2 = \\frac{a^2+b^2}{4}$\n$g_{33} = \\mathbf{p}_3 \\cdot \\mathbf{p}_3 = c^2$\n$g_{12} = \\mathbf{p}_1 \\cdot \\mathbf{p}_2 = (\\frac{a}{2})(-\\frac{a}{2}) + (\\frac{b}{2})(\\frac{b}{2}) = \\frac{b^2-a^2}{4}$\n$g_{13} = \\mathbf{p}_1 \\cdot \\mathbf{p}_3 = (\\frac{a}{2})(c\\cos\\beta) = \\frac{ac\\cos\\beta}{2}$\n$g_{23} = \\mathbf{p}_2 \\cdot \\mathbf{p}_3 = (-\\frac{a}{2})(c\\cos\\beta) = -\\frac{ac\\cos\\beta}{2}$\n$$\nG_{\\mathrm{p}} = \\begin{pmatrix} \\frac{a^2+b^2}{4} & \\frac{b^2-a^2}{4} & \\frac{ac\\cos\\beta}{2} \\\\ \\frac{b^2-a^2}{4} & \\frac{a^2+b^2}{4} & -\\frac{ac\\cos\\beta}{2} \\\\ \\frac{ac\\cos\\beta}{2} & -\\frac{ac\\cos\\beta}{2} & c^2 \\end{pmatrix}\n$$\n$V_{\\mathrm{prim}}^2 = \\det(G_{\\mathrm{p}})$。\n$\\det(G_{\\mathrm{p}}) = \\frac{a^2+b^2}{4} \\left[ \\frac{c^2(a^2+b^2)}{4} - \\frac{a^2c^2\\cos^2\\beta}{4} \\right] - \\frac{b^2-a^2}{4} \\left[ \\frac{c^2(b^2-a^2)}{4} + \\frac{a^2c^2\\cos^2\\beta}{4} \\right] + \\frac{ac\\cos\\beta}{2} \\left[ \\frac{-ac\\cos\\beta(b^2-a^2)}{8} - \\frac{ac\\cos\\beta(a^2+b^2)}{8} \\right]$\n$= \\frac{c^2}{16}((a^2+b^2)^2 - (b^2-a^2)^2) - \\frac{a^2c^2\\cos^2\\beta}{16}((a^2+b^2)+(b^2-a^2)) + \\frac{ac\\cos\\beta}{2} \\left[ \\frac{-ac\\cos\\beta}{8}(2b^2) \\right]$\n$= \\frac{c^2}{16}(4a^2b^2) - \\frac{a^2c^2\\cos^2\\beta}{16}(2b^2) - \\frac{a^2b^2c^2\\cos^2\\beta}{8}$\n$= \\frac{a^2b^2c^2}{4} - \\frac{a^2b^2c^2\\cos^2\\beta}{8} - \\frac{a^2b^2c^2\\cos^2\\beta}{8} = \\frac{a^2b^2c^2}{4} - \\frac{a^2b^2c^2\\cos^2\\beta}{4} = \\frac{a^2b^2c^2}{4}(1-\\cos^2\\beta) = \\frac{a^2b^2c^2\\sin^2\\beta}{4}$。\n$V_{\\mathrm{prim}} = \\sqrt{\\det(G_{\\mathrm{p}})} = \\frac{abc\\sin\\beta}{2}$，再次证实了结果。\n\n原胞边长为 $|\\mathbf{p}_i| = \\sqrt{g_{ii}}$。\n$|\\mathbf{p}_1| = \\sqrt{\\frac{a^2+b^2}{4}} = \\frac{1}{2}\\sqrt{a^2+b^2}$\n$|\\mathbf{p}_2| = \\sqrt{\\frac{a^2+b^2}{4}} = \\frac{1}{2}\\sqrt{a^2+b^2}$\n$|\\mathbf{p}_3| = \\sqrt{c^2} = c$\n\n原胞轴间角的余弦为 $\\cos\\theta_{ij} = \\frac{\\mathbf{p}_i \\cdot \\mathbf{p}_j}{|\\mathbf{p}_i||\\mathbf{p}_j|} = \\frac{g_{ij}}{\\sqrt{g_{ii}g_{jj}}}$。\n$\\cos(\\angle(\\mathbf{p}_1, \\mathbf{p}_2)) = \\frac{(b^2-a^2)/4}{\\sqrt{\\frac{a^2+b^2}{4}}\\sqrt{\\frac{a^2+b^2}{4}}} = \\frac{b^2-a^2}{a^2+b^2}$\n$\\cos(\\angle(\\mathbf{p}_1, \\mathbf{p}_3)) = \\frac{ac\\cos\\beta/2}{\\sqrt{\\frac{a^2+b^2}{4}}\\sqrt{c^2}} = \\frac{ac\\cos\\beta/2}{c/2 \\cdot \\sqrt{a^2+b^2}} = \\frac{a\\cos\\beta}{\\sqrt{a^2+b^2}}$\n$\\cos(\\angle(\\mathbf{p}_2, \\mathbf{p}_3)) = \\frac{-ac\\cos\\beta/2}{\\sqrt{\\frac{a^2+b^2}{4}}\\sqrt{c^2}} = \\frac{-ac\\cos\\beta/2}{c/2 \\cdot \\sqrt{a^2+b^2}} = \\frac{-a\\cos\\beta}{\\sqrt{a^2+b^2}}$\n\n最后，问题要求计算比值 $R = V_{\\mathrm{conv}}/V_{\\mathrm{prim}}$。\n$$\nR = \\frac{V_{\\mathrm{conv}}}{V_{\\mathrm{prim}}} = \\frac{abc\\sin\\beta}{\\frac{1}{2}abc\\sin\\beta}\n$$\n项 $a, b, c, \\sin\\beta$ 均不为零，因此它们可以消去。\n$$\nR = 2\n$$\n这个结果与底心传统晶胞包含两个格点，而原胞根据定义只包含一个格点的事实相符。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "最后的这个练习 () 旨在弥合抽象晶格理论与实际计算挑战之间的鸿沟。通过一个关于 $\\mathbf{k}$ 点采样的假想情景，您将诊断出使用非原胞的超胞 (supercell) 如何破坏其内在的晶体对称性，并导致错误的物理预测。这突显了在模拟中正确选择晶胞的重要性。",
            "id": "3445110",
            "problem": "考虑一个二维晶体固体，其正格子由矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$ 的列向量 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 描述。一个晶胞由序对 $(A, \\{\\boldsymbol{\\tau}_\\alpha\\})$ 定义，其中 $\\{\\boldsymbol{\\tau}_\\alpha\\}$ 是一组原子的胞内位置（基矢）。在本问题中，我们模拟一个非磁性系统，其底层原胞格子为 $A_{\\mathrm{prim}}$，模拟所用的晶胞为 $A_{\\mathrm{cell}} = A_{\\mathrm{prim}} S$，其中 $S = \\operatorname{diag}(n_1,n_2)$ 是一个对角整数超胞缩放矩阵，且 $n_1, n_2 \\in \\mathbb{Z}^+$。倒格子矩阵 $B \\in \\mathbb{R}^{2 \\times 2}$ 由条件 $A^\\top B = 2\\pi I$ 定义，即 $B = 2\\pi (A^{-1})^\\top$。第一布里渊区 (BZ) 由 $B$ 的列向量张成，沿每个倒格矢轴向的分数坐标在 $[0,1)$ 区间内。\n\n我们研究在倒易空间中，在一个 Monkhorst-Pack 型网格上采样的波矢 $\\mathbf{k}$，定义为\n$$\n\\mathbf{k}(i,j) = \\frac{i + s_1}{N_1} \\mathbf{b}_1 + \\frac{j + s_2}{N_2} \\mathbf{b}_2,\n$$\n其中整数 $i \\in \\{0,1,\\dots,N_1-1\\}$，$j \\in \\{0,1,\\dots,N_2-1\\}$，权重均匀，实数位移 $s_1, s_2 \\in [0,1)$，$\\mathbf{b}_1$ 和 $\\mathbf{b}_2$ 是用于构建该网格的倒格子矩阵的列向量。所有角度均以弧度为单位。在我们的情境中，物理上正确的对称性是原胞格子 $A_{\\mathrm{prim}}$ 的对称性，但采样是使用模拟晶胞 $A_{\\mathrm{cell}}$（可能不是原胞）进行的。为了揭示对称性破缺的影响，考虑每个 $\\mathbf{k}$ 的一个磁化代理，定义为\n$$\nm(\\mathbf{k}) = \\sin(\\mathbf{k} \\cdot \\mathbf{a}_1^{\\mathrm{prim}}) - \\sin(\\mathbf{k} \\cdot \\mathbf{a}_2^{\\mathrm{prim}}),\n$$\n它满足时间反演奇性 $m(-\\mathbf{k}) = -m(\\mathbf{k})$。在一个保持对称性且对原胞格子的反演操作封闭的采样中，平均磁化代理\n$$\nM_{\\mathrm{raw}} = \\frac{1}{|\\mathcal{K}|} \\sum_{\\mathbf{k} \\in \\mathcal{K}} m(\\mathbf{k})\n$$\n必须为零。然而，非原胞会折叠布里渊区，并导致采样集 $\\mathcal{K}$ 相对于原胞格子而言不是对称完备的，从而产生一个虚假的非零 $M_{\\mathrm{raw}}$。\n\n你的任务是：\n$1.$ 从第一性原理出发实现基础部分：\n$1.1.$ 从 $A_{\\mathrm{prim}}$ 和 $A_{\\mathrm{cell}}$ 分别构造 $B_{\\mathrm{prim}}$ 和 $B_{\\mathrm{cell}}$，使用 $A^\\top B = 2\\pi I$。\n$1.2.$ 从 $(B_{\\mathrm{cell}}, N_1, N_2, s_1, s_2)$ 生成 $\\mathcal{K}_{\\mathrm{cell}}$。\n$1.3.$ 将 $\\mathcal{K}_{\\mathrm{cell}}$ 中的每个 $\\mathbf{k}$ 通过加上所有不同的偏移量\n$$\n\\mathbf{G}(p,q) = \\frac{p}{n_1} \\mathbf{b}_1^{\\mathrm{prim}} + \\frac{q}{n_2} \\mathbf{b}_2^{\\mathrm{prim}},\n$$\n（其中 $p \\in \\{0,1,\\dots,n_1-1\\}$ 且 $q \\in \\{0,1,\\dots,n_2-1\\}$）展开到原胞布里渊区，然后对原胞布里渊区取模，以获得以 $B_{\\mathrm{prim}}$ 的 $[0,1)$ 分数坐标表示的展开集 $\\mathcal{K}_{\\mathrm{unfold}}$。\n$1.4.$ 在候选正交操作 $R \\in \\{I, -I, R_{90^\\circ}, R_{270^\\circ}\\}$ 中，识别原胞格子的点群，其中\n$$\nR_{90^\\circ} = \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix}, \\quad R_{270^\\circ} = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}.\n$$\n一个实空间操作 $R$ 是格子 $A_{\\mathrm{prim}}$ 的一个晶格对称操作，当且仅当 $T = A_{\\mathrm{prim}}^{-1} R A_{\\mathrm{prim}}$ 的条目是整数（在数值容差范围内）且 $\\det(T) = \\pm 1$。其在倒空间对 $\\mathbf{k}$ 的相应作用是 $\\mathbf{k} \\mapsto R \\mathbf{k}$。\n\n$2.$ 设计一个针对 $\\mathbf{k}$ 点采样中对称性破缺伪影的诊断方法：\n$2.1.$ 测试 $\\mathcal{K}_{\\mathrm{unfold}}$ 在每个原胞对称性 $R$ 下的封闭性：对于 $\\mathcal{K}_{\\mathrm{unfold}}$ 中的每个 $\\mathbf{k}$，检查 $R \\mathbf{k}$（对原胞布里渊区取模后）是否存在于 $\\mathcal{K}_{\\mathrm{unfold}}$ 中。\n$2.2.$ 使用 $\\mathcal{K}_{\\mathrm{cell}}$ 和磁化代理 $m(\\mathbf{k})$（其中使用 $\\mathbf{a}_i^{\\mathrm{prim}}$）计算 $M_{\\mathrm{raw}}$。\n$2.3.$ 通过对原胞点群和展开偏移量进行对称性平均，定义一个修正后的磁化强度：\n$$\nM_{\\mathrm{corr}} = \\frac{1}{|\\mathcal{K}_{\\mathrm{cell}}| \\, n_1 \\, n_2 \\, |G|} \\sum_{\\mathbf{k} \\in \\mathcal{K}_{\\mathrm{cell}}} \\sum_{p=0}^{n_1-1} \\sum_{q=0}^{n_2-1} \\sum_{R \\in G} m\\!\\left(R \\left(\\mathbf{k} + \\mathbf{G}(p,q)\\right)\\right),\n$$\n其中 $G$ 是检测到的原胞对称性集合。\n$2.4.$ 如果封闭性测试对任何 $R \\in G$ 失败，或者 $|M_{\\mathrm{raw}}|$ 超过一个小的容差，则声明检测到伪影。\n\n你必须实现一个完整的程序，对下面的测试套件执行上述任务，并产生所需的输出。所有 $2 \\times 2$ 矩阵和向量都在笛卡尔坐标系中，角度以弧度为单位，最终输出没有物理单位。\n\n测试套件：\n$1.$ 正常路径（原胞正方格子）：\n$A_{\\mathrm{prim}} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$, $S = \\operatorname{diag}(1,1)$, $A_{\\mathrm{cell}} = A_{\\mathrm{prim}} S$, 网格参数 $N_1 = 4$, $N_2 = 4$, $s_1 = 0$, $s_2 = 0$。\n$2.$ 导致布里渊区折叠的非原胞矩形超胞：\n$A_{\\mathrm{prim}} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$, $S = \\operatorname{diag}(2,1)$, $A_{\\mathrm{cell}} = A_{\\mathrm{prim}} S$, 网格参数 $N_1 = 3$, $N_2 = 1$, $s_1 = 0$, $s_2 = 0$。\n$3.$ 具有非原胞超胞和非对称采样的斜角原胞格子：\n$A_{\\mathrm{prim}} = \\begin{pmatrix} 1 & 0 \\\\ 0.5 & 0.9 \\end{pmatrix}$, $S = \\operatorname{diag}(2,1)$, $A_{\\mathrm{cell}} = A_{\\mathrm{prim}} S$, 网格参数 $N_1 = 3$, $N_2 = 1$, $s_1 = 0$, $s_2 = 0$。\n$4.$ 边界情况（具有对称友好位移网格的原胞正方格子）：\n$A_{\\mathrm{prim}} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$, $S = \\operatorname{diag}(1,1)$, $A_{\\mathrm{cell}} = A_{\\mathrm{prim}} S$, 网格参数 $N_1 = 3$, $N_2 = 3$, $s_1 = 0.5$, $s_2 = 0.5$。\n\n要求的最终输出格式：\n你的程序应该生成一行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来。对于每个测试用例，输出一个包含三个条目的列表 $[b, M_{\\mathrm{raw}}, M_{\\mathrm{corr}}]$，其中 $b$ 是一个布尔值，表示是否检测到伪影，$M_{\\mathrm{raw}}$ 是一个浮点数，$M_{\\mathrm{corr}}$ 是一个浮点数。完整的输出应如下所示\n$[\\,[b_1, M_{\\mathrm{raw},1}, M_{\\mathrm{corr},1}], [b_2, M_{\\mathrm{raw},2}, M_{\\mathrm{corr},2}], [b_3, M_{\\mathrm{raw},3}, M_{\\mathrm{corr},3}], [b_4, M_{\\mathrm{raw},4}, M_{\\mathrm{corr},4}]\\,]$。",
            "solution": "### **1. 基础构造**\n\n**1.1. 晶格与倒格矩阵**\n正格子由一个矩阵 $A$ 描述，其列是格矢。给定的原胞格子是 $A_{\\mathrm{prim}}$，而模拟晶胞（可能是一个超胞）由 $A_{\\mathrm{cell}} = A_{\\mathrm{prim}} S$ 给出，其中 $S = \\operatorname{diag}(n_1, n_2)$ 是一个对角缩放矩阵。\n\n倒格子矩阵 $B$ 由关系 $A^\\top B = 2\\pi I$ 定义，其中 $I$ 是单位矩阵。这导出了定义 $B = 2\\pi (A^\\top)^{-1} = 2\\pi (A^{-1})^\\top$。\n\n对于原胞格子，倒格子矩阵是：\n$$\nB_{\\mathrm{prim}} = 2\\pi (A_{\\mathrm{prim}}^{-1})^\\top\n$$\n对于模拟晶胞：\n$$\nA_{\\mathrm{cell}} = A_{\\mathrm{prim}} S \\implies A_{\\mathrm{cell}}^{-1} = (A_{\\mathrm{prim}} S)^{-1} = S^{-1} A_{\\mathrm{prim}}^{-1}\n$$\n因此，\n$$\nB_{\\mathrm{cell}} = 2\\pi (A_{\\mathrm{cell}}^{-1})^\\top = 2\\pi (S^{-1} A_{\\mathrm{prim}}^{-1})^\\top = 2\\pi (A_{\\mathrm{prim}}^{-1})^\\top (S^{-1})^\\top\n$$\n由于 $S$ 是对角矩阵，$(S^{-1})^\\top = S^{-1}$。因此：\n$$\nB_{\\mathrm{cell}} = B_{\\mathrm{prim}} S^{-1}\n$$\n这表明，实空间中缩放矩阵为 $S$ 的超胞对应于倒易空间中缩放矩阵为 $S^{-1}$ 的“子胞”。$B_{\\mathrm{prim}}$ 和 $B_{\\mathrm{cell}}$ 的列将分别表示为 $\\mathbf{b}_i^{\\mathrm{prim}}$ 和 $\\mathbf{b}_i^{\\mathrm{cell}}$。\n\n**1.2. k点集生成**\n模拟晶胞的波矢集 $\\mathcal{K}_{\\mathrm{cell}}$ 是在 Monkhorst-Pack 网格上生成的。$\\mathcal{K}_{\\mathrm{cell}}$ 中的每个向量 $\\mathbf{k}$ 都是晶胞倒格矢 $\\mathbf{b}_1^{\\mathrm{cell}}$ 和 $\\mathbf{b}_2^{\\mathrm{cell}}$ 的线性组合：\n$$\n\\mathbf{k}(i,j) = \\frac{i + s_1}{N_1} \\mathbf{b}_1^{\\mathrm{cell}} + \\frac{j + s_2}{N_2} \\mathbf{b}_2^{\\mathrm{cell}}\n$$\n其中整数 $i \\in \\{0, \\dots, N_1-1\\}$ 且 $j \\in \\{0, \\dots, N_2-1\\}$。在矩阵形式中，如果 $\\mathbf{f}_{\\mathrm{cell}}(i, j) = \\left(\\frac{i+s_1}{N_1}, \\frac{j+s_2}{N_2}\\right)^\\top$，则 $\\mathbf{k}(i,j) = B_{\\mathrm{cell}} \\mathbf{f}_{\\mathrm{cell}}(i,j)$。\n\n**1.3. k点展开**\n展开操作将 k 点从超胞的布里渊区 (BZ) 重新映射到原胞的布里渊区。这是通过添加超胞的倒格矢来实现的，这些倒格矢对应于原胞布里渊区中一个更精细的偏移向量网格。这些偏移量是：\n$$\n\\mathbf{G}(p,q) = \\frac{p}{n_1} \\mathbf{b}_1^{\\mathrm{prim}} + \\frac{q}{n_2} \\mathbf{b}_2^{\\mathrm{prim}}\n$$\n其中 $p \\in \\{0, \\dots, n_1-1\\}$ 且 $q \\in \\{0, \\dots, n_2-1\\}$。\n对于 $\\mathcal{K}_{\\mathrm{cell}}$ 中的每个 $\\mathbf{k}$，我们生成一组展开后的向量 $\\{\\mathbf{k} + \\mathbf{G}(p,q)\\}$。每个结果向量必须对原胞布里渊区取模。一个向量 $\\mathbf{k}'$ 通过将其表示为 $B_{\\mathrm{prim}}$ 的分数坐标 $\\mathbf{k}' = B_{\\mathrm{prim}} \\mathbf{f}'$ 来约化，然后取 $\\mathbf{f}'$ 每个分量的分数部分：$\\mathbf{f}'_{\\text{red}} = \\mathbf{f}' - \\lfloor \\mathbf{f}' \\rfloor$。唯一的约化向量集合构成了 $\\mathcal{K}_{\\mathrm{unfold}}$。\n\n**1.4. 点群识别**\n一个正交操作 $R$ 是晶格 $A_{\\mathrm{prim}}$ 的一个点群对称操作，如果它能将晶格映射到自身。这当且仅当变换矩阵 $T = A_{\\mathrm{prim}}^{-1} R A_{\\mathrm{prim}}$ 由整数条目组成时才成立。此条件确保任何格矢 $A_{\\mathrm{prim}} \\mathbf{n}$（其中 $\\mathbf{n} \\in \\mathbb{Z}^2$）被映射到另一个格矢 $R A_{\\mathrm{prim}} \\mathbf{n} = A_{\\mathrm{prim}} T \\mathbf{n}$，其中 $T \\mathbf{n}$ 是一个整数向量。条件 $\\det(T)=\\pm 1$ 确保变换是可逆的。我们必须根据这个标准测试候选矩阵 $\\{I, -I, R_{90^\\circ}, R_{270^\\circ}\\}$ 来找到点群 $G$。\n\n### **2. 对称性破缺诊断**\n\n**2.1. 封闭性测试**\n一个保持对称性的 k 点集必须在晶格点群的作用下是封闭的。展开后的集合 $\\mathcal{K}_{\\mathrm{unfold}}$ 应具有原胞格子的完整对称性。对于每个对称操作 $R \\in G$，以及对于 $\\mathcal{K}_{\\mathrm{unfold}}$ 中的每个向量 $\\mathbf{k}$，变换后的向量 $R\\mathbf{k}$（在约化到第一布里渊区后）也必须存在于 $\\mathcal{K}_{\\mathrm{unfold}}$ 中。任何 $R$ 不满足此条件都表明存在对称性破缺伪影。由于浮点运算，此检查必须在数值容差内进行。\n\n**2.2. 原始磁化代理, $M_{\\mathrm{raw}}$**\n磁化代理定义为 $m(\\mathbf{k}) = \\sin(\\mathbf{k} \\cdot \\mathbf{a}_1^{\\mathrm{prim}}) - \\sin(\\mathbf{k} \\cdot \\mathbf{a}_2^{\\mathrm{prim}})$。该函数具有属性 $m(-\\mathbf{k}) = -m(\\mathbf{k})$。对于任何在反演操作下封闭的 k 点集 $\\mathcal{K}$（即，如果 $\\mathbf{k} \\in \\mathcal{K}$，那么 $-\\mathbf{k}$ 也在 $\\mathcal{K}$ 中，相差一个倒格矢），其平均值 $M = \\frac{1}{|\\mathcal{K}|} \\sum_{\\mathbf{k} \\in \\mathcal{K}} m(\\mathbf{k})$ 将为零。\n原始平均值 $M_{\\mathrm{raw}}$ 是在采样集合 $\\mathcal{K}_{\\mathrm{cell}}$ 上计算的。一个非零的 $|M_{\\mathrm{raw}}|$（高于数值容差）表明 $\\mathcal{K}_{\\mathrm{cell}}$ 不是反演对称的，这是超胞计算中常见的伪影。\n\n**2.3. 修正后磁化强度, $M_{\\mathrm{corr}}$**\n修正后的磁化强度是通过对原胞点群 $G$ 的所有对称操作和所有展开偏移量 $\\mathbf{G}(p,q)$ 进行显式平均来计算的：\n$$\nM_{\\mathrm{corr}} = \\frac{1}{N_{\\text{tot}}} \\sum_{\\mathbf{k} \\in \\mathcal{K}_{\\mathrm{cell}}} \\sum_{p=0}^{n_1-1} \\sum_{q=0}^{n_2-1} \\sum_{R \\in G} m\\!\\left(R \\left(\\mathbf{k} + \\mathbf{G}(p,q)\\right)\\right),\n$$\n其中 $N_{\\text{tot}} = |\\mathcal{K}_{\\mathrm{cell}}| \\, n_1 \\, n_2 \\, |G|$。这个求和中 $m(\\cdot)$ 的参数集合被明确构造成在 $G$ 中所有对称性下都是封闭的。由于任何二维布拉菲格都具有反演对称性（$R=-I \\in G$）且 $m(\\mathbf{k})$ 是一个奇函数，求和中的项将成对抵消，导致 $M_{\\mathrm{corr}} = 0$（在浮点精度内）。这可作为一个强有力的内部一致性检查。\n\n**2.4. 伪影检测**\n如果满足以下两个条件之一，则声明检测到伪影：\n1. 对于 $\\mathcal{K}_{\\mathrm{unfold}}$，封闭性测试失败。这表示采样即使在展开后也没有遵循完整的晶格对称性。\n2. 原始磁化强度 $|M_{\\mathrm{raw}}|$ 显著不为零。这是对原始采样 $\\mathcal{K}_{\\mathrm{cell}}$ 中反演对称性破缺的直接度量。\n此检查使用一个数值容差，例如 $10^{-9}$。",
            "answer": "```python\nimport numpy as np\nfrom typing import List, Tuple, Dict, Any\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        # 1. Happy path (primitive square lattice)\n        {\n            \"A_prim\": [[1, 0], [0, 1]],\n            \"S_diag\": [1, 1],\n            \"N\": (4, 4),\n            \"s\": (0.0, 0.0),\n        },\n        # 2. Non-primitive rectangular supercell\n        {\n            \"A_prim\": [[1, 0], [0, 1]],\n            \"S_diag\": [2, 1],\n            \"N\": (3, 1),\n            \"s\": (0.0, 0.0),\n        },\n        # 3. Oblique primitive lattice with non-primitive supercell\n        {\n            \"A_prim\": [[1, 0], [0.5, 0.9]],\n            \"S_diag\": [2, 1],\n            \"N\": (3, 1),\n            \"s\": (0.0, 0.0),\n        },\n        # 4. Boundary case (primitive square with symmetric shifted grid)\n         {\n            \"A_prim\": [[1, 0], [0, 1]],\n            \"S_diag\": [1, 1],\n            \"N\": (3, 3),\n            \"s\": (0.5, 0.5),\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_diagnostic(**case_params)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \", \".join([f\"[{str(b).lower()}, {mr:.6f}, {mc:.6f}]\" for b, mr, mc in results]) + \"]\"\n    print(output_str.replace(\"0.000000\", \"0.0\").replace(\"-0.000000\", \"0.0\"))\n\n\ndef run_diagnostic(A_prim: List[List[float]], S_diag: List[int], N: Tuple[int, int], s: Tuple[float, float]) -> List[Any]:\n    \"\"\"\n    Performs the full symmetry analysis for a single test case.\n    \"\"\"\n    TOL = 1e-9\n    PRECISION_MULT = 1e12\n\n    # --- 1. Foundational Constructions ---\n    \n    # 1.1. Lattice and Reciprocal Lattice Matrices\n    A_prim_np = np.array(A_prim, dtype=float)\n    S = np.diag(S_diag).astype(float)\n    n1, n2 = S_diag[0], S_diag[1]\n    N1, N2 = N\n    s1, s2 = s\n\n    A_cell = A_prim_np @ S\n    \n    try:\n        B_prim = 2 * np.pi * np.linalg.inv(A_prim_np).T\n        B_cell = 2 * np.pi * np.linalg.inv(A_cell).T\n    except np.linalg.LinAlgError:\n        # Handle non-invertible matrices, though not expected for valid problems.\n        return [True, np.nan, np.nan]\n\n    # 1.4. Identify Point Group\n    R_I = np.identity(2)\n    R_inv = -np.identity(2)\n    R_90 = np.array([[0, -1], [1, 0]])\n    R_270 = np.array([[0, 1], [-1, 0]])\n    candidate_R = [R_I, R_inv, R_90, R_270]\n    \n    A_prim_inv = np.linalg.inv(A_prim_np)\n    G = []\n    for R in candidate_R:\n        T = A_prim_inv @ R @ A_prim_np\n        is_integer_matrix = np.allclose(T, np.round(T), atol=TOL)\n        det_T = np.linalg.det(T)\n        is_det_pm1 = np.isclose(det_T, 1.0, atol=TOL) or np.isclose(det_T, -1.0, atol=TOL)\n        if is_integer_matrix and is_det_pm1:\n            G.append(R)\n\n    # 1.2. k-point Set Generation (K_cell)\n    k_cell = []\n    for i in range(N1):\n        for j in range(N2):\n            frac_k = np.array([(i + s1) / N1, (j + s2) / N2])\n            k_vec = B_cell @ frac_k\n            k_cell.append(k_vec)\n    \n    # 1.3. Unfolding k-points (K_unfold)\n    unfolding_offsets = []\n    for p in range(n1):\n        for q in range(n2):\n            frac_G = np.array([p / n1, q / n2] if n1 > 0 and n2 > 0 else [0,0])\n            G_vec = B_prim @ frac_G\n            unfolding_offsets.append(G_vec)\n\n    B_prim_inv = np.linalg.inv(B_prim)\n\n    def reduce_k_to_frac(k_vec, B_inv):\n        frac = B_inv @ k_vec\n        return frac - np.floor(frac)\n\n    unfolded_k_frac_coords_set = set()\n    for k_vec in k_cell:\n        for G_vec in unfolding_offsets:\n            k_unfolded = k_vec + G_vec\n            frac_coords = reduce_k_to_frac(k_unfolded, B_prim_inv)\n            key = tuple(np.round(frac_coords * PRECISION_MULT).astype(np.int64))\n            unfolded_k_frac_coords_set.add(key)\n    \n    # --- 2. Symmetry-Breaking Diagnostic ---\n\n    # 2.1. Closure Test\n    closure_fails = False\n    for R in G:\n        if np.allclose(R, R_I):\n            continue\n        \n        # Create a temporary set of keys for the current symmetry op to check against\n        temp_set = unfolded_k_frac_coords_set.copy()\n        \n        for frac_tuple in unfolded_k_frac_coords_set:\n            frac_coords = np.array(frac_tuple) / PRECISION_MULT\n            k_vec = B_prim @ frac_coords\n            k_sym = R @ k_vec\n            \n            frac_sym_reduced = reduce_k_to_frac(k_sym, B_prim_inv)\n            key_sym = tuple(np.round(frac_sym_reduced * PRECISION_MULT).astype(np.int64))\n            \n            if key_sym not in temp_set:\n                closure_fails = True\n                break\n        if closure_fails:\n            break\n\n    # 2.2. Raw Magnetization Proxy (M_raw)\n    a1_prim, a2_prim = A_prim_np[:, 0], A_prim_np[:, 1]\n    \n    def m_proxy(k_vec):\n        return np.sin(k_vec.dot(a1_prim)) - np.sin(k_vec.dot(a2_prim))\n\n    m_raw_sum = sum(m_proxy(k_vec) for k_vec in k_cell)\n    M_raw = m_raw_sum / len(k_cell) if k_cell else 0.0\n\n    # 2.3. Corrected Magnetization (M_corr)\n    m_corr_sum = 0.0\n    for k_vec in k_cell:\n        for G_vec in unfolding_offsets:\n            k_prime = k_vec + G_vec\n            for R in G:\n                k_final = R @ k_prime\n                m_corr_sum += m_proxy(k_final)\n    \n    num_terms = len(k_cell) * len(unfolding_offsets) * len(G)\n    M_corr = m_corr_sum / num_terms if num_terms > 0 else 0.0\n\n    # 2.4. Declare Artifact\n    artifact_detected = closure_fails or (abs(M_raw) > TOL)\n\n    return [artifact_detected, M_raw, M_corr]\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}