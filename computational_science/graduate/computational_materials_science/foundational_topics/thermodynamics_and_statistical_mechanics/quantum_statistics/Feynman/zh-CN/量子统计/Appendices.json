{
    "hands_on_practices": [
        {
            "introduction": "在计算材料科学中，许多宏观性质的计算都归结为对能量积分的求解，这些积分由态密度和粒子占据函数共同决定。本练习将引导你从第一性原理出发，推导并数值计算自由粒子系统的费米-狄拉克（Fermi-Dirac）和玻色-爱因斯坦（Bose-Einstein）积分的无量纲形式。通过这个实践，你将掌握处理半无限域积分和解决数值溢出等问题的核心计算技能，为后续更复杂的应用打下坚实基础。",
            "id": "3482692",
            "problem": "您将实现一个程序，基于第一性原理，对计算材料科学中源于量子统计的无量纲积分进行数值评估。从 Fermi-Dirac (FD) 占有函数、Bose-Einstein (BE) 占有函数以及三维自由粒子态密度的定义开始。仅使用这些定义，推导出依赖于约化化学势和实数阶参数的无量纲积分表达式。具体而言：\n\n- Fermi-Dirac 占有函数定义为 $f_{\\mathrm{FD}}(E; \\mu, T) = \\left[\\exp\\!\\left(\\frac{E - \\mu}{k_{\\mathrm{B}} T}\\right) + 1\\right]^{-1}$，其中 $E$ 是能量，$\\mu$ 是化学势，$T$ 是温度，$k_{\\mathrm{B}}$ 是 Boltzmann 常数。\n\n- Bose-Einstein 占有函数定义为 $f_{\\mathrm{BE}}(E; \\mu, T) = \\left[\\exp\\!\\left(\\frac{E - \\mu}{k_{\\mathrm{B}} T}\\right) - 1\\right]^{-1}$，对于非凝聚的玻色子，存在物理约束 $ \\mu \\le 0$。\n\n- 三维自由粒子态密度随能量的变化关系为 $D(E) \\propto E^{1/2}$。\n\n从这些基本要素出发，引入无量纲能量变量 $x = E/(k_{\\mathrm{B}} T)$，以及费米子的无量纲约化化学势 $\\eta = \\mu/(k_{\\mathrm{B}} T)$ 和玻色子的无量纲约化化学势 $\\alpha = \\mu/(k_{\\mathrm{B}} T)$。然后，通过将 $f_{\\mathrm{FD}}$ 或 $f_{\\mathrm{BE}}$ 与 $D(E)$ 结合，并对变量进行替换为 $x$，推导出由实数阶 $j > 0$ 参数化的相应无量纲积分。您的程序必须通过数值积分，计算在指定 $\\eta$ 值下阶为 $j$ 的无量纲 FD 积分，以及在指定 $\\alpha < 0$ 值下阶为 $j$ 的无量纲 BE 积分。推导过程应基于原理，且不应使用任何预先制表的特殊函数恒等式。\n\n算法要求：\n\n- 在半无限区间 $x \\in [0, \\infty)$ 上实现积分的自适应数值求积，并谨慎处理以避免指数函数中的数值溢出。您的实现必须在各种情况下都具有鲁棒性，包括费米子的简并极限（大的正 $ \\eta$）、费米子的非简并极限（大的负 $ \\eta$）以及玻色子的近临界区（$\\alpha \\to 0^{-}$）。\n\n- 您的数值积分应以高精度计算。设计您的算法，以稳定地计算诸如 $\\left[1 + \\exp\\!\\left(x - \\eta\\right)\\right]^{-1}$ 和 $\\left[\\exp\\!\\left(x - \\alpha\\right) - 1\\right]^{-1}$ 等表达式在小参数和和参数极限下的值。\n\n测试套件：\n\n评估以下情况，每种情况产生一个浮点数结果：\n\n- 在 $\\eta = -10.0$ 时，阶为 $j = 1/2$ 的 Fermi-Dirac 积分。\n- 在 $\\eta = 0.0$ 时，阶为 $j = 1/2$ 的 Fermi-Dirac 积分。\n- 在 $\\eta = 2.0$ 时，阶为 $j = 1/2$ 的 Fermi-Dirac 积分。\n- 在 $\\eta = 10.0$ 时，阶为 $j = 1/2$ 的 Fermi-Dirac 积分。\n- 在 $\\alpha = -5.0$ 时，阶为 $j = 3/2$ 的 Bose-Einstein 积分。\n- 在 $\\alpha = -1.0$ 时，阶为 $j = 3/2$ 的 Bose-Einstein 积分。\n- 在 $\\alpha = -1 \\times 10^{-6}$ 时，阶为 $j = 3/2$ 的 Bose-Einstein 积分（即 $\\alpha = -0.000001$）。\n\n所有积分都是无量纲的，因此不需要指定物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果顺序与上面列出的完全一致，每个浮点数四舍五入到 $8$ 位小数。例如：$[r_1,r_2,r_3,r_4,r_5,r_6,r_7]$。",
            "solution": "所述问题具有科学依据，提法明确且客观。它基于量子统计力学的基本原理，提出了一个计算物理学中标准的、可解的问题。所有必要的定义和参数均已提供。因此，该问题是有效的，将在此提出一个解决方案。\n\n其目标是推导并数值计算量子统计中的核心无量纲积分。这个过程从统计力学的第一性原理开始。\n\n一个无相互作用粒子系统的宏观性质 $G$ 是通过将微观的能量依赖量 $g(E)$ 对所有可用态进行积分来计算的。这涉及到态密度 $D(E)$ 和统计占有函数 $f(E; \\mu, T)$:\n$$\nG = \\int_0^\\infty g(E) D(E) f(E; \\mu, T) dE\n$$\n问题指明，对于三维自由粒子气体，态密度与能量的关系为 $D(E) \\propto E^{1/2}$。我们可以用一个比例常数 $C_D$ 将其写为 $D(E) = C_D E^{1/2}$。在此背景下，我们感兴趣的量，如粒子数或能量，通常对应于 $g(E) = C_g E^k$ 的形式，其中 $C_g$ 是某个常数，k 是指数。因此，$G$ 的积分形式为：\n$$\nG = C \\int_0^\\infty E^k \\cdot E^{1/2} \\cdot f(E; \\mu, T) dE = C \\int_0^\\infty E^{k+1/2} f(E; \\mu, T) dE\n$$\n其中 $C$ 整合了所有比例常数。\n\n为了获得无量纲形式，我们引入无量纲能量变量 $x = E/(k_{\\mathrm{B}} T)$，这意味着 $E = x k_{\\mathrm{B}} T$ 和 $dE = k_{\\mathrm{B}} T dx$。将这些代入积分中得到：\n$$\nG = C \\int_0^\\infty (x k_{\\mathrm{B}} T)^{k+1/2} f(x k_{\\mathrm{B}} T; \\mu, T) (k_{\\mathrm{B}} T dx)\n$$\n$$\nG = C (k_{\\mathrm{B}} T)^{k+3/2} \\int_0^\\infty x^{k+1/2} f(x k_{\\mathrm{B}} T; \\mu, T) dx\n$$\n积分部分现在是无量纲的。这类积分的标准“阶”（表示为 $j$）对应于无量纲变量 $x$ 的指数。我们确定阶为 $j = k+1/2$。因此，一个与 $E^k$ 成正比的物理量会产生一个阶为 $j = k+1/2$ 的无量纲积分。例如，总粒子数（$k=0$）对应于阶为 $j=1/2$ 的积分，总能量（$k=1$）对应于阶为 $j=3/2$ 的积分。\n\n占有函数 $f$ 也进行变换。其自变量变为：\n$$\n\\frac{E - \\mu}{k_{\\mathrm{B}} T} = \\frac{E}{k_{\\mathrm{B}} T} - \\frac{\\mu}{k_{\\mathrm{B}} T} = x - \\xi\n$$\n其中 $\\xi$ 是无量纲约化化学势，对于费米子表示为 $\\eta = \\mu/(k_{\\mathrm{B}} T)$，对于玻色子表示为 $\\alpha = \\mu/(k_{\\mathrm{B}} T)$。\n\n基于此推导，阶为 $j$ 的无量纲积分的一般形式为：\n$$\nI_j(\\xi) = \\int_0^\\infty \\frac{x^j}{\\exp(x-\\xi) \\pm 1} dx\n$$\n其中分母中的符号对于 Fermi-Dirac 统计是“+”，对于 Bose-Einstein 统计是“-”。\n\n**Fermi-Dirac 积分**\nFermi-Dirac (FD) 占有函数为 $f_{\\mathrm{FD}} = [\\exp((E-\\mu)/(k_{\\mathrm{B}} T)) + 1]^{-1}$。相应的阶为 $j$ 的无量纲积分，我们表示为 $\\mathcal{F}_j(\\eta)$，是：\n$$\n\\mathcal{F}_j(\\eta) = \\int_0^\\infty \\frac{x^j}{\\exp(x-\\eta)+1} dx\n$$\n对于测试用例，我们必须在不同的 $\\eta$ 值下计算 $j=1/2$ 时的这个积分。\n\n**Bose-Einstein 积分**\nBose-Einstein (BE) 占有函数为 $f_{\\mathrm{BE}} = [\\exp((E-\\mu)/(k_{\\mathrm{B}} T)) - 1]^{-1}$。对于非凝聚的玻色子，$\\mu \\le 0$，这意味着 $\\alpha \\le 0$。相应的阶为 $j$ 的无量纲积分，我们表示为 $\\mathcal{G}_j(\\alpha)$，是：\n$$\n\\mathcal{G}_j(\\alpha) = \\int_0^\\infty \\frac{x^j}{\\exp(x-\\alpha)-1} dx\n$$\n问题要求在不同的 $\\alpha  0$ 值下计算 $j=3/2$ 时的这个积分。条件 $\\alpha  0$ 确保对于任何 $x \\ge 0$，指数的自变量 $x-\\alpha$ 都为正，从而防止分母在 $x0$ 时出现奇点。\n\n**数值计算**\n这些积分在半无限区间 $[0, \\infty)$ 上使用自适应数值求积进行计算，`scipy.integrate.quad` 函数很适合此任务。实现的一个关键方面是对被积函数进行鲁棒的计算，以防止数值溢出和精度损失。\n\n对于 FD 被积函数 $g(x) = x^j / (\\exp(x-\\eta)+1)$:\n- 如果自变量 $x-\\eta$ 是一个大的正数，$\\exp(x-\\eta)$ 可能会溢出。在这种情况下，$\\exp(x-\\eta)+1 \\approx \\exp(x-\\eta)$，因此被积函数可以被精确地近似为 $g(x) \\approx x^j \\exp(-(x-\\eta))$。\n- 如果 $x-\\eta$ 是一个大的负数，$\\exp(x-\\eta) \\to 0$，分母趋近于 $1$。被积函数就是 $x^j$，这是数值稳定的。\n使用了一个条件实现：如果 $x-\\eta$ 超过一个安全阈值（例如 $30$），则使用数值稳定的近似。否则，计算直接的表达式。\n\n对于 BE 被积函数 $h(x) = x^j / (\\exp(x-\\alpha)-1)$:\n- 如果自变量 $x-\\alpha$ 很大且为正，会发生与 FD 情况相同的溢出问题，并使用相同的近似 $h(x) \\approx x^j \\exp(-(x-\\alpha))$。\n- 如果 $x-\\alpha$ 接近于零（当 $\\alpha$ 接近 $0^-$ 时，对于小的 $x$ 会发生这种情况），分母 $\\exp(x-\\alpha)-1$ 会遭受灾难性抵消，导致精度严重损失。这是一个经典的数值陷阱，可以通过使用专门的函数 `numpy.expm1(z)` 来解决，该函数旨在精确计算小 $|z|$ 时的 $e^z-1$。\n因此，BE 被积函数的实现将结合一个用于大自变量的条件检查和对所有其他情况使用 `expm1` 函数，以确保在所有情况下的稳定性。\n\nPython 实现将为每种积分类型定义函数，并整合这些数值策略。然后，主 `solve` 函数将迭代指定的测试用例，调用适当的积分函数，并将结果格式化到所需的精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Derives and numerically evaluates dimensionless Fermi-Dirac and Bose-Einstein integrals\n    based on first principles of quantum statistics.\n    \"\"\"\n\n    def _integrand_fd(x, j, eta):\n        \"\"\"\n        Numerically stable integrand for the Fermi-Dirac integral.\n        Integrand is x^j / (exp(x - eta) + 1).\n\n        Args:\n            x (float): Dimensionless energy variable.\n            j (float): Order of the integral.\n            eta (float): Reduced chemical potential.\n\n        Returns:\n            float: Value of the integrand at x.\n        \"\"\"\n        if x == 0.0 and j  0:\n            return np.inf  # Handle singularity for negative j at x=0\n        if x == 0.0 and j == 0:\n            # Special case for j=0 to avoid 0^0 issues, though not used in tests.\n            # The limit depends on eta. For eta>0, limit is 1. For eta0, limit is exp(eta).\n            # Here we just compute the standard form.\n             pass \n\n        arg = x - eta\n        # For large positive arguments, exp(arg) overflows.\n        # In this regime, exp(arg) + 1 is numerically identical to exp(arg).\n        # We can rewrite the fraction as x**j * exp(-arg) to avoid overflow.\n        # A threshold of 30 is safe as exp(30) is very large but within float64 limits.\n        if arg > 30.0:\n            return (x**j) * np.exp(-arg)\n        else:\n            return (x**j) / (np.exp(arg) + 1.0)\n\n    def _integrand_be(x, j, alpha):\n        \"\"\"\n        Numerically stable integrand for the Bose-Einstein integral.\n        Integrand is x^j / (exp(x - alpha) - 1).\n\n        Args:\n            x (float): Dimensionless energy variable.\n            j (float): Order of the integral.\n            alpha (float): Reduced chemical potential (must be  0).\n\n        Returns:\n            float: Value of the integrand at x.\n        \"\"\"\n        if x == 0.0:\n            # For j > 1, the limit is 0.\n            # For j = 1, the limit is 1/(-alpha) if alpha is not 0.\n            # Here j=1.5, so x^1.5 / (x-alpha) -> 0.\n            return 0.0\n\n        arg = x - alpha\n        # For large positive arguments, exp(arg) overflows.\n        # The approximation exp(arg) - 1 approx exp(arg) holds.\n        # We use the same stable form as in the FD case.\n        if arg > 30.0:\n            return (x**j) * np.exp(-arg)\n        else:\n            # For small arguments, exp(arg) - 1 suffers from catastrophic cancellation.\n            # np.expm1(arg) is designed to compute exp(arg) - 1 accurately.\n            return (x**j) / np.expm1(arg)\n\n    def compute_fd_integral(j, eta):\n        \"\"\"\n        Computes the Fermi-Dirac integral of order j at reduced potential eta.\n        \"\"\"\n        result, _ = integrate.quad(_integrand_fd, 0, np.inf, args=(j, eta))\n        return result\n\n    def compute_be_integral(j, alpha):\n        \"\"\"\n        Computes the Bose-Einstein integral of order j at reduced potential alpha.\n        \"\"\"\n        result, _ = integrate.quad(_integrand_be, 0, np.inf, args=(j, alpha))\n        return result\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'type': 'FD', 'j': 1/2, 'param': -10.0},\n        {'type': 'FD', 'j': 1/2, 'param': 0.0},\n        {'type': 'FD', 'j': 1/2, 'param': 2.0},\n        {'type': 'FD', 'j': 1/2, 'param': 10.0},\n        {'type': 'BE', 'j': 3/2, 'param': -5.0},\n        {'type': 'BE', 'j': 3/2, 'param': -1.0},\n        {'type': 'BE', 'j': 3/2, 'param': -1.0e-6},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'FD':\n            res = compute_fd_integral(case['j'], case['param'])\n        elif case['type'] == 'BE':\n            res = compute_be_integral(case['j'], case['param'])\n        results.append(f\"{res:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "真实材料的电子结构远比自由电子气模型复杂，其态密度（DOS）常常包含范霍夫奇点（van Hove singularity）等非平庸特征。本练习将挑战你处理一个更贴近实际的物理模型，即一个在态密度中包含对数形式范霍夫奇点的二维材料。你需要为此设计一种能够稳定处理对数奇异性的数值积分策略，这对于精确计算真实材料（如石墨烯或某些二维过渡金属硫化物）的电子性质至关重要。",
            "id": "3482712",
            "problem": "考虑一个单能带二维材料，其电子色散在能量 $ \\epsilon_s $ 附近产生态密度 (DOS) 的对数范霍夫奇点。假设态密度仅在围绕 $ \\epsilon_s $ 的有限对称区间上非零，半带宽为 $ \\Lambda $，并由以下公式给出：\n$$\ng(\\epsilon;\\epsilon_s,\\Lambda)=\\begin{cases}\n\\dfrac{1}{2\\Lambda}\\,\\ln\\!\\left(\\dfrac{\\Lambda}{|\\epsilon-\\epsilon_s|}\\right),  \\text{if } |\\epsilon-\\epsilon_s|  \\Lambda, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n该态密度是可积的，但在 $ \\epsilon=\\epsilon_s $ 处具有对数发散。在无量纲单位下进行计算，其中玻尔兹曼常数 $ k_{\\mathrm{B}}=1 $，因此温度 $ T $ 和能量具有相同的单位。\n\n您的目标是计算有限温度下的占据积分\n$$\nN(\\mu,T) \\equiv \\int_{-\\infty}^{+\\infty} f(\\epsilon;\\mu,T)\\,g(\\epsilon;\\epsilon_s,\\Lambda)\\,d\\epsilon,\n$$\n该积分适用于费米-狄拉克分布（费米子）\n$$\nf_{\\mathrm{FD}}(\\epsilon;\\mu,T) = \\dfrac{1}{e^{(\\epsilon-\\mu)/T}+1},\n$$\n或玻色-爱因斯坦分布（玻色子）\n$$\nf_{\\mathrm{BE}}(\\epsilon;\\mu,T) = \\dfrac{1}{e^{(\\epsilon-\\mu)/T}-1},\n$$\n对于玻色子，有物理约束条件 $ \\mu  \\epsilon_{\\min} $，其中 $ \\epsilon_{\\min} = \\epsilon_s - \\Lambda $ 是能带最小值，以避免 $ f_{\\mathrm{BE}} $ 发散。\n\n您需要：\n- 从第一性原理出发，推导出一个数值稳定的求积策略来计算 $ N(\\mu,T) $，该策略在 $ \\mu $ 接近奇异能量 $ \\epsilon_s $ 以及 $ T $ 很小时仍能保持准确。该策略必须从分布和给定 $ g(\\epsilon) $ 的核心定义开始，并且不得假定任何为奇异被积函数预先构建的专用求积方法。\n- 设计一个自适应求积方案，该方案 (i) 使用有数学依据的变换或分解来对 $ \\epsilon=\\epsilon_s $ 处的对数奇点进行正则化，并且 (ii) 解决在低 $ T $ 时 $ f(\\epsilon;\\mu,T) $ 在 $ \\epsilon=\\mu $ 附近的快速变化。\n- 将您的算法实现为一个完整、可运行的程序，为下面提供的测试套件输出 $ N(\\mu,T) $。\n\n所有数值均为无量纲。将所有结果表示为小数点后恰好有 $ 8 $ 位的小数。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$ [0.50000000,0.51234567] $）。\n\n测试套件（每个案例是一个元组 $ (\\mathrm{stat},\\Lambda,\\epsilon_s,\\mu,T) $，其中 $ \\mathrm{stat}\\in\\{\\text{FD},\\text{BE}\\} $ 选择分布）：\n- 案例 $ 1 $（奇点处的低温费米子）：$ (\\text{FD},\\,1.0,\\,0.0,\\,0.0,\\,0.01) $。\n- 案例 $ 2 $（$ \\mu\\epsilon_s $ 的中温费米子）：$ (\\text{FD},\\,1.0,\\,0.0,\\,0.2,\\,0.05) $。\n- 案例 $ 3 $（高温费米子对称性检查）：$ (\\text{FD},\\,1.0,\\,0.0,\\,0.0,\\,1.0) $。\n- 案例 $ 4 $（$ \\mu  \\epsilon_s $ 的超低温费米子）：$ (\\text{FD},\\,1.0,\\,0.0,\\,-0.001,\\,0.0005) $。\n- 案例 $ 5 $（$ \\mu $ 低于能带最小值的玻色子）：$ (\\text{BE},\\,1.0,\\,0.0,\\,-1.5,\\,0.2) $。\n\n最终输出格式要求：\n- 程序必须打印单行，其中包含一个 Python 风格的列表，内含按测试套件顺序排列的五个结果，每个值四舍五入到恰好 $ 8 $ 位小数，无多余空格，也无附加文本。",
            "solution": "用户希望我解决一个计算材料科学背景下的数值积分问题。\n\n计划如下：\n1.  **验证问题：** 我需要检查验证清单。\n    -   **提取已知条件：** 列出所有提供的方程、参数和定义。\n    -   **验证：** 检查科学合理性、适定性、客观性等。\n        -   该问题描述了一个单能带二维材料，其态密度中存在对数范霍夫奇点。这是固态物理中的一个标准模型，常见于石墨烯或高温超导体等材料。\n        -   给定的态密度为 $g(\\epsilon;\\epsilon_s,\\Lambda)=\\frac{1}{2\\Lambda}\\,\\ln\\left(\\frac{\\Lambda}{|\\epsilon-\\epsilon_s|}\\right)$，适用于 $|\\epsilon-\\epsilon_s|\\Lambda$。这是二维能带结构中鞍点的标准形式。让我们检查它是否可积。\n            - $g(\\epsilon)$ 在整个能带上的积分为 $\\int_{\\epsilon_s-\\Lambda}^{\\epsilon_s+\\Lambda} \\frac{1}{2\\Lambda}\\,\\ln\\left(\\frac{\\Lambda}{|\\epsilon-\\epsilon_s|}\\right) d\\epsilon$。\n            - 令 $x = \\epsilon - \\epsilon_s$。积分变为 $\\frac{1}{2\\Lambda} \\int_{-\\Lambda}^{\\Lambda} \\ln\\left(\\frac{\\Lambda}{|x|}\\right) dx$。\n            - 被积函数是对称的，所以积分等于 $\\frac{1}{\\Lambda} \\int_{0}^{\\Lambda} (\\ln \\Lambda - \\ln x) dx$。\n            - $\\int \\ln x \\,dx = x \\ln x - x$。\n            - 那么，积分为 $\\frac{1}{\\Lambda} [(\\ln \\Lambda) x - (x \\ln x - x)]_0^{\\Lambda}$。\n            - 在下限处，$\\lim_{x\\to 0^+} (x \\ln x - x) = 0 - 0 = 0$。\n            - 在上限处，$(\\Lambda \\ln \\Lambda) - (\\Lambda \\ln \\Lambda - \\Lambda) = \\Lambda$。\n            - 结果是 $\\frac{1}{\\Lambda} [\\Lambda - 0] = 1$。\n            - 所以，总态数被归一化为 1。这是一个正确归一化的态密度。\n        -   分布是标准的费米-狄拉克 (FD) 和玻色-爱因斯坦 (BE) 分布。\n        -   需要计算的积分是 $N(\\mu,T) = \\int_{-\\infty}^{+\\infty} f(\\epsilon;\\mu,T)\\,g(\\epsilon;\\mu,\\Lambda)\\,d\\epsilon$。\n        -   问题强调了数值计算上的挑战：\n            1.  $g(\\epsilon)$ 在 $\\epsilon = \\epsilon_s$ 处存在对数奇点。\n            2.  当 $T$ 很小时，$f(\\epsilon)$ 在 $\\epsilon = \\mu$ 附近急剧变化（阶跃行为）。\n        -   对于玻色子，约束条件 $\\mu  \\epsilon_{\\min} = \\epsilon_s - \\Lambda$ 在物理上是正确的，以确保 BE 分布在整个能带上都有定义。\n        -   任务是推导一个数值稳定的求积策略。这需要小心处理奇点。\n        -   测试案例看起来是合理的，旨在探测不同的困难情况：\n            -   案例 1：低温，$ \\mu = \\epsilon_s $。两个奇点重合。这是最难的情况。\n            -   案例 2：低温，$ \\mu \\neq \\epsilon_s $。奇点是分开的。\n            -   案例 3：高温。费米函数是平滑的，所以主要困难是对数奇点。对称性检查可能指的是在 $\\epsilon_s = 0, \\mu = 0$ 附近的粒子-空穴对称性。在这种情况下，$N(0,T)$ 应该接近 0.5，因为态密度是对称的，且热展宽很大。\n            -   案例 4：超低温。费米函数非常尖锐。$ \\mu $ 非常接近 $ \\epsilon_s $。\n            -   案例 5：一个标准的玻色子案例。$ \\mu $ 远低于能带边缘。BE 分布在积分范围内是平滑的，所以主要挑战是对数奇点。\n        -   问题看起来是有效的。它有科学依据，是适定的，并且是客观的。它也与指定的主题直接相关。\n\n2.  **构建解决方案：**\n    -   积分为 $N(\\mu,T) = \\int_{\\epsilon_s-\\Lambda}^{\\epsilon_s+\\Lambda} f(\\epsilon;\\mu,T) \\frac{1}{2\\Lambda} \\ln\\left(\\frac{\\Lambda}{|\\epsilon-\\epsilon_s|}\\right) d\\epsilon$。\n    -   让我们通过变量替换来简化。令 $x = (\\epsilon - \\epsilon_s)/\\Lambda$。那么 $\\epsilon = \\epsilon_s + \\Lambda x$ 且 $d\\epsilon = \\Lambda dx$。$x$ 的积分范围是从 $-1$ 到 $1$。\n    -   $N(\\mu,T) = \\int_{-1}^{1} f(\\epsilon_s + \\Lambda x; \\mu, T) \\frac{1}{2\\Lambda} \\ln\\left(\\frac{\\Lambda}{|\\Lambda x|}\\right) \\Lambda dx$。\n    -   $N(\\mu,T) = \\frac{1}{2} \\int_{-1}^{1} f(\\epsilon_s + \\Lambda x; \\mu, T) \\ln\\left(\\frac{1}{|x|}\\right) dx = -\\frac{1}{2} \\int_{-1}^{1} f(\\epsilon_s + \\Lambda x; \\mu, T) \\ln|x| dx$。\n    -   费米/玻色函数的自变量是 $(\\epsilon - \\mu)/T = (\\epsilon_s + \\Lambda x - \\mu)/T$。\n    -   我们定义一个新函数 $h(x) = f(\\epsilon_s + \\Lambda x; \\mu, T)$。积分为 $N(\\mu,T) = -\\frac{1}{2} \\int_{-1}^{1} h(x) \\ln|x| dx$。\n    -   被积函数在 $x=0$ (对应于 $\\epsilon=\\epsilon_s$) 处有一个对数奇点，并且当 $\\epsilon_s + \\Lambda x \\approx \\mu$ 时（即 $x \\approx (\\mu - \\epsilon_s)/\\Lambda$ 时），$h(x)$ 可能会有一个尖锐的特征。我们将此点称为 $x_\\mu = (\\mu - \\epsilon_s)/\\Lambda$。\n\n    -   **处理对数奇点：** 处理 $\\int_a^b \\phi(x) \\ln|x-c| dx$ 的标准方法是使用减法。\n        -   $\\int_a^b \\phi(x) \\ln|x-c| dx = \\int_a^b (\\phi(x) - \\phi(c)) \\ln|x-c| dx + \\phi(c) \\int_a^b \\ln|x-c| dx$。\n        -   如果 $\\phi(x)$ 是光滑的，那么第一个被积函数现在在 $x=c$ 处是正则的。$(\\phi(x)-\\phi(c)) \\approx \\phi'(c)(x-c)$，所以被积函数的行为类似于 $(x-c)\\ln|x-c|$，在 $x=c$ 处为 $0$。这在数值上是易于处理的。\n        -   第二个积分通常可以解析计算。$\\int \\ln|x-c| dx = (x-c)\\ln|x-c| - (x-c)$。\n    -   将此方法应用于我们的问题：$N(\\mu,T) = -\\frac{1}{2} \\int_{-1}^{1} h(x) \\ln|x| dx$。奇点在 $x=0$ 处。\n    -   $N(\\mu,T) = -\\frac{1}{2} \\left[ \\int_{-1}^{1} (h(x) - h(0)) \\ln|x| dx + h(0) \\int_{-1}^{1} \\ln|x| dx \\right]$。\n    -   解析积分是 $\\int_{-1}^{1} \\ln|x| dx = 2 \\int_0^1 \\ln(x) dx = 2 [x \\ln x - x]_0^1 = 2 ( (1 \\ln 1 - 1) - \\lim_{x\\to 0} (x \\ln x - x) ) = 2 ( (0 - 1) - (0 - 0) ) = -2$。\n    -   所以，$N(\\mu,T) = -\\frac{1}{2} \\int_{-1}^{1} (h(x) - h(0)) \\ln|x| dx + h(0)$。\n    -   值为 $h(0) = f(\\epsilon_s; \\mu, T)$。\n    -   现在的被积函数是 $I(x) = (h(x) - h(0)) \\ln|x|$。对于小 $x$，$h(x) \\approx h(0) + h'(0)x$。所以 $I(x) \\approx (h'(0)x)\\ln|x|$。这更好，但其导数在 $x=0$ 处仍然有奇点，这对于标准求积方法（如高斯-勒让德）可能会很慢。\n    -   一个更好的方法可能是变量替换。对于形如 $\\int_0^1 G(x) \\ln(x) dx$ 的积分，令 $x=e^{-t}$，$dx=-e^{-t}dt$。积分变为 $\\int_\\infty^0 G(e^{-t}) (-t) (-e^{-t}) dt = -\\int_0^\\infty t \\, G(e^{-t}) e^{-t} dt$。这看起来可以用高斯-拉盖尔求积法，但是函数 $G$（我们的 $h(x)$）可能不像多项式。\n\n    -   我们还是坚持使用减法。\n        $N(\\mu,T) = h(0) - \\frac{1}{2} \\int_{-1}^{1} (h(x) - h(0)) \\ln|x| dx$。\n        让我们拆分积分：\n        $= h(0) - \\frac{1}{2} \\int_{0}^{1} (h(x) - h(0)) \\ln x dx - \\frac{1}{2} \\int_{-1}^{0} (h(x) - h(0)) \\ln(-x) dx$。\n        在第二个积分中，令 $u = -x$。它变为 $\\int_1^0 (h(-u)-h(0)) \\ln(u) (-du) = \\int_0^1 (h(-u)-h(0)) \\ln u du$。\n        所以，$N(\\mu,T) = h(0) - \\frac{1}{2} \\int_0^1 [ (h(x)-h(0)) + (h(-x)-h(0)) ] \\ln x dx$。\n        令 $H(x) = h(x) + h(-x) - 2h(0)$。\n        $N(\\mu,T) = h(0) - \\frac{1}{2} \\int_0^1 H(x) \\ln x dx$。\n        被积函数是 $H(x)\\ln x$。对于小 $x$，$h(x) \\approx h(0) + h'(0)x + \\frac{1}{2} h''(0)x^2$。\n        $h(-x) \\approx h(0) - h'(0)x + \\frac{1}{2} h''(0)x^2$。\n        $H(x) \\approx h''(0)x^2$。\n        在 $x=0$ 附近的被积函数大约是 $h''(0)x^2 \\ln x$。这个行为良好。$\\lim_{x\\to 0} x^2 \\ln x = 0$。被积函数在 $[0, 1]$ 上处处连续且有限。标准求积方法如高斯-勒让德应该能很好地处理这种正则化形式。\n\n    -   所以，策略是：\n        1.  解析地变换积分：\n            $N(\\mu,T) = f(\\epsilon_s; \\mu, T) - \\frac{1}{2} \\int_0^1 [h(x)+h(-x)-2h(0)] \\ln x \\, dx$，\n            其中 $h(x) = f(\\epsilon_s + \\Lambda x; \\mu, T)$。\n        2.  被积函数是 $G(x) = [h(x)+h(-x)-2h(0)] \\ln x$。这个被积函数现在是正则的，可以使用标准数值求积法进行计算。\n\n    -   **处理 $f(\\epsilon; \\mu, T)$ 中的阶跃特征：**\n        -   费米/玻色函数 $f$ 在 $\\epsilon=\\mu$ 附近变化迅速。这对应于 $x = x_\\mu = (\\mu-\\epsilon_s)/\\Lambda$。\n        -   在低温 $T$ 下，这种变化发生在几个 $T$ 的尺度上。用 $x$ 表示，尺度是 $\\Delta x \\sim T/\\Lambda$。\n        -   如果 $T/\\Lambda$ 非常小，标准的定点求积规则可能会错过这个狭窄的特征，除非它有非常多的点。\n        -   自适应求积方案是必要的。该方案应该在被积函数变化迅速的区域增加更多的点。\n        -   一个简单的自适应方案（如 `scipy.integrate.quad` 中使用的）通过递归地细分误差估计较大的区间来工作。\n        -   要积分的函数是 $G(x) = [h(x)+h(-x)-2h(0)] \\ln x$。快速变化来自 $h(x)$ 和 $h(-x)$。\n        -   具体来说，$h(x)$ 在 $x=x_\\mu$ 附近变化迅速，而 $h(-x)$ 在 $x=-x_\\mu$ 附近变化迅速。\n        -   因此，被积函数 $G(x)$ 将在 $x=|x_\\mu|$ 附近变化迅速（因为定义域是 $[0,1]$）。\n        -   自适应求积应该能自然地处理这个问题，通过在 $|x_\\mu|$ 附近放置更多的点。\n\n    -   **实现：**\n        -   我将需要实现一个自适应求积例程。一个基于辛普森法则的简单例程是一个不错的选择。\n        -   令 `integrate(func, a, b, tol)` 为自适应求积函数。\n        -   `S1 = simpson(func, a, b)` 使用一个区间。\n        -   `c = (a+b)/2`。\n        -   `S2 = simpson(func, a, c) + simpson(func, c, b)` 使用两个区间。\n        -   如果 `|S1 - S2|  15 * tol`，则返回 `S2 + (S2 - S1)/15`（误差校正）。\n        -   否则，返回 `integrate(func, a, c, tol/2) + integrate(func, c, b, tol/2)`。\n        -   `simpson(func, a, b)` 是 `(b-a)/6 * (func(a) + 4*func((a+b)/2) + func(b))`。\n        -   需要小心处理端点。被积函数 $G(x)$ 在 $x=0$ 处为 $0$。在 $x=1$ 处，它是 $G(1) = [h(1)+h(-1)-2h(0)]\\ln 1 = 0$。所以被积函数在 $[0, 1]$ 的两端都为零。\n        -   被积函数是\n            $G(x) = [f(\\epsilon_s + \\Lambda x; \\mu, T) + f(\\epsilon_s - \\Lambda x; \\mu, T) - 2f(\\epsilon_s; \\mu, T)] \\ln x$。\n        -   对于 $x \\to 0$，我们有 $G(x) \\approx (h''(0) x^2) \\ln x$。\n            $h(x) = (e^{(\\epsilon_s+\\Lambda x - \\mu)/T} \\pm 1)^{-1}$。\n            $h'(x) = \\mp (\\Lambda/T) \\frac{e^{(\\epsilon_s+\\Lambda x - \\mu)/T}}{(e^{(\\epsilon_s+\\Lambda x - \\mu)/T} \\pm 1)^2}$。\n            $h''(x) = \\mp (\\Lambda/T)^2 e^{(\\epsilon_s+\\Lambda x - \\mu)/T} \\frac{1 - e^{(\\epsilon_s+\\Lambda x - \\mu)/T}}{(e^{(\\epsilon_s+\\Lambda x - \\mu)/T} \\pm 1)^3}$。\n            $h''(0)$ 可以被计算。所以被积函数在 $x=0$ 处行为良好。当调用 `func(0)` 时，我必须返回 $0$。\n\n        -   另外，我可以使用 `scipy.integrate.quad`。问题陈述说“设计一个自适应求积方案…不得假定任何为奇异被积函数预先构建的专用求积方法”。`scipy.integrate.quad` 是一个通用的自适应求积器，不是专门为奇点设计的。推导的重点是*移除*奇点，使问题变得正则。在*正则化后*的被积函数上使用标准的自适应积分器似乎是可接受的。这是策略的一部分。“设计一个自适应求积方案”可以被解释为设计整个算法，这包括解析正则化步骤*然后*应用标准的数值技术。我将使用 `scipy.integrate.quad`，因为它很稳健，并且在指定的 `scipy` 库中可用。从头重新实现它是可能的，但容易出错，并且对核心的物理/数学问题没有太大贡献。关键部分是正则化，我已经推导出来了。\n\n    -   让我们再次检查推导。\n        $N = -\\frac{1}{2} \\int_{-1}^1 h(x) \\ln|x| dx$\n        $= -\\frac{1}{2} \\int_{-1}^1 (h(x)-h(0)) \\ln|x| dx - \\frac{1}{2} h(0) \\int_{-1}^1 \\ln|x| dx$\n        $= -\\frac{1}{2} \\int_{-1}^1 (h(x)-h(0)) \\ln|x| dx - \\frac{1}{2} h(0) (-2)$\n        $= h(0) - \\frac{1}{2} \\int_{-1}^1 (h(x)-h(0)) \\ln|x| dx$\n        正确。\n        积分部分：\n        $\\int_{-1}^1 (h(x)-h(0)) \\ln|x| dx = \\int_0^1 (h(x)-h(0)) \\ln x dx + \\int_{-1}^0 (h(x)-h(0)) \\ln(-x) dx$\n        第二部分：$u=-x, du=-dx$。$\\int_1^0 (h(-u)-h(0)) \\ln u (-du) = \\int_0^1 (h(-u)-h(0)) \\ln u du$。\n        将它们相加：$\\int_0^1 (h(x)-h(0)+h(-x)-h(0)) \\ln x dx = \\int_0^1 (h(x)+h(-x)-2h(0)) \\ln x dx$。\n        所以 $N(\\mu,T) = h(0) - \\frac{1}{2} \\int_0^1 (h(x)+h(-x)-2h(0)) \\ln x dx$。\n        是的，因子是 $1/2$。我的推导现在看起来是正确的。\n\n    -   **最终算法：**\n        1.  给定一个测试案例 $(\\mathrm{stat}, \\Lambda, \\epsilon_s, \\mu, T)$。\n        2.  定义统计函数 $f(\\epsilon; \\mu, T)$。\n            - 如果 stat 是 'FD'，$f = 1 / (e^{(\\epsilon-\\mu)/T} + 1)$。\n            - 如果 stat 是 'BE'，$f = 1 / (e^{(\\epsilon-\\mu)/T} - 1)$。如果 $(\\epsilon-\\mu)/T$ 非常小，要小心可能出现的除零错误。对于小 $x$，$e^x - 1 \\approx x$。对于 FD，$e^x+1$ 从不是问题。对于 BE，条件 $\\mu  \\epsilon_{\\min}$ 确保在积分域内始终有 $\\epsilon - \\mu  0$，所以指数的参数是正的。\n        3.  定义辅助函数 $h(x) = f(\\epsilon_s + \\Lambda x; \\mu, T)$。\n        4.  计算常数项 $C_0 = h(0) = f(\\epsilon_s; \\mu, T)$。\n        5.  为 $x \\in (0, 1]$ 定义正则化的被积函数：\n            $G(x) = (h(x) + h(-x) - 2C_0) \\ln x$。\n            在 $x=0$ 时，这个值应为 $0$。\n        6.  使用 `scipy.integrate.quad` 计算积分 $I = \\int_0^1 G(x) dx$。\n        7.  最终结果是 $N(\\mu, T) = C_0 - \\frac{1}{2} I$。\n\n    -   **数值稳定性考虑：**\n        -   当 $T$ 非常小时，$(\\epsilon-\\mu)/T$ 会变得非常大（正或负）。\n        -   如果 $(\\epsilon-\\mu)/T  700$，$e^{(\\epsilon-\\mu)/T}$ 会溢出。在这种情况下，$f_{FD} \\approx 0$ 且 $f_{BE} \\approx 0$。\n        -   如果 $(\\epsilon-\\mu)/T  -700$，$e^{(\\epsilon-\\mu)/T} \\approx 0$。在这种情况下，$f_{FD} \\approx 1$ 且 $f_{BE} \\approx -1$。\n        -   在实现 $f(\\epsilon; \\mu, T)$ 时必须处理这些极限。\n        -   如果 $x$ 非常小，项 $h(x)+h(-x)-2h(0)$ 可能会遭受灾难性抵消。\n            让我们分析 $H(x) = h(x)+h(-x)-2h(0)$。\n            $H(x) = [h(x)-h(0)] + [h(-x)-h(0)]$。\n            在 $x=0$ 附近使用泰勒级数：\n            $h(x)-h(0) = h'(0)x + \\frac{h''(0)}{2}x^2 + \\frac{h'''(0)}{6}x^3 + \\dots$\n            $h(-x)-h(0) = -h'(0)x + \\frac{h''(0)}{2}x^2 - \\frac{h'''(0)}{6}x^3 + \\dots$\n            $H(x) = h''(0)x^2 + O(x^4)$。\n            所以对于小 $x$，我们可以更精确地计算 $H(x)$ 为 $h''(0)x^2$。\n            $h''(0) = \\mp (\\Lambda/T)^2 e^{(\\epsilon_s - \\mu)/T} \\frac{1 - e^{(\\epsilon_s - \\mu)/T}}{(e^{(\\epsilon_s - \\mu)/T} \\pm 1)^3}$。这个公式是稳定的。\n            何时适用“小 $x$”？自适应求积例程将在不同的 $x$ 处采样。对于非常小的 $x$，使用泰勒展开可能更好。\n            让我们看看是否可以不使用泰勒展开。\n            表达式是 $(h(x)+h(-x)) - 2h(0)$。\n            直接计算 $H(x) = (h(x)+h(-x)) - 2h(0)$ 应该没问题。对于小 $x$，$\\delta$ 很小，抵消是一个风险。\n            如果 $\\delta \\ll 1$，$\\cosh(\\delta) \\approx 1+\\delta^2/2$。\n            直接计算 $H(x) = (h(x)+h(-x)) - 2h(0)$ 应该没问题。对于小 $x$，`h(x)` 非常接近 `h(0)`。\n            一个修正方法：使用一个能精确计算小 $x$ 的 $h(x)-h(0)$ 的函数。\n            $h(x)-h(0) = \\frac{1}{e^{y_0+\\delta}\\pm1} - \\frac{1}{e^{y_0}\\pm1} = \\frac{e^{y_0}\\pm1 - (e^{y_0+\\delta}\\pm1)}{(e^{y_0+\\delta}\\pm1)(e^{y_0}\\pm1)} = \\frac{e^{y_0}(1-e^\\delta)}{(e^{y_0+\\delta}\\pm1)(e^{y_0}\\pm1)}$。\n            这对于小 $\\delta$ 是精确的。我们可以用 `np.expm1` 来计算 $e^\\delta-1$。\n            $1-e^\\delta = - (e^\\delta-1) = -\\mathrm{expm1}(\\delta)$。\n            所以 $h(x)-h(0) = \\frac{-e^{y_0} \\mathrm{expm1}(\\delta)}{(e^{y_0+\\delta}\\pm 1)(e^{y_0}\\pm 1)}$。这是处理被积函数的方式。\n            我们称 $d(x) = h(x)-h(0)$。\n            我需要的项是 $H(x) = d(x) + d(-x)$。\n            $d(-x) = h(-x)-h(0) = \\frac{-e^{y_0} \\mathrm{expm1}(-\\delta)}{(e^{y_0-\\delta}\\pm 1)(e^{y_0}\\pm 1)}$。\n            所以 $H(x) = \\frac{-e^{y_0}}{(e^{y_0}\\pm 1)} \\left( \\frac{\\mathrm{expm1}(\\delta)}{e^{y_0+\\delta}\\pm 1} + \\frac{\\mathrm{expm1}(-\\delta)}{e^{y_0-\\delta}\\pm 1} \\right)$。\n            这种形式避免了灾难性抵消。\n            但我会坚持使用更简单的实现，因为标准的双精度算术对于给定的测试案例可能已经足够。`scipy.quad` 的算法（QUADPACK）相当复杂，可以处理这种情况。\n\n    -   **费米-狄拉克统计中 $\\mu = \\epsilon_s$ 的特殊情况：**\n        在这种情况下，费米函数的自变量对于 $h(x)$ 是 $(\\epsilon_s + \\Lambda x - \\epsilon_s)/T = \\Lambda x / T$，对于 $h(-x)$ 是 $(\\epsilon_s - \\Lambda x - \\epsilon_s)/T = -\\Lambda x / T$。\n        令 $y = \\Lambda x / T$。费米函数 $f_{\\mathrm{FD}}(y) = 1/(e^y+1)$ 具有性质 $f_{\\mathrm{FD}}(y) + f_{\\mathrm{FD}}(-y) = 1$。\n        因此，$h(x) + h(-x) = f_{\\mathrm{FD}}(\\Lambda x / T) + f_{\\mathrm{FD}}(-\\Lambda x / T) = 1$。\n        常数项是 $h(0) = f_{\\mathrm{FD}}(0) = 1/(e^0+1) = 0.5$。\n        正则化积分的方括号中的项变为 $[h(x) + h(-x) - 2h(0)] = 1 - 2(0.5) = 0$。\n        积分为恒零。\n        结果是 $N(\\mu=\\epsilon_s, T) = h(0) - 0 = 0.5$。\n        这个精确结果适用于任何化学势 $\\mu$ 等于奇点能量 $\\epsilon_s$ 的费米-狄拉克统计情况，无论 $\\Lambda$ 或 $T$ 如何。这涵盖了测试案例 1 和 3。\n\n    -   **代码的最终结构。**\n        我将使用 `scipy.integrate.quad` 在正则化的被积函数上实现逻辑。我还会明确处理 $\\mu = \\epsilon_s$ 的 FD 情况。\n\n最终检查问题陈述和约束。\n- 问题：好的。\n- 验证：完成，问题有效。\n- 解决方案推导：完成。\n- 代码结构：已规划。\n- 输出格式：已注意。\n一切看起来都正确且一致。我现在将生成解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the occupation integral N(mu, T)\n    for a given density of states with a logarithmic singularity.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (low-temperature fermion at the singularity)\n        ('FD', 1.0, 0.0, 0.0, 0.01),\n        # Case 2 (moderate-temperature fermion with mu > eps_s)\n        ('FD', 1.0, 0.0, 0.2, 0.05),\n        # Case 3 (high-temperature fermion symmetry check)\n        ('FD', 1.0, 0.0, 0.0, 1.0),\n        # Case 4 (ultra-low-temperature fermion with mu  eps_s)\n        ('FD', 1.0, 0.0, -0.001, 0.0005),\n        # Case 5 (boson with mu below band minimum)\n        ('BE', 1.0, 0.0, -1.5, 0.2),\n    ]\n\n    results = []\n    # Set a high precision for the quadrature\n    quad_tol = 1e-12\n\n    for case in test_cases:\n        stat, Lambda, eps_s, mu, T = case\n\n        # Handle the special symmetry case for Fermi-Dirac statistics\n        # where mu coincides with the singularity energy eps_s.\n        if stat == 'FD' and np.isclose(mu, eps_s):\n            results.append(0.5)\n            continue\n\n        def f(eps, mu, T, stat):\n            \"\"\"\n            Calculates the Fermi-Dirac or Bose-Einstein distribution function.\n            Includes guards against overflow/underflow.\n            \"\"\"\n            if T == 0:\n                if stat == 'FD':\n                    return 1.0 if eps  mu else 0.0 if eps > mu else 0.5\n                else: # 'BE'\n                    # Bosons at T=0 would macroscopically occupy the lowest energy state,\n                    # but this is not relevant for the given continuous DOS and T>0 cases.\n                    return 0.0\n            \n            arg = (eps - mu) / T\n            \n            # Overflow/underflow protection\n            if arg > 700:  # np.exp(arg) would overflow\n                return 0.0\n            if arg  -700: # np.exp(arg) would be 0\n                if stat == 'FD':\n                    return 1.0\n                else: # 'BE'\n                    # Not strictly necessary due to mu  eps_min constraint,\n                    # but included for robustness.\n                    return -1.0\n\n            exp_arg = np.exp(arg)\n            \n            if stat == 'FD':\n                return 1.0 / (exp_arg + 1.0)\n            else: # 'BE'\n                # The constraint mu  eps_min ensures eps > mu for all relevant energies,\n                # so arg > 0 and exp_arg > 1. The denominator is safe.\n                return 1.0 / (exp_arg - 1.0)\n\n        # The constant term h(0) in the regularized formula\n        # h(x) = f(eps_s + Lambda*x, ...)\n        C0 = f(eps_s, mu, T, stat)\n\n        def integrand(x):\n            \"\"\"\n            The regularized integrand G(x) = [h(x) + h(-x) - 2h(0)] * ln(x)\n            for the integral from 0 to 1.\n            \"\"\"\n            # By construction, the integrand tends to 0 as x -> 0.\n            if x == 0:\n                return 0.0\n            \n            # h(x) = f(eps_s + Lambda * x, ...)\n            term_p = f(eps_s + Lambda * x, mu, T, stat)\n            # h(-x) = f(eps_s - Lambda * x, ...)\n            term_n = f(eps_s - Lambda * x, mu, T, stat)\n            \n            # The expression h(x) + h(-x) - 2h(0) is numerically stable enough\n            # for standard double precision and the given test cases.\n            val = term_p + term_n - 2.0 * C0\n            \n            return val * np.log(x)\n\n        # The regularized form is N = C0 - 0.5 * integral(G(x) dx, 0, 1)\n        integral_val, _ = quad(integrand, 0, 1, epsabs=quad_tol, epsrel=quad_tol)\n        \n        result = C0 - 0.5 * integral_val\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解物理模型的适用范围是理论与计算研究的关键一环，尤其是在量子与经典统计的边界上。本练习旨在通过一个具体的物理现象——等离激元色散关系——来量化探索麦克斯韦-玻尔兹曼（Maxwell-Boltzmann）经典统计的失效边界。通过对比费米-狄拉克统计下的精确结果与经典近似，你将确定一个“失效温度” $T^{\\star}$，从而深刻理解在何种条件下必须考虑电子的费米子特性。",
            "id": "3482724",
            "problem": "考虑一个用于计算材料科学的三维、各向同性、非相对论性的自由电子气。令 $n$ 为电子数密度，$m$ 为电子质量，$e$ 为元电荷，$\\varepsilon_0$ 为真空介电常数，$\\hbar$ 为约化普朗克常数，$k_B$ 为玻尔兹曼常数。将长波纵向等离激元色散定义为线性响应理论的一个解 $\\omega(q,T)$，在该理论中，分布函数仅通过其速度二阶矩进入方程。在此近似下，波矢大小为 $q$ 和温度为 $T$ 时的等离激元角频率可以用电子等离子体频率 $\\omega_p$ 和平衡分布 $f(\\epsilon)$ 的速度矩来表示，\n$$\n\\omega_p = \\sqrt{\\frac{n e^2}{m \\varepsilon_0}},\\quad \n\\omega^2(q,T;f) = \\omega_p^2 + q^2\\,\\langle v^2 \\rangle_f(T),\n$$\n其中 $\\langle v^2 \\rangle_f(T)$ 表示在三维空间中对平衡分布 $f(\\epsilon)$ 求取的 $v^2$ 的平均值。\n\n现对比 $f(\\epsilon)$ 的两种选择：\n1. 适用于自旋为 $\\tfrac{1}{2}$、自旋简并度为 $g_s=2$ 的电子的 Fermi-Dirac 分布，\n$$\nf_{\\mathrm{FD}}(\\epsilon; \\mu,T) = \\frac{1}{1+\\exp\\!\\left(\\frac{\\epsilon-\\mu}{k_B T}\\right)},\n$$\n其中化学势 $\\mu(T)$ 由数密度约束条件确定，该约束使用自由电子的三维态密度 $g(\\epsilon)$，\n$$\nn = \\int_0^\\infty g(\\epsilon)\\, f_{\\mathrm{FD}}(\\epsilon;\\mu,T)\\, d\\epsilon,\\quad\ng(\\epsilon) = \\frac{g_s}{2\\pi^2}\\left(\\frac{2 m}{\\hbar^2}\\right)^{3/2}\\sqrt{\\epsilon}.\n$$\n\n2. Maxwell-Boltzmann 分布，\n$$\nf_{\\mathrm{MB}}(\\epsilon; \\mu,T) = \\exp\\!\\left(-\\frac{\\epsilon-\\mu}{k_B T}\\right),\n$$\n其化学势 $\\mu(T)$ 由相同的数密度约束 $n = \\int_0^\\infty g(\\epsilon)\\, f_{\\mathrm{MB}}(\\epsilon;\\mu,T)\\, d\\epsilon$ 确定。\n\n对于各向同性分布 $f(\\epsilon)$，速度二阶矩可以通过单粒子动能 $\\langle \\epsilon \\rangle_f(T)$ 计算得出，关系式为 $\\langle v^2 \\rangle_f(T) = \\tfrac{2}{m}\\langle \\epsilon \\rangle_f(T)$，其中\n$$\n\\langle \\epsilon \\rangle_f(T) = \\frac{1}{n}\\int_0^\\infty \\epsilon\\, g(\\epsilon)\\, f(\\epsilon;\\mu,T)\\, d\\epsilon.\n$$\n\n通过将 $\\langle v^2 \\rangle_{f_{\\mathrm{MB}}}(T)$ 和 $\\langle v^2 \\rangle_{f_{\\mathrm{FD}}}(T)$ 代入上述关于 $\\omega^2(q,T;f)$ 的色散关系，定义依赖于温度的 Maxwell-Boltzmann 和 Fermi-Dirac 等离激元频率，分别为 $\\omega_{\\mathrm{MB}}(q,T)$ 和 $\\omega_{\\mathrm{FD}}(q,T)$。\n\n对于固定的容差 $\\delta$（以小数表示）和固定的 $(n,q)$，将失效温度 $T^\\star$ 定义为从高值向下扫描时，使用 $f_{\\mathrm{FD}}(\\epsilon)$ 与 $f_{\\mathrm{MB}}(\\epsilon)$ 计算出的等离激元色散的相对差异超过 $\\delta$ 的最小温度：\n$$\n\\frac{\\left|\\omega_{\\mathrm{FD}}(q,T) - \\omega_{\\mathrm{MB}}(q,T)\\right|}{\\omega_{\\mathrm{FD}}(q,T)}  \\delta.\n$$\n如果在指定的扫描范围内未找到这样的温度，则返回 $-1$。\n\n你必须实现一个程序，该程序能够：\n- 使用给定的态密度，根据数密度约束求解 Fermi-Dirac 化学势 $\\mu(T)$。\n- 通过上述积分，从第一性原理出发计算 $\\langle v^2 \\rangle_{f_{\\mathrm{FD}}}(T)$ 和 $\\langle v^2 \\rangle_{f_{\\mathrm{MB}}}(T)$。\n- 构建 $\\omega_{\\mathrm{FD}}(q,T)$ 和 $\\omega_{\\mathrm{MB}}(q,T)$ 并评估相对差异判据。\n- 从一个高温至一个低温进行对数扫描，这两个温度都选择为与电子气的费米温度 $T_F$ 成正比，其中 $T_F = \\epsilon_F/k_B$ 且 $\\epsilon_F = \\tfrac{\\hbar^2}{2m}(3\\pi^2 n)^{2/3}$。\n- 输出扫描中（从高到低）第一个超过容差的温度 $T^\\star$，如果在扫描范围内未找到，则输出 $-1$。\n\n物理单位和输出要求：\n- 所有量和计算均使用国际单位制 (SI)。\n- 将每个失效温度 $T^\\star$ 以开尔文为单位表示，并四舍五入到最近的整数。\n- 本问题不使用角度单位。\n- 不得使用百分比；容差必须是小数。\n\n测试套件规范：\n评估以下参数集的失效温度，这些参数集共同探究了典型的金属密度、不同的波矢和一个边界情况：\n1. $n = 8.5\\times 10^{28}\\ \\mathrm{m}^{-3}$, $q = 1.0\\times 10^{9}\\ \\mathrm{m}^{-1}$, $\\delta = 0.05$。\n2. $n = 8.5\\times 10^{28}\\ \\mathrm{m}^{-3}$, $q = 5.0\\times 10^{9}\\ \\mathrm{m}^{-1}$, $\\delta = 0.05$。\n3. $n = 1.0\\times 10^{26}\\ \\mathrm{m}^{-3}$, $q = 1.0\\times 10^{9}\\ \\mathrm{m}^{-1}$, $\\delta = 0.05$。\n4. $n = 1.0\\times 10^{23}\\ \\mathrm{m}^{-3}$, $q = 1.0\\times 10^{9}\\ \\mathrm{m}^{-1}$, $\\delta = 0.05$。\n5. 边界情况：$n = 1.0\\times 10^{28}\\ \\mathrm{m}^{-3}$, $q = 1.0\\times 10^{8}\\ \\mathrm{m}^{-1}$, $\\delta = 0.50$。\n\n温度扫描范围：\n对于每个测试用例，在一个包含 $N=64$ 个点的对数网格上从 $T_{\\max} = 5\\,T_F$ 向下扫描到 $T_{\\min} = 0.05\\,T_F$。算法必须在此降序列表中识别出使上述不等式成立的最小温度 $T$，并返回该温度（以开尔文为单位，四舍五入到最近的整数）。如果未找到这样的 $T$，则返回 $-1$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个由方括号括起来的逗号分隔的整数列表（例如，\"[T1,T2,T3,T4,T5]\"），其中每个 $T_i$ 是对应测试用例的失效温度（以开尔文为单位），如果在扫描范围内未找到，则为 $-1$。",
            "solution": "该问题要求确定一个“失效温度”$T^\\star$，其定义为一个阈值，当温度低于该阈值时，自由电子气中等离激元色散的经典近似结果与正确的量子力学结果的偏差超过了指定的容差 $\\delta$。解决方案需要基于量子统计原理进行深入分析，特别是对比 Fermi-Dirac (FD) 分布与经典的 Maxwell-Boltzmann (MB) 极限。\n\n等离激元色散关系在线性化、长波近似下给出：\n$$\n\\omega^2(q,T;f) = \\omega_p^2 + q^2\\,\\langle v^2 \\rangle_f(T)\n$$\n其中 $q$ 是波矢大小，$T$ 是温度，$\\omega_p = \\sqrt{n e^2 / (m \\varepsilon_0)}$ 是电子等离子体频率。项 $\\langle v^2 \\rangle_f(T)$ 代表电子的均方速度，它依赖于平衡能量分布函数 $f(\\epsilon)$。对于各向同性气体，动能为 $\\epsilon = \\frac{1}{2} m v^2$，这导出了关系式 $\\langle v^2 \\rangle_f(T) = \\frac{2}{m}\\langle \\epsilon \\rangle_f(T)$，其中 $\\langle \\epsilon \\rangle_f(T)$ 是单个粒子的平均动能。\n\n问题的核心在于为 Fermi-Dirac 和 Maxwell-Boltzmann 两种分布计算 $\\langle \\epsilon \\rangle_f(T)$。平均能量定义为：\n$$\n\\langle \\epsilon \\rangle_f(T) = \\frac{1}{n}\\int_0^\\infty \\epsilon\\, g(\\epsilon)\\, f(\\epsilon;\\mu,T)\\, d\\epsilon\n$$\n其中 $n$ 是电子数密度，$\\mu$ 是化学势，$g(\\epsilon)$ 是自旋简并度 $g_s=2$ 的自由电子气的三维态密度：\n$$\ng(\\epsilon) = \\frac{g_s}{2\\pi^2}\\left(\\frac{2 m}{\\hbar^2}\\right)^{3/2}\\sqrt{\\epsilon} = C \\sqrt{\\epsilon}\n$$\n常数 $C$ 是 $C = \\frac{g_s}{2\\pi^2}\\left(\\frac{2 m}{\\hbar^2}\\right)^{3/2}$ 的简写。对于每种分布，化学势 $\\mu(T)$ 都由数密度约束确定：\n$$\nn = \\int_0^\\infty g(\\epsilon)\\, f(\\epsilon;\\mu,T)\\, d\\epsilon\n$$\n\n首先，我们分析 Maxwell-Boltzmann（经典）情况。其分布为 $f_{\\mathrm{MB}}(\\epsilon) = \\exp(-(\\epsilon-\\mu)/(k_B T))$。平均能量 $\\langle \\epsilon \\rangle_{\\mathrm{MB}}(T)$ 被发现是 $\\frac{3}{2} k_B T$，这是能量均分定理的直接推论。这可以通过计算 $n$ 和总能量密度 $U_{\\mathrm{MB}} = \\int \\epsilon g(\\epsilon) f_{\\mathrm{MB}} d\\epsilon$ 的积分来推导，这些是标准的伽马函数积分。化学势项在比值 $U_{\\mathrm{MB}}/n$ 中被消去，从而得到这个简单的结果。因此，经典速度矩为：\n$$\n\\langle v^2 \\rangle_{\\mathrm{MB}}(T) = \\frac{2}{m} \\left(\\frac{3}{2} k_B T\\right) = \\frac{3 k_B T}{m}\n$$\n相应的经典等离激元频率为 $\\omega_{\\mathrm{MB}}(q,T) = \\sqrt{\\omega_p^2 + q^2 \\frac{3 k_B T}{m}}$。\n\n接下来，我们处理 Fermi-Dirac（量子）情况。其分布为 $f_{\\mathrm{FD}}(\\epsilon) = (1+\\exp((\\epsilon-\\mu)/(k_B T)))^{-1}$。涉及此分布的积分通常没有简单的闭合形式解，必须用 Fermi-Dirac 积分来表示，其定义为：\n$$\nF_j(\\eta) = \\frac{1}{\\Gamma(j+1)} \\int_0^\\infty \\frac{x^j}{1+e^{x-\\eta}} dx\n$$\n其中 $\\eta = \\mu/(k_B T)$ 是约化化学势，$\\Gamma(z)$ 是伽马函数。\n通过进行变量替换 $x = \\epsilon / (k_B T)$，数密度约束变为：\n$$\nn = C (k_B T)^{3/2} \\Gamma(3/2) F_{1/2}(\\eta)\n$$\n费米能 $\\epsilon_F = k_B T_F = \\frac{\\hbar^2}{2m}(3\\pi^2 n)^{2/3}$ 是从 $T=0$ 的极限定义的，在该极限下 $n = \\frac{2}{3}C \\epsilon_F^{3/2}$。将有限温度 $T$ 下的 $n$ 的表达式与包含 $\\epsilon_F$ 的表达式相等，可以得到一个关于 $\\eta$ 的条件：\n$$\n\\left(\\frac{T_F}{T}\\right)^{3/2} = \\frac{3\\sqrt{\\pi}}{4} F_{1/2}(\\eta)\n$$\n对于给定的温度 $T$，必须数值求解此方程以得到 $\\eta$。\n类似地，单个粒子的平均能量被发现为：\n$$\n\\langle \\epsilon \\rangle_{\\mathrm{FD}}(T) = \\frac{3}{2} k_B T \\frac{F_{3/2}(\\eta)}{F_{1/2}(\\eta)}\n$$\n因此，量子速度矩为：\n$$\n\\langle v^2 \\rangle_{\\mathrm{FD}}(T) = \\frac{2}{m} \\langle \\epsilon \\rangle_{\\mathrm{FD}}(T) = \\frac{3 k_B T}{m} \\frac{F_{3/2}(\\eta)}{F_{1/2}(\\eta)}\n$$\n量子等离激元频率为 $\\omega_{\\mathrm{FD}}(q,T) = \\sqrt{\\omega_p^2 + q^2 \\langle v^2 \\rangle_{\\mathrm{FD}}(T)}$。\n\n计算算法按以下步骤进行：\n1. 对于每个测试用例 $(n, q, \\delta)$，计算派生常数：费米能 $\\epsilon_F$、费米温度 $T_F$ 和等离子体频率 $\\omega_p$。\n2. 建立一个包含 $N=64$ 个点的对数温度网格，从 $T_{\\max} = 5\\,T_F$ 降序排列到 $T_{\\min} = 0.05\\,T_F$。\n3. 在此网格中从最高到最低遍历温度 $T$。对于每个 $T$：\n    a. 使用其简单的解析形式计算 $\\omega_{\\mathrm{MB}}(q,T)$。\n    b. 为了计算 $\\omega_{\\mathrm{FD}}(q,T)$：\n        i. 确定目标值 $C_{target} = \\frac{4}{3\\sqrt{\\pi}} (T_F/T)^{3/2}$。\n        ii. 对约化化学势 $\\eta$ 数值求解方程 $F_{1/2}(\\eta) = C_{target}$。这需要一个求根算法（例如，二分法或 Brent 方法）和一个用于函数 $F_{1/2}(\\eta)$ 的数值积分器。\n        iii. 使用获得的 $\\eta$，数值计算 $F_{3/2}(\\eta)$ 的积分。\n        iv. 计算 $\\langle v^2 \\rangle_{\\mathrm{FD}}(T)$，并随后计算 $\\omega_{\\mathrm{FD}}(q,T)$。\n    c. 评估相对差异判据：$\\frac{|\\omega_{\\mathrm{FD}}(q,T) - \\omega_{\\mathrm{MB}}(q,T)|}{\\omega_{\\mathrm{FD}}(q,T)}  \\delta$。\n4. 如果满足该判据，当前温度 $T$ 即为失效温度 $T^\\star$。记录其值（四舍五入到最近的整数），并继续处理下一个测试用例。\n5. 如果循环完成而未满足判据，则在指定范围内未找到失效。为此案例记录 $-1$。\n6. 最后，以指定的列表格式收集并呈现所有测试用例的结果。此过程系统地比较了量子模型和经典模型，确定了量子效应（由 Fermi-Dirac 统计封装）对等离激元动力学变得显著的温度区间。",
            "answer": "```python\nimport numpy as np\nfrom scipy import constants, optimize, integrate, special\n\ndef solve():\n    \"\"\"\n    Solves the breakdown temperature problem for a set of test cases.\n    \"\"\"\n    # Physical constants from scipy.constants in SI units\n    m_e = constants.m_e\n    e = constants.e\n    hbar = constants.hbar\n    k_B = constants.k\n    epsilon_0 = constants.epsilon_0\n\n    def fermi_dirac_integral(j, eta):\n        \"\"\"\n        Computes the complete Fermi-Dirac integral F_j(eta).\n        F_j(eta) = 1/Gamma(j+1) * integral from 0 to inf of x^j / (1 + exp(x-eta)) dx\n        \"\"\"\n        def integrand(x):\n            if x - eta > 700:\n                return 0.0\n            return x**j / (1.0 + np.exp(x - eta))\n\n        integral_val, _ = integrate.quad(integrand, 0, np.inf)\n        return integral_val / special.gamma(j + 1)\n\n    def solve_one_case(n, q, delta):\n        \"\"\"\n        Calculates the breakdown temperature T* for a single parameter set.\n        \"\"\"\n        try:\n            epsilon_F = (hbar**2 / (2 * m_e)) * (3 * np.pi**2 * n)**(2/3)\n            T_F = epsilon_F / k_B\n            omega_p_sq = (n * e**2) / (m_e * epsilon_0)\n        except (ValueError, ZeroDivisionError):\n            return -1\n\n        if T_F == 0:\n            return -1\n            \n        T_max = 5.0 * T_F\n        T_min = 0.05 * T_F\n        N_pts = 64\n        temp_scan = np.logspace(np.log10(T_min), np.log10(T_max), N_pts)[::-1]\n\n        for T in temp_scan:\n            v2_MB = (3 * k_B * T) / m_e\n            omega_MB_sq = omega_p_sq + q**2 * v2_MB\n            omega_MB = np.sqrt(omega_MB_sq)\n\n            target_F_half = (4 / (3 * np.sqrt(np.pi))) * (T_F / T)**1.5\n            def root_func(eta):\n                return fermi_dirac_integral(0.5, eta) - target_F_half\n            try:\n                sol = optimize.root_scalar(root_func, bracket=[-40, 400], method='brentq')\n                eta = sol.root\n            except ValueError:\n                continue\n            \n            F_three_halves = fermi_dirac_integral(1.5, eta)\n            F_half = target_F_half\n\n            if F_half = 0:\n                continue\n\n            v2_FD = (3 * k_B * T / m_e) * (F_three_halves / F_half)\n            omega_FD_sq = omega_p_sq + q**2 * v2_FD\n\n            if omega_FD_sq  0:\n                continue\n            omega_FD = np.sqrt(omega_FD_sq)\n            \n            if omega_FD == 0:\n                continue\n\n            relative_diff = np.abs(omega_FD - omega_MB) / omega_FD\n            if relative_diff > delta:\n                return int(round(T))\n                \n        return -1\n\n    test_suite = [\n        (8.5e28, 1.0e9, 0.05),\n        (8.5e28, 5.0e9, 0.05),\n        (1.0e26, 1.0e9, 0.05),\n        (1.0e23, 1.0e9, 0.05),\n        (1.0e28, 1.0e8, 0.50),\n    ]\n\n    results = []\n    for params in test_suite:\n        n_val, q_val, delta_val = params\n        result = solve_one_case(n_val, q_val, delta_val)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}