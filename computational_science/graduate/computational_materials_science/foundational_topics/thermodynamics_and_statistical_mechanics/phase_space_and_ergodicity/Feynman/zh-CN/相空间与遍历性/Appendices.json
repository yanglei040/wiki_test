{
    "hands_on_practices": [
        {
            "introduction": "分子动力学模拟的一个核心是遍历性假说，它将长时间平均与系综平均等同起来。然而，由于模拟轨迹中的数据点存在时间相关性，我们需要一种方法来量化获得统计独立样本所需的时间。本练习通过计算积分自相关时间（Integrated Autocorrelation Time, IAT），帮助你掌握一项关键技能：如何估算确保模拟结果收敛到给定统计精度所需的最小模拟时长 。",
            "id": "3475291",
            "problem": "考虑一个使用分子动力学 (MD) 模拟的 Lennard-Jones (LJ) 流体。令 $U(t)$ 表示瞬时势能作为时间 $t$ 的函数。假设该过程是平稳的且遍历的，即当轨迹长度趋于无穷大时，时间平均等于系综平均。定义长度为 $T$ 的轨迹上的势能的时间平均为\n$$\n\\overline{U}_T = \\frac{1}{T} \\int_{0}^{T} U(t)\\, dt,\n$$\n并将系综平均表示为\n$$\n\\langle U \\rangle = \\mathbb{E}[U(t)].\n$$\n令涨落为 $\\delta U(t) = U(t) - \\langle U \\rangle$。定义自协方差函数\n$$\nC(\\tau) = \\langle \\delta U(0)\\,\\delta U(\\tau) \\rangle,\n$$\n以及归一化自相关函数 (ACF)\n$$\n\\rho(\\tau) = \\frac{C(\\tau)}{C(0)},\n$$\n其中 $C(0) = \\sigma^2$ 是 $U(t)$ 的方差。对于连续时间过程，积分自相关时间 (IAT) 为\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\rho(\\tau)\\, d\\tau,\n$$\n对于采样间隔为 $\\Delta t$ 且延迟由整数 $k \\in \\{0,1,2,\\dots\\}$ 索引的离散时间采样过程，以步数为单位的 IAT 为\n$$\n\\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k,\n$$\n以时间为单位的 IAT 由 $\\tau_{\\mathrm{int,time}} = \\Delta t \\,\\tau_{\\mathrm{int,steps}}$ 给出。\n\n仅从这些定义、平稳过程的性质和基础概率演算出发，推导出一个表达式，用于计算最小轨迹长度 $T$，使得 $\\overline{U}_T$ 相对于 $\\langle U \\rangle$ 的均方根偏差不超过给定的能量单位公差 $\\varepsilon$。最终表达式必须显示 $T$ 如何依赖于 $\\sigma^2$、$\\varepsilon$ 和积分自相关时间 (IAT)。\n\n实现一个程序，对以下每个测试用例，计算所需的最小轨迹长度 $T$，以使均方根偏差最多为 $\\varepsilon$。所有 $T$ 值必须以皮秒为单位报告。对于连续时间情况，请使用连续时间 IAT。对于离散时间情况，通过对 ACF 求和直至项的量级低于 $10^{-12}$ 的阈值来计算 $\\tau_{\\mathrm{int,steps}}$，然后使用 $\\Delta t$ 将其转换为时间单位。\n\n测试套件规格：\n- 案例 1 (连续时间指数 ACF)：\n  - $\\rho(\\tau) = \\exp\\left(-\\frac{\\tau}{\\tau_c}\\right)$,\n  - $\\tau_c = 2.5$ $\\mathrm{ps}$,\n  - $\\sigma^2 = 25$ $(\\mathrm{kJ/mol})^2$,\n  - $\\varepsilon = 0.5$ $\\mathrm{kJ/mol}$.\n- 案例 2 (连续时间拉伸指数 ACF)：\n  - $\\rho(\\tau) = \\exp\\left(-\\left(\\frac{\\tau}{\\tau_c}\\right)^{\\beta}\\right)$,\n  - $\\tau_c = 1.0$ $\\mathrm{ps}$,\n  - $\\beta = 0.5$,\n  - $\\sigma^2 = 9$ $(\\mathrm{kJ/mol})^2$,\n  - $\\varepsilon = 0.3$ $\\mathrm{kJ/mol}$.\n- 案例 3 (离散时间指数 ACF)：\n  - $\\rho_k = \\exp\\left(-\\frac{k\\,\\Delta t}{\\tau_c}\\right)$,\n  - $\\Delta t = 0.693147$ $\\mathrm{ps}$,\n  - $\\tau_c = 1.0$ $\\mathrm{ps}$,\n  - $\\sigma^2 = 4$ $(\\mathrm{kJ/mol})^2$,\n  - $\\varepsilon = 0.2$ $\\mathrm{kJ/mol}$.\n- 案例 4 (离散时间不相关边缘情况)：\n  - 对于所有 $k \\ge 1$, $\\rho_k = 0$,\n  - $\\Delta t = 0.5$ $\\mathrm{ps}$,\n  - $\\sigma^2 = 16$ $(\\mathrm{kJ/mol})^2$,\n  - $\\varepsilon = 1.0$ $\\mathrm{kJ/mol}$.\n\n角度单位不适用。所有物理单位必须一致处理。将最终轨迹长度 $T$ 以皮秒表示，并四舍五入到小数点后 3 位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 1 到 4 的顺序排列为 $[T_1, T_2, T_3, T_4]$，例如 $[T_1,T_2,T_3,T_4]$，其中每个 $T_i$ 是一个以皮秒为单位、四舍五入到小数点后 3 位的浮点数。",
            "solution": "问题陈述是在计算模拟的时间序列数据统计分析方面一个有效且适定的练习，这是计算材料科学中的一个标准课题。它在科学上基于统计力学的原理，特别是涨落理论和时间相关函数。所提供的时间平均、系综平均、自相关函数 (ACF) 和积分自相关时间 (IAT) 的定义都是标准的。测试用例的所有参数都已明确给出，问题是自洽且内部一致的。没有科学上的不准确、模糊或矛盾之处。\n\n中心任务是推导出一个表达式，用于计算以指定的统计精度估算势能系综平均 $\\langle U \\rangle$ 所需的最小模拟时间 $T$。精度由时间平均势能 $\\overline{U}_T$ 与真实系综平均的均方根偏差不超过公差 $\\varepsilon$ 的条件来定义。这个条件可以正式表示为：\n$$\n\\sqrt{\\mathbb{E}\\left[ (\\overline{U}_T - \\langle U \\rangle)^2 \\right]} \\le \\varepsilon\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示期望算子。对两边平方，得到关于时间平均方差 $\\text{Var}(\\overline{U}_T)$ 的条件：\n$$\n\\text{Var}(\\overline{U}_T) = \\mathbb{E}\\left[ (\\overline{U}_T - \\langle U \\rangle)^2 \\right] \\le \\varepsilon^2\n$$\n注意，对于平稳过程，$\\mathbb{E}[\\overline{U}_T] = \\langle U \\rangle$。我们的第一步是推导 $\\text{Var}(\\overline{U}_T)$ 的表达式。\n\n从连续时间过程的时间平均 $\\overline{U}_T$ 的定义开始：\n$$\n\\overline{U}_T = \\frac{1}{T} \\int_{0}^{T} U(t)\\, dt\n$$\n方差为：\n$$\n\\text{Var}(\\overline{U}_T) = \\mathbb{E}\\left[ \\left( \\frac{1}{T} \\int_{0}^{T} U(t)\\, dt - \\langle U \\rangle \\right)^2 \\right]\n$$\n使用涨落 $\\delta U(t) = U(t) - \\langle U \\rangle$，我们可以将其重写为：\n$$\n\\text{Var}(\\overline{U}_T) = \\mathbb{E}\\left[ \\left( \\frac{1}{T} \\int_{0}^{T} \\delta U(t)\\, dt \\right)^2 \\right] = \\frac{1}{T^2} \\mathbb{E}\\left[ \\int_{0}^{T} \\int_{0}^{T} \\delta U(t) \\delta U(t')\\, dt\\, dt' \\right]\n$$\n通过应用 Fubini 定理交换期望和积分算子，我们得到：\n$$\n\\text{Var}(\\overline{U}_T) = \\frac{1}{T^2} \\int_{0}^{T} \\int_{0}^{T} \\mathbb{E}[ \\delta U(t) \\delta U(t') ]\\, dt\\, dt'\n$$\n积分内的项是自协方差函数，对于平稳过程，它仅取决于时间差 $\\tau = t - t'$：$C(t-t') = \\langle \\delta U(t) \\delta U(t') \\rangle$。\n$$\n\\text{Var}(\\overline{U}_T) = \\frac{1}{T^2} \\int_{0}^{T} \\int_{0}^{T} C(t - t')\\, dt\\, dt'\n$$\n这个在方形域上的二重积分可以被简化。通过变量代换或几何上评估积分，可以得到标准结果：\n$$\n\\int_{0}^{T} \\int_{0}^{T} C(t - t')\\, dt\\, dt' = 2 \\int_{0}^{T} (T-\\tau) C(\\tau)\\, d\\tau\n$$\n因此，方差变为：\n$$\n\\text{Var}(\\overline{U}_T) = \\frac{2}{T} \\int_{0}^{T} \\left(1 - \\frac{\\tau}{T}\\right) C(\\tau)\\, d\\tau\n$$\n对于长度为 $T$ 的轨迹，如果 $T$ 远大于相关性衰减的时间尺度（即，对于所有 $C(\\tau)$ 不可忽略的 $\\tau$，都有 $T \\gg \\tau$），则 $\\tau/T$ 项变得不重要，并且积分上限可以扩展到无穷大而不会产生实质性误差。这个近似得出：\n$$\n\\text{Var}(\\overline{U}_T) \\approx \\frac{2}{T} \\int_{0}^{\\infty} C(\\tau)\\, d\\tau\n$$\n使用定义 $C(\\tau) = C(0) \\rho(\\tau) = \\sigma^2 \\rho(\\tau)$ 和 $\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\rho(\\tau)\\, d\\tau$，我们发现：\n$$\n\\text{Var}(\\overline{U}_T) \\approx \\frac{2 \\sigma^2}{T} \\int_{0}^{\\infty} \\rho(\\tau)\\, d\\tau = \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{T}\n$$\n将此代入我们的精度要求 $\\text{Var}(\\overline{U}_T) \\le \\varepsilon^2$ 中：\n$$\n\\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{T} \\le \\varepsilon^2\n$$\n求解最小轨迹长度 $T$ 得到主要结果：\n$$\nT \\ge \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{\\varepsilon^2}\n$$\n因此，最小长度为 $T = \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{\\varepsilon^2}$。\n\n对于采样间隔为 $\\Delta t$ 的离散时间过程，类似的推导得出 $N$ 个样本均值的方差为 $\\text{Var}(\\overline{U}_N) \\approx \\frac{\\sigma^2}{N} \\left( 1 + 2 \\sum_{k=1}^{\\infty} \\rho_k \\right)$。使用问题中对以步数计的 IAT 的定义 $\\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k$，括号中的项是 $2 \\tau_{\\mathrm{int,steps}}$。因此，$\\text{Var}(\\overline{U}_N) \\approx \\frac{2 \\sigma^2 \\tau_{\\mathrm{int,steps}}}{N}$。总时间为 $T = N \\Delta t$。条件变为 $\\frac{2 \\sigma^2 \\tau_{\\mathrm{int,steps}}}{T / \\Delta t} \\le \\varepsilon^2$，可简化为 $T \\ge \\frac{2 \\sigma^2 (\\tau_{\\mathrm{int,steps}} \\Delta t)}{\\varepsilon^2}$。定义 $\\tau_{\\mathrm{int,time}} = \\tau_{\\mathrm{int,steps}} \\Delta t$，则 $T$ 的公式与连续情况下的形式相同。\n\n我们现在将这个主公式 $T = \\frac{2 \\sigma^2 \\tau_{\\mathrm{int}}}{\\varepsilon^2}$ 应用于每个测试用例。\n\n**案例 1：连续时间指数 ACF**\n- 给定：$\\rho(\\tau) = \\exp(-\\tau/\\tau_c)$，$\\tau_c = 2.5$ $\\mathrm{ps}$，$\\sigma^2 = 25$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 0.5$ $\\mathrm{kJ/mol}$。\n- 首先，我们计算 IAT：\n  $$ \\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\exp\\left(-\\frac{\\tau}{\\tau_c}\\right) d\\tau = \\left[ -\\tau_c \\exp\\left(-\\frac{\\tau}{\\tau_c}\\right) \\right]_0^\\infty = 0 - (-\\tau_c) = \\tau_c = 2.5 \\text{ ps} $$\n- 然后，我们计算最小轨迹长度 $T$：\n  $$ T_1 = \\frac{2 \\cdot 25 \\cdot 2.5}{(0.5)^2} = \\frac{125}{0.25} = 500.0 \\text{ ps} $$\n\n**案例 2：连续时间拉伸指数 ACF**\n- 给定：$\\rho(\\tau) = \\exp(-(\\tau/\\tau_c)^\\beta)$，$\\tau_c = 1.0$ $\\mathrm{ps}$，$\\beta = 0.5$，$\\sigma^2 = 9$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 0.3$ $\\mathrm{kJ/mol}$。\n- 我们通过变量代换 $x = (\\tau/\\tau_c)^\\beta$ 来计算 IAT：\n  $$ \\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\exp\\left(-\\left(\\frac{\\tau}{\\tau_c}\\right)^\\beta\\right) d\\tau = \\frac{\\tau_c}{\\beta} \\int_{0}^{\\infty} x^{\\frac{1}{\\beta}-1} e^{-x} dx = \\frac{\\tau_c}{\\beta} \\Gamma\\left(\\frac{1}{\\beta}\\right) $$\n- 当 $\\beta = 0.5$ 时，我们有 $1/\\beta = 2$。使用 $\\Gamma(2) = 1! = 1$：\n  $$ \\tau_{\\mathrm{int}} = \\frac{1.0}{0.5} \\Gamma(2) = 2 \\cdot 1 = 2.0 \\text{ ps} $$\n- 然后，我们计算 $T$：\n  $$ T_2 = \\frac{2 \\cdot 9 \\cdot 2.0}{(0.3)^2} = \\frac{36}{0.09} = 400.0 \\text{ ps} $$\n\n**案例 3：离散时间指数 ACF**\n- 给定：$\\rho_k = \\exp(-k \\Delta t/\\tau_c)$，$\\Delta t = 0.693147$ $\\mathrm{ps}$，$\\tau_c = 1.0$ $\\mathrm{ps}$，$\\sigma^2 = 4$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 0.2$ $\\mathrm{kJ/mol}$。\n- 我们计算 $\\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k$。该和是一个几何级数 $\\sum_{k=1}^{\\infty} r^k$，其中 $r = \\exp(-\\Delta t/\\tau_c) = \\exp(-0.693147) \\approx 0.5$。和为 $\\frac{r}{1-r} = \\frac{0.5}{1-0.5} = 1$。数值求和到 $10^{-12}$ 的公差将非常接近这个值。\n  $$ \\tau_{\\mathrm{int,steps}} = 0.5 + 1.0 = 1.5 $$\n- 以时间为单位的 IAT 是：\n  $$ \\tau_{\\mathrm{int,time}} = \\tau_{\\mathrm{int,steps}} \\cdot \\Delta t = 1.5 \\cdot 0.693147 \\text{ ps} \\approx 1.0397205 \\text{ ps} $$\n- 然后，我们计算 $T$：\n  $$ T_3 = \\frac{2 \\cdot 4 \\cdot 1.0397205}{(0.2)^2} = \\frac{8 \\cdot 1.0397205}{0.04} = 200 \\cdot 1.0397205 \\approx 207.944 \\text{ ps} $$\n\n**案例 4：离散时间不相关边缘情况**\n- 给定：对于 $k \\ge 1$, $\\rho_k = 0$，$\\Delta t = 0.5$ $\\mathrm{ps}$，$\\sigma^2 = 16$ $(\\mathrm{kJ/mol})^2$，$\\varepsilon = 1.0$ $\\mathrm{kJ/mol}$。\n- 我们计算 $\\tau_{\\mathrm{int,steps}}$：\n  $$ \\tau_{\\mathrm{int,steps}} = \\frac{1}{2} + \\sum_{k=1}^{\\infty} 0 = 0.5 $$\n- 这种情况代表一个完全不相关的过程（白噪声）。以时间为单位的 IAT 是：\n  $$ \\tau_{\\mathrm{int,time}} = \\tau_{\\mathrm{int,steps}} \\cdot \\Delta t = 0.5 \\cdot 0.5 \\text{ ps} = 0.25 \\text{ ps} $$\n- 然后，我们计算 $T$：\n  $$ T_4 = \\frac{2 \\cdot 16 \\cdot 0.25}{(1.0)^2} = 32 \\cdot 0.25 = 8.0 \\text{ ps} $$\n这对应于需要 $N = T/\\Delta t = 8.0/0.5 = 16$ 个样本，其均值的方差为 $\\sigma^2/N = 16/16 = 1 = \\varepsilon^2$，这与独立样本的预期相符。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Computes the minimal trajectory length T required for a given statistical tolerance\n    based on the integrated autocorrelation time of a stationary process.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Structure: (case_type, parameters_dict)\n    test_cases = [\n        ('continuous', {\n            'type': 'exponential', 'tau_c': 2.5, 'sigma_sq': 25.0, 'epsilon': 0.5\n        }),\n        ('continuous', {\n            'type': 'stretched_exponential', 'tau_c': 1.0, 'beta': 0.5, 'sigma_sq': 9.0, 'epsilon': 0.3\n        }),\n        ('discrete', {\n            'type': 'exponential', 'delta_t': 0.693147, 'tau_c': 1.0, 'sigma_sq': 4.0, 'epsilon': 0.2\n        }),\n        ('discrete', {\n            'type': 'uncorrelated', 'delta_t': 0.5, 'sigma_sq': 16.0, 'epsilon': 1.0\n        })\n    ]\n\n    results = []\n\n    for case_type, params in test_cases:\n        sigma_sq = params['sigma_sq']\n        epsilon = params['epsilon']\n\n        if case_type == 'continuous':\n            if params['type'] == 'exponential':\n                # For rho(tau) = exp(-tau/tau_c), the IAT is tau_c.\n                tau_int = params['tau_c']\n            elif params['type'] == 'stretched_exponential':\n                # For rho(tau) = exp(-(tau/tau_c)^beta), IAT = (tau_c/beta) * Gamma(1/beta)\n                tau_c = params['tau_c']\n                beta = params['beta']\n                tau_int = (tau_c / beta) * gamma(1.0 / beta)\n        \n        elif case_type == 'discrete':\n            delta_t = params['delta_t']\n            \n            sum_rho_k = 0.0\n            if params['type'] == 'exponential':\n                tau_c = params['tau_c']\n                k = 1\n                ratio = delta_t / tau_c\n                # Sum ACF terms until they are smaller than the given threshold.\n                while True:\n                    term = np.exp(-k * ratio)\n                    if term  1e-12:\n                        break\n                    sum_rho_k += term\n                    k += 1\n            elif params['type'] == 'uncorrelated':\n                # rho_k = 0 for k >= 1, so the sum is 0.\n                sum_rho_k = 0.0\n            \n            # IAT in units of steps\n            tau_int_steps = 0.5 + sum_rho_k\n            # IAT in units of time\n            tau_int = tau_int_steps * delta_t\n            \n        # The master formula for minimal trajectory length T\n        # T = (2 * sigma^2 * tau_int) / epsilon^2\n        T = (2.0 * sigma_sq * tau_int) / (epsilon**2)\n        results.append(T)\n\n    # Format the final output as a comma-separated list of floats\n    # rounded to 3 decimal places, enclosed in brackets.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "即使使用辛积分器，系统的遍历性也并非总能得到保证，数值误差有时会将系统限制在可及相空间的一个子集中。本练习将带你深入著名的费米-帕斯塔-乌拉姆（Fermi-Pasta-Ulam, FPU）问题，这是一个关于混沌和遍历性的经典案例。通过监测简正模能量的涨落，你将量化遍历性破缺的程度，并理解数值方法的选择如何深刻影响模拟所揭示的物理行为 。",
            "id": "3475273",
            "problem": "您的任务是为一维晶格模型中的声子动力学设计、实现并分析一种哈密顿量分裂方法，所有计算均在无量纲单位下进行。核心目标是检验由 Trotter 分解引起的时间离散化误差是否会产生额外的有效不变量，并通过一个基于相空间中可观测量方差的度量来量化这种伪常数的出现。您必须通过编写一个完整、可运行的程序来解决此问题，该程序将执行数值模拟，并以指定格式生成所要求的数值输出。\n\n考虑一个由 $N$ 个单位质量的相同粒子组成的周期性链，这些粒子通过最近邻非线性弹簧耦合，其特性由 Fermi-Pasta-Ulam (FPU) 势能描述。无量纲哈密顿量为\n$$\nH(\\mathbf{q},\\mathbf{p}) \\;=\\; \\sum_{i=0}^{N-1} \\frac{p_i^2}{2 m} \\;+\\; \\sum_{i=0}^{N-1} \\left[ \\frac{K}{2}\\left(q_{i+1}-q_i\\right)^2 \\;+\\; \\frac{\\alpha}{4}\\left(q_{i+1}-q_i\\right)^4 \\right],\n$$\n其中 $q_N \\equiv q_0$ 为周期性边界条件，$\\mathbf{q} = (q_0,\\dots,q_{N-1})$ 是位置，$\\mathbf{p} = (p_0,\\dots,p_{N-1})$ 是动量，$m$ 是质量，$K$ 是线性弹簧常数，$\\alpha$ 是非线性系数。所有量都必须在无量纲单位下处理。\n\n相空间演化遵循哈密顿方程，\n$$\n\\dot{q}_i \\,=\\, \\frac{\\partial H}{\\partial p_i} \\,=\\, \\frac{p_i}{m}, \\qquad\n\\dot{p}_i \\,=\\, -\\frac{\\partial H}{\\partial q_i} \\,=\\, f_i(\\mathbf{q}),\n$$\n其中力 $\\mathbf{f}(\\mathbf{q})$ 由势能的梯度确定。您必须使用算符分裂法，基于哈密顿量分解 $H = T(\\mathbf{p}) + V(\\mathbf{q})$ 来构建时间积分器，其中\n$$\nT(\\mathbf{p}) \\,=\\, \\sum_{i=0}^{N-1} \\frac{p_i^2}{2 m}, \\qquad\nV(\\mathbf{q}) \\,=\\, \\sum_{i=0}^{N-1} \\left[ \\frac{K}{2}\\left(q_{i+1}-q_i\\right)^2 \\;+\\; \\frac{\\alpha}{4}\\left(q_{i+1}-q_i\\right)^4 \\right].\n$$\n实现以下两种辛分裂格式：\n- Lie–Trotter (一阶) 分裂，在大小为 $\\Delta t$ 的单步上：对 $T$ 应用一个漂移映射，然后对 $V$ 应用一个踢动映射，\n$$\n\\text{漂移: } \\mathbf{q} \\leftarrow \\mathbf{q} + \\frac{\\Delta t}{m}\\,\\mathbf{p}, \\qquad\n\\text{踢动: } \\mathbf{p} \\leftarrow \\mathbf{p} + \\Delta t\\,\\mathbf{f}(\\mathbf{q}).\n$$\n- Strang (二阶) 分裂，在大小为 $\\Delta t$ 的单步上：应用半步踢动、完整漂移和半步踢动，\n$$\n\\mathbf{p} \\leftarrow \\mathbf{p} + \\frac{\\Delta t}{2}\\,\\mathbf{f}(\\mathbf{q}), \\quad\n\\mathbf{q} \\leftarrow \\mathbf{q} + \\frac{\\Delta t}{m}\\,\\mathbf{p}, \\quad\n\\mathbf{p} \\leftarrow \\mathbf{p} + \\frac{\\Delta t}{2}\\,\\mathbf{f}(\\mathbf{q}).\n$$\n\n定义线性化简正模能量作为诊断性可观测量。设 $\\mathcal{F}$ 为长度为 $N$ 的幺正离散傅里叶变换（使用使 Parseval 恒等式成立的归一化），并记 $\\mathbf{Q} = \\mathcal{F}\\mathbf{q}$ 和 $\\mathbf{P} = \\mathcal{F}\\mathbf{p}$。对于 $\\alpha = 0$ 的线性链，离散色散因子为\n$$\n\\lambda_k \\,=\\, 4 \\sin^2\\!\\left( \\frac{\\pi k}{N} \\right), \\quad k = 0,1,\\dots,N-1,\n$$\n波数为 $k$ 的线性简正模能量为\n$$\nE_k^{\\text{lin}}(\\mathbf{q},\\mathbf{p}) \\,=\\, \\frac{1}{2m}\\,\\lvert P_k \\rvert^2 \\;+\\; \\frac{K}{2}\\,\\lambda_k\\,\\lvert Q_k \\rvert^2.\n$$\n即使在 $\\alpha \\neq 0$ 的情况下，也使用此线性简正模能量作为相空间可观测量，以检测由离散化引起的伪不变量。具体来说，定义低频带能量\n$$\nI(t) \\,=\\, \\sum_{k \\in \\mathcal{S}} E_k^{\\text{lin}}(\\mathbf{q}(t),\\mathbf{p}(t)),\n$$\n其中 $\\mathcal{S} = \\{1,2,\\dots,k_c\\} \\cup \\{N-k_c,\\dots,N-1\\}$，对于一个选定的截断值 $k_c$。将模拟轨迹上的时间方差 $\\mathrm{Var}(I)$ 计算为\n$$\n\\mathrm{Var}(I) \\,=\\, \\frac{1}{M}\\sum_{j=1}^{M} \\left( I(t_j) - \\overline{I} \\right)^2, \\qquad\n\\overline{I} \\,=\\, \\frac{1}{M}\\sum_{j=1}^{M} I(t_j),\n$$\n其中 $M$ 是记录的时间样本数。在无量纲单位下，将 $\\mathrm{Var}(I)$ 报告为一个浮点数。\n\n初始化必须激发单个低频模式以探测能量交换：设置\n$$\nq_i(0) \\,=\\, A \\cos\\!\\left( \\frac{2\\pi k_0 i}{N} \\right), \\qquad p_i(0) \\,=\\, 0,\n$$\n其中振幅为 $A$，模式指数为 $k_0 = 1$。\n\n解释小 $\\mathrm{Var}(I)$ 与遍历性减弱之间的联系：在真正的非线性链中，能量应在各模式间交换，但如果积分器的 Trotter 误差引入了有效不变量，低频带能量 $I(t)$ 的变化会小于预期，从而使 $\\mathrm{Var}(I)$ 变小。反之，较大的 $\\mathrm{Var}(I)$ 表示对相空间的探索更充分，受伪不变量的约束更少。\n\n您必须实现两种分裂方法，对指定的测试套件模拟动力学过程，计算每种情况下的 $\\mathrm{Var}(I)$，并将结果以逗号分隔列表的形式单行输出，并用方括号括起来。\n\n所有量均为无量纲；因此，无需报告物理单位。除了单位圆上的三角函数参数外，不涉及角度，也不需要明确的单位。所有数值答案都以浮点数表示。\n\n测试套件：\n- 情况 1 (边缘情况：可积基线)：$N = 16$， $m = 1$， $K = 1$， $\\alpha = 0$， $\\Delta t = 0.04$， 步数 $M = 4000$， 方法 = Strang， 截断值 $k_c = 2$， 振幅 $A = 0.4$。\n- 情况 2 (正常路径非线性，小步长)：$N = 16$， $m = 1$， $K = 1$， $\\alpha = 0.5$， $\\Delta t = 0.01$， $M = 8000$， 方法 = Strang， $k_c = 2$， $A = 0.4$。\n- 情况 3 (非线性，较大步长)：$N = 16$， $m = 1$， $K = 1$， $\\alpha = 0.5$， $\\Delta t = 0.05$， $M = 8000$， 方法 = Strang， $k_c = 2$， $A = 0.4$。\n- 情况 4 (非线性，较大步长，低阶分裂)：$N = 16$， $m = 1$， $K = 1$， $\\alpha = 0.5$， $\\Delta t = 0.05$， $M = 8000$， 方法 = Lie–Trotter， $k_c = 2$， $A = 0.4$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是为情况 $i$ 计算的 $\\mathrm{Var}(I)$，以无量纲单位下的浮点数表示。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它提出了一个来自计算统计力学的、定义明确且具有科学依据的问题，具体涉及 Fermi-Pasta-Ulam (FPU) 晶格模型的模拟。所有参数、初始条件和分析方法都得到了清晰且一致的定义。\n\n问题的核心是研究数值积分格式如何影响非线性哈密顿系统的长时行为。FPU 模型是一个经典例子，其中最初置于单个低频模式中的能量，既可以保持局域化，也可以扩散到所有可用模式中，这一过程与遍历性有关。数值方法本身通过其离散化误差，可能会引入人为限制这种能量流动的伪（非物理的）守恒量。我们将通过测量线性简正模的低频带内所含能量的时间方差来量化这种效应。\n\n首先，我们定义系统的动力学。哈密顿量由下式给出\n$$\nH(\\mathbf{q},\\mathbf{p}) \\;=\\; T(\\mathbf{p}) + V(\\mathbf{q})\n$$\n其中 $T(\\mathbf{p})$ 是动能，$V(\\mathbf{q})$ 是势能：\n$$\nT(\\mathbf{p}) \\,=\\, \\sum_{i=0}^{N-1} \\frac{p_i^2}{2 m}, \\qquad\nV(\\mathbf{q}) \\,=\\, \\sum_{i=0}^{N-1} \\left[ \\frac{K}{2}\\left(q_{i+1}-q_i\\right)^2 \\;+\\; \\frac{\\alpha}{4}\\left(q_{i+1}-q_i\\right)^4 \\right]\n$$\n运动方程为哈密顿方程：\n$$\n\\dot{q}_i \\,=\\, \\frac{\\partial H}{\\partial p_i} \\,=\\, \\frac{p_i}{m}, \\qquad\n\\dot{p}_i \\,=\\, -\\frac{\\partial H}{\\partial q_i} \\,=\\, f_i(\\mathbf{q})\n$$\n粒子 $i$ 上的力 $f_i$ 由势能导出。一个粒子 $i$ 受到其邻居 $i-1$ 和 $i+1$ 的影响。该力为\n$$\nf_i(\\mathbf{q}) = -\\frac{\\partial V}{\\partial q_i} = - \\left( \\frac{\\partial V_{i-1}}{\\partial q_i} + \\frac{\\partial V_i}{\\partial q_i} \\right)\n$$\n其中 $V_j$ 是粒子 $j$ 和 $j+1$ 之间弹簧的势能项。令 $\\Delta q_j = q_{j+1} - q_j$。单个弹簧的势能为 $U(x) = \\frac{K}{2}x^2 + \\frac{\\alpha}{4}x^4$，其导数为 $U'(x) = Kx + \\alpha x^3$。粒子 $i$ 上的力可以表示为：\n$$\nf_i(\\mathbf{q}) = U'(\\Delta q_i) - U'(\\Delta q_{i-1}) = \\left[ K(q_{i+1}-q_i) + \\alpha(q_{i+1}-q_i)^3 \\right] - \\left[ K(q_i-q_{i-1}) + \\alpha(q_i-q_{i-1})^3 \\right]\n$$\n这些方程通过算符分裂法进行数值求解。与 Liouvillian $L_H = \\{\\cdot, H\\}$ 相关的时间演化算符 $e^{\\Delta t L_H}$ 通过将 $L_H$ 分裂为 $L_T$ 和 $L_V$ 来近似。$T$ 和 $V$ 的精确流分别被称为漂移和踢动。\nLie–Trotter 方法是一阶对称分裂：\n$$\n\\mathbf{q}(t+\\Delta t) = \\mathbf{q}(t) + \\frac{\\Delta t}{m}\\mathbf{p}(t) \\quad (\\text{漂移}) \\\\\n\\mathbf{p}(t+\\Delta t) = \\mathbf{p}(t) + \\Delta t\\,\\mathbf{f}(\\mathbf{q}(t+\\Delta t)) \\quad (\\text{踢动})\n$$\nStrang 分裂方法是一种二阶对称组合：\n$$\n\\mathbf{p}(t+\\Delta t/2) = \\mathbf{p}(t) + \\frac{\\Delta t}{2}\\,\\mathbf{f}(\\mathbf{q}(t)) \\quad (\\text{半步踢动}) \\\\\n\\mathbf{q}(t+\\Delta t) = \\mathbf{q}(t) + \\frac{\\Delta t}{m}\\,\\mathbf{p}(t+\\Delta t/2) \\quad (\\text{完整漂移}) \\\\\n\\mathbf{p}(t+\\Delta t) = \\mathbf{p}(t+\\Delta t/2) + \\frac{\\Delta t}{2}\\,\\mathbf{f}(\\mathbf{q}(t+\\Delta t)) \\quad (\\text{半步踢动})\n$$\n这些积分器是辛的，意味着它们精确地保持一个与原始哈密顿量接近的“影子”哈密顿量。影子哈密顿量与真实哈密顿量的偏差取决于时间步长 $\\Delta t$ 和方法的阶数。这种偏差可能会引入伪运动不变量。\n\n为了诊断系统的遍历性，我们使用相应线性系统（$\\alpha=0$）的简正模。模空间坐标通过幺正离散傅里叶变换获得，即 $\\mathbf{Q} = \\mathcal{F}\\mathbf{q}$ 和 $\\mathbf{P} = \\mathcal{F}\\mathbf{p}$。幺正归一化确保 Parseval 恒等式成立，即 $\\sum_i |q_i|^2 = \\sum_k |Q_k|^2$。模式 $k$ 的线性简正模能量为\n$$\nE_k^{\\text{lin}} \\,=\\, \\frac{1}{2m}\\,\\lvert P_k \\rvert^2 \\;+\\; \\frac{K}{2}\\,\\lambda_k\\,\\lvert Q_k \\rvert^2, \\quad \\text{其中} \\quad \\lambda_k \\,=\\, 4 \\sin^2\\!\\left( \\frac{\\pi k}{N} \\right).\n$$\n虽然在线性情况（$\\alpha=0$）下这些模式是解耦的且其能量是守恒的，但在 FPU 模型中，它们通过 $\\alpha$ 项耦合，从而允许能量交换。我们监测一个低波数带内的能量 $I(t) = \\sum_{k \\in \\mathcal{S}} E_k^{\\text{lin}}$，其中 $\\mathcal{S} = \\{1, \\dots, k_c\\} \\cup \\{N-k_c, \\dots, N-1\\}$。在一个真正的遍历系统中，$I(t)$ 应该会随着能量流入和流出频带 $\\mathcal{S}$ 而随时间显著波动。在一个受伪不变量约束的系统中，这种流动受到限制，$I(t)$ 保持得更为恒定。时间方差 $\\mathrm{Var}(I)$ 量化了这些波动。较小的 $\\mathrm{Var}(I)$ 表示更强的伪守恒性和减弱的遍历性。\n\n对于每个测试用例，算法流程如下：\n1. 根据指定的单模式激发初始化位置和动量数组 $\\mathbf{q}(0)$ 和 $\\mathbf{p}(0)$：$q_i(0) = A \\cos(2\\pi k_0 i / N)$，其中 $k_0 = 1$，以及 $p_i(0)=0$。\n2. 使用指定的积分器（Lie-Trotter 或 Strang）模拟系统 $M$ 个时间步。\n3. 在每个时间步 $t_j = j\\Delta t$，计算诊断量 $I(t_j)$。这包括：\n    a. 使用 `ortho` 归一化计算傅里叶变换 $\\mathbf{Q}(t_j)$ 和 $\\mathbf{P}(t_j)$。\n    b. 计算所有 $k$ 的线性模式能量 $E_k^{\\text{lin}}(t_j)$。\n    c. 对指定集合 $\\mathcal{S}$ 中的 $k$ 的能量求和以得到 $I(t_j)$。\n4. 完成模拟后，计算存储的时间序列 $\\{I(t_j)\\}_{j=1}^M$ 的方差。\n\n此过程应用于四个测试用例中的每一个，并报告所得的方差。在情况 1 ($\\alpha=0$) 中，我们预期 $\\mathrm{Var}(I) \\approx 0$，因为线性模式能量是精确守恒的。对于非线性情况，我们预期方差能反映伪守恒的程度。一个阶数较低的方法（Lie-Trotter）或一个较大的时间步长 $\\Delta t$ 通常会导致影子哈密顿量有更大的偏差，这会增强伪不变量，从而导致更小的方差。",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Main function to run the FPU simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: integrable baseline\n        {'N': 16, 'm': 1, 'K': 1, 'alpha': 0, 'dt': 0.04, 'M': 4000, \n         'method': 'Strang', 'k_c': 2, 'A': 0.4, 'k0': 1},\n        # Case 2: happy path nonlinear, small step\n        {'N': 16, 'm': 1, 'K': 1, 'alpha': 0.5, 'dt': 0.01, 'M': 8000, \n         'method': 'Strang', 'k_c': 2, 'A': 0.4, 'k0': 1},\n        # Case 3: nonlinear, larger step\n        {'N': 16, 'm': 1, 'K': 1, 'alpha': 0.5, 'dt': 0.05, 'M': 8000, \n         'method': 'Strang', 'k_c': 2, 'A': 0.4, 'k0': 1},\n        # Case 4: nonlinear, larger step, lower order splitting\n        {'N': 16, 'm': 1, 'K': 1, 'alpha': 0.5, 'dt': 0.05, 'M': 8000, \n         'method': 'Lie-Trotter', 'k_c': 2, 'A': 0.4, 'k0': 1},\n    ]\n\n    results = []\n    for params in test_cases:\n        var_I = run_simulation(**params)\n        results.append(var_I)\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef calculate_force(q, K, alpha):\n    \"\"\"\n    Calculates the force on each particle in the FPU chain.\n    f_i = (K(q_{i+1}-q_i) + alpha(q_{i+1}-q_i)^3) - (K(q_i-q_{i-1}) + alpha(q_i-q_{i-1})^3)\n    \"\"\"\n    # Difference with the particle to the right (i+1)\n    delta_q_plus = np.roll(q, -1) - q\n    # Difference with the particle to the left (i-1)\n    delta_q_minus = q - np.roll(q, 1)\n\n    # Force contribution from the right and left springs\n    force_plus = K * delta_q_plus + alpha * np.power(delta_q_plus, 3)\n    force_minus = K * delta_q_minus + alpha * np.power(delta_q_minus, 3)\n\n    return force_plus - force_minus\n\ndef calculate_band_energy(q, p, N, m, K, k_c):\n    \"\"\"\n    Calculates the low-frequency band energy diagnostic I(t).\n    \"\"\"\n    # Unitary Discrete Fourier Transform (norm='ortho')\n    Q = scipy.fft.fft(q, norm='ortho')\n    P = scipy.fft.fft(p, norm='ortho')\n    \n    k_vals = np.arange(N)\n    \n    # Dispersion factor\n    lambda_k = 4 * np.sin(np.pi * k_vals / N)**2\n    \n    # Linear normal mode energies\n    E_k_lin = (0.5 / m) * np.abs(P)**2 + (0.5 * K) * lambda_k * np.abs(Q)**2\n    \n    # Define the set S for low-frequency modes\n    # S = {1, 2, ..., k_c} U {N-k_c, ..., N-1}\n    indices_low = np.arange(1, k_c + 1)\n    indices_high = np.arange(N - k_c, N)\n    s_indices = np.concatenate((indices_low, indices_high))\n    \n    # Sum energies over the band\n    I_t = np.sum(E_k_lin[s_indices])\n    \n    return I_t\n\ndef run_simulation(N, m, K, alpha, dt, M, method, k_c, A, k0):\n    \"\"\"\n    Runs a single FPU simulation and returns the variance of the band energy.\n    \"\"\"\n    # Initialization\n    i_vals = np.arange(N)\n    q = A * np.cos(2 * np.pi * k0 * i_vals / N)\n    p = np.zeros(N)\n    \n    I_series = np.zeros(M)\n\n    for j in range(M):\n        # Apply the selected integration scheme\n        if method == 'Lie-Trotter':\n            # Drift\n            q = q + (dt / m) * p\n            # Kick\n            force = calculate_force(q, K, alpha)\n            p = p + dt * force\n        elif method == 'Strang':\n            # Half-kick\n            force1 = calculate_force(q, K, alpha)\n            p_half = p + (dt / 2.0) * force1\n            # Full Drift\n            q = q + (dt / m) * p_half\n            # Half-kick\n            force2 = calculate_force(q, K, alpha)\n            p = p_half + (dt / 2.0) * force2\n\n        # Record the diagnostic quantity\n        I_series[j] = calculate_band_energy(q, p, N, m, K, k_c)\n        \n    # Calculate the time variance of the band energy\n    # np.var computes population variance by default, matching the problem spec\n    var_I = np.var(I_series)\n    \n    return var_I\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "为了在长时间尺度上正确地探索相空间，用于积分运动方程的数值算法必须具备某些特殊性质。本练习聚焦于辛性（symplecticity），这是像速度-Verlet算法这类几何积分器的一个关键特性，它能够保持相空间的体积不变。通过数值计算积分器映射的雅可比行列式，你将具体理解“结构保持”算法的含义，并验证为何辛积分器是分子动力学模拟的黄金标准 。",
            "id": "3475280",
            "problem": "考虑一个一维Lennard–Jones二聚体，由两个质量为 $m$ 的相同粒子组成，它们通过Lennard–Jones势 $U(r) = 4\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right]$ 相互作用，其中 $r = |x_1 - x_2|$，$x_1$ 和 $x_2$ 是粒子位置，粒子的速度分别为 $v_1$ 和 $v_2$。设该系统在约化单位制下描述，其中 $m = 1$，$\\varepsilon = 1$，$\\sigma = 1$。其哈密顿量为 $H = \\dfrac{p_1^2}{2m} + \\dfrac{p_2^2}{2m} + U(|x_1 - x_2|)$，正则变量为 $(x_1,x_2,p_1,p_2)$，且 $p_i = m v_i$。\n\n一个时间离散映射 $T_{\\Delta t}$ 由速度Verlet积分器对状态向量 $y = (x_1,x_2,v_1,v_2)$ 应用一步来定义：\n- 第一步半踢：$v_i^{n+1/2} = v_i^n + \\dfrac{\\Delta t}{2} a_i(x_1^n,x_2^n)$。\n- 漂移：$x_i^{n+1} = x_i^n + \\Delta t \\, v_i^{n+1/2}$。\n- 第二步半踢：$v_i^{n+1} = v_i^{n+1/2} + \\dfrac{\\Delta t}{2} a_i(x_1^{n+1},x_2^{n+1})$。\n\n这里 $a_i = F_i/m$，$F_i$ 是作用在粒子 $i$ 上的Lennard–Jones力，由 $U(r)$ 通过 $F_1 = -\\dfrac{dU}{dr} \\dfrac{x_1 - x_2}{r}$ 和 $F_2 = -F_1$ 计算得出。\n\n您的任务是通过中心有限差分法，在固定的参考状态 $y$ 下，数值估算雅可比矩阵 $J(\\Delta t) = \\dfrac{\\partial T_{\\Delta t}}{\\partial y}$，并计算其行列式 $\\det J(\\Delta t)$。由于速度Verlet映射是辛的，其真实的行列式值恰好为 $1$。然而，由于有限差分近似中的截断误差，您的数值估算值会偏离 $1$。使用中心差分扰动幅度 $\\varepsilon_{\\text{fd}} = c \\, \\Delta t$（其中 $c = 10^{-2}$），独立地应用于 $y$ 的每个分量，以近似雅可比矩阵的各列：\n$$\nJ_{\\cdot,i}(\\Delta t) \\approx \\frac{T_{\\Delta t}(y + \\varepsilon_{\\text{fd}} e_i) - T_{\\Delta t}(y - \\varepsilon_{\\text{fd}} e_i)}{2 \\, \\varepsilon_{\\text{fd}}}, \\quad i \\in \\{1,2,3,4\\},\n$$\n其中 $e_i$ 是 $\\mathbb{R}^4$ 中的第 $i$ 个单位向量。定义绝对偏差 $\\delta(\\Delta t) = \\left|\\det J(\\Delta t) - 1\\right|$。\n\n实现一个完整、可运行的程序，该程序：\n1. 在约化单位制（$m = 1$，$\\varepsilon = 1$，$\\sigma = 1$）下，对两个粒子使用一维速度Verlet映射 $T_{\\Delta t}$ 和Lennard–Jones力。\n2. 对于每个指定的时间步长 $\\Delta t$，使用中心差分模板和 $\\varepsilon_{\\text{fd}} = c \\, \\Delta t$（其中 $c = 10^{-2}$），在固定的参考状态 $y = (x_1, x_2, v_1, v_2) = (0, 1.5, 0.1, -0.05)$ 下计算有限差分雅可比矩阵。\n3. 为提供的测试集返回绝对偏差 $\\delta(\\Delta t)$ 的列表。\n\n测试集：\n- 使用时间步长 $\\Delta t \\in \\{0.001, 0.002, 0.005, 0.01, 0.02\\}$。\n- 使用有限差分缩放因子 $c = 10^{-2}$，使得对每个 $\\Delta t$ 都有 $\\varepsilon_{\\text{fd}} = c \\, \\Delta t$。\n- 使用固定的初始状态 $y = (0, 1.5, 0.1, -0.05)$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，即形如 $[r_1,r_2,r_3,r_4,r_5]$，其中 $r_k$ 是测试集中第 $k$ 个时间步长对应的 $\\delta(\\Delta t_k)$ 的浮点数值。\n- 所有输出必须是无单位的实数（浮点数）。",
            "solution": "该问题是有效的。这是一个适定、科学上合理的计算物理问题，旨在探究哈密顿系统数值积分器的性质。\n\n核心任务是数值评估速度Verlet积分算法的辛性。辛映射 $T$（描述哈密顿系统在相空间中的演化）的一个关键性质是它保持相空间体积。这在数学上表示为映射的雅可比矩阵 $J$ 的行列式恰好为1：$\\det(J) = 1$。速度Verlet算法是一种著名的几何积分器，其设计就是为了保证辛性。然而，题目要求我们不是解析地计算其雅可比矩阵，而是使用有限差分近似进行数值计算。这会引入截断误差，导致我们计算出的行列式会偏离 $1$。问题要求我们对一个特定的系统和一组时间步长 $\\Delta t$，计算这个偏差 $\\delta(\\Delta t) = |\\det J(\\Delta t) - 1|$。\n\n首先，我们定义物理系统。它由两个质量为 $m=1$ 的相同粒子在一维空间中组成，通过Lennard-Jones (LJ) 势相互作用。在指定的约化单位制下，其中 $\\varepsilon=1$ 且 $\\sigma=1$，势能为：\n$$\nU(r) = 4\\left(r^{-12} - r^{-6}\\right)\n$$\n其中 $r = |x_1 - x_2|$ 是粒子在位置 $x_1$ 和 $x_2$ 之间的距离。系统的哈密顿量为 $H = \\frac{p_1^2}{2m} + \\frac{p_2^2}{2m} + U(|x_1 - x_2|)$。运动方程由牛顿第二定律 $m a_i = F_i$ 给出，其中 $a_i$ 是粒子 $i$ 的加速度，$F_i$ 是作用在其上的力。由于 $m=1$，我们有 $a_i = F_i$。力是势的负梯度。对于粒子1，力由 $F_1 = -\\frac{dU}{dr} \\frac{x_1 - x_2}{r}$ 给出。根据牛顿第三定律，作用在粒子2上的力是 $F_2 = -F_1$。\n\nLJ势对 $r$ 的导数为：\n$$\n\\frac{dU}{dr} = 4\\left(-12r^{-13} + 6r^{-7}\\right) = \\frac{24}{r}\\left(-2r^{-12} + r^{-6}\\right)\n$$\n这个表达式使我们能够计算任意给定粒子位置对 $(x_1, x_2)$ 的力和加速度。\n\n接下来，我们使用速度Verlet积分器来形式化时间演化。系统的状态由一个4维向量 $y = (x_1, x_2, v_1, v_2)$ 描述。一个持续时间为 $\\Delta t$ 的单次积分步长将时间 $t_n$ 的状态 $y^n$ 映射到时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $y^{n+1}$。这个映射记为 $T_{\\Delta t}$，因此 $y^{n+1} = T_{\\Delta t}(y^n)$。该算法分三步进行：\n1.  计算中间步长的速度：对于 $i \\in \\{1,2\\}$，$v_i^{n+1/2} = v_i^n + \\frac{\\Delta t}{2} a_i(x_1^n, x_2^n)$。\n2.  使用这些中间步长的速度更新位置：对于 $i \\in \\{1,2\\}$，$x_i^{n+1} = x_i^n + \\Delta t \\, v_i^{n+1/2}$。\n3.  计算新位置的加速度 $a_i(x_1^{n+1}, x_2^{n+1})$，并完成速度更新：对于 $i \\in \\{1,2\\}$，$v_i^{n+1} = v_i^{n+1/2} + \\frac{\\Delta t}{2} a_i(x_1^{n+1}, x_2^{n+1})$。\n\n问题的核心部分是计算该映射的雅可比矩阵 $J(\\Delta t)$，在特定的参考状态 $y = (0, 1.5, 0.1, -0.05)$ 下进行评估。雅可比矩阵是一个 $4 \\times 4$ 的矩阵，其元素为 $J_{ij} = \\frac{\\partial (T_{\\Delta t}(y))_i}{\\partial y_j}$。我们将使用中心有限差分公式来近似雅可比矩阵的每一列。对于第 $j$ 列（$j \\in \\{1,2,3,4\\}$）：\n$$\nJ_{\\cdot,j}(\\Delta t) \\approx \\frac{T_{\\Delta t}(y + \\varepsilon_{\\text{fd}} e_j) - T_{\\Delta t}(y - \\varepsilon_{\\text{fd}} e_j)}{2 \\varepsilon_{\\text{fd}}}\n$$\n这里，$e_j$ 是 $\\mathbb{R}^4$ 中的第 $j$ 个标准基向量（例如，$e_1 = (1,0,0,0)$），$\\varepsilon_{\\text{fd}}$ 是一个小的扰动幅度。问题指定这个幅度应与时间步长成比例：$\\varepsilon_{\\text{fd}} = c \\, \\Delta t$，其中 $c = 10^{-2}$。\n\n总的算法将是：\n1.  对于给定测试集 $\\{0.001, 0.002, 0.005, 0.01, 0.02\\}$ 中的每个时间步长 $\\Delta t$。\n2.  设置有限差分扰动 $\\varepsilon_{\\text{fd}} = c \\, \\Delta t$。\n3.  初始化一个空的 $4 \\times 4$ 矩阵 $J$。\n4.  对于从 $1$ 到 $4$ 的每个列索引 $j$：\n    a. 定义扰动后的初始状态 $y^+ = y + \\varepsilon_{\\text{fd}} e_j$ 和 $y^- = y - \\varepsilon_{\\text{fd}} e_j$。\n    b. 使用速度Verlet映射将 $y^+$ 和 $y^-$ 演化一个时间步长，得到 $y'^+ = T_{\\Delta t}(y^+)$ 和 $y'^- = T_{\\Delta t}(y^-)$。\n    c. 将雅可比矩阵的第 $j$ 列计算为 $(y'^+ - y'^-) / (2 \\varepsilon_{\\text{fd}})$。\n5.  构造完整的矩阵 $J$ 后，计算其行列式 $\\det J(\\Delta t)$。\n6.  计算绝对偏差 $\\delta(\\Delta t) = |\\det J(\\Delta t) - 1|$。\n7.  收集所有指定的 $\\Delta t$ 对应的 $\\delta(\\Delta t)$ 值。\n\n此过程将通过一个Python程序实现，使用 `numpy` 库进行高效的向量和矩阵运算，包括行列式计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the deviation of the numerically computed Jacobian determinant of the\n    velocity-Verlet map from 1 for a 1D Lennard-Jones dimer.\n    \"\"\"\n\n    # Reduced unit constants from the problem statement\n    M = 1.0\n    EPSILON = 1.0\n    SIGMA = 1.0\n    \n    # Finite-difference scaling factor\n    C_FD = 1e-2\n\n    # Fixed reference state y = (x1, x2, v1, v2)\n    y_ref = np.array([0.0, 1.5, 0.1, -0.05])\n    \n    # Test suite of time steps\n    test_cases = [0.001, 0.002, 0.005, 0.01, 0.02]\n\n    def calculate_accelerations(positions):\n        \"\"\"\n        Computes the accelerations of the two particles based on their positions.\n        \n        Args:\n            positions (np.ndarray): A 2-element array [x1, x2].\n            \n        Returns:\n            np.ndarray: A 2-element array [a1, a2].\n        \"\"\"\n        x1, x2 = positions[0], positions[1]\n        r_vec = x1 - x2\n        r = abs(r_vec)\n\n        # Avoid division by zero, though unlikely with the LJ potential\n        if r == 0.0:\n            return np.array([0.0, 0.0])\n\n        r_inv = SIGMA / r\n        r_inv6 = r_inv**6\n        r_inv12 = r_inv6**2\n\n        # Force calculation based on F = -dU/dr * (x1-x2)/r\n        # dU/dr = (24 * EPSILON / r) * (-2 * (SIGMA/r)**12 + (SIGMA/r)**6)\n        dU_dr = (24.0 * EPSILON / r) * (-2.0 * r_inv12 + r_inv6)\n        \n        # In 1D, (x1-x2)/r is just sign(x1-x2)\n        force_on_1 = -dU_dr * np.sign(r_vec) if r_vec != 0 else 0\n\n        # Acceleration a = F/m\n        accel_1 = force_on_1 / M\n        accel_2 = -accel_1  # By Newton's third law\n\n        return np.array([accel_1, accel_2])\n\n    def velocity_verlet_step(y, dt):\n        \"\"\"\n        Performs one step of the velocity-Verlet integration.\n        \n        Args:\n            y (np.ndarray): The 4-element state vector [x1, x2, v1, v2].\n            dt (float): The time step.\n            \n        Returns:\n            np.ndarray: The new state vector after one time step.\n        \"\"\"\n        pos_n = y[0:2]\n        vel_n = y[2:4]\n\n        # First half-kick\n        accel_n = calculate_accelerations(pos_n)\n        vel_half = vel_n + 0.5 * dt * accel_n\n\n        # Drift\n        pos_new = pos_n + dt * vel_half\n\n        # Second half-kick\n        accel_new = calculate_accelerations(pos_new)\n        vel_new = vel_half + 0.5 * dt * accel_new\n\n        return np.concatenate((pos_new, vel_new))\n\n    results = []\n    for dt in test_cases:\n        eps_fd = C_FD * dt\n        jacobian = np.zeros((4, 4))\n        \n        for i in range(4):\n            # Create perturbation vectors\n            perturbation = np.zeros(4)\n            perturbation[i] = eps_fd\n\n            y_plus = y_ref + perturbation\n            y_minus = y_ref - perturbation\n\n            # Evolve perturbed states\n            y_next_plus = velocity_verlet_step(y_plus, dt)\n            y_next_minus = velocity_verlet_step(y_minus, dt)\n\n            # Compute column of the Jacobian using central differences\n            jacobian_col = (y_next_plus - y_next_minus) / (2.0 * eps_fd)\n            jacobian[:, i] = jacobian_col\n\n        # Calculate determinant and its deviation from 1\n        det_J = np.linalg.det(jacobian)\n        deviation = abs(det_J - 1.0)\n        results.append(deviation)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}