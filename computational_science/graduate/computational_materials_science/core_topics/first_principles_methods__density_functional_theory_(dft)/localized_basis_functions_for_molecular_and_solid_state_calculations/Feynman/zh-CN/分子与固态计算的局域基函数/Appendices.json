{
    "hands_on_practices": [
        {
            "introduction": "在量子化学计算中，高斯型轨道（GTOs）因其能够解析计算多中心积分而成为首选。然而，斯莱特型轨道（STOs）能更准确地描述原子附近的电子波函数及其尖峰（cusp）行为。这项实践将指导你通过最小二乘法，用一组高斯基函数构建一个收缩基函数，以最佳方式近似一个给定的斯莱特型轨道。这个练习不仅揭示了现代基组构建的核心思想，也提供了处理非正交基函数和求解线性方程组的宝贵实践经验。",
            "id": "3461808",
            "problem": "要求您形式化、实现并测试一种策略，该策略利用原初高斯函数构建收缩高斯基组，以从第一性原理出发近似基态类氢轨道的斯莱特型轨道。研究将在三维空间中进行，使用 $\\mathbb{R}^3$ 上的平方可积函数以及平方可积函数希尔伯特空间的常规内积。目标是使积分范数误差达到一个预设的界限。\n\n给定一个指数为 $\\zeta$ 的归一化 $1s$ 斯莱特型轨道 (Slater Type Orbital, STO)，其由实空间函数 $\\phi_{\\zeta}(\\mathbf{r}) = N_{\\mathrm{STO}} \\exp(-\\zeta r)$ 定义，其中 $r = \\|\\mathbf{r}\\|$，归一化常数 $N_{\\mathrm{STO}}$ 的选择使得 $\\int_{\\mathbb{R}^3} |\\phi_{\\zeta}(\\mathbf{r})|^2 \\, d^3\\mathbf{r} = 1$。再给定一族归一化的原初 $s$ 型高斯型轨道 (Gaussian Type Orbitals, GTO) $g_{\\alpha}(\\mathbf{r}) = N_{\\mathrm{GTO}} \\exp(-\\alpha r^2)$，其高斯指数 $\\alpha > 0$，归一化常数 $N_{\\mathrm{GTO}}$ 的选择使得 $\\int_{\\mathbb{R}^3} |g_{\\alpha}(\\mathbf{r})|^2 \\, d^3\\mathbf{r} = 1$。考虑一个收缩高斯函数\n$$\n\\chi_{n}(\\mathbf{r}) = \\sum_{i=1}^{n} c_i \\, g_{\\alpha_i}(\\mathbf{r}),\n$$\n其中 $\\{\\alpha_i\\}_{i=1}^n$ 是互不相同且大于零的原初指数，$\\{c_i\\}_{i=1}^n$ 是实数收缩系数。\n\n您的任务是：\n- 仅从 $L^2(\\mathbb{R}^3)$ 上的内积定义、$\\phi_{\\zeta}$ 和 $g_{\\alpha}$ 的归一化条件以及高斯积分的标准性质出发，推导出能够使平方 $L^2$ 误差最小化的系数集 $\\{c_i\\}_{i=1}^n$ 所满足的条件。\n$$\n\\left\\| \\phi_{\\zeta} - \\chi_{n} \\right\\|_{2}^2 = \\int_{\\mathbb{R}^3} \\left| \\phi_{\\zeta}(\\mathbf{r}) - \\sum_{i=1}^{n} c_i g_{\\alpha_i}(\\mathbf{r}) \\right|^2 \\, d^3\\mathbf{r}.\n$$\n除各自归一化外，不要假设 $g_{\\alpha_i}$ 具有任何特殊的正交性；您的推导必须仅使用内积定义以及高斯积分和指数积分的基本微积分恒等式。\n- 实现一个算法，对于给定的由 $\\alpha_i = \\alpha_0 \\beta^{i-1}$（其中 $\\alpha_0 > 0$ 和 $\\beta > 1$）定义的均匀回火原初指数集，该算法通过递增 $n$（取均匀回火列表中的前 $n$ 个指数）进行搜索，以找到使最优收缩函数 $\\chi_n$ 满足积分范数误差预设容差 $\\varepsilon$ 的最小 $n$，即：\n$$\n\\left\\| \\phi_{\\zeta} - \\chi_{n} \\right\\|_{2} \\le \\varepsilon.\n$$\n- 您的实现必须依赖于第一性原理推导得出的所有必需重叠积分和其他积分的解析表达式，并且必须使用数值稳定的线性代数程序来计算最优系数。如果重叠矩阵系统是病态的，则引入一个极小的 Tikhonov 正则化项，该项不会实质性地影响最小值点，但能稳定求解过程。\n\n测试输入必须作为一组测试用例硬编码在程序中。对于每个测试用例，给定 $\\zeta$、$\\alpha_0$、$\\beta$、定义候选池 $\\{\\alpha_1,\\dots,\\alpha_{N_{\\max}}\\}$ 的原初函数最大数量 $N_{\\max}$ 以及目标容差 $\\varepsilon$。程序必须为每个测试用例返回一个数对 $[n^\\star, e^\\star]$，其中 $n^\\star$ 是找到的最小收缩长度（上界为 $N_{\\max}$），$e^\\star$ 是该 $n^\\star$ 所达到的积分范数误差。\n\n测试套件：\n- 情况 A (正常路径): $\\zeta = $ $1.0$, $\\alpha_0 = $ $0.01$, $\\beta = $ $2.5$, $N_{\\max} = $ $12$, $\\varepsilon = $ $1.0\\times 10^{-4}$。\n- 情况 B (弥散轨道): $\\zeta = $ $0.25$, $\\alpha_0 = $ $0.0005$, $\\beta = $ $2.5$, $N_{\\max} = $ $14$, $\\varepsilon = $ $4.0\\times 10^{-4}$。\n- 情况 C (紧凑轨道): $\\zeta = $ $4.0$, $\\alpha_0 = $ $0.02$, $\\beta = $ $3.0$, $N_{\\max} = $ $14$, $\\varepsilon = $ $2.0\\times 10^{-4}$。\n- 情况 D (边界紧容差): $\\zeta = $ $1.0$, $\\alpha_0 = $ $0.01$, $\\beta = $ $2.5$, $N_{\\max} = $ $10$, $\\varepsilon = $ $1.0\\times 10^{-8}$。\n\n所有量均为无量纲量，必须照此处理。不需要物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的四个数对的逗号分隔列表。每个数对本身必须写成一个双元素列表，包含最小整数 $n^\\star$ 和浮点误差 $e^\\star$。对于 $e^\\star$，请使用至少有 $8$ 位有效数字的科学记数法。例如，包含两个假设用例的输出行可能如下所示：\n$$\n[[n_1,e_1],[n_2,e_2],[n_3,e_3],[n_4,e_4]].\n$$\n您的程序不得读取任何输入，并且除了必需的单行输出外，不得打印任何其他文本。",
            "solution": "所提出的问题要求对一种方法进行形式推导和实现，该方法使用高斯型轨道 (GTOs) 的线性组合（即所谓的收缩高斯函数）来近似斯莱特型轨道 (STO)。其目标是最小化目标 STO 与收缩 GTO 近似之间差值的平方 $L^2$ 范数。\n\n该问题被验证为是合理的。它在科学上基于量子化学基组设计的原理，在希尔伯特空间中被恰当地表述为一个线性最小二乘问题，并且客观地陈述了解决该问题所需的所有数据。\n\n在此，我们从第一性原理推导出一个完整的解。\n\n设归一化的 $1s$ STO 为 $\\phi_{\\zeta}(\\mathbf{r})$，其指数为 $\\zeta>0$；归一化的原初 $s$ 型 GTO 集为 $\\{g_{\\alpha_i}(\\mathbf{r})\\}_{i=1}^n$，其指数为 $\\{\\alpha_i > 0\\}$。收缩高斯轨道由 $\\chi_n(\\mathbf{r}) = \\sum_{i=1}^{n} c_i g_{\\alpha_i}(\\mathbf{r})$ 给出。\n\n任务是找到使平方 $L^2$ 误差最小化的实数收缩系数 $\\{c_i\\}_{i=1}^n$：\n$$\nE = \\left\\| \\phi_{\\zeta} - \\chi_{n} \\right\\|_{2}^2 = \\left\\langle \\phi_{\\zeta} - \\sum_{i=1}^{n} c_i g_{\\alpha_i}, \\phi_{\\zeta} - \\sum_{j=1}^{n} c_j g_{\\alpha_j} \\right\\rangle\n$$\n其中，对于 $\\mathbb{R}^3$ 上的实值平方可积函数，内积定义为 $\\langle f, g \\rangle = \\int_{\\mathbb{R}^3} f(\\mathbf{r}) g(\\mathbf{r}) \\, d^3\\mathbf{r}$。\n\n利用内积的线性性质展开：\n$$\nE = \\langle \\phi_{\\zeta}, \\phi_{\\zeta} \\rangle - 2 \\sum_{i=1}^{n} c_i \\langle \\phi_{\\zeta}, g_{\\alpha_i} \\rangle + \\sum_{i=1}^{n} \\sum_{j=1}^{n} c_i c_j \\langle g_{\\alpha_i}, g_{\\alpha_j} \\rangle\n$$\n为找到使 $E$ 最小化的系数 $\\{c_k\\}$，我们必须将 $E$ 对每个 $c_k$ 的偏导数设为零：\n$$\n\\frac{\\partial E}{\\partial c_k} = 0 - 2 \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle + \\sum_{i=1}^{n} c_i \\langle g_{\\alpha_i}, g_{\\alpha_k} \\rangle + \\sum_{j=1}^{n} c_j \\langle g_{\\alpha_k}, g_{\\alpha_j} \\rangle = 0\n$$\n由于内积是对称的，即 $\\langle g_{\\alpha_i}, g_{\\alpha_k} \\rangle = \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle$，因此这两个和是相同的。于是，对于每个 $k \\in \\{1, \\dots, n\\}$：\n$$\n-2 \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle + 2 \\sum_{i=1}^{n} c_i \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle = 0\n$$\n$$\n\\sum_{i=1}^{n} \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle c_i = \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle\n$$\n这是一个线性方程组，可以表示为矩阵形式 $\\mathbf{S}\\mathbf{c} = \\mathbf{b}$，其中：\n- $\\mathbf{c}$ 是系数列向量 $[c_1, \\dots, c_n]^T$。\n- $\\mathbf{S}$ 是 GTO 原初函数的 $n \\times n$ 重叠矩阵，其元素为 $S_{ki} = \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle$。\n- $\\mathbf{b}$ 是一个长度为 $n$ 的列向量，其元素为 $b_k = \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle$。\n\n为了计算 $\\mathbf{S}$ 和 $\\mathbf{b}$ 的元素，我们必须从第一性原理出发计算所需的积分。由于轨道是球对称的，体积元 $d^3\\mathbf{r}$ 可以写成 $4\\pi r^2 dr$。\n\n首先，我们推导归一化常数。令 $\\tilde{\\phi}_{\\zeta}(r) = e^{-\\zeta r}$ 和 $\\tilde{g}_{\\alpha}(r) = e^{-\\alpha r^2}$ 为未归一化的函数。\n$\\phi_{\\zeta}(\\mathbf{r}) = N_{\\mathrm{STO}} \\tilde{\\phi}_{\\zeta}(r)$ 的归一化常数 $N_{\\mathrm{STO}}$ 通过要求 $\\langle \\phi_{\\zeta}, \\phi_{\\zeta} \\rangle = 1$ 来找到：\n$$\n1 = N_{\\mathrm{STO}}^2 \\int_{\\mathbb{R}^3} e^{-2\\zeta r} d^3\\mathbf{r} = N_{\\mathrm{STO}}^2 \\int_0^\\infty 4\\pi r^2 e^{-2\\zeta r} dr\n$$\n使用标准积分 $\\int_0^\\infty x^n e^{-ax} dx = n!/a^{n+1}$，其中 $n=2$ 且 $a=2\\zeta$：\n$$\n1 = N_{\\mathrm{STO}}^2 \\cdot 4\\pi \\left(\\frac{2!}{(2\\zeta)^3}\\right) = N_{\\mathrm{STO}}^2 \\frac{8\\pi}{8\\zeta^3} \\implies N_{\\mathrm{STO}} = \\sqrt{\\frac{\\zeta^3}{\\pi}}\n$$\n$g_{\\alpha}(\\mathbf{r}) = N_{\\mathrm{GTO}} \\tilde{g}_{\\alpha}(r)$ 的归一化常数 $N_{\\mathrm{GTO}}$ 通过要求 $\\langle g_{\\alpha}, g_{\\alpha} \\rangle = 1$ 来找到：\n$$\n1 = N_{\\mathrm{GTO}}^2 \\int_{\\mathbb{R}^3} e^{-2\\alpha r^2} d^3\\mathbf{r} = N_{\\mathrm{GTO}}^2 \\int_0^\\infty 4\\pi r^2 e^{-2\\alpha r^2} dr\n$$\n使用标准积分 $\\int_0^\\infty x^2 e^{-ax^2} dx = \\frac{1}{4}\\sqrt{\\frac{\\pi}{a^3}}$，其中 $a=2\\alpha$：\n$$\n1 = N_{\\mathrm{GTO}}^2 \\cdot 4\\pi \\left(\\frac{1}{4}\\sqrt{\\frac{\\pi}{(2\\alpha)^3}}\\right) = N_{\\mathrm{GTO}}^2 \\frac{\\pi^{3/2}}{(2\\alpha)^{3/2}} \\implies N_{\\mathrm{GTO}} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\n$$\n重叠矩阵元素 $S_{ki} = \\langle g_{\\alpha_k}, g_{\\alpha_i} \\rangle$ 为：\n$$\nS_{ki} = N_{\\mathrm{GTO},k} N_{\\mathrm{GTO},i} \\int_{\\mathbb{R}^3} e^{-\\alpha_k r^2} e^{-\\alpha_i r^2} d^3\\mathbf{r} = N_{\\mathrm{GTO},k} N_{\\mathrm{GTO},i} \\int_0^\\infty 4\\pi r^2 e^{-(\\alpha_k + \\alpha_i)r^2} dr\n$$\n使用相同的高斯积分形式，其中 $a = \\alpha_k + \\alpha_i$：\n$$\nS_{ki} = \\left(\\frac{2\\alpha_k}{\\pi}\\right)^{3/4} \\left(\\frac{2\\alpha_i}{\\pi}\\right)^{3/4} \\cdot 4\\pi \\left( \\frac{1}{4} \\sqrt{\\frac{\\pi}{(\\alpha_k+\\alpha_i)^3}} \\right) = \\frac{(4\\alpha_k\\alpha_i)^{3/4}}{\\pi^{3/2}} \\frac{\\pi^{3/2}}{(\\alpha_k+\\alpha_i)^{3/2}} = \\left( \\frac{2\\sqrt{\\alpha_k\\alpha_i}}{\\alpha_k+\\alpha_i} \\right)^{3/2}\n$$\n向量元素 $b_k = \\langle \\phi_{\\zeta}, g_{\\alpha_k} \\rangle$ 为：\n$$\nb_k = N_{\\mathrm{STO}} N_{\\mathrm{GTO},k} \\int_{\\mathbb{R}^3} e^{-\\zeta r} e^{-\\alpha_k r^2} d^3\\mathbf{r} = N_{\\mathrm{STO}} N_{\\mathrm{GTO},k} \\int_0^\\infty 4\\pi r^2 e^{-\\zeta r} e^{-\\alpha_k r^2} dr\n$$\n所需的积分 $I(\\alpha_k, \\zeta) = \\int_0^\\infty r^2 e^{-\\alpha_k r^2 -\\zeta r} dr$ 可以通过计算 $\\frac{\\partial^2 J(\\alpha_k, \\zeta)}{\\partial \\zeta^2}$ 得到，其中 $J(\\alpha, \\zeta) = \\int_0^\\infty e^{-\\alpha r^2 - \\zeta r} dr$。这个推导得出了以下表达式：\n$$\nI(\\alpha_k, \\zeta) = \\left(\\frac{\\sqrt{\\pi}(2\\alpha_k+\\zeta^2)}{8\\alpha_k^{5/2}}\\right) e^{\\zeta^2/4\\alpha_k}\\mathrm{erfc}\\left(\\frac{\\zeta}{2\\sqrt{\\alpha_k}}\\right) - \\frac{\\zeta}{4\\alpha_k^2}\n$$\n为了数值稳定性，特别是当误差函数的自变量较大时，这可以用标度互补误差函数 $\\mathrm{erfcx}(z) = e^{z^2}\\mathrm{erfc}(z)$ 来表示。\n$$\nI(\\alpha_k, \\zeta) = \\left(\\frac{\\sqrt{\\pi}(2\\alpha_k+\\zeta^2)}{8\\alpha_k^{5/2}}\\right) \\mathrm{erfcx}\\left(\\frac{\\zeta}{2\\sqrt{\\alpha_k}}\\right) - \\frac{\\zeta}{4\\alpha_k^2}\n$$\n因此，$b_k = N_{\\mathrm{STO}} N_{\\mathrm{GTO},k} \\cdot 4\\pi \\cdot I(\\alpha_k, \\zeta)$。\n\n最优系数向量通过求解线性系统 $\\mathbf{c} = \\mathbf{S}^{-1}\\mathbf{b}$ 得到。考虑到如果原初指数很接近，$\\mathbf{S}$ 可能会是病态的，因此需要一个稳定的数值求解器。\n\n利用最优系数 $\\mathbf{c}$，最小平方误差 $E_{min}$ 为：\n$$\nE_{min} = \\langle \\phi_{\\zeta}, \\phi_{\\zeta} \\rangle - 2\\mathbf{c}^T\\mathbf{b} + \\mathbf{c}^T\\mathbf{S}\\mathbf{c}\n$$\n代入 $\\mathbf{S}\\mathbf{c}=\\mathbf{b}$ 意味着 $\\mathbf{c}^T\\mathbf{S}\\mathbf{c}=\\mathbf{c}^T\\mathbf{b}$。\n$$\nE_{min} = 1 - 2\\mathbf{c}^T\\mathbf{b} + \\mathbf{c}^T\\mathbf{b} = 1 - \\mathbf{c}^T\\mathbf{b}\n$$\n最终的积分范数误差是 $e_n = \\sqrt{E_{min}} = \\sqrt{1 - \\mathbf{c}^T\\mathbf{b}}$。\n\n算法流程如下：对于给定的参数集 $(\\zeta, \\alpha_0, \\beta, N_{\\max}, \\varepsilon)$，我们生成 GTO 指数池 $\\{\\alpha_i = \\alpha_0 \\beta^{i-1}\\}_{i=1}^{N_{\\max}}$。然后我们从 $1$ 到 $N_{\\max}$ 迭代 $n$。在每次迭代中，我们为前 $n$ 个原初函数构建并求解线性系统，以找到最优系数 $\\mathbf{c}_n$ 和对应的误差 $e_n$。第一个满足 $e_n \\le \\varepsilon$ 的 $n$ 值即为所需的最小收缩长度 $n^\\star$。如果在 $n \\le N_{\\max}$ 的范围内没有满足容差的 $n$，我们报告 $n=N_{\\max}$ 时的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfcx\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the minimal contraction length n and corresponding L2 error\n    for approximating a Slater-type orbital with a sum of Gaussians.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    test_cases = [\n        # (zeta, alpha0, beta, N_max, epsilon)\n        (1.0, 0.01, 2.5, 12, 1.0e-4),\n        (0.25, 0.0005, 2.5, 14, 4.0e-4),\n        (4.0, 0.02, 3.0, 14, 2.0e-4),\n        (1.0, 0.01, 2.5, 10, 1.0e-8),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        zeta, alpha0, beta, N_max, epsilon = case\n        \n        # Generate the pool of primitive GTO exponents\n        exponents = np.array([alpha0 * (beta**(i)) for i in range(N_max)])\n\n        # Calculate N_STO once\n        N_sto = math.sqrt(zeta**3 / math.pi)\n\n        # Store errors for n=1 to N_max\n        errors = np.zeros(N_max)\n        \n        for n in range(1, N_max + 1):\n            \n            current_exponents = exponents[:n]\n            \n            # --- Build the overlap matrix S ---\n            S = np.zeros((n, n))\n            for i in range(n):\n                for j in range(i, n):\n                    alpha_i = current_exponents[i]\n                    alpha_j = current_exponents[j]\n                    val = (2 * math.sqrt(alpha_i * alpha_j) / (alpha_i + alpha_j))**1.5\n                    S[i, j] = val\n                    S[j, i] = val\n\n            # --- Build the overlap vector b ---\n            b = np.zeros(n)\n            for i in range(n):\n                alpha = current_exponents[i]\n                \n                # N_GTO for the current exponent\n                N_gto = (2 * alpha / math.pi)**0.75\n                \n                # Integral I(alpha, zeta)\n                z = zeta / (2 * math.sqrt(alpha))\n                # The expression inside I(alpha, zeta) before 4*pi multiplication\n                I_val = (math.sqrt(math.pi) * (2*alpha + zeta**2)) / (8 * alpha**2.5) * erfcx(z) - zeta / (4 * alpha**2)\n                \n                # Full b_i element\n                b[i] = N_sto * N_gto * 4 * math.pi * I_val\n            \n            # --- Solve the linear system and compute error ---\n            try:\n                # Solve Sc = b for coefficients c\n                coeffs = np.linalg.solve(S, b)\n                \n                # Calculate squared error E_min = 1 - c^T * b\n                # Note: c and b are 1-D arrays, so transpose is not needed.\n                squared_error = 1.0 - np.dot(coeffs, b)\n                \n                # Ensure squared error is non-negative due to potential floating point inaccuracies\n                if squared_error  0:\n                    squared_error = 0.0\n                \n                errors[n-1] = math.sqrt(squared_error)\n                \n            except np.linalg.LinAlgError:\n                # If matrix is singular, error is considered infinite\n                errors[n-1] = float('inf')\n\n        # Find the smallest n that meets the tolerance\n        found_n = -1\n        found_error = -1.0\n        \n        for n in range(N_max):\n            if errors[n] = epsilon:\n                found_n = n + 1\n                found_error = errors[n]\n                break\n        \n        # If no n met the tolerance, return the result for N_max\n        if found_n == -1:\n            n_star = N_max\n            e_star = errors[N_max-1]\n        else:\n            n_star = found_n\n            e_star = found_error\n            \n        all_results.append([n_star, e_star])\n    \n    # Format the results for the final output string\n    formatted_results = []\n    for result in all_results:\n        n_val, e_val = result\n        formatted_results.append(f\"[{n_val}, {e_val:.8e}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从离域的布洛赫波函数过渡到局域的化学键图像，是理解晶体材料电子结构的关键一步，而瓦尼尔函数（Wannier functions）正是实现这一目标的有力工具。对于绝缘体，瓦尼尔函数通常是指数局域的，其衰减长度由能带的解析性质决定。本练习通过一个精确可解的紧束缚模型，让你推导出瓦尼尔函数的渐近衰减长度与复能带结构中能隙闭合点之间的深刻联系，从而将抽象的能带理论与真实的局域化行为联系起来。",
            "id": "3461802",
            "problem": "考虑一个一维周期性紧束缚模型，每个晶胞有两个轨道，分别标记为$A$和$B$，晶格常数为$a$。假设相邻晶胞间的$A$和$B$轨道存在最近邻跃迁，跃迁振幅为$t0$；轨道$A$的在位能为$+\\Delta$，轨道$B$的在位能为$-\\Delta$，其中$\\Delta0$。在布洛赫表象中，作为晶体动量$k$的函数的哈密顿量为\n$$\nH(k) \\;=\\; \\begin{pmatrix}\n\\Delta   2 t \\cos\\!\\left(\\frac{k a}{2}\\right) \\\\\n2 t \\cos\\!\\left(\\frac{k a}{2}\\right)  -\\Delta\n\\end{pmatrix}.\n$$\n当$\\Delta \\neq 0$时，对于实数$k$，该模型具有直接能隙。将与占据（价）带相关的瓦尼尔函数定义为其布洛赫本征函数在布里渊区上的傅里叶变换，并采用平滑规范，使得布洛赫本征函数沿实数$k$轴连续。利用布洛赫本征函数在$k$复延拓下的解析性，以及长距离衰减与能带结构中最近的复奇点之间的联系，确定价带瓦尼尔函数沿链方向的渐近指数衰减长度$\\ell$（定义为在$x$很大时$|w(x)| \\propto \\exp(-x/\\ell)$）。\n\n请用$a$、$t$和$\\Delta$表示您的最终答案，给出一个单一的闭式符号表达式，并假设$a$的单位为米，答案也以米为单位。没有提供数值；不需要四舍五入。答案必须是单一的解析表达式。",
            "solution": "该问题要求解给定的一维双能带紧束缚模型中，价带瓦尼尔函数的渐近指数衰减长度$\\ell$。将瓦尼尔函数的空间局域性与能带结构联系起来的基本原理是：指数衰减率由布洛赫能带到复动量平面的解析延拓所决定。具体来说，衰减长度是价带和导带发生简并时，复波矢$k$的虚部的最小量值的倒数。这些简并点是能谱$E(k)$的支点。\n\n步骤如下：\n1.  对角化布洛赫哈密顿量$H(k)$，求出能带$E(k)$。\n2.  找出能带发生简并（即能隙闭合）时的复波矢$k$。\n3.  确定具有最小非零虚部$|k_{\\text{im}}|$的解。\n4.  衰减长度$\\ell$则由$\\ell = 1 / |k_{\\text{im}}|$给出。\n\n布洛赫表象中的哈密顿量为：\n$$\nH(k) \\;=\\; \\begin{pmatrix}\n\\Delta   2 t \\cos\\!\\left(\\frac{k a}{2}\\right) \\\\\n2 t \\cos\\!\\left(\\frac{k a}{2}\\right)  -\\Delta\n\\end{pmatrix}\n$$\n其中$\\Delta  0$是在位能劈裂的一半，$t  0$是跃迁振幅，$a$是晶格常数。\n\n首先，我们通过求解特征方程$\\det(H(k) - E I) = 0$来找到能量本征值$E$，其中$I$是$2 \\times 2$的单位矩阵。\n$$\n\\det \\begin{pmatrix}\n\\Delta - E   2 t \\cos\\!\\left(\\frac{k a}{2}\\right) \\\\\n2 t \\cos\\!\\left(\\frac{k a}{2}\\right)  -\\Delta - E\n\\end{pmatrix} = 0\n$$\n$$\n(\\Delta - E)(-\\Delta - E) - \\left(2 t \\cos\\!\\left(\\frac{k a}{2}\\right)\\right)^2 = 0\n$$\n$$\nE^2 - \\Delta^2 - 4 t^2 \\cos^2\\!\\left(\\frac{k a}{2}\\right) = 0\n$$\n求解$E$，我们得到两个能带（导带和价带）的能量色散关系：\n$$\nE_{\\pm}(k) = \\pm \\sqrt{\\Delta^2 + 4 t^2 \\cos^2\\!\\left(\\frac{k a}{2}\\right)}\n$$\n占据的价带对应较低的能量$E_-(k)$，未占据的导带对应较高的能量$E_+(k)$。能带之间的能隙为$E_g(k) = E_+(k) - E_-(k) = 2 \\sqrt{\\Delta^2 + 4 t^2 \\cos^2(ka/2)}$。因为$\\Delta  0$且$t0$，对于实数$k$，有$\\cos^2(ka/2) \\ge 0$，因此平方根下的项严格为正，这证实了对于所有实数$k$都存在非零能隙。\n\n接下来，我们寻找使能带发生简并的复数$k$值。这种情况发生在能隙闭合时，意味着平方根的参数必须为零：\n$$\n\\Delta^2 + 4 t^2 \\cos^2\\!\\left(\\frac{k a}{2}\\right) = 0\n$$\n$$\n\\cos^2\\!\\left(\\frac{k a}{2}\\right) = -\\frac{\\Delta^2}{4 t^2}\n$$\n对两边取平方根，得到：\n$$\n\\cos\\!\\left(\\frac{k a}{2}\\right) = \\pm i \\frac{\\Delta}{2 t}\n$$\n为了求解复波矢$k$，我们令$k = k_{\\text{re}} + i k_{\\text{im}}$，其中$k_{\\text{re}}$和$k_{\\text{im}}$分别是$k$的实部和虚部。我们使用复数的余弦恒等式 $\\cos(x+iy) = \\cos(x)\\cosh(y) - i\\sin(x)\\sinh(y)$：\n$$\n\\cos\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\cosh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) - i \\sin\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\pm i \\frac{\\Delta}{2 t}\n$$\n将该等式的实部和虚部相等，我们得到两个条件。首先，实部必须为零：\n$$\n\\cos\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\cosh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = 0\n$$\n由于对于任何实数$y$，$\\cosh(y) \\geq 1$，所以只有当余弦项为零时，该条件才能满足：\n$$\n\\cos\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right) = 0\n$$\n这意味着$\\frac{k_{\\text{re}} a}{2} = \\frac{\\pi}{2} + n\\pi$，其中$n$为任意整数。对于这些$k_{\\text{re}}$的值，我们有$|\\sin(\\frac{k_{\\text{re}} a}{2})| = 1$。\n\n现在，我们令虚部相等：\n$$\n- \\sin\\!\\left(\\frac{k_{\\text{re}} a}{2}\\right)\\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\pm \\frac{\\Delta}{2 t}\n$$\n由于$\\sin(\\frac{k_{\\text{re}} a}{2})$可以是$+1$或$-1$，我们可以写出：\n$$\n\\mp \\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\pm \\frac{\\Delta}{2 t}\n$$\n无论哪种情况，这都简化为要求$\\sinh(\\frac{k_{\\text{im}} a}{2})$的量值满足：\n$$\n\\left| \\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) \\right| = \\frac{\\Delta}{2 t}\n$$\n我们在寻找具有最小非零$k_{\\text{im}}$量值的解。不失一般性，我们可以求解正的$k_{\\text{im}}$：\n$$\n\\sinh\\!\\left(\\frac{k_{\\text{im}} a}{2}\\right) = \\frac{\\Delta}{2 t}\n$$\n通过取反双曲正弦来求解$k_{\\text{im}}$：\n$$\n\\frac{k_{\\text{im}} a}{2} = \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)\n$$\n$$\nk_{\\text{im}} = \\frac{2}{a} \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)\n$$\n这表示能带接触时，复波矢虚部的最小正值。瓦尼尔函数$|w(x)|$在$x$很大时的渐近衰减由$|w(x)| \\propto \\exp(-|k_{\\text{im}}||x|)$给出。问题通过$|w(x)| \\propto \\exp(-x/\\ell)$定义了衰减长度$\\ell$。通过比较，我们有：\n$$\n\\frac{1}{\\ell} = |k_{\\text{im}}| = \\frac{2}{a} \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)\n$$\n因此，衰减长度$\\ell$是：\n$$\n\\ell = \\frac{a}{2 \\arcsinh\\!\\left(\\frac{\\Delta}{2 t}\\right)}\n$$\n这个表达式是用给定的参数$a$、$t$和$\\Delta$表示的。由于$a$的单位是米，而$\\arcsinh$的参数是无量纲的（因为$\\Delta$和$t$都是能量），所以得到的衰减长度$\\ell$的单位是米，符合要求。",
            "answer": "$$\n\\boxed{\\frac{a}{2 \\arcsinh\\left(\\frac{\\Delta}{2 t}\\right)}}\n$$"
        },
        {
            "introduction": "为金属系统构建局域化的瓦尼尔函数比绝缘体更具挑战性，因为导带与价带之间没有能隙，导致能带发生“纠缠”。为了解决这个问题，需要一种系统性的方法来从一个更大的能量窗口中“解纠缠”出一个最优的、能够产生最大局域化轨道的子空间。这项实践将指导你实现这一过程的核心算法，即通过一个迭代的规范选择方案来处理能带交叉问题，并最小化一个离散化的扩展泛函。完成这个练习，你将掌握为复杂材料构建有效模型和进行化学分析的关键技术。",
            "id": "3461832",
            "problem": "给定一个具有周期性边界条件的离散一维晶体动量网格，一个固定数量的纠缠能带，以及一个固定数量的目标局域化函数，这些函数需要通过退纠缠和规范选择来构建。任务是实现一个数学上精确、鲁棒且可复现的方案，该方案构建一个平滑的规范来控制一个离散化的展宽泛函，适用于存在能带交叉的类金属情况下最大局域化瓦尼尔函数的构造。所有角度都应以弧度为单位。\n\n基本依据和定义：\n- 考虑一组幺正矩阵 $\\{B_k\\}_{k=0}^{K-1}$，其中每个 $B_k \\in \\mathbb{C}^{J \\times J}$ 代表在离散晶体动量点 $k$ 处 $J$ 个纠缠能带的一个正交归一的布洛赫框架，并满足周期性边界条件 $k \\mapsto (k+1) \\bmod K$。在纠缠能带表示中，点间交叠矩阵定义为\n$$\nM(k) \\equiv B_k^\\dagger B_{k+1} \\in \\mathbb{C}^{J \\times J}.\n$$\n- 在全局希尔伯特空间中，提供了一组固定的 $J'  J$ 个试探轨道，由矩阵 $T \\in \\mathbb{C}^{J \\times J'}$ 表示。在每个 $k$ 点，纠缠能带表示中的投影子空间系数定义为\n$$\nA(k) \\equiv B_k^\\dagger T \\in \\mathbb{C}^{J \\times J'}.\n$$\n- 每个 $k$ 点的退纠缠子空间由一个具有正交归一列的矩阵 $W(k) \\in \\mathbb{C}^{J \\times J'}$ 来表征，该矩阵通过对 $A(k)$ 的列进行正交归一化得到（例如，通过薄 $QR$ 分解），使得 $W(k)^\\dagger W(k) = I_{J'}$ 且 $\\operatorname{span}(W(k)) = \\operatorname{span}(A(k))$。\n- 子空间到子空间的连接交叠定义为\n$$\nS(k) \\equiv W(k)^\\dagger M(k) W(k+1) \\in \\mathbb{C}^{J' \\times J'}.\n$$\n- 退纠缠子空间上的规范是一组幺正矩阵 $\\{V(k)\\}_{k=0}^{K-1}$，其中 $V(k) \\in \\mathbb{C}^{J' \\times J'}$，产生规范变换后的框架 $W(k)V(k)$。一个需要控制的、依赖于规范的离散展宽量度定义为\n$$\n\\Omega \\equiv \\sum_{k=0}^{K-1} \\left( J' - \\sum_{n=1}^{J'} \\left| \\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn} \\right|^2 \\right),\n$$\n其中 $k+1$ 在模 $K$ 的意义下理解。\n\n要求的构造方法：\n- 退纠缠：对每个 $k$，通过对 $A(k) = B_k^\\dagger T$ 的列进行正交归一化来计算 $W(k)$。\n- 在存在能带交叉情况下的鲁棒规范选择：构造 $V(0) = I_{J'}$，然后对 $k = 0,1,\\dots,K-1$ 递归地确定 $V(k+1)$，以贪婪地最大化规范变换后框架中连接交叠的对角元素的大小。具体来说，在每一步：\n  1. 令 $A_{\\mathrm{link}}(k) \\equiv V(k)^\\dagger S(k)$。\n  2. 在所有大小为 $J' \\times J'$ 的列置换 $\\Pi$ 中（对于 $J' = 2$，只有两种置换），选择使 $\\sum_{n=1}^{J'} \\left| \\left[A_{\\mathrm{link}}(k)\\Pi\\right]_{nn} \\right|^2$ 最大化的置换 $\\Pi^\\star$。\n  3. 定义一个对角幺正相位矩阵 $D$，其元素为 $D_{nn} = e^{-i \\arg\\left(\\left[A_{\\mathrm{link}}(k)\\Pi^\\star\\right]_{nn}\\right)}$（如果对角元素为零，则将相位因子设为 $1$）。设置 $V(k+1) \\equiv \\Pi^\\star D$。\n- 在构造出 $\\{V(k)\\}$ 后，使用给定的公式计算 $\\Omega$。\n\n角度单位：下面指定的所有旋转角均以弧度为单位。\n\n测试套件：\n对于所有测试用例，使用 $J = 3$ 和 $J' = 2$，以及相同的试探轨道矩阵\n$$\nT = \\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0.15  0.2\n\\end{pmatrix}.\n$$\n定义 $3 \\times 3$ 的旋转矩阵 $R_{12}(\\theta)$ 和 $R_{23}(\\theta)$ 以及对角幺正矩阵 $D(\\alpha_1,\\alpha_2,\\alpha_3)$ 如下\n$$\nR_{12}(\\theta) \\equiv \\begin{pmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}, \\quad\nR_{23}(\\theta) \\equiv \\begin{pmatrix}\n1  0  0 \\\\\n0  \\cos\\theta  -\\sin\\theta \\\\\n0  \\sin\\theta  \\cos\\theta\n\\end{pmatrix}, \\quad\nD(\\alpha_1,\\alpha_2,\\alpha_3) \\equiv \\operatorname{diag}\\left(e^{i\\alpha_1}, e^{i\\alpha_2}, e^{i\\alpha_3}\\right).\n$$\n令 $I_3$ 为 $3 \\times 3$ 的单位矩阵，令 $P$ 为交换前两个基矢量而保持第三个不变的 $3 \\times 3$ 置换矩阵：\n$$\nP \\equiv \\begin{pmatrix}\n0  1  0 \\\\\n1  0  0 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n\n- 测试用例 A（无交叉的平滑演化）：\n  - 使用 $K = 4$ 和以下框架：\n  $$\n  B_0 = I_3, \\quad\n  B_1 = R_{12}(0.2)\\, D(0.1,-0.05,0.2), \\quad\n  B_2 = R_{12}(0.4)\\, R_{23}(0.15)\\, D(0.2,-0.1,0.3), \\quad\n  B_3 = R_{12}(0.6)\\, R_{23}(0.3)\\, D(0.3,-0.15,0.4).\n  $$\n- 测试用例 B（通过置换实现的能带交叉）：\n  - 使用 $K = 5$ 和以下框架：\n  $$\n  B_0 = I_3, \\quad\n  B_1 = R_{12}(0.5)\\, D(0.05,-0.02,0.1), \\quad\n  B_2 = R_{12}(1.0)\\, R_{23}(0.3)\\, D(0.1,-0.04,0.15), \\\\\n  B_3 = P\\, R_{12}(1.2)\\, R_{23}(0.5)\\, D(0.12,-0.05,0.2), \\quad\n  B_4 = P\\, R_{12}(1.4)\\, R_{23}(0.7)\\, D(0.14,-0.06,0.25).\n  $$\n- 测试用例 C（由剧烈旋转导致的近奇异连接）：\n  - 使用 $K = 3$ 和以下框架：\n  $$\n  B_0 = I_3, \\quad\n  B_1 = R_{12}(1.2)\\, R_{23}(1.2)\\, D(0.2,-0.2,0.3), \\quad\n  B_2 = R_{12}(2.2)\\, R_{23}(2.0)\\, D(0.4,-0.3,0.6).\n  $$\n\n要求：\n- 实现上述的退纠缠和规范构造方案，并为每个测试用例计算 $\\Omega$。\n- 数值稳定性：在对 $A(k)$ 进行正交归一化时，使用数值稳定的算法（例如，薄 QR 分解）。在计算相位时，将恰好为零的复数视为具有相位 $0$。\n- 最终程序必须按顺序计算对应于测试用例 A、测试用例 B 和测试用例 C 的三个 $\\Omega$ 值，并将其打印为单行，形式为方括号内包含的逗号分隔列表，每个值四舍五入到恰好 $10$ 位小数（例如，$[0.1234567890,0.0000000000,1.4142135624]$）。不允许有其他输出。",
            "solution": "该问题要求实现一个特定的计算方案，用于为一维离散晶体中的一组纠缠电子能带构建平滑规范，这是为金属系统计算最大局域化瓦尼尔函数的一项常见任务。目标是为三个不同的测试用例计算离散展宽泛函 $\\Omega$。\n\n该过程基于 Marzari-Vanderbilt 局域化理论的原理，并经过调整以用于从一个更大的 $J$ 个能带的空间中退纠缠出一个由 $J'$ 个能带组成的子集。核心思想是选择一个规范（一组幺正变换），使相邻晶体动量点（$k$ 点）之间基态的连接尽可能平滑。动量空间中更平滑的连接对应于实空间中更局域化的函数。\n\n解决方案是通过遵循规定的算法步骤来构建的：\n\n1.  **子空间定义与退纠缠**：\n    起点是在 $K$ 个动量点的离散网格上的一组 $J$ 个纠缠布洛赫框架 $\\{B_k\\}_{k=0}^{K-1}$。在这个 $J$ 维希尔伯特空间内，通过投影定义一个维度为 $J'$ 的目标子空间。一组由矩阵 $T \\in \\mathbb{C}^{J \\times J'}$ 的列表示的 $J'$ 个全局试探轨道，被投影到每个 $k$ 点的布洛赫框架上。这产生了系数矩阵 $A(k) = B_k^\\dagger T$。$A(k)$ 的列张成了所期望的 $J'$ 维“退纠缠”子空间，但它们通常不是正交归一的。\n    为了获得一个一致且数值稳定的表示，我们在每个 $k$ 点计算该子空间的一个正交归一基。这通过对 $A(k)$ 执行薄 QR 分解来实现，即 $A(k) = W(k)R(k)$，其中 $W(k) \\in \\mathbb{C}^{J \\times J'}$ 具有正交归一的列（$W(k)^\\dagger W(k) = I_{J'}$），而 $R(k)$ 是一个上三角矩阵。$W(k)$ 的列构成了在 $k$ 点 $k$ 处的退纠缠子空间的正交归一基。\n\n2.  **定义子空间交叠**：\n    为了量化相邻 $k$ 点子空间之间连接的平滑度，我们定义了交叠矩阵。原始纠缠框架之间的交叠为 $M(k) \\equiv B_k^\\dagger B_{k+1}$。退纠缠子空间之间的交叠则由此投影得到，即子空间到子空间的连接矩阵 $S(k) \\equiv W(k)^\\dagger M(k) W(k+1) \\in \\mathbb{C}^{J' \\times J'}$。矩阵 $S(k)$ 描述了在 $k$ 点的子空间基如何变换到在 $k+1$ 点的子空间基。注意，所有涉及 $k+1$ 的索引都取模 $K$，以遵循晶体的周期性边界条件。\n\n3.  **为平滑性选择规范**：\n    基 $W(k)$ 的唯一性仅在幺正变换 $W(k) \\to W(k)V(k)$ 的意义下成立，其中 $V(k) \\in \\mathbb{C}^{J' \\times J'}$ 是幺正的。这就是 $U(J')$ 规范自由度。目标是选择一组规范矩阵 $\\{V(k)\\}_{k=0}^{K-1}$ 以优化平滑度。规范变换后的连接矩阵为 $\\tilde{S}(k) = (W(k)V(k))^\\dagger M(k) (W(k+1)V(k+1)) = V(k)^\\dagger S(k) V(k+1)$。\n    一个平滑的规范是指对所有 $k$，$\\tilde{S}(k)$ 都“尽可能对角化”。问题将非对角性（或展宽）的量度 $\\Omega$ 定义为：\n    $$ \\Omega \\equiv \\sum_{k=0}^{K-1} \\left( J' - \\sum_{n=1}^{J'} \\left| \\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn} \\right|^2 \\right) $$\n    最小化 $\\Omega$ 等价于最大化规范变换后连接矩阵对角元素大小的平方和。\n\n4.  **贪婪递归算法**：\n    问题指定了一个贪婪递归算法来构造规范。\n    - 我们首先固定第一个 $k$ 点的规范，即 $V(0) = I_{J'}$。\n    - 对于从 $0$ 到 $K-2$ 的每一步 $k$，我们根据已知的 $V(k)$ 和预先计算的连接 $S(k)$ 来确定 $V(k+1)$。选择的依据是贪婪地最大化当前连接的对角特性，即最大化 $\\sum_{n=1}^{J'} \\left| \\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn} \\right|^2$。\n    - 该算法将此优化简化为寻找 $V(k+1)$ 的两步过程。令 $A_{\\mathrm{link}}(k) \\equiv V(k)^\\dagger S(k)$。我们寻找能够最大化 $A_{\\mathrm{link}}(k) V(k+1)$ 对角和的 $V(k+1)$。规定的选择是 $V(k+1) = \\Pi^\\star D$，其中：\n        a. $\\Pi^\\star$ 是一个置换矩阵，它能最佳地对齐 $A_{\\mathrm{link}}(k)$ 的列。对于 $J'=2$，我们测试单位置换和交换置换，以确定哪一个能将较大的元素置于 $A_{\\mathrm{link}}(k)\\Pi$ 的对角线上。具体来说，我们选择使 $\\sum_{n=1}^{J'} |[A_{\\mathrm{link}}(k)\\Pi]_{nn}|^2$ 最大化的置换 $\\Pi$。这一步对于处理能带交叉至关重要，因为在能带交叉处，态的特性可能会交换。\n        b. $D$ 是一个对角幺正矩阵，其相位的选择是为了将得到的对角元素 $\\left[A_{\\mathrm{link}}(k)\\Pi^\\star\\right]_{nn}$ 旋转为实数且为正。这是通过设置 $D_{nn} = \\exp(-i \\arg(\\left[A_{\\mathrm{link}}(k)\\Pi^\\star\\right]_{nn}))$ 来完成的。这确保了对于这个连接，对总和 $|\\left[V(k)^\\dagger S(k) V(k+1)\\right]_{nn}|^2$ 的贡献被最大化。\n\n5.  **最终计算**：\n    在构建了完整的规范矩阵集合 $\\{V(k)\\}_{k=0}^{K-1}$ 之后，通过对每个连接（包括从 $k=K-1$ 回到 $k=0$ 的周期性连接）的贡献求和来计算展宽泛函 $\\Omega$。\n\n这整个过程通过计算实现。所有矩阵都表示为 `numpy` 数组。矩阵乘法和共轭转置等是标准操作。薄 QR 分解使用 `numpy.linalg.qr` 并设置 `mode='reduced'` 来执行。复数的辐角使用 `numpy.angle` 查找，它能按规定正确处理零值输入。该算法应用于三个测试用例中的每一个，以得出所需的 $\\Omega$ 值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified scheme to construct a smooth gauge and computes the spread functional Omega.\n    \"\"\"\n\n    def get_rot_matrices(theta):\n        \"\"\"Helper to create 3x3 rotation matrices R12 and R23.\"\"\"\n        c, s = np.cos(theta), np.sin(theta)\n        r12 = np.array([\n            [c, -s, 0],\n            [s,  c, 0],\n            [0,  0, 1]\n        ], dtype=float)\n        r23 = np.array([\n            [1, 0,  0],\n            [0, c, -s],\n            [0, s,  c]\n        ], dtype=float)\n        return r12, r23\n\n    def get_diag_unitary(alpha1, alpha2, alpha3):\n        \"\"\"Helper to create a 3x3 diagonal unitary matrix.\"\"\"\n        return np.diag([np.exp(1j*alpha1), np.exp(1j*alpha2), np.exp(1j*alpha3)])\n\n    def compute_omega_for_case(K, B_frames, J, J_prime, T):\n        \"\"\"\n        Computes the spread functional Omega for a single test case.\n        \n        Args:\n            K (int): Number of k-points.\n            B_frames (list): List of JxJ unitary Bloch frames B_k.\n            J (int): Dimension of the entangled band space.\n            J_prime (int): Dimension of the disentangled subspace.\n            T (np.ndarray): JxJ' matrix of trial orbitals.\n            \n        Returns:\n            float: The computed value of the spread functional Omega.\n        \"\"\"\n        \n        # 1. Pre-computation of M, W, and S matrices\n        M_list = []\n        for k in range(K):\n            B_k_plus_1 = B_frames[(k + 1) % K]\n            M_k = B_frames[k].conj().T @ B_k_plus_1\n            M_list.append(M_k)\n\n        W_list = []\n        for k in range(K):\n            A_k = B_frames[k].conj().T @ T\n            # Thin QR factorization for orthonormalization\n            Q, _ = np.linalg.qr(A_k, mode='reduced')\n            W_list.append(Q)\n\n        S_list = []\n        for k in range(K):\n            W_k_plus_1 = W_list[(k + 1) % K]\n            S_k = W_list[k].conj().T @ M_list[k] @ W_k_plus_1\n            S_list.append(S_k)\n\n        # 2. Recursive gauge selection\n        V_list = [None] * K\n        V_list[0] = np.eye(J_prime, dtype=complex)\n        \n        # Permutation matrices for J'=2\n        perm_identity = np.eye(J_prime, dtype=complex)\n        perm_swap = np.array([[0, 1], [1, 0]], dtype=complex)\n        permutations = [perm_identity, perm_swap]\n\n        for k in range(K - 1):\n            V_k = V_list[k]\n            S_k = S_list[k]\n            A_link_k = V_k.conj().T @ S_k\n            \n            # Find the best permutation Pi_star\n            best_perm = None\n            max_sum_sq_diag = -1.0\n\n            for Pi in permutations:\n                M_prime = A_link_k @ Pi\n                current_sum = np.sum(np.abs(np.diag(M_prime))**2)\n                if current_sum > max_sum_sq_diag:\n                    max_sum_sq_diag = current_sum\n                    best_perm = Pi\n            \n            Pi_star = best_perm\n            M_prime = A_link_k @ Pi_star\n            \n            # Construct diagonal phase matrix D\n            diag_elements = np.diag(M_prime)\n            # np.angle(0.0 + 0.0j) is 0.0, satisfying the problem condition\n            phases = np.angle(diag_elements)\n            D_diag = np.exp(-1j * phases)\n            D = np.diag(D_diag)\n            \n            # Set the next gauge matrix\n            V_list[k + 1] = Pi_star @ D\n\n        # 3. Compute Omega\n        omega_total = 0.0\n        for k in range(K):\n            V_k = V_list[k]\n            S_k = S_list[k]\n            V_k_plus_1 = V_list[(k + 1) % K]\n            \n            # Gauge-transformed link matrix\n            L_k = V_k.conj().T @ S_k @ V_k_plus_1\n            \n            # Sum current k-point's contribution to Omega\n            term_k = J_prime - np.sum(np.abs(np.diag(L_k))**2)\n            omega_total += term_k\n            \n        return omega_total\n\n    # --- Problem Constants ---\n    J, J_prime = 3, 2\n    T = np.array([[1, 0], [0, 1], [0.15, 0.2]], dtype=float)\n    I3 = np.eye(J)\n    P = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]], dtype=float)\n\n    # --- Test Case Definitions ---\n    \n    # Test Case A\n    K_A = 4\n    R12_02, _ = get_rot_matrices(0.2)\n    R12_04, R23_015 = get_rot_matrices(0.4)\n    R23_015 = get_rot_matrices(0.15)[1]\n    R12_06, _ = get_rot_matrices(0.6)\n    R23_03 = get_rot_matrices(0.3)[1]\n    B_A = [\n        I3,\n        R12_02 @ get_diag_unitary(0.1, -0.05, 0.2),\n        R12_04 @ R23_015 @ get_diag_unitary(0.2, -0.1, 0.3),\n        R12_06 @ R23_03 @ get_diag_unitary(0.3, -0.15, 0.4)\n    ]\n\n    # Test Case B\n    K_B = 5\n    R12_05, _ = get_rot_matrices(0.5)\n    R12_10, R23_03_B = get_rot_matrices(1.0)\n    R23_03_B = get_rot_matrices(0.3)[1]\n    R12_12, R23_05 = get_rot_matrices(1.2)\n    R23_05 = get_rot_matrices(0.5)[1]\n    R12_14, R23_07 = get_rot_matrices(1.4)\n    R23_07 = get_rot_matrices(0.7)[1]\n\n    B_B = [\n        I3,\n        R12_05 @ get_diag_unitary(0.05, -0.02, 0.1),\n        R12_10 @ R23_03_B @ get_diag_unitary(0.1, -0.04, 0.15),\n        P @ R12_12 @ R23_05 @ get_diag_unitary(0.12, -0.05, 0.2),\n        P @ R12_14 @ R23_07 @ get_diag_unitary(0.14, -0.06, 0.25)\n    ]\n    \n    # Test Case C\n    K_C = 3\n    R12_12C, R23_12 = get_rot_matrices(1.2)\n    R12_22, R23_20 = get_rot_matrices(2.2)\n    R23_20 = get_rot_matrices(2.0)[1]\n\n    B_C = [\n        I3,\n        R12_12C @ R23_12 @ get_diag_unitary(0.2, -0.2, 0.3),\n        R12_22 @ R23_20 @ get_diag_unitary(0.4, -0.3, 0.6)\n    ]\n\n    test_cases = [\n        (K_A, B_A),\n        (K_B, B_B),\n        (K_C, B_C)\n    ]\n    \n    results = []\n    for K, B_frames in test_cases:\n        omega = compute_omega_for_case(K, B_frames, J, J_prime, T)\n        results.append(omega)\n\n    # Format the final output as specified\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}