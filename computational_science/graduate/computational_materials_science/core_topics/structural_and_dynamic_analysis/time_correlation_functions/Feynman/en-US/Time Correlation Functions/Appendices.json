{
    "hands_on_practices": [
        {
            "introduction": "While the mean-squared displacement (MSD) provides a first look at particle motion, the full time correlation function contains far richer information. This exercise delves into non-Gaussian dynamics, a hallmark of complex systems like supercooled liquids, by exploring how a distribution of particle mobilities affects higher-order correlations . You will derive and compute the non-Gaussian parameter $\\alpha_2(t)$ to quantify deviations from simple diffusive behavior and connect these deviations to characteristic features in the self-intermediate scattering function.",
            "id": "3496735",
            "problem": "Consider a three-dimensional ensemble of independent particles undergoing isotropic Brownian motion with quenched dynamical heterogeneity: each particle has a scalar diffusivity $D$ that is constant in time but drawn once per particle from a two-point distribution. With probability $p$ the particle has diffusivity $D_1$, and with probability $1-p$ the particle has diffusivity $D_2$. Let $\\Delta \\mathbf{r}(t)$ denote the displacement vector of a particle over time $t$, and let $\\Delta r(t) = \\|\\Delta \\mathbf{r}(t)\\|$ denote its magnitude. Define the self-intermediate scattering function (ISF) as $F_s(k,t) = \\langle e^{i \\mathbf{k} \\cdot \\Delta \\mathbf{r}(t)} \\rangle$ for a wavevector $\\mathbf{k}$ with magnitude $k$, and note that isotropy implies dependence only on $k$ and $t$.\n\nStarting only from:\n- the definition of Brownian motion in three dimensions (zero-mean Gaussian displacement with variance per Cartesian component $\\langle (\\Delta x)^2 \\rangle = 2 D t$ for a given $D$),\n- the definition of the self-intermediate scattering function $F_s(k,t) = \\langle e^{i \\mathbf{k} \\cdot \\Delta \\mathbf{r}(t)} \\rangle$,\n- the definitions of the mean-squared displacement (MSD) $\\langle (\\Delta r)^2 \\rangle$ and the fourth-order time correlation $C_4(t) = \\langle (\\Delta r)^4 \\rangle$,\n\nderive expressions for the ensemble-averaged quantities $C_4(t)$ and $F_s(k,t)$ under the stated heterogeneity, and construct the Gaussian prediction $F_s^{G}(k,t)$ obtained by assuming a strictly Gaussian displacement distribution characterized only by the MSD. Using these, quantify non-Gaussian dynamics via $C_4(t)$ and relate deviations from the Gaussian prediction to features in $F_s(k,t)$ at intermediate times by computing the following for each test case:\n- the fourth-order correlation $C_4(t)$,\n- the non-Gaussian parameter in three dimensions $\\alpha_2(t)$ defined from $C_4(t)$ and the MSD,\n- the deviation $\\Delta F_s(k,t) = F_s(k,t) - F_s^{G}(k,t)$.\n\nAll quantities are dimensionless; report all outputs as pure numbers without any physical units.\n\nUse the following test suite of parameter sets $(p, D_1, D_2, k, t)$:\n1. $(p = 1.0, D_1 = 0.2, D_2 = 0.5, k = 2.0, t = 1.0)$, a boundary case that is purely Gaussian due to $p = 1.0$.\n2. $(p = 0.5, D_1 = 0.1, D_2 = 0.5, k = 3.0, t = 1.0)$, a general case probing intermediate-time, intermediate-$k$ non-Gaussian features.\n3. $(p = 0.2, D_1 = 0.01, D_2 = 1.0, k = 4.0, t = 0.5)$, an edge case with strong heterogeneity where the fast subpopulation decays rapidly at intermediate times.\n4. $(p = 0.5, D_1 = 0.1, D_2 = 0.5, k = 0.1, t = 1.0)$, a boundary case at small $k$ where Gaussian and non-Gaussian predictions are expected to coincide closely.\n5. $(p = 0.5, D_1 = 0.1, D_2 = 0.5, k = 3.0, t = 10.0)$, a large-$t$ case where $\\Delta F_s(k,t)$ reveals long-time decay dominated by the slow subpopulation.\n\nYour program must, for each test case $i$, compute and output three floats in the order $[C_4(t_i), \\alpha_2(t_i), \\Delta F_s(k_i,t_i)]$, each rounded to six decimal places. Aggregate all test cases into a single flat list, in order from case $1$ to case $5$, and print exactly one line containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots,r_{15}]$ where $r_j$ are the rounded floats).",
            "solution": "The problem is first assessed for validity.\n\n### Step 1: Extracted Givens\n- **System**: A three-dimensional ensemble of independent particles undergoing isotropic Brownian motion.\n- **Heterogeneity**: Quenched dynamical heterogeneity, where each particle's scalar diffusivity $D$ is constant, drawn from a two-point distribution.\n- **Diffusivity Distribution**: $P(D=D_1) = p$ and $P(D=D_2) = 1-p$.\n- **Displacement**: Displacement vector $\\Delta \\mathbf{r}(t)$ over time $t$, with magnitude $\\Delta r(t) = \\|\\Delta \\mathbf{r}(t)\\|$.\n- **Brownian Motion (Fixed D)**: For a given diffusivity $D$, displacement is a zero-mean Gaussian process. Variance per Cartesian component is $\\langle (\\Delta x)^2 \\rangle_D = 2 D t$. The notation $\\langle \\cdot \\rangle_D$ denotes an average for a fixed $D$.\n- **Definitions**:\n    - Self-intermediate scattering function (ISF): $F_s(k,t) = \\langle e^{i \\mathbf{k} \\cdot \\Delta \\mathbf{r}(t)} \\rangle$, where $k = \\|\\mathbf{k}\\|$.\n    - Mean-squared displacement (MSD): $\\langle (\\Delta r)^2 \\rangle$.\n    - Fourth-order time correlation: $C_4(t) = \\langle (\\Delta r)^4 \\rangle$.\n- **Gaussian Prediction**: $F_s^{G}(k,t)$ is the ISF for a hypothetical Gaussian displacement distribution characterized solely by the ensemble-averaged MSD.\n- **Objective**: Derive expressions for and compute $C_4(t)$, the non-Gaussian parameter $\\alpha_2(t)$, and the deviation $\\Delta F_s(k,t) = F_s(k,t) - F_s^{G}(k,t)$.\n- **Test Cases**: Five sets of parameters $(p, D_1, D_2, k, t)$ are provided.\n- **Output Format**: For each case, $[C_4(t), \\alpha_2(t), \\Delta F_s(k,t)]$ rounded to six decimal places, aggregated into a single flat list.\n\n### Step 2: Validation\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard and solvable model in the statistical physics of disordered systems (the \"two-state model\" of dynamical heterogeneity). All terms are formally defined or are standard quantities (like the non-Gaussian parameter $\\alpha_2(t)$) whose definition is unambiguous in this context. The problem is self-contained, with all necessary parameters provided for the required calculations. The test cases are well-chosen to probe different physical regimes of the model. No scientific, logical, or structural flaws are detected.\n\n### Step 3: Verdict\nThe problem is valid. A reasoned solution follows.\n\n### Derivation of Required Quantities\n\nThe ensemble average, denoted by $\\langle \\cdot \\rangle$, involves two steps: first, an average over the Brownian trajectories for a fixed diffusivity $D$, denoted by $\\langle \\cdot \\rangle_D$; and second, an average over the distribution of $D$. For any observable $A$, the ensemble average is $\\langle A \\rangle = p \\langle A \\rangle_{D_1} + (1-p) \\langle A \\rangle_{D_2}$.\n\n**1. Moments of Displacement for a Fixed Diffusivity $D$**\n\nFor a particle with a fixed diffusivity $D$, the displacement components $\\Delta x(t)$, $\\Delta y(t)$, and $\\Delta z(t)$ are independent and identically distributed Gaussian random variables with mean $0$ and variance $\\langle (\\Delta x)^2 \\rangle_D = 2Dt$. Let $\\sigma^2 = 2Dt$.\n\nThe squared displacement magnitude is $(\\Delta r)^2 = (\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2$.\nThe mean-squared displacement for a fixed $D$ is:\n$$ \\langle (\\Delta r)^2 \\rangle_D = \\langle (\\Delta x)^2 \\rangle_D + \\langle (\\Delta y)^2 \\rangle_D + \\langle (\\Delta z)^2 \\rangle_D = 2Dt + 2Dt + 2Dt = 6Dt $$\n\nThe fourth moment $\\langle (\\Delta r)^4 \\rangle_D$ is:\n$$ \\langle (\\Delta r)^4 \\rangle_D = \\langle ((\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2)^2 \\rangle_D $$\nUsing the independence of the components and the moments of a zero-mean Gaussian variable ($\\langle X^2 \\rangle = \\sigma^2$, $\\langle X^4 \\rangle = 3\\sigma^4$):\n$$ \\langle (\\Delta r)^4 \\rangle_D = \\langle (\\Delta x)^4 + (\\Delta y)^4 + (\\Delta z)^4 + 2(\\Delta x)^2(\\Delta y)^2 + 2(\\Delta x)^2(\\Delta z)^2 + 2(\\Delta y)^2(\\Delta z)^2 \\rangle_D $$\n$$ \\langle (\\Delta r)^4 \\rangle_D = 3 \\langle (\\Delta x)^4 \\rangle_D + 6 \\langle (\\Delta x)^2 \\rangle_D \\langle (\\Delta y)^2 \\rangle_D = 3(3\\sigma^4) + 6(\\sigma^2 \\cdot \\sigma^2) = 9\\sigma^4 + 6\\sigma^4 = 15\\sigma^4 $$\nSubstituting $\\sigma^2 = 2Dt$:\n$$ \\langle (\\Delta r)^4 \\rangle_D = 15(2Dt)^2 = 60 D^2 t^2 $$\n\n**2. Ensemble-Averaged Moments and $C_4(t)$**\n\nWe now average over the distribution of $D$. Let $\\langle D \\rangle = pD_1 + (1-p)D_2$ and $\\langle D^2 \\rangle = pD_1^2 + (1-p)D_2^2$.\n\nThe ensemble-averaged MSD is:\n$$ \\langle (\\Delta r)^2 \\rangle = p \\langle (\\Delta r)^2 \\rangle_{D_1} + (1-p) \\langle (\\Delta r)^2 \\rangle_{D_2} = p(6D_1t) + (1-p)(6D_2t) = 6t(pD_1 + (1-p)D_2) = 6 \\langle D \\rangle t $$\n\nThe fourth-order correlation function $C_4(t)$ is the ensemble-averaged fourth moment of displacement:\n$$ C_4(t) = \\langle (\\Delta r)^4 \\rangle = p \\langle (\\Delta r)^4 \\rangle_{D_1} + (1-p) \\langle (\\Delta r)^4 \\rangle_{D_2} = p(60 D_1^2 t^2) + (1-p)(60 D_2^2 t^2) $$\n$$ C_4(t) = 60 t^2 (pD_1^2 + (1-p)D_2^2) = 60 \\langle D^2 \\rangle t^2 $$\n\n**3. Non-Gaussian Parameter $\\alpha_2(t)$**\n\nThe non-Gaussian parameter in three dimensions is defined as:\n$$ \\alpha_2(t) = \\frac{3}{5} \\frac{\\langle (\\Delta r)^4 \\rangle}{\\langle (\\Delta r)^2 \\rangle^2} - 1 $$\nSubstituting our derived ensemble averages:\n$$ \\alpha_2(t) = \\frac{3}{5} \\frac{60 \\langle D^2 \\rangle t^2}{(6 \\langle D \\rangle t)^2} - 1 = \\frac{3}{5} \\frac{60 \\langle D^2 \\rangle t^2}{36 \\langle D \\rangle^2 t^2} - 1 = \\frac{180}{180} \\frac{\\langle D^2 \\rangle}{\\langle D \\rangle^2} - 1 $$\n$$ \\alpha_2(t) = \\frac{\\langle D^2 \\rangle}{\\langle D \\rangle^2} - 1 = \\frac{pD_1^2 + (1-p)D_2^2}{(pD_1 + (1-p)D_2)^2} - 1 $$\nFor this model, $\\alpha_2(t)$ is surprisingly independent of time $t$. Note that if $p=0$ or $p=1$, or if $D_1=D_2$, then $\\langle D^2 \\rangle = \\langle D \\rangle^2$ and $\\alpha_2(t)=0$, correctly reflecting purely Gaussian dynamics.\n\n**4. Self-Intermediate Scattering Function $F_s(k,t)$**\n\nFirst, we compute the ISF for a fixed diffusivity $D$. Due to isotropy, we can align $\\mathbf{k}$ with the z-axis, so $\\mathbf{k} = (0, 0, k)$ and $\\mathbf{k} \\cdot \\Delta \\mathbf{r}(t) = k \\Delta z(t)$.\n$$ F_s(k,t)_D = \\langle e^{i k \\Delta z(t)} \\rangle_D $$\nThis is the characteristic function of the Gaussian variable $\\Delta z(t)$ (mean $0$, variance $2Dt$), evaluated at $k$. For a Gaussian $N(\\mu, \\sigma^2)$, this is $e^{i k \\mu - \\frac{1}{2} k^2 \\sigma^2}$.\n$$ F_s(k,t)_D = e^{-\\frac{1}{2} k^2 (2Dt)} = e^{-D k^2 t} $$\nThe ensemble-averaged ISF is then:\n$$ F_s(k,t) = \\langle F_s(k,t)_D \\rangle = p F_s(k,t)_{D_1} + (1-p) F_s(k,t)_{D_2} $$\n$$ F_s(k,t) = p e^{-D_1 k^2 t} + (1-p) e^{-D_2 k^2 t} $$\nThis is a sum of two exponentials, characteristic of a two-state relaxation process.\n\n**5. Gaussian Prediction $F_s^G(k,t)$ and Deviation $\\Delta F_s(k,t)$**\n\nThe Gaussian prediction $F_s^G(k,t)$ is constructed for a hypothetical homogeneous system whose MSD matches the true ensemble MSD. This implies an effective diffusivity $D_{eff}$ such that $6 D_{eff} t = \\langle (\\Delta r)^2 \\rangle = 6 \\langle D \\rangle t$, which gives $D_{eff} = \\langle D \\rangle$.\n\nThe ISF for this effective homogeneous system is:\n$$ F_s^G(k,t) = e^{-D_{eff} k^2 t} = e^{-\\langle D \\rangle k^2 t} = e^{-(pD_1 + (1-p)D_2) k^2 t} $$\nThe deviation is the difference between the true ISF and the Gaussian prediction:\n$$ \\Delta F_s(k,t) = F_s(k,t) - F_s^G(k,t) = \\left(p e^{-D_1 k^2 t} + (1-p) e^{-D_2 k^2 t}\\right) - e^{-(pD_1 + (1-p)D_2) k^2 t} $$\nBy Jensen's inequality for the convex function $f(x)=e^{-x}$, we have $\\langle e^{-X} \\rangle \\ge e^{-\\langle X \\rangle}$. Setting $X=Dk^2t$, it follows that $F_s(k,t) \\ge F_s^G(k,t)$, so $\\Delta F_s(k,t) \\ge 0$.\n\n**Summary of Formulae for Implementation**\nFor each test case $(p, D_1, D_2, k, t)$:\n1.  Calculate average diffusivities: $\\langle D \\rangle = p D_1 + (1-p) D_2$ and $\\langle D^2 \\rangle = p D_1^2 + (1-p) D_2^2$.\n2.  Compute $C_4(t) = 60 \\langle D^2 \\rangle t^2$.\n3.  Compute $\\alpha_2(t) = \\frac{\\langle D^2 \\rangle}{\\langle D \\rangle^2} - 1$. Handle the case $\\langle D \\rangle = 0$ if necessary, though not for the given test data.\n4.  Compute $\\Delta F_s(k,t) = (p e^{-D_1 k^2 t} + (1-p) e^{-D_2 k^2 t}) - e^{-\\langle D \\rangle k^2 t}$.\nThese formulae are implemented in the provided Python code.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ensemble-averaged dynamical properties for a system with quenched\n    diffusivity heterogeneity.\n    \"\"\"\n    # Test cases: (p, D1, D2, k, t)\n    test_cases = [\n        (1.0, 0.2, 0.5, 2.0, 1.0),\n        (0.5, 0.1, 0.5, 3.0, 1.0),\n        (0.2, 0.01, 1.0, 4.0, 0.5),\n        (0.5, 0.1, 0.5, 0.1, 1.0),\n        (0.5, 0.1, 0.5, 3.0, 10.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p, D1, D2, k, t = case\n\n        # --- Derive required quantities ---\n\n        # 1. Calculate ensemble-averaged moments of D\n        # Average diffusivity <D>\n        avg_D = p * D1 + (1 - p) * D2\n        # Average squared diffusivity <D^2>\n        avg_D2 = p * D1**2 + (1 - p) * D2**2\n        \n        # 2. Compute the fourth-order correlation C4(t)\n        # C4(t) = <(Δr)^4> = 60 * <D^2> * t^2\n        c4_t = 60 * avg_D2 * t**2\n\n        # 3. Compute the non-Gaussian parameter alpha_2(t)\n        # alpha_2(t) = (<D^2> / <D>^2) - 1\n        # Avoid division by zero, though not an issue with given positive D values.\n        if avg_D == 0:\n            # If avg_D is zero, it implies D1=D2=0 (for p in (0,1)), so avg_D2=0.\n            # Or if p=1, D1=0. In any physical case of no motion, alpha_2 is ill-defined or 0.\n            alpha2_t = 0.0\n        else:\n            alpha2_t = (avg_D2 / avg_D**2) - 1\n\n        # 4. Compute the deviation of the intermediate scattering function, ΔFs(k,t)\n        k2t = k**2 * t\n        \n        # True ISF: Fs(k,t) = p*exp(-D1*k^2*t) + (1-p)*exp(-D2*k^2*t)\n        fs_kt = p * np.exp(-D1 * k2t) + (1 - p) * np.exp(-D2 * k2t)\n        \n        # Gaussian approximation: Fs^G(k,t) = exp(-<D>*k^2*t)\n        fs_g_kt = np.exp(-avg_D * k2t)\n        \n        # Deviation ΔFs(k,t) = Fs(k,t) - Fs^G(k,t)\n        delta_fs_kt = fs_kt - fs_g_kt\n        \n        # Round results to six decimal places and append\n        results.extend([\n            round(c4_t, 6),\n            round(alpha2_t, 6),\n            round(delta_fs_kt, 6)\n        ])\n\n    # Format output as a single comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "One of the most powerful applications of time correlation functions is the calculation of transport coefficients via the Green-Kubo relations, which rigorously link macroscopic transport to microscopic fluctuations. In this practice, you will implement a mode-resolved analysis of thermal conductivity, a key material property . By computing and integrating cross-correlations between modal heat fluxes and the total heat flux, you will learn to decompose a bulk transport coefficient and identify the dominant microscopic carriers of energy.",
            "id": "3496766",
            "problem": "You must design and implement a complete, runnable program that uses time correlation functions to decompose thermal conductivity into mode-resolved contributions and identify the dominant vibrational modes. The core quantity to use is the cross-correlation function defined by $C_{AB}(t)=\\langle A(0)B(t)\\rangle$, where $\\langle\\cdot\\rangle$ denotes an equilibrium ensemble average. The foundational base for the derivation must begin from the definition of time correlation functions and the Green-Kubo (GK) relation for thermal conductivity, together with basic assumptions of stationarity and ergodicity that enable time averages to approximate ensemble averages in practice.\n\nYou will work in a context where the total heat flux is resolved into mode-specific components, and your job is to quantify phonon-heat flux coupling via cross-correlation, integrate to obtain conductivity contributions, and use these to identify dominant vibrational modes. The final quantity to identify for each test case is the index of the mode that contributes the largest portion to the thermal conductivity.\n\nScientific setup and data model:\n- The total heat flux signal will be denoted by $q(t)$ and expressed in watts per square meter. The thermal conductivity must be computed in watts per meter-kelvin.\n- The mode-resolved heat flux signals will be denoted by $A_m(t)$ for mode index $m$, also in watts per square meter.\n- You must treat the stochastic signals as stationary and ergodic, and you must derive appropriate discrete-time estimators for cross-correlation and the Green-Kubo integral.\n- You must use the base definitions to derive discrete formulas for estimating $C_{AB}(t)$ from finite-length signals sampled at regular intervals $\\Delta t$, and then use numerical integration to obtain conductivity contributions.\n\nFoundational principles to use in your derivation:\n- Time correlation function: $C_{AB}(t)=\\langle A(0)B(t)\\rangle$.\n- Green-Kubo relation (defined here as a foundational starting point): thermal conductivity along a given direction is given by an integral of the equilibrium heat flux correlation function.\n- Stationarity and ergodicity: time translation invariance of equilibrium correlation functions and replacement of ensemble averages by time averages over sufficiently long trajectories.\n\nNumerical and algorithmic requirements:\n- You must implement a statistically unbiased discrete-time estimator of $C_{AB}(t)$ using nonnegative time lags $t=k\\Delta t$ with integer $k\\ge 0$, and then a numerical quadrature to approximate the corresponding time integral.\n- You must implement a principled cutoff $t_{\\text{cut}}$ for truncating the integral based on the decay of the total heat flux autocorrelation function $C_{qq}(t)$ so that the integral remains numerically stable and physically meaningful.\n- You must compute the total thermal conductivity from the total heat flux autocorrelation and compute mode-resolved raw contributions from the cross-correlations $C_{A_m q}(t)$. You must then rescale the raw mode contributions so that their sum exactly matches the total thermal conductivity, ensuring a self-consistent decomposition.\n\nOutput specification:\n- For each test case, identify the dominant mode by its zero-based index $m^{\\star}$, defined as the index with the largest rescaled conductivity contribution.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$text{result}_1$,$text{result}_2$,$text{result}_3$]\"), where each $\\text{result}_i$ is an integer mode index. The program must print this line exactly, with no extra text.\n- Although intermediate quantities may carry physical units, the final output is unitless indices. All internal computations of thermal conductivity must be in watts per meter-kelvin.\n\nTest suite and parameters:\n- You must internally generate synthetic time series for the mode-resolved heat fluxes $A_m(t)$ and the total heat flux $q(t)$ as follows. For each mode $m$, generate $A_m(t)$ as an Ornstein-Uhlenbeck (OU) process (defined here as a widely used stochastic process with exponentially decaying autocorrelation), with zero mean, correlation time $\\tau_m$, and stationary standard deviation $\\sigma_m$. Generate $q(t)$ as the sum of all $A_m(t)$ plus an independent OU noise process with correlation time $\\tau_{\\text{noise}}$ and standard deviation $\\sigma_{\\text{noise}}$.\n- A test case consists of the parameters $(T,V,\\Delta t,N,\\{\\tau_m\\},\\{\\sigma_m\\},\\tau_{\\text{noise}},\\sigma_{\\text{noise}},\\text{seed},\\{\\nu_m\\})$, where $T$ is temperature in kelvin, $V$ is volume in cubic meters, $\\Delta t$ is the sampling interval in seconds, $N$ is the number of samples, $\\tau_m$ are the mode correlation times in seconds, $\\sigma_m$ are the mode stationary standard deviations in watts per square meter, $\\tau_{\\text{noise}}$ and $\\sigma_{\\text{noise}}$ parameterize the independent OU noise added to $q(t)$, and $\\text{seed}$ is the random seed. The $\\{\\nu_m\\}$ are labels for nominal vibrational frequencies in hertz to identify each mode and are not used directly in generating the OU signals, but are provided to indicate the physical interpretation of the modes as vibrational.\n- You must use the Boltzmann constant $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ in your Green-Kubo prefactor.\n\nProvide and solve the following three test cases:\n1. Happy-path case dominated by an intermediate mode:\n   - $T=300\\ \\mathrm{K}$, $V=1.0\\times 10^{-28}\\ \\mathrm{m}^3$, $\\Delta t=1.0\\times 10^{-14}\\ \\mathrm{s}$, $N=8192$\n   - Modes $m\\in\\{0,1,2\\}$ with correlation times $\\{\\tau_m\\}=\\{5.0\\times 10^{-13},\\ 2.0\\times 10^{-13},\\ 1.0\\times 10^{-13}\\}\\ \\mathrm{s}$\n   - Stationary standard deviations $\\{\\sigma_m\\}=\\{1.0\\times 10^{8},\\ 3.0\\times 10^{8},\\ 8.0\\times 10^{7}\\}\\ \\mathrm{W/m}^2$\n   - Noise parameters: $\\tau_{\\text{noise}}=1.0\\times 10^{-13}\\ \\mathrm{s}$, $\\sigma_{\\text{noise}}=5.0\\times 10^{7}\\ \\mathrm{W/m}^2$\n   - Random seed: $\\text{seed}=42$\n   - Mode labels (nominal vibrational frequencies): $\\{\\nu_m\\}=\\{1.0\\times 10^{12},\\ 4.0\\times 10^{12},\\ 8.0\\times 10^{12}\\}\\ \\mathrm{Hz}$\n\n2. Boundary case with effectively single-mode dominance:\n   - $T=300\\ \\mathrm{K}$, $V=1.0\\times 10^{-28}\\ \\mathrm{m}^3$, $\\Delta t=1.0\\times 10^{-14}\\ \\mathrm{s}$, $N=8192$\n   - Modes $m\\in\\{0,1,2\\}$ with correlation times $\\{\\tau_m\\}=\\{5.0\\times 10^{-13},\\ 2.0\\times 10^{-13},\\ 1.0\\times 10^{-13}\\}\\ \\mathrm{s}$\n   - Stationary standard deviations $\\{\\sigma_m\\}=\\{0.0,\\ 2.0\\times 10^{8},\\ 0.0\\}\\ \\mathrm{W/m}^2$\n   - Noise parameters: $\\tau_{\\text{noise}}=1.0\\times 10^{-13}\\ \\mathrm{s}$, $\\sigma_{\\text{noise}}=5.0\\times 10^{7}\\ \\mathrm{W/m}^2$\n   - Random seed: $\\text{seed}=43$\n   - Mode labels: $\\{\\nu_m\\}=\\{1.0\\times 10^{12},\\ 4.0\\times 10^{12},\\ 8.0\\times 10^{12}\\}\\ \\mathrm{Hz}$\n\n3. Short-trajectory edge case with equal amplitudes but differing correlation times:\n   - $T=300\\ \\mathrm{K}$, $V=1.0\\times 10^{-28}\\ \\mathrm{m}^3$, $\\Delta t=1.0\\times 10^{-14}\\ \\mathrm{s}$, $N=2048$\n   - Modes $m\\in\\{0,1,2\\}$ with correlation times $\\{\\tau_m\\}=\\{5.0\\times 10^{-13},\\ 1.0\\times 10^{-13},\\ 5.0\\times 10^{-14}\\}\\ \\mathrm{s}$\n   - Stationary standard deviations $\\{\\sigma_m\\}=\\{1.0\\times 10^{8},\\ 1.0\\times 10^{8},\\ 1.0\\times 10^{8}\\}\\ \\mathrm{W/m}^2$\n   - Noise parameters: $\\tau_{\\text{noise}}=1.0\\times 10^{-13}\\ \\mathrm{s}$, $\\sigma_{\\text{noise}}=5.0\\times 10^{7}\\ \\mathrm{W/m}^2$\n   - Random seed: $\\text{seed}=44$\n   - Mode labels: $\\{\\nu_m\\}=\\{1.0\\times 10^{12},\\ 4.0\\times 10^{12},\\ 8.0\\times 10^{12}\\}\\ \\mathrm{Hz}$\n\nImplementation specifics and numerical stability:\n- For each test case, generate the OU processes using the discrete-time update rule that yields a stationary variance equal to $\\sigma^2$ and an exponential correlation time equal to $\\tau$, with zero mean. Use the given seeds for reproducibility.\n- Use a numerically unbiased estimator for the correlation functions with nonnegative lag $k$, dividing each lagged sum by the number of overlapping samples $N-k$.\n- Determine the integration cutoff $t_{\\text{cut}}$ by selecting the smallest nonnegative lag $k$ for which the magnitude of the total heat flux autocorrelation $|C_{qq}(k\\Delta t)|$ falls below $0.02$ times $C_{qq}(0)$, or use $N/4$ lags if no such $k$ occurs. Then apply the same cutoff to all cross-correlations in that test case.\n- Use a trapezoidal integration rule over $[0,t_{\\text{cut}}]$.\n- Compute the total thermal conductivity from the autocorrelation of $q(t)$ and compute raw mode contributions from $C_{A_m q}(t)$. Rescale the raw contributions to exactly sum to the total thermal conductivity. Identify the dominant mode by the largest rescaled contribution and return its zero-based index.\n\nFinal output format requirement:\n- Your program must output a single line containing a list of three integers corresponding to the dominant mode indices for the three test cases, exactly in the format \"[$a$,$b$,$c$]\". No other text or lines should be printed.",
            "solution": "The problem requires the design and implementation of a method to decompose the total thermal conductivity, $\\kappa$, into contributions from individual vibrational modes. This decomposition is to be achieved by analyzing time series data of mode-resolved heat fluxes, $A_m(t)$, and the total heat flux, $q(t)$, using the framework of time correlation functions and the Green-Kubo (GK) relation.\n\nThe foundational principle is the Green-Kubo formula for thermal conductivity, which relates $\\kappa$ to the time integral of the equilibrium heat flux autocorrelation function (HFACF):\n$$\n\\kappa = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^\\infty \\langle q(0)q(t) \\rangle dt\n$$\nHere, $V$ is the system volume, $T$ is the absolute temperature, $k_{\\mathrm{B}}$ is the Boltzmann constant, and $\\langle q(0)q(t) \\rangle$ is the HFACF, denoted as $C_{qq}(t)$. The angle brackets $\\langle\\cdot\\rangle$ represent an ensemble average at thermodynamic equilibrium. The problem assumes stationarity and ergodicity, which allows us to replace the ensemble average with a time average over a single, sufficiently long trajectory.\n\nThe total heat flux $q(t)$ is modeled as the sum of contributions from individual modes, $A_m(t)$, and an independent noise term, $\\eta(t)$:\n$$\nq(t) = \\sum_m A_m(t) + \\eta(t)\n$$\nSubstituting this decomposition into the GK formula and exploiting the linearity of the correlation function, we can express the total conductivity as a sum of terms:\n$$\n\\kappa = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^\\infty \\left\\langle \\left( \\sum_m A_m(0) + \\eta(0) \\right) q(t) \\right\\rangle dt = \\sum_m \\left( \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^\\infty \\langle A_m(0) q(t) \\rangle dt \\right) + \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^\\infty \\langle \\eta(0) q(t) \\rangle dt\n$$\nThis decomposition naturally defines a set of \"raw\" mode contributions, $\\kappa_m^{\\text{raw}}$, based on the cross-correlation between each mode's heat flux and the total heat flux:\n$$\n\\kappa_m^{\\text{raw}} = \\frac{V}{k_{\\mathrm{B}} T^2} \\int_0^\\infty C_{A_m q}(t) dt\n$$\nwhere $C_{A_m q}(t) = \\langle A_m(0) q(t) \\rangle$.\n\nThe implementation proceeds through the following computational steps:\n\nFirst, we generate the synthetic time series for each mode-resolved heat flux, $A_m(t)$, and the noise, $\\eta(t)$. These are modeled as Ornstein-Uhlenbeck (OU) processes, which are stationary Gaussian processes characterized by a zero mean, a stationary standard deviation $\\sigma$, and an exponential autocorrelation decay with a correlation time $\\tau$. For a discrete time step $\\Delta t$, a time series $\\{x_i\\}$ for an OU process can be generated using the exact update rule:\n$$\nx_{i+1} = x_i \\exp(-\\Delta t/\\tau) + \\sigma \\sqrt{1 - \\exp(-2\\Delta t/\\tau)} Z_i\n$$\nwhere $Z_i$ is a sequence of independent and identically distributed random numbers drawn from a standard normal distribution. We generate each $A_m(t)$ and $\\eta(t)$ using this rule with their specified parameters $(\\tau_m, \\sigma_m)$ and $(\\tau_{\\text{noise}}, \\sigma_{\\text{noise}})$, respectively. The total heat flux time series is then constructed as $q(i\\Delta t) = \\sum_m A_m(i\\Delta t) + \\eta(i\\Delta t)$.\n\nSecond, we compute the necessary time correlation functions from the discrete time series. For two time series $A$ and $B$ of length $N$, the unbiased estimator for the cross-correlation at a discrete time lag $k \\ge 0$ is:\n$$\nC_{AB}(k\\Delta t) = \\frac{1}{N-k} \\sum_{i=0}^{N-k-1} A(i\\Delta t) B((i+k)\\Delta t)\n$$\nThis formula is applied to calculate the total heat flux autocorrelation, $C_{qq}(t)$, and the mode-resolved cross-correlations, $C_{A_m q}(t)$.\n\nThird, we perform numerical integration of these correlation functions to obtain conductivity values. The infinite integral in the GK formula is ill-defined for finite, noisy data, as the correlation functions do not decay perfectly to zero. We therefore truncate the integral at a cutoff time, $t_{\\text{cut}} = k_{\\text{cut}}\\Delta t$. The cutoff lag, $k_{\\text{cut}}$, is determined by finding the smallest non-negative lag $k$ for which the magnitude of the normalized HFACF falls below a threshold: $|C_{qq}(k\\Delta t)| < 0.02 \\cdot C_{qq}(0)$. If this condition is not met within the available range of lags, a default cutoff of $k_{\\text{cut}} = \\lfloor N/4 \\rfloor$ is used. The definite integral from $0$ to $t_{\\text{cut}}$ is then computed numerically using the trapezoidal rule:\n$$\n\\int_0^{t_{\\text{cut}}} C(t) dt \\approx \\Delta t \\left( \\frac{C(0)+C(t_{\\text{cut}})}{2} + \\sum_{k=1}^{k_{\\text{cut}}-1} C(k\\Delta t) \\right)\n$$\nThis procedure yields the total thermal conductivity, $\\kappa_{\\text{total}}$, from $C_{qq}(t)$, and the raw modal contributions, $\\kappa_m^{\\text{raw}}$, from each $C_{A_m q}(t)$.\n\nFinally, due to statistical noise and the presence of the $\\eta(t)$ term, the sum of raw contributions, $\\sum_m \\kappa_m^{\\text{raw}}$, may not equal $\\kappa_{\\text{total}}$. To enforce self-consistency, the raw contributions are rescaled:\n$$\n\\kappa_m^{\\text{rescaled}} = \\kappa_m^{\\text{raw}} \\cdot \\frac{\\kappa_{\\text{total}}}{\\sum_j \\kappa_j^{\\text{raw}}}\n$$\nThis ensures that $\\sum_m \\kappa_m^{\\text{rescaled}} = \\kappa_{\\text{total}}$. The dominant vibrational mode, $m^\\star$, is then identified as the mode with the largest rescaled contribution, $\\kappa_{m^\\star}^{\\text{rescaled}}$. The zero-based index $m^\\star$ is the final result for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the dominant mode contribution to thermal conductivity\n    based on the Green-Kubo formalism and mode-resolved analysis.\n    \"\"\"\n    KB_CONST = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"T\": 300.0, \"V\": 1.0e-28, \"dt\": 1.0e-14, \"N\": 8192,\n            \"tau_m\": [5.0e-13, 2.0e-13, 1.0e-13],\n            \"sigma_m\": [1.0e8, 3.0e8, 8.0e7],\n            \"tau_noise\": 1.0e-13, \"sigma_noise\": 5.0e7,\n            \"seed\": 42\n        },\n        {\n            \"T\": 300.0, \"V\": 1.0e-28, \"dt\": 1.0e-14, \"N\": 8192,\n            \"tau_m\": [5.0e-13, 2.0e-13, 1.0e-13],\n            \"sigma_m\": [0.0, 2.0e8, 0.0],\n            \"tau_noise\": 1.0e-13, \"sigma_noise\": 5.0e7,\n            \"seed\": 43\n        },\n        {\n            \"T\": 300.0, \"V\": 1.0e-28, \"dt\": 1.0e-14, \"N\": 2048,\n            \"tau_m\": [5.0e-13, 1.0e-13, 5.0e-14],\n            \"sigma_m\": [1.0e8, 1.0e8, 1.0e8],\n            \"tau_noise\": 1.0e-13, \"sigma_noise\": 5.0e7,\n            \"seed\": 44\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        T = case[\"T\"]\n        V = case[\"V\"]\n        dt = case[\"dt\"]\n        N = case[\"N\"]\n        tau_m_list = case[\"tau_m\"]\n        sigma_m_list = case[\"sigma_m\"]\n        tau_noise = case[\"tau_noise\"]\n        sigma_noise = case[\"sigma_noise\"]\n        seed = case[\"seed\"]\n        num_modes = len(tau_m_list)\n\n        rng = np.random.default_rng(seed)\n\n        def generate_ou_process(tau, sigma, dt, N, rng_instance):\n            \"\"\"Generates an Ornstein-Uhlenbeck process time series.\"\"\"\n            if tau == 0 or sigma == 0:\n                return np.zeros(N)\n            \n            # Precompute constants for the update rule\n            exp_factor = np.exp(-dt / tau)\n            # The scaling factor ensures the stationary variance is sigma**2\n            noise_coeff = sigma * np.sqrt(1 - exp_factor**2)\n            \n            x = np.zeros(N)\n            # Initialize from the stationary distribution\n            x[0] = rng_instance.normal(0, sigma)\n            \n            # Generate standard normal random numbers\n            Z = rng_instance.standard_normal(N - 1)\n            \n            for i in range(N - 1):\n                x[i+1] = x[i] * exp_factor + noise_coeff * Z[i]\n            \n            return x\n\n        # Generate mode-resolved flux signals\n        A_m_series = [generate_ou_process(tau_m, sigma_m, dt, N, rng)\n                      for tau_m, sigma_m in zip(tau_m_list, sigma_m_list)]\n\n        # Generate noise signal\n        noise_series = generate_ou_process(tau_noise, sigma_noise, dt, N, rng)\n\n        # Calculate total heat flux signal\n        q_series = np.sum(A_m_series, axis=0) + noise_series\n        \n        def calculate_correlation(series_A, series_B, max_lag):\n            \"\"\"\n            Calculates the unbiased cross-correlation C_AB(k*dt) for k in [0, max_lag].\n            C_AB(t) = <A(0)B(t)>\n            \"\"\"\n            N = len(series_A)\n            # np.correlate computes sum_n B[n+k] * A[n], which matches <A(0)B(t)>\n            # where B is series_B and A is series_A\n            full_corr = np.correlate(series_B, series_A, mode='full')\n            \n            # Extract correlations for non-negative lags\n            lags = np.arange(max_lag + 1)\n            corr_values = full_corr[N - 1 : N + max_lag]\n            \n            # Normalization for the unbiased estimator\n            norm = N - lags\n            \n            return corr_values / norm\n\n        # Determine integration cutoff from total heat flux autocorrelation\n        # Search up to the maximum possible lag\n        max_possible_lag = N - 1\n        C_qq = calculate_correlation(q_series, q_series, max_possible_lag)\n        C_qq_0 = C_qq[0]\n        \n        cutoff_lag = N // 4  # Default cutoff\n        if C_qq_0 > 0:\n            threshold = 0.02 * C_qq_0\n            # Search for the first lag where magnitude drops below threshold\n            decay_indices = np.where(np.abs(C_qq[1:])  threshold)[0]\n            if len(decay_indices) > 0:\n                # Add 1 because we searched from C_qq[1:]\n                cutoff_lag = decay_indices[0] + 1\n        \n        # Calculate total thermal conductivity\n        gk_prefactor = V / (KB_CONST * T**2)\n        integral_C_qq = np.trapz(C_qq[:cutoff_lag+1], dx=dt)\n        kappa_total = gk_prefactor * integral_C_qq\n        \n        # Calculate raw mode contributions\n        kappa_raw_list = []\n        for m in range(num_modes):\n            C_Am_q = calculate_correlation(A_m_series[m], q_series, cutoff_lag)\n            integral_C_Am_q = np.trapz(C_Am_q, dx=dt)\n            kappa_m_raw = gk_prefactor * integral_C_Am_q\n            kappa_raw_list.append(kappa_m_raw)\n\n        # Rescale mode contributions\n        raw_sum = np.sum(kappa_raw_list)\n        if np.isclose(raw_sum, 0):\n            # Handle case where all raw contributions are zero\n            kappa_rescaled = np.zeros(num_modes)\n        else:\n            rescale_factor = kappa_total / raw_sum\n            kappa_rescaled = [k * rescale_factor for k in kappa_raw_list]\n        \n        # Identify dominant mode\n        dominant_mode_index = np.argmax(kappa_rescaled)\n        results.append(dominant_mode_index)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Molecular dynamics simulations are necessarily performed on finite systems, and the choice of boundary conditions can have profound, often subtle, effects on measured dynamical properties. This exercise explores the impact of periodic boundary conditions on long-time correlations, a critical source of systematic error in transport calculations . You will use hydrodynamic theory to derive the leading-order finite-size correction to the diffusion coefficient and numerically verify how this correction manifests in the intermediate scattering function.",
            "id": "3496764",
            "problem": "Consider a simple isothermal suspension in which the coarse-grained number density field $\\rho(\\mathbf{x},t)$ evolves under overdamped conditions so that, at long wavelengths and long times, it is governed by linear hydrodynamic laws. The fundamental base is that the density obeys the continuity equation $\\partial_t \\rho + \\nabla \\cdot \\mathbf{J} = 0$ and a constitutive relation for the current consistent with equilibrium fluctuation-dissipation, such that for a conserved scalar the linear response is diffusive with a collective diffusion coefficient $D$. In a cubic domain of side length $L$ with periodic boundary conditions (PBC), the allowed wavevectors are $\\mathbf{k} = \\frac{2\\pi}{L}(n_x,n_y,n_z)$ with integers $n_x,n_y,n_z$, and the smallest nonzero magnitude is $k_{\\min} = \\frac{2\\pi}{L}$. The intermediate scattering function $F(k,t)$ (the normalized autocorrelation of the Fourier-transformed density mode of magnitude $k$) exhibits hydrodynamic relaxation at small $k$ and long times.\n\nTask 1 (Derivation): Starting from the continuity equation and linear response for a conserved scalar in an isothermal solvent, derive the small-$k$ and long-time form of $F(k,t)$ and show that its decay rate depends on the collective diffusion coefficient $D$. Then, using hydrodynamic arguments for Stokes flow and the Green's function (Oseen tensor) in a periodic domain, derive the leading finite-size correction to the collective mobility arising from periodic images. Combine this with the Einstein relation to obtain the leading finite-size correction to the collective diffusion coefficient in the form $D(L) = D(\\infty) + \\delta D(L)$, where $\\delta D(L)$ scales as $1/L$ with a geometry-dependent dimensionless constant for cubic PBC. Determine the sign and scaling of $\\delta D(L)$ and express it in terms of the Boltzmann constant $k_{\\mathrm{B}}$, the absolute temperature $T$, the solvent shear viscosity $\\eta$, and the box size $L$, introducing a geometry constant $\\xi_{\\mathrm{cubic}}$. You may take the numerical value of the cubic PBC geometry constant from hydrodynamic lattice sums as a known dimensionless number $\\xi_{\\mathrm{cubic}} = 2.837297$.\n\nTask 2 (Numerical verification): Implement a program that, for specified physically plausible parameters, computes $F(k,t)$ using the derived hydrodynamic form at small $k$ with and without the finite-size correction to $D$. Use the relation\n$$\nF(k,t) = \\exp\\!\\big(- D\\,k^2\\, t\\big)\n$$\nto generate $F_{\\infty}(k,t)$ with $D(\\infty)$ and $F_{L}(k,t)$ with $D(L)$. From these, estimate the finite-size diffusion correction numerically via\n$$\n\\delta D_{\\mathrm{est}}(L) = \\left[\\frac{-\\ln F_{L}(k,t)}{k^2 t}\\right] - \\left[\\frac{-\\ln F_{\\infty}(k,t)}{k^2 t}\\right],\n$$\nand compare it to your derived $\\delta D(L)$ to verify the hydrodynamic finite-size correction.\n\nPhysical and numerical parameters (use the International System of Units): Boltzmann constant $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$, absolute temperature $T = 300\\,\\mathrm{K}$, solvent shear viscosity $\\eta = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\,s}$, spherical particle hydrodynamic radius $a = 5.0\\times 10^{-8}\\,\\mathrm{m}$. The infinite-system collective diffusion coefficient is set by the Stokes-Einstein relation $D(\\infty) = \\frac{k_{\\mathrm{B}} T}{6\\pi \\eta a}$. For the wavevector, use the smallest nonzero mode $k = k_{\\min} = \\frac{2\\pi}{L}$ in each test case. Times must be expressed in seconds.\n\nTest suite: Evaluate the following four cases, each specified by the box size $L$ and the evaluation time $t$, both in the International System of Units. The program must compute $F_{\\infty}(k,t)$ and $F_{L}(k,t)$ for each case, estimate $\\delta D_{\\mathrm{est}}(L)$, compute the theoretical $\\delta D(L)$ from your derivation, and report whether the relative difference between $\\delta D_{\\mathrm{est}}(L)$ and $\\delta D(L)$ is within a tolerance of $0.05$ (that is, within $5$ percent as a decimal). The cases are:\n- Case $1$: $L = 1.0\\times 10^{-6}\\,\\mathrm{m}$, $t = 1.0\\times 10^{-4}\\,\\mathrm{s}$.\n- Case $2$: $L = 5.0\\times 10^{-7}\\,\\mathrm{m}$, $t = 5.0\\times 10^{-5}\\,\\mathrm{s}$.\n- Case $3$: $L = 2.0\\times 10^{-7}\\,\\mathrm{m}$, $t = 1.0\\times 10^{-5}\\,\\mathrm{s}$.\n- Case $4$: $L = 5.0\\times 10^{-6}\\,\\mathrm{m}$, $t = 2.0\\times 10^{-4}\\,\\mathrm{s}$.\n\nAnswer specification and output format: Your program should produce a single line of output containing the verification results for the four cases as a comma-separated list of booleans enclosed in square brackets, for example, $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$. Each boolean indicates whether $\\left|\\delta D_{\\mathrm{est}}(L) - \\delta D(L)\\right|/\\left|\\delta D(L)\\right| \\le 0.05$ in its respective case. All internal calculations must consistently use the International System of Units.",
            "solution": "The problem has been validated and is deemed a valid, scientifically grounded, and well-posed problem in the domain of computational statistical mechanics. It asks for a standard theoretical derivation followed by a numerical verification, with all necessary parameters and relations provided.\n\nThe solution proceeds in two parts as requested: derivation and numerical implementation.\n\n### Task 1: Derivation\n\n#### Form of the Intermediate Scattering Function $F(k,t)$\nThe evolution of the number density fluctuation, $\\delta\\rho(\\mathbf{x},t) = \\rho(\\mathbf{x},t) - \\langle\\rho\\rangle$, is governed by the continuity equation:\n$$ \\partial_t \\delta\\rho(\\mathbf{x},t) + \\nabla \\cdot \\mathbf{J}(\\mathbf{x},t) = 0 $$\nFor a conserved scalar quantity at long wavelengths and long times, the system exhibits a linear diffusive response. The current $\\mathbf{J}$ is related to the density gradient by Fick's first law:\n$$ \\mathbf{J}(\\mathbf{x},t) = -D \\nabla \\delta\\rho(\\mathbf{x},t) $$\nwhere $D$ is the collective diffusion coefficient. Substituting the constitutive relation into the continuity equation yields the diffusion equation for density fluctuations:\n$$ \\partial_t \\delta\\rho(\\mathbf{x},t) = D \\nabla^2 \\delta\\rho(\\mathbf{x},t) $$\nTo analyze the dynamics of different spatial modes, we perform a Fourier transform. Let $\\delta\\hat{\\rho}(\\mathbf{k},t)$ be the Fourier transform of $\\delta\\rho(\\mathbf{x},t)$. The diffusion equation in Fourier space becomes a first-order ordinary differential equation for each wavevector $\\mathbf{k}$:\n$$ \\frac{d}{dt}\\delta\\hat{\\rho}(\\mathbf{k},t) = -D k^2 \\delta\\hat{\\rho}(\\mathbf{k},t) $$\nwhere $k = |\\mathbf{k}|$. The solution to this equation is an exponential decay:\n$$ \\delta\\hat{\\rho}(\\mathbf{k},t) = \\delta\\hat{\\rho}(\\mathbf{k},0) \\exp(-D k^2 t) $$\nThe intermediate scattering function, $F(k,t)$, is defined as the time autocorrelation function of the Fourier density modes, normalized by its value at $t=0$:\n$$ F(k,t) = \\frac{\\langle \\delta\\hat{\\rho}(\\mathbf{k},t) \\delta\\hat{\\rho}(-\\mathbf{k},0) \\rangle}{\\langle |\\delta\\hat{\\rho}(\\mathbf{k},0)|^2 \\rangle} $$\nSubstituting the solution for $\\delta\\hat{\\rho}(\\mathbf{k},t)$ into this definition, we obtain:\n$$ F(k,t) = \\frac{\\langle \\delta\\hat{\\rho}(\\mathbf{k},0) \\exp(-D k^2 t) \\delta\\hat{\\rho}(-\\mathbf{k},0) \\rangle}{\\langle |\\delta\\hat{\\rho}(\\mathbf{k},0)|^2 \\rangle} = \\exp(-D k^2 t) \\frac{\\langle |\\delta\\hat{\\rho}(\\mathbf{k},0)|^2 \\rangle}{\\langle |\\delta\\hat{\\rho}(\\mathbf{k},0)|^2 \\rangle} $$\nThus, the hydrodynamic form of the intermediate scattering function is:\n$$ F(k,t) = \\exp(-D k^2 t) $$\nThe decay rate, $\\Gamma_k = D k^2$, is directly proportional to the collective diffusion coefficient $D$.\n\n#### Finite-Size Correction to the Diffusion Coefficient\nThe collective diffusion coefficient $D$ in a simulation is size-dependent due to the periodic boundary conditions (PBC). For a dilute suspension, $D$ is approximated by the self-diffusion coefficient of a single particle. Through the Einstein relation, the diffusion coefficient $D$ is connected to the particle mobility $\\mu$ by $D = k_{\\mathrm{B}} T \\mu$, where $k_{\\mathrm{B}}$ is the Boltzmann constant and $T$ is the absolute temperature. The mobility $\\mu$ relates the particle's velocity $\\mathbf{v}$ to an external force $\\mathbf{F}$ via $\\mathbf{v} = \\mu \\mathbf{F}$.\n\nIn an infinite system, the mobility of a spherical particle of hydrodynamic radius $a$ in a solvent of viscosity $\\eta$ is given by the Stokes law, $\\mu(\\infty) = (6\\pi\\eta a)^{-1}$. The corresponding infinite-system diffusion coefficient is the Stokes-Einstein expression, $D(\\infty) = k_{\\mathrm{B}} T / (6\\pi\\eta a)$.\n\nIn a periodic system of side length $L$, a particle at the origin interacts with its periodic images located at lattice vectors $\\mathbf{R} = L(n_x, n_y, n_z)$ for integers $(n_x,n_y,n_z) \\neq (0,0,0)$. When a force $\\mathbf{F}$ is applied to the particle, the same force is effectively applied to all its images. The velocity of the central particle is the sum of its velocity in an infinite fluid and the fluid velocity contributions induced by the motion of all its images. This induced velocity field is described by the Oseen tensor $\\mathbf{T}(\\mathbf{r})$, which is the Green's function for the Stokes equation. The velocity of the particle is therefore:\n$$ \\mathbf{v} = \\mu(\\infty)\\mathbf{F} + \\sum_{\\mathbf{R}\\neq 0} \\mathbf{T}(\\mathbf{R}) \\cdot \\mathbf{F} $$\nThe effective mobility in the periodic system, $\\mu(L)$, is thus:\n$$ \\mu(L) = \\mu(\\infty) + \\sum_{\\mathbf{R}\\neq 0} T_{\\alpha\\alpha}(\\mathbf{R}) $$\nwhere we assume an isotropic sum for a cubic lattice, so the mobility tensor is a scalar multiple of the identity tensor. The Oseen tensor is $\\mathbf{T}(\\mathbf{r}) = \\frac{1}{8\\pi\\eta |\\mathbf{r}|}(\\mathbf{I} + \\frac{\\mathbf{r}\\mathbf{r}}{|\\mathbf{r}|^2})$. The trace is $\\mathrm{Tr}(\\mathbf{T}) = \\frac{1}{2\\pi\\eta|\\mathbf{r}|}$. The scalar sum is then $\\frac{1}{3}\\sum \\mathrm{Tr}(\\mathbf{T})$. A more careful analysis shows the correction to mobility is $\\frac{1}{6\\pi \\eta L} \\xi_{\\mathrm{cubic}}$, where $\\xi_{\\mathrm{cubic}}$ is a dimensionless constant from the lattice sum of the Oseen tensor. The corrected mobility is:\n$$ \\mu(L) = \\mu(\\infty) + \\frac{\\xi_{\\mathrm{cubic}}}{6\\pi\\eta L} = \\frac{1}{6\\pi\\eta a} + \\frac{\\xi_{\\mathrm{cubic}}}{6\\pi\\eta L} $$\nUsing the Einstein relation, we find the size-dependent diffusion coefficient $D(L)$:\n$$ D(L) = k_{\\mathrm{B}} T \\mu(L) = k_{\\mathrm{B}} T \\left( \\frac{1}{6\\pi\\eta a} + \\frac{\\xi_{\\mathrm{cubic}}}{6\\pi\\eta L} \\right) = \\frac{k_{\\mathrm{B}} T}{6\\pi\\eta a} + \\frac{k_{\\mathrm{B}} T \\xi_{\\mathrm{cubic}}}{6\\pi\\eta L} $$\nThis expression has the form $D(L) = D(\\infty) + \\delta D(L)$, where the leading finite-size correction term $\\delta D(L)$ is:\n$$ \\delta D(L) = \\frac{k_{\\mathrm{B}} T \\xi_{\\mathrm{cubic}}}{6\\pi \\eta L} $$\nThis correction is positive, indicating an enhancement of diffusion due to the hydrodynamic interactions with periodic images, and scales as $1/L$.\n\n### Task 2: Numerical Verification\nThe numerical task is to verify this derived correction. We use the given parameters:\n- Boltzmann constant: $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$\n- Temperature: $T = 300\\,\\mathrm{K}$\n- Viscosity: $\\eta = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\,s}$\n- Particle radius: $a = 5.0\\times 10^{-8}\\,\\mathrm{m}$\n- Cubic geometry constant: $\\xi_{\\mathrm{cubic}} = 2.837297$\n\nWe will compute:\n1.  The infinite-system diffusion coefficient: $D(\\infty) = \\frac{k_{\\mathrm{B}} T}{6\\pi \\eta a}$.\n2.  The theoretical finite-size correction: $\\delta D(L) = \\frac{k_{\\mathrm{B}} T \\xi_{\\mathrm{cubic}}}{6\\pi \\eta L}$.\n3.  The finite-size diffusion coefficient: $D(L) = D(\\infty) + \\delta D(L)$.\n4.  The wavevector for the smallest mode: $k = k_{\\min} = \\frac{2\\pi}{L}$.\n5.  The scattering functions $F_{\\infty}(k,t) = \\exp(-D(\\infty)k^2t)$ and $F_{L}(k,t) = \\exp(-D(L)k^2t)$.\n6.  The numerically estimated correction: $\\delta D_{\\mathrm{est}}(L) = \\left[\\frac{-\\ln F_{L}(k,t)}{k^2 t}\\right] - \\left[\\frac{-\\ln F_{\\infty}(k,t)}{k^2 t}\\right]$.\n\nBy substituting the expressions for $F_L(k,t)$ and $F_\\infty(k,t)$ into the formula for $\\delta D_{\\mathrm{est}}(L)$, we find:\n$$ \\delta D_{\\mathrm{est}}(L) = \\frac{-(-D(L)k^2t)}{k^2 t} - \\frac{-(-D(\\infty)k^2t)}{k^2 t} = D(L) - D(\\infty) $$\nSince we defined $D(L) = D(\\infty) + \\delta D(L)$, it follows that $D(L) - D(\\infty) = \\delta D(L)$. Therefore, algebraically, $\\delta D_{\\mathrm{est}}(L)$ is identical to the theoretical $\\delta D(L)$. The numerical verification $\\left|\\delta D_{\\mathrm{est}}(L) - \\delta D(L)\\right|/\\left|\\delta D(L)\\right| \\le 0.05$ thus serves as a check on the correct implementation of the formulas, ensuring that numerical floating-point errors do not lead to a significant discrepancy. Given the nature of the calculation, the relative error is expected to be close to machine precision, and thus well within the $5\\%$ tolerance. The program will implement these calculations for the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying the finite-size correction to the \n    collective diffusion coefficient in a periodic system.\n    \"\"\"\n    # Define physical and numerical parameters in SI units.\n    k_B = 1.380649e-23  # Boltzmann constant (J/K)\n    T_abs = 300.0       # Absolute temperature (K)\n    eta = 1.0e-3        # Solvent shear viscosity (Pa.s)\n    a = 5.0e-8          # Hydrodynamic radius (m)\n    xi_cubic = 2.837297 # Geometry constant for cubic PBC\n    tolerance = 0.05    # Relative difference tolerance\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (L, t) with L in meters and t in seconds.\n    test_cases = [\n        (1.0e-6, 1.0e-4),  # Case 1\n        (5.0e-7, 5.0e-5),  # Case 2\n        (2.0e-7, 1.0e-5),  # Case 3\n        (5.0e-6, 2.0e-4),  # Case 4\n    ]\n\n    results = []\n    \n    # Calculate the infinite-system diffusion coefficient (Stokes-Einstein)\n    D_inf = (k_B * T_abs) / (6 * np.pi * eta * a)\n\n    for L, t in test_cases:\n        # Task 1: Calculate the theoretical finite-size correction\n        delta_D_L_theoretical = (k_B * T_abs * xi_cubic) / (6 * np.pi * eta * L)\n\n        # Calculate the size-dependent diffusion coefficient\n        D_L = D_inf + delta_D_L_theoretical\n\n        # Use the smallest nonzero wavevector magnitude\n        k = 2 * np.pi / L\n\n        # Task 2: Compute F(k,t) with and without finite-size corrections\n        # F_inf for the infinite system\n        F_inf = np.exp(-D_inf * k**2 * t)\n        \n        # F_L for the finite system of size L\n        F_L = np.exp(-D_L * k**2 * t)\n\n        # Estimate the finite-size diffusion correction numerically from F(k,t)\n        # delta_D_est = [-ln(F_L)/(k^2*t)] - [-ln(F_inf)/(k^2*t)]\n        # This simplifies algebraically to D_L - D_inf, which is delta_D_L_theoretical.\n        # The calculation is performed to mimic a real analysis and check for\n        # implementation or floating point issues.\n        term_L = -np.log(F_L) / (k**2 * t)\n        term_inf = -np.log(F_inf) / (k**2 * t)\n        delta_D_est = term_L - term_inf\n\n        # Verify if the relative difference is within the specified tolerance\n        # The absolute value of the theoretical value is used in the denominator.\n        if delta_D_L_theoretical != 0:\n            relative_difference = np.abs(delta_D_est - delta_D_L_theoretical) / np.abs(delta_D_L_theoretical)\n            is_verified = relative_difference = tolerance\n        else:\n            # If the theoretical correction is zero, the estimated one must also be zero.\n            is_verified = np.isclose(delta_D_est, 0)\n        \n        results.append(is_verified.item())\n\n    # Final print statement in the exact required format.\n    # The problem asks for lowercase booleans, but Python's str(bool) is capitalized.\n    # The example [True,False,True,True] suggests capitalized is fine. If lowercase\n    # were strictly required, `str(r).lower()` would be used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}