{
    "hands_on_practices": [
        {
            "introduction": "在基于平面波的计算中，能量截断值 $E_{\\mathrm{cut}}$ 是一个核心参数，但它并非只是一个抽象的数字。该参数直接决定了用于描述电子波函数等物理量的实空间网格的精细程度，这对于精确描绘原子核附近波函数的剧烈振荡等特征至关重要。本实践将引导你从量子力学和采样理论的基本原理出发，推导 $E_{\\mathrm{cut}}$ 与实空间分辨率之间的关系，并应用该关系来预测给定赝势所需的最小能量截断值。",
            "id": "3440845",
            "problem": "您的任务是为解析模守恒赝势核心区的短波长特征所需的最小平面波能量截断构建一个基于第一性原理的预测器，然后使用一个简单的、具有物理动机的收敛模型对计算出的可观测量来验证该预测。请完全基于第一性原理和经过充分检验的事实，而非快捷公式进行工作。\n\n起点与目标：\n- 从动量为 $\\mathbf{p}$ 的电子平面波的非相对论动能出发，结合动量与波矢之间的德布罗意关系，以及实空间中带限函数的经典采样准则。基于这些，推导平面波能量截断与保留的最大倒格矢模长之间的关系，以及实空间采样分辨率与该倒易空间带宽之间的关系。\n- 使用这些推导出的关系，得到最小能量截断 $E_{\\mathrm{cut,min}}$ 的预测器，要求实空间网格能够解析半径为 $r_c$ 的赝势核心区的振荡特征，并满足核心直径 $2 r_c$ 至少由 $N$ 个格点采样的约束条件。\n- 使用一个为计算出的Bader电荷可观测量而构建的、具有物理动机的收敛模型，来验证预测的 $E_{\\mathrm{cut,min}}$。Bader电荷是通过电子密度中的零通量面分配给原子的积分电子电荷；其单位是电子数。假设该可观测量随着倒易空间带宽的增加而单调收敛，并且可以建模为指数趋近一个极限值的形式。\n\n使用的基本事实：\n- 非相对论粒子的动能为 $E = p^2/(2m)$，其中 $p$ 是动量，$m$ 是电子质量。\n- 德布罗意关系将动量与波矢联系起来：$p = \\hbar k$，其中 $k$ 是波矢的模长，$\\hbar$ 是约化普朗克常数。\n- 对于一个带限于最大波矢模长 $G_{\\max}$ 的函数，其实空间采样需要一个不大于奈奎斯特间距的网格间距，该间距与 $G_{\\max}$ 成反比。\n- 单位与换算：能量以电子伏特 (eV) 表示，长度以埃 ($\\mathrm{\\AA}$) 表示，电子质量以千克 ($\\mathrm{kg}$) 表示，约化普朗克常数以焦耳·秒 ($\\mathrm{J\\cdot s}$) 表示。当从 $G_{\\max}$ 计算 $E_{\\mathrm{cut}}$ 时，根据需要使用精确的国际单位制（SI）常数和单位换算。\n\n预测准则：\n- 施加要求：核心直径 $2 r_c$ 至少由 $N$ 个点采样。这意味着实空间网格间距 $\\Delta x$ 必须满足 $\\Delta x \\le 2 r_c / N$。\n- 结合 $E_{\\mathrm{cut}}$、$G_{\\max}$ 和 $\\Delta x$ 之间的关系，以获得 $E_{\\mathrm{cut,min}}$ 作为 $r_c$ 和 $N$ 的函数。\n\n验证模型：\n- 设模拟的Bader电荷为 $Q(G_{\\max}) = Q_{\\infty} - A \\exp(-\\kappa G_{\\max})$，其中 $Q_{\\infty}$ 是 $G_{\\max} \\to \\infty$ 时的渐近值，$A$ 是一个正振幅，$\\kappa$ 是一个量纲为长度倒数的正常数衰减参数，使得 $\\kappa G_{\\max}$ 是无量纲的。假设 $Q(G_{\\max})$ 的单位是电子数。\n- 收敛准则定义如下：对于给定的 $E_{\\mathrm{cut}}$ 及其对应的 $G_{\\max}$，计算在缩放后的截断能 $\\alpha_1 E_{\\mathrm{cut}}$ 和 $\\alpha_2 E_{\\mathrm{cut}}$（其中 $\\alpha_1 > 1$ 且 $\\alpha_2 > \\alpha_1$）处的可观测量。如果可观测量幅值的两个连续差值均小于容差 $\\tau$（单位为电子数），则宣布收敛。\n\n数值要求与输出：\n- 在所有计算中使用以下国际单位制（SI）的物理常数：\n  - 电子质量 $m = 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg}$，\n  - 约化普朗克常数 $\\hbar = 1.054571817 \\times 10^{-34}\\,\\mathrm{J\\cdot s}$，\n  - 电子伏特到焦耳换算 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$，\n  - 埃到米换算 $1\\,\\mathrm{\\AA} = 1.0 \\times 10^{-10}\\,\\mathrm{m}$。\n- 以 eV 为单位表示预测的最小能量截断 $E_{\\mathrm{cut,min}}$，并四舍五入到一位小数。\n- 以 $\\mathrm{\\AA}$ 为单位表示相应的实空间网格间距 $\\Delta x$，并四舍五入到三位小数。\n- Bader电荷的单位是电子数；用于收敛判断的差值必须以电子数为单位计算。使用 $0.002$ 电子数的容差 $\\tau$。\n\n测试套件：\n- 使用代表氧（O）、氮（N）和氟（F）的三个赝势核心半径，其 $r_c$ 值和模型参数指定如下：\n  1. 氧：$r_c = 0.60\\,\\mathrm{\\AA}$，$N = 6$，$Q_{\\infty} = 6.0$ 电子数，$A = 0.5$ 电子数，$\\kappa = 0.30\\,\\mathrm{\\AA}^{-1}$。\n  2. 氮：$r_c = 0.55\\,\\mathrm{\\AA}$，$N = 6$，$Q_{\\infty} = 5.0$ 电子数，$A = 0.5$ 电子数，$\\kappa = 0.28\\,\\mathrm{\\AA}^{-1}$。\n  3. 氟：$r_c = 0.50\\,\\mathrm{\\AA}$，$N = 6$，$Q_{\\infty} = 7.0$ 电子数，$A = 0.5$ 电子数，$\\kappa = 0.32\\,\\mathrm{\\AA}^{-1}$。\n- 对于验证用的缩放因子，使用 $\\alpha_1 = 1.25$ 和 $\\alpha_2 = 1.50$。\n\n算法任务：\n- 推导并实现从 $E_{\\mathrm{cut}}$ 到 $G_{\\max}$ 以及从 $G_{\\max}$ 到 $\\Delta x$ 的映射。\n- 对于每个测试用例，根据 $r_c$ 和 $N$ 的约束计算预测的 $E_{\\mathrm{cut,min}}$。\n- 计算相应的 $\\Delta x$。\n- 通过在 $E_{\\mathrm{cut,min}}$、$\\alpha_1 E_{\\mathrm{cut,min}}$ 和 $\\alpha_2 E_{\\mathrm{cut,min}}$ 处评估模拟的Bader电荷来验证收敛性，并正确地将每个能量转换为 $G_{\\max}$。报告基于连续差值的收敛准则是否得到满足。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格列表的结果，每个测试用例一个条目，顺序为氧、氮、氟。\n- 每个条目必须是 $[E_{\\mathrm{cut,min}}, \\Delta x, \\text{converged}]$ 形式的列表，其中 $E_{\\mathrm{cut,min}}$ 是以 eV 为单位、四舍五入到一位小数的浮点数，$\\Delta x$ 是以 $\\mathrm{\\AA}$ 为单位、四舍五入到三位小数的浮点数，而 $\\text{converged}$ 是一个布尔值，指示在预测的截断能下验证标准是否成立。\n- 格式示例（使用占位符值）：$[[100.0,0.250,\\text{True}],[110.0,0.245,\\text{False}],[120.0,0.240,\\text{True}]]$。\n\n角度单位不适用。本问题不使用百分比。确保所有计算量均遵守指定的单位和四舍五入说明，并且程序不需要用户输入。",
            "solution": "该问题要求为计算材料学计算所需的最小平面波能量截断 $E_{\\mathrm{cut,min}}$ 推导一个预测模型，然后使用一个人工构建的收敛模型对该预测进行验证。整个过程将按照规定从第一性原理出发进行推导。\n\n### 第一部分：基本关系的推导\n\n基于平面波的电子结构方法（如密度泛函理论，DFT）的基础在于将波函数在一组平面波基组上展开。该基组的大小由一个能量截断值 $E_{\\mathrm{cut}}$ 控制。我们首先建立这个能量截断、它所定义的倒易空间带宽以及相应的实空间网格分辨率之间的关系。\n\n首先，我们考虑一个非相对论自由电子的动能 $E$。它由经典表达式给出：\n$$E = \\frac{p^2}{2m}$$\n其中 $p$ 是电子动量的模长，$m$ 是电子质量。德布罗意关系将该动量与电子波矢的模长 $k = |\\mathbf{k}|$ 联系起来：\n$$p = \\hbar k$$\n其中 $\\hbar$ 是约化普朗克常数。将德布罗意关系代入动能表达式，我们得到电子平面波的能量：\n$$E(k) = \\frac{(\\hbar k)^2}{2m} = \\frac{\\hbar^2 k^2}{2m}$$\n在平面波计算中，基组被截断，只包含动能最高达到指定截断值 $E_{\\mathrm{cut}}$ 的平面波。这意味着展开式包括所有满足 $\\frac{\\hbar^2 G^2}{2m} \\le E_{\\mathrm{cut}}$ 的倒格矢 $\\mathbf{G}$。因此，基组中包含的最大倒格矢的模长，记为 $G_{\\max}$，由该截断能决定：\n$$E_{\\mathrm{cut}} = \\frac{\\hbar^2 G_{\\max}^2}{2m}$$\n该方程提供了从倒易空间带宽 $G_{\\max}$到能量截断 $E_{\\mathrm{cut}}$ 的直接映射。我们可以将其反转，以求出给定 $E_{\\mathrm{cut}}$ 对应的 $G_{\\max}$：\n$$G_{\\max} = \\frac{\\sqrt{2m E_{\\mathrm{cut}}}}{\\hbar}$$\n接下来，我们将倒易空间带宽 $G_{\\max}$与实空间网格分辨率 $\\Delta x$ 联系起来。采样定理指出，为了无混叠地表示一个函数，采样率必须足够高。对于一个傅里叶分量在波矢模长大于 $G_{\\max}$ 时为零的函数，所需的最小采样分辨率与 $G_{\\max}$ 相关。平面波计算程序中的一个标准惯例是，根据基函数本身的类奈奎斯特准则来设置实空间网格间距 $\\Delta x$，以确保最高频率的基函数得到良好表示：\n$$\\Delta x \\le \\frac{\\pi}{G_{\\max}}$$\n为了在给定的 $G_{\\max}$ 下获得最高可能的分辨率（反之亦然），我们取等式：\n$$\\Delta x = \\frac{\\pi}{G_{\\max}}$$\n该关系意味着，更大的倒易空间带宽（更大的 $G_{\\max}$）对应于更精细的实空间网格（更小的 $\\Delta x$），这对于表示更短波长的特征是必需的。\n\n### 第二部分：$E_{\\mathrm{cut,min}}$ 预测器的推导\n\n我们的任务是推导一个预测器，用于预测解析赝势核心区内特征所需的最小能量截断 $E_{\\mathrm{cut,min}}$。问题提出了一个特定的实空间采样约束：赝势核心的直径 $2r_c$ 必须由至少 $N$ 个格点采样。这为最大允许的网格间距 $\\Delta x$ 提供了一个直接条件：\n$$N \\cdot \\Delta x \\le 2r_c \\quad \\implies \\quad \\Delta x \\le \\frac{2r_c}{N}$$\n为了在使用的能量截断尽可能低（从而 $\\Delta x$ 尽可能大）的同时满足此约束，我们将网格间距设置为其最大允许值：\n$$\\Delta x = \\frac{2r_c}{N}$$\n现在，我们可以结合我们推导出的关系。将这个 $\\Delta x$ 的表达式代入其与 $G_{\\max}$ 相关的方程中，我们可以找到所需的最小倒易空间带宽，我们称之为 $G_{\\mathrm{cut,min}}$：\n$$\\frac{2r_c}{N} = \\frac{\\pi}{G_{\\mathrm{cut,min}}} \\quad \\implies \\quad G_{\\mathrm{cut,min}} = \\frac{N\\pi}{2r_c}$$\n最后，我们将这个最小所需带宽 $G_{\\mathrm{cut,min}}$ 代入能量-波矢关系式，以求出预测的最小能量截断 $E_{\\mathrm{cut,min}}$：\n$$E_{\\mathrm{cut,min}} = \\frac{\\hbar^2 G_{\\mathrm{cut,min}}^2}{2m} = \\frac{\\hbar^2}{2m} \\left( \\frac{N\\pi}{2r_c} \\right)^2$$\n该公式基于赝势核心的物理尺寸 $r_c$ 和期望的采样密度 $N$，提供了一个直接、基于第一性原理的最小能量截断预测器。\n\n### 第三部分：验证过程\n\n为了验证此预测，我们使用一个人工模型来描述计算出的可观测量——Bader电荷 $Q$——作为倒易空间带宽 $G_{\\max}$ 函数的收敛行为。该模型以指数形式趋近一个渐近值 $Q_{\\infty}$：\n$$Q(G_{\\max}) = Q_{\\infty} - A e^{-\\kappa G_{\\max}}$$\n其中 $A$ 是一个正振幅，$\\kappa$ 是一个正常数衰减常数。\n\n验证协议如下：\n1.  对于每个具有给定参数 $r_c$, $N$, $Q_{\\infty}$, $A$ 和 $\\kappa$ 的测试用例（原子），首先计算预测的 $E_{\\mathrm{cut,min}}$ 和相应的 $\\Delta x$。\n2.  在此预测的截断能下评估可观测量 $Q$ 的收敛性。该准则涉及在按比例缩放的能量截断下检查 $Q$ 的连续差值。定义基础能量 $E_0 = E_{\\mathrm{cut,min}}$，以及两个更高的能量 $E_1 = \\alpha_1 E_0$ 和 $E_2 = \\alpha_2 E_0$，给定的缩放因子为 $\\alpha_1 = 1.25$ 和 $\\alpha_2 = 1.50$。\n3.  对于每个能量 $E_i$（其中 $i \\in \\{0, 1, 2\\}$），我们必须首先将其转换为相应的带宽 $G_{\\max,i}$，以便在 $Q$ 的模型中使用。这包括：\n    a.  将能量从电子伏特 ($\\mathrm{eV}$) 转换为焦耳 ($\\mathrm{J}$)，因为基本常数采用国际单位制（SI）。设 $e$ 为以库仑为单位的基本电荷，则 $E_{\\mathrm{J}} = E_{\\mathrm{eV}} \\cdot e$。\n    b.  使用 $G_{\\max,i} = \\frac{\\sqrt{2m E_{i, \\mathrm{J}}}}{\\hbar}$ 计算以 $\\mathrm{m}^{-1}$ 为单位的 $G_{\\max,i}$。\n    c.  将 $G_{\\max,i}$ 从 $\\mathrm{m}^{-1}$ 转换为 $\\mathrm{\\AA}^{-1}$，因为模型参数 $\\kappa$ 是以 $\\mathrm{\\AA}^{-1}$ 给出的。换算关系为 $G_{\\max,i} [\\mathrm{\\AA}^{-1}] = G_{\\max,i} [\\mathrm{m}^{-1}] \\cdot 10^{-10} \\mathrm{m}/\\mathrm{\\AA}$。\n4.  计算每个带宽下的可观测量：$Q_0 = Q(G_{\\max,0})$, $Q_1 = Q(G_{\\max,1})$ 和 $Q_2 = Q(G_{\\max,2})$。\n5.  检查是否满足收敛准则。如果可观测量的两个连续变化量均小于容差 $\\tau = 0.002$ 电子数，则认为预测得到了验证（“已收敛”）：\n    $$|Q_1 - Q_0|  \\tau \\quad \\text{and} \\quad |Q_2 - Q_1|  \\tau$$\n\n### 算法摘要\n\n最终的实现将对三个测试用例（氧、氮、氟）中的每一个执行以下步骤：\n1.  使用提供的 $r_c$（单位为 $\\mathrm{\\AA}$）和 $N$ 的值。\n2.  使用推导出的公式计算 $E_{\\mathrm{cut,min}}$（单位为 eV），确保所有物理常数（$\\hbar$, $m$, $e$）均为国际单位制（SI）单位，并正确应用 $\\mathrm{\\AA}$、$\\mathrm{m}$、$\\mathrm{eV}$ 和 $\\mathrm{J}$ 之间的换算。结果四舍五入到一位小数。\n3.  计算相应的实空间网格间距 $\\Delta x = 2r_c / N$（单位为 $\\mathrm{\\AA}$）。结果四舍五入到三位小数。\n4.  计算三个能量值 $E_0 = E_{\\mathrm{cut,min}}$（为保证精度使用未四舍五入的值）、$E_1 = 1.25 E_0$ 和 $E_2 = 1.50 E_0$。\n5.  对每个能量 $E_i$，计算相应的 $G_{\\max,i}$（单位为 $\\mathrm{\\AA}^{-1}$）。\n6.  使用该原子的特定模型参数（$Q_{\\infty}$, $A$, $\\kappa$），计算三个电荷值 $Q_0$、$Q_1$ 和 $Q_2$。\n7.  将绝对差值 $|Q_1 - Q_0|$ 和 $|Q_2 - Q_1|$ 与容差 $\\tau=0.002$ 进行比较，以确定是否满足收敛准则。\n8.  将每个原子的结果收集到一个形式为 $[E_{\\mathrm{cut,min}}, \\Delta x, \\text{converged}]$ 的列表中，并呈现在最终的列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a predictor for the plane-wave energy cutoff.\n    \"\"\"\n    \n    # Physical constants in SI units\n    M_E = 9.1093837015e-31  # Electron mass in kg\n    H_BAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    E_CHARGE = 1.602176634e-19 # Elementary charge in C (J/eV)\n    ANGSTROM_TO_METER = 1.0e-10 # Angstrom to meter conversion\n\n    # Validation parameters\n    ALPHA_1 = 1.25\n    ALPHA_2 = 1.50\n    TOLERANCE = 0.002  # electrons\n\n    # Define the test cases from the problem statement.\n    # (r_c [A], N, Q_inf [e], A [e], kappa [A^-1])\n    test_cases = [\n        # Oxygen\n        (0.60, 6, 6.0, 0.5, 0.30),\n        # Nitrogen\n        (0.55, 6, 5.0, 0.5, 0.28),\n        # Fluorine\n        (0.50, 6, 7.0, 0.5, 0.32),\n    ]\n\n    results = []\n\n    def get_charge(energy_ev, q_inf, amp, kappa):\n        \"\"\"\n        Calculates the Bader charge for a given energy cutoff using the model.\n        Args:\n            energy_ev (float): Energy cutoff in eV.\n            q_inf (float): Asymptotic charge value.\n            amp (float): Exponential model amplitude.\n            kappa (float): Exponential model decay constant in A^-1.\n        Returns:\n            float: The calculated Bader charge.\n        \"\"\"\n        # Convert energy from eV to Joules\n        energy_j = energy_ev * E_CHARGE\n        \n        # Calculate G_max in m^-1\n        # E = (hbar^2 * G_max^2) / (2 * m) = G_max = sqrt(2*m*E) / hbar\n        g_max_si = np.sqrt(2 * M_E * energy_j) / H_BAR\n        \n        # Convert G_max to A^-1 for the model\n        g_max_angstrom_inv = g_max_si * ANGSTROM_TO_METER\n        \n        # Calculate charge using the convergence model\n        # Q(G_max) = Q_inf - A * exp(-kappa * G_max)\n        charge = q_inf - amp * np.exp(-kappa * g_max_angstrom_inv)\n        return charge\n\n    for case in test_cases:\n        r_c_angstrom, n_samples, q_inf, amp, kappa = case\n        \n        # --- Prediction Step ---\n        \n        # Convert core radius to meters\n        r_c_meter = r_c_angstrom * ANGSTROM_TO_METER\n        \n        # Calculate the minimum required reciprocal-space bandwidth G_cut,min in m^-1\n        # G_cut,min = (N * pi) / (2 * r_c)\n        g_cut_min_si = (n_samples * np.pi) / (2 * r_c_meter)\n        \n        # Calculate predicted minimum energy cutoff E_cut,min in Joules\n        # E_cut,min = (hbar^2 * G_cut,min^2) / (2 * m)\n        e_cut_min_j = (H_BAR**2 * g_cut_min_si**2) / (2 * M_E)\n        \n        # Convert E_cut,min to eV\n        e_cut_min_ev = e_cut_min_j / E_CHARGE\n        \n        # Calculate the corresponding real-space grid spacing in Angstrom\n        # dx = 2 * r_c / N\n        delta_x_angstrom = (2 * r_c_angstrom) / n_samples\n        \n        # --- Validation Step ---\n        \n        # Define the three energy cutoffs for validation\n        e0 = e_cut_min_ev  # Use unrounded value for precision\n        e1 = ALPHA_1 * e0\n        e2 = ALPHA_2 * e0\n        \n        # Calculate the observable Q at each cutoff\n        q0 = get_charge(e0, q_inf, amp, kappa)\n        q1 = get_charge(e1, q_inf, amp, kappa)\n        q2 = get_charge(e2, q_inf, amp, kappa)\n        \n        # Check convergence criterion\n        diff1 = abs(q1 - q0)\n        diff2 = abs(q2 - q1)\n        \n        is_converged = (diff1  TOLERANCE) and (diff2  TOLERANCE)\n        \n        # --- Formatting Step ---\n        \n        # Round final results as per requirements\n        e_cut_min_rounded = round(e_cut_min_ev, 1)\n        delta_x_rounded = round(delta_x_angstrom, 3)\n        \n        results.append([e_cut_min_rounded, delta_x_rounded, is_converged])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly formats the inner lists and booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在结构优化过程中，当原子移动时，依赖于原子位置的基组（例如周期性晶胞中的平面波）会引入非物理的赝力，即Pulay力（Pulay force）。这种“幽灵”力并非源于真实的物理相互作用，若不加以处理，会导致错误的优化结构和能量。本实践通过一个简化的玩具模型，直观地展示了这些非物理力如何影响计算结果，并引导你评估和比较几种旨在缓解这一关键问题的计算策略。",
            "id": "3440811",
            "problem": "您的任务是构建一个可复现的、自洽的数值实验，用于分离和量化在结构弛豫过程中，当平面波动能截断值（表示为 $E_{\\mathrm{cut}}$）逐渐增加时出现的有限基组（Pulay）力赝象。目标是揭示由基组不完备性和基组变化产生的非保守力分量如何使优化后的几何结构产生偏差，并实现和评估两种缓解策略：固定基组弛豫和通过从力中显式移除主要的基组大小依赖性来进行的力修正弛豫。\n\n您的推导和程序设计应基于以下原理和事实：\n\n- Ritz 变分原理以及基态能量相对于波函数变分的定态性保证了，在一个完备且与位置无关的基组中，作用于原子坐标 $x$ 的力等于势能的负梯度，$F_{\\mathrm{true}}(x) = -\\partial V/\\partial x$。当基组不完备且依赖于如 $E_{\\mathrm{cut}}$ 等计算参数时，会出现额外的非变分力项；这些通常被称为 Pulay 力。\n- 对于一大类基组族，可观测量中的主要截断误差与基组大小的某个幂次成比例。在使用 $E_{\\mathrm{cut}}$ 截断的平面波中，一个广泛使用的关于计算量 $Q$ 的领头误差的拟设是 $Q(E_{\\mathrm{cut}}) \\approx Q(\\infty) + c E_{\\mathrm{cut}}^{-p}$，其中指数 $p  0$，振幅 $c$ 可能依赖于几何结构。\n\n构建一个一维玩具模型来模拟这些特征：\n\n- 定义一个标量自由度 $x$（单位为埃），它代表例如原子间距。真实势是谐振的，$V_{\\mathrm{true}}(x) = \\tfrac{1}{2} k (x - x_0)^2$，其刚度为 $k$（单位为 $\\mathrm{eV}/\\mathrm{\\AA}^2$），最小值点在 $x_0$（单位为 $\\mathrm{\\AA}$），因此真实力为 $F_{\\mathrm{true}}(x) = -k (x - x_0)$（单位为 $\\mathrm{eV}/\\mathrm{\\AA}$）。\n- 定义一个合成的 Pulay 力模型，该模型既能捕捉随 $E_{\\mathrm{cut}}$ 变化的幅值标度，也能模拟因快速变化特征的表示不完备而产生的与位置相关的涟波。使用\n$$\nF_{\\mathrm{Pulay}}(x, E_{\\mathrm{cut}}) = A \\left(\\frac{E_{\\mathrm{ref}}}{E_{\\mathrm{cut}}}\\right)^p \\left[1 + 0.1 \\sin\\!\\big(N(E_{\\mathrm{cut}})\\,\\phi_0\\big)\\right] \\sin\\!\\left(\\frac{2\\pi x}{L}\\right),\n$$\n其中 $A$（单位为 $\\mathrm{eV}/\\mathrm{\\AA}$）、$E_{\\mathrm{ref}}$（单位为 $\\mathrm{eV}$）、指数 $p  0$、空间周期 $L$（单位为 $\\mathrm{\\AA}$）、相位参数 $\\phi_0$（无量纲），以及一个离散化的基组指数\n$$\nN(E_{\\mathrm{cut}}) = \\left\\lfloor \\alpha \\sqrt{\\frac{E_{\\mathrm{cut}}}{1~\\mathrm{eV}}} \\right\\rfloor,\n$$\n其中 $\\alpha$（无量纲）控制着当 $E_{\\mathrm{cut}}$ 变化时调制器变化的频率。总的计算力为 $F_{\\mathrm{calc}}(x, E_{\\mathrm{cut}}) = F_{\\mathrm{true}}(x) + F_{\\mathrm{Pulay}}(x, E_{\\mathrm{cut}})$。\n- 实现一个简单的最速下降法几何弛豫方案，其更新规则为 $x_{n+1} = x_n + \\gamma F(x_n, E_{\\mathrm{cut},n})$，其中 $\\gamma$（单位为 $\\mathrm{\\AA}^2/\\mathrm{eV}$）是谐振势阱的一个稳定步长，而 $E_{\\mathrm{cut},n}$ 将根据下文规定固定或渐增。最多使用 $N_{\\max}$ 步，如果 $|F_{\\mathrm{used}}|  \\varepsilon_F$ 和 $|x_{n+1} - x_n|  \\varepsilon_x$ 同时满足，则提前停止，其中 $F_{\\mathrm{used}}$ 是特定弛豫策略实际使用的力。\n\n设计并实现三种弛豫策略：\n\n- 渐增截断能：$E_{\\mathrm{cut}}$ 在弛豫步骤中从 $E_{\\mathrm{start}}$ 线性增加到 $E_{\\mathrm{end}}$。在步骤 $n \\in \\{0,\\dots,N_{\\max}-1\\}$，使用 $E_{\\mathrm{cut},n} = E_{\\mathrm{start}} + \\frac{n}{\\max(1, N_{\\max}-1)} (E_{\\mathrm{end}} - E_{\\mathrm{start}})$，使用的力为 $F_{\\mathrm{used}} = F_{\\mathrm{calc}}(x_n, E_{\\mathrm{cut},n})$。\n- 固定基组（无渐增）：在所有步骤中，$E_{\\mathrm{cut}}$ 固定为 $E_{\\mathrm{end}}$，使用的力为 $F_{\\mathrm{used}} = F_{\\mathrm{calc}}(x_n, E_{\\mathrm{end}})$。\n- 力修正（双截断能外推）：在每一步，计算在两个截断能 $E_1$ 和 $E_2$ 下的 $F_{\\mathrm{calc}}(x_n, E_1)$ 和 $F_{\\mathrm{calc}}(x_n, E_2)$，其中 $E_1 = E_{\\mathrm{start}}$ 且 $E_2 = E_{\\mathrm{end}}$。假设领头的 $E_{\\mathrm{cut}}^{-p}$ 依赖关系在 Pulay 力中占主导地位，并根据这两个计算结果构建一个修正力 $F_{\\mathrm{used}}(x_n)$，以消除领头的 $E_{\\mathrm{cut}}^{-p}$ 项。使用这个 $F_{\\mathrm{used}}$ 来更新 $x$。\n\n对于每种策略，测量两个性能指标：\n\n- 几何偏差：收敛后的坐标与真实最小值之间的绝对偏差，即 $|x_{\\mathrm{final}} - x_0|$，单位为 $\\mathrm{\\AA}$。\n- 沿途轨迹的 Pulay 赝象均方根，定义为 $\\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left(F_{\\mathrm{used}}(x_m) - F_{\\mathrm{true}}(x_m)\\right)^2}$，单位为 $\\mathrm{eV}/\\mathrm{\\AA}$，其中求和遍历该策略所采取的所有步骤，$F_{\\mathrm{used}}(x_m)$ 是该策略在该步骤施加的力。\n\n实现您的程序，为以下三个测试案例中的每一个计算这两个指标。所有能量单位必须为电子伏特（$\\mathrm{eV}$），所有长度单位为埃（$\\mathrm{\\AA}$），力单位为电子伏特每埃（$\\mathrm{eV}/\\mathrm{\\AA}$）。几何偏差以 $\\mathrm{\\AA}$ 表示，均方根赝象以 $\\mathrm{eV}/\\mathrm{\\AA}$ 表示；打印不带单位符号的普通十进制数。\n\n测试套件：\n\n- 案例 1：$k = 5.0$, $x_0 = 1.5$, $x_{\\mathrm{init}} = 0.5$, $A = 0.25$, $p = 2.0$, $L = 1.0$, $E_{\\mathrm{ref}} = 1.0$, $E_{\\mathrm{start}} = 200.0$, $E_{\\mathrm{end}} = 600.0$, $\\alpha = 1.0$, $\\phi_0 = 0.7$, $\\gamma = 0.2$, $N_{\\max} = 300$, $\\varepsilon_F = 1.0\\times 10^{-6}$, $\\varepsilon_x = 1.0\\times 10^{-9}$。\n- 案例 2：$k = 3.0$, $x_0 = 2.0$, $x_{\\mathrm{init}} = 3.2$, $A = 0.6$, $p = 1.5$, $L = 1.0$, $E_{\\mathrm{ref}} = 1.0$, $E_{\\mathrm{start}} = 150.0$, $E_{\\mathrm{end}} = 400.0$, $\\alpha = 1.2$, $\\phi_0 = 0.9$, $\\gamma = 0.18$, $N_{\\max} = 400$, $\\varepsilon_F = 1.0\\times 10^{-6}$, $\\varepsilon_x = 1.0\\times 10^{-9}$。\n- 案例 3：$k = 0.8$, $x_0 = 0.8$, $x_{\\mathrm{init}} = -0.5$, $A = 0.7$, $p = 2.2$, $L = 1.2$, $E_{\\mathrm{ref}} = 1.0$, $E_{\\mathrm{start}} = 250.0$, $E_{\\mathrm{end}} = 350.0$, $\\alpha = 0.8$, $\\phi_0 = 1.1$, $\\gamma = 0.25$, $N_{\\max} = 500$, $\\varepsilon_F = 1.0\\times 10^{-6}$, $\\varepsilon_x = 1.0\\times 10^{-9}$。\n\n您的程序必须为每个案例运行所有三种策略并计算：\n- 渐增截断能的几何偏差，渐增截断能的均方根赝象，\n- 固定基组的几何偏差，固定基组的均方根赝象，\n- 力修正的几何偏差，力修正的均方根赝象。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含结果，形式为一个逗号分隔的列表，包含三个子列表，每个案例一个，顺序为案例1、案例2、案例3。每个子列表必须是包含六个十进制数的列表，顺序为 $[\\text{bias}_{\\mathrm{ramp}}, \\text{rms}_{\\mathrm{ramp}}, \\text{bias}_{\\mathrm{fixed}}, \\text{rms}_{\\mathrm{fixed}}, \\text{bias}_{\\mathrm{corr}}, \\text{rms}_{\\mathrm{corr}}]$。例如：$[[b_1,r_1,b_2,r_2,b_3,r_3],[\\dots],[\\dots]]$，使用不带单位符号的普通十进制数打印。",
            "solution": "### 步骤 1：提取给定信息\n\n该问题为一维结构弛豫模拟提供了以下数据、定义和模型组件，该模拟旨在研究 Pulay 力赝象。\n\n**模型定义：**\n- **自由度：** 单个标量坐标 $x$，单位为埃（$\\mathrm{\\AA}$）。\n- **真实势：** $V_{\\mathrm{true}}(x) = \\tfrac{1}{2} k (x - x_0)^2$，刚度为 $k$（单位 $\\mathrm{eV}/\\mathrm{\\AA}^2$），平衡位置为 $x_0$（单位 $\\mathrm{\\AA}$）。\n- **真实力：** $F_{\\mathrm{true}}(x) = -k (x - x_0)$，单位 $\\mathrm{eV}/\\mathrm{\\AA}$。\n- **合成 Pulay 力：**\n  $$\n  F_{\\mathrm{Pulay}}(x, E_{\\mathrm{cut}}) = A \\left(\\frac{E_{\\mathrm{ref}}}{E_{\\mathrm{cut}}}\\right)^p \\left[1 + 0.1 \\sin\\!\\big(N(E_{\\mathrm{cut}})\\,\\phi_0\\big)\\right] \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\n  $$\n  - **参数：** 振幅 $A$（$\\mathrm{eV}/\\mathrm{\\AA}$）、参考能量 $E_{\\mathrm{ref}}$（$\\mathrm{eV}$）、指数 $p$、空间周期 $L$（$\\mathrm{\\AA}$）和相位参数 $\\phi_0$（无量纲）。\n- **离散化基组指数：**\n  $$\n  N(E_{\\mathrm{cut}}) = \\left\\lfloor \\alpha \\sqrt{\\frac{E_{\\mathrm{cut}}}{1~\\mathrm{eV}}} \\right\\rfloor\n  $$\n  - **参数：** $\\alpha$（无量纲）。\n- **总计算力：** $F_{\\mathrm{calc}}(x, E_{\\mathrm{cut}}) = F_{\\mathrm{true}}(x) + F_{\\mathrm{Pulay}}(x, E_{\\mathrm{cut}})$。\n\n**弛豫方案：**\n- **更新规则：** $x_{n+1} = x_n + \\gamma F(x_n, E_{\\mathrm{cut},n})$，其中 $\\gamma$ 是步长，单位 $\\mathrm{\\AA}^2/\\mathrm{eV}$。\n- **最大步数：** $N_{\\max}$。\n- **收敛判据：** 如果 $|F_{\\mathrm{used}}|  \\varepsilon_F$ 和 $|x_{n+1} - x_n|  \\varepsilon_x$ 同时满足，则停止。\n\n**弛豫策略：**\n1.  **渐增截断能：**\n    - 第 $n$ 步的能量截断值：$E_{\\mathrm{cut},n} = E_{\\mathrm{start}} + \\frac{n}{\\max(1, N_{\\max}-1)} (E_{\\mathrm{end}} - E_{\\mathrm{start}})$，其中 $n \\in \\{0, \\dots, N_{\\max}-1\\}$。\n    - 使用的力：$F_{\\mathrm{used}} = F_{\\mathrm{calc}}(x_n, E_{\\mathrm{cut},n})$。\n2.  **固定基组（无渐增）：**\n    - 能量截断值：所有步骤中均为 $E_{\\mathrm{cut}} = E_{\\mathrm{end}}$。\n    - 使用的力：$F_{\\mathrm{used}} = F_{\\mathrm{calc}}(x_n, E_{\\mathrm{end}})$。\n3.  **力修正（双截断能外推）：**\n    - 用于评估的截断能：$E_1 = E_{\\mathrm{start}}$ 和 $E_2 = E_{\\mathrm{end}}$。\n    - 使用的力：$F_{\\mathrm{used}}(x_n)$ 是通过在 $E_1$ 和 $E_2$ 处的 $F_{\\mathrm{calc}}$ 的计算结果构建的，以消除领头的 $E_{\\mathrm{cut}}^{-p}$ 误差项。\n\n**性能指标：**\n1.  **几何偏差：** $|x_{\\mathrm{final}} - x_0|$，单位 $\\mathrm{\\AA}$。\n2.  **Pulay 赝象均方根：** $\\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left(F_{\\mathrm{used}}(x_m) - F_{\\mathrm{true}}(x_m)\\right)^2}$，单位 $\\mathrm{eV}/\\mathrm{\\AA}$，其中求和遍历所有 $M$ 个已执行的步骤。\n\n**测试套件数据：**\n- **案例 1：** $k = 5.0$, $x_0 = 1.5$, $x_{\\mathrm{init}} = 0.5$, $A = 0.25$, $p = 2.0$, $L = 1.0$, $E_{\\mathrm{ref}} = 1.0$, $E_{\\mathrm{start}} = 200.0$, $E_{\\mathrm{end}} = 600.0$, $\\alpha = 1.0$, $\\phi_0 = 0.7$, $\\gamma = 0.2$, $N_{\\max} = 300$, $\\varepsilon_F = 1.0 \\times 10^{-6}$, $\\varepsilon_x = 1.0 \\times 10^{-9}$。\n- **案例 2：** $k = 3.0$, $x_0 = 2.0$, $x_{\\mathrm{init}} = 3.2$, $A = 0.6$, $p = 1.5$, $L = 1.0$, $E_{\\mathrm{ref}} = 1.0$, $E_{\\mathrm{start}} = 150.0$, $E_{\\mathrm{end}} = 400.0$, $\\alpha = 1.2$, $\\phi_0 = 0.9$, $\\gamma = 0.18$, $N_{\\max} = 400$, $\\varepsilon_F = 1.0 \\times 10^{-6}$, $\\varepsilon_x = 1.0 \\times 10^{-9}$。\n- **案例 3：** $k = 0.8$, $x_0 = 0.8$, $x_{\\mathrm{init}} = -0.5$, $A = 0.7$, $p = 2.2$, $L = 1.2$, $E_{\\mathrm{ref}} = 1.0$, $E_{\\mathrm{start}} = 250.0$, $E_{\\mathrm{end}} = 350.0$, $\\alpha = 0.8$, $\\phi_0 = 1.1$, $\\gamma = 0.25$, $N_{\\max} = 500$, $\\varepsilon_F = 1.0 \\times 10^{-6}$, $\\varepsilon_x = 1.0 \\times 10^{-9}$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n- **科学上合理：** 该问题是计算材料科学中一个真实且重要现象的精心构建的玩具模型，即电子结构计算中 Pulay 力（或基组不完备性误差）的存在。该模型正确地指出了这些力的来源是与位置相关的基组，并使用了物理上合理的误差相对于计算截断参数 $E_{\\mathrm{cut}}$ 的幂律标度关系。Ritz 变分原理和力推导的概念被正确引用。\n- **定义明确：** 所有参数、初始条件和函数都已明确定义。任务是实现三种明确指定的数值算法，并为三个不同的测试案例计算两个明确定义的指标。整个设置是确定性的，能导出一个唯一、稳定且有意义的数值结果。\n- **客观性：** 问题陈述完全客观，使用精确的数学和计算语言。它不含主观论断或有争议的科学观点。\n- **完备性与一致性：** 该问题是自洽的。所有必需的公式、参数和程序均已提供。没有缺失的定义或矛盾的约束。例如，在所有测试案例中，$E_{\\mathrm{start}} \\neq E_{\\mathrm{end}}$，这避免了力修正公式中除以零的问题。\n- **真实性：** 尽管是一个玩具模型，但参数值对于原子尺度模拟而言数量级是合理的（例如，刚度 $k \\sim \\mathrm{eV}/\\mathrm{\\AA}^2$，长度单位为 $\\mathrm{\\AA}$，能量单位为 $\\mathrm{eV}$）。\n\n该问题通过了所有验证标准。它是一个严谨、定义明确且具有科学相关性的计算练习。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。我将继续提供完整的解决方案。\n\n### 基于原理的设计与求解\n\n这个问题的核心是实现并比较三种在存在基组依赖（Pulay）力的情况下进行结构弛豫的不同策略。我们将构建一个模块化程序，首先定义力模型，然后为三种指定策略中的每一种实现弛豫循环。\n\n**1. 力模型实现**\n\n我们首先根据问题中的定义实现力的不同分量的函数。\n\n- **真实力, $F_{\\mathrm{true}}(x)$：** 这是从真实谐振势推导出的力，$F_{\\mathrm{true}}(x) = -k(x - x_0)$。\n- **Pulay 力, $F_{\\mathrm{Pulay}}(x, E_{\\mathrm{cut}})$：** 此函数代表合成的赝象。它同时依赖于位置 $x$ 和能量截断值 $E_{\\mathrm{cut}}$。需要一个用于计算 $N(E_{\\mathrm{cut}})$ 的辅助函数。\n  - $N(E_{\\mathrm{cut}}) = \\lfloor \\alpha \\sqrt{E_{\\mathrm{cut}}} \\rfloor$。除以 $1~\\mathrm{eV}$ 是一个单位处理的手段，如果 $E_{\\mathrm{cut}}$ 被视为以 eV 为单位的数值，则此操作是隐式的。\n  - 然后，完整的表达式由其各部分组装而成：随 $E_{\\mathrm{cut}}$ 的幂律衰减、一个依赖于 $N(E_{\\mathrm{cut}})$ 的高频调制器和一个空间振荡。\n- **计算力, $F_{\\mathrm{calc}}(x, E_{\\mathrm{cut}})$：** 这是真实力与 Pulay 赝象之和，$F_{\\mathrm{calc}} = F_{\\mathrm{true}} + F_{\\mathrm{Pulay}}$。这是一个标准计算代码在给定几何结构和截断能下会报告的力。\n\n**2. 弛豫策略**\n\n实现一个基于最速下降更新规则 $x_{n+1} = x_n + \\gamma F_{\\mathrm{used}}$ 的单一弛豫引擎。决定 $F_{\\mathrm{used}}$ 的逻辑取决于所选的策略。\n\n- **策略 1：渐增截断能：** 该策略模拟了一种常见但有缺陷的做法，即在弛豫过程中逐渐提高基组质量以节省计算成本。在每一步 $n$，截断能 $E_{\\mathrm{cut},n}$ 在 $E_{\\mathrm{start}}$ 和 $E_{\\mathrm{end}}$ 之间进行线性插值。使用的力为 $F_{\\mathrm{used}} = F_{\\mathrm{calc}}(x_n, E_{\\mathrm{cut},n})$。由于 $E_{\\mathrm{cut},n}$ 在每一步都变化，力函数 $F_{\\mathrm{used}}(x, n)$ 不是任何固定势能面的梯度，这使得力是非保守的。这可能导致不正确的最终几何结构。\n\n- **策略 2：固定基组：** 这是单次弛豫的标准、正确方法。由 $E_{\\mathrm{cut}} = E_{\\mathrm{end}}$ 定义的基组在整个过程中保持不变。使用的力为 $F_{\\mathrm{used}} = F_{\\mathrm{calc}}(x_n, E_{\\mathrm{end}})$。虽然 Pulay 力仍然存在（因为 $E_{\\mathrm{end}}$ 是有限的），但它相对于一个固定的（但错误的）势能面 $V_{\\mathrm{calc}}(x, E_{\\mathrm{end}})$ 是保守的。弛豫将正确地找到这个*计算*势能面的最小值，但该最小值仍与真实最小值 $x_0$ 存在偏差。\n\n- **策略 3：力修正：** 这种高级策略旨在通过显式移除领头阶的基组误差来近似 $F_{\\mathrm{true}}(x)$。它依赖于拟设 $F_{\\mathrm{calc}}(x, E_{\\mathrm{cut}}) \\approx F_{\\mathrm{true}}(x) + C(x)E_{\\mathrm{cut}}^{-p}$。通过在两个不同的截断能 $E_1 = E_{\\mathrm{start}}$ 和 $E_2 = E_{\\mathrm{end}}$ 下计算力，我们得到了一个关于两个未知数 $F_{\\mathrm{true}}(x)$ 和 $C(x)$ 的二元线性方程组。\n  $$ F_{\\mathrm{calc}}(x, E_1) = F_{\\mathrm{true}}(x) + C(x)E_1^{-p} $$\n  $$ F_{\\mathrm{calc}}(x, E_2) = F_{\\mathrm{true}}(x) + C(x)E_2^{-p} $$\n  求解该方程组以得到 $F_{\\mathrm{true}}(x)$，我们找到外推的（或修正的）力：\n  $$ F_{\\mathrm{used}}(x) = F_{\\mathrm{true}}(x) \\approx \\frac{F_{\\mathrm{calc}}(x, E_1) E_1^p - F_{\\mathrm{calc}}(x, E_2) E_2^p}{E_1^p - E_2^p} $$\n  在弛豫的每一步都使用这个力。该方法有效地在每一步计算出对真实力的更好近似，旨在获得更准确的最终几何结构。\n\n**3. 指标计算**\n\n对于每次完成的弛豫，我们计算两个所需的指标。\n- **几何偏差：** 这简单地测量最终收敛位置的误差：$|x_{\\mathrm{final}} - x_0|$。\n- **RMS Pulay 赝象：** 该指标量化了算法使用的力沿弛豫路径与真实物理力的平均偏差。对于一个包含 $M$ 步的轨迹（从初始位置 $x_0^{\\mathrm{traj}}$ 到 $x_{M-1}^{\\mathrm{traj}}$），对应施加的力为 $F_{\\mathrm{used},0}, \\dots, F_{\\mathrm{used},M-1}$，RMS 赝象为：\n  $$ \\sqrt{\\frac{1}{M} \\sum_{i=0}^{M-1} \\left(F_{\\mathrm{used}, i} - F_{\\mathrm{true}}(x_{i}^{\\mathrm{traj}})\\right)^2} $$\n  这需要存储弛豫过程中的位置序列以及在这些位置上施加的力。\n\n最终的程序将系统地将三种策略中的每一种应用于每个测试案例，并按照要求格式报告每次运行的两个性能指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'k': 5.0, 'x0': 1.5, 'x_init': 0.5, 'A': 0.25, 'p': 2.0, 'L': 1.0, \n         'E_ref': 1.0, 'E_start': 200.0, 'E_end': 600.0, 'alpha': 1.0, \n         'phi0': 0.7, 'gamma': 0.2, 'N_max': 300, 'eps_F': 1.0e-6, 'eps_x': 1.0e-9},\n        # Case 2\n        {'k': 3.0, 'x0': 2.0, 'x_init': 3.2, 'A': 0.6, 'p': 1.5, 'L': 1.0, \n         'E_ref': 1.0, 'E_start': 150.0, 'E_end': 400.0, 'alpha': 1.2, \n         'phi0': 0.9, 'gamma': 0.18, 'N_max': 400, 'eps_F': 1.0e-6, 'eps_x': 1.0e-9},\n        # Case 3\n        {'k': 0.8, 'x0': 0.8, 'x_init': -0.5, 'A': 0.7, 'p': 2.2, 'L': 1.2, \n         'E_ref': 1.0, 'E_start': 250.0, 'E_end': 350.0, 'alpha': 0.8, \n         'phi0': 1.1, 'gamma': 0.25, 'N_max': 500, 'eps_F': 1.0e-6, 'eps_x': 1.0e-9},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        case_results = []\n        \n        # Strategy 1: Ramped Cutoff\n        bias_ramp, rms_ramp = run_relaxation('ramped', params)\n        case_results.extend([bias_ramp, rms_ramp])\n        \n        # Strategy 2: Fixed-Basis\n        bias_fixed, rms_fixed = run_relaxation('fixed', params)\n        case_results.extend([bias_fixed, rms_fixed])\n        \n        # Strategy 3: Force Correction\n        bias_corr, rms_corr = run_relaxation('corrected', params)\n        case_results.extend([bias_corr, rms_corr])\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified in the problem\n    result_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in all_results])}]\"\n    print(result_str)\n\ndef F_true(x, k, x0):\n    \"\"\"Calculates the true force F_true(x) = -k(x - x0).\"\"\"\n    return -k * (x - x0)\n\ndef F_pulay(x, Ecut, A, Eref, p, L, alpha, phi0):\n    \"\"\"Calculates the synthetic Pulay force.\"\"\"\n    if Ecut == 0: return 0.0\n    N_Ecut = np.floor(alpha * np.sqrt(Ecut))\n    prefactor = A * (Eref / Ecut)**p\n    modulator = 1.0 + 0.1 * np.sin(N_Ecut * phi0)\n    spatial_term = np.sin(2.0 * np.pi * x / L)\n    return prefactor * modulator * spatial_term\n\ndef F_calc(x, Ecut, k, x0, A, Eref, p, L, alpha, phi0):\n    \"\"\"Calculates the total force F_calc = F_true + F_Pulay.\"\"\"\n    return F_true(x, k, x0) + F_pulay(x, Ecut, A, Eref, p, L, alpha, phi0)\n    \ndef run_relaxation(strategy, params):\n    \"\"\"\n    Performs a structural relaxation for a given strategy and parameters.\n    Returns the geometry bias and RMS Pulay artifact.\n    \"\"\"\n    # Unpack parameters\n    k, x0, x_init = params['k'], params['x0'], params['x_init']\n    A, p, L, Eref = params['A'], params['p'], params['L'], params['E_ref']\n    E_start, E_end = params['E_start'], params['E_end']\n    alpha, phi0 = params['alpha'], params['phi0']\n    gamma, N_max = params['gamma'], params['N_max']\n    eps_F, eps_x = params['eps_F'], params['eps_x']\n\n    x = x_init\n    pos_trajectory = [x]\n    forces_used_list = []\n    \n    ramp_denom = max(1, N_max - 1)\n\n    for n in range(N_max):\n        current_x = pos_trajectory[-1]\n        F_used = 0.0\n\n        if strategy == 'ramped':\n            E_cut_n = E_start + n / ramp_denom * (E_end - E_start)\n            F_used = F_calc(current_x, E_cut_n, k, x0, A, Eref, p, L, alpha, phi0)\n        \n        elif strategy == 'fixed':\n            F_used = F_calc(current_x, E_end, k, x0, A, Eref, p, L, alpha, phi0)\n\n        elif strategy == 'corrected':\n            E1, E2 = E_start, E_end\n            F1 = F_calc(current_x, E1, k, x0, A, Eref, p, L, alpha, phi0)\n            F2 = F_calc(current_x, E2, k, x0, A, Eref, p, L, alpha, phi0)\n            \n            E1_p, E2_p = E1**p, E2**p\n            denom = E1_p - E2_p\n            # Denominator is non-zero because E_start != E_end in test cases\n            F_used = (F1 * E1_p - F2 * E2_p) / denom\n        \n        forces_used_list.append(F_used)\n\n        delta_x = gamma * F_used\n        if abs(F_used)  eps_F and abs(delta_x)  eps_x:\n            break\n        \n        x_new = current_x + delta_x\n        pos_trajectory.append(x_new)\n\n    x_final = pos_trajectory[-1]\n    \n    # 1. Geometry Bias\n    bias = abs(x_final - x0)\n\n    # 2. RMS Pulay Artifact\n    num_steps = len(forces_used_list)\n    if num_steps == 0:\n        rms_artifact = 0.0\n    else:\n        sum_sq_err = 0.0\n        for i in range(num_steps):\n            x_step = pos_trajectory[i] # Position where force was calculated\n            F_u = forces_used_list[i]\n            F_t = F_true(x_step, k, x0)\n            sum_sq_err += (F_u - F_t)**2\n        rms_artifact = np.sqrt(sum_sq_err / num_steps)\n        \n    return bias, rms_artifact\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在实际的材料模拟中，获得精确的计算结果往往需要同时收敛多个计算参数，例如能量截断 $E_{\\mathrm{cut}}$ 和倒易空间采样的k点网格密度。简单地将每个参数独立地收敛到极高精度不仅计算成本高昂，而且并非最优策略。本实践将收敛性测试提升为一个多目标优化问题，引导你构建一个综合的“误差预算”，并运用帕累托最优（Pareto-optimal）的概念，去寻找能够同时满足能量、力和应力精度要求且计算效率最高的参数组合。",
            "id": "3440829",
            "problem": "你的任务是设计并实现一个程序化过程，用于规范化计算材料科学中平面波计算的收敛性测试，重点关注能量截断选择和布里渊区采样密度。目标是构建一个显式的误差预算，并计算出能量截断和倒易空间采样密度的帕累托最优对，这些最优对需要同时满足对总能量、原子间力以及应力张量分量的严格精度目标。\n\n请从以下基本原则开始，这些原则在该领域被广泛接受，并且必须用于对算法设计进行推理：\n\n- 电子结构计算中的平面波基组在动能截断 $E_{cut}$ 处被截断，这会产生一个变分基组截断误差，该误差随着 $E_{cut}$ 的增加而单调递减。在解是光滑的渐近区域，该误差可以很好地用一个形式为 $C \\, E_{cut}^{-p}$ 的衰减函数来描述，其中 $C  0$ 且 $p  0$。\n\n- 布里渊区积分通过在有限的 $k$ 点集上采样来近似。对于足够光滑的被积函数和结构化网格，积分误差会随着一个形式为 $D \\, N_k^{-q}$ 的衰减函数而减小，其中 $D  0$ 且 $q  0$，$N_k$ 表示总 $k$ 点数。\n\n你可以假设每个关注量的总误差可以表示为能量截断控制的贡献和 $k$ 点网格控制的贡献之和。对于此问题，你必须使用以下抽象误差模型，其中所有参数均为正值且依赖于材料：\n$$\n\\Delta E(E_{cut}, N_k) = \\alpha_E \\, E_{cut}^{-p_E} + \\beta_E \\, N_k^{-q_E}, \\quad\n\\Delta F(E_{cut}, N_k) = \\alpha_F \\, E_{cut}^{-p_F} + \\beta_F \\, N_k^{-q_F}, \\quad\n\\Delta \\sigma(E_{cut}, N_k) = \\alpha_\\sigma \\, E_{cut}^{-p_\\sigma} + \\beta_\\sigma \\, N_k^{-q_\\sigma}.\n$$\n\n精度要求是严格的，并且必须同时满足：\n- 每个原子的总能量误差满足 $|\\Delta E|  1$ meV/atom，这必须强制执行为 $|\\Delta E|  0.001$ eV/atom。\n- 力的误差大小满足 $|\\Delta F|  0.01$ eV/$\\text{\\AA}$。\n- 应力误差满足 $|\\Delta \\sigma|  0.1$ GPa。\n\n程序必须在能量截断和 $k$ 点网格密度的离散候选集上搜索，并返回在上述可行性约束下，关于二维目标向量 $(E_{cut}, N_k)$ 的帕累托最优对集合。一个可行对 $(E_{cut}, N_k)$ 是帕累托最优的，如果没有其他可行对 $(E_{cut}', N_k')$ 满足 $E_{cut}' \\le E_{cut}$ 和 $N_k' \\le N_k$ 且至少有一个不等式是严格的。这一定义体现了在满足所有精度目标的同时，最小化平面波动能截断和 $k$ 点网格密度的目标。\n\n单位和离散化：\n\n- 能量截断必须以 $\\mathrm{eV}$ 表示。\n- $k$ 点网格密度是总整数计数 $N_k$（无单位）。\n- 候选能量截断值为离散集合 $\\{300, 350, 400, 450, 500, 600, 700\\}$ $\\mathrm{eV}$。\n- 候选 $k$ 点网格密度为离散集合 $\\{8, 12, 16, 20, 24, 32\\}$。\n\n测试套件：\n\n你必须为以下依赖于材料的参数集计算帕累托集合，每个参数集由一个六元组 $(\\alpha_E, p_E, \\beta_E, q_E; \\alpha_F, p_F, \\beta_F, q_F; \\alpha_\\sigma, p_\\sigma, \\beta_\\sigma, q_\\sigma)$ 定义，所有单位都与误差阈值一致：\n\n- 情况 $1$ (类金属，k点收敛较慢): \n  $\\alpha_E = 80$, $p_E = 2.0$, $\\beta_E = 0.03$, $q_E = 1.5$; \n  $\\alpha_F = 2.5$, $p_F = 1.5$, $\\beta_F = 0.12$, $q_F = 1.2$; \n  $\\alpha_\\sigma = 12$, $p_\\sigma = 1.2$, $\\beta_\\sigma = 1.2$, $q_\\sigma = 1.0$.\n\n- 情况 $2$ (类绝缘体，k点收敛快，对基组敏感):\n  $\\alpha_E = 150$, $p_E = 2.2$, $\\beta_E = 0.01$, $q_E = 2.0$; \n  $\\alpha_F = 4.0$, $p_F = 1.8$, $\\beta_F = 0.05$, $q_F = 1.7$; \n  $\\alpha_\\sigma = 20$, $p_\\sigma = 1.5$, $\\beta_\\sigma = 0.8$, $q_\\sigma = 1.6$.\n\n- 情况 $3$ (临界情况，需要高 $E_{cut}$ 和密集的 $k$ 点网格):\n  $\\alpha_E = 300$, $p_E = 2.4$, $\\beta_E = 0.05$, $q_E = 1.2$; \n  $\\alpha_F = 8.0$, $p_F = 1.6$, $\\beta_F = 0.2$, $q_F = 1.2$; \n  $\\alpha_\\sigma = 30$, $p_\\sigma = 1.3$, $\\beta_\\sigma = 2.2$, $q_\\sigma = 1.1$.\n\n- 情况 $4$ (不可行边界情况，在提供的网格中无解):\n  $\\alpha_E = 400$, $p_E = 2.0$, $\\beta_E = 0.3$, $q_E = 1.0$; \n  $\\alpha_F = 10.0$, $p_F = 1.2$, $\\beta_F = 0.5$, $q_F = 1.1$; \n  $\\alpha_\\sigma = 50$, $p_\\sigma = 1.1$, $\\beta_\\sigma = 5.0$, $q_\\sigma = 0.9$.\n\n你的程序应该：\n- 从指定的离散集合中枚举所有 $(E_{cut}, N_k)$ 对。\n- 对于每个测试案例，使用给定的参数和上述模型计算三个误差。\n- 识别同时满足所有三个约束的可行对。\n- 从可行集中，根据 $(E_{cut}, N_k)$ 上的二维偏序计算帕累托最优子集。\n- 对每个测试案例的帕累托最优对按 $E_{cut}$ 然后按 $N_k$ 的升序字典序进行排序。\n\n最终输出格式：\n- 对于每个测试案例，返回一个帕累托最优对的列表，编码为 $[E_{cut}, N_k]$ 列表，其中 $E_{cut}$ 单位为 $\\mathrm{eV}$，$N_k$ 是一个整数。\n- 你的程序应该生成一行输出，包含四个测试案例结果的逗号分隔列表，每个结果本身都是一个 $[E_{cut}, N_k]$ 对的列表，没有空格，并用方括号括起来。例如：`[[[300,12],[350,8]],[[400,16]],[],[[700,32]]]`。",
            "solution": "所提出的问题要求设计一个计算流程，以确定平面波电子结构计算中两个关键参数的最优设置：动能截断 $E_{cut}$ 和布里渊区采样网格的密度（由总 $k$ 点数 $N_k$ 表示）。目标是找到参数对 $(E_{cut}, N_k)$，使其在满足总能量、原子间力和应力张量的一系列严格精度约束的同时，最小化这两个参数。这是一个离散搜索空间上的多目标优化问题。解对构成了帕累托最优前沿。\n\n该方法的基础是所提供的唯象误差模型，这些模型描述了计算量随 $E_{cut}$ 和 $N_k$ 的收敛行为。对于一个通用的关注量 $Q$（其中 $Q$ 可以是总能量 $E$、最大原子力大小 $F$ 或最大应力张量分量大小 $\\sigma$），总数值误差 $\\Delta Q$ 被假定为两个独立贡献的总和：一个来自基组截断（$E_{cut}$），另一个来自布里渊区积分（$N_k$）。误差模型如下：\n$$\n\\Delta E(E_{cut}, N_k) = \\alpha_E \\, E_{cut}^{-p_E} + \\beta_E \\, N_k^{-q_E}\n$$\n$$\n\\Delta F(E_{cut}, N_k) = \\alpha_F \\, E_{cut}^{-p_F} + \\beta_F \\, N_k^{-q_F}\n$$\n$$\n\\Delta \\sigma(E_{cut}, N_k) = \\alpha_\\sigma \\, E_{cut}^{-p_\\sigma} + \\beta_\\sigma \\, N_k^{-q_\\sigma}\n$$\n每个量 $Q$ 的参数 $(\\alpha_Q, p_Q, \\beta_Q, q_Q)$ 均为正值，并依赖于所模拟的特定材料体系。\n\n必须同时满足的精度约束是：\n1.  总能量误差: $|\\Delta E| \\le \\tau_E$，其中 $\\tau_E = 0.001$ eV/atom。\n2.  力误差: $|\\Delta F| \\le \\tau_F$，其中 $\\tau_F = 0.01$ eV/Å。\n3.  应力误差: $|\\Delta \\sigma| \\le \\tau_\\sigma$，其中 $\\tau_\\sigma = 0.1$ GPa。\n\n最优参数的搜索在离散的候选值集合上进行：\n-   $E_{cut} \\in \\mathcal{E}_{cut} = \\{300, 350, 400, 450, 500, 600, 700\\}$ eV。\n-   $N_k \\in \\mathcal{N}_k = \\{8, 12, 16, 20, 24, 32\\}$。\n完整的搜索空间是笛卡尔积 $\\mathcal{S} = \\mathcal{E}_{cut} \\times \\mathcal{N}_k$。\n\n对于每个给定的材料特定参数集，识别帕累托最优对 $(E_{cut}, N_k)$ 的算法流程设计为两个主要阶段。\n\n**阶段 1: 识别可行集**\n第一阶段涉及对搜索空间 $\\mathcal{S}$ 中所有可能的对 $(E_{cut}, N_k)$ 进行暴力枚举。对于每一对，我们使用指定的误差模型和材料参数计算三个误差值 $\\Delta E$、$\\Delta F$ 和 $\\Delta \\sigma$。当且仅当一个参数对同时满足所有三个精度约束时，它才被认为是*可行的*：\n$$\n(\\Delta E \\le \\tau_E) \\land (\\Delta F \\le \\tau_F) \\land (\\Delta \\sigma \\le \\tau_\\sigma)\n$$\n所有满足这些条件的对被收集到一个*可行集*中，记为 $\\mathcal{F}$。如果在搜索空间 $\\mathcal{S}$ 中没有对满足所有标准，则可行集 $\\mathcal{F}$ 为空。\n\n**阶段 2: 确定帕累托最优前沿**\n第二阶段过滤可行集 $\\mathcal{F}$ 以找到帕累托最优子集。在这个二维最小化问题的背景下，如果一个可行对 $P_1 = (E_{cut,1}, N_{k,1})$ 满足 $E_{cut,1} \\le E_{cut,2}$ 和 $N_{k,1} \\le N_{k,2}$，且至少有一个不等式是严格的，那么它就*支配*另一个可行对 $P_2 = (E_{cut,2}, N_{k,2})$。帕累托最优集（或帕累托前沿）由所有不被任何其他可行对支配的可行对组成。这些代表了计算效率最高的选择，因为要进一步减少 $E_{cut}$ 或 $N_k$ 中的任何一个，都需要增加另一个才能保持可行，否则将违反精度约束。\n\n找到这个二维帕累托前沿的一种高效算法如下：\n1.  如果可行集 $\\mathcal{F}$ 为空，则帕累托集也为空。\n2.  否则，按字典序对 $\\mathcal{F}$ 中的对进行排序，首先按 $E_{cut}$ 升序，然后按 $N_k$ 升序。设这个排序后的列表为 $F_{sorted}$。\n3.  为帕累托最优集 $\\mathcal{P}$ 初始化一个空列表，并初始化一个跟踪变量 `min_nk_seen` 为一个比任何可能的 $N_k$ 都大的值（例如，无穷大）。\n4.  遍历 $F_{sorted}$ 中的每个对 $(e, n)$。\n5.  对于每个对，将其 $N_k$ 值 $n$ 与 `min_nk_seen` 进行比较。\n    -   如果 $n  \\text{min\\_nk\\_seen}$，则该对 $(e, n)$ 不被任何已处理的点所支配。因为列表是按 $e$ 排序的，所以帕累托集中的任何先前点 $(e', n')$ 都满足 $e'  e$。由于我们还知道 $n  \\text{min\\_nk\\_seen} \\le n'$，所以先前的点不会支配当前点。因此，$(e, n)$ 是帕累托前沿上的一个新点。它被添加到 $\\mathcal{P}$ 中，并且 `min_nk_seen` 更新为 $n$。\n    -   如果 $n \\ge \\text{min\\_nk\\_seen}$，则当前对 $(e, n)$ 被一个先前已识别的帕累托最优点 $(e', n')$ 所支配，其中 $e' \\le e$ 且 $n'  n$。因此，$(e, n)$ 被丢弃。\n\n该算法正确且高效地（复杂度为 $O(|\\mathcal{F}|\\log|\\mathcal{F}|)$，主要由排序决定）识别帕累托最优集。最终的实现将此过程应用于提供的四个测试案例中的每一个，构建结果列表的无空格字符串表示形式作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Pareto-optimal (E_cut, N_k) pairs for plane-wave calculations\n    based on a given error model and convergence criteria.\n    \"\"\"\n    \n    # Define candidate sets for energy cutoff and k-mesh density\n    E_cut_candidates = [300, 350, 400, 450, 500, 600, 700]\n    Nk_candidates = [8, 12, 16, 20, 24, 32]\n\n    # Define error thresholds\n    tau_E = 0.001  # eV/atom\n    tau_F = 0.01   # eV/Angstrom\n    tau_sigma = 0.1  # GPa\n\n    # Define test cases. Each tuple contains 12 parameters in the order:\n    # (alpha_E, p_E, beta_E, q_E, \n    #  alpha_F, p_F, beta_F, q_F,\n    #  alpha_sigma, p_sigma, beta_sigma, q_sigma)\n    test_cases = [\n        # Case 1 (metal-like)\n        (80, 2.0, 0.03, 1.5, 2.5, 1.5, 0.12, 1.2, 12, 1.2, 1.2, 1.0),\n        # Case 2 (insulator-like)\n        (150, 2.2, 0.01, 2.0, 4.0, 1.8, 0.05, 1.7, 20, 1.5, 0.8, 1.6),\n        # Case 3 (borderline)\n        (300, 2.4, 0.05, 1.2, 8.0, 1.6, 0.2, 1.2, 30, 1.3, 2.2, 1.1),\n        # Case 4 (infeasible)\n        (400, 2.0, 0.3, 1.0, 10.0, 1.2, 0.5, 1.1, 50, 1.1, 5.0, 0.9),\n    ]\n\n    def calculate_error(E_cut, Nk, alpha, p, beta, q):\n        \"\"\"Calculates the error for a given quantity based on the model.\"\"\"\n        return alpha * E_cut**(-p) + beta * Nk**(-q)\n\n    all_results = []\n    for case_params in test_cases:\n        # Unpack parameters for readability\n        aE, pE, bE, qE, aF, pF, bF, qF, aS, pS, bS, qS = case_params\n        \n        # Step 1: Find all feasible (E_cut, Nk) pairs\n        feasible_pairs = []\n        for E_cut in E_cut_candidates:\n            for Nk in Nk_candidates:\n                error_E = calculate_error(E_cut, Nk, aE, pE, bE, qE)\n                error_F = calculate_error(E_cut, Nk, aF, pF, bF, qF)\n                error_sigma = calculate_error(E_cut, Nk, aS, pS, bS, qS)\n\n                if error_E = tau_E and error_F = tau_F and error_sigma = tau_sigma:\n                    feasible_pairs.append([E_cut, Nk])\n\n        # Step 2: Determine the Pareto-optimal front from the feasible set\n        if not feasible_pairs:\n            all_results.append([])\n            continue\n\n        # Sort pairs lexicographically: by E_cut, then by Nk\n        feasible_pairs.sort(key=lambda x: (x[0], x[1]))\n\n        pareto_optimal_set = []\n        min_nk_seen = float('inf')\n        for e_cut, nk in feasible_pairs:\n            if nk  min_nk_seen:\n                pareto_optimal_set.append([e_cut, nk])\n                min_nk_seen = nk\n        \n        all_results.append(pareto_optimal_set)\n\n    # Format the final output string to match the exact requirement (no spaces)\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}