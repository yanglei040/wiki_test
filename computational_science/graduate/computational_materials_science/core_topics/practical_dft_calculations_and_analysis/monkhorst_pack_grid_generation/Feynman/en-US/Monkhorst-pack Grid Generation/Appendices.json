{
    "hands_on_practices": [
        {
            "introduction": "Mastering any numerical technique begins with a solid implementation of its core algorithm. This first practice challenges you to build a Monkhorst-Pack grid generator from first principles, a fundamental tool for nearly all modern electronic structure calculations . The exercise emphasizes not just the creation of a uniform sampling mesh, but also the critical step of mapping these points into the First Brillouin Zone, ensuring that the periodicity of reciprocal space is correctly handled.",
            "id": "3467044",
            "problem": "You are to derive and implement, from first principles, an algorithm that constructs a uniform set of sampling points in the reciprocal space of a crystal and maps them into the First Brillouin Zone (FBZ). The algorithm must generate all points of a three-dimensional grid commonly used in band-structure calculations and ensure these points lie within the FBZ, defined as the Wigner–Seitz (WS) cell of the reciprocal lattice. The mesh must be expressed in fractional coordinates with respect to the reciprocal primitive vectors.\n\nFundamental bases and definitions to use:\n\n- Let the triple of real-space primitive lattice vectors be the columns of the matrix $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ with units in Angstroms. The reciprocal lattice primitive vectors are defined by $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$ and have units in inverse Angstroms. Any reciprocal lattice vector can be written as $\\mathbf{G} = n_1 \\mathbf{b}_1 + n_2 \\mathbf{b}_2 + n_3 \\mathbf{b}_3 = \\mathbf{B}\\mathbf{n}$ where $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\n- A point in reciprocal space $\\mathbf{k}$ may be parameterized in fractional coordinates $\\mathbf{f} \\in \\mathbb{R}^3$ as $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$.\n\n- The First Brillouin Zone (FBZ), which is the Wigner–Seitz (WS) cell of the reciprocal lattice, is the set of points $\\mathbf{k}$ that are closer to the origin $\\mathbf{0}$ than to any other reciprocal lattice point. Equivalently, $\\mathbf{k}$ is in the FBZ if for all nonzero $\\mathbf{n} \\in \\mathbb{Z}^3$, $\\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$.\n\nYour goals:\n\n1. Starting from the requirement of uniform sampling density along each reciprocal primitive direction and symmetry about the $\\Gamma$ point (the origin), construct in fractional coordinates a three-dimensional grid with $N_1 \\times N_2 \\times N_3$ points such that along each direction the $N_i$ samples are uniformly spaced and centered with respect to the origin. Denote the fractional coordinates by $\\mathbf{f}_{m_1,m_2,m_3}$ for indices $m_i \\in \\{1,2,\\dots,N_i\\}$.\n\n2. Implement a mapping for each $\\mathbf{k} = \\mathbf{B}\\mathbf{f}$ into the FBZ by subtracting an appropriate reciprocal lattice vector $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$, where $\\mathbf{n} \\in \\mathbb{Z}^3$ is chosen to minimize the Euclidean norm $\\lVert \\mathbf{B}(\\mathbf{f} + \\mathbf{n}) \\rVert$. Express all distances and norms in inverse Angstroms.\n\n3. To test the robustness of your mapping, include an optional uniform fractional offset (or “shift”) $\\mathbf{s} \\in \\mathbb{R}^3$ such that the initial fractional coordinates used to form $\\mathbf{k}$ are $\\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}$ before mapping. The mapping must bring points back into the FBZ.\n\n4. Verification criterion for the FBZ membership must use the WS definition: for a mapped $\\mathbf{k}$, verify that $\\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert$ for all nonzero integer vectors $\\mathbf{n}$ in a symmetric bounded neighborhood of the origin in $\\mathbb{Z}^3$. Use a bounded neighborhood that is sufficient to decide FBZ membership for the points generated by your test suite.\n\nUnits and output requirements:\n\n- All real-space lattice inputs $\\mathbf{A}$ are given in Angstroms. All reciprocal-space quantities (including norms of $\\mathbf{k}$) must be computed and reported in inverse Angstroms.\n\n- Angle units do not apply in this problem.\n\n- Your program must produce a single line of output containing, for each test case, a list with three values:\n    1. An integer equal to the number of points that are outside the FBZ before mapping,\n    2. An integer equal to the number of points that remain outside the FBZ after mapping (this should be $0$ if the mapping is correct),\n    3. A float equal to the maximum Euclidean norm $\\max \\lVert \\mathbf{k} \\rVert$ among the mapped points, in inverse Angstroms, rounded to six decimal places.\n  Aggregate the lists for all test cases into one top-level comma-separated list enclosed in square brackets (e.g., \"[[a,b,c],[d,e,f],...]\").\n\nTest suite:\n\nImplement the algorithm and run it on the following four cases. In each case, construct $\\mathbf{B} = 2\\pi \\left( \\mathbf{A}^{-1} \\right)^{\\top}$ and generate the $N_1 \\times N_2 \\times N_3$ grid, apply the shift $\\mathbf{s}$, map to the FBZ, and report the three requested values.\n\n- Case 1 (happy path, orthogonal lattice):\n  $\\mathbf{A} = \\begin{bmatrix} 1.0 & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (2,2,2)$, $\\mathbf{s} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$.\n\n- Case 2 (orthorhombic lattice with significant shift):\n  $\\mathbf{A} = \\begin{bmatrix} 3.0 & 0.0 & 0.0 \\\\ 0.0 & 2.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (3,3,3)$, $\\mathbf{s} = \\begin{bmatrix} 0.6 \\\\ 0.2 \\\\ -0.4 \\end{bmatrix}$.\n\n- Case 3 (skewed lattice):\n  $\\mathbf{A} = \\begin{bmatrix} 2.0 & 0.1 & 0.0 \\\\ 0.0 & 2.2 & 0.3 \\\\ 0.0 & 0.0 & 1.8 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (4,2,3)$, $\\mathbf{s} = \\begin{bmatrix} 0.3 \\\\ 0.3 \\\\ 0.3 \\end{bmatrix}$.\n\n- Case 4 (hexagonal-like lattice with large shift and minimal grid):\n  $\\mathbf{A} = \\begin{bmatrix} 1.0 & 0.5 & 0.0 \\\\ 0.0 & 0.866 & 0.0 \\\\ 0.0 & 0.0 & 2.5 \\end{bmatrix}$ Angstroms, $(N_1,N_2,N_3) = (1,1,1)$, $\\mathbf{s} = \\begin{bmatrix} 1.2 \\\\ -1.2 \\\\ 0.8 \\end{bmatrix}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes its own three-element list as described above.",
            "solution": "The problem requires the derivation and implementation of an algorithm to generate a uniform grid of sampling points in reciprocal space, known as a Monkhorst-Pack grid, and to map these points into the First Brillouin Zone (FBZ).\n\n### 1. Reciprocal Lattice and Coordinate Systems\n\nThe crystal structure is defined by a set of real-space primitive lattice vectors, given as the columns of a matrix $\\mathbf{A}$. The corresponding reciprocal lattice primitive vectors, which form the basis for reciprocal space, are the columns of the matrix $\\mathbf{B}$ defined as:\n$$\n\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top\n$$\nAny point $\\mathbf{k}$ in reciprocal space can be expressed in Cartesian coordinates (units of $\\AA^{-1}$) or in fractional coordinates $\\mathbf{f}$ with respect to the basis $\\mathbf{B}$:\n$$\n\\mathbf{k} = \\mathbf{Bf} = f_1 \\mathbf{b}_1 + f_2 \\mathbf{b}_2 + f_3 \\mathbf{b}_3\n$$\nA reciprocal lattice vector $\\mathbf{G}$ corresponds to a point where the fractional coordinates are integers, i.e., $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$ for some integer vector $\\mathbf{n} \\in \\mathbb{Z}^3$.\n\n### 2. Monkhorst-Pack Grid Generation\n\nThe goal is to create a uniform grid of $N_1 \\times N_2 \\times N_3$ points in reciprocal space, centered at the origin ($\\Gamma$ point). This is achieved by generating a uniform grid in the space of fractional coordinates. To ensure the grid is symmetric with respect to the origin, the fractional coordinates $f_i$ along each direction $i$ are chosen as:\n$$\nf_i = \\frac{m_i - \\frac{N_i+1}{2}}{N_i} \\quad \\text{for } m_i = 1, 2, \\dots, N_i\n$$\nFor an odd $N_i$, this series includes $0$, and for an even $N_i$, it is symmetric around $0$. For example, for $N_i=3$, the fractional coordinates are $\\{-\\frac{1}{3}, 0, \\frac{1}{3}\\}$, and for $N_i=4$, they are $\\{-\\frac{3}{8}, -\\frac{1}{8}, \\frac{1}{8}, \\frac{3}{8}\\}$. All generated coordinates lie in the interval $(-0.5, 0.5)$.\n\nThe problem specifies an additional uniform shift $\\mathbf{s}$ to be applied to the grid. The final set of unmapped fractional coordinates $\\mathbf{f'}$ is therefore:\n$$\n\\mathbf{f'}_{m_1,m_2,m_3} = \\mathbf{f}_{m_1,m_2,m_3} + \\mathbf{s}\n$$\nThe initial set of k-points is then given by $\\mathbf{k}_{init} = \\mathbf{Bf'}$. These points are not guaranteed to lie within the First Brillouin Zone.\n\n### 3. Mapping to the First Brillouin Zone\n\nThe First Brillouin Zone (FBZ) is the Wigner-Seitz cell of the reciprocal lattice centered at the origin. It is defined as the set of all points $\\mathbf{k}$ that are closer to the origin ($\\mathbf{G} = \\mathbf{0}$) than to any other reciprocal lattice point $\\mathbf{G} = \\mathbf{B}\\mathbf{n}$ ($\\mathbf{n} \\neq \\mathbf{0}$):\n$$\n\\text{FBZ} = \\{ \\mathbf{k} \\in \\mathbb{R}^3 \\mid \\lVert \\mathbf{k} \\rVert \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert \\quad \\forall \\mathbf{n} \\in \\mathbb{Z}^3, \\mathbf{n} \\neq \\mathbf{0} \\}\n$$\nTo map an arbitrary point $\\mathbf{k}_{init}$ into the FBZ, we must subtract the specific reciprocal lattice vector $\\mathbf{G}^* = \\mathbf{B}\\mathbf{n}^*$ that is closest to $\\mathbf{k}_{init}$. The mapped point $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{G}^*$ will then be closer to the origin than to any other reciprocal lattice point, fulfilling the definition of the FBZ.\n\nThis task is equivalent to solving the Closest Vector Problem (CVP) for each $\\mathbf{k}_{init}$: finding the integer vector $\\mathbf{n}^* \\in \\mathbb{Z}^3$ that minimizes the Euclidean distance $\\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert$.\n$$\n\\mathbf{n}^* = \\arg\\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert^2\n$$\nWhile CVP is NP-hard in general, for a low-dimensional space like $\\mathbb{R}^3$, we can solve it effectively using a search-based method. A robust strategy is to first find a good initial guess for $\\mathbf{n}$ and then search in its local vicinity.\nThe fractional coordinates of $\\mathbf{k}_{init}$ provide an excellent guess. We first compute $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$, where $\\mathbf{B}^{-1} = \\frac{1}{2\\pi}\\mathbf{A}^\\top$. The closest integer vector in fractional space is simply $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$. This corresponds to Babai's rounding algorithm for CVP.\n\nTo improve upon this, we perform a brute-force search for $\\mathbf{n}^*$ in a small integer box centered at $\\mathbf{n}_{guess}$. We search all candidate vectors $\\mathbf{n} = \\mathbf{n}_{guess} + \\Delta\\mathbf{n}$, where $\\Delta\\mathbf{n}$ is an integer vector with small components (e.g., $\\Delta n_i \\in \\{-1, 0, 1\\}$). This checks $3^3=27$ candidates for $\\mathbf{n}$ and guarantees finding the solution if it lies within this local neighborhood, which is a very safe assumption for typical physical systems.\n\nThe algorithm for mapping a point $\\mathbf{k}_{init}$ is:\n1.  Calculate the fractional coordinates $\\mathbf{f'} = \\mathbf{B}^{-1}\\mathbf{k}_{init}$.\n2.  Determine the initial guess integer vector $\\mathbf{n}_{guess} = \\text{round}(\\mathbf{f'})$.\n3.  Search through all integer vectors $\\mathbf{n}$ in a $3 \\times 3 \\times 3$ cube centered at $\\mathbf{n}_{guess}$. For each candidate $\\mathbf{n}$, compute the squared distance $d^2 = \\lVert \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n} \\rVert^2$.\n4.  Identify the vector $\\mathbf{n}^*$ that yields the minimum $d^2$.\n5.  The final mapped point is $\\mathbf{k}_{mapped} = \\mathbf{k}_{init} - \\mathbf{B}\\mathbf{n}^*$.\n\n### 4. Verification of FBZ Membership\n\nTo verify if a point $\\mathbf{k}$ is in the FBZ, we directly apply the definition. We must check if $\\lVert \\mathbf{k} \\rVert^2 \\le \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert^2$ for all non-zero integer vectors $\\mathbf{n}$ in a sufficiently large neighborhood of the origin. For the test cases, a search box where $n_i \\in \\{-1, 0, 1\\}$ (26 non-zero vectors) is sufficient. A small numerical tolerance $\\epsilon$ is used to handle floating-point comparisons, i.e., we check if $\\lVert \\mathbf{k} \\rVert^2 > \\lVert \\mathbf{k} - \\mathbf{B}\\mathbf{n} \\rVert^2 + \\epsilon$ to declare a point outside the FBZ.\n\n### 5. Summary of the Procedure\nThe overall algorithm proceeds as follows for each test case:\n1.  Given $\\mathbf{A}$, compute $\\mathbf{B} = 2\\pi (\\mathbf{A}^{-1})^\\top$ and $\\mathbf{B}^{-1} = \\frac{1}{2\\pi} \\mathbf{A}^\\top$.\n2.  Generate the base Monkhorst-Pack grid of fractional coordinates $\\mathbf{f}$.\n3.  Apply the shift $\\mathbf{s}$ to get the initial coordinates $\\mathbf{f'} = \\mathbf{f} + \\mathbf{s}$.\n4.  For each $\\mathbf{f'}$, compute the initial k-point $\\mathbf{k}_{init} = \\mathbf{Bf'}$.\n5.  Count the number of initial points outside the FBZ using the verification procedure.\n6.  Map each $\\mathbf{k}_{init}$ to its FBZ equivalent $\\mathbf{k}_{mapped}$ using the CVP-based search algorithm.\n7.  Count the number of mapped points that are still outside the FBZ (this should be zero).\n8.  Determine the maximum Euclidean norm among all $\\mathbf{k}_{mapped}$ points.\n9.  Report the three computed values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm for Monkhorst-Pack grid generation\n    and mapping to the First Brillouin Zone for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"A\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (2, 2, 2),\n            \"s\": np.array([0.0, 0.0, 0.0])\n        },\n        {\n            \"A\": np.array([[3.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"N\": (3, 3, 3),\n            \"s\": np.array([0.6, 0.2, -0.4])\n        },\n        {\n            \"A\": np.array([[2.0, 0.1, 0.0], [0.0, 2.2, 0.3], [0.0, 0.0, 1.8]]),\n            \"N\": (4, 2, 3),\n            \"s\": np.array([0.3, 0.3, 0.3])\n        },\n        {\n            \"A\": np.array([[1.0, 0.5, 0.0], [0.0, 0.866, 0.0], [0.0, 0.0, 2.5]]),\n            \"N\": (1, 1, 1),\n            \"s\": np.array([1.2, -1.2, 0.8])\n        }\n    ]\n\n    results = []\n    \n    # Define the search box for integer vectors n for FBZ verification.\n    # A 3x3x3 cube around the origin is sufficient for these test cases.\n    verify_n_coords = [-1, 0, 1]\n    verify_n_vectors = []\n    for i in verify_n_coords:\n        for j in verify_n_coords:\n            for k in verify_n_coords:\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                verify_n_vectors.append(np.array([i, j, k]))\n\n    def is_in_fbz(k_vec, B_mat, n_vectors, tol=1e-12):\n        \"\"\"\n        Verifies if a k-point is inside the First Brillouin Zone.\n        A point k is in the FBZ if ||k|| <= ||k - G|| for all G = B@n.\n        \"\"\"\n        k_norm_sq = np.dot(k_vec, k_vec)\n        for n in n_vectors:\n            G = B_mat @ n\n            k_shifted_norm_sq = np.dot(k_vec - G, k_vec - G)\n            if k_norm_sq > k_shifted_norm_sq + tol:\n                return False\n        return True\n\n    def map_to_fbz(k_vec, B_mat, B_inv_mat):\n        \"\"\"\n        Maps a k-point into the First Brillouin Zone by solving the\n        Closest Vector Problem over a local search grid.\n        \"\"\"\n        # Get fractional coordinates to find a good guess for integer vector n\n        f_prime = B_inv_mat @ k_vec\n        n_guess = np.round(f_prime)\n        \n        min_dist_sq = np.inf\n        best_n = np.zeros(3)\n\n        # Search in a 3x3x3 cube around the initial guess n_guess\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                for l in range(-1, 2):\n                    n_cand = n_guess + np.array([i, j, l])\n                    G_cand = B_mat @ n_cand\n                    dist_sq = np.dot(k_vec-G_cand, k_vec-G_cand)\n                    if dist_sq < min_dist_sq:\n                        min_dist_sq = dist_sq\n                        best_n = n_cand\n        \n        G_final = B_mat @ best_n\n        return k_vec - G_final\n\n    for case in test_cases:\n        A = case[\"A\"]\n        N = case[\"N\"]\n        s = case[\"s\"]\n        \n        B = 2 * np.pi * np.linalg.inv(A).T\n        B_inv = (1 / (2 * np.pi)) * A.T\n\n        # Generate Monkhorst-Pack grid points\n        N1, N2, N3 = N\n        m1_vals = np.arange(1, N1 + 1)\n        m2_vals = np.arange(1, N2 + 1)\n        m3_vals = np.arange(1, N3 + 1)\n\n        f1 = (m1_vals - (N1 + 1) / 2) / N1\n        f2 = (m2_vals - (N2 + 1) / 2) / N2\n        f3 = (m3_vals - (N3 + 1) / 2) / N3\n        \n        initial_k_points = []\n        for i in range(N1):\n            for j in range(N2):\n                for k in range(N3):\n                    f = np.array([f1[i], f2[j], f3[k]])\n                    f_shifted = f + s\n                    k_point = B @ f_shifted\n                    initial_k_points.append(k_point)\n\n        outside_before = 0\n        outside_after = 0\n        max_norm_after = 0.0\n\n        for k_init in initial_k_points:\n            if not is_in_fbz(k_init, B, verify_n_vectors):\n                outside_before += 1\n            \n            k_mapped = map_to_fbz(k_init, B, B_inv)\n            \n            if not is_in_fbz(k_mapped, B, verify_n_vectors):\n                outside_after += 1\n            \n            norm_val = np.linalg.norm(k_mapped)\n            if norm_val > max_norm_after:\n                max_norm_after = norm_val\n\n        results.append([outside_before, outside_after, round(max_norm_after, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Once a k-point grid can be generated, the immediate question becomes: how dense must the grid be for a given calculation? This practice transitions from algorithm implementation to the essential skill of convergence analysis, connecting the numerical grid parameters directly to physical observables and a desired error tolerance . By deriving an estimate for the necessary k-point density in a model system, you will develop a quantitative understanding of how to ensure your computational results are both accurate and reliable.",
            "id": "3467058",
            "problem": "Consider a simple cubic metal with lattice constant $a$ and one free electron per primitive cell. Model the electrons with the free-electron dispersion $E(\\mathbf{k}) = \\frac{\\hbar^{2} |\\mathbf{k}|^{2}}{2 m}$, where $m$ is the electron mass and $\\hbar$ is the reduced Planck constant. The first Brillouin zone of the simple cubic lattice is the cube of edge length $\\frac{2 \\pi}{a}$ centered at the origin in reciprocal space. Sampling this Brillouin zone is performed using a Monkhorst-Pack (MP) grid, defined as an $N \\times N \\times N$ uniform mesh of points whose spacing along each reciprocal lattice direction is $\\Delta k = \\frac{2 \\pi}{a N}$.\n\nTo approximate the total energy per electron, the occupation near the Fermi energy is smoothed using a Fermi-Dirac (FD) smearing represented phenomenologically by an energy broadening parameter $\\sigma$ (in Joules), meaning that the occupancy transition occurs over an energy scale $\\sigma$ around the Fermi energy $E_{F}$. Let the target tolerance for the relative error in the total energy per electron due to $k$-point discretization be $\\eta$ (a dimensionless number with $0 < \\eta \\ll 1$).\n\nAssume the following modeling assumptions grounded in well-tested facts:\n- The Fermi wavevector $k_{F}$ satisfies $k_{F} = \\left(3 \\pi^{2} n \\right)^{1/3}$ for a three-dimensional free electron gas with electron number density $n$, and for one electron per primitive cell $n = \\frac{1}{a^{3}}$.\n- The smearing over an energy width $\\sigma$ induces a characteristic radial $k$-space transition width $\\delta k$ at the Fermi surface set by the local energy slope, $\\delta k \\approx \\frac{\\sigma}{\\frac{d E}{d k}\\big|_{k = k_{F}}}$.\n- For twice-differentiable integrands, the relative integration error of a uniform-grid trapezoidal (or equivalently midpoint) quadrature over the narrow transition region of width $\\delta k$ scales as the square of the ratio of the grid spacing to the transition width, that is, as $\\left(\\frac{\\Delta k}{\\delta k}\\right)^{2}$ up to an order-unity constant, which you may take to be $1$ for this estimate.\n\nUsing only these bases, derive a closed-form analytic expression for the minimal total number of $k$ points $N_{k}$ in the Monkhorst-Pack mesh needed to ensure that the relative discretization error in the total energy per electron does not exceed $\\eta$ under the smearing width $\\sigma$. Express your final result solely in terms of $a$, $m$, $\\hbar$, $\\sigma$, and $\\eta$, with no numerical substitution. If an integer is required, use the least-integer function explicitly. No rounding is required, and no units should be included in your final expression.",
            "solution": "The objective is to derive a closed-form analytic expression for the minimal total number of $k$-points, denoted $N_k$, required to sample the first Brillouin zone of a simple cubic metal such that the relative error in the total energy per electron does not exceed a tolerance $\\eta$. The sampling is performed on an $N \\times N \\times N$ Monkhorst-Pack grid, which means the total number of points is $N_k = N^3$, where $N$ is an integer.\n\nThe problem provides a model for the relative error, stating that it scales as the square of the ratio of the grid spacing $\\Delta k$ to the characteristic $k$-space transition width $\\delta k$ near the Fermi surface. The condition for the tolerance to be met is therefore:\n$$\n\\left( \\frac{\\Delta k}{\\delta k} \\right)^2 \\le \\eta\n$$\nTaking the square root of both sides, we get the condition:\n$$\n\\frac{\\Delta k}{\\delta k} \\le \\sqrt{\\eta}\n$$\nTo find the minimal number of points, we must use the finest grid spacing (largest $N$) necessary, which corresponds to the equality condition. We will derive expressions for $\\Delta k$ and $\\delta k$ in terms of the given physical parameters.\n\nFirst, the grid spacing $\\Delta k$ for an $N \\times N \\times N$ grid in a cubic Brillouin zone of side length $\\frac{2\\pi}{a}$ is given as:\n$$\n\\Delta k = \\frac{2\\pi}{a N}\n$$\nSecond, the $k$-space transition width $\\delta k$ is given by the approximation $\\delta k \\approx \\frac{\\sigma}{\\frac{dE}{dk}\\big|_{k=k_F}}$, where $\\sigma$ is the energy broadening parameter and $k_F$ is the Fermi wavevector. To evaluate this, we need to find both $k_F$ and the derivative of the energy dispersion $E(k)$.\n\nThe energy dispersion for a free electron is $E(k) = \\frac{\\hbar^2 k^2}{2m}$, where $k=|\\mathbf{k}|$. Its derivative with respect to $k$ is:\n$$\n\\frac{dE}{dk} = \\frac{d}{dk} \\left( \\frac{\\hbar^2 k^2}{2m} \\right) = \\frac{\\hbar^2 k}{m}\n$$\nNext, we find the Fermi wavevector $k_F$. The problem states that $k_F = (3\\pi^2 n)^{1/3}$, where $n$ is the electron density. For a simple cubic lattice with lattice constant $a$ and one free electron per primitive cell, the electron density is $n = \\frac{1}{a^3}$. Substituting this into the formula for $k_F$:\n$$\nk_F = \\left( 3\\pi^2 \\frac{1}{a^3} \\right)^{1/3} = \\frac{(3\\pi^2)^{1/3}}{a}\n$$\nNow we can evaluate the slope of the energy dispersion at the Fermi surface:\n$$\n\\frac{dE}{dk}\\bigg|_{k=k_F} = \\frac{\\hbar^2 k_F}{m} = \\frac{\\hbar^2}{m} \\frac{(3\\pi^2)^{1/3}}{a}\n$$\nUsing this slope, we find the expression for $\\delta k$:\n$$\n\\delta k = \\frac{\\sigma}{\\frac{\\hbar^2 (3\\pi^2)^{1/3}}{ma}} = \\frac{m \\sigma a}{\\hbar^2 (3\\pi^2)^{1/3}}\n$$\nWe now substitute the expressions for $\\Delta k$ and $\\delta k$ into the tolerance inequality $\\frac{\\Delta k}{\\delta k} \\le \\sqrt{\\eta}$:\n$$\n\\frac{\\frac{2\\pi}{aN}}{\\frac{m \\sigma a}{\\hbar^2 (3\\pi^2)^{1/3}}} \\le \\sqrt{\\eta}\n$$\nSimplifying the fraction on the left-hand side gives:\n$$\n\\frac{2\\pi}{aN} \\cdot \\frac{\\hbar^2 (3\\pi^2)^{1/3}}{m \\sigma a} \\le \\sqrt{\\eta}\n$$\n$$\n\\frac{2\\pi \\hbar^2 (3\\pi^2)^{1/3}}{m \\sigma a^2 N} \\le \\sqrt{\\eta}\n$$\nTo find the minimal required grid size, we solve for $N$:\n$$\nN \\ge \\frac{2\\pi \\hbar^2 (3\\pi^2)^{1/3}}{m \\sigma a^2 \\sqrt{\\eta}}\n$$\nSince $N$ must be an integer, the minimal value of $N$ that satisfies this condition, $N_{min}$, is the smallest integer greater than or equal to the expression on the right. This is given by the ceiling function (least-integer function):\n$$\nN_{min} = \\left\\lceil \\frac{2\\pi \\hbar^2 (3\\pi^2)^{1/3}}{m \\sigma a^2 \\sqrt{\\eta}} \\right\\rceil\n$$\nThe total number of $k$-points in the Monkhorst-Pack mesh is $N_k = N^3$. Therefore, the minimal total number of $k$-points required to meet the specified tolerance is $(N_{min})^3$.",
            "answer": "$$\\boxed{\\left\\lceil \\frac{2 \\pi \\hbar^{2} (3 \\pi^2)^{1/3}}{m \\sigma a^2 \\sqrt{\\eta}} \\right\\rceil^3}$$"
        },
        {
            "introduction": "Directly integrating over the full Brillouin zone is often computationally prohibitive. Fortunately, the inherent symmetry of the crystal lattice provides a powerful means of optimization. This final practice guides you through the implementation of a symmetry-reduction algorithm, a cornerstone of efficient materials simulation . You will learn how to partition the full Monkhorst-Pack grid into symmetry-equivalent orbits, identify the minimal set of unique k-points in the Irreducible Brillouin Zone (IBZ), and calculate their corresponding weights, a process that dramatically accelerates real-world calculations.",
            "id": "3467067",
            "problem": "You are given a periodic reciprocal lattice with primitive reciprocal vectors that define fractional coordinates in reciprocal space. A fractional coordinate $\\mathbf{k}$ represents a wave vector modulo addition of integer-valued reciprocal lattice vectors, which implies the equivalence relation $\\mathbf{k} \\sim \\mathbf{k} + \\mathbf{G}$ for any integer vector $\\mathbf{G} \\in \\mathbb{Z}^3$. Consider a set of point operations $\\{ \\mathbf{R} \\}$ acting on fractional coordinates by $\\mathbf{k} \\mapsto \\mathbf{R}\\mathbf{k}$. Assume each $\\mathbf{R}$ is an integer-valued $3 \\times 3$ matrix with determinant $\\det(\\mathbf{R}) = \\pm 1$ such that the action preserves the reciprocal lattice, and that the set $\\{ \\mathbf{R} \\}$ is closed under composition and contains the identity operation. These operations represent the point part of a space group; their action on fractional coordinates is considered modulo reciprocal lattice translations, i.e., after applying $\\mathbf{R}$ one reduces the resulting $\\mathbf{k}'$ back to a canonical cell via $\\mathbf{k}' \\mapsto \\mathbf{k}' + \\mathbf{G}$ for some integer $\\mathbf{G}$ to bring it into a chosen representative region, for example the canonical hypercube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$.\n\nYour task is to design and implement a procedure that, given:\n- a uniform Monkhorst–Pack (MP) sampling grid specified by integers $\\mathbf{N} = (N_1, N_2, N_3)$,\n- a closed set of point operations $\\{ \\mathbf{R} \\}$ in fractional reciprocal coordinates,\n\nconstructs the irreducible set of sampling points (the irreducible Brillouin zone (IBZ) with respect to $\\{ \\mathbf{R} \\}$) and computes weights $w_\\alpha$ for each irreducible representative $\\mathbf{k}_\\alpha$ such that every symmetry-equivalence class contributes proportionally to the total number of grid points.\n\nBegin from fundamental definitions and well-tested facts:\n- The Brillouin zone integral over a function $f(\\mathbf{k})$ that is invariant under all point operations, i.e., $f(\\mathbf{R}\\mathbf{k}) = f(\\mathbf{k})$ for all $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$, can be approximated by a uniform sum over a discrete grid. Reducing to symmetry-inequivalent points is valid when counting multiplicities correctly.\n- An equivalence class (orbit) of a point $\\mathbf{k}$ under the action of $\\{ \\mathbf{R} \\}$ is the set $\\mathcal{O}(\\mathbf{k}) = \\left\\{ \\mathrm{wrap}\\!\\left(\\mathbf{R}\\mathbf{k}\\right) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\right\\}$, where $\\mathrm{wrap}(\\cdot)$ maps a fractional coordinate back into a canonical cell by adding an appropriate integer vector. Distinct points of the grid that lie in the same orbit are symmetry-equivalent.\n\nRequirements for your program:\n- Generate a Monkhorst–Pack grid that is symmetric about the origin and uniformly samples each reciprocal direction with $N_i$ points. The construction must honor periodicity, i.e., points differing by integer vectors are identified modulo the reciprocal lattice. Do not assume any particular centering beyond the requirement of origin symmetry and uniform spacing that is standard for Monkhorst–Pack grids.\n- Partition the entire grid into disjoint symmetry orbits under the given $\\{ \\mathbf{R} \\}$. For each orbit $\\alpha$, select a canonical representative $\\mathbf{k}_\\alpha$ (for example, the lexicographically minimal fractional coordinate in $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$) and assign a weight $w_\\alpha = \\dfrac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$, where $|\\cdot|$ denotes the size of the orbit. This choice ensures that the total weight sums to $1$, i.e., $\\sum_\\alpha w_\\alpha = 1$.\n- Use a numerically robust wrapping to $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ and a tolerance to recognize grid points mapped by symmetry operations.\n\nYour program must implement the above and produce, for each test case, the following tuple of results:\n- The integer number of irreducible points $M$.\n- The float sum of all weights $S$.\n- The float minimum weight among all irreducible points $\\min w_\\alpha$.\n- The float maximum weight among all irreducible points $\\max w_\\alpha$.\n- A boolean $b$ indicating whether $|S - 1|$ is less than a small tolerance (e.g., $10^{-12}$).\n\nTest suite:\n- Case A (general \"happy path\"): $\\mathbf{N} = (N_1, N_2, N_3) = (4, 4, 4)$ with point operations given by the cyclic fourfold rotations around the $z$-axis,\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{90} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{180} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{270} = \\begin{pmatrix} 0 & 1 & 0 \\\\ -1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.$$\n- Case B (boundary condition with no symmetry reduction): $\\mathbf{N} = (N_1, N_2, N_3) = (3, 3, 3)$ with only the identity operation,\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}.$$\n- Case C (edge case with inversion pairing): $\\mathbf{N} = (N_1, N_2, N_3) = (2, 2, 2)$ with inversion symmetry,\n  $$\\mathbf{R}_0 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix},\\quad\n    \\mathbf{R}_{\\mathrm{inv}} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}.$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list formatted as $[M,S,\\min w_\\alpha,\\max w_\\alpha,b]$. Thus the overall output must look like\n  $$\\big[ [M_A,S_A,\\min w_A,\\max w_A,b_A], [M_B,S_B,\\min w_B,\\max w_B,b_B], [M_C,S_C,\\min w_C,\\max w_C,b_C] \\big],$$\nwith all numbers printed as plain decimals and booleans as plain logical values. No physical units or angle units are involved in this problem; all quantities are dimensionless real numbers or integers.",
            "solution": "The problem posed is to develop a procedure for reducing a uniform Monkhorst-Pack (MP) k-point sampling grid of the Brillouin zone to its irreducible set, given a group of point symmetry operations. We must also calculate the corresponding weights for each irreducible k-point. This task is a cornerstone of modern electronic structure calculations, as it dramatically reduces computational cost by exploiting crystal symmetry. The problem is well-posed, scientifically sound, and provides sufficient information for a unique, algorithmic solution.\n\nWe begin by establishing the fundamental definitions and principles.\n\nA point $\\mathbf{k}$ in the reciprocal space is represented by fractional coordinates with respect to the primitive reciprocal lattice vectors. Periodicity implies that any two points $\\mathbf{k}$ and $\\mathbf{k}'$ are considered equivalent if they differ by an integer vector $\\mathbf{G} \\in \\mathbb{Z}^3$, i.e., $\\mathbf{k}' = \\mathbf{k} + \\mathbf{G}$. To work with a unique representation, we map all k-points into a canonical primitive cell, chosen here as the hypercube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$. This mapping, denoted $\\mathrm{wrap}(\\mathbf{k})$, is achieved by the operation $\\mathbf{k} \\mapsto \\mathbf{k} - \\lfloor \\mathbf{k} + \\tfrac{1}{2} \\rfloor$, where the operations are performed component-wise.\n\nThe Monkhorst-Pack (MP) grid is a uniform sampling of the reciprocal space. For a grid specified by integers $\\mathbf{N} = (N_1, N_2, N_3)$, a total of $N_{tot} = N_1 N_2 N_3$ points are generated. To ensure the grid is symmetric with respect to the origin (the $\\Gamma$-point), we construct the grid points $\\mathbf{k}=(k_1, k_2, k_3)$ where each component $k_j$ is given by:\n$$k_j = \\frac{2i_j - N_j - 1}{2N_j} \\quad \\text{for } i_j = 1, 2, \\dots, N_j$$\nThis construction generates a set of k-points that is invariant under the inversion operation $\\mathbf{k} \\mapsto -\\mathbf{k}$ (modulo reciprocal lattice vectors).\n\nThe point group of the crystal is given by a set of symmetry operations $\\{ \\mathbf{R} \\}$, which are $3 \\times 3$ integer matrices with determinant $\\det(\\mathbf{R}) = \\pm 1$. The action of an operation $\\mathbf{R}$ on a k-point $\\mathbf{k}$ is a linear transformation $\\mathbf{k}' = \\mathbf{R}\\mathbf{k}$, followed by wrapping the result back into the canonical cell.\n\nTwo k-points $\\mathbf{k}_a$ and $\\mathbf{k}_b$ are symmetry-equivalent if there exists an operation $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$ such that $\\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_a) = \\mathbf{k}_b$. The set of all points equivalent to a given point $\\mathbf{k}$ forms its orbit, $\\mathcal{O}(\\mathbf{k}) = \\{ \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}) \\mid \\mathbf{R} \\in \\{ \\mathbf{R} \\} \\}$. The fundamental property of these orbits is that they partition the full k-point grid into disjoint sets.\n\nThe goal is to find one representative k-point for each orbit. This set of representatives constitutes the irreducible Brillouin zone (IBZ) k-points for the given grid and symmetry. The choice of representative must be canonical to ensure uniqueness. A standard choice is the lexicographically smallest k-point within each orbit.\n\nThe weight $w_\\alpha$ of an irreducible k-point $\\mathbf{k}_\\alpha$ is defined as the ratio of the size of its orbit $|\\mathcal{O}(\\mathbf{k}_\\alpha)|$ to the total number of k-points in the full grid $N_{tot}$:\n$$w_\\alpha = \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_1 N_2 N_3}$$\nBy construction, the sum of the sizes of all disjoint orbits equals the total number of grid points, $\\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = N_{tot}$. Consequently, the sum of all weights must be equal to $1$:\n$$\\sum_\\alpha w_\\alpha = \\sum_\\alpha \\frac{|\\mathcal{O}(\\mathbf{k}_\\alpha)|}{N_{tot}} = \\frac{1}{N_{tot}} \\sum_\\alpha |\\mathcal{O}(\\mathbf{k}_\\alpha)| = \\frac{N_{tot}}{N_{tot}} = 1$$\n\nThe algorithm to implement this procedure is as follows:\n1.  **Grid Generation**: Given $\\mathbf{N}=(N_1, N_2, N_3)$, generate the full grid of $N_{tot}$ k-points using the origin-symmetric construction described above.\n2.  **Partitioning**: Iterate through each k-point $\\mathbf{k}_i$ in the full grid. To avoid redundant computations, maintain a set of `visited_points`.\n    a. If $\\mathbf{k}_i$ is already in `visited_points`, skip it as it belongs to an orbit that has already been processed.\n    b. If $\\mathbf{k}_i$ has not been visited, it is the first member of a new orbit to be discovered.\n3.  **Orbit Construction**: For the new point $\\mathbf{k}_i$, compute its full orbit by applying every symmetry operation $\\mathbf{R} \\in \\{ \\mathbf{R} \\}$:\n    a. Calculate $\\mathbf{k}' = \\mathrm{wrap}(\\mathbf{R}\\mathbf{k}_i)$.\n    b. Add the resulting unique points $\\mathbf{k}'$ to a temporary set representing the current orbit. Numerical tolerance is critical here; floating-point k-vectors are considered identical if their component-wise difference is smaller than a threshold, e.g., $10^{-8}$. Hashing rounded coordinate tuples is an effective technique for managing uniqueness.\n4.  **Irreducible Point and Weight**:\n    a. The size of the orbit, $|\\mathcal{O}(\\mathbf{k}_i)|$, is the number of unique points found in the previous step.\n    b. The weight is calculated as $w_i = |\\mathcal{O}(\\mathbf{k}_i)| / N_{tot}$.\n    c. The canonical representative for this orbit is selected as the lexicographically smallest vector among all points in the orbit.\n    d. Store the canonical representative and its weight.\n5.  **Update Visited set**: Add all points from the newly computed orbit to the `visited_points` set.\n6.  **Repeat**: Continue this process until all points in the full grid have been visited.\n7.  **Final Results**: Once the iteration is complete, the list of canonical representatives is the irreducible set of k-points. From the list of weights, calculate the total number of irreducible points $M$, the sum of weights $S$, the minimum weight $\\min w_\\alpha$, and the maximum weight $\\max w_\\alpha$. Verify that $|S - 1|$ is below a numerical tolerance.\n\nThis algorithm systematically partitions the full grid and correctly identifies the irreducible set and their weights, adhering to the principles of group theory as applied to crystal lattices.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def wrap_to_canonical_cell(k_vector):\n        \"\"\"\n        Wraps a fractional coordinate vector into the canonical cell [-0.5, 0.5).\n        This is equivalent to k -> k - floor(k + 0.5).\n        \"\"\"\n        return k_vector - np.floor(k_vector + 0.5)\n\n    def get_k_point_hash(k_vector, precision=8):\n        \"\"\"\n        Creates a hashable representation of a k-vector by rounding to a\n        fixed precision to handle floating point inaccuracies.\n        \"\"\"\n        return tuple(np.round(k_vector, precision))\n\n    def generate_mp_grid(n_dims):\n        \"\"\"\n        Generates a Gamma-centered (origin-symmetric) Monkhorst-Pack grid.\n        Args:\n            n_dims (tuple): A tuple (N1, N2, N3) of grid dimensions.\n        Returns:\n            np.ndarray: A (N1*N2*N3, 3) array of k-point coordinates.\n        \"\"\"\n        k_coords = []\n        for n in n_dims:\n            # Formula for Gamma-centered grid: (2*i - N - 1) / (2*N) for i=1..N\n            k_coords.append((2 * np.arange(1, n + 1) - n - 1) / (2 * n))\n        \n        # Use meshgrid with 'ij' indexing to get Cartesian product in a standard order\n        kx, ky, kz = np.meshgrid(k_coords[0], k_coords[1], k_coords[2], indexing='ij')\n        \n        # Stack and reshape to get a list of (kx, ky, kz) vectors\n        grid = np.stack([kx, ky, kz], axis=-1).reshape(-1, 3)\n        return grid\n\n    def compute_ibz(n_dims, r_ops, tol=1e-12, hash_precision=8):\n        \"\"\"\n        Computes the irreducible Brillouin zone (IBZ) for a given MP grid\n        and a set of point group symmetry operations.\n\n        Args:\n            n_dims (tuple): Grid dimensions (N1, N2, N3).\n            r_ops (list): List of 3x3 numpy arrays for symmetry operations.\n            tol (float): Tolerance for checking if the sum of weights is 1.\n            hash_precision (int): Decimal precision for hashing k-points.\n\n        Returns:\n            tuple: (M, S, min_w, max_w, b) where\n                M: Number of irreducible points.\n                S: Sum of weights.\n                min_w: Minimum weight.\n                max_w: Maximum weight.\n                b: Boolean, True if |S-1| < tol.\n        \"\"\"\n        n_total = np.prod(n_dims)\n        full_grid = generate_mp_grid(n_dims)\n        \n        visited_k_hashes = set()\n        ir_k_points = []\n        ir_weights = []\n        \n        for k_point in full_grid:\n            # Check if point has been visited (is part of a previously found orbit)\n            # We must wrap the point first to get its canonical representation\n            # before checking the visited set.\n            canonical_k_point = wrap_to_canonical_cell(k_point)\n            k_hash = get_k_point_hash(canonical_k_point, hash_precision)\n\n            if k_hash in visited_k_hashes:\n                continue\n            \n            # If not visited, this k-point starts a new orbit.\n            # Generate the orbit by applying all symmetry operations.\n            orbit_hashes = set()\n            for r_mat in r_ops:\n                k_rotated = r_mat @ k_point\n                k_wrapped = wrap_to_canonical_cell(k_rotated)\n                orbit_hashes.add(get_k_point_hash(k_wrapped, hash_precision))\n            \n            # Calculate orbit properties\n            orbit_size = len(orbit_hashes)\n            weight = orbit_size / n_total\n            \n            # Determine canonical representative (lexicographically smallest)\n            canonical_rep_tuple = min(orbit_hashes)\n            \n            ir_k_points.append(np.array(canonical_rep_tuple))\n            ir_weights.append(weight)\n            \n            # Mark all points in the newly found orbit as visited\n            visited_k_hashes.update(orbit_hashes)\n            \n        m = len(ir_k_points)\n        s = np.sum(ir_weights)\n        min_w = np.min(ir_weights) if ir_weights else 0.0\n        max_w = np.max(ir_weights) if ir_weights else 0.0\n        b = np.abs(s - 1.0) < tol\n        \n        return m, s, min_w, max_w, b\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": (4, 4, 4),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]),\n                np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (3, 3, 3),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            ]\n        },\n        {\n            \"N\": (2, 2, 2),\n            \"R\": [\n                np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n                np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]]),\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, s, min_w, max_w, b_val = compute_ibz(case[\"N\"], case[\"R\"])\n        results.append(f\"[{m},{s},{min_w},{max_w},{str(b_val).lower()}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}