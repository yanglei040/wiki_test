{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any Brillouin zone integration is the generation of a discrete set of $\\mathbf{k}$-points. A key challenge arises from the periodic nature of reciprocal space, which makes points on the Brillouin zone boundary equivalent to one another. This hands-on exercise  will guide you through implementing a robust algorithm to map a simple integer grid to a canonical, unique set of $\\mathbf{k}$-points, a fundamental procedure at the core of all electronic structure software.",
            "id": "3459456",
            "problem": "Consider a crystalline solid with a primitive Bravais lattice in real space, and let the reciprocal lattice be generated by the reciprocal basis vectors collected as columns of a matrix $B \\in \\mathbb{R}^{d \\times d}$, so that any wave vector $k \\in \\mathbb{R}^d$ can be written in reduced coordinates $u \\in \\mathbb{R}^d$ via $k = B u$. Reciprocal space is periodic under addition of reciprocal lattice vectors, so $k$ and $k + B m$ represent the same Bloch state for any integer vector $m \\in \\mathbb{Z}^d$. Consequently, when sampling the Brillouin Zone (BZ) for integrals over $k$-space, one must avoid double counting points related by addition of reciprocal lattice vectors. A standard remedy is to choose a canonical representative of each equivalence class modulo the reciprocal lattice, by restricting reduced coordinates to a single fundamental domain, for example the half-open hypercube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^d$.\n\nYou are asked to implement a program that, for each of several test cases, takes an integer grid of index tuples and maps each index tuple to a unique $k$-point modulo reciprocal lattice vectors, using the following setup:\n\n1. The reduced coordinate corresponding to an index $i \\in \\mathbb{Z}^d$ is defined by $u_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2}$ for each component $\\alpha = 1, \\ldots, d$, where $N \\in \\mathbb{N}^d$ is the grid size, and $s \\in [0,1)^d$ is a fixed shift vector.\n2. Two reduced coordinates $u$ and $u'$ represent the same equivalence class if $u' = u + m$ for some $m \\in \\mathbb{Z}^d$.\n3. Your mapping must assign a canonical reduced coordinate $u^{\\mathrm{canon}}$ in the half-open hypercube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^d$ to each index $i$, with the explicit convention that any component exactly on the upper boundary $\\tfrac{1}{2}$ is mapped to $-\\tfrac{1}{2}$ in that component, ensuring a unique representative and avoiding double counting at BZ boundaries.\n4. The canonical Cartesian $k$-point is then $k^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}$.\n\nFor practical numerical uniqueness, use a tolerance $\\varepsilon > 0$ in Cartesian space to determine equality of canonical $k$-points: two canonical $k$-points $k^{\\mathrm{canon}}$ and $(k^{\\mathrm{canon}})'$ are considered equal if $\\|k^{\\mathrm{canon}} - (k^{\\mathrm{canon}})'\\|_\\infty \\le \\varepsilon$, where $\\|\\cdot\\|_\\infty$ is the infinity norm. Your program must deduplicate points based on this criterion.\n\nFor each test case, after deduplication, define a uniform integration weight per unique canonical $k$-point as $w = \\frac{1}{\\prod_{\\alpha=1}^{d} N_\\alpha}$. Report the following for each case:\n- The integer count of unique canonical $k$-points.\n- A boolean indicating whether the sum of the weights of the unique canonical $k$-points equals $1$ within an absolute tolerance of $10^{-12}$.\n- The maximum multiplicity, defined as the maximum number of distinct index tuples that map to the same canonical $k$-point under your scheme.\n\nUse the following test suite. For each case, $B$ is given explicitly, $N$ is the grid size, $s$ is the shift, the index set $I$ is specified componentwise, and $\\varepsilon$ is the Cartesian deduplication tolerance.\n\n- Test Case 1 (one-dimensional, boundary-inclusion sanity check):\n  - $d = 1$\n  - $B = [1.0]$\n  - $N = (4)$\n  - $s = (0.0)$\n  - Index set $I = \\{0,1,2,3,4\\}$ (inclusive of both $0$ and $N$)\n  - $\\varepsilon = 10^{-12}$\n\n- Test Case 2 (two-dimensional, hexagonal reciprocal basis with both axes including boundaries):\n  - $d = 2$\n  - $B = \\begin{bmatrix} 1.0 & 0.5 \\\\ 0.0 & \\tfrac{\\sqrt{3}}{2} \\end{bmatrix}$\n  - $N = (3,3)$\n  - $s = (0.0, 0.0)$\n  - Index set $I = \\{0,1,2,3\\} \\times \\{0,1,2,3\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- Test Case 3 (three-dimensional, anisotropic reciprocal basis and grid sizes, boundaries included):\n  - $d = 3$\n  - $B = \\begin{bmatrix} 1.0 & 0.0 & 0.5 \\\\ 0.0 & 2.0 & 0.5 \\\\ 0.0 & 0.0 & 3.0 \\end{bmatrix}$\n  - $N = (2,1,4)$\n  - $s = (0.0, 0.0, 0.0)$\n  - Index set $I = \\{0,1,2\\} \\times \\{0,1\\} \\times \\{0,1,2,3,4\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- Test Case 4 (one-dimensional, extensive negative-to-positive indices):\n  - $d = 1$\n  - $B = [1.0]$\n  - $N = (5)$\n  - $s = (0.0)$\n  - Index set $I = \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- Test Case 5 (two-dimensional, non-orthogonal basis, mixed index ranges with a half-component shift):\n  - $d = 2$\n  - $B = \\begin{bmatrix} 1.0 & 0.3 \\\\ 0.2 & 1.1 \\end{bmatrix}$\n  - $N = (2,3)$\n  - $s = (0.5, 0.0)$\n  - Index set $I = \\{-2,-1,0,1,2\\} \\times \\{-3,-2,-1,0,1,2,3\\}$\n  - $\\varepsilon = 10^{-12}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, where each test case contributes three items: the unique count (integer), the weight-sum check (boolean), and the maximum multiplicity (integer). For example, the output format should be like $[c_1,b_1,m_1,c_2,b_2,m_2,\\ldots,c_5,b_5,m_5]$ with no spaces.",
            "solution": "We begin from the periodicity of Bloch states in reciprocal space. Let $L^* = \\{B m : m \\in \\mathbb{Z}^d\\}$ denote the reciprocal lattice. For any crystal momentum $k \\in \\mathbb{R}^d$, Bloch wave functions and band energies are periodic under addition by reciprocal lattice vectors, so any integrand $F(k)$ used in Brillouin Zone (BZ) integrals satisfies $F(k) = F(k + G)$ for all $G \\in L^*$. Therefore, integrals over $k$-space may be restricted to any fundamental domain of $L^*$ with appropriate normalization.\n\nTo implement uniform sampling without double counting at the BZ boundaries, it is sufficient to choose the reciprocal primitive cell as the fundamental domain for reduced coordinates. Let $u \\in \\mathbb{R}^d$ denote reduced coordinates such that $k = B u$. The equivalence relation $u \\sim u + m$ for $m \\in \\mathbb{Z}^d$ partitions $\\mathbb{R}^d$ into equivalence classes modulo $\\mathbb{Z}^d$. A canonical choice for representatives is the half-open hypercube\n$$\n\\mathcal{C} = \\left[-\\tfrac{1}{2}, \\tfrac{1}{2}\\right)^d,\n$$\nso that each equivalence class has a unique representative $u^{\\mathrm{canon}} \\in \\mathcal{C}$ and points on the upper boundary are identified with the corresponding lower boundary to avoid double counting.\n\nGiven an integer grid index $i \\in \\mathbb{Z}^d$, a grid size vector $N \\in \\mathbb{N}^d$, and a shift $s \\in [0,1)^d$, we define the reduced coordinate\n$$\nu_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2} \\quad \\text{for each} \\quad \\alpha = 1,\\ldots,d.\n$$\nThis defines a uniform grid in reduced coordinates before considering periodic identification. To map $u$ to its canonical representative in $\\mathcal{C}$, we use integer translations by $\\mathbb{Z}^d$. The core principle is that for any real number $x$, the expression $x - \\lfloor x + \\tfrac{1}{2} \\rfloor$ lies in the interval $[-\\tfrac{1}{2}, \\tfrac{1}{2})$. This follows from properties of the floor function:\n- Let $y = x + \\tfrac{1}{2}$. There exists a unique integer $m = \\lfloor y \\rfloor$ such that $m \\le y < m + 1$.\n- Then $x - m = y - \\tfrac{1}{2} - m \\in [-\\tfrac{1}{2}, \\tfrac{1}{2})$.\n- If $x = \\tfrac{1}{2}$ exactly, then $y = 1$, and $\\lfloor y \\rfloor = 1$, so $x - \\lfloor y \\rfloor = \\tfrac{1}{2} - 1 = -\\tfrac{1}{2}$, which enforces the boundary convention.\n\nApplying this componentwise yields the canonical reduced coordinate\n$$\nu^{\\mathrm{canon}}_\\alpha = u_\\alpha - \\left\\lfloor u_\\alpha + \\tfrac{1}{2} \\right\\rfloor, \\quad \\alpha = 1,\\ldots,d,\n$$\nand hence the canonical Cartesian $k$-point\n$$\nk^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}.\n$$\n\nNumerical implementation requires robust deduplication. Because floating-point arithmetic may represent rational values only approximately, we determine numerical equality of canonical $k$-points using a Cartesian tolerance $\\varepsilon > 0$ and the infinity norm:\n$$\n\\|k^{\\mathrm{canon}} - (k^{\\mathrm{canon}})'\\|_\\infty \\le \\varepsilon \\quad \\Rightarrow \\quad \\text{equal}.\n$$\nAlgorithmically, we can quantize each component of $k^{\\mathrm{canon}}$ by dividing by $\\varepsilon$ and rounding to the nearest integer to form a hashable key, which groups points within $\\varepsilon$.\n\nFor each test case, the steps are:\n1. Enumerate all index tuples $i$ from the specified index set $I$.\n2. Compute the reduced coordinate $u$ via $u_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2}$.\n3. Canonicalize by $u^{\\mathrm{canon}}_\\alpha = u_\\alpha - \\left\\lfloor u_\\alpha + \\tfrac{1}{2} \\right\\rfloor$, using a small positive numerical offset inside the floor to stabilize boundary cases under floating-point arithmetic, while preserving the mapping to $[-\\tfrac{1}{2}, \\tfrac{1}{2})$.\n4. Compute $k^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}$.\n5. Use quantized keys based on $\\varepsilon$ to deduplicate and count multiplicities: maintain a dictionary from keys to multiplicity counts.\n6. The number of unique canonical $k$-points is the number of dictionary entries. The maximum multiplicity is the maximum value among the dictionary counts.\n7. The uniform weight per unique canonical point is $w = \\frac{1}{\\prod_{\\alpha=1}^{d} N_\\alpha}$. The sum of weights equals $\\frac{\\text{unique\\_count}}{\\prod_{\\alpha} N_\\alpha}$, which should be $1$ if the canonicalization has exactly $\\prod_{\\alpha} N_\\alpha$ distinct representatives. We check $|\\text{sum\\_weights} - 1| \\le 10^{-12}$ and report a boolean.\n\nCorrectness arguments:\n- The floor-based canonicalization ensures each component lies in $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ and respects periodicity modulo $\\mathbb{Z}^d$, thereby selecting a unique representative per equivalence class, including boundary handling at $\\tfrac{1}{2}$ mapped to $-\\tfrac{1}{2}$.\n- Deduplication under $\\varepsilon$ reflects exact equivalence in the ideal arithmetic; with sufficiently small $\\varepsilon$ relative to the magnitude of $B$ and grid spacings, it avoids spurious merging.\n- For index sets that include both lower and upper boundaries (e.g., $\\{0,1,\\ldots,N\\}$) or extended ranges (e.g., $\\{-N,\\ldots,N\\}$), multiple indices map to the same canonical representative; the dictionary counts reflect multiplicities, while the unique count equals $\\prod_{\\alpha} N_\\alpha$ assuming all components cover a complete period of sampling in each direction.\n\nApplying the procedure to the supplied test suite:\n- Test Case 1 includes both $0$ and $N$ in one dimension, so points at $u = -\\tfrac{1}{2}$ and $u = \\tfrac{1}{2}$ are identified; the unique canonical set has size $N = 4$, the sum of weights is $1$, and the maximum multiplicity is $2$ at boundary points.\n- Test Case 2 covers $4 \\times 4$ indices with $N = (3,3)$, so each axis includes both boundaries; the unique canonical set has size $\\prod N_\\alpha = 9$, the sum of weights is $1$, and the corner points have multiplicity $4$ due to boundary identification in two dimensions.\n- Test Case 3 has $N = (2,1,4)$ and indices including boundaries; the unique canonical set has size $2 \\cdot 1 \\cdot 4 = 8$, the sum of weights is $1$, and the maximum multiplicity is $2 \\cdot 2 \\cdot 2 = 8$ at the corner where all axes include an upper boundary.\n- Test Case 4 spans indices from $-5$ to $5$ in one dimension with $N = 5$, thus sampling over multiple periods; the unique canonical set has size $5$, the sum of weights is $1$, and maximum multiplicity reflects how many indices fall into the same canonical equivalence class within the extended range.\n- Test Case 5 mixes negative-to-positive indices and a half-component shift in a non-orthogonal basis; canonicalization proceeds componentwise in reduced coordinates, producing a unique count equal to $\\prod N_\\alpha = 6$, a sum of weights equal to $1$, and a maximum multiplicity corresponding to the product of boundary duplications per axis.\n\nThe program implements this logic, deduplicates using the given tolerances, computes the requested quantities, and prints the aggregated results in the required single-line format.",
            "answer": "```python\nimport numpy as np\n\ndef canonicalize_reduced(u, eps=1e-12):\n    \"\"\"\n    Map reduced coordinates u to the half-open hypercube [-1/2, 1/2)^d\n    componentwise using floor(u + 1/2). A small eps is added to stabilize\n    boundary cases under floating-point arithmetic.\n    \"\"\"\n    return u - np.floor(u + 0.5 + eps)\n\ndef dedup_keys(k_points, tol):\n    \"\"\"\n    Deduplicate a set of Cartesian k-points using an infinity-norm tolerance tol.\n    Returns a dictionary mapping quantized keys to multiplicity counts.\n    The key is constructed by quantizing each component: round(k_i / tol) to int.\n    \"\"\"\n    counts = {}\n    for k in k_points:\n        key = tuple(np.round(k / tol).astype(np.int64).tolist())\n        counts[key] = counts.get(key, 0) + 1\n    return counts\n\ndef generate_indices(N, range_type):\n    \"\"\"\n    Generate index tuples for a grid size vector N according to range_type.\n    range_type can be:\n    - '0_to_N_inclusive': per dimension, indices i in {0, 1, ..., N}\n    - 'negN_to_posN_inclusive': per dimension, indices i in {-N, ..., N}\n    Returns a list of index tuples.\n    \"\"\"\n    ranges = []\n    for n in N:\n        if range_type == '0_to_N_inclusive':\n            ranges.append(range(0, n + 1))\n        elif range_type == 'negN_to_posN_inclusive':\n            ranges.append(range(-n, n + 1))\n        else:\n            raise ValueError(\"Unknown range_type\")\n    # Cartesian product of ranges\n    if len(ranges) == 1:\n        return [(i,) for i in ranges[0]]\n    elif len(ranges) == 2:\n        return [(i, j) for i in ranges[0] for j in ranges[1]]\n    elif len(ranges) == 3:\n        return [(i, j, k) for i in ranges[0] for j in ranges[1] for k in ranges[2]]\n    else:\n        # General case for d > 3\n        indices = [[]]\n        for r in ranges:\n            indices = [idx + [val] for idx in indices for val in r]\n        return [tuple(idx) for idx in indices]\n\ndef process_case(B, N, s, index_range_type, tol):\n    \"\"\"\n    Process a single test case:\n    - Build all index tuples according to index_range_type.\n    - Map to reduced coordinates u = (i + s)/N - 1/2.\n    - Canonicalize to u_canon in [-1/2, 1/2)^d.\n    - Map to Cartesian k = B @ u_canon.\n    - Deduplicate with tolerance tol.\n    - Return unique_count (int), weight_sum_ok (bool), max_multiplicity (int).\n    \"\"\"\n    N = np.array(N, dtype=np.int64)\n    s = np.array(s, dtype=np.float64)\n    B = np.array(B, dtype=np.float64)\n    d = len(N)\n    indices = generate_indices(N, index_range_type)\n\n    k_points = []\n    for idx in indices:\n        i = np.array(idx, dtype=np.float64)\n        u = (i + s) / N - 0.5\n        u_canon = canonicalize_reduced(u, eps=1e-12)\n        k = B @ u_canon\n        k_points.append(k)\n\n    counts = dedup_keys(k_points, tol)\n    unique_count = len(counts)\n    max_multiplicity = max(counts.values()) if counts else 0\n\n    total_grid_points = int(np.prod(N))\n    # Uniform weight per unique canonical point is 1 / prod(N)\n    weight_sum = unique_count / total_grid_points\n    weight_sum_ok = abs(weight_sum - 1.0) <= 1e-12\n\n    return unique_count, weight_sum_ok, max_multiplicity\n\ndef solve():\n    # Define the test cases from the problem statement.\n    sqrt3 = np.sqrt(3.0)\n    test_cases = [\n        # Test Case 1\n        {\n            \"B\": [[1.0]],\n            \"N\": (4,),\n            \"s\": (0.0,),\n            \"index_range_type\": \"0_to_N_inclusive\",\n            \"tol\": 1e-12\n        },\n        # Test Case 2\n        {\n            \"B\": [[1.0, 0.5],\n                  [0.0, sqrt3/2.0]],\n            \"N\": (3, 3),\n            \"s\": (0.0, 0.0),\n            \"index_range_type\": \"0_to_N_inclusive\",\n            \"tol\": 1e-12\n        },\n        # Test Case 3\n        {\n            \"B\": [[1.0, 0.0, 0.5],\n                  [0.0, 2.0, 0.5],\n                  [0.0, 0.0, 3.0]],\n            \"N\": (2, 1, 4),\n            \"s\": (0.0, 0.0, 0.0),\n            \"index_range_type\": \"0_to_N_inclusive\",\n            \"tol\": 1e-12\n        },\n        # Test Case 4\n        {\n            \"B\": [[1.0]],\n            \"N\": (5,),\n            \"s\": (0.0,),\n            \"index_range_type\": \"negN_to_posN_inclusive\",\n            \"tol\": 1e-12\n        },\n        # Test Case 5\n        {\n            \"B\": [[1.0, 0.3],\n                  [0.2, 1.1]],\n            \"N\": (2, 3),\n            \"s\": (0.5, 0.0),\n            \"index_range_type\": \"negN_to_posN_inclusive\",\n            \"tol\": 1e-12\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        unique_count, weight_ok, max_mult = process_case(\n            B=case[\"B\"],\n            N=case[\"N\"],\n            s=case[\"s\"],\n            index_range_type=case[\"index_range_type\"],\n            tol=case[\"tol\"]\n        )\n        results.extend([unique_count, weight_ok, max_mult])\n\n    # Final print statement in the exact required format: single line list, no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While a full grid of $\\mathbf{k}$-points covers the entire Brillouin zone, it is computationally wasteful for symmetric crystals. The crystal's point group symmetry ensures that large families of $\\mathbf{k}$-points are physically equivalent, and their contributions to BZ integrals are identical. This practice  delves into the essential technique of symmetry reduction, where you will programmatically reduce a full mesh to its unique subset—the Irreducible Brillouin Zone (IBZ)—and determine the correct integration weights, a crucial step for performing efficient and accurate calculations.",
            "id": "3459449",
            "problem": "You are given a simple cubic crystal with full octahedral symmetry, described by the point group $O_h$. Consider the Brillouin zone represented in reduced fractional reciprocal coordinates, where the fundamental domain is the half-open cube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$ and periodic boundary conditions identify points differing by integer reciprocal lattice vectors. A uniform $\\mathbf{k}$-point grid is constructed as follows: each component $k_{\\alpha}$ is restricted to the set $\\{-\\tfrac{1}{2}, -\\tfrac{1}{4}, 0, \\tfrac{1}{4}\\}$, resulting in a $4\\times 4\\times 4$ grid of $64$ points, which we denote by the set $\\mathcal{K}$.\n\nFundamental base definitions:\n- The Brillouin zone integration exploits crystal symmetry. Two wave vectors $\\mathbf{k}$ and $\\mathbf{k}'$ are symmetry-equivalent if there exists a point-group operation $R \\in O_h$ such that $\\mathbf{k}' = R \\mathbf{k}$ modulo a reciprocal lattice vector. Symmetry-equivalent points contribute identically to integrals over the Brillouin zone for scalar quantities invariant under the point group.\n- The full octahedral group $O_h$ in reciprocal space is represented by all orthogonal $3\\times 3$ matrices with entries in $\\{-1,0,1\\}$ that have exactly one nonzero entry per row and per column. This set includes $3!$ axis permutations combined with $2^3$ independent sign flips, yielding $48$ symmetry operations (both proper rotations and improper operations such as reflections via inversion combined with a $180^\\circ$ rotation).\n- Time-reversal symmetry for nonmagnetic crystals maps $\\mathbf{k}$ to $-\\mathbf{k}$. In the presence of inversion symmetry (included in $O_h$), $-\\mathbf{k}$ is already generated by a point-group operation. Nevertheless, we shall explicitly include the time-reversal operation in the algorithm to demonstrate its handling.\n\nAlgorithmic objectives:\n1. Define the group action. Let the set of symmetry operations be\n$$\n\\mathcal{G} = \\{ R \\in \\mathbb{R}^{3\\times 3} \\mid R \\text{ orthogonal}, R_{ij} \\in \\{-1,0,1\\}, \\text{ exactly one nonzero per row and column} \\}.\n$$\nInclude the time-reversal mapping $\\Theta: \\mathbf{k} \\mapsto -\\mathbf{k}$; note that $-I \\in \\mathcal{G}$, but include it explicitly and deduplicate.\n2. Implement a periodic wrap function consistent with the half-open Brillouin zone $[-\\tfrac{1}{2},\\tfrac{1}{2})^3$. In integer quarter units, let each component be represented by an integer $n \\in \\{-2,-1,0,1\\}$ corresponding to $n/4$. When symmetry transforms produce a component $n=2$ (which corresponds to $+\\tfrac{1}{2}$), wrap it to $n=-2$ (which corresponds to $-\\tfrac{1}{2}$), ensuring all coordinates remain in the half-open interval.\n3. For each $\\mathbf{k}\\in \\mathcal{K}$, form its orbit under the symmetry group with periodic wrapping:\n$$\n\\mathrm{Orbit}(\\mathbf{k}) = \\big\\{ \\operatorname{wrap}(R \\mathbf{k}) \\,\\big|\\, R \\in \\mathcal{G} \\cup \\{-I\\} \\big\\},\n$$\nwhere $\\operatorname{wrap}$ enforces membership in $[-\\tfrac{1}{2},\\tfrac{1}{2})^3$ component-wise.\n4. Define a canonical representative of the orbit as the lexicographically minimal vector in integer quarter units:\n$$\n\\mathbf{k}^\\star = \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{k}),\n$$\nusing the standard tuple ordering on $(n_x,n_y,n_z)$ where each $n_{\\alpha}\\in\\{-2,-1,0,1\\}$.\n5. Define the irreducible Brillouin zone (IBZ) as the set of all such canonical representatives across the grid:\n$$\n\\mathrm{IBZ} = \\big\\{ \\mathbf{k}^\\star \\,\\big|\\, \\mathbf{k} \\in \\mathcal{K} \\big\\}.\n$$\n6. The weight of a representative $\\mathbf{k}^\\star$ is the fraction of the full grid that maps to it:\n$$\nw(\\mathbf{k}^\\star) = \\frac{|\\{\\mathbf{q} \\in \\mathcal{K} \\mid \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{q}) = \\mathbf{k}^\\star \\}|}{|\\mathcal{K}|}.\n$$\nThese weights must sum to $1$ when aggregated over $\\mathrm{IBZ}$.\n\nImplementation requirements:\n- Construct all symmetry operations in $O_h$ as signed permutation matrices with one nonzero entry per row and column and entries in $\\{-1,0,1\\}$, and include $\\Theta$ explicitly as $-I$ before deduplication.\n- Represent coordinates in integer quarter units $n\\in\\{-2,-1,0,1\\}$ to ensure exact arithmetic.\n- Map each of the $64$ grid points to its IBZ representative and compute the weights as defined above.\n\nTest suite:\n- Test case $1$ (general coverage): Compute the total number of representatives $|\\mathrm{IBZ}|$ as an integer.\n- Test case $2$ (normalization check): Compute the sum $\\sum_{\\mathbf{k}^\\star \\in \\mathrm{IBZ}} w(\\mathbf{k}^\\star)$ as a float.\n- Test case $3$ (high-symmetry point): Compute the weight of the center $\\Gamma$ point $\\mathbf{k} = (0,0,0)$ as a float.\n- Test case $4$ (boundary corner): Compute the weight of the Brillouin zone corner $\\mathbf{k} = (-\\tfrac{1}{2}, -\\tfrac{1}{2}, -\\tfrac{1}{2})$ as a float.\n- Test case $5$ (boundary edge): Compute the weight of the edge point $\\mathbf{k} = (-\\tfrac{1}{2}, 0, 0)$ as a float.\n- Test case $6$ (generic interior with a zero component): Compute the weight of the interior point $\\mathbf{k} = (-\\tfrac{1}{4}, 0, \\tfrac{1}{4})$ as a float.\n- Test case $7$ (boolean normalization): Return a boolean indicating whether the normalization check satisfies $|\\sum w - 1| < 10^{-12}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$$\n\\big[\\, |\\mathrm{IBZ}|, \\, \\sum w, \\, w(0,0,0), \\, w(-\\tfrac{1}{2},-\\tfrac{1}{2},-\\tfrac{1}{2}), \\, w(-\\tfrac{1}{2},0,0), \\, w(-\\tfrac{1}{4},0,\\tfrac{1}{4}), \\, \\text{boolean} \\,\\big].\n$$\nAll floating-point values should be printed in decimal form; the boolean should be printed as either $\\text{True}$ or $\\text{False}$. No additional text should be printed.",
            "solution": "The problem is to determine the set of irreducible $\\mathbf{k}$-points and their corresponding weights for a specified uniform grid within the first Brillouin zone (BZ) of a simple cubic crystal. This reduction is achieved by exploiting the crystal's point group symmetry, specifically the octahedral group $O_h$, combined with time-reversal symmetry. The process involves mapping each point in the full grid to a canonical representative chosen from its symmetry-generated orbit.\n\n### 1. Symmetry Group and k-Point Grid Representation\n\nThe symmetry of the crystal is described by the octahedral point group $O_h$. In reciprocal space, the $48$ operations of this group are represented by the set of all $3\\times 3$ signed permutation matrices, which are orthogonal matrices with entries in $\\{-1, 0, 1\\}$ and exactly one nonzero entry per row and column. We denote this set of matrices as $\\mathcal{G}$. Time-reversal symmetry, $\\Theta: \\mathbf{k} \\mapsto -\\mathbf{k}$, corresponds to the matrix $-I$. The full symmetry group for our reduction is $\\mathcal{G} \\cup \\{-I\\}$, which, after removing duplicates (since $-I \\in \\mathcal{G}$), contains exactly $48$ unique operations.\n\nThe $\\mathbf{k}$-point grid, $\\mathcal{K}$, is a uniform $4\\times 4\\times 4$ mesh. The coordinates for each component $k_{\\alpha}$ are given as $\\{-\\tfrac{1}{2}, -\\tfrac{1}{4}, 0, \\tfrac{1}{4}\\}$. For exact integer arithmetic, we scale these by a factor of $4$, representing the grid points by integer vectors $(n_x, n_y, n_z)$ where each component $n_{\\alpha} \\in \\{-2, -1, 0, 1\\}$.\n\n### 2. Periodic Boundary Conditions and Wrapping\n\nThe Brillouin zone is defined as the half-open cube $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$. In our integer coordinate system, this corresponds to each component $n_{\\alpha}$ being in the set $\\{-2, -1, 0, 1\\}$. A symmetry operation $R$ applied to a vector $\\mathbf{k}$ may produce a vector $R\\mathbf{k}$ whose components lie outside this range. Specifically, for a grid point $\\mathbf{k}$ with a component $k_\\alpha = -\\tfrac{1}{2}$ (or $n_\\alpha = -2$), an operation that negates this component would yield $+\\tfrac{1}{2}$ (or $n_\\alpha = 2$). Due to the periodic nature of the reciprocal lattice, this point is equivalent to $-\\tfrac{1}{2}$. We must therefore apply a wrapping rule: any component $n_\\alpha = 2$ is mapped to $n_\\alpha = -2$. This ensures all transformed $\\mathbf{k}$-points remain within the defined fundamental domain.\n\n### 3. Irreducible Brillouin Zone (IBZ) Reduction Algorithm\n\nThe core of the task is to partition the full grid $\\mathcal{K}$ into disjoint sets of symmetry-equivalent points, known as orbits. From each orbit, a single canonical representative is chosen to form the irreducible Brillouin zone (IBZ). The weight of this representative is then the size of its orbit, normalized by the total number of points in the grid.\n\nThe algorithm proceeds as follows:\n1.  **Generate Symmetry Operations**: Construct the $48$ unique $3\\times 3$ integer matrices representing the operations of $O_h$, including inversion.\n2.  **Initialize Data Structures**: Create a mapping to store the canonical representative for each of the $64$ grid points and a counter for the number of points mapping to each representative.\n3.  **Iterate and Map**: For each point $\\mathbf{k}$ in the grid $\\mathcal{K}$:\n    a.  **Generate Orbit**: Compute the set of all unique points generated by applying every symmetry operation $R$ to $\\mathbf{k}$, followed by the periodic wrapping rule. This set is $\\mathrm{Orbit}(\\mathbf{k})$.\n    b.  **Find Canonical Representative**: Identify the representative $\\mathbf{k}^\\star$ for this orbit by selecting the lexicographically smallest vector in $\\mathrm{Orbit}(\\mathbf{k})$.\n    c.  **Store Mapping**: Record that $\\mathbf{k}$ maps to $\\mathbf{k}^\\star$.\n4.  **Count and Weigh**: After iterating through all $64$ points, aggregate the results. The set of all unique representatives $\\mathbf{k}^\\star$ constitutes the IBZ. For each $\\mathbf{k}^\\star \\in \\mathrm{IBZ}$, its count is the number of grid points that map to it. The weight is this count divided by the total number of grid points ($64$).\n$$w(\\mathbf{k}^\\star) = \\frac{|\\{\\mathbf{q} \\in \\mathcal{K} \\mid \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{q}) = \\mathbf{k}^\\star \\}|}{|\\mathcal{K}|}$$\n\n### 4. Calculation of Test Case Results\n\nApplying this algorithm yields the following classification of the $64$ grid points into $10$ distinct orbits, each identified by its lexicographically minimal representative.\n\n-   $\\mathbf{k}^\\star = (0,0,0)$: The $\\Gamma$ point. Its orbit contains only itself. Count = $1$. $w = 1/64$.\n-   $\\mathbf{k}^\\star = (-1,0,0)$: Represents points on faces, like $(\\pm\\tfrac{1}{4}, 0, 0)$. Orbit size = $6$. Count = $6$. $w = 6/64$.\n-   $\\mathbf{k}^\\star = (-1,-1,0)$: Represents points on face diagonals, like $(\\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4}, 0)$. Orbit size = $12$. Count = $12$. $w = 12/64$.\n-   $\\mathbf{k}^\\star = (-1,-1,-1)$: Represents general interior points, like $(\\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4})$. Orbit size = $8$. Count = $8$. $w = 8/64$.\n-   $\\mathbf{k}^\\star = (-2,0,0)$: Represents BZ boundary face centers, like $(-\\tfrac{1}{2}, 0, 0)$. Orbit size = $3$. Count = $3$. $w = 3/64$.\n-   $\\mathbf{k}^\\star = (-2,-1,0)$: Represents points on boundary faces, like $(-\\tfrac{1}{2}, \\pm\\tfrac{1}{4}, 0)$. Orbit size = $12$. Count = $12$. $w = 12/64$.\n-   $\\mathbf{k}^\\star = (-2,-1,-1)$: Represents points on boundary faces, like $(-\\tfrac{1}{2}, \\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4})$. Orbit size = $12$. Count = $12$. $w = 12/64$.\n-   $\\mathbf{k}^\\star = (-2,-2,0)$: Represents BZ boundary edge centers, like $(-\\tfrac{1}{2}, -\\tfrac{1}{2}, 0)$. Orbit size = $3$. Count = $3$. $w = 3/64$.\n-   $\\mathbf{k}^\\star = (-2,-2,-1)$: Represents points on boundary edges, like $(-\\tfrac{1}{2}, -\\tfrac{1}{2}, \\pm\\tfrac{1}{4})$. Orbit size = $6$. Count = $6$. $w = 6/64$.\n-   $\\mathbf{k}^\\star = (-2,-2,-2)$: The BZ corner point $(-\\tfrac{1}{2}, -\\tfrac{1}{2}, -\\tfrac{1}{2})$. Orbit size = $1$. Count = $1$. $w = 1/64$.\n\nThe total count is $1+6+12+8+3+12+12+3+6+1 = 64$.\n\n-   **Test case 1 ($|\\mathrm{IBZ}|$)**: There are $10$ unique representatives.\n-   **Test case 2 ($\\sum w$)**: The sum of weights is $\\frac{64}{64} = 1$.\n-   **Test case 3 ($w(0,0,0)$)**: The point $(0,0,0)$ is its own representative. Its weight is $1/64$.\n-   **Test case 4 ($w(-\\tfrac{1}{2},-\\tfrac{1}{2},-\\tfrac{1}{2})$)**: The point $(-2,-2,-2)$ is its own representative. Its weight is $1/64$.\n-   **Test case 5 ($w(-\\tfrac{1}{2},0,0)$)**: The point $(-2,0,0)$ has representative $(-2,0,0)$. Its weight is $3/64$.\n-   **Test case 6 ($w(-\\tfrac{1}{4},0,\\tfrac{1}{4})$)**: The point $(-1,0,1)$ has representative $(-1,-1,0)$. The weight of this representative is $12/64$.\n-   **Test case 7 (Normalization)**: The sum of weights is exactly $1$, so the condition $|\\sum w - 1| < 10^{-12}$ is satisfied.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes the irreducible Brillouin zone (IBZ) and weights for a given\n    k-point grid under octahedral group symmetry (O_h).\n    \"\"\"\n\n    # 1. Construct Symmetry Operations for the O_h group\n    # O_h is represented by all 3x3 signed permutation matrices.\n    permutations = list(itertools.permutations([0, 1, 2]))\n    sign_flips = list(itertools.product([-1, 1], repeat=3))\n    \n    op_matrices_set = set()\n    for p in permutations:\n        for s in sign_flips:\n            op = np.zeros((3, 3), dtype=int)\n            op[0, p[0]] = s[0]\n            op[1, p[1]] = s[1]\n            op[2, p[2]] = s[2]\n            op_matrices_set.add(tuple(map(tuple, op)))\n\n    # Explicitly include time-reversal (-I) and deduplicate.\n    # Note: -I is already in the set of signed permutation matrices.\n    neg_I = tuple(map(tuple, -np.identity(3, dtype=int)))\n    op_matrices_set.add(neg_I)\n    \n    # Final list of numpy array representations for the operations.\n    symmetry_ops = [np.array(op, dtype=int) for op in op_matrices_set]\n    \n    # 2. Define the k-point grid and the periodic wrapping function\n    # Coordinates are in integer quarter units: {-2, -1, 0, 1}\n    integer_coords = [-2, -1, 0, 1]\n    k_points = list(itertools.product(integer_coords, repeat=3))\n    total_k_points = len(k_points)\n\n    def wrap_vector(v):\n        \"\"\"Applies periodic wrapping to a k-vector component: 2 -> -2.\"\"\"\n        return tuple(-2 if c == 2 else c for c in v)\n\n    # 3. & 4. Find IBZ representatives and count their occurrences\n    k_to_rep = {}\n    rep_counts = {}\n\n    for k_tuple in k_points:\n        k_vec = np.array(k_tuple)\n        \n        orbit = set()\n        for op in symmetry_ops:\n            # Apply symmetry operation and wrap coordinates\n            transformed_k = op @ k_vec\n            wrapped_k = wrap_vector(transformed_k)\n            orbit.add(wrapped_k)\n        \n        # The canonical representative is the lexicographically smallest in the orbit\n        canonical_rep = min(orbit)\n        k_to_rep[k_tuple] = canonical_rep\n        \n    # Count how many k-points from the full grid map to each representative\n    for rep in k_to_rep.values():\n        rep_counts[rep] = rep_counts.get(rep, 0) + 1\n\n    # 5. Compute weights for each representative in the IBZ\n    ibz_k_points = rep_counts.keys()\n    weights = {k_star: count / total_k_points for k_star, count in rep_counts.items()}\n\n    # 6. Evaluate the test suite queries\n    # Test case 1: Total number of representatives in the IBZ\n    num_ibz = len(ibz_k_points)\n\n    # Test case 2: Sum of all weights (should be 1.0)\n    sum_of_weights = sum(weights.values())\n\n    # Test case 3: Weight of the Gamma point k = (0, 0, 0)\n    gamma_point_rep = k_to_rep[(0, 0, 0)]\n    w_gamma = weights.get(gamma_point_rep, 0.0)\n\n    # Test case 4: Weight of the corner point k = (-1/2, -1/2, -1/2) -> (-2, -2, -2)\n    corner_point_int = (-2, -2, -2)\n    corner_rep = k_to_rep[corner_point_int]\n    w_corner = weights.get(corner_rep, 0.0)\n\n    # Test case 5: Weight of the edge point k = (-1/2, 0, 0) -> (-2, 0, 0)\n    edge_point_int = (-2, 0, 0)\n    edge_rep = k_to_rep[edge_point_int]\n    w_edge = weights.get(edge_rep, 0.0)\n\n    # Test case 6: Weight of the point k = (-1/4, 0, 1/4) -> (-1, 0, 1)\n    generic_point_int = (-1, 0, 1)\n    generic_rep = k_to_rep[generic_point_int]\n    w_generic = weights.get(generic_rep, 0.0)\n\n    # Test case 7: Boolean check for normalization\n    is_normalized = abs(sum_of_weights - 1.0) < 1e-12\n\n    results = [\n        num_ibz,\n        sum_of_weights,\n        w_gamma,\n        w_corner,\n        w_edge,\n        w_generic,\n        is_normalized\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Standard uniform $\\mathbf{k}$-point meshes are effective for many systems, but their efficiency can diminish for materials with highly anisotropic electronic structures. For properties like electrical conductivity, which depend sensitively on the details of the Fermi surface, it is often better to adapt the sampling density to the physics of the problem. In this advanced practice , you will design and validate an anisotropic $\\mathbf{k}$-point mesh that is aligned with an elongated Fermi surface, demonstrating how tailored sampling strategies can significantly accelerate the convergence of calculated transport properties.",
            "id": "3459479",
            "problem": "Consider a three-dimensional anisotropic parabolic band for Bloch electrons in a crystal. The electronic energy dispersion near a band extremum is given by $E(\\mathbf{k}) = \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{\\hbar^2 k_\\alpha^2}{2 m^*_\\alpha}$, where $m^*_\\alpha$ are the direction-dependent effective masses, $\\hbar$ is the reduced Planck constant, and $\\mathbf{k} = (k_x, k_y, k_z)$ is the crystal momentum. The group velocity is defined by $v_\\alpha(\\mathbf{k}) = \\frac{1}{\\hbar} \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha}$. In the relaxation-time approximation of semiclassical Boltzmann transport theory with a constant scattering time $\\tau$, the conductivity tensor element $\\sigma_{\\alpha\\beta}$ is proportional to the integral over the Brillouin zone of $v_\\alpha(\\mathbf{k}) v_\\beta(\\mathbf{k}) \\delta(E(\\mathbf{k}) - E_F)$, where $E_F$ is the Fermi energy and $\\delta$ is the Dirac delta function.\n\nYour task is to design and implement a computational experiment that validates the improved convergence of transport tensor components when using anisotropic $k$-point meshes aligned to elongated Fermi surfaces by scaling grid axes according to effective masses $m^*_\\alpha$. Work within dimensionless units such that $\\hbar = 1$, and treat all quantities as dimensionless; the final outputs must be dimensionless real numbers. Angles are not used in this problem.\n\nStarting from the above fundamental definitions, implement the following:\n\n1. Construct two distinct $k$-point sampling strategies over a rectangular domain centered at $\\mathbf{k}=\\mathbf{0}$:\n   - A baseline isotropic uniform grid with $N_x = N_y = N_z = N_{\\mathrm{base}}$.\n   - An anisotropic grid in which the number of points $N_\\alpha$ along each axis is scaled in proportion to the axis-dependent extent of the Fermi surface, chosen such that the total number of points $N_x N_y N_z$ is approximately equal to the baseline total. Use a rectangular domain half-width $K_{\\max,\\alpha}$ along each axis that scales with the Fermi wavevector extent in that direction. Explicitly, choose $K_{\\max,\\alpha} = s \\, k_{F,\\alpha}$ with a safety factor $s > 1$ to ensure the energy shell is contained in the domain.\n\n2. Approximate the Dirac delta function $\\delta(E(\\mathbf{k}) - E_F)$ by a normalized Gaussian $g_\\eta(E(\\mathbf{k}) - E_F) = \\frac{1}{\\sqrt{2\\pi}\\,\\eta} \\exp\\!\\left(-\\frac{(E(\\mathbf{k}) - E_F)^2}{2 \\eta^2}\\right)$ with a small width parameter $\\eta$.\n\n3. For each grid, compute the diagonal components of a dimensionless transport vector $\\mathbf{S} = (S_x,S_y,S_z)$ where $S_\\alpha$ is proportional to the discrete approximation of $\\int v_\\alpha(\\mathbf{k})^2 \\delta(E(\\mathbf{k}) - E_F) \\, d^3k$ and then normalized so that $\\sum_{\\alpha} S_\\alpha = 1$.\n\n4. Derive, from first principles, an exact analytical reference for the normalized diagonal components $\\mathbf{S}^{\\mathrm{exact}}$ for the anisotropic parabolic band, and use it to quantify the error of each grid as the Euclidean norm $||\\mathbf{S} - \\mathbf{S}^{\\mathrm{exact}}||_2$.\n\n5. Validate improved convergence by computing, for each test case, the baseline isotropic-grid error and the anisotropic-grid error and reporting whether the anisotropic grid yields a strictly smaller error.\n\nUse mid-point sampling (cell centers) for numerical integration with a uniform rectangular rule. Your domain half-widths $K_{\\max,\\alpha}$ must be sufficiently large to capture the energy shell defined by $E(\\mathbf{k}) = E_F$; choose $K_{\\max,\\alpha} = s \\, k_{F,\\alpha}$ with $s = 2.0$. In dimensionless units with $\\hbar = 1$, the axis-dependent Fermi wavevector $k_{F,\\alpha}$ is given by the radius of the constant-energy ellipsoid along axis $\\alpha$ implied by the dispersion. The anisotropic grid sizes $N_\\alpha$ must be scaled in proportion to $k_{F,\\alpha}$ and normalized such that $N_x N_y N_z \\approx N_{\\mathrm{base}}^3$, with each $N_\\alpha \\geq 3$.\n\nTest Suite:\nImplement your program to run the following test cases, each specified as $(m^*_x, m^*_y, m^*_z, E_F, N_{\\mathrm{base}}, \\eta)$ using the dimensionless conventions above:\n- Case A (happy path): $(0.2, 1.0, 5.0, 0.20, 14, 0.010)$.\n- Case B (isotropic boundary): $(1.0, 1.0, 1.0, 0.20, 14, 0.010)$.\n- Case C (strong anisotropy edge): $(0.05, 1.2, 25.0, 0.15, 14, 0.007)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a comma-separated list of results for the three test cases, enclosed in square brackets. Each test case result must itself be a list containing three entries in order: the isotropic-grid error as a float, the anisotropic-grid error as a float, and a boolean indicating whether the anisotropic-grid error is strictly smaller than the isotropic-grid error. For example, the output must have the form \"[[e_iso_A,e_aniso_A,improved_A],[e_iso_B,e_aniso_B,improved_B],[e_iso_C,e_aniso_C,improved_C]]\", where each \"e_*\" is a dimensionless float.",
            "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded in the principles of solid-state physics, is well-posed, objective, self-contained, and internally consistent. It presents a non-trivial computational task that is both feasible and verifiable.\n\n### 1. Theoretical Framework and Analytical Solution\n\nThe problem asks us to analyze the numerical convergence of a transport-related quantity for an anisotropic electronic band structure. The core of the problem lies in the evaluation of an integral over the Brillouin zone, which is proportional to a component of the conductivity tensor in the relaxation-time approximation.\n\nThe electronic energy dispersion is given by the anisotropic parabolic model:\n$$ E(\\mathbf{k}) = \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{\\hbar^2 k_\\alpha^2}{2 m^*_\\alpha} $$\nwhere $m^*_\\alpha$ is the effective mass along the principal axis $\\alpha$ and $\\mathbf{k} = (k_x, k_y, k_z)$ is the crystal momentum vector. The problem is formulated in dimensionless units where the reduced Planck constant $\\hbar = 1$, so the dispersion simplifies to:\n$$ E(\\mathbf{k}) = \\sum_{\\alpha} \\frac{k_\\alpha^2}{2 m^*_\\alpha} $$\nThe group velocity of an electron in a state $\\mathbf{k}$ is defined as:\n$$ v_\\alpha(\\mathbf{k}) = \\frac{1}{\\hbar} \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha} = \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha} = \\frac{k_\\alpha}{m^*_\\alpha} $$\nWe are tasked with computing the diagonal components of a normalized transport vector $\\mathbf{S}$, where each component $S_\\alpha$ is derived from the un-normalized integral $I_\\alpha$:\n$$ I_\\alpha = \\int_{\\text{BZ}} v_\\alpha(\\mathbf{k})^2 \\delta(E(\\mathbf{k}) - E_F) \\, d^3k $$\nHere, $E_F$ is the Fermi energy and $\\delta$ is the Dirac delta function, which constrains the integration to the constant-energy surface $E(\\mathbf{k}) = E_F$, known as the Fermi surface.\n\nTo derive the exact analytical reference $\\mathbf{S}^{\\mathrm{exact}}$, we evaluate the integral $I_\\alpha$. Substituting the expressions for $v_\\alpha$ and $E(\\mathbf{k})$:\n$$ I_\\alpha = \\int \\left(\\frac{k_\\alpha}{m^*_\\alpha}\\right)^2 \\delta\\left(\\sum_{\\beta} \\frac{k_\\beta^2}{2 m^*_\\beta} - E_F\\right) \\, d^3k $$\nTo solve this integral, we perform a change of variables to map the ellipsoidal Fermi surface onto a unit sphere. Let us define a new set of coordinates $\\mathbf{q} = (q_x, q_y, q_z)$ such that:\n$$ q_\\beta = \\frac{k_\\beta}{\\sqrt{2 m^*_\\beta E_F}} $$\nThis implies $k_\\beta = q_\\beta \\sqrt{2 m^*_\\beta E_F}$. The Jacobian of this transformation for the volume element is:\n$$ d^3k = \\left(\\frac{\\partial k_x}{\\partial q_x}\\frac{\\partial k_y}{\\partial q_y}\\frac{\\partial k_z}{\\partial q_z}\\right) d^3q = \\left(\\sqrt{2 m^*_x E_F} \\sqrt{2 m^*_y E_F} \\sqrt{2 m^*_z E_F}\\right) d^3q \\\\ = (2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z} \\, d^3q $$\nThe energy expression transforms to:\n$$ E(\\mathbf{q}) = \\sum_{\\beta} \\frac{(q_\\beta \\sqrt{2 m^*_\\beta E_F})^2}{2 m^*_\\beta} = E_F \\sum_{\\beta} q_\\beta^2 = E_F |\\mathbf{q}|^2 $$\nThe argument of the Dirac delta function becomes $E_F|\\mathbf{q}|^2 - E_F = E_F(|\\mathbf{q}|^2 - 1)$. Using the property $\\delta(ax) = \\frac{1}{|a|}\\delta(x)$, we have $\\delta(E_F(|\\mathbf{q}|^2 - 1)) = \\frac{1}{E_F}\\delta(|\\mathbf{q}|^2 - 1)$.\n\nThe term $v_\\alpha^2 = (k_\\alpha/m^*_\\alpha)^2$ becomes:\n$$ \\left(\\frac{q_\\alpha \\sqrt{2 m^*_\\alpha E_F}}{m^*_\\alpha}\\right)^2 = \\frac{q_\\alpha^2 (2 m^*_\\alpha E_F)}{(m^*_\\alpha)^2} = \\frac{2 E_F}{m^*_\\alpha} q_\\alpha^2 $$\nSubstituting all transformed parts back into the integral for $I_\\alpha$:\n$$ I_\\alpha = \\int \\left(\\frac{2 E_F}{m^*_\\alpha} q_\\alpha^2\\right) \\left(\\frac{1}{E_F} \\delta(|\\mathbf{q}|^2 - 1)\\right) \\left((2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z}\\right) d^3q $$\n$$ I_\\alpha = \\frac{2}{m^*_\\alpha} \\left((2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z}\\right) \\int q_\\alpha^2 \\delta(|\\mathbf{q}|^2 - 1) \\, d^3q $$\nThe integral $\\int q_\\alpha^2 \\delta(|\\mathbf{q}|^2 - 1) \\, d^3q$ is now over a unit sphere in $\\mathbf{q}$-space. By symmetry, this integral has the same value for $\\alpha=x, y, z$. Let this constant value be $C_q$. All other terms in the expression for $I_\\alpha$ that depend on material parameters ($m^*_\\alpha$) or $E_F$ are factored out. We see that the dependence on the axis index $\\alpha$ is solely through the prefactor:\n$$ I_\\alpha \\propto \\frac{1}{m^*_\\alpha} $$\nThe un-normalized transport components are thus $S'_\\alpha = C \\cdot (1/m^*_\\alpha)$ for some constant $C$. To find the normalized vector $\\mathbf{S}^{\\mathrm{exact}}$, we compute:\n$$ S^{\\mathrm{exact}}_\\alpha = \\frac{S'_\\alpha}{\\sum_{\\beta} S'_\\beta} = \\frac{C/m^*_\\alpha}{\\sum_{\\beta} C/m^*_\\beta} = \\frac{1/m^*_\\alpha}{1/m^*_x + 1/m^*_y + 1/m^*_z} $$\nThis is the exact analytical result that will serve as our reference.\n\n### 2. Numerical Integration Scheme\n\nThe problem requires a numerical approximation of the integral $I_\\alpha$. The Dirac delta is approximated by a narrow Gaussian function:\n$$ \\delta(E - E_F) \\approx g_\\eta(E - E_F) = \\frac{1}{\\sqrt{2\\pi}\\,\\eta} \\exp\\left(-\\frac{(E(\\mathbf{k}) - E_F)^2}{2 \\eta^2}\\right) $$\nThe integral is performed over a finite rectangular domain in $\\mathbf{k}$-space, defined by half-widths $K_{\\max,\\alpha} = s \\cdot k_{F,\\alpha}$, where $s=2.0$ is a safety factor. The Fermi wavevector $k_{F,\\alpha}$ represents the extent of the Fermi surface along axis $\\alpha$ and is found by setting $E(\\mathbf{k})=E_F$ and $k_\\beta=0$ for $\\beta \\neq \\alpha$:\n$$ E_F = \\frac{k_{F,\\alpha}^2}{2 m^*_\\alpha} \\implies k_{F,\\alpha} = \\sqrt{2 m^*_\\alpha E_F} $$\nThe integral is discretized using a midpoint rule on a rectangular grid. For a grid with $N_\\alpha$ points and half-width $K_{\\max,\\alpha}$ along each axis, the step size is $\\Delta k_\\alpha = 2K_{\\max,\\alpha}/N_\\alpha$. The grid points are the centers of the integration cells:\n$$ k_{\\alpha,i} = -K_{\\max,\\alpha} + (i + 0.5) \\Delta k_\\alpha, \\quad i = 0, 1, \\dots, N_\\alpha - 1 $$\nThe volume of each cell in $\\mathbf{k}$-space is $\\Delta V_k = \\Delta k_x \\Delta k_y \\Delta k_z$. The numerical approximation of $I_\\alpha$ is:\n$$ I_\\alpha \\approx \\sum_{i,j,l} v_\\alpha(\\mathbf{k}_{ijl})^2 \\, g_\\eta(E(\\mathbf{k}_{ijl}) - E_F) \\, \\Delta V_k $$\nwhere the sum is over all grid points $\\mathbf{k}_{ijl} = (k_{x,i}, k_{y,j}, k_{z,l})$. After computing the un-normalized components $S'_\\alpha \\approx I_\\alpha$, they are normalized to obtain the numerical result $\\mathbf{S}$.\n\n### 3. Grid Construction\n\nTwo different sampling grids are compared:\n\n- **Isotropic Grid**: This grid uses an equal number of points along each axis, $N_x = N_y = N_z = N_{\\mathrm{base}}$. The total number of points is $N_{\\mathrm{base}}^3$.\n\n- **Anisotropic Grid**: This grid adapts the sampling density to the shape of the Fermi surface. For an elongated ellipsoid, more points are allocated along the longer axes. The number of points $N_\\alpha$ is scaled proportionally to the Fermi wavevector extent $k_{F,\\alpha}$:\n$$ N_\\alpha \\propto k_{F,\\alpha} $$\nA normalization constant is chosen such that the total number of points is approximately the same as in the isotropic case: $N_x N_y N_z \\approx N_{\\mathrm{base}}^3$. This leads to the scaling rule:\n$$ N_\\alpha = \\text{round}\\left( N_{\\mathrm{base}} \\frac{k_{F,\\alpha}}{(k_{F,x}k_{F,y}k_{F,z})^{1/3}} \\right) $$\nEach $N_\\alpha$ is constrained to be at least $3$. This strategy aims to maintain a roughly constant number of sampling points per unit surface area of the Fermi surface, which should lead to improved accuracy for a fixed total number of points.\n\n### 4. Error Calculation\n\nFor each grid type (isotropic and anisotropic), the computed normalized vector $\\mathbf{S}^{\\mathrm{num}}$ is compared against the analytical reference $\\mathbf{S}^{\\mathrm{exact}}$. The error is quantified using the Euclidean norm of the difference vector:\n$$ \\text{error} = ||\\mathbf{S}^{\\mathrm{num}} - \\mathbf{S}^{\\mathrm{exact}}||_2 = \\sqrt{\\sum_{\\alpha} (S^{\\mathrm{num}}_\\alpha - S^{\\mathrm{exact}}_\\alpha)^2} $$\nThe final step is to compare the errors from the two grids to validate that the anisotropic grid provides a more accurate result for anisotropic systems.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational experiment for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: (m*_x, m*_y, m*_z, E_F, N_base, eta)\n        (0.2, 1.0, 5.0, 0.20, 14, 0.010),\n        # Case B\n        (1.0, 1.0, 1.0, 0.20, 14, 0.010),\n        # Case C\n        (0.05, 1.2, 25.0, 0.15, 14, 0.007),\n    ]\n\n    results = []\n    for case in test_cases:\n        m_stars_tuple, E_F, N_base, eta = case[0:3], case[3], case[4], case[5]\n        m_stars = np.array(m_stars_tuple)\n\n        # 1. Derive the exact analytical reference S^exact\n        inv_m_stars = 1.0 / m_stars\n        S_exact = inv_m_stars / np.sum(inv_m_stars)\n\n        # 2. Define integration domain and common parameters\n        s_factor = 2.0\n        kF_vec = np.sqrt(2 * m_stars * E_F)\n        Kmax_vec = s_factor * kF_vec\n\n        # Helper function for the numerical calculation\n        def _calculate_S(m_s, EF, n_eta, N_vec, K_vec):\n            \"\"\"\n            Calculates the normalized transport vector S for a given grid.\n            \"\"\"\n            m_x, m_y, m_z = m_s\n            Nx, Ny, Nz = N_vec\n            Kmax_x, Kmax_y, Kmax_z = K_vec\n\n            # Create k-point coordinates using midpoint rule\n            delta_k = 2 * K_vec / N_vec\n            kx_pts = -Kmax_x + (np.arange(Nx) + 0.5) * delta_k[0]\n            ky_pts = -Kmax_y + (np.arange(Ny) + 0.5) * delta_k[1]\n            kz_pts = -Kmax_z + (np.arange(Nz) + 0.5) * delta_k[2]\n\n            # Create 3D grid\n            Kx, Ky, Kz = np.meshgrid(kx_pts, ky_pts, kz_pts, indexing='ij')\n\n            # Calculate energy and velocity squared on the grid\n            E = Kx**2 / (2 * m_x) + Ky**2 / (2 * m_y) + Kz**2 / (2 * m_z)\n            Vx_sq = (Kx / m_x)**2\n            Vy_sq = (Ky / m_y)**2\n            Vz_sq = (Kz / m_z)**2\n\n            # Approximate Dirac delta with a Gaussian\n            gauss_arg = -(E - EF)**2 / (2 * n_eta**2)\n            gaussian = (1.0 / (np.sqrt(2 * np.pi) * n_eta)) * np.exp(gauss_arg)\n\n            # Numerical integration\n            dV_k = delta_k[0] * delta_k[1] * delta_k[2]\n            S_prime_x = np.sum(Vx_sq * gaussian) * dV_k\n            S_prime_y = np.sum(Vy_sq * gaussian) * dV_k\n            S_prime_z = np.sum(Vz_sq * gaussian) * dV_k\n            \n            S_prime_vec = np.array([S_prime_x, S_prime_y, S_prime_z])\n            total_S_prime = np.sum(S_prime_vec)\n\n            if total_S_prime == 0:\n                # Fallback for cases where integral is zero, though unlikely here\n                return np.array([1/3.0, 1/3.0, 1/3.0])\n\n            # Normalize the vector\n            return S_prime_vec / total_S_prime\n\n        # 3. Isotropic grid calculation\n        N_iso = np.array([N_base, N_base, N_base], dtype=int)\n        S_iso = _calculate_S(m_stars, E_F, eta, N_iso, Kmax_vec)\n        error_iso = np.linalg.norm(S_iso - S_exact)\n\n        # 4. Anisotropic grid calculation\n        # Handle case where a kF is zero to avoid division by zero or NaN\n        if np.any(kF_vec == 0):\n             # This can happen if E_F=0 or an m*=0. All kF_a will be same.\n             kF_geom_mean = 0\n             N_aniso_unrounded = np.full(3, N_base) # effectively an isotropic grid\n        else:\n             kF_geom_mean = np.prod(kF_vec)**(1.0/3.0)\n             N_aniso_unrounded = N_base * kF_vec / kF_geom_mean\n        \n        N_aniso = np.maximum(3, np.round(N_aniso_unrounded)).astype(int)\n        \n        S_aniso = _calculate_S(m_stars, E_F, eta, N_aniso, Kmax_vec)\n        error_aniso = np.linalg.norm(S_aniso - S_exact)\n\n        # 5. Store results for the case\n        improved = error_aniso < error_iso\n        results.append([error_iso, error_aniso, improved])\n\n    # Final output formatting\n    # Example format: [[e_iso_A,e_aniso_A,improved_A],[e_iso_B,e_aniso_B,improved_B],...]\n    # str(True) -> 'True', str(False) -> 'False'\n    case_results_str = []\n    for res in results:\n        # res is [float, float, bool]\n        case_results_str.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}