{
    "hands_on_practices": [
        {
            "introduction": "在计算中生成$k$点网格时，必须仔细处理布里渊区的周期性边界，以避免重复计数。本练习旨在通过亲手实践，实现一个将整数网格索引映射到唯一$k$点的规范化方案。掌握这一基本技能是正确执行布里渊区积分计算的前提。",
            "id": "3459456",
            "problem": "考虑一个在实空间中具有原胞布拉菲晶格的晶体固体，其倒易晶格由倒易基矢生成，这些基矢作为矩阵 $B \\in \\mathbb{R}^{d \\times d}$ 的列向量。因此，任何波矢 $k \\in \\mathbb{R}^d$ 都可以通过 $k = B u$ 写成简约坐标 $u \\in \\mathbb{R}^d$ 的形式。倒易空间在加上倒易晶格矢量后是周期性的，因此对于任何整数矢量 $m \\in \\mathbb{Z}^d$，$k$ 和 $k + B m$ 表示相同的布洛赫态。因此，在为 $k$ 空间积分对布里渊区（BZ）进行采样时，必须避免重复计数因加上倒易晶格矢量而关联的点。一个标准的解决方法是通过将简约坐标限制在单个基本域内（例如半开超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^d$），为每个模倒易晶格的等价类选择一个典范代表元。\n\n你需要实现一个程序，对于几个测试用例，该程序接受一个整数索引元组网格，并使用以下设置将每个索引元组映射到一个唯一的 $k$ 点（模倒易晶格矢量）：\n\n1. 对于每个分量 $\\alpha = 1, \\ldots, d$，与索引 $i \\in \\mathbb{Z}^d$ 对应的简约坐标定义为 $u_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2}$，其中 $N \\in \\mathbb{N}^d$ 是网格尺寸，$s \\in [0,1)^d$ 是一个固定的位移矢量。\n2. 如果对于某个 $m \\in \\mathbb{Z}^d$ 有 $u' = u + m$，则两个简约坐标 $u$ 和 $u'$ 表示同一个等价类。\n3. 你的映射必须为每个索引 $i$ 分配一个位于半开超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^d$ 中的典范简约坐标 $u^{\\mathrm{canon}}$，并明确约定任何恰好位于上边界 $\\tfrac{1}{2}$ 的分量在该分量上被映射到 $-\\tfrac{1}{2}$，以确保唯一的代表元并避免在布里渊区边界上重复计数。\n4. 典范笛卡尔 $k$ 点则为 $k^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}$。\n\n为了实际的数值唯一性，请在笛卡尔空间中使用一个容差 $\\varepsilon > 0$ 来确定典范 $k$ 点的相等性：如果 $\\|k^{\\mathrm{canon}} - (k^{\\mathrm{canon}})'\\|_\\infty \\le \\varepsilon$，则认为两个典范 $k$ 点 $k^{\\mathrm{canon}}$ 和 $(k^{\\mathrm{canon}})'$ 相等，其中 $\\|\\cdot\\|_\\infty$ 是无穷范数。你的程序必须根据此标准对点进行去重。\n\n对于每个测试用例，去重后，为每个唯一的典范 $k$ 点定义一个均匀积分权重 $w = \\frac{1}{\\prod_{\\alpha=1}^{d} N_\\alpha}$。为每种情况报告以下内容：\n- 唯一典范 $k$ 点的整数计数。\n- 一个布尔值，指示唯一典范 $k$ 点的权重之和是否在 $10^{-12}$ 的绝对容差内等于 $1$。\n- 最大多重性，定义为在你的方案下映射到同一个典范 $k$ 点的不同索引元组的最大数量。\n\n使用以下测试套件。对于每种情况，$B$ 被明确给出，$N$ 是网格尺寸，$s$ 是位移，索引集 $I$ 按分量指定，$\\varepsilon$ 是笛卡尔去重容差。\n\n- 测试用例 1（一维，包含边界的健全性检查）：\n  - $d = 1$\n  - $B = [1.0]$\n  - $N = (4)$\n  - $s = (0.0)$\n  - 索引集 $I = \\{0,1,2,3,4\\}$（包含 $0$ 和 $N$）\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例 2（二维，六方倒易基，两个轴都包含边界）：\n  - $d = 2$\n  - $B = \\begin{bmatrix} 1.0  0.5 \\\\ 0.0  \\tfrac{\\sqrt{3}}{2} \\end{bmatrix}$\n  - $N = (3,3)$\n  - $s = (0.0, 0.0)$\n  - 索引集 $I = \\{0,1,2,3\\} \\times \\{0,1,2,3\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例 3（三维，各向异性倒易基和网格尺寸，包含边界）：\n  - $d = 3$\n  - $B = \\begin{bmatrix} 1.0  0.0  0.5 \\\\ 0.0  2.0  0.5 \\\\ 0.0  0.0  3.0 \\end{bmatrix}$\n  - $N = (2,1,4)$\n  - $s = (0.0, 0.0, 0.0)$\n  - 索引集 $I = \\{0,1,2\\} \\times \\{0,1\\} \\times \\{0,1,2,3,4\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例 4（一维，从负到正的广泛索引范围）：\n  - $d = 1$\n  - $B = [1.0]$\n  - $N = (5)$\n  - $s = (0.0)$\n  - 索引集 $I = \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例 5（二维，非正交基，混合索引范围，带半分量位移）：\n  - $d = 2$\n  - $B = \\begin{bmatrix} 1.0  0.3 \\\\ 0.2  1.1 \\end{bmatrix}$\n  - $N = (2,3)$\n  - $s = (0.5, 0.0)$\n  - 索引集 $I = \\{-2,-1,0,1,2\\} \\times \\{-3,-2,-1,0,1,2,3\\}$\n  - $\\varepsilon = 10^{-12}$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按测试用例的顺序排列，每个测试用例贡献三项：唯一计数（整数）、权重和检查（布尔值）和最大多重性（整数）。例如，输出格式应类似于 $[c_1,b_1,m_1,c_2,b_2,m_2,\\ldots,c_5,b_5,m_5]$，不含空格。",
            "solution": "我们从布洛赫态在倒易空间中的周期性开始。令 $L^* = \\{B m : m \\in \\mathbb{Z}^d\\}$ 表示倒易晶格。对于任何晶体动量 $k \\in \\mathbb{R}^d$，布洛赫波函数和能带能量在加上倒易晶格矢量后是周期性的，因此任何用于布里渊区（BZ）积分的被积函数 $F(k)$ 都满足 $F(k) = F(k + G)$，其中 $G \\in L^*$。因此，对 $k$ 空间的积分可以限制在 $L^*$ 的任何一个基本域内，并进行适当的归一化。\n\n为了在布里渊区边界上实现均匀采样而不重复计数，选择倒易原胞作为简约坐标的基本域是充分的。令 $u \\in \\mathbb{R}^d$ 表示简约坐标，使得 $k = B u$。等价关系 $u \\sim u + m$（其中 $m \\in \\mathbb{Z}^d$）将 $\\mathbb{R}^d$ 划分为模 $\\mathbb{Z}^d$ 的等价类。代表元的典范选择是半开超立方体\n$$\n\\mathcal{C} = \\left[-\\tfrac{1}{2}, \\tfrac{1}{2}\\right)^d,\n$$\n这样每个等价类在 $\\mathcal{C}$ 中都有一个唯一的代表元 $u^{\\mathrm{canon}}$，并且上边界的点与相应的下边界点等同，以避免重复计数。\n\n给定一个整数网格索引 $i \\in \\mathbb{Z}^d$、一个网格尺寸矢量 $N \\in \\mathbb{N}^d$ 和一个位移 $s \\in [0,1)^d$，我们定义简约坐标\n$$\nu_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2} \\quad \\text{对于每个} \\quad \\alpha = 1,\\ldots,d.\n$$\n这在考虑周期性等同之前，定义了一个在简约坐标中的均匀网格。为了将 $u$ 映射到其在 $\\mathcal{C}$ 中的典范代表元，我们使用 $\\mathbb{Z}^d$ 的整数平移。核心原理是，对于任何实数 $x$，表达式 $x - \\lfloor x + \\tfrac{1}{2} \\rfloor$ 位于区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内。这可以由向下取整函数的性质得出：\n- 令 $y = x + \\tfrac{1}{2}$。存在一个唯一的整数 $m = \\lfloor y \\rfloor$ 使得 $m \\le y  m + 1$。\n- 那么 $x - m = y - \\tfrac{1}{2} - m \\in [-\\tfrac{1}{2}, \\tfrac{1}{2})$。\n- 如果 $x$ 恰好等于 $\\tfrac{1}{2}$，那么 $y = 1$，且 $\\lfloor y \\rfloor = 1$，所以 $x - \\lfloor y \\rfloor = \\tfrac{1}{2} - 1 = -\\tfrac{1}{2}$，这强制执行了边界约定。\n\n逐分量地应用此方法，得到典范简约坐标\n$$\nu^{\\mathrm{canon}}_\\alpha = u_\\alpha - \\left\\lfloor u_\\alpha + \\tfrac{1}{2} \\right\\rfloor, \\quad \\alpha = 1,\\ldots,d,\n$$\n并因此得到典范笛卡尔 $k$ 点\n$$\nk^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}.\n$$\n\n数值实现需要稳健的去重操作。因为浮点运算可能只能近似地表示有理数值，我们使用一个笛卡尔容差 $\\varepsilon > 0$ 和无穷范数来确定典范 $k$ 点的数值相等性：\n$$\n\\|k^{\\mathrm{canon}} - (k^{\\mathrm{canon}})'\\|_\\infty \\le \\varepsilon \\quad \\Rightarrow \\quad \\text{相等}.\n$$\n在算法上，我们可以通过将 $k^{\\mathrm{canon}}$ 的每个分量除以 $\\varepsilon$ 并四舍五入到最近的整数来量化，从而形成一个可哈希的键，这将把在 $\\varepsilon$ 范围内的点分组。\n\n对于每个测试用例，步骤如下：\n1. 枚举指定索引集 $I$ 中的所有索引元组 $i$。\n2. 通过 $u_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2}$ 计算简约坐标 $u$。\n3. 通过 $u^{\\mathrm{canon}}_\\alpha = u_\\alpha - \\left\\lfloor u_\\alpha + \\tfrac{1}{2} \\right\\rfloor$ 进行典范化，在向下取整函数内部使用一个小的正数值偏移量来稳定浮点运算下的边界情况，同时保持到 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 的映射。\n4. 计算 $k^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}$。\n5. 使用基于 $\\varepsilon$ 的量化键进行去重和计数多重性：维护一个从键到多重性计数的字典。\n6. 唯一典范 $k$ 点的数量是字典条目的数量。最大多重性是字典计数值中的最大值。\n7. 每个唯一典范点的均匀权重为 $w = \\frac{1}{\\prod_{\\alpha=1}^{d} N_\\alpha}$。权重之和等于 $\\frac{\\text{unique\\_count}}{\\prod_{\\alpha} N_\\alpha}$，如果典范化后恰好有 $\\prod_{\\alpha} N_\\alpha$ 个不同的代表元，则该值应为 $1$。我们检查 $|\\text{sum\\_weights} - 1| \\le 10^{-12}$ 并报告一个布尔值。\n\n正确性论证：\n- 基于向下取整函数的典范化确保每个分量都位于 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内，并遵循模 $\\mathbb{Z}^d$ 的周期性，从而为每个等价类选择一个唯一的代表元，包括在 $\\tfrac{1}{2}$ 映射到 $-\\tfrac{1}{2}$ 的边界处理。\n- 在容差 $\\varepsilon$ 下的去重反映了理想算术中的精确等价；当 $\\varepsilon$ 相对于 $B$ 的大小和网格间距足够小时，可以避免虚假合并。\n- 对于包含下边界和上边界（例如 $\\{0,1,\\ldots,N\\}$）或扩展范围（例如 $\\{-N,\\ldots,N\\}$）的索引集，多个索引会映射到同一个典范代表元；字典计数反映了多重性，而唯一计数等于 $\\prod_{\\alpha} N_\\alpha$，前提是所有分量在每个方向上都覆盖了一个完整的采样周期。\n\n将此过程应用于提供的测试套件：\n- 测试用例 1 在一维中包含 $0$ 和 $N$，因此 $u = -\\tfrac{1}{2}$ 和 $u = \\tfrac{1}{2}$ 处的点是等同的；唯一的典范集大小为 $N = 4$，权重之和为 $1$，边界点的最大多重性为 $2$。\n- 测试用例 2 覆盖了 $4 \\times 4$ 的索引，其中 $N = (3,3)$，因此每个轴都包含边界；唯一的典范集大小为 $\\prod N_\\alpha = 9$，权重之和为 $1$，由于二维中的边界等同，角点的多重性为 $4$。\n- 测试用例 3 的 $N = (2,1,4)$ 且索引包含边界；唯一的典范集大小为 $2 \\cdot 1 \\cdot 4 = 8$，权重之和为 $1$，在所有轴都包含上边界的角点处，最大多重性为 $2 \\cdot 2 \\cdot 2 = 8$。\n- 测试用例 4 在一维中索引范围从 $-5$ 到 $5$，$N = 5$，因此在多个周期上进行采样；唯一的典范集大小为 $5$，权重之和为 $1$，最大多重性反映了在扩展范围内有多少索引落入同一个典范等价类。\n- 测试用例 5 在非正交基中混合了从负到正的索引和一个半分量位移；典范化在简约坐标中逐分量进行，产生的唯一计数等于 $\\prod N_\\alpha = 6$，权重之和等于 $1$，最大多重性对应于每个轴上边界重复的乘积。\n\n程序实现了这一逻辑，使用给定的容差进行去重，计算所要求的量，并以要求的单行格式打印聚合结果。",
            "answer": "```python\nimport numpy as np\n\ndef canonicalize_reduced(u, eps=1e-12):\n    \"\"\"\n    Map reduced coordinates u to the half-open hypercube [-1/2, 1/2)^d\n    componentwise using floor(u + 1/2). A small eps is added to stabilize\n    boundary cases under floating-point arithmetic.\n    \"\"\"\n    return u - np.floor(u + 0.5 + eps)\n\ndef dedup_keys(k_points, tol):\n    \"\"\"\n    Deduplicate a set of Cartesian k-points using an infinity-norm tolerance tol.\n    Returns a dictionary mapping quantized keys to multiplicity counts.\n    The key is constructed by quantizing each component: round(k_i / tol) to int.\n    \"\"\"\n    counts = {}\n    for k in k_points:\n        key = tuple(np.round(k / tol).astype(np.int64).tolist())\n        counts[key] = counts.get(key, 0) + 1\n    return counts\n\ndef generate_indices_from_problem_desc(case_num, N):\n    \"\"\"\n    Generate index tuples based on problem description.\n    This is hard-coded to match the problem statement.\n    \"\"\"\n    if case_num == 1: # I = {0,1,2,3,4}\n        return [(i,) for i in range(5)]\n    if case_num == 2: # I = {0,1,2,3} x {0,1,2,3}\n        return [(i, j) for i in range(4) for j in range(4)]\n    if case_num == 3: # I = {0,1,2} x {0,1} x {0,1,2,3,4}\n        return [(i, j, k) for i in range(3) for j in range(2) for k in range(5)]\n    if case_num == 4: # I = {-5,...,5}\n        return [(i,) for i in range(-5, 6)]\n    if case_num == 5: # I = {-2,...,2} x {-3,...,3}\n        return [(i, j) for i in range(-2, 3) for j in range(-3, 4)]\n    return []\n\n\ndef process_case(case_num, B, N, s, tol):\n    \"\"\"\n    Process a single test case.\n    \"\"\"\n    N = np.array(N, dtype=np.int64)\n    s = np.array(s, dtype=np.float64)\n    B = np.array(B, dtype=np.float64)\n    indices = generate_indices_from_problem_desc(case_num, N)\n\n    k_points = []\n    for idx in indices:\n        i = np.array(idx, dtype=np.float64)\n        u = (i + s) / N - 0.5\n        u_canon = canonicalize_reduced(u, eps=1e-12)\n        k = B @ u_canon\n        k_points.append(k)\n\n    counts = dedup_keys(k_points, tol)\n    unique_count = len(counts)\n    max_multiplicity = max(counts.values()) if counts else 0\n\n    total_grid_points = int(np.prod(N))\n    weight_sum = unique_count / total_grid_points\n    weight_sum_ok = abs(weight_sum - 1.0) = 1e-12\n\n    return unique_count, weight_sum_ok, max_multiplicity\n\ndef solve():\n    sqrt3 = np.sqrt(3.0)\n    test_specs = [\n        {\"B\": [[1.0]], \"N\": (4,), \"s\": (0.0,), \"tol\": 1e-12},\n        {\"B\": [[1.0, 0.5], [0.0, sqrt3/2.0]], \"N\": (3, 3), \"s\": (0.0, 0.0), \"tol\": 1e-12},\n        {\"B\": [[1.0, 0.0, 0.5], [0.0, 2.0, 0.5], [0.0, 0.0, 3.0]], \"N\": (2, 1, 4), \"s\": (0.0, 0.0, 0.0), \"tol\": 1e-12},\n        {\"B\": [[1.0]], \"N\": (5,), \"s\": (0.0,), \"tol\": 1e-12},\n        {\"B\": [[1.0, 0.3], [0.2, 1.1]], \"N\": (2, 3), \"s\": (0.5, 0.0), \"tol\": 1e-12},\n    ]\n\n    results = []\n    for i, spec in enumerate(test_specs):\n        unique_count, weight_ok, max_mult = process_case(\n            case_num=i + 1,\n            B=spec[\"B\"],\n            N=spec[\"N\"],\n            s=spec[\"s\"],\n            tol=spec[\"tol\"]\n        )\n        results.extend([unique_count, str(weight_ok), max_mult])\n\n    print(f\"[{','.join(map(str, results))}]\".replace(\"'True'\", \"True\").replace(\"'False'\", \"False\"))\n\n# The provided solution in the original XML had a flawed generic index generator and a syntax error.\n# The corrected answer below uses a specific generator matching the problem description and fixes the syntax.\n# The following code is a re-implementation based on the corrected logic and problem specification.\n\ndef solve_corrected():\n    \n    # Redefine the processing function with the fixed comparison and generator\n    def process_case_final(case_num, B_matrix, N_tuple, s_tuple, tol):\n        N_arr = np.array(N_tuple, dtype=np.int64)\n        s_arr = np.array(s_tuple, dtype=np.float64)\n        B_mat = np.array(B_matrix, dtype=np.float64)\n        \n        # Use problem-specific index generator\n        indices = []\n        if case_num == 1: indices = [(i,) for i in range(5)]\n        elif case_num == 2: indices = [(i,j) for i in range(4) for j in range(4)]\n        elif case_num == 3: indices = [(i,j,k) for i in range(3) for j in range(2) for k in range(5)]\n        elif case_num == 4: indices = [(i,) for i in range(-5, 6)]\n        elif case_num == 5: indices = [(i,j) for i in range(-2, 3) for j in range(-3, 4)]\n        \n        k_points_canon = []\n        for idx in indices:\n            i_arr = np.array(idx, dtype=np.float64)\n            u = (i_arr + s_arr) / N_arr - 0.5\n            u_canon = u - np.floor(u + 0.5 + 1e-12)\n            k_canon = B_mat @ u_canon\n            k_points_canon.append(k_canon)\n            \n        counts_map = {}\n        for k in k_points_canon:\n            key = tuple(np.round(k / tol).astype(np.int64))\n            counts_map[key] = counts_map.get(key, 0) + 1\n            \n        unique_count = len(counts_map)\n        max_multiplicity = max(counts_map.values()) if counts_map else 0\n        total_grid_size = np.prod(N_arr)\n        sum_of_weights = unique_count / total_grid_size\n        weights_sum_ok = abs(sum_of_weights - 1.0) = 1e-12\n        \n        return unique_count, weights_sum_ok, max_multiplicity\n\n    sqrt3 = np.sqrt(3.0)\n    test_cases_data = [\n        (1, [[1.0]], (4,), (0.0,), 1e-12),\n        (2, [[1.0, 0.5], [0.0, sqrt3/2.0]], (3, 3), (0.0, 0.0), 1e-12),\n        (3, [[1.0, 0.0, 0.5], [0.0, 2.0, 0.5], [0.0, 0.0, 3.0]], (2, 1, 4), (0.0, 0.0, 0.0), 1e-12),\n        (4, [[1.0]], (5,), (0.0,), 1e-12),\n        (5, [[1.0, 0.3], [0.2, 1.1]], (2, 3), (0.5, 0.0), 1e-12),\n    ]\n\n    final_results = []\n    for data in test_cases_data:\n        uc, w_ok, mm = process_case_final(*data)\n        final_results.extend([uc, w_ok, mm])\n\n    # Convert boolean to string 'True' or 'False'\n    final_results_str = [str(x) if isinstance(x, bool) else str(x) for x in final_results]\n    print(f\"[{','.join(final_results_str)}]\")\n\nsolve_corrected()\n```"
        },
        {
            "introduction": "通过利用晶体对称性，可以大幅降低电子结构计算的成本。本练习将指导你完成将一个完整的$k$点网格约化到其不可约子集（即不可约布里渊区，IBZ）的全过程，并计算出相应的权重。这是所有高效电子结构计算软件包中的核心步骤。",
            "id": "3459449",
            "problem": "给定一个具有全八面体对称性的简单立方晶体，其对称性由点群 $O_h$ 描述。考虑在简约分数倒易坐标中表示的布里渊区，其基本区域为半开立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$，并且周期性边界条件将相差整数倍倒易晶格矢量的点视为等同。一个均匀的$\\mathbf{k}$点网格按如下方式构建：每个分量 $k_{\\alpha}$ 仅限于集合 $\\{-\\tfrac{1}{2}, -\\tfrac{1}{4}, 0, \\tfrac{1}{4}\\}$，从而形成一个包含 $64$ 个点的 $4\\times 4\\times 4$ 网格，我们将其表示为集合 $\\mathcal{K}$。\n\n基本定义：\n- 布里渊区积分利用了晶体对称性。如果存在点群操作 $R \\in O_h$ 使得 $\\mathbf{k}' = R \\mathbf{k}$ （模一个倒易晶格矢量），则两个波矢 $\\mathbf{k}$ 和 $\\mathbf{k}'$ 是对称等价的。对于在点群操作下不变的标量，对称等价点对布里渊区积分的贡献相同。\n- 在倒易空间中，全八面体群 $O_h$ 由所有元素在 $\\{-1,0,1\\}$ 内且每行每列只有一个非零元素的正交 $3\\times 3$ 矩阵表示。该集合包括 $3!$ 种轴置换与 $2^3$ 种独立的符号翻转组合，共产生 $48$ 个对称操作（包括真旋转和非真操作，如通过反演结合 $180^\\circ$ 旋转实现的反映）。\n- 对于非磁性晶体，时间反演对称性将 $\\mathbf{k}$ 映射到 $-\\mathbf{k}$。在存在反演对称性（已包含在 $O_h$ 中）的情况下，$-\\mathbf{k}$ 已经可以通过一个点群操作生成。尽管如此，我们仍将在算法中明确包含时间反演操作，以演示如何处理它。\n\n算法目标：\n1. 定义群作用。设对称操作集合为\n$$\n\\mathcal{G} = \\{ R \\in \\mathbb{R}^{3\\times 3} \\mid R \\text{ orthogonal}, R_{ij} \\in \\{-1,0,1\\}, \\text{ exactly one nonzero per row and column} \\}.\n$$\n包括时间反演映射 $\\Theta: \\mathbf{k} \\mapsto -\\mathbf{k}$；注意 $-I \\in \\mathcal{G}$，但仍需明确包含它并去重。\n2. 实现一个与半开布里渊区 $[-\\tfrac{1}{2},\\tfrac{1}{2})^3$ 一致的周期性回绕函数。以四分之一整数为单位，令每个分量由一个整数 $n \\in \\{-2,-1,0,1\\}$ 表示，对应于 $n/4$。当对称变换产生分量 $n=2$ (对应于 $+\\tfrac{1}{2}$) 时，将其回绕至 $n=-2$ (对应于 $-\\tfrac{1}{2}$)，确保所有坐标保持在半开区间内。\n3. 对每个 $\\mathbf{k}\\in \\mathcal{K}$，在对称群作用下（考虑周期性回绕）形成其轨道：\n$$\n\\mathrm{Orbit}(\\mathbf{k}) = \\big\\{ \\operatorname{wrap}(R \\mathbf{k}) \\,\\big|\\, R \\in \\mathcal{G} \\cup \\{-I\\} \\big\\},\n$$\n其中 $\\operatorname{wrap}$ 按分量强制使其属于 $[-\\tfrac{1}{2},\\tfrac{1}{2})^3$。\n4. 将轨道的规范代表元定义为以四分之一整数为单位的字典序最小矢量：\n$$\n\\mathbf{k}^\\star = \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{k}),\n$$\n使用 $(n_x,n_y,n_z)$ 上的标准元组排序，其中每个 $n_{\\alpha}\\in\\{-2,-1,0,1\\}$。\n5. 将不可约布里渊区（IBZ）定义为网格中所有此类规范代表元的集合：\n$$\n\\mathrm{IBZ} = \\big\\{ \\mathbf{k}^\\star \\,\\big|\\, \\mathbf{k} \\in \\mathcal{K} \\big\\}.\n$$\n6. 代表元 $\\mathbf{k}^\\star$ 的权重是整个网格中映射到它的点的比例：\n$$\nw(\\mathbf{k}^\\star) = \\frac{|\\{\\mathbf{q} \\in \\mathcal{K} \\mid \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{q}) = \\mathbf{k}^\\star \\}|}{|\\mathcal{K}|}.\n$$\n在 $\\mathrm{IBZ}$ 上对这些权重求和，其总和必须为 $1$。\n\n实现要求：\n- 将 $O_h$ 中的所有对称操作构建为带符号的置换矩阵，其每行每列只有一个非零元素且元素值在 $\\{-1,0,1\\}$ 中，并在去重前明确地将 $\\Theta$ 作为 $-I$ 包含在内。\n- 以四分之一整数为单位 $n\\in\\{-2,-1,0,1\\}$ 表示坐标，以确保精确计算。\n- 将 $64$ 个网格点中的每一个都映射到其 IBZ 代表元，并按上述定义计算权重。\n\n测试套件：\n- 测试用例 1 (一般覆盖性)：计算代表元总数 $|\\mathrm{IBZ}|$ (整数)。\n- 测试用例 2 (归一化检验)：计算总和 $\\sum_{\\mathbf{k}^\\star \\in \\mathrm{IBZ}} w(\\mathbf{k}^\\star)$ (浮点数)。\n- 测试用例 3 (高对称点)：计算中心 $\\Gamma$ 点 $\\mathbf{k} = (0,0,0)$ 的权重 (浮点数)。\n- 测试用例 4 (边界角点)：计算布里渊区角点 $\\mathbf{k} = (-\\tfrac{1}{2}, -\\tfrac{1}{2}, -\\tfrac{1}{2})$ 的权重 (浮点数)。\n- 测试用例 5 (边界棱点)：计算棱点 $\\mathbf{k} = (-\\tfrac{1}{2}, 0, 0)$ 的权重 (浮点数)。\n- 测试用例 6 (含零分量的通用内部点)：计算内部点 $\\mathbf{k} = (-\\tfrac{1}{4}, 0, \\tfrac{1}{4})$ 的权重 (浮点数)。\n- 测试用例 7 (布尔归一化)：返回一个布尔值，指示归一化检验是否满足 $|\\sum w - 1|  10^{-12}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\big[\\, |\\mathrm{IBZ}|, \\, \\sum w, \\, w(0,0,0), \\, w(-\\tfrac{1}{2},-\\tfrac{1}{2},-\\tfrac{1}{2}), \\, w(-\\tfrac{1}{2},0,0), \\, w(-\\tfrac{1}{4},0,\\tfrac{1}{4}), \\, \\text{boolean} \\,\\big].\n$$\n所有浮点值都应以十进制形式打印；布尔值应打印为 $\\text{True}$ 或 $\\text{False}$。不应打印任何额外文本。",
            "solution": "问题在于，对于简单立方晶体第一布里渊区（BZ）内的一个指定均匀网格，需要确定其不可约$\\mathbf{k}$点集及其对应的权重。这一简约过程是通过利用晶体的点群对称性（特别是八面体群 $O_h$）以及时间反演对称性来实现的。该过程包括将完整网格中的每个点映射到从其对称生成的轨道中选出的一个规范代表元。\n\n### 1. 对称群与k点网格表示\n\n晶体的对称性由八面体点群 $O_h$ 描述。在倒易空间中，该群的 $48$ 个操作由所有 $3\\times 3$ 带符号置换矩阵的集合表示，这些矩阵是元素在 $\\{-1, 0, 1\\}$ 内且每行每列只有一个非零元素的正交矩阵。我们将此矩阵集合表示为 $\\mathcal{G}$。时间反演对称性 $\\Theta: \\mathbf{k} \\mapsto -\\mathbf{k}$ 对应于矩阵 $-I$。用于我们简约过程的完整对称群是 $\\mathcal{G} \\cup \\{-I\\}$，在移除重复项后（因为 $-I \\in \\mathcal{G}$），该群恰好包含 $48$ 个唯一操作。\n\n$\\mathbf{k}$点网格 $\\mathcal{K}$ 是一个均匀的 $4\\times 4\\times 4$ 网格。每个分量 $k_{\\alpha}$ 的坐标取自 $\\{-\\tfrac{1}{2}, -\\tfrac{1}{4}, 0, \\tfrac{1}{4}\\}$。为了实现精确的整数运算，我们将其乘以因子 $4$，用整数矢量 $(n_x, n_y, n_z)$ 表示网格点，其中每个分量 $n_{\\alpha} \\in \\{-2, -1, 0, 1\\}$。\n\n### 2. 周期性边界条件与回绕\n\n布里渊区被定义为半开立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$。在我们的整数坐标系中，这对应于每个分量 $n_{\\alpha}$ 都在集合 $\\{-2, -1, 0, 1\\}$ 中。将对称操作 $R$ 应用于矢量 $\\mathbf{k}$ 可能会产生一个分量超出此范围的矢量 $R\\mathbf{k}$。具体来说，对于分量为 $k_\\alpha = -\\tfrac{1}{2}$ (或 $n_\\alpha = -2$) 的网格点 $\\mathbf{k}$，一个对此分量取反的操作将得到 $+\\tfrac{1}{2}$ (或 $n_\\alpha = 2$)。由于倒易晶格的周期性，该点等价于 $-\\tfrac{1}{2}$。因此，我们必须应用一个回绕规则：任何分量 $n_\\alpha = 2$ 都被映射到 $n_\\alpha = -2$。这确保了所有变换后的 $\\mathbf{k}$点都保留在定义的基本区域内。\n\n### 3. 不可约布里渊区（IBZ）简约算法\n\n任务的核心是将完整网格 $\\mathcal{K}$ 划分为不相交的对称等价点集，这些集合被称为轨道。从每个轨道中，选择一个规范代表元来构成不可约布里渊区（IBZ）。然后，该代表元的权重就是映射到该代表元的原始网格点数，再用网格中的总点数进行归一化。\n\n算法流程如下：\n1.  **生成对称操作**：构建代表 $O_h$ 群（包括反演）操作的 $48$ 个唯一的 $3\\times 3$ 整数矩阵。\n2.  **初始化数据结构**：创建一个映射，用于存储 $64$ 个网格点中每个点的规范代表元，并创建一个计数器，用于统计映射到每个代表元的点的数量。\n3.  **迭代与映射**：对于网格 $\\mathcal{K}$ 中的每个点 $\\mathbf{k}$：\n    a.  **生成轨道**：通过对 $\\mathbf{k}$ 应用每个对称操作 $R$ 并遵循周期性回绕规则，计算生成的所有唯一点的集合。该集合即为 $\\mathrm{Orbit}(\\mathbf{k})$。\n    b.  **寻找规范代表元**：通过在 $\\mathrm{Orbit}(\\mathbf{k})$ 中选择字典序最小的矢量，来确定此轨道的代表元 $\\mathbf{k}^\\star$。\n    c.  **存储映射**：记录 $\\mathbf{k}$ 映射到 $\\mathbf{k}^\\star$。\n4.  **计数与加权**：遍历所有 $64$ 个点后，汇总结果。所有唯一代表元 $\\mathbf{k}^\\star$ 的集合构成了 IBZ。对于每个 $\\mathbf{k}^\\star \\in \\mathrm{IBZ}$，其计数是映射到它的网格点的数量。权重是此计数除以网格点总数（$64$）。\n$$w(\\mathbf{k}^\\star) = \\frac{|\\{\\mathbf{q} \\in \\mathcal{K} \\mid \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{q}) = \\mathbf{k}^\\star \\}|}{|\\mathcal{K}|}$$\n\n### 4. 测试用例结果计算\n\n应用此算法可将 $64$ 个网格点分为 $10$ 个不同的轨道，每个轨道由其字典序最小的代表元标识。\n\n-   $\\mathbf{k}^\\star = (0,0,0)$: $\\Gamma$点。其轨道只包含其自身。有 $1$ 个点映射到它。$w = 1/64$。\n-   $\\mathbf{k}^\\star = (-1,0,0)$: 代表内部轴上的点，如 $(\\pm\\tfrac{1}{4}, 0, 0)$ 及其排列。有 $6$ 个点映射到它。$w = 6/64$。\n-   $\\mathbf{k}^\\star = (-1,-1,0)$: 代表内部面对角线上的点，如 $(\\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4}, 0)$ 及其排列。有 $12$ 个点映射到它。$w = 12/64$。\n-   $\\mathbf{k}^\\star = (-1,-1,-1)$: 代表通用内部点，如 $(\\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4})$。有 $8$ 个点映射到它。$w = 8/64$。\n-   $\\mathbf{k}^\\star = (-2,0,0)$: 代表布里渊区边界的面心，如 $(-\\tfrac{1}{2}, 0, 0)$ 及其排列。有 $3$ 个点映射到它。$w = 3/64$。\n-   $\\mathbf{k}^\\star = (-2,-1,0)$: 代表边界表面上的点，如 $(-\\tfrac{1}{2}, \\pm\\tfrac{1}{4}, 0)$ 及其排列。有 $12$ 个点映射到它。$w = 12/64$。\n-   $\\mathbf{k}^\\star = (-2,-1,-1)$: 代表边界表面上的点，如 $(-\\tfrac{1}{2}, \\pm\\tfrac{1}{4}, \\pm\\tfrac{1}{4})$ 及其排列。有 $12$ 个点映射到它。$w = 12/64$。\n-   $\\mathbf{k}^\\star = (-2,-2,0)$: 代表布里渊区边界的棱心，如 $(-\\tfrac{1}{2}, -\\tfrac{1}{2}, 0)$ 及其排列。有 $3$ 个点映射到它。$w = 3/64$。\n-   $\\mathbf{k}^\\star = (-2,-2,-1)$: 代表边界棱上的点，如 $(-\\tfrac{1}{2}, -\\tfrac{1}{2}, \\pm\\tfrac{1}{4})$ 及其排列。有 $6$ 个点映射到它。$w = 6/64$。\n-   $\\mathbf{k}^\\star = (-2,-2,-2)$: 布里渊区角点 $(-\\tfrac{1}{2}, -\\tfrac{1}{2}, -\\tfrac{1}{2})$。有 $1$ 个点映射到它。$w = 1/64$。\n\n总计数为 $1+6+12+8+3+12+12+3+6+1 = 64$。\n\n-   **测试用例 1 ($|\\mathrm{IBZ}|$)**：有 $10$ 个唯一的代表元。\n-   **测试用例 2 ($\\sum w$)**：权重之和为 $\\frac{64}{64} = 1.0$。\n-   **测试用例 3 ($w(0,0,0)$)**：点 $(0,0,0)$ 是其自身的代表元。其权重为 $1/64$。\n-   **测试用例 4 ($w(-\\tfrac{1}{2},-\\tfrac{1}{2},-\\tfrac{1}{2})$)**：点 $(-2,-2,-2)$ 的代表元是其自身。其权重为 $1/64$。\n-   **测试用例 5 ($w(-\\tfrac{1}{2},0,0)$)**：点 $(-2,0,0)$ 的代表元是其自身。其权重为 $3/64$。\n-   **测试用例 6 ($w(-\\tfrac{1}{4},0,\\tfrac{1}{4})$)**：点 $(-1,0,1)$ 的代表元是 $(-1,-1,0)$。该代表元的权重为 $12/64$。\n-   **测试用例 7 (归一化)**：权重之和恰好为 $1$，因此满足条件 $|\\sum w - 1|  10^{-12}$，结果为 True。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes the irreducible Brillouin zone (IBZ) and weights for a given\n    k-point grid under octahedral group symmetry (O_h).\n    \"\"\"\n\n    # 1. Construct Symmetry Operations for the O_h group\n    permutations = list(itertools.permutations([0, 1, 2]))\n    sign_flips = list(itertools.product([-1, 1], repeat=3))\n    \n    op_matrices_set = set()\n    for p in permutations:\n        for s in sign_flips:\n            op = np.zeros((3, 3), dtype=int)\n            op[0, p[0]] = s[0]\n            op[1, p[1]] = s[1]\n            op[2, p[2]] = s[2]\n            op_matrices_set.add(tuple(map(tuple, op)))\n\n    neg_I = tuple(map(tuple, -np.identity(3, dtype=int)))\n    op_matrices_set.add(neg_I)\n    \n    symmetry_ops = [np.array(op, dtype=int) for op in op_matrices_set]\n    \n    # 2. Define the k-point grid and the periodic wrapping function\n    integer_coords = [-2, -1, 0, 1]\n    k_points = list(itertools.product(integer_coords, repeat=3))\n    total_k_points = len(k_points)\n\n    def wrap_vector(v):\n        \"\"\"Applies periodic wrapping to a k-vector component: 2 -> -2.\"\"\"\n        return tuple(-2 if c == 2 else c for c in v)\n\n    # 3.  4. Find IBZ representatives and count their occurrences\n    k_to_rep = {}\n    \n    for k_tuple in k_points:\n        k_vec = np.array(k_tuple)\n        \n        orbit = set()\n        for op in symmetry_ops:\n            transformed_k = op @ k_vec\n            wrapped_k = wrap_vector(transformed_k)\n            orbit.add(wrapped_k)\n        \n        canonical_rep = min(orbit)\n        k_to_rep[k_tuple] = canonical_rep\n        \n    rep_counts = {}\n    for rep in k_to_rep.values():\n        rep_counts[rep] = rep_counts.get(rep, 0) + 1\n\n    # 5. Compute weights for each representative in the IBZ\n    ibz_k_points = rep_counts.keys()\n    weights = {k_star: count / total_k_points for k_star, count in rep_counts.items()}\n\n    # 6. Evaluate the test suite queries\n    num_ibz = len(ibz_k_points)\n\n    sum_of_weights = sum(weights.values())\n\n    # To find the representative for a point, we must compute it.\n    gamma_point_tuple = (0, 0, 0)\n    gamma_point_rep = k_to_rep[gamma_point_tuple]\n    w_gamma = weights.get(gamma_point_rep, 0.0)\n\n    corner_point_tuple = (-2, -2, -2)\n    corner_rep = k_to_rep[corner_point_tuple]\n    w_corner = weights.get(corner_rep, 0.0)\n\n    edge_point_tuple = (-2, 0, 0)\n    edge_rep = k_to_rep[edge_point_tuple]\n    w_edge = weights.get(edge_rep, 0.0)\n    \n    # For k = (-1/4, 0, 1/4) -> (-1, 0, 1)\n    generic_point_tuple = (-1, 0, 1)\n    generic_rep = k_to_rep[generic_point_tuple]\n    w_generic = weights.get(generic_rep, 0.0)\n\n    is_normalized = abs(sum_of_weights - 1.0)  1e-12\n\n    results = [\n        num_ibz,\n        sum_of_weights,\n        w_gamma,\n        w_corner,\n        w_edge,\n        w_generic,\n        is_normalized\n    ]\n    \n    final_results_str = [str(x) if isinstance(x, bool) else f\"{x:.6f}\" if isinstance(x, float) else str(x) for x in results]\n    # Reformat based on expected output format from other problems\n    final_results_str[0] = str(results[0])\n    final_results_str[1] = str(results[1])\n    final_results_str[6] = str(results[6])\n\n\n    print(f\"[{','.join(final_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于具有各向异性电子性质的体系，均匀的$k$点网格可能导致计算效率低下。本练习将展示如何根据费米面的形状设计一个各向异性的$k$点网格。你将通过计算电导率等物理量来验证这种物理驱动的采样策略能够显著提高收敛速度。",
            "id": "3459479",
            "problem": "考虑晶体中布洛赫电子的三维各向异性抛物线能带。在能带极值点附近，电子能量色散关系由 $E(\\mathbf{k}) = \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{\\hbar^2 k_\\alpha^2}{2 m^*_\\alpha}$ 给出，其中 $m^*_\\alpha$ 是方向相关的有效质量，$\\hbar$ 是约化普朗克常数，$\\mathbf{k} = (k_x, k_y, k_z)$ 是晶体动量。群速度定义为 $v_\\alpha(\\mathbf{k}) = \\frac{1}{\\hbar} \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha}$。在具有恒定散射时间 $\\tau$ 的半经典玻尔兹曼输运理论的弛豫时间近似下，电导率张量元 $\\sigma_{\\alpha\\beta}$ 正比于在布里淵区上对 $v_\\alpha(\\mathbf{k}) v_\\beta(\\mathbf{k}) \\delta(E(\\mathbf{k}) - E_F)$ 的积分，其中 $E_F$ 是费米能，$\\delta$ 是狄拉克δ函数。\n\n你的任务是设计并实现一个计算实验，通过根据有效质量 $m^*_\\alpha$ 缩放网格轴，来验证在使用与拉长的费米面对齐的各向异性k点网格时，输运张量分量的收敛性得到了改善。在无量纲单位制（$\\hbar = 1$）下进行计算，并将所有量视为无量纲量；最终输出必须是无量纲实数。本问题不使用角度。\n\n从上述基本定义出发，实现以下内容：\n\n1. 在以 $\\mathbf{k}=\\mathbf{0}$ 为中心的矩形域上构建两种不同的k点采样策略：\n   - 一个基准各向同性均匀网格，其中 $N_x = N_y = N_z = N_{\\mathrm{base}}$。\n   - 一个各向异性网格，其中沿每个轴的点数 $N_\\alpha$ 与费米面在该轴向的范围成比例缩放，并选择使得总点数 $N_x N_y N_z$ 近似等于基准总点数。沿每个轴使用矩形域半宽 $K_{\\max,\\alpha}$，该半宽与该方向上的费米波矢范围成比例。具体来说，选择 $K_{\\max,\\alpha} = s \\, k_{F,\\alpha}$，安全系数 $s > 1$，以确保能量壳层包含在域内。\n\n2. 使用宽度参数 $\\eta$ 很小的归一化高斯函数 $g_\\eta(E(\\mathbf{k}) - E_F) = \\frac{1}{\\sqrt{2\\pi}\\,\\eta} \\exp\\!\\left(-\\frac{(E(\\mathbf{k}) - E_F)^2}{2 \\eta^2}\\right)$ 来近似狄拉克δ函数 $\\delta(E(\\mathbf{k}) - E_F)$。\n\n3. 对于每个网格，计算无量纲输运矢量 $\\mathbf{S} = (S_x,S_y,S_z)$ 的对角分量，其中 $S_\\alpha$ 正比于 $\\int v_\\alpha(\\mathbf{k})^2 \\delta(E(\\mathbf{k}) - E_F) \\, d^3k$ 的离散近似，然后进行归一化，使得 $\\sum_{\\alpha} S_\\alpha = 1$。\n\n4. 从第一性原理出发，推导各向异性抛物线能带的归一化对角分量 $\\mathbf{S}^{\\mathrm{exact}}$ 的精确解析参考值，并用它来量化每个网格的误差，误差定义为欧几里得范数 $||\\mathbf{S} - \\mathbf{S}^{\\mathrm{exact}}||_2$。\n\n5. 通过计算每个测试用例的基准各向同性网格误差和各向异性网格误差，并报告各向异性网格是否产生严格更小的误差，来验证收敛性的改善。\n\n使用中点采样（单元中心）和均匀矩形法则进行数值积分。你的域半宽 $K_{\\max,\\alpha}$ 必须足够大，以捕捉由 $E(\\mathbf{k}) = E_F$ 定义的能量壳层；选择 $K_{\\max,\\alpha} = s \\, k_{F,\\alpha}$，其中 $s = 2.0$。在 $\\hbar = 1$ 的无量纲单位制中，与轴相关的费米波矢 $k_{F,\\alpha}$ 由色散关系所蕴含的恒定能量椭球沿 $\\alpha$ 轴的半径给出。各向异性网格的尺寸 $N_\\alpha$ 必须与 $k_{F,\\alpha}$ 成比例缩放，并进行归一化，使得 $N_x N_y N_z \\approx N_{\\mathrm{base}}^3$，且每个 $N_\\alpha \\geq 3$。\n\n测试套件：\n实现你的程序以运行以下测试用例，每个用例均使用上述无量纲约定，指定为 $(m^*_x, m^*_y, m^*_z, E_F, N_{\\mathrm{base}}, \\eta)$：\n- 用例 A (正常路径)：$(0.2, 1.0, 5.0, 0.20, 14, 0.010)$。\n- 用例 B (各向同性边界)：$(1.0, 1.0, 1.0, 0.20, 14, 0.010)$。\n- 用例 C (强各向异性边缘情况)：$(0.05, 1.2, 25.0, 0.15, 14, 0.007)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的三个测试用例的结果列表。每个测试用例的结果本身必须是一个列表，按顺序包含三个条目：各向同性网格误差（浮点数）、各向异性网格误差（浮点数），以及一个布尔值，指示各向异性网格误差是否严格小于各向同性网格误差。例如，输出必须具有以下形式：\"[[e_iso_A,e_aniso_A,improved_A],[e_iso_B,e_aniso_B,improved_B],[e_iso_C,e_aniso_C,improved_C]]\"，其中每个 \"e_*\" 都是一个无量纲浮点数。",
            "solution": "该问题要求我们分析各向异性电子能带结构下，一个与输运相关的量的数值收敛性。问题的核心在于计算布里渊区上的一个积分，该积分在弛豫时间近似下与电导率张量的一个分量成正比。\n\n### 1. 理论框架与解析解\n\n电子能量色散由各向异性抛物线模型给出：\n$$ E(\\mathbf{k}) = \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{\\hbar^2 k_\\alpha^2}{2 m^*_\\alpha} $$\n其中 $m^*_\\alpha$ 是沿主轴 $\\alpha$ 的有效质量，$\\mathbf{k} = (k_x, k_y, k_z)$ 是晶体动量矢量。该问题在约化普朗克常数 $\\hbar = 1$ 的无量纲单位制下进行表述，因此色散关系简化为：\n$$ E(\\mathbf{k}) = \\sum_{\\alpha} \\frac{k_\\alpha^2}{2 m^*_\\alpha} $$\n处于状态 $\\mathbf{k}$ 的电子的群速度定义为：\n$$ v_\\alpha(\\mathbf{k}) = \\frac{1}{\\hbar} \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha} = \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha} = \\frac{k_\\alpha}{m^*_\\alpha} $$\n我们的任务是计算归一化的输运矢量 $\\mathbf{S}$ 的对角分量，其中每个分量 $S_\\alpha$ 来自未归一化的积分 $I_\\alpha$：\n$$ I_\\alpha = \\int_{\\text{BZ}} v_\\alpha(\\mathbf{k})^2 \\delta(E(\\mathbf{k}) - E_F) \\, d^3k $$\n这里，$E_F$ 是费米能，$\\delta$ 是狄拉克δ函数，它将积分限制在称为费米面的恒定能量面 $E(\\mathbf{k}) = E_F$ 上。\n\n为了推导精确的解析参考值 $\\mathbf{S}^{\\mathrm{exact}}$，我们计算积分 $I_\\alpha$。代入 $v_\\alpha$ 和 $E(\\mathbf{k})$ 的表达式：\n$$ I_\\alpha = \\int \\left(\\frac{k_\\alpha}{m^*_\\alpha}\\right)^2 \\delta\\left(\\sum_{\\beta} \\frac{k_\\beta^2}{2 m^*_\\beta} - E_F\\right) \\, d^3k $$\n为了求解这个积分，我们进行变量替换，将椭球形费米面映射到一个单位球面上。我们定义一组新的坐标 $\\mathbf{q} = (q_x, q_y, q_z)$，使得：\n$$ q_\\beta = \\frac{k_\\beta}{\\sqrt{2 m^*_\\beta E_F}} $$\n这意味着 $k_\\beta = q_\\beta \\sqrt{2 m^*_\\beta E_F}$。此变换对体积元的雅可比行列式为：\n$$ d^3k = \\left(\\frac{\\partial k_x}{\\partial q_x}\\frac{\\partial k_y}{\\partial q_y}\\frac{\\partial k_z}{\\partial q_z}\\right) d^3q = \\left(\\sqrt{2 m^*_x E_F} \\sqrt{2 m^*_y E_F} \\sqrt{2 m^*_z E_F}\\right) d^3q \\\\ = (2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z} \\, d^3q $$\n能量表达式变换为：\n$$ E(\\mathbf{q}) = \\sum_{\\beta} \\frac{(q_\\beta \\sqrt{2 m^*_\\beta E_F})^2}{2 m^*_\\beta} = E_F \\sum_{\\beta} q_\\beta^2 = E_F |\\mathbf{q}|^2 $$\n狄拉克δ函数的自变量变为 $E_F|\\mathbf{q}|^2 - E_F = E_F(|\\mathbf{q}|^2 - 1)$。利用性质 $\\delta(ax) = \\frac{1}{|a|}\\delta(x)$，我们得到 $\\delta(E_F(|\\mathbf{q}|^2 - 1)) = \\frac{1}{E_F}\\delta(|\\mathbf{q}|^2 - 1)$。\n\n$v_\\alpha^2 = (k_\\alpha/m^*_\\alpha)^2$ 项变为：\n$$ \\left(\\frac{q_\\alpha \\sqrt{2 m^*_\\alpha E_F}}{m^*_\\alpha}\\right)^2 = \\frac{q_\\alpha^2 (2 m^*_\\alpha E_F)}{(m^*_\\alpha)^2} = \\frac{2 E_F}{m^*_\\alpha} q_\\alpha^2 $$\n将所有变换后的部分代回到 $I_\\alpha$ 的积分中：\n$$ I_\\alpha = \\int \\left(\\frac{2 E_F}{m^*_\\alpha} q_\\alpha^2\\right) \\left(\\frac{1}{E_F} \\delta(|\\mathbf{q}|^2 - 1)\\right) \\left((2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z}\\right) d^3q $$\n$$ I_\\alpha = \\frac{2}{m^*_\\alpha} \\left((2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z}\\right) \\int q_\\alpha^2 \\delta(|\\mathbf{q}|^2 - 1) \\, d^3q $$\n积分 $\\int q_\\alpha^2 \\delta(|\\mathbf{q}|^2 - 1) \\, d^3q$ 现在是在 $\\mathbf{q}$ 空间中的单位球面上进行的。根据对称性，对于 $\\alpha=x, y, z$，该积分的值是相同的。设这个常数值为 $C_q$。$I_\\alpha$ 表达式中所有其他依赖于材料参数 ($m^*_\\alpha$) 或 $E_F$ 的项都已作为因子提出。我们看到，对轴索引 $\\alpha$ 的依赖仅通过前置因子体现：\n$$ I_\\alpha \\propto \\frac{1}{m^*_\\alpha} $$\n因此，未归一化的输运分量为 $S'_\\alpha = C \\cdot (1/m^*_\\alpha)$，其中 C 为某个常数。为了找到归一化矢量 $\\mathbf{S}^{\\mathrm{exact}}$，我们计算：\n$$ S^{\\mathrm{exact}}_\\alpha = \\frac{S'_\\alpha}{\\sum_{\\beta} S'_\\beta} = \\frac{C/m^*_\\alpha}{\\sum_{\\beta} C/m^*_\\beta} = \\frac{1/m^*_\\alpha}{1/m^*_x + 1/m^*_y + 1/m^*_z} $$\n这就是将作为我们参考的精确解析结果。\n\n### 2. 数值积分方案\n\n该问题要求对积分 $I_\\alpha$ 进行数值近似。狄拉克δ函数由一个窄高斯函数近似：\n$$ \\delta(E - E_F) \\approx g_\\eta(E - E_F) = \\frac{1}{\\sqrt{2\\pi}\\,\\eta} \\exp\\left(-\\frac{(E(\\mathbf{k}) - E_F)^2}{2 \\eta^2}\\right) $$\n积分在 $\\mathbf{k}$ 空间中的一个有限矩形域上进行，该域由半宽 $K_{\\max,\\alpha} = s \\cdot k_{F,\\alpha}$ 定义，其中 $s=2.0$ 是一个安全系数。费米波矢 $k_{F,\\alpha}$ 表示费米面沿轴 $\\alpha$ 的范围，通过设置 $E(\\mathbf{k})=E_F$ 和 $k_\\beta=0$ (对于 $\\beta \\neq \\alpha$) 求得：\n$$ E_F = \\frac{k_{F,\\alpha}^2}{2 m^*_\\alpha} \\implies k_{F,\\alpha} = \\sqrt{2 m^*_\\alpha E_F} $$\n该积分使用矩形网格上的中点法则进行离散化。对于沿每个轴有 $N_\\alpha$ 个点和半宽 $K_{\\max,\\alpha}$ 的网格，步长为 $\\Delta k_\\alpha = 2K_{\\max,\\alpha}/N_\\alpha$。网格点是积分单元的中心：\n$$ k_{\\alpha,i} = -K_{\\max,\\alpha} + (i + 0.5) \\Delta k_\\alpha, \\quad i = 0, 1, \\dots, N_\\alpha - 1 $$\n$\\mathbf{k}$ 空间中每个单元的体积是 $\\Delta V_k = \\Delta k_x \\Delta k_y \\Delta k_z$。$I_\\alpha$ 的数值近似为：\n$$ I_\\alpha \\approx \\sum_{i,j,l} v_\\alpha(\\mathbf{k}_{ijl})^2 \\, g_\\eta(E(\\mathbf{k}_{ijl}) - E_F) \\, \\Delta V_k $$\n其中求和遍及所有网格点 $\\mathbf{k}_{ijl} = (k_{x,i}, k_{y,j}, k_{z,l})$。计算出未归一化的分量 $S'_\\alpha \\approx I_\\alpha$ 后，对其进行归一化以获得数值结果 $\\mathbf{S}$。\n\n### 3. 网格构建\n\n比较了两种不同的采样网格：\n\n- **各向同性网格**：该网格沿每个轴使用相同数量的点，$N_x = N_y = N_z = N_{\\mathrm{base}}$。总点数为 $N_{\\mathrm{base}}^3$。\n\n- **各向异性网格**：该网格使采样密度适应费米面的形状。对于一个拉长的椭球体，沿较长轴分配更多的点。点数 $N_\\alpha$与费米波矢范围 $k_{F,\\alpha}$ 成比例缩放：\n$$ N_\\alpha \\propto k_{F,\\alpha} $$\n选择一个归一化常数，使得总点数与各向同性情况下的总点数大致相同：$N_x N_y N_z \\approx N_{\\mathrm{base}}^3$。这导出了以下缩放规则：\n$$ N_\\alpha = \\text{round}\\left( N_{\\mathrm{base}} \\frac{k_{F,\\alpha}}{(k_{F,x}k_{F,y}k_{F,z})^{1/3}} \\right) $$\n每个 $N_\\alpha$ 被限制为至少为 $3$。该策略旨在保持费米面单位表面积上的采样点数量大致恒定，这对于固定的总点数应能提高精度。\n\n### 4. 误差计算\n\n对于每种网格类型（各向同性和各向异性），将计算出的归一化矢量 $\\mathbf{S}^{\\mathrm{num}}$ 与解析参考值 $\\mathbf{S}^{\\mathrm{exact}}$进行比较。误差通过差矢量的欧几里得范数来量化：\n$$ \\text{error} = ||\\mathbf{S}^{\\mathrm{num}} - \\mathbf{S}^{\\mathrm{exact}}||_2 = \\sqrt{\\sum_{\\alpha} (S^{\\mathrm{num}}_\\alpha - S^{\\mathrm{exact}}_\\alpha)^2} $$\n最后一步是比较两种网格的误差，以验证各向异性网格为各向异性系统提供了更准确的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational experiment for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: (m*_x, m*_y, m*_z, E_F, N_base, eta)\n        (0.2, 1.0, 5.0, 0.20, 14, 0.010),\n        # Case B\n        (1.0, 1.0, 1.0, 0.20, 14, 0.010),\n        # Case C\n        (0.05, 1.2, 25.0, 0.15, 14, 0.007),\n    ]\n\n    results = []\n    for case in test_cases:\n        m_stars_tuple, E_F, N_base, eta = case[0:3], case[3], case[4], case[5]\n        m_stars = np.array(m_stars_tuple)\n\n        # 1. Derive the exact analytical reference S^exact\n        inv_m_stars = 1.0 / m_stars\n        S_exact = inv_m_stars / np.sum(inv_m_stars)\n\n        # 2. Define integration domain and common parameters\n        s_factor = 2.0\n        kF_vec = np.sqrt(2 * m_stars * E_F)\n        Kmax_vec = s_factor * kF_vec\n\n        # Helper function for the numerical calculation\n        def _calculate_S(m_s, EF, n_eta, N_vec, K_vec):\n            \"\"\"\n            Calculates the normalized transport vector S for a given grid.\n            \"\"\"\n            m_x, m_y, m_z = m_s\n            Nx, Ny, Nz = N_vec\n            Kmax_x, Kmax_y, Kmax_z = K_vec\n\n            delta_k = 2 * K_vec / N_vec\n            kx_pts = -Kmax_x + (np.arange(Nx) + 0.5) * delta_k[0]\n            ky_pts = -Kmax_y + (np.arange(Ny) + 0.5) * delta_k[1]\n            kz_pts = -Kmax_z + (np.arange(Nz) + 0.5) * delta_k[2]\n\n            Kx, Ky, Kz = np.meshgrid(kx_pts, ky_pts, kz_pts, indexing='ij')\n\n            E = Kx**2 / (2 * m_x) + Ky**2 / (2 * m_y) + Kz**2 / (2 * m_z)\n            Vx_sq = (Kx / m_x)**2\n            Vy_sq = (Ky / m_y)**2\n            Vz_sq = (Kz / m_z)**2\n\n            gauss_arg = -(E - EF)**2 / (2 * n_eta**2)\n            gaussian = (1.0 / (np.sqrt(2 * np.pi) * n_eta)) * np.exp(gauss_arg)\n\n            dV_k = delta_k[0] * delta_k[1] * delta_k[2]\n            S_prime_x = np.sum(Vx_sq * gaussian) * dV_k\n            S_prime_y = np.sum(Vy_sq * gaussian) * dV_k\n            S_prime_z = np.sum(Vz_sq * gaussian) * dV_k\n            \n            S_prime_vec = np.array([S_prime_x, S_prime_y, S_prime_z])\n            total_S_prime = np.sum(S_prime_vec)\n\n            if total_S_prime == 0:\n                return np.array([1/3.0, 1/3.0, 1/3.0])\n\n            return S_prime_vec / total_S_prime\n\n        # 3. Isotropic grid calculation\n        N_iso = np.array([N_base, N_base, N_base], dtype=int)\n        S_iso = _calculate_S(m_stars, E_F, eta, N_iso, Kmax_vec)\n        error_iso = np.linalg.norm(S_iso - S_exact)\n\n        # 4. Anisotropic grid calculation\n        if np.any(kF_vec == 0) or np.prod(kF_vec) == 0:\n             kF_geom_mean = 1.0 # Avoid division by zero\n             N_aniso_unrounded = np.full(3, N_base)\n        else:\n             kF_geom_mean = np.prod(kF_vec)**(1.0/3.0)\n             N_aniso_unrounded = N_base * kF_vec / kF_geom_mean\n        \n        N_aniso = np.maximum(3, np.round(N_aniso_unrounded)).astype(int)\n        \n        S_aniso = _calculate_S(m_stars, E_F, eta, N_aniso, Kmax_vec)\n        error_aniso = np.linalg.norm(S_aniso - S_exact)\n\n        # 5. Store results for the case\n        improved = error_aniso  error_iso\n        results.append([error_iso, error_aniso, improved])\n\n    case_results_str = []\n    for res in results:\n        case_results_str.append(f\"[{res[0]},{res[1]},{str(res[2])}]\")\n    \n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}