{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，精确计算自由度 ($g$) 对于正确估算温度至关重要。此练习将指导您推导当移除系统质心运动等约束时，温度估算器和 Nosé-Hoover 温控器参数应如何修正 。掌握如何调整温控器质量参数 $Q$ 以保持恒定的响应频率，是确保模拟稳定性和准确性的基本技能。",
            "id": "3496428",
            "problem": "在一个目标温度为 $T_{0}$ 的周期性单元中，对 $N$ 个相同原子进行了三维分子动力学（MD）模拟。瞬时动能定义为 $K = \\sum_{i=1}^{N} \\frac{1}{2} m v_{i}^{2}$，温度通过能量均分原理从动能估算得出。该模拟在每个时间步中通过从所有原子速度中减去瞬时质心（COM）速度来移除系统的净质心运动。假设不存在其他完整约束。\n\n仅从第一性原理和核心定义出发，完成以下任务：\n\n1. 推导移除质心运动如何修正基于动能的温度估算器，明确展示由此产生的自由度以及估算器对它们的依赖关系。对于固定的瞬时动能 $K$，证明当移除三个平动自由度时，估算器变化的因子。\n\n2. 考虑一个单变量 Nosé–Hoover (NH) 恒温器。具有质量参数 $Q$ 的 NH 摩擦变量 $\\xi$ 通过扩展的运动方程与动量耦合。将耦合的动能-恒温器动力学在平衡点附近线性化，并以 $g$、$k_{B}$、$T_{0}$ 和 $Q$ 表示动能涨落的小振幅弛豫频率 $\\omega$，其中 $g$ 是活动的二次自由度数。利用此关系，确定当通过移除质心运动而减少 $g$ 时，必须如何调整 $Q$ 以保持相同的弛豫时间尺度。用约化的自由度、$k_{B}$、$T_{0}$ 和选定的时间尺度参数符号化地表示调整后的 $Q$。\n\n3. 将你的结果应用于一个包含 $N = 1000$ 个原子、温度为 $T_{0} = 300\\,\\mathrm{K}$、且已移除质心运动的系统。选择一个目标小振幅弛豫时间尺度 $\\tau = 0.5\\,\\mathrm{ps}$，该时间尺度在移除质心运动前后保持不变。计算在移除质心运动后能实现相同 $\\tau$ 的调整后的 Nosé–Hoover 质量参数 $Q'$。将 $Q'$ 的最终值以 $\\mathrm{J\\,ps^{2}}$ 为单位表示，并四舍五入到四位有效数字。\n\n在你的推理中，可以引用牛顿定律、动能的定义和能量均分定理。你不得在未从这些基础推导的情况下假定任何恒温器特定的简化公式。最终答案应为 $Q'$ 的单个数值，以 $\\mathrm{J\\,ps^{2}}$ 为单位，并四舍五入到四位有效数字。",
            "solution": "该问题被验证为具有科学依据、提法明确且客观。它包含计算统计力学中的标准推导和应用。\n\n根据问题陈述的要求，解答分为三个部分呈现。\n\n第1部分：修正后的温度估算器的推导。\n\n能量均分定理指出，对于一个在温度 $T_{0}$ 下处于热平衡的系统，哈密顿量中每个独立的二次自由度所对应的平均能量为 $\\frac{1}{2} k_{B} T_{0}$，其中 $k_{B}$ 是玻尔兹曼常数。在分子动力学（MD）模拟中，通过将此原理推广到瞬时动能 $K$，来估算瞬时温度 $T$。如果系统拥有 $g$ 个动能自由度，则瞬时温度 $T$ 由以下关系定义：\n$$K = \\frac{g}{2} k_{B} T$$\n由此，温度估算器为：\n$$T = \\frac{2K}{g k_{B}}$$\n对于一个在三维空间中运动的由 $N$ 个点状原子组成的系统，每个原子有3个平动自由度，对应其速度分量 $(v_{ix}, v_{iy}, v_{iz})$。这类自由度的总数为 $g = 3N$。总动能为 $K = \\sum_{i=1}^{N} \\frac{1}{2} m v_{i}^{2}$。因此，标准的温度估算器为：\n$$T = \\frac{2K}{3N k_{B}}$$\n当移除净质心（COM）运动时，系统速度会受到一个约束。质心速度定义为 $\\mathbf{V}_{\\text{COM}} = \\frac{\\sum_{i=1}^{N} m \\mathbf{v}_{i}}{\\sum_{i=1}^{N} m} = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{v}_{i}$。移除质心运动意味着在所有时间强制执行 $\\mathbf{V}_{\\text{COM}} = \\mathbf{0}$。这给原子速度引入了三个线性约束：\n$$\\sum_{i=1}^{N} v_{ix} = 0, \\quad \\sum_{i=1}^{N} v_{iy} = 0, \\quad \\sum_{i=1}^{N} v_{iz} = 0$$\n这些约束减少了独立速度分量的数量。原有的 $3N$ 个自由度减少了3个。新的活动自由度数，记为 $g'$，是：\n$$g' = 3N - 3$$\n现在，系统的动能 $K$ 是由满足这些约束的速度计算得出的。温度估算器必须进行调整以反映自由度数的变化。新的估算器 $T'$ 为：\n$$T' = \\frac{2K}{g' k_{B}} = \\frac{2K}{(3N-3)k_{B}}$$\n为了找出在瞬时动能 $K$ 固定的情况下估算器变化的因子，我们计算新估算器 $T'$ 与旧估算器 $T$ 的比值：\n$$\\frac{T'}{T} = \\frac{\\frac{2K}{(3N-3)k_{B}}}{\\frac{2K}{3N k_{B}}} = \\frac{3N}{3N-3} = \\frac{3N}{3(N-1)} = \\frac{N}{N-1}$$\n因此，对于给定的动能 $K$，移除质心运动会使估算的温度增加一个因子 $\\frac{N}{N-1}$。\n\n第2部分：Nosé–Hoover 动力学和恒温器参数调整。\n\nNosé–Hoover (NH) 恒温器通过一个扩展的相空间变量，即摩擦系数 $\\xi$，将物理系统与一个热库耦合。原子动量 $\\mathbf{p}_{i}$ 和恒温器变量 $\\xi$ 的运动方程为：\n$$\\dot{\\mathbf{p}}_{i} = \\mathbf{F}_{i} - \\xi \\mathbf{p}_{i}$$\n$$\\dot{\\xi} = \\frac{1}{Q} \\left( \\sum_{i=1}^{N} \\frac{p_{i}^{2}}{m} - g k_{B} T_{0} \\right) = \\frac{1}{Q} (2K - g k_{B} T_{0})$$\n这里，$Q$ 是恒温器的“质量”参数，它决定了温度涨落的时间尺度，$g$ 是活动自由度的数量。\n\n为了分析动能涨落的动力学，我们首先推导 $K = \\sum_{i=1}^{N} \\frac{p_{i}^{2}}{2m}$ 的运动方程：\n$$\\dot{K} = \\frac{d}{dt} \\sum_{i=1}^{N} \\frac{\\mathbf{p}_{i} \\cdot \\mathbf{p}_{i}}{2m} = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_{i} \\cdot \\dot{\\mathbf{p}}_{i}}{m} = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_{i} \\cdot (\\mathbf{F}_{i} - \\xi \\mathbf{p}_{i})}{m}$$\n$$\\dot{K} = \\sum_{i=1}^{N} \\mathbf{v}_{i} \\cdot \\mathbf{F}_{i} - \\xi \\sum_{i=1}^{N} \\frac{p_{i}^{2}}{m} = \\sum_{i=1}^{N} \\mathbf{v}_{i} \\cdot \\mathbf{F}_{i} - 2\\xi K$$\n我们定义一个涨落项 $\\Gamma(t) = \\sum_{i=1}^{N} \\mathbf{v}_{i} \\cdot \\mathbf{F}_{i}$，代表与势能面的能量交换。$K$ 和 $\\xi$ 的耦合动力学是：\n$$ \\begin{cases} \\dot{K} = \\Gamma(t) - 2\\xi K \\\\ \\dot{\\xi} = \\frac{1}{Q} (2K - g k_{B} T_{0}) \\end{cases} $$\n我们在平衡态附近将这些方程线性化，平衡态的特征是 $\\langle \\xi \\rangle = 0$ 和 $\\langle K \\rangle = K_{0} = \\frac{g}{2} k_{B} T_{0}$。我们引入小偏离量 $\\delta K = K - K_{0}$ 和 $\\delta \\xi = \\xi - 0$。线性化后的方程变为：\n$$ \\begin{cases} \\delta\\dot{K} \\approx \\Gamma(t) - 2 K_{0} \\delta\\xi \\\\ \\delta\\dot{\\xi} \\approx \\frac{1}{Q} (2(K_{0}+\\delta K) - g k_{B} T_{0}) = \\frac{2 \\delta K}{Q} \\end{cases} $$\n对第一个方程关于时间求导，并代入第二个方程，得到一个关于 $\\delta K$ 的方程：\n$$\\delta\\ddot{K} \\approx \\dot{\\Gamma}(t) - 2K_{0}\\delta\\dot{\\xi} = \\dot{\\Gamma}(t) - 2K_{0} \\left( \\frac{2\\delta K}{Q} \\right)$$\n$$\\delta\\ddot{K} + \\left( \\frac{4K_{0}}{Q} \\right) \\delta K = \\dot{\\Gamma}(t)$$\n这是一个受驱谐振子的方程。动能小振幅涨落的自然频率 $\\omega$ 由下式给出：\n$$\\omega^{2} = \\frac{4K_{0}}{Q} = \\frac{4}{Q} \\left( \\frac{g}{2} k_{B} T_{0} \\right) = \\frac{2g k_{B} T_{0}}{Q}$$\n所以，弛豫频率为 $\\omega = \\sqrt{\\frac{2g k_{B} T_{0}}{Q}}$。弛豫时间尺度为 $\\tau = \\frac{2\\pi}{\\omega}$。\n为了在自由度数从 $g$ 变为 $g'$ 时保持相同的弛豫时间尺度 $\\tau$（从而保持相同的频率 $\\omega$），比率 $\\frac{g}{Q}$ 必须保持不变：\n$$\\frac{g}{Q} = \\frac{g'}{Q'} \\implies Q' = Q \\frac{g'}{g}$$\n这表明恒温器质量 $Q$ 必须与自由度数成比例地缩放，以维持恒定的响应频率。\n为了用期望的时间尺度 $\\tau$ 表示调整后的质量 $Q'$，我们重排频率方程：\n$$Q' = \\frac{2g' k_{B} T_{0}}{\\omega^{2}}$$\n代入 $\\omega = \\frac{2\\pi}{\\tau}$，我们得到：\n$$Q' = \\frac{2g' k_{B} T_{0}}{(2\\pi/\\tau)^{2}} = \\frac{g' k_{B} T_{0} \\tau^{2}}{2\\pi^{2}}$$\n这为具有 $g'$ 个自由度的系统实现目标时间尺度 $\\tau$ 提供了调整后质量参数 $Q'$ 的符号表达式。\n\n第3部分：调整后恒温器质量 $Q'$ 的数值计算。\n\n问题指定了一个包含 $N = 1000$ 个原子、目标温度为 $T_{0} = 300\\,\\mathrm{K}$ 的系统。质心运动被移除。期望的弛豫时间尺度为 $\\tau = 0.5\\,\\mathrm{ps}$。\n\n首先，我们计算活动自由度的数量 $g'$：\n$$g' = 3N - 3 = 3(1000) - 3 = 2997$$\n接下来，我们使用推导出的 $Q'$ 公式以及给定的参数和常数：\n$$Q' = \\frac{g' k_{B} T_{0} \\tau^{2}}{2\\pi^{2}}$$\n物理常数为：\n$k_{B} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\n参数为：\n$g' = 2997$\n$T_{0} = 300\\,\\mathrm{K}$\n$\\tau = 0.5\\,\\mathrm{ps}$\n\n现在我们将这些值代入 $Q'$ 的表达式中。单位必须正确处理，以得到以 $\\mathrm{J\\,ps^{2}}$ 为单位的最终答案。\n$$Q' = \\frac{(2997) \\times (1.380649 \\times 10^{-23}\\,\\mathrm{J/K}) \\times (300\\,\\mathrm{K}) \\times (0.5\\,\\mathrm{ps})^{2}}{2\\pi^{2}}$$\n$$Q' = \\frac{2997 \\times (1.380649 \\times 10^{-23}) \\times 300 \\times 0.25}{2\\pi^{2}} \\,\\mathrm{J\\,ps^{2}}$$\n项 $k_{B} T_{0}$ 为 $(1.380649 \\times 10^{-23}\\,\\mathrm{J/K}) \\times (300\\,\\mathrm{K}) = 4.141947 \\times 10^{-21}\\,\\mathrm{J}$。\n分子变为：\n$$ \\text{Numerator} = 2997 \\times (4.141947 \\times 10^{-21}\\,\\mathrm{J}) \\times (0.25\\,\\mathrm{ps}^{2}) \\approx 3.1032178 \\times 10^{-18}\\,\\mathrm{J\\,ps^{2}} $$\n分母为：\n$$ \\text{Denominator} = 2\\pi^{2} \\approx 19.7392088 $$\n进行除法运算：\n$$ Q' \\approx \\frac{3.1032178 \\times 10^{-18}}{19.7392088} \\,\\mathrm{J\\,ps^{2}} \\approx 1.572101 \\times 10^{-19}\\,\\mathrm{J\\,ps^{2}} $$\n按要求将结果四舍五入到四位有效数字：\n$$ Q' \\approx 1.572 \\times 10^{-19}\\,\\mathrm{J\\,ps^{2}} $$\n这就是为达到所需弛豫时间尺度而调整后的 Nosé–Hoover 质量参数。",
            "answer": "$$\\boxed{1.572 \\times 10^{-19}}$$"
        },
        {
            "introduction": "除了作为热量交换的工具，温控器本身也具有特定的动力学行为，可以从控制论的角度进行分析。本练习将引导您运用线性响应理论来研究 Berendsen 温控器的动态特性 。通过将其建模为一个低通滤波器，您将深刻理解弛豫时间 $\\tau$ 如何影响系统动能的涨落，并学会如何定量描述温控器的“耦合强度”。",
            "id": "3496421",
            "problem": "一个具有 $f$ 个二次自由度的经典分子动力学 (MD) 系统，在一种弱耦合速度重标热浴下进行模拟，该热浴通常称为 Berendsen 恒温器。瞬时动能温度 $T(t)$ 通过动能 $K(t)$ 定义为 $K(t) = \\frac{f}{2} k_B T(t)$，其中 $k_B$ 是玻尔兹曼常数。目标温度为 $T_0$，恒温器配置有弛豫时间 $\\tau$，该弛豫时间对 $T(t)$ 施加负反馈。\n\n假设在 $T_0$ 附近存在小偏差 $\\delta T(t) = T(t) - T_0$，并考虑在 MD 积分时间步长的连续极限下的线性响应。在此机制下，将确定性哈密顿能量交换的净效应建模为对温度动力学的一个小的、附加的驱动项 $u(t)$，该驱动项可包含角频率为 $\\Omega$ 的窄带分量，代表快速动能涨落（例如，由角频率为 $\\omega_v$ 的振动模式引起的，其导致频率为 $2\\omega_v$ 的动能涨落）。\n\n从粒子动力学的牛顿定律、上述 $T(t)$ 的定义以及 Berendsen 恒温器的速度重标定作用出发，推导在弱耦合条件下接近平衡态时，控制 $\\delta T(t)$ 的线性化一阶微分方程。然后，使用线性响应理论，求出从涨落输入 $u(t)$ 到输出 $\\delta T(t)$ 的闭环传递函数，并确定闭环 $-3\\,\\text{dB}$ 带宽（即闭环增益的幅度降至其零频值的 $1/\\sqrt{2}$ 时的角截止频率）。\n\n将最终带宽以弧度/秒为单位表示为一个关于 $\\tau$ 的单一闭式解析表达式。无需进行数值计算。最后，在你的推导过程中，用你的表达式解释 $\\tau$ 的选择如何控制 $\\delta T(t)$ 中动能涨落快速分量的衰减，阐明在这种机制下，这些快速分量是如何被恒温器反馈所滤除的。",
            "solution": "该问题陈述经评估是有效的，因为它在科学上基于计算统计力学的原理，问题提出得当，信息充分，可得到唯一解，并以客观、正式的语言表述。它没有矛盾、模糊或不合理的假设。因此，我们可以进行推导。\n\nBerendsen 恒温器通过在每个时间步长重新缩放粒子速度来控制系统温度。瞬时动能温度 $T(t)$ 的变化率与目标温度 $T_0$ 的偏差成正比。这可以表示为一个一阶弛豫过程。在连续极限下，恒温器的作用是引起温度变化率，由下式给出：\n$$\n\\left. \\frac{dT}{dt} \\right|_{\\text{thermostat}} = \\frac{T_0 - T(t)}{\\tau}\n$$\n其中 $\\tau$ 是弛豫时间常数。\n\n问题陈述指出，除了恒温器的作用外，还有来自确定性哈密顿动力学的净效应，它作为对温度动力学的一个小的、附加的驱动项 $u(t)$。温度 $T(t)$ 的总变化率是恒温器的贡献和这个内在驱动项的总和：\n$$\n\\frac{dT(t)}{dt} = \\frac{T_0 - T(t)}{\\tau} + u(t)\n$$\n这是在 Berendsen 恒温器和内部能量涨落影响下，控制温度 $T(t)$ 的非线性微分方程。\n\n为了推导小偏差 $\\delta T(t) = T(t) - T_0$ 的线性化方程，我们将 $T(t) = T_0 + \\delta T(t)$ 代入控制方程。$T(t)$ 的导数是：\n$$\n\\frac{dT(t)}{dt} = \\frac{d}{dt} (T_0 + \\delta T(t)) = \\frac{d(\\delta T(t))}{dt}\n$$\n因为 $T_0$ 是一个常数。等式右边的项变为：\n$$\n\\frac{T_0 - (T_0 + \\delta T(t))}{\\tau} + u(t) = -\\frac{\\delta T(t)}{\\tau} + u(t)\n$$\n将两个表达式相等，我们得到关于 $\\delta T(t)$ 的线性化一阶常微分方程：\n$$\n\\frac{d(\\delta T(t))}{dt} = -\\frac{\\delta T(t)}{\\tau} + u(t)\n$$\n将其重新整理成标准形式得到：\n$$\n\\frac{d(\\delta T(t))}{dt} + \\frac{1}{\\tau} \\delta T(t) = u(t)\n$$\n该方程描述了平衡态附近的小温度偏差作为一个受驱动的一阶线性系统的演化。\n\n接下来，我们确定从输入 $u(t)$ 到输出 $\\delta T(t)$ 的闭环传递函数 $H(s)$。我们对微分方程应用拉普拉斯变换，假设偏差的初始条件为零（$\\delta T(0) = 0$）。设 $\\Delta \\tilde{T}(s) = \\mathcal{L}\\{\\delta T(t)\\}$ 和 $\\tilde{U}(s) = \\mathcal{L}\\{u(t)\\}$。\n导数的拉普拉斯变换是 $\\mathcal{L}\\{\\frac{d(\\delta T(t))}{dt}\\} = s \\Delta \\tilde{T}(s) - \\delta T(0) = s \\Delta \\tilde{T}(s)$。\n对整个方程进行变换得到：\n$$\ns \\Delta \\tilde{T}(s) + \\frac{1}{\\tau} \\Delta \\tilde{T}(s) = \\tilde{U}(s)\n$$\n提出因子 $\\Delta \\tilde{T}(s)$：\n$$\n\\Delta \\tilde{T}(s) \\left( s + \\frac{1}{\\tau} \\right) = \\tilde{U}(s)\n$$\n传递函数 $H(s)$ 是输出变换与输入变换的比值：\n$$\nH(s) = \\frac{\\Delta \\tilde{T}(s)}{\\tilde{U}(s)} = \\frac{1}{s + \\frac{1}{\\tau}}\n$$\n为了分析频率响应，我们通过设置 $s = j\\omega$ 来评估虚轴上的传递函数，其中 $j$ 是虚数单位，$\\omega$ 是以弧度/秒为单位的角频率。\n$$\nH(j\\omega) = \\frac{1}{j\\omega + \\frac{1}{\\tau}}\n$$\n频率响应的幅度，或称增益，为：\n$$\n|H(j\\omega)| = \\left| \\frac{1}{\\frac{1}{\\tau} + j\\omega} \\right| = \\frac{1}{\\sqrt{\\left(\\frac{1}{\\tau}\\right)^2 + \\omega^2}}\n$$\n$-3\\,\\text{dB}$ 带宽，记为 $\\omega_c$，是增益幅度下降到其零频（DC）值的 $1/\\sqrt{2}$ 时的角频率。首先，我们通过设置 $\\omega = 0$ 来求得零频增益：\n$$\n|H(j0)| = \\frac{1}{\\sqrt{\\left(\\frac{1}{\\tau}\\right)^2 + 0^2}} = \\frac{1}{1/\\tau} = \\tau\n$$\n现在，我们将 $\\omega_c$ 处的增益设为等于 $\\frac{1}{\\sqrt{2}}|H(j0)|$：\n$$\n|H(j\\omega_c)| = \\frac{1}{\\sqrt{\\left(\\frac{1}{\\tau}\\right)^2 + \\omega_c^2}} = \\frac{\\tau}{\\sqrt{2}}\n$$\n将方程两边平方：\n$$\n\\frac{1}{\\left(\\frac{1}{\\tau}\\right)^2 + \\omega_c^2} = \\frac{\\tau^2}{2}\n$$\n两边取倒数：\n$$\n\\frac{1}{\\tau^2} + \\omega_c^2 = \\frac{2}{\\tau^2}\n$$\n求解 $\\omega_c^2$：\n$$\n\\omega_c^2 = \\frac{2}{\\tau^2} - \\frac{1}{\\tau^2} = \\frac{1}{\\tau^2}\n$$\n取正根，因为角频率是非负的，得到 $-3\\,\\text{dB}$ 带宽：\n$$\n\\omega_c = \\frac{1}{\\tau}\n$$\n这个表达式揭示了 $\\tau$ 的选择如何控制系统对涨落的响应。传递函数描述了一个截止频率为 $\\omega_c = 1/\\tau$ 的一阶低通滤波器。\n对于具有低频分量（$\\omega \\ll 1/\\tau$）的输入涨落 $u(t)$，增益 $|H(j\\omega)| \\approx |H(j0)| = \\tau$。恒温器允许这些缓慢的变化传递到温度 $\\delta T(t)$。\n相反，对于具有高频分量（$\\omega \\gg 1/\\tau$）的快速涨落，增益被衰减。在这种情况下， $|H(j\\omega)| \\approx \\frac{1}{\\sqrt{\\omega^2}} = \\frac{1}{\\omega}$。响应幅度随频率成反比减小。\n因此，为了有效地滤除或抑制快速的动能涨落，例如角频率为 $\\Omega$ 的涨落，必须选择一个大的弛豫时间 $\\tau$。具体来说，强衰减的条件是 $\\frac{1}{\\tau} \\ll \\Omega$，这使得滤波器的截止频率远低于涨落的频率。在这种机制下（弱耦合，大 $\\tau$），恒温器通过对许多短时间尺度的涨落进行平均来起作用，从而产生更平滑的温度曲线 $T(t)$，使其不易受到来自底层哈密顿动力学的高频噪声的影响。",
            "answer": "$$\\boxed{\\frac{1}{\\tau}}$$"
        },
        {
            "introduction": "对于统计力学模拟而言，温控器的最终目标是确保对正则系综进行各态历经的采样。本高阶练习提供了一个完整的数值实验框架，用于检验 Nosé–Hoover 链式温控器在存在高能垒的复杂势能面上的各态历经性 。通过比较模拟轨迹的驻留时间与理论玻尔兹曼分布，您将学会如何验证温控器是否真正实现了其核心功能。",
            "id": "3496461",
            "problem": "设计并实现一个完整的、独立的数值实验，通过将基于驻留时间的阱经验占据分数与相应的玻尔兹曼权重进行比较，以评估Nosé–Hoover链采样器对于在三阱势中演化的一维粒子是否有效遍历。您的程序必须实现确定性动力学的时间积分（使用Nosé–Hoover链恒温器）、计算预定义阱中的驻留时间、通过数值积分评估理论玻尔兹曼概率，并根据一个量化差异度量为指定的测试用例判定通过或失败。\n\n所有模拟均采用简化的无量纲单位。设粒子质量为$m = 1$，玻尔兹曼常数为$k_{\\mathrm{B}} = 1$。势能为\n$$\nV(x) = \\frac{x^{6}}{6} - \\frac{a}{4}\\,x^{4} + \\frac{b}{2}\\,x^{2},\n$$\n参数为$a = 5$和$b = 4$。对于这些参数，距离原点最近的局部极大值出现在$x = \\pm 1$处，且该势有三个阱：左阱$(-\\infty,-1)$、中阱$[-1,1]$和右阱$(1,\\infty)$。\n\n实现一个长度为$M$的Nosé–Hoover链，用于将动能温度控制在目标温度$T$。使用单个物理坐标$x$和速度$v = \\dot{x}$。令$\\xi_{j}$表示第$j$个恒温器变量，$Q_{j}$表示相应的恒温器质量。需要积分的运动方程是用于单自由度的标准Nosé–Hoover链常微分方程：\n- $\\dot{x} = v$,\n- $\\dot{v} = \\frac{F(x)}{m} - \\xi_{1}\\,v$，其中$F(x) = -\\frac{d V}{d x}$，\n- 对于$j = 1$：若$M \\ge 2$，则$\\dot{\\xi}_{1} = \\frac{m v^{2} - k_{\\mathrm{B}} T}{Q_{1}} - \\xi_{2}\\,\\xi_{1}$；若$M = 1$，则$\\dot{\\xi}_{1} = \\frac{m v^{2} - k_{\\mathrm{B}} T}{Q_{1}}$，\n- 对于$j = 2,\\dots,M-1$：$\\dot{\\xi}_{j} = \\frac{Q_{j-1}\\,\\xi_{j-1}^{2} - k_{\\mathrm{B}} T}{Q_{j}} - \\xi_{j+1}\\,\\xi_{j}$，\n- 对于$j = M$：$\\dot{\\xi}_{M} = \\frac{Q_{M-1}\\,\\xi_{M-1}^{2} - k_{\\mathrm{B}} T}{Q_{M}}$。\n\n根据$Q_{j} = k_{\\mathrm{B}} T\\,\\tau^{2}$（对于所有$j \\in \\{1,\\dots,M\\}$）选择恒温器质量，其中$\\tau$是用户指定的恒温器时间尺度。使用固定时间步长$\\Delta t$和您选择的固定步长显式积分器对上述系统进行数值积分。您的数值实验必须：\n- 使用时间步长$\\Delta t$模拟总共$N_{\\text{steps}}$步，\n- 从所有统计数据中舍弃最初$N_{\\text{burn}}$步的预烧期（burn-in），\n- 通过将轨迹分割为每个阱内的最大连续片段，并以$\\Delta t$的时间单位记录每个片段的持续时间，来计算驻留时间分布，\n- 计算经验占据分数向量$\\hat{\\boldsymbol{p}} = (\\hat{p}_{\\mathrm{L}}, \\hat{p}_{\\mathrm{C}}, \\hat{p}_{\\mathrm{R}})$，作为预烧期后模拟时间中在三个阱中各自所花费的时间分数，\n- 通过以下公式计算理论玻尔兹曼概率$\\boldsymbol{p}^{\\star} = (p_{\\mathrm{L}}^{\\star}, p_{\\mathrm{C}}^{\\star}, p_{\\mathrm{R}}^{\\star})$\n$$\np_{\\mathrm{L}}^{\\star} = \\frac{1}{Z}\\int_{-\\infty}^{-1} e^{-\\beta V(x)}\\,dx,\\quad\np_{\\mathrm{C}}^{\\star} = \\frac{1}{Z}\\int_{-1}^{1} e^{-\\beta V(x)}\\,dx,\\quad\np_{\\mathrm{R}}^{\\star} = \\frac{1}{Z}\\int_{1}^{\\infty} e^{-\\beta V(x)}\\,dx,\n$$\n其中$\\beta = 1/(k_{\\mathrm{B}} T)$，配分函数$Z$等于这三个积分之和；以高精度数值计算这些积分，\n- 计算总变差\n$$\nD_{\\mathrm{TV}}(\\hat{\\boldsymbol{p}}, \\boldsymbol{p}^{\\star}) = \\frac{1}{2}\\sum_{w \\in \\{\\mathrm{L},\\mathrm{C},\\mathrm{R}\\}} \\left|\\hat{p}_{w} - p_{w}^{\\star}\\right|.\n$$\n\n如果$D_{\\mathrm{TV}}(\\hat{\\boldsymbol{p}}, \\boldsymbol{p}^{\\star}) \\le \\varepsilon$，则一个测试用例被判定为“通过”（pass），其中$\\varepsilon$是为该用例提供的容差。否则，判定为“失败”（fail）。使用以下测试套件，其中每个元组为$(T, M, \\Delta t, N_{\\text{steps}}, N_{\\text{burn}}, \\tau, \\varepsilon)$：\n- 案例1：$(0.5, 3, 0.002, 60000, 5000, 0.2, 0.12)$,\n- 案例2：$(0.1, 3, 0.002, 40000, 5000, 0.2, 0.20)$,\n- 案例3：$(0.5, 1, 0.002, 40000, 5000, 0.2, 0.12)$,\n- 案例4：$(0.5, 5, 0.002, 80000, 5000, 0.2, 0.10)$。\n\n初始化要求：\n- 设置初始位置为$x(0) = 0$，\n- 使用固定的随机种子从方差为$k_{\\mathrm{B}} T / m$的零均值高斯分布中抽取初始速度，以使结果具有确定性，\n- 将所有恒温器变量初始化为$\\xi_{j}(0) = 0$。\n\n所有量均为无量纲。您的程序必须为每个测试用例计算一个布尔值，根据上述标准指示通过（true）或失败（false）。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[true,false,true,true]”），并保留Python布尔值的大小写（“True”和“False”）。不要求输出角度或百分比。最终输出必须严格遵循此格式，不得包含任何额外文本。",
            "solution": "该问题要求设计并实现一个数值实验，以评估Nosé–Hoover链恒温器的遍历性采样效率。所考虑的系统是一个质量为$m=1$的一维粒子，在对称三阱势中运动，该势由以下公式给出\n$$\nV(x) = \\frac{x^{6}}{6} - \\frac{a}{4}\\,x^{4} + \\frac{b}{2}\\,x^{2}\n$$\n其中参数$a=5$和$b=4$。玻尔兹曼常数设为$k_{\\mathrm{B}}=1$。遍历性的评估是通过将从长时分子动力学轨迹中获得的势阱经验占据分数与从玻尔兹曼分布推导出的理论概率进行比较来执行的。\n\n首先，我们定义物理系统。作用在粒子上的力是势的负梯度：\n$$\nF(x) = -\\frac{dV(x)}{dx} = -\\left(x^{5} - ax^{3} + bx\\right) = -x^{5} + 5x^{3} - 4x.\n$$\n系统的温度由长度为$M$的Nosé–Hoover链控制。整个系统的状态由粒子的位置$x$、速度$v$以及$M$个恒温器变量$\\xi_{1}, \\xi_{2}, \\dots, \\xi_{M}$描述。这个扩展系统的运动方程是一组耦合的一阶常微分方程(ODEs)：\n\\begin{align*}\n\\dot{x} = v \\\\\n\\dot{v} = \\frac{F(x)}{m} - \\xi_{1} v \\\\\n\\dot{\\xi}_{1} = \\frac{1}{Q_{1}}(m v^{2} - k_{\\mathrm{B}} T) - \\begin{cases} 0  \\text{if } M=1 \\\\ \\xi_{2} \\xi_{1}  \\text{if } M \\ge 2 \\end{cases} \\\\\n\\dot{\\xi}_{j} = \\frac{1}{Q_{j}}(Q_{j-1} \\xi_{j-1}^{2} - k_{\\mathrm{B}} T) - \\xi_{j+1} \\xi_{j}, \\quad \\text{for } j=2, \\dots, M-1 \\\\\n\\dot{\\xi}_{M} = \\frac{1}{Q_{M}}(Q_{M-1} \\xi_{M-1}^{2} - k_{\\mathrm{B}} T), \\quad \\text{for } M \\ge 2\n\\end{align*}\n其中$T$是目标温度，$Q_j$是恒温器“质量”，对于给定的时间尺度参数$\\tau$，设置为$Q_j = k_{\\mathrm{B}} T \\tau^2$。这个恒温器链旨在生成正则系综动力学。第一个恒温器变量$\\xi_1$直接耦合到物理粒子的动能，而随后的变量$\\xi_2, \\ldots, \\xi_M$形成一个链，对前一个变量进行恒温控制，这有助于抑制振荡并改善相空间的探索，这是简单Nosé-Hoover恒温器($M=1$)的一个已知问题。\n\n为了数值求解这些常微分方程，需要一个鲁棒的积分方案。虽然像Martyna-Tuckerman-Klein算法这样的辛积分器很常用，但对于这个问题，我们选择四阶龙格-库塔(RK4)方法。RK4是一种通用、显式且高精度的积分器，适用于在有限时间间隔内行为良好的常微分方程组。虽然不是辛算法，但其高阶特性可将每一步的能量漂移降至最低，并且恒温器的作用旨在纠正任何此类漂移，以长期维持目标温度。状态向量是$Y = (x, v, \\xi_1, \\dots, \\xi_M)$，积分通过迭代应用RK4更新规则进行。\n\n实验的核心是检验遍历性假设，该假设指出，对于一个遍历系统，可观测量的时间平均值等于其系综平均值。在这里，可观测量是粒子相对于三个势阱的位置：左阱$W_L = (-\\infty, -1)$、中阱$W_C = [-1, 1]$和右阱$W_R = (1, \\infty)$。\n对于一个阱$w \\in \\{\\mathrm{L}, \\mathrm{C}, \\mathrm{R}\\}$的经验占据分数，记为$\\hat{p}_w$，计算为粒子在该阱中度过的时间占模拟总时间（在$N_{\\text{burn}}$步的初始预烧期之后）的比例。\n$$\n\\hat{p}_{w} = \\frac{\\text{阱 } w \\text{ 中预烧期后的步数}}{\\text{预烧期后的总步数}}\n$$\n理论概率$p_w^{\\star}$源自正则系综的玻尔兹曼分布。在某个区域内发现粒子的概率与该区域上玻尔兹曼因子$e^{-\\beta V(x)}$的积分成正比，其中$\\beta = 1/(k_{\\mathrm{B}} T)$。这些概率是：\n$$\np_{w}^{\\star} = \\frac{1}{Z} \\int_{x \\in W_w} e^{-\\beta V(x)} dx\n$$\n其中$Z = \\int_{-\\infty}^{\\infty} e^{-\\beta V(x)} dx$是配分函数，确保归一化（$\\sum_w p_w^{\\star} = 1$）。由于$V(x)$的复杂性，这些积分使用标准的求积方法（例如`scipy.integrate.quad`提供的方法）进行高精度数值计算。\n\n最后，使用总变差距离来量化模拟分布与理论分布之间的差异：\n$$\nD_{\\mathrm{TV}}(\\hat{\\boldsymbol{p}}, \\boldsymbol{p}^{\\star}) = \\frac{1}{2}\\sum_{w \\in \\{\\mathrm{L},\\mathrm{C},\\mathrm{R}\\}} \\left|\\hat{p}_{w} - p_{w}^{\\star}\\right|.\n$$\n如果此差异小于或等于给定的容差$\\varepsilon$，则该测试用例被视为“通过”，这表明模拟已经以与目标正则系综一致的方式对构型空间进行了采样。通过固定随机数生成器的种子，整个过程是确定性的，包括初始速度的抽取。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy, version: 1.23.5\n#   name: scipy, version: 1.11.4\n\ndef solve():\n    \"\"\"\n    Main function to run the series of numerical experiments.\n    \"\"\"\n    # Define test cases: (T, M, dt, N_steps, N_burn, tau, epsilon)\n    test_cases = [\n        (0.5, 3, 0.002, 60000, 5000, 0.2, 0.12),\n        (0.1, 3, 0.002, 40000, 5000, 0.2, 0.20),\n        (0.5, 1, 0.002, 40000, 5000, 0.2, 0.12),\n        (0.5, 5, 0.002, 80000, 5000, 0.2, 0.10),\n    ]\n\n    # Global parameters\n    m = 1.0\n    k_B = 1.0\n    a = 5.0\n    b = 4.0\n    \n    # Use a fixed seed for reproducibility as requested\n    np.random.seed(12345)\n\n    def V(x):\n        \"\"\"Potential energy function V(x).\"\"\"\n        return (x**6 / 6.0) - (a / 4.0) * x**4 + (b / 2.0) * x**2\n\n    def F(x):\n        \"\"\"Force function F(x) = -dV/dx.\"\"\"\n        return -(x**5 - a * x**3 + b * x)\n\n    def calculate_theoretical_probabilities(T):\n        \"\"\"\n        Computes theoretical well probabilities using numerical quadrature.\n        \"\"\"\n        beta = 1.0 / (k_B * T)\n        integrand = lambda x: np.exp(-beta * V(x))\n\n        I_L, _ = quad(integrand, -np.inf, -1.0)\n        I_C, _ = quad(integrand, -1.0, 1.0)\n        I_R, _ = quad(integrand, 1.0, np.inf)\n\n        Z = I_L + I_C + I_R\n        return np.array([I_L / Z, I_C / Z, I_R / Z])\n\n    def get_derivatives(state, T, M, Q, m_val):\n        \"\"\"\n        Computes the time derivatives of the state vector [x, v, xi_1, ..., xi_M].\n        \"\"\"\n        x, v = state[0], state[1]\n        xi = state[2:]\n        \n        derivs = np.zeros_like(state)\n        \n        # d_x/dt\n        derivs[0] = v\n        # d_v/dt\n        derivs[1] = F(x) / m_val - xi[0] * v\n        \n        # d_xi/dt\n        if M == 1:\n            g1 = m_val * v**2 - k_B * T\n            derivs[2] = g1 / Q[0]\n        else: # M >= 2\n            # j = 1\n            g1 = m_val * v**2 - k_B * T\n            derivs[2] = g1 / Q[0] - xi[1] * xi[0]\n            \n            # j = 2 to M-1\n            for j in range(1, M - 1):\n                gj_plus_1 = Q[j - 1] * xi[j - 1]**2 - k_B * T\n                derivs[j + 2] = gj_plus_1 / Q[j] - xi[j + 1] * xi[j]\n                \n            # j = M\n            gM = Q[M - 2] * xi[M - 2]**2 - k_B * T\n            derivs[M + 1] = gM / Q[M - 1]\n            \n        return derivs\n\n    def run_simulation(T, M, dt, N_steps, N_burn, tau):\n        \"\"\"\n        Runs a single MD simulation with a Nosé-Hoover chain thermostat.\n        \"\"\"\n        # Initial conditions\n        x0 = 0.0\n        v0 = np.random.normal(loc=0.0, scale=np.sqrt(k_B * T / m))\n        xi0 = np.zeros(M)\n        \n        state = np.concatenate(([x0, v0], xi0))\n        \n        Q_vals = np.full(M, k_B * T * tau**2)\n        \n        residence_counts = np.zeros(3) # [Left, Center, Right]\n\n        for step in range(N_steps):\n            # RK4 integrator\n            k1 = dt * get_derivatives(state, T, M, Q_vals, m)\n            k2 = dt * get_derivatives(state + 0.5 * k1, T, M, Q_vals, m)\n            k3 = dt * get_derivatives(state + 0.5 * k2, T, M, Q_vals, m)\n            k4 = dt * get_derivatives(state + k3, T, M, Q_vals, m)\n            state += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n            if step >= N_burn:\n                x_pos = state[0]\n                if x_pos  -1.0:\n                    residence_counts[0] += 1\n                elif x_pos > 1.0:\n                    residence_counts[2] += 1\n                else:\n                    residence_counts[1] += 1\n        \n        total_production_steps = N_steps - N_burn\n        if total_production_steps > 0:\n            p_hat = residence_counts / total_production_steps\n        else:\n            p_hat = np.array([0.0, 0.0, 0.0])\n            \n        return p_hat\n\n    results = []\n    for T, M, dt, N_steps, N_burn, tau, epsilon in test_cases:\n        p_star = calculate_theoretical_probabilities(T)\n        p_hat = run_simulation(T, M, dt, N_steps, N_burn, tau)\n        \n        D_TV = 0.5 * np.sum(np.abs(p_hat - p_star))\n        \n        pass_fail = D_TV = epsilon\n        results.append(pass_fail)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}