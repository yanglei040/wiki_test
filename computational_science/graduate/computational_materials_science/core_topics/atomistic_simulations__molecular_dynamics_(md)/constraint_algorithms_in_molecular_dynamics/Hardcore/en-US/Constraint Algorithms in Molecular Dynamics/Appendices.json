{
    "hands_on_practices": [
        {
            "introduction": "This exercise dives into the mathematical core of second-order constraint algorithms like RATTLE. You will derive the \"curvature term,\" $c(q, \\dot{q})$, that arises from the second time derivative of a holonomic constraint. Mastering this derivation provides a deep understanding of the kinematics on a constraint manifold and is essential for implementing or analyzing advanced, time-reversible constraint solvers. ",
            "id": "3439796",
            "problem": "Consider a three-dimensional diatomic system with atomic positions $r_a \\in \\mathbb{R}^3$ and $r_b \\in \\mathbb{R}^3$. Define the bond vector $r_{ab} = r_a - r_b$, the relative velocity $v_{ab} = \\dot{r}_a - \\dot{r}_b$, and a fixed bond length $d > 0$. The holonomic distance constraint is imposed as\n$$\n\\sigma(q) = r_{ab} \\cdot r_{ab} - d^2 = 0,\n$$\nwhere $q = (r_a, r_b)$ denotes the full coordinate vector. In constraint-based molecular dynamics, the second time derivative of the constraint takes the general form\n$$\n\\ddot{\\sigma}(q,\\dot{q},\\ddot{q}) = \\nabla \\sigma(q) \\cdot \\ddot{q} + c(q,\\dot{q}),\n$$\nwhere the curvature term is defined by\n$$\nc(q,\\dot{q}) = \\dot{q}^{\\top} \\nabla^2 \\sigma(q) \\, \\dot{q}.\n$$\nStarting from these definitions and Newtonian kinematics, derive an explicit expression for $c(q,\\dot{q})$ in terms of $v_{ab}$ and $r_{ab}$. Your final answer must be a single, closed-form analytic expression for $c(q,\\dot{q})$. No numerical evaluation is required, and no units are to be included in the final expression.",
            "solution": "The curvature term $c(q,\\dot{q})$ is defined by the quadratic form $c(q,\\dot{q}) = \\dot{q}^{\\top} \\nabla^2 \\sigma(q) \\, \\dot{q}$. To derive its explicit expression, we will first compute the Hessian matrix $\\nabla^2 \\sigma(q)$ of the constraint function $\\sigma(q)$ and then apply the quadratic form.\n\n**1. Constraint Function and Coordinate System**\n\nThe coordinate vector is $q = (r_a, r_b)$, which can be written as a $6 \\times 1$ column vector $q = [x_a, y_a, z_a, x_b, y_b, z_b]^{\\top}$. The constraint function is:\n$$\n\\sigma(q) = (r_a - r_b) \\cdot (r_a - r_b) - d^2 = \\|r_a - r_b\\|^2 - d^2\n$$\n\n**2. Gradient of the Constraint**\n\nFirst, we compute the gradient of $\\sigma(q)$, which is a $6 \\times 1$ vector of partial derivatives. Using vector calculus, the partial derivatives with respect to the vector coordinates $r_a$ and $r_b$ are:\n$$\n\\frac{\\partial \\sigma}{\\partial r_a} = 2(r_a - r_b) = 2r_{ab}\n$$\n$$\n\\frac{\\partial \\sigma}{\\partial r_b} = -2(r_a - r_b) = -2r_{ab}\n$$\nThus, the gradient vector $\\nabla \\sigma(q)$ can be represented in block form as $\\begin{pmatrix} 2r_{ab} \\\\ -2r_{ab} \\end{pmatrix}$.\n\n**3. Hessian of the Constraint**\n\nNext, we compute the Hessian matrix $\\nabla^2 \\sigma(q)$, which is the $6 \\times 6$ matrix of second partial derivatives. We find the $3 \\times 3$ blocks of this matrix by differentiating the gradient components:\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_a \\partial r_a} = \\frac{\\partial}{\\partial r_a} (2(r_a - r_b)) = 2 I_3\n$$\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_a \\partial r_b} = \\frac{\\partial}{\\partial r_b} (2(r_a - r_b)) = -2 I_3\n$$\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_b \\partial r_a} = \\frac{\\partial}{\\partial r_a} (-2(r_a - r_b)) = -2 I_3\n$$\n$$\n\\frac{\\partial^2 \\sigma}{\\partial r_b \\partial r_b} = \\frac{\\partial}{\\partial r_b} (-2(r_a - r_b)) = 2 I_3\n$$\nHere, $I_3$ is the $3 \\times 3$ identity matrix. Assembling these blocks, the Hessian is:\n$$\n\\nabla^2 \\sigma(q) = \\begin{pmatrix} 2I_3 & -2I_3 \\\\ -2I_3 & 2I_3 \\end{pmatrix} = 2 \\begin{pmatrix} I_3 & -I_3 \\\\ -I_3 & I_3 \\end{pmatrix}\n$$\n\n**4. Computing the Curvature Term**\n\nNow we can compute the quadratic form $c(q,\\dot{q}) = \\dot{q}^{\\top} \\nabla^2 \\sigma(q) \\, \\dot{q}$. The velocity vector $\\dot{q}$ is given in block form as $\\dot{q} = \\begin{pmatrix} \\dot{r}_a \\\\ \\dot{r}_b \\end{pmatrix}$.\n$$\nc(q,\\dot{q}) = \\begin{pmatrix} \\dot{r}_a^{\\top} & \\dot{r}_b^{\\top} \\end{pmatrix} \\left( 2 \\begin{pmatrix} I_3 & -I_3 \\\\ -I_3 & I_3 \\end{pmatrix} \\right) \\begin{pmatrix} \\dot{r}_a \\\\ \\dot{r}_b \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\nc(q,\\dot{q}) = 2 \\begin{pmatrix} \\dot{r}_a^{\\top} & \\dot{r}_b^{\\top} \\end{pmatrix} \\begin{pmatrix} I_3\\dot{r}_a - I_3\\dot{r}_b \\\\ -I_3\\dot{r}_a + I_3\\dot{r}_b \\end{pmatrix} = 2 \\begin{pmatrix} \\dot{r}_a^{\\top} & \\dot{r}_b^{\\top} \\end{pmatrix} \\begin{pmatrix} \\dot{r}_a - \\dot{r}_b \\\\ -(\\dot{r}_a - \\dot{r}_b) \\end{pmatrix}\n$$\nCompleting the dot product:\n$$\nc(q,\\dot{q}) = 2 \\left( \\dot{r}_a^{\\top}(\\dot{r}_a - \\dot{r}_b) - \\dot{r}_b^{\\top}(\\dot{r}_a - \\dot{r}_b) \\right) = 2 \\left( (\\dot{r}_a^{\\top} - \\dot{r}_b^{\\top})(\\dot{r}_a - \\dot{r}_b) \\right)\n$$\nUsing the definition of the relative velocity, $v_{ab} = \\dot{r}_a - \\dot{r}_b$:\n$$\nc(q,\\dot{q}) = 2 (\\dot{r}_a - \\dot{r}_b)^{\\top} (\\dot{r}_a - \\dot{r}_b) = 2 v_{ab}^{\\top} v_{ab}\n$$\nThis is the dot product of the relative velocity vector with itself, which can be written as:\n$$\nc(q,\\dot{q}) = 2 (v_{ab} \\cdot v_{ab}) = 2 \\|v_{ab}\\|^2\n$$\nThe problem asks for the answer in terms of $v_{ab}$ and $r_{ab}$, so $2 v_{ab} \\cdot v_{ab}$ is the most appropriate form matching the answer box.\n\n**Alternative Method: Direct Differentiation**\n\nAn alternative way to find the curvature term is by differentiating the velocity-level constraint equation, $\\dot{\\sigma} = 0$.\n1. Differentiate the position constraint $\\sigma(q)=0$ with respect to time:\n$$\n\\dot{\\sigma} = \\frac{d}{dt} (r_{ab} \\cdot r_{ab} - d^2) = 2 r_{ab} \\cdot \\dot{r}_{ab} = 2 r_{ab} \\cdot v_{ab} = 0\n$$\n2. Differentiate $\\dot{\\sigma}$ again with respect to time:\n$$\n\\ddot{\\sigma} = \\frac{d}{dt}(2 r_{ab} \\cdot v_{ab}) = 2(\\dot{r}_{ab} \\cdot v_{ab} + r_{ab} \\cdot \\dot{v}_{ab}) = 2(v_{ab} \\cdot v_{ab} + r_{ab} \\cdot \\dot{v}_{ab}) = 2\\|v_{ab}\\|^2 + 2r_{ab} \\cdot (\\ddot{r}_a - \\ddot{r}_b)\n$$\n3. Compare this with the given form $\\ddot{\\sigma} = \\nabla \\sigma(q) \\cdot \\ddot{q} + c(q,\\dot{q})$. We have $\\nabla \\sigma(q) \\cdot \\ddot{q} = (2r_{ab}, -2r_{ab}) \\cdot (\\ddot{r}_a, \\ddot{r}_b) = 2r_{ab} \\cdot \\ddot{r}_a - 2r_{ab} \\cdot \\ddot{r}_b = 2r_{ab} \\cdot (\\ddot{r}_a - \\ddot{r}_b)$.\n4. By comparing the two expressions for $\\ddot{\\sigma}$, we can identify the remaining term as $c(q,\\dot{q})$:\n$$\nc(q,\\dot{q}) = 2 \\|v_{ab}\\|^2 = 2 v_{ab} \\cdot v_{ab}\n$$\nThis confirms the result from the first method.",
            "answer": "$$\n\\boxed{2 v_{ab} \\cdot v_{ab}}\n$$"
        },
        {
            "introduction": "Building on the theoretical foundations, this practice problem explores the profound impact of algorithmic choices on physical realism in a simulation. By comparing a simple position-only constraint enforcement (SHAKE) with a full position and velocity constraint method (RATTLE), you will analyze why the latter is crucial for correct energy conservation and temperature measurement in microcanonical simulations. This exercise highlights the direct link between an algorithm's mathematical properties and the physical fidelity of the simulation results. ",
            "id": "3439783",
            "problem": "Consider a system of $N$ particles in Molecular Dynamics (MD) evolving in the microcanonical ensemble (NVE) with holonomic constraints $g(q)=0$, where $q \\in \\mathbb{R}^{3N}$ is the vector of Cartesian coordinates, $g:\\mathbb{R}^{3N} \\to \\mathbb{R}^{m}$ is the vector of $m$ constraint functions, $J(q) = \\partial g(q)/\\partial q$ is the constraint Jacobian, and $M$ is the symmetric positive definite mass matrix. The constrained equations of motion are enforced by Lagrange multipliers $\\lambda \\in \\mathbb{R}^{m}$ so that the dynamics obey Newton’s second law $M \\ddot{q} = -\\nabla U(q) + J(q)^{\\top}\\lambda$, where $U(q)$ is the potential energy, together with the holonomic constraints $g(q)=0$. The velocity Verlet (VV) integrator is used. In the SHAKE approach, position constraints are imposed each step to enforce $g(q_{n+1})=0$ but no explicit velocity constraint is applied. In the full RATTLE approach, both position constraints and velocity constraints $J(q_{n+1})\\dot{q}_{n+1}=0$ are imposed at each step by appropriate Lagrange multiplier corrections.\n\nFrom first principles, analyze how the discrete constraint enforcement affects the total energy behavior and the kinetic temperature associated with the unconstrained degrees of freedom. The kinetic temperature is to be understood in the constrained sense: it should be associated with velocity components tangent to the constraint manifold, and $k_{\\mathrm{B}}$ denotes the Boltzmann constant. Assume time step $\\Delta t$ is small, the potential $U(q)$ is smooth, and initial conditions satisfy both $g(q_0)=0$ and $J(q_0)\\dot{q}_0=0$.\n\nWhich of the following statements are correct in this setting?\n\nA. For velocity Verlet with constraints, if only position constraints are enforced (SHAKE-only), the discrete constraint force can perform nonzero work because $J(q_{n+1})\\dot{q}_{n+1}\\neq 0$ at finite $\\Delta t$, leading to a systematic drift in the total energy over long times. In contrast, full RATTLE enforces $J(q_{n+1})\\dot{q}_{n+1}=0$ and yields bounded, oscillatory energy error characteristic of symplectic, time-reversible integration rather than secular drift.\n\nB. The constrained kinetic temperature computed from unprojected velocities and divided by the number of unconstrained degrees of freedom is, in long-time average, identical for SHAKE-only and RATTLE, because position constraints alone are sufficient to eliminate spurious velocity components along constrained directions.\n\nC. The RATTLE corrections introduce effective damping into the velocity Verlet scheme, reducing the total energy over time compared to SHAKE-only, even in the absence of any thermostat, because Lagrange multipliers always remove energy associated with constrained motion.\n\nD. The correct constrained kinetic temperature is defined from the kinetic energy associated with velocity components tangent to the constraint manifold; imposing velocity constraints in RATTLE ensures $J(q_{n+1})\\dot{q}_{n+1}=0$, so the measured kinetic temperature is unbiased and consistent with equipartition over the unconstrained degrees of freedom. Under SHAKE-only, if one uses unprojected velocities, spurious normal components can produce a bias in the reported constrained kinetic temperature.\n\nSelect all that apply.",
            "solution": "The problem asks for an analysis of two constraint algorithms, SHAKE and RATTLE, used with the velocity Verlet integrator in a microcanonical (NVE) molecular dynamics simulation. We must assess their impact on total energy conservation and the calculation of kinetic temperature.\n\n### 1. Validation of the Problem Statement\n\n**Step 1: Extract Givens**\n- System: $N$ particles, microcanonical ensemble (NVE).\n- Constraints: $m$ holonomic constraints, $g(q)=0$, where $q \\in \\mathbb{R}^{3N}$.\n- Jacobian: $J(q) = \\partial g(q)/\\partial q$.\n- Mass Matrix: $M$, symmetric positive definite.\n- Equations of Motion: $M \\ddot{q} = -\\nabla U(q) + J(q)^{\\top}\\lambda$, with potential energy $U(q)$ and Lagrange multipliers $\\lambda \\in \\mathbb{R}^{m}$.\n- Integrator: Velocity Verlet (VV).\n- SHAKE Algorithm: Enforces position constraints $g(q_{n+1})=0$. No explicit velocity constraint is applied.\n- RATTLE Algorithm: Enforces both position constraints $g(q_{n+1})=0$ and velocity constraints $J(q_{n+1})\\dot{q}_{n+1}=0$.\n- Kinetic Temperature: To be understood in the constrained sense, i.e., associated with velocity components tangent to the constraint manifold.\n- Assumptions: Time step $\\Delta t$ is small, potential $U(q)$ is smooth, and initial conditions satisfy $g(q_0)=0$ and $J(q_0)\\dot{q}_0=0$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is scientifically sound and well-posed. It describes a standard problem in the field of computational physics and chemistry concerning the numerical integration of constrained Hamiltonian systems. All terms like holonomic constraints, Lagrange multipliers, SHAKE, and RATTLE are standard in this context. The equations of motion are the correct formulation for a classical system under such constraints. The question is objective and requires a rigorous analysis of the properties of these well-known algorithms. The problem provides all necessary information and contains no internal contradictions, factual errors, or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed with a detailed derivation and analysis.\n\n### 2. Derivation and Analysis\n\n**2.1. Continuous Dynamics and Constraints**\nIn the continuous phase space, the holonomic constraints $g(q)=0$ imply that velocities must be tangent to the constraint manifold. Differentiating the constraint equation with respect to time gives the velocity constraint:\n$$\n\\frac{d}{dt} g(q(t)) = \\frac{\\partial g}{\\partial q} \\frac{dq}{dt} = J(q) \\dot{q} = 0\n$$\nThe constraint force is given by $F_c = J(q)^{\\top}\\lambda$. This force is, by construction, in the direction of the gradient of the constraint functions, and is therefore normal to the constraint manifold at point $q$. The power, or work rate, of the constraint force is:\n$$\nP_c = F_c \\cdot \\dot{q} = (J(q)^{\\top}\\lambda)^{\\top} \\dot{q} = \\lambda^{\\top} (J(q)\\dot{q})\n$$\nSince $J(q)\\dot{q}=0$ for the exact continuous trajectory, it follows that $P_c=0$. The constraint forces do no work, and the total energy $E = \\frac{1}{2}\\dot{q}^{\\top}M\\dot{q} + U(q)$ is exactly conserved.\n\n**2.2. Discretized Dynamics: Velocity Verlet**\nThe velocity Verlet algorithm for unconstrained motion proceeds in two steps:\n1. First velocity half-step: $\\dot{q}_{n+1/2} = \\dot{q}_n + \\frac{\\Delta t}{2}M^{-1}F(q_n)$\n2. Position full-step: $q_{n+1} = q_n + \\Delta t \\dot{q}_{n+1/2}$\n3. Second velocity half-step: $\\dot{q}_{n+1} = \\dot{q}_{n+1/2} + \\frac{\\Delta t}{2}M^{-1}F(q_{n+1})$\nwhere $F(q) = -\\nabla U(q)$. This algorithm is symplectic and time-reversible, leading to excellent long-term energy conservation (bounded, oscillatory error) for Hamiltonian systems.\n\n**2.3. Analysis of the SHAKE-only approach**\nWhen incorporating constraints via SHAKE into the velocity Verlet scheme, the primary modification is to enforce $g(q_{n+1})=0$. A common implementation is as follows:\n1. Compute an unconstrained position update: $q_{n+1}^* = q_n + \\Delta t \\dot{q}_n + \\frac{\\Delta t^2}{2}M^{-1}F(q_n)$.\n2. Correct the positions iteratively to find $q_{n+1}$ such that $g(q_{n+1})=0$. This correction is equivalent to applying an impulsive constraint force.\n3. Update the velocities, for instance, using a finite difference like $\\dot{q}_{n+1} = (q_{n+1} - q_{n-1})/(2\\Delta t)$ (Störmer-Verlet form) or via the VV scheme where the force at the corrected position $q_{n+1}$ is used.\nThe problem statement describes a SHAKE-like procedure applied to VV where only position constraints are enforced. Critically, after the position $q_{n+1}$ is projected onto the constraint manifold, the velocity $\\dot{q}_{n+1}$ is calculated without a corresponding projection. This means that, in general, the final velocity vector is not tangent to the constraint manifold, i.e., $J(q_{n+1})\\dot{q}_{n+1} \\neq 0$.\n\nThis non-tangential velocity implies that the discrete equivalent of the work done by the constraint force is non-zero. The constraint correction effectively changes the energy of the system at each step. Because the underlying algorithm's symplectic structure is broken by the position-only projection, these energy changes do not average out to zero over many steps. Instead, they typically accumulate, leading to a systematic drift (usually an increase) in the total energy. This is a well-known deficiency of applying SHAKE without a corresponding velocity correction.\n\n**2.4. Analysis of the RATTLE approach**\nRATTLE is specifically designed to remedy the shortcomings of SHAKE when used with velocity-based integrators like VV. It enforces both the position and velocity constraints at the end of each time step. The algorithm can be formulated as:\n1. First velocity half-step (unconstrained): $\\dot{q}_{n+1/2} = \\dot{q}_n + \\frac{\\Delta t}{2} M^{-1} F(q_n)$.\n2. Position full-step with constraint: Solve for $q_{n+1}$ and multipliers $\\lambda_p$ such that $q_{n+1} = q_n + \\Delta t \\dot{q}_{n+1/2}$ and $g(q_{n+1}) = 0$. This is the \"SHAKE\" part of the step, which corrects the positions.\n3. Second velocity half-step with constraint: First, compute a trial velocity $\\dot{q}_{n+1}^{*} = \\dot{q}_{n+1/2} + \\frac{\\Delta t}{2} M^{-1} F(q_{n+1})$. Then, solve for the final velocity $\\dot{q}_{n+1}$ and multipliers $\\lambda_v$ such that $\\dot{q}_{n+1} = \\dot{q}_{n+1}^{*} - M^{-1}J(q_{n+1})^\\top\\lambda_v$ and the velocity constraint $J(q_{n+1})\\dot{q}_{n+1}=0$ is satisfied.\n\nBy explicitly enforcing $J(q_{n+1})\\dot{q}_{n+1}=0$, RATTLE ensures that the velocity vector at the end of the step is tangent to the constraint manifold. This means the constraint force (which is normal to the manifold) is always orthogonal to the velocity. Consequently, the constraint force does no work, even in the discrete sense. The RATTLE algorithm preserves the time-reversibility and symplectic nature of the underlying integrator. For a time-independent Hamiltonian, this guarantees that the total energy error does not exhibit secular drift, but instead remains bounded and oscillates around a constant value, which is a hallmark of high-quality geometric integrators.\n\n**2.5. Analysis of Kinetic Temperature**\nThe kinetic temperature $T$ of a system is related to the average kinetic energy per degree of freedom. For a constrained system, the number of degrees of freedom is reduced from $3N$ to $N_{dof} = 3N-m$. The motion is restricted to the constraint manifold, so the physically relevant kinetic energy is that associated with the velocity components tangent to this manifold. Let $\\dot{q}_{tan}$ be the projection of the velocity $\\dot{q}$ onto the tangent space. The correct constrained kinetic energy is $K_{tan} = \\frac{1}{2}\\dot{q}_{tan}^{\\top}M\\dot{q}_{tan}$, and the temperature is given by $\\langle K_{tan} \\rangle = \\frac{1}{2}N_{dof} k_B T$.\n\n- **RATTLE**: As established, RATTLE ensures $\\dot{q}_{n+1}$ is tangent to the constraint manifold, so $\\dot{q}_{n+1} = \\dot{q}_{tan, n+1}$. Therefore, computing the kinetic energy directly from the output velocities $\\frac{1}{2}\\dot{q}_{n+1}^{\\top}M\\dot{q}_{n+1}$ gives the correct tangential kinetic energy. The resulting kinetic temperature is an unbiased measure consistent with the equipartition principle over the available $N_{dof}$ degrees of freedom.\n\n- **SHAKE-only**: The velocity $\\dot{q}_{n+1}$ has a non-zero component normal to the constraint manifold, $\\dot{q}_{norm, n+1}$. The total kinetic energy calculated from the unprojected velocity is $K_{unproj} = \\frac{1}{2}(\\dot{q}_{tan, n+1}+\\dot{q}_{norm, n+1})^{\\top}M(\\dot{q}_{tan, n+1}+\\dot{q}_{norm, n+1}) \\approx K_{tan} + K_{norm}$, where $K_{norm} = \\frac{1}{2}\\dot{q}_{norm, n+1}^{\\top}M\\dot{q}_{norm, n+1}$. Since $K_{norm} > 0$, the kinetic energy calculated from the unprojected velocities is systematically larger than the true tangential kinetic energy. This leads to a systematic overestimation, or positive bias, in the computed kinetic temperature.\n\n### 3. Evaluation of Options\n\n**A. For velocity Verlet with constraints, if only position constraints are enforced (SHAKE-only), the discrete constraint force can perform nonzero work because $J(q_{n+1})\\dot{q}_{n+1}\\neq 0$ at finite $\\Delta t$, leading to a systematic drift in the total energy over long times. In contrast, full RATTLE enforces $J(q_{n+1})\\dot{q}_{n+1}=0$ and yields bounded, oscillatory energy error characteristic of symplectic, time-reversible integration rather than secular drift.**\nThis statement is a precise summary of our analysis. The failure of SHAKE-only to enforce the velocity constraint leads to non-zero work by the discrete constraint force and energy drift. RATTLE corrects this, restoring the geometric properties (symplecticity, time-reversibility) that lead to bounded energy error.\n**Verdict: Correct.**\n\n**B. The constrained kinetic temperature computed from unprojected velocities and divided by the number of unconstrained degrees of freedom is, in long-time average, identical for SHAKE-only and RATTLE, because position constraints alone are sufficient to eliminate spurious velocity components along constrained directions.**\nThis statement is incorrect. As analyzed, the unprojected velocities in SHAKE-only contain spurious components normal to the constraint manifold, leading to an overestimation of the kinetic temperature. The reasoning provided is also false; position constraints alone are *not* sufficient to eliminate these spurious velocity components. Therefore, the average temperature from SHAKE-only would be higher than that from RATTLE.\n**Verdict: Incorrect.**\n\n**C. The RATTLE corrections introduce effective damping into the velocity Verlet scheme, reducing the total energy over time compared to SHAKE-only, even in the absence of any thermostat, because Lagrange multipliers always remove energy associated with constrained motion.**\nThis statement is incorrect. RATTLE is a conservative, time-reversible algorithm, not a dissipative one. \"Damping\" implies a systematic loss of energy, which would violate time-reversibility. RATTLE prevents upward energy drift, but it does not cause a systematic decrease. The energy error oscillates. While its average energy might be lower than a SHAKE simulation with upward drift, the mechanism is not damping. The reason provided, that multipliers \"always remove energy,\" is an inaccurate generalization.\n**Verdict: Incorrect.**\n\n**D. The correct constrained kinetic temperature is defined from the kinetic energy associated with velocity components tangent to the constraint manifold; imposing velocity constraints in RATTLE ensures $J(q_{n+1})\\dot{q}_{n+1}=0$, so the measured kinetic temperature is unbiased and consistent with equipartition over the unconstrained degrees of freedom. Under SHAKE-only, if one uses unprojected velocities, spurious normal components can produce a bias in the reported constrained kinetic temperature.**\nThis statement is fully consistent with our analysis. It correctly defines the constrained kinetic temperature and accurately describes why RATTLE provides an unbiased measurement while SHAKE-only with unprojected velocities leads to a biased (overestimated) measurement.\n**Verdict: Correct.**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "This final practice moves from theory to a hands-on computational experiment, addressing a critical issue in the practical application of iterative constraint solvers. You will investigate how molecular topology—specifically the presence of loops and near-collinear arrangements—can lead to ill-conditioned linear systems, slowing down or preventing solver convergence. By implementing a Gauss-Seidel solver and testing it on various molecular graphs, you will gain a practical understanding of the numerical stability challenges inherent in constraint algorithms. ",
            "id": "3439810",
            "problem": "In constrained molecular dynamics, holonomic bond-length constraints are enforced by solving for Lagrange multipliers within each time step of an integrator such as the SHAKE algorithm (which enforces constraints on positions) or the RATTLE algorithm (which enforces constraints on positions and velocities). Consider a set of $N$ point particles with masses $\\{m_a\\}_{a=1}^{N}$ at positions $\\{\\mathbf{r}_a\\}_{a=1}^{N}$ in three-dimensional space. A set of $K$ scalar holonomic constraints is defined from a molecular graph, where each constraint $k$ is a fixed distance between two particles $(i_k,j_k)$, represented as $c_k(\\mathbf{r}) = \\lVert \\mathbf{r}_{i_k} - \\mathbf{r}_{j_k} \\rVert^2 - d_{i_k j_k}^2 = 0$. The gradient of constraint $k$ with respect to particle $a$ is $\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})$, which is nonzero only if $a \\in \\{i_k, j_k\\}$, and equals $2(\\mathbf{r}_{i_k} - \\mathbf{r}_{j_k})$ for $a=i_k$ and $-2(\\mathbf{r}_{i_k} - \\mathbf{r}_{j_k})$ for $a=j_k$. Define the constraint Jacobian $G(\\mathbf{r}) \\in \\mathbb{R}^{K \\times 3N}$ with rows $g_k^\\top$ collecting these gradients, and the diagonal mass matrix $M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3) \\in \\mathbb{R}^{3N \\times 3N}$, where $I_3$ is the $3 \\times 3$ identity matrix. The symmetric matrix $A(\\mathbf{r}) \\in \\mathbb{R}^{K \\times K}$ that couples the constraints is given by $A(\\mathbf{r}) = G(\\mathbf{r}) M^{-1} G(\\mathbf{r})^\\top$, with entries\n$$\nA_{kl}(\\mathbf{r}) = \\sum_{a=1}^{N} \\left(\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})\\right)^\\top \\left(m_a^{-1} I_3\\right) \\left(\\nabla_{\\mathbf{r}_a} c_l(\\mathbf{r})\\right).\n$$\nWhen the constraints form multiple closed loops or are nearly linearly dependent, $A(\\mathbf{r})$ can be ill-conditioned (near-singular). To enforce constraints in SHAKE or RATTLE, one solves a linear system $A(\\mathbf{r}) \\, \\boldsymbol{\\lambda} = \\mathbf{b}$ for the Lagrange multipliers $\\boldsymbol{\\lambda} \\in \\mathbb{R}^K$, where $\\mathbf{b} \\in \\mathbb{R}^K$ depends on the current constraint violations and integration details. The Gauss–Seidel iterative method for solving linear systems updates $\\boldsymbol{\\lambda}$ sequentially using the lower-triangular part of $A(\\mathbf{r})$, and its convergence rate deteriorates as the condition number of $A(\\mathbf{r})$ increases.\n\nYour task is to write a complete, runnable program that constructs several molecular graphs and their corresponding $A(\\mathbf{r})$ matrices from first principles and empirically determines, for each case, a lower bound on the number of Gauss–Seidel iterations needed to reduce the relative residual norm below a specified tolerance $\\epsilon$. Concretely:\n\n- Use the following fundamental definitions and facts only:\n  - Newtonian mechanics with holonomic constraints and the Lagrange multiplier formalism.\n  - The constraint Jacobian $G(\\mathbf{r})$ formed from gradients of $c_k(\\mathbf{r})$.\n  - The mass-weighted coupling $A(\\mathbf{r}) = G(\\mathbf{r}) M^{-1} G(\\mathbf{r})^\\top$.\n  - The Gauss–Seidel iteration for solving $A \\boldsymbol{\\lambda} = \\mathbf{b}$, initialized at $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$, which updates each component $\\lambda_i$ in sequence using the most recent values.\n  - The relative residual at iteration $t$ is $\\rho^{(t)} = \\lVert \\mathbf{b} - A \\boldsymbol{\\lambda}^{(t)} \\rVert_2 / \\lVert \\mathbf{b} \\rVert_2$.\n\n- For every test instance, define the right-hand side as the constant vector $\\mathbf{b} = (1, 1, \\dots, 1)^\\top \\in \\mathbb{R}^K$.\n\n- For every test instance, use all masses $m_a$ equal to $1$ unless otherwise stated.\n\n- Implement Gauss–Seidel with the standard forward sweep update\n  $$\n  \\lambda_i^{(t+1)} \\leftarrow \\frac{1}{A_{ii}} \\left(b_i - \\sum_{j=1}^{i-1} A_{ij} \\lambda_j^{(t+1)} - \\sum_{j=i+1}^{K} A_{ij} \\lambda_j^{(t)} \\right),\n  $$\n  and stop at the smallest iteration index $T$ such that $\\rho^{(T)} \\le \\epsilon$. This $T$ is the requested empirical lower bound.\n\n- If convergence is not reached within $10^5$ iterations, stop and return the achieved iteration count $10^5$ for that test.\n\nConstruct the following test suite. Each test instance is specified by particle positions, a set of pairwise distance constraints, the mass vector if not all equal to $1$, and the tolerance $\\epsilon$. There are no physical units in this problem; all quantities are nondimensional.\n\n- Test $1$ (trivial, single constraint):\n  - Particles: $N=2$ with positions $\\mathbf{r}_0 = (0, 0, 0)$, $\\mathbf{r}_1 = (1, 0, 0)$.\n  - Constraints: $K=1$ with edge $(0,1)$.\n  - Masses: all $1$.\n  - Tolerance: $\\epsilon = 10^{-12}$.\n\n- Test $2$ (single ring with closed loop):\n  - Particles: $N=6$ arranged on a unit circle in the $xy$-plane at angles $2\\pi i / 6$ for $i \\in \\{0,1,2,3,4,5\\}$, i.e., $\\mathbf{r}_i = (\\cos(2\\pi i/6), \\sin(2\\pi i/6), 0)$.\n  - Constraints: $K=6$ edges forming a ring $(i, (i+1) \\bmod 6)$ for $i \\in \\{0,1,2,3,4,5\\}$.\n  - Masses: all $1$.\n  - Tolerance: $\\epsilon = 10^{-8}$.\n\n- Test $3$ (ring with an added chord increasing loop connectivity):\n  - Particles: as in Test $2$.\n  - Constraints: the $6$ ring edges plus one chord $(0,3)$, so $K=7$.\n  - Masses: all $1$.\n  - Tolerance: $\\epsilon = 10^{-8}$.\n\n- Test $4$ (nearly singular triple-constraint triangle, almost collinear):\n  - Particles: $N=3$ with positions $\\mathbf{r}_0 = (0, 0, 0)$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{r}_2 = (2, 10^{-6}, 0)$.\n  - Constraints: $K=3$ with edges $(0,1)$, $(1,2)$, $(0,2)$.\n  - Masses: all $1$.\n  - Tolerance: $\\epsilon = 10^{-12}$.\n\n- Test $5$ (linear chain, tridiagonal coupling):\n  - Particles: $N=4$ with positions $\\mathbf{r}_0 = (0, 0, 0)$, $\\mathbf{r}_1 = (1, 0, 0)$, $\\mathbf{r}_2 = (2, 0, 0)$, $\\mathbf{r}_3 = (3, 0, 0)$.\n  - Constraints: $K=3$ with edges $(0,1)$, $(1,2)$, $(2,3)$.\n  - Masses: all $1$.\n  - Tolerance: $\\epsilon = 10^{-10}$.\n\nYour program must:\n\n- Construct $A(\\mathbf{r})$ explicitly from the gradients and masses.\n- Run Gauss–Seidel starting from $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$ and compute the smallest $T$ such that $\\rho^{(T)} \\le \\epsilon$ for each test.\n- Aggregate the results for the five tests into a single line of output in the exact format of a Python list of integers, for example, $[T_1,T_2,T_3,T_4,T_5]$ with no spaces after commas.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\").",
            "solution": "The problem requires the implementation of a procedure to empirically determine the number of Gauss–Seidel iterations required for convergence when solving for Lagrange multipliers in a constrained molecular dynamics context. This involves two main steps: first, constructing the constraint coupling matrix $A(\\mathbf{r})$ from the geometry and topology of a molecular system; and second, applying an iterative solver to the resulting linear system.\n\nThe core of the problem lies in the formalism of holonomic constraints. A set of $K$ constraints is given by $c_k(\\mathbf{r}) = 0$ for $k=1, \\dots, K$. For this problem, the constraints are pairwise distances, $c_k(\\mathbf{r}) = \\lVert \\mathbf{r}_{i_k} - \\mathbf{r}_{j_k} \\rVert^2 - d_{i_k j_k}^2 = 0$. In algorithms like SHAKE or RATTLE, the constraint forces required to satisfy these conditions are proportional to the gradients of the constraints, $\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})$. The coefficients of proportionality are the Lagrange multipliers, $\\lambda_k$.\n\nThe relationship between constraint violations and the required multipliers is encapsulated in a linear system $A(\\mathbf{r})\\boldsymbol{\\lambda} = \\mathbf{b}$, where $A(\\mathbf{r})$ is a symmetric $K \\times K$ matrix. The matrix $A(\\mathbf{r})$ is defined as $A(\\mathbf{r}) = G(\\mathbf{r}) M^{-1} G(\\mathbf{r})^\\top$, where $G(\\mathbf{r})$ is the $K \\times 3N$ constraint Jacobian matrix whose rows are the flattened gradients of each constraint with respect to all particle coordinates, and $M$ is the $3N \\times 3N$ diagonal mass matrix. An element $A_{kl}$ of this matrix represents the coupling between constraint $k$ and constraint $l$ through the mass-weighted mobility of the particles.\n\nThe explicit formula for an entry $A_{kl}$ is given as:\n$$\nA_{kl}(\\mathbf{r}) = \\sum_{a=1}^{N} \\frac{1}{m_a} \\left(\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r})\\right)^\\top \\left(\\nabla_{\\mathbf{r}_a} c_l(\\mathbf{r})\\right)\n$$\nThe gradient of a constraint $c_k(\\mathbf{r})$ between particles $i_k$ and $j_k$ is non-zero only for these two particles. Let $\\mathbf{d}_k = \\mathbf{r}_{i_k} - \\mathbf{r}_{j_k}$. The gradients are:\n$$\n\\nabla_{\\mathbf{r}_a} c_k(\\mathbf{r}) = \n\\begin{cases} \n2\\mathbf{d}_k & \\text{if } a = i_k \\\\\n-2\\mathbf{d}_k & \\text{if } a = j_k \\\\\n\\mathbf{0} & \\text{otherwise}\n\\end{cases}\n$$\nThe sum for $A_{kl}$ therefore only includes terms for particles that are common to both constraint $k$ (involving particles $i_k, j_k$) and constraint $l$ (involving $i_l, j_l$).\n\nLet us analyze the structure of $A_{kl}$:\n1.  **Diagonal elements ($k=l$):** The constraint is coupled with itself. The particles involved are $i_k$ and $j_k$.\n    $$\n    A_{kk} = \\frac{1}{m_{i_k}}(\\nabla_{\\mathbf{r}_{i_k}} c_k)^\\top(\\nabla_{\\mathbf{r}_{i_k}} c_k) + \\frac{1}{m_{j_k}}(\\nabla_{\\mathbf{r}_{j_k}} c_k)^\\top(\\nabla_{\\mathbf{r}_{j_k}} c_k)\n    $$\n    $$\n    A_{kk} = \\frac{1}{m_{i_k}}(2\\mathbf{d}_k)^\\top(2\\mathbf{d}_k) + \\frac{1}{m_{j_k}}(-2\\mathbf{d}_k)^\\top(-2\\mathbf{d}_k) = 4\\lVert \\mathbf{d}_k \\rVert^2 \\left( \\frac{1}{m_{i_k}} + \\frac{1}{m_{j_k}} \\right)\n    $$\n2.  **Off-diagonal elements ($k \\neq l$):** The coupling depends on shared particles. The sum is over atoms $a \\in \\{i_k, j_k\\} \\cap \\{i_l, j_l\\}$. For each such shared atom $a$, we add a term $\\frac{1}{m_a} (\\nabla_{\\mathbf{r}_a} c_k) \\cdot (\\nabla_{\\mathbf{r}_a} c_l)$. For example, if the constraints share exactly one particle, say $i_k = i_l = a$, and particles $j_k, j_l$ are distinct, the term is:\n    $$\n    A_{kl} = \\frac{1}{m_a}(\\nabla_{\\mathbf{r}_a} c_k)^\\top(\\nabla_{\\mathbf{r}_a} c_l) = \\frac{1}{m_a}(2\\mathbf{d}_k)^\\top(2\\mathbf{d}_l) = \\frac{4}{m_a} \\mathbf{d}_k \\cdot \\mathbf{d}_l\n    $$\n    If one constraint involves atom $a$ as its first particle ($i_k=a$) and the other as its second ($j_l=a$), the sign flips:\n    $$\n    A_{kl} = \\frac{1}{m_a}(2\\mathbf{d}_k)^\\top(-2\\mathbf{d}_l) = -\\frac{4}{m_a} \\mathbf{d}_k \\cdot \\mathbf{d}_l\n    $$\n    A general implementation will sum over all four possible sign combinations depending on which role the shared atom plays in each constraint.\n\nOnce the matrix $A$ is constructed for a given system, we solve the linear system $A\\boldsymbol{\\lambda} = \\mathbf{b}$ using the Gauss–Seidel method. Given an initial guess $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$, the method iteratively updates each component $\\lambda_i$ for $i=1, \\dots, K$ as:\n$$\n\\lambda_i^{(t+1)} = \\frac{1}{A_{ii}} \\left(b_i - \\sum_{j=1}^{i-1} A_{ij} \\lambda_j^{(t+1)} - \\sum_{j=i+1}^{K} A_{ij} \\lambda_j^{(t)} \\right)\n$$\nThe iteration proceeds for $t=0, 1, 2, \\dots$ until the relative residual norm $\\rho^{(t)} = \\lVert \\mathbf{b} - A \\boldsymbol{\\lambda}^{(t)} \\rVert_2 / \\lVert \\mathbf{b} \\rVert_2$ falls below a specified tolerance $\\epsilon$. The number of iterations $T$ required to achieve this is the desired output. For this problem, $\\mathbf{b}$ is a vector of ones. The process is repeated for each of the five test configurations, which are designed to probe different conditioning properties of the matrix $A$, from a trivial single constraint to a nearly singular system arising from close-to-collinear geometry.\n\nThe implementation will consist of a primary function that iterates through the test cases. For each case, it will:\n1.  Initialize the particle positions, masses, and constraint definitions.\n2.  Call a subroutine to construct the $K \\times K$ matrix $A$ using the derived formulae.\n3.  Call a second subroutine to execute the Gauss–Seidel iteration, starting from $\\boldsymbol{\\lambda}^{(0)} = \\mathbf{0}$ and using $\\mathbf{b} = (1, \\dots, 1)^\\top$, counting iterations until the convergence criterion $\\rho^{(T)} \\leq \\epsilon$ is met or a maximum of $10^5$ iterations is reached.\n4.  Store the resulting iteration count $T$.\nFinally, all computed iteration counts will be collected and formatted into the required output string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_A(positions, constraints, masses):\n    \"\"\"\n    Constructs the A matrix from particle positions, constraints, and masses.\n\n    Args:\n        positions (np.ndarray): (N, 3) array of particle positions.\n        constraints (list of tuples): List of K constraints, each a tuple (i, j) of particle indices.\n        masses (np.ndarray): (N,) array of particle masses.\n\n    Returns:\n        np.ndarray: The (K, K) symmetric matrix A.\n    \"\"\"\n    K = len(constraints)\n    A = np.zeros((K, K))\n\n    # Pre-calculate difference vectors for all constraints\n    d_vectors = []\n    for i_k, j_k in constraints:\n        d_vectors.append(positions[i_k] - positions[j_k])\n    d_vectors = np.array(d_vectors)\n\n    for k in range(K):\n        for l in range(k, K):\n            i_k, j_k = constraints[k]\n            i_l, j_l = constraints[l]\n\n            d_k = d_vectors[k]\n            d_l = d_vectors[l]\n\n            # Find common particles between constraint k and l\n            common_particles = set([i_k, j_k]) & set([i_l, j_l])\n            \n            sum_term = 0.0\n            for a in common_particles:\n                # Determine sign for gradient based on atom's role in constraint\n                sign_k = 1 if a == i_k else -1\n                sign_l = 1 if a == i_l else -1\n                \n                # Gradients are (sign * 2 * d), so dot product is (4 * sign_k * sign_l * d_k . d_l)\n                term = (4.0 * sign_k * sign_l * np.dot(d_k, d_l)) / masses[a]\n                sum_term += term\n\n            A[k, l] = sum_term\n            if k != l:\n                A[l, k] = sum_term\n    \n    return A\n\ndef gauss_seidel(A, b, epsilon, max_iter):\n    \"\"\"\n    Solves Ax = b using the Gauss-Seidel method.\n\n    Args:\n        A (np.ndarray): The matrix A.\n        b (np.ndarray): The vector b.\n        epsilon (float): The tolerance for the relative residual norm.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        int: The number of iterations performed.\n    \"\"\"\n    K = len(b)\n    lambdas = np.zeros(K)\n    \n    norm_b = np.linalg.norm(b)\n    if norm_b == 0:\n        return 0\n\n    for t in range(max_iter):\n        lambdas_old = np.copy(lambdas)\n        for i in range(K):\n            # Sum over j < i using newly computed lambda values\n            sigma1 = np.dot(A[i, :i], lambdas[:i])\n            # Sum over j > i using old lambda values\n            sigma2 = np.dot(A[i, i + 1:], lambdas_old[i + 1:])\n            \n            if A[i, i] == 0: # Avoid division by zero, though A should be positive definite\n                return max_iter\n                \n            lambdas[i] = (b[i] - sigma1 - sigma2) / A[i, i]\n\n        # Check for convergence\n        residual = b - A @ lambdas\n        rel_residual_norm = np.linalg.norm(residual) / norm_b\n        \n        if rel_residual_norm <= epsilon:\n            return t + 1\n            \n    return max_iter\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    max_iterations = 100000\n\n    test_cases = [\n        # Test 1 (trivial, single constraint)\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]]),\n            \"constraints\": [(0, 1)],\n            \"masses\": np.array([1.0, 1.0]),\n            \"epsilon\": 1e-12\n        },\n        # Test 2 (single ring with closed loop)\n        {\n            \"positions\": np.array([\n                [np.cos(2 * np.pi * i / 6), np.sin(2 * np.pi * i / 6), 0.0]\n                for i in range(6)\n            ]),\n            \"constraints\": [(i, (i + 1) % 6) for i in range(6)],\n            \"masses\": np.ones(6),\n            \"epsilon\": 1e-8\n        },\n        # Test 3 (ring with an added chord)\n        {\n            \"positions\": np.array([\n                [np.cos(2 * np.pi * i / 6), np.sin(2 * np.pi * i / 6), 0.0]\n                for i in range(6)\n            ]),\n            \"constraints\": [(i, (i + 1) % 6) for i in range(6)] + [(0, 3)],\n            \"masses\": np.ones(6),\n            \"epsilon\": 1e-8\n        },\n        # Test 4 (nearly singular triple-constraint triangle)\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 1e-6, 0.0]]),\n            \"constraints\": [(0, 1), (1, 2), (0, 2)],\n            \"masses\": np.ones(3),\n            \"epsilon\": 1e-12\n        },\n        # Test 5 (linear chain, tridiagonal coupling)\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0], [3.0, 0.0, 0.0]]),\n            \"constraints\": [(0, 1), (1, 2), (2, 3)],\n            \"masses\": np.ones(4),\n            \"epsilon\": 1e-10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = build_A(case[\"positions\"], case[\"constraints\"], case[\"masses\"])\n        K = len(case[\"constraints\"])\n        b = np.ones(K)\n        iterations = gauss_seidel(A, b, case[\"epsilon\"], max_iterations)\n        results.append(iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}