{
    "hands_on_practices": [
        {
            "introduction": "A fundamental prerequisite for any molecular dynamics simulation is numerical stability. This exercise connects the abstract theory of stability to the physical properties of a material by tasking you with determining the maximum stable time step, $\\Delta t_{\\max}$, for the velocity Verlet algorithm. By analyzing the fastest vibrational mode in a system, you will derive the stability condition and learn the essential skill of choosing a $\\Delta t$ that prevents the simulation from becoming unphysically divergent .",
            "id": "3497060",
            "problem": "A covalent solid composed of a hydrogenated graphene sheet is modeled for Molecular Dynamics (MD) with atoms interacting via harmonic bond-stretch potentials. The dominant stretching bonds are carbon–hydrogen and carbon–carbon with experimentally determined bond-stretching stiffnesses $k_{\\mathrm{C-H}} = 1.60 \\times 10^{3}\\ \\mathrm{N/m}$ and $k_{\\mathrm{C-C}} = 1.20 \\times 10^{3}\\ \\mathrm{N/m}$. The atomic masses are $m_{\\mathrm{H}} = 1.00784\\ \\mathrm{u}$ and $m_{\\mathrm{C}} = 12.0107\\ \\mathrm{u}$, where $1\\ \\mathrm{u} = 1.66053906660 \\times 10^{-27}\\ \\mathrm{kg}$. Assume that the stiffest vibrational mode is well-approximated by the harmonic motion of the light atom bonded by the stiffest spring, and estimate the maximum angular frequency as $\\omega_{\\max} = \\sqrt{k/m}$ using the stiffness of the stiffest bond and the mass of the lighter atom it binds.\n\nStarting from Newton’s second law applied to a harmonic potential and the discrete update equations of the velocity Verlet algorithm, derive the linear stability condition for the time step $\\Delta t$ in terms of the angular frequency $\\omega$ for the harmonic oscillator. Use this to compute the largest stable time step for velocity Verlet for the stiffest mode identified above. Express the final time step in femtoseconds, using $1\\ \\mathrm{fs} = 10^{-15}\\ \\mathrm{s}$, and round your answer to four significant figures.",
            "solution": "### Derivation of the Stability Condition\n\nThe non-dimensional motion of a one-dimensional harmonic oscillator is described by Newton's second law:\n$$ \\frac{d^2x}{dt^2} = -\\omega^2 x $$\nwhere $\\omega = \\sqrt{k/m}$ is the angular frequency, $x$ is the displacement from equilibrium, $k$ is the spring constant, and $m$ is the mass. The acceleration is $a(t) = -\\omega^2 x(t)$.\n\nThe velocity Verlet algorithm consists of the following update steps for position $x$ and velocity $v$ over a time step $\\Delta t$:\n$$ x(t+\\Delta t) = x(t) + v(t) \\Delta t + \\frac{1}{2} a(t) (\\Delta t)^2 $$\n$$ v(t+\\Delta t) = v(t) + \\frac{1}{2} [a(t) + a(t+\\Delta t)] \\Delta t $$\n\nLet $x_n = x(n\\Delta t)$, $v_n = v(n\\Delta t)$, and $a_n = a(n\\Delta t)$. The equations in discrete form are:\n$$ x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2 $$\n$$ v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t $$\n\nFor the harmonic oscillator, $a_n = -\\omega^2 x_n$ and $a_{n+1} = -\\omega^2 x_{n+1}$. Substituting these into the update rules:\n$$ x_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 $$\n$$ v_{n+1} = v_n - \\frac{1}{2} \\omega^2 (x_n + x_{n+1}) \\Delta t $$\n\nWe can write this as a matrix transformation for the state vector $\\mathbf{z}_n = \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$. First, we express $x_{n+1}$ and $v_{n+1}$ solely in terms of $x_n$ and $v_n$.\nThe equation for $x_{n+1}$ is already in the desired form:\n$$ x_{n+1} = \\left(1 - \\frac{1}{2} (\\omega \\Delta t)^2\\right) x_n + (\\Delta t) v_n $$\nNow substitute this expression for $x_{n+1}$ into the equation for $v_{n+1}$:\n$$ v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[x_n + \\left(x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2\\right)\\right] $$\n$$ v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[2x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2\\right] $$\n$$ v_{n+1} = v_n - \\omega^2 \\Delta t x_n - \\frac{1}{2} (\\omega \\Delta t)^2 v_n + \\frac{1}{4} \\omega^4 (\\Delta t)^3 x_n $$\n$$ v_{n+1} = \\left[-\\omega^2 \\Delta t \\left(1 - \\frac{1}{4} (\\omega \\Delta t)^2\\right)\\right] x_n + \\left(1 - \\frac{1}{2} (\\omega \\Delta t)^2\\right) v_n $$\n\nThe system can be written in matrix form, $\\mathbf{z}_{n+1} = \\mathbf{A} \\mathbf{z}_n$, where $\\mathbf{A}$ is the amplification matrix:\n$$ \\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{2}(\\omega \\Delta t)^2  \\Delta t \\\\ -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}(\\omega \\Delta t)^2\\right)  1 - \\frac{1}{2}(\\omega \\Delta t)^2 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix} $$\nFor the algorithm to be stable, the magnitudes of the eigenvalues $\\lambda$ of the amplification matrix $\\mathbf{A}$ must be less than or equal to $1$. The eigenvalues are found by solving the characteristic equation $\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$.\n$$ \\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2 - \\lambda\\right)^2 + \\Delta t \\left(\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}(\\omega \\Delta t)^2\\right)\\right) = 0 $$\n$$ \\lambda^2 - 2\\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2\\right)\\lambda + \\left(1 - \\frac{1}{2}(\\omega \\Delta t)^2\\right)^2 + (\\omega \\Delta t)^2 \\left(1 - \\frac{1}{4}(\\omega \\Delta t)^2\\right) = 0 $$\n$$ \\lambda^2 - \\left(2 - (\\omega \\Delta t)^2\\right)\\lambda + \\left(1 - (\\omega \\Delta t)^2 + \\frac{1}{4}(\\omega \\Delta t)^4\\right) + \\left((\\omega \\Delta t)^2 - \\frac{1}{4}(\\omega \\Delta t)^4\\right) = 0 $$\n$$ \\lambda^2 - \\left(2 - (\\omega \\Delta t)^2\\right)\\lambda + 1 = 0 $$\nThe solutions for $\\lambda$ are:\n$$ \\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(2 - (\\omega \\Delta t)^2)^2 - 4}}{2} = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm \\sqrt{\\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 - 1} $$\nFor stability, we require $|\\lambda| \\le 1$.\nIf the term inside the square root is non-positive, the eigenvalues are complex conjugates. The term is non-positive if:\n$$ \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 - 1 \\le 0 \\implies \\left|1 - \\frac{(\\omega \\Delta t)^2}{2}\\right| \\le 1 $$\nThis inequality expands to:\n$$ -1 \\le 1 - \\frac{(\\omega \\Delta t)^2}{2} \\le 1 $$\nThe right side, $1 - \\frac{(\\omega \\Delta t)^2}{2} \\le 1$, implies $-\\frac{(\\omega \\Delta t)^2}{2} \\le 0$, which is always true.\nThe left side, $-1 \\le 1 - \\frac{(\\omega \\Delta t)^2}{2}$, implies $\\frac{(\\omega \\Delta t)^2}{2} \\le 2$, which gives $(\\omega \\Delta t)^2 \\le 4$.\nThus, for complex eigenvalues, stability requires $(\\omega \\Delta t)^2 \\le 4$. In this case, the magnitude of the eigenvalues is:\n$$ |\\lambda|^2 = \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 + \\left(1 - \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2\\right) = 1 $$\nSo, $|\\lambda|=1$ for $(\\omega \\Delta t)^2 \\le 4$.\nIf $(\\omega \\Delta t)^2  4$, the eigenvalues are real and distinct. Let $X = \\frac{(\\omega \\Delta t)^2}{2}  2$. Then $\\lambda = (1-X) \\pm \\sqrt{(1-X)^2 - 1}$. Since $1-X  -1$, one eigenvalue will have magnitude greater than $1$: $\\lambda_{-} = (1-X) - \\sqrt{(1-X)^2 - 1}  -1$. This leads to an unstable trajectory.\nThe stability limit is therefore given by the boundary condition $(\\omega \\Delta t)^2 = 4$.\nThe linear stability condition for the velocity Verlet algorithm is:\n$$ \\omega \\Delta t \\le 2 $$\n\n### Calculation of the Maximum Stable Time Step\n\nThe largest stable time step, $\\Delta t_{\\max}$, is determined by the highest frequency mode in the system, $\\omega_{\\max}$:\n$$ \\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}} $$\nThe problem instructs to estimate $\\omega_{\\max}$ using $\\omega_{\\max} = \\sqrt{k/m}$ with the stiffest bond and the mass of the lighter atom.\nComparing the bond stiffnesses, $k_{\\mathrm{C-H}} = 1.60 \\times 10^{3}\\ \\mathrm{N/m}$ and $k_{\\mathrm{C-C}} = 1.20 \\times 10^{3}\\ \\mathrm{N/m}$, the stiffest bond is the C-H bond, so $k = k_{\\mathrm{C-H}}$.\nThe atoms in this bond are Carbon ($m_{\\mathrm{C}}$) and Hydrogen ($m_{\\mathrm{H}}$). The lighter atom is Hydrogen, so $m = m_{\\mathrm{H}}$.\n\nThe required values are:\n$k = 1.60 \\times 10^{3}\\ \\mathrm{N/m}$\n$m = m_{\\mathrm{H}} = 1.00784\\ \\mathrm{u}$\n\nFirst, convert the mass to SI units (kg):\n$m = 1.00784\\ \\mathrm{u} \\times (1.66053906660 \\times 10^{-27}\\ \\mathrm{kg/u})$\n$m \\approx 1.673533 \\times 10^{-27}\\ \\mathrm{kg}$\n\nNow, calculate $\\omega_{\\max}$:\n$$ \\omega_{\\max} = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{1.60 \\times 10^{3}\\ \\mathrm{N/m}}{1.673533 \\times 10^{-27}\\ \\mathrm{kg}}} $$\n$$ \\omega_{\\max} \\approx \\sqrt{9.56064 \\times 10^{29}\\ \\mathrm{s^{-2}}} \\approx 9.77785 \\times 10^{14}\\ \\mathrm{s^{-1}} $$\n\nFinally, calculate the maximum stable time step $\\Delta t_{\\max}$:\n$$ \\Delta t_{\\max} = \\frac{2}{\\omega_{\\max}} = \\frac{2}{9.77785 \\times 10^{14}\\ \\mathrm{s^{-1}}} $$\n$$ \\Delta t_{\\max} \\approx 2.04543 \\times 10^{-15}\\ \\mathrm{s} $$\n\nThe problem requires the answer in femtoseconds ($1\\ \\mathrm{fs} = 10^{-15}\\ \\mathrm{s}$), rounded to four significant figures.\n$$ \\Delta t_{\\max} \\approx 2.04543\\ \\mathrm{fs} $$\nRounding to four significant figures gives:\n$$ \\Delta t_{\\max} = 2.045\\ \\mathrm{fs} $$",
            "answer": "$$ \\boxed{2.045} $$"
        },
        {
            "introduction": "While stability prevents a simulation from failing, it does not guarantee accuracy. This practice moves beyond stability to the critical task of quantifying integrator performance through a hands-on coding exercise . You will implement the velocity Verlet integrator and measure three key diagnostics: the energy drift rate, the phase error, and the virial error, providing a comprehensive assessment of the algorithm's fidelity to physical conservation laws, temporal dynamics, and statistical mechanics.",
            "id": "3497051",
            "problem": "Consider a one-dimensional harmonic oscillator governed by Newton’s second law, where a particle of mass $m$ is attached to an ideal spring with stiffness $k$. The position $x(t)$ evolves under the force $f(x) = -k x$, with acceleration $a(t) = f(x)/m = -\\omega^{2} x$, where $\\omega = \\sqrt{k/m}$ is the angular frequency. The velocity is $v(t) = \\mathrm{d}x/\\mathrm{d}t$. Time integration is to be performed using the velocity Verlet method, derived from Taylor expansions and Newton’s second law without introducing any formulas externally.\n\nYour task is to implement a program that:\n- Integrates the trajectory using velocity Verlet for given parameters $(m, k, x_0, v_0, \\Delta t, N_{\\text{steps}})$, where $x_0$ is the initial position, $v_0$ is the initial velocity, $\\Delta t$ is the time step, and $N_{\\text{steps}}$ is the number of steps.\n- Computes the following performance diagnostics of the integrator over the trajectory:\n  1. Energy drift rate: Fit the total mechanical energy time series $E(t) = K(t) + U(t)$, where $K(t) = \\frac{1}{2} m v^{2}(t)$ and $U(t) = \\frac{1}{2} k x^{2}(t)$, to a straight line $E(t) \\approx \\alpha t + \\beta$ over the sampled times and return the slope $\\alpha$ as the energy drift rate. Express the energy drift rate in Joules per second (J/s).\n  2. Phase error at final time: For the harmonic oscillator, define the polar angle in phase space at time $t$ by $\\theta(t) = \\operatorname{atan2}\\!\\left(\\frac{v(t)}{\\omega}, x(t)\\right)$. Let $\\theta_{\\text{num}}(t_N)$ be the angle computed from the numerical trajectory at the final time $t_N = N_{\\text{steps}} \\Delta t$. Let $\\theta_{\\text{exact}}(t_N) = \\operatorname{atan2}\\!\\left(\\frac{v_0}{\\omega}, x_0\\right) + \\omega t_N$ be the exact harmonic oscillator phase at $t_N$. Compute the wrapped difference $\\Delta \\theta = \\mathrm{wrap}\\!\\left(\\theta_{\\text{num}}(t_N) - \\theta_{\\text{exact}}(t_N)\\right)$ to the interval $[-\\pi, \\pi]$, and report $|\\Delta \\theta|$ as the phase error. Express the phase error in radians.\n  3. Virial error: For a power-law potential $U \\propto r^n$, the classical virial theorem states that $2 \\langle K \\rangle = n \\langle U \\rangle$ at equilibrium, where angle brackets denote time averages. For the harmonic oscillator ($n = 2$), this reduces to $\\langle K \\rangle = \\langle U \\rangle$. Over the integrated trajectory, compute the time averages $\\langle K \\rangle$ and $\\langle U \\rangle$ and report the normalized virial error defined by $\\varepsilon_{\\mathrm{vir}} = \\frac{|\\langle K \\rangle - \\langle U \\rangle|}{\\langle E \\rangle}$, where $\\langle E \\rangle = \\langle K \\rangle + \\langle U \\rangle$. This metric is dimensionless.\n\nAll angles must be computed and reported in radians. All physical quantities must use International System of Units (SI): mass in kilograms (kg), stiffness in Newtons per meter (N/m), position in meters (m), velocity in meters per second (m/s), time in seconds (s), energy in Joules (J), and energy drift rate in Joules per second (J/s).\n\nDesign a program that, for the following test suite, integrates the trajectory and returns the three metrics for each case:\n- Test case $1$ (happy path): $(m, k, x_0, v_0, \\Delta t, N_{\\text{steps}}) = (1.0, 1.0, 1.0, 0.0, 0.05, 200)$.\n- Test case $2$ (near stability boundary for the integrator with large time step): $(m, k, x_0, v_0, \\Delta t, N_{\\text{steps}}) = (1.0, 1.0, 1.0, 0.0, 1.9, 50)$. Note that for the harmonic oscillator with angular frequency $\\omega = \\sqrt{k/m} = 1.0$, the explicit Verlet family exhibits a stability boundary at $\\omega \\Delta t = 2.0$. This test probes performance close to that limit.\n- Test case $3$ (small time step, mixed initial conditions): $(m, k, x_0, v_0, \\Delta t, N_{\\text{steps}}) = (1.0, 1.0, 0.7, 0.3, 0.001, 5000)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of three floating-point numbers $[$energy drift rate in $\\mathrm{J}/\\mathrm{s}$, phase error in radians, virial error dimensionless$]$. Each number must be rounded to $6$ decimal places. For example, the output format must be exactly:\n$[[\\alpha_1, \\Delta\\theta_1, \\varepsilon_{\\mathrm{vir},1}],[\\alpha_2, \\Delta\\theta_2, \\varepsilon_{\\mathrm{vir},2}],[\\alpha_3, \\Delta\\theta_3, \\varepsilon_{\\mathrm{vir},3}]]$.\n\nIn addition to implementing the computations, include in your solution an explanation of why these diagnostics together characterize the performance of the velocity Verlet integrator.",
            "solution": "The problem requires the implementation and evaluation of the velocity Verlet integration algorithm for a one-dimensional harmonic oscillator. The performance of the integrator is to be characterized by three distinct metrics: the energy drift rate, the phase error, and the virial error. First, we will derive the velocity Verlet algorithm as stipulated, and then we will analyze the significance of each diagnostic metric.\n\n### Derivation of the Velocity Verlet Algorithm\n\nThe velocity Verlet algorithm is a numerical method for integrating Newton's equations of motion. It can be derived from the Taylor series expansions for the position $x(t)$ around time $t$. The position at a future time $t + \\Delta t$ is given by:\n$$\nx(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2} a(t) \\Delta t^2 + \\frac{1}{6} \\dot{a}(t) \\Delta t^3 + \\mathcal{O}(\\Delta t^4)\n$$\nwhere $v(t) = \\dot{x}(t)$ is the velocity and $a(t) = \\ddot{x}(t)$ is the acceleration.\n\nThe core of the velocity Verlet method lies in a clever combination of updates for position and velocity that achieves second-order accuracy in $\\Delta t$ while maintaining time-reversibility and good energy conservation properties. The algorithm proceeds in two main steps.\n\nFirst, the position is updated from time $t$ to $t + \\Delta t$. We use the Taylor expansion truncated at the second-order term:\n$$\nx(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2\n$$\nThis update computes the new position $x(t + \\Delta t)$ using the position, velocity, and acceleration at the current time $t$.\n\nSecond, we need to update the velocity to $v(t + \\Delta t)$. A simple forward Euler update, $v(t + \\Delta t) = v(t) + a(t)\\Delta t$, would only be first-order accurate and lead to poor stability. To achieve second-order accuracy, we average the accelerations at the beginning and end of the time step. The velocity update rule is based on the trapezoidal rule for integrating acceleration:\n$$\nv(t + \\Delta t) = v(t) + \\int_{t}^{t+\\Delta t} a(\\tau) d\\tau \\approx v(t) + \\frac{a(t) + a(t + \\Delta t)}{2}\\Delta t\n$$\nThis requires the acceleration at the new time, $a(t + \\Delta t)$, which can be computed from the new position $x(t + \\Delta t)$ using Newton's second law: $a(t + \\Delta t) = f(x(t + \\Delta t))/m$.\n\nCombining these steps gives the complete velocity Verlet algorithm for a single time step from $t_i$ to $t_{i+1}$:\n1.  Update position: $x_{i+1} = x_i + v_i \\Delta t + \\frac{1}{2} a_i \\Delta t^2$.\n2.  Compute the new acceleration: $a_{i+1} = \\frac{f(x_{i+1})}{m}$.\n3.  Update velocity: $v_{i+1} = v_i + \\frac{1}{2} (a_i + a_{i+1}) \\Delta t$.\n\nThis scheme is explicit, self-starting, time-reversible, and symplectic, which contributes to its excellent long-term stability.\n\n### Analysis of Performance Diagnostics\n\nThe three chosen diagnostics—energy drift, phase error, and virial error—provide a comprehensive assessment of the integrator's quality by probing its fidelity to different physical and statistical properties of the true dynamics.\n\n1.  **Energy Drift Rate ($\\alpha$)**: The total mechanical energy $E=K+U$ of the isolated harmonic oscillator is a conserved quantity. Numerical integrators, however, typically introduce errors that cause the computed energy to deviate from its initial value. The velocity Verlet algorithm is symplectic, meaning it exactly conserves a \"shadow\" Hamiltonian, which is close to the true Hamiltonian. For this reason, the energy calculated from a Verlet trajectory does not drift systematically over long times but rather oscillates around a constant mean value. The amplitude of these oscillations scales with $\\Delta t^2$. The energy drift rate, $\\alpha$, is determined by fitting the energy time series $E(t)$ to a line. For a perfect symplectic integrator over many periods, this slope should be zero. A non-zero $\\alpha$ over a finite simulation indicates the degree of deviation from perfect symplecticity (e.g., due to finite precision arithmetic) or can be an artifact of fitting a line to a short segment of a long-period oscillation, especially for large $\\Delta t$. It is a primary measure of the integrator's long-term stability.\n\n2.  **Phase Error at Final Time ($|\\Delta \\theta|$)**: While Verlet integrators exhibit excellent long-term energy conservation, they typically introduce a small error in the frequency of oscillations. The numerical trajectory evolves with a slightly different angular frequency, $\\omega_{\\text{num}}$, compared to the exact analytical frequency, $\\omega$. This leads to a secular drift in the phase angle $\\theta(t)$ of the oscillator in phase space. The phase error, defined as the difference between the numerical and exact phase at the final time, accumulates over the simulation, approximately linearly with time. It is a direct measure of the integrator's temporal accuracy, i.e., how accurately it reproduces the timescale of the system's dynamics. An integrator with a large phase error may conserve energy but will produce a trajectory that is out-of-sync with reality.\n\n3.  **Virial Error ($\\varepsilon_{\\mathrm{vir}}$)**: The virial theorem provides a relationship between the time-averaged kinetic energy $\\langle K \\rangle$ and the time-averaged potential energy $\\langle U \\rangle$. For a potential of the form $U \\propto r^n$, it states that $2\\langle K \\rangle = n \\langle U \\rangle$. For the harmonic oscillator, the potential is $U(x) = \\frac{1}{2} k x^2$, so $n=2$, and the theorem simplifies to $\\langle K \\rangle = \\langle U \\rangle$. This is a statement about the statistical distribution of states sampled by the trajectory. The virial error $\\varepsilon_{\\mathrm{vir}}$ quantifies how well the numerical trajectory satisfies this fundamental statistical mechanical property. A small virial error indicates that the integrator is correctly sampling the configurational and kinetic energy distributions over time, suggesting that thermodynamic and statistical mechanical properties derived from the simulation are reliable.\n\nIn summary, these three metrics provide a multi-faceted evaluation: the energy drift assesses **stability and conservation laws**, the phase error assesses **temporal accuracy and propagation of dynamics**, and the virial error assesses **statistical mechanical integrity**. A high-quality integrator must perform well across all three measures.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (m, k, x0, v0, dt, n_steps)\n        (1.0, 1.0, 1.0, 0.0, 0.05, 200),\n        (1.0, 1.0, 1.0, 0.0, 1.9, 50),\n        (1.0, 1.0, 0.7, 0.3, 0.001, 5000),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        m, k, x0, v0, dt, n_steps = case\n        \n        # Run simulation and compute diagnostics\n        alpha, phase_error, virial_error = run_simulation(m, k, x0, v0, dt, n_steps)\n        \n        # Format the result for the current case\n        res_str = f\"[{alpha:.6f}, {phase_error:.6f}, {virial_error:.6f}]\"\n        all_results_str.append(res_str)\n\n    # Final print statement in the exact required format\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\ndef run_simulation(m, k, x0, v0, dt, n_steps):\n    \"\"\"\n    Integrates a 1D harmonic oscillator using velocity Verlet and computes performance diagnostics.\n\n    Args:\n        m (float): Mass of the particle.\n        k (float): Spring stiffness.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        n_steps (int): Number of integration steps.\n\n    Returns:\n        tuple: A tuple containing (energy_drift_rate, phase_error, virial_error).\n    \"\"\"\n    omega = np.sqrt(k / m)\n    \n    # Initialize arrays to store trajectory data\n    # Size is n_steps + 1 to include the initial state at t=0\n    num_points = n_steps + 1\n    times = np.linspace(0, n_steps * dt, num_points)\n    positions = np.zeros(num_points)\n    velocities = np.zeros(num_points)\n    total_energies = np.zeros(num_points)\n    \n    # Set initial conditions\n    positions[0] = x0\n    velocities[0] = v0\n    \n    # Initial acceleration and energy\n    a_current = -k * positions[0] / m\n    kinetic_energy = 0.5 * m * velocities[0]**2\n    potential_energy = 0.5 * k * positions[0]**2\n    total_energies[0] = kinetic_energy + potential_energy\n    \n    # Velocity Verlet integration loop\n    for i in range(n_steps):\n        # Update position\n        positions[i+1] = positions[i] + velocities[i] * dt + 0.5 * a_current * dt**2\n        \n        # Update acceleration\n        a_next = -k * positions[i+1] / m\n        \n        # Update velocity\n        velocities[i+1] = velocities[i] + 0.5 * (a_current + a_next) * dt\n        \n        # Store new acceleration for the next step\n        a_current = a_next\n        \n        # Calculate and store total energy\n        kinetic_energy = 0.5 * m * velocities[i+1]**2\n        potential_energy = 0.5 * k * positions[i+1]**2\n        total_energies[i+1] = kinetic_energy + potential_energy\n\n    # --- Compute Diagnostics ---\n\n    # 1. Energy Drift Rate\n    # Linear regression of E(t) vs t\n    lin_reg_result = linregress(times, total_energies)\n    alpha = lin_reg_result.slope\n\n    # 2. Phase Error\n    # Final numerical phase angle\n    theta_num_final = np.arctan2(velocities[-1] / omega, positions[-1])\n    \n    # Exact final phase angle\n    theta_initial = np.arctan2(v0 / omega, x0)\n    theta_exact_final = theta_initial + omega * (n_steps * dt)\n    \n    # Wrapped phase difference\n    delta_theta = theta_num_final - theta_exact_final\n    wrapped_delta_theta = (delta_theta + np.pi) % (2 * np.pi) - np.pi\n    phase_error_abs = np.abs(wrapped_delta_theta)\n\n    # 3. Virial Error\n    # Time averages of kinetic and potential energies over the whole trajectory\n    kin_energies = 0.5 * m * velocities**2\n    pot_energies = 0.5 * k * positions**2\n    avg_K = np.mean(kin_energies)\n    avg_U = np.mean(pot_energies)\n    \n    # Avoid division by zero if total energy is zero (unlikely but possible)\n    avg_E = avg_K + avg_U\n    if np.isclose(avg_E, 0):\n        virial_error = 0.0\n    else:\n        virial_error = np.abs(avg_K - avg_U) / avg_E\n        \n    return alpha, phase_error_abs, virial_error\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world materials simulation often involves complex many-body potentials that are not mathematically ideal; for instance, they may contain non-differentiable features or 'cusps' that challenge standard integrators. This advanced practice explores the consequences of such non-smooth forces on energy conservation for different algorithms within the Verlet family . You will investigate the breakdown of energy conservation at a potential cusp and implement force smoothing (mollification) as a practical technique to restore numerical accuracy in a realistic materials model.",
            "id": "3497076",
            "problem": "You are asked to quantitatively compare energy conservation properties of two time integration algorithms from the Verlet family under a many-body potential typical of metals, and to assess the benefits of force smoothing (mollification) when the potential contains cusp-like features. The context is a one-dimensional periodic chain of atoms interacting via a simplified Embedded Atom Method (EAM)-like many-body potential with a cusp in the embedding functional, and a smooth Morse pair potential.\n\nStart from the following fundamental base:\n- Newton's Second Law: $$m \\frac{d^2 x_i}{dt^2} = F_i,$$ where $m$ is the particle mass, $x_i$ is the position of particle $i$, and $F_i$ is the total force acting on particle $i$.\n- Velocity definition: $$v_i = \\frac{dx_i}{dt}.$$\n- Total energy: $$E = \\sum_i \\frac{1}{2} m v_i^2 + U(\\{x_i\\}),$$ where $U$ is the total potential energy.\n- Many-body EAM-like potential energy for atoms $i=1,\\dots,N$ in one dimension with periodic boundary conditions of length $L$:\n  $$U = \\sum_{i=1}^N F(\\rho_i) + \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij}),$$\n  with local \"electron density\"\n  $$\\rho_i = \\sum_{j \\neq i} f(r_{ij}),$$\n  pair distance $$r_{ij} = \\left| x_i - x_j - L \\,\\mathrm{round}\\left(\\frac{x_i - x_j}{L}\\right) \\right|,$$\n  density kernel $$f(r) = \\begin{cases} \\exp(-\\beta r),  r \\le r_c, \\\\ 0,  r  r_c, \\end{cases}$$\n  smooth pair potential (Morse)\n  $$\\phi(r) = D\\left(e^{-2\\alpha (r - r_0)} - 2 e^{-\\alpha (r - r_0)}\\right), \\quad r \\le r_c,$$\n  and an embedding functional with a cusp at $$\\rho_0$$\n  $$F(\\rho) = A \\, |\\rho - \\rho_0|.$$\n  Force smoothing (mollification) replaces the non-differentiable $|\\rho - \\rho_0|$ by a smooth approximation\n  $$F_\\epsilon(\\rho) = A \\sqrt{(\\rho - \\rho_0)^2 + \\epsilon^2},$$\n  whose derivative is\n  $$F_\\epsilon'(\\rho) = A \\frac{\\rho - \\rho_0}{\\sqrt{(\\rho - \\rho_0)^2 + \\epsilon^2}}.$$\n  In the unsmoothed limit $\\epsilon \\to 0$, the embedding derivative recovers the sign function, $$F_0'(\\rho) = A \\,\\mathrm{sign}(\\rho - \\rho_0),$$ with a subgradient $0$ at the cusp $\\rho=\\rho_0$.\n\nThe force on atom $i$ is obtained by taking the negative gradient of $U$ with respect to $x_i$. In one dimension with the minimum image convention and unit direction $e_{ij} = \\frac{x_i - x_j - L\\,\\mathrm{round}((x_i - x_j)/L)}{r_{ij}}$, the force contributions per pair $(i,j)$ are of the form\n$$F_i^{\\text{pair}} = - \\sum_{j \\neq i} \\phi'(r_{ij}) \\, e_{ij}, \\quad \\phi'(r) = 2 \\alpha D \\left(e^{-\\alpha (r - r_0)} - e^{-2 \\alpha (r - r_0)}\\right),$$\nand the embedding term\n$$F_i^{\\text{emb}} = - \\sum_{j \\neq i} \\left(F'(\\rho_i) + F'(\\rho_j)\\right) f'(r_{ij}) \\, e_{ij}, \\quad f'(r) = -\\beta \\exp(-\\beta r),$$\nwith $F'(\\rho)$ interpreted as either the mollified derivative $F_\\epsilon'(\\rho)$ or the unsmoothed sign-based derivative $F_0'(\\rho)$.\n\nYou must implement and compare the following two time integrators:\n- Standard position Verlet: advancing positions using current and previous positions and current accelerations without explicitly updating velocities, then reconstructing velocities by a central difference for energy evaluation.\n- Velocity Verlet: advancing positions and velocities using current and next-step accelerations.\n\nThe system specification and units:\n- One-dimensional periodic box of length $L = 10.0 \\,\\mathrm{\\AA}.$\n- Number of atoms $N = 4$ with initial positions $x = [0.0, 2.5, 5.0, 7.5] \\,\\mathrm{\\AA}.$\n- Initial velocities $v = [0.0, 0.02, -0.02, 0.0] \\,\\mathrm{\\AA}/\\mathrm{fs}.$\n- Mass per atom $m = 58.693 \\,\\mathrm{amu}.$\n- Pair parameters: $D = 0.3 \\,\\mathrm{eV}, \\; \\alpha = 1.2 \\,\\mathrm{\\AA}^{-1}, \\; r_0 = 2.5 \\,\\mathrm{\\AA}, \\; r_c = 6.0 \\,\\mathrm{\\AA}.$\n- Density kernel parameter $\\beta = 1.5 \\,\\mathrm{\\AA}^{-1}.$\n- Embedding amplitude $A = 0.8 \\,\\mathrm{eV}.$\n- Cusp location $\\rho_0 = 2 e^{-\\beta r_0} + e^{-2 \\beta r_0}.$ This choice makes the initial state lie at the cusp in the unsmoothed embedding model.\n- Use consistent physical units with positions in $\\mathrm{\\AA}$, velocities in $\\mathrm{\\AA}/\\mathrm{fs}$, time step in $\\mathrm{fs}$, energy in $\\mathrm{eV}$, and mass in $\\mathrm{amu}$. When computing accelerations using $F=ma$, apply the necessary conversion factor to use force $F$ in $\\mathrm{eV}/\\mathrm{\\AA}$, mass $m$ in $\\mathrm{amu}$, and acceleration $a$ in $\\mathrm{\\AA}/\\mathrm{fs}^2$. When computing kinetic energy, ensure the result is expressed in $\\mathrm{eV}$.\n\nDefine the following energy conservation metric for a trajectory of $M$ steps:\n- Maximum absolute relative energy deviation\n  $$\\Delta_{\\max} = \\max_{0 \\le n  M} \\frac{|E_n - E_0|}{|E_0|},$$\n  where $E_n$ is the total energy at step $n$ and $E_0$ is the initial energy at $n=0$.\n\nImplement both integrators and compute $\\Delta_{\\max}$ under two embeddings: unsmoothed ($\\epsilon = 0$) and mollified ($\\epsilon  0$). From these four $\\Delta_{\\max}$ values, compute:\n- Integrator comparison ratio (unsmoothed embedding): $R_{\\text{int}} = \\frac{\\Delta_{\\max}^{\\text{position-Verlet, unsmoothed}}}{\\Delta_{\\max}^{\\text{velocity-Verlet, unsmoothed}}}.$\n- Smoothing benefit for velocity Verlet: $R_{\\text{smooth,VV}} = \\frac{\\Delta_{\\max}^{\\text{velocity-Verlet, unsmoothed}}}{\\Delta_{\\max}^{\\text{velocity-Verlet, smoothed}}}.$\n- Smoothing benefit for position Verlet: $R_{\\text{smooth,PV}} = \\frac{\\Delta_{\\max}^{\\text{position-Verlet, unsmoothed}}}{\\Delta_{\\max}^{\\text{position-Verlet, smoothed}}}.$\n\nTest Suite:\nFor each parameter set, run $M = 3000$ steps for both integrators and both embeddings (unsmoothed and smoothed), with the following cases:\n1. Happy path: $\\Delta t = 1.0 \\,\\mathrm{fs}, \\; \\epsilon = 0.02.$\n2. Boundary near cusp and finer time resolution: $\\Delta t = 0.5 \\,\\mathrm{fs}, \\; \\epsilon = 0.02.$\n3. Large time step stress test: $\\Delta t = 2.5 \\,\\mathrm{fs}, \\; \\epsilon = 0.02.$\n\nRequired final output format:\nYour program should produce a single line of output containing, for each test case in order, the triple $[R_{\\text{int}}, R_{\\text{smooth,VV}}, R_{\\text{smooth,PV}}]$, and aggregate the three triples into one list, formatted as a comma-separated list of lists enclosed in square brackets (e.g., [[r11,r12,r13],[r21,r22,r23],[r31,r32,r33]]). All three ratios must be printed as decimal floats with no units.\n\nAll physical quantities in the derivations and algorithm description above must be treated using the specified units: positions in $\\mathrm{\\AA}$, velocities in $\\mathrm{\\AA}/\\mathrm{fs}$, time step in $\\mathrm{fs}$, mass in $\\mathrm{amu}$, and energy in $\\mathrm{eV}$. Express the final ratios as pure decimal numbers (unitless fractions).",
            "solution": "This problem requires a comparison of the energy conservation properties of the position Verlet and velocity Verlet integrators for a one-dimensional system of atoms interacting via a simplified many-body potential containing a non-differentiable cusp. The beneficial effect of smoothing (mollifying) this cusp is also to be quantified.\n\n**1. Unit Conversions**\nThe simulation uses a mixed set of units common in molecular dynamics: angstroms ($\\mathrm{\\AA}$) for length, femtoseconds ($\\mathrm{fs}$) for time, atomic mass units ($\\mathrm{amu}$) for mass, and electronvolts ($\\mathrm{eV}$) for energy. Newton's second law, $F = ma$, and the kinetic energy formula, $E_K = \\frac{1}{2}mv^2$, require consistent units. We establish conversion factors to relate forces in $\\mathrm{eV}/\\mathrm{\\AA}$ to accelerations in $\\mathrm{\\AA}/\\mathrm{fs}^2$, and the term $mv^2$ in $\\mathrm{amu} \\cdot (\\mathrm{\\AA}/\\mathrm{fs})^2$ to energy in $\\mathrm{eV}$.\n\n-   **Force to Acceleration:** To find the acceleration $a$ in $\\mathrm{\\AA}/\\mathrm{fs}^2$ from a force $F$ in $\\mathrm{eV}/\\mathrm{\\AA}$ and mass $m$ in $\\mathrm{amu}$, we use the conversion factor $C_{F/m}$:\n    $$a \\, [\\mathrm{\\AA}/\\mathrm{fs}^2] = \\frac{F \\, [\\mathrm{eV}/\\mathrm{\\AA}]}{m \\, [\\mathrm{amu}]} \\times C_{F/m}$$\n    $$C_{F/m} = \\frac{ (1.602... \\times 10^{-19} \\, \\mathrm{J}/\\mathrm{eV}) / (10^{-10} \\, \\mathrm{m}/\\mathrm{\\AA}) }{ 1.660... \\times 10^{-27} \\, \\mathrm{kg}/\\mathrm{amu} } \\times \\frac{ (10^{-15} \\, \\mathrm{s}/\\mathrm{fs})^2 }{ 10^{-10} \\, \\mathrm{m}/\\mathrm{\\AA} } \\approx 0.0096485$$\n\n-   **Kinetic Energy:** To find the kinetic energy $E_K$ in $\\mathrm{eV}$ from mass $m$ in $\\mathrm{amu}$ and velocity $v$ in $\\mathrm{\\AA}/\\mathrm{fs}$, we use the conversion factor $C_{E_K}$:\n    $$E_K \\, [\\mathrm{eV}] = \\frac{1}{2} m \\, [\\mathrm{amu}] v^2 \\, [(\\mathrm{\\AA}/\\mathrm{fs})^2] \\times C_{E_K}$$\n    $$C_{E_K} = \\frac{ (1.660... \\times 10^{-27} \\, \\mathrm{kg}/\\mathrm{amu}) \\times \\left( (10^{-10} \\, \\mathrm{m}/\\mathrm{\\AA}) / (10^{-15} \\, \\mathrm{s}/\\mathrm{fs}) \\right)^2 }{ 1.602... \\times 10^{-19} \\, \\mathrm{J}/\\mathrm{eV} } \\approx 103.6427$$\n\n**2. Force and Energy Calculation**\nThe core of the simulation is calculating the total potential energy $U$ and the force on each atom $F_i = -\\nabla_i U$. This involves two main steps:\n1.  For a given set of atomic positions $\\{x_i\\}$, first calculate all pairwise distances $r_{ij}$ using the minimum image convention. Then, compute the local electron density $\\rho_i$ at each atomic site by summing the contributions $f(r_{ij})$ from its neighbors within the cutoff radius $r_c$.\n2.  With all $\\rho_i$ known, calculate the embedding energy contribution $U_{emb} = \\sum_i F(\\rho_i)$ and the derivatives $F'(\\rho_i)$. The functional form of $F$ and $F'$ depends on whether the smoothed ($\\epsilon  0$) or unsmoothed ($\\epsilon=0$) model is used. Then, loop over all unique pairs $(i,j)$ again to compute the pair potential energy $U_{pair} = \\frac{1}{2}\\sum_{i \\neq j} \\phi(r_{ij})$ and the total force on each atom. The force on atom $i$ is a sum of contributions from all other atoms $j$, comprising a pair term derived from $\\phi'(r_{ij})$ and a many-body term involving $F'(\\rho_i)$, $F'(\\rho_j)$, and $f'(r_{ij})$.\n\n**3. Integration Algorithms**\n\n-   **Position Verlet:** This algorithm updates positions without explicitly using velocities in the primary integration step. It requires positions from two previous time steps, $x_n$ and $x_{n-1}$.\n    -   Startup: The required previous position $x_{-1}$ is not known and must be estimated from the initial conditions $x_0$ and $v_0$. A Taylor expansion gives: $x_{-1} \\approx x_0 - v_0 \\Delta t + \\frac{1}{2} a_0 (\\Delta t)^2$, where $a_0 = F(x_0)/m$.\n    -   Time Step: The new position $x_{n+1}$ is calculated from $x_n$, $x_{n-1}$, and the current acceleration $a_n$:\n        $$x_{n+1} = 2x_n - x_{n-1} + a_n (\\Delta t)^2$$\n    -   Energy Calculation: To evaluate the total energy, velocities are required for the kinetic energy term. They are reconstructed using a central difference formula, which is consistent with the Verlet scheme's order of accuracy:\n        $$v_n = \\frac{x_{n+1} - x_{n-1}}{2 \\Delta t}$$\n\n-   **Velocity Verlet:** This algorithm explicitly propagates both position and velocity. It is generally preferred as it provides velocities at the same time step as positions, simplifying energy calculations and thermostatting.\n    -   Time Step: The update occurs in two stages, using the accelerations from the current ($a_n$) and next ($a_{n+1}$) steps.\n        1.  Update positions to $x_{n+1}$: $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$\n        2.  Calculate the new force $F_{n+1}$ and acceleration $a_{n+1}$ at the new position $x_{n+1}$.\n        3.  Update velocities to $v_{n+1}$: $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$\n    -   Energy Calculation: The total energy $E_{n+1}$ is computed directly using the newly calculated $x_{n+1}$ for the potential energy and $v_{n+1}$ for the kinetic energy.\n\n**4. Analysis**\nFor each of the three test cases, four separate simulations are performed over $M=3000$ steps: position Verlet with and without smoothing, and velocity Verlet with and without smoothing. For each run, the maximum absolute relative energy deviation $\\Delta_{\\max}$ is recorded. The specified ratios ($R_{\\text{int}}, R_{\\text{smooth,VV}}, R_{\\text{smooth,PV}}$) are then computed from these four $\\Delta_{\\max}$ values. The results from all three test cases are aggregated into a final list. The unsmoothed case is numerically modeled by setting the smoothing parameter $\\epsilon$ to $0$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics integrator comparison problem.\n    \"\"\"\n    # --- PHYSICAL AND UNIT CONVERSION CONSTANTS ---\n    eV_to_J = 1.602176634e-19\n    amu_to_kg = 1.66053906660e-27\n    Å_to_m = 1e-10\n    fs_to_s = 1e-15\n\n    # F/m conversion factor: [(eV/Å)/amu] - [Å/fs^2]\n    F_M_CONV = (eV_to_J / Å_to_m) / amu_to_kg * (fs_to_s**2 / Å_to_m)\n\n    # m*v^2 conversion factor: [amu*(Å/fs)^2] - [eV]\n    MV2_TO_EV = (amu_to_kg * (Å_to_m / fs_to_s)**2) / eV_to_J\n\n    # --- HELPER FUNCTIONS FOR SIMULATION ---\n\n    def calculate_potential_and_forces(x, params, epsilon):\n        N = params['N']; L = params['L']; D = params['D']; alpha = params['alpha']\n        r0_pair = params['r0_pair']; rc = params['rc']; beta = params['beta']\n        A = params['A']; rho0 = params['rho0']\n\n        U_pair = 0.0\n        forces = np.zeros(N)\n        rho = np.zeros(N)\n\n        # Step 1: Calculate local densities rho_i\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dx = dx - L * np.round(dx / L)\n                r_ij = np.abs(dx)\n\n                if r_ij = rc:\n                    f_ij = np.exp(-beta * r_ij)\n                    rho[i] += f_ij\n                    rho[j] += f_ij\n        \n        # Step 2: Calculate embedding energy F(rho) and its derivative F'(rho)\n        delta_rho = rho - rho0\n        if epsilon == 0:\n            U_emb = A * np.sum(np.abs(delta_rho))\n            F_prime_rho = A * np.sign(delta_rho)\n        else:\n            sqrt_term = np.sqrt(delta_rho**2 + epsilon**2)\n            U_emb = A * np.sum(sqrt_term)\n            F_prime_rho = A * delta_rho / sqrt_term\n    \n        # Step 3: Loop over pairs for pair energy and forces\n        for i in range(N):\n            for j in range(i + 1, N):\n                dx = x[i] - x[j]\n                dx = dx - L * np.round(dx / L)\n                r_ij = np.abs(dx)\n\n                if 0  r_ij = rc:\n                    e_ij = np.sign(dx)\n                    \n                    # Pair potential and force\n                    exp_term = np.exp(-alpha * (r_ij - r0_pair))\n                    phi = D * (exp_term**2 - 2 * exp_term)\n                    phi_prime = 2 * alpha * D * (exp_term - exp_term**2)\n                    \n                    U_pair += phi\n                    F_pair_ij = -phi_prime * e_ij\n                    \n                    # Embedding force\n                    f_prime = -beta * np.exp(-beta * r_ij)\n                    F_emb_ij = -(F_prime_rho[i] + F_prime_rho[j]) * f_prime * e_ij\n                    \n                    # Total pairwise force\n                    F_total_ij = F_pair_ij + F_emb_ij\n                    forces[i] += F_total_ij\n                    forces[j] -= F_total_ij\n    \n        return U_emb + U_pair, forces\n\n    def run_velocity_verlet(x0, v0, params, dt, M, epsilon):\n        m = params['m']; L = params['L']\n        x = np.copy(x0); v = np.copy(v0)\n        \n        U, F = calculate_potential_and_forces(x, params, epsilon)\n        KE = 0.5 * m * np.sum(v**2) * MV2_TO_EV\n        E0 = U + KE\n        if np.abs(E0)  1e-12: return 1.0\n\n        max_abs_dev = 0.0\n        a = F / m * F_M_CONV\n\n        for _ in range(M):\n            x = x + v * dt + 0.5 * a * dt**2\n            # Apply periodic boundary conditions to positions\n            x = x - L * np.floor(x / L)\n\n\n            U_next, F_next = calculate_potential_and_forces(x, params, epsilon)\n            a_next = F_next / m * F_M_CONV\n            v = v + 0.5 * (a + a_next) * dt\n            a = a_next\n\n            KE_next = 0.5 * m * np.sum(v**2) * MV2_TO_EV\n            E_next = U_next + KE_next\n            \n            max_abs_dev = max(max_abs_dev, np.abs(E_next - E0))\n        \n        return max_abs_dev / np.abs(E0)\n\n    def run_position_verlet(x0, v0, params, dt, M, epsilon):\n        m = params['m']; L = params['L']\n        x_curr = np.copy(x0)\n        \n        U0, F0 = calculate_potential_and_forces(x_curr, params, epsilon)\n        KE0 = 0.5 * m * np.sum(v0**2) * MV2_TO_EV\n        E0 = U0 + KE0\n        if np.abs(E0)  1e-12: return 1.0\n\n        max_abs_dev = 0.0\n        \n        a0 = F0 / m * F_M_CONV\n        x_prev = x_curr - v0 * dt + 0.5 * a0 * dt**2\n        \n        for _ in range(M):\n            U_curr, F_curr = calculate_potential_and_forces(x_curr, params, epsilon)\n            a_curr = F_curr / m * F_M_CONV\n            \n            x_next = 2 * x_curr - x_prev + a_curr * dt**2\n            \n            v_reconstructed = (x_next - x_prev) / (2 * dt)\n            KE_curr = 0.5 * m * np.sum(v_reconstructed**2) * MV2_TO_EV\n            E_curr = U_curr + KE_curr\n            \n            max_abs_dev = max(max_abs_dev, abs(E_curr - E0))\n            x_prev, x_curr = x_curr, x_next\n        \n        return max_abs_dev / np.abs(E0)\n    \n    # --- MAIN EXECUTION ---\n    \n    r0_pair_val = 2.5\n    beta_val = 1.5\n    params = {\n        'N': 4, 'm': 58.693, 'L': 10.0, 'D': 0.3, 'alpha': 1.2, \n        'r0_pair': r0_pair_val, 'rc': 6.0, 'beta': beta_val, 'A': 0.8,\n        'rho0': 2 * np.exp(-beta_val * r0_pair_val) + np.exp(-2 * beta_val * r0_pair_val)\n    }\n    x0 = np.array([0.0, 2.5, 5.0, 7.5])\n    v0 = np.array([0.0, 0.02, -0.02, 0.0])\n\n    test_cases = [\n        {'dt': 1.0, 'epsilon': 0.02, 'M': 3000},\n        {'dt': 0.5, 'epsilon': 0.02, 'M': 3000},\n        {'dt': 2.5, 'epsilon': 0.02, 'M': 3000},\n    ]\n\n    results = []\n    for case in test_cases:\n        dt, epsilon, M = case['dt'], case['epsilon'], case['M']\n        \n        # Unsmoothed runs (epsilon=0)\n        delta_pv_un = run_position_verlet(x0, v0, params, dt, M, epsilon=0)\n        delta_vv_un = run_velocity_verlet(x0, v0, params, dt, M, epsilon=0)\n        \n        # Smoothed runs\n        delta_pv_sm = run_position_verlet(x0, v0, params, dt, M, epsilon)\n        delta_vv_sm = run_velocity_verlet(x0, v0, params, dt, M, epsilon)\n        \n        # Add a small constant to denominators to prevent division by zero\n        safe_denom = 1e-18 \n        R_int = delta_pv_un / (delta_vv_un + safe_denom)\n        R_smooth_VV = delta_vv_un / (delta_vv_sm + safe_denom)\n        R_smooth_PV = delta_pv_un / (delta_pv_sm + safe_denom)\n        \n        results.append([R_int, R_smooth_VV, R_smooth_PV])\n\n    # Format the final output string as per requirements\n    list_strs = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_output = f\"[{','.join(list_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}