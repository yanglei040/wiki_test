{
    "hands_on_practices": [
        {
            "introduction": "埃瓦尔德方法的效率和准确性在很大程度上取决于筛分参数 $\\alpha$ 的选择。这个参数控制着实空间和倒易空间计算之间的工作分配。本练习  将引导你从第一性原理出发，探索力对 $\\alpha$ 的敏感性，并基于此设计一种自适应策略来动态优化该参数，从而加深对PME方法核心权衡的理解。",
            "id": "3473558",
            "problem": "给定一个三维周期性模拟单元，其边长为 $L$，体积为 $V = L^3$，以及一组 $M$ 个点电荷，其电荷量为 $\\{q_i\\}_{i=1}^M$，位置为 $\\{\\mathbf{r}_i\\}_{i=1}^M$，所有量均采用简约无量纲单位。考虑使用高斯屏蔽参数 $\\alpha > 0$ 的静电场埃瓦尔德分解的倒易空间部分。设倒易格矢为 $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ 为整数三元组。傅里叶空间电荷密度表示为 $\\rho(\\mathbf{k})$，并假设其满足 $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$，以确保电场为实数。假设在位置 $\\mathbf{r}$ 处，由模式振幅 $\\rho(\\mathbf{k})$ 产生的倒易空间电场由标准的埃瓦尔德屏蔽傅里叶表示给出，并对一组截断的模式 $\\{\\mathbf{k} : 0 < \\lVert \\mathbf{k} \\rVert \\le k_c\\}$ 进行求和，其中 $k_c > 0$ 是倒易空间截断半径。粒子所受的力为 $\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)$。\n\n从这些定义和埃瓦尔德分裂为每个倒易模式引入高斯因子 $\\exp\\!\\left(-\\lVert \\mathbf{k} \\rVert^2 / (4 \\alpha^2)\\right)$ 的核心原理出发，完成以下任务：\n\n1. 从第一性原理出发，推导倒易空间电场 $\\mathbf{E}(\\mathbf{r})$ 的表达式，然后用 $\\rho(\\mathbf{k})$、$\\alpha$ 和 $\\mathbf{k} \\cdot \\mathbf{r}_i$ 的三角函数推导出力相对于屏蔽参数的灵敏度 $\\partial \\mathbf{F}_i / \\partial \\alpha$。你的推导必须从屏蔽势的傅里叶表示开始，通过取空间梯度并对 $\\alpha$ 求导来进行。\n\n2. 提出一种基于 $\\rho(\\mathbf{k})$ 瞬时谱选择 $\\alpha(t)$ 的自适应策略。你的策略必须平衡实空间截断误差和倒易空间截断误差的模型。使用一个随任一截断误差增大而增大的离散标量目标 $J(\\alpha)$，并指明如何选择使 $J(\\alpha)$ 最小化的 $\\alpha$。\n\n3. 实现一个程序，该程序：\n   - 构建一个边长 $L = 6.0$、体积 $V = L^3$ 的立方盒子。\n   - 使用倒易格矢 $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{n}$，其中整数分量 $n_x, n_y, n_z$ 在 $-N_{\\text{outer}} \\le n_\\mu \\le N_{\\text{outer}}$ 范围内，不包括 $\\mathbf{n} = \\mathbf{0}$，并设 $N_{\\text{outer}} = 6$。定义倒易空间截断半径为 $N_c = 3$，因此 $k_c = \\frac{2\\pi}{L} N_c$，并定义外部评估极限 $k_{\\text{outer}} = \\frac{2\\pi}{L} N_{\\text{outer}}$。\n   - 定义四个粒子的位置和电荷：\n     - $\\mathbf{r}_1 = (0.7, 1.3, 2.9)$, $q_1 = 1.0$。\n     - $\\mathbf{r}_2 = (2.2, 4.5, 1.1)$, $q_2 = -1.5$。\n     - $\\mathbf{r}_3 = (5.1, 0.4, 3.8)$, $q_3 = 0.7$。\n     - $\\mathbf{r}_4 = (1.9, 3.3, 5.5)$, $q_4 = -0.6$。\n   - 对 $\\rho(\\mathbf{k})$ 使用以下四种作为 $\\lVert \\mathbf{k} \\rVert$ 的函数的谱，每种谱都为满足 $0 < \\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}$ 的所有模式定义，并满足 $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$：\n     1. 白谱：$\\rho(\\mathbf{k}) = 1$。\n     2. 低 $k$ 主导：$\\rho(\\mathbf{k}) = \\exp\\!\\left(-(\\lVert \\mathbf{k} \\rVert / k_0)^2\\right)$，其中 $k_0 = 0.5\\, k_c$。\n     3. 高 $k$ 主导：$\\rho(\\mathbf{k}) = \\left(\\lVert \\mathbf{k} \\rVert / k_c\\right)^2 \\exp\\!\\left(-\\left(\\lVert \\mathbf{k} \\rVert - 1.5\\, k_c\\right)^2 / \\sigma^2\\right)$，其中 $\\sigma = 0.3\\, k_c$。\n     4. 单模：如果 $\\lVert \\mathbf{k} \\rVert$ 等于最小的非零模长（在 $10^{-8}$ 的容差内），则 $\\rho(\\mathbf{k}) = 1$，否则 $\\rho(\\mathbf{k}) = 0$。\n   - 对于固定的 $\\alpha_0 = 1.0$ 和对称有限差分步长 $\\delta\\alpha = 10^{-4}$，为每种谱计算：\n     - 对所有粒子，仅使用满足 $0 < \\lVert \\mathbf{k} \\rVert \\le k_c$ 的模式计算解析的 $\\partial \\mathbf{F}_i / \\partial \\alpha$。\n     - 对相同的力定义，计算中心差分近似 $\\left(\\mathbf{F}_i(\\alpha_0 + \\delta\\alpha) - \\mathbf{F}_i(\\alpha_0 - \\delta\\alpha)\\right) / (2 \\delta\\alpha)$。\n     - 解析灵敏度与有限差分灵敏度之间的均方根误差（一个标量），该误差聚合了所有粒子和笛卡尔分量。\n   - 通过最小化标量目标来实现你的自适应 $\\alpha$ 选择：\n     $$J(\\alpha) = \\left[\\operatorname{erfc}(\\alpha r_c)\\right]^2 + \\sum_{\\lVert \\mathbf{k} \\rVert > k_c}^{\\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}} \\left[\\rho(\\mathbf{k}) \\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^2}\\right)\\right]^2,$$\n     其中 $r_c = 2.0$，$\\operatorname{erfc}$ 是互补误差函数。在 $\\alpha \\in [0.4, 2.0]$ 上使用至少 $200$ 个点的均匀网格搜索，为每种谱分别找到最小化 $J(\\alpha)$ 的 $\\alpha^\\star$。\n   - 输出单行结果，格式为一个由方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $8$ 个浮点数：对于给定顺序（白谱、低 $k$、高 $k$、单模）的每种谱，先是均方根误差，然后是推荐的 $\\alpha^\\star$。例如，输出格式为 $[e_1,\\alpha^\\star_1,e_2,\\alpha^\\star_2,e_3,\\alpha^\\star_3,e_4,\\alpha^\\star_4]$。\n\n科学和数值要求：\n- 所有量都是无量纲的。\n- 三角函数必须使用弧度。\n- 实现必须是自包含的，并且不应需要任何输入。\n\n你的程序应该产生一行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，$[0.001,1.234,0.002,1.111,0.003,0.987,0.0001,1.543]$）。",
            "solution": "经审慎检验，问题陈述有效。其科学基础在于计算物理学原理，特别是用于周期性静电相互作用的埃瓦尔德求和方法。该问题是适定的、客观的，并为得出唯一且有意义的解提供了所有必要的数据和约束。尽管它包含一个用于误差优化目标函数的非标准公式，但这被解释为一个给定的建模选择，不构成根本性缺陷。\n\n解决方案按要求分为三个部分：理论推导、自适应策略的制定和数值实现。\n\n### 1. 倒易空间电场和力灵敏度的推导\n\n推导从静电势的傅里叶表示开始，进而推导出电场及其对埃瓦尔德屏蔽参数 $\\alpha$ 的灵敏度。\n\n**1.1. 倒易空间电场 $\\mathbf{E}(\\mathbf{r})$**\n\n周期系统中的静电势 $\\phi(\\mathbf{r})$ 可以用傅里叶级数表示。倒易空间分量 $\\phi_{\\text{rec}}(\\mathbf{r})$ 解释了势的长程部分，该部分由高斯电荷分布屏蔽。对于体积为 $V = L^3$ 的系统，其势由下式给出：\n$$\n\\phi_{\\text{rec}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\hat{\\phi}_{\\text{rec}}(\\mathbf{k}) e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\n其中 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$ 是整数三元组 $\\mathbf{n}$ 的倒易格矢。\n\n傅里叶系数 $\\hat{\\phi}_{\\text{rec}}(\\mathbf{k})$ 是通过在傅里叶空间中求解屏蔽泊松方程得到的。该解包含标准的埃瓦尔德屏蔽因子 $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (4\\alpha^2))$。对于傅里叶空间电荷密度 $\\rho(\\mathbf{k})$，系数为：\n$$\n\\hat{\\phi}_{\\text{rec}}(\\mathbf{k}) = C \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)\n$$\n在无量纲单位中，通常设置前置因子常数 $C=1$。（在高斯单位制中，$C=4\\pi$。）问题指定 $\\rho(\\mathbf{k})$ 为实数且满足 $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$。这意味着当对对称的 $(\\mathbf{k}, -\\mathbf{k})$ 对求和时，$e^{i\\mathbf{k}\\cdot\\mathbf{r}}$ 的虚部（正弦）分量将相互抵消，留下一个由余弦级数表示的纯实数势。\n$$\n\\phi_{\\text{rec}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cos(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n电场 $\\mathbf{E}(\\mathbf{r})$ 是势的负梯度，即 $\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi_{\\text{rec}}(\\mathbf{r})$。应用梯度算子：\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\left[ \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cos(\\mathbf{k} \\cdot \\mathbf{r}) \\right]\n$$\n余弦项的梯度是 $\\nabla \\cos(\\mathbf{k} \\cdot \\mathbf{r}) = -\\mathbf{k} \\sin(\\mathbf{k} \\cdot \\mathbf{r})$。这得出了电场的表达式，对截断的模式集 $0 < \\lVert \\mathbf{k} \\rVert \\le k_c$ 求和：\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{V} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\frac{\\rho(\\mathbf{k}) \\mathbf{k}}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n\n**1.2. 力灵敏度 $\\partial \\mathbf{F}_i / \\partial \\alpha$**\n\n粒子 $i$ 上的静电力为 $\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)$。此力相对于屏蔽参数 $\\alpha$ 的灵敏度通过求偏导数 $\\partial \\mathbf{F}_i / \\partial \\alpha$ 得到：\n$$\n\\frac{\\partial \\mathbf{F}_i}{\\partial \\alpha} = q_i \\frac{\\partial \\mathbf{E}(\\mathbf{r}_i; \\alpha)}{\\partial \\alpha}\n$$\n我们对 $\\mathbf{E}(\\mathbf{r})$ 的表达式关于 $\\alpha$ 求导。唯一依赖于 $\\alpha$ 的项是指数因子。使用链式法则：\n$$\n\\frac{\\partial}{\\partial \\alpha} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) = \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cdot \\frac{\\partial}{\\partial \\alpha}\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4} \\alpha^{-2}\\right) = \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cdot \\left(\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^3}\\right)\n$$\n将此代入 $\\partial \\mathbf{E} / \\partial \\alpha$ 的表达式中：\n$$\n\\frac{\\partial \\mathbf{E}(\\mathbf{r}; \\alpha)}{\\partial \\alpha} = \\frac{1}{V} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\frac{\\rho(\\mathbf{k}) \\mathbf{k}}{\\lVert \\mathbf{k} \\rVert^2} \\left[ \\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^3} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\right] \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n分子和分母中的 $\\lVert \\mathbf{k} \\rVert^2$ 项相互抵消，得到简化的场灵敏度表达式：\n$$\n\\frac{\\partial \\mathbf{E}(\\mathbf{r}; \\alpha)}{\\partial \\alpha} = \\frac{1}{2V\\alpha^3} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\rho(\\mathbf{k}) \\mathbf{k} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n最后，粒子 $i$ 的力灵敏度为：\n$$\n\\frac{\\partial \\mathbf{F}_i}{\\partial \\alpha} = \\frac{q_i}{2V\\alpha^3} \\sum_{0 < \\lVert \\mathbf{k} \\rVert \\le k_c} \\rho(\\mathbf{k}) \\mathbf{k} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_i)\n$$\n\n### 2. 选择 $\\alpha$ 的自适应策略\n\n$\\alpha$ 的选择代表了一种权衡：大的 $\\alpha$ 使屏蔽电荷集中在狭窄区域，导致实空间中快速衰减（低实空间误差），但在倒易空间中衰减缓慢（高倒易空间误差）。相反，小的 $\\alpha$ 产生低的倒易空间误差，但高的实空间误差。最佳的 $\\alpha$ 平衡了这两种相互竞争的误差源。\n\n问题提供了一个特定的目标函数 $J(\\alpha)$ 来模拟这种权衡：\n$$\nJ(\\alpha) = \\underbrace{\\left[\\operatorname{erfc}(\\alpha r_c)\\right]^2}_{J_{\\text{real}}(\\alpha)} + \\underbrace{\\sum_{\\lVert \\mathbf{k} \\rVert > k_c}^{\\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}} \\left[\\rho(\\mathbf{k}) \\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^2}\\right)\\right]^2}_{J_{\\text{rec}}(\\alpha)}\n$$\n- 第一项 $J_{\\text{real}}(\\alpha)$ 模拟实空间截断误差。互补误差函数 $\\operatorname{erfc}(x)$ 是一个单调递减函数。因此，$J_{\\text{real}}(\\alpha)$ 随 $\\alpha$ 的增加而减小，惩罚小的 $\\alpha$ 值。\n- 第二项 $J_{\\text{rec}}(\\alpha)$ 通过对首批被忽略项的平方大小求和来模拟倒易空间截断误差。指数因子 $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (2 \\alpha^2))$ 随 $\\alpha$ 的增加而增加（对于固定的 $\\mathbf{k}$），意味着 $J_{\\text{rec}}(\\alpha)$ 是 $\\alpha$ 的单调递增函数。它惩罚大的 $\\alpha$ 值。\n\n自适应策略是找到使总误差模型 $J(\\alpha)$ 最小化的 $\\alpha$ 值，记为 $\\alpha^\\star$。由于 $J(\\alpha)$ 是一个递减函数和一个递增函数之和，预期它会有一个唯一的最小值。所提出的策略是数值网格搜索：\n1. 在指定区间 $\\alpha \\in [0.4, 2.0]$ 上定义一个离散的候选 $\\alpha$ 值网格。\n2. 对于网格上的每个 $\\alpha$，使用给定的系统参数（$r_c$、$k_c$、$k_{\\text{outer}}$）和瞬时电荷谱 $\\rho(\\mathbf{k})$ 来评估 $J(\\alpha)$。\n3. 从网格中找出产生 $J(\\alpha)$ 最小值的 $\\alpha^\\star$。\n\n这个 $\\alpha^\\star$ 代表了给定电荷配置下的最佳选择，根据所提供的模型平衡了估计的实空间和倒易空间误差。\n\n### 3. 实现\n\n以下部分提供了实现所述计算的 Python 代码。它计算了解析推导的力灵敏度与有限差分近似之间的均方根误差。它还执行网格搜索，为四种不同的电荷密度谱找到最佳的 $\\alpha^\\star$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the particle mesh Ewald-related problem, including force sensitivity\n    analysis and adaptive alpha parameter selection.\n    \"\"\"\n    # Define system parameters and constants as per the problem statement\n    L = 6.0\n    V = L**3\n    N_outer = 6\n    N_c = 3\n    k_c = 2 * np.pi / L * N_c\n    k_outer = 2 * np.pi / L * N_outer\n    \n    # Define particle properties: positions and charges\n    positions = np.array([\n        [0.7, 1.3, 2.9],\n        [2.2, 4.5, 1.1],\n        [5.1, 0.4, 3.8],\n        [1.9, 3.3, 5.5]\n    ])\n    charges = np.array([1.0, -1.5, 0.7, -0.6])\n    \n    # Generate reciprocal lattice vectors\n    n_range = np.arange(-N_outer, N_outer + 1)\n    nx, ny, nz = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n    n_vecs = np.stack((nx.ravel(), ny.ravel(), nz.ravel()), axis=1)\n    \n    # Exclude the n=(0,0,0) vector\n    mask_zero = np.all(n_vecs == 0, axis=1)\n    n_vecs = n_vecs[~mask_zero]\n    \n    k_vecs = (2 * np.pi / L) * n_vecs\n    k_mags = np.linalg.norm(k_vecs, axis=1)\n\n    # Define the charge density spectra\n    spectra_names = ['white', 'low-k', 'high-k', 'single-mode']\n    k0 = 0.5 * k_c\n    sigma = 0.3 * k_c\n    \n    # Smallest nonzero k-magnitude for the single-mode spectrum\n    k_min = np.min(k_mags[k_mags > 1e-9])\n\n    def get_rho(k_magnitudes, spectrum_name):\n        if spectrum_name == 'white':\n            return np.ones_like(k_magnitudes)\n        elif spectrum_name == 'low-k':\n            return np.exp(-(k_magnitudes / k0)**2)\n        elif spectrum_name == 'high-k':\n            return (k_magnitudes / k_c)**2 * np.exp(-((k_magnitudes - 1.5 * k_c) / sigma)**2)\n        elif spectrum_name == 'single-mode':\n            return np.isclose(k_magnitudes, k_min, atol=1e-8).astype(float)\n        else:\n            raise ValueError(f\"Unknown spectrum name: {spectrum_name}\")\n\n    results = []\n    \n    # Iterate through each spectrum to perform calculations\n    for name in spectra_names:\n        # Generate the full spectrum of rho(k) up to k_outer\n        rho_k_full = get_rho(k_mags, name)\n        \n        # --- Task 1: Sensitivity Calculation and RMSE ---\n        alpha0 = 1.0\n        delta_alpha = 1e-4\n\n        # Filter k-vectors for force calculation (0  ||k|| = k_c)\n        mask_force = k_mags  k_c\n        k_vecs_force = k_vecs[mask_force]\n        k_mags_force = k_mags[mask_force]\n        rho_k_force = rho_k_full[mask_force]\n\n        def calculate_forces(alpha, k_v, k_m, rho_k, pos, chg, vol):\n            forces = np.zeros_like(pos)\n            prefactor = 1.0 / vol\n            for i in range(len(chg)):\n                dotprods = k_v @ pos[i]\n                sins = np.sin(dotprods)\n                \n                k_m_sq_inv = np.zeros_like(k_m)\n                valid_k = k_m  1e-9\n                k_m_sq_inv[valid_k] = 1.0 / k_m[valid_k]**2\n\n                exp_term = np.exp(-k_m**2 / (4 * alpha**2))\n                common_factor = rho_k * k_m_sq_inv * exp_term * sins\n                force_sum = np.sum(common_factor[:, np.newaxis] * k_v, axis=0)\n                forces[i, :] = chg[i] * prefactor * force_sum\n            return forces\n\n        def calculate_force_deriv_analytic(alpha, k_v, k_m, rho_k, pos, chg, vol):\n            derivs = np.zeros_like(pos)\n            prefactor = 1.0 / (2 * vol * alpha**3)\n            for i in range(len(chg)):\n                dotprods = k_v @ pos[i]\n                sins = np.sin(dotprods)\n                exp_term = np.exp(-k_m**2 / (4 * alpha**2))\n                common_factor = rho_k * exp_term * sins\n                deriv_sum = np.sum(common_factor[:, np.newaxis] * k_v, axis=0)\n                derivs[i, :] = chg[i] * prefactor * deriv_sum\n            return derivs\n        \n        F_analytic = calculate_force_deriv_analytic(alpha0, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        \n        F_plus = calculate_forces(alpha0 + delta_alpha, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        F_minus = calculate_forces(alpha0 - delta_alpha, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        F_numeric = (F_plus - F_minus) / (2 * delta_alpha)\n        \n        rmse = np.sqrt(np.mean((F_analytic - F_numeric)**2))\n        results.append(rmse)\n\n        # --- Task 2: Adaptive alpha selection ---\n        r_c = 2.0\n        alpha_grid = np.linspace(0.4, 2.0, 201)\n\n        # Filter k-vectors for J_rec calculation (k_c  ||k|| = k_outer)\n        mask_J = (k_mags  k_c)  (k_mags  k_outer)\n        k_mags_J = k_mags[mask_J]\n        rho_k_J = rho_k_full[mask_J]\n        \n        J_values = np.zeros_like(alpha_grid)\n        for j, alpha_val in enumerate(alpha_grid):\n            J_real = erfc(alpha_val * r_c)**2\n            exp_term = np.exp(-k_mags_J**2 / (2 * alpha_val**2))\n            terms = rho_k_J * exp_term\n            J_rec = np.sum(terms**2)\n            J_values[j] = J_real + J_rec\n        \n        alpha_star = alpha_grid[np.argmin(J_values)]\n        results.append(alpha_star)\n\n    # Format and print the final output as a single-line comma-separated list\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了进一步优化计算效率，可以采用比标准PME更复杂的方案，例如双网格PME方法。这种方法使用一个粗网格处理长波分量，一个细网格处理中波分量。本练习  将带你深入了解谱分裂技术的核心，通过设计平滑的倒易空间滤波器来评估和优化这种双网格方案的性能，重点关注谱重叠和力稳定性等关键指标。",
            "id": "3473525",
            "problem": "您被委派设计和评估一种用于粒子网格埃瓦尔德（Particle Mesh Ewald, PME）方法的双网格谱分裂方案，该方法在一个三维周期性立方晶胞中进行。双网格设计使用一个粗网格来捕捉长波分量，一个细网格来捕捉中等波长分量，而短波分量则由埃瓦尔德分解的实空间部分处理。您的程序必须在倒易空间中为粗网格和细网格构建光滑的径向滤波器，分别表示为 $F_c(\\mathbf{k})$ 和 $F_f(\\mathbf{k})$，并定量分析两个属性：最小谱重叠和稳定的力响应。\n\n基本原理：\n- 在一个边长为 $L$ 的周期性立方盒子中，对于电荷密度 $\\rho(\\mathbf{r})$，静电势 $\\phi(\\mathbf{r})$ 遵循泊松方程 $\\nabla^2 \\phi(\\mathbf{r}) = - \\rho(\\mathbf{r}) / \\varepsilon_0$。在埃瓦尔德分解下，阻尼库仑相互作用的倒易空间格林函数由 $G(\\mathbf{k}) = \\dfrac{4\\pi}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\!\\left(-\\dfrac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)$ 给出，其中 $\\alpha$ 是埃瓦尔德屏蔽参数，$\\mathbf{k}$ 是倒易矢量。PME方法通过一个紧凑的分配核将电荷插值到网格上，以替代连续的 $\\rho(\\mathbf{r})$，该核的傅里叶变换会抑制高频模式。\n- 对于间距为 $\\Delta x$ 的均匀网格，逐维度的 $m$ 阶基数B样条分配给出了一个可分离的傅里叶衰减因子。在倒易空间中，每个笛卡尔分量 $k_d$ 的衰减为 $\\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x}{2}\\right)^m$，其中 $\\operatorname{sinc}(x) = \\dfrac{\\sin(x)}{x}$，三维因子是在 $d \\in \\{x,y,z\\}$ 上的乘积。\n\n设计任务：\n- 考虑一个边长 $L = 1$（任意长度单位，无量纲）的立方盒子。设粗网格每边有 $N_c$ 个点，间距为 $\\Delta x_c = \\dfrac{L}{N_c}$；细网格每边有 $N_f$ 个点，间距为 $\\Delta x_f = \\dfrac{L}{N_f}$。定义细网格分量的奈奎斯特波数 $k_{\\text{Ny},f} = \\pi N_f / L$。您将构建 $F_c(\\mathbf{k})$ 和 $F_f(\\mathbf{k})$ 作为 $\\lVert \\mathbf{k} \\rVert$ 的光滑径向函数，使用升余弦窗形成一个低通（$F_c$）和一个带通（$F_f$）滤波器：\n    - 粗网格滤波器 $F_c$ 是一个径向低通滤波器，其过渡中心位于 $k_c$，半宽为 $\\delta_c$，由升余弦过渡函数 $W(x)$ 定义。当 $x \\le -1$ 时 $W(x)$ 等于 $1$，当 $x \\ge +1$ 时等于 $0$，并在 $x \\in [-1,1]$ 区间内通过 $W(x) = \\dfrac{1}{2}\\left(1 + \\cos(\\pi x)\\right)$ 平滑插值。使用 $F_c(\\mathbf{k}) = W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)$。\n    - 细网格滤波器 $F_f$ 是粗网格过渡的高通互补滤波器与一个中心在 $k_f$、半宽为 $\\delta_f$ 的高频滚降低通滤波器的乘积：$F_f(\\mathbf{k}) = \\left(1 - W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\\right) \\cdot W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_f}{\\delta_f}\\right)$。其中，$k_c = \\gamma_c\\, k_{\\text{Ny},f}$，$k_f = \\gamma_f\\, k_{\\text{Ny},f}$，$\\gamma_c$ 和 $\\gamma_f$ 是给定的无量纲分数；$\\delta_c = \\eta_c\\, k_{\\text{Ny},f}$，$\\delta_f = \\eta_f\\, k_{\\text{Ny},f}$。\n- 在每个网格上的电荷分配使用基数B样条，粗网格的阶数为 $m_c$，细网格的阶数为 $m_f$。对应的三维衰减因子为 $S_c(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_c}{2}\\right)^{m_c}$ 和 $S_f(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_f}{2}\\right)^{m_f}$。\n- 双网格PME组合的倒易空间传递函数（单位电荷的势）为 $T(\\mathbf{k}) = G(\\mathbf{k}) \\left(F_c(\\mathbf{k}) S_c(\\mathbf{k}) + F_f(\\mathbf{k}) S_f(\\mathbf{k})\\right)$。每个模式的力振幅与 $\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})$ 成正比。\n\n程序要求：\n- 在由细网格导出的离散倒易晶格上进行计算：设每个分量 $k_d = \\dfrac{2\\pi n_d}{L}$，其中 $n_d \\in \\{-\\lfloor \\dfrac{N_f}{2}\\rfloor, \\ldots, \\lfloor \\dfrac{N_f}{2}\\rfloor\\}$。在任何分母或最大值计算中排除 $\\mathbf{k} = \\mathbf{0}$ 模式，以避免奇点。\n- 计算以下定量指标：\n    $1.$ 最小重叠：在离散晶格上计算 $O = \\text{mean}_{\\mathbf{k}} \\left(F_c(\\mathbf{k})^2 F_f(\\mathbf{k})^2\\right)$。\n    $2.$ 可用频带内的单位分解偏差：$E_{\\text{PU}} = \\max_{\\mathbf{k}} \\left|F_c(\\mathbf{k}) + F_f(\\mathbf{k}) - 1\\right|$，仅对满足 $\\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f$ 且 $\\mathbf{k} \\ne \\mathbf{0}$ 的模式进行评估。\n    $3.$ 力稳定性比率：$R = \\dfrac{\\max_{\\mathbf{k}} \\left(\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})\\right)}{\\max_{\\mathbf{k}} \\left(\\lVert \\mathbf{k} \\rVert \\, G(\\mathbf{k})\\right)}$，同样在 $\\mathbf{k} \\ne \\mathbf{0}$ 上计算。为保证稳定性，该值不应显著超过1。\n- 全程使用以 $L = 1$ 为基准的无量纲单位，并将所有输出表示为无量纲浮点数。如果使用角度，必须以弧度为单位。\n\n测试套件：\n为以下三个参数集提供结果，其中 $\\alpha$ 的单位是逆长度单位，但由于 $L=1$ 而是无量纲的：\n- 情况1（一般情况）：$\\alpha = 3.5$, $N_c = 16$, $N_f = 64$, $m_c = 4$, $m_f = 6$, $\\gamma_c = 0.30$, $\\eta_c = 0.05$, $\\gamma_f = 0.85$, $\\eta_f = 0.05$。\n- 情况2（高重叠边界）：$\\alpha = 3.5$, $N_c = 16$, $N_f = 64$, $m_c = 4$, $m_f = 6$, $\\gamma_c = 0.30$, $\\eta_c = 0.20$, $\\gamma_f = 0.85$, $\\eta_f = 0.05$。\n- 情况3（极粗的粗网格边缘情况）：$\\alpha = 3.0$, $N_c = 8$, $N_f = 64$, $m_c = 3$, $m_f = 6$, $\\gamma_c = 0.15$, $\\eta_c = 0.05$, $\\gamma_f = 0.90$, $\\eta_f = 0.05$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中按顺序包含了三个情况的三个指标（平铺展开）。例如，应打印出 $[O_1,E_{\\text{PU},1},R_1,O_2,E_{\\text{PU},2},R_2,O_3,E_{\\text{PU},3},R_3]$ 作为无量纲浮点数。",
            "solution": "所提出的问题是计算材料科学领域中一个有效且定义明确的任务，具体涉及分析粒子网格埃瓦尔德（PME）方法的双网格谱分裂方案。所有必需的物理常数、数学定义和数值参数均已提供，该问题具有科学依据、客观且内部一致。因此，我们可以着手提供完整解答。\n\n目标是通过为粗网格和细网格构建光滑的径向滤波器，来设计和评估一个双网格PME谱分裂方案，然后基于谱重叠、单位分解偏差和力响应稳定性来量化其性能。分析将在一个离散的倒易晶格上针对三组特定参数进行。\n\nPME方法的基础是库仑相互作用的埃瓦尔德分解，它将问题分解为一个短程的实空间部分和一个长程的倒易空间部分。倒易空间的贡献通过在网格上求解泊松方程来计算。势 $\\phi(\\mathbf{r})$ 与电荷密度 $\\rho(\\mathbf{r})$ 的关系为 $\\nabla^2 \\phi(\\mathbf{r}) = - \\rho(\\mathbf{r}) / \\varepsilon_0$。在倒易空间中，这变为 $\\lVert \\mathbf{k} \\rVert^2 \\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) / \\varepsilon_0$。埃瓦尔德技巧引入了一个屏蔽电荷分布，从而产生一个阻尼的实空间势和一个修正的倒易空间势。此阻尼相互作用的倒易空间格林函数表示为：\n$$\nG(\\mathbf{k}) = \\dfrac{4\\pi}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\!\\left(-\\dfrac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)\n$$\n其中 $\\mathbf{k}$ 是倒易空间矢量，$\\alpha$ 是埃瓦尔德屏蔽参数。\n\n我们的分析在一个边长为 $L=1$ 的无量纲立方周期性盒子中进行。倒易晶格矢量定义在一个对应于 $N_f \\times N_f \\times N_f$ 个点的细网格上。倒易矢量 $\\mathbf{k}$ 的分量由 $k_d = \\frac{2\\pi n_d}{L}$ 给出（对于 $d \\in \\{x,y,z\\}$），其中整数 $n_d$ 的范围是从 $-\\lfloor N_f/2 \\rfloor$ 到 $\\lfloor N_f/2 \\rfloor$。其大小为 $\\lVert \\mathbf{k} \\rVert = \\sqrt{k_x^2 + k_y^2 + k_z^2}$。$\\mathbf{k}=\\mathbf{0}$ 的特殊情况对应于系统的整体电荷中性，在涉及除以 $\\lVert \\mathbf{k} \\rVert$ 的计算或奇异量的最大值计算中被排除。\n\n双网格方法使用两个谱滤波器，$F_c(\\mathbf{k})$ 用于粗网格，$F_f(\\mathbf{k})$ 用于细网格，以划分倒易空间的计算。这些滤波器使用升余弦窗函数 $W(x)$ 构建，定义如下：\n$$\nW(x) =\n\\begin{cases}\n1  x \\le -1 \\\\\n\\frac{1}{2} (1 + \\cos(\\pi x))  -1  x  1 \\\\\n0  x \\ge 1\n\\end{cases}\n$$\n粗网格滤波器 $F_c(\\mathbf{k})$ 是一个低通滤波器，细网格滤波器 $F_f(\\mathbf{k})$ 是一个带通滤波器。它们的定义是：\n$$\nF_c(\\mathbf{k}) = W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\n$$\n$$\nF_f(\\mathbf{k}) = \\left(1 - W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\\right) \\cdot W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_f}{\\delta_f}\\right)\n$$\n过渡中心 $k_c, k_f$ 和半宽 $\\delta_c, \\delta_f$ 是相对于细网格奈奎斯特频率 $k_{\\text{Ny},f} = \\pi N_f/L$ 定义的：$k_c = \\gamma_c k_{\\text{Ny},f}$，$\\delta_c = \\eta_c k_{\\text{Ny},f}$，$k_f = \\gamma_f k_{\\text{Ny},f}$，以及 $\\delta_f = \\eta_f k_{\\text{Ny},f}$。\n\nPME方法使用一个分配函数（通常是 $m$ 阶的基数B样条）将粒子电荷插值到网格上。这个过程引入了一个傅里叶空间衰减因子 $S(\\mathbf{k})$。对于间距为 $\\Delta x_c = L/N_c$ 和 $\\Delta x_f = L/N_f$、样条阶数为 $m_c$ 和 $m_f$ 的粗细网格，这些因子是：\n$$\nS_c(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\left( \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_c}{2}\\right) \\right)^{m_c}\n$$\n$$\nS_f(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\left( \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_f}{2}\\right) \\right)^{m_f}\n$$\n其中问题指定 $\\operatorname{sinc}(x) = \\sin(x)/x$。\n\n双网格方案的总倒易空间传递函数 $T(\\mathbf{k})$ 结合了这些元素：\n$$\nT(\\mathbf{k}) = G(\\mathbf{k}) \\left( F_c(\\mathbf{k}) S_c(\\mathbf{k}) + F_f(\\mathbf{k}) S_f(\\mathbf{k}) \\right)\n$$\n我们现在将为每个参数集计算三个指定的指标。\n\n1.  **最小重叠, $O$**：该指标量化了两个滤波器同时非零的程度，这可能导致冗余计算。它被计算为在整个离散倒易晶格上滤波器函数乘积的均方值。\n    $$\n    O = \\text{mean}_{\\mathbf{k}} \\left(F_c(\\mathbf{k})^2 F_f(\\mathbf{k})^2\\right)\n    $$\n2.  **单位分解偏差, $E_{\\text{PU}}$**：在预期的波数工作频带内，滤波器之和理想情况下应为1，即 $F_c(\\mathbf{k}) + F_f(\\mathbf{k}) = 1$，以确保所有谱分量都被精确捕获一次。我们在由 $\\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f$ 定义的频带内评估与此理想情况的最大偏差。\n    $$\n    E_{\\text{PU}} = \\max_{\\mathbf{k}, \\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f, \\mathbf{k} \\ne \\mathbf{0}} \\left| F_c(\\mathbf{k}) + F_f(\\mathbf{k}) - 1 \\right|\n    $$\n    根据构造，在此频带内，项 $W((\\lVert \\mathbf{k} \\rVert - k_f)/\\delta_f)$ 精确为 $1$，这使得 $F_f(\\mathbf{k}) = 1 - F_c(\\mathbf{k})$。因此，解析上 $F_c(\\mathbf{k})+F_f(\\mathbf{k})=1$，而 $E_{\\text{PU}}$ 在浮点精度范围内应为零。\n\n3.  **力稳定性比率, $R$**：粒子上的力与势的梯度有关，在倒易空间中对应于乘以 $i\\mathbf{k}$。来自模式 $\\mathbf{k}$ 的力贡献的大小与 $\\lVert \\mathbf{k} \\rVert T(\\mathbf{k})$ 成正比。一个稳定的数值方案不应与基线阻尼相互作用 $G(\\mathbf{k})$ 相比过度放大高频模式。比率 $R$ 比较了PME方案的最大力振幅与纯阻尼相互作用的最大力振幅。\n    $$\n    R = \\dfrac{\\max_{\\mathbf{k} \\ne \\mathbf{0}} \\left(\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})\\right)}{\\max_{\\mathbf{k} \\ne \\mathbf{0}} \\left(\\lVert \\mathbf{k} \\rVert \\, G(\\mathbf{k})\\right)}\n    $$\n    $R$ 的值接近 $1$ 是理想的。\n\n以下程序为三个指定的测试用例实现了这些计算，将倒易晶格和所有中间函数构造为多维数组以实现高效计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PME two-grid spectral splitting problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, Nc, Nf, mc, mf, gamma_c, eta_c, gamma_f, eta_f)\n        (3.5, 16, 64, 4, 6, 0.30, 0.05, 0.85, 0.05), # Case 1\n        (3.5, 16, 64, 4, 6, 0.30, 0.20, 0.85, 0.05), # Case 2\n        (3.0, 8, 64, 3, 6, 0.15, 0.05, 0.90, 0.05),  # Case 3\n    ]\n\n    results = []\n\n    def my_sinc(x):\n        \"\"\"Custom sinc(x) = sin(x)/x, as defined in the problem.\"\"\"\n        x = np.asanyarray(x)\n        y = np.ones_like(x, dtype=float)\n        # Numerically stable for x - 0, where sinc(x) - 1\n        nonzero_mask = x != 0\n        y[nonzero_mask] = np.sin(x[nonzero_mask]) / x[nonzero_mask]\n        return y\n\n    def raised_cosine_window(x):\n        \"\"\"Raised-cosine window function W(x).\"\"\"\n        x = np.asanyarray(x)\n        y = np.zeros_like(x, dtype=float)\n        \n        cond1 = x  -1\n        cond3 = x  1\n        cond2 = ~cond1  ~cond3 # -1  x  1\n        \n        y[cond1] = 1.0\n        y[cond2] = 0.5 * (1.0 + np.cos(np.pi * x[cond2]))\n        # y[cond3] is already 0.0\n        \n        return y\n\n    for case in test_cases:\n        alpha, N_c, N_f, m_c, m_f, gamma_c, eta_c, gamma_f, eta_f = case\n        \n        L = 1.0\n        \n        # Grid spacings\n        delta_xc = L / N_c\n        delta_xf = L / N_f\n        \n        # Reciprocal space parameters\n        k_ny_f = np.pi * N_f / L\n        k_c = gamma_c * k_ny_f\n        delta_c = eta_c * k_ny_f\n        k_f = gamma_f * k_ny_f\n        delta_f = eta_f * k_ny_f\n        \n        # Create reciprocal lattice\n        n_range = np.arange(-np.floor(N_f / 2), np.floor(N_f / 2) + 1)\n        nx, ny, nz = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n        \n        kx = 2.0 * np.pi * nx / L\n        ky = 2.0 * np.pi * ny / L\n        kz = 2.0 * np.pi * nz / L\n        \n        k_norm = np.sqrt(kx**2 + ky**2 + kz**2)\n        k_norm_sq = k_norm**2\n        \n        # Mask for k=0 mode\n        k_is_not_zero = k_norm != 0\n        \n        # --- Component Functions ---\n        \n        # Green's function G(k)\n        G_k = np.zeros_like(k_norm)\n        G_k[k_is_not_zero] = (4.0 * np.pi / k_norm_sq[k_is_not_zero]) * \\\n                           np.exp(-k_norm_sq[k_is_not_zero] / (4.0 * alpha**2))\n        \n        # Filters Fc(k) and Ff(k)\n        arg_c = np.zeros_like(k_norm)\n        arg_c[delta_c != 0] = (k_norm[delta_c != 0] - k_c) / delta_c\n        F_c = raised_cosine_window(arg_c)\n        \n        arg_f = np.zeros_like(k_norm)\n        arg_f[delta_f != 0] = (k_norm[delta_f != 0] - k_f) / delta_f\n        F_f = (1.0 - F_c) * raised_cosine_window(arg_f)\n        \n        # Spline attenuation factors Sc(k) and Sf(k)\n        Sc_kx = my_sinc(kx * delta_xc / 2.0)**m_c\n        Sc_ky = my_sinc(ky * delta_xc / 2.0)**m_c\n        Sc_kz = my_sinc(kz * delta_xc / 2.0)**m_c\n        S_c = Sc_kx * Sc_ky * Sc_kz\n        \n        Sf_kx = my_sinc(kx * delta_xf / 2.0)**m_f\n        Sf_ky = my_sinc(ky * delta_xf / 2.0)**m_f\n        Sf_kz = my_sinc(kz * delta_xf / 2.0)**m_f\n        S_f = Sf_kx * Sf_ky * Sf_kz\n        \n        # --- Metrics Calculation ---\n        \n        # 1. Minimal overlap O\n        overlap = np.mean(F_c**2 * F_f**2)\n        results.append(overlap)\n        \n        # 2. Partition-of-unity deviation E_PU\n        pu_mask = (k_norm  (k_f - delta_f))  k_is_not_zero\n        if np.any(pu_mask):\n            pu_dev = np.max(np.abs(F_c[pu_mask] + F_f[pu_mask] - 1.0))\n        else:\n            pu_dev = 0.0 # No points in the evaluation domain\n        results.append(pu_dev)\n        \n        # 3. Force stability ratio R\n        T_k = G_k * (F_c * S_c + F_f * S_f)\n        \n        force_T = k_norm * T_k\n        force_G = k_norm * G_k\n        \n        max_force_T = np.max(force_T[k_is_not_zero])\n        max_force_G = np.max(force_G[k_is_not_zero])\n        \n        force_ratio = max_force_T / max_force_G if max_force_G != 0 else 0.0\n        results.append(force_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在高性能计算环境中，理解和预测算法的性能至关重要。本练习  将理论与实践相结合，要求你为并行PME算法构建一个参数化的性能模型。通过将总执行时间分解为与粒子数、网格大小和通信相关的项，并使用微基准测试数据进行校准，你将学会如何量化和预测大规模模拟的计算成本。",
            "id": "3473535",
            "problem": "您的任务是，在一台分布式内存并行机上，为使用Pencil分解的三维快速傅里叶变换（FFT）的粒子网格埃瓦尔德（PME）方法，推导、实现并校准一个参数化性能模型。目标是从PME流水线中算法工作量和通信的第一性原理出发，构建一个包含三个基项的模型，这三个基项分别代表短程粒子操作、网格空间计算以及由全局转置引起的进程间通信。然后，您必须使用提供的微基准测试测量值来估计未知的标量系数，并使用校准后的模型为新的参数集预测执行时间。\n\n假设粒子网格埃瓦尔德（PME）方法具有以下科学基础：\n\n- 在固定的截断半径和插值阶数下，短程和电荷分配操作的工作量与粒子数 $N$ 呈线性伸缩，每个粒子的工作量为常数。这为我们提供了一个与 $N$ 成比例的基项。\n- 在线性尺寸为 $m$ 的立方网格上进行的三维快速傅里叶变换（FFT）大约执行 $\\mathcal{O}(m^3 \\log m)$ 次算术运算，这为我们提供了一个与 $m^3 \\log m$ 成比例的基项，其中 $\\log$ 表示自然对数。\n- 在 $P$ 个进程（消息传递接口（MPI）进程）上使用Pencil分解时，需要两次全局转置。每次转置的通信伙伴数量增长趋势如同 $\\sqrt{P}$，每个进程交换的总数据量伸缩趋势如同 $m^3/P$。基于此，定义一个无量纲归一化通信函数\n$$\n\\mathrm{comm}(P,m) =\n\\begin{cases}\n0,  P = 1, \\\\\n2\\left(\\sqrt{P}-1 + \\dfrac{m^3}{P}\\right),  P  1,\n\\end{cases}\n$$\n该函数将类延迟和类带宽的贡献捆绑成一个单一的无量纲量，捕捉了在 $P$ 和 $m$ 上的主要伸缩关系。该项作为一个通信基项，将通过一个未知标量转换为秒。\n\n您的任务是：\n1. 从上述基础出发，将总PME时间表示为对应于 $N$、$m^3 \\log m$ 和 $\\mathrm{comm}(P,m)$ 的三个基项的线性组合，其中包含三个必须由数据确定的未知标量系数。\n2. 使用提供的微基准测试测量值和线性最小二乘法来拟合这些系数。\n3. 使用拟合后的模型为给定的测试套件中的 $(N,m,P)$ 值预测执行时间。\n\n所有时间都必须以秒为单位表示。此问题不涉及角度。\n\n您将获得由元组 $(N,m,P,T_{\\mathrm{meas}})$ 组成的微基准测试测量值，其中 $T_{\\mathrm{meas}}$ 是测得的总墙钟时间（秒）：\n- $(200000, 64, 1, 0.114523)$\n- $(200000, 96, 1, 0.409523)$\n- $(500000, 64, 1, 0.122000)$\n- $(1000000, 128, 1, 1.044748)$\n- $(200000, 64, 16, 0.154130)$\n- $(500000, 96, 16, 0.550020)$\n- $(1000000, 128, 16, 1.358830)$\n- $(200000, 128, 64, 1.103410)$\n- $(1000000, 64, 64, 0.144448)$\n- $(500000, 128, 4, 2.291540)$\n- $(0, 96, 16, 0.537020)$\n- $(800000, 96, 4, 0.955767)$\n\n使用这些测量值校准模型系数，然后为以下参数值 $(N,m,P)$ 的测试套件生成预测：\n- $(700000, 96, 16)$\n- $(1000000, 128, 64)$\n- $(200000, 64, 1)$\n- $(500000, 128, 4)$\n- $(1000000, 64, 64)$\n\n您的程序应生成单行输出，其中包含上述五个测试用例的预测时间，形式为用方括号括起来的逗号分隔列表，每个数字四舍五入到六位小数，例如 $[t_1,t_2,t_3,t_4,t_5]$，其中每个 $t_i$ 的单位为秒。\n\n澄清和约束：\n- 使用自然对数计算 $\\log$。\n- 将 $N$ 和 $m$ 视为正整数，$P$ 视为表示并行进程数量的正整数。\n- 通信基项 $\\mathrm{comm}(P,m)$ 在构造上是无量纲的，必须通过拟合的标量系数转换为秒。\n- 拟合必须使用输入的微基准测试测量值，通过线性最小二乘法进行。\n- 对测试套件的运行时间预测必须以秒为单位，并四舍五入到六位小数。",
            "solution": "该问题要求为粒子网格埃瓦尔德（PME）方法构建和校准一个参数化性能模型。总执行时间 $T$ 将被建模为三个基函数的线性组合，这三个基函数代表了不同的计算核心：基于粒子的工作、基于网格的工作和进程间通信。\n\n该模型由以下线性方程给出：\n$$\nT_{\\text{pred}}(N, m, P) = c_N f_N(N) + c_m f_m(m) + c_P f_P(P, m)\n$$\n其中 $N$ 是粒子数，$m$ 是FFT网格的线性尺寸，$P$ 是并行进程数。系数 $c_N$、$c_m$ 和 $c_P$ 是未知的标量常数，分别代表每个基函数单位工作量的时间成本。\n\n根据问题陈述，基函数定义如下：\n$1$. **粒子项**：短程相互作用和电荷分配的工作量与粒子数 $N$ 呈线性伸缩。因此，第一个基函数是 $f_N(N) = N$。\n$2$. **网格项**：在 $m \\times m \\times m$ 网格上进行三维快速傅里叶变换（FFT）的工作量与 $m^3 \\log m$ 成正比。因此，第二个基函数是 $f_m(m) = m^3 \\log m$，其中 $\\log$ 是自然对数。\n$3$. **通信项**：并行FFT的通信开销由所提供的无量纲函数 $\\mathrm{comm}(P, m)$ 建模。因此，第三个基函数是 $f_P(P, m) = \\mathrm{comm}(P, m)$，定义为：\n$$\n\\mathrm{comm}(P,m) =\n\\begin{cases}\n0,  \\text{if } P = 1, \\\\\n2\\left(\\sqrt{P}-1 + \\dfrac{m^3}{P}\\right),  \\text{if } P  1.\n\\end{cases}\n$$\n\n因此，完整的性能模型是：\n$$\nT_{\\text{pred}}(N, m, P) = c_N N + c_m (m^3 \\log m) + c_P \\mathrm{comm}(P, m)\n$$\n我们的目标是使用一组实验测量值来确定系数 $c_N$、$c_m$ 和 $c_P$。给定 $k=12$ 个微基准测试测量值，每个都是一个元组 $(N_i, m_i, P_i, T_{\\text{meas},i})$，其中 $i=1, \\dots, 12$。对于每个测量值，我们可以写出模型方程的一个实例：\n$$\nT_{\\text{meas},i} \\approx c_N N_i + c_m (m_i^3 \\log m_i) + c_P \\mathrm{comm}(P_i, m_i)\n$$\n这构成了一个线性方程组，可以表示为矩阵形式 $\\mathbf{y} \\approx \\mathbf{A}\\mathbf{c}$，其中：\n- $\\mathbf{y}$ 是一个 $12 \\times 1$ 的列向量，由测量的次数 $T_{\\text{meas},i}$ 组成。\n- $\\mathbf{c}$ 是我们试图找到的 $3 \\times 1$ 的未知系数列向量：$\\mathbf{c} = [c_N, c_m, c_P]^T$。\n- $\\mathbf{A}$ 是 $12 \\times 3$ 的设计矩阵，其中第 $i$ 行由第 $i$ 次测量的基函数值组成：\n$$\n\\mathbf{A}_{i,:} = \\begin{bmatrix} N_i  m_i^3 \\log m_i  \\mathrm{comm}(P_i, m_i) \\end{bmatrix}\n$$\n由于我们的测量次数（$12$）多于未知系数的数量（$3$），该系统是超定的。$\\mathbf{c}$ 的最佳拟合解是通过最小化残差平方和 $r_i = T_{\\text{meas},i} - T_{\\text{pred},i}$ 求得的。这是一个标准的线性最小二乘问题。使残差向量的欧几里得范数 $\\|\\mathbf{y} - \\mathbf{A}\\mathbf{c}\\|_2$ 最小化的解 $\\mathbf{c}$ 由正规方程组的解给出：\n$$\n\\mathbf{A}^T \\mathbf{A} \\mathbf{c} = \\mathbf{A}^T \\mathbf{y}\n$$\n假设 $\\mathbf{A}^T \\mathbf{A}$ 是可逆的，解为 $\\mathbf{c} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{y}$。在计算上，这可以通过诸如QR分解等方法高效且稳健地求解，这些方法已在NumPy等库中实现。\n\n步骤如下：\n$1$. 根据提供的微基准测试数据，构建 $12 \\times 3$ 的设计矩阵 $\\mathbf{A}$ 和 $12 \\times 1$ 的测量向量 $\\mathbf{y}$。\n$2$. 求解线性最小二乘系统 $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{y}$，以获得系数向量 $\\mathbf{c} = [c_N, c_m, c_P]^T$。\n$3$. 有了校准后的系数，性能模型就完全确定了。\n$4$. 对于测试套件中的 $5$ 个参数集中的每一个 $(N_j, m_j, P_j)$，计算一个预测向量 $\\mathbf{a}_j = [N_j, m_j^3 \\log m_j, \\mathrm{comm}(P_j, m_j)]$。\n$5$. 预测时间是点积 $T_{\\text{pred}, j} = \\mathbf{a}_j \\cdot \\mathbf{c}$。然后将这些预测收集起来并格式化为最终结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, calibrates, and applies a parametric performance model for PME.\n    \n    The model is T_pred = c_N*N + c_m*(m^3*log(m)) + c_P*comm(P,m).\n    The coefficients [c_N, c_m, c_P] are found by a linear least squares fit\n    to the provided microbenchmark data. The calibrated model is then used to\n    predict execution times for a new set of test cases.\n    \"\"\"\n    \n    # Define the custom communication basis function.\n    def comm_func(P, m):\n        \"\"\"\n        Calculates the dimensionless communication cost.\n        \"\"\"\n        if P == 1:\n            return 0.0\n        # The problem statement defines P as a positive integer.\n        # So P  1 is the only other case.\n        return 2.0 * (np.sqrt(P) - 1.0 + float(m**3) / P)\n\n    # Microbenchmark measurements: (N, m, P, T_meas)\n    benchmarks = [\n        (200000, 64, 1, 0.114523),\n        (200000, 96, 1, 0.409523),\n        (500000, 64, 1, 0.122000),\n        (1000000, 128, 1, 1.044748),\n        (200000, 64, 16, 0.154130),\n        (500000, 96, 16, 0.550020),\n        (1000000, 128, 16, 1.358830),\n        (200000, 128, 64, 1.103410),\n        (1000000, 64, 64, 0.144448),\n        (500000, 128, 4, 2.291540),\n        (0, 96, 16, 0.537020),\n        (800000, 96, 4, 0.955767),\n    ]\n\n    num_benchmarks = len(benchmarks)\n    # The model has 3 basis functions, so the design matrix has 3 columns.\n    num_coeffs = 3\n    \n    # A is the design matrix, y is the vector of measured times.\n    A = np.zeros((num_benchmarks, num_coeffs))\n    y = np.zeros(num_benchmarks)\n\n    for i, (N, m, P, T_meas) in enumerate(benchmarks):\n        # Basis function 1: N\n        f_N = float(N)\n        # Basis function 2: m^3 * log(m)\n        f_m = float(m**3) * np.log(m) if m  0 else 0.0\n        # Basis function 3: comm(P, m)\n        f_P = comm_func(P, m)\n        \n        A[i, :] = [f_N, f_m, f_P]\n        y[i] = T_meas\n\n    # Solve the linear least squares problem A*c = y for coefficients c.\n    coeffs, residuals, rank, s = np.linalg.lstsq(A, y, rcond=None)\n    c_N, c_m, c_P = coeffs\n\n    # Test suite for predictions: (N, m, P)\n    test_cases = [\n        (700000, 96, 16),\n        (1000000, 128, 64),\n        (200000, 64, 1),\n        (500000, 128, 4),\n        (1000000, 64, 64),\n    ]\n\n    predictions = []\n    for N_test, m_test, P_test in test_cases:\n        # Construct the feature vector for the test case.\n        f_N_test = float(N_test)\n        f_m_test = float(m_test**3) * np.log(m_test) if m_test  0 else 0.0\n        f_P_test = comm_func(P_test, m_test)\n        \n        feature_vector = np.array([f_N_test, f_m_test, f_P_test])\n        \n        # Predict the time using the calibrated model.\n        T_pred = np.dot(feature_vector, coeffs)\n        predictions.append(T_pred)\n\n    # Format the final output string as specified.\n    # Each number must be rounded to six decimal places.\n    # Using \"{:.6f}\".format() handles this requirement correctly.\n    formatted_results = [f\"{t:.6f}\" for t in predictions]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}