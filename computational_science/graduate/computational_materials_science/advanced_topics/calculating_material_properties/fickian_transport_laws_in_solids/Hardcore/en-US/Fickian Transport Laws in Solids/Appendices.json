{
    "hands_on_practices": [
        {
            "introduction": "This practice will explore the microscopic underpinnings of Fick's law, moving beyond its simple phenomenological form. By comparing the standard Fickian model with a lattice-gas model that explicitly accounts for site-exclusion effects, you will derive the concentration dependence of diffusivity from first principles. This exercise  is crucial for understanding the limits of the constant-diffusivity approximation and for developing more accurate transport models in systems with high solute concentrations.",
            "id": "3451875",
            "problem": "You are asked to implement and analyze one-dimensional mass transport in a solid following two constitutive laws that originate from different physical assumptions: a lattice-gas exclusion model and Fick's law. The objective is to determine, from first principles and computational verification, the ranges of site-fraction concentration where Fickian behavior is not an adequate approximation of the lattice-gas model. All quantities must be treated in the International System of Units (SI), except concentration, which is a dimensionless site fraction in the interval $\\left(0,1\\right)$. Your final program must compute and report results for a specified test suite.\n\nFundamental base and definitions to be used:\n- The continuity equation in one spatial dimension is $\\,\\partial c/\\partial t + \\partial J/\\partial x = 0\\,$, where $\\,c(x,t)\\,$ is the site-fraction concentration and $\\,J(x,t)\\,$ is the number flux.\n- Nonequilibrium thermodynamics at isothermal conditions implies a constitutive relation tying flux to gradients in chemical potential $\\,\\mu\\,$ via a mobility. For the lattice-gas with site exclusion, the local chemical potential for non-interacting occupants on a lattice is $\\,\\mu(c) = k_{\\mathrm{B}} T \\ln\\!\\left(\\dfrac{c}{1-c}\\right)\\,$, where $\\,k_{\\mathrm{B}}\\,$ is the Boltzmann constant and $\\,T\\,$ is the absolute temperature.\n- Let $\\,M_{\\mathrm{p}}(c)\\,$ denote the per-particle mobility, with units $\\mathrm{s}/\\mathrm{kg}$. Assume $\\,M_{\\mathrm{p}}(c) = D_0/(k_{\\mathrm{B}} T)\\,$, where $\\,D_0\\,$ is a reference tracer diffusivity with units $\\mathrm{m}^2/\\mathrm{s}$. The lattice-gas constitutive law for number flux is $\\,J_{\\mathrm{LG}} = - M_{\\mathrm{p}}(c)\\, c\\, \\nabla \\mu\\,$. In one dimension, this is $\\,J_{\\mathrm{LG}}(x) = - M_{\\mathrm{p}}(c(x))\\, c(x)\\, \\dfrac{\\mathrm{d}\\mu}{\\mathrm{d}x}\\,$.\n- Fick's law with a constant diffusivity $\\,D_0\\,$ is $\\,J_{\\mathrm{F}} = - D_0 \\nabla c\\,$, or in one dimension $\\,J_{\\mathrm{F}}(x) = - D_0 \\dfrac{\\mathrm{d} c}{\\mathrm{d} x}\\,$.\n\nTask:\n1. Starting from the above definitions, derive an expression for the instantaneous local relative deviation between the Fickian flux $\\,J_{\\mathrm{F}}\\,$ and the lattice-gas flux $\\,J_{\\mathrm{LG}}\\,$ in terms of the local concentration $\\,c\\,$. Your derivation must proceed from the stated fundamental base and should not invoke any unprovided shortcut formulas. Express the final relative deviation as a function of $\\,c\\,$ alone.\n2. Implement a numerical verification in a one-dimensional periodic domain of length $\\,L\\,$ by constructing a stationary concentration profile $\\,c(x) = \\bar{c} + a \\sin(2\\pi x/L)\\,$. Here $\\,\\bar{c}\\,$ is the spatial average concentration and $\\,a\\,$ is an amplitude chosen so that $\\,c(x)\\in(0,1)\\,$ everywhere. Use a uniform grid with $\\,N\\,$ points and periodic finite differences to compute spatial gradients. Use $\\,N = 20001\\,$ and $\\,L = 1\\times 10^{-6}\\,\\mathrm{m}\\,$. Use $\\,k_{\\mathrm{B}} = 1.380\\,649\\times 10^{-23}\\,\\mathrm{J/K}\\,$, $\\,T = 1000\\,\\mathrm{K}\\,$, and $\\,D_0 = 1\\times 10^{-14}\\,\\mathrm{m}^2/\\mathrm{s}\\,$. Ensure numerical stability in the presence of the logarithm by bounding $\\,c(x)\\,$ away from $\\,0\\,$ and $\\,1\\,$ by a small $\\,\\varepsilon = 10^{-9}\\,$ when evaluating $\\,\\mu(c)\\,$.\n3. For each grid point, compute the instantaneous lattice-gas flux $\\,J_{\\mathrm{LG}}(x)\\,$ and the instantaneous Fickian flux $\\,J_{\\mathrm{F}}(x)\\,$ using the given constitutive relations. Define the pointwise relative deviation as $\\,r(x) = \\dfrac{\\lvert J_{\\mathrm{F}}(x) - J_{\\mathrm{LG}}(x)\\rvert}{\\max\\left(\\lvert J_{\\mathrm{LG}}(x)\\rvert, \\tau\\right)}\\,$ with $\\,\\tau = 10^{-30}\\,$ to avoid division by zero at stationary points where the gradient vanishes.\n4. For a specified tolerance $\\,\\delta\\in(0,1)\\,$, define the failure set as the set of positions where $\\,r(x) \\ge \\delta\\,$. Map this set to its concentration values $\\,c(x)\\,$. If the failure set is empty, report $\\,\\left[0.0, 0.0\\right]\\,$. Otherwise, report the minimum and maximum concentrations over the failure set, rounded to three decimal places.\n5. Implement the computation for the following test suite of parameter triplets $\\,\\left(\\bar{c}, a, \\delta\\right)\\,$, which have been chosen to probe dilute, intermediate, and near-saturation regimes, as well as near-threshold and broad-coverage cases:\n   - Test $\\,1\\,$: $\\left(\\bar{c}, a, \\delta\\right) = \\left(0.1, 0.05, 0.2\\right)$.\n   - Test $\\,2\\,$: $\\left(\\bar{c}, a, \\delta\\right) = \\left(0.3, 0.1, 0.25\\right)$.\n   - Test $\\,3\\,$: $\\left(\\bar{c}, a, \\delta\\right) = \\left(0.8, 0.15, 0.1\\right)$.\n   - Test $\\,4\\,$: $\\left(\\bar{c}, a, \\delta\\right) = \\left(0.5, 0.49, 0.5\\right)$.\n   - Test $\\,5\\,$: $\\left(\\bar{c}, a, \\delta\\right) = \\left(0.02, 0.015, 0.03\\right)$.\n6. Units and numerical outputs:\n   - The concentration is dimensionless. All other inputs and intermediate quantities must be treated in SI units as specified.\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a test case and is itself a two-element list of the lower and upper concentration bounds of failure, rounded to three decimal places. For example, a valid output format is $\\left[\\left[0.000,0.000\\right],\\left[0.250,0.400\\right],\\dots\\right]$.\n\nYour final deliverable must be a complete, runnable program that carries out the above tasks and prints only the described single-line output for the specified test suite. No external input is permitted, and no files may be read or written.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of non-equilibrium thermodynamics and transport phenomena, specifically Fickian diffusion and its relation to a more fundamental lattice-gas model. The problem is well-posed, with all necessary constants, definitions, and boundary conditions provided for a unique solution. The language is objective and precise, and the tasks are structured to lead to a verifiable result. Therefore, a full solution will be provided.\n\nThe solution is presented in two parts: first, an analytical derivation of the relationship between the two flux models and the resulting relative deviation, and second, a description of the numerical algorithm designed to verify this relationship.\n\n### Part 1: Analytical Derivation\n\nThe problem defines two constitutive laws for one-dimensional mass flux. Fick's first law with a constant diffusivity $D_0$ is given by:\n$$\nJ_{\\mathrm{F}}(x) = - D_0 \\frac{\\mathrm{d} c}{\\mathrm{d} x}\n$$\nThe lattice-gas model, based on non-equilibrium thermodynamics, defines the flux $J_{\\mathrm{LG}}$ in terms of the chemical potential gradient:\n$$\nJ_{\\mathrm{LG}}(x) = - M_{\\mathrm{p}}(c(x))\\, c(x)\\, \\frac{\\mathrm{d}\\mu}{\\mathrm{d}x}\n$$\nThe provided definitions for the per-particle mobility $M_{\\mathrm{p}}(c)$ and the chemical potential $\\mu(c)$ are:\n$$\nM_{\\mathrm{p}}(c) = \\frac{D_0}{k_{\\mathrm{B}} T}\n$$\n$$\n\\mu(c) = k_{\\mathrm{B}} T \\ln\\left(\\frac{c}{1-c}\\right)\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant and $T$ is the absolute temperature.\n\nTo relate $J_{\\mathrm{LG}}$ to the concentration gradient $\\frac{\\mathrm{d}c}{\\mathrm{d}x}$, we first apply the chain rule to the derivative of the chemical potential:\n$$\n\\frac{\\mathrm{d}\\mu}{\\mathrm{d}x} = \\frac{\\mathrm{d}\\mu}{\\mathrm{d}c} \\frac{\\mathrm{d}c}{\\mathrm{d}x}\n$$\nThe derivative of $\\mu(c)$ with respect to $c$ is:\n$$\n\\frac{\\mathrm{d}\\mu}{\\mathrm{d}c} = \\frac{\\mathrm{d}}{\\mathrm{d}c} \\left[ k_{\\mathrm{B}} T (\\ln(c) - \\ln(1-c)) \\right] = k_{\\mathrm{B}} T \\left( \\frac{1}{c} + \\frac{1}{1-c} \\right) = k_{\\mathrm{B}} T \\frac{1-c+c}{c(1-c)} = \\frac{k_{\\mathrm{B}} T}{c(1-c)}\n$$\nNow, we substitute this result and the expression for $M_{\\mathrm{p}}(c)$ into the formula for $J_{\\mathrm{LG}}(x)$:\n$$\nJ_{\\mathrm{LG}}(x) = - \\left(\\frac{D_0}{k_{\\mathrm{B}} T}\\right) c(x) \\left(\\frac{k_{\\mathrm{B}} T}{c(x)(1-c(x))}\\right) \\frac{\\mathrm{d}c}{\\mathrm{d}x}\n$$\nThe terms $k_{\\mathrm{B}}T$ and $c(x)$ cancel, leading to a simplified expression for the lattice-gas flux:\n$$\nJ_{\\mathrm{LG}}(x) = - \\frac{D_0}{1-c(x)} \\frac{\\mathrm{d}c}{\\mathrm{d}x}\n$$\nBy comparing this to the Fickian flux $J_{\\mathrm{F}}(x)$, we find a direct relationship:\n$$\nJ_{\\mathrm{LG}}(x) = \\frac{1}{1-c(x)} \\left(-D_0 \\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right) = \\frac{1}{1-c(x)} J_{\\mathrm{F}}(x)\n$$\nThis demonstrates that the lattice-gas model is equivalent to Fickian diffusion with a concentration-dependent diffusivity $D(c) = D_0 / (1-c)$. Fick's law with constant diffusivity $D_0$ is recovered only in the dilute limit where $c \\to 0$. From this relationship, we can also write $J_{\\mathrm{F}}(x) = (1-c(x)) J_{\\mathrm{LG}}(x)$.\n\nNext, we derive an expression for the pointwise relative deviation, defined as:\n$$\nr(x) = \\frac{\\lvert J_{\\mathrm{F}}(x) - J_{\\mathrm{LG}}(x)\\rvert}{\\max\\left(\\lvert J_{\\mathrm{LG}}(x)\\rvert, \\tau\\right)}\n$$\nUsing the relation $J_{\\mathrm{F}}(x) = (1-c(x)) J_{\\mathrm{LG}}(x)$, we simplify the numerator:\n$$\n\\lvert J_{\\mathrm{F}}(x) - J_{\\mathrm{LG}}(x)\\rvert = \\lvert (1-c(x)) J_{\\mathrm{LG}}(x) - J_{\\mathrm{LG}}(x)\\rvert = \\lvert -c(x) J_{\\mathrm{LG}}(x)\\rvert = c(x) \\lvert J_{\\mathrm{LG}}(x)\\rvert\n$$\nsince the concentration $c(x)$ is always positive. The relative deviation becomes:\n$$\nr(x) = \\frac{c(x) \\lvert J_{\\mathrm{LG}}(x)\\rvert}{\\max\\left(\\lvert J_{\\mathrm{LG}}(x)\\rvert, \\tau\\right)}\n$$\nThe flux $\\lvert J_{\\mathrm{LG}}(x)\\rvert$ is non-zero wherever $\\frac{\\mathrm{d}c}{\\mathrm{d}x} \\neq 0$. For all points where $\\lvert J_{\\mathrm{LG}}(x)\\rvert \\ge \\tau$, the expression simplifies to:\n$$\nr(x) = c(x)\n$$\nThe regularization parameter $\\tau = 10^{-30}$ is extremely small. The flux magnitude will only fall below this value in infinitesimally small regions around the extrema of the concentration profile where the gradient vanishes. Therefore, for practical purposes, the failure condition $r(x) \\ge \\delta$ is equivalent to $c(x) \\ge \\delta$.\n\nThe failure set, consisting of points where Fick's law is a poor approximation, thus corresponds to the regions where the local concentration $c(x)$ exceeds the tolerance $\\delta$.\n\n### Part 2: Numerical Implementation and Algorithm\n\nThe numerical verification is structured to compute the fluxes and their deviation from first principles without relying on the analytical simplification derived above. This serves as a robust check of the theory.\n\n1.  **Discretization**: A one-dimensional periodic domain of length $L = 1 \\times 10^{-6}\\,\\mathrm{m}$ is discretized into a uniform grid of $N = 20001$ points. The grid spacing is $h = L/N$. The spatial coordinates are represented by the array $x_i = i \\cdot h$ for $i = 0, \\dots, N-1$.\n\n2.  **Concentration Profile**: For each test case $(\\bar{c}, a, \\delta)$, the stationary concentration profile is computed at each grid point:\n    $$\n    c_i = c(x_i) = \\bar{c} + a \\sin(2\\pi x_i/L)\n    $$\n\n3.  **Gradient Calculation**: Spatial gradients are computed using a second-order central finite difference scheme that respects the periodic boundary conditions. For a generic function $f(x)$ on the grid, its derivative at point $i$ is approximated as:\n    $$\n    \\frac{\\mathrm{d}f}{\\mathrm{d}x}\\bigg|_{i} \\approx \\frac{f_{i+1} - f_{i-1}}{2h}\n    $$\n    The periodic nature is handled by wrapping around the indices (e.g., $f_{N} \\equiv f_0$ and $f_{-1} \\equiv f_{N-1}$).\n\n4.  **Flux Computation**:\n    -   **Fickian Flux ($J_{\\mathrm{F}}$)**: First, the concentration gradient $\\frac{\\mathrm{d}c}{\\mathrm{d}x}$ is calculated using the finite difference scheme. Then, the flux is computed as $J_{\\mathrm{F},i} = -D_0 \\left(\\frac{\\mathrm{d}c}{\\mathrm{d}x}\\right)_i$.\n    -   **Lattice-Gas Flux ($J_{\\mathrm{LG}}$)**: This is computed following the fundamental definitions.\n        a. The chemical potential $\\mu_i = \\mu(c_i)$ is calculated. To avoid numerical instability from the logarithm, the concentration values $c_i$ are first clipped to the range $[\\varepsilon, 1-\\varepsilon]$, where $\\varepsilon = 10^{-9}$.\n        $$\n        c_{\\text{clamped},i} = \\max(\\varepsilon, \\min(c_i, 1-\\varepsilon))\n        $$\n        $$\n        \\mu_i = k_{\\mathrm{B}} T \\ln\\left(\\frac{c_{\\text{clamped},i}}{1-c_{\\text{clamped},i}}\\right)\n        $$\n        b. The gradient of the chemical potential, $\\left(\\frac{\\mathrm{d}\\mu}{\\mathrm{d}x}\\right)_i$, is computed using the same periodic central difference scheme on the array of $\\mu_i$ values.\n        c. The per-particle mobility $M_p = D_0/(k_{\\mathrm{B}}T)$ is calculated.\n        d. Finally, the lattice-gas flux is assembled: $J_{\\mathrm{LG},i} = -M_p \\cdot c_i \\cdot \\left(\\frac{\\mathrm{d}\\mu}{\\mathrm{d}x}\\right)_i$. Note that the original, unclamped concentration $c_i$ is used as the prefactor.\n\n5.  **Failure Set Analysis**:\n    a. The pointwise relative deviation $r_i$ is computed for each grid point $i$ using the given formula, with $\\tau=10^{-30}$ for regularization.\n    b. A boolean mask identifies all points in the \"failure set\" where $r_i \\ge \\delta$.\n    c. If this mask is empty (i.e., no points satisfy the condition), the result for the test case is $[0.0, 0.0]$.\n    d. Otherwise, the concentrations $c_i$ corresponding to the failure set are collected. The minimum and maximum values of this collection are found, providing the bounds of the concentration range where the Fickian approximation fails. These bounds are then rounded to three decimal places.\n\nThis comprehensive numerical procedure, when executed for the given test suite, verifies the analytical finding that the failure region is determined by the condition $c(x) \\ge \\delta$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the concentration range where the Fickian model deviates from a\n    lattice-gas model by a given tolerance, for a set of test cases.\n    \"\"\"\n    # Define physical and numerical constants from the problem statement\n    N = 20001\n    L = 1.0e-6  # meters\n    k_B = 1.380649e-23  # J/K\n    T = 1000.0  # K\n    D_0 = 1.0e-14  # m²/s\n    epsilon = 1.0e-9\n    tau = 1.0e-30\n\n    # Define the test suite of parameter triplets (c_bar, a, delta)\n    test_cases = [\n        (0.1, 0.05, 0.2),    # Test 1\n        (0.3, 0.1, 0.25),   # Test 2\n        (0.8, 0.15, 0.1),   # Test 3\n        (0.5, 0.49, 0.5),   # Test 4\n        (0.02, 0.015, 0.03), # Test 5\n    ]\n\n    all_results = []\n\n    # Setup the discretized one-dimensional periodic spatial grid\n    x = np.linspace(0, L, N, endpoint=False)\n    h = L / N  # Grid spacing\n\n    # Process each test case\n    for c_bar, a, delta in test_cases:\n        # 1. Construct the stationary concentration profile c(x)\n        c = c_bar + a * np.sin(2 * np.pi * x / L)\n\n        # 2. Compute the Fickian flux J_F\n        # Gradient of concentration using second-order periodic central differences\n        dc_dx = (np.roll(c, -1) - np.roll(c, 1)) / (2 * h)\n        J_F = -D_0 * dc_dx\n\n        # 3. Compute the Lattice-Gas flux J_LG from fundamental definitions\n        # Clamp concentration to avoid log(0) or division by zero in mu\n        c_clamped = np.clip(c, epsilon, 1 - epsilon)\n        \n        # Chemical potential mu(c)\n        mu = k_B * T * np.log(c_clamped / (1 - c_clamped))\n        \n        # Gradient of chemical potential using second-order periodic central differences\n        dmu_dx = (np.roll(mu, -1) - np.roll(mu, 1)) / (2 * h)\n        \n        # Per-particle mobility M_p\n        M_p = D_0 / (k_B * T)\n        \n        # Assemble the lattice-gas flux J_LG (using original unclamped c)\n        J_LG = -M_p * c * dmu_dx\n\n        # 4. Compute the pointwise relative deviation r(x)\n        numerator = np.abs(J_F - J_LG)\n        denominator = np.maximum(np.abs(J_LG), tau)\n        r = numerator / denominator\n\n        # 5. Determine the failure set and its concentration range\n        # The failure set consists of points where the deviation exceeds the tolerance\n        failure_mask = r >= delta\n        \n        if not np.any(failure_mask):\n            # If the failure set is empty, report [0.0, 0.0]\n            result = [0.0, 0.0]\n        else:\n            # Otherwise, find the min and max concentrations in the failure set\n            c_in_failure_set = c[failure_mask]\n            min_c = np.min(c_in_failure_set)\n            max_c = np.max(c_in_failure_set)\n            result = [min_c, max_c]\n        \n        all_results.append(result)\n\n    # 6. Format the final output string as specified\n    formatted_results = []\n    for res in all_results:\n        # Round each bound to three decimal places\n        formatted_results.append(f\"[{res[0]:.3f},{res[1]:.3f}]\")\n    \n    # Print the single-line output\n    print(f\"[{','.join(formatted_results)}]\")\n\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "Real crystalline solids are often anisotropic, meaning their properties vary with direction. This practice bridges the atomistic and continuum scales to quantify and predict anisotropic diffusion, a key feature of layered materials. You will use synthetic Molecular Dynamics (MD) trajectories to extract the principal components of the diffusion tensor, $D_\\parallel$ and $D_\\perp$, via the Einstein relation, and then use these to predict the elliptical spread of a diffusing species . This workflow is fundamental to multiscale modeling, demonstrating how macroscopic transport coefficients are derived from atom-level dynamics.",
            "id": "3451861",
            "problem": "Consider the problem of anisotropic Fickian transport in a two-dimensional cross-section of a layered crystalline solid, with principal directions aligned along the Cartesian axes. The layered planes are parallel to the $x$-axis and stacking is along the $y$-axis. You are provided synthetic Molecular Dynamics (MD) trajectories that emulate the long-time diffusive motion of non-interacting tracer atoms in this solid. Your task is to build a program that, starting from first principles, quantifies the uniaxial anisotropy and predicts anisotropic diffusion fronts.\n\nBegin from a valid fundamental base: conservation of mass and the linear response form of Fick’s first law with an anisotropic transport tensor. From these principles, derive the governing transport equation appropriate for solids with a constant anisotropic diffusivity tensor, and identify the fundamental solution for a point-source initialization under these conditions. In parallel, connect the diffusive motion observed in MD to the macroscopic transport coefficients, using the appropriate long-time relation between the mean-squared displacement and the diffusion coefficients along each principal axis. Use these derivations to design a numerically robust algorithm that:\n- Estimates $D_\\parallel$ along $x$ and $D_\\perp$ along $y$ from MD trajectories by regressing the mean-squared displacement versus time at long times, separately for each axis.\n- Predicts, at a specified evaluation time $t_\\text{eval}$, the positions $x_\\text{front}$ and $y_\\text{front}$ along the $x$- and $y$-axes, respectively, where the concentration equals a prescribed threshold $c_\\text{th}$, given a point-source total mass $M$ at $t=0$.\n\nScientific realism constraints:\n- Treat the diffusivity tensor as constant and diagonal in the laboratory frame, reflecting homogeneous layered crystals with principal axes aligned to the coordinates.\n- Treat the MD trajectories as dilute, non-interacting tracers, whose long-time statistics reflect independent Gaussian increments consistent with diffusive motion in solids.\n\nUnits and outputs:\n- Diffusion coefficients must be reported in $\\mathrm{m^2/s}$.\n- Distances must be reported in $\\mathrm{m}$.\n- All final numerical results must be printed as floating-point numbers. No angles are used in this task.\n\nTest suite and required parameters:\nFor each test case, your program must generate synthetic MD trajectories using independent Gaussian increments with zero mean and variance consistent with diffusive motion along each axis. Specifically, for a time step $\\Delta t$, the per-step increment along axis $i \\in \\{x,y\\}$ is drawn from a normal distribution with variance $2 D_i \\Delta t$. Use a fixed pseudo-random seed per case to ensure reproducibility. The program must then estimate $D_\\parallel$ and $D_\\perp$ from the generated trajectories, and subsequently compute $x_\\text{front}$ and $y_\\text{front}$ at $t_\\text{eval}$ using the derived anisotropic solution.\n\nImplement the following three scientifically plausible test cases:\n\n- Case A (happy path, isotropic limit):\n  - True diffusivities: $D_\\parallel = 2\\times 10^{-17}\\ \\mathrm{m^2/s}$, $D_\\perp = 2\\times 10^{-17}\\ \\mathrm{m^2/s}$.\n  - Number of particles: $N_\\text{p} = 500$.\n  - Number of time steps: $N_\\text{steps} = 400$.\n  - Time step: $\\Delta t = 100\\ \\mathrm{s}$.\n  - Evaluation time: $t_\\text{eval} = N_\\text{steps}\\,\\Delta t = 40000\\ \\mathrm{s}$.\n  - Point-source mass: $M = 1.0$.\n  - Concentration threshold: $c_\\text{th} = 10^{10}$.\n  - Random seed: $s = 42$.\n\n- Case B (moderate anisotropy, layered crystal):\n  - True diffusivities: $D_\\parallel = 1\\times 10^{-16}\\ \\mathrm{m^2/s}$, $D_\\perp = 1\\times 10^{-18}\\ \\mathrm{m^2/s}$.\n  - Number of particles: $N_\\text{p} = 800$.\n  - Number of time steps: $N_\\text{steps} = 600$.\n  - Time step: $\\Delta t = 100\\ \\mathrm{s}$.\n  - Evaluation time: $t_\\text{eval} = N_\\text{steps}\\,\\Delta t = 60000\\ \\mathrm{s}$.\n  - Point-source mass: $M = 1.0$.\n  - Concentration threshold: $c_\\text{th} = 2\\times 10^{10}$.\n  - Random seed: $s = 12345$.\n\n- Case C (edge case, extreme anisotropy with near-blocked perpendicular transport):\n  - True diffusivities: $D_\\parallel = 5\\times 10^{-17}\\ \\mathrm{m^2/s}$, $D_\\perp = 1\\times 10^{-21}\\ \\mathrm{m^2/s}$.\n  - Number of particles: $N_\\text{p} = 400$.\n  - Number of time steps: $N_\\text{steps} = 500$.\n  - Time step: $\\Delta t = 200\\ \\mathrm{s}$.\n  - Evaluation time: $t_\\text{eval} = N_\\text{steps}\\,\\Delta t = 100000\\ \\mathrm{s}$.\n  - Point-source mass: $M = 1.0$.\n  - Concentration threshold: $c_\\text{th} = 10^{11}$.\n  - Random seed: $s = 2023$.\n\nAlgorithmic requirements:\n- Construct the MD trajectories by cumulative summation of per-step increments along $x$ and $y$ for $N_\\text{p}$ independent particles, starting from zero displacement at $t=0$.\n- Compute the mean-squared displacement along each axis, $\\langle \\Delta x(t)^2\\rangle$ and $\\langle \\Delta y(t)^2\\rangle$, by averaging over particles at each time step $t_k = k\\,\\Delta t$ for $k=1,\\dots,N_\\text{steps}$.\n- Estimate $D_\\parallel$ and $D_\\perp$ by linear least-squares fitting of the mean-squared displacement versus time over the last $70\\%$ of the time samples. Extract the slope $a_i$ for $i\\in\\{x,y\\}$ and return the estimate $D_i = a_i / 2$.\n- Using the derived anisotropic fundamental solution for a point-source total mass $M$ at time $t_\\text{eval}$, compute the axial front locations $x_\\text{front}$ and $y_\\text{front}$ where the concentration equals $c_\\text{th}$. Ensure that the logarithmic argument required by your derived expressions is strictly positive; if it is not, return a Not-a-Number result for the corresponding front location in that test case.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list of four floats in the order $[D_\\parallel, D_\\perp, x_\\text{front}, y_\\text{front}]$, with $D_\\parallel$ and $D_\\perp$ in $\\mathrm{m^2/s}$ and $x_\\text{front}$ and $y_\\text{front}$ in $\\mathrm{m}$. The overall output must therefore be a list of three such lists, one per test case, for example, $[[d_{1x},d_{1y},x_1,y_1],[d_{2x},d_{2y},x_2,y_2],[d_{3x},d_{3y},x_3,y_3]]$.",
            "solution": "The scientific foundation begins with conservation of mass and Fick’s first law for solids. Denote the concentration by $c(\\mathbf{r},t)$ and the flux by $\\mathbf{J}(\\mathbf{r},t)$. Conservation requires\n$$\n\\frac{\\partial c}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0.\n$$\nFor anisotropic Fickian transport, the linear response connects the flux to concentration gradients via a constant second-rank tensor $\\mathbf{D}$,\n$$\n\\mathbf{J} = -\\mathbf{D}\\,\\nabla c,\n$$\nwhere $\\mathbf{D}$ is positive-definite and, in the principal axes of the layered crystal, is diagonal with entries $D_\\parallel$ along $x$ and $D_\\perp$ along $y$. Substituting $\\mathbf{J}$ into conservation yields the anisotropic diffusion equation\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left(\\mathbf{D}\\,\\nabla c\\right).\n$$\nIn two dimensions with $\\mathbf{D}=\\mathrm{diag}(D_\\parallel,D_\\perp)$ and an unbounded domain, the fundamental solution (Green’s function) for a point source of total mass $M$ at the origin at $t=0$ is the anisotropic Gaussian\n$$\nc(x,y,t) = \\frac{M}{4\\pi t \\sqrt{D_\\parallel D_\\perp}} \\exp\\!\\left(-\\frac{x^2}{4 D_\\parallel t} - \\frac{y^2}{4 D_\\perp t}\\right).\n$$\nThis solution follows from Fourier transform methods: applying the spatial Fourier transform decouples the linear, constant-coefficient partial differential equation into an ordinary differential equation in time for each wavevector $\\mathbf{k}$, whose solution in Fourier space is $\\hat{c}(\\mathbf{k},t) = \\hat{c}(\\mathbf{k},0)\\exp\\!\\left(-t\\,(D_\\parallel k_x^2 + D_\\perp k_y^2)\\right)$; inversion yields the Gaussian above.\n\nTo connect Molecular Dynamics (MD) trajectories to the macroscopic transport coefficients, use the Einstein relation along each principal axis. For a tracer particle executing a stationary, ergodic random walk with uncorrelated increments in the long-time regime, the mean-squared displacement (MSD) along axis $i \\in \\{x,y\\}$ scales linearly with time:\n$$\n\\left\\langle \\Delta r_i(t)^2 \\right\\rangle = 2 D_i t \\quad \\text{as } t \\to \\infty,\n$$\nwhere $D_i$ is the corresponding component of the diffusion tensor. For an ensemble of $N_\\text{p}$ independent tracers, the empirical MSD at discrete times $t_k = k\\,\\Delta t$ is computed by averaging the squared displacements over particles, $\\left\\langle \\Delta r_i(t_k)^2 \\right\\rangle = \\frac{1}{N_\\text{p}}\\sum_{n=1}^{N_\\text{p}} \\left(r_{i,n}(t_k) - r_{i,n}(0)\\right)^2$. A linear least-squares regression of $\\left\\langle \\Delta r_i(t)^2 \\right\\rangle$ versus $t$ over the late-time window estimates the slope $a_i$, yielding $D_i \\approx a_i/2$.\n\nOnce $D_\\parallel$ and $D_\\perp$ are estimated, the axial diffusion fronts at a prescribed threshold $c_\\text{th}$ at time $t_\\text{eval}$ are found by solving for the positions along the coordinate axes where the concentration equals $c_\\text{th}$. Along the $x$-axis ($y=0$), the solution reduces to\n$$\nc(x,0,t_\\text{eval}) = \\frac{M}{4\\pi t_\\text{eval} \\sqrt{D_\\parallel D_\\perp}} \\exp\\!\\left(-\\frac{x^2}{4 D_\\parallel t_\\text{eval}}\\right),\n$$\nand the front $x_\\text{front}$ satisfies\n$$\n\\exp\\!\\left(-\\frac{x_\\text{front}^2}{4 D_\\parallel t_\\text{eval}}\\right) = c_\\text{th}\\,\\frac{4\\pi t_\\text{eval} \\sqrt{D_\\parallel D_\\perp}}{M}.\n$$\nAssuming $0  c_\\text{th}  \\frac{M}{4\\pi t_\\text{eval} \\sqrt{D_\\parallel D_\\perp}}$ so that the right-hand side is in $(0,1)$, the solution is\n$$\nx_\\text{front} = \\sqrt{ -4 D_\\parallel t_\\text{eval} \\,\\ln\\!\\left( c_\\text{th}\\,\\frac{4\\pi t_\\text{eval} \\sqrt{D_\\parallel D_\\perp}}{M} \\right) }.\n$$\nSimilarly, along the $y$-axis ($x=0$),\n$$\ny_\\text{front} = \\sqrt{ -4 D_\\perp t_\\text{eval} \\,\\ln\\!\\left( c_\\text{th}\\,\\frac{4\\pi t_\\text{eval} \\sqrt{D_\\parallel D_\\perp}}{M} \\right) }.\n$$\n\nAlgorithmic implementation details:\n- Synthetic MD generation: For each case, draw, at each time step of duration $\\Delta t$, independent Gaussian increments $\\Delta x \\sim \\mathcal{N}\\!\\left(0,\\,2 D_\\parallel \\Delta t\\right)$ and $\\Delta y \\sim \\mathcal{N}\\!\\left(0,\\,2 D_\\perp \\Delta t\\right)$ for each of $N_\\text{p}$ particles. Cumulatively sum these increments to build positions $x_n(t_k)$ and $y_n(t_k)$, initializing at zero for $t_0=0$. Fix the pseudo-random seed $s$ per case for reproducibility.\n- MSD estimation: At each $t_k$, compute $\\langle \\Delta x(t_k)^2 \\rangle$ and $\\langle \\Delta y(t_k)^2 \\rangle$ by averaging over particles. Use the last $70\\%$ of $\\{t_k\\}$ to fit $\\langle \\Delta x(t)^2 \\rangle \\approx a_x t + b_x$ and $\\langle \\Delta y(t)^2 \\rangle \\approx a_y t + b_y$. Report $D_\\parallel = a_x/2$ and $D_\\perp = a_y/2$.\n- Front computation: Evaluate the logarithmic argument $A = c_\\text{th}\\,\\frac{4\\pi t_\\text{eval} \\sqrt{D_\\parallel D_\\perp}}{M}$. If $A \\le 0$ or $A \\ge 1$, the requested front is not defined in the unbounded Gaussian model at that threshold and time; in this case, return Not-a-Number for both $x_\\text{front}$ and $y_\\text{front}$. Otherwise, compute $x_\\text{front}$ and $y_\\text{front}$ using the formulas above.\n\nApplying this method to the specified test suite:\n- Case A has $D_\\parallel = 2\\times 10^{-17}\\ \\mathrm{m^2/s}$, $D_\\perp = 2\\times 10^{-17}\\ \\mathrm{m^2/s}$, $N_\\text{p}=500$, $N_\\text{steps}=400$, $\\Delta t=100\\ \\mathrm{s}$, $t_\\text{eval}=40000\\ \\mathrm{s}$, $M=1.0$, $c_\\text{th}=10^{10}$, $s=42$. The algorithm will estimate $D_\\parallel$ and $D_\\perp$ close to their true values, and the fronts will be equal along $x$ and $y$.\n- Case B has $D_\\parallel = 1\\times 10^{-16}\\ \\mathrm{m^2/s}$, $D_\\perp = 1\\times 10^{-18}\\ \\mathrm{m^2/s}$, $N_\\text{p}=800$, $N_\\text{steps}=600$, $\\Delta t=100\\ \\mathrm{s}$, $t_\\text{eval}=60000\\ \\mathrm{s}$, $M=1.0$, $c_\\text{th}=2\\times 10^{10}$, $s=12345$. The algorithm will capture a much larger $x$-axis front than $y$-axis front, consistent with anisotropy.\n- Case C has $D_\\parallel = 5\\times 10^{-17}\\ \\mathrm{m^2/s}$, $D_\\perp = 1\\times 10^{-21}\\ \\mathrm{m^2/s}$, $N_\\text{p}=400$, $N_\\text{steps}=500$, $\\Delta t=200\\ \\mathrm{s}$, $t_\\text{eval}=100000\\ \\mathrm{s}$, $M=1.0$, $c_\\text{th}=10^{11}$, $s=2023$. The algorithm will predict a front orders of magnitude larger along $x$ than along $y$, reflecting near-blocked perpendicular diffusion.\n\nThe final program must aggregate the results for the three cases into a single line formatted as $[[D_{\\parallel,A},D_{\\perp,A},x_{\\text{front},A},y_{\\text{front},A}],[D_{\\parallel,B},D_{\\perp,B},x_{\\text{front},B},y_{\\text{front},B}],[D_{\\parallel,C},D_{\\perp,C},x_{\\text{front},C},y_{\\text{front},C}]]$ and print that line exactly.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_diffusion_coefficients(msd_times, msd_values):\n    # Fit MSD(t) ~ a * t + b over times and return D = a/2\n    # Use numpy polyfit for linear regression\n    a, b = np.polyfit(msd_times, msd_values, 1)\n    return a / 2.0\n\ndef generate_md_trajectories(Dx, Dy, Np, Nsteps, dt, seed):\n    # Generate synthetic MD trajectories: positions over time for Np particles\n    rng = np.random.default_rng(seed)\n    # Increments: shape (Np, Nsteps) for each axis\n    std_x = np.sqrt(2.0 * Dx * dt)\n    std_y = np.sqrt(2.0 * Dy * dt)\n    inc_x = rng.normal(loc=0.0, scale=std_x, size=(Np, Nsteps))\n    inc_y = rng.normal(loc=0.0, scale=std_y, size=(Np, Nsteps))\n    # Positions by cumulative sum along time\n    pos_x = np.cumsum(inc_x, axis=1)\n    pos_y = np.cumsum(inc_y, axis=1)\n    return pos_x, pos_y\n\ndef compute_msd(pos, dt):\n    # pos: shape (Np, Nsteps), initial position at t=0 is zero implicitly\n    # Times: t_k = (k+1) * dt (since first column is after first increment)\n    Nsteps = pos.shape[1]\n    times = dt * np.arange(1, Nsteps + 1)\n    # MSD at each time step: average over particles of squared displacement\n    msd = np.mean(pos**2, axis=0)\n    return times, msd\n\ndef compute_fronts(Dx_est, Dy_est, M, c_th, t_eval):\n    # Compute front positions along axes using anisotropic Gaussian solution\n    # Argument for logarithm:\n    arg = c_th * (4.0 * np.pi * t_eval * np.sqrt(Dx_est * Dy_est)) / M\n    if not (arg > 0.0 and arg  1.0):\n        return np.nan, np.nan\n    ln_arg = np.log(arg)\n    x_front = np.sqrt(-4.0 * Dx_est * t_eval * ln_arg)\n    y_front = np.sqrt(-4.0 * Dy_est * t_eval * ln_arg)\n    return x_front, y_front\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Dx_true, Dy_true, Np, Nsteps, dt, t_eval, M, c_th, seed)\n    test_cases = [\n        (2e-17, 2e-17, 500, 400, 100.0, 40000.0, 1.0, 1e10, 42),\n        (1e-16, 1e-18, 800, 600, 100.0, 60000.0, 1.0, 2e10, 12345),\n        (5e-17, 1e-21, 400, 500, 200.0, 100000.0, 1.0, 1e11, 2023),\n    ]\n\n    results = []\n    for Dx_true, Dy_true, Np, Nsteps, dt, t_eval, M, c_th, seed in test_cases:\n        # Generate synthetic MD trajectories\n        pos_x, pos_y = generate_md_trajectories(Dx_true, Dy_true, Np, Nsteps, dt, seed)\n        # Compute MSD vs time for each axis\n        times_x, msd_x = compute_msd(pos_x, dt)\n        times_y, msd_y = compute_msd(pos_y, dt)\n        # Use last 70% of times for regression\n        start_idx = int(0.3 * Nsteps)  # index where the last 70% begins\n        Dx_est = estimate_diffusion_coefficients(times_x[start_idx:], msd_x[start_idx:])\n        Dy_est = estimate_diffusion_coefficients(times_y[start_idx:], msd_y[start_idx:])\n        # Compute anisotropic diffusion fronts at t_eval using estimated D\n        x_front, y_front = compute_fronts(Dx_est, Dy_est, M, c_th, t_eval)\n        results.append([Dx_est, Dy_est, x_front, y_front])\n\n    # Final print statement in the exact required format.\n    # Ensure floats print in a compact representation.\n    print(f\"[{','.join('[' + ','.join(map(str, case)) + ']' for case in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Extracting reliable diffusion coefficients from experimental data is a critical skill in materials science, but raw data is often convoluted by measurement artifacts. This exercise  simulates the realistic analysis of a Secondary Ion Mass Spectrometry (SIMS) depth profile, where the true Fickian profile is broadened by instrumental effects. By modeling the measured signal as a convolution of the ideal $\\text{erfc}$ solution with a Gaussian point-spread function, you will learn to deconvolve these effects, fit for the underlying diffusivity $D$, and rigorously assess the uncertainty in your result.",
            "id": "3451877",
            "problem": "Consider one-dimensional tracer diffusion into a semi-infinite, homogeneous, isotropic solid with constant diffusivity. Start from Fick’s second law and core definitions. You are given that a Secondary Ion Mass Spectrometry (SIMS) depth profile after an anneal displays an error-function-like shape. Your tasks are to (i) derive from first principles the ideal concentration profile under appropriate initial and boundary conditions, and (ii) incorporate realistic measurement effects by modeling the measured SIMS profile as a depth-wise convolution of the ideal profile with a Gaussian point-spread function that represents the combined effect of sputter-induced atomic mixing and instrument depth resolution. Treat the combined broadening as the quadrature sum of the two contributions. Your program must synthesize data, fit the diffusivity, and estimate uncertainty in the diffusivity due to uncertainty in the broadening parameters.\n\nFundamental base:\n- Fick’s second law in one dimension: $\\frac{\\partial C}{\\partial t} = D \\frac{\\partial^2 C}{\\partial x^2}$ for constant $D$.\n- Semi-infinite solid occupying $x \\ge 0$; initial condition is a step in surface concentration consistent with a constant surface activity source during anneal; boundary at $x = 0$ maintains a fixed surface driving condition during the anneal; concentration vanishes far from the surface as $x \\to \\infty$.\n- The measured concentration profile $M(x)$ is the convolution $M(x) = \\frac{\\displaystyle \\int_{0}^{L} C(x') \\, G(x - x'; \\sigma_{\\mathrm{tot}}) \\, dx'}{\\displaystyle \\int_{0}^{L} G(x - x'; \\sigma_{\\mathrm{tot}}) \\, dx'}$, where $G(\\Delta; \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\!\\left(-\\frac{\\Delta^2}{2\\sigma^2}\\right)$ is the Gaussian kernel, and the denominator enforces proper normalization on the finite interval $\\left[0,L\\right]$. The total broadening is $\\sigma_{\\mathrm{tot}} = \\sqrt{\\sigma_{\\mathrm{res}}^2 + \\sigma_{\\mathrm{sput}}^2}$, with $\\sigma_{\\mathrm{res}}$ the instrument depth resolution and $\\sigma_{\\mathrm{sput}}$ the sputter-induced mixing length. Amplitude scaling and a small baseline offset may be present in the SIMS signal.\n\nTasks your program must perform:\n- For each test case below, synthesize a “measured” SIMS profile by computing the ideal Fickian profile for the given anneal time with a known true diffusivity, convolving it with a Gaussian kernel using the true total broadening, and adding zero-mean Gaussian noise with a specified standard deviation.\n- Fit the measured profile to extract the best-fit diffusivity $D$ while holding the total broadening fixed at its nominal value (the midpoint of the stated uncertainty ranges), allowing for an overall amplitude factor and a constant baseline offset in the fit.\n- Estimate the uncertainty in the fitted $D$ arising solely from the uncertainty in $\\sigma_{\\mathrm{res}}$ and $\\sigma_{\\mathrm{sput}}$ by repeating the fit at the lower and upper bounds of $\\sigma_{\\mathrm{tot}}$ obtained by combining the stated bounds in quadrature, then reporting the minimum and maximum fitted $D$ across these two refits.\n- Use a fixed pseudo-random seed of $0$ for noise generation to ensure reproducibility.\n- Express the diffusivity in $\\mathrm{m}^2/\\mathrm{s}$.\n\nTest suite (three cases). In all cases, use the specified depth range and sampling to define $x \\in [0,L]$ with uniform spacing $\\Delta x$, and treat the system as semi-infinite within $[0,L]$ for synthesis and fitting. All numbers below are to be used exactly as provided.\n\n- Case A (general “happy path”):\n  - Anneal time: $t = 7.2 \\times 10^{3}\\ \\mathrm{s}$.\n  - True diffusivity: $D_{\\mathrm{true}} = 3.0 \\times 10^{-17}\\ \\mathrm{m}^2/\\mathrm{s}$.\n  - Instrument resolution range: $\\sigma_{\\mathrm{res}} \\in \\left[1.0 \\times 10^{-9},\\, 2.0 \\times 10^{-9}\\right]\\ \\mathrm{m}$.\n  - Sputter mixing range: $\\sigma_{\\mathrm{sput}} \\in \\left[2.0 \\times 10^{-9},\\, 3.0 \\times 10^{-9}\\right]\\ \\mathrm{m}$.\n  - Depth domain and sampling: $L = 1.5 \\times 10^{-6}\\ \\mathrm{m}$, $\\Delta x = 5.0 \\times 10^{-9}\\ \\mathrm{m}$.\n  - Amplitude and baseline used for synthesis: $A_{\\mathrm{true}} = 1.0$, $B_{\\mathrm{true}} = 0.0$ (dimensionless SIMS units).\n  - Additive noise standard deviation: $\\sigma_{\\mathrm{noise}} = 2.0 \\times 10^{-3}$ (dimensionless SIMS units).\n- Case B (boundary condition with near-ideal resolution):\n  - Anneal time: $t = 1.0 \\times 10^{4}\\ \\mathrm{s}$.\n  - True diffusivity: $D_{\\mathrm{true}} = 1.0 \\times 10^{-18}\\ \\mathrm{m}^2/\\mathrm{s}$.\n  - Instrument resolution range: $\\sigma_{\\mathrm{res}} \\in \\left[0.0,\\, 0.5 \\times 10^{-9}\\right]\\ \\mathrm{m}$.\n  - Sputter mixing range: $\\sigma_{\\mathrm{sput}} \\in \\left[0.0,\\, 0.5 \\times 10^{-9}\\right]\\ \\mathrm{m}$.\n  - Depth domain and sampling: $L = 4.0 \\times 10^{-7}\\ \\mathrm{m}$, $\\Delta x = 2.0 \\times 10^{-9}\\ \\mathrm{m}$.\n  - Amplitude and baseline used for synthesis: $A_{\\mathrm{true}} = 1.0$, $B_{\\mathrm{true}} = 0.0$ (dimensionless SIMS units).\n  - Additive noise standard deviation: $\\sigma_{\\mathrm{noise}} = 2.0 \\times 10^{-3}$ (dimensionless SIMS units).\n- Case C (edge case with broadening comparable to or exceeding diffusion length):\n  - Anneal time: $t = 3.6 \\times 10^{3}\\ \\mathrm{s}$.\n  - True diffusivity: $D_{\\mathrm{true}} = 1.0 \\times 10^{-20}\\ \\mathrm{m}^2/\\mathrm{s}$.\n  - Instrument resolution range: $\\sigma_{\\mathrm{res}} \\in \\left[7.0 \\times 10^{-9},\\, 9.0 \\times 10^{-9}\\right]\\ \\mathrm{m}$.\n  - Sputter mixing range: $\\sigma_{\\mathrm{sput}} \\in \\left[9.0 \\times 10^{-9},\\, 11.0 \\times 10^{-9}\\right]\\ \\mathrm{m}$.\n  - Depth domain and sampling: $L = 2.0 \\times 10^{-7}\\ \\mathrm{m}$, $\\Delta x = 2.0 \\times 10^{-9}\\ \\mathrm{m}$.\n  - Amplitude and baseline used for synthesis: $A_{\\mathrm{true}} = 1.0$, $B_{\\mathrm{true}} = 0.0$ (dimensionless SIMS units).\n  - Additive noise standard deviation: $\\sigma_{\\mathrm{noise}} = 2.0 \\times 10^{-3}$ (dimensionless SIMS units).\n\nAlgorithmic requirements:\n- Derive and implement the ideal semi-infinite solution of Fick’s second law for the stated initial and boundary conditions using a similarity-variable approach.\n- Implement the finite-interval Gaussian convolution with proper normalization at each depth to avoid edge bias near $x=0$ and $x=L$.\n- Use nonlinear least squares to fit the diffusivity $D$ together with an amplitude $A$ and baseline $B$, holding $\\sigma_{\\mathrm{tot}}$ fixed at the nominal value $\\sigma_{\\mathrm{tot,nom}} = \\sqrt{\\left(\\frac{\\sigma_{\\mathrm{res,min}} + \\sigma_{\\mathrm{res,max}}}{2}\\right)^2 + \\left(\\frac{\\sigma_{\\mathrm{sput,min}} + \\sigma_{\\mathrm{sput,max}}}{2}\\right)^2}$.\n- For uncertainty estimation, perform two additional refits at the extreme total broadenings $\\sigma_{\\mathrm{tot,low}} = \\sqrt{\\sigma_{\\mathrm{res,min}}^2 + \\sigma_{\\mathrm{sput,min}}^2}$ and $\\sigma_{\\mathrm{tot,high}} = \\sqrt{\\sigma_{\\mathrm{res,max}}^2 + \\sigma_{\\mathrm{sput,max}}^2}$, and report the minimum and maximum fitted $D$ across these two refits, along with the nominal-fit $D$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of three lists, one per test case, each inner list containing three floating-point numbers in scientific notation representing $[D_{\\mathrm{nom}}, D_{\\mathrm{low}}, D_{\\mathrm{high}}]$ in $\\mathrm{m}^2/\\mathrm{s}$. For example: $\\left[\\left[d_{1,\\mathrm{nom}},d_{1,\\mathrm{low}},d_{1,\\mathrm{high}}\\right],\\left[d_{2,\\mathrm{nom}},d_{2,\\mathrm{low}},d_{2,\\mathrm{high}}\\right],\\left[d_{3,\\mathrm{nom}},d_{3,\\mathrm{low}},d_{3,\\mathrm{high}}\\right]\\right]$.",
            "solution": "The problem requires the derivation of a concentration profile for one-dimensional tracer diffusion in a semi-infinite solid, the synthesis of simulated experimental data including measurement artifacts, and the subsequent fitting of this data to extract the diffusivity and estimate its uncertainty. This process is divided into a theoretical derivation and a computational implementation.\n\n**Part 1: Derivation of the Ideal Concentration Profile**\n\nThe physical process is governed by Fick's second law for constant diffusivity $D$ in one dimension $x$:\n$$ \\frac{\\partial C}{\\partial t} = D \\frac{\\partial^2 C}{\\partial x^2} $$\nwhere $C(x, t)$ is the concentration of the tracer species at depth $x$ and time $t$. The problem specifies a semi-infinite solid occupying the domain $x \\ge 0$, with the following initial and boundary conditions:\n1.  Initial Condition (IC): The solid is initially free of the tracer for $x  0$.\n    $$ C(x, 0) = 0 \\quad \\text{for } x  0 $$\n2.  Boundary Condition 1 (BC1): A constant surface concentration, $C_s$, is maintained at the boundary $x=0$ for all time during the anneal ($t0$).\n    $$ C(0, t) = C_s \\quad \\text{for } t  0 $$\n3.  Boundary Condition 2 (BC2): The concentration vanishes far from the surface.\n    $$ \\lim_{x\\to\\infty} C(x, t) = 0 \\quad \\text{for } t  0 $$\n\nThis partial differential equation (PDE) with its associated conditions can be solved using the similarity transformation method. The characteristic length scale of diffusion is $\\sqrt{Dt}$, which suggests a dimensionless similarity variable $\\eta$ that combines $x$ and $t$. The conventional choice is:\n$$ \\eta = \\frac{x}{2\\sqrt{Dt}} $$\nWe postulate a solution of the form $C(x, t) = f(\\eta)$. The derivatives of $C$ with respect to $t$ and $x$ are transformed using the chain rule:\n$$ \\frac{\\partial C}{\\partial t} = \\frac{df}{d\\eta}\\frac{\\partial \\eta}{\\partial t} = f'(\\eta) \\left( \\frac{x}{2\\sqrt{D}} \\cdot \\left(-\\frac{1}{2}t^{-3/2}\\right) \\right) = -f'(\\eta) \\frac{x}{4\\sqrt{D}t^{3/2}} = -f'(\\eta)\\frac{\\eta}{2t} $$\n$$ \\frac{\\partial C}{\\partial x} = \\frac{df}{d\\eta}\\frac{\\partial \\eta}{\\partial x} = f'(\\eta) \\frac{1}{2\\sqrt{Dt}} $$\n$$ \\frac{\\partial^2 C}{\\partial x^2} = \\frac{\\partial}{\\partial x}\\left(f'(\\eta) \\frac{1}{2\\sqrt{Dt}}\\right) = f''(\\eta) \\frac{\\partial \\eta}{\\partial x} \\frac{1}{2\\sqrt{Dt}} = f''(\\eta) \\left(\\frac{1}{2\\sqrt{Dt}}\\right)^2 = \\frac{f''(\\eta)}{4Dt} $$\nSubstituting these derivatives into Fick's second law yields an ordinary differential equation (ODE) for $f(\\eta)$:\n$$ -f'(\\eta)\\frac{\\eta}{2t} = D \\left( \\frac{f''(\\eta)}{4Dt} \\right) \\implies f''(\\eta) + 2\\eta f'(\\eta) = 0 $$\nTo solve this ODE, we let $g(\\eta) = f'(\\eta)$, which gives a first-order separable equation: $g'(\\eta) = -2\\eta g(\\eta)$.\n$$ \\frac{dg}{g} = -2\\eta \\, d\\eta \\implies \\int \\frac{dg}{g} = \\int -2\\eta \\, d\\eta \\implies \\ln(g) = -\\eta^2 + K_1 $$\nSolving for $g(\\eta)$ gives $g(\\eta) = e^{K_1}e^{-\\eta^2} = K_2 e^{-\\eta^2}$. Since $g(\\eta) = f'(\\eta)$, we integrate again to find $f(\\eta)$:\n$$ f(\\eta) = \\int K_2 e^{-\\eta^2} \\, d\\eta + K_3 $$\nThis integral is related to the definition of the error function, $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_0^z e^{-u^2}du$. The general solution is:\n$$ f(\\eta) = K_4 \\text{erf}(\\eta) + K_3 $$\nThe constants $K_3$ and $K_4$ are determined by the boundary conditions.\n1.  From BC1, $C(0, t) = C_s$. At $x=0$, $\\eta=0$. So, $f(0) = C_s$.\n    $C_s = K_4 \\text{erf}(0) + K_3 = K_4 \\cdot 0 + K_3 \\implies K_3 = C_s$.\n2.  From BC2, $\\lim_{x\\to\\infty} C(x, t) = 0$. As $x\\to\\infty$, $\\eta\\to\\infty$. So, $\\lim_{\\eta\\to\\infty} f(\\eta) = 0$.\n    $0 = K_4 \\text{erf}(\\infty) + C_s = K_4 \\cdot 1 + C_s \\implies K_4 = -C_s$.\n\nSubstituting the constants back, we get $f(\\eta) = -C_s \\text{erf}(\\eta) + C_s = C_s (1 - \\text{erf}(\\eta))$. The expression $1 - \\text{erf}(z)$ is the complementary error function, $\\text{erfc}(z)$. Thus, the ideal concentration profile is:\n$$ C(x, t) = C_s \\cdot \\text{erfc}\\left(\\frac{x}{2\\sqrt{Dt}}\\right) $$\nFor our computational model, we can use a normalized profile by setting $C_s=1$, since the absolute amplitude will be a fitting parameter.\n\n**Part 2: Algorithmic Design and Implementation**\n\nThe program must synthesize, fit, and analyze diffusion profiles according to the problem specification.\n\n1.  **Data Synthesis**: For each test case, a \"measured\" profile is generated.\n    *   An array of depth points $x$ is created from $0$ to $L$ with spacing $\\Delta x$.\n    *   The true total broadening, $\\sigma_{\\mathrm{tot,true}}$, is calculated from the midpoint (nominal) values of the given $\\sigma_{\\mathrm{res}}$ and $\\sigma_{\\mathrm{sput}}$ ranges.\n    *   The ideal Fickian profile $C(x)$ is calculated using the true diffusivity $D_{\\text{true}}$ and anneal time $t$.\n    *   This ideal profile is then convolved with a Gaussian kernel of standard deviation $\\sigma_{\\mathrm{tot,true}}$. The convolution is performed over the finite interval $[0, L]$ with proper normalization at each point $x_i$ to account for edge effects, as specified by the formula:\n        $$ M(x_i) = \\frac{\\sum_{j} C(x_j) \\, G(x_i - x_j; \\sigma_{\\mathrm{tot}}) \\Delta x}{\\sum_{j} G(x_i - x_j; \\sigma_{\\mathrm{tot}}) \\Delta x} $$\n        where the sums run over all points $x_j$ in the discrete depth grid. A direct numerical implementation of this summation is employed.\n    *   Finally, zero-mean Gaussian noise with the specified standard deviation $\\sigma_{\\mathrm{noise}}$ is added to the convolved profile to create the synthetic measured data, $y_{\\text{measured}}$. A fixed pseudo-random seed of $0$ ensures reproducibility.\n\n2.  **Fitting Procedure**: The synthetic data $y_{\\text{measured}}$ is fitted using a nonlinear least-squares algorithm (`scipy.optimize.curve_fit`).\n    *   The model function for the fit is $y_{\\text{fit}}(x; D, A, B) = A \\cdot M(x; D, \\sigma_{\\mathrm{tot}}) + B$, where $M(x; D, \\sigma_{\\mathrm{tot}})$ is the convolved Fickian profile, $A$ is a scaling amplitude, and $B$ is a baseline offset.\n    *   Three separate fits are performed for each test case to assess the uncertainty in $D$ due to the uncertainty in the broadening parameters:\n        a.  **Nominal Fit**: The fit is performed holding $\\sigma_{\\mathrm{tot}}$ fixed at its nominal value, $\\sigma_{\\mathrm{tot,nom}} = \\sqrt{\\sigma_{\\mathrm{res,nom}}^2 + \\sigma_{\\mathrm{sput,nom}}^2}$. This yields the best-fit diffusivity $D_{\\mathrm{nom}}$.\n        b.  **Low-Bound Fit**: The fit is repeated with $\\sigma_{\\mathrm{tot}}$ fixed at its lower bound, $\\sigma_{\\mathrm{tot,low}} = \\sqrt{\\sigma_{\\mathrm{res,min}}^2 + \\sigma_{\\mathrm{sput,min}}^2}$. This yields a fitted diffusivity $D_{\\text{fit_low}}$.\n        c.  **High-Bound Fit**: The fit is repeated with $\\sigma_{\\mathrm{tot}}$ fixed at its upper bound, $\\sigma_{\\mathrm{tot,high}} = \\sqrt{\\sigma_{\\mathrm{res,max}}^2 + \\sigma_{\\mathrm{sput,max}}^2}$. This yields a fitted diffusivity $D_{\\text{fit_high}}$.\n    *   The parameters to be fitted are $(D, A, B)$. Initial guesses are provided based on the true values used for synthesis, and bounds are set to ensure physical validity (e.g., $D  0, A  0$).\n\n3.  **Uncertainty Reporting**: The final results for each case are compiled as a list containing three values: $[D_{\\mathrm{nom}}, D_{\\mathrm{low}}, D_{\\mathrm{high}}]$.\n    *   $D_{\\mathrm{nom}}$ is the diffusivity from the nominal fit.\n    *   $D_{\\mathrm{low}}$ is the minimum of the two diffusivities obtained from the low-bound and high-bound fits, i.e., $\\min(D_{\\text{fit_low}}, D_{\\text{fit_high}})$.\n    *   $D_{\\mathrm{high}}$ is the maximum of the two, i.e., $\\max(D_{\\text{fit_low}}, D_{\\text{fit_high}})$.\n\nThis comprehensive approach simulates a realistic data analysis workflow, from raw data generation that includes physical and instrumental effects to parameter extraction and uncertainty quantification.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Solves the Fickian diffusion problem for three test cases.\n\n    For each case, it:\n    1. Synthesizes a \"measured\" SIMS profile with noise.\n    2. Fits the profile with nominal broadening to find D_nom.\n    3. Re-fits with lower and upper bound broadening to find the uncertainty range [D_low, D_high].\n    4. Collects and prints the results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        # Case A\n        {\n            \"t\": 7.2e3, \"D_true\": 3.0e-17,\n            \"sigma_res_range\": [1.0e-9, 2.0e-9], \"sigma_sput_range\": [2.0e-9, 3.0e-9],\n            \"L\": 1.5e-6, \"dx\": 5.0e-9,\n            \"A_true\": 1.0, \"B_true\": 0.0, \"sigma_noise\": 2.0e-3\n        },\n        # Case B\n        {\n            \"t\": 1.0e4, \"D_true\": 1.0e-18,\n            \"sigma_res_range\": [0.0, 0.5e-9], \"sigma_sput_range\": [0.0, 0.5e-9],\n            \"L\": 4.0e-7, \"dx\": 2.0e-9,\n            \"A_true\": 1.0, \"B_true\": 0.0, \"sigma_noise\": 2.0e-3\n        },\n        # Case C\n        {\n            \"t\": 3.6e3, \"D_true\": 1.0e-20,\n            \"sigma_res_range\": [7.0e-9, 9.0e-9], \"sigma_sput_range\": [9.0e-9, 11.0e-9],\n            \"L\": 2.0e-7, \"dx\": 2.0e-9,\n            \"A_true\": 1.0, \"B_true\": 0.0, \"sigma_noise\": 2.0e-3\n        }\n    ]\n\n    # Use a fixed seed for reproducible noise generation.\n    rng = np.random.default_rng(0)\n    \n    final_results = []\n\n    def convolve_with_normalization(x, c_ideal, sigma):\n        \"\"\"\n        Performs depth-wise convolution of an ideal profile C_ideal with a\n        Gaussian kernel on a finite interval [0, L] with proper normalization.\n        \"\"\"\n        if sigma  1e-12:  # Effectively a delta function, convolution is identity\n            return c_ideal\n\n        m_convolved = np.zeros_like(c_ideal)\n        for i, xi in enumerate(x):\n            delta_x = xi - x\n            kernel = np.exp(-delta_x**2 / (2 * sigma**2))\n            \n            numerator = np.sum(c_ideal * kernel)\n            denominator = np.sum(kernel)\n            \n            if denominator > 0:\n                m_convolved[i] = numerator / denominator\n        return m_convolved\n\n    def full_model(x, D, A, B, t, sigma_tot):\n        \"\"\"\n        The full model for the measured SIMS profile, including convolution,\n        amplitude scaling, and baseline offset.\n        \"\"\"\n        # 1. Ideal Fickian profile (erfc)\n        diffusion_length = 2 * np.sqrt(D * t)\n        if diffusion_length == 0:\n            c_ideal = np.ones_like(x)\n            if len(x)>1: c_ideal[1:] = 0.0 # Step function\n        else:\n            c_ideal = erfc(x / diffusion_length)\n\n        # 2. Convolution with Gaussian kernel\n        m_convolved = convolve_with_normalization(x, c_ideal, sigma_tot)\n        \n        # 3. Apply amplitude and baseline\n        return A * m_convolved + B\n\n    for case in test_cases:\n        t = case[\"t\"]\n        D_true = case[\"D_true\"]\n        sigma_res_range = case[\"sigma_res_range\"]\n        sigma_sput_range = case[\"sigma_sput_range\"]\n        L = case[\"L\"]\n        dx = case[\"dx\"]\n        A_true = case[\"A_true\"]\n        B_true = case[\"B_true\"]\n        sigma_noise = case[\"sigma_noise\"]\n\n        x_grid = np.arange(0, L, dx)\n\n        # --- Data Synthesis ---\n        sigma_res_nom = np.mean(sigma_res_range)\n        sigma_sput_nom = np.mean(sigma_sput_range)\n        sigma_tot_true = np.sqrt(sigma_res_nom**2 + sigma_sput_nom**2)\n        \n        y_ideal_convolved = full_model(x_grid, D_true, A_true, B_true, t, sigma_tot_true)\n        noise = rng.normal(0, sigma_noise, size=len(x_grid))\n        y_measured = y_ideal_convolved + noise\n\n        # --- Fitting ---\n        # Initial guesses and bounds for the fitter\n        p0 = [D_true, A_true, B_true]\n        bounds = ([1e-25, 0, -np.inf], [np.inf, 2.0, np.inf])\n\n        # 1. Nominal fit\n        sigma_tot_nom = sigma_tot_true # Same as for synthesis\n        fit_func_nom = lambda x, D, A, B: full_model(x, D, A, B, t, sigma_tot_nom)\n        popt_nom, _ = curve_fit(fit_func_nom, x_grid, y_measured, p0=p0, bounds=bounds)\n        D_nom = popt_nom[0]\n\n        # 2. Fit at lower bound of sigma_tot\n        sigma_res_min, sigma_res_max = sigma_res_range\n        sigma_sput_min, sigma_sput_max = sigma_sput_range\n        sigma_tot_low = np.sqrt(sigma_res_min**2 + sigma_sput_min**2)\n        \n        fit_func_low = lambda x, D, A, B: full_model(x, D, A, B, t, sigma_tot_low)\n        popt_low, _ = curve_fit(fit_func_low, x_grid, y_measured, p0=p0, bounds=bounds)\n        D_fit_low = popt_low[0]\n\n        # 3. Fit at upper bound of sigma_tot\n        sigma_tot_high = np.sqrt(sigma_res_max**2 + sigma_sput_max**2)\n\n        fit_func_high = lambda x, D, A, B: full_model(x, D, A, B, t, sigma_tot_high)\n        popt_high, _ = curve_fit(fit_func_high, x_grid, y_measured, p0=p0, bounds=bounds)\n        D_fit_high = popt_high[0]\n\n        # Determine min and max D for uncertainty range\n        D_unc_low = min(D_fit_low, D_fit_high)\n        D_unc_high = max(D_fit_low, D_fit_high)\n\n        final_results.append([D_nom, D_unc_low, D_unc_high])\n\n    # Format the final output string\n    output_str = \"[\"\n    for i, result in enumerate(final_results):\n        d_nom, d_low, d_high = result\n        output_str += f\"[{d_nom:.6e},{d_low:.6e},{d_high:.6e}]\"\n        if i  len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n        \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}