{
    "hands_on_practices": [
        {
            "introduction": "在进行任何复杂的计算物理模拟之前，确保对所计算的物理量及其单位有扎实的理解是至关重要的一步。本练习从线性响应理论和久保公式等第一性原理出发，引导您通过量纲分析推导反常霍尔电导率 $\\sigma_{xy}$ 的物理单位。通过构建一个将不同计算程序中常见的“原生单位”（如原子单位）转换为国际单位制（SI）的自动化流程，您将掌握一项在验证计算结果和进行理论与实验比较时不可或缺的核心技能。",
            "id": "3433211",
            "problem": "您的任务是为反常霍尔电导率构建一个程序化的单位转换流程，该流程从线性响应和量纲分析的第一性原理出发。您的程序必须将反常霍尔电导率 $\\sigma_{xy}$ 的代码原生单位转换为国际单位制（SI），并通过对久保公式的量纲分析来验证目标单位的恒等性。科学基础必须基于以下两个基本点：(i) 将电流密度 $J_{\\alpha}$ 与电场 $E_{\\beta}$ 联系起来的线性响应定义 $J_{\\alpha}=\\sigma_{\\alpha\\beta}E_{\\beta}$，以及 (ii) 电导率张量与电磁矢量势微扰的推迟流-流响应之间的久保公式关系。基于这些基础，必须推导出 $\\sigma_{xy}$ 的量纲并进行编码，而不能使用关于 $\\sigma_{xy}$ 的捷径或预先给定的目标公式，并且转换流程必须从推导出的量纲中导出。\n\n从基本定义 $J_{\\alpha}=\\sigma_{\\alpha\\beta}E_{\\beta}$ 开始，并回想在时间规范下，电磁矢量势 $A_{\\beta}$ 满足关系 $E_{\\beta}(\\omega)=i\\omega A_{\\beta}(\\omega)$。推迟线性响应关系为 $\\delta J_{\\alpha}(\\omega)=\\chi_{\\alpha\\beta}^{JJ}(\\omega)\\delta A_{\\beta}(\\omega)$，因此 $\\sigma_{\\alpha\\beta}(\\omega)=\\chi_{\\alpha\\beta}^{JJ}(\\omega)/(i\\omega)$。利用这一点，通过量纲分析确定 $[\\sigma_{\\alpha\\beta}]$，已知 $[J_{\\alpha}]=\\mathrm{A}/\\mathrm{m}^2$ 且 $[A_{\\beta}]=\\mathrm{V}\\cdot\\mathrm{s}/\\mathrm{m}$。体反常霍尔电导率的目标单位是 $\\mathrm{S/m}$，其中 $[\\mathrm{S/m}]=\\mathrm{A}/(\\mathrm{V}\\cdot\\mathrm{m})$。请仅用基本国际单位制单位表示，并根据能量、时间、长度和电荷的基本单位推导出一个通用的转换因子。\n\n设计一个稳健的单位转换流程，对于任何代码原生单位系统，计算一个转换因子 $C_{\\sigma}$，将代码原生的 $\\sigma_{xy}$ 映射到以 $\\mathrm{S/m}$ 为单位的国际单位制 $\\sigma_{xy}$。仅使用能量 $U_E$（每代码能量单位对应的焦耳数）、时间 $U_T$（每代码时间单位对应的秒数）、长度 $U_L$（每代码长度单位对应的米数）和电荷 $U_Q$（每代码电荷单位对应的库仑数）的基本单位。如果代码原生系统将约化普朗克常数设为1，则在未提供明确的 $U_T$ 时，使用 $\\hbar$ 通过 $U_T=\\hbar/U_E$ 从能量单位推断时间单位。根据您从久保公式和线性响应中获得的量纲恒等式推导转换因子。您的流程必须为每个测试用例返回一个数对 $[C_{\\sigma},\\mathrm{dimension\\_ok}]$，其中 $C_{\\sigma}$ 是浮点转换因子，$\\mathrm{dimension\\_ok}$ 是一个布尔值，指示您的量纲分析是否确实得出 $[\\sigma_{xy}]=\\mathrm{S/m}$。\n\n您必须在没有任何外部输入的情况下实现程序。使用以下五个测试用例套件来实践覆盖范围：\n\n- 测试用例1（使用$\\hbar$推断的正常路径）：能量单位 $U_E$ 是电子伏特（$\\mathrm{eV}$），长度单位 $U_L$ 是埃（$\\mathrm{\\AA}$），未明确提供时间单位，电荷单位 $U_Q$ 是基本电荷 $e$，您必须使用 $\\hbar$ 推断时间。\n- 测试用例2（使用$\\hbar$推断的原子单位）：能量单位 $U_E$ 是哈特里（Hartree），长度单位 $U_L$ 是玻尔半径 $a_0$，未明确提供时间单位，电荷单位 $U_Q$ 是基本电荷 $e$，您必须使用 $\\hbar$ 推断时间。\n- 测试用例3（纯国际单位制的边界检查）：能量单位 $U_E$ 是焦耳，长度单位 $U_L$ 是米，时间单位 $U_T$ 是秒，电荷单位 $U_Q$ 是库仑。转换因子必须在数值公差范围内等于 $1$。\n- 测试用例4（显式时间单位和非国际单位制长度/能量）：能量单位 $U_E$ 是里德堡（Rydberg，其中1里德堡等于半个哈特里），长度单位 $U_L$ 是纳米，时间单位 $U_T$ 是飞秒，电荷单位 $U_Q$ 是基本电荷 $e$。\n- 测试用例5（小能量和介观长度的边缘情况）：能量单位 $U_E$ 是毫电子伏特（$\\mathrm{meV}$），长度单位 $U_L$ 是微米，时间单位 $U_T$ 是皮秒，电荷单位 $U_Q$ 是基本电荷 $e$。\n\n您的算法必须：\n- 从 $J_{\\alpha}=\\sigma_{\\alpha\\beta}E_{\\beta}$ 和 $E_{\\beta}(\\omega)=i\\omega A_{\\beta}(\\omega)$ 推导出单位恒等式 $[\\sigma_{xy}]$，并用基本国际单位制单位表示最终目标单位。推导出形式为\n$$\nC_{\\sigma}=\\frac{U_Q^2}{U_E\\,U_T\\,U_L}\n$$\n的转换因子。\n- 在指定时，通过 $\\hbar$ 使用 $U_T=\\hbar/U_E$ 实现对隐式时间单位的稳健处理。\n- 对于每个测试用例，返回数对 $[C_{\\sigma},\\mathrm{dimension\\_ok}]$，其中 $C_{\\sigma}$ 是一个浮点数，$\\mathrm{dimension\\_ok}$ 是一个布尔值。\n\n物理单位和输出要求：\n- 所有结果中，电导率转换因子必须以 $\\mathrm{S/m}$ 为单位。\n- 不涉及角度；不要使用度或弧度。\n- 不涉及百分比。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由五个逗号分隔的数对组成的列表，每个数对格式为 $[C_{\\sigma},\\mathrm{dimension\\_ok}]$，并用方括号括起来。例如，您的输出必须类似于 $[[x_1,b_1],[x_2,b_2],[x_3,b_3],[x_4,b_4],[x_5,b_5]]$，其中每个 $x_i$ 是一个浮点数，每个 $b_i$ 是一个布尔值。",
            "solution": "该问题要求开发一个用于反常霍尔电导率 $\\sigma_{xy}$ 的单位转换流程，该流程基于从线性响应理论推导出的第一性原理量纲分析。此过程包括两个主要阶段：首先，是量纲和转换因子的理论推导；其次，是在Python程序中实现这些发现，以处理特定的测试用例。\n\n### 第1部分：理论推导与量纲分析\n\n此分析的基础是问题陈述中提供的关系式。我们首先正式推导电导率张量 $\\sigma_{\\alpha\\beta}$ 的物理量纲。\n\n**步骤1.1：推导电导率 $\\sigma_{\\alpha\\beta}$ 的量纲**\n\n电导率张量 $\\sigma_{\\alpha\\beta}$ 由电流密度 $J_{\\alpha}$ 对外加电场 $E_{\\beta}$ 的线性响应定义：\n$$\nJ_{\\alpha} = \\sigma_{\\alpha\\beta}E_{\\beta}\n$$\n根据此定义，电导率的量纲（用 $[\\sigma]$ 表示）可以表示为电流量纲 $[J]$ 与电场量纲 $[E]$ 的比值：\n$$\n[\\sigma] = \\frac{[J]}{[E]}\n$$\n问题指定电流量纲为安培每平方米：\n$$\n[J] = \\frac{\\mathrm{A}}{\\mathrm{m}^2} = \\frac{[I]}{[L]^2}\n$$\n其中 $[I]$ 表示电流的量纲，$[L]$ 表示长度的量纲。\n\n为了找到电场 $[E]$ 的量纲，我们使用问题中提供的在傅里叶空间中电场 $E_{\\beta}(\\omega)$ 和电磁矢量势 $A_{\\beta}(\\omega)$ 之间的关系，这在时间规范 ($A_0=0$)下有效：\n$$\nE_{\\beta}(\\omega) = i\\omega A_{\\beta}(\\omega)\n$$\n虚数单位 $i$ 是无量纲的。角频率 $\\omega$ 的量纲是时间的倒数，即 $[\\omega] = [T]^{-1}$。因此，量纲关系为：\n$$\n[E] = [\\omega][A] = [T]^{-1}[A]\n$$\n问题提供的矢量势的量纲是伏特·秒每米：\n$$\n[A] = \\frac{\\mathrm{V} \\cdot \\mathrm{s}}{\\mathrm{m}} = \\frac{[V][T]}{[L]}\n$$\n其中 $[V]$ 表示电势（电压）的量纲。\n\n将 $[A]$ 的量纲代入 $[E]$ 的方程中，得到：\n$$\n[E] = [T]^{-1} \\frac{[V][T]}{[L]} = \\frac{[V]}{[L]}\n$$\n这个结果 $[E] = [V]/[L]$ 是我们所熟悉的电场量纲（伏特每米）。\n\n现在我们可以通过代入 $[J]$ 和 $[E]$ 的量纲来确定电导率 $[\\sigma]$ 的量纲：\n$$\n[\\sigma] = \\frac{[J]}{[E]} = \\frac{[I]/[L]^2}{[V]/[L]} = \\frac{[I]}{[V][L]}\n$$\n在国际单位制中，电流 $I$ 的单位是安培（$\\mathrm{A}$），电势 $V$ 的单位是伏特（$\\mathrm{V}$），长度 $L$ 的单位是米（$\\mathrm{m}$）。因此，电导率的导出单位是 $\\mathrm{A}/(\\mathrm{V}\\cdot\\mathrm{m})$。国际单位制中的电导单位是西门子（$\\mathrm{S}$），定义为 $\\mathrm{S} = \\mathrm{A/V}$。因此，电导率的单位是 $\\mathrm{S/m}$。\n\n此分析证实了所提供的量纲框架是内部一致的，并正确地得出了体电导率的目标单位 $\\mathrm{S/m}$。因此，布尔标志 `dimension_ok` 为 `True`。\n\n**步骤1.2：用基本单位表示电导率量纲**\n\n为了创建一个通用的转换因子，我们用一组更基本的物理量来表示电导率的量纲：电荷（$Q$）、能量（$E$）、长度（$L$）和时间（$T$）。\n\n电流量纲是单位时间内的电荷：$[I] = [Q][T]^{-1}$。\n电压（电势）量纲是单位电荷的能量：$[V] = [E][Q]^{-1}$。\n\n将这些代入我们推导出的电导率量纲中：\n$$\n[\\sigma] = \\frac{[I]}{[V][L]} = \\frac{[Q][T]^{-1}}{([E][Q]^{-1})[L]} = \\frac{[Q]^2}{[E][L][T]}\n$$\n因此，电导率的量纲是 $[\\sigma] = [Q]^2 [E]^{-1} [L]^{-1} [T]^{-1}$。\n\n**步骤1.3：推导转换因子 $C_{\\sigma}$**\n\n我们的任务是找到一个转换因子 $C_{\\sigma}$，它通过关系式 $\\sigma_{\\mathrm{SI}} = C_{\\sigma} \\sigma_{\\mathrm{code}}$ 将在代码原生单位系统中计算出的电导率数值 $\\sigma_{\\mathrm{code}}$ 映射到其在国际单位制中的对应值 $\\sigma_{\\mathrm{SI}}$。\n\n设代码原生系统使用基本单位 charge$_{\\mathrm{code}}$、energy$_{\\mathrm{code}}$、length$_{\\mathrm{code}}$ 和 time$_{\\mathrm{code}}$。到国际单位制的转换因子由以下给出：\n-   $U_Q$：库仑每 charge$_{\\mathrm{code}}$ ($1$ charge$_{\\mathrm{code}} = U_Q \\, \\mathrm{C}$)\n-   $U_E$：焦耳每 energy$_{\\mathrm{code}}$ ($1$ energy$_{\\mathrm{code}} = U_E \\, \\mathrm{J}$)\n-   $U_L$：米每 length$_{\\mathrm{code}}$ ($1$ length$_{\\mathrm{code}} = U_L \\, \\mathrm{m}$)\n-   $U_T$：秒每 time$_{\\mathrm{code}}$ ($1$ time$_{\\mathrm{code}} = U_T \\, \\mathrm{s}$)\n\n一个物理量的值与单位制无关。设 $\\sigma_{\\mathrm{phys}}$ 为物理电导率。\n$$\n\\sigma_{\\mathrm{phys}} = \\sigma_{\\mathrm{SI}} \\left( \\frac{\\mathrm{S}}{\\mathrm{m}} \\right) = \\sigma_{\\mathrm{code}} \\left( \\frac{(\\mathrm{charge}_{\\mathrm{code}})^2}{(\\mathrm{energy}_{\\mathrm{code}})(\\mathrm{length}_{\\mathrm{code}})(\\mathrm{time}_{\\mathrm{code}})} \\right)\n$$\n为了找到 $\\sigma_{\\mathrm{SI}}$ 和 $\\sigma_{\\mathrm{code}}$ 之间的关系，我们通过代入转换因子将代码原生单位组合表示为国际单位制单位：\n$$\n\\frac{(\\mathrm{charge}_{\\mathrm{code}})^2}{...} = \\frac{(U_Q \\, \\mathrm{C})^2}{(U_E \\, \\mathrm{J})(U_L \\, \\mathrm{m})(U_T \\, \\mathrm{s})} = \\frac{U_Q^2}{U_E U_L U_T} \\left( \\frac{\\mathrm{C}^2}{\\mathrm{J} \\cdot \\mathrm{m} \\cdot \\mathrm{s}} \\right)\n$$\n如前所示，$\\mathrm{C}^2/(\\mathrm{J}\\cdot\\mathrm{m}\\cdot\\mathrm{s})$ 等价于 $\\mathrm{S/m}$。因此：\n$$\n\\sigma_{\\mathrm{phys}} = \\sigma_{\\mathrm{code}} \\left( \\frac{U_Q^2}{U_E U_L U_T} \\right) \\left( \\frac{\\mathrm{S}}{\\mathrm{m}} \\right)\n$$\n通过将其与 $\\sigma_{\\mathrm{phys}} = \\sigma_{\\mathrm{SI}} (\\mathrm{S/m})$ 进行比较，我们确定了转换因子：\n$$\nC_{\\sigma} = \\frac{U_Q^2}{U_E U_T U_L}\n$$\n这证实了问题陈述中提供的函数形式。\n\n**步骤1.4：处理隐式时间单位**\n\n在许多计算物理代码中，习惯于在一个约化普朗克常数 $\\hbar$ 设为 1 的单位制中工作。问题规定，如果未明确提供时间单位转换因子 $U_T$，则应根据此惯例进行推断。\n\n在量子力学中，能量 $E$ 和时间 $T$ 之间的物理关系涉及 $\\hbar$。例如，$E = \\hbar\\omega$，其中 $\\omega$ 是角频率。从量纲上看，$[E][T] = [\\hbar]$。\n如果在代码原生单位中 $\\hbar_{\\mathrm{code}}=1$，那么 $energy_{\\mathrm{code}} \\cdot time_{\\mathrm{code}}$ 的数值为 $1$。要将其转换为国际单位制，我们必须有：\n$$\n(1 \\, \\mathrm{energy}_{\\mathrm{code}}) \\cdot (1 \\, \\mathrm{time}_{\\mathrm{code}}) = (U_E \\, \\mathrm{J}) \\cdot (U_T \\, \\mathrm{s})\n$$\n右侧的乘积 $U_E U_T$ 必须等于 $\\hbar$ 的国际单位制值。\n$$\nU_E U_T = \\hbar_{\\mathrm{SI}}\n$$\n因此，当未给出明确的时间单位时，我们可以从能量单位转换因子推断其转换因子：\n$$\nU_T = \\frac{\\hbar_{\\mathrm{SI}}}{U_E}\n$$\n其中 $\\hbar_{\\mathrm{SI}} \\approx 1.05457 \\times 10^{-34} \\, \\mathrm{J \\cdot s}$。\n在这种特殊情况下，转换因子 $C_{\\sigma}$ 简化为：\n$$\nC_{\\sigma} = \\frac{U_Q^2}{U_E U_L (\\hbar/U_E)} = \\frac{U_Q^2}{\\hbar U_L}\n$$\n\n### 第2部分：算法实现\n\n该算法是推导出的 $C_{\\sigma}$ 公式的直接实现。\n1.  用国际单位制定义一组高精度物理常数。\n2.  对于每个测试用例，根据提供的单位名称（例如 'eV', 'Angstrom'）确定单位转换因子 $U_E$、$U_L$、$U_T$ 和 $U_Q$ 的国际单位制值。\n3.  如果测试用例未提供时间单位，则使用公式 $U_T = \\hbar / U_E$ 计算 $U_T$。\n4.  使用公式 $C_{\\sigma} = U_Q^2 / (U_E U_T U_L)$ 计算转换因子 $C_{\\sigma}$。\n5.  根据步骤1.1中的理论分析，量纲一致性检查 `dimension_ok` 总是 `True`。\n6.  将每个结果存储为一对 $[C_{\\sigma}, \\mathrm{True}]$，并按规定格式化最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Calculates the conversion factor for anomalous Hall conductivity from\n    code-native units to SI units (S/m) based on first-principles\n    dimensional analysis.\n    \"\"\"\n\n    # Physical constants in SI units from scipy.constants\n    # Values are based on CODATA 2018.\n    consts = {\n        'e_charge': constants.e,  # Elementary charge in Coulombs\n        'hbar': constants.hbar,  # Reduced Planck constant in J*s\n        'eV_in_J': constants.electron_volt,  # Electron-volt in Joules\n        'Hartree_in_J': constants.physical_constants['Hartree energy'][0],\n        'Rydberg_in_J': constants.physical_constants['Rydberg constant times hc in J'][0],\n        'Angstrom_in_m': constants.angstrom,\n        'Bohr_radius_in_m': constants.physical_constants['Bohr radius'][0],\n    }\n\n    # Map unit names to their SI conversion factors (U_X)\n    unit_map = {\n        # Energy Units (Joules per code energy unit)\n        'eV': consts['eV_in_J'],\n        'meV': consts['eV_in_J'] * 1e-3,\n        'Hartree': consts['Hartree_in_J'],\n        'Rydberg': consts['Hartree_in_J'] / 2.0, # Corrected definition 1 Ryd = 0.5 Hartree\n        'J': 1.0,\n        # Length Units (meters per code length unit)\n        'Angstrom': consts['Angstrom_in_m'],\n        'Bohr': consts['Bohr_radius_in_m'],\n        'nm': 1e-9,\n        'micrometer': 1e-6,\n        'm': 1.0,\n        # Time Units (seconds per code time unit)\n        'fs': 1e-15,\n        'ps': 1e-12,\n        's': 1.0,\n        # Charge Units (Coulombs per code charge unit)\n        'e': consts['e_charge'],\n        'C': 1.0,\n    }\n\n    # Test cases as defined in the problem statement\n    # Each dict defines the unit system for a given test case.\n    # A time_unit of None indicates it should be inferred using hbar.\n    test_cases = [\n        # Test case 1: happy path using hbar inference\n        {'energy_unit': 'eV', 'length_unit': 'Angstrom', 'time_unit': None, 'charge_unit': 'e'},\n        # Test case 2: atomic units using hbar inference\n        {'energy_unit': 'Hartree', 'length_unit': 'Bohr', 'time_unit': None, 'charge_unit': 'e'},\n        # Test case 3: boundary check with pure SI\n        {'energy_unit': 'J', 'length_unit': 'm', 'time_unit': 's', 'charge_unit': 'C'},\n        # Test case 4: explicit time units and non-SI length/energy\n        {'energy_unit': 'Rydberg', 'length_unit': 'nm', 'time_unit': 'fs', 'charge_unit': 'e'},\n        # Test case 5: edge case with small energy and mesoscopic length\n        {'energy_unit': 'meV', 'length_unit': 'micrometer', 'time_unit': 'ps', 'charge_unit': 'e'},\n    ]\n\n    results = []\n    \n    # The dimensional analysis performed in the solution text confirms that the\n    # framework is consistent and yields S/m. This boolean is therefore always True.\n    dimension_ok = True\n\n    for case in test_cases:\n        # Get the conversion factors from the unit map\n        U_E = unit_map[case['energy_unit']]\n        U_L = unit_map[case['length_unit']]\n        U_Q = unit_map[case['charge_unit']]\n\n        # Determine the time unit conversion factor U_T\n        if case['time_unit'] is None:\n            # Infer time unit from energy unit via hbar=1 convention\n            U_T = consts['hbar'] / U_E\n        else:\n            # Use explicit time unit\n            U_T = unit_map[case['time_unit']]\n\n        # Calculate the conductivity conversion factor C_sigma\n        # C_sigma = U_Q^2 / (U_E * U_T * U_L)\n        C_sigma = U_Q**2 / (U_E * U_T * U_L)\n        \n        results.append([C_sigma, dimension_ok])\n\n    # Format the final output string exactly as required\n    # e.g., [[x1,True],[x2,True],...]\n    # Using python's str() on a list containing a boolean produces the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从数值对角化得到的布洛赫波函数具有相位模糊性，即规范自由度，这为贝里曲率和反常霍尔电导率的计算带来了核心挑战。本练习将揭示一个天真的、基于贝里联络的有限差分方法为何会得出依赖于规范选择的错误结果。通过实现并对比一种规范变化的计算方法和一种基于格点规范理论思想的、规范不变的格点链路变量方法，您将深刻理解为何计算拓扑量子数时必须采用稳健的算法，并掌握这种算法的实际操作。",
            "id": "3433169",
            "problem": "你需要编写一个完整、可运行的程序，分析在二维双带紧束缚模型中，Wannier规范的选择如何影响计算出的贝里曲率 $ \\Omega_{z}(\\mathbf{k}) $ 和反常霍尔电导率 $ \\sigma_{xy} $。此分析必须通过比较模拟不同投影集的不同规范固定策略，并量化一个离散光滑度度量来执行。你的程序必须实现两种贝里曲率的数值估计方法：一种是规范依赖的有限差分估计方法，另一种是规范不变的格点链路变量估计方法，然后对每种估计方法，计算 $ \\sigma_{xy} $ 在不同规范选择下的方差。所有布里渊区角度必须以弧度处理，最终的 $ \\sigma_{xy} $ 必须以 $ e^{2}/h $ 为单位返回，并采用 $ e = h = 1 $ 的约定（因此是无量纲的）。\n\n物理模型是方形格点上的Qi–Wu–Zhang双带陈绝缘体。布洛赫哈密顿量为\n$$\nH(\\mathbf{k}) = d_{x}(\\mathbf{k})\\,\\sigma_{x} + d_{y}(\\mathbf{k})\\,\\sigma_{y} + d_{z}(\\mathbf{k})\\,\\sigma_{z},\n$$\n其中泡利矩阵为 $ \\sigma_{x},\\sigma_{y},\\sigma_{z} $，且\n$$\nd_{x}(\\mathbf{k}) = \\sin(k_{x}), \\quad d_{y}(\\mathbf{k}) = \\sin(k_{y}), \\quad d_{z}(\\mathbf{k}) = m + \\cos(k_{x}) + \\cos(k_{y}).\n$$\n布里渊区为 $ k_{x},k_{y} \\in [-\\pi,\\pi) $。下能带为占据带。使用一个均匀的 $ N \\times N $ 网格，其中\n$$\nk_{x}(i) = -\\pi + \\frac{2\\pi}{N}\\,i, \\quad k_{y}(j) = -\\pi + \\frac{2\\pi}{N}\\,j, \\quad i,j \\in \\{0,1,\\dots,N-1\\},\n$$\n并采用周期性边界条件。记 $ \\delta k = 2\\pi/N $。\n\n规范选择。令 $ \\lvert u(\\mathbf{k})\\rangle $ 为在 $ \\mathbf{k} $ 处归一化的占据带本征矢量。通过首先使用投影集固定相位，然后施加一个确定的、依赖于 $ \\mathbf{k} $ 的相位来构造三种类Wannier规范。对于规范指数 $ g \\in \\{0,1,2\\} $，定义投影旋量为\n$$\n\\lvert p_{0}\\rangle = \\begin{pmatrix}1\\\\0\\end{pmatrix}, \\quad\n\\lvert p_{1}\\rangle = \\begin{pmatrix}0\\\\1\\end{pmatrix}, \\quad\n\\lvert p_{2}\\rangle = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1\\\\ e^{i\\pi/3}\\end{pmatrix}.\n$$\n在每个 $ \\mathbf{k} $ 处，通过乘以一个补偿性的 $ U(1) $ 相位来强制满足 $ \\arg\\langle p_{g}\\vert u(\\mathbf{k})\\rangle = 0 $ 和 $ \\langle p_{g}\\vert u(\\mathbf{k})\\rangle \\ge 0 $，从而定义相位固定的本征矢量 $ \\lvert \\tilde{u}_{g}(\\mathbf{k})\\rangle $。然后施加一个额外的光滑相位场 $ \\phi_{g}(\\mathbf{k}) $，并设置\n$$\n\\lvert u_{g}(\\mathbf{k})\\rangle = e^{i\\phi_{g}(\\mathbf{k})}\\,\\lvert \\tilde{u}_{g}(\\mathbf{k})\\rangle.\n$$\n这些相位场被确定性地指定为\n$$\n\\phi_{0}(\\mathbf{k}) = 0, \\quad \\phi_{1}(\\mathbf{k}) = \\alpha_{1}\\,\\Big(\\sin(k_{x}) + \\tfrac{1}{2}\\cos(k_{y})\\Big), \\quad \\phi_{2}(\\mathbf{k}) = \\alpha_{2}\\,\\sin(2k_{x})\\sin(2k_{y}),\n$$\n其中振幅 $ \\alpha_{1} $ 和 $ \\alpha_{2} $ 由每个测试用例指定，而 $ \\alpha_{0} = 0 $。\n\n光滑度度量。对于每种规范 $ g $，定义离散光滑度度量\n$$\nS_{g} = \\frac{1}{2N^{2}} \\sum_{i,j} \\sum_{\\mu \\in \\{x,y\\}} \\Big(1 - \\big|\\langle u_{g}(k_{x}(i),k_{y}(j)) \\vert u_{g}(k_{x}(i)+\\delta k\\,\\delta_{\\mu,x}, k_{y}(j)+\\delta k\\,\\delta_{\\mu,y}) \\rangle \\big| \\Big),\n$$\n并采用周期性边界条件。$ S_{g} $ 值越小，意味着规范越光滑。\n\n贝里曲率估计方法。实现以下两种方法：\n- 一种规范依赖的有限差分估计方法。首先近似贝里联络分量\n$$\nA_{\\mu}^{(g)}(\\mathbf{k}) = i\\,\\langle u_{g}(\\mathbf{k})\\vert \\partial_{k_{\\mu}} u_{g}(\\mathbf{k})\\rangle,\n$$\n使用中心差分\n$$\n\\partial_{k_{\\mu}} \\lvert u_{g}(\\mathbf{k})\\rangle \\approx \\frac{\\lvert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle - \\lvert u_{g}(\\mathbf{k}-\\delta k\\,\\hat{\\mu})\\rangle}{2\\delta k},\n$$\n然后近似\n$$\n\\Omega_{z,\\text{FD}}^{(g)}(\\mathbf{k}) = \\partial_{k_{x}} A_{y}^{(g)}(\\mathbf{k}) - \\partial_{k_{y}} A_{x}^{(g)}(\\mathbf{k}),\n$$\n再次在网格上使用中心差分。有限差分反常霍尔电导率为\n$$\n\\sigma_{xy,\\text{FD}}^{(g)} = \\frac{1}{2\\pi} \\sum_{i,j} \\Omega_{z,\\text{FD}}^{(g)}(k_{x}(i),k_{y}(j))\\,(\\delta k)^{2},\n$$\n以 $ e^{2}/h $ 为单位表示，并采用 $ e = h = 1 $。\n- 一种规范不变的格点链路变量估计方法。定义链路变量\n$$\nU_{\\mu}^{(g)}(\\mathbf{k}) = \\frac{\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle}{\\big|\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle\\big|},\n$$\n以及每个格框上的格点场强\n$$\nF^{(g)}(\\mathbf{k}) = \\arg\\Big[ U_{x}^{(g)}(\\mathbf{k})\\,U_{y}^{(g)}(\\mathbf{k}+\\delta k\\,\\hat{x})\\,\\big(U_{x}^{(g)}(\\mathbf{k}+\\delta k\\,\\hat{y})\\big)^{-1}\\,\\big(U_{y}^{(g)}(\\mathbf{k})\\big)^{-1} \\Big],\n$$\n其中 $ \\arg $ 返回 $ (-\\pi,\\pi] $ 区间内的主值。相应的电导率为\n$$\n\\sigma_{xy,\\text{LI}}^{(g)} = \\frac{1}{2\\pi} \\sum_{\\text{plaquettes}} F^{(g)}(\\mathbf{k}),\n$$\n同样以 $ e^{2}/h $ 为单位。\n\n跨规范的方差。对于每种估计方法类型 $ E \\in \\{\\text{FD},\\text{LI}\\} $ 和每个测试用例，计算三种规范 $ g \\in \\{0,1,2\\} $ 下的总体方差，\n$$\n\\mathrm{Var}_{E} = \\frac{1}{3} \\sum_{g=0}^{2} \\Big(\\sigma_{xy,E}^{(g)} - \\overline{\\sigma}_{xy,E}\\Big)^{2}, \\quad \\overline{\\sigma}_{xy,E} = \\frac{1}{3}\\sum_{g=0}^{2} \\sigma_{xy,E}^{(g)}.\n$$\n\n测试套件。你的程序必须精确地评估以下四个测试用例，每个用例由 $ (m,N,\\alpha_{1},\\alpha_{2}) $ 指定：\n- 案例1（理想路径，拓扑）：$ m = -1.0 $，$ N = 25 $，$ \\alpha_{1} = 0.5 $，$ \\alpha_{2} = 1.5 $。\n- 案例2（接近相变边界）：$ m = -1.9 $，$ N = 25 $，$ \\alpha_{1} = 1.0 $，$ \\alpha_{2} = 2.0 $。\n- 案例3（平庸绝缘体）：$ m = 0.5 $，$ N = 25 $，$ \\alpha_{1} = 0.5 $，$ \\alpha_{2} = 1.5 $。\n- 案例4（粗网格压力测试）：$ m = -1.0 $，$ N = 9 $，$ \\alpha_{1} = 2.0 $，$ \\alpha_{2} = 4.0 $。\n\n要求输出。对于每个测试用例，生成一个包含5个浮点数的列表：\n- 三种规范下的方差 $ \\mathrm{Var}_{\\text{FD}} $。\n- 三种规范下的方差 $ \\mathrm{Var}_{\\text{LI}} $。\n- 三个光滑度度量 $ S_{0}, S_{1}, S_{2} $。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个由各案例列表组成的列表，严格按照以下格式：\n$$\n\\big[ [v_{1}^{\\text{FD}},v_{1}^{\\text{LI}},S_{1,0},S_{1,1},S_{1,2}], [v_{2}^{\\text{FD}},v_{2}^{\\text{LI}},S_{2,0},S_{2,1},S_{2,2}], [v_{3}^{\\text{FD}},v_{3}^{\\text{LI}},S_{3,0},S_{3,1},S_{3,2}], [v_{4}^{\\text{FD}},v_{4}^{\\text{LI}},S_{4,0},S_{4,1},S_{4,2}] \\big],\n$$\n不含任何额外文本。所有 $ \\sigma_{xy} $ 值必须以 $ e^{2}/h $ 为单位、采用 $ e = h = 1 $ 的无量纲数表示。所有角度均为弧度。上述总体方差的定义必须严格按照给定的定义使用。你的程序不得读取任何输入。",
            "solution": "该问题要求对一个双带紧束缚模型中，反常霍尔电导率（AHC）计算的规范依赖效应进行数值分析。该分析涉及在三种不同的规范选择下，实现并比较两种不同的AHC数值估计方法。解决方案是通过遵循一系列从所提供的物理原理和数学定义中推导出的步骤来构建的。\n\n首先，我们建立计算环境。物理系统，即Qi–Wu–Zhang模型，定义在二维方形格点上，这对应于一个离散化的布里渊区（BZ）。对于给定的网格尺寸$N$，我们构建一个均匀的$N \\times N$动量矢量$\\mathbf{k} = (k_x, k_y)$网格。动量定义为$k_{x}(i) = -\\pi + \\frac{2\\pi}{N}\\,i$和$k_{y}(j) = -\\pi + \\frac{2\\pi}{N}\\,j$，其中$i,j \\in \\{0,1,\\dots,N-1\\}$。网格间距为$\\delta k = 2\\pi/N$。\n\n计算的核心是布洛赫哈密顿量，$H(\\mathbf{k}) = \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}$，其中$\\boldsymbol{\\sigma} = (\\sigma_x, \\sigma_y, \\sigma_z)$是泡利矩阵矢量，且$\\mathbf{d}(\\mathbf{k}) = (\\sin(k_{x}), \\sin(k_{y}), m + \\cos(k_{x}) + \\cos(k_{y}))$。对于网格上的每个点$\\mathbf{k}$，我们构造这个$2 \\times 2$的厄米矩阵。\n\n下一步是确定占据的电子态。我们在每个$\\mathbf{k}$点求解本征值问题$H(\\mathbf{k})\\lvert u(\\mathbf{k}) \\rangle = E(\\mathbf{k})\\lvert u(\\mathbf{k}) \\rangle$。这是使用一个数值线性代数例程（具体来说是`numpy.linalg.eigh`）来执行的，该例程稳健且高效。哈密顿量有两个能带，其本征值为$E_\\pm(\\mathbf{k}) = \\pm |\\mathbf{d}(\\mathbf{k})|$。问题指明，能量为$E_-(\\mathbf{k}) = -|\\mathbf{d}(\\mathbf{k})|$的下能带是占据带。我们提取相应的归一化本征矢量，记作$\\lvert u_{\\text{raw}}(\\mathbf{k}) \\rangle$。对角化例程的输出对每个本征矢量都有一个任意相位，这正是待研究的规范自由度的来源。\n\n然后我们实现三种指定的规范固定程序，用$g \\in \\{0,1,2\\}$索引。每个程序包含两个步骤。首先，通过将原始本征矢量$\\lvert u_{\\text{raw}}(\\mathbf{k})\\rangle$投影到恒定的参考旋量$\\lvert p_g \\rangle$上来固定初始相位。三个投影旋量是$\\lvert p_{0}\\rangle = (1,0)^T$，$\\lvert p_{1}\\rangle = (0,1)^T$和$\\lvert p_{2}\\rangle = (1/\\sqrt{2})(1, e^{i\\pi/3})^T$。对于每个$\\mathbf{k}$，我们计算投影交叠$c_g(\\mathbf{k}) = \\langle p_g \\vert u_{\\text{raw}}(\\mathbf{k}) \\rangle$。然后，我们将$\\lvert u_{\\text{raw}}(\\mathbf{k}) \\rangle$乘以一个补偿相位因子$e^{-i\\arg(c_g(\\mathbf{k}))}$，得到相位固定的状态$\\lvert \\tilde{u}_g(\\mathbf{k}) \\rangle$。这强制满足交叠$\\langle p_g \\vert \\tilde{u}_g(\\mathbf{k}) \\rangle$是实数且非负的条件。其次，施加一个额外的依赖于k的光滑相位场$\\phi_g(\\mathbf{k})$，得到最终的规范化本征矢量$\\lvert u_{g}(\\mathbf{k})\\rangle = e^{i\\phi_{g}(\\mathbf{k})}\\,\\lvert \\tilde{u}_{g}(\\mathbf{k})\\rangle$。相位场为$\\phi_{0}(\\mathbf{k}) = 0$，$\\phi_{1}(\\mathbf{k}) = \\alpha_{1}(\\sin(k_{x}) + \\frac{1}{2}\\cos(k_{y}))$，以及$\\phi_{2}(\\mathbf{k}) = \\alpha_{2}\\sin(2k_{x})\\sin(2k_{y})$。对三种规范中的每一种都重复这整个过程。\n\n有了每种$g$的规范化本征矢量网格$\\lvert u_g(\\mathbf{k}) \\rangle$，我们继续计算所需的物理量。\n\n每个规范的光滑度由度量$S_g$来量化。该度量涉及计算相邻k点处本征矢量之间的内积（交叠）$\\langle u_g(\\mathbf{k}) \\vert u_g(\\mathbf{k}+\\delta k\\,\\hat{\\mu}) \\rangle$的模，方向包括$\\mu \\in \\{x,y\\}$。计算使用`numpy.roll`进行矢量化，以高效地访问具有周期性边界条件的相邻网格点。公式$S_{g} = \\frac{1}{2N^{2}} \\sum_{i,j} \\sum_{\\mu \\in \\{x,y\\}} (1 - |\\langle u_{g}(\\mathbf{k}) \\vert u_{g}(\\mathbf{k}') \\rangle |)$通过在整个网格上对局域项求和来实现。\n\n接下来，实现两种AHC $\\sigma_{xy}$的估计方法。\n第一种是规范依赖的有限差分（FD）估计方法。此方法近似贝里曲率的连续谱公式$\\Omega_z = \\partial_{k_x} A_y - \\partial_{k_y} A_x$，其中$A_\\mu = i\\langle u|\\partial_{k_\\mu} u \\rangle$是贝里联络。我们首先计算贝里联络的分量$A_x^{(g)}(\\mathbf{k})$和$A_y^{(g)}(\\mathbf{k})$，方法是用中心有限差分近似代替导数$\\partial_{k_\\mu} \\lvert u_{g}(\\mathbf{k})\\rangle$。这涉及到在各自方向上位移$\\pm \\delta k$。随后，我们通过对计算出的联络场$A_{x}^{(g)}$和$A_{y}^{(g)}$应用另一个中心有限差分近似来计算贝里曲率$\\Omega_{z,\\text{FD}}^{(g)}(\\mathbf{k})$。最后，AHC通过对所有网格点的曲率求和并按面积元缩放得到：$\\sigma_{xy,\\text{FD}}^{(g)} = \\frac{1}{2\\pi} \\sum_{\\mathbf{k}} \\Omega_{z,\\text{FD}}^{(g)}(\\mathbf{k}) (\\delta k)^2$。\n\n第二种是规范不变的格点链路变量（LI）估计方法。此方法基于计算格框磁通，它是场强的离散类比。我们首先定义链路变量$U_{\\mu}^{(g)}(\\mathbf{k}) = \\frac{\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle}{|\\langle u_{g}(\\mathbf{k})\\vert u_{g}(\\mathbf{k}+\\delta k\\,\\hat{\\mu})\\rangle|}$，对于$\\mu \\in \\{x,y\\}$。这些是模为1的复数。然后，格点场强$F^{(g)}(\\mathbf{k})$被计算为格框乘积$U_x^{(g)}(\\mathbf{k}) U_y^{(g)}(\\mathbf{k}+\\delta k \\hat{x}) (U_x^{(g)}(\\mathbf{k}+\\delta k \\hat{y}))^{-1} (U_y^{(g)}(\\mathbf{k}))^{-1}$的相位。使用`numpy.angle`函数来获取幅角的主值。然后，AHC是布里渊区中所有格框上这些场强的总和，再按$1/(2\\pi)$缩放：$\\sigma_{xy,\\text{LI}}^{(g)} = \\frac{1}{2\\pi} \\sum_{\\mathbf{k}} F^{(g)}(\\mathbf{k})$。这种表述被明确地设计为在在位规范变换$e^{i\\phi_g(\\mathbf{k})}$下是不变的。\n\n在为三种规范（$g=0,1,2$）中的每一种计算出AHC值$\\sigma_{xy, \\text{FD}}^{(g)}$和$\\sigma_{xy, \\text{LI}}^{(g)}$之后，我们为每种估计方法类型计算跨规范的方差。如问题中所定义的，总体方差被计算为：$\\mathrm{Var}_{E} = \\frac{1}{3} \\sum_{g=0}^{2} (\\sigma_{xy,E}^{(g)} - \\overline{\\sigma}_{xy,E})^{2}$，其中$\\overline{\\sigma}_{xy,E}$是三个规范下的平均值。这对$E=\\text{FD}$和$E=\\text{LI}$两种情况都进行计算。\n\n这整个计算工作流被封装在一个函数中，该函数接受测试用例参数$(m, N, \\alpha_1, \\alpha_2)$作为输入，并返回一个包含两个方差和三个光滑度度量的列表：$[\\mathrm{Var}_{\\text{FD}}, \\mathrm{Var}_{\\text{LI}}, S_0, S_1, S_2]$。一个主脚本遍历四个指定的测试用例，为每个案例调用此函数，并将结果收集到一个嵌套列表中，然后以要求的格式打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_results(m, N, alpha1, alpha2):\n    \"\"\"\n    Performs the full analysis for a single test case: gauge fixing,\n    smoothness calculation, and AHC calculation via two methods,\n    finally returning the variances and smoothness metrics.\n    \"\"\"\n    # 1. Setup grid and Hamiltonian\n    dk = 2 * np.pi / N\n    k_vals = -np.pi + dk * np.arange(N)\n    Kx, Ky = np.meshgrid(k_vals, k_vals, indexing='ij')\n\n    sigma_x = np.array([[0, 1], [1, 0]], dtype=complex)\n    sigma_y = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n\n    d_x = np.sin(Kx)\n    d_y = np.sin(Ky)\n    d_z = m + np.cos(Kx) + np.cos(Ky)\n\n    H_k = d_x[..., np.newaxis, np.newaxis] * sigma_x + \\\n          d_y[..., np.newaxis, np.newaxis] * sigma_y + \\\n          d_z[..., np.newaxis, np.newaxis] * sigma_z\n          \n    # 2. Diagonalize H(k) to get eigenvectors for the lower band\n    # numpy.linalg.eigh returns eigenvalues in ascending order.\n    # The first eigenvector corresponds to the lowest eigenvalue (occupied band).\n    _, eigvecs = np.linalg.eigh(H_k)\n    u_raw = eigvecs[..., :, 0]\n\n    # 3. Define gauges and loop through them\n    p_g = [\n        np.array([1, 0], dtype=complex),\n        np.array([0, 1], dtype=complex),\n        1/np.sqrt(2) * np.array([1, np.exp(1j*np.pi/3)], dtype=complex)\n    ]\n    phi_g_list = [\n        np.zeros((N, N), dtype=float),\n        alpha1 * (np.sin(Kx) + 0.5 * np.cos(Ky)),\n        alpha2 * np.sin(2*Kx) * np.sin(2*Ky)\n    ]\n\n    sigmas_fd = []\n    sigmas_li = []\n    smoothness_metrics = []\n\n    for g in range(3):\n        # --- Gauge Fixing ---\n        c_g_k = np.einsum('i,kji->kj', p_g[g].conj(), u_raw)\n        phase_correction = np.exp(-1j * np.angle(c_g_k))\n        u_tilde_g = u_raw * phase_correction[..., np.newaxis]\n        phi_g = phi_g_list[g]\n        u_g = u_tilde_g * np.exp(1j * phi_g)[..., np.newaxis]\n\n        # --- Smoothness Metric Calculation ---\n        overlap_x = np.einsum('ijk,ijk->ij', u_g.conj(), np.roll(u_g, -1, axis=0))\n        overlap_y = np.einsum('ijk,ijk->ij', u_g.conj(), np.roll(u_g, -1, axis=1))\n        S_g = (1 / (2 * N**2)) * np.sum(2.0 - np.abs(overlap_x) - np.abs(overlap_y))\n        smoothness_metrics.append(S_g)\n        \n        # --- Method 1: Finite Difference (FD) ---\n        du_dx = (np.roll(u_g, -1, axis=0) - np.roll(u_g, 1, axis=0)) / (2 * dk)\n        du_dy = (np.roll(u_g, -1, axis=1) - np.roll(u_g, 1, axis=1)) / (2 * dk)\n        A_x = 1j * np.einsum('ijk,ijk->ij', u_g.conj(), du_dx)\n        A_y = 1j * np.einsum('ijk,ijk->ij', u_g.conj(), du_dy)\n        dA_y_dx = (np.roll(A_y, -1, axis=0) - np.roll(A_y, 1, axis=0)) / (2 * dk)\n        dA_x_dy = (np.roll(A_x, -1, axis=1) - np.roll(A_x, 1, axis=1)) / (2 * dk)\n        Omega_z_fd = dA_y_dx - dA_x_dy\n        sigma_xy_fd = (1 / (2 * np.pi)) * np.sum(Omega_z_fd) * (dk**2)\n        sigmas_fd.append(np.real(sigma_xy_fd))\n\n        # --- Method 2: Link Invariant (LI) ---\n        U_x = overlap_x / np.abs(overlap_x)\n        U_y = overlap_y / np.abs(overlap_y)\n        U_x_y_shifted = np.roll(U_x, -1, axis=1)\n        U_y_x_shifted = np.roll(U_y, -1, axis=0)\n        F_k = np.angle(U_x * U_y_x_shifted * np.conj(U_x_y_shifted) * np.conj(U_y))\n        sigma_xy_li = (1 / (2 * np.pi)) * np.sum(F_k)\n        sigmas_li.append(sigma_xy_li)\n\n    # 4. Calculate variances across gauges\n    var_fd = np.var(sigmas_fd, ddof=0)\n    var_li = np.var(sigmas_li, ddof=0)\n\n    return [var_fd, var_li] + smoothness_metrics\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        (-1.0, 25, 0.5, 1.5),\n        (-1.9, 25, 1.0, 2.0),\n        (0.5, 25, 0.5, 1.5),\n        (-1.0, 9, 2.0, 4.0),\n    ]\n\n    all_results = []\n    for m, N, alpha1, alpha2 in test_cases:\n        results = compute_case_results(m, N, alpha1, alpha2)\n        all_results.append(results)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了计算反常霍尔电导率的稳健算法之后，下一步是确保计算结果的数值精度，这要求对所有相关的计算参数进行系统的收敛性研究。本练习模拟了在现代材料计算中常见的“粗网格计算、密网格插值”工作流，让您亲手研究计算结果如何依赖于关键的数值参数。通过系统地改变 $k$ 点网格密度、用于近似零温费米函数的斯米尔（smearing）宽度以及插值方案，您将学会如何验证计算的收敛性，从而确保最终结果的可靠性和准确性，这是任何严谨计算研究的基石。",
            "id": "3433226",
            "problem": "您的任务是根据适用于计算材料科学的第一性原理，设计并实现一个关于反常霍尔电导率的数值收敛性研究。考虑一个二维双带模型，其哈密顿量为有质量的狄拉克哈密顿量 $H(\\mathbf{k}) = \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}$，其中 $\\boldsymbol{\\sigma}$ 是泡利矩阵，$\\mathbf{d}(\\mathbf{k}) = \\left(A k_x, A k_y, m\\right)$，其中常数 $A>0$ 且质量 $m \\neq 0$。设费米能级为 $E_F = 0$，并假设一个由光滑展宽函数近似的零温极限。反常霍尔电导率 (AHC)，通过电导量子 $e^2/h$ 进行归一化以使其无量纲，可以从贝里相位表述中表示为对类布里渊区中占据态的积分：\n$$\n\\sigma_{xy}^{\\mathrm{norm}} = \\frac{1}{2\\pi} \\sum_{n \\in \\{+,-\\}} \\int_{\\mathcal{D}} f\\left(E_n(\\mathbf{k})\\right) \\, \\Omega_n(\\mathbf{k}) \\, d^2 k,\n$$\n其中 $E_{\\pm}(\\mathbf{k}) = \\pm \\|\\mathbf{d}(\\mathbf{k})\\|$，$f(E)$ 是占据函数，$\\Omega_n(\\mathbf{k})$ 是能带 $n$ 的贝里曲率。对于一个通用的双带 $\\mathbf{d} \\cdot \\boldsymbol{\\sigma}$ 模型，能带 $n$ 的贝里曲率由下式给出\n$$\n\\Omega_{n}(\\mathbf{k}) = s_n \\frac{1}{2} \\frac{\\mathbf{d}(\\mathbf{k}) \\cdot \\left( \\frac{\\partial \\mathbf{d}}{\\partial k_x} \\times \\frac{\\partial \\mathbf{d}}{\\partial k_y} \\right)}{\\|\\mathbf{d}(\\mathbf{k})\\|^3},\n$$\n其中 $s_{+} = +1$，$s_{-} = -1$。对于指定的 $\\mathbf{d}(\\mathbf{k})$，可得\n$$\n\\Omega_{\\pm}(\\mathbf{k}) = \\pm \\frac{m A^2}{2 \\left(m^2 + A^2 k_x^2 + A^2 k_y^2\\right)^{3/2}}.\n$$\n占据函数 $f(E)$ 使用高斯展宽作为亥维赛阶跃函数在 $E_F = 0$ 处的代理来近似：\n$$\nf(E) = \\frac{1}{2} \\left[ 1 - \\operatorname{erf}\\left( \\frac{E - E_F}{\\sqrt{2}\\,\\sigma} \\right) \\right],\n$$\n其中 $\\sigma>0$ 是展宽宽度，$\\operatorname{erf}(\\cdot)$ 是误差函数。这种选择确保了当 $\\sigma \\to 0^+$ 时，跃变是平滑但越来越陡峭的。\n\n您的程序必须：\n1. 构建一个方形积分域 $\\mathcal{D} = \\{(k_x,k_y) \\mid -k_{\\max} \\le k_x \\le k_{\\max},\\ -k_{\\max} \\le k_y \\le k_{\\max}\\}$，并通过一个 $N_k \\times N_k$ 的 $k$ 点矩形网格对 $\\sigma_{xy}^{\\mathrm{norm}}$ 进行数值积分。使用 $A = 1$，$m = 1$，$E_F = 0$，以及 $k_{\\max} = 10$。\n2. 对于给定的参数三元组 $(N_k, \\sigma, p)$，按如下方式计算 $\\sigma_{xy}^{\\mathrm{norm}}$：\n   - 在粗糙的 $N_k \\times N_k$ 网格上计算被积函数 $g(\\mathbf{k}) = \\sum_{n \\in \\{+,-\\}} f(E_n(\\mathbf{k}))\\,\\Omega_n(\\mathbf{k})$。\n   - 使用样条插值阶数 $p \\in \\{0,1,3\\}$ 将 $g(\\mathbf{k})$ 插值到一个大小为 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 的公共精细网格上，其中 $p=0$ 是最近邻插值，$p=1$ 是双线性插值，$p=3$ 是双三次插值。使用 $N_{\\mathrm{ref}} = 800$。\n   - 在精细网格上使用矩形法则进行积分，面积元为 $\\Delta A = \\left(\\frac{2k_{\\max}}{N_{\\mathrm{ref}}}\\right)^2$，并应用归一化因子 $\\frac{1}{2\\pi}$。\n3. 通过直接在 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 网格上使用展宽宽度 $\\sigma_{\\mathrm{ref}} = 10^{-6}$ 且不进行任何插值来计算相同的积分，从而建立一个高精度基准 $\\sigma_{xy}^{\\mathrm{norm,ref}}$。\n\n定义相对偏差\n$$\n\\Delta = \\left| \\frac{\\sigma_{xy}^{\\mathrm{norm}} - \\sigma_{xy}^{\\mathrm{norm,ref}}}{\\sigma_{xy}^{\\mathrm{norm,ref}}} \\right|,\n$$\n并评估是否达到了目标容差 $|\\Delta\\sigma_{xy}|  1\\%$，即 $\\Delta  0.01$ 是否成立。\n\n您的程序必须评估以下参数三元组的测试用例套件 $(N_k, \\sigma, p)$：\n- 案例 1: $(32, 0.02, 1)$\n- 案例 2: $(128, 0.01, 1)$\n- 案例 3: $(64, 0.05, 3)$\n- 案例 4: $(16, 0.10, 1)$\n- 案例 5: $(64, 0.0001, 3)$\n- 案例 6: $(48, 0.05, 0)$\n\n物理单位：反常霍尔电导率以无量纲的归一化单位报告（除以 $e^2/h$）。不需要其他物理单位。角度单位不适用。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的、逗号分隔的布尔值列表，其顺序与测试用例套件相同（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4},\\mathrm{result5},\\mathrm{result6}]$），其中每个布尔值表示该案例是否满足1%的容差要求。",
            "solution": "此问题是有效的。它提出了一个定义明确的数值任务，该任务基于凝聚态物理中反常霍尔效应的标准理论框架。所有必需的方程、参数和程序都已指定，并且没有内部矛盾或科学不准确之处。\n\n目标是为一个二维有质量狄拉克模型执行反常霍尔电导率（AHC）的数值收敛性研究。这涉及计算几种数值参数组合（k点网格密度、能量展宽和插值阶数）下的AHC，并将它们与一个高精度参考值进行比较，以确定是否满足指定的容差。\n\n核心物理量是归一化反常霍尔电导率 $\\sigma_{xy}^{\\mathrm{norm}}$，它由Kubo-Streda公式以贝里曲率 $\\Omega_n(\\mathbf{k})$ 的形式给出：\n$$\n\\sigma_{xy}^{\\mathrm{norm}} = \\frac{1}{2\\pi} \\sum_{n \\in \\{+,-\\}} \\int_{\\mathcal{D}} f\\left(E_n(\\mathbf{k})\\right) \\, \\Omega_n(\\mathbf{k}) \\, d^2 k\n$$\n该积分在动量空间（$\\mathbf{k}$-空间）中的指定域 $\\mathcal{D}$ 上进行。该公式的各组成部分由模型哈密顿量 $H(\\mathbf{k}) = \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}$ 定义，其中 $\\boldsymbol{\\sigma}$ 是泡利矩阵的矢量，$\\mathbf{d}(\\mathbf{k}) = (A k_x, A k_y, m)$。\n\n两个能带（导带和价带）的能量本征值为 $E_n(\\mathbf{k})$，其中 $n \\in \\{+,-\\}$：\n$$\nE_{\\pm}(\\mathbf{k}) = \\pm \\|\\mathbf{d}(\\mathbf{k})\\| = \\pm \\sqrt{A^2 k_x^2 + A^2 k_y^2 + m^2}\n$$\n贝里曲率 $\\Omega_n(\\mathbf{k})$ 在动量空间中充当赝磁场，对于此模型，其表达式为：\n$$\n\\Omega_{\\pm}(\\mathbf{k}) = \\pm \\frac{m A^2}{2 \\left(m^2 + A^2 k_x^2 + A^2 k_y^2\\right)^{3/2}}\n$$\n我们观察到 $\\Omega_+(\\mathbf{k}) = -\\Omega_-(\\mathbf{k})$。函数 $f(E)$ 是占据函数。在零温下，它是一个亥维赛阶跃函数，$f(E) = \\Theta(E_F - E)$。为了数值稳定性，它被一个高斯展宽近似所取代：\n$$\nf(E) = \\frac{1}{2} \\left[ 1 - \\operatorname{erf}\\left( \\frac{E - E_F}{\\sqrt{2}\\,\\sigma} \\right) \\right]\n$$\n其中 $E_F=0$ 是费米能级，$\\sigma$ 是展宽宽度。\n\n被积函数可以被简化。令 $g(\\mathbf{k}) = \\sum_{n} f(E_n(\\mathbf{k})) \\Omega_n(\\mathbf{k})$。代入表达式并利用 $E_+ = -E_-$ 和 $\\Omega_+ = -\\Omega_-$：\n$$\ng(\\mathbf{k}) = f(E_+)\\Omega_+ + f(E_-)\\Omega_- = f(E_+)\\Omega_+ + f(-E_+)(-\\Omega_+) = \\Omega_+ \\left[ f(E_+) - f(-E_+) \\right]\n$$\n使用 $f(E)$ 的定义（其中 $E_F=0$）以及 $\\operatorname{erf}(-x) = -\\operatorname{erf}(x)$ 的性质：\n$$\nf(E_+) - f(-E_+) = \\frac{1}{2}\\left[1 - \\operatorname{erf}\\left(\\frac{E_+}{\\sqrt{2}\\sigma}\\right)\\right] - \\frac{1}{2}\\left[1 - \\operatorname{erf}\\left(\\frac{-E_+}{\\sqrt{2}\\sigma}\\right)\\right] = -\\operatorname{erf}\\left(\\frac{E_+}{\\sqrt{2}\\sigma}\\right)\n$$\n因此，总被积函数简化为单项：\n$$\ng(\\mathbf{k}) = -\\Omega_+(\\mathbf{k}) \\operatorname{erf}\\left(\\frac{E_+(\\mathbf{k})}{\\sqrt{2}\\,\\sigma}\\right)\n$$\n这种形式在计算上更高效，因为它将函数求值次数减半。\n\n数值流程如下：\n首先，建立一个高精度参考值 $\\sigma_{xy}^{\\mathrm{norm,ref}}$。这是通过在 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 点的精细网格上直接对 $g(\\mathbf{k})$ 在域 $\\mathcal{D} = [-k_{\\max}, k_{\\max}] \\times [-k_{\\max}, k_{\\max}]$ 上进行数值积分来完成的。积分使用矩形法则执行：\n$$\n\\sigma_{xy}^{\\mathrm{norm,ref}} = \\frac{1}{2\\pi} \\sum_{i,j} g(\\mathbf{k}_{ij}; \\sigma_{\\mathrm{ref}}) \\Delta A\n$$\n其中 $\\mathbf{k}_{ij}$ 是 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 网格上的点，展宽是一个很小的值 $\\sigma_{\\mathrm{ref}} = 10^{-6}$ 以近似零温极限，面积元为 $\\Delta A = \\left(\\frac{2k_{\\max}}{N_{\\mathrm{ref}}}\\right)^2$。在实现中，我们使用具体的模型参数 $A=1$，$m=1$，$k_{\\max}=10$，以及 $N_{\\mathrm{ref}}=800$。\n\n其次，对于每个测试用例三元组 $(N_k, \\sigma, p)$，计算一个测试值 $\\sigma_{xy}^{\\mathrm{norm}}$。这涉及一个多步骤过程，旨在模拟在粗糙网格上执行计算然后进行插值的实际计算工作流程：\n1.  在粗糙的 $N_k \\times N_k$ 网格上计算被积函数 $g(\\mathbf{k}; \\sigma)$。\n2.  使用阶数为 $p$ 的样条插值将所得值插值到精细的 $N_{\\mathrm{ref}} \\times N_{\\mathrm{ref}}$ 网格上。映射关系为 $p=0$ (最近邻)，$p=1$ (双线性)，以及 $p=3$ (双三次)。\n3.  使用与参考计算相同的矩形法则在精细网格上对插值函数 $g_{\\mathrm{interp}}(\\mathbf{k})$ 进行积分。\n\n最后，对于每个测试用例，计算相对偏差 $\\Delta$ 并与容差进行比较：\n$$\n\\Delta = \\left| \\frac{\\sigma_{xy}^{\\mathrm{norm}} - \\sigma_{xy}^{\\mathrm{norm,ref}}}{\\sigma_{xy}^{\\mathrm{norm,ref}}} \\right|  0.01\n$$\n每个案例的结果是一个布尔值，指示此条件是否满足。实现将使用 `numpy` 进行高效的数组计算，并使用 `scipy.interpolate.RegularGridInterpolator` 用于插值步骤，它将整数阶数 $p$ 映射到所需的插值方案。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes a numerical convergence study for anomalous Hall conductivity (AHC).\n    \"\"\"\n    # Define constants and global parameters from the problem statement\n    A = 1.0\n    m = 1.0\n    k_max = 10.0\n    E_F = 0.0\n    N_ref = 800\n    sigma_ref = 1e-6\n\n    # --- Step 1: Define the fine reference grid ---\n    # The grid points are defined by linspace, spanning the domain.\n    k_ref_coords = np.linspace(-k_max, k_max, N_ref)\n    kx_ref_grid, ky_ref_grid = np.meshgrid(k_ref_coords, k_ref_coords, indexing='ij')\n\n    # --- Step 2: Define the physical functions based on the model ---\n    \n    # Memoize energy and Berry curvature on the fine grid to avoid re-computation\n    _energy_ref_grid = np.sqrt((A * kx_ref_grid)**2 + (A * ky_ref_grid)**2 + m**2)\n    _omega_plus_ref_grid = (m * A**2) / (2 * _energy_ref_grid**3)\n\n    def calculate_integrand(kx_grid, ky_grid, sigma):\n        \"\"\"\n        Calculates the simplified integrand g(k) on a given grid.\n        g(k) = -Omega_+(k) * erf(E_+(k) / (sqrt(2)*sigma))\n        \"\"\"\n        energy = np.sqrt((A * kx_grid)**2 + (A * ky_grid)**2 + m**2)\n        omega_plus = (m * A**2) / (2 * energy**3)\n        \n        # In the limit of small sigma, E/sigma becomes large, and erf(...) -> 1 for E>0.\n        if sigma  1e-12:\n            erf_term = np.ones_like(energy)\n        else:\n            erf_term = erf(energy / (np.sqrt(2) * sigma))\n        \n        return -omega_plus * erf_term\n\n    # --- Step 3: Calculate the high-accuracy reference AHC ---\n    # Calculate integrand on the fine grid with the reference smearing\n    integrand_ref = calculate_integrand(kx_ref_grid, ky_ref_grid, sigma_ref)\n\n    # Integrate using the rectangle rule as specified\n    dk_ref_area = ((2 * k_max) / N_ref) ** 2\n    integral_ref = np.sum(integrand_ref) * dk_ref_area\n    sigma_xy_ref = integral_ref / (2 * np.pi)\n\n    # --- Step 4: Define test suite and process each case ---\n    test_cases = [\n        # (Nk, sigma, p)\n        (32, 0.02, 1),\n        (128, 0.01, 1),\n        (64, 0.05, 3),\n        (16, 0.10, 1),\n        (64, 0.0001, 3),\n        (48, 0.05, 0),\n    ]\n\n    # Map interpolation order p to scipy's 'kind' argument\n    p_map = {0: 'nearest', 1: 'linear', 3: 'cubic'}\n    \n    results = []\n    \n    # Grid of points for evaluating the interpolator\n    fine_points_for_interp = np.stack([kx_ref_grid.ravel(), ky_ref_grid.ravel()], axis=-1)\n\n    for Nk, sigma, p in test_cases:\n        # Define the coarse grid for the current test case\n        k_coarse_coords = np.linspace(-k_max, k_max, Nk)\n        kx_coarse_grid, ky_coarse_grid = np.meshgrid(k_coarse_coords, k_coarse_coords, indexing='ij')\n\n        # Calculate integrand on the coarse grid with the case-specific smearing\n        integrand_coarse = calculate_integrand(kx_coarse_grid, ky_coarse_grid, sigma)\n\n        # Set up and run the interpolation from the coarse grid to the fine grid\n        interpolator = RegularGridInterpolator(\n            (k_coarse_coords, k_coarse_coords), \n            integrand_coarse, \n            method=p_map[p], \n            bounds_error=False, \n            fill_value=0.0\n        )\n        \n        # Evaluate the interpolator on the fine grid points\n        integrand_interp = interpolator(fine_points_for_interp).reshape((N_ref, N_ref))\n        \n        # Integrate the interpolated function on the fine grid\n        integral_test = np.sum(integrand_interp) * dk_ref_area\n        sigma_xy_test = integral_test / (2 * np.pi)\n\n        # Calculate the relative deviation and check against the 1% tolerance\n        # The value of sigma_xy_ref is ~-0.45, so no risk of division by zero.\n        delta = np.abs((sigma_xy_test - sigma_xy_ref) / sigma_xy_ref)\n        \n        results.append(delta  0.01)\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}