{
    "hands_on_practices": [
        {
            "introduction": "A primary goal of first-principles calculations in magnetism is to bridge the quantum-mechanical scale with macroscopic continuum models, such as micromagnetism. This exercise guides you through this crucial process by showing how to extract fundamental magnetic parameters from the computed energy landscape of spin spirals. You will fit a set of synthetic total energies $E(\\mathbf{q})$ to the theoretical long-wavelength expansion to determine the spin stiffness $D$, the Dzyaloshinskii-Moriya interaction (DMI) vector $\\mathbf{D}$, and the magnetocrystalline anisotropy constant $K$, providing a direct link between DFT and effective magnetic Hamiltonians .",
            "id": "3468726",
            "problem": "You are given synthetic first-principles total energies for planar spin spirals in a metallic ferromagnet, computed under three exchange–correlation approximations: Local Spin Density Approximation (LSDA), Generalized Gradient Approximation (GGA), and meta-Generalized Gradient Approximation (meta-GGA). For small wavevectors, symmetry and analyticity imply that the energy per atom of a homogeneous spin spiral with propagation vector $\\mathbf{q}$ and chirality $s \\in \\{+1,-1\\}$ admits the lowest-order expansion\n$$\nE(\\mathbf{q},s,c)=E_{0} + K c + D \\lvert \\mathbf{q} \\rvert^{2} + s \\mathbf{D}\\cdot\\mathbf{q},\n$$\nwhere $E_{0}$ is a baseline energy, $D$ is the scalar spin stiffness, $\\mathbf{D}$ is the Dzyaloshinskii–Moriya Interaction (DMI) vector, $K$ is the uniaxial magnetocrystalline anisotropy constant relative to the easy axis $\\hat{\\mathbf{z}}$, and $c$ is an orientation factor for the anisotropy contribution. For the data provided here, all spin spirals are planar in the $xy$-plane, so $c=1$ for all noncollinear spirals. Two uniform (collinear) states are also provided: one aligned with the easy axis $\\hat{\\mathbf{z}}$ for which $c=0$, and one perpendicular to $\\hat{\\mathbf{z}}$ for which $c=1$. The chirality $s=+1$ denotes right-handed rotation and $s=-1$ denotes left-handed rotation. The units are as follows: energies in milli-electronvolts per atom (meV/atom), wavevectors in inverse ångström ($\\text{\\AA}^{-1}$), so that $D$ is in $\\text{meV}\\cdot\\text{\\AA}^{2}$ and $\\mathbf{D}$ in $\\text{meV}\\cdot\\text{\\AA}$, and $K$ in meV/atom.\n\nTask. Starting from the expansion above and the principle of linear superposition for the different invariant contributions, derive an algorithm that, given a set of measurements $\\{(\\mathbf{q}_{i},s_{i},c_{i},E_{i})\\}$, estimates the parameters $\\{D,\\mathbf{D},K\\}$ by solving a linear least-squares problem over the regressors $\\{1,c_{i},\\lvert \\mathbf{q}_{i}\\rvert^{2}, s_{i} q_{i,x}, s_{i} q_{i,y}, s_{i} q_{i,z}\\}$. Then implement the algorithm as a complete, runnable program that reports the fitted parameters for each functional as specified below.\n\nData. For each functional, you are given the list of tuples $(q_{x},q_{y},q_{z},s,c,E)$ as follows. All $E$ values are in meV/atom and all $q$ components in $\\text{\\AA}^{-1}$. The uniform states are listed last with $\\mathbf{q}=\\mathbf{0}$; for these, use $s=0$.\n\n- LSDA (Local Spin Density Approximation):\n  - Spirals:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-117.71)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-117.89)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-117.83)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-117.77)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-118.448)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-118.448)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-118.67)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-118.73)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-119.069)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-119.087)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-119.171)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-119.093)$\n  - Uniform:\n    - $(0.00,0.00,0.00,0,0,-120.00)$\n    - $(0.00,0.00,0.00,0,1,-119.60)$\n\n- GGA (Generalized Gradient Approximation):\n  - Spirals:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-147.63)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-147.87)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-147.70)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-147.80)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-148.47)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-148.47)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-148.665)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-148.835)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-149.131)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-149.209)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-149.273)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-149.187)$\n  - Uniform:\n    - $(0.00,0.00,0.00,0,0,-150.00)$\n    - $(0.00,0.00,0.00,0,1,-149.75)\n\n- meta-GGA (meta-Generalized Gradient Approximation):\n  - Spirals:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-197.76)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-197.76)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-198.468)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-198.516)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-198.80)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-198.80)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-199.244)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-199.280)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-199.289)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-199.367)$\n  - Uniform:\n    - $(0.00,0.00,0.00,0,0,-200.00)$\n    - $(0.00,0.00,0.00,0,1,-199.90)$\n\nRequirements.\n- Use only the linear model stated above and derive a least-squares estimator from first principles by constructing a design matrix with columns corresponding to $1$, $c$, $\\lvert \\mathbf{q} \\rvert^{2}$, $s\\,q_{x}$, $s\\,q_{y}$, $s\\,q_{z}$.\n- For each functional, estimate and report the tuple $[D,D_{x},D_{y},D_{z},K]$, where $\\mathbf{D}=(D_{x},D_{y},D_{z})$.\n- Numerical units:\n  - Energies must be treated in meV/atom.\n  - Wavevectors must be treated in $\\text{\\AA}^{-1}$.\n  - Report $D$ in $\\text{meV}\\cdot\\text{\\AA}^{2}$, each component of $\\mathbf{D}$ in $\\text{meV}\\cdot\\text{\\AA}$, and $K$ in meV/atom.\n- Angle units are not used in this problem.\n- Output rounding: Round each reported number to three decimal places.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one functional in the order LSDA, GGA, meta-GGA. The exact format is\n  $$\n  \\big[\\,[D_{\\mathrm{LSDA}},D_{x,\\mathrm{LSDA}},D_{y,\\mathrm{LSDA}},D_{z,\\mathrm{LSDA}},K_{\\mathrm{LSDA}}],\\,[D_{\\mathrm{GGA}},D_{x,\\mathrm{GGA}},D_{y,\\mathrm{GGA}},D_{z,\\mathrm{GGA}},K_{\\mathrm{GGA}}],\\,[D_{\\mathrm{mGGA}},D_{x,\\mathrm{mGGA}},D_{y,\\mathrm{mGGA}},D_{z,\\mathrm{mGGA}},K_{\\mathrm{mGGA}}]\\,\\big]\n  $$\n  where each value is rounded to three decimals. For example, an output could look like\n  $$\n  [[180.000,0.900,-0.300,0.000,0.400],[200.000,1.200,0.500,0.000,0.250],[220.000,-0.600,0.600,0.300,0.100]].\n  $$\n\nTest suite and coverage.\n- The LSDA set includes a direction with $q_{z}\\neq 0$ but $D_{z}=0$, and a case with $s$-independent energy to probe the absence of DMI along $z$.\n- The GGA set exercises nonzero $D_{x}$ and $D_{y}$ with both chiralities and multiple magnitudes of $\\lvert \\mathbf{q}\\rvert$ to constrain $D$ robustly.\n- The meta-GGA set includes nonzero $D_{z}$ and a spiral with $\\mathbf{D}\\cdot\\mathbf{q}=0$ to test sensitivity to null-projection scenarios.\n- Uniform states at $\\mathbf{q}=\\mathbf{0}$ with $c=0$ and $c=1$ allow independent identification of $K$ and separation from the intercept $E_{0}$.\n\nYour submission must be a single, complete program that constructs the design matrices from the provided data, solves the least-squares problems, and prints the results in the exact format described above, with all numbers rounded to three decimals, using no input files. The program must be self-contained and runnable as is.",
            "solution": "The problem requires the derivation and implementation of an algorithm to estimate micromagnetic parameters from a set of synthetic first-principles total energy calculations. The provided model for the energy $E$ per atom of a planar spin spiral as a function of its wavevector $\\mathbf{q}$, chirality $s$, and an anisotropy orientation factor $c$ is:\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,\\lvert \\mathbf{q} \\rvert^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q}\n$$\nwhere $E_{0}$ is a baseline energy, $K$ is the uniaxial magnetocrystalline anisotropy constant, $D$ is the scalar spin stiffness, and $\\mathbf{D}$ is the Dzyaloshinskii–Moriya Interaction (DMI) vector. The task is to estimate the parameters $\\{D, \\mathbf{D}, K\\}$.\n\nFirst, we expand the DMI term $s\\,\\mathbf{D}\\cdot\\mathbf{q}$. With $\\mathbf{D} = (D_{x}, D_{y}, D_{z})$ and $\\mathbf{q} = (q_{x}, q_{y}, q_{z})$, this becomes $s(D_{x}q_{x} + D_{y}q_{y} + D_{z}q_{z})$. Substituting this into the energy model reveals its linear structure with respect to the parameters:\n$$\nE(\\mathbf{q},s,c) = E_{0}(1) + K(c) + D(\\lvert\\mathbf{q}\\rvert^{2}) + D_{x}(s q_{x}) + D_{y}(s q_{y}) + D_{z}(s q_{z})\n$$\nThe terms in parentheses are the regressor variables, and $\\{E_{0}, K, D, D_{x}, D_{y}, D_{z}\\}$ are the coefficients to be determined. Given a set of $N$ measurements $\\{(\\mathbf{q}_{i}, s_{i}, c_{i}, E_{i})\\}_{i=1}^{N}$, this defines a system of linear equations. This system is amenable to a linear least-squares analysis.\n\nWe formulate the problem in matrix notation as $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\beta}$, where:\n- $\\mathbf{y}$ is the $N \\times 1$ column vector of observed energies: $\\mathbf{y} = [E_{1}, E_{2}, \\dots, E_{N}]^T$.\n- $\\boldsymbol{\\beta}$ is the $M \\times 1$ column vector of the unknown model parameters. For this problem, there are $M=6$ parameters. We define $\\boldsymbol{\\beta}$ based on the order of regressors specified in the problem statement: $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5]^T = [E_0, K, D, D_x, D_y, D_z]^T$.\n- $\\mathbf{X}$ is the $N \\times M$ design matrix. Each row $i$ of $\\mathbf{X}$ is constructed from the $i$-th data point, and the columns correspond to the regressors $\\{1, c, \\lvert\\mathbf{q}\\rvert^{2}, s q_{x}, s q_{y}, s q_{z}\\}$. Specifically, the $i$-th row is:\n$$\n\\mathbf{X}_{i,:} = \\begin{bmatrix} 1 & c_{i} & \\lvert\\mathbf{q}_{i}\\rvert^{2} & s_{i}q_{i,x} & s_{i}q_{i,y} & s_{i}q_{i,z} \\end{bmatrix}\n$$\nwhere $\\lvert\\mathbf{q}_{i}\\rvert^{2} = q_{i,x}^2 + q_{i,y}^2 + q_{i,z}^2$.\n\nThe linear least-squares method seeks the parameter vector $\\hat{\\boldsymbol{\\beta}}$ that minimizes the sum of squared residuals, $S = \\sum_{i=1}^{N} (E_i - \\mathbf{X}_{i,:}\\boldsymbol{\\beta})^2 = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})$. The solution that minimizes $S$ is found by solving the normal equations:\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\nAssuming the columns of $\\mathbf{X}$ are linearly independent (which is generally true for a well-designed set of measurements), the matrix $\\mathbf{X}^T \\mathbf{X}$ is invertible. The unique least-squares estimate of the parameter vector is then:\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\nThe implemented algorithm will, for each functional's dataset:\n1.  Construct the design matrix $\\mathbf{X}$ and the observation vector $\\mathbf{y}$ from the provided data tuples $(q_{x}, q_{y}, q_{z}, s, c, E)$.\n2.  Numerically compute the parameter vector $\\hat{\\boldsymbol{\\beta}}$ by solving the linear least-squares problem. This is best done using a stable numerical routine, such as one based on QR decomposition or Singular Value Decomposition (SVD), which is more robust than explicitly computing the inverse of $\\mathbf{X}^T \\mathbf{X}$.\n3.  The components of the resulting vector $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5]^T$ are the estimates for the physical parameters:\n    - Anisotropy constant $K \\approx \\hat{\\beta}_1$\n    - Spin stiffness $D \\approx \\hat{\\beta}_2$\n    - DMI vector components $\\{D_x, D_y, D_z\\} \\approx \\{\\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5\\}$\n4.  Assemble the required output tuple $[D, D_x, D_y, D_z, K]$ from the components of $\\hat{\\boldsymbol{\\beta}}$, which corresponds to $[\\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5, \\hat{\\beta}_1]$.\n5.  Round the final values to three decimal places and format them as specified.\nThis procedure systematically derives the physical parameters from the energy data based on the provided theoretical model.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Fits micromagnetic parameters to synthetic first-principles energy data\n    using linear least-squares regression and prints the results.\n    \"\"\"\n    \n    # Data sets provided in the problem statement.\n    # Each tuple is (qx, qy, qz, s, c, E).\n    lsda_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -117.71),\n        (0.10, 0.00, 0.00, -1, 1, -117.89),\n        (0.00, 0.10, 0.00, 1, 1, -117.83),\n        (0.00, 0.10, 0.00, -1, 1, -117.77),\n        (0.00, 0.00, 0.08, 1, 1, -118.448),\n        (0.00, 0.00, 0.08, -1, 1, -118.448),\n        (0.05, 0.05, 0.00, 1, 1, -118.67),\n        (0.05, 0.05, 0.00, -1, 1, -118.73),\n        (0.02, 0.03, 0.04, 1, 1, -119.069),\n        (0.02, 0.03, 0.04, -1, 1, -119.087),\n        (-0.04, 0.01, 0.03, 1, 1, -119.171),\n        (-0.04, 0.01, 0.03, -1, 1, -119.093),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -120.00),\n        (0.00, 0.00, 0.00, 0, 1, -119.60)\n    ]\n\n    gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -147.63),\n        (0.10, 0.00, 0.00, -1, 1, -147.87),\n        (0.00, 0.10, 0.00, 1, 1, -147.70),\n        (0.00, 0.10, 0.00, -1, 1, -147.80),\n        (0.00, 0.00, 0.08, 1, 1, -148.47),\n        (0.00, 0.00, 0.08, -1, 1, -148.47),\n        (0.05, 0.05, 0.00, 1, 1, -148.665),\n        (0.05, 0.05, 0.00, -1, 1, -148.835),\n        (0.02, 0.03, 0.04, 1, 1, -149.131),\n        (0.02, 0.03, 0.04, -1, 1, -149.209),\n        (-0.04, 0.01, 0.03, 1, 1, -149.273),\n        (-0.04, 0.01, 0.03, -1, 1, -149.187),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -150.00),\n        (0.00, 0.00, 0.00, 0, 1, -149.75)\n    ]\n\n    meta_gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -197.76),\n        (0.10, 0.00, 0.00, -1, 1, -197.64),\n        (0.00, 0.10, 0.00, 1, 1, -197.64),\n        (0.00, 0.10, 0.00, -1, 1, -197.76),\n        (0.00, 0.00, 0.08, 1, 1, -198.468),\n        (0.00, 0.00, 0.08, -1, 1, -198.516),\n        (0.05, 0.05, 0.00, 1, 1, -198.80),\n        (0.05, 0.05, 0.00, -1, 1, -198.80),\n        (0.02, 0.03, 0.04, 1, 1, -199.244),\n        (0.02, 0.03, 0.04, -1, 1, -199.280),\n        (-0.04, 0.01, 0.03, 1, 1, -199.289),\n        (-0.04, 0.01, 0.03, -1, 1, -199.367),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -200.00),\n        (0.00, 0.00, 0.00, 0, 1, -199.90)\n    ]\n\n    all_datasets = [lsda_data, gga_data, meta_gga_data]\n    overall_results = []\n\n    for dataset in all_datasets:\n        num_points = len(dataset)\n        # Design matrix X: columns for [1, c, |q|^2, s*qx, s*qy, s*qz]\n        X = np.zeros((num_points, 6))\n        # Observation vector y: energies E\n        y = np.zeros(num_points)\n\n        for i, point in enumerate(dataset):\n            qx, qy, qz, s, c, E = point\n            q_sq = qx**2 + qy**2 + qz**2\n            \n            X[i, 0] = 1.0       # Corresponds to E0 (intercept)\n            X[i, 1] = float(c)  # Corresponds to K\n            X[i, 2] = q_sq      # Corresponds to D\n            X[i, 3] = s * qx    # Corresponds to Dx\n            X[i, 4] = s * qy    # Corresponds to Dy\n            X[i, 5] = s * qz    # Corresponds to Dz\n            \n            y[i] = E\n\n        # Solve the linear least-squares problem X*p = y for p\n        params, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # Extract parameters according to the model: E = E0 + K*c + D*|q|^2 + ...\n        # params[0] = E0\n        K = params[1]\n        D = params[2]\n        Dx = params[3]\n        Dy = params[4]\n        Dz = params[5]\n        \n        # Assemble the results in the required order: [D, Dx, Dy, Dz, K]\n        result_list = [D, Dx, Dy, Dz, K]\n        overall_results.append(result_list)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to three decimal places.\n    output_parts = []\n    for res_list in overall_results:\n        formatted_numbers = [f\"{num:.3f}\" for num in res_list]\n        output_parts.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The accuracy of the parameters derived in the previous practice depends critically on the quality of the calculated $E(\\mathbf{q})$ energy surface. This exercise tackles a subtle but significant numerical challenge: the error introduced when the discrete $\\mathbf{k}$-point grid used for Brillouin zone integration is incommensurate with the spin-spiral vector $\\mathbf{q}$. Through a simplified model, you will quantify this bias and implement a powerful adaptive sampling strategy that constructs a commensurate grid to eliminate the interpolation error, a key skill for obtaining reliable results for modulated structures .",
            "id": "3468708",
            "problem": "You are tasked with quantifying how non-commensurate $\\mathbf{k}$-point grids bias the computed spin-spiral energy $E(\\mathbf{q})$ in a simplified first-principles inspired model of non-collinear magnetism, and to implement an adaptive $\\mathbf{k}+\\mathbf{q}$ sampling strategy that ameliorates this bias. The setting is a two-dimensional square lattice with a single-band tight-binding dispersion and a surrogate for the generalized Bloch theorem coupling.\n\nBase assumptions and definitions:\n- Consider a two-dimensional Brillouin zone that is the Cartesian product $[-\\pi,\\pi)\\times[-\\pi,\\pi)$ in radians. All angles must be in radians.\n- Use the single-band tight-binding dispersion on a square lattice\n$$\n\\varepsilon(\\mathbf{k}) \\equiv \\varepsilon(k_x,k_y) = -2t\\left[\\cos(k_x) + \\cos(k_y)\\right],\n$$\nwith $t=1$ (dimensionless).\n- In a spin-spiral described by the Generalized Bloch Theorem (GBT), a wave vector $\\mathbf{q}$ couples $\\mathbf{k}$-states to $\\mathbf{k}+\\mathbf{q}$. As a smooth surrogate for second-order perturbation energy in the presence of weak exchange, define\n$$\nS(x,y;\\alpha) = \\frac{1}{1 + \\alpha (y-x)^2},\n$$\nwith $\\alpha=0.5$ (dimensionless). The spin-spiral energy functional is defined as the Brillouin-zone average\n$$\nE(\\mathbf{q}) = \\frac{1}{\\Omega_{\\text{BZ}}}\\int_{\\text{BZ}} d^2k \\; S\\big(\\varepsilon(\\mathbf{k}),\\varepsilon(\\mathbf{k}+\\mathbf{q});\\alpha\\big),\n$$\nwhere $\\Omega_{\\text{BZ}}=(2\\pi)^2$.\n\nDiscrete sampling and numerical tasks:\n- Replace the Brillouin-zone integral by a uniform Monkhorst-Pack like sum on an $N\\times N$ grid with Cartesian nodes\n$$\nk_x(i) = -\\pi + \\left(i+\\tfrac{1}{2}\\right)\\Delta, \\quad k_y(j) = -\\pi + \\left(j+\\tfrac{1}{2}\\right)\\Delta,\\quad \\Delta=\\frac{2\\pi}{N},\n$$\nfor integers $i,j\\in\\{0,1,\\dots,N-1\\}$.\n- Define a periodic wrapping operator $\\mathcal{W}$ that maps any angle $\\theta$ to $[-\\pi,\\pi)$ by $\\mathcal{W}(\\theta)=((\\theta+\\pi)\\bmod 2\\pi)-\\pi$.\n\nImplement three numerical estimators of $E(\\mathbf{q})$:\n1. A high-resolution reference $E_{\\text{ref}}(\\mathbf{q})$ computed by the above Riemann sum on a dense grid of size $N_{\\text{ref}}\\times N_{\\text{ref}}$ with $N_{\\text{ref}}=384$.\n2. A coarse non-adaptive estimate $E_{\\text{na}}(\\mathbf{q};N)$ on an $N\\times N$ grid that emulates a code which only knows band energies on the coarse grid:\n   - Precompute $\\varepsilon$ only at the $N\\times N$ grid points.\n   - For each coarse grid point $\\mathbf{k}$, form $\\mathbf{k}+\\mathbf{q}$, wrap each component with $\\mathcal{W}$, and evaluate $\\varepsilon(\\mathbf{k}+\\mathbf{q})$ by periodic bilinear interpolation from the $N\\times N$ table of precomputed values. When $\\mathbf{q}$ is commensurate with the coarse mesh (i.e., both $q_x/\\Delta$ and $q_y/\\Delta$ are integers), the interpolation reduces to exact table lookup.\n   - Average $S\\big(\\varepsilon(\\mathbf{k}),\\varepsilon(\\mathbf{k}+\\mathbf{q});\\alpha\\big)$ over the $N\\times N$ grid to obtain $E_{\\text{na}}(\\mathbf{q};N)$.\n3. An adaptive $\\mathbf{k}+\\mathbf{q}$ estimate $E_{\\text{ad}}(\\mathbf{q};N)$ that seeks a refined grid commensurate with $\\mathbf{q}$:\n   - For a tolerance $\\tau=10^{-12}$ and an upper bound $M_{\\max}=96$, find the smallest integer $M\\ge N$ such that both $q_x/\\Delta_M$ and $q_y/\\Delta_M$ are within $\\tau$ of an integer, where $\\Delta_M=2\\pi/M$. If no such $M\\le M_{\\max}$ exists, set $M=M_{\\max}$.\n   - Compute $E_{\\text{ad}}(\\mathbf{q};N)$ as in the non-adaptive case but using the $M\\times M$ grid and periodic bilinear interpolation on that refined grid. When commensurability is achieved, the bilinear interpolation again reduces to exact table lookup, removing the $\\mathbf{k}+\\mathbf{q}$ alignment bias.\n\nError metrics:\n- For each test case, compute the relative errors\n$$\n\\delta_{\\text{na}} = \\frac{\\left|E_{\\text{na}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|,10^{-12}\\right)},\\quad\n\\delta_{\\text{ad}} = \\frac{\\left|E_{\\text{ad}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|,10^{-12}\\right)}.\n$$\n- Also report the boolean $b_{\\text{imp}}$ which is true if and only if $\\delta_{\\text{ad}} < \\delta_{\\text{na}}$.\n\nTest suite:\n- Use the following four test cases, which probe commensurate and incommensurate scenarios, multi-component $\\mathbf{q}$, and a boundary condition:\n  - Case A: $N=12$, $\\mathbf{q}=(\\pi/3,\\,0)$.\n  - Case B: $N=12$, $\\mathbf{q}=(\\pi/5,\\,0)$.\n  - Case C: $N=12$, $\\mathbf{q}=(\\pi/5,\\,2\\pi/5)$.\n  - Case D: $N=12$, $\\mathbf{q}=(0,\\,0)$.\n\nFinal output requirement:\n- Your program must produce a single line of output containing a list of lists, one inner list per test case in the order A, B, C, D. Each inner list must contain exactly three entries in this order: $\\delta_{\\text{na}}$ as a float, $\\delta_{\\text{ad}}$ as a float, and $b_{\\text{imp}}$ as a boolean. The output must have the exact format of a Python literal list, for example, $[[0.1,0.05,True],[\\dots],\\dots]$ with no extra text, spaces optional. No physical units are required because the model is dimensionless, and all angles are in radians.",
            "solution": "The problem is deemed valid. It is scientifically grounded as a well-defined model problem in computational materials science, designed to test numerical methods for handling incommensurate structures. It is well-posed, with all necessary functions, parameters, and procedures explicitly defined. The problem statement is objective and free of ambiguities.\n\nThe task is to implement and compare three numerical estimators for the spin-spiral energy functional $E(\\mathbf{q})$. This functional quantifies the energy of a system with a spin-spiral magnetic ordering characterized by a wave vector $\\mathbf{q}$. The comparison will highlight the numerical bias introduced by standard discrete Brillouin zone sampling when the spin-spiral wave vector $\\mathbf{q}$ is incommensurate with the sampling grid, and demonstrate how an adaptive grid strategy can mitigate this bias.\n\nFirst, we define the fundamental physical and mathematical components of the model.\nThe system is a two-dimensional square lattice, whose Brillouin zone (BZ) is the square region $[-\\pi, \\pi) \\times [-\\pi, \\pi)$, with area $\\Omega_{\\text{BZ}} = (2\\pi)^2$.\nThe electronic band structure is described by a single-band tight-binding dispersion relation:\n$$\n\\varepsilon(\\mathbf{k}) = \\varepsilon(k_x, k_y) = -2t \\left[ \\cos(k_x) + \\cos(k_y) \\right]\n$$\nwhere $\\mathbf{k} = (k_x, k_y)$ is a wave vector in the BZ and the hopping parameter is set to $t=1$.\nThe interaction giving rise to the spin-spiral state is modeled by a surrogate coupling function, $S$, which depends on the energies of two states coupled by the vector $\\mathbf{q}$:\n$$\nS(x, y; \\alpha) = \\frac{1}{1 + \\alpha (y-x)^2}\n$$\nThe parameter $\\alpha$ controls the strength of the energy penalty for large differences between the coupled state energies, and is given as $\\alpha=0.5$.\nThe total spin-spiral energy $E(\\mathbf{q})$ is the average of this coupling function over all possible pairs of states $(\\mathbf{k}, \\mathbf{k}+\\mathbf{q})$ in the Brillouin zone:\n$$\nE(\\mathbf{q}) = \\frac{1}{\\Omega_{\\text{BZ}}} \\int_{\\text{BZ}} d^2k \\; S\\big(\\varepsilon(\\mathbf{k}), \\varepsilon(\\mathbf{k}+\\mathbf{q}); \\alpha\\big)\n$$\n\nNumerically, the continuous integral is replaced by a discrete sum over a uniform $N \\times N$ grid of $\\mathbf{k}$-points, analogous to a Monkhorst-Pack sampling scheme. The grid points are defined as:\n$$\nk_x(i) = -\\pi + \\left(i + \\frac{1}{2}\\right)\\Delta, \\quad k_y(j) = -\\pi + \\left(j + \\frac{1}{2}\\right)\\Delta\n$$\nfor integers $i, j \\in \\{0, 1, \\dots, N-1\\}$, with grid spacing $\\Delta = 2\\pi/N$. The integral is then approximated by a Riemann sum:\n$$\nE(\\mathbf{q}) \\approx \\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} S\\big(\\varepsilon(\\mathbf{k}_{ij}), \\varepsilon(\\mathbf{k}_{ij}+\\mathbf{q}); \\alpha\\big)\n$$\nwhere $\\mathbf{k}_{ij} = (k_x(i), k_y(j))$. A crucial step is handling the vector $\\mathbf{k}+\\mathbf{q}$, whose components may fall outside the primary BZ interval $[-\\pi, \\pi)$. We map them back into this interval using the periodic wrapping operator $\\mathcal{W}$, defined as $\\mathcal{W}(\\theta) = ((\\theta+\\pi) \\pmod{2\\pi}) - \\pi$.\n\nWe will now detail the three distinct numerical estimators for $E(\\mathbf{q})$.\n\n1.  **High-Resolution Reference, $E_{\\text{ref}}(\\mathbf{q})$**: This serves as the \"ground truth\" for our numerical experiment. It is computed by performing the discrete sum on a very dense grid with $N_{\\text{ref}} = 384$. For each grid point $\\mathbf{k}$, both $\\varepsilon(\\mathbf{k})$ and $\\varepsilon(\\mathcal{W}(\\mathbf{k}+\\mathbf{q}))$ are calculated directly from the analytical formula for $\\varepsilon$. The high density of points ensures a very accurate approximation of the true integral, minimizing discretization error.\n\n2.  **Non-Adaptive Estimator, $E_{\\text{na}}(\\mathbf{q}; N)$**: This method simulates a standard, non-adaptive first-principles calculation performed on a coarse $N \\times N$ grid.\n    - First, a table of energy values, $\\varepsilon(\\mathbf{k})$, is pre-computed and stored only for the points on the coarse $N \\times N$ grid.\n    - The summation proceeds over this coarse grid. For each coarse-grid point $\\mathbf{k}$, we require the energy $\\varepsilon(\\mathbf{k}+\\mathbf{q})$.\n    - When $\\mathbf{q}$ is incommensurate with the grid (i.e., $q_x/\\Delta$ or $q_y/\\Delta$ is not an integer), the point $\\mathbf{k}' = \\mathcal{W}(\\mathbf{k}+\\mathbf{q})$ will not coincide with any point in our pre-computed table.\n    - To obtain $\\varepsilon(\\mathbf{k}')$, we must interpolate from the surrounding four grid points in the table. The problem specifies periodic bilinear interpolation. Given a point $\\mathbf{k}'=(k'_x, k'_y)$ and the energy table on the $N \\times N$ grid with spacing $\\Delta$, we find the \"floor\" grid indices $(i_0, j_0)$ and normalized displacements $(t_x, t_y)$ such that $k'_x$ is between grid points $i_0$ and $(i_0+1)\\pmod N$, and similarly for $k'_y$. The interpolated energy is then:\n      $$\n      \\varepsilon(\\mathbf{k}') \\approx (1-t_x)(1-t_y)\\varepsilon_{i_0,j_0} + t_x(1-t_y)\\varepsilon_{i_0+1,j_0} + (1-t_x)t_y\\varepsilon_{i_0,j_0+1} + t_x t_y\\varepsilon_{i_0+1,j_0+1}\n      $$\n      (Indices are taken modulo $N$). This interpolation introduces an error that depends on the non-linearity of $\\varepsilon(\\mathbf{k})$ and the location of $\\mathbf{k}'$. $E_{\\text{na}}$ is the average of $S(\\varepsilon(\\mathbf{k}), \\varepsilon_{\\text{interp}}(\\mathcal{W}(\\mathbf{k}+\\mathbf{q})); \\alpha)$ over the coarse grid.\n\n3.  **Adaptive Estimator, $E_{\\text{ad}}(\\mathbf{q}; N)$**: This method aims to eliminate the interpolation error by selecting a new, finer grid that is commensurate with $\\mathbf{q}$.\n    - A search is performed to find the smallest integer grid size $M$, with $N \\le M \\le M_{\\max}$, such that the new grid spacing $\\Delta_M = 2\\pi/M$ makes $\\mathbf{q}$ a grid vector. This is achieved when $q_x/\\Delta_M$ and $q_y/\\Delta_M$ are both within a small tolerance $\\tau=10^{-12}$ of an integer. If no such $M \\le M_{\\max}=96$ is found, $M$ is set to $M_{\\max}$.\n    - The entire calculation is then performed on this new, adaptive $M \\times M$ grid. An energy table for $\\varepsilon(\\mathbf{k})$ is computed on this $M \\times M$ grid. The summation for $E_{\\text{ad}}$ is also carried out over this grid.\n    - For each point $\\mathbf{k}$ on the $M \\times M$ grid, the shifted point $\\mathbf{k}+\\mathbf{q}$ will now land on (or extremely close to) another grid point. Consequently, the bilinear interpolation for $\\varepsilon(\\mathcal{W}(\\mathbf{k}+\\mathbf{q}))$ becomes a simple, exact table lookup, thereby removing the source of bias present in the non-adaptive scheme.\n\nFinally, to quantify the improvement, we compute the relative errors of the two coarse-grid methods with respect to the high-resolution reference:\n$$\n\\delta_{\\text{na}} = \\frac{\\left|E_{\\text{na}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|, 10^{-12}\\right)}, \\quad \\delta_{\\text{ad}} = \\frac{\\left|E_{\\text{ad}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|, 10^{-12}\\right)}\n$$\nThe boolean flag $b_{\\text{imp}}$ is set to true if the adaptive method is more accurate, i.e., $\\delta_{\\text{ad}}  \\delta_{\\text{na}}$. The implementation will process the four specified test cases and report these three metrics for each.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem statement\nT_HOP = 1.0\nALPHA = 0.5\nN_REF = 384\nTAU = 1e-12\nM_MAX = 96\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n\n    def wrap(theta):\n        \"\"\"Applies the periodic wrapping operator W to map angles to [-pi, pi).\"\"\"\n        return (theta + np.pi) % (2 * np.pi) - np.pi\n\n    def epsilon(k, t):\n        \"\"\"Computes the tight-binding dispersion epsilon(k).\"\"\"\n        kx, ky = k[..., 0], k[..., 1]\n        return -2 * t * (np.cos(kx) + np.cos(ky))\n\n    def S_func(eps1, eps2, alpha):\n        \"\"\"Computes the surrogate coupling function S(eps1, eps2; alpha).\"\"\"\n        return 1.0 / (1.0 + alpha * (eps2 - eps1)**2)\n\n    def bilinear_interp(k_prime, eps_grid, N):\n        \"\"\"Performs periodic bilinear interpolation of epsilon on a grid.\"\"\"\n        delta = 2.0 * np.pi / N\n        kx_p_wrapped, ky_p_wrapped = k_prime\n\n        # Calculate floating-point indices and interpolation weights\n        ix_float = (kx_p_wrapped + np.pi) / delta - 0.5\n        iy_float = (ky_p_wrapped + np.pi) / delta - 0.5\n\n        ix0 = int(np.floor(ix_float))\n        iy0 = int(np.floor(iy_float))\n\n        tx = ix_float - ix0\n        ty = iy_float - iy0\n\n        # Apply periodic boundary conditions on indices\n        ix0 %= N\n        iy0 %= N\n        ix1 = (ix0 + 1) % N\n        iy1 = (iy0 + 1) % N\n\n        # Get values at the four surrounding grid points\n        v00 = eps_grid[ix0, iy0]\n        v10 = eps_grid[ix1, iy0]\n        v01 = eps_grid[ix0, iy1]\n        v11 = eps_grid[ix1, iy1]\n\n        # Perform interpolation\n        c0 = v00 * (1 - tx) + v10 * tx\n        c1 = v01 * (1 - tx) + v11 * tx\n\n        return c0 * (1 - ty) + c1 * ty\n\n    def find_M(q, N, M_max, tau):\n        \"\"\"Finds the smallest commensurate grid size M = N.\"\"\"\n        q_frac = q / (2 * np.pi)\n        for M_cand in range(N, M_max + 1):\n            scaled_q = M_cand * q_frac\n            residuals = np.abs(scaled_q - np.round(scaled_q))\n            if np.all(residuals  tau):\n                return M_cand\n        return M_max\n\n    def calc_E_ref(q, N, t, alpha):\n        \"\"\"Computes the high-resolution reference energy E_ref.\"\"\"\n        delta = 2.0 * np.pi / N\n        k_1d = -np.pi + (np.arange(N) + 0.5) * delta\n        kx_grid, ky_grid = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_grid = np.stack((kx_grid, ky_grid), axis=-1)\n\n        eps_k = epsilon(k_grid, t)\n        \n        k_plus_q = k_grid + q\n        k_plus_q_wrapped = wrap(k_plus_q)\n        \n        eps_k_plus_q = epsilon(k_plus_q_wrapped, t)\n        \n        s_vals = S_func(eps_k, eps_k_plus_q, alpha)\n        \n        return np.mean(s_vals)\n\n    def calc_E_interp(q, N, t, alpha):\n        \"\"\"Computes energy using interpolation, base for E_na and E_ad.\"\"\"\n        delta = 2.0 * np.pi / N\n        k_1d = -np.pi + (np.arange(N) + 0.5) * delta\n        kx_grid, ky_grid = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_grid = np.stack((kx_grid, ky_grid), axis=-1)\n\n        eps_table = epsilon(k_grid, t)\n        \n        total_s = 0.0\n        for i in range(N):\n            for j in range(N):\n                k = k_grid[i, j, :]\n                eps_k = eps_table[i, j]\n                \n                k_plus_q = k + q\n                k_plus_q_wrapped = wrap(k_plus_q)\n                \n                eps_k_plus_q = bilinear_interp(k_plus_q_wrapped, eps_table, N)\n                total_s += S_func(eps_k, eps_k_plus_q, alpha)\n        \n        return total_s / (N * N)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # N, q\n        (12, np.array([np.pi/3, 0.0])),         # Case A\n        (12, np.array([np.pi/5, 0.0])),         # Case B\n        (12, np.array([np.pi/5, 2*np.pi/5])),  # Case C\n        (12, np.array([0.0, 0.0])),             # Case D\n    ]\n\n    results = []\n    for N, q in test_cases:\n        # 1. Compute reference energy\n        E_ref = calc_E_ref(q, N_REF, T_HOP, ALPHA)\n        \n        # 2. Compute non-adaptive energy\n        E_na = calc_E_interp(q, N, T_HOP, ALPHA)\n\n        # 3. Compute adaptive energy\n        M = find_M(q, N, M_MAX, TAU)\n        E_ad = calc_E_interp(q, M, T_HOP, ALPHA)\n        \n        # 4. Compute error metrics\n        denom = max(abs(E_ref), 1e-12)\n        delta_na = abs(E_na - E_ref) / denom\n        delta_ad = abs(E_ad - E_ref) / denom\n        b_imp = delta_ad  delta_na\n        \n        results.append([delta_na, delta_ad, b_imp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond analyzing the ground state, it is often necessary to investigate specific non-collinear configurations that may be metastable or part of an energy barrier path. This practice introduces the powerful method of constrained calculations, which allows researchers to force a magnetic system into a predefined target order. You will implement a classical analog of a constrained non-collinear calculation, using a primal-dual algorithm with Lagrange multipliers to enforce the classic $120^\\circ$ spin order on a frustrated triangular lattice, offering insight into the core mechanics of this advanced computational technique .",
            "id": "3468712",
            "problem": "Implement a minimal classical constrained non-collinear spin calculation on a triangular cluster with three sites that enforces a target $120^\\circ$ spin order using Lagrange multipliers. The system consists of $N=3$ classical spins $\\{\\mathbf{m}_i\\}_{i=1}^N$, each a three-dimensional unit vector representing the local magnetization direction at site $i$. The spins reside on a triangle, so each site interacts with the other two as nearest neighbors. The physical model is the classical isotropic Heisenberg model with antiferromagnetic exchange coupling.\n\nStart from the following foundational definitions:\n\n- The classical Heisenberg energy (for general exchange $J$) on this triangle is\n$$\nE_{\\text{ex}} = \\frac{J}{2}\\sum_{i=1}^{3}\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_i\\cdot\\mathbf{m}_j,\n$$\nwhere $J0$ corresponds to antiferromagnetic coupling and the factor $\\tfrac{1}{2}$ avoids double-counting pairs.\n\n- The exchange effective field at site $i$ is defined by the negative gradient of the energy with respect to $\\mathbf{m}_i$,\n$$\n\\mathbf{B}_i^{\\text{ex}} = -\\frac{\\partial E_{\\text{ex}}}{\\partial \\mathbf{m}_i} = -J\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_j.\n$$\n\nTo enforce a target non-collinear order, introduce Lagrange multipliers $\\boldsymbol{\\lambda}_i$ that couple linearly to the deviation from a prescribed target direction $\\mathbf{m}_i^{(0)}$. The constrained energy contribution is\n$$\nE_{\\lambda} = \\sum_{i=1}^{3}\\boldsymbol{\\lambda}_i\\cdot\\big(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\big),\n$$\nwhich yields a constraining field contribution\n$$\n\\mathbf{B}_i^{\\text{constr}} = -\\frac{\\partial E_{\\lambda}}{\\partial \\mathbf{m}_i} = -\\boldsymbol{\\lambda}_i.\n$$\nThe total effective field is therefore\n$$\n\\mathbf{B}_i^{\\text{eff}} = \\mathbf{B}_i^{\\text{ex}} + \\mathbf{B}_i^{\\text{constr}} = -J\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_j - \\boldsymbol{\\lambda}_i.\n$$\n\nThe target $120^\\circ$ spin order on the triangle is specified in the plane by the three unit vectors\n$$\n\\mathbf{m}_1^{(0)}=\\big(\\cos 0,\\sin 0,0\\big),\\quad\n\\mathbf{m}_2^{(0)}=\\big(\\cos (2\\pi/3),\\sin (2\\pi/3),0\\big),\\quad\n\\mathbf{m}_3^{(0)}=\\big(\\cos (4\\pi/3),\\sin (4\\pi/3),0\\big),\n$$\nwith all angles expressed in radians. The initial condition for the spins is a uniform in-plane rotation by angle $\\phi_0$ of the entire target pattern, i.e.,\n$$\n\\mathbf{m}_i^{(0,\\text{init})} = R_z(\\phi_0)\\,\\mathbf{m}_i^{(0)},\n$$\nwhere $R_z(\\phi)$ is the rotation by angle $\\phi$ around the $z$-axis. The initial Lagrange multipliers are $\\boldsymbol{\\lambda}_i=\\mathbf{0}$.\n\nImplement the following iterative primal-dual scheme for a fixed number of iterations $T$:\n\n1. For each site $i$, compute the exchange field $\\mathbf{B}_i^{\\text{ex}}$ and the effective field $\\mathbf{B}_i^{\\text{eff}}$ using the definitions above.\n\n2. Update the spin by damped alignment toward the effective field direction:\n$$\n\\tilde{\\mathbf{m}}_i = \n\\begin{cases}\n\\frac{\\mathbf{B}_i^{\\text{eff}}}{\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert},  \\text{if }\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert  \\varepsilon,\\\\[6pt]\n\\mathbf{m}_i,  \\text{otherwise},\n\\end{cases}\n\\quad\n\\mathbf{m}_i \\leftarrow \\operatorname{normalize}\\Big((1-\\beta)\\,\\mathbf{m}_i + \\beta\\,\\tilde{\\mathbf{m}}_i\\Big),\n$$\nwhere $\\beta\\in(0,1]$ is a mixing parameter, $\\varepsilon0$ is a small threshold to avoid division by zero, and $\\operatorname{normalize}(\\mathbf{v})=\\mathbf{v}/\\lVert\\mathbf{v}\\rVert$.\n\n3. Perform a dual ascent step on the Lagrange multipliers to enforce the constraint:\n$$\n\\boldsymbol{\\lambda}_i \\leftarrow \\boldsymbol{\\lambda}_i + \\gamma\\left(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\right),\n$$\nwhere $\\gamma0$ is the dual step size.\n\nAfter completing $T$ iterations, evaluate the residual torques at each site,\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{m}_i \\times \\mathbf{B}_i^{\\text{eff}},\n$$\nand report the maximum norm across sites,\n$$\n\\tau_{\\max} = \\max_{i\\in\\{1,2,3\\}}\\lVert \\boldsymbol{\\tau}_i\\rVert.\n$$\n\nAngle units: all angles, including the initial rotation $\\phi_0$, must be interpreted in radians. There are no physical units for the spins or the torque magnitudes in this non-dimensionalized setup; report raw floating-point values.\n\nYour task is to write a complete, runnable program that implements the above scheme and computes $\\tau_{\\max}$ for each of the following test cases (each test is an independent run starting from its own initial condition):\n\n- Test $1$: $J=1.0$, $\\beta=0.55$, $\\gamma=0.8$, $T=800$, $\\phi_0=\\pi/12$.\n- Test $2$: $J=0.0$, $\\beta=0.55$, $\\gamma=0.8$, $T=400$, $\\phi_0=\\pi/6$.\n- Test $3$: $J=10.0$, $\\beta=0.35$, $\\gamma=0.5$, $T=1200$, $\\phi_0=\\pi/18$.\n\nImplementation details:\n\n- Use the target directions $\\mathbf{m}_i^{(0)}$ as defined above.\n- Initialize $\\mathbf{m}_i$ by rotating $\\mathbf{m}_i^{(0)}$ by $\\phi_0$ around the $z$-axis for each test case.\n- Initialize $\\boldsymbol{\\lambda}_i=\\mathbf{0}$ for all $i$.\n- Use a small threshold $\\varepsilon=10^{-12}$ in the alignment step.\n- Keep all spins normalized to unit length at each iteration.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests above. Each number must be formatted to exactly six digits after the decimal point. For example, an output with three results should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3],\n$$\nwhere each $\\text{result}_k$ is a decimal string with exactly six digits after the decimal point. The outputs must be the values of $\\tau_{\\max}$ for the three tests.",
            "solution": "The user-provided problem has been analyzed and is deemed valid according to the specified criteria. It is scientifically sound, well-posed, objective, and contains all necessary information for a deterministic solution.\n\nThe problem requires the implementation of a primal-dual iterative algorithm to find the constrained ground state of a classical Heisenberg model on a three-site triangular cluster. The objective is to enforce a specific $120^\\circ$ non-collinear spin configuration using the method of Lagrange multipliers. The solution involves iteratively updating the spin vectors (primal variables) and the Lagrange multipliers (dual variables) until the system approaches a static equilibrium.\n\nThe total energy of the system, including the constraints, is described by a Lagrangian functional $L$:\n$$\nL(\\{\\mathbf{m}_i\\}, \\{\\boldsymbol{\\lambda}_i\\}) = E_{\\text{ex}}(\\{\\mathbf{m}_i\\}) + E_{\\lambda}(\\{\\mathbf{m}_i\\}, \\{\\boldsymbol{\\lambda}_i\\}) = \\frac{J}{2}\\sum_{i=1}^{3}\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_i\\cdot\\mathbf{m}_j + \\sum_{i=1}^{3}\\boldsymbol{\\lambda}_i\\cdot\\big(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\big)\n$$\nHere, $\\{\\mathbf{m}_i\\}_{i=1}^3$ are the classical spin vectors of unit length, $J$ is the exchange coupling constant, $\\{\\mathbf{m}_i^{(0)}\\}_{i=1}^3$ are the target spin directions, and $\\{\\boldsymbol{\\lambda}_i\\}_{i=1}^3$ are the Lagrange multipliers. The solution corresponds to a saddle point of this Lagrangian, where it is minimized with respect to the primal variables $\\mathbf{m}_i$ and maximized with respect to the dual variables $\\boldsymbol{\\lambda}_i$.\n\nThe iterative algorithm described is a standard approach for solving such saddle-point problems. It consists of two main steps performed in each iteration: a primal update (gradient descent on spins) and a dual update (gradient ascent on multipliers).\n\n**1. Primal Step: Spin Update**\n\nThe spins are updated to lower the system's energy under the influence of an effective magnetic field. This effective field, $\\mathbf{B}_i^{\\text{eff}}$, is the negative gradient of the Lagrangian with respect to the spin vector $\\mathbf{m}_i$:\n$$\n\\mathbf{B}_i^{\\text{eff}} = -\\frac{\\partial L}{\\partial \\mathbf{m}_i} = -\\frac{\\partial E_{\\text{ex}}}{\\partial \\mathbf{m}_i} - \\frac{\\partial E_{\\lambda}}{\\partial \\mathbf{m}_i} = \\mathbf{B}_i^{\\text{ex}} + \\mathbf{B}_i^{\\text{constr}}\n$$\nwhere $\\mathbf{B}_i^{\\text{ex}} = -J\\sum_{j \\neq i} \\mathbf{m}_j$ is the exchange field from neighboring spins and $\\mathbf{B}_i^{\\text{constr}} = -\\boldsymbol{\\lambda}_i$ is the constraining field from the Lagrange multiplier.\n\nThe spin update is performed via a damped alignment towards the direction of this effective field. First, the target direction is determined:\n$$\n\\tilde{\\mathbf{m}}_i = \\frac{\\mathbf{B}_i^{\\text{eff}}}{\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert}\n$$\nA small threshold $\\varepsilon$ is used to prevent division by zero if $\\mathbf{B}_i^{\\text{eff}}$ is close to zero. Then, the spin is updated using a mixing scheme:\n$$\n\\mathbf{m}_i \\leftarrow \\operatorname{normalize}\\Big((1-\\beta)\\,\\mathbf{m}_i + \\beta\\,\\tilde{\\mathbf{m}}_i\\Big)\n$$\nThe parameter $\\beta \\in (0,1]$ is a mixing factor that controls the step size of the update, ensuring stability. The `normalize` operation is essential to enforce the unit-length constraint on the spin vectors, $\\lVert\\mathbf{m}_i\\rVert=1$. This step corresponds to a gradient descent on the manifold of unit vectors.\n\n**2. Dual Step: Lagrange Multiplier Update**\n\nThe Lagrange multipliers are updated to enforce the constraints $\\mathbf{m}_i = \\mathbf{m}_i^{(0)}$. This is achieved through a gradient ascent step on the dual variables:\n$$\n\\boldsymbol{\\lambda}_i \\leftarrow \\boldsymbol{\\lambda}_i + \\gamma\\left(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\right)\n$$\nHere, $\\gamma  0$ is a step size parameter. The update pushes $\\boldsymbol{\\lambda}_i$ in the direction of the constraint violation, $(\\mathbf{m}_i - \\mathbf{m}_i^{(0)})$. In the next iteration, this change in $\\boldsymbol{\\lambda}_i$ modifies the constraining field $\\mathbf{B}_i^{\\text{constr}}$, applying a corrective \"force\" that drives the spin $\\mathbf{m}_i$ closer to its target $\\mathbf{m}_i^{(0)}$.\n\n**3. Convergence and Final Output**\n\nThe iterative process is repeated for a fixed number of steps, $T$. A static equilibrium is characterized by a zero torque on each spin, $\\boldsymbol{\\tau}_i = \\mathbf{m}_i \\times \\mathbf{B}_i^{\\text{eff}} = \\mathbf{0}$, which occurs when each spin is parallel to its effective field. The quantity to be reported, $\\tau_{\\max} = \\max_i \\lVert\\boldsymbol{\\tau}_i\\rVert$, serves as a metric for how close the system is to this equilibrium state after $T$ iterations.\n\nThe implementation will proceed by initializing the spins based on the given rotation angle $\\phi_0$ and the Lagrange multipliers to zero. Then, the primal and dual updates are executed within a loop for $T$ steps. Finally, the maximum residual torque norm is calculated and reported. Vector operations will be handled using the `numpy` library.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a primal-dual scheme for a constrained classical Heisenberg model\n    on a 3-site triangular cluster and computes the maximum residual torque for\n    three different test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (J, beta, gamma, T, phi0)\n    test_cases = [\n        (1.0, 0.55, 0.8, 800, np.pi / 12.0),\n        (0.0, 0.55, 0.8, 400, np.pi / 6.0),\n        (10.0, 0.35, 0.5, 1200, np.pi / 18.0),\n    ]\n\n    # Small threshold for numerical stability\n    epsilon = 1e-12\n    \n    results = []\n\n    # Define the target 120-degree spin order in the xy-plane.\n    m_target = np.array([\n        [np.cos(0.0), np.sin(0.0), 0.0],\n        [np.cos(2.0 * np.pi / 3.0), np.sin(2.0 * np.pi / 3.0), 0.0],\n        [np.cos(4.0 * np.pi / 3.0), np.sin(4.0 * np.pi / 3.0), 0.0]\n    ])\n\n    for J, beta, gamma, T, phi0 in test_cases:\n        # ----- Initialization for the current test case -----\n        \n        # Initialize spins m_i by rotating the target pattern by phi0 around the z-axis.\n        c, s = np.cos(phi0), np.sin(phi0)\n        Rz = np.array([[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]])\n        # m is a (3, 3) array where m[i] is the spin vector for site i.\n        m = (Rz @ m_target.T).T\n        \n        # Initialize Lagrange multipliers lambda_i to zero.\n        # lam is a (3, 3) array where lam[i] is the lambda vector for site i.\n        lam = np.zeros_like(m)\n\n        # ----- Iterative Primal-Dual Scheme -----\n        for _ in range(T):\n            m_old = m.copy()\n            m_new = np.zeros_like(m)\n\n            # Primal step: Update spins m_i for all sites i=0,1,2.\n            # This is done using the spin configuration from the previous step (m_old).\n            for i in range(3):\n                # Sum of neighboring spins for site i\n                m_neighbors_sum = np.sum(m_old, axis=0) - m_old[i]\n                \n                # Exchange field\n                B_ex_i = -J * m_neighbors_sum\n                \n                # Effective field (includes constraining field -lambda_i)\n                B_eff_i = B_ex_i - lam[i]\n                \n                norm_B_eff = np.linalg.norm(B_eff_i)\n                \n                # Determine target direction for alignment\n                if norm_B_eff  epsilon:\n                    m_tilde_i = B_eff_i / norm_B_eff\n                else:\n                    m_tilde_i = m_old[i]\n                \n                # Damped update with mixing parameter beta\n                m_mixed = (1.0 - beta) * m_old[i] + beta * m_tilde_i\n                \n                # Normalize to maintain unit spin length\n                m_new[i] = m_mixed / np.linalg.norm(m_mixed)\n            \n            # Atomically update the spins for the next step\n            m = m_new\n\n            # Dual step: Update Lagrange multipliers lambda_i.\n            # This uses the newly computed spins 'm' to calculate the constraint violation.\n            lam += gamma * (m - m_target)\n\n        # ----- Final Calculation: Residual Torques -----\n        \n        tau_norms = []\n        for i in range(3):\n            # Recalculate the final effective field for each site\n            m_neighbors_sum = np.sum(m, axis=0) - m[i]\n            B_ex_i = -J * m_neighbors_sum\n            B_eff_i = B_ex_i - lam[i]\n            \n            # Calculate the torque tau_i = m_i x B_eff_i\n            tau_i = np.cross(m[i], B_eff_i)\n            \n            # Store the norm of the torque vector\n            tau_norms.append(np.linalg.norm(tau_i))\n            \n        # Find the maximum torque norm across all three sites\n        tau_max = np.max(tau_norms)\n        results.append(tau_max)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}