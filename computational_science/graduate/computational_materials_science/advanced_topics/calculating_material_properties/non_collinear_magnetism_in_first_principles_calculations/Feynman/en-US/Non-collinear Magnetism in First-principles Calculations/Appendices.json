{
    "hands_on_practices": [
        {
            "introduction": "The Heisenberg model, with its interaction energy proportional to $\\mathbf{S}_i \\cdot \\mathbf{S}_j$, provides a foundational picture of magnetism, but many real materials exhibit more complex behavior. This exercise  guides you through analyzing the energy landscape between two magnetic moments by including a higher-order biquadratic exchange term, which is often crucial in itinerant magnets. By fitting first-principles energy data to a model including a $B \\cos^2\\theta$ term, you will learn to quantify the degree of non-Heisenberg character and connect it to the material's underlying electronic nature.",
            "id": "3468670",
            "problem": "You are given angle-resolved total energies for isolated two-atom magnetic dimers computed with a non-collinear first-principles method such as Density Functional Theory (DFT). For a dimer with spin directions forming a relative angle $\\theta$, assume the magnetic interaction energy (after subtracting a constant reference so that $E(90^{\\circ})=0$) is described by the lowest two angular harmonics\n$$\nE(\\theta) = J \\cos\\theta + B \\cos^2\\theta,\n$$\nwhere $J$ and $B$ are effective bilinear and biquadratic exchange coefficients that incorporate the fixed spin magnitudes into their definitions. This form goes beyond the classical Heisenberg model by including a biquadratic term that can arise from itinerant electron effects.\n\nTask:\n1. Starting from the concept of an isotropic bilinear exchange interaction between two spins $\\mathbf{S}_1$ and $\\mathbf{S}_2$ and the scalar identity $\\mathbf{S}_1 \\cdot \\mathbf{S}_2 = |\\mathbf{S}_1||\\mathbf{S}_2|\\cos\\theta$, and allowing the next-order scalar invariant $(\\mathbf{S}_1 \\cdot \\mathbf{S}_2)^2$, argue that for fixed $|\\mathbf{S}_1|$ and $|\\mathbf{S}_2|$, the energy can be represented as a linear combination of $\\cos\\theta$ and $\\cos^2\\theta$ up to an additive constant which you are told has already been removed by setting $E(90^\\circ)=0$. You must then fit $J$ and $B$ by linear least squares to minimize the sum of squared residuals between the model and the provided total energies.\n\n2. For each dataset below, compute the ratio\n$$\nr = \\frac{|B|}{|J| + \\delta},\n$$\nwith $\\delta = 10^{-9}$ in meV to avoid division by zero, and classify the itinerant enhancement as an integer code $c$ using the rule:\n- $c=0$ if $r < 0.05$ (Heisenberg-dominated, localized-like),\n- $c=1$ if $0.05 \\le r < 0.2$ (intermediate),\n- $c=2$ if $r \\ge 0.2$ (strongly itinerant-influenced, non-Heisenberg).\n\n3. All angles are given in degrees and all energies are given in millielectronvolts (meV). When evaluating trigonometric functions, use radians internally. Your program must solve a linear least-squares problem for $J$ and $B$ with the design matrix columns $x_1(\\theta)=\\cos\\theta$ and $x_2(\\theta)=\\cos^2\\theta$. Express $J$ and $B$ in meV and $r$ as a dimensionless float. Round $J$, $B$, and $r$ to three decimals in the final output. The classification $c$ must be an integer.\n\nInput data (embedded in your program as constants):\n- Case A (happy path, Heisenberg-dominated): angles in degrees $[\\,0,\\,60,\\,90,\\,120,\\,180\\,]$, energies in meV $[\\, -30.0,\\,-15.0,\\,0.0,\\,15.0,\\,30.0 \\,]$.\n- Case B (mixed bilinear-biquadratic, positive $B$): angles in degrees $[\\,0,\\,45,\\,90,\\,135,\\,180\\,]$, energies in meV $[\\, -12.0,\\,-10.14213562,\\,0.0,\\,18.14213562,\\,28.0 \\,]$.\n- Case C (edge case, purely biquadratic): angles in degrees $[\\,0,\\,60,\\,90,\\,120,\\,180\\,]$, energies in meV $[\\, 15.0,\\,3.75,\\,0.0,\\,3.75,\\,15.0 \\,]$.\n- Case D (mixed signs, negative $B$): angles in degrees $[\\,0,\\,30,\\,90,\\,150,\\,180\\,]$, energies in meV $[\\, 20.0,\\,17.9006350946,\\,0.0,\\,-25.4006350946,\\,-30.0 \\,]$.\n\nRequirements and output:\n- Implement a linear least-squares fit for each case to obtain $J$ and $B$ according to the model $E(\\theta)=J\\cos\\theta + B\\cos^2\\theta$.\n- Compute $r$ with $\\delta = 10^{-9}$ meV.\n- Determine the class code $c$ from $r$ using the rule above.\n- Your program should produce a single line of output containing the results as a comma-separated Python-style list of four lists, one per case, with each inner list in the form $[J,B,r,c]$, where $J$ and $B$ are in meV rounded to three decimals, $r$ is rounded to three decimals, and $c$ is an integer. For example, the formatting should look like $[[J_A,B_A,r_A,c_A],[J_B,B_B,r_B,c_B],[J_C,B_C,r_C,c_C],[J_D,B_D,r_D,c_D]]$ with no extra spaces.\n- Angle unit must be degrees as provided, and radians must be used in trigonometric evaluation.",
            "solution": "The problem requires fitting a phenomenological model of magnetic exchange energy to provided data and classifying the interaction based on the fitted parameters. The solution proceeds in two main steps: first, establishing the theoretical validity of the energy model, and second, applying a linear least-squares algorithm to determine the model parameters for each dataset.\n\n**1. Theoretical Foundation of the Energy Model**\n\nThe interaction energy between two localized magnetic moments, represented by spin vectors $\\mathbf{S}_1$ and $\\mathbf{S}_2$, must be a scalar quantity that is invariant under global rotations of the coordinate system. Such a scalar can only depend on the relative orientation of the two spins. The most general form for this energy can be expressed as a series of scalar invariants constructed from $\\mathbf{S}_1$ and $\\mathbf{S}_2$. The simplest such invariant is the scalar product $\\mathbf{S}_1 \\cdot \\mathbf{S}_2$. Higher-order invariants can be formed, such as $(\\mathbf{S}_1 \\cdot \\mathbf{S}_2)^2$, $(\\mathbf{S}_1 \\cdot \\mathbf{S}_2)^3$, and so on. A general expansion of the exchange energy $E_{ex}$ is therefore:\n$$\nE_{ex} = C_0 - C_1 (\\mathbf{S}_1 \\cdot \\mathbf{S}_2) - C_2 (\\mathbf{S}_1 \\cdot \\mathbf{S}_2)^2 - \\dots\n$$\nwhere $C_k$ are coupling constants. The first term, linear in the dot product, corresponds to the Heisenberg exchange interaction. The second term is the biquadratic exchange interaction. For many systems, truncating this series at the second order provides a sufficiently accurate description. Using the geometric definition of the dot product, $\\mathbf{S}_1 \\cdot \\mathbf{S}_2 = |\\mathbf{S}_1||\\mathbf{S}_2|\\cos\\theta$, where $\\theta$ is the angle between the two spin vectors, the truncated energy expression becomes:\n$$\nE_{ex}(\\theta) = C_0 - C_1 |\\mathbf{S}_1||\\mathbf{S}_2|\\cos\\theta - C_2 (|\\mathbf{S}_1||\\mathbf{S}_2|)^2\\cos^2\\theta\n$$\nIn the context of this problem, the spin magnitudes $|\\mathbf{S}_1|$ and $|\\mathbf{S}_2|$ are considered fixed. We can therefore absorb them into the coupling coefficients by defining effective exchange parameters:\n$$\nJ = -C_1 |\\mathbf{S}_1||\\mathbf{S}_2|\n$$\n$$\nB = -C_2 (|\\mathbf{S}_1||\\mathbf{S}_2|)^2\n$$\nThis leads to the model form $E(\\theta) = C_0 + J \\cos\\theta + B \\cos^2\\theta$. The problem specifies that the energy is referenced such that $E(90^{\\circ})=0$. Applying this condition:\n$$\nE(90^{\\circ}) = C_0 + J \\cos(90^{\\circ}) + B \\cos^2(90^{\\circ}) = C_0 + J(0) + B(0)^2 = C_0\n$$\nThus, the condition $E(90^{\\circ})=0$ implies $C_0=0$. The final, justified model for the energy is:\n$$\nE(\\theta) = J \\cos\\theta + B \\cos^2\\theta\n$$\n\n**2. Parameter Fitting via Linear Least Squares**\n\nThe task is to determine the optimal values of $J$ and $B$ that best fit the provided datasets $(\\theta_i, E_i)$. This is a linear regression problem. For a set of $N$ data points, we seek to minimize the sum of squared residuals, $S$:\n$$\nS(J, B) = \\sum_{i=1}^{N} [E_i - (J \\cos\\theta_i + B \\cos^2\\theta_i)]^2\n$$\nThis problem can be cast in matrix form. Let the parameter vector be $\\mathbf{p} = \\begin{pmatrix} J \\\\ B \\end{pmatrix}$, the vector of observed energies be $\\mathbf{y} = [E_1, E_2, \\dots, E_N]^T$, and the design matrix $\\mathbf{X}$ be:\n$$\n\\mathbf{X} = \\begin{pmatrix} \\cos\\theta_1 & \\cos^2\\theta_1 \\\\ \\cos\\theta_2 & \\cos^2\\theta_2 \\\\ \\vdots & \\vdots \\\\ \\cos\\theta_N & \\cos^2\\theta_N \\end{pmatrix}\n$$\nThe model is then compactly written as $\\mathbf{y} \\approx \\mathbf{X} \\mathbf{p}$. The least-squares solution for $\\mathbf{p}$ is the vector that solves the normal equations:\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\mathbf{p} = \\mathbf{X}^T \\mathbf{y}\n$$\nThe solution is formally given by $\\mathbf{p} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$. This computation is performed numerically for each case. The angles $\\theta_i$ are provided in degrees and must be converted to radians for evaluation of trigonometric functions.\n\nOnce $J$ and $B$ are determined, the ratio $r$ is computed as:\n$$\nr = \\frac{|B|}{|J| + \\delta}\n$$\nwith $\\delta = 10^{-9}$ meV. The classification code $c$ is then assigned based on the value of $r$:\n- $c=0$ if $r < 0.05$\n- $c=1$ if $0.05 \\le r < 0.2$\n- $c=2$ if $r \\ge 0.2$\n\nThe following procedure is implemented in the provided program for each case:\n1. The input angles in degrees are converted to radians.\n2. The $N \\times 2$ design matrix $\\mathbf{X}$ and $N \\times 1$ energy vector $\\mathbf{y}$ are constructed.\n3. The linear least-squares problem $\\mathbf{Xp}=\\mathbf{y}$ is solved for $\\mathbf{p} = [J, B]^T$ using a standard numerical library function, `numpy.linalg.lstsq`.\n4. The ratio $r$ and classification code $c$ are calculated using the fitted $J$ and $B$ values.\n5. The results $[J, B, r, c]$ are collected, with numerical values for $J$, $B$, and $r$ rounded to three decimal places as required for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for J, B, r, and c for four cases of magnetic dimer energies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"angles_deg\": np.array([0.0, 60.0, 90.0, 120.0, 180.0]),\n            \"energies_meV\": np.array([-30.0, -15.0, 0.0, 15.0, 30.0]),\n        },\n        {\n            \"id\": \"B\",\n            \"angles_deg\": np.array([0.0, 45.0, 90.0, 135.0, 180.0]),\n            \"energies_meV\": np.array([-12.0, -10.14213562, 0.0, 18.14213562, 28.0]),\n        },\n        {\n            \"id\": \"C\",\n            \"angles_deg\": np.array([0.0, 60.0, 90.0, 120.0, 180.0]),\n            \"energies_meV\": np.array([15.0, 3.75, 0.0, 3.75, 15.0]),\n        },\n        {\n            \"id\": \"D\",\n            \"angles_deg\": np.array([0.0, 30.0, 90.0, 150.0, 180.0]),\n            \"energies_meV\": np.array([20.0, 17.9006350946, 0.0, -25.4006350946, -30.0]),\n        }\n    ]\n\n    all_results = []\n    delta = 1e-9\n\n    for case in test_cases:\n        # 1. Convert angles to radians\n        angles_rad = np.deg2rad(case[\"angles_deg\"])\n        energies = case[\"energies_meV\"]\n\n        # 2. Construct the design matrix X and energy vector y\n        cos_theta = np.cos(angles_rad)\n        cos2_theta = cos_theta**2\n        X = np.c_[cos_theta, cos2_theta]\n        y = energies\n\n        # 3. Solve the linear least-squares problem for p = [J, B]\n        #    We use rcond=None to use the machine-precision-dependent default.\n        p, residuals, rank, s = np.linalg.lstsq(X, y, rcond=None)\n        J, B = p\n\n        # 4. Compute r and c\n        r = np.abs(B) / (np.abs(J) + delta)\n\n        if r < 0.05:\n            c = 0\n        elif 0.05 <= r < 0.2:\n            c = 1\n        else: # r >= 0.2\n            c = 2\n            \n        # 5. Store the results for this case\n        all_results.append([J, B, r, c])\n\n    # Final print statement in the exact required format.\n    # The format string {val:.3f} rounds the float to three decimal places.\n    output_parts = []\n    for res in all_results:\n        j_val, b_val, r_val, c_val = res\n        part = f\"[{j_val:.3f},{b_val:.3f},{r_val:.3f},{c_val}]\"\n        output_parts.append(part)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Calculating the energy of a spin spiral, $E(\\mathbf{q})$, presents a subtle but critical numerical challenge related to Brillouin zone integration. This exercise  uses a simplified model to demonstrate how a standard, fixed $\\mathbf{k}$-point grid can introduce significant errors when the spiral wavevector $\\mathbf{q}$ is incommensurate with the grid. By comparing a naive interpolation scheme with an adaptive grid approach, you will develop an intuition for achieving accurate results for incommensurate magnetic structures, a common task in studying non-collinear magnetism.",
            "id": "3468708",
            "problem": "You are tasked with quantifying how non-commensurate $\\mathbf{k}$-point grids bias the computed spin-spiral energy $E(\\mathbf{q})$ in a simplified first-principles inspired model of non-collinear magnetism, and to implement an adaptive $\\mathbf{k}+\\mathbf{q}$ sampling strategy that ameliorates this bias. The setting is a two-dimensional square lattice with a single-band tight-binding dispersion and a surrogate for the generalized Bloch theorem coupling.\n\nBase assumptions and definitions:\n- Consider a two-dimensional Brillouin zone that is the Cartesian product $[-\\pi,\\pi)\\times[-\\pi,\\pi)$ in radians. All angles must be in radians.\n- Use the single-band tight-binding dispersion on a square lattice\n$$\n\\varepsilon(\\mathbf{k}) \\equiv \\varepsilon(k_x,k_y) = -2t\\left[\\cos(k_x) + \\cos(k_y)\\right],\n$$\nwith $t=1$ (dimensionless).\n- In a spin-spiral described by the Generalized Bloch Theorem (GBT), a wave vector $\\mathbf{q}$ couples $\\mathbf{k}$-states to $\\mathbf{k}+\\mathbf{q}$. As a smooth surrogate for second-order perturbation energy in the presence of weak exchange, define\n$$\nS(x,y;\\alpha) = \\frac{1}{1 + \\alpha\\,(y-x)^2},\n$$\nwith $\\alpha=0.5$ (dimensionless). The spin-spiral energy functional is defined as the Brillouin-zone average\n$$\nE(\\mathbf{q}) = \\frac{1}{\\Omega_{\\text{BZ}}}\\int_{\\text{BZ}} d^2k \\; S\\big(\\varepsilon(\\mathbf{k}),\\varepsilon(\\mathbf{k}+\\mathbf{q});\\alpha\\big),\n$$\nwhere $\\Omega_{\\text{BZ}}=(2\\pi)^2$.\n\nDiscrete sampling and numerical tasks:\n- Replace the Brillouin-zone integral by a uniform Monkhorst-Pack like sum on an $N\\times N$ grid with Cartesian nodes\n$$\nk_x(i) = -\\pi + \\left(i+\\tfrac{1}{2}\\right)\\Delta, \\quad k_y(j) = -\\pi + \\left(j+\\tfrac{1}{2}\\right)\\Delta,\\quad \\Delta=\\frac{2\\pi}{N},\n$$\nfor integers $i,j\\in\\{0,1,\\dots,N-1\\}$.\n- Define a periodic wrapping operator $\\mathcal{W}$ that maps any angle $\\theta$ to $[-\\pi,\\pi)$ by $\\mathcal{W}(\\theta)=((\\theta+\\pi)\\bmod 2\\pi)-\\pi$.\n\nImplement three numerical estimators of $E(\\mathbf{q})$:\n1. A high-resolution reference $E_{\\text{ref}}(\\mathbf{q})$ computed by the above Riemann sum on a dense grid of size $N_{\\text{ref}}\\times N_{\\text{ref}}$ with $N_{\\text{ref}}=384$.\n2. A coarse non-adaptive estimate $E_{\\text{na}}(\\mathbf{q};N)$ on an $N\\times N$ grid that emulates a code which only knows band energies on the coarse grid:\n   - Precompute $\\varepsilon$ only at the $N\\times N$ grid points.\n   - For each coarse grid point $\\mathbf{k}$, form $\\mathbf{k}+\\mathbf{q}$, wrap each component with $\\mathcal{W}$, and evaluate $\\varepsilon(\\mathbf{k}+\\mathbf{q})$ by periodic bilinear interpolation from the $N\\times N$ table of precomputed values. When $\\mathbf{q}$ is commensurate with the coarse mesh (i.e., both $q_x/\\Delta$ and $q_y/\\Delta$ are integers), the interpolation reduces to exact table lookup.\n   - Average $S\\big(\\varepsilon(\\mathbf{k}),\\varepsilon(\\mathbf{k}+\\mathbf{q});\\alpha\\big)$ over the $N\\times N$ grid to obtain $E_{\\text{na}}(\\mathbf{q};N)$.\n3. An adaptive $\\mathbf{k}+\\mathbf{q}$ estimate $E_{\\text{ad}}(\\mathbf{q};N)$ that seeks a refined grid commensurate with $\\mathbf{q}$:\n   - For a tolerance $\\tau=10^{-12}$ and an upper bound $M_{\\max}=96$, find the smallest integer $M\\ge N$ such that both $q_x/\\Delta_M$ and $q_y/\\Delta_M$ are within $\\tau$ of an integer, where $\\Delta_M=2\\pi/M$. If no such $M\\le M_{\\max}$ exists, set $M=M_{\\max}$.\n   - Compute $E_{\\text{ad}}(\\mathbf{q};N)$ as in the non-adaptive case but using the $M\\times M$ grid and periodic bilinear interpolation on that refined grid. When commensurability is achieved, the bilinear interpolation again reduces to exact table lookup, removing the $\\mathbf{k}+\\mathbf{q}$ alignment bias.\n\nError metrics:\n- For each test case, compute the relative errors\n$$\n\\delta_{\\text{na}} = \\frac{\\left|E_{\\text{na}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|,10^{-12}\\right)},\\quad\n\\delta_{\\text{ad}} = \\frac{\\left|E_{\\text{ad}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|,10^{-12}\\right)}.\n$$\n- Also report the boolean $b_{\\text{imp}}$ which is true if and only if $\\delta_{\\text{ad}}<\\delta_{\\text{na}}$.\n\nTest suite:\n- Use the following four test cases, which probe commensurate and incommensurate scenarios, multi-component $\\mathbf{q}$, and a boundary condition:\n  - Case A: $N=12$, $\\mathbf{q}=(\\pi/3,\\,0)$.\n  - Case B: $N=12$, $\\mathbf{q}=(\\pi/5,\\,0)$.\n  - Case C: $N=12$, $\\mathbf{q}=(\\pi/5,\\,2\\pi/5)$.\n  - Case D: $N=12$, $\\mathbf{q}=(0,\\,0)$.\n\nFinal output requirement:\n- Your program must produce a single line of output containing a list of lists, one inner list per test case in the order A, B, C, D. Each inner list must contain exactly three entries in this order: $\\delta_{\\text{na}}$ as a float, $\\delta_{\\text{ad}}$ as a float, and $b_{\\text{imp}}$ as a boolean. The output must have the exact format of a Python literal list, for example, $[[0.1,0.05,True],[\\dots],\\dots]$ with no extra text, spaces optional. No physical units are required because the model is dimensionless, and all angles are in radians.",
            "solution": "The problem is deemed valid. It is scientifically grounded as a well-defined model problem in computational materials science, designed to test numerical methods for handling incommensurate structures. It is well-posed, with all necessary functions, parameters, and procedures explicitly defined. The problem statement is objective and free of ambiguities.\n\nThe task is to implement and compare three numerical estimators for the spin-spiral energy functional $E(\\mathbf{q})$. This functional quantifies the energy of a system with a spin-spiral magnetic ordering characterized by a wave vector $\\mathbf{q}$. The comparison will highlight the numerical bias introduced by standard discrete Brillouin zone sampling when the spin-spiral wave vector $\\mathbf{q}$ is incommensurate with the sampling grid, and demonstrate how an adaptive grid strategy can mitigate this bias.\n\nFirst, we define the fundamental physical and mathematical components of the model.\nThe system is a two-dimensional square lattice, whose Brillouin zone (BZ) is the square region $[-\\pi, \\pi) \\times [-\\pi, \\pi)$, with area $\\Omega_{\\text{BZ}} = (2\\pi)^2$.\nThe electronic band structure is described by a single-band tight-binding dispersion relation:\n$$\n\\varepsilon(\\mathbf{k}) = \\varepsilon(k_x, k_y) = -2t \\left[ \\cos(k_x) + \\cos(k_y) \\right]\n$$\nwhere $\\mathbf{k} = (k_x, k_y)$ is a wave vector in the BZ and the hopping parameter is set to $t=1$.\nThe interaction giving rise to the spin-spiral state is modeled by a surrogate coupling function, $S$, which depends on the energies of two states coupled by the vector $\\mathbf{q}$:\n$$\nS(x, y; \\alpha) = \\frac{1}{1 + \\alpha (y-x)^2}\n$$\nThe parameter $\\alpha$ controls the strength of the energy penalty for large differences between the coupled state energies, and is given as $\\alpha=0.5$.\nThe total spin-spiral energy $E(\\mathbf{q})$ is the average of this coupling function over all possible pairs of states $(\\mathbf{k}, \\mathbf{k}+\\mathbf{q})$ in the Brillouin zone:\n$$\nE(\\mathbf{q}) = \\frac{1}{\\Omega_{\\text{BZ}}} \\int_{\\text{BZ}} d^2k \\; S\\big(\\varepsilon(\\mathbf{k}), \\varepsilon(\\mathbf{k}+\\mathbf{q}); \\alpha\\big)\n$$\n\nNumerically, the continuous integral is replaced by a discrete sum over a uniform $N \\times N$ grid of $\\mathbf{k}$-points, analogous to a Monkhorst-Pack sampling scheme. The grid points are defined as:\n$$\nk_x(i) = -\\pi + \\left(i + \\frac{1}{2}\\right)\\Delta, \\quad k_y(j) = -\\pi + \\left(j + \\frac{1}{2}\\right)\\Delta\n$$\nfor integers $i, j \\in \\{0, 1, \\dots, N-1\\}$, with grid spacing $\\Delta = 2\\pi/N$. The integral is then approximated by a Riemann sum:\n$$\nE(\\mathbf{q}) \\approx \\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} S\\big(\\varepsilon(\\mathbf{k}_{ij}), \\varepsilon(\\mathbf{k}_{ij}+\\mathbf{q}); \\alpha\\big)\n$$\nwhere $\\mathbf{k}_{ij} = (k_x(i), k_y(j))$. A crucial step is handling the vector $\\mathbf{k}+\\mathbf{q}$, whose components may fall outside the primary BZ interval $[-\\pi, \\pi)$. We map them back into this interval using the periodic wrapping operator $\\mathcal{W}$, defined as $\\mathcal{W}(\\theta) = ((\\theta+\\pi) \\pmod{2\\pi}) - \\pi$.\n\nWe will now detail the three distinct numerical estimators for $E(\\mathbf{q})$.\n\n1.  **High-Resolution Reference, $E_{\\text{ref}}(\\mathbf{q})$**: This serves as the \"ground truth\" for our numerical experiment. It is computed by performing the discrete sum on a very dense grid with $N_{\\text{ref}} = 384$. For each grid point $\\mathbf{k}$, both $\\varepsilon(\\mathbf{k})$ and $\\varepsilon(\\mathcal{W}(\\mathbf{k}+\\mathbf{q}))$ are calculated directly from the analytical formula for $\\varepsilon$. The high density of points ensures a very accurate approximation of the true integral, minimizing discretization error.\n\n2.  **Non-Adaptive Estimator, $E_{\\text{na}}(\\mathbf{q}; N)$**: This method simulates a standard, non-adaptive first-principles calculation performed on a coarse $N \\times N$ grid.\n    - First, a table of energy values, $\\varepsilon(\\mathbf{k})$, is pre-computed and stored only for the points on the coarse $N \\times N$ grid.\n    - The summation proceeds over this coarse grid. For each coarse-grid point $\\mathbf{k}$, we require the energy $\\varepsilon(\\mathbf{k}+\\mathbf{q})$.\n    - When $\\mathbf{q}$ is incommensurate with the grid (i.e., $q_x/\\Delta$ or $q_y/\\Delta$ is not an integer), the point $\\mathbf{k}' = \\mathcal{W}(\\mathbf{k}+\\mathbf{q})$ will not coincide with any point in our pre-computed table.\n    - To obtain $\\varepsilon(\\mathbf{k}')$, we must interpolate from the surrounding four grid points in the table. The problem specifies periodic bilinear interpolation. Given a point $\\mathbf{k}'=(k'_x, k'_y)$ and the energy table on the $N \\times N$ grid with spacing $\\Delta$, we find the \"floor\" grid indices $(i_0, j_0)$ and normalized displacements $(t_x, t_y)$ such that $k'_x$ is between grid points $i_0$ and $(i_0+1)\\pmod N$, and similarly for $k'_y$. The interpolated energy is then:\n      $$\n      \\varepsilon(\\mathbf{k}') \\approx (1-t_x)(1-t_y)\\varepsilon_{i_0,j_0} + t_x(1-t_y)\\varepsilon_{i_0+1,j_0} + (1-t_x)t_y\\varepsilon_{i_0,j_0+1} + t_x t_y\\varepsilon_{i_0+1,j_0+1}\n      $$\n      (Indices are taken modulo $N$). This interpolation introduces an error that depends on the non-linearity of $\\varepsilon(\\mathbf{k})$ and the location of $\\mathbf{k}'$. $E_{\\text{na}}$ is the average of $S(\\varepsilon(\\mathbf{k}), \\varepsilon_{\\text{interp}}(\\mathcal{W}(\\mathbf{k}+\\mathbf{q})); \\alpha)$ over the coarse grid.\n\n3.  **Adaptive Estimator, $E_{\\text{ad}}(\\mathbf{q}; N)$**: This method aims to eliminate the interpolation error by selecting a new, finer grid that is commensurate with $\\mathbf{q}$.\n    - A search is performed to find the smallest integer grid size $M$, with $N \\le M \\le M_{\\max}$, such that the new grid spacing $\\Delta_M = 2\\pi/M$ makes $\\mathbf{q}$ a grid vector. This is achieved when $q_x/\\Delta_M$ and $q_y/\\Delta_M$ are both within a small tolerance $\\tau=10^{-12}$ of an integer. If no such $M \\le M_{\\max}=96$ is found, $M$ is set to $M_{\\max}$.\n    - The entire calculation is then performed on this new, adaptive $M \\times M$ grid. An energy table for $\\varepsilon(\\mathbf{k})$ is computed on this $M \\times M$ grid. The summation for $E_{\\text{ad}}$ is also carried out over this grid.\n    - For each point $\\mathbf{k}$ on the $M \\times M$ grid, the shifted point $\\mathbf{k}+\\mathbf{q}$ will now land on (or extremely close to) another grid point. Consequently, the bilinear interpolation for $\\varepsilon(\\mathcal{W}(\\mathbf{k}+\\mathbf{q}))$ becomes a simple, exact table lookup, thereby removing the source of bias present in the non-adaptive scheme.\n\nFinally, to quantify the improvement, we compute the relative errors of the two coarse-grid methods with respect to the high-resolution reference:\n$$\n\\delta_{\\text{na}} = \\frac{\\left|E_{\\text{na}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|, 10^{-12}\\right)}, \\quad \\delta_{\\text{ad}} = \\frac{\\left|E_{\\text{ad}}(\\mathbf{q};N) - E_{\\text{ref}}(\\mathbf{q})\\right|}{\\max\\left(|E_{\\text{ref}}(\\mathbf{q})|, 10^{-12}\\right)}\n$$\nThe boolean flag $b_{\\text{imp}}$ is set to true if the adaptive method is more accurate, i.e., $\\delta_{\\text{ad}} < \\delta_{\\text{na}}$. The implementation will process the four specified test cases and report these three metrics for each.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem statement\nT_HOP = 1.0\nALPHA = 0.5\nN_REF = 384\nTAU = 1e-12\nM_MAX = 96\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n\n    def wrap(theta):\n        \"\"\"Applies the periodic wrapping operator W to map angles to [-pi, pi).\"\"\"\n        return (theta + np.pi) % (2 * np.pi) - np.pi\n\n    def epsilon(k, t):\n        \"\"\"Computes the tight-binding dispersion epsilon(k).\"\"\"\n        kx, ky = k[..., 0], k[..., 1]\n        return -2 * t * (np.cos(kx) + np.cos(ky))\n\n    def S_func(eps1, eps2, alpha):\n        \"\"\"Computes the surrogate coupling function S(eps1, eps2; alpha).\"\"\"\n        return 1.0 / (1.0 + alpha * (eps2 - eps1)**2)\n\n    def bilinear_interp(k_prime, eps_grid, N):\n        \"\"\"Performs periodic bilinear interpolation of epsilon on a grid.\"\"\"\n        delta = 2.0 * np.pi / N\n        kx_p_wrapped, ky_p_wrapped = k_prime\n\n        # Calculate floating-point indices and interpolation weights\n        ix_float = (kx_p_wrapped + np.pi) / delta - 0.5\n        iy_float = (ky_p_wrapped + np.pi) / delta - 0.5\n\n        ix0 = int(np.floor(ix_float))\n        iy0 = int(np.floor(iy_float))\n\n        tx = ix_float - ix0\n        ty = iy_float - iy0\n\n        # Apply periodic boundary conditions on indices\n        ix0 %= N\n        iy0 %= N\n        ix1 = (ix0 + 1) % N\n        iy1 = (iy0 + 1) % N\n\n        # Get values at the four surrounding grid points\n        v00 = eps_grid[ix0, iy0]\n        v10 = eps_grid[ix1, iy0]\n        v01 = eps_grid[ix0, iy1]\n        v11 = eps_grid[ix1, iy1]\n\n        # Perform interpolation\n        c0 = v00 * (1 - tx) + v10 * tx\n        c1 = v01 * (1 - tx) + v11 * tx\n\n        return c0 * (1 - ty) + c1 * ty\n\n    def find_M(q, N, M_max, tau):\n        \"\"\"Finds the smallest commensurate grid size M >= N.\"\"\"\n        q_frac = q / (2 * np.pi)\n        for M_cand in range(N, M_max + 1):\n            scaled_q = M_cand * q_frac\n            residuals = np.abs(scaled_q - np.round(scaled_q))\n            if np.all(residuals < tau):\n                return M_cand\n        return M_max\n\n    def calc_E_ref(q, N, t, alpha):\n        \"\"\"Computes the high-resolution reference energy E_ref.\"\"\"\n        delta = 2.0 * np.pi / N\n        k_1d = -np.pi + (np.arange(N) + 0.5) * delta\n        kx_grid, ky_grid = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_grid = np.stack((kx_grid, ky_grid), axis=-1)\n\n        eps_k = epsilon(k_grid, t)\n        \n        k_plus_q = k_grid + q\n        k_plus_q_wrapped = wrap(k_plus_q)\n        \n        eps_k_plus_q = epsilon(k_plus_q_wrapped, t)\n        \n        s_vals = S_func(eps_k, eps_k_plus_q, alpha)\n        \n        return np.mean(s_vals)\n\n    def calc_E_interp(q, N, t, alpha):\n        \"\"\"Computes energy using interpolation, base for E_na and E_ad.\"\"\"\n        delta = 2.0 * np.pi / N\n        k_1d = -np.pi + (np.arange(N) + 0.5) * delta\n        kx_grid, ky_grid = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_grid = np.stack((kx_grid, ky_grid), axis=-1)\n\n        eps_table = epsilon(k_grid, t)\n        \n        total_s = 0.0\n        for i in range(N):\n            for j in range(N):\n                k = k_grid[i, j, :]\n                eps_k = eps_table[i, j]\n                \n                k_plus_q = k + q\n                k_plus_q_wrapped = wrap(k_plus_q)\n                \n                eps_k_plus_q = bilinear_interp(k_plus_q_wrapped, eps_table, N)\n                total_s += S_func(eps_k, eps_k_plus_q, alpha)\n        \n        return total_s / (N * N)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # N, q\n        (12, np.array([np.pi/3, 0.0])),         # Case A\n        (12, np.array([np.pi/5, 0.0])),         # Case B\n        (12, np.array([np.pi/5, 2*np.pi/5])),  # Case C\n        (12, np.array([0.0, 0.0])),             # Case D\n    ]\n\n    results = []\n    for N, q in test_cases:\n        # 1. Compute reference energy\n        E_ref = calc_E_ref(q, N_REF, T_HOP, ALPHA)\n        \n        # 2. Compute non-adaptive energy\n        E_na = calc_E_interp(q, N, T_HOP, ALPHA)\n\n        # 3. Compute adaptive energy\n        M = find_M(q, N, M_MAX, TAU)\n        E_ad = calc_E_interp(q, M, T_HOP, ALPHA)\n        \n        # 4. Compute error metrics\n        denom = max(abs(E_ref), 1e-12)\n        delta_na = abs(E_na - E_ref) / denom\n        delta_ad = abs(E_ad - E_ref) / denom\n        b_imp = delta_ad < delta_na\n        \n        results.append([delta_na, delta_ad, b_imp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A primary goal of first-principles calculations is to derive parameters for higher-level models that describe physics at larger length scales. This practice  demonstrates how to bridge the atomistic and continuum scales by extracting key micromagnetic parameters from a set of spin-spiral energy calculations. By fitting computed energies to a low-wavevector expansion, you will determine the spin stiffness $D$, the Dzyaloshinskii-Moriya vector $\\mathbf{D}$, and the magnetocrystalline anisotropy $K$, gaining a practical skill essential for multiscale materials modeling.",
            "id": "3468726",
            "problem": "You are given synthetic first-principles total energies for planar spin spirals in a metallic ferromagnet, computed under three exchange–correlation approximations: Local Spin Density Approximation (LSDA), Generalized Gradient Approximation (GGA), and meta-Generalized Gradient Approximation (meta-GGA). For small wavevectors, symmetry and analyticity imply that the energy per atom of a homogeneous spin spiral with propagation vector $\\mathbf{q}$ and chirality $s \\in \\{+1,-1\\}$ admits the lowest-order expansion\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,\\lvert \\mathbf{q} \\rvert^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q},\n$$\nwhere $E_{0}$ is a baseline energy, $D$ is the scalar spin stiffness, $\\mathbf{D}$ is the Dzyaloshinskii–Moriya Interaction (DMI) vector, $K$ is the uniaxial magnetocrystalline anisotropy constant relative to the easy axis $\\hat{\\mathbf{z}}$, and $c$ is an orientation factor for the anisotropy contribution. For the data provided here, all spin spirals are planar in the $xy$-plane, so $c=1$ for all noncollinear spirals. Two uniform (collinear) states are also provided: one aligned with the easy axis $\\hat{\\mathbf{z}}$ for which $c=0$, and one perpendicular to $\\hat{\\mathbf{z}}$ for which $c=1$. The chirality $s=+1$ denotes right-handed rotation and $s=-1$ denotes left-handed rotation. The units are as follows: energies in milli-electronvolts per atom (meV/atom), wavevectors in inverse ångström ($\\text{\\AA}^{-1}$), so that $D$ is in $\\text{meV}\\cdot\\text{\\AA}^{2}$ and $\\mathbf{D}$ in $\\text{meV}\\cdot\\text{\\AA}$, and $K$ in meV/atom.\n\nTask. Starting from the expansion above and the principle of linear superposition for the different invariant contributions, derive an algorithm that, given a set of measurements $\\{(\\mathbf{q}_{i},s_{i},c_{i},E_{i})\\}$, estimates the parameters $\\{D,\\mathbf{D},K\\}$ by solving a linear least-squares problem over the regressors $\\{1,c_{i},\\lvert \\mathbf{q}_{i}\\rvert^{2}, s_{i} q_{i,x}, s_{i} q_{i,y}, s_{i} q_{i,z}\\}$. Then implement the algorithm as a complete, runnable program that reports the fitted parameters for each functional as specified below.\n\nData. For each functional, you are given the list of tuples $(q_{x},q_{y},q_{z},s,c,E)$ as follows. All $E$ values are in meV/atom and all $q$ components in $\\text{\\AA}^{-1}$. The uniform states are listed last with $\\mathbf{q}=\\mathbf{0}$; for these, use $s=0$.\n\n- LSDA (Local Spin Density Approximation):\n  - Spirals:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-117.71)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-117.89)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-117.83)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-117.77)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-118.448)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-118.448)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-118.67)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-118.73)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-119.069)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-119.087)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-119.171)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-119.093)$\n  - Uniform:\n    - $(0.00,0.00,0.00,0,0,-120.00)$\n    - $(0.00,0.00,0.00,0,1,-119.60)$\n\n- GGA (Generalized Gradient Approximation):\n  - Spirals:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-147.63)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-147.87)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-147.70)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-147.80)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-148.47)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-148.47)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-148.665)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-148.835)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-149.131)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-149.209)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-149.273)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-149.187)$\n  - Uniform:\n    - $(0.00,0.00,0.00,0,0,-150.00)$\n    - $(0.00,0.00,0.00,0,1,-149.75)\n\n- meta-GGA (meta-Generalized Gradient Approximation):\n  - Spirals:\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-197.76)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-197.76)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-198.468)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-198.516)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-198.80)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-198.80)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-199.244)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-199.280)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-199.289)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-199.367)$\n  - Uniform:\n    - $(0.00,0.00,0.00,0,0,-200.00)$\n    - $(0.00,0.00,0.00,0,1,-199.90)\n\nRequirements.\n- Use only the linear model stated above and derive a least-squares estimator from first principles by constructing a design matrix with columns corresponding to $1$, $c$, $\\lvert \\mathbf{q} \\rvert^{2}$, $s\\,q_{x}$, $s\\,q_{y}$, $s\\,q_{z}$.\n- For each functional, estimate and report the tuple $[D,D_{x},D_{y},D_{z},K]$, where $\\mathbf{D}=(D_{x},D_{y},D_{z})$.\n- Numerical units:\n  - Energies must be treated in meV/atom.\n  - Wavevectors must be treated in $\\text{\\AA}^{-1}$.\n  - Report $D$ in $\\text{meV}\\cdot\\text{\\AA}^{2}$, each component of $\\mathbf{D}$ in $\\text{meV}\\cdot\\text{\\AA}$, and $K$ in meV/atom.\n- Angle units are not used in this problem.\n- Output rounding: Round each reported number to three decimal places.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one functional in the order LSDA, GGA, meta-GGA. The exact format is\n  $$\n  [[D_{\\mathrm{LSDA}},D_{x,\\mathrm{LSDA}},D_{y,\\mathrm{LSDA}},D_{z,\\mathrm{LSDA}},K_{\\mathrm{LSDA}}],[D_{\\mathrm{GGA}},D_{x,\\mathrm{GGA}},D_{y,\\mathrm{GGA}},D_{z,\\mathrm{GGA}},K_{\\mathrm{GGA}}],[D_{\\mathrm{mGGA}},D_{x,\\mathrm{mGGA}},D_{y,\\mathrm{mGGA}},D_{z,\\mathrm{mGGA}},K_{\\mathrm{mGGA}}]]\n  $$\n  where each value is rounded to three decimals. For example, an output could look like\n  $$\n  [[180.000,0.900,-0.300,0.000,0.400],[200.000,1.200,0.500,0.000,0.250],[220.000,-0.600,0.600,0.300,0.100]].\n  $$\n\nTest suite and coverage.\n- The LSDA set includes a direction with $q_{z}\\neq 0$ but $D_{z}=0$, and a case with $s$-independent energy to probe the absence of DMI along $z$.\n- The GGA set exercises nonzero $D_{x}$ and $D_{y}$ with both chiralities and multiple magnitudes of $\\lvert \\mathbf{q}\\rvert$ to constrain $D$ robustly.\n- The meta-GGA set includes nonzero $D_{z}$ and a spiral with $\\mathbf{D}\\cdot\\mathbf{q}=0$ to test sensitivity to null-projection scenarios.\n- Uniform states at $\\mathbf{q}=\\mathbf{0}$ with $c=0$ and $c=1$ allow independent identification of $K$ and separation from the intercept $E_{0}$.\n\nYour submission must be a single, complete program that constructs the design matrices from the provided data, solves the least-squares problems, and prints the results in the exact format described above, with all numbers rounded to three decimals, using no input files. The program must be self-contained and runnable as is.",
            "solution": "The problem requires the derivation and implementation of an algorithm to estimate micromagnetic parameters from a set of synthetic first-principles total energy calculations. The provided model for the energy $E$ per atom of a planar spin spiral as a function of its wavevector $\\mathbf{q}$, chirality $s$, and an anisotropy orientation factor $c$ is:\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,\\lvert \\mathbf{q} \\rvert^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q}\n$$\nwhere $E_{0}$ is a baseline energy, $K$ is the uniaxial magnetocrystalline anisotropy constant, $D$ is the scalar spin stiffness, and $\\mathbf{D}$ is the Dzyaloshinskii–Moriya Interaction (DMI) vector. The task is to estimate the parameters $\\{D, \\mathbf{D}, K\\}$.\n\nFirst, we expand the DMI term $s\\,\\mathbf{D}\\cdot\\mathbf{q}$. With $\\mathbf{D} = (D_{x}, D_{y}, D_{z})$ and $\\mathbf{q} = (q_{x}, q_{y}, q_{z})$, this becomes $s(D_{x}q_{x} + D_{y}q_{y} + D_{z}q_{z})$. Substituting this into the energy model reveals its linear structure with respect to the parameters:\n$$\nE(\\mathbf{q},s,c) = E_{0}(1) + K(c) + D(\\lvert\\mathbf{q}\\rvert^{2}) + D_{x}(s q_{x}) + D_{y}(s q_{y}) + D_{z}(s q_{z})\n$$\nThe terms in parentheses are the regressor variables, and $\\{E_{0}, K, D, D_{x}, D_{y}, D_{z}\\}$ are the coefficients to be determined. Given a set of $N$ measurements $\\{(\\mathbf{q}_{i}, s_{i}, c_{i}, E_{i})\\}_{i=1}^{N}$, this defines a system of linear equations. This system is amenable to a linear least-squares analysis.\n\nWe formulate the problem in matrix notation as $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\beta}$, where:\n- $\\mathbf{y}$ is the $N \\times 1$ column vector of observed energies: $\\mathbf{y} = [E_{1}, E_{2}, \\dots, E_{N}]^T$.\n- $\\boldsymbol{\\beta}$ is the $M \\times 1$ column vector of the unknown model parameters. For this problem, there are $M=6$ parameters. We define $\\boldsymbol{\\beta}$ based on the order of regressors specified in the problem statement: $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5]^T = [E_0, K, D, D_x, D_y, D_z]^T$.\n- $\\mathbf{X}$ is the $N \\times M$ design matrix. Each row $i$ of $\\mathbf{X}$ is constructed from the $i$-th data point, and the columns correspond to the regressors $\\{1, c, \\lvert\\mathbf{q}\\rvert^{2}, s q_{x}, s q_{y}, s q_{z}\\}$. Specifically, the $i$-th row is:\n$$\n\\mathbf{X}_{i,:} = \\begin{bmatrix} 1 & c_{i} & \\lvert\\mathbf{q}_{i}\\rvert^{2} & s_{i}q_{i,x} & s_{i}q_{i,y} & s_{i}q_{i,z} \\end{bmatrix}\n$$\nwhere $\\lvert\\mathbf{q}_{i}\\rvert^{2} = q_{i,x}^2 + q_{i,y}^2 + q_{i,z}^2$.\n\nThe linear least-squares method seeks the parameter vector $\\hat{\\boldsymbol{\\beta}}$ that minimizes the sum of squared residuals, $S = \\sum_{i=1}^{N} (E_i - \\mathbf{X}_{i,:}\\boldsymbol{\\beta})^2 = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})$. The solution that minimizes $S$ is found by solving the normal equations:\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\nAssuming the columns of $\\mathbf{X}$ are linearly independent (which is generally true for a well-designed set of measurements), the matrix $\\mathbf{X}^T \\mathbf{X}$ is invertible. The unique least-squares estimate of the parameter vector is then:\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\nThe implemented algorithm will, for each functional's dataset:\n1.  Construct the design matrix $\\mathbf{X}$ and the observation vector $\\mathbf{y}$ from the provided data tuples $(q_{x}, q_{y}, q_{z}, s, c, E)$.\n2.  Numerically compute the parameter vector $\\hat{\\boldsymbol{\\beta}}$ by solving the linear least-squares problem. This is best done using a stable numerical routine, such as one based on QR decomposition or Singular Value Decomposition (SVD), which is more robust than explicitly computing the inverse of $\\mathbf{X}^T \\mathbf{X}$.\n3.  The components of the resulting vector $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5]^T$ are the estimates for the physical parameters:\n    - Anisotropy constant $K \\approx \\hat{\\beta}_1$\n    - Spin stiffness $D \\approx \\hat{\\beta}_2$\n    - DMI vector components $\\{D_x, D_y, D_z\\} \\approx \\{\\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5\\}$\n4.  Assemble the required output tuple $[D, D_x, D_y, D_z, K]$ from the components of $\\hat{\\boldsymbol{\\beta}}$, which corresponds to $[\\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5, \\hat{\\beta}_1]$.\n5.  Round the final values to three decimal places and format them as specified.\nThis procedure systematically derives the physical parameters from the energy data based on the provided theoretical model.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Fits micromagnetic parameters to synthetic first-principles energy data\n    using linear least-squares regression and prints the results.\n    \"\"\"\n    \n    # Data sets provided in the problem statement.\n    # Each tuple is (qx, qy, qz, s, c, E).\n    lsda_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -117.71),\n        (0.10, 0.00, 0.00, -1, 1, -117.89),\n        (0.00, 0.10, 0.00, 1, 1, -117.83),\n        (0.00, 0.10, 0.00, -1, 1, -117.77),\n        (0.00, 0.00, 0.08, 1, 1, -118.448),\n        (0.00, 0.00, 0.08, -1, 1, -118.448),\n        (0.05, 0.05, 0.00, 1, 1, -118.67),\n        (0.05, 0.05, 0.00, -1, 1, -118.73),\n        (0.02, 0.03, 0.04, 1, 1, -119.069),\n        (0.02, 0.03, 0.04, -1, 1, -119.087),\n        (-0.04, 0.01, 0.03, 1, 1, -119.171),\n        (-0.04, 0.01, 0.03, -1, 1, -119.093),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -120.00),\n        (0.00, 0.00, 0.00, 0, 1, -119.60)\n    ]\n\n    gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -147.63),\n        (0.10, 0.00, 0.00, -1, 1, -147.87),\n        (0.00, 0.10, 0.00, 1, 1, -147.70),\n        (0.00, 0.10, 0.00, -1, 1, -147.80),\n        (0.00, 0.00, 0.08, 1, 1, -148.47),\n        (0.00, 0.00, 0.08, -1, 1, -148.47),\n        (0.05, 0.05, 0.00, 1, 1, -148.665),\n        (0.05, 0.05, 0.00, -1, 1, -148.835),\n        (0.02, 0.03, 0.04, 1, 1, -149.131),\n        (0.02, 0.03, 0.04, -1, 1, -149.209),\n        (-0.04, 0.01, 0.03, 1, 1, -149.273),\n        (-0.04, 0.01, 0.03, -1, 1, -149.187),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -150.00),\n        (0.00, 0.00, 0.00, 0, 1, -149.75)\n    ]\n\n    meta_gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -197.76),\n        (0.10, 0.00, 0.00, -1, 1, -197.64),\n        (0.00, 0.10, 0.00, 1, 1, -197.64),\n        (0.00, 0.10, 0.00, -1, 1, -197.76),\n        (0.00, 0.00, 0.08, 1, 1, -198.468),\n        (0.00, 0.00, 0.08, -1, 1, -198.516),\n        (0.05, 0.05, 0.00, 1, 1, -198.80),\n        (0.05, 0.05, 0.00, -1, 1, -198.80),\n        (0.02, 0.03, 0.04, 1, 1, -199.244),\n        (0.02, 0.03, 0.04, -1, 1, -199.280),\n        (-0.04, 0.01, 0.03, 1, 1, -199.289),\n        (-0.04, 0.01, 0.03, -1, 1, -199.367),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -200.00),\n        (0.00, 0.00, 0.00, 0, 1, -199.90)\n    ]\n\n    all_datasets = [lsda_data, gga_data, meta_gga_data]\n    overall_results = []\n\n    for dataset in all_datasets:\n        num_points = len(dataset)\n        # Design matrix X: columns for [1, c, |q|^2, s*qx, s*qy, s*qz]\n        X = np.zeros((num_points, 6))\n        # Observation vector y: energies E\n        y = np.zeros(num_points)\n\n        for i, point in enumerate(dataset):\n            qx, qy, qz, s, c, E = point\n            q_sq = qx**2 + qy**2 + qz**2\n            \n            X[i, 0] = 1.0       # Corresponds to E0 (intercept)\n            X[i, 1] = float(c)  # Corresponds to K\n            X[i, 2] = q_sq      # Corresponds to D\n            X[i, 3] = s * qx    # Corresponds to Dx\n            X[i, 4] = s * qy    # Corresponds to Dy\n            X[i, 5] = s * qz    # Corresponds to Dz\n            \n            y[i] = E\n\n        # Solve the linear least-squares problem X*p = y for p\n        params, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # Extract parameters according to the model: E = E0 + K*c + D*|q|^2 + ...\n        # params[0] = E0\n        K = params[1]\n        D = params[2]\n        Dx = params[3]\n        Dy = params[4]\n        Dz = params[5]\n        \n        # Assemble the results in the required order: [D, Dx, Dy, Dz, K]\n        result_list = [D, Dx, Dy, Dz, K]\n        overall_results.append(result_list)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to three decimal places.\n    output_parts = []\n    for res_list in overall_results:\n        formatted_numbers = [f\"{num:.3f}\" for num in res_list]\n        output_parts.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}