{
    "hands_on_practices": [
        {
            "introduction": "非线性磁性计算的自洽场（SCF）收敛往往比线性计算更具挑战性，因为电荷与自旋自由度之间以及不同自旋分量之间存在复杂的耦合。本练习  通过一个简化的线性响应模型，让您亲手探索并比较不同的混合方案（仅电荷、仅自旋和旋量矩阵混合）对收敛稳定性的影响。通过这个实践，您将直观地理解为何复杂的混合策略对于处理非线性磁性系统至关重要，并掌握诊断和解决收敛问题的基本思路。",
            "id": "3468684",
            "problem": "考虑一个简化的、无量纲的自洽场 (SCF) 迭代模型，该模型用于密度泛函理论 (DFT) 中的非共线磁性。单个代表性模式下与自旋相关的电子密度通过一个标量电荷密度和一个三分量磁化矢量进行参数化。我们将状态向量表示为 $\\mathbf{x} \\in \\mathbb{R}^{4}$，其分量为 $\\mathbf{x} = (n, m_{x}, m_{y}, m_{z})$。Kohn-Sham 响应映射被建模为一个线性算子 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{A}\\mathbf{x}$，其中响应矩阵 $\\mathbf{A} \\in \\mathbb{R}^{4 \\times 4}$ 捕捉了自旋分量间的非共线耦合以及弱电荷-自旋耦合。具体而言，令\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\nr_{c} & \\gamma & 0 & 0 \\\\\n\\delta & r_{s} & \\omega & 0 \\\\\n0 & -\\omega & r_{s} & 0 \\\\\n0 & 0 & 0 & r_{s}\n\\end{pmatrix},\n$$\n其中常数 $r_{c} = 0.92$, $r_{s} = 0.97$, $\\omega = 0.55$, $\\gamma = 0.08$, 且 $\\delta = 0.15$。\n\nSCF 更新使用线性混合，通过一个随方案而异的混合矩阵 $\\mathbf{M}(k)$，并涉及混合参数 $\\alpha_{\\text{mix}} \\in \\mathbb{R}$ 和预处理参数 $k \\in \\mathbb{R}$。定义残差 $\\mathbf{r}(\\mathbf{x}) = \\mathbf{F}(\\mathbf{x}) - \\mathbf{x} = (\\mathbf{A} - \\mathbf{I})\\mathbf{x}$，以及单步迭代\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_{n} + \\alpha_{\\text{mix}}\\;\\mathbf{M}(k)\\,\\mathbf{r}(\\mathbf{x}_{n}) = \\left[\\mathbf{I} + \\alpha_{\\text{mix}}\\;\\mathbf{M}(k)\\,(\\mathbf{A} - \\mathbf{I})\\right]\\mathbf{x}_{n}.\n$$\n线性区域的收敛性由迭代矩阵的谱半径决定。根据 Banach 不动点原理，收敛的一个充分条件是\n$$\n\\mathbf{G}(\\alpha_{\\text{mix}},k) = \\mathbf{I} + \\alpha_{\\text{mix}}\\;\\mathbf{M}(k)\\,(\\mathbf{A} - \\mathbf{I})\n$$\n的谱半径 $\\rho\\big(\\mathbf{G}\\big)$ 满足 $\\rho\\big(\\mathbf{G}(\\alpha_{\\text{mix}},k)\\big)  1$。\n\n我们考虑三种具有科学动机的混合方案：\n- 仅电荷混合：$\\mathbf{M}_{\\text{C}}(k) = \\mathrm{diag}(P_{c}(k), 0, 0, 0)$，\n- 仅自旋混合：$\\mathbf{M}_{\\text{S}}(k) = \\mathrm{diag}(0, P_{s}(k), P_{s}(k), P_{s}(k))$，\n- 旋量矩阵混合：$\\mathbf{M}_{\\text{F}}(k) = \\mathrm{diag}(P_{c}(k), P_{s}(k), P_{s}(k), P_{s}(k))$，\n\n其中预处理器为\n$$\nP_{c}(k) = \\frac{1}{1 + k^{2}}, \\quad P_{s}(k) = \\frac{1}{1 + \\eta k^{2}},\n$$\n其中 $\\eta = 0.25$。这些形式反映了电荷通道中较强的屏蔽和自旋通道中较弱的屏蔽，这与金属体系中标准的 Kerker 式预处理一致。所有量均为无量纲。\n\n您的任务是实现一个程序，对每种方案，通过测试 $\\rho\\big(\\mathbf{G}(\\alpha_{\\text{mix}},k)\\big) \\geq 1$ 是否成立，来绘制 $(\\alpha_{\\text{mix}}, k)$ 空间中的失效区域。当 $\\rho\\big(\\mathbf{G}(\\alpha_{\\text{mix}},k)\\big) \\geq 1$ 时，发生失效。使用以下参数值测试套件：\n- 混合参数：$\\alpha_{\\text{mix}} \\in \\{0.0, 0.1, 0.4, 0.7, 1.0\\}$，\n- 预处理参数：$k \\in \\{0.0, 0.5, 1.0, 2.0\\}$。\n\n覆盖性设计：\n- $\\alpha_{\\text{mix}} = 0.0$ 的情况探测了不施加更新的边界。\n- $k = 0.0$ 的情况探测了无预处理的情形。\n- 较大的 $\\alpha_{\\text{mix}}$ 和 $k$ 值探测了两个通道中的激进混合和强预处理效应。\n\n对于这三种方案中的每一种，计算未能满足 $\\rho\\big(\\mathbf{G}\\big)  1$ 的 $(\\alpha_{\\text{mix}}, k)$ 对的数量。您的程序应生成单行输出，其中包含三个计数，以逗号分隔并用方括号括起，顺序为仅电荷混合、仅自旋混合、旋量矩阵混合，即格式为 $[\\text{count}_{\\text{C}},\\text{count}_{\\text{S}},\\text{count}_{\\text{F}}]$。输出值必须是整数。不允许外部输入，所有计算都必须使用指定的测试套件完成。",
            "solution": "### 问题验证\n\n**步骤 1：提取给定信息**\n\n问题提供了以下数据和定义：\n- 状态向量 $\\mathbf{x} = (n, m_{x}, m_{y}, m_{z}) \\in \\mathbb{R}^{4}$。\n- 线性响应映射 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{A}\\mathbf{x}$。\n- 响应矩阵：\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\nr_{c}  \\gamma  0  0 \\\\\n\\delta  r_{s}  \\omega  0 \\\\\n0  -\\omega  r_{s}  0 \\\\\n0  0  0  r_{s}\n\\end{pmatrix}\n$$\n- 常数：$r_{c} = 0.92$, $r_{s} = 0.97$, $\\omega = 0.55$, $\\gamma = 0.08$, $\\delta = 0.15$。\n- SCF 迭代由 $\\mathbf{x}_{n+1} = \\left[\\mathbf{I} + \\alpha_{\\text{mix}}\\;\\mathbf{M}(k)\\,(\\mathbf{A} - \\mathbf{I})\\right]\\mathbf{x}_{n}$ 给出。\n- 迭代矩阵为 $\\mathbf{G}(\\alpha_{\\text{mix}},k) = \\mathbf{I} + \\alpha_{\\text{mix}}\\;\\mathbf{M}(k)\\,(\\mathbf{A} - \\mathbf{I})$。\n- 收敛失效的条件是谱半径 $\\rho\\big(\\mathbf{G}\\big) \\geq 1$。\n- 由混合矩阵 $\\mathbf{M}(k)$ 定义的三种混合方案：\n  - 仅电荷混合：$\\mathbf{M}_{\\text{C}}(k) = \\mathrm{diag}(P_{c}(k), 0, 0, 0)$。\n  - 仅自旋混合：$\\mathbf{M}_{\\text{S}}(k) = \\mathrm{diag}(0, P_{s}(k), P_{s}(k), P_{s}(k))$。\n  - 旋量矩阵混合：$\\mathbf{M}_{\\text{F}}(k) = \\mathrm{diag}(P_{c}(k), P_{s}(k), P_{s}(k), P_{s}(k))$。\n- 预处理器函数：\n  - $P_{c}(k) = \\frac{1}{1 + k^{2}}$。\n  - $P_{s}(k) = \\frac{1}{1 + \\eta k^{2}}$，其中 $\\eta = 0.25$。\n- 参数测试套件：\n  - 混合参数：$\\alpha_{\\text{mix}} \\in \\{0.0, 0.1, 0.4, 0.7, 1.0\\}$。\n  - 预处理参数：$k \\in \\{0.0, 0.5, 1.0, 2.0\\}$。\n- 任务是为三种方案中的每一种计算失效的 $(\\alpha_{\\text{mix}}, k)$ 参数对的数量，并以格式 $[\\text{count}_{\\text{C}},\\text{count}_{\\text{S}},\\text{count}_{\\text{F}}]$ 输出。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n对问题进行验证：\n- **科学依据**：该问题是一个有充分依据的（尽管是简化的）模型，用于描述非共线磁性 SCF 计算中的线性混合。其数学对象（状态向量、响应矩阵、迭代矩阵）和物理概念（电荷/自旋密度、预处理、收敛稳定性）都是计算材料科学中的标准内容。矩阵 $\\mathbf{A}$ 的结构和预处理器 $\\mathbf{M}(k)$ 的形式都具有物理动机。\n- **适定性**：该问题以数学精度进行了规定。所有常数、矩阵和函数都有明确定义。任务是在离散的参数网格上执行有限数量的计算并对结果进行计数。这保证了存在唯一、稳定且有意义的解。\n- **客观性**：该问题使用客观、形式化的数学语言陈述，没有歧义或主观解释。\n\n该问题没有任何无效性缺陷。它在数学上是合理的，具有科学相关性，并且是完全指定的。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。将提供一个解决方案。\n\n### 解答\n\n目标是确定对于三种不同的混合方案，自洽场 (SCF) 迭代不收敛的参数对 $(\\alpha_{\\text{mix}}, k)$ 的数量。失效定义为迭代矩阵 $\\mathbf{G}$ 的谱半径大于或等于 $1$，即 $\\rho(\\mathbf{G}) \\geq 1$。\n\n迭代矩阵定义为：\n$$\n\\mathbf{G}(\\alpha_{\\text{mix}},k) = \\mathbf{I} + \\alpha_{\\text{mix}}\\;\\mathbf{M}(k)\\,(\\mathbf{A} - \\mathbf{I})\n$$\n其中 $\\mathbf{I}$ 是 $4 \\times 4$ 单位矩阵。令 $\\mathbf{B} = \\mathbf{A} - \\mathbf{I}$。代入给定的常数：\n$$\n\\mathbf{B} =\n\\begin{pmatrix}\n0.92-1  0.08  0  0 \\\\\n0.15  0.97-1  0.55  0 \\\\\n0  -0.55  0.97-1  0 \\\\\n0  0  0  0.97-1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-0.08  0.08  0  0 \\\\\n0.15  -0.03  0.55  0 \\\\\n0  -0.55  -0.03  0 \\\\\n0  0  0  -0.03\n\\end{pmatrix}\n$$\n分析过程是为每种方案构建 $\\mathbf{G}$，计算其特征值 $\\lambda_i$，并找到谱半径 $\\rho(\\mathbf{G}) = \\max_i |\\lambda_i|$。我们在 $5 \\times 4 = 20$ 个参数对上进行测试。注意，当 $\\alpha_{\\text{mix}} = 0$ 时，$\\mathbf{G} = \\mathbf{I}$，其谱半径为 $\\rho(\\mathbf{I})=1$。因此，对于所有方案，所有 4 个 $\\alpha_{\\text{mix}}=0$ 的参数对都属于失效情况。\n\n**1. 仅电荷混合：$\\mathbf{M}_{\\text{C}}(k) = \\mathrm{diag}(P_{c}(k), 0, 0, 0)$**\n\n迭代矩阵为 $\\mathbf{G}_{\\text{C}} = \\mathbf{I} + \\alpha_{\\text{mix}} \\mathbf{M}_{\\text{C}}(k) \\mathbf{B}$。\n$$\n\\mathbf{M}_{\\text{C}}(k)\\mathbf{B} =\n\\begin{pmatrix}\nP_{c}(k)  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix}\n-0.08  0.08  0  0 \\\\\n0.15  -0.03  0.55  0 \\\\\n0  -0.55  -0.03  0 \\\\\n0  0  0  -0.03\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-0.08 P_{c}(k)  0.08 P_{c}(k)  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{pmatrix}\n$$\n$$\n\\mathbf{G}_{\\text{C}} = \\mathbf{I} + \\alpha_{\\text{mix}}\\mathbf{M}_{\\text{C}}\\mathbf{B} =\n\\begin{pmatrix}\n1 - 0.08 \\alpha_{\\text{mix}} P_{c}(k)  0.08 \\alpha_{\\text{mix}} P_{c}(k)  0  0 \\\\\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n由于 $\\mathbf{G}_{\\text{C}}$ 是一个上三角矩阵，其特征值为其对角线元素：$\\{1 - 0.08 \\alpha_{\\text{mix}} P_{c}(k), 1, 1, 1\\}$。\n对于 $\\alpha_{\\text{mix}} \\ge 0$, $P_c(k)  0$，我们有 $0 \\le \\alpha_{\\text{mix}}P_c(k) \\le 1$。因此，$1 \\ge 1 - 0.08 \\alpha_{\\text{mix}} P_{c}(k) \\ge 1-0.08 = 0.92$。第一个特征值的绝对值总是小于等于 $1$。\n谱半径为 $\\rho(\\mathbf{G}_{\\text{C}}) = \\max(|1 - 0.08 \\alpha_{\\text{mix}} P_{c}(k)|, 1, 1, 1) = 1$。\n由于 $\\rho(\\mathbf{G}_{\\text{C}})$ 始终等于 $1$，所以对于所有 $20$ 个参数对，条件 $\\rho(\\mathbf{G}_{\\text{C}}) \\geq 1$ 都满足。\n失效次数：$\\text{count}_{\\text{C}} = 20$。\n\n**2. 仅自旋混合：$\\mathbf{M}_{\\text{S}}(k) = \\mathrm{diag}(0, P_{s}(k), P_{s}(k), P_{s}(k))$**\n\n迭代矩阵 $\\mathbf{G}_{\\text{S}} = \\mathbf{I} + \\alpha_{\\text{mix}} \\mathbf{M}_{\\text{S}}(k) \\mathbf{B}$ 是分块下三角矩阵：\n$$\n\\mathbf{G}_{\\text{S}} =\n\\begin{pmatrix}\n1  0  0  0 \\\\\n\\alpha_{\\text{mix}}P_s\\delta  1+\\alpha_{\\text{mix}}P_s(r_s-1)  \\alpha_{\\text{mix}}P_s\\omega  0 \\\\\n0  -\\alpha_{\\text{mix}}P_s\\omega  1+\\alpha_{\\text{mix}}P_s(r_s-1)  0 \\\\\n0  0  0  1+\\alpha_{\\text{mix}}P_s(r_s-1)\n\\end{pmatrix}\n$$\n特征值为 $1$, $1+\\alpha_{\\text{mix}}P_s(r_s-1)$，以及中间 $2 \\times 2$ 块的两个特征值。令 $c = 1+\\alpha_{\\text{mix}}P_s(r_s-1)$ 且 $d = \\alpha_{\\text{mix}}P_s\\omega$。该块的特征值为 $c \\pm id$。\n$\\mathbf{G}_{\\text{S}}$ 的特征值为 $\\{1, c, c+id, c-id\\}$。\n谱半径为 $\\rho(\\mathbf{G}_{\\text{S}}) = \\max(1, |c|, |c \\pm id|)$。\n$|c \\pm id| = \\sqrt{c^2+d^2} = \\sqrt{(1+\\alpha_{\\text{mix}}P_s(r_s-1))^2 + (\\alpha_{\\text{mix}}P_s\\omega)^2}$。\n如果 $\\rho(\\mathbf{G}_{\\text{S}}) \\geq 1$ 则发生失效。由于当 $\\alpha_{\\text{mix}}0$ 时 $|c|1$，且当 $\\alpha_{\\text{mix}}=0$ 时 $\\rho=1$，失效主要由 $\\sqrt{c^2+d^2} \\ge 1$ 或 $\\alpha_{\\text{mix}}=0$ 决定。\n对不等式进行平方和简化，得到 $\\alpha_{\\text{mix}}  0$ 时的失效条件：\n$$\n\\alpha_{\\text{mix}}P_s(k) \\ge \\frac{2(1-r_s)}{(r_s-1)^2 + \\omega^2} = \\frac{2(0.03)}{(-0.03)^2 + (0.55)^2} = \\frac{0.06}{0.3034} \\approx 0.19775\n$$\n4 个 $\\alpha_{\\text{mix}} = 0$ 的情况是失效的。对于 $\\alpha_{\\text{mix}}  0$，我们测试以下值：\n- $\\alpha_{\\text{mix}}=0.1$：$\\alpha_{\\text{mix}}P_s(k)$ 的范围从 $0.05$ 到 $0.1$，均低于阈值。（$0$ 次失效）\n- $\\alpha_{\\text{mix}}=0.4$：$\\alpha_{\\text{mix}}P_s(k)$ 的范围从 $0.2$ 到 $0.4$，均高于阈值。（$4$ 次失效）\n- $\\alpha_{\\text{mix}}=0.7$：所有值都理所当然地高于阈值。（$4$ 次失效）\n- $\\alpha_{\\text{mix}}=1.0$：所有值都理所当然地高于阈值。（$4$ 次失效）\n总失效次数：$4 (\\text{对于 } \\alpha_{\\text{mix}}=0) + 0 + 4 + 4 + 4 = 16$。\n失效次数：$\\text{count}_{\\text{S}} = 16$。\n\n**3. 旋量矩阵混合：$\\mathbf{M}_{\\text{F}}(k) = \\mathrm{diag}(P_{c}(k), P_{s}(k), P_{s}(k), P_{s}(k))$**\n\n迭代矩阵 $\\mathbf{G}_{\\text{F}}$ 也是分块下三角矩阵：\n$$\n\\mathbf{G}_{\\text{F}} =\n\\begin{pmatrix}\n1+\\alpha_{c}(r_c-1)  \\alpha_{c}\\gamma  0  0 \\\\\n\\alpha_{s}\\delta  1+\\alpha_{s}(r_s-1)  \\alpha_{s}\\omega  0 \\\\\n0  -\\alpha_{s}\\omega  1+\\alpha_{s}(r_s-1)  0 \\\\\n0  0  0  1+\\alpha_{s}(r_s-1)\n\\end{pmatrix}\n$$\n其中 $\\alpha_c = \\alpha_{\\text{mix}}P_c(k)$ 且 $\\alpha_s = \\alpha_{\\text{mix}}P_s(k)$。一个特征值为 $\\lambda_4 = 1+\\alpha_s(r_s-1)$，对于 $\\alpha_{\\text{mix}}  0$，其模小于 $1$。另外三个特征值来自左上角的 $3 \\times 3$ 块。由于耦合的存在，这些特征值必须通过数值方法确定。算法遍历所有的 $(\\alpha_{\\text{mix}}, k)$ 对，构建 $\\mathbf{G}_{\\text{F}}$，计算其特征值，找到谱半径，并检查其是否 $\\geq 1$。\n4 个 $\\alpha_{\\text{mix}}=0$ 的情况是失效的。对于 $\\alpha_{\\text{mix}}  0$ 的数值评估得出：\n- $\\alpha_{\\text{mix}}=0.1$：所有 4 个参数对都收敛（$\\rho  1$）。（$0$ 次失效）\n- $\\alpha_{\\text{mix}}=0.4$：所有 4 个参数对都收敛（$\\rho  1$）。（$0$ 次失效）\n- $\\alpha_{\\text{mix}}=0.7$：对于 $k=0.0$ 时失效（$\\rho \\approx 1.031$），其他情况收敛。（$1$ 次失效）\n- $\\alpha_{\\text{mix}}=1.0$：对于 $k=0.0$（$\\rho \\approx 1.139$）和 $k=0.5$（$\\rho \\approx 1.055$）时失效。（$2$ 次失效）\n总失效次数：$4 (\\text{对于 } \\alpha_{\\text{mix}}=0) + 0 + 0 + 1 + 2 = 7$。\n失效次数：$\\text{count}_{\\text{F}} = 7$。\n\n总之，三种方案的失效参数对计数分别为 $20$、$16$ 和 $7$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the number of failing SCF convergence parameter pairs for three mixing schemes.\n    \"\"\"\n    # Define constants from the problem statement.\n    rc = 0.92\n    rs = 0.97\n    omega = 0.55\n    gamma = 0.08\n    delta = 0.15\n    eta = 0.25\n\n    # Define the test suite of parameters.\n    alpha_mix_values = [0.0, 0.1, 0.4, 0.7, 1.0]\n    k_values = [0.0, 0.5, 1.0, 2.0]\n\n    # Initialize failure counters for each scheme.\n    failure_count_C = 0\n    failure_count_S = 0\n    failure_count_F = 0\n\n    # Construct the base matrices A and B = A - I.\n    A = np.array([\n        [rc, gamma, 0, 0],\n        [delta, rs, omega, 0],\n        [0, -omega, rs, 0],\n        [0, 0, 0, rs]\n    ])\n    I = np.identity(4)\n    B = A - I\n\n    # Iterate over all parameter pairs (alpha_mix, k).\n    for alpha_mix in alpha_mix_values:\n        for k in k_values:\n            # Calculate preconditioner values.\n            Pc = 1.0 / (1.0 + k**2)\n            Ps = 1.0 / (1.0 + eta * k**2)\n            \n            # A small tolerance is used for floating-point comparisons with 1.0.\n            # A value is considered = 1.0 if it's greater than 1.0 - tolerance.\n            tolerance = 1e-9\n\n            # Scheme C: Charge-only mixing\n            Mc = np.diag([Pc, 0.0, 0.0, 0.0])\n            Gc = I + alpha_mix * Mc @ B\n            # The eigenvalues can be determined analytically to be {1 - 0.08*alpha_mix*Pc, 1, 1, 1}.\n            # The spectral radius is always 1.0. Thus, it always fails.\n            failure_count_C += 1\n\n            # Scheme S: Spin-only mixing\n            Ms = np.diag([0.0, Ps, Ps, Ps])\n            Gs = I + alpha_mix * Ms @ B\n            eigenvalues_S = np.linalg.eigvals(Gs)\n            spectral_radius_S = np.max(np.abs(eigenvalues_S))\n            if spectral_radius_S = 1.0 - tolerance:\n                failure_count_S += 1\n\n            # Scheme F: Spinor-matrix mixing\n            Mf = np.diag([Pc, Ps, Ps, Ps])\n            Gf = I + alpha_mix * Mf @ B\n            eigenvalues_F = np.linalg.eigvals(Gf)\n            spectral_radius_F = np.max(np.abs(eigenvalues_F))\n            if spectral_radius_F = 1.0 - tolerance:\n                failure_count_F += 1\n\n    # Format and print the final result.\n    final_counts = [failure_count_C, failure_count_S, failure_count_F]\n    print(f\"[{','.join(map(str, final_counts))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何收敛计算之后，下一步是精确地控制我们想要研究的磁性构型，例如计算特定波矢的自旋螺旋或复杂拓扑磁结构的能量。本练习  将指导您在一个经典的Heisenberg模型上，通过实现拉格朗日乘子法来强制系统形成一个目标非线性磁序（例如$120^\\circ$自旋序）。这个实践揭示了“约束DFT”技术的核心原理，让您了解如何施加外部约束来探索复杂磁性系统的能量势垒和亚稳态。",
            "id": "3468712",
            "problem": "在一个包含三个格点的三角团簇上，使用 Lagrange 乘子实现一个最小的经典约束非共线自旋计算，以强制实现一个目标 $120^\\circ$ 自旋序。该系统由 $N=3$ 个经典自旋 $\\{\\mathbf{m}_i\\}_{i=1}^N$ 组成，每个自旋都是一个三维单位矢量，代表格点 $i$ 上的局域磁化方向。自旋位于一个三角形上，因此每个格点都与其他两个格點作为最近邻相互作用。物理模型是具有反铁磁交换耦合的经典各向同性 Heisenberg 模型。\n\n从以下基本定义开始：\n\n- 在此三角形上，经典 Heisenberg 能量（对于一般的交换 $J$）为\n$$\nE_{\\text{ex}} = \\frac{J}{2}\\sum_{i=1}^{3}\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_i\\cdot\\mathbf{m}_j,\n$$\n其中 $J0$ 对应反铁磁耦合，因子 $\\tfrac{1}{2}$ 是为了避免对自旋对进行重复计数。\n\n- 格点 $i$ 上的交换有效场定义为能量相对于 $\\mathbf{m}_i$ 的负梯度，\n$$\n\\mathbf{B}_i^{\\text{ex}} = -\\frac{\\partial E_{\\text{ex}}}{\\partial \\mathbf{m}_i} = -J\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_j.\n$$\n\n为强制实现目标非共线序，引入 Lagrange 乘子 $\\boldsymbol{\\lambda}_i$，它们与自旋偏离预设目标方向 $\\mathbf{m}_i^{(0)}$ 的偏差线性耦合。约束能量贡献为\n$$\nE_{\\lambda} = \\sum_{i=1}^{3}\\boldsymbol{\\lambda}_i\\cdot\\big(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\big),\n$$\n这产生了一个约束场贡献\n$$\n\\mathbf{B}_i^{\\text{constr}} = -\\frac{\\partial E_{\\lambda}}{\\partial \\mathbf{m}_i} = -\\boldsymbol{\\lambda}_i.\n$$\n因此总有效场为\n$$\n\\mathbf{B}_i^{\\text{eff}} = \\mathbf{B}_i^{\\text{ex}} + \\mathbf{B}_i^{\\text{constr}} = -J\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_j - \\boldsymbol{\\lambda}_i.\n$$\n\n三角形上的目标 $120^\\circ$ 自旋序由平面内的三个单位矢量指定\n$$\n\\mathbf{m}_1^{(0)}=\\big(\\cos 0,\\sin 0,0\\big),\\quad\n\\mathbf{m}_2^{(0)}=\\big(\\cos (2\\pi/3),\\sin (2\\pi/3),0\\big),\\quad\n\\mathbf{m}_3^{(0)}=\\big(\\cos (4\\pi/3),\\sin (4\\pi/3),0\\big),\n$$\n所有角度均以弧度表示。自旋的初始条件是将整个目标图案在平面内统一旋转角度 $\\phi_0$，即\n$$\n\\mathbf{m}_i^{(0,\\text{init})} = R_z(\\phi_0)\\,\\mathbf{m}_i^{(0)},\n$$\n其中 $R_z(\\phi)$ 是绕 $z$ 轴旋转角度 $\\phi$ 的旋转操作。初始 Lagrange 乘子为 $\\boldsymbol{\\lambda}_i=\\mathbf{0}$。\n\n实现以下迭代的原始-对偶方案，固定迭代次数为 $T$：\n\n1. 对于每个格点 $i$，使用上述定义计算交换场 $\\mathbf{B}_i^{\\text{ex}}$ 和有效场 $\\mathbf{B}_i^{\\text{eff}}$。\n\n2. 通过朝向有效场方向的阻尼对齐来更新自旋：\n$$\n\\tilde{\\mathbf{m}}_i = \n\\begin{cases}\n\\frac{\\mathbf{B}_i^{\\text{eff}}}{\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert},  \\text{if }\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert  \\varepsilon, \\\\\n\\mathbf{m}_i,  \\text{otherwise},\n\\end{cases}\n\\quad\n\\mathbf{m}_i \\leftarrow \\operatorname{normalize}\\Big((1-\\beta)\\,\\mathbf{m}_i + \\beta\\,\\tilde{\\mathbf{m}}_i\\Big),\n$$\n其中 $\\beta\\in(0,1]$ 是一个混合参数，$\\varepsilon0$ 是一个避免除以零的小阈值，且 $\\operatorname{normalize}(\\mathbf{v})=\\mathbf{v}/\\lVert\\mathbf{v}\\rVert$。\n\n3. 对 Lagrange 乘子执行对偶上升步骤，以强制施加约束：\n$$\n\\boldsymbol{\\lambda}_i \\leftarrow \\boldsymbol{\\lambda}_i + \\gamma\\left(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\right),\n$$\n其中 $\\gamma0$ 是对偶步长。\n\n完成 $T$ 次迭代后，评估每个格点上的残余力矩，\n$$\n\\boldsymbol{\\tau}_i = \\mathbf{m}_i \\times \\mathbf{B}_i^{\\text{eff}},\n$$\n并报告所有格点中的最大范数，\n$$\n\\tau_{\\max} = \\max_{i\\in\\{1,2,3\\}}\\lVert \\boldsymbol{\\tau}_i\\rVert.\n$$\n\n角度单位：所有角度，包括初始旋转角 $\\phi_0$，都必须解释为弧度。在此无量纲化的设置中，自旋或力矩大小没有物理单位；报告原始浮点数值。\n\n你的任务是编写一个完整、可运行的程序，该程序实现上述方案并为以下每个测试用例计算 $\\tau_{\\max}$ (每个测试都是从其自身的初始条件开始的独立运行)：\n\n- 测试 1：$J=1.0$, $\\beta=0.55$, $\\gamma=0.8$, $T=800$, $\\phi_0=\\pi/12$.\n- 测试 2：$J=0.0$, $\\beta=0.55$, $\\gamma=0.8$, $T=400$, $\\phi_0=\\pi/6$.\n- 测试 3：$J=10.0$, $\\beta=0.35$, $\\gamma=0.5$, $T=1200$, $\\phi_0=\\pi/18$.\n\n实现细节：\n\n- 使用如上定义的目标方向 $\\mathbf{m}_i^{(0)}$。\n- 对于每个测试用例，通过将 $\\mathbf{m}_i^{(0)}$ 绕 $z$ 轴旋转 $\\phi_0$ 来初始化 $\\mathbf{m}_i$。\n- 对所有 $i$ 初始化 $\\boldsymbol{\\lambda}_i=\\mathbf{0}$。\n- 在对齐步骤中使用小阈值 $\\varepsilon=10^{-12}$。\n- 在每次迭代中保持所有自旋归一化为单位长度。\n\n要求的最终输出格式：你的程序应生成单行输出，其中包含按上述测试顺序排列的结果，结果为用逗号分隔并括在方括号中的列表。每个数字的格式必须精确到小数点后六位。例如，包含三个结果的输出應如下所示：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3],\n$$\n其中每个 $\\text{result}_k$ 是一个小数点后恰好有六位数字的十进制字符串。输出必须是三个测试的 $\\tau_{\\max}$ 值。",
            "solution": "本问题的核心是实现一个原始-对偶迭代算法，用于求解一个有约束的经典海森堡模型。目标是在一个三格点的三角团簇上，通过拉格朗日乘子法强制实现一个特定的$120^\\circ$非共线自旋构型。该方法通过寻找一个拉格朗日泛函的鞍点来求解。该泛函 $L$ 包括系统的物理能量（海森堡交换能 $E_{\\text{ex}}$）和施加约束的能量项（$E_{\\lambda}$）：\n$$\nL(\\{\\mathbf{m}_i\\}, \\{\\boldsymbol{\\lambda}_i\\}) = E_{\\text{ex}}(\\{\\mathbf{m}_i\\}) + E_{\\lambda}(\\{\\mathbf{m}_i\\}, \\{\\boldsymbol{\\lambda}_i\\}) = \\frac{J}{2}\\sum_{i=1}^{3}\\sum_{\\substack{j=1\\\\ j\\neq i}}^{3}\\mathbf{m}_i\\cdot\\mathbf{m}_j + \\sum_{i=1}^{3}\\boldsymbol{\\lambda}_i\\cdot\\big(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\big)\n$$\n此处，$\\{\\mathbf{m}_i\\}_{i=1}^3$ 是单位长度的经典自旋矢量，$J$ 是交换耦合常数，$\\{\\mathbf{m}_i^{(0)}\\}_{i=1}^3$ 是目标自旋方向，而 $\\{\\boldsymbol{\\lambda}_i\\}_{i=1}^3$ 是拉格朗日乘子。解对应于此拉格朗日泛函的一个鞍点，在此鞍点上，泛函相对于原始变量 $\\mathbf{m}_i$ 取最小值，相对于对偶变量 $\\boldsymbol{\\lambda}_i$ 取最大值。\n\n所述的迭代算法是解决此类鞍点问题的标准方法。它包括在每次迭代中执行的两个主要步骤：原始更新（对自旋进行梯度下降）和对偶更新（对乘子进行梯度上升）。\n\n**1. 原始步骤：自旋更新**\n\n在有效磁场的影响下，通过更新自旋来降低系统能量。这个有效场 $\\mathbf{B}_i^{\\text{eff}}$ 是拉格朗日泛函相对于自旋矢量 $\\mathbf{m}_i$ 的负梯度：\n$$\n\\mathbf{B}_i^{\\text{eff}} = -\\frac{\\partial L}{\\partial \\mathbf{m}_i} = -\\frac{\\partial E_{\\text{ex}}}{\\partial \\mathbf{m}_i} - \\frac{\\partial E_{\\lambda}}{\\partial \\mathbf{m}_i} = \\mathbf{B}_i^{\\text{ex}} + \\mathbf{B}_i^{\\text{constr}}\n$$\n其中 $\\mathbf{B}_i^{\\text{ex}} = -J\\sum_{j \\neq i} \\mathbf{m}_j$ 是来自相邻自旋的交换场，而 $\\mathbf{B}_i^{\\text{constr}} = -\\boldsymbol{\\lambda}_i$ 是来自拉格朗日乘子的约束场。\n\n自旋更新通过朝向此有效场方向的阻尼对齐来执行。首先，确定目标方向：\n$$\n\\tilde{\\mathbf{m}}_i = \\frac{\\mathbf{B}_i^{\\text{eff}}}{\\lVert \\mathbf{B}_i^{\\text{eff}}\\rVert}\n$$\n如果 $\\mathbf{B}_i^{\\text{eff}}$ 接近于零，则使用一个小阈值 $\\varepsilon$ 来防止除以零。然后，使用混合方案更新自旋：\n$$\n\\mathbf{m}_i \\leftarrow \\operatorname{normalize}\\Big((1-\\beta)\\,\\mathbf{m}_i + \\beta\\,\\tilde{\\mathbf{m}}_i\\Big)\n$$\n参数 $\\beta \\in (0,1]$ 是一个混合因子，用于控制更新的步长以确保稳定性。`normalize` 操作对于强制施加自旋矢量的单位长度约束 $\\lVert\\mathbf{m}_i\\rVert=1$ 至关重要。这一步对应于在单位矢量流形上的梯度下降。\n\n**2. 对偶步骤：拉格朗日乘子更新**\n\n更新拉格朗日乘子以强制施加约束 $\\mathbf{m}_i = \\mathbf{m}_i^{(0)}$。这是通过对对偶变量进行梯度上升步骤来实现的：\n$$\n\\boldsymbol{\\lambda}_i \\leftarrow \\boldsymbol{\\lambda}_i + \\gamma\\left(\\mathbf{m}_i - \\mathbf{m}_i^{(0)}\\right)\n$$\n此处，$\\gamma  0$ 是一个步长参数。此更新将 $\\boldsymbol{\\lambda}_i$ 推向约束违反的方向 $(\\mathbf{m}_i - \\mathbf{m}_i^{(0)})$。在下一次迭代中，$\\boldsymbol{\\lambda}_i$ 的这种变化会修改约束场 $\\mathbf{B}_i^{\\text{constr}}$，施加一个校正“力”，从而将自旋 $\\mathbf{m}_i$ 推向其目标 $\\mathbf{m}_i^{(0)}$。\n\n**3. 收敛和最终输出**\n\n迭代过程重复固定的步数 $T$。静态平衡的特征是每个自旋上的力矩为零，即 $\\boldsymbol{\\tau}_i = \\mathbf{m}_i \\times \\mathbf{B}_i^{\\text{eff}} = \\mathbf{0}$，这种情况发生在每个自旋都与其有效场平行时。需要报告的量 $\\tau_{\\max} = \\max_i \\lVert\\boldsymbol{\\tau}_i\\rVert$ 用作衡量系统在 $T$ 次迭代后离此平衡状态有多近的度量。\n\n实现将首先根据给定的旋转角 $\\phi_0$ 初始化自旋，并将拉格朗日乘子初始化为零。然后，在一个循环中执行 $T$ 步的原始和对偶更新。最后，计算并报告最大残余力矩的范数。矢量运算将使用 `numpy` 库来处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a primal-dual scheme for a constrained classical Heisenberg model\n    on a 3-site triangular cluster and computes the maximum residual torque for\n    three different test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (J, beta, gamma, T, phi0)\n    test_cases = [\n        (1.0, 0.55, 0.8, 800, np.pi / 12.0),\n        (0.0, 0.55, 0.8, 400, np.pi / 6.0),\n        (10.0, 0.35, 0.5, 1200, np.pi / 18.0),\n    ]\n\n    # Small threshold for numerical stability\n    epsilon = 1e-12\n    \n    results = []\n\n    # Define the target 120-degree spin order in the xy-plane.\n    m_target = np.array([\n        [np.cos(0.0), np.sin(0.0), 0.0],\n        [np.cos(2.0 * np.pi / 3.0), np.sin(2.0 * np.pi / 3.0), 0.0],\n        [np.cos(4.0 * np.pi / 3.0), np.sin(4.0 * np.pi / 3.0), 0.0]\n    ])\n\n    for J, beta, gamma, T, phi0 in test_cases:\n        # ----- Initialization for the current test case -----\n        \n        # Initialize spins m_i by rotating the target pattern by phi0 around the z-axis.\n        c, s = np.cos(phi0), np.sin(phi0)\n        Rz = np.array([[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]])\n        # m is a (3, 3) array where m[i] is the spin vector for site i.\n        m = (Rz @ m_target.T).T\n        \n        # Initialize Lagrange multipliers lambda_i to zero.\n        # lam is a (3, 3) array where lam[i] is the lambda vector for site i.\n        lam = np.zeros_like(m)\n\n        # ----- Iterative Primal-Dual Scheme -----\n        for _ in range(T):\n            m_old = m.copy()\n            m_new = np.zeros_like(m)\n\n            # Primal step: Update spins m_i for all sites i=0,1,2.\n            # This is done using the spin configuration from the previous step (m_old).\n            for i in range(3):\n                # Sum of neighboring spins for site i\n                m_neighbors_sum = np.sum(m_old, axis=0) - m_old[i]\n                \n                # Exchange field\n                B_ex_i = -J * m_neighbors_sum\n                \n                # Effective field (includes constraining field -lambda_i)\n                B_eff_i = B_ex_i - lam[i]\n                \n                norm_B_eff = np.linalg.norm(B_eff_i)\n                \n                # Determine target direction for alignment\n                if norm_B_eff  epsilon:\n                    m_tilde_i = B_eff_i / norm_B_eff\n                else:\n                    m_tilde_i = m_old[i]\n                \n                # Damped update with mixing parameter beta\n                m_mixed = (1.0 - beta) * m_old[i] + beta * m_tilde_i\n                \n                # Normalize to maintain unit spin length\n                m_new[i] = m_mixed / np.linalg.norm(m_mixed)\n            \n            # Atomically update the spins for the next step\n            m = m_new\n\n            # Dual step: Update Lagrange multipliers lambda_i.\n            # This uses the newly computed spins 'm' to calculate the constraint violation.\n            lam += gamma * (m - m_target)\n\n        # ----- Final Calculation: Residual Torques -----\n        \n        tau_norms = []\n        for i in range(3):\n            # Recalculate the final effective field for each site\n            m_neighbors_sum = np.sum(m, axis=0) - m[i]\n            B_ex_i = -J * m_neighbors_sum\n            B_eff_i = B_ex_i - lam[i]\n            \n            # Calculate the torque tau_i = m_i x B_eff_i\n            tau_i = np.cross(m[i], B_eff_i)\n            \n            # Store the norm of the torque vector\n            tau_norms.append(np.linalg.norm(tau_i))\n            \n        # Find the maximum torque norm across all three sites\n        tau_max = np.max(tau_norms)\n        results.append(tau_max)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "第一性原理计算的最终目标之一是为更高尺度的模型提供可靠的材料参数。本练习  是一个综合性实践，它将教您如何将一系列自旋螺旋计算得到的总能量数据，与微磁学模型的能量展开式进行拟合。通过解决一个线性最小二乘问题，您将能从第一性原理计算结果中提取出关键的微磁学参数，如自旋刚度（$D$）、Dzyaloshinskii–Moriya相互作用（DMI）矢量（$\\mathbf{D}$）和磁晶各向异性（$K$），并比较不同交换关联泛函对这些参数的影响。",
            "id": "3468726",
            "problem": "给定一个金属铁磁体中平面自旋螺旋的综合第一性原理总能，这些总能是在三种交换关联近似下计算的：局域自旋密度近似 (LSDA)、广义梯度近似 (GGA) 和元-广义梯度近似 (meta-GGA)。对于小波矢，对称性和解析性意味着，对于传播矢量为 $\\mathbf{q}$、手性为 $s \\in \\{+1,-1\\}$ 的均匀自旋螺旋，其每个原子的能量具有以下最低阶展开式：\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,\\lvert \\mathbf{q} \\rvert^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q},\n$$\n其中 $E_{0}$ 是基准能量，$D$ 是标量自旋刚度，$\\mathbf{D}$ 是 Dzyaloshinskii–Moriya 相互作用 (DMI) 矢量，$K$ 是相对于易轴 $\\hat{\\mathbf{z}}$ 的单轴磁晶各向异性常数，$c$ 是各向异性贡献的取向因子。对于此处提供的数据，所有自旋螺旋在 $xy$ 平面内都是平面的，因此对于所有非共线螺旋，$c=1$。此外还提供了两个均匀（共线）态：一个与易轴 $\\hat{\\mathbf{z}}$ 对齐（此时 $c=0$），另一个垂直于 $\\hat{\\mathbf{z}}$（此时 $c=1$）。手性 $s=+1$ 表示右手旋转，$s=-1$ 表示左手旋转。单位如下：能量单位为毫电子伏特/原子 (meV/atom)，波矢单位为逆埃 ($\\text{\\AA}^{-1}$)，因此 $D$ 的单位为 $\\text{meV}\\cdot\\text{\\AA}^{2}$，$\\mathbf{D}$ 的单位为 $\\text{meV}\\cdot\\text{\\AA}$，$K$ 的单位为 meV/atom。\n\n任务。从上述展开式和不同不变性贡献的线性叠加原理出发，推导一个算法，该算法在给定一组测量值 $\\{(\\mathbf{q}_{i},s_{i},c_{i},E_{i})\\}$ 的情况下，通过对回归量 $\\{1,c_{i},\\lvert \\mathbf{q}_{i}\\rvert^{2}, s_{i} q_{i,x}, s_{i} q_{i,y}, s_{i} q_{i,z}\\}$ 求解一个线性最小二乘问题来估计参数 $\\{D,\\mathbf{D},K\\}$。然后，将该算法实现为一个完整的、可运行的程序，该程序如下文所述报告每个泛函的拟合参数。\n\n数据。对于每个泛函，均以元组列表 $(q_{x},q_{y},q_{z},s,c,E)$ 的形式给出数据。所有 $E$ 值的单位都是 meV/atom，所有 $q$ 分量的单位都是 $\\text{\\AA}^{-1}$。均匀态列在最后，其 $\\mathbf{q}=\\mathbf{0}$；对于这些状态，使用 $s=0$。\n\n- LSDA (局域自旋密度近似):\n  - 螺旋态：\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-117.71)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-117.89)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-117.83)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-117.77)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-118.448)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-118.448)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-118.67)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-118.73)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-119.069)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-119.087)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-119.171)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-119.093)$\n  - 均匀态：\n    - $(0.00,0.00,0.00,0,0,-120.00)$\n    - $(0.00,0.00,0.00,0,1,-119.60)$\n\n- GGA (广义梯度近似):\n  - 螺旋态：\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-147.63)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-147.87)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-147.70)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-147.80)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-148.47)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-148.47)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-148.665)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-148.835)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-149.131)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-149.209)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-149.273)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-149.187)$\n  - 均匀态：\n    - $(0.00,0.00,0.00,0,0,-150.00)$\n    - $(0.00,0.00,0.00,0,1,-149.75)\n\n- meta-GGA (元-广义梯度近似):\n  - 螺旋态：\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,+1,1,-197.76)$\n    - $(+\\,0.10,+\\,0.00,+\\,0.00,-1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,+1,1,-197.64)$\n    - $(+\\,0.00,+\\,0.10,+\\,0.00,-1,1,-197.76)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,+1,1,-198.468)$\n    - $(+\\,0.00,+\\,0.00,+\\,0.08,-1,1,-198.516)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,+1,1,-198.80)$\n    - $(+\\,0.05,+\\,0.05,+\\,0.00,-1,1,-198.80)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,+1,1,-199.244)$\n    - $(+\\,0.02,+\\,0.03,+\\,0.04,-1,1,-199.280)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,+1,1,-199.289)$\n    - $(-\\,0.04,+\\,0.01,+\\,0.03,-1,1,-199.367)$\n  - 均匀态：\n    - $(0.00,0.00,0.00,0,0,-200.00)$\n    - $(0.00,0.00,0.00,0,1,-199.90)\n\n要求。\n- 仅使用上述线性模型，并通过构建列分别对应于 $1$、$c$、$\\lvert \\mathbf{q} \\rvert^{2}$、$s\\,q_{x}$、$s\\,q_{y}$、$s\\,q_{z}$ 的设计矩阵，从第一性原理出发推导最小二乘估计量。\n- 对于每个泛函，估计并报告元组 $[D,D_{x},D_{y},D_{z},K]$，其中 $\\mathbf{D}=(D_{x},D_{y},D_{z})$。\n- 数值单位：\n  - 能量必须以 meV/atom 为单位处理。\n  - 波矢必须以 $\\text{\\AA}^{-1}$ 为单位处理。\n  - 报告 $D$ 的单位为 $\\text{meV}\\cdot\\text{\\AA}^{2}$，$\\mathbf{D}$ 的每个分量的单位为 $\\text{meV}\\cdot\\text{\\AA}$，$K$ 的单位为 meV/atom。\n- 本问题不使用角度单位。\n- 输出四舍五入：将报告的每个数字四舍五入到三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，每个内部列表按 LSDA、GGA、meta-GGA 的顺对应一个泛函。确切格式为：\n```\n[[D_{\\mathrm{LSDA}},D_{x,\\mathrm{LSDA}},D_{y,\\mathrm{LSDA}},D_{z,\\mathrm{LSDA}},K_{\\mathrm{LSDA}}],[D_{\\mathrm{GGA}},D_{x,\\mathrm{GGA}},D_{y,\\mathrm{GGA}},D_{z,\\mathrm{GGA}},K_{\\mathrm{GGA}}],[D_{\\mathrm{mGGA}},D_{x,\\mathrm{mGGA}},D_{y,\\mathrm{mGGA}},D_{z,\\mathrm{mGGA}},K_{\\mathrm{mGGA}}]]\n```\n  其中每个值都四舍五入到三位小数。例如，输出可能看起来像\n  $$\n  [[180.000,0.900,-0.300,0.000,0.400],[200.000,1.200,0.500,0.000,0.250],[220.000,-0.600,0.600,0.300,0.100]].\n  $$\n\n测试套件和覆盖范围。\n- LSDA 集包括一个 $q_{z}\\neq 0$ 但 $D_{z}=0$ 的方向，以及一个 s-无关能量的情况，以探测沿 z 轴 DMI 的缺失。\n- GGA 集对非零的 $D_{x}$ 和 $D_{y}$ 进行练习，包含两种手性和多个 $\\lvert \\mathbf{q}\\rvert$ 的大小，以稳健地约束 $D$。\n- meta-GGA 集包括非零的 $D_{z}$ 和一个 $\\mathbf{D}\\cdot\\mathbf{q}=0$ 的螺旋，以测试对零投影场景的敏感度。\n- $\\mathbf{q}=\\mathbf{0}$ 处 $c=0$ 和 $c=1$ 的均匀态允许独立识别 $K$ 并将其与截距 $E_{0}$ 分离。\n\n您提交的内容必须是一个单一的、完整的程序，该程序根据所提供的数据构建设计矩阵，求解最小二乘问题，并以上述确切格式打印结果，所有数字四舍五入到三位小数，不使用任何输入文件。程序必须是自包含的且可直接运行。",
            "solution": "为了从第一性原理总能数据中提取微磁参数，我们首先需要将所提供的能量模型与待求参数建立线性关系。对于平面自旋螺旋，每个原子的能量 $E$ 作为其波矢 $\\mathbf{q}$、手性 $s$ 和各向异性取向因子 $c$ 的函数，其模型为：\n$$\nE(\\mathbf{q},s,c)=E_{0} + K\\,c + D\\,\\lvert \\mathbf{q} \\rvert^{2} + s\\,\\mathbf{D}\\cdot\\mathbf{q}\n$$\n其中 $E_{0}$ 是一个基准能量，$K$ 是单轴磁晶各向异性常数，$D$ 是标量自旋刚度，$\\mathbf{D}$ 是 Dzyaloshinskii–Moriya 相互作用 (DMI) 矢量。任务是估计参数 $\\{D, \\mathbf{D}, K\\}$。\n\n首先，我们展开 DMI 项 $s\\,\\mathbf{D}\\cdot\\mathbf{q}$。设 $\\mathbf{D} = (D_{x}, D_{y}, D_{z})$ 和 $\\mathbf{q} = (q_{x}, q_{y}, q_{z})$，该项变为 $s(D_{x}q_{x} + D_{y}q_{y} + D_{z}q_{z})$。将其代入能量模型，揭示了其关于参数的线性结构：\n$$\nE(\\mathbf{q},s,c) = E_{0}(1) + K(c) + D(\\lvert\\mathbf{q}\\rvert^{2}) + D_{x}(s q_{x}) + D_{y}(s q_{y}) + D_{z}(s q_{z})\n$$\n括号中的项是回归变量，而 $\\{E_{0}, K, D, D_{x}, D_{y}, D_{z}\\}$ 是待定系数。给定一组 $N$ 个测量值 $\\{(\\mathbf{q}_{i}, s_{i}, c_{i}, E_{i})\\}_{i=1}^{N}$，这就定义了一个线性方程组。该系统适用于线性最小二乘分析。\n\n我们用矩阵表示法将问题表述为 $\\mathbf{y} \\approx \\mathbf{X}\\boldsymbol{\\beta}$，其中：\n- $\\mathbf{y}$ 是观测能量的 $N \\times 1$ 列向量：$\\mathbf{y} = [E_{1}, E_{2}, \\dots, E_{N}]^T$。\n- $\\boldsymbol{\\beta}$ 是未知模型参数的 $M \\times 1$ 列向量。对于此问题，有 $M=6$ 个参数。我们根据问题陈述中指定的回归量顺序定义 $\\boldsymbol{\\beta}$：$\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5]^T = [E_0, K, D, D_x, D_y, D_z]^T$。\n- $\\mathbf{X}$ 是 $N \\times M$ 的设计矩阵。$\\mathbf{X}$ 的每一行 $i$ 由第 $i$ 个数据点构成，列对应于回归量 $\\{1, c, \\lvert\\mathbf{q}\\rvert^{2}, s q_{x}, s q_{y}, s q_{z}\\}$。具体来说，第 $i$ 行是：\n$$\n\\mathbf{X}_{i,:} = \\begin{bmatrix} 1  c_{i}  \\lvert\\mathbf{q}_{i}\\rvert^{2}  s_{i}q_{i,x}  s_{i}q_{i,y}  s_{i}q_{i,z} \\end{bmatrix}\n$$\n其中 $\\lvert\\mathbf{q}_{i}\\rvert^{2} = q_{i,x}^2 + q_{i,y}^2 + q_{i,z}^2$。\n\n线性最小二乘法旨在寻找使残差平方和 $S = \\sum_{i=1}^{N} (E_i - \\mathbf{X}_{i,:}\\boldsymbol{\\beta})^2 = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})^T (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta})$ 最小化的参数矢量 $\\hat{\\boldsymbol{\\beta}}$。最小化 $S$ 的解可以通过求解正规方程得到：\n$$\n(\\mathbf{X}^T \\mathbf{X}) \\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设 $\\mathbf{X}$ 的列是线性无关的（对于一组设计良好的测量，这通常成立），则矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的。参数矢量的唯一最小二乘估计则为：\n$$\n\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n实现的算法将对每个泛函的数据集执行以下操作：\n1.  从提供的元组数据 $(q_{x}, q_{y}, q_{z}, s, c, E)$ 构建设计矩阵 $\\mathbf{X}$ 和观测向量 $\\mathbf{y}$。\n2.  通过求解线性最小二乘问题，数值计算参数矢量 $\\hat{\\boldsymbol{\\beta}}$。最好使用稳定的数值程序，例如基于 QR 分解或奇异值分解 (SVD) 的程序，这比显式计算 $\\mathbf{X}^T \\mathbf{X}$ 的逆矩阵更稳健。\n3.  所得矢量 $\\hat{\\boldsymbol{\\beta}} = [\\hat{\\beta}_0, \\hat{\\beta}_1, \\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5]^T$ 的分量是物理参数的估计值：\n    - 各向异性常数 $K \\approx \\hat{\\beta}_1$\n    - 自旋刚度 $D \\approx \\hat{\\beta}_2$\n    - DMI 矢量分量 $\\{D_x, D_y, D_z\\} \\approx \\{\\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5\\}$\n4.  从 $\\hat{\\boldsymbol{\\beta}}$ 的分量中组装所需的输出元组 $[D, D_x, D_y, D_z, K]$，这对应于 $[\\hat{\\beta}_2, \\hat{\\beta}_3, \\hat{\\beta}_4, \\hat{\\beta}_5, \\hat{\\beta}_1]$。\n5.  将最终值四舍五入到三位小数，并按指定格式进行格式化。\n此过程基于所提供的理论模型，从能量数据中系统地推导出物理参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Fits micromagnetic parameters to synthetic first-principles energy data\n    using linear least-squares regression and prints the results.\n    \"\"\"\n    \n    # Data sets provided in the problem statement.\n    # Each tuple is (qx, qy, qz, s, c, E).\n    lsda_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -117.71),\n        (0.10, 0.00, 0.00, -1, 1, -117.89),\n        (0.00, 0.10, 0.00, 1, 1, -117.83),\n        (0.00, 0.10, 0.00, -1, 1, -117.77),\n        (0.00, 0.00, 0.08, 1, 1, -118.448),\n        (0.00, 0.00, 0.08, -1, 1, -118.448),\n        (0.05, 0.05, 0.00, 1, 1, -118.67),\n        (0.05, 0.05, 0.00, -1, 1, -118.73),\n        (0.02, 0.03, 0.04, 1, 1, -119.069),\n        (0.02, 0.03, 0.04, -1, 1, -119.087),\n        (-0.04, 0.01, 0.03, 1, 1, -119.171),\n        (-0.04, 0.01, 0.03, -1, 1, -119.093),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -120.00),\n        (0.00, 0.00, 0.00, 0, 1, -119.60)\n    ]\n\n    gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -147.63),\n        (0.10, 0.00, 0.00, -1, 1, -147.87),\n        (0.00, 0.10, 0.00, 1, 1, -147.70),\n        (0.00, 0.10, 0.00, -1, 1, -147.80),\n        (0.00, 0.00, 0.08, 1, 1, -148.47),\n        (0.00, 0.00, 0.08, -1, 1, -148.47),\n        (0.05, 0.05, 0.00, 1, 1, -148.665),\n        (0.05, 0.05, 0.00, -1, 1, -148.835),\n        (0.02, 0.03, 0.04, 1, 1, -149.131),\n        (0.02, 0.03, 0.04, -1, 1, -149.209),\n        (-0.04, 0.01, 0.03, 1, 1, -149.273),\n        (-0.04, 0.01, 0.03, -1, 1, -149.187),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -150.00),\n        (0.00, 0.00, 0.00, 0, 1, -149.75)\n    ]\n\n    meta_gga_data = [\n        # Spirals\n        (0.10, 0.00, 0.00, 1, 1, -197.76),\n        (0.10, 0.00, 0.00, -1, 1, -197.64),\n        (0.00, 0.10, 0.00, 1, 1, -197.64),\n        (0.00, 0.10, 0.00, -1, 1, -197.76),\n        (0.00, 0.00, 0.08, 1, 1, -198.468),\n        (0.00, 0.00, 0.08, -1, 1, -198.516),\n        (0.05, 0.05, 0.00, 1, 1, -198.80),\n        (0.05, 0.05, 0.00, -1, 1, -198.80),\n        (0.02, 0.03, 0.04, 1, 1, -199.244),\n        (0.02, 0.03, 0.04, -1, 1, -199.280),\n        (-0.04, 0.01, 0.03, 1, 1, -199.289),\n        (-0.04, 0.01, 0.03, -1, 1, -199.367),\n        # Uniform\n        (0.00, 0.00, 0.00, 0, 0, -200.00),\n        (0.00, 0.00, 0.00, 0, 1, -199.90)\n    ]\n\n    all_datasets = [lsda_data, gga_data, meta_gga_data]\n    overall_results = []\n\n    for dataset in all_datasets:\n        num_points = len(dataset)\n        # Design matrix X: columns for [1, c, |q|^2, s*qx, s*qy, s*qz]\n        X = np.zeros((num_points, 6))\n        # Observation vector y: energies E\n        y = np.zeros(num_points)\n\n        for i, point in enumerate(dataset):\n            qx, qy, qz, s, c, E = point\n            q_sq = qx**2 + qy**2 + qz**2\n            \n            X[i, 0] = 1.0       # Corresponds to E0 (intercept)\n            X[i, 1] = float(c)  # Corresponds to K\n            X[i, 2] = q_sq      # Corresponds to D\n            X[i, 3] = s * qx    # Corresponds to Dx\n            X[i, 4] = s * qy    # Corresponds to Dy\n            X[i, 5] = s * qz    # Corresponds to Dz\n            \n            y[i] = E\n\n        # Solve the linear least-squares problem X*p = y for p\n        params, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # Extract parameters according to the model: E = E0 + K*c + D*|q|^2 + ...\n        # params[0] = E0\n        K = params[1]\n        D = params[2]\n        Dx = params[3]\n        Dy = params[4]\n        Dz = params[5]\n        \n        # Assemble the results in the required order: [D, Dx, Dy, Dz, K]\n        result_list = [D, Dx, Dy, Dz, K]\n        overall_results.append(result_list)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to three decimal places.\n    output_parts = []\n    for res_list in overall_results:\n        formatted_numbers = [f\"{num:.3f}\" for num in res_list]\n        output_parts.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}