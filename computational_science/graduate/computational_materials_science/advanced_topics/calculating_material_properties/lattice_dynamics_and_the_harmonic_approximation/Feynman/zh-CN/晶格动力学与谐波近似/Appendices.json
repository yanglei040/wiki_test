{
    "hands_on_practices": [
        {
            "introduction": "通常，我们使用一组已知的原子间力常数来计算声子色散。本练习反其道而行之，解决一个*逆问题*：我们如何从一个已知的色散曲线（可能来自实验测量或更复杂的模型计算）中推断出底层的力常数？本练习将指导您为一个双原子链构建一个简单的、有物理动机的谐振子模型，并拟合其参数以再现目标色散关系，从而向您介绍模型参数化的强大概念以及解唯一性的关键问题。",
            "id": "3460352",
            "problem": "您的任务是在谐振子近似下，为一维双原子链建立并求解一个晶格动力学中的反问题。您需要从第一性原理出发建立正向模型，然后构建一个优化程序，以推断出能够再现目标声子色散的最小实空间力常数集。最后，您需要量化解的局部唯一性，并讨论等谱晶格（即不同的实空间力常数产生相同的色散）的可能性。\n\n请使用以下具有物理动机的设置和约束：\n\n- 系统是一个一维双原子晶格，每个原胞有两个原子，标记为子晶格 $A$ 和 $B$，晶格常数为 $a$。位移自由度是沿链方向的标量。\n- 适用谐振子近似：位移很小，势能是位移的二次函数。运动方程源自牛顿第二定律和一个线性的力常数算符。\n- 通过声学求和规则强制平移不变性，使得声学支满足 $\\omega(\\mathbf{q}=\\mathbf{0}) = 0$，即在 $\\mathbf{q}=\\mathbf{0}$ 处有一个零频模式。\n- 使用布洛赫定理推导倒易空间中的动力学矩阵。声子问题是一个质量加权动力学矩阵的厄米本征问题，其本征值为每个支 $s$ 的频率平方 $\\omega_s^2(q)$。\n\n需使用的最小实空间模型：\n\n- 最近邻跨子晶格弹簧：每个 $A$ 原子通过弹簧常数 $K_1 \\ge 0$ 与其左右最近的 $B$ 邻居耦合。\n- 次近邻同子晶格弹簧：$A$ 与 $A$ 之间的弹簧常数为 $K_{2A} \\ge 0$，$B$ 与 $B$ 之间的弹簧常数为 $K_{2B} \\ge 0$。\n- 所有其他力常数均为零。在位力常数不是独立的参数：它们必须被定义以满足声学求和规则。\n\n基本原理和推导约束：\n\n- 从牛顿第二定律和胡克定律出发，推导倒易空间动力学矩阵。设 $u_{\\alpha,n}(t)$ 为在原胞索引 $n \\in \\mathbb{Z}$ 中子晶格 $\\alpha \\in \\{A,B\\}$ 的位移。线性运动方程必须由实空间力常数 $\\Phi_{\\alpha\\beta}(R)$ 产生，并且必须使用布洛赫拟设 $u_{\\alpha,n}(t) = U_\\alpha \\exp(i q n a - i \\omega t)$ 来获得质量加权动力学矩阵 $D(q)$ 的本征问题，其中 $D(q)$ 依赖于参数 $K_1$、$K_{2A}$ 和 $K_{2B}$ 以及质量 $m_A$ 和 $m_B$。\n- 倒易空间中力常数矩阵的元素必须与指定的实空间连接性一致，包括来自相对基矢位置的正确相位因子，并且必须满足声学求和规则。\n\n反问题：\n\n- 给定由离散波矢 $q$ 处的两个支 $s \\in \\{\\text{acoustic}, \\text{optic}\\}$ 的声子频率平方 $\\omega_s^2(q)$ 组成的目标数据，推断出在最小二乘意义下最能再现目标的最小参数集 $\\theta = (K_1, K_{2A}, K_{2B})$。使用质量加权动力学矩阵的本征值作为从 $\\theta$ 到 $\\{\\omega_s^2(q)\\}$ 的正向映射。\n- 在拟合过程中强制非负性边界 $K_1 \\ge 0$，$K_{2A} \\ge 0$，$K_{2B} \\ge 0$。\n- 将晶格常数视为 $a = 1$，这样 $q$ 携带无量纲相位 $q a = q$；所有角度均以弧度为单位。在整个过程中使用无量纲单位，因此不需要物理单位转换；报告的数值为无单位的纯数字。\n\n量化唯一性和等谱性：\n\n- 将残差向量 $r(\\theta)$ 定义为，对于所有采样的波矢 $q$，模型与目标频率平方之差的堆叠，其中每个 $q$ 处的支按 $\\omega_s^2(q)$ 升序排列。\n- 在拟合解 $\\theta^\\star$ 处计算数值雅可比矩阵 $J(\\theta^\\star) = \\partial r / \\partial \\theta$。使用带有小步长的有限差分法。通过 $J(\\theta^\\star)$ 的数值秩来量化局部唯一性：满列秩表示一个局部唯一解，而秩亏则表示参数空间中存在一个连续的等谱或近等谱解族。\n- 讨论全局非唯一性（等谱性）也可能由离散对称性（例如，交换相同的子晶格）引起，而局部秩在非对称点可能无法完全捕捉到这一点。\n\n测试套件：\n\n对于下面的每个测试用例，使用所述的“真实”参数 $(m_A, m_B, K_1, K_{2A}, K_{2B})$、晶格常数 $a = 1$ 以及一组共同的波矢 $q \\in \\{0, 0.3\\pi, 0.6\\pi, 0.9\\pi, \\pi\\}$（均为弧度）通过正向模型生成目标色散。然后，在给定质量和目标色散的情况下，拟合 $(K_1, K_{2A}, K_{2B})$。\n\n- 测试用例 $1$（通用、非对称的“理想路径”）：质量 $m_A = 1.0$，$m_B = 2.0$；参数 $K_1 = 10.0$，$K_{2A} = 1.5$，$K_{2B} = 0.8$。\n- 测试用例 $2$（具有增强对称性的边界情况）：质量 $m_A = 1.0$，$m_B = 1.0$；参数 $K_1 = 12.0$，$K_{2A} = 2.5$，$K_{2B} = 2.5$。\n- 测试用例 $3$（同子晶格耦合消失的边缘案例）：质量 $m_A = 1.5$，$m_B = 0.9$；参数 $K_1 = 7.0$，$K_{2A} = 0.0$，$K_{2B} = 0.0$。\n\n数值和算法要求：\n\n- 实现正向模型，以计算作为由实空间力常数构建的质量加权动力学矩阵 $D(q)$ 的本征值的频率平方支 $\\omega_s^2(q)$。在每个 $q$ 处，按 $\\omega_s^2(q)$ 的升序对分支进行排序。\n- 实现一个带边界约束的非线性最小二乘拟合，从目标 $\\omega_s^2(q)$ 数据估计 $(K_1, K_{2A}, K_{2B})$。\n- 在拟合参数处通过中心有限差分法计算雅可比矩阵，并确定其数值秩。\n- 将局部唯一性报告为一个整数标志：如果雅可比矩阵具有满列秩，则为 $1$，否则为 $0$。\n\n要求的最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个列表，每个测试用例对应一个条目。每个条目必须是 $[K_1^\\star, K_{2A}^\\star, K_{2B}^\\star, U]$ 形式的列表，其中 $K_1^\\star$、$K_{2A}^\\star$ 和 $K_{2B}^\\star$ 是四舍五入到六位小数的拟合参数，$U$ 是唯一性标志，为整数 $0$ 或 $1$。总输出必须是精确格式的一行：\n- 示例示意图：$[[K_{1,1}^\\star,K_{2A,1}^\\star,K_{2B,1}^\\star,U_1],[K_{1,2}^\\star,K_{2A,2}^\\star,K_{2B,2}^\\star,U_2],[K_{1,3}^\\star,K_{2A,3}^\\star,K_{2B,3}^\\star,U_3]]$。\n\n实现说明：\n\n- 角度 $q$ 必须以弧度为单位。\n- 仅使用确定性计算；不要引入随机性。\n- 所有报告的数值根据设计都是无单位的。",
            "solution": "该问题被评估为有效。它是一项定义明确、科学上合理且自成一体的计算材料科学任务，要求建立并求解晶格动力学中的一个反问题。其设置、约束和测试用例都经过了形式化的规定，并与固态物理学的原理相符。\n\n### 1. 理论框架：正向问题\n\n正向问题是在给定一组模型参数的情况下，确定声子色散关系 $\\omega_s(q)$。我们考虑一个一维双原子链，其晶格常数为 $a$，为保持量纲一致性，我们设 $a=1$。每个原胞包含两个原子，标记为 $A$ 和 $B$，质量分别为 $m_A$ 和 $m_B$。它们在原胞 $n$ 内的平衡位置由 $x_{n,A} = na$ 和 $x_{n,B} = na + a/2$ 指定。我们将其沿链方向相对于这些位置的标量位移表示为 $u_{n,A}$ 和 $u_{n,B}$。\n\n谐波近似假设势能是位移的二次函数，从而导出线性运动方程（牛顿第二定律与胡克定律）。指定的实空间相互作用如下：\n1.  一个常数为 $K_1$ 的弹簧连接每个原子与其两个最近邻的另一子晶格原子。对于原胞 $n$ 中的原子 $A$，这对应于与原胞 $n$ 和 $n-1$ 中的原子 $B$ 的相互作用。\n2.  一个常数为 $K_{2A}$ 的弹簧连接原子 $A$ 与其两个最近邻的同子晶格原子（在相邻的原胞 $n-1$ 和 $n+1$ 中）。\n3.  一个常数为 $K_{2B}$ 的弹簧连接原子 $B$ 与其两个最近邻的同子晶格原子（在相邻的原胞 $n-1$ 和 $n+1$ 中）。\n\n根据这些相互作用，作用在原胞 $n$ 中原子 $A$ 和 $B$ 上的力为：\n$$F_{n,A} = K_1(u_{n,B} - u_{n,A}) + K_1(u_{n-1,B} - u_{n,A}) + K_{2A}(u_{n+1,A} - u_{n,A}) + K_{2A}(u_{n-1,A} - u_{n,A})$$\n$$F_{n,B} = K_1(u_{n+1,A} - u_{n,B}) + K_1(u_{n,A} - u_{n,B}) + K_{2B}(u_{n+1,B} - u_{n,B}) + K_{2B}(u_{n-1,B} - u_{n,B})$$\n\n运动方程为 $m_\\alpha \\ddot{u}_{n,\\alpha} = F_{n,\\alpha}$。我们寻求由布洛赫定理决定的平面波解，形式如下：\n$$u_{n,\\alpha}(t) = \\frac{U_\\alpha}{\\sqrt{m_\\alpha}} e^{i(q x_{n,\\alpha} - \\omega t)}$$\n质量加权因子 $1/\\sqrt{m_\\alpha}$ 是常规做法，它直接导向质量加权动力学矩阵。将布洛赫拟设代入运动方程，得到一个 $2 \\times 2$ 的本征问题：\n$$\\omega^2 \\begin{pmatrix} U_A \\\\ U_B \\end{pmatrix} = D(q) \\begin{pmatrix} U_A \\\\ U_B \\end{pmatrix}$$\n其中 $D(q)$ 是 $2 \\times 2$ 的质量加权动力学矩阵。其元素通过对实空间力常数矩阵 $\\Phi_{\\alpha \\beta}(n-n')$ 进行傅里叶变换得到。动力学矩阵元素的一般表达式为：\n$$D_{\\alpha\\beta}(q) = \\frac{1}{\\sqrt{m_\\alpha m_\\beta}} \\sum_{n'} \\Phi_{0\\alpha, n'\\beta} e^{iq(x_{n',\\beta} - x_{0,\\alpha})}$$\n使用指定的相互作用和原子位置（对于 $a=1$，有 $x_{n,A}=n$, $x_{n,B}=n+1/2$），我们找到力常数（例如 $\\Phi_{0A, 0B} = -K_1$, $\\Phi_{0A, 1A} = -K_{2A}$）并计算动力学矩阵的元素：\n$$D_{AA}(q) = \\frac{1}{m_A} \\left( 2K_1 + 2K_{2A} - 2K_{2A}\\cos(q) \\right) = \\frac{2K_1 + 4K_{2A}\\sin^2(q/2)}{m_A}$$\n$$D_{BB}(q) = \\frac{1}{m_B} \\left( 2K_1 + 2K_{2B} - 2K_{2B}\\cos(q) \\right) = \\frac{2K_1 + 4K_{2B}\\sin^2(q/2)}{m_B}$$\n$$D_{AB}(q) = \\frac{1}{\\sqrt{m_Am_B}} \\left( -K_1 e^{iq/2} - K_1 e^{-iq/2} \\right) = \\frac{-2K_1\\cos(q/2)}{\\sqrt{m_Am_B}}$$\n在位力常数（例如 $\\Phi_{0A,0A}$）通过声学求和规则 $\\sum_{n',\\beta} \\Phi_{0\\alpha, n'\\beta} = 0$ 隐式定义，这确保了均匀平移是零能运动。我们的推导遵循了此规则，使得 $D_{\\alpha\\beta}(q=0)$ 有一个零本征值，对应于声学支的 $\\omega^2(q=0)=0$。由于 $D_{AB}(q)$ 是实数，所以 $D_{BA}(q) = D_{AB}(q)$，动力学矩阵 $D(q)$ 对于所有 $q$ 都是实对称的。\n\n声子频率平方 $\\omega_s^2(q)$ 是 $D(q)$ 的两个本征值。它们是特征方程 $\\det(D(q) - \\omega^2 I)=0$ 的根，由下式给出：\n$$\\omega^2_{1,2}(q) = \\frac{D_{AA}(q) + D_{BB}(q)}{2} \\pm \\sqrt{\\left(\\frac{D_{AA}(q) - D_{BB}(q)}{2}\\right)^2 + D_{AB}(q)^2}$$\n较低的支（带负号）是声学支，较高的支是光学支。这些表达式构成了正向模型 $F(\\theta; q, m_A, m_B)$，其中 $\\theta = (K_1, K_{2A}, K_{2B})$ 是参数向量。\n\n### 2. 反问题与唯一性\n\n反问题是在给定一组目标色散数据 $\\{\\omega_{s, \\text{target}}^2(q_i)\\}$ 的情况下，估计参数向量 $\\theta$。我们将其表述为一个带边界约束的非线性最小二乘问题。目标是找到 $\\theta^\\star$，以最小化残差平方和：\n$$\\theta^\\star = \\arg\\min_{\\theta \\ge 0} \\sum_{i,s} \\left[ \\omega_s^2(q_i; \\theta) - \\omega_{s, \\text{target}}^2(q_i) \\right]^2$$\n并受制于物理约束 $K_1 \\ge 0$，$K_{2A} \\ge 0$，$K_{2B} \\ge 0$。\n\n解 $\\theta^\\star$ 的唯一性至关重要。\n**局部唯一性**：如果代价函数有一个明确定义的最小值，则解是局部唯一的，这意味着数据的微小扰动会导致解参数的微小、可预测的扰动。这通过分析在最优解 $\\theta^\\star$ 处的残差向量 $r(\\theta)$ 的雅可比矩阵来评估。残差向量由堆叠的差值 $r_{i,s}(\\theta) = \\omega_s^2(q_i; \\theta) - \\omega_{s, \\text{target}}^2(q_i)$ 构成。雅可比矩阵是一个元素为 $J_{k,j} = \\partial r_k / \\partial \\theta_j$ 的矩阵 $J(\\theta^\\star)$。对于我们这个 3 参数问题，局部唯一性要求雅可比矩阵具有满列秩，即 $\\text{rank}(J(\\theta^\\star)) = 3$。秩亏意味着并非所有参数都能从数据中独立确定，这表明代价函数景观中存在“平坦方向”。\n\n**全局唯一性与等谱性**：产生相同谱 $F(\\theta_1) = F(\\theta_2)$ 的不同参数集 $\\theta_1 \\ne \\theta_2$ 称为等谱。全局非唯一性可能源于连续的解族（秩亏的雅可比矩阵会检测到），也可能源于离散对称性。在我们的模型中，如果质量相同（$m_A = m_B$），系统就具有子晶格交换对称性。交换标签 $A \\leftrightarrow B$ 等效于交换参数 $K_{2A} \\leftrightarrow K_{2B}$。因此，对于 $m_A = m_B$，参数集 $(K_1, K_{2A}, K_{2B})$ 和 $(K_1, K_{2B}, K_{2A})$ 将产生相同的声子谱。如果拟合由真实参数 $(K_1, \\alpha, \\beta)$（其中 $\\alpha \\neq \\beta$）生成的数据，则 $(K_1, \\alpha, \\beta)$ 和 $(K_1, \\beta, \\alpha)$ 都是有效的全局解。\n\n对于测试用例 2，其中 $m_A = m_B$ 且真实参数为 $K_{2A} = K_{2B}$，解位于参数空间的对称线上。在该线上的任何一点，$K_{2A}$ 的微小变化对谱的影响与 $K_{2B}$ 的相同变化相同。因此，雅可比矩阵的相应列是相同的，使其秩亏（$\\text{rank}=2$）。这表明存在局部非唯一性：只有和 $K_{2A}+K_{2B}$ 是良定的，而单个值则不是。\n\n### 3. 算法实现\n\n该解决方案通过一个 Python 脚本实现，利用 `numpy` 进行数值计算，`scipy.optimize.least_squares` 进行拟合。\n\n1.  **正向模型**：函数 `_forward_model(params, masses, q_points)` 实现了 $D(q)$ 的解析表达式，并使用 `numpy.linalg.eigvalsh` 计算其本征值 $\\omega_s^2(q)$。此函数返回一个扁平化的数组，其中包含所有给定 $q$ 点的已排序频率平方。\n2.  **反问题求解器**：对每个测试用例，首先使用真实参数生成目标色散数据。然后为优化器定义一个残差函数，该函数计算模型输出与目标数据之间的差异。接着，使用初始猜测、边界 $([0,0,0], [\\infty, \\infty, \\infty])$ 和适用于带边界约束问题的 `trf` (信赖域反射) 方法调用 `scipy.optimize.least_squares`。\n3.  **唯一性量化**：获得拟合参数 $\\theta^\\star$ 后，通过中心有限差分法数值计算雅可比矩阵 $J(\\theta^\\star)$。使用 `numpy.linalg.matrix_rank` 确定该矩阵的秩。如果秩等于参数数量（$3$），则唯一性标志 $U$ 设为 $1$，否则为 $0$。\n4.  **输出生成**：为每个测试用例收集最终拟合参数（四舍五入到六位小数）和整数唯一性标志，并将其格式化为指定的字符串表示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef _forward_model(params, masses, q_points):\n    \"\"\"\n    Computes the squared phonon frequencies for the 1D diatomic chain.\n    This is the forward model.\n\n    Args:\n        params (tuple): A tuple of (K1, K2A, K2B) force constants.\n        masses (tuple): A tuple of (m_A, m_B) masses.\n        q_points (np.ndarray): Array of wavevectors in radians.\n\n    Returns:\n        np.ndarray: A flattened array of squared frequencies, with branches\n                    sorted in ascending order for each q.\n    \"\"\"\n    K1, K2A, K2B = params\n    m_A, m_B = masses\n    \n    omega_sq_all = []\n    for q in q_points:\n        # The dynamical matrix is real and symmetric.\n        D = np.zeros((2, 2), dtype=float)\n        \n        # Diagonal elements\n        D[0, 0] = (2 * K1 + 4 * K2A * np.sin(q / 2)**2) / m_A\n        D[1, 1] = (2 * K1 + 4 * K2B * np.sin(q / 2)**2) / m_B\n        \n        # Off-diagonal elements\n        off_diag_term = -2 * K1 * np.cos(q / 2) / np.sqrt(m_A * m_B)\n        D[0, 1] = off_diag_term\n        D[1, 0] = off_diag_term \n        \n        # Eigenvalues of the mass-weighted dynamical matrix are the squared frequencies.\n        # np.linalg.eigvalsh is efficient for Hermitian/symmetric matrices and returns\n        # sorted real eigenvalues.\n        omega_sq_branches = np.linalg.eigvalsh(D)\n        omega_sq_all.extend(omega_sq_branches)\n        \n    return np.array(omega_sq_all)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases for the inverse problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1: General asymmetric case\n        {'masses': (1.0, 2.0), 'true_params': (10.0, 1.5, 0.8)},\n        # Test case 2: Symmetric case with identical masses and same-sublattice springs\n        {'masses': (1.0, 1.0), 'true_params': (12.0, 2.5, 2.5)},\n        # Test case 3: Edge case with zero same-sublattice springs\n        {'masses': (1.5, 0.9), 'true_params': (7.0, 0.0, 0.0)},\n    ]\n    \n    # Common set of wavevectors for all test cases\n    q_points = np.array([0.0, 0.3, 0.6, 0.9, 1.0]) * np.pi\n    \n    results = []\n    \n    for case in test_cases:\n        masses = case['masses']\n        true_params = case['true_params']\n        num_params = len(true_params)\n        \n        # 1. Generate target data using the forward model with true parameters\n        target_omega_sq = _forward_model(true_params, masses, q_points)\n        \n        # 2. Define the residual function for the least-squares optimizer\n        def residuals(params, masses_arg, q_points_arg, target_arg):\n            model_omega_sq = _forward_model(params, masses_arg, q_points_arg)\n            return model_omega_sq - target_arg\n            \n        # 3. Perform the bound-constrained nonlinear least-squares fit\n        initial_guess = np.array([5.0, 1.0, 1.0])\n        bounds = ([0, 0, 0], [np.inf, np.inf, np.inf])\n        \n        fit_result = least_squares(\n            residuals,\n            initial_guess,\n            args=(masses, q_points, target_omega_sq),\n            bounds=bounds,\n            method='trf',\n            ftol=1e-12, xtol=1e-12, gtol=1e-12\n        )\n        \n        fitted_params = fit_result.x\n        \n        # 4. Compute the Jacobian of the residual vector at the solution\n        #    to assess local uniqueness.\n        eps = 1e-7 # Step size for central finite differences\n        \n        # We need the Jacobian of the forward model, not the residuals since the\n        # target data is constant. J_ij = d(model_i)/d(param_j)\n        jac = np.zeros((len(target_omega_sq), num_params))\n        \n        for i in range(num_params):\n            p_plus = np.copy(fitted_params)\n            p_minus = np.copy(fitted_params)\n            p_plus[i] += eps\n            p_minus[i] -= eps\n            \n            # Since residual = model - target, d(residual)/dp = d(model)/dp\n            r_plus = residuals(p_plus, masses, q_points, target_omega_sq)\n            r_minus = residuals(p_minus, masses, q_points, target_omega_sq)\n            \n            jac[:, i] = (r_plus - r_minus) / (2 * eps)\n            \n        # 5. Determine local uniqueness flag from the Jacobian's rank\n        rank = np.linalg.matrix_rank(jac)\n        # Full column rank indicates a locally unique solution\n        uniqueness_flag = 1 if rank == num_params else 0\n        \n        # 6. Format and store the results for this test case\n        k1_fit, k2a_fit, k2b_fit = fitted_params\n        results.append(\n            f\"[{k1_fit:.6f},{k2a_fit:.6f},{k2b_fit:.6f},{uniqueness_flag}]\"\n        )\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个晶体的计算模型只有在代表一个稳定或至少是亚稳态的结构时才具有物理意义。在谐波近似中，晶格不稳定性的标志是“虚频模式”的出现——即振动模式具有虚数频率（即 $\\omega^2 < 0$）。本练习超越了简单的检测，提供了一个框架来诊断导致不稳定性的特定原子间相互作用，并计算一个最小的、符合物理约束的修正来恢复晶格的稳定性。",
            "id": "3460382",
            "problem": "考虑一个一维布拉菲晶格，每个原胞中有一个原子，且位移是沿链方向的标量。在谐波近似和周期性边界条件下，运动方程遵循牛顿第二定律和线性的力-位移关系。实空间中的原子间力常数由一组对相互作用 $\\{\\Phi(R)\\}$ 指定，该相互作用耦合了位于位置 $0$ 的原子与位于位置 $\\pm R$ 的原子，其中 $R \\in \\{a,2a,3a,\\dots\\}$。假设由于反演对称性，$\\Phi(R)=\\Phi(-R)$，并且在位项满足由对偶表示所蕴含的平移不变性（声学求和规则）。\n\n使用布洛赫拟设求解简正模，并根据倒易空间中动力学矩阵的定义，可以得出角频率的平方 $\\omega^2(k)$ 是标量，等于一维动力学矩阵 $D(k)$ 的本征值除以质量。您必须：\n- 对于具有对称对相互作用 $\\{\\Phi(R)\\}$ 的一维单原子链，推导出标量 $D(k)$，并用 $\\{\\Phi(R)\\}$ 和波矢 $k$ 表示，\n- 识别表征虚模的 $D(k)$ 条件，\n- 并构建一个最小校正问题，通过对给定的 $\\{\\Phi(R)\\}$ 施加微扰 $\\{\\delta \\Phi(R)\\}$ 来消除指定 $k$ 网格上的虚模，同时尊重对称性 $\\Phi(R)=\\Phi(-R)$ 并确保对相互作用强度 $\\Phi(R) \\ge 0$ (对于 $R>0$) 的物理非负性。\n\n您的程序必须为每个提供的测试用例实现以下功能：\n1) 给定邻居距离列表 $\\{R_i\\}$ 和初始对力常数 $\\{\\Phi_i\\}$ (其中 $i=1,\\dots,N$)，在指定的 $k$ 网格上计算 $D(k)$（角度以弧度为单位）。使用无量纲单位，其中质量 $m=1$ 且晶格常数 $a=1$。\n2) 诊断虚模：收集所有 $D(k) < 0$ 的网格点。为了诊断，在每个不稳定的 $k$ 点计算灵敏度 $\\partial D(k)/\\partial \\Phi_i$，并构建一个非负最小二乘估计 $\\delta \\Phi^{\\mathrm{diag}}$，使其近似满足每个点的稳定性要求。将 $\\delta \\Phi^{\\mathrm{diag}}$ 中分量最大的 $i$（从零开始的索引）定义为诊断出的罪魁祸首邻居索引。如果不存在虚模，则罪魁祸首索引必须为 $-1$。\n3) 通过求解以下凸优化问题，计算恢复稳定性的最小修正 $\\{\\delta \\Phi_i\\}$：最小化欧几里得范数 $\\sqrt{\\sum_i (\\delta \\Phi_i)^2}$，约束条件为线性不等式约束，这些约束强制要求网格中所有 $k$ 的 $D(k) \\ge 0$，以及物理约束 $\\Phi_i + \\delta \\Phi_i \\ge 0$ (对于所有 $i$)。校正后的力常数为 $\\Phi_i' = \\Phi_i + \\delta \\Phi_i$。角度以弧度为单位。所有量均为无量纲。\n4) 对于每个测试用例，输出一个结果列表，其中包含罪魁祸首索引，后跟校正后的力常数 $\\{\\Phi_i'\\}$，每个数值都四舍五入到 $6$ 位小数。\n\n用作基本依据的定义和要求：\n- 牛顿第二定律：$m \\,\\ddot{u}_n = F_n$，其中 $u_n$ 是原子 $n$ 的位移。\n- 谐波近似中的线性力响应：力通过原子间力常数 $\\Phi(R)$ 与位移成线性关系。\n- 用于晶格振动的布洛赫定理：形式为 $u_n \\propto e^{i(kn a - \\omega t)}$ 的试探解。\n- 虚模对应于 $\\omega^2(k) < 0$，当 $m=1$ 时，等价于标量 $D(k)$ 为负。\n\n您的程序必须使用以下测试套件。对于每个案例，都提供了邻居集 $\\{R_i\\}$、初始力常数 $\\{\\Phi_i\\}$ 和 $k$ 网格。角度以弧度为单位。不涉及物理单位；所有量均视为无量纲。\n\n- 测试用例 $1$ (由第二邻居驱动的一般不稳定性)：\n  - $\\{R_i\\} = [1, 2]$\n  - $\\{\\Phi_i\\} = [1.0, -1.2]$\n  - $k$-网格 $\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$\n- 测试用例 $2$ (第三邻居软化)：\n  - $\\{R_i\\} = [1, 2, 3]$\n  - $\\{\\Phi_i\\} = [0.2, 0.05, -0.1]$\n  - $k$-网格 $\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$\n- 测试用例 $3$ (边缘情况，除了一个弱的不稳定第三邻居外，刚度接近于零)：\n  - $\\{R_i\\} = [1, 2, 3]$\n  - $\\{\\Phi_i\\} = [0.0, 0.0, -0.01]$\n  - $k$-网格 $\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$\n- 测试用例 $4$ (已稳定的参考)：\n  - $\\{R_i\\} = [1, 2]$\n  - $\\{\\Phi_i\\} = [0.8, 0.2]$\n  - $k$-网格 $\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果列表。每个测试用例的结果必须是 $[$罪魁祸首$,\\Phi_1',\\Phi_2',\\dots]$ 形式的列表，所有浮点数四舍五入到 $6$ 位小数。将它们聚合到一个由方括号括起来的列表中，测试用例结果之间用逗号分隔，不含空格。例如：$[[i_1,\\phi_{1,1}',\\dots],[i_2,\\phi_{2,1}',\\dots],[i_3,\\dots],[i_4,\\dots]]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上是合理的，内容是自洽的，并且是适定的。它提出了一个计算材料科学中关于晶格稳定性的标准问题，该问题被构建为一个凸优化问题，这是一种公认且适当的方法。所有必要的数据和定义都已提供。\n\n解决方案按照问题所述分三个阶段进行：首先，推导一维链的动力学矩阵；其次，制定一个诊断程序以识别不稳定的来源；第三，指定一个基于凸优化的最小校正算法。\n\n**1. 动力学矩阵 $D(k)$ 的推导**\n\n我们考虑一个一维单原子布拉菲晶格，其晶格常数 $a=1$，原子质量 $m=1$。设 $u_n$ 为位于晶格位置 $n$ 的原子的标量位移。在谐波近似下，该原子的运动方程由牛顿第二定律给出：$m \\ddot{u}_n = F_n$。\n\n作用在原子 $n$ 上的力 $F_n$ 源于它与其他原子的相互作用。对于由力常数 $\\Phi(R_i)$ 表征的对称对偶相互作用，其中 $R_i$ 是到第 $i$ 个邻居壳层的距离，力为：\n$$\nF_n = \\sum_i \\Phi(R_i) \\left[ (u_{n+R_i} - u_n) + (u_{n-R_i} - u_n) \\right]\n$$\n这里，我们利用了问题是无量纲单位且 $a=1$ 的事实，因此在原胞 $p$ 中的原子位置就是 $p$。与距离 $R_i$ 处的原子的相互作用对应于与位置 $n \\pm R_i$ 处原子的相互作用。运动方程变为：\n$$\nm \\ddot{u}_n = \\sum_i \\Phi(R_i) \\left( u_{n+R_i} + u_{n-R_i} - 2u_n \\right)\n$$\n我们寻求由布洛赫定理给出的简正模解的形式：\n$$\nu_n(t) = A e^{i(kna - \\omega t)} = A e^{i(kn - \\omega t)}\n$$\n因为 $a=1$。位于 $n \\pm R_i$ 位置的邻居原子的位移是：\n$$\nu_{n \\pm R_i}(t) = A e^{i(k(n \\pm R_i) - \\omega t)} = u_n(t) e^{\\pm ikR_i}\n$$\n将这些代入运动方程得到：\n$$\nm (-\\omega^2) u_n = \\sum_i \\Phi(R_i) \\left( u_n e^{ikR_i} + u_n e^{-ikR_i} - 2u_n \\right)\n$$\n除以 $u_n$（非零）得到：\n$$\n-m \\omega^2 = \\sum_i \\Phi(R_i) (2\\cos(kR_i) - 2)\n$$\n重新整理各项，我们得到色散关系 $\\omega^2(k)$：\n$$\n\\omega^2(k) = \\frac{1}{m} \\sum_i 2\\Phi(R_i) (1 - \\cos(kR_i))\n$$\n问题定义了标量动力学矩阵 $D(k)$，使得 $\\omega^2(k) = D(k)/m$。利用提供的邻居距离列表 $\\{R_i\\}$ 和力常数 $\\{\\Phi_i\\}$，并设置 $m=1$，我们得到 $D(k)$ 的表达式：\n$$\nD(k) = \\sum_i 2\\Phi_i (1 - \\cos(kR_i))\n$$\n该表达式内在地满足声学求和规则，确保当 $k \\to 0$ 时 $D(k) \\to 0$，这对应于晶体的平移不变性。\n\n**2. 虚模条件与诊断程序**\n\n晶格不稳定性由虚频率 $\\omega \\in i\\mathbb{R}$ 的存在所指示。这发生在 $\\omega^2(k) < 0$ 时。由于质量 $m$ 为正，此条件等价于动力学矩阵的负本征值：\n$$\nD(k) < 0\n$$\n为了诊断这种不稳定性的原因，我们分析力常数 $\\{\\Phi_i\\}$ 的变化如何影响 $D(k)$。$D(k)$ 关于 $\\Phi_i$ 的灵敏度是偏导数：\n$$\n\\frac{\\partial D(k)}{\\partial \\Phi_i} = 2(1 - \\cos(kR_i))\n$$\n令 $\\mathcal{K}_{unstable} = \\{k_j \\mid D(k_j) < 0\\}$ 为网格上系统不稳定的波矢集合。对于每个 $k_j \\in \\mathcal{K}_{unstable}$，我们寻求一个校正 $\\delta\\Phi \\ge 0$ 来恢复稳定性，即 $D'(k_j) \\ge 0$。在一阶近似下，这是 $D(k_j) + \\sum_i \\frac{\\partial D(k_j)}{\\partial \\Phi_i} \\delta\\Phi_i \\approx 0$。这导出一个线性方程组 $A \\delta\\Phi \\approx b$，其中 $A_{ji} = \\frac{\\partial D(k_j)}{\\partial \\Phi_i}$ 且 $b_j = -D(k_j)$，$b_j > 0$。\n问题指定了一个使用非负最小二乘 (NNLS) 估计 $\\delta\\Phi^{\\mathrm{diag}}$ 的诊断程序。我们求解以下问题：\n$$\n\\min_{\\delta\\Phi \\ge 0} \\| A \\delta\\Phi - b \\|_2^2\n$$\n“罪魁祸首”相互作用被确定为对应于所得向量 $\\delta\\Phi^{\\mathrm{diag}}$ 中最大分量的那一个。如果不存在不稳定性，则罪魁祸首索引指定为 $-1$。\n\n**3. 通过凸优化进行最小校正**\n\n完全校正需要找到最小的微扰 $\\delta\\Phi$，以确保在整个 $k$ 网格上的稳定性，同时满足物理约束。这被表述为一个凸优化问题。\n\n目标是最小化校正的量级，该量级由 $\\delta\\Phi$ 的欧几里得范数衡量。最小化 $\\|\\delta\\Phi\\|_2$ 等价于最小化其平方 $\\|\\delta\\Phi\\|_2^2 = \\sum_i (\\delta\\Phi_i)^2$，这是一个二次目标函数。\n\n解必须满足两组约束条件：\n1.  **稳定性约束**：校正后的动力学矩阵 $D'(k) = D(k) + \\sum_i \\delta\\Phi_i \\frac{\\partial D(k)}{\\partial \\Phi_i}$，对于所提供网格 $\\mathcal{K}$ 上的所有 $k$ 都必须为非负。这给出了一组线性不等式约束：\n    $$\n    \\sum_i \\delta\\Phi_i \\cdot 2(1 - \\cos(kR_i)) \\ge -D(k) \\quad \\forall k \\in \\mathcal{K}\n    $$\n2.  **物理性约束**：校正后的力常数 $\\Phi_i' = \\Phi_i + \\delta\\Phi_i$，对于所有相互作用 $i$ 都必须为非负。这是另一组线性不等式约束：\n    $$\n    \\delta\\Phi_i \\ge -\\Phi_i \\quad \\forall i\n    $$\n因此，该问题是一个二次规划 (QP) 问题：\n$$\n\\begin{align*}\n\\text{minimize} \\quad  \\sum_i (\\delta\\Phi_i)^2 \\\\\n\\text{subject to} \\quad  \\sum_i \\delta\\Phi_i \\cdot 2(1 - \\cos(kR_i)) + D(k) \\ge 0, \\quad \\forall k \\in \\mathcal{K} \\\\\n \\Phi_i + \\delta\\Phi_i \\ge 0, \\quad \\forall i\n\\end{align*}\n$$\n这个 QP 问题可以使用标准算法（如序列最小二乘规划，SLSQP）进行数值求解，以找到最优校正向量 $\\delta\\Phi^*$。最终稳定的力常数则为 $\\Phi' = \\Phi + \\delta\\Phi^*$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls, minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the lattice stability problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        (np.array([1.0, 2.0]), np.array([1.0, -1.2]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n        # Test Case 2\n        (np.array([1.0, 2.0, 3.0]), np.array([0.2, 0.05, -0.1]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n        # Test Case 3\n        (np.array([1.0, 2.0, 3.0]), np.array([0.0, 0.0, -0.01]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n        # Test Case 4\n        (np.array([1.0, 2.0]), np.array([0.8, 0.2]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n    ]\n\n    results = []\n    for R, Phi, k_grid in test_cases:\n        result = process_case(R, Phi, k_grid)\n        results.append(result)\n\n    # Format the final output string as specified\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        culprit = res[0]\n        phis_prime = res[1:]\n        phi_str = ','.join(f\"{x:.6f}\" for x in phis_prime)\n        output_str += f\"[{culprit},{phi_str}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\ndef process_case(R, Phi, k_grid):\n    \"\"\"\n    Processes a single test case: diagnoses instability and computes the minimal correction.\n    \"\"\"\n    N = len(Phi)\n\n    # Helper function to compute D(k)\n    def compute_D_values(phi_vec, k_vec, R_vec):\n        # S_matrix[j, i] = 2 * (1 - cos(k_j * R_i))\n        S_matrix = 2.0 * (1.0 - np.cos(np.outer(k_vec, R_vec)))\n        # D_values[j] = sum_i(phi_i * S_ji)\n        return np.dot(S_matrix, phi_vec)\n\n    # 1. Initial Stability Check and Diagnosis\n    D_initial = compute_D_values(Phi, k_grid, R)\n    unstable_indices = np.where(D_initial  0)[0]\n\n    if len(unstable_indices) == 0:\n        # System is already stable\n        culprit_index = -1\n        Phi_prime = Phi\n    else:\n        # System is unstable, proceed with diagnosis and correction\n        \n        # 2. Diagnosis\n        k_unstable = k_grid[unstable_indices]\n        # Sensitivity matrix A for unstable k-points\n        A = 2.0 * (1.0 - np.cos(np.outer(k_unstable, R)))\n        # Target vector b\n        b = -D_initial[unstable_indices]\n        \n        # Nonnegative least squares to find diagnostic correction\n        delta_phi_diag, _ = nnls(A, b)\n        culprit_index = int(np.argmax(delta_phi_diag))\n\n        # 3. Correction via Convex Optimization\n        # Objective function: minimize ||delta_Phi||^2\n        objective_fun = lambda delta_phi: np.sum(delta_phi**2)\n\n        # Initial guess for the correction\n        delta_phi_0 = np.zeros(N)\n\n        # Build constraints for the optimizer\n        # The use of default arguments in lambda (e.g., k=k_val) is crucial\n        # to capture the value from the loop iteration correctly.\n        constraints = []\n        \n        # Stability constraints: D'(k) >= 0 for all k in the grid\n        for i in range(len(k_grid)):\n            k_val = k_grid[i]\n            D_k_val = D_initial[i]\n            S_k_vec = 2.0 * (1.0 - np.cos(k_val * R))\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, d=D_k_val, s=S_k_vec: d + np.dot(s, x)\n            })\n\n        # Physicality constraints: Phi'_i = Phi_i + delta_Phi_i >= 0\n        for i in range(N):\n            phi_val = Phi[i]\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, idx=i, p_val=phi_val: p_val + x[idx]\n            })\n\n        # Solve the Quadratic Programming problem\n        opt_result = minimize(\n            objective_fun,\n            delta_phi_0,\n            method='SLSQP',\n            constraints=constraints,\n            options={'ftol': 1e-9, 'maxiter': 200}\n        )\n\n        delta_phi_optimal = opt_result.x\n        Phi_prime = Phi + delta_phi_optimal\n\n    return [culprit_index] + list(Phi_prime)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "利用稳定的谐波模型，我们可以使用准谐波近似（Quasi-Harmonic Approximation, QHA）来计算自由能和热膨胀等热力学性质。QHA巧妙地通过在*每个固定体积*下都将晶体视为谐波系统来引入体积依赖性。本练习旨在探索QHA的强大功能及其缺陷。您将计算随体积变化的自由能，更重要的是，学会识别预示着这一广泛使用的近似方法失效的关键特征——例如在应变体积下出现的虚频模式或剧烈的模式交叉。",
            "id": "3460359",
            "problem": "考虑一个在谐波近似下建模的晶体固体，其振动自由能通过对独立量子谐振子的贡献求和得到。计算在完全无量纲单位制下进行，其中约化普朗克常数和玻尔兹曼常数均设为1（即 $\\hbar = 1$ 和 $k_B = 1$）。体积也用单位表示，其中参考平衡体积为 $V_0 = 1$。任务是通过在多个温度下对不同体积的振动自由能进行拟合，并识别标志着该近似失效的特征，来评估准谐波近似 (QHA) 的稳健性。\n\n基本原理：\n- 在温度 $T$ 下，角频率为 $\\omega$ 的单个谐振模式的振动自由能为\n$$\nf_{\\text{mode}}(T,\\omega) = T \\ln \\left(2 \\sinh \\left(\\frac{\\omega}{2T}\\right)\\right).\n$$\n- 对于一组由 $i$ 索引的模式，在温度 $T$ 和体积 $V$ 下的振动自由能为\n$$\nF_{\\text{vib}}(T,V) = \\sum_i f_{\\text{mode}}(T,\\omega_i(V)).\n$$\n- 在准谐波近似 (QHA) 中，允许频率 $\\omega_i(V)$ 依赖于体积，但在每个固定的 $V$ 值下，势能仍按谐波方式处理。\n- 为完整起见，提供一个简单的静态晶格能量模型：\n$$\nE_0(V) = a (V - 1)^2 + b (V - 1)^3,\n$$\n其中参数 $a$ 和 $b$ 已给出，但确定 $E_0(V)$ 并非拟合的目标；主要焦点是 $F_{\\text{vib}}(T,V)$。\n\n您的程序必须对下面测试套件中的每种材料，计算在一组指定的体积 $\\{V_k\\}$ 和温度 $\\{T_m\\}$ 下的 $F_{\\text{vib}}(T,V)$，在每个温度 $T_m$ 下对 $F_{\\text{vib}}(T_m,V)$ 相对于 $V$ 进行二次最小二乘拟合，然后评估以下QHA稳健性判据：\n\n1. 虚模判据：如果在给定集合中的任何体积 $V_k$ 下，有任何模式的频率 $\\omega_i(V_k) \\le 0$，则将该材料的QHA归类为失效。\n\n2. 二次拟合判据：对于每个温度 $T_m$，将 $F_{\\text{vib}}(T_m,V)$ 在所提供的体积 $\\{V_k\\}$ 上拟合成一个关于 $V$ 的2次多项式。计算均方根误差\n$$\n\\text{RMSE}(T_m) = \\sqrt{\\frac{1}{K} \\sum_{k=1}^{K} \\left(F_{\\text{vib}}(T_m,V_k) - \\hat{F}_{\\text{vib}}(T_m,V_k)\\right)^2},\n$$\n其中 $\\hat{F}_{\\text{vib}}(T_m,V_k)$ 是在 $V_k$ 处的拟合二次值，而 $K$ 是体积点的数量。用该温度下的平均绝对自由能对此进行归一化，\n$$\n\\text{nRMSE}(T_m) = \\frac{\\text{RMSE}(T_m)}{\\frac{1}{K}\\sum_{k=1}^{K} \\left|F_{\\text{vib}}(T_m,V_k)\\right| + \\epsilon},\n$$\n其中数值正则化子 $\\epsilon = 10^{-12}$。如果 $\\max_m \\text{nRMSE}(T_m)  \\tau$，阈值 $\\tau = 2 \\times 10^{-3}$，则将该材料的QHA归类为失效。\n\n3. 模式交叉严重性判据：检测当 $V$ 在离散集合 $\\{V_k\\}$ 上变化时，是否有任何模式对 $(i,j)$ 发生交叉；也就是说，是否存在某个相邻的 $V_k$ 和 $V_{k+1}$，使得\n$$\n\\left(\\omega_i(V_k) - \\omega_j(V_k)\\right)\\left(\\omega_i(V_{k+1}) - \\omega_j(V_{k+1})\\right)  0.\n$$\n对于每个模式，在 $V=1$ 处定义一个有效的格林爱森参数：\n- 对于幂律模式，$\\omega(V) = \\omega_0 V^{-\\gamma}$，取 $\\gamma_{\\text{eff}} = \\gamma$。\n- 对于线性软化模式，$\\omega(V) = \\omega_0 - \\alpha (V - 1)$，取 $\\gamma_{\\text{eff}} = \\alpha / \\omega_0$。\n- 对于二次硬化模式，$\\omega(V) = \\omega_0 \\left(1 + \\beta (V - 1)^2\\right)$，取 $\\gamma_{\\text{eff}} = 0$。\n如果检测到任何交叉发生在两个模式之间，且它们的有效参数满足 $|\\gamma_{\\text{eff},i} - \\gamma_{\\text{eff},j}|  \\Gamma_{\\text{th}}$，其中 $\\Gamma_{\\text{th}} = 0.5$，则将该材料的QHA归类为失效。\n\n如果一种材料没有触发上述任何失效条件，则将该材料的QHA归类为稳健。\n\n要使用的模型频率形式：\n- 幂律：$\\omega(V) = \\omega_0 \\, V^{-\\gamma}$，参数为 $\\omega_0  0$ 和 $\\gamma  0$。\n- 线性软化：$\\omega(V) = \\omega_0 - \\alpha (V - 1)$，参数为 $\\omega_0  0$ 和 $\\alpha  0$。\n- 二次硬化：$\\omega(V) = \\omega_0 \\left(1 + \\beta (V - 1)^2\\right)$，参数为 $\\omega_0  0$ 和 $\\beta  0$。\n\n测试套件：\n- 材料 A：\n  - 模式：\n    - 幂律，参数为 $\\omega_0 = 2.0$, $\\gamma = 1.2$。\n    - 幂律，参数为 $\\omega_0 = 3.5$, $\\gamma = 0.8$。\n    - 幂律，参数为 $\\omega_0 = 5.0$, $\\gamma = 1.0$。\n    - 幂律，参数为 $\\omega_0 = 6.0$, $\\gamma = 1.5$。\n  - 体积：$[0.94, 0.98, 1.00, 1.02, 1.06, 1.10]$。\n  - 温度：$[0.05, 0.20, 0.50, 1.00]$。\n  - 静态能量参数：$a = 200$, $b = 0$。\n\n- 材料 B：\n  - 模式：\n    - 线性软化，参数为 $\\omega_0 = 0.80$, $\\alpha = 8.50$。\n    - 幂律，参数为 $\\omega_0 = 2.00$, $\\gamma = 1.00$。\n    - 幂律，参数为 $\\omega_0 = 3.00$, $\\gamma = 1.00$。\n  - 体积：$[0.96, 1.00, 1.04, 1.08, 1.12]$。\n  - 温度：$[0.10, 0.30, 0.60]$。\n  - 静态能量参数：$a = 150$, $b = 10$。\n\n- 材料 C：\n  - 模式：\n    - 幂律，参数为 $\\omega_0 = 3.00$, $\\gamma = 1.00$。\n    - 幂律，参数为 $\\omega_0 = 2.80$, $\\gamma = 2.00$。\n    - 二次硬化，参数为 $\\omega_0 = 1.20$, $\\beta = 15.00$。\n  - 体积：$[0.90, 0.95, 1.00, 1.05, 1.10]$。\n  - 温度：$[0.05, 0.20, 0.50, 1.00]$。\n  - 静态能量参数：$a = 180$, $b = 5$。\n\n角度单位未使用。所有量在指定的单位系统中都是无量纲的。您的程序必须严格按照所述判据实现，并针对有序的材料 $\\text{A}$、$\\text{B}$、$\\text{C}$，生成一行输出，其中包含一个布尔值列表 $[$robust$_A$, robust$_B$, robust$_C]$，不含空格，其中如果该材料的QHA是稳健的，则对应条目为 $\\text{True}$，否则为 $\\text{False}$。例如，输出可能看起来像 $[\\text{True},\\text{False},\\text{True}]$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[ \\text{result}_1,\\text{result}_2,\\text{result}_3 ]$ 但不含空格）。不需要用户输入，也不应读取或写入任何文件。",
            "solution": "所提供的问题经评估是有效的。它在科学上基于固态物理学的原理，特别是用于建模晶体固体的准谐波近似 (QHA)。该问题是良定的，为三个不同的测试用例提供了所有必要的数学定义、物理参数，以及一套用于评估QHA稳健性的清晰、客观的算法判据。其中没有内部矛盾、歧义或事实错误。该任务是数值方法在计算材料科学概念中的一个非平凡应用。\n\n我们现在将进行系统、分步的求解。该方法包括对三种指定材料中的每一种评估三个不同的判据。如果任何一个判据表明失效，则该材料的QHA被视为失效。如果一种材料通过了所有三个判据，则认为其QHA是稳健的。\n\n基本量是依赖于频率和体积的声子模式 $\\omega_i(V)$，以及振动自由能 $F_{\\text{vib}}(T,V)$。问题指定了 $\\omega_i(V)$ 的三种函数形式：\n1.  幂律：$\\omega(V) = \\omega_0 V^{-\\gamma}$\n2.  线性软化：$\\omega(V) = \\omega_0 - \\alpha (V - 1)$\n3.  二次硬化：$\\omega(V) = \\omega_0 (1 + \\beta (V - 1)^2)$\n\n在给定温度 $T$ 和体积 $V$ 下的总振动自由能是所有模式 $i$ 贡献的总和：\n$$\nF_{\\text{vib}}(T,V) = \\sum_i f_{\\text{mode}}(T,\\omega_i(V))\n$$\n其中单模自由能由下式给出：\n$$\nf_{\\text{mode}}(T,\\omega) = T \\ln \\left(2 \\sinh \\left(\\frac{\\omega}{2T}\\right)\\right)\n$$\n此计算在无量纲单位制（$\\hbar = 1$ 和 $k_B = 1$）下进行。为了确保双曲正弦函数的大宗量（特别是当比率 $x = \\omega/(2T)$ 很大时）具有数值稳定性，该表达式可以重新表述。对于大的 $x$，$\\sinh(x) \\approx \\frac{1}{2}e^x$，这将自由能简化为零点能，$f_{\\text{mode}} \\approx T \\ln(e^x) = Tx = \\omega/2$。一个更稳健的数值计算形式是 $f_{\\text{mode}}(T,\\omega) = T \\left( \\frac{\\omega}{2T} + \\ln(1 - e^{-\\omega/T}) \\right)$，它能避免溢出并保持精度。采用一种混合方法，对小的 $x$ 使用直接形式，对大的 $x$ 使用稳定形式，是最佳选择。\n\n对于每种材料，我们依次应用三个验证判据：\n\n**判据1：虚模判据**\nQHA基于晶体在所考虑的每个体积 $V$ 下都是动力学稳定的假设。这种稳定性的破坏由一个或多个声子频率变为虚数来标志，这对应于 $\\omega^2  0$，或者由于我们处理的是非负频率，对应于 $\\omega \\le 0$。我们为所有给定的体积 $\\{V_k\\}$ 计算每个 $\\omega_i(V_k)$。如果任何 $\\omega_i(V_k) \\le 0$，则材料在该体积下的谐波图像中是力学不稳定的，QHA失效。\n\n**判据2：二次拟合判据**\n当总自由能 $F(V,T) = E_0(V) + F_{\\text{vib}}(V,T)$ 在其最小值附近的体积依赖关系是简单的、近似二次关系时，QHA最有效。问题专门测试振动部分 $F_{\\text{vib}}(V,T)$。对于所提供集合中的每个温度 $T_m$，我们计算所有体积 $\\{V_k\\}$ 下的 $F_{\\text{vib}}(T_m,V_k)$ 值。然后，我们将这些数据对 $V$ 进行最小二乘拟合，得到一个二次多项式 $\\hat{F}_{\\text{vib}}(T_m,V) = p_2 V^2 + p_1 V + p_0$。拟合的质量由归一化均方根误差 $\\text{nRMSE}(T_m)$ 量化：\n$$\n\\text{nRMSE}(T_m) = \\frac{\\sqrt{\\frac{1}{K} \\sum_{k=1}^{K} \\left(F_{\\text{vib}}(T_m,V_k) - \\hat{F}_{\\text{vib}}(T_m,V_k)\\right)^2}}{\\frac{1}{K}\\sum_{k=1}^{K} \\left|F_{\\text{vib}}(T_m,V_k)\\right| + \\epsilon}\n$$\n其中 $K$ 是体积点的数量，$\\epsilon = 10^{-12}$ 是一个正则化常数。如果所有温度中的最大 $\\text{nRMSE}(T_m)$ 超过阈值 $\\tau = 2 \\times 10^{-3}$，这表示振动自由能的体积依赖性过于复杂，无法用简单的二次模型捕捉，表明QHA的内在简单性已失效。\n\n**判据3：模式交叉严重性判据**\n在真实材料中，由于非谐相互作用，声子分支的交叉可以是“避免交叉”，这是QHA所忽略的现象。当具有非常不同体积依赖性（即不同的格林爱森参数）的模式交叉时，该近似最值得怀疑。我们首先通过检查相邻体积下任何模式对 $(i,j)$ 之间频率差的符号变化来检测模式交叉：$(\\omega_i(V_k) - \\omega_j(V_k))(\\omega_i(V_{k+1}) - \\omega_j(V_{k+1}))  0$。如果检测到交叉，我们评估其严重性。这是通过比较为每种模式类型定义的有效格林爱森参数 $\\gamma_{\\text{eff}}$ 来完成的：\n-   幂律：$\\gamma_{\\text{eff}} = \\gamma$\n-   线性软化：$\\gamma_{\\text{eff}} = \\alpha / \\omega_0$\n-   二次硬化：$\\gamma_{\\text{eff}} = 0$\n如果在模式 $i$ 和 $j$ 之间发生交叉，且 $|\\gamma_{\\text{eff},i} - \\gamma_{\\text{eff},j}|  \\Gamma_{\\text{th}} = 0.5$，则该交叉被认为是严重的，QHA被归类为失效。\n\n对测试套件中的每种材料执行此程序。\n\n- **材料 A**：所有模式均为幂律类型。由于 $\\omega_0  0$ 且 $V  0$，不可能出现虚频。因此，它通过了判据1。模式交叉分析显示，在指定的体积范围内没有发生交叉。因此，它通过了判据3。最后的检查是二次拟合。数值计算表明，最大 $\\text{nRMSE}$ 低于阈值 $\\tau = 2 \\times 10^{-3}$。因此，材料A被归类为**稳健**。\n\n- **材料 B**：该材料包括一个由 $\\omega(V) = 0.80 - 8.50 (V - 1)$ 定义的线性软化模式。在其集合的最大体积 $V_k = 1.12$ 处计算该频率，得到 $\\omega(1.12) = 0.80 - 8.50 \\times 0.12 = 0.80 - 1.02 = -0.22$。由于此频率为负，存在虚模。根据判据1，材料B的QHA已失效。对该材料的分析可以终止。材料B被归类为**不稳健**。\n\n- **材料 C**：该材料的模式在所有体积下均为正，因此它通过了判据1。然后我们检查模式交叉。该材料有一个幂律模式 $\\omega_1(V) = 3.0 V^{-1}$ 和另一个幂律模式 $\\omega_2(V) = 2.8 V^{-2}$。在 $3V^{-1} = 2.8V^{-2}$ 处发生交叉，解得 $V = 2.8/3 \\approx 0.933$。此值位于所提供的体积点 $V_k=0.90$ 和 $V_{k+1}=0.95$ 之间。检查证实了符号变化：在 $V=0.90$ 时，$\\omega_1 \\approx 3.333$ 且 $\\omega_2 \\approx 3.457$ ($\\omega_1  \\omega_2$)，而在 $V=0.95$ 时，$\\omega_1 \\approx 3.158$ 且 $\\omega_2 \\approx 3.102$ ($\\omega_1  \\omega_2$)。检测到交叉。然后我们评估其严重性。有效的格林爱森参数为 $\\gamma_{\\text{eff},1} = 1.0$ 和 $\\gamma_{\\text{eff},2} = 2.0$。差值为 $|\\gamma_{\\text{eff},1} - \\gamma_{\\text{eff},2}| = |1.0 - 2.0| = 1.0$。这超过了阈值 $\\Gamma_{\\text{th}} = 0.5$。由于这个严重的模式交叉，材料C的QHA在判据3下已失效。材料C被归类为**不稳健**。\n\n最终结果是一个布尔值列表，分别指示材料 A、B 和 C 的稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: scipy is listed as an available library but is not required for this implementation.\n\ndef solve():\n    \"\"\"\n    Main solver function to evaluate QHA robustness for all materials.\n    \"\"\"\n    \n    #\n    # Define Mode Classes\n    #\n    \n    class Mode:\n        def __init__(self, w0, params):\n            self.w0 = w0\n            self.params = params\n\n        def frequency(self, V):\n            raise NotImplementedError\n\n        def gamma_eff(self):\n            raise NotImplementedError\n\n    class PowerLawMode(Mode):\n        def frequency(self, V):\n            gamma = self.params['gamma']\n            # V must be positive for this model\n            return self.w0 * V**(-gamma) if V > 0 else -1.0\n\n        def gamma_eff(self):\n            return self.params['gamma']\n\n    class LinearSofteningMode(Mode):\n        def frequency(self, V):\n            alpha = self.params['alpha']\n            return self.w0 - alpha * (V - 1.0)\n\n        def gamma_eff(self):\n            # Avoid division by zero, although w0 > 0 is a problem constraint.\n            return self.params['alpha'] / self.w0 if self.w0 != 0 else float('inf')\n\n    class QuadraticStiffeningMode(Mode):\n        def frequency(self, V):\n            beta = self.params['beta']\n            return self.w0 * (1.0 + beta * (V - 1.0)**2)\n\n        def gamma_eff(self):\n            return 0.0\n\n    mode_map = {\n        'power_law': PowerLawMode,\n        'linear_softening': LinearSofteningMode,\n        'quadratic_stiffening': QuadraticStiffeningMode\n    }\n\n    #\n    # Test Suite Data\n    #\n    \n    test_suite = [\n        {\n            \"name\": \"Material A\",\n            \"modes_def\": [\n                {'type': 'power_law', 'w0': 2.0, 'params': {'gamma': 1.2}},\n                {'type': 'power_law', 'w0': 3.5, 'params': {'gamma': 0.8}},\n                {'type': 'power_law', 'w0': 5.0, 'params': {'gamma': 1.0}},\n                {'type': 'power_law', 'w0': 6.0, 'params': {'gamma': 1.5}},\n            ],\n            \"volumes\": np.array([0.94, 0.98, 1.00, 1.02, 1.06, 1.10]),\n            \"temperatures\": np.array([0.05, 0.20, 0.50, 1.00]),\n        },\n        {\n            \"name\": \"Material B\",\n            \"modes_def\": [\n                {'type': 'linear_softening', 'w0': 0.80, 'params': {'alpha': 8.50}},\n                {'type': 'power_law', 'w0': 2.00, 'params': {'gamma': 1.00}},\n                {'type': 'power_law', 'w0': 3.00, 'params': {'gamma': 1.00}},\n            ],\n            \"volumes\": np.array([0.96, 1.00, 1.04, 1.08, 1.12]),\n            \"temperatures\": np.array([0.10, 0.30, 0.60]),\n        },\n        {\n            \"name\": \"Material C\",\n            \"modes_def\": [\n                {'type': 'power_law', 'w0': 3.00, 'params': {'gamma': 1.00}},\n                {'type': 'power_law', 'w0': 2.80, 'params': {'gamma': 2.00}},\n                {'type': 'quadratic_stiffening', 'w0': 1.20, 'params': {'beta': 15.00}},\n            ],\n            \"volumes\": np.array([0.90, 0.95, 1.00, 1.05, 1.10]),\n            \"temperatures\": np.array([0.05, 0.20, 0.50, 1.00]),\n        },\n    ]\n\n    #\n    # Helper Functions for anaylsis\n    #\n    \n    def calculate_free_energy_mode(T, omega):\n        \"\"\"Calculates vibrational free energy for a single mode using a numerically stable approach.\"\"\"\n        if T == 0:\n            return omega / 2.0\n        \n        x = omega / (2.0 * T)\n\n        # The term 2*sinh(x) can overflow for large x.\n        # Use a hybrid method for numerical stability.\n        # Crossover point x=15 is chosen safely inside the stable regime for float64.\n        if x > 15.0:\n            # f = T * log(2 * sinh(x)) approx T * log(exp(x)) = T*x = omega/2\n            return omega / 2.0\n        else:\n            return T * np.log(2.0 * np.sinh(x))\n\n    def evaluate_robustness(material_data):\n        \"\"\"Evaluates QHA robustness for a single material based on the three criteria.\"\"\"\n        modes = [mode_map[m['type']](m['w0'], m['params']) for m in material_data['modes_def']]\n        volumes = material_data['volumes']\n        temperatures = material_data['temperatures']\n        \n        # Calculate all frequencies at all volumes\n        omega_V = np.array([[m.frequency(v) for v in volumes] for m in modes])\n\n        # Criterion 1: Imaginary-mode criterion\n        if np.any(omega_V = 0):\n            return False\n\n        # Criterion 3: Mode-crossing severity criterion\n        gamma_th = 0.5\n        num_modes = len(modes)\n        for i in range(num_modes):\n            for j in range(i + 1, num_modes):\n                omega_diff = omega_V[i, :] - omega_V[j, :]\n                # Check for sign change between adjacent volumes\n                crossings = omega_diff[:-1] * omega_diff[1:]  0\n                if np.any(crossings):\n                    gamma_eff_i = modes[i].gamma_eff()\n                    gamma_eff_j = modes[j].gamma_eff()\n                    if abs(gamma_eff_i - gamma_eff_j) > gamma_th:\n                        return False\n                        \n        # Criterion 2: Quadratic-fit criterion\n        nrmse_threshold = 2e-3\n        regularizer = 1e-12\n        max_nrmse = 0.0\n        \n        for T in temperatures:\n            if T == 0: continue # The formula can have a singularity\n            \n            F_vib_V = np.zeros_like(volumes, dtype=float)\n            for k, V in enumerate(volumes):\n                omegas_at_V = omega_V[:, k]\n                F_vib_V[k] = np.sum([calculate_free_energy_mode(T, w) for w in omegas_at_V])\n\n            # Perform quadratic fit\n            coeffs = np.polyfit(volumes, F_vib_V, 2)\n            F_vib_fit = np.polyval(coeffs, volumes)\n            \n            # Calculate nRMSE\n            rmse = np.sqrt(np.mean((F_vib_V - F_vib_fit)**2))\n            mean_abs_F = np.mean(np.abs(F_vib_V))\n            \n            nrmse = rmse / (mean_abs_F + regularizer)\n\n            if nrmse > max_nrmse:\n                max_nrmse = nrmse\n        \n        if max_nrmse > nrmse_threshold:\n            return False\n\n        # If all criteria passed\n        return True\n\n    #\n    # Main Execution Logic\n    #\n    \n    results = []\n    for material in test_suite:\n        is_robust = evaluate_robustness(material)\n        results.append(is_robust)\n        \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}