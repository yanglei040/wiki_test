{
    "hands_on_practices": [
        {
            "introduction": "在非平衡分子动力学（NEMD）模拟中，一个核心任务是从原子轨迹中计算宏观输运系数。这项实践将指导你完成此过程中的关键一步：分析稳态剖面数据。你将学习如何区分受恒温层影响的非线性边界区域和展现线性行为的体相区域，并通过对体相数据的线性拟合，精确提取温度和速度梯度 ()，这是计算傅里叶热导率或牛顿粘度等输运系数的根本前提。",
            "id": "3469013",
            "problem": "给定一个一维稳态、边界驱动的非平衡分子动力学 (NEMD) 配置，其中一个长度为 $L$ 的平板沿 $x$ 轴被细分为 $N$ 个空间单元。每个单元都有一个中心坐标 $x_i$ 和测得的稳态单元平均场：温度 $T_i$（单位为开尔文）和流向速度 $u_i$（单位为米/秒）。恒温板在左边界占据 $W_L$ 个单元，在右边界占据 $W_R$ 个单元。目标是通过拟合线性区域来提取体相梯度，并量化靠近恒温板的边界层偏差。\n\n基本依据与假设：\n- 对于具有恒定输运系数的简单流体，在一维均匀驱动下，热量和动量的稳态输运意味着温度和速度的体相分布呈线性，前提是体相区域没有受到直接的恒温控制。当傅里叶定律 (Fourier’s law) 和牛顿本构关系 (Newtonian constitutive relation) 与稳态平衡及体相中无源项的条件相结合时，即可得出此结论。\n- 恒温板在边界附近引入了非体相行为；为防止污染体相拟合，除了恒温单元本身，还必须排除每个恒温板旁边的 $g$ 个单元作为保护区。\n\n对于每个测试用例，您的程序必须执行以下操作：\n1. 为 $i \\in \\{0,\\dots,N-1\\}$ 构建单元中心 $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = L/N$。\n2. 通过排除左恒温板 $\\{0,\\dots,W_L-1\\}$ 和右恒温板 $\\{N-W_R,\\dots,N-1\\}$ 中的索引，然后再排除每个板旁边额外的 $g=1$ 个保护单元，来确定体相拟合区域。也就是说，仅对索引 $i \\in \\{W_L+g,\\dots,N-W_R-g-1\\}$ 进行拟合。\n3. 使用普通最小二乘法，对体相区域拟合线性模型 $T(x) \\approx a_T x + b_T$ 和 $u(x) \\approx a_u x + b_u$，以提取体相梯度 $a_T = dT/dx$ 和 $a_u = du/dx$。报告 $a_T$（单位为 $\\mathrm{K}/\\mathrm{m}$）和 $a_u$（单位为 $\\mathrm{s}^{-1}$）。\n4. 通过分别计算每一侧的以下数值，来量化恒温板中的偏差：\n   - 在与每个板相邻的第一个体相单元处的界面跳跃，定义为该位置的测量值减去体相拟合的预测值。在左侧，使用第一个体相索引 $i_L = W_L + g$ 并计算 $J_T^{(L)} = T_{i_L} - (a_T x_{i_L} + b_T)$ 和 $J_u^{(L)} = u_{i_L} - (a_u x_{i_L} + b_u)$；在右侧，使用 $i_R = N - W_R - g - 1$ 并类似地计算 $J_T^{(R)}$ 和 $J_u^{(R)}$。报告 $J_T^{(L)}$ 和 $J_T^{(R)}$（单位为 $\\mathrm{K}$），以及 $J_u^{(L)}$ 和 $J_u^{(R)}$（单位为 $\\mathrm{m}/\\mathrm{s}$）。\n   - 每个恒温板中的均方根 (RMS) 偏差，相对于体相拟合，并按相应场在整个域上的总体相降幅进行归一化。对于左侧板索引 $\\{0,\\dots,W_L-1\\}$ 和右侧板索引 $\\{N-W_R,\\dots,N-1\\}$，计算残差 $T_i - (a_T x_i + b_T)$ 和 $u_i - (a_u x_i + b_u)$ 的 RMS。将温度 RMS 除以 $\\left|a_T\\right| L$ 进行归一化，将速度 RMS 除以 $\\left|a_u\\right| L$ 进行归一化。以小数形式报告无量纲值 $D_T^{(L)}$、$D_T^{(R)}$、$D_u^{(L)}$ 和 $D_u^{(R)}$。所有提供的测试用例都具有非零的体相梯度，因此归一化是明确定义的。\n5. 对于每个测试用例，按以下固定顺序列出结果：\n   - $a_T$ (单位 $\\mathrm{K}/\\mathrm{m}$),\n   - $a_u$ (单位 $\\mathrm{s}^{-1}$),\n   - $J_T^{(L)}$ (单位 $\\mathrm{K}$),\n   - $J_T^{(R)}$ (单位 $\\mathrm{K}$),\n   - $J_u^{(L)}$ (单位 $\\mathrm{m}/\\mathrm{s}$),\n   - $J_u^{(R)}$ (单位 $\\mathrm{m}/\\mathrm{s}$),\n   - $D_T^{(L)}$ (无量纲),\n   - $D_T^{(R)}$ (无量纲),\n   - $D_u^{(L)}$ (无量纲),\n   - $D_u^{(R)}$ (无量纲)。\n\n测试套件构建：\n- 对于每个测试用例，您必须按如下方式根据指定参数合成 $T_i$ 和 $u_i$。对于 $i \\in \\{0,\\dots,N-1\\}$：\n  - $x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$, 其中 $\\Delta x = L/N$。\n  - 基准线性场：\n    - $T_i^{\\mathrm{lin}} = T_0 + a_T^{\\mathrm{true}} x_i$,\n    - $u_i^{\\mathrm{lin}} = u_0 + a_u^{\\mathrm{true}} x_i$.\n  - 仅在恒温单元内部施加的恒温器局部偏差：\n    - 左侧板索引 $i \\in \\{0,\\dots,W_L-1\\}$：\n      - $T_i \\leftarrow T_i^{\\mathrm{lin}} + A_T^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_T^{(L)}}\\right)$,\n      - $u_i \\leftarrow u_i^{\\mathrm{lin}} + A_u^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_u^{(L)}}\\right)$.\n    - 右侧板索引 $i \\in \\{N-W_R,\\dots,N-1\\}$：\n      - $T_i \\leftarrow T_i^{\\mathrm{lin}} + A_T^{(R)} \\exp\\left(-\\frac{L - x_i}{\\ell_T^{(R)}}\\right)$,\n      - $u_i \\leftarrow u_i^{\\mathrm{lin}} + A_u^{(R)} \\exp\\left(-\\frac{L - x_i}{\\ell_u^{(R)}}\\right)$.\n    - 所有其他索引（体相）在添加噪声前为 $T_i \\leftarrow T_i^{\\mathrm{lin}}$ 和 $u_i \\leftarrow u_i^{\\mathrm{lin}}$。\n  - 应用于所有单元的平滑空间小噪声：\n    - $T_i \\leftarrow T_i + A_T^{\\mathrm{noise}} \\sin\\!\\left(2\\pi k_T \\frac{x_i}{L}\\right)$,\n    - $u_i \\leftarrow u_i + A_u^{\\mathrm{noise}} \\sin\\!\\left(2\\pi k_u \\frac{x_i}{L}\\right)$.\n- 使用以下三个测试用例，全部采用国际单位制 (SI units)：\n  - 测试用例 1 (理想情况):\n    - $L = 50 \\times 10^{-9} \\,\\mathrm{m}$, $N = 50$, $W_L = 6$, $W_R = 6$, $g = 1$,\n    - $T_0 = 400 \\,\\mathrm{K}$, $a_T^{\\mathrm{true}} = -2.0 \\times 10^{9} \\,\\mathrm{K}/\\mathrm{m}$,\n    - $u_0 = 0 \\,\\mathrm{m}/\\mathrm{s}$, $a_u^{\\mathrm{true}} = 1.0 \\times 10^{7} \\,\\mathrm{s}^{-1}$,\n    - $A_T^{(L)} = 10 \\,\\mathrm{K}$, $\\ell_T^{(L)} = 2 \\Delta x$; $A_T^{(R)} = -8 \\,\\mathrm{K}$, $\\ell_T^{(R)} = 2 \\Delta x$,\n    - $A_u^{(L)} = 0.02 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(L)} = 2 \\Delta x$; $A_u^{(R)} = -0.015 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(R)} = 2 \\Delta x$,\n    - $A_T^{\\mathrm{noise}} = 0.5 \\,\\mathrm{K}$ with $k_T = 7$, $A_u^{\\mathrm{noise}} = 0.002 \\,\\mathrm{m}/\\mathrm{s}$ with $k_u = 5$.\n  - 测试用例 2 (不对称板和相反梯度):\n    - $L = 100 \\times 10^{-9} \\,\\mathrm{m}$, $N = 80$, $W_L = 4$, $W_R = 10$, $g = 1$,\n    - $T_0 = 300 \\,\\mathrm{K}$, $a_T^{\\mathrm{true}} = 1.2 \\times 10^{9} \\,\\mathrm{K}/\\mathrm{m}$,\n    - $u_0 = 0.1 \\,\\mathrm{m}/\\mathrm{s}$, $a_u^{\\mathrm{true}} = -5.0 \\times 10^{6} \\,\\mathrm{s}^{-1}$,\n    - $A_T^{(L)} = -12 \\,\\mathrm{K}$, $\\ell_T^{(L)} = 1.5 \\Delta x$; $A_T^{(R)} = 6 \\,\\mathrm{K}$, $\\ell_T^{(R)} = 1.5 \\Delta x$,\n    - $A_u^{(L)} = 0.01 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(L)} = 1.5 \\Delta x$; $A_u^{(R)} = -0.01 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(R)} = 1.5 \\Delta x$,\n    - $A_T^{\\mathrm{noise}} = 1.0 \\,\\mathrm{K}$ with $k_T = 9$, $A_u^{\\mathrm{noise}} = 0.001 \\,\\mathrm{m}/\\mathrm{s}$ with $k_u = 4$.\n  - 测试用例 3 (最小板和更强的边界层振幅):\n    - $L = 40 \\times 10^{-9} \\,\\mathrm{m}$, $N = 40$, $W_L = 1$, $W_R = 1$, $g = 1$,\n    - $T_0 = 350 \\,\\mathrm{K}$, $a_T^{\\mathrm{true}} = -1.0 \\times 10^{9} \\,\\mathrm{K}/\\mathrm{m}$,\n    - $u_0 = 0 \\,\\mathrm{m}/\\mathrm{s}$, $a_u^{\\mathrm{true}} = 2.0 \\times 10^{6} \\,\\mathrm{s}^{-1}$,\n    - $A_T^{(L)} = 20 \\,\\mathrm{K}$, $\\ell_T^{(L)} = 1 \\Delta x$; $A_T^{(R)} = -15 \\,\\mathrm{K}$, $\\ell_T^{(R)} = 1 \\Delta x$,\n    - $A_u^{(L)} = 0.03 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(L)} = 1 \\Delta x$; $A_u^{(R)} = -0.02 \\,\\mathrm{m}/\\mathrm{s}$, $\\ell_u^{(R)} = 1 \\Delta x$,\n    - $A_T^{\\mathrm{noise}} = 0.2 \\,\\mathrm{K}$ with $k_T = 6$, $A_u^{\\mathrm{noise}} = 0.0005 \\,\\mathrm{m}/\\mathrm{s}$ with $k_u = 3$.\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有三个测试用例的结果，形式为列表的列表，每个内部列表均按上述指定顺序排列。对所有数字使用小数点后六位的科学记数法。例如，一个有效的输出形状是\n  - $[[a_T^{(1)},a_u^{(1)},J_T^{(L,1)},J_T^{(R,1)},J_u^{(L,1)},J_u^{(R,1)},D_T^{(L,1)},D_T^{(R,1)},D_u^{(L,1)},D_u^{(R,1)}],[\\dots],[\\dots]]$.\n所有梯度必须以指定单位（$\\mathrm{K}/\\mathrm{m}$ 和 $\\mathrm{s}^{-1}$）表示，跳跃以（$\\mathrm{K}$ 和 $\\mathrm{m}/\\mathrm{s}$）表示，偏差以无量纲十进制形式表示。程序必须精确打印一行：如上所述的单个聚合列表，无任何附加文本。",
            "solution": "所提出的问题在科学上是合理的、适定的，并且在计算上是可行的。它涉及分析合成数据，这些数据模拟了在热梯度和速度梯度下流体板的非平衡分子动力学 (NEMD) 模拟结果。每个测试用例的解决方案都需要一个两阶段过程：首先，生成指定的数据剖面；其次，分析这些剖面以提取物理量。\n\n解决该问题的系统方法如下：\n\n首先，对于每个测试用例，将长度为 $L$ 的一维空间域离散为 $N$ 个单元。每个单元 $i$（对于 $i \\in \\{0, \\dots, N-1\\}$）的中心坐标计算为 $x_i = (i + \\frac{1}{2})\\Delta x$，其中单元宽度为 $\\Delta x = L/N$。\n\n其次，合成逼真的温度 $T_i$ 和速度 $u_i$ 剖面。该过程首先根据提供的真实梯度 ($a_T^{\\mathrm{true}}$, $a_u^{\\mathrm{true}}$) 和截距 ($T_0$, $u_0$) 创建理想的线性体相剖面：\n$$T_i^{\\mathrm{lin}} = T_0 + a_T^{\\mathrm{true}} x_i$$\n$$u_i^{\\mathrm{lin}} = u_0 + a_u^{\\mathrm{true}} x_i$$\n为了模拟边界处恒温器的局部非线性效应，在恒温区域内的这些线性剖面上添加指数偏差项。对于左侧恒温板，包含索引 $i \\in \\{0, \\dots, W_L-1\\}$，场被修改为：\n$$T_i \\leftarrow T_i^{\\mathrm{lin}} + A_T^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_T^{(L)}}\\right)$$\n$$u_i \\leftarrow u_i^{\\mathrm{lin}} + A_u^{(L)} \\exp\\left(-\\frac{x_i}{\\ell_u^{(L)}}\\right)$$\n对右侧恒温板，覆盖索引 $i \\in \\{N-W_R, \\dots, N-1\\}$，应用类似的修改，使用相应的右侧参数。最后，为了表示分子动力学固有的统计波动，在整个域的所有单元中，为温度场和速度场都添加了一个小的、空间平滑的正弦噪声项。\n\n第三，分析阶段从识别板的体相区域开始。该区域的定义是排除两端的恒温板（左侧 $W_L$ 个单元，右侧 $W_R$ 个单元）以及每个板旁边额外的 $g=1$ 个保护区域单元。最终的体相拟合区域由单元索引 $i \\in \\{W_L+g, \\dots, N-W_R-g-1\\}$ 组成。\n\n第四，在这个已识别的体相区域内，采用普通最小二乘 (OLS) 回归来拟合线性模型 $T(x) \\approx a_T x + b_T$ 和 $u(x) \\approx a_u x + b_u$。这可以通过使用 `numpy.polyfit` 并将次数设置为 $1$ 来完成。这些拟合的斜率 $a_T$ 和 $a_u$ 分别代表数值上提取的体相热梯度 ($dT/dx$) 和速度梯度 ($du/dx$) 。\n\n第五，量化边界附近与这种理想体相行为的偏差。计算两个指标：\n1.  界面跳跃，它测量了保护区域和体相之间界面处的局部偏差。它被计算为在每一侧第一个体相单元处，测量数据与线性拟合预测值之间的残差。对于左侧索引 $i_L = W_L + g$，跳跃为 $J_T^{(L)} = T_{i_L} - (a_T x_{i_L} + b_T)$ 和 $J_u^{(L)} = u_{i_L} - (a_u x_{i_L} + b_u)$。在右侧索引 $i_R = N-W_R-g-1$ 处进行类似的计算。\n2.  归一化的均方根 (RMS) 偏差，它量化了恒温区域内的整体非线性。对于每个板（左侧：$i \\in \\{0,\\dots,W_L-1\\}$；右侧：$i \\in \\{N-W_R,\\dots,N-1\\}$），计算测量数据 ($T_i, u_i$) 和外推的体相拟合 ($a_T x_i + b_T, a_u x_i + b_u$) 之间残差的 RMS。然后，此 RMS 值通过整个域上体相场变化的总幅度（温度为 $|a_T|L$，速度为 $|a_u|L$）进行归一化，得到无量纲偏差指标 $D_T^{(L)}$、$D_T^{(R)}$、$D_u^{(L)}$ 和 $D_u^{(R)}$。\n\n将此完整过程系统地应用于三个测试用例中的每一个，并收集每个案例的十个指定输出量并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the processing of all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"L\": 50e-9, \"N\": 50, \"W_L\": 6, \"W_R\": 6, \"g\": 1,\n            \"T0\": 400.0, \"a_T_true\": -2.0e9,\n            \"u0\": 0.0, \"a_u_true\": 1.0e7,\n            \"A_T_L\": 10.0, \"l_T_L_factor\": 2.0,\n            \"A_T_R\": -8.0, \"l_T_R_factor\": 2.0,\n            \"A_u_L\": 0.02, \"l_u_L_factor\": 2.0,\n            \"A_u_R\": -0.015, \"l_u_R_factor\": 2.0,\n            \"A_T_noise\": 0.5, \"k_T\": 7.0,\n            \"A_u_noise\": 0.002, \"k_u\": 5.0,\n        },\n        # Test case 2\n        {\n            \"L\": 100e-9, \"N\": 80, \"W_L\": 4, \"W_R\": 10, \"g\": 1,\n            \"T0\": 300.0, \"a_T_true\": 1.2e9,\n            \"u0\": 0.1, \"a_u_true\": -5.0e6,\n            \"A_T_L\": -12.0, \"l_T_L_factor\": 1.5,\n            \"A_T_R\": 6.0, \"l_T_R_factor\": 1.5,\n            \"A_u_L\": 0.01, \"l_u_L_factor\": 1.5,\n            \"A_u_R\": -0.01, \"l_u_R_factor\": 1.5,\n            \"A_T_noise\": 1.0, \"k_T\": 9.0,\n            \"A_u_noise\": 0.001, \"k_u\": 4.0,\n        },\n        # Test case 3\n        {\n            \"L\": 40e-9, \"N\": 40, \"W_L\": 1, \"W_R\": 1, \"g\": 1,\n            \"T0\": 350.0, \"a_T_true\": -1.0e9,\n            \"u0\": 0.0, \"a_u_true\": 2.0e6,\n            \"A_T_L\": 20.0, \"l_T_L_factor\": 1.0,\n            \"A_T_R\": -15.0, \"l_T_R_factor\": 1.0,\n            \"A_u_L\": 0.03, \"l_u_L_factor\": 1.0,\n            \"A_u_R\": -0.02, \"l_u_R_factor\": 1.0,\n            \"A_T_noise\": 0.2, \"k_T\": 6.0,\n            \"A_u_noise\": 0.0005, \"k_u\": 3.0,\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        case_results = process_case(params)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    inner_lists_str = []\n    for res_list in all_results:\n        formatted_nums = [f\"{num:.6e}\" for num in res_list]\n        inner_lists_str.append(f\"[{','.join(formatted_nums)}]\")\n    \n    print(f\"[{','.join(inner_lists_str)}]\")\n\ndef process_case(params: dict) -> list:\n    \"\"\"\n    Generates synthetic data and performs analysis for a single test case.\n    \"\"\"\n    L = params[\"L\"]\n    N = params[\"N\"]\n    W_L = params[\"W_L\"]\n    W_R = params[\"W_R\"]\n    g = params[\"g\"]\n    \n    # Step 1: Construct coordinates and generate data profiles\n    delta_x = L / N\n    i_coords = np.arange(N)\n    x = (i_coords + 0.5) * delta_x\n\n    # Baseline linear fields\n    T = params[\"T0\"] + params[\"a_T_true\"] * x\n    u = params[\"u0\"] + params[\"a_u_true\"] * x\n\n    # Add thermostat-localized deviations\n    # Left slab\n    if W_L > 0:\n      l_slab_indices = np.arange(W_L)\n      x_l_slab = x[l_slab_indices]\n      l_T_L = params[\"l_T_L_factor\"] * delta_x\n      l_u_L = params[\"l_u_L_factor\"] * delta_x\n      T[l_slab_indices] += params[\"A_T_L\"] * np.exp(-x_l_slab / l_T_L)\n      u[l_slab_indices] += params[\"A_u_L\"] * np.exp(-x_l_slab / l_u_L)\n\n    # Right slab\n    if W_R > 0:\n      r_slab_indices = np.arange(N - W_R, N)\n      x_r_slab = x[r_slab_indices]\n      l_T_R = params[\"l_T_R_factor\"] * delta_x\n      l_u_R = params[\"l_u_R_factor\"] * delta_x\n      T[r_slab_indices] += params[\"A_T_R\"] * np.exp(-(L - x_r_slab) / l_T_R)\n      u[r_slab_indices] += params[\"A_u_R\"] * np.exp(-(L - x_r_slab) / l_u_R)\n\n    # Add spatially smooth noise to all bins\n    T += params[\"A_T_noise\"] * np.sin(2 * np.pi * params[\"k_T\"] * x / L)\n    u += params[\"A_u_noise\"] * np.sin(2 * np.pi * params[\"k_u\"] * x / L)\n\n    # Step 2  3: Identify bulk region and perform OLS fit\n    bulk_start_idx = W_L + g\n    bulk_end_idx = N - W_R - g - 1\n    bulk_indices = np.arange(bulk_start_idx, bulk_end_idx + 1)\n    \n    x_bulk = x[bulk_indices]\n    T_bulk = T[bulk_indices]\n    u_bulk = u[bulk_indices]\n\n    a_T, b_T = np.polyfit(x_bulk, T_bulk, 1)\n    a_u, b_u = np.polyfit(x_bulk, u_bulk, 1)\n\n    # Step 4: Quantify deviations from the bulk fit\n    # Interfacial jumps at the first/last bulk bin\n    i_L = W_L + g\n    T_fit_L = a_T * x[i_L] + b_T\n    J_T_L = T[i_L] - T_fit_L\n    u_fit_L = a_u * x[i_L] + b_u\n    J_u_L = u[i_L] - u_fit_L\n\n    i_R = N - W_R - g - 1\n    T_fit_R = a_T * x[i_R] + b_T\n    J_T_R = T[i_R] - T_fit_R\n    u_fit_R = a_u * x[i_R] + b_u\n    J_u_R = u[i_R] - u_fit_R\n\n    # RMS of residuals in thermostatted slabs, normalized\n    def rms(v):\n        return np.sqrt(np.mean(np.square(v)))\n\n    # Left slab RMSD\n    if W_L > 0:\n        x_slab_L = x[l_slab_indices]\n        T_res_L = T[l_slab_indices] - (a_T * x_slab_L + b_T)\n        u_res_L = u[l_slab_indices] - (a_u * x_slab_L + b_u)\n        D_T_L = rms(T_res_L) / (np.abs(a_T) * L)\n        D_u_L = rms(u_res_L) / (np.abs(a_u) * L)\n    else:\n        D_T_L, D_u_L = 0.0, 0.0\n\n    # Right slab RMSD\n    if W_R > 0:\n        x_slab_R = x[r_slab_indices]\n        T_res_R = T[r_slab_indices] - (a_T * x_slab_R + b_u)\n        u_res_R = u[r_slab_indices] - (a_u * x_slab_R + b_u)\n        D_T_R = rms(T_res_R) / (np.abs(a_T) * L)\n        D_u_R = rms(u_res_R) / (np.abs(a_u) * L)\n    else:\n        D_T_R, D_u_R = 0.0, 0.0\n\n    # Step 5: Return results in the specified order\n    return [a_T, a_u, J_T_L, J_T_R, J_u_L, J_u_R, D_T_L, D_T_R, D_u_L, D_u_R]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "计算出一个输运系数值仅仅是研究的开始，更关键的是确保该结果的科学严谨性。这项实践将挑战你设计一个全面的NEMD模拟验证方案，以系统性地评估结果的可靠性。你将学习如何检查从数值积分器的稳定性、恒温器的统计正确性，到系统对线性响应的遵循程度以及结果的可复现性等一系列关键问题 ()，从而掌握确保模拟质量的必要技能。",
            "id": "3469000",
            "problem": "一位研究人员使用非平衡分子动力学 (NEMD) 方法，通过在模拟单元两端的两个恒温槽区域之间施加稳定的通量，来计算晶体的输运系数。在这两个恒温区域之间是一个非恒温的体区。该系统使用速度Verlet算法进行积分，时间步长为 $\\Delta t$，并在与施加的梯度正交的方向上应用周期性边界条件。测量目标是在线性响应区内，由受控热力学力驱动的稳态通量 $J$（例如，服从傅里叶定律的温度梯度 $\\nabla T$ 或服从欧姆定律的电场 $E$）。在报告输运系数之前，研究人员必须验证四个方面：能量守恒（在适用的情况下）、恒温器功效、体区内的梯度线性以及独立运行之间的可复现性。\n\n仅从经典力学（牛顿定律）和统计力学（系综定义和能量均分）的基本原理出发，为所述的NEMD设置选择一个能以科学上合理且自洽的方式正确处理所有四个方面的验证方案。\n\nA. 在施加外场的同时，对整个系统在微正则系综（粒子数、体积和能量恒定）中进行一次长时间的生产运行，并通过检查总能量 $E$ 在数值容差范围内保持恒定来验证能量守恒。通过确保整个模拟单元中的瞬时动能温度 $T(t)$ 在所有时间都等于目标温度 $T_{0}$ 来确认恒温器功效。通过将稳态温度分布 $T(x)$ 拟合到二次多项式并确认存在非零曲率来评估梯度线性。报告从这次单次运行中得到的输运系数。\n\nB. 在等温等压系综（粒子数、压力和温度恒定）中平衡系统，然后切换到NEMD，在边界区域使用 Nosé–Hoover 恒温器，在体区不使用恒温器。通过确认尽管施加了外场，体区的总能量 $E_{\\text{bulk}}$ 在稳态期间保持恒定来验证能量守恒。通过检查体区内的平均动能温度 $\\langle T \\rangle$ 等于恒温槽的设定点温度 $T_{0}$ 来确认恒温器功效。通过仅在恒温槽附近将 $T(x)$ 与线性拟合进行比较来评估梯度线性。如果单次运行的估计值在先前文献值的 $5\\%$ 范围内，则报告该输运系数。\n\nC. 在NEMD期间对所有原子应用郎之万恒温器，以在各处维持目标温度 $T_{0}$。通过确保瞬时动能 $K(t)$ 恒定来验证能量守恒。通过施加一个大的温差 $\\Delta T$ 以使 $|\\nabla T|$ 最大化，并确认 $T(x)$ 中指示强驱动的曲率来评估梯度线性。跳过可复现性检查，因为随机恒温器可确保在一次运行中实现遍历采样。\n\nD. 通过运行零场微正则测试（无外部驱动，无任何恒温器）来验证积分器，并确认总能量 $E$ 在严格的容差内守恒，能量漂移的标度为 $\\mathcal{O}(\\Delta t^{2})$。对于NEMD，仅对恒温槽区域应用恒温器；体区不进行恒温。通过确认恒温槽区域维持目标温度 $T_{0}$，恒温区域中的速度分布是麦克斯韦-玻尔兹曼分布 $P(v)\\propto \\exp\\!\\left(-m v^{2}/(2 k_{B} T_{0})\\right)$，并且能量均分成立，即对于 $f$ 个二次自由度，$\\langle K\\rangle = (f/2)\\,k_{B} T_{0}$，来验证恒温器功效。通过以下方式验证梯度线性：(i) 测量稳态分布 $T(x)$ 并确认其在体区内（不包括 Kapitza 跳跃区域）是线性的，以及 (ii) 使用至少两个具有不同小 $\\Delta T$ 或场强的驱动进行模拟，并证明在不确定性范围内，$J$ 与驱动力呈线性关系（例如，$J\\propto \\nabla T$）。通过执行多次使用不同初始条件或随机种子的统计独立运行来建立可复现性，为每次运行计算输运系数，通过使用考虑自相关的分块长度进行分块平均来估计不确定性，并确认各次运行之间的一致性（例如，重叠的置信区间和在重新分块下稳定的均值）。\n\nE. 在NEMD期间，使用周期性动能重标度法在各处维持 $T_{0}$。通过确保扩展能量（系统加上重标度功）恒定来验证能量守恒。通过将 $T(x)$ 拟合到二次函数并接受小的曲率作为数值噪声来评估梯度线性。通过使用相同的初始构型重复分析，并报告两次相同运行的平均值来建立可复现性。\n\n选择一个为所述NEMD协议提出的，在科学上正确和完整的验证方案，该方案处理了适用的能量守恒、恒温器功效、梯度线性和可复现性。",
            "solution": "问题描述了一个标准的边界驱动非平衡分子动力学 (NEMD) 模拟，该模拟旨在计算线性响应区内晶体的输运系数。该设置包括恒温槽和一个非恒温的体区，稳态通量被驱动通过该体区。问题要求找出正确的验证方案，以解决四个关键方面：能量守恒、恒温器功效、梯度线性和可复现性。该问题具有科学依据，提法明确且客观。它描述了计算材料科学中一种常用且有效的方法。因此，问题陈述是有效的，可以从统计力学和数值模拟的基本原理推导出解决方案。\n\n一个正确的验证方案必须遵循以下原则：\n\n1.  **能量守恒**：在使用恒温器的NEMD模拟中，能量与外部热源持续交换以维持非平衡稳态。因此，模拟单元的总能量**不是**一个守恒量。能量守恒原理应被用来验证数值积分器（例如速度Verlet算法）本身。正确的做法是进行一次初步的微正则 ($NVE$) 系综模拟——没有恒温器，也没有外部驱动力——并验证系统总能量在长时间内以高精度守恒。对于像速度Verlet这样的辛积分器，任何残余的能量漂移都应随时间步长的平方（即 $\\mathcal{O}(\\Delta t^{2})$）而缩放。\n\n2.  **恒温器功效**：恒温器仅应用于恒温槽区域，作为输运量（如热量）的源和汇。它们的功效必须*在那些特定区域*进行检查。一个有效的检查涉及多个标准：\n    *   每个恒温槽区域内粒子的时间平均动能温度必须与其目标设定点温度 $T_{0}$ 相匹配。\n    *   由于温度是一个统计量，需要进行更严格的检查，以确保恒温器生成了正确的正则系综统计数据。恒温区域中粒子的速度分布应符合麦克斯韦-玻尔兹曼分布，$P(v) \\propto \\exp(-m v^{2} / (2 k_B T_{0}))$。\n    *   因此，能量均分定理必须成立，即每个二次自由度 $f$ 的平均动能为 $\\langle K \\rangle = (f/2) k_B T_{0}$。\n    期望非恒温体区的温度与恒温槽的温度相匹配是错误的，因为模拟的目的是在该区域建立一个梯度。\n\n3.  **梯度线性与线性响应**：问题指明测量是在线性响应区内进行的。对于热输运，这意味着傅里叶定律 $J = -\\kappa \\nabla T$ 成立。对于一个稳态通量 $J$ 和一个在温度范围内热导率 $\\kappa$ 近似恒定的材料，温度梯度 $\\nabla T$ 必须是恒定的。这意味着沿输运方向的温度分布 $T(x)$ 在材料体区内必须是线性的。由于界面（Kapitza）电阻，温度分布通常在恒温槽和体区之间的界面处表现出急剧的跳跃或非线性。在拟合梯度时必须排除这些区域。此外，为了确认在线性响应区内操作，必须证明通量 $J$ 与驱动力（例如 $\\nabla T$）成正比。这需要对至少两个不同的小驱动力大小进行模拟，并验证所产生的通量呈线性关系。单次模拟无法确认线性响应。\n\n4.  **可复现性与不确定性量化**：分子动力学模拟是确定性的但也是混沌的，这意味着初始条件的微小变化会导致轨迹发散。一个科学上有效的结果必须是可复现的，并附有其统计不确定性的稳健估计。仅依赖单次模拟运行是不够的。标准方案是进行多次（>2次）统计独立的模拟，通常通过使用不同的初始随机速度来实现。为每次运行计算输运系数。最终报告的值是这些独立结果的平均值，不确定性则根据它们的方差来估计。在每次运行内部，可以使用分块平均等技术来估计该单次轨迹平均值的不确定性，但这必须考虑数据中的时间相关性。在独立运行之间比较结果是检验可复现性的最严格方法。\n\n基于这些原则，我们评估每个选项：\n\n**选项A**：该选项存在根本性缺陷。它错误地提议在微正则系综中运行NEMD模拟并检查总能量守恒，这在边界驱动的NEMD设置中是不可能的，因为能量在不断地被加入和移除。它错误地指出瞬时温度应该处处恒定，这与创建梯度的目标相矛盾。它还错误地建议温度分布中的*非零曲率*是可取的，而在线性响应区，线性才是恒定热导率的预期特征。它依赖于单次运行，未能解决可复现性问题。**不正确**。\n\n**选项B**：该选项包含多个错误。它错误地提议通过检查体区能量（$E_{\\text{bulk}}$）来验证能量守恒；净能量通量穿过体区，因此其能量不守恒。它错误地识别了恒温器功效的检查方法，将其应用于体区而不是恒温槽。它错误地建议在恒温槽附近拟合温度分布的线性，而这恰恰是非线性Kapitza效应预期的区域。最后，它提出了一个不科学的验证标准，即与文献值进行比较，并且未能为可复现性执行独立运行。**不正确**。\n\n**选项C**：该选项描述的设置——将所有原子恒温至单一温度——与创建梯度的直接NEMD方法不兼容。这将导致一个平衡系统，其中不存在稳态通量。其验证步骤也是错误的：在郎之万恒温器下，瞬时动能不是恒定的；当线性响应需要小驱动时，它却使用了大驱动；当预期是线性时，它却寻求曲率。它错误地忽略了可复现性检查。**不正确**。\n\n**选项D**：该选项提出了一个完全正确和全面的验证方案。\n1.  **能量守恒**：它正确地指出，应在初步的微正则 ($NVE$) 运行中检查能量守恒以验证积分器，并指出了预期的误差标度 $\\mathcal{O}(\\Delta t^2)$。\n2.  **恒温器功效**：它正确地指明恒温器仅在恒温槽上，并提出了一个严格的检查方法，包括维持平均温度，确认麦克斯韦-玻尔兹曼分布，以及验证*在恒温槽区域内*的能量均分。\n3.  **梯度线性**：它正确地描述了检查*体区内*的线性温度分布，排除了界面区域。至关重要的是，它包含了必要的步骤，即在多个小驱动力下进行模拟，以确认通量和梯度之间的线性关系，这正是线性响应区的定义。\n4.  **可复现性**：它正确地要求执行多次具有不同初始条件的独立运行，并概述了估计不确定性和确认一致性的合理程序。该方案符合该领域的既定最佳实践。**正确**。\n\n**选项E**：该选项提议在各处使用粗略的速度重标度恒温器，这与选项C一样，是用于产生输运梯度的错误设置。它误用了扩展能量的概念。它建议将温度分布中的曲率当作噪声接受，这是糟糕的科学实践。最严重的是，其可复现性测试——对两次相同的运行求平均——在科学上是无意义的，并显示出对统计独立性的根本性误解。**不正确**。\n\n总之，选项D是唯一一个为所描述的NEMD模拟验证提供了科学上合理、严谨和完整方案的选项。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "分子动力学模拟总是在有限尺寸的体系中进行，但我们的目标往往是预测宏观体材料的性质。这项实践聚焦于一个关键的高级分析技术——有限尺寸标度法，它能帮助我们消除由边界散射等效应引入的系统误差。你将学习如何通过分析有效热导率 $\\kappa(L)$ 对系统尺寸 $L$ 的依赖关系，来外推出真实的体相热导率 $\\kappa_\\infty$ 和声子平均自由程 $\\lambda$ ()，这是连接纳米尺度模拟与宏观材料性能的重要桥梁。",
            "id": "3468983",
            "problem": "您正在使用非平衡分子动力学 (NEMD) 分析一维纳米线中的非平衡稳态热输运。目标是通过对不同线长的有限尺寸标度，推断体热导率和特征声子平均自由程。从线性响应原理出发，热通量 $q$ 通过傅里叶定律及其非局域推广与温度梯度相关联。在均匀介质中，局域极限为 $q(z) = -\\kappa_\\infty \\frac{dT}{dz}$，其中 $\\kappa_\\infty$ 是体（无限长）热导率。在长度为 $L$ 的有限纳米尺度系统中，非局域性和边界散射会改变有效热导率。在线性响应下，当非局域性存在单一主导长度尺度时，主导阶的有限尺寸修正与 $L^{-1}$ 成比例。具体而言，有效热导率的形式为 $\\kappa(L) = \\kappa_\\infty \\left(1 + \\frac{a}{L}\\right)$，其中 $a$ 是一个长度，在所述假设下，其物理意义可解释为有效声子平均自由程尺度。\n\n您的任务是编写一个程序，针对每个测试用例，通过拟合关于变量 $x = 1/L$ 的线性模型 $\\kappa(L) = b + m x$（其中 $b = \\kappa_\\infty$ 且 $m = \\kappa_\\infty a$）来估计 $\\kappa_\\infty$ 和 $a$。然后，通过认定 $\\lambda = a$ 来计算推断出的声子平均自由程 $\\lambda$。使用普通最小二乘法，并假设所提供数据的不确定度是均匀的。\n\n要求：\n- 使用线性回归公式 $y_i = b + m x_i$（其中 $x_i = 1/L_i$ 且 $y_i = \\kappa(L_i)$）从每个测试用例的数据中确定 $b$ 和 $m$，然后设定 $\\kappa_\\infty = b$，$a = \\frac{m}{b}$ 以及 $\\lambda = a$。\n- 以瓦特每米开尔文 (W/(m·K)) 为单位表示 $\\kappa_\\infty$，以纳米 (nm) 为单位表示 $\\lambda$。将报告的每个浮点数四舍五入到六位小数。\n- 自变量 $L$ 以纳米 (nm) 为单位提供，所有报告的长度也必须以纳米 (nm) 为单位。热导率以 W/(m·K) 为单位提供。\n\n测试套件：\n- 用例 $1$（正常路径，中等长度）：$L = [\\,100,\\,200,\\,400,\\,800\\,]$ nm，$\\kappa(L) = [\\,300,\\,200,\\,150,\\,125\\,]$ W/(m·K)。\n- 用例 $2$（大 $L$ 区间）：$L = [\\,1000,\\,2000,\\,4000,\\,8000\\,]$ nm，$\\kappa(L) = [\\,375,\\,312.5,\\,281.25,\\,265.625\\,]$ W/(m·K)。\n- 用例 $3$（短 $L$ 倾向弹道输运区间）：$L = [\\,50,\\,75,\\,100,\\,150\\,]$ nm，$\\kappa(L) = [\\,90,\\,70,\\,60,\\,50\\,]$ W/(m·K)。\n- 用例 $4$（最少数据，两点）：$L = [\\,200,\\,400\\,]$ nm，$\\kappa(L) = [\\,120,\\,100\\,]$ W/(m·K)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个用例，按用例顺序输出 $(\\kappa_\\infty, \\lambda)$ 对，并展开成一个列表。例如，输出必须类似于 $[r_1,r_2,\\dots]$，其中对于用例 $k$，$r_{2k-1} = \\kappa_\\infty$（单位 W/(m·K)），$r_{2k} = \\lambda$（单位 nm），每个浮点数四舍五入到六位小数。",
            "solution": "该问题已经过评估并被认为是有效的。它在计算物理学中分析模拟数据的背景下具有科学依据，提供了一个定义明确的数学模型和清晰、客观的参数估计程序。该问题是自包含的，所提供的数据与指定模型内部一致，从而能够得出唯一且有意义的解。\n\n目标是通过分析一维系统中有效热导率 $\\kappa(L)$ 的有限尺寸依赖性，来确定体热导率 $\\kappa_\\infty$ 和特征声子平均自由程 $\\lambda$。该分析基于所提供的模型，该模型将有限长度 $L$ 下的有效热导率与体热导率 $\\kappa_\\infty$ 联系起来：\n$$ \\kappa(L) = \\kappa_\\infty \\left(1 + \\frac{a}{L}\\right) $$\n在此， $a$ 是一个具有长度单位的参数，它将被认定为声子平均自由程 $\\lambda$。该模型描述了一个系统中，电导率的主导阶有限尺寸修正与 $L^{-1}$ 成比例。\n\n为了估计参数 $\\kappa_\\infty$ 和 $a$，我们对模型进行线性化处理。通过定义自变量 $x = 1/L$ 和因变量 $y = \\kappa(L)$，该方程可以重写为标准线性方程形式 $y = mx + b$：\n$$ \\kappa(L) = \\kappa_\\infty + (\\kappa_\\infty a) \\frac{1}{L} $$\n通过将其与通用线性形式 $y = b + mx$ 进行比较，我们可以在物理参数和回归系数之间建立以下对应关系：\n- 截距 $b$ 对应于体热导率：$\\kappa_\\infty = b$。\n- 斜率 $m$ 与两个参数相关：$m = \\kappa_\\infty a$。\n\n问题要求使用普通最小二乘法 (OLS) 对给定的数据集 $(x_i, y_i)$（其中 $x_i = 1/L_i$ 且 $y_i = \\kappa(L_i)$）找到斜率 $m$ 和截距 $b$ 的最佳拟合值。$n$ 个数据点样本的 OLS 估计量 $m$ 和 $b$ 由以下公式给出：\n$$ m = \\frac{n \\sum_{i=1}^{n} x_i y_i - (\\sum_{i=1}^{n} x_i)(\\sum_{i=1}^{n} y_i)}{n \\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2} $$\n$$ b = \\bar{y} - m\\bar{x} = \\frac{1}{n} \\left( \\sum_{i=1}^{n} y_i - m \\sum_{i=1}^{n} x_i \\right) $$\n一旦确定了 $m$ 和 $b$，我们就可以求解物理参数。从截距我们直接得到 $\\kappa_\\infty$：\n$$ \\kappa_\\infty = b $$\n然后，使用斜率的表达式，假设 $\\kappa_\\infty \\neq 0$，我们可以解出参数 $a$：\n$$ a = \\frac{m}{\\kappa_\\infty} = \\frac{m}{b} $$\n问题指出，声子平均自由程 $\\lambda$ 应被认定为参数 $a$，因此：\n$$ \\lambda = a = \\frac{m}{b} $$\n每个测试用例中提供的数据集都是为了完美满足线性模型而构建的。因此，OLS 回归将产生精确拟合，我们可以通过求解任意两个数据点的线性方程组，以代数方式确定参数 $m$ 和 $b$。\n\n我们现在将此程序应用于每个测试用例。\n\n用例 $1$：$L = [\\,100,\\,200,\\,400,\\,800\\,]$ nm 且 $\\kappa(L) = [\\,300,\\,200,\\,150,\\,125\\,]$ W/(m·K)。\n我们选择前两个数据点。设 $x_1 = 1/100$ nm$^{-1}$ 且 $y_1 = 300$ W/(m·K)，以及 $x_2 = 1/200$ nm$^{-1}$ 且 $y_2 = 200$ W/(m·K)。\n我们求解方程组：\n$$ 300 = b + m \\cdot \\frac{1}{100} $$\n$$ 200 = b + m \\cdot \\frac{1}{200} $$\n从第一个方程中减去第二个方程，得到 $100 = m(1/100 - 1/200) = m(1/200)$，得出 $m = 20000$ W·nm/(m·K)。\n将 $m$ 代入第一个方程：$300 = b + 20000/100 = b + 200$，得出 $b = 100$ W/(m·K)。\n因此，$\\kappa_\\infty = b = 100$ W/(m·K)。\n平均自由程为 $\\lambda = m/b = 20000/100 = 200$ nm。\n\n用例 $2$：$L = [\\,1000,\\,2000,\\,4000,\\,8000\\,]$ nm 且 $\\kappa(L) = [\\,375,\\,312.5,\\,281.25,\\,265.625\\,]$ W/(m·K)。\n使用前两个点（$x_1=1/1000$, $y_1=375$）和（$x_2=1/2000$, $y_2=312.5$）：\n$$ 375 = b + m \\cdot \\frac{1}{1000} $$\n$$ 312.5 = b + m \\cdot \\frac{1}{2000} $$\n从第一个方程中减去第二个方程，得到 $62.5 = m(1/2000)$，所以 $m = 125000$ W·nm/(m·K)。\n代回：$375 = b + 125000/1000 = b + 125$，得出 $b = 250$ W/(m·K)。\n因此，$\\kappa_\\infty = b = 250$ W/(m·K)。\n平均自由程为 $\\lambda = m/b = 125000/250 = 500$ nm。\n\n用例 $3$：$L = [\\,50,\\,75,\\,100,\\,150\\,]$ nm 且 $\\kappa(L) = [\\,90,\\,70,\\,60,\\,50\\,]$ W/(m·K)。\n使用前两个点（$x_1=1/50$, $y_1=90$）和（$x_2=1/75$, $y_2=70$）：\n$$ 90 = b + m \\cdot \\frac{1}{50} $$\n$$ 70 = b + m \\cdot \\frac{1}{75} $$\n从第一个方程得到 $m = 50(90 - b)$。从第二个方程得到 $m = 75(70 - b)$。\n令二者相等：$50(90 - b) = 75(70 - b) \\implies 4500 - 50b = 5250 - 75b \\implies 25b = 750$，所以 $b = 30$ W/(m·K)。\n那么 $m = 50(90 - 30) = 3000$ W·nm/(m·K)。\n因此，$\\kappa_\\infty = b = 30$ W/(m·K)。\n平均自由程为 $\\lambda = m/b = 3000/30 = 100$ nm。\n\n用例 $4$：$L = [\\,200,\\,400\\,]$ nm 且 $\\kappa(L) = [\\,120,\\,100\\,]$ W/(m·K)。\n只有两个点，直线被精确确定。设（$x_1=1/200$, $y_1=120$）和（$x_2=1/400$, $y_2=100$）：\n$$ 120 = b + m \\cdot \\frac{1}{200} $$\n$$ 100 = b + m \\cdot \\frac{1}{400} $$\n从第一个方程减去第二个方程：$20 = m(1/200 - 1/400) = m(1/400)$，所以 $m = 8000$ W·nm/(m·K)。\n代回：$100 = b + 8000/400 = b + 20$，得出 $b = 80$ W/(m·K)。\n因此，$\\kappa_\\infty = b = 80$ W/(m·K)。\n平均自由程为 $\\lambda = m/b = 8000/80 = 100$ nm。\n\n每个用例计算出的参数是：\n- 用例 $1$：$\\kappa_\\infty = 100$ W/(m·K)，$\\lambda = 200$ nm。\n- 用例 $2$：$\\kappa_\\infty = 250$ W/(m·K)，$\\lambda = 500$ nm。\n- 用例 $3$：$\\kappa_\\infty = 30$ W/(m·K)，$\\lambda = 100$ nm。\n- 用例 $4$：$\\kappa_\\infty = 80$ W/(m·K)，$\\lambda = 100$ nm。\n\n这些结果将按程序要求进行格式化和打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes finite-size scaling of thermal conductivity to infer bulk\n    conductivity and phonon mean free path using linear regression.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, moderate lengths)\n        ([100, 200, 400, 800], [300, 200, 150, 125]),\n        # Case 2 (large-L regime)\n        ([1000, 2000, 4000, 8000], [375, 312.5, 281.25, 265.625]),\n        # Case 3 (short-L ballistic-leaning regime)\n        ([50, 75, 100, 150], [90, 70, 60, 50]),\n        # Case 4 (minimal data, two points)\n        ([200, 400], [120, 100]),\n    ]\n\n    results = []\n    for L_vals, kappa_vals in test_cases:\n        # Convert input lists to NumPy arrays for vectorized operations.\n        # The data types are explicitly float to ensure floating point division.\n        L_np = np.array(L_vals, dtype=float)\n        kappa_np = np.array(kappa_vals, dtype=float)\n\n        # The model is kappa(L) = kappa_inf * (1 + a/L).\n        # This linearizes to kappa(L) = kappa_inf + (kappa_inf * a) * (1/L).\n        # We fit a line y = m*x + b, where:\n        # y = kappa(L)\n        # x = 1/L\n        # The regression coefficients are then identified as:\n        # b = kappa_inf\n        # m = kappa_inf * a\n        \n        x = 1.0 / L_np\n        y = kappa_np\n\n        # Perform ordinary least squares for a first-degree polynomial (a line)\n        # using numpy.polyfit. It returns the coefficients [m, b] for y = mx + b.\n        m, b = np.polyfit(x, y, 1)\n\n        # From the relationships derived above, calculate the physical parameters.\n        # kappa_inf is the y-intercept of the fit.\n        kappa_inf = b\n        \n        # The phonon mean free path lambda is identified with parameter 'a'.\n        # a = m / kappa_inf.\n        # A check for kappa_inf being close to zero is good practice, though not\n        # necessary for the provided test cases.\n        if np.isclose(kappa_inf, 0):\n            # This case implies zero bulk conductivity, which is physically\n            # unusual and would make 'a' and 'lambda' indeterminate.\n            lambda_mfp = np.nan\n        else:\n            a = m / kappa_inf\n            lambda_mfp = a\n            \n        results.append(kappa_inf)\n        results.append(lambda_mfp)\n\n    # Final print statement in the exact required format.\n    # The output is a single flattened list of [kappa_inf_1, lambda_1, kappa_inf_2, lambda_2, ...].\n    # Each float is rounded to six decimal places.\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```"
        }
    ]
}