{
    "hands_on_practices": [
        {
            "introduction": "At the core of crystal plasticity theory lies the criterion for slip activation, which determines how stress drives plastic flow. While the classical Schmid law provides a foundational starting point, many materials exhibit more complex yield behavior sensitive to pressure and other stress components. This practice  challenges you to design a computational benchmark that isolates these non-Schmid effects, providing a powerful method for discriminating between slip systems that would otherwise appear equally likely to activate.",
            "id": "3441899",
            "problem": "Construct a computational benchmark for Crystal Plasticity Finite Element (CPFE) modeling that isolates the role of non-Schmid effects in slip activation under small strain. Consider a single crystal with two slip systems, indexed by $\\alpha \\in \\{1,2\\}$, whose classical Schmid contributions are identical along a specified deviatoric loading direction, but whose non-Schmid sensitivities differ. The goal is to design a family of stress load paths that discriminate the first-activating system and to implement a program that predicts the first-activating slip system for a given path.\n\nStart from the following fundamental base:\n- The Cauchy stress tensor is $\\boldsymbol{\\sigma}$, and the hydrostatic pressure is $p = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$.\n- For slip system $\\alpha$, the slip direction is a unit vector $\\boldsymbol{s}^\\alpha$, the slip plane unit normal is $\\boldsymbol{m}^\\alpha$, and $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$.\n- The resolved shear stress is $\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$.\n- The normal stress on the slip plane is $\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$.\n- A non-Schmid augmented driving stress for activation is $\\psi^\\alpha = \\tau^\\alpha + a^\\alpha p + b^\\alpha \\sigma_{nn}^\\alpha$, where $a^\\alpha$ and $b^\\alpha$ are dimensionless non-Schmid coefficients that may depend on $\\alpha$.\n- Slip system $\\alpha$ activates when $|\\psi^\\alpha| = g^\\alpha$, where $g^\\alpha$ is the critical resolved shear stress.\n\nDesign the loading as a one-parameter family that mixes a fixed deviatoric tensor and a tunable hydrostatic component. Let the total stress be\n$$\n\\boldsymbol{\\sigma}(\\lambda; r) = \\lambda \\,\\boldsymbol{D} + r \\,\\lambda \\,\\boldsymbol{I},\n$$\nwhere $\\lambda \\ge 0$ scales the overall stress magnitude in megapascal, $\\boldsymbol{I}$ is the identity tensor, $\\boldsymbol{D}$ is a fixed deviatoric tensor, and $r$ is a real-valued path ratio that sets the hydrostatic-to-deviatoric proportion. Because $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$, the hydrostatic component does not contribute to the classical Schmid term.\n\nUse the following concrete, scientifically plausible specification:\n- Use the canonical deviatoric tensor\n$$\n\\boldsymbol{D} = \\operatorname{diag}\\!\\big(1,\\,-\\tfrac{1}{2},\\,-\\tfrac{1}{2}\\big).\n$$\n- Define two slip systems with identical Schmid contributions along $\\boldsymbol{D}$:\n  - System $1$: $\\boldsymbol{m}^1 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,1)$, $\\boldsymbol{s}^1 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,-1)$.\n  - System $2$: $\\boldsymbol{m}^2 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,-1)$, $\\boldsymbol{s}^2 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,1)$.\n- Verify that $ \\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2$.\n- Assign non-Schmid coefficients and critical resolved shear stresses:\n  - $a^1 = 0.3$, $b^1 = 0.1$, $g^1 = 50$ (in megapascal).\n  - $a^2 = -0.1$, $b^2 = 0.25$, $g^2 = 50$ (in megapascal).\n\nUnder this loading, for each slip system $\\alpha$, derive the linear dependence\n$$\n\\psi^\\alpha(\\lambda; r) = \\big[\\, \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha \\,+\\, a^\\alpha r \\,+\\, b^\\alpha \\big(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r \\big) \\,\\big] \\,\\lambda \\equiv K^\\alpha(r)\\,\\lambda,\n$$\nand compute the activation load level\n$$\n\\lambda_c^\\alpha(r) = \\frac{g^\\alpha}{|K^\\alpha(r)|},\n$$\nexpressed in megapascal. The first-activating slip system is the one with the smallest $\\lambda_c^\\alpha(r)$. In the rare case that $\\lambda_c^1(r)$ and $\\lambda_c^2(r)$ are equal within a numerical tolerance, treat it as an exact tie for first activation.\n\nYour program must:\n- Implement the above definitions using the specified $\\boldsymbol{D}$, $\\boldsymbol{s}^\\alpha$, $\\boldsymbol{m}^\\alpha$, $a^\\alpha$, $b^\\alpha$, and $g^\\alpha$.\n- For each provided test case value of $r$, compute $K^\\alpha(r)$, then $\\lambda_c^\\alpha(r)$ in megapascal, and determine the first-activating system.\n- Use the following test suite of path ratios $r$:\n  - Case $1$: $r = 0$.\n  - Case $2$: $r = 0.15$.\n  - Case $3$: $r = 0.5$.\n  - Case $4$: $r = -0.5$.\n- Apply a tie tolerance of $\\varepsilon = 10^{-9}$ on $|\\lambda_c^1(r) - \\lambda_c^2(r)|$ to decide ties.\n\nFinal output format:\n- For each test case, output a single integer indicating the first-activating slip system index in $\\{1,2\\}$; if there is a tie, output the integer $0$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[2,0,1,2]$ corresponds to the four test cases in order.\n- All intermediate calculations involving stress magnitudes must be carried out in megapascal, but the final reported integers are unitless indices.",
            "solution": "The problem statement has been rigorously validated and is determined to be **valid**. It is scientifically grounded in the principles of crystal plasticity, well-posed with a complete and consistent set of parameters, and presented objectively. The task is a well-defined computational benchmark design, a legitimate exercise in computational materials science.\n\nThe objective is to determine which of two slip systems, $\\alpha \\in \\{1,2\\}$, activates first under a specified family of stress paths. The first-activating system is the one that requires the minimum stress magnitude $\\lambda$ to reach its activation threshold. This corresponds to the system with the minimum critical load level, $\\lambda_c^\\alpha$.\n\nThe applied macroscopic Cauchy stress tensor $\\boldsymbol{\\sigma}$ is given by the one-parameter family:\n$$\n\\boldsymbol{\\sigma}(\\lambda; r) = \\lambda \\,\\boldsymbol{D} + r \\,\\lambda \\,\\boldsymbol{I}\n$$\nwhere $\\lambda \\ge 0$ is the load magnitude in megapascals (MPa), $\\boldsymbol{D}$ is a fixed deviatoric tensor, $\\boldsymbol{I}$ is the identity tensor, and $r$ is a dimensionless path ratio controlling the hydrostatic stress component.\n\nThe activation of slip system $\\alpha$ is governed by a non-Schmid criterion, where the driving stress $\\psi^\\alpha$ must reach a critical value $g^\\alpha$. The driving stress is defined as:\n$$\n\\psi^\\alpha = \\tau^\\alpha + a^\\alpha p + b^\\alpha \\sigma_{nn}^\\alpha\n$$\nHere, $\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$ is the resolved shear stress, $p = \\frac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$ is the hydrostatic pressure, and $\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$ is the stress component normal to the slip plane. The coefficients $a^\\alpha$ and $b^\\alpha$ are material parameters for non-Schmid effects.\n\nWe first express the components of the driving stress in terms of the loading parameters $\\lambda$ and $r$.\nThe hydrostatic pressure is:\n$$\np = \\frac{1}{3} \\operatorname{tr}(\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) = \\frac{\\lambda}{3} \\operatorname{tr}(\\boldsymbol{D}) + \\frac{r\\lambda}{3} \\operatorname{tr}(\\boldsymbol{I})\n$$\nSince $\\boldsymbol{D}$ is deviatoric, $\\operatorname{tr}(\\boldsymbol{D}) = 0$. With $\\operatorname{tr}(\\boldsymbol{I}) = 3$, this simplifies to $p = r\\lambda$.\n\nThe resolved shear stress is:\n$$\n\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot (\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) \\cdot \\boldsymbol{m}^\\alpha = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + r\\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha)\n$$\nGiven the orthogonality of a slip system, $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$, the second term vanishes, leaving $\\tau^\\alpha = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha)$.\n\nThe slip plane normal stress is:\n$$\n\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot (\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) \\cdot \\boldsymbol{m}^\\alpha = \\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + r\\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha)\n$$\nSince $\\boldsymbol{m}^\\alpha$ is a unit vector, $\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 1$, which gives $\\sigma_{nn}^\\alpha = \\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)$.\n\nSubstituting these into the expression for $\\psi^\\alpha$:\n$$\n\\psi^\\alpha(\\lambda; r) = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + a^\\alpha(r\\lambda) + b^\\alpha \\left[\\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)\\right]\n$$\nFactoring out $\\lambda$ yields $\\psi^\\alpha(\\lambda; r) = K^\\alpha(r)\\lambda$, where the effective driving stress coefficient $K^\\alpha(r)$ is:\n$$\nK^\\alpha(r) = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + a^\\alpha r + b^\\alpha(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)\n$$\nThis confirms the expression provided in the problem statement. Slip activation occurs when $|\\psi^\\alpha| = g^\\alpha$, so $|\\lambda K^\\alpha(r)| = g^\\alpha$. The critical load level is therefore $\\lambda_c^\\alpha(r) = \\frac{g^\\alpha}{|K^\\alpha(r)|}$.\n\nWe now compute the constant geometric factors using the provided data:\n- Deviatoric tensor: $\\boldsymbol{D} = \\operatorname{diag}(1, -1/2, -1/2)$.\n- System $1$: $\\boldsymbol{m}^1 = \\frac{1}{\\sqrt{2}}(1, 0, 1)$, $\\boldsymbol{s}^1 = \\frac{1}{\\sqrt{2}}(1, 0, -1)$.\n- System $2$: $\\boldsymbol{m}^2 = \\frac{1}{\\sqrt{2}}(1, 0, -1)$, $\\boldsymbol{s}^2 = \\frac{1}{\\sqrt{2}}(1, 0, 1)$.\n\nFor system $1$:\n- Schmid factor: $\\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1/2 \\end{pmatrix} = \\frac{1}{2}(1 + 1/2) = \\frac{3}{4}$.\n- Normal stress factor: $\\boldsymbol{m}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1/2 \\end{pmatrix} = \\frac{1}{2}(1 - 1/2) = \\frac{1}{4}$.\n\nFor system $2$:\n- Schmid factor: $\\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1/2 \\end{pmatrix} = \\frac{1}{2}(1 + 1/2) = \\frac{3}{4}$.\n- Normal stress factor: $\\boldsymbol{m}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1/2 \\end{pmatrix} = \\frac{1}{2}(1 - 1/2) = \\frac{1}{4}$.\n\nAs required, the Schmid factors are identical, $\\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = 0.75$. The normal stress factors are also incidentally identical, $\\boldsymbol{m}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{m}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = 0.25$. The difference in activation will arise solely from the non-Schmid coefficients.\n\nWe assemble the expressions for $K^\\alpha(r)$ using coefficients $a^1=0.3$, $b^1=0.1$, $a^2=-0.1$, $b^2=0.25$:\n- $K^1(r) = 0.75 + a^1 r + b^1 (0.25 + r) = 0.75 + 0.3r + 0.1(0.25 + r) = 0.75 + 0.3r + 0.025 + 0.1r = 0.775 + 0.4r$.\n- $K^2(r) = 0.75 + a^2 r + b^2 (0.25 + r) = 0.75 - 0.1r + 0.25(0.25 + r) = 0.75 - 0.1r + 0.0625 + 0.25r = 0.8125 + 0.15r$.\n\nWith $g^1 = g^2 = 50$ MPa, we have:\n$\\lambda_c^1(r) = \\frac{50}{|0.775 + 0.4r|}$ and $\\lambda_c^2(r) = \\frac{50}{|0.8125 + 0.15r|}$.\n\nWe now evaluate for each test case:\n\nCase 1: $r = 0$\n- $K^1(0) = 0.775$, $\\lambda_c^1(0) = 50/0.775 \\approx 64.516$ MPa.\n- $K^2(0) = 0.8125$, $\\lambda_c^2(0) = 50/0.8125 \\approx 61.538$ MPa.\n- $\\lambda_c^2(0)  \\lambda_c^1(0)$, so system $2$ activates first. Result: $2$.\n\nCase 2: $r = 0.15$\n- $K^1(0.15) = 0.775 + 0.4(0.15) = 0.775 + 0.06 = 0.835$.\n- $K^2(0.15) = 0.8125 + 0.15(0.15) = 0.8125 + 0.0225 = 0.835$.\n- $K^1(0.15) = K^2(0.15)$, which means $\\lambda_c^1(0.15) = \\lambda_c^2(0.15)$.\n- The difference $|\\lambda_c^1 - \\lambda_c^2| = 0$, which is less than the tolerance $\\varepsilon=10^{-9}$. This is an exact tie. Result: $0$.\n\nCase 3: $r = 0.5$\n- $K^1(0.5) = 0.775 + 0.4(0.5) = 0.775 + 0.2 = 0.975$. $\\lambda_c^1(0.5) = 50/0.975 \\approx 51.282$ MPa.\n- $K^2(0.5) = 0.8125 + 0.15(0.5) = 0.8125 + 0.075 = 0.8875$. $\\lambda_c^2(0.5) = 50/0.8875 \\approx 56.338$ MPa.\n- $\\lambda_c^1(0.5)  \\lambda_c^2(0.5)$, so system $1$ activates first. Result: $1$.\n\nCase 4: $r = -0.5$\n- $K^1(-0.5) = 0.775 + 0.4(-0.5) = 0.775 - 0.2 = 0.575$. $\\lambda_c^1(-0.5) = 50/0.575 \\approx 86.957$ MPa.\n- $K^2(-0.5) = 0.8125 + 0.15(-0.5) = 0.8125 - 0.075 = 0.7375$. $\\lambda_c^2(-0.5) = 50/0.7375 \\approx 67.796$ MPa.\n- $\\lambda_c^2(-0.5)  \\lambda_c^1(-0.5)$, so system $2$ activates first. Result: $2$.\n\nThe final sequence of results for the given test cases is $[2, 0, 1, 2]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the first-activating slip system for a single crystal under\n    various mixed deviatoric-hydrostatic loading paths, considering\n    non-Schmid effects.\n    \"\"\"\n    \n    # Define problem parameters\n    \n    # Deviatoric stress tensor D\n    D = np.diag([1.0, -0.5, -0.5])\n\n    # Parameters for slip system 1\n    m1 = np.array([1.0, 0.0, 1.0]) / np.sqrt(2)\n    s1 = np.array([1.0, 0.0, -1.0]) / np.sqrt(2)\n    a1 = 0.3\n    b1 = 0.1\n    g1 = 50.0  # in MPa\n\n    # Parameters for slip system 2\n    m2 = np.array([1.0, 0.0, -1.0]) / np.sqrt(2)\n    s2 = np.array([1.0, 0.0, 1.0]) / np.sqrt(2)\n    a2 = -0.1\n    b2 = 0.25\n    g2 = 50.0  # in MPa\n    \n    # Test suite of path ratios r\n    test_cases_r = [0.0, 0.15, 0.5, -0.5]\n    \n    # Tie tolerance\n    epsilon = 1e-9\n    \n    results = []\n\n    # Pre-compute constant geometric factors\n    # For system 1\n    tau1_D = np.dot(s1, D @ m1)\n    sigma_nn1_D = np.dot(m1, D @ m1)\n    \n    # For system 2\n    tau2_D = np.dot(s2, D @ m2)\n    sigma_nn2_D = np.dot(m2, D @ m2)\n\n    for r in test_cases_r:\n        # Calculate the effective driving stress coefficient K(r) for each system\n        \n        # System 1: K^1(r) = s^1.D.m^1 + a^1*r + b^1*(m^1.D.m^1 + r)\n        K1_r = tau1_D + a1 * r + b1 * (sigma_nn1_D + r)\n        \n        # System 2: K^2(r) = s^2.D.m^2 + a^2*r + b^2*(m^2.D.m^2 + r)\n        K2_r = tau2_D + a2 * r + b2 * (sigma_nn2_D + r)\n        \n        # Calculate the critical activation load lambda_c = g / |K(r)|\n        # Avoid division by zero, though not expected for these test cases.\n        # If K(r) is zero, the system never activates, so lambda_c is infinite.\n        if abs(K1_r)  epsilon:\n            lambda_c1 = np.inf\n        else:\n            lambda_c1 = g1 / abs(K1_r)\n\n        if abs(K2_r)  epsilon:\n            lambda_c2 = np.inf\n        else:\n            lambda_c2 = g2 / abs(K2_r)\n            \n        # Determine the first-activating system\n        if abs(lambda_c1 - lambda_c2) = epsilon:\n            # Activation thresholds are equal within tolerance: it's a tie.\n            results.append(0)\n        elif lambda_c1  lambda_c2:\n            # System 1 activates at a lower stress magnitude.\n            results.append(1)\n        else:\n            # System 2 activates at a lower stress magnitude.\n            results.append(2)\n\n    # Print the final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "Once plastic slip occurs, a crystal plasticity model must accurately update the kinematic state of the material, particularly the orientation of the crystal lattice during large deformations. This exercise  guides you through the essential derivation of the lattice spin from first principles and the implementation of a numerically stable integration scheme for the lattice rotation. Properly handling these rotational kinematics is crucial for any finite-strain simulation, as it guarantees that the crystal orientation evolves in a physically and mathematically consistent manner, preserving the geometric integrity of the special orthogonal group $SO(3)$.",
            "id": "3441906",
            "problem": "You are to derive, implement, and test a lattice-rotation update scheme in a crystal plasticity finite element method (CPFEM; Crystal Plasticity Finite Element Method) context. Begin from the multiplicative kinematics and classical time-rate definitions, and demonstrate how the skew-symmetric lattice spin emerges. Then construct a discrete integration procedure that updates the lattice rotation while preserving membership in the Special Orthogonal Group (SO(3); Special Orthogonal Group of degree three).\n\nDerivation task:\n- Start from the kinematic multiplicative decomposition $F = F^{e} F^{p}$, where $F$ is the deformation gradient, $F^{e}$ is the elastic deformation gradient, and $F^{p}$ is the plastic deformation gradient.\n- Define the elastic velocity gradient $L^{e} = \\dot{F}^{e} (F^{e})^{-1}$ using the material time derivative $\\,\\dot{(\\cdot)}\\,$.\n- Introduce the polar decomposition $F^{e} = R^{e} U^{e}$, where $R^{e} \\in \\mathrm{SO}(3)$ is the lattice rotation and $U^{e}$ is the elastic right stretch tensor with $U^{e}$ symmetric positive-definite.\n- Derive the lattice spin as the skew-symmetric part of the elastic velocity gradient. Your derivation must make explicit use of the orthogonality of $R^{e}$ and the symmetry of $U^{e}$, and must proceed from the above fundamental definitions without invoking any shortcut formulas outside of these bases.\n\nIntegration task:\n- Construct an integration scheme for updating $R^{e}$ over a time step $\\Delta t$ that guarantees $R^{e} \\in \\mathrm{SO}(3)$ at the end of the step. The scheme must be based on a matrix exponential on $\\mathfrak{so}(3)$ (the Lie algebra of $\\mathrm{SO}(3)$) applied to the lattice spin, and can use either a forward evaluation or a midpoint evaluation of the spin over the step.\n- The update must be written in terms of a skew-symmetric matrix in $\\mathbb{R}^{3 \\times 3}$ and must demonstrate, mathematically, why the orthogonality of $R^{e}$ is preserved by the update.\n\nImplementation and test suite:\n- Implement your scheme in a program that computes the rotation update for the following four test cases. Angles must be in radians and time in seconds.\n- Definitions to use:\n    - For a vector $\\omega \\in \\mathbb{R}^{3}$, define its associated skew map $[\\omega]_{\\times} \\in \\mathbb{R}^{3 \\times 3}$ by\n      $$[\\omega]_{\\times} = \\begin{bmatrix} 0  -\\omega_{3}  \\omega_{2} \\\\ \\omega_{3}  0  -\\omega_{1} \\\\ -\\omega_{2}  \\omega_{1}  0 \\end{bmatrix}.$$\n    - Define $\\operatorname{skw}(A) = \\tfrac{1}{2}(A - A^{\\top})$ for any $A \\in \\mathbb{R}^{3 \\times 3}$.\n    - The matrix exponential $\\exp(\\cdot)$ on $\\mathbb{R}^{3 \\times 3}$ is the standard one from linear algebra.\n\n- Test cases:\n    1. Constant lattice spin (happy path): $\\omega = [0.1,\\,0.2,\\,-0.05]$ with $R^{e}(0) = I$, $\\Delta t = 0.01$ s, $N = 100$ steps. Use midpoint evaluation of the spin; the exact rotation after $T = N \\Delta t$ is $\\exp(T [\\omega]_{\\times})$.\n    2. Zero lattice spin (boundary case): $\\omega(t) \\equiv [0,\\,0,\\,0]$ with $R^{e}(0) = \\exp(0.3\\,[e_{y}]_{\\times})$, $\\Delta t = 0.05$ s, $N = 10$ steps. The rotation must remain constant.\n    3. Coexistent elastic stretch and rotation (edge case checking $\\operatorname{skw}(L^{e})$): Let $U^{e}(t) = \\mathrm{diag}(\\exp(\\alpha t),\\,\\exp(\\beta t),\\,\\exp(\\gamma t))$ with $(\\alpha,\\beta,\\gamma) = (0.2,-0.1,0.0)$ in $\\mathrm{s}^{-1}$. Let $R^{e}(t)$ be a rotation about $e_{z}$ with constant rate $\\omega_{z} = 0.5$ $\\mathrm{rad/s}$, so $R^{e}(t) = \\exp(t\\,[e_{z}]_{\\times}\\,\\omega_{z})$. Define $L^{e}(t) = \\dot{F}^{e}(t)\\,(F^{e}(t))^{-1}$ with $F^{e}(t) = R^{e}(t)\\,U^{e}(t)$; compute $\\operatorname{skw}(L^{e}(t))$ and use it to update $R^{e}$. Use $\\Delta t = 0.02$ s, $N = 100$, $R^{e}(0) = I$. The exact rotation at $T$ is $\\exp(T\\,[e_{z}]_{\\times}\\,\\omega_{z})$.\n    4. Time-dependent lattice spin about a fixed axis (commuting case, large step): $\\omega(t) = [\\omega_{0}\\sin(\\nu t),\\,0,\\,0]$ with $\\omega_{0}=1.2$ $\\mathrm{rad/s}$, $\\nu=0.8$ $\\mathrm{rad/s}$, $R^{e}(0) = I$, $\\Delta t = 0.2$ s, $N = 25$. Use midpoint evaluation. The exact rotation at $T$ is $\\exp(\\theta(T)\\,[e_{x}]_{\\times})$ with $\\theta(T) = \\int_{0}^{T}\\omega_{0}\\sin(\\nu t)\\,dt = \\frac{\\omega_{0}}{\\nu}\\bigl(1 - \\cos(\\nu T)\\bigr)$.\n\n- For each test case, compute and return two error metrics:\n    - The Frobenius norm of the difference between the numerically updated rotation and the exact rotation at the final time $T$, i.e., $\\|R^{e}_{\\text{num}}(T) - R^{e}_{\\text{exact}}(T)\\|_{F}$.\n    - The Frobenius norm of the violation of orthogonality at the final time, i.e., $\\|R^{e}_{\\text{num}}(T)^{\\top} R^{e}_{\\text{num}}(T) - I\\|_{F}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list of floats in the same order as specified above. For example, the output format must be like \"[[e11,e12],[e21,e22],[e31,e32],[e41,e42]]\", where $e_{i1}$ is the rotation error and $e_{i2}$ is the orthogonality error for test case $i$.\n\nAll angles must be in radians, all times must be in seconds, and each error value must be returned as a floating-point number.",
            "solution": "The derivation begins with the kinematic framework of crystal plasticity. The deformation gradient $F$ admits the multiplicative split $F = F^{e} F^{p}$, which distinguishes elastic lattice distortion $F^{e}$ and plastic distortion $F^{p}$. The elastic velocity gradient is defined by $L^{e} = \\dot{F}^{e} (F^{e})^{-1}$, where $\\dot{(\\cdot)}$ denotes the material time derivative. The elastic deformation gradient admits the polar decomposition $F^{e} = R^{e} U^{e}$, with $R^{e} \\in \\mathrm{SO}(3)$ an orthogonal rotation with $\\det(R^{e}) = 1$ and $U^{e}$ a symmetric positive-definite right stretch.\n\nDifferentiating $F^{e} = R^{e} U^{e}$ with respect to time yields $\\dot{F}^{e} = \\dot{R}^{e} U^{e} + R^{e} \\dot{U}^{e}$. Multiplying by $(F^{e})^{-1} = (U^{e})^{-1} (R^{e})^{\\top}$ gives\n$$\nL^{e} = \\dot{F}^{e} (F^{e})^{-1} = \\dot{R}^{e} U^{e} (U^{e})^{-1} (R^{e})^{\\top} + R^{e} \\dot{U}^{e} (U^{e})^{-1} (R^{e})^{\\top}\n= \\dot{R}^{e} (R^{e})^{\\top} + R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)(R^{e})^{\\top}.\n$$\nThe first term $\\dot{R}^{e} (R^{e})^{\\top}$ is skew-symmetric. To see this, note that orthogonality of $R^{e}$ implies $(R^{e})^{\\top} R^{e} = I$, hence differentiating gives $(\\dot{R}^{e})^{\\top} R^{e} + (R^{e})^{\\top} \\dot{R}^{e} = 0$, so\n$$\n\\left(\\dot{R}^{e} (R^{e})^{\\top}\\right)^{\\top} = R^{e} (\\dot{R}^{e})^{\\top} = - \\dot{R}^{e} (R^{e})^{\\top}.\n$$\nThe second term $R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)(R^{e})^{\\top}$ is symmetric because $U^{e}$ is symmetric positive-definite. Indeed, $U^{e}$ admits an orthogonal spectral decomposition $U^{e} = Q \\Lambda Q^{\\top}$ with $Q \\in \\mathrm{SO}(3)$ and diagonal positive $\\Lambda$. Differentiating and forming $\\dot{U}^{e} (U^{e})^{-1}$ yields, in the co-rotational principal basis, a diagonal operator (the rates of principal stretches scaled by principal stretches), hence symmetric; orthogonal congruence by $R^{e}$ preserves symmetry. Therefore, taking the skew-symmetric part,\n$$\n\\operatorname{skw}(L^{e}) = \\operatorname{skw}\\bigl(\\dot{R}^{e} (R^{e})^{\\top}\\bigr),\n$$\nand the lattice spin is identified as the skew-symmetric tensor associated with the lattice rotation rate. This object resides in the Lie algebra $\\mathfrak{so}(3)$ of skew-symmetric $3 \\times 3$ matrices.\n\nNext, the evolution of $R^{e}$ follows the rotational kinematics. Define the angular velocity tensor $W^{e} = \\operatorname{skw}(L^{e}) \\in \\mathfrak{so}(3)$. The rotational rate equation consistent with group structure is\n$$\n\\dot{R}^{e} = W^{e} R^{e}.\n$$\nPremultiplication by $(R^{e})^{\\top}$ yields $(R^{e})^{\\top}\\dot{R}^{e} = (R^{e})^{\\top} W^{e} R^{e}$, and the left-hand side is skew-symmetric because $(R^{e})^{\\top}\\dot{R}^{e} = - \\bigl((R^{e})^{\\top}\\dot{R}^{e}\\bigr)^{\\top}$, in consistency with $W^{e} \\in \\mathfrak{so}(3)$. The solution over a time step of size $\\Delta t$ is given by a Lie-group exponential update\n$$\nR^{e}(t+\\Delta t) = \\exp\\bigl(\\Delta t\\, W^{e}_{\\star}\\bigr)\\, R^{e}(t),\n$$\nwhere $W^{e}_{\\star}$ is a suitably chosen approximation to $W^{e}$ over the interval, for example $W^{e}(t)$ (forward Euler) or $W^{e}(t+\\Delta t/2)$ (midpoint). Because $W^{e}_{\\star}$ is skew-symmetric, $\\exp(\\Delta t\\,W^{e}_{\\star})$ is an orthogonal matrix with unit determinant, hence the update preserves $R^{e} \\in \\mathrm{SO}(3)$. This follows from the fact that for any skew-symmetric matrix $A$, $\\exp(A)$ is orthogonal since $\\exp(A)^{\\top}\\exp(A) = \\exp(A^{\\top}) \\exp(A) = \\exp(-A)\\exp(A) = I$, and $\\det(\\exp(A)) = \\exp(\\operatorname{tr}(A)) = 1$ because $\\operatorname{tr}(A)=0$.\n\nAlgorithmic design for implementation:\n- Represent the spin by a skew-symmetric matrix $W^{e}(t) \\in \\mathbb{R}^{3 \\times 3}$, produced either directly from a specified angular velocity vector via the $[\\cdot]_{\\times}$ operator or via $W^{e}(t) = \\operatorname{skw}(L^{e}(t))$ when $L^{e}(t)$ is known.\n- Use a midpoint evaluation $W^{e}_{\\star} = W^{e}(t+\\Delta t/2)$ for improved accuracy. Compute the incremental rotation $R_{\\Delta} = \\exp(\\Delta t\\, W^{e}_{\\star})$ and update $R^{e} \\leftarrow R_{\\Delta} R^{e}$.\n- The matrix exponential can be evaluated robustly by standard linear algebra methods. For skew-symmetric matrices, one may equivalently use Rodriguesâ€™ formula derived from the mapping between $\\mathfrak{so}(3)$ and $\\mathrm{SO}(3)$, but a direct exponential is general and concise.\n\nTest case construction:\n- Test case 1: Constant spin with $\\omega = [0.1, 0.2, -0.05]$ produces $W^{e}(t) \\equiv [\\omega]_{\\times}$ and exact $R^{e}(T) = \\exp(T [\\omega]_{\\times})$.\n- Test case 2: Zero spin with $R^{e}(0) = \\exp(0.3\\,[e_{y}]_{\\times})$ and $W^{e}(t) \\equiv 0$ yields $R^{e}(T) = R^{e}(0)$.\n- Test case 3: $F^{e}(t) = R^{e}(t)\\,U^{e}(t)$ with $R^{e}(t)$ a constant-rate rotation about $e_{z}$, $U^{e}(t) = \\mathrm{diag}(\\exp(\\alpha t),\\,\\exp(\\beta t),\\,\\exp(\\gamma t))$. Compute\n$$\nL^{e}(t) = \\dot{F}^{e}(t)\\,(F^{e}(t))^{-1} = \\dot{R}^{e}(t)\\,(R^{e}(t))^{\\top} + R^{e}(t)\\,\\bigl(\\dot{U}^{e}(t)\\,(U^{e}(t))^{-1}\\bigr)\\,(R^{e}(t))^{\\top},\n$$\nand then $W^{e}(t) = \\operatorname{skw}(L^{e}(t))$. For the chosen diagonal $U^{e}$ and rotation about $e_{z}$, the second term is symmetric while the first is $\\omega_{z}[e_{z}]_{\\times}$, recovering the expected spin.\n- Test case 4: Time-dependent spin $\\omega(t) = [\\omega_{0}\\sin(\\nu t), 0, 0]$ about $e_{x}$. Since the generator is fixed, the exact $R^{e}(T) = \\exp(\\theta(T)\\,[e_{x}]_{\\times})$ with $\\theta(T) = \\frac{\\omega_{0}}{\\nu}(1 - \\cos(\\nu T))$.\n\nError metrics:\n- For each case, compute $\\|R^{e}_{\\text{num}}(T) - R^{e}_{\\text{exact}}(T)\\|_{F}$ to measure integration accuracy, and $\\|R^{e}_{\\text{num}}(T)^{\\top} R^{e}_{\\text{num}}(T) - I\\|_{F}$ to measure orthogonality preservation.\n- The final output is the list of these pairs for the four cases, printed as a single line in the specified format.\n\nThis approach ensures that the update respects the group structure of rotations and anchors the lattice spin as the skew part of the elastic velocity gradient, derived strictly from the multiplicative decomposition and polar kinematics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef hat(omega):\n    \"\"\"Return the skew-symmetric matrix [omega]_x for omega in R^3.\"\"\"\n    wx, wy, wz = omega\n    return np.array([[0.0, -wz,  wy],\n                     [wz,  0.0, -wx],\n                     [-wy, wx,  0.0]])\n\ndef skew(A):\n    \"\"\"Return the skew-symmetric part of a 3x3 matrix.\"\"\"\n    return 0.5 * (A - A.T)\n\ndef fro_norm(A):\n    \"\"\"Frobenius norm.\"\"\"\n    return float(np.linalg.norm(A, 'fro'))\n\ndef update_rotation(R0, W_func, dt, N, scheme='midpoint'):\n    \"\"\"\n    Update rotation R in SO(3) using exponential map with midpoint or forward scheme.\n\n    Parameters:\n    - R0: initial 3x3 rotation matrix\n    - W_func: function of time t returning a 3x3 skew-symmetric matrix W^e(t)\n    - dt: time step (seconds)\n    - N: number of steps\n    - scheme: 'midpoint' or 'forward'\n\n    Returns:\n    - R: final rotation matrix after N steps\n    \"\"\"\n    R = R0.copy()\n    t = 0.0\n    for _ in range(N):\n        if scheme == 'midpoint':\n            W = W_func(t + 0.5 * dt)\n        elif scheme == 'forward':\n            W = W_func(t)\n        else:\n            raise ValueError(\"Unknown scheme\")\n        R_delta = expm(dt * W)\n        R = R_delta @ R\n        t += dt\n    return R\n\ndef rotation_about_axis(axis, angle):\n    \"\"\"\n    Return rotation matrix exp(angle * [axis]_x), axis must be a 3-vector.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    return expm(angle * hat(axis))\n\ndef test_case_1():\n    # Constant lattice spin (happy path)\n    omega = np.array([0.1, 0.2, -0.05])  # rad/s\n    W_const = hat(omega)\n    R0 = np.eye(3)\n    dt = 0.01\n    N = 100\n    T = dt * N\n\n    def W_func(t):\n        return W_const\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = expm(T * W_const)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_2():\n    # Zero lattice spin (boundary case)\n    def W_func(t):\n        return np.zeros((3, 3))  # W^e(t) = 0\n\n    R0 = rotation_about_axis([0.0, 1.0, 0.0], 0.3)  # initial rotation about y\n    dt = 0.05\n    N = 10\n    T = dt * N\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = R0.copy()  # No change expected\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_3():\n    # Coexistent elastic stretch and rotation (edge case checking skw(L^e))\n    # U^e(t) = diag(exp(alpha t), exp(beta t), exp(gamma t))\n    alpha, beta, gamma = 0.2, -0.1, 0.0  # s^{-1}\n    D_diag = np.array([alpha, beta, gamma])  # Udot U^{-1} in principal frame (constant)\n    D = np.diag(D_diag)  # symmetric\n    omega_z = 0.5  # rad/s\n    ez = np.array([0.0, 0.0, 1.0])\n\n    def R_of_t(t):\n        return expm((omega_z * t) * hat(ez))\n\n    def L_e_of_t(t):\n        # L^e(t) = Rdot R^T + R D R^T\n        # For rotation about ez at constant rate, Rdot R^T = omega_z [ez]_x\n        R = R_of_t(t)\n        W_rot = omega_z * hat(ez)\n        return W_rot + R @ D @ R.T\n\n    def W_func(t):\n        # W^e(t) = skw(L^e(t))\n        return skew(L_e_of_t(t))\n\n    R0 = np.eye(3)\n    dt = 0.02\n    N = 100\n    T = dt * N\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = R_of_t(T)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_4():\n    # Time-dependent lattice spin about a fixed axis (commuting case, large step)\n    omega0 = 1.2  # rad/s\n    nu = 0.8      # rad/s\n    ex = np.array([1.0, 0.0, 0.0])\n\n    def W_func(t):\n        return hat(np.array([omega0 * np.sin(nu * t), 0.0, 0.0]))\n\n    dt = 0.2\n    N = 25\n    T = dt * N\n\n    R0 = np.eye(3)\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    # Exact rotation: theta(T) = (omega0/nu) * (1 - cos(nu T))\n    theta_T = (omega0 / nu) * (1.0 - np.cos(nu * T))\n    R_exact = rotation_about_axis(ex, theta_T)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    results = []\n    results.append(test_case_1())\n    results.append(test_case_2())\n    results.append(test_case_3())\n    results.append(test_case_4())\n\n    # Final print statement in the exact required format.\n    # Print as a single line: list of four [rotation_error, orthogonality_error] pairs.\n    # Ensure default string conversion yields comma-separated floats within nested lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}