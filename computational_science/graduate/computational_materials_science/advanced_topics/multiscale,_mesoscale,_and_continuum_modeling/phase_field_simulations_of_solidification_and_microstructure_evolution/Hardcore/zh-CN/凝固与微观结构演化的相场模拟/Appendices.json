{
    "hands_on_practices": [
        {
            "introduction": "稳定的数值积分是可靠模拟的基石。本练习聚焦于Cahn-Hilliard方程，该方程是模拟合金成分等守恒量的基础。通过执行冯·诺依曼稳定性分析，您将亲手实践如何确定最大稳定时间步长，这是开发高效、准确的相场模拟代码的一项关键技能。",
            "id": "3476642",
            "problem": "考虑一个长度为 $L$ 的一维周期性区域，该区域由 $N$ 个均匀分布的节点离散化，网格间距为 $h = L / N$。令 $c(x,t)$ 表示一个守恒的序参量（组分），其演化遵循线性化的 Cahn-Hilliard (CH) 方程。该方程源于一个在均匀参考态下具有正曲率的自由能密度。从自由能泛函 $F[c] = \\int \\left( f(c) + \\frac{\\kappa}{2} |\\nabla c|^2 \\right) \\, dx$（其中 $\\kappa \\ge 0$）和化学势 $\\mu = \\frac{\\delta F}{\\delta c}$ 出发，CH 演化定律为 $\\partial_t c = \\nabla \\cdot \\left( M \\nabla \\mu \\right)$，其中 $M \\ge 0$ 是迁移率。在一个均匀组分 $c_0$ 附近进行线性化，设 $f''(c_0) = A \\ge 0$（常数），可得\n$$\n\\frac{\\partial c}{\\partial t} = M \\left( A \\nabla^2 c - \\kappa \\nabla^4 c \\right).\n$$\n使用二阶精度的中心有限差分对具有周期性边界条件的拉普拉斯算子进行空间离散化，并使用时间步长为 $\\Delta t$ 的前向欧拉 (FE) 格式对时间进行离散化。周期性网格上的离散拉普拉斯算子可被傅里叶模对角化，通过 von Neumann 分析，可将完全离散的格式简化为对每个离散傅里叶模振幅 $C_m^n$ 的标量线性更新：\n$$\nC_m^{n+1} = G_m(\\Delta t) \\, C_m^n, \\quad G_m(\\Delta t) = 1 + \\Delta t \\, \\lambda_m,\n$$\n其中 $\\lambda_m$ 是与模指数 $m \\in \\{0,1,\\dots,N-1\\}$ 相关的线性算子 $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ 的离散特征值，$\\nabla_h^2$ 表示离散拉普拉斯算子。对于给定的 $\\Delta t$，前向欧拉格式是稳定的，当且仅当对于每个模指数 $m$ 都有 $|G_m(\\Delta t)| \\le 1$。\n\n您的任务是：\n\n- 利用基本定义（自由能泛函、化学势、线性化和 von Neumann 模态分析），推导稳定性条件，该条件确定了使得前向欧拉格式对周期性网格上所有离散傅里叶模都稳定的最大允许时间步长 $\\Delta t_{\\max}$。用算子 $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ 的离散谱以及基本常数 $M$、$A$、$\\kappa$、$L$ 和 $N$ 来表示 $\\Delta t_{\\max}$。不要假设任何连续极限的简化公式；从周期性网格上的离散算子出发。\n\n- 设计一个算法，在给定 $L$、$N$、$M$、$A$ 和 $\\kappa$ 的情况下，通过扫描所有离散傅里叶模并对所有 $m$ 强制执行 von Neumann 准则 $|G_m(\\Delta t)| \\le 1$ 来计算 $\\Delta t_{\\max}$，其中需理解 $A \\ge 0$ 且 $\\kappa \\ge 0$。您的算法应使用周期性二阶差分算子及其平方的精确离散特征值。\n\n- 实现一个程序，该程序：\n  1) 通过扫描所有离散傅里叶模，为下面测试套件中的每个参数集计算以秒为单位的 $\\Delta t_{\\max}$。\n  2) 对于一个指定的参数集和三个给定的乘数 $\\gamma$，通过检查所有模的 von Neumann 准则，评估选择 $\\Delta t = \\gamma \\, \\Delta t_{\\max}$ 是否稳定（布尔结果）。\n\n物理和数值细节：\n\n- 空间单位必须是米，时间单位必须是秒。迁移率 $M$ 以及系数 $A$ 和 $\\kappa$ 应被视为与线性化 CH 模型一致的给定正常数；报告每个计算出的 $\\Delta t_{\\max}$ 值，单位为秒。不涉及角度量。\n\n测试套件：\n\n- 为以下每个参数集计算 $\\Delta t_{\\max}$（单位：秒）：\n  - 案例 T$1$：$L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 1.0\\times 10^{-14}$。\n  - 案例 T$2$：$L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 0.0$。\n  - 案例 T$3$：$L = 1.0\\times 10^{-6}$ m, $N = 63$, $M = 1.0\\times 10^{-14}$, $A = 1.0\\times 10^{9}$, $\\kappa = 1.0\\times 10^{-14}$。\n  - 案例 T$4$：$L = 1.0\\times 10^{-6}$ m, $N = 64$, $M = 1.0\\times 10^{-14}$, $A = 1.0$, $\\kappa = 1.0\\times 10^{-14}$。\n\n- 对于稳定性检查，使用案例 T$1$ 的参数和以下乘数\n  - $\\gamma_1 = 0.5$,\n  - $\\gamma_2 = 1.0$,\n  - $\\gamma_3 = 1.01$,\n  并通过检查所有离散模的 von Neumann 条件，确定前向欧拉方法对于 $\\Delta t = \\gamma_i \\, \\Delta t_{\\max}$（$i \\in \\{1,2,3\\}$）是否稳定。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个扁平列表，其值为\n  $[\\Delta t_{\\max}(\\text{T}1), \\Delta t_{\\max}(\\text{T}2), \\Delta t_{\\max}(\\text{T}3), \\Delta t_{\\max}(\\text{T}4), \\text{stable}(\\gamma_1), \\text{stable}(\\gamma_2), \\text{stable}(\\gamma_3)]$，\n  其中前四个条目是浮点数（单位为秒），后三个条目是布尔值，所有值都用逗号分隔并用方括号括起来，例如 $[x_1, x_2, x_3, x_4, \\text{True}, \\text{True}, \\text{False}]$。",
            "solution": "我们从自由能泛函 $F[c] = \\int \\left( f(c) + \\frac{\\kappa}{2} |\\nabla c|^2 \\right) \\, dx$ 出发，化学势为 $\\mu = \\frac{\\delta F}{\\delta c} = f'(c) - \\kappa \\nabla^2 c$。Cahn-Hilliard (CH) 方程是守恒律\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( M \\nabla \\mu \\right).\n$$\n在一个均匀态 $c_0$ 附近进行线性化，设 $A = f''(c_0) \\ge 0$，可得\n$$\n\\frac{\\partial c}{\\partial t} = M \\left( A \\nabla^2 c - \\kappa \\nabla^4 c \\right).\n$$\n\n我们考虑一个一维周期性区域 $[0,L]$，其上有 $N$ 个均匀分布的点，间距为 $h = L/N$。令 $c_j^n$ 表示在网格索引 $j \\in \\{0,1,\\dots,N-1\\}$ 和时间层 $n$ 的离散解。具有周期性边界条件的标准二阶中心离散拉普拉斯算子是\n$$\n(\\nabla_h^2 c)_j = \\frac{c_{j+1} - 2 c_j + c_{j-1}}{h^2},\n$$\n其中索引是周期性的。线性化 CH 方程的前向欧拉 (FE) 离散化为\n$$\nc^{n+1} = c^n + \\Delta t \\; M \\left( A \\nabla_h^2 c^n - \\kappa \\nabla_h^4 c^n \\right),\n$$\n其中 $\\nabla_h^4 = \\nabla_h^2 \\circ \\nabla_h^2$。\n\n为分析稳定性，我们通过投影到离散傅里叶基上，使用 von Neumann 模态分析。周期性网格上的离散拉普拉斯算子可被离散傅里叶模 $e^{\\mathrm{i} k_m x}$ 对角化，其波数为 $k_m = \\frac{2\\pi m}{L}$，$m \\in \\{0,1,\\dots,N-1\\}$。等效地，用网格索引表示，模为 $\\varphi_m(j) = e^{\\mathrm{i} 2\\pi m j / N}$。模指数为 $m$ 的离散拉普拉斯算子特征值为\n$$\n\\lambda_{\\Delta}(m) = \\frac{e^{\\mathrm{i} 2\\pi m / N} - 2 + e^{-\\mathrm{i} 2\\pi m / N}}{h^2} = \\frac{-2 + 2 \\cos(2\\pi m / N)}{h^2} = - \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right).\n$$\n因此，离散双调和算子的特征值为 $\\lambda_{\\Delta^2}(m) = \\left( \\lambda_{\\Delta}(m) \\right)^2$。线性算子 $M \\left( A \\nabla_h^2 - \\kappa \\nabla_h^4 \\right)$ 的特征值为\n$$\n\\lambda_m = M \\left( A \\lambda_{\\Delta}(m) - \\kappa \\left( \\lambda_{\\Delta}(m) \\right)^2 \\right).\n$$\n对于 $A \\ge 0$、$\\kappa \\ge 0$ 和 $m \\ne 0$，我们有 $\\lambda_{\\Delta}(m) \\le 0$ 和 $\\left( \\lambda_{\\Delta}(m) \\right)^2 \\ge 0$，因此 $\\lambda_m \\le 0$。零模 $m=0$ 得到 $\\lambda_{\\Delta}(0) = 0$，因此 $\\lambda_0 = 0$，这反映了守恒性。\n\n模振幅 $C_m^n$ 的 FE 更新公式为\n$$\nC_m^{n+1} = \\left( 1 + \\Delta t \\, \\lambda_m \\right) C_m^n,\n$$\n其放大因子为 $G_m(\\Delta t) = 1 + \\Delta t \\lambda_m$。对于实负的 $\\lambda_m$，FE 的稳定性要求 $-2 \\le \\Delta t \\lambda_m \\le 0$，或者等效地，对于每个 $\\lambda_m  0$ 的 $m$，都有 $0 \\le \\Delta t \\le \\frac{2}{|\\lambda_m|}$。最紧的界由最负（绝对值最大）的 $\\lambda_m$ 控制，即最大化非负量\n$$\ns_m \\equiv -\\lambda_{\\Delta}(m) = \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right).\n$$\n的模。其中 $s_m \\in [0, s_{\\max}]$，且\n$$\ns_{\\max} = \\max_{m \\in \\{0,1,\\dots,N-1\\}} s_m = \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi \\lfloor N/2 \\rfloor}{N} \\right),\n$$\n最负特征值的绝对值为\n$$\n|\\lambda|_{\\max} = \\max_{m} \\left( -\\lambda_m \\right) = M \\left( A s_{\\max} + \\kappa s_{\\max}^2 \\right),\n$$\n且 FE 稳定的最大时间步长为\n$$\n\\Delta t_{\\max} = \\frac{2}{|\\lambda|_{\\max}} = \\frac{2}{M \\left( A s_{\\max} + \\kappa s_{\\max}^2 \\right)}.\n$$\n这个结果也可以通过算法得到：扫描所有模指数 $m$，并计算所有 $\\lambda_m  0$ 的 $\\frac{2}{-\\lambda_m}$ 中的最小值。\n\n算法设计：\n\n- 输入 $L$、$N$、$M$、$A$、$\\kappa$。计算 $h = L / N$。\n- 对于每个整数 $m \\in \\{0,1,\\dots,N-1\\}$，计算离散拉普拉斯算子特征值 $\\lambda_{\\Delta}(m) = -\\frac{4}{h^2} \\sin^2\\!\\left( \\frac{\\pi m}{N} \\right)$。\n- 计算 $\\lambda_m = M \\left( A \\lambda_{\\Delta}(m) - \\kappa \\left( \\lambda_{\\Delta}(m) \\right)^2 \\right)$。\n- 对于所有 $\\lambda_m  0$ 的模（即 $m \\ne 0$），计算候选边界 $\\Delta t_m = \\frac{2}{-\\lambda_m}$，并取这些模中 $\\Delta t_m$ 的最小值作为 $\\Delta t_{\\max}$。以秒为单位报告 $\\Delta t_{\\max}$。\n- 为测试给定乘数 $\\gamma$ 的稳定性，设置 $\\Delta t = \\gamma \\, \\Delta t_{\\max}$ 并检查所有 $m$ 的 von Neumann 条件 $|1 + \\Delta t \\lambda_m| \\le 1$。因为对于 $A \\ge 0$ 和 $\\kappa \\ge 0$，所有 $\\lambda_m$ 都是实数且非正，这可以简化为验证对于每个 $\\lambda_m  0$ 的模，都有 $\\Delta t \\le \\frac{2}{-\\lambda_m}$。等效地，可以计算 $\\max_m |1 + \\Delta t \\lambda_m|$ 并与 1 在一个小的数值容差范围内进行比较。\n\n测试套件覆盖范围原理：\n\n- 案例 T$1$ 是一个通用设置，其中二阶项和四阶项都有贡献。\n- 案例 T$2$ 设置 $\\kappa = 0$ 以恢复为二阶算子；这简化为类扩散约束，并检验 $\\Delta t_{\\max} \\sim h^2$ 的极限情况。\n- 案例 T$3$ 使用奇数 $N$，以检验与偶数 $N$ 相比，最高模在离散谱中的轻微位移。\n- 案例 T$4$ 使用一个非常小的 $A$ 使四阶项占主导，以检验 $\\Delta t_{\\max} \\sim h^4$ 的极限情况。\n- 乘数 $\\gamma_1 = 0.5$、$\\gamma_2 = 1.0$ 和 $\\gamma_3 = 1.01$ 分别测试了严格稳定的选择、稳定性的边界以及一个预期对于最严格的模而言会不稳定的轻微超临界选择。\n\n该实现通过使用精确的离散特征值扫描所有离散模来计算 $\\Delta t_{\\max}$，并报告四个 $\\Delta t_{\\max}$ 值（单位为秒），后随针对指定乘数的三个稳定性布尔值，所有结果汇总在所需输出格式的单个扁平列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_eigs_periodic(N, h):\n    \"\"\"\n    Compute the eigenvalues of the 1D periodic second-difference Laplacian\n    with grid spacing h and N points.\n    lambda_D(m) = -4/h^2 * sin^2(pi*m/N), for m=0,...,N-1\n    \"\"\"\n    m = np.arange(N, dtype=np.float64)\n    angles = np.pi * m / N\n    lam = -4.0 / (h * h) * (np.sin(angles) ** 2)\n    return lam\n\ndef max_stable_dt(L, N, M, A, kappa):\n    \"\"\"\n    Compute the maximum stable forward Euler time step for the linearized\n    Cahn-Hilliard operator M*(A*Δ - κ*Δ^2) on a periodic 1D grid.\n    Returns dt_max (float).\n    \"\"\"\n    h = L / N\n    lam_delta = discrete_laplacian_eigs_periodic(N, h)\n    # Operator eigenvalues: lambda_m = M*(A*lam_delta - kappa*lam_delta^2)\n    lam_op = M * (A * lam_delta - kappa * (lam_delta ** 2))\n    # Exclude modes with non-negative lambda (m=0 has lambda=0), consider only lambda  0\n    negative_mask = lam_op  0.0\n    if not np.any(negative_mask):\n        # No restrictive modes; dt can be arbitrarily large for FE (degenerate case).\n        return np.inf\n    # For each negative eigenvalue, FE stability requires dt = 2/(-lambda)\n    dt_candidates = 2.0 / (-lam_op[negative_mask])\n    dt_max = np.min(dt_candidates)\n    return dt_max\n\ndef is_stable_dt(L, N, M, A, kappa, dt, tol=1e-12):\n    \"\"\"\n    Check von Neumann stability for a given dt by verifying |1 + dt*lambda_m| = 1\n    for all discrete modes (within a small tolerance to account for floating error).\n    \"\"\"\n    h = L / N\n    lam_delta = discrete_laplacian_eigs_periodic(N, h)\n    lam_op = M * (A * lam_delta - kappa * (lam_delta ** 2))\n    amp = 1.0 + dt * lam_op  # real quantities\n    # For modes with lambda=0 (m=0 has lambda=0), amp=1. Stability needs amp>=-1\n    # which is |amp|=1. Include tolerance for floating point comparisons.\n    return np.all(np.abs(amp) = 1.0 + tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # dt_max test cases (T1..T4)\n    dt_cases = [\n        # (L, N, M, A, kappa) for T1\n        (1.0e-6, 64, 1.0e-14, 1.0e9, 1.0e-14),\n        # T2: kappa=0\n        (1.0e-6, 64, 1.0e-14, 1.0e9, 0.0),\n        # T3: odd N\n        (1.0e-6, 63, 1.0e-14, 1.0e9, 1.0e-14),\n        # T4: small A, fourth-order dominated\n        (1.0e-6, 64, 1.0e-14, 1.0, 1.0e-14),\n    ]\n\n    dt_max_values = []\n    for (L, N, M, A, kappa) in dt_cases:\n        dt_max = max_stable_dt(L, N, M, A, kappa)\n        dt_max_values.append(dt_max)\n\n    # Stability tests use parameters of T1 with gamma multipliers\n    L_T1, N_T1, M_T1, A_T1, kappa_T1 = dt_cases[0]\n    dt_max_T1 = dt_max_values[0]\n    gammas = [0.5, 1.0, 1.01]\n    stability_results = []\n    for g in gammas:\n        dt_test = g * dt_max_T1\n        stable = is_stable_dt(L_T1, N_T1, M_T1, A_T1, kappa_T1, dt_test, tol=1e-12)\n        stability_results.append(stable)\n\n    # Aggregate final results: [dt_max_T1, dt_max_T2, dt_max_T3, dt_max_T4, stable(g1), stable(g2), stable(g3)]\n    results = dt_max_values + stability_results\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生长中的微观结构（如枝晶）的形貌对其所处环境高度敏感。本练习使用经典的镜像法来探究邻近边界（如自由表面或模具壁）如何改变扩散场并引导枝晶的生长方向。这个简化模型为理解更复杂的相场模拟中同样存在的“镜像力”提供了深刻的物理洞察，有助于解释非对称侧枝等复杂现象。",
            "id": "3476682",
            "problem": "您需要实现一个小型的、自包含的程序，通过使用镜像法对扩散场进行建模，计算在平面边界附近生长的枝晶尖端的准静态转向和侧枝不对称性。目标是比较自由表面与刚性壁面的情况，并根据镜像力类比和基于接触角的润湿倾向来解释结果。\n\n起点和建模假设：\n- 代表无量纲温度过冷或溶质过饱和的标量场 $u(x,y)$ 在远离源的地方服从稳态扩散方程，即 $\\nabla^2 u = 0$。在点状枝晶尖端附近，它以强度为 $s$ 的理想化点奇点的形式消耗或释放该场，使得在二维空间中 $\\nabla^2 u = s \\,\\delta(\\mathbf{r}-\\mathbf{r}_0)$。\n- 远离尖端处，施加的场在 $+x$ 方向上具有均匀梯度，即当 $r \\to \\infty$ 时，$u(x,y) \\to -G_{\\infty}\\, x$，其中 $G_{\\infty}  0$ 是一个常数。\n- 枝晶尖端位于 $y=0$ 处平面边界上方的 $\\mathbf{r}_0 = (0,h)$ 处。该边界可以是一个建模为等温的自由表面（Dirichlet 边界条件 $u=0$ 在 $y=0$ 处），也可以是一个建模为绝热的刚性壁面（Neumann 边界条件 $\\partial u/\\partial y = 0$ 在 $y=0$ 处）。\n- 对于 Dirichlet 或 Neumann 平面边界，您必须使用经典的二维拉普拉斯方程镜像法，并结合二维格林函数 $G(\\mathbf{r}) = \\frac{1}{2\\pi} \\ln \\lVert \\mathbf{r} \\rVert$，通过一个镜像奇点来获得边界对场的额外贡献。放置在 $(0,h)$ 处的点奇点的镜像位于 $(0,-h)$，其符号由边界类型决定。\n- 枝晶尖端的瞬时生长方向定义为与场的局部“下坡”方向对齐，即沿在尖端位置 $\\mathbf{r}_0$ 处计算的 $-\\nabla u$ 方向。将此局部驱动向量表示为 $\\mathbf{g} = -\\nabla u \\big\\vert_{\\mathbf{r}_0} = (g_x,g_y)$。\n- 将转向角 $\\alpha$ 定义为 $\\mathbf{g}$ 相对于 $+x$ 轴的角度，即 $\\alpha = \\operatorname{atan2}(g_y, g_x)$，单位为弧度。同时，定义一个无量纲的侧枝不对称指数 $A = g_y/g_x$，对于较小的 $\\alpha$，该指数近似于尖端上方与下方侧枝的物量供应偏差。最后，定义一个布尔标志 $\\text{toward} = (g_y  0)$，用于指示转向是否朝向边界，假定边界平面位于较低的 $y$ 值处。\n- 接触角解释：对于刚性壁面处指定的微观接触角 $\\theta$（单位为弧度），经典的 Young 关系意味着当 $\\theta  \\pi/2$ 时存在润湿倾向。定义一个润湿布尔值 $W$，如果 $\\theta  \\pi/2$，则 $W = \\text{True}$，否则 $W = \\text{False}$。为了输出格式的完整性，请为所有列出的测试用例计算 $W$，即使它仅对刚性壁面具有物理意义。\n\n您的程序必须：\n1. 对每个测试用例，叠加远场梯度和镜像奇点贡献，以计算尖端处的 $\\mathbf{g}$。然后计算：\n   - 转向角 $\\alpha$（单位：弧度），\n   - 不对称指数 $A$（无量纲小数），\n   - 指示是否朝向边界转向的布尔值 $\\text{toward}$，\n   - 指示基于接触角的润湿倾向的布尔值 $W$。\n2. 生成单行输出，其中包含所有测试用例的汇总结果，格式为一个逗号分隔的列表，用方括号括起，每个测试用例的结果按 $[\\alpha, A, \\text{toward}, W]$ 的顺序排列，并按照测试套件的顺序连接。\n\n单位和约定：\n- 所有长度单位都是任意但一致的。唯一要求的单位是角度：以弧度报告 $\\alpha$。\n- 将 $s$ 和 $G_{\\infty}$ 视为无量纲正常数，将 $h0$ 视为尖端到边界的距离。\n\n测试套件：\n为以下参数集提供结果：\n- 测试 $1$（自由表面）：边界类型为 Dirichlet，$s = 1.0$，$G_{\\infty} = 0.2$，$h = 5.0$，$\\theta = \\pi/2$。\n- 测试 $2$（刚性壁面）：边界类型为 Neumann，$s = 1.0$，$G_{\\infty} = 0.2$，$h = 5.0$，$\\theta = \\pi/3$。\n- 测试 $3$（刚性壁面，远距离）：边界类型为 Neumann，$s = 1.0$，$G_{\\infty} = 0.2$，$h = 50.0$，$\\theta = 2\\pi/3$。\n\n交付内容：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\alpha_1, A_1, \\text{toward}_1, W_1, \\alpha_2, A_2, \\text{toward}_2, W_2, \\alpha_3, A_3, \\text{toward}_3, W_3]$，其中所有 $\\alpha$ 均以弧度为单位。",
            "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个计算材料科学中定义明确、有科学依据的问题，可以使用势理论的既定原则来解决。\n\n该问题要求计算在平面边界附近生长的枝晶尖端的转向行为。该物理系统通过一个标量场 $u(x,y)$ 进行建模，该场代表无量纲的过冷或过饱和，并服从稳态扩散方程。位于 $\\mathbf{r}_0 = (0, h)$ 的枝晶尖端是一个强度为 $s$ 的点源，并施加了一个均匀的远场梯度 $u(x,y) \\to -G_{\\infty}x$。\n\n总场 $u(\\mathbf{r})$ 是三个分量的叠加：\n1. 远场贡献，$u_{\\text{far}}(\\mathbf{r}) = -G_{\\infty}x$。\n2. 位于 $\\mathbf{r}_0$ 处物理源的贡献，$u_{\\text{source}}(\\mathbf{r})$。\n3. 镜像源的贡献，$u_{\\text{image}}(\\mathbf{r})$，它强制执行 $y=0$ 处的边界条件。\n\n生长方向假定为沿着在尖端位置 $\\mathbf{r}_0$ 处计算的向量 $\\mathbf{g} = -\\nabla u$。在此类奇异模型中，一个关键且标准的步骤是通过认识到尖端不会自我转向来对计算进行正则化。因此，必须排除尖端自身奇异场 $\\nabla u_{\\text{source}}$ 的梯度贡献。驱动转向的有效梯度因此仅由远场和镜像场计算得出：\n$$ \\mathbf{g} = - \\nabla (u_{\\text{far}} + u_{\\text{image}}) \\big\\vert_{\\mathbf{r}_0} $$\n\n远场分量的梯度在各处都是恒定的：\n$$ \\nabla u_{\\text{far}} = \\left( \\frac{\\partial}{\\partial x}(-G_{\\infty}x), \\frac{\\partial}{\\partial y}(-G_{\\infty}x) \\right) = (-G_{\\infty}, 0) $$\n\n问题指定使用镜像法。位于位置 $\\mathbf{r}_s$ 处、强度为 $S$ 的点源产生的场为 $u(\\mathbf{r}) = \\frac{S}{2\\pi} \\ln \\lVert \\mathbf{r} - \\mathbf{r}_s \\rVert$。镜像源位于镜像位置 $\\mathbf{r}_{\\text{image}} = (0, -h)$。其强度 $s_{\\text{image}}$ 取决于 $y=0$ 处的边界条件。由镜像源产生的场为：\n$$ u_{\\text{image}}(x,y) = \\frac{s_{\\text{image}}}{2\\pi} \\ln \\lVert \\mathbf{r} - \\mathbf{r}_{\\text{image}} \\rVert = \\frac{s_{\\text{image}}}{2\\pi} \\ln \\sqrt{x^2 + (y+h)^2} = \\frac{s_{\\text{image}}}{4\\pi} \\ln(x^2 + (y+h)^2) $$\n\n镜像场的梯度为：\n$$ \\nabla u_{\\text{image}}(x,y) = \\left( \\frac{s_{\\text{image}}}{4\\pi} \\frac{2x}{x^2 + (y+h)^2}, \\frac{s_{\\text{image}}}{4\\pi} \\frac{2(y+h)}{x^2 + (y+h)^2} \\right) $$\n\n我们在物理尖端的位置 $\\mathbf{r}_0 = (0,h)$ 处计算该梯度：\n$$ \\nabla u_{\\text{image}} \\big\\vert_{\\mathbf{r}_0} = \\left( \\frac{s_{\\text{image}}}{4\\pi} \\frac{2(0)}{0^2 + (h+h)^2}, \\frac{s_{\\text{image}}}{4\\pi} \\frac{2(h+h)}{0^2 + (h+h)^2} \\right) = \\left( 0, \\frac{s_{\\text{image}}}{4\\pi} \\frac{4h}{4h^2} \\right) = \\left( 0, \\frac{s_{\\text{image}}}{4\\pi h} \\right) $$\n此结果代表作用在尖端上的“镜像力”。\n\n尖端处的总有效梯度是远场梯度和镜像场梯度的和：\n$$ \\nabla u \\big\\vert_{\\mathbf{r}_0} = \\nabla u_{\\text{far}} + \\nabla u_{\\text{image}} \\big\\vert_{\\mathbf{r}_0} = (-G_{\\infty}, 0) + \\left(0, \\frac{s_{\\text{image}}}{4\\pi h}\\right) = \\left(-G_{\\infty}, \\frac{s_{\\text{image}}}{4\\pi h}\\right) $$\n\n因此，驱动向量 $\\mathbf{g} = (g_x, g_y)$ 为：\n$$ \\mathbf{g} = -\\left(-G_{\\infty}, \\frac{s_{\\text{image}}}{4\\pi h}\\right) = \\left(G_{\\infty}, -\\frac{s_{\\text{image}}}{4\\pi h}\\right) $$\n所以，$g_x = G_{\\infty}$ 且 $g_y = -s_{\\text{image}} / (4\\pi h)$。\n\n我们现在分析两种边界条件：\n1.  **Dirichlet 条件（自由表面）**：$u(x,0)=0$。通过在 $\\mathbf{r}_{\\text{image}} = (0,-h)$ 处放置一个强度相反的镜像源 $s_{\\text{image}} = -s$ 来满足此条件。\n    对于这种情况，驱动向量的 $y$ 分量是：\n    $$ g_y = -\\frac{(-s)}{4\\pi h} = \\frac{s}{4\\pi h} $$\n    由于 $s0$ 和 $h0$，所以 $g_y > 0$。尖端向 $+y$ 方向转向，即*远离*边界。这类似于来自等温表面的排斥力。\n\n2.  **Neumann 条件（刚性壁面）**：$\\partial u / \\partial y |_{y=0} = 0$。通过在 $\\mathbf{r}_{\\text{image}} = (0,-h)$ 处放置一个等强度的镜像源 $s_{\\text{image}} = +s$ 来满足此条件。\n    对于这种情况，驱动向量的 $y$ 分量是：\n    $$ g_y = -\\frac{(+s)}{4\\pi h} = -\\frac{s}{4\\pi h} $$\n    由于 $s0$ 和 $h0$，所以 $g_y  0$。尖端向 $-y$ 方向转向，即*朝向*边界。这类似于对绝热壁面的吸引力。这种吸引力与小接触角（$\\theta  \\pi / 2$）所指示的润湿倾向在物理上是一致的。\n\n所需的输出按以下方式计算：\n-   转向角：$\\alpha = \\operatorname{atan2}(g_y, g_x)$\n-   不对称指数：$A = g_y / g_x$\n-   转向方向：$\\text{toward} = (g_y  0)$\n-   润湿倾向：$W = (\\theta  \\pi/2)$\n\n现在，我们将这些公式应用于具体的测试用例。\n\n**测试 1：** 自由表面 (Dirichlet)，$s = 1.0$，$G_{\\infty} = 0.2$，$h = 5.0$，$\\theta = \\pi/2$。\n-   $g_x = G_{\\infty} = 0.2$\n-   $g_y = \\frac{s}{4\\pi h} = \\frac{1.0}{4\\pi (5.0)} = \\frac{1}{20\\pi} \\approx 0.015915$\n-   $\\alpha_1 = \\operatorname{atan2}(1/(20\\pi), 0.2) \\approx 0.07936$ 弧度\n-   $A_1 = \\frac{1/(20\\pi)}{0.2} = \\frac{1}{4\\pi} \\approx 0.07958$\n-   $\\text{toward}_1 = (g_y  0) = (\\text{正数}  0) = \\text{False}$\n-   $W_1 = (\\pi/2  \\pi/2) = \\text{False}$\n\n**测试 2：** 刚性壁面 (Neumann)，$s = 1.0$，$G_{\\infty} = 0.2$，$h = 5.0$，$\\theta = \\pi/3$。\n-   $g_x = G_{\\infty} = 0.2$\n-   $g_y = -\\frac{s}{4\\pi h} = -\\frac{1.0}{4\\pi (5.0)} = -\\frac{1}{20\\pi} \\approx -0.015915$\n-   $\\alpha_2 = \\operatorname{atan2}(-1/(20\\pi), 0.2) \\approx -0.07936$ 弧度\n-   $A_2 = \\frac{-1/(20\\pi)}{0.2} = -\\frac{1}{4\\pi} \\approx -0.07958$\n-   $\\text{toward}_2 = (g_y  0) = (\\text{负数}  0) = \\text{True}$\n-   $W_2 = (\\pi/3  \\pi/2) = \\text{True}$\n\n**测试 3：** 刚性壁面 (Neumann)，$s = 1.0$，$G_{\\infty} = 0.2$，$h = 50.0$，$\\theta = 2\\pi/3$。\n-   $g_x = G_{\\infty} = 0.2$\n-   $g_y = -\\frac{s}{4\\pi h} = -\\frac{1.0}{4\\pi (50.0)} = -\\frac{1}{200\\pi} \\approx -0.0015915$\n-   $\\alpha_3 = \\operatorname{atan2}(-1/(200\\pi), 0.2) \\approx -0.007955$ 弧度\n-   $A_3 = \\frac{-1/(200\\pi)}{0.2} = -\\frac{1}{40\\pi} \\approx -0.007958$\n-   $\\text{toward}_3 = (g_y  0) = (\\text{负数}  0) = \\text{True}$\n-   $W_3 = (2\\pi/3  \\pi/2) = (0.666\\dots\\pi  0.5\\pi) = \\text{False}$\n\n实现将直接遵循这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes steering and asymmetry for a dendrite tip near a planar boundary.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (boundary_type, s, G_infinity, h, theta)\n    # boundary_type: 'dirichlet' for free surface, 'neumann' for rigid wall\n    test_cases = [\n        ('dirichlet', 1.0, 0.2, 5.0, np.pi/2),\n        ('neumann',   1.0, 0.2, 5.0, np.pi/3),\n        ('neumann',   1.0, 0.2, 50.0, 2*np.pi/3),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        boundary_type, s, g_inf, h, theta = case\n\n        # The x-component of the driving vector is determined by the far-field gradient.\n        # g_x = G_infinity\n        g_x = g_inf\n\n        # The y-component is determined by the image source.\n        # The image source strength s_image is -s for Dirichlet and +s for Neumann.\n        # g_y = -s_image / (4 * pi * h)\n        if boundary_type == 'dirichlet':\n            s_image = -s\n        elif boundary_type == 'neumann':\n            s_image = s\n        else:\n            raise ValueError(\"Unknown boundary type\")\n\n        g_y = -s_image / (4 * np.pi * h)\n\n        # 1. Steering angle alpha in radians\n        alpha = np.arctan2(g_y, g_x)\n\n        # 2. Asymmetry index A\n        A = g_y / g_x\n        \n        # 3. Boolean indicating steering toward the boundary\n        toward = g_y  0\n\n        # 4. Boolean indicating contact-angle-based wetting predisposition\n        W = theta  (np.pi / 2)\n        \n        # Append this case's results to the master list\n        all_results.extend([alpha, A, toward, W])\n\n    # Final print statement in the exact required format.\n    # The format is a single line, comma-separated list enclosed in square brackets.\n    # Booleans are represented as 'True' or 'False'.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "许多重要的工程合金会经历复杂的相变，例如包晶反应，而这类反应的模拟极具挑战性。这项综合性练习要求您构建一个完整的多相场求解器，用以模拟定向凝固过程中不同固相之间的竞争。通过实现该模型，您将直接面对耦合多个序参量、溶质扩散和平流的难题，并捕捉瞬态相形成等复杂的微观结构演化过程。",
            "id": "3476675",
            "problem": "要求您设计并实现一个最小化的、自洽的一维多相场求解器，用于研究包晶反应为 $L+\\alpha\\to\\beta$ 的包晶体系中的定向凝固过程。该公式使用三个相序参量：$\\phi_{\\alpha}$、$\\phi_{\\beta}$ 和 $\\phi_{L}$，其约束条件为 $\\phi_{\\alpha}+\\phi_{\\beta}+\\phi_{L}=1$，其中每个 $\\phi$ 的取值范围为 $[0,1]$。成分场为 $c(x,t)\\in[0,1]$。所有量均为无量纲。\n\n从以下基本和核心定义出发：\n- 非守恒（Allen-Cahn）序参量的变分动力学：$\\partial \\phi_i/\\partial t = -L\\,\\delta \\mathcal{F}/\\delta \\phi_i$，其中 $L0$ 是迁移率，$\\mathcal{F}$ 是自由能泛函。\n- 包含扩散和平流的守恒成分场的守恒定律：$\\partial c/\\partial t = \\nabla\\cdot\\left(D(\\phi_L)\\nabla c\\right) - V_p \\,\\partial c/\\partial x + S$，其中 $D(\\phi_L)$ 是相依赖的扩散系数，$V_p\\ge 0$ 是提拉速率，$S$ 是考虑相变过程中溶质交换的源项。\n- 具有恒定梯度的定向凝固温度场：$T(x,t)=T_0+G\\,(x - V_p\\,t)$，其中 $T_0$ 和 $G0$ 是常数。\n\n为序参量定义一个易于处理的单位体积自由能密度 $\\psi$，其包含双势阱、抑制相重叠的混合惩罚项、界面的梯度惩罚项，以及一个编码各相局部热力学驱动力的倾斜项：\n- 每个固相序参量的双势阱：$W\\,\\phi_i^2(1-\\phi_i)^2$，其中 $W0$ 且 $i\\in\\{\\alpha,\\beta\\}$。\n- 以 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 表示的多相惩罚项，其中 $\\phi_{L}=1-\\phi_{\\alpha}-\\phi_{\\beta}$：$\\eta\\left(\\phi_{\\alpha}+\\phi_{\\beta}-\\phi_{\\alpha}^2-\\phi_{\\beta}^2-\\phi_{\\alpha}\\phi_{\\beta}\\right)$，其中 $\\eta0$。\n- 梯度惩罚项：$(\\varepsilon^2/2)\\left(|\\nabla \\phi_{\\alpha}|^2+|\\nabla \\phi_{\\beta}|^2\\right)$，其中 $\\varepsilon0$。\n- 每个固相的热力学倾斜项：$-\\lambda_i f_i(T,c)\\,h(\\phi_i)$，其中 $i\\in\\{\\alpha,\\beta\\}$，$\\lambda_i0$，$h(\\phi)=\\phi^2(3-2\\phi)$，且局部驱动力 $f_i(T,c)=T_{\\ell,i}(c)-T$。假设液相线关系是线性的 $T_{\\ell,i}(c)=T_i^0+m_i\\,c$，其中 $T_i^0$ 和 $m_i$ 是常数。\n\n基于以上定义，一维相场方程如下：\n- 对于 $i\\in\\{\\alpha,\\beta\\}$，\n$$\n\\frac{\\partial \\phi_i}{\\partial t} = -L\\left(\\frac{\\partial \\psi}{\\partial \\phi_i} - \\varepsilon^2 \\frac{\\partial^2 \\phi_i}{\\partial x^2}\\right),\n$$\n其中\n$$\n\\frac{\\partial \\psi}{\\partial \\phi_{\\alpha}} = 2W\\,\\phi_{\\alpha}(1-\\phi_{\\alpha})(1-2\\phi_{\\alpha}) + \\eta\\,(1-2\\phi_{\\alpha}-\\phi_{\\beta}) - \\lambda_{\\alpha} f_{\\alpha}(T,c)\\,h'(\\phi_{\\alpha}),\n$$\n$$\n\\frac{\\partial \\psi}{\\partial \\phi_{\\beta}} = 2W\\,\\phi_{\\beta}(1-\\phi_{\\beta})(1-2\\phi_{\\beta}) + \\eta\\,(1-2\\phi_{\\beta}-\\phi_{\\alpha}) - \\lambda_{\\beta} f_{\\beta}(T,c)\\,h'(\\phi_{\\beta}),\n$$\n且 $h'(\\phi)=6\\phi(1-\\phi)$。在每个时间步后，强制执行 $\\phi_L=1-\\phi_{\\alpha}-\\phi_{\\beta}$ 并将 $\\phi_{\\alpha}、\\phi_{\\beta}、\\phi_{L}$ 投影到 $[0,1]$ 区间内以维持约束。\n\n- 对于成分场，\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial x}\\left(D(\\phi_L)\\frac{\\partial c}{\\partial x}\\right) - V_p \\frac{\\partial c}{\\partial x} + S,\n$$\n其中 $D(\\phi_L)=D_L\\,\\phi_L + D_s\\,(1-\\phi_L)$，并使用一个小的 $D_s0$ 进行数值正则化。使用一个简化的由分配驱动的源项\n$$\nS = B_{\\alpha}\\,\\frac{\\partial \\phi_{\\alpha}}{\\partial t} + B_{\\beta}\\,\\frac{\\partial \\phi_{\\beta}}{\\partial t},\n$$\n其中 $B_i=(1-k_i)\\,c_{\\mathrm{ref}}$，$k_i\\in(0,1)$ 是有效分配系数，$c_{\\mathrm{ref}}$ 是参考浓度。\n\n在长度为 $L_x$、包含 $N_x$ 个点的均匀网格上进行空间离散，并对所有场使用无通量（Neumann）边界条件。使用：\n- 中心差分计算空间导数和带有 Neumann 边界条件的离散拉普拉斯算子。\n- 对 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 使用显式时间步进（前向欧拉法）。\n- 对 $c$ 使用显式时间步进，并对平流项 $-V_p\\,\\partial c/\\partial x$ 使用迎风离散格式。\n\n$t=0$ 时的初始条件：\n- 对于 $x\\in[0,w_{\\alpha}]$，$\\phi_{\\alpha}(x,0)\\approx 1$，并在量级为 $\\varepsilon$ 的界面宽度上平滑过渡到 $0$，在其他地方为 $0$。\n- $\\phi_{\\beta}(x,0)=0$，除非在特定测试用例中指定了小的形核。\n- $c(x,0)=c_0$ 均匀分布。\n\n参数值为无量纲。数值求解器应运行至固定的最终时间 $t_f$。\n\n您的程序必须实现上述模型，并为下面定义的每个测试用例计算三个诊断量：\n1. 最终时间 $t_f$ 时的前沿引领相指示符 $I_{\\mathrm{lead}}\\in\\{0,1\\}$，其中 $0$ 表示 $\\alpha$ 相前沿领先，$1$ 表示 $\\beta$ 相前沿领先。将相 $i$ 的前沿位置定义为 $x_i=\\max\\{x: \\phi_i(x,t_f)\\ge 0.5\\}$（如果不存在这样的 $x$，则取 $x_i=-\\infty$）。$x_i$ 较大的相为引领相。\n2. 在整个模拟时间窗口 $[0,t_f]$ 内观察到的最大溶质堆积 $\\Delta c_{\\max}=\\max_x c(x,t)-c_0$，以浮点数形式返回，四舍五入到三位小数。\n3. 瞬态包晶岛指示符 $I_{\\mathrm{isl}}\\in\\{0,1\\}$，如果在任何时刻 $t\\in(0,t_f)$，$\\phi_{\\beta}(x,t)0.6$ 的不相交连续团簇数量超过了最终时刻 $t=t_f$ 的此类团簇数量，并且在某个时刻至少为 $2$，则该指示符等于 $1$；否则为 $0$。\n\n需要实现的模拟和数值细节：\n- 区域和网格：$L_x=1$，$N_x=128$，网格间距 $\\Delta x=L_x/N_x$。\n- 时间步长和持续时间：$\\Delta t=5\\times 10^{-4}$，$t_f=N_t\\,\\Delta t$，其中 $N_t=800$。\n- 边界条件：在 $x=0$ 和 $x=L_x$ 处对所有场应用齐次 Neumann 边界条件。\n- 所有用例的通用参数：$W=2$, $\\eta=2$, $\\varepsilon=0.02$, $L=1$, $D_s=10^{-4}$, $T_0=0.35$, $G=0.5$, $T_{\\alpha}^0=0.50$, $m_{\\alpha}=-0.30$, $T_{\\beta}^0=0.55$, $m_{\\beta}=-0.60$, $\\lambda_{\\alpha}=1.0$, $k_{\\alpha}=0.7$, $k_{\\beta}=0.6$, $c_{\\mathrm{ref}}=c_0$, $w_{\\alpha}=0.10$，初始 $c_0=0.30$。\n- 初始 $\\phi_{\\alpha}(x,0)$ 分布：$\\phi_{\\alpha}(x,0)=\\frac{1}{2}\\left[1-\\tanh\\left(\\frac{x-w_{\\alpha}}{\\sqrt{2}\\,\\varepsilon}\\right)\\right]$，并截断到 $[0,1]$ 区间内。\n- 初始 $\\phi_{\\beta}(x,0)$：除非另有说明，否则为零；一个核是高斯分布 $\\phi_{\\beta}(x,0)=A_{\\beta}\\exp\\left(-\\frac{(x-x_{\\beta})^2}{2\\sigma_{\\beta}^2}\\right)$，截断到 $[0,1]$ 区间内，宽度为 $\\sigma_{\\beta}=0.01$。\n\n三个测试用例的套件（均为无量纲）：\n- 用例 1：$(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(0.4,5\\times 10^{-4},0.8,0.0)$。\n- 用例 2：$(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(0.8,7.5\\times 10^{-4},1.2,0.0)$。\n- 用例 3：$(V_p,D_L,\\lambda_{\\beta},A_{\\beta})=(1.0,5\\times 10^{-4},1.1,0.20)$，其中 $x_{\\beta}=0.35$。\n\n角度单位不适用。所有输出均为无量纲。您的程序应生成单行输出，其中包含所有三个测试用例的结果，形式为一个包含九个条目的逗号分隔列表，并用方括号括起来，顺序如下\n$[I_{\\mathrm{lead}}^{(1)},\\Delta c_{\\max}^{(1)},I_{\\mathrm{isl}}^{(1)},I_{\\mathrm{lead}}^{(2)},\\Delta c_{\\max}^{(2)},I_{\\mathrm{isl}}^{(2)},I_{\\mathrm{lead}}^{(3)},\\Delta c_{\\max}^{(3)},I_{\\mathrm{isl}}^{(3)}]$\n其中每个 $\\Delta c_{\\max}^{(i)}$ 四舍五入到三位小数，指示符为整数 $0$ 或 $1$。",
            "solution": "用户提供的问题陈述已经过严格验证，被认为是**有效的**。它在科学上基于计算材料科学的原理，特别是使用多相场模型进行凝固研究。该问题是适定的，提供了一套完整且一致的控制偏微分方程、参数、初始/边界条件以及数值离散化方案。它是客观且可形式化的，允许得到唯一的数值解。\n\n该问题要求实现一个一维、三相的包晶凝固求解器。该模型将两个用于固相序参量 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 的非守恒 Allen-Cahn 方程，与一个用于守恒成分场 $c$ 的 Cahn-Hilliard 型平流-扩散-反应方程耦合起来。系统在移动的温度梯度下演化，以模拟定向凝固。\n\n该解决方案通过在均匀空间网格上离散化控制方程，并按规定使用显式欧拉格式进行时间前向积分来实现。数值实现包括以下关键步骤：\n\n1.  **网格和场初始化**：为长度为 $L_x=1$ 的计算域建立一个包含 $N_x=128$ 个点的一维网格。根据问题的初始条件，将场 $\\phi_{\\alpha}$、$\\phi_{\\beta}$ 和 $c$ 初始化为 NumPy 数组。具体来说，$\\phi_{\\alpha}(x,0)$ 是一个平滑的阶梯状分布，$c(x,0)$ 是均匀的 $c_0$，而 $\\phi_{\\beta}(x,0)$ 为零，但在测试用例3中引入了一个高斯核。\n\n2.  **空间算子的离散化**：\n    *   出现在 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 的 Allen-Cahn 方程中的拉普拉斯算子 $\\partial^2/\\partial x^2$，使用二阶中心差分格式进行离散化。在计算域边界 $x=0$ 和 $x=L_x$ 强制执行齐次 Neumann 边界条件（$\\partial \\phi_i/\\partial x = 0$）。\n    *   成分方程中的平流项 $-V_p \\partial c/\\partial x$，使用一阶迎风格式进行离散化，该格式适用于输运主导的现象并能增强数值稳定性。边界条件通过假设上游边界处的平流贡献为零来处理。\n    *   变系数扩散项 $\\partial/\\partial x (D(\\phi_L) \\partial c/\\partial x)$ 在交错网格上使用类有限体积法进行离散化，以确保局部守恒。相依赖的扩散系数 $D(\\phi_L)$ 在单元界面上进行评估。成分场的齐次 Neumann 边界条件 $\\partial c/\\partial x=0$ 转化为边界上扩散部分的零通量条件。\n\n3.  **时间积分**：按照要求，使用显式前向欧拉法对所有三个场进行时间步进。时间步长为 $\\Delta t = 5 \\times 10^{-4}$。在运行 $N_t=800$ 步的主时间循环内部：\n    *   在每个步骤中更新移动的温度场 $T(x,t)$。\n    *   使用前一时间步的场值计算每个控制偏微分方程的右侧项（RHS）。这包括从自由能泛函计算化学势导数，以及计算成分方程的源项 $S$。\n    *   更新场值：$\\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\Delta t \\cdot \\text{RHS}(\\mathbf{u}^n)$，其中 $\\mathbf{u} = (\\phi_{\\alpha}, \\phi_{\\beta}, c)$。\n    *   每次更新后，一个投影步骤会强制施加序参量的物理约束。首先将 $\\phi_{\\alpha}$ 和 $\\phi_{\\beta}$ 的值裁剪到 $[0,1]$ 区间内。然后，在它们的和超过 $1$ 的网格单元中，对它们进行归一化以确保 $\\phi_{\\alpha} + \\phi_{\\beta} \\le 1$，这保证了 $\\phi_L = 1 - \\phi_{\\alpha} - \\phi_{\\beta} \\ge 0$。\n\n4.  **诊断量计算**：在整个模拟过程和结束时，为每个测试用例计算三个指定的诊断量：\n    *   **前沿引领相指示符（$I_{\\mathrm{lead}}$）**：在最终时间 $t_f$，通过找到 $\\phi_i(x,t_f) \\ge 0.5$ 的最大坐标 $x$ 来确定 $\\alpha$ 和 $\\beta$ 凝固前沿的位置。前沿位置较大的相即为引领相。\n    *   **最大溶质堆积（$\\Delta c_{\\max}$）**：在模拟过程中，跟踪所有网格点和所有时间步上 $c(x,t) - c_0$ 的最大值。最终结果四舍五入到三位小数。\n    *   **瞬态包晶岛指示符（$I_{\\mathrm{isl}}$）**：在每个时间步，使用 `scipy.ndimage.label` 函数计算 $\\phi_{\\beta} > 0.6$ 的独立空间团簇的数量。如果在模拟期间（$t \\in (0, t_f)$）观察到的最大团簇数大于最终时刻 $t=t_f$ 的团簇数，并且在某个时刻至少存在两个团簇，则该指示符设为 $1$。否则为 $0$。\n\n以下代码为三个指定的测试用例实现了此数值解，并按要求格式化输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def run_simulation(case_params):\n        \"\"\"\n        Executes a single phase-field simulation run for a given set of parameters.\n        \"\"\"\n        # Unpack case-specific parameters\n        Vp, DL, lambda_beta, A_beta, x_beta = case_params\n\n        # --- Simulation and numerical parameters ---\n        Lx = 1.0\n        Nx = 128\n        dx = Lx / Nx\n        x = np.arange(Nx) * dx\n\n        Nt = 800\n        dt = 5.0e-4\n\n        # --- Common physical parameters ---\n        W = 2.0\n        eta = 2.0\n        epsilon = 0.02\n        L_mob = 1.0  # Mobility L from the problem statement\n        Ds = 1.0e-4\n        T0 = 0.35\n        G = 0.5\n        T_alpha_0 = 0.50\n        m_alpha = -0.30\n        T_beta_0 = 0.55\n        m_beta = -0.60\n        lambda_alpha = 1.0\n        k_alpha = 0.7\n        k_beta = 0.6\n        c0 = 0.30\n        c_ref = c0\n        w_alpha = 0.10\n        sigma_beta = 0.01\n\n        B_alpha = (1.0 - k_alpha) * c_ref\n        B_beta = (1.0 - k_beta) * c_ref\n\n        # --- Initial conditions ---\n        phi_a = 0.5 * (1.0 - np.tanh((x - w_alpha) / (np.sqrt(2.0) * epsilon)))\n        phi_a = np.clip(phi_a, 0.0, 1.0)\n\n        phi_b = np.zeros_like(x)\n        if A_beta > 0.0 and x_beta is not None:\n            phi_b = A_beta * np.exp(-((x - x_beta)**2) / (2.0 * sigma_beta**2))\n            phi_b = np.clip(phi_b, 0.0, 1.0)\n        \n        c = np.full_like(x, c0)\n\n        # --- Diagnostics trackers ---\n        max_delta_c = 0.0\n        num_beta_clusters_history = []\n        \n        def count_clusters(phi_field, threshold):\n            binary_field = phi_field > threshold\n            if not np.any(binary_field):\n                return 0\n            _, num_features = label(binary_field)\n            return num_features\n\n        # --- Main time integration loop ---\n        for n in range(Nt):\n            t_current = (n + 1.0) * dt\n            T = T0 + G * (x - Vp * t_current)\n            \n            phi_L = 1.0 - phi_a - phi_b\n            phi_L = np.clip(phi_L, 0.0, 1.0)\n\n            # --- RHS for phi_a and phi_b ---\n            lap_phi_a = np.zeros(Nx)\n            lap_phi_a[1:-1] = (phi_a[2:] - 2.0*phi_a[1:-1] + phi_a[:-2]) / dx**2\n            lap_phi_a[0] = 2.0 * (phi_a[1] - phi_a[0]) / dx**2 # Neumann BC\n            lap_phi_a[-1] = 2.0 * (phi_a[-2] - phi_a[-1]) / dx**2 # Neumann BC\n\n            lap_phi_b = np.zeros(Nx)\n            lap_phi_b[1:-1] = (phi_b[2:] - 2.0*phi_b[1:-1] + phi_b[:-2]) / dx**2\n            lap_phi_b[0] = 2.0 * (phi_b[1] - phi_b[0]) / dx**2 # Neumann BC\n            lap_phi_b[-1] = 2.0 * (phi_b[-2] - phi_b[-1]) / dx**2 # Neumann BC\n\n            f_alpha = (T_alpha_0 + m_alpha * c) - T\n            f_beta = (T_beta_0 + m_beta * c) - T\n            \n            h_prime_a = 6.0 * phi_a * (1.0 - phi_a)\n            h_prime_b = 6.0 * phi_b * (1.0 - phi_b)\n\n            d_psi_d_phi_a = 2.0*W*phi_a*(1.0-phi_a)*(1.0-2.0*phi_a) + eta*(1.0 - 2.0*phi_a - phi_b) - lambda_alpha * f_alpha * h_prime_a\n            d_psi_d_phi_b = 2.0*W*phi_b*(1.0-phi_b)*(1.0-2.0*phi_b) + eta*(1.0 - 2.0*phi_b - phi_a) - lambda_beta * f_beta * h_prime_b\n\n            phi_a_rhs = -L_mob * (d_psi_d_phi_a - epsilon**2 * lap_phi_a)\n            phi_b_rhs = -L_mob * (d_psi_d_phi_b - epsilon**2 * lap_phi_b)\n\n            # --- RHS for c ---\n            S = B_alpha * phi_a_rhs + B_beta * phi_b_rhs\n\n            D = DL * phi_L + Ds * (1.0 - phi_L)\n            D_plus_half = (D[1:] + D[:-1]) / 2.0\n            flux = np.zeros(Nx - 1)\n            flux = D_plus_half * (c[1:] - c[:-1]) / dx\n            \n            diff_c_term = np.zeros(Nx)\n            diff_c_term[1:-1] = (flux[1:] - flux[:-1]) / dx\n            # Neumann BC: flux at boundaries is zero\n            diff_c_term[0] = flux[0] / dx\n            diff_c_term[-1] = -flux[-1] / dx\n\n            adv_c_term = np.zeros(Nx)\n            if Vp > 0:\n                adv_c_term[1:] = -Vp * (c[1:] - c[:-1]) / dx\n                # Neumann BC for advection at x=0 (upwind)\n                adv_c_term[0] = 0\n\n            c_rhs = diff_c_term + adv_c_term + S\n\n            # --- Explicit Euler update ---\n            phi_a_new = phi_a + dt * phi_a_rhs\n            phi_b_new = phi_b + dt * phi_b_rhs\n            c = c + dt * c_rhs\n\n            # --- Projection step for phi ---\n            phi_a = np.clip(phi_a_new, 0.0, 1.0)\n            phi_b = np.clip(phi_b_new, 0.0, 1.0)\n            \n            sum_ab = phi_a + phi_b\n            mask = sum_ab > 1.0\n            sum_ab_masked = sum_ab[mask]\n            \n            if np.any(mask):\n                # Avoid division by zero, although mask > 1 prevents it.\n                phi_a[mask] /= sum_ab_masked[sum_ab_masked > 0]\n                phi_b[mask] /= sum_ab_masked[sum_ab_masked > 0]\n\n\n            # --- Update diagnostics ---\n            max_delta_c = max(max_delta_c, np.max(c) - c0)\n            num_clusters = count_clusters(phi_b, 0.6)\n            num_beta_clusters_history.append(num_clusters)\n\n        # --- Final diagnostics calculation ---\n        # 1. Front leader indicator I_lead\n        alpha_indices = np.where(phi_a >= 0.5)[0]\n        x_alpha_front = x[alpha_indices.max()] if alpha_indices.size > 0 else -np.inf\n        beta_indices = np.where(phi_b >= 0.5)[0]\n        x_beta_front = x[beta_indices.max()] if beta_indices.size > 0 else -np.inf\n        I_lead = 1 if x_beta_front > x_alpha_front else 0\n\n        # 2. Maximum solute pile-up Delta_c_max\n        delta_c_max_rounded = round(max_delta_c, 3)\n        \n        # 3. Transient peritectic island indicator I_isl\n        I_isl = 0\n        if num_beta_clusters_history:\n            max_overall_clusters = np.max(num_beta_clusters_history)\n            final_clusters = num_beta_clusters_history[-1]\n            if max_overall_clusters > final_clusters and max_overall_clusters >= 2:\n                I_isl = 1\n        \n        return I_lead, delta_c_max_rounded, I_isl\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (V_p, D_L, lambda_beta, A_beta, x_beta)\n        (0.4, 5.0e-4, 0.8, 0.0, None),\n        (0.8, 7.5e-4, 1.2, 0.0, None),\n        (1.0, 5.0e-4, 1.1, 0.20, 0.35),\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(case)\n        results.extend(res)\n\n    # Format each float to three decimal places before joining.\n    formatted_results = []\n    for r in results:\n        if isinstance(r, float):\n            formatted_results.append(f\"{r:.3f}\")\n        else:\n            formatted_results.append(str(r))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}