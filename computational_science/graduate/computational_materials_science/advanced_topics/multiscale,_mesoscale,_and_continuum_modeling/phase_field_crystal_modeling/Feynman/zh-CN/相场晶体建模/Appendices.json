{
    "hands_on_practices": [
        {
            "introduction": "晶体材料的塑性变形主要是通过位错等缺陷的运动来实现的。理解位错运动的内在阻力对于预测材料的机械强度至关重要。本实践旨在运用相场晶体模型，通过构建一个包含位错的简化模型，并计算其在晶格中移动一个原子间距时的能量变化，从而直接量化这个被称为Peierls势垒的内在阻力 。这个练习将帮助你掌握如何利用PFC能量泛函来探究晶体缺陷的核心性质。",
            "id": "3475629",
            "problem": "考虑二维周期性边界条件下的相场晶体（PFC）模型。对于无量纲数密度场$n(\\mathbf{r})$，其自由能泛函由下式给出\n$$\nF[n] = \\int_{\\Omega} \\left[ \\frac{1}{2} n(\\mathbf{r}) \\left( -\\varepsilon + \\left( \\nabla^2 + q_0^2 \\right)^2 \\right) n(\\mathbf{r}) + \\frac{1}{4} n(\\mathbf{r})^4 \\right] \\, d\\mathbf{r},\n$$\n其中$\\varepsilon > 0$是控制临近不稳定性程度的过冷参数，$q_0$是特征波数，$\\Omega$是计算区域。在本问题中，设$q_0 = 1$，因此$\\left( \\nabla^2 + 1 \\right)^2$决定了弹性惩罚项。在标准的PFC标度下，所有量均为无量纲。\n\n该模型中的三角晶格可以用单模近似表示为\n$$\nn_{\\text{tri}}(x,y) = n_0 + 2 A \\left[ \\cos\\left( k_{1x} x + k_{1y} y \\right) + \\cos\\left( k_{2x} x + k_{2y} y \\right) + \\cos\\left( k_{3x} x + k_{3y} y \\right) \\right],\n$$\n其三个波矢为\n$$\n\\mathbf{k}_1 = (1, 0), \\quad \\mathbf{k}_2 = \\left( \\frac{1}{2}, \\frac{\\sqrt{3}}{2} \\right), \\quad \\mathbf{k}_3 = \\left( -\\frac{1}{2}, \\frac{\\sqrt{3}}{2} \\right),\n$$\n参数$A$（晶格振幅）和$n_0$（平均密度）。使用一个矩形周期性区域，其长度为$L_x = 4\\pi$和$L_y = \\frac{4\\pi}{\\sqrt{3}}$，这使得上述三个波矢与该区域的离散傅里叶模式相称。\n\n为了近似计算沿$x$方向位错滑移的 Peierls 势垒，构建一系列构型，其中半平面$y > L_y/2$在$x$方向上刚性平移一个位移量$\\Delta$，并通过一个以$y_0 = L_y/2$为中心的窄滑移区进行平滑过渡：\n$$\nS(y) = \\frac{1}{2}\\left[1 + \\tanh\\left( \\frac{y - y_0}{w} \\right)\\right],\n$$\n$$\nn_{\\Delta}(x,y) = S(y)\\, n_{\\text{tri}}(x - \\Delta, y) + \\left[1 - S(y)\\right]\\, n_{\\text{tri}}(x, y),\n$$\n其中$w > 0$是一个控制滑移面厚度的平滑宽度。能量$F(\\Delta)$是对$n_{\\Delta}(x,y)$使用上述 PFC 泛函计算得到的自由能。沿位错线（在此二维设置中与$x$方向对齐）的单位长度 Peierls 势垒定义为\n$$\nB = \\frac{\\max_{\\Delta \\in [0, L_x)} F(\\Delta) - \\min_{\\Delta \\in [0, L_x)} F(\\Delta)}{L_x}.\n$$\n\n从自由能泛函$F[n]$出发，并使用谱方法和周期性边界条件来计算算子$\\left( \\nabla^2 + 1 \\right)^2$，编写一个程序，该程序：\n- 在$\\Omega = [0,L_x) \\times [0,L_y)$上的$N_x \\times N_y$均匀网格上构建$n_{\\text{tri}}(x,y)$。\n- 对$[0, L_x)$内一组均匀间隔的位移$\\Delta$构建$n_{\\Delta}(x,y)$。\n- 通过在区域上对能量密度进行积分，为每个位移计算$F(\\Delta)$。\n- 返回如上定义的势垒$B$。\n\n所有量都用无量纲单位表示。数值积分应作为网格上的黎曼和来执行（即，将能量密度乘以$dx\\,dy$并对所有网格点求和）。谱方法必须使用离散傅里叶变换及其与周期性边界条件一致的相应波数。\n\n您的程序必须为以下每个测试用例计算势垒$B$，这些用例共同构成测试套件：\n1.  $N_x = 128$, $N_y = 128$, $\\varepsilon = 0.05$, $n_0 = -0.10$, $A = 0.27$, $w = 0.08$，并在$[0,L_x)$中使用$64$个均匀间隔的$\\Delta$值。\n2.  $N_x = 128$, $N_y = 128$, $\\varepsilon = 0.02$, $n_0 = -0.05$, $A = 0.12$, $w = 0.08$，并在$[0,L_x)$中使用$64$个均匀间隔的$\\Delta$值。\n3.  $N_x = 128$, $N_y = 128$, $\\varepsilon = 0.20$, $n_0 = -0.15$, $A = 0.35$, $w = 0.04$，并在$[0,L_x)$中使用$64$个均匀间隔的$\\Delta$值。\n4.  $N_x = 128$, $N_y = 128$, $\\varepsilon = 0.05$, $n_0 = 0.00$, $A = 0.00$, $w = 0.08$，并在$[0,L_x)$中使用$64$个均匀间隔的$\\Delta$值。\n\n您的程序应产生单行输出，其中包含四个测试用例的势垒值，格式为用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是表示相应测试用例的无量纲单位长度能量$B$的浮点数。不应打印其他任何文本。",
            "solution": "该问题陈述在计算材料科学领域内提出了一个定义明确且具有坚实科学基础的任务。它要求使用相场晶体（PFC）模型计算二维三角晶体中位错滑移的 Peierls 势垒。所有参数、方程和边界条件都已完整且一致地指定。该问题是有效的。\n\n该解决方案通过数值计算一系列代表晶体被剪切的原子构型的 PFC 自由能泛函来实现。该方法的核心是在网格上对系统进行离散化，并使用谱方法高效地计算能量贡献。\n\n自由能泛函由下式给出：\n$$\nF[n] = \\int_{\\Omega} \\left[ \\frac{1}{2} n(\\mathbf{r}) \\left( -\\varepsilon + \\left( \\nabla^2 + q_0^2 \\right)^2 \\right) n(\\mathbf{r}) + \\frac{1}{4} n(\\mathbf{r})^4 \\right] \\, d\\mathbf{r}\n$$\n当$q_0=1$时，问题定义在周期性矩形区域$\\Omega = [0, L_x) \\times [0, L_y)$上，其中$L_x = 4\\pi$且$L_y = 4\\pi/\\sqrt{3}$。\n\n方法步骤如下：\n\n1.  **数值离散化**：将连续区域$\\Omega$离散化为$N_x \\times N_y$个点的均匀网格。实空间坐标为$(x_i, y_j)$，其中$x_i = i \\cdot \\Delta x$，$y_j = j \\cdot \\Delta y$，网格间距为$\\Delta x = L_x/N_x$和$\\Delta y = L_y/N_y$。对于涉及空间导数的计算，我们转换到傅里叶空间。相应的离散波矢为$k_x = 2\\pi m / L_x$和$k_y = 2\\pi n / L_y$，可使用 `numpy.fft.fftfreq` 函数高效生成。\n\n2.  **能量计算**：总自由能$F[n]$是二次（线性）项和四次（非线性）项的和。采用混合实空间/傅里叶空间方法是其计算的最优选择。\n    *   **非线性项**：四次项$\\frac{1}{4} \\int n^4 \\, d\\mathbf{r}$在实空间中是局域的。其计算方法是在网格上计算$n(x_i, y_j)$，在每个点上取其四次方，然后对所有网格点执行黎曼和：$\\sum_{i,j} \\frac{1}{4} n(x_i, y_j)^4 \\Delta x \\Delta y$。\n    *   **线性项**：二次项$\\frac{1}{2} \\int n \\left( -\\varepsilon + (\\nabla^2 + 1)^2 \\right) n \\, d\\mathbf{r}$包含一个微分算子。此类算子在傅里叶空间中是对角的，这使得它们的应用在计算上非常高效。算子$(\\nabla^2 + 1)^2$在傅里叶域中变成一个乘法因子$(-(k_x^2+k_y^2)+1)^2 = (1-|\\mathbf{k}|^2)^2$。计算过程如下：\n        a. 计算密度场$n(\\mathbf{r})$的离散傅里叶变换（DFT），$n(\\mathbf{r}) \\xrightarrow{\\text{FFT}} \\hat{n}(\\mathbf{k})$。\n        b. 在傅里叶空间中通过逐元素相乘来应用线性算子：$\\hat{g}(\\mathbf{k}) = [-\\varepsilon + (1-|\\mathbf{k}|^2)^2] \\hat{n}(\\mathbf{k})$。\n        c. 将结果变换回实空间：$g(\\mathbf{r}) = \\mathcal{F}^{-1}\\{\\hat{g}(\\mathbf{k})\\}$。\n        d. 然后，积分在实空间中作为黎曼和计算：$\\frac{1}{2}\\sum_{i,j} n(x_i, y_j) g(x_i, y_j) \\Delta x \\Delta y$。\n\n3.  **滑移态的构建**：问题定义了一个构型$n_\\Delta(x,y)$，它模拟一个晶体，其上半部分（$y > y_0$）相对于其下半部分（$y  y_0$）沿$x$轴平移了位移$\\Delta$。这是通过使用双曲正切函数$S(y)$将未平移的三角晶体场$n_{\\text{tri}}(x,y)$与平移后的场$n_{\\text{tri}}(x-\\Delta, y)$进行平滑混合来实现的：\n    $$\n    n_{\\Delta}(x,y) = S(y)\\, n_{\\text{tri}}(x - \\Delta, y) + \\left[1 - S(y)\\right]\\, n_{\\text{tri}}(x, y)\n    $$\n    三角晶格的单模近似$n_{\\text{tri}}$是使用给定的波矢$\\mathbf{k}_1$、$\\mathbf{k}_2$和$\\mathbf{k}_3$构建的，这些波矢与所选的模拟区域相称。\n\n4.  **Peierls 势垒计算**：Peierls 势垒$B$量化了将一个原子面滑过另一个原子面所需的能量成本。它被定义为滑移过程中最大和最小能量构型之间的差值，并按滑移面长度$L_x$进行归一化。算法按以下方式计算$B$：\n    a. 在$[0, L_x)$范围内生成一组$64$个均匀间隔的位移值$\\Delta$。\n    b. 对于每个$\\Delta$，构建密度场$n_\\Delta(x,y)$。\n    c. 使用上述混合空间方法计算总自由能$F(\\Delta) = F[n_\\Delta]$。\n    d. 遍历所有$\\Delta$值后，找到最大和最小能量$\\max F(\\Delta)$和$\\min F(\\Delta)$。\n    e. 势垒计算为$B = (\\max_{\\Delta} F(\\Delta) - \\min_{\\Delta} F(\\Delta)) / L_x$。\n\n5.  **特殊情况**：对于测试用例4，振幅$A$为$0$。这意味着$n_{\\text{tri}}(x,y) = n_0$。由于$n_0$也为$0$，因此对于所有构型，密度场$n(x,y)$恒为零。因此，自由能$F(\\Delta)$始终为零，导致 Peierls 势垒$B=0$。程序通过在$A=0$时返回$0$来高效处理这种情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_barrier(Nx, Ny, epsilon, n0, A, w, num_displacements):\n    \"\"\"\n    Calculates the Peierls barrier B for a given set of PFC parameters.\n    \"\"\"\n    # If the amplitude A is zero, the density field is constant (n0).\n    # The energy is independent of the shift delta, so the barrier is zero.\n    if A == 0.0:\n        return 0.0\n\n    # 1. Define constants, domain, and grid spacings\n    Lx = 4.0 * np.pi\n    Ly = 4.0 * np.pi / np.sqrt(3.0)\n    dx = Lx / Nx\n    dy = Ly / Ny\n    y0 = Ly / 2.0\n\n    # 2. Set up real and Fourier space grids\n    # Real space grid\n    x_vec = np.linspace(0, Lx, Nx, endpoint=False)\n    y_vec = np.linspace(0, Ly, Ny, endpoint=False)\n    xx, yy = np.meshgrid(x_vec, y_vec)\n\n    # Fourier space grid of wave numbers\n    kx_vec = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n    ky_vec = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n    kx, ky = np.meshgrid(kx_vec, ky_vec)\n    k_squared = kx**2 + ky**2\n\n    # 3. Pre-calculate terms that are constant over the delta loop\n    # Linear operator in Fourier space\n    linear_op_k = -epsilon + (1 - k_squared)**2\n    \n    # Blending function S(y)\n    S_y = 0.5 * (1 + np.tanh((yy - y0) / w))\n\n    # Wave vectors for the one-mode triangular lattice approximation\n    k1 = np.array([1.0, 0.0])\n    k2 = np.array([0.5, np.sqrt(3.0) / 2.0])\n    k3 = np.array([-0.5, np.sqrt(3.0) / 2.0])\n    \n    # Terms for constructing the unshifted triangular field\n    n_tri_term1_base = k1[0] * xx + k1[1] * yy\n    n_tri_term2_base = k2[0] * xx + k2[1] * yy\n    n_tri_term3_base = k3[0] * xx + k3[1] * yy\n    \n    n_tri_0 = n0 + 2 * A * (np.cos(n_tri_term1_base) + np.cos(n_tri_term2_base) + np.cos(n_tri_term3_base))\n\n    # 4. Loop over displacements delta to calculate F(delta)\n    delta_vals = np.linspace(0, Lx, num_displacements, endpoint=False)\n    F_delta_list = []\n\n    for delta in delta_vals:\n        # Construct the shifted triangular field n_tri(x-delta, y)\n        n_tri_term1_shifted = n_tri_term1_base - k1[0] * delta\n        n_tri_term2_shifted = n_tri_term2_base - k2[0] * delta\n        n_tri_term3_shifted = n_tri_term3_base - k3[0] * delta\n\n        n_tri_shifted = n0 + 2 * A * (np.cos(n_tri_term1_shifted) + np.cos(n_tri_term2_shifted) + np.cos(n_tri_term3_shifted))\n        \n        # Construct the full blended field n_delta(x, y)\n        n_delta = S_y * n_tri_shifted + (1 - S_y) * n_tri_0\n        \n        # Calculate the free energy F(delta)\n        \n        # Linear part (calculated in Fourier space)\n        n_delta_hat = np.fft.fft2(n_delta)\n        op_n_hat = linear_op_k * n_delta_hat\n        op_n = np.fft.ifft2(op_n_hat)\n        # Integrand is 0.5 * n * op(n). Summing over grid and multiplying by area element completes integration.\n        E_lin = 0.5 * np.sum(n_delta * np.real(op_n)) * dx * dy\n        \n        # Nonlinear part (calculated in real space)\n        E_nonlin = 0.25 * np.sum(n_delta**4) * dx * dy\n        \n        F_delta = E_lin + E_nonlin\n        F_delta_list.append(F_delta)\n\n    # 5. Compute the Peierls barrier B\n    F_max = np.max(F_delta_list)\n    F_min = np.min(F_delta_list)\n    \n    B = (F_max - F_min) / Lx\n    return B\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, epsilon, n0, A, w, num_displacements)\n        (128, 128, 0.05, -0.10, 0.27, 0.08, 64),\n        (128, 128, 0.02, -0.05, 0.12, 0.08, 64),\n        (128, 128, 0.20, -0.15, 0.35, 0.04, 64),\n        (128, 128, 0.05,  0.00, 0.00, 0.08, 64),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and calculate the barrier for the current case.\n        Nx, Ny, epsilon, n0, A, w, num_displacements = case\n        result = calculate_barrier(Nx, Ny, epsilon, n0, A, w, num_displacements)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在探究了晶格中静态缺陷的能量学之后，我们将转向考察晶体材料在持续外力作用下的动态响应。本实践将微观的相场晶体动力学与宏观的材料流变学联系起来，为你展示如何从底层模型推导出材料的粘弹性行为 。通过施加一个恒定的剪切速率，你将推导并计算出材料达到的稳态剪切应力，从而深入理解晶体如何通过扩散过程来耗散能量并产生宏观流动。",
            "id": "3475589",
            "problem": "考虑相场晶体（PFC）模型，它由一个标量序参量场的自由能泛函和守恒动力学定义。相场晶体（PFC）模型描述了原子尺度的密度调制及其在长时间尺度上的扩散弛豫。设自由能泛函为\n$$\nF[\\psi] = \\int_{\\Omega} \\mathrm{d}\\mathbf{r} \\left( \\frac{1}{2}\\,\\psi \\left[ r + \\left(1 + \\nabla^2\\right)^2 \\right] \\psi + \\frac{1}{4}\\,\\psi^4 \\right),\n$$\n其中$\\,\\psi(\\mathbf{r},t)\\,$是无量纲的原子密度场，$\\,r\\,$是一个控制参数，$\\,\\Omega\\,$是一个周期性区域，$\\,\\nabla^2\\,$是拉普拉斯算子。扩散的守恒动力学为\n$$\n\\frac{\\partial \\psi}{\\partial t} + \\mathbf{v}\\cdot\\nabla \\psi = M \\nabla^2 \\mu, \\quad \\mu = \\frac{\\delta F}{\\delta \\psi} = \\left[ r + \\left(1 + \\nabla^2\\right)^2 \\right]\\psi + \\psi^3,\n$$\n其中$\\,M\\,$是迁移率，$\\,\\mu\\,$是化学势。一个沿着$\\,x\\,$方向且梯度在$\\,y\\,$方向上的恒定剪切速率为$\\,\\dot{\\gamma}\\,$的施加宏观简单剪切流由$\\,\\mathbf{v}(\\mathbf{r},t) = \\left(\\dot{\\gamma}\\,y,\\,0\\right)\\,$给出。在PFC背景下，这种宏观剪切可以通过 Lees–Edwards 滑动周期性边界条件来引入，或者等效地，通过变换到一个移动（剪切）参考系$\\,x' = x - \\gamma(t)\\,y\\,$（其中$\\,\\gamma(t) = \\dot{\\gamma}\\,t\\,$），这会在实验室参考系中引入一个平流项$\\,\\mathbf{v}\\cdot\\nabla \\psi\\,$。\n\n您将展示施加的剪切如何通过边界条件或移动参考系进入动力学方程，然后使用适用于长波长、小应变响应的粗粒化简化方法，计算在恒定剪切速率$\\,\\dot{\\gamma}\\,$下的稳态剪切应力。特别地，考虑一个均匀剪切变形，其中微观位移场$\\,\\mathbf{u}(\\mathbf{r},t)\\,$使得无穷小剪切应变为$\\,\\epsilon_{xy}(t) = \\partial u_x / \\partial y\\,$，且相应的宏观剪切应力为$\\,\\sigma_{xy}(t)\\,$。假设\n\n- $\\,\\epsilon_{xy}(t)\\,$在$\\,\\Omega\\,$上空间均匀，并且足够小以至于二次弹性贡献占主导地位。\n- 与守恒PFC动力学一致的过阻尼扩散弛豫，无惯性。\n- 对于小的均匀剪切，粗粒化弹性自由能密度为$\\,\\frac{1}{2} G\\,\\epsilon_{xy}^2\\,$，其中$\\,G\\,$是一个有效剪切模量，通过$\\,F\\,$对$\\,\\epsilon_{xy}\\,$的二阶导数得到。\n- 剪切应变的扩散弛豫由一个单一的弛豫时间$\\,\\tau\\,$表征，该时间源于迁移率$\\,M\\,$和与剪切模式相关的自由能形貌的曲率。\n\n从这些基础出发，推导在恒定剪切速率$\\,\\dot{\\gamma}\\,$下$\\,\\sigma_{xy}(t)\\,$的本构演化方程，并求出当$\\,t \\to \\infty\\,$时达到的稳态剪切应力$\\,\\sigma_{xy}^{\\text{ss}}\\,$。您的推导必须从给定的自由能泛函和动力学方程开始，明确论证剪切如何通过边界条件或移动参考系变换引入，并进而得到与上述假设一致的粗粒化、长时间描述。不要使用预先给定的本构公式；相反，应从模型和假设中推导出任何所需的关系。\n\n实现要求：\n\n- 以无量纲单位表示最终的稳态剪切应力$\\,\\sigma_{xy}^{\\text{ss}}\\,$。\n- 您的程序必须（在内部，无需用户交互）接受一组固定的参数集$\\,\\{(G,\\tau,\\dot{\\gamma})\\}\\,$作为输入，为每组参数计算$\\,\\sigma_{xy}^{\\text{ss}}\\,$，并以指定格式输出所有结果。\n- 不涉及角度单位。\n- 不涉及百分比。\n\n测试集：\n\n- 情况$\\,1\\,$：$\\,G = 30.0\\,$, $\\,\\tau = 2.5\\,$, $\\,\\dot{\\gamma} = 0.02\\,$.\n- 情况$\\,2\\,$：$\\,G = 15.0\\,$, $\\,\\tau = 0.1\\,$, $\\,\\dot{\\gamma} = 0.0\\,$.\n- 情况$\\,3\\,$：$\\,G = 50.0\\,$, $\\,\\tau = 10.0\\,$, $\\,\\dot{\\gamma} = 0.005\\,$.\n- 情况$\\,4\\,$：$\\,G = 5.0\\,$, $\\,\\tau = 0.001\\,$, $\\,\\dot{\\gamma} = 1000.0\\,$.\n- 情况$\\,5\\,$：$\\,G = 80.0\\,$, $\\,\\tau = 0.5\\,$, $\\,\\dot{\\gamma} = 0.1\\,$.\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，即$\\,\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]\\,$，其中每个$\\,\\text{result}_i\\,$是对应测试用例计算出的$\\,\\sigma_{xy}^{\\text{ss}}\\,$，表示为无量纲单位的浮点数。",
            "solution": "该问题陈述被评估为具有科学依据、适定且客观。它提供了相场晶体（PFC）模型的标准形式，并要求在一组物理上一致的粗粒化假设下推导稳态剪切应力。该问题是有效的。\n\n目标是为一个由相场晶体模型控制、处于恒定施加剪切速率$\\dot{\\gamma}$下的系统，推导宏观剪切应力$\\sigma_{xy}(t)$的本构演化方程，并随后求出其稳态值$\\sigma_{xy}^{\\text{ss}}$。\n\n分析始于在问题假设的指导下，建立微观PFC模型与宏观、粗粒化的粘弹性描述之间的联系。\n\nPFC自由能泛函由下式给出\n$$F[\\psi] = \\int_{\\Omega} \\mathrm{d}\\mathbf{r} \\left( \\frac{1}{2}\\,\\psi \\left[ r + \\left(1 + \\nabla^2\\right)^2 \\right] \\psi + \\frac{1}{4}\\,\\psi^4 \\right)$$\n晶相的弹性性质被编码在该泛函中。粗粒化剪切模量$G$代表了周期性密度场$\\psi$发生空间均匀剪切变形时的能量惩罚。它被正式定义为自由能密度在零应变下对剪切应变$\\epsilon_{xy}$的二阶导数。问题将$G$作为一个给定参数，从而绕过了从$F[\\psi]$对其实际计算。因此，自由能密度的弹性分量为$f_{el} = \\frac{1}{2} G\\,\\epsilon_{xy}^2$。\n\n弹性剪切应力$\\sigma_{xy}^{el}$和弹性剪切应变$\\epsilon_{xy}^{el}$之间的关系通过对弹性自由能密度对应变求导得到：\n$$\\sigma_{xy} = \\frac{\\partial f_{el}}{\\partial \\epsilon_{xy}^{el}} = G\\,\\epsilon_{xy}^{el}$$\n这是剪切的胡克定律。注意，系统中的总应力$\\sigma_{xy}$由晶格的弹性变形承载。\n\n系统承受一个恒定的、外部施加的剪切速率$\\dot{\\gamma}$。因此，总剪切应变率$\\dot{\\epsilon}_{xy} = \\frac{d\\epsilon_{xy}}{dt}$等于$\\dot{\\gamma}$。在粘弹性材料中，这个总应变率是弹性应变变化率$\\dot{\\epsilon}_{xy}^{el}$和塑性（或粘性）应变率$\\dot{\\epsilon}_{xy}^{pl}$的和：\n$$\\dot{\\epsilon}_{xy} = \\dot{\\epsilon}_{xy}^{el} + \\dot{\\epsilon}_{xy}^{pl} = \\dot{\\gamma}$$\n\n弹性应变率可以通过对胡克定律求时间导数，用应力变化率来表示：\n$$\\dot{\\epsilon}_{xy}^{el} = \\frac{d}{dt}\\left(\\frac{\\sigma_{xy}}{G}\\right) = \\frac{1}{G} \\frac{d\\sigma_{xy}}{dt}$$\n\n塑性应变率$\\dot{\\epsilon}_{xy}^{pl}$代表不可逆流动。这个过程由PFC模型的扩散动力学$\\frac{\\partial \\psi}{\\partial t} + \\mathbf{v}\\cdot\\nabla \\psi = M \\nabla^2 \\mu$控制。迁移率$M$设定了系统通过重排密度场（例如，通过位错滑移）向自由能最小值弛豫的时间尺度。应力通过这种塑性变形得到弛豫。问题假设这个复杂的微观过程可以由一个单一的宏观弛豫时间$\\tau$来描述。在线性粘弹性框架内，对于一个过阻尼系统，塑性流速由施加的应力驱动。与问题假设一致的最简单模型是塑性应变率与应力成正比的模型，这定义了麦克斯韦流体。其关系为\n$$\\dot{\\epsilon}_{xy}^{pl} = \\frac{\\sigma_{xy}}{\\eta}$$\n其中$\\eta$是剪切粘度。弛豫时间$\\tau$是指在没有外部驱动（$\\dot{\\gamma}=0$）且应变保持恒定的情况下，应力衰减所需的时间。在这种情况下，$\\dot{\\epsilon}_{xy}^{el} = -\\dot{\\epsilon}_{xy}^{pl}$，导致$\\frac{1}{G} \\frac{d\\sigma_{xy}}{dt} = -\\frac{\\sigma_{xy}}{\\eta}$。其解为$\\sigma_{xy}(t) = \\sigma_0 \\exp(-t/(\\eta/G))$。因此，弛豫时间$\\tau$被确定为$\\tau = \\eta/G$。我们因此可以将粘度写为$\\eta = G\\tau$。塑性应变率变为：\n$$\\dot{\\epsilon}_{xy}^{pl} = \\frac{\\sigma_{xy}}{G\\tau}$$\n\n现在，我们将弹性和塑性应变率的表达式代入总应变率方程，从而组合成完整的本构方程：\n$$\\dot{\\gamma} = \\frac{1}{G} \\frac{d\\sigma_{xy}}{dt} + \\frac{\\sigma_{xy}}{G\\tau}$$\n两边乘以$G\\tau$得到剪切应力的演化方程：\n$$\\tau \\frac{d\\sigma_{xy}}{dt} + \\sigma_{xy} = G\\tau\\dot{\\gamma}$$\n这就是线性粘弹性的麦克斯韦模型的本构方程，它是从问题陈述中阐述的物理原理和粗粒化假设推导出来的。\n\n最后一步是确定稳态剪切应力$\\sigma_{xy}^{\\text{ss}}$，即当$t \\to \\infty$时$\\sigma_{xy}$的值。在稳态下，系统变量不随时间变化，因此它们的时间导数为零。在本构方程中令$\\frac{d\\sigma_{xy}}{dt} = 0$可得：\n$$\\tau \\cdot (0) + \\sigma_{xy}^{\\text{ss}} = G\\tau\\dot{\\gamma}$$\n这给出了稳态剪切应力：\n$$\\sigma_{xy}^{\\text{ss}} = G \\tau \\dot{\\gamma}$$\n\n这个结果表明，在连续剪切下，粘弹性固体的流动就像一个有效剪切粘度为$\\eta = G\\tau$的简单粘性流体。稳态应力与剪切模量、弛豫时间和施加的剪切速率成正比。这个公式将用于计算给定测试用例的结果。\n\n每个测试用例$(G, \\tau, \\dot{\\gamma})$的计算都使用这个推导出的公式进行。\n对于情况$1$：$\\sigma_{xy}^{\\text{ss}} = (30.0)(2.5)(0.02) = 1.5$。\n对于情况$2$：$\\sigma_{xy}^{\\text{ss}} = (15.0)(0.1)(0.0) = 0.0$。\n对于情况$3$：$\\sigma_{xy}^{\\text{ss}} = (50.0)(10.0)(0.005) = 2.5$。\n对于情况$4$：$\\sigma_{xy}^{\\text{ss}} = (5.0)(0.001)(1000.0) = 5.0$。\n对于情况$5$：$\\sigma_{xy}^{\\text{ss}} = (80.0)(0.5)(0.1) = 4.0$。\n\n这些数值结果在提供的Python代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state shear stress for a viscoelastic material\n    described by a Maxwell model, based on parameters derived from a\n    coarse-grained Phase-Field Crystal (PFC) model.\n\n    The derivation shows that for a system with shear modulus G,\n    relaxation time tau, under a constant shear rate gamma_dot,\n    the constitutive equation is:\n    sigma + tau * d(sigma)/dt = G * tau * gamma_dot\n\n    In steady state, d(sigma)/dt = 0, which simplifies to:\n    sigma_ss = G * tau * gamma_dot\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (G, tau, gamma_dot)\n    # G: effective shear modulus (dimensionless)\n    # tau: shear strain relaxation time (dimensionless)\n    # gamma_dot: constant shear rate (dimensionless)\n    test_cases = [\n        (30.0, 2.5, 0.02),    # Case 1\n        (15.0, 0.1, 0.0),     # Case 2\n        (50.0, 10.0, 0.005),  # Case 3\n        (5.0, 0.001, 1000.0), # Case 4\n        (80.0, 0.5, 0.1),     # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case.\n        G, tau, gamma_dot = case\n        \n        # Calculate the steady-state shear stress using the derived formula.\n        # sigma_ss = G * tau * gamma_dot\n        sigma_ss = G * tau * gamma_dot\n        \n        results.append(sigma_ss)\n\n    # Format the results into a single string as specified.\n    # The output should be a comma-separated list of floating-point numbers\n    # enclosed in square brackets.\n    # Using str() on floats is sufficient to get the required representation.\n    output_string = f\"[{','.join(map(str, results))}]\"\n\n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "除了体相性质外，晶体表面的结构和稳定性对于晶体生长、平衡形状和催化活性等应用领域也至关重要。本节的最后一个实践将带领你使用PFC框架来研究一个倾斜晶面（vicinal surface）的形貌稳定性 。你将通过计算表面台阶的形成能及其相互作用，来预测一个理想光滑的晶面在特定温度下是会保持其原子级平整（小面化），还是会因热涨落而变得无序（粗糙化）。",
            "id": "3475614",
            "problem": "您的任务是在相场晶体（PFC）框架内，通过计算台阶自由能并预测台阶-台阶相互作用随错切角和温度代理的变化，来制定并实现晶体表面刻面与粗糙化的一个有原则的条件。该建模必须植根于相场晶体自由能泛函和基本的错切几何。您的最终程序必须为每个测试用例计算台阶线自由能、每单位面积的台阶-台阶相互作用贡献、相对于完全平坦取向的总表面过剩自由能变化，以及刻面与粗糙化的布尔分类。\n\n您推导的基础应从相场晶体自由能密度开始，其无量纲形式可以写为\n$$\nf = \\frac{1}{2} \\, n \\left[r + \\left(1 + \\nabla^2 \\right)^2 \\right] n + \\frac{g}{3} \\, n^3 + \\frac{1}{4} \\, n^4,\n$$\n其中$n(\\mathbf{r})$是标度化的数密度场，$r$是控制接近有序化程度的温度代理。晶相存在于$r  0$的情况，液相存在于$r \\ge 0$的情况。在共存点附近的晶态的单模振幅近似中，主导密度波的包络振幅$A(r)$随着与线性不稳定性阈值的距离进行标度，并且包络关联长度$\\xi(r)$在阈值附近发散。使用以下具有物理动机的标度关系：\n$$\nA(r) = \n\\begin{cases}\n\\sqrt{\\alpha \\, (-r)}  \\text{if } r  0,\\\\\n0  \\text{if } r \\ge 0,\n\\end{cases}\n\\qquad\n\\xi(r) = \n\\begin{cases}\n\\lambda \\, (-r)^{-1/2}  \\text{if } r  0,\\\\\n+\\infty  \\text{if } r \\ge 0,\n\\end{cases}\n$$\n其中$\\alpha$和$\\lambda$为正常数。考虑一个相对于低指数晶面具有小错切角$\\theta$（以弧度为单位）的邻近表面。台阶高度为$h > 0$，台阶密度为\n$$\n\\rho_{\\text{step}}(\\theta) = \\frac{\\tan \\theta}{h},\n$$\n平均平台宽度为\n$$\nd(\\theta) = \\frac{h}{\\tan \\theta}.\n$$\n\n将台阶线自由能（线张力）建模为主要由包络梯度贡献决定，并带有一个表示粗糙化效应的唯象熵补偿，得到\n$$\n\\gamma_{\\text{step}}(r) = \\kappa \\left[A(r)^2 - A_c^2 \\right],\n$$\n其中$\\kappa > 0$是一个线张力前因子，$A_c > 0$是一个编码粗糙化转变的常数振幅阈值。对于台阶-台阶相互作用，假设为由包络尾部重叠控制的Yukawa型成对排斥相互作用，\n$$\nV(d; r) = \\mu \\, A(r)^2 \\, e^{-d/\\xi(r)},\n$$\n其中相互作用强度$\\mu > 0$。对于均匀的台阶序列，来自所有邻居的每单位面积的总相互作用能由几何级数求和给出\n$$\nE_{\\text{int}}(\\theta, r) = \\rho_{\\text{step}}(\\theta) \\sum_{n=1}^{\\infty} V(n d(\\theta); r) = \\rho_{\\text{step}}(\\theta) \\, \\mu \\, A(r)^2 \\, \\frac{e^{-d(\\theta)/\\xi(r)}}{1 - e^{-d(\\theta)/\\xi(r)}},\n$$\n如果$A(r)=0$或$\\xi(r)=+\\infty$，该值应取为零。\n\n将相对于完全平坦晶面（$\\theta=0$）的每单位面积的表面过剩自由能变化定义为\n$$\n\\Delta \\gamma(\\theta, r) = \\rho_{\\text{step}}(\\theta) \\, \\gamma_{\\text{step}}(r) + E_{\\text{int}}(\\theta, r).\n$$\n使用此公式对给定的错切角下的刻面与粗糙化进行如下分类：\n- 如果$\\Delta \\gamma(\\theta, r) \\ge 0$，则为刻面化。\n- 如果$\\Delta \\gamma(\\theta, r)  0$，则为粗糙化。\n\n您的推导必须从给定的相场晶体自由能密度和邻近表面几何开始，并逻辑地得出上述关于$A(r)$、$\\xi(r)$、$\\rho_{\\text{step}}(\\theta)$、$d(\\theta)$、$\\gamma_{\\text{step}}(r)$、$V(d; r)$和$E_{\\text{int}}(\\theta, r)$的表达式，以及使用$\\Delta \\gamma(\\theta, r)$的分类标准。您还应该明确讨论小角度极限$\\theta \\to 0^+$以及由$\\gamma_{\\text{step}}(r)$符号决定的斜率所表示的刻面与粗糙化条件。\n\n完成推导后，实现一个Python程序，为每个测试用例计算：\n1. 台阶线自由能$\\gamma_{\\text{step}}(r)$。\n2. 每单位面积的相互作用能$E_{\\text{int}}(\\theta, r)$。\n3. 表面过剩自由能变化$\\Delta \\gamma(\\theta, r)$。\n4. 基于$\\Delta \\gamma(\\theta, r)$符号的刻面（true）与粗糙化（false）的布尔分类。\n\n所有量均为无量纲，角度必须以弧度为单位。使用以下固定参数值：\n- $\\alpha = 1.0$,\n- $\\lambda = 2.0$,\n- $\\kappa = 1.0$,\n- $\\mu = 0.2$,\n- $h = 1.0$,\n- $A_c^2 = 0.02$.\n\n测试套件（每个用例指定为$(r,\\theta)$，单位为弧度）：\n- $(-0.5, 0.2)$,\n- $(-0.1, 0.01)$,\n- $(-0.02, 0.2)$,\n- $(-0.01, 0.2)$,\n- $(-0.0001, 0.2)$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个列表$[\\gamma_{\\text{step}}, E_{\\text{int}}, \\Delta \\gamma, \\text{is\\_faceted}]$。例如，一个有效的输出格式是\n$$\n[\\,[\\gamma_{\\text{step}}^{(1)}, E_{\\text{int}}^{(1)}, \\Delta \\gamma^{(1)}, \\text{True}],\\,[\\gamma_{\\text{step}}^{(2)}, E_{\\text{int}}^{(2)}, \\Delta \\gamma^{(2)}, \\text{False}],\\,\\ldots\\,],\n$$\n其中数值是按上述顺序为每个测试用例计算的。",
            "solution": "经评估，问题陈述是有效的。它在计算材料科学的相场晶体（PFC）框架中具有科学依据，在数学和物理上是自洽的，并且是适定的，提供了制定和执行所需计算的所有必要信息。任务是推导并实现一个晶体表面刻面与粗糙化的模型。\n\n### 理论推导与原理\n\n**1. 相场晶体（PFC）模型**\n起点是无量纲的PFC自由能泛函，一个守恒的Swift-Hohenberg类型模型：\n$$\nF[n] = \\int f \\, d\\mathbf{r} = \\int \\left( \\frac{1}{2} \\, n \\left[r + \\left(1 + \\nabla^2 \\right)^2 \\right] n + \\frac{g}{3} \\, n^3 + \\frac{1}{4} \\, n^4 \\right) d\\mathbf{r}\n$$\n这里，$n(\\mathbf{r})$是一个标量场，表示相对于参考液体密度的原子数密度，$r$是一个作为温度代理的参数，控制着液相和晶相之间的转变。项$\\left(1+\\nabla^2\\right)^2$会惩罚除了特征波矢大小为$k=1$之外的密度变化，从而有利于周期性（晶体）结构。系统在$r \\ge 0$时形成液相，在$r  0$时形成晶体固相。\n\n**2. 单模振幅近似**\n在相变温度附近 ($r \\approx 0$)，晶态可以通过单一主导模式的密度波来近似，例如，由三个平面波叠加形成的二维六方晶格。总密度场可以写成$n(\\mathbf{r}) = A e^{i \\mathbf{k}_1 \\cdot \\mathbf{r}} + A e^{i \\mathbf{k}_2 \\cdot \\mathbf{r}} + A e^{i \\mathbf{k}_3 \\cdot \\mathbf{r}} + \\text{c.c.} + \\ldots$，其中$A$是一个缓变复振幅。将此拟设代入PFC泛函并对快速空间振荡进行积分，可以得到一个关于振幅$A$的Ginzburg-Landau型泛函。平衡体相振幅$A(r)$和关联长度$\\xi(r)$（振幅扰动衰减的特征长度尺度）在$r=0$的二阶相变点附近表现出标准的平均场标度律：\n$$\nA(r)^2 \\propto (-r) \\quad \\text{and} \\quad \\xi(r) \\propto (-r)^{-1/2} \\quad \\text{for } r  0\n$$\n问题提供了这些标度关系的比物理驱动的具体形式：\n$$\nA(r) = \n\\begin{cases}\n\\sqrt{\\alpha \\, (-r)}  \\text{if } r  0,\\\\\n0  \\text{if } r \\ge 0,\n\\end{cases}\n\\qquad\n\\xi(r) = \n\\begin{cases}\n\\lambda \\, (-r)^{-1/2}  \\text{if } r  0,\\\\\n+\\infty  \\text{if } r \\ge 0,\n\\end{cases}\n$$\n其中$\\alpha$和$\\lambda$是正常数。平方振幅$A(r)^2$是结晶有序度的一个度量。\n\n**3. 邻近表面几何**\n邻近表面是一个从低指数晶面轻微错向的表面。它可以被建模为一系列宽度为$d$的平坦平台，由高度为$h$的单原子台阶隔开。对于相对于平台平面的错切角$\\theta$，几何结构决定了台阶密度（垂直于台阶的单位长度内的台阶数）和平均平台宽度：\n$$\n\\rho_{\\text{step}}(\\theta) = \\frac{\\tan \\theta}{h} \\qquad \\text{and} \\qquad d(\\theta) = \\cot \\theta \\, h = \\frac{h}{\\tan \\theta}\n$$\n对于小角度$\\theta \\ll 1$，我们有$\\tan\\theta \\approx \\theta$，所以$\\rho_{\\text{step}}(\\theta) \\approx \\theta/h$和$d(\\theta) \\approx h/\\theta$。\n\n**4. 台阶自由能与台阶-台阶相互作用**\n\n*   **台阶线自由能, $\\gamma_{\\text{step}}(r)$**：台阶是晶体有序中的一种线缺陷。它的产生会带来每单位长度的能量成本，称为线张力或台阶自由能$\\gamma_{\\text{step}}$。在PFC振幅框架中，该能量与台阶核心处振幅场$A$的局域畸变有关。这种畸变的能量密度与振幅的梯度和振幅本身成标度关系，导致线张力与有序度成正比，即$\\gamma_{\\text{step}} \\propto A(r)^2$。问题引入了一个唯象模型，该模型也考虑了粗糙化转变：\n    $$\n    \\gamma_{\\text{step}}(r) = \\kappa \\left[A(r)^2 - A_c^2 \\right]\n    $$\n    这里，$\\kappa > 0$是一个前因子，$A_c^2 > 0$是一个临界阈值。如果晶体有序度强 ($A(r)^2 > A_c^2$)，则$\\gamma_{\\text{step}}(r) > 0$，创建台阶需要能量。如果有序度弱 ($A(r)^2  A_c^2$)，当接近熔化温度时，$\\gamma_{\\text{step}}(r)  0$。负的台阶自由能意味着创建台阶所获得的熵超过了能量成本，导致台阶自发增殖和表面粗糙化。条件$\\gamma_{\\text{step}}(r) = 0$定义了粗糙化转变温度。\n\n*   **台阶-台阶相互作用能, $E_{\\text{int}}(\\theta, r)$**：台阶通过其关联畸变场的长程尾部相互作用。在PFC/Ginzburg-Landau框架中，这些场以特征长度等于关联长度$\\xi(r)$的指数形式衰减。相互作用强度与振幅的平方$A(r)^2$成正比。这为相距为$d$的两个台阶之间的Yukawa型成对相互作用势提供了依据：\n    $$\n    V(d; r) = \\mu \\, A(r)^2 \\, e^{-d/\\xi(r)}\n    $$\n    其中$\\mu > 0$是一个相互作用强度常数。对于间距为$d(\\theta)$的均匀台阶序列，每个台阶的总相互作用能是与所有其他台阶相互作用的总和。为简单起见，问题使用了单边和。给定位置的台阶与距离为$d, 2d, 3d, \\ldots$的台阶相互作用。每单位表面积的总相互作用能是台阶密度乘以每个台阶的这个总相互作用势：\n    $$\n    E_{\\text{int}}(\\theta, r) = \\rho_{\\text{step}}(\\theta) \\sum_{n=1}^{\\infty} V(n d(\\theta); r) = \\rho_{\\text{step}}(\\theta) \\, \\mu \\, A(r)^2 \\sum_{n=1}^{\\infty} e^{-n d(\\theta)/\\xi(r)}\n    $$\n    这个求和是一个几何级数$\\sum_{n=1}^{\\infty} x^n = x/(1-x)$，其中$x = e^{-d(\\theta)/\\xi(r)}$。这就得出了给定的表达式：\n    $$\n    E_{\\text{int}}(\\theta, r) = \\rho_{\\text{step}}(\\theta) \\, \\mu \\, A(r)^2 \\, \\frac{e^{-d(\\theta)/\\xi(r)}}{1 - e^{-d(\\theta)/\\xi(r)}}\n    $$\n    对于$r0$，这种相互作用是排斥的且始终为正。\n\n**5. 表面过剩自由能与刻面准则**\n相对于完全平坦晶面（$\\theta=0$）的邻近表面每单位投影面积的总过剩自由能，是创建台阶的能量和它们相互作用能量的总和：\n$$\n\\Delta \\gamma(\\theta, r) = \\rho_{\\text{step}}(\\theta) \\, \\gamma_{\\text{step}}(r) + E_{\\text{int}}(\\theta, r)\n$$\n这个量决定了刻面表面的稳定性。\n*   **小角度极限与晶面稳定性**：在极限$\\theta \\to 0^+$下，平台宽度$d(\\theta) \\to \\infty$。$E_{\\text{int}}$中的指数项$e^{-d(\\theta)/\\xi(r)}$衰减至零的速度远快于$\\rho_{\\text{step}} \\propto \\theta$的增长速度。因此，对于小$\\theta$，与台阶创建项相比，相互作用项可以忽略不计：\n    $$\n    \\Delta \\gamma(\\theta, r) \\approx \\rho_{\\text{step}}(\\theta) \\, \\gamma_{\\text{step}}(r) \\approx \\frac{\\theta}{h} \\gamma_{\\text{step}}(r) \\quad (\\text{for small } \\theta)\n    $$\n    平坦晶面（$\\theta=0$）的稳定性由表面能“伽马图”在原点的斜率决定。这个斜率与$\\gamma_{\\text{step}}(r)$成正比。如果$\\gamma_{\\text{step}}(r) > 0$，能量随$\\theta$增加，在$\\theta=0$处形成一个尖点，这表示一个稳定的晶面。如果$\\gamma_{\\text{step}}(r)  0$，能量随$\\theta$减小，意味着平坦表面不稳定，会通过形成台阶而自发粗糙化。\n\n*   **通用刻面准则**：问题为任何给定的$\\theta$和$r$定义了分类：\n    *   **刻面化 ($\\Delta \\gamma(\\theta, r) \\ge 0$)**：台阶状表面在能量上不利或等同于平坦表面。系统倾向于最小化台阶密度，从而形成大的、平坦的刻面。\n    *   **粗糙化 ($\\Delta \\gamma(\\theta, r)  0$)**：台阶状表面在能量上是有利的。系统通过引入台阶来降低其自由能，导致一个粗糙的、非刻面的平衡态。\n\n**6. 算法规划**\n该实现将直接应用这些推导出的公式。对于每个测试用例$(r, \\theta)$，程序将：\n1.  计算$A(r)^2 = \\alpha(-r)$，因为所有测试用例的$r  0$。\n2.  计算$\\xi(r) = \\lambda(-r)^{-1/2}$。\n3.  计算台阶线自由能$\\gamma_{\\text{step}}(r) = \\kappa(A(r)^2 - A_c^2)$。\n4.  计算几何量$\\rho_{\\text{step}}(\\theta) = (\\tan\\theta)/h$和$d(\\theta) = h/(\\tan\\theta)$。\n5.  使用几何级数公式计算相互作用能$E_{\\text{int}}(\\theta, r)$。\n6.  将各贡献相加，得到总过剩自由能$\\Delta \\gamma(\\theta, r) = \\rho_{\\text{step}}\\gamma_{\\text{step}} + E_{\\text{int}}$。\n7.  如果$\\Delta \\gamma \\ge 0$，则将结果分类为刻面化（True），否则为粗糙化（False）。\n8.  为每个测试用例收集这四个结果，并按指定格式进行格式化。\n固定参数为：$\\alpha = 1.0$，$\\lambda = 2.0$，$\\kappa = 1.0$，$\\mu = 0.2$，$h = 1.0$，以及$A_c^2 = 0.02$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes step free energies, interactions, and faceting/roughening\n    classification for a crystal surface within the Phase-Field Crystal framework.\n    \"\"\"\n\n    # Define the fixed physical parameters for the model.\n    # All quantities are dimensionless.\n    alpha = 1.0   # Prefactor for amplitude scaling\n    lambda_ = 2.0 # Prefactor for correlation length scaling\n    kappa = 1.0   # Prefactor for step line tension\n    mu_ = 0.2     # Prefactor for step-step interaction strength\n    h = 1.0       # Step height\n    Ac_sq = 0.02  # Squared critical amplitude for roughening transition\n\n    # Test suite: each case is a tuple of (r, theta)\n    # r is the temperature proxy\n    # theta is the miscut angle in radians\n    test_cases = [\n        (-0.5, 0.2),\n        (-0.1, 0.01),\n        (-0.02, 0.2),\n        (-0.01, 0.2),\n        (-0.0001, 0.2),\n    ]\n\n    results = []\n    for r, theta in test_cases:\n        # The model is for the crystalline phase, which exists for r  0.\n        # The liquid phase (r >= 0) is not part of the test suite.\n        if r >= 0:\n            # In the liquid phase, amplitude is zero, so no crystalline order.\n            # This case is handled for completeness but is not tested.\n            A_sq = 0.0\n            xi = np.inf\n            gamma_step = kappa * (A_sq - Ac_sq)\n            E_int = 0.0\n            # Step density is well-defined, but energy contributions are based on A_sq.\n            rho_step = np.tan(theta) / h\n            delta_gamma = rho_step * gamma_step + E_int\n            is_faceted = (delta_gamma >= 0.0)\n            results.append([gamma_step, E_int, delta_gamma, is_faceted])\n            continue\n\n        # == Calculations for the crystalline phase (r  0) ==\n\n        # 1. Calculate squared amplitude and correlation length\n        # A(r)^2 = alpha * (-r)\n        A_sq = alpha * (-r)\n        # xi(r) = lambda * (-r)^(-1/2)\n        xi = lambda_ * ((-r)**(-0.5))\n\n        # 2. Calculate step line free energy (line tension)\n        # gamma_step(r) = kappa * (A(r)^2 - Ac^2)\n        gamma_step = kappa * (A_sq - Ac_sq)\n\n        # 3. Calculate geometric properties of the vicinal surface\n        tan_theta = np.tan(theta)\n        # Step density: rho_step(theta) = tan(theta) / h\n        rho_step = tan_theta / h\n        # Mean terrace width: d(theta) = h / tan(theta)\n        d = h / tan_theta\n\n        # 4. Calculate step-step interaction energy per area\n        # V(d;r) = mu * A^2 * exp(-d/xi)\n        # E_int is a sum of V(n*d) over n=1,2,... which is a geometric series.\n        # E_int = rho_step * mu * A^2 * (exp(-d/xi) / (1 - exp(-d/xi)))\n        exp_term = np.exp(-d / xi)\n        \n        # The denominator can be zero only if d/xi is zero, which is not\n        # physically relevant for these test cases (theta is not pi/2, r is not 0).\n        # np.expm1 is more numerically stable for small arguments, but 1-exp_term is fine here.\n        if exp_term == 1.0:\n            # This would imply infinite interaction, but it's avoided by the problem constraints\n            E_int = np.inf\n        else:\n            E_int = rho_step * mu_ * A_sq * (exp_term / (1.0 - exp_term))\n\n        # 5. Calculate total surface excess free-energy change per area\n        # Delta_gamma = rho_step * gamma_step + E_int\n        delta_gamma = rho_step * gamma_step + E_int\n\n        # 6. Classify faceting vs. roughening\n        # Faceting if Delta_gamma >= 0, Roughening if Delta_gamma  0\n        is_faceted = (delta_gamma >= 0.0)\n\n        # Store the computed values for this test case\n        results.append([gamma_step, E_int, delta_gamma, is_faceted])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # Example: [[val1, val2, ...], [val1, val2, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}