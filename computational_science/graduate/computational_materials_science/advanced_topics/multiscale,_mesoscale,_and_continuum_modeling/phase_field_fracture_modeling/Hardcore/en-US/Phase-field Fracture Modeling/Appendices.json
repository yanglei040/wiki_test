{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex numerical simulations, it is essential to understand the foundational behavior of the phase-field model in its simplest form. This exercise guides you through a cornerstone analytical derivation using the calculus of variations . By solving the Euler–Lagrange equation for the one-dimensional crack problem, you will derive the characteristic exponential profile and verify that the regularized model correctly reproduces the material's fracture toughness, $G_c$, in the limit.",
            "id": "3550298",
            "problem": "Consider a one-dimensional infinite domain $\\mathbb{R}$ within the framework of phase-field modeling of fracture for a stationary straight crack centered at $x=0$. Let $d(x)$ denote the scalar phase-field variable, with $d=1$ representing fully broken material and $d=0$ representing intact material. Assume the Ambrosio-Tortorelli type 2 (AT2) crack surface density functional, a regularization length scale $\\ell0$, critical energy release rate $G_c0$, and a vanishing residual stiffness parameter $\\kappa \\to 0$, so that there is no elastic driving energy and the only energetic contribution is the fracture surface energy. \n\nStarting from the principle of minimum potential energy and the AT2 fracture surface functional expressed in one dimension as\n$$\n\\Psi[d] \\;=\\; \\int_{-\\infty}^{\\infty} G_c \\left( \\frac{d(x)^{2}}{2\\,\\ell} \\;+\\; \\frac{\\ell}{2}\\left(\\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right)^{2} \\right)\\,\\mathrm{d}x,\n$$\ndetermine the equilibrium phase-field profile $d(x)$ corresponding to a stationary straight crack by solving the associated Euler–Lagrange equation subject to the physically motivated conditions $d(0)=1$ and $d(x)\\to 0$ as $|x|\\to\\infty$. Then, using that profile, verify analytically that the total fracture surface energy per unit area of the crack equals $G_c$ by evaluating the integral $\\Psi[d]$.\n\nYour final answer must provide:\n- the closed-form expression of the equilibrium profile $d(x)$, and\n- the value of the fracture surface energy per unit area, expressed symbolically in terms of $G_c$.\n\nDo not substitute any numerical values and do not include units in your final boxed answer. Express the energy symbolically in terms of $G_c$ only. If you use any angular quantities, they must be in radians; however, no rounding is required in this problem.",
            "solution": "The user wants to solve for a phase-field fracture problem, here is a step-by-step procedure for this task.\n\n### Step 1: Problem Validation\n\nThe problem statement describes a standard, albeit simplified, scenario in the phase-field modeling of fracture.\n\n**Extracted Givens:**\n*   **Domain:** One-dimensional infinite domain $\\mathbb{R}$.\n*   **Physical Setup:** A stationary straight crack centered at $x=0$.\n*   **Phase-Field Variable:** $d(x)$, with $d=1$ for broken material and $d=0$ for intact material.\n*   **Fracture Surface Functional (AT2):** $\\Psi[d] = \\int_{-\\infty}^{\\infty} G_c \\left( \\frac{d(x)^{2}}{2\\,\\ell} + \\frac{\\ell}{2}\\left(\\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right)^{2} \\right)\\,\\mathrm{d}x$.\n*   **Parameters:** Regularization length scale $\\ell0$ and critical energy release rate $G_c0$.\n*   **Assumption:** No elastic driving energy (equivalent to vanishing residual stiffness $\\kappa \\to 0$).\n*   **Boundary Conditions:** $d(0)=1$ and $d(x)\\to 0$ as $|x|\\to\\infty$.\n*   **Objective 1:** Find the equilibrium phase-field profile $d(x)$ by solving the Euler–Lagrange equation for the functional $\\Psi[d]$.\n*   **Objective 2:** Analytically verify that the total fracture surface energy $\\Psi[d]$ evaluates to $G_c$ using the derived profile $d(x)$.\n\n**Validation Verdict:**\nThe problem is **valid**.\n1.  **Scientifically Grounded:** The problem uses the Ambrosio-Tortorelli (AT2) functional, a cornerstone of variational fracture mechanics. The use of the Euler-Lagrange equation to find the equilibrium profile by minimizing the potential energy functional is a standard method in physics and mechanics.\n2.  **Well-Posed:** The problem is a well-defined boundary value problem for a second-order ordinary differential equation. The givens are sufficient and consistent, leading to a unique, stable, and meaningful solution.\n3.  **Objective:** The language is formal and precise, with all terms defined within the context of computational geomechanics and phase-field theory.\n\n### Step 2: Solution Derivation\n\nThe equilibrium profile $d(x)$ is the function that minimizes the potential energy functional $\\Psi[d]$. Since there is no elastic energy, we only need to minimize the fracture surface functional. This is a classic problem in the calculus of variations.\n\nThe integrand of the functional is the Lagrangian, $L$:\n$$\nL\\left(d, \\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right) = G_c \\left( \\frac{d^{2}}{2\\,\\ell} + \\frac{\\ell}{2}\\left(\\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right)^{2} \\right)\n$$\nThe function $d(x)$ that minimizes $\\Psi[d]$ must satisfy the Euler–Lagrange equation:\n$$\n\\frac{\\partial L}{\\partial d} - \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{\\partial L}{\\partial (\\mathrm{d}d/\\mathrm{d}x)}\\right) = 0\n$$\nFirst, we compute the partial derivatives of $L$:\n$$\n\\frac{\\partial L}{\\partial d} = G_c \\left(\\frac{2d}{2\\ell}\\right) = \\frac{G_c d}{\\ell}\n$$\n$$\n\\frac{\\partial L}{\\partial (\\mathrm{d}d/\\mathrm{d}x)} = G_c \\left(\\frac{\\ell}{2} \\cdot 2 \\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right) = G_c \\ell \\frac{\\mathrm{d}d}{\\mathrm{d}x}\n$$\nSubstituting these into the Euler-Lagrange equation gives:\n$$\n\\frac{G_c d}{\\ell} - \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(G_c \\ell \\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right) = 0\n$$\nSince $G_c$ and $\\ell$ are non-zero constants, we can simplify the equation:\n$$\n\\frac{d}{\\ell} - \\ell \\frac{\\mathrm{d}^2 d}{\\mathrm{d}x^2} = 0\n$$\n$$\n\\frac{\\mathrm{d}^2 d}{\\mathrm{d}x^2} - \\frac{1}{\\ell^2} d = 0\n$$\nThis is a second-order linear homogeneous ordinary differential equation with constant coefficients. The characteristic equation is $r^2 - 1/\\ell^2 = 0$, which has roots $r_1 = 1/\\ell$ and $r_2 = -1/\\ell$.\nThe general solution is therefore:\n$$\nd(x) = C_1 \\exp\\left(\\frac{x}{\\ell}\\right) + C_2 \\exp\\left(-\\frac{x}{\\ell}\\right)\n$$\nwhere $C_1$ and $C_2$ are constants to be determined by the boundary conditions.\n\nThe boundary conditions are $d(x) \\to 0$ as $|x| \\to \\infty$ and $d(0)=1$.\n1.  For the condition $d(x) \\to 0$ as $x \\to \\infty$, the term $C_1 \\exp(x/\\ell)$ would grow infinitely unless $C_1=0$. So, for $x0$, we must have $C_1=0$.\n2.  For the condition $d(x) \\to 0$ as $x \\to -\\infty$, the term $C_2 \\exp(-x/\\ell)$ would grow infinitely unless $C_2=0$. So, for $x0$, we must have $C_2=0$.\n\nThis suggests we should consider the solution piecewise, or more elegantly, combine the decay conditions using the absolute value function, which is also consistent with the physical symmetry of the problem around the crack center at $x=0$. The solution that decays for both $x \\to \\infty$ and $x \\to -\\infty$ must have the form:\n$$\nd(x) = C \\exp\\left(-\\frac{|x|}{\\ell}\\right)\n$$\nNow, we apply the condition at the crack center, $d(0)=1$:\n$$\nd(0) = C \\exp\\left(-\\frac{|0|}{\\ell}\\right) = C \\exp(0) = C = 1\n$$\nThus, the equilibrium phase-field profile is:\n$$\nd(x) = \\exp\\left(-\\frac{|x|}{\\ell}\\right)\n$$\n\nNext, we verify that the total fracture surface energy $\\Psi[d]$ for this profile equals $G_c$. We substitute $d(x)$ and its derivative into the functional.\nThe derivative of $d(x)$ for $x \\neq 0$ is:\n$$\n\\frac{\\mathrm{d}d}{\\mathrm{d}x} = -\\frac{\\mathrm{sgn}(x)}{\\ell} \\exp\\left(-\\frac{|x|}{\\ell}\\right)\n$$\nwhere $\\mathrm{sgn}(x)$ is the sign function.\nThe square of the derivative is:\n$$\n\\left(\\frac{\\mathrm{d}d}{\\mathrm{d}x}\\right)^2 = \\frac{1}{\\ell^2} \\exp\\left(-\\frac{2|x|}{\\ell}\\right)\n$$\nThe square of the profile itself is:\n$$\nd(x)^2 = \\exp\\left(-\\frac{2|x|}{\\ell}\\right)\n$$\nNow, substitute these into the integral for $\\Psi[d]$:\n$$\n\\Psi[d] = \\int_{-\\infty}^{\\infty} G_c \\left( \\frac{\\exp(-2|x|/\\ell)}{2\\ell} + \\frac{\\ell}{2} \\left(\\frac{1}{\\ell^2} \\exp(-2|x|/\\ell)\\right) \\right)\\,\\mathrm{d}x\n$$\n$$\n\\Psi[d] = \\int_{-\\infty}^{\\infty} G_c \\left( \\frac{\\exp(-2|x|/\\ell)}{2\\ell} + \\frac{\\exp(-2|x|/\\ell)}{2\\ell} \\right)\\,\\mathrm{d}x\n$$\nThe two terms in the integrand are identical. This is a manifestation of the principle of equipartition of energy for this type of variational problem.\n$$\n\\Psi[d] = \\int_{-\\infty}^{\\infty} G_c \\frac{\\exp(-2|x|/\\ell)}{\\ell} \\,\\mathrm{d}x = \\frac{G_c}{\\ell} \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{2|x|}{\\ell}\\right) \\,\\mathrm{d}x\n$$\nThe integrand is an even function, so we can write the integral as twice the integral from $0$ to $\\infty$:\n$$\n\\Psi[d] = \\frac{G_c}{\\ell} \\left( 2 \\int_{0}^{\\infty} \\exp\\left(-\\frac{2x}{\\ell}\\right) \\,\\mathrm{d}x \\right)\n$$\nWe now evaluate the definite integral:\n$$\n\\int_{0}^{\\infty} \\exp\\left(-\\frac{2x}{\\ell}\\right) \\,\\mathrm{d}x = \\left[ -\\frac{\\ell}{2} \\exp\\left(-\\frac{2x}{\\ell}\\right) \\right]_{0}^{\\infty}\n$$\n$$\n= \\left( \\lim_{x\\to\\infty} -\\frac{\\ell}{2} \\exp\\left(-\\frac{2x}{\\ell}\\right) \\right) - \\left( -\\frac{\\ell}{2} \\exp(0) \\right)\n$$\n$$\n= (0) - \\left(-\\frac{\\ell}{2}\\right) = \\frac{\\ell}{2}\n$$\nSubstituting this result back into the expression for $\\Psi[d]$:\n$$\n\\Psi[d] = \\frac{G_c}{\\ell} \\left( 2 \\cdot \\frac{\\ell}{2} \\right) = \\frac{G_c}{\\ell} (\\ell) = G_c\n$$\nThis analytically verifies that the total fracture surface energy per unit area for the regularized crack profile is indeed equal to the critical energy release rate $G_c$, as required by the theory.\n\nThe two parts of the final answer are the profile $d(x)$ and the energy value $\\Psi[d]$.\n1.  Profile: $d(x) = \\exp(-|x|/\\ell)$\n2.  Energy: $\\Psi = G_c$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\exp\\left(-\\frac{|x|}{\\ell}\\right)  G_c \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "A powerful theoretical model is only useful if its parameters can be connected to real-world, measurable properties. This hands-on coding practice demonstrates how to calibrate the internal length scale, $\\ell$, from an experimentally observed process zone width . Furthermore, it introduces the critical concept of mesh sensitivity by using a surrogate model to explore how the predicted failure load can be affected by the finite element mesh resolution, a primary challenge in computational fracture mechanics.",
            "id": "3476013",
            "problem": "You are asked to construct a complete, runnable program that calibrates the internal length scale parameter in phase-field fracture modeling from measured process zone sizes and then examines mesh dependence of the peak load in three-point bending using a scientifically grounded surrogate model. The context is Computational Materials Science and the topic is phase-field fracture modeling for brittle materials with the Ambrosio–Tortorelli regularization, specifically the quadratic model often referred to as AT-2.\n\nStarting point and fundamental base:\n- In the phase-field description of brittle fracture, the crack is represented by a scalar damage field $d(x)$ that regularizes sharp cracks over a finite width controlled by an internal length scale parameter $\\ell$. The crack surface density functional in the Ambrosio–Tortorelli quadratic model (AT-2) is defined as\n$$\n\\gamma(d,\\nabla d) \\equiv \\frac{d^2}{2\\ell} + \\frac{\\ell}{2} \\lVert \\nabla d \\rVert^2,\n$$\nso that the fracture surface energy is $G_c \\int \\gamma(d,\\nabla d) \\,\\mathrm{d}x$ where $G_c$ is the critical energy release rate (fracture toughness).\n- The stationary profile of the damage field for an isolated crack in one dimension is obtained by minimizing the integral of $\\gamma$ with respect to $d(x)$, leading to the Euler–Lagrange ordinary differential equation. The resulting characteristic decay of $d(x)$ determines the process zone width over which the damage field exceeds a chosen threshold $d_{\\mathrm{th}}$ used to define the measurable crack process zone width $w_{\\mathrm{crack}}$.\n- The elastic strain energy density under uniaxial stress is $\\psi_0 = \\sigma^2 / (2E)$ where $\\sigma$ is the stress and $E$ is the Young's modulus. A basic energy balance argument for crack initiation in a regularized model equates the elastic energy released in the process zone to the fracture energy $G_c$ consumed by forming the diffused crack.\n\nYour tasks:\n1. Calibrate the internal length $\\ell$ from a directly measured process zone width $w_{\\mathrm{crack}}$ for a chosen threshold $d_{\\mathrm{th}}$ by using the one-dimensional stationary damage profile obtained from minimizing the AT-2 fracture surface density. Use the exact relation between $w_{\\mathrm{crack}}$ and $\\ell$ implied by this profile to determine $\\ell$ for each test case.\n2. Using a first-principles energy balance, derive a scaling for the critical stress $\\sigma_c$ at damage initiation in terms of $E$, $G_c$, and $w_{\\mathrm{crack}}$. Then, using classical beam theory for a simply supported rectangular beam in three-point bending, compute the peak load $P_{\\mathrm{ref}}$ at which the maximum fiber stress equals $\\sigma_c$. The maximum bending stress at the extreme fiber under a mid-span load $P$ and span $L$ for a beam of width $b$ and thickness $t$ is $\\sigma_{\\max} = (3 P L)/(2 b t^2)$, and initiation occurs when $\\sigma_{\\max} = \\sigma_c$.\n3. Examine mesh dependence of the peak load by adopting a surrogate numerical error model motivated by the resolution requirement of the phase-field regularization. Let $n$ denote the number of elements across the process zone, $n = w_{\\mathrm{crack}}/h$, where $h$ is the mesh size. For linear finite elements, assume a first-order error scaling in the peak load, modeled as\n$$\nP_{\\mathrm{peak}}(h) = P_{\\mathrm{ref}} \\left( 1 + \\beta \\frac{h}{w_{\\mathrm{crack}}} \\right),\n$$\nwith a mesh bias coefficient $\\beta$ that captures the tendency for under-resolved gradients to overestimate the peak load. Use $\\beta = 0.25$ for all test cases.\n\nUnits and outputs:\n- All inputs and computations must use the International System of Units (SI). Specifically, lengths must be in meters ($\\mathrm{m}$), Young’s modulus in pascals ($\\mathrm{Pa}$), fracture toughness in joules per square meter ($\\mathrm{J}/\\mathrm{m}^2$ or equivalently $\\mathrm{N}/\\mathrm{m}$), and loads in newtons ($\\mathrm{N}$).\n- The program must produce a single line of output containing the aggregated results as a comma-separated list enclosed in square brackets. For each test case, the result must be the list $[\\ell, P_{\\mathrm{peak}}(h_1), P_{\\mathrm{peak}}(h_2), P_{\\mathrm{peak}}(h_3)]$ using the mesh sizes specified below, so the final output is a list of these lists, for example $[[\\dots],[\\dots],[\\dots]]$ without any spaces.\n\nTest suite:\nUse the following three test cases. For each case, the mesh sizes must be defined relative to the calibrated $\\ell$ after it is computed for that case as $h_1 = \\ell/10$, $h_2 = \\ell/2$, $h_3 = 2\\ell$.\n\n- Test case $1$ (stiff, high $E$ material):\n  - Measured process zone width: $w_{\\mathrm{crack}} = 0.002\\ \\mathrm{m}$.\n  - Threshold for damage width definition: $d_{\\mathrm{th}} = 0.5$.\n  - Young’s modulus: $E = 210 \\times 10^9\\ \\mathrm{Pa}$.\n  - Fracture toughness: $G_c = 1000\\ \\mathrm{N}/\\mathrm{m}$.\n  - Beam width: $b = 0.01\\ \\mathrm{m}$.\n  - Beam thickness: $t = 0.005\\ \\mathrm{m}$.\n  - Span: $L = 0.1\\ \\mathrm{m}$.\n\n- Test case $2$ (moderate stiffness material):\n  - Measured process zone width: $w_{\\mathrm{crack}} = 0.003\\ \\mathrm{m}$.\n  - Threshold for damage width definition: $d_{\\mathrm{th}} = 0.5$.\n  - Young’s modulus: $E = 70 \\times 10^9\\ \\mathrm{Pa}$.\n  - Fracture toughness: $G_c = 300\\ \\mathrm{N}/\\mathrm{m}$.\n  - Beam width: $b = 0.02\\ \\mathrm{m}$.\n  - Beam thickness: $t = 0.004\\ \\mathrm{m}$.\n  - Span: $L = 0.12\\ \\mathrm{m}$.\n\n- Test case $3$ (low stiffness, large process zone material):\n  - Measured process zone width: $w_{\\mathrm{crack}} = 0.010\\ \\mathrm{m}$.\n  - Threshold for damage width definition: $d_{\\mathrm{th}} = 0.5$.\n  - Young’s modulus: $E = 3 \\times 10^9\\ \\mathrm{Pa}$.\n  - Fracture toughness: $G_c = 1000\\ \\mathrm{N}/\\mathrm{m}$.\n  - Beam width: $b = 0.015\\ \\mathrm{m}$.\n  - Beam thickness: $t = 0.003\\ \\mathrm{m}$.\n  - Span: $L = 0.08\\ \\mathrm{m}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists with no spaces, in the order of the test cases, namely\n$$\n\\left[ [\\ell_1,P_{\\mathrm{peak},1}(h_1),P_{\\mathrm{peak},1}(h_2),P_{\\mathrm{peak},1}(h_3)], [\\ell_2,P_{\\mathrm{peak},2}(h_1),P_{\\mathrm{peak},2}(h_2),P_{\\mathrm{peak},2}(h_3)], [\\ell_3,P_{\\mathrm{peak},3}(h_1),P_{\\mathrm{peak},3}(h_2),P_{\\mathrm{peak},3}(h_3)] \\right]\n$$\nwith numerical values in SI units. The elements must be floats, and the single printed line must match the exact bracketed, comma-separated format with no additional text.",
            "solution": "The problem requires the calibration of a phase-field fracture model parameter and a subsequent analysis of mesh dependence on peak load predictions. The solution is derived in three sequential parts, following the problem statement.\n\n### Part 1: Calibration of the Internal Length Scale $\\ell$\n\nThe foundation of the model is the Ambrosio–Tortorelli (AT-2) crack surface density functional, given by:\n$$\n\\gamma(d, \\nabla d) = \\frac{d^2}{2\\ell} + \\frac{\\ell}{2} \\lVert \\nabla d \\rVert^2\n$$\nHere, $d$ is the scalar damage field ($d=0$ for intact material, $d=1$ for fully broken) and $\\ell$ is the internal length scale parameter that regularizes the sharp crack over a finite width. The total fracture energy is $W_f = \\int_V G_c \\gamma(d, \\nabla d) \\, \\mathrm{d}V$, where $G_c$ is the material's fracture toughness.\n\nTo calibrate $\\ell$, we consider an isolated, straight crack in a one-dimensional setting. The damage field $d(x)$ varies only in the direction $x$ perpendicular to the crack plane. The stationary profile for $d(x)$ is found by minimizing the fracture energy functional, which leads to the Euler-Lagrange equation. The Lagrangian density is $L(d, d') = G_c \\left( \\frac{d^2}{2\\ell} + \\frac{\\ell}{2}(d')^2 \\right)$, where $d' = \\mathrm{d}d/\\mathrm{d}x$. The Euler-Lagrange equation is:\n$$\n\\frac{\\partial L}{\\partial d} - \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( \\frac{\\partial L}{\\partial d'} \\right) = 0\n$$\n$$\nG_c \\frac{d}{\\ell} - \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( G_c \\ell d' \\right) = 0\n$$\nThis simplifies to the ordinary differential equation:\n$$\nd(x) - \\ell^2 d''(x) = 0\n$$\nFor an isolated crack centered at $x=0$, the physically relevant boundary conditions are $d(0)=1$ (fully cracked) and $d(x) \\to 0$ as $|x| \\to \\infty$ (undamaged material far from the crack). The solution to this boundary value problem is:\n$$\nd(x) = \\exp\\left(-\\frac{|x|}{\\ell}\\right)\n$$\nThe problem defines the process zone width, $w_{\\mathrm{crack}}$, as the region where the damage field exceeds a specified threshold, $d(x) \\ge d_{\\mathrm{th}}$. Due to symmetry, $w_{\\mathrm{crack}} = 2x_{\\mathrm{th}}$, where $x_{\\mathrm{th}}$ is the positive coordinate at which $d(x_{\\mathrm{th}}) = d_{\\mathrm{th}}$.\n$$\nd_{\\mathrm{th}} = \\exp\\left(-\\frac{x_{\\mathrm{th}}}{\\ell}\\right)\n$$\nSolving for $x_{\\mathrm{th}}$ yields:\n$$\nx_{\\mathrm{th}} = -\\ell \\ln(d_{\\mathrm{th}})\n$$\nSince $d_{\\mathrm{th}}  1$, its logarithm is negative, ensuring $x_{\\mathrm{th}}$ is positive. The total process zone width is thus:\n$$\nw_{\\mathrm{crack}} = 2x_{\\mathrm{th}} = -2\\ell \\ln(d_{\\mathrm{th}})\n$$\nThis equation provides a direct relationship between the model parameter $\\ell$ and the measurable quantity $w_{\\mathrm{crack}}$. By inverting this relationship, we can calibrate $\\ell$:\n$$\n\\ell = \\frac{w_{\\mathrm{crack}}}{-2 \\ln(d_{\\mathrm{th}})}\n$$\nThis formula is used to compute $\\ell$ for each test case.\n\n### Part 2: Derivation of the Reference Peak Load $P_{\\mathrm{ref}}$\n\nThe critical stress for crack initiation, $\\sigma_c$, is determined using a simplified energy balance argument. The principle states that at the onset of fracture, the elastic strain energy released from the \"process zone\" must be sufficient to provide the energy required to form the crack, which is the fracture toughness $G_c$.\n\nThe elastic strain energy density stored in the material under uniaxial stress $\\sigma$ is $\\psi_0 = \\frac{\\sigma^2}{2E}$. The volume of material that releases this energy is characterized by the process zone width, $w_{\\mathrm{crack}}$. Per unit of crack area, the released elastic energy is approximated as the energy stored in a column of length $w_{\\mathrm{crack}}$:\n$$\nU_{\\mathrm{el}} = \\psi_0 \\cdot w_{\\mathrm{crack}} = \\frac{\\sigma_c^2}{2E} w_{\\mathrm{crack}}\n$$\nEquating this to the fracture energy consumed per unit area, $G_c$, gives the condition for crack initiation:\n$$\n\\frac{\\sigma_c^2}{2E} w_{\\mathrm{crack}} = G_c\n$$\nSolving for the critical stress $\\sigma_c$:\n$$\n\\sigma_c = \\sqrt{\\frac{2EG_c}{w_{\\mathrm{crack}}}}\n$$\nThis critical stress corresponds to the maximum fiber stress in the three-point bending test at the moment of failure initiation. For a rectangular beam of width $b$ and thickness $t$ under a mid-span load $P$ over a span $L$, the maximum stress is given by:\n$$\n\\sigma_{\\max} = \\frac{3PL}{2bt^2}\n$$\nSetting $\\sigma_{\\max} = \\sigma_c$ and the corresponding load to the reference peak load $P_{\\mathrm{ref}}$:\n$$\n\\sigma_c = \\frac{3P_{\\mathrm{ref}}L}{2bt^2}\n$$\nSolving for $P_{\\mathrm{ref}}$ gives:\n$$\nP_{\\mathrm{ref}} = \\frac{2bt^2}{3L} \\sigma_c = \\frac{2bt^2}{3L} \\sqrt{\\frac{2EG_c}{w_{\\mathrm{crack}}}}\n$$\n\n### Part 3: Mesh-Dependent Peak Load $P_{\\mathrm{peak}}(h)$\n\nNumerical simulations of phase-field fracture are sensitive to the mesh size $h$, especially when the mesh is too coarse to resolve the damage profile within the width $w_{\\mathrm{crack}}$. The problem provides a surrogate model to represent this mesh dependence, assuming a first-order error scaling for linear elements:\n$$\nP_{\\mathrm{peak}}(h) = P_{\\mathrm{ref}} \\left( 1 + \\beta \\frac{h}{w_{\\mathrm{crack}}} \\right)\n$$\nHere, $P_{\\mathrm{ref}}$ is the ideal peak load derived above, $h$ is the mesh element size, and $\\beta$ is a mesh bias coefficient, given as $\\beta = 0.25$. This model captures the common numerical artifact where an under-resolved simulation (large $h/w_{\\mathrm{crack}}$) artificially stiffens the response and overestimates the peak load.\n\nThe analysis is performed for three mesh sizes defined relative to the calibrated length scale $\\ell$: a fine mesh ($h_1 = \\ell/10$), a moderately resolved mesh ($h_2 = \\ell/2$), and a coarse, under-resolved mesh ($h_3 = 2\\ell$). For each test case, we first compute $\\ell$, then $P_{\\mathrm{ref}}$, and finally the values of $P_{\\mathrm{peak}}(h)$ for these three mesh sizes. The final result for each case is the list $[\\ell, P_{\\mathrm{peak}}(h_1), P_{\\mathrm{peak}}(h_2), P_{\\mathrm{peak}}(h_3)]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the phase-field fracture modeling problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (stiff, high E)\",\n            \"w_crack\": 0.002,   # m\n            \"d_th\": 0.5,\n            \"E\": 210e9,         # Pa\n            \"Gc\": 1000,         # N/m\n            \"b\": 0.01,          # m\n            \"t\": 0.005,         # m\n            \"L\": 0.1,           # m\n        },\n        {\n            \"name\": \"Case 2 (moderate stiffness)\",\n            \"w_crack\": 0.003,   # m\n            \"d_th\": 0.5,\n            \"E\": 70e9,          # Pa\n            \"Gc\": 300,          # N/m\n            \"b\": 0.02,          # m\n            \"t\": 0.004,         # m\n            \"L\": 0.12,          # m\n        },\n        {\n            \"name\": \"Case 3 (low stiffness, large process zone)\",\n            \"w_crack\": 0.010,   # m\n            \"d_th\": 0.5,\n            \"E\": 3e9,           # Pa\n            \"Gc\": 1000,         # N/m\n            \"b\": 0.015,         # m\n            \"t\": 0.003,         # m\n            \"L\": 0.08,          # m\n        },\n    ]\n\n    # Fixed parameter for all cases\n    beta = 0.25\n\n    all_results = []\n    \n    for case in test_cases:\n        # Unpack parameters for the current case\n        w_crack = case[\"w_crack\"]\n        d_th = case[\"d_th\"]\n        E = case[\"E\"]\n        Gc = case[\"Gc\"]\n        b = case[\"b\"]\n        t = case[\"t\"]\n        L = case[\"L\"]\n\n        # 1. Calibrate the internal length scale parameter l\n        ell = w_crack / (-2 * np.log(d_th))\n\n        # 2. Calculate the reference peak load P_ref\n        # First, find the critical stress sigma_c from the energy balance\n        sigma_c = np.sqrt((2 * E * Gc) / w_crack)\n        \n        # Then, calculate P_ref from the beam bending formula\n        P_ref = (2 * b * t**2 * sigma_c) / (3 * L)\n\n        # 3. Examine mesh dependence of the peak load\n        # Define the mesh sizes relative to the calibrated ell\n        h1 = ell / 10\n        h2 = ell / 2\n        h3 = 2 * ell\n        mesh_sizes = [h1, h2, h3]\n        \n        peak_loads = []\n        for h in mesh_sizes:\n            # Apply the surrogate numerical error model\n            P_peak = P_ref * (1 + beta * (h / w_crack))\n            peak_loads.append(P_peak)\n            \n        # Assemble the results for the current case\n        case_results = [ell] + peak_loads\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format: [[...],[...],[...]]\n    # Using str().replace() is a robust way to meet the \"no spaces\" requirement.\n    print(str(all_results).replace(' ', ''))\n\nsolve()\n\n```"
        },
        {
            "introduction": "Phase-field models concentrate damage and strain into narrow bands, demanding high mesh resolution that can be computationally prohibitive with uniform meshes. This advanced practice tackles this challenge by guiding you through the implementation of an adaptive mesh refinement (AMR) strategy driven by a physics-based error indicator . You will compare the efficiency of classic $h$-refinement with a more sophisticated $hp$-refinement, gaining insight into how to build powerful and efficient solvers for multiscale fracture problems.",
            "id": "3476039",
            "problem": "You are to implement and compare two adaptive strategies for resolving a one-dimensional proxy of a phase-field crack-tip profile using a polynomial Finite Element Method (FEM). The phase-field variable is denoted by $\\,\\phi(x;\\ell)\\,$ and represents a smooth damage field that transitions between fully broken ($\\,\\phi=1\\,$) and intact ($\\,\\phi=0\\,$) material over a length scale $\\,\\ell0\\,$. The aim is to quantify how the number of degrees of freedom scales with the regularization length $\\,\\ell\\,$ under $\\,h\\,$-refinement (mesh subdivision at fixed polynomial degree) and $\\,hp\\,$-refinement (combined mesh subdivision and polynomial enrichment).\n\nThe modeling base must start from fundamental principles in phase-field fracture modeling. In an isotropic regularized brittle fracture model, the fracture energy density is often written as a sum of a gradient penalty and a local crack density term, such as\n$$\n\\Psi_{\\mathrm{frac}}(\\phi,\\nabla \\phi) \\;=\\; G_c\\left(\\frac{\\ell}{2}\\,|\\nabla \\phi|^2 \\;+\\; \\frac{1}{4\\ell}\\,w(\\phi)\\right),\n$$\nwhere $\\,G_c\\,$ is the critical energy release rate (a material constant), $\\,\\ell\\,$ is the regularization length, and $\\,w(\\phi)\\,$ is a double-well crack density function. The Euler–Lagrange equation for the damage field $\\,\\phi\\,$ derived from minimizing a suitable total potential energy contains a diffusion-like operator $\\,\\ell^2\\Delta \\phi\\,$ that sets a characteristic width of the damage transition zone proportional to $\\,\\ell\\,$. In one spatial dimension, this implies that the crack tip transition layer has a thickness of order $\\,\\mathcal{O}(\\ell)\\,$, and typical gradients scale like $\\,\\mathcal{O}(1/\\ell)\\,$ through the tip region.\n\nTo decouple mechanical coupling from mesh resolution logic and to enforce an analytically controlled ground truth, approximate the crack-tip phase-field by the analytic, smooth proxy\n$$\n\\phi(x;\\ell)\\;=\\;1 - \\exp\\left(-\\frac{|x|}{\\ell}\\right),\n$$\non the domain $\\,\\Omega = [-1,1]\\,$. This proxy respects the expected boundary-layer behavior and gradient scaling near $\\,x=0\\,$ in a regularized crack-tip transition.\n\nDefine the element-wise error indicator\n$$\n\\eta_K \\;\\equiv\\; \\left(\\int_K \\bigl|\\nabla \\phi(x;\\ell)\\bigr|^2\\,dx\\right)^{1/2},\n$$\nand use it to drive adaptive refinement. You must implement two strategies:\n\n- $\\,h\\,$-strategy: refine by bisecting marked elements; keep the polynomial degree fixed at $\\,p=1\\,$.\n- $\\,hp\\,$-strategy: on marked elements, decide between $\\,h\\,$-refinement or $\\,p\\,$-enrichment using the rule below.\n\nYour FEM surrogate is a piecewise polynomial interpolant of degree $\\,p_K\\,$ on each element $\\,K\\,$, constructed by interpolating $\\,\\phi(x;\\ell)\\,$ at the Chebyshev–Lobatto nodes on each element. For quadrature, use Gauss–Legendre with $\\,n_q=\\max(8,2p_K+4)\\,$ points per element. For $\\,hp\\,$-adaptivity, use the following deterministic policy with maximum degree $\\,p_{\\max}=8\\,$:\n- On each marked element $\\,K\\,$ with length $\\,h_K\\,$ and current degree $\\,p_K\\,$, compute the under-resolution indicator\n$$\nr_K \\;=\\; \\frac{h_K\\,p_K}{c_{\\mathrm{res}}\\,\\ell}, \\quad \\text{with } c_{\\mathrm{res}} = 0.5.\n$$\nIf $\\,r_K  1\\,$, perform $\\,h\\,$-refinement (bisect $\\,K\\,$, keep $\\,p_K\\,$ on the children). Otherwise, if $\\,p_K  p_{\\max}\\,$, perform $\\,p\\,$-refinement by setting $\\,p_K \\leftarrow p_K + 1\\,$; if $\\,p_K = p_{\\max}\\,$ and $\\,r_K \\le 1\\,$, perform $\\,h\\,$-refinement.\n\nUse Dörfler marking with parameter $\\,\\theta=0.5\\,$ on the set of error indicators $\\,\\{\\eta_K\\}\\,$ each iteration: pick a minimal subset of elements whose squared indicators sum to at least a fraction $\\,\\theta\\,$ of the total squared indicator.\n\nMeasure crack-tip resolution by the relative $\\,L^2\\,$-error restricted to the window $\\,\\omega_\\ell = \\{ x\\in\\Omega : |x|\\le 3\\ell \\}\\,$:\n$$\nE_{\\mathrm{tip}}(\\ell) \\;=\\; \\frac{\\left(\\int_{\\omega_\\ell} \\left(\\phi(x;\\ell) - \\Pi_h \\phi(x;\\ell)\\right)^2 dx\\right)^{1/2}}{\\left(\\int_{\\omega_\\ell} \\phi(x;\\ell)^2 dx\\right)^{1/2}},\n$$\nwhere $\\,\\Pi_h\\,$ denotes the piecewise polynomial interpolant defined above.\n\nInitialize the mesh as $\\,8\\,$ uniform elements on $\\,[-1,1]\\,$ with $\\,p=1\\,$. On each refinement iteration, apply Dörfler marking, then refine according to the strategy. Stop when either $\\,E_{\\mathrm{tip}}(\\ell) \\le 2\\times 10^{-3}\\,$ or after $\\,12\\,$ refinement iterations, whichever occurs first. Count the global number of degrees of freedom as $\\,\\mathrm{DoF}=1+\\sum_K p_K\\,$ (for $\\,C^0\\,$ continuity in one dimension). Define computational cost by the resulting $\\,\\mathrm{DoF}\\,$ required to meet the stopping criterion.\n\nYour program must do the following:\n\n- Implement the above adaptive interpolation-based surrogate FEM, the element-wise indicator $\\,\\eta_K\\,$, Dörfler marking with $\\,\\theta=0.5\\,$, and the refinement policies for both $\\,h\\,$ and $\\,hp\\,$ strategies.\n- For each given $\\,\\ell\\,$, run both strategies starting from the same initial mesh. Record the final $\\,\\mathrm{DoF}\\,$ when the stopping criterion is satisfied (or at iteration cap).\n- The analytic reference is $\\,\\phi(x;\\ell) = 1 - \\exp(-|x|/\\ell)\\,$. Use $\\,\\phi'(x;\\ell) = \\frac{1}{\\ell}\\exp(-|x|/\\ell)\\,\\mathrm{sign}(x)\\,$ wherever needed for computing $\\,\\eta_K\\,$. Note that $\\,\\phi'\\,$ is undefined at $\\,x=0\\,$, but this does not affect the integrals.\n\nTest Suite:\n- Use the following set of $\\,\\ell\\,$ values: $\\,\\ell\\in\\{0.2,\\,0.05,\\,0.01\\}\\,$.\n- For each $\\,\\ell\\,$, run both strategies and output the final $\\,\\mathrm{DoF}\\,$ as integers.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The list must contain the $\\,\\mathrm{DoF}\\,$ for the $\\,h\\,$-strategy followed by the $\\,\\mathrm{DoF}\\,$ for the $\\,hp\\,$-strategy for each $\\,\\ell\\,$ in the given order. Concretely, the output format is\n$$\n[\\mathrm{DoF}_h(\\ell{=}0.2),\\mathrm{DoF}_{hp}(\\ell{=}0.2),\\mathrm{DoF}_h(\\ell{=}0.05),\\mathrm{DoF}_{hp}(\\ell{=}0.05),\\mathrm{DoF}_h(\\ell{=}0.01),\\mathrm{DoF}_{hp}(\\ell{=}0.01)].\n$$\n\nAll quantities here are dimensionless, so no physical unit conversion is required. Ensure numerical integration is sufficiently accurate as specified. Avoid any external input. The program must be deterministic and reproducible.",
            "solution": "The problem requires the implementation and comparison of two adaptive finite element strategies, $h$-refinement and $hp$-refinement, for resolving a one-dimensional proxy of a phase-field crack-tip profile. The solution involves developing a complete adaptive loop based on an interpolation-based error analysis. The core components of the solution are the mathematical model, the finite element discretization, the adaptive refinement algorithm, and the final implementation.\n\n### 1. Mathematical and Discretization Principles\n\nThe foundation of the problem is the one-dimensional proxy for the phase-field crack profile, given by the function:\n$$\n\\phi(x;\\ell) = 1 - \\exp\\left(-\\frac{|x|}{\\ell}\\right) \\quad \\text{on} \\quad \\Omega = [-1, 1]\n$$\nThis function models a smooth transition from a broken state ($\\phi \\approx 1$) to an intact state ($\\phi=0$) over a characteristic length scale $\\ell$. The sharpness of this transition is governed by the gradient, $\\nabla\\phi$. The squared magnitude of the gradient, used to drive adaptivity, is:\n$$\n|\\nabla \\phi(x;\\ell)|^2 = \\left|\\frac{1}{\\ell}e^{-|x|/\\ell}\\,\\mathrm{sign}(x)\\right|^2 = \\frac{1}{\\ell^2} e^{-2|x|/\\ell}\n$$\nThis function is continuous and sharply peaked at $x=0$, indicating that mesh resolution must be finest around this point, especially for small $\\ell$.\n\nThe continuous function $\\phi(x;\\ell)$ is approximated by a piecewise polynomial interpolant, $\\Pi_h\\phi$. On each element $K = [x_{\\min}, x_{\\max}]$ of the mesh, $\\Pi_h\\phi$ is a polynomial of degree $p_K$. This polynomial is constructed by interpolating the exact function $\\phi(x;\\ell)$ at $p_K+1$ specific points within the element, known as the Chebyshev-Lobatto nodes. These nodes are the extrema of the Chebyshev polynomial of degree $p_K$ and are known to yield excellent approximation properties, forming the basis of so-called spectral element methods. The resulting global approximation $\\Pi_h\\phi$ is continuous ($C^0$) across element boundaries. In one dimension, the total number of degrees of freedom (DoF) for such a discretization is correctly given by $\\mathrm{DoF} = 1 + \\sum_K p_K$.\n\n### 2. Numerical Integration\n\nAll integrals required for the error indicator and the stopping criterion are computed using numerical quadrature. The problem specifies Gauss-Legendre quadrature with a high number of points, $n_q = \\max(8, 2p_K+4)$, for each element $K$. A Gauss-Legendre rule with $n_q$ points integrates polynomials of degree up to $2n_q-1$ exactly. Since our integrands are not polynomials (e.g., they involve exponential terms), a high-order rule is necessary to ensure that the quadrature error is negligible compared to the discretization error we aim to measure. The quadrature points and weights, defined on the reference interval $[-1, 1]$, are mapped to each physical element $K$.\n\n### 3. Adaptive Refinement Algorithm\n\nThe core of the solution is the adaptive loop, which iteratively refines the mesh to reduce the approximation error. This process consists of a sequence of `SOLVE - ESTIMATE - MARK - REFINE`.\n\n**Error Indicator ($\\eta_K$):** The refinement process is driven by the element-wise error indicator:\n$$\n\\eta_K = \\left(\\int_K |\\nabla \\phi(x;\\ell)|^2\\,dx\\right)^{1/2}\n$$\nThis indicator effectively measures the \"activity\" or \"energy\" of the gradient within element $K$. A large value of $\\eta_K$ suggests that the function $\\phi$ changes rapidly within $K$, and therefore the element is a candidate for refinement.\n\n**Dörfler Marking:** Once $\\eta_K$ is computed for all elements, a subset of elements is marked for refinement. We use Dörfler marking with parameter $\\theta=0.5$. This strategy consists of sorting the elements in descending order of their squared indicators, $\\eta_K^2$, and selecting the minimal set of elements $\\mathcal{M}$ such that the sum of their indicators meets a certain fraction of the total:\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\geq \\theta \\sum_{\\text{all } K} \\eta_K^2\n$$\nThis ensures that a fixed portion of the total estimated error is targeted for reduction in each refinement step.\n\n**Refinement Strategies:**\nTwo strategies are implemented for the marked elements:\n\n1.  **$h$-strategy:** The polynomial degree is held constant at $p=1$. Each marked element is bisected into two children of equal size, which inherit the same polynomial degree. This strategy increases resolution by reducing the element size $h_K$.\n\n2.  **$hp$-strategy:** This is a more sophisticated strategy that decides between reducing element size ($h$-refinement) or increasing polynomial degree ($p$-refinement). The decision for a marked element $K$ is based on the under-resolution indicator:\n    $$\n    r_K = \\frac{h_K p_K}{c_{\\mathrm{res}}\\,\\ell}\n    $$\n    where $c_{\\mathrm{res}}=0.5$. This indicator compares the effective resolution of the element, $h_K/p_K$, to the physical length scale $\\ell$.\n    - If $r_K  1$, the element is too large to resolve the feature scale $\\ell$; thus, an $h$-refinement is performed (bisection).\n    - If $r_K \\leq 1$, the element size is adequate. The approximation can be improved more efficiently by increasing the polynomial degree, so a $p$-refinement is performed ($p_K \\to p_K+1$), provided the degree does not exceed a prescribed maximum, $p_{\\max}=8$. If $p_K$ is already at its maximum, an $h$-refinement is performed as a fallback.\n\n### 4. Stopping Criterion and Cost Measurement\n\nThe adaptive loop terminates when the approximation is deemed sufficiently accurate or a maximum number of iterations is reached. Accuracy is measured by the relative $L^2$-error, $E_{\\mathrm{tip}}$, restricted to the \"crack-tip\" window $\\omega_\\ell = \\{x : |x| \\le 3\\ell\\}$:\n$$\nE_{\\mathrm{tip}}(\\ell) = \\frac{\\|\\phi - \\Pi_h \\phi\\|_{L^2(\\omega_\\ell)}}{\\|\\phi\\|_{L^2(\\omega_\\ell)}}\n$$\nThe loop stops if $E_{\\mathrm{tip}}(\\ell) \\le 2\\times 10^{-3}$ or after $12$ iterations. The computational cost is defined as the total number of degrees of freedom, $\\mathrm{DoF}$, in the final mesh. This provides a basis for comparing the efficiency of the $h$- and $hp$-strategies.\n\n### 5. Algorithmic Implementation\n\nThe algorithm is implemented in Python using the `numpy` and `scipy` libraries.\n- An `Element` class stores the properties of each element: its spatial interval $[x_{\\min}, x_{\\max}]$ and its polynomial degree $p$.\n- An `AdaptiveFEMSimulator` class orchestrates the entire process. It manages the mesh (a list of `Element` objects), computes error indicators and tip error, and applies the marking and refinement logic according to the selected strategy (`h` or `hp`).\n- For efficient evaluation of the polynomial interpolant $\\Pi_h\\phi$, `scipy.interpolate.BarycentricInterpolator` is used. This is significantly faster than a naive implementation of the Lagrange formula, especially within the nested quadrature loops.\n- Helper functions are used for standard tasks like generating quadrature rules (`numpy.polynomial.legendre.leggauss`) and interpolation nodes (`numpy.polynomial.chebyshev.chebpts2`).\n- The main `solve` function iterates through the prescribed $\\ell$ values, runs both adaptive strategies for each, collects the resulting DoF counts, and formats the final output.\n\nThis structured approach ensures a correct and verifiable implementation of the specified adaptive finite element procedure.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\n# GLOBAL PARAMETERS (from problem statement)\nP_MAX = 8\nC_RES = 0.5\nTHETA = 0.5\nTOLERANCE = 2e-3\nMAX_ITERATIONS = 12\n\ndef phi(x, ell):\n    \"\"\"Analytic proxy function for the phase-field.\"\"\"\n    return 1.0 - np.exp(-np.abs(x) / ell)\n\ndef d_phi_sq(x, ell):\n    \"\"\"Squared magnitude of the gradient of the phase-field proxy.\"\"\"\n    return (1.0 / ell**2) * np.exp(-2.0 * np.abs(x) / ell)\n\nclass Element:\n    \"\"\"Represents a 1D finite element.\"\"\"\n    def __init__(self, x_min, x_max, p):\n        self.x_min = float(x_min)\n        self.x_max = float(x_max)\n        self.h = self.x_max - self.x_min\n        self.p = int(p)\n\nclass AdaptiveFEMSimulator:\n    \"\"\"Manages the adaptive simulation for a given strategy.\"\"\"\n\n    def __init__(self, ell, strategy):\n        if strategy not in ['h', 'hp']:\n            raise ValueError(\"Strategy must be 'h' or 'hp'\")\n        self.ell = ell\n        self.strategy = strategy\n        self.mesh = self._create_initial_mesh()\n\n    def _create_initial_mesh(self):\n        \"\"\"Creates the initial uniform mesh of 8 elements with p=1.\"\"\"\n        nodes = np.linspace(-1.0, 1.0, 9)\n        return [Element(nodes[i], nodes[i+1], 1) for i in range(8)]\n\n    def _get_quadrature(self, n_q, x_min, x_max):\n        \"\"\"Returns Gauss-Legendre quadrature points and weights on [x_min, x_max].\"\"\"\n        ref_pts, ref_wts = np.polynomial.legendre.leggauss(n_q)\n        h = x_max - x_min\n        pts = x_min + (ref_pts + 1.0) * 0.5 * h\n        wts = ref_wts * 0.5 * h\n        return pts, wts\n\n    def _get_chebyshev_lobatto_nodes(self, p, x_min, x_max):\n        \"\"\"Returns Chebyshev-Lobatto nodes on [x_min, x_max].\"\"\"\n        # chebpts2(p+1) gives p+1 nodes on [-1, 1] including endpoints.\n        ref_nodes = np.polynomial.chebyshev.chebpts2(p + 1)\n        h = x_max - x_min\n        return x_min + (ref_nodes + 1.0) * 0.5 * h\n\n    def calculate_tip_error(self):\n        \"\"\"Calculates the relative L2 error in the tip window.\"\"\"\n        tip_window_min = max(-1.0, -3.0 * self.ell)\n        tip_window_max = min(1.0, 3.0 * self.ell)\n\n        numerator_sq = 0.0\n        denominator_sq = 0.0\n\n        for element in self.mesh:\n            intersect_min = max(element.x_min, tip_window_min)\n            intersect_max = min(element.x_max, tip_window_max)\n\n            if intersect_min  intersect_max:\n                n_q = max(8, 2 * element.p + 4)\n                quad_pts, quad_wts = self._get_quadrature(n_q, intersect_min, intersect_max)\n\n                interp_nodes = self._get_chebyshev_lobatto_nodes(element.p, element.x_min, element.x_max)\n                phi_at_nodes = phi(interp_nodes, self.ell)\n                interpolator = BarycentricInterpolator(interp_nodes, phi_at_nodes)\n\n                phi_exact_vals = phi(quad_pts, self.ell)\n                phi_interp_vals = interpolator(quad_pts)\n                \n                numerator_sq += np.sum((phi_exact_vals - phi_interp_vals)**2 * quad_wts)\n                denominator_sq += np.sum(phi_exact_vals**2 * quad_wts)\n        \n        return np.sqrt(numerator_sq / denominator_sq) if denominator_sq  0 else 0.0\n\n    def calculate_indicators(self):\n        \"\"\"Calculates the error indicator eta_K for each element.\"\"\"\n        indicators = np.zeros(len(self.mesh))\n        for i, element in enumerate(self.mesh):\n            n_q = max(8, 2 * element.p + 4)\n            quad_pts, quad_wts = self._get_quadrature(n_q, element.x_min, element.x_max)\n            integrand_vals = d_phi_sq(quad_pts, self.ell)\n            integral = np.sum(integrand_vals * quad_wts)\n            indicators[i] = np.sqrt(integral)\n        return indicators\n\n    def mark_elements(self, indicators):\n        \"\"\"Performs Dörfler marking.\"\"\"\n        indicators_sq = indicators**2\n        total_indicator_sq = np.sum(indicators_sq)\n        \n        if total_indicator_sq == 0:\n            return []\n            \n        sorted_indices = np.argsort(indicators_sq)[::-1]\n        \n        marked_indices = []\n        current_sum = 0.0\n        theta_sum = THETA * total_indicator_sq\n        \n        for idx in sorted_indices:\n            current_sum += indicators_sq[idx]\n            marked_indices.append(idx)\n            if current_sum = theta_sum:\n                break\n        return marked_indices\n\n    def refine_mesh(self, marked_indices):\n        \"\"\"Creates a new mesh by refining marked elements.\"\"\"\n        new_mesh = []\n        for i, element in enumerate(self.mesh):\n            if i not in marked_indices:\n                new_mesh.append(element)\n                continue\n\n            if self.strategy == 'h':\n                mid_point = (element.x_min + element.x_max) / 2.0\n                new_mesh.append(Element(element.x_min, mid_point, element.p))\n                new_mesh.append(Element(mid_point, element.x_max, element.p))\n            elif self.strategy == 'hp':\n                r_k = (element.h * element.p) / (C_RES * self.ell)\n                \n                perform_h_refinement = False\n                if r_k  1.0:\n                    perform_h_refinement = True\n                else: \n                    if element.p  P_MAX:\n                        new_mesh.append(Element(element.x_min, element.x_max, element.p + 1))\n                    else:\n                        perform_h_refinement = True\n                \n                if perform_h_refinement:\n                    mid_point = (element.x_min + element.x_max) / 2.0\n                    new_mesh.append(Element(element.x_min, mid_point, element.p))\n                    new_mesh.append(Element(mid_point, element.x_max, element.p))\n        self.mesh = new_mesh\n\n    def get_dof(self):\n        \"\"\"Calculates the total number of degrees of freedom.\"\"\"\n        return 1 + sum(el.p for el in self.mesh)\n\n    def run_adaptive_loop(self):\n        \"\"\"Executes the main adaptive refinement loop.\"\"\"\n        for _ in range(MAX_ITERATIONS):\n            error = self.calculate_tip_error()\n            if error = TOLERANCE:\n                break\n            \n            indicators = self.calculate_indicators()\n            marked_indices = self.mark_elements(indicators)\n            \n            if not marked_indices:\n                break\n\n            self.refine_mesh(marked_indices)\n            \n        return self.get_dof()\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [0.2, 0.05, 0.01]\n    results = []\n\n    for ell_val in test_cases:\n        # H-strategy\n        simulator_h = AdaptiveFEMSimulator(ell=ell_val, strategy='h')\n        dof_h = simulator_h.run_adaptive_loop()\n        results.append(dof_h)\n\n        # HP-strategy\n        simulator_hp = AdaptiveFEMSimulator(ell=ell_val, strategy='hp')\n        dof_hp = simulator_hp.run_adaptive_loop()\n        results.append(dof_hp)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}