{
    "hands_on_practices": [
        {
            "introduction": "光学吸收谱是探索材料电子结构的关键实验手段。本实践将引导你从最基本的层面入手，通过一个简化的半导体模型，亲手构建其吸收光谱。你将学习如何通过对倒易空间进行采样来数值计算联合态密度（JDOS），并应用谱展宽技术来模拟真实的谱线形状，从而深刻理解能带结构与光学响应之间的内在联系。",
            "id": "3451139",
            "problem": "考虑一个在独立粒子近似下描述的各向同性三维半导体。带边附近的导带和价带色散关系是抛物线型的，并由有效质量来表征。您将计算一个归一化的吸收光谱形状，该光谱形状是通过在偶极矩阵元恒定的假设下，对联合态密度（JDOS）进行展宽得到的。目标是实现一个程序，通过在倒易空间中进行均匀采样来数值近似JDOS，并应用谱展宽来获得归一化光谱，然后为提供的测试集评估特定量。\n\n基本原理：\n- 对于光子能量为 $E$ 的带间跃迁，联合态密度（JDOS）定义为\n$$\nD(E) \\propto \\int_{\\mathbb{R}^3} \\delta\\big(E_c(\\mathbf{k}) - E_v(\\mathbf{k}) - E\\big)\\, d^3k,\n$$\n其中 $E_c(\\mathbf{k})$ 和 $E_v(\\mathbf{k})$ 分别是导带和价带的能量。\n- 在带边附近，假设色散关系为抛物线型\n$$\nE_c(\\mathbf{k}) = E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_c}, \\quad E_v(\\mathbf{k}) = 0,\n$$\n其中 $E_g$ 是带隙，$m_c$ 是导带有效质量，价带顶被设为零参考点。如果使用非零的价带有效质量 $m_v$，则在波矢 $\\mathbf{k}$ 处的带间跃迁能量遵循\n$$\nE_{cv}(\\mathbf{k}) = E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_r}, \\quad \\text{with} \\quad \\frac{1}{m_r} = \\frac{1}{m_c} + \\frac{1}{m_v},\n$$\n其中 $m_r$ 是折合质量。\n- 谱展宽通过一个面积为单位的线型函数 $L(E - E')$ 来替代狄拉克δ函数。两种标准选择是：\n  1. 宽度参数为 $\\sigma$ 的高斯展宽：\n  $$\n  L_G(E - E') = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(E - E')^2}{2 \\sigma^2}\\right).\n  $$\n  2. 半峰半宽为 $\\gamma$ 的洛伦兹展宽：\n  $$\n  L_L(E - E') = \\frac{1}{\\pi} \\frac{\\gamma}{(E - E')^2 + \\gamma^2}.\n  $$\n- 通过将JDOS与 $L$ 进行卷积，然后归一化至单位面积，可以得到归一化的吸收光谱形状 $I(E)$（无量纲）：\n$$\nI(E) = \\frac{\\int D(E')\\, L(E - E')\\, dE'}{\\int D(E')\\, dE'}.\n$$\n\n数值近似要求：\n- 在波矢空间 $k_x, k_y, k_z \\in [-k_{\\mathrm{max}}, k_{\\mathrm{max}}]$ 中使用一个每轴 $N$ 个点的均匀立方网格，并仅包括球体 $\\|\\mathbf{k}\\| \\le k_{\\mathrm{max}}$ 内的点，以确保跃迁能量不超过预设的最大值。\n- 设 $E_g$ 是以 $\\mathrm{eV}$ 为单位的带隙，$m_c$ 和 $m_v$ 是以电子质量 $m_e$ 的倍数表示的导带和价带有效质量，并设 $E_{\\mathrm{max}}$ 是光谱窗口的最大光子能量，以 $\\mathrm{eV}$ 为单位。通过反演以下公式计算球形截断波矢 $k_{\\mathrm{max}}$：\n$$\nE_{\\mathrm{max}} = E_g + \\frac{\\hbar^2 k_{\\mathrm{max}}^2}{2 m_r},\n$$\n其中 $\\hbar$ 是约化普朗克常数。使用单位为 $\\mathrm{J\\cdot s}$ 的 $\\hbar$，并通过 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ 在电子伏特 ($\\mathrm{eV}$) 和焦耳 ($\\mathrm{J}$) 之间进行一致的能量转换。\n- 对于每个包含的 $\\mathbf{k}$ 点，计算以 $\\mathrm{eV}$ 为单位的 $E_{cv}(\\mathbf{k})$，然后在目标光子能量 $E$ 处评估展宽后的贡献 $L(E - E_{cv}(\\mathbf{k}))$。归一化强度通过对所有包含的 $\\mathbf{k}$ 点进行平均得到：\n$$\nI(E) = \\frac{1}{N_{\\mathrm{in}}} \\sum_{i=1}^{N_{\\mathrm{in}}} L\\big(E - E_{cv}(\\mathbf{k}_i)\\big),\n$$\n其中 $N_{\\mathrm{in}}$ 是球体内部的网格点数。由于 $L$ 对能量的积分为 $1$，这种离散平均可确保 $\\int I(E)\\, dE \\approx 1$。\n- 假设偶极矩阵元是恒定的，因此光谱形状与JDOS成正比，上述定义的归一化对于无量纲输出是充分的。\n\n单位和输出要求：\n- 能量（$E$、$E_g$、$E_{\\mathrm{max}}$）必须以 $\\mathrm{eV}$ 为单位。\n- 有效质量（$m_c$、$m_v$）是 $m_e$ 的倍数（无量纲）。\n- 展宽宽度（高斯展宽为 $\\sigma$，洛伦兹展宽为 $\\gamma$）必须以 $\\mathrm{eV}$ 为单位。\n- 输出强度是无量纲的，并且必须四舍五入到六位小数。\n- 不使用角度。\n- 不使用百分比。\n\n程序任务：\n1. 实现一个函数，给定 $(E, E_g, m_c, m_v, N, E_{\\mathrm{max}}, \\text{broadening type}, \\text{width})$，使用在立方 $N \\times N \\times N$ 波矢网格内的球形截断，计算如上所述的归一化强度 $I(E)$。\n2. 实现一个收敛性检查，给定两个网格尺寸 $N_{\\mathrm{coarse}}$ 和 $N_{\\mathrm{fine}}$，在相同参数下计算绝对差 $\\Delta = |I_{N_{\\mathrm{coarse}}}(E) - I_{N_{\\mathrm{fine}}}(E)|$，结果四舍五入到六位小数。\n\n测试集：\n对于所有情况，使用 $E_g = 1.5\\,\\mathrm{eV}$，$m_c = 0.25\\,m_e$，$m_v = 0.5\\,m_e$，以及 $E_{\\mathrm{max}} = 2.4\\,\\mathrm{eV}$。五个测试案例如下：\n\n- 案例1（标准情况，中等展宽）：高斯展宽，$\\sigma = 0.05\\,\\mathrm{eV}$，$N = 20$，在 $E = 1.8\\,\\mathrm{eV}$ 处评估 $I(E)$。\n- 案例2（阈值行为）：高斯展宽，$\\sigma = 0.20\\,\\mathrm{eV}$，$N = 20$，在 $E = 1.5\\,\\mathrm{eV}$ 处评估 $I(E)$。\n- 案例3（替代线型）：洛伦兹展宽，$\\gamma = 0.05\\,\\mathrm{eV}$，$N = 24$，在 $E = 2.0\\,\\mathrm{eV}$ 处评估 $I(E)$。\n- 案例4（收敛性检查）：高斯展宽，$\\sigma = 0.08\\,\\mathrm{eV}$，$N_{\\mathrm{coarse}} = 12$，$N_{\\mathrm{fine}} = 36$，在 $E = 1.9\\,\\mathrm{eV}$ 处评估 $\\Delta$。\n- 案例5（边界情况，带边附近的窄展宽）：高斯展宽，$\\sigma = 0.01\\,\\mathrm{eV}$，$N = 28，在 $E = 1.51\\,\\mathrm{eV}$ 处评估 $I(E)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，按案例1到5的顺序排列结果。第一、二、三和五个条目是指定案例的强度 $I(E)$，第四个条目是案例4的收敛性绝对差 $\\Delta$。每个值都必须四舍五入到六位小数。例如：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]\n$$\n其中每个 $\\text{result}_i$ 是一个十进制形式的浮点数。",
            "solution": "用户提供的问题是一个有效且适定的计算物理任务。它要求实现一个标准模型来计算半导体的光吸收谱。该模型基于具有抛物线型能带的独立粒子近似。所有必要的物理原理、公式、数值步骤和测试案例参数都已提供，并且它们在科学上是合理且一致的。\n\n解决方案首先建立理论和数值框架，然后进行分步的算法实现。\n\n**1. 物理模型和基本方程**\n\n问题的核心是计算吸收光谱的形状，该形状与联合态密度（JDOS）$D(E)$ 成正比。JDOS计算在价带和导带中由给定光子能量 $E$ 分隔的状态对的数量。对于从能量为 $E_v(\\mathbf{k})$ 的价带态 $\\mathbf{k}$ 到能量为 $E_c(\\mathbf{k})$ 的导带态（对于直接跃迁，$\\mathbf{k}$ 相同）的跃迁，吸收的光子能量为 $E = E_c(\\mathbf{k}) - E_v(\\mathbf{k})$。\n\n问题指定了带边附近的抛物线型能带色散关系：\n$$\nE_c(\\mathbf{k}) = E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_c}\n$$\n$$\nE_v(\\mathbf{k}) = -\\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_v}\n$$\n这里，$E_g$ 是带隙，$m_c$ 和 $m_v$ 分别是导带和价带的有效质量。跃迁能量 $E_{cv}(\\mathbf{k}) = E_c(\\mathbf{k}) - E_v(\\mathbf{k})$ 则为：\n$$\nE_{cv}(\\mathbf{k}) = E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_c} + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_v} = E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2} \\left(\\frac{1}{m_c} + \\frac{1}{m_v}\\right)\n$$\n这可以通过使用由 $\\frac{1}{m_r} = \\frac{1}{m_c} + \\frac{1}{m_v}$ 定义的折合有效质量 $m_r$ 来简化。跃迁能量变为：\n$$\nE_{cv}(\\mathbf{k}) = E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_r}\n$$\n注意，问题设定了 $E_v(\\mathbf{k})=0$ 和 $E_c(\\mathbf{k})=E_g + \\frac{\\hbar^2 \\|\\mathbf{k}\\|^2}{2 m_r^*}$，其中 $m_r^*$ 用来代替 $m_c$。这是一种常见的简化，但对于带间跃迁，使用折合质量 $m_r$ 的形式在物理上是正确的。问题陈述正确地过渡到为 $E_{cv}(\\mathbf{k})$ 使用折合质量 $m_r$，我们也将使用它。必须注意单位：在我们的实现中，$m_c$ 和 $m_v$ 是以电子质量 $m_e$ 的倍数给出的。因此，公式中的质量是 $m_r \\cdot m_e$。所有能量（$E, E_g, E_{\\mathrm{max}}$）都以电子伏特（$\\mathrm{eV}$）为单位，因此在涉及 $\\hbar$ 的计算中，需要与国际单位制（焦耳）进行一致的转换。转换因子是 $e = 1.602176634 \\times 10^{-19} \\, \\mathrm{J/eV}$。\n\n为了便于数值计算，能量公式可以重写为：\n$$\nE_{cv}(\\mathbf{k}) \\, [\\mathrm{eV}] = E_g \\, [\\mathrm{eV}] + \\left( \\frac{\\hbar^2}{2 m_e e} \\right) \\frac{\\|\\mathbf{k}\\|^2}{m_r}\n$$\n其中 $m_r$ 是无量纲的折合质量比，常数因子 $C = \\frac{\\hbar^2}{2 m_e e}$ 的单位是 $\\mathrm{eV} \\cdot \\mathrm{m}^2$。\n\n**2. JDOS的数值近似与谱展宽**\n\nJDOS涉及狄拉克δ函数，这在数值上难以处理。问题规定了一种标准的数值方法：\n1.  **离散化**：将$\\mathbf{k}$空间上的连续积分替换为对一组离散点的求和。这些点选自一个跨越体积 $[-k_{\\mathrm{max}}, k_{\\mathrm{max}}]^3$ 的 $N \\times N \\times N$ 点的均匀立方网格。\n2.  **能量截断**：施加上限能量 $E_{\\mathrm{max}}$。这转化为$\\mathbf{k}$空间中的球形截断 $\\|\\mathbf{k}\\| \\le k_{\\mathrm{max}}$，其中 $k_{\\mathrm{max}}$ 通过反演能量方程确定：\n    $$\n    k_{\\mathrm{max}} = \\sqrt{\\frac{2 m_r m_e (E_{\\mathrm{max}} - E_g) e}{\\hbar^2}}\n    $$\n    只有满足此条件的网格点才被包含在计算中。设这些点的数量为 $N_{\\mathrm{in}}$。\n3.  **谱展宽**：狄拉克δ函数被一个归一化的线型函数 $L(E)$（如高斯函数或洛伦兹函数）所取代。展宽后的光谱 $I(E)$ 是JDOS与 $L(E)$ 的卷积。在数值上，这通过对每个允许的离散跃迁的贡献求和来近似：\n    $$\n    I(E) \\approx \\frac{1}{N_{\\mathrm{in}}} \\sum_{i=1}^{N_{\\mathrm{in}}} L\\big(E - E_{cv}(\\mathbf{k}_i)\\big)\n    $$\n    此公式对所有有贡献的跃迁的线型函数进行平均，并且由于 $\\int L(E) dE = 1$ 而是内在地归一化的。\n\n**3. 算法实现**\n\n该算法在一个名为 `calculate_intensity` 的Python函数中实现，该函数将物理和数值参数作为输入。\n\n1.  **常量和参数计算**：我们定义物理常量 $\\hbar$、$m_e$ 和 $e$。给定输入 $m_c$ 和 $m_v$，我们计算无量纲的折合质量 $m_r$。最大波矢 $k_{\\mathrm{max}}$ 基于 $E_g$、$E_{\\mathrm{max}}$ 和 $m_r$ 进行计算。\n2.  **网格生成**：我们使用 `numpy.linspace` 生成从 $-k_{\\mathrm{max}}$ 到 $k_{\\mathrm{max}}$ 且包含 $N$ 个点的立方网格单轴坐标。然后使用 `numpy.meshgrid` 创建完整的三维 $(k_x, k_y, k_z)$ 点网格。\n3.  **球形筛选**：对于网格上的每个点，我们计算其模长的平方 $\\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$ 并筛选掉满足 $\\|\\mathbf{k}\\|^2 > k_{\\mathrm{max}}^2$ 的点。这避免了昂贵的平方根运算。剩余点的数量为 $N_{\\mathrm{in}}$。\n4.  **跃迁能量计算**：对于球内的 $N_{\\mathrm{in}}$ 个点，我们使用向量化公式计算跃迁能量 $E_{cv}(\\mathbf{k}_i)$。\n5.  **展宽和平均**：对于给定的目标能量 $E$，我们计算差值 $E - E_{cv}(\\mathbf{k}_i)$。将适当的线型函数（高斯或洛伦兹）应用于这些差值。将所得值求和并除以 $N_{\\mathrm{in}}$，以获得最终的归一化强度 $I(E)$。\n6.  **收敛性检查**：对于案例4，使用不同的网格密度 $N_{\\mathrm{coarse}}$ 和 $N_{\\mathrm{fine}}$ 两次调用 `calculate_intensity` 函数。计算两次所得强度的绝对差 $\\Delta = |I_{N_{\\mathrm{coarse}}}(E) - I_{N_{\\mathrm{fine}}}(E)|$。\n\n所有计算都使用 `numpy` 以实现高效的向量化数组操作。最终结果按要求格式化为六位小数。",
            "answer": "```python\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing a normalized absorption spectrum for a\n    semiconductor, based on a provided test suite.\n    \"\"\"\n\n    # Define physical constants\n    HBAR = constants.hbar  # Reduced Planck constant in J·s\n    M_E = constants.m_e    # Electron mass in kg\n    E_CHARGE = 1.602176634e-19  # Electron charge in C (J/eV)\n    \n    def gaussian_lineshape(dE, sigma):\n        \"\"\"\n        Calculates the Gaussian lineshape function.\n        - dE: Energy difference (E_target - E_transition) in eV.\n        - sigma: Broadening width in eV.\n        \"\"\"\n        return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-dE**2 / (2 * sigma**2))\n\n    def lorentzian_lineshape(dE, gamma):\n        \"\"\"\n        Calculates the Lorentzian lineshape function.\n        - dE: Energy difference (E_target - E_transition) in eV.\n        - gamma: Half-width at half-maximum (HWHM) in eV.\n        \"\"\"\n        return (1 / np.pi) * (gamma / (dE**2 + gamma**2))\n\n    def calculate_intensity(E_target, Eg, mc, mv, N, Emax, broadening_type, width):\n        \"\"\"\n        Computes the normalized spectral intensity at a target energy.\n        \"\"\"\n        # 1. Calculate derived physical parameters\n        mr = (mc * mv) / (mc + mv)  # Dimensionless reduced effective mass\n        \n        # This factor converts k^2 (in m^-2) to energy (in eV)\n        # E_cv(k) = Eg + energy_factor * k^2\n        energy_factor = HBAR**2 / (2 * mr * M_E * E_CHARGE)  # Units: eV·m^2\n\n        # 2. Calculate k_max from E_max\n        if Emax = Eg:\n            return 0.0\n        k_max_sq = (Emax - Eg) / energy_factor\n        k_max = np.sqrt(k_max_sq)\n        \n        # 3. Generate k-space grid and apply spherical cutoff\n        if N == 1:\n            k_coords = np.array([0.0])\n        else:\n            k_coords = np.linspace(-k_max, k_max, N)\n\n        kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n        \n        k_sq = kx**2 + ky**2 + kz**2\n        mask = k_sq = k_max_sq\n        k_sq_inside = k_sq[mask]\n        \n        Nin = k_sq_inside.shape[0]\n        if Nin == 0:\n            return 0.0\n\n        # 4. Calculate transition energies for included k-points\n        E_transitions = Eg + energy_factor * k_sq_inside # in eV\n\n        # 5. Calculate broadened intensity\n        dE = E_target - E_transitions\n        \n        if broadening_type == 'gaussian':\n            lineshape_values = gaussian_lineshape(dE, width)\n        elif broadening_type == 'lorentzian':\n            lineshape_values = lorentzian_lineshape(dE, width)\n        else:\n            raise ValueError(\"Unknown broadening type specified\")\n            \n        # 6. Average over all k-points to get normalized intensity\n        intensity = np.sum(lineshape_values) / Nin\n        \n        return intensity\n\n    # Common parameters for all test cases\n    Eg = 1.5      # eV\n    mc = 0.25     # dimensionless (multiple of m_e)\n    mv = 0.5      # dimensionless (multiple of m_e)\n    Emax = 2.4    # eV\n\n    # Define the test suite\n    test_cases = [\n        {'type': 'calc', 'params': {'E_target': 1.8, 'N': 20, 'broadening_type': 'gaussian', 'width': 0.05}},\n        {'type': 'calc', 'params': {'E_target': 1.5, 'N': 20, 'broadening_type': 'gaussian', 'width': 0.20}},\n        {'type': 'calc', 'params': {'E_target': 2.0, 'N': 24, 'broadening_type': 'lorentzian', 'width': 0.05}},\n        {'type': 'conv', 'params': {'E_target': 1.9, 'N_coarse': 12, 'N_fine': 36, 'broadening_type': 'gaussian', 'width': 0.08}},\n        {'type': 'calc', 'params': {'E_target': 1.51, 'N': 28, 'broadening_type': 'gaussian', 'width': 0.01}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        if case['type'] == 'calc':\n            intensity = calculate_intensity(Eg=Eg, mc=mc, mv=mv, Emax=Emax, **case['params'])\n            results.append(intensity)\n        elif case['type'] == 'conv':\n            p = case['params']\n            I_coarse = calculate_intensity(\n                E_target=p['E_target'], Eg=Eg, mc=mc, mv=mv, \n                N=p['N_coarse'], Emax=Emax, \n                broadening_type=p['broadening_type'], width=p['width']\n            )\n            I_fine = calculate_intensity(\n                E_target=p['E_target'], Eg=Eg, mc=mc, mv=mv, \n                N=p['N_fine'], Emax=Emax, \n                broadening_type=p['broadening_type'], width=p['width']\n            )\n            delta = abs(I_coarse - I_fine)\n            results.append(delta)\n    \n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在先进的激发态计算（如LR-TDDFT）中，我们通常只能在有限的非占据轨道（虚轨道）基组下进行计算，这会引入截断误差。本实践旨在让你掌握一种关键的误差修正技术：如何通过对一系列不同基组大小的计算结果进行外推，来预估在无限基组极限下的精确激发能。这不仅是一个数值技巧，更是确保计算结果物理可靠性的重要步骤。",
            "id": "3451141",
            "problem": "本题要求您开发并论证一个数值方法，用以基于线性响应瞬时密度泛函理论 (LR-TDDFT; Linear-Response Time-Dependent Density Functional Theory) 的收敛数据，估算一个材料体系的极限激发能，单位为电子伏特 (eV)。其目标是量化因在有限数量的虚带（表示为 $N_v$）处截断未占据（虚）Kohn-Sham 流形而引入的误差，并提出一种对流形尺寸的倒数进行合理外推的策略，以恢复在 $N_v \\to \\infty$ 极限下的激发能。您的程序必须实现以下任务：\n\n1. 从具有物理动机的基础出发：在 LR-TDDFT 中，激发能是作为由已占据和未占据 Kohn-Sham 轨道之间的跃迁所构建的本征值问题的解而出现的。在有限 $N_v$ 处截断未占据流形会忽略那些通过长程尾部对响应核有贡献的高能跃迁。这些尾部可以通过态求和论证和能量划分，利用由能量分母加权的跃迁密度积分来推导。在对跃迁能和耦合分布作温和的平滑性假设下，被忽略的态的总贡献会随着能量上限截断值的增加而衰减，而该截断值本身随 $N_v$ 单调增长。这为对流形尺寸的倒数进行回归提供了动机，而无需指定任何目标公式或中间简化表达式。\n\n2. 设计并实现一个在统计上合理的外推方法。您的方法必须：\n   - 解释并实施为何将激发能表示为 $x = 1/N_v$ 的函数能够捕捉到与被忽略的高能跃迁相关的渐近尾部。\n   - 使用最小二乘法对给定数据拟合一个关于 $x$ 的低阶模型，并选择受数据支持的最简单模型，同时防止过拟合。在样本量允许的情况下，使用稳健的选择准则，如留一法交叉验证。不要在问题陈述中硬编码任何特定的函数形式。\n   - 返回模型在 $x = 0$ 处评估的截距，作为外推的无限流形极限。\n\n3. 数值输出必须是以电子伏特 (eV) 表示的激发能。每个最终结果必须四舍五入到六位小数。\n\n4. 测试套件。使用以下四个测试用例，它们提供了从假设的 LR-TDDFT 收敛性研究中获得的 $N_v$ 值和相应的激发能 $E(N_v)$ (eV)。每个用例都是独立的，应分别处理以产生一个外推的极限激发能 $E_\\infty$ (eV)。\n   - 用例 A（带有轻微噪声的一般性收敛）：\n     - $N_v = [8, 12, 20, 40, 80]$\n     - $E(N_v) = [2.2047, 2.1704, 2.1418, 2.1211, 2.1104]$ eV\n   - 用例 B（由高阶效应引起的尾部曲率）：\n     - $N_v = [6, 10, 14, 22, 30]$\n     - $E(N_v) = [1.8003, 1.7442, 1.71807, 1.6947148, 1.6825999]$ eV\n   - 用例 C（接近饱和且变化极小）：\n     - $N_v = [20, 40, 80]$\n     - $E(N_v) = [3.50095, 3.50052, 3.50024]$ eV\n   - 用例 D（样本量极小的边界情况）：\n     - $N_v = [10, 100]$\n     - $E(N_v) = [2.10, 2.01]$ eV\n\n5. 输出规范。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含四个外推的极限激发能 $[E_\\infty^{A}, E_\\infty^{B}, E_\\infty^{C}, E_\\infty^{D}]$，每个值都以电子伏特 (eV) 为单位，四舍五入到六位小数，并严格按照以下格式：\n   - 示例格式：$[0.000000,1.000000,2.000000]$\n   - 您的程序不得打印任何额外文本。\n\n您的解决方案必须与任何现代编程语言兼容，但最终答案必须是指定的完整、可运行的 Python 程序。所有数值输出必须以电子伏特 (eV) 为单位，并四舍五入到六位小数。角度不属于本问题。百分比不属于本问题。最终输出必须严格遵守上述单行方括号列表格式。",
            "solution": "该问题要求开发一种数值方法，以确定当虚带数量 $N_v$ 趋于无穷大时材料体系的极限激发能 $E_\\infty$。这是计算材料科学和量子化学中的一项常见任务，其中使用有限基组进行计算的结果必须外推到完备基组极限。所提供的数据包含使用大小为 $N_v$ 的截断未占据 Kohn-Sham 流形计算出的激发能 $E(N_v)$。\n\n问题陈述的验证过程如下：\n1.  **已知条件提取**：\n    -   物理背景：线性响应瞬时密度泛函理论 (LR-TDDFT)。\n    -   参数：$N_v$，虚带数量。\n    -   可观测量：$E(N_v)$，给定 $N_v$ 时的激发能，单位为电子伏特 (eV)。\n    -   目标：估算 $E_\\infty = \\lim_{N_v \\to \\infty} E(N_v)$。\n    -   方法论约束：使用关于变量 $x = 1/N_v$ 的回归模型进行外推。\n    -   模型拟合：使用最小二乘法。\n    -   模型选择：对于足够大的数据集，使用留一法交叉验证 (LOOCV) 在低阶多项式模型之间进行选择，以避免过拟合。\n    -   输出：外推能量 $E_\\infty$，即模型在 $x=0$ 处的截距。\n    -   数据集：提供了四个独立的用例（A, B, C, D），每个用例都包含一个 $N_v$ 值列表和相应的 $E(N_v)$ 能量列表。\n        -   用例 A：$N_v = [8, 12, 20, 40, 80]$，$E(N_v) = [2.2047, 2.1704, 2.1418, 2.1211, 2.1104]$ eV。\n        -   用例 B：$N_v = [6, 10, 14, 22, 30]$，$E(N_v) = [1.8003, 1.7442, 1.71807, 1.6947148, 1.6825999]$ eV。\n        -   用例 C：$N_v = [20, 40, 80]$，$E(N_v) = [3.50095, 3.50052, 3.50024]$ eV。\n        -   用例 D：$N_v = [10, 100]$，$E(N_v) = [2.10, 2.01]$ eV。\n2.  **验证**：\n    -   该问题是**有科学依据的**。基组外推的概念是高精度计算化学的基石。其物理依据根植于态求和微扰理论，正确地为修正项的渐近展开提供了动机。当截断虚空间时，本征值的误差与被忽略的高能态的集体贡献有关。这种贡献可以通过对能量截断值的负幂次展开来系统地近似，而能量截断值与 $N_v$ 单调相关。因此，将 $E(N_v)$ 建模为 $x=1/N_v$ 的函数是一种行之有效且具有物理合理性的拟设。\n    -   该问题是**良定的**和**客观的**。它提供了所有必要的数据，并指定了一个清晰、可证伪的数值协议（最小二乘回归结合标准统计模型选择准则 LOOCV）。其语言是技术性的，没有歧义或主观性。\n    -   该问题没有缺陷；它不是不完整、矛盾、不切实际或微不足道的。\n\n**结论**：该问题是**有效的**。将制定并实施一个解决方案。\n\n**方法论**\n\n任务的核心是将一系列计算出的激发能 $\\{ (N_{v,i}, E_i) \\}$ 外推到 $N_v \\to \\infty$ 的极限。\n\n**1. 以 $x = 1/N_v$ 进行外推的原理**\n\n在 LR-TDDFT 中，激发能是矩阵方程的本征值。在 $N_v$ 处截断虚（未占据）轨道空间是一种基组不完备性的形式。由这种截断引入的误差可以使用微扰理论进行分析。对于一个给定的激发能，来自更高能量的虚-占据轨道跃迁的修正表现出渐近行为。许多从计算中被忽略的高能跃迁的总体效应，通常可以表示为虚空间能量截断值的负幂次渐近级数。假设所包含的最高虚轨道的能量 $\\epsilon_{N_v}$ 是 $N_v$ 的一个平滑、单调递增的函数，则外推可以重新用 $N_v$ 来表述。一个简单而常见的外推变量选择是 $x = 1/N_v$，它将 $N_v \\to \\infty$ 的极限转换为更方便的 $x \\to 0$ 极限。然后我们可以将激发能表示为 $x$ 的低阶多项式：\n$$ E(x) = a_0 + a_1 x + a_2 x^2 + \\mathcal{O}(x^3) $$\n所需的极限能量是该函数的截距，即 $E_\\infty = E(x=0) = a_0$。\n\n**2. 模型构建与拟合**\n\n我们将考虑两个候选模型：一个线性模型（一阶）和一个二次模型（二阶）。\n-   线性模型：$E(x) = a_0 + a_1 x$\n-   二次模型：$E(x) = a_0 + a_1 x + a_2 x^2$\n\n对于给定的数据集 $\\{ (x_i, E_i) \\}_{i=1}^n$（其中 $x_i = 1/N_{v,i}$），每个模型的系数 $(a_0, a_1, \\dots)$ 通过最小化残差平方和 $\\sum_{i=1}^n (E_i - E(x_i))^2$ 来确定。这是一个标准的普通最小二乘 (OLS) 回归问题。\n\n**3. 使用留一法交叉验证 (LOOCV) 进行模型选择**\n\n在线性模型和二次模型之间的选择至关重要。高阶模型可能能更好地拟合给定数据（即具有更低的残差平方和），但可能会对噪声过拟合，导致预测能力较差和外推结果不可靠。为了做出稳健的选择，我们按照规定采用留一法交叉验证。该程序评估模型对未见数据的泛化能力。\n\n对于大小为 $n$ 的数据集和给定的模型（例如，二次模型）：\n1.  对于每个数据点 $i \\in \\{1, \\dots, n\\}$：\n    a.  暂时从数据集中移除点 $(x_i, E_i)$。\n    b.  将模型拟合到剩余的 $n-1$ 个点。\n    c.  使用拟合的模型预测被留出的点的能量：$\\hat{E}_i = E(x_i)$。\n    d.  计算该点的预测平方误差：$(E_i - \\hat{E}_i)^2$。\n2.  LOOCV 分数是这些平方误差的均值：$S_{LOOCV} = \\frac{1}{n} \\sum_{i=1}^n (E_i - \\hat{E}_i)^2$。\n\n我们为线性和二次模型计算 $S_{LOOCV}$。选择具有较低 $S_{LOOCV}$ 分数的模型，因为它表现出更好的泛化能力。当数据点数量 $n$ 大于模型中的参数数量时，此程序适用。\n\n**4. 处理小数据集**\n\nLOOCV 程序对小的 $n$ 值需要特殊考虑：\n-   对于 $n$ 个点，可以拟合最高 $n-1$ 次的多项式。\n-   **用例 D ($n=2$)：** 仅有两个点时，只能唯一确定一个线性模型（它有两个参数，$a_0$ 和 $a_1$）。该模型将精确地穿过这两个点。高阶模型是欠定的。因此，线性拟合是唯一的选择。\n-   **用例 C ($n=3$)：** 有三个点时，可以通过最小二乘法拟合一个线性模型（2个参数）。一个二次模型（3个参数）将完美地插值这三个点，导致训练误差为零。然而，在为二次模型执行 LOOCV 时，每个训练折仅包含2个点。无法将一个3参数的二次模型拟合到2个点上。因此，二次模型的 LOOCV 分数是不明确的。问题要求选择“受数据支持的”最简单模型。由于二次模型无法进行交叉验证，我们默认使用更简单、可稳健拟合的线性模型。\n\n**5. 最终外推**\n\n一旦确定了给定用例的最佳模型阶数（次数 $d \\in \\{1, 2\\}$），就使用该模型对该用例的*整个*数据集执行最终回归。外推的无限流形能量 $E_\\infty$ 是此次最终拟合的截距系数 $a_0$。最终结果四舍五入到六位小数。\n\n这一完整的程序，结合了具有物理动机的外推变量、标准回归技术以及用于模型选择的稳健统计准则，为解决该问题提供了一种有原则且可复现的方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Case A: General convergence with mild noise\n        {\n            \"Nv\": np.array([8, 12, 20, 40, 80]),\n            \"E\": np.array([2.2047, 2.1704, 2.1418, 2.1211, 2.1104]),\n        },\n        # Case B: Curvature in the tail due to higher-order effects\n        {\n            \"Nv\": np.array([6, 10, 14, 22, 30]),\n            \"E\": np.array([1.8003, 1.7442, 1.71807, 1.6947148, 1.6825999]),\n        },\n        # Case C: Near saturation with minimal variation\n        {\n            \"Nv\": np.array([20, 40, 80]),\n            \"E\": np.array([3.50095, 3.50052, 3.50024]),\n        },\n        # Case D: Boundary case with minimal sample size\n        {\n            \"Nv\": np.array([10, 100]),\n            \"E\": np.array([2.10, 2.01]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        extrapolated_energy = extrapolate_energy(case[\"Nv\"], case[\"E\"])\n        results.append(extrapolated_energy)\n\n    # Format the output as specified: [E_A,E_B,E_C,E_D] rounded to 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef loocv_error(x, y, deg):\n    \"\"\"\n    Calculates the Leave-One-Out Cross-Validation error for a polynomial fit.\n    \n    Args:\n        x (np.ndarray): Independent variable.\n        y (np.ndarray): Dependent variable.\n        deg (int): Degree of the polynomial to fit.\n        \n    Returns:\n        float: The mean squared error from LOOCV.\n    \"\"\"\n    n = len(x)\n    # Cannot fit a polynomial of degree `deg` to `n-1` points if `n-1  deg+1`.\n    # This simplifies to `n  deg+2`.\n    if n  deg + 2:\n        return np.inf\n\n    errors = []\n    for i in range(n):\n        # Create training set by removing the i-th point\n        x_train = np.delete(x, i)\n        y_train = np.delete(y, i)\n\n        # The point to be predicted (test set)\n        x_test = x[i]\n        y_test = y[i]\n\n        # Fit model on training data\n        coeffs = np.polyfit(x_train, y_train, deg)\n        \n        # Predict on the test point\n        p = np.poly1d(coeffs)\n        y_pred = p(x_test)\n        \n        # Calculate and store squared error\n        errors.append((y_test - y_pred)**2)\n    \n    return np.mean(errors)\n\ndef extrapolate_energy(Nv, E):\n    \"\"\"\n    Extrapolates excitation energy to the infinite virtual manifold limit.\n    \n    Args:\n        Nv (np.ndarray): Array of numbers of virtual bands.\n        E (np.ndarray): Array of corresponding excitation energies.\n        \n    Returns:\n        float: The extrapolated energy E_infinity.\n    \"\"\"\n    # The extrapolation variable is x = 1/Nv\n    x = 1.0 / Nv\n    n = len(x)\n    \n    best_degree = 1 # Default to linear model\n\n    # Model selection based on the number of data points\n    if n >= 4:\n        # Sufficient data to compare linear and quadratic models using LOOCV\n        # For quadratic (d=2), we need n >= 2+2 = 4 points for LOOCV.\n        error_linear = loocv_error(x, E, deg=1)\n        error_quadratic = loocv_error(x, E, deg=2)\n        \n        if error_quadratic  error_linear:\n            best_degree = 2\n    elif n == 3:\n        # Not enough points to cross-validate a quadratic model, as each\n        # training fold would have 2 points, which is insufficient to\n        # determine 3 parameters. We must use a linear model.\n        best_degree = 1\n    elif n == 2:\n        # Only a linear model (2 parameters) can be uniquely determined.\n        best_degree = 1\n    else:\n        # Not enough data to perform any meaningful fit. This case is not in the problem.\n        # We handle it for robustness, returning NaN.\n        return np.nan\n\n    # Perform the final fit on the full dataset with the selected model degree\n    final_coeffs = np.polyfit(x, E, best_degree)\n    \n    # The intercept (a0) is the last coefficient returned by np.polyfit.\n    # For a polynomial p(x) = c_d*x^d + ... + c_1*x + c_0, polyfit returns [c_d, ..., c_1, c_0].\n    E_infinity = final_coeffs[-1]\n    \n    return E_infinity\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "标准的绝热TDDFT方法在描述某些类型的激发态，特别是具有显著“双激发”特征的激发态时，存在固有的局限性。本实践通过一个巧妙的简化模型，让你直观地理解这一局限性的根源，并探索更高级的方法（如含频率依赖相互作用核的BSE方法）是如何克服这一难题的。通过对比不同理论模型的预测，你将深入洞察激发态理论的核心差异与演进。",
            "id": "3451119",
            "problem": "要求您实现一个最小化的自洽模型，通过对比计算材料科学中三种广泛使用的激发态方法，来捕捉和量化共轭分子光学响应中的双激发特征：实时含时密度泛函理论 (Real-Time Time-Dependent Density Functional Theory, RT-TDDFT)、线性响应含时密度泛函理论 (Linear-Response Time-Dependent Density Functional Theory, LR-TDDFT)，以及一种带有动态核的 Bethe-Salpeter 方程 (BSE) 方法。您的实现必须仅依赖于线性响应和因果性的第一性原理，并且必须在一个简化的标量模型中计算激发能和谱权重，该模型需与一个亮单激发通道和一个暗双激发通道耦合的物理过程相一致。\n\n从相互作用密度响应函数的线性响应 Dyson 方程出发，其中标量相互作用响应 $\\,\\chi(\\omega)\\,$ 通过以下公式与标量无相互作用响应 $\\,\\chi_{0}(\\omega)\\,$ 以及标量交换相关或电子-空穴相互作用核 $\\,f(\\omega)\\,$ 相关联：\n$$\n\\chi(\\omega) \\;=\\; \\frac{\\chi_{0}(\\omega)}{1 - f(\\omega)\\,\\chi_{0}(\\omega)} \\, .\n$$\n在 Tamm–Dancoff 近似 (TDA) 内，假设一个双能级亮跃迁，因此无相互作用响应的共振部分具有以下形式：\n$$\n\\chi_{0}^{\\mathrm{R}}(\\omega) \\;=\\; \\frac{S}{\\omega - \\Delta} \\, ,\n$$\n其中 $\\,\\Delta  0\\,$ 是单粒子带隙（单位为电子伏特），$\\,S  0\\,$ 是一个无量纲的振子强度比例因子。您将比较三种情况：\n\n- 绝热（频率无关）核的 LR-TDDFT，其中 $\\,f(\\omega) = f_{0}\\,$，$\\,f_{0}\\,$ 为常数，单位为电子伏特。物理极点是分母条件 $\\,1 - f_{0}\\,\\chi_{0}^{\\mathrm{R}}(\\omega) = 0\\,$ 的实数正解。\n- 具有相同绝热核的 RT-TDDFT。在线性区域，从含时偶极矩的傅里叶变换中提取的共振在绝热近似下与 LR-TDDFT 的共振相匹配。对于本问题，报告与 LR-TDDFT 相同的共振。\n- 一种动态的类 BSE 核，通过一个因果极点来模拟与能量为 $\\,\\Omega_{\\mathrm{d}}  0\\,$ 的暗双激发通道的耦合，\n$$\nf(\\omega) \\;=\\; f_{0} \\;+\\; \\frac{g^{2}}{\\omega - \\Omega_{\\mathrm{d}}} \\, ,\n$$\n耦合强度为 $\\,g  0\\,$，单位为电子伏特。物理极点是 $\\,1 - f(\\omega)\\,\\chi_{0}^{\\mathrm{R}}(\\omega) = 0\\,$ 的实数正解，通常成对出现。将这两个极点解释为亮单激发通道和暗双激发通道之间杂化的结果。\n\n从基本原理出发，使用以下物理上合理的步骤，不要为最终结果调用任何预先制定的公式：\n- 通过求解标量分母为零时的实数频率 $\\,\\omega\\,$ 来确定 $\\,\\chi(\\omega)\\,$ 的极点。\n- 证明动态核会产生两种杂化模式。将亮通道和暗通道视为一个耦合双能级问题，其本征频率是相互作用重整化后的极点。构建相应的归一化本征矢量。\n- 将高能模式的双激发特性量化为该模式所携带的偶极振子强度的分数。在耦合双能级描述中，外场仅与亮通道耦合，振幅与 $\\,\\sqrt{S}\\,$ 成正比。因此，如果一个本征矢量的亮通道分量为 $\\,x\\,$，暗通道分量为 $\\,y\\,$，且归一化条件为 $\\,x^{2} + y^{2} = 1\\,$，那么该模式携带的振子强度分数为 $\\,x^{2}\\,$，总振子强度守恒为 $\\,S\\,$。\n\n您的程序必须为下面定义的每个测试用例计算并返回以下量：\n- LR-TDDFT 激发能 $\\,\\omega_{\\mathrm{LR}}\\,$，单位为电子伏特。\n- RT-TDDFT 激发能 $\\,\\omega_{\\mathrm{RT}}\\,$，单位为电子伏特（在规定的假设下等于 $\\,\\omega_{\\mathrm{LR}}\\,$）。\n- 两个动态 BSE 杂化激发能 $\\,\\omega_{\\mathrm{dyn}}^{\\mathrm{low}}\\,$ 和 $\\,\\omega_{\\mathrm{dyn}}^{\\mathrm{high}}\\,$，单位为电子伏特，按 $\\,\\omega_{\\mathrm{dyn}}^{\\mathrm{low}} \\le \\omega_{\\mathrm{dyn}}^{\\mathrm{high}}\\,$ 排序。\n- 高能杂化模式的振子强度分数 $\\,w_{\\mathrm{high}}\\in[0,1]\\,$，定义为其归一化本征矢量的亮通道分量的平方，即 $\\,w_{\\mathrm{high}} = x_{\\mathrm{high}}^{2}\\,$。\n- 偏差 $\\,\\delta_{\\mathrm{LR,low}} = \\lvert \\omega_{\\mathrm{LR}} - \\omega_{\\mathrm{dyn}}^{\\mathrm{low}} \\rvert\\,$，单位为电子伏特。\n- 杂化模式分裂 $\\,\\Delta\\omega = \\omega_{\\mathrm{dyn}}^{\\mathrm{high}} - \\omega_{\\mathrm{dyn}}^{\\mathrm{low}}\\,$，单位为电子伏特。\n\n所有能量必须以电子伏特 (eV) 表示。所有振子强度分数必须以小数表示。所有报告的浮点数输出必须精确到六位小数。\n\n测试套件。对所有情况使用 $\\,S = 1.0\\,$。对于每个元组 $\\,(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}})\\,$, 计算上述输出：\n- 情况 A（理想路径，近共振中等耦合）：$\\,(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}}) = (2.0, 0.2, 0.4, 3.9)\\,$。\n- 情况 B（弱耦合，近共振）：$\\,(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}}) = (2.0, 0.1, 0.05, 4.0)\\,$。\n- 情况 C（较强耦合，蓝移双激发）：$\\,(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}}) = (2.0, 0.3, 0.6, 5.0)\\,$。\n- 情况 D（边界情况，无频率依赖）：$\\,(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}}) = (2.0, 0.2, 0.0, 4.0)\\,$。\n- 情况 E（负静态位移，蓝移双激发）：$\\,(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}}) = (3.0, -0.1, 0.3, 6.0)\\,$。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有情况的结果列表。该列表必须为每个测试用例包含一个子列表，顺序与上面列出的顺序相同。每个子列表必须包含元组 $\\,\\big[\\omega_{\\mathrm{LR}},\\,\\omega_{\\mathrm{RT}},\\,\\omega_{\\mathrm{dyn}}^{\\mathrm{low}},\\,\\omega_{\\mathrm{dyn}}^{\\mathrm{high}},\\,w_{\\mathrm{high}},\\,\\delta_{\\mathrm{LR,low}},\\,\\Delta\\omega\\big]\\,$。打印的格式必须是单行，由逗号分隔的列表包含在方括号内，且无空格，例如：\n[ [caseA_results],[caseB_results],... ]\n您的程序必须匹配这种确切的单行格式，不得有任何附加文本，并且所有数字都必须按指定顺序四舍五入到恰好六位小数。",
            "solution": "该问题要求为一个共轭分子中电子激发的简化标量模型计算激发能和谱权重。我们分析三种理论方法：线性响应含时密度泛函理论 (LR-TDDFT)、实时含时密度泛函理论 (RT-TDDFT) 以及一种带有动态相互作用核的类 Bethe-Salpeter 方程 (BSE) 模型。所有方法的出发点都是相互作用密度响应函数 $\\chi(\\omega)$ 的 Dyson 方程：\n$$\n\\chi(\\omega) = \\frac{\\chi_{0}(\\omega)}{1 - f(\\omega)\\,\\chi_{0}(\\omega)}\n$$\n物理激发能对应于 $\\chi(\\omega)$ 的极点，这些极点出现在分母为零的频率 $\\omega$ 处。在 Tamm-Dancoff 近似 (TDA) 内，给定的无相互作用响应函数为：\n$$\n\\chi_{0}^{\\mathrm{R}}(\\omega) = \\frac{S}{\\omega - \\Delta}\n$$\n这里，$\\Delta  0$ 是无相互作用的单粒子带隙，而 $S  0$ 是一个无量纲的振子强度因子。对于所有测试用例，$S=1.0$。\n\n### LR-TDDFT 和 RT-TDDFT 激发能\n\n对于 LR-TDDFT 和 RT-TDDFT，问题指定了一个绝热（频率无关）的相互作用核 $f(\\omega) = f_{0}$，其中 $f_{0}$ 是一个常数。物理激发能是极点条件的实数正解：\n$$\n1 - f_{0}\\,\\chi_{0}^{\\mathrm{R}}(\\omega) = 0\n$$\n代入 $\\chi_{0}^{\\mathrm{R}}(\\omega)$ 的表达式：\n$$\n1 - f_{0} \\frac{S}{\\omega - \\Delta} = 0\n$$\n重新整理各项以求解激发能 $\\omega$，我们将其表示为 $\\omega_{\\mathrm{LR}}$：\n$$\n\\omega - \\Delta = f_{0} S\n$$\n$$\n\\omega_{\\mathrm{LR}} = \\Delta + f_{0} S\n$$\n问题陈述，在线性响应区域，RT-TDDFT 计算得出相同的共振。因此，我们设定 $\\omega_{\\mathrm{RT}} = \\omega_{\\mathrm{LR}}$。此能量代表一个单一的亮激发，其能量相对于裸带隙 $\\Delta$ 的移动量为静态相互作用项 $f_0 S$。\n\n### 动态类 BSE 模型：杂化激发\n\n类 BSE 模型引入了一个频率依赖的核，该核解释了与能量为 $\\Omega_{\\mathrm{d}}$ 的暗双激发通道的耦合：\n$$\nf(\\omega) = f_{0} + \\frac{g^{2}}{\\omega - \\Omega_{\\mathrm{d}}}\n$$\n其中 $g$ 是耦合强度。极点 $\\omega$ 再次通过求解分母条件得到：\n$$\n1 - \\left( f_{0} + \\frac{g^{2}}{\\omega - \\Omega_{\\mathrm{d}}} \\right) \\frac{S}{\\omega - \\Delta} = 0\n$$\n为了揭示态混合的内在物理，我们遵循指示，将其视为一个耦合双能级问题。非耦合系统包含一个能量为静态移动后能量 $\\omega'_{\\mathrm{B}} = \\Delta + f_{0}S = \\omega_{\\mathrm{LR}}$ 的“亮”单激发态和一个能量为 $\\Omega_{\\mathrm{d}}$ 的“暗”双激发态。核的频率依赖部分在它们之间引入了耦合。该耦合系统的本征值对应于 $\\chi(\\omega)$ 的极点。\n这等价于求解一个 $2 \\times 2$ 有效哈密顿量的本征值：\n$$\nH_{\\mathrm{eff}} = \\begin{pmatrix} \\Delta + f_{0}S  \\sqrt{S}g \\\\ \\sqrt{S}g  \\Omega_{\\mathrm{d}} \\end{pmatrix}\n$$\n对角元素代表非耦合的亮（静态移动后）和暗态的能量，而非对角元素 $\\sqrt{S}g$ 代表它们的耦合。该矩阵的本征值 $\\omega$ 满足特征方程 $\\det(H_{\\mathrm{eff}} - \\omega I) = 0$：\n$$\n(\\Delta + f_{0}S - \\omega)(\\Omega_{\\mathrm{d}} - \\omega) - (\\sqrt{S}g)^2 = 0\n$$\n这是一个关于 $\\omega$ 的二次方程，其解给出了两个杂化激发能 $\\omega_{\\mathrm{dyn}}^{\\mathrm{low}}$ 和 $\\omega_{\\mathrm{dyn}}^{\\mathrm{high}}$。对于一个一般的 $2\\times2$ 实对称矩阵 $\\begin{pmatrix} a  b \\\\ b  d \\end{pmatrix}$，其本征值为 $\\lambda = \\frac{a+d \\pm \\sqrt{(a-d)^2 + 4b^2}}{2}$。将此公式应用于 $a = \\Delta + f_{0}S$，$d = \\Omega_{\\mathrm{d}}$ 和 $b = \\sqrt{S}g$，我们找到两个杂化能量：\n$$\n\\omega_{\\mathrm{dyn}} = \\frac{(\\Delta + f_{0}S) + \\Omega_{\\mathrm{d}} \\pm \\sqrt{((\\Delta + f_{0}S) - \\Omega_{\\mathrm{d}})^2 + 4Sg^2}}{2}\n$$\n我们将带有负号的解赋给 $\\omega_{\\mathrm{dyn}}^{\\mathrm{low}}$，带有正号的解赋给 $\\omega_{\\mathrm{dyn}}^{\\mathrm{high}}$。\n\n### 振子强度分数\n\n外场仅与亮通道耦合。$H_{\\mathrm{eff}}$ 的本征矢量描述了新的杂化态的特性。设对应于本征值 $\\omega_{\\mathrm{dyn}}^{\\mathrm{high}}$ 的本征矢量为 $v_{\\mathrm{high}} = \\begin{pmatrix} x_{\\mathrm{high}} \\\\ y_{\\mathrm{high}} \\end{pmatrix}$，其中 $x_{\\mathrm{high}}$ 是沿原始亮态的分量，$y_{\\mathrm{high}}$ 是沿暗态的分量，归一化条件为 $x_{\\mathrm{high}}^2 + y_{\\mathrm{high}}^2 = 1$。此高能模式的振子强度分数 $w_{\\mathrm{high}}$ 由其亮态分量的平方给出：$w_{\\mathrm{high}} = x_{\\mathrm{high}}^2$。\n\n为了求得 $x_{\\mathrm{high}}$，我们求解本征矢量方程 $(H_{\\mathrm{eff}} - \\omega_{\\mathrm{dyn}}^{\\mathrm{high}} I)v_{\\mathrm{high}} = 0$：\n$$\n\\begin{pmatrix} \\Delta + f_{0}S - \\omega_{\\mathrm{dyn}}^{\\mathrm{high}}  \\sqrt{S}g \\\\ \\sqrt{S}g  \\Omega_{\\mathrm{d}} - \\omega_{\\mathrm{dyn}}^{\\mathrm{high}} \\end{pmatrix} \\begin{pmatrix} x_{\\mathrm{high}} \\\\ y_{\\mathrm{high}} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n从第一行，我们得到 $(\\Delta + f_{0}S - \\omega_{\\mathrm{dyn}}^{\\mathrm{high}})x_{\\mathrm{high}} + \\sqrt{S}g y_{\\mathrm{high}} = 0$。\n一个未归一化的本征矢量可以写作 $\\tilde{v}_{\\mathrm{high}} = \\begin{pmatrix} \\sqrt{S}g \\\\ -(\\Delta + f_{0}S - \\omega_{\\mathrm{dyn}}^{\\mathrm{high}}) \\end{pmatrix}$。将此矢量归一化得到分量 $x_{\\mathrm{high}}$。分量的平方 $x_{\\mathrm{high}}^2$ 为：\n$$\nw_{\\mathrm{high}} = x_{\\mathrm{high}}^2 = \\frac{(\\sqrt{S}g)^2}{(\\sqrt{S}g)^2 + (-(\\Delta + f_{0}S - \\omega_{\\mathrm{dyn}}^{\\mathrm{high}}))^2} = \\frac{Sg^2}{Sg^2 + (\\omega_{\\mathrm{dyn}}^{\\mathrm{high}} - (\\Delta + f_{0}S))^2}\n$$\n\n### 最终计算量\n\n对于每个测试用例 $(\\Delta, f_{0}, g, \\Omega_{\\mathrm{d}})$，我们在 $S=1.0$ 的条件下计算以下七个值：\n1.  $\\omega_{\\mathrm{LR}} = \\Delta + f_{0}S$\n2.  $\\omega_{\\mathrm{RT}} = \\omega_{\\mathrm{LR}}$\n3.  $\\omega_{\\mathrm{dyn}}^{\\mathrm{low}} = \\frac{(\\Delta + f_{0}S) + \\Omega_{\\mathrm{d}} - \\sqrt{((\\Delta + f_{0}S) - \\Omega_{\\mathrm{d}})^2 + 4Sg^2}}{2}$\n4.  $\\omega_{\\mathrm{dyn}}^{\\mathrm{high}} = \\frac{(\\Delta + f_{0}S) + \\Omega_{\\mathrm{d}} + \\sqrt{((\\Delta + f_{0}S) - \\Omega_{\\mathrm{d}})^2 + 4Sg^2}}{2}$\n5.  $w_{\\mathrm{high}} = \\frac{Sg^2}{Sg^2 + (\\omega_{\\mathrm{dyn}}^{\\mathrm{high}} - (\\Delta + f_{0}S))^2}$\n6.  偏差 $\\delta_{\\mathrm{LR,low}} = |\\omega_{\\mathrm{LR}} - \\omega_{\\mathrm{dyn}}^{\\mathrm{low}}|$\n7.  杂化模式分裂 $\\Delta\\omega = \\omega_{\\mathrm{dyn}}^{\\mathrm{high}} - \\omega_{\\mathrm{dyn}}^{\\mathrm{low}}$，可简化为 $\\sqrt{((\\Delta + f_{0}S) - \\Omega_{\\mathrm{d}})^2 + 4Sg^2}$。\n\n所有结果均按要求计算并四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_excitation_properties(delta, f0, g, omega_d, S=1.0):\n    \"\"\"\n    Computes excitation energies and spectral weights for the three models.\n\n    Args:\n        delta (float): One-particle gap (eV).\n        f0 (float): Adiabatic kernel strength (eV).\n        g (float): Coupling strength to double-excitation channel (eV).\n        omega_d (float): Energy of the dark double-excitation channel (eV).\n        S (float): Dimensionless oscillator-strength scale factor.\n\n    Returns:\n        tuple: A tuple containing the seven required output quantities.\n    \"\"\"\n    # 1. LR-TDDFT and RT-TDDFT excitation energy\n    omega_lr = delta + f0 * S\n    omega_rt = omega_lr\n\n    # 2. Setup for the dynamical BSE-like model as a 2x2 eigenvalue problem\n    # H_eff = [[delta + S*f0, sqrt(S)*g], [sqrt(S)*g, omega_d]]\n    # Let a, d be diagonal elements and b be the off-diagonal element\n    a = delta + S * f0\n    d = omega_d\n    b = np.sqrt(S) * g\n\n    # 3. Eigenvalues of the effective Hamiltonian (hybrid energies)\n    # The eigenvalues are (a+d +/- sqrt((a-d)**2 + 4*b**2)) / 2\n    term_under_sqrt = (a - d)**2 + 4 * b**2\n    sqrt_term = np.sqrt(term_under_sqrt)\n    \n    omega_dyn_high = (a + d + sqrt_term) / 2.0\n    omega_dyn_low = (a + d - sqrt_term) / 2.0\n\n    # 4. Fractional oscillator strength of the higher-energy mode\n    # w_high = (b**2) / (b**2 + (omega_dyn_high - a)**2)\n    # This formula is well-behaved even for g=0 (where b=0).\n    numerator_w = b**2\n    denominator_w = b**2 + (omega_dyn_high - a)**2\n    # Avoid division by zero, although not expected with problem constraints\n    if denominator_w == 0:\n        # This occurs if b=0 and omega_dyn_high=a, meaning the states are\n        # uncoupled and degenerate. Not the case in the test suite.\n        # The bright state carries all strength.\n        w_high = 1.0 if d == a else 0.0\n    else:\n        w_high = numerator_w / denominator_w\n\n    # 5. Discrepancy and splitting\n    delta_lr_low = np.abs(omega_lr - omega_dyn_low)\n    delta_omega = omega_dyn_high - omega_dyn_low\n\n    return (omega_lr, omega_rt, omega_dyn_low, omega_dyn_high, w_high, delta_lr_low, delta_omega)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (Delta, f0, g, Omega_d)\n    test_cases = [\n        (2.0, 0.2, 0.4, 3.9),  # Case A\n        (2.0, 0.1, 0.05, 4.0), # Case B\n        (2.0, 0.3, 0.6, 5.0),  # Case C\n        (2.0, 0.2, 0.0, 4.0),  # Case D\n        (3.0, -0.1, 0.3, 6.0)  # Case E\n    ]\n    \n    # Constant oscillator strength scale factor\n    S = 1.0\n\n    all_results_formatted = []\n    \n    for case in test_cases:\n        delta_val, f0_val, g_val, omega_d_val = case\n        results = calculate_excitation_properties(delta_val, f0_val, g_val, omega_d_val, S)\n        \n        # Format the tuple of results into a list of strings with 6 decimal places\n        formatted_case_results = [f\"{val:.6f}\" for val in results]\n        # Join the strings into a sublist format \"[val1,val2,...]\"\n        all_results_formatted.append(f\"[{','.join(formatted_case_results)}]\")\n\n    # Final print statement in the exact required format.\n    # The outer list is joined by commas: \"[[...],[...],...]\"\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```"
        }
    ]
}