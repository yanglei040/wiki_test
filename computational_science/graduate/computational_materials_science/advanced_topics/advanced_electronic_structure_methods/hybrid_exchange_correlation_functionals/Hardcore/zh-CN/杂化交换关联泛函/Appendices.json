{
    "hands_on_practices": [
        {
            "introduction": "在应用或修改混杂泛函之前，理解其数学构造至关重要。本练习 () 将引导你从第一性原理出发，推导全局混杂泛函的完整能量表达式。通过分析每个能量项随体系尺寸和基组完备度的标度行为，你将对混杂 DFT 计算中固有的计算成本与精度权衡获得关键的洞见。",
            "id": "3457641",
            "problem": "考虑一个有限的、自旋受限的闭壳层体系，在原子单位制下，并用 Kohn–Sham 密度泛函理论 (DFT) 来描述。该体系具有占据空间轨道 $\\{\\phi_i\\}_{i=1}^{N_{\\mathrm{occ}}}$，每个轨道都被双占据，电子密度为 $\\rho(\\mathbf{r}) = 2 \\sum_{i=1}^{N_{\\mathrm{occ}}} |\\phi_i(\\mathbf{r})|^{2}$。总 Kohn–Sham 能量分解为无相互作用动能、外势能、经典电子-电子静电（Hartree）能以及交换相关能。全局杂化交换相关泛函将固定比例 $a \\in [0,1]$ 的 Hartree–Fock (HF) 交换与半局域交换混合，同时保留半局域相关。\n\n仅从这些核心定义以及 DFT 和 Hartree–Fock 理论中交换和相关的一般性质出发，完成以下任务：\n\n- 推导全局杂化泛函（混合比例为 $a$）总能量中每一项的显式轨道积分表达式，即无相互作用动能、外势能、Hartree 能、Hartree–Fock 交换能、半局域交换能和半局域相关能，所有表达式均用 $\\{\\phi_i\\}$ 和 $\\rho(\\mathbf{r})$ 写出。\n\n- 对于每一项，陈述其在一系列尺寸递增、电中性、闭壳层体系中随电子数 $N = 2 N_{\\mathrm{occ}}$ 的领头阶标度，以及在没有辅助近似（例如，没有密度拟合）的典型原子中心高斯基组中随基函数数量 $M$ 的领头阶计算功标度，并指出该项计算中的主要操作计数。\n\n- 定性评估基组的完备性（增加 $M$，或者对于平面波，增加截断能）如何影响每个能量项向其基组极限的收斂，并强调哪些项对基组完备性最敏感及其原因。\n\n你的最终答案必须是一个单一的闭合形式解析表达式，它组合所有项，给出混合比例为 $a$ 的全局杂化泛函的总能量，以 $\\{\\phi_i\\}$ 和 $\\rho(\\mathbf{r})$ 表示。不需要进行数值计算。如果引入任何缩写，请在首次使用时写出其全称。全文使用原子单位制。",
            "solution": "我们从自旋受限闭壳层体系的 Kohn–Sham 密度泛函理论 (DFT) 总能量的基本分解开始。Kohn–Sham 无相互作用动能源于单粒子轨道，外势能是密度与核势的相互作用，Hartree 能是密度的经典静电能，而交换相关能则解释了量子交换和相关效应。\n\n我们使用原子单位制，其中 $\\hbar = 1$，电子质量 $m_{e} = 1$，库仑常数为 1。对于一个具有占据空间轨道 $\\{\\phi_i\\}_{i=1}^{N_{\\mathrm{occ}}}$ 的自旋受限闭壳层体系，其电子密度为\n$$\n\\rho(\\mathbf{r}) = 2 \\sum_{i=1}^{N_{\\mathrm{occ}}} |\\phi_i(\\mathbf{r})|^{2}.\n$$\n\nKohn–Sham 无相互作用动能 $T_{s}$ 是双占据空间轨道的单粒子动能之和。在原子单位制下，对于每个空间轨道 $\\phi_i(\\mathbf{r})$，每个自旋通道的动能贡献为 $\\int \\frac{1}{2} |\\nabla \\phi_i(\\mathbf{r})|^{2} \\, d\\mathbf{r}$。由于轨道是双占据的，总的无相互作用动能可以紧凑地写为\n$$\nT_{s}[\\{\\phi_i\\}] = \\sum_{i=1}^{N_{\\mathrm{occ}}} \\int |\\nabla \\phi_i(\\mathbf{r})|^{2} \\, d\\mathbf{r}.\n$$\n这里使用了在原子单位制下每个轨道 $2 \\times \\frac{1}{2} = 1$ 的恒等式。\n\n外势能 $V_{\\mathrm{ext}}$ 为\n$$\nV_{\\mathrm{ext}}[\\rho] = \\int v_{\\mathrm{ext}}(\\mathbf{r}) \\, \\rho(\\mathbf{r}) \\, d\\mathbf{r},\n$$\n其中 $v_{\\mathrm{ext}}(\\mathbf{r})$ 是外（核）势。\n\n密度的 Hartree（经典库仑）能为\n$$\nE_{\\mathrm{H}}[\\rho] = \\frac{1}{2} \\iint \\frac{\\rho(\\mathbf{r}) \\, \\rho(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}'.\n$$\n\n对于自旋受限闭壳层体系，使用 Kohn–Sham 轨道计算的 Hartree–Fock (HF) 交换能，可以用占据空间轨道表示为\n$$\nE_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}] = - \\sum_{i=1}^{N_{\\mathrm{occ}}} \\sum_{j=1}^{N_{\\mathrm{occ}}} \\iint \\frac{\\phi_i(\\mathbf{r}) \\phi_j(\\mathbf{r}) \\phi_j(\\mathbf{r}') \\phi_i(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}',\n$$\n为简单起见，我们假设轨道是实函数；对于复轨道，每个 $\\phi$ 应在适当位置替换为其复共轭。\n\n半局域交换能 $E_{x}^{\\mathrm{sl}}[\\rho]$ 和半局域相关能 $E_{c}^{\\mathrm{sl}}[\\rho]$ 是密度（可能还有其梯度和其他简单的局域描述符）的泛函。在不指定具体形式（如局域密度近似 (LDA) 或广义梯度近似 (GGA)）的情况下，我们将其泛写为局域能量密度的空间积分：\n$$\nE_{x}^{\\mathrm{sl}}[\\rho] = \\int e_{x}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r},\n\\qquad\nE_{c}^{\\mathrm{sl}}[\\rho] = \\int e_{c}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r}.\n$$\n\n全局杂化交换相关泛函将固定比例 $a \\in [0,1]$ 的 Hartree–Fock 交换与半局域交换混合，并保留半局域相关。因此，全局杂化泛函中的交换相关能为\n$$\nE_{xc}^{\\mathrm{hyb}}[\\{\\phi_i\\},\\rho] = a \\, E_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}] + (1 - a) \\, E_{x}^{\\mathrm{sl}}[\\rho] + E_{c}^{\\mathrm{sl}}[\\rho].\n$$\n\n结合所有项，混合比例为 $a$ 的全局杂化泛函的总能量为\n$$\nE^{\\mathrm{hyb}}[\\{\\phi_i\\},\\rho] = T_{s}[\\{\\phi_i\\}] + V_{\\mathrm{ext}}[\\rho] + E_{\\mathrm{H}}[\\rho] + a \\, E_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}] + (1 - a) \\, E_{x}^{\\mathrm{sl}}[\\rho] + E_{c}^{\\mathrm{sl}}[\\rho].\n$$\n将上述显式形式代入，即可得到以 $\\{\\phi_i\\}$ 和 $\\rho(\\mathbf{r})$ 表示的最终闭合形式表达式。\n\n现在我们来讨论所要求的标度分析。\n\n在电中性、有限、闭壳层体系中随电子数 $N = 2 N_{\\mathrm{occ}}$ 的领头阶标度：\n- $T_{s}[\\{\\phi_i\\}]$: 在平均密度和化学组成固定的情况下，随着 $N$ 的增加，动能是广延的，其标度为 $\\mathcal{O}(N)$。\n- $V_{\\mathrm{ext}}[\\rho]$: 对于每个电子固定的核电荷分布，此项标度为 $\\mathcal{O}(N)$（广延）。\n- $E_{\\mathrm{H}}[\\rho]$: Hartree 项计算电子-电子对，其量级通常标度为 $\\mathcal{O}(N^{2})$。对于电中性的有限体系，总能量中的长程相消可能会在某些情况下降低净标度，但 Hartree 贡献本身是成对的，因此是 $\\mathcal{O}(N^{2})$。\n- $E_{x}^{\\mathrm{HF}}[\\{\\phi_i\\}]$: 交换也计算自旋相同电子对，对于相似结构体系的扩展增长，其量级标度为 $\\mathcal{O}(N^{2})$。\n- $E_{x}^{\\mathrm{sl}}[\\rho]$ 和 $E_{c}^{\\mathrm{sl}}[\\rho]$: 半局域泛函对局域能量密度进行积分，是广延的，标度为 $\\mathcal{O}(N)$。\n\n在典型的高斯原子轨道基组中，使用标准的四中心积分且无辅助近似时，随基函数数量 $M$ 的领头阶计算功标度：\n- 单电子项 $T_{s}$ 和 $V_{\\mathrm{ext}}$: 在能量计算中，构建单电子矩阵并将其与密度矩阵缩并的标度为 $\\mathcal{O}(M^{2})$（假设积分已预先计算或可廉价获得）。\n- $E_{\\mathrm{H}}$: 粗略地说，构建四中心双电子库仑积分的标度为 $\\mathcal{O}(M^{4})$，能量计算和类 Fock 缩并的标度也为 $\\mathcal{O}(M^{4})$；使用标准近似（此处未假设）可以降低此标度，但领头的粗略标度为 $\\mathcal{O}(M^{4})$。\n- $E_{x}^{\\mathrm{HF}}$: HF 交换能涉及同类的四中心双电子积分和缩并，因此其粗略标度为 $\\mathcal{O}(M^{4})$。\n- 半局域的 $E_{x}^{\\mathrm{sl}}$ 和 $E_{c}^{\\mathrm{sl}}$: 在数值求积格点上进行计算时，主要成本是获取格点上的 $\\rho(\\mathbf{r})$ 和 $\\nabla \\rho(\\mathbf{r})$ 并执行格点积分。如果格点大小与 $M$ 成正比，则典型的缩并成本介于 $\\mathcal{O}(M^{2})$（密度矩阵到格点）和 $\\mathcal{O}(M \\, N_{g})$ 之间，具体取决于实现方式；泛函本身的计算标度为 $\\mathcal{O}(N_{g})$。在解析原子轨道方法中（对于 GGA 较不常见），标度可保持在 $\\mathcal{O}(M^{2})$ 附近。\n\n基组完备性与收敛行为：\n- $T_{s}$ 和 $V_{\\mathrm{ext}}$ 取决于单粒子轨道及其光滑度。在具有系统可改进序列的原子中心高斯基组中，由于轨道得到了很好的表示，能量收敛迅速（对于束缚态，随着基数增加，通常接近指数收敛）。在平面波基组中，收敛由动能截斷控制；光滑的轨道使这些项相对较快地收敛。\n- $E_{\\mathrm{H}}$ 取决于 $\\rho(\\mathbf{r})$，对轨道中细微的高频分量相对不敏感；在密度精确的情况下，随着基组的改进或格点的细化，它会稳步收敛。在平面波中，求解泊松方程可以实现随截断能的快速可控收敛。\n- $E_{x}^{\\mathrm{HF}}$ 是非局域的，取决于两点处占据轨道的乘积 $\\phi_i(\\mathbf{r}) \\phi_j(\\mathbf{r}')$ 除以 $|\\mathbf{r}-\\mathbf{r}'|$。要准确表示这些轨道乘积，需要底层轨道乘积空间具有更高的完备性。因此，$E_{x}^{\\mathrm{HF}}$ 随基组大小的收敛速度通常比半局域项慢，并且对角度和径向分量（对于高斯基组）的完备性或高截断能（对于平面波）敏感，这反映了其长程、非局域的特性。\n- 半局域的 $E_{x}^{\\mathrm{sl}}$ 和 $E_{c}^{\\mathrm{sl}}$ 取决于 $\\rho(\\mathbf{r})$（可能还有 $\\nabla \\rho(\\mathbf{r})$）。因为密度是轨道平方和，所以它比单个轨道更光滑，这些项随基组改进的收敛速度通常比 $E_{x}^{\\mathrm{HF}}$ 更快。在平面波表示中，梯度由截断能很好地控制并系统地收敛。\n\n最后，将混合比例为 $a$ 的全局杂化泛函总能量的显式轨道积分形式组合起来，就得到了所要求的解析表达式。",
            "answer": "$$\\boxed{\\sum_{i=1}^{N_{\\mathrm{occ}}} \\int |\\nabla \\phi_i(\\mathbf{r})|^{2} \\, d\\mathbf{r} \\;+\\; \\int v_{\\mathrm{ext}}(\\mathbf{r}) \\, \\rho(\\mathbf{r}) \\, d\\mathbf{r} \\;+\\; \\frac{1}{2} \\iint \\frac{\\rho(\\mathbf{r}) \\, \\rho(\\mathbf{r}')}{|\\mathbf{r} - \\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}' \\;+\\; a \\left( - \\sum_{i=1}^{N_{\\mathrm{occ}}} \\sum_{j=1}^{N_{\\mathrm{occ}}} \\iint \\frac{\\phi_i(\\mathbf{r})\\phi_j(\\mathbf{r})\\phi_j(\\mathbf{r}')\\phi_i(\\mathbf{r}')}{|\\mathbf{r}-\\mathbf{r}'|} \\, d\\mathbf{r} \\, d\\mathbf{r}' \\right) \\;+\\; (1 - a) \\int e_{x}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r} \\;+\\; \\int e_{c}^{\\mathrm{sl}}\\!\\left(\\rho(\\mathbf{r}), \\nabla \\rho(\\mathbf{r})\\right) \\, d\\mathbf{r}}$$"
        },
        {
            "introduction": "使用混杂泛函的一个关键动机是修正简单近似中存在的自相互作用误差，该误差表现为能量随分数电子数的变化偏离了精确的逐片线性关系。本练习 () 将介绍一种强大的方法，通过最小化这种非物理的能量曲率来“优化调节”混杂参数 $\\alpha$。通过这个练习，你将学习如何施加一个基本的物理约束，以构建一个更具预测性的、针对特定材料的泛函。",
            "id": "3457625",
            "problem": "考虑在电子结构计算中使用的一类全局混合交换相关泛函，其中，对于具有分数电子数的电子系统，其总能量在整数参考点附近被建模为前线轨道分数占据数的二次展开。令 $N$ 为电子数，$N_0$ 为整数电子数，并定义分数占据数 $f = N - N_0$，其中 $f \\in [0,1]$。假设能量分解与广泛使用的密度泛函理论（DFT）实践一致：总能量可以表示为 Kohn-Sham 动能、外势能、Hartree 能量和交换相关能量之和。对于全局混合泛函，交换部分是半局域近似和精确（Hartree-Fock）交换的线性混合，混合分数为 $\\alpha \\in [0,1]$。\n\n利用一个公认的事实：对于精确的 DFT，总能量 $E(N)$ 在整数 $N_0$ 和 $N_0+1$ 之间是分段线性的，而近似泛函与分段线性行为的偏差可以通过曲率 $C = \\partial^2 E/\\partial N^2$ 来量化。在一种具有物理基础的分段线性分析替代模型中，将一小部分（$f$）电子添加到材料 $m$ 的单个前线轨道所引起的能量变化建模为\n$$\nE_m(N;\\alpha) \\approx E_{\\mathrm{ref},m} + \\varepsilon_m f + \\tfrac{1}{2} U_m \\left[1 - \\alpha \\sigma_m - (1 - \\alpha)\\kappa_m\\right] f^2,\n$$\n其中 $E_{\\mathrm{ref},m}$ 是一个恒定的参考能量，$\\varepsilon_m$ 是在 $N_0$ 处的前线 Kohn-Sham 本征值，$U_m$（单位为 eV）量化了前线轨道的有效 Hartree 自相互作用标度，$\\kappa_m \\in [0,1]$ 量化了半局域交换所提供的自相互作用抵消的分数，而 $\\sigma_m \\in [0,1]$ 量化了固体中精确交换所提供的有效抵消（考虑了可能的屏蔽效应）。参数 $U_m$、$\\kappa_m$ 和 $\\sigma_m$ 取决于材料。\n\n您的任务是，对每种材料，使用中心有限差分近似在 $f=0.5$ 附近计算作为 $\\alpha$ 函数的曲率 $C_m(\\alpha) = \\partial^2 E_m/\\partial N^2$。也就是说，使用一个小的步长 $h$ 并计算\n$$\nC_m(\\alpha) \\approx \\frac{E_m(N_0 + f + h;\\alpha) - 2 E_m(N_0 + f;\\alpha) + E_m(N_0 + f - h;\\alpha)}{h^2}\n$$\n其中 $f = 0.5$ 且 $h = 10^{-4}$。请以电子伏特（eV）为单位表示 $C_m(\\alpha)$。对于给定的材料集，将偏离分段线性的聚合偏差定义为所有材料曲率的均方根（RMS），\n$$\n\\mathrm{RMS}(\\alpha) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} \\left[C_m(\\alpha)\\right]^2},\n$$\n并选择唯一的 $\\alpha \\in [0,1]$，以最小化该集合的 $\\mathrm{RMS}(\\alpha)$。\n\n实现一个程序，对于每个提供的测试用例，计算并返回在 $\\alpha \\in [0,1]$ 约束下最小化 $\\mathrm{RMS}(\\alpha)$ 的最优 $\\alpha$。该程序必须通过上述中心有限差分公式计算 $C_m(\\alpha)$。为了数值稳定性，如果经过严格推导，您也可以使用模型中得出的任何等价代数简化形式。\n\n测试套件：\n- 测试用例1（典型的半导体和一种边缘情况）：\n  - 材料1：$U_1 = 5.0$ eV, $\\kappa_1 = 0.3$, $\\sigma_1 = 0.8$。\n  - 材料2：$U_2 = 2.5$ eV, $\\kappa_2 = 0.2$, $\\sigma_2 = 0.6$。\n  - 材料3：$U_3 = 7.0$ eV, $\\kappa_3 = 0.7$, $\\sigma_3 = 0.95$。\n  - 材料4：$U_4 = 3.0$ eV, $\\kappa_4 = 0.5$, $\\sigma_4 = 0.5$。\n- 测试用例2（强半局域抵消主导精确交换）：\n  - 材料1：$U_1 = 4.0$ eV, $\\kappa_1 = 0.9$, $\\sigma_1 = 0.2$。\n  - 材料2：$U_2 = 6.0$ eV, $\\kappa_2 = 0.85$, $\\sigma_2 = 0.4$。\n  - 材料3：$U_3 = 5.0$ eV, $\\kappa_3 = 0.8$, $\\sigma_3 = 0.3$。\n  - 材料4：$U_4 = 2.0$ eV, $\\kappa_4 = 0.8$, $\\sigma_4 = 0.8$。\n- 测试用例3（混合屏蔽机制）：\n  - 材料1：$U_1 = 3.0$ eV, $\\kappa_1 = 0.2$, $\\sigma_1 = 0.7$。\n  - 材料2：$U_2 = 5.0$ eV, $\\kappa_2 = 0.85$, $\\sigma_2 = 0.4$。\n  - 材料3：$U_3 = 2.5$ eV, $\\kappa_3 = 0.5$, $\\sigma_3 = 0.9$。\n  - 材料4：$U_4 = 1.5$ eV, $\\kappa_4 = 0.6$, $\\sigma_4 = 0.3$。\n\n约束和说明：\n- 使用 $f = 0.5$ 和 $h = 10^{-4}$ 进行曲率估计。\n- 将 $E_{\\mathrm{ref},m}$ 和 $\\varepsilon_m$ 视为不影响曲率的常数，在计算曲率时，可以不失一般性地将其设置为零。\n- 混合参数 $\\alpha$ 必须被约束在区间 $[0,1]$ 内。\n- 曲率的单位是电子伏特（eV）；然而，最终输出是无量纲的 $\\alpha$ 值。\n- 您的程序应生成一行输出，其中包含每个测试用例的最优 $\\alpha$，格式为方括号内以逗号分隔的列表。将每个 $\\alpha$ 表示为小数点后保留六位的小数浮点数。例如：“[0.250000,0.500000,0.750000]”。",
            "solution": "所提供的问题被判定为有效。它在科学上基于密度泛函理论（DFT）的原理，作为一个优化问题被恰当地提出，并为其解决提供了完整且一致的信息集。\n\n我们的目标是找到混合参数 $\\alpha \\in [0,1]$，以最小化给定材料集的均方根（RMS）曲率 $\\mathrm{RMS}(\\alpha)$。均方根曲率定义为：\n$$\n\\mathrm{RMS}(\\alpha) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} \\left[C_m(\\alpha)\\right]^2}\n$$\n其中 $M$ 是材料的数量，$C_m(\\alpha)$ 是材料 $m$ 的能量曲率。\n\n第一步是获得曲率 $C_m(\\alpha) = \\partial^2 E_m/\\partial N^2$ 的一个易于处理的表达式。问题提供了材料 $m$ 的能量模型，作为分数占据数 $f = N - N_0$ 的函数：\n$$\nE_m(N;\\alpha) \\approx E_{\\mathrm{ref},m} + \\varepsilon_m f + \\tfrac{1}{2} U_m \\left[1 - \\alpha \\sigma_m - (1 - \\alpha)\\kappa_m\\right] f^2\n$$\n由于 $f = N - N_0$，关于 $N$ 的偏导数等价于关于 $f$ 的偏导数，即 $\\partial/\\partial N = \\partial/\\partial f$。$E_{\\mathrm{ref},m}$ 和 $\\varepsilon_m f$ 项分别是关于 $f$ 的常数项和线性项，因此在求二阶导数时会消失。我们可以通过直接解析微分求得曲率 $C_m(\\alpha)$：\n$$\n\\frac{\\partial E_m}{\\partial f} = \\varepsilon_m + U_m \\left[1 - \\alpha \\sigma_m - (1 - \\alpha)\\kappa_m\\right] f\n$$\n$$\nC_m(\\alpha) = \\frac{\\partial^2 E_m}{\\partial f^2} = U_m \\left[1 - \\alpha \\sigma_m - (1 - \\alpha)\\kappa_m\\right]\n$$\n这个解析结果表明，曲率 $C_m(\\alpha)$ 相对于分数占据数 $f$ 是一个常数。\n\n问题陈述要求使用步长为 $h$ 的中心有限差分公式：\n$$\nC_m(\\alpha) \\approx \\frac{E_m(f+h) - 2E_m(f) + E_m(f-h)}{h^2}\n$$\n对于形如 $g(f) = a f^2 + b f + c$ 的一般二次函数，此有限差分公式是精确的：\n\\begin{align*}\n\\frac{g(f+h) - 2g(f) + g(f-h)}{h^2} = \\frac{[a(f+h)^2 + b(f+h) + c] - 2[af^2+bf+c] + [a(f-h)^2 + b(f-h) + c]}{h^2} \\\\\n= \\frac{a(f^2+2fh+h^2) - 2af^2 + a(f^2-2fh+h^2) + b(f+h) - 2bf + b(f-h)}{h^2} \\\\\n= \\frac{a(2h^2) + b(0)}{h^2} = 2a\n\\end{align*}\n这恰好是解析二阶导数 $\\partial^2 g / \\partial f^2 = 2a$。由于我们的能量模型 $E_m(f; \\alpha)$ 是关于 $f$ 的二次函数，数值近似会得到精确的解析结果，该结果与 $f$ 和 $h$ 的值无关。因此，我们可以按许可使用解析推导出的 $C_m(\\alpha)$ 表达式。\n\n为简化 $C_m(\\alpha)$ 的表达式，我们可以将其重排为 $\\alpha$ 的线性函数：\n$$\nC_m(\\alpha) = U_m [1 - \\kappa_m - \\alpha \\sigma_m + \\alpha \\kappa_m] = U_m (1 - \\kappa_m) + \\alpha U_m (\\kappa_m - \\sigma_m)\n$$\n我们定义 $A_m = U_m(1-\\kappa_m)$ 和 $B_m = U_m(\\kappa_m - \\sigma_m)$。那么，曲率可以简化为 $C_m(\\alpha) = A_m + \\alpha B_m$。\n\n下一步是最小化 $\\mathrm{RMS}(\\alpha)$。最小化 $\\mathrm{RMS}(\\alpha)$ 等价于最小化它的平方，我们将其表示为 $J(\\alpha)$：\n$$\nJ(\\alpha) = [\\mathrm{RMS}(\\alpha)]^2 = \\frac{1}{M}\\sum_{m=1}^{M} \\left[C_m(\\alpha)\\right]^2 = \\frac{1}{M}\\sum_{m=1}^{M} (A_m + \\alpha B_m)^2\n$$\n$J(\\alpha)$ 是 $\\alpha$ 的二次函数。为了找到最小化 $J(\\alpha)$ 的 $\\alpha$ 值，我们对 $\\alpha$ 求导并令其为零：\n$$\n\\frac{dJ}{d\\alpha} = \\frac{1}{M} \\sum_{m=1}^{M} 2(A_m + \\alpha B_m) \\cdot B_m = 0\n$$\n假设 $M>0$，我们可以简化为：\n$$\n\\sum_{m=1}^{M} (A_m B_m + \\alpha B_m^2) = 0 \\implies \\left(\\sum_{m=1}^{M} A_m B_m\\right) + \\alpha \\left(\\sum_{m=1}^{M} B_m^2\\right) = 0\n$$\n求解 $\\alpha$ 得到无约束的最小值 $\\alpha_{\\text{unconstrained}}$：\n$$\n\\alpha_{\\text{unconstrained}} = - \\frac{\\sum_{m=1}^{M} A_m B_m}{\\sum_{m=1}^{M} B_m^2}\n$$\n二阶导数 $\\frac{d^2J}{d\\alpha^2} = \\frac{2}{M}\\sum B_m^2 \\ge 0$ 确认了这是一个最小值。代入 $A_m$ 和 $B_m$ 的定义：\n$$\n\\alpha_{\\text{unconstrained}} = - \\frac{\\sum_{m=1}^{M} U_m(1-\\kappa_m) \\cdot U_m(\\kappa_m - \\sigma_m)}{\\sum_{m=1}^{M} [U_m(\\kappa_m - \\sigma_m)]^2} = \\frac{\\sum_{m=1}^{M} U_m^2(1-\\kappa_m)(\\sigma_m - \\kappa_m)}{\\sum_{m=1}^{M} U_m^2(\\sigma_m - \\kappa_m)^2}\n$$\n只要分母不为零，该公式就是良定义的，除非对于所有材料 $m$ 都有 $\\kappa_m = \\sigma_m$。如果分母为零，则对于所有 $m$，$C_m$ 都将与 $\\alpha$ 无关，使得 $J(\\alpha)$ 成为一个常数，此时任何 $\\alpha$ 都是有效解。\n\n最后，我们必须施加 $\\alpha \\in [0,1]$ 的物理约束。由于 $J(\\alpha)$ 是一个开口向上的抛物线，其在区间 $[0,1]$ 上的最小值可以通过将无约束解“裁剪”到此范围来找到：\n- 如果 $\\alpha_{\\text{unconstrained}}  0$，区间上的最小值在 $\\alpha = 0$ 处。\n- 如果 $\\alpha_{\\text{unconstrained}} > 1$，区间上的最小值在 $\\alpha = 1$ 处。\n- 如果 $0 \\le \\alpha_{\\text{unconstrained}} \\le 1$，最小值在 $\\alpha = \\alpha_{\\text{unconstrained}}$ 处。\n\n因此，最优混合参数为 $\\alpha^* = \\text{clip}(\\alpha_{\\text{unconstrained}}, 0, 1)$。实现部分将为每个测试用例计算此值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal exchange mixing parameter alpha for a series of test cases.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each test case is a list of materials, where each material is a tuple (U, kappa, sigma).\n    test_cases = [\n        # Test case 1 (typical semiconductors and an edge component)\n        [\n            (5.0, 0.3, 0.8),\n            (2.5, 0.2, 0.6),\n            (7.0, 0.7, 0.95),\n            (3.0, 0.5, 0.5)\n        ],\n        # Test case 2 (strong semilocal cancellation dominating exact exchange)\n        [\n            (4.0, 0.9, 0.2),\n            (6.0, 0.85, 0.4),\n            (5.0, 0.8, 0.3),\n            (2.0, 0.8, 0.8)\n        ],\n        # Test case 3 (mixed screening regime)\n        [\n            (3.0, 0.2, 0.7),\n            (5.0, 0.85, 0.4),\n            (2.5, 0.5, 0.9),\n            (1.5, 0.6, 0.3)\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        # The optimal unconstrained alpha is given by the formula:\n        # alpha_unconstrained = sum(U_m^2 * (1-kappa_m) * (sigma_m - kappa_m)) / sum(U_m^2 * (sigma_m - kappa_m)^2)\n        \n        numerator_sum = 0.0\n        denominator_sum = 0.0\n        \n        for material_params in case:\n            U, kappa, sigma = material_params\n            \n            U2 = U**2\n            one_minus_kappa = 1.0 - kappa\n            sigma_minus_kappa = sigma - kappa\n            \n            numerator_sum += U2 * one_minus_kappa * sigma_minus_kappa\n            denominator_sum += U2 * sigma_minus_kappa**2\n\n        if denominator_sum == 0:\n            # This edge case occurs if kappa_m = sigma_m for all materials.\n            # In this scenario, the curvature is independent of alpha, so the RMS\n            # is constant. Any alpha in [0, 1] is a minimizer.\n            # We conventionally choose alpha = 0.0, although any value in [0,1] is correct.\n            alpha_unconstrained = 0.0\n        else:\n            alpha_unconstrained = numerator_sum / denominator_sum\n            \n        # The final solution must be constrained to the interval [0, 1].\n        # Since the objective function is a parabola, the minimum on the interval\n        # is found by clipping the unconstrained minimum.\n        optimal_alpha = np.clip(alpha_unconstrained, 0.0, 1.0)\n        \n        results.append(optimal_alpha)\n\n    # Format the results into the required string format: \"[val1,val2,val3]\"\n    # Each value is a float rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "精确交换项的高昂计算成本是限制混杂泛函应用于大体系的主要瓶颈。本练习 () 将直面这一挑战，探索一种基于电子物质“近视性”原理的线性标度算法。你将实现一个利用空间截断和密度矩阵截断来提升效率的模型，并量化计算精度与速度之间的基本权衡关系。",
            "id": "3457635",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用定域化轨道和密度矩阵截断，为杂化交换相关泛函中的哈特里-福克 (HF) 精确交换能建立一个线性标度算法模型并进行评估。目标是通过将稠密参考评估与基于屏蔽和邻居列表的线性标度算法进行比较，来形式化大型多孔框架中稀疏性与误差之间的权衡。您的解决方案必须基于第一性原理，并从哈特里-福克理论中交换的标准定义以及电子物质的短视性原理出发。\n\n从以下基本定义和经过充分检验的事实出发：\n- 哈特里-福克 (HF) 交换能可以在一个正交归一化的定域基中写为\n$$\nE_x^{\\text{HF}} \\;=\\; -\\frac{1}{2}\\sum_{\\mu,\\nu,\\lambda,\\sigma} P_{\\mu\\lambda}\\,P_{\\nu\\sigma}\\,(\\mu\\nu|\\lambda\\sigma),\n$$\n其中 $P$ 是单粒子密度矩阵，$(\\mu\\nu|\\lambda\\sigma)$ 是基于库仑核的双电子排斥积分。\n- 在具有定域化轨道的绝缘固体中，密度矩阵元素 $P_{ij}$ 随着轨道中心间距离 $r_{ij}$ 呈指数衰减，这是电子物质短视性原理的一种体现。\n- 在大型多孔框架中，这种衰减导致密度矩阵和屏蔽库仑相互作用中出现稀疏性，从而通过定域性和截断实现线性标度算法。\n\n为了使计算完全自洽且易于处理，同时仍能检验线性标度的原理，请考虑以下模型交换泛函，它能在不需计算完整四中心积分的情况下，捕捉到交换的正确定性局域性：\n$$\nE_x^{\\text{model}} \\;=\\; -\\frac{1}{2}\\sum_{i,j} \\left(P_{ij}\\right)^2\\,K(r_{ij}),\n$$\n其中\n$$\nP_{ij} \\;=\\;\n\\begin{cases}\n1,  i=j,\\\\\n\\exp\\!\\left(-\\left(\\frac{r_{ij}}{\\xi}\\right)^2\\right),  i\\neq j,\n\\end{cases}\n\\quad\\text{and}\\quad\nK(r) \\;=\\; \\dfrac{\\exp\\!\\left(-\\left(\\dfrac{r}{\\lambda}\\right)^2\\right)}{\\sqrt{r^2 + r_0^2}}.\n$$\n这里，$r_{ij}$ 是中心 $i$ 和 $j$ 之间的欧几里得距离，$\\xi$ 是密度矩阵衰减长度，$\\lambda$ 是相互作用屏蔽长度，$r_0$ 是一个短程正则化子，当 $r=0$ 时产生有限的自交换。\n\n您必须完成以下任务：\n1. 构建三维原子框架，将其视为简单立方晶格上的点，晶格间距 $a=1$（无量纲单位），晶格大小为 $n\\times n\\times n$。通过在立方体的几何中心挖出一个半径为 $R_p$ 的球形孔隙来引入孔隙度；仅保留那些与中心的距离大于或等于 $R_p$ 的格点。当 $R_p=0$ 时，这简化为完整的稠密立方体。\n2. 对于每个框架，通过评估所有对 $(i,j)$ 的完整双重求和，不进行截断，来计算 $E_x^{\\text{model}}$ 的稠密参考值。\n3. 实现一个使用对空间截断和密度矩阵截断的线性标度算法：\n   - 使用一个由均匀单元格网格（单元格尺寸等于距离截断半径 $R_c$）构建的邻居列表，将位点 $i$ 的候选邻居 $j$ 限制在距离 $R_c$ 之内的那些位点。\n   - 对任何满足 $| P_{ij} |  \\tau$ 的对 $(i,j)$ 应用密度矩阵截断，其中 $\\tau$ 是一个非负阈值。\n   - 累加稀疏近似能量\n   $$\n   E_x^{\\text{sparse}} \\;=\\; -\\frac{1}{2}\\sum_{(i,j)\\,\\text{kept}} \\left(P_{ij}\\right)^2\\,K(r_{ij}),\n   $$\n   其中求和仅对在上述截断下保留的对进行。您必须计算保留的有序对 $(i,j)$ 的数量（当截断允许时包括 $i=j$），以量化稀疏性。\n4. 对每种情况，报告相对误差\n$$\n\\varepsilon \\;=\\; \\dfrac{\\lvert E_x^{\\text{sparse}} - E_x^{\\text{ref}} \\rvert}{\\lvert E_x^{\\text{ref}} \\rvert}\n$$\n和保留对分数\n$$\ns \\;=\\; \\dfrac{N_{\\text{kept}}}{N^2},\n$$\n其中 $N$ 是经过孔隙度筛选后的位点数，$N_{\\text{kept}}$ 是稀疏算法实际评估并保留的有序对的数量。稠密参考值 $E_x^{\\text{ref}}$ 是在没有任何截断的情况下计算的值。\n\n定义模型的参数，且必须统一用于所有测试：\n- 密度矩阵衰减长度 $\\xi = 1.5$。\n- 屏蔽长度 $\\lambda = 1.0$。\n- 短程正则化子 $r_0 = 0.5$。\n- 晶格间距 $a = 1$。\n\n角度单位不适用。不存在物理单位；所有量均为无量纲。将所有输出报告为浮点数。\n\n测试套件：\n在以下六种情况下运行您的程序，每种情况由 $(n, R_p, R_c, \\tau)$ 指定：\n- 情况 1：$(5, 0.0, 2.0, 10^{-4})$。\n- 情况 2：$(5, 0.0, 3.0, 10^{-6})$。\n- 情况 3：$(5, 0.0, 1.0, 10^{-2})$。\n- 情况 4：$(5, 2.0, 2.0, 10^{-4})$。\n- 情况 5（边界条件）：$(5, 2.0, 0.0, 0.0)$。\n- 情况 6（近稠密稀疏评估）：$(5, 0.0, 10.0, 0.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来。对于上述顺序中的每种情况，将两个数字 $[\\varepsilon, s]$ 附加到输出列表中，因此最后一行包含 12 个浮点数，顺序为 $[\\varepsilon_1, s_1, \\varepsilon_2, s_2, \\ldots, \\varepsilon_6, s_6]$。每个浮点数至少打印 6 位小数。不得打印任何其他文本。",
            "solution": "该问题要求设计并实现一个算法，用于评估一个模型交换泛函，并比较稠密的精确计算与稀疏的线性标度近似计算。其科学背景是计算杂化交换相关泛函中的哈特里-福克 (HF) 交换能，这是现代计算材料科学和量子化学的基石。线性标度方法的有效性和效率基于“电子物质的短视性原理”，该原理指出，对于具有非零电子带隙的系统，位于位置 $i$ 和 $j$ 的两个定域化轨道之间的单粒子密度矩阵元素 $P_{ij}$ 会随着它们之间的距离 $r_{ij}$ 呈指数衰减。这一物理原理是该模型和算法的基础。\n\n问题从 HF 交换能在正交归一化定域轨道基 $\\{\\phi_{\\mu}\\}$ 中的形式化表达式开始：\n$$\nE_x^{\\text{HF}} = -\\frac{1}{2}\\sum_{\\mu,\\nu,\\lambda,\\sigma} P_{\\mu\\lambda}\\,P_{\\nu\\sigma}\\,(\\mu\\nu|\\lambda\\sigma)\n$$\n其中 $P$ 是密度矩阵，$P_{\\mu\\lambda} = \\sum_{k}^{\\text{occ}} c_{\\mu k} c_{\\lambda k}^*$，而 $(\\mu\\nu|\\lambda\\sigma)$ 是四中心双电子排斥积分，$(\\mu\\nu|\\lambda\\sigma) = \\iint \\phi_{\\mu}^*(\\mathbf{r}_1) \\phi_{\\nu}(\\mathbf{r}_1) \\frac{1}{|\\mathbf{r}_1 - \\mathbf{r}_2|} \\phi_{\\lambda}^*(\\mathbf{r}_2) \\phi_{\\sigma}(\\mathbf{r}_2) d\\mathbf{r}_1 d\\mathbf{r}_2$。朴素地评估此求和的计算成本按 $O(N^4)$ 比例缩放，这对于大型系统而言是望而却步的。\n\n为了创建一个易于处理且具有物理意义的模型，问题引入了一个简化的交换泛函，它捕捉了局域性的基本特征。四中心项被替换为双中心屏蔽相互作用，求和被简化为对原子位点 $i$ 和 $j$ 进行：\n$$\nE_x^{\\text{model}} = -\\frac{1}{2}\\sum_{i,j} \\left(P_{ij}\\right)^2\\,K(r_{ij})\n$$\n该模型的组成部分被定义为模仿物理现实。位点 $i$ 和 $j$ 之间相隔欧几里得距离 $r_{ij}$ 的密度矩阵元素 $P_{ij}$ 被建模为高斯衰减，这与短视性原理一致：\n$$\nP_{ij} =\n\\begin{cases}\n1,  i=j\\\\\n\\exp\\!\\left(-\\left(\\frac{r_{ij}}{\\xi}\\right)^2\\right),  i\\neq j\n\\end{cases}\n$$\n这里，$\\xi=1.5$ 是特征衰减长度。相互作用核 $K(r)$ 代表一种屏蔽库仑相互作用，它也随距离衰减：\n$$\nK(r) = \\dfrac{\\exp\\!\\left(-\\left(\\dfrac{r}{\\lambda}\\right)^2\\right)}{\\sqrt{r^2 + r_0^2}}\n$$\n其中 $\\lambda=1.0$ 是屏蔽长度，$r_0=0.5$ 是一个正则化子，用于防止在 $r=0$ 时发散，从而产生有限的自交换能。\n\n结构模型由简单立方晶格上的点组成，晶格间距 $a=1$。通过从 $n\\times n\\times n$ 立方体的几何中心移除半径为 $R_p$ 的球内的所有格点来引入孔隙度。对于整数坐标从 $0$ 到 $n-1$ 的立方体，其几何中心位于 $(\\frac{n-1}{2}, \\frac{n-1}{2}, \\frac{n-1}{2})$。\n\n任务的核心是比较计算 $E_x^{\\text{model}}$ 的两种方法：\n\n1.  **稠密参考计算**：参考能量 $E_x^{\\text{ref}}$ 是通过对框架中所有 $N^2$ 个有序位点对 $(i,j)$ 进行完全双重求和来计算的。这为模型泛函提供了精确值，但其计算复杂度为 $O(N^2)$，无法扩展到非常大的系统。\n\n2.  **稀疏线性标度算法**：近似能量 $E_x^{\\text{sparse}}$ 是通过系统地截断求和来计算的。短视性原理意味着相距很远的位点对 $(i,j)$ 对总能量的贡献可以忽略不计，因为 $P_{ij}$ 和 $K(r_{ij})$ 都随 $r_{ij}$ 迅速衰减。稀疏算法利用这一点，定义了两个截断标准：一个空间距离截断半径 $R_c$ 和一个密度矩阵元素阈值 $\\tau$。一对 $(i,j)$ 仅当**同时**满足 $r_{ij} \\le R_c$ 和 $|P_{ij}| \\ge \\tau$ 时，才对求和有贡献。\n    为了高效实现并达到线性 $O(N)$ 标度，采用了基于均匀单元格网格的邻居列表算法。模拟域被划分为边长为 $R_c$ 的立方单元格。每个位点都被分配到一个单元格中。要查找位点 $i$ 的邻居，只需在包含位点 $i$ 的单元格及其 26 个相邻单元格中搜索位点 $j$。这将需要检查的对数从每个位点的 $O(N)$ 数量急剧减少到 $O(1)$，从而使得构建保留对列表的总复杂度为 $O(N)$。\n\n稀疏算法的性能由两个指标量化：\n-   **相对误差 ($\\varepsilon$)**：衡量近似的准确性。\n    $$\n    \\varepsilon = \\dfrac{\\lvert E_x^{\\text{sparse}} - E_x^{\\text{ref}} \\rvert}{\\lvert E_x^{\\text{ref}} \\rvert}\n    $$\n-   **保留对分数 ($s$)**：衡量计算节省或稀疏性。\n    $$\n    s = \\dfrac{N_{\\text{kept}}}{N^2}\n    $$\n    其中 $N$ 是位点数，$N_{\\text{kept}}$ 是通过截断标准保留下来的有序对的数量。\n\n所实现的程序遵循这些原则。它首先为给定情况生成原子坐标。然后，它通过对所有对的嵌套循环计算 $E_x^{\\text{ref}}$。随后，它实现单元格列表算法来计算 $E_x^{\\text{sparse}}$ 和 $N_{\\text{kept}}$。对于距离截断半径 $R_c=0$ 的特殊情况，只考虑在位点上的项（$i=j$），这被明确处理。最后，它计算 $\\varepsilon$ 和 $s$，并按规定格式化所有测试用例的结果。这种系统性比较展示了计算科学中线性标度方法固有的计算成本与准确性之间的基本权衡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # Uniform parameters from the problem statement\n    XI = 1.5\n    LAMBDA = 1.0\n    R0 = 0.5\n    A = 1.0\n\n    def P_ij(r, xi):\n        \"\"\"\n        Calculates the model density matrix element P_ij.\n        \"\"\"\n        if np.isclose(r, 0.0):\n            return 1.0\n        return np.exp(-(r / xi)**2)\n\n    def K_r(r, lambda_, r0):\n        \"\"\"\n        Calculates the model interaction kernel K(r).\n        \"\"\"\n        return np.exp(-(r / lambda_)**2) / np.sqrt(r**2 + r0**2)\n\n    def generate_framework(n, Rp, a):\n        \"\"\"\n        Generates the 3D atomic framework on a simple cubic lattice with a spherical pore.\n        \"\"\"\n        center = np.array([(n - 1) / 2.0, (n - 1) / 2.0, (n - 1) / 2.0]) * a\n        \n        coords = np.array([\n            [i * a, j * a, k * a] \n            for i in range(n) for j in range(n) for k in range(n)\n        ])\n        \n        if Rp > 0:\n            distances_to_center = np.linalg.norm(coords - center, axis=1)\n            sites = coords[distances_to_center >= Rp]\n        else:\n            sites = coords\n            \n        return sites\n\n    def calculate_dense_energy(sites, xi, lambda_, r0):\n        \"\"\"\n        Calculates the dense reference energy E_ref by summing over all pairs.\n        \"\"\"\n        N = sites.shape[0]\n        if N == 0:\n            return 0.0\n        \n        total_energy_term = 0.0\n        for i in range(N):\n            for j in range(N):\n                r_ij = np.linalg.norm(sites[i] - sites[j])\n                p_val = P_ij(r_ij, xi)\n                k_val = K_r(r_ij, lambda_, r0)\n                total_energy_term += p_val**2 * k_val\n                \n        return -0.5 * total_energy_term\n\n    def calculate_sparse_energy(sites, Rc, tau, xi, lambda_, r0):\n        \"\"\"\n        Calculates the sparse energy E_sparse and counts kept pairs using a cell-list algorithm.\n        \"\"\"\n        N = sites.shape[0]\n        if N == 0:\n            return 0.0, 0\n        \n        sparse_energy_term = 0.0\n        N_kept = 0\n\n        # Handle the special case where Rc = 0; only i=j pairs are considered.\n        if np.isclose(Rc, 0.0):\n            for i in range(N):\n                p_val_ii = 1.0  # P_ii is always 1\n                if p_val_ii >= tau:\n                    k_val_0 = K_r(0.0, lambda_, r0)\n                    sparse_energy_term += p_val_ii**2 * k_val_0\n                    N_kept += 1\n            return -0.5 * sparse_energy_term, N_kept\n        \n        # General case with cell list for Rc > 0\n        min_coord = np.min(sites, axis=0) if N > 0 else np.array([0,0,0])\n        grid = {}\n        for i, site in enumerate(sites):\n            cell_coord = tuple(np.floor((site - min_coord) / Rc).astype(int))\n            if cell_coord not in grid:\n                grid[cell_coord] = []\n            grid[cell_coord].append(i)\n\n        for i in range(N):\n            site_i = sites[i]\n            cell_i_coord_tuple = tuple(np.floor((site_i - min_coord) / Rc).astype(int))\n            \n            # Iterate over the 27 neighboring cells (including the cell itself)\n            for d in itertools.product([-1, 0, 1], repeat=3):\n                neighbor_cell_coord = (\n                    cell_i_coord_tuple[0] + d[0],\n                    cell_i_coord_tuple[1] + d[1],\n                    cell_i_coord_tuple[2] + d[2]\n                )\n                \n                if neighbor_cell_coord in grid:\n                    for j in grid[neighbor_cell_coord]:\n                        site_j = sites[j]\n                        r_ij = np.linalg.norm(site_i - site_j)\n                        \n                        # First cutoff: distance\n                        if r_ij > Rc:\n                            continue\n                        \n                        p_val = P_ij(r_ij, xi)\n                        \n                        # Second cutoff: density matrix value\n                        if abs(p_val)  tau:\n                            continue\n                            \n                        # Pair is kept\n                        N_kept += 1\n                        k_val = K_r(r_ij, lambda_, r0)\n                        sparse_energy_term += p_val**2 * k_val\n\n        return -0.5 * sparse_energy_term, N_kept\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (n, Rp, Rc, tau)\n        (5, 0.0, 2.0, 1e-4),\n        (5, 0.0, 3.0, 1e-6),\n        (5, 0.0, 1.0, 1e-2),\n        (5, 2.0, 2.0, 1e-4),\n        (5, 2.0, 0.0, 0.0),\n        (5, 0.0, 10.0, 0.0),\n    ]\n\n    results = []\n    for n, Rp, Rc, tau in test_cases:\n        sites = generate_framework(n, Rp, A)\n        N = sites.shape[0]\n        \n        if N == 0:\n            # If no sites, energies are 0. Error is 0, sparsity is ill-defined.\n            # We set s=0 as no pairs are kept from a set of 0 total pairs.\n            eps = 0.0\n            s = 0.0\n        else:\n            E_ref = calculate_dense_energy(sites, XI, LAMBDA, R0)\n            E_sparse, N_kept = calculate_sparse_energy(sites, Rc, tau, XI, LAMBDA, R0)\n            \n            if np.isclose(E_ref, 0.0):\n                # This should only happen if N=0, but as a safeguard:\n                # If E_ref is 0 and E_sparse is also 0, error is 0. Otherwise, it's infinite.\n                eps = 0.0 if np.isclose(E_sparse, 0.0) else np.inf\n            else:\n                eps = np.abs((E_sparse - E_ref) / E_ref)\n                \n            s = N_kept / (N**2)\n        \n        results.extend([eps, s])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6e}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}