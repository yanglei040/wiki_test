{
    "hands_on_practices": [
        {
            "introduction": "A fundamental requirement for any physically realistic interatomic potential is that forces must be rotationally covariant; that is, if the atomic system undergoes a rigid rotation, the force vectors acting on the atoms must rotate by the same amount. This hands-on exercise demonstrates why a naive neural network that directly processes Cartesian coordinates fails to uphold this principle. By building a non-equivariant model and explicitly calculating the covariance error for a rotated configuration, you will gain a tangible appreciation for the necessity of building symmetry directly into the network architecture .",
            "id": "3449440",
            "problem": "Consider a setting in computational materials science where interatomic forces are predicted by a learned energy model. In a physically valid model, the forces must satisfy rotational covariance: if a configuration is rotated by an angle $\\theta$ about a unit axis $\\hat{\\mathbf{a}}$, then the force vectors must rotate by the same rigid-body rotation. A learned energy that maps raw Cartesian coordinates directly to a scalar energy without constructing rotationally invariant features can be non-equivariant and produce forces that violate rotational covariance, even when the underlying physics would require it. The goal is to construct a minimal, explicit counterexample and quantify the covariance error under specified test rotations.\n\nStart from the following fundamental base:\n- Rotational symmetry in classical mechanics: a scalar energy $E$ describing an isolated system with no external fields must be invariant under a rigid rotation; forces defined by $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$ must transform as covariant vectors under rotation.\n- Chain rule of multivariable calculus: if $\\mathbf{y} = \\mathbf{R}\\mathbf{x}$ with $\\mathbf{R}$ an orthogonal rotation matrix in the special orthogonal group in three dimensions, then gradients transform in a way determined by the Jacobian.\n\nDefine a non-equivariant Artificial Neural Network (ANN) energy model that depends directly on raw Cartesian coordinates. For a system of $N$ atoms with positions $\\mathbf{r}_i \\in \\mathbb{R}^3$, stack the coordinates into a single vector $\\mathbf{x} \\in \\mathbb{R}^{3N}$ by concatenation. Let the energy be defined by\n$$\nE(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\tanh\\!\\big( \\mathbf{w}_h^\\top \\mathbf{x} + b_h \\big) + c,\n$$\nwhere $H$ is the number of hidden units, $\\mathbf{w}_h \\in \\mathbb{R}^{3N}$ are the rows of a weight matrix $W_1 \\in \\mathbb{R}^{H \\times 3N}$, $b_h \\in \\mathbb{R}$ are biases, $\\alpha_h \\in \\mathbb{R}$ are output weights, and $c \\in \\mathbb{R}$ is a scalar offset. This ANN is deliberately constructed to be non-equivariant: it uses anisotropic weights on raw Cartesian coordinates without any symmetry-preserving architecture.\n\nForces are defined as the negative gradient of the energy with respect to the stacked coordinates:\n$$\n\\mathbf{F}(\\mathbf{x}) = -\\nabla_{\\mathbf{x}} E(\\mathbf{x}) \\in \\mathbb{R}^{3N}.\n$$\nWhen a configuration is rotated by angle $\\theta$ about axis $\\hat{\\mathbf{a}}$, let $\\mathbf{R}(\\theta,\\hat{\\mathbf{a}}) \\in \\mathbb{R}^{3 \\times 3}$ be the corresponding rotation matrix. The rotated configuration is $\\mathbf{x}_{\\mathrm{rot}} = (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{x}$, where $\\mathrm{I}_N$ is the $N \\times N$ identity matrix and $\\otimes$ denotes the Kronecker product. A rotationally covariant model should satisfy\n$$\n\\mathbf{F}_{\\mathrm{cov}}(\\mathbf{x}_{\\mathrm{rot}}) = (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}),\n$$\nbut the non-equivariant ANN generally will not.\n\nQuantify the rotational covariance violation by the relative error\n$$\n\\varepsilon(\\theta,\\hat{\\mathbf{a}}) = \\frac{\\left\\| (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}) - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}}) \\right\\|_2}{\\max\\!\\big(\\left\\| (\\mathrm{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})) \\mathbf{F}(\\mathbf{x}) \\right\\|_2, \\epsilon\\big)},\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm and $\\epsilon$ is a small positive constant to avoid division by zero. All quantities are dimensionless for this exercise.\n\nUse the following explicit, fixed molecular configuration with $N=3$ atoms:\n$$\n\\mathbf{r}_1 = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\end{bmatrix},\\quad\n\\mathbf{r}_2 = \\begin{bmatrix}1.2\\\\0.5\\\\-0.3\\end{bmatrix},\\quad\n\\mathbf{r}_3 = \\begin{bmatrix}-0.8\\\\-1.0\\\\0.7\\end{bmatrix}.\n$$\nStack these into $\\mathbf{x} \\in \\mathbb{R}^{9}$ by concatenation in the order $\\mathbf{r}_1$, $\\mathbf{r}_2$, $\\mathbf{r}_3$.\n\nUse the following ANN parameters with $H=3$ and $3N=9$:\n$$\nW_1 = \\begin{bmatrix}\n0.8 & -0.4 & 0.2 & 0.1 & 0.6 & -0.3 & -0.5 & 0.7 & -0.2 \\\\\n-0.3 & 0.9 & -0.6 & 0.4 & -0.1 & 0.5 & 0.2 & -0.8 & 0.3 \\\\\n0.5 & 0.2 & 0.7 & -0.9 & 0.3 & -0.4 & 0.6 & -0.1 & 0.8\n\\end{bmatrix},\\quad\n\\mathbf{b}_1=\\begin{bmatrix}0.1\\\\-0.2\\\\0.05\\end{bmatrix},\\quad\n\\boldsymbol{\\alpha}=\\begin{bmatrix}1.2\\\\-0.7\\\\0.9\\end{bmatrix},\\quad\nc=0.1.\n$$\n\nImplement $\\mathbf{R}(\\theta,\\hat{\\mathbf{a}})$ via the Rodrigues rotation formula using a unit axis $\\hat{\\mathbf{a}}$ and angle $\\theta$ (in radians).\n\nTest Suite:\nCompute $\\varepsilon(\\theta,\\hat{\\mathbf{a}})$ for the following five cases, which collectively probe the happy path, boundary conditions, and general axes:\n- Case $1$: $\\theta = 0$, $\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$.\n- Case $2$: $\\theta = \\pi/6$, $\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$.\n- Case $3$: $\\theta = \\pi/2$, $\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$.\n- Case $4$: $\\theta = \\pi$, $\\hat{\\mathbf{a}} = \\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$.\n- Case $5$: $\\theta = \\pi/3$, $\\hat{\\mathbf{a}} = \\dfrac{1}{\\sqrt{3}}\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}$.\n\nAnswer specification and output format:\n- For each test case, return a single floating-point number equal to $\\varepsilon(\\theta,\\hat{\\mathbf{a}})$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $\\big[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5\\big]$.\n- Angles must be interpreted in radians. No physical units are used; all quantities are dimensionless.",
            "solution": "The problem requires the computation of a rotational covariance error for a non-equivariant neural network potential. The solution proceeds by first deriving the analytical expression for the interatomic forces from the given energy model, then implementing the rotation operations, and finally calculating the specified error metric for a set of test cases.\n\n### Step 1: System and Model Definition\n\nThe system consists of $N=3$ atoms with initial Cartesian coordinates $\\mathbf{r}_i \\in \\mathbb{R}^3$:\n$$\n\\mathbf{r}_1 = \\begin{bmatrix}0.0\\\\0.0\\\\0.0\\end{bmatrix},\\quad\n\\mathbf{r}_2 = \\begin{bmatrix}1.2\\\\0.5\\\\-0.3\\end{bmatrix},\\quad\n\\mathbf{r}_3 = \\begin{bmatrix}-0.8\\\\-1.0\\\\0.7\\end{bmatrix}\n$$\nThese are concatenated into a single state vector $\\mathbf{x} \\in \\mathbb{R}^{3N} = \\mathbb{R}^9$:\n$$\n\\mathbf{x} = \\begin{bmatrix} \\mathbf{r}_1 \\\\ \\mathbf{r}_2 \\\\ \\mathbf{r}_3 \\end{bmatrix} = \\begin{bmatrix} 0.0, 0.0, 0.0, 1.2, 0.5, -0.3, -0.8, -1.0, 0.7 \\end{bmatrix}^\\top\n$$\nThe energy $E(\\mathbf{x})$ is defined by a single-hidden-layer Artificial Neural Network (ANN) with $H=3$ hidden units:\n$$\nE(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\tanh\\!\\big( \\mathbf{w}_h^\\top \\mathbf{x} + b_h \\big) + c\n$$\nHere, $\\mathbf{w}_h^\\top$ represents the $h$-th row of the weight matrix $W_1 \\in \\mathbb{R}^{H \\times 3N}$. The given parameters are:\n$$\nW_1 = \\begin{bmatrix}\n0.8 & -0.4 & 0.2 & 0.1 & 0.6 & -0.3 & -0.5 & 0.7 & -0.2 \\\\\n-0.3 & 0.9 & -0.6 & 0.4 & -0.1 & 0.5 & 0.2 & -0.8 & 0.3 \\\\\n0.5 & 0.2 & 0.7 & -0.9 & 0.3 & -0.4 & 0.6 & -0.1 & 0.8\n\\end{bmatrix},\\quad\n\\mathbf{b}_1=\\begin{bmatrix}0.1\\\\-0.2\\\\0.05\\end{bmatrix},\\quad\n\\boldsymbol{\\alpha}=\\begin{bmatrix}1.2\\\\-0.7\\\\0.9\\end{bmatrix},\\quad\nc=0.1\n$$\n\n### Step 2: Derivation of the Force Vector\n\nThe force vector $\\mathbf{F}(\\mathbf{x}) \\in \\mathbb{R}^{3N}$ is the negative gradient of the scalar energy $E(\\mathbf{x})$ with respect to the coordinates $\\mathbf{x}$:\n$$\n\\mathbf{F}(\\mathbf{x}) = -\\nabla_{\\mathbf{x}} E(\\mathbf{x})\n$$\nWe compute the gradient using the chain rule. Let the pre-activation for the $h$-th hidden unit be $u_h(\\mathbf{x}) = \\mathbf{w}_h^\\top \\mathbf{x} + b_h$. The gradient of the energy is:\n$$\n\\nabla_{\\mathbf{x}} E(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\left( \\sum_{h=1}^{H} \\alpha_h \\tanh(u_h(\\mathbf{x})) + c \\right) = \\sum_{h=1}^{H} \\alpha_h \\nabla_{\\mathbf{x}} (\\tanh(u_h(\\mathbf{x})))\n$$\nApplying the chain rule to each term:\n$$\n\\nabla_{\\mathbf{x}} (\\tanh(u_h(\\mathbf{x}))) = \\frac{d}{du_h}(\\tanh(u_h)) \\cdot \\nabla_{\\mathbf{x}} u_h\n$$\nThe derivative of $\\tanh$ is $\\text{sech}^2(u_h)$, which can be expressed as $1 - \\tanh^2(u_h)$. The gradient of $u_h$ is $\\nabla_{\\mathbf{x}} (\\mathbf{w}_h^\\top \\mathbf{x} + b_h) = \\mathbf{w}_h$. Substituting these back gives:\n$$\n\\nabla_{\\mathbf{x}} E(\\mathbf{x}) = \\sum_{h=1}^{H} \\alpha_h \\left( 1 - \\tanh^2(\\mathbf{w}_h^\\top \\mathbf{x} + b_h) \\right) \\mathbf{w}_h\n$$\nTherefore, the force vector is:\n$$\n\\mathbf{F}(\\mathbf{x}) = - \\sum_{h=1}^{H} \\alpha_h \\left( 1 - \\tanh^2(\\mathbf{w}_h^\\top \\mathbf{x} + b_h) \\right) \\mathbf{w}_h\n$$\nIn matrix notation, this is more compactly written as:\n$$\n\\mathbf{F}(\\mathbf{x}) = -W_1^\\top \\big( \\boldsymbol{\\alpha} \\odot \\text{sech}^2(W_1 \\mathbf{x} + \\mathbf{b}_1) \\big)\n$$\nwhere $\\odot$ denotes the element-wise (Hadamard) product. This expression provides a direct method for computing the force vector for any given configuration $\\mathbf{x}$.\n\n### Step 3: Rotation Operator\n\nA rotation in $\\mathbb{R}^3$ by an angle $\\theta$ around a unit axis $\\hat{\\mathbf{a}}$ is represented by a $3 \\times 3$ matrix $\\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$, constructed using Rodrigues' rotation formula:\n$$\n\\mathbf{R}(\\theta, \\hat{\\mathbf{a}}) = \\mathbf{I}_3 + \\sin(\\theta)\\mathbf{K} + (1 - \\cos(\\theta))\\mathbf{K}^2\n$$\nwhere $\\mathbf{I}_3$ is the $3 \\times 3$ identity matrix and $\\mathbf{K}$ is the cross-product matrix of $\\hat{\\mathbf{a}} = [a_x, a_y, a_z]^\\top$:\n$$\n\\mathbf{K} = \\begin{bmatrix} 0 & -a_z & a_y \\\\ a_z & 0 & -a_x \\\\ -a_y & a_x & 0 \\end{bmatrix}\n$$\nTo rotate the entire $N$-atom system, we apply this rotation to each atom's coordinate vector. This is achieved using a block-diagonal matrix formed by the Kronecker product:\n$$\n\\mathbf{R}_{\\text{block}} = \\mathbf{I}_N \\otimes \\mathbf{R}(\\theta,\\hat{\\mathbf{a}})\n$$\nFor $N=3$, this results in a $9 \\times 9$ matrix.\n\n### Step 4: Formulation of the Covariance Error\n\nThe core of the problem is to quantify the violation of rotational covariance. The rotated configuration is $\\mathbf{x}_{\\mathrm{rot}} = \\mathbf{R}_{\\text{block}} \\mathbf{x}$. The force calculated on this new configuration is $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$.\n\nFor a truly covariant model, the force vectors would rotate rigidly with the system. The correctly transformed force vector, denoted $\\mathbf{F}_{\\mathrm{cov}}$, is obtained by applying the same rotation to the original force vector:\n$$\n\\mathbf{F}_{\\mathrm{cov}} = \\mathbf{R}_{\\text{block}} \\mathbf{F}(\\mathbf{x})\n$$\nThe rotational covariance error, $\\varepsilon$, is the relative difference between the force computed on the rotated system, $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$, and the rotated original force, $\\mathbf{F}_{\\mathrm{cov}}$:\n$$\n\\varepsilon(\\theta,\\hat{\\mathbf{a}}) = \\frac{\\left\\| \\mathbf{F}_{\\mathrm{cov}} - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}}) \\right\\|_2}{\\max\\!\\big(\\left\\| \\mathbf{F}_{\\mathrm{cov}} \\right\\|_2, \\epsilon\\big)}\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm and $\\epsilon$ is a small positive constant (e.g., $10^{-9}$) to prevent division by zero or by a near-zero number.\n\n### Step 5: Computational Algorithm\n\nFor each test case $(\\theta, \\hat{\\mathbf{a}})$:\n1.  Compute the original force vector $\\mathbf{F}(\\mathbf{x})$ using the analytical formula derived in Step 2.\n2.  Construct the $3 \\times 3$ rotation matrix $\\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$ using Rodrigues' formula.\n3.  Construct the $9 \\times 9$ block rotation matrix $\\mathbf{R}_{\\text{block}} = \\mathbf{I}_3 \\otimes \\mathbf{R}(\\theta, \\hat{\\mathbf{a}})$.\n4.  Calculate the correctly transformed force vector: $\\mathbf{F}_{\\mathrm{cov}} = \\mathbf{R}_{\\text{block}} \\mathbf{F}(\\mathbf{x})$.\n5.  Calculate the rotated coordinate vector: $\\mathbf{x}_{\\mathrm{rot}} = \\mathbf{R}_{\\text{block}} \\mathbf{x}$.\n6.  Calculate the force vector on the rotated configuration: $\\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})$.\n7.  Compute the L2 norm of the difference: $\\|\\mathbf{F}_{\\mathrm{cov}} - \\mathbf{F}(\\mathbf{x}_{\\mathrm{rot}})\\|_2$.\n8.  Compute the L2 norm of the reference force: $\\|\\mathbf{F}_{\\mathrm{cov}}\\|_2$.\n9.  Calculate the final error $\\varepsilon$ using the formula from Step 4.\n\nThis procedure will be implemented for the five specified test cases. The case $\\theta=0$ serves as a sanity check, as it corresponds to an identity rotation and must yield an error of $0$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the rotational covariance error for a non-equivariant ANN potential.\n    \"\"\"\n    \n    # --- Step 1: Define Givens (System and Model Parameters) ---\n    N = 3\n    \n    r1 = np.array([0.0, 0.0, 0.0])\n    r2 = np.array([1.2, 0.5, -0.3])\n    r3 = np.array([-0.8, -1.0, 0.7])\n    x = np.concatenate((r1, r2, r3))\n\n    W1 = np.array([\n        [0.8, -0.4, 0.2, 0.1, 0.6, -0.3, -0.5, 0.7, -0.2],\n        [-0.3, 0.9, -0.6, 0.4, -0.1, 0.5, 0.2, -0.8, 0.3],\n        [0.5, 0.2, 0.7, -0.9, 0.3, -0.4, 0.6, -0.1, 0.8]\n    ])\n\n    b1 = np.array([0.1, -0.2, 0.05])\n    alpha = np.array([1.2, -0.7, 0.9])\n    \n    # Small constant for denominator stabilization, as per the problem statement\n    epsilon_small = 1e-9\n\n    # --- Step 2: Define Helper Functions ---\n    \n    def calculate_force(pos_vec):\n        \"\"\"\n        Calculates the force F(x) = -nabla_x E(x) based on the derived formula.\n        \"\"\"\n        # u = W1 @ x + b1\n        u = W1 @ pos_vec + b1\n        \n        # sech^2(u) = 1 - tanh^2(u)\n        tanh_u = np.tanh(u)\n        sech_sq_u = 1.0 - tanh_u**2\n        \n        # v = alpha .* sech^2(u)\n        v = alpha * sech_sq_u\n        \n        # gradient = W1^T @ v\n        gradient = W1.T @ v\n        \n        force = -gradient\n        return force\n\n    def rodrigues_rotation(theta, axis):\n        \"\"\"\n        Computes the 3x3 rotation matrix R(theta, a_hat) via Rodrigues' formula.\n        \"\"\"\n        # Ensure the axis is a unit vector\n        axis = axis / np.linalg.norm(axis)\n        ax, ay, az = axis\n        \n        K = np.array([\n            [0, -az, ay],\n            [az, 0, -ax],\n            [-ay, ax, 0]\n        ])\n        \n        I = np.eye(3)\n        R = I + np.sin(theta) * K + (1 - np.cos(theta)) * (K @ K)\n        return R\n\n    # --- Step 3: Define Test Suite ---\n    test_cases = [\n        # Case 1: theta = 0, a_hat = [0, 0, 1]\n        (0.0, np.array([0.0, 0.0, 1.0])),\n        # Case 2: theta = pi/6, a_hat = [0, 0, 1]\n        (np.pi / 6, np.array([0.0, 0.0, 1.0])),\n        # Case 3: theta = pi/2, a_hat = [0, 0, 1]\n        (np.pi / 2, np.array([0.0, 0.0, 1.0])),\n        # Case 4: theta = pi, a_hat = [0, 0, 1]\n        (np.pi, np.array([0.0, 0.0, 1.0])),\n        # Case 5: theta = pi/3, a_hat = [1, 1, 1] / sqrt(3)\n        (np.pi / 3, np.array([1.0, 1.0, 1.0]) / np.sqrt(3))\n    ]\n\n    results = []\n\n    # --- Step 4: Execute Test Cases and Calculate Error ---\n    for theta, a_hat in test_cases:\n        # Calculate force on the original configuration\n        F_x = calculate_force(x)\n\n        # Construct the rotation matrices\n        R_3x3 = rodrigues_rotation(theta, a_hat)\n        R_block = np.kron(np.eye(N), R_3x3)\n\n        # Calculate the covariantly transformed force\n        F_cov = R_block @ F_x\n\n        # Calculate the rotated configuration\n        x_rot = R_block @ x\n\n        # Calculate the force on the rotated configuration\n        F_x_rot = calculate_force(x_rot)\n\n        # Calculate the error numerator and denominator\n        numerator = np.linalg.norm(F_cov - F_x_rot)\n        denominator = np.linalg.norm(F_cov)\n        \n        # Calculate the relative error\n        error = numerator / max(denominator, epsilon_small)\n        results.append(error)\n        \n    # --- Step 5: Format and Print Final Answer ---\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established the need for equivariance, we now turn to the mathematical machinery that makes it possible. Equivariant features are constructed using basis functions that transform in a predictable way under rotations, namely the spherical harmonics $Y_{\\ell m}$, whose transformation is described by the Wigner $D$-matrices. This practice allows you to numerically verify this fundamental transformation law for a rank-1 vector feature, bridging the gap between the abstract theory of group representations and its concrete application in building equivariant models .",
            "id": "3449495",
            "problem": "You are asked to verify, by direct numerical computation, the equivariant transformation of a rank-$1$ (vector) feature constructed from complex spherical harmonics under a rigid rotation. Work in the Special Orthogonal group in three dimensions (SO(3)), using the $Z\\text{-}Y\\text{-}Z$ Euler-angle convention.\n\nDefinitions and fundamental base:\n- Let $\\hat{\\mathbf{r}} = (x,y,z)/\\|\\,(x,y,z)\\,\\|$ be a unit direction in $\\mathbb{R}^3$. Define the spherical angles $\\theta \\in [0,\\pi]$ and $\\phi \\in [0,2\\pi)$ by $\\theta = \\arccos(z)$ and $\\phi = \\operatorname{atan2}(y,x)$.\n- Let $Y_{\\ell m}(\\theta,\\phi)$ be the complex spherical harmonics with the Condon–Shortley phase and the physics convention (magnetic quantum number $m$ as the first argument), where $\\ell \\in \\mathbb{N}_0$ and $m \\in \\{-\\ell,\\ldots,\\ell\\}$.\n- For a finite set of neighbor directions $\\{\\hat{\\mathbf{r}}_i\\}_{i=1}^{N}$ with real weights $\\{w_i\\}_{i=1}^{N}$, define the $\\ell=1$ feature vector with components\n$$\nF_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i,\\phi_i),\n\\quad m \\in \\{1,0,-1\\},\n$$\nwhere $(\\theta_i,\\phi_i)$ are the spherical angles of $\\hat{\\mathbf{r}}_i$.\n- Let a rotation $R \\in \\mathrm{SO}(3)$ be parameterized by $Z\\text{-}Y\\text{-}Z$ Euler angles $(\\alpha,\\beta,\\gamma)$ in radians. The associated Wigner $D$-matrix in the $\\ell=1$ irreducible representation, $D^{(1)}(R)\\in \\mathbb{C}^{3\\times 3}$ with rows and columns ordered by $m=1,0,-1$, is\n$$\nD^{(1)}_{m m'}(\\alpha,\\beta,\\gamma) \\;=\\; e^{-i m \\alpha}\\, d^{(1)}_{m m'}(\\beta)\\, e^{-i m' \\gamma},\n$$\nwhere the Wigner small-$d$ elements for $\\ell=1$ are\n$$\n\\begin{aligned}\nd^{(1)}_{1,1}(\\beta) &= \\tfrac{1+\\cos\\beta}{2}, \\quad &\nd^{(1)}_{1,0}(\\beta) &= -\\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad &\nd^{(1)}_{1,-1}(\\beta) &= \\tfrac{1-\\cos\\beta}{2}, \\\\\nd^{(1)}_{0,1}(\\beta) &= \\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad &\nd^{(1)}_{0,0}(\\beta) &= \\cos\\beta, \\quad &\nd^{(1)}_{0,-1}(\\beta) &= -\\tfrac{\\sin\\beta}{\\sqrt{2}}, \\\\\nd^{(1)}_{-1,1}(\\beta) &= \\tfrac{1-\\cos\\beta}{2}, \\quad &\nd^{(1)}_{-1,0}(\\beta) &= \\tfrac{\\sin\\beta}{\\sqrt{2}}, \\quad &\nd^{(1)}_{-1,-1}(\\beta) &= \\tfrac{1+\\cos\\beta}{2}.\n\\end{aligned}\n$$\n- Fundamental transformation law: For an active rotation of directions $\\hat{\\mathbf{r}}_i \\mapsto R\\,\\hat{\\mathbf{r}}_i$, the spherical harmonics satisfy\n$$\nY_{1m}(\\widehat{R\\,\\mathbf{r}}) \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1}) \\, Y_{1m'}(\\hat{\\mathbf{r}}),\n$$\nwhich implies the equivariant feature transforms as\n$$\nF^{\\mathrm{rot}}_m \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\, F_{m'},\n$$\nwhere $F^{\\mathrm{rot}}_m$ is constructed from the rotated neighbor directions. Angles must be in radians.\n\nYour task:\n- Implement a program that, for each test case below, constructs $F$ from the provided neighbors and weights, rotates all neighbor directions by the specified rotation $R$ (using the $Z\\text{-}Y\\text{-}Z$ convention), constructs $F^{\\mathrm{rot}}$ from the rotated directions, computes $D^{(1)}(R)$, then forms $D^{(1)}(R^{-1}) = \\left(D^{(1)}(R)\\right)^{\\dagger}$, and finally reports the maximum absolute component-wise discrepancy\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m \\;-\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'} \\,\\right|.\n$$\n- All computations must use the definitions above. Neighbor direction vectors must be normalized to unit length before extracting $(\\theta,\\phi)$. Trigonometric functions and spherical harmonics must use radians. The discrepancy $\\varepsilon$ is a real nonnegative float.\n\nTest suite (use exactly these three cases):\n- Case $1$ (general rotation):\n  - Neighbors (each as $(x,y,z)$): $(1,0,0)$, $(0,1,0)$, $(0,0,1)$, $(-1,-1,1)$.\n  - Weights: $[1.0,\\,0.5,\\,-0.7,\\,1.2]$.\n  - Euler angles $(\\alpha,\\beta,\\gamma)$ in radians: $(0.7,\\,1.1,\\,-0.4)$.\n- Case $2$ (identity rotation boundary):\n  - Neighbors: $(2,1,0)$, $(0,-3,1)$, $(-1,0,2)$, $(1,-1,-1)$.\n  - Weights: $[1.0,\\,-0.3,\\,2.0,\\,-1.0]$.\n  - Euler angles: $(0.0,\\,0.0,\\,0.0)$.\n- Case $3$ (pure $z$-axis rotation by $\\pi$):\n  - Neighbors: $(1.0,\\,0.0,\\,0.2)$, $(0.3,\\,0.953939,\\,-0.4)$, $(-0.588,\\,-0.809,\\,0.7)$.\n  - Weights: $[0.8,\\,-1.1,\\,0.6]$.\n  - Euler angles: $(\\pi,\\,0.0,\\,0.0)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, in the order of Cases $1,2,3$, for example, $[x_1,x_2,x_3]$, where each $x_k$ is the float $\\varepsilon$ for Case $k$.",
            "solution": "The user requests a numerical verification of the rotational equivariance property of a rank-$1$ feature vector constructed from complex spherical harmonics. The problem is well-posed, scientifically grounded in the representation theory of the rotation group $\\mathrm{SO}(3)$, and provides all necessary definitions and data for a unique solution.\n\nThe core task is to compute the discrepancy $\\varepsilon$ for three test cases, where $\\varepsilon$ is defined as:\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m \\;-\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'} \\,\\right|\n$$\nThis involves two independent calculations of the transformed feature vector:\n$1$. The \"direct\" transformation, $F^{\\mathrm{rot}}$, is computed by first rotating the input coordinates in $\\mathbb{R}^3$ and then evaluating the feature vector construction pipeline on these new coordinates.\n$2$. The \"equivariant\" transformation, which we can denote $F^{\\mathrm{equiv}}$, is computed by applying the appropriate Wigner $D$-matrix, $D^{(1)}(R^{-1})$, to the original feature vector $F$.\n\nThe verification consists of showing that $F^{\\mathrm{rot}}$ and $F^{\\mathrm{equiv}}$ are numerically identical, up to floating-point precision. The value $\\varepsilon$ quantifies their difference.\n\nThe computational procedure for each test case is as follows:\n\n**Step 1: Spherical Harmonics Implementation**\nThe feature vector relies on the complex spherical harmonics for angular momentum $\\ell=1$. Following the Condon–Shortley phase convention, the required functions are:\n$$\n\\begin{aligned}\nY_{1,1}(\\theta, \\phi) &= -\\sqrt{\\frac{3}{8\\pi}} \\sin\\theta \\, e^{i\\phi} \\\\\nY_{1,0}(\\theta, \\phi) &= \\sqrt{\\frac{3}{4\\pi}} \\cos\\theta \\\\\nY_{1,-1}(\\theta, \\phi) &= \\sqrt{\\frac{3}{8\\pi}} \\sin\\theta \\, e^{-i\\phi}\n\\end{aligned}\n$$\nThese functions take spherical angles $(\\theta, \\phi)$ in radians as input.\n\n**Step 2: Coordinate and Feature Vector Calculation (Pre-Rotation)**\nFor a given set of neighbor vectors $\\{\\mathbf{r}_i\\}_{i=1}^{N}$ and weights $\\{w_i\\}_{i=1}^{N}$:\n$1$. Normalize each neighbor vector: $\\hat{\\mathbf{r}}_i = \\mathbf{r}_i / \\|\\mathbf{r}_i\\|$.\n$2$. Convert the Cartesian coordinates $(x_i, y_i, z_i)$ of each $\\hat{\\mathbf{r}}_i$ to spherical coordinates $(\\theta_i, \\phi_i)$. Given $\\hat{\\mathbf{r}}_i=(x_i,y_i,z_i)$, the conversion formulas are $\\theta_i = \\arccos(z_i)$ and $\\phi_i = \\operatorname{atan2}(y_i, x_i)$.\n$3$. Construct the original feature vector $F$, which is a $3$-component complex vector indexed by $m \\in \\{1, 0, -1\\}$. The components are:\n$$\nF_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i,\\phi_i)\n$$\n\n**Step 3: Direct Transformation (Rotation in $\\mathbb{R}^3$)**\n$1$. Construct the Cartesian rotation matrix $R(\\alpha, \\beta, \\gamma) \\in \\mathrm{SO}(3)$ from the given $Z\\text{-}Y\\text{-}Z$ Euler angles $(\\alpha, \\beta, \\gamma)$. The matrix is the product $R = R_z(\\alpha) R_y(\\beta) R_z(\\gamma)$, where $R_z$ and $R_y$ are standard rotation matrices about the respective axes.\n$2$. Apply this rotation to each of the original unit vectors: $\\hat{\\mathbf{r}}_i^{\\mathrm{rot}} = R\\,\\hat{\\mathbf{r}}_i$.\n$3$. Convert the resulting Cartesian coordinates of each $\\hat{\\mathbf{r}}_i^{\\mathrm{rot}}$ to a new set of spherical coordinates $(\\theta_i^{\\mathrm{rot}}, \\phi_i^{\\mathrm{rot}})$.\n$4$. Construct the rotated feature vector $F^{\\mathrm{rot}}$ using these new spherical coordinates and the original weights:\n$$\nF^{\\mathrm{rot}}_m \\;=\\; \\sum_{i=1}^{N} w_i \\, Y_{1m}(\\theta_i^{\\mathrm{rot}},\\phi_i^{\\mathrm{rot}})\n$$\n\n**Step 4: Equivariant Transformation (Rotation in Representation Space)**\n$1$. Construct the Wigner $D$-matrix for $\\ell=1$, $D^{(1)}(R) \\in \\mathbb{C}^{3\\times 3}$, using the Euler angles $(\\alpha, \\beta, \\gamma)$. Its elements are given by:\n$$\nD^{(1)}_{m m'}(\\alpha,\\beta,\\gamma) \\;=\\; e^{-i m \\alpha}\\, d^{(1)}_{m m'}(\\beta)\\, e^{-i m' \\gamma}\n$$\nThe matrix rows and columns are ordered corresponding to $m, m' \\in \\{1, 0, -1\\}$. The small-$d$ matrix elements $d^{(1)}_{mm'}(\\beta)$ are provided in the problem statement.\n$2$. The transformation law requires the matrix for the inverse rotation, $R^{-1}$. For unitary representations of $\\mathrm{SO}(3)$, this is the conjugate transpose of the forward rotation matrix: $D^{(1)}(R^{-1}) = (D^{(1)}(R))^{\\dagger}$.\n$3. $Apply this transformation to the original feature vector $F$ via matrix-vector multiplication to get the equivariantly transformed vector, $F^{\\mathrm{equiv}}$:\n$$\nF^{\\mathrm{equiv}}_m \\;=\\; \\sum_{m'=-1}^{1} D^{(1)}_{m m'}(R^{-1})\\,F_{m'}\n$$\n\n**Step 5: Discrepancy Calculation**\nFinally, compute the maximum absolute difference between the components of the two resulting vectors, $F^{\\mathrm{rot}}$ and $F^{\\mathrm{equiv}}$:\n$$\n\\varepsilon \\;=\\; \\max_{m \\in \\{1,0,-1\\}} \\left|\\, F^{\\mathrm{rot}}_m - F^{\\mathrm{equiv}}_m \\,\\right|\n$$\nThis value should be near machine precision (e.g., $\\approx 10^{-15}$) if the implementation is correct, confirming the equivariance property. The following program implements this procedure for the three specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Verifies the equivariant transformation of a rank-1 spherical harmonic feature.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"neighbors\": np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, -1.0, 1.0]]),\n            \"weights\": np.array([1.0, 0.5, -0.7, 1.2]),\n            \"euler_angles\": np.array([0.7, 1.1, -0.4]),\n        },\n        {\n            \"neighbors\": np.array([[2.0, 1.0, 0.0], [0.0, -3.0, 1.0], [-1.0, 0.0, 2.0], [1.0, -1.0, -1.0]]),\n            \"weights\": np.array([1.0, -0.3, 2.0, -1.0]),\n            \"euler_angles\": np.array([0.0, 0.0, 0.0]),\n        },\n        {\n            \"neighbors\": np.array([[1.0, 0.0, 0.2], [0.3, 0.953939, -0.4], [-0.588, -0.809, 0.7]]),\n            \"weights\": np.array([0.8, -1.1, 0.6]),\n            \"euler_angles\": np.array([np.pi, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    \n    # m-values ordering for feature vectors and Wigner matrices\n    m_vals = np.array([1, 0, -1])\n\n    def get_spherical_harmonics_l1(theta, phi):\n        \"\"\"\n        Computes Y_1m(theta, phi) for m=1,0,-1.\n        Vectorized over theta and phi.\n        \"\"\"\n        c1 = np.sqrt(3 / (8 * np.pi))\n        c0 = np.sqrt(3 / (4 * np.pi))\n        \n        sin_theta = np.sin(theta)\n        cos_theta = np.cos(theta)\n        \n        y11 = -c1 * sin_theta * np.exp(1j * phi)\n        y10 =  c0 * cos_theta\n        y1m1 = c1 * sin_theta * np.exp(-1j * phi)\n        \n        # Return in order m=1, 0, -1\n        return np.array([y11, y10, y1m1])\n\n    def get_feature_vector(neighbors, weights):\n        \"\"\"\n        Computes the feature vector F_m from neighbors and weights.\n        \"\"\"\n        norms = np.linalg.norm(neighbors, axis=1)\n        unit_vectors = neighbors / norms[:, np.newaxis]\n        \n        x, y, z = unit_vectors.T\n        \n        theta = np.arccos(z)\n        phi = np.arctan2(y, x)\n        \n        y1m_vals = get_spherical_harmonics_l1(theta, phi) # Shape (3, N)\n        \n        # F_m = sum_i w_i Y_1m(theta_i, phi_i)\n        # weights are (N,), y1m_vals are (3, N), broadcasting does the trick\n        F = np.sum(weights * y1m_vals, axis=1) # Shape (3,)\n        return F, unit_vectors\n\n    def get_rotation_matrix(alpha, beta, gamma):\n        \"\"\"\n        Computes the Z-Y-Z Euler rotation matrix.\n        \"\"\"\n        ca, sa = np.cos(alpha), np.sin(alpha)\n        cb, sb = np.cos(beta), np.sin(beta)\n        cg, sg = np.cos(gamma), np.sin(gamma)\n        \n        Rz_a = np.array([[ca, -sa, 0], [sa, ca, 0], [0, 0, 1]])\n        Ry_b = np.array([[cb, 0, sb], [0, 1, 0], [-sb, 0, cb]])\n        Rz_g = np.array([[cg, -sg, 0], [sg, cg, 0], [0, 0, 1]])\n        \n        return Rz_a @ Ry_b @ Rz_g\n\n    def get_wigner_d1_matrix(alpha, beta, gamma):\n        \"\"\"\n        Computes the Wigner D-matrix for l=1.\n        Rows/cols are ordered by m=1, 0, -1.\n        \"\"\"\n        cb, sb = np.cos(beta), np.sin(beta)\n        sqrt2 = np.sqrt(2)\n        \n        # Wigner small-d matrix for l=1\n        d1 = np.array([\n            [(1 + cb) / 2, -sb / sqrt2, (1 - cb) / 2],\n            [sb / sqrt2,        cb,    -sb / sqrt2],\n            [(1 - cb) / 2,  sb / sqrt2, (1 + cb) / 2]\n        ])\n        \n        exp_a = np.exp(-1j * m_vals * alpha)\n        exp_g = np.exp(-1j * m_vals * gamma)\n        \n        # D(R) = diag(exp(-im*alpha)) * d(beta) * diag(exp(-im'*gamma))\n        D1 = np.diag(exp_a) @ d1 @ np.diag(exp_g)\n        return D1\n\n    for case in test_cases:\n        neighbors = case[\"neighbors\"]\n        weights = case[\"weights\"]\n        alpha, beta, gamma = case[\"euler_angles\"]\n\n        # 1. Compute original feature vector F\n        F, unit_vectors = get_feature_vector(neighbors, weights)\n        \n        # 2. Compute rotated feature vector F_rot by rotating coordinates\n        R_cartesian = get_rotation_matrix(alpha, beta, gamma)\n        rotated_unit_vectors = (R_cartesian @ unit_vectors.T).T\n        F_rot, _ = get_feature_vector(rotated_unit_vectors, weights)\n        \n        # 3. Compute transformed vector F_equiv using Wigner D-matrix\n        D1_R = get_wigner_d1_matrix(alpha, beta, gamma)\n        # D(R^-1) = D(R)^dagger for unitary representations\n        D1_R_inv = D1_R.conj().T\n        F_equiv = D1_R_inv @ F\n        \n        # 4. Calculate the discrepancy\n        discrepancy = np.max(np.abs(F_rot - F_equiv))\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    # Use a format specifier for consistent scientific notation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final exercise integrates the principles of the previous sections into a complete, albeit minimal, E(3)-equivariant message-passing neural network. You will construct a two-layer model from first principles, implementing how atoms exchange information through equivariant messages built from scalar ($l=0$) and vector ($l=1$) features. By performing a full forward pass to compute an invariant energy, you will solidify your understanding of how these components work together to create a powerful and physically principled potential .",
            "id": "3449494",
            "problem": "You are asked to construct, from first principles, a minimal yet nontrivial two-layer Euclidean group in three dimensions (E(3))-equivariant message passing neural network for a small molecule. The network must operate on node features decomposed into irreducible representations of the special orthogonal group in three dimensions (SO(3)), specifically scalar features of degree $l=0$ and vector features of degree $l=1$. You will implement an explicit forward pass on a fixed set of test configurations using only the mathematical rules of equivariant coupling and a specified set of scalar weights and radial functions. The final output must be a single line containing a list of floating-point results for the provided test suite.\n\nFundamental base and constraints:\n- The Euclidean group in three dimensions (E(3)) symmetry acts on point coordinates via rotations and translations. Rotational equivariance is defined such that vector features transform according to the $l=1$ irreducible representation, and scalar features are invariant. Translations affect only relative positions, hence using relative displacements ensures translation invariance.\n- For each directed edge from node $j$ to node $i$, let the displacement be $\\mathbf{r}_{ij} = \\mathbf{x}_{j} - \\mathbf{x}_{i}$, the distance be $r_{ij} = \\|\\mathbf{r}_{ij}\\|$, and the unit direction be $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$. Under a rotation represented by a matrix $\\mathbf{R} \\in \\mathrm{SO}(3)$, vectors such as $\\mathbf{r}$ and $l=1$ features transform as $\\mathbf{v} \\mapsto \\mathbf{R} \\mathbf{v}$, scalars remain invariant, and inner products such as $\\mathbf{u} \\cdot \\mathbf{v}$ are invariant.\n- Equivariant tensor products at the level of $l \\in \\{0, 1\\}$ can be realized using the following couplings:\n  - Scalar-scalar to scalar: $0 \\otimes 0 \\rightarrow 0$ via multiplication by a scalar radial envelope.\n  - Vector-vector to scalar: $1 \\otimes 1 \\rightarrow 0$ via the dot product.\n  - Scalar-vector and vector-scalar to vector: $0 \\otimes 1 \\rightarrow 1$ and $1 \\otimes 0 \\rightarrow 1$ via scaling a vector by a scalar.\n  - Vector-vector to vector: $1 \\otimes 1 \\rightarrow 1$ via projection of one vector onto the other’s direction, e.g., $(\\mathbf{v} \\cdot \\hat{\\mathbf{r}})\\,\\hat{\\mathbf{r}}$.\n- Use a smooth radial envelope to ensure locality and continuity: for a cutoff radius $R_{c}$ and radial decay constant $\\alpha$, define\n  $$\\phi(r) = \\exp(-\\alpha r), \\quad f_{\\mathrm{cut}}(r) = \\begin{cases} \\tfrac{1}{2}\\left(\\cos\\left(\\pi r / R_{c}\\right)+1\\right), & r \\le R_{c} \\\\ 0, & r > R_{c} \\end{cases}, \\quad s(r) = \\phi(r)\\, f_{\\mathrm{cut}}(r).$$\n\nArchitecture and forward pass specification:\n- Nodes carry scalar feature $s^{(l)}_{i} \\in \\mathbb{R}$ and vector feature $\\mathbf{v}^{(l)}_{i} \\in \\mathbb{R}^{3}$ at layer $l \\in \\{0, 1, 2\\}$.\n- Initialization uses an embedding that maps atomic number $Z$ to an initial scalar and vector:\n  - For $Z=1$ (hydrogen), $s^{(0)} = 0.7$, $\\mathbf{v}^{(0)} = (0, 0, 0)$.\n  - For $Z=6$ (carbon), $s^{(0)} = 0.4$, $\\mathbf{v}^{(0)} = (0, 0, 0)$.\n  - For $Z=8$ (oxygen), $s^{(0)} = -0.2$, $\\mathbf{v}^{(0)} = (0, 0, 0)$.\n- There are no self-edges. Messages at layer $l$ for node $i$ are aggregated by summation over all $j \\neq i$:\n  - Scalar message:\n    $$m^{(l)}_{0,i} = \\sum_{j \\ne i} \\left( w^{(l)}_{00}\\, s(r_{ij})\\, s^{(l)}_{j} + w^{(l)}_{11\\rightarrow 0}\\, s(r_{ij})\\, \\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij} \\right).$$\n  - Vector message:\n    $$\\mathbf{m}^{(l)}_{1,i} = \\sum_{j \\ne i} \\left( w^{(l)}_{01}\\, s(r_{ij})\\, s^{(l)}_{j}\\, \\hat{\\mathbf{r}}_{ij} + w^{(l)}_{10}\\, s(r_{ij})\\, \\mathbf{v}^{(l)}_{j} + w^{(l)}_{11\\rightarrow 1}\\, s(r_{ij})\\, (\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij})\\, \\hat{\\mathbf{r}}_{ij} \\right).$$\n- Feature updates are affine for scalars and linear for vectors:\n  $$s^{(l+1)}_{i} = a^{(l)}_{0}\\, s^{(l)}_{i} + b^{(l)}_{0}\\, m^{(l)}_{0,i} + \\mathrm{bias}^{(l)}_{0}, \\quad \\mathbf{v}^{(l+1)}_{i} = a^{(l)}_{1}\\, \\mathbf{v}^{(l)}_{i} + b^{(l)}_{1}\\, \\mathbf{m}^{(l)}_{1,i}.$$\n- The readout produces a per-node invariant energy contribution combining scalar and the squared norm of the vector:\n  $$e_{i} = c_{0}\\, s^{(2)}_{i} + c_{1}\\, \\|\\mathbf{v}^{(2)}_{i}\\|^{2}, \\quad E = \\sum_{i} e_{i}.$$\n\nHyperparameters and weights:\n- Cutoff radius $R_{c} = 2.5$, radial decay $\\alpha = 1.0$ shared across layers.\n- Layer $l=0$ weights:\n  - $w^{(0)}_{00} = 0.8$, $w^{(0)}_{11\\rightarrow 0} = 0.3$, $w^{(0)}_{01} = 1.1$, $w^{(0)}_{10} = 0.5$, $w^{(0)}_{11\\rightarrow 1} = 0.7$.\n  - $a^{(0)}_{0} = 0.9$, $b^{(0)}_{0} = 1.2$, $\\mathrm{bias}^{(0)}_{0} = 0.05$.\n  - $a^{(0)}_{1} = 0.8$, $b^{(0)}_{1} = 1.0$.\n- Layer $l=1$ weights:\n  - $w^{(1)}_{00} = -0.4$, $w^{(1)}_{11\\rightarrow 0} = 0.2$, $w^{(1)}_{01} = 0.6$, $w^{(1)}_{10} = 0.9$, $w^{(1)}_{11\\rightarrow 1} = -0.3$.\n  - $a^{(1)}_{0} = 1.1$, $b^{(1)}_{0} = 0.7$, $\\mathrm{bias}^{(1)}_{0} = -0.02$.\n  - $a^{(1)}_{1} = 0.95$, $b^{(1)}_{1} = 0.85$.\n- Readout weights: $c_{0} = 1.3$, $c_{1} = 0.2$.\n\nTest suite of molecular configurations and required outputs:\n- All coordinates are in angstroms, and the final energies must be in arbitrary energy units. Angles must be in radians.\n- Case $1$ (water-like geometry): three atoms with atomic numbers and positions\n  - $Z = 8$ at $(0.0, 0.0, 0.0)$,\n  - $Z = 1$ at $(0.9572, 0.0, 0.0)$,\n  - $Z = 1$ at $(-0.2390, 0.9270, 0.0)$.\n  Compute $E_{1}$.\n- Case $2$ (rotated Case $1$): rotate all positions of Case $1$ about the $z$-axis by angle $\\theta = 0.61$ to obtain a new configuration. Compute $E_{2}$ and then compute the absolute difference $\\Delta = |E_{1} - E_{2}|$ as the result for this case.\n- Case $3$ (beyond cutoff): two atoms\n  - $Z = 6$ at $(0.0, 0.0, 0.0)$,\n  - $Z = 1$ at $(3.0, 0.0, 0.0)$.\n  Compute $E_{3}$.\n- Case $4$ (collinear triatomic with a cutoff boundary): three atoms\n  - $Z = 6$ at $(0.0, 0.0, 0.0)$,\n  - $Z = 6$ at $(1.25, 0.0, 0.0)$,\n  - $Z = 6$ at $(2.5, 0.0, 0.0)$.\n  Compute $E_{4}$.\n\nRequirements for your program:\n- Implement exactly the two-layer equivariant message passing network as specified, using the given weights, features, and radial functions. Use pairwise directed edges without self-edges. Use the unit direction $\\hat{\\mathbf{r}}_{ij}$ for vector couplings.\n- Ensure numerical stability by avoiding division by zero; in this setup, $r_{ij} = 0$ does not occur because there are no self-edges.\n- Compute the four case results as follows: the first element is $E_{1}$, the second is $\\Delta$ from Case $2$, the third is $E_{3}$, and the fourth is $E_{4}$.\n- Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$). Each floating-point result must be rounded to $6$ decimal places.",
            "solution": "The problem requires the construction and implementation of a two-layer Euclidean group in three dimensions, E(3)-equivariant, message-passing neural network to calculate the potential energy of small molecular configurations. The solution adheres to the specified architecture, weights, and mathematical principles.\n\nThe fundamental principle of an E(3)-equivariant network is that its operations must respect the symmetries of 3D space: translation, rotation, and inversion. For a system of atoms, the potential energy $E$ must be invariant under any rigid translation or rotation of the entire system.\n\n1.  **Symmetry Considerations**:\n    - **Translation Invariance**: This is achieved by making the network operate on relative position vectors $\\mathbf{r}_{ij} = \\mathbf{x}_{j} - \\mathbf{x}_{i}$ rather than absolute coordinates $\\mathbf{x}_i$. Since $\\mathbf{r}_{ij}$ is invariant under a global translation $\\mathbf{x}_k \\mapsto \\mathbf{x}_k + \\mathbf{t}$ for all $k$, all subsequent calculations based on these displacements will also be translation-invariant.\n    - **Rotational Equivariance**: This is managed by characterizing features according to their transformation properties under the special orthogonal group SO(3). The features are decomposed into irreducible representations (irreps), indexed by a degree $l \\in \\{0, 1, 2, \\dots\\}$. In this problem, we only consider scalar features (degree $l=0$, invariant under rotation) and vector features (degree $l=1$, which rotate like coordinate vectors). An operation is equivariant if applying a rotation to the input and then performing the operation yields the same result as performing the operation first and then rotating its output. For a final invariant quantity like energy, the network must be equivariant at intermediate layers and conclude with an invariant readout.\n\n2.  **Network Architecture**: The network is composed of three stages: initialization, two layers of message passing, and a final energy readout.\n\n    - **Feature Initialization (Layer $l=0$)**: Each atom $i$ is initialized with a scalar feature $s^{(0)}_{i}$ and a vector feature $\\mathbf{v}^{(0)}_{i}$ based on its atomic number $Z_i$. As specified, the initial vector features $\\mathbf{v}^{(0)}_{i}$ are all zero vectors, $\\mathbf{v}^{(0)}_{i} = (0, 0, 0)$, which is trivially equivariant. The initial scalar features are constants for each element type: $s^{(0)} = 0.7$ for $Z=1$, $s^{(0)} = 0.4$ for $Z=6$, and $s^{(0)} = -0.2$ for $Z=8$.\n\n    - **Message Passing (Layers $l=0, 1$)**: At each layer $l$, every atom $i$ receives messages from all other atoms $j \\neq i$. These messages are constructed using equivariant tensor products of the features of atom $j$ and the geometric information from the relative position vector $\\mathbf{r}_{ij}$.\n      - The geometry is encoded in the distance $r_{ij} = \\|\\mathbf{r}_{ij}\\|$ and the direction vector $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$.\n      - A radial function $s(r) = \\exp(-\\alpha r) \\cdot \\frac{1}{2}(\\cos(\\pi r / R_{c})+1)$ for $r \\le R_c$ and $s(r)=0$ for $r > R_c$ is used to provide a learnable, smooth, and local (within a cutoff radius $R_c$) weighting for all interactions. The parameters are given as $R_c=2.5$ and $\\alpha=1.0$.\n      - **Scalar Message $m^{(l)}_{0,i}$**: The scalar message is an invariant quantity (degree $l=0$). It is formed by summing two types of invariant terms over neighbors $j$:\n        1.  $s^{(l)}_j \\cdot s(r_{ij})$: Product of two scalars (type $0 \\otimes 0 \\to 0$), weighted by $w^{(l)}_{00}$.\n        2.  $(\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\cdot s(r_{ij})$: Dot product of two vectors (type $1 \\otimes 1 \\to 0$), weighted by $w^{(l)}_{11\\rightarrow 0}$.\n        The total scalar message for atom $i$ is:\n        $$m^{(l)}_{0,i} = \\sum_{j \\ne i} s(r_{ij}) \\left( w^{(l)}_{00} s^{(l)}_{j} + w^{(l)}_{11\\rightarrow 0} \\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij} \\right)$$\n      - **Vector Message $\\mathbf{m}^{(l)}_{1,i}$**: The vector message is an equivariant vector (degree $l=1$). It is a sum of three equivariant vector terms:\n        1.  $s^{(l)}_{j} \\hat{\\mathbf{r}}_{ij} \\cdot s(r_{ij})$: A scalar multiplying a vector (type $0 \\otimes 1 \\to 1$), weighted by $w^{(l)}_{01}$.\n        2.  $\\mathbf{v}^{(l)}_{j} \\cdot s(r_{ij})$: A scalar-like radial function multiplying a vector (type $1 \\otimes 0 \\to 1$), weighted by $w^{(l)}_{10}$.\n        3.  $(\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij} \\cdot s(r_{ij})$: The projection of one vector onto another (type $1 \\otimes 1 \\to 1$), weighted by $w^{(l)}_{11\\rightarrow 1}$.\n        The total vector message for atom $i$ is:\n        $$\\mathbf{m}^{(l)}_{1,i} = \\sum_{j \\ne i} s(r_{ij}) \\left( w^{(l)}_{01} s^{(l)}_{j} \\hat{\\mathbf{r}}_{ij} + w^{(l)}_{10} \\mathbf{v}^{(l)}_{j} + w^{(l)}_{11\\rightarrow 1} (\\mathbf{v}^{(l)}_{j} \\cdot \\hat{\\mathbf{r}}_{ij}) \\hat{\\mathbf{r}}_{ij} \\right)$$\n\n    - **Feature Updates**: The features for the next layer, $s^{(l+1)}_{i}$ and $\\mathbf{v}^{(l+1)}_{i}$, are computed from the current features and the aggregated messages. The update rules must preserve the transformation properties of the features.\n      - The scalar update is an affine transformation, which preserves the scalar nature:\n        $$s^{(l+1)}_{i} = a^{(l)}_{0}\\, s^{(l)}_{i} + b^{(l)}_{0}\\, m^{(l)}_{0,i} + \\mathrm{bias}^{(l)}_{0}$$\n      - The vector update is a linear combination of two vectors (the previous layer's vector $\\mathbf{v}^{(l)}_{i}$ and the message vector $\\mathbf{m}^{(l)}_{1,i}$), which results in a vector that transforms equivariantly:\n        $$\\mathbf{v}^{(l+1)}_{i} = a^{(l)}_{1}\\, \\mathbf{v}^{(l)}_{i} + b^{(l)}_{1}\\, \\mathbf{m}^{(l)}_{1,i}$$\n      This process is executed for layer $l=0$ to produce features $(s^{(1)}, \\mathbf{v}^{(1)})$, and then for layer $l=1$ to produce features $(s^{(2)}, \\mathbf{v}^{(2)})$. The specific weights for each layer and update are provided in the problem statement.\n\n    - **Energy Readout**: The final step is to compute a single, rotationally and translationally invariant total energy $E$ from the final layer's features. This is done by first calculating a per-atom invariant energy contribution $e_i$ and then summing over all atoms.\n      - The per-atom energy $e_i$ is a linear combination of two invariant quantities derived from the layer-2 features: the scalar feature $s^{(2)}_{i}$ (already invariant) and the squared norm of the vector feature $\\|\\mathbf{v}^{(2)}_{i}\\|^2$ (which is invariant because the norm of a vector does not change upon rotation).\n        $$e_{i} = c_{0}\\, s^{(2)}_{i} + c_{1}\\, \\|\\mathbf{v}^{(2)}_{i}\\|^{2}$$\n      - The total energy is the sum over all atoms:\n        $$E = \\sum_{i} e_{i}$$\n      The readout weights are given as $c_{0} = 1.3$ and $c_{1} = 0.2$.\n\n3.  **Implementation for Test Cases**: The algorithm is applied to the four specified test cases. For each case, the atomic numbers and positions are used to initialize the network. The two message-passing layers are executed sequentially, followed by the energy readout.\n    - **Case 1**: A direct calculation on a water-like molecule to find $E_1$.\n    - **Case 2**: The coordinates of Case 1 are rotated. A key test of the network's rotational invariance is that the energy $E_2$ of the rotated system must equal $E_1$. The result for this case is the absolute difference $\\Delta = |E_1 - E_2|$, which is expected to be close to zero.\n    - **Case 3**: Involves two atoms separated by a distance greater than the cutoff $R_c$. This tests the locality of interactions; since $s(r_{ij})=0$, all message terms are zero, and the features update only based on their previous values (the \"self-interaction\" part of the update rule).\n    - **Case 4**: A collinear system where one interatomic distance is exactly equal to the cutoff radius. This tests the boundary condition of the cutoff function $f_{\\mathrm{cut}}(R_c)=0$, which should nullify the interaction between that specific pair of atoms.\n\nThe final Python implementation encapsulates this entire procedure, precisely following the formulas and using the provided parameters to compute the required results for the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the equivariant network model.\n    \"\"\"\n\n    def radial_s(r, R_c, alpha):\n        \"\"\"Computes the radial basis function s(r).\"\"\"\n        if r > R_c or r == 0:\n            return 0.0\n        phi_r = np.exp(-alpha * r)\n        f_cut = 0.5 * (np.cos(np.pi * r / R_c) + 1.0)\n        return phi_r * f_cut\n\n    def run_forward_pass(atomic_numbers, positions):\n        \"\"\"\n        Executes the full forward pass of the 2-layer E(3)-equivariant network.\n        \"\"\"\n        # Hyperparameters and weights\n        R_c = 2.5\n        alpha = 1.0\n\n        weights = [\n            {  # Layer l=0\n                'w00': 0.8, 'w11_0': 0.3, 'w01': 1.1, 'w10': 0.5, 'w11_1': 0.7,\n                'a0': 0.9, 'b0': 1.2, 'bias0': 0.05,\n                'a1': 0.8, 'b1': 1.0\n            },\n            {  # Layer l=1\n                'w00': -0.4, 'w11_0': 0.2, 'w01': 0.6, 'w10': 0.9, 'w11_1': -0.3,\n                'a0': 1.1, 'b0': 0.7, 'bias0': -0.02,\n                'a1': 0.95, 'b1': 0.85\n            }\n        ]\n        readout_weights = {'c0': 1.3, 'c1': 0.2}\n\n        # Initial feature embeddings\n        embeddings = {\n            1: {'s': 0.7, 'v': np.array([0.0, 0.0, 0.0])},  # H\n            6: {'s': 0.4, 'v': np.array([0.0, 0.0, 0.0])},  # C\n            8: {'s': -0.2, 'v': np.array([0.0, 0.0, 0.0])}, # O\n        }\n\n        num_atoms = len(atomic_numbers)\n        s_features = np.array([embeddings[z]['s'] for z in atomic_numbers])\n        v_features = np.array([embeddings[z]['v'] for z in atomic_numbers])\n        \n        # Two message passing layers\n        for l in range(2):\n            w = weights[l]\n            s_next = np.zeros(num_atoms)\n            v_next = np.zeros((num_atoms, 3))\n\n            for i in range(num_atoms):\n                m0_i = 0.0\n                m1_i = np.zeros(3)\n                \n                for j in range(num_atoms):\n                    if i == j:\n                        continue\n                    \n                    r_ij_vec = positions[j] - positions[i]\n                    r_ij_norm = np.linalg.norm(r_ij_vec)\n                    \n                    if r_ij_norm > R_c:\n                        continue\n                    \n                    r_ij_hat = r_ij_vec / r_ij_norm\n                    s_r = radial_s(r_ij_norm, R_c, alpha)\n                    \n                    s_j = s_features[j]\n                    v_j = v_features[j]\n                    \n                    v_j_dot_r_hat = np.dot(v_j, r_ij_hat)\n                    \n                    # Scalar message aggregation\n                    m0_i += s_r * (w['w00'] * s_j + w['w11_0'] * v_j_dot_r_hat)\n                    \n                    # Vector message aggregation\n                    term1 = w['w01'] * s_j * r_ij_hat\n                    term2 = w['w10'] * v_j\n                    term3 = w['w11_1'] * v_j_dot_r_hat * r_ij_hat\n                    m1_i += s_r * (term1 + term2 + term3)\n                \n                # Feature updates\n                s_next[i] = w['a0'] * s_features[i] + w['b0'] * m0_i + w['bias0']\n                v_next[i, :] = w['a1'] * v_features[i] + w['b1'] * m1_i\n            \n            s_features = s_next\n            v_features = v_next\n        \n        # Energy Readout\n        total_energy = 0.0\n        for i in range(num_atoms):\n            s2_i = s_features[i]\n            v2_i_norm_sq = np.linalg.norm(v_features[i])**2\n            e_i = readout_weights['c0'] * s2_i + readout_weights['c1'] * v2_i_norm_sq\n            total_energy += e_i\n            \n        return total_energy\n\n    # --- Test Suite ---\n    \n    # Case 1: Water-like geometry\n    z1 = [8, 1, 1]\n    pos1 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.9572, 0.0, 0.0],\n        [-0.2390, 0.9270, 0.0]\n    ])\n    E1 = run_forward_pass(z1, pos1)\n\n    # Case 2: Rotated Case 1\n    theta = 0.61\n    c, s = np.cos(theta), np.sin(theta)\n    R_z = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    pos2 = pos1 @ R_z.T \n    E2 = run_forward_pass(z1, pos2)\n    Delta = abs(E1 - E2)\n\n    # Case 3: Beyond cutoff\n    z3 = [6, 1]\n    pos3 = np.array([\n        [0.0, 0.0, 0.0],\n        [3.0, 0.0, 0.0]\n    ])\n    E3 = run_forward_pass(z3, pos3)\n\n    # Case 4: Collinear triatomic with cutoff boundary\n    z4 = [6, 6, 6]\n    pos4 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.25, 0.0, 0.0],\n        [2.5, 0.0, 0.0]\n    ])\n    E4 = run_forward_pass(z4, pos4)\n\n    results = [E1, Delta, E3, E4]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}