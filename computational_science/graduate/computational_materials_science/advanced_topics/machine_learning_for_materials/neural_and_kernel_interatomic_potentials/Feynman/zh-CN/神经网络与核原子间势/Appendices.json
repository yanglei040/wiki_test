{
    "hands_on_practices": [
        {
            "introduction": "构建任何原子间势的第一步是为原子环境选择一个合适的数学表示，即“描述符”。一个直观的想法是使用对距离的统计直方图，但这可能会丢失关键的结构信息。本练习  将通过一个具体的反例，展示两个结构截然不同的构型如何因具有相同的距离直方图而产生不同的能量，从而揭示了开发能够捕捉角度等高阶相关性信息的复杂描述符的必要性。",
            "id": "3468348",
            "problem": "给定两种原子构型的表示方法：欧几里得空间中的完整坐标集，以及由对距离（pairwise distances）直方图给出的降维特征向量。考虑一个依赖于键角和径向衰减的三体势能，该势能通常无法仅从对距离直方图重构。您的任务是构建明确的反例来证明这种不充分性，并量化任何仅限于使用对距离直方图的模型所必须产生的不可约偏差。\n\n定义与基本基础：\n- 设有 $N$ 个原子，其在 $\\mathbb{R}^3$ 中的位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$。无序的对距离为 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$，其中 $1 \\le i  j \\le N$。\n- 固定一个区间边界向量 $\\mathbf{b} = (b_0,b_1,\\dots,b_B)$，其中 $b_0  b_1  \\cdots  b_B$。通过对每个区间索引 $m \\in \\{1,\\dots,B\\}$ 进行计数，定义对距离直方图特征 $\\mathbf{H} \\in \\mathbb{Z}_{\\ge 0}^B$：\n$$\nH_m = \\left|\\left\\{(i,j) \\,\\middle|\\, 1 \\le i  j \\le N,\\, r_{ij} \\in [b_{m-1}, b_m) \\right\\}\\right|.\n$$\n- 使用第二勒让德多项式定义一个具有角度依赖性的三体能量。对于给定的径向尺度 $\\sigma > 0$，径向函数 $f(r) = \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^2\\right)$，以及 $P_2(x) = \\frac{1}{2}\\left(3x^2 - 1\\right)$，设定\n$$\nE_3(\\{\\mathbf{r}_i\\}; \\sigma) = \\sum_{i=1}^N \\sum_{\\substack{j, k \\neq i \\\\ j  k}} f(r_{ij})f(r_{ik})P_2(\\cos\\theta_{ijk})\n$$\n其中 $\\theta_{ijk}$ 是以原子 $i$ 为顶点，连接原子 $j$ 和 $k$ 的向量所形成的夹角。\n\n您的任务是针对以下三个测试用例，计算由对距离直方图简并性引起的不可约偏差。对于每种情况，提供了两种不同的原子构型 $\\mathcal{A}$ 和 $\\mathcal{B}$，它们的对距离直方图保证相同。您必须计算 $|E_3(\\mathcal{A};\\sigma) - E_3(\\mathcal{B};\\sigma)| / 2$。\n\n测试用例 1：\n- 构型 $\\mathcal{A}$：$\\{(0,0,0), (1,0,0), (1,1,0), (0,1,0)\\}$\n- 构型 $\\mathcal{B}$：$\\{(0,0,0), (0.9,0,0), (0.9,1.1,0), (0,1.1,0)\\}$\n- 直方图区间：$[0.0, 1.2, 2.0]$\n- 径向尺度 $\\sigma = 1.0$\n\n测试用例 2：\n- 构型 $\\mathcal{A}$（正四面体）：$\\{(0,0,0), (1,0,0), (0.5, \\sqrt{3}/2, 0), (0.5, \\sqrt{3}/6, \\sqrt{6}/3)\\}$\n- 构型 $\\mathcal{B}$（平面正方形）：$\\{(0,0,0), (1,0,0), (1,1,0), (0,1,0)\\}$\n- 直方图区间：$[0.0, 2.0]$\n- 径向尺度 $\\sigma = 1.0$\n\n测试用例 3：\n- 构型 $\\mathcal{A}$：$\\{(0,0,0), (1,0,0), (1,1,0), (0,1,0)\\}$\n- 构型 $\\mathcal{B}$：$\\{(0,0,0), (0.9,0,0), (0.9,1.1,0), (0,1.1,0)\\}$\n- 直方图区间：$[0.0, 1.2, 2.0]$\n- 径向尺度 $\\sigma = 0.01$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序列出三个测试用例的不可约偏差，即 $[d_1, d_2, d_3]$，其中每个 $d_i$ 都表示为一个浮点数。",
            "solution": "该问题要求构建并分析反例，以证明基于对距离直方图的特征向量不足以唯一确定一个依赖于角度的三体相互作用能。我们的任务是量化任何受限于此类直方图表示的模型的最小不可避免误差，该误差被称为不可约偏差。\n\n其核心原理是特征化过程中的信息损失。原子位置 $\\{\\mathbf{r}_i\\}_{i=1}^N$ 在 $\\mathbb{R}^3$ 中的完整几何信息被投影到一个低维特征空间，在本例中即为对距离直方图 $\\mathbf{H}$。虽然这种投影保留了部分信息（特别是原子间距离的分布），但它丢弃了其他信息，例如原子三元组之间的角度相关性。一个依赖于这些被丢弃信息的势能函数，如所提供的三体项 $E_3$，无法被一个只能访问直方图的模型 $\\widehat{E}(\\mathbf{H})$完美表示。\n\n证明这一点的方法如下：\n1.  定义两个不同的原子构型 $\\mathcal{A}$ 和 $\\mathcal{B}$，其原子坐标分别为 $\\{\\mathbf{r}_i^\\mathcal{A}\\}$ 和 $\\{\\mathbf{r}_i^\\mathcal{B}\\}$。\n2.  选择区间边界 $\\mathbf{b}$，使得两种构型的对距离直方图相同，即 $\\mathbf{H}(\\mathcal{A}) = \\mathbf{H}(\\mathcal{B})$。这在特征空间中造成了简并或“碰撞”。\n3.  使用所提供的公式计算真实的三体能量 $E_3(\\mathcal{A};\\sigma)$ 和 $E_3(\\mathcal{B};\\sigma)$，该公式对三维几何（包括键角）敏感。\n4.  如果 $E_3(\\mathcal{A};\\sigma) \\ne E_3(\\mathcal{B};\\sigma)$，则证明直方图 $\\mathbf{H}$ 是一个不充分的描述符。任何从 $\\mathbf{H}$ 映射到能量预测的模型 $\\widehat{E}$ 都必须为两者赋予相同的值，即 $\\widehat{E}(\\mathbf{H}(\\mathcal{A})) = \\widehat{E}(\\mathbf{H}(\\mathcal{B}))$，这导致至少对其中一个构型产生误差。这对构型的误差下界是不可约偏差，由 $\\frac{1}{2}|E_3(\\mathcal{A};\\sigma) - E_3(\\mathcal{B};\\sigma)|$ 给出。\n\n解决每个测试用例的算法流程是：\n\n首先，我们实现一个函数来为给定的一组 $N$ 个原子坐标 $\\{\\mathbf{r}_i\\}$ 计算对距离。这涉及遍历所有唯一的原子对 $(i,j)$（其中 $1 \\le i  j \\le N$）并计算欧几里得范数 $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$。\n\n其次，我们实现一个函数来生成直方图 $\\mathbf{H}$。该函数将对距离列表和区间边界向量 $\\mathbf{b} = (b_0, b_1, \\dots, b_B)$ 作为输入。对于每个区间 $m \\in \\{1, \\dots, B\\}$，它会计算落入半开区间 $[b_{m-1}, b_m)$ 的距离 $r_{ij}$ 的数量。必须对构型 $\\mathcal{A}$ 和 $\\mathcal{B}$ 都执行此过程，以验证它们的直方图确实相同，正如问题所规定的。\n\n第三，我们实现三体能量 $E_3$ 的计算。公式为：\n$$\nE_3(\\{\\mathbf{r}_i\\}; \\sigma) = \\sum_{i=1}^N \\sum_{\\substack{j, k \\neq i \\\\ j  k}} f(r_{ij})f(r_{ik})P_2(\\cos\\theta_{ijk})\n$$\n这个计算需要一个三层嵌套循环。外层循环遍历所有原子 $i=1,\\dots,N$ 作为潜在的中心原子。中间两层循环遍历所有唯一的邻居对 $(j,k)$，其中 $j \\ne i, k \\ne i, j  k$。在最内层循环中，我们计算向量 $\\mathbf{v}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 和 $\\mathbf{v}_{ik} = \\mathbf{r}_k - \\mathbf{r}_i$。然后，我们计算它们的范数（距离）$r_{ij}$ 和 $r_{ik}$，以及它们之间夹角的余弦 $\\cos\\theta_{ijk} = \\frac{\\mathbf{v}_{ij} \\cdot \\mathbf{v}_{ik}}{r_{ij} r_{ik}}$。这些值被代入项 $f(r_{ij})f(r_{ik})P_2(\\cos\\theta_{ijk})$ 中，并累加到总能量 $E_3$ 中。\n\n最后，对于每个测试用例，我们计算构型 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的能量 $E_3(\\mathcal{A})$ 和 $E_3(\\mathcal{B})$。不可约偏差计算为 $\\frac{1}{2}|E_3(\\mathcal{A}) - E_3(\\mathcal{B})|$。最终输出是一个包含三个测试用例计算出的偏差的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main solver function to compute irreducible bias for the given test cases.\n    \"\"\"\n\n    def calculate_pairwise_distances(coords: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates all unique pairwise distances for a set of atomic coordinates.\n        \"\"\"\n        num_atoms = coords.shape[0]\n        distances = []\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                dist = np.linalg.norm(coords[i] - coords[j])\n                distances.append(dist)\n        return np.array(distances)\n\n    def calculate_histogram(distances: np.ndarray, bins: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the histogram of distances based on given bin edges.\n        The interval is [left, right), matching the problem spec.\n        \"\"\"\n        hist, _ = np.histogram(distances, bins=bins)\n        return hist\n\n    def calculate_three_body_energy(coords: np.ndarray, sigma: float) -> float:\n        \"\"\"\n        Calculates the three-body energy for a configuration.\n        \"\"\"\n        num_atoms = coords.shape[0]\n        total_energy = 0.0\n\n        if num_atoms  3:\n            return 0.0\n\n        f = lambda r: np.exp(-(r / sigma)**2) if sigma > 0 else 0.0\n        p2 = lambda x: 0.5 * (3 * x**2 - 1)\n\n        # Iterate over all unique triples of atoms (i, j, k),\n        # with i being the central atom.\n        indices = range(num_atoms)\n        for i in indices:\n            # Create a list of neighbors for atom i\n            neighbors = list(indices)\n            neighbors.remove(i)\n            \n            # Iterate over all unique pairs of neighbors {j, k}\n            if len(neighbors)  2:\n                continue\n            \n            for j, k in combinations(neighbors, 2):\n                # Vectors from central atom i to j and k\n                v_ij = coords[j] - coords[i]\n                v_ik = coords[k] - coords[i]\n\n                # Distances\n                r_ij = np.linalg.norm(v_ij)\n                r_ik = np.linalg.norm(v_ik)\n\n                # Avoid division by zero if atoms are on top of each other\n                if r_ij == 0.0 or r_ik == 0.0:\n                    continue\n\n                # Cosine of the angle\n                cos_theta = np.dot(v_ij, v_ik) / (r_ij * r_ik)\n                # Clamp to handle potential floating point inaccuracies\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                \n                # Energy term for this triplet\n                term = f(r_ij) * f(r_ik) * p2(cos_theta)\n                total_energy += term\n\n        return total_energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]),\n            np.array([[0.0, 0.0, 0.0], [0.9, 0.0, 0.0], [0.9, 1.1, 0.0], [0.0, 1.1, 0.0]]),\n            np.array([0.0, 1.2, 2.0]),\n            1.0\n        ),\n        # Case 2\n        (\n            np.array([\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [0.5, np.sqrt(3)/2.0, 0.0],\n                [0.5, np.sqrt(3)/6.0, np.sqrt(6)/3.0]\n            ]),\n            np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]),\n            np.array([0.0, 2.0]),\n            1.0\n        ),\n        # Case 3\n        (\n            np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]),\n            np.array([[0.0, 0.0, 0.0], [0.9, 0.0, 0.0], [0.9, 1.1, 0.0], [0.0, 1.1, 0.0]]),\n            np.array([0.0, 1.2, 2.0]),\n            0.01\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        coords_a, coords_b, bins, sigma = case\n\n        # 1. Verify that histograms are identical (internal check).\n        distances_a = calculate_pairwise_distances(coords_a)\n        distances_b = calculate_pairwise_distances(coords_b)\n        hist_a = calculate_histogram(distances_a, bins)\n        hist_b = calculate_histogram(distances_b, bins)\n        assert np.array_equal(hist_a, hist_b), f\"Histograms do not match for case {len(results)+1}\"\n\n        # 2. Compute three-body energies.\n        energy_a = calculate_three_body_energy(coords_a, sigma)\n        energy_b = calculate_three_body_energy(coords_b, sigma)\n\n        # 3. Report the irreducible bias.\n        irreducible_bias = 0.5 * np.abs(energy_a - energy_b)\n        results.append(irreducible_bias)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "既然简单的描述符存在局限，我们需要一个能够有效捕捉角度信息的替代方案。矩张量势 (Moment Tensor Potentials, MTP) 提供了一种系统性的方法来构建包含高阶信息的线性模型。此练习  将引导你从原始原子坐标出发，一步步显式地构建 MTP 的旋转不变量基函数，从而揭开这些描述符如何将复杂的几何信息编码为适合线性拟合的向量表示。",
            "id": "3468372",
            "problem": "您需要实现一个针对原子局域环境的、级别为 $2$ 的最小化完全指定的矩张量势 (MTP)，显式地构建一个旋转不变基，为一组给定的环境构建设计矩阵，并求解一个线性最小二乘问题以得到能量系数。所有计算必须在三维笛卡尔坐标中进行，并且必须使用以下基本定义。\n\n定义与约束：\n- 一个局域环境是相对于中心原子的一组有限的邻近原子向量 $\\{\\mathbf{r}_j\\}_{j=1}^{N}$，位于 $\\mathbb{R}^3$ 中。距离单位为埃（ångström）。\n- 截断函数为 $f_{\\mathrm{cut}}(r) = \\tfrac{1}{2}\\big(\\cos(\\pi r / r_c) + 1\\big)$ (当 $r  r_c$ 时)，以及 $f_{\\mathrm{cut}}(r) = 0$ (当 $r \\ge r_c$ 时)，其中 $r = \\|\\mathbf{r}\\|$，$r_c$ 是截断半径（单位为埃）。\n- 径向基函数为 $R_1(r) = r_c - r$ 和 $R_2(r) = (r_c - r)^2$ (当 $r  r_c$ 时)，当 $r \\ge r_c$ 时，由于 $f_{\\mathrm{cut}}(r)=0$，它们的贡献隐式地为零。\n- 对于 $\\mu \\in \\{1,2\\}$，定义矩张量\n  $$M_{\\mu,0} = \\sum_{j=1}^{N} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j),$$\n  $$M_{\\mu,1} = \\sum_{j=1}^{N} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, \\mathbf{r}_j \\in \\mathbb{R}^3,$$\n  $$M_{\\mu,2} = \\sum_{j=1}^{N} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, \\mathbf{r}_j \\otimes \\mathbf{r}_j \\in \\mathbb{R}^{3 \\times 3}.$$\n- 通过以下缩并构建级别最高为 $2$ 的标量、旋转不变基函数：\n  1. $B_1 = M_{1,0}$,\n  2. $B_2 = M_{2,0}$,\n  3. $B_3 = \\mathrm{Tr}(M_{1,2})$,\n  4. $B_4 = \\mathrm{Tr}(M_{2,2})$,\n  5. $B_5 = M_{1,1} \\cdot M_{1,1}$,\n  6. $B_6 = M_{1,1} \\cdot M_{2,1}$,\n  7. $B_7 = M_{2,1} \\cdot M_{2,1}$,\n  其中 $\\mathrm{Tr}(\\cdot)$ 是矩阵的迹，$\\cdot$ 表示 $\\mathbb{R}^3$ 中的欧几里得点积。\n- 一个局域环境的能量被建模为这些不变量的线性组合：\n  $$E = \\sum_{k=1}^{7} c_k\\, B_k,$$\n  其中 $c_k$ 是常数系数（单位为电子伏特）。\n\n使用以下固定参数和数据：\n- 截断半径 $r_c = 4.5$ 埃（ångström）。\n- 基准真相系数（单位为电子伏特）：$c = \\big[c_1,\\dots,c_7\\big] = \\big[0.5, -0.3, 0.1, 0.05, 0.2, -0.15, 0.08\\big]$。\n- 包含 $9$ 个局域环境的测试套件，每个环境都以埃（ångström）为单位，由邻近原子向量 $\\mathbf{r}_j = (x_j, y_j, z_j)$ 的显式列表给出：\n  1. 环境 1：无邻近原子，\\{\\}。\n  2. 环境 2：\\{(2.0, 0.0, 0.0)\\}。\n  3. 环境 3：\\{(2.5, 0.0, 0.0),\\, (-2.5, 0.0, 0.0)\\}。\n  4. 环境 4：\\{(2.0, 0.0, 0.0),\\, (0.0, 2.0, 0.0)\\}。\n  5. 环境 5：\\{(1.8, 0.0, 0.0),\\, (0.0, 2.2, 0.0),\\, (0.0, 0.0, 2.5)\\}。\n  6. 环境 6：$xy$ 平面内半径为 $2.4$ 的等边三角形，即 \\{(2.4, 0.0, 0.0),\\, (-1.2, 2.4\\cdot \\sqrt{3}/2, 0.0),\\, (-1.2, -2.4\\cdot \\sqrt{3}/2, 0.0)\\}。\n  7. 环境 7：缩放到长度 $2.8$ 的正四面体方向，即 $\\{ \\tfrac{2.8}{\\sqrt{3}}(1,1,1),\\, \\tfrac{2.8}{\\sqrt{3}}(1,-1,-1),\\, \\tfrac{2.8}{\\sqrt{3}}(-1,1,-1),\\, \\tfrac{2.8}{\\sqrt{3}}(-1,-1,1)\\}$。\n  8. 环境 8：\\{(1.9, 0.5, 0.2),\\, (-0.3, 2.4, 0.1),\\, (0.4, -0.2, 2.6),\\, (-1.1, -0.8, 2.0)\\}。\n  9. 环境 9：截断范围外的单个邻近原子，\\{(5.0, 0.0, 0.0)\\}。\n\n需要实现的任务：\n1. 对每个环境，使用上述定义计算 $7$ 维不变量向量 $\\mathbf{B} = [B_1,\\dots,B_7]$。\n2. 构建设计矩阵 $X \\in \\mathbb{R}^{9 \\times 7}$，其行分别为环境 $1$到 $9$ 的不变量向量转置 $\\mathbf{B}^{\\top}$。\n3. 通过 $\\mathbf{y} = X\\, \\mathbf{c}$ 从基准真相系数生成观测能量 $\\mathbf{y} \\in \\mathbb{R}^{9}$。\n4. 求解线性最小二乘问题，从 $(X,\\mathbf{y})$ 中估计 $\\widehat{\\mathbf{c}}$，使其为 $\\|\\!|X \\mathbf{c} - \\mathbf{y}\\|\\!|_2^2$ 的最小值点。\n5. 使用 $\\widehat{\\mathbf{c}}$ 计算预测能量 $\\widehat{\\mathbf{y}} = X\\, \\widehat{\\mathbf{c}}$，并报告每个环境的绝对误差 $e_i = |y_i - \\widehat{y}_i|$。\n\n物理和数值单位：\n- 距离必须以埃（ångström）为单位处理；截断半径以埃为单位给出。\n- 能量和能量误差必须以电子伏特 (eV) 为单位，表示为十进制数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序列出 $9$ 个环境的绝对能量误差，即 $[e_1,e_2,\\dots,e_9]$，其中每个 $e_i$ 的单位为 $\\mathrm{eV}$。将每个 $e_i$ 四舍五入到至少 $10$ 位小数。\n\n覆盖设计：\n- 环境 1 测试没有邻近原子的边界情况（所有不变量为零，能量为 $0$）。\n- 环境 9 测试一个邻近原子在截断范围外的边界情况（所有不变量为零，能量为 $0$）。\n- 环境 3 和 4 测试对称性效应，这些效应会抵消 $M_{\\mu,1}$，同时保持更高阶矩非零。\n- 环境 6 和 7 测试非平凡的多邻近原子构型，这会导致不同的不变量值。",
            "solution": "该问题要求实现并验证一个简化的矩张量势 (MTP) 模型。该过程涉及为给定的一组原子环境计算旋转不变基函数，构建一个设计矩阵，并执行线性回归以验证模型的实现。\n\nMTP 框架的核心是通过一组在旋转下保持不变的描述符来表示一个局域原子环境（由中心原子周围的一组邻近原子向量 $\\{\\mathbf{r}_j\\}_{j=1}^{N}$ 定义）。这确保了如果整个系统被旋转，环境的预测能量不会改变，这是一项基本的物理要求。\n\n该过程可分为以下几个步骤：\n\n1.  **矩张量的计算**：\n    对于每个局域环境，我们首先计算矩张量，它们是环境中原子的加权和。权重包含一个平滑的截断函数 $f_{\\mathrm{cut}}(r)$ 和一组径向基函数 $R_{\\mu}(r)$。\n\n    - 截断函数 $f_{\\mathrm{cut}}(r) = \\tfrac{1}{2}\\big(\\cos(\\pi r / r_c) + 1\\big)$ (当 $r  r_c$) 否则为 $0$，确保当一个原子与中心原子的距离 $r$ 接近截断半径 $r_c = 4.5$ Å 时，其影响平滑地趋于零。这种局部性对于大规模模拟中的计算效率至关重要。\n\n    - 径向基函数 $R_1(r) = r_c - r$ 和 $R_2(r) = (r_c - r)^2$ 将距离信息编码到模型中。\n\n    对于每个径向基函数索引 $\\mu \\in \\{1,2\\}$，我们定义递增秩（级别）的矩张量：\n    - 级别 0（标量）：$M_{\\mu,0} = \\sum_{j} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)$\n    - 级别 1（向量）：$M_{\\mu,1} = \\sum_{j} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, \\mathbf{r}_j$\n    - 级别 2（矩阵）：$M_{\\mu,2} = \\sum_{j} f_{\\mathrm{cut}}(r_j)\\, R_{\\mu}(r_j)\\, (\\mathbf{r}_j \\otimes \\mathbf{r}_j)$\n\n    这里，$\\mathbf{r}_j \\otimes \\mathbf{r}_j$ 表示向量 $\\mathbf{r}_j$ 与其自身的外积，结果是一个 $3 \\times 3$ 矩阵。这些张量捕捉了关于原子邻域几何形状的日益复杂的信息。对于空环境或所有原子都在截断半径 $r_c$ 之外的环境，所有矩张量都为零。\n\n2.  **旋转不变基函数的构建**：\n    矩张量本身不是旋转不变的（例如，$M_{\\mu,1}$ 是一个向量，会随坐标系旋转）。为实现旋转不变性，我们通过缩并这些张量来形成标量。问题指定了七个这样的基函数 $B_k$：\n    - $B_1 = M_{1,0}$ 和 $B_2 = M_{2,0}$：它们本身就是标量，因此是固有不变的。它们代表了邻近原子的加权计数。\n    - $B_3 = \\mathrm{Tr}(M_{1,2})$ 和 $B_4 = \\mathrm{Tr}(M_{2,2})$：矩阵的迹 $\\mathrm{Tr}(\\cdot)$ 在旋转下是不变的。这些不变量与邻近原子平方距离的加权和有关。\n    - $B_5 = M_{1,1} \\cdot M_{1,1}$、$B_6 = M_{1,1} \\cdot M_{2,1}$ 和 $B_7 = M_{2,1} \\cdot M_{2,1}$：两个向量的点积结果是一个标量，它也是旋转不变的。这些不变量捕捉了关于环境不对称性的信息。对于具有高点群对称性（如以原点为中心的正四面体或等边三角形）的环境，向量矩 $M_{\\mu,1}$ 的和为零，导致这些不变量消失。\n\n    对于提供的 $9$ 个环境中的每一个，我们计算对应的不变量的 $7$ 维向量 $\\mathbf{B} = [B_1, B_2, B_3, B_4, B_5, B_6, B_7]$。\n\n3.  **设计矩阵和能量向量的构建**：\n    一个环境的能量被建模为基不变量的线性组合：$E = \\sum_{k=1}^{7} c_k\\, B_k$。这可以写成向量形式 $E = \\mathbf{B} \\cdot \\mathbf{c}$。\n    我们构建一个设计矩阵 $X \\in \\mathbb{R}^{9 \\times 7}$，其中第 $i$ 行是第 $i$ 个环境的不变量向量 $\\mathbf{B}^{(i)}$。\n    然后，使用基准真相系数 $\\mathbf{c} = [0.5, -0.3, 0.1, 0.05, 0.2, -0.15, 0.08]^{\\top}$ 生成所有 $9$ 个环境的“观测”能量。这是一个矩阵-向量乘积：$\\mathbf{y} = X\\,\\mathbf{c}$，其中 $\\mathbf{y} \\in \\mathbb{R}^9$ 是能量向量。\n\n4.  **线性最小二乘拟合和误差计算**：\n    该问题构成了一个“往返”测试。我们从一个已知的线性模型生成了数据 $(\\mathbf{X}, \\mathbf{y})$。下一步是求解线性最小二乘问题，找到使残差的平方范数 $\\|\\!|X \\widehat{\\mathbf{c}} - \\mathbf{y}\\|\\!|_2^2$ 最小化的系数 $\\widehat{\\mathbf{c}}$。\n    由于数据 $\\mathbf{y}$ 是无噪声的，并且是直接从 $X$ 生成的（即 $\\mathbf{y}$ 精确地位于 $X$ 的列空间中），最小二乘解将产生预测能量 $\\widehat{\\mathbf{y}} = X \\widehat{\\mathbf{c}}$，这与“观测”能量 $\\mathbf{y}$ 相同。因此，在浮点精度的限制内，每个环境的绝对误差 $e_i = |y_i - \\widehat{y}_i|$ 预期为零。非零误差将表明基函数计算的实现不正确。\n\n    算法流程如下：\n    - 使用标准的线性最小二乘求解器求解 $\\widehat{\\mathbf{c}}$，其中 `scipy.linalg.lstsq` 非常适用。\n    - 计算预测能量 $\\widehat{\\mathbf{y}} = X \\widehat{\\mathbf{c}}$。\n    - 计算绝对误差 $\\mathbf{e} = |\\mathbf{y} - \\widehat{\\mathbf{y}}|$。\n    - 按照要求的精度格式化并报告 $\\mathbf{e}$ 的分量。\n\n这个验证过程确保了复杂的基函数计算的正确性，这是在任何实际应用中使用 MTP 模型的基本先决条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lstsq\n\ndef solve():\n    \"\"\"\n    Implements a simplified Moment Tensor Potential (MTP) model,\n    calculates invariants for given environments, and verifies the\n    implementation via a linear least squares round-trip test.\n    \"\"\"\n\n    # Define the fixed parameters from the problem statement.\n    r_c = 4.5  # Cutoff radius in angstrom\n    c_true = np.array([0.5, -0.3, 0.1, 0.05, 0.2, -0.15, 0.08]) # Ground-truth coefficients in eV\n\n    # Define the test suite of 9 local environments.\n    sqrt3 = np.sqrt(3)\n    environments = [\n        [],  # Env 1: no neighbors\n        [(2.0, 0.0, 0.0)],  # Env 2\n        [(2.5, 0.0, 0.0), (-2.5, 0.0, 0.0)],  # Env 3\n        [(2.0, 0.0, 0.0), (0.0, 2.0, 0.0)],  # Env 4\n        [(1.8, 0.0, 0.0), (0.0, 2.2, 0.0), (0.0, 0.0, 2.5)],  # Env 5\n        [(2.4, 0.0, 0.0), (-1.2, 2.4 * sqrt3 / 2.0, 0.0), (-1.2, -2.4 * sqrt3 / 2.0, 0.0)],  # Env 6\n        [\n            (2.8 / sqrt3 * v[0], 2.8 / sqrt3 * v[1], 2.8 / sqrt3 * v[2])\n            for v in [(1, 1, 1), (1, -1, -1), (-1, 1, -1), (-1, -1, 1)]\n        ],  # Env 7\n        [(1.9, 0.5, 0.2), (-0.3, 2.4, 0.1), (0.4, -0.2, 2.6), (-1.1, -0.8, 2.0)],  # Env 8\n        [(5.0, 0.0, 0.0)],  # Env 9: out of cutoff\n    ]\n\n    def calculate_invariants(neighbor_vectors, rc):\n        \"\"\"\n        Calculates the 7 MTP basis invariants for a single environment.\n        \"\"\"\n        # Initialize moment tensors\n        m_10, m_20 = 0.0, 0.0\n        m_11, m_21 = np.zeros(3), np.zeros(3)\n        m_12, m_22 = np.zeros((3, 3)), np.zeros((3, 3))\n\n        for vec in neighbor_vectors:\n            r_j = np.array(vec)\n            r = np.linalg.norm(r_j)\n\n            if r  rc and r > 1e-9:  # Check cutoff and avoid division by zero\n                # Calculate cutoff function and radial basis functions\n                f_cut = 0.5 * (np.cos(np.pi * r / rc) + 1.0)\n                r1_val = rc - r\n                r2_val = (rc - r) ** 2\n                \n                # Pre-calculate weighted radial terms\n                w1 = f_cut * r1_val\n                w2 = f_cut * r2_val\n                \n                # Accumulate moment tensors\n                m_10 += w1\n                m_20 += w2\n                \n                m_11 += w1 * r_j\n                m_21 += w2 * r_j\n                \n                m_12 += w1 * np.outer(r_j, r_j)\n                m_22 += w2 * np.outer(r_j, r_j)\n\n        # Construct the 7 scalar invariants B_k\n        b_vec = np.zeros(7)\n        b_vec[0] = m_10                # B1 = M_1,0\n        b_vec[1] = m_20                # B2 = M_2,0\n        b_vec[2] = np.trace(m_12)      # B3 = Tr(M_1,2)\n        b_vec[3] = np.trace(m_22)      # B4 = Tr(M_2,2)\n        b_vec[4] = np.dot(m_11, m_11)  # B5 = M_1,1 . M_1,1\n        b_vec[5] = np.dot(m_11, m_21)  # B6 = M_1,1 . M_2,1\n        b_vec[6] = np.dot(m_21, m_21)  # B7 = M_2,1 . M_2,1\n        \n        return b_vec\n\n    # 1.  2. Compute invariants and assemble the design matrix X\n    num_environments = len(environments)\n    num_invariants = 7\n    X = np.zeros((num_environments, num_invariants))\n    for i, env in enumerate(environments):\n        X[i, :] = calculate_invariants(env, r_c)\n\n    # 3. Generate the \"observed\" energies y\n    y = X @ c_true\n\n    # 4. Solve the linear least squares problem for c_hat\n    c_hat, residuals, rank, s = lstsq(X, y)\n\n    # 5. Compute predicted energies and absolute errors\n    y_hat = X @ c_hat\n    errors = np.abs(y - y_hat)\n\n    # Format the final output string\n    # Using high precision formatting to show the errors are numerically zero\n    error_strs = [f\"{err:.17f}\" for err in errors]\n    print(f\"[{','.join(error_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了线性模型，核方法是构建机器学习势的另一大主流框架，其中高斯过程 (Gaussian Process, GP) 回归与原子位置光滑重叠 (Smooth Overlap of Atomic Positions, SOAP) 核的结合尤为成功。该方法的关键优势之一是能够以解析方式计算与能量协变的力。本练习  将带你亲手实现一个简化的 SOAP/GP 模型，不仅用于预测新环境的能量，更重要的是通过对核函数求导来计算原子受力，这是现代机器学习势能模型的核心技术之一。",
            "id": "3468379",
            "problem": "给定一个包含三个局部原子环境的玩具数据集，您的任务是使用高斯过程 (GP) 和原子位置光滑重叠 (SOAP) 核函数对其位点能量进行建模，然后通过对核函数关于探针原子坐标进行微分，计算几个查询环境中探针原子的预测平均能量及相应的力。设定为单物种、有限范围相互作用，且 SOAP 描述符被简化为在固定的一维网格上离散化的径向密度。模型和计算必须使用与计算材料科学相关的、科学上合理且物理上可信的术语来表达。\n\n使用的定义和模型假设：\n- 原子位置光滑重叠 (SOAP) 描述符近似为径向邻居密度。对于位于位置 $\\mathbf{r}_{\\mathrm{p}} \\in \\mathbb{R}^{3}$ 的探针原子和位于位置 $\\{\\mathbf{r}_{j}\\}_{j=1}^{N_{\\mathrm{n}}}$ 的邻居原子，定义径向距离 $d_{j} = \\|\\mathbf{r}_{j} - \\mathbf{r}_{\\mathrm{p}}\\|$，并在径向网格 $\\{r_{g}\\}_{g=1}^{G}$（网格值见下文）上评估离散化密度。在 $r_{g}$ 处的密度贡献被建模为以每个 $d_{j}$ 为中心的高斯函数之和，并由一个光滑截断函数进行调制，高斯宽度 $\\sigma$ 和截断半径 $r_{\\mathrm{c}}$ 的值见下文。这为每个环境生成一个描述符向量 $\\mathbf{x} \\in \\mathbb{R}^{G}$。假设通过使用相对坐标 $\\mathbf{r}_{j} - \\mathbf{r}_{\\mathrm{p}}$ 来捕捉平移不变性。\n- 两个环境（其描述符分别为 $\\mathbf{x}, \\mathbf{y} \\in \\mathbb{R}^{G}$）之间的 SOAP 核函数是归一化点积的正整数 $\\zeta$ 次幂：$k(\\mathbf{x}, \\mathbf{y}) = s(\\mathbf{x}, \\mathbf{y})^{\\zeta}$，其中 $s(\\mathbf{x}, \\mathbf{y})$ 是余弦相似度 $s(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathbf{x} \\cdot \\mathbf{y}}{\\|\\mathbf{x}\\| \\, \\|\\mathbf{y}\\|}$。\n- 使用高斯过程 (GP) 回归对位点能量进行建模，训练输出为 $\\mathbf{y}_{\\text{train}} \\in \\mathbb{R}^{N}$，核矩阵 $K \\in \\mathbb{R}^{N \\times N}$ 由训练环境上的 SOAP 核函数构建。对角线上添加方差为 $\\sigma_{\\mathrm{n}}^{2}$ 的同方差观测噪声。对于查询描述符 $\\mathbf{x}_{*}$，GP 的预测均值为 $m(\\mathbf{x}_{*}) = \\mathbf{k}_{*}^{\\top} \\boldsymbol{\\alpha}$，其中 $\\mathbf{k}_{*} \\in \\mathbb{R}^{N}$ 的元素为 $k(\\mathbf{x}_{*}, \\mathbf{x}_{i})$，且 $\\boldsymbol{\\alpha} = (K + \\sigma_{\\mathrm{n}}^{2} I)^{-1} \\mathbf{y}_{\\text{train}}$。\n- 探针原子上的力是 GP 预测平均能量相对于探针原子坐标的负梯度，$\\mathbf{F} = - \\nabla_{\\mathbf{r}_{\\mathrm{p}}} m(\\mathbf{x}_{*})$。该梯度通过链式法则以及描述符 $\\mathbf{x}_{*}$ 对原子距离的依赖关系，对核函数 $k(\\mathbf{x}_{*}, \\mathbf{x}_{i})$ 关于 $\\mathbf{r}_{\\mathrm{p}}$ 进行微分来计算。\n\n参数（请精确使用这些值和单位）：\n- 径向网格（单位：埃, Å）：$\\{ r_{g} \\}_{g=1}^{G} = \\{ 0.5, 1.0, 1.5, 2.0, 2.5 \\}$，因此 $G = 5$。\n- 高斯宽度（单位：Å）：$\\sigma = 0.25$。\n- 截断半径（单位：Å）：$r_{\\mathrm{c}} = 3.0$。\n- SOAP 核指数：$\\zeta = 2$。\n- GP 观测噪声标准差（单位：电子伏特, eV）：$\\sigma_{\\mathrm{n}} = 0.05$。\n\n包含三个环境的训练集（坐标单位：Å，能量单位：eV）：\n- 环境 1：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.0, 0.0, 0.0)$、$(-1.0, 0.0, 0.0)$、$(0.0, 1.5, 0.0)$，能量 $y_{1} = -0.80$。\n- 环境 2：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.3, 0.0, 0.0)$、$(0.0, 1.3, 0.0)$，能量 $y_{2} = -0.65$。\n- 环境 3：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(2.2, 0.0, 0.0)$、$(0.0, 2.0, 0.0)$、$(1.5, 1.5, 0.0)$，能量 $y_{3} = -1.10$。\n\n查询环境测试套件（坐标单位：Å）：\n- 情况 A（一般情况）：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.2, 0.0, 0.0)$、$(0.0, 1.0, 0.0)$、$(-1.4, 0.0, 0.0)$。\n- 情况 B（接近截断边界）：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(2.95, 0.0, 0.0)$、$(0.0, 2.80, 0.0)$。\n- 情况 C（力对称性边界情况）：探针位于 $\\mathbf{r}_{\\mathrm{p}} = (0.0, 0.0, 0.0)$，邻居位于 $(1.0, 0.0, 0.0)$、$(-1.0, 0.0, 0.0)$。\n\n您的程序必须：\n- 使用上述模型假设为所有训练和查询环境构建简化的 SOAP 径向描述符。\n- 使用给定的指数 $\\zeta$ 构建训练环境上的 SOAP 核矩阵，并使用带有观测噪声 $\\sigma_{\\mathrm{n}}$ 的 GP 法则计算 $\\boldsymbol{\\alpha}$。\n- 对于每个查询环境，通过对核函数关于探针原子坐标进行微分，计算 GP 预测平均能量 $m(\\mathbf{x}_{*})$（单位：eV）和探针原子上的力矢量 $\\mathbf{F}$（单位：eV/Å）。\n- 使用一个光滑截断函数，该函数在距离严格小于 $r_{\\mathrm{c}}$ 时可微，在超出 $r_{\\mathrm{c}}$ 时为零；并使用以每个邻居距离为中心的高斯弥散作用于径向网格。\n- 确保数值鲁棒性，对于在梯度计算中 $d_{j} = 0$ 时可能发生的任何除以零的情况，应使用有数学依据的极限过程或不改变物理解释的小正则化方法。\n\n不涉及角度单位。距离必须以 Å 为单位处理，能量以 eV 为单位处理。力必须以 eV/Å 表示。最终输出必须是实值浮点数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由三个子列表组成的列表，每个子列表对应一个查询情况。每个子列表必须按 $[ m, F_{x}, F_{y}, F_{z} ]$ 的顺序列出四个浮点数，其中 $m$ 是预测平均能量（eV），$(F_{x}, F_{y}, F_{z})$ 是力的分量（eV/Å）。整个输出必须是一个用方括号括起来的逗号分隔列表，例如：$[ [ m_{A}, F_{x,A}, F_{y,A}, F_{z,A} ], [ m_{B}, F_{x,B}, F_{y,B}, F_{z,B} ], [ m_{C}, F_{x,C}, F_{y,C}, F_{z,C} ] ]$。\n\n程序必须完全自包含，无需用户输入，并严格遵守指定的执行环境。提供科学上合理的计算，并确保为每个测试用例返回的数值是浮点数。",
            "solution": "该问题要求使用基于简化的原子位置光滑重叠 (SOAP) 核函数的高斯过程 (GP) 回归模型来计算位点能量和原子间力。求解过程分为三个主要阶段：首先，通过计算描述符和相关的核矩阵来构建训练模型；其次，推导查询原子的预测能量和力的解析表达式；最后，将这些公式应用于指定的测试用例。\n\n### 1. 模型构建\n\n该模型的核心是通过描述符向量来表示局部原子环境，该向量作为核函数的输入。\n\n#### 1.1. 径向密度描述符\n\n对于一个以探针原子为中心（位置为 $\\mathbf{r}_{\\mathrm{p}}$）、拥有 $N_{\\mathrm{n}}$ 个邻居原子（位置为 $\\{\\mathbf{r}_{j}\\}$）的给定原子环境，我们首先计算径向距离集合 $d_{j} = \\|\\mathbf{r}_{j} - \\mathbf{r}_{\\mathrm{p}}\\|$。\n\n采用光滑截断函数 $f_c(d)$ 来确保相互作用在有限的截断半径 $r_{\\mathrm{c}} = 3.0 \\, \\text{Å}$ 处平滑衰减至零。一个在 $d=0$ 和 $d=r_{\\mathrm{c}}$ 处均连续可微（$C^1$）的合适的 $f_c(d)$ 选择是基于余弦的函数：\n$$\nf_c(d) = \\begin{cases} \\frac{1}{2} \\left[ \\cos\\left(\\frac{\\pi d}{r_{\\mathrm{c}}}\\right) + 1 \\right]  \\text{if } d \\le r_{\\mathrm{c}} \\\\ 0  \\text{if } d  r_{\\mathrm{c}} \\end{cases}\n$$\n计算力时需要该函数的导数：\n$$\nf_c'(d) = \\begin{cases} -\\frac{\\pi}{2 r_{\\mathrm{c}}} \\sin\\left(\\frac{\\pi d}{r_{\\mathrm{c}}}\\right)  \\text{if } d \\le r_{\\mathrm{c}} \\\\ 0  \\text{if } d  r_{\\mathrm{c}} \\end{cases}\n$$\n\n简化的 SOAP 描述符是一个向量 $\\mathbf{x} \\in \\mathbb{R}^{G}$，表示离散化的径向密度。每个分量 $x_g$ 是密度在网格点 $r_g$（来自集合 $\\{0.5, 1.0, 1.5, 2.0, 2.5\\} \\, \\text{Å}$）上的值。该密度通过对以每个邻居距离 $d_j$ 为中心的高斯函数求和构建，每个高斯函数都由截断函数加权。高斯宽度为 $\\sigma = 0.25 \\, \\text{Å}$，描述符的第 $g$ 个分量为：\n$$\nx_g = \\sum_{j=1}^{N_{\\mathrm{n}}} f_c(d_j) \\exp\\left(-\\frac{(r_g - d_j)^2}{2\\sigma^2}\\right)\n$$\n\n#### 1.2. SOAP 核函数\n\n两个原子环境（由其描述符 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 表示）之间的相似性通过 SOAP 核函数来衡量。我们使用基于余弦相似度 $s(\\mathbf{x}_i, \\mathbf{x}_j)$ 的归一化多项式核：\n$$\nk(\\mathbf{x}_i, \\mathbf{x}_j) = s(\\mathbf{x}_i, \\mathbf{x}_j)^{\\zeta} = \\left( \\frac{\\mathbf{x}_i \\cdot \\mathbf{x}_j}{\\|\\mathbf{x}_i\\| \\|\\mathbf{x}_j\\|} \\right)^{\\zeta}\n$$\n其中指数给定为 $\\zeta = 2$。归一化确保了核函数对相同邻居的排列具有不变性，并提供了一个鲁棒的相似性度量。为了数值稳定性，如果描述符的范数 $\\|\\mathbf{x}\\|$ 为零（即所有邻居都在截断半径之外），则核函数值定义为 $0$。\n\n#### 1.3. 高斯过程回归\n\n位点能量 $E$ 被建模为一个高斯过程，$E(\\mathbf{x}) \\sim \\mathcal{GP}(m(\\mathbf{x}), k(\\mathbf{x}, \\mathbf{x}'))$。给定一个包含 $N=3$ 个环境的训练集，其描述符为 $\\{\\mathbf{x}_i\\}_{i=1}^N$，对应的能量为 $\\mathbf{y}_{\\text{train}} = [y_1, y_2, y_3]^{\\top}$，对于一个描述符为 $\\mathbf{x}_{*}$ 的新查询环境，GP 的预测平均能量为：\n$$\nm(\\mathbf{x}_{*}) = \\mathbf{k}_{*}^{\\top} \\boldsymbol{\\alpha}\n$$\n其中 $\\mathbf{k}_{*} \\in \\mathbb{R}^{N}$ 是查询环境与训练环境之间的核相似度向量，其元素为 $k_{*i} = k(\\mathbf{x}_{*}, \\mathbf{x}_i)$。权重向量 $\\boldsymbol{\\alpha} \\in \\mathbb{R}^{N}$ 通过求解以下线性系统获得：\n$$\n\\boldsymbol{\\alpha} = (K + \\sigma_{\\mathrm{n}}^{2} I)^{-1} \\mathbf{y}_{\\text{train}}\n$$\n这里，$K$ 是训练数据的 $N \\times N$ Gram 矩阵，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$，$I$ 是单位矩阵，$\\sigma_{\\mathrm{n}}^{2}$ 是观测噪声的方差，其中 $\\sigma_{\\mathrm{n}} = 0.05 \\, \\text{eV}$。$\\sigma_{\\mathrm{n}}^{2}I$ 项对矩阵进行正则化，确保其良态且可逆。\n\n### 2. 力的推导\n\n探针原子上的力是预测平均能量相对于探针原子位置 $\\mathbf{r}_{\\mathrm{p}}$ 的负梯度：\n$$\n\\mathbf{F} = - \\nabla_{\\mathbf{r}_{\\mathrm{p}}} m(\\mathbf{x}_{*}) = - \\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\left( \\sum_{i=1}^{N} \\alpha_i k(\\mathbf{x}_{*}, \\mathbf{x}_i) \\right) = - \\sum_{i=1}^{N} \\alpha_i \\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i)\n$$\n力计算的核心在于计算核函数 $k(\\mathbf{x}_{*}, \\mathbf{x}_i)$ 的梯度 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i)$。由于只有查询描述符 $\\mathbf{x}_{*}$ 依赖于 $\\mathbf{r}_{\\mathrm{p}}$，我们应用链式法则。\n\n令 $s_{*} = s(\\mathbf{x}_{*}, \\mathbf{x}_i)$。核函数的梯度为：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i) = \\frac{\\partial k}{\\partial s_{*}} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} s_{*} = \\zeta s_{*}^{\\zeta-1} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} s_{*}\n$$\n接下来，我们求相似度 $s_{*} = \\frac{\\mathbf{x}_{*} \\cdot \\mathbf{x}_i}{\\|\\mathbf{x}_{*}\\| \\|\\mathbf{x}_i\\|}$ 的梯度。使用归一化向量 $\\hat{\\mathbf{x}}_{*} = \\mathbf{x}_{*}/\\|\\mathbf{x}_{*}\\|$ 和 $\\hat{\\mathbf{x}}_i = \\mathbf{x}_i/\\|\\mathbf{x}_i\\|$，我们有 $s_{*} = \\hat{\\mathbf{x}}_{*} \\cdot \\hat{\\mathbf{x}}_i$。其梯度可以优雅地表示为：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{p}}} s_{*} = \\frac{1}{\\|\\mathbf{x}_{*}\\|} (\\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\mathbf{x}_{*})^{\\top} (\\hat{\\mathbf{x}}_i - s_{*} \\hat{\\mathbf{x}}_{*})\n$$\n其中 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\mathbf{x}_{*}$ 是一个 $G \\times 3$ 的雅可比矩阵，其 $(g, \\beta)$ 元素为 $\\frac{\\partial x_{*g}}{\\partial r_{\\mathrm{p},\\beta}}$，$\\beta \\in \\{x, y, z\\}$。\n\n最后一步是确定这个雅可比矩阵。描述符分量 $x_{*g}$ 对 $\\mathbf{r}_{\\mathrm{p}}$ 的导数通过对查询环境中每个邻居 $j$ 的贡献求和得到：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{p}}} x_{*g} = \\sum_{j} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\left[ f_c(d_j) \\exp\\left(-\\frac{(r_g - d_j)^2}{2\\sigma^2}\\right) \\right]\n$$\n再次应用链式法则，$\\nabla_{\\mathbf{r}_{\\mathrm{p}}} (\\cdot) = \\frac{\\partial (\\cdot)}{\\partial d_j} \\nabla_{\\mathbf{r}_{\\mathrm{p}}} d_j$。距离的梯度为 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} d_j = \\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\|\\mathbf{r}_j - \\mathbf{r}_{\\mathrm{p}}\\| = -\\frac{\\mathbf{r}_j - \\mathbf{r}_{\\mathrm{p}}}{d_j}$。关于距离 $d_j$ 的导数为：\n$$\n\\frac{\\partial}{\\partial d_j} \\left[ f_c(d_j) e^{-\\frac{(r_g-d_j)^2}{2\\sigma^2}} \\right] = \\left( f_c'(d_j) + f_c(d_j) \\frac{r_g-d_j}{\\sigma^2} \\right) e^{-\\frac{(r_g-d_j)^2}{2\\sigma^2}}\n$$\n通过组合这些分量，我们可以计算每个核元素的梯度，从而得到总力矢量 $\\mathbf{F}$。在涉及 $d_j$ 或 $\\|\\mathbf{x}\\|$ 的分母中添加一个很小的 epsilon，以防止在原子重叠或描述符为空的罕见情况下出现除以零的问题，从而确保数值稳定性。\n\n### 3. 实现总结\n\n算法流程如下：\n1.  **训练阶段**：\n    a. 对于 $N=3$ 个训练环境中的每一个，计算 $G=5$ 维的描述符向量 $\\mathbf{x}_i$。\n    b. 构建 $3 \\times 3$ 的核矩阵 $K$，其中 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$。\n    c. 将噪声项 $\\sigma_{\\mathrm{n}}^{2} = (0.05)^2$ 添加到 $K$ 的对角线上。\n    d. 求解线性系统 $(K + \\sigma_{\\mathrm{n}}^{2}I)\\boldsymbol{\\alpha} = \\mathbf{y}_{\\text{train}}$ 以获得权重 $\\boldsymbol{\\alpha}$。\n\n2.  **预测阶段**：\n    a. 对于三个查询环境中的每一个：\n    b. 计算查询描述符 $\\mathbf{x}_{*}$ 及其 $G \\times 3$ 的雅可比矩阵 $\\nabla_{\\mathbf{r}_{\\mathrm{p}}} \\mathbf{x}_{*}$。\n    c. 计算预测平均能量 $m(\\mathbf{x}_{*}) = \\sum_{i=1}^{N} \\alpha_i k(\\mathbf{x}_{*}, \\mathbf{x}_i)$。\n    d. 通过对加权梯度求和 $-\\sum_{i=1}^{N} \\alpha_i \\nabla_{\\mathbf{r}_{\\mathrm{p}}} k(\\mathbf{x}_{*}, \\mathbf{x}_i)$ 来计算力矢量 $\\mathbf{F}$，使用推导出的解析表达式。\n    e. 存储每个情况的结果 $[m, F_x, F_y, F_z]$。\n\n此过程被实现以生成指定查询用例的最终数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of predicting site energies and atomic forces using a \n    Gaussian Process model with a simplified SOAP kernel.\n    \"\"\"\n    \n    # --- Parameters (as defined in the problem) ---\n    R_GRID = np.array([0.5, 1.0, 1.5, 2.0, 2.5]) # Radial grid, Å\n    G_DIM = len(R_GRID)                         # Dimension of descriptor\n    SIGMA = 0.25                                # Gaussian width, Å\n    R_CUT = 3.0                                 # Cutoff radius, Å\n    ZETA = 2                                    # SOAP kernel exponent\n    SIGMA_N = 0.05                              # GP observation noise, eV\n    EPS = 1e-12                                 # Small epsilon for numerical stability\n\n    # --- Training Data ---\n    train_environments = [\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.0, 0.0, 0.0]), np.array([-1.0, 0.0, 0.0]), np.array([0.0, 1.5, 0.0])], 'energy': -0.80},\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.3, 0.0, 0.0]), np.array([0.0, 1.3, 0.0])], 'energy': -0.65},\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([2.2, 0.0, 0.0]), np.array([0.0, 2.0, 0.0]), np.array([1.5, 1.5, 0.0])], 'energy': -1.10}\n    ]\n    N_TRAIN = len(train_environments)\n    Y_TRAIN = np.array([env['energy'] for env in train_environments])\n\n    # --- Test (Query) Data ---\n    query_environments = [\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.2, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]), np.array([-1.4, 0.0, 0.0])]}, # Case A\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([2.95, 0.0, 0.0]), np.array([0.0, 2.80, 0.0])]}, # Case B\n        {'probe': np.array([0.0, 0.0, 0.0]), 'neighbors': [np.array([1.0, 0.0, 0.0]), np.array([-1.0, 0.0, 0.0])]}, # Case C\n    ]\n\n    # --- Helper Functions ---\n\n    def cutoff_f(d, r_c):\n        \"\"\"Smooth cosine cutoff function.\"\"\"\n        return np.where(d = r_c, 0.5 * (np.cos(np.pi * d / r_c) + 1.0), 0.0)\n\n    def cutoff_f_prime(d, r_c):\n        \"\"\"Derivative of the smooth cosine cutoff function.\"\"\"\n        return np.where(d = r_c, -0.5 * (np.pi / r_c) * np.sin(np.pi * d / r_c), 0.0)\n\n    def compute_descriptor_and_grad(probe_pos, neighbors_pos, r_grid, sigma, r_c):\n        \"\"\"\n        Computes the radial descriptor and its gradient w.r.t. probe_pos.\n        Returns:\n            x (np.ndarray): Descriptor vector of shape (G_DIM,).\n            dx_drp (np.ndarray): Jacobian matrix of shape (G_DIM, 3).\n        \"\"\"\n        x = np.zeros(G_DIM)\n        dx_drp = np.zeros((G_DIM, 3))\n\n        for r_j in neighbors_pos:\n            vec_jp = r_j - probe_pos\n            d_j = np.linalg.norm(vec_jp)\n            \n            if d_j > r_c or d_j  EPS:\n                continue\n\n            # Unit vector from probe to neighbor\n            d_hat_j = vec_jp / (d_j + EPS)\n\n            # --- Density contribution from neighbor j ---\n            f_c_val = cutoff_f(d_j, r_c)\n            exp_term = np.exp(-(r_grid - d_j)**2 / (2 * sigma**2))\n            rho_j = f_c_val * exp_term\n            x += rho_j\n\n            # --- Gradient contribution from neighbor j ---\n            d_rho_j_dd_j = (cutoff_f_prime(d_j, r_c) + f_c_val * (r_grid - d_j) / sigma**2) * exp_term\n            \n            # Chain rule: grad_rp(rho) = (d(rho)/d(d_j)) * grad_rp(d_j)\n            # grad_rp(d_j) = -vec_jp / d_j = -d_hat_j\n            grad_rp_rho_j = -np.outer(d_rho_j_dd_j, d_hat_j)\n            dx_drp += grad_rp_rho_j\n\n        return x, dx_drp\n\n    def soap_kernel(x1, x2, zeta):\n        \"\"\"Computes the SOAP kernel between two descriptors.\"\"\"\n        norm1 = np.linalg.norm(x1)\n        norm2 = np.linalg.norm(x2)\n        \n        if norm1  EPS or norm2  EPS:\n            return 0.0\n            \n        similarity = np.dot(x1, x2) / (norm1 * norm2)\n        # Clip similarity to avoid numerical issues with arccos domain for debug, or for powers\n        similarity = np.clip(similarity, -1.0, 1.0)\n        return similarity**zeta\n\n    # --- 1. Training Phase ---\n    \n    train_descriptors = []\n    for env in train_environments:\n        desc, _ = compute_descriptor_and_grad(env['probe'], env['neighbors'], R_GRID, SIGMA, R_CUT)\n        train_descriptors.append(desc)\n\n    K = np.zeros((N_TRAIN, N_TRAIN))\n    for i in range(N_TRAIN):\n        for j in range(N_TRAIN):\n            K[i, j] = soap_kernel(train_descriptors[i], train_descriptors[j], ZETA)\n            \n    K_reg = K + np.eye(N_TRAIN) * (SIGMA_N**2)\n\n    # Solve for alpha weights\n    alpha = np.linalg.solve(K_reg, Y_TRAIN)\n    \n    # --- 2. Prediction Phase ---\n    \n    results = []\n    for query_env in query_environments:\n        # a. Compute query descriptor and its gradient\n        x_star, dx_star_drp = compute_descriptor_and_grad(query_env['probe'], query_env['neighbors'], R_GRID, SIGMA, R_CUT)\n\n        # b. Compute predictive mean energy\n        k_star = np.array([soap_kernel(x_star, x_i, ZETA) for x_i in train_descriptors])\n        energy = np.dot(k_star, alpha)\n\n        # c. Compute force\n        force = np.zeros(3)\n        norm_x_star = np.linalg.norm(x_star)\n        \n        if norm_x_star  EPS:\n            results.append([energy, 0.0, 0.0, 0.0])\n            continue\n\n        x_hat_star = x_star / norm_x_star\n        \n        for i in range(N_TRAIN):\n            x_i = train_descriptors[i]\n            norm_x_i = np.linalg.norm(x_i)\n            \n            if norm_x_i  EPS:\n                continue\n\n            x_hat_i = x_i / norm_x_i\n            s = np.dot(x_hat_star, x_hat_i)\n            s = np.clip(s, -1.0, 1.0)\n\n            # Gradient of similarity: grad_s = (1/norm_x_star) * (dx_star_drp)^T * (x_hat_i - s * x_hat_star)\n            grad_s = (1.0 / norm_x_star) * dx_star_drp.T @ (x_hat_i - s * x_hat_star)\n            \n            # Gradient of kernel: grad_k = zeta * s^(zeta-1) * grad_s\n            # Handle s=0 case for zeta-1 > 0, although here zeta=2, so it's fine.\n            if abs(s)  EPS and ZETA > 1:\n                grad_k = np.zeros(3)\n            else:\n                grad_k = ZETA * (s**(ZETA - 1)) * grad_s\n            \n            force -= alpha[i] * grad_k\n            \n        results.append([energy] + force.tolist())\n\n    # --- Final Output Formatting ---\n    sublist_strs = [f\"[{','.join(f'{val:.8f}' for val in sublist)}]\" for sublist in results]\n    final_output = f\"[{','.join(sublist_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}