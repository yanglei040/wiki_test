{
    "hands_on_practices": [
        {
            "introduction": "高通量材料筛选的第一步是界定需要探索的广阔化学空间。本练习提供了一种基础且可动手实践的方法，用于估算给定晶体原型和元素取代集所能产生的化学修饰结构的数量。通过将一个复杂的群论问题简化为一个易于处理的组合问题，您将掌握构建大型材料数据库时估算材料空间规模的核心技能。",
            "id": "3456708",
            "problem": "在计算材料科学中，给定用于高通量材料筛选的原型晶体结构和允许的元素替换集。目标是算法性地估计在空间群对称性下的不同修饰结构的数量，假设在一个自动化工作流程中，Wyckoff 轨道内的对称等效位置被视为不可区分的。推导必须从群作用的数学概念和轨道的定义开始，而不使用现成的枚举公式。\n\n使用的基本原理：\n- 空间群通过排列对称等效位点来作用于 Wyckoff 位置集。\n- 将元素分配到位点可以看作是此作用下的一个标记。\n- 在对称性下的不同修饰结构对应于群作用下标记的轨道。\n\n情景：\n- 考虑原型集 $P=\\{\\text{perovskite},\\text{spinel}\\}$。\n- 对于空间群为 $\\mathrm{Pm}\\bar{3}\\mathrm{m}$ 的 $ABO_3$ 型 perovskite，假设 $A$、$B$ 和 $O$ 亚晶格的 Wyckoff 轨道多重度分别为 $n_A=1$、$n_B=1$、$n_O=3$。\n- 对于空间群为 $\\mathrm{Fd}\\bar{3}\\mathrm{m}$ 的 $AB_2O_4$ 型 spinel，假设 $A$、$B$ 和 $O$ 亚晶格的 Wyckoff 轨道多重度分别为 $n_A=8$、$n_B=16$、$n_O=32$。\n- 对于每个亚晶格 $X\\in\\{A,B,O\\}$，给定一个允许的元素替换集 $E_X$，其基数为 $m_X=|E_X|$，这意味着有 $m_X$ 种不同的元素类型可以占据亚晶格 $X$ 上的位点。\n\n假设：\n- 在每个 Wyckoff 轨道内，空间群对称性使得各位置不可区分，因此仅在轨道内排列不同的标记被认为是等效的。\n- 不同亚晶格之间的替换被独立处理，除了轨道多重度 $n_X$ 外，没有全局的成分约束。\n\n任务：\n- 从提供的基本原理出发，构建一个有原则的算法，对于给定的原型和 $m_A$、$m_B$、$m_O$，通过计算每个轨道上的不等效标记并对亚晶格进行汇总，来估计在空间群对称性下的不同修饰结构集的基数。\n- 将其实现为一个完整的、可运行的程序，将该算法应用于下面的测试套件，并以指定格式输出结果。\n\n测试套件：\n- 案例 $1$：原型 $=$ perovskite, $m_A=2$, $m_B=3$, $m_O=2$。\n- 案例 $2$：原型 $=$ perovskite, $m_A=1$, $m_B=1$, $m_O=1$。\n- 案例 $3$：原型 $=$ perovskite, $m_A=5$, $m_B=4$, $m_O=3$。\n- 案例 $4$：原型 $=$ spinel, $m_A=2$, $m_B=2$, $m_O=1$。\n- 案例 $5$：原型 $=$ spinel, $m_A=2$, $m_B=3$, $m_O=2$。\n\n答案规格：\n- 对于每个案例，答案是一个整数，给出在空间群对称性下估计的不同修饰结构的数量。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots]$。",
            "solution": "问题陈述经评估有效。它在科学上基于计算材料科学的原理，特别是与晶体学对称性和高通量筛选相关的原理。问题定义明确，所有必要的参数和假设都清晰界定，从而导出一个唯一且有意义的解。问题是客观的，没有歧义。\n\n任务是推导并实现一个算法，用于在给定原型结构、其 Wyckoff 轨道多重度以及每个亚晶格允许的元素替换集的情况下，计算不同修饰晶体结构的数量。推导必须植根于基本原理。\n\n不同修饰结构的总数 $N_{total}$ 是每个独立亚晶格的可能唯一修饰数量的乘积。这是基于不同亚晶格（$A$、$B$ 和 $O$）之间的替换被独立处理的假设。\n$$N_{total} = N_A \\cdot N_B \\cdot N_O$$\n其中 $N_X$ 是亚晶格 $X$ 的不同修饰的数量。\n\n我们现在必须推导出 $N_X$ 的公式。亚晶格 $X$ 由包含 $n_X$ 个位点的单个 Wyckoff 轨道定义。我们给定一个包含 $m_X$ 种不同元素类型的集合，这些元素可以放置在这些位点上。关键假设是“在每个 Wyckoff 轨道内，空间群对称性使得各位置不可区分，因此仅在轨道内排列不同的标记被认为是等效的”。\n\n这个假设极大地简化了问题。它意味着我们无需考虑空间群对位点集的具体作用，而是假设轨道中 $n_X$ 个位点上元素的任何排列都会产生相同、不可区分的结构。这将问题从一个复杂的群论枚举问题（例如需要对特定空间群使用 Burnside 引理或 Pólya 枚举定理的问题）简化为一个基本的组合问题。\n\n我们实质上是在尝试确定从一个包含 $m_X$ 种元素类型的集合中选择 $n_X$ 个元素的方法数，允许重复选择，且选择的顺序无关紧要。这是一个从 $m_X$ 个项目中计算大小为 $n_X$ 的多重集的问题。\n\n设 $m_X$ 种元素类型为 $E_1, E_2, \\dots, E_{m_X}$。亚晶格 $X$ 的一个特定修饰由每种元素类型占据的位点数量定义。设 $k_i$ 是元素类型 $E_i$ 占据的位点数。由于总共有 $n_X$ 个位点，非负整数集合 $\\{k_1, k_2, \\dots, k_{m_X}\\}$ 必须满足以下条件：\n$$k_1 + k_2 + \\dots + k_{m_X} = n_X, \\quad k_i \\ge 0$$\n因此，不同修饰的数量 $N_X$ 等于该方程的非负整数解的数量。\n\n这是一个经典的组合问题，可以使用“隔板法”（stars and bars）解决。想象我们有 $n_X$ 个不可区分的物品（星号，*），希望将它们放入 $m_X$ 个可区分的箱子（元素类型）中。我们可以通过排列 $n_X$ 个星号并用 $m_X - 1$ 个隔板（竖线，|）将它们分开来表示这种排列。例如，如果 $n_X=5$ 和 $m_X=4$，排列 `**|*||**` 对应于解 $k_1=2$、$k_2=1$、$k_3=0$ 和 $k_4=2$。\n\n符号（星号和隔板）的总数是 $n_X + (m_X - 1)$。这些符号的任何序列都代表一个唯一的解。唯一序列的数量等同于从总共 $n_X + m_X - 1$ 个可用位置中为 $n_X$ 个星号选择位置。这由二项式系数给出：\n$$N_X = \\binom{n_X + m_X - 1}{n_X}$$\n这也可以写成选择 $m_X - 1$ 个隔板的位置：\n$$N_X = \\binom{n_X + m_X - 1}{m_X - 1}$$\n这两个表达式是等价的，因为 $\\binom{n}{k} = \\binom{n}{n-k}$。\n\n将每个亚晶格的这一结果结合起来，不同修饰结构的总数由以下公式给出：\n$$N_{total} = \\binom{n_A + m_A - 1}{n_A} \\cdot \\binom{n_B + m_B - 1}{n_B} \\cdot \\binom{n_O + m_O - 1}{n_O}$$\n\n此公式将被实现以解决给定的测试案例。\n\n原型的具体参数是：\n-   Perovskite ($ABO_3$)：$n_A=1$, $n_B=1$, $n_O=3$。\n-   Spinel ($AB_2O_4$)：$n_A=8$, $n_B=16$, $n_O=32$。\n\n对于任何多重度 $n_X=1$ 的亚晶格，公式简化为：\n$$N_X = \\binom{1 + m_X - 1}{1} = \\binom{m_X}{1} = m_X$$\n这很直观：只有一个位点，因此有 $m_X$ 种选择来决定在此处放置哪种元素。\n\n对于任何允许的元素类型数量 $m_X=1$ 的亚晶格，公式简化为：\n$$N_X = \\binom{n_X + 1 - 1}{n_X} = \\binom{n_X}{n_X} = 1$$\n这也同样直观：如果只允许一种元素类型，那么只有一种方法来修饰亚晶格（即用该元素填充所有位点）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the number of distinct decorated crystal structures based on\n    combinatorial principles for high-throughput materials screening.\n    \"\"\"\n\n    # Define the Wyckoff orbit multiplicities for each prototype structure.\n    # n_X is the number of symmetry-equivalent sites for sublattice X.\n    prototype_params = {\n        'perovskite': {'n_A': 1, 'n_B': 1, 'n_O': 3},\n        'spinel': {'n_A': 8, 'n_B': 16, 'n_O': 32},\n    }\n\n    # Test suite provided in the problem statement.\n    # Each case is a tuple: (prototype_name, m_A, m_B, m_O)\n    # m_X is the number of allowed element types for sublattice X.\n    test_cases = [\n        ('perovskite', 2, 3, 2),\n        ('perovskite', 1, 1, 1),\n        ('perovskite', 5, 4, 3),\n        ('spinel', 2, 2, 1),\n        ('spinel', 2, 3, 2),\n    ]\n\n    results = []\n\n    def count_decorations(n, m):\n        \"\"\"\n        Calculates the number of ways to decorate a sublattice with n sites\n        using m element types.\n\n        This is a multiset combination problem, also known as \"stars and bars\".\n        The formula is C(n + m - 1, n).\n\n        Args:\n            n (int): The number of indistinguishable sites (orbit multiplicity).\n            m (int): The number of distinct element types to choose from.\n\n        Returns:\n            int: The number of distinct decorations for the sublattice.\n        \"\"\"\n        # Ensure n and m are non-negative integers.\n        if n  0 or m  0:\n            raise ValueError(\"Number of sites and element types must be non-negative.\")\n        if m == 0 and n > 0:\n            return 0  # Cannot fill sites if no elements are available.\n        if n == 0:\n            return 1 # One way to have an empty decoration.\n        \n        # Using math.comb for robust calculation of binomial coefficients\n        # C(n, k) = n! / (k! * (n-k)!)\n        return math.comb(n + m - 1, n)\n\n    for case in test_cases:\n        prototype_name, m_A, m_B, m_O = case\n        params = prototype_params[prototype_name]\n        n_A, n_B, n_O = params['n_A'], params['n_B'], params['n_O']\n\n        # Calculate the number of distinct decorations for each sublattice.\n        N_A = count_decorations(n_A, m_A)\n        N_B = count_decorations(n_B, m_B)\n        N_O = count_decorations(n_O, m_O)\n\n        # The total number of distinct structures is the product of the\n        # possibilities for each independent sublattice.\n        total_structures = N_A * N_B * N_O\n        results.append(total_structures)\n\n    # Format the final output as a comma-separated list in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论计算，如密度泛函理论（DFT），其结果天然带有不确定性。本练习将教授一项关键技能：如何将这些计算能量的不确定性传播到衍生物理量（例如，相图中的凸包能量$E_{\\text{hull}}$）的评估中。通过亲手实现蒙特卡洛自举法（bootstrap），您将学习如何量化预测的置信度，从而从单一的数值点估计迈向更稳健的统计分析。",
            "id": "3456702",
            "problem": "您正在设计一个自动化工作流程，用于将密度泛函理论（DFT）计算的生成焓中的不确定性传播到二元体系的相稳定性评估中，该流程适用于高通量材料筛选。对于一个由元素 A 和 B 组成的二元体系，考虑一系列以 $i$ 索引的中间化合物，其组成为 $x_i \\in (0,1)$，代表 B 的原子分数，单位原子的生成焓为 $H_{f,i}$，单位为电子伏特/原子。根据定义，在 $x=0$ 和 $x=1$ 处的纯元素的 $H_f = 0$。每个中间化合物都有一个由标准差 $\\sigma_i$ 表示的独立估计的不确定性，并且不确定性被建模为独立的高斯分布。\n\n您的任务是实现一个蒙特卡洛自举（Monte Carlo bootstrap）方法，在每个测试用例中，将 $H_{f,i}$ 中的不确定性传播到指定目标化合物的凸包之上能量 $E_{\\mathrm{hull},i}$。所需的步骤和定义如下：\n\n- 基本原理：沿连接两个相（组分为 $x_a$ 和 $x_b$，生成焓为 $H_{f,a}$ 和 $H_{f,b}$）的连接线（tie-line）的混合物的单位原子生成焓由凸组合 $H_{f,\\mathrm{mix}}(x) = \\lambda H_{f,a} + (1-\\lambda) H_{f,b}$ 给出，其中对于 $x \\in [x_a, x_b]$，$\\lambda = \\dfrac{x_b - x}{x_b - x_a}$。点集 $\\{(x,H_f)\\}$ 的下凸包络（一维中的凸包）代表了在杠杆定则下能量上稳定的混合物集合。在组分 $x_i$ 处的凸包之上能量定义为 $E_{\\mathrm{hull},i} = H_{f,i} - H_{\\mathrm{hull}}(x_i)$，其中 $H_{\\mathrm{hull}}(x)$ 是通过在包围 $x$ 的相邻凸包顶点之间进行线性插值而在 $x$ 处评估的凸包能量。\n\n- 传播不确定性的自举（Bootstrap）程序：\n  1. 对于一个给定的案例，构建包含纯元素 $(0,0)$ 和 $(1,0)$ 以及所有中间化合物 $(x_i, H_{f,i})$ 的完整点集。纯元素的不确定性为零。\n  2. 对于每个自举复制 $b \\in \\{1,\\dots,B\\}$，为每个中间化合物独立地从 $\\mathcal{N}(H_{f,i}, \\sigma_i^2)$ 中抽取一个样本 $H'_{f,i}$；保持 $(0,0)$ 和 $(1,0)$ 不变。\n  3. 使用正确的凸性条件计算采样点 $\\{(x_i, H'_{f,i})\\}$ 加上 $(0,0)$ 和 $(1,0)$ 的下凸包：对于三个连续的候选凸包点 $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$ 且 $x_1  x_2  x_3$，斜率必须满足 $\\dfrac{y_2 - y_1}{x_2 - x_1} \\le \\dfrac{y_3 - y_2}{x_3 - x_2}$；否则移除中间点并重新检查，直到满足凸性条件。\n  4. 通过在包围目标组分 $x_t$ 的两个相邻凸包顶点之间进行线性插值，在 $x_t$ 处评估 $H_{\\mathrm{hull}}(x_t)$。\n  5. 对于该自举复制，计算 $E^{(b)}_{\\mathrm{hull}} = \\max\\{0, H'_{f,t} - H_{\\mathrm{hull}}(x_t)\\}$。\n  6. 在 $B$ 次复制后，估计样本均值和双侧 $95\\%$ 置信区间，该区间是集合 $\\{E^{(b)}_{\\mathrm{hull}}\\}_{b=1}^B$ 在概率 $0.025$ 和 $0.975$ 处的经验分位数。\n\n- 您的程序必须使用提供的种子实现确定性的伪随机性。\n\n- 所有能量必须以电子伏特/原子表示，所有输出必须以电子伏特/原子报告，并四舍五入到 $6$ 位小数。\n\n- 为了数值稳定性，将任何因浮点舍入误差产生的负值 $E_{\\mathrm{hull}}$ 视为 $0$。\n\n数学和算法规范：\n\n- 您必须计算在点集 $(x,H_f)$ 加上 $(0,0)$ 和 $(1,0)$ 后的一维下凸包。该凸包是位于所有点之下或与之相等的唯一的最小凸函数。在一维中的一种实用构造方法是按 $x$ 对点进行排序，并如上所述在连续的三个点上迭代地强制执行凸性不等式。\n\n- 您必须为每个测试用例仅针对指定的目标化合物产生结果。对于在某次自举复制中组分恰好等于凸包顶点的目标，该次复制中的 $E_{\\mathrm{hull}}$ 为 $0$。\n\n- 置信区间定义：如果排序后的 $E_{\\mathrm{hull}}$ 样本为 $e_{(1)} \\le \\dots \\le e_{(B)}$，则下端点是位于位置 $\\lceil 0.025 \\times B \\rceil$ 的元素，上端点是位于位置 $\\lceil 0.975 \\times B \\rceil$ 的元素，使用允许线性插值的标准经验分位数；使用数值库在概率 $0.025$ 和 $0.975$ 处的 `quantile` 函数是可接受的。\n\n用于覆盖一般、边界和边缘情况的测试套件。在以下每个案例中，在凸包构建中都包括不确定性为零的纯元素 $(0,0)$ 和 $(1,0)$；只有列出的中间化合物是不确定的。\n\n- 案例 $1$（一般的稳定内部相）：\n  - 中间组分和统计数据：$\\{(x_i, H_{f,i}, \\sigma_i)\\} = \\{(0.25, -0.090, 0.020), (0.50, -0.150, 0.015), (0.75, -0.085, 0.020)\\}$。\n  - 目标索引：$1$（即组分为 $x = 0.50$ 的化合物）。\n  - 自举复制次数：$B = 400$。\n  - 种子：$7$。\n\n- 案例 $2$（不确定性可能跨越凸包的亚稳态边界倾斜相）：\n  - 中间组分和统计数据：$\\{(x_i, H_{f,i}, \\sigma_i)\\} = \\{(0.20, -0.030, 0.010), (0.33, -0.070, 0.025), (0.60, -0.040, 0.010), (0.80, -0.010, 0.010)\\}$。\n  - 目标索引：$0$（即组分为 $x = 0.20$ 的化合物）。\n  - 自举复制次数：$B = 400$。\n  - 种子：$11$。\n\n- 案例 $3$（测试凸包翻转的近简并内部相）：\n  - 中间组分和统计数据：$\\{(x_i, H_{f,i}, \\sigma_i)\\} = \\{(0.10, -0.005, 0.004), (0.40, -0.085, 0.012), (0.55, -0.083, 0.012), (0.90, -0.004, 0.004)\\}$。\n  - 目标索引：$2$（即组分为 $x = 0.55$ 的化合物）。\n  - 自举复制次数：$B = 600$。\n  - 种子：$13$。\n\n最终输出规范：\n\n- 对每个案例，计算目标化合物的三个值：$E_{\\mathrm{hull}}$ 的自举样本均值、经验下 $0.025$ 分位数和经验上 $0.975$ 分位数。\n- 将这三个值中的每一个都四舍五入到 $6$ 位小数。\n- 您的程序应生成一行输出，其中包含按案例顺序列出的、以逗号分隔的列表的列表，每个内部列表的结构为 $[ \\text{mean}, \\text{lower}, \\text{upper} ]$。例如，打印的行应类似于 $[[m_1,\\ell_1,u_1],[m_2,\\ell_2,u_2],[m_3,\\ell_3,u_3]]$，其中每个条目都是一个以电子伏特/原子为单位的浮点数，四舍五入到 $6$ 位小数。",
            "solution": "该问题已经过验证，并被确定为一个定义良好、具有科学依据的计算材料科学问题。它为使用蒙特卡洛自举（Monte Carlo bootstrap）方法对相稳定性进行不确定性量化，提供了一套完整且一致的定义、数据和算法要求。所有指定参数在物理上都是合理的，且该方法论与该领域的标准实践相符。\n\n任务是将密度泛函理论（DFT）计算的生成焓 $H_{f,i}$ 的不确定性，传播到二元材料体系的导出量——凸包之上能量 $E_{\\mathrm{hull},i}$。每个 $H_{f,i}$ 的不确定性由标准差 $\\sigma_i$ 给出，并由一个独立的高斯分布 $\\mathcal{N}(H_{f,i}, \\sigma_i^2)$ 建模。解决方案需要实现指定的自举程序。\n\n该方法的核心是针对每个测试用例进行 $B$ 次复制的蒙特卡洛模拟。在每次复制中，我们执行以下步骤：\n\n1.  **随机抽样**：对于每个具有组分 $x_i$ 和平均生成焓 $H_{f,i}$ 的中间化合物，从其高斯概率分布中抽取一个新的生成焓样本 $H'_{f,i}$。位于 $x=0$ 和 $x=1$ 的纯元素的生成焓固定为 $H_f=0$，不确定性为零。通过为每个案例设定伪随机数生成器的种子，确保了此随机过程的可复现性。\n\n2.  **凸包构建**：使用所有中间化合物的点集 $\\{(x_i, H'_{f,i})\\}$，并增补纯元素的固定点 $(0,0)$ 和 $(1,0)$，来构建一维下凸包。这是通过 Andrew 单调链算法的一个变体实现的，该算法非常适合这个一维问题。算法流程如下：\n    a. 所有点按其组分（x坐标）排序。\n    b. 遍历这些点，并构建一个候选凸包。对于正在考虑的每个新点 $p_3$，会与候选凸包上的最后两个点 $p_1$ 和 $p_2$ 进行检查。这三个点必须形成一个“右转”或共线，以维持下凸包的凸性。这对应于线段斜率序列的非递减性：$\\text{slope}(p_1, p_2) \\le \\text{slope}(p_2, p_3)$。\n    c. 如果这些点形成“左转”（即 $\\text{slope}(p_1, p_2) > \\text{slope}(p_2, p_3)$），则中间点 $p_2$ 引入了一个凹陷，因此被从候选凸包中移除。重复此检查直到满足凸性条件，然后添加新点 $p_3$。\n    d. 这个过程最终得到一个按组分排序的、定义了下凸包的顶点列表。为了数值稳定性，斜率比较通过使用叉积来实现，从而避免了除法。当考虑点 $p_3 = (x_3, y_3)$ 时，给定前一个凸包点 $p_1 = (x_1, y_1)$，移除点 $p_2 = (x_2, y_2)$ 的条件是 $(y_2 - y_1)(x_3 - x_2) - (x_2 - x_1)(y_3 - y_2) > 0$。\n\n3.  **凸包之上能量的计算**：对于一个指定组分为 $x_t$ 的目标化合物，必须计算其凸包之上能量 $E_{\\mathrm{hull}}$。\n    a. 首先确定目标组分处的凸包能量 $H_{\\mathrm{hull}}(x_t)$。这需要找到计算出的凸包上包围目标组分的两个相邻顶点 $(x_a, H_a)$ 和 $(x_b, H_b)$，即 $x_a \\le x_t \\le x_b$。\n    b. $H_{\\mathrm{hull}}(x_t)$ 随后通过在这两个顶点之间进行线性插值计算得出：$H_{\\mathrm{hull}}(x_t) = H_a + (H_b - H_a) \\frac{x_t - x_a}{x_b - x_a}$。\n    c. 当前自举复制的凸包之上能量 $E^{(b)}_{\\mathrm{hull}}$ 是目标化合物的采样焓与其组分处凸包能量之差：$E^{(b)}_{\\mathrm{hull}} = H'_{f,t} - H_{\\mathrm{hull}}(x_t)$。根据规定，任何由此产生的负值（当点位于凸包上时可能因浮点不精确而出现）都被设为 $0$。\n\n4.  **统计分析**：完成所有 $B$ 次自举复制后，得到一个 $\\{E^{(b)}_{\\mathrm{hull}}\\}_{b=1}^B$ 值的分布。从此分布中计算样本均值，它代表了凸包之上能量的最佳估计值。该估计的不确定性通过双侧 $95\\%$ 置信区间来量化，该区间由样本分布在概率 $0.025$ 和 $0.975$ 处的经验分位数确定。\n\n该实现将封装在一个单一的 Python 脚本中。利用 `numpy` 库进行高效的数值运算，特别是用于生成高斯随机数、执行数组操作以及计算最终的统计量（均值和分位数）。每个案例的最终结果，包括均值、下分位数和上分位数，都四舍五入到 $6$ 位小数，并按要求格式化为单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty propagation problem for DFT formation enthalpies\n    using a Monte Carlo bootstrap method as specified.\n    \"\"\"\n    test_cases = [\n        {\n            \"data\": np.array([\n                [0.25, -0.090, 0.020],\n                [0.50, -0.150, 0.015],\n                [0.75, -0.085, 0.020]\n            ]),\n            \"target_idx\": 1,\n            \"B\": 400,\n            \"seed\": 7\n        },\n        {\n            \"data\": np.array([\n                [0.20, -0.030, 0.010],\n                [0.33, -0.070, 0.025],\n                [0.60, -0.040, 0.010],\n                [0.80, -0.010, 0.010]\n            ]),\n            \"target_idx\": 0,\n            \"B\": 400,\n            \"seed\": 11\n        },\n        {\n            \"data\": np.array([\n                [0.10, -0.005, 0.004],\n                [0.40, -0.085, 0.012],\n                [0.55, -0.083, 0.012],\n                [0.90, -0.004, 0.004]\n            ]),\n            \"target_idx\": 2,\n            \"B\": 600,\n            \"seed\": 13\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        data = case[\"data\"]\n        target_idx = case[\"target_idx\"]\n        B = case[\"B\"]\n        seed = case[\"seed\"]\n\n        x_coords = data[:, 0]\n        h_means = data[:, 1]\n        h_stds = data[:, 2]\n        target_x = x_coords[target_idx]\n\n        rng = np.random.default_rng(seed)\n\n        e_hull_samples = []\n        for _ in range(B):\n            # 1. Sample H_f values for intermediate compounds\n            h_samples = rng.normal(loc=h_means, scale=h_stds)\n            \n            # 2. Form the full set of points including endpoints (0,0) and (1,0)\n            points = [(0.0, 0.0)]\n            for i in range(len(x_coords)):\n                points.append((x_coords[i], h_samples[i]))\n            points.append((1.0, 0.0))\n            \n            # Points are already sorted by x-coordinate based on problem input structure\n            # points.sort(key=lambda p: p[0]) is implicitly handled.\n\n            # 3. Compute the lower convex hull using the monotone chain algorithm\n            lower_hull = []\n            for p3 in points:\n                # p1, p2, p3 must form a \"right turn\" for a lower hull. Pop on \"left turn\".\n                while len(lower_hull) >= 2:\n                    p1 = lower_hull[-2]\n                    p2 = lower_hull[-1]\n                    # Cross product check: (y2-y1)(x3-x2) - (x2-x1)(y3-y2) > 0 -> \"left turn\"\n                    # We pop if the turn is counter-clockwise (left turn), which corresponds\n                    # to a concave corner in the lower hull.\n                    if (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1]) > 0:\n                        lower_hull.pop()\n                    else:\n                        break\n                lower_hull.append(p3)\n\n            # 4. Evaluate H_hull(x_t) by interpolation on the computed hull\n            h_hull_at_target = 0.0\n            for i in range(len(lower_hull) - 1):\n                p_a = lower_hull[i]\n                p_b = lower_hull[i+1]\n                if p_a[0] = target_x = p_b[0]:\n                    xa, ha = p_a\n                    xb, hb = p_b\n                    # Handle cases where target_x is exactly a hull vertex\n                    if abs(target_x - xa)  1e-12:\n                        h_hull_at_target = ha\n                        break\n                    if abs(target_x - xb)  1e-12:\n                        h_hull_at_target = hb\n                        break\n                    # Linear interpolation for x_t between two hull vertices\n                    h_hull_at_target = ha + (hb - ha) * (target_x - xa) / (xb - xa)\n                    break\n            \n            # 5. Compute E_hull for the replicate\n            h_prime_t = h_samples[target_idx]\n            e_hull = h_prime_t - h_hull_at_target\n            e_hull = max(0.0, e_hull)\n            e_hull_samples.append(e_hull)\n\n        # 6. Compute statistics (mean, 95% CI)\n        e_hull_samples = np.array(e_hull_samples)\n        mean_e_hull = np.mean(e_hull_samples)\n        lower_ci = np.quantile(e_hull_samples, 0.025)\n        upper_ci = np.quantile(e_hull_samples, 0.975)\n        \n        all_results.append([\n            round(mean_e_hull, 6),\n            round(lower_ci, 6),\n            round(upper_ci, 6)\n        ])\n\n    result_str = \"[\" + \",\".join([f\"[{m},{l},{u}]\" for m, l, u in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在大规模材料筛选中，计算资源总是有限的。本练习引入了一个高级概念，即将资源分配问题构建为一个信息论驱动的优化问题。通过使用信息论（香农熵）来定义计算的“价值”，并将其解决为一个0-1背包问题，您将学习如何设计智能化的工作流，从而在固定的预算内最大化知识的获取。",
            "id": "3456745",
            "problem": "一个高通量计算材料筛选工作流必须在一组候选材料中，为收敛性精化任务分配有限的计算资源。每个候选材料 $x_i$ 有一个不确定的属性，该属性被建模为一个具有高斯先验的潜在均值，并通过计算进行测量，这些计算产生具有已知高斯噪声的条件独立观测值。精化过程包括对候选材料 $i$ 进行 $m_i$ 次额外的独立计算采样，每次采样消耗 $u_i$ 个核时，因此候选材料 $i$ 的增量成本为 $c_i = m_i u_i$ 核时。您必须将在总预算 $B$ 核时内决定精化哪些候选材料的决策问题，建模为一个 $0$-$1$ 背包选择问题，其中选择候选材料 $i$ 的“价值”$v_i$ 是来自精化的期望信息增益。\n\n使用以下基础知识：\n- 单变量高斯分布 $\\mathcal{N}(0,\\sigma^2)$ 的香农微分熵 (SDE) 为 $H(\\sigma^2) = \\frac{1}{2}\\ln\\!\\big(2\\pi e\\,\\sigma^2\\big)$，单位为奈特（nats）。\n- 在正态-正态共轭模型下，对于候选材料 $i$，若已知观测噪声方差为 $\\tau_i^2$ 且先验方差为 $\\sigma_{0,i}^2$，经过 $m_i$ 次独立观测后，后验精度等于先验精度与数据精度之和：$\\sigma_{\\text{post},i}^{-2} = \\sigma_{0,i}^{-2} + m_i \\tau_i^{-2}$，因此 $\\sigma_{\\text{post},i}^{2} = \\big(\\sigma_{0,i}^{-2} + m_i \\tau_i^{-2}\\big)^{-1}$。\n\n基于这些基础，推导出候选材料 $i$ 的信息增益 $v_i$（即先验与后验之间的SDE减少量），并使用提供的参数为每个候选材料计算 $v_i$。将选择问题表述为在子集 $S \\subset \\{0,1,\\dots,N-1\\}$ 上最大化 $\\sum_{i \\in S} v_i$，约束条件为 $\\sum_{i \\in S} c_i \\le B$，其中每个物品要么被选中，要么不被选中；不允许部分选择。按以下确定性规则解决平局：在所有达到最大总价值的子集中，选择总成本最小的子集；如果仍然存在平局，则选择索引和最小的子集。\n\n您的程序必须实现一个精确的、包含上述平局解决规则的 $0$-$1$ 背包动态规划算法，为每个测试用例计算选中的索引，并将结果以单行形式输出，格式为方括号括起来的、逗号分隔的列表。每个结果必须是该测试用例的、按升序排列的选中索引列表。\n\n物理单位说明：所有计算预算和成本都必须以“核时”为单位处理，所有熵都必须以“奈特”为单位。最终输出仅包含整数索引，这些索引是无单位的。\n\n测试套件：\n- 测试用例1 (正常路径):\n  - $N = 6$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.09, 0.16, 0.25, 0.04, 0.12, 0.20\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.03, 0.04, 0.05, 0.02, 0.06, 0.08\\big]$\n  - 计划采样数 $m$: $\\big[2, 3, 1, 4, 2, 3\\big]$\n  - 单位成本 $u$ (核时/采样): $\\big[4, 5, 2, 3, 6, 4\\big]$\n  - 预算 $B = 25$ 核时。\n- 测试用例2 (边界 B=0):\n  - $N = 3$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.10, 0.20, 0.30\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.05, 0.10, 0.15\\big]$\n  - 计划采样数 $m$: $\\big[1, 2, 3\\big]$\n  - 单位成本 $u$: $\\big[4, 5, 6\\big]$\n  - 预算 $B = 0$ 核时。\n- 测试用例3 (精确匹配，唯一最优解):\n  - $N = 5$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.10, 0.08, 0.18, 0.12, 0.05\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.05, 0.04, 0.09, 0.03, 0.05\\big]$\n  - 计划采样数 $m$: $\\big[2, 1, 2, 1, 3\\big]$\n  - 单位成本 $u$: $\\big[3, 6, 4, 5, 2\\big]$\n  - 预算 $B = 19$ 核时。\n- 测试用例4 (含零价值物品的边缘情况，价值平局通过最小索引和解决):\n  - $N = 4$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.15, 0.15, 0.30, 0.10\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.05, 0.05, 0.10, 0.10\\big]$\n  - 计划采样数 $m$: $\\big[0, 2, 1, 3\\big]$\n  - 单位成本 $u$: $\\big[3, 3, 6, 2\\big]$\n  - 预算 $B = 12$ 核时。\n- 测试用例5 (总价值平局，通过最小总成本解决):\n  - $N = 4$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.20, 0.10, 0.05, 0.15\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.10, 0.05, 0.05, 0.05\\big]$\n  - 计划采样数 $m$: $\\big[1, 2, 3, 1\\big]$\n  - 单位成本 $u$: $\\big[10, 5, 3, 6\\big]$\n  - 预算 $B = 19$ 核时。\n\n最终输出格式要求：您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果，每个测试用例的结果是一个按升序排列的选中索引列表，例如 $\\big[[0,1,2],[],[0,2,3],[1,2],[1,3]\\big]$。",
            "solution": "用户提供的问题陈述被评估为**有效**。它在计算材料科学和信息论方面有科学依据，在数学上被适定地表述为一个具有确定性平局解决规则的0-1背包问题，并为所有测试用例提供了完整且一致的给定条件。\n\n目标是选择一个候选材料子集进行计算精化，以在固定的计算预算 $B$ 内最大化总信息增益。这可以被严格地表述为一个 $0$-$1$ 背包问题。\n\n首先，我们必须推导出将每个候选材料 $i$ 包含在精化集合 $S$ 中的“价值”$v_i$ 和“成本”（或“重量”）$c_i$。\n\n精化候选材料 $i$ 的成本 $c_i$ 被明确地给出为计划计算采样数 $m_i$ 与每次采样的单位成本 $u_i$（以核时为单位）的乘积：\n$$c_i = m_i u_i$$\n由于在所有测试用例中 $m_i$ 和 $u_i$ 都被指定为整数，因此成本 $c_i$ 是一个整数。\n\n价值 $v_i$ 被定义为期望信息增益，其量化方式为属性分布的香农微分熵（SDE）从先验到后验的减少量。方差为 $\\sigma^2$ 的单变量高斯分布的SDE给出如下：\n$$H(\\sigma^2) = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma^2)$$\n对于先验方差为 $\\sigma_{0,i}^2$ 的候选材料 $i$，其先验熵为：\n$$H_{\\text{prior},i} = H(\\sigma_{0,i}^2) = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{0,i}^2)$$\n经过 $m_i$ 次独立观测（每次观测的噪声方差为 $\\tau_i^2$）后，后验方差 $\\sigma_{\\text{post},i}^2$ 的贝叶斯更新规则如下：\n$$\\sigma_{\\text{post},i}^2 = \\left(\\sigma_{0,i}^{-2} + m_i \\tau_i^{-2}\\right)^{-1}$$\n那么，后验熵为：\n$$H_{\\text{post},i} = H(\\sigma_{\\text{post},i}^2) = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{\\text{post},i}^2)$$\n信息增益 $v_i$ 是二者之差：\n$$v_i = H_{\\text{prior},i} - H_{\\text{post},i} = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{0,i}^2) - \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{\\text{post},i}^2)$$\n利用对数性质 $\\ln a - \\ln b = \\ln(a/b)$，我们将其简化为：\n$$v_i = \\frac{1}{2}\\ln\\left(\\frac{2\\pi e\\,\\sigma_{0,i}^2}{2\\pi e\\,\\sigma_{\\text{post},i}^2}\\right) = \\frac{1}{2}\\ln\\left(\\frac{\\sigma_{0,i}^2}{\\sigma_{\\text{post},i}^2}\\right)$$\n我们可以使用后验方差公式来表示方差之比：\n$$\\frac{1}{\\sigma_{\\text{post},i}^2} = \\frac{1}{\\sigma_{0,i}^2} + \\frac{m_i}{\\tau_i^2}$$\n两边乘以 $\\sigma_{0,i}^2$：\n$$\\frac{\\sigma_{0,i}^2}{\\sigma_{\\text{post},i}^2} = \\sigma_{0,i}^2 \\left(\\frac{1}{\\sigma_{0,i}^2} + \\frac{m_i}{\\tau_i^2}\\right) = 1 + m_i \\frac{\\sigma_{0,i}^2}{\\tau_i^2}$$\n将此代回 $v_i$ 的表达式，得到每个物品价值的最终公式：\n$$v_i = \\frac{1}{2}\\ln\\left(1 + m_i \\frac{\\sigma_{0,i}^2}{\\tau_i^2}\\right)$$\n注意，如果 $m_i=0$，则 $v_i = \\frac{1}{2}\\ln(1) = 0$，这在逻辑上是一致的，因为没有获得新的信息。\n\n选择问题是在预算约束 $\\sum_{i \\in S} c_i \\le B$ 下，找到一个索引子集 $S \\subseteq \\{0, 1, \\dots, N-1\\}$ 来最大化总价值 $\\sum_{i \\in S} v_i$。这是一个经典的 $0$-$1$ 背包问题。该问题指定了通过动态规划求解的精确解法，并附有三级平局解决规则：\n1.  最大化总价值 $\\sum v_i$。\n2.  在具有最大价值的解中，最小化总成本 $\\sum c_i$。\n3.  如果仍然存在平局，最小化所选候选材料的索引之和 $\\sum i$。\n\n为了实现这一点，我们使用动态规划方法。设 $dp[i][w]$ 为使用前 $i$ 个物品（索引为 $0, \\dots, i-1$）在预算为 $w$ 的情况下可达到的最优解。为了处理平局解决规则，每个状态 $dp[i][w]$ 将存储一个元组 $(V, C, I_{\\text{sum}})$，分别代表最大价值、达到该价值的最小成本，以及达到该成本的最小索引和。\n\n大小为 $(N+1) \\times (B+1)$ 的DP表 `dp` 被初始化为 $(0, 0, 0)$。该表被迭代地填充。对于每个物品 $i$（从 $1$ 到 $N$）和每个预算容量 $w$（从 $1$ 到 $B$），我们决定是否包含物品 $i-1$（其属性为 $v_{i-1}, c_{i-1}, \\text{index}=i-1$）。\n\n递推关系如下：$dp[i][w]$ 是以下两个候选方案中较优的一个：\n1.  **不包含物品 $i-1$**：解与只考虑前 $i-1$ 个物品的解相同，即 $dp[i-1][w]$。\n2.  **包含物品 $i-1$**（如果 $w \\ge c_{i-1}$）：解由物品 $i-1$ 与在剩余预算下对前 $i-1$ 个物品的最优解 $dp[i-1][w-c_{i-1}]$ 组合而成。新的元组为 $(dp[i-1][w-c_{i-1}].V + v_{i-1}, dp[i-1][w-c_{i-1}].C + c_{i-1}, dp[i-1][w-c_{i-1}].I_{\\text{sum}} + (i-1))$。\n\n“更优”的候选方案根据指定的平局解决规则来选择。填满整个表后，$dp[N][B]$ 处的元组代表了最优解的属性。\n\n为了重构选中的物品集合，我们使用第二个表 `path[i][w]` 来存储每一步做出的决策。通过从 `path[N][B]` 开始向后追溯这些决策，我们可以识别出最优集合中包含的所有物品。得到的索引列表随后按要求升序排序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of 0-1 knapsack problems derived from a materials screening\n    workflow, with specific tie-breaking rules.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"N\": 6,\n            \"sig0_sq\": [0.09, 0.16, 0.25, 0.04, 0.12, 0.20],\n            \"tau_sq\": [0.03, 0.04, 0.05, 0.02, 0.06, 0.08],\n            \"m\": [2, 3, 1, 4, 2, 3],\n            \"u\": [4, 5, 2, 3, 6, 4],\n            \"B\": 25,\n        },\n        # Test case 2 (boundary B=0)\n        {\n            \"N\": 3,\n            \"sig0_sq\": [0.10, 0.20, 0.30],\n            \"tau_sq\": [0.05, 0.10, 0.15],\n            \"m\": [1, 2, 3],\n            \"u\": [4, 5, 6],\n            \"B\": 0,\n        },\n        # Test case 3 (exact fit, unique optimum)\n        {\n            \"N\": 5,\n            \"sig0_sq\": [0.10, 0.08, 0.18, 0.12, 0.05],\n            \"tau_sq\": [0.05, 0.04, 0.09, 0.03, 0.05],\n            \"m\": [2, 1, 2, 1, 3],\n            \"u\": [3, 6, 4, 5, 2],\n            \"B\": 19,\n        },\n        # Test case 4 (edge case with zero-value item, tie on value resolved by minimal index sum)\n        {\n            \"N\": 4,\n            \"sig0_sq\": [0.15, 0.15, 0.30, 0.10],\n            \"tau_sq\": [0.05, 0.05, 0.10, 0.10],\n            \"m\": [0, 2, 1, 3],\n            \"u\": [3, 3, 6, 2],\n            \"B\": 12,\n        },\n        # Test case 5 (tie on total value, resolve by minimal total cost)\n        {\n            \"N\": 4,\n            \"sig0_sq\": [0.20, 0.10, 0.05, 0.15],\n            \"tau_sq\": [0.10, 0.05, 0.05, 0.05],\n            \"m\": [1, 2, 3, 1],\n            \"u\": [10, 5, 3, 6],\n            \"B\": 19,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        sig0_sq = case[\"sig0_sq\"]\n        tau_sq = case[\"tau_sq\"]\n        m = case[\"m\"]\n        u = case[\"u\"]\n        B = case[\"B\"]\n\n        items = []\n        for i in range(N):\n            cost = int(m[i] * u[i])\n            if m[i] == 0 or tau_sq[i] == 0:\n                value = 0.0\n            else:\n                value = 0.5 * np.log(1 + m[i] * sig0_sq[i] / tau_sq[i])\n            items.append({'v': value, 'c': cost, 'i': i})\n\n        # dp[i][w] = (max_value, min_cost, min_index_sum)\n        # for items 0..i-1 and budget w\n        dp = [[(0.0, 0, 0) for _ in range(B + 1)] for _ in range(N + 1)]\n        path = [[0 for _ in range(B + 1)] for _ in range(N + 1)]\n\n        for i in range(1, N + 1):\n            item = items[i - 1]\n            v_i, c_i, idx_i = item['v'], item['c'], item['i']\n\n            for w in range(B + 1):\n                # Option 1: Don't include item i-1\n                candidate1 = dp[i - 1][w]\n                dp[i][w] = candidate1\n                path[i][w] = 0\n\n                # Option 2: Include item i-1 (if possible)\n                if w >= c_i:\n                    base_sol_for_2 = dp[i - 1][w - c_i]\n                    candidate2 = (\n                        base_sol_for_2[0] + v_i,\n                        base_sol_for_2[1] + c_i,\n                        base_sol_for_2[2] + idx_i\n                    )\n                    \n                    v1, c1, s1 = candidate1\n                    v2, c2, s2 = candidate2\n\n                    # Compare candidates using the specified tie-breaking rules\n                    # A small tolerance is used for floating-point value comparison\n                    is_candidate2_better = False\n                    if v2 > v1 + 1e-9:\n                        is_candidate2_better = True\n                    elif abs(v2 - v1)  1e-9:\n                        if c2  c1:\n                            is_candidate2_better = True\n                        elif c2 == c1:\n                            if s2  s1:\n                                is_candidate2_better = True\n                    \n                    if is_candidate2_better:\n                        dp[i][w] = candidate2\n                        path[i][w] = 1\n\n        # Backtrack to find the selected items\n        selected_indices = []\n        w = B\n        for i in range(N, 0, -1):\n            if path[i][w] == 1:\n                item_index = items[i - 1]['i']\n                item_cost = items[i - 1]['c']\n                selected_indices.append(item_index)\n                w -= item_cost\n\n        selected_indices.sort()\n        all_results.append(selected_indices)\n\n    # Format the final output string as specified\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str.replace(' ', '')}]\")\n\nsolve()\n```"
        }
    ]
}