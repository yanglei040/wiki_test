{
    "hands_on_practices": [
        {
            "introduction": "在将材料科学问题映射到量子计算机之前，首先必须理解问题的规模。本练习旨在通过对一个通用晶体模型进行第一性原理的标度分析，来量化问题大小如何随系统尺寸而指数增长。通过完成此练习，您将深入体会到电子结构问题固有的复杂性，并理解为何需要量子计算等新范式。",
            "id": "3481650",
            "problem": "考虑为晶体的相互作用电子模型设置变分量子本征求解器（VQE, Variational Quantum Eigensolver）计算，该模型在适用于二次量子化的局域轨道基中表示。该晶体有 $N$ 个相同的晶胞，每个晶胞有 $M$ 个局域空间轨道。假设自旋简并，无自旋极化，因此每个空间轨道允许两种自旋态。您使用标准的二次量子化电子哈密顿量对电子进行建模，该哈密顿量包括所有自旋轨道上的所有单电子和双电子项。假设长程库仑相互作用是未屏蔽的，因此没有双电子积分因距离截断而消失，并且不利用任何点群或平移对称性来消除项。您打算使用费米子到量子比特的映射，其中每个自旋轨道都映射到一个量子比特。\n\n在这些假设下，请从第一性原理出发完成以下任务：\n- 根据 $N$ 和 $M$ 确定自旋轨道的总数。\n- 将哈密顿量的“大小”定义为在进行任何映射之前，二次量子化哈密顿量中出现的不同算符单项式的总数（即，单体和双体求和中索引组合的总数）。通过仅保留 $N$ 和 $M$ 的最高次多项式项，计算此总数对 $N$ 和 $M$ 的领头阶依赖关系。\n\n将您的最终结果表示为一个包含两个条目的行矩阵 [自旋轨道总数, 哈密顿量项数关于 $N$ 和 $M$ 的领头阶]。不需要单位。请提供精确表达式，无需四舍五入。",
            "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据，问题明确，客观且自洽。为了进行理论上的标度分析，明确陈述了诸如忽略对称性和考虑所有潜在相互作用项等假设。因此，我们可以继续进行推导。\n\n问题要求从晶体相互作用电子模型的二次量子化描述中推导出两个量：自旋轨道的总数和电子哈密顿量中项数的领头阶标度。\n\n**1. 自旋轨道总数**\n\n该系统是一个由 $N$ 个相同晶胞组成的晶体。每个晶胞包含 $M$ 个局域空间轨道。\n晶体中空间轨道的总数是晶胞数与每个晶胞中空间轨道数的乘积。\n设 $N_{orb}$ 为空间轨道的总数。\n$$N_{orb} = N \\times M$$\n问题陈述假设自旋简并，这意味着每个空间轨道可以被一个自旋向上（$\\sigma = +\\frac{1}{2}$，记作 $\\alpha$）或自旋向下（$\\sigma = -\\frac{1}{2}$，记作 $\\beta$）的电子占据。因此，每个空间轨道产生两个不同的自旋轨道。\n设 $N_{so}$ 为自旋轨道的总数。这是单粒子福克空间的基组大小。\n$$N_{so} = N_{orb} \\times 2 = 2NM$$\n这是第一个所求的量。\n\n**2. 哈密顿量项数的领头阶计数**\n\n相互作用电子系统的通用二次量子化电子哈密顿量由单体项和双体项之和给出：\n$$H = H_1 + H_2 = \\sum_{p,q=1}^{N_{so}} h_{pq} a_p^\\dagger a_q + \\frac{1}{2} \\sum_{p,q,r,s=1}^{N_{so}} v_{pqrs} a_p^\\dagger a_q^\\dagger a_r a_s$$\n其中，索引 $p, q, r, s$ 遍历所有 $N_{so}$ 个自旋轨道。项 $a_p^\\dagger$ 是在自旋轨道 $p$ 中产生一个电子的产生算符，而 $a_q$ 是在自旋轨道 $q$ 中湮灭一个电子的湮灭算符。系数 $h_{pq}$ 是单电子积分，$v_{pqrs}$ 是双电子积分。\n\n问题将“哈密顿量大小”明确定义为“在进行任何映射之前，二次量子化哈密顿量中出现的不同算符单项式的总数（即，单体和双体求和中索引组合的总数）”。我们必须严格遵守这一定义。问题还指示不要利用任何对称性来消除项。这意味着我们应该计算写出的求和中的项数，而不考虑系数（例如，$h_{pq} = h_{qp}^*$）或算符串（例如，$a_p^\\dagger a_q^\\dagger = -a_q^\\dagger a_p^\\dagger$）之间的关系，这些关系通常用于减少唯一项的数量。\n\n**单体项计数：**\n哈密顿量的单体部分是 $H_1 = \\sum_{p,q=1}^{N_{so}} h_{pq} a_p^\\dagger a_q$。\n根据问题的定义，我们必须计算索引对 $(p, q)$ 的组合数。由于索引 $p$ 和 $q$ 都独立地从 $1$ 遍历到 $N_{so}$，组合的总数为：\n$$ \\text{Count}_1 = N_{so} \\times N_{so} = N_{so}^2 $$\n\n**双体项计数：**\n哈密顿量的双体部分是 $H_2 = \\frac{1}{2} \\sum_{p,q,r,s=1}^{N_{so}} v_{pqrs} a_p^\\dagger a_q^\\dagger a_r a_s$。\n我们计算四元组 $(p, q, r, s)$ 的索引组合数。四个索引中的每一个都独立地从 $1$ 遍历到 $N_{so}$。组合的总数为：\n$$ \\text{Count}_2 = N_{so} \\times N_{so} \\times N_{so} \\times N_{so} = N_{so}^4 $$\n哈密顿量表达式中的前置因子 $\\frac{1}{2}$ 是一个惯例，不影响执行求和的索引组合的计数。\n\n**总数和领头阶依赖关系：**\n根据定义，哈密顿量项的总数是单体项和双体项计数之和：\n$$ \\text{Total Count} = \\text{Count}_1 + \\text{Count}_2 = N_{so}^2 + N_{so}^4 $$\n问题要求此总数对 $N$ 和 $M$ 的领头阶依赖关系。这对应于 $N$ 和 $M$ 的总幂次最高的项。我们代入 $N_{so} = 2NM$：\n$$ \\text{Total Count} = (2NM)^2 + (2NM)^4 = 4N^2M^2 + 16N^4M^4 $$\n$4N^2M^2$ 项的总次数为 $2+2=4$。$16N^4M^4$ 项的总次数为 $4+4=8$。因此，领头阶项是次数最高的项，即 $16N^4M^4$。\n\n因此，哈密顿量项数对 $N$ 和 $M$ 的领头阶依赖关系是 $16N^4M^4$。\n\n**最终结果表达式：**\n问题要求将最终结果表示为一个包含两个条目的行矩阵：[自旋轨道总数，哈密顿量项数关于 $N$ 和 $M$ 的领头阶]。\n这两个条目是 $2NM$ 和 $16N^4M^4$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2NM & 16N^{4}M^{4} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "直接模拟大规模系统通常是不可行的，但利用物理对称性可以极大地简化问题。本练习将指导您利用平移对称性（晶体的一个基本特征）来简化周期性氢链的哈密顿量。您将应用布洛赫定理将哈密顿量变换到动量空间，从而实现问题规模的缩减，这是在近期量子设备上进行模拟的关键一步。",
            "id": "3481667",
            "problem": "设计并实现一个完整、可运行的程序，该程序通过利用平移对称性，为一个一维周期性氢链形式化一个变分量子本征求解器 (VQE) 工作流。从以下第一性原理基础和核心定义开始。\n\n考虑一个一维周期性氢原子链，它有 $N$ 个晶胞，晶格常数为 $a$，每个格点有一个价轨道，自旋简并度为二。在具有周期性边界条件（格点索引模 $N$）的二次量子化中，具有在位能 $\\epsilon$ 和最近邻跃迁振幅 $t$ 的紧束缚电子哈密顿量为\n$$\nH \\;=\\; \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\epsilon \\, \\hat{n}_{j,\\sigma} \\;-\\; t \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j+1,\\sigma} \\;+\\; \\hat{c}_{j+1,\\sigma}^\\dagger \\hat{c}_{j,\\sigma} \\right),\n$$\n其中 $\\hat{c}_{j,\\sigma}^\\dagger$ 在格点 $j$ 上创建一个自旋为 $\\sigma$ 的电子，且 $\\hat{n}_{j,\\sigma} = \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j,\\sigma}$。通过离散傅里叶变换（布洛赫定理）定义适应布洛赫定理的产生算符，\n$$\n\\hat{c}_{k,\\sigma}^\\dagger \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} e^{i k R_j} \\, \\hat{c}_{j,\\sigma}^\\dagger, \\quad R_j = j a, \\quad k_m = \\frac{2\\pi}{N a} m, \\; m \\in \\{0,1,\\dots,N-1\\}.\n$$\n仅使用上述基础，推导 $k$ 空间哈密顿量，并证明其可以分解为独立的晶体动量部分，\n$$\nH \\;=\\; \\sum_{k} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} E(k) \\, \\hat{n}_{k,\\sigma}, \\qquad E(k) = \\epsilon - 2 t \\cos(k a),\n$$\n其中余弦函数的参数以弧度为单位。对于变分量子本征求解器 (VQE)，可以通过将费米子数算符映射到量子比特来分别模拟每个 $k$ 分量。在 Jordan–Wigner (JW) 变换下，每个自旋轨道映射到一个量子比特，数算符映射为 $\\hat{n} \\mapsto \\tfrac{1}{2} (I - Z)$。因此，此模型中每个 $k$ 分量所需的量子比特数为 $Q_k = 2$（每个自旋一个量子比特），而未使用 $k$ 分量分解的朴素实空间映射则使用 $Q_{\\text{full}} = 2 N$ 个量子比特。将因 $k$ 锥化（k-tapering）而节省的量子比特数定义为 $S = Q_{\\text{full}} - Q_k$，节省率定义为 $r = S / Q_{\\text{full}}$。\n\n您的程序必须：\n- 为每个测试用例构建离散的晶体动量网格 $k_m = \\tfrac{2\\pi}{N a} m$，并计算相应的能带能量 $E(k_m) = \\epsilon - 2 t \\cos(k_m a)$，对余弦函数使用弧度。\n- 计算 $Q_{\\text{full}} = 2 N$、$Q_k = 2$、$S = Q_{\\text{full}} - Q_k$ 和 $r = S/Q_{\\text{full}}$。\n- 对每个测试用例，报告在允许的 $k$ 值范围内离散能带能量的最小值和最大值，分别表示为 $E_{\\min}$ 和 $E_{\\max}$，并以电子伏特 (eV) 为单位表示。\n- 所有能量均以电子伏特 (eV) 表示，所有角度均使用弧度。在最终输出中，将 $r$、$E_{\\min}$ 和 $E_{\\max}$ 四舍五入到六位小数。\n\n测试套件：\n为以下参数集 $(N, a, \\epsilon, t)$ 提供结果，其中 $a$ 的单位是埃，$(\\epsilon, t)$ 的单位是电子伏特：\n- 案例 1：$(N, a, \\epsilon, t) = (8, 1.0, -0.3, 1.5)$。\n- 案例 2：$(N, a, \\epsilon, t) = (3, 1.4, 0.0, 1.0)$。\n- 案例 3（边界情况，零跃迁）：$(N, a, \\epsilon, t) = (4, 1.2, -0.5, 0.0)$。\n- 案例 4（更大系统）：$(N, a, \\epsilon, t) = (16, 0.74, -0.1, 2.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含每个案例结果的列表。每个案例的结果必须是 $[Q_{\\text{full}}, Q_k, S, r, E_{\\min}, E_{\\max}]$ 形式的列表，其中 $Q_{\\text{full}}$、$Q_k$ 和 $S$ 是整数，$r$、$E_{\\min}$、$E_{\\max}$ 是四舍五入到六位小数的十进制数。将这些按案例划分的列表聚合到一个外部列表中，并以单行形式打印，例如：\n$[[Q_{\\text{full}},Q_k,S,r,E_{\\min},E_{\\max}],\\dots]$。",
            "solution": "该问题已被验证并被认为是合理的。它在科学上基于固态物理和量子计算的原理，其提法恰当，具有一套完整的定义和参数，并以客观、正式的语言表述。因此，我们可以继续提供完整的解决方案。\n\n该问题要求分析一个简化的一维周期性氢原子链，重点是在利用平移对称性的情况下，变分量子本征求解器 (VQE) 上下文中计算资源的节省。任务的核心是推导动量空间（$k$空间）中的哈密顿量，然后用它来计算几个参数集的能带结构性质。\n\n首先，我们从给定的实空间（紧束缚）表示法推导哈密顿量的 $k$ 空间表示。实空间哈密顿量由下式给出：\n$$ H \\;=\\; \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\epsilon \\, \\hat{n}_{j,\\sigma} \\;-\\; t \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j+1,\\sigma} \\;+\\; \\hat{c}_{j+1,\\sigma}^\\dagger \\hat{c}_{j,\\sigma} \\right) $$\n这里，$j$ 索引链中的 $N$ 个格点，$\\sigma$ 是自旋，$\\epsilon$ 是在位能，$t$ 是最近邻跃迁振幅。算符 $\\hat{c}_{j,\\sigma}^\\dagger$ 和 $\\hat{c}_{j,\\sigma}$ 是在格点 $j$ 上自旋为 $\\sigma$ 的电子的费米子产生和湮灭算符，而 $\\hat{n}_{j,\\sigma} = \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j,\\sigma}$ 是数算符。\n\n为了对角化这个哈密顿量，我们对费米子算符应用离散傅里叶变换，这等效于由于系统的平移对称性而转换到布洛赫波基。适应布洛赫定理的产生算符定义为：\n$$ \\hat{c}_{k,\\sigma}^\\dagger \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} e^{i k R_j} \\, \\hat{c}_{j,\\sigma}^\\dagger $$\n其中 $R_j = j a$ 是格点 $j$ 的位置，$k$ 属于第一布里渊区中允许的离散晶体动量集合，$k_m = \\frac{2\\pi m}{Na}$，$m \\in \\{0, 1, \\dots, N-1\\}$。逆变换为：\n$$ \\hat{c}_{j,\\sigma}^\\dagger \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{k} e^{-i k R_j} \\, \\hat{c}_{k,\\sigma}^\\dagger, \\qquad \\hat{c}_{j,\\sigma} \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{k'} e^{i k' R_j} \\, \\hat{c}_{k',\\sigma} $$\n\n现在我们将这些代入哈密顿量中，逐项进行。\n在位能项变为：\n$$ \\sum_{j,\\sigma} \\epsilon \\, \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j,\\sigma} \\;=\\; \\sum_{j,\\sigma} \\epsilon \\left( \\frac{1}{\\sqrt{N}} \\sum_{k} e^{-i k R_j} \\hat{c}_{k,\\sigma}^\\dagger \\right) \\left( \\frac{1}{\\sqrt{N}} \\sum_{k'} e^{i k' R_j} \\hat{c}_{k',\\sigma} \\right) $$\n$$ \\;=\\; \\frac{\\epsilon}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} \\sum_{j=0}^{N-1} e^{i(k'-k)R_j} $$\n对 $j$ 的求和是一个几何级数，其值为 $N \\delta_{k,k'}$。这个正交关系简化了表达式：\n$$ \\frac{\\epsilon}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} (N \\delta_{k,k'}) \\;=\\; \\sum_{k,\\sigma} \\epsilon \\, \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k,\\sigma} \\;=\\; \\sum_{k,\\sigma} \\epsilon \\, \\hat{n}_{k,\\sigma} $$\n在位能项在 $k$ 基下是对角的。\n\n接下来，我们变换跃迁项。考虑第一部分 $\\sum_{j,\\sigma} \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j+1,\\sigma}$：\n$$ \\sum_{j,\\sigma} \\left( \\frac{1}{\\sqrt{N}} \\sum_{k} e^{-i k R_j} \\hat{c}_{k,\\sigma}^\\dagger \\right) \\left( \\frac{1}{\\sqrt{N}} \\sum_{k'} e^{i k' R_{j+1}} \\hat{c}_{k',\\sigma} \\right) $$\n使用 $R_{j+1} = R_j + a$，这变为：\n$$ \\frac{1}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} e^{i k' a} \\sum_{j=0}^{N-1} e^{i(k'-k)R_j} \\;=\\; \\frac{1}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} e^{i k' a} (N \\delta_{k,k'}) \\;=\\; \\sum_{k,\\sigma} e^{i k a} \\hat{n}_{k,\\sigma} $$\n厄米共轭项 $\\sum_{j,\\sigma} \\hat{c}_{j+1,\\sigma}^\\dagger \\hat{c}_{j,\\sigma}$ 产生 $\\sum_{k,\\sigma} e^{-i k a} \\hat{n}_{k,\\sigma}$。\n\n合并所有项，完整的哈密顿量是：\n$$ H \\;=\\; \\sum_{k,\\sigma} \\epsilon \\, \\hat{n}_{k,\\sigma} - t \\sum_{k,\\sigma} (e^{i k a} + e^{-i k a}) \\hat{n}_{k,\\sigma} \\;=\\; \\sum_{k,\\sigma} (\\epsilon - 2t \\cos(ka)) \\hat{n}_{k,\\sigma} $$\n这证实了哈密顿量在动量空间中的块对角结构：\n$$ H \\;=\\; \\sum_{k} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} E(k) \\, \\hat{n}_{k,\\sigma}, \\qquad \\text{with } E(k) = \\epsilon - 2 t \\cos(k a) $$\n这个推导验证了所提供的能量色散关系。每个 $k$ 分量都是独立的。在 VQE 模拟中，我们不必模拟完整的 $2N$ 量子比特系统，而是可以单独模拟每个 $k$ 分量。对于每个 $k$，有两个自旋轨道（$\\uparrow$ 和 $\\downarrow$），它们映射到 $Q_k=2$ 个量子比特。与不考虑对称性的实空间模拟所需的 $Q_{\\text{full}} = 2N$ 个量子比特相比，这显著节省了量子比特资源。\n\n计算步骤如下：\n对于每个测试用例 $(N, a, \\epsilon, t)$：\n1.  计算完整系统的量子比特数 $Q_{\\text{full}} = 2N$，以及单个 $k$ 分量的量子比特数 $Q_k = 2$。\n2.  计算绝对量子比特节省量 $S = Q_{\\text{full}} - Q_k = 2N - 2$，以及节省率 $r = S / Q_{\\text{full}} = 1 - 1/N$。\n3.  生成晶体动量的离散网格 $k_m = \\frac{2\\pi m}{Na}$，其中 $m = 0, 1, \\dots, N-1$。\n4.  对于网格上的每个 $k_m$，计算能量 $E(k_m) = \\epsilon - 2t\\cos(k_m a)$。注意余弦函数的参数是 $k_m a = \\frac{2\\pi m}{N}$，它与晶格常数 $a$ 无关。\n5.  确定这组能量的最小值和最大值，$E_{\\min} = \\min_{m} E(k_m)$ 和 $E_{\\max} = \\max_{m} E(k_m)$。\n6.  将 $r$、$E_{\\min}$ 和 $E_{\\max}$ 的值四舍五入到六位小数。\n7.  将每个测试用例的结果 $[Q_{\\text{full}}, Q_k, S, r, E_{\\min}, E_{\\max}]$ 聚合到一个最终列表中。\n\n能带 $E(k) = \\epsilon - 2t \\cos(ka)$ 的极值取决于余弦项在离散 $k$ 网格上的极值。\n- 对于 $t>0$，$E(k)$ 在 $\\cos(ka)$ 最大化时最小化。最大值为 $\\cos(0) = 1$（当 $m=0$ 时），得出 $E_{\\min} = \\epsilon - 2t$。\n- 对于 $t>0$，$E(k)$ 在 $\\cos(ka)$ 最小化时最大化。网格上 $\\cos(\\frac{2\\pi m}{N})$ 的最小值决定了 $E_{\\max}$。如果 $N$ 是偶数，最小值为 $\\cos(\\pi) = -1$，得出 $E_{\\max} = \\epsilon + 2t$。如果 $N$ 是奇数，最小值为 $\\cos(\\frac{2\\pi \\lfloor N/2 \\rfloor}{N})$。\n如果 $t=0$，能带是平的，$E(k) = \\epsilon$ 对所有 $k$ 成立，因此 $E_{\\min} = E_{\\max} = \\epsilon$。\n实现将数值计算所有能量并直接找到最小值和最大值，这对所有情况都是稳健的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not required for this problem.\n\ndef solve():\n    \"\"\"\n    Computes VQE-related properties for a 1D periodic hydrogen chain\n    for a given set of test cases, leveraging translational symmetry.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (N, a, epsilon, t)\n    # N: number of unit cells (integer)\n    # a: lattice constant in angstroms (float)\n    # epsilon: on-site energy in eV (float)\n    # t: nearest-neighbor hopping amplitude in eV (float)\n    test_cases = [\n        (8, 1.0, -0.3, 1.5),\n        (3, 1.4, 0.0, 1.0),\n        (4, 1.2, -0.5, 0.0),\n        (16, 0.74, -0.1, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, epsilon, t = case\n\n        # --- Qubit Resource Calculation ---\n        # Qubits for full real-space simulation\n        Q_full = 2 * N\n        # Qubits for a single k-sector simulation\n        Q_k = 2\n        # Qubit savings\n        S = Q_full - Q_k\n        # Savings ratio\n        if N > 0:\n            r = S / Q_full\n        else:\n            r = 0.0 # Avoid division by zero, though N > 0 is implied.\n\n        # --- Energy Band Calculation ---\n        # m ranges from 0 to N-1\n        m_values = np.arange(N)\n        \n        # The argument for the cosine function is k*a = (2*pi*m / (N*a)) * a = 2*pi*m / N\n        # The lattice constant 'a' cancels out.\n        cos_args = 2 * np.pi * m_values / N\n        \n        # Calculate energies for all k-points\n        # E(k) = epsilon - 2*t*cos(k*a)\n        energies = epsilon - 2 * t * np.cos(cos_args)\n        \n        # Find the minimum and maximum of the discrete band energies\n        E_min = np.min(energies)\n        E_max = np.max(energies)\n\n        # --- Rounding and Formatting ---\n        # Round r, E_min, E_max to six decimal places as required.\n        r_rounded = round(r, 6)\n        E_min_rounded = round(E_min, 6)\n        E_max_rounded = round(E_max, 6)\n\n        # Append the list of results for the current case\n        case_result = [Q_full, Q_k, S, r_rounded, E_min_rounded, E_max_rounded]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists in Python matches the desired output.\n    # Using join and map to construct the string representation as per the template.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在变分量子本征求解器（VQE）中，即使哈密顿量已被简化，高效地测量其期望值仍然是一个重大挑战。本练习将引导您设计并实现一个完整的测量优化工作流，包括将费米子哈密顿量映射为泡利算符串、利用图着色算法对可同时测量的算符进行分组，以及估算达到目标精度所需的总测量次数。这个实践将让您掌握解决VQE算法中测量开销这一核心瓶颈的关键技术。",
            "id": "3481711",
            "problem": "您的任务是设计并分析一种测量策略，用于在变分量子本征求解器（VQE）的框架内，通过使用基于图着色的按比特通勤测量分组方法，来估算一个扩展Hubbard哈密顿量的基态能量期望值。您必须实现一种算法方法，该方法从标准的二次量子化费米子定义和Jordan–Wigner变换开始，根据按比特通勤准则构建泡利串的冲突图，对着色该图以形成测量分组，然后推导出这些分组间的最佳测量次数分配，以达到指定的能量精度目标。您的最终程序必须计算并输出多个测试用例的总测量代价。\n\n基本原理：\n考虑一个长度为$L$且包含有自旋电子的一维链。设$t$为跃迁振幅，$U$为在位相互作用强度，$V$为最近邻密度-密度相互作用强度。在二次量子化形式下，扩展Hubbard哈密顿量为\n$$\nH = -t \\sum_{i=0}^{L-2} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + a_{i+1,\\sigma}^{\\dagger} a_{i,\\sigma} \\right)\n+ U \\sum_{i=0}^{L-1} n_{i,\\uparrow} n_{i,\\downarrow}\n+ V \\sum_{i=0}^{L-2} \\sum_{\\sigma,\\sigma' \\in \\{\\uparrow,\\downarrow\\}} n_{i,\\sigma} n_{i+1,\\sigma'} ,\n$$\n其中 $a_{i,\\sigma}^{\\dagger}$ 和 $a_{i,\\sigma}$ 是费米子产生和湮灭算符，而 $n_{i,\\sigma} = a_{i,\\sigma}^{\\dagger} a_{i,\\sigma}$ 是粒子数算符。\n\n到量子比特的映射：\n采用Jordan–Wigner变换，并按照位点和自旋固定轨道排序，其中每个位点 $i \\in \\{0,\\dots,L-1\\}$ 有两个轨道：自旋向上和自旋向下。量子比特总数为 $N_q = 2L$，轨道到量子比特的索引映射为\n$$\np(i,\\sigma) = \\begin{cases}\n2i  & \\text{for } \\sigma = \\uparrow,\\\\\n2i+1 & \\text{for } \\sigma = \\downarrow.\n\\end{cases}\n$$\nJordan–Wigner变换使用以下经过充分检验的恒等式：\n$$\na_p = \\left( \\prod_{q=0}^{p-1} Z_q \\right) \\frac{X_p + i Y_p}{2}, \\quad\na_p^{\\dagger} = \\left( \\prod_{q=0}^{p-1} Z_q \\right) \\frac{X_p - i Y_p}{2}, \\quad\nn_p = a_p^{\\dagger} a_p = \\frac{1 - Z_p}{2}.\n$$\n对于最近邻跃迁（$p  q$）项，如$a_p^{\\dagger}a_q + a_q^{\\dagger}a_p$，其JW变换结果为 $\\frac{1}{2} (X_p Z_{p+1} \\dots Z_{q-1} X_q + Y_p Z_{p+1} \\dots Z_{q-1} Y_q)$。\n\n测量策略：\n哈密顿量可写为 $H = \\sum_j c_j P_j$，其中 $P_j$ 是泡利串。为了测量 $\\langle H \\rangle$，我们对泡利串进行分组。\n- **按比特通勤（Qubit-Wise Commuting, QWC）**：如果两个泡利串在每个量子比特位置上的算符都对易，则它们是QWC的。这意味着在任何位置上，要么至少有一个算符是单位算符 $I$，要么两个算符相同。\n- **图着色**：构建一个冲突图，其中每个顶点代表一个非单位的泡利串$P_j$。如果两个泡利串非QWC，则在对应顶点间连一条边。使用贪心图着色算法（按度数降序处理顶点）对该图进行着色，颜色相同的顶点构成一个可同时测量的组。\n\n测量代价：\n对于一个包含泡利串 $\\{P_j\\}_{j \\in G_k}$ 的测量组 $G_k$，其单次测量方差上限为 $V_k = \\sum_{j \\in G_k} c_j^2$。为了在总能量估计中达到 $\\epsilon$ 的精度，所需的最小总测量次数 $S_{\\min}$ 由以下公式给出：\n$$\nS_{\\min} = \\frac{\\left( \\sum_k \\sqrt{V_k} \\right)^2}{\\epsilon^2},\n$$\n其中求和遍历所有测量组。\n\n您的任务：\n编写一个程序，该程序：\n1. 对于给定的参数 $L, t, U, V$，生成扩展Hubbard模型的量子比特哈密顿量，即一组泡利串及其系数。\n2. 基于QWC准则构建泡利串之间的冲突图。\n3. 应用贪心图着色算法（按度数降序）将泡利串分组。\n4. 使用提供的公式计算达到目标能量精度 $\\epsilon$ 所需的最小总测量次数 $S_{\\text{total}}$，并将结果向上取整到最近的整数。\n\n测试用例：\n为以下参数集 $(L, t, U, V, \\epsilon)$ 计算总测量代价：\n- 案例 1: $(2, 1.0, 4.0, 1.0, 0.01)$\n- 案例 2: $(3, 1.0, 0.0, 0.0, 0.02)$\n- 案例 3: $(1, 0.0, 3.0, 0.0, 0.001)$\n- 案例 4: $(4, 0.5, 2.0, 0.5, 0.005)$\n- 案例 5: $(2, 0.0, 0.0, 0.0, 0.01)$\n\n输出格式：\n生成一个单行输出，其中包含一个列表，列表中的每个元素是对应测试用例计算出的总测量次数。例如：`[cost1, cost2, ...]`",
            "solution": "用户提供的问题是计算量子物理学中一个明确定义的任务，具体涉及在扩展Hubbard模型上运行变分量子本征求解器（VQE）算法的资源估算。问题陈述在科学上是合理的、内部一致的，并提供了构建唯一算法解决方案所需的所有必要信息。因此，它被认为是一个有效的问题。\n\n解决方案系统地遵循以下步骤：\n1.  **通过Jordan-Wigner变换构建哈密顿量**：将二次量子化的扩展Hubbard哈密顿量转换为量子比特哈密顿量，即具有实系数的多量子比特泡利算符（泡利串）之和。\n2.  **生成冲突图**：基于按比特通勤（QWC）准则构建一个冲突图。该图的顶点是哈密顿量中的非单位泡利串。如果两个顶点对应的泡利串不是QWC的，则在它们之间连接一条边。\n3.  **贪心图着色**：使用贪心算法对着色冲突图。顶点按度数降序排列，以优先为约束最强的泡利串着色。每个色类形成一个测量组，因为其中的所有泡利串都是相互QWC的。\n4.  **最佳测量次数分配和代价计算**：为每个测量组计算一个方差上限。利用这些方差和目标能量精度$\\epsilon$，确定最佳的测量次数分布以最小化总测量次数（shots）。然后计算总测量代价并向上取整到最近的整数。\n\n我们将在下面详细介绍这些步骤。\n\n### 1. 量子比特哈密顿量公式化\n\n扩展Hubbard哈密顿量由下式给出：\n$$\nH = -t \\sum_{i=0}^{L-2} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + a_{i+1,\\sigma}^{\\dagger} a_{i,\\sigma} \\right)\n+ U \\sum_{i=0}^{L-1} n_{i,\\uparrow} n_{i,\\downarrow}\n+ V \\sum_{i=0}^{L-2} \\sum_{\\sigma,\\sigma' \\in \\{\\uparrow,\\downarrow\\}} n_{i,\\sigma} n_{i+1,\\sigma'}\n$$\n系统有$L$个位点，考虑到自旋，这对应于$2L$个自旋轨道。使用指定的Jordan-Wigner（JW）映射，我们将这$2L$个轨道映射到$N_q = 2L$个量子比特。对于位点$i$上自旋为$\\sigma$的自旋轨道，其量子比特索引$p$为$p(i,\\sigma) = 2i$（当$\\sigma=\\uparrow$时）和$p(i,\\sigma) = 2i+1$（当$\\sigma=\\downarrow$时）。\n\n将提供的JW变换规则应用于$H$的每一项：\n\n- **跃迁项 ($t$)**：对于每个位点 $i \\in [0, L-2]$ 和自旋 $\\sigma$，我们有一项 $-t(a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + h.c.)$。令 $p = p(i,\\sigma)$ 且 $q = p(i+1,\\sigma)$。JW变换产生：\n$$\na_p^{\\dagger} a_q + a_q^{\\dagger} a_p = \\frac{1}{2}\\left( X_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) X_q + Y_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) Y_q \\right)\n$$\n这两个泡利串中的每一个都获得一个系数$-t/2$。\n\n- **在位相互作用项 ($U$)**：对于每个位点 $i \\in [0, L-1]$，我们有 $U n_{i,\\uparrow} n_{i,\\downarrow}$。令 $p = p(i,\\uparrow)=2i$ 且 $q = p(i,\\downarrow)=2i+1$。粒子数算符为 $n_k = (1-Z_k)/2$。该乘积变为：\n$$\nU n_p n_q = U \\frac{1 - Z_p}{2} \\frac{1 - Z_q}{2} = \\frac{U}{4} (I - Z_p - Z_q + Z_p Z_q)\n$$\n这贡献了三个非单位泡利串：系数为$-U/4$的$Z_p$、系数为$-U/4$的$Z_q$和系数为$U/4$的$Z_p Z_q$。单位项$I$被排除在测量分析之外，因为它的期望值是精确已知的并且方差为零。\n\n- **最近邻相互作用项 ($V$)**：对于每个位点 $i \\in [0, L-2]$，我们有 $V \\sum_{\\sigma,\\sigma'} n_{i,\\sigma} n_{i+1,\\sigma'}$。该项可以重写为 $V(n_{i,\\uparrow}+n_{i,\\downarrow})(n_{i+1,\\uparrow}+n_{i+1,\\downarrow})$。令 $p_0=2i, p_1=2i+1, q_0=2(i+1), q_1=2(i+1)+1$。该项为 $V(n_{p_0}+n_{p_1})(n_{q_0}+n_{q_1})$。使用 $n_k=(1-Z_k)/2$ 展开此项会产生大量的泡利-Z项。系统地展开会得到：\n    - 对于 $k \\in \\{p_0, p_1, q_0, q_1\\}$ 的单比特项 $Z_k$，每个系数为$-V/2$。\n    - 对于 $\\alpha,\\beta \\in \\{0,1\\}$ 的双比特项 $Z_{p_\\alpha}Z_{q_\\beta}$，每个系数为$V/4$。\n这些项是为每个$i$生成的并进行汇总。来自不同物理项的相同泡利串的系数会被相加。\n\n### 2. 通过图着色进行测量分组\n\n得到的量子比特哈密顿量为 $H = \\sum_j c_j P_j$。为了估算 $\\langle H \\rangle$，我们需要测量每个 $\\langle P_j \\rangle$。我们将泡利串 $P_j$ 分组以减少不同测量设置的数量。\n\n- **按比特通勤 (QWC)**：两个泡利串 $P_A$ 和 $P_B$ 是QWC的，如果对于每个量子比特位置 $k$，它们各自的单比特算符 $P_{A,k}$ 和 $P_{B,k}$ 对易。如果它们中至少有一个是单位算符$I$，或者它们是相同的算符 ($P_{A,k} = P_{B,k}$)，则此条件满足。对于不同的非单位算符 $\\{X,Y,Z\\}$，任何一对都不能对易。因此，条件简化为：如果不存在位置 $k$ 使得 $P_{A,k} \\neq I$，$P_{B,k} \\neq I$ 且 $P_{A,k} \\neq P_{B,k}$，则 $P_A$ 和 $P_B$ 是QWC的。\n\n- **冲突图**：我们构建一个图，其中每个顶点代表一个非单位泡利串 $P_j$。如果两个顶点对应的泡利串*不是*QWC的，则在这两个顶点之间放置一条边。\n\n- **贪心着色**：应用贪心着色算法来找到冲突图的一个有效顶点着色。\n    1. 顶点（泡利串）按其在冲突图中的度数降序排序。平局由泡利串的初始索引打破。\n    2. 我们遍历排序后的顶点。对于每个顶点 $v$，我们为其分配尚未被其任何已着色邻居使用的最小非负整数颜色。\n    3. 所有被分配相同颜色的顶点形成一个测量组。根据构造，一个组中的所有泡利串都是相互QWC的。\n\n### 3. 测量代价估算\n\n能量估计的总方差是每个组方差的总和：$\\mathrm{Var}(\\langle H \\rangle) = \\sum_k \\mathrm{Var}(\\hat{E}_k)$，其中 $\\hat{E}_k$ 是从组 $G_k$ 得到的能量估计。对于 $N_k$ 次测量，$\\mathrm{Var}(\\hat{E}_k) = \\sigma_k^2/N_k$，其中 $\\sigma_k^2$ 是该组的单次测量方差。问题提供了一个保守的界限：\n$$\n\\sigma_k^2 \\le V_k = \\sum_{j \\in G_k} c_j^2\n$$\n总方差必须小于或等于目标精度 $\\epsilon$ 的平方：\n$$\n\\sum_k \\frac{V_k}{N_k} \\le \\epsilon^2\n$$\n为了在该约束下最小化总测量代价 $S = \\sum_k N_k$，我们使用拉格朗日乘子法，得到最优分配：\n$$\nN_k = \\frac{\\sqrt{V_k} \\sum_j \\sqrt{V_j}}{\\epsilon^2}\n$$\n最小总测量代价 $S_{\\min}$ 于是为：\n$$\nS_{\\min} = \\sum_k N_k = \\frac{\\left( \\sum_j \\sqrt{V_j} \\right) \\left( \\sum_k \\sqrt{V_k} \\right)}{\\epsilon^2} = \\frac{\\left( \\sum_k \\sqrt{V_k} \\right)^2}{\\epsilon^2}\n$$\n最终的测量次数是大于或等于 $S_{\\min}$ 的最小整数，即 $\\lceil S_{\\min} \\rceil$。如果哈密顿量不包含非单位项（即它是一个常数），则测量代价为$0$。\n\n整个过程的实现代码在最终答案代码块中提供。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Pauli operators are represented by integers: 0:I, 1:X, 2:Y, 3:Z\n    PAULI_I, PAULI_X, PAULI_Y, PAULI_Z = 0, 1, 2, 3\n\n    def build_hamiltonian(L, t, U, V):\n        \"\"\"\n        Constructs the qubit Hamiltonian as a dictionary of {Pauli_tuple: coefficient}.\n        \"\"\"\n        if L == 0:\n            return {}\n            \n        num_qubits = 2 * L\n        hamiltonian = defaultdict(float)\n\n        def add_pauli(p_str, coeff):\n            hamiltonian[p_str] += coeff\n        \n        # Helper to create a Pauli string from a dict of {qubit_idx: operator}\n        def create_pauli(op_dict):\n            p_list = [PAULI_I] * num_qubits\n            for q_idx, op in op_dict.items():\n                p_list[q_idx] = op\n            return tuple(p_list)\n\n        # 1. Hopping term (-t)\n        if t != 0.0:\n            for i in range(L - 1):\n                for sigma in range(2):  # 0 for up, 1 for down\n                    p = 2 * i + sigma\n                    q = 2 * (i + 1) + sigma\n                    \n                    z_chain = {r: PAULI_Z for r in range(p + 1, q)}\n                    \n                    # X_p ... Z ... X_q term\n                    op_dict_x = z_chain.copy()\n                    op_dict_x[p] = PAULI_X\n                    op_dict_x[q] = PAULI_X\n                    add_pauli(create_pauli(op_dict_x), -t / 2.0)\n                    \n                    # Y_p ... Z ... Y_q term\n                    op_dict_y = z_chain.copy()\n                    op_dict_y[p] = PAULI_Y\n                    op_dict_y[q] = PAULI_Y\n                    add_pauli(create_pauli(op_dict_y), -t / 2.0)\n\n        # 2. On-site interaction term (U)\n        if U != 0.0:\n            for i in range(L):\n                p_up = 2 * i\n                p_down = 2 * i + 1\n                \n                # U/4 * (I - Z_up - Z_down + Z_upZ_down)\n                # We ignore the constant term I for measurement grouping\n                add_pauli(create_pauli({p_up: PAULI_Z}), -U / 4.0)\n                add_pauli(create_pauli({p_down: PAULI_Z}), -U / 4.0)\n                add_pauli(create_pauli({p_up: PAULI_Z, p_down: PAULI_Z}), U / 4.0)\n\n        # 3. Nearest-neighbor interaction term (V)\n        if V != 0.0:\n            for i in range(L - 1):\n                # V * (n_i,up + n_i,down) * (n_i+1,up + n_i+1,down)\n                # V * sum_{s,s'} n_{i,s} n_{i+1,s'}\n                qubits_i = [2 * i, 2 * i + 1]\n                qubits_i1 = [2 * (i + 1), 2 * (i + 1) + 1]\n                \n                for p_idx in qubits_i:\n                    for q_idx in qubits_i1:\n                        # V * n_p * n_q = V/4 * (I - Z_p - Z_q + Z_p*Z_q)\n                        # We ignore the constant term\n                        add_pauli(create_pauli({p_idx: PAULI_Z}), -V / 4.0)\n                        add_pauli(create_pauli({q_idx: PAULI_Z}), -V / 4.0)\n                        add_pauli(create_pauli({p_idx: PAULI_Z, q_idx: PAULI_Z}), V / 4.0)\n        \n        # Clean up terms with coefficients close to zero\n        final_hamiltonian = {p: c for p, c in hamiltonian.items() if not np.isclose(c, 0)}\n        return final_hamiltonian\n\n    def are_qwc(p1, p2):\n        \"\"\"Checks if two Pauli strings are qubit-wise commuting.\"\"\"\n        for op1, op2 in zip(p1, p2):\n            if op1 != PAULI_I and op2 != PAULI_I and op1 != op2:\n                return False\n        return True\n\n    def calculate_shot_cost(L, t, U, V, epsilon):\n        \"\"\"\n        Performs the full calculation pipeline for a single test case.\n        \"\"\"\n        hamiltonian = build_hamiltonian(L, t, U, V)\n        \n        if not hamiltonian:\n            return 0\n        \n        pauli_list = list(hamiltonian.keys())\n        coeffs = list(hamiltonian.values())\n        num_paulis = len(pauli_list)\n\n        # Build conflict graph\n        adj = [[] for _ in range(num_paulis)]\n        degrees = [0] * num_paulis\n        for i in range(num_paulis):\n            for j in range(i + 1, num_paulis):\n                if not are_qwc(pauli_list[i], pauli_list[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n                    degrees[i] += 1\n                    degrees[j] += 1\n        \n        # Greedy coloring\n        # Order vertices by decreasing degree (stable sort breaks ties by original index)\n        sorted_vertices = sorted(range(num_paulis), key=lambda i: degrees[i], reverse=True)\n        \n        colors = [-1] * num_paulis\n        num_colors = 0\n        \n        for i in sorted_vertices:\n            neighbor_colors = {colors[j] for j in adj[i] if colors[j] != -1}\n            \n            c = 0\n            while True:\n                if c not in neighbor_colors:\n                    colors[i] = c\n                    if c + 1  num_colors:\n                        num_colors = c + 1\n                    break\n                c += 1\n\n        # Calculate group variances (V_k)\n        group_variances = [0.0] * num_colors\n        for i in range(num_paulis):\n            color = colors[i]\n            if color != -1:\n                group_variances[color] += coeffs[i]**2\n        \n        # Calculate total shot cost\n        sum_sqrt_V = sum(np.sqrt(v) for v in group_variances if v > 0)\n        s_min = (sum_sqrt_V**2) / (epsilon**2)\n        \n        return int(np.ceil(s_min))\n\n    test_cases = [\n        (2, 1.0, 4.0, 1.0, 0.01),\n        (3, 1.0, 0.0, 0.0, 0.02),\n        (1, 0.0, 3.0, 0.0, 0.001),\n        (4, 0.5, 2.0, 0.5, 0.005),\n        (2, 0.0, 0.0, 0.0, 0.01),\n    ]\n\n    results = []\n    for L, t, U, V, epsilon in test_cases:\n        result = calculate_shot_cost(L, t, U, V, epsilon)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}