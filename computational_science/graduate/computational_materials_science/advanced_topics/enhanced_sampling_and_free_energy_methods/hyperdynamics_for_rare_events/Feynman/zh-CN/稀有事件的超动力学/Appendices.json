{
    "hands_on_practices": [
        {
            "introduction": "掌握任何新方法的关键在于从一个可控的简单系统开始。本练习  将引导您在一个经典的一维双势阱模型中应用超动力学的核心思想。您将通过数值模拟来验证一个关键的理论预测：经过恰当时间重整的偏置动力学模拟，其结果在统计上等同于长时间的无偏置模拟，从而亲手验证超动力学方法的正确性。",
            "id": "3458021",
            "problem": "考虑一个由 $V(x)=a x^4 - b x^2$（其中 $a>0$，$b>0$）定义的一维四次双势阱势，以及一个由 $V_b(x)=\\lambda\\,\\max\\left(0, x_c^2 - x^2\\right)$（其中 $\\lambda\\ge 0$）定义的依赖于构象的偏置势。势盆 $B$ 是闭区间 $[-x_c, x_c]$，势盆的边界是点集 $\\{|x|=x_c\\}$，在此边界上偏置为零。该系统使用 Euler–Maruyama 积分方法，根据过阻尼朗之万动力学演化，其中迁移率设为 $1$，逆热能为 $\\beta$，扩散系数为 $D=1/\\beta$。上划线表示对限制在 $B$ 内的相关稳态分布进行的系综平均。\n\n您的任务是：\n1. 从 Boltzmann 分布和受限配分函数的定义出发，推导超动力学增强因子 $\\alpha$ 的表达式，该因子为 $e^{\\beta V_b(x)}$ 在限制于 $B$ 内的偏置稳态分布上的平衡平均值。用涉及 $V(x)$ 和 $V_b(x)$ 且在 $B$ 上积分的形式显式表达 $\\alpha$，并对给定的参数集通过数值求积法计算 $\\alpha$ 的值。\n2. 从严格位于 $B$ 内部的初始点 $x_0$ 开始，实施两次到达边界 $\\{|x|=x_c\\}$ 的首达模拟：\n   - 无偏置动力学，其漂移项为 $-\\partial_x V(x)$，扩散系数为 $D=1/\\beta$，得到以特征时间 $\\tau_0$ 为单位的无偏置首达时间 $t$。\n   - 偏置超动力学，其漂移项为 $-\\partial_x\\left(V(x)+V_b(x)\\right)$，扩散系数相同，通过重加权规则 $t_{\\text{phys}}=\\sum_{n} \\Delta t\\, e^{\\beta V_b(x_n)}$ 累积物理时间，其中 $x_n$ 是第 $n$ 个时间步开始时的状态，$\\Delta t$ 是数值积分的时间步长。使用双样本 Kolmogorov–Smirnov (KS) 检验来统计验证 $t_{\\text{phys}}$ 的分布是否与 $t$ 的分布相匹配。报告一个布尔值，指示 KS 检验的 p 值是否大于 $0.05$。\n3. 使用以下测试套件。对于每种情况，设置 $x_0=-x_c/2$，所有时间均以 $\\tau_0$ 为单位表示，并对无偏置和偏置模拟执行指定数量的独立轨迹。使用固定的时间步长 $\\Delta t$，并在每条轨迹首次到达 $\\{|x| \\ge x_c\\}$ 时终止。\n   - 情况 A（理想路径）：$a=1.0$, $b=4.0$, $\\beta=4.0$, $\\lambda=1.0$, $x_c=0.6$, $\\Delta t=1\\times 10^{-4}$，轨迹数量 $N=1200$。\n   - 情况 B（边界条件）：$a=1.0$, $b=4.0$, $\\beta=4.0$, $\\lambda=0.0$, $x_c=0.6$, $\\Delta t=1\\times 10^{-4}$，轨迹数量 $N=1000$。\n   - 情况 C（具有更强偏置和更低温度的边缘情况）：$a=1.0$, $b=6.0$, $\\beta=6.0$, $\\lambda=2.5$, $x_c=0.5$, $\\Delta t=7\\times 10^{-5}$，轨迹数量 $N=1200$。\n4. 您的程序必须：\n   - 对每种情况，通过对 $[-x_c,x_c]$ 上的积分进行数值求积来计算 $\\alpha$。\n   - 生成无偏置首达时间 $t$ 和偏置重加权物理时间 $t_{\\text{phys}}$，并对每种情况执行双样本 Kolmogorov–Smirnov (KS) 检验以比较 $t$ 和 $t_{\\text{phys}}$ 的分布，返回一个布尔值，指示 KS 检验的 p 值是否超过 $0.05$。\n   - 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每种情况，输出 $\\alpha$ 的数值（浮点数，保留六位小数），后跟 KS 检验的布尔决策。因此，最终输出必须是包含六个项目的列表：$[\\alpha_A,\\text{KS}_A,\\alpha_B,\\text{KS}_B,\\alpha_C,\\text{KS}_C]$。\n\n使用的基本原理：\n- 一维过阻尼朗之万动力学：$dx_t = -\\partial_x U(x_t)\\,dt + \\sqrt{2D}\\,dW_t$，其中对于无偏置动力学 $U(x)=V(x)$，对于偏置动力学 $U(x)=V(x)+V_b(x)$，$D=1/\\beta$，$W_t$ 是标准 Wiener 过程。\n- 平衡态下的 Boltzmann 统计：对于势 $U(x)$，在 $B$ 内的稳态密度与 $e^{-\\beta U(x)}$ 成正比。\n- 势盆 $B$ 内的超动力学重加权规则：物理时间增量为 $d t_{\\text{phys}} = e^{\\beta V_b(x)}\\, dt$。\n- Kolmogorov–Smirnov (KS) 检验比较两个经验分布函数，并返回一个 p 值，用于评估样本是否可被视为来自同一基础分布。\n\n角度单位不适用。所有物理时间必须以 $\\tau_0$ 为单位报告。增强因子 $\\alpha$ 是无量纲的。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5,result6]”）。",
            "solution": "该问题被验证为具有科学依据、提法明确且客观。它展示了超动力学理论在一个简单一维系统上的标准应用，这是一计算统计物理学中常见的教学示例。所有给定的参数和方程均符合统计力学和随机动力学的原理。关于特征时间单位 $\\tau_0$ 的模糊性已被注意到，但这并不妨碍所需无量纲增强因子 $\\alpha$ 的计算或标度不变的 Kolmogorov-Smirnov 检验结果。因此，我们可以继续提供完整解答。\n\n解答分为两个主要部分：首先是超动力学增强因子 $\\alpha$ 的解析推导和数值计算，其次是实施随机模拟以统计验证超动力学的核心原理。\n\n**1. 增强因子 $\\alpha$ 的推导与计算**\n\n在逆温度 $\\beta$ 下，由势能 $U(x)$ 描述的系统的稳态概率分布是 Boltzmann 分布，$p(x) \\propto e^{-\\beta U(x)}$。\n\n在超动力学模拟中，系统在偏置势 $U_b(x) = V(x) + V_b(x)$ 下演化。当限制在势盆 $B = [-x_c, x_c]$ 内时，相应的稳态概率密度由下式给出：\n$$\np_b(x) = \\frac{1}{Z_b} e^{-\\beta (V(x) + V_b(x))} \\quad \\text{for } x \\in B\n$$\n其中 $Z_b$ 是偏置系统的受限配分函数，由在势盆 $B$ 上的积分定义：\n$$\nZ_b = \\int_{B} e^{-\\beta (V(x) + V_b(x))} dx = \\int_{-x_c}^{x_c} e^{-\\beta (V(x) + V_b(x))} dx\n$$\n问题将增强因子 $\\alpha$ 定义为重加权因子 $e^{\\beta V_b(x)}$ 在此偏置稳态分布上的系综平均。这个平均值，记作 $\\overline{e^{\\beta V_b(x)}}_{\\text{biased}}$，计算如下：\n$$\n\\alpha = \\int_{B} e^{\\beta V_b(x)} p_b(x) dx\n$$\n将 $p_b(x)$ 的表达式代入此积分中，得到：\n$$\n\\alpha = \\int_{-x_c}^{x_c} e^{\\beta V_b(x)} \\left( \\frac{1}{Z_b} e^{-\\beta (V(x) + V_b(x))} \\right) dx = \\frac{1}{Z_b} \\int_{-x_c}^{x_c} e^{\\beta V_b(x)} e^{-\\beta V(x)} e^{-\\beta V_b(x)} dx\n$$\n涉及偏置势的指数项 $e^{\\beta V_b(x)}$ 和 $e^{-\\beta V_b(x)}$ 相互抵消，将表达式简化为：\n$$\n\\alpha = \\frac{1}{Z_b} \\int_{-x_c}^{x_c} e^{-\\beta V(x)} dx\n$$\n我们认识到分子中的积分是原始无偏置系统的受限配分函数，$Z_u = \\int_{-x_c}^{x_c} e^{-\\beta V(x)} dx$。因此，增强因子 $\\alpha$ 可以优雅地表示为无偏置与偏置受限配分函数之比：\n$$\n\\alpha = \\frac{Z_u}{Z_b} = \\frac{\\int_{-x_c}^{x_c} e^{-\\beta V(x)} dx}{\\int_{-x_c}^{x_c} e^{-\\beta (V(x) + V_b(x))} dx}\n$$\n给定 $V(x) = ax^4 - bx^2$ 和 $V_b(x) = \\lambda \\max(0, x_c^2 - x^2)$ 的具体形式，并注意到对于 $x \\in [-x_c, x_c]$，表达式简化为 $V_b(x) = \\lambda(x_c^2 - x^2)$，我们得到用于数值计算的最终公式：\n$$\n\\alpha = \\frac{\\int_{-x_c}^{x_c} \\exp\\left(-\\beta (ax^4 - bx^2)\\right) dx}{\\int_{-x_c}^{x_c} \\exp\\left(-\\beta (ax^4 - bx^2 + \\lambda(x_c^2 - x^2))\\right) dx}\n$$\n这些一维积分使用数值求积法计算。\n\n**2. 模拟与统计验证**\n\n系统的演化由过阻尼朗之万方程描述，我们使用时间步长为 $\\Delta t$ 的 Euler-Maruyama 格式对其进行离散化：\n$$\nx_{n+1} = x_n + F(x_n)\\Delta t + \\sqrt{2D\\Delta t} \\cdot \\mathcal{N}(0,1)\n$$\n此处，$F(x) = -\\partial_x U(x)$ 是力，$D = 1/\\beta$ 是扩散系数，$\\mathcal{N}(0,1)$ 是一个标准正态随机变量。\n\n对于**无偏置模拟**，势为 $U(x) = V(x) = ax^4 - bx^2$，力为 $F_u(x) = 2bx - 4ax^3$。每条轨迹从 $x_0 = -x_c/2$ 开始，演化直到首次到达边界 $\\{|x| \\ge x_c\\}$。总耗时 $t = N_{\\text{steps}} \\Delta t$ 被记录为无偏置首达时间。\n\n对于**偏置（超动力学）模拟**，势盆内的势为 $U(x) = V(x) + V_b(x) = ax^4 - (b+\\lambda)x^2 + \\lambda x_c^2$。力为 $F_b(x) = 2(b+\\lambda)x - 4ax^3$。轨迹在此修正力下演化，这加速了从势盆中的逃逸。物理时间不等同于模拟时间。它是通过累积重加权的时间步长来重构的：\n$$\nt_{\\text{phys}} = \\sum_{n=0}^{N_{\\text{steps}}-1} \\Delta t \\cdot e^{\\beta V_b(x_n)}\n$$\n其中 $x_n$ 是第 $n$ 个时间步开始时粒子的位置。到达边界时累积的 $t_{\\text{phys}}$ 即为重加权的首达时间。\n\n为了**验证该方法**，我们生成 $N$ 个独立的无偏置首达时间样本 $\\{t_i\\}$，以及 $N$ 个偏置重加权时间样本 $\\{t_{\\text{phys}, i}\\}$。超动力学理论假定这两组样本应来自相同的基础统计分布。我们使用双样本 Kolmogorov-Smirnov (KS) 检验来测试这一假设。该检验会得出一个 p 值。当 p 值大于选定的显著性水平（此处为 $0.05$）时，表明没有统计学证据拒绝两分布相同的原假设。程序将为此检验报告一个布尔值（如果 $p > 0.05$ 则为 `True`，否则为 `False`）。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate, stats\n\ndef calculate_alpha(a, b, beta, lambda_, xc):\n    \"\"\"\n    Calculates the hyperdynamics boost factor alpha via numerical quadrature.\n    alpha = Z_u / Z_b = integral(exp(-beta*V)) / integral(exp(-beta*(V+Vb))).\n    \"\"\"\n\n    def unbiased_integrand(x):\n        \"\"\"Integrand for the unbiased partition function Z_u.\"\"\"\n        V = a * x**4 - b * x**2\n        return np.exp(-beta * V)\n\n    def biased_integrand(x):\n        \"\"\"Integrand for the biased partition function Z_b.\"\"\"\n        V = a * x**4 - b * x**2\n        # Inside the basin [-xc, xc], max(0, xc^2 - x^2) is (xc^2 - x^2)\n        Vb = lambda_ * (xc**2 - x**2)\n        return np.exp(-beta * (V + Vb))\n\n    # Numerical integration over the basin B = [-xc, xc]\n    Z_u, _ = integrate.quad(unbiased_integrand, -xc, xc, limit=200)\n    Z_b, _ = integrate.quad(biased_integrand, -xc, xc, limit=200)\n\n    # Avoid division by zero, though Z_b should always be positive.\n    if Z_b == 0:\n        return np.inf\n    \n    return Z_u / Z_b\n\ndef run_simulations(params):\n    \"\"\"\n    Runs both unbiased and biased simulations to collect first-passage times.\n    \"\"\"\n    a, b, beta, lambda_, xc, dt, N = params['a'], params['b'], params['beta'], params['lambda_'], params['xc'], params['dt'], params['N']\n    \n    D = 1.0 / beta\n    x0 = -xc / 2.0\n    \n    sqrt_2Ddt = np.sqrt(2 * D * dt)\n\n    def simulate_trajectories(is_biased):\n        \"\"\"Helper function to run N trajectories for one type of dynamics.\"\"\"\n        times = np.zeros(N)\n        for i in range(N):\n            x = x0\n            t_physical = 0.0\n            t_simulation = 0.0\n\n            while abs(x)  xc:\n                x_n = x  # Position at start of step\n                \n                if is_biased:\n                    force = 2 * (b + lambda_) * x_n - 4 * a * x_n**3\n                else:\n                    force = 2 * b * x_n - 4 * a * x_n**3\n                \n                # Euler-Maruyama step\n                noise_term = sqrt_2Ddt * np.random.randn()\n                x = x_n + force * dt + noise_term\n                \n                # Time accumulation\n                if is_biased:\n                    Vb = lambda_ * (xc**2 - x_n**2)\n                    t_physical += dt * np.exp(beta * Vb)\n                else:\n                    t_simulation += dt\n\n            if is_biased:\n                times[i] = t_physical\n            else:\n                times[i] = t_simulation\n        return times\n\n    unbiased_times = simulate_trajectories(is_biased=False)\n    biased_reweighted_times = simulate_trajectories(is_biased=True)\n    \n    return unbiased_times, biased_reweighted_times\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 1.0, 'b': 4.0, 'beta': 4.0, 'lambda_': 1.0, 'xc': 0.6, 'dt': 1e-4, 'N': 1200},\n        {'a': 1.0, 'b': 4.0, 'beta': 4.0, 'lambda_': 0.0, 'xc': 0.6, 'dt': 1e-4, 'N': 1000},\n        {'a': 1.0, 'b': 6.0, 'beta': 6.0, 'lambda_': 2.5, 'xc': 0.5, 'dt': 7e-5, 'N': 1200},\n    ]\n\n    results = []\n    # Set a seed for reproducibility of the stochastic simulations\n    np.random.seed(42)\n\n    for case in test_cases:\n        # Task 1: Compute boost factor alpha\n        alpha = calculate_alpha(case['a'], case['b'], case['beta'], case['lambda_'], case['xc'])\n        results.append(str(round(alpha, 6)))\n\n        # Task 2  3: Run simulations and perform KS test\n        t_unbiased, t_phys_biased = run_simulations(case)\n        \n        # Two-sample Kolmogorov-Smirnov test\n        _ks_statistic, p_value = stats.ks_2samp(t_unbiased, t_phys_biased)\n        \n        # Report boolean for p-value > 0.05\n        ks_decision = p_value > 0.05\n        results.append(str(ks_decision))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本原理后，下一个挑战是如何在实际模拟中构建一个有效且可靠的偏置势。本练习  介绍了一种基于势能面局部曲率的先进方法，即利用Hessian矩阵的最小特征值 $\\lambda_{\\min}$ 来动态定义偏置势。您还将解决一个在真实系统中常见的难题：如何设计一个平滑函数以确保偏置在过渡态附近精确为零，从而保证模拟结果的准确性。",
            "id": "3457977",
            "problem": "您被要求形式化并实现一个超动力学偏置势，该偏置势依赖于分子动力学轨迹上Hessian矩阵的最小特征值。请从以下基础开始：根据过渡态理论 (TST)，通过添加一个在过渡态分割面上恒为零的非负偏置势，稀有事件的速率保持不变。对于一个由离散时间样本索引状态的轨迹，将在一个采样构象处的Hessian矩阵的最小特征值表示为 $\\lambda_{\\min}$，它在鞍点区域可以为负，在盆地区域可以为正。目标是基于 $\\lambda_{\\min}$ 的一个阈值构建一个偏置势，同时强制该偏置在鞍点区域周围的一个小带内消失，以保持TST一致性。\n\n仅使用基本原理和定义，在一个完整的程序中执行以下任务。所有能量必须以电子伏特表示，记为 $\\mathrm{eV}$，能量的倒数记为 $\\mathrm{eV}^{-1}$。不使用角度。您的程序必须使用下面详述的精确数值参数和测试数组。\n\n1. 为给定样本定义一个朴素偏置势为 $V_b^{\\mathrm{naive}}(\\lambda_{\\min}) = c \\,\\max\\!\\big(0,\\ \\lambda^* - \\lambda_{\\min}\\big)$，其中 $c$ 的单位是 $\\mathrm{eV}$ 每 $\\lambda_{\\min}$ 单位，$\\lambda^*$ 是为 $\\lambda_{\\min}$ 选择的阈值。根据构造，此函数是非负的。\n\n2. 认识到在 $\\lambda_{\\min} \\approx 0$ 的非谐鞍点区域，朴素偏置通常非零，您必须引入一个平滑核函数 $K(\\lambda_{\\min};\\delta)$，它强制在 $|\\lambda_{\\min}| \\le \\delta$ 时 $V_b=0$，同时平滑地过渡到远离鞍点区域时无抑制的状态。构建 $K$ 使其二阶连续可微并满足\n   - 当 $|\\lambda_{\\min}| \\le \\delta$ 时，$K(\\lambda_{\\min};\\delta) = 0$，\n   - 当 $|\\lambda_{\\min}| \\ge 2\\delta$ 时，$K(\\lambda_{\\min};\\delta) = 1$，\n   - 在区间 $\\delta \\lt |\\lambda_{\\min}| \\lt 2\\delta$ 上，关于 $|\\lambda_{\\min}|$ 单调递增，\n   - 在 $|\\lambda_{\\min}|=\\delta$ 和 $|\\lambda_{\\min}|=2\\delta$ 处具有连续的一阶和二阶导数。\n   为实现此目的，通过将 $|\\lambda_{\\min}|$ 映射到归一化坐标 $t \\in [0,1]$（通过 $t = \\big(|\\lambda_{\\min}| - \\delta\\big)/\\delta$），并使用满足 $S(0)=0$、$S(1)=1$、$S'(0)=0$、$S'(1)=0$、$S''(0)=0$ 和 $S''(1)=0$ 的最小次数多项式来显式构建核函数。定义当 $t \\le 0$ 时 $K(\\lambda_{\\min};\\delta) = 0$，当 $t \\ge 1$ 时 $K(\\lambda_{\\min};\\delta) = 1$，以及当 $t \\in (0,1)$ 时 $K(\\lambda_{\\min};\\delta) = S(t)$。\n\n3. 定义平滑偏置势为 $V_b^{\\mathrm{sm}}(\\lambda_{\\min}) = K(\\lambda_{\\min};\\delta)\\,V_b^{\\mathrm{naive}}(\\lambda_{\\min})$。\n\n4. 对于给定的逆热能 $\\beta$（单位为 $\\mathrm{eV}^{-1}$），将样本的瞬时超动力学增强因子定义为 $b = \\exp\\!\\big(\\beta\\,V_b\\big)$，并将离散轨迹段上的时间平均值定义为样本的算术平均值 $\\langle b \\rangle$。\n\n5. 对每个轨迹段，通过计算 $|\\lambda_{\\min}| \\le \\delta$ 的样本上的 $V_b$ 的最大值来量化注入鞍带中的伪偏置；对朴素偏置和平滑偏置分别定义此量。\n\n6. 为您的核函数实现一个数值可微性检查：在 $x=\\delta$ 和 $x=2\\delta$ 处，使用步长为 $\\varepsilon=\\delta/1000$ 的单边有限差分来验证关于 $x=|\\lambda_{\\min}|$ 的一阶和二阶导数的双边连续性。具体来说，使用一阶单边差分计算左右一阶导数，使用二阶单边差分计算左右二阶导数，如果每个点处左右导数之间的绝对差值对于一阶导数低于 $10^{-6}$，对于二阶导数低于 $10^{-4}$，则返回一个布尔值true。\n\n使用以下固定参数，这些参数在所有测试中保持不变：\n- 逆热能 $\\beta = 20.0\\ \\mathrm{eV}^{-1}$（将数字写为 $20.0$）。\n- 偏置缩放因子 $c = 0.02\\ \\mathrm{eV}$ 每 $\\lambda_{\\min}$ 单位（将数字写为 $0.02$）。\n- 阈值 $\\lambda^* = 1.0$（将数字写为 $1.0$）。\n- 平滑半宽度 $\\delta = 0.05$（将数字写为 $0.05$）。\n\n将您的实现应用于以下四个轨迹段的测试套件，每个轨迹段都以 $\\lambda_{\\min}$ 样本的有序列表形式给出：\n- 测试 A（远离鞍点的盆地区域）：$\\big[0.7,\\ 0.8,\\ 0.9,\\ 0.85,\\ 0.75\\big]$。\n- 测试 B（非谐鞍带）：$\\big[-0.02,\\ 0.01,\\ -0.03,\\ 0.0,\\ 0.02,\\ -0.01\\big]$。\n- 测试 C（围绕 $\\delta$ 和 $2\\delta$ 的边界检查）：$\\big[-0.05,\\ 0.05,\\ -0.10,\\ 0.10,\\ -0.049,\\ 0.049,\\ -0.051,\\ 0.051,\\ -0.099,\\ 0.099,\\ -0.101,\\ 0.101\\big]$。\n- 测试 D（深鞍点状区域）：$\\big[-0.5,\\ -0.2,\\ -0.3,\\ -0.25,\\ -0.4\\big]$。\n\n对每个测试段，按顺序生成以下输出：\n- 朴素偏置的时间平均增强因子，$\\langle \\exp(\\beta V_b^{\\mathrm{naive}}) \\rangle$，以浮点数表示。\n- 平滑偏置的时间平均增强因子，$\\langle \\exp(\\beta V_b^{\\mathrm{sm}}) \\rangle$，以浮点数表示。\n- 鞍带 $|\\lambda_{\\min}| \\le \\delta$ 内的最大伪朴素偏置，以浮点数表示，单位为 $\\mathrm{eV}$。\n- 鞍带 $|\\lambda_{\\min}| \\le \\delta$ 内的最大伪平滑偏置，以浮点数表示，单位为 $\\mathrm{eV}$。\n- 上述的核函数可微性检查布尔值。\n\n您的程序应生成单行输出，其中包含一个由每个测试的结果组成的逗号分隔列表，每个测试的结果是一个包含上述五个条目的列表，并用方括号括起来。例如，您的最终输出必须是如下形式的单行\n$[ [a_1,a_2,a_3,a_4,a_5], [b_1,b_2,b_3,b_4,b_5], [c_1,c_2,c_3,c_4,c_5], [d_1,d_2,d_3,d_4,d_5] ]$\n其中占位符被计算出的值替换。所有浮点输出必须是标准十进制表示。不应打印其他文本。",
            "solution": "我们通过强制偏置在过渡态分割面上消失，来构建一个保持过渡态理论 (TST) 速率不变的超动力学偏置。其基本原理是TST的论述：添加一个在分割面上恒为零的非负偏置势 $V_b$ 不会改变穿越概率，并且加速后的时间可以通过使用因子 $\\exp(\\beta V_b)$ 进行重加权来恢复，其中 $\\beta$ 是逆热能，单位为 $\\mathrm{eV}^{-1}$。对于一个由 $i$ 索引的离散时间序列，朴素瞬时增强因子为 $b_i^{\\mathrm{naive}}=\\exp(\\beta V_{b,i}^{\\mathrm{naive}})$，时间平均增强因子是算术平均值 $\\langle b^{\\mathrm{naive}}\\rangle=\\frac{1}{N}\\sum_{i=1}^N b_i^{\\mathrm{naive}}$，平滑对应项的定义相同。\n\n1. 给定最小Hessian特征值 $\\lambda_{\\min}$，定义一个朴素偏置\n$$\nV_b^{\\mathrm{naive}}(\\lambda_{\\min}) \\;=\\; c\\,\\max\\!\\big(0,\\ \\lambda^*-\\lambda_{\\min}\\big),\n$$\n其中 $c$ 的单位是 $\\mathrm{eV}$ 每 $\\lambda_{\\min}$ 单位。此选择是非负的，因为它是正的常数乘以一个与零取最大值的项。然而，在鞍点区域，其中 $\\lambda_{\\min}\\approx 0$（并且由于非谐性可能略为负值），只要 $\\lambda^*-\\lambda_{\\min}0$，朴素偏置就保持为正，这违反了TST在分割面上偏置为零的要求。因此，我们需要一个平滑因子，在零附近的一个小带 $|\\lambda_{\\min}| \\le \\delta$ 内消除该偏置。\n\n2. 我们需要一个核函数 $K(\\lambda_{\\min};\\delta)$ 具有以下性质\n- 当 $|\\lambda_{\\min}|\\le\\delta$ 时，$K(\\lambda_{\\min};\\delta)=0$，\n- 当 $|\\lambda_{\\min}|\\ge 2\\delta$ 时，$K(\\lambda_{\\min};\\delta)=1$，\n- 在 $\\delta  |\\lambda_{\\min}|  2\\delta$ 上关于 $|\\lambda_{\\min}|$ 单调递增，\n- 在连接点 $|\\lambda_{\\min}|=\\delta$ 和 $|\\lambda_{\\min}|=2\\delta$ 处二阶连续可微。\n\n为了获得满足平滑性约束的最小次数多项式，我们引入归一化坐标\n$$\nt \\;=\\; \\frac{|\\lambda_{\\min}| - \\delta}{\\delta},\n$$\n它将 $|\\lambda_{\\min}|=\\delta$ 映射到 $t=0$，将 $|\\lambda_{\\min}|=2\\delta$ 映射到 $t=1$。我们寻求一个多项式 $S(t)$ 使得\n$$\nS(0)=0,\\quad S(1)=1,\\quad S'(0)=0,\\quad S'(1)=0,\\quad S''(0)=0,\\quad S''(1)=0.\n$$\n满足六个独立线性条件的最小次数多项式是五次多项式，$S(t)=a_0+a_1 t+a_2 t^2+a_3 t^3+a_4 t^4+a_5 t^5$。强制施加这些条件可以得到一个关于系数的线性系统。从 $S(0)=0$ 设 $a_0=0$，从 $S'(0)=0$ 和 $S''(0)=0$ 设 $a_1=0$、$a_2=0$，并使用在 $t=1$ 处的端点条件：\n$$\n\\begin{aligned}\nS(1)=a_3+a_4+a_5=1,\\\\\nS'(1)=3a_3+4a_4+5a_5=0,\\\\\nS''(1)=6a_3+12a_4+20a_5=0,\n\\end{aligned}\n$$\n我们求解 $a_3$、$a_4$ 和 $a_5$。从第三个方程中减去第二个方程的两倍，得到 $(6a_3+12a_4+20a_5) - 2(3a_3+4a_4+5a_5) = 0$，因此 $4a_4+10a_5=0$ 且 $a_4=-\\tfrac{5}{2}a_5$。代入第二个方程，得到 $3a_3+4(-\\tfrac{5}{2}a_5)+5a_5=3a_3-10a_5+5a_5=3a_3-5a_5=0$，所以 $a_3=\\tfrac{5}{3}a_5$。使用第一个方程，$\\tfrac{5}{3}a_5-\\tfrac{5}{2}a_5+a_5=1$ 可以简化为 $\\big(\\tfrac{5}{3}-\\tfrac{5}{2}+1\\big)a_5=1$。括号中的系数是 $\\tfrac{10}{6}-\\tfrac{15}{6}+\\tfrac{6}{6}=\\tfrac{1}{6}$，所以 $a_5=6$。然后 $a_3=\\tfrac{5}{3}\\cdot 6=10$ 且 $a_4=-\\tfrac{5}{2}\\cdot 6=-15$。因此\n$$\nS(t) \\;=\\; 10 t^3 - 15 t^4 + 6 t^5 \\;=\\; 6 t^5 - 15 t^4 + 10 t^3,\n$$\n这就是众所周知的五次平滑步进函数，它是 $C^2$ 连续的。然后我们定义\n$$\nK(\\lambda_{\\min};\\delta) \\;=\\;\n\\begin{cases}\n0,  t\\le 0,\\\\\nS(t),  0\\lt t\\lt 1,\\\\\n1,  t\\ge 1,\n\\end{cases}\n\\qquad\\text{其中}\\quad t=\\dfrac{|\\lambda_{\\min}|-\\delta}{\\delta}.\n$$\n根据构造，$K$ 在 $\\delta  |\\lambda_{\\min}|  2\\delta$ 上关于 $|\\lambda_{\\min}|$ 是单调递增的，并且由于 $S'(0)=S'(1)=0$ 和 $S''(0)=S''(1)=0$，其一阶和二阶导数在端点处与左右两边的常数片段连续匹配。\n\n3. 平滑偏置为\n$$\nV_b^{\\mathrm{sm}}(\\lambda_{\\min}) \\;=\\; K(\\lambda_{\\min};\\delta)\\, V_b^{\\mathrm{naive}}(\\lambda_{\\min}).\n$$\n当 $|\\lambda_{\\min}|\\le \\delta$ 时，我们有 $K=0$，因此 $V_b^{\\mathrm{sm}}=0$，满足了在分割面附近的TST要求。当 $|\\lambda_{\\min}|\\ge 2\\delta$ 时，$K=1$，偏置退化为朴素形式，保留了在势阱深处或远离鞍带区域的加速效果。\n\n4. 对于每个具有样本 $\\{\\lambda_{\\min,i}\\}_{i=1}^N$ 的时间序列段，我们计算瞬时增强因子 $b_i^{\\mathrm{naive}}=\\exp(\\beta V_{b,i}^{\\mathrm{naive}})$ 和 $b_i^{\\mathrm{sm}}=\\exp(\\beta V_{b,i}^{\\mathrm{sm}})$，然后计算平均值\n$$\n\\left\\langle b^{\\mathrm{naive}}\\right\\rangle \\;=\\; \\frac{1}{N}\\sum_{i=1}^N \\exp\\!\\big(\\beta V_{b,i}^{\\mathrm{naive}}\\big),\\qquad\n\\left\\langle b^{\\mathrm{sm}}\\right\\rangle \\;=\\; \\frac{1}{N}\\sum_{i=1}^N \\exp\\!\\big(\\beta V_{b,i}^{\\mathrm{sm}}\\big).\n$$\n鞍带内的伪偏置由下式量化\n$$\n\\max_{i:\\ |\\lambda_{\\min,i}| \\le \\delta} V_{b,i}^{\\mathrm{naive}},\\qquad\n\\max_{i:\\ |\\lambda_{\\min,i}| \\le \\delta} V_{b,i}^{\\mathrm{sm}},\n$$\n约定空集上的最大值为 $0$。\n\n5. 数值可微性检查。在 $x=\\delta$ 和 $x=2\\delta$ 处，其中 $x=|\\lambda_{\\min}|$，我们定义步长 $\\varepsilon=\\delta/1000$ 并计算导数的单边有限差分近似。对于函数 $f(x)=K(x;\\delta)$ 其中 $x\\ge 0$，在 $x_0$ 处的左一阶导数近似为\n$$\nf'_-(x_0)\\;\\approx\\;\\frac{f(x_0)-f(x_0-\\varepsilon)}{\\varepsilon},\n$$\n右一阶导数近似为\n$$\nf'_+(x_0)\\;\\approx\\;\\frac{f(x_0+\\varepsilon)-f(x_0)}{\\varepsilon}.\n$$\n类似地，左二阶导数可以近似为\n$$\nf''_-(x_0)\\;\\approx\\;\\frac{f(x_0)-2f(x_0-\\varepsilon)+f(x_0-2\\varepsilon)}{\\varepsilon^2},\n$$\n右二阶导数可以近似为\n$$\nf''_+(x_0)\\;\\approx\\;\\frac{f(x_0+2\\varepsilon)-2f(x_0+\\varepsilon)+f(x_0)}{\\varepsilon^2}.\n$$\n然后我们检查对于 $x_0=\\delta$ 和 $x_0=2\\delta$，是否有 $|f'_+(x_0)-f'_-(x_0)|  10^{-6}$ 和 $|f''_+(x_0)-f''_-(x_0)|  10^{-4}$。因为 $K$ 在 $[0,\\delta]$ 和 $[2\\delta,\\infty)$ 上是常数，并且 $S'(0)=S'(1)=0$，$S''(0)=S''(1)=0$，这些差值在数值精度范围内应接近于零。\n\n6. 参数和测试。我们使用固定参数 $\\beta=20.0\\ \\mathrm{eV}^{-1}$，$c=0.02\\ \\mathrm{eV}$ 每 $\\lambda_{\\min}$ 单位，$\\lambda^*=1.0$ 和 $\\delta=0.05$。四个轨迹段是\n- 测试 A：$\\big[0.7,\\ 0.8,\\ 0.9,\\ 0.85,\\ 0.75\\big]$，\n- 测试 B：$\\big[-0.02,\\ 0.01,\\ -0.03,\\ 0.0,\\ 0.02,\\ -0.01\\big]$，\n- 测试 C：$\\big[-0.05,\\ 0.05,\\ -0.10,\\ 0.10,\\ -0.049,\\ 0.049,\\ -0.051,\\ 0.051,\\ -0.099,\\ 0.099,\\ -0.101,\\ 0.101\\big]$，\n- 测试 D：$\\big[-0.5,\\ -0.2,\\ -0.3,\\ -0.25,\\ -0.4\\big]$。\n\n7. 输出规格。对于每个测试，输出一个包含五个条目的列表：$\\langle \\exp(\\beta V_b^{\\mathrm{naive}}) \\rangle$，$\\langle \\exp(\\beta V_b^{\\mathrm{sm}}) \\rangle$，$\\max_{|\\lambda_{\\min}| \\le \\delta} V_b^{\\mathrm{naive}}$（单位 $\\mathrm{eV}$），$\\max_{|\\lambda_{\\min}| \\le \\delta} V_b^{\\mathrm{sm}}$（单位 $\\mathrm{eV}$），以及可微性检查布尔值。将四个测试的列表聚合为单个列表，并将该单列表打印在一行上，不带任何附加文本。\n\n实现的算法步骤：\n- 实现 $S(t)=6t^5-15t^4+10t^3$ 和使用 $t=\\big(|\\lambda_{\\min}|-\\delta\\big)/\\delta$ 的分段函数 $K(\\lambda_{\\min};\\delta)$，并对 $t\\le 0$ 和 $t\\ge 1$ 进行截断处理。\n- 为每个样本计算 $V_b^{\\mathrm{naive}}$ 和 $V_b^{\\mathrm{sm}}$。\n- 计算 $\\exp(\\beta V_b)$ 的平均值。\n- 在集合 $\\{i:\\ |\\lambda_{\\min,i}| \\le \\delta\\}$ 内计算 $V_b$ 的最大值，如果集合为空则为 $0$。\n- 使用 $\\varepsilon=\\delta/1000$ 在 $x=\\delta$ 和 $x=2\\delta$ 处实现单边有限差分检查。\n\n数值输出中，增强因子是无量纲的，偏置的单位是 $\\mathrm{eV}$。所有要求的输出都是浮点数或布尔值。",
            "answer": "```python\nimport numpy as np\n\ndef smoothstep_quintic(t):\n    # S(t) = 6 t^5 - 15 t^4 + 10 t^3 for t in [0,1]\n    return ((6.0 * t - 15.0) * t + 10.0) * t**3\n\ndef kernel_K(lam, delta):\n    # K depends on |lambda_min|\n    x = abs(lam)\n    if x = delta:\n        return 0.0\n    elif x >= 2.0 * delta:\n        return 1.0\n    else:\n        t = (x - delta) / delta  # in (0,1)\n        return smoothstep_quintic(t)\n\ndef bias_naive(lam, c, lam_star):\n    return c * max(0.0, lam_star - lam)\n\ndef bias_smoothed(lam, c, lam_star, delta):\n    return kernel_K(lam, delta) * bias_naive(lam, c, lam_star)\n\ndef avg_boost(lams, beta, c, lam_star, delta=None):\n    if delta is None:\n        vb = np.array([bias_naive(l, c, lam_star) for l in lams], dtype=float)\n    else:\n        vb = np.array([bias_smoothed(l, c, lam_star, delta) for l in lams], dtype=float)\n    return float(np.mean(np.exp(beta * vb)))\n\ndef max_spurious_bias(lams, c, lam_star, delta, smoothed=False):\n    mask = np.array([abs(l) = delta for l in lams], dtype=bool)\n    if not np.any(mask):\n        return 0.0\n    if smoothed:\n        arr = np.array([bias_smoothed(l, c, lam_star, delta) for l in lams], dtype=float)\n    else:\n        arr = np.array([bias_naive(l, c, lam_star) for l in lams], dtype=float)\n    return float(np.max(arr[mask])) if arr[mask].size > 0 else 0.0\n\ndef kernel_derivative_checks(delta, atol1=1e-6, atol2=1e-4):\n    # Check at x = delta, x = 2*delta using one-sided finite differences\n    eps = delta / 1000.0 if delta > 0 else 1e-9\n\n    def Kx(x):\n        # K as a function of x = |lambda_min|, x >= 0\n        if x = delta:\n            return 0.0\n        elif x >= 2.0 * delta:\n            return 1.0\n        else:\n            t = (x - delta) / delta\n            return smoothstep_quintic(t)\n\n    def first_deriv_left(x0):\n        # (f(x0) - f(x0 - eps)) / eps\n        return (Kx(x0) - Kx(x0 - eps)) / eps\n\n    def first_deriv_right(x0):\n        # (f(x0 + eps) - f(x0)) / eps\n        return (Kx(x0 + eps) - Kx(x0)) / eps\n\n    def second_deriv_left(x0):\n        # (f(x0) - 2 f(x0 - eps) + f(x0 - 2 eps)) / eps^2\n        return (Kx(x0) - 2.0 * Kx(x0 - eps) + Kx(x0 - 2.0 * eps)) / (eps ** 2)\n\n    def second_deriv_right(x0):\n        # (f(x0 + 2 eps) - 2 f(x0 + eps) + f(x0)) / eps^2\n        return (Kx(x0 + 2.0 * eps) - 2.0 * Kx(x0 + eps) + Kx(x0)) / (eps ** 2)\n\n    checks = []\n    for x0 in (delta, 2.0 * delta):\n        dL = first_deriv_left(x0)\n        dR = first_deriv_right(x0)\n        ddL = second_deriv_left(x0)\n        ddR = second_deriv_right(x0)\n        ok1 = abs(dR - dL)  atol1\n        ok2 = abs(ddR - ddL)  atol2\n        checks.append(ok1 and ok2)\n    return all(checks)\n\ndef solve():\n    # Fixed parameters\n    beta = 20.0  # eV^{-1}\n    c = 0.02     # eV per unit of lambda_min\n    lam_star = 1.0\n    delta = 0.05\n\n    # Test suite: lists of lambda_min samples\n    tests = [\n        [0.7, 0.8, 0.9, 0.85, 0.75],  # Test A\n        [-0.02, 0.01, -0.03, 0.0, 0.02, -0.01],  # Test B\n        [-0.05, 0.05, -0.10, 0.10, -0.049, 0.049, -0.051, 0.051, -0.099, 0.099, -0.101, 0.101],  # Test C\n        [-0.5, -0.2, -0.3, -0.25, -0.4],  # Test D\n    ]\n\n    results = []\n    for lams in tests:\n        # Average boost factors\n        avg_boost_naive_val = avg_boost(lams, beta, c, lam_star, delta=None)\n        avg_boost_smoothed_val = avg_boost(lams, beta, c, lam_star, delta=delta)\n        # Spurious bias in saddle band\n        max_spurious_naive = max_spurious_bias(lams, c, lam_star, delta, smoothed=False)\n        max_spurious_smoothed = max_spurious_bias(lams, c, lam_star, delta, smoothed=True)\n        # Kernel differentiability boolean\n        kernel_ok = kernel_derivative_checks(delta)\n        results.append([\n            avg_boost_naive_val,\n            avg_boost_smoothed_val,\n            max_spurious_naive,\n            max_spurious_smoothed,\n            kernel_ok\n        ])\n\n    # Print results as a single-line list of lists\n    # Ensure default string conversion for booleans and floats\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个严谨的科学方法不仅需要知道它为什么有效，更需要理解它在什么情况下会失效。本练习  将通过一个精心设计的“失效模式测试”来加深您对超动力学适用条件的理解。您将定量地研究当偏置势“泄漏”到过渡态区域时对反应速率计算造成的误差，并将模拟结果与过渡态理论的微扰分析预测进行比较。",
            "id": "3458000",
            "problem": "考虑一个用于模拟计算材料科学中稀有事件跃迁的一维双势阱。设物理势定义为 $U(x) = E_b \\left(x^2 - 1\\right)^2$，其在 $x = \\pm 1$ 处有极小值，并在位于 $x^\\ddagger = 0$ 的过渡态处有势垒顶。假设动量可分离的一维经典过渡态理论 (TST)。从左势阱 $A$（定义为 $x  0$）到右势阱的速率，通过计算穿过一个以 $x^\\ddagger = 0$ 为中心、宽度为 $\\delta$ 的窄过渡态带的通量来得到，其中用均匀带平均来近似 delta 曲面。具体而言，TST 速率可近似为\n$$\nk_{\\text{true}}(\\delta) \\approx \\frac{1}{\\beta Z_A(U)} \\cdot \\frac{1}{\\delta} \\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] \\, dx,\n$$\n其中 $Z_A(U) = \\int_{-\\infty}^{0} \\exp\\left[-\\beta U(x)\\right] \\, dx$ 是在势 $U(x)$ 下盆地 $A$ 的配分函数，$\\beta = 1/(k_B T)$ 是逆热能，其中 $k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n在超动力学中，引入一个正偏置势 $V_b(x) \\ge 0$ 来加速盆地内的动力学，同时保持势垒区域不变。当偏置势泄漏到宽度为 $\\delta$ 的过渡态带中，导致在 $\\left[-\\delta/2, \\delta/2\\right]$ 内的某些 $x$ 处出现 $V_b(x)  0$ 时，会出现一种失效模式。设泄漏形状定义为\n$$\nV_b(x; \\delta, V_{\\max}) = \\begin{cases}\nV_{\\max} \\exp\\!\\left[-\\left(\\frac{2x}{\\delta}\\right)^2\\right],  \\text{若 } |x| \\le \\delta/2, \\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n其中 $V_{\\max}  0$ 是在 $x^\\ddagger$ 处的最大泄漏幅度。\n\n在势为 $W(x) = U(x) + V_b(x)$ 的偏置动力学下，并采用常规的超动力学时间重加权 $dt_{\\text{true}} = \\exp\\left[\\beta V_b(x)\\right] dt_{\\text{biased}}$，校正后的带平均 TST 速率变为\n$$\nk_{\\text{corr}}(\\delta, V_{\\max}) \\approx \\frac{1}{\\beta Z_A(U)} \\cdot \\frac{1}{\\delta} \\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta \\left(U(x) + V_b(x)\\right)\\right] dx.\n$$\n定义由泄漏引起的分数速率偏差为\n$$\n\\frac{\\Delta k}{k}(\\delta, V_{\\max}) \\equiv \\frac{k_{\\text{corr}}(\\delta, V_{\\max}) - k_{\\text{true}}(\\delta)}{k_{\\text{true}}(\\delta)}.\n$$\n\n任务：从上述定义出发，实现一个程序，该程序：\n- 为指定的测试用例计算 $Z_A(U)$、$k_{\\text{true}}(\\delta)$、$k_{\\text{corr}}(\\delta, V_{\\max})$ 和 $\\Delta k/k(\\delta, V_{\\max})$。\n- 通过在小幅度下对 $\\Delta k/k$ 与 $V_{\\max}$ 进行线性拟合，以获得每个 $\\delta$ 的测量斜率 $s_{\\text{meas}}(\\delta)$，从而估计 $\\Delta k/k$ 对 $V_{\\max}$ 的前导阶微扰依赖性。\n- 基于带平均泄漏计算斜率 $s_{\\text{pred}}(\\delta)$ 的前导阶理论预测，该泄漏由形状因子的带加权平均定义，\n$$\n\\langle g \\rangle_{\\text{band}}(\\delta) \\equiv \\frac{\\int_{-\\delta/2}^{\\delta/2} \\exp\\!\\left[-\\beta U(x)\\right] \\exp\\!\\left[-\\left(\\frac{2x}{\\delta}\\right)^2\\right] dx}{\\int_{-\\delta/2}^{\\delta/2} \\exp\\!\\left[-\\beta U(x)\\right] dx},\n$$\n前导阶斜率定义为\n$$\ns_{\\text{pred}}(\\delta) \\equiv -\\beta \\, \\langle g \\rangle_{\\text{band}}(\\delta).\n$$\n\n物理和数值参数：\n- 使用 $E_b = 0.5$ 电子伏特 (eV)，$T = 300$ 开尔文 (K)，以及 $k_B = 8.617333262145 \\times 10^{-5}$ eV/K。\n- 能量（$U$、$V_b$、$E_b$、$V_{\\max}$）必须以电子伏特 (eV) 为单位。温度 $T$ 必须以开尔文 (K) 为单位。分数速率偏差 $\\Delta k/k$ 是无量纲的，必须以小数形式报告。\n\n测试套件：\n- 过渡态带宽度 $\\delta \\in \\{0.05, 0.2, 1.0\\}$（在无量纲的 $x$ 坐标中）。\n- 泄漏幅度 $V_{\\max} \\in \\{0.0 \\text{ eV}, 0.01 \\text{ eV}, 0.05 \\text{ eV}\\}$。\n\n对于上述集合的笛卡尔积中的每个 $(\\delta, V_{\\max})$ 对，计算并记录分数偏差 $\\Delta k/k(\\delta, V_{\\max})$ 为一个浮点数。然后，对于每个 $\\delta$，使用 $V_{\\max} = 0.0$ eV 和 $V_{\\max} = 0.01$ eV 时的分数偏差，通过两点线性拟合来估计 $s_{\\text{meas}}(\\delta)$。同时，使用上述定义计算 $s_{\\text{pred}}(\\delta)$，并报告绝对差 $|s_{\\text{meas}}(\\delta) - s_{\\text{pred}}(\\delta)|$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按顺序包含：\n    1. 九个分数偏差 $\\Delta k/k(\\delta, V_{\\max})$，按 $\\delta$ 递增（即，首先是 $\\delta = 0.05$，然后是 $0.2$，然后是 $1.0$）排序，对于每个固定的 $\\delta$，按 $V_{\\max}$ 递增（即，$0.0$ eV、$0.01$ eV、$0.05$ eV）排序。\n    2. 三个测量斜率 $s_{\\text{meas}}(\\delta)$，对应 $\\delta \\in \\{0.05, 0.2, 1.0\\}$，按此顺序排列。\n    3. 三个预测斜率 $s_{\\text{pred}}(\\delta)$，对应 $\\delta \\in \\{0.05, 0.2, 1.0\\}$，按此顺序排列。\n    4. 三个绝对差 $|s_{\\text{meas}}(\\delta) - s_{\\text{pred}}(\\delta)|$，对应 $\\delta \\in \\{0.05, 0.2, 1.0\\}$，按此顺序排列。\n\n所有输出都必须是浮点数，表示为不带单位的小数。",
            "solution": "我们从位置 $x^\\ddagger$ 处固定分割面的一维经典过渡态理论 (TST) 速率开始。在一维且动量可分离的情况下，从盆地 $A$ 进入产物区域的 TST 速率为\n$$\nk_{\\text{TST}} = \\frac{1}{Z_A(U)} \\int dp \\, \\frac{p}{m} \\Theta(p) \\exp\\left[-\\beta \\left(\\frac{p^2}{2m} + U(x^\\ddagger)\\right)\\right],\n$$\n其中 $Z_A(U)$ 是盆地 $A$ 上的构型积分，$\\Theta(p)$ 是强制正通量的 Heaviside 阶跃函数。动量积分得出\n$$\n\\int_0^\\infty \\frac{p}{m} \\exp\\left[-\\beta \\frac{p^2}{2m}\\right] dp = \\frac{1}{\\beta},\n$$\n该结果与质量 $m$ 无关。因此，\n$$\nk_{\\text{TST}} = \\frac{1}{\\beta Z_A(U)} \\exp\\left[-\\beta U(x^\\ddagger)\\right].\n$$\n在实践中，人们通常用一个以 $x^\\ddagger$ 为中心、宽度为 $\\delta$ 的窄带近似分割面，并用带平均值取代 delta 曲面积分。记\n$$\nI_{\\text{true}}(\\delta) \\equiv \\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] dx,\n$$\n带平均的 TST 速率近似为\n$$\nk_{\\text{true}}(\\delta) \\approx \\frac{1}{\\beta Z_A(U)} \\cdot \\frac{I_{\\text{true}}(\\delta)}{\\delta},\n$$\n这在极限 $\\delta \\to 0$ 时恢复精确结果。\n\n在超动力学中，势被修改为 $W(x) = U(x) + V_b(x)$，其中 $V_b(x) \\ge 0$ 被构造成在过渡态处为零，以在加速盆地内动力学的同时保持速率不变。当 $V_b(x)$ 泄漏到过渡态带中，特别是在 $x^\\ddagger$ 附近时，会出现一种失效模式。常规的超动力学时间重加权通过以下方式将偏置动力学时间 $dt_{\\text{biased}}$ 映射到真实时间：\n$$\ndt_{\\text{true}} = \\exp\\left[\\beta V_b(x)\\right] \\, dt_{\\text{biased}}.\n$$\n在此重加权下，从偏置势下的带平均通量计算出的校正速率为\n$$\nk_{\\text{corr}}(\\delta, V_{\\max}) \\approx \\frac{1}{\\beta Z_A(U)} \\cdot \\frac{1}{\\delta} \\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta \\left(U(x) + V_b(x)\\right)\\right] dx,\n$$\n因为当用分母中的 $Z_A(U)$ 表示时，时间重加权抵消了盆地概率重整化。\n\n分数速率偏差定义为\n$$\n\\frac{\\Delta k}{k}(\\delta, V_{\\max}) \\equiv \\frac{k_{\\text{corr}}(\\delta, V_{\\max}) - k_{\\text{true}}(\\delta)}{k_{\\text{true}}(\\delta)}.\n$$\n使用带积分，该比率简化为\n$$\n\\frac{k_{\\text{corr}}(\\delta, V_{\\max})}{k_{\\text{true}}(\\delta)} = \\frac{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] \\exp\\left[-\\beta V_b(x)\\right] dx}{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] dx}.\n$$\n因此，\n$$\n\\frac{\\Delta k}{k}(\\delta, V_{\\max}) = \\left\\langle \\exp\\left[-\\beta V_b(x)\\right] \\right\\rangle_{\\text{band}} - 1,\n$$\n其中带加权平均是关于权重 $\\exp\\left[-\\beta U(x)\\right]$ 在过渡态带上的平均。对于小泄漏幅度 $V_{\\max}$，指数函数的前导阶微扰展开给出\n$$\n\\exp\\left[-\\beta V_b(x)\\right] \\approx 1 - \\beta V_b(x) + \\frac{1}{2} \\beta^2 V_b(x)^2 + \\cdots.\n$$\n仅保留线性项，得到前导阶预测\n$$\n\\frac{\\Delta k}{k}(\\delta, V_{\\max}) \\approx -\\beta \\left\\langle V_b(x) \\right\\rangle_{\\text{band}},\n$$\n其中\n$$\n\\left\\langle V_b(x) \\right\\rangle_{\\text{band}} \\equiv \\frac{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] V_b(x) \\, dx}{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] dx}.\n$$\n给定泄漏形状 $V_b(x; \\delta, V_{\\max}) = V_{\\max} g(x; \\delta)$，其中 $g(x; \\delta) = \\exp\\left[-\\left(\\frac{2x}{\\delta}\\right)^2\\right]$ 在带内，带外为零，带加权平均可因子分解为\n$$\n\\left\\langle V_b(x) \\right\\rangle_{\\text{band}} = V_{\\max} \\, \\langle g \\rangle_{\\text{band}}(\\delta),\n$$\n其中\n$$\n\\langle g \\rangle_{\\text{band}}(\\delta) = \\frac{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] \\exp\\left[-\\left(\\frac{2x}{\\delta}\\right)^2\\right] dx}{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] dx}.\n$$\n因此，分数速率偏差相对于 $V_{\\max}$ 在 $V_{\\max} \\to 0$ 时的前导阶斜率为\n$$\ns_{\\text{pred}}(\\delta) \\equiv \\left. \\frac{d}{d V_{\\max}} \\frac{\\Delta k}{k}(\\delta, V_{\\max}) \\right|_{V_{\\max} \\to 0} = -\\beta \\, \\langle g \\rangle_{\\text{band}}(\\delta).\n$$\n\n算法流程：\n1. 设置物理常数：$E_b = 0.5$ 电子伏特 (eV)，$T = 300$ 开尔文 (K)，$k_B = 8.617333262145 \\times 10^{-5}$ eV/K，因此 $\\beta = 1/(k_B T)$ 单位为 $\\text{eV}^{-1}$。\n2. 定义 $U(x) = E_b \\left(x^2 - 1\\right)^2$。\n3. 使用半无限区间上的数值积分计算 $Z_A(U) = \\int_{-\\infty}^{0} \\exp\\left[-\\beta U(x)\\right] dx$；$U(x)$ 的四次增长确保了收敛性。\n4. 对于每个测试用例 $(\\delta, V_{\\max})$：\n   - 计算 $I_{\\text{true}}(\\delta) = \\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] dx$。\n   - 如上定义 $V_b(x; \\delta, V_{\\max})$。\n   - 计算 $I_{\\text{bias}}(\\delta, V_{\\max}) = \\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] \\exp\\left[-\\beta V_b(x)\\right] dx$。\n   - 通过 $\\Delta k/k = I_{\\text{bias}}/I_{\\text{true}} - 1$ 计算分数偏差并记录。\n5. 对于每个 $\\delta$，使用 $V_{\\max} \\in \\{0.0 \\text{ eV}, 0.01 \\text{ eV}\\}$ 处的 $(V_{\\max}, \\Delta k/k)$ 点进行两点线性拟合，估计测量斜率 $s_{\\text{meas}}(\\delta)$。\n6. 对于每个 $\\delta$，计算预测斜率 $s_{\\text{pred}}(\\delta) = -\\beta \\, \\langle g \\rangle_{\\text{band}}(\\delta)$，其中\n   $$\n   \\langle g \\rangle_{\\text{band}}(\\delta) = \\frac{\\int_{-\\delta/2}^{\\delta/2} \\exp\\left[-\\beta U(x)\\right] \\exp\\left[-\\left(\\frac{2x}{\\delta}\\right)^2\\right] dx}{I_{\\text{true}}(\\delta)}.\n   $$\n7. 报告九个分数偏差（按 $\\delta$ 再按 $V_{\\max}$ 排序），然后是对应 $\\delta \\in \\{0.05, 0.2, 1.0\\}$ 的三个测量斜率，接着是相同顺序的三个预测斜率，最后是三个绝对差。\n\n该流程直接测试了偏置势泄漏到过渡态区域所引入的失效模式，并从过渡态理论和超动力学时间重加权的基本定义出发，定量地将该依赖关系拟合到前导阶微扰理论。所有计算量均为无量纲分数或单位为能量倒数的斜率（其中 $V_{\\max}$ 以电子伏特指定），最终报告的分数偏差为无单位的纯小数，符合要求。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef U(x, Eb):\n    \"\"\"Double-well potential with minima at x=±1.\"\"\"\n    return Eb * (x**2 - 1.0)**2\n\ndef Vb(x, delta, Vmax):\n    \"\"\"Leakage bias potential confined to the TS band.\"\"\"\n    half_delta = delta / 2.0\n    if -half_delta = x = half_delta:\n        return Vmax * np.exp(-(2.0 * x / delta)**2)\n    return 0.0\n\ndef band_integral_true(beta, Eb, delta):\n    \"\"\"Computes I_true = ∫ exp[-βU(x)]dx over the band.\"\"\"\n    half_delta = delta / 2.0\n    integrand = lambda x: np.exp(-beta * U(x, Eb))\n    val, _ = quad(integrand, -half_delta, half_delta, limit=200)\n    return val\n\ndef band_integral_bias(beta, Eb, delta, Vmax):\n    \"\"\"Computes I_bias = ∫ exp[-β(U+Vb)]dx over the band.\"\"\"\n    half_delta = delta / 2.0\n    integrand = lambda x: np.exp(-beta * U(x, Eb)) * np.exp(-beta * Vb(x, delta, Vmax))\n    val, _ = quad(integrand, -half_delta, half_delta, limit=200)\n    return val\n\ndef g_band_weighted_average(beta, Eb, delta):\n    \"\"\"Computes the band-weighted average of the leakage shape factor g(x).\"\"\"\n    half_delta = delta / 2.0\n    \n    numerator_integrand = lambda x: np.exp(-beta * U(x, Eb)) * np.exp(-(2.0 * x / delta)**2)\n    numerator, _ = quad(numerator_integrand, -half_delta, half_delta, limit=200)\n    \n    denominator = band_integral_true(beta, Eb, delta)\n    \n    return numerator / denominator if denominator != 0 else 0.0\n\ndef solve():\n    \"\"\"Main solver function.\"\"\"\n    Eb = 0.5\n    T = 300.0\n    kB = 8.617333262145e-5\n    beta = 1.0 / (kB * T)\n\n    delta_values = [0.05, 0.2, 1.0]\n    Vmax_values = [0.0, 0.01, 0.05]\n\n    all_results = []\n    \n    # Task 1: Calculate fractional deviations for all (delta, Vmax) pairs\n    delta_k_k_storage = {}\n    for delta in delta_values:\n        delta_k_k_storage[delta] = {}\n        I_true = band_integral_true(beta, Eb, delta)\n        for Vmax in Vmax_values:\n            if I_true == 0:\n                delta_k_k = 0.0\n            else:\n                I_bias = band_integral_bias(beta, Eb, delta, Vmax)\n                delta_k_k = (I_bias / I_true) - 1.0\n            delta_k_k_storage[delta][Vmax] = delta_k_k\n    \n    # Append to results in the specified order\n    for delta in delta_values:\n        for Vmax in Vmax_values:\n            all_results.append(delta_k_k_storage[delta][Vmax])\n\n    # Tasks 2  3: Calculate slopes and differences\n    s_meas_results = []\n    s_pred_results = []\n    diff_results = []\n\n    for delta in delta_values:\n        # Measured slope from two-point fit\n        y0 = delta_k_k_storage[delta][Vmax_values[0]]\n        y1 = delta_k_k_storage[delta][Vmax_values[1]]\n        x0 = Vmax_values[0]\n        x1 = Vmax_values[1]\n        s_meas = (y1 - y0) / (x1 - x0)\n        s_meas_results.append(s_meas)\n        \n        # Predicted slope from theory\n        g_avg = g_band_weighted_average(beta, Eb, delta)\n        s_pred = -beta * g_avg\n        s_pred_results.append(s_pred)\n        \n        # Absolute difference\n        diff_results.append(abs(s_meas - s_pred))\n\n    all_results.extend(s_meas_results)\n    all_results.extend(s_pred_results)\n    all_results.extend(diff_results)\n\n    # Final formatted output\n    print(f\"[{','.join(f'{x:.8g}' for x in all_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}