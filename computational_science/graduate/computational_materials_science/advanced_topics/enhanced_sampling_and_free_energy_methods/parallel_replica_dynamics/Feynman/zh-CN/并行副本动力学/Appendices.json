{
    "hands_on_practices": [
        {
            "introduction": "并行副本动力学方法的核心优势在于其加速稀有事件模拟的能力，但这种加速并非无限制的。此练习旨在通过一个理想化的模型，深入探讨ParRep的性能核心。我们将基于指数分布的逃逸时间和简化的开销模型，推导其理论加速比，并找出最优的副本数量，从而揭示并行效率与通信成本之间的基本权衡关系 。",
            "id": "3473181",
            "problem": "考虑一个原子模型中的亚稳态，其中在单副本串行模拟中，从该状态逃离（退出）的时间被建模为一个速率参数为 $\\lambda > 0$ 的指数随机变量。并行副本动力学 (ParRep) 用于通过在退相干阶段后运行 $N \\in \\mathbb{N}$ 个独立的副本来加速逃离事件的采样。在 ParRep 中，工作流程如下：一个持续时间为 $\\tau_{d} > 0$ 的退相干阶段会产生 $N$ 个位于亚稳态内部的去相关且准稳态的初始条件；然后一个并行阶段运行 $N$ 个独立副本，直到检测到第一个逃离事件；最后，算法执行一个同步和选择阶段，其开销随 $N$ 线性增长，系数为 $\\tau_{s} > 0$，代表每个副本的通信和协调成本。\n\n假设如下：\n- 串行逃离时间是速率为 $\\lambda$ 的指数分布，其均值为 $1/\\lambda$。\n- $N$ 个并行副本具有独立同分布的指数逃离时间，速率同为 $\\lambda$，并且检测/选择阶段在第一个副本逃离时停止所有副本。\n- 对于一个统计上正确的逃离事件，总的 ParRep 期望挂钟时间是退相干时间、在 $N$ 个副本中直到第一个逃离事件的期望时间，以及随 $N$ 线性增长（系数为 $\\tau_{s}$）的同步开销的总和。\n\n仅使用指数等待时间过程和独立性的第一性原理，推导期望加速比 $\\mathbb{E}[S(N)]$ 的闭式表达式，该加速比定义为期望串行时间与单个逃离事件的 ParRep 期望挂钟时间之比。然后，确定在给定的线性同步开销模型下，使 $\\mathbb{E}[S(N)]$ 最大化的值 $N^{\\star}$（为优化的目的，将其视为正实数）。将您的最终答案表示为闭式解析表达式。不需要数值。加速比是无量纲的，答案中不应使用单位。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 第一步：提取已知条件\n- 串行逃离时间 $T_{serial}$ 是一个速率参数为 $\\lambda > 0$ 的指数随机变量。\n- 副本数量为 $N \\in \\mathbb{N}$。\n- 各副本是独立的。\n- 退相干阶段的持续时间为 $\\tau_{d} > 0$。\n- 并行阶段运行 $N$ 个独立副本，直到第一个副本逃离。\n- 每个副本的同步开销为 $\\tau_{s} > 0$，总开销为 $N\\tau_s$。\n- $N$ 个副本中每个副本的逃离时间 $T_i$ (其中 $i=1, 2, ..., N$) 是一个速率为 $\\lambda$ 的指数随机变量。它们是独立同分布的 (i.i.d.)。\n- 一个逃离事件的总 ParRep 期望挂钟时间为 $\\mathbb{E}[T_{ParRep}(N)] = \\tau_{d} + \\mathbb{E}[\\text{直到第一个副本逃离的时间}] + N\\tau_{s}$。\n- 期望加速比定义为 $\\mathbb{E}[S(N)] = \\frac{\\mathbb{E}[T_{serial}]}{\\mathbb{E}[T_{ParRep}(N)]}$。\n- 任务是推导 $\\mathbb{E}[S(N)]$ 的闭式表达式，并找到使其最大化的值 $N^{\\star}$ (作为正实数)。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学基础（关键）：** 该问题基于计算科学中用于研究稀有事件的成熟方法——并行副本动力学 (ParRep)。将逃离时间建模为指数随机变量是基于过渡态理论和泊松过程性质的标准和基本假设。线性开销模型是并行算法中通信成本的基本且有效的表示。该问题在科学上是合理的。\n- **适定性：** 问题定义清晰，包含所有必要的参数（$\\lambda, \\tau_d, \\tau_s$）和变量（$N$）。目标函数（加速比及其最大化）已明确说明。数学框架为获得唯一且有意义的解提供了清晰的路径。\n- **客观性（关键）：** 问题以精确、正式且无偏见的语言陈述。不存在主观或基于观点的陈述。\n\n### 第三步：结论与行动\n该问题具有科学基础、适定性、客观性且内部一致。判定为**有效**。将推导解答。\n\n### 解答推导\n\n解答的推导分为两部分：首先是期望加速比 $\\mathbb{E}[S(N)]$ 的表达式，其次是使该加速比最大化的最优副本数 $N^{\\star}$。\n\n**第一部分：期望加速比 $\\mathbb{E}[S(N)]$**\n\n期望加速比是单副本模拟观察到一个逃离事件的期望时间与 ParRep 算法观察到一个统计上正确的逃离事件的期望挂钟时间之比。\n\n1.  **期望串行时间：** 串行逃离时间 $T_{serial}$ 被说明为速率为 $\\lambda$ 的指数随机变量。这类变量的期望值是其速率的倒数。\n    $$\n    \\mathbb{E}[T_{serial}] = \\frac{1}{\\lambda}\n    $$\n\n2.  **期望 ParRep 挂钟时间：** 总的 ParRep 期望时间 $\\mathbb{E}[T_{ParRep}(N)]$ 是三个分量的和：\n    - 退相干时间，给定为常数 $\\tau_d$。\n    - 并行阶段中直到第一个逃离事件发生的期望时间。设 $T_1, T_2, \\ldots, T_N$ 为 $N$ 个副本的独立同分布逃离时间，每个都服从速率为 $\\lambda$ 的指数分布。并行阶段的时间是 $T_{parallel} = \\min(T_1, T_2, \\ldots, T_N)$。$N$ 个速率为 $\\lambda$ 的独立同分布指数随机变量的最小值本身也是一个指数随机变量，其速率等于各个速率之和，即 $N\\lambda$。\n    单个副本 $T_i$ 在时间 $t$ 之前没有逃离的概率是 $P(T_i > t) = \\exp(-\\lambda t)$。由于各副本是独立的，所以在时间 $t$ 之前所有副本都没有逃离的概率是：\n    $$\n    P(T_{parallel} > t) = P(T_1 > t, \\ldots, T_N > t) = \\prod_{i=1}^{N} P(T_i > t) = (\\exp(-\\lambda t))^N = \\exp(-N\\lambda t)\n    $$\n    这是速率为 $N\\lambda$ 的指数分布的生存函数。该分布的期望值为：\n    $$\n    \\mathbb{E}[T_{parallel}] = \\frac{1}{N\\lambda}\n    $$\n    - 同步开销，给定为 $N$ 的线性函数：$N\\tau_s$。\n\n    将这三个分量相加，得到总的 ParRep 期望挂钟时间：\n    $$\n    \\mathbb{E}[T_{ParRep}(N)] = \\tau_d + \\mathbb{E}[T_{parallel}] + N\\tau_s = \\tau_d + \\frac{1}{N\\lambda} + N\\tau_s\n    $$\n\n3.  **期望加速比表达式：** 期望加速比 $\\mathbb{E}[S(N)]$ 是期望串行时间与期望 ParRep 时间之比。\n    $$\n    \\mathbb{E}[S(N)] = \\frac{\\mathbb{E}[T_{serial}]}{\\mathbb{E}[T_{ParRep}(N)]} = \\frac{1/\\lambda}{\\tau_d + \\frac{1}{N\\lambda} + N\\tau_s}\n    $$\n    为了简化此表达式，我们可以将分子和分母同乘以 $N\\lambda$：\n    $$\n    \\mathbb{E}[S(N)] = \\frac{N\\lambda(1/\\lambda)}{N\\lambda(\\tau_d + \\frac{1}{N\\lambda} + N\\tau_s)} = \\frac{N}{N\\lambda\\tau_d + 1 + N^2\\lambda\\tau_s}\n    $$\n    这可以重新整理为分母为标准多项式形式：\n    $$\n    \\mathbb{E}[S(N)] = \\frac{N}{N^2\\lambda\\tau_s + N\\lambda\\tau_d + 1}\n    $$\n    这是第一个要求的结果。\n\n**第二部分：最优副本数 $N^{\\star}$**\n\n为了找到使加速比 $\\mathbb{E}[S(N)]$ 最大化的副本数 $N^{\\star}$，我们将 $N$ 视为一个连续的正实变量，并求函数 $\\mathbb{E}[S(N)]$ 的最大值。最大化 $\\mathbb{E}[S(N)]$ 等价于最小化其倒数，这简化为最小化原始分数的分母，即 $\\mathbb{E}[T_{ParRep}(N)]$。我们将这个要最小化的函数定义为 $f(N)$：\n$$\nf(N) = \\mathbb{E}[T_{ParRep}(N)] = \\tau_d + \\frac{1}{N\\lambda} + N\\tau_s\n$$\n我们通过求 $f(N)$ 对 $N$ 的一阶导数并将其设为零来找到临界点。\n$$\n\\frac{df}{dN} = \\frac{d}{dN} \\left( \\tau_d + \\frac{1}{N\\lambda} + N\\tau_s \\right) = 0 - \\frac{1}{N^2\\lambda} + \\tau_s\n$$\n将导数设为零：\n$$\n\\tau_s - \\frac{1}{N^2\\lambda} = 0 \\implies \\tau_s = \\frac{1}{N^2\\lambda}\n$$\n求解 $N^2$：\n$$\nN^2 = \\frac{1}{\\lambda\\tau_s}\n$$\n由于 $N$ 必须为正，我们取正平方根：\n$$\nN^{\\star} = \\sqrt{\\frac{1}{\\lambda\\tau_s}} = \\frac{1}{\\sqrt{\\lambda\\tau_s}}\n$$\n为了确认该值对应于加速比的最大值（即时间 $f(N)$ 的最小值），我们检查 $f(N)$ 的二阶导数：\n$$\n\\frac{d^2f}{dN^2} = \\frac{d}{dN} \\left( -\\frac{1}{N^2\\lambda} + \\tau_s \\right) = - \\left( \\frac{-2}{N^3\\lambda} \\right) = \\frac{2}{N^3\\lambda}\n$$\n由于 $\\lambda > 0$，$\\tau_s > 0$，最优的 $N^{\\star}$ 是正的。因此，对于任何 $N > 0$，我们有 $\\frac{d^2f}{dN^2} > 0$。这个正的二阶导数表明 $f(N)$ 对于 $N>0$ 是一个凸函数，并且 $N^{\\star}$ 对应于 $f(N)$ 的一个局部和全局最小值。因此，$N^{\\star}$ 产生了加速比 $\\mathbb{E}[S(N)]$ 的最大值。这是第二个要求的结果。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{N}{N^2\\lambda\\tau_s + N\\lambda\\tau_d + 1} & \\frac{1}{\\sqrt{\\lambda\\tau_s}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在实际的高性能计算环境中，计算节点往往存在性能差异，导致各个并行副本的模拟速度不尽相同。本练习将理论模型与实际应用相结合，要求您分析和比较同步与异步ParRep方案在异构资源下的性能表现。通过设计最优的调度策略，您将学会如何在保证模拟结果统计正确性的前提下，最大化计算资源的利用效率 。",
            "id": "3473158",
            "problem": "给定一个针对亚稳态逃逸问题的简化第一性原理模型——并行副本动力学（Parallel Replica Dynamics, ParRep）。假设以下基本前提：若单个副本在亚稳态势阱的准稳态分布中初始化，则其物理逃逸时间服从速率参数为 $\\lambda$（单位为时间倒数）的指数分布，即逃逸时间 $\\tau$ 满足 $\\tau \\sim \\mathrm{Exp}(\\lambda)$ 且 $\\mathbb{E}[\\tau] = 1/\\lambda$。考虑 $N$ 个独立的副本，每个副本单位物理时间的计算成本 $c_i > 0$（单位为秒/单位物理时间）是确定的、异构的。只要副本 $i$ 正在执行，它就以 $1/c_i$ 物理时间单位/秒（挂钟时间）的速率推进物理时间。\n\n定义两种方案，并通过将首次逃逸发生前所有副本推进的物理时间相加，推导获得单个轨迹逃逸时间的一个无偏样本（即，一个在物理时间上与 $\\mathrm{Exp}(\\lambda)$ 具有相同分布的样本）所需的期望挂钟时间：\n\n- 带壁垒的同步方案：所有副本同步推进。每个副本的挂钟速度受最慢副本的限制，因此总物理时间推进率为 $N / c_{\\max}$，其中 $c_{\\max} = \\max_i c_i$。令 $T_{\\mathrm{sync}}$ 为同步方案提供一个以物理单位计量的无偏逃逸时间样本所需的期望挂钟时间。\n\n- 异步非阻塞方案：所有副本以各自的速度独立推进，没有同步壁垒。总物理时间推进率为 $\\sum_{i=1}^N (1/c_i)$。令 $T_{\\mathrm{async}}$ 为异步方案提供一个以物理单位计量的无偏逃逸时间样本所需的期望挂钟时间。\n\n对于这两种方案，无偏性要求指的是在物理时间上保持逃逸时间定律，即报告的物理逃逸时间分布为 $\\mathrm{Exp}(\\lambda)$。这是通过将加速物理时间定义为直到观察到首次逃逸时所有运行中副本推进的物理时间之和来实现的。\n\n接下来，考虑一个广义调度问题，其中在任何时刻最多可以同时运行 $K$ 个副本，满足 $1 \\leq K \\leq N$。在任何给定时间，您可以选择一个大小为 $|S| = K$ 的子集 $S \\subset \\{0,1,\\dots,N-1\\}$ 来执行，其中每个选定的副本 $i \\in S$ 以 $1/c_i$ 的速率贡献物理时间进度。调度可以是静态的（始终使用固定的子集）或动态的（随时间变化的子集），但停止时间是观察到任何运行中副本发生第一次逃逸的瞬间。无偏性要求仍然是报告的物理逃逸时间在物理单位上以速率 $\\lambda$ 服从指数分布，这是通过将所有运行中副本推进的物理时间相加直到第一次逃逸发生来实现的。\n\n- 在任何时候最多运行 $K$ 个副本并保持上述意义上的无偏逃逸时间统计特性的约束下，构建一个最小化 $\\mathbb{E}[T_{\\mathrm{wall}}]$ 的最优调度策略下的期望挂钟时间 $T_{\\mathrm{opt}}$。\n\n- 当调度器仅限于静态子集时，用纯数学术语给出一个选择最优静态子集 $S^\\star$ 的规则，并计算该 $S^\\star$ 对应的 $T_{\\mathrm{opt}}$。论证为什么在所有静态调度中，您提出的规则能最小化期望挂钟时间。\n\n您的程序必须为一组测试用例实现推导出的公式和策略。所有物理单位必须按规定使用：成本 $c_i$ 的单位是秒/单位物理时间，$\\lambda$ 的单位是物理时间的倒数。所有期望挂钟时间都以秒为单位表示，并四舍五入到六位小数。\n\n测试套件规范。对于每个测试用例，给定 $(\\lambda, \\{c_i\\}_{i=0}^{N-1}, K)$。您必须计算四个输出：\n\n- $T_{\\mathrm{sync}}$（秒），\n- $T_{\\mathrm{async}}$（秒，这对应于 $K = N$ 且所有副本无壁垒运行的情况），\n- 给定 $K$ 的最优静态调度的 $T_{\\mathrm{opt}}$（秒），\n- 所选最优静态子集 $S^\\star$ 的索引列表（一个从0开始、升序排列的索引列表）。\n\n使用以下测试用例：\n\n- 案例 1：$\\lambda = $ $0.2$, $\\{c_i\\} = [$ $1.0$, $1.5$, $0.8$, $2.0$ $]$, $K = $ $2$.\n- 案例 2：$\\lambda = $ $1.0$, $\\{c_i\\} = [$ $1.0$, $1.0$, $1.0$ $]$, $K = $ $3$.\n- 案例 3：$\\lambda = $ $0.05$, $\\{c_i\\} = [$ $10.0$, $10.0$, $0.1$, $0.1$, $0.1$ $]$, $K = $ $3$.\n- 案例 4：$\\lambda = $ $2.0$, $\\{c_i\\} = [$ $3.0$ $]$, $K = $ $1$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例贡献一个形式为 $[T_{\\mathrm{sync}}, T_{\\mathrm{async}}, T_{\\mathrm{opt}}, S^\\star]$ 的列表。例如，整体输出应类似于 $[[\\cdot,\\cdot,\\cdot,[\\cdot]], [\\cdot,\\cdot,\\cdot,[\\cdot]], \\dots]$，所有时间以秒为单位，四舍五入到六位小数。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且客观的。它提出了一个简化的但标准的并行副本动力学（Parallel Replica Dynamics, ParRep）模型，我们可以据此推导出所要求的性能指标。\n\nParRep的核心原理依赖于指数分布的性质。如果单个过程的逃逸时间 $\\tau$ 服从 $\\mathrm{Exp}(\\lambda)$ 分布，其期望时间为 $\\mathbb{E}[\\tau] = 1/\\lambda$。如果我们运行该过程的 $M$ 个独立副本，其中第一个逃逸发生的时间 $\\tau_{\\text{first}}$ 将服从速率大 $M$ 倍的指数分布，即 $\\tau_{\\text{first}} \\sim \\mathrm{Exp}(M\\lambda)$，其期望值为 $\\mathbb{E}[\\tau_{\\text{first}}] = 1/(M\\lambda)$。\n\nParRep方法通过将总加速物理时间 $\\mathcal{T}_{\\text{phys}}$ 定义为所有副本直到首次逃逸事件发生时所模拟的物理时间之和，来生成原始单轨迹逃逸时间分布的一个无偏样本。对于运行了物理时间 $\\tau_{\\text{first}}$ 的 $M$ 个副本，这个总时间是 $\\mathcal{T}_{\\text{phys}} = M \\tau_{\\text{first}}$。$\\mathcal{T}_{\\text{phys}}$ 的分布是 $\\mathrm{Exp}((M\\lambda)/M) = \\mathrm{Exp}(\\lambda)$，这与原始分布相同。因此，为获得这样一个样本需要模拟的期望总物理时间是 $\\mathbb{E}[\\mathcal{T}_{\\text{phys}}] = 1/\\lambda$。\n\n物理时间与挂钟时间之间的联系由每个副本 $i$ 的计算成本 $c_i$ 决定。成本 $c_i$ 以秒/单位物理时间给出。因此，副本 $i$ 推进物理时间的速率是 $r_i = 1/c_i$，以物理时间单位/秒（挂钟时间）来衡量。\n\n令 $S$ 为在给定时刻运行的副本的索引集合。总物理时间推进率 $R_S$ 是运行中副本各自速率的总和：\n$$\nR_S = \\sum_{i \\in S} r_i = \\sum_{i \\in S} \\frac{1}{c_i}\n$$\n这个速率 $R_S$ 的单位是物理时间/秒。如果此速率恒定，模拟总物理时间 $\\mathcal{T}_{\\text{phys}}$ 所需的挂钟时间 $T_{\\text{wall}}$ 就是 $T_{\\text{wall}} = \\mathcal{T}_{\\text{phys}} / R_S$。\n\n我们寻求期望挂钟时间 $\\mathbb{E}[T_{\\text{wall}}]$。由于 $\\mathbb{E}[\\mathcal{T}_{\\text{phys}}] = 1/\\lambda$ 且对于一个固定的运行副本集合，挂钟时间与物理时间之间的关系是线性的，我们可以写出：\n$$\n\\mathbb{E}[T_{\\text{wall}}(S)] = \\frac{\\mathbb{E}[\\mathcal{T}_{\\text{phys}}]}{R_S} = \\frac{1/\\lambda}{\\sum_{i \\in S} \\frac{1}{c_i}} = \\frac{1}{\\lambda \\sum_{i \\in S} \\frac{1}{c_i}}\n$$\n这是对于一个静态运行副本集合 $S$ 的期望挂钟时间的通用公式。现在我们将其应用于具体的方案。\n\n**1. 同步方案 ($T_{\\mathrm{sync}}$)**\n在此方案中，所有 $N$ 个副本都运行，但它们被一个壁垒同步，导致所有副本都以最慢副本的速度进行。最慢的副本是计算成本最高的那个，即 $c_{\\max} = \\max_i c_i$。其速率为 $1/c_{\\max}$。因此，每个副本实际上都以这个相同的速率推进物理时间。总物理时间推进率是所有 $N$ 个副本的这些有效速率之和：\n$$\nR_{\\mathrm{sync}} = \\sum_{i=1}^N \\frac{1}{c_{\\max}} = \\frac{N}{c_{\\max}}\n$$\n于是，期望挂钟时间 $T_{\\mathrm{sync}}$ 为：\n$$\nT_{\\mathrm{sync}} = \\frac{1/\\lambda}{R_{\\mathrm{sync}}} = \\frac{1/\\lambda}{N/c_{\\max}} = \\frac{c_{\\max}}{N\\lambda}\n$$\n\n**2. 异步非阻塞方案 ($T_{\\mathrm{async}}$)**\n在此方案中，所有 $N$ 个副本以各自的最大速度独立运行。活动副本的集合是 $S = \\{0, 1, \\dots, N-1\\}$。总物理时间推进率是所有单个速率的总和：\n$$\nR_{\\mathrm{async}} = \\sum_{i=0}^{N-1} \\frac{1}{c_i}\n$$\n期望挂钟时间 $T_{\\mathrm{async}}$ 为：\n$$\nT_{\\mathrm{async}} = \\frac{1/\\lambda}{R_{\\mathrm{async}}} = \\frac{1}{\\lambda \\sum_{i=0}^{N-1} \\frac{1}{c_i}}\n$$\n这对应于有 $K=N$ 个可用处理器时的通用公式。\n\n**3. K个副本的最优调度 ($T_{\\mathrm{opt}}$)**\n问题要求在最多可同时运行 $K$ 个副本（其中 $1 \\leq K \\leq N$）的情况下，找到一个能最小化期望挂钟时间 $\\mathbb{E}[T_{\\text{wall}}]$ 的最优策略。\n对于任意一个由 $K$ 个副本组成的静态集合 $S$，期望时间为 $T(S) = (\\lambda \\sum_{i \\in S} c_i^{-1})^{-1}$。为了最小化 $T(S)$，我们必须最大化分母，特别是总速率 $R_S = \\sum_{i \\in S} c_i^{-1}$。\n由于逃逸过程是无记忆的（源于指数分布），运行哪些副本的最优选择不会随时间改变。在任何时刻，为了最大化进展速率，必须使用那 $K$ 个个体速度最快的副本。最快的副本是那些具有最高速率 $r_i = 1/c_i$ 的副本，这对应于最低的计算成本 $c_i$。\n\n**最优静态选择规则：**最优静态子集 $S^\\star$ 由对应于 $K$ 个最小成本 $c_i$ 的 $K$ 个副本组成。\n\n这个静态策略也是全局最优策略（在所有静态和动态调度中）。动态策略会涉及交换副本。然而，由于系统的状态在概率上始终是相同的（无记忆性），因此无法获得任何信息来证明改变运行副本集合是合理的。为了在任何挂钟时间 $T_w$ 最大化累积物理时间（即 $\\int_0^{T_w} R_{S(t')} dt'$），必须在每个瞬间 $t'$ 最大化被积函数 $R_{S(t')}$。这通过始终选择同一个集合 $S^\\star$ 来实现。\n\n因此，最小期望挂钟时间 $T_{\\mathrm{opt}}$ 是通过这个静态集合 $S^\\star$ 实现的：\n$$\nT_{\\mathrm{opt}} = \\frac{1}{\\lambda \\sum_{i \\in S^\\star} \\frac{1}{c_i}}\n$$\n其中 $S^\\star$ 是对应于 $\\{c_0, c_1, \\dots, c_{N-1}\\}$ 中 $K$ 个最小值的索引集合。根据问题规范，为 $S^\\star$ 提供的索引列表将按升序排序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Parallel Replica Dynamics scheduling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (lambda, c_i_list, K)\n        (0.2, [1.0, 1.5, 0.8, 2.0], 2),\n        (1.0, [1.0, 1.0, 1.0], 3),\n        (0.05, [10.0, 10.0, 0.1, 0.1, 0.1], 3),\n        (2.0, [3.0], 1),\n    ]\n\n    # A list to hold the string representation of each case's result\n    all_results_str = []\n\n    for case in test_cases:\n        lam, c_list, K = case\n        c = np.array(c_list)\n        N = len(c)\n\n        # 1. Synchronous scheme (T_sync)\n        c_max = np.max(c)\n        t_sync = c_max / (N * lam)\n\n        # 2. Asynchronous scheme (T_async, all N replicas running)\n        async_rate_sum = np.sum(1.0 / c)\n        t_async = 1.0 / (lam * async_rate_sum)\n\n        # 3. Optimal static schedule for K replicas (T_opt, S_star)\n        # Find the indices of the K replicas with the smallest costs c_i.\n        # np.argsort returns the indices that would sort the array.\n        sorted_indices = np.argsort(c)\n        s_star_indices = sorted_indices[:K]\n        \n        # Calculate T_opt using the costs of the optimal subset\n        optimal_subset_costs = c[s_star_indices]\n        optimal_rate_sum = np.sum(1.0 / optimal_subset_costs)\n        t_opt = 1.0 / (lam * optimal_rate_sum)\n\n        # The output requires the index list to be sorted\n        s_star_indices.sort()\n        s_star_list = s_star_indices.tolist()\n\n        # Format the results for this case into a string\n        # Round times to 6 decimal places as required.\n        # Manually format the list string to avoid spaces.\n        s_star_str = f\"[{','.join(map(str, s_star_list))}]\"\n        \n        result_str = (\n            f\"[{t_sync:.6f},\"\n            f\"{t_async:.6f},\"\n            f\"{t_opt:.6f},\"\n            f\"{s_star_str}]\"\n        )\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "并行副本动力学的有效性依赖于一个关键的物理假设：系统在势阱内部的弛豫（混合）要远快于其跨越势垒的稀有跃迁。本练习提供了一个具体的计算任务，让您通过“提交者函数”（committor function）分析来检验这一时间尺度分离假设。通过为一个一维三阱势编写代码并计算提交者函数的过渡层宽度，您将深入理解ParRep的理论基础，并掌握一种分析复杂系统动力学的重要方法 。",
            "id": "3473222",
            "problem": "考虑一个粒子在约束性三阱势中演化，其动力学行为由一维空间中的过阻尼朗之万动力学描述。该动力学由随机微分方程 $dx_t = -D \\beta U'(x_t) \\, dt + \\sqrt{2D} \\, dW_t$ 描述，其中 $x_t$ 是位置随时间 $t$ 变化的函数，$D$ 是恒定扩散系数，$\\beta$ 是逆温度，$U(x)$ 是势能函数，$U'(x)$ 是 $U(x)$ 的空间导数，$W_t$ 是一个标准 Wiener 过程。在无量纲单位中，取 $D = 1$。势能函数具体为 $U(x) = a x^6 - b x^4 + c x^2$，其参数 $a > 0$，$b > 0$，$c > 0$ 的选取需使 $U(x)$ 具有三个由两个局域极大值分隔的局域极小值。这在 $b^2 > 3 a c$ 时发生。将计算域定义为区间 $\\left[-L, L\\right]$，其中 $L > 0$ 足够大以包含外部势阱。\n\n并行副本动力学 (Parallel Replica Dynamics, PRD) 的一个关键假设是，阱内混合与跨阱穿越之间存在时间尺度分离：一旦系统进入一个势阱，它会迅速弛豫到准稳态分布，然后才会发生离开该势阱的稀有跃迁事件。验证此假设的一种方法是通过 committor 函数。对于一对不相交的边界 $x_\\ell, x_r$，committor 函数 $q(x)$ 定义为从位置 $x$ 开始的轨迹在到达边界 $x_\\ell$ 之前先到达边界 $x_r$ 的概率。\n\n您的任务是：\n\n1. 使用 $U(x)$ 的局域极小值和局域极大值将区域划分为多个势阱。具体而言：\n   - 通过求解 $U'(x) = 0$ 计算 $U(x)$ 的所有临界点，并根据 $U''(x)$ 的符号对其进行分类，以识别局域极小值和局域极大值。\n   - 设 $x = 0$ 为中心极小值（对于 $c > 0$）。利用剩余的临界点，确定位于 $x = -x_{\\min}$ 和 $x = +x_{\\min}$ 的左侧和右侧局域极小值，以及位于 $x = -x_{\\mathrm{sad}}$ 和 $x = +x_{\\mathrm{sad}}$ 的左侧和右侧局域极大值（一维中的鞍点），其中 $x_{\\mathrm{sad}} < x_{\\min}$。\n   - 将三个势阱定义为区间：左侧势阱 $\\left[-L, -x_{\\mathrm{sad}}\\right]$，中心势阱 $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$ 和右侧势阱 $\\left[+x_{\\mathrm{sad}}, +L\\right]$。\n\n2. 为每个势阱定义一个与跨阱穿越事件方向一致的合适的 committor 函数：\n   - 在左侧势阱中，将 $q_{\\mathrm{left}}(x)$ 定义为在到达 $-L$ 之前先到达 $-x_{\\mathrm{sad}}$ 的概率。\n   - 在中心势阱中，将 $q_{\\mathrm{center}}(x)$ 定义为在到达 $-x_{\\mathrm{sad}}$ 之前先到达 $+x_{\\mathrm{sad}}$ 的概率。\n   - 在右侧势阱中，将 $p_{\\mathrm{right}}(x)$ 定义为在到达 $+L$ 之前先到达 $+x_{\\mathrm{sad}}$ 的概率。\n   在所有情况下，使用与朗之万动力学相关的后向方程来计算这些 committor 函数，并对与该势阱相关的点对 $\\left(x_\\ell, x_r\\right)$ 使用吸收边界条件 $q(x_\\ell) = 0$ 和 $q(x_r) = 1$。以无量纲单位作答。\n\n3. 为了验证阱内混合相对于跨阱事件是快速的，通过计算 committor 函数值位于阈值 $0.1$ 和 $0.9$ 之间的区域宽度，来量化每个势阱内 committor 过渡层的陡峭程度。具体而言，对每个势阱，计算 committor 分别等于 $0.1$ 和 $0.9$ 时的位置 $x_{0.1}$ 和 $x_{0.9}$，并将过渡宽度定义为 $w = x_{0.9} - x_{0.1}$。将势阱宽度定义为 $W = x_r - x_\\ell$。对于右侧势阱，将此方法应用于 $p_{\\mathrm{right}}(x)$ 而非 $q_{\\mathrm{right}}(x)$，以便阈值解释与朝向中心的穿越保持一致。报告每个势阱的比率 $r = w / W$，最后对每个参数集，报告这三个势阱比率中的最大值。较小的 $r$ 值表示过渡区域相对于势阱尺寸较窄，因此意味着阱内混合相对于跨阱穿越是快速的。\n\n4. 实现一个完整的程序，执行上述步骤并为以下测试套件生成结果。全程使用无量纲单位。对于每个测试用例，输出一个等于三个势阱中最大过渡比率的浮点数：\n   - 测试用例 1：$a = 1.0$, $b = 3.0$, $c = 2.0$, $\\beta = 10.0$, $L = 3.0$。\n   - 测试用例 2：$a = 1.0$, $b = 2.8$, $c = 2.0$, $\\beta = 5.0$, $L = 3.0$。\n   - 测试用例 3：$a = 1.0$, $b = 3.5$, $c = 2.0$, $\\beta = 25.0$, $L = 3.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。每个结果必须是浮点数。不应打印任何其他文本。",
            "solution": "用户希望我解决一个多步骤的计算问题，该问题涉及验证在一维三阱势中粒子并行副本动力学 (PRD) 的一个假设。\n\n### 第 1 步：提取已知信息\n- **控制方程**: 过阻尼朗之万动力学，$dx_t = -D \\beta U'(x_t) \\, dt + \\sqrt{2D} \\, dW_t$。\n- **扩散系数**: $D=1$ (无量纲)。\n- **势能**: $U(x) = a x^6 - b x^4 + c x^2$。\n- **势能参数**: $a > 0$，$b > 0$，$c > 0$。\n- **三极小值条件**: $b^2 > 3ac$。\n- **计算域**: $\\left[-L, L\\right]$，$L > 0$。\n- **PRD 假设**: 快速阱内弛豫与慢速跨阱跃迁之间的时间尺度分离。\n- **验证方法**: 计算 committor 函数 $q(x)$ 并分析其过渡宽度。\n- **任务 1：势阱定义**:\n    - **临界点**: 求解 $U'(x)=0$。\n    - **使用 $U''(x)$ 将点分类为极小值点 ($\\pm x_{\\min}$, $0$) 和极大值点 ($\\pm x_{\\mathrm{sad}}$)。**\n    - **使用鞍点 $\\pm x_{\\mathrm{sad}}$ 建立势阱边界：**\n        - **左侧势阱**: $\\left[-L, -x_{\\mathrm{sad}}\\right]$。\n        - **中心势阱**: $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$。\n        - **右侧势阱**: $\\left[+x_{\\mathrm{sad}}, +L\\right]$。\n- **任务 2：Committor 函数**:\n    - **在 $[x_\\ell, x_r]$ 上的 Committor 函数 $q(x)$ 是在到达 $x_\\ell$ 之前先到达 $x_r$ 的概率。**\n    - **由后向方程控制: $q''(x) - \\beta U'(x) q'(x) = 0$ (当 $D=1$ 时)。**\n    - **边界条件**: $q(x_\\ell) = 0$，$q(x_r) = 1$。\n    - **具体的 committor 函数：**\n        - **左侧, $q_{\\mathrm{left}}(x)$: 在 $\\left[-L, -x_{\\mathrm{sad}}\\right]$ 上，在到达 $-L$ 之前先到达 $-x_{\\mathrm{sad}}$。**\n        - **中心, $q_{\\mathrm{center}}(x)$: 在 $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$ 上，在到达 $-x_{\\mathrm{sad}}$ 之前先到达 $+x_{\\mathrm{sad}}$。**\n        - **右侧, $p_{\\mathrm{right}}(x)$: 在 $\\left[+x_{\\mathrm{sad}}, +L\\right]$ 上，在到达 $+L$ 之前先到达 $+x_{\\mathrm{sad}}$。**\n- **任务 3：过渡比率**:\n    - **找到相关 committor 函数值为 $0.1$ 和 $0.9$ 的位置 $x_{0.1}$ 和 $x_{0.9}$。**\n    - **过渡宽度: $w = x_{0.9} - x_{0.1}$。(解释为 $|x_{0.9} - x_{0.1}|$ 以确保物理宽度为正)。**\n    - **势阱宽度: $W = x_r - x_\\ell$。**\n    - **比率: $r = w / W$。**\n    - **每个测试用例的最终结果: 三个势阱比率中的最大值。**\n- **任务 4：测试用例**:\n    1. $a = 1.0$, $b = 3.0$, $c = 2.0$, $\\beta = 10.0$, $L = 3.0$。\n    2. $a = 1.0$, $b = 2.8$, $c = 2.0$, $\\beta = 5.0$, $L = 3.0$。\n    3. $a = 1.0$, $b = 3.5$, $c = 2.0$, $\\beta = 25.0$, $L = 3.5$。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据、是良定且客观的。它描述了一个标准的物理模型（多阱势中的朗之万动力学），并使用成熟的数学工具（committor 函数、后向 Fokker-Planck 方程）来研究计算化学中的一个核心概念（时间尺度分离）。参数和条件是自洽且完备的。例如，条件 $b^2 > 3ac$ 确保了五个不同实临界点的存在，这对于三阱结构是必需的。任务是按算法定义的，并导向一个唯一的、可计算的解。唯一微小的不精确之处在于右侧势阱过渡宽度 $w = x_{0.9} - x_{0.1}$ 的定义，其中 committor 函数 $p_{\\mathrm{right}}(x)$ 是递减的。字面解释会产生负的宽度。物理上有意义的解释是宽度是一个正量，即 $|x_{0.9} - x_{0.1}|$。这一澄清不会使问题无效，但对于比较各势阱过渡陡峭程度的有意义解是必要的。\n\n### 第 3 步：结论与行动\n问题是有效的。我现在将着手解决。\n\n### 基于原理的设计\n解决方案通过一系列源自随机过程理论的逻辑步骤进行。\n\n**1. 势阱识别**\n\n势能由 $U(x) = a x^6 - b x^4 + c x^2$ 给出。吸引盆由势能的局域极大值（一维中的鞍点）分隔。为了找到这些点，我们首先通过求解 $U'(x) = 0$ 来计算临界点：\n$$ U'(x) = 6ax^5 - 4bx^3 + 2cx = 2x(3ax^4 - 2bx^2 + c) = 0 $$\n一个临界点是 $x=0$。其他的点通过解关于 $x^2$ 的二次方程 $3a(x^2)^2 - 2b(x^2) + c = 0$ 得到。$x^2$ 的解是：\n$$ x^2 = \\frac{2b \\pm \\sqrt{4b^2 - 12ac}}{6a} = \\frac{b \\pm \\sqrt{b^2 - 3ac}}{3a} $$\n条件 $b^2 > 3ac$ 确保了 $x^2$ 有两个不同的正解。设它们为 $x_{\\min}^2$ 和 $x_{\\mathrm{sad}}^2$。我们使用二阶导数 $U''(x) = 30ax^4 - 12bx^2 + 2c$ 的符号来对它们进行分类。\n- 对于 $x^2 = x_{\\mathrm{sad}}^2 = \\frac{b - \\sqrt{b^2 - 3ac}}{3a}$，$U''(x) < 0$，对应于位于 $\\pm x_{\\mathrm{sad}}$ 的局域极大值（鞍点）。\n- 对于 $x=0$，$U''(0) = 2c > 0$，对应于中心的局域极小值。\n- 对于 $x^2 = x_{\\min}^2 = \\frac{b + \\sqrt{b^2 - 3ac}}{3a}$，$U''(x) > 0$，对应于位于 $\\pm x_{\\min}$ 的侧阱局域极小值。\n然后，势阱由鞍点定义：左侧：$\\left[-L, -x_{\\mathrm{sad}}\\right]$，中心：$\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$，以及右侧：$\\left[+x_{\\mathrm{sad}}, L\\right]$。\n\n**2. Committor 函数解**\n\n在区间 $[x_\\ell, x_r]$ 上的 committor 函数 $q(x)$ 由后向方程控制，对于给定的过阻尼朗之万动力学且 $D=1$，该方程为：\n$$ \\frac{d^2q}{dx^2} - \\beta U'(x) \\frac{dq}{dx} = 0 $$\n边界条件为 $q(x_\\ell) = 0$ 和 $q(x_r) = 1$。这是一个二阶线性常微分方程。令 $v(x) = q'(x)$，我们得到一个一阶可分离方程 $v'(x) = \\beta U'(x) v(x)$，其解为 $v(x) = C_1 e^{\\beta U(x)}$。将 $q'(x)$ 从 $x_\\ell$ 积分到 $x$ 并应用边界条件，得到熟知的解：\n$$ q(x) = \\frac{\\displaystyle \\int_{x_\\ell}^{x} e^{\\beta U(y)} \\,dy}{\\displaystyle \\int_{x_\\ell}^{x_r} e^{\\beta U(y)} \\,dy} $$\n此公式直接适用于 $q_{\\mathrm{left}}(x)$ 和 $q_{\\mathrm{center}}(x)$。对于右侧势阱，committor 函数 $p_{\\mathrm{right}}(x)$ 是在到达 $+L$ 之前先到达 $+x_{\\mathrm{sad}}$ 的概率。这对应于设置 $x_\\ell = +L$ 和 $x_r = +x_{\\mathrm{sad}}$，导致 $p_{\\mathrm{right}}(+L)=0$ 和 $p_{\\mathrm{right}}(+x_{\\mathrm{sad}})=1$。解为：\n$$ p_{\\mathrm{right}}(x) = \\frac{\\displaystyle \\int_{+L}^{x} e^{\\beta U(y)} \\,dy}{\\displaystyle \\int_{+L}^{+x_{\\mathrm{sad}}} e^{\\beta U(y)} \\,dy} = 1 - \\frac{\\displaystyle \\int_{+x_{\\mathrm{sad}}}^{x} e^{\\beta U(y)} \\,dy}{\\displaystyle \\int_{+x_{\\mathrm{sad}}}^{+L} e^{\\beta U(y)} \\,dy} $$\n\n**3. 数值实现**\n\n问题的核心是为每个势阱计算比率 $r = w/W$。这需要找到每个 committor 函数的 $x_{0.1}$ 和 $x_{0.9}$ 位置。\n对于一个递增的 committor 函数 $q(x)$，我们必须解 $q(x) = 0.1$ 和 $q(x) = 0.9$。这等价于求解方程中的 $x$：\n$$ \\int_{x_\\ell}^{x} e^{\\beta U(y)} \\,dy = C \\cdot \\int_{x_\\ell}^{x_r} e^{\\beta U(y)} \\,dy $$\n其中 $C$ 是 $0.1$ 或 $0.9$。这是一个求根问题。\n\n一个重大的数值挑战来自于项 $e^{\\beta U(y)}$。对于大的 $\\beta$ 或大的 $|x|$，这一项可能导致浮点溢出。我们可以通过将势能移动一个常数 $U_0$ 来规避这个问题，而不会改变结果：\n$$ q(x) = \\frac{\\displaystyle \\int_{x_\\ell}^{x} e^{\\beta (U(y)-U_0)} \\,dy}{\\displaystyle \\int_{x_\\ell}^{x_r} e^{\\beta (U(y)-U_0)} \\,dy} $$\n通过选择 $U_0$ 作为区间 $[x_\\ell, x_r]$ 中 $U(y)$ 的最小值，我们确保指数 $\\beta(U(y)-U_0)$ 始终为非负，且其最小值为 $0$。这最大化了数值稳定性。\n\n每个势阱的总体算法如下：\n1.  定义势阱边界 $(x_\\ell, x_r)$。\n2.  使用数值优化程序找到势能的最小值 $U_0 = \\min_{y \\in [x_\\ell, x_r]} U(y)$。\n3.  定义稳定化的被积函数 $f(y) = e^{\\beta(U(y)-U_0)}$。\n4.  使用数值积分计算总积分 $I_{\\mathrm{tot}} = \\int_{x_\\ell}^{x_r} f(y) \\,dy$。\n5.  通过使用数值求根器求解方程 $\\int_{x_\\ell}^{x} f(y) \\,dy - C \\cdot I_{\\mathrm{tot}} = 0$（其中 $C=0.1$ 和 $C=0.9$）来求解 $x_{0.1}$ 和 $x_{0.9}$。\n6.  对于所有势阱，过渡宽度取为正距离 $w = |x_{0.9}-x_{0.1}|$。这与宽度的物理意义一致，并正确处理了递增（$q_{\\text{left}}, q_{\\text{center}}$）和递减（$p_{\\text{right}}$）的 committor 函数。\n7.  计算比率 $r = w / (x_r - x_\\ell)$。\n最后，选择三个势阱中的最大比率作为给定参数集的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq, minimize_scalar\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # (a, b, c, beta, L)\n        (1.0, 3.0, 2.0, 10.0, 3.0),\n        (1.0, 2.8, 2.0, 5.0, 3.0),\n        (1.0, 3.5, 2.0, 25.0, 3.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, c, beta, L = case\n        max_ratio = calculate_max_transition_ratio(a, b, c, beta, L)\n        results.append(max_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_transition_ratio(a, b, c, beta, L):\n    \"\"\"\n    Calculates the maximum transition ratio across the three basins for a given set of parameters.\n    \"\"\"\n    \n    # Define the potential energy function U(x)\n    U = lambda x: a * x**6 - b * x**4 + c * x**2\n    \n    # 1. Find critical points to define basins\n    # The saddles are roots of 3a*z^2 - 2b*z + c = 0 where z = x^2.\n    # We only need the smaller positive root for x^2, which corresponds to the saddle points.\n    discriminant = (2 * b)**2 - 4 * (3 * a) * c\n    # The x^2 value for the saddle point\n    x_sad_sq = (2 * b - np.sqrt(discriminant)) / (2 * 3 * a)\n    x_sad = np.sqrt(x_sad_sq)\n    \n    # Define the three basins based on the saddle points\n    basins = [\n        (-L, -x_sad),       # Left basin\n        (-x_sad, x_sad),    # Central basin\n        (x_sad, L),         # Right basin\n    ]\n    \n    ratios = []\n    for xl, xr in basins:\n        ratio = compute_ratio_for_basin(xl, xr, U, beta)\n        ratios.append(ratio)\n        \n    return max(ratios)\n\ndef compute_ratio_for_basin(xl, xr, U_func, beta):\n    \"\"\"\n    Computes the transition width to basin width ratio for a single basin.\n\n    This function calculates the width of the region where the normalized integral\n    of exp(beta*U(x)) is between 0.1 and 0.9. This corresponds to the physical\n    transition width of the committor function.\n    \"\"\"\n    \n    # 1. Numerical stabilization by shifting the potential\n    # Find the minimum of the potential U(x) in the interval [xl, xr]\n    res = minimize_scalar(U_func, bounds=(xl, xr), method='bounded')\n    U_min = res.fun\n    \n    # Define the numerically stable integrand\n    stable_integrand = lambda y: np.exp(beta * (U_func(y) - U_min))\n    \n    # 2. Compute the total integral for normalization\n    total_integral, _ = quad(stable_integrand, xl, xr, epsabs=1e-12, epsrel=1e-12)\n    \n    # 3. Define functions for the root-finder\n    # The root of this function gives the position x where the partial integral\n    # is 0.1 of the total integral.\n    def root_func_01(x):\n        integral_part, _ = quad(stable_integrand, xl, x, epsabs=1e-12, epsrel=1e-12)\n        return integral_part - 0.1 * total_integral\n    \n    # The root of this function gives the position x for the 0.9 threshold.\n    def root_func_09(x):\n        integral_part, _ = quad(stable_integrand, xl, x, epsabs=1e-12, epsrel=1e-12)\n        return integral_part - 0.9 * total_integral\n        \n    # 4. Find the positions x_0.1 and x_0.9 by finding the roots\n    # The brentq algorithm requires an interval where the function changes sign.\n    # The functions are monotonic, so [xl, xr] is a valid bracket.\n    try:\n        x_sol_01 = brentq(root_func_01, xl, xr)\n        x_sol_09 = brentq(root_func_09, xl, xr)\n    except ValueError:\n        # This may happen if the function does not change sign,\n        # e.g., if the integral is numerically zero. Return a default value.\n        return 0.0\n\n    # 5. Calculate widths and the final ratio\n    # W_basin is the total width of the basin\n    W_basin = xr - xl\n    \n    # w_transition is the width of the transition region (0.1 to 0.9)\n    # The width is a positive quantity, |x_0.9 - x_0.1|.\n    # Since the integral is monotonically increasing, x_sol_09 > x_sol_01.\n    w_transition = x_sol_09 - x_sol_01\n    \n    if W_basin == 0:\n        return 0.0\n\n    return w_transition / W_basin\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}