{
    "hands_on_practices": [
        {
            "introduction": "任何微动弹性带（NEB）计算的第一步都是为反应路径创建一个初始猜测。这个练习演示了最常见的方法：在初始和最终状态之间进行线性插值。通过这个练习，你将亲手实践处理晶格坐标和应用周期性边界条件等基本技能，这对于材料科学的模拟计算至关重要。",
            "id": "3471006",
            "problem": "考虑一个在六方密堆积晶体中，在周期性边界条件下的扩散事件，该事件使用微动弹性带（Nudged Elastic Band, NEB）方法进行建模，其中路径的端点固定在两个局部最小值。该晶体的晶格参数为 $a$ 和 $c$，原胞晶格矢量由 $\\mathbf{a}_{1} = (a, 0, 0)$、$\\mathbf{a}_{2} = \\left(\\frac{a}{2}, \\frac{\\sqrt{3}\\,a}{2}, 0\\right)$ 和 $\\mathbf{a}_{3} = (0, 0, c)$ 给出。一个间隙氢原子从分数坐标 $\\mathbf{s}_{A} = \\left(\\frac{1}{3}, \\frac{2}{3}, 0.25\\right)$ 移动到 $\\mathbf{s}_{B} = \\left(\\frac{2}{3}, \\frac{1}{3}, 0.25\\right)$，而所有其他原子保持固定。具有分数坐标 $\\mathbf{s} = (s_{x}, s_{y}, s_{z})$ 的点的笛卡尔位置为 $\\mathbf{R} = s_{x}\\,\\mathbf{a}_{1} + s_{y}\\,\\mathbf{a}_{2} + s_{z}\\,\\mathbf{a}_{3}$。使用最小镜像约定来选择分数位移 $\\Delta \\mathbf{s}$，使得每个分量都位于区间 $\\left[-\\frac{1}{2}, \\frac{1}{2}\\right]$ 内。\n\n通过在固定端点之间进行笛卡尔坐标的线性插值，构建一个包含 $M = 4$ 个中间构象的初始 NEB 路径带。将 NEB 构型空间距离视为 $3N$ 维（此处可移动原子数 $N = 1$）的标准欧几里得范数。晶格参数为 $a = 2.95\\,\\text{\\AA}$ 和 $c = 4.68\\,\\text{\\AA}$。计算构象间距离的集合 $\\left\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i}\\right\\|$，其中 $i = 0, 1, 2, 3, 4$，$\\mathbf{R}_{0}$ 和 $\\mathbf{R}_{5}$ 是固定端点，$\\mathbf{R}_{1}, \\dots, \\mathbf{R}_{4}$ 是插值得到的构象。将每个距离以埃（angstrom）为单位表示，并将结果四舍五入至四位有效数字。",
            "solution": "用户希望解决一个基于微动弹性带 (Nudged Elastic Band, NEB) 方法的问题。第一步是验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **晶体系统**：六方密堆积 (HCP)\n- **晶格参数**：$a = 2.95\\,\\text{\\AA}$，$c = 4.68\\,\\text{\\AA}$\n- **原胞晶格矢量**：$\\mathbf{a}_{1} = (a, 0, 0)$，$\\mathbf{a}_{2} = \\left(\\frac{a}{2}, \\frac{\\sqrt{3}\\,a}{2}, 0\\right)$，$\\mathbf{a}_{3} = (0, 0, c)$\n- **初始分数坐标**：$\\mathbf{s}_{A} = \\left(\\frac{1}{3}, \\frac{2}{3}, 0.25\\right)$\n- **最终分数坐标**：$\\mathbf{s}_{B} = \\left(\\frac{2}{3}, \\frac{1}{3}, 0.25\\right)$\n- **坐标变换**：对于分数坐标 $\\mathbf{s} = (s_{x}, s_{y}, s_{z})$，其笛卡尔位置为 $\\mathbf{R} = s_{x}\\,\\mathbf{a}_{1} + s_{y}\\,\\mathbf{a}_{2} + s_{z}\\,\\mathbf{a}_{3}$\n- **周期性边界条件**：对分数位移 $\\Delta \\mathbf{s}$ 使用最小镜像约定，使其分量位于区间 $\\left[-\\frac{1}{2}, \\frac{1}{2}\\right]$ 内。\n- **NEB 设置**：$M = 4$ 个中间构象。路径包含端点 $\\mathbf{R}_0 = \\mathbf{R}_A$ 和 $\\mathbf{R}_{M+1} = \\mathbf{R}_5 = \\mathbf{R}_B$。\n- **插值方法**：笛卡尔坐标下的线性插值。\n- **任务**：计算构象间距离集合 $\\left\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i}\\right\\|$，其中 $i = 0, 1, 2, 3, 4$。\n- **输出格式**：距离以埃为单位，并四舍五入至四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了晶体中扩散过程的微动弹性带初始路径的标准设置。HCP 晶格、分数坐标、最小镜像约定和线性插值都是计算材料科学中的标准概念和实践。所提供的晶格参数在物理上是现实的。该问题基于成熟的科学方法。\n- **适定性**：问题定义明确。计算所需距离的所有必要信息（晶格参数、坐标、构象数量、插值方案）均已提供。目标清晰，可以通过标准的数学程序确定唯一解。\n- **客观性**：语言精确、量化，没有任何主观或模棱两可的术语。\n\n该问题未表现出验证标准中列出的任何缺陷。数据是自洽且一致的。最终计算中未使用晶格参数 $c$ 并不构成缺陷；问题中包含可能不相关的数据以测试概念理解是很常见的。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供详细的解决方案。\n\n### 解答\n\n笛卡尔位置矢量 $\\mathbf{R} = (R_x, R_y, R_z)$ 与分数坐标矢量 $\\mathbf{s} = (s_x, s_y, s_z)$ 之间的关系由线性变换 $\\mathbf{R} = \\mathbf{L}\\mathbf{s}$ 给出，其中 $\\mathbf{L}$ 是晶格矩阵，其列为原胞晶格矢量 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{a}_3$。\n$$\n\\mathbf{L} = \\begin{pmatrix} a  \\frac{a}{2}  0 \\\\ 0  \\frac{\\sqrt{3}\\,a}{2}  0 \\\\ 0  0  c \\end{pmatrix}\n$$\n该问题定义了单个原子从初始位置到最终位置的路径。端点以分数坐标给出：\n初始位置：$\\mathbf{s}_0 = \\mathbf{s}_A = \\left(\\frac{1}{3}, \\frac{2}{3}, 0.25\\right)$\n最终位置：$\\mathbf{s}_{\\text{end}} = \\mathbf{s}_B = \\left(\\frac{2}{3}, \\frac{1}{3}, 0.25\\right)$\n\n我们必须首先在周期性边界条件下，使用最小镜像约定，找到连接这两点的最短位移矢量。分数坐标中的原始位移为：\n$$\n\\Delta \\mathbf{s}_{\\text{raw}} = \\mathbf{s}_B - \\mathbf{s}_A = \\left(\\frac{2}{3} - \\frac{1}{3}, \\frac{1}{3} - \\frac{2}{3}, 0.25 - 0.25\\right) = \\left(\\frac{1}{3}, -\\frac{1}{3}, 0\\right)\n$$\n$\\Delta \\mathbf{s}_{\\text{raw}}$ 的每个分量都已在区间 $\\left[-\\frac{1}{2}, \\frac{1}{2}\\right]$ 内，因此这就是最小镜像位移矢量，即 $\\Delta \\mathbf{s} = \\Delta \\mathbf{s}_{\\text{raw}}$。\n\n笛卡尔坐标中的位移矢量 $\\Delta \\mathbf{R}$ 通过变换 $\\Delta \\mathbf{s}$ 得到：\n$$\n\\Delta \\mathbf{R} = \\mathbf{L} \\Delta \\mathbf{s} = \\frac{1}{3}\\mathbf{a}_1 - \\frac{1}{3}\\mathbf{a}_2 + 0\\mathbf{a}_3\n$$\n代入 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 的定义：\n$$\n\\Delta \\mathbf{R} = \\frac{1}{3}(a, 0, 0) - \\frac{1}{3}\\left(\\frac{a}{2}, \\frac{\\sqrt{3}\\,a}{2}, 0\\right) = \\left(\\frac{a}{3} - \\frac{a}{6}, -\\frac{\\sqrt{3}\\,a}{6}, 0\\right) = \\left(\\frac{a}{6}, -\\frac{\\sqrt{3}\\,a}{6}, 0\\right)\n$$\n这个总位移矢量的大小为：\n$$\n\\|\\Delta \\mathbf{R}\\| = \\sqrt{\\left(\\frac{a}{6}\\right)^2 + \\left(-\\frac{\\sqrt{3}\\,a}{6}\\right)^2 + 0^2} = \\sqrt{\\frac{a^2}{36} + \\frac{3a^2}{36}} = \\sqrt{\\frac{4a^2}{36}} = \\sqrt{\\frac{a^2}{9}} = \\frac{a}{3}\n$$\nNEB 路径总共由 $M+2 = 4+2 = 6$ 个构象组成：$\\mathbf{R}_0, \\mathbf{R}_1, \\mathbf{R}_2, \\mathbf{R}_3, \\mathbf{R}_4, \\mathbf{R}_5$。其中，$\\mathbf{R}_0$ 是初始态，$\\mathbf{R}_5$ 是最终态。该路径通过在笛卡尔坐标中进行线性插值来构建。这意味着总的笛卡尔位移矢量 $\\Delta \\mathbf{R} = \\mathbf{R}_5 - \\mathbf{R}_0$ 被分成 $M+1 = 5$ 个相等的段。\n\n第 $i$ 个构象的位置由以下公式给出：\n$$\n\\mathbf{R}_i = \\mathbf{R}_0 + \\frac{i}{M+1} \\Delta \\mathbf{R} = \\mathbf{R}_0 + \\frac{i}{5} \\Delta \\mathbf{R} \\quad \\text{for } i = 0, 1, \\dots, 5\n$$\n分隔两个连续构象 $\\mathbf{R}_{i+1}$ 和 $\\mathbf{R}_i$ 的矢量为：\n$$\n\\mathbf{R}_{i+1} - \\mathbf{R}_i = \\left(\\mathbf{R}_0 + \\frac{i+1}{5}\\Delta\\mathbf{R}\\right) - \\left(\\mathbf{R}_0 + \\frac{i}{5}\\Delta\\mathbf{R}\\right) = \\frac{1}{5}\\Delta\\mathbf{R}\n$$\n对于初始路径带的所有段（$i = 0, 1, 2, 3, 4$），这个矢量是恒定的。因此，任意两个连续构象之间的距离也是恒定的：\n$$\n\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| = \\left\\|\\frac{1}{5}\\Delta\\mathbf{R}\\right\\| = \\frac{1}{5}\\|\\Delta\\mathbf{R}\\|\n$$\n代入先前计算的大小 $\\|\\Delta\\mathbf{R}\\| = \\frac{a}{3}$：\n$$\n\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| = \\frac{1}{5} \\left(\\frac{a}{3}\\right) = \\frac{a}{15}\n$$\n现在，我们代入给定的晶格参数数值 $a = 2.95\\,\\text{\\AA}$：\n$$\n\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| = \\frac{2.95\\,\\text{\\AA}}{15} \\approx 0.196666\\dots\\,\\text{\\AA}\n$$\n按要求将结果四舍五入到四位有效数字，得到 $0.1967\\,\\text{\\AA}$。\n\n对于 $i=0, 1, 2, 3, 4$，构象间距离的集合是一组五个相同的值。\n$\\|\\mathbf{R}_1 - \\mathbf{R}_0\\| = \\frac{a}{15} \\approx 0.1967\\,\\text{\\AA}$\n$\\|\\mathbf{R}_2 - \\mathbf{R}_1\\| = \\frac{a}{15} \\approx 0.1967\\,\\text{\\AA}$\n$\\|\\mathbf{R}_3 - \\mathbf{R}_2\\| = \\frac{a}{15} \\approx 0.1967\\,\\text{\\AA}$\n$\\|\\mathbf{R}_4 - \\mathbf{R}_3\\| = \\frac{a}{15} \\approx 0.1967\\,\\text{\\AA}$\n$\\|\\mathbf{R}_5 - \\mathbf{R}_4\\| = \\frac{a}{15} \\approx 0.1967\\,\\text{\\AA}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.1967  0.1967  0.1967  0.1967  0.1967 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在建立初始路径后，NEB算法通过计算图像上的力并移动它们来工作。一个关键步骤是定义路径的局部切线，以便将力分解为垂直分量（驱动路径向最小能量路径移动）和平行分量（弹簧力）。这项实践探讨了NEB中使用的离散切线近似的几何精度，这对方法的正确性至关重要。通过将离散切线与已知最小能量路径（MEP）的真实切线进行比较，你将量化固有的几何误差，并理解它与路径曲率和图像间距的关系，这是解释NEB结果的一个关键概念。",
            "id": "3471060",
            "problem": "给定一个精确定义的二维势能面 (PES)，要求您针对一组情景，计算已知的最小能量路径 (MEP) 的真实切线与微动弹性带 (Nudged Elastic Band, NEB) 方法中使用的离散对称差分切线之间的偏差角。任务是实现一个完整的程序，执行这些计算，并生成一个单行输出，汇总所有结果。\n\n势能面 (PES) 定义为\n$$\nV(x,y) \\equiv U(x) + \\frac{k_{\\perp}}{2}\\left(y - g(x)\\right)^2,\n$$\n其中谷底中心线为\n$$\ng(x) \\equiv \\alpha x^2,\n$$\n平坦的基线为\n$$\nU(x) \\equiv 0.\n$$\n此处，$x$ 和 $y$ 是笛卡尔坐标，$\\alpha$ 是一个曲率参数，$k_{\\perp}$ 控制垂直于谷底方向的刚度。由于 $U(x)$ 是平坦的，已知的最小能量路径 (MEP) 精确地是在区间 $[x_A,x_B]$ 内的曲线 $\\mathcal{C}: y = g(x)$。\n\n对于此问题，请使用以下参数值：\n- $\\alpha = 0.3$，\n- $x_A = 0.1$，\n- $x_B = 1.1$。\n\n设沿曲线 $\\mathcal{C}$ 从 $x_A$ 到任意 $x \\in [x_A,x_B]$ 的弧长为\n$$\nS(x) \\equiv \\int_{x_A}^{x} \\sqrt{1 + \\left(g'(u)\\right)^2}\\,du,\n$$\n并设总弧长为\n$$\nS_{\\mathrm{tot}} \\equiv S(x_B).\n$$\n将中点弧长记为\n$$\ns_0 \\equiv \\frac{S_{\\mathrm{tot}}}{2}.\n$$\n\n考虑在弧长参数为 $s_0 - \\Delta s$、$s_0$ 和 $s_0 + \\Delta s$ 处的三个图像 (image)，它们精确地放置在 MEP 上（具有相等的弧长间距 $\\Delta s$）。通过反转 $S(x)$ 将弧长映射回 $x$ 来定义相应的图像位置，即找到 $x(s)$ 使得 $S\\!\\left(x(s)\\right)=s$，然后设\n$$\n\\mathbf{R}(s) \\equiv \\big(x(s),\\, g\\!\\left(x(s)\\right)\\big).\n$$\n\n定义：\n- $s_0$ 处的真实单位切线为\n$$\n\\hat{\\mathbf{t}}_{\\mathrm{true}} \\equiv \\frac{\\left(1,\\, g'(x_0)\\right)}{\\sqrt{1 + \\left(g'(x_0)\\right)^2}}, \\quad \\text{其中 } x_0 \\equiv x(s_0)。\n$$\n- 中间图像处的离散对称差分切线为\n$$\n\\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}} \\equiv \\frac{\\mathbf{R}(s_0+\\Delta s) - \\mathbf{R}(s_0-\\Delta s)}{\\left\\|\\mathbf{R}(s_0+\\Delta s) - \\mathbf{R}(s_0-\\Delta s)\\right\\|}.\n$$\n\n偏差角是这两个单位向量之间的绝对主夹角，\n$$\n\\theta \\equiv \\arccos\\!\\left(\\hat{\\mathbf{t}}_{\\mathrm{true}} \\cdot \\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}}\\right),\n$$\n以弧度表示。\n\n对于每个测试用例，您将得到一对 $(r, k_s)$，其中 $r$ 是一个无量纲比率，通过 $\\Delta s \\equiv r\\, S_{\\mathrm{tot}}$ 设定图像间距，$k_s$ 是沿着路径带的 NEB 弹簧常数。在收敛的标准 NEB 公式中，相等的弧长间距的形成与 $k_s$ 的大小无关，因此当图像以精确相等的间距精确位于 MEP 上时，$k_s$ 不会影响 $\\theta$。尽管如此，您的程序必须能够接受 $(r,k_s)$ 对，并使用 $\\Delta s = r S_{\\mathrm{tot}}$ 计算如上定义的 $\\theta$。\n\n角度单位要求：以弧度报告所有偏差角。\n\n实现一个程序，该程序：\n- 使用上述定义，\n- 通过数值积分计算 $S_{\\mathrm{tot}}$，\n- 通过数值方法反转 $S(x)$ 来计算任意 $s \\in [0,S_{\\mathrm{tot}}]$ 的 $x(s)$，\n- 将三个图像放置在 $s_0 - \\Delta s$、$s_0$ 和 $s_0 + \\Delta s$ 处，\n- 为每个测试用例计算 $\\theta$。\n\n测试套件：\n- 情况 1：$(r, k_s) = (0.10, 1.0)$，\n- 情况 2：$(r, k_s) = (0.05, 7.5)$，\n- 情况 3：$(r, k_s) = (0.45, 50.0)$，\n- 情况 4：$(r, k_s) = (0.20, 0.5)$。\n\n所有情况均满足 $0  r \\le 0.5$，确保 $s_0 \\pm \\Delta s$ 保持在 $[0, S_{\\mathrm{tot}}]$ 范围内。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[a_1,a_2,a_3,a_4]$），其中每个 $a_i$ 是按上述顺序列出的相应测试用例的偏差角 $\\theta$（一个以弧度为单位的浮点数）。",
            "solution": "此问题的核心目标是计算最小能量路径 (MEP) 的真实几何切线与微动弹性带 (Nudged Elastic Band, NEB) 方法中使用的离散切线近似之间的偏差角 $\\theta$。这个角度量化了路径离散化所固有的几何误差源。该分析在指定的二维势能面 (PES) 上进行。\n\n势能面由以下函数给出\n$$\nV(x,y) = U(x) + \\frac{k_{\\perp}}{2}\\left(y - g(x)\\right)^2\n$$\n其中谷底的势能为 $U(x) \\equiv 0$，谷底中心线是由 $g(x) \\equiv \\alpha x^2$ 定义的抛物线。指定的参数为 $\\alpha=0.3$，并且路径考虑的是 $x$ 在区间 $[x_A, x_B]$ 内，其中 $x_A=0.1$ 且 $x_B=1.1$。由于势能是恒定的 ($U(x)=0$)，并且对于任何 $x$，当 $y=g(x)$ 时势能最小化，因此 MEP 精确地是当 $x \\in [x_A, x_B]$ 时由 $y = g(x)$ 描述的曲线 $\\mathcal{C}$。\n\n计算过程涉及几个不同的步骤，详述如下。\n\n**1. 弧长参数化**\n为了处理 MEP 上的位置，我们首先建立一个弧长参数化。从起始点 $x_A$ 到任意点 $x \\in [x_A, x_B]$，曲线 $y=g(x)$ 的弧长 $S$ 由以下积分给出：\n$$\nS(x) = \\int_{x_A}^{x} \\sqrt{1 + \\left(g'(u)\\right)^2}\\,du\n$$\n对于 $g(x) = \\alpha x^2$，其导数为 $g'(x) = 2\\alpha x$。代入 $\\alpha = 0.3$ 的值，被积函数变为 $\\sqrt{1+(0.6u)^2}$。\n路径段的总弧长 $S_{\\mathrm{tot}}$，通过在终点 $x_B=1.1$ 处计算该积分得到：\n$$\nS_{\\mathrm{tot}} = S(x_B) = \\int_{0.1}^{1.1} \\sqrt{1 + (0.6u)^2}\\,du\n$$\n该积分使用数值求积法计算，从而为总路径长度提供一个精确值。\n\n**2. 通过反转弧长函数来放置图像**\n问题指定了沿 MEP 在弧长为 $s_0 - \\Delta s$、$s_0$ 和 $s_0 + \\Delta s$ 处放置三个图像。这里，$s_0 = S_{\\mathrm{tot}}/2$ 是中点弧长，间距 $\\Delta s$ 由无量纲比率 $r$ 通过 $\\Delta s = r S_{\\mathrm{tot}}$ 确定。\n为了找到与给定弧长 $s$ 对应的笛卡尔坐标 $\\mathbf{R}(s) = (x(s), g(x(s)))$，我们必须对函数 $S(x)$ 进行反转。这意味着求解方程 $S(x) = s$ 以得到 $x$。由于 $S(x)$ 是一个严格单调递增函数，对于任何 $s \\in [0, S_{\\mathrm{tot}}]$ 都存在唯一的解 $x(s)$。这种反转是通过在区间 $[x_A, x_B]$ 内找到函数 $f(x) = S(x) - s = 0$ 的根来数值化执行的。\n\n**3. 切向量定义**\n在确定图像位置后，我们可以定义位于弧长 $s_0$ 处的中心图像的两个我们感兴趣的切向量。\n\n**真实单位切向量** $\\hat{\\mathbf{t}}_{\\mathrm{true}}$ 是由曲线 $\\mathcal{C}$ 在点 $x_0 = x(s_0)$ 处的精确微分几何定义的。由 $x$ 参数化的曲线的切向量是 $(1, g'(x))$。对该向量进行归一化可得到单位切线：\n$$\n\\hat{\\mathbf{t}}_{\\mathrm{true}} = \\frac{(1, g'(x_0))}{\\sqrt{1 + (g'(x_0))^2}}\n$$\n\n**离散对称差分切线** $\\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}}$ 是 NEB 方法中使用的近似值。它是由两个相邻图像的位置 $\\mathbf{R}(s_0-\\Delta s)$ 和 $\\mathbf{R}(s_0+\\Delta s)$ 构建的：\n$$\n\\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}} = \\frac{\\mathbf{R}(s_0+\\Delta s) - \\mathbf{R}(s_0-\\Delta s)}{\\left\\|\\mathbf{R}(s_0+\\Delta s) - \\mathbf{R}(s_0-\\Delta s)\\right\\|}\n$$\n这个向量表示连接两个相邻点的弦的方向。问题陈述中的参数 $k_s$ 和 $k_\\perp$ 不参与此几何计算，因为图像位置已预先确定为以相等的弧长间距精确位于 MEP 上，这代表了一种理想化的收敛状态。\n\n**4. 偏差角的计算**\n偏差角 $\\theta$ 是这两个单位向量之间的绝对夹角。它通过它们的点积计算得出：\n$$\n\\theta = \\arccos(\\hat{\\mathbf{t}}_{\\mathrm{true}} \\cdot \\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}})\n$$\n结果以弧度表示，衡量了离散切线近似的误差。此误差从根本上是由于路径的局部曲率造成的；对于直线路径，误差将为零。\n\n**每个测试用例 $(r, k_s)$ 的算法摘要：**\n1.  数值计算总弧长 $S_{\\mathrm{tot}} = \\int_{x_A}^{x_B} \\sqrt{1 + (2\\alpha u)^2}\\,du$。\n2.  计算中点弧长 $s_0 = S_{\\mathrm{tot}}/2$ 和间距 $\\Delta s = r S_{\\mathrm{tot}}$。\n3.  确定三个弧长值：$s_{-} = s_0 - \\Delta s$、$s_0$ 和 $s_{+} = s_0 + \\Delta s$。\n4.  对于每个 $s \\in \\{s_{-}, s_0, s_{+}\\}$，通过数值求解方程 $\\left(\\int_{x_A}^{x} \\sqrt{1+(2\\alpha u)^2}\\,du\\right) - s = 0$ 来找到相应的坐标 $x(s)$。设解为 $x_{-}$、$x_0$ 和 $x_{+}$。\n5.  计算外部图像的位置：$\\mathbf{R}_{-} = (x_{-}, \\alpha x_{-}^2)$ 和 $\\mathbf{R}_{+} = (x_{+}, \\alpha x_{+}^2)$。\n6.  使用 $x_0$ 计算真实切向量 $\\hat{\\mathbf{t}}_{\\mathrm{true}}$。\n7.  使用 $\\mathbf{R}_{-}$ 和 $\\mathbf{R}_{+}$ 计算离散切向量 $\\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}}$。\n8.  计算偏差角 $\\theta = \\arccos(\\hat{\\mathbf{t}}_{\\mathrm{true}} \\cdot \\hat{\\boldsymbol{\\tau}}_{\\mathrm{disc}})$。\n\n对提供的测试套件中的每一对 $(r, k_s)$ 重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the deviation angle between the true MEP tangent and the discrete NEB tangent\n    for a set of test cases on a defined 2D potential energy surface.\n    \"\"\"\n    # 1. Define constants and functions based on the problem statement.\n    ALPHA = 0.3\n    X_A = 0.1\n    X_B = 1.1\n\n    def g(x):\n        \"\"\"Parabolic valley centerline y = g(x).\"\"\"\n        return ALPHA * x**2\n\n    def g_prime(x):\n        \"\"\"Derivative of the valley centerline, g'(x).\"\"\"\n        return 2 * ALPHA * x\n\n    def arc_length_integrand(u):\n        \"\"\"Integrand for the arc-length calculation: sqrt(1 + g'(u)^2).\"\"\"\n        return np.sqrt(1 + g_prime(u)**2)\n\n    # 2. Compute the total arc-length S_tot by numerical integration.\n    # The quad_cache dictionary will memoize the results of the quad function\n    # to avoid re-computation, particularly within the root-finding routine.\n    quad_cache = {}\n    def S(x):\n        \"\"\"\n        Calculates the arc-length S(x) from X_A to x.\n        Uses memoization to speed up repeated calculations with the same x.\n        \"\"\"\n        if x in quad_cache:\n            return quad_cache[x]\n        if x == X_A:\n            return 0.0\n        \n        # Integrate from X_A to x to find the arc length.\n        result, _ = quad(arc_length_integrand, X_A, x)\n        quad_cache[x] = result\n        return result\n    \n    S_tot = S(X_B)\n\n    # 3. Define the function to invert S(x) to find x(s).\n    # The x_of_s_cache dictionary will memoize the results of the inversion.\n    x_of_s_cache = {}\n    def x_of_s(s):\n        \"\"\"\n        Finds the coordinate x that corresponds to a given arc-length s by\n        numerically inverting S(x).\n        \"\"\"\n        if s in x_of_s_cache:\n            return x_of_s_cache[s]\n\n        # Function whose root we want to find: S(x) - s = 0.\n        def root_function(x):\n            return S(x) - s\n\n        # brentq is a robust root-finding algorithm given a bracket [a, b]\n        # where the function has opposite signs at a and b.\n        # S(X_A) - s = -s = 0 and S(X_B) - s = S_tot - s = 0 for s in [0, S_tot],\n        # so [X_A, X_B] is a valid bracket.\n        x_val = brentq(root_function, X_A, X_B)\n        x_of_s_cache[s] = x_val\n        return x_val\n\n    # 4. Define test cases and process them.\n    test_cases = [\n        (0.10, 1.0),\n        (0.05, 7.5),\n        (0.45, 50.0),\n        (0.20, 0.5),\n    ]\n\n    results = []\n    \n    # The midpoint arc-length is constant for all cases.\n    s0 = S_tot / 2.0\n    \n    for r, k_s in test_cases:\n        # a. Calculate the arc-length spacing Delta_s from the ratio r.\n        delta_s = r * S_tot\n        \n        # b. Define the arc-lengths for the three images.\n        s_minus = s0 - delta_s\n        s_mid = s0\n        s_plus = s0 + delta_s\n        \n        # c. Find the corresponding x-coordinates by inverting S(x).\n        x_minus = x_of_s(s_minus)\n        x_mid = x_of_s(s_mid)\n        x_plus = x_of_s(s_plus)\n        \n        # d. Calculate the true unit tangent vector at the middle image.\n        true_tangent_unnormalized = np.array([1.0, g_prime(x_mid)])\n        t_true = true_tangent_unnormalized / np.linalg.norm(true_tangent_unnormalized)\n        \n        # e. Calculate the discrete symmetric-difference tangent vector.\n        R_minus = np.array([x_minus, g(x_minus)])\n        R_plus = np.array([x_plus, g(x_plus)])\n        discrete_tangent_unnormalized = R_plus - R_minus\n        tau_disc = discrete_tangent_unnormalized / np.linalg.norm(discrete_tangent_unnormalized)\n\n        # f. Calculate the deviation angle theta.\n        # The dot product of two unit vectors gives the cosine of the angle between them.\n        dot_product = np.dot(t_true, tau_disc)\n        \n        # Clip the dot product to the valid range [-1.0, 1.0] to prevent\n        # potential domain errors in arccos due to floating-point inaccuracies.\n        dot_product = np.clip(dot_product, -1.0, 1.0)\n        \n        theta = np.arccos(dot_product)\n        results.append(theta)\n\n    # 5. Print the final results in the specified format.\n    # The output is a single line: a comma-separated list of angles in radians,\n    # enclosed in square brackets.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实践中，简单的切线定义在复杂的能量面上可能会失效，导致“Z形振荡”等数值不稳定性，从而阻碍收敛。本练习演示了这种不稳定性是如何在一个具有高峰值的路径上由不良的切线估计引起的，并介绍了减轻这些问题的先进技术。你将实现并比较一个朴素的切线和一个更稳健的自适应切线，通过测量垂直力分量来量化改进效果，这将让你深入了解NEB的实际挑战以及复杂算法选择的重要性。",
            "id": "3471037",
            "problem": "设计并实现一个完整的、可运行的程序，该程序构建一个二维尖点状势能面，并比较在微动弹性带（Nudged Elastic Band, NEB）方法的两种变体（朴素中心差分切线和自适应切线）下，沿着离散路径的各个映像点所受到的最大垂直力。其目标是量化势能面的平滑化或自适应切线的使用，如何通过减小最大垂直力来减少映像点的伪Z形振荡。您的程序必须是自包含的，并且在没有用户输入的情况下产生所需的输出。\n\n从以下基础和定义开始。\n\n1. 势能面是一个函数 $V:\\mathbb{R}^2 \\to \\mathbb{R}$，其未平滑的尖点形式为 $V(x,y) = |x| + \\tfrac{1}{2}k_y y^2$。通过将 $|x|$ 替换为 $\\sqrt{x^2 + \\varepsilon^2}$ 来平滑尖点，其中 $\\varepsilon \\ge 0$ 是一个平滑参数，即 $V_{\\varepsilon}(x,y) = \\sqrt{x^2 + \\varepsilon^2} + \\tfrac{1}{2}k_y y^2$，并约定 $V_0(x,y) = |x| + \\tfrac{1}{2}k_y y^2$。使用 $k_y$ 和 $\\varepsilon$ 作为依赖于具体案例的参数，具体说明如下。\n\n2. 物理力定义为 $\\mathbf{F}(x,y) = -\\nabla V_{\\varepsilon}(x,y)$。对于 $\\varepsilon = 0$，定义当 $x \\ne 0$ 时 $\\partial V_0/\\partial x = \\operatorname{sign}(x)$，当 $x=0$ 时为 $0$，以及 $\\partial V_0/\\partial y = k_y y$。对于 $\\varepsilon > 0$，定义 $\\partial V_{\\varepsilon}/\\partial x = x/\\sqrt{x^2 + \\varepsilon^2}$ 以及 $\\partial V_{\\varepsilon}/\\partial y = k_y y$。\n\n3. 在微动弹性带（NEB）方法中，索引为 $i=0,\\dots,N-1$ 的映像点 $\\mathbf{R}_i \\in \\mathbb{R}^2$ 在固定的端点 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 之间进行插值。力计算中不包括端点。使用以下两种方案之一来定义映像点 $i$ 处的单位切线 $\\boldsymbol{\\tau}_i$：\n   - 朴素中心差分切线：$\\boldsymbol{\\tau}_i$ 是向量 $\\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}$ 的归一化向量。\n   - 自适应切线（Henkelman–Jónsson 风格）：设 $E_j = V_{\\varepsilon}(\\mathbf{R}_j)$，$\\Delta E^{+} = E_{i+1} - E_i$ 和 $\\Delta E^{-} = E_i - E_{i-1}$。如果 $\\Delta E^{+} > 0$ 且 $\\Delta E^{-} > 0$，则选择沿 $\\mathbf{R}_{i+1} - \\mathbf{R}_i$ 方向的 $\\boldsymbol{\\tau}_i$。如果 $\\Delta E^{+}  0$ 且 $\\Delta E^{-}  0$，则选择沿 $\\mathbf{R}_i - \\mathbf{R}_{i-1}$ 方向的 $\\boldsymbol{\\tau}_i$。否则，选择对应于 $|\\Delta E^{+}|$ 和 $|\\Delta E^{-}|$ 中较大值的方向。\n\n4. 对于任何映像点 $i$，将来自物理力的 NEB 垂直力分量定义为 $\\mathbf{F}_{\\perp,i} = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$，其中 $\\mathbf{F}_i = \\mathbf{F}(\\mathbf{R}_i)$。将我们关注的度量定义为 $F_{\\perp}^{\\max} = \\max_{i=1,\\dots,N-2} \\|\\mathbf{F}_{\\perp,i}\\|_2$。\n\n按如下方式构建映像点。将端点固定在 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_{N-1} = (1,0)$。对于 $N$ 个映像点，将 $x_i$ 均匀分布在 $-1$ 和 $1$ 之间，即对于 $i=0,\\dots,N-1$，$x_i = -1 + \\frac{2i}{N-1}$。令 $y_0 = y_{N-1} = 0$。对于内部映像点，使用交替的横向位移 $y_i = A \\cdot (-1)^i \\cdot \\exp(-\\alpha |x_i|)$ 来模拟伪Z形振荡，其中 $A$ 和 $\\alpha$ 在每个测试案例中指定。\n\n实现一个程序，该程序：\n- 为给定的参数和指定的切线方案计算 $F_{\\perp}^{\\max}$。\n- 比较有平滑（即 $\\varepsilon  0$）和无平滑（即 $\\varepsilon = 0$）的配置。\n- 通过比率 $r = F_{\\perp,\\text{baseline}}^{\\max} / F_{\\perp,\\text{improved}}^{\\max}$ 来量化 $F_{\\perp}^{\\max}$ 的减小量，其中基线是在未平滑势能上使用朴素切线的情况。\n\n您的程序必须评估以下测试套件。对于每个组，在要求的最终输出格式中报告原始最大值和比率。\n\n- 第1组（理想情况，中等尖点和中等Z形振荡）：使用 $N=21, A=0.2, \\alpha=2.0, k_y=2.0$，带平滑（$\\varepsilon=0.05$）和不带平滑（$\\varepsilon=0$）；计算：\n  1. $F_{\\perp,\\text{naive,unsm}}^{\\max}$,\n  2. $F_{\\perp,\\text{adapt,unsm}}^{\\max}$,\n  3. $r_{\\text{adapt}} = F_{\\perp,\\text{naive,unsm}}^{\\max} / F_{\\perp,\\text{adapt,unsm}}^{\\max}$,\n  4. $F_{\\perp,\\text{naive,sm}}^{\\max}$,\n  5. $r_{\\text{sm}} = F_{\\perp,\\text{naive,unsm}}^{\\max} / F_{\\perp,\\text{naive,sm}}^{\\max}$。\n\n- 第2组（边界情况，由于更强的横向刚度导致更尖锐的尖点）：使用 $N=21, A=0.2, \\alpha=1.5, k_y=10.0$，带平滑（$\\varepsilon=0.1$）和不带平滑（$\\varepsilon=0$）；计算：\n  6. $F_{\\perp,\\text{naive,unsm}}^{\\max}$,\n  7. $F_{\\perp,\\text{adapt,unsm}}^{\\max}$,\n  8. $r_{\\text{adapt}}$,\n  9. $F_{\\perp,\\text{naive,sm}}^{\\max}$,\n  10. $r_{\\text{sm}}$。\n\n- 第3组（边缘情况，最小Z形振荡）：使用 $N=21, A=10^{-6}, \\alpha=2.0, k_y=2.0$，不带平滑（$\\varepsilon=0$）；计算：\n  11. $F_{\\perp,\\text{naive,unsm}}^{\\max}$,\n  12. $F_{\\perp,\\text{adapt,unsm}}^{\\max}$,\n  13. $r_{\\text{adapt}}$。\n\n最终输出格式：您的程序应生成一行输出，其中包含13个结果，以逗号分隔的列表形式并用方括号括起来（例如 $[x_1,x_2,\\dots,x_{13}]$）。所有输出必须是实数（浮点数）。此问题不需要单位。角度（如果有）必须以弧度为单位，但此处不需要指定角度。",
            "solution": "所提出的问题是一项有效的计算任务，它基于计算材料科学的原理，特别是关于用于寻找最小能量路径（Minimum Energy Paths, MEPs）的微动弹性带（Nudged Elastic Band, NEB）方法。所有参数、函数和算法都已明确定义，使得该问题成为一个自包含、客观且适定的问题。不存在科学或逻辑上的矛盾。该问题要求为一组指定的测试案例实现一个已定义的算法，这是数值方法验证的标准程序。我现在将提供一个完整的解决方案。\n\n问题的核心是计算由一系列在二维势能面（PES）上离散化一条路径的点（称为“映像点”）所承受的最大垂直力 $F_{\\perp}^{\\max}$。该度量用于量化路径的“扭结”或伪Z形振荡，这是NEB计算中常见的数值伪影。问题要求在不同条件下比较 $F_{\\perp}^{\\max}$：尖锐（“尖点状”）势能面与平滑势能面，以及计算路径切线的“朴素”方法与“自适应”方法。\n\n**1. 势能面（PES）与力**\n\nPES 由 $V_{\\varepsilon}(x,y) = \\sqrt{x^2 + \\varepsilon^2} + \\tfrac{1}{2}k_y y^2$ 给出。参数 $\\varepsilon$ 控制势能沿 $x$ 轴的平滑度。\n- 对于 $\\varepsilon = 0$，它变为 $V_0(x,y) = |x| + \\tfrac{1}{2}k_y y^2$，在 $x=0$ 处有一个不可微的尖点。\n- 对于 $\\varepsilon  0$，尖点被平滑成一个可微函数。\n\n位于位置 $\\mathbf{R}=(x,y)$ 的粒子所受的物理力是势的负梯度，$\\mathbf{F}(\\mathbf{R}) = -\\nabla V_{\\varepsilon}(\\mathbf{R})$。力向量 $\\mathbf{F} = (F_x, F_y)$ 的分量为：\n$F_x(x,y) = -\\frac{\\partial V_{\\varepsilon}}{\\partial x}$ 和 $F_y(x,y) = -\\frac{\\partial V_{\\varepsilon}}{\\partial y}$。\n\n偏导数定义如下：\n- 对于 $\\varepsilon = 0$：\n  $$ \\frac{\\partial V_0}{\\partial x} = \\begin{cases} \\operatorname{sign}(x)  x \\ne 0 \\\\ 0  x = 0 \\end{cases}, \\quad \\frac{\\partial V_0}{\\partial y} = k_y y $$\n- 对于 $\\varepsilon  0$：\n  $$ \\frac{\\partial V_{\\varepsilon}}{\\partial x} = \\frac{x}{\\sqrt{x^2 + \\varepsilon^2}}, \\quad \\frac{\\partial V_{\\varepsilon}}{\\partial y} = k_y y $$\n\n**2. 离散化路径（映像点）**\n\n连续路径被离散化为一系列 $N$ 个映像点 $\\mathbf{R}_i = (x_i, y_i)$，其中 $i=0, \\dots, N-1$。端点 $\\mathbf{R}_0 = (-1,0)$ 和 $\\mathbf{R}_{N-1} = (1,0)$ 是固定的。构建内部映像点以模拟Z形振荡路径，在这种情况下，切线定义的​​选择至关重要。\n坐标由以下公式给出：\n- $x_i = -1 + \\frac{2i}{N-1}$\n- 对于 $i=1, \\dots, N-2$，$y_i = A \\cdot (-1)^i \\cdot \\exp(-\\alpha |x_i|)$，且 $y_0=y_{N-1}=0$。参数 $A$ 和 $\\alpha$ 控制Z形振荡的振幅和衰减。\n\n**3. 切向量定义**\n\n内部映像点 $\\mathbf{R}_i$ 处的单位切向量 $\\boldsymbol{\\tau}_i$ 对力的分解至关重要。需要实现两种方案。\n\n- **朴素中心差分切线**：切线是使用相邻映像点的位置来估计的：\n  $$ \\mathbf{t}_i^{\\text{naive}} = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1} $$\n  然后将此向量归一化以获得单位切线 $\\boldsymbol{\\tau}_i = \\mathbf{t}_i / \\|\\mathbf{t}_i\\|$。虽然简单，但已知此方法会加剧路径中的不稳定性（扭结）。\n\n- **自适应切线（Henkelman-Jónsson 风格）**：这种更复杂的方案根据沿路径的能量景观调整切线方向。设 $E_j = V_{\\varepsilon}(\\mathbf{R}_j)$ 为映像点 $j$ 的能量。切线选择如下：\n  - 如果路径在映像点 $i$ 周围的能量单调增加（即 $E_{i-1}  E_i  E_{i+1}$），则切线指向前方：$\\mathbf{t}_i^{\\text{adapt}} = \\mathbf{R}_{i+1} - \\mathbf{R}_i$。\n  - 如果路径单调递减（即 $E_{i-1}  E_i  E_{i+1}$），则切线指向上坡方向，即向后：$\\mathbf{t}_i^{\\text{adapt}} = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。\n  - 否则（映像点 $i$ 位于路径上的局部能量极值点），切线指向远离能量更近的邻居点。设 $\\Delta E^{+} = E_{i+1} - E_i$ 和 $\\Delta E^{-} = E_i - E_{i-1}$。如果 $|\\Delta E^{+}| \\geq |\\Delta E^{-}|$，则选择沿 $\\mathbf{R}_{i+1} - \\mathbf{R}_i$ 的方向；如果 $|\\Delta E^{-}|  |\\Delta E^{+}|$，则选择沿 $\\mathbf{R}_i - \\mathbf{R}_{i-1}$ 的方向。\n  同样，所选向量 $\\mathbf{t}_i^{\\text{adapt}}$ 被归一化以获得 $\\boldsymbol{\\tau}_i$。\n\n**4. 垂直力与评估度量**\n\nNEB 方法旨在通过将垂直于路径的物理力分量驱动为零来弛豫映像点。映像点 $i$ 处的该垂直力分量通过投影掉平行于切线的分量来计算：\n$$ \\mathbf{F}_{\\perp,i} = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\boldsymbol{\\tau}_i)\\boldsymbol{\\tau}_i $$\n该向量的大小 $\\|\\mathbf{F}_{\\perp,i}\\|$ 表明了映像点在局部偏离理想路径的程度。路径的整体“扭结”程度通过所有内部映像点的这些大小的最大值来衡量：\n$$ F_{\\perp}^{\\max} = \\max_{i=1, \\dots, N-2} \\|\\mathbf{F}_{\\perp,i}\\|_2 $$\n\n**5. 算法实现与测试案例**\n\n程序将为提供的三组测试参数系统地计算 $F_{\\perp}^{\\max}$。对于每组，它将：\n1. 根据指定的 $A$ 和 $\\alpha$ 生成 $N$ 个映像点的集合。\n2. 通过应用相应的势能（未平滑 $\\varepsilon=0$ 或平滑 $\\varepsilon0$）和切线方案（“朴素”或“自适应”）来计算所需的 $F_{\\perp}^{\\max}$ 值。\n3. 对于第1组和第2组，计算减小比率 $r = F_{\\perp,\\text{baseline}}^{\\max} / F_{\\perp,\\text{improved}}^{\\max}$，其中基线是在未平滑势能上使用朴素切线的情况。\n\n最终代码将为势能、力、映像点生成实现辅助函数，以及一个主计算函数，该函数评估所有指定的量，并将输出格式化为单个逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the NEB perpendicular force calculations for all test groups.\n    \"\"\"\n\n    def potential_energy(R, k_y, epsilon):\n        \"\"\"Calculates the potential energy V(x,y) for a given image.\"\"\"\n        x, y = R\n        if epsilon == 0.0:\n            # Unsmoothed cusp potential\n            v_x = np.abs(x)\n        else:\n            # Smoothed cusp potential\n            v_x = np.sqrt(x**2 + epsilon**2)\n        return v_x + 0.5 * k_y * y**2\n\n    def physical_force(R, k_y, epsilon):\n        \"\"\"Calculates the physical force F = -grad(V) on a given image.\"\"\"\n        x, y = R\n        if epsilon == 0.0:\n            # Force from unsmoothed potential. np.sign(0) correctly returns 0.\n            dV_dx = np.sign(x)\n        else:\n            # Force from smoothed potential. Denominator is safe since epsilon  0.\n            dV_dx = x / np.sqrt(x**2 + epsilon**2)\n        \n        dV_dy = k_y * y\n        return np.array([-dV_dx, -dV_dy])\n\n    def generate_images(N, A, alpha):\n        \"\"\"Generates the coordinates of the N images along the zig-zag path.\"\"\"\n        images = np.zeros((N, 2))\n        x_coords = np.linspace(-1.0, 1.0, N)\n        images[:, 0] = x_coords\n\n        # Internal images (i=1 to N-2) have a zig-zag displacement.\n        # Endpoints (i=0, N-1) have y=0 as per initialization.\n        for i in range(1, N - 1):\n            x_i = x_coords[i]\n            images[i, 1] = A * ((-1)**i) * np.exp(-alpha * np.abs(x_i))\n            \n        return images\n\n    def calculate_f_perp_max(images, k_y, epsilon, tangent_scheme):\n        \"\"\"\n        Calculates the maximum perpendicular force component F_perp^max.\n        \"\"\"\n        N = len(images)\n        f_perp_magnitudes = []\n\n        for i in range(1, N - 1):  # Iterate over internal images only\n            R_im1, R_i, R_ip1 = images[i-1], images[i], images[i+1]\n\n            # Step 1: Calculate the tangent vector based on the specified scheme\n            if tangent_scheme == 'naive':\n                tangent_vec = R_ip1 - R_im1\n            elif tangent_scheme == 'adaptive':\n                E_im1 = potential_energy(R_im1, k_y, epsilon)\n                E_i = potential_energy(R_i, k_y, epsilon)\n                E_ip1 = potential_energy(R_ip1, k_y, epsilon)\n                \n                dE_plus = E_ip1 - E_i\n                dE_minus = E_i - E_im1\n\n                if dE_plus > 0 and dE_minus > 0:\n                    tangent_vec = R_ip1 - R_i\n                elif dE_plus  0 and dE_minus  0:\n                    tangent_vec = R_i - R_im1\n                else: \n                    if np.abs(dE_minus) > np.abs(dE_plus):\n                        tangent_vec = R_i - R_im1\n                    else: # Default to forward for tie-break\n                        tangent_vec = R_ip1 - R_i\n            else:\n                raise ValueError(\"Unknown tangent scheme.\")\n\n            # Step 2: Normalize to get the unit tangent\n            norm = np.linalg.norm(tangent_vec)\n            tau_i = tangent_vec / norm if norm > 0 else np.zeros_like(tangent_vec)\n\n            # Step 3: Calculate the physical force\n            F_i = physical_force(R_i, k_y, epsilon)\n\n            # Step 4: Calculate the perpendicular component of the force\n            F_parallel_mag = np.dot(F_i, tau_i)\n            F_perp_i = F_i - F_parallel_mag * tau_i\n            \n            f_perp_magnitudes.append(np.linalg.norm(F_perp_i))\n\n        return max(f_perp_magnitudes) if f_perp_magnitudes else 0.0\n\n    all_results = []\n\n    # --- Group 1: Moderate cusp and zig-zag ---\n    N, A, alpha, k_y, eps_sm = 21, 0.2, 2.0, 2.0, 0.05\n    eps_unsm = 0.0\n    images_g1 = generate_images(N, A, alpha)\n\n    f_naive_unsm_g1 = calculate_f_perp_max(images_g1, k_y, eps_unsm, 'naive')\n    f_adapt_unsm_g1 = calculate_f_perp_max(images_g1, k_y, eps_unsm, 'adaptive')\n    r_adapt_g1 = f_naive_unsm_g1 / f_adapt_unsm_g1\n    f_naive_sm_g1 = calculate_f_perp_max(images_g1, k_y, eps_sm, 'naive')\n    r_sm_g1 = f_naive_unsm_g1 / f_naive_sm_g1\n    all_results.extend([f_naive_unsm_g1, f_adapt_unsm_g1, r_adapt_g1, f_naive_sm_g1, r_sm_g1])\n\n    # --- Group 2: Sharper cusp ---\n    N, A, alpha, k_y, eps_sm = 21, 0.2, 1.5, 10.0, 0.1\n    images_g2 = generate_images(N, A, alpha)\n\n    f_naive_unsm_g2 = calculate_f_perp_max(images_g2, k_y, eps_unsm, 'naive')\n    f_adapt_unsm_g2 = calculate_f_perp_max(images_g2, k_y, eps_unsm, 'adaptive')\n    r_adapt_g2 = f_naive_unsm_g2 / f_adapt_unsm_g2\n    f_naive_sm_g2 = calculate_f_perp_max(images_g2, k_y, eps_sm, 'naive')\n    r_sm_g2 = f_naive_unsm_g2 / f_naive_sm_g2\n    all_results.extend([f_naive_unsm_g2, f_adapt_unsm_g2, r_adapt_g2, f_naive_sm_g2, r_sm_g2])\n\n    # --- Group 3: Minimal zig-zag ---\n    N, A, alpha, k_y = 21, 1e-6, 2.0, 2.0\n    images_g3 = generate_images(N, A, alpha)\n    \n    f_naive_unsm_g3 = calculate_f_perp_max(images_g3, k_y, eps_unsm, 'naive')\n    f_adapt_unsm_g3 = calculate_f_perp_max(images_g3, k_y, eps_unsm, 'adaptive')\n    r_adapt_g3 = f_naive_unsm_g3 / f_adapt_unsm_g3 if f_adapt_unsm_g3 > 0 else float('inf')\n    all_results.extend([f_naive_unsm_g3, f_adapt_unsm_g3, r_adapt_g3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}