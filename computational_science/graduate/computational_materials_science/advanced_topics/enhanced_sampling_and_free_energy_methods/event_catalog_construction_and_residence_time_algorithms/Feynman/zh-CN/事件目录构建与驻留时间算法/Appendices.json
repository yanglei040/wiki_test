{
    "hands_on_practices": [
        {
            "introduction": "对于大型体系而言，动力学蒙特卡洛（KMC）模拟的效率至关重要。本练习的核心是在格点模型上构建KMC模拟的核心引擎，其中相互作用是局域的。你将实现一种利用这种局域性在事件发生后以恒定时间复杂度更新事件目录的算法，这是构建高性能KMC代码的一项基本技能 。",
            "id": "3450027",
            "problem": "考虑一个由 $N$ 个格点组成的一维周期性晶格（一个环），格点由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引，每个格点上有二元占据变量 $s_i \\in \\{0,1\\}$。相互作用是局域的，范围为 $r=1$，因此每个格点的配位数为 $z=2$（左、右邻居）。该系统演化为一个连续时间马尔可夫跳跃过程，其中单格点事件会将 $s_i$ 在 $0$ 和 $1$ 之间翻转。在格点 $i$ 处发生翻转的瞬时速率仅通过其已占据邻居的数量 $n_i \\in \\{0,1,2\\}$ 依赖于局域环境。定义吸附为事件 $0 \\rightarrow 1$，解吸为事件 $1 \\rightarrow 0$。假设过渡态速率为 Arrhenius 型：\n- 对于吸附， $k_{\\mathrm{ads}}(n) = \\nu \\exp\\!\\left(-\\dfrac{E_{\\mathrm{ads}} - n \\,\\epsilon}{k_{\\mathrm{B}} T}\\right)$。\n- 对于解吸， $k_{\\mathrm{des}}(n) = \\nu \\exp\\!\\left(-\\dfrac{E_{\\mathrm{des}} + n \\,\\epsilon}{k_{\\mathrm{B}} T}\\right)$。\n\n此处 $T$ 是绝对温度（单位：开尔文），$k_{\\mathrm{B}}$ 是玻尔兹曼常数（单位：电子伏特每开尔文），$\\nu$ 是尝试频率（单位：每秒），$E_{\\mathrm{ads}}$ 和 $E_{\\mathrm{des}}$ 是基础活化能（单位：电子伏特），$\\epsilon$ 是最近邻相互作用能（单位：电子伏特）。总速率为 $R = \\sum_{i} r_i$，其中如果 $s_i=0$，则 $r_i = k_{\\mathrm{ads}}(n_i)$；如果 $s_i=1$，则 $r_i = k_{\\mathrm{des}}(n_i)$。\n\n驻留时间算法（也称为 $n$-fold way）按如下方式选择并执行事件：\n- 到下一个事件的等待时间 $\\Delta t$ 是一个参数为 $R$ 的指数随机变量，因此对于一个均匀分布的随机数 $u \\in (0,1)$，有 $\\Delta t = -\\ln(u)/R$。\n- 下一个事件从所有可能事件中被选择，其被选择的概率与它的速率成正比。\n\n事件目录的构建是根据格点的局域环境将其分组为不同的类别。此处，定义由对 $(s,n)$ 索引的 $K=2(z+1)=6$ 个类别，其中 $s \\in \\{0,1\\}$ 且 $n \\in \\{0,1,2\\}$。每个类别 $k$ 都有一个仅依赖于 $(s,n)$ 的单位格点速率 $r_k$ 和一个等于当前处于该局域构型中的格点数量的布居数 $N_k$。总速率可以写为 $R=\\sum_{k=0}^{K-1} N_k r_k$。在选择事件时，首先按正比于 $N_k r_k$ 的方式选择一个类别 $k$，然后在该类别中从 $N_k$ 个格点中均匀选择一个。在格点 $i$ 处执行一次单格点翻转后，只有格点 $i$ 本身及其 $z=2$ 个最近邻的类别归属可能发生改变，因为速率仅依赖于范围 $r=1$ 内的局域构型。\n\n任务。仅使用具有局域相互作用的连续时间马尔可夫过程的基本定义和上述 Arrhenius 速率，解释为什么单个翻转事件仅影响一个大小有界且与 $N$ 无关的格点邻域。然后，设计一种算法来维护事件目录，并支持在事件发生后更新时，对每个受影响的格点实现 $O(1)$ 的均摊时间。您的算法应：\n- 为每个类别 $k$ 维护当前的布居数 $N_k$ 和一个成员（格点索引）的动态列表，以便在一个类别内进行均匀选择。\n- 为每个格点 $i$ 维护其当前的类别索引，以便通过与类别列表中的最后一个元素交换，实现常数时间的移除和插入，从而使每个格点的更新操作达到 $O(1)$。\n- 通过遍历 $K$ 个类别来选择下一个类别。由于 $K$ 仅依赖于 $z$ 并且对于固定的局域相互作用范围是一个常数，因此该步骤必须是每个事件 $O(1)$ 的时间复杂度。\n- 当类别归属发生变化时，增量地更新总速率 $R$。\n\n实现。使用上述的事件目录维护方法，为以下固定的参数值实现驻留时间算法：\n- 温度 $T = 500$ 开尔文。\n- 玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ 电子伏特每开尔文。\n- 尝试频率 $\\nu = 10^{13}$ 每秒。\n- 能量 $E_{\\mathrm{ads}} = 0.35$ 电子伏特, $E_{\\mathrm{des}} = 0.45$ 电子伏特, $\\epsilon = 0.05$ 电子伏特。\n\n使用周期性边界条件。对于每个模拟步骤，使用三个在 $(0,1)$ 区间内的独立均匀随机数：一个用于类别选择，一个用于在所选类别内选择格点，一个用于驻留时间。下面提供了一个包含三个测试用例的测试套件。对于每个用例，模拟固定数量的事件并记录总模拟时间。此外，在每一步通过在每个事件后为所有格点重新计算类别标签来验证局域性属性，并检查类别发生变化的格点集合是否包含在由被翻转的格点及其两个最近邻组成的集合之内。\n\n测试套件。对于每个用例，初始构型是一个长度为 $N$ 的数字字符串，编码为 $s_0 s_1 \\dots s_{N-1}$，要模拟的事件数为 $M$，随机数以一个长度为 $3M$ 的扁平列表形式给出，顺序为每个步骤的 $(u_{\\mathrm{class}}, u_{\\mathrm{site}}, u_{\\mathrm{time}})$。\n\n- 用例 1：$N=10$，初始构型 $0101101001$，$M=8$，随机数\n  $\\{0.13, 0.77, 0.42, 0.91, 0.05, 0.33, 0.68, 0.27, 0.88, 0.12, 0.56, 0.74, 0.21, 0.93, 0.49, 0.36, 0.59, 0.18, 0.81, 0.07, 0.66, 0.25, 0.97, 0.44\\}$。\n\n- 用例 2：$N=6$，初始构型 $000000$，$M=6$，随机数\n  $\\{0.11, 0.62, 0.58, 0.47, 0.29, 0.83, 0.14, 0.71, 0.39, 0.52, 0.26, 0.64, 0.19, 0.86, 0.41, 0.73, 0.32, 0.57\\}$。\n\n- 用例 3：$N=4$，初始构型 $1111$，$M=5$，随机数\n  $\\{0.24, 0.68, 0.35, 0.79, 0.22, 0.61, 0.48, 0.84, 0.17, 0.69, 0.53, 0.91, 0.28, 0.75, 0.46\\}$。\n\n输出规范。您的程序必须：\n- 为三个用例实现算法并完全按照指定的方式执行模拟。\n- 对于每个用例，按顺序输出两个值：$M$ 次事件后的总模拟时间（以纳秒表示，即将秒数乘以 $10^{9}$），四舍五入到三位小数；以及一个布尔值，指示局域性验证是否在每一步都通过。\n- 生成一行输出，其中包含按用例 1、2、3 顺序排列的结果，形式为用方括号括起来的逗号分隔列表。最终输出格式必须完全是：$[t_1,\\mathrm{local}_1,t_2,\\mathrm{local}_2,t_3,\\mathrm{local}_3]$，其中每个 $t_j$ 是一个以纳秒为单位、四舍五入到三位小数的十进制数，每个 $\\mathrm{local}_j$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "该问题是有效的。它在计算材料科学领域提出了一个清晰、有科学依据且良构的任务，具体是使用驻留时间算法和高效事件目录实现动力学蒙特卡洛（KMC）模拟。\n\n### 局域性的理论论证\n\n单格点翻转事件仅影响一个有界大小的邻域这一断言，是模型中定义的相互作用具有局域性的直接后果。系统的演化由一组跃迁速率决定，其中特定格点 $i$ 上的翻转速率仅依赖于该格点的状态及其直接环境。\n\n设系统的状态为所有占据变量的构型，$S = \\{s_0, s_1, \\dots, s_{N-1}\\}$。格点 $i$ 上的一个潜在事件（翻转）的速率记为 $r_i$，并且是局域构型的函数。具体来说，问题定义了格点 $i$ 上的速率依赖于其自身状态 $s_i$ 和已占据最近邻的数量 $n_i$。对于相互作用范围 $r=1$ 的一维晶格，格点 $i$ 的邻居位于索引 $(i-1) \\pmod N$ 和 $(i+1) \\pmod N$ 处。因此，已占据邻居的数量为 $n_i = s_{(i-1) \\pmod N} + s_{(i+1) \\pmod N}$。所以速率 $r_i$ 是一个函数 $f(s_i, s_{(i-1) \\pmod N}, s_{(i+1) \\pmod N})$。\n\n事件目录根据格点的局域构型将其分组到不同类别。格点 $i$ 的类别由对 $(s_i, n_i)$ 定义。因此，格点 $i$ 的类别是由集合 $\\mathcal{N}_i = \\{i, (i-1) \\pmod N, (i+1) \\pmod N\\}$ 中格点的状态决定的。\n\n现在，考虑一个事件：在选定的格点 $j$ 处发生一次翻转。这意味着状态变量 $s_j$ 改变，$s_j \\rightarrow 1-s_j$。我们来考察由于这次单次翻转，哪些格点的类别会发生变化。一个格点 $i$ 的类别发生变化，当且仅当其状态 $s_i$ 或其邻居数 $n_i$ 发生变化。\n\n1.  **格点 $j$ (被翻转的格点)：** 根据定义，其状态 $s_j$ 发生改变。其邻居数 $n_j = s_{(j-1) \\pmod N} + s_{(j+1) \\pmod N}$ 依赖于其邻居的状态，而邻居的状态没有改变。因此，对 $(s_j, n_j)$ 发生改变，格点 $j$ 必须改变其类别。\n\n2.  **$j$ 的邻居，格点 $k=(j-1) \\pmod N$：** 其状态 $s_k$ 保持不变。其邻居数为 $n_k = s_{(k-1) \\pmod N} + s_{(k+1) \\pmod N} = s_{(j-2) \\pmod N} + s_j$。由于 $s_j$ 已改变，$n_k$ 也可能改变。因此，格点 $k=(j-1) \\pmod N$ 的类别可能会改变。\n\n3.  **$j$ 的邻居，格点 $l=(j+1) \\pmod N$：** 其状态 $s_l$ 保持不变。其邻居数为 $n_l = s_{(l-1) \\pmod N} + s_{(l+1) \\pmod N} = s_j + s_{(j+2) \\pmod N}$。由于 $s_j$ 已改变，$n_l$ 也可能改变。因此，格点 $l=(j+1) \\pmod N$ 的类别可能会改变。\n\n4.  **任何其他格点 $m \\notin \\{j, (j-1)\\pmod N, (j+1)\\pmod N\\}$：** 其状态 $s_m$ 不变。其邻居数为 $n_m = s_{(m-1) \\pmod N} + s_{(m+1) \\pmod N}$。由于格点 $m$ 及其邻居都与格点 $j$ 不同，因此状态 $s_m$、$s_{(m-1) \\pmod N}$ 和 $s_{(m+1) \\pmod N}$ 均不受 $j$ 处翻转的影响。因此，$s_m$ 和 $n_m$ 都不变，格点 $m$ 的类别保持不变。\n\n总而言之，唯一可能改变类别归属的格点是被翻转的格点本身（$j$）及其最近邻（$(j-1)\\pmod N$ 和 $(j+1)\\pmod N$）。这个可能受影响的格点集合的大小为 $1+z = 1+2 = 3$，其中 $z=2$ 是配位数。这个大小是一个小的常数，与总格点数 $N$ 无关。对于具有短程相互作用的系统，这个局域性原理是 KMC 算法效率的基础。\n\n### 用于 $O(1)$ 更新的算法设计\n\n为了对一个具有恒定类别数 $K$ 的系统实现每个事件 $O(1)$ 的均摊时间复杂度，我们必须设计能够在常数时间内支持事件选择和状态更新的数据结构。\n\n**1. 数据结构**\n\n算法的核心在于维护一个所有可能事件的实时目录。\n- **`state[i]`**：一个大小为 $N$ 的数组，存储每个格点 $i$ 的二元占据变量 $s_i$。\n- **`class_rates[k]`**：一个大小为 $K=6$ 的数组，存储每个类别 $k$ 预先计算的单位格点速率 $r_k$。类别索引 $k$ 可以通过 $k = s \\cdot (z+1) + n = 3s+n$ 从 $(s,n)$ 映射得到。这些速率在整个模拟过程中是恒定的。\n- **`class_pops[k]`**：一个大小为 $K$ 的数组，存储每个类别当前的布居数 $N_k$。\n- **`total_rate`**：一个标量变量，存储总速率 $R = \\sum_{k=0}^{K-1} N_k r_k$。\n- **`class_members[k]`**：一个列表（或动态数组）的数组，其中 `class_members[k]` 包含当前属于类别 $k$ 的所有格点的索引。这允许在一个类别内对格点进行均匀随机选择。\n- **`site_to_class[i]`**：一个大小为 $N$ 的数组，其中 `site_to_class[i]` 存储格点 $i$ 的当前类别索引 $k$。\n- **`site_to_pos_in_class[i]`**：一个大小为 $N$ 的数组。这是实现 $O(1)$ 更新的关键结构。`site_to_pos_in_class[i]` 存储格点 $i$ 在列表 `class_members[site_to_class[i]]` 中的索引（位置）。即 `class_members[site_to_class[i]][site_to_pos_in_class[i]] == i`。\n\n**2. 初始化**\n\n1.  根据给定的初始构型初始化 `state` 数组。\n2.  使用给定的 Arrhenius 表达式计算 $K=6$ 个单位格点速率 $r_k$，并将其存储在 `class_rates` 中。\n3.  将 `class_pops` 初始化为零，将 `class_members` 初始化为 $K$ 个空列表。\n4.  遍历每个格点 $i \\in \\{0, \\dots, N-1\\}$：\n    a. 通过计算 $n_i$ 并使用 $k=3s_i+n_i$ 来确定其初始类别 $k$。\n    b. 将该格点添加到其类别中：将 $i$ 附加到 `class_members[k]`，设置 `site_to_class[i]=k`，将 `site_to_pos_in_class[i]` 设置为 `class_members[k]` 中新的最后一个索引，并增加 `class_pops[k]`。\n5.  计算初始 `total_rate` $R = \\sum_{k} \\text{class\\_pops}[k] \\cdot \\text{class\\_rates}[k]$。\n\n**3. 模拟步骤（单个事件）**\n\n1.  **事件选择**：\n    a. 生成一个均匀随机数 $u_{\\mathrm{class}} \\in (0,1)$。\n    b. 以与该类别总速率 $N_k r_k$ 成正比的概率选择一个类别 $k_{sel}$。这可以通过找到满足 $\\sum_{j=0}^{k_{sel}} N_j r_j > u_{\\mathrm{class}} \\cdot R$ 的最小 $k_{sel}$ 来完成。由于 $K$ 是一个小常数，这种线性扫描需要 $O(K) = O(1)$ 的时间。\n    c. 生成一个均匀随机数 $u_{\\mathrm{site}} \\in (0,1)$。\n    d. 通过从列表 `class_members[k_{sel}]` 中选择一个随机元素来选择要翻转的格点 $i_{flip}$。索引为 $\\lfloor u_{\\mathrm{site}} \\cdot N_{k_{sel}} \\rfloor$。这是一个 $O(1)$ 操作。\n\n2.  **时间推进**：\n    a. 生成一个均匀随机数 $u_{\\mathrm{time}} \\in (0,1)$。\n    b. 将模拟时间推进 $\\Delta t = -\\ln(u_{\\mathrm{time}}) / R$。\n\n3.  **状态和目录更新**：\n    a. 翻转所选格点的状态：$s_{i_{flip}} \\rightarrow 1 - s_{i_{flip}}$。\n    b. 识别受影响的格点集合：$\\mathcal{A} = \\{ (i_{flip}-1)\\pmod N, i_{flip}, (i_{flip}+1)\\pmod N \\}$。\n    c. 对于每个格点 $j \\in \\mathcal{A}$：\n        i.  获取其旧类别 $k_{old} = \\text{site\\_to\\_class}[j]$。\n        ii. 重新计算其局域环境以找到其新类别 $k_{new}$。\n        iii. 如果 $k_{new} \\neq k_{old}$：\n            - **更新总速率**：$R \\leftarrow R - r_{k_{old}} + r_{k_{new}}$。\n            - **从旧类别中移除**：这必须是一个 $O(1)$ 操作。\n                - 获取该格点在其类别列表中的当前位置：$p_j = \\text{site\\_to\\_pos\\_in\\_class}[j]$。\n                - 设 $i_{last}$ 为 `class_members[k_{old}]` 中的最后一个格点。\n                - 将 $i_{last}$ 移动到位置 $p_j$：`class_members[k_{old}][p_j] = i_{last}`。\n                - 更新被移动格点的位置：`site_to_pos_in_class[i_{last}] = p_j`。\n                - 从 `class_members[k_{old}]` 中移除最后一个元素。\n                - 递减 `class_pops[k_{old}]`。\n            - **添加到新类别**：这是一个 $O(1)$ 操作。\n                - 将 $j$ 附加到 `class_members[k_{new}]`。\n                - 更新 `site_to_class[j] = k_{new}`。\n                - 将 `site_to_pos_in_class[j]` 更新为新的最后一个索引。\n                - 递增 `class_pops[k_{new}]`。\n\n由于受影响集合 $\\mathcal{A}$ 的大小是常数（$3$），并且由于 `site_to_pos_in_class` 提供的直接寻址，每个格点的更新耗时 $O(1)$，因此每个事件的总更新时间为 $O(1)$。所以，整个模拟步骤的时间复杂度是 $O(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    class KMCSimulator:\n        \"\"\"\n        Implements the residence-time algorithm with an efficient event catalog.\n        \"\"\"\n        def __init__(self, N, initial_config_str, params):\n            self.N = N\n            self.state = np.array([int(c) for c in initial_config_str], dtype=np.int8)\n            self.params = params\n            \n            # Constants\n            self.K = 6  # Number of classes\n            self.z = 2  # Coordination number\n            \n            # Data structures for catalog\n            self.class_rates = np.zeros(self.K, dtype=np.float64)\n            self.class_pops = np.zeros(self.K, dtype=np.int32)\n            self.class_members = [[] for _ in range(self.K)]\n            self.site_to_class = np.full(self.N, -1, dtype=np.int32)\n            self.site_to_pos_in_class = np.full(self.N, -1, dtype=np.int32)\n            self.total_rate = 0.0\n\n            self._precompute_rates()\n            self._initialize_catalog()\n\n        def _precompute_rates(self):\n            nu = self.params['nu']\n            E_ads = self.params['E_ads']\n            E_des = self.params['E_des']\n            epsilon = self.params['epsilon']\n            kBT = self.params['k_B'] * self.params['T']\n            \n            # Classes s=0 (adsorption)\n            for n in range(3):\n                k = 3 * 0 + n\n                E_A = E_ads - n * epsilon\n                self.class_rates[k] = nu * np.exp(-E_A / kBT)\n            \n            # Classes s=1 (desorption)\n            for n in range(3):\n                k = 3 * 1 + n\n                E_A = E_des + n * epsilon\n                self.class_rates[k] = nu * np.exp(-E_A / kBT)\n\n        def _get_class_of_site(self, i):\n            s_i = self.state[i]\n            n_i = self.state[(i - 1) % self.N] + self.state[(i + 1) % self.N]\n            return 3 * s_i + n_i\n\n        def _add_site_to_class(self, site_idx, class_idx):\n            self.class_members[class_idx].append(site_idx)\n            pos = len(self.class_members[class_idx]) - 1\n            self.site_to_class[site_idx] = class_idx\n            self.site_to_pos_in_class[site_idx] = pos\n            self.class_pops[class_idx] += 1\n        \n        def _remove_site_from_class(self, site_idx, class_idx):\n            pos = self.site_to_pos_in_class[site_idx]\n            last_site_in_class = self.class_members[class_idx][-1]\n            \n            # Swap with last element for O(1) removal\n            self.class_members[class_idx][pos] = last_site_in_class\n            self.site_to_pos_in_class[last_site_in_class] = pos\n            \n            self.class_members[class_idx].pop()\n            self.class_pops[class_idx] -= 1\n\n        def _initialize_catalog(self):\n            for i in range(self.N):\n                k = self._get_class_of_site(i)\n                self._add_site_to_class(i, k)\n            \n            self.total_rate = np.dot(self.class_pops, self.class_rates)\n\n        def _update_site_and_neighbors(self, site_idx):\n            affected_sites = {(site_idx - 1) % self.N, site_idx, (site_idx + 1) % self.N}\n            \n            for i in affected_sites:\n                old_class = self.site_to_class[i]\n                new_class = self._get_class_of_site(i)\n\n                if old_class != new_class:\n                    # Update total rate\n                    self.total_rate -= self.class_rates[old_class]\n                    self.total_rate += self.class_rates[new_class]\n                    \n                    # Move site between classes\n                    self._remove_site_from_class(i, old_class)\n                    self._add_site_to_class(i, new_class)\n\n        def run_simulation(self, M, random_numbers):\n            total_time = 0.0\n            locality_verification_passed = True\n            rng_iterator = iter(random_numbers)\n\n            for step in range(M):\n                if self.total_rate == 0.0:\n                    break\n                \n                # --- Locality Verification (pre-flip) ---\n                if locality_verification_passed:\n                    old_classes = np.array([self._get_class_of_site(i) for i in range(self.N)])\n                \n                # --- Step 1: Select class ---\n                u_class = next(rng_iterator)\n                rand_val = u_class * self.total_rate\n                \n                partial_rate_sum = 0.0\n                selected_class = -1\n                for k in range(self.K):\n                    partial_rate_sum += self.class_pops[k] * self.class_rates[k]\n                    if rand_val = partial_rate_sum:\n                        selected_class = k\n                        break\n                \n                # --- Step 2: Select site ---\n                u_site = next(rng_iterator)\n                num_sites_in_class = self.class_pops[selected_class]\n                selected_pos = int(u_site * num_sites_in_class)\n                site_to_flip = self.class_members[selected_class][selected_pos]\n                \n                # --- Step 3: Advance time ---\n                u_time = next(rng_iterator)\n                dt = -np.log(u_time) / self.total_rate\n                total_time += dt\n\n                # --- Step 4: Execute event and update ---\n                self.state[site_to_flip] = 1 - self.state[site_to_flip]\n                self._update_site_and_neighbors(site_to_flip)\n\n                # --- Locality Verification (post-flip) ---\n                if locality_verification_passed:\n                    new_classes = np.array([self._get_class_of_site(i) for i in range(self.N)])\n                    changed_sites = {i for i, (old, new) in enumerate(zip(old_classes, new_classes)) if old != new}\n                    expected_affected = {(site_to_flip - 1) % self.N, site_to_flip, (site_to_flip + 1) % self.N}\n                    if not changed_sites.issubset(expected_affected):\n                        locality_verification_passed = False\n\n            return total_time, locality_verification_passed\n\n    # Fixed parameters for all simulations\n    params = {\n        'T': 500.0,\n        'k_B': 8.617333262145e-5,\n        'nu': 1e13,\n        'E_ads': 0.35,\n        'E_des': 0.45,\n        'epsilon': 0.05,\n    }\n\n    # Test suite\n    test_cases = [\n        {\n            \"N\": 10,\n            \"initial_config\": \"0101101001\",\n            \"M\": 8,\n            \"random_numbers\": [0.13, 0.77, 0.42, 0.91, 0.05, 0.33, 0.68, 0.27, 0.88, 0.12, 0.56, 0.74, 0.21, 0.93, 0.49, 0.36, 0.59, 0.18, 0.81, 0.07, 0.66, 0.25, 0.97, 0.44]\n        },\n        {\n            \"N\": 6,\n            \"initial_config\": \"000000\",\n            \"M\": 6,\n            \"random_numbers\": [0.11, 0.62, 0.58, 0.47, 0.29, 0.83, 0.14, 0.71, 0.39, 0.52, 0.26, 0.64, 0.19, 0.86, 0.41, 0.73, 0.32, 0.57]\n        },\n        {\n            \"N\": 4,\n            \"initial_config\": \"1111\",\n            \"M\": 5,\n            \"random_numbers\": [0.24, 0.68, 0.35, 0.79, 0.22, 0.61, 0.48, 0.84, 0.17, 0.69, 0.53, 0.91, 0.28, 0.75, 0.46]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sim = KMCSimulator(case[\"N\"], case[\"initial_config\"], params)\n        total_time_s, locality_ok = sim.run_simulation(case[\"M\"], case[\"random_numbers\"])\n        total_time_ns = total_time_s * 1e9\n        results.append((total_time_ns, locality_ok))\n    \n    # Format and print the final output string\n    output_parts = []\n    for t, loc in results:\n        output_parts.append(f\"{t:.3f}\")\n        output_parts.append(str(loc))\n        \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模拟本质上是在有限体系中进行的，但我们的目标常常是理解无限的块体材料。本练习直面有限尺寸效应的挑战，即边界会扰动局域事件的速率。你将推导这种偏差典型的 $1/L$ 标度关系，并实现一种修正方案，这是连接有限模拟晶胞和宏观现实的关键一步 。",
            "id": "3449946",
            "problem": "考虑一个长度为 $L$ 的一维板坯，用于为计算材料科学中的动力学蒙特卡洛（KMC，定义为 Kinetic Monte Carlo）模拟构建事件目录。每种基本事件类型 $i$ 由于边界效应而具有一个与位置相关的局域倾向性 $r_i(x)$。事件目录使用有限尺寸测量来估计事件速率，这会对那些激活环境在边界附近受到扰动的事件引入偏差。设事件 $i$ 的边界层宽度为 $\\ell_i$（其中 $\\ell_i \\ll L$），并假设局域倾向性在内部区域是空间均匀的，而在边界层内则有所改变。将事件 $i$ 的有限尺寸测量速率 $k_i(L)$ 定义为 $r_i(x)$ 在整个板坯上的空间平均值：\n$$\nk_i(L) = \\frac{1}{L} \\int_0^L r_i(x)\\, dx.\n$$\n假设一个带有小的曲率修正的双区域模型：\n- 在内部区域 $x \\in [\\ell_i, L - \\ell_i]$，局域倾向性等于其体相值 $k_i(\\infty)$，该值与 $L$ 无关。\n- 在边界层 $x \\in [0, \\ell_i] \\cup [L - \\ell_i, L]$，局域倾向性等于 $k_i^{\\text{edge}}$。\n- 由于目录构建假象，有限尺寸测量包含一个弱二阶修正 $b_i/L^2$。\n\n在这些假设下，事件 $i$ 的有限尺寸速率被建模为\n$$\nk_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2},\n$$\n其中 $\\ell_i  L/2$ 以确保内部区域存在。你的任务是：\n1. 从上述定义和模型出发，推导受边界影响事件的主导阶有限尺寸偏差标度关系：\n$$\n\\left|k_i(L) - k_i(\\infty)\\right| \\sim \\frac{c_i}{L},\n$$\n并用 $\\ell_i$、$k_i(\\infty)$ 和 $k_i^{\\text{edge}}$ 来表示 $c_i$。\n2. 为驻留时间算法提出一个能够恢复体相动力学的修正变换，并对其进行论证。驻留时间算法按如下方式对等待时间 $\\Delta t$ 进行采样：\n$$\n\\Delta t = -\\frac{\\ln u}{\\sum_j k_j(L)},\n$$\n其中 $u \\in (0,1)$ 是一个均匀随机数，求和遍及目录中的所有事件类型 $j$。提供一个修正后的表达式，用一个与体相一致的速率和来替换 $\\sum_j k_j(L)$，并且仅使用从有限尺寸模型中可获取的量（即 $k_j(L)$、$k_j^{\\text{edge}}$、$\\ell_j$ 和 $b_j$），其约束条件是 $k_j(\\infty)$ 无法直接测量，而必须从该模型中估计。修正后的表达式必须具有如下形式\n$$\n\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)},\n$$\n并且必须能够根据给定参数进行显式计算。\n\n实现一个程序，对每个指定的测试用例，计算：\n- 对于用例中的所有事件 $i$，计算标度化的有限尺寸偏差向量 $\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i$。\n- 未修正的驻留时间 $\\Delta t$（以秒为单位）。\n- 使用你提出的修正方法计算得到的修正后的驻留时间 $\\Delta t_{\\text{corr}}$（以秒为单位）。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个形如下式的嵌套列表：\n$$\n\\left[\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i,\\ \\Delta t,\\ \\Delta t_{\\text{corr}}\\right].\n$$\n\n使用以下测试套件（所有速率单位为 $\\text{s}^{-1}$，长度单位为任意单位且在各参数间保持一致，时间必须表示为不带单位符号的普通浮点数）：\n\n- 测试用例 1 (一般正常路径):\n  - $L = 100$, $u =  \\exp(-1)$,\n  - 事件 $i = 1,2,3$ 及其参数:\n    - $k_1(\\infty) = 1.0$, $k_1^{\\text{edge}} = 0.8$, $\\ell_1 = 2.0$, $b_1 = 0.0$,\n    - $k_2(\\infty) = 0.5$, $k_2^{\\text{edge}} = 0.6$, $\\ell_2 = 1.0$, $b_2 = 0.0$,\n    - $k_3(\\infty) = 2.0$, $k_3^{\\text{edge}} = 1.7$, $\\ell_3 = 3.0$, $b_3 = 0.0$.\n\n- 测试用例 2 (强边界影响，小系统):\n  - $L = 10$, $u = 0.5$,\n  - 事件 $i = 1,2$ 及其参数:\n    - $k_1(\\infty) = 3.0$, $k_1^{\\text{edge}} = 2.0$, $\\ell_1 = 2.0$, $b_1 = 0.1$,\n    - $k_2(\\infty) = 1.5$, $k_2^{\\text{edge}} = 2.5$, $\\ell_2 = 3.0$, $b_2 = -0.2$.\n\n- 测试用例 3 (近体相极限，非常大的系统):\n  - $L = 10000$, $u = 0.9$,\n  - 事件 $i = 1,2$ 及其参数:\n    - $k_1(\\infty) = 0.1$, $k_1^{\\text{edge}} = 0.1$, $\\ell_1 = 1.0$, $b_1 = 10^{-4}$,\n    - $k_2(\\infty) = 10.0$, $k_2^{\\text{edge}} = 9.5$, $\\ell_2 = 5.0$, $b_2 = -5\\times 10^{-4}$.\n\n对每个测试用例：\n- 使用指定的模型计算 $k_i(L)$。\n- 计算 $c_i$ 和向量 $\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i$。\n- 使用 $\\sum_j k_j(L)$ 计算 $\\Delta t$。\n- 通过对 $k_j(\\infty)$ 进行代数消元，从模型中计算 $\\widehat{k}_j(\\infty)$：\n$$\n\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}},\n$$\n然后使用 $\\sum_j \\widehat{k}_j(\\infty)$ 计算 $\\Delta t_{\\text{corr}}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个嵌套列表，每个嵌套列表包含：\n- 一个浮点数列表，表示按事件顺序排列的标度化偏差，\n- 未修正的 $\\Delta t$（以秒为单位的浮点数），\n- 修正后的 $\\Delta t_{\\text{corr}}$（以秒为单位的浮点数）。\n\n例如，输出应如下所示\n$[\\,[\\,[s_{1}, s_{2}, \\dots], \\Delta t_1, \\Delta t_{\\text{corr},1}], \\,[\\,[\\dots], \\Delta t_2, \\Delta t_{\\text{corr},2}], \\,[\\,[\\dots], \\Delta t_3, \\Delta t_{\\text{corr},3}]\\,]$,\n其中每个 $s_i$ 是对应事件的 $L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|$。最终打印的数字必须是不带单位的普通浮点数，并按规定汇总到一行中。",
            "solution": "在尝试解答之前，对问题陈述进行有效性评估。\n\n### 步骤 1：提取已知条件\n- **板坯几何形状**：长度为 $L$ 的一维板坯。\n- **事件类型 $i$**：由与位置相关的局域倾向性 $r_i(x)$ 表征。\n- **边界层宽度**：$\\ell_i$，其中 $\\ell_i \\ll L$ 且具体为 $\\ell_i  L/2$。\n- **有限尺寸测量速率 $k_i(L)$**：\n$$k_i(L) = \\frac{1}{L} \\int_0^L r_i(x)\\, dx.$$\n- **双区域倾向性模型**：\n  - 内部 ($x \\in [\\ell_i, L - \\ell_i]$)：$r_i(x) = k_i(\\infty)$ (体相速率)。\n  - 边界层 ($x \\in [0, \\ell_i] \\cup [L - \\ell_i, L]$)：$r_i(x) = k_i^{\\text{edge}}$ (边缘速率)。\n- **有限尺寸速率 $k_i(L)$ 的模型**：\n$$k_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}.$$\n- **任务 1**：推导主导阶有限尺寸偏差标度关系 $|k_i(L) - k_i(\\infty)| \\sim \\frac{c_i}{L}$ 并确定 $c_i$。\n- **任务 2**：为驻留时间算法提出一个修正变换。\n- **驻留时间算法 (未修正)**：\n$$\\Delta t = -\\frac{\\ln u}{\\sum_j k_j(L)},$$\n其中 $u \\in (0,1)$ 是一个均匀随机数。\n- **修正后的驻留时间形式**：\n$$\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)}.$$\n- **体相速率的估计量**：\n$$\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}}.$$\n- **测试用例**：提供了三组具体的参数（$L$、$u$ 和事件数据 $\\{k_i(\\infty), k_i^{\\text{edge}}, \\ell_i, b_i\\}$）用于实现。\n- **输出要求**：对每个测试用例，计算并输出一个嵌套列表，其中包含：\n  1. 一个标度化的有限尺寸偏差向量，$[L \\cdot |k_i(L) - k_i(\\infty)|]_i$。\n  2. 未修正的驻留时间 $\\Delta t$。\n  3. 修正后的驻留时间 $\\Delta t_{\\text{corr}}$。\n最终输出必须是包含这些嵌套列表的单行列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学上成立**：该问题根植于计算材料科学领域的标准实践和已知挑战，特别是动力学蒙特卡洛（KMC）模拟。有限尺寸效应、边界扰动速率及其 $1/L$ 标度关系是该领域的一个基本课题。驻留时间算法是 KMC 中推进时间的标准方法。所提供的模型是针对此类系统的成熟的一阶近似。\n- **适定性**：问题定义清晰。它要求基于明确的公式和参数进行特定的推导和计算实现。推导过程是直接的代数操作。计算任务在测试用例中提供了所有必要的数据，并且明确规定了预期的输出格式。所有测试用例均满足约束条件 $\\ell_i  L/2$，确保了模型的物理诠释成立。\n- **客观性**：问题以精确、正式和客观的语言陈述，没有歧义或主观内容。\n- **其他缺陷**：该问题没有表现出任何列举的缺陷。它在科学上是合理的、可形式化的、完整的且计算上是可行的。在所提供模型的背景下，解是唯一且有意义的。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供解答。\n\n### 解答\n按照要求，解答分为两部分：理论推导，以及对修正算法的论证。\n\n**第 1 部分：有限尺寸偏差标度关系的推导**\n\n事件类型 $i$ 的有限尺寸偏差是有限尺寸测量速率 $k_i(L)$ 与真实体相速率 $k_i(\\infty)$ 之间的差值。我们从给定的 $k_i(L)$ 模型开始：\n$$k_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n为了求得偏差，我们从等式两边减去 $k_i(\\infty)$：\n$$k_i(L) - k_i(\\infty) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) - k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n展开右侧的第一项得到：\n$$k_i(L) - k_i(\\infty) = k_i(\\infty) - \\frac{2\\ell_i}{L} k_i(\\infty) - k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n$k_i(\\infty)$ 项相互抵消，剩下：\n$$k_i(L) - k_i(\\infty) = -\\frac{2\\ell_i}{L} k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n提取出 $1/L$ 项：\n$$k_i(L) - k_i(\\infty) = \\frac{2\\ell_i}{L} \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right) + \\frac{b_i}{L^2}$$\n主导阶行为是当 $L \\to \\infty$ 时衰减最慢的项。在此表达式中，第一项的阶数为 $\\mathcal{O}(1/L)$，第二项的阶数为 $\\mathcal{O}(1/L^2)$。对于大的 $L$，$\\mathcal{O}(1/L)$ 项占主导地位。因此，主导阶标度关系为：\n$$k_i(L) - k_i(\\infty) \\approx \\frac{2\\ell_i \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right)}{L}$$\n问题要求的是绝对差的标度关系 $|k_i(L) - k_i(\\infty)| \\sim c_i/L$。从上述近似中，我们可以确定 $c_i$：\n$$|k_i(L) - k_i(\\infty)| \\approx \\left| \\frac{2\\ell_i \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right)}{L} \\right| = \\frac{1}{L} \\cdot 2\\ell_i |k_i^{\\text{edge}} - k_i(\\infty)|$$\n因此，标度常数 $c_i$ 是：\n$$c_i = 2\\ell_i \\left| k_i^{\\text{edge}} - k_i(\\infty) \\right|$$\n\n**第 2 部分：驻留时间算法的修正变换**\n\n标准的 KMC 驻留时间（或等待时间）$\\Delta t$ 是根据所有可能事件的总速率 $K_{\\text{total}} = \\sum_j k_j$ 计算的。在一个具有边界效应的有限系统中，使用有限尺寸速率 $k_j(L)$ 会导致一个有偏差的总速率 $K_{\\text{total}}(L) = \\sum_j k_j(L)$，从而得到一个有偏差的时间步长 $\\Delta t = -(\\ln u) / K_{\\text{total}}(L)$。\n\n为了恢复体相动力学，我们必须用真实的体相总速率 $K_{\\text{total}}(\\infty) = \\sum_j k_j(\\infty)$ 来替换有偏差的总速率 $K_{\\text{total}}(L)$。然而，问题指明体相速率 $k_j(\\infty)$ 是未知的，必须使用可测量的量从模型中进行估计。所提出的修正变换是为每个事件速率 $k_j(\\infty)$ 计算一个估计量 $\\widehat{k}_j(\\infty)$。\n\n问题提供了这个估计量的公式。我们可以通过对 $k_j(L)$ 的模型进行代数反演来求解 $k_j(\\infty)$，从而论证该公式的合理性：\n$$k_j(L) = \\left(1 - \\frac{2\\ell_j}{L}\\right) k_j(\\infty) + \\frac{2\\ell_j}{L} k_j^{\\text{edge}} + \\frac{b_j}{L^2}$$\n分离含有 $k_j(\\infty)$ 的项：\n$$k_j(L) - \\frac{2\\ell_j}{L} k_j^{\\text{edge}} - \\frac{b_j}{L^2} = \\left(1 - \\frac{2\\ell_j}{L}\\right) k_j(\\infty)$$\n除以 $k_j(\\infty)$ 的系数，即可得到用其他参数表示 $k_j(\\infty)$ 的表达式。这个表达式正是所提出的估计量 $\\widehat{k}_j(\\infty)$：\n$$\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}}$$\n这个计算表明，$\\widehat{k}_j(\\infty)$ 是与有限尺寸模型和测量速率 $k_j(L)$ 完全一致的体相速率值。假设该模型是对系统的精确描述，则此过程能完全恢复真实的体相速率，即 $\\widehat{k}_j(\\infty) = k_j(\\infty)$。\n\n修正后的总速率是这些估计量的和，即 $\\sum_j \\widehat{k}_j(\\infty)$。因此，恢复了体相动力学的修正后驻留时间由下式给出：\n$$\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)}$$\n这种方法系统地从 KMC 时间步长计算中移除了有限尺寸偏差。实现过程将首先根据给定的体相参数计算 $k_j(L)$，然后使用该结果计算 $\\widehat{k}_j(\\infty)$，作为对该修正方案的程序性验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 100.0,\n            \"u\": np.exp(-1),\n            \"events\": [\n                {\"k_inf\": 1.0, \"k_edge\": 0.8, \"ell\": 2.0, \"b\": 0.0},\n                {\"k_inf\": 0.5, \"k_edge\": 0.6, \"ell\": 1.0, \"b\": 0.0},\n                {\"k_inf\": 2.0, \"k_edge\": 1.7, \"ell\": 3.0, \"b\": 0.0},\n            ]\n        },\n        {\n            \"L\": 10.0,\n            \"u\": 0.5,\n            \"events\": [\n                {\"k_inf\": 3.0, \"k_edge\": 2.0, \"ell\": 2.0, \"b\": 0.1},\n                {\"k_inf\": 1.5, \"k_edge\": 2.5, \"ell\": 3.0, \"b\": -0.2},\n            ]\n        },\n        {\n            \"L\": 10000.0,\n            \"u\": 0.9,\n            \"events\": [\n                {\"k_inf\": 0.1, \"k_edge\": 0.1, \"ell\": 1.0, \"b\": 1e-4},\n                {\"k_inf\": 10.0, \"k_edge\": 9.5, \"ell\": 5.0, \"b\": -5e-4},\n            ]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        u = case[\"u\"]\n        events = case[\"events\"]\n        \n        scaled_biases = []\n        k_L_values = []\n        k_hat_inf_values = []\n        k_inf_values = []\n\n        for event in events:\n            k_inf = event[\"k_inf\"]\n            k_edge = event[\"k_edge\"]\n            ell = event[\"ell\"]\n            b = event[\"b\"]\n            \n            # Compute k_i(L) using the specified model.\n            k_L = (1 - 2 * ell / L) * k_inf + (2 * ell / L) * k_edge + b / L**2\n            k_L_values.append(k_L)\n            \n            # Compute the scaled finite-size bias vector.\n            scaled_bias = L * abs(k_L - k_inf)\n            scaled_biases.append(scaled_bias)\n\n            # Compute the estimated bulk rate k_hat_inf.\n            # This demonstrates the inversion of the model.\n            numerator = k_L - (2 * ell / L) * k_edge - b / L**2\n            denominator = 1 - 2 * ell / L\n            k_hat_inf = numerator / denominator if denominator != 0 else 0\n            k_hat_inf_values.append(k_hat_inf)\n            \n            # Store original k_inf for comparison and for the corrected sum.\n            k_inf_values.append(k_inf)\n\n        # Calculate total rates\n        sum_k_L = sum(k_L_values)\n        sum_k_hat_inf = sum(k_hat_inf_values)\n        \n        # Calculate uncorrected and corrected residence times\n        log_u = np.log(u)\n        delta_t = -log_u / sum_k_L if sum_k_L != 0 else float('inf')\n        delta_t_corr = -log_u / sum_k_hat_inf if sum_k_hat_inf != 0 else float('inf')\n\n        # Since k_hat_inf must equal k_inf if the model is exact, we can verify this.\n        # For calculation, using sum(k_inf_values) is numerically equivalent and\n        # more direct, but we follow the explicit instruction to sum the computed k_hat_inf.\n        # assert np.isclose(sum_k_hat_inf, sum(k_inf_values))\n\n        case_results = [scaled_biases, delta_t, delta_t_corr]\n        all_results.append(case_results)\n\n    def format_nested_list_to_string(lst):\n        \"\"\"Recursively formats a nested list into a string without spaces.\"\"\"\n        if isinstance(lst, list):\n            return f\"[{','.join(map(format_nested_list_to_string, lst))}]\"\n        else:\n            return repr(lst)\n\n    # Final print statement in the exact required format.\n    print(format_nested_list_to_string(all_results))\n\nsolve()\n```"
        },
        {
            "introduction": "从晶体系统转向无序系统给KMC带来了重大挑战：当不存在底层晶格时，我们如何定义一个系统的“状态”？这项高级练习将引导你为一个局域原子环境构建一个正则关键字（canonical key），该关键字在旋转、平移和原子置换下保持不变，从而解决这一问题。掌握这项技术对于为非晶材料或复杂缺陷等非格点系统构建事件目录至关重要 。",
            "id": "3450014",
            "problem": "给定若干组三维原子位置，你需要实现一个正则化算法，用于离格动力学蒙特卡洛 (KMC) 事件目录的构建。该算法必须生成一个在任何刚性运动（平移、旋转或反射）下保持不变的局部图键，然后使用该键通过驻留时间算法 (RTA) 计算驻留时间。你必须从 Euclidean 几何和随机过程的基本原理出发推导此算法，并将其实现为一个完整、可运行的程序。\n\n请从以下基本依据开始：\n- Euclidean 等距变换保持点对距离和内积不变。具体而言，如果 $\\mathbf{R}$ 是一个满足 $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ 的正交矩阵，$\\mathbf{t}$ 是一个平移向量，那么对于任意位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，变换后的位置 $\\mathbf{x}_i' = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$ 满足 $\\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|_2 = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$ 以及 $(\\mathbf{x}_i' - \\mathbf{x}_0') \\cdot (\\mathbf{x}_j' - \\mathbf{x}_0') = (\\mathbf{x}_i - \\mathbf{x}_0) \\cdot (\\mathbf{x}_j - \\mathbf{x}_0)$，其中 $\\mathbf{x}_0$ 是一个选定的参考原子。\n- 在具有独立指数时钟的连续时间马尔可夫过程中，到下一个事件的等待时间呈指数分布，其速率参数等于各个事件速率之和。如果事件 $i$ 的速率为 $k_i$，则系统的平均驻留时间 $\\tau$（即在跃迁发生前等待时间的期望值）由 $\\tau = 1/\\sum_i k_i$ 给出。\n\n算法要求：\n- 从一组原子位置构建一个正则化的局部图键，该键在任何刚性运动下均保持不变。仅使用刚性运动下保持不变的量，即点对距离和从内积导出的角度余弦。\n- 正则键必须是局部环境的确定性函数，且不依赖于原子的原始排序。为此，你必须使用排序后的不变量多重集。\n- 为确保数值稳定性和可复现性，在排序前，将所有点对距离四舍五入至 $10^{-6}$ $\\mathrm{\\AA}$ 的容差，并将所有角度余弦四舍五入至 $10^{-6}$（无量纲）的容差。\n\n键构建规范：\n- 给定 $\\mathbb{R}^3$ 中的 $N$ 个原子位置 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 和一个指定的中心原子索引 $c$，定义集合 $S$ 为所提供的所有原子位置（假设所提供的集合已是局部邻域）。构建：\n    1. 所有点对距离 $\\{d_{ij}\\}_{1 \\le i  j \\le N}$ 的排序多重集，其中 $d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$（单位为 $\\mathrm{\\AA}$），四舍五入至 $10^{-6}$ 并按升序排序。\n    2. 中心原子 $c$ 处所有角度余弦的排序多重集，为所有无序的邻居对 $(j,k)$（其中 $j \\ne c$，$k \\ne c$，$j  k$）定义为 $\\cos\\theta_{c;jk} = \\dfrac{(\\mathbf{x}_j - \\mathbf{x}_c) \\cdot (\\mathbf{x}_k - \\mathbf{x}_c)}{\\|\\mathbf{x}_j - \\mathbf{x}_c\\|_2 \\, \\|\\mathbf{x}_k - \\mathbf{x}_c\\|_2}$，四舍五入至 $10^{-6}$ 并按升序排序。如果 $c$ 的邻居少于两个，则此多重集为空。\n- 正则键是由这两个排序列表组成的有序对。该构造在平移、旋转和反射下不变，且与输入顺序无关。\n\n驻留时间算法 (RTA) 规范：\n- 设事件目录将正则键映射到一个事件列表，每个事件由尝试频率 $\\nu_i$（单位 $\\mathrm{s}^{-1}$）和能垒 $E_i$（单位 $\\mathrm{eV}$）参数化。对于给定的温度 $T$（单位 $\\mathrm{K}$），通过 Arrhenius 关系定义速率 $k_i$：$k_i = \\nu_i \\exp\\!\\left(-\\dfrac{E_i}{k_{\\mathrm{B}} T}\\right)$，其中 $k_{\\mathrm{B}}$ 是 Boltzmann 常数（单位 $\\mathrm{eV}/\\mathrm{K}$）。平均驻留时间为 $\\tau = \\dfrac{1}{\\sum_i k_i}$ 秒。如果目录中没有该键的事件，则定义 $\\tau = +\\infty$。\n\n单位与数值要求：\n- 所有位置均以 $\\mathrm{\\AA}$ 为单位。\n- 距离必须以 $\\mathrm{\\AA}$ 计算，并在使用前四舍五入至 $10^{-6}$。\n- 角度余弦是无量纲的，必须在使用前四舍五入至 $10^{-6}$。\n- 温度必须以 $\\mathrm{K}$ 为单位。\n- 尝试频率必须以 $\\mathrm{s}^{-1}$ 为单位，能垒以 $\\mathrm{eV}$ 为单位。\n- 最终的驻留时间以秒为单位表示为浮点数，不带单位字符串。\n\n测试套件：\n实现你的程序以处理以下四个测试用例。对每个测试用例，计算其正则键，然后使用提供的事件目录计算驻留时间。程序必须按下述格式，在单行输出中生成所有测试用例的最终驻留时间。\n\n事件目录条目（键由应用于以下原型几何构型的算法定义）：\n- 对于与中心原子周围的方形平面邻域相对应的正则键（原型如下所述），使用以下事件：\n    - 事件 1: $\\nu_1 = 1.00 \\times 10^{13} \\, \\mathrm{s}^{-1}$, $E_1 = 0.55 \\, \\mathrm{eV}$。\n    - 事件 2: $\\nu_2 = 8.00 \\times 10^{12} \\, \\mathrm{s}^{-1}$, $E_2 = 0.60 \\, \\mathrm{eV}$。\n    - 事件 3: $\\nu_3 = 2.50 \\times 10^{13} \\, \\mathrm{s}^{-1}$, $E_3 = 0.85 \\, \\mathrm{eV}$。\n- 对于与中心原子周围的等边三角形邻域相对应的正则键（原型如下所述），使用以下事件：\n    - 事件 1: $\\nu_1 = 1.20 \\times 10^{13} \\, \\mathrm{s}^{-1}$, $E_1 = 0.50 \\, \\mathrm{eV}$。\n    - 事件 2: $\\nu_2 = 9.00 \\times 10^{12} \\, \\mathrm{s}^{-1}$, $E_2 = 0.70 \\, \\mathrm{eV}$。\n\nBoltzmann 常数：\n- 使用 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV}/\\mathrm{K}$。\n\n温度：\n- 所有测试用例均使用 $T = 300 \\, \\mathrm{K}$。\n\n用于定义目录键的原型几何构型：\n- 方形平面邻域（中心原子在原点）：位置（单位 $\\mathrm{\\AA}$）为\n  $\\mathbf{x}_c = (0, 0, 0)$、$\\mathbf{x}_1 = (1, 0, 0)$、$\\mathbf{x}_2 = (0, 1, 0)$、$\\mathbf{x}_3 = (-1, 0, 0)$、$\\mathbf{x}_4 = (0, -1, 0)$，中心索引为 $c = 0$。\n- 等边三角形邻域（中心原子在原点）：位置（单位 $\\mathrm{\\AA}$）为\n  $\\mathbf{x}_c = (0, 0, 0)$、$\\mathbf{x}_1 = (1, 0, 0)$、$\\mathbf{x}_2 = \\left(-\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{2}, 0\\right)$、$\\mathbf{x}_3 = \\left(-\\dfrac{1}{2}, -\\dfrac{\\sqrt{3}}{2}, 0\\right)$，中心索引为 $c = 0$。\n\n待处理的测试用例：\n- 测试用例 1（正常路径）：使用上述方形平面邻域，中心索引 $c = 0$，温度 $T = 300 \\, \\mathrm{K}$。\n- 测试用例 2（刚性运动不变性）：对测试用例 1 的方形平面邻域，绕 $z$ 轴旋转角度 $\\theta = \\dfrac{\\pi}{6}$ 弧度，然后平移向量 $\\mathbf{t} = (2.5, -1.7, 0.3)$（单位 $\\mathrm{\\AA}$）。使用中心索引 $c = 0$，温度 $T = 300 \\, \\mathrm{K}$。\n- 测试用例 3（不同环境）：使用上述等边三角形邻域，中心索引 $c = 0$，温度 $T = 300 \\, \\mathrm{K}$。\n- 测试用例 4（无事件的边界情况）：一个孤立原子，位置为 $\\mathbf{x}_c = (2, 2, 2)$（单位 $\\mathrm{\\AA}$），中心索引 $c = 0$；没有邻居。使用温度 $T = 300 \\, \\mathrm{K}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试用例 1、2、3 和 4 的驻留时间，按此顺序排列，形式为用方括号括起来的逗号分隔列表。例如，输出应类似于 $[t_1, t_2, t_3, t_4]$，其中每个 $t_i$ 是一个以秒为单位的浮点数（不带单位字符串）。如果驻留时间为无穷大，则打印为浮点无穷大。",
            "solution": "任务是为局部原子环境构建一个正则表示，该表示对刚性运动和原子排列不变，然后使用此表示根据用于动力学蒙特卡洛 (KMC) 的驻留时间算法 (RTA) 来计算系统在该状态下的驻留时间。该解决方案从 Euclidean 几何和随机过程的第一性原理推导得出。\n\n该问题被确定为有效。它在科学上基于计算材料科学的原理，在数学上是适定的、客观的，并为得到唯一的、可验证的解提供了所有必要信息。\n\n问题的核心在于两个部分：首先是正则键的设计，其次是该键在驻留时间算法中的应用。\n\n**从第一性原理构建正则键**\n\n局部原子构型 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 的正则表示（或称键）必须满足三个关键属性：平移不变性、旋转和反射不变性（合称刚性运动或等距变换），以及原子标签排列不变性。\n\n1.  **刚性运动不变性**：在 Euclidean 等距变换下保持不变的基本量是点之间的距离。给定任意两个原子位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，刚性运动将它们变换为 $\\mathbf{x}_i' = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$ 和 $\\mathbf{x}_j' = \\mathbf{R}\\mathbf{x}_j + \\mathbf{t}$，其中 $\\mathbf{R}$ 是一个正交矩阵（$\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$），$\\mathbf{t}$ 是一个平移向量。变换后点之间的距离为 $\\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|_2 = \\|(\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}) - (\\mathbf{R}\\mathbf{x}_j + \\mathbf{t})\\|_2 = \\|\\mathbf{R}(\\mathbf{x}_i - \\mathbf{x}_j)\\|_2$。由于正交矩阵保持范数不变，该距离等于 $\\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$。因此，所有点对距离的集合 $\\{d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2\\}$（$1 \\le i  j \\le N$）在任何刚性运动下都是不变的。这构成了我们键的第一个组成部分。\n\n2.  **不变性与局部结构**：虽然所有点对距离的集合构成了一个鲁棒的不变量，但通常需要包含相对于特定原子（指定为中心原子 $\\mathbf{x}_c$）的角度信息。从中心 $\\mathbf{x}_c$ 观察，两个邻居 $\\mathbf{x}_j$ 和 $\\mathbf{x}_k$ 之间的夹角 $\\theta_{c;jk}$ 由位移向量 $\\mathbf{v}_j = \\mathbf{x}_j - \\mathbf{x}_c$ 和 $\\mathbf{v}_k = \\mathbf{x}_k - \\mathbf{x}_c$ 的内积决定。该角度的余弦由 $\\cos\\theta_{c;jk} = \\frac{\\mathbf{v}_j \\cdot \\mathbf{v}_k}{\\|\\mathbf{v}_j\\|_2 \\|\\mathbf{v}_k\\|_2}$ 给出。位移向量本身是平移不变的。在旋转/反射下，它们变换为 $\\mathbf{v}_j' = \\mathbf{R}\\mathbf{v}_j$。内积保持不变：$\\mathbf{v}_j' \\cdot \\mathbf{v}_k' = (\\mathbf{R}\\mathbf{v}_j)^{\\top}(\\mathbf{R}\\mathbf{v}_k) = \\mathbf{v}_j^{\\top}\\mathbf{R}^{\\top}\\mathbf{R}\\mathbf{v}_k = \\mathbf{v}_j^{\\top}\\mathbf{I}\\mathbf{v}_k = \\mathbf{v}_j \\cdot \\mathbf{v}_k$。范数也保持不变，使得角度余弦成为一个等距变换不变量。所有此类余弦的集合 $\\{\\cos\\theta_{c;jk}\\}$（对于所有唯一的邻居对 $(j,k)$，其中 $j,k \\ne c$，并且我们可以取 $j  k$ 以避免重复计数）是不变的，构成了我们键的第二个组成部分。\n\n3.  **排列不变性**：为了确保我们的表示不依赖于原子的任意标记（例如，原子 1 和原子 2 交换位置），我们必须使用多重集（允许重复值的集合）。通过对不变量列表（距离和角度余弦）进行排序，我们创建了一个唯一的、正则的表示。两个原子构型，如果它们的原子只是重新标记，那么在排序后将产生完全相同的不变量列表。\n\n因此，由排序后的点对距离列表和排序后的中心角度余弦列表组成的有序对，构成了局部原子环境的正则键。\n\n**驻留时间算法 (RTA)**\n\nRTA 的基础是连续时间马尔可夫过程。系统在某个状态停留的时间是一个随机变量，服从指数分布。该分布的速率参数 $K_{\\text{total}}$ 是从当前状态出发的所有可能传出事件速率 $k_i$ 的总和。\n$$K_{\\text{total}} = \\sum_i k_i$$\n驻留时间是 KMC 模拟中系统在跃迁到新状态之前在当前状态停留的平均时间。它等于总速率的倒数：\n$$\\tau = \\frac{1}{K_{\\text{total}}}$$\n每个单独的事件速率 $k_i$ 通常由 Arrhenius 方程给出：\n$$k_i = \\nu_i \\exp\\left(-\\frac{E_i}{k_{\\mathrm{B}} T}\\right)$$\n其中 $\\nu_i$ 是尝试频率，$E_i$ 是活化能垒，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。\n\n如果对于给定的正则键，事件目录中没有条目，则意味着没有已知的传出事件。在这种情况下，总速率 $K_{\\text{total}} = 0$，驻留时间变为无穷大，表示系统被“困”在该状态。\n\n**实施**\n\n程序必须：\n1.  实现一个 `generate_key` 函数，该函数接收原子位置和中心原子索引，并返回由排序后的距离和角度余弦组成的元组。\n2.  为目录中的原型几何构型预先计算它们的键。\n3.  创建一个将这些原型键映射到其各自事件参数（$(\\nu_i, E_i)$ 对）的字典，作为事件目录。\n4.  对于每个测试用例：\n    a. 使用 `generate_key` 函数计算其正则键。\n    b. 在事件目录中查找该键。\n    c. 如果找到，则使用 Arrhenius 方程计算每个事件的速率，并求和得到总速率 $K_{\\text{total}}$。\n    d. 计算驻留时间 $\\tau = 1/K_{\\text{total}}$。如果 $K_{\\text{total}} = 0$（包括键未找到的情况），则 $\\tau = \\infty$。\n5.  将所有计算出的驻留时间收集到一个列表中，并以指定的格式打印。\n该方法确保了只要两个原子环境在几何上是等价的（即可通过刚性运动相互叠加），无论它们的绝对位置、朝向或原子标签如何，它们都将被映射到相同的事件集和驻留时间，从而为非晶系统的 KMC 模拟提供了必要的基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Implements the canonicalization and residence-time algorithm for off-lattice KMC.\n    \"\"\"\n    \n    # Define constants and parameters from the problem statement.\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n    TEMPERATURE = 300.0          # Temperature in K\n    PRECISION = 6                # Decimal places for rounding\n\n    def generate_key(positions: np.ndarray, central_idx: int) - tuple:\n        \"\"\"\n        Generates a canonical key for a local atomic environment.\n\n        The key is invariant under translation, rotation, reflection, and\n        permutation of atom indices.\n\n        Args:\n            positions (np.ndarray): Array of atomic positions, shape (N, 3).\n            central_idx (int): Index of the central atom.\n\n        Returns:\n            tuple: A hashable canonical key (tuple of sorted distances, \n                   tuple of sorted angle cosines).\n        \"\"\"\n        num_atoms = positions.shape[0]\n\n        # 1. Compute the sorted multiset of all pairwise distances.\n        if num_atoms  2:\n            distances = []\n        else:\n            # pdist computes distances for i  j, which matches the problem spec.\n            distances = pdist(positions)\n        \n        rounded_distances = np.round(distances, PRECISION)\n        sorted_distances = tuple(np.sort(rounded_distances))\n\n        # 2. Compute the sorted multiset of all central angle cosines.\n        neighbor_indices = [i for i in range(num_atoms) if i != central_idx]\n        \n        cosines = []\n        if len(neighbor_indices) >= 2:\n            central_pos = positions[central_idx]\n            # Iterate through all unique pairs of neighbors.\n            for j, k in combinations(neighbor_indices, 2):\n                vec_j = positions[j] - central_pos\n                vec_k = positions[k] - central_pos\n                \n                norm_j = np.linalg.norm(vec_j)\n                norm_k = np.linalg.norm(vec_k)\n\n                # The problem guarantees environments where neighbors are distinct from the center,\n                # so norms will not be zero.\n                cos_theta = np.dot(vec_j, vec_k) / (norm_j * norm_k)\n                cosines.append(cos_theta)\n\n        rounded_cosines = np.round(cosines, PRECISION)\n        sorted_cosines = tuple(np.sort(rounded_cosines))\n\n        return (sorted_distances, sorted_cosines)\n\n    # --- Build Event Catalog ---\n    # Define prototype geometries to generate catalog keys.\n    square_planar_positions = np.array([\n        [0.0, 0.0, 0.0],  # central atom c=0\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0]\n    ])\n\n    equilateral_triangle_positions = np.array([\n        [0.0, 0.0, 0.0],  # central atom c=0\n        [1.0, 0.0, 0.0],\n        [-0.5, np.sqrt(3)/2, 0.0],\n        [-0.5, -np.sqrt(3)/2, 0.0]\n    ])\n\n    # Generate the keys for the prototypes.\n    square_key = generate_key(square_planar_positions, central_idx=0)\n    triangle_key = generate_key(equilateral_triangle_positions, central_idx=0)\n\n    # Define the event catalog.\n    event_catalog = {\n        square_key: [\n            (1.00e13, 0.55),  # (nu_i in s^-1, E_i in eV)\n            (8.00e12, 0.60),\n            (2.50e13, 0.85)\n        ],\n        triangle_key: [\n            (1.20e13, 0.50),\n            (9.00e12, 0.70)\n        ]\n    }\n\n    # --- Define Test Cases ---\n    \n    # Test Case 1: Square planar neighborhood\n    case1_positions = square_planar_positions\n    \n    # Test Case 2: Rotated and translated square planar neighborhood\n    theta = np.pi / 6\n    rotation_matrix = np.array([\n        [np.cos(theta), -np.sin(theta), 0.0],\n        [np.sin(theta),  np.cos(theta), 0.0],\n        [0.0,            0.0,           1.0]\n    ])\n    translation_vector = np.array([2.5, -1.7, 0.3])\n    case2_positions = (rotation_matrix @ square_planar_positions.T).T + translation_vector\n\n    # Test Case 3: Equilateral triangle neighborhood\n    case3_positions = equilateral_triangle_positions\n\n    # Test Case 4: Single isolated atom\n    case4_positions = np.array([[2.0, 2.0, 2.0]])\n\n    test_cases = [\n        # (positions, central_idx)\n        (case1_positions, 0),\n        (case2_positions, 0),\n        (case3_positions, 0),\n        (case4_positions, 0)\n    ]\n\n    results = []\n    kbt = KB_EV_K * TEMPERATURE\n\n    # --- Process Test Cases ---\n    for positions, central_idx in test_cases:\n        # Generate the key for the current configuration.\n        key = generate_key(positions, central_idx)\n        \n        # Look up events in the catalog.\n        events = event_catalog.get(key, [])\n        \n        # Calculate total rate.\n        total_rate = 0.0\n        for nu, E in events:\n            rate = nu * np.exp(-E / kbt)\n            total_rate += rate\n            \n        # Calculate residence time.\n        if total_rate == 0.0:\n            tau = float('inf')\n        else:\n            tau = 1.0 / total_rate\n        \n        results.append(tau)\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}