{
    "hands_on_practices": [
        {
            "introduction": "理论知识的有效应用始于对核心算法的高效实现。本练习旨在为具有局部相互作用的系统构建一个高效的动力学蒙特卡洛（KMC）模拟。您将通过实践，利用“局域性”原理，将事件目录的更新从朴素的 $O(N)$ 复杂度优化到 $O(1)$，从而掌握构建可扩展模拟程序的关键技能 ()。这是理解和实施驻留时间算法的基础。",
            "id": "3450027",
            "problem": "考虑一个由 $N$ 个格点组成的一维周期性晶格（一个环），格点索引为 $i \\in \\{0,1,\\dots,N-1\\}$，具有二元占据变量 $s_i \\in \\{0,1\\}$。相互作用是局域的，范围为 $r=1$，因此每个格点有配位数 $z=2$（左、右邻居）。该系统以连续时间马尔可夫跳跃过程演化，其单格点事件会将 $s_i$ 在 $0$ 和 $1$ 之间翻转。格点 $i$ 上发生翻转的瞬时速率仅通过已占据邻居的数量 $n_i \\in \\{0,1,2\\}$ 依赖于局域环境。定义吸附为事件 $0 \\rightarrow 1$，脱附为事件 $1 \\rightarrow 0$。假设为 Arrhenius 型的过渡态速率：\n- 对吸附， $k_{\\mathrm{ads}}(n) = \\nu \\exp\\!\\left(-\\dfrac{E_{\\mathrm{ads}} - n \\,\\epsilon}{k_{\\mathrm{B}} T}\\right)$。\n- 对脱附， $k_{\\mathrm{des}}(n) = \\nu \\exp\\!\\left(-\\dfrac{E_{\\mathrm{des}} + n \\,\\epsilon}{k_{\\mathrm{B}} T}\\right)$。\n\n这里，$T$ 是绝对温度（单位为开尔文），$k_{\\mathrm{B}}$ 是玻尔兹曼常数（单位为电子伏特每开尔文），$\\nu$ 是尝试频率（单位为每秒），$E_{\\mathrm{ads}}$ 和 $E_{\\mathrm{des}}$ 是基础活化能（单位为电子伏特），$\\epsilon$ 是最近邻相互作用能（单位为电子伏特）。总速率为 $R = \\sum_{i} r_i$，其中如果 $s_i=0$，则 $r_i = k_{\\mathrm{ads}}(n_i)$；如果 $s_i=1$，则 $r_i = k_{\\mathrm{des}}(n_i)$。\n\n驻留时间算法（也称为 $n$-fold way）按如下方式选择并执行事件：\n- 到下一个事件的等待时间 $\\Delta t$ 是一个参数为 $R$ 的指数随机变量，因此对于一个均匀随机数 $u \\in (0,1)$，$\\Delta t = -\\ln(u)/R$。\n- 下一个事件以与其速率成正比的概率从所有可能事件中选出。\n\n事件目录构建根据局域环境将格点分组为不同的类别。这里，定义由数对 $(s,n)$ 索引的 $K=2(z+1)=6$ 个类别，其中 $s \\in \\{0,1\\}$ 且 $n \\in \\{0,1,2\\}$。每个类别 $k$ 有一个仅依赖于 $(s,n)$ 的单位格点速率 $r_k$ 和一个等于当前处于该局域构型中的格点数的布居数 $N_k$。总速率可以写作 $R=\\sum_{k=0}^{K-1} N_k r_k$。对于事件选择，首先按与 $N_k r_k$ 成正比的概率选择一个类别 $k$，然后在该类别内的 $N_k$ 个格点中均匀选择一个。在格点 $i$ 执行一次单格点翻转后，只有格点 $i$ 本身及其 $z=2$ 个最近邻的类别归属可能改变，因为速率仅依赖于范围 $r=1$ 内的局域构型。\n\n任务。仅使用连续时间马尔可夫过程与局域相互作用的基本定义以及上述 Arrhenius 速率，解释为何单个翻转事件仅影响一个大小有界且与 $N$ 无关的格点邻域。然后，设计一种算法，该算法能维护事件目录，并在事件发生后更新时支持每个受影响格点 $O(1)$ 的摊销时间。你的算法应该：\n- 为每个类别 $k$ 维护当前的布居数 $N_k$ 和一个成员（格点索引）的动态列表，以允许在类别内进行均匀选择。\n- 为每个格点 $i$ 维护其当前的类别索引，以便通过与类别列表中的最后一个元素交换，实现常数时间的移除和插入，从而使每个格点的更新能在 $O(1)$ 时间内执行。\n- 通过扫描 $K$ 个类别来选择下一个类别。由于 $K$ 仅依赖于 $z$ 并且对于固定的局域相互作用范围是常数，因此该步骤必须是每次事件 $O(1)$。\n- 当类别归属发生变化时，增量更新总速率 $R$。\n\n实现。使用上述事件目录维护方法，为以下固定参数值实现驻留时间算法：\n- 温度 $T = 500$ 开尔文。\n- 玻尔兹曼常数 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}$ 电子伏特每开尔文。\n- 尝试频率 $\\nu = 10^{13}$ 每秒。\n- 能量 $E_{\\mathrm{ads}} = 0.35$ 电子伏特，$E_{\\mathrm{des}} = 0.45$ 电子伏特，以及 $\\epsilon = 0.05$ 电子伏特。\n\n使用周期性边界条件。对于每个模拟步骤，使用三个在 $(0,1)$ 区间内的独立均匀随机数：一个用于类别选择，一个用于在所选类别内选择格点，一个用于驻留时间。下面提供一个包含三个测试用例的测试套件。对于每个用例，模拟固定数量的事件并记录总模拟时间。此外，在每一步通过在每个事件后为所有格点重新计算类别标签，并检查类别发生变化的格点集合是否包含在由翻转格点及其两个最近邻组成的集合之内，来验证局域性属性。\n\n测试套件。对于每个用例，初始构型是一个长度为 $N$ 的数字字符串，编码了 $s_0 s_1 \\dots s_{N-1}$，要模拟的事件数量为 $M$，随机数以一个长度为 $3M$ 的扁平列表形式给出，顺序为每个步骤的 $(u_{\\mathrm{class}}, u_{\\mathrm{site}}, u_{\\mathrm{time}})$。\n\n- 用例 1：$N=10$，初始构型 $0101101001$，$M=8$，随机数\n  $\\{0.13, 0.77, 0.42, 0.91, 0.05, 0.33, 0.68, 0.27, 0.88, 0.12, 0.56, 0.74, 0.21, 0.93, 0.49, 0.36, 0.59, 0.18, 0.81, 0.07, 0.66, 0.25, 0.97, 0.44\\}$。\n\n- 用例 2：$N=6$，初始构型 $000000$，$M=6$，随机数\n  $\\{0.11, 0.62, 0.58, 0.47, 0.29, 0.83, 0.14, 0.71, 0.39, 0.52, 0.26, 0.64, 0.19, 0.86, 0.41, 0.73, 0.32, 0.57\\}$。\n\n- 用例 3：$N=4$，初始构型 $1111$，$M=5$，随机数\n  $\\{0.24, 0.68, 0.35, 0.79, 0.22, 0.61, 0.48, 0.84, 0.17, 0.69, 0.53, 0.91, 0.28, 0.75, 0.46\\}$。\n\n输出规范。你的程序必须：\n- 为这三个用例精确地实现算法并执行模拟。\n- 对每个用例，按顺序输出两个值：$M$ 个事件后的总模拟时间，以纳秒（即秒乘以 $10^{9}$）表示，并四舍五入到三位小数；以及一个布尔值，指示局域性验证是否在每一步都通过。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为用例 1、2 和 3。最终输出格式必须严格为：$[t_1,\\mathrm{local}_1,t_2,\\mathrm{local}_2,t_3,\\mathrm{local}_3]$，其中每个 $t_j$ 是一个四舍五入到三位小数的纳秒单位的十进制数，每个 $\\mathrm{local}_j$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "该问题是有效的。它在计算材料科学领域提出了一个清晰、有科学依据且定义明确的任务，具体来说是使用驻留时间算法和高效事件目录实现动力学蒙特卡洛（KMC）模拟。\n\n### 局域性的理论论证\n\n“单格点翻转事件仅影响一个大小有界的邻域”这一论断是模型中定义的相互作用局域性的直接结果。系统的演化由一组跃迁速率控制，其中特定格点 $i$ 的翻转速率仅取决于该格点及其直接环境的状态。\n\n设系统的状态为所有占据变量的构型，$S = \\{s_0, s_1, \\dots, s_{N-1}\\}$。格点 $i$ 上一个潜在事件（翻转）的速率记为 $r_i$，并且是局域构型的函数。具体来说，问题将格点 $i$ 的速率定义为依赖于其自身状态 $s_i$ 和已占据的最近邻数量 $n_i$。对于相互作用范围 $r=1$ 的一维晶格，格点 $i$ 的邻居位于索引 $(i-1) \\pmod N$ 和 $(i+1) \\pmod N$ 处。因此，已占据邻居的数量为 $n_i = s_{(i-1) \\pmod N} + s_{(i+1) \\pmod N}$。因此，速率 $r_i$ 是一个函数 $f(s_i, s_{(i-1) \\pmod N}, s_{(i+1) \\pmod N})$。\n\n事件目录根据局域构型将格点分组为不同的类别。格点 $i$ 的类别由数对 $(s_i, n_i)$ 定义。因此，格点 $i$ 的类别由集合 $\\mathcal{N}_i = \\{i, (i-1) \\pmod N, (i+1) \\pmod N\\}$ 中格点的状态决定。\n\n现在，考虑一个事件：在选定的格点 $j$ 上发生一次翻转。这意味着状态变量 $s_j$ 改变，$s_j \\rightarrow 1-s_j$。我们来研究哪些格点会因此次单次翻转而改变类别。一个格点 $i$ 的类别发生变化，当且仅当其状态 $s_i$ 或其邻居数 $n_i$ 发生变化。\n\n1.  **格点 $j$（被翻转的格点）：** 根据定义，其状态 $s_j$ 发生改变。其邻居数 $n_j = s_{(j-1) \\pmod N} + s_{(j+1) \\pmod N}$ 依赖于其邻居，而邻居的状态没有改变。因此，数对 $(s_j, n_j)$ 发生变化，格点 $j$ 必须改变其类别。\n\n2.  **$j$ 的邻居，格点 $k=(j-1) \\pmod N$：** 其状态 $s_k$ 保持不变。其邻居数是 $n_k = s_{(k-1) \\pmod N} + s_{(k+1) \\pmod N} = s_{(j-2) \\pmod N} + s_j$。由于 $s_j$ 已经改变，$n_k$ 也可能改变。因此，格点 $k=(j-1) \\pmod N$ 的类别可能会改变。\n\n3.  **$j$ 的邻居，格点 $l=(j+1) \\pmod N$：** 其状态 $s_l$ 保持不变。其邻居数是 $n_l = s_{(l-1) \\pmod N} + s_{(l+1) \\pmod N} = s_j + s_{(j+2) \\pmod N}$。由于 $s_j$ 已经改变，$n_l$ 也可能改变。因此，格点 $l=(j+1) \\pmod N$ 的类别可能会改变。\n\n4.  **任何其他格点 $m \\notin \\{j, (j-1)\\pmod N, (j+1)\\pmod N\\}$：** 其状态 $s_m$ 不变。其邻居数是 $n_m = s_{(m-1) \\pmod N} + s_{(m+1) \\pmod N}$。由于格点 $m$ 及其邻居都与格点 $j$ 不同，状态 $s_m$、$s_{(m-1) \\pmod N}$ 和 $s_{(m+1) \\pmod N}$ 都不会受到 $j$ 处翻转的影响。因此，$s_m$ 和 $n_m$ 都不会改变，格点 $m$ 的类别保持不变。\n\n总之，唯一可能改变类别归属的格点是被翻转的格点本身（$j$）及其最近邻（$(j-1)\\pmod N$ 和 $(j+1)\\pmod N$）。这个可能受影响的格点集合的大小为 $1+z = 1+2 = 3$，其中 $z=2$ 是配位数。这个大小是一个很小的常数，与总格点数 $N$ 无关。这种局域性原理对于具有短程相互作用的系统的 KMC 算法效率至关重要。\n\n### $O(1)$ 更新的算法设计\n\n为了在具有恒定类别数 $K$ 的系统中实现每次事件 $O(1)$ 的摊销时间复杂度，我们必须设计支持常数时间事件选择和状态更新的数据结构。\n\n**1. 数据结构**\n\n该算法的核心在于维护一个所有可能事件的实时目录。\n- **`state[i]`**：一个大小为 $N$ 的数组，存储每个格点 $i$ 的二元占据变量 $s_i$。\n- **`class_rates[k]`**：一个大小为 $K=6$ 的数组，存储每个类别 $k$ 预先计算的单位格点速率 $r_k$。类别索引 $k$ 可以通过 $k = s \\cdot (z+1) + n = 3s+n$ 从 $(s,n)$ 映射得到。这些速率在整个模拟过程中是恒定的。\n- **`class_pops[k]`**：一个大小为 $K$ 的数组，存储每个类别的当前布居数 $N_k$。\n- **`total_rate`**：一个标量变量，存储总速率 $R = \\sum_{k=0}^{K-1} N_k r_k$。\n- **`class_members[k]`**：一个列表（或动态数组）的数组，其中 `class_members[k]` 包含当前属于类别 $k$ 的所有格点的索引。这允许在类别内均匀随机地选择一个格点。\n- **`site_to_class[i]`**：一个大小为 $N$ 的数组，其中 `site_to_class[i]` 存储格点 $i$ 当前的类别索引 $k$。\n- **`site_to_pos_in_class[i]`**：一个大小为 $N$ 的数组。这是实现 $O(1)$ 更新的关键结构。`site_to_pos_in_class[i]` 存储格点 $i$ 在列表 `class_members[site_to_class[i]]` 中的索引（位置）。即 `class_members[site_to_class[i]][site_to_pos_in_class[i]] == i`。\n\n**2. 初始化**\n\n1.  从给定的初始构型初始化 `state` 数组。\n2.  使用给定的 Arrhenius 表达式计算 $K=6$ 个单位格点速率 $r_k$ 并将它们存储在 `class_rates` 中。\n3.  将 `class_pops` 初始化为零，并将 `class_members` 初始化为 $K$ 个空列表。\n4.  遍历每个格点 $i \\in \\{0, \\dots, N-1\\}$：\n    a. 通过计算 $n_i$ 并使用 $k=3s_i+n_i$ 来确定其初始类别 $k$。\n    b. 将格点添加到其类别中：将 $i$ 附加到 `class_members[k]`，设置 `site_to_class[i]=k`，将 `site_to_pos_in_class[i]` 设置为 `class_members[k]` 中的新最后一个索引，并增加 `class_pops[k]`。\n5.  计算初始 `total_rate` $R = \\sum_{k} \\text{class\\_pops}[k] \\cdot \\text{class\\_rates}[k]$。\n\n**3. 模拟步骤（单个事件）**\n\n1.  **事件选择**：\n    a. 生成一个均匀随机数 $u_{\\mathrm{class}} \\in (0,1)$。\n    b. 以与该类别总速率 $N_k r_k$ 成正比的概率选择一个类别 $k_{sel}$。这可以通过找到满足 $\\sum_{j=0}^{k_{sel}} N_j r_j > u_{\\mathrm{class}} \\cdot R$ 的最小 $k_{sel}$ 来完成。由于 $K$ 是一个小常数，这个线性扫描耗时 $O(K) = O(1)$。\n    c. 生成一个均匀随机数 $u_{\\mathrm{site}} \\in (0,1)$。\n    d. 通过从列表 `class_members[k_{sel}]` 中选择一个随机元素来选择要翻转的格点 $i_{flip}$。索引为 $\\lfloor u_{\\mathrm{site}} \\cdot N_{k_{sel}} \\rfloor$。这是一个 $O(1)$ 操作。\n\n2.  **时间推进**：\n    a. 生成一个均匀随机数 $u_{\\mathrm{time}} \\in (0,1)$。\n    b. 将模拟时间推进 $\\Delta t = -\\ln(u_{\\mathrm{time}}) / R$。\n\n3.  **状态和目录更新**：\n    a. 翻转所选格点的状态：$s_{i_{flip}} \\rightarrow 1 - s_{i_{flip}}$。\n    b. 识别受影响的格点集合：$\\mathcal{A} = \\{ (i_{flip}-1)\\pmod N, i_{flip}, (i_{flip}+1)\\pmod N \\}$。\n    c. 对于集合 $\\mathcal{A}$ 中的每个格点 $j$：\n        i.  获取其旧类别 $k_{old} = \\text{site\\_to\\_class}[j]$。\n        ii. 重新计算其局域环境以找到其新类别 $k_{new}$。\n        iii. 如果 $k_{new} \\neq k_{old}$：\n            - **更新总速率**：$R \\leftarrow R - r_{k_{old}} + r_{k_{new}}$。\n            - **从旧类别中移除**：这必须是一个 $O(1)$ 操作。\n                - 获取格点在其类别列表中的当前位置：$p_j = \\text{site\\_to\\_pos\\_in\\_class}[j]$。\n                - 设 $i_{last}$ 是 `class_members[k_{old}]` 中的最后一个格点。\n                - 将 $i_{last}$ 移动到位置 $p_j$：`class_members[k_{old}][p_j] = i_{last}`。\n                - 更新被移动格点的位置：`site_to_pos_in_class[i_{last}] = p_j`。\n                - 从 `class_members[k_{old}]` 中移除最后一个元素。\n                - 递减 `class_pops[k_{old}]`。\n            - **添加到新类别**：这是一个 $O(1)$ 操作。\n                - 将 $j$ 附加到 `class_members[k_{new}]`。\n                - 更新 `site_to_class[j] = k_{new}`。\n                - 将 `site_to_pos_in_class[j]` 更新为新的最后一个索引。\n                - 递增 `class_pops[k_{new}]`。\n\n由于受影响集合 $\\mathcal{A}$ 的大小是常数（$3$），并且由于 `site_to_pos_in_class` 提供的直接寻址，每个格点的更新耗时 $O(1)$，因此每次事件的总更新时间为 $O(1)$。所以，整个模拟步骤的时间复杂度为 $O(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    class KMCSimulator:\n        \"\"\"\n        Implements the residence-time algorithm with an efficient event catalog.\n        \"\"\"\n        def __init__(self, N, initial_config_str, params):\n            self.N = N\n            self.state = np.array([int(c) for c in initial_config_str], dtype=np.int8)\n            self.params = params\n            \n            # Constants\n            self.K = 6  # Number of classes\n            self.z = 2  # Coordination number\n            \n            # Data structures for catalog\n            self.class_rates = np.zeros(self.K, dtype=np.float64)\n            self.class_pops = np.zeros(self.K, dtype=np.int32)\n            self.class_members = [[] for _ in range(self.K)]\n            self.site_to_class = np.full(self.N, -1, dtype=np.int32)\n            self.site_to_pos_in_class = np.full(self.N, -1, dtype=np.int32)\n            self.total_rate = 0.0\n\n            self._precompute_rates()\n            self._initialize_catalog()\n\n        def _precompute_rates(self):\n            nu = self.params['nu']\n            E_ads = self.params['E_ads']\n            E_des = self.params['E_des']\n            epsilon = self.params['epsilon']\n            kBT = self.params['k_B'] * self.params['T']\n            \n            # Classes s=0 (adsorption)\n            for n in range(3):\n                k = 3 * 0 + n\n                E_A = E_ads - n * epsilon\n                self.class_rates[k] = nu * np.exp(-E_A / kBT)\n            \n            # Classes s=1 (desorption)\n            for n in range(3):\n                k = 3 * 1 + n\n                E_A = E_des + n * epsilon\n                self.class_rates[k] = nu * np.exp(-E_A / kBT)\n\n        def _get_class_of_site(self, i):\n            s_i = self.state[i]\n            n_i = self.state[(i - 1) % self.N] + self.state[(i + 1) % self.N]\n            return 3 * s_i + n_i\n\n        def _add_site_to_class(self, site_idx, class_idx):\n            self.class_members[class_idx].append(site_idx)\n            pos = len(self.class_members[class_idx]) - 1\n            self.site_to_class[site_idx] = class_idx\n            self.site_to_pos_in_class[site_idx] = pos\n            self.class_pops[class_idx] += 1\n        \n        def _remove_site_from_class(self, site_idx, class_idx):\n            pos = self.site_to_pos_in_class[site_idx]\n            last_site_in_class = self.class_members[class_idx][-1]\n            \n            # Swap with last element for O(1) removal\n            self.class_members[class_idx][pos] = last_site_in_class\n            self.site_to_pos_in_class[last_site_in_class] = pos\n            \n            self.class_members[class_idx].pop()\n            self.class_pops[class_idx] -= 1\n\n        def _initialize_catalog(self):\n            for i in range(self.N):\n                k = self._get_class_of_site(i)\n                self._add_site_to_class(i, k)\n            \n            self.total_rate = np.dot(self.class_pops, self.class_rates)\n\n        def _update_site_and_neighbors(self, site_idx):\n            affected_sites = {(site_idx - 1) % self.N, site_idx, (site_idx + 1) % self.N}\n            \n            for i in affected_sites:\n                old_class = self.site_to_class[i]\n                new_class = self._get_class_of_site(i)\n\n                if old_class != new_class:\n                    # Update total rate\n                    self.total_rate -= self.class_rates[old_class]\n                    self.total_rate += self.class_rates[new_class]\n                    \n                    # Move site between classes\n                    self._remove_site_from_class(i, old_class)\n                    self._add_site_to_class(i, new_class)\n\n        def run_simulation(self, M, random_numbers):\n            total_time = 0.0\n            locality_verification_passed = True\n            rng_iterator = iter(random_numbers)\n\n            for step in range(M):\n                if self.total_rate == 0.0:\n                    break\n                \n                # --- Locality Verification (pre-flip) ---\n                if locality_verification_passed:\n                    old_classes = np.array([self._get_class_of_site(i) for i in range(self.N)])\n                \n                # --- Step 1: Select class ---\n                u_class = next(rng_iterator)\n                rand_val = u_class * self.total_rate\n                \n                partial_rate_sum = 0.0\n                selected_class = -1\n                for k in range(self.K):\n                    partial_rate_sum += self.class_pops[k] * self.class_rates[k]\n                    if rand_val = partial_rate_sum:\n                        selected_class = k\n                        break\n                \n                # --- Step 2: Select site ---\n                u_site = next(rng_iterator)\n                num_sites_in_class = self.class_pops[selected_class]\n                selected_pos = int(u_site * num_sites_in_class)\n                site_to_flip = self.class_members[selected_class][selected_pos]\n                \n                # --- Step 3: Advance time ---\n                u_time = next(rng_iterator)\n                dt = -np.log(u_time) / self.total_rate\n                total_time += dt\n\n                # --- Step 4: Execute event and update ---\n                self.state[site_to_flip] = 1 - self.state[site_to_flip]\n                self._update_site_and_neighbors(site_to_flip)\n\n                # --- Locality Verification (post-flip) ---\n                if locality_verification_passed:\n                    new_classes = np.array([self._get_class_of_site(i) for i in range(self.N)])\n                    changed_sites = {i for i, (old, new) in enumerate(zip(old_classes, new_classes)) if old != new}\n                    expected_affected = {(site_to_flip - 1) % self.N, site_to_flip, (site_to_flip + 1) % self.N}\n                    if not changed_sites.issubset(expected_affected):\n                        locality_verification_passed = False\n\n            return total_time, locality_verification_passed\n\n    # Fixed parameters for all simulations\n    params = {\n        'T': 500.0,\n        'k_B': 8.617333262145e-5,\n        'nu': 1e13,\n        'E_ads': 0.35,\n        'E_des': 0.45,\n        'epsilon': 0.05,\n    }\n\n    # Test suite\n    test_cases = [\n        {\n            \"N\": 10,\n            \"initial_config\": \"0101101001\",\n            \"M\": 8,\n            \"random_numbers\": [0.13, 0.77, 0.42, 0.91, 0.05, 0.33, 0.68, 0.27, 0.88, 0.12, 0.56, 0.74, 0.21, 0.93, 0.49, 0.36, 0.59, 0.18, 0.81, 0.07, 0.66, 0.25, 0.97, 0.44]\n        },\n        {\n            \"N\": 6,\n            \"initial_config\": \"000000\",\n            \"M\": 6,\n            \"random_numbers\": [0.11, 0.62, 0.58, 0.47, 0.29, 0.83, 0.14, 0.71, 0.39, 0.52, 0.26, 0.64, 0.19, 0.86, 0.41, 0.73, 0.32, 0.57]\n        },\n        {\n            \"N\": 4,\n            \"initial_config\": \"1111\",\n            \"M\": 5,\n            \"random_numbers\": [0.24, 0.68, 0.35, 0.79, 0.22, 0.61, 0.48, 0.84, 0.17, 0.69, 0.53, 0.91, 0.28, 0.75, 0.46]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sim = KMCSimulator(case[\"N\"], case[\"initial_config\"], params)\n        total_time_s, locality_ok = sim.run_simulation(case[\"M\"], case[\"random_numbers\"])\n        total_time_ns = total_time_s * 1e9\n        results.append((total_time_ns, locality_ok))\n    \n    # Format and print the final output string\n    output_parts = []\n    for t, loc in results:\n        output_parts.append(f\"{t:.3f}\")\n        output_parts.append(str(loc))\n        \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了核心算法之后，下一步是处理实际模拟中不可避免的复杂性。由于计算资源的限制，我们的模拟总是在有限的尺度上进行，这会引入与真实宏观系统行为不符的“有限尺寸”人为效应。本练习将指导您如何对这些边界效应进行建模、量化，并最终在驻留时间算法中校正它们，以确保您的模拟结果能够准确地反映体相材料的性质 ()。",
            "id": "3449946",
            "problem": "考虑一个长度为 $L$ 的一维平板，用于为计算材料科学中的动力学蒙特卡洛（KMC）模拟构建事件目录。由于边界效应，每种基本事件类型 $i$ 都有一个与位置相关的局部倾向（local propensity）$r_i(x)$。事件目录使用有限尺寸测量来估计事件速率，这会对那些激活环境在边界附近受到扰动的事件引入偏差。设事件 $i$ 的边界层宽度为 $\\ell_i$（其中 $\\ell_i \\ll L$），并假设局部倾向在内部区域空间上是均匀的，而在边界层内则发生改变。将事件 $i$ 的有限尺寸测量速率 $k_i(L)$ 定义为 $r_i(x)$ 在整个平板上的空间平均值：\n$$\nk_i(L) = \\frac{1}{L} \\int_0^L r_i(x)\\, dx.\n$$\n假设一个带有微小曲率校正的双区域模型：\n- 在内部区域 $x \\in [\\ell_i, L - \\ell_i]$，局部倾向等于其体相值（bulk value）$k_i(\\infty)$，该值与 $L$ 无关。\n- 在边界层 $x \\in [0, \\ell_i] \\cup [L - \\ell_i, L]$，局部倾向等于 $k_i^{\\text{edge}}$。\n- 由于目录构建中的人为效应（artifacts），有限尺寸测量包含一个微弱的二阶校正项 $b_i/L^2$。\n\n在这些假设下，事件 $i$ 的有限尺寸速率模型为\n$$\nk_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2},\n$$\n其中 $\\ell_i  L/2$，以确保内部区域存在。您的任务是：\n1. 从上述定义和模型出发，推导受边界影响事件的主导阶有限尺寸偏差标度关系：\n$$\n\\left|k_i(L) - k_i(\\infty)\\right| \\sim \\frac{c_i}{L},\n$$\n并用 $\\ell_i$、$k_i(\\infty)$ 和 $k_i^{\\text{edge}}$ 表示 $c_i$。\n2. 提出并论证一种用于驻留时间算法的校正变换，以恢复体相动力学。驻留时间算法按如下方式抽样等待时间\n$$\n\\Delta t = -\\frac{\\ln u}{\\sum_j k_j(L)},\n$$\n其中 $u \\in (0,1)$ 是一个均匀分布的随机数，求和遍历目录中所有的事件类型 $j$。提供一个校正后的表达式，用一个与体相一致的速率和替换 $\\sum_j k_j(L)$，且仅使用可从有限尺寸模型中获取的量（即 $k_j(L)$、$k_j^{\\text{edge}}$、$\\ell_j$ 和 $b_j$），约束条件是 $k_j(\\infty)$ 无法直接测量，必须从模型中估计。校正后的表达式必须具有以下形式\n$$\n\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)},\n$$\n并且必须可以根据给定参数进行显式计算。\n\n实现一个程序，对每个指定的测试用例，计算：\n- 案例中所有事件 $i$ 的标度化有限尺寸偏差向量 $\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i$。\n- 未校正的驻留时间 $\\Delta t$（单位：秒）。\n- 使用您提出的校正方法计算出的已校正驻留时间 $\\Delta t_{\\text{corr}}$（单位：秒）。\n\n您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个形如下式的嵌套列表\n$$\n\\left[\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i,\\ \\Delta t,\\ \\Delta t_{\\text{corr}}\\right].\n$$\n\n使用以下测试套件（所有速率单位为 $\\text{s}^{-1}$，长度单位为任意单位且在各参数间保持一致，时间必须表示为无单位符号的普通浮点数秒）：\n\n- 测试用例 1 (通用理想路径):\n  - $L = 100$, $u =  \\exp(-1)$,\n  - 事件 $i = 1,2,3$ 及其参数:\n    - $k_1(\\infty) = 1.0$, $k_1^{\\text{edge}} = 0.8$, $\\ell_1 = 2.0$, $b_1 = 0.0$,\n    - $k_2(\\infty) = 0.5$, $k_2^{\\text{edge}} = 0.6$, $\\ell_2 = 1.0$, $b_2 = 0.0$,\n    - $k_3(\\infty) = 2.0$, $k_3^{\\text{edge}} = 1.7$, $\\ell_3 = 3.0$, $b_3 = 0.0$.\n\n- 测试用例 2 (强边界影响，小系统):\n  - $L = 10$, $u = 0.5$,\n  - 事件 $i = 1,2$ 及其参数:\n    - $k_1(\\infty) = 3.0$, $k_1^{\\text{edge}} = 2.0$, $\\ell_1 = 2.0$, $b_1 = 0.1$,\n    - $k_2(\\infty) = 1.5$, $k_2^{\\text{edge}} = 2.5$, $\\ell_2 = 3.0$, $b_2 = -0.2$.\n\n- 测试用例 3 (近体相极限，大系统):\n  - $L = 10000$, $u = 0.9$,\n  - 事件 $i = 1,2$ 及其参数:\n    - $k_1(\\infty) = 0.1$, $k_1^{\\text{edge}} = 0.1$, $\\ell_1 = 1.0$, $b_1 = 10^{-4}$,\n    - $k_2(\\infty) = 10.0$, $k_2^{\\text{edge}} = 9.5$, $\\ell_2 = 5.0$, $b_2 = -5\\times 10^{-4}$.\n\n对每个测试用例：\n- 使用指定模型计算 $k_i(L)$。\n- 计算 $c_i$ 和向量 $\\left[L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|\\right]_i$。\n- 使用 $\\sum_j k_j(L)$ 计算 $\\Delta t$。\n- 通过代数消元 $k_j(\\infty)$ 从模型中计算 $\\widehat{k}_j(\\infty)$：\n$$\n\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}},\n$$\n然后使用 $\\sum_j \\widehat{k}_j(\\infty)$ 计算 $\\Delta t_{\\text{corr}}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个嵌套列表，每个嵌套列表包含：\n- 一个浮点数列表，表示按事件顺序排列的标度化偏差，\n- 未校正的 $\\Delta t$，为浮点数，单位为秒，\n- 已校正的 $\\Delta t_{\\text{corr}}$，为浮点数，单位为秒。\n\n例如，输出应如下所示\n$[\\,[\\,[s_{1}, s_{2}, \\dots], \\Delta t_1, \\Delta t_{\\text{corr},1}], \\,[\\,[\\dots], \\Delta t_2, \\Delta t_{\\text{corr},2}], \\,[\\,[\\dots], \\Delta t_3, \\Delta t_{\\text{corr},3}]\\,]$,\n其中每个 $s_i$ 是相应事件的 $L\\cdot\\left|k_i(L) - k_i(\\infty)\\right|$。最终打印的数字必须是无单位的普通浮点数，并按规定汇集成一行。",
            "solution": "在尝试解答之前，对问题陈述的有效性进行评估。\n\n### 步骤 1：提取已知条件\n- **平板几何**：长度为 $L$ 的一维平板。\n- **事件类型 $i$**：由与位置相关的局部倾向 $r_i(x)$ 表征。\n- **边界层宽度**：$\\ell_i$，其中 $\\ell_i \\ll L$，具体为 $\\ell_i  L/2$。\n- **有限尺寸测量速率 $k_i(L)$**：\n$$k_i(L) = \\frac{1}{L} \\int_0^L r_i(x)\\, dx.$$\n- **双区域倾向模型**：\n  - 内部区域 ($x \\in [\\ell_i, L - \\ell_i]$)：$r_i(x) = k_i(\\infty)$ (体相速率)。\n  - 边界层 ($x \\in [0, \\ell_i] \\cup [L - \\ell_i, L]$)：$r_i(x) = k_i^{\\text{edge}}$ (边缘速率)。\n- **有限尺寸速率 $k_i(L)$ 的模型**：\n$$k_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}.$$\n- **任务 1**：推导主导阶有限尺寸偏差标度关系 $|k_i(L) - k_i(\\infty)| \\sim \\frac{c_i}{L}$ 并确定 $c_i$。\n- **任务 2**：为驻留时间算法提出一个校正变换。\n- **驻留时间算法（未校正）**：\n$$\\Delta t = -\\frac{\\ln u}{\\sum_j k_j(L)},$$\n其中 $u \\in (0,1)$ 是一个均匀分布的随机数。\n- **校正后的驻留时间形式**：\n$$\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)}.$$\n- **体相速率的估计量**：\n$$\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}}.$$\n- **测试用例**：提供了三组特定的参数（$L$、$u$ 和事件数据 $\\{k_i(\\infty), k_i^{\\text{edge}}, \\ell_i, b_i\\}$）用于实现。\n- **输出要求**：对每个测试用例，计算并输出一个嵌套列表，其中包含：1. 标度化有限尺寸偏差向量 $[L \\cdot |k_i(L) - k_i(\\infty)|]_i$。2. 未校正的驻留时间 $\\Delta t$。3. 校正后的驻留时间 $\\Delta t_{\\text{corr}}$。最终输出必须是单行，格式为这些嵌套列表的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题植根于计算材料科学，特别是动力学蒙特卡洛（KMC）模拟中的标准实践和已知挑战。有限尺寸效应、边界扰动速率及其 $1/L$ 标度关系是该领域的一个基本课题。驻留时间算法是 KMC 中推进时间的标准方法。所提供的模型是针对此类系统的公认的一阶近似。\n- **适定性**：问题定义清晰。它要求基于明确的公式和参数进行特定的推导和计算实现。推导是直接的代数操作。计算任务在测试用例中提供了所有必要的数据，并且明确规定了预期的输出格式。所有测试用例均满足约束条件 $\\ell_i  L/2$，确保了模型的物理诠释成立。\n- **客观性**：问题以精确、正式和客观的语言陈述，没有歧义或主观内容。\n- **其他缺陷**：该问题没有表现出任何列举的缺陷。它在科学上是合理的、可形式化的、完整的和计算上可行的。在所提供模型的背景下，解是唯一的且有意义的。\n\n### 步骤 3：结论与行动\n问题是 **有效的**。将提供解答。\n\n### 解答\n根据要求，解答分为两部分：首先是理论推导，其次是校正算法的论证。\n\n**第一部分：有限尺寸偏差标度关系的推导**\n\n事件类型 $i$ 的有限尺寸偏差是有限尺寸测量速率 $k_i(L)$ 与真实体相速率 $k_i(\\infty)$ 之间的差值。我们从给定的 $k_i(L)$ 模型开始：\n$$k_i(L) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n为了求出偏差，我们从等式两边减去 $k_i(\\infty)$：\n$$k_i(L) - k_i(\\infty) = \\left(1 - \\frac{2\\ell_i}{L}\\right) k_i(\\infty) - k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n展开右侧的第一项得到：\n$$k_i(L) - k_i(\\infty) = k_i(\\infty) - \\frac{2\\ell_i}{L} k_i(\\infty) - k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n$k_i(\\infty)$ 项相互抵消，剩下：\n$$k_i(L) - k_i(\\infty) = -\\frac{2\\ell_i}{L} k_i(\\infty) + \\frac{2\\ell_i}{L} k_i^{\\text{edge}} + \\frac{b_i}{L^2}$$\n提出 $1/L$ 项：\n$$k_i(L) - k_i(\\infty) = \\frac{2\\ell_i}{L} \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right) + \\frac{b_i}{L^2}$$\n主导阶行为是当 $L \\to \\infty$ 时衰减最慢的项。在此表达式中，第一项是 $\\mathcal{O}(1/L)$ 阶，第二项是 $\\mathcal{O}(1/L^2)$ 阶。对于大的 $L$，$\\mathcal{O}(1/L)$ 项占主导地位。因此，主导阶标度关系为：\n$$k_i(L) - k_i(\\infty) \\approx \\frac{2\\ell_i \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right)}{L}$$\n问题要求的是绝对差值的标度关系 $|k_i(L) - k_i(\\infty)| \\sim c_i/L$。根据上述近似，我们可以确定 $c_i$：\n$$|k_i(L) - k_i(\\infty)| \\approx \\left| \\frac{2\\ell_i \\left( k_i^{\\text{edge}} - k_i(\\infty) \\right)}{L} \\right| = \\frac{1}{L} \\cdot 2\\ell_i |k_i^{\\text{edge}} - k_i(\\infty)|$$\n因此，标度常数 $c_i$ 为：\n$$c_i = 2\\ell_i \\left| k_i^{\\text{edge}} - k_i(\\infty) \\right|$$\n\n**第二部分：驻留时间算法的校正变换**\n\n标准的 KMC 驻留时间（或等待时间）$\\Delta t$ 是根据所有可能事件的总速率 $K_{\\text{total}} = \\sum_j k_j$ 计算的。在具有边界效应的有限系统中，使用有限尺寸速率 $k_j(L)$ 会导致一个有偏差的总速率 $K_{\\text{total}}(L) = \\sum_j k_j(L)$，从而导致一个有偏差的时间步长 $\\Delta t = -(\\ln u) / K_{\\text{total}}(L)$。\n\n为了恢复体相动力学，我们必须用真实的体相总速率 $K_{\\text{total}}(\\infty) = \\sum_j k_j(\\infty)$ 替换有偏差的总速率 $K_{\\text{total}}(L)$。然而，问题指明体相速率 $k_j(\\infty)$ 是未知的，必须使用可测量的量从模型中估计。所提出的校正变换是为每个事件速率 $k_j(\\infty)$ 计算一个估计量 $\\widehat{k}_j(\\infty)$。\n\n问题为此估计量提供了公式。我们可以通过对 $k_j(L)$ 的模型进行代数反演以求解 $k_j(\\infty)$ 来证明其合理性：\n$$k_j(L) = \\left(1 - \\frac{2\\ell_j}{L}\\right) k_j(\\infty) + \\frac{2\\ell_j}{L} k_j^{\\text{edge}} + \\frac{b_j}{L^2}$$\n分离含有 $k_j(\\infty)$ 的项：\n$$k_j(L) - \\frac{2\\ell_j}{L} k_j^{\\text{edge}} - \\frac{b_j}{L^2} = \\left(1 - \\frac{2\\ell_j}{L}\\right) k_j(\\infty)$$\n除以 $k_j(\\infty)$ 的系数，即可得到用其他参数表示的 $k_j(\\infty)$ 表达式。该表达式正是所提出的估计量 $\\widehat{k}_j(\\infty)$：\n$$\\widehat{k}_j(\\infty) = \\frac{k_j(L) - \\left(\\frac{2\\ell_j}{L}\\right) k_j^{\\text{edge}} - \\frac{b_j}{L^2}}{1 - \\frac{2\\ell_j}{L}}$$\n此计算表明，$\\widehat{k}_j(\\infty)$ 是与有限尺寸模型和测量速率 $k_j(L)$ 完全一致的体相速率值。假设该模型是对系统的精确描述，则此过程可以完美地恢复真实的体相速率，即 $\\widehat{k}_j(\\infty) = k_j(\\infty)$。\n\n校正后的总速率是这些估计量的总和 $\\sum_j \\widehat{k}_j(\\infty)$。因此，恢复了体相动力学的校正后驻留时间由下式给出：\n$$\\Delta t_{\\text{corr}} = -\\frac{\\ln u}{\\sum_j \\widehat{k}_j(\\infty)}$$\n这种方法系统地消除了 KMC 时间步长计算中的有限尺寸偏差。实现过程将首先根据给定的体相参数计算 $k_j(L)$，然后使用该结果计算 $\\widehat{k}_j(\\infty)$，作为对校正方案的程序性验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 100.0,\n            \"u\": np.exp(-1),\n            \"events\": [\n                {\"k_inf\": 1.0, \"k_edge\": 0.8, \"ell\": 2.0, \"b\": 0.0},\n                {\"k_inf\": 0.5, \"k_edge\": 0.6, \"ell\": 1.0, \"b\": 0.0},\n                {\"k_inf\": 2.0, \"k_edge\": 1.7, \"ell\": 3.0, \"b\": 0.0},\n            ]\n        },\n        {\n            \"L\": 10.0,\n            \"u\": 0.5,\n            \"events\": [\n                {\"k_inf\": 3.0, \"k_edge\": 2.0, \"ell\": 2.0, \"b\": 0.1},\n                {\"k_inf\": 1.5, \"k_edge\": 2.5, \"ell\": 3.0, \"b\": -0.2},\n            ]\n        },\n        {\n            \"L\": 10000.0,\n            \"u\": 0.9,\n            \"events\": [\n                {\"k_inf\": 0.1, \"k_edge\": 0.1, \"ell\": 1.0, \"b\": 1e-4},\n                {\"k_inf\": 10.0, \"k_edge\": 9.5, \"ell\": 5.0, \"b\": -5e-4},\n            ]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        u = case[\"u\"]\n        events = case[\"events\"]\n        \n        scaled_biases = []\n        k_L_values = []\n        k_hat_inf_values = []\n        k_inf_values = []\n\n        for event in events:\n            k_inf = event[\"k_inf\"]\n            k_edge = event[\"k_edge\"]\n            ell = event[\"ell\"]\n            b = event[\"b\"]\n            \n            # Compute k_i(L) using the specified model.\n            k_L = (1 - 2 * ell / L) * k_inf + (2 * ell / L) * k_edge + b / L**2\n            k_L_values.append(k_L)\n            \n            # Compute the scaled finite-size bias vector.\n            scaled_bias = L * abs(k_L - k_inf)\n            scaled_biases.append(scaled_bias)\n\n            # Compute the estimated bulk rate k_hat_inf.\n            # This demonstrates the inversion of the model.\n            numerator = k_L - (2 * ell / L) * k_edge - b / L**2\n            denominator = 1 - 2 * ell / L\n            k_hat_inf = numerator / denominator if denominator != 0 else 0\n            k_hat_inf_values.append(k_hat_inf)\n            \n            # Store original k_inf for comparison and for the corrected sum.\n            k_inf_values.append(k_inf)\n\n        # Calculate total rates\n        sum_k_L = sum(k_L_values)\n        sum_k_hat_inf = sum(k_hat_inf_values)\n        \n        # Calculate uncorrected and corrected residence times\n        log_u = np.log(u)\n        delta_t = -log_u / sum_k_L if sum_k_L != 0 else float('inf')\n        delta_t_corr = -log_u / sum_k_hat_inf if sum_k_hat_inf != 0 else float('inf')\n\n        # Since k_hat_inf must equal k_inf if the model is exact, we can verify this.\n        # For calculation, using sum(k_inf_values) is numerically equivalent and\n        # more direct, but we follow the explicit instruction to sum the computed k_hat_inf.\n        # assert np.isclose(sum_k_hat_inf, sum(k_inf_values))\n\n        case_results = [scaled_biases, delta_t, delta_t_corr]\n        all_results.append(case_results)\n\n    def format_nested_list_to_string(lst):\n        \"\"\"Recursively formats a nested list into a string without spaces.\"\"\"\n        if isinstance(lst, list):\n            return f\"[{','.join(map(format_nested_list_to_string, lst))}]\"\n        else:\n            return repr(lst)\n\n    # Final print statement in the exact required format.\n    print(format_nested_list_to_string(all_results))\n\nsolve()\n```"
        },
        {
            "introduction": "为了将KMC方法的应用从理想化的晶格模型推广到更复杂的真实材料系统，我们必须解决如何识别和分类非晶格原子环境的挑战。本练习将引导您设计一个“正则键”，用于唯一地标识连续空间中的局部原子构型，该标识符在刚体运动（如平移和旋转）下保持不变。这项高级实践是构建适用于非晶材料、界面或复杂缺陷的离格KMC事件目录的关键一步，极大地扩展了该方法学的应用范围 ()。",
            "id": "3450014",
            "problem": "给定若干组三维原子位置，要求您为离格动力学蒙特卡洛 (KMC) 事件目录的构建实现一个规范化算法。该算法必须生成一个在任何刚性运动（平移、旋转或反射）下都保持不变的局部图键，然后使用该键通过驻留时间算法 (RTA) 计算驻留时间。您必须从欧几里得几何和随机过程基础的第一性原理出发推导此算法，并将其实现为一个完整的、可运行的程序。\n\n从以下基本原理开始：\n- 欧几里得等距变换保持成对距离和内积不变。具体而言，如果 $\\mathbf{R}$ 是一个满足 $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ 的正交矩阵，$\\mathbf{t}$ 是一个平移向量，那么对于任意位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，变换后的位置 $\\mathbf{x}_i' = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$ 满足 $\\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|_2 = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$ 以及对于一个选定的参考原子 $\\mathbf{x}_0$，满足 $(\\mathbf{x}_i' - \\mathbf{x}_0') \\cdot (\\mathbf{x}_j' - \\mathbf{x}_0') = (\\mathbf{x}_i - \\mathbf{x}_0) \\cdot (\\mathbf{x}_j - \\mathbf{x}_0)$。\n- 在具有独立指数时钟的连续时间马尔可夫过程中，到下一个事件的等待时间服从指数分布，其速率参数等于各个事件速率之和。如果事件 $i$ 的速率为 $k_i$，则驻留时间 $\\tau$ 满足 $\\tau = 1/\\sum_i k_i$。\n\n算法要求：\n- 从一组原子位置构建一个在任何刚性运动下都保持不变的规范局部图键。仅使用刚性运动下的不变量，即成对距离和从内积导出的角余弦。\n- 该规范键必须是局部环境的一个确定性函数，不依赖于原子的初始排序。为此，您必须使用排序后的不变量多重集。\n- 为确保数值稳定性和可复现性，在排序前，将所有成对距离四舍五入至 $10^{-6}$ $\\mathrm{\\AA}$ 的容差，并将所有角余弦四舍五入至 $10^{-6}$（无量纲）的容差。\n\n键构建规范：\n- 给定 $\\mathbb{R}^3$ 中的 $N$ 个原子位置 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 和一个指定的中心原子索引 $c$，定义集合 $S$ 为所提供位置中的所有原子（假设所提供的集合已经是局部邻域）。构建：\n    1. 所有成对距离 $\\{d_{ij}\\}_{1 \\le i  j \\le N}$ 的排序多重集，其中 $d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$，单位为 $\\mathrm{\\AA}$，四舍五入至 $10^{-6}$ 并按升序排序。\n    2. 在中心原子 $c$ 处的所有角余弦的排序多重集，为所有满足 $j \\ne c$、$k \\ne c$、$j  k$ 的无序邻居对 $(j,k)$ 定义为 $\\cos\\theta_{c;jk} = \\dfrac{(\\mathbf{x}_j - \\mathbf{x}_c) \\cdot (\\mathbf{x}_k - \\mathbf{x}_c)}{\\|\\mathbf{x}_j - \\mathbf{x}_c\\|_2 \\, \\|\\mathbf{x}_k - \\mathbf{x}_c\\|_2}$，四舍五入至 $10^{-6}$ 并按升序排序。如果 $c$ 的邻居少于两个，则此多重集为空。\n- 规范键是由这两个排序列表组成的有序对。此构造在平移、旋转和反射下保持不变，并且与输入顺序无关。\n\n驻留时间算法 (RTA) 规范：\n- 设事件目录将规范键映射到一个事件列表，每个事件由尝试频率 $\\nu_i$（单位 $\\mathrm{s}^{-1}$）和能垒 $E_i$（单位 $\\mathrm{eV}$）参数化。对于给定的温度 $T$（单位 $\\mathrm{K}$），通过阿伦尼乌斯关系定义速率 $k_i$ 为 $k_i = \\nu_i \\exp\\!\\left(-\\dfrac{E_i}{k_{\\mathrm{B}} T}\\right)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数（单位 $\\mathrm{eV}/\\mathrm{K}$）。驻留时间为 $\\tau = \\dfrac{1}{\\sum_i k_i}$（单位秒）。如果目录中没有该键对应的事件，则定义 $\\tau = +\\infty$。\n\n单位和数值要求：\n- 所有位置均以 $\\mathrm{\\AA}$ 为单位提供。\n- 距离必须以 $\\mathrm{\\AA}$ 为单位计算，并在使用前四舍五入至 $10^{-6}$。\n- 角余弦是无量纲的，并且在使用前必须四舍五入至 $10^{-6}$。\n- 温度单位必须为 $\\mathrm{K}$。\n- 尝试频率单位必须为 $\\mathrm{s}^{-1}$，能垒单位必须为 $\\mathrm{eV}$。\n- 最终的驻留时间以秒为单位，表示为浮点数，不带单位字符串。\n\n测试套件：\n实现您的程序以处理以下四个测试用例。对于每个测试用例，计算规范键，然后使用提供的事件目录计算驻留时间。程序必须按照下面指定的格式，在单行输出中生成所有测试用例的最终驻留时间。\n\n事件目录条目（键由应用于以下原型几何结构的算法定义）：\n- 对于与中心原子周围的方形平面邻域（原型如下所述）相对应的规范键，使用以下事件：\n    - 事件 $1$：$\\nu_1 = 1.00 \\times 10^{13} \\, \\mathrm{s}^{-1}$，$E_1 = 0.55 \\, \\mathrm{eV}$。\n    - 事件 $2$：$\\nu_2 = 8.00 \\times 10^{12} \\, \\mathrm{s}^{-1}$，$E_2 = 0.60 \\, \\mathrm{eV}$。\n    - 事件 $3$：$\\nu_3 = 2.50 \\times 10^{13} \\, \\mathrm{s}^{-1}$，$E_3 = 0.85 \\, \\mathrm{eV}$。\n- 对于与中心原子周围的等边三角形邻域（原型如下所述）相对应的规范键，使用以下事件：\n    - 事件 $1$：$\\nu_1 = 1.20 \\times 10^{13} \\, \\mathrm{s}^{-1}$，$E_1 = 0.50 \\, \\mathrm{eV}$。\n    - 事件 $2$：$\\nu_2 = 9.00 \\times 10^{12} \\, \\mathrm{s}^{-1}$，$E_2 = 0.70 \\, \\mathrm{eV}$。\n\n玻尔兹曼常数：\n- 使用 $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV}/\\mathrm{K}$。\n\n温度：\n- 对所有测试用例使用 $T = 300 \\, \\mathrm{K}$。\n\n用于定义目录键的原型几何结构：\n- 方形平面邻域（中心原子位于原点）：以 $\\mathrm{\\AA}$ 为单位的位置是 $\\mathbf{x}_c = (0, 0, 0)$，$\\mathbf{x}_1 = (1, 0, 0)$，$\\mathbf{x}_2 = (0, 1, 0)$，$\\mathbf{x}_3 = (-1, 0, 0)$，$\\mathbf{x}_4 = (0, -1, 0)$，中心索引为 $c = 0$。\n- 等边三角形邻域（中心原子位于原点）：以 $\\mathrm{\\AA}$ 为单位的位置是 $\\mathbf{x}_c = (0, 0, 0)$，$\\mathbf{x}_1 = (1, 0, 0)$，$\\mathbf{x}_2 = \\left(-\\dfrac{1}{2}, \\dfrac{\\sqrt{3}}{2}, 0\\right)$，$\\mathbf{x}_3 = \\left(-\\dfrac{1}{2}, -\\dfrac{\\sqrt{3}}{2}, 0\\right)$，中心索引为 $c = 0$。\n\n要处理的测试用例：\n- 测试用例 $1$（正常路径）：使用上述方形平面邻域，中心索引 $c = 0$，温度 $T = 300 \\, \\mathrm{K}$。\n- 测试用例 $2$（刚性运动不变性）：对测试用例 $1$ 的方形平面邻域应用绕 z 轴旋转角度 $\\theta = \\dfrac{\\pi}{6}$ 弧度的旋转，然后应用向量 $\\mathbf{t} = (2.5, -1.7, 0.3)$（单位 $\\mathrm{\\AA}$）的平移。使用中心索引 $c = 0$，温度 $T = 300 \\, \\mathrm{K}$。\n- 测试用例 $3$（不同环境）：使用上述等边三角形邻域，中心索引 $c = 0$，温度 $T = 300 \\, \\mathrm{K}$。\n- 测试用例 $4$（无事件的边界情况）：一个单个孤立原子，其位置为 $\\mathbf{x}_c = (2, 2, 2)$（单位 $\\mathrm{\\AA}$），中心索引 $c = 0$；没有邻居。使用温度 $T = 300 \\, \\mathrm{K}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试用例 $1$、$2$、$3$ 和 $4$ 的驻留时间，按此顺序排列，形式为用方括号括起来的逗号分隔列表。例如，输出应类似于 $[t_1, t_2, t_3, t_4]$，其中每个 $t_i$ 是以秒为单位的浮点数（不带单位字符串）。如果驻留时间为无穷大，则将其打印为浮点数无穷大。",
            "solution": "任务是构建一个局部原子环境的规范表示，该表示对刚性运动和原子置换保持不变，然后根据动力学蒙特卡洛 (KMC) 的驻留时间算法 (RTA) 使用此表示来计算系统在该状态下的驻留时间。该解决方案是从欧几里得几何和随机过程的第一性原理推导出来的。\n\n该问题被判定为有效。它在科学上基于计算材料科学的原理，在数学上是适定的、客观的，并为获得唯一的、可验证的解提供了所有必要信息。\n\n问题的核心在于两个部分：首先是规范键的设计，其次是在驻留时间算法中应用此键。\n\n**从第一性原理构建规范键**\n\n一个局部原子构型 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 的规范表示（或键）必须满足三个关键属性：平移不变性、旋转和反射不变性（合称刚性运动或等距变换），以及原子标签置换不变性。\n\n1.  **刚性运动不变性**：在欧几里得等距变换下保持不变的基本量是点与点之间的距离。给定任意两个原子位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，刚性运动将其变换为 $\\mathbf{x}_i' = \\mathbf{R}\\mathbf{x}_i + \\mathbf{t}$ 和 $\\mathbf{x}_j' = \\mathbf{R}\\mathbf{x}_j + \\mathbf{t}$，其中 $\\mathbf{R}$ 是一个正交矩阵（$\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$），$\\mathbf{t}$ 是一个平移向量。变换后两点间的距离为 $\\|\\mathbf{x}_i' - \\mathbf{x}_j'\\|_2 = \\|(\\mathbf{R}\\mathbf{x}_i + \\mathbf{t}) - (\\mathbf{R}\\mathbf{x}_j + \\mathbf{t})\\|_2 = \\|\\mathbf{R}(\\mathbf{x}_i - \\mathbf{x}_j)\\|_2$。由于正交矩阵保持范数不变，这等于 $\\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2$。因此，所有成对距离的集合 $\\{d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|_2\\}$（对于 $1 \\le i  j \\le N$）在任何刚性运动下都是不变的。这构成了我们键的第一个组成部分。\n\n2.  **不变性与局部结构**：虽然所有成对距离的集合构成了一个稳健的不变量，但通常需要包含相对于特定原子（指定为中心原子 $\\mathbf{x}_c$）的角度信息。从中心 $\\mathbf{x}_c$ 看，两个邻居 $\\mathbf{x}_j$ 和 $\\mathbf{x}_k$ 之间的夹角 $\\theta_{c;jk}$ 由位移向量 $\\mathbf{v}_j = \\mathbf{x}_j - \\mathbf{x}_c$ 和 $\\mathbf{v}_k = \\mathbf{x}_k - \\mathbf{x}_c$ 的内积决定。该夹角的余弦由 $\\cos\\theta_{c;jk} = \\frac{\\mathbf{v}_j \\cdot \\mathbf{v}_k}{\\|\\mathbf{v}_j\\|_2 \\|\\mathbf{v}_k\\|_2}$ 给出。位移向量本身是平移不变的。在旋转/反射下，它们变换为 $\\mathbf{v}_j' = \\mathbf{R}\\mathbf{v}_j$。内积保持不变：$\\mathbf{v}_j' \\cdot \\mathbf{v}_k' = (\\mathbf{R}\\mathbf{v}_j)^{\\top}(\\mathbf{R}\\mathbf{v}_k) = \\mathbf{v}_j^{\\top}\\mathbf{R}^{\\top}\\mathbf{R}\\mathbf{v}_k = \\mathbf{v}_j^{\\top}\\mathbf{I}\\mathbf{v}_k = \\mathbf{v}_j \\cdot \\mathbf{v}_k$。范数也保持不变，使得角余弦成为一个等距变换不变量。对于所有唯一的邻居对 $(j,k)$（其中 $j,k \\ne c$，并且我们可以取 $j  k$ 以避免重复），角余弦的集合也满足刚性运动不变性。\n\n3.  **置换不变性**：所提供原子位置的初始顺序是任意的。为了确保规范键独立于这种顺序，我们必须使用对顺序不敏感的构造。将距离和角余弦的集合（多重集）按数值大小进行排序，可以创建一个确定性的、与输入顺序无关的列表。\n\n因此，规范键被定义为由排序后的成对距离列表和排序后的中心角余弦列表组成的有序对。这是一个确定性的、对刚性运动和原子标签置换不变的函数，完全符合算法要求。\n\n**驻留时间算法 (RTA) 的应用**\n\nRTA 是 KMC 的核心。在一个给定的状态下，系统可以经历多个可能的转变（事件），每个事件 $i$ 都有一个速率 $k_i$。在连续时间马尔可夫过程中，每个事件都与一个独立的指数时钟相关联。系统在该状态下停留的时间，即驻留时间 $\\tau$，是所有这些指数时钟中最快的一个触发的时间。这个时间本身服从一个指数分布，其速率参数是所有单个事件速率的总和，$K = \\sum_i k_i$。问题要求计算驻留时间，并将其定义为 $\\tau = 1/K$。这对应于该指数分布的**平均驻留时间**，而不是从分布中随机抽取一个样本。\n\n对于给定的温度 $T$，每个事件的速率由阿伦尼乌斯关系 $k_i = \\nu_i \\exp(-E_i / k_{\\mathrm{B}}T)$ 给出，其中 $\\nu_i$ 是尝试频率，$E_i$ 是能垒，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n该算法的实现流程如下：\n1.  对于给定的原子构型，使用上述方法计算其规范键。\n2.  在事件目录中查找此键。\n3.  如果找到了键，则检索关联的事件列表（每个事件由 $(\\nu_i, E_i)$ 定义）。\n4.  使用阿伦尼乌斯公式和给定的温度 $T$ 计算每个事件的速率 $k_i$。\n5.  将所有速率相加得到总速率 $K = \\sum_i k_i$。\n6.  计算驻留时间 $\\tau = 1/K$。\n7.  如果目录中不存在该键，则没有已知的逃逸路径，总速率为零，驻留时间为无穷大。\n\n此过程将对每个测试用例执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Implements the canonicalization and residence-time algorithm for off-lattice KMC.\n    \"\"\"\n    \n    # Define constants and parameters from the problem statement.\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n    TEMPERATURE = 300.0          # Temperature in K\n    PRECISION = 6                # Decimal places for rounding\n\n    def generate_key(positions: np.ndarray, central_idx: int) - tuple:\n        \"\"\"\n        Generates a canonical key for a local atomic environment.\n\n        The key is invariant under translation, rotation, reflection, and\n        permutation of atom indices.\n\n        Args:\n            positions (np.ndarray): Array of atomic positions, shape (N, 3).\n            central_idx (int): Index of the central atom.\n\n        Returns:\n            tuple: A hashable canonical key (tuple of sorted distances, \n                   tuple of sorted angle cosines).\n        \"\"\"\n        num_atoms = positions.shape[0]\n\n        # 1. Compute the sorted multiset of all pairwise distances.\n        if num_atoms  2:\n            distances = []\n        else:\n            # pdist computes distances for i  j, which matches the problem spec.\n            distances = pdist(positions)\n        \n        rounded_distances = np.round(distances, PRECISION)\n        sorted_distances = tuple(np.sort(rounded_distances))\n\n        # 2. Compute the sorted multiset of all central angle cosines.\n        neighbor_indices = [i for i in range(num_atoms) if i != central_idx]\n        \n        cosines = []\n        if len(neighbor_indices) >= 2:\n            central_pos = positions[central_idx]\n            # Iterate through all unique pairs of neighbors.\n            for j, k in combinations(neighbor_indices, 2):\n                vec_j = positions[j] - central_pos\n                vec_k = positions[k] - central_pos\n                \n                norm_j = np.linalg.norm(vec_j)\n                norm_k = np.linalg.norm(vec_k)\n\n                # The problem guarantees environments where neighbors are distinct from the center,\n                # so norms will not be zero.\n                cos_theta = np.dot(vec_j, vec_k) / (norm_j * norm_k)\n                cosines.append(cos_theta)\n\n        rounded_cosines = np.round(cosines, PRECISION)\n        sorted_cosines = tuple(np.sort(rounded_cosines))\n\n        return (sorted_distances, sorted_cosines)\n\n    # --- Build Event Catalog ---\n    # Define prototype geometries to generate catalog keys.\n    square_planar_positions = np.array([\n        [0.0, 0.0, 0.0],  # central atom c=0\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0]\n    ])\n\n    equilateral_triangle_positions = np.array([\n        [0.0, 0.0, 0.0],  # central atom c=0\n        [1.0, 0.0, 0.0],\n        [-0.5, np.sqrt(3)/2, 0.0],\n        [-0.5, -np.sqrt(3)/2, 0.0]\n    ])\n\n    # Generate the keys for the prototypes.\n    square_key = generate_key(square_planar_positions, central_idx=0)\n    triangle_key = generate_key(equilateral_triangle_positions, central_idx=0)\n\n    # Define the event catalog.\n    event_catalog = {\n        square_key: [\n            (1.00e13, 0.55),  # (nu_i in s^-1, E_i in eV)\n            (8.00e12, 0.60),\n            (2.50e13, 0.85)\n        ],\n        triangle_key: [\n            (1.20e13, 0.50),\n            (9.00e12, 0.70)\n        ]\n    }\n\n    # --- Define Test Cases ---\n    \n    # Test Case 1: Square planar neighborhood\n    case1_positions = square_planar_positions\n    \n    # Test Case 2: Rotated and translated square planar neighborhood\n    theta = np.pi / 6\n    rotation_matrix = np.array([\n        [np.cos(theta), -np.sin(theta), 0.0],\n        [np.sin(theta),  np.cos(theta), 0.0],\n        [0.0,            0.0,           1.0]\n    ])\n    translation_vector = np.array([2.5, -1.7, 0.3])\n    case2_positions = (rotation_matrix @ square_planar_positions.T).T + translation_vector\n\n    # Test Case 3: Equilateral triangle neighborhood\n    case3_positions = equilateral_triangle_positions\n\n    # Test Case 4: Single isolated atom\n    case4_positions = np.array([[2.0, 2.0, 2.0]])\n\n    test_cases = [\n        # (positions, central_idx)\n        (case1_positions, 0),\n        (case2_positions, 0),\n        (case3_positions, 0),\n        (case4_positions, 0)\n    ]\n\n    results = []\n    kbt = KB_EV_K * TEMPERATURE\n\n    # --- Process Test Cases ---\n    for positions, central_idx in test_cases:\n        # Generate the key for the current configuration.\n        key = generate_key(positions, central_idx)\n        \n        # Look up events in the catalog.\n        events = event_catalog.get(key, [])\n        \n        # Calculate total rate.\n        total_rate = 0.0\n        for nu, E in events:\n            rate = nu * np.exp(-E / kbt)\n            total_rate += rate\n            \n        # Calculate residence time.\n        if total_rate == 0.0:\n            tau = float('inf')\n        else:\n            tau = 1.0 / total_rate\n        \n        results.append(tau)\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}