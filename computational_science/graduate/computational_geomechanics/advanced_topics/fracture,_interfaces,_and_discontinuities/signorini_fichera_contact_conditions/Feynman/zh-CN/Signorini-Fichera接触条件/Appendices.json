{
    "hands_on_practices": [
        {
            "introduction": "任何计算模型开发或应用的关键第一步都是用已知解对其进行验证。本实践将引导你完成一个基础的验证流程，针对一个简单的单边接触问题来验证有限元法（FEM）的实现。通过将罚函数法和Nitsche法的数值结果与推导出的解析解进行比较，你将获得评估算法精度和收敛率的第一手经验，这是计算工程师必备的核心技能。",
            "id": "3558634",
            "problem": "考虑在区间 $[0,L]$ 上的一维静态线性弹性杆，其杨氏模量为 $E$，横截面积为 $A$，单位长度上受到的均布体力为 $f_0$。未知位移场为沿杆轴线的 $u(x)$，单位为米。左端点 $x=0$ 处固定，因此 $u(0)=0$。右端点 $x=L$ 处与一个刚性挡块发生单边无摩擦接触，该挡块位于间隙为 $g$（单位为米）的位置。控制平衡方程为一维线性动量平衡方程 $-(E A u')' = f_0$（在 $(0,L)$ 上）以及在 $x=L$ 处的 Signorini-Fichera 接触条件：\n$$\nu(L) - g \\le 0,\\quad t(L) \\le 0,\\quad t(L)\\,\\big(u(L) - g\\big) = 0,\n$$\n其中 $t(L)$ 表示 $x=L$ 处的法向牵引力（压力取非正值）。\n\n您的任务是：\n- 推导出一个与 $-(E A u')' = f_0$、$u(0)=0$ 及 Signorini-Fichera 边界条件一致的解析分段解 $u(x)$。\n- 在有限元法（FEM）框架内，使用均匀网格上的连续分段线性基函数，构建并实现两种计算近似方法：\n  1. 罚函数法，通过在弱形式中增加一个依赖于罚参数 $\\alpha>0$ 的边界罚项来施加单边接触约束。\n  2. 对称 Nitsche 型稳定化方法，用于单边接触问题，它使用一个由 $x=L$ 处局部网格尺寸缩放的稳定化参数 $\\gamma>0$，在活动集上弱施加边界约束。\n- 对于每种方法，使用对最高二次多项式精确的高斯积分，计算近似位移场 $u_h(x)$ 以及在 $[0,L]$ 上以 $L^2$ 范数度量的位移误差，即 $\\lVert u - u_h \\rVert_{L^2(0,L)}$（单位为米）。\n- 将观测收敛率 $p$ 作为均匀网格尺寸 $h=L/N$（其中 $N$ 为单元数）的函数进行估计。假设误差与网格尺寸之间存在幂律关系 $\\lVert u - u_h \\rVert_{L^2} \\approx C h^p$（其中 $C>0$ 为某个常数），$p$ 定义为 $\\log(\\lVert u - u_h \\rVert_{L^2})$ 对 $\\log(h)$进行线性回归得到的斜率。\n\n实现一个完整的程序，该程序：\n- 使用分段线性单元和体力 $f_0$ 组装一维杆的标准刚度矩阵。\n- 在 $x=0$ 处强施加本质边界条件。\n- 通过首先计算无约束解并评估 $x=L$ 处的间隙条件来判断接触是活动的还是非活动的；如果接触是活动的，则仅在活动集上应用所选方法的边界项；如果接触是非活动的，则保持右边界为自然边界。\n- 在每个网格上通过单元级高斯积分计算 $L^2$ 误差。\n- 对每个测试用例，在多个网格尺寸下评估误差，并返回基于回归计算的罚函数法和 Nitsche 方法的收敛率 $p$。\n\n使用以下构成测试套件的科学上合理的参数值：\n- 所有测试的材料和几何参数：$L=1.0\\,\\mathrm{m}$，$E=30\\times 10^9\\,\\mathrm{Pa}$，$A=0.01\\,\\mathrm{m}^2$，均布体力 $f_0=1.0\\times 10^5\\,\\mathrm{N/m}$。\n- 每个测试的网格尺寸：$N\\in\\{10,20,40\\}$（因此 $h=L/N$）。\n- 测试用例 1（非活动接触，理想情况）：$g=2.0\\times 10^{-4}\\,\\mathrm{m}$，罚参数 $\\alpha=1.0\\times 10^9$，Nitsche 稳定化参数 $\\gamma=10.0$。\n- 测试用例 2（活动接触，中等间隙）：$g=1.0\\times 10^{-4}\\,\\mathrm{m}$，罚参数 $\\alpha=1.0\\times 10^7$，Nitsche 稳定化参数 $\\gamma=10.0$。\n- 测试用例 3（活动接触，边界处有刚性挡块）：$g=0.0\\,\\mathrm{m}$，罚参数 $\\alpha=1.0\\times 10^6$，Nitsche 稳定化参数 $\\gamma=10.0$。\n\n您的程序应生成单行输出，其中包含六个收敛率，格式为方括号内的逗号分隔列表，顺序为 $[p_{\\text{pen},1},p_{\\text{nit},1},p_{\\text{pen},2},p_{\\text{nit},2},p_{\\text{pen},3},p_{\\text{nit},3}]$，其中 $p_{\\text{pen},k}$ 和 $p_{\\text{nit},k}$ 分别对应测试用例 $k$ 的罚函数法和 Nitsche 方法。收敛率 $p$ 是无量纲浮点数。\n\n不允许用户输入；程序必须按原样运行，并为指定的测试套件精确计算这些量。",
            "solution": "用户希望求解一维线性弹性杆的单边接触问题，并分析两种不同有限元法（FEM）公式的收敛性：罚函数法和对称 Nitsche 法。\n\n### 步骤 1：解析解\n\n位移 $u(x)$ 的控制常微分方程（ODE）为 $-(E A u'(x))' = f_0$，其中 $E$、$A$ 和 $f_0$ 是常数。对 $x$ 积分两次，得到通解：\n$$\nu(x) = -\\frac{f_0}{2EA} x^2 + C_1 x + C_2\n$$\n积分常数 $C_1$ 和 $C_2$ 由边界条件确定。左端固定，即 $u(0)=0$，这意味着 $C_2=0$。\n$$\nu(x) = -\\frac{f_0}{2EA} x^2 + C_1 x\n$$\n右端点 $x=L$ 处需满足 Signorini-Fichera 条件：\n1.  $u(L) - g \\le 0$ (无穿透)\n2.  $t(L) \\le 0$ (压缩或零牵引力)，其中 $t(L) = E u'(L)$\n3.  $t(L)(u(L) - g) = 0$ (互补性)\n\n接触有两种可能的状态。\n\n**情况 1：非活动接触（间隙保持张开）**\n当杆在 $x=L$ 处为自由边界条件下未达到挡块时，发生此状态。自由边界意味着零牵引力，即 $t(L)=0$。\n$t(L) = E u'(L) = E \\left(-\\frac{f_0 L}{EA} + C_1\\right) = -\\frac{f_0 L}{A} + E C_1 = 0 \\implies C_1 = \\frac{f_0 L}{EA}$。\n位移场为 $u_{\\text{free}}(x) = \\frac{f_0}{EA} (Lx - \\frac{x^2}{2})$。\n端点位移为 $u_{\\text{free}}(L) = \\frac{f_0 L^2}{2EA}$。\n此解若满足 Signorini 条件则有效。$t(L)=0 \\le 0$ 已满足。互补条件已满足。无穿透条件 $u(L) \\le g$ 要求 $\\frac{f_0 L^2}{2EA} \\le g$。\n\n**情况 2：活动接触（间隙闭合）**\n如果自由端位移将超过间隙，即 $\\frac{f_0 L^2}{2EA} > g$，则发生此状态。在这种情况下，无穿透条件变为约束条件：$u(L)=g$。\n使用此条件求 $C_1$：\n$u(L) = g = -\\frac{f_0 L^2}{2EA} + C_1 L \\implies C_1 = \\frac{g}{L} + \\frac{f_0 L}{2EA}$。\n位移场为 $u(x) = \\left(\\frac{g}{L} + \\frac{f_0 L}{2EA}\\right)x - \\frac{f_0 x^2}{2EA}$。\n此解若 $t(L) \\le 0$ 则有效。\n$t(L) = E u'(L) = E \\left( \\frac{g}{L} + \\frac{f_0 L}{2EA} - \\frac{f_0 L}{EA} \\right) = \\frac{Eg}{L} - \\frac{f_0 L}{2A}$。\n条件 $t(L) \\le 0$ 等价于 $\\frac{Eg}{L} \\le \\frac{f_0 L}{2A}$，化简后为 $g \\le \\frac{f_0 L^2}{2EA}$，这证实了接触激活的条件。因为 $u(L)-g=0$，互补性得以满足。\n\n令 $u_{\\text{max}} = \\frac{f_0 L^2}{2EA}$。完整的解析解为：\n$$\nu(x) =\n\\begin{cases}\n    \\frac{f_0}{2EA}(2Lx - x^2)   \\text{if } g \\ge u_{\\text{max}} \\quad (\\text{非活动}) \\\\\n    \\frac{g}{L}x + \\frac{f_0}{2EA}(Lx - x^2)   \\text{if } g  u_{\\text{max}} \\quad (\\text{活动})\n\\end{cases}\n$$\n\n### 步骤 2：有限元弱形式\n\n起点是平衡方程的弱形式。对于一个满足 $v(0)=0$ 的测试函数 $v$：\n$$\n\\int_0^L EA u' v' dx = \\int_0^L f_0 v dx + T(L) v(L)\n$$\n其中 $T(L) = A t(L)$ 是接触处的反作用力。使用大小为 $h=L/N$ 的均匀网格上的分段线性单元进行离散化，我们得到一个代数方程组 $K\\mathbf{u} = \\mathbf{F}$。我们采用活动集策略：首先，在 $T(L)=0$（自然边界条件）下求解，得到 $u_h^{\\text{free}}$。如果 $u_h^{\\text{free}}(L) > g$，我们用接触约束重新求解该系统。\n\n**罚函数法（活动接触）**\n通过在总势能中增加一个罚能量项 $\\frac{1}{2}\\alpha(u(L)-g)^2$ 来近似单边约束，其中 $\\alpha \\gg 0$ 是一个罚参数。该项的变分在弱形式中增加了 $\\alpha (u(L)-g) v(L)$。这只修改了有限元系统的最后一个方程（对应于 $x=L$ 处的节点 $N$）。刚度矩阵项 $K_{NN}$ 和力向量项 $F_N$ 被修改为：\n$$\nK_{NN} \\to K_{NN} + \\alpha, \\quad F_N \\to F_N + \\alpha g\n$$\n\n**对称 Nitsche 法（活动接触）**\n此方法弱施加 Dirichlet 型条件 $u(L)=g$，而无需大的罚参数。它通过增加项来修改弱形式，以一种一致且稳定的方式施加约束。对称公式为：\n求 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$：\n$$\na_h(u_h, v_h) = \\ell_h(v_h)\n$$\n其中\n$$\na_h(u, v) = \\int_0^L EA u'v' dx - (EA u'(L))v(L) - (EA v'(L))u(L) + \\frac{\\gamma EA}{h} u(L)v(L)\n$$\n$$\n\\ell_h(v) = \\int_0^L f_0 v dx - (EA v'(L))g + \\frac{\\gamma EA}{h} gv(L)\n$$\n这里，$\\gamma>0$ 是一个无量纲稳定化参数。对于分段线性单元，导数 $u_h'(L)$ 和 $v_h'(L)$ 是最后一个单元 $[x_{N-1}, L]$ 上的常数导数。这些修改影响了有限元系统矩阵的最后两行和两列。在 $N \\times N$ 系统中（对于自由度 $u_1, ..., u_N$），由此产生的修改项是：\n$$\nK_{N-1, N} \\to 0, \\quad K_{N, N-1} \\to 0\n$$\n$$\nK_{N, N} \\to (\\gamma-1)\\frac{EA}{h}\n$$\n$$\nF_{N-1} \\to F_{N-1} + \\frac{EAg}{h}, \\quad F_{N} \\to F_{N} + (\\gamma-1)\\frac{EAg}{h}\n$$\n\n### 步骤 3：数值实现与收敛性分析\n\n程序为给定的测试用例实现这些步骤。\n1.  **组装**：为固定-自由杆组装标准的 $N \\times N$ 刚度矩阵和力向量。\n2.  **活动集**：计算无约束解以确定接触是否为活动的。\n3.  **求解**：如果接触是非活动的，则使用无约束解。如果是活动的，则将罚函数法或 Nitsche 方法的相应修改应用于矩阵和向量，然后再次求解系统。\n4.  **误差计算**：通过对使用两点高斯积分计算的单元贡献求和，来计算 $L^2$ 误差 $\\lVert u - u_h \\rVert_{L^2}$。\n5.  **收敛率**：在网格数 $N=10, 20, 40$ 的情况下计算误差。对误差与网格尺寸 $h$ 的对数-对数图进行线性回归。该线的斜率给出了观测到的收敛率 $p$。对所有三个测试用例的两种方法重复此过程。\n\n对于使用线性单元的这两种方法，预期的收敛率是 $p=2$，因为精确解是分段光滑的，并且误差是在 $L^2$ 范数下测量的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Solves a 1D unilateral contact problem for an elastic bar using FEM,\n    comparing penalty and Nitsche methods for convergence analysis.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    L = 1.0       # m\n    E = 30.0e9    # Pa\n    A = 0.01      # m^2\n    f0 = 1.0e5    # N/m\n    EA = E * A\n\n    # --- Test Cases ---\n    test_cases = [\n        {'g': 2.0e-4, 'alpha': 1.0e9, 'gamma': 10.0, 'id': '1 (inactive)'},\n        {'g': 1.0e-4, 'alpha': 1.0e7, 'gamma': 10.0, 'id': '2 (active)'},\n        {'g': 0.0,    'alpha': 1.0e6, 'gamma': 10.0, 'id': '3 (active)'},\n    ]\n    \n    mesh_Ns = [10, 20, 40]\n    all_rates = []\n\n    # --- Gaussian Quadrature (2-point) ---\n    gauss_points = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n    gauss_weights = np.array([1.0, 1.0])\n\n    # --- Analytical Solution ---\n    u_max_free = f0 * L**2 / (2 * EA)\n\n    def get_analytic_solution(g_val):\n        if g_val >= u_max_free: # Inactive contact\n            def u_exact(x):\n                return (f0 / (2 * EA)) * (2 * L * x - x**2)\n        else: # Active contact\n            def u_exact(x):\n                return (g_val / L) * x + (f0 / (2 * EA)) * (L * x - x**2)\n        return u_exact\n\n    for case in test_cases:\n        g = case['g']\n        alpha = case['alpha']\n        gamma = case['gamma']\n        \n        u_exact_func = get_analytic_solution(g)\n\n        for method in ['penalty', 'nitsche']:\n            h_values = []\n            l2_errors = []\n\n            for N in mesh_Ns:\n                h = L / N\n                nodes = np.linspace(0, L, N + 1)\n                \n                # Assemble system for unknown DOFs u_1, ..., u_N (size N x N)\n                K_unconstrained = np.zeros((N, N))\n                F_unconstrained = np.zeros(N)\n\n                # Stiffness matrix with natural BC at x=L\n                diag0 = np.full(N, 2 * EA / h)\n                diag1 = np.full(N - 1, -EA / h)\n                K_unconstrained += np.diag(diag0) + np.diag(diag1, k=1) + np.diag(diag1, k=-1)\n                K_unconstrained[N - 1, N - 1] = EA / h\n                \n                # Force vector\n                F_unconstrained[:] = f0 * h\n                F_unconstrained[N-1] = f0 * h / 2.0\n\n                # --- Active Set Strategy ---\n                u_free = solve_linear_system(K_unconstrained, F_unconstrained)\n                u_N_free = u_free[-1]\n                is_active = (u_N_free > g)\n\n                K, F = K_unconstrained.copy(), F_unconstrained.copy()\n                if is_active:\n                    if method == 'penalty':\n                        K[N-1, N-1] += alpha\n                        F[N-1] += alpha * g\n                    elif method == 'nitsche':\n                        # The modifications implement the derived symmetric Nitsche form\n                        F[N-2] += EA * g / h\n                        F[N-1] += (gamma - 1) * EA * g / h\n                        \n                        K[N-2, N-1] = 0.0\n                        K[N-1, N-2] = 0.0\n                        K[N-1, N-1] = (gamma-1) * EA / h\n\n                u_h_dofs = solve_linear_system(K, F)\n                # Full solution vector including the fixed DoF u_0 = 0\n                u_h_full = np.concatenate(([0.0], u_h_dofs))\n\n                # --- Error Calculation (L2 norm) ---\n                total_error_sq = 0.0\n                for i in range(N):\n                    elem_nodes = nodes[i:i+2]\n                    elem_dofs = u_h_full[i:i+2]\n                    \n                    x_gauss = elem_nodes[0] + (h / 2.0) * (1.0 + gauss_points)\n                    u_exact_vals = u_exact_func(x_gauss)\n                    \n                    shape_func_vals_at_gauss = 0.5 * np.array([1.0 - gauss_points, 1.0 + gauss_points])\n                    u_h_vals = elem_dofs @ shape_func_vals_at_gauss\n                    \n                    integrand = (u_exact_vals - u_h_vals)**2\n                    elem_error_sq = (h / 2.0) * np.sum(gauss_weights * integrand)\n                    total_error_sq += elem_error_sq\n                \n                l2_error = np.sqrt(total_error_sq)\n                h_values.append(h)\n                l2_errors.append(l2_error)\n            \n            # --- Convergence Rate Calculation ---\n            log_h = np.log(h_values)\n            log_err = np.log(l2_errors)\n            p, _ = np.polyfit(log_h, log_err, 1)\n            all_rates.append(p)\n\n    print(f\"[{','.join(f'{rate:.10f}' for rate in all_rates)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然罚函数法和主动集法很直观，但它们可能会遇到数值问题，如病态条件或收敛缓慢。本实践介绍了一种更先进、更强大的方法，即使用互补函数将非光滑的Signorini-Fichera条件重构为一个方程组。你将实现一个半光滑牛顿法，这是一种处理接触问题内在不可微性的前沿技术，从而构建出更稳健、更高效的求解器。",
            "id": "3558641",
            "problem": "考虑一个在计算岩土力学框架下建模的、弹性节点与刚性障碍物之间的单自由度、无摩擦、单边接触问题。令 $u \\in \\mathbb{R}$ 表示沿指向障碍物的内法线方向测量的节点位移，令 $k \\in \\mathbb{R}_{>0}$ 表示支撑的线性弹性刚度。令 $f \\in \\mathbb{R}$ 表示沿正方向施加的外部荷载，令 $\\lambda \\in \\mathbb{R}_{\\ge 0}$ 表示作用于节点上的法向接触压力（拉格朗日乘子）。令法向间隙函数为 $g(u) = c - u$，其中 $c \\in \\mathbb{R}$ 是初始间隙（当障碍物初始未接触节点时为正值）。Signorini-Fichera 接触条件将单边不可穿透性和接触压力非负性表示为 $g(u) \\ge 0$，$\\lambda \\ge 0$ 和 $g(u)\\,\\lambda = 0$。\n\n从以下基本出发点开始：\n- 准静态单自由度弹性系统的线性动量平衡：$k\\,u + \\lambda = f$。\n- Signorini-Fichera 互补条件：$g(u) \\ge 0$，$\\lambda \\ge 0$ 和 $g(u)\\,\\lambda = 0$。\n- 由 $\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$ 定义的 Fischer–Burmeister (FB) 函数 $\\phi:\\mathbb{R}\\times\\mathbb{R}\\to\\mathbb{R}$。\n\n你的任务是：\n1. 推导法向互补条件的半光滑重构，将 $0 \\le g(u) \\perp \\lambda \\ge 0$ 替换为单个方程 $\\phi(g(u),\\lambda) = 0$。将其与平衡方程结合，定义一个适用于牛顿类方法的残差映射 $R:\\mathbb{R}^2 \\to \\mathbb{R}^2$。不要先验地假设 FB 函数在原点处的可微性；而是使用半光滑分析的概念来论证你的残差及其广义导数。\n2. 通过计算 FB 函数在点 $(a,b) \\ne (0,0)$ 处的偏导数，并在点 $(a,b) = (0,0)$ 处选择 Clarke 次微分中的一个一致性元素，来推导一个适用于半光滑牛顿步的广义雅可比矩阵。\n3. 实现一个阻尼半光滑牛顿类求解器，该求解器在给定 $(k,c,f)$ 和初始猜测值 $(u_0,\\lambda_0)$ 的情况下，计算系统 $R(u,\\lambda) = 0$ 的近似解 $(u^\\star,\\lambda^\\star)$，当残差的欧几里得范数小于 $10^{-10}$ 或达到最大迭代次数 $50$ 次时终止。使用基于残差范数的简单回溯线搜索来促进全局收敛性。\n4. 对于下面的每个测试用例，使用 $(u_0,\\lambda_0) = (0,0)$ 运行求解器，并报告每个用例的三个无量纲数：$u^\\star$，$\\lambda^\\star$ 和最终残差的欧几里得范数 $\\lVert R(u^\\star,\\lambda^\\star) \\rVert_2$。本问题中所有量均为无量纲；所有输出均以无量纲数报告。\n\n使用以下测试套件，其选择覆盖了典型情况、主动接触情况、退化非光滑点和边界情况：\n- 测试用例 1（预期无接触）：$k = 1000$，$c = 0.15$，$f = 100$。\n- 测试用例 2（预期主动接触）：$k = 1000$，$c = 0.05$，$f = 400$。\n- 测试用例 3（在原点处退化）：$k = 1000$，$c = 0$，$f = 0$。\n- 测试用例 4（边界情况 $f = k\\,c$）：$k = 800$，$c = 0.2$，$f = 160$。\n\n你的程序必须：\n- 基于上述基础和指定的半光滑重构，从第一性原理出发实现残差 $R(u,\\lambda)$。\n- 通过在 $(a,b)=(0,0)$ 处进行有原则的选择，实现一个一致的广义雅可比矩阵。\n- 应用带有回溯线搜索的阻尼半光滑牛顿法，该方法将步长以 $1/2$ 的因子缩减，直到观察到残差范数的充分下降或达到 $2^{-20}$ 的最小步长。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的浮点数列表，顺序为 $[u_1^\\star,\\lambda_1^\\star,\\lVert R_1\\rVert_2, u_2^\\star,\\lambda_2^\\star,\\lVert R_2\\rVert_2, u_3^\\star,\\lambda_3^\\star,\\lVert R_3\\rVert_2, u_4^\\star,\\lambda_4^\\star,\\lVert R_4\\rVert_2]$，其中下标表示测试用例的索引。\n- 每个浮点数打印小数点后恰好 $10$ 位。",
            "solution": "该问题要求为单自由度单边接触问题构建并实现一个半光滑牛顿法。此过程涉及基于 Fischer-Burmeister 接触条件重构推导残差函数，计算相应的广义雅可比矩阵，并实现一个阻尼牛顿类求解器。\n\n### 步骤 1：半光滑重构与残差映射\n\n该力学系统由一组方程和不等式控制。节点的平衡由线性动量平衡描述：\n$$k\\,u + \\lambda = f$$\n其中 $k \\in \\mathbb{R}_{>0}$ 是刚度，$u \\in \\mathbb{R}$ 是位移，$\\lambda \\in \\mathbb{R}_{\\ge 0}$ 是接触压力（一个拉格朗日乘子），$f \\in \\mathbb{R}$ 是外部荷载。\n\n接触本身由 Signorini-Fichera 条件描述，这些条件强制了不可穿透性 ($g(u) \\ge 0$)、非拉伸接触压力 ($\\lambda \\ge 0$)，以及压力仅在间隙闭合时才存在的性质 ($g(u)\\,\\lambda=0$)。在间隙函数定义为 $g(u) = c - u$（其中 $c$ 是初始间隙）的情况下，这些条件可以简洁地表示为一个互补问题：\n$$0 \\le (c - u) \\perp \\lambda \\ge 0$$\n\n为数值求解该系统，我们使用 Fischer-Burmeister (FB) 函数 $\\phi: \\mathbb{R}\\times\\mathbb{R} \\to \\mathbb{R}$ 将非光滑的互补条件替换为单个等价的不可微方程，该函数定义为：\n$$\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$$\n性质 $\\phi(a,b) = 0$ 等价于互补条件 $0 \\le a \\perp b \\ge 0$。通过设置 $a = g(u) = c-u$ 和 $b = \\lambda$，我们将接触定律重构为单个方程：\n$$\\phi(c-u, \\lambda) = \\sqrt{(c-u)^2 + \\lambda^2} - (c-u) - \\lambda = 0$$\n\n将此方程与平衡方程结合，我们得到一个包含两个未知数 $(u, \\lambda)$ 的两个非线性方程组。我们定义一个残差映射 $R: \\mathbb{R}^2 \\to \\mathbb{R}^2$，使得解 $(u^\\star, \\lambda^\\star)$ 满足 $R(u^\\star, \\lambda^\\star) = 0$：\n$$R(u, \\lambda) = \\begin{pmatrix} R_1(u, \\lambda) \\\\ R_2(u, \\lambda) \\end{pmatrix} = \\begin{pmatrix} k\\,u + \\lambda - f \\\\ \\sqrt{(c-u)^2 + \\lambda^2} - c + u - \\lambda \\end{pmatrix}$$\n函数 $R(u, \\lambda)$ 处处连续，但由于平方根项的存在，在 $(c-u, \\lambda) = (0,0)$ 的点处不可微。然而，该函数是半光滑的，这允许使用一种局部超线性收敛的广义牛顿法。\n\n### 步骤 2：广义雅可比矩阵的推导\n\n求解 $R(x)=0$ 的半光滑牛顿法遵循迭代式 $x_{k+1} = x_k - V_k^{-1} R(x_k)$，其中 $x=(u, \\lambda)$，$V_k$ 是 $R$ 在 $x_k$ 处的广义雅可比矩阵（例如，Clarke 次微分 $\\partial_C R(x_k)$）中的一个元素。\n\n雅可比矩阵 $J_R$ 由 $R$ 的各分量的偏导数组成：\n$$J_R(u, \\lambda) = \\begin{pmatrix} \\frac{\\partial R_1}{\\partial u}  \\frac{\\partial R_1}{\\partial \\lambda} \\\\ \\frac{\\partial R_2}{\\partial u}  \\frac{\\partial R_2}{\\partial \\lambda} \\end{pmatrix}$$\n\n第一个分量 $R_1(u, \\lambda) = k\\,u + \\lambda - f$ 的导数很简单：\n$$\\frac{\\partial R_1}{\\partial u} = k, \\quad \\frac{\\partial R_1}{\\partial \\lambda} = 1$$\n\n对于第二个分量 $R_2(u, \\lambda) = \\phi(c-u, \\lambda)$，我们使用链式法则。对于任意点 $(c-u, \\lambda) \\ne (0,0)$，$\\phi(a,b)$ 的偏导数为：\n$$\\frac{\\partial \\phi}{\\partial a} = \\frac{a}{\\sqrt{a^2+b^2}} - 1, \\quad \\frac{\\partial \\phi}{\\partial b} = \\frac{b}{\\sqrt{a^2+b^2}} - 1$$\n应用链式法则，设 $a=c-u$ 和 $b=\\lambda$：\n$$\\frac{\\partial R_2}{\\partial u} = \\frac{\\partial \\phi}{\\partial a}\\frac{\\partial a}{\\partial u} = -\\frac{\\partial \\phi}{\\partial a} = 1 - \\frac{c-u}{\\sqrt{(c-u)^2+\\lambda^2}}$$\n$$\\frac{\\partial R_2}{\\partial \\lambda} = \\frac{\\partial \\phi}{\\partial b}\\frac{\\partial b}{\\partial \\lambda} = \\frac{\\partial \\phi}{\\partial b} = \\frac{\\lambda}{\\sqrt{(c-u)^2+\\lambda^2}} - 1$$\n令 $N = \\sqrt{(c-u)^2+\\lambda^2}$，则非奇异情况（$N > 0$）下的雅可比矩阵为：\n$$J_R(u, \\lambda) = \\begin{pmatrix} k  1 \\\\ 1 - \\frac{c-u}{N}  \\frac{\\lambda}{N} - 1 \\end{pmatrix} \\quad (\\text{对于 } (c-u, \\lambda) \\ne (0,0))$$\n\n在奇异点 $(c-u, \\lambda) = (0,0)$ 处，函数不可微。我们必须从广义雅可比矩阵中选择一个元素。在可行域（$a \\ge 0, b \\ge 0$）内，$\\phi(a,b)$ 在 $(0,0)$ 处的 Clarke 次微分是梯度极限点集的凸包，即 $\\{(\\cos\\theta-1, \\sin\\theta-1) | \\theta \\in [0, \\pi/2]\\}$。从此凸集中任取一个元素，对于半光滑牛顿法都是一个有效的选择。我们从 Bouligand（或 B-）次微分中选择一个有原则的元素，它对应于沿某条路径趋向奇异点时雅可比矩阵的极限。取沿“主动接触”路径（$(u_k, \\lambda_k) \\to (c, 0)$，其中 $u_k=c$ 且 $\\lambda_k \\to 0^+$）的极限，得到：\n$$\\lim_{\\lambda \\to 0^+} \\nabla_x R_2(c, \\lambda) = \\lim_{\\lambda \\to 0^+} \\left(1, \\frac{\\lambda}{|\\lambda|}-1 \\right) = (1, 0)$$\n这导致在奇异点 $(u,\\lambda)=(c,0)$ 处，我们对广义雅可比矩阵做出如下选择：\n$$V(c, 0) = \\begin{pmatrix} k  1 \\\\ 1  0 \\end{pmatrix}$$\n对于 $k>0$，该矩阵是可逆的，确保了牛顿步是良定义的。\n\n### 步骤 3：算法设计：阻尼半光滑牛顿法\n\n求解器实现了一个阻尼半光滑 Newton-Raphson 算法来寻找 $R(u,\\lambda)=0$ 的根。令 $x_k = (u_k, \\lambda_k)^T$ 为第 $k$ 次迭代时的未知数向量。\n\n算法按以下步骤进行，对于 $k=0, 1, 2, \\ldots$：\n1.  **初始化**：从一个初始猜测值 $x_0 = (u_0, \\lambda_0) = (0,0)$ 开始。\n2.  **终止检查**：计算残差 $R_k = R(x_k)$。如果其欧几里得范数 $\\lVert R_k \\rVert_2$ 小于容差 $\\epsilon = 10^{-10}$，或者达到了最大迭代次数（$50$），则算法终止。\n3.  **牛顿步计算**：\n    a.  使用上面推导的表达式组装广义雅可比矩阵 $V_k = V(x_k)$。使用一个小的数值容差来区分奇异情况和常规情况。\n    b.  求解线性系统 $V_k \\Delta x_k = -R_k$ 以获得搜索方向 $\\Delta x_k = (\\Delta u_k, \\Delta \\lambda_k)^T$。\n4.  **线搜索**：为促进全局收敛，使用回溯线搜索来寻找一个合适的步长 $\\alpha_k \\in (0, 1]$。\n    a.  从完整步长 $\\alpha = 1$ 开始。\n    b.  计算试探点 $x_{trial} = x_k + \\alpha \\Delta x_k$。\n    c.  评估试探点处的残差范数 $\\lVert R(x_{trial}) \\rVert_2$。\n    d.  如果 $\\lVert R(x_{trial}) \\rVert_2  \\lVert R_k \\rVert_2$，则接受该步长（$\\alpha_k = \\alpha$）。\n    e.  否则，减小步长（$\\alpha \\leftarrow \\alpha/2$）并重复检查。此过程持续进行，直到观察到充分下降或步长低于最小阈值 $\\alpha_{min} = 2^{-20}$。\n5.  **更新**：更新解：$x_{k+1} = x_k + \\alpha_k \\Delta x_k$。\n最终输出包括收敛解 $(u^\\star, \\lambda^\\star)$ 和最终残差范数 $\\lVert R(u^\\star, \\lambda^\\star) \\rVert_2$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the series of contact problems and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        (1000.0, 0.15, 100.0),  # Case 1: No contact expected\n        (1000.0, 0.05, 400.0),  # Case 2: Active contact expected\n        (1000.0, 0.0, 0.0),     # Case 3: Degenerate at the origin\n        (800.0, 0.2, 160.0),   # Case 4: Boundary case f = k*c\n    ]\n\n    results = []\n    for k, c, f in test_cases:\n        u_star, lambda_star, final_residual_norm = run_solver(k, c, f)\n        results.extend([u_star, lambda_star, final_residual_norm])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.10f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef run_solver(k, c, f, u0=0.0, lam0=0.0, max_iter=50, tol=1e-10, min_alpha=2**-20):\n    \"\"\"\n    Implements a damped semismooth Newton solver for the unilateral contact problem.\n\n    Args:\n        k (float): Stiffness coefficient.\n        c (float): Initial clearance.\n        f (float): Applied external load.\n        u0 (float): Initial guess for displacement.\n        lam0 (float): Initial guess for contact pressure.\n        max_iter (int): Maximum number of iterations.\n        tol (float): Convergence tolerance for the residual norm.\n        min_alpha (float): Minimum step size for the line search.\n\n    Returns:\n        tuple: A tuple containing the final displacement (u), contact pressure (lam),\n               and the Euclidean norm of the final residual.\n    \"\"\"\n    u, lam = u0, lam0\n    \n    # Small tolerance for checking singularity in Jacobian\n    jac_tol = 1e-12\n\n    for _ in range(max_iter):\n        # 1. Compute Residual R(u, lam)\n        gap = c - u\n        \n        # Fischer-Burmeister part of the residual\n        norm_val = np.sqrt(gap**2 + lam**2)\n        r1 = k * u + lam - f\n        r2 = norm_val - gap - lam\n        \n        R_vec = np.array([r1, r2])\n        res_norm = np.linalg.norm(R_vec)\n\n        # 2. Check for convergence\n        if res_norm  tol:\n            break\n\n        # 3. Compute Generalized Jacobian J(u, lam)\n        J = np.zeros((2, 2))\n        J[0, 0] = k\n        J[0, 1] = 1.0\n\n        if norm_val > jac_tol:\n            # Regular case (not at the non-differentiable point)\n            J[1, 0] = 1.0 - gap / norm_val\n            J[1, 1] = lam / norm_val - 1.0\n        else:\n            # Singular case: (c-u, lam) = (0,0). Use an element from the B-subdifferential.\n            # This choice corresponds to the limit from the active contact side.\n            J[1, 0] = 1.0\n            J[1, 1] = 0.0\n\n        # 4. Solve the linear system J * delta_x = -R for the Newton step\n        try:\n            delta_x = np.linalg.solve(J, -R_vec)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, can't proceed with this step\n            break\n\n        # 5. Backtracking Line Search\n        alpha = 1.0\n        while alpha > min_alpha:\n            u_new = u + alpha * delta_x[0]\n            lam_new = lam + alpha * delta_x[1]\n            \n            # Evaluate residual at the new trial point\n            gap_new = c - u_new\n            norm_val_new = np.sqrt(gap_new**2 + lam_new**2)\n            r1_new = k * u_new + lam_new - f\n            r2_new = norm_val_new - gap_new - lam_new\n            \n            res_norm_new = np.linalg.norm([r1_new, r2_new])\n            \n            # Check for sufficient decrease\n            if res_norm_new  res_norm:\n                break\n            \n            # Reduce step size\n            alpha /= 2.0\n        \n        if alpha = min_alpha and res_norm_new >= res_norm:\n             # Line search failed to find a better point, stop iterating\n             break\n\n        # 6. Update solution\n        u = u + alpha * delta_x[0]\n        lam = lam + alpha * delta_x[1]\n\n    # Evaluate final residual at the returned point\n    final_gap = c - u\n    final_norm_val = np.sqrt(final_gap**2 + lam**2)\n    final_r1 = k * u + lam - f\n    final_r2 = final_norm_val - final_gap - lam\n    final_res_norm = np.linalg.norm([final_r1, final_r2])\n\n    return u, lam, final_res_norm\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "接触力学原理是解决现实世界中岩土力学问题的基础。本实践将法向接触的概念扩展到一个更复杂的场景：岩石节理上的摩擦滑移，并引入了摩擦各向异性和剪胀等实际效应。你将学习如何使用模拟实验数据来标定一个复杂的接触模型，并利用该模型预测节理的行为，从而将抽象理论与岩土工程实践联系起来。",
            "id": "3558632",
            "problem": "考虑一个承受单边接触和摩擦滑动的平面岩石节理。法向接触遵循 Signorini-Fichera 条件：法向间隙 $g_n$ 和法向接触压力 $p_n$ 满足 $g_n \\ge 0$，$p_n \\ge 0$ 且 $g_n \\, p_n = 0$。由于节理粗糙度，切向（剪切）行为是各向异性的。假设，在给定的法向压缩应力 $\\sigma_n$（以 $\\mathrm{MPa}$ 为单位）下，容许的切向牵引矢量 $\\boldsymbol{t}_t = \\tau \\, \\boldsymbol{s}$（其中 $\\tau \\ge 0$ 是剪切量值，$\\boldsymbol{s} = [\\cos \\varphi, \\sin \\varphi]^\\top$ 是实验室坐标系中滑移方向的单位矢量，角度为 $\\varphi$（单位为度））受材料坐标系中的一个凸椭圆摩擦不等式约束。在主粗糙度方向上，摩擦系数为 $\\mu_1$ 和 $\\mu_2$（无量纲），且材料坐标系相对于实验室坐标系旋转了一个角度 $\\theta_0$（单位为度）。容许集为椭圆内部\n$$\\left(\\frac{t_1}{\\mu_1 \\, \\sigma_n}\\right)^2 + \\left(\\frac{t_2}{\\mu_2 \\, \\sigma_n}\\right)^2 \\le 1,$$\n其中 $[t_1, t_2]^\\top$ 是 $\\boldsymbol{t}_t$ 在材料坐标系中的分量。Signorini-Fichera 摩擦互补性通过各向异性屈服函数 $F(\\boldsymbol{t}_t, \\sigma_n) \\le 0$、一个用于滑动的拉格朗日乘子 $\\lambda_s \\ge 0$ 以及 $\\lambda_s \\, F = 0$ 的 Kuhn-Tucker 条件来强制执行。\n\n从上述基本原理出发，推导在给定法向应力 $\\sigma_n$ 下沿给定实验室剪切方向 $\\varphi$ 的剪切强度包络线，并证明最大容许剪切量值 $\\,\\tau_{\\max}(\\varphi, \\sigma_n)\\,$ 可以通过将方向 $\\boldsymbol{s}$ 变换到材料坐标系并计算椭圆来表示为 $\\mu_1$、$\\mu_2$ 和 $\\theta_0$ 的函数。然后，通过最小化一组给定的直剪试验中测得的峰值剪应力与推导出的 $\\tau_{\\max}$ 之间的残差平方和，来标定各向异性摩擦参数 $(\\mu_1, \\mu_2, \\theta_0)$。标定后，通过两种方式验证接触模型：通过检查相对于标定椭圆的容许性和互补性，将给定的试验状态分类为粘滞或滑动；以及使用一个非关联流动法则来预测剪胀角，其中剪胀取决于法向应力和各向异性。\n\n下方输入数据中的所有角度均以度为单位。所有应力均以 $\\mathrm{MPa}$ 为单位。您的程序必须遵循以下任务和测试套件。您计算的任何角度在最终输出中都必须以度表示，并按指定要求四舍五入。\n\n任务A. 从直剪数据标定参数：\n- 从上述基于互补性的接触模型和椭圆各向异性摩擦定律出发。基于材料坐标系中椭圆的几何形状和 $\\theta_0$ 的旋转，推导 $\\tau_{\\max}(\\varphi, \\sigma_n)$ 的表达式。\n- 使用非线性最小二乘法，根据以下在恒定法向应力下测得的峰值剪应力来标定 $(\\mu_1, \\mu_2, \\theta_0)$。使用惯例，即在实验室坐标系中，单位滑移方向为 $\\boldsymbol{s} = [\\cos \\varphi, \\sin \\varphi]^\\top$，材料坐标系通过旋转 $\\theta_0$ 得到。\n\n标定数据集 A（每个元组为 $(\\varphi, \\sigma_n, \\tau_{\\text{meas}})$）：\n- $(0, 2, 2.000000)$, $(0, 5, 5.000000)$, $(0, 10, 10.000000)$\n- $(45, 2, 1.264911)$, $(45, 5, 3.162278)$, $(45, 10, 6.324555)$\n- $(90, 2, 1.000000)$, $(90, 5, 2.500000)$, $(90, 10, 5.000000)$\n\n报告标定后的 $\\mu_1$ 和 $\\mu_2$（无量纲），保留三位小数，以及 $\\theta_0$（单位为度），保留两位小数。\n\n任务B. 通过 Signorini-Fichera 不等式进行粘滞与滑动分类：\n- 对于以下每个试验状态，使用从数据集 A 标定的参数来确定状态是滑动（布尔值 true）还是粘滞（布尔值 false）。使用带各向异性椭圆的 Signorini-Fichera 容许性条件；如果试验剪切量值 $\\tau_{\\text{trial}}$ 违反了容许集或恰好位于其边界上，则声明为“滑动”；如果它严格位于容许集内部，则声明为“粘滞”。\n\n分类测试状态（每个元组为 $(\\varphi, \\sigma_n, \\tau_{\\text{trial}})$）：\n- $(45, 5, 3.500000)$\n- $(90, 5, 2.200000)$\n- $(0, 2, 2.000000)$\n\n按此顺序输出三个布尔值。\n\n任务C. 不同法向应力下的剪胀预测：\n- 假设一个非关联流动，其中塑性法向滑移增量 $d\\delta_n$ 和塑性切向滑移增量 $d\\delta_t$ 满足 $d\\delta_n/d\\delta_t = \\tan \\psi$，其中剪胀角 $\\psi$ 取决于各向异性和法向应力，如下所示：\n$$ \\tan \\psi(\\varphi, \\sigma_n) = \\gamma \\, \\mu_{\\mathrm{eff}}(\\varphi) \\, \\frac{\\sigma_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}} + \\sigma_n}, $$\n其中 $\\gamma$ 是一个无量纲常数，$\\sigma_{\\mathrm{ref}} > 0$（单位为 $\\mathrm{MPa}$），$\\mu_{\\mathrm{eff}}(\\varphi)$ 是您从椭圆和旋转推导出的方向有效摩擦系数。使用 $\\gamma = 1.2$ 和 $\\sigma_{\\mathrm{ref}} = 5.0$。\n- 使用从数据集 A 标定的参数，计算以下情况的 $\\psi$（单位为度），并将每个结果保留两位小数：\n    - $(\\varphi, \\sigma_n) = (0, 2)$\n    - $(\\varphi, \\sigma_n) = (45, 5)$\n    - $(\\varphi, \\sigma_n) = (90, 10)$\n\n任务D. 近各向同性边缘情况：\n- 使用相同的最小二乘法程序，从以下近各向同性的数据集 B 中标定 $(\\mu_1, \\mu_2, \\theta_0)$。报告定义为 $\\mu_{\\max}/\\mu_{\\min}$ 的各向异性比，保留三位小数。\n\n标定数据集 B（每个元组为 $(\\varphi, \\sigma_n, \\tau_{\\text{meas}})$）：\n- $(0, 3, 2.400000)$, $(0, 6, 4.800000)$\n- $(45, 3, 2.371137)$, $(45, 6, 4.742274)$\n- $(90, 3, 2.340000)$, $(90, 6, 4.680000)$\n\n任务E. 法向互补性检查：\n- 对于下面的每对 $(g_n, p_n)$，在数值上合理的容差范围内验证 Signorini-Fichera 法向接触条件 $g_n \\ge 0$，$p_n \\ge 0$ 和 $g_n \\, p_n = 0$；输出一个布尔值，当且仅当这三个条件都成立时为 true。使用的容差为：如果一个乘积的绝对值小于 $10^{-9}$，则认为其为零。\n\n法向测试对 $(g_n, p_n)$（单位：$g_n$ 为 $\\mathrm{m}$，$p_n$ 为 $\\mathrm{MPa}$）：\n- $(0, 5)$\n- $(0.001, 0)$\n- $(0.001, 2)$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序包含：\n    - $\\mu_1$（数据集 A，保留三位小数），\n    - $\\mu_2$（数据集 A，保留三位小数），\n    - $\\theta_0$，单位为度（数据集 A，保留两位小数），\n    - 任务 B 的三个布尔值，按给定顺序，\n    - 任务 C 的三个剪胀角，单位为度，每个保留两位小数，\n    - 数据集 B 的各向异性比 $\\mu_{\\max}/\\mu_{\\min}$（保留三位小数），\n    - 任务 E 的三个布尔值，按给定顺序。\n- 角度必须以度为单位。应力必须按提供的方式在内部以 $\\mathrm{MPa}$ 处理。最终输出必须打印为单行，例如：$[\\mu_1,\\mu_2,\\theta_0,\\text{bool}_1,\\text{bool}_2,\\text{bool}_3,\\psi_1,\\psi_2,\\psi_3,\\text{ratio},\\text{bool}_4,\\text{bool}_5,\\text{bool}_6]$。",
            "solution": "该问题要求对平面岩石节理上的各向异性摩擦接触进行分析，该接触受法向接触的 Signorini-Fichera 条件和切向滑动的椭圆屈服准则控制。分析涉及多个任务：推导剪切强度表达式、从实验数据标定模型参数、分类接触状态以及预测剪胀等附带现象。\n\n此问题的理论基础在于连续介质力学，特别是在接触力学和塑性理论领域。法向接触由互补性条件 $g_n \\ge 0$、$p_n \\ge 0$ 和 $g_n p_n = 0$ 描述，其中 $g_n$ 是法向间隙，$p_n$ 是法向接触压力。这些是经典的 Signorini-Fichera 条件，适用于非穿透、非粘附的界面。切向行为使用各向异性摩擦定律建模，这是一个来自塑性理论的概念，其中（应力空间中的）屈服面不是各向同性的。\n\n分析工作的核心是推导在实验室坐标系中沿给定方向的剪切强度 $\\tau_{\\max}$。这需要进行坐标变换。实验室坐标系是实验的参考坐标系，其中滑移方向由角度 $\\varphi$ 定义。材料坐标系与节理表面粗糙度的主方向对齐，相对于实验室坐标系旋转了一个角度 $\\theta_0$。\n\n一个在实验室坐标系中分量为 $[v_x, v_y]^\\top$ 的牵引矢量 $\\boldsymbol{v}$，在材料坐标系中的分量 $[v_1, v_2]^\\top$ 由以下旋转给出：\n$$\n\\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix} = \\mathbf{R}(-\\theta_0) \\begin{pmatrix} v_x \\\\ v_y \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta_0  \\sin\\theta_0 \\\\ -\\sin\\theta_0  \\cos\\theta_0 \\end{pmatrix} \\begin{pmatrix} v_x \\\\ v_y \\end{pmatrix}\n$$\n实验室坐标系中的剪切牵引矢量为 $\\boldsymbol{t}_t = [\\tau \\cos\\varphi, \\tau \\sin\\varphi]^\\top$。应用该变换，其在材料坐标系中的分量为：\n$$\nt_1 = \\tau (\\cos\\varphi \\cos\\theta_0 + \\sin\\varphi \\sin\\theta_0) = \\tau \\cos(\\varphi - \\theta_0)\n$$\n$$\nt_2 = \\tau (-\\cos\\varphi \\sin\\theta_0 + \\sin\\varphi \\cos\\theta_0) = \\tau \\sin(\\varphi - \\theta_0)\n$$\n切向牵引的容许集由材料坐标系中的椭圆不等式定义：\n$$\nF(\\boldsymbol{t}_t, \\sigma_n) = \\left(\\frac{t_1}{\\mu_1 \\sigma_n}\\right)^2 + \\left(\\frac{t_2}{\\mu_2 \\sigma_n}\\right)^2 - 1 \\le 0\n$$\n其中 $\\mu_1$ 和 $\\mu_2$ 是主摩擦系数，$\\sigma_n$ 是施加的法向应力。当屈服函数 $F=0$ 时发生滑动。通过代入 $t_1$ 和 $t_2$ 的表达式并设 $\\tau = \\tau_{\\max}$，我们得到剪切强度的条件：\n$$\n\\left(\\frac{\\tau_{\\max} \\cos(\\varphi - \\theta_0)}{\\mu_1 \\sigma_n}\\right)^2 + \\left(\\frac{\\tau_{\\max} \\sin(\\varphi - \\theta_0)}{\\mu_2 \\sigma_n}\\right)^2 = 1\n$$\n解出 $\\tau_{\\max}$ 得到剪切强度包络线的表达式：\n$$\n\\tau_{\\max}(\\varphi, \\sigma_n) = \\sigma_n \\left[ \\frac{\\cos^2(\\varphi - \\theta_0)}{\\mu_1^2} + \\frac{\\sin^2(\\varphi - \\theta_0)}{\\mu_2^2} \\right]^{-1/2}\n$$\n则方向有效摩擦系数为 $\\mu_{\\text{eff}}(\\varphi) = \\tau_{\\max}(\\varphi, \\sigma_n) / \\sigma_n$。\n\n在此基础上，按如下方式执行任务：\n\n**任务A：参数标定。** 通过最小化测量的剪切强度 $\\tau_{\\text{meas}}$ 与模型预测值 $\\tau_{\\max}$ 之间的残差平方和（SSR），来标定参数 $(\\mu_1, \\mu_2, \\theta_0)$。\n$$\n\\text{SSR}(\\mu_1, \\mu_2, \\theta_0) = \\sum_{i} \\left( \\tau_{\\text{meas}, i} - \\tau_{\\max}(\\varphi_i, \\sigma_{n,i}; \\mu_1, \\mu_2, \\theta_0) \\right)^2\n$$\n这是一个非线性最小二乘问题，将对提供的数据集A进行数值求解。\n\n**任务B：粘滞与滑动分类。** 使用任务A中标定的参数，为每个试验状态计算剪切强度 $\\tau_{\\max}$。如果试验剪应力 $\\tau_{\\text{trial}}$ 大于或等于强度，即 $\\tau_{\\text{trial}} \\ge \\tau_{\\max}$，则状态分类为“滑动”；如果严格小于强度，即 $\\tau_{\\text{trial}}  \\tau_{\\max}$，则分类为“粘滞”。\n\n**任务C：剪胀预测。** 使用给定的非关联流动法则计算剪胀角 $\\psi$。首先，使用标定的参数计算有效摩擦系数 $\\mu_{\\text{eff}}(\\varphi)$。然后，应用公式：\n$$\n\\tan \\psi(\\varphi, \\sigma_n) = \\gamma \\, \\mu_{\\mathrm{eff}}(\\varphi) \\, \\frac{\\sigma_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}} + \\sigma_n}\n$$\n通过取该值的反正切来获得角度 $\\psi$。\n\n**任务D：近各向同性边缘情况。** 对数据集B重复任务A中的标定过程。然后根据得到的标定主摩擦系数 $\\mu_{1,B}$ 和 $\\mu_{2,B}$ 计算各向异性比，即 $\\mu_{\\max}/\\mu_{\\min} = \\max(\\mu_{1,B}, \\mu_{2,B}) / \\min(\\mu_{1,B}, \\mu_{2,B})$。\n\n**任务E：法向互补性检查。** 每对法向间隙 $g_n$ 和法向压力 $p_n$ 都根据三个 Signorini-Fichera 条件进行评估：$g_n \\ge 0$、$p_n \\ge 0$ 以及互补性乘积 $|g_n \\cdot p_n|  10^{-9}$。布尔值 true 表示所有三个条件都满足。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a multi-part problem in computational geomechanics involving\n    anisotropic friction, contact mechanics, and parameter calibration.\n    \"\"\"\n\n    # --- Model Functions ---\n\n    def get_tau_max(params, phi_deg, sigma_n):\n        \"\"\"Calculates the maximum admissible shear stress (shear strength).\"\"\"\n        mu1, mu2, theta0_deg = params\n        phi_rad = np.deg2rad(phi_deg)\n        theta0_rad = np.deg2rad(theta0_deg)\n\n        term1 = (np.cos(phi_rad - theta0_rad) / mu1)**2\n        term2 = (np.sin(phi_rad - theta0_rad) / mu2)**2\n        if term1 + term2 == 0:\n            return 0.0\n        \n        mu_eff = 1.0 / np.sqrt(term1 + term2)\n        return sigma_n * mu_eff\n\n    def ssr_objective(params, data):\n        \"\"\"Sum of Squared Residuals objective function for optimization.\"\"\"\n        mu1, mu2, theta0_deg = params\n        if mu1 = 0 or mu2 = 0:\n            return np.inf  # Enforce positive friction coefficients\n        \n        residuals = []\n        for phi_deg, sigma_n, tau_meas in data:\n            tau_pred = get_tau_max(params, phi_deg, sigma_n)\n            residuals.append((tau_pred - tau_meas)**2)\n        return np.sum(residuals)\n\n    # --- Task A: Parameter calibration from direct-shear data ---\n\n    calibration_data_A = [\n        (0, 2, 2.000000), (0, 5, 5.000000), (0, 10, 10.000000),\n        (45, 2, 1.264911), (45, 5, 3.162278), (45, 10, 6.324555),\n        (90, 2, 1.000000), (90, 5, 2.500000), (90, 10, 5.000000)\n    ]\n    \n    initial_guess_A = [1.0, 0.5, 0.0]\n    bounds_A = [(1e-6, None), (1e-6, None), (-90, 90)]\n    \n    result_A = minimize(\n        ssr_objective,\n        initial_guess_A,\n        args=(calibration_data_A,),\n        method='L-BFGS-B',\n        bounds=bounds_A\n    )\n    \n    mu1_A, mu2_A, theta0_A = result_A.x\n    calibrated_params_A = [mu1_A, mu2_A, theta0_A]\n\n    # --- Task B: Stick-versus-sliding classification ---\n\n    classification_states = [\n        (45, 5, 3.500000),\n        (90, 5, 2.200000),\n        (0, 2, 2.000000)\n    ]\n    \n    classif_results = []\n    for phi_deg, sigma_n, tau_trial in classification_states:\n        tau_lim = get_tau_max(calibrated_params_A, phi_deg, sigma_n)\n        is_sliding = tau_trial >= tau_lim\n        classif_results.append(is_sliding)\n\n    # --- Task C: Dilation prediction ---\n    \n    def get_dilation_angle(params, phi_deg, sigma_n, gamma, sigma_ref):\n        \"\"\"Computes the dilation angle psi in degrees.\"\"\"\n        mu1, mu2, theta0_deg = params\n        tau_lim = get_tau_max(params, phi_deg, sigma_n)\n        if sigma_n == 0:\n            mu_eff = 0\n        else:\n            mu_eff = tau_lim / sigma_n\n        \n        tan_psi = gamma * mu_eff * (sigma_ref / (sigma_ref + sigma_n))\n        psi_rad = np.arctan(tan_psi)\n        return np.rad2deg(psi_rad)\n\n    dilation_cases = [\n        (0, 2),\n        (45, 5),\n        (90, 10)\n    ]\n    gamma = 1.2\n    sigma_ref = 5.0\n    \n    dilation_results = []\n    for phi_deg, sigma_n in dilation_cases:\n        psi = get_dilation_angle(calibrated_params_A, phi_deg, sigma_n, gamma, sigma_ref)\n        dilation_results.append(psi)\n\n    # --- Task D: Near-isotropy edge case ---\n\n    calibration_data_B = [\n        (0, 3, 2.400000), (0, 6, 4.800000),\n        (45, 3, 2.371137), (45, 6, 4.742274),\n        (90, 3, 2.340000), (90, 6, 4.680000)\n    ]\n    \n    initial_guess_B = [0.8, 0.78, 0.0]\n    bounds_B = [(1e-6, None), (1e-6, None), (-90, 90)]\n\n    result_B = minimize(\n        ssr_objective,\n        initial_guess_B,\n        args=(calibration_data_B,),\n        method='L-BFGS-B',\n        bounds=bounds_B\n    )\n    \n    mu1_B, mu2_B, _ = result_B.x\n    anisotropy_ratio = max(mu1_B, mu2_B) / min(mu1_B, mu2_B)\n\n    # --- Task E: Normal complementarity checks ---\n\n    normal_test_pairs = [\n        (0, 5),\n        (0.001, 0),\n        (0.001, 2)\n    ]\n    \n    complementarity_results = []\n    tolerance = 1e-9\n    for g_n, p_n in normal_test_pairs:\n        cond1 = g_n >= 0\n        cond2 = p_n >= 0\n        cond3 = abs(g_n * p_n)  tolerance\n        holds = cond1 and cond2 and cond3\n        complementarity_results.append(holds)\n\n    # --- Final Output Formatting ---\n    \n    output_list = [\n        f\"{mu1_A:.3f}\",\n        f\"{mu2_A:.3f}\",\n        f\"{theta0_A:.2f}\",\n        str(classif_results[0]).lower(),\n        str(classif_results[1]).lower(),\n        str(classif_results[2]).lower(),\n        f\"{dilation_results[0]:.2f}\",\n        f\"{dilation_results[1]:.2f}\",\n        f\"{dilation_results[2]:.2f}\",\n        f\"{anisotropy_ratio:.3f}\",\n        str(complementarity_results[0]).lower(),\n        str(complementarity_results[1]).lower(),\n        str(complementarity_results[2]).lower()\n    ]\n    \n    print(f\"[{','.join(output_list)}]\")\n\nsolve()\n```"
        }
    ]
}