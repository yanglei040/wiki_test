{
    "hands_on_practices": [
        {
            "introduction": "To build a strong intuition for static condensation, we begin with a foundational exercise. By manually deriving the condensed system for a simple one-dimensional bar from first principles, you will see exactly how the individual element stiffnesses combine to form the Schur complement and how external forces are transformed into an effective interface load. This pen-and-paper practice reveals the underlying physics of the procedure, including how it correctly captures conditions for static equilibrium for an unconstrained system. ",
            "id": "3565840",
            "problem": "A straight, prismatic, one-dimensional bar is discretized into two linear two-node finite elements connected at a single interface node. Let the global nodes be labeled $\\{1,2,3\\}$ from left to right, with element $1$ connecting nodes $\\{1,2\\}$ and element $2$ connecting nodes $\\{2,3\\}$. The axial stiffnesses of the two elements are $k_1$ and $k_2$, respectively, each with physical units of $\\text{N}/\\text{m}$. Denote the nodal axial displacements by $u_1$, $u_2$, $u_3$ and the externally applied nodal axial loads by $f_1$, $f_2$, $f_3$ (positive in the positive axial direction).\n\nAssume small strain, linear elasticity, and quasi-static conditions. As a fundamental base, use (i) force equilibrium at nodes, (ii) linear elastic axial force–displacement relation for each element, and (iii) the standard two-node bar element stiffness representation in local coordinates.\n\nTasks:\n1. Assemble the global stiffness matrix $\\mathbf{K}$ for the system in the global degree-of-freedom ordering $\\{u_1,u_2,u_3\\}$, starting from the well-known two-node bar element stiffness $\\mathbf{k}_e = k_e \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$, where $k_e \\in \\{k_1,k_2\\}$ for elements $1$ and $2$, respectively. Write the assembled $\\mathbf{K}$ explicitly in terms of $k_1$ and $k_2$.\n\n2. Partition the global system $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ to eliminate the boundary displacements $\\{u_1, u_3\\}$ and retain the interface displacement $u_2$. To match the standard notation for static condensation used in the main text, let the set of degrees of freedom to be retained (the \"boundary\" set) be $\\mathbf{u}_b = u_2$, and the set of degrees of freedom to be eliminated (the \"internal\" set) be $\\mathbf{u}_i = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$. Reorder the system according to the partitioning $\\begin{pmatrix} \\mathbf{u}_b \\\\ \\mathbf{u}_i \\end{pmatrix}$ and explicitly write the blocks $\\mathbf{K}_{bb}$, $\\mathbf{K}_{bi}$, $\\mathbf{K}_{ib}$, and $\\mathbf{K}_{ii}$.\n\n3. Using static condensation based on the Schur complement, eliminate $\\mathbf{u}_i$ to obtain a single scalar interface equilibrium of the form\n$$\nS\\,u_b \\;=\\; g,\n$$\nwhere $S$ is the condensed scalar stiffness and $g$ is the condensed scalar load. Derive $S$ and $g$ explicitly in terms of $k_1$, $k_2$, and the nodal loads $f_1$, $f_2$, $f_3$. Verify that the partitioned stiffness is symmetric and that the physical units of $S$ and $g$ are consistent with stiffness and force, respectively.\n\nExpress the final answer in Newtons for $g$. Do not numerically evaluate; provide the exact algebraic expression. Report only $g$ as your final answer.",
            "solution": "The problem is first validated to ensure it is scientifically sound, self-contained, and well-posed.\n\n### Step 1: Extract Givens\n- **System**: A straight, prismatic, one-dimensional bar.\n- **Discretization**: Two linear two-node finite elements connected at an interface node.\n- **Nodes**: Global nodes are labeled {$1$, $2$, $3$}. Element $1$ connects nodes {$1, 2$}; element $2$ connects nodes {$2, 3$}.\n- **Stiffness**: Axial stiffness of element $1$ is $k_1$. Axial stiffness of element $2$ is $k_2$. Units are $\\text{N}/\\text{m}$.\n- **Degrees of Freedom (DOFs)**: Nodal axial displacements are $u_1$, $u_2$, $u_3$.\n- **Loads**: External nodal axial loads are $f_1$, $f_2$, $f_3$.\n- **Assumptions**: Small strain, linear elasticity, quasi-static conditions.\n- **Governing Principles**: (i) force equilibrium, (ii) linear elastic force-displacement relation, (iii) standard two-node bar element stiffness matrix.\n- **Element Stiffness Matrix**: $\\mathbf{k}_e = k_e \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ for $k_e \\in \\{k_1, k_2\\}$.\n- **Task 1**: Assemble the global stiffness matrix $\\mathbf{K}$ for the DOF ordering $\\{u_1, u_2, u_3\\}$.\n- **Task 2**: Partition the system $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ by specifying the retained DOF as $\\mathbf{u}_b = u_2$ and the DOFs to be eliminated (condensed) as $\\mathbf{u}_i = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$. Identify the blocks $\\mathbf{K}_{bb}$, $\\mathbf{K}_{bi}$, $\\mathbf{K}_{ib}$, and $\\mathbf{K}_{ii}$.\n- **Task 3**: Use static condensation to eliminate $\\mathbf{u}_i$ and derive the condensed system $S u_b = g$. Derive expressions for the scalar stiffness $S$ and scalar load $g$.\n- **Final Answer**: Report the exact algebraic expression for $g$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard exercise in the Finite Element Method (FEM) applied to structural mechanics. All concepts, including element stiffness matrices, global assembly, and static condensation (via Schur complement), are fundamental and well-established principles in computational mechanics. The problem is stated with clear, objective language and provides all necessary information for a unique solution. The partitioning scheme, while demonstrating an unusual application of condensation (eliminating boundary nodes to retain an interior node), is mathematically well-defined. The condition for the existence of the required matrix inverse ($\\mathbf{K}_{ii}^{-1}$) is met as element stiffnesses $k_1, k_2$ are physically required to be positive. The problem is scientifically grounded, well-posed, and objective.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\n**1. Assembly of the Global Stiffness Matrix $\\mathbf{K}$**\n\nThe system consists of two elements. The element stiffness matrices are given for their respective local node orderings.\nFor element $1$ (nodes $1, 2$), the stiffness matrix is:\n$$ \\mathbf{k}^{(1)} = k_1 \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\nFor element $2$ (nodes $2, 3$), the stiffness matrix is:\n$$ \\mathbf{k}^{(2)} = k_2 \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\nThe global stiffness matrix $\\mathbf{K}$ is assembled for the global degrees of freedom $\\{u_1, u_2, u_3\\}$ using the direct stiffness method. The entries of the element matrices are added to the corresponding locations in the global matrix.\n\n$K_{11}$ gets the $(1,1)$ entry from $\\mathbf{k}^{(1)}$.\n$K_{22}$ gets the $(2,2)$ entry from $\\mathbf{k}^{(1)}$ and the $(1,1)$ entry from $\\mathbf{k}^{(2)}$.\n$K_{33}$ gets the $(2,2)$ entry from $\\mathbf{k}^{(2)}$.\nThe off-diagonal terms are assembled similarly.\n\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\nk_1 & -k_1 & 0 \\\\\n-k_1 & k_1 + k_2 & -k_2 \\\\\n0 & -k_2 & k_2\n\\end{pmatrix}\n$$\nThe global system of equations is $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$, where $\\mathbf{u} = \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix}$ and $\\mathbf{f} = \\begin{pmatrix} f_1 \\\\ f_2 \\\\ f_3 \\end{pmatrix}$.\n\n**2. Partitioning the Global System**\n\nThe problem specifies a partitioning where the retained DOF is $\\mathbf{u}_b = u_2$ and the eliminated DOFs are $\\mathbf{u}_i = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$. To conform to the block matrix structure, we must reorder the system of equations for the DOF vector $\\begin{pmatrix} \\mathbf{u}_b \\\\ \\mathbf{u}_i \\end{pmatrix} = \\begin{pmatrix} u_2 \\\\ u_1 \\\\ u_3 \\end{pmatrix}$. The corresponding force vector is $\\begin{pmatrix} \\mathbf{f}_b \\\\ \\mathbf{f}_i \\end{pmatrix} = \\begin{pmatrix} f_2 \\\\ f_1 \\\\ f_3 \\end{pmatrix}$.\n\nThe reordered stiffness matrix, denoted $\\mathbf{K}'$, is obtained by permuting the rows and columns of $\\mathbf{K}$ to match the new DOF order $\\{2, 1, 3\\}$.\n$$\n\\mathbf{K}' =\n\\begin{pmatrix}\nK_{22} & K_{21} & K_{23} \\\\\nK_{12} & K_{11} & K_{13} \\\\\nK_{32} & K_{31} & K_{33}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nk_1+k_2 & -k_1 & -k_2 \\\\\n-k_1 & k_1 & 0 \\\\\n-k_2 & 0 & k_2\n\\end{pmatrix}\n$$\nThe partitioned system is $\\mathbf{K}' \\begin{pmatrix} \\mathbf{u}_b \\\\ \\mathbf{u}_i \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f}_b \\\\ \\mathbf{f}_i \\end{pmatrix}$. We identify the blocks as:\n$$\n\\mathbf{K}' =\n\\left[\n\\begin{array}{c|cc}\n\\mathbf{K}_{bb} & \\mathbf{K}_{bi} \\\\\n\\hline\n\\mathbf{K}_{ib} & \\mathbf{K}_{ii}\n\\end{array}\n\\right]\n$$\nThe specific blocks are:\n- $\\mathbf{K}_{bb} = [k_1+k_2]$ (a $1 \\times 1$ matrix)\n- $\\mathbf{K}_{bi} = \\begin{pmatrix} -k_1 & -k_2 \\end{pmatrix}$ (a $1 \\times 2$ matrix)\n- $\\mathbf{K}_{ib} = \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix}$ (a $2 \\times 1$ matrix)\n- $\\mathbf{K}_{ii} = \\begin{pmatrix} k_1 & 0 \\\\ 0 & k_2 \\end{pmatrix}$ (a $2 \\times 2$ matrix)\n\nThe partitioned system of equations is:\n$$ \\mathbf{K}_{bb} \\mathbf{u}_b + \\mathbf{K}_{bi} \\mathbf{u}_i = \\mathbf{f}_b $$\n$$ \\mathbf{K}_{ib} \\mathbf{u}_b + \\mathbf{K}_{ii} \\mathbf{u}_i = \\mathbf{f}_i $$\n\n**3. Static Condensation**\n\nWe eliminate $\\mathbf{u}_i$ as requested. From the second equation:\n$$ \\mathbf{K}_{ii} \\mathbf{u}_i = \\mathbf{f}_i - \\mathbf{K}_{ib} \\mathbf{u}_b $$\nTo solve for $\\mathbf{u}_i$, we must invert $\\mathbf{K}_{ii}$. The determinant is $\\det(\\mathbf{K}_{ii}) = k_1 k_2$. Since $k_1$ and $k_2$ represent physical stiffnesses, they are strictly positive, so $\\det(\\mathbf{K}_{ii}) > 0$ and the inverse exists.\n$$ \\mathbf{K}_{ii}^{-1} = \\frac{1}{k_1 k_2} \\begin{pmatrix} k_2 & 0 \\\\ 0 & k_1 \\end{pmatrix} = \\begin{pmatrix} 1/k_1 & 0 \\\\ 0 & 1/k_2 \\end{pmatrix} $$\nThus,\n$$ \\mathbf{u}_i = \\mathbf{K}_{ii}^{-1} (\\mathbf{f}_i - \\mathbf{K}_{ib} \\mathbf{u}_b) $$\nSubstituting this into the first equation:\n$$ \\mathbf{K}_{bb} \\mathbf{u}_b + \\mathbf{K}_{bi} \\left( \\mathbf{K}_{ii}^{-1} (\\mathbf{f}_i - \\mathbf{K}_{ib} \\mathbf{u}_b) \\right) = \\mathbf{f}_b $$\nRearranging the terms to group $\\mathbf{u}_b$:\n$$ (\\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib}) \\mathbf{u}_b = \\mathbf{f}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{f}_i $$\nThis is the condensed system $S u_b = g$, where $S$ is the Schur complement of $\\mathbf{K}_{ii}$ in $\\mathbf{K}'$.\n\nLet's compute $S$ and $g$.\n$$ S = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} $$\n$$ S = (k_1+k_2) - \\begin{pmatrix} -k_1 & -k_2 \\end{pmatrix} \\begin{pmatrix} 1/k_1 & 0 \\\\ 0 & 1/k_2 \\end{pmatrix} \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix} $$\n$$ S = (k_1+k_2) - \\begin{pmatrix} -1 & -1 \\end{pmatrix} \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix} $$\n$$ S = (k_1+k_2) - ((-1)(-k_1) + (-1)(-k_2)) $$\n$$ S = (k_1+k_2) - (k_1+k_2) = 0 $$\nThe condensed stiffness is $S=0$. This physically corresponds to the fact that the unconstrained bar has a rigid-body mode, and the condensation process has isolated the condition for static equilibrium. The units of $S$ are $\\text{N}/\\text{m}$, which is consistent.\n\nNow we compute the condensed load vector $g$.\n$$ g = \\mathbf{f}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{f}_i $$\nRecalling $\\mathbf{f}_b = f_2$ and $\\mathbf{f}_i = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}$:\n$$ g = f_2 - \\begin{pmatrix} -k_1 & -k_2 \\end{pmatrix} \\begin{pmatrix} 1/k_1 & 0 \\\\ 0 & 1/k_2 \\end{pmatrix} \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix} $$\n$$ g = f_2 - \\begin{pmatrix} -1 & -1 \\end{pmatrix} \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix} $$\n$$ g = f_2 - ((-1)f_1 + (-1)f_3) $$\n$$ g = f_2 - (-f_1 - f_3) = f_1 + f_2 + f_3 $$\nThe resulting expression for $g$ is the sum of all external nodal forces. The condensed equation is $0 \\cdot u_b = f_1 + f_2 + f_3$. This demonstrates that for a static solution to exist, the net external force on the free-floating system must be zero, i.e., $g=0$. The physical units of $g$ are Newtons ($\\text{N}$), as it is a sum of forces.\n\nThe problem asks for the expression for $g$.\n$$ g = f_1 + f_2 + f_3 $$\nThis is the final derived expression.",
            "answer": "$$\n\\boxed{f_1 + f_2 + f_3}\n$$"
        },
        {
            "introduction": "Transitioning from analytical derivation to computational practice, this exercise addresses a crucial aspect of implementing sub-structuring for large-scale systems. Explicitly assembling the global Schur complement matrix $S$ is often computationally prohibitive due to its density and size. This practice guides you through the standard and scalable alternative: implementing a \"matrix-free\" function that computes the action of the operator, $\\mathbf{y}_b = \\mathbf{S} \\mathbf{x}_b$, using a sequence of local subdomain solves and gather-scatter operations on interface vectors, a cornerstone of modern domain decomposition methods. ",
            "id": "3565877",
            "problem": "You are asked to implement the application of an interface operator arising from sub-structuring and static condensation without explicitly assembling the global Schur complement. The objective is to design data structures and assembly maps that enable the action of the operator on a global interface vector by using only local subdomain solves on interior degrees of freedom (DOFs) and gather-scatter operations on interface vectors.\n\nConsider a set of subdomains indexed by $s$, each with a stiffness matrix block-partitioned into interior and interface DOFs. The fundamental base is that the governing linear system is symmetric positive definite and arises from a well-posed variational formulation, and that performing block Gaussian elimination on interior DOFs yields an operator acting only on interface DOFs. You must not explicitly assemble the global operator; instead, you must implement its action on a given interface vector by doing local linear solves on interior DOFs and summing contributions via an assembly map.\n\nProgram requirements:\n- Design a data structure for each subdomain $s$ storing matrices $\\mathbf{K}_{ii}^{(s)}$, $\\mathbf{K}_{ib}^{(s)}$, $\\mathbf{K}_{bi}^{(s)}$, $\\mathbf{K}_{bb}^{(s)}$ and a map $\\phi^{(s)}$ taking each local interface DOF index $j$ to a global interface index $\\phi^{(s)}(j)$.\n- Implement a function that, given a global interface vector $\\mathbf{x}_b \\in \\mathbb{R}^{N_b}$, computes $\\mathbf{y}_b = \\mathbf{S} \\mathbf{x}_b$ without assembling $\\mathbf{S}$ by:\n  - Gathering the local slice $\\mathbf{x}_b^{(s)}$ using $\\phi^{(s)}$,\n  - Solving a local interior system per subdomain on its interior DOFs,\n  - Forming the local interface contribution,\n  - Scattering and summing these contributions back to the global interface vector using $\\phi^{(s)}$.\n- Your program must apply this operation for a set of test cases given below and print the resulting vectors.\n\nDefinitions and constraints:\n- All matrices and vectors are real-valued.\n- If a subdomain has zero interior DOFs, treat its interior blocks as empty and skip interior solves; its contribution then depends only on its interface block.\n- All interface maps are many-to-one from local to global indices, and overlapping contributions must be summed.\n- Angles are not involved. No physical units are required.\n\nTest suite:\nProvide results for the following three test cases. For each subdomain $s$, you are given $\\mathbf{K}_{ii}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_i^{(s)}}$, $\\mathbf{K}_{ib}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_b^{(s)}}$, $\\mathbf{K}_{bi}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_i^{(s)}}$, $\\mathbf{K}_{bb}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_b^{(s)}}$, and a local-to-global interface map $\\phi^{(s)}: \\{0,\\ldots,n_b^{(s)}-1\\} \\to \\{0,\\ldots,N_b-1\\}$. The global interface vector $\\mathbf{x}_b$ has length $N_b$.\n\n- Test Case A:\n  - Global interface size $N_b = 1$.\n  - Subdomains: a single subdomain $s$ with\n    $$\n    \\mathbf{K}_{ii}^{(s)} =\n    \\begin{bmatrix}\n    4 & 1 \\\\\n    1 & 3\n    \\end{bmatrix},\\quad\n    \\mathbf{K}_{ib}^{(s)} =\n    \\begin{bmatrix}\n    1 \\\\\n    2\n    \\end{bmatrix},\\quad\n    \\mathbf{K}_{bi}^{(s)} =\n    \\begin{bmatrix}\n    1 & 2\n    \\end{bmatrix},\\quad\n    \\mathbf{K}_{bb}^{(s)} =\n    \\begin{bmatrix}\n    5\n    \\end{bmatrix}.\n    $$\n    The local-to-global map is $\\phi^{(s)} = [0]$.\n  - Use $\\mathbf{x}_b = [1.5]$.\n- Test Case B:\n  - Global interface size $N_b = 3$.\n  - Subdomains: two subdomains $s \\in \\{1,2\\}$ specified as follows.\n    - Subdomain $s=1$:\n      $$\n      \\mathbf{K}_{ii}^{(1)} =\n      \\begin{bmatrix}\n      3\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{ib}^{(1)} =\n      \\begin{bmatrix}\n      1 & -1\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bi}^{(1)} =\n      \\begin{bmatrix}\n      1 \\\\\n      -1\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bb}^{(1)} =\n      \\begin{bmatrix}\n      4 & 0.5 \\\\\n      0.5 & 2\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(1)} = [0, 1]$.\n    - Subdomain $s=2$:\n      $$\n      \\mathbf{K}_{ii}^{(2)} =\n      \\begin{bmatrix}\n      6 & 1 \\\\\n      1 & 4\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{ib}^{(2)} =\n      \\begin{bmatrix}\n      2 & 0 \\\\\n      -1 & 3\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bi}^{(2)} =\n      \\begin{bmatrix}\n      2 & -1 \\\\\n      0 & 3\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bb}^{(2)} =\n      \\begin{bmatrix}\n      3 & -0.2 \\\\\n      -0.2 & 5\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(2)} = [1, 2]$.\n  - Use $\\mathbf{x}_b = [1.0,\\,-0.5,\\,2.0]$.\n- Test Case C:\n  - Global interface size $N_b = 3$.\n  - Subdomains: three subdomains $s \\in \\{1,2,3\\}$ specified as follows.\n    - Subdomain $s=1$ (no interior DOFs):\n      $$\n      \\mathbf{K}_{ii}^{(1)} \\in \\mathbb{R}^{0 \\times 0},\\quad\n      \\mathbf{K}_{ib}^{(1)} \\in \\mathbb{R}^{0 \\times 2},\\quad\n      \\mathbf{K}_{bi}^{(1)} \\in \\mathbb{R}^{2 \\times 0},\\quad\n      \\mathbf{K}_{bb}^{(1)} =\n      \\begin{bmatrix}\n      2 & 0.3 \\\\\n      0.3 & 1.5\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(1)} = [0, 1]$.\n    - Subdomain $s=2$:\n      $$\n      \\mathbf{K}_{ii}^{(2)} =\n      \\begin{bmatrix}\n      2\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{ib}^{(2)} =\n      \\begin{bmatrix}\n      -1 & 0.5\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bi}^{(2)} =\n      \\begin{bmatrix}\n      -1 \\\\\n      0.5\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bb}^{(2)} =\n      \\begin{bmatrix}\n      1 & 0.1 \\\\\n      0.1 & 2\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(2)} = [1, 2]$.\n    - Subdomain $s=3$:\n      $$\n      \\mathbf{K}_{ii}^{(3)} =\n      \\begin{bmatrix}\n      7 & 0 \\\\\n      0 & 8\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{ib}^{(3)} =\n      \\begin{bmatrix}\n      1 \\\\\n      2\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bi}^{(3)} =\n      \\begin{bmatrix}\n      1 & 2\n      \\end{bmatrix},\\quad\n      \\mathbf{K}_{bb}^{(3)} =\n      \\begin{bmatrix}\n      4\n      \\end{bmatrix}.\n      $$\n      The local-to-global map is $\\phi^{(3)} = [2]$.\n  - Use $\\mathbf{x}_b = [0.2,\\,-1.2,\\,0.7]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to one test case and must itself be a list representing the resulting global interface vector $\\mathbf{y}_b$ for that test case. For example, the printed structure must look like $[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,\\ldots\\,]$.\n- Express all floating-point numbers with $6$ digits after the decimal point using standard rounding.",
            "solution": "The problem is valid as it is scientifically sound, well-posed, and provides a complete specification. It describes a standard numerical procedure in computational mechanics known as static condensation, which is a key component of certain domain decomposition methods like the Finite Element Tearing and Interconnecting (FETI) methods or general substructuring. The problem asks for an implementation of the matrix-vector product with the global Schur complement operator without explicitly forming this operator.\n\nThe governing principle is based on the block partitioning of a global linear system of equations, typically arising from a Finite Element Method (FEM) discretization. For a system partitioned into interior degrees of freedom (DOFs), indexed by $i$, and interface (or boundary) DOFs, indexed by $b$, the linear system for a single subdomain $s$ can be written as:\n$$\n\\begin{bmatrix} \\mathbf{K}_{ii}^{(s)} & \\mathbf{K}_{ib}^{(s)} \\\\ \\mathbf{K}_{bi}^{(s)} & \\mathbf{K}_{bb}^{(s)} \\end{bmatrix}\n\\begin{bmatrix} \\mathbf{x}_i^{(s)} \\\\ \\mathbf{x}_b^{(s)} \\end{bmatrix}\n=\n\\begin{bmatrix} \\mathbf{f}_i^{(s)} \\\\ \\mathbf{f}_b^{(s)} \\end{bmatrix}\n$$\nHere, $\\mathbf{K}^{(s)}$ is the stiffness matrix of subdomain $s$, $\\mathbf{x}^{(s)}$ is the vector of unknown displacements, and $\\mathbf{f}^{(s)}$ is the vector of applied nodal forces. The indices $i$ and $b$ refer to local interior and local interface DOFs, respectively.\n\nStatic condensation is the process of eliminating the interior DOFs $\\mathbf{x}_i^{(s)}$. Assuming no external forces are applied to the interior DOFs (i.e., $\\mathbf{f}_i^{(s)} = \\mathbf{0}$), the first row of the block system gives:\n$$\n\\mathbf{K}_{ii}^{(s)} \\mathbf{x}_i^{(s)} + \\mathbf{K}_{ib}^{(s)} \\mathbf{x}_b^{(s)} = \\mathbf{0}\n$$\nSince the problem states that the system arises from a well-posed formulation, the matrix $\\mathbf{K}_{ii}^{(s)}$ (the stiffness of the subdomain with its boundary 'clamped') is symmetric positive definite and thus invertible. We can express the interior displacements $\\mathbf{x}_i^{(s)}$ in terms of the interface displacements $\\mathbf{x}_b^{(s)}$:\n$$\n\\mathbf{x}_i^{(s)} = -(\\mathbf{K}_{ii}^{(s)})^{-1} \\mathbf{K}_{ib}^{(s)} \\mathbf{x}_b^{(s)}\n$$\nSubstituting this into the second row of the block system, which describes the forces on the interface DOFs, we get:\n$$\n\\mathbf{f}_b^{(s)} = \\mathbf{K}_{bi}^{(s)} \\mathbf{x}_i^{(s)} + \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)} = \\mathbf{K}_{bi}^{(s)} \\left( -(\\mathbf{K}_{ii}^{(s)})^{-1} \\mathbf{K}_{ib}^{(s)} \\mathbf{x}_b^{(s)} \\right) + \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)}\n$$\nThis simplifies to:\n$$\n\\mathbf{f}_b^{(s)} = \\left( \\mathbf{K}_{bb}^{(s)} - \\mathbf{K}_{bi}^{(s)} (\\mathbf{K}_{ii}^{(s)})^{-1} \\mathbf{K}_{ib}^{(s)} \\right) \\mathbf{x}_b^{(s)}\n$$\nThe term in the parentheses is the local Schur complement matrix, $\\mathbf{S}^{(s)}$:\n$$\n\\mathbf{S}^{(s)} = \\mathbf{K}_{bb}^{(s)} - \\mathbf{K}_{bi}^{(s)} (\\mathbf{K}_{ii}^{(s)})^{-1} \\mathbf{K}_{ib}^{(s)}\n$$\n$\\mathbf{S}^{(s)}$ relates the displacements of the local interface DOFs to the forces on them, after the effect of the interior has been \"condensed out\".\n\nThe global interface system is formed by assembling the contributions from all subdomains. The global Schur complement, $\\mathbf{S}$, is the sum of the local Schur complements projected onto the global interface DOFs. If $\\mathbf{A}^{(s)}$ represents the mapping (or gathering) from the global interface vector to the local interface vector for subdomain $s$, then its transpose $\\mathbf{A}^{(s)T}$ represents the scattering (and summation) from local to global. The global operator is $\\mathbf{S} = \\sum_s \\mathbf{A}^{(s)T} \\mathbf{S}^{(s)} \\mathbf{A}^{(s)}$.\n\nThe problem requires computing the action of this global operator on a given global interface vector $\\mathbf{x}_b$, i.e., computing $\\mathbf{y}_b = \\mathbf{S} \\mathbf{x}_b$, without explicitly forming either $\\mathbf{S}$ or the local $\\mathbf{S}^{(s)}$ matrices. The computation proceeds as follows:\n$$\n\\mathbf{y}_b = \\left( \\sum_s \\mathbf{A}^{(s)T} \\mathbf{S}^{(s)} \\mathbf{A}^{(s)} \\right) \\mathbf{x}_b = \\sum_s \\mathbf{A}^{(s)T} \\left( \\mathbf{S}^{(s)} (\\mathbf{A}^{(s)} \\mathbf{x}_b) \\right)\n$$\nLet $\\mathbf{x}_b^{(s)} = \\mathbf{A}^{(s)} \\mathbf{x}_b$ be the local vector gathered from $\\mathbf{x}_b$. The core task is to compute the local product $\\mathbf{y}_b^{(s)} = \\mathbf{S}^{(s)} \\mathbf{x}_b^{(s)}$ for each subdomain and then scatter-add the results: $\\mathbf{y}_b = \\sum_s \\mathbf{A}^{(s)T} \\mathbf{y}_b^{(s)}$.\n\nThe local product $\\mathbf{y}_b^{(s)} = \\mathbf{S}^{(s)} \\mathbf{x}_b^{(s)}$ is evaluated efficiently as:\n$$\n\\mathbf{y}_b^{(s)} = \\left( \\mathbf{K}_{bb}^{(s)} - \\mathbf{K}_{bi}^{(s)} (\\mathbf{K}_{ii}^{(s)})^{-1} \\mathbf{K}_{ib}^{(s)} \\right) \\mathbf{x}_b^{(s)} = \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)} - \\mathbf{K}_{bi}^{(s)} \\left( (\\mathbf{K}_{ii}^{(s)})^{-1} (\\mathbf{K}_{ib}^{(s)} \\mathbf{x}_b^{(s)}) \\right)\n$$\nThis is computed in steps to avoid forming the matrix inverse $(\\mathbf{K}_{ii}^{(s)})^{-1}$:\n1.  Compute the right-hand side for the interior problem: $\\mathbf{v}^{(s)} = \\mathbf{K}_{ib}^{(s)} \\mathbf{x}_b^{(s)}$.\n2.  Solve the local interior system for an auxiliary vector $\\mathbf{u}_i^{(s)}$: $\\mathbf{K}_{ii}^{(s)} \\mathbf{u}_i^{(s)} = \\mathbf{v}^{(s)}$. This is the \"local solve on interior DOFs\".\n3.  Compute the final local contribution: $\\mathbf{y}_b^{(s)} = \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)} - \\mathbf{K}_{bi}^{(s)} \\mathbf{u}_i^{(s)}$.\n\nIf a subdomain $s$ has no interior DOFs ($n_i^{(s)} = 0$), the matrices $\\mathbf{K}_{ii}^{(s)}$, $\\mathbf{K}_{ib}^{(s)}$, and $\\mathbf{K}_{bi}^{(s)}$ are empty. The Schur complement term involving the inverse vanishes, and the local contribution simplifies to $\\mathbf{y}_b^{(s)} = \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)}$.\n\nThe overall algorithm is as follows:\n1.  Initialize the global result vector $\\mathbf{y}_b$ to zeros, with length $N_b$.\n2.  For each subdomain $s$:\n    a.  **Gather**: Use the map $\\phi^{(s)}$ to extract the local interface vector $\\mathbf{x}_b^{(s)}$ from the global vector $\\mathbf{x}_b$.\n    b.  **Compute Local Contribution**:\n        i. If $n_i^{(s)} > 0$, compute $\\mathbf{y}_b^{(s)} = \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)} - \\mathbf{K}_{bi}^{(s)} (\\mathbf{K}_{ii}^{(s)})^{-1} (\\mathbf{K}_{ib}^{(s)} \\mathbf{x}_b^{(s)})$ by performing the local solve as described above.\n        ii. If $n_i^{(s)} = 0$, compute $\\mathbf{y}_b^{(s)} = \\mathbf{K}_{bb}^{(s)} \\mathbf{x}_b^{(s)}$.\n    c.  **Scatter**: Use the map $\\phi^{(s)}$ to add the elements of the local result $\\mathbf{y}_b^{(s)}$ to the corresponding positions in the global vector $\\mathbf{y}_b$.\n3.  The final vector $\\mathbf{y}_b$ is the result of the operation $\\mathbf{S} \\mathbf{x}_b$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_schur_operator(Nb, subdomains, xb):\n    \"\"\"\n    Computes the action of the Schur complement operator S on a vector xb.\n\n    This function computes yb = S @ xb without explicitly assembling S.\n    The computation is done subdomain by subdomain using gather-solve-scatter ops.\n\n    Args:\n        Nb (int): The total number of global interface DOFs.\n        subdomains (list): A list of dictionaries, each representing a subdomain's data.\n        xb (np.ndarray): The global interface vector.\n\n    Returns:\n        np.ndarray: The resulting global interface vector yb.\n    \"\"\"\n    yb = np.zeros(Nb, dtype=float)\n\n    for s_data in subdomains:\n        Kii = s_data['Kii']\n        Kib = s_data['Kib']\n        Kbi = s_data['Kbi']\n        Kbb = s_data['Kbb']\n        phi = s_data['phi']\n        ni_s = Kii.shape[0]\n\n        # 1. Gather operation: extract local interface vector from global vector\n        xb_s = xb[phi]\n\n        # 2. Compute local contribution yb_s = S_s * xb_s\n        if ni_s > 0:\n            # S_s = Kbb_s - Kbi_s * inv(Kii_s) * Kib_s\n            # We compute the product yb_s = S_s @ xb_s in steps:\n            # a. Compute intermediate vector v_s = Kib_s @ xb_s\n            v_s = Kib @ xb_s\n            # b. Solve the local interior system: Kii_s * u_i_s = v_s\n            u_i_s = np.linalg.solve(Kii, v_s)\n            # c. Compute local contribution: yb_s = Kbb_s @ xb_s - Kbi_s @ u_i_s\n            yb_s = Kbb @ xb_s - Kbi @ u_i_s\n        else:\n            # If no interior DOFs, S_s = Kbb_s\n            yb_s = Kbb @ xb_s\n        \n        # 3. Scatter operation: add local contribution back to global vector\n        # np.add.at is a vectorized way to perform this scatter-add operation.\n        np.add.at(yb, phi, yb_s)\n\n    return yb\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            \"Nb\": 1,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[4, 1], [1, 3]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[5]]),\n                    \"phi\": np.array([0]),\n                }\n            ],\n            \"xb\": np.array([1.5]),\n        },\n        # Test Case B\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[3]]),\n                    \"Kib\": np.array([[1, -1]]),\n                    \"Kbi\": np.array([[1], [-1]]),\n                    \"Kbb\": np.array([[4, 0.5], [0.5, 2]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[6, 1], [1, 4]]),\n                    \"Kib\": np.array([[2, 0], [-1, 3]]),\n                    \"Kbi\": np.array([[2, -1], [0, 3]]),\n                    \"Kbb\": np.array([[3, -0.2], [-0.2, 5]]),\n                    \"phi\": np.array([1, 2]),\n                },\n            ],\n            \"xb\": np.array([1.0, -0.5, 2.0]),\n        },\n        # Test Case C\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                { # Subdomain with no interior DOFs\n                    \"Kii\": np.empty((0, 0)),\n                    \"Kib\": np.empty((0, 2)),\n                    \"Kbi\": np.empty((2, 0)),\n                    \"Kbb\": np.array([[2, 0.3], [0.3, 1.5]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[2]]),\n                    \"Kib\": np.array([[-1, 0.5]]),\n                    \"Kbi\": np.array([[-1], [0.5]]),\n                    \"Kbb\": np.array([[1, 0.1], [0.1, 2]]),\n                    \"phi\": np.array([1, 2]),\n                },\n                {\n                    \"Kii\": np.array([[7, 0], [0, 8]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[4]]),\n                    \"phi\": np.array([2]),\n                },\n            ],\n            \"xb\": np.array([0.2, -1.2, 0.7]),\n        },\n    ]\n\n    results_str = []\n    for case in test_cases:\n        Nb = case[\"Nb\"]\n        subdomains = case[\"subdomains\"]\n        xb = case[\"xb\"]\n        \n        yb = apply_schur_operator(Nb, subdomains, xb)\n        \n        # Format the result vector as a string list with 6 decimal places\n        formatted_yb = [f\"{val:.6f}\" for val in yb]\n        results_str.append(f\"[{','.join(formatted_yb)}]\")\n\n    # Print the final output in the required format: [[...],[...],...]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice demonstrates the analytical power of static condensation for performing rapid \"what-if\" analyses, a common task in engineering design and sensitivity studies. When a localized change occurs within a subdomain, such as a modification to soil properties, re-assembling and re-factorizing the entire system is inefficient. This exercise leverages the Sherman-Morrison-Woodbury identity to efficiently update the inverse of the internal stiffness matrix under low-rank perturbations, allowing for the rapid recalculation of the boundary response without starting from scratch. ",
            "id": "3565864",
            "problem": "Consider a finite element soil–structure interaction sub-structure where the global stiffness matrix is partitioned into boundary degrees of freedom and internal soil degrees of freedom. Let the equilibrium in the absence of inertia be governed by the linear system $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$, where $\\mathbf{K}$ is the symmetric positive definite (SPD) stiffness matrix, $\\mathbf{u}$ is the displacement vector, and $\\mathbf{f}$ is the force vector. Using sub-structuring, partition the variables as $\\mathbf{u} = \\begin{bmatrix} \\mathbf{u}_b \\\\ \\mathbf{u}_i \\end{bmatrix}$ and $\\mathbf{f} = \\begin{bmatrix} \\mathbf{f}_b \\\\ \\mathbf{f}_i \\end{bmatrix}$, and the stiffness matrix as\n$$\n\\mathbf{K} = \\begin{bmatrix}\n\\mathbf{K}_{bb} & \\mathbf{K}_{bi} \\\\\n\\mathbf{K}_{ib} & \\mathbf{K}_{ii}\n\\end{bmatrix}.\n$$\nStatic condensation eliminates the internal soil degrees of freedom to yield a reduced system in the boundary degrees of freedom. You are to derive this reduction from first principles and then implement a program that performs rapid \"what-if\" analyses in the boundary displacement vector $\\mathbf{u}_b$ when the internal soil stiffness $\\mathbf{K}_{ii}$ is perturbed by low-rank changes $\\delta \\mathbf{K}_{ii}$.\n\nBase your derivation on the following foundational facts:\n- Equilibrium of linear elasticity in the finite element method: $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$.\n- Properties of the block-partitioned linear system and elimination of internal variables.\n- The Sherman–Morrison–Woodbury identity (SMW), defined as follows on first appearance: the Sherman–Morrison–Woodbury identity (SMW) states that for invertible $\\mathbf{A}$ and appropriately sized matrices $\\mathbf{U}$, $\\mathbf{C}$, and $\\mathbf{V}$, one has $(\\mathbf{A} + \\mathbf{U} \\mathbf{C} \\mathbf{V})^{-1} = \\mathbf{A}^{-1} - \\mathbf{A}^{-1} \\mathbf{U} \\left(\\mathbf{C}^{-1} + \\mathbf{V} \\mathbf{A}^{-1} \\mathbf{U} \\right)^{-1} \\mathbf{V} \\mathbf{A}^{-1}$.\n\nYou must not use or quote the target condensed formula directly; start from $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$ and reason to the condensed system. Then, use SMW to update the inverse of the internal stiffness block $\\mathbf{K}_{ii}$ efficiently under low-rank changes, and consequently update the condensed stiffness and the condensed right-hand-side without recomputing any full inverse from scratch.\n\nAssume the following specific matrices (units: stiffness entries in kilonewtons per meter ($\\mathrm{kN/m}$)):\n$$\n\\mathbf{K}_{bb} = \\begin{bmatrix}\n1000 & -200 \\\\\n-200 & 800\n\\end{bmatrix},\\quad\n\\mathbf{K}_{bi} = \\begin{bmatrix}\n-150 & 100 & 0 \\\\\n50 & -120 & 80\n\\end{bmatrix},\\quad\n\\mathbf{K}_{ib} = \\mathbf{K}_{bi}^\\top,\n$$\n$$\n\\mathbf{K}_{ii} = \\begin{bmatrix}\n3000 & -500 & 0 \\\\\n-500 & 2000 & -400 \\\\\n0 & -400 & 1500\n\\end{bmatrix}.\n$$\n\nYou will analyze four \"what-if\" cases, each characterized by a low-rank update to the internal stiffness $\\delta \\mathbf{K}_{ii} = \\mathbf{U} \\mathbf{C} \\mathbf{U}^\\top$ and specified boundary and internal forces. In each case, compute the boundary displacement vector $\\mathbf{u}_b$ produced by the condensed system. Express each displacement component in meters ($\\mathrm{m}$), rounded to six decimal places.\n\nThe test suite is given by:\n- Case $1$ (baseline, happy path): $\\delta \\mathbf{K}_{ii} = \\mathbf{0}$, $\\mathbf{f}_b = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$ in $\\mathrm{kN}$, $\\mathbf{f}_i = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$ in $\\mathrm{kN}$.\n- Case $2$ (rank-$1$ positive update): $\\mathbf{U} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $\\mathbf{C} = \\begin{bmatrix} 200 \\end{bmatrix}$ (units $\\mathrm{kN/m}$), thus $\\delta \\mathbf{K}_{ii} = 200 \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}$, $\\mathbf{f}_b = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$ in $\\mathrm{kN}$, $\\mathbf{f}_i = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$ in $\\mathrm{kN}$.\n- Case $3$ (rank-$2$ mixed update with internal loads): $\\mathbf{U} = \\begin{bmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$, $\\mathbf{C} = \\begin{bmatrix} 100 & 0 \\\\ 0 & -50 \\end{bmatrix}$ (units $\\mathrm{kN/m}$), $\\mathbf{f}_b = \\begin{bmatrix} 12 \\\\ 8 \\end{bmatrix}$ in $\\mathrm{kN}$, $\\mathbf{f}_i = \\begin{bmatrix} 5 \\\\ -10 \\\\ 15 \\end{bmatrix}$ in $\\mathrm{kN}$.\n- Case $4$ (edge case: zero boundary loads, rank-$1$ isotropic direction): $\\mathbf{U} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$, $\\mathbf{C} = \\begin{bmatrix} 300 \\end{bmatrix}$ (units $\\mathrm{kN/m}$), $\\mathbf{f}_b = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$ in $\\mathrm{kN}$, $\\mathbf{f}_i = \\begin{bmatrix} 20 \\\\ -5 \\\\ 10 \\end{bmatrix}$ in $\\mathrm{kN}$.\n\nImplementation requirements:\n- Compute the baseline inverse $\\mathbf{K}_{ii}^{-1}$ once.\n- For each case, use the Sherman–Morrison–Woodbury identity to obtain $(\\mathbf{K}_{ii} + \\delta \\mathbf{K}_{ii})^{-1}$ without recomputing a full inverse from scratch.\n- Form the condensed stiffness $\\mathbf{S} = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib}$ and, under updates, $\\mathbf{S}' = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} (\\mathbf{K}_{ii} + \\delta \\mathbf{K}_{ii})^{-1} \\mathbf{K}_{ib}$.\n- Form the condensed force $\\mathbf{g} = \\mathbf{f}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{f}_i$ and, under updates, $\\mathbf{g}' = \\mathbf{f}_b - \\mathbf{K}_{bi} (\\mathbf{K}_{ii} + \\delta \\mathbf{K}_{ii})^{-1} \\mathbf{f}_i$.\n- Solve $\\mathbf{S}' \\mathbf{u}_b = \\mathbf{g}'$ for $\\mathbf{u}_b$ in each case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the components ordered by case and then by boundary degree of freedom. Specifically, output $[u_{b,1}^{(1)},u_{b,2}^{(1)},u_{b,1}^{(2)},u_{b,2}^{(2)},u_{b,1}^{(3)},u_{b,2}^{(3)},u_{b,1}^{(4)},u_{b,2}^{(4)}]$, where each $u_{b,j}^{(c)}$ is in meters and rounded to six decimal places.",
            "solution": "The user has provided a valid problem statement concerning sub-structuring, static condensation, and the efficient updating of a condensed system in computational geomechanics. It is scientifically grounded, well-posed, and objective. The derivation and implementation will proceed as requested.\n\nThe starting point is the linear system of equations governing static equilibrium in a finite element model:\n$$\n\\mathbf{K} \\mathbf{u} = \\mathbf{f}\n$$\nwhere $\\mathbf{K}$ is the global stiffness matrix, $\\mathbf{u}$ is the vector of nodal displacements, and $\\mathbf{f}$ is the vector of nodal forces. The matrix $\\mathbf{K}$ is symmetric and positive definite (SPD).\n\nWe partition the degrees of freedom (DOFs) into boundary DOFs, denoted by subscript $b$, and internal DOFs, denoted by subscript $i$. This induces a block structure in the matrix $\\mathbf{K}$ and vectors $\\mathbf{u}$ and $\\mathbf{f}$:\n$$\n\\begin{bmatrix}\n\\mathbf{K}_{bb} & \\mathbf{K}_{bi} \\\\\n\\mathbf{K}_{ib} & \\mathbf{K}_{ii}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u}_b \\\\\n\\mathbf{u}_i\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f}_b \\\\\n\\mathbf{f}_i\n\\end{bmatrix}\n$$\nHere, $\\mathbf{K}_{bb}$ represents the stiffness coupling between boundary DOFs, $\\mathbf{K}_{ii}$ represents the stiffness coupling between internal DOFs, and $\\mathbf{K}_{bi}$ (with its transpose $\\mathbf{K}_{ib} = \\mathbf{K}_{bi}^\\top$ due to symmetry) represents the coupling between boundary and internal DOFs.\n\nThis block matrix equation can be expanded into two coupled vector equations:\n$$\n(1) \\quad \\mathbf{K}_{bb} \\mathbf{u}_b + \\mathbf{K}_{bi} \\mathbf{u}_i = \\mathbf{f}_b\n$$\n$$\n(2) \\quad \\mathbf{K}_{ib} \\mathbf{u}_b + \\mathbf{K}_{ii} \\mathbf{u}_i = \\mathbf{f}_i\n$$\nThe procedure of static condensation aims to eliminate the internal DOFs $\\mathbf{u}_i$ to obtain a smaller system solely in terms of the boundary DOFs $\\mathbf{u}_b$. We achieve this by first solving Equation (2) for $\\mathbf{u}_i$. Since $\\mathbf{K}$ is SPD, its principal submatrix $\\mathbf{K}_{ii}$ is also SPD and thus invertible.\n$$\n\\mathbf{K}_{ii} \\mathbf{u}_i = \\mathbf{f}_i - \\mathbf{K}_{ib} \\mathbf{u}_b\n$$\n$$\n\\mathbf{u}_i = \\mathbf{K}_{ii}^{-1} (\\mathbf{f}_i - \\mathbf{K}_{ib} \\mathbf{u}_b)\n$$\nThis expression gives the internal displacements $\\mathbf{u}_i$ in terms of the boundary displacements $\\mathbf{u}_b$ and the applied forces.\n\nNext, we substitute this expression for $\\mathbf{u}_i$ back into Equation (1):\n$$\n\\mathbf{K}_{bb} \\mathbf{u}_b + \\mathbf{K}_{bi} \\left( \\mathbf{K}_{ii}^{-1} (\\mathbf{f}_i - \\mathbf{K}_{ib} \\mathbf{u}_b) \\right) = \\mathbf{f}_b\n$$\nWe distribute $\\mathbf{K}_{bi}$ and group the terms involving $\\mathbf{u}_b$ on the left-hand side and all other terms (the effective forces) on the right-hand side:\n$$\n\\mathbf{K}_{bb} \\mathbf{u}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} \\mathbf{u}_b = \\mathbf{f}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{f}_i\n$$\nFactoring out $\\mathbf{u}_b$ leads to the condensed system of equations:\n$$\n\\left( \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} \\right) \\mathbf{u}_b = \\mathbf{f}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{f}_i\n$$\nThis is the desired reduced system, which can be written as $\\mathbf{S} \\mathbf{u}_b = \\mathbf{g}$, where:\n- The condensed stiffness matrix, or Schur complement of $\\mathbf{K}_{ii}$ in $\\mathbf{K}$, is $\\mathbf{S} = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib}$.\n- The condensed force vector is $\\mathbf{g} = \\mathbf{f}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{f}_i$.\n\nNow, we consider a \"what-if\" scenario where the internal stiffness matrix $\\mathbf{K}_{ii}$ is perturbed by a low-rank update, $\\delta \\mathbf{K}_{ii} = \\mathbf{U} \\mathbf{C} \\mathbf{U}^\\top$, where $\\mathbf{U}$ has dimensions $n_i \\times r$, $\\mathbf{C}$ is an $r \\times r$ invertible matrix, and $r$ is small. The new internal stiffness is $\\mathbf{K}'_{ii} = \\mathbf{K}_{ii} + \\delta \\mathbf{K}_{ii} = \\mathbf{K}_{ii} + \\mathbf{U} \\mathbf{C} \\mathbf{U}^\\top$.\n\nThe new condensed system becomes $\\mathbf{S}' \\mathbf{u}_b = \\mathbf{g}'$, where:\n$$\n\\mathbf{S}' = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} (\\mathbf{K}'_{ii})^{-1} \\mathbf{K}_{ib}\n$$\n$$\n\\mathbf{g}' = \\mathbf{f}_b - \\mathbf{K}_{bi} (\\mathbf{K}'_{ii})^{-1} \\mathbf{f}_i\n$$\nDirectly inverting $\\mathbf{K}'_{ii}$ for each what-if scenario would be computationally expensive. Instead, we use the Sherman–Morrison–Woodbury identity (SMW), which states that for an invertible matrix $\\mathbf{A}$ and appropriately sized matrices $\\mathbf{U}$, $\\mathbf{C}$, and $\\mathbf{V}$: $(\\mathbf{A} + \\mathbf{U} \\mathbf{C} \\mathbf{V})^{-1} = \\mathbf{A}^{-1} - \\mathbf{A}^{-1} \\mathbf{U} (\\mathbf{C}^{-1} + \\mathbf{V} \\mathbf{A}^{-1} \\mathbf{U})^{-1} \\mathbf{V} \\mathbf{A}^{-1}$.\n\nWe apply this identity to compute $(\\mathbf{K}'_{ii})^{-1} = (\\mathbf{K}_{ii} + \\mathbf{U} \\mathbf{C} \\mathbf{U}^\\top)^{-1}$ with $\\mathbf{A}=\\mathbf{K}_{ii}$ and $\\mathbf{V}=\\mathbf{U}^\\top$:\n$$\n(\\mathbf{K}'_{ii})^{-1} = \\mathbf{K}_{ii}^{-1} - \\mathbf{K}_{ii}^{-1} \\mathbf{U} \\left(\\mathbf{C}^{-1} + \\mathbf{U}^\\top \\mathbf{K}_{ii}^{-1} \\mathbf{U} \\right)^{-1} \\mathbf{U}^\\top \\mathbf{K}_{ii}^{-1}\n$$\nThe key advantage is that the matrix to be inverted, $\\mathbf{M} = \\mathbf{C}^{-1} + \\mathbf{U}^\\top \\mathbf{K}_{ii}^{-1} \\mathbf{U}$, is of size $r \\times r$, which is much smaller than the size of $\\mathbf{K}_{ii}$. This allows for a rapid update of the inverse.\n\nThe algorithm for each what-if analysis is as follows:\n1.  Compute the inverse of the baseline internal stiffness matrix, $\\mathbf{K}_{ii}^{-1}$, once.\n2.  For each case, define the update matrices $\\mathbf{U}$ and $\\mathbf{C}$, and force vectors $\\mathbf{f}_b$ and $\\mathbf{f}_i$.\n3.  If there is a non-zero update ($\\delta \\mathbf{K}_{ii} \\neq \\mathbf{0}$), calculate the perturbed inverse $(\\mathbf{K}'_{ii})^{-1}$ using the SMW formula. This involves:\n    a. Computing the small matrix $\\mathbf{M} = \\mathbf{C}^{-1} + \\mathbf{U}^\\top \\mathbf{K}_{ii}^{-1} \\mathbf{U}$.\n    b. Inverting $\\mathbf{M}$ to get $\\mathbf{M}^{-1}$.\n    c. Assembling the updated inverse $(\\mathbf{K}'_{ii})^{-1} = \\mathbf{K}_{ii}^{-1} - (\\mathbf{K}_{ii}^{-1} \\mathbf{U}) \\mathbf{M}^{-1} (\\mathbf{U}^\\top \\mathbf{K}_{ii}^{-1})$.\n4.  If there is no update, set $(\\mathbf{K}'_{ii})^{-1} = \\mathbf{K}_{ii}^{-1}$.\n5.  Form the perturbed condensed stiffness matrix $\\mathbf{S}' = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} (\\mathbf{K}'_{ii})^{-1} \\mathbf{K}_{ib}$.\n6.  Form the perturbed condensed force vector $\\mathbf{g}' = \\mathbf{f}_b - \\mathbf{K}_{bi} (\\mathbf{K}'_{ii})^{-1} \\mathbf{f}_i$.\n7.  Solve the small $2 \\times 2$ linear system $\\mathbf{S}' \\mathbf{u}_b = \\mathbf{g}'$ for the boundary displacement vector $\\mathbf{u}_b$.\n8.  The resulting displacements are in meters, as stiffness is in $\\mathrm{kN/m}$ and force is in $\\mathrm{kN}$. These will be rounded to six decimal places for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sub-structuring and static condensation problem for four \"what-if\" cases.\n    The solution involves deriving the condensed system, updating it with the\n    Sherman-Morrison-Woodbury identity for low-rank perturbations, and solving for\n    boundary displacements.\n    \"\"\"\n\n    # --- Step 1: Define baseline matrices from the problem statement ---\n    # Units: stiffness entries in kN/m\n    K_bb = np.array([\n        [1000, -200],\n        [-200, 800]\n    ])\n    K_bi = np.array([\n        [-150, 100, 0],\n        [50, -120, 80]\n    ])\n    K_ib = K_bi.T\n    K_ii = np.array([\n        [3000, -500, 0],\n        [-500, 2000, -400],\n        [0, -400, 1500]\n    ])\n\n    # --- Step 2: Define the test suite for the four cases ---\n    # Units: forces in kN, stiffness update in kN/m\n    test_cases = [\n        # Case 1: baseline, happy path\n        {\n            \"U\": None,\n            \"C\": None,\n            \"f_b\": np.array([10, -5]),\n            \"f_i\": np.array([0, 0, 0])\n        },\n        # Case 2: rank-1 positive update\n        {\n            \"U\": np.array([[1], [0], [0]]),\n            \"C\": np.array([[200]]),\n            \"f_b\": np.array([10, -5]),\n            \"f_i\": np.array([0, 0, 0])\n        },\n        # Case 3: rank-2 mixed update with internal loads\n        {\n            \"U\": np.array([[0, 0], [1, 0], [0, 1]]),\n            \"C\": np.array([[100, 0], [0, -50]]),\n            \"f_b\": np.array([12, 8]),\n            \"f_i\": np.array([5, -10, 15])\n        },\n        # Case 4: zero boundary loads, rank-1 isotropic direction\n        {\n            \"U\": np.array([[1], [1], [1]]),\n            \"C\": np.array([[300]]),\n            \"f_b\": np.array([0, 0]),\n            \"f_i\": np.array([20, -5, 10])\n        }\n    ]\n\n    # --- Step 3: Perform calculations ---\n\n    # Compute the baseline inverse of K_ii once.\n    K_ii_inv = np.linalg.inv(K_ii)\n\n    results = []\n    for case in test_cases:\n        U = case[\"U\"]\n        C = case[\"C\"]\n        f_b = case[\"f_b\"]\n        f_i = case[\"f_i\"]\n\n        K_ii_p_inv = None # Perturbed inverse\n        \n        # Check if there is an update\n        if U is None or C is None:\n            # Case 1: No update, use baseline inverse\n            K_ii_p_inv = K_ii_inv\n        else:\n            # Cases 2, 3, 4: Update K_ii_inv using Sherman-Morrison-Woodbury\n            # (K_ii + UCU^T)^-1 = K_ii^-1 - K_ii^-1 U (C^-1 + U^T K_ii^-1 U)^-1 U^T K_ii^-1\n            C_inv = np.linalg.inv(C)\n            M = C_inv + U.T @ K_ii_inv @ U\n            M_inv = np.linalg.inv(M)\n            \n            # Efficiently calculate update term\n            Kii_inv_U = K_ii_inv @ U\n            update_term = Kii_inv_U @ M_inv @ Kii_inv_U.T\n            \n            K_ii_p_inv = K_ii_inv - update_term\n\n        # Form the condensed stiffness matrix S'\n        S_prime = K_bb - K_bi @ K_ii_p_inv @ K_ib\n\n        # Form the condensed force vector g'\n        g_prime = f_b - K_bi @ K_ii_p_inv @ f_i\n\n        # Solve the condensed system S' * u_b = g' for boundary displacements u_b\n        u_b = np.linalg.solve(S_prime, g_prime)\n\n        # Append results, rounded to six decimal places, to the list\n        results.extend(u_b)\n\n    # Format the final output string as required\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}