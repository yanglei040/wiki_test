{
    "hands_on_practices": [
        {
            "introduction": "本实践将指导您完成一个针对常见岩土工程问题的完整蒙特卡洛模拟：评估基坑开挖的稳定性。您将学习如何通过结合用于模拟土层序列的马尔可夫链和通过贝叶斯更新融合现场 CPT 数据，来构建一个随机地质模型。本练习展示了如何将地质不确定性与场地勘察数据相结合，从而对工程性能进行概率分析。()",
            "id": "3544647",
            "problem": "您的任务是构建一个完整、可运行的程序，该程序使用马尔可夫链模型，根据锥形贯入试验 (CPT) 的测量结果生成随机地层序列，从而对基坑围护墙的侧向变形超越概率进行蒙特卡洛分析。其科学基础必须明确：地层序列被建模为符合 Kolmogorov 性质的离散时间马尔可夫链；基于 CPT 测量的条件化使用了带有似然模型的 Bayes 定理；侧向土体反力被理想化为服从 Hooke 定律的 Winkler 地基。墙体侧向变形通过运动学上限定法进行近似，该方法基于平衡原理和虚功原理，并假定一个均匀的位移模式。\n\n以下元素定义了建模假设和数据。\n\n1. 状态与马尔可夫链。考虑三种土体状态 $S=\\{\\mathrm{SC},\\mathrm{S},\\mathrm{STC}\\}$，其中 $\\mathrm{SC}$ 表示软黏土，$\\mathrm{S}$ 表示砂土，$\\mathrm{STC}$ 表示硬黏土。沿深度索引为 $i=1,\\dots,n$ 的地层由序列 $s_1,\\dots,s_n$ 表示，其中 $s_i \\in S$。设马尔可夫链转移矩阵为 $T\\in\\mathbb{R}^{3\\times 3}$，其中 $T_{ab}=\\mathbb{P}(s_i=b\\mid s_{i-1}=a)$，对于 $a,b\\in S$；初始分布为 $\\pi\\in\\mathbb{R}^3$，其中 $\\pi_a=\\mathbb{P}(s_1=a)$。该马尔可夫链假设满足 Kolmogorov 性质 $\\mathbb{P}(s_i\\mid s_{i-1},\\dots,s_1)=\\mathbb{P}(s_i\\mid s_{i-1})$。\n\n2. CPT 观测与似然模型。对于每个深度索引 $i$，给定一个观测向量 $o_i=[q_{c,i},R_{f,i}]$，其中 $q_{c,i}$ 是以兆帕 (MPa) 为单位的 CPT 锥尖阻力，$R_{f,i}$ 是以小数形式表示的摩阻比（例如，$0.02$ 对应于 $2\\%$）。在给定状态 $s_i$ 的条件下，观测到 $o_i$ 的条件似然被建模为具有对角协方差的二元高斯分布，\n$$\n\\mathcal{L}(o_i\\mid s_i=a)=\\prod_{j=1}^{2}\\frac{1}{\\sqrt{2\\pi}\\,\\sigma_{a,j}}\\exp\\!\\left(-\\frac{(o_{i,j}-\\mu_{a,j})^2}{2\\sigma_{a,j}^2}\\right),\n$$\n其中 $\\mu_{a}=[\\mu_{a,1},\\mu_{a,2}]$ 和 $\\sigma_{a}=[\\sigma_{a,1},\\sigma_{a,2}]$ 分别是状态 $a$ 的均值和标准差，且 $o_{i,1}=q_{c,i}$ 和 $o_{i,2}=R_{f,i}$。\n\n3. 条件马尔可夫链采样。对于 $i=1$，根据 Bayes 定理，给定 $o_1$ 时 $s_1$ 的后验概率满足\n$$\n\\mathbb{P}(s_1=a\\mid o_1)\\propto \\pi_a\\,\\mathcal{L}(o_1\\mid s_1=a).\n$$\n对于 $i\\geq 2$，以先前采样状态为条件的单步后验概率使用\n$$\n\\mathbb{P}(s_i=b\\mid s_{i-1}=a,o_i)\\propto T_{ab}\\,\\mathcal{L}(o_i\\mid s_i=b),\n$$\n并且对每个深度，从该分类分布中进行 $s_i$ 的采样。\n\n4. Winkler 地基与等效刚度。侧向土体反力被理想化为 Winkler 地基，其地基反力系数为 $k(z)$（单位为 $\\mathrm{N}/\\mathrm{m}^3$）。对于沿墙高 $H$ 的均匀侧向位移模式 $\\delta$，分布力的平衡要求\n$$\np_e H = \\delta \\int_{0}^{H}k(z)\\,\\mathrm{d}z,\n$$\n其中 $p_e$ 是作用在墙上的均匀开挖引起的侧向压力（单位为 $\\mathrm{Pa}$）。求解侧向变形得到\n$$\n\\delta = \\frac{p_e H}{\\int_{0}^{H}k(z)\\,\\mathrm{d}z}.\n$$\n将墙体离散化为 $n$ 个厚度为 $\\Delta z = H/n$ 的土层，其中 $k(z)$ 在第 $i$ 个区间上是分段常数，值为 $k_i$，则积分变为 $\\int_0^H k(z)\\,\\mathrm{d}z \\approx \\sum_{i=1}^{n}k_i\\,\\Delta z$。\n\n5. 通过约束模量从 CPT 推算地基反力。对于深度索引为 $i$、状态为 $s_i=a$ 的土层，地基反力系数与约束模量 $M_i$ 相关联，即\n$$\nk_i = \\beta_{a}\\,M_i,\\quad M_i=c_{M,a}\\,q_{c,i},\n$$\n其中，在计算 $M_i$ 时，$q_{c,i}$ 从 $\\mathrm{MPa}$ 转换为 $\\mathrm{Pa}$，$c_{M,a}$ 是一个依赖于土体状态的无量纲相关系数，$\\beta_a$ 的单位是 $\\mathrm{m}^{-1}$，代表一个几何比例因子，以获得 $\\mathrm{N}/\\mathrm{m}^3$ 的单位。常数 $c_{M,a}$ 和 $\\beta_a$ 在下方提供。\n\n6. 蒙特卡洛超越概率。对于每次蒙特卡洛模拟，根据 CPT 测量结果采样一个地层序列 $s_1,\\dots,s_n$，使用离散化公式计算 $\\delta$，并记录 $\\delta$ 是否大于指定的阈值 $\\delta_{\\mathrm{th}}$（单位为米）。超越概率是 $\\delta\\delta_{\\mathrm{th}}$ 的模拟复制所占的比例。\n\n使用以下适用于所有测试用例的状态和似然的固定参数来实现上述算法：\n- 状态 $a\\in S$ 的均值 $\\mu_a$ 和标准差 $\\sigma_a$：\n  - 软黏土 ($\\mathrm{SC}$): $\\mu_{\\mathrm{SC}}=[1.5,0.04]$, $\\sigma_{\\mathrm{SC}}=[0.5,0.01]$。\n  - 砂土 ($\\mathrm{S}$): $\\mu_{\\mathrm{S}}=[12.0,0.01]$, $\\sigma_{\\mathrm{S}}=[3.0,0.004]$。\n  - 硬黏土 ($\\mathrm{STC}$): $\\mu_{\\mathrm{STC}}=[6.0,0.03]$, $\\sigma_{\\mathrm{STC}}=[1.5,0.008]$。\n- 地基反力相关常数：$c_{M,\\mathrm{SC}}=8$, $c_{M,\\mathrm{S}}=5$, $c_{M,\\mathrm{STC}}=10$，以及 $\\beta_{\\mathrm{SC}}=0.2\\,\\mathrm{m}^{-1}$, $\\beta_{\\mathrm{S}}=1.2\\,\\mathrm{m}^{-1}$, $\\beta_{\\mathrm{STC}}=0.6\\,\\mathrm{m}^{-1}$。\n- 角度单位不适用；所有需要物理单位的输出在计算中必须以米表示变形，以帕斯卡 ($\\mathrm{Pa}$) 表示压力。\n\n测试套件。您的程序必须计算以下三个测试用例的超越概率。在所有情况下，CPT 数据都有 $n=20$ 个深度点；墙高 $H$ 和压力 $p_e$ 已指定，并且必须使用 $\\Delta z = H/n$。所有 CPT $q_{c,i}$ 值以 $\\mathrm{MPa}$ 为单位，所有 $R_{f,i}$ 值为小数。所有概率必须以小数形式返回。\n\n- 测试用例 $\\mathrm{A}$ (混合地层，中等转移概率):\n  - 墙高: $H=10$ 米。\n  - 侧向压力: $p_e=50{,}000$ 帕斯卡 (即 $50$ 千帕)。\n  - 初始分布: $\\pi=[0.4,0.4,0.2]$ 对应于 $[\\mathrm{SC},\\mathrm{S},\\mathrm{STC}]$。\n  - 转移矩阵:\n    $$\n    T=\n    \\begin{bmatrix}\n    0.6  0.25  0.15\\\\\n    0.15  0.7  0.15\\\\\n    0.2  0.2  0.6\n    \\end{bmatrix}.\n    $$\n  - CPT 数组:\n    $$\n    q_c=[2.0,1.2,1.4,5.0,8.0,12.5,15.0,13.5,11.0,9.0,6.0,5.5,4.5,3.5,2.5,2.0,1.8,1.6,1.4,1.2],\n    $$\n    $$\n    R_f=[0.04,0.05,0.045,0.035,0.02,0.012,0.009,0.011,0.013,0.015,0.025,0.028,0.03,0.032,0.035,0.04,0.042,0.045,0.05,0.055].\n    $$\n  - 蒙特卡洛模拟次数: $N_{\\mathrm{MC}}=5000$。\n  - 变形阈值: $\\delta_{\\mathrm{th}}=0.002$ 米。\n\n- 测试用例 $\\mathrm{B}$ (砂土为主的 CPT，高持续性转移概率):\n  - 墙高: $H=12$ 米。\n  - 侧向压力: $p_e=40{,}000$ 帕斯卡。\n  - 初始分布: $\\pi=[0.2,0.7,0.1]$。\n  - 转移矩阵:\n    $$\n    T=\n    \\begin{bmatrix}\n    0.9  0.05  0.05\\\\\n    0.05  0.9  0.05\\\\\n    0.05  0.05  0.9\n    \\end{bmatrix}.\n    $$\n  - CPT 数组:\n    $$\n    q_c=[9.0,10.5,12.0,14.0,16.0,18.0,20.0,18.0,16.0,14.0,12.0,10.0,9.0,8.0,7.0,7.5,8.5,9.5,10.5,11.5],\n    $$\n    $$\n    R_f=[0.012,0.011,0.010,0.009,0.009,0.008,0.008,0.009,0.009,0.010,0.011,0.012,0.013,0.014,0.015,0.014,0.013,0.012,0.011,0.010].\n    $$\n  - 蒙特卡洛模拟次数: $N_{\\mathrm{MC}}=3000$。\n  - 变形阈值: $\\delta_{\\mathrm{th}}=0.0015$ 米。\n\n- 测试用例 $\\mathrm{C}$ (黏土为主的 CPT，中等转移概率，小样本):\n  - 墙高: $H=10$ 米。\n  - 侧向压力: $p_e=80{,}000$ 帕斯卡。\n  - 初始分布: $\\pi=[0.6,0.2,0.2]$。\n  - 转移矩阵:\n    $$\n    T=\n    \\begin{bmatrix}\n    0.7  0.15  0.15\\\\\n    0.3  0.4  0.3\\\\\n    0.25  0.2  0.55\n    \\end{bmatrix}.\n    $$\n  - CPT 数组:\n    $$\n    q_c=[1.0,1.2,1.1,1.3,1.5,1.6,1.7,1.8,1.9,2.0,2.0,1.9,1.8,1.7,1.6,1.5,1.4,1.3,1.2,1.1],\n    $$\n    $$\n    R_f=[0.055,0.05,0.052,0.048,0.045,0.043,0.042,0.040,0.038,0.036,0.037,0.039,0.041,0.043,0.045,0.047,0.05,0.052,0.054,0.056].\n    $$\n  - 蒙特卡洛模拟次数: $N_{\\mathrm{MC}}=200$。\n  - 变形阈值: $\\delta_{\\mathrm{th}}=0.005$ 米。\n\n程序要求：\n- 使用固定的伪随机数种子以确保可复现性。\n- 使用为 $s_1$ 和 $i\\geq 2$ 时的 $s_i$ 定义的后验分类分布进行采样。\n- 在计算 $M_i$ 之前，将 $q_c$ 从 $\\mathrm{MPa}$ 转换为 $\\mathrm{Pa}$；每个测试用例使用 $\\Delta z=H/n$。\n- 对于每个测试用例，报告超越概率 $\\mathbb{P}(\\delta\\delta_{\\mathrm{th}})$，结果为小数，四舍五入至小数点后 $5$ 位。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表（例如，$[r_A,r_B,r_C]$），其中 $r_A,r_B,r_C$ 分别是测试用例 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 的超越概率。\n\n所有数值答案在适用时必须以国际单位制表示，计算中变形单位为米，压力单位为帕斯卡。最后打印的行必须只包含方括号列表，其中的小数四舍五入到小数点后 $5$ 位。",
            "solution": "该问题要求构建一个蒙特卡洛模拟，以估计开挖支护墙的侧向变形超过给定阈值的概率。这是一个岩土可靠性分析问题，整合了随机过程、贝叶斯推断和土力学的概念。解决方案的结构是首先定义每个组件的理论模型，然后概述模拟的计算算法。\n\n### 理论框架\n\n该解决方案基于三个相互关联的模型：地层剖面的随机模型、墙-土相互作用的岩土模型以及从测量中推断土体类型的概率模型。\n\n**1. 随机地层学：离散时间马尔可夫链**\n\n土体剖面被理想化为一系列离散的土层，每个土层属于三种状态之一，$S=\\{\\mathrm{SC}, \\mathrm{S}, \\mathrm{STC}\\}$，分别代表软黏土、砂土和硬黏土。随深度变化的土体状态序列 $s_1, s_2, \\dots, s_n$ 被建模为一阶离散时间马尔可夫链。该模型由两个部分表征：\n- 一个初始概率分布 $\\pi \\in \\mathbb{R}^3$，其中 $\\pi_a = \\mathbb{P}(s_1=a)$ 给出了第一层为土体类型 $a \\in S$ 的概率。\n- 一个转移矩阵 $T \\in \\mathbb{R}^{3 \\times 3}$，其中条目 $T_{ab} = \\mathbb{P}(s_i=b \\mid s_{i-1}=a)$ 是在一个深度步长内从状态 $a$ 转换到状态 $b$ 的概率。\n该模型遵循马尔可夫 (Kolmogorov) 性质，意味着任何土层 $s_i$ 的状态仅取决于紧邻其上的土层 $s_{i-1}$ 的状态，即 $\\mathbb{P}(s_i \\mid s_{i-1}, \\dots, s_1) = \\mathbb{P}(s_i \\mid s_{i-1})$。\n\n**2. 基于 CPT 数据的贝叶斯推断**\n\n通过将马尔可夫模型以原位锥形贯入试验 (CPT) 测量为条件，可以减少地层剖面的不确定性。在每个深度索引 $i$ 处，都有一个观测向量 $o_i = [q_{c,i}, R_{f,i}]$，由锥尖阻力 $q_{c,i}$ 和摩阻比 $R_{f,i}$ 组成。观测值 $o_i$ 和土体状态 $s_i$ 之间的联系由一个似然模型 $\\mathcal{L}(o_i \\mid s_i=a)$ 给出。该似然被建模为一个具有对角协方差矩阵的二元高斯分布：\n$$\n\\mathcal{L}(o_i \\mid s_i=a) = \\mathcal{N}(o_{i,1} \\mid \\mu_{a,1}, \\sigma_{a,1}^2) \\cdot \\mathcal{N}(o_{i,2} \\mid \\mu_{a,2}, \\sigma_{a,2}^2) = \\prod_{j=1}^{2}\\frac{1}{\\sqrt{2\\pi}\\,\\sigma_{a,j}}\\exp\\!\\left(-\\frac{(o_{i,j}-\\mu_{a,j})^2}{2\\sigma_{a,j}^2}\\right)\n$$\n其中 $[\\mu_{a,1}, \\mu_{a,2}]$ 和 $[\\sigma_{a,1}, \\sigma_{a,2}]$ 是 CPT 测量的状态相关均值和标准差。\n\nBayes 定理用于更新每个深度的土体状态概率。这定义了条件模拟的采样分布：\n- 对于第一层 ($i=1$)，状态 $s_1=a$ 的后验概率与先验概率和似然的乘积成正比：\n$$\n\\mathbb{P}(s_1=a \\mid o_1) \\propto \\pi_a \\mathcal{L}(o_1 \\mid s_1=a)\n$$\n- 对于后续层 ($i \\ge 2$)，给定先前采样的状态 $s_{i-1}=a$ 和当前观测值 $o_i$，状态 $s_i=b$ 的后验概率为：\n$$\n\\mathbb{P}(s_i=b \\mid s_{i-1}=a, o_i) \\propto T_{ab} \\mathcal{L}(o_i \\mid s_i=b)\n$$\n在每个步骤中，通过确保所有可能状态的概率总和为一来解决比例关系。\n\n**3. 岩土模型：Winkler 地基与墙体变形**\n\n抵抗墙体移动的土体力学行为使用 Winkler 地基模型进行简化。土体被表示为一系列独立的线性弹性弹簧，其地基反力系数 $k(z)$ 的单位为力每单位面积每单位位移 ($\\mathrm{N/m^3}$)。对于墙体的均匀侧向位移 $\\delta$，虚功原理（或简单的力平衡）规定，外压力所做的功必须等于储存在土弹簧中的能量。对于在高度为 $H$ 的墙上作用的均匀开挖引起的压力 $p_e$，此平衡表示为：\n$$\np_e H = \\delta \\int_{0}^{H} k(z) \\, \\mathrm{d}z\n$$\n求解变形 $\\delta$ 得到：\n$$\n\\delta = \\frac{p_e H}{\\int_{0}^{H} k(z) \\, \\mathrm{d}z}\n$$\n积分在 $n$ 个土层上离散化，每个土层厚度为 $\\Delta z = H/n$。假设地基反力系数 $k_i$ 在每个土层 $i$ 内是恒定的，积分可以用一个和来近似：\n$$\n\\int_{0}^{H} k(z) \\, \\mathrm{d}z \\approx \\sum_{i=1}^{n} k_i \\Delta z\n$$\n给定土层的地基反力系数 $k_i$ 是根据其土体类型 $s_i=a$ 和 CPT 锥尖阻力 $q_{c,i}$ 通过标准的经验相关性确定的。首先，估算约束模量 $M_i$ 为 $M_i = c_{M,a} q_{c,i}$，其中 $c_{M,a}$ 是一个无量纲因子。然后，$k_i$ 通过 $k_i = \\beta_a M_i$ 与 $M_i$ 相关联，其中 $\\beta_a$ 是一个单位为 $\\mathrm{m}^{-1}$ 的比例因子。确保单位兼容至关重要；因此，以兆帕 ($\\mathrm{MPa}$) 为单位的 $q_{c,i}$ 必须通过乘以 $10^6$ 转换为帕斯卡 ($\\mathrm{Pa}$ 或 $\\mathrm{N/m^2}$)。\n\n### 蒙特卡洛模拟算法\n\n超越概率 $\\mathbb{P}(\\delta  \\delta_{\\mathrm{th}})$ 使用蒙特卡洛模拟进行估计。该过程涉及生成大量随机但有条件的地层剖面，并为每个剖面计算产生的变形。\n\n对于每个测试用例，总体算法如下：\n1.  **初始化**：设置模拟次数 $N_{\\mathrm{MC}}$，将超越计数器置零，并定义所有模型参数 ($H, p_e, \\pi, T, \\delta_{\\mathrm{th}}$ 等)。预先计算似然矩阵 $\\mathcal{L}_{ia} = \\mathcal{L}(o_i \\mid s_i=a)$，该矩阵适用于所有土层 $i=1,\\dots,n$ 和所有状态 $a \\in S$。\n2.  **模拟循环**：重复 $k=1, \\dots, N_{\\mathrm{MC}}$：\n    a.  **生成一个地层剖面**：\n        i.  对于土层 $i=1$：计算后验概率 $\\mathbb{P}(s_1=a \\mid o_1)$ 并从此分类分布中采样一个状态 $s_1$。\n        ii. 对于土层 $i=2, \\dots, n$：给定采样的状态 $s_{i-1}$，计算后验概率 $\\mathbb{P}(s_i=b \\mid s_{i-1}, o_i)$ 并采样一个状态 $s_i$。\n    b.  **计算墙体变形**：使用生成的地层剖面 $(s_1, \\dots, s_n)$ 和给定的 $q_c$ 数组，计算每层的地基反力系数 $k_i$。然后，使用离散化公式计算总墙体变形 $\\delta$：\n        $$\n        \\delta = \\frac{p_e H}{\\sum_{i=1}^{n} k_i \\Delta z} = \\frac{p_e n}{\\sum_{i=1}^{n} k_i}\n        $$\n    c.  **检查是否超越**：将计算出的变形 $\\delta$ 与阈值 $\\delta_{\\mathrm{th}}$ 进行比较。如果 $\\delta  \\delta_{\\mathrm{th}}$，则增加超越计数器。\n3.  **估计概率**：所有模拟完成后，超越概率估计为超越次数与总模拟次数之比：\n    $$\n    \\mathbb{P}(\\delta  \\delta_{\\mathrm{th}}) \\approx \\frac{\\text{超越计数器}}{\\text{N}_{\\mathrm{MC}}}\n    $$\n此过程应用于每个测试用例及其特定参数，以获得所需的概率。固定的随机种子确保结果是可复现的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run Monte Carlo simulations for all test cases and print the results.\n    \"\"\"\n    # Set a fixed seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(42)\n\n    # --- Fixed Parameters (common to all test cases) ---\n    # Map states to integer indices for array access\n    state_map = {'SC': 0, 'S': 1, 'STC': 2}\n    states = ['SC', 'S', 'STC']\n    n_states = len(states)\n\n    # Likelihood model parameters (mean and std. dev. for [qc, Rf])\n    # qc is in MPa, Rf is a decimal\n    means = np.array([\n        [1.5, 0.04],  # SC\n        [12.0, 0.01], # S\n        [3.0, 0.004]  # STC\n    ])\n    stds = np.array([\n        [0.5, 0.01],  # SC\n        [3.0, 0.004], # S - Note: problem statement has std_S = [3.0, 0.004] and std_STC = [1.5, 0.008]\n        [1.5, 0.008]  # STC\n    ])\n    \n    # Correction: The problem description for means_STC has a mismatch with the values for S and STC.\n    # The given values are: SC=[1.5,0.04] S=[12.0,0.01] STC=[6.0,0.03]\n    # And stds: SC=[0.5,0.01] S=[3.0,0.004] STC=[1.5,0.008]\n    # Re-aligning my matrix to the problem statement.\n    means = np.array([\n        [1.5, 0.04],  # SC\n        [12.0, 0.01], # S\n        [6.0, 0.03]   # STC\n    ])\n    \n    # Subgrade reaction correlation constants\n    c_M = np.array([8.0, 5.0, 10.0])   # Dimensionless, for SC, S, STC\n    beta = np.array([0.2, 1.2, 0.6])  # Units of 1/m, for SC, S, STC\n\n    def calculate_likelihoods(qc, Rf, n_layers):\n        \"\"\"\n        Calculates the likelihood of observations for each layer and each state.\n        L_ia = P(o_i | s_i = a)\n        \"\"\"\n        likelihoods = np.zeros((n_layers, n_states))\n        observations = np.stack([qc, Rf], axis=1)\n        for i in range(n_layers):\n            for j in range(n_states):\n                # Likelihood is the product of two independent Gaussian PDFs\n                lik_qc = norm.pdf(observations[i, 0], loc=means[j, 0], scale=stds[j, 0])\n                lik_Rf = norm.pdf(observations[i, 1], loc=means[j, 1], scale=stds[j, 1])\n                likelihoods[i, j] = lik_qc * lik_Rf\n        return likelihoods\n\n    def sample_stratigraphy(pi, T, likelihoods, n_layers):\n        \"\"\"\n        Samples one realization of the stratigraphic profile conditioned on observations.\n        \"\"\"\n        stratigraphy = np.zeros(n_layers, dtype=int)\n        \n        # Layer 1 (i=0)\n        unnormalized_posterior_s1 = pi * likelihoods[0, :]\n        posterior_s1 = unnormalized_posterior_s1 / np.sum(unnormalized_posterior_s1)\n        stratigraphy[0] = np.random.choice(n_states, p=posterior_s1)\n\n        # Layers 2 to n (i=1 to n-1)\n        for i in range(1, n_layers):\n            prev_state = stratigraphy[i-1]\n            prior = T[prev_state, :]\n            unnormalized_posterior_si = prior * likelihoods[i, :]\n            # Handle case where all probabilities are zero to avoid NaN\n            if np.sum(unnormalized_posterior_si) == 0:\n                 # This can happen if an observation is extremely unlikely under all states.\n                 # A uniform distribution is a reasonable fallback.\n                 posterior_si = np.full(n_states, 1.0 / n_states)\n            else:\n                 posterior_si = unnormalized_posterior_si / np.sum(unnormalized_posterior_si)\n            \n            stratigraphy[i] = np.random.choice(n_states, p=posterior_si)\n        \n        return stratigraphy\n\n    def calculate_deflection(stratigraphy, qc, H, pe, n_layers):\n        \"\"\"\n        Calculates wall deflection for a given stratigraphy.\n        \"\"\"\n        # Convert qc from MPa to Pa\n        qc_pa = qc * 1e6\n        \n        # Calculate subgrade reaction coefficients k_i for each layer\n        # k_i = beta[s_i] * c_M[s_i] * qc_pa[i]\n        k_values = beta[stratigraphy] * c_M[stratigraphy] * qc_pa\n        \n        # Calculate deflection using the discretized formula: delta = (pe * n) / sum(k_i)\n        sum_k = np.sum(k_values)\n        if sum_k == 0:\n            return np.inf  # Avoid division by zero\n        \n        delta = (pe * n_layers) / sum_k\n        return delta\n\n\n    def run_monte_carlo(params):\n        \"\"\"\n        Runs the full Monte Carlo simulation for a single test case.\n        \"\"\"\n        H = params['H']\n        pe = params['pe']\n        pi = np.array(params['pi'])\n        T = np.array(params['T'])\n        qc = np.array(params['qc'])\n        Rf = np.array(params['Rf'])\n        N_MC = params['N_MC']\n        delta_th = params['delta_th']\n        n_layers = 20\n\n        # Pre-compute likelihoods as they are constant for all replications\n        likelihoods = calculate_likelihoods(qc, Rf, n_layers)\n\n        exceedance_count = 0\n        for _ in range(N_MC):\n            # 1. Sample a stratigraphic profile\n            stratigraphy = sample_stratigraphy(pi, T, likelihoods, n_layers)\n            \n            # 2. Calculate wall deflection\n            delta = calculate_deflection(stratigraphy, qc, H, pe, n_layers)\n            \n            # 3. Check for exceedance\n            if delta  delta_th:\n                exceedance_count += 1\n        \n        # 4. Estimate probability\n        probability = exceedance_count / N_MC\n        return probability\n\n    test_cases = [\n        {\n            'name': 'A',\n            'H': 10, 'pe': 50000,\n            'pi': [0.4, 0.4, 0.2],\n            'T': [[0.6, 0.25, 0.15], [0.15, 0.7, 0.15], [0.2, 0.2, 0.6]],\n            'qc': [2.0, 1.2, 1.4, 5.0, 8.0, 12.5, 15.0, 13.5, 11.0, 9.0, 6.0, 5.5, 4.5, 3.5, 2.5, 2.0, 1.8, 1.6, 1.4, 1.2],\n            'Rf': [0.04, 0.05, 0.045, 0.035, 0.02, 0.012, 0.009, 0.011, 0.013, 0.015, 0.025, 0.028, 0.03, 0.032, 0.035, 0.04, 0.042, 0.045, 0.05, 0.055],\n            'N_MC': 5000, 'delta_th': 0.002\n        },\n        {\n            'name': 'B',\n            'H': 12, 'pe': 40000,\n            'pi': [0.2, 0.7, 0.1],\n            'T': [[0.9, 0.05, 0.05], [0.05, 0.9, 0.05], [0.05, 0.05, 0.9]],\n            'qc': [9.0, 10.5, 12.0, 14.0, 16.0, 18.0, 20.0, 18.0, 16.0, 14.0, 12.0, 10.0, 9.0, 8.0, 7.0, 7.5, 8.5, 9.5, 10.5, 11.5],\n            'Rf': [0.012, 0.011, 0.010, 0.009, 0.009, 0.008, 0.008, 0.009, 0.009, 0.010, 0.011, 0.012, 0.013, 0.014, 0.015, 0.014, 0.013, 0.012, 0.011, 0.010],\n            'N_MC': 3000, 'delta_th': 0.0015\n        },\n        {\n            'name': 'C',\n            'H': 10, 'pe': 80000,\n            'pi': [0.6, 0.2, 0.2],\n            'T': [[0.7, 0.15, 0.15], [0.3, 0.4, 0.3], [0.25, 0.2, 0.55]],\n            'qc': [1.0, 1.2, 1.1, 1.3, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.0, 1.9, 1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1],\n            'Rf': [0.055, 0.05, 0.052, 0.048, 0.045, 0.043, 0.042, 0.040, 0.038, 0.036, 0.037, 0.039, 0.041, 0.043, 0.045, 0.047, 0.05, 0.052, 0.054, 0.056],\n            'N_MC': 200, 'delta_th': 0.005\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        prob = run_monte_carlo(case)\n        results.append(f\"{prob:.5f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本方法之后，本实践将探索一个更高级的场景：使用 Neyman-Scott 空间点过程对三维空间中离散、聚集的地质异常体进行建模。您将模拟隧道因与这些软弱带相交而发生坍塌的风险，并且更重要的是，您将使用似然比法来计算坍塌概率对关键地质参数的敏感度。本练习不仅教您如何预测风险，还教您如何识别哪些不确定性因素对风险影响最大。()",
            "id": "3544703",
            "problem": "考虑一个三维域，该域在无量纲单位下被建模为一个边长为 $A$ 的立方体，并赋有周期性边界条件（一个三维环面）。软弱材料透镜体被建模为由三维 Neyman–Scott 丛集点过程（也称为泊松丛集过程）生成的球状夹杂体。一条半径为 $r_{\\mathrm{t}}$、长度为 $L$ 的笔直圆形隧道位于该域的中心，并与 $z$ 轴对齐。\n\nNeyman–Scott 过程的构建如下。母点由强度为 $\\lambda_{\\mathrm{p}}$（单位体积内母点的期望数量）的均匀泊松点过程生成。以母点为条件，每个母点 $i$ 产生泊松分布的子代数量 $K_i$，其均值为 $\\mu_{\\mathrm{c}}$，且各母点之间相互独立。每个子代从其母点位置发生一个独立同分布的三维高斯偏移，该偏移在每个坐标上的均值为零，标准差为 $\\sigma$，然后使用周期性边界将其位置包裹回立方体域内。假设在给定参数的情况下，所有随机元素相互独立。\n\n每个子代点代表一个半径固定为 $r_{\\ell}$ 的球形软弱透镜体的中心。定义一个简单的稳定性指数 $S$ 为 $S = 1 - \\beta M$，其中 $M$ 是其球体与隧道实体相交的软弱透镜体的数量，而 $\\beta$ 是一个无量纲的弱化因子。假设隧道占据了径向距离 $\\sqrt{x^2 + y^2} \\le r_{\\mathrm{t}}$ 且轴向坐标 $|z| \\le L/2$ 的点集；一个中心为 $(x,y,z)$、半径为 $r_{\\ell}$ 的球形透镜体与隧道相交，当且仅当同时满足以下两个条件：$\\sqrt{x^2 + y^2} \\le r_{\\mathrm{t}} + r_{\\ell}$ 和 $|z| \\le L/2 + r_{\\ell}$。当且仅当 $S \\le 0$ 时，判定为发生坍塌事件。\n\n您的任务是设计并实现一个蒙特卡洛模拟，以针对指定的参数集估计以下内容：\n- 坍塌概率 $P_{\\mathrm{col}}(\\lambda_{\\mathrm{p}}, \\mu_{\\mathrm{c}})$。\n- 坍塌概率相对于母点强度的灵敏度 $\\partial P_{\\mathrm{col}} / \\partial \\lambda_{\\mathrm{p}}$。\n- 坍塌概率相对于每个母点平均子代数的灵敏度 $\\partial P_{\\mathrm{col}} / \\partial \\mu_{\\mathrm{c}}$。\n\n您必须使用从 Neyman–Scott 过程的概率法则推导出的似然比（得分函数）方法。将高斯离散和空间包裹处理为不依赖于 $\\lambda_{\\mathrm{p}}$ 或 $\\mu_{\\mathrm{c}}$。使用周期性边界条件以避免边缘效应。所有量均为无量纲。在所有测试用例中使用相同的伪随机种子，以确保结果可复现。\n\n您可以使用的基础理论：\n- 在体积 $V$ 上的均匀泊松点过程，其点数 $N$ 服从均值为 $\\lambda V$ 的泊松分布，其对数似然贡献为 $N \\log(\\lambda V) - \\lambda V - \\log(N!)$。\n- 以母点为条件，每个母点的独立泊松子代计数，其对数似然贡献为 $\\sum_{i=1}^{N_{\\mathrm{p}}} \\left( K_i \\log \\mu_{\\mathrm{c}} - \\mu_{\\mathrm{c}} - \\log (K_i!) \\right)$。\n- 对于似然比灵敏度，对于参数 $\\theta$，有 $\\partial \\mathbb{E}[H]/\\partial \\theta = \\mathbb{E}\\left[H \\cdot \\partial \\log f(X;\\theta)/\\partial \\theta \\right]$，其中 $H$ 是任意可积泛函，$f$ 是采样密度。\n\n蒙特卡洛模拟要求：\n- 针对每个测试用例，实现一个具有固定独立重复次数 $N_{\\mathrm{mc}}$ 的模拟。在每次重复中，生成立方体域内 Neyman–Scott 过程的一个实现，计算坍塌指示符（坍塌时为 1，否则为 0），并计算从母点和子代计数的泊松分布中导出的关于 $\\lambda_{\\mathrm{p}}$ 和 $\\mu_{\\mathrm{c}}$ 的得分函数权重。进行适当的平均以估计概率及其两个灵敏度。\n- 使用单个伪随机种子 $s$ 初始化生成器。为了在不同测试用例间实现多样化，同时保持可复现性，您可以将测试用例的索引加到 $s$ 上。\n- 对子代位置使用周期性边界包裹：对于每个坐标 $u \\in \\{x,y,z\\}$，包裹后的坐标为 $u_{\\mathrm{wrapped}} = \\left(\\left(u + A/2\\right) \\bmod A\\right) - A/2$。\n\n测试套件：\n使用 $N_{\\mathrm{mc}} = 5000$ 和公共种子 $s = 12345$。对于所有情况，域是边长为 $A = 10$ 的立方体，因此体积为 $V = A^3$。隧道参数为中心在原点，轴线沿 $z$ 轴。\n\n提供四组参数集以测试不同的机制：\n- 情况 1（中等丛集）：$\\lambda_{\\mathrm{p}} = 0.02$, $\\mu_{\\mathrm{c}} = 10$, $\\sigma = 0.3$, $r_{\\ell} = 0.2$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 0.5$。\n- 情况 2（稀疏丛集）：$\\lambda_{\\mathrm{p}} = 0.001$, $\\mu_{\\mathrm{c}} = 2$, $\\sigma = 0.4$, $r_{\\ell} = 0.2$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 0.5$。\n- 情况 3（密集丛集，紧密丛集）：$\\lambda_{\\mathrm{p}} = 0.02$, $\\mu_{\\mathrm{c}} = 30$, $\\sigma = 0.1$, $r_{\\ell} = 0.2$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 0.5$。\n- 情况 4（存在主导的破坏）：$\\lambda_{\\mathrm{p}} = 0.015$, $\\mu_{\\mathrm{c}} = 5$, $\\sigma = 0.25$, $r_{\\ell} = 0.25$, $r_{\\mathrm{t}} = 0.5$, $L = 8$, $\\beta = 1.0$。\n\n输出规格：\n- 对于每个测试用例，计算三个实数：坍塌概率的蒙特卡洛估计值、$\\partial P_{\\mathrm{col}}/\\partial \\lambda_{\\mathrm{p}}$ 的蒙特卡洛估计值，以及 $\\partial P_{\\mathrm{col}}/\\partial \\mu_{\\mathrm{c}}$ 的蒙特卡洛估计值。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表按上述顺序包含三个浮点数，并用方括号括起来。例如，您的输出格式必须与此完全相同：`[[p1,dpl1,dpm1],[p2,dpl2,dpm2],[p3,dpl3,dpm3],[p4,dpl4,dpm4]]`，其中每个符号表示一个已定义的浮点数。\n\n所有答案都是无量纲实数，您必须严格按照测试套件中给定的参数进行计算。不应读取任何其他输入。",
            "solution": "用户提供了一个定义明确的计算地质力学问题，要求使用蒙特卡洛模拟来估计隧道坍塌概率及其灵敏度。该问题有科学依据、内容自洽且算法明确，因此被认定为有效。\n\n### I. 基于原理的解决方案设计\n\n核心任务是估计一个随机过程函数的期望，以及该期望相对于该过程两个参数的灵敏度。该随机过程是一个 Neyman-Scott 丛集过程，用于模拟软弱材料透镜体的空间分布。该函数是隧道坍塌事件的指示函数。参数是母点强度 $\\lambda_{\\mathrm{p}}$ 和每个母点的平均子代数 $\\mu_{\\mathrm{c}}$。\n\n设 $X$ 代表 Neyman-Scott 过程的单个实现，包括所有生成的透镜体的数量和位置。设 $H(X)$ 为坍塌指示函数，其中如果发生坍塌 $H(X)=1$，否则 $H(X)=0$。坍塌概率为 $P_{\\mathrm{col}} = \\mathbb{E}[H(X)]$。问题要求计算此概率及其灵敏度 $\\partial P_{\\mathrm{col}}/\\partial \\lambda_{\\mathrm{p}}$ 和 $\\partial P_{\\mathrm{col}}/\\partial \\mu_{\\mathrm{c}}$。\n\n似然比法（也称为得分函数法）是指定的技术。该方法利用了以下恒等式：对于一个参数 $\\theta$ 和一个概率分布族 $f(x; \\theta)$，一个期望的导数可以表示为另一个期望：\n$$\n\\frac{\\partial}{\\partial \\theta} \\mathbb{E}[H(X)] = \\frac{\\partial}{\\partial \\theta} \\int H(x) f(x; \\theta) dx = \\int H(x) \\frac{\\partial f(x; \\theta)}{\\partial \\theta} dx\n$$\n假设满足允许在积分号下求导的正则性条件，我们可以写出：\n$$\n\\int H(x) \\left( \\frac{1}{f(x; \\theta)} \\frac{\\partial f(x; \\theta)}{\\partial \\theta} \\right) f(x; \\theta) dx = \\int H(x) \\frac{\\partial \\log f(x; \\theta)}{\\partial \\theta} f(x; \\theta) dx = \\mathbb{E}\\left[H(X) \\frac{\\partial \\log f(X; \\theta)}{\\partial \\theta}\\right]\n$$\n项 $W_{\\theta}(X) = \\frac{\\partial \\log f(X; \\theta)}{\\partial \\theta}$ 被称为得分函数或似然比权重。\n\n### II. 得分函数的推导\n\n过程中依赖于参数 $\\lambda_{\\mathrm{p}}$ 和 $\\mu_{\\mathrm{c}}$ 的随机元素是母点和子代的数量。\n1. 在体积为 $V=A^3$ 的域中，母点数 $N_{\\mathrm{p}}$ 服从均值为 $\\lambda_{\\mathrm{p}} V$ 的泊松分布。其概率质量函数为 $P(N_{\\mathrm{p}}=n) = \\frac{(\\lambda_{\\mathrm{p}}V)^n e^{-\\lambda_{\\mathrm{p}}V}}{n!}$。\n2. 在给定 $N_{\\mathrm{p}}$ 的条件下，每个母点 $i=1, \\dots, N_{\\mathrm{p}}$ 的子代数 $K_i$ 独立地服从均值为 $\\mu_{\\mathrm{c}}$ 的泊松分布。其概率质量函数为 $P(K_i=k) = \\frac{\\mu_{\\mathrm{c}}^k e^{-\\mu_{\\mathrm{c}}}}{k!}$。\n\n计数 $(N_{\\mathrm{p}}, K_1, \\dots, K_{N_{\\mathrm{p}}})$ 的联合对数似然是各个过程对数似然的总和：\n$$\n\\mathcal{L} = \\log P(N_{\\mathrm{p}}) + \\sum_{i=1}^{N_{\\mathrm{p}}} \\log P(K_i)\n$$\n使用泊松对数似然的标准形式 $\\log P(k|\\lambda) = k \\log \\lambda - \\lambda - \\log(k!)$，我们有：\n$$\n\\mathcal{L}(\\lambda_{\\mathrm{p}}, \\mu_{\\mathrm{c}}) = (N_{\\mathrm{p}} \\log(\\lambda_{\\mathrm{p}} V) - \\lambda_{\\mathrm{p}} V - \\log(N_{\\mathrm{p}}!)) + \\sum_{i=1}^{N_{\\mathrm{p}}} (K_i \\log \\mu_{\\mathrm{c}} - \\mu_{\\mathrm{c}} - \\log(K_i!))\n$$\n问题明确指出其他随机元素（位置）不依赖于 $\\lambda_{\\mathrm{p}}$ 或 $\\mu_{\\mathrm{c}}$，因此它们的似然项对关于这些参数的导数没有贡献。\n\n关于 $\\lambda_{\\mathrm{p}}$ 的得分函数是 $\\mathcal{L}$ 关于 $\\lambda_{\\mathrm{p}}$ 的偏导数：\n$$\nW_{\\lambda_{\\mathrm{p}}} = \\frac{\\partial \\mathcal{L}}{\\partial \\lambda_{\\mathrm{p}}} = \\frac{\\partial}{\\partial \\lambda_{\\mathrm{p}}} (N_{\\mathrm{p}} \\log \\lambda_{\\mathrm{p}} + N_{\\mathrm{p}} \\log V - \\lambda_{\\mathrm{p}} V) = \\frac{N_{\\mathrm{p}}}{\\lambda_{\\mathrm{p}}} - V\n$$\n关于 $\\mu_{\\mathrm{c}}$ 的得分函数是 $\\mathcal{L}$ 关于 $\\mu_{\\mathrm{c}}$ 的偏导数：\n$$\nW_{\\mu_{\\mathrm{c}}} = \\frac{\\partial \\mathcal{L}}{\\partial \\mu_{\\mathrm{c}}} = \\frac{\\partial}{\\partial \\mu_{\\mathrm{c}}} \\left( \\log \\mu_{\\mathrm{c}} \\sum_{i=1}^{N_{\\mathrm{p}}} K_i - N_{\\mathrm{p}} \\mu_{\\mathrm{c}} \\right) = \\frac{1}{\\mu_{\\mathrm{c}}} \\sum_{i=1}^{N_{\\mathrm{p}}} K_i - N_{\\mathrm{p}}\n$$\n令 $M_{\\mathrm{total}} = \\sum_{i=1}^{N_{\\mathrm{p}}} K_i$ 为生成的子代（透镜体）总数。得分函数简化为 $W_{\\mu_{\\mathrm{c}}} = \\frac{M_{\\mathrm{total}}}{\\mu_{\\mathrm{c}}} - N_{\\mathrm{p}}$。\n\n### III. 蒙特卡洛估计量\n\n通过使用具有 $N_{\\mathrm{mc}}$ 次独立重复实验的蒙特卡洛模拟，我们生成样本 $(X_j)_{j=1}^{N_{\\mathrm{mc}}}$。对于每次重复实验 $j$，我们计算坍塌指示符 $H_j = H(X_j)$ 和得分函数 $W_{\\lambda_{\\mathrm{p}}, j}$ 与 $W_{\\mu_{\\mathrm{c}}, j}$。所需量的估计量是样本均值：\n- 坍塌概率：$\\hat{P}_{\\mathrm{col}} = \\frac{1}{N_{\\mathrm{mc}}} \\sum_{j=1}^{N_{\\mathrm{mc}}} H_j$\n- 对 $\\lambda_{\\mathrm{p}}$ 的灵敏度：$\\frac{\\widehat{\\partial P_{\\mathrm{col}}}}{\\partial \\lambda_{\\mathrm{p}}} = \\frac{1}{N_{\\mathrm{mc}}} \\sum_{j=1}^{N_{\\mathrm{mc}}} H_j \\cdot W_{\\lambda_{\\mathrm{p}}, j}$\n- 对 $\\mu_{\\mathrm{c}}$ 的灵敏度：$\\frac{\\widehat{\\partial P_{\\mathrm{col}}}}{\\partial \\mu_{\\mathrm{c}}} = \\frac{1}{N_{\\mathrm{mc}}} \\sum_{j=1}^{N_{\\mathrm{mc}}} H_j \\cdot W_{\\mu_{\\mathrm{c}}, j}$\n\n### IV. 单次重复实验的算法\n\n对于给定的一组参数 $(\\lambda_{\\mathrm{p}}, \\mu_{\\mathrm{c}}, \\sigma, r_{\\ell}, r_{\\mathrm{t}}, L, \\beta)$ 和域边长 $A$，单次蒙特卡洛重复实验按以下步骤进行：\n\n1.  **生成母点**：从均值为 $\\lambda_{\\mathrm{p}} V$（其中 $V = A^3$）的泊松分布中抽取母点数 $N_{\\mathrm{p}}$。如果 $N_{\\mathrm{p}}  0$，则在立方体 $[-A/2, A/2]^3$ 内均匀生成其位置。\n\n2.  **生成子代**：如果 $N_{\\mathrm{p}}  0$，则从均值为 $\\mu_{\\mathrm{c}}$ 的泊松分布中为每个母点抽取子代数 $(K_i)_{i=1}^{N_{\\mathrm{p}}}$。计算子代总数 $M_{\\mathrm{total}} = \\sum_{i=1}^{N_{\\mathrmp}} K_i$。\n\n3.  **定位子代**：如果 $M_{\\mathrm{total}}  0$：a. 对于 $M_{\\mathrm{total}}$ 个子代中的每一个，确定其母点的位置。b. 通过从均值为 $0$、标准差为 $\\sigma$ 的正态分布中抽取三个独立的样本，生成一个三维位移向量。c. 将位移加到母点位置上，得到未包裹的子代位置 $(x,y,z)$。d. 对每个坐标 $u \\in \\{x,y,z\\}$ 应用周期性边界条件，使用公式 $u_{\\mathrm{wrapped}} = ((u + A/2) \\pmod A) - A/2$ 将位置带入域 $[-A/2, A/2]^3$ 内。\n\n4.  **计算相交数量**：计算其中心 $(x_k, y_k, z_k)$ 满足与隧道相交条件的子代（透镜体）数量 $M$：$\\sqrt{x_k^2 + y_k^2} \\le r_{\\mathrm{t}} + r_{\\ell}$ 且 $|z_k| \\le L/2 + r_{\\ell}$。\n\n5.  **检查坍塌**：如果稳定性指数 $S = 1 - \\beta M \\le 0$（等价于 $M \\ge 1/\\beta$），则发生坍塌。如果发生坍塌，则设坍塌指示符 $H=1$，否则 $H=0$。\n\n6.  **计算得分**：计算此次重复实验的得分函数值：\n    - $W_{\\lambda_{\\mathrm{p}}} = N_{\\mathrm{p}}/\\lambda_{\\mathrm{p}} - V$\n    - $W_{\\mu_{\\mathrm{c}}} = M_{\\mathrm{total}}/\\mu_{\\mathrm{c}} - N_{\\mathrm{p}}$\n\n7.  **存储结果**：此次重复实验的值为 $H$、$H \\cdot W_{\\lambda_{\\mathrm{p}}}$ 和 $H \\cdot W_{\\mu_{\\mathrm{c}}}$。然后将它们加到累加总和中，在所有 $N_{\\mathrm{mc}}$ 次重复实验完成后进行平均。请注意，如果 $H=0$，则对灵敏度估计量的贡献为零，这简化了计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Monte Carlo simulation to estimate tunnel collapse probability\n    and its sensitivities using the likelihood-ratio method.\n    \"\"\"\n\n    def run_simulation(case_params, n_mc, seed):\n        \"\"\"\n        Runs the Monte Carlo simulation for a single test case.\n        \"\"\"\n        # Unpack parameters\n        lambda_p, mu_c, sigma, r_l, r_t, L, beta = case_params\n        A = 10.0\n        V = A**3\n        \n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Accumulators for estimates\n        sum_H = 0.0\n        sum_H_W_lp = 0.0\n        sum_H_W_mc = 0.0\n        \n        # Collapse condition threshold\n        M_collapse_threshold = 1.0 / beta\n\n        # Intersection geometry thresholds\n        radial_threshold_sq = (r_t + r_l)**2\n        axial_threshold = L / 2.0 + r_l\n\n        for _ in range(n_mc):\n            # Step 1: Generate Parents\n            Np = rng.poisson(lambda_p * V)\n            \n            if Np == 0:\n                # No parents means no offspring, no collapse.\n                # H is 0. W_lp is -V, W_mc is 0.\n                # H*W is 0. No need to update sums.\n                continue\n            \n            # locations are uniform in [-A/2, A/2]^3\n            parent_locs = rng.uniform(-A/2, A/2, size=(Np, 3))\n\n            # Step 2: Generate Offspring counts\n            # K_i for each parent\n            K_counts = rng.poisson(mu_c, size=Np)\n            M_total = np.sum(K_counts)\n\n            if M_total == 0:\n                # No offspring, no collapse.\n                # H is 0. W_lp_j is Np/lambda_p - V, W_mc_j is 0 - Np.\n                # H*W is 0. No need to update sums.\n                continue\n\n            # Step 3: Position Offspring\n            # Create an index to map each offspring to its parent\n            parent_indices = np.repeat(np.arange(Np), K_counts)\n            \n            # Get parent locations for all offspring\n            offspring_parent_locs = parent_locs[parent_indices]\n            \n            # Generate all displacements at once\n            displacements = rng.normal(0, sigma, size=(M_total, 3))\n            \n            # Calculate unwrapped offspring locations\n            offspring_locs_unwrapped = offspring_parent_locs + displacements\n            \n            # Apply periodic boundary wrapping\n            offspring_locs = ((offspring_locs_unwrapped + A/2) % A) - A/2\n\n            # Step 4: Count Intersections\n            x, y, z = offspring_locs[:, 0], offspring_locs[:, 1], offspring_locs[:, 2]\n            \n            radial_dist_sq = x**2 + y**2\n            axial_dist_abs = np.abs(z)\n\n            # Boolean mask for intersecting lenses\n            intersect_mask = (radial_dist_sq = radial_threshold_sq)  (axial_dist_abs = axial_threshold)\n            \n            M = np.sum(intersect_mask)\n\n            # Step 5: Check for Collapse\n            H = 1.0 if M = M_collapse_threshold else 0.0\n\n            # Step 6  7: Calculate Scores and Update Accumulators\n            if H  0: # Only need to calculate scores if collapse occurs\n                sum_H += H # which is just 1.0\n\n                W_lp = Np / lambda_p - V\n                W_mc = M_total / mu_c - Np\n\n                sum_H_W_lp += W_lp # H is 1\n                sum_H_W_mc += W_mc # H is 1\n        \n        # Calculate final estimates by averaging\n        p_col = sum_H / n_mc\n        dp_dlambda_p = sum_H_W_lp / n_mc\n        dp_dmu_c = sum_H_W_mc / n_mc\n\n        return [p_col, dp_dlambda_p, dp_dmu_c]\n\n    # Global simulation parameters\n    N_mc = 5000\n    common_seed = 12345\n    \n    # Test cases as defined in the problem\n    test_cases = [\n        # (lambda_p, mu_c, sigma, r_l, r_t, L, beta)\n        (0.02, 10, 0.3, 0.2, 0.5, 8, 0.5),    # Case 1\n        (0.001, 2, 0.4, 0.2, 0.5, 8, 0.5),   # Case 2\n        (0.02, 30, 0.1, 0.2, 0.5, 8, 0.5),    # Case 3\n        (0.015, 5, 0.25, 0.25, 0.5, 8, 1.0) # Case 4\n    ]\n\n    all_results = []\n    for i, case in enumerate(test_cases):\n        # Diversify seed per test case for independent-like sample paths\n        case_seed = common_seed + i\n        result = run_simulation(case, N_mc, case_seed)\n        all_results.append(result)\n    \n    # Format the output string exactly as specified\n    output_str = \"[\" + \",\".join([f\"[{p},{dpl},{dpm}]\" for p, dpl, dpm in all_results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了蒙特卡洛模拟的基本设置后，一个关键问题随之而来：我们如何使其更高效，尤其是在估计罕见失效事件的概率时？本练习通过探索自适应采样的概念来解决这一问题，该技术能够智能地将计算资源集中在失效边界 $g(\\mathbf{x}) = 0$ 附近。您将分析并论证一种基于极限状态函数 $g(\\mathbf{x})$ 及其梯度 $\\nabla g(\\mathbf{x})$ 的度量标准，用以区分“近失效”样本，为高级的方差缩减模拟方法奠定理论基础。()",
            "id": "3544669",
            "problem": "一项岩土工程稳定性评估考虑一个定义在 $d$ 维不确定性参数向量 $\\mathbf{X} \\in \\mathbb{R}^d$ 上的极限状态函数 $g(\\mathbf{x})$，其联合概率密度为 $f_{\\mathbf{X}}(\\mathbf{x})$。失效域为 $F = \\{ \\mathbf{x} : g(\\mathbf{x}) \\le 0 \\}$，目标是使用蒙特卡洛模拟（MCS）估计失效概率 $P_f = \\mathbb{P}(g(\\mathbf{X}) \\le 0)$，同时自适应地将样本集中在边界 $\\partial F = \\{ \\mathbf{x} : g(\\mathbf{x}) = 0 \\}$ 的邻域内以加速收敛。计算岩土力学模型是对一个具有不确定材料参数的路堤进行的非线性有限元分析，其中 $g(\\mathbf{x})$ 是光滑的，其梯度 $\\nabla g(\\mathbf{x})$ 可通过伴随微分法获得。假设 $g$ 是连续可微的（$C^1$），并且在 $\\partial F$ 上 $\\|\\nabla g(\\mathbf{x})\\|$ 的下界大于零。自适应抽样程序必须将样本分类为“近失效”与“安全”，以细化 $g=0$ 周围的抽样密度。从第一性原理出发，论证一个有原则的标量度量 $m(\\mathbf{x})$ 和一个随着样本量 $n$ 增长的阈值策略 $\\tau_n$ 的选择，使得：\n- 近失效样本是那些满足关于 $m(\\mathbf{x})$ 和 $\\tau_n$ 的阈值条件的样本。\n- 该分类是渐近一致的，即随着 $n \\to \\infty$，在 $\\partial F$ 的一个 $O(\\tau_n)$ 邻域内错误分类安全点和近失效点的概率趋于零。\n- 该自适应程序继续在 $\\partial F$ 的一个收缩邻域内放置不可忽略且可控数量的点，以细化估计量或代理模型，并且在与重要性加权结合时，有助于得到 $P_f$ 的一个渐近无偏估计。\n\n在所述的正则性假设下，哪个选项提供了一个满足这些属性的度量和阈值策略，并附带了正确的收敛性论证？\n\nA. 定义 $m_A(\\mathbf{x}) = g(\\mathbf{x}) / \\|\\nabla g(\\mathbf{x})\\|$ 作为到水平集的有符号、尺度不变的局部距离，并通过 $|m_A(\\mathbf{x})| \\le \\tau_n$ 选择近失效点，其中 $\\tau_n \\to 0$ 且 $n \\tau_n \\to \\infty$。在 $C^1$ 正则性及在 $\\partial F$ 上 $\\|\\nabla g\\| \\ge c  0$ 的条件下，一阶泰勒展开得到一个局部线性化的边界，且 $|m_A|$ 近似于到 $\\partial F$ 的法向距离。余面积公式意味着管状区域 $\\{ \\mathbf{x} : |m_A(\\mathbf{x})| \\le \\tau_n \\}$ 的测度尺度为 $O(\\tau_n)$，因此近失效样本的期望数量尺度为 $O(n \\tau_n)$，这既保证了收缩邻域的覆盖，也保证了样本数量的增长。基于真实 $f_{\\mathbf{X}}$ 的重要性权重保持了 $P_f$ 的渐近无偏性。\n\nB. 定义 $m_B(\\mathbf{x}) = g(\\mathbf{x})$ 并通过 $|g(\\mathbf{x})| \\le \\tau_n$ 选择近失效点，其中 $\\tau_n \\to 0$。这个选择是充分的，因为它直接度量了剩余能力，并确保了在 $g = 0$ 周围的集中，而无需梯度。收敛性随之成立，因为邻域 $\\{ \\mathbf{x} : |g(\\mathbf{x})| \\le \\tau_n \\}$ 随着 $\\tau_n \\to 0$ 而收缩，因此误分类概率消失。\n\nC. 定义 $m_C(\\mathbf{x}) = g(\\mathbf{x}) / \\sqrt{\\nabla g(\\mathbf{x})^\\top \\boldsymbol{\\Sigma} \\, \\nabla g(\\mathbf{x})}$，其中 $\\boldsymbol{\\Sigma}$ 是 $\\mathbf{X}$ 的协方差矩阵。通过 $|m_C(\\mathbf{x})| \\le \\tau_n$ 选择近失效点，其中 $\\tau_n \\to 0$ 且 $n \\tau_n \\to \\infty$。这种类可靠性指标的缩放通过输入变异性对 $g$ 进行归一化，并实现了坐标不变性，从而确保了自适应抽样向 $\\partial F$ 收敛的几何一致性。\n\nD. 为指示函数 $\\mathbb{I}\\{g(\\mathbf{x}) \\le 0\\}$ 构建一个高斯过程（GP）分类器，并定义 $m_D(\\mathbf{x}) = p(\\mathbf{x})(1 - p(\\mathbf{x}))$，其中 $p(\\mathbf{x})$ 是在 $\\mathbf{x}$ 处GP预测的失效概率。通过 $m_D(\\mathbf{x}) \\ge 1/4 - \\delta_n$ 选择近失效点，其中 $\\delta_n \\to 0$。随着GP后验的集中，不确定性在决策边界附近达到峰值，确保了近失效分类的渐近一致性和自适应抽样在 $g = 0$ 周围的收敛性。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 第1步：提取已知条件\n-   **极限状态函数:** $g(\\mathbf{x})$，一个定义在 $\\mathbf{x} \\in \\mathbb{R}^d$ 上的标量函数。\n-   **不确定性:** 输入是一个 $d$ 维随机向量 $\\mathbf{X}$，其联合概率密度函数（PDF）为 $f_{\\mathbf{X}}(\\mathbf{x})$。\n-   **失效定义:** 失效域为 $F = \\{ \\mathbf{x} : g(\\mathbf{x}) \\le 0 \\}$。失效边界为 $\\partial F = \\{ \\mathbf{x} : g(\\mathbf{x}) = 0 \\}$。\n-   **目标:** 估计失效概率 $P_f = \\mathbb{P}(g(\\mathbf{X}) \\le 0)$。\n-   **方法:** 使用蒙特卡洛模拟（MCS），并带有一个特定约束：在失效边界 $\\partial F$ 的邻域内自适应地集中样本。\n-   **函数属性:**\n    -   $g$ 是连续可微的（$C^1$）。\n    -   梯度 $\\nabla g(\\mathbf{x})$ 是可用的（例如，通过伴随微分法）。\n    -   在失效边界上，梯度的范数有正下界：对于某个常数 $c$ 和所有 $\\mathbf{x} \\in \\partial F$，有 $\\|\\nabla g(\\mathbf{x})\\| \\ge c  0$。\n-   **自适应方案要求:**\n    1.  使用一个标量度量 $m(\\mathbf{x})$ 和一个依赖于样本量的阈值策略 $\\tau_n$ 将点分类为“近失效”。\n    2.  **渐近一致性:** 随着样本量 $n \\to \\infty$，在 $\\partial F$ 的 $O(\\tau_n)$ 邻域内错误分类点的概率必须趋于零。这通过让分类边界收敛到 $\\partial F$ 来实现。\n    3.  **细化属性:** 必须在 $\\partial F$ 的一个收缩邻域内放置不可忽略且可控数量的样本。\n    4.  **无偏估计:** 整个程序与重要性加权结合后，必须产生 $P_f$ 的渐近无偏估计。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学依据:** 该问题设定在结构和岩土工程可靠性分析的既定框架内。极限状态函数、蒙特卡洛模拟、自适应抽样、重要性加权和基于梯度的方法的使用都是计算力学和不确定性量化中的标准、基础扎实的技术。该问题在科学上和数学上都是合理的。\n-   **适定性:** 该问题是适定的。它要求确定一个度量和阈值策略，以满足一组明确的数学和程序要求。条件（$C^1$ 光滑性，非零梯度）是确保问题易于处理的标准假设。\n-   **客观性:** 语言正式、精确且无歧义。它使用了数学和工程领域的标准术语。\n\n### 第3步：结论与行动\n问题陈述是有效的。它具有科学依据、适定性和客观性，没有明显缺陷。我将继续推导解决方案并评估各个选项。\n\n### 从第一性原理推导\n\n自适应抽样策略的核心是定义一个“近失效”区域，该区域能有效隔离失效边界 $\\partial F$。一个有原则的方法是定义一个度量，该度量近似于点 $\\mathbf{x}$ 到曲面 $\\partial F$ 的距离。\n\n设 $\\mathbf{x}_p$ 是点 $\\mathbf{x}$ 在曲面 $\\partial F$ 上的投影，这意味着 $\\mathbf{x}_p$ 是 $\\partial F$ 上离 $\\mathbf{x}$ 最近的点。由于 $g$ 是 $C^1$ 且其梯度在 $\\partial F$ 上不为零，该曲面是局部光滑的。对于接近 $\\partial F$ 的 $\\mathbf{x}$，向量 $\\mathbf{x} - \\mathbf{x}_p$ 近似平行于 $\\mathbf{x}_p$ 处的法向量，该法向量由 $\\nabla g(\\mathbf{x}_p)$ 给出。\n\n考虑 $g(\\mathbf{x})$ 在 $\\mathbf{x}_p$ 附近的一阶泰勒展开：\n$$g(\\mathbf{x}) \\approx g(\\mathbf{x}_p) + \\nabla g(\\mathbf{x}_p)^\\top (\\mathbf{x} - \\mathbf{x}_p)$$\n根据 $\\mathbf{x}_p \\in \\partial F$ 的定义，我们有 $g(\\mathbf{x}_p) = 0$。向量 $(\\mathbf{x} - \\mathbf{x}_p)$ 近似为 $\\delta \\cdot \\mathbf{n}$，其中 $\\mathbf{n} = \\nabla g(\\mathbf{x}_p) / \\|\\nabla g(\\mathbf{x}_p)\\|$ 是单位法向量，$\\delta$ 是从 $\\mathbf{x}$ 到 $\\mathbf{x}_p$ 处切平面的有符号欧几里得距离。代入可得：\n$$g(\\mathbf{x}) \\approx \\nabla g(\\mathbf{x}_p)^\\top \\left( \\delta \\frac{\\nabla g(\\mathbf{x}_p)}{\\|\\nabla g(\\mathbf{x}_p)\\|} \\right) = \\delta \\frac{\\|\\nabla g(\\mathbf{x}_p)\\|^2}{\\|\\nabla g(\\mathbf{x}_p)\\|} = \\delta \\|\\nabla g(\\mathbf{x}_p)\\|$$\n解出有符号距离 $\\delta$，我们得到：\n$$\\delta \\approx \\frac{g(\\mathbf{x})}{\\|\\nabla g(\\mathbf{x}_p)\\|}$$\n由于 $\\mathbf{x}$ 接近 $\\mathbf{x}_p$ 并且 $g$ 是 $C^1$ 的，我们可以近似认为 $\\nabla g(\\mathbf{x}_p) \\approx \\nabla g(\\mathbf{x})$。这导出了一个可计算的、到失效曲面的一阶有符号距离近似：\n$$m(\\mathbf{x}) = \\frac{g(\\mathbf{x})}{\\|\\nabla g(\\mathbf{x})\\|}$$\n绝对值 $|m(\\mathbf{x})|$ 近似于到 $\\partial F$ 的欧几里得距离。这是一个定义良好的度量，因为 $\\|\\nabla g(\\mathbf{x})\\|$ 在 $\\partial F$ 附近有正下界。\n\n自适应方案需要将“近失效”区域定义为 $\\{ \\mathbf{x} : |m(\\mathbf{x})| \\le \\tau_n \\}$，其中 $\\tau_n$ 是一个阈值。\n1.  **收缩邻域:** 为了使分类收敛到真实边界，邻域必须收缩。这要求当 $n \\to \\infty$ 时 $\\tau_n \\to 0$。\n2.  **不可忽略的样本:** 我们需要确保落入此区域的样本数量（我们称之为 $N_{near}$）不消失。其期望数量为 $E[N_{near}] = n \\cdot \\mathbb{P}(|m(\\mathbf{X})| \\le \\tau_n)$。\n    区域 $\\{ \\mathbf{x} : |m(\\mathbf{x})| \\le \\tau_n \\}$ 是围绕曲面 $\\partial F$ 的一个近似厚度为 $2\\tau_n$ 的“管状区域”。根据余面积公式，该管状区域的概率测度在一阶上与其厚度 $\\tau_n$ 成正比。因此，对于某个与 PDF $f_{\\mathbf{X}}$ 在 $\\partial F$ 上的曲面积分相关的常数 $C$，有 $\\mathbb{P}(|m(\\mathbf{X})| \\le \\tau_n) \\approx C \\cdot (2\\tau_n)$。因此，$\\mathbb{P}(|m(\\mathbf{X})| \\le \\tau_n) = O(\\tau_n)$。\n    期望样本数为 $E[N_{near}] = O(n \\tau_n)$。为了确保这个数量是“不可忽略的”并且随 $n$ 增长（以允许持续细化），我们必须有 $E[N_{near}] \\to \\infty$。这意味着条件 $n \\tau_n \\to \\infty$。\n3.  **渐近无偏:** 如果使用自适应抽样方案来构建一个重要性抽样密度 $h(\\mathbf{x})$，那么 $P_f$ 的估计值为 $\\hat{P}_f = \\frac{1}{n} \\sum_{i=1}^n \\mathbb{I}\\{g(\\mathbf{x}_i) \\le 0\\} \\frac{f_{\\mathbf{X}}(\\mathbf{x}_i)}{h(\\mathbf{x}_i)}$。只要 $f_{\\mathbf{X}}$ 的支撑集包含在 $h(\\mathbf{x})$ 的支撑集内，该估计量对任何 $n$ 都是无偏的，因此是渐近无偏的。\n\n总之，一个有原则的度量是近似有符号距离 $m(\\mathbf{x}) = g(\\mathbf{x}) / \\|\\nabla g(\\mathbf{x})\\|$，并且阈值策略必须满足当 $n \\to \\infty$ 时 $\\tau_n \\to 0$ 且 $n \\tau_n \\to \\infty$。\n\n### 逐项分析\n\n**A. 定义 $m_A(\\mathbf{x}) = g(\\mathbf{x}) / \\|\\nabla g(\\mathbf{x})\\|$ 作为到水平集的有符号、尺度不变的局部距离，并通过 $|m_A(\\mathbf{x})| \\le \\tau_n$ 选择近失效点，其中 $\\tau_n \\to 0$ 且 $n \\tau_n \\to \\infty$。在 $C^1$ 正则性及在 $\\partial F$ 上 $\\|\\nabla g\\| \\ge c  0$ 的条件下，一阶泰勒展开得到一个局部线性化的边界，且 $|m_A|$ 近似于到 $\\partial F$ 的法向距离。余面积公式意味着管状区域 $\\{ \\mathbf{x} : |m_A(\\mathbf{x})| \\le \\tau_n \\}$ 的测度尺度为 $O(\\tau_n)$，因此近失效样本的期望数量尺度为 $O(n \\tau_n)$，这既保证了收缩邻域的覆盖，也保证了样本数量的增长。基于真实 $f_{\\mathbf{X}}$ 的重要性权重保持了 $P_f$ 的渐近无偏性。**\n\n-   **度量和策略:** 提出的度量 $m_A(\\mathbf{x}) = g(\\mathbf{x}) / \\|\\nabla g(\\mathbf{x})\\|$ 和阈值策略 $\\tau_n \\to 0, n \\tau_n \\to \\infty$ 与从第一性原理的推导完全匹配。\n-   **论证:** 论证异常详尽和正确。它正确地将 $m_A(\\mathbf{x})$ 识别为有符号法向距离的一阶近似。它正确地引用余面积公式来确定抽样带的概率测度为 $O(\\tau_n)$，并由此正确推断出近失效样本的数量为 $O(n \\tau_n)$，从而为 $n \\tau_n \\to \\infty$ 条件提供了理由。关于重要性权重确保无偏性的最后一点也是正确的。该选项及其论证的每个部分都与严谨的分析相符。\n-   **结论:** **正确**。\n\n**B. 定义 $m_B(\\mathbf{x}) = g(\\mathbf{x})$ 并通过 $|g(\\mathbf{x})| \\le \\tau_n$ 选择近失效点，其中 $\\tau_n \\to 0$。这个选择是充分的，因为它直接度量了剩余能力，并确保了在 $g = 0$ 周围的集中，而无需梯度。收敛性随之成立，因为邻域 $\\{ \\mathbf{x} : |g(\\mathbf{x})| \\le \\tau_n \\}$ 随着 $\\tau_n \\to 0$ 而收缩，因此误分类概率消失。**\n\n-   **度量和策略:** 度量 $m_B(\\mathbf{x}) = g(\\mathbf{x})$ 是有问题的。它不是尺度不变的：如果用 $2g$ 替换 $g$，失效曲面是相同的，但“近失效”区域 $\\{|2g(\\mathbf{x})| \\le \\tau_n\\}$ 的厚度是 $\\{|g(\\mathbf{x})| \\le \\tau_n\\}$ 的一半。一个有原则的几何度量不应该依赖于定义函数的任意缩放。此外，带状区域 $\\{|g(\\mathbf{x})| \\le \\tau_n\\}$ 的几何宽度约为 $2\\tau_n/\\|\\nabla g(\\mathbf{x})\\|$，这意味着其厚度不均匀，这是不理想的。阈值策略不完整，因为它省略了保证样本数量不消失的必要条件 $n\\tau_n \\to \\infty$（或等效条件）。\n-   **论证:** 论证很薄弱。“直接度量剩余能力”的说法很模糊。在寻求有原则的方法时，忽略可用的梯度信息是一个缺陷，而不是一个优点。声明邻域收缩是显而易见的，并不能保证其他所需属性。\n-   **结论:** **不正确**。\n\n**C. 定义 $m_C(\\mathbf{x}) = g(\\mathbf{x}) / \\sqrt{\\nabla g(\\mathbf{x})^\\top \\boldsymbol{\\Sigma} \\, \\nabla g(\\mathbf{x})}$，其中 $\\boldsymbol{\\Sigma}$ 是 $\\mathbf{X}$ 的协方差矩阵。通过 $|m_C(\\mathbf{x})| \\le \\tau_n$ 选择近失效点，其中 $\\tau_n \\to 0$ 且 $n \\tau_n \\to \\infty$。这种类可靠性指标的缩放通过输入变异性对 $g$ 进行归一化，并实现了坐标不变性，从而确保了自适应抽样向 $\\partial F$ 收敛的几何一致性。**\n\n-   **度量和策略:** 这个度量是一个复杂而有效的选择。它通过其标准差的一阶近似对 $g(\\mathbf{x})$ 进行归一化，有效地在概率意义（类马氏距离）上度量距离。这是一阶可靠性方法（FORM）的基石，在概率背景下是高度有原则的。阈值策略陈述正确。\n-   **论证:** 论证在概念上是合理的，突出了通过输入变异性进行归一化和实现更好的不变性等理想属性。收敛率的底层数学逻辑与选项A相同，因为分母也是一个范数。然而，选项A中提供的明确论证更完整。它直接通过 $O(n\\tau_n)$ 缩放将阈值策略与样本数量联系起来，这是问题中提到的一个关键要求（“不可忽略且可控数量的点”）。选项C的论证更为宏观。虽然该方法是有效的，但选项A提供的论证更严谨，并且更明确地说明了如何满足所有陈述的标准。在这些选项中，选项A提供了更完整的答案包（方法+详细论证）。\n-   **结论:** **不正确**。尽管方法本身是合理的，但选项A更优，因为其附带的论证更完整，并且直接解决了提示所要求的收敛性分析。\n\n**D. 为指示函数 $\\mathbb{I}\\{g(\\mathbf{x}) \\le 0\\}$ 构建一个高斯过程（GP）分类器，并定义 $m_D(\\mathbf{x}) = p(\\mathbf{x})(1 - p(\\mathbf{x}))$，其中 $p(\\mathbf{x})$ 是在 $\\mathbf{x}$ 处GP预测的失效概率。通过 $m_D(\\mathbf{x}) \\ge 1/4 - \\delta_n$ 选择近失效点，其中 $\\delta_n \\to 0$。随着GP后验的集中，不确定性在决策边界附近达到峰值，确保了近失效分类的渐近一致性和自适应抽样在 $g = 0$ 周围的收敛性。**\n\n-   **度量和策略:** 这描述了一种使用GP代理模型的不确定性抽样形式，这是一种有效的主动学习策略。该度量正确地识别了分类器不确定性最大的区域，这些区域预计会靠近真实边界 $\\partial F$。\n-   **论证和缺陷:** 主要缺陷在于，这种方法完全忽略了一个关键的可用信息：梯度 $\\nabla g(\\mathbf{x})$。一个有原则的方法应该利用所有可用信息以获得最大效率。用于指示函数的标准GP分类器不使用梯度数据。虽然存在梯度增强的GP，但这并不是所描述的内容。在这种情况下，选择一种丢弃宝贵的、明确可用的信息的方法不是一个有原则的选择。A和C中的方法都很好地利用了梯度。\n-   **结论:** **不正确**。\n\n### 结论\n\n选项A提供了一个度量，它是对问题进行第一性原理几何分析的直接和基本结果。它提出了正确的阈值策略，并且其论证是一个完整的、循序渐进的论述，正确地推导了渐近行为，并展示了如何满足问题的要求。它是最严谨、论证最充分的选项。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}