{
    "hands_on_practices": [
        {
            "introduction": "A fundamental benchmark for any numerical method in solid mechanics is its ability to exactly reproduce a state of constant strain. This exercise, known as the linear patch test, serves as a crucial first step in verifying the correctness of your Material Point Method (MPM) implementation. By applying a linear displacement field to the grid, you will confirm that both GIMP and CPDI formulations can recover the exact analytical strain at the material points, irrespective of their position or size relative to the grid cells, thus demonstrating their linear completeness. ",
            "id": "3541702",
            "problem": "Consider a two-dimensional small-strain linear patch test posed on a structured, uniform, Cartesian background grid used in the Material Point Method (MPM). Let the uniform grid have spacing $h$ in both directions and nodes located at coordinates $(x_I,y_I)$ for node index $I$. A synthetic kinematic field is imposed at the grid nodes by prescribing the nodal displacements according to the linear function $u_x(x,y) = a x + b$ and $u_y(x,y) = c y + d$, where $a$, $b$, $c$, and $d$ are given real parameters and $(x,y)$ denotes spatial position. The objective is to verify that two domain-aware MPM mappings, Generalized Interpolation Material Point (GIMP) and Convected Particle Domain Interpolation (CPDI), reproduce the exact constant small strain tensor $\\boldsymbol{\\varepsilon}$ across material points (particles) for varying particle domain sizes and random particle-to-grid offsets. The verification should be carried out by computing strain at material points from the nodal displacements using each mapping, and comparing it to the exact analytical strain induced by the imposed linear displacement field.\n\nThe fundamental base for the derivation is the kinematic definition of the displacement gradient and small strain: the displacement gradient is $\\nabla \\mathbf{u} = \\begin{bmatrix} \\partial u_x/\\partial x  \\partial u_x/\\partial y \\\\ \\partial u_y/\\partial x  \\partial u_y/\\partial y \\end{bmatrix}$ and the infinitesimal strain tensor is $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^\\top\\right)$. In the patch test, the expected analytical strain is constant with $\\varepsilon_{xx}=a$, $\\varepsilon_{yy}=c$, and $\\varepsilon_{xy}=0$. The numerical strain at a particle is computed from nodal displacements using an MPM mapping, which assigns to each particle an averaged gradient of background-grid shape functions over the particle domain. In GIMP, this average is defined by an area integral of the shape-function gradients over the rectangular particle domain. In CPDI, this average is consistently defined by the particle domain corners and yields the same result for linear fields when the particle domain is axis-aligned with the grid. Both mappings should reproduce the exact linear field in this test.\n\nYour task is to implement a program that:\n- Constructs a uniform, square grid with spacing $h$ and dimensions large enough to host randomly placed particle domains entirely within the grid interior.\n- Generates a set of material points with rectangular domains of side length $l_p$ in both directions such that the ratio $l_p/h$ can vary per test case. Particle centers are randomly distributed within the interior so that each particle domain remains inside the grid bounds. For one test case, purposely concentrate particle centers near grid lines to create edge-crossing scenarios.\n- Imposes nodal displacements from the linear field $u_x=a x + b$, $u_y=c y + d$ at all grid nodes.\n- For each particle, computes the numerical displacement gradient $\\nabla \\mathbf{u}$ and small strain $\\boldsymbol{\\varepsilon}$ using:\n  1. The GIMP definition based on the exact area average of the background bilinear shape-function gradients over the particle domain (with proper handling when a particle domain overlaps multiple grid cells by partitioning into cell-wise subdomains).\n  2. The CPDI definition based on corner-averaged gradients within each overlapped cell subdomain, area-weighted over the entire particle domain.\n- Compares the computed particle strains to the exact analytical strain, and reports, for each test case and each mapping, the maximum absolute error in $\\boldsymbol{\\varepsilon}$ across all particles. Errors are dimensionless since $\\boldsymbol{\\varepsilon}$ is dimensionless.\n\nUse a uniform grid with spacing $h$ expressed in meters and nodal coordinates in meters. Displacements $u_x$ and $u_y$ must be in meters. The strain $\\boldsymbol{\\varepsilon}$ must be treated as dimensionless, and the error metric must also be dimensionless.\n\nImplement the following test suite, where each test case defines $(a,b,c,d)$, the particle-to-grid size ratio $l_p/h$, the number of particles $N_p$, and a random seed to deterministically generate particle centers:\n1. Happy path: $a=0.03$, $b=0.0$, $c=-0.02$, $d=0.1$, $l_p/h=0.3$, $N_p=50$, seed $42$.\n2. Near-cell-size domains: $a=0.05$, $b=0.5$, $c=0.04$, $d=-0.3$, $l_p/h=0.99$, $N_p=60$, seed $123$.\n3. Edge-crossing offsets: $a=-0.01$, $b=0.2$, $c=0.02$, $d=0.0$, $l_p/h=0.6$, $N_p=40$, seed $2024$; choose particle centers near grid lines so that many particle domains cross cell boundaries while remaining inside the grid.\n4. Very small domains: $a=0.0$, $b=-0.1$, $c=0.0$, $d=0.25$, $l_p/h=0.05$, $N_p=80$, seed $7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E^{\\mathrm{GIMP}}_1,E^{\\mathrm{CPDI}}_1,E^{\\mathrm{GIMP}}_2,E^{\\mathrm{CPDI}}_2,E^{\\mathrm{GIMP}}_3,E^{\\mathrm{CPDI}}_3,E^{\\mathrm{GIMP}}_4,E^{\\mathrm{CPDI}}_4]$, where $E^{\\mathrm{GIMP}}_k$ and $E^{\\mathrm{CPDI}}_k$ denote the maximum absolute error in the strain components across all particles for test case $k$ computed with the GIMP and CPDI mappings, respectively. All outputs must be dimensionless real numbers. No other output is permitted.",
            "solution": "The problem statement is critically assessed and determined to be valid. It constitutes a well-posed, scientifically grounded verification problem in the field of computational geomechanics. Specifically, it describes a linear patch test for the Material Point Method (MPM), which is a standard procedure to verify the correctness of a numerical implementation. The givens are complete, consistent, and physically plausible. The objective is clear and the methods (GIMP, CPDI) are well-defined within the context of MPM. We may therefore proceed with a formal solution.\n\nThe core principle being tested is the ability of the Generalized Interpolation Material Point (GIMP) and Convected Particle Domain Interpolation (CPDI) formulations to exactly reproduce a state of constant strain. This property, known as linear completeness, is a necessary condition for a numerical method to converge to the correct solution as the grid is refined.\n\nFirst, we establish the analytical solution. The prescribed displacement field is given by:\n$$\nu_x(x,y) = a x + b \\\\\nu_y(x,y) = c y + d\n$$\nwhere $a, b, c, d$ are constants. The displacement gradient tensor, $\\nabla \\mathbf{u}$, is found by taking the partial derivatives of the displacement components:\n$$\n\\nabla \\mathbf{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x}  \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x}  \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na  0 \\\\\n0  c\n\\end{bmatrix}\n$$\nThe infinitesimal (small) strain tensor, $\\boldsymbol{\\varepsilon}$, is the symmetric part of the displacement gradient:\n$$\n\\boldsymbol{\\varepsilon}_{exact} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right) = \\frac{1}{2} \\left(\n\\begin{bmatrix}\na  0 \\\\\n0  c\n\\end{bmatrix}\n+\n\\begin{bmatrix}\na  0 \\\\\n0  c\n\\end{bmatrix}^\\top\n\\right)\n=\n\\begin{bmatrix}\na  0 \\\\\n0  c\n\\end{bmatrix}\n$$\nThus, the analytical strain field is constant throughout the domain, with components $\\varepsilon_{xx} = a$, $\\varepsilon_{yy} = c$, and $\\varepsilon_{xy} = 0$. This is the exact solution that the numerical method must reproduce.\n\nIn the Material Point Method, the displacement field $\\mathbf{u}^h(\\mathbf{x})$ is interpolated from nodal values $\\mathbf{u}_I$ using grid-based shape functions $N_I(\\mathbf{x})$:\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{I} N_I(\\mathbf{x}) \\mathbf{u}_I\n$$\nThe problem uses bilinear shape functions on a uniform Cartesian grid of spacing $h$. A key property of these functions is that they form a partition of unity ($\\sum_I N_I(\\mathbf{x}) = 1$) and are linearly complete ($\\sum_I N_I(\\mathbf{x}) \\mathbf{x}_I = \\mathbf{x}$). Because the prescribed displacement field is linear, and the nodal displacements are set to the exact values at the nodes, i.e., $\\mathbf{u}_I = \\mathbf{u}(\\mathbf{x}_I)$, the linear completeness property guarantees that the interpolated field exactly reproduces the linear field everywhere: $\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$.\n\nThe displacement gradient computed from the interpolated field is:\n$$\n\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\sum_I \\mathbf{u}_I \\otimes \\nabla N_I(\\mathbf{x})\n$$\nSince $\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$, it follows that $\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\nabla \\mathbf{u}(\\mathbf{x})$, which we found to be a constant matrix.\n\nIn GIMP and CPDI, the displacement gradient at a material point $p$ is not evaluated at the point's center, but is averaged over the particle's domain, $\\Omega_p$. The particle-averaged gradient is:\n$$\n(\\nabla \\mathbf{u})_p = \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla \\mathbf{u}^h(\\mathbf{x}) \\, dA = \\frac{1}{A_p} \\int_{\\Omega_p} \\left( \\sum_I \\mathbf{u}_I \\otimes \\nabla N_I(\\mathbf{x}) \\right) dA = \\sum_I \\mathbf{u}_I \\otimes \\left( \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla N_I(\\mathbf{x}) \\, dA \\right)\n$$\nwhere $A_p = l_p^2$ is the area of the particle domain. We define the particle-averaged shape function gradient as $\\mathbf{G}_{Ip} = \\langle \\nabla N_I \\rangle_p$. Thus:\n$$\n(\\nabla \\mathbf{u})_p = \\sum_I \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}\n$$\nThe components are computed as:\n$$\n(\\nabla u_x)_p = \\sum_I u_{x,I} \\mathbf{G}_{Ip} \\quad \\text{and} \\quad (\\nabla u_y)_p = \\sum_I u_{y,I} \\mathbf{G}_{Ip}\n$$\nMore explicitly:\n$$\n(\\nabla \\mathbf{u})_p = \\begin{bmatrix}\n\\sum_I u_{x,I} G_{Ip,x}  \\sum_I u_{x,I} G_{Ip,y} \\\\\n\\sum_I u_{y,I} G_{Ip,x}  \\sum_I u_{y,I} G_{Ip,y}\n\\end{bmatrix}\n$$\nThe challenge lies in correctly calculating the components of $\\mathbf{G}_{Ip}$ for each node $I$ whose support intersects the particle domain $\\Omega_p$. For a node at $\\mathbf{x}_I=(x_I, y_I)$, the standard bilinear basis function can be written as $N_I(x,y) = s\\left(\\frac{x-x_I}{h}\\right) s\\left(\\frac{y-y_I}{h}\\right)$, where $s(z) = \\max(0, 1-|z|)$ is the 1D hat function. Its derivative is $s'(z) = -\\text{sgn}(z)$ for $|z| \\in (0,1)$ and $0$ otherwise.\n\nThe components of $\\mathbf{G}_{Ip}$ are the result of the separable integral:\n$$\nG_{Ip,x} = \\frac{1}{A_p} \\int_{y_p-l_p/2}^{y_p+l_p/2} \\int_{x_p-l_p/2}^{x_p+l_p/2} \\frac{\\partial N_I}{\\partial x} \\, dx \\, dy = \\frac{1}{l_p^2 h} \\left[ \\int_{x_p-l_p/2}^{x_p+l_p/2} s'\\left(\\frac{x-x_I}{h}\\right) \\, dx \\right] \\left[ \\int_{y_p-l_p/2}^{y_p+l_p/2} s\\left(\\frac{y-y_I}{h}\\right) \\, dy \\right]\n$$\nBy the fundamental theorem of calculus, the integral of the derivative $s'$ is simply $s$. A change of variables ($z=(x-x_I)/h$) simplifies the integrals:\n$$\nG_{Ip,x} = \\frac{h}{l_p^2} \\left[ s(z) \\right]_{z_1}^{z_2} \\left[ \\int_{w_1}^{w_2} s(w) \\, dw \\right]\n$$\nand similarly,\n$$\nG_{Ip,y} = \\frac{h}{l_p^2} \\left[ \\int_{z_1}^{z_2} s(z) \\, dz \\right] \\left[ s(w) \\right]_{w_1}^{w_2}\n$$\nwhere the integration limits are $z_1 = (x_p-l_p/2-x_I)/h$, $z_2 = (x_p+l_p/2-x_I)/h$, $w_1 = (y_p-l_p/2-y_I)/h$, and $w_2 = (y_p+l_p/2-y_I)/h$. The definite integral of $s(z)$ can be computed analytically by considering its piecewise definition.\nLet $F(z) = \\int_0^z s(t) \\, dt$. Then $\\int_a^b s(t) \\, dt = F(b) - F(a)$. The function $F(z)$ is:\n$$\nF(z) =\n\\begin{cases}\n-0.5  z \\le -1 \\\\\nz + z^2/2  -1  z  0 \\\\\nz - z^2/2  0 \\le z \\le 1 \\\\\n0.5  z  1\n\\end{cases}\n$$\nWith these analytical expressions, $\\mathbf{G}_{Ip}$ can be computed to machine precision for GIMP. The problem states that for an axis-aligned rectangular particle domain and a linear displacement field, the CPDI formulation gives the same result. Therefore, the same calculation will be used for both, and the expected error in both cases should be near zero, limited only by floating-point arithmetic.\n\nThe algorithm proceeds as follows for each test case:\n1. Define a sufficiently large grid and set the grid spacing $h$.\n2. Generate $N_p$ particle-center coordinates $(x_p, y_p)$ using the specified random seed, ensuring particle domains of size $l_p \\times l_p$ are fully contained within the grid interior. For the edge-crossing case, particle centers are explicitly placed near grid lines.\n3. For every node $I$ in the grid with coordinates $(x_I, y_I)$, compute the prescribed nodal displacements $u_{x,I} = a x_I + b$ and $u_{y,I} = c y_I + d$.\n4. For each particle, initialize its displacement gradient tensor $(\\nabla \\mathbf{u})_p$ to zero.\n5. Identify all nodes $I$ whose shape function support overlaps the particle domain. The support of $N_I$ is a $2h \\times 2h$ square centered at $\\mathbf{x}_I$.\n6. For each such active node, compute the averaged gradient vector $\\mathbf{G}_{Ip}$ using the exact integral formulas derived above.\n7. Accumulate the contribution of each node to the particle's displacement gradient: $(\\nabla \\mathbf{u})_p += \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}$.\n8. After iterating through all active nodes, compute the particle strain tensor $\\boldsymbol{\\varepsilon}_p = \\frac{1}{2}((\\nabla \\mathbf{u})_p + (\\nabla \\mathbf{u})_p^\\top)$.\n9. Calculate the error for the particle as the maximum absolute difference between the components of the computed strain $\\boldsymbol{\\varepsilon}_p$ and the analytical strain $\\boldsymbol{\\varepsilon}_{exact}$.\n10. The result for the test case is the maximum error found across all particles. This value is reported for both GIMP and CPDI.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef s_hat(z: np.ndarray) - np.ndarray:\n    \"\"\"Computes the 1D linear B-spline (hat function).\"\"\"\n    z_abs = np.abs(z)\n    return np.where(z_abs  1.0, 1.0 - z_abs, 0.0)\n\ndef integral_s_hat(z: np.ndarray) - np.ndarray:\n    \"\"\"Computes the analytical integral of the hat function from 0 to z.\"\"\"\n    res = np.zeros_like(z, dtype=float)\n    \n    # z = -1\n    res[z = -1.0] = -0.5\n    \n    # -1  z  0\n    mask = (-1.0  z)  (z  0.0)\n    res[mask] = z[mask] + 0.5 * z[mask]**2\n    \n    # 0 = z = 1\n    mask = (0.0 = z)  (z = 1.0)\n    res[mask] = z[mask] - 0.5 * z[mask]**2\n\n    # z  1\n    res[z  1.0] = 0.5\n    \n    return res\n\ndef eval_integral_s_hat(z1: np.ndarray, z2: np.ndarray) - np.ndarray:\n    \"\"\"Computes the definite integral of the hat function from z1 to z2.\"\"\"\n    return integral_s_hat(z2) - integral_s_hat(z1)\n\ndef run_test_case(a, b, c, d, lp_h_ratio, Np, seed, is_edge_crossing):\n    \"\"\"\n    Runs a single patch test case.\n    \"\"\"\n    h = 1.0\n    lp = lp_h_ratio * h\n    \n    # 1. Grid setup\n    grid_dim = 20  # Number of cells in each direction\n    grid_min, grid_max = 0.0, grid_dim * h\n    \n    # Generate node coordinates and displacements\n    x_coords = np.arange(grid_min, grid_max + h, h)\n    y_coords = np.arange(grid_min, grid_max + h, h)\n    nx, ny = len(x_coords), len(y_coords)\n    nodes_x, nodes_y = np.meshgrid(x_coords, y_coords)\n    \n    u_x_nodal = a * nodes_x + b\n    u_y_nodal = c * nodes_y + d\n    \n    # 2. Particle generation\n    rng = np.random.default_rng(seed)\n    particles_pos = np.zeros((Np, 2))\n    \n    # Ensure particles and their domains are within the grid 'interior'\n    # Use a margin of 1 cell from the boundary to avoid edge cases\n    margin = h\n    p_min = grid_min + margin + lp / 2.0\n    p_max = grid_max - margin - lp / 2.0\n\n    if is_edge_crossing:\n        # Concentrate particles near grid lines\n        grid_lines_x_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        grid_lines_y_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        \n        base_x = grid_lines_x_idx * h\n        base_y = grid_lines_y_idx * h\n\n        # Offset by a small amount, ensuring cell crossing\n        offset_mag = 0.4 * lp # Small enough to be near line, large enough to guarantee crossing if lp  h\n        offsets_x = rng.uniform(-offset_mag, offset_mag, size=Np)\n        offsets_y = rng.uniform(-offset_mag, offset_mag, size=Np)\n        \n        particles_pos[:, 0] = np.clip(base_x + offsets_x, p_min, p_max)\n        particles_pos[:, 1] = np.clip(base_y + offsets_y, p_min, p_max)\n    else:\n        particles_pos = rng.uniform(low=p_min, high=p_max, size=(Np, 2))\n\n    max_err = 0.0\n    analytical_strain = np.array([[a, 0.0], [0.0, c]])\n\n    # 3. Process each particle\n    for p_idx in range(Np):\n        xp, yp = particles_pos[p_idx]\n        grad_u_p = np.zeros((2, 2))\n        \n        # Identify active nodes\n        x_min_infl = xp - lp / 2.0 - h\n        x_max_infl = xp + lp / 2.0 + h\n        y_min_infl = yp - lp / 2.0 - h\n        y_max_infl = yp + lp / 2.0 + h\n\n        # Find indices of nodes within the influence region\n        min_i = int(np.floor(x_min_infl / h))\n        max_i = int(np.ceil(x_max_infl / h))\n        min_j = int(np.floor(y_min_infl / h))\n        max_j = int(np.ceil(y_max_infl / h))\n\n        min_i = max(0, min_i)\n        max_i = min(nx-1, max_i)\n        min_j = max(0, min_j)\n        max_j = min(ny-1, max_j)\n\n        for j in range(min_j, max_j + 1):\n            for i in range(min_i, max_i + 1):\n                xi, yi = x_coords[i], y_coords[j]\n\n                # Calculate particle-averaged shape function gradients (G_ip)\n                z1 = (xp - lp / 2.0 - xi) / h\n                z2 = (xp + lp / 2.0 - xi) / h\n                w1 = (yp - lp / 2.0 - yi) / h\n                w2 = (yp + lp / 2.0 - yi) / h\n                \n                term_z_s = s_hat(z2) - s_hat(z1)\n                term_w_s = s_hat(w2) - s_hat(w1)\n                \n                term_z_int_s = eval_integral_s_hat(z1, z2)\n                term_w_int_s = eval_integral_s_hat(w1, w2)\n                \n                if abs(term_z_s)  1e-15 and abs(term_w_s)  1e-15 and \\\n                   abs(term_z_int_s)  1e-15 and abs(term_w_int_s)  1e-15:\n                    continue\n\n                common_factor = h / (lp**2)\n                G_ip_x = common_factor * term_z_s * term_w_int_s\n                G_ip_y = common_factor * term_z_int_s * term_w_s\n                \n                # Accumulate displacement gradient\n                grad_u_p[0, 0] += u_x_nodal[j, i] * G_ip_x\n                grad_u_p[0, 1] += u_x_nodal[j, i] * G_ip_y\n                grad_u_p[1, 0] += u_y_nodal[j, i] * G_ip_x\n                grad_u_p[1, 1] += u_y_nodal[j, i] * G_ip_y\n        \n        # Calculate strain and error\n        strain_p = 0.5 * (grad_u_p + grad_u_p.T)\n        err_matrix = np.abs(strain_p - analytical_strain)\n        \n        if np.max(err_matrix)  max_err:\n            max_err = np.max(err_matrix)\n            \n    return max_err\n\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # a, b, c, d, lp/h, Np, seed, is_edge_crossing\n        (0.03, 0.0, -0.02, 0.1, 0.3, 50, 42, False),\n        (0.05, 0.5, 0.04, -0.3, 0.99, 60, 123, False),\n        (-0.01, 0.2, 0.02, 0.0, 0.6, 40, 2024, True),\n        (0.0, -0.1, 0.0, 0.25, 0.05, 80, 7, False),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_test_case(*params)\n        # For this linear patch test with axis-aligned domains, GIMP and CPDI yield identical results.\n        results.append(f\"{error:.15e}\")\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While passing the patch test confirms basic accuracy, more advanced formulations like CPDI are distinguished by their adherence to fundamental conservation laws. This practice explores the conservation of angular momentum, a property that is not automatically satisfied by all MPM mapping schemes and whose violation can lead to non-physical, self-induced torques. You will compare a naive mapping with the consistent CPDI formulation to quantify this spurious torque and test a correction scheme, gaining a deeper appreciation for the importance of symmetric gradient operators in ensuring physically accurate simulations. ",
            "id": "3541779",
            "problem": "Consider a two-dimensional material point method on a uniform Cartesian grid for computational geomechanics, in which a single material point (particle) interacts with grid nodes through mapping operators. The goal is to analyze the discrete balance of angular momentum for internal forces induced by a uniform, symmetric Cauchy stress and to quantify mapping-induced torque under two particle-to-grid mappings: a corner-averaged gradient mapping that serves as a proxy for a naive Generalized Interpolation Material Point (GIMP) approach, and the Convected Particle Domain Interpolation (CPDI) mapping. You will then implement a symmetric correction that removes the spurious torque while preserving linear momentum.\n\nStart from the following fundamental base:\n\n- Continuum linear momentum balance for a material subdomain: the internal force density is given by the divergence of the Cauchy stress, and the nodal internal force arising from a particle discretization is a quadrature of the stress divergence against gradients of grid shape functions.\n- Continuum angular momentum balance requires the Cauchy stress to be symmetric and implies that the net internal couple (torque) is zero in the absence of external couples.\n- In a discrete grid formulation, the internal nodal force at grid node $i$ due to a particle $p$ of area $V_p$ and Cauchy stress $\\boldsymbol{\\sigma}_p$ is assembled as\n$$\n\\mathbf{f}^{\\text{int}}_i \\;=\\; -\\sum_{p} V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\overline{\\nabla N}_{ip},\n$$\nwhere $\\overline{\\nabla N}_{ip}$ is the mapped gradient weight associated with node $i$ and particle $p$. The discrete internal torque about the origin is\n$$\n\\tau_z \\;=\\; \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z,\n$$\nwhere $\\mathbf{x}_i$ is the position of node $i$, $\\times$ is the three-dimensional cross product, and $\\mathbf{e}_z$ is the unit vector out of the plane.\n\nDefinitions and assumptions to be used in this problem:\n\n- Use a uniform Cartesian grid with spacing $h = 1$ in meters. Grid nodes are located at $(i\\,h, j\\,h)$ for integers $i$ and $j$.\n- Within any grid cell, use standard bilinear finite element basis functions. For a cell with lower-left corner at $(x_0, y_0)$ and local coordinates $\\xi = (x-x_0)/h$ and $\\eta = (y-y_0)/h$, the shape functions attached to the four cell vertices are\n  - $N_{00} = (1-\\xi)(1-\\eta)$, $N_{10} = \\xi (1-\\eta)$, $N_{01} = (1-\\xi)\\eta$, $N_{11} = \\xi \\eta$,\n  with corresponding physical gradients\n  $$\n  \\nabla N_{00} = \\left[-\\frac{1-\\eta}{h}, -\\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{10} = \\left[ \\frac{1-\\eta}{h}, -\\frac{\\xi}{h}\\right],\\;\n  \\nabla N_{01} = \\left[-\\frac{\\eta}{h}, \\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{11} = \\left[ \\frac{\\eta}{h}, \\frac{\\xi}{h}\\right].\n  $$\n- The particle $p$ has center $\\mathbf{x}_p \\in \\mathbb{R}^2$, axis-aligned half-dimensions $a = L_x/2$, $b = L_y/2$ in meters, and in-plane rotation by angle $\\theta$ in radians. Its four corners are\n$$\n\\mathbf{x}_p^{(c)} \\;=\\; \\mathbf{x}_p + \\mathbf{R}(\\theta)\\,\\mathbf{q}^{(c)},\\quad \\text{with}\\quad \\mathbf{q}^{(c)} \\in \\{(\\pm a, \\pm b)\\},\n$$\nordered counter-clockwise, $\\mathbf{R}(\\theta)$ is the planar rotation matrix, and the area is $A_p = L_x L_y$.\n- The Cauchy stress is uniform and isotropic, $\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$ with $p$ in pascals and $\\mathbf{I}$ the identity tensor. There are no body couples and no external tractions on the grid nodes; only internal forces are considered.\n- Three particle-to-grid gradient mappings $\\overline{\\nabla N}_{ip}$ will be compared:\n  1. A naive corner-averaged gradient mapping (proxy for a naive Generalized Interpolation Material Point approach): \n     $$\n     \\overline{\\nabla N}_{ip}^{\\text{naive}} \\;=\\; \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right),\n     $$\n     where each corner $\\mathbf{x}_p^{(c)}$ is evaluated in its containing cell and contributes to the four nodes of that cell.\n  2. Convected Particle Domain Interpolation (CPDI-1) mapping:\n     $$\n     \\overline{\\nabla N}_{ip}^{\\text{CPDI}} \\;=\\; \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)},\n     $$\n     where the corner vector is \n     $$\n     \\mathbf{r}^{(c)} \\;=\\; \\frac{1}{2}\\,\\begin{bmatrix}\n     y_p^{(c+1)} - y_p^{(c-1)} \\\\\n     -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right)\n     \\end{bmatrix},\n     $$\n     using cyclic indexing on corners. This is the standard CPDI-1 boundary-integral-based gradient for a convex quadrilateral particle domain.\n  3. A symmetric correction applied a posteriori to any assembled internal nodal forces $\\{\\mathbf{f}^{\\text{int}}_i\\}$ to remove the net internal torque while preserving net internal force. Let the arithmetic mean of supporting node positions be $\\bar{\\mathbf{x}} = \\frac{1}{n}\\sum_i \\mathbf{x}_i$ and let $J$ be the $\\pi/2$ rotation in the plane, $J[x, y]^T = [-y, x]^T$. Define\n     $$\n     \\lambda \\;=\\; -\\,\\frac{\\tau_z}{\\sum_i \\|\\mathbf{x}_i - \\bar{\\mathbf{x}}\\|^2},\\qquad\n     \\delta\\mathbf{f}_i \\;=\\; \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right),\n     $$\n     and corrected forces $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$. This construction preserves $\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$ and enforces zero net internal torque.\n\nYour tasks:\n\n- Implement the bilinear shape evaluation and gradient within the containing grid cell of any query point, consistent with the above grid and basis.\n- For a given particle, assemble internal nodal forces $\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\overline{\\nabla N}_{ip}$ using each mapping $\\overline{\\nabla N}_{ip}$ described above. Include all nodes that are vertices of any cell that contains at least one particle corner.\n- Compute the scalar out-of-plane torque in newton-meters,\n$$\n\\tau_z \\;=\\; \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right),\n$$\nfor the naive corner-averaged mapping, for the CPDI mapping, and for the symmetric-corrected forces applied to the naive mapping. Round the output to reasonable floating-point representation; units must be in newton-meters.\n\nDesign a test suite with three cases that probe different facets of the mapping-induced torque:\n\n- Case A (happy path, particle inside one cell): $\\mathbf{x}_p = (0.5,\\,0.5)$ meters, $(L_x, L_y) = (0.4,\\,0.4)$ meters, $\\theta = 0$ radians.\n- Case B (edge case, domain straddles multiple cells): $\\mathbf{x}_p = (0.75,\\,0.5)$ meters, $(L_x, L_y) = (1.2,\\,0.6)$ meters, $\\theta = 0$ radians.\n- Case C (rotated, domain straddles multiple cells): $\\mathbf{x}_p = (0.5,\\,0.5)$ meters, $(L_x, L_y) = (1.2,\\,0.6)$ meters, $\\theta = \\pi/6$ radians.\n\nUse $h = 1$ meter, $p = 1000$ pascals, and $V_p = A_p = L_x L_y$ in square meters. Angles must be in radians. All answers for torque must be expressed in newton-meters as floats.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the $9$ results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\tau^{\\text{naive}}_{\\text{A}},\\;\\tau^{\\text{CPDI}}_{\\text{A}},\\;\\tau^{\\text{corr}}_{\\text{A}},\\;\\tau^{\\text{naive}}_{\\text{B}},\\;\\tau^{\\text{CPDI}}_{\\text{B}},\\;\\tau^{\\text{corr}}_{\\text{B}},\\;\\tau^{\\text{naive}}_{\\text{C}},\\;\\tau^{\\text{CPDI}}_{\\text{C}},\\;\\tau^{\\text{corr}}_{\\text{C}}].\n$$\nNo other text should be printed. All values must be in newton-meters.",
            "solution": "The problem requires an analysis of mapping-induced spurious torque in the Material Point Method (MPM) for a two-dimensional domain on a uniform Cartesian grid. We will implement and compare three approaches for computing internal nodal forces and the resulting net internal torque for a single particle subjected to a uniform isotropic stress state: a naive corner-averaged gradient mapping (a proxy for a naive GIMP), the Convected Particle Domain Interpolation (CPDI) mapping, and a symmetric a posteriori correction applied to the naive mapping.\n\nThe fundamental principle is the balance of linear and angular momentum. In the continuum, for a body subjected to a symmetric Cauchy stress tensor $\\boldsymbol{\\sigma}$ with no body couples, the net internal torque is zero. In a discrete MPM formulation, this property is not always preserved, leading to numerical errors. The discrete internal force at a grid node $i$ from a particle $p$ with volume $V_p$ and stress $\\boldsymbol{\\sigma}_p$ is given by:\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\overline{\\nabla N}_{ip}\n$$\nwhere $\\overline{\\nabla N}_{ip}$ is the particle-to-grid mapped gradient of the grid basis function $N_i$. Given the problem specifies a uniform isotropic stress $\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$, where $p$ is a constant pressure and $\\mathbf{I}$ is the identity tensor, this simplifies to:\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\overline{\\nabla N}_{ip}\n$$\nThe total internal torque about the origin is the sum of the moments of these nodal forces:\n$$\n\\tau_z = \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z = \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right)\n$$\nwhere $\\mathbf{x}_i = [x_i, y_i]^T$ is the position of node $i$, and $\\mathbf{f}^{\\text{int}}_i = [f^{\\text{int}}_{i,x}, f^{\\text{int}}_{i,y}]^T$. The problem is set in two dimensions on a grid with spacing $h=1$ m. A single particle is considered, for which the volume $V_p$ is taken to be its area $A_p = L_x L_y$. The pressure is given as $p=1000$ Pa.\n\nOur computational procedure is as follows:\nFirst, we establish geometric and finite element utilities. For any point $\\mathbf{x} \\in \\mathbb{R}^2$, we must identify its containing grid cell and evaluate the bilinear shape functions $N_i(\\mathbf{x})$ and their gradients $\\nabla N_i(\\mathbf{x})$ associated with the cell's four vertices. The provided formulas for $N_i$ and $\\nabla N_i$ in local coordinates $\\xi, \\eta$ are implemented.\n\nSecond, for each of the three test cases, we define the particle's geometry. Given its center $\\mathbf{x}_p$, dimensions $(L_x, L_y)$, and rotation angle $\\theta$, we compute the world coordinates of its four corners, $\\mathbf{x}_p^{(c)}$, and its area, $A_p$.\n\nThird, we implement the three distinct methods to compute nodal forces and torque.\n\n1.  **Naive Corner-Averaged Mapping**:\n    The gradient weight is an average of the standard finite element shape function gradients evaluated at the particle's four corners:\n    $$\n    \\overline{\\nabla N}_{ip}^{\\text{naive}} = \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\n    $$\n    We identify the set of all unique grid nodes that are vertices of any cell containing one or more particle corners. For each such node $i$, we sum the gradient contributions from each corner and then average. The internal force $\\mathbf{f}^{\\text{int}}_i$ is then computed and the total torque $\\tau_z^{\\text{naive}}$ is summed. This method does not generally conserve angular momentum, and we expect a non-zero torque when the particle is not symmetrically aligned with the grid.\n\n2.  **Convected Particle Domain Interpolation (CPDI) Mapping**:\n    The CPDI gradient mapping is designed to be variationally consistent and is known to conserve both linear and angular momentum exactly for uniform stress states, even for general quadrilateral particle domains. The gradient is defined as:\n    $$\n    \\overline{\\nabla N}_{ip}^{\\text{CPDI}} = \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)}\n    $$\n    where $\\mathbf{r}^{(c)}$ are geometric vectors derived from the particle corner coordinates:\n    $$\n    \\mathbf{r}^{(c)} = \\frac{1}{2}\\,\\begin{bmatrix} y_p^{(c+1)} - y_p^{(c-1)} \\\\ -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right) \\end{bmatrix}\n    $$\n    The procedure involves first calculating the four vectors $\\mathbf{r}^{(c)}$ using cyclic indexing on the corners. Then, for each corner, we evaluate the shape functions $N_i$ at its location and accumulate the weighted sums for $\\overline{\\nabla N}_{ip}^{\\text{CPDI}}$. Forces and the resulting torque $\\tau_z^{\\text{CPDI}}$ are then computed. We theoretically expect $\\tau_z^{\\text{CPDI}} = 0$ for all test cases.\n\n3.  **Symmetric Correction**:\n    This method provides a way to enforce angular momentum balance a posteriori. Starting with a set of internal forces $\\{\\mathbf{f}^{\\text{int}}_i\\}$ (in our case, those from the naive mapping) that produce a non-zero torque $\\tau_z$, we compute a set of corrective nodal forces $\\{\\delta\\mathbf{f}_i\\}$ that have a zero net force but a net torque of $-\\tau_z$. The correction is defined as:\n    $$\n    \\delta\\mathbf{f}_i = \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right) \\quad \\text{with} \\quad \\lambda = -\\,\\frac{\\tau_z}{\\sum_j \\|\\mathbf{x}_j - \\bar{\\mathbf{x}}\\|^2}\n    $$\n    Here, $\\bar{\\mathbf{x}}$ is the centroid of the supporting node positions, and $J$ is the operator for a $\\pi/2$ rotation. The corrected forces are $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$. By construction, $\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$ (preserving linear momentum balance if it existed), and the new total torque $\\tau_z^{\\text{corr}}$ is zero (up to floating-point precision).\n\nWe apply this three-step analysis to each test case (A, B, and C) and collect the nine resulting torque values for the final output. The calculations are performed using double-precision floating-point arithmetic.\n-   **Case A**: A small, unrotated particle fully inside one cell. Due to complete symmetry, we expect all three methods to yield zero torque.\n-   **Case B**: A larger, unrotated particle straddling a cell boundary. This asymmetry is expected to produce a non-zero torque for the naive mapping.\n-   **Case C**: A large, rotated particle centered in a cell but spanning multiple cells. This complex geometry is also expected to induce a spurious torque in the naive mapping.\n\nFor both CPDI and the corrected method, the theoretical result for torque is $0$. The implementation should yield values very close to zero, reflecting the limits of floating-point arithmetic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculations for all test cases.\n    \"\"\"\n    H = 1.0  # Grid spacing\n    P = 1000.0  # Pressure\n\n    # (center, (Lx, Ly), theta)\n    test_cases = [\n        # Case A\n        ((0.5, 0.5), (0.4, 0.4), 0.0),\n        # Case B\n        ((0.75, 0.5), (1.2, 0.6), 0.0),\n        # Case C\n        ((0.5, 0.5), (1.2, 0.6), np.pi / 6.0),\n    ]\n\n    results = []\n    for xp, L, theta in test_cases:\n        particle = Particle(xp, L, theta)\n\n        # 1. Naive corner-averaged mapping\n        naive_forces = calculate_naive_forces(particle, P, H)\n        tau_naive = calculate_torque(naive_forces)\n\n        # 2. CPDI mapping\n        cpdi_forces = calculate_cpdi_forces(particle, P, H)\n        tau_cpdi = calculate_torque(cpdi_forces)\n\n        # 3. Symmetric correction on naive forces\n        _, tau_corr = apply_correction(naive_forces, tau_naive)\n\n        results.extend([tau_naive, tau_cpdi, tau_corr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_shape_info(point, h=1.0):\n    \"\"\"\n    Calculates shape functions and gradients for a point in a Cartesian grid.\n\n    Args:\n        point (np.ndarray): The (x, y) coordinates of the query point.\n        h (float): The grid cell spacing.\n\n    Returns:\n        dict: A dictionary mapping node coordinates (tuples) to their\n              shape function values ('N') and gradients ('gradN').\n    \"\"\"\n    x, y = point\n    x0 = np.floor(x / h) * h\n    y0 = np.floor(y / h) * h\n\n    xi = (x - x0) / h\n    eta = (y - y0) / h\n\n    # Node coordinates for the cell, ordered to match N00, N10, N01, N11\n    nodes_coords = [\n        (x0, y0),          # For N00\n        (x0 + h, y0),      # For N10\n        (x0, y0 + h),      # For N01\n        (x0 + h, y0 + h),  # For N11\n    ]\n\n    # Shape function values\n    N_vals = [\n        (1 - xi) * (1 - eta),  # N00\n        xi * (1 - eta),        # N10\n        (1 - xi) * eta,        # N01\n        xi * eta,              # N11\n    ]\n\n    # Shape function gradients\n    grad_N_vals = [\n        np.array([-(1 - eta) / h, -(1 - xi) / h]),  # gradN00\n        np.array([(1 - eta) / h, -xi / h]),         # gradN10\n        np.array([-eta / h, (1 - xi) / h]),        # gradN01\n        np.array([eta / h, xi / h]),               # gradN11\n    ]\n\n    info = {}\n    for i in range(4):\n        info[nodes_coords[i]] = {'N': N_vals[i], 'gradN': grad_N_vals[i]}\n    return info\n\nclass Particle:\n    \"\"\"\n    Represents a 2D rectangular material point (particle).\n    \"\"\"\n\n    def __init__(self, xp, L, theta):\n        \"\"\"\n        Initializes the particle's geometry.\n\n        Args:\n            xp (tuple): Center coordinates (x, y).\n            L (tuple): Dimensions (Lx, Ly).\n            theta (float): Rotation angle in radians.\n        \"\"\"\n        self.xp = np.array(xp)\n        self.Lx, self.Ly = L\n        self.theta = theta\n        self.Ap = self.Lx * self.Ly\n\n        a = self.Lx / 2.0\n        b = self.Ly / 2.0\n\n        # Local corner coordinates, ordered CCW for r_c calculation\n        q_local = [\n            np.array([a, -b]),\n            np.array([a, b]),\n            np.array([-a, b]),\n            np.array([-a, -b]),\n        ]\n\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n\n        self.corners = [self.xp + R @ qc for qc in q_local]\n\ndef calculate_naive_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the naive corner-averaged mapping.\n    \"\"\"\n    grad_N_bar = {}\n    \n    for c_idx in range(4):\n        corner_pos = particle.corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_N_bar:\n                grad_N_bar[node_coord] = np.zeros(2)\n            grad_N_bar[node_coord] += info['gradN']\n            \n    forces = {}\n    for node_coord, summed_grad in grad_N_bar.items():\n        avg_grad = summed_grad / 4.0\n        # Force is -Vp*p*gradN_bar; problem states Vp = Ap\n        forces[node_coord] = -particle.Ap * p * avg_grad\n\n    return forces\n\ndef calculate_cpdi_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the CPDI mapping.\n    \"\"\"\n    corners = particle.corners\n    r_c = []\n    for c_idx in range(4):\n        c_prev = (c_idx - 1 + 4) % 4\n        c_next = (c_idx + 1) % 4\n        \n        xp_prev, yp_prev = corners[c_prev]\n        xp_next, yp_next = corners[c_next]\n        \n        r_vec = 0.5 * np.array([yp_next - yp_prev, -(xp_next - xp_prev)])\n        r_c.append(r_vec)\n        \n    grad_N_bar = {}\n    for c_idx in range(4):\n        corner_pos = corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        r_vec = r_c[c_idx]\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_N_bar:\n                grad_N_bar[node_coord] = np.zeros(2, dtype=float)\n            grad_N_bar[node_coord] += info['N'] * r_vec\n            \n    forces = {}\n    for node_coord, summed_N_r in grad_N_bar.items():\n        grad = summed_N_r / particle.Ap\n        # Force is -Vp*sigma.gradN_bar = -Vp*p*gradN_bar; Vp=Ap\n        forces[node_coord] = -particle.Ap * p * grad\n\n    return forces\n\ndef calculate_torque(forces):\n    \"\"\"\n    Computes the total 2D torque about the origin from a set of nodal forces.\n    \"\"\"\n    tau_z = 0.0\n    for node_coord, f_int in forces.items():\n        x_i, y_i = node_coord\n        f_x, f_y = f_int\n        tau_z += x_i * f_y - y_i * f_x\n    return tau_z\n\ndef apply_correction(forces, tau_z):\n    \"\"\"\n    Applies the symmetric correction to a set of forces to nullify torque.\n    \"\"\"\n    if np.isclose(tau_z, 0.0):\n        return forces, 0.0\n        \n    node_coords_list = list(forces.keys())\n    node_coords = np.array(node_coords_list)\n    \n    if len(node_coords)  2:\n        return forces, tau_z\n\n    x_bar = np.mean(node_coords, axis=0)\n    \n    sum_sq_dist = np.sum((node_coords - x_bar)**2)\n        \n    if np.isclose(sum_sq_dist, 0.0):\n        return forces, tau_z\n\n    lambda_corr = -tau_z / sum_sq_dist\n    \n    corr_forces = {}\n    for node_coord_tuple in node_coords_list:\n        node_coord = np.array(node_coord_tuple)\n        d_i = node_coord - x_bar\n        # delta_f_i = lambda * J(d_i) where J(d_i) = [-d_i_y, d_i_x]\n        delta_f_i = lambda_corr * np.array([-d_i[1], d_i[0]])\n        corr_forces[node_coord_tuple] = forces[node_coord_tuple] + delta_f_i\n        \n    new_tau = calculate_torque(corr_forces)\n    \n    return corr_forces, new_tau\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "The true power of advanced MPM formulations becomes evident in scenarios involving large deformations, a hallmark of geomechanical failure. This hands-on problem directly contrasts a GIMP-style mapping with a fixed particle domain against the CPDI method, which explicitly tracks the domain's deformation through the deformation gradient $ \\mathbf{F}_p $. By simulating a material point under extreme simple shear, you will quantify the errors in the recovered velocity gradient and the resulting plastic work, demonstrating the superior accuracy of the CPDI approach in capturing the kinematics of highly distorted material. ",
            "id": "3541682",
            "problem": "Consider a two-dimensional small-strain geomechanics setting where the Material Point Method (MPM) is used with either Generalized Interpolation Material Point (GIMP) mapping under fixed particle domains or Convected Particle Domain Interpolation (CPDI) mapping with updated particle domain corners from the particle deformation gradient. Let the background computational grid be a single bilinear quadrilateral element spanning the unit square with nodes at $(0,0)$, $(1,0)$, $(1,1)$, and $(0,1)$. Denote the bilinear shape functions at a spatial point $(x,y)$ as $N_1(x,y)=(1-x)(1-y)$, $N_2(x,y)=x(1-y)$, $N_3(x,y)=xy$, and $N_4(x,y)=(1-x)y$, and their gradients $\\nabla N_i(x,y)$ as standard spatial derivatives of these functions. A single material point (particle) of uniform density is centered at $(x_c,y_c)=(0.5,0.5)$ with an initial rectangular domain of half-lengths $(w_p/2,h_p/2)$ aligned with the coordinate axes.\n\nThe spatial velocity field is prescribed as $ \\mathbf{v}(x,y) = (\\gamma y,\\, 0) $, which produces a constant velocity gradient $ \\nabla \\mathbf{v} = \\begin{bmatrix} 0  \\gamma \\\\ 0  0 \\end{bmatrix} $ and a symmetric rate-of-deformation tensor $ \\mathbf{D} = \\frac{1}{2}(\\nabla \\mathbf{v} + \\nabla \\mathbf{v}^{\\mathsf{T}}) $. Assume perfect rigid-plastic behavior with a von Mises yield stress $\\sigma_y$ and plastic work rate per unit volume $ \\dot{W}_p = \\sigma_y \\,\\dot{\\varepsilon}_{\\mathrm{eq}} $, where the equivalent strain rate is $ \\dot{\\varepsilon}_{\\mathrm{eq}} = \\sqrt{\\frac{2}{3}\\,\\mathbf{D}:\\mathbf{D}} $. Over a time step $\\Delta t$, the exact plastic work per unit volume under the given field is $ W_{\\mathrm{exact}} = \\sigma_y \\,\\dot{\\varepsilon}_{\\mathrm{eq}} \\,\\Delta t $ evaluated using the exact $ \\mathbf{D} $.\n\nYou must implement and compare two mapping strategies for particle-to-grid transfers and grid-to-particle gradient recovery:\n\n1. Convected Particle Domain Interpolation (CPDI): The current particle domain is a parallelogram defined by the current corner vectors obtained from the particle deformation gradient $ \\mathbf{F}_p $. In the small time-step explicit update, take $ \\mathbf{F}_p = \\mathbf{I} + \\mathbf{L}\\,\\Delta t $, where $ \\mathbf{L} = \\nabla \\mathbf{v} $ evaluated at the particle center and $ \\mathbf{I} $ is the identity tensor. The current half-edge vectors are $ \\mathbf{r}_1 = \\frac{w_p}{2}\\,\\mathbf{F}_p \\mathbf{e}_x $ and $ \\mathbf{r}_2 = \\frac{h_p}{2}\\,\\mathbf{F}_p \\mathbf{e}_y $, where $ \\mathbf{e}_x=[1,0]^{\\mathsf{T}} $ and $ \\mathbf{e}_y=[0,1]^{\\mathsf{T}} $. Parameterize the current domain by $(\\xi,\\eta)\\in[-1,1]^2$ with the mapping $ \\mathbf{x}(\\xi,\\eta) = \\mathbf{x}_c + \\xi\\,\\mathbf{r}_1 + \\eta\\,\\mathbf{r}_2 $, and compute the particle-to-node mass and momentum transfers by numerically integrating $ \\int_{\\Omega_p} N_i(\\mathbf{x})\\,\\mathrm{d}A $ and $ \\int_{\\Omega_p} \\mathbf{v}(\\mathbf{x})\\,N_i(\\mathbf{x})\\,\\mathrm{d}A $, respectively. The nodal velocities are $ \\mathbf{v}_i = \\left( \\int_{\\Omega_p} \\mathbf{v}(\\mathbf{x})\\,N_i(\\mathbf{x})\\,\\mathrm{d}A \\right)\\big/\\left( \\int_{\\Omega_p} N_i(\\mathbf{x})\\,\\mathrm{d}A \\right) $.\n\n2. GIMP-style fixed domain mapping: Use the same integration but with a fixed rectangular particle domain aligned with the axes, i.e., take $ \\mathbf{r}_1 = \\frac{w_p}{2}\\,\\mathbf{e}_x $ and $ \\mathbf{r}_2 = \\frac{h_p}{2}\\,\\mathbf{e}_y $, without applying $ \\mathbf{F}_p $ to convect the corners. The particle center remains at $ \\mathbf{x}_c $, and the integration for nodal mass and momentum is performed over this fixed domain.\n\nFor both strategies, recover the particle velocity gradient as $ \\nabla \\mathbf{v}_p \\approx \\sum_{i=1}^4 \\mathbf{v}_i \\otimes \\nabla N_i(\\mathbf{x}_c) $, then compute $ \\mathbf{D}_p = \\frac{1}{2}(\\nabla \\mathbf{v}_p + \\nabla \\mathbf{v}_p^{\\mathsf{T}}) $, the equivalent strain rate $ \\dot{\\varepsilon}_{\\mathrm{eq},p} = \\sqrt{\\frac{2}{3}\\,\\mathbf{D}_p:\\mathbf{D}_p} $, and the plastic work per unit volume $ W_p = \\sigma_y \\,\\dot{\\varepsilon}_{\\mathrm{eq},p}\\,\\Delta t $. Quantify the errors by the relative Frobenius-norm error in the velocity gradient, $ E_{\\nabla \\mathbf{v}} = \\|\\nabla \\mathbf{v}_p - \\nabla \\mathbf{v}\\|_F / \\|\\nabla \\mathbf{v}\\|_F $, and the relative error in plastic work, $ E_W = |W_p - W_{\\mathrm{exact}}|/|W_{\\mathrm{exact}}| $.\n\nImplement the above using numerical quadrature over the particle domain in parameter space $(\\xi,\\eta)\\in[-1,1]^2$ with appropriate Gaussian quadrature, and assume unit density so that it cancels in nodal velocity computations. Use the following three test cases with specified physical parameters, and express plastic work in pascals (Pa) internally but only output dimensionless relative errors:\n\n- Test case 1 (happy path): $ w_p = 0.20 $, $ h_p = 0.20 $, $ \\gamma = 200\\,\\mathrm{s}^{-1} $, $ \\Delta t = 2\\cdot 10^{-3}\\,\\mathrm{s} $, $ \\sigma_y = 1.5\\cdot 10^{5}\\,\\mathrm{Pa} $.\n- Test case 2 (extreme shear, slender domain): $ w_p = 0.20 $, $ h_p = 0.05 $, $ \\gamma = 1000\\,\\mathrm{s}^{-1} $, $ \\Delta t = 10^{-3}\\,\\mathrm{s} $, $ \\sigma_y = 2.0\\cdot 10^{5}\\,\\mathrm{Pa} $.\n- Test case 3 (small particle, high shear): $ w_p = 0.05 $, $ h_p = 0.05 $, $ \\gamma = 500\\,\\mathrm{s}^{-1} $, $ \\Delta t = 5\\cdot 10^{-4}\\,\\mathrm{s} $, $ \\sigma_y = 1.0\\cdot 10^{5}\\,\\mathrm{Pa} $.\n\nYour program should compute, for each test case, the pair of relative errors $ E_{\\nabla \\mathbf{v}} $ and $ E_W $ for CPDI (updated corners) and for GIMP-style fixed domain mapping. The final output must be a single line containing the twelve numbers in the order $[E_{\\nabla \\mathbf{v}}^{\\mathrm{CPDI}}, E_{\\nabla \\mathbf{v}}^{\\mathrm{fixed}}, E_{W}^{\\mathrm{CPDI}}, E_{W}^{\\mathrm{fixed}}]$ for each test case appended sequentially, separated by commas and enclosed in square brackets, for a total of twelve comma-separated floats. No other text may be printed. Angles are not used; time is in seconds; velocity gradient is in $\\mathrm{s}^{-1}$; stress is in pascals. All outputs are dimensionless relative errors, so no unit string is included in the output.",
            "solution": "The user-provided problem is a valid computational mechanics exercise. It requires comparing two distinct particle-to-grid mapping strategies within the Material Point Method (MPM) framework: Convected Particle Domain Interpolation (CPDI) and a simplified Generalized Interpolation Material Point (GIMP) method using a fixed particle domain. The comparison is quantitative, based on the accuracy of recovering a prescribed velocity gradient and the consequent plastic work calculation. All parameters, physical laws, and calculation procedures are specified, making the problem self-contained, scientifically grounded, and well-posed.\n\nThe solution proceeds by first defining the exact analytical quantities that serve as the ground truth. Subsequently, a numerical procedure is developed to compute the same quantities using the two specified MPM mapping schemes. This involves numerical integration over the particle domain to transfer information to the grid, followed by a gradient recovery step to transfer information back to the particle. Finally, the errors are calculated as specified.\n\n**1. Analytical Ground Truth**\n\nThe problem prescribes a simple shear velocity field $\\mathbf{v}(x,y)$, defined in a two-dimensional Cartesian coordinate system $(x,y)$, as:\n$$\n\\mathbf{v}(x,y) = \\begin{pmatrix} \\gamma y \\\\ 0 \\end{pmatrix}\n$$\nwhere $\\gamma$ is a constant shear rate. The velocity gradient tensor $\\nabla \\mathbf{v}$ is uniform throughout the domain:\n$$\n\\nabla \\mathbf{v} = \\begin{pmatrix} \\frac{\\partial v_x}{\\partial x}  \\frac{\\partial v_x}{\\partial y} \\\\ \\frac{\\partial v_y}{\\partial x}  \\frac{\\partial v_y}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0  \\gamma \\\\ 0  0 \\end{pmatrix}\n$$\nThe rate-of-deformation tensor $\\mathbf{D}$, representing the symmetric part of $\\nabla \\mathbf{v}$, is:\n$$\n\\mathbf{D} = \\frac{1}{2}(\\nabla \\mathbf{v} + \\nabla \\mathbf{v}^{\\mathsf{T}}) = \\frac{1}{2} \\begin{pmatrix} 0  \\gamma \\\\ \\gamma  0 \\end{pmatrix}\n$$\nThe equivalent strain rate, $\\dot{\\varepsilon}_{\\mathrm{eq}}$, is derived from the Frobenius norm of $\\mathbf{D}$:\n$$\n\\dot{\\varepsilon}_{\\mathrm{eq}} = \\sqrt{\\frac{2}{3} \\mathbf{D}:\\mathbf{D}} = \\sqrt{\\frac{2}{3} \\sum_{i,j} D_{ij}^2} = \\sqrt{\\frac{2}{3} \\left( (\\frac{\\gamma}{2})^2 + (\\frac{\\gamma}{2})^2 \\right)} = \\sqrt{\\frac{2}{3} \\frac{\\gamma^2}{2}} = \\frac{|\\gamma|}{\\sqrt{3}}\n$$\nGiven a constant von Mises yield stress $\\sigma_y$ and a time step $\\Delta t$, the exact plastic work per unit volume, $W_{\\mathrm{exact}}$, is:\n$$\nW_{\\mathrm{exact}} = \\sigma_y \\dot{\\varepsilon}_{\\mathrm{eq}} \\Delta t = \\sigma_y \\frac{|\\gamma|}{\\sqrt{3}} \\Delta t\n$$\nThese analytical results, $\\nabla \\mathbf{v}$ and $W_{\\mathrm{exact}}$, serve as the benchmark for evaluating the accuracy of the numerical MPM schemes. The Frobenius norm of the exact velocity gradient, needed for the relative error calculation, is $\\|\\nabla \\mathbf{v}\\|_F = \\sqrt{\\gamma^2} = |\\gamma|$.\n\n**2. Numerical Procedure: Particle-to-Grid and Grid-to-Particle Transfers**\n\nThe core of the MPM simulation involves transferring mass and momentum from the material point (particle) to the nodes of the computational grid, and then using the nodal values to recover field gradients at the particle location. The particle is centered at $\\mathbf{x}_c = (0.5, 0.5)$ and initially occupies a rectangular domain $\\Omega_p$ of size $w_p \\times h_p$.\n\nThe background grid is a single bilinear element defined by $4$ nodes and their associated shape functions $N_i(\\mathbf{x})$. Particle properties are transferred to a node $i$ by integrating over the particle domain $\\Omega_p$. For example, the mass $m_i$ and momentum $\\mathbf{p}_i$ at node $i$ are computed as:\n$$\nm_i = \\int_{\\Omega_p} \\rho N_i(\\mathbf{x}) \\mathrm{d}A\n\\quad \\text{and} \\quad\n\\mathbf{p}_i = \\int_{\\Omega_p} \\rho \\mathbf{v}(\\mathbf{x}) N_i(\\mathbf{x}) \\mathrm{d}A\n$$\nAssuming unit density ($\\rho=1$), the nodal velocity $\\mathbf{v}_i$ is then $\\mathbf{v}_i = \\mathbf{p}_i / m_i$.\n\nThese integrals are evaluated numerically using Gaussian quadrature. The particle domain, which may be a rectangle or a parallelogram, is mapped from a canonical square domain $(\\xi, \\eta) \\in [-1, 1]^2$. The mapping is given by $\\mathbf{x}(\\xi, \\eta) = \\mathbf{x}_c + \\xi \\mathbf{r}_1 + \\eta \\mathbf{r}_2$, where $\\mathbf{r}_1$ and $\\mathbf{r}_2$ are the half-edge vectors of the particle domain. The differential area element transforms as $\\mathrm{d}A = |\\det(J)| \\mathrm{d}\\xi \\mathrm{d}\\eta$, where $J = [\\mathbf{r}_1, \\mathbf{r}_2]$ is the constant Jacobian matrix of the mapping. The integral becomes:\n$$\n\\int_{\\Omega_p} f(\\mathbf{x}) \\mathrm{d}A = \\int_{-1}^{1} \\int_{-1}^{1} f(\\mathbf{x}(\\xi, \\eta)) |\\det(J)| \\mathrm{d}\\xi \\mathrm{d}\\eta \\approx |\\det(J)| \\sum_{j=1}^{N_q} \\sum_{k=1}^{N_q} w_j w_k f(\\mathbf{x}(\\xi_j, \\eta_k))\n$$\nwhere $(\\xi_j, \\eta_k)$ are the Gauss points and $(w_j, w_k)$ are the corresponding weights for an $N_q \\times N_q$ quadrature rule. A $4 \\times 4$ rule provides sufficient accuracy for the polynomial integrands involved.\n\nThe two mapping strategies differ in their definition of the domain vectors $\\mathbf{r}_1$ and $\\mathbf{r}_2$:\n\n- **GIMP-style Fixed Domain:** The particle domain remains a fixed, axis-aligned rectangle. The half-edge vectors are constant:\n$$\n\\mathbf{r}_1 = \\begin{pmatrix} w_p/2 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_2 = \\begin{pmatrix} 0 \\\\ h_p/2 \\end{pmatrix}\n$$\n\n- **CPDI (Convected Particle Domain Interpolation):** The particle domain deforms with the flow. The deformation gradient at the particle, $\\mathbf{F}_p$, is updated using the velocity gradient $\\mathbf{L} = \\nabla\\mathbf{v}(\\mathbf{x}_c)$ over the time step $\\Delta t$:\n$$\n\\mathbf{F}_p = \\mathbf{I} + \\mathbf{L} \\Delta t = \\begin{pmatrix} 1  \\gamma \\Delta t \\\\ 0  1 \\end{pmatrix}\n$$\nThe current half-edge vectors are obtained by transforming the initial vectors $\\mathbf{e}_x = [1,0]^{\\mathsf{T}}$ and $\\mathbf{e}_y = [0,1]^{\\mathsf{T}}$:\n$$\n\\mathbf{r}_1 = \\frac{w_p}{2} \\mathbf{F}_p \\mathbf{e}_x = \\begin{pmatrix} w_p/2 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_2 = \\frac{h_p}{2} \\mathbf{F}_p \\mathbf{e}_y = \\begin{pmatrix} (h_p/2)\\gamma\\Delta t \\\\ h_p/2 \\end{pmatrix}\n$$\nThis results in a sheared parallelogram domain for the integration.\n\n**3. Gradient Recovery and Error Calculation**\n\nAfter computing the nodal velocities $\\mathbf{v}_i$ for each strategy, the velocity gradient is recovered at the particle center $\\mathbf{x}_c$ using the computed nodal velocities and the analytical gradients of the shape functions, $\\nabla N_i(\\mathbf{x}_c)$:\n$$\n\\nabla \\mathbf{v}_p \\approx \\sum_{i=1}^{4} \\mathbf{v}_i \\otimes \\nabla N_i(\\mathbf{x}_c)\n$$\nwhere $\\otimes$ denotes the outer product. From the recovered $\\nabla \\mathbf{v}_p$, the corresponding particle rate-of-deformation tensor $\\mathbf{D}_p$, equivalent strain rate $\\dot{\\varepsilon}_{\\mathrm{eq},p}$, and plastic work $W_p$ are calculated using the same formulas as for the exact quantities.\n\nFinally, the relative errors are computed to quantify the accuracy of each method:\n$$\nE_{\\nabla \\mathbf{v}} = \\frac{\\|\\nabla \\mathbf{v}_p - \\nabla \\mathbf{v}\\|_F}{\\|\\nabla \\mathbf{v}\\|_F}\n\\quad \\text{and} \\quad\nE_W = \\frac{|W_p - W_{\\mathrm{exact}}|}{|W_{\\mathrm{exact}}|}\n$$\nThis procedure is repeated for each of the three test cases specified in the problem statement, generating twelve error values in total. CPDI is expected to yield lower errors as it explicitly accounts for the domain's shear deformation, which the fixed-domain method ignores.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef get_gauss_quadrature(n):\n    \"\"\"Returns Gauss-Legendre quadrature points and weights for the interval [-1, 1].\"\"\"\n    points, weights = special.roots_legendre(n)\n    return points, weights\n\ndef shape_functions(x, y):\n    \"\"\"Evaluates bilinear shape functions at a point (x, y).\"\"\"\n    N1 = (1 - x) * (1 - y)\n    N2 = x * (1 - y)\n    N3 = x * y\n    N4 = (1 - x) * y\n    return np.array([N1, N2, N3, N4])\n\ndef shape_function_gradients(x, y):\n    \"\"\"Evaluates the gradients of bilinear shape functions at a point (x, y).\"\"\"\n    grad_N1 = np.array([-(1 - y), -(1 - x)])\n    grad_N2 = np.array([1 - y, -x])\n    grad_N3 = np.array([y, x])\n    grad_N4 = np.array([-y, 1 - x])\n    return [grad_N1, grad_N2, grad_N3, grad_N4]\n\ndef velocity_field(x, y, gamma):\n    \"\"\"Evaluates the prescribed velocity field v(x,y) = (gamma*y, 0).\"\"\"\n    return np.array([gamma * y, 0.0])\n\ndef compute_errors_for_mapping(params, mapping_type):\n    \"\"\"\n    Computes relative errors for a given mapping strategy (CPDI or Fixed).\n\n    Args:\n        params (tuple): A tuple of (wp, hp, gamma, dt, sigma_y).\n        mapping_type (str): Either 'CPDI' or 'Fixed'.\n\n    Returns:\n        tuple: A tuple containing (E_grad_v, E_W).\n    \"\"\"\n    wp, hp, gamma, dt, sigma_y = params\n    x_c = np.array([0.5, 0.5])\n\n    # 1. Compute exact analytical values\n    grad_v_exact = np.array([[0.0, gamma], [0.0, 0.0]])\n    norm_grad_v_exact = np.linalg.norm(grad_v_exact, 'fro')\n    if np.isclose(norm_grad_v_exact, 0): norm_grad_v_exact = 1.0 # Avoid division by zero\n\n    D_exact = 0.5 * (grad_v_exact + grad_v_exact.T)\n    D_colon_D_exact = np.sum(D_exact * D_exact)\n    e_eq_dot_exact = np.sqrt(2.0 / 3.0 * D_colon_D_exact)\n    W_exact = sigma_y * e_eq_dot_exact * dt\n    if np.isclose(W_exact, 0): W_exact = 1.0 # Avoid division by zero\n\n    # Get shape function gradients at particle center (constant for all calculations)\n    grads_N_at_xc = shape_function_gradients(x_c[0], x_c[1])\n\n    # 2. Define particle domain half-edge vectors r1, r2 based on mapping type\n    if mapping_type == 'Fixed':\n        r1 = np.array([wp / 2.0, 0.0])\n        r2 = np.array([0.0, hp / 2.0])\n    else:  # CPDI\n        Fp = np.array([[1.0, gamma * dt], [0.0, 1.0]])\n        r1 = (wp / 2.0) * Fp @ np.array([1.0, 0.0])\n        r2 = (hp / 2.0) * Fp @ np.array([0.0, 1.0])\n\n    # 3. Compute Jacobian determinant for numerical integration\n    J_det = r1[0] * r2[1] - r1[1] * r2[0]\n\n    # 4. Set up numerical quadrature\n    n_gauss = 4\n    g_points, g_weights = get_gauss_quadrature(n_gauss)\n\n    # 5. Perform particle-to-grid transfer (mass and momentum) via numerical integration\n    m_i = np.zeros(4)\n    p_i = np.zeros((4, 2))\n    for i in range(n_gauss):\n        for j in range(n_gauss):\n            xi, eta = g_points[i], g_points[j]\n            w_xi, w_eta = g_weights[i], g_weights[j]\n\n            # Map from quadrature point in [-1,1]^2 to spatial position\n            pos = x_c + xi * r1 + eta * r2\n            x, y = pos[0], pos[1]\n            \n            # Evaluate quantities at the spatial position\n            Ni_vals = shape_functions(x, y)\n            v_val = velocity_field(x, y, gamma)\n\n            # Accumulate integrals for mass and momentum\n            dV = J_det * w_xi * w_eta\n            m_i += Ni_vals * dV\n            p_i += np.outer(Ni_vals, v_val) * dV\n    \n    # 6. Compute nodal velocities\n    v_i = np.zeros((4, 2))\n    for i in range(4):\n        if m_i[i]  1e-15:\n            v_i[i, :] = p_i[i, :] / m_i[i]\n    \n    # 7. Recover particle velocity gradient from nodal velocities\n    grad_v_p = np.zeros((2, 2))\n    for i in range(4):\n        grad_v_p += np.outer(v_i[i, :], grads_N_at_xc[i])\n\n    # 8. Compute particle rate-of-deformation, strain rate, and plastic work\n    D_p = 0.5 * (grad_v_p + grad_v_p.T)\n    D_p_colon_D_p = np.sum(D_p * D_p)\n    e_eq_dot_p = np.sqrt(2.0 / 3.0 * D_p_colon_D_p)\n    W_p = sigma_y * e_eq_dot_p * dt\n\n    # 9. Compute relative errors\n    error_grad_v = np.linalg.norm(grad_v_p - grad_v_exact, 'fro') / norm_grad_v_exact\n    error_W = np.abs(W_p - W_exact) / np.abs(W_exact)\n\n    return error_grad_v, error_W\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (wp, hp, gamma, dt, sigma_y)\n        (0.20, 0.20, 200.0, 2e-3, 1.5e5),\n        (0.20, 0.05, 1000.0, 1e-3, 2.0e5),\n        (0.05, 0.05, 500.0, 5e-4, 1.0e5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E_grad_v_cpdi, E_w_cpdi = compute_errors_for_mapping(case, 'CPDI')\n        E_grad_v_fixed, E_w_fixed = compute_errors_for_mapping(case, 'Fixed')\n        all_results.extend([E_grad_v_cpdi, E_w_fixed, E_grad_v_fixed, E_w_cpdi])\n\n    # Format the output as a single-line comma-separated list in brackets\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}