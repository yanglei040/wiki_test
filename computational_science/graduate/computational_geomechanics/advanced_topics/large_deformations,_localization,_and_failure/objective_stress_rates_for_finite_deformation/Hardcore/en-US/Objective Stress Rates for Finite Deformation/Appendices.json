{
    "hands_on_practices": [
        {
            "introduction": "Before we can appreciate the various formulations of objective stress rates, we must first understand the fundamental kinematic reason for their existence. This analytical exercise dissects the kinematics of simple shear, a deformation mode central to many geomechanical problems like faulting and soil failure, to reveal the non-coaxiality between the rate of deformation and material spin . This non-coaxiality, quantified by the commutator of the rate-of-deformation tensor $ \\mathbf{D} $ and the spin tensor $ \\mathbf{W} $, is the root cause for the non-objectivity of the standard material time derivative of Cauchy stress.",
            "id": "3546917",
            "problem": "Consider a homogeneous simple shear deformation in a continuum undergoing finite deformation, with deformation gradient given by $\\,\\mathbf{F}(t) = \\mathbf{I} + \\gamma(t)\\,\\mathbf{e}_{1}\\otimes \\mathbf{e}_{2}\\,$, where $\\gamma(t)$ is a differentiable shear function, $\\mathbf{I}$ is the identity tensor, and $\\mathbf{e}_{i}$ are fixed orthonormal basis vectors. From the definitions of kinematic quantities in finite deformation, namely the velocity gradient $\\mathbf{L}(t) = \\dot{\\mathbf{F}}(t)\\,\\mathbf{F}(t)^{-1}$, the rate-of-deformation tensor $\\mathbf{D}(t) = \\tfrac{1}{2}\\left(\\mathbf{L}(t) + \\mathbf{L}(t)^{\\mathsf{T}}\\right)$, and the spin tensor $\\mathbf{W}(t) = \\tfrac{1}{2}\\left(\\mathbf{L}(t) - \\mathbf{L}(t)^{\\mathsf{T}}\\right)$, derive explicit expressions for $\\mathbf{L}(t)$, $\\mathbf{D}(t)$, and $\\mathbf{W}(t)$. Using these, form the commutator $[\\mathbf{D}(t),\\mathbf{W}(t)] = \\mathbf{D}(t)\\mathbf{W}(t) - \\mathbf{W}(t)\\mathbf{D}(t)$ and use the Frobenius norm $\\|\\cdot\\|_{\\mathrm{F}}$, defined by $\\|\\mathbf{A}\\|_{\\mathrm{F}} = \\sqrt{\\mathrm{tr}\\!\\left(\\mathbf{A}^{\\mathsf{T}}\\mathbf{A}\\right)}$, as a scalar measure of noncommutativity along the deformation path. Explain briefly how the noncommutativity of $\\mathbf{D}(t)$ and $\\mathbf{W}(t)$ influences the use of objective stress rates in computational geomechanics. Your final answer must be the closed-form analytic expression of the scalar measure $\\|\\,[\\mathbf{D}(t),\\mathbf{W}(t)]\\,\\|_{\\mathrm{F}}$ in terms of $\\dot{\\gamma}(t)$. No rounding is required, and no units are to be reported.",
            "solution": "The problem is assessed as valid following a critical examination of its premises.\n\n**Problem Validation**\n\n1.  **Extracted Givens:**\n    *   Deformation gradient: $\\mathbf{F}(t) = \\mathbf{I} + \\gamma(t)\\,\\mathbf{e}_{1}\\otimes \\mathbf{e}_{2}$.\n    *   Shear function: $\\gamma(t)$ is a differentiable function of time $t$.\n    *   Basis: $\\mathbf{e}_{i}$ are fixed orthonormal basis vectors.\n    *   Identity tensor: $\\mathbf{I}$.\n    *   Velocity gradient definition: $\\mathbf{L}(t) = \\dot{\\mathbf{F}}(t)\\,\\mathbf{F}(t)^{-1}$.\n    *   Rate-of-deformation tensor definition: $\\mathbf{D}(t) = \\tfrac{1}{2}\\left(\\mathbf{L}(t) + \\mathbf{L}(t)^{\\mathsf{T}}\\right)$.\n    *   Spin tensor definition: $\\mathbf{W}(t) = \\tfrac{1}{2}\\left(\\mathbf{L}(t) - \\mathbf{L}(t)^{\\mathsf{T}}\\right)$.\n    *   Commutator definition: $[\\mathbf{D}(t),\\mathbf{W}(t)] = \\mathbf{D}(t)\\mathbf{W}(t) - \\mathbf{W}(t)\\mathbf{D}(t)$.\n    *   Frobenius norm definition: $\\|\\mathbf{A}\\|_{\\mathrm{F}} = \\sqrt{\\mathrm{tr}\\!\\left(\\mathbf{A}^{\\mathsf{T}}\\mathbf{A}\\right)}$.\n    *   Objective: Derive an explicit expression for $\\|\\,[\\mathbf{D}(t),\\mathbf{W}(t)]\\,\\|_{\\mathrm{F}}$ and explain its significance for objective stress rates in computational geomechanics.\n\n2.  **Validation Verdict:**\n    *   The problem is **scientifically grounded**. It is a standard exercise in finite deformation kinematics, a cornerstone of continuum mechanics. All provided definitions are correct and widely used.\n    *   The problem is **well-posed**. It is self-contained and provides all necessary information to derive a unique analytical solution.\n    *   The problem is **objective**. It is formulated using precise mathematical language, free from any subjectivity or ambiguity.\n    *   The problem is directly relevant to its stated field, as the non-commutativity of $\\mathbf{D}$ and $\\mathbf{W}$ is a fundamental issue underlying the formulation of hypoelastic constitutive laws and the choice of objective stress rates for materials undergoing large non-coaxial deformations, which are prevalent in geomechanics.\n\nNo flaws are identified. We may proceed with the solution.\n\n**Derivation of Kinematic Quantities**\n\nWe will work with matrix representations of the tensors in the fixed orthonormal basis $\\{\\mathbf{e}_1, \\mathbf{e}_2, \\mathbf{e}_3\\}$. The dyadic product $\\mathbf{e}_1 \\otimes \\mathbf{e}_2$ corresponds to a matrix with a $1$ in the $(1,2)$ position and zeros elsewhere.\n\nThe deformation gradient $\\mathbf{F}(t)$ is given by:\n$$[\\mathbf{F}(t)] = [\\mathbf{I}] + \\gamma(t)[\\mathbf{e}_1 \\otimes \\mathbf{e}_2] = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} + \\gamma(t) \\begin{pmatrix} 0  1  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 1  \\gamma(t)  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$$\n\nFirst, we compute its time derivative, $\\dot{\\mathbf{F}}(t)$, where the dot denotes differentiation with respect to time $t$. Let $\\dot{\\gamma}(t) = \\frac{d\\gamma}{dt}$.\n$$[\\dot{\\mathbf{F}}(t)] = \\frac{d}{dt} \\begin{pmatrix} 1  \\gamma(t)  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$$\nIn tensor notation, $\\dot{\\mathbf{F}}(t) = \\dot{\\gamma}(t)\\,\\mathbf{e}_1 \\otimes \\mathbf{e}_2$.\n\nNext, we find the inverse of $\\mathbf{F}(t)$. The determinant is $\\det(\\mathbf{F}(t)) = 1$. The inverse is:\n$$[\\mathbf{F}(t)^{-1}] = \\begin{pmatrix} 1  -\\gamma(t)  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$$\nIn tensor notation, $\\mathbf{F}(t)^{-1} = \\mathbf{I} - \\gamma(t)\\,\\mathbf{e}_1 \\otimes \\mathbf{e}_2$.\n\nNow, we compute the velocity gradient $\\mathbf{L}(t) = \\dot{\\mathbf{F}}(t)\\,\\mathbf{F}(t)^{-1}$:\n$$[\\mathbf{L}(t)] = [\\dot{\\mathbf{F}}(t)][\\mathbf{F}(t)^{-1}] = \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 1  -\\gamma(t)  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$$\nThus, in this specific case, $\\mathbf{L}(t) = \\dot{\\mathbf{F}}(t) = \\dot{\\gamma}(t)\\,\\mathbf{e}_1 \\otimes \\mathbf{e}_2$.\n\nThe rate-of-deformation tensor $\\mathbf{D}(t)$ is the symmetric part of $\\mathbf{L}(t)$:\n$$[\\mathbf{D}(t)] = \\frac{1}{2} \\left( [\\mathbf{L}(t)] + [\\mathbf{L}(t)]^{\\mathsf{T}} \\right) = \\frac{1}{2} \\left( \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} + \\begin{pmatrix} 0  0  0 \\\\ \\dot{\\gamma}(t)  0  0 \\\\ 0  0  0 \\end{pmatrix} \\right) = \\frac{\\dot{\\gamma}(t)}{2} \\begin{pmatrix} 0  1  0 \\\\ 1  0  0 \\\\ 0  0  0 \\end{pmatrix}$$\n\nThe spin tensor $\\mathbf{W}(t)$ is the skew-symmetric part of $\\mathbf{L}(t)$:\n$$[\\mathbf{W}(t)] = \\frac{1}{2} \\left( [\\mathbf{L}(t)] - [\\mathbf{L}(t)]^{\\mathsf{T}} \\right) = \\frac{1}{2} \\left( \\begin{pmatrix} 0  \\dot{\\gamma}(t)  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} - \\begin{pmatrix} 0  0  0 \\\\ \\dot{\\gamma}(t)  0  0 \\\\ 0  0  0 \\end{pmatrix} \\right) = \\frac{\\dot{\\gamma}(t)}{2} \\begin{pmatrix} 0  1  0 \\\\ -1  0  0 \\\\ 0  0  0 \\end{pmatrix}$$\n\n**Commutator and Frobenius Norm**\n\nWe now form the commutator $[\\mathbf{D}(t),\\mathbf{W}(t)] = \\mathbf{D}(t)\\mathbf{W}(t) - \\mathbf{W}(t)\\mathbf{D}(t)$.\nFirst, we compute the product $\\mathbf{D}(t)\\mathbf{W}(t)$:\n$$[\\mathbf{D(t)W(t)}] = \\left( \\frac{\\dot{\\gamma}(t)}{2} \\right)^2 \\begin{pmatrix} 0  1  0 \\\\ 1  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ -1  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\frac{\\dot{\\gamma}(t)^2}{4} \\begin{pmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{pmatrix}$$\nNext, we compute the product $\\mathbf{W}(t)\\mathbf{D}(t)$:\n$$[\\mathbf{W(t)D(t)}] = \\left( \\frac{\\dot{\\gamma}(t)}{2} \\right)^2 \\begin{pmatrix} 0  1  0 \\\\ -1  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 1  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\frac{\\dot{\\gamma}(t)^2}{4} \\begin{pmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  0 \\end{pmatrix}$$\nThe commutator is the difference of these two results:\n$$[\\mathbf{D}(t),\\mathbf{W}(t)] = \\frac{\\dot{\\gamma}(t)^2}{4} \\left( \\begin{pmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{pmatrix} - \\begin{pmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  0 \\end{pmatrix} \\right) = \\frac{\\dot{\\gamma}(t)^2}{4} \\begin{pmatrix} -2  0  0 \\\\ 0  2  0 \\\\ 0  0  0 \\end{pmatrix} = \\frac{\\dot{\\gamma}(t)^2}{2} \\begin{pmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{pmatrix}$$\n\nFinally, we calculate the Frobenius norm of this commutator, $\\|\\,[\\mathbf{D}(t),\\mathbf{W}(t)]\\,\\|_{\\mathrm{F}}$. The Frobenius norm is the square root of the sum of the squares of the matrix elements. Let $\\mathbf{A} = [\\mathbf{D}(t),\\mathbf{W}(t)]$.\n$$\\|\\mathbf{A}\\|_{\\mathrm{F}}^2 = \\left(-\\frac{\\dot{\\gamma}(t)^2}{2}\\right)^2 + \\left(\\frac{\\dot{\\gamma}(t)^2}{2}\\right)^2 + 0^2 + \\dots = \\frac{\\dot{\\gamma}(t)^4}{4} + \\frac{\\dot{\\gamma}(t)^4}{4} = \\frac{2\\dot{\\gamma}(t)^4}{4} = \\frac{\\dot{\\gamma}(t)^4}{2}$$\nTaking the square root gives the norm:\n$$\\|\\mathbf{A}\\|_{\\mathrm{F}} = \\sqrt{\\frac{\\dot{\\gamma}(t)^4}{2}} = \\frac{\\sqrt{\\dot{\\gamma}(t)^4}}{\\sqrt{2}} = \\frac{\\dot{\\gamma}(t)^2}{\\sqrt{2}} = \\frac{\\sqrt{2}}{2}\\dot{\\gamma}(t)^2$$\n\n**Significance for Objective Stress Rates in Computational Geomechanics**\n\nThe non-commutativity of the rate-of-deformation tensor $\\mathbf{D}(t)$ and the spin tensor $\\mathbf{W}(t)$, as quantified by the non-zero result for $\\|\\,[\\mathbf{D}(t),\\mathbf{W}(t)]\\,\\|_{\\mathrm{F}}$, is of fundamental importance in the formulation of constitutive laws at finite deformation. The time derivative of the Cauchy stress tensor $\\boldsymbol{\\sigma}$ is not objective (i.e., it is frame-dependent). To formulate physically meaningful material laws, one must use an objective stress rate, $\\overset{\\triangledown}{\\boldsymbol{\\sigma}}$, such as the Jaumann rate, $\\overset{\\triangledown}{\\boldsymbol{\\sigma}}_{\\mathrm{J}} = \\dot{\\boldsymbol{\\sigma}} - \\mathbf{W}\\boldsymbol{\\sigma} + \\boldsymbol{\\sigma}\\mathbf{W}$. This rate is then related to the rate of deformation, e.g., via a hypoelastic law $\\overset{\\triangledown}{\\boldsymbol{\\sigma}} = \\mathcal{C}[\\mathbf{D}]$.\n\nThe problem arises because for an elastic material subjected to a closed deformation cycle (e.g., simple shear applied and then reversed), the stress state should return to its original value with no net work done. However, for deformations like simple shear where $[\\mathbf{D}, \\mathbf{W}] \\neq \\mathbf{0}$, many common objective rates, including the Jaumann rate, predict a spurious, non-physical stress response and energy generation or dissipation over a closed cycle. This is a direct consequence of the fact that the principal axes of stress (which tend to align with the principal axes of strain/strain rate) rotate differently than the material itself (whose rotation is described by $\\mathbf{W}$). The commutator $[\\mathbf{D}, \\mathbfW]$ is a measure of the non-coaxiality between the spin of the material and the spin of the principal axes of $\\mathbf{D}$.\n\nIn computational geomechanics, phenomena such as fault slip, shear banding, and soil liquefaction involve large, sustained shear deformations. Using an inappropriate objective stress rate in a numerical model can lead to significant errors in predicting stress evolution, material stability, and failure. The magnitude of $\\|\\,[\\mathbf{D},\\mathbf{W}]\\,\\|_{\\mathrm{F}}$ is proportional to $\\dot{\\gamma}(t)^2$, indicating that this issue becomes more pronounced at higher shear rates. This necessitates careful selection of an objective rate, or the use of alternative constitutive frameworks (e.g., hyperelasticity formulated in the reference configuration), to ensure physically correct simulations.",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{2}\\dot{\\gamma}(t)^2}$$"
        },
        {
            "introduction": "A core tenet of continuum mechanics is the principle of material frame-indifference, which states that a material's constitutive response must be independent of the observer's rigid body motion. An objective stress rate is specifically constructed to satisfy this principle. This computational patch test provides a direct, hands-on method to verify that a numerical implementation correctly honors this principle by producing zero stress increments under pure rigid body rotation, a necessary condition for any valid finite deformation analysis .",
            "id": "3546931",
            "problem": "Design a computational patch test to verify the invariance of an objective stress rate under a uniform rigid body rotation with zero deformation. The goal is to demonstrate that a finite element implementation that uses an objective stress rate yields zero stress increments in the co-rotational frame during pure rotation, which is a necessary property for numerical stability in finite deformation simulations in computational geomechanics.\n\nBegin from fundamental definitions. Consider a three-dimensional continuum undergoing a rigid body rotation with a constant angular velocity vector $\\boldsymbol{\\omega}$, where the velocity field is given by $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{\\omega} \\times \\boldsymbol{x}$. The spatial velocity gradient $\\boldsymbol{L}$ is the Jacobian of $\\boldsymbol{v}$ with respect to $\\boldsymbol{x}$. For rigid rotation, the symmetric rate-of-deformation tensor $\\boldsymbol{D} = \\tfrac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^\\mathsf{T})$ is identically zero, and the antisymmetric spin tensor $\\boldsymbol{W} = \\tfrac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^\\mathsf{T})$ equals $\\boldsymbol{L}$. Construct $\\boldsymbol{W}$ from $\\boldsymbol{\\omega}$ via the skew-symmetric cross-product representation, such that $\\boldsymbol{W}\\boldsymbol{x} = \\boldsymbol{\\omega} \\times \\boldsymbol{x}$ for any vector $\\boldsymbol{x}$.\n\nLet $\\boldsymbol{Q}(t)$ be the proper orthogonal rotation satisfying $\\dot{\\boldsymbol{Q}}(t) = \\boldsymbol{W}\\boldsymbol{Q}(t)$ and $\\boldsymbol{Q}(0) = \\boldsymbol{I}$, giving $\\boldsymbol{Q}(t) = \\exp(\\boldsymbol{W}t)$. Under pure rigid rotation, the Cauchy stress $\\boldsymbol{\\sigma}(t)$ is related to the initial Cauchy stress $\\boldsymbol{\\sigma}_0$ by $\\boldsymbol{\\sigma}(t) = \\boldsymbol{Q}(t)\\,\\boldsymbol{\\sigma}_0\\,\\boldsymbol{Q}^\\mathsf{T}(t)$. In the co-rotational frame, defined by $\\widehat{\\boldsymbol{\\sigma}}(t) = \\boldsymbol{Q}^\\mathsf{T}(t)\\,\\boldsymbol{\\sigma}(t)\\,\\boldsymbol{Q}(t)$, the stress should remain constant when $\\boldsymbol{D} = \\boldsymbol{0}$ and a proper objective stress rate is employed.\n\nYour task is to write a complete, runnable program that, for a specified set of test cases, performs the following:\n\n1. Constructs the antisymmetric spin tensor $\\boldsymbol{W}$ from a given angular velocity vector $\\boldsymbol{\\omega}$.\n2. Computes the rotation $\\boldsymbol{Q}(\\Delta t) = \\exp(\\boldsymbol{W}\\,\\Delta t)$ for a given time step $\\Delta t$.\n3. Propagates the rotation in $N$ equal steps over a total time $T$ where $N = T/\\Delta t$ is an integer, updating $\\boldsymbol{Q}_n$ and the spatial Cauchy stress $\\boldsymbol{\\sigma}_n = \\boldsymbol{Q}_n\\,\\boldsymbol{\\sigma}_0\\,\\boldsymbol{Q}_n^\\mathsf{T}$.\n4. Computes the co-rotational stress at each step, $\\widehat{\\boldsymbol{\\sigma}}_n = \\boldsymbol{Q}_n^\\mathsf{T}\\,\\boldsymbol{\\sigma}_n\\,\\boldsymbol{Q}_n$, and determines the maximum Frobenius norm of the discrete co-rotational stress rate over the time steps, defined as $\\max_n \\left\\| (\\widehat{\\boldsymbol{\\sigma}}_{n+1} - \\widehat{\\boldsymbol{\\sigma}}_n)/\\Delta t \\right\\|_F$. This quantity should be approximately zero if the objective stress rate is correctly implemented.\n5. For comparison, computes the maximum Frobenius norm of the naive spatial stress rate $\\max_n \\left\\| (\\boldsymbol{\\sigma}_{n+1} - \\boldsymbol{\\sigma}_n)/\\Delta t \\right\\|_F$, which need not be zero under rotation unless $\\boldsymbol{\\omega} = \\boldsymbol{0}$ or $\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$.\n\nUnits and numerical checks:\n- Express angular velocities in radians per second (rad/s), time in seconds (s), and stresses in Pascals (Pa).\n- Use the Frobenius norm with its implicit unit consistent with the stress rate, i.e., Pascals per second (Pa/s).\n- Use a tolerance $\\varepsilon_\\text{obj}$ to check the co-rotational objective increment: declare the objective test passed if the maximum co-rotational stress rate is less than or equal to $\\varepsilon_\\text{obj}$ in Pa/s.\n- Use a threshold $\\varepsilon_\\text{naive}$ to check that the naive spatial stress rate is detectably nonzero: declare the naive check as true if the maximum naive spatial stress rate is greater than or equal to $\\varepsilon_\\text{naive}$ in Pa/s.\n\nTest suite:\n- Case $1$: $\\boldsymbol{\\sigma}_0 = \\mathrm{diag}(100000, 50000, 25000)$ Pa, $\\boldsymbol{\\omega} = (0, 0, 1)$ rad/s, $T = 1.0$ s, $\\Delta t = 0.01$ s.\n- Case $2$: $\\boldsymbol{\\sigma}_0 = \\begin{bmatrix}80000  30000  0\\\\ 30000  120000  0\\\\ 0  0  60000\\end{bmatrix}$ Pa, $\\boldsymbol{\\omega} = (0.2, -0.1, 0.5)$ rad/s, $T = 2.0$ s, $\\Delta t = 0.02$ s.\n- Case $3$: $\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$ Pa, $\\boldsymbol{\\omega} = (10, 0, 0)$ rad/s, $T = 0.1$ s, $\\Delta t = 0.001$ s.\n- Case $4$: $\\boldsymbol{\\sigma}_0 = \\begin{bmatrix}0  50000  0\\\\ 50000  0  0\\\\ 0  0  0\\end{bmatrix}$ Pa, $\\boldsymbol{\\omega} = (0, 1000, 0)$ rad/s, $T = 0.01$ s, $\\Delta t = 0.00001$ s.\n\nUse $\\varepsilon_\\text{obj} = 1.0\\times10^{-8}$ Pa/s for the objective check and $\\varepsilon_\\text{naive} = 10.0$ Pa/s for the naive check.\n\nFinal output format:\n- For each test case, produce two boolean results in order: first the objective check result, then the naive check result.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots,r_8]$ where $r_{2k-1}$ is the objective result and $r_{2k}$ is the naive check result for case $k$).",
            "solution": "The principle of material frame-indifference, a cornerstone of continuum mechanics, mandates that the constitutive equations describing a material's behavior must be independent of the observer's rigid body motion. This requires the use of objective time derivatives (rates) of tensors, such as stress, in any rate-form constitutive law. An objective stress rate is one that vanishes during a pure rigid body motion of the continuum, as no genuine deformation occurs. This computational patch test is designed to verify that a numerical implementation of a co-rotational stress formulation correctly adheres to this principle.\n\nThe test simulates a pure rigid body rotation of a material point with an initial Cauchy stress $\\boldsymbol{\\sigma}_0$. The velocity field for a rigid rotation with a constant angular velocity vector $\\boldsymbol{\\omega} = (\\omega_1, \\omega_2, \\omega_3)^\\mathsf{T}$ is given by $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{\\omega} \\times \\boldsymbol{x}$. The spatial velocity gradient, $\\boldsymbol{L} = \\nabla\\boldsymbol{v}$, can be decomposed into its symmetric part, the rate-of-deformation tensor $\\boldsymbol{D}$, and its antisymmetric part, the spin tensor $\\boldsymbol{W}$. For this velocity field, we find $\\boldsymbol{D} = \\boldsymbol{0}$, indicating no deformation, and $\\boldsymbol{W}$ is the skew-symmetric tensor uniquely associated with the axial vector $\\boldsymbol{\\omega}$ such that $\\boldsymbol{W}\\boldsymbol{x} = \\boldsymbol{\\omega} \\times \\boldsymbol{x}$. The matrix form of $\\boldsymbol{W}$ is:\n$$ \\boldsymbol{W} = \\begin{bmatrix} 0  -\\omega_3  \\omega_2 \\\\ \\omega_3  0  -\\omega_1 \\\\ -\\omega_2  \\omega_1  0 \\end{bmatrix} $$\nThe orientation of the material element is described by a proper orthogonal rotation tensor $\\boldsymbol{Q}(t)$, which evolves according to the differential equation $\\dot{\\boldsymbol{Q}}(t) = \\boldsymbol{W}\\boldsymbol{Q}(t)$ with the initial condition $\\boldsymbol{Q}(0) = \\boldsymbol{I}$. For a constant $\\boldsymbol{W}$, the solution is the matrix exponential $\\boldsymbol{Q}(t) = \\exp(\\boldsymbol{W}t)$.\n\nUnder this rotation, the Cauchy stress tensor $\\boldsymbol{\\sigma}$ in the fixed spatial frame evolves from its initial state $\\boldsymbol{\\sigma}_0$ via a push-forward operation:\n$$ \\boldsymbol{\\sigma}(t) = \\boldsymbol{Q}(t)\\,\\boldsymbol{\\sigma}_0\\,\\boldsymbol{Q}^\\mathsf{T}(t) $$\nThe co-rotational stress tensor, $\\widehat{\\boldsymbol{\\sigma}}$, is defined in the frame that rotates with the material. It is obtained by pulling back the spatial Cauchy stress $\\boldsymbol{\\sigma}(t)$ with the rotation $\\boldsymbol{Q}(t)$:\n$$ \\widehat{\\boldsymbol{\\sigma}}(t) = \\boldsymbol{Q}^\\mathsf{T}(t)\\,\\boldsymbol{\\sigma}(t)\\,\\boldsymbol{Q}(t) $$\nSubstituting the expression for $\\boldsymbol{\\sigma}(t)$ into this definition demonstrates the analytical basis for the patch test:\n$$ \\widehat{\\boldsymbol{\\sigma}}(t) = \\boldsymbol{Q}^\\mathsf{T}(t) \\left( \\boldsymbol{Q}(t)\\,\\boldsymbol{\\sigma}_0\\,\\boldsymbol{Q}^\\mathsf{T}(t) \\right) \\boldsymbol{Q}(t) = \\left(\\boldsymbol{Q}^\\mathsf{T}(t)\\boldsymbol{Q}(t)\\right) \\boldsymbol{\\sigma}_0 \\left(\\boldsymbol{Q}^\\mathsf{T}(t)\\boldsymbol{Q}(t)\\right) $$\nSince $\\boldsymbol{Q}(t)$ is an orthogonal tensor, $\\boldsymbol{Q}^\\mathsf{T}(t)\\boldsymbol{Q}(t) = \\boldsymbol{I}$, where $\\boldsymbol{I}$ is the identity tensor. Thus, we find:\n$$ \\widehat{\\boldsymbol{\\sigma}}(t) = \\boldsymbol{I}\\,\\boldsymbol{\\sigma}_0\\,\\boldsymbol{I} = \\boldsymbol{\\sigma}_0 $$\nThis shows that the co-rotational stress must remain constant and equal to the initial stress $\\boldsymbol{\\sigma}_0$ throughout the rigid body motion. Consequently, any objective stress rate, which is the time derivative of $\\widehat{\\boldsymbol{\\sigma}}$, must be identically zero.\n\nThe numerical verification proceeds by discretizing the total time of rotation $T$ into $N$ equal steps of duration $\\Delta t = T/N$. The rotation over a single time step is given by the constant matrix $\\boldsymbol{Q}_{\\Delta t} = \\exp(\\boldsymbol{W}\\Delta t)$. The state at time $t_n = n\\Delta t$ is described by $\\boldsymbol{Q}_n$ and $\\boldsymbol{\\sigma}_n$. These are updated iteratively for $n = 0, 1, \\dots, N-1$:\n$$ \\boldsymbol{Q}_{n+1} = \\boldsymbol{Q}_{\\Delta t} \\boldsymbol{Q}_n $$\n$$ \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{Q}_{\\Delta t} \\boldsymbol{\\sigma}_n \\boldsymbol{Q}_{\\Delta t}^\\mathsf{T} $$\nstarting with $\\boldsymbol{Q}_0 = \\boldsymbol{I}$ and $\\boldsymbol{\\sigma}_0$. At each step, we compute the co-rotational stress $\\widehat{\\boldsymbol{\\sigma}}_n = \\boldsymbol{Q}_n^\\mathsf{T}\\boldsymbol{\\sigma}_n\\boldsymbol{Q}_n$ and $\\widehat{\\boldsymbol{\\sigma}}_{n+1} = \\boldsymbol{Q}_{n+1}^\\mathsf{T}\\boldsymbol{\\sigma}_{n+1}\\boldsymbol{Q}_{n+1}$.\n\nThe objective test verifies that the numerically computed rate of co-rotational stress is close to zero. We use a finite difference to approximate this rate and check if its maximum Frobenius norm over all time steps is bounded by a small tolerance $\\varepsilon_\\text{obj}$ to account for floating-point arithmetic errors:\n$$ \\max_{n=0,\\dots,N-1} \\left\\| \\frac{\\widehat{\\boldsymbol{\\sigma}}_{n+1} - \\widehat{\\boldsymbol{\\sigma}}_n}{\\Delta t} \\right\\|_F \\le \\varepsilon_\\text{obj} $$\nFor comparison, we also compute the naive stress rate in the fixed spatial frame, approximated by $(\\boldsymbol{\\sigma}_{n+1} - \\boldsymbol{\\sigma}_n) / \\Delta t$. This rate is not objective and is generally expected to be non-zero for non-trivial $\\boldsymbol{\\sigma}_0$ and $\\boldsymbol{\\omega}$. The second part of the test verifies this by checking if its maximum Frobenius norm is detectably non-zero, i.e., greater than a threshold $\\varepsilon_\\text{naive}$:\n$$ \\max_{n=0,\\dots,N-1} \\left\\| \\frac{\\boldsymbol{\\sigma}_{n+1} - \\boldsymbol{\\sigma}_n}{\\Delta t} \\right\\|_F \\ge \\varepsilon_\\text{naive} $$\nPassing both checks confirms that the implementation correctly computes a zero stress increment for an objective rate while correctly capturing a non-zero increment for a non-objective rate under pure rigid body rotation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the computational patch test for all specified cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"sigma0\": np.array([\n                [100000., 0., 0.],\n                [0., 50000., 0.],\n                [0., 0., 25000.]\n            ]),\n            \"omega\": np.array([0., 0., 1.]),\n            \"T\": 1.0,\n            \"dt\": 0.01,\n        },\n        {\n            \"sigma0\": np.array([\n                [80000., 30000., 0.],\n                [30000., 120000., 0.],\n                [0., 0., 60000.]\n            ]),\n            \"omega\": np.array([0.2, -0.1, 0.5]),\n            \"T\": 2.0,\n            \"dt\": 0.02,\n        },\n        {\n            \"sigma0\": np.zeros((3, 3)),\n            \"omega\": np.array([10., 0., 0.]),\n            \"T\": 0.1,\n            \"dt\": 0.001,\n        },\n        {\n            \"sigma0\": np.array([\n                [0., 50000., 0.],\n                [50000., 0., 0.],\n                [0., 0., 0.]\n            ]),\n            \"omega\": np.array([0., 1000., 0.]),\n            \"T\": 0.01,\n            \"dt\": 0.00001,\n        }\n    ]\n\n    # Define tolerances\n    epsilon_obj = 1.0e-8\n    epsilon_naive = 10.0\n\n    results = []\n    for case in test_cases:\n        obj_check, naive_check = run_patch_test(\n            case[\"sigma0\"],\n            case[\"omega\"],\n            case[\"T\"],\n            case[\"dt\"],\n            epsilon_obj,\n            epsilon_naive\n        )\n        results.extend([obj_check, naive_check])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef construct_spin_tensor(omega):\n    \"\"\"\n    Constructs the antisymmetric spin tensor W from an angular velocity vector omega.\n    W * x = omega x x\n    \"\"\"\n    w1, w2, w3 = omega\n    return np.array([\n        [0., -w3, w2],\n        [w3, 0., -w1],\n        [-w2, w1, 0.]\n    ])\n\ndef run_patch_test(sigma0, omega, T, dt, eps_obj, eps_naive):\n    \"\"\"\n    Performs the patch test for a single case.\n    \"\"\"\n    # 1. Calculate number of steps\n    if not np.isclose(T / dt, round(T / dt)):\n        raise ValueError(\"T/dt must be an integer.\")\n    num_steps = int(round(T / dt))\n\n    # 2. Construct spin tensor and incremental rotation matrix\n    W = construct_spin_tensor(omega)\n    Q_step = expm(W * dt)\n\n    # Initialize loop variables\n    Q_n = np.identity(3)\n    sigma_n = np.copy(sigma0)\n    \n    max_obj_rate_norm = 0.0\n    max_naive_rate_norm = 0.0\n\n    # 3. Propagate rotation over N steps\n    for _ in range(num_steps):\n        # State at step n\n        Q_prev = Q_n\n        sigma_prev = sigma_n\n        \n        # Update state to step n+1\n        Q_n = Q_step @ Q_prev\n        sigma_n = Q_step @ sigma_prev @ Q_step.T\n\n        # 4. Compute co-rotational stresses\n        hat_sigma_n_prev = Q_prev.T @ sigma_prev @ Q_prev\n        hat_sigma_n_curr = Q_n.T @ sigma_n @ Q_n\n        \n        # 5. Compute rates and their norms\n        objective_rate = (hat_sigma_n_curr - hat_sigma_n_prev) / dt\n        naive_rate = (sigma_n - sigma_prev) / dt\n        \n        obj_rate_norm = np.linalg.norm(objective_rate, 'fro')\n        naive_rate_norm = np.linalg.norm(naive_rate, 'fro')\n\n        if obj_rate_norm > max_obj_rate_norm:\n            max_obj_rate_norm = obj_rate_norm\n        \n        if naive_rate_norm > max_naive_rate_norm:\n            max_naive_rate_norm = naive_rate_norm\n\n    # 6. Perform checks against tolerances\n    objective_check = max_obj_rate_norm = eps_obj\n    naive_check = max_naive_rate_norm >= eps_naive\n    \n    return objective_check, naive_check\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While many different objective stress rates have been proposed, they are not all equivalent, and the choice of rate can have significant physical consequences. This exercise demonstrates a well-known pathological behavior of the widely-used Jaumann rate under specific non-proportional loading conditions . By simulating a kinematically closed deformation cycle, you will observe the non-physical generation of residual stress, a critical lesson highlighting the importance of selecting appropriate constitutive formulations for simulations involving large shear and rotation.",
            "id": "3546986",
            "problem": "Consider a homogeneous, isotropic, compressible continuum in finite deformation undergoing a two-step loading sequence repeated to form a closed cycle: first a simple shear in the plane followed by a rigid rotation about the out-of-plane axis, and then an unshear applied in the rotated axes followed by a reverse rotation back to the original axes. The objective is to implement a rate-based hypoelastic constitutive model with the Zaremba–Jaumann objective stress rate and quantify the residual stress after completing the cycle to assess path dependence.\n\nStart from the following fundamental definitions and kinematics in the spatial (current) configuration:\n- The velocity gradient is $\\mathbf{L} = \\nabla \\mathbf{v}$.\n- The symmetric part (rate-of-deformation tensor) is $\\mathbf{d} = \\tfrac{1}{2}\\left(\\mathbf{L} + \\mathbf{L}^{\\mathsf{T}}\\right)$.\n- The skew-symmetric part (spin tensor) is $\\boldsymbol{\\omega} = \\tfrac{1}{2}\\left(\\mathbf{L} - \\mathbf{L}^{\\mathsf{T}}\\right)$.\n- The deviatoric part of any second-order tensor $\\mathbf{A}$ is $\\mathrm{dev}(\\mathbf{A}) = \\mathbf{A} - \\tfrac{1}{3}\\mathrm{tr}(\\mathbf{A})\\mathbf{I}$, where $\\mathbf{I}$ is the identity tensor and $\\mathrm{tr}(\\cdot)$ denotes the trace.\n- The Zaremba–Jaumann objective stress rate of the Cauchy stress $\\boldsymbol{\\sigma}$ is defined by $\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\dot{\\boldsymbol{\\sigma}} - \\boldsymbol{\\omega}\\boldsymbol{\\sigma} + \\boldsymbol{\\sigma}\\boldsymbol{\\omega}$.\n- The deformation gradient $\\mathbf{F}$ evolves according to $\\dot{\\mathbf{F}} = \\mathbf{L}\\,\\mathbf{F}$ with $\\mathbf{F}(t=0) = \\mathbf{I}$.\n\nAssume isotropic linear hypoelasticity, where the objective stress rate is linearly related to the rate-of-deformation tensor. Use two independent elastic moduli: bulk modulus $K$ and shear modulus $G$ (both in pascals). Derive the explicit form of the linear isotropic constitutive relation for $\\dot{\\boldsymbol{\\sigma}}^{\\nabla}$ in terms of $\\mathbf{d}$, $K$, and $G$, starting only from isotropy, linearity, and the decomposition of $\\mathbf{d}$ into volumetric and deviatoric parts.\n\nNumerically integrate the constitutive and kinematic equations with a time-marching scheme over four segments that together form a closed kinematic cycle (net $\\mathbf{F}$ should be the identity tensor to within numerical tolerance), all in three dimensions with motion confined to the $x$-$y$ plane (the $z$-components remain zero):\n\n1. Segment A (simple shear): apply a constant simple shear rate $\\dot{\\gamma}$ in the $x$-$y$ plane for a duration $T_s$, producing a total shear $\\gamma = \\dot{\\gamma} T_s$. Use the velocity gradient\n$$\n\\mathbf{L}_s = \\begin{bmatrix}\n0  \\dot{\\gamma}  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n\n2. Segment B (rigid rotation): apply a constant rigid-body rotation rate $\\dot{\\theta}$ about the $z$-axis for a duration $T_r$, producing a total rotation $\\theta = \\dot{\\theta} T_r$. Use the velocity gradient\n$$\n\\mathbf{L}_r = \\begin{bmatrix}\n0  -\\dot{\\theta}  0 \\\\\n\\dot{\\theta}  0  0 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n\n3. Segment C (unshear in rotated axes): apply an unshear of $-\\gamma$ but aligned with axes rotated by angle $\\theta$ relative to the original axes. Implement this by holding the velocity gradient constant as\n$$\n\\mathbf{L}_{u} = \\mathbf{R}(\\theta)\\,\n\\begin{bmatrix}\n0  -\\dot{\\gamma}  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}\n\\,\\mathbf{R}(\\theta)^{\\mathsf{T}},\n$$\nfor the same duration $T_s$, where\n$$\n\\mathbf{R}(\\theta) = \\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{bmatrix}\n$$\nis the rotation tensor about the $z$-axis.\n\n4. Segment D (reverse rotation): apply a reverse rotation rate $-\\dot{\\theta}$ for duration $T_r$, i.e.\n$$\n\\mathbf{L}_{-r} = \\begin{bmatrix}\n0  \\dot{\\theta}  0 \\\\\n-\\dot{\\theta}  0  0 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n\nTake $T_s = 1\\,\\mathrm{s}$ and $T_r = 1\\,\\mathrm{s}$ for all segments. Start from zero initial stress $\\boldsymbol{\\sigma}(t=0) = \\mathbf{0}$. Implement an explicit time integration with a uniform number of time steps per segment. At each time step, update the Cauchy stress using the derived hypoelastic relation and the Jaumann objective rate, and update the deformation gradient using $\\dot{\\mathbf{F}} = \\mathbf{L}\\mathbf{F}$.\n\nDefine the residual stress after the full four-segment cycle as the von Mises equivalent stress\n$$\n\\sigma_{\\mathrm{vm}} = \\sqrt{\\tfrac{3}{2}\\,\\mathrm{dev}(\\boldsymbol{\\sigma}):\\mathrm{dev}(\\boldsymbol{\\sigma})},\n$$\nwhere $:$ denotes the Frobenius inner product. Report $\\sigma_{\\mathrm{vm}}$ in pascals (Pa) as a floating-point number.\n\nAngle unit must be radians. All stress-related quantities must be expressed in pascals. Use the following test suite of cases, each specified by $(K, G, \\gamma, \\theta, N_s, N_r)$ where $N_s$ and $N_r$ are the number of time steps used for shear and rotation segments, respectively:\n\n- Case 1 (general): $(5.0\\times 10^{10}, 3.0\\times 10^{10}, 0.2, 0.5, 400, 400)$.\n- Case 2 (small amplitudes): $(2.0\\times 10^{10}, 1.0\\times 10^{10}, 0.05, 0.1, 200, 200)$.\n- Case 3 (no rotation baseline): $(5.0\\times 10^{10}, 3.0\\times 10^{10}, 0.2, 0.0, 400, 400)$.\n- Case 4 (large rotation and shear): $(1.0\\times 10^{11}, 4.0\\times 10^{10}, 0.5, \\tfrac{\\pi}{2}, 800, 800)$.\n\nYour program should produce a single line of output containing the residual von Mises stresses for the above cases as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), each result as a float in pascals. No other text may be printed.",
            "solution": "The user-provided problem is a valid exercise in computational continuum mechanics. It requires the derivation of a standard hypoelastic constitutive law and its numerical integration over a specified finite deformation path to demonstrate the path-dependent nature of such models. All necessary parameters and definitions are provided, and the problem is scientifically sound and well-posed.\n\n### Part 1: Derivation of the Isotropic Hypoelastic Constitutive Relation\n\nThe problem specifies an isotropic linear hypoelastic material. The constitutive relationship is a linear mapping from the rate-of-deformation tensor, $\\mathbf{d}$, to an objective stress rate, in this case, the Zaremba–Jaumann rate, $\\dot{\\boldsymbol{\\sigma}}^{\\nabla}$.\n$$\n\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\mathbb{C} : \\mathbf{d}\n$$\nwhere $\\mathbb{C}$ is a fourth-order elasticity tensor. For an isotropic material, $\\mathbb{C}$ must be an isotropic tensor. The general form for an isotropic fourth-order tensor mapping symmetric second-order tensors to symmetric second-order tensors is:\n$$\n\\mathbb{C} = \\lambda \\mathbf{I} \\otimes \\mathbf{I} + 2\\mu \\mathbb{I}_{\\text{sym}}\n$$\nwhere $\\lambda$ and $\\mu$ are the Lamé parameters, $\\mathbf{I}$ is the second-order identity tensor, and $\\mathbb{I}_{\\text{sym}}$ is the symmetric fourth-order identity tensor. In component form, this is $\\mathbb{C}_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu (\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})$.\n\nApplying this to $\\mathbf{d}$ yields the relation in direct notation:\n$$\n\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\lambda \\, \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2\\mu \\mathbf{d}\n$$\nThe problem specifies the use of bulk modulus $K$ and shear modulus $G$. These are related to the Lamé parameters. The shear modulus is identical to the second Lamé parameter, so $\\mu = G$.\n\nTo find $\\lambda$ in terms of $K$ and $G$, we consider a pure volumetric deformation. Taking the trace of the constitutive equation:\n$$\n\\mathrm{tr}(\\dot{\\boldsymbol{\\sigma}}^{\\nabla}) = \\mathrm{tr}(\\lambda \\, \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2G \\mathbf{d}) = 3\\lambda \\, \\mathrm{tr}(\\mathbf{d}) + 2G \\, \\mathrm{tr}(\\mathbf{d}) = (3\\lambda + 2G)\\mathrm{tr}(\\mathbf{d})\n$$\nThe trace of any objective stress rate is equal to the trace of the material time derivative of the stress, $\\mathrm{tr}(\\dot{\\boldsymbol{\\sigma}}^{\\nabla}) = \\mathrm{tr}(\\dot{\\boldsymbol{\\sigma}})$. The bulk modulus $K$ relates the rate of change of mean stress, $\\dot{p} = \\frac{1}{3}\\mathrm{tr}(\\dot{\\boldsymbol{\\sigma}})$, to the volumetric strain rate, $\\mathrm{tr}(\\mathbf{d})$.\n$$\n\\dot{p} = K \\, \\mathrm{tr}(\\mathbf{d}) \\implies \\mathrm{tr}(\\dot{\\boldsymbol{\\sigma}}) = 3K \\, \\mathrm{tr}(\\mathbf{d})\n$$\nEquating the expressions for $\\mathrm{tr}(\\dot{\\boldsymbol{\\sigma}})$ gives:\n$$\n3K = 3\\lambda + 2G \\implies \\lambda = K - \\frac{2}{3}G\n$$\nSubstituting these into the constitutive law gives:\n$$\n\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\left(K - \\frac{2}{3}G\\right) \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2G \\mathbf{d}\n$$\nAs suggested by the problem, this can be re-expressed using the volumetric and deviatoric decomposition of $\\mathbf{d}$, where $\\mathbf{d} = \\mathrm{dev}(\\mathbf{d}) + \\frac{1}{3}\\mathrm{tr}(\\mathbf{d})\\mathbf{I}$:\n$$\n\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\left(K - \\frac{2}{3}G\\right) \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2G \\left(\\mathrm{dev}(\\mathbf{d}) + \\frac{1}{3}\\mathrm{tr}(\\mathbf{d})\\mathbf{I}\\right)\n$$\n$$\n\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\left(K - \\frac{2}{3}G + \\frac{2}{3}G\\right) \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2G \\, \\mathrm{dev}(\\mathbf{d})\n$$\nThis simplifies to the final, physically intuitive form:\n$$\n\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = K \\, \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2G \\, \\mathrm{dev}(\\mathbf{d})\n$$\nThis is the required hypoelastic constitutive relation.\n\n### Part 2: Numerical Integration Scheme\n\nWe employ an explicit forward Euler time-marching scheme to integrate the evolution equations for the Cauchy stress $\\boldsymbol{\\sigma}$ and the deformation gradient $\\mathbf{F}$. For a time step $\\Delta t$, the updates from step $n$ to $n+1$ are:\n\n1.  **Deformation Gradient Update:**\n    The evolution is given by $\\dot{\\mathbf{F}} = \\mathbf{L}\\mathbf{F}$. Discretizing gives:\n    $$\n    \\mathbf{F}_{n+1} = \\mathbf{F}_n + \\Delta t \\, (\\mathbf{L} \\mathbf{F}_n) = (\\mathbf{I} + \\Delta t \\, \\mathbf{L}) \\mathbf{F}_n\n    $$\n\n2.  **Cauchy Stress Update:**\n    The evolution is given by the definition of the Zaremba-Jaumann rate, $\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\dot{\\boldsymbol{\\sigma}} - \\boldsymbol{\\omega}\\boldsymbol{\\sigma} + \\boldsymbol{\\sigma}\\boldsymbol{\\omega}$, which is rearranged to find the material time derivative $\\dot{\\boldsymbol{\\sigma}}$:\n    $$\n    \\dot{\\boldsymbol{\\sigma}} = \\dot{\\boldsymbol{\\sigma}}^{\\nabla} + \\boldsymbol{\\omega}\\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}\\boldsymbol{\\omega}\n    $$\n    The term $\\dot{\\boldsymbol{\\sigma}}^{\\nabla}$ is determined by the constitutive law derived above. The tensors $\\mathbf{d}$ and $\\boldsymbol{\\omega}$ are the symmetric and skew-symmetric parts of the velocity gradient $\\mathbf{L}$, which is constant within each segment of the loading path.\n    The stress update is then:\n    $$\n    \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_n + \\Delta t \\, \\dot{\\boldsymbol{\\sigma}}_n = \\boldsymbol{\\sigma}_n + \\Delta t \\left( (K \\, \\mathrm{tr}(\\mathbf{d}) \\mathbf{I} + 2G \\, \\mathrm{dev}(\\mathbf{d})) + \\boldsymbol{\\omega}\\boldsymbol{\\sigma}_n - \\boldsymbol{\\sigma}_n\\boldsymbol{\\omega} \\right)\n    $$\n    This integration is performed iteratively over the four segments with initial conditions $\\boldsymbol{\\sigma}(0) = \\mathbf{0}$ and $\\mathbf{F}(0) = \\mathbf{I}$. For each segment, the corresponding constant velocity gradient $\\mathbf{L}$, duration ($T_s$ or $T_r$), and number of steps ($N_s$ or $N_r$) are used.\n\n### Part 3: Path Analysis\n\nThe four segments are:\n- **A. Simple Shear:** $\\mathbf{L}_s = \\begin{bsmallmatrix} 0  \\dot{\\gamma}  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bsmallmatrix}$. In this case, $\\mathrm{tr}(\\mathbf{d}) = 0$, so $\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = 2G \\mathbf{d}$.\n- **B. Rigid Rotation:** $\\mathbf{L}_r = \\begin{bsmallmatrix} 0  -\\dot{\\theta}  0 \\\\ \\dot{\\theta}  0  0 \\\\ 0  0  0 \\end{bsmallmatrix}$. This is a skew-symmetric tensor, so $\\mathbf{d} = \\mathbf{0}$ and $\\boldsymbol{\\omega}=\\mathbf{L}_r$. Thus, $\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\mathbf{0}$. The stress tensor is only rotated.\n- **C. Unshear:** $\\mathbf{L}_{u} = \\mathbf{R}(\\theta) \\left( \\begin{bsmallmatrix} 0  -\\dot{\\gamma}  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bsmallmatrix} \\right) \\mathbf{R}(\\theta)^{\\mathsf{T}}$. Here, $\\mathrm{tr}(\\mathbf{d})=0$ as well, so $\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = 2G \\mathbf{d}$.\n- **D. Reverse Rotation:** $\\mathbf{L}_{-r} = \\begin{bsmallmatrix} 0  \\dot{\\theta}  0 \\\\ -\\dot{\\theta}  0  0 \\\\ 0  0  0 \\end{bsmallmatrix}$. Again, $\\mathbf{d} = \\mathbf{0}$, so $\\dot{\\boldsymbol{\\sigma}}^{\\nabla} = \\mathbf{0}$.\n\nAfter completing all four segments, the final deformation gradient $\\mathbf{F}_{\\text{final}}$ returns to the identity tensor (to within numerical error), indicating a closed kinematic path. However, due to the path-dependent nature of the hypoelastic model (specifically, the spin terms in the Jaumann rate interacting with the evolving stress tensor), the final stress $\\boldsymbol{\\sigma}_{\\text{final}}$ is generally non-zero.\n\nThe residual stress is quantified using the von Mises equivalent stress:\n$$\n\\sigma_{\\mathrm{vm}} = \\sqrt{\\tfrac{3}{2}\\,\\mathrm{dev}(\\boldsymbol{\\sigma}_{\\text{final}}):\\mathrm{dev}(\\boldsymbol{\\sigma}_{\\text{final}})}\n$$\nwhere $\\mathrm{dev}(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\tfrac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\mathbf{I}$ and the colon denotes the Frobenius inner product.\nA special case is when $\\theta=0$, where the loading path is fully reversible and the residual stress is expected to be zero. This provides a valuable check for the numerical implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_cycle_simulation(K, G, gamma, theta, N_s, N_r):\n    \"\"\"\n    Simulates the four-segment loading cycle for a given set of parameters\n    and returns the residual von Mises stress.\n\n    Args:\n        K (float): Bulk modulus in Pascals.\n        G (float): Shear modulus in Pascals.\n        gamma (float): Total shear strain magnitude.\n        theta (float): Total rotation angle in radians.\n        N_s (int): Number of time steps for shear/unshear segments.\n        N_r (int): Number of time steps for rotation segments.\n\n    Returns:\n        float: The final residual von Mises stress in Pascals.\n    \"\"\"\n    # 0. Initialization\n    sigma = np.zeros((3, 3))\n    F = np.eye(3)\n    I = np.eye(3)\n    \n    T_s = 1.0  # Duration of shear segments in seconds\n    T_r = 1.0  # Duration of rotation segments in seconds\n    \n    d_gamma = gamma / T_s\n    d_theta = theta / T_r\n    \n    dt_s = T_s / N_s\n    dt_r = T_r / N_r\n\n    def dev(tensor):\n        \"\"\"Calculates the deviatoric part of a 2nd order tensor.\"\"\"\n        return tensor - (1.0/3.0) * np.trace(tensor) * I\n\n    # 1. Segment A: Simple Shear\n    L_s = np.array([[0.0, d_gamma, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    d_s = 0.5 * (L_s + L_s.T)\n    omega_s = 0.5 * (L_s - L_s.T)\n    # Volumetric strain rate tr(d_s) is 0, so dsigma_nabla depends only on the deviatoric part\n    dsigma_nabla_s = 2.0 * G * d_s\n    \n    for _ in range(N_s):\n        dsigma_dt = dsigma_nabla_s + omega_s @ sigma - sigma @ omega_s\n        sigma += dsigma_dt * dt_s\n        F = (I + L_s * dt_s) @ F\n\n    # 2. Segment B: Rigid Rotation\n    L_r = np.array([[0.0, -d_theta, 0.0], [d_theta, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    d_r = 0.5 * (L_r + L_r.T)  # This is the zero matrix\n    omega_r = L_r\n    dsigma_nabla_r = np.zeros((3, 3)) # Rate-of-deformation is zero\n\n    for _ in range(N_r):\n        dsigma_dt = dsigma_nabla_r + omega_r @ sigma - sigma @ omega_r\n        sigma += dsigma_dt * dt_r\n        F = (I + L_r * dt_r) @ F\n\n    # 3. Segment C: Unshear in Rotated Axes\n    c, s = np.cos(theta), np.sin(theta)\n    R_theta = np.array([[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]])\n    L_su_template = np.array([[0.0, -d_gamma, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    L_u = R_theta @ L_su_template @ R_theta.T\n    \n    d_u = 0.5 * (L_u + L_u.T)\n    omega_u = 0.5 * (L_u - L_u.T)\n    # Volumetric strain rate tr(d_u) is 0\n    dsigma_nabla_u = 2.0 * G * d_u\n\n    for _ in range(N_s):\n        dsigma_dt = dsigma_nabla_u + omega_u @ sigma - sigma @ omega_u\n        sigma += dsigma_dt * dt_s\n        F = (I + L_u * dt_s) @ F\n        \n    # 4. Segment D: Reverse Rotation\n    L_mr = np.array([[0.0, d_theta, 0.0], [-d_theta, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    d_mr = 0.5 * (L_mr + L_mr.T) # This is the zero matrix\n    omega_mr = L_mr\n    dsigma_nabla_mr = np.zeros((3, 3)) # Rate-of-deformation is zero\n    \n    for _ in range(N_r):\n        dsigma_dt = dsigma_nabla_mr + omega_mr @ sigma - sigma @ omega_mr\n        sigma += dsigma_dt * dt_r\n        F = (I + L_mr * dt_r) @ F\n\n    # 5. Calculate Residual Stress\n    dev_sigma_final = dev(sigma)\n    vm_stress = np.sqrt(1.5 * np.sum(dev_sigma_final * dev_sigma_final))\n    \n    return vm_stress\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (5.0e10, 3.0e10, 0.2, 0.5, 400, 400),\n        (2.0e10, 1.0e10, 0.05, 0.1, 200, 200),\n        (5.0e10, 3.0e10, 0.2, 0.0, 400, 400),\n        (1.0e11, 4.0e10, 0.5, np.pi / 2, 800, 800),\n    ]\n\n    results = []\n    for params in test_cases:\n        K, G, gamma, theta, Ns, Nr = params\n        residual_stress = run_cycle_simulation(K, G, gamma, theta, Ns, Nr)\n        results.append(residual_stress)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}