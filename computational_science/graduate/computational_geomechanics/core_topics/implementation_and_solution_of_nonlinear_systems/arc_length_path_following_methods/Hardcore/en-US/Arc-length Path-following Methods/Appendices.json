{
    "hands_on_practices": [
        {
            "introduction": "Before diving into the complexities of implementing an arc-length solver, it is essential to grasp the core phenomenon these methods are designed to address: the limit point. This first exercise  uses a simple, one-degree-of-freedom model to analytically explore the conditions under which the tangent stiffness of a system vanishes, leading to instabilities like 'snap-through'. By deriving the tangent slope $d\\lambda/du$, you will build a foundational understanding of why traditional load-controlled solution strategies fail and why path-following techniques are indispensable for robust nonlinear analysis.",
            "id": "3501024",
            "problem": "Consider a one-degree-of-freedom nonlinear equilibrium model representative of a proportional loading process in computational geomechanics, where the scalar displacement is $u$ and the load factor is $\\lambda$. The governing equilibrium equation is\n$$\nF(u,\\lambda) \\equiv k\\,u + \\beta\\,u^{3} - \\lambda\\,P = 0,\n$$\nwith $k0$ the initial linear stiffness, $\\beta$ a constant characterizing geometric or constitutive nonlinearity, and $P0$ a fixed reference load magnitude (so that the physical load is $\\lambda P$). This setting appears as a reduced-order proxy for tracing equilibrium paths by the Riks and Crisfield arc-length methods in the presence of limit points.\n\nStarting from the equilibrium definition and the assumption that the equilibrium path $\\lambda(u)$ is differentiable wherever it is single-valued, use first principles (implicit differentiation and the implicit function theorem) to:\n- Derive the expression for the tangent slope $d\\lambda/du$ along the equilibrium path.\n- Using your expression, state the condition on $\\beta$ and $u$ under which a load-controlled limit point occurs and interpret it in terms of snap-through versus snap-back, relating each to the sign of $d\\lambda/du$. Assume $P0$ and $k0$ throughout.\n- Under the softening case that admits a load-controlled limit point, determine the positive critical displacement magnitude $u_{c}$ at which $d\\lambda/du=0$.\n\nAnswer specification: Provide a single closed-form expression for the positive critical displacement $u_{c}$ in terms of $k$ and $\\beta$, assuming $\\beta0$, $k0$, and $P0$. Do not approximate or round. No units are required for the final expression.",
            "solution": "The task is to analyze a simple one-degree-of-freedom nonlinear model to understand the conditions leading to a limit point instability.\n\nThe governing equilibrium equation for the system is given by:\n$$\nF(u,\\lambda) = k\\,u + \\beta\\,u^{3} - \\lambda\\,P = 0\n$$\nwhere $u$ is the displacement, $\\lambda$ is the load factor, $k0$ is the initial stiffness, $\\beta$ is a nonlinearity parameter, and $P0$ is a reference load. We are to find the equilibrium path, which can be expressed as the function $\\lambda(u)$.\n\n**1. Derivation of the Tangent Slope $d\\lambda/du$**\n\nTo find the slope of the equilibrium path in the $\\lambda-u$ plane, we can differentiate the equilibrium equation with respect to $u$. This is an application of implicit differentiation, formally justified by the implicit function theorem. The theorem states that if $F(u, \\lambda) = 0$ and $\\frac{\\partial F}{\\partial \\lambda} \\neq 0$, then $\\lambda$ can be expressed as a function of $u$ and its derivative is given by:\n$$\n\\frac{d\\lambda}{du} = - \\frac{\\partial F / \\partial u}{\\partial F / \\partial \\lambda}\n$$\nFirst, we compute the required partial derivatives of $F(u, \\lambda) = k\\,u + \\beta\\,u^{3} - \\lambda\\,P$:\nThe partial derivative with respect to displacement $u$ is:\n$$\n\\frac{\\partial F}{\\partial u} = \\frac{\\partial}{\\partial u} (k\\,u + \\beta\\,u^{3} - \\lambda\\,P) = k + 3\\beta\\,u^{2}\n$$\nThe partial derivative with respect to the load factor $\\lambda$ is:\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} (k\\,u + \\beta\\,u^{3} - \\lambda\\,P) = -P\n$$\nSubstituting these partial derivatives into the formula from the implicit function theorem, we obtain the expression for the tangent slope:\n$$\n\\frac{d\\lambda}{du} = - \\frac{k + 3\\beta\\,u^{2}}{-P} = \\frac{k + 3\\beta\\,u^{2}}{P}\n$$\n\n**2. Condition for a Load-Controlled Limit Point and Interpretation**\n\nA load-controlled limit point (or extremum point on the load-displacement path) occurs when the tangent to the equilibrium path in the $\\lambda-u$ plane is horizontal. This corresponds to the mathematical condition:\n$$\n\\frac{d\\lambda}{du} = 0\n$$\nUsing the expression derived above, this condition becomes:\n$$\n\\frac{k + 3\\beta\\,u^{2}}{P} = 0\n$$\nSince the reference load $P$ is given to be positive ($P0$), the condition for a limit point simplifies to the numerator being zero:\n$$\nk + 3\\beta\\,u^{2} = 0\n$$\nFor this equation to have a real, non-zero solution for the displacement $u$, the signs of the terms must be opposite. We are given that the initial stiffness $k$ is positive ($k0$). Also, $u^2$ is always non-negative. Therefore, a solution can only exist if the nonlinearity parameter $\\beta$ is negative ($\\beta  0$). This type of behavior where the stiffness decreases with increasing displacement magnitude is known as \"softening\" nonlinearity. If $\\beta \\ge 0$ (a \"hardening\" or linear system), the term $k + 3\\beta\\,u^{2}$ is always positive, meaning $\\frac{d\\lambda}{du}$ is always positive, and no load-controlled limit point exists.\n\n**Interpretation:**\nThe sign of the slope $\\frac{d\\lambda}{du}$ indicates the stability of the equilibrium path under load control.\n- When $\\frac{d\\lambda}{du}  0$, the equilibrium is stable. An infinitesimal increase in load $\\lambda$ corresponds to an increase in displacement $u$.\n- When $\\frac{d\\lambda}{du}  0$, the equilibrium is unstable. To trace this portion of the path, the load must decrease as the displacement magnitude increases. In a load-controlled physical experiment where the load is monotonically increased, the system cannot follow this unstable path. Instead, upon reaching the limit point where $\\frac{d\\lambda}{du}=0$, it will undergo a dynamic jump, or \"snap\", to a distant stable equilibrium state at a much larger displacement. This phenomenon is known as **snap-through**.\n- The limit point itself marks the transition from stability to instability. The instability is characterized by a \"loss of stiffness\" of the system with respect to the applied load. The quantity $k+3\\beta u^2$ is called the tangent stiffness of the system's internal force response. A limit point occurs precisely when this tangent stiffness vanishes. The term **snap-back** typically refers to a more complex path topology where the path reverses in both load and displacement, creating a C-shaped curve in the $\\lambda-u$ plane. While this simple model primarily illustrates snap-through, the negative slope region is the characteristic feature that both phenomena share.\n\n**3. Determination of the Critical Displacement $u_{c}$**\n\nFor the softening case ($\\beta  0$), we can now solve for the critical displacement $u_c$ at which the limit point occurs. We use the limit point condition derived previously:\n$$\nk + 3\\beta\\,u^{2} = 0\n$$\nSolving for $u^2$:\n$$\n3\\beta\\,u^{2} = -k\n$$\n$$\nu^{2} = -\\frac{k}{3\\beta}\n$$\nSince $k0$ and $\\beta0$ for the softening case, the right-hand side is a positive real number, ensuring that real solutions for $u$ exist. Taking the square root of both sides gives two possible values for the critical displacement:\n$$\nu = \\pm \\sqrt{-\\frac{k}{3\\beta}}\n$$\nThe problem asks for the positive critical displacement magnitude, which we denote as $u_c$. Therefore, we take the positive root:\n$$\nu_c = \\sqrt{-\\frac{k}{3\\beta}}\n$$\nThis is the final closed-form expression for the positive critical displacement.",
            "answer": "$$\n\\boxed{\\sqrt{-\\frac{k}{3\\beta}}}\n$$"
        },
        {
            "introduction": "The arc-length algorithm proceeds in a predictor-corrector fashion, where the 'predictor' step involves taking an initial step along the tangent to the last known point on the equilibrium path. This exercise  provides a concrete, hands-on calculation of this predictor step, focusing on how the arc-length constraint equation is used to determine the initial increments in both displacement, $\\hat{\\Delta u}$, and load, $\\hat{\\Delta\\lambda}$. Mastering this calculation is a key first step toward building a full arc-length solver and understanding how the step size is controlled.",
            "id": "3501079",
            "problem": "Consider a quasi-static nonlinear Finite Element Method (FEM) analysis in computational geomechanics where the external load vector is applied proportionally to a scalar load factor $\\lambda$. At the start of a new load step, the tangent linearization of the equilibrium equations about the current configuration $(u_{n},\\lambda_{n})$ gives the predictor direction by solving the linear system $K_{t}\\,\\hat{v} = f_{\\text{ext}}$, where $K_{t}$ is the current consistent tangent stiffness and $f_{\\text{ext}}$ is the reference load vector. An arc-length path-following constraint is enforced in the Riks–Crisfield framework by requiring\n$$\ng(\\Delta u,\\Delta \\lambda) \\;=\\; \\Delta u^{\\top} W \\,\\Delta u \\;+\\; c\\,(\\Delta \\lambda)^{2} \\;-\\; (\\Delta s)^{2} \\;=\\; 0,\n$$\nwhere $W$ is a symmetric positive-definite weighting matrix, $c0$ is a scalar coupling coefficient, and $\\Delta s0$ is the prescribed arc-length.\n\nAssume a nondimensionalized two-degree-of-freedom system with\n$$\nK_{t} \\;=\\; \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix}, \n\\qquad\nf_{\\text{ext}} \\;=\\; \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix},\n\\qquad\nW \\;=\\; \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix},\n\\qquad\nc \\;=\\; \\frac{1}{2},\n\\qquad\n\\Delta s \\;=\\; 0.1.\n$$\nLet $\\hat{v}$ be the solution of $K_{t}\\,\\hat{v} = f_{\\text{ext}}$, and define the initial Riks–Crisfield predictor by the scaled pair $(\\hat{\\Delta u},\\hat{\\Delta\\lambda}) = (\\alpha\\,\\hat{v},\\,\\alpha)$, where the sign of $\\alpha$ is chosen so that $\\hat{\\Delta\\lambda}  0$. Compute the scaling factor $\\alpha$ that enforces $g(\\hat{\\Delta u},\\hat{\\Delta\\lambda})=0$.\n\nProvide the numerical value of $\\alpha$ rounded to six significant figures. Since $\\alpha$ is dimensionless, no physical units are required.",
            "solution": "The task is to calculate the scaling factor $\\alpha$ for the initial predictor in a Riks-Crisfield arc-length method.\n\nThe given data are:\nThe tangent stiffness matrix $K_{t} = \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix}$.\nThe reference external load vector $f_{\\text{ext}} = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$.\nThe weighting matrix $W = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}$.\nThe scalar coupling coefficient $c = \\frac{1}{2}$.\nThe prescribed arc-length $\\Delta s = 0.1$.\n\nThe solution proceeds in three steps.\n\nFirst, we compute the tangent predictor displacement vector $\\hat{v}$ by solving the linear system $K_{t}\\,\\hat{v} = f_{\\text{ext}}$. To do this, we find the inverse of $K_{t}$. The determinant of $K_{t}$ is $\\det(K_{t}) = (4)(3) - (1)(1) = 11$.\nThe inverse matrix is:\n$$\nK_{t}^{-1} = \\frac{1}{\\det(K_{t})} \\begin{pmatrix} 3  -1 \\\\ -1  4 \\end{pmatrix} = \\frac{1}{11} \\begin{pmatrix} 3  -1 \\\\ -1  4 \\end{pmatrix}\n$$\nNow, we calculate $\\hat{v}$:\n$$\n\\hat{v} = K_{t}^{-1} f_{\\text{ext}} = \\frac{1}{11} \\begin{pmatrix} 3  -1 \\\\ -1  4 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\frac{1}{11} \\begin{pmatrix} (3)(1) + (-1)(2) \\\\ (-1)(1) + (4)(2) \\end{pmatrix} = \\frac{1}{11} \\begin{pmatrix} 3 - 2 \\\\ -1 + 8 \\end{pmatrix} = \\frac{1}{11} \\begin{pmatrix} 1 \\\\ 7 \\end{pmatrix}\n$$\nSo, the tangent predictor displacement vector is $\\hat{v} = \\begin{pmatrix} \\frac{1}{11} \\\\ \\frac{7}{11} \\end{pmatrix}$.\n\nSecond, we use the arc-length constraint equation to find $\\alpha$. The constraint is:\n$$\ng(\\Delta u, \\Delta \\lambda) = \\Delta u^{\\top} W \\,\\Delta u + c\\,(\\Delta \\lambda)^{2} - (\\Delta s)^{2} = 0\n$$\nThe problem specifies the predictor to be $(\\hat{\\Delta u}, \\hat{\\Delta\\lambda}) = (\\alpha\\,\\hat{v}, \\alpha)$. Substituting these into the constraint equation yields:\n$$\n(\\alpha\\,\\hat{v})^{\\top} W (\\alpha\\,\\hat{v}) + c\\,(\\alpha)^{2} - (\\Delta s)^{2} = 0\n$$\nFactoring out the scalar $\\alpha$:\n$$\n\\alpha^{2} (\\hat{v}^{\\top} W \\hat{v}) + c\\,\\alpha^{2} - (\\Delta s)^{2} = 0\n$$\n$$\n\\alpha^{2} (\\hat{v}^{\\top} W \\hat{v} + c) = (\\Delta s)^{2}\n$$\nSolving for $\\alpha^2$:\n$$\n\\alpha^{2} = \\frac{(\\Delta s)^{2}}{\\hat{v}^{\\top} W \\hat{v} + c}\n$$\nWe need to evaluate the term $\\hat{v}^{\\top} W \\hat{v}$:\n$$\n\\hat{v}^{\\top} W \\hat{v} = \\left(\\frac{1}{11} \\begin{pmatrix} 1 \\\\ 7 \\end{pmatrix}\\right)^{\\top} \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix} \\left(\\frac{1}{11} \\begin{pmatrix} 1 \\\\ 7 \\end{pmatrix}\\right) = \\frac{1}{121} \\begin{pmatrix} 1  7 \\end{pmatrix} \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 7 \\end{pmatrix}\n$$\n$$\n= \\frac{1}{121} \\begin{pmatrix} 1  7 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 7 \\end{pmatrix} = \\frac{1}{121} ((1)(2) + (7)(7)) = \\frac{1}{121} (2 + 49) = \\frac{51}{121}\n$$\nNow, we compute the denominator of the expression for $\\alpha^2$:\n$$\n\\hat{v}^{\\top} W \\hat{v} + c = \\frac{51}{121} + \\frac{1}{2} = \\frac{2 \\times 51 + 1 \\times 121}{2 \\times 121} = \\frac{102 + 121}{242} = \\frac{223}{242}\n$$\nThe numerator is $(\\Delta s)^{2} = (0.1)^{2} = 0.01 = \\frac{1}{100}$.\nSubstituting these results back into the expression for $\\alpha^2$:\n$$\n\\alpha^{2} = \\frac{\\frac{1}{100}}{\\frac{223}{242}} = \\frac{1}{100} \\cdot \\frac{242}{223} = \\frac{242}{22300} = \\frac{121}{11150}\n$$\n\nThird, we solve for $\\alpha$.\n$$\n\\alpha = \\pm \\sqrt{\\frac{121}{11150}} = \\pm \\frac{11}{\\sqrt{11150}}\n$$\nThe problem requires that the sign of $\\alpha$ be chosen such that $\\hat{\\Delta\\lambda}  0$. Since $\\hat{\\Delta\\lambda} = \\alpha$, we must select the positive root:\n$$\n\\alpha = \\frac{11}{\\sqrt{11150}}\n$$\nWe compute the numerical value:\n$$\n\\alpha \\approx \\frac{11}{105.5935591} \\approx 0.104173105\n$$\nRounding to six significant figures as required by the problem statement, we obtain:\n$$\n\\alpha \\approx 0.104173\n$$",
            "answer": "$$\n\\boxed{0.104173}\n$$"
        },
        {
            "introduction": "This final practice  integrates the core concepts into a complete path-following solver applied to a classic geomechanics problem. You will implement a full predictor-corrector algorithm to trace the load-settlement curve of a footing on soil, including the challenging post-peak softening regime that characterizes materials like crushable sands or brittle clays. By comparing the behavior of a softening soil model against a purely hardening one, you will see firsthand the power and necessity of arc-length methods for capturing complex material responses and structural failure.",
            "id": "3501082",
            "problem": "A rigid strip footing of infinite length is modeled under plane strain on a homogeneous, compressible granular soil. The footing settlement is represented by a single generalized displacement $u$ in meters. The external load resultant per unit out-of-plane length is represented by $\\lambda P_{\\mathrm{ref}}$ in kilonewton per meter, where $P_{\\mathrm{ref}}$ is a constant reference load and $\\lambda$ is a dimensionless load factor. The soil reaction is modeled as a spatially uniform contact pressure proxy $q(u;\\boldsymbol{\\theta})$ in kilonewton per meter that depends only on the settlement $u$ and on model parameters $\\boldsymbol{\\theta}$ that characterize the constitutive behavior of the soil.\n\nThe reduced equilibrium of the footing is written as the scalar residual\n$$\nr(u,\\lambda;\\boldsymbol{\\theta}) \\equiv q(u;\\boldsymbol{\\theta}) - \\lambda P_{\\mathrm{ref}} = 0.\n$$\nThe objective is to numerically follow the entire equilibrium branch $\\{(u,\\lambda)\\,|\\, r(u,\\lambda;\\boldsymbol{\\theta})=0\\}$ beyond a peak load by means of an arc-length path-following method of the Riks–Crisfield type. The tangent required by the method is the scalar stiffness\n$$\nK_{\\mathrm{t}}(u;\\boldsymbol{\\theta}) \\equiv \\dfrac{\\partial q(u;\\boldsymbol{\\theta})}{\\partial u}.\n$$\n\nTwo soil constitutive surrogates are to be compared under identical boundary conditions:\n- A crushable form intended to mimic a $p$–$\\alpha$ cap response with progressive crushing, which exhibits a post-peak softening of the reaction with settlement.\n- A ductile hardening form intended to mimic Modified Cam-Clay under predominantly compressive volumetric loading, which exhibits monotonic hardening to a plateau without a limit point.\n\nTo ensure a well-posed and testable problem without recourse to a full finite element model, define the following surrogate reaction laws (all parameters are positive and have the indicated units):\n- $p$–$\\alpha$-like crushable surrogate:\n$$\nq_{\\mathrm{pa}}(u; a_1,b_1,a_2,b_2) = a_1\\,u\\,e^{-b_1 u} \\;+\\; a_2\\left(1-e^{-b_2 u}\\right),\n$$\nwith tangent\n$$\nK_{\\mathrm{t,pa}}(u; a_1,b_1,a_2,b_2) = a_1 e^{-b_1 u}\\left(1-b_1 u\\right) \\;+\\; a_2 b_2 e^{-b_2 u}.\n$$\nHere $a_1$ is in kilonewton per meter squared, $b_1$ is in inverse meters, $a_2$ is in kilonewton per meter, and $b_2$ is in inverse meters.\n- Modified Cam-Clay-like ductile surrogate:\n$$\nq_{\\mathrm{mcc}}(u; S,\\beta) = S\\left(1-e^{-\\beta u}\\right),\n$$\nwith tangent\n$$\nK_{\\mathrm{t,mcc}}(u; S,\\beta) = S\\beta e^{-\\beta u},\n$$\nwhere $S$ is in kilonewton per meter and $\\beta$ is in inverse meters.\n\nBoth surrogates are consistent with the geomechanical statement that the footing reaction is the integral of a pressure distribution that, under the simplifying assumptions adopted, depends only on $u$ and saturates or softens after an initial hardening phase due to crushing or plastic compaction.\n\nImplement a two-equation, two-unknown arc-length procedure for the scalar system with unknowns $(u,\\lambda)$, based on:\n- Equilibrium: $r(u,\\lambda;\\boldsymbol{\\theta}) = 0$.\n- Crisfield-type spherical constraint per increment $n\\to n+1$:\n$$\ng(u,\\lambda;u_n,\\lambda_n) \\equiv (u-u_n)^2 + \\psi (\\lambda-\\lambda_n)^2 - \\Delta s^2 = 0,\n$$\nwhere $\\psi$ is a positive scaling parameter that balances units, and $\\Delta s$ is the prescribed arc-length size. For each increment, the Newton correction system should use the Jacobian of the residuals assembled from $K_{\\mathrm{t}}(u;\\boldsymbol{\\theta})$ and the linearization of $g$.\n\nUse the following test suite. In all cases, take $P_{\\mathrm{ref}} = 1\\,\\mathrm{kN/m}$, so that the load factor $\\lambda$ numerically equals the footing reaction in $\\mathrm{kN/m}$. Express all displacements in meters and all loads in $\\mathrm{kN/m}$. Use radians implicitly for any exponential arguments (dimensionally consistent with inverse meters as specified). For each case, run the arc-length tracing for both models with identical algorithmic settings and report the requested quantities.\n\nCommon algorithmic parameters for all cases:\n- Initial state $(u_0,\\lambda_0) = (0,0)$.\n- Arc-length size $\\Delta s = 0.002\\,\\mathrm{m}$.\n- Scaling $\\psi = 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{kN/m})^2$.\n- Number of continuation steps $N_{\\mathrm{steps}} = 200$.\n- Newton iterations per step with a robust stopping criterion based on the norms of $r$ and $g$.\n\nTest cases (parameters in consistent units as specified):\n- Case $1$ (strong crushable softening versus ductile hardening):\n  - $p$–$\\alpha$ surrogate: $(a_1,b_1,a_2,b_2) = (120000, 20, 300, 3)$.\n  - Modified Cam-Clay surrogate: $(S,\\beta) = (1800, 8)$.\n- Case $2$ (milder softening):\n  - $p$–$\\alpha$ surrogate: $(a_1,b_1,a_2,b_2) = (70000, 12, 600, 1.5)$.\n  - Modified Cam-Clay surrogate: $(S,\\beta) = (1100, 5)$.\n- Case $3$ (near-plateau behavior):\n  - $p$–$\\alpha$ surrogate: $(a_1,b_1,a_2,b_2) = (40000, 8, 900, 1)$.\n  - Modified Cam-Clay surrogate: $(S,\\beta) = (900, 4)$.\n\nFor each test case, compute using the arc-length method the following four outputs:\n- The maximum equilibrium load per unit length for the $p$–$\\alpha$ surrogate, $\\max\\lambda_{\\mathrm{pa}}$, in $\\mathrm{kN/m}$, rounded to two decimal places.\n- The maximum equilibrium load per unit length for the Modified Cam-Clay surrogate, $\\max\\lambda_{\\mathrm{mcc}}$, in $\\mathrm{kN/m}$, rounded to two decimal places.\n- A boolean indicating whether a limit point was detected in the $p$–$\\alpha$ branch (defined as a sign change of $K_{\\mathrm{t,pa}}$ along the traced path).\n- A boolean indicating whether a limit point was detected in the Modified Cam-Clay branch (defined as a sign change of $K_{\\mathrm{t,mcc}}$ along the traced path).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order specified above. For example: \"[[case1_result1,case1_result2,case1_result3,case1_result4],[case2_result1,case2_result2,case2_result3,case2_result4],[case3_result1,case3_result2,case3_result3,case3_result4]]\".",
            "solution": "The solution requires implementing a Crisfield-type arc-length path-following algorithm. This method is essential for analyzing systems that may exhibit limit points (e.g., maximum load points followed by softening), where standard load-controlled or displacement-controlled methods fail. The method augments the physical equilibrium equation with a constraint equation that guides the solution along the equilibrium path in the load-displacement space.\n\nFor each step $n \\to n+1$ along the path, we seek a new equilibrium point $(u_{n+1}, \\lambda_{n+1})$ that is a prescribed \"distance\" $\\Delta s$ away from the previously converged point $(u_n, \\lambda_n)$. This leads to a system of two nonlinear equations for two unknowns, $(u, \\lambda)$:\n\n1.  Equilibrium: $r(u, \\lambda) = q(u;\\boldsymbol{\\theta}) - \\lambda P_{\\mathrm{ref}} = 0$\n2.  Arc-Length Constraint: $g(u, \\lambda) = (u - u_n)^2 + \\psi (\\lambda - \\lambda_n)^2 - \\Delta s^2 = 0$\n\nHere, $\\psi$ is a scaling factor to make the two terms in the constraint dimensionally homogeneous and of comparable magnitude. This system is solved iteratively using a predictor-corrector scheme based on Newton's method.\n\n**1. Predictor Step**\n\nFirst, an initial estimate for the new point, $(u_{n+1}^{(0)}, \\lambda_{n+1}^{(0)})$, is made by moving a distance $\\Delta s$ along the tangent to the path at the current point $(u_n, \\lambda_n)$. The tangent vector $(\\dot{u}, \\dot{\\lambda})$ is found by differentiating the equilibrium equation with respect to the arc-length parameter $s$:\n$$\n\\dfrac{dr}{ds} = \\dfrac{\\partial r}{\\partial u}\\dfrac{du}{ds} + \\dfrac{\\partial r}{\\partial \\lambda}\\dfrac{d\\lambda}{ds} = K_t \\dot{u} - P_{\\mathrm{ref}} \\dot{\\lambda} = 0\n$$\nThe tangent vector must also be of unit length with respect to the arc-length metric: $\\dot{u}^2 + \\psi \\dot{\\lambda}^2 = 1$. Combining these two conditions allows for solving for $\\dot{u}$ and $\\dot{\\lambda}$. The predictor point is then:\n$$\n(u_{n+1}^{(0)}, \\lambda_{n+1}^{(0)}) = (u_n, \\lambda_n) + \\Delta s (\\dot{u}_n, \\dot{\\lambda}_n)\n$$\nThe sign of the tangent vector is chosen to ensure the path continues in a consistent direction, typically by checking that its dot product with the previous tangent vector is positive.\n\n**2. Corrector Step**\n\nStarting from the predictor point $(u_k, \\lambda_k) = (u_{n+1}^{(0)}, \\lambda_{n+1}^{(0)})$, we use Newton's method to find a correction $(\\delta u, \\delta \\lambda)$ that drives the residuals of both equations to zero. The linear system to be solved at each Newton iteration $k$ is:\n$$\n\\mathbf{J}(\\mathbf{x}_k) \\Delta \\mathbf{x}_k = -\\mathbf{R}(\\mathbf{x}_k)\n$$\nwhere $\\mathbf{x}_k = [u_k, \\lambda_k]^T$ is the current guess, $\\mathbf{R}(\\mathbf{x}_k) = [r(u_k, \\lambda_k), g(u_k, \\lambda_k)]^T$ is the residual vector, and $\\mathbf{J}$ is the Jacobian matrix of the system:\n$$\n\\mathbf{J} =\n\\begin{bmatrix}\n\\frac{\\partial r}{\\partial u}  \\frac{\\partial r}{\\partial \\lambda} \\\\\n\\frac{\\partial g}{\\partial u}  \\frac{\\partial g}{\\partial \\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nK_t(u)  -P_{\\mathrm{ref}} \\\\\n2(u - u_n)  2\\psi(\\lambda - \\lambda_n)\n\\end{bmatrix}\n$$\nThe solution $\\Delta \\mathbf{x}_k = [\\delta u, \\delta \\lambda]^T$ is used to update the guess: $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta \\mathbf{x}_k$. This iterative process is repeated until the norm of the residual vector falls below a specified tolerance. The resulting converged point is $(u_{n+1}, \\lambda_{n+1})$.\n\n**3. Path Continuation and Analysis**\n\nThe algorithm proceeds for the specified number of steps ($N_{\\mathrm{steps}} = 200$), storing the converged points $(u_i, \\lambda_i)$ at each step $i$. A limit point is detected when the tangent stiffness $K_t$ changes sign between two consecutive converged steps, indicating the equilibrium path has reached a local extremum in load. For the monotonic hardening MCC model, $K_t$ is always positive, so no limit point is expected. For the softening $p$–$\\alpha$ model, a limit point is possible. Once all steps are completed, the maximum load factor, $\\max \\lambda$, is found by taking the maximum value from the stored $\\lambda_i$ path. The requested outputs are then compiled for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the arc-length path-following problem.\n    \"\"\"\n\n    # --- Constitutive Surrogates and Tangents ---\n\n    def q_pa(u, a1, b1, a2, b2):\n        \"\"\"p-alpha-like crushable surrogate reaction law.\"\"\"\n        return a1 * u * np.exp(-b1 * u) + a2 * (1.0 - np.exp(-b2 * u))\n\n    def Kt_pa(u, a1, b1, a2, b2):\n        \"\"\"Tangent stiffness for the p-alpha surrogate.\"\"\"\n        return a1 * np.exp(-b1 * u) * (1.0 - b1 * u) + a2 * b2 * np.exp(-b2 * u)\n\n    def q_mcc(u, S, beta):\n        \"\"\"Modified Cam-Clay-like ductile surrogate reaction law.\"\"\"\n        if u  0: return 0.0 # Physical constraint\n        return S * (1.0 - np.exp(-beta * u))\n\n    def Kt_mcc(u, S, beta):\n        \"\"\"Tangent stiffness for the MCC surrogate.\"\"\"\n        if u  0: return S * beta # Physical constraint\n        return S * beta * np.exp(-beta * u)\n\n    # --- Arc-Length Solver ---\n\n    def arc_length_solver(q_func, Kt_func, params, settings):\n        \"\"\"\n        Implements a Crisfield-type arc-length solver for the scalar system.\n\n        Args:\n            q_func (function): The soil reaction function q(u, *params).\n            Kt_func (function): The tangent stiffness function Kt(u, *params).\n            params (tuple): Model parameters for q_func and Kt_func.\n            settings (dict): Algorithmic settings (P_ref, ds, psi, etc.).\n\n        Returns:\n            tuple: (max_lambda, limit_point_detected)\n        \"\"\"\n        # Unpack settings\n        P_ref = settings['P_ref']\n        u0, lambda0 = settings['u0'], settings['lambda0']\n        ds, psi = settings['ds'], settings['psi']\n        N_steps = settings['N_steps']\n\n        newton_tol = 1e-9\n        max_newton_iter = 15\n\n        # Path storage\n        u_path = [u0]\n        lambda_path = [lambda0]\n\n        # Initial state\n        u_n, lambda_n = u0, lambda0\n        \n        # Limit point tracking\n        limit_point_detected = False\n        Kt_n = Kt_func(u_n, *params)\n        Kt_sign_prev = np.sign(Kt_n) if Kt_n != 0 else 1.0\n\n        # Initial tangent vector (dot_u, dot_lambda)\n        if abs(Kt_n)  1e-12:\n            dot_u, dot_lambda = 1.0, 0.0\n        else:\n            norm_factor = np.sqrt((P_ref / Kt_n)**2 + psi)\n            dot_lambda = 1.0 / norm_factor  # Assume initial load increase\n            dot_u = (P_ref / Kt_n) * dot_lambda\n\n        for _ in range(N_steps):\n            # Predictor step\n            u_pred = u_n + ds * dot_u\n            lambda_pred = lambda_n + ds * dot_lambda\n            \n            u_k, lambda_k = u_pred, lambda_pred\n\n            # Corrector step (Newton-Raphson)\n            converged = False\n            for _ in range(max_newton_iter):\n                r_k = q_func(u_k, *params) - lambda_k * P_ref\n                g_k = (u_k - u_n)**2 + psi * (lambda_k - lambda_n)**2 - ds**2\n                \n                res_vec = np.array([-r_k, -g_k])\n\n                if np.linalg.norm(res_vec)  newton_tol:\n                    converged = True\n                    break\n                \n                Kt_k = Kt_func(u_k, *params)\n                J = np.array([\n                    [Kt_k, -P_ref],\n                    [2.0 * (u_k - u_n), 2.0 * psi * (lambda_k - lambda_n)]\n                ])\n                \n                try:\n                    delta = np.linalg.solve(J, res_vec)\n                except np.linalg.LinAlgError:\n                    break # Failed to converge\n                \n                u_k += delta[0]\n                lambda_k += delta[1]\n            \n            if not converged:\n                # In a real application, would add logic like reducing ds\n                break\n\n            # Update state with converged point\n            u_n1, lambda_n1 = u_k, lambda_k\n            u_path.append(u_n1)\n            lambda_path.append(lambda_n1)\n\n            # Check for limit point\n            Kt_n1 = Kt_func(u_n1, *params)\n            Kt_sign_curr = np.sign(Kt_n1) if Kt_n1 != 0 else Kt_sign_prev\n            if not limit_point_detected and Kt_sign_curr * Kt_sign_prev  0:\n                limit_point_detected = True\n            if Kt_sign_curr != 0:\n                Kt_sign_prev = Kt_sign_curr\n\n            # Calculate next tangent vector\n            if abs(Kt_n1)  1e-12: # Vertical tangent at limit point\n                dot_u_new = 1.0\n                dot_lambda_new = 0.0\n            else: # Regular case\n                norm_factor = np.sqrt((P_ref / Kt_n1)**2 + psi)\n                dot_lambda_new = 1.0 / norm_factor\n                dot_u_new = (P_ref / Kt_n1) * dot_lambda_new\n\n            # Ensure consistent direction of traversal\n            if dot_u_new * dot_u + dot_lambda_new * dot_lambda  0:\n                dot_u_new *= -1.0\n                dot_lambda_new *= -1.0\n\n            # Update for next step\n            u_n, lambda_n = u_n1, lambda_n1\n            dot_u, dot_lambda = dot_u_new, dot_lambda_new\n\n        max_lambda = np.max(lambda_path) if lambda_path else 0.0\n        return max_lambda, limit_point_detected\n\n    # --- Test Execution ---\n    \n    settings = {\n        'P_ref': 1.0,\n        'u0': 0.0,\n        'lambda0': 0.0,\n        'ds': 0.002,\n        'psi': 1.0e-6,\n        'N_steps': 200,\n    }\n\n    test_cases = [\n        {'pa_params': (120000.0, 20.0, 300.0, 3.0), 'mcc_params': (1800.0, 8.0)},\n        {'pa_params': (70000.0, 12.0, 600.0, 1.5), 'mcc_params': (1100.0, 5.0)},\n        {'pa_params': (40000.0, 8.0, 900.0, 1.0), 'mcc_params': (900.0, 4.0)},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        max_lambda_pa, lp_pa = arc_length_solver(q_pa, Kt_pa, case['pa_params'], settings)\n        max_lambda_mcc, lp_mcc = arc_length_solver(q_mcc, Kt_mcc, case['mcc_params'], settings)\n        \n        case_results = [\n            max_lambda_pa,\n            max_lambda_mcc,\n            lp_pa,\n            lp_mcc\n        ]\n        all_results.append(case_results)\n\n    # Format output string exactly as requested\n    case_strs = []\n    for res in all_results:\n        val1 = f\"{res[0]:.2f}\"\n        val2 = f\"{res[1]:.2f}\"\n        val3 = str(res[2])\n        val4 = str(res[3])\n        case_strs.append(f\"[{val1},{val2},{val3},{val4}]\")\n    \n    final_output = f\"[{','.join(case_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}