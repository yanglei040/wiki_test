{
    "hands_on_practices": [
        {
            "introduction": "To appreciate the power of arc-length methods, we must first understand the problem they are designed to solve: the failure of conventional analysis at limit points. This foundational exercise uses a simple one-degree-of-freedom model to analytically explore the conditions under which a system's tangent stiffness vanishes, leading to instabilities like snap-through behavior. By deriving the properties of the equilibrium path from first principles, you will gain a concrete understanding of the mathematical and physical nature of limit points, which motivate the need for path-following techniques .",
            "id": "3501024",
            "problem": "Consider a one-degree-of-freedom nonlinear equilibrium model representative of a proportional loading process in computational geomechanics, where the scalar displacement is $u$ and the load factor is $\\lambda$. The governing equilibrium equation is\n$$\nF(u,\\lambda) \\equiv k\\,u + \\beta\\,u^{3} - \\lambda\\,P = 0,\n$$\nwith $k>0$ the initial linear stiffness, $\\beta$ a constant characterizing geometric or constitutive nonlinearity, and $P>0$ a fixed reference load magnitude (so that the physical load is $\\lambda P$). This setting appears as a reduced-order proxy for tracing equilibrium paths by the Riks and Crisfield arc-length methods in the presence of limit points.\n\nStarting from the equilibrium definition and the assumption that the equilibrium path $\\lambda(u)$ is differentiable wherever it is single-valued, use first principles (implicit differentiation and the implicit function theorem) to:\n- Derive the expression for the tangent slope $d\\lambda/du$ along the equilibrium path.\n- Using your expression, state the condition on $\\beta$ and $u$ under which a load-controlled limit point occurs and interpret it in terms of snap-through versus snap-back, relating each to the sign of $d\\lambda/du$. Assume $P>0$ and $k>0$ throughout.\n- Under the softening case that admits a load-controlled limit point, determine the positive critical displacement magnitude $u_{c}$ at which $d\\lambda/du=0$.\n\nAnswer specification: Provide a single closed-form expression for the positive critical displacement $u_{c}$ in terms of $k$ and $\\beta$, assuming $\\beta<0$, $k>0$, and $P>0$. Do not approximate or round. No units are required for the final expression.",
            "solution": "The user has provided a problem statement that successfully passes the validation protocol. It is scientifically grounded, well-posed, objective, and contains all necessary information for a complete solution. The problem describes a canonical one-degree-of-freedom model used to illustrate concepts of nonlinear structural stability, specifically the occurrence of limit points, which motivates the use of path-following numerical techniques like the Riks and Crisfield arc-length methods in computational mechanics.\n\nThe analysis proceeds by applying the principles of calculus to the given equilibrium equation.\n\nThe governing equilibrium equation for the system is given by:\n$$\nF(u,\\lambda) = k\\,u + \\beta\\,u^{3} - \\lambda\\,P = 0\n$$\nwhere $u$ is the displacement, $\\lambda$ is the load factor, $k>0$ is the initial stiffness, $\\beta$ is a nonlinearity parameter, and $P>0$ is a reference load. We are to find the equilibrium path, which can be expressed as the function $\\lambda(u)$.\n\n**1. Derivation of the Tangent Slope $d\\lambda/du$**\n\nTo find the slope of the equilibrium path in the $\\lambda-u$ plane, we can differentiate the equilibrium equation with respect to $u$. This is an application of implicit differentiation, formally justified by the implicit function theorem, as the problem suggests. The theorem states that if $F(u, \\lambda) = 0$ and $\\frac{\\partial F}{\\partial \\lambda} \\neq 0$, then $\\lambda$ can be expressed as a function of $u$ and its derivative is given by:\n$$\n\\frac{d\\lambda}{du} = - \\frac{\\partial F / \\partial u}{\\partial F / \\partial \\lambda}\n$$\nFirst, we compute the required partial derivatives of $F(u, \\lambda) = k\\,u + \\beta\\,u^{3} - \\lambda\\,P$:\nThe partial derivative with respect to displacement $u$ is:\n$$\n\\frac{\\partial F}{\\partial u} = \\frac{\\partial}{\\partial u} (k\\,u + \\beta\\,u^{3} - \\lambda\\,P) = k + 3\\beta\\,u^{2}\n$$\nThe partial derivative with respect to the load factor $\\lambda$ is:\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\frac{\\partial}{\\partial \\lambda} (k\\,u + \\beta\\,u^{3} - \\lambda\\,P) = -P\n$$\nSubstituting these partial derivatives into the formula from the implicit function theorem, we obtain the expression for the tangent slope:\n$$\n\\frac{d\\lambda}{du} = - \\frac{k + 3\\beta\\,u^{2}}{-P} = \\frac{k + 3\\beta\\,u^{2}}{P}\n$$\n\n**2. Condition for a Load-Controlled Limit Point and Interpretation**\n\nA load-controlled limit point (or extremum point on the load-displacement path) occurs when the tangent to the equilibrium path in the $\\lambda-u$ plane is horizontal. This corresponds to the mathematical condition:\n$$\n\\frac{d\\lambda}{du} = 0\n$$\nUsing the expression derived above, this condition becomes:\n$$\n\\frac{k + 3\\beta\\,u^{2}}{P} = 0\n$$\nSince the reference load $P$ is given to be positive ($P>0$), the condition for a limit point simplifies to the numerator being zero:\n$$\nk + 3\\beta\\,u^{2} = 0\n$$\nFor this equation to have a real, non-zero solution for the displacement $u$, the signs of the terms must be opposite. We are given that the initial stiffness $k$ is positive ($k>0$). Also, $u^2$ is always non-negative. Therefore, a solution can only exist if the nonlinearity parameter $\\beta$ is negative ($\\beta < 0$). This type of behavior where the stiffness decreases with increasing displacement magnitude is known as \"softening\" nonlinearity. If $\\beta \\ge 0$ (a \"hardening\" or linear system), the term $k + 3\\beta\\,u^{2}$ is always positive, meaning $\\frac{d\\lambda}{du}$ is always positive, and no load-controlled limit point exists.\n\n**Interpretation:**\nThe sign of the slope $\\frac{d\\lambda}{du}$ indicates the stability of the equilibrium path under load control.\n- When $\\frac{d\\lambda}{du} > 0$, the equilibrium is stable. An infinitesimal increase in load $\\lambda$ corresponds to an increase in displacement $u$.\n- When $\\frac{d\\lambda}{du} < 0$, the equilibrium is unstable. To trace this portion of the path, the load must decrease as the displacement magnitude increases. In a load-controlled physical experiment where the load is monotonically increased, the system cannot follow this unstable path. Instead, upon reaching the limit point where $\\frac{d\\lambda}{du}=0$, it will undergo a dynamic jump, or \"snap\", to a distant stable equilibrium state at a much larger displacement. This phenomenon is known as **snap-through**.\n- The limit point itself marks the transition from stability to instability. The instability is characterized by a \"loss of stiffness\" of the system with respect to the applied load. The quantity $k+3\\beta u^2$ is called the tangent stiffness of the system's internal force response. A limit point occurs precisely when this tangent stiffness vanishes. The term **snap-back** typically refers to a more complex path topology where the path reverses in both load and displacement, creating a C-shaped curve in the $\\lambda-u$ plane. While this simple model primarily illustrates snap-through, the negative slope region is the characteristic feature that both phenomena share.\n\n**3. Determination of the Critical Displacement $u_{c}$**\n\nFor the softening case ($\\beta < 0$), we can now solve for the critical displacement $u_c$ at which the limit point occurs. We use the limit point condition derived previously:\n$$\nk + 3\\beta\\,u^{2} = 0\n$$\nSolving for $u^2$:\n$$\n3\\beta\\,u^{2} = -k\n$$\n$$\nu^{2} = -\\frac{k}{3\\beta}\n$$\nSince $k>0$ and $\\beta<0$ for the softening case, the right-hand side is a positive real number, ensuring that real solutions for $u$ exist. Taking the square root of both sides gives two possible values for the critical displacement:\n$$\nu = \\pm \\sqrt{-\\frac{k}{3\\beta}}\n$$\nThe problem asks for the positive critical displacement magnitude, which we denote as $u_c$. Therefore, we take the positive root:\n$$\nu_c = \\sqrt{-\\frac{k}{3\\beta}}\n$$\nThis is the final closed-form expression for the positive critical displacement.",
            "answer": "$$\n\\boxed{\\sqrt{-\\frac{k}{3\\beta}}}\n$$"
        },
        {
            "introduction": "Having established *why* path-following methods are necessary, we now turn to a critical aspect of *how* they are implemented. The quadratic nature of the arc-length constraint introduces an ambiguity in the direction of traversal along the solution path. This practice challenges you to develop a robust logical rule for selecting the correct sign of the load increment, ensuring the analysis consistently follows the equilibrium path without unintentionally reversing or jumping to another branch . The exercise emphasizes using physical principles, like incremental work, to guide the numerical algorithm.",
            "id": "3501046",
            "problem": "You are to derive and implement a robust sign update rule for the load scaling increment in arc-length path-following, suitable for the Riks and Crisfield formulations commonly used in computational geomechanics. Consider the nonlinear equilibrium problem defined by the residual equation $r(u,\\lambda) = f_{\\text{int}}(u) - \\lambda f_{\\text{ext}} = 0$, where $u$ is the displacement vector, $\\lambda$ is a dimensionless scalar load parameter that scales a fixed reference external load vector $f_{\\text{ext}}$, and $f_{\\text{int}}(u)$ is the internal force vector. In the arc-length method, the predictor-corrector step solves a linearized system coupled with an arc-length constraint of the form $g(\\Delta u, \\Delta \\lambda) = \\Delta u^{T} W \\Delta u + \\alpha \\Delta \\lambda^{2} - \\Delta s^{2} = 0$, where $W$ is a positive-definite weighting matrix, $\\alpha$ is a positive scaling constant, and $\\Delta s$ is the prescribed arc-length. Because the constraint is quadratic, the magnitude $\\lvert \\Delta \\lambda \\rvert$ is determined but its sign is ambiguous, leading to two symmetric candidates $\\Delta \\lambda = \\pm \\lvert \\Delta \\lambda \\rvert$. Choosing the wrong sign can cause branch switching at limit points or snap-throughs.\n\nStarting from the fundamental principle that the incremental external work input should be consistent with the intended load progression, derive a sign-update criterion expressed in terms of the incremental displacement $\\Delta u$ and the reference external load vector $f_{\\text{ext}}$. The criterion must decide the sign of $\\Delta \\lambda$ to avoid branch switching by checking either the scalar quantity $f_{\\text{ext}}^{T} \\Delta u$ or the commanded load increment direction. Your derivation must rely on first principles: the definitions of the residual equation, the arc-length constraint, and the incremental work concept, without introducing any shortcut formulas. Then design an algorithm that:\n- Computes the sign of $\\Delta \\lambda$ using the incremental external work $f_{\\text{ext}}^{T} \\Delta u$ as the primary test.\n- Employs a tie-breaker hierarchy when $f_{\\text{ext}}^{T} \\Delta u$ is within a small tolerance of zero (numerical ambiguity). The hierarchy must first use a commanded load direction, then the previous step’s $\\Delta \\lambda$, and finally a default positive sign if neither is available.\n- Produces the signed $\\Delta \\lambda = s \\lvert \\Delta \\lambda \\rvert$, where $s \\in \\{ -1, +1 \\}$ is the chosen sign, for each test case.\n\nAssume all quantities are non-dimensional and angles are not involved. The final output of your program must be a single line that aggregates the computed signed values of $\\Delta \\lambda$ for all test cases as a comma-separated list enclosed in square brackets, for example, \"[0.1,-0.2,0.05]\".\n\nUse the following test suite, which exercises different facets of the rule. In each tuple, the elements are, in order: the vector $f_{\\text{ext}}$, the vector $\\Delta u$, the positive magnitude $\\lvert \\Delta \\lambda \\rvert$, the previous increment $\\Delta \\lambda_{\\text{prev}}$, and the commanded direction $d$ where $d \\in \\{ -1, 0, +1 \\}$:\n1. $([10, 0], [0.001, 0], 0.05, 0.05, +1)$: A happy-path case where $f_{\\text{ext}}^{T} \\Delta u$ is clearly positive.\n2. $([10, 0], [-0.001, 0], 0.2, 0.1, +1)$: A case where $f_{\\text{ext}}^{T} \\Delta u$ is clearly negative.\n3. $([1, 0], [0, 1], 0.1, 0.0, -1)$: A boundary case with exactly zero dot product, using the commanded direction.\n4. $([1, 10^{-12}], [10^{-12}, -1], 0.3, -0.3, 0)$: A near-zero dot product within tolerance, using the previous increment sign.\n5. $([3, -3], [1, 1], 0.07, 0.0, 0)$: A boundary case with zero dot product and no direction history, using the default.\n6. $([5, 5], [0.01, 0.01], 0.04, -0.04, -1)$: A conflict case where $f_{\\text{ext}}^{T} \\Delta u$ indicates positive, overriding a negative commanded direction.\n7. $([10^{6}, 0], [10^{-6}, 0], 1.5, 0.0, +1)$: A large-magnitude case testing numerical stability.\n\nYour program must:\n- Implement the derived sign update rule with a tolerance parameter $tol = 10^{-9}$ for deciding when $f_{\\text{ext}}^{T} \\Delta u$ is treated as zero.\n- For each test case, compute the signed $\\Delta \\lambda$ as specified.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite.",
            "solution": "The problem requires the derivation and implementation of a sign update rule for the load parameter increment, $\\Delta \\lambda$, within the context of arc-length path-following methods used in computational geomechanics.\n\nThe state of a system is described by the displacement vector $u$ and a scalar load parameter $\\lambda$. The equilibrium condition is given by the nonlinear residual equation:\n$$r(u, \\lambda) = f_{\\text{int}}(u) - \\lambda f_{\\text{ext}} = 0$$\nwhere $f_{\\text{int}}(u)$ is the history-dependent internal force vector and $f_{\\text{ext}}$ is a fixed reference external load vector. Arc-length methods augment this system with a constraint on the size of the incremental step, $(\\Delta u, \\Delta \\lambda)$. A general form of this constraint is:\n$$g(\\Delta u, \\Delta \\lambda) = \\Delta u^{T} W \\Delta u + \\alpha \\Delta \\lambda^{2} - \\Delta s^{2} = 0$$\nHere, $\\Delta s$ is the prescribed arc-length for the step, $W$ is a positive-definite weighting matrix (often the identity matrix), and $\\alpha$ is a positive scaling constant used to balance the contributions of displacement and load increments.\n\nSolving the linearized equilibrium equations in tandem with this quadratic constraint yields the magnitude of the load increment, $|\\Delta \\lambda|$, but its sign remains ambiguous. There are two potential solutions, $\\Delta \\lambda = +|\\Delta \\lambda|$ and $\\Delta \\lambda = -|\\Delta \\lambda|$, corresponding to two symmetric points on the constraint surface. An incorrect choice of sign can cause the numerical solution to reverse direction along the equilibrium path or jump to an entirely different solution branch, compromising the analysis, especially near critical points such as limit points or bifurcation points.\n\nThe core task is to derive a criterion for choosing the sign $s \\in \\{-1, +1\\}$ such that the computed increment $\\Delta \\lambda = s |\\Delta \\lambda|$ correctly advances the solution along the desired equilibrium path. The derivation is to be based on the principle that the incremental external work should be consistent with the intended load progression.\n\nLet us define a measure of incremental work based on the fixed reference load vector, $\\Delta W_{\\text{ref}} = f_{\\text{ext}}^T \\Delta u$. The sign of this scalar quantity indicates whether the incremental displacement $\\Delta u$ is, in an aggregate sense, aligned with the direction of the reference load $f_{\\text{ext}}$.\n- If $f_{\\text{ext}}^T \\Delta u > 0$, the system is deforming \"in the direction of\" the reference load. In typical loading scenarios, particularly in the pre-critical regime, this corresponds to an increase in the applied load. It is therefore physically consistent to seek an increase in the load parameter, i.e., to choose $\\Delta \\lambda > 0$.\n- If $f_{\\text{ext}}^T \\Delta u < 0$, the system is deforming \"against\" the reference load. This situation can arise in post-critical regimes, such as snap-back, where maintaining equilibrium requires a reduction in the applied load. Thus, it is consistent to seek a decrease in the load parameter, i.e., to choose $\\Delta \\lambda < 0$.\n\nThis line of reasoning establishes a consistency criterion: the sign of the load parameter increment should match the sign of the reference work. Mathematically, we choose the sign $s$ of $\\Delta \\lambda$ to be:\n$$s = \\text{sign}(f_{\\text{ext}}^T \\Delta u)$$\nThis ensures that the product $\\Delta \\lambda (f_{\\text{ext}}^T \\Delta u) \\ge 0$, which is a common criterion for maintaining path consistency. While this rule is effective for many situations, it has known limitations, for instance, in certain snap-through phenomena where displacement continues to increase while load must decrease. However, it serves as a robust primary test as stipulated by the problem.\n\nA critical edge case arises when the reference work is zero or numerically close to zero, i.e., $|f_{\\text{ext}}^T \\Delta u| \\approx 0$. This occurs if the incremental displacement vector $\\Delta u$ is orthogonal to the reference load vector $f_{\\text{ext}}$, a situation that can happen at limit points. In this case, the primary criterion is inconclusive, and a tie-breaking hierarchy is necessary to ensure a determinate choice. The problem specifies the following hierarchy:\n\n1.  **Primary Criterion**: The sign $s$ is determined by $s = \\text{sign}(f_{\\text{ext}}^T \\Delta u)$, provided $|f_{\\text{ext}}^T \\Delta u|$ is greater than a specified numerical tolerance, $\\text{tol}$.\n\n2.  **Tie-Breaker 1 (Commanded Direction)**: If the primary criterion is ambiguous (i.e., $|f_{\\text{ext}}^T \\Delta u| \\le \\text{tol}$), the sign is determined by a user-specified commanded direction, $d \\in \\{-1, 0, +1\\}$. If $d \\neq 0$, then $s = d$. This allows for external control over the path-following direction.\n\n3.  **Tie-Breaker 2 (Path Continuity)**: If the commanded direction is not provided ($d=0$), the sign is chosen to maintain continuity with the previous step. The sign of the current increment $\\Delta \\lambda$ is set to the sign of the previous increment, $\\Delta \\lambda_{\\text{prev}}$. If $\\Delta \\lambda_{\\text{prev}} \\neq 0$, then $s = \\text{sign}(\\Delta \\lambda_{\\text{prev}})$. This prevents the solution from abruptly reversing direction.\n\n4.  **Tie-Breaker 3 (Default)**: If all preceding criteria are inconclusive (which occurs on the very first step if $d=0$ and $|f_{\\text{ext}}^T \\Delta u| \\le \\text{tol}$), a default sign is used. Conventionally, loading starts in the positive direction, so the default is $s = +1$.\n\nThis hierarchical algorithm provides a complete and robust decision-making process for determining the sign of $\\Delta \\lambda$ for each step in the path-following analysis. The final signed load increment is then computed as $\\Delta \\lambda = s |\\Delta \\lambda|$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a robust sign update rule for the load scaling increment\n    in arc-length path-following methods.\n    \"\"\"\n    \n    # Test suite: (f_ext, delta_u, abs_delta_lambda, delta_lambda_prev, d)\n    # f_ext: reference external load vector\n    # delta_u: incremental displacement vector\n    # abs_delta_lambda: magnitude of the load scaling increment\n    # delta_lambda_prev: signed load scaling increment from the previous step\n    # d: commanded direction {-1, 0, +1}\n    test_cases = [\n        (np.array([10.0, 0.0]), np.array([0.001, 0.0]), 0.05, 0.05, 1),\n        (np.array([10.0, 0.0]), np.array([-0.001, 0.0]), 0.2, 0.1, 1),\n        (np.array([1.0, 0.0]), np.array([0.0, 1.0]), 0.1, 0.0, -1),\n        (np.array([1.0, 1e-12]), np.array([1e-12, -1.0]), 0.3, -0.3, 0),\n        (np.array([3.0, -3.0]), np.array([1.0, 1.0]), 0.07, 0.0, 0),\n        (np.array([5.0, 5.0]), np.array([0.01, 0.01]), 0.04, -0.04, -1),\n        (np.array([1e6, 0.0]), np.array([1e-6, 0.0]), 1.5, 0.0, 1),\n    ]\n\n    tol = 1e-9\n    results = []\n\n    for case in test_cases:\n        f_ext, delta_u, abs_delta_lambda, delta_lambda_prev, d = case\n        \n        sign = 0\n        \n        # 1. Primary Test: Incremental external work\n        work_dot_product = np.dot(f_ext, delta_u)\n        \n        if work_dot_product > tol:\n            sign = 1\n        elif work_dot_product  -tol:\n            sign = -1\n        else:\n            # The work dot product is within the tolerance of zero.\n            # Apply the tie-breaker hierarchy.\n            \n            # 2. Tie-Breaker: Commanded direction\n            if d == 1:\n                sign = 1\n            elif d == -1:\n                sign = -1\n            else: # d == 0\n                # 3. Tie-Breaker: Previous step's increment sign\n                if delta_lambda_prev > 0:\n                    sign = 1\n                elif delta_lambda_prev  0:\n                    sign = -1\n                else: # delta_lambda_prev == 0\n                    # 4. Tie-Breaker: Default sign\n                    sign = 1\n        \n        signed_delta_lambda = sign * abs_delta_lambda\n        results.append(signed_delta_lambda)\n\n    # Format the results into the required string format.\n    # We use a custom formatting to avoid trailing zeros for integers (e.g., -0.2 instead of -0.20)\n    # and to represent numbers cleanly.\n    formatted_results = [f\"{r:.15g}\".rstrip('0').rstrip('.') if '.' in f\"{r:.15g}\" else f\"{r:.15g}\" for r in results]\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes the concepts from the previous exercises into a complete application. You will implement an entire arc-length solver to tackle a simplified but highly relevant geomechanics problem: tracing the full load-settlement response of a footing on soil, including its post-peak behavior. By comparing a soil model that exhibits softening with one that hardens continuously, you will see firsthand how arc-length methods are indispensable for capturing the complex, non-monotonic material responses that define many challenges in computational geomechanics .",
            "id": "3501082",
            "problem": "A rigid strip footing of infinite length is modeled under plane strain on a homogeneous, compressible granular soil. The footing settlement is represented by a single generalized displacement $u$ in meters. The external load resultant per unit out-of-plane length is represented by $\\lambda P_{\\mathrm{ref}}$ in kilonewton per meter, where $P_{\\mathrm{ref}}$ is a constant reference load and $\\lambda$ is a dimensionless load factor. The soil reaction is modeled as a spatially uniform contact pressure proxy $q(u;\\boldsymbol{\\theta})$ in kilonewton per meter that depends only on the settlement $u$ and on model parameters $\\boldsymbol{\\theta}$ that characterize the constitutive behavior of the soil.\n\nThe reduced equilibrium of the footing is written as the scalar residual\n$$\nr(u,\\lambda;\\boldsymbol{\\theta}) \\equiv q(u;\\boldsymbol{\\theta}) - \\lambda P_{\\mathrm{ref}} = 0.\n$$\nThe objective is to numerically follow the entire equilibrium branch $\\{(u,\\lambda)\\,|\\, r(u,\\lambda;\\boldsymbol{\\theta})=0\\}$ beyond a peak load by means of an arc-length path-following method of the Riks–Crisfield type. The tangent required by the method is the scalar stiffness\n$$\nK_{\\mathrm{t}}(u;\\boldsymbol{\\theta}) \\equiv \\dfrac{\\partial q(u;\\boldsymbol{\\theta})}{\\partial u}.\n$$\n\nTwo soil constitutive surrogates are to be compared under identical boundary conditions:\n- A crushable form intended to mimic a $p$–$\\alpha$ cap response with progressive crushing, which exhibits a post-peak softening of the reaction with settlement.\n- A ductile hardening form intended to mimic Modified Cam-Clay under predominantly compressive volumetric loading, which exhibits monotonic hardening to a plateau without a limit point.\n\nTo ensure a well-posed and testable problem without recourse to a full finite element model, define the following surrogate reaction laws (all parameters are positive and have the indicated units):\n- $p$–$\\alpha$-like crushable surrogate:\n$$\nq_{\\mathrm{pa}}(u; a_1,b_1,a_2,b_2) = a_1\\,u\\,e^{-b_1 u} \\;+\\; a_2\\left(1-e^{-b_2 u}\\right),\n$$\nwith tangent\n$$\nK_{\\mathrm{t,pa}}(u; a_1,b_1,a_2,b_2) = a_1 e^{-b_1 u}\\left(1-b_1 u\\right) \\;+\\; a_2 b_2 e^{-b_2 u}.\n$$\nHere $a_1$ is in kilonewton per meter squared, $b_1$ is in inverse meters, $a_2$ is in kilonewton per meter, and $b_2$ is in inverse meters.\n- Modified Cam-Clay-like ductile surrogate:\n$$\nq_{\\mathrm{mcc}}(u; S,\\beta) = S\\left(1-e^{-\\beta u}\\right),\n$$\nwith tangent\n$$\nK_{\\mathrm{t,mcc}}(u; S,\\beta) = S\\beta e^{-\\beta u},\n$$\nwhere $S$ is in kilonewton per meter and $\\beta$ is in inverse meters.\n\nBoth surrogates are consistent with the geomechanical statement that the footing reaction is the integral of a pressure distribution that, under the simplifying assumptions adopted, depends only on $u$ and saturates or softens after an initial hardening phase due to plastic compaction.\n\nImplement a two-equation, two-unknown arc-length procedure for the scalar system with unknowns $(u,\\lambda)$, based on:\n- Equilibrium: $r(u,\\lambda;\\boldsymbol{\\theta}) = 0$.\n- Crisfield-type spherical constraint per increment $n\\to n+1$:\n$$\ng(u,\\lambda;u_n,\\lambda_n) \\equiv (u-u_n)^2 + \\psi (\\lambda-\\lambda_n)^2 - \\Delta s^2 = 0,\n$$\nwhere $\\psi$ is a positive scaling parameter that balances units, and $\\Delta s$ is the prescribed arc-length size. For each increment, the Newton correction system should use the Jacobian of the residuals assembled from $K_{\\mathrm{t}}(u;\\boldsymbol{\\theta})$ and the linearization of $g$.\n\nUse the following test suite. In all cases, take $P_{\\mathrm{ref}} = 1\\,\\mathrm{kN/m}$, so that the load factor $\\lambda$ numerically equals the footing reaction in $\\mathrm{kN/m}$. Express all displacements in meters and all loads in $\\mathrm{kN/m}$. Use radians implicitly for any exponential arguments (dimensionally consistent with inverse meters as specified). For each case, run the arc-length tracing for both models with identical algorithmic settings and report the requested quantities.\n\nCommon algorithmic parameters for all cases:\n- Initial state $(u_0,\\lambda_0) = (0,0)$.\n- Arc-length size $\\Delta s = 0.002\\,\\mathrm{m}$.\n- Scaling $\\psi = 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{kN/m})^2$.\n- Number of continuation steps $N_{\\mathrm{steps}} = 200$.\n- Newton iterations per step with a robust stopping criterion based on the norms of $r$ and $g$.\n\nTest cases (parameters in consistent units as specified):\n- Case $1$ (strong crushable softening versus ductile hardening):\n  - $p$–$\\alpha$ surrogate: $(a_1,b_1,a_2,b_2) = (120000, 20, 300, 3)$.\n  - Modified Cam-Clay surrogate: $(S,\\beta) = (1800, 8)$.\n- Case $2$ (milder softening):\n  - $p$–$\\alpha$ surrogate: $(a_1,b_1,a_2,b_2) = (70000, 12, 600, 1.5)$.\n  - Modified Cam-Clay surrogate: $(S,\\beta) = (1100, 5)$.\n- Case $3$ (near-plateau behavior):\n  - $p$–$\\alpha$ surrogate: $(a_1,b_1,a_2,b_2) = (40000, 8, 900, 1)$.\n  - Modified Cam-Clay surrogate: $(S,\\beta) = (900, 4)$.\n\nFor each test case, compute using the arc-length method the following four outputs:\n- The maximum equilibrium load per unit length for the $p$–$\\alpha$ surrogate, $\\max\\lambda_{\\mathrm{pa}}$, in $\\mathrm{kN/m}$, rounded to two decimal places.\n- The maximum equilibrium load per unit length for the Modified Cam-Clay surrogate, $\\max\\lambda_{\\mathrm{mcc}}$, in $\\mathrm{kN/m}$, rounded to two decimal places.\n- A boolean indicating whether a limit point was detected in the $p$–$\\alpha$ branch (defined as a sign change of $K_{\\mathrm{t,pa}}$ along the traced path).\n- A boolean indicating whether a limit point was detected in the Modified Cam-Clay branch (defined as a sign change of $K_{\\mathrm{t,mcc}}$ along the traced path).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order specified above. For example: \"[[case1_result1,case1_result2,case1_result3,case1_result4],[case2_result1,case2_result2,case2_result3,case2_result4],[case3_result1,case3_result2,case3_result3,case3_result4]]\".",
            "solution": "The user's request is to solve a computational geomechanics problem using a numerical path-following technique. The problem involves tracing the equilibrium path of a simplified footing model under two different soil constitutive laws.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Equilibrium Relation:** $r(u,\\lambda;\\boldsymbol{\\theta}) \\equiv q(u;\\boldsymbol{\\theta}) - \\lambda P_{\\mathrm{ref}} = 0$, where $u$ is settlement, $\\lambda$ is a load factor, and $q(u;\\boldsymbol{\\theta})$ is the soil reaction.\n- **Tangent Stiffness:** $K_{\\mathrm{t}}(u;\\boldsymbol{\\theta}) \\equiv \\frac{\\partial q}{\\partial u}$.\n- **$p$–$\\alpha$-like Surrogate:** $q_{\\mathrm{pa}}(u; a_1,b_1,a_2,b_2) = a_1 u e^{-b_1 u} + a_2(1-e^{-b_2 u})$.\n- **$p$–$\\alpha$-like Tangent:** $K_{\\mathrm{t,pa}}(u; a_1,b_1,a_2,b_2) = a_1 e^{-b_1 u}(1-b_1 u) + a_2 b_2 e^{-b_2 u}$.\n- **Modified Cam-Clay-like Surrogate:** $q_{\\mathrm{mcc}}(u; S,\\beta) = S(1-e^{-\\beta u})$.\n- **Modified Cam-Clay-like Tangent:** $K_{\\mathrm{t,mcc}}(u; S,\\beta) = S\\beta e^{-\\beta u}$.\n- **Arc-Length Constraint:** $g(u,\\lambda;u_n,\\lambda_n) \\equiv (u-u_n)^2 + \\psi (\\lambda-\\lambda_n)^2 - \\Delta s^2 = 0$.\n- **Algorithmic Parameters:**\n  - $P_{\\mathrm{ref}} = 1\\,\\mathrm{kN/m}$\n  - Initial State $(u_0, \\lambda_0) = (0, 0)$\n  - Arc-length size $\\Delta s = 0.002\\,\\mathrm{m}$\n  - Scaling factor $\\psi = 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{kN/m})^2$\n  - Number of steps $N_{\\mathrm{steps}} = 200$\n- **Test Cases:**\n  - Case $1$: $p$–$\\alpha$ params $(120000, 20, 300, 3)$; MCC params $(1800, 8)$.\n  - Case $2$: $p$–$\\alpha$ params $(70000, 12, 600, 1.5)$; MCC params $(1100, 5)$.\n  - Case $3$: $p$–$\\alpha$ params $(40000, 8, 900, 1)$; MCC params $(900, 4)$.\n- **Outputs:** For each case, $[\\max\\lambda_{\\mathrm{pa}}, \\max\\lambda_{\\mathrm{mcc}}, \\text{limit\\_point\\_pa}, \\text{limit\\_point\\_mcc}]$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed based on the predefined criteria:\n- **Scientifically Grounded:** The problem is a classic application of nonlinear numerical methods in structural/geotechnical engineering. The use of surrogate models for soil behavior and the implementation of a Riks-Crisfield arc-length method are standard and sound practices.\n- **Well-Posed:** The problem is fully specified. It provides all necessary mathematical models, parameters, initial conditions, and algorithmic settings to obtain a unique solution path.\n- **Objective:** The problem statement is formal, quantitative, and free of ambiguity or subjective claims.\n- **Flaw Checklist:**\n  1. **Scientific/Factual Unsoundness:** None. The provided equations for tangents are correct derivatives of the reaction laws. All units are consistent.\n  2. **Non-Formalizable/Irrelevant:** None. The problem is a direct and formalizable numerical task within the specified domain.\n  3. **Incomplete/Contradictory:** None. The setup is complete and self-consistent.\n  4. **Unrealistic/Infeasible:** None. The parameter values are chosen to produce physically plausible behaviors (softening/hardening).\n  5. **Ill-Posed/Poorly Structured:** None. The arc-length method is specifically chosen to handle potential limit points where the tangent stiffness $K_t$ vanishes, making the problem well-posed for numerical solution.\n  6. **Pseudo-Profound/Trivial:** None. The task requires a non-trivial implementation of a predictor-corrector algorithm for a system of nonlinear equations.\n  7. **Outside Scientific Verifiability:** None. The results can be independently verified.\n\n**Step 3: Verdict and Action**\nThe problem is **valid** and well-posed. A solution will be developed.\n\n### Principle-Based Solution Design\n\nThe core of the problem is to implement a Crisfield-type arc-length path-following algorithm. This method is essential for analyzing systems that may exhibit limit points (e.g., maximum load points followed by softening), where standard load-controlled or displacement-controlled methods fail. The method augments the physical equilibrium equation with a constraint equation that guides the solution along the equilibrium path in the load-displacement space.\n\nFor each step $n \\to n+1$ along the path, we want to find a new equilibrium point $(u_{n+1}, \\lambda_{n+1})$ that is a prescribed \"distance\" $\\Delta s$ away from the previously converged point $(u_n, \\lambda_n)$. This leads to a system of two nonlinear equations for two unknowns, $(u, \\lambda)$:\n\n$1$. Equilibrium: $r(u, \\lambda) = q(u;\\boldsymbol{\\theta}) - \\lambda P_{\\mathrm{ref}} = 0$\n$2$. Arc-Length Constraint: $g(u, \\lambda) = (u - u_n)^2 + \\psi (\\lambda - \\lambda_n)^2 - \\Delta s^2 = 0$\n\nHere, $\\psi$ is a scaling factor to make the two terms in the constraint dimensionally homogeneous and of comparable magnitude.\n\nThis system is solved iteratively using a predictor-corrector scheme based on Newton's method.\n\n**1. Predictor Step**\n\nFirst, an initial estimate for the new point, $(u_{n+1}^{(0)}, \\lambda_{n+1}^{(0)})$, is made by moving a distance $\\Delta s$ along the tangent to the path at the current point $(u_n, \\lambda_n)$. The tangent vector $(\\dot{u}, \\dot{\\lambda})$ is found by differentiating the equilibrium equation with respect to the arc-length parameter $s$:\n$$\n\\dfrac{dr}{ds} = \\dfrac{\\partial r}{\\partial u}\\dfrac{du}{ds} + \\dfrac{\\partial r}{\\partial \\lambda}\\dfrac{d\\lambda}{ds} = K_t \\dot{u} - P_{\\mathrm{ref}} \\dot{\\lambda} = 0\n$$\nThe tangent vector must also be of unit length with respect to the arc-length metric: $\\dot{u}^2 + \\psi \\dot{\\lambda}^2 = 1$. Combining these two conditions allows for solving for $\\dot{u}$ and $\\dot{\\lambda}$. The predictor point is then:\n$$\n(u_{n+1}^{(0)}, \\lambda_{n+1}^{(0)}) = (u_n, \\lambda_n) + \\Delta s (\\dot{u}_n, \\dot{\\lambda}_n)\n$$\nThe sign of the tangent vector is chosen to ensure the path continues in a consistent direction, typically by checking that its dot product with the previous tangent vector is positive.\n\n**2. Corrector Step**\n\nStarting from the predictor point $(u_k, \\lambda_k) = (u_{n+1}^{(0)}, \\lambda_{n+1}^{(0)})$, we use Newton's method to find a correction $(\\delta u, \\delta \\lambda)$ that drives the residuals of both equations to zero. The linear system to be solved at each Newton iteration $k$ is:\n$$\n\\mathbf{J}(\\mathbf{x}_k) \\Delta \\mathbf{x}_k = -\\mathbf{R}(\\mathbf{x}_k)\n$$\nwhere $\\mathbf{x}_k = [u_k, \\lambda_k]^T$ is the current guess, $\\mathbf{R}(\\mathbf{x}_k) = [r(u_k, \\lambda_k), g(u_k, \\lambda_k)]^T$ is the residual vector, and $\\mathbf{J}$ is the Jacobian matrix of the system:\n$$\n\\mathbf{J} =\n\\begin{bmatrix}\n\\frac{\\partial r}{\\partial u}  \\frac{\\partial r}{\\partial \\lambda} \\\\\n\\frac{\\partial g}{\\partial u}  \\frac{\\partial g}{\\partial \\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nK_t(u)  -P_{\\mathrm{ref}} \\\\\n2(u - u_n)  2\\psi(\\lambda - \\lambda_n)\n\\end{bmatrix}\n$$\nThe solution $\\Delta \\mathbf{x}_k = [\\delta u, \\delta \\lambda]^T$ is used to update the guess: $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta \\mathbf{x}_k$. This iterative process is repeated until the norm of the residual vector falls below a specified tolerance. The resulting converged point is $(u_{n+1}, \\lambda_{n+1})$.\n\n**3. Path Continuation and Analysis**\n\nThe algorithm proceeds for the specified number of steps ($N_{\\mathrm{steps}} = 200$), storing the converged points $(u_i, \\lambda_i)$ at each step $i$. A limit point is detected when the tangent stiffness $K_t$ changes sign between two consecutive converged steps, indicating the equilibrium path has reached a local extremum in load. For the monotonic hardening MCC model, $K_t$ is always positive, so no limit point is expected. For the softening $p$–$\\alpha$ model, a limit point is possible. Once all steps are completed, the maximum load factor, $\\max \\lambda$, is found by taking the maximum value from the stored $\\lambda_i$ path. The requested outputs are then compiled for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the arc-length path-following problem.\n    \"\"\"\n\n    # --- Constitutive Surrogates and Tangents ---\n\n    def q_pa(u, a1, b1, a2, b2):\n        \"\"\"p-alpha-like crushable surrogate reaction law.\"\"\"\n        return a1 * u * np.exp(-b1 * u) + a2 * (1.0 - np.exp(-b2 * u))\n\n    def Kt_pa(u, a1, b1, a2, b2):\n        \"\"\"Tangent stiffness for the p-alpha surrogate.\"\"\"\n        return a1 * np.exp(-b1 * u) * (1.0 - b1 * u) + a2 * b2 * np.exp(-b2 * u)\n\n    def q_mcc(u, S, beta):\n        \"\"\"Modified Cam-Clay-like ductile surrogate reaction law.\"\"\"\n        if u  0: return 0.0 # Physical constraint\n        return S * (1.0 - np.exp(-beta * u))\n\n    def Kt_mcc(u, S, beta):\n        \"\"\"Tangent stiffness for the MCC surrogate.\"\"\"\n        if u  0: return S * beta # Physical constraint\n        return S * beta * np.exp(-beta * u)\n\n    # --- Arc-Length Solver ---\n\n    def arc_length_solver(q_func, Kt_func, params, settings):\n        \"\"\"\n        Implements a Crisfield-type arc-length solver for the scalar system.\n\n        Args:\n            q_func (function): The soil reaction function q(u, *params).\n            Kt_func (function): The tangent stiffness function Kt(u, *params).\n            params (tuple): Model parameters for q_func and Kt_func.\n            settings (dict): Algorithmic settings (P_ref, ds, psi, etc.).\n\n        Returns:\n            tuple: (max_lambda, limit_point_detected)\n        \"\"\"\n        # Unpack settings\n        P_ref = settings['P_ref']\n        u0, lambda0 = settings['u0'], settings['lambda0']\n        ds, psi = settings['ds'], settings['psi']\n        N_steps = settings['N_steps']\n\n        newton_tol = 1e-9\n        max_newton_iter = 15\n\n        # Path storage\n        u_path = [u0]\n        lambda_path = [lambda0]\n\n        # Initial state\n        u_n, lambda_n = u0, lambda0\n        \n        # Limit point tracking\n        limit_point_detected = False\n        Kt_n = Kt_func(u_n, *params)\n        Kt_sign_prev = np.sign(Kt_n) if Kt_n != 0 else 1.0\n\n        # Initial tangent vector (dot_u, dot_lambda)\n        if abs(Kt_n)  1e-12:\n            dot_u, dot_lambda = 1.0, 0.0\n        else:\n            norm_factor = np.sqrt((P_ref / Kt_n)**2 + psi)\n            dot_lambda = 1.0 / norm_factor  # Assume initial load increase\n            dot_u = (P_ref / Kt_n) * dot_lambda\n\n        for _ in range(N_steps):\n            # Predictor step\n            u_pred = u_n + ds * dot_u\n            lambda_pred = lambda_n + ds * dot_lambda\n            \n            u_k, lambda_k = u_pred, lambda_pred\n\n            # Corrector step (Newton-Raphson)\n            converged = False\n            for _ in range(max_newton_iter):\n                r_k = q_func(u_k, *params) - lambda_k * P_ref\n                g_k = (u_k - u_n)**2 + psi * (lambda_k - lambda_n)**2 - ds**2\n                \n                res_vec = np.array([-r_k, -g_k])\n\n                if np.linalg.norm(res_vec)  newton_tol:\n                    converged = True\n                    break\n                \n                Kt_k = Kt_func(u_k, *params)\n                J = np.array([\n                    [Kt_k, -P_ref],\n                    [2.0 * (u_k - u_n), 2.0 * psi * (lambda_k - lambda_n)]\n                ])\n                \n                try:\n                    delta = np.linalg.solve(J, res_vec)\n                except np.linalg.LinAlgError:\n                    break # Failed to converge\n                \n                u_k += delta[0]\n                lambda_k += delta[1]\n            \n            if not converged:\n                # In a real application, would add logic like reducing ds\n                break\n\n            # Update state with converged point\n            u_n1, lambda_n1 = u_k, lambda_k\n            u_path.append(u_n1)\n            lambda_path.append(lambda_n1)\n\n            # Check for limit point\n            Kt_n1 = Kt_func(u_n1, *params)\n            Kt_sign_curr = np.sign(Kt_n1) if Kt_n1 != 0 else Kt_sign_prev\n            if not limit_point_detected and Kt_sign_curr * Kt_sign_prev  0:\n                limit_point_detected = True\n            if Kt_sign_curr != 0:\n                Kt_sign_prev = Kt_sign_curr\n\n            # Calculate next tangent vector\n            if abs(Kt_n1)  1e-12: # Vertical tangent at limit point\n                dot_u_new = 1.0\n                dot_lambda_new = 0.0\n            else: # Regular case\n                norm_factor = np.sqrt((P_ref / Kt_n1)**2 + psi)\n                dot_lambda_new = 1.0 / norm_factor\n                dot_u_new = (P_ref / Kt_n1) * dot_lambda_new\n\n            # Ensure consistent direction of traversal\n            if dot_u_new * dot_u + dot_lambda_new * dot_lambda  0:\n                dot_u_new *= -1.0\n                dot_lambda_new *= -1.0\n\n            # Update for next step\n            u_n, lambda_n = u_n1, lambda_n1\n            dot_u, dot_lambda = dot_u_new, dot_lambda_new\n\n        max_lambda = np.max(lambda_path) if lambda_path else 0.0\n        return max_lambda, limit_point_detected\n\n    # --- Test Execution ---\n    \n    settings = {\n        'P_ref': 1.0,\n        'u0': 0.0,\n        'lambda0': 0.0,\n        'ds': 0.002,\n        'psi': 1.0e-6,\n        'N_steps': 200,\n    }\n\n    test_cases = [\n        {'pa_params': (120000.0, 20.0, 300.0, 3.0), 'mcc_params': (1800.0, 8.0)},\n        {'pa_params': (70000.0, 12.0, 600.0, 1.5), 'mcc_params': (1100.0, 5.0)},\n        {'pa_params': (40000.0, 8.0, 900.0, 1.0), 'mcc_params': (900.0, 4.0)},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        max_lambda_pa, lp_pa = arc_length_solver(q_pa, Kt_pa, case['pa_params'], settings)\n        max_lambda_mcc, lp_mcc = arc_length_solver(q_mcc, Kt_mcc, case['mcc_params'], settings)\n        \n        case_results = [\n            max_lambda_pa,\n            max_lambda_mcc,\n            lp_pa,\n            lp_mcc\n        ]\n        all_results.append(case_results)\n\n    # Format output string exactly as requested\n    case_strs = []\n    for res in all_results:\n        val1 = f\"{res[0]:.2f}\"\n        val2 = f\"{res[1]:.2f}\"\n        val3 = str(res[2])\n        val4 = str(res[3])\n        case_strs.append(f\"[{val1},{val2},{val3},{val4}]\")\n    \n    final_output = f\"[{','.join(case_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}