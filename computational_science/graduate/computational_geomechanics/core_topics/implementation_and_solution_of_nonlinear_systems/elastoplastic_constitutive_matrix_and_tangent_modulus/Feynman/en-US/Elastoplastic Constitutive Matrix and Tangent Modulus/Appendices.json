{
    "hands_on_practices": [
        {
            "introduction": "The theoretical importance of the consistent tangent modulus is best understood by seeing its practical impact on numerical performance. This exercise provides a clear, hands-on demonstration by tasking you with solving a simple 1D elastoplastic problem using two different Newton-Raphson solvers. By comparing the convergence speed of a solver using the true algorithmic tangent against one using only the elastic modulus, you will directly quantify the benefit of using a consistent Jacobian .",
            "id": "3522215",
            "problem": "Consider a one-dimensional, small-strain, rate-independent elastoplastic material with linear isotropic hardening. Let the total strain be denoted by $\\varepsilon$, the stress by $\\sigma$, the elastic modulus by $E$ (in $\\mathrm{Pa}$), the initial yield stress by $\\sigma_{y0}$ (in $\\mathrm{Pa}$), and the plastic modulus by $H$ (in $\\mathrm{Pa}$). Assume monotonic loading in tension so that the plastic flow direction is positive. The material follows the additive strain decomposition and standard small-strain elastoplasticity with linear isotropic hardening, a convex yield function, associative flow, and the Kuhn–Tucker conditions. A single material point is subjected to a prescribed traction $T$ (in $\\mathrm{Pa}$); equilibrium at the material point is enforced by solving the scalar equation $R(\\varepsilon) = \\sigma(\\varepsilon) - T = 0$ for $\\varepsilon$ using Newton’s method.\n\nStarting only from the fundamental definitions of small-strain elastoplasticity, convex yield function with linear isotropic hardening, associative flow, and the consistency condition, derive the algorithmic elastoplastic tangent modulus $D^{ep}$ required for quadratic convergence of Newton’s method applied to the scalar equilibrium equation $R(\\varepsilon)=0$. Then, design and implement a benchmark to compare:\n- a Newton solver that uses the algorithmic $D^{ep}$ (i.e., the consistent tangent modulus) as the Jacobian $d\\sigma/d\\varepsilon$ in the iterations,\n- versus a Newton solver based on an elastic predictor–plastic corrector without a consistent tangent, which uses the elastic modulus $E$ as the Jacobian $d\\sigma/d\\varepsilon$ throughout the iterations, even after yielding.\n\nYour program must:\n1. Implement a physically admissible stress–strain response $\\sigma(\\varepsilon)$ for the described material point based on a standard return-mapping concept with linear isotropic hardening, ensuring that $\\sigma(\\varepsilon)$ is continuous and piecewise differentiable in $\\varepsilon$.\n2. Implement two Newton solvers for the scalar equation $R(\\varepsilon)=\\sigma(\\varepsilon)-T=0$:\n   - Solver A: Use the algorithmic elastoplastic tangent modulus $D^{ep}$ as the Jacobian $d\\sigma/d\\varepsilon$ when in plastic loading and the elastic modulus $E$ when in elastic loading.\n   - Solver B: Use only the elastic modulus $E$ as the Jacobian $d\\sigma/d\\varepsilon$ for all iterations, i.e., do not use the consistent tangent in plastic loading.\n3. Use a fixed residual tolerance of $10^{0}$ $\\mathrm{Pa}$, i.e., declare convergence when $|R(\\varepsilon)| \\leq 10^{0}$ $\\mathrm{Pa}$. Use a maximum number of Newton iterations of $1000$.\n4. Compute and report the following error metrics for each test case:\n   - The number of Newton iterations until convergence for Solver A and Solver B (each an integer).\n   - A boolean indicating whether convergence was achieved for Solver A and for Solver B within the iteration limit.\n   - The absolute strain error $|\\varepsilon_{\\text{num}} - \\varepsilon_{\\text{exact}}|$ (dimensionless), where $\\varepsilon_{\\text{exact}}$ is the exact closed-form solution obtained analytically by enforcing the elastic or plastic state conditions derived from first principles.\n   - The final residual $|R(\\varepsilon)|$ (in $\\mathrm{Pa}$) at termination for Solver A and Solver B.\n5. Use the following test suite, each case defined by $(E, \\sigma_{y0}, H, T)$ with all moduli and tractions in $\\mathrm{Pa}$:\n   - Case $1$: $(200 \\times 10^9, 400 \\times 10^6, 10 \\times 10^9, 300 \\times 10^6)$, an elastic case.\n   - Case $2$: $(200 \\times 10^9, 400 \\times 10^6, 10 \\times 10^9, 400 \\times 10^6)$, at the elastic–plastic boundary.\n   - Case $3$: $(200 \\times 10^9, 400 \\times 10^6, 10 \\times 10^9, 800 \\times 10^6)$, a plastic case with moderate hardening.\n   - Case $4$: $(200 \\times 10^9, 400 \\times 10^6, 0.5 \\times 10^9, 800 \\times 10^6)$, a plastic case with weak hardening stressing the need for a consistent tangent.\n   - Case $5$: $(200 \\times 10^9, 400 \\times 10^6, 100 \\times 10^9, 1200 \\times 10^6)$, a plastic case with strong hardening approaching elastic-like behavior.\n6. Use the initial guess $\\varepsilon_0 = 0$ for all test cases.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list in the form:\n$[\\text{itersA},\\text{itersB},\\text{convA},\\text{convB},\\text{errA},\\text{errB},\\text{resA},\\text{resB}]$.\nThus the final output must be a list of five such lists, one per test case, e.g., $[[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$.\n\nAnswer all physical quantities in the specified units: moduli and stresses in $\\mathrm{Pa}$, strains dimensionless. Angles are not involved. All boolean values must be Python booleans. All floating-point and integer outputs must be raw numerical values, not rounded or formatted with units.",
            "solution": "The problem is assessed to be valid. It is a well-posed, scientifically grounded problem in computational plasticity, with all necessary data and conditions provided for a unique solution.\n\n### 1. Fundamental Constitutive Relations\nThe problem describes a one-dimensional, rate-independent elastoplastic material with linear isotropic hardening under monotonic tensile loading from an initial unstressed state. The governing relations are as follows:\n\n- **Strain Decomposition**: The total strain $\\varepsilon$ is the sum of the elastic strain $\\varepsilon^e$ and plastic strain $\\varepsilon^p$.\n  $$ \\varepsilon = \\varepsilon^e + \\varepsilon^p $$\n- **Elastic Law**: The stress $\\sigma$ is related to the elastic strain by Hooke's law, with elastic modulus $E$.\n  $$ \\sigma = E \\varepsilon^e $$\n- **Yield Condition**: Plastic flow initiates when the stress reaches the current yield strength $\\sigma_y$. For monotonic tension ($\\sigma \\ge 0$), the yield function $f$ is:\n  $$ f(\\sigma, \\alpha) = \\sigma - \\sigma_y(\\alpha) \\le 0 $$\n- **Linear Isotropic Hardening**: The yield strength $\\sigma_y$ evolves linearly with the equivalent plastic strain $\\alpha$, starting from an initial yield stress $\\sigma_{y0}$ with a plastic modulus $H$.\n  $$ \\sigma_y(\\alpha) = \\sigma_{y0} + H\\alpha $$\n- **Flow Rule and Plastic Strain**: For this 1D tension case, the associative flow rule simplifies such that the rate of plastic strain equals the rate of the plastic multiplier, $\\dot{\\varepsilon}^p = \\dot{\\gamma}$. Furthermore, the equivalent plastic strain rate is $\\dot{\\alpha} = |\\dot{\\varepsilon}^p| = \\dot{\\varepsilon}^p$ (since $\\dot{\\varepsilon}^p \\ge 0$). Integrating over time from a virgin state, we find that the accumulated plastic strain is equal to the equivalent plastic strain, $\\varepsilon^p = \\alpha$.\n  The yield condition can thus be written in terms of $\\varepsilon^p$:\n  $$ f = \\sigma - (\\sigma_{y0} + H\\varepsilon^p) \\le 0 $$\n\n### 2. Derivation of the Stress-Strain Relation $\\sigma(\\varepsilon)$\nFor a given total strain $\\varepsilon$ under monotonic tensile loading from $\\varepsilon=0$, we can determine the stress $\\sigma$. The initial yield strain is $\\varepsilon_y = \\sigma_{y0}/E$.\n\n- **Elastic Regime** ($\\varepsilon \\le \\varepsilon_y$): No plastic deformation occurs ($\\varepsilon^p=0$). The total strain is purely elastic, $\\varepsilon = \\varepsilon^e$.\n  $$ \\sigma(\\varepsilon) = E\\varepsilon $$\n- **Plastic Regime** ($\\varepsilon > \\varepsilon_y$): The material yields. The state must satisfy the yield condition, $\\sigma = \\sigma_y = \\sigma_{y0} + H\\varepsilon^p$. We also have $\\sigma = E\\varepsilon^e = E(\\varepsilon-\\varepsilon^p)$. Equating the two expressions for $\\sigma$:\n  $$ E(\\varepsilon - \\varepsilon^p) = \\sigma_{y0} + H\\varepsilon^p $$\n  Solving for the plastic strain $\\varepsilon^p$:\n  $$ E\\varepsilon - \\sigma_{y0} = (E+H)\\varepsilon^p \\implies \\varepsilon^p = \\frac{E\\varepsilon - \\sigma_{y0}}{E+H} $$\n  Substituting this back into the elastic law to find $\\sigma$ in terms of $\\varepsilon$:\n  $$ \\sigma(\\varepsilon) = E(\\varepsilon - \\varepsilon^p) = E\\left(\\varepsilon - \\frac{E\\varepsilon - \\sigma_{y0}}{E+H}\\right) = \\frac{E(E+H)\\varepsilon - E(E\\varepsilon - \\sigma_{y0})}{E+H} = \\frac{EH\\varepsilon + E\\sigma_{y0}}{E+H} $$\nThe complete, continuous, and piecewise-differentiable stress-strain relation $\\sigma(\\varepsilon)$ for monotonic tension is:\n$$\n\\sigma(\\varepsilon) = \\begin{cases}\n    E\\varepsilon & \\text{if } \\varepsilon \\le \\sigma_{y0}/E \\\\\n    \\frac{EH\\varepsilon + E\\sigma_{y0}}{E+H} & \\text{if } \\varepsilon > \\sigma_{y0}/E\n\\end{cases}\n$$\n\n### 3. Derivation of the Algorithmic (Consistent) Tangent Modulus $D^{ep}$\nThe problem requires solving the nonlinear equilibrium equation $R(\\varepsilon) = \\sigma(\\varepsilon) - T = 0$ using Newton's method. The Jacobian of this equation is $R'(\\varepsilon) = d\\sigma/d\\varepsilon$. For quadratic convergence, this Jacobian must be the *consistent tangent modulus*, which is the exact derivative of the stress update algorithm. For this 1D rate-independent case, this corresponds to the derivative of the $\\sigma(\\varepsilon)$ function derived above.\n\n- **Elastic Tangent**: In the elastic regime ($\\varepsilon \\le \\sigma_{y0}/E$):\n  $$ D^e = \\frac{d}{d\\varepsilon}(E\\varepsilon) = E $$\n- **Elastoplastic Tangent**: In the plastic regime ($\\varepsilon > \\sigma_{y0}/E$):\n  $$ D^{ep} = \\frac{d}{d\\varepsilon}\\left(\\frac{EH\\varepsilon + E\\sigma_{y0}}{E+H}\\right) = \\frac{EH}{E+H} $$\nThis $D^{ep}$ is the algorithmic tangent modulus for plastic loading.\n\n### 4. Newton's Method and Solver Implementation\nThe Newton-Raphson iteration to find $\\varepsilon$ such that $R(\\varepsilon)=0$ is:\n$$ \\varepsilon_{k+1} = \\varepsilon_{k} - \\frac{R(\\varepsilon_k)}{J_k} $$\nwhere $\\varepsilon_k$ is the strain at iteration $k$, $R(\\varepsilon_k) = \\sigma(\\varepsilon_k) - T$ is the residual, and $J_k$ is the Jacobian.\n\n- **Solver A (Consistent Tangent)**: Uses the true Jacobian, leading to quadratic convergence.\n  $$ J_k = \\frac{d\\sigma}{d\\varepsilon}\\bigg|_{\\varepsilon_k} = \\begin{cases} E & \\text{if } \\varepsilon_k \\le \\sigma_{y0}/E \\\\ \\frac{EH}{E+H} & \\text{if } \\varepsilon_k > \\sigma_{y0}/E \\end{cases} $$\n- **Solver B (Elastic Tangent)**: Uses the elastic modulus $E$ as the Jacobian for all iterations.\n  $$ J_k = E $$\n  When the material is plastic, this Jacobian is incorrect, and the convergence rate degrades to linear. The performance difference between Solver A and B is most pronounced when the consistent tangent $D^{ep}$ is significantly different from the elastic tangent $E$, which occurs for low values of the plastic modulus $H$.\n\n### 5. Exact Analytical Solution $\\varepsilon_{\\text{exact}}$\nTo calculate the numerical error, we derive the exact solution $\\varepsilon_{\\text{exact}}$ that satisfies $\\sigma(\\varepsilon_{\\text{exact}}) = T$.\n\n- **If $T \\le \\sigma_{y0}$ (Elastic)**:\n  $$ E\\varepsilon_{\\text{exact}} = T \\implies \\varepsilon_{\\text{exact}} = \\frac{T}{E} $$\n- **If $T > \\sigma_{y0}$ (Plastic)**:\n  $$ \\frac{EH\\varepsilon_{\\text{exact}} + E\\sigma_{y0}}{E+H} = T \\implies EH\\varepsilon_{\\text{exact}} = T(E+H) - E\\sigma_{y0} $$\n  $$ \\varepsilon_{\\text{exact}} = \\frac{T(E+H) - E\\sigma_{y0}}{EH} = \\frac{T}{H} + \\frac{T}{E} - \\frac{\\sigma_{y0}}{H} $$\n  Alternatively, using the strain decomposition $\\varepsilon = \\varepsilon^e + \\varepsilon^p$:\n  $$ \\varepsilon^e = \\sigma/E = T/E $$\n  $$ \\sigma = T = \\sigma_{y0} + H\\varepsilon^p \\implies \\varepsilon^p = \\frac{T-\\sigma_{y0}}{H} $$\n  $$ \\varepsilon_{\\text{exact}} = \\varepsilon^e + \\varepsilon^p = \\frac{T}{E} + \\frac{T-\\sigma_{y0}}{H} $$\n  These two forms for the plastic case are identical. This analytical solution provides the benchmark against which the numerical results are compared.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the strain in a 1D elastoplastic material under a given traction,\n    comparing a Newton solver using the consistent tangent modulus with one\n    using only the elastic modulus as the Jacobian.\n    \"\"\"\n    \n    # Define the test suite as specified in the problem statement.\n    # Each case is a tuple: (E, sigma_y0, H, T) in Pa.\n    test_cases = [\n        (200e9, 400e6, 10e9, 300e6),    # Case 1: Elastic\n        (200e9, 400e6, 10e9, 400e6),    # Case 2: At yield boundary\n        (200e9, 400e6, 10e9, 800e6),    # Case 3: Plastic, moderate hardening\n        (200e9, 400e6, 0.5e9, 800e6),   # Case 4: Plastic, weak hardening\n        (200e9, 400e6, 100e9, 1200e6),  # Case 5: Plastic, strong hardening\n    ]\n\n    results = []\n\n    for E, sigma_y0, H, T in test_cases:\n        \n        # 1. Calculate the exact analytical solution for strain.\n        if T <= sigma_y0:\n            # Elastic case\n            epsilon_exact = T / E\n        else:\n            # Plastic case: epsilon = elastic_strain + plastic_strain\n            # elastic_strain = T / E\n            # plastic_strain = (T - sigma_y0) / H\n            epsilon_exact = T / E + (T - sigma_y0) / H\n\n        # 2. Define the Newton solver.\n        def newton_solver(use_consistent_tangent):\n            \"\"\"\n            Performs Newton-Raphson iterations to solve R(e) = sigma(e) - T = 0.\n            \n            Args:\n                use_consistent_tangent (bool): If True, uses the algorithmic tangent\n                                               modulus (Solver A). If False, uses the\n                                               elastic modulus (Solver B).\n            Returns:\n                A tuple containing the final strain, number of iterations,\n                convergence status, and final residual.\n            \"\"\"\n            epsilon = 0.0\n            max_iter = 1000\n            tolerance = 1.0  # Pa, as specified\n            \n            def get_stress_and_tangent(current_epsilon):\n                \"\"\"\n                Computes stress and consistent tangent for a given total strain,\n                assuming monotonic loading from a virgin state.\n                \"\"\"\n                epsilon_yield = sigma_y0 / E\n                \n                # Check if the state is elastic or plastic\n                if current_epsilon <= epsilon_yield:\n                    sigma = E * current_epsilon\n                    tangent = E\n                else:\n                    sigma = (E * H * current_epsilon + E * sigma_y0) / (E + H)\n                    tangent = (E * H) / (E + H)\n                return sigma, tangent\n\n            for i in range(max_iter):\n                sigma, tangent_consistent = get_stress_and_tangent(epsilon)\n                residual = sigma - T\n                \n                if abs(residual) <= tolerance:\n                    return epsilon, i + 1, True, abs(residual)\n                \n                jacobian = tangent_consistent if use_consistent_tangent else E\n                \n                # Prevent division by zero, although not expected in these test cases\n                if abs(jacobian) < 1e-12:\n                    break\n                    \n                delta_epsilon = -residual / jacobian\n                epsilon += delta_epsilon\n            \n            # If the loop completes without converging\n            final_sigma, _ = get_stress_and_tangent(epsilon)\n            final_residual = abs(final_sigma - T)\n            return epsilon, max_iter, False, final_residual\n\n        # 3. Run both solvers and collect metrics.\n        \n        # Solver A (Consistent Tangent)\n        eps_A, iters_A, conv_A, res_A = newton_solver(use_consistent_tangent=True)\n        err_A = abs(eps_A - epsilon_exact)\n\n        # Solver B (Elastic Tangent)\n        eps_B, iters_B, conv_B, res_B = newton_solver(use_consistent_tangent=False)\n        err_B = abs(eps_B - epsilon_exact)\n\n        # 4. Store the results for the current test case.\n        case_result = [iters_A, iters_B, conv_A, conv_B, err_A, err_B, res_A, res_B]\n        results.append(case_result)\n\n    # 5. Format and print the final output string.\n    # Using repr() to get an unambiguous string representation of the list of lists,\n    # then removing spaces to create a compact output as per the problem's implicit format.\n    final_output_str = repr(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While 1D models are excellent for building intuition, real-world geomechanics problems require 3D formulations. This practice guides you through the essential derivation of the algorithmic tangent modulus for a classic 3D von Mises ($J_2$) plasticity model. The core task is to translate the fourth-order tangent tensor into the 6x6 matrix (Voigt) representation used in finite element codes, ensuring the mapping preserves energy consistency .",
            "id": "3522229",
            "problem": "A small-strain, isotropic, associative von Mises (Second deviatoric invariant, $J_2$) elastoplastic material with linear isotropic hardening is used in a Finite Element (FE) implementation. The elastic response is defined by the bulk modulus $K$ and shear modulus $G$, such that for any symmetric strain tensor $\\boldsymbol{\\epsilon}$ the elastic stress is $\\boldsymbol{\\sigma}^{e} = \\mathbb{C}^{e} : \\boldsymbol{\\epsilon}$, where the fourth-order elastic stiffness is $\\mathbb{C}^{e} = K\\,\\mathbf{I} \\otimes \\mathbf{I} + 2 G\\,\\mathbb{I}^{s}$. Here $\\mathbf{I}$ is the second-order identity tensor, and $\\mathbb{I}^{s}$ is the symmetric fourth-order identity. The yield function is $f(\\boldsymbol{\\sigma},\\alpha) = \\sigma_{\\mathrm{eq}} - \\sigma_{y0} - H \\alpha$, where $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}\\,\\boldsymbol{s}:\\boldsymbol{s}}$, $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}\\,\\mathrm{tr}(\\boldsymbol{\\sigma})\\,\\mathbf{I}$ is the deviatoric stress, $\\sigma_{y0}$ is the initial yield stress, $H$ is the plastic modulus, and $\\alpha$ is the accumulated plastic strain. The flow rule is associative, $\\dot{\\boldsymbol{\\epsilon}}^{p} = \\dot{\\lambda}\\,\\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$, and the hardening law is $\\dot{\\alpha} = \\dot{\\lambda}$.\n\nAt a converged material point in a Newton iteration, assume a plastic state ($\\dot{\\lambda} \\ge 0$) and denote the unit deviatoric direction by $\\boldsymbol{n} = \\boldsymbol{s}/\\|\\boldsymbol{s}\\|$ and the plastic flow direction by $\\boldsymbol{m} = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\sqrt{\\frac{3}{2}}\\,\\boldsymbol{n}$. The algorithmic consistent tangent modulus (fourth-order tensor) is defined as the derivative of the stress update with respect to the strain increment, consistent with the chosen material rate, such that the internal power is preserved, i.e., $\\dot{W} = \\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}}$.\n\nYour task is to express the algorithmic tangent modulus in the six-component Voigt form suitable for FE implementation, using the engineering shear convention for the strain-like vector and ensuring energy consistency with the chosen material time rate. Specifically:\n\n1. Define the energy-consistent Voigt mappings for the strain and stress:\n   $$\\boldsymbol{\\epsilon}^{V} = \\begin{pmatrix}\\epsilon_{11} \\\\ \\epsilon_{22} \\\\ \\epsilon_{33} \\\\ 2\\,\\epsilon_{23} \\\\ 2\\,\\epsilon_{13} \\\\ 2\\,\\epsilon_{12}\\end{pmatrix}, \\qquad \\boldsymbol{\\sigma}^{V} = \\begin{pmatrix}\\sigma_{11} \\\\ \\sigma_{22} \\\\ \\sigma_{33} \\\\ \\sigma_{23} \\\\ \\sigma_{13} \\\\ \\sigma_{12}\\end{pmatrix},$$\n   and verify that $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = (\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V}$.\n\n2. Starting from the small-strain kinematics, isotropic elasticity, the associative flow rule, and the return-mapping structure for the $J_{2}$ model, derive the fourth-order algorithmic tangent in the plastic state and show that it can be written as\n   $$\\mathbb{C}_{\\mathrm{alg}} = \\mathbb{C}^{e} - \\frac{4 G^{2}}{H + 3 G}\\,\\boldsymbol{m} \\otimes \\boldsymbol{m},$$\n   with $\\boldsymbol{m} = \\sqrt{\\frac{3}{2}}\\,\\boldsymbol{n}$.\n\n3. Using the energy-consistent mapping and the engineering shear convention, provide the $6 \\times 6$ Voigt matrix $\\mathbf{C}_{\\mathrm{alg}}^{V}$ such that $\\boldsymbol{\\sigma}^{V} = \\mathbf{C}_{\\mathrm{alg}}^{V}\\,\\boldsymbol{\\epsilon}^{V}$. Express the result in closed form as the sum of the elastic Voigt matrix and a rank-one correction constructed from the stress-like Voigt mapping of $\\boldsymbol{m}$,\n   $$\\boldsymbol{m}_{\\sigma}^{V} = \\begin{pmatrix}m_{11} \\\\ m_{22} \\\\ m_{33} \\\\ m_{23} \\\\ m_{13} \\\\ m_{12}\\end{pmatrix},$$\n   and ensure that the mapping preserves the internal power $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = (\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V}$.\n\nExpress your final answer as a single closed-form analytic expression for $\\mathbf{C}_{\\mathrm{alg}}^{V}$ in terms of $K$, $G$, $H$, and the components $m_{ij}$. No numerical evaluation is required.",
            "solution": "The problem is valid as it represents a standard and well-posed derivation in the field of computational plasticity. It is scientifically grounded, objective, and contains all necessary information to derive the requested algorithmic tangent modulus for a $J_2$-plasticity model.\n\nThe derivation will proceed in three stages: first, verification of the energy consistency of the specified Voigt mappings; second, derivation of the fourth-order algorithmic tangent tensor $\\mathbb{C}_{\\mathrm{alg}}$; and third, conversion of this tensor into its $6 \\times 6$ Voigt matrix representation $\\mathbf{C}_{\\mathrm{alg}}^{V}$.\n\n**1. Verification of Energy-Consistent Voigt Mappings**\n\nThe internal power, representing the rate of work done by stresses on strain rates, is given by the double dot product $\\dot{W} = \\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}}$. For symmetric stress $\\boldsymbol{\\sigma}$ and strain rate $\\dot{\\boldsymbol{\\epsilon}}$ tensors, this expands to:\n$$\n\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\sigma_{ij} \\dot{\\epsilon}_{ij} = \\sigma_{11}\\dot{\\epsilon}_{11} + \\sigma_{22}\\dot{\\epsilon}_{22} + \\sigma_{33}\\dot{\\epsilon}_{33} + 2\\sigma_{12}\\dot{\\epsilon}_{12} + 2\\sigma_{13}\\dot{\\epsilon}_{13} + 2\\sigma_{23}\\dot{\\epsilon}_{23}\n$$\nThe problem defines the stress-like and strain-like Voigt vectors as:\n$$\n\\boldsymbol{\\sigma}^{V} = \\begin{pmatrix}\\sigma_{11} \\\\ \\sigma_{22} \\\\ \\sigma_{33} \\\\ \\sigma_{23} \\\\ \\sigma_{13} \\\\ \\sigma_{12}\\end{pmatrix}, \\qquad \\dot{\\boldsymbol{\\epsilon}}^{V} = \\begin{pmatrix}\\dot{\\epsilon}_{11} \\\\ \\dot{\\epsilon}_{22} \\\\ \\dot{\\epsilon}_{33} \\\\ 2\\dot{\\epsilon}_{23} \\\\ 2\\dot{\\epsilon}_{13} \\\\ 2\\dot{\\epsilon}_{12}\\end{pmatrix}\n$$\nThe dot product of their transposes is:\n$$\n(\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V} = \\begin{pmatrix}\\sigma_{11} & \\sigma_{22} & \\sigma_{33} & \\sigma_{23} & \\sigma_{13} & \\sigma_{12}\\end{pmatrix} \\begin{pmatrix}\\dot{\\epsilon}_{11} \\\\ \\dot{\\epsilon}_{22} \\\\ \\dot{\\epsilon}_{33} \\\\ 2\\dot{\\epsilon}_{23} \\\\ 2\\dot{\\epsilon}_{13} \\\\ 2\\dot{\\epsilon}_{12}\\end{pmatrix}\n$$\n$$\n(\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V} = \\sigma_{11}\\dot{\\epsilon}_{11} + \\sigma_{22}\\dot{\\epsilon}_{22} + \\sigma_{33}\\dot{\\epsilon}_{33} + \\sigma_{23}(2\\dot{\\epsilon}_{23}) + \\sigma_{13}(2\\dot{\\epsilon}_{13}) + \\sigma_{12}(2\\dot{\\epsilon}_{12})\n$$\nThis expression is identical to the tensor-based internal power. Thus, the condition $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\epsilon}} = (\\boldsymbol{\\sigma}^{V})^{\\mathsf{T}}\\dot{\\boldsymbol{\\epsilon}}^{V}$ is verified, confirming the energy consistency of the chosen mappings. This is crucial for correctly transforming constitutive tensors into matrix form.\n\n**2. Derivation of the Fourth-Order Algorithmic Tangent Tensor**\n\nThe algorithmic tangent modulus is the exact linearization of the stress update algorithm. For the $J_2$-plasticity model with linear hardening, a return-mapping algorithm is used. We consider a discrete time step from $t_n$ to $t_{n+1}$. For simplicity, subscripts $n+1$ are dropped.\n\nThe total strain $\\boldsymbol{\\epsilon}$ is additively decomposed into elastic and plastic parts: $\\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}^e + \\boldsymbol{\\epsilon}^p$. The stress is given by the elastic law: $\\boldsymbol{\\sigma} = \\mathbb{C}^e : \\boldsymbol{\\epsilon}^e$.\nThe algorithm consists of an elastic trial step followed by a plastic corrector step. The trial stress is $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathbb{C}^e : (\\boldsymbol{\\epsilon} - \\boldsymbol{\\epsilon}_n^p)$. The stress is split into its volumetric part $\\boldsymbol{p} = \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})\\mathbf{I}$ and deviatoric part $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\boldsymbol{p}$.\nThe elastic response is purely volumetric from the bulk modulus $K$ and deviatoric from the shear modulus $G$. Thus, $\\boldsymbol{p}^{\\mathrm{tr}} = K\\,\\mathrm{tr}(\\boldsymbol{\\epsilon} - \\boldsymbol{\\epsilon}_n^p)\\mathbf{I}$ and $\\boldsymbol{s}^{\\mathrm{tr}} = 2G\\,\\mathrm{dev}(\\boldsymbol{\\epsilon} - \\boldsymbol{\\epsilon}_n^p)$. The plastic flow is purely deviatoric, so $\\boldsymbol{p} = \\boldsymbol{p}^{\\mathrm{tr}}$.\n\nThe plastic correction only affects the deviatoric stress. The yield condition at the trial state is $f^{\\mathrm{tr}} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - (\\sigma_{y0} + H\\alpha_n)$, where $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} = \\sqrt{\\frac{3}{2}\\boldsymbol{s}^{\\mathrm{tr}}:\\boldsymbol{s}^{\\mathrm{tr}}}$. If $f^{\\mathrm{tr}} > 0$, plastic deformation occurs. The plastic multiplier increment $\\Delta\\lambda$ is found by enforcing the consistency condition $f(\\boldsymbol{\\sigma}, \\alpha)=0$ at the end of the step.\nThe deviatoric stress is returned to the yield surface via:\n$\\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{tr}} - 2G\\Delta\\boldsymbol{\\epsilon}^p$.\nWith an associative flow rule, $\\Delta\\boldsymbol{\\epsilon}^p = \\Delta\\lambda \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\Delta\\lambda\\,\\boldsymbol{m}$, where $\\boldsymbol{m} = \\sqrt{\\frac{3}{2}}\\frac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|}$. For radial return, the direction of plastic flow is determined by the trial state, so $\\boldsymbol{m} = \\sqrt{\\frac{3}{2}}\\frac{\\boldsymbol{s}^{\\mathrm{tr}}}{\\|\\boldsymbol{s}^{\\mathrm{tr}}\\|} = \\frac{3}{2}\\frac{\\boldsymbol{s}^{\\mathrm{tr}}}{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}$.\nTaking the equivalent stress measure of the stress update equation gives $\\sigma_{\\mathrm{eq}} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3G\\Delta\\lambda$.\nThe updated yield stress is $\\sigma_y = \\sigma_{y0} + H\\alpha = \\sigma_{y0} + H(\\alpha_n + \\Delta\\lambda)$.\nThe consistency condition $\\sigma_{\\mathrm{eq}} = \\sigma_y$ yields:\n$\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3G\\Delta\\lambda = \\sigma_{y0} + H\\alpha_n + H\\Delta\\lambda$.\nSolving for $\\Delta\\lambda$: $\\Delta\\lambda = \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - (\\sigma_{y0} + H\\alpha_n)}{H+3G} = \\frac{f^{\\mathrm{tr}}}{H+3G}$.\nThe final stress is $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2G\\Delta\\lambda\\,\\boldsymbol{m}$.\nThe algorithmic tangent modulus is $\\mathbb{C}_{\\mathrm{alg}} = \\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\epsilon}}$. Through the chain rule, $\\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\epsilon}} = \\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\sigma}^{\\mathrm{tr}}} : \\frac{d\\boldsymbol{\\sigma}^{\\mathrm{tr}}}{d\\boldsymbol{\\epsilon}}$.\nSince $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathbb{C}^e : (\\boldsymbol{\\epsilon} - \\boldsymbol{\\epsilon}_n^p)$, we have $d\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathbb{C}^e : d\\boldsymbol{\\epsilon}$.\nWe differentiate the stress update equation with respect to $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$:\n$d\\boldsymbol{\\sigma} = d\\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2G(d(\\Delta\\lambda)\\,\\boldsymbol{m} + \\Delta\\lambda\\,d\\boldsymbol{m})$.\nFor the consistent tangent, the direction $\\boldsymbol{m}$ is held fixed at the converged state of the just-completed step. This is a key simplification for the algorithmic tangent. Thus, $d\\boldsymbol{m} = \\mathbf{0}$.\n$d\\boldsymbol{\\sigma} = d\\boldsymbol{\\sigma}^{\\mathrm{tr}} - 2G\\,d(\\Delta\\lambda)\\,\\boldsymbol{m}$.\nThe differential of the plastic multiplier is $d(\\Delta\\lambda) = \\frac{df^{\\mathrm{tr}}}{H+3G} = \\frac{1}{H+3G} \\frac{\\partial f^{\\mathrm{tr}}}{\\partial \\boldsymbol{\\sigma}^{\\mathrm{tr}}} : d\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\frac{1}{H+3G}\\boldsymbol{m} : d\\boldsymbol{\\sigma}^{\\mathrm{tr}}$.\nSubstituting this into the expression for $d\\boldsymbol{\\sigma}$:\n$d\\boldsymbol{\\sigma} = d\\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\frac{2G}{H+3G}(\\boldsymbol{m}:d\\boldsymbol{\\sigma}^{\\mathrm{tr}})\\,\\boldsymbol{m} = \\left[ \\mathbb{I}^s - \\frac{2G}{H+3G}\\boldsymbol{m}\\otimes\\boldsymbol{m} \\right] : d\\boldsymbol{\\sigma}^{\\mathrm{tr}}$.\nHere, $\\mathbb{I}^s$ is the symmetric fourth-order identity. Now, we compose this with $d\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathbb{C}^e : d\\boldsymbol{\\epsilon}$:\n$\\mathbb{C}_{\\mathrm{alg}} = \\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\epsilon}} = \\left[ \\mathbb{I}^s - \\frac{2G}{H+3G}\\boldsymbol{m}\\otimes\\boldsymbol{m} \\right] : \\mathbb{C}^e$.\nThe elastic stiffness tensor is $\\mathbb{C}^e = K \\mathbf{I} \\otimes \\mathbf{I} + 2G \\mathbb{I}^s_d$, where $\\mathbb{I}^s_d = \\mathbb{I}^s - \\frac{1}{3}\\mathbf{I}\\otimes\\mathbf{I}$ is the fourth-order deviatoric projector.\n$\\mathbb{C}_{\\mathrm{alg}} = \\mathbb{C}^e - \\frac{2G}{H+3G}(\\boldsymbol{m}\\otimes\\boldsymbol{m}) : (K \\mathbf{I} \\otimes \\mathbf{I} + 2G \\mathbb{I}^s_d)$.\nSince $\\boldsymbol{m}$ is deviatoric, $\\mathrm{tr}(\\boldsymbol{m})=0$, so $\\boldsymbol{m}:\\mathbf{I}=0$. This implies $(\\boldsymbol{m}\\otimes\\boldsymbol{m}):(\\mathbf{I}\\otimes\\mathbf{I}) = (\\boldsymbol{m}:\\mathbf{I})\\otimes(\\boldsymbol{m}:\\mathbf{I}) = 0$.\nAlso, $(\\boldsymbol{m}\\otimes\\boldsymbol{m}):\\mathbb{I}^s_d$ maps a tensor $\\boldsymbol{A}$ to $(\\boldsymbol{m}:\\mathrm{dev}(\\boldsymbol{A}))\\boldsymbol{m}$. As $\\boldsymbol{m}$ is deviatoric, this simplifies to $(\\boldsymbol{m}:\\boldsymbol{A})\\boldsymbol{m}$, which means $(\\boldsymbol{m}\\otimes\\boldsymbol{m}):\\mathbb{I}^s_d = \\boldsymbol{m}\\otimes\\boldsymbol{m}$.\nThus, the expression becomes:\n$\\mathbb{C}_{\\mathrm{alg}} = \\mathbb{C}^e - \\frac{2G}{H+3G}(2G\\boldsymbol{m}\\otimes\\boldsymbol{m})$.\nThis yields the desired result:\n$$\n\\mathbb{C}_{\\mathrm{alg}} = \\mathbb{C}^{e} - \\frac{4 G^{2}}{H + 3 G}\\,\\boldsymbol{m} \\otimes \\boldsymbol{m}\n$$\n\n**3. Voigt Matrix Representation**\n\nWe now convert the fourth-order tensor $\\mathbb{C}_{\\mathrm{alg}}$ to its $6 \\times 6$ matrix form $\\mathbf{C}_{\\mathrm{alg}}^{V}$. The constitutive law in Voigt notation is $\\boldsymbol{\\sigma}^{V} = \\mathbf{C}_{\\mathrm{alg}}^{V} \\boldsymbol{\\epsilon}^{V}$.\nThe elastic part $\\mathbb{C}^e$ maps to the standard isotropic elastic matrix $\\mathbf{C}_e^V$. With $\\lambda = K-\\frac{2}{3}G$, it is:\n$$\n\\mathbf{C}_{e}^{V} =\n\\begin{pmatrix}\nK+\\frac{4}{3}G & K-\\frac{2}{3}G & K-\\frac{2}{3}G & 0 & 0 & 0 \\\\\nK-\\frac{2}{3}G & K+\\frac{4}{3}G & K-\\frac{2}{3}G & 0 & 0 & 0 \\\\\nK-\\frac{2}{3}G & K-\\frac{2}{3}G & K+\\frac{4}{3}G & 0 & 0 & 0 \\\\\n0 & 0 & 0 & G & 0 & 0 \\\\\n0 & 0 & 0 & 0 & G & 0 \\\\\n0 & 0 & 0 & 0 & 0 & G\n\\end{pmatrix}\n$$\nThe plastic correction term is a rank-one tensor product $\\boldsymbol{m}\\otimes\\boldsymbol{m}$. For a fourth-order tensor of the form $\\mathbb{C} = \\boldsymbol{a} \\otimes \\boldsymbol{b}$, where $\\boldsymbol{a}$ and $\\boldsymbol{b}$ are symmetric second-order tensors, the action on a strain tensor $\\boldsymbol{\\epsilon}$ is $\\boldsymbol{\\sigma} = \\mathbb{C}:\\boldsymbol{\\epsilon} = (\\boldsymbol{b}:\\boldsymbol{\\epsilon})\\boldsymbol{a}$.\nUsing the energy-consistent Voigt map, the scalar product becomes $\\boldsymbol{b}:\\boldsymbol{\\epsilon} = (\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}\\boldsymbol{\\epsilon}^{V}$, where $\\boldsymbol{b}_{\\sigma}^{V}$ is the stress-like vector form of $\\boldsymbol{b}$.\nThe resulting stress is $\\boldsymbol{\\sigma} = [(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}\\boldsymbol{\\epsilon}^{V}]\\boldsymbol{a}$. Converting $\\boldsymbol{\\sigma}$ to its stress-like Voigt vector $\\boldsymbol{\\sigma}^V$ gives $\\boldsymbol{\\sigma}^{V} = [(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}\\boldsymbol{\\epsilon}^{V}]\\boldsymbol{a}_{\\sigma}^{V}$.\nRearranging this into matrix-vector form: $\\boldsymbol{\\sigma}^{V} = (\\boldsymbol{a}_{\\sigma}^{V}(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}})\\boldsymbol{\\epsilon}^{V}$. Therefore, the Voigt matrix for $\\boldsymbol{a}\\otimes\\boldsymbol{b}$ is the outer product $\\boldsymbol{a}_{\\sigma}^{V}(\\boldsymbol{b}_{\\sigma}^{V})^{\\mathsf{T}}$.\n\nFor the plastic correction term, $\\boldsymbol{a}=\\boldsymbol{b}=\\boldsymbol{m}$. The corresponding Voigt matrix is $\\boldsymbol{m}_{\\sigma}^{V}(\\boldsymbol{m}_{\\sigma}^{V})^{\\mathsf{T}}$.\nThe vector $\\boldsymbol{m}_{\\sigma}^{V}$ is given as $\\boldsymbol{m}_{\\sigma}^{V} = (m_{11}, m_{22}, m_{33}, m_{23}, m_{13}, m_{12})^{\\mathsf{T}}$.\nThe complete Voigt representation of the algorithmic tangent is:\n$\\mathbf{C}_{\\mathrm{alg}}^{V} = \\mathbf{C}_{e}^{V} - \\frac{4G^2}{H+3G} \\boldsymbol{m}_{\\sigma}^{V}(\\boldsymbol{m}_{\\sigma}^{V})^{\\mathsf{T}}$.\nThis is the required closed-form expression. Expanding this gives the full $6 \\times 6$ matrix. Let $\\gamma' = \\frac{4G^2}{H+3G}$. The matrix $(\\boldsymbol{m}_{\\sigma}^{V}(\\boldsymbol{m}_{\\sigma}^{V})^{\\mathsf{T}})_{IJ} = m_I m_J$, where the $m_I$ and $m_J$ are the components of $\\boldsymbol{m}_{\\sigma}^{V}$. The final matrix is the sum of the elastic matrix and the negative of this rank-one correction matrix scaled by $\\gamma'$.",
            "answer": "$$\n\\boxed{\n\\mathbf{C}_{\\mathrm{alg}}^{V} =\n\\begin{pmatrix}\nK+\\frac{4}{3}G & K-\\frac{2}{3}G & K-\\frac{2}{3}G & 0 & 0 & 0 \\\\\nK-\\frac{2}{3}G & K+\\frac{4}{3}G & K-\\frac{2}{3}G & 0 & 0 & 0 \\\\\nK-\\frac{2}{3}G & K-\\frac{2}{3}G & K+\\frac{4}{3}G & 0 & 0 & 0 \\\\\n0 & 0 & 0 & G & 0 & 0 \\\\\n0 & 0 & 0 & 0 & G & 0 \\\\\n0 & 0 & 0 & 0 & 0 & G\n\\end{pmatrix}\n- \\frac{4G^2}{H+3G}\n\\begin{pmatrix}\nm_{11}^2 & m_{11}m_{22} & m_{11}m_{33} & m_{11}m_{23} & m_{11}m_{13} & m_{11}m_{12} \\\\\nm_{22}m_{11} & m_{22}^2 & m_{22}m_{33} & m_{22}m_{23} & m_{22}m_{13} & m_{22}m_{12} \\\\\nm_{33}m_{11} & m_{33}m_{22} & m_{33}^2 & m_{33}m_{23} & m_{33}m_{13} & m_{33}m_{12} \\\\\nm_{23}m_{11} & m_{23}m_{22} & m_{23}m_{33} & m_{23}^2 & m_{23}m_{13} & m_{23}m_{12} \\\\\nm_{13}m_{11} & m_{13}m_{22} & m_{13}m_{33} & m_{13}m_{23} & m_{13}^2 & m_{13}m_{12} \\\\\nm_{12}m_{11} & m_{12}m_{22} & m_{12}m_{33} & m_{12}m_{23} & m_{12}m_{13} & m_{12}^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A correctly derived tangent modulus not only ensures quadratic convergence but also reflects the underlying physics of the constitutive model. This advanced practice focuses on the crucial step of verification, where you will numerically test if the tangent leads to physically meaningful predictions of incremental plastic work. By comparing the work predicted by the linearized model against the exact work from a full return-mapping step, you can verify that your implementation respects the principles of plastic dissipation .",
            "id": "3522268",
            "problem": "Consider small-strain, rate-independent, isotropic, associated elastoplasticity with a von Mises (also known as $J_2$) yield condition and linear isotropic hardening, as used in computational geomechanics. The fundamental base consists of the additive strain decomposition, the elastic law for isotropic linear elasticity, the von Mises yield function, and the associated flow rule:\n- Additive strain decomposition: $\\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}^e + \\boldsymbol{\\epsilon}^p$.\n- Isotropic linear elasticity: $\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\epsilon}^e)\\,\\mathbf{I} + 2\\mu\\,\\mathrm{dev}(\\boldsymbol{\\epsilon}^e)$, where $\\lambda$ and $\\mu$ are the Lamé parameters, $\\mathrm{tr}(\\cdot)$ denotes the trace, $\\mathbf{I}$ is the identity tensor, and $\\mathrm{dev}(\\cdot)$ extracts the deviatoric part.\n- von Mises yield function with linear isotropic hardening: $f = \\|\\mathbf{s}\\| - \\sqrt{\\dfrac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha\\right)$, where $\\mathbf{s} = \\mathrm{dev}(\\boldsymbol{\\sigma})$ is the deviatoric stress, $\\sigma_{y0}$ is the initial yield stress, $H$ is the hardening modulus, and $\\alpha$ is the accumulated plastic strain measure (equivalent plastic strain), which evolves via $\\dot{\\alpha} = \\sqrt{\\frac{2}{3}}\\dot{\\gamma}$.\n- Associated flow rule: $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\gamma}\\,\\mathbf{n}$ with $\\mathbf{n} = \\dfrac{\\mathbf{s}}{\\|\\mathbf{s}\\|}$ and consistency enforced when plastic loading is active.\n\nThe incremental plastic work over a load step from time $t_n$ to $t_{n+1}$ with strain increment $\\Delta\\boldsymbol{\\epsilon}$ is defined as $W_p^{\\mathrm{inc}} = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$, expressed in megapascals (MPa), where the colon denotes the double contraction and $\\Delta\\boldsymbol{\\epsilon}^p$ is the plastic strain increment tensor. The algorithmic consistent elastoplastic tangent modulus $\\mathbf{D}^{ep}$ is the derivative of the stress update mapping with respect to the strain increment, evaluated at the state of interest.\n\nYour task is to write a program that:\n1. Implements an incremental return mapping algorithm for the specified model, starting from the fundamental base listed above (do not use any pre-derived shortcut formulas beyond those derivable from the base).\n2. Numerically constructs the algorithmic consistent tangent modulus $\\mathbf{D}^{ep}$ at a given state by finite differencing the exact stress update algorithm with respect to the strain increment in Voigt notation. Use the Voigt ordering $[\\epsilon_{xx}, \\epsilon_{yy}, \\epsilon_{zz}, \\gamma_{yz}, \\gamma_{xz}, \\gamma_{xy}]$, where $\\gamma_{ij}$ are the engineering shear strains and stresses are ordered as $[\\sigma_{xx}, \\sigma_{yy}, \\sigma_{zz}, \\tau_{yz}, \\tau_{xz}, \\tau_{xy}]$.\n3. Uses $\\mathbf{D}^{ep}$ to compute a linearized prediction of the plastic strain increment for a given step via the relation $\\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}} = \\Delta\\boldsymbol{\\epsilon} - \\mathbf{S}:\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}$, where $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}} = \\mathbf{D}^{ep} : \\Delta\\boldsymbol{\\epsilon}$ and $\\mathbf{S}$ is the elastic compliance, which in tensor form is $\\mathbf{S} = \\dfrac{1}{2\\mu}\\mathbf{P}_{\\mathrm{dev}} + \\dfrac{1}{9K}\\mathbf{I}_{\\mathrm{vol}}$, with $\\mathbf{P}_{\\mathrm{dev}}$ the deviatoric projector, $\\mathbf{I}_{\\mathrm{vol}}$ the volumetric projector, and $K$ the bulk modulus.\n4. Evaluates the incremental plastic work in two ways:\n   - Exact incremental plastic work: $W_p^{\\mathrm{inc,exact}} = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$, computed from the return-mapped stress and the exact plastic strain increment.\n   - Linearized incremental plastic work using the tangent: $W_p^{\\mathrm{inc,lin}} = \\boldsymbol{\\sigma}_{n} : \\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}}$, computed from the pre-step stress and the linearized plastic strain increment derived using $\\mathbf{D}^{ep}$ and $\\mathbf{S}$.\n\nVerify algorithmic consistency through incremental energy dissipation by checking that:\n- The linearized plastic work is non-negative $W_p^{\\mathrm{inc,lin}} \\ge 0$ (no spurious creation of plastic work with linearization).\n- The linearized plastic work matches the exact plastic work to first order, i.e., $\\left|W_p^{\\mathrm{inc,lin}} - W_p^{\\mathrm{inc,exact}}\\right| \\le \\varepsilon \\,\\max\\left(1, \\left|W_p^{\\mathrm{inc,exact}}\\right|\\right)$ for a chosen tolerance $\\varepsilon$.\n\nMaterial parameters to use in all cases are:\n- Young’s modulus $E = 10000$ MPa, Poisson’s ratio $\\nu = 0.3$.\n- Initial yield stress $\\sigma_{y0} = 50$ MPa, hardening modulus $H = 1000$ MPa.\n\nExpress all plastic work values internally in megapascals (MPa). Angles do not appear in this problem. Strain is dimensionless.\n\nConstruct a test suite of five sequential incremental steps, applied cumulatively to the same material point starting from zero stress and zero plastic strain:\n- Step 1 (pure volumetric, elastic): $\\Delta\\boldsymbol{\\epsilon} = [1\\times 10^{-5},\\,1\\times 10^{-5},\\,1\\times 10^{-5},\\,0,\\,0,\\,0]$.\n- Step 2 (pure shear, plastic): $\\Delta\\boldsymbol{\\epsilon} = [0,\\,0,\\,0,\\,0,\\,0,\\,0.01]$.\n- Step 3 (reverse shear, likely elastic due to hardening): $\\Delta\\boldsymbol{\\epsilon} = [0,\\,0,\\,0,\\,0,\\,0,\\,-0.005]$.\n- Step 4 (near-yield shear from a fresh state snapshot; for this step, reset to zero stress and zero plastic strain before applying): $\\Delta\\boldsymbol{\\epsilon} = [0,\\,0,\\,0,\\,0,\\,0,\\,\\gamma_y]$ with $\\gamma_y = \\dfrac{\\sigma_{y0}}{\\sqrt{3}\\,\\mu}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$.\n- Step 5 (combined volumetric-deviatoric, plastic): $\\Delta\\boldsymbol{\\epsilon} = [5\\times 10^{-4},\\,-2.5\\times 10^{-4},\\,-2.5\\times 10^{-4},\\,0,\\,0,\\,0.008]$.\n\nFor the five steps above, determine a boolean result for each step indicating whether both conditions hold:\n- Non-negative linearized plastic work.\n- Agreement of linearized and exact plastic work within tolerance $\\varepsilon = 5\\times 10^{-3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true,false,true,true,false]\"). The booleans must be lowercase. The program must be fully self-contained and must not require user input.",
            "solution": "We begin with small-strain elastoplasticity. The total strain can be additively decomposed as $\\boldsymbol{\\epsilon} = \\boldsymbol{\\epsilon}^e + \\boldsymbol{\\epsilon}^p$. The elastic law for isotropic linear elasticity is written as $\\boldsymbol{\\sigma} = \\lambda\\,\\mathrm{tr}(\\boldsymbol{\\epsilon}^e)\\,\\mathbf{I} + 2\\mu\\,\\mathrm{dev}(\\boldsymbol{\\epsilon}^e)$, where $\\boldsymbol{\\epsilon}^e_{\\mathrm{dev}} = \\mathrm{dev}(\\boldsymbol{\\epsilon}^e)$ and the deviatoric projector acts as $\\mathrm{dev}(\\mathbf{A}) = \\mathbf{A} - \\dfrac{1}{3}\\mathrm{tr}(\\mathbf{A})\\mathbf{I}$. The shear modulus is $\\mu = \\dfrac{E}{2(1+\\nu)}$ and the bulk modulus is $K = \\dfrac{E}{3(1-2\\nu)}$. The Lamé parameter is $\\lambda = K - \\dfrac{2}{3}\\mu$.\n\nThe von Mises yield function with linear isotropic hardening is $f = \\|\\mathbf{s}\\| - \\sqrt{\\dfrac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha\\right)$, where $\\mathbf{s} = \\mathrm{dev}(\\boldsymbol{\\sigma})$ and $\\alpha$ is the equivalent plastic strain. The associated flow rule prescribes $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\gamma}\\,\\mathbf{n}$ with $\\mathbf{n} = \\dfrac{\\mathbf{s}}{\\|\\mathbf{s}\\|}$, and the hardening evolves as $\\dot{\\alpha} = \\sqrt{\\dfrac{2}{3}}\\dot{\\gamma}$.\n\nAn incremental return mapping algorithm for a strain increment $\\Delta\\boldsymbol{\\epsilon}$ proceeds as follows. Denote the pre-step state by $(\\boldsymbol{\\sigma}_n, \\boldsymbol{\\epsilon}^p_n, \\alpha_n)$ and the post-step state by $(\\boldsymbol{\\sigma}_{n+1}, \\boldsymbol{\\epsilon}^p_{n+1}, \\alpha_{n+1})$. Compute the elastic predictor (trial stress increment) using the elastic stiffness without plastic strain increment:\n$$\n\\Delta\\boldsymbol{\\sigma}_{\\mathrm{trial}} = K\\,\\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon})\\,\\mathbf{I} + 2\\mu\\,\\mathrm{dev}(\\Delta\\boldsymbol{\\epsilon}),\n$$\nand form the trial stress $\\boldsymbol{\\sigma}_{\\mathrm{trial}} = \\boldsymbol{\\sigma}_n + \\Delta\\boldsymbol{\\sigma}_{\\mathrm{trial}}$. Extract its deviatoric part $\\mathbf{s}_{\\mathrm{trial}} = \\mathrm{dev}(\\boldsymbol{\\sigma}_{\\mathrm{trial}})$ and compute the yield function at trial:\n$$\nf_{\\mathrm{trial}} = \\left\\|\\mathbf{s}_{\\mathrm{trial}}\\right\\| - \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_n\\right).\n$$\nIf $f_{\\mathrm{trial}} \\le 0$, the step is elastic, so $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\mathrm{trial}}$, $\\Delta\\boldsymbol{\\epsilon}^p = \\mathbf{0}$, and $\\alpha_{n+1} = \\alpha_n$. If $f_{\\mathrm{trial}} > 0$, plasticity occurs and the standard radial return mapping applies. Define the unit deviatoric direction $\\mathbf{n} = \\dfrac{\\mathbf{s}_{\\mathrm{trial}}}{\\|\\mathbf{s}_{\\mathrm{trial}}\\|}$ and solve for the plastic consistency increment $\\Delta\\gamma$ by enforcing the yield condition at the end of the step:\n$$\n\\left\\|\\mathbf{s}_{n+1}\\right\\| = \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_{n+1}\\right).\n$$\nUnder radial return, $\\mathbf{s}_{n+1} = \\mathbf{s}_{\\mathrm{trial}} - 2\\mu\\,\\Delta\\gamma\\,\\mathbf{n}$ and $\\alpha_{n+1} = \\alpha_n + \\sqrt{\\dfrac{2}{3}}\\Delta\\gamma$. Substitution yields the scalar equation\n$$\n\\|\\mathbf{s}_{\\mathrm{trial}}\\| - 2\\mu\\,\\Delta\\gamma = \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_n + H\\sqrt{\\frac{2}{3}}\\Delta\\gamma\\right),\n$$\nwhich simplifies to\n$$\n\\Delta\\gamma = \\frac{ \\|\\mathbf{s}_{\\mathrm{trial}}\\| - \\sqrt{\\dfrac{2}{3}}\\left(\\sigma_{y0} + H\\,\\alpha_n\\right)}{ 2\\mu + \\dfrac{2}{3}H }.\n$$\nThe plastic strain increment is then\n$$\n\\Delta\\boldsymbol{\\epsilon}^p = \\Delta\\gamma\\,\\mathbf{n},\n$$\nand the post-step stress is\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\mathbf{s}_{n+1} + p_{\\mathrm{trial}}\\,\\mathbf{I},\\quad p_{\\mathrm{trial}} = \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma}_{\\mathrm{trial}}).\n$$\nThe exact incremental plastic work for the step is $W_p^{\\mathrm{inc,exact}} = \\boldsymbol{\\sigma}_{n+1} : \\Delta\\boldsymbol{\\epsilon}^p$, expressed in megapascals.\n\nNext, we discuss the algorithmic consistent elastoplastic tangent modulus. By definition, $\\mathbf{D}^{ep}$ is the Fréchet derivative of the stress update mapping at the state of interest, i.e., $\\Delta\\boldsymbol{\\sigma} \\approx \\mathbf{D}^{ep} : \\Delta\\boldsymbol{\\epsilon}$ for sufficiently small $\\Delta\\boldsymbol{\\epsilon}$, where the stress is updated with the exact algorithm (including plastic flow when active). A robust way to obtain $\\mathbf{D}^{ep}$ is to numerically differentiate the update mapping via finite differences: perturb the strain increment along each Voigt basis direction by a small amount and compute the resulting stress increment, assembling the columns of $\\mathbf{D}^{ep}$ from these directional derivatives.\n\nGiven $\\mathbf{D}^{ep}$, we obtain a linearized prediction of the elastic strain increment by applying the elastic compliance operator. The compliance in tensor form is\n$$\n\\mathbf{S} = \\frac{1}{2\\mu}\\mathbf{P}_{\\mathrm{dev}} + \\frac{1}{9K}\\mathbf{I}_{\\mathrm{vol}},\n$$\nwhere $\\mathbf{P}_{\\mathrm{dev}}$ extracts the deviatoric component of a second-order tensor and $\\mathbf{I}_{\\mathrm{vol}}$ maps a scalar (trace) to the volumetric strain tensor. For a stress increment $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}$, the elastic strain increment is\n$$\n\\Delta\\boldsymbol{\\epsilon}^e_{\\mathrm{lin}} = \\mathbf{S} : \\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}} = \\frac{1}{2\\mu}\\mathrm{dev}\\left(\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}\\right) + \\frac{1}{9K}\\mathrm{tr}\\left(\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}}\\right)\\mathbf{I}.\n$$\nTherefore, the linearized plastic strain increment is\n$$\n\\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}} = \\Delta\\boldsymbol{\\epsilon} - \\Delta\\boldsymbol{\\epsilon}^e_{\\mathrm{lin}}.\n$$\nWe then define the linearized incremental plastic work as\n$$\nW_p^{\\mathrm{inc,lin}} = \\boldsymbol{\\sigma}_n : \\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}},\n$$\nwhich is a first-order accurate approximation to $W_p^{\\mathrm{inc,exact}}$ under the consistent tangent linearization.\n\nTwo consistency checks are required: non-negativity and first-order agreement. The Clausius-Duhem inequality for rate-independent associated plasticity implies $\\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\epsilon}}^p \\ge 0$, which at the discrete level motivates $W_p^{\\mathrm{inc,lin}} \\ge 0$. First-order agreement is assessed by requiring $|W_p^{\\mathrm{inc,lin}} - W_p^{\\mathrm{inc,exact}}|$ to be sufficiently small relative to the magnitude of $W_p^{\\mathrm{inc,exact}}$.\n\nAlgorithmic design:\n- Represent stress and strain in Voigt notation with engineering shear components for scalar products to reflect work conjugacy.\n- Implement conversion between Voigt vectors and $3\\times 3$ symmetric tensors to compute deviatoric parts and norms consistently.\n- Implement the return mapping algorithm per step, updating $(\\boldsymbol{\\sigma}, \\boldsymbol{\\epsilon}^p, \\alpha)$ and computing $\\Delta\\boldsymbol{\\epsilon}^p$.\n- Build $\\mathbf{D}^{ep}$ by finite difference of the full update mapping at the pre-step state for the given step.\n- Compute $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{lin}} = \\mathbf{D}^{ep} : \\Delta\\boldsymbol{\\epsilon}$, then $\\Delta\\boldsymbol{\\epsilon}^e_{\\mathrm{lin}}$ via the compliance operator, and finally $\\Delta\\boldsymbol{\\epsilon}^p_{\\mathrm{lin}}$.\n- Compute $W_p^{\\mathrm{inc,exact}}$ and $W_p^{\\mathrm{inc,lin}}$ in megapascals by the Voigt scalar product, and check the two conditions for each step.\n- For the fourth step, reset the state to $(\\boldsymbol{\\sigma}, \\boldsymbol{\\epsilon}^p, \\alpha) = (\\mathbf{0}, \\mathbf{0}, 0)$ prior to applying the near-yield increment; this tests the boundary case at the yield surface.\n- Aggregate the booleans for the five steps into a single list and print it in the specified format.\n\nThis design conforms to the fundamental laws and definitions and avoids shortcut formulas by deriving the return mapping relations and the compliance-based decomposition from first principles. The test suite covers elastic, plastic, unloading, yield boundary, and combined loading cases, ensuring coverage of algorithmic consistency across different regimes. The output is a single list of lowercase booleans indicating whether the tangent-based linearization preserves non-negative plastic work and matches the exact plastic work to first order for each incremental step.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Material parameters\nE = 10000.0  # MPa\nnu = 0.3\nsigma_y0 = 50.0  # MPa\nH = 1000.0  # MPa\n\n# Derived elastic moduli\nmu = E / (2.0 * (1.0 + nu))         # shear modulus\nK = E / (3.0 * (1.0 - 2.0 * nu))    # bulk modulus\nlam = K - 2.0 * mu / 3.0            # Lamé first parameter\n\n# Helpers: Voigt <-> tensor and deviatoric operations\ndef voigt_strain_to_tensor(e):\n    # e = [exx, eyy, ezz, gyz, gxz, gxy] (engineering shear)\n    eps = np.zeros((3, 3))\n    eps[0, 0] = e[0]\n    eps[1, 1] = e[1]\n    eps[2, 2] = e[2]\n    eps[1, 2] = e[3] / 2.0\n    eps[2, 1] = e[3] / 2.0\n    eps[0, 2] = e[4] / 2.0\n    eps[2, 0] = e[4] / 2.0\n    eps[0, 1] = e[5] / 2.0\n    eps[1, 0] = e[5] / 2.0\n    return eps\n\ndef tensor_to_voigt_strain(eps):\n    return np.array([\n        eps[0, 0],\n        eps[1, 1],\n        eps[2, 2],\n        eps[1, 2] * 2.0,\n        eps[0, 2] * 2.0,\n        eps[0, 1] * 2.0\n    ])\n\ndef voigt_stress_to_tensor(s):\n    # s = [sxx, syy, szz, tyz, txz, txy]\n    sig = np.zeros((3, 3))\n    sig[0, 0] = s[0]\n    sig[1, 1] = s[1]\n    sig[2, 2] = s[2]\n    sig[1, 2] = s[3]\n    sig[2, 1] = s[3]\n    sig[0, 2] = s[4]\n    sig[2, 0] = s[4]\n    sig[0, 1] = s[5]\n    sig[1, 0] = s[5]\n    return sig\n\ndef tensor_to_voigt_stress(sig):\n    return np.array([\n        sig[0, 0],\n        sig[1, 1],\n        sig[2, 2],\n        sig[1, 2],\n        sig[0, 2],\n        sig[0, 1]\n    ])\n\ndef dev(tensor):\n    tr = np.trace(tensor)\n    return tensor - (tr / 3.0) * np.eye(3)\n\ndef tensor_norm(tensor):\n    return np.sqrt(np.sum(tensor * tensor))\n\n# Elastic trial stress increment mapping\ndef elastic_stress_increment(delta_eps_tensor):\n    # delta_sigma = K tr(delta_eps) I + 2 mu dev(delta_eps)\n    tr_eps = np.trace(delta_eps_tensor)\n    return K * tr_eps * np.eye(3) + 2.0 * mu * dev(delta_eps_tensor)\n\n# Compliance mapping: from stress increment tensor to elastic strain increment tensor\ndef elastic_compliance_map(delta_sigma_tensor):\n    # epsilon_e = (1/(2 mu)) dev(delta_sigma) + (1/(9 K)) tr(delta_sigma) I\n    tr_sig = np.trace(delta_sigma_tensor)\n    return (1.0 / (2.0 * mu)) * dev(delta_sigma_tensor) + (tr_sig / (9.0 * K)) * np.eye(3)\n\n# Return mapping for one step\ndef return_mapping_update(state, delta_eps_voigt):\n    # state: dict with 'sigma' (3x3 tensor), 'eps_p' (3x3 tensor), 'alpha' (float)\n    sigma_n = state['sigma']\n    alpha_n = state['alpha']\n\n    delta_eps_tensor = voigt_strain_to_tensor(delta_eps_voigt)\n    # Elastic predictor: trial stress\n    delta_sigma_trial = elastic_stress_increment(delta_eps_tensor)\n    sigma_trial = sigma_n + delta_sigma_trial\n\n    s_trial = dev(sigma_trial)\n    norm_s_trial = tensor_norm(s_trial)\n    f_trial = norm_s_trial - np.sqrt(2.0 / 3.0) * (sigma_y0 + H * alpha_n)\n\n    if f_trial <= 0.0:\n        # Elastic step\n        sigma_np1 = sigma_trial\n        delta_eps_p_tensor = np.zeros((3, 3))\n        alpha_np1 = alpha_n\n    else:\n        # Plastic step: radial return\n        n_dir = s_trial / (norm_s_trial + 1e-32)\n        denom = 2.0 * mu + (2.0 / 3.0) * H\n        delta_gamma = f_trial / denom\n        s_np1 = s_trial - 2.0 * mu * delta_gamma * n_dir\n        p_trial = np.trace(sigma_trial) / 3.0\n        sigma_np1 = s_np1 + p_trial * np.eye(3)\n        delta_eps_p_tensor = delta_gamma * n_dir\n        alpha_np1 = alpha_n + np.sqrt(2.0 / 3.0) * delta_gamma\n\n    # Exact incremental plastic work: sigma_{n+1} : delta_eps_p\n    delta_eps_p_voigt = tensor_to_voigt_strain(delta_eps_p_tensor)\n    sigma_np1_voigt = tensor_to_voigt_stress(sigma_np1)\n    Wp_inc_exact = float(np.dot(sigma_np1_voigt, delta_eps_p_voigt))\n\n    # Update state\n    new_state = {\n        'sigma': sigma_np1,\n        'eps_p': state['eps_p'] + delta_eps_p_tensor,\n        'alpha': alpha_np1\n    }\n    return new_state, delta_eps_p_voigt, Wp_inc_exact\n\n# Numerical tangent D_ep at given state via finite difference\ndef numeric_tangent_dep(state, h=1e-8):\n    sigma_base = state['sigma']\n    Dep = np.zeros((6, 6))\n    for i in range(6):\n        delta_eps = np.zeros(6)\n        delta_eps[i] = h\n        # Apply small increment from the base state\n        base_copy = {\n            'sigma': sigma_base.copy(),\n            'eps_p': state['eps_p'].copy(),\n            'alpha': state['alpha']\n        }\n        new_state, _, _ = return_mapping_update(base_copy, delta_eps)\n        delta_sigma_tensor = new_state['sigma'] - sigma_base\n        delta_sigma_voigt = tensor_to_voigt_stress(delta_sigma_tensor)\n        Dep[:, i] = delta_sigma_voigt / h\n    return Dep\n\ndef solve():\n    # Tolerance for first-order agreement\n    tol = 5e-3\n    # Define the sequential test steps (cumulative), with the reset before step 4 as specified.\n    # Steps 1-3 are cumulative; before step 4, reset; step 5 continues from step 3 state (not from step 4 reset).\n    steps = [\n        np.array([1e-5, 1e-5, 1e-5, 0.0, 0.0, 0.0]),   # Step 1\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.01]),     # Step 2\n        np.array([0.0, 0.0, 0.0, -0.0, 0.0, -0.005]),  # Step 3\n    ]\n\n    # Initial state\n    state = {\n        'sigma': np.zeros((3, 3)),\n        'eps_p': np.zeros((3, 3)),\n        'alpha': 0.0\n    }\n\n    results = []\n\n    # Process steps 1-3 cumulatively\n    for delta_eps in steps:\n        # Build numeric tangent at pre-step state\n        Dep = numeric_tangent_dep(state, h=1e-8)\n        # Linearized stress increment\n        delta_sigma_lin_voigt = Dep @ delta_eps\n        delta_sigma_lin_tensor = voigt_stress_to_tensor(delta_sigma_lin_voigt)\n        # Linearized elastic strain increment via compliance\n        delta_eps_e_lin_tensor = elastic_compliance_map(delta_sigma_lin_tensor)\n        delta_eps_e_lin_voigt = tensor_to_voigt_strain(delta_eps_e_lin_tensor)\n        # Linearized plastic strain increment\n        delta_eps_p_lin_voigt = delta_eps - delta_eps_e_lin_voigt\n        # Linearized plastic work using pre-step stress\n        sigma_n_voigt = tensor_to_voigt_stress(state['sigma'])\n        Wp_inc_lin = float(np.dot(sigma_n_voigt, delta_eps_p_lin_voigt))\n        # Exact update and exact plastic work\n        new_state, delta_eps_p_exact_voigt, Wp_inc_exact = return_mapping_update(state, delta_eps)\n        # Consistency checks\n        nonneg = (Wp_inc_lin >= -1e-10)\n        err = abs(Wp_inc_lin - Wp_inc_exact)\n        scale = max(1.0, abs(Wp_inc_exact))\n        agree = (err <= tol * scale)\n        results.append(nonneg and agree)\n        # Update cumulative state\n        state = new_state\n\n    # Step 4: reset to zero state before applying near-yield shear increment\n    state_reset = {\n        'sigma': np.zeros((3, 3)),\n        'eps_p': np.zeros((3, 3)),\n        'alpha': 0.0\n    }\n    gamma_y = sigma_y0 / (np.sqrt(3.0) * mu)\n    delta_eps4 = np.array([0.0, 0.0, 0.0, 0.0, 0.0, gamma_y])\n\n    Dep4 = numeric_tangent_dep(state_reset, h=1e-8)\n    delta_sigma_lin_voigt_4 = Dep4 @ delta_eps4\n    delta_sigma_lin_tensor_4 = voigt_stress_to_tensor(delta_sigma_lin_voigt_4)\n    delta_eps_e_lin_tensor_4 = elastic_compliance_map(delta_sigma_lin_tensor_4)\n    delta_eps_e_lin_voigt_4 = tensor_to_voigt_strain(delta_eps_e_lin_tensor_4)\n    delta_eps_p_lin_voigt_4 = delta_eps4 - delta_eps_e_lin_voigt_4\n    sigma_n_voigt_4 = tensor_to_voigt_stress(state_reset['sigma'])\n    Wp_inc_lin_4 = float(np.dot(sigma_n_voigt_4, delta_eps_p_lin_voigt_4))\n    new_state_4, delta_eps_p_exact_voigt_4, Wp_inc_exact_4 = return_mapping_update(state_reset, delta_eps4)\n    nonneg_4 = (Wp_inc_lin_4 >= -1e-10)\n    err_4 = abs(Wp_inc_lin_4 - Wp_inc_exact_4)\n    scale_4 = max(1.0, abs(Wp_inc_exact_4))\n    agree_4 = (err_4 <= tol * scale_4)\n    results.append(nonneg_4 and agree_4)\n\n    # Step 5: continue from the state after step 3 (cumulative sequence), combined loading\n    delta_eps5 = np.array([5e-4, -2.5e-4, -2.5e-4, 0.0, 0.0, 0.008])\n    Dep5 = numeric_tangent_dep(state, h=1e-8)\n    delta_sigma_lin_voigt_5 = Dep5 @ delta_eps5\n    delta_sigma_lin_tensor_5 = voigt_stress_to_tensor(delta_sigma_lin_voigt_5)\n    delta_eps_e_lin_tensor_5 = elastic_compliance_map(delta_sigma_lin_tensor_5)\n    delta_eps_e_lin_voigt_5 = tensor_to_voigt_strain(delta_eps_e_lin_tensor_5)\n    delta_eps_p_lin_voigt_5 = delta_eps5 - delta_eps_e_lin_voigt_5\n    sigma_n_voigt_5 = tensor_to_voigt_stress(state['sigma'])\n    Wp_inc_lin_5 = float(np.dot(sigma_n_voigt_5, delta_eps_p_lin_voigt_5))\n    new_state_5, delta_eps_p_exact_voigt_5, Wp_inc_exact_5 = return_mapping_update(state, delta_eps5)\n    nonneg_5 = (Wp_inc_lin_5 >= -1e-10)\n    err_5 = abs(Wp_inc_lin_5 - Wp_inc_exact_5)\n    scale_5 = max(1.0, abs(Wp_inc_exact_5))\n    agree_5 = (err_5 <= tol * scale_5)\n    results.append(nonneg_5 and agree_5)\n\n    # Final print statement in the exact required format (lowercase booleans)\n    print(f\"[{','.join(map(lambda x: 'true' if x else 'false', results))}]\")\n\nsolve()\n```"
        }
    ]
}