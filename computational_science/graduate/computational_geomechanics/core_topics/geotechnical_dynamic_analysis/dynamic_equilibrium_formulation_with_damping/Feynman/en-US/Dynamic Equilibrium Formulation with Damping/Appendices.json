{
    "hands_on_practices": [
        {
            "introduction": "The Rayleigh damping model provides a convenient way to construct a damping matrix $\\mathbf{C}$ from the mass matrix $\\mathbf{M}$ and stiffness matrix $\\mathbf{K}$. This foundational exercise will guide you through the process of translating this matrix-level assumption into its effects on individual modes of vibration. By performing a modal analysis, you will derive the effective damping ratio $\\zeta_n$ for each mode, a critical skill for understanding and predicting how energy dissipation is distributed across a system's frequency spectrum .",
            "id": "3519848",
            "problem": "Consider a small-strain, linear-elastic soil domain discretized by the Finite Element (FE) method, resulting in the semi-discrete dynamic equilibrium equation\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0},\n$$\nwhere $\\mathbf{M}$ is the symmetric positive-definite mass matrix, $\\mathbf{K}$ is the symmetric positive-definite stiffness matrix, $\\mathbf{C}$ is the damping matrix, and $\\mathbf{u}(t)$ is the nodal displacement vector. Assume proportional (Rayleigh) damping such that\n$$\n\\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K},\n$$\nwith $\\alpha > 0$ and $\\beta > 0$. Let the undamped modal properties be defined by the generalized eigenvalue problem\n$$\n\\mathbf{K}\\,\\boldsymbol{\\phi}_n = \\omega_n^{2}\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_n,\n$$\nwhere $\\boldsymbol{\\phi}_n$ is the $n$-th mode shape and $\\omega_n$ is its undamped natural circular frequency. Starting from Newton’s second law in semi-discrete form and the Rayleigh damping definition, perform a modal transformation and use the fundamental orthogonality relations of undamped modes to obtain the scalar modal equation for an arbitrary mode $n$. From this scalar equation, derive the damping ratio $\\zeta_n$ and the damped natural circular frequency $\\omega_{d,n}$ for mode $n$ in terms of $\\alpha$, $\\beta$, and $\\omega_n$, without invoking any additional constitutive or phenomenological assumptions beyond linearity and proportional damping. Express your final answer symbolically, and present it as a single row matrix containing, in order, the two analytic expressions for $\\zeta_n$ and $\\omega_{d,n}$. No numerical evaluation is required. If you introduce any auxiliary modal quantities, they must be eliminated in the final expressions so that only $\\alpha$, $\\beta$, and $\\omega_n$ appear. Provide the final answer using the LaTeX $\\mathrm{pmatrix}$ environment and do not include units in the final boxed expression.",
            "solution": "The problem is first validated against the established criteria.\n\n### Step 1: Extract Givens\n-   The semi-discrete dynamic equilibrium equation for a linear-elastic soil domain is:\n    $$\n    \\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}\n    $$\n-   $\\mathbf{M}$ is the symmetric positive-definite mass matrix.\n-   $\\mathbf{K}$ is the symmetric positive-definite stiffness matrix.\n-   $\\mathbf{C}$ is the damping matrix.\n-   $\\mathbf{u}(t)$ is the nodal displacement vector.\n-   The damping is of the proportional (Rayleigh) type:\n    $$\n    \\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K}\n    $$\n-   The Rayleigh damping coefficients satisfy $\\alpha > 0$ and $\\beta > 0$.\n-   The undamped generalized eigenvalue problem is:\n    $$\n    \\mathbf{K}\\,\\boldsymbol{\\phi}_n = \\omega_n^{2}\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_n\n    $$\n-   $\\boldsymbol{\\phi}_n$ is the $n$-th mode shape (eigenvector).\n-   $\\omega_n$ is the $n$-th undamped natural circular frequency (related to the eigenvalue).\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem is based on fundamental principles of structural dynamics and the Finite Element Method as applied to geomechanics. The equations for dynamic equilibrium, Rayleigh damping, and modal analysis are standard and well-established.\n-   **Well-Posed**: The problem is clearly formulated. It provides all necessary equations and definitions to perform the requested derivation. A unique analytical solution for the requested quantities exists.\n-   **Objective**: The language is precise, mathematical, and free of any subjective or non-scientific content.\n\nThe problem statement satisfies all validity criteria. It is scientifically sound, well-posed, and objective, with no evident flaws. Therefore, it is deemed **valid**.\n\n### Solution Derivation\n\nThe solution begins with the semi-discrete equation of motion:\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}\n$$\nThe core of modal analysis is to transform the system of coupled differential equations into a set of uncoupled scalar equations using the mode shapes as a basis. The displacement vector $\\mathbf{u}(t)$ is expressed as a linear combination of the mode shapes $\\boldsymbol{\\phi}_j$, weighted by time-dependent modal coordinates $q_j(t)$:\n$$\n\\mathbf{u}(t) = \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, q_j(t)\n$$\nwhere $N$ is the number of degrees of freedom. Substituting this modal expansion into the equation of motion yields:\n$$\n\\mathbf{M} \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, \\ddot{q}_j(t) + \\mathbf{C} \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, \\dot{q}_j(t) + \\mathbf{K} \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, q_j(t) = \\mathbf{0}\n$$\nBy the linearity of matrix multiplication, we can write:\n$$\n\\sum_{j=1}^{N} \\left( \\mathbf{M} \\boldsymbol{\\phi}_j \\, \\ddot{q}_j(t) + \\mathbf{C} \\boldsymbol{\\phi}_j \\, \\dot{q}_j(t) + \\mathbf{K} \\boldsymbol{\\phi}_j \\, q_j(t) \\right) = \\mathbf{0}\n$$\nTo isolate the equation for an arbitrary mode $n$, we pre-multiply the entire equation by the transpose of the $n$-th mode shape, $\\boldsymbol{\\phi}_n^T$:\n$$\n\\sum_{j=1}^{N} \\left( \\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_j \\, \\ddot{q}_j(t) + \\boldsymbol{\\phi}_n^T \\mathbf{C} \\boldsymbol{\\phi}_j \\, \\dot{q}_j(t) + \\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_j \\, q_j(t) \\right) = \\mathbf{0}\n$$\nThe mode shapes $\\boldsymbol{\\phi}_n$ of the undamped system possess fundamental orthogonality properties with respect to the mass matrix $\\mathbf{M}$ and the stiffness matrix $\\mathbf{K}$. These are given by:\n$$\n\\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_j = M_n \\delta_{nj}\n$$\n$$\n\\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_j = K_n \\delta_{nj}\n$$\nwhere $\\delta_{nj}$ is the Kronecker delta, $M_n = \\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_n$ is the modal mass, and $K_n = \\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_n$ is the modal stiffness of the $n$-th mode. Due to the Kronecker delta, all terms in the summation vanish except for the case where $j=n$. The system of equations is thus decoupled, and for mode $n$, we have:\n$$\nM_n \\ddot{q}_n(t) + \\left( \\boldsymbol{\\phi}_n^T \\mathbf{C} \\boldsymbol{\\phi}_n \\right) \\dot{q}_n(t) + K_n q_n(t) = 0\n$$\nThe term $C_n = \\boldsymbol{\\phi}_n^T \\mathbf{C} \\boldsymbol{\\phi}_n$ represents the modal damping. Now, we substitute the given expression for Rayleigh damping, $\\mathbf{C} = \\alpha \\mathbf{M} + \\beta \\mathbf{K}$:\n$$\nC_n = \\boldsymbol{\\phi}_n^T (\\alpha \\mathbf{M} + \\beta \\mathbf{K}) \\boldsymbol{\\phi}_n = \\alpha (\\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_n) + \\beta (\\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_n) = \\alpha M_n + \\beta K_n\n$$\nSubstituting this expression for $C_n$ back into the modal equation:\n$$\nM_n \\ddot{q}_n(t) + (\\alpha M_n + \\beta K_n) \\dot{q}_n(t) + K_n q_n(t) = 0\n$$\nTo normalize this equation into a standard form, we divide by the modal mass $M_n$ (which is non-zero since $\\mathbf{M}$ is positive-definite and $\\boldsymbol{\\phi}_n$ is a non-zero vector):\n$$\n\\ddot{q}_n(t) + \\left(\\alpha + \\beta \\frac{K_n}{M_n}\\right) \\dot{q}_n(t) + \\frac{K_n}{M_n} q_n(t) = 0\n$$\nFrom the generalized eigenvalue problem, $\\mathbf{K}\\boldsymbol{\\phi}_n = \\omega_n^2 \\mathbf{M}\\boldsymbol{\\phi}_n$, we pre-multiply by $\\boldsymbol{\\phi}_n^T$ to obtain $\\boldsymbol{\\phi}_n^T \\mathbf{K}\\boldsymbol{\\phi}_n = \\omega_n^2 \\boldsymbol{\\phi}_n^T \\mathbf{M}\\boldsymbol{\\phi}_n$, which is $K_n = \\omega_n^2 M_n$. This gives the crucial relationship:\n$$\n\\frac{K_n}{M_n} = \\omega_n^2\n$$\nSubstituting this into the normalized modal equation, we arrive at the final scalar modal equation for mode $n$:\n$$\n\\ddot{q}_n(t) + (\\alpha + \\beta \\omega_n^2) \\dot{q}_n(t) + \\omega_n^2 q_n(t) = 0\n$$\nThis equation is in the standard form of a damped harmonic oscillator:\n$$\n\\ddot{x}(t) + 2\\zeta_n \\omega_n \\dot{x}(t) + \\omega_n^2 x(t) = 0\n$$\nBy comparing the coefficients of the $\\dot{q}_n(t)$ term, we can identify $2\\zeta_n\\omega_n$:\n$$\n2\\zeta_n \\omega_n = \\alpha + \\beta \\omega_n^2\n$$\nSolving for the damping ratio $\\zeta_n$ for mode $n$:\n$$\n\\zeta_n = \\frac{\\alpha + \\beta \\omega_n^2}{2\\omega_n} = \\frac{\\alpha}{2\\omega_n} + \\frac{\\beta \\omega_n}{2}\n$$\nThe damped natural circular frequency, $\\omega_{d,n}$, is related to the undamped natural frequency $\\omega_n$ and the damping ratio $\\zeta_n$ by the well-known formula for an underdamped oscillator ($\\zeta_n < 1$):\n$$\n\\omega_{d,n} = \\omega_n \\sqrt{1 - \\zeta_n^2}\n$$\nThe problem requires this to be expressed in terms of $\\alpha$, $\\beta$, and $\\omega_n$. We substitute the derived expression for $\\zeta_n$:\n$$\n\\omega_{d,n} = \\omega_n \\sqrt{1 - \\left( \\frac{\\alpha + \\beta \\omega_n^2}{2\\omega_n} \\right)^2}\n$$\nThese are the final expressions for the modal damping ratio and the damped natural circular frequency.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\dfrac{\\alpha}{2\\omega_n} + \\dfrac{\\beta \\omega_n}{2} & \\omega_n \\sqrt{1 - \\left( \\dfrac{\\alpha + \\beta \\omega_n^2}{2\\omega_n} \\right)^2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While modal superposition is powerful for linear systems, direct time integration of the full system of equations is a more general and fundamental approach, applicable to both linear and nonlinear dynamics. In this practice, you will implement the celebrated Newmark-$\\beta$ method, a workhorse algorithm in computational mechanics for solving the dynamic equilibrium equation $\\mathbf{M}\\ddot{\\mathbf{u}} + \\mathbf{C}\\dot{\\mathbf{u}} + \\mathbf{K}\\mathbf{u} = \\mathbf{f}(t)$. Deriving the effective stiffness and load vectors from first principles will provide you with a robust understanding of how implicit time-stepping schemes advance the solution in time .",
            "id": "3519826",
            "problem": "A linear semi-discrete dynamic equilibrium of a geomechanical system with multiple degrees of freedom (DOF) is governed by the second law of motion, stating that the net force equals mass times acceleration. In matrix-vector form, this balance can be written as $\\boldsymbol{M}\\ddot{\\boldsymbol{u}} + \\boldsymbol{C}\\dot{\\boldsymbol{u}} + \\boldsymbol{K}\\boldsymbol{u} = \\boldsymbol{f}(t)$, where $\\boldsymbol{M}$ is the consistent mass matrix (units $\\mathrm{kg}$), $\\boldsymbol{C}$ is the damping matrix (units $\\mathrm{N\\cdot s/m}$), $\\boldsymbol{K}$ is the stiffness matrix (units $\\mathrm{N/m}$), $\\boldsymbol{u}$ is the displacement vector (units $\\mathrm{m}$), $\\dot{\\boldsymbol{u}}$ is the velocity vector (units $\\mathrm{m/s}$), $\\ddot{\\boldsymbol{u}}$ is the acceleration vector (units $\\mathrm{m/s^2}$), and $\\boldsymbol{f}(t)$ is the external force vector (units $\\mathrm{N}$). In computational geomechanics, the Newmark family of time integration schemes is commonly used to advance the solution in time without sacrificing numerical stability for linear systems. You must derive from first principles how to construct a single-step update from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ for the unknown $\\boldsymbol{u}_{n+1}$, $\\dot{\\boldsymbol{u}}_{n+1}$, and $\\ddot{\\boldsymbol{u}}_{n+1}$, starting only from fundamental kinematics and dynamics: Newton’s second law applied to the semi-discrete system and the definitions of velocity and acceleration as time derivatives. Using the general Newmark parameters $\\gamma$ and $\\beta$ and a constant time step $\\Delta t$, derive the discrete linear system that must be solved for $\\boldsymbol{u}_{n+1}$, identify its effective stiffness matrix $\\boldsymbol{K}_{\\mathrm{eff}}$, and derive the corresponding effective load vector $\\boldsymbol{r}_{\\mathrm{eff}}$ that enforces dynamic equilibrium at $t_{n+1}$. After this derivation, implement the resulting algorithm to integrate the system numerically, computing $\\boldsymbol{K}_{\\mathrm{eff}}$ and $\\boldsymbol{r}_{\\mathrm{eff}}$ at each time step and advancing the solution.\n\nYour program must use the following test suite. For all sinusoidal loads, angles must be in radians. Report displacement magnitudes in meters.\n\nTest Suite:\n$1.$ Single-degree-of-freedom (SDOF), undamped, constant load:\n- $\\boldsymbol{M} = [\\,1.0\\,]\\,\\mathrm{kg}$\n- $\\boldsymbol{K} = [\\,400.0\\,]\\,\\mathrm{N/m}$\n- $\\boldsymbol{C} = [\\,0.0\\,]\\,\\mathrm{N\\cdot s/m}$\n- $\\boldsymbol{f}(t) = [\\,100.0\\,]\\,\\mathrm{N}$ for all $t$\n- $\\boldsymbol{u}_0 = [\\,0.0\\,]\\,\\mathrm{m}$, $\\dot{\\boldsymbol{u}}_0 = [\\,0.0\\,]\\,\\mathrm{m/s}$\n- $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.5\\,\\mathrm{s}$, $\\gamma = 0.5$, $\\beta = 0.25$\n\n$2.$ SDOF, viscously damped with specified damping ratio, step load:\n- $\\boldsymbol{M} = [\\,1.5\\,]\\,\\mathrm{kg}$\n- $\\boldsymbol{K} = [\\,600.0\\,]\\,\\mathrm{N/m}$\n- Damping ratio $\\zeta = 0.05$ and viscous damping $\\boldsymbol{C} = [\\,2\\,\\zeta\\,\\sqrt{\\boldsymbol{K}\\boldsymbol{M}}\\,] = [\\,2 \\times 0.05 \\times \\sqrt{600.0 \\times 1.5}\\,]\\,\\mathrm{N\\cdot s/m}$\n- $\\boldsymbol{f}(t) = [\\,150.0\\,]\\,\\mathrm{N}$ for all $t$\n- $\\boldsymbol{u}_0 = [\\,0.0\\,]\\,\\mathrm{m}$, $\\dot{\\boldsymbol{u}}_0 = [\\,0.0\\,]\\,\\mathrm{m/s}$\n- $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.8\\,\\mathrm{s}$, $\\gamma = 0.5$, $\\beta = 0.25$\n\n$3.$ Two-degree-of-freedom (two-DOF), Rayleigh damping, harmonic load on the first DOF:\n- $\\boldsymbol{M} = \\mathrm{diag}([\\,2.0,\\,1.0\\,])\\,\\mathrm{kg}$\n- $\\boldsymbol{K} = \\begin{bmatrix} 600.0 & -200.0 \\\\ -200.0 & 400.0 \\end{bmatrix}\\,\\mathrm{N/m}$\n- Rayleigh damping $\\boldsymbol{C} = \\alpha \\boldsymbol{M} + \\beta_r \\boldsymbol{K}$ with $\\alpha = 0.1\\,\\mathrm{s^{-1}}$ and $\\beta_r = 0.0005\\,\\mathrm{s}$\n- $\\boldsymbol{f}(t) = [\\,50.0 \\sin(15.0\\, t),\\, 0.0\\,]\\,\\mathrm{N}$ for $0 \\le t \\le T$\n- $\\boldsymbol{u}_0 = [\\,0.0,\\,0.0\\,]\\,\\mathrm{m}$, $\\dot{\\boldsymbol{u}}_0 = [\\,0.0,\\,0.0\\,]\\,\\mathrm{m/s}$\n- $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 2.0\\,\\mathrm{s}$, $\\gamma = 0.5$, $\\beta = 0.25$\n\n$4.$ SDOF, critically damped free vibration with nonzero initial velocity:\n- $\\boldsymbol{M} = [\\,1.0\\,]\\,\\mathrm{kg}$\n- $\\boldsymbol{K} = [\\,100.0\\,]\\,\\mathrm{N/m}$\n- Critical viscous damping $\\boldsymbol{C} = [\\,2 \\sqrt{100.0 \\times 1.0}\\,] = [\\,20.0\\,]\\,\\mathrm{N\\cdot s/m}$\n- $\\boldsymbol{f}(t) = [\\,0.0\\,]\\,\\mathrm{N}$ for all $t$\n- $\\boldsymbol{u}_0 = [\\,0.0\\,]\\,\\mathrm{m}$, $\\dot{\\boldsymbol{u}}_0 = [\\,1.0\\,]\\,\\mathrm{m/s}$\n- $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$, $\\gamma = 0.5$, $\\beta = 0.25$\n\nComputation task:\n$1.$ Derive, from the definitions of velocity and acceleration and Newton’s second law, the Newmark update relations and show how substituting them into the dynamic equilibrium at $t_{n+1}$ yields an algebraic system in $\\boldsymbol{u}_{n+1}$ with an effective stiffness $\\boldsymbol{K}_{\\mathrm{eff}}$ and an effective load $\\boldsymbol{r}_{\\mathrm{eff}}$. Clearly identify $\\boldsymbol{K}_{\\mathrm{eff}}$ and $\\boldsymbol{r}_{\\mathrm{eff}}$ in terms of $\\boldsymbol{M}$, $\\boldsymbol{C}$, $\\boldsymbol{K}$, $\\Delta t$, $\\gamma$, $\\beta$, and the known states at $t_n$.\n$2.$ Implement the resulting single-step algorithm to integrate from $t = 0$ to $t = T$ for each test case. At each step, form $\\boldsymbol{K}_{\\mathrm{eff}}$ and $\\boldsymbol{r}_{\\mathrm{eff}}$, solve for $\\boldsymbol{u}_{n+1}$, then recover $\\ddot{\\boldsymbol{u}}_{n+1}$ and $\\dot{\\boldsymbol{u}}_{n+1}$.\n$3.$ For each test case, output the Euclidean norm of the final displacement vector $\\lVert \\boldsymbol{u}(T) \\rVert_2$ in meters, rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example `[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]`, where each entry is a float representing $\\lVert \\boldsymbol{u}(T) \\rVert_2$ in $\\mathrm{m}$, rounded to six decimal places.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of classical mechanics and numerical analysis, specifically concerning the dynamic analysis of structures. The problem is well-posed, providing all necessary matrices, initial conditions, and parameters for the Newmark time integration scheme. The language is objective and the requirements are formalizable into a computational algorithm.\n\nThe derivation and implementation proceed as follows.\n\n### Part 1: Derivation of the Newmark Integration Scheme\n\nThe fundamental equation governing the dynamic equilibrium of a semi-discretized linear system is Newton's second law, expressed in matrix form:\n$$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}(t) + \\boldsymbol{C}\\dot{\\boldsymbol{u}}(t) + \\boldsymbol{K}\\boldsymbol{u}(t) = \\boldsymbol{f}(t) $$\nwhere $\\boldsymbol{M}$, $\\boldsymbol{C}$, and $\\boldsymbol{K}$ are the mass, damping, and stiffness matrices, respectively. The vectors $\\boldsymbol{u}$, $\\dot{\\boldsymbol{u}}$, and $\\ddot{\\boldsymbol{u}}$ represent displacement, velocity, and acceleration, and $\\boldsymbol{f}(t)$ is the external force vector.\n\nThe Newmark family of methods provides a way to approximate the state of the system at time $t_{n+1} = t_n + \\Delta t$ based on its state at time $t_n$. The core of the method lies in two kinematic assumptions that relate displacement, velocity, and acceleration across a time step $\\Delta t$:\n$$ \\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + (1 - \\gamma) \\Delta t \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\ddot{\\boldsymbol{u}}_{n+1} \\quad (1) $$\n$$ \\boldsymbol{u}_{n+1} = \\boldsymbol{u}_n + \\Delta t \\dot{\\boldsymbol{u}}_n + \\frac{(\\Delta t)^2}{2} \\left[ (1 - 2\\beta) \\ddot{\\boldsymbol{u}}_n + 2\\beta \\ddot{\\boldsymbol{u}}_{n+1} \\right] \\quad (2) $$\nHere, $\\gamma$ and $\\beta$ are the Newmark integration parameters that control the accuracy and stability of the method. The state variables $(\\boldsymbol{u}_n, \\dot{\\boldsymbol{u}}_n, \\ddot{\\boldsymbol{u}}_n)$ at time $t_n$ are known. The goal is to find the state variables $(\\boldsymbol{u}_{n+1}, \\dot{\\boldsymbol{u}}_{n+1}, \\ddot{\\boldsymbol{u}}_{n+1})$ at time $t_{n+1}$.\n\nThe primary unknown in an implicit scheme is the displacement at the next time step, $\\boldsymbol{u}_{n+1}$. To solve for it, we must express $\\dot{\\boldsymbol{u}}_{n+1}$ and $\\ddot{\\boldsymbol{u}}_{n+1}$ in terms of $\\boldsymbol{u}_{n+1}$ and known quantities from step $n$.\n\nFirst, we rearrange Equation $(2)$ to solve for the acceleration at time $t_{n+1}$, $\\ddot{\\boldsymbol{u}}_{n+1}$:\n$$ 2\\beta \\frac{(\\Delta t)^2}{2} \\ddot{\\boldsymbol{u}}_{n+1} = \\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n - \\Delta t \\dot{\\boldsymbol{u}}_n - (1 - 2\\beta) \\frac{(\\Delta t)^2}{2} \\ddot{\\boldsymbol{u}}_n $$\n$$ \\beta (\\Delta t)^2 \\ddot{\\boldsymbol{u}}_{n+1} = \\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n - \\Delta t \\dot{\\boldsymbol{u}}_n - (\\frac{1}{2} - \\beta)(\\Delta t)^2 \\ddot{\\boldsymbol{u}}_n $$\nIsolating $\\ddot{\\boldsymbol{u}}_{n+1}$ yields:\n$$ \\ddot{\\boldsymbol{u}}_{n+1} = \\frac{1}{\\beta (\\Delta t)^2} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - \\frac{1}{\\beta \\Delta t} \\dot{\\boldsymbol{u}}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{\\boldsymbol{u}}_n \\quad (3) $$\n\nNext, substitute this expression for $\\ddot{\\boldsymbol{u}}_{n+1}$ into Equation $(1)$ to find $\\dot{\\boldsymbol{u}}_{n+1}$ in terms of $\\boldsymbol{u}_{n+1}$:\n$$ \\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + (1 - \\gamma) \\Delta t \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta (\\Delta t)^2} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - \\frac{1}{\\beta \\Delta t} \\dot{\\boldsymbol{u}}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{\\boldsymbol{u}}_n \\right] $$\n$$ \\dot{\\boldsymbol{u}}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right) \\dot{\\boldsymbol{u}}_n + \\Delta t \\left(1 - \\gamma - \\gamma\\left(\\frac{1}{2\\beta} - 1\\right)\\right) \\ddot{\\boldsymbol{u}}_n $$\nA simpler approach is to substitute equations (3) and (1) into the equation of motion at time $t_{n+1}$:\n$$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}_{n+1} + \\boldsymbol{C}\\dot{\\boldsymbol{u}}_{n+1} + \\boldsymbol{K}\\boldsymbol{u}_{n+1} = \\boldsymbol{f}_{n+1} $$\nLet's group the terms involving the primary unknown $\\boldsymbol{u}_{n+1}$. We first express $\\ddot{\\boldsymbol{u}}_{n+1}$ and $\\dot{\\boldsymbol{u}}_{n+1}$ in terms of $\\boldsymbol{u}_{n+1}$ and known quantities at step $n$.\n$$ \\boldsymbol{M}\\left( \\frac{1}{\\beta (\\Delta t)^2} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - \\frac{1}{\\beta \\Delta t} \\dot{\\boldsymbol{u}}_n - a_3 \\ddot{\\boldsymbol{u}}_n \\right) + \\boldsymbol{C}\\left( \\frac{\\gamma}{\\beta \\Delta t} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) + a_4\\dot{\\boldsymbol{u}}_n + a_5\\ddot{\\boldsymbol{u}}_n \\right) + \\boldsymbol{K}\\boldsymbol{u}_{n+1} = \\boldsymbol{f}_{n+1} $$\nwhere $a_3=\\frac{1}{2\\beta} - 1$, $a_4=1-\\frac{\\gamma}{\\beta}$, and $a_5 = \\Delta t(1 - \\gamma - \\frac{\\gamma}{2\\beta} + \\gamma) = \\Delta t (1 - \\frac{\\gamma}{2\\beta})$.\nGrouping terms multiplying $\\boldsymbol{u}_{n+1}$ on the left-hand side (LHS):\n$$ \\left( \\frac{1}{\\beta (\\Delta t)^2}\\boldsymbol{M} + \\frac{\\gamma}{\\beta \\Delta t}\\boldsymbol{C} + \\boldsymbol{K} \\right) \\boldsymbol{u}_{n+1} = \\dots $$\nThis identifies the effective stiffness matrix $\\boldsymbol{K}_{\\mathrm{eff}}$:\n$$ \\boldsymbol{K}_{\\mathrm{eff}} = \\boldsymbol{K} + \\frac{\\gamma}{\\beta \\Delta t} \\boldsymbol{C} + \\frac{1}{\\beta (\\Delta t)^2} \\boldsymbol{M} $$\nNow, we collect all other terms on the right-hand side (RHS) to form the effective load vector $\\boldsymbol{r}_{\\mathrm{eff}}$. Using slightly different (but equivalent) standard constants for clarity:\n$a_0 = \\frac{1}{\\beta (\\Delta t)^2}$, $a_1 = \\frac{\\gamma}{\\beta \\Delta t}$, $a_2 = \\frac{1}{\\beta \\Delta t}$, $a_3=\\frac{1}{2\\beta}-1$, $a_4=\\frac{\\gamma}{\\beta}-1$, $a_5=\\frac{\\Delta t}{2}(\\frac{\\gamma}{\\beta}-2)$.\n$$ \\boldsymbol{r}_{\\mathrm{eff}} = \\boldsymbol{f}_{n+1} + \\boldsymbol{M}(a_0 \\boldsymbol{u}_n + a_2 \\dot{\\boldsymbol{u}}_n + a_3 \\ddot{\\boldsymbol{u}}_n) + \\boldsymbol{C}(a_1 \\boldsymbol{u}_n + a_4 \\dot{\\boldsymbol{u}}_n + a_5 \\ddot{\\boldsymbol{u}}_n) $$\nThe final algebraic system to be solved at each time step is:\n$$ \\boldsymbol{K}_{\\mathrm{eff}} \\boldsymbol{u}_{n+1} = \\boldsymbol{r}_{\\mathrm{eff}} $$\n\n### Part 2: Algorithmic Procedure\n\nThe numerical integration proceeds as follows:\n1.  **Initialization ($n=0$)**:\n    a. Given initial conditions $\\boldsymbol{u}_0$ and $\\dot{\\boldsymbol{u}}_0$.\n    b. Solve for the initial acceleration $\\ddot{\\boldsymbol{u}}_0$ from the equation of motion at $t=0$:\n       $$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}_0 = \\boldsymbol{f}(0) - \\boldsymbol{C}\\dot{\\boldsymbol{u}}_0 - \\boldsymbol{K}\\boldsymbol{u}_0 $$\n2.  **Time-stepping loop (for $n = 0, 1, 2, \\dots, N-1$ where $N = T/\\Delta t$)**:\n    a. Calculate the effective stiffness matrix, which is constant for a linear system with constant $\\Delta t$:\n       $$ \\boldsymbol{K}_{\\mathrm{eff}} = \\boldsymbol{K} + \\frac{\\gamma}{\\beta \\Delta t} \\boldsymbol{C} + \\frac{1}{\\beta (\\Delta t)^2} \\boldsymbol{M} $$\n    b. Calculate the effective load vector at time $t_{n+1}$ using the known state at $t_n$:\n       $$ \\boldsymbol{r}_{\\mathrm{eff}} = \\boldsymbol{f}_{n+1} + \\boldsymbol{M}(a_0 \\boldsymbol{u}_n + a_2 \\dot{\\boldsymbol{u}}_n + a_3 \\ddot{\\boldsymbol{u}}_n) + \\boldsymbol{C}(a_1 \\boldsymbol{u}_n + a_4 \\dot{\\boldsymbol{u}}_n + a_5 \\ddot{\\boldsymbol{u}}_n) $$\n       with constants defined as: $a_0 = \\frac{1}{\\beta (\\Delta t)^2}$, $a_1 = \\frac{\\gamma}{\\beta \\Delta t}$, $a_2 = \\frac{1}{\\beta \\Delta t}$, $a_3=\\frac{1}{2\\beta}-1$, $a_4=\\frac{\\gamma}{\\beta}-1$, $a_5=\\frac{\\Delta t}{2}(\\frac{\\gamma}{\\beta}-2)$.\n    c. Solve the linear system for the displacement at the next time step:\n       $$ \\boldsymbol{u}_{n+1} = \\boldsymbol{K}_{\\mathrm{eff}}^{-1} \\boldsymbol{r}_{\\mathrm{eff}} $$\n    d. Update the acceleration and velocity for time $t_{n+1}$:\n       $$ \\ddot{\\boldsymbol{u}}_{n+1} = a_0 (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - a_2 \\dot{\\boldsymbol{u}}_n - a_3 \\ddot{\\boldsymbol{u}}_n $$\n       $$ \\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + (1 - \\gamma)\\Delta t \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\ddot{\\boldsymbol{u}}_{n+1} $$\n3.  **Final Result**: After the loop completes, the final displacement vector is $\\boldsymbol{u}_{N}$. The required output is its Euclidean norm, $\\lVert \\boldsymbol{u}_N \\rVert_2$. The provided test cases use $\\gamma=0.5$ and $\\beta=0.25$, which corresponds to the constant average acceleration method, an unconditionally stable scheme for linear systems.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef integrate_newmark(M, C, K, f_func, u0, u_dot0, dt, T, gamma, beta):\n    \"\"\"\n    Integrates a linear dynamic system using the Newmark-beta method.\n\n    Args:\n        M (np.ndarray): Mass matrix.\n        C (np.ndarray): Damping matrix.\n        K (np.ndarray): Stiffness matrix.\n        f_func (callable): Function of time t that returns the force vector f(t).\n        u0 (np.ndarray): Initial displacement vector.\n        u_dot0 (np.ndarray): Initial velocity vector.\n        dt (float): Time step.\n        T (float): Total integration time.\n        gamma (float): Newmark parameter.\n        beta (float): Newmark parameter.\n\n    Returns:\n        np.ndarray: The final displacement vector u(T).\n    \"\"\"\n    num_steps = int(round(T / dt))\n    \n    # Initialize state vectors\n    u = u0.copy()\n    u_dot = u_dot0.copy()\n    \n    # Calculate initial acceleration: M*u_ddot_0 = f(0) - C*u_dot_0 - K*u_0\n    f0 = f_func(0.0)\n    try:\n        u_ddot = np.linalg.solve(M, f0 - C @ u_dot - K @ u)\n    except np.linalg.LinAlgError:\n        # Handle singular mass matrix (though not in test cases)\n        # Or if M is scalar for SDOF\n        if M.shape == (1, 1):\n             u_ddot = (f0 - C @ u_dot - K @ u) / M[0, 0]\n        else:\n            raise\n\n    # Newmark constants based on the derived effective system\n    a0 = 1.0 / (beta * dt**2)\n    a1 = gamma / (beta * dt)\n    a2 = 1.0 / (beta * dt)\n    a3 = 1.0 / (2.0 * beta) - 1.0\n    a4 = gamma / beta - 1.0\n    a5 = dt / 2.0 * (gamma / beta - 2.0)\n    a6 = dt * (1.0 - gamma)\n    a7 = dt * gamma\n    \n    # Form effective stiffness matrix (constant for linear problems)\n    K_eff = K + a1 * C + a0 * M\n    \n    # Time stepping loop\n    for n in range(num_steps):\n        t_next = (n + 1) * dt\n        \n        # Form effective load vector\n        f_next = f_func(t_next)\n        r_eff = f_next + M @ (a0 * u + a2 * u_dot + a3 * u_ddot) + \\\n                      C @ (a1 * u + a4 * u_dot + a5 * u_ddot)\n        \n        # Solve for displacement at t_{n+1}\n        u_next = np.linalg.solve(K_eff, r_eff)\n        \n        # Update acceleration and velocity at t_{n+1}\n        u_ddot_next = a0 * (u_next - u) - a2 * u_dot - a3 * u_ddot\n        u_dot_next = u_dot + a6 * u_ddot + a7 * u_ddot_next\n        \n        # Update state for the next iteration\n        u = u_next\n        u_dot = u_dot_next\n        u_ddot = u_ddot_next\n        \n    return u\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"M\": np.array([[1.0]]),\n            \"K\": np.array([[400.0]]),\n            \"C\": np.array([[0.0]]),\n            \"f_func\": lambda t: np.array([100.0]),\n            \"u0\": np.array([0.0]),\n            \"u_dot0\": np.array([0.0]),\n            \"dt\": 0.001, \"T\": 0.5, \"gamma\": 0.5, \"beta\": 0.25\n        },\n        {\n            \"M\": np.array([[1.5]]),\n            \"K\": np.array([[600.0]]),\n            \"C\": np.array([[2.0 * 0.05 * np.sqrt(600.0 * 1.5)]]),\n            \"f_func\": lambda t: np.array([150.0]),\n            \"u0\": np.array([0.0]),\n            \"u_dot0\": np.array([0.0]),\n            \"dt\": 0.001, \"T\": 0.8, \"gamma\": 0.5, \"beta\": 0.25\n        },\n        {\n            \"M\": np.diag([2.0, 1.0]),\n            \"K\": np.array([[600.0, -200.0], [-200.0, 400.0]]),\n            \"C\": 0.1 * np.diag([2.0, 1.0]) + 0.0005 * np.array([[600.0, -200.0], [-200.0, 400.0]]),\n            \"f_func\": lambda t: np.array([50.0 * np.sin(15.0 * t), 0.0]),\n            \"u0\": np.array([0.0, 0.0]),\n            \"u_dot0\": np.array([0.0, 0.0]),\n            \"dt\": 0.001, \"T\": 2.0, \"gamma\": 0.5, \"beta\": 0.25\n        },\n        {\n            \"M\": np.array([[1.0]]),\n            \"K\": np.array([[100.0]]),\n            \"C\": np.array([[2.0 * np.sqrt(100.0 * 1.0)]]),\n            \"f_func\": lambda t: np.array([0.0]),\n            \"u0\": np.array([0.0]),\n            \"u_dot0\": np.array([1.0]),\n            \"dt\": 0.001, \"T\": 1.0, \"gamma\": 0.5, \"beta\": 0.25\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        u_final = integrate_newmark(\n            M=case[\"M\"],\n            C=case[\"C\"],\n            K=case[\"K\"],\n            f_func=case[\"f_func\"],\n            u0=case[\"u0\"],\n            u_dot0=case[\"u_dot0\"],\n            dt=case[\"dt\"],\n            T=case[\"T\"],\n            gamma=case[\"gamma\"],\n            beta=case[\"beta\"]\n        )\n        \n        norm_u_final = np.linalg.norm(u_final)\n        results.append(f\"{norm_u_final:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The predictions of a finite element model are not just dependent on the underlying physics, but also on numerical formulation choices. This advanced computational practice explores the subtle but important distinction between a consistent mass matrix and a lumped mass matrix, focusing on their influence on high-frequency modal properties. By conducting a numerical experiment, you will discover how this choice interacts with the Rayleigh damping model to affect the damping of high-frequency modes, which are often critical for accurately predicting peak accelerations in transient analyses .",
            "id": "3519874",
            "problem": "You are to study the influence of mass matrix choice on high-frequency modal damping in a three-dimensional basin idealized for anti-plane shear (scalar displacement) dynamics. Use the dynamic equilibrium of a linear elastic discretized system, given by the second-order ordinary differential equation $\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}$ with Rayleigh damping $\\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K}$, where $\\mathbf{M}$ is the mass matrix, $\\mathbf{K}$ is the stiffness matrix, $\\alpha$ is the mass-proportional damping coefficient, and $\\beta$ is the stiffness-proportional damping coefficient. Assume small deformations and linear material response.\n\nConstruct $\\mathbf{M}$ and $\\mathbf{K}$ for a regular hexahedral grid that represents a $3$-D basin with scalar displacement $u$ (anti-plane shear). Let the domain be discretized into $n_x \\times n_y \\times n_z$ trilinear hexahedral elements of uniform size $h \\times h \\times h$, with nodal degrees of freedom located at the grid vertices. Adopt free surfaces on all faces except the base; impose homogeneous Dirichlet boundary conditions $u=0$ on the base plane $z=0$. The material properties are uniform: constant mass density $\\rho$ (in $\\mathrm{kg/m^3}$) and constant shear modulus $G$ (in $\\mathrm{Pa}$).\n\nDefine the two alternative mass matrices:\n- The consistent mass matrix $\\mathbf{M}_{\\mathrm{con}}$ is assembled from element-wise $8 \\times 8$ consistent mass matrices for trilinear hexahedra for a scalar field. For a single element of volume $V = h^3$, the element mass matrix is $\\mathbf{M}_e = \\rho \\int_{\\Omega_e} \\mathbf{N}^\\top \\mathbf{N}\\,\\mathrm{d}\\Omega$. On an affine mapping of the reference cube $[-1,1]^3$, this equals $\\mathbf{M}_e = \\rho\\,\\dfrac{V}{8}\\,\\mathbf{E}$, where the $(i,j)$ entry of $\\mathbf{E}$ is $E_{ij} = \\prod_{d \\in \\{x,y,z\\}} I_d(i,j)$ with the one-dimensional integrals $I_d(i,j) \\in \\{\\,\\frac{2}{3},\\,\\frac{1}{3}\\,\\}$ depending on whether the local node indices $i$ and $j$ coincide or differ in coordinate $d$, respectively. Equivalently, if $m$ is the number of coordinates in which the local indices $i$ and $j$ match, then $E_{ij} = \\left(\\frac{2}{3}\\right)^{m}\\left(\\frac{1}{3}\\right)^{3-m}$.\n- The lumped mass matrix $\\mathbf{M}_{\\mathrm{lmp}}$ is diagonal and assembled by allocating to each node one eighth of the element mass, that is, an element-wise diagonal contribution of $\\rho\\,V/8$ to each of its $8$ nodes.\n\nDefine the stiffness matrix $\\mathbf{K}$ by assembling nearest-neighbor axial springs on the nodal graph that connect adjacent nodes along the $x$-, $y$-, and $z$-directions. For a pair of neighboring nodes separated by distance $h$ along direction $d \\in \\{x,y,z\\}$, use the linear spring stiffness $k_d = G\\,A_d/L_d$ with $A_x = A_y = A_z = h^2$ and $L_x = L_y = L_z = h$, so $k_x = k_y = k_z = G\\,h$. Each spring contributes $k\\begin{bmatrix}1 & -1\\\\ -1 & 1\\end{bmatrix}$ to the corresponding $2 \\times 2$ submatrix of $\\mathbf{K}$. Apply the base boundary condition by eliminating the degrees of freedom on the $z=0$ plane.\n\nFor vibrations with no external forcing, consider the generalized eigenvalue problem $\\mathbf{K}\\,\\boldsymbol{\\phi}_i = \\omega_i^2\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_i$, where $\\omega_i > 0$ are the natural circular frequencies (in $\\mathrm{rad/s}$) and $\\boldsymbol{\\phi}_i$ are the mass-normalized modes. From the Rayleigh damping model, each mode experiences a scalar, effective modal damping ratio $\\xi_i$ that depends on $\\alpha$, $\\beta$, and $\\omega_i$. You must determine this $\\xi_i$ from first principles.\n\nFocus on the highest-frequency mode (the mode with the largest $\\omega_i$), as such modes are known to influence peak accelerations in transient responses. For each test case, compute two numbers:\n- $\\xi_{\\max}^{\\mathrm{con}}$: the effective modal damping ratio of the highest-frequency mode when using $\\mathbf{M}=\\mathbf{M}_{\\mathrm{con}}$,\n- $\\xi_{\\max}^{\\mathrm{lmp}}$: the effective modal damping ratio of the highest-frequency mode when using $\\mathbf{M}=\\mathbf{M}_{\\mathrm{lmp}}$,\n\nand then compute the relative difference\n$$\n\\Delta = \\frac{\\xi_{\\max}^{\\mathrm{lmp}} - \\xi_{\\max}^{\\mathrm{con}}}{\\xi_{\\max}^{\\mathrm{con}}}\\,,\n$$\nreported as a dimensionless decimal (no units). All intermediate physical quantities must be handled in the International System of Units: lengths in $\\mathrm{m}$, density in $\\mathrm{kg/m^3}$, shear modulus in $\\mathrm{Pa}$, $\\alpha$ in $\\mathrm{s^{-1}}$, $\\beta$ in $\\mathrm{s}$, angular frequencies in $\\mathrm{rad/s}$. The final outputs are the $\\Delta$ values for the following test suite of parameters:\n\n- Test $1$ (baseline mixed Rayleigh damping): $n_x=2$, $n_y=2$, $n_z=2$, $h=50\\,\\mathrm{m}$, $\\rho=2000\\,\\mathrm{kg/m^3}$, $G=1.0\\times 10^{8}\\,\\mathrm{Pa}$, $\\alpha=0.5\\,\\mathrm{s^{-1}}$, $\\beta=5.0\\times 10^{-4}\\,\\mathrm{s}$.\n- Test $2$ (mass-proportional damping only): $n_x=2$, $n_y=2$, $n_z=2$, $h=50\\,\\mathrm{m}$, $\\rho=2000\\,\\mathrm{kg/m^3}$, $G=1.0\\times 10^{8}\\,\\mathrm{Pa}$, $\\alpha=5.0\\,\\mathrm{s^{-1}}$, $\\beta=0.0\\,\\mathrm{s}$.\n- Test $3$ (stiffness-proportional damping only): $n_x=2$, $n_y=2$, $n_z=2$, $h=50\\,\\mathrm{m}$, $\\rho=2000\\,\\mathrm{kg/m^3}$, $G=1.0\\times 10^{8}\\,\\mathrm{Pa}$, $\\alpha=0.0\\,\\mathrm{s^{-1}}$, $\\beta=2.0\\times 10^{-3}\\,\\mathrm{s}$.\n- Test $4$ (larger grid, mixed Rayleigh damping): $n_x=3$, $n_y=3$, $n_z=2$, $h=40\\,\\mathrm{m}$, $\\rho=1800\\,\\mathrm{kg/m^3}$, $G=8.0\\times 10^{7}\\,\\mathrm{Pa}$, $\\alpha=0.2\\,\\mathrm{s^{-1}}$, $\\beta=1.0\\times 10^{-3}\\,\\mathrm{s}$.\n\nYour program must:\n- Assemble $\\mathbf{K}$ once for the grid and material parameters of each test,\n- Assemble both $\\mathbf{M}_{\\mathrm{con}}$ and $\\mathbf{M}_{\\mathrm{lmp}}$ for the same grid and material parameters,\n- Apply the boundary conditions by elimination of constrained degrees of freedom at $z=0$,\n- Solve the generalized eigenvalue problem for each mass choice to obtain the set of positive $\\omega_i$ and identify $\\omega_{\\max}$,\n- Determine the effective modal damping ratio $\\xi_{\\max}$ for $\\omega_{\\max}$ under Rayleigh damping,\n- Compute $\\Delta$ as defined above.\n\nFinal output format: Your program should produce a single line of output containing the results for the four tests as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $4$, for example `[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]`. Each $\\Delta$ must be a floating-point decimal number.",
            "solution": "The problem statement has been critically validated and is deemed to be sound, well-posed, and computationally tractable. It is based on established principles of computational mechanics and structural dynamics, provides a complete set of parameters and definitions, and requests a verifiable numerical outcome.\n\nThe solution proceeds as follows: First, we establish the theoretical relationship between the Rayleigh damping model and the effective modal damping ratio. Second, we detail the numerical procedures for constructing the stiffness and mass matrices. Third, we outline the process for solving the generalized eigenvalue problem and computing the final requested quantity, the relative difference in damping ratios for the highest-frequency mode.\n\n**1. Modal Damping Ratio with Rayleigh Damping**\n\nThe governing equation for the dynamic equilibrium of the discretized system is given by:\n$$ \\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0} $$\nwhere $\\mathbf{M}$ is the mass matrix, $\\mathbf{C}$ is the damping matrix, $\\mathbf{K}$ is the stiffness matrix, and $\\mathbf{u}(t)$ is the vector of nodal displacements. The Rayleigh damping model defines the damping matrix as a linear combination of the mass and stiffness matrices:\n$$ \\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K} $$\nwhere $\\alpha$ and $\\beta$ are scalar coefficients.\n\nTo analyze the system's response, we employ modal analysis. The undamped free-vibration characteristics are found by solving the generalized eigenvalue problem:\n$$ \\mathbf{K}\\,\\boldsymbol{\\phi}_i = \\omega_i^2\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_i $$\nHere, $\\omega_i$ are the natural circular frequencies and $\\boldsymbol{\\phi}_i$ are the corresponding mode shape vectors. The mode shapes possess the crucial properties of orthogonality with respect to both the mass and stiffness matrices. For mass-normalized eigenvectors ($\\boldsymbol{\\phi}_i^\\top \\mathbf{M} \\boldsymbol{\\phi}_i = 1$), these properties are:\n$$ \\boldsymbol{\\phi}_j^\\top \\mathbf{M} \\boldsymbol{\\phi}_i = \\delta_{ij} $$\n$$ \\boldsymbol{\\phi}_j^\\top \\mathbf{K} \\boldsymbol{\\phi}_i = \\omega_i^2 \\delta_{ij} $$\nwhere $\\delta_{ij}$ is the Kronecker delta.\n\nAssuming the damping matrix $\\mathbf{C}$ satisfies the orthogonality condition (which Rayleigh damping does), the system of coupled equations can be transformed into a set of uncoupled single-degree-of-freedom (SDOF) equations in modal coordinates $q_i(t)$, where $\\mathbf{u}(t) = \\sum_i \\boldsymbol{\\phi}_i q_i(t)$. The SDOF equation for the $i$-th mode is:\n$$ \\ddot{q}_i(t) + 2\\xi_i\\omega_i \\dot{q}_i(t) + \\omega_i^2 q_i(t) = 0 $$\nThe term $2\\xi_i\\omega_i$ is the modal damping coefficient, obtained by projecting the damping matrix onto the modal basis:\n$$ 2\\xi_i\\omega_i = \\boldsymbol{\\phi}_i^\\top \\mathbf{C} \\boldsymbol{\\phi}_i = \\boldsymbol{\\phi}_i^\\top (\\alpha\\mathbf{M} + \\beta\\mathbf{K}) \\boldsymbol{\\phi}_i = \\alpha(\\boldsymbol{\\phi}_i^\\top \\mathbf{M} \\boldsymbol{\\phi}_i) + \\beta(\\boldsymbol{\\phi}_i^\\top \\mathbf{K} \\boldsymbol{\\phi}_i) $$\nUsing the orthogonality relations for mass-normalized modes, this simplifies to:\n$$ 2\\xi_i\\omega_i = \\alpha(1) + \\beta(\\omega_i^2) = \\alpha + \\beta\\omega_i^2 $$\nSolving for the effective modal damping ratio, $\\xi_i$, we obtain the fundamental relationship for this problem:\n$$ \\xi_i = \\frac{\\alpha}{2\\omega_i} + \\frac{\\beta\\omega_i}{2} $$\nThis equation shows that the damping ratio for each mode depends on its natural frequency $\\omega_i$ and the Rayleigh coefficients $\\alpha$ and $\\beta$.\n\n**2. Matrix Assembly and System Formulation**\n\nThe domain is a regular grid of $n_x \\times n_y \\times n_z$ hexahedral elements. The total number of nodes is $(n_x+1)(n_y+1)(n_z+1)$. Each node has a single scalar degree of freedom (DOF), $u$. A global node index is assigned to each grid point $(i,j,k)$, where $i \\in [0, n_x]$, $j \\in [0, n_y]$, and $k \\in [0, n_z]$.\n\nThe boundary condition $u=0$ on the base plane $z=0$ (corresponding to $k=0$) is imposed by static condensation. The system matrices are first assembled for all DOFs and then reduced by retaining only the rows and columns corresponding to the free DOFs (where $k > 0$).\n\n**Stiffness Matrix ($\\mathbf{K}$):**\nThe stiffness matrix is constructed based on a finite difference-like model where adjacent nodes are connected by linear springs. The stiffness of a spring connecting two nodes separated by a distance $h$ is given as $k = G A/L = G h^2/h = Gh$. For any two adjacent nodes with global indices $p$ and $q$, the spring contributes a $2 \\times 2$ matrix $Gh \\begin{psmallmatrix} 1 & -1 \\\\ -1 & 1 \\end{psmallmatrix}$ to the locations $(p,p)$, $(p,q)$, $(q,p)$, and $(q,q)$ of the global stiffness matrix $\\mathbf{K}$. This assembly is performed by iterating over all interior grid lines in the $x, y,$ and $z$ directions.\n\n**Mass Matrices ($\\mathbf{M}_{\\mathrm{lmp}}$ and $\\mathbf{M}_{\\mathrm{con}}$):**\nBoth mass matrices are assembled by summing contributions from each of the $n_x n_y n_z$ elements.\n\n- **Lumped Mass Matrix ($\\mathbf{M}_{\\mathrm{lmp}}$):** This is a diagonal matrix. For each element of volume $V = h^3$, its total mass $\\rho V$ is distributed equally among its $8$ nodes. Thus, each of the $8$ nodes receives a mass contribution of $\\rho h^3 / 8$, which is added to the corresponding diagonal entry of the global matrix $\\mathbf{M}_{\\mathrm{lmp}}$.\n\n- **Consistent Mass Matrix ($\\mathbf{M}_{\\mathrm{con}}$):** This is a non-diagonal, or full, mass matrix that reflects the kinematic coupling assumed by the element's shape functions. The element consistent mass matrix, $\\mathbf{M}_e$, is an $8 \\times 8$ matrix. Its entries are given by the formula:\n$$ (\\mathbf{M}_e)_{pq} = \\rho \\frac{h^3}{8} \\left(\\frac{2}{3}\\right)^{m} \\left(\\frac{1}{3}\\right)^{3-m} $$\nwhere $p$ and $q$ are local node indices (from $0$ to $7$), and $m$ is the number of local Cartesian coordinates ($x, y, z$) that are identical for nodes $p$ and $q$. For example, if $p$ and $q$ are the same node, $m=3$; if they are adjacent along an edge, $m=2$; if they are on the same face but diagonally opposite, $m=1$; and if they are at opposite corners of the hexahedron, $m=0$. These element matrices are assembled into the global matrix $\\mathbf{M}_{\\mathrm{con}}$.\n\n**3. Numerical Solution Procedure**\n\nFor each test case defined in the problem, the following steps are executed:\n1.  Define grid parameters ($n_x, n_y, n_z$) and material/damping properties ($h, \\rho, G, \\alpha, \\beta$).\n2.  Construct the global stiffness matrix $\\mathbf{K}$ and the two global mass matrices, $\\mathbf{M}_{\\mathrm{lmp}}$ and $\\mathbf{M}_{\\mathrm{con}}$. These are initially created as sparse matrices for efficiency.\n3.  Identify the indices of the free DOFs (nodes with $k>0$).\n4.  Extract the reduced matrices $\\mathbf{K}_{\\mathrm{red}}$, $\\mathbf{M}_{\\mathrm{lmp,red}}$, and $\\mathbf{M}_{\\mathrm{con,red}}$ by slicing the global matrices with the free DOF indices.\n5.  Solve the two separate generalized eigenvalue problems:\n    - $\\mathbf{K}_{\\mathrm{red}}\\,\\boldsymbol{\\phi} = \\lambda^{\\mathrm{con}}\\,\\mathbf{M}_{\\mathrm{con,red}}\\,\\boldsymbol{\\phi}$\n    - $\\mathbf{K}_{\\mathrm{red}}\\,\\boldsymbol{\\phi} = \\lambda^{\\mathrm{lmp}}\\,\\mathbf{M}_{\\mathrm{lmp,red}}\\,\\boldsymbol{\\phi}$\n    where $\\lambda = \\omega^2$. We use a numerical solver optimized for symmetric matrices (`scipy.linalg.eigh`).\n6.  From the resulting sets of eigenvalues, identify the maximum value in each case, $\\lambda_{\\max}^{\\mathrm{con}}$ and $\\lambda_{\\max}^{\\mathrm{lmp}}$.\n7.  Calculate the corresponding highest natural frequencies: $\\omega_{\\max}^{\\mathrm{con}} = \\sqrt{\\lambda_{\\max}^{\\mathrm{con}}}$ and $\\omega_{\\max}^{\\mathrm{lmp}} = \\sqrt{\\lambda_{\\max}^{\\mathrm{lmp}}}$.\n8.  Use the derived formula for $\\xi_i$ to compute the damping ratios for these highest-frequency modes:\n    - $\\xi_{\\max}^{\\mathrm{con}} = \\dfrac{\\alpha}{2\\omega_{\\max}^{\\mathrm{con}}} + \\dfrac{\\beta\\omega_{\\max}^{\\mathrm{con}}}{2}$\n    - $\\xi_{\\max}^{\\mathrm{lmp}} = \\dfrac{\\alpha}{2\\omega_{\\max}^{\\mathrm{lmp}}} + \\dfrac{\\beta\\omega_{\\max}^{\\mathrm{lmp}}}{2}$\n9.  Finally, calculate the relative difference $\\Delta$:\n    $$ \\Delta = \\frac{\\xi_{\\max}^{\\mathrm{lmp}} - \\xi_{\\max}^{\\mathrm{con}}}{\\xi_{\\max}^{\\mathrm{con}}} $$\nThis procedure is repeated for all four test cases, and the results are collected.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.sparse import lil_matrix\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1 (baseline)\n        (2, 2, 2, 50.0, 2000.0, 1.0e8, 0.5, 5.0e-4),\n        # Test 2 (mass-proportional)\n        (2, 2, 2, 50.0, 2000.0, 1.0e8, 5.0, 0.0),\n        # Test 3 (stiffness-proportional)\n        (2, 2, 2, 50.0, 2000.0, 1.0e8, 0.0, 2.0e-3),\n        # Test 4 (larger grid)\n        (3, 3, 2, 40.0, 1800.0, 8.0e7, 0.2, 1.0e-3),\n    ]\n\n    results = []\n    for params in test_cases:\n        delta = calculate_delta(*params)\n        results.append(delta)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\n\ndef assemble_matrices_and_solve(nx, ny, nz, h, rho, G, alpha, beta):\n    \"\"\"\n    Assembles matrices, applies BCs, solves eigenvalue problems, \n    and returns the relative difference in modal damping.\n    \"\"\"\n    # Grid dimensions\n    Nx, Ny, Nz = nx + 1, ny + 1, nz + 1\n    num_nodes = Nx * Ny * Nz\n    num_elements = nx * ny * nz\n\n    # Map (i, j, k) grid indices to a single node index\n    def get_node_idx(i, j, k):\n        return i + j * Nx + k * Nx * Ny\n\n    # --- Matrix Assembly ---\n    K = lil_matrix((num_nodes, num_nodes), dtype=np.float64)\n    M_lmp = lil_matrix((num_nodes, num_nodes), dtype=np.float64)\n    M_con = lil_matrix((num_nodes, num_nodes), dtype=np.float64)\n    \n    # 1. Stiffness Matrix K\n    k_spring = G * h\n    spring_mat = k_spring * np.array([[1, -1], [-1, 1]])\n    \n    for k in range(Nz):\n        for j in range(Ny):\n            for i in range(nx):\n                n1 = get_node_idx(i, j, k)\n                n2 = get_node_idx(i + 1, j, k)\n                K[[[n1],[n2]], [n1, n2]] += spring_mat\n    \n    for k in range(Nz):\n        for i in range(Nx):\n            for j in range(ny):\n                n1 = get_node_idx(i, j, k)\n                n2 = get_node_idx(i, j + 1, k)\n                K[[[n1],[n2]], [n1, n2]] += spring_mat\n                \n    for j in range(Ny):\n        for i in range(Nx):\n            for k in range(nz):\n                n1 = get_node_idx(i, j, k)\n                n2 = get_node_idx(i, j, k + 1)\n                K[[[n1],[n2]], [n1, n2]] += spring_mat\n\n    # 2. Mass Matrices M_lmp and M_con\n    element_mass = rho * h**3\n    lumped_mass_per_node = element_mass / 8.0\n\n    # Local node coordinates in an element {0,1}^3\n    local_coords = [\n        (0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0),\n        (0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1)\n    ]\n    \n    # Pre-calculate 8x8 element consistent mass matrix\n    Me_con = np.zeros((8, 8), dtype=np.float64)\n    for p in range(8):\n        for q in range(8):\n            m_matches = sum(c1 == c2 for c1, c2 in zip(local_coords[p], local_coords[q]))\n            Me_con[p, q] = (element_mass / 8.0) * (2.0/3.0)**m_matches * (1.0/3.0)**(3 - m_matches)\n\n    # Assemble global mass matrices by iterating through elements\n    for k_el in range(nz):\n        for j_el in range(ny):\n            for i_el in range(nx):\n                # Global indices of the 8 nodes of the element\n                global_indices = [get_node_idx(i_el + dc[0], j_el + dc[1], k_el + dc[2]) for dc in local_coords]\n                \n                # Assembly for M_lmp\n                for idx in global_indices:\n                    M_lmp[idx, idx] += lumped_mass_per_node\n                \n                # Assembly for M_con\n                idx_grid = np.ix_(global_indices, global_indices)\n                M_con[idx_grid] += Me_con\n\n    # --- Boundary Conditions ---\n    # Homogeneous Dirichlet at z=0 (k=0)\n    fixed_dofs = [get_node_idx(i, j, 0) for i in range(Nx) for j in range(Ny)]\n    all_dofs = np.arange(num_nodes)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs, assume_unique=True)\n\n    # Reduce matrices to free DOFs\n    K_red = K[free_dofs, :][:, free_dofs].toarray()\n    M_lmp_red = M_lmp[free_dofs, :][:, free_dofs].toarray()\n    M_con_red = M_con[free_dofs, :][:, free_dofs].toarray()\n\n    # --- Eigenvalue Problem ---\n    # Solve K*phi = lambda*M*phi for lambda = omega^2\n    # We only need eigenvalues, so we can use eigvals_only=True for speed.\n    eigvals_lmp = eigh(K_red, M_lmp_red, eigvals_only=True)\n    eigvals_con = eigh(K_red, M_con_red, eigvals_only=True)\n    \n    # Filter out potential near-zero eigenvalues from rigid body modes if any\n    # (not expected here due to BCs but good practice)\n    tol = 1e-9\n    eigvals_lmp = eigvals_lmp[eigvals_lmp > tol]\n    eigvals_con = eigvals_con[eigvals_con > tol]\n\n    # Highest natural frequencies\n    omega_max_lmp = np.sqrt(np.max(eigvals_lmp))\n    omega_max_con = np.sqrt(np.max(eigvals_con))\n\n    # --- Damping Ratio Calculation ---\n    def get_xi(omega, alpha_damp, beta_damp):\n        if omega == 0: return np.inf\n        # Handle cases where alpha or beta are zero to avoid division by zero or unnecessary calcs\n        xi = 0.0\n        if alpha_damp > 0:\n            xi += alpha_damp / (2.0 * omega)\n        if beta_damp > 0:\n            xi += beta_damp * omega / 2.0\n        return xi\n\n    xi_max_lmp = get_xi(omega_max_lmp, alpha, beta)\n    xi_max_con = get_xi(omega_max_con, alpha, beta)\n    \n    if xi_max_con == 0:\n        return 0.0 if xi_max_lmp == 0.0 else np.inf\n\n    delta = (xi_max_lmp - xi_max_con) / xi_max_con\n    return delta\n\ndef calculate_delta(nx, ny, nz, h, rho, G, alpha, beta):\n    \"\"\"Wrapper function to call the main solver.\"\"\"\n    return assemble_matrices_and_solve(nx, ny, nz, h, rho, G, alpha, beta)\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}