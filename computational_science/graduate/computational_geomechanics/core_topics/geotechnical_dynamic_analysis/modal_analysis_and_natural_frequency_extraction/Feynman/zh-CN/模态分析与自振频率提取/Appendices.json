{
    "hands_on_practices": [
        {
            "introduction": "模态分析的核心思想在于将复杂系统的运动分解为一系列简单的振动模式。这个过程的数学基础是广义特征值问题的解，即模态向量（振型）的 $M$-正交性。本练习是一项“纸上推演”任务，旨在通过第一性原理推导模态坐标的表达式，从而加深对物理位移场如何投影到模态基上的理解。掌握这一推导过程对于将一个复杂的多自由度耦合系统转化为一组简单的解耦的单自由度系统至关重要 。",
            "id": "3543998",
            "problem": "考虑通过有限元法（FEM）离散化的线性弹性、均质土域的无阻尼、小应变自由振动。其半离散运动方程由以下二阶常微分方程给出\n$$\nM \\ddot{u}(t) + K u(t) = 0,\n$$\n其中 $M \\in \\mathbb{R}^{n \\times n}$ 是对称正定质量矩阵，$K \\in \\mathbb{R}^{n \\times n}$ 是对称正定刚度矩阵，$u(t) \\in \\mathbb{R}^{n}$ 是节点位移向量。相关的自由振动广义特征值问题为\n$$\nK \\psi_i = \\omega_i^{2} M \\psi_i,\n$$\n其中，数值特征求解器返回实数正特征值 $\\omega_i^{2}$ 和实数特征向量 $\\psi_i \\in \\mathbb{R}^{n}$，其缩放比例为任意非零值。\n\n要求您通过强制执行以下条件，将每个计算出的振型归一化为单位广义质量：\n$$\n\\phi_i^{T} M \\phi_i = 1,\n$$\n其中 $\\phi_i = \\alpha_i \\psi_i$，$\\alpha_i \\neq 0$ 为某个标量。对于一个由质量归一化振型进行截断振型叠加表示的位移场，\n$$\nu(t) = \\sum_{j=1}^{m} \\phi_j \\, q_j(t),\n$$\n请从第一性原理出发，推导振型坐标 $q_i(t)$ 关于 $u(t)$、$M$ 和未归一化振型 $\\psi_i$ 的表达式。您的推导必须从运动方程和质量归一化的定义开始，不得引入任何未经证明的简化公式。\n\n请以 $u(t)$、$M$ 和 $\\psi_i$ 的单个闭式解析表达式形式给出 $q_i(t)$ 的最终答案。无需进行数值计算，也无需四舍五入。最终表达式中不要包含物理单位。",
            "solution": "该问题已经过验证，被认为是可靠、适定且客观的。它基于线性代数和计算力学的基本原理，特别是离散系统的振型分析。所有必要信息均已提供，目标明确。我们可以开始推导。\n\n我们的目标是推导振型坐标 $q_i(t)$ 关于位移向量 $u(t)$、质量矩阵 $M$ 和未归一化特征向量（振型）$\\psi_i$ 的表达式。\n\n推导从给定的位移场振型展开式开始，该式将总位移表示为质量归一化振型 $\\phi_j$ 的线性组合：\n$$\nu(t) = \\sum_{j=1}^{m} \\phi_j \\, q_j(t)\n$$\n为了分离出特定的振型坐标 $q_i(t)$，我们将利用特征向量的正交性。广义特征值问题 $K \\psi_i = \\omega_i^2 M \\psi_i$ 的特征向量 $\\psi_i$ 关于刚度矩阵 $K$ 和质量矩阵 $M$ 都是正交的。质量正交性（或M-正交性）是这里的关键。对于任意两个对应于不同特征值（$\\omega_i^2 \\neq \\omega_j^2$）的特征向量 $\\psi_i$ 和 $\\psi_j$，我们有：\n$$\n\\psi_i^T M \\psi_j = 0 \\quad (\\text{for } i \\neq j)\n$$\n该性质直接源于特征值问题本身。给定 $K \\psi_i = \\omega_i^2 M \\psi_i$ 和 $K \\psi_j = \\omega_j^2 M \\psi_j$，我们用 $\\psi_j^T$ 左乘第一个方程得到 $\\psi_j^T K \\psi_i = \\omega_i^2 \\psi_j^T M \\psi_i$。对第二个方程进行转置，并利用 $K$ 和 $M$ 的对称性（$K=K^T, M=M^T$），我们得到 $\\psi_j^T K \\psi_i = \\omega_j^2 \\psi_j^T M \\psi_i$。令这两个表达式相等，得到 $(\\omega_i^2 - \\omega_j^2)\\psi_j^T M \\psi_i = 0$。由于 $\\omega_i^2 \\neq \\omega_j^2$，因此必然有 $\\psi_j^T M \\psi_i = 0$。对于存在重特征值的情况，可以选择相应的特征向量构成一个M-正交集。\n\n质量归一化的振型 $\\phi_i$ 通过一个缩放因子 $\\alpha_i$ 与未归一化的特征向量 $\\psi_i$ 相关联，即 $\\phi_i = \\alpha_i \\psi_i$。因此，M-正交性对于归一化振型也成立：当 $i \\neq j$ 时，$\\phi_i^T M \\phi_j = (\\alpha_i \\psi_i)^T M (\\alpha_j \\psi_j) = \\alpha_i \\alpha_j (\\psi_i^T M \\psi_j) = 0$。\n\n此外，问题要求振型被归一化为单位广义质量，该条件定义为：\n$$\n\\phi_i^T M \\phi_i = 1\n$$\n结合正交性和归一化条件，我们得到归一化振型集合 $\\{\\phi_i\\}$ 的M-正交归一性：\n$$\n\\phi_i^T M \\phi_j = \\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ函数，当 $i=j$ 时等于 $1$，当 $i \\neq j$ 时等于 $0$。\n\n我们现在可以利用这个M-正交归一性来分离出 $q_i(t)$。我们将 $u(t)$ 的振型展开方程两边同时左乘 $\\phi_i^T M$：\n$$\n\\phi_i^T M u(t) = \\phi_i^T M \\left( \\sum_{j=1}^{m} \\phi_j \\, q_j(t) \\right)\n$$\n利用矩阵乘法的分配律，我们将左乘项移入求和号内：\n$$\n\\phi_i^T M u(t) = \\sum_{j=1}^{m} (\\phi_i^T M \\phi_j) q_j(t)\n$$\n代入M-正交归一条件 $\\phi_i^T M \\phi_j = \\delta_{ij}$：\n$$\n\\phi_i^T M u(t) = \\sum_{j=1}^{m} \\delta_{ij} \\, q_j(t)\n$$\n右侧的求和项会简化，因为克罗内克δ函数 $\\delta_{ij}$ 在索引 $j$ 不等于 $i$ 时为零。这使得求和中只剩下一项：\n$$\n\\phi_i^T M u(t) = q_i(t)\n$$\n这给出了用归一化振型 $\\phi_i$ 表示的振型坐标 $q_i(t)$ 的表达式。然而，问题要求最终表达式用未归一化的特征向量 $\\psi_i$ 来表示。为了实现这一点，我们首先从归一化条件中确定缩放因子 $\\alpha_i$。\n$$\n\\phi_i^T M \\phi_i = 1\n$$\n代入 $\\phi_i = \\alpha_i \\psi_i$：\n$$\n(\\alpha_i \\psi_i)^T M (\\alpha_i \\psi_i) = 1\n$$\n由于 $\\alpha_i$ 是一个标量，我们可以将其提取出来：\n$$\n\\alpha_i^2 (\\psi_i^T M \\psi_i) = 1\n$$\n项 $\\psi_i^T M \\psi_i$ 是一个标量，代表未归一化振型 $i$ 的广义质量。由于 $M$ 是正定的且 $\\psi_i$ 是非零向量，该项是一个正实数。求解 $\\alpha_i$（并按惯例取正根）可得：\n$$\n\\alpha_i = \\frac{1}{\\sqrt{\\psi_i^T M \\psi_i}}\n$$\n现在，将这个 $\\alpha_i$ 的表达式代回关系式 $\\phi_i = \\alpha_i \\psi_i$ 中：\n$$\n\\phi_i = \\frac{\\psi_i}{\\sqrt{\\psi_i^T M \\psi_i}}\n$$\n最后，我们将这个 $\\phi_i$ 的表达式代入我们得到的 $q_i(t)$ 的结果中：\n$$\nq_i(t) = \\phi_i^T M u(t) = \\left( \\frac{\\psi_i}{\\sqrt{\\psi_i^T M \\psi_i}} \\right)^T M u(t)\n$$\n分母是一个标量，可以提取出来。分子中的转置运算仅作用于向量 $\\psi_i$：\n$$\nq_i(t) = \\frac{1}{\\sqrt{\\psi_i^T M \\psi_i}} \\psi_i^T M u(t)\n$$\n这可以写成一个单独的分数。分子 $\\psi_i^T M u(t)$ 是一个标量。这就是用指定量表示的振型坐标 $q_i(t)$ 的最终表达式。",
            "answer": "$$\n\\boxed{\\frac{\\psi_i^T M u(t)}{\\sqrt{\\psi_i^T M \\psi_i}}}\n$$"
        },
        {
            "introduction": "在理解了模态叠加的理论基础后，下一步便是通过计算来获得这些模态。本编程练习旨在解决动力有限元分析中的一个经典数值问题：选择一致质量矩阵还是集中质量矩阵。通过亲手实现这两种矩阵的构建，并比较它们对系统固有频率和模态正交性的影响，您将亲身体验不同数值策略如何系统性地改变计算结果，并揭示数值精度与计算效率之间的权衡 。",
            "id": "3543947",
            "problem": "您的任务是开发一个完整的、可运行的程序，用于比较一维地震场地响应模型的一致质量矩阵和集中质量矩阵，并量化自振圆频率的系统性偏差以及对振型正交性关系的符合程度。该物理系统是一个高度为 $H$ 的土柱的垂向离散、小应变剪切梁模型，其侧向位移为 $u(z,t)$，剪切模量为 $G(z)$，质量密度为 $\\rho(z)$。其控制方程源自牛顿第二定律和线性弹性胡克定律，为 $\\rho(z)\\,\\partial^2 u/\\partial t^2=\\partial/\\partial z\\left(G(z)\\,\\partial u/\\partial z\\right)$，$z\\in(0,H)$，并满足 $u(0,t)=0$（固定基底）和 $G(z)\\,\\partial u/\\partial z\\vert_{z=H}=0$（自由表面）的边界条件。使用有限元法，通过线性形函数和单位横截面积对域进行离散，以获得对称的全局刚度矩阵 $K$ 和全局质量矩阵 $M$。考虑两种质量矩阵的构建方法：一致质量矩阵，通过对每个单元上的动能进行精确积分得到；以及集中质量矩阵，通过将单元质量贡献对角化分配到节点上得到。\n\n定义广义特征值问题 $K\\,\\phi=\\omega^2\\,M\\,\\phi$，其解为振型向量 $\\phi$ 和自振圆频率 $\\omega$（单位为 $\\mathrm{rad/s}$）。对于每种质量矩阵构建方法，在给定的边界条件下，计算前三个自振圆频率及其对应的振型向量。将第 $i$ 个自振圆频率的相对偏差定义为 $\\beta_i=\\left(\\omega_i^{\\mathrm{lumped}}-\\omega_i^{\\mathrm{consistent}}\\right)/\\omega_i^{\\mathrm{consistent}}$，以小数形式表示。为评估正交性，缩放每个振型向量 $\\phi_i$，使其满足 $\\phi_i^T M\\,\\phi_i=1$，并计算矩阵 $S=\\Phi^T M\\,\\Phi$，其中 $\\Phi$ 是由缩放后的振型向量作为列组成的矩阵。报告 $S$ 的最大绝对非对角线元素，即 $m=\\max_{i\\neq j}\\left|S_{ij}\\right|$，作为偏离 $M$-正交性的度量。对一致质量矩阵和集中质量矩阵分别进行此评估。\n\n您的程序必须从第一性原理出发组装 $K$ 和 $M$，通过移除基底自由度来施加固定基底边界条件，求解广义对称特征值问题，按 $\\omega$ 升序对振型进行排序，并计算所需的度量指标。所有自振圆频率必须在内部以 $\\mathrm{rad/s}$ 为单位进行处理。相对偏差和正交性度量的输出为无单位的小数。\n\n使用以下参数集测试套件，沿 $z\\in[0,H]$ 的单元大小相等，且横截面积为单位1：\n\n- 测试用例 1 (均匀介质，理想情况)：$H=30\\,\\mathrm{m}$，$G=80\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1800\\,\\mathrm{kg/m^3}$，$n=10$ 个单元。\n- 测试用例 2 (粗糙离散边界)：$H=30\\,\\mathrm{m}$，$G=80\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1800\\,\\mathrm{kg/m^3}$，$n=3$ 个单元。\n- 测试用例 3 (分层介质)：$H=30\\,\\mathrm{m}$，顶层厚度 $10\\,\\mathrm{m}$，其 $G=40\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1700\\,\\mathrm{kg/m^3}$；底层厚度 $20\\,\\mathrm{m}$，其 $G=120\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1900\\,\\mathrm{kg/m^3}$，$n=30$ 个单元。\n- 测试用例 4 (精细离散)：$H=30\\,\\mathrm{m}$，$G=80\\times 10^6\\,\\mathrm{Pa}$，$\\rho=1800\\,\\mathrm{kg/m^3}$，$n=200$ 个单元。\n\n对于每个测试用例，计算：\n- 列表 $[\\beta_1,\\beta_2,\\beta_3]$。\n- 一致质量矩阵的标量 $m_{\\mathrm{consistent}}$。\n- 集中质量矩阵的标量 $m_{\\mathrm{lumped}}$。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个 $[[\\beta_1,\\beta_2,\\beta_3],m_{\\mathrm{consistent}},m_{\\mathrm{lumped}}]$ 格式的列表。例如，输出格式必须完全类似于跨越四个测试用例的聚合列表 $[[\\cdot,\\cdot,\\cdot],\\cdot,\\cdot]$，并显示在单行上。",
            "solution": "该问题要求开发一个程序，用于比较一维土柱剪切梁模型中，由一致质量矩阵和集中质量矩阵公式推导出的振型特性。该分析涉及有限元离散化、求解广义特征值问题以及计算特定的比较指标。\n\n**1. 控制方程和弱形式**\n\n物理系统是一个高度为 $H$ 的土柱，被建模为剪切梁。侧向位移 $u(z,t)$ 的控制偏微分方程如下：\n$$ \\rho(z)\\,\\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial z}\\left(G(z)\\,\\frac{\\partial u}{\\partial z}\\right) \\quad \\text{for } z \\in (0, H) $$\n其中 $\\rho(z)$ 是质量密度，$G(z)$ 是剪切模量，$z$ 是垂直坐标。边界条件为固定基底，$u(0,t)=0$，和自由表面，$G(H)\\,\\frac{\\partial u}{\\partial z}\\vert_{z=H}=0$。\n\n假设简谐运动，我们使用分离变量法，$u(z,t) = \\phi(z)e^{i\\omega t}$，其中 $\\phi(z)$ 是振型，$\\omega$ 是自振圆频率。将其代入控制方程，得到关于振型的常微分方程：\n$$ \\frac{d}{dz}\\left(G(z)\\frac{d\\phi}{dz}\\right) + \\omega^2\\rho(z)\\phi(z) = 0 $$\n为了获得适用于有限元法的弱形式，我们乘以一个检验函数 $v(z)$（其中 $v(0)=0$ 以满足本质边界条件），并在域 $[0, H]$ 上积分：\n$$ \\int_0^H v(z) \\left[ \\frac{d}{dz}\\left(G(z)\\frac{d\\phi}{dz}\\right) + \\omega^2\\rho(z)\\phi(z) \\right] dz = 0 $$\n对刚度项进行分部积分得到：\n$$ \\left[v(z)G(z)\\frac{d\\phi}{dz}\\right]_0^H - \\int_0^H G(z)\\frac{dv}{dz}\\frac{d\\phi}{dz}dz + \\omega^2\\int_0^H \\rho(z)v(z)\\phi(z)dz = 0 $$\n由于 $v(0)=0$ 以及表面的自然边界条件为 $G(H)\\frac{d\\phi}{dz}\\vert_{z=H}=0$，边界项消失。这导出了特征值问题的弱形式：\n$$ \\int_0^H G(z)\\frac{dv}{dz}\\frac{d\\phi}{dz}dz = \\omega^2\\int_0^H \\rho(z)v(z)\\phi(z)dz $$\n\n**2. 有限元离散化**\n\n我们使用线性形函数将域离散为 $n$ 个一维单元。对于一个长度为 $L_e$、节点为 1 和 2 的单元 $e$，位移场近似为 $u^e(z) = N_1(z)d_1^e + N_2(z)d_2^e = \\mathbf{N}(z)\\mathbf{d}^e$。对于单位横截面积（$A=1$），单元刚度矩阵 $k^e$ 和质量矩阵 $m^e$ 从弱形式导出：\n$$ k^e_{ij} = \\int_{L_e} G_e \\frac{dN_i}{dz}\\frac{dN_j}{dz} dz $$\n$$ m^e_{ij} = \\int_{L_e} \\rho_e N_i N_j dz $$\n假设单元上的属性 $G_e$ 和 $\\rho_e$ 是常数，对线性形函数进行积分可得到标准的单元矩阵。\n\n单元刚度矩阵为：\n$$ k^e = \\frac{G_e}{L_e} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} $$\n单元一致质量矩阵 $m_C^e$，通过精确积分动能项得到，其形式为：\n$$ m_C^e = \\frac{\\rho_e L_e}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix} $$\n单元集中质量矩阵 $m_L^e$，通过将质量集中到节点上获得，通常做法是将一致质量矩阵的行相加，并将结果放在对角线上。这等效于将单元质量的一半分配给每个节点：\n$$ m_L^e = \\frac{\\rho_e L_e}{2} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} $$\n\n**3. 全局系统和特征值问题**\n\n全局刚度矩阵 $K$ 和质量矩阵 $M_C$（一致）及 $M_L$（集中）是通过将所有 $n$ 个单元矩阵的贡献相加来组装的。得到的方程组即为广义特征值问题：\n$$ K\\,\\phi = \\omega^2 M\\,\\phi $$\n该系统有 $n+1$ 个自由度（节点 $0, 1, \\dots, n$）。固定基底边界条件 $u(0)=0$ 通过静力凝聚法施加，这等效于从全局矩阵 $K$ 和 $M$ 中移除第一行和第一列。这将问题简化为一个 $n \\times n$ 的系统。\n\n**4. 求解与后处理**\n\n简化的 $n \\times n$ 广义对称特征值问题通过数值特征求解器（例如 `scipy.linalg.eigh`）对两种质量矩阵构建方法进行求解。这将产生 $n$ 个特征值 $\\lambda_i = \\omega_i^2$ 和对应的特征向量 $\\phi'_i$。自振圆频率为 $\\omega_i = \\sqrt{\\lambda_i}$。求解器返回按频率升序排列的振型。通过在前面添加一个零来表示固定基底的位移，可以恢复大小为 $(n+1) \\times 1$ 的完整特征向量 $\\phi_i$。\n\n然后计算所需的度量指标：\n- **相对偏差**：前三个自振频率的系统性偏差计算如下：\n$$ \\beta_i = \\frac{\\omega_i^{\\mathrm{lumped}} - \\omega_i^{\\mathrm{consistent}}}{\\omega_i^{\\mathrm{consistent}}} \\quad \\text{for } i \\in \\{1, 2, 3\\} $$\n理论上已经证实，对于给定的网格，一致质量矩阵法倾向于高估真实的连续体频率，而集中质量矩阵法倾向于低估它们。因此，我们预期 $\\omega_i^{\\mathrm{lumped}} < \\omega_i^{\\mathrm{consistent}}$，从而导致 $\\beta_i$ 为负值。\n\n- **正交性检验**：对于每种质量矩阵构建方法（我们使用 $M$ 和 $\\phi_i$ 作为通用占位符），前三个振型向量被缩放为 $M$-标准正交的，满足 $\\phi_i^T M \\phi_j = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 delta 函数。用于广义问题的标准特征求解器通常返回相对于简化质量矩阵已经如此归一化的特征向量。这种归一化会延续到整个系统中。我们构建一个矩阵 $\\Phi = [\\phi_1, \\phi_2, \\phi_3]$，其中包含前三个缩放后的振型向量作为列。然后我们计算检验矩阵 $S = \\Phi^T M \\Phi$。理想情况下，$S$ 应该是一个 $3 \\times 3$ 的单位矩阵。度量 $m$ 量化了与完美正交性的数值偏差：\n$$ m = \\max_{i\\neq j}\\left|S_{ij}\\right| $$\n这对一致质量 ($m_{\\mathrm{consistent}}$) 和集中质量 ($m_{\\mathrm{lumped}}$) 的构建方法分别进行计算。\n\n程序实现了这整个过程，遍历所提供的测试用例，每个用例都有不同的离散化方式和材料属性（包括分层剖面）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: uniform, n=10\n        {'H': 30.0, 'n': 10, 'layers': [{'thickness': 30.0, 'G': 80e6, 'rho': 1800.0}]},\n        # Case 2: uniform, coarse n=3\n        {'H': 30.0, 'n': 3, 'layers': [{'thickness': 30.0, 'G': 80e6, 'rho': 1800.0}]},\n        # Case 3: layered, n=30\n        {'H': 30.0, 'n': 30, 'layers': [\n            {'thickness': 20.0, 'G': 120e6, 'rho': 1900.0},  # Bottom layer\n            {'thickness': 10.0, 'G': 40e6, 'rho': 1700.0}   # Top layer\n        ]},\n        # Case 4: uniform, fine n=200\n        {'H': 30.0, 'n': 200, 'layers': [{'thickness': 30.0, 'G': 80e6, 'rho': 1800.0}]}\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(run_analysis(case))\n\n    # Format the results for printing as specified.\n    # The output from each case is a list like [[b1, b2, b3], m_c, m_l]\n    # We need to format it into a string representation inside a larger list.\n    formatted_results = []\n    for res in results:\n        betas_str = f\"[{res[0][0]:.8f},{res[0][1]:.8f},{res[0][2]:.8f}]\"\n        m_c_str = f\"{res[1]:.8e}\"\n        m_l_str = f\"{res[2]:.8e}\"\n        formatted_results.append(f\"[{betas_str},{m_c_str},{m_l_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_analysis(params):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \"\"\"\n    H = params['H']\n    n_elements = params['n']\n    layers = params['layers']\n    \n    # Create property functions G(z) and rho(z) from layer data\n    def get_properties(z):\n        current_depth = 0.0\n        for layer in layers:\n            current_depth += layer['thickness']\n            if z = current_depth:\n                return layer['G'], layer['rho']\n        # Fallback for z=H which might fall on the boundary\n        return layers[-1]['G'], layers[-1]['rho']\n\n    # 1. Assemble matrices\n    K, M_C, M_L = assemble_matrices(H, n_elements, get_properties)\n    \n    # 2. Solve for consistent mass formulation\n    omegas_C, eigvecs_C = solve_eigenproblem(K, M_C)\n    \n    # 3. Solve for lumped mass formulation\n    omegas_L, eigvecs_L = solve_eigenproblem(K, M_L)\n    \n    # 4. Compute metrics\n    # Take first 3 modes for calculations\n    num_modes = 3\n\n    # Fractional bias\n    betas = (omegas_L[:num_modes] - omegas_C[:num_modes]) / omegas_C[:num_modes]\n    \n    # Orthogonality check for consistent mass\n    Phi_C = eigvecs_C[:, :num_modes]\n    S_C = Phi_C.T @ M_C @ Phi_C\n    np.fill_diagonal(S_C, 0.0)\n    m_consistent = np.max(np.abs(S_C))\n\n    # Orthogonality check for lumped mass\n    Phi_L = eigvecs_L[:, :num_modes]\n    S_L = Phi_L.T @ M_L @ Phi_L\n    np.fill_diagonal(S_L, 0.0)\n    m_lumped = np.max(np.abs(S_L))\n\n    return [betas.tolist(), m_consistent, m_lumped]\n\ndef assemble_matrices(H, n_elements, get_properties):\n    \"\"\"\n    Assembles global stiffness and mass matrices for a 1D shear beam.\n    \"\"\"\n    n_nodes = n_elements + 1\n    L_e = H / n_elements  # Element length\n    \n    K = np.zeros((n_nodes, n_nodes))\n    M_C = np.zeros((n_nodes, n_nodes))\n    M_L = np.zeros((n_nodes, n_nodes))\n    \n    # Cross-sectional area is 1\n    A = 1.0\n\n    for e in range(n_elements):\n        # Nodes connected by element e\n        i, j = e, e + 1\n        \n        # Get material properties at the element's midpoint\n        z_mid = (e + 0.5) * L_e\n        G_e, rho_e = get_properties(z_mid)\n        \n        # Element stiffness matrix\n        k_e = (G_e * A / L_e) * np.array([[1, -1], [-1, 1]])\n        \n        # Element consistent mass matrix\n        m_c_e = (rho_e * A * L_e / 6) * np.array([[2, 1], [1, 2]])\n        \n        # Element lumped mass matrix\n        m_l_e = (rho_e * A * L_e / 2) * np.array([[1, 0], [0, 1]])\n        \n        # Assemble into global matrices\n        K[i:j+1, i:j+1] += k_e\n        M_C[i:j+1, i:j+1] += m_c_e\n        M_L[i:j+1, i:j+1] += m_l_e\n        \n    return K, M_C, M_L\n\ndef solve_eigenproblem(K, M):\n    \"\"\"\n    Applies boundary conditions and solves the generalized eigenvalue problem.\n    \"\"\"\n    n_nodes = K.shape[0]\n    \n    # Apply fixed-base boundary condition u(0)=0 by removing the first DOF\n    K_reduced = K[1:, 1:]\n    M_reduced = M[1:, 1:]\n    \n    # Solve the generalized eigenvalue problem: K' * v = w * M' * v\n    # eigh returns eigenvalues in ascending order\n    eigvals, eigvecs_reduced = eigh(K_reduced, M_reduced)\n    \n    # Frequencies omega = sqrt(eigenvalues)\n    omegas = np.sqrt(eigvals)\n    \n    # Reconstruct full eigenvectors (size n_nodes) by prepending zero for the fixed base\n    n_modes = eigvecs_reduced.shape[1]\n    eigvecs_full = np.zeros((n_nodes, n_modes))\n    eigvecs_full[1:, :] = eigvecs_reduced\n    \n    return omegas, eigvecs_full\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们将已建立的计算技能应用于一个经典的岩土工程问题。实际的土层剖面很少是均匀的，因此本练习旨在模拟一个分层土柱，并量化这种非均质性如何影响其动力特性，特别是与一个等效的均质模型相比。本实践引入了模态置信准则（Modal Assurance Criterion, MAC）这一强大的工具，用于定量比较不同模型下的振型差异，从而深化对场地特定地震反应的物理直觉与理解 。",
            "id": "3543944",
            "problem": "您的任务是推导、实现并验证一个计算程序，用以提取一个经受横向剪切振动的竖向分层土柱的前三个自振频率和相关振型。该土柱使用有限元法（FEM）进行建模，采用一维空间中的线性双节点单元。土柱底部固定，顶部自由。您的推导和实现必须从基本原理和既定事实出发，而不是使用简便公式。\n\n从牛顿第二定律出发，该定律指出合力等于质量乘以加速度。对于一个横向位移场为 $u(z,t)$ 的一维剪切变形柱，其剪应力 $\\tau(z,t)$ 遵循 $\\tau(z,t) = G(z) \\, \\partial u / \\partial z$，其中 $G(z)$ 是剪切模量剖面。质量密度为 $\\rho(z)$，横截面积为 $A$（假定为常数）。横向线性动量的基本平衡导出一个控制方程，该方程通过材料属性 $G(z)$ 和 $\\rho(z)$ 将惯性、应力和变形联系起来。\n\n将总长度为 $L$ 的土柱离散为 $N$ 个节点（以及 $N-1$ 个单元），节点间距均匀。使用线性形函数和一致质量公式构建单元刚度和质量贡献。在考虑底部固定边界的情况下，组装全局刚度矩阵和全局质量矩阵。寻求谐波解并执行模态分析，以计算前三个自振频率（单位：赫兹）和相关振型。相对于全局质量矩阵对振型进行归一化。\n\n为了分离出分层对模态特性的影响，对每种分层配置，还需构建一个具有相同总长度 $L$、相同节点数 $N$ 的均质参考土柱，并满足以下两个等效条件：\n- 静剪切刚度等效：均质剪切模量 $G_{\\mathrm{eq}}$ 必须满足 $L / (G_{\\mathrm{eq}} A) = \\sum_{i} \\ell_i / (G_i A)$，即 $G_{\\mathrm{eq}} = \\dfrac{L}{\\sum_i \\ell_i / G_i}$，其中 $\\ell_i$ 和 $G_i$ 分别是第 $i$ 层的厚度和剪切模量。\n- 质量等效：均质密度 $\\rho_{\\mathrm{eq}}$ 必须满足 $\\rho_{\\mathrm{eq}} = \\dfrac{1}{L} \\sum_i \\ell_i \\rho_i$，其中 $\\rho_i$ 是第 $i$ 层的密度。\n\n对于下述每个测试用例，计算：\n1. 分层土柱的前三个自振频率，单位为赫兹，四舍五入到四位小数。\n2. 其均质参考土柱的前三个自振频率，单位为赫兹，四舍五入到四位小数。\n3. 使用振型保证准则（MAC）来定量度量分层相对于均质参考土柱如何改变前三个振型。将两个振型之间的MAC定义为一个在 $[0,1]$ 区间内的标量，由归一化向量计算得出，并报告每个MAC值，四舍五入到四位小数。接近 $1$ 的值表示振型非常相似；接近 $0$ 的值表示差异很大。\n\n构建您的程序来求解每个案例中由组装好的全局矩阵产生的广义特征值问题。对振型使用质量归一化，对MAC计算使用欧几里得归一化。不允许外部输入；程序必须实现以下测试套件。\n\n参数值测试套件（所有长度单位为米，模量单位为帕斯卡，密度单位为千克/立方米）：\n- 案例1（均质基线，理想情况）：$L = 30$, $A = 10$, $N = 7$ 个节点，单层 $(\\ell_1 = 30, G_1 = 80 \\times 10^6, \\rho_1 = 1800)$。\n- 案例2（双层对比）：$L = 30$, $A = 10$, $N = 7$ 个节点，两层：底层 $(\\ell_1 = 20, G_1 = 120 \\times 10^6, \\rho_1 = 1900)$ 和顶层 $(\\ell_2 = 10, G_2 = 40 \\times 10^6, \\rho_2 = 1600)$。\n- 案例3（边缘情况，薄软顶层）：$L = 30$, $A = 10$, $N = 7$ 个节点，两层：底层 $(\\ell_1 = 29, G_1 = 100 \\times 10^6, \\rho_1 = 1800)$ 和顶层 $(\\ell_2 = 1, G_2 = 10 \\times 10^6, \\rho_2 = 1600)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个嵌套列表，格式严格如下：\n[[fL1,fL2,fL3],[fH1,fH2,fH3],[MAC1,MAC2,MAC3]]\n此处 [fL1,fL2,fL3] 是分层土柱的前三个频率（赫兹），[fH1,fH2,fH3] 是均质参考土柱的前三个频率（赫兹），[MAC1,MAC2,MAC3] 是前三对振型的MAC值。最终的汇总输出必须是：\n[[...案例1...],[...案例2...],[...案例3...]]\n所有频率和MAC值都四舍五入到四位小数，并表示为小数（无百分号）。",
            "solution": "该问题要求推导并实现一个有限元法（FEM）程序，用以确定一维剪切柱的自振频率和振型，并将分层土柱与其均质等效土柱进行比较。下面从基本原理开始详细描述该过程。\n\n### 步骤1：运动控制方程\n\n我们考虑一个总长度为 $L$、恒定横截面积为 $A$、剪切模量 $G(z)$ 和质量密度 $\\rho(z)$ 随空间变化的竖向土柱，其中 $z$ 是从固定底面测量的竖向坐标。该土柱经历横向剪切变形，位移场由 $u(z,t)$ 给出。\n\n根据牛顿第二定律，作用在高度为 $dz$ 的微分单元上的合力必须等于其质量乘以加速度。惯性力为 $dF_{inertia} = (\\rho(z) A dz) \\frac{\\partial^2 u}{\\partial t^2}$。净剪力源于剪应力 $\\tau(z,t)$ 在单元高度上的变化：$dF_{shear} = (\\tau(z+dz) - \\tau(z))A \\approx \\frac{\\partial \\tau}{\\partial z} A dz$。使这些力相等以达到动力平衡，可得：\n$$ \\rho(z) A \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial \\tau}{\\partial z} A $$\n剪应力通过线性弹性本构关系与剪应变 $\\gamma = \\frac{\\partial u}{\\partial z}$ 相关联：$\\tau(z,t) = G(z) \\gamma(z,t) = G(z) \\frac{\\partial u}{\\partial z}$。将此关系代入平衡方程，得到剪切波传播的控制偏微分方程（PDE）：\n$$ \\rho(z) \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial z} \\left( G(z) \\frac{\\partial u}{\\partial z} \\right) $$\n\n对于模态分析，我们寻求 $u(z, t) = \\phi(z) e^{i\\omega t}$ 形式的谐波解，其中 $\\phi(z)$ 是振型，$\\omega$ 是自振圆频率。将此解代入PDE，得到不含时间的常微分方程：\n$$ -\\omega^2 \\rho(z) \\phi(z) = \\frac{d}{dz} \\left( G(z) \\frac{d\\phi}{dz} \\right) $$\n\n### 步骤2：弱形式与有限元公式\n\n我们使用伽辽金法求解此方程。我们将方程乘以一个检验函数 $v(z)$ 并在定义域 $[0, L]$ 上积分：\n$$ \\int_{0}^{L} v(z) \\left[ \\frac{d}{dz} \\left( G(z) \\frac{d\\phi}{dz} \\right) + \\omega^2 \\rho(z) \\phi(z) \\right] dz = 0 $$\n对第一项应用分部积分（以降低微分阶数）可得：\n$$ \\left[ v(z) G(z) \\frac{d\\phi}{dz} \\right]_0^L - \\int_{0}^{L} \\frac{dv}{dz} G(z) \\frac{d\\phi}{dz} dz + \\omega^2 \\int_{0}^{L} v(z) \\rho(z) \\phi(z) dz = 0 $$\n边界条件为底部固定（$z=0$）和顶部自由（$z=L$）。\n- 在固定底面，位移为零：$u(0,t)=0 \\implies \\phi(0)=0$。作为本质边界条件，检验函数也必须为零：$v(0)=0$。\n- 在自由顶面，剪应力为零：$\\tau(L) = G(L) \\frac{d\\phi}{dz}\\big|_{z=L} = 0$。\n这些条件使得边界项 $\\left[ v G \\frac{d\\phi}{dz} \\right]_0^L$ 为零。由此得到的弱形式为：\n$$ \\int_{0}^{L} \\frac{dv}{dz} G(z) \\frac{d\\phi}{dz} dz = \\omega^2 \\int_{0}^{L} v(z) \\rho(z) \\phi(z) dz $$\n\n我们将域离散为 $N-1$ 个线性双节点单元。在长度为 $h_e$ 的单元 $e$ 内，位移场 $\\phi_e(z')$ 使用线性形函数 $\\mathbf{N}(z') = [N_1(z'), N_2(z')]$ 和节点位移 $\\mathbf{d}_e = [\\phi_1, \\phi_2]^T$ 进行近似：\n$\\phi_e(z') = \\mathbf{N}(z') \\mathbf{d}_e$，其中 $z'$ 是局部坐标，$z' \\in [0, h_e]$。\n形函数为 $N_1(z') = 1 - z'/h_e$ 和 $N_2(z') = z'/h_e$。应变近似为 $\\frac{d\\phi_e}{dz'} = \\mathbf{B} \\mathbf{d}_e$，其中 $\\mathbf{B} = [-1/h_e, 1/h_e]$。\n\n将这些近似代入单个单元的弱形式（并对任意 $\\mathbf{c}$ 使用 $v_e = \\mathbf{N} \\mathbf{c}$），得到单元刚度矩阵 $\\mathbf{k}_e$ 和一致质量矩阵 $\\mathbf{m}_e$：\n$$ \\mathbf{k}_e = \\int_{V_e} \\mathbf{B}^T G_e \\mathbf{B} \\, dV = A \\int_0^{h_e} \\mathbf{B}^T G_e \\mathbf{B} \\, dz' = \\frac{G_e A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n$$ \\mathbf{m}_e = \\int_{V_e} \\mathbf{N}^T \\rho_e \\mathbf{N} \\, dV = A \\int_0^{h_e} \\mathbf{N}^T \\rho_e \\mathbf{N} \\, dz' = \\frac{\\rho_e A h_e}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} $$\n其中 $G_e$ 和 $\\rho_e$ 是单元 $e$ 上的恒定剪切模量和密度。\n\n### 步骤3：组装与特征值问题求解\n\n单元矩阵被组装成大小为 $N \\times N$ 的全局矩阵 $\\mathbf{K}_{\\text{global}}$ 和 $\\mathbf{M}_{\\text{global}}$。通过移除全局矩阵的第一行和第一列来施加底部固定条件 $\\phi(0) = 0$（对应于节点0）。这会得到对应于自由度的大小为 $(N-1) \\times (N-1)$ 的缩减矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$。\n\n离散的方程组成为广义特征值问题：\n$$ \\mathbf{K} \\mathbf{\\phi} = \\omega^2 \\mathbf{M} \\mathbf{\\phi} $$\n其中 $\\mathbf{\\phi}$ 是自由节点的节点位移向量（振型）。我们求解此问题以获得特征值 $\\lambda_i = \\omega_i^2$ 和对应的特征向量 $\\mathbf{\\phi}_i$。然后，自振频率（单位：赫兹）为 $f_i = \\omega_i / (2\\pi) = \\sqrt{\\lambda_i} / (2\\pi)$。\n\n问题要求振型是质量归一化的，这意味着它们被缩放以满足 $\\mathbf{\\phi}_i^T \\mathbf{M} \\mathbf{\\phi}_i = 1$。这是像 `scipy.linalg.eigh` 这样的广义特征值求解器的标准输出。通过在固定底部位移前添加一个零来重构完整的振型。\n\n### 步骤4：均质参考土柱\n\n对于每种分层配置，定义一个具有等效属性 $G_{\\text{eq}}$ 和 $\\rho_{\\text{eq}}$ 的参考均质土柱，以保持总静刚度和总质量。\n- **静剪切刚度等效**：分层土柱的总剪切柔度是各层柔度之和。$K_{\\text{total}}^{-1} = \\sum_i (G_i A / \\ell_i)^{-1} = \\frac{1}{A} \\sum_i \\frac{\\ell_i}{G_i}$。对于等效土柱，$K_{\\text{eq}}^{-1} = \\frac{L}{G_{\\text{eq}} A}$。令二者相等，得到等效剪切模量：\n$$ G_{\\mathrm{eq}} = \\frac{L}{\\sum_{i} \\ell_i / G_i} $$\n- **质量等效**：分层土柱的总质量为 $\\sum_i \\rho_i A \\ell_i$。对于等效土柱，总质量为 $\\rho_{\\text{eq}} A L$。令二者相等，得到等效密度：\n$$ \\rho_{\\mathrm{eq}} = \\frac{1}{L} \\sum_i \\ell_i \\rho_i $$\n对这个均质土柱重复有限元分析，以获得其参考频率和振型。\n\n### 步骤5：振型保证准则（MAC）\n\n振型保证准则（MAC）用于量化两个振型 $\\mathbf{\\phi}_A$（来自分层分析）和 $\\mathbf{\\phi}_B$（来自均质分析）之间的相似性。它是一个介于0和1之间的标量值，定义为：\n$$ \\text{MAC}(\\mathbf{\\phi}_A, \\mathbf{\\phi}_B) = \\frac{(\\mathbf{\\phi}_A^T \\mathbf{\\phi}_B)^2}{(\\mathbf{\\phi}_A^T \\mathbf{\\phi}_A)(\\mathbf{\\phi}_B^T \\mathbf{\\phi}_B)} $$\n值为1表示完全相关（振型相同），而接近0的值表示正交（振型差异很大）。计算在完整的振型向量（包括底部的零）上使用标准的欧几里得点积。\n\n对每个测试用例执行该程序，以计算所需的频率和MAC值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Homogeneous baseline\n        {\n            \"L\": 30.0, \"A\": 10.0, \"N\": 7,\n            \"layers\": [(30.0, 80e6, 1800.0)]\n        },\n        # Case 2: Two-layer contrast\n        {\n            \"L\": 30.0, \"A\": 10.0, \"N\": 7,\n            \"layers\": [(20.0, 120e6, 1900.0), (10.0, 40e6, 1600.0)]\n        },\n        # Case 3: Thin soft cap\n        {\n            \"L\": 30.0, \"A\": 10.0, \"N\": 7,\n            \"layers\": [(29.0, 100e6, 1800.0), (1.0, 10e6, 1600.0)]\n        }\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        L = params[\"L\"]\n        A = params[\"A\"]\n        N = params[\"N\"]\n        layers = params[\"layers\"]\n\n        # 1. Analyze layered column\n        freqs_L, modes_L = run_fem_analysis(L, A, N, layers)\n\n        # 2. Define and analyze equivalent homogeneous column\n        sum_li_over_Gi = sum(li / Gi for li, Gi, _ in layers)\n        G_eq = L / sum_li_over_Gi\n        \n        sum_li_rhoi = sum(li * rhoi for li, _, rhoi in layers)\n        rho_eq = sum_li_rhoi / L\n        \n        layers_H = [(L, G_eq, rho_eq)]\n        freqs_H, modes_H = run_fem_analysis(L, A, N, layers_H)\n\n        # 3. Compute MAC values\n        mac_values = compute_mac(modes_L, modes_H, 3)\n\n        # 4. Format results\n        case_result = [\n            [round(f, 4) for f in freqs_L[:3]],\n            [round(f, 4) for f in freqs_H[:3]],\n            [round(m, 4) for m in mac_values]\n        ]\n        all_results.append(case_result)\n\n    # Final print statement\n    print(f\"{all_results}\")\n\ndef get_properties_at_z(z, layers):\n    \"\"\"\n    Finds the material properties (G, rho) at a given depth z.\n    Layers are defined from the bottom (z=0) up.\n    \"\"\"\n    current_z = 0.0\n    for thickness, G, rho in layers:\n        # Use a small tolerance for floating point comparisons at boundaries\n        if z = current_z + thickness + 1e-9:\n            return G, rho\n        current_z += thickness\n    # Fallback for z at the very top edge due to float precision\n    return layers[-1][1], layers[-1][2]\n\ndef run_fem_analysis(L, A, N, layers):\n    \"\"\"\n    Performs FEM analysis for a 1D shear column.\n    Returns the first few natural frequencies and mass-normalized mode shapes.\n    \"\"\"\n    num_elements = N - 1\n    h = L / num_elements  # Element length\n\n    # Initialize global matrices\n    K_global = np.zeros((N, N))\n    M_global = np.zeros((N, N))\n    \n    node_coords = np.linspace(0, L, N)\n\n    for i in range(num_elements):\n        # Determine properties at element midpoint\n        z_mid = (node_coords[i] + node_coords[i+1]) / 2.0\n        G_e, rho_e = get_properties_at_z(z_mid, layers)\n\n        # Element stiffness matrix\n        k_e = (G_e * A / h) * np.array([[1, -1], [-1, 1]])\n\n        # Element consistent mass matrix\n        m_e = (rho_e * A * h / 6.0) * np.array([[2, 1], [1, 2]])\n\n        # Assemble into global matrices\n        nodes = slice(i, i + 2)\n        K_global[nodes, nodes] += k_e\n        M_global[nodes, nodes] += m_e\n        \n    # Apply boundary conditions (fixed base at node 0)\n    # The active DOFs are nodes 1 to N-1\n    K_reduced = K_global[1:, 1:]\n    M_reduced = M_global[1:, 1:]\n\n    # Solve the generalized eigenvalue problem K*phi = omega^2*M*phi\n    # eigh returns eigenvalues in ascending order and M-orthonormal eigenvectors\n    eigvals, eigvecs = eigh(K_reduced, M_reduced)\n\n    # Frequencies in Hertz (f = omega / 2*pi)\n    omegas = np.sqrt(eigvals)\n    freqs = omegas / (2.0 * np.pi)\n\n    # Reconstruct full mode shapes (add 0 for fixed base)\n    num_modes = eigvecs.shape[1]\n    modes = []\n    for i in range(num_modes):\n        mode_reduced = eigvecs[:, i]\n        # Prepend the 0 for the fixed node\n        mode_full = np.insert(mode_reduced, 0, 0)\n        modes.append(mode_full)\n        \n    return freqs, modes\n\ndef compute_mac(modes_A, modes_B, num_modes):\n    \"\"\"\n    Computes the Modal Assurance Criterion for corresponding mode pairs.\n    \"\"\"\n    mac_values = []\n    for i in range(num_modes):\n        phi_A = modes_A[i]\n        phi_B = modes_B[i]\n        \n        numerator = (phi_A.T @ phi_B)**2\n        denominator = (phi_A.T @ phi_A) * (phi_B.T @ phi_B)\n        \n        mac = 0.0 if denominator == 0 else numerator / denominator\n        mac_values.append(mac)\n    return mac_values\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}