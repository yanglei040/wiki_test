{
    "hands_on_practices": [
        {
            "introduction": "In dynamic geomechanical analyses, such as seismic response or wave propagation, the element mass matrix is a critical component. This exercise  delves into two common formulations: the consistent mass matrix, which is fully populated and theoretically more accurate, and the lumped mass matrix, which is diagonal and computationally efficient. By deriving the ratio of their traces for a standard bilinear element, you will gain a deeper appreciation for the mathematical properties that distinguish these methods and the implications for numerical modeling.",
            "id": "3535709",
            "problem": "Consider transient wave propagation in a homogeneous, dry soil layer under plane strain, discretized by the Finite Element Method (FEM) using a single isoparametric bilinear $4$-node quadrilateral element that covers a rectangular patch with corner nodes at $(0,0)$, $(a,0)$, $(a,b)$, and $(0,b)$, where $a0$ and $b0$. The soil has constant mass density $\\rho0$. The parent (reference) coordinate system is $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$, and the standard bilinear shape functions are\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\nLet the isoparametric mapping be $x(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)x_i$ and $y(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)y_i$, and let the Jacobian matrix be $\\mathbf{J}=\\partial(x,y)/\\partial(\\xi,\\eta)$ with determinant $\\det\\mathbf{J}0$ over the element. The consistent element mass matrix is defined by\n$$\n\\mathbf{M}_c = \\int_{\\Omega_e} \\rho\\, \\mathbf{N}^T\\mathbf{N}\\, d\\Omega,\\quad \\text{with } \\mathbf{N}=[N_1\\;N_2\\;N_3\\;N_4],\n$$\nand, under the isoparametric mapping, $d\\Omega = \\det\\mathbf{J}\\, d\\xi\\, d\\eta$. The lumped element mass matrix is obtained by the standard row-sum diagonal approximation,\n$$\n\\mathbf{M}_\\ell = \\mathrm{diag}\\big(\\mathbf{M}_c\\,\\mathbf{1}\\big),\\quad \\text{where } \\mathbf{1}=[1\\;1\\;1\\;1]^T.\n$$\nStarting from these definitions and without invoking any pre-tabulated integrals, derive an exact expression for the ratio $r$ of the trace of the consistent mass matrix to the trace of the lumped mass matrix,\n$$\nr \\equiv \\frac{\\mathrm{tr}(\\mathbf{M}_c)}{\\mathrm{tr}(\\mathbf{M}_\\ell)},\n$$\nand provide the final value of $r$ as a single exact rational number. The answer is dimensionless, so no units are required. No rounding is needed; report the exact value.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of the Finite Element Method, is well-posed with all necessary information provided, and is stated objectively without ambiguity. We can therefore proceed with a full derivation.\n\nThe objective is to compute the ratio $r$ defined as\n$$\nr = \\frac{\\mathrm{tr}(\\mathbf{M}_c)}{\\mathrm{tr}(\\mathbf{M}_\\ell)}\n$$\nwhere $\\mathbf{M}_c$ is the consistent mass matrix and $\\mathbf{M}_\\ell$ is the lumped mass matrix for a single rectangular isoparametric element.\n\nFirst, we determine the Jacobian of the isoparametric mapping. The corner nodes of the rectangular element in the physical domain $(x,y)$ are given as $(x_1, y_1) = (0,0)$, $(x_2, y_2) = (a,0)$, $(x_3, y_3) = (a,b)$, and $(x_4, y_4) = (0,b)$. The isoparametric mapping from the parent domain $(\\xi, \\eta)$ to the physical domain is given by:\n$$\nx(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)x_i = N_1(0) + N_2(a) + N_3(a) + N_4(0) = a(N_2 + N_3)\n$$\n$$\ny(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)y_i = N_1(0) + N_2(0) + N_3(b) + N_4(b) = b(N_3 + N_4)\n$$\nUsing the provided definitions of the shape functions $N_i$:\n$$\nN_2 + N_3 = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta+1+\\eta) = \\frac{1}{2}(1+\\xi)\n$$\n$$\nN_3 + N_4 = \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) = \\frac{1}{4}(1+\\eta)(1+\\xi+1-\\xi) = \\frac{1}{2}(1+\\eta)\n$$\nThus, the mapping is:\n$$\nx(\\xi,\\eta) = \\frac{a}{2}(1+\\xi) \\quad \\text{and} \\quad y(\\xi,\\eta) = \\frac{b}{2}(1+\\eta)\n$$\nThe Jacobian matrix $\\mathbf{J}$ has components $J_{ij} = \\frac{\\partial x_i}{\\partial \\xi_j}$:\n$$\nJ_{11} = \\frac{\\partial x}{\\partial \\xi} = \\frac{a}{2}, \\quad J_{12} = \\frac{\\partial x}{\\partial \\eta} = 0\n$$\n$$\nJ_{21} = \\frac{\\partial y}{\\partial \\xi} = 0, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\frac{b}{2}\n$$\nSo, the Jacobian matrix is $\\mathbf{J} = \\begin{pmatrix} a/2  0 \\\\ 0  b/2 \\end{pmatrix}$. The determinant of the Jacobian is:\n$$\n\\det\\mathbf{J} = \\left(\\frac{a}{2}\\right)\\left(\\frac{b}{2}\\right) - (0)(0) = \\frac{ab}{4}\n$$\nSince $a0$ and $b0$, $\\det\\mathbf{J}0$ as required. The determinant is constant over the element, which simplifies the integration.\n\nNext, we calculate the trace of the consistent mass matrix, $\\mathrm{tr}(\\mathbf{M}_c)$. The consistent mass matrix is given by:\n$$\n\\mathbf{M}_c = \\int_{\\Omega_e} \\rho\\, \\mathbf{N}^T\\mathbf{N}\\, d\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} \\rho\\, \\mathbf{N}^T(\\xi,\\eta)\\mathbf{N}(\\xi,\\eta)\\, \\det\\mathbf{J}\\, d\\xi\\, d\\eta\n$$\nThe components of $\\mathbf{M}_c$ are:\n$$\n(M_c)_{ij} = \\rho \\frac{ab}{4} \\int_{-1}^{1}\\int_{-1}^{1} N_i(\\xi,\\eta)N_j(\\xi,\\eta)\\, d\\xi\\, d\\eta\n$$\nThe trace of $\\mathbf{M}_c$ is the sum of its diagonal elements:\n$$\n\\mathrm{tr}(\\mathbf{M}_c) = \\sum_{i=1}^{4} (M_c)_{ii} = \\rho \\frac{ab}{4} \\sum_{i=1}^{4} \\int_{-1}^{1}\\int_{-1}^{1} N_i^2(\\xi,\\eta)\\, d\\xi\\, d\\eta\n$$\nDue to the structure of the shape functions, the integral of $N_i^2$ is the same for all $i=1,2,3,4$. Let's compute it for $i=1$:\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} N_1^2(\\xi,\\eta)\\, d\\xi\\, d\\eta = \\int_{-1}^{1}\\int_{-1}^{1} \\left(\\frac{1}{4}(1-\\xi)(1-\\eta)\\right)^2 d\\xi\\, d\\eta = \\frac{1}{16} \\int_{-1}^{1} (1-\\xi)^2 d\\xi \\int_{-1}^{1} (1-\\eta)^2 d\\eta\n$$\nWe evaluate the one-dimensional integral:\n$$\n\\int_{-1}^{1} (1-u)^2 du = \\left[ -\\frac{(1-u)^3}{3} \\right]_{-1}^{1} = -\\frac{(1-1)^3}{3} - \\left(-\\frac{(1-(-1))^3}{3}\\right) = 0 + \\frac{2^3}{3} = \\frac{8}{3}\n$$\nTherefore, the double integral is:\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} N_1^2(\\xi,\\eta)\\, d\\xi\\, d\\eta = \\frac{1}{16} \\left(\\frac{8}{3}\\right) \\left(\\frac{8}{3}\\right) = \\frac{64}{16 \\times 9} = \\frac{4}{9}\n$$\nBy symmetry, this result holds for all $N_i^2$. So, the diagonal elements of $\\mathbf{M}_c$ are:\n$$\n(M_c)_{ii} = \\rho \\frac{ab}{4} \\left(\\frac{4}{9}\\right) = \\frac{\\rho ab}{9}\n$$\nThe trace of the consistent mass matrix is the sum of these four identical diagonal elements:\n$$\n\\mathrm{tr}(\\mathbf{M}_c) = 4 \\times \\frac{\\rho ab}{9} = \\frac{4\\rho ab}{9}\n$$\n\nNow, we calculate the trace of the lumped mass matrix, $\\mathrm{tr}(\\mathbf{M}_\\ell)$. The lumped mass matrix is defined by the row-sum technique: $\\mathbf{M}_\\ell = \\mathrm{diag}(\\mathbf{M}_c\\mathbf{1})$. The diagonal elements are $(M_\\ell)_{ii} = \\sum_{j=1}^{4} (M_c)_{ij}$. The trace is the sum of these diagonal elements:\n$$\n\\mathrm{tr}(\\mathbf{M}_\\ell) = \\sum_{i=1}^{4} (M_\\ell)_{ii} = \\sum_{i=1}^{4} \\sum_{j=1}^{4} (M_c)_{ij}\n$$\nThis is the sum of all entries in the consistent mass matrix $\\mathbf{M}_c$. We can compute this sum directly:\n$$\n\\sum_{i=1}^{4} \\sum_{j=1}^{4} (M_c)_{ij} = \\sum_{i=1}^{4} \\sum_{j=1}^{4} \\left( \\rho \\frac{ab}{4} \\int_{-1}^{1}\\int_{-1}^{1} N_i N_j \\, d\\xi\\, d\\eta \\right) = \\rho \\frac{ab}{4} \\int_{-1}^{1}\\int_{-1}^{1} \\left(\\sum_{i=1}^{4} N_i\\right) \\left(\\sum_{j=1}^{4} N_j\\right) d\\xi\\, d\\eta\n$$\nA fundamental property of interpolating shape functions is that they form a partition of unity, i.e., $\\sum_{k=1}^{4} N_k(\\xi, \\eta) = 1$ for all $(\\xi, \\eta)$. Substituting this property into the expression:\n$$\n\\mathrm{tr}(\\mathbf{M}_\\ell) = \\rho \\frac{ab}{4} \\int_{-1}^{1}\\int_{-1}^{1} (1)(1)\\, d\\xi\\, d\\eta = \\rho \\frac{ab}{4} \\left[ \\xi \\right]_{-1}^{1} \\left[ \\eta \\right]_{-1}^{1} = \\rho \\frac{ab}{4} (2)(2) = \\rho ab\n$$\nPhysically, $\\mathrm{tr}(\\mathbf{M}_\\ell)$ represents the total mass of the element, which is the density $\\rho$ times the area $ab$.\n\nFinally, we compute the ratio $r$:\n$$\nr = \\frac{\\mathrm{tr}(\\mathbf{M}_c)}{\\mathrm{tr}(\\mathbf{M}_\\ell)} = \\frac{\\frac{4\\rho ab}{9}}{\\rho ab}\n$$\nThe terms $\\rho$, $a$, and $b$ cancel, yielding the final dimensionless value:\n$$\nr = \\frac{4}{9}\n$$\nThis result is an exact rational number as requested.",
            "answer": "$$ \\boxed{\\frac{4}{9}} $$"
        },
        {
            "introduction": "The isoparametric mapping, while powerful, can introduce subtle yet significant effects. When an element is distorted from its ideal shape, the Jacobian of the mapping becomes anisotropic, meaning it warps space non-uniformly. This practice  provides a hands-on coding exercise to explore a critical consequence of this anisotropy: the misrepresentation of physical directions. You will quantify how element distortion can lead to errors in the computed orientation of a shear band, a vital concept for accurately simulating failure in geomaterials.",
            "id": "3535712",
            "problem": "You are asked to implement a program that quantifies how the computed shear band orientation in a bilinear quadrilateral isoparametric element is sensitive to element distortion, when a naive procedure ignores the anisotropy introduced by the isoparametric mapping. Work in two dimensions under small strains. The fundamental base shall consist of the isoparametric mapping with bilinear shape functions for a four-node quadrilateral element, the small-strain kinematics, and the transformation of gradients by the Jacobian matrix.\n\nConsider a four-node bilinear isoparametric quadrilateral element (often denoted as a $Q_4$ element). Let the parent coordinates be $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$. The parent-to-physical mapping is defined by the bilinear interpolation\n$$\n\\mathbf{x}(\\xi,\\eta) \\;=\\; \\sum_{a=1}^{4} N_a(\\xi,\\eta)\\,\\mathbf{x}_a,\n$$\nwhere $\\mathbf{x}_a = [x_a,y_a]^T$ are the physical coordinates of node $a$, and $N_a(\\xi,\\eta)$ are the standard bilinear shape functions. The Jacobian matrix at a point $(\\xi,\\eta)$ is\n$$\n\\mathbf{J}(\\xi,\\eta) \\;=\\; \\frac{\\partial \\mathbf{x}}{\\partial(\\xi,\\eta)} \\;=\\; \\begin{bmatrix}\n\\sum_{a=1}^{4} x_a\\,\\frac{\\partial N_a}{\\partial \\xi}  \\sum_{a=1}^{4} x_a\\,\\frac{\\partial N_a}{\\partial \\eta} \\\\\n\\sum_{a=1}^{4} y_a\\,\\frac{\\partial N_a}{\\partial \\xi}  \\sum_{a=1}^{4} y_a\\,\\frac{\\partial N_a}{\\partial \\eta}\n\\end{bmatrix}.\n$$\nIn small-strain kinematics, spatial gradients transform via $\\nabla_{\\mathbf{x}} = \\mathbf{J}^{-T}\\,\\nabla_{(\\xi,\\eta)}$. Consequently, spatial directions are affected by the anisotropy of $\\mathbf{J}$.\n\nSuppose a true physical shear band normal is specified by a unit vector $\\mathbf{n}_0 = [\\cos\\theta_0,\\sin\\theta_0]^T$ in physical space. A naive discrete procedure that ignores the anisotropy of the isoparametric mapping may erroneously treat $\\mathbf{n}_0$ as if it were a parent-space normal and then map it to physical space by the gradient transformation, thereby predicting a normal\n$$\n\\widehat{\\mathbf{n}} \\;\\propto\\; \\mathbf{J}^{-T}\\,\\mathbf{n}_0,\n$$\nnormalized to unit length. The resulting orientation error is defined by the smallest physical angle between $\\mathbf{n}_0$ and $\\widehat{\\mathbf{n}}$,\n$$\n\\Delta\\theta \\;=\\; \\arccos\\left(\\big|\\mathbf{n}_0\\cdot \\widehat{\\mathbf{n}}\\big|\\right),\n$$\nwhich lies in $[0,\\pi/2]$ due to the line-normal symmetry. This error is driven by the anisotropy and skewness of the Jacobian and, through the chain rule in the isoparametric formulation, by the corresponding skewness in the strain-displacement matrix. For interpretive analysis, define the metric tensor\n$$\n\\mathbf{M} \\;=\\; \\mathbf{J}^{-T}\\,\\mathbf{J}^{-1},\n$$\nwhose eigenvalues quantify the anisotropy of direction mapping. An anisotropy index can be defined as\n$$\n\\rho \\;=\\; \\sqrt{\\frac{\\lambda_{\\max}(\\mathbf{M})}{\\lambda_{\\min}(\\mathbf{M})}},\n$$\nand a skewness index as\n$$\ns \\;=\\; \\frac{|M_{12}|}{\\sqrt{M_{11}\\,M_{22}}}.\n$$\nThese indices do not need to be printed; they provide a means to relate distortion to orientation errors.\n\nUse the element centroid $(\\xi,\\eta)=(0,0)$ for all computations. At this point, the derivatives of the standard bilinear shape functions are\n$$\n\\left.\\frac{\\partial N}{\\partial \\xi}\\right|_{(0,0)} \\;=\\; \\left[-\\frac{1}{4},\\,\\frac{1}{4},\\,\\frac{1}{4},\\,-\\frac{1}{4}\\right],\\quad\n\\left.\\frac{\\partial N}{\\partial \\eta}\\right|_{(0,0)} \\;=\\; \\left[-\\frac{1}{4},\\,-\\frac{1}{4},\\,\\frac{1}{4},\\,\\frac{1}{4}\\right].\n$$\n\nImplement a program that, for the test suite below, computes the list of orientation errors $\\Delta\\theta$ (expressed in degrees) corresponding to each element and each target true orientation $\\theta_0$. Use the following test suite.\n\n- Element $E_0$ (square, in meters): node coordinates ordered as $a=1,2,3,4$ corresponding to parent nodes $(\\xi,\\eta)=(-1,-1),(1,-1),(1,1),(-1,1)$,\n$$\n[(0,0),(1,0),(1,1),(0,1)].\n$$\n- Element $E_1$ (rectangle with aspect ratio, in meters):\n$$\n[(0,0),(2,0),(2,1),(0,1)].\n$$\n- Element $E_2$ (skewed parallelogram, in meters):\n$$\n[(0,0),(2,0.2),(2,1.2),(0,1)].\n$$\n\nFor each element, evaluate four true physical shear band orientation angles (in radians) at the centroid:\n$$\n\\theta_0 \\in \\left\\{0,\\,\\frac{\\pi}{8},\\,\\frac{\\pi}{4},\\,\\frac{3\\pi}{8}\\right\\}.\n$$\nFor each pair of element and $\\theta_0$, compute $\\Delta\\theta$ in degrees and round to six decimal places. Use the following angle unit specification: all input angles are in radians; the required outputs are in degrees.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by element then by angle in the sequence above, namely:\n$$\n[E_0\\text{ with }\\theta_0=0,\\; E_0\\text{ with }\\theta_0=\\pi/8,\\; E_0\\text{ with }\\theta_0=\\pi/4,\\; E_0\\text{ with }\\theta_0=3\\pi/8,\\; E_1\\text{ with the same four angles},\\; E_2\\text{ with the same four angles}].\n$$\nEach entry must be a float rounded to six decimal places.\n\nAll physical coordinates are in meters. The final answers (orientation errors) must be expressed in degrees, rounded to six decimal places. The final output format must be exactly a single line of the form\n$$\n[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_{12}].\n$$",
            "solution": "The problem is valid as it presents a well-defined, scientifically grounded problem in computational mechanics. All necessary data and mathematical formulations are provided, leading to a unique and verifiable solution. The task is to compute the orientation error, $\\Delta\\theta$, for a shear band normal in a bilinear quadrilateral isoparametric element when a naive computation ignores the mapping-induced anisotropy.\n\nThe procedure to calculate the orientation error $\\Delta\\theta$ for each given element and true orientation angle $\\theta_0$ is as follows. All computations are performed at the element centroid, where the parent coordinates are $(\\xi,\\eta)=(0,0)$.\n\nFirst, we establish the element geometry and the necessary derivatives. For a four-node quadrilateral element with nodal coordinates $\\mathbf{x}_a = [x_a, y_a]^T$ for $a=1,2,3,4$, the Jacobian matrix $\\mathbf{J}$ of the isoparametric mapping $\\mathbf{x}(\\xi,\\eta)$ is computed at the centroid. The components of the Jacobian are given by:\n$$\nJ_{ij} = \\sum_{a=1}^{4} \\frac{\\partial N_a}{\\partial \\xi_j} x_{ai}\n$$\nwhere $i,j \\in \\{1,2\\}$, $(\\xi_1, \\xi_2) = (\\xi, \\eta)$, and $(x_{a1}, x_{a2}) = (x_a, y_a)$. At the element centroid $(\\xi,\\eta)=(0,0)$, the derivatives of the bilinear shape functions $N_a$ are provided:\n$$\n\\left.\\frac{\\partial N}{\\partial \\xi}\\right|_{(0,0)} = \\left[-\\frac{1}{4},\\,\\frac{1}{4},\\,\\frac{1}{4},\\,-\\frac{1}{4}\\right]\n$$\n$$\n\\left.\\frac{\\partial N}{\\partial \\eta}\\right|_{(0,0)} = \\left[-\\frac{1}{4},\\,-\\frac{1}{4},\\,\\frac{1}{4},\\,\\frac{1}{4}\\right]\n$$\nThe node ordering $a=1,2,3,4$ corresponds to the parent-space corners $(-1,-1), (1,-1), (1,1), (-1,1)$, respectively. Using these values and the given nodal coordinates for each element, the $2 \\times 2$ Jacobian matrix $\\mathbf{J}$ is assembled.\n\nSecond, the true physical shear band normal is defined by a unit vector $\\mathbf{n}_0$ for a given orientation angle $\\theta_0$:\n$$\n\\mathbf{n}_0 = \\begin{bmatrix} \\cos\\theta_0 \\\\ \\sin\\theta_0 \\end{bmatrix}\n$$\n\nThird, we determine the erroneously predicted normal, $\\widehat{\\mathbf{n}}$. A naive procedure treats $\\mathbf{n}_0$ as if it were a vector in the parent space and transforms it to the physical space using the same rule as for gradients, i.e., via the inverse-transpose Jacobian $\\mathbf{J}^{-T}$. This gives a predicted (but un-normalized) vector $\\mathbf{v}$:\n$$\n\\mathbf{v} = \\mathbf{J}^{-T} \\mathbf{n}_0\n$$\nTo calculate $\\mathbf{J}^{-T}$, we first compute the matrix inverse $\\mathbf{J}^{-1}$ and then its transpose $(\\mathbf{J}^{-1})^T$. The predicted normal direction is then found by normalizing $\\mathbf{v}$:\n$$\n\\widehat{\\mathbf{n}} = \\frac{\\mathbf{v}}{||\\mathbf{v}||}\n$$\n\nFourth, the orientation error $\\Delta\\theta$ is the smallest physical angle between the true normal $\\mathbf{n}_0$ and the predicted normal $\\widehat{\\mathbf{n}}$. This is calculated using the dot product:\n$$\n\\cos(\\Delta\\theta_{abs}) = \\mathbf{n}_0 \\cdot \\widehat{\\mathbf{n}}\n$$\nThe problem specifies the error as being in the range $[0, \\pi/2]$, which corresponds to the angle between the lines defined by the normals. This is achieved by taking the absolute value of the dot product before applying the arccosine function:\n$$\n\\Delta\\theta_{\\text{rad}} = \\arccos\\left(\\left|\\mathbf{n}_0 \\cdot \\widehat{\\mathbf{n}}\\right|\\right)\n$$\nFinally, the result is converted from radians to degrees:\n$$\n\\Delta\\theta_{\\text{deg}} = \\Delta\\theta_{\\text{rad}} \\times \\frac{180^\\circ}{\\pi}\n$$\nThis procedure is repeated for each element ($E_0$, $E_1$, $E_2$) and each specified angle $\\theta_0 \\in \\{0, \\pi/8, \\pi/4, 3\\pi/8\\}$. The resulting value of $\\Delta\\theta_{\\text{deg}}$ is rounded to six decimal places.\n\nFor an undistorted element like the square $E_0$, the Jacobian at the centroid is isotropic, i.e., $\\mathbf{J} = c\\mathbf{I}$ where $c$ is a scalar and $\\mathbf{I}$ is the identity matrix. In this case, $\\mathbf{J}^{-T} = (1/c)\\mathbf{I}$, and the transformation simply scales the vector $\\mathbf{n}_0$. Normalization removes this scaling, so $\\widehat{\\mathbf{n}} = \\mathbf{n}_0$, resulting in zero error, $\\Delta\\theta = 0$. For distorted elements, $\\mathbf{J}$ is not a scaled identity matrix, leading to a non-zero orientation error that depends on both the element distortion and the initial angle $\\theta_0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the shear band orientation error due to naive isoparametric mapping.\n    \"\"\"\n    # Define the derivatives of the shape functions at the centroid (xi, eta) = (0, 0).\n    # dN/d_xi for nodes 1, 2, 3, 4\n    dN_dxi = np.array([-0.25, 0.25, 0.25, -0.25])\n    # dN/d_eta for nodes 1, 2, 3, 4\n    dN_deta = np.array([-0.25, -0.25, 0.25, 0.25])\n\n    # Node ordering a=1,2,3,4 corresponds to parent nodes (xi,eta)=(-1,-1),(1,-1),(1,1),(-1,1).\n    # Element E0 (square)\n    E0_coords = (np.array([0., 1., 1., 0.]), np.array([0., 0., 1., 1.]))\n    # Element E1 (rectangle)\n    E1_coords = (np.array([0., 2., 2., 0.]), np.array([0., 0., 1., 1.]))\n    # Element E2 (skewed parallelogram)\n    E2_coords = (np.array([0., 2., 2., 0.]), np.array([0., 0.2, 1.2, 1.]))\n\n    # Define the test suite of elements and orientation angles.\n    elements = [E0_coords, E1_coords, E2_coords]\n    thetas = [0., np.pi/8, np.pi/4, 3*np.pi/8]\n\n    results = []\n\n    for x_coords, y_coords in elements:\n        # Calculate the Jacobian matrix J at the centroid.\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(x_coords, dN_dxi)\n        J[0, 1] = np.dot(x_coords, dN_deta)\n        J[1, 0] = np.dot(y_coords, dN_dxi)\n        J[1, 1] = np.dot(y_coords, dN_deta)\n\n        # Calculate the inverse-transpose of the Jacobian.\n        try:\n            J_inv_T = np.linalg.inv(J).T\n        except np.linalg.LinAlgError:\n            # Handle singular Jacobian if necessary, though not expected for these elements.\n            # For a singular matrix, we would have infinite error, but this case is invalid.\n            # For this problem, we can assume J is always invertible.\n            results.extend([float('nan')] * len(thetas))\n            continue\n\n        for theta_0 in thetas:\n            # Define the true physical normal vector n_0.\n            n0 = np.array([np.cos(theta_0), np.sin(theta_0)])\n\n            # Calculate the predicted normal vector n_hat.\n            # v is the un-normalized predicted vector.\n            v = J_inv_T @ n0\n            \n            # Normalize v to get the unit vector n_hat.\n            norm_v = np.linalg.norm(v)\n            if norm_v  1e-15: # handles potential division by zero\n                # This case implies n_0 is in the null space of J_inv_T, error is ill-defined\n                # or can be considered max (90 degrees). For this problem, it won't occur.\n                delta_theta_deg = 90.0\n            else:\n                n_hat = v / norm_v\n\n                # Calculate the orientation error delta_theta.\n                # The dot product between two unit vectors is the cosine of the angle between them.\n                # We take the absolute value as per the problem to get the smallest angle in [0, pi/2].\n                cos_delta_theta = np.abs(np.dot(n0, n_hat))\n\n                # Clip the value to be within [-1, 1] to avoid domain errors in arccos\n                # due to floating point inaccuracies.\n                cos_delta_theta = np.clip(cos_delta_theta, -1.0, 1.0)\n                \n                delta_theta_rad = np.arccos(cos_delta_theta)\n                delta_theta_deg = np.rad2deg(delta_theta_rad)\n\n            # Round the result to six decimal places and append to the list.\n            results.append(round(delta_theta_deg, 6))\n\n    # Format the final output as a single line: [result1,result2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Standard low-order finite elements often perform poorly when modeling nearly incompressible materials, a common scenario in geomechanics involving undrained soils or saturated rock. This issue, known as volumetric locking, leads to overly stiff behavior and inaccurate stress fields. This advanced practice  guides you through implementing and testing a solution: enriching an eight-node element ($Q_8$) with an internal 'bubble' function. By kinematically evaluating the improvement in volumetric strain approximation, you will see firsthand how element technology can be enhanced to overcome fundamental numerical challenges.",
            "id": "3535676",
            "problem": "You are asked to design and implement a program that evaluates the effect of bubble enrichment on the volumetric strain approximation of an isoparametric eight-node quadrilateral element ($Q_8$) used in the Finite Element Method (FEM) for computational geomechanics. The investigation is motivated by near-incompressible unloading scenarios, where volumetric locking can degrade the quality of the volumetric strain field. Your program must work purely at the kinematic level: for a prescribed smooth exact displacement field, compare the $L^2$-norm of the volumetric strain error of a standard isoparametric $Q_8$ interpolation against an enriched interpolation that adds a single internal bubble mode. The comparison must be performed using isoparametric mapping and numerical quadrature over distorted physical elements.\n\nStart from the following fundamental bases:\n- Kinematics of small strains: the volumetric strain is the divergence of displacement, $\\varepsilon_v = \\nabla \\cdot \\mathbf{u}$.\n- Isoparametric mapping: a mapping $\\mathcal{X}$ from the reference square $\\{(\\xi,\\eta) \\in [-1,1]^2\\}$ to a physical quadrilateral $\\Omega_e \\subset \\mathbb{R}^2$ is given by $Q_8$ shape functions $\\{N_i(\\xi,\\eta)\\}_{i=1}^8$ and physical node coordinates $\\{\\mathbf{X}_i\\}_{i=1}^8$, via $\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^8 N_i(\\xi,\\eta)\\,\\mathbf{X}_i$, with Jacobian $\\mathbf{J} = \\partial \\mathbf{x}/\\partial(\\xi,\\eta)$.\n- Finite element interpolation: the standard $Q_8$ displacement field is $\\mathbf{u}_h(\\xi,\\eta) = \\sum_{i=1}^8 N_i(\\xi,\\eta)\\,\\mathbf{d}_i$, where $\\mathbf{d}_i$ are the nodal displacement vectors. The bubble-enriched interpolation augments this with a single internal bubble mode $N_b(\\xi,\\eta)$ as $\\mathbf{u}_h^{\\text{enr}}(\\xi,\\eta) = \\sum_{i=1}^8 N_i(\\xi,\\eta)\\,\\mathbf{d}_i + N_b(\\xi,\\eta)\\,\\mathbf{c}$, where $\\mathbf{c} \\in \\mathbb{R}^2$ are additional internal parameters to be chosen locally to optimally reduce the volumetric strain error in an $L^2$ sense.\n\nYou must not assume any constitutive law; this is a purely kinematic approximation study. The exact displacement field models near-incompressible unloading through a divergence-free stream function part plus a small dilatational component. Define a scalar stream function $\\psi(x,y) = x^4 - 6x^2 y^2 + y^4$ and set the divergence-free part $\\mathbf{u}_s = \\left(\\dfrac{\\partial \\psi}{\\partial y},\\; -\\dfrac{\\partial \\psi}{\\partial x}\\right)$. Then define the exact displacement field\n$$\n\\mathbf{u}_{\\text{exact}}(x,y) = \\mathbf{u}_s(x,y) + \\varepsilon\\,\\begin{bmatrix} x \\\\ y \\end{bmatrix},\n$$\nso that the exact volumetric strain is the constant\n$$\n\\varepsilon_{v,\\text{exact}} = \\nabla \\cdot \\mathbf{u}_{\\text{exact}} = 2\\varepsilon.\n$$\nYou will prescribe nodal displacements by sampling $\\mathbf{u}_{\\text{exact}}$ at the physical node coordinates.\n\nFor the bubble enrichment, use the internal mode\n$$\nN_b(\\xi,\\eta) = (1-\\xi^2)(1-\\eta^2),\n$$\nand determine the internal vector $\\mathbf{c} = [c_x,c_y]^T$ by minimizing the quadratic functional\n$$\n\\mathcal{J}(\\mathbf{c}) = \\int_{\\Omega_e} \\left(\\nabla \\cdot \\mathbf{u}_h^{\\text{enr}} - \\varepsilon_{v,\\text{exact}}\\right)^2 \\, d\\Omega,\n$$\nsubject to keeping the nodal degrees of freedom fixed to the exact values (that is, $\\mathbf{c}$ is the only free parameter). Show that this reduces to solving a local symmetric positive-definite $2\\times 2$ linear system for $\\mathbf{c}$ derived from first-order optimality conditions using the chain rule through the isoparametric mapping. You must compute all integrals by Gaussian quadrature on the reference square, mapping to the physical element with the Jacobian determinant factor.\n\nImplement the isoparametric $Q_8$ shape functions $\\{N_i\\}$ on the reference square. The mid-edge nodes are located at $\\xi=0$ or $\\eta=0$ as appropriate, and the node order is\n$$\n(\\xi,\\eta):\\; (-1,-1),\\; (1,-1),\\; (1,1),\\; (-1,1),\\; (0,-1),\\; (1,0),\\; (0,1),\\; (-1,0).\n$$\nUse the inverse-transpose of the Jacobian to map parametric derivatives to physical gradients.\n\nYour program must evaluate the $L^2$-norm of the volumetric strain error for:\n- the standard $Q_8$ interpolation, and\n- the bubble-enriched interpolation with the optimal internal vector $\\mathbf{c}$,\nand report, for each test case, the ratio\n$$\nR = \\dfrac{\\left\\| \\nabla \\cdot \\mathbf{u}_h^{\\text{enr}} - \\varepsilon_{v,\\text{exact}} \\right\\|_{L^2(\\Omega_e)}}\n{\\left\\| \\nabla \\cdot \\mathbf{u}_h - \\varepsilon_{v,\\text{exact}} \\right\\|_{L^2(\\Omega_e)}}.\n$$\n\nAngle units are not involved. No physical units are required; all quantities are dimensionless.\n\nTest Suite:\nFor each case, define the physical corner nodes in counterclockwise order as $\\mathbf{X}_1,\\mathbf{X}_2,\\mathbf{X}_3,\\mathbf{X}_4$, and set the mid-side nodes as averages of adjacent corners to form an isoparametric $Q_8$ geometry. Use the following three cases with the specified $\\varepsilon$ values:\n- Case A (mild distortion, near-incompressible): corners\n  $\\mathbf{X}_1 = (-1.0,-1.0)$, $\\mathbf{X}_2 = (2.0,-1.0)$, $\\mathbf{X}_3 = (1.8,1.1)$, $\\mathbf{X}_4 = (-1.2,0.9)$; use $\\varepsilon = 10^{-3}$.\n- Case B (heavy distortion, very near-incompressible): corners\n  $\\mathbf{X}_1 = (-1.0,-1.0)$, $\\mathbf{X}_2 = (2.0,-0.5)$, $\\mathbf{X}_3 = (1.0,1.5)$, $\\mathbf{X}_4 = (-1.5,1.0)$; use $\\varepsilon = 10^{-6}$.\n- Case C (skewed, exactly incompressible): corners\n  $\\mathbf{X}_1 = (0.0,0.0)$, $\\mathbf{X}_2 = (2.0,0.2)$, $\\mathbf{X}_3 = (2.2,1.8)$, $\\mathbf{X}_4 = (-0.2,1.6)$; use $\\varepsilon = 0$.\n\nFor each case:\n1. Build the $Q_8$ node set with mid-side nodes $\\mathbf{X}_5 = (\\mathbf{X}_1+\\mathbf{X}_2)/2$, $\\mathbf{X}_6 = (\\mathbf{X}_2+\\mathbf{X}_3)/2$, $\\mathbf{X}_7 = (\\mathbf{X}_3+\\mathbf{X}_4)/2$, $\\mathbf{X}_8 = (\\mathbf{X}_4+\\mathbf{X}_1)/2$.\n2. Sample $\\mathbf{u}_{\\text{exact}}$ at all $\\mathbf{X}_i$ to obtain nodal values.\n3. Compute the $L^2$ error norms and the ratio $R$ as defined above using Gaussian quadrature with sufficiently many points to integrate the polynomials and mapping accurately.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases A, B, C. Specifically, output a single list with three floating-point numbers $[R_A,R_B,R_C]$.",
            "solution": "The problem asks for a quantitative comparison between a standard eight-node isoparametric quadrilateral element ($Q_8$) and a version enriched with an internal bubble function. The comparison is to be performed at the kinematic level by evaluating the accuracy of the volumetric strain approximation for a prescribed exact displacement field. The metric for comparison is the ratio of the $L^2$-norms of the volumetric strain error for the enriched versus the standard formulation.\n\nFirst, we establish the theoretical framework for the finite element formulation and the error analysis.\n\n**1. Isoparametric $Q_8$ Element and Strain Approximation**\n\nThe geometry of a physical element domain $\\Omega_e \\subset \\mathbb{R}^2$ is mapped from a master square element defined by reference coordinates $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$. The mapping is given by the $Q_8$ shape functions $\\{N_i(\\xi, \\eta)\\}_{i=1}^8$ and the physical coordinates of the element's eight nodes, $\\{\\mathbf{X}_i\\}_{i=1}^8$:\n$$\n\\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta) \\mathbf{X}_i\n$$\nThe standard isoparametric formulation uses the same shape functions to interpolate the displacement field $\\mathbf{u}_h$ from the nodal displacement vectors $\\{\\mathbf{d}_i\\}_{i=1}^8$:\n$$\n\\mathbf{u}_h(\\xi, \\eta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta) \\mathbf{d}_i\n$$\nThe volumetric strain is the divergence of the displacement field, $\\varepsilon_v = \\nabla \\cdot \\mathbf{u}$. To compute this for the approximate field $\\mathbf{u}_h$, we require gradients with respect to the physical coordinates $(x, y)$. These are obtained from gradients in the reference coordinates $(\\xi, \\eta)$ using the chain rule, which involves the inverse of the Jacobian matrix of the geometric mapping, $\\mathbf{J}$:\n$$\n\\mathbf{J} = \\frac{\\partial \\mathbf{x}}{\\partial (\\xi, \\eta)} = \\begin{bmatrix} \\partial x / \\partial \\xi  \\partial x / \\partial \\eta \\\\ \\partial y / \\partial \\xi  \\partial y / \\partial \\eta \\end{bmatrix} \\quad \\implies \\quad \\begin{Bmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{Bmatrix} = \\mathbf{J}^{-T} \\begin{Bmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{Bmatrix}\n$$\nThe approximate volumetric strain $\\varepsilon_v^h$ is then:\n$$\n\\varepsilon_v^h = \\nabla \\cdot \\mathbf{u}_h = \\frac{\\partial u_{hx}}{\\partial x} + \\frac{\\partial u_{hy}}{\\partial y} = \\sum_{i=1}^{8} \\left( \\frac{\\partial N_i}{\\partial x} d_{ix} + \\frac{\\partial N_i}{\\partial y} d_{iy} \\right) = \\sum_{i=1}^{8} (\\nabla N_i) \\cdot \\mathbf{d}_i\n$$\nwhere $\\nabla N_i = [\\partial N_i/\\partial x, \\partial N_i/\\partial y]^T$ are computed using the aforementioned transformation.\n\n**2. Exact Displacement Field and Volumetric Strain**\n\nThe problem provides an exact displacement field $\\mathbf{u}_{\\text{exact}}(x,y)$ to serve as a benchmark. It is constructed from a stream function $\\psi(x,y) = x^4 - 6x^2 y^2 + y^4$, which defines a divergence-free component $\\mathbf{u}_s = (\\partial\\psi/\\partial y, -\\partial\\psi/\\partial x)$, and a small dilatational component:\n$$\n\\mathbf{u}_{\\text{exact}}(x,y) = \\mathbf{u}_s(x,y) + \\varepsilon \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} -12x^2 y + 4y^3 + \\varepsilon x \\\\ -4x^3 + 12xy^2 + \\varepsilon y \\end{bmatrix}\n$$\nThe divergence of the stream function component is $\\nabla \\cdot \\mathbf{u}_s = \\frac{\\partial^2\\psi}{\\partial x \\partial y} - \\frac{\\partial^2\\psi}{\\partial y \\partial x} = 0$. Therefore, the exact volumetric strain is constant throughout the domain:\n$$\n\\varepsilon_{v,\\text{exact}} = \\nabla \\cdot \\mathbf{u}_{\\text{exact}} = \\nabla \\cdot \\left(\\varepsilon \\begin{bmatrix} x \\\\ y \\end{bmatrix}\\right) = \\frac{\\partial(\\varepsilon x)}{\\partial x} + \\frac{\\partial(\\varepsilon y)}{\\partial y} = 2\\varepsilon\n$$\nThe nodal displacements $\\mathbf{d}_i$ for the finite element approximation are prescribed by sampling this exact field at the element nodes: $\\mathbf{d}_i = \\mathbf{u}_{\\text{exact}}(\\mathbf{X}_i)$.\n\n**3. Bubble-Enriched Formulation**\n\nTo improve the element's performance, particularly in representing volumetric strains, the standard interpolation is augmented with an internal \"bubble\" mode. The enriched displacement field $\\mathbf{u}_h^{\\text{enr}}$ is:\n$$\n\\mathbf{u}_h^{\\text{enr}}(\\xi,\\eta) = \\mathbf{u}_h(\\xi, \\eta) + N_b(\\xi, \\eta) \\mathbf{c} = \\sum_{i=1}^8 N_i(\\xi,\\eta)\\,\\mathbf{d}_i + N_b(\\xi,\\eta)\\,\\mathbf{c}\n$$\nwhere $N_b(\\xi, \\eta) = (1-\\xi^2)(1-\\eta^2)$ is the bubble shape function, which vanishes on the element boundary, thus not altering the prescribed nodal displacements. The vector $\\mathbf{c} = [c_x, c_y]^T$ contains the amplitudes of the bubble mode, which are internal degrees of freedom. The enriched volumetric strain is:\n$$\n\\varepsilon_v^{\\text{enr}} = \\nabla \\cdot \\mathbf{u}_h^{\\text{enr}} = \\nabla \\cdot \\mathbf{u}_h + \\nabla \\cdot (N_b \\mathbf{c}) = \\varepsilon_v^h + (\\nabla N_b) \\cdot \\mathbf{c}\n$$\n\n**4. Optimal Bubble Coefficients**\n\nThe coefficients $\\mathbf{c}$ are determined locally for each element by minimizing the squared $L^2$-norm of the volumetric strain error. This involves minimizing the functional $\\mathcal{J}(\\mathbf{c})$:\n$$\n\\mathcal{J}(\\mathbf{c}) = \\int_{\\Omega_e} \\left( \\varepsilon_v^{\\text{enr}} - \\varepsilon_{v,\\text{exact}} \\right)^2 d\\Omega = \\int_{\\Omega_e} \\left( (\\varepsilon_v^h - \\varepsilon_{v,\\text{exact}}) + (\\nabla N_b) \\cdot \\mathbf{c} \\right)^2 d\\Omega\n$$\nLet $e_v = \\varepsilon_v^h - \\varepsilon_{v,\\text{exact}}$ be the error of the standard formulation and let the vector of bubble function gradients be $\\mathbf{B} = \\nabla N_b$. The functional becomes $\\mathcal{J}(\\mathbf{c}) = \\int_{\\Omega_e} (e_v + \\mathbf{B}^T \\mathbf{c})^2 d\\Omega$. The first-order optimality condition, $\\partial \\mathcal{J} / \\partial \\mathbf{c} = \\mathbf{0}$, leads to:\n$$\n\\frac{\\partial \\mathcal{J}}{\\partial \\mathbf{c}} = \\int_{\\Omega_e} 2 (e_v + \\mathbf{B}^T \\mathbf{c}) \\mathbf{B} \\,d\\Omega = \\mathbf{0}\n$$\nRearranging gives the $2 \\times 2$ symmetric linear system $\\mathbf{H} \\mathbf{c} = \\mathbf{f}$:\n$$\n\\left( \\int_{\\Omega_e} \\mathbf{B} \\mathbf{B}^T d\\Omega \\right) \\mathbf{c} = - \\int_{\\Omega_e} \\mathbf{B} e_v d\\Omega\n$$\nwhere $\\mathbf{H} = \\int_{\\Omega_e} \\mathbf{B} \\mathbf{B}^T d\\Omega$ is symmetric and positive-definite for non-degenerate elements, and $\\mathbf{f} = - \\int_{\\Omega_e} \\mathbf{B} e_v d\\Omega$. Solving this system yields the optimal coefficients $\\mathbf{c}$ that minimize the volumetric strain error in an $L^2$ sense.\n\n**5. Numerical Evaluation**\n\nThe solution requires computing integrals over distorted physical element domains. These are handled by transforming the integrals to the reference square and using numerical quadrature. The differential area element transforms as $d\\Omega = \\det(\\mathbf{J}) d\\xi d\\eta$. A $4 \\times 4$ Gaussian quadrature rule is employed for accuracy, as the integrands are rational functions of $\\xi$ and $\\eta$.\n\nThe algorithm for each test case is as follows:\n1.  Define the $8$ nodal coordinates $\\mathbf{X}_i$ for the element.\n2.  Calculate the $8$ nodal displacement vectors $\\mathbf{d}_i = \\mathbf{u}_{\\text{exact}}(\\mathbf{X}_i)$.\n3.  Initialize integrals for the standard error norm squared ($\\|e_v\\|^2_{L^2}$), the matrix $\\mathbf{H}$, and the vector $\\mathbf{f}$.\n4.  Loop over the $4 \\times 4 = 16$ quadrature points $(\\xi_q, \\eta_q)$:\n    a. Compute the Jacobian $\\mathbf{J}$, its determinant $\\det(\\mathbf{J})$, and its inverse $\\mathbf{J}^{-1}$ at the point.\n    b. Calculate the standard approximate strain $\\varepsilon_v^h$ and its error $e_v = \\varepsilon_v^h - 2\\varepsilon$.\n    c. Accumulate the integral for $\\|e_v\\|^2_{L^2} = \\int e_v^2 d\\Omega$.\n    d. Compute the physical gradient of the bubble function, $\\mathbf{B} = \\nabla N_b$.\n    e. Accumulate the integrals for $\\mathbf{H}$ and $\\mathbf{f}$.\n5.  After the loop, solve the system $\\mathbf{H} \\mathbf{c} = \\mathbf{f}$ for $\\mathbf{c}$.\n6.  Calculate the $L^2$-norm of the enriched error, $\\|e_v^{\\text{enr}}\\|_{L^2} = \\left( \\int (e_v + \\mathbf{B}^T\\mathbf{c})^2 d\\Omega \\right)^{1/2}$, by another pass over the quadrature points (or by using stored intermediate values).\n7.  Compute the final ratio $R = \\|e_v^{\\text{enr}}\\|_{L^2} / \\|e_v\\|_{L^2}$.\n\nThis procedure is applied to each of the three specified test cases (A, B, and C), yielding the requested ratios of error norms.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def shape_functions_Q8(xi, eta):\n        \"\"\"\n        Computes the Q8 shape functions and their derivatives at a point (xi, eta).\n        Node order is corners CCW starting from (-1,-1), then midsides starting from bottom edge.\n        1:(-1,-1), 2:(1,-1), 3:(1,1), 4:(-1,1), 5:(0,-1), 6:(1,0), 7:(0,1), 8:(-1,0)\n        \"\"\"\n        N = np.zeros(8)\n        dNdxi = np.zeros(8)\n        dNdeta = np.zeros(8)\n        \n        # Local coordinates of corner nodes\n        xi_n = np.array([-1.0, 1.0, 1.0, -1.0])\n        eta_n = np.array([-1.0, -1.0, 1.0, 1.0])\n        \n        # Corner nodes (i=0 to 3)\n        for i in range(4):\n            x_i, e_i = xi_n[i], eta_n[i]\n            \n            term1 = (1.0 + x_i * xi) * (1.0 + e_i * eta)\n            dterm1_dxi = x_i * (1.0 + e_i * eta)\n            dterm1_deta = e_i * (1.0 + x_i * xi)\n            \n            term2 = (x_i * xi + e_i * eta - 1.0)\n            dterm2_dxi = x_i\n            dterm2_deta = e_i\n\n            N[i] = 0.25 * term1 * term2\n            dNdxi[i] = 0.25 * (dterm1_dxi * term2 + term1 * dterm2_dxi)\n            dNdeta[i] = 0.25 * (dterm1_deta * term2 + term1 * dterm2_deta)\n\n        # Midside nodes (i=4 to 7)\n        # Node 5 (index 4): (0,-1)\n        N[4] = 0.5 * (1.0 - xi**2) * (1.0 - eta)\n        dNdxi[4] = -xi * (1.0 - eta)\n        dNdeta[4] = -0.5 * (1.0 - xi**2)\n\n        # Node 6 (index 5): (1,0)\n        N[5] = 0.5 * (1.0 + xi) * (1.0 - eta**2)\n        dNdxi[5] = 0.5 * (1.0 - eta**2)\n        dNdeta[5] = -eta * (1.0 + xi)\n\n        # Node 7 (index 6): (0,1)\n        N[6] = 0.5 * (1.0 - xi**2) * (1.0 + eta)\n        dNdxi[6] = -xi * (1.0 + eta)\n        dNdeta[6] = 0.5 * (1.0 - xi**2)\n        \n        # Node 8 (index 7): (-1,0)\n        N[7] = 0.5 * (1.0 - xi) * (1.0 - eta**2)\n        dNdxi[7] = -0.5 * (1.0 - eta**2)\n        dNdeta[7] = -eta * (1.0 - xi)\n        \n        return N, dNdxi, dNdeta\n\n    def bubble_function(xi, eta):\n        \"\"\"Computes the bubble function and its derivatives at (xi, eta).\"\"\"\n        Nb = (1.0 - xi**2) * (1.0 - eta**2)\n        dNb_dxi = -2.0 * xi * (1.0 - eta**2)\n        dNb_deta = -2.0 * eta * (1.0 - xi**2)\n        return Nb, dNb_dxi, dNb_deta\n\n    def exact_displacement(x, y, epsilon):\n        \"\"\"Computes the exact displacement u(x,y).\"\"\"\n        ux = -12.0 * x**2 * y + 4.0 * y**3 + epsilon * x\n        uy = -4.0 * x**3 + 12.0 * x * y**2 + epsilon * y\n        return np.array([ux, uy])\n\n    def solve_case(corners, epsilon):\n        \"\"\"Computes the error ratio R for a single test case.\"\"\"\n        # 1. Build Q8 node set\n        X_corners = np.array(corners, dtype=float)\n        X_midsides = np.array([\n            0.5 * (X_corners[0] + X_corners[1]),\n            0.5 * (X_corners[1] + X_corners[2]),\n            0.5 * (X_corners[2] + X_corners[3]),\n            0.5 * (X_corners[3] + X_corners[0]),\n        ])\n        X_nodes = np.vstack((X_corners, X_midsides))\n        \n        # 2. Sample exact displacements at nodes\n        d_nodes = np.array([exact_displacement(x, y, epsilon) for x, y in X_nodes])\n        \n        # 3. Setup numerical quadrature (4x4 Gauss-Legendre)\n        quad_order = 4\n        xi_q, w_q = np.polynomial.legendre.leggauss(quad_order)\n        \n        # 4. Integrate to find H, f, and standard error norm\n        norm_sq_std = 0.0\n        H = np.zeros((2, 2))\n        f = np.zeros(2)\n        \n        quad_point_data = [] # Store data to avoid a second loop\n\n        for i in range(quad_order):\n            for j in range(quad_order):\n                xi, eta = xi_q[i], xi_q[j]\n                weight = w_q[i] * w_q[j]\n                \n                _, dN_dxi, dN_deta = shape_functions_Q8(xi, eta)\n                \n                J = np.zeros((2, 2))\n                J[0, 0] = np.dot(dN_dxi, X_nodes[:, 0])\n                J[1, 0] = np.dot(dN_dxi, X_nodes[:, 1])\n                J[0, 1] = np.dot(dN_deta, X_nodes[:, 0])\n                J[1, 1] = np.dot(dN_deta, X_nodes[:, 1])\n\n                detJ = np.linalg.det(J)\n                if detJ = 1e-12:\n                    raise ValueError(\"Jacobian is zero or negative.\")\n                \n                # Gradients w.r.t physical coordinates (x,y)\n                grad_op_local = np.vstack((dN_dxi, dN_deta))\n                grad_op_phys = np.linalg.inv(J).T @ grad_op_local\n\n                # Standard approximate volumetric strain\n                eps_v_h = np.sum(grad_op_phys[0, :] * d_nodes[:, 0] + grad_op_phys[1, :] * d_nodes[:, 1])\n                \n                eps_v_exact = 2.0 * epsilon\n                error_std = eps_v_h - eps_v_exact\n\n                norm_sq_std += error_std**2 * detJ * weight\n                \n                # Bubble enrichment calculations\n                _, dNb_dxi, dNb_deta = bubble_function(xi, eta)\n                B_ref = np.array([dNb_dxi, dNb_deta])\n                B_phys = np.linalg.inv(J).T @ B_ref\n                \n                H += np.outer(B_phys, B_phys) * detJ * weight\n                f += -B_phys * error_std * detJ * weight\n\n                quad_point_data.append({\n                    'error_std': error_std,\n                    'B_phys': B_phys,\n                    'w_detJ': weight * detJ\n                })\n\n        # 5. Solve for optimal bubble coefficients c\n        try:\n            c = np.linalg.solve(H, f)\n        except np.linalg.LinAlgError:\n            c = np.zeros(2) # H is singular, no unique solution, take c=0\n\n        # 6. Compute enriched error norm\n        norm_sq_enr = 0.0\n        for data in quad_point_data:\n            error_enr = data['error_std'] + np.dot(data['B_phys'], c)\n            norm_sq_enr += error_enr**2 * data['w_detJ']\n\n        # 7. Final norms and ratio\n        norm_std = np.sqrt(norm_sq_std)\n        norm_enr = np.sqrt(norm_sq_enr)\n\n        if norm_std  1e-15:\n            # If standard error is zero, enriched is also zero. No change.\n            return 1.0\n\n        return norm_enr / norm_std\n\n    test_cases = [\n        # Case A (mild distortion, near-incompressible)\n        {'corners': [(-1.0, -1.0), (2.0, -1.0), (1.8, 1.1), (-1.2, 0.9)], 'epsilon': 1e-3},\n        # Case B (heavy distortion, very near-incompressible)\n        {'corners': [(-1.0, -1.0), (2.0, -0.5), (1.0, 1.5), (-1.5, 1.0)], 'epsilon': 1e-6},\n        # Case C (skewed, exactly incompressible)\n        {'corners': [(0.0, 0.0), (2.0, 0.2), (2.2, 1.8), (-0.2, 1.6)], 'epsilon': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = solve_case(case['corners'], case['epsilon'])\n        results.append(ratio)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}