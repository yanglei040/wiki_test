{
    "hands_on_practices": [
        {
            "introduction": "理解弹塑性行为最清晰的方式是从最简单的一维情况入手。本练习将引导你分析一个单轴受力杆的基本力学响应。通过从第一性原理出发，你将亲手推导弹性应变和塑性应变的演化过程，并确定塑性流动开始的精确时刻，从而牢固掌握应变分解、屈服条件和流动法则等速率无关塑性理论的核心概念 。",
            "id": "3554857",
            "problem": "考虑一根由均质岩土材料制成的棱柱形单轴杆，处于小应变、等温条件下。该材料遵循一维的率无关理想塑性模型，具有应变加和分解 $\\,\\epsilon = \\epsilon^{e} + \\epsilon^{p}\\,$、线性弹性关系 $\\,\\sigma = E\\,\\epsilon^{e}\\,$ 以及屈服函数 $\\,f(\\sigma) = |\\sigma| - Y\\,$，其中屈服应力 $\\,Y  0\\,$ 为常数。塑性流动是关联的且率无关的，满足 Kuhn–Tucker 条件 $\\,\\lambda \\ge 0\\,$, $\\,f(\\sigma) \\le 0\\,$, $\\,\\lambda\\,f(\\sigma) = 0\\,$，以及塑性应变率 $\\,\\dot{\\epsilon}^{p} = \\lambda\\,\\partial f/\\partial \\sigma\\,$. 假设一个单调拉伸应变历史，因此在塑性加载期间 $\\,\\sigma \\ge 0\\,$ 且 $\\,\\partial f/\\partial \\sigma = 1\\,$.\n\n给定的总应变为 $\\,\\epsilon(t) = \\alpha\\,t\\,$，其中 $\\,t \\in [0,T]\\,$ 且 $\\,\\epsilon(0) = 0\\,$. 参数为 $\\,E = 100\\,\\mathrm{MPa}\\,$, $\\,Y = 1\\,\\mathrm{MPa}\\,$, $\\,\\alpha = 0.005\\,\\mathrm{s}^{-1}\\,$ 以及 $\\,T = 10\\,\\mathrm{s}\\,$。初始塑性应变为零，即 $\\,\\epsilon^{p}(0) = 0\\,$.\n\n仅使用上述定义和率无关塑性原理，从第一性原理推导：\n- 在 $\\,t \\in [0,T]\\,$ 区间内 $\\,\\epsilon^{e}(t)\\,$ 和 $\\,\\epsilon^{p}(t)\\,$ 的分段演化过程，\n- 塑性起始时间 $\\,t_{y}\\,$ 和屈服时的一致性条件，\n- 然后计算最终塑性应变 $\\,\\epsilon^{p}(T)\\,$.\n\n将最终答案表示为单个数值 $\\,\\epsilon^{p}(T)\\,$（无量纲）。将你的答案四舍五入到四位有效数字。",
            "solution": "在尝试求解之前，先评估问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n- **本构模型**：率无关、理想塑性、一维、小应变、等温条件。\n- **应变分解**：$\\epsilon = \\epsilon^{e} + \\epsilon^{p}$。\n- **弹性定律**：$\\sigma = E\\,\\epsilon^{e}$。\n- **屈服函数**：$f(\\sigma) = |\\sigma| - Y$，其中屈服应力 $Y > 0$ 为常数。\n- **流动法则（Kuhn–Tucker 条件）**：$\\lambda \\ge 0$, $f(\\sigma) \\le 0$, $\\lambda\\,f(\\sigma) = 0$。\n- **塑性应变率**：$\\dot{\\epsilon}^{p} = \\lambda\\,\\frac{\\partial f}{\\partial \\sigma}$。\n- **加载假设**：单调拉伸应变，意味着 $\\sigma \\ge 0$，因此 $\\frac{\\partial f}{\\partial \\sigma} = 1$。\n- **给定总应变**：$\\epsilon(t) = \\alpha\\,t$ 对于 $t \\in [0,T]$。\n- **初始条件**：$\\epsilon(0) = 0$, $\\epsilon^{p}(0) = 0$。\n- **参数**：$E = 100\\,\\mathrm{MPa}$, $Y = 1\\,\\mathrm{MPa}$, $\\alpha = 0.005\\,\\mathrm{s}^{-1}$, $T = 10\\,\\mathrm{s}$。\n- **目标**：推导 $\\epsilon^{e}(t)$ 和 $\\epsilon^{p}(t)$ 的演化过程，找到塑性起始时间 $t_{y}$，解释一致性条件，并计算最终塑性应变 $\\epsilon^{p}(T)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题定义明确且具有科学依据。\n- **科学依据**：该问题描述了典型的一维弹塑性模型，这是固体力学和岩土力学中的一个基本概念。所有方程和条件（应变加和分解、胡克定律、一维的类 von Mises 屈服准则、关联流动法则、Kuhn-Tucker 条件）都是率无关塑性理论的标准组成部分。\n- **适定性**：问题提供了一套完整的材料参数（$E, Y$）、一个定义明确的加载历史（$\\epsilon(t) = \\alpha t$）以及必要的初始条件（$\\epsilon^p(0) = 0$）。这确保可以确定一个唯一解。\n- **目标**：问题使用连续介质力学中精确、标准且无歧义的术语进行陈述。\n- **一致性**：所提供的数据在量纲上和物理上都是一致的。设置中不包含矛盾。\n\n### 步骤 3：结论与行动\n问题有效。将按要求从第一性原理进行推导。\n\n### 推导\n\n分析分为两个阶段：初始弹性阶段和随后的塑性阶段。\n\n**1. 弹性阶段：$t \\in [0, t_y]$**\n\n最初，材料无应力。施加应变时，响应是纯弹性的。在此区域内，没有塑性变形，因此 $\\epsilon^{p}(t) = 0$ 且其率为 $\\dot{\\epsilon}^{p}(t) = 0$。\n\n根据流动法则，$\\dot{\\epsilon}^{p} = \\lambda\\,\\frac{\\partial f}{\\partial \\sigma}$。由于拉伸加载时 $\\frac{\\partial f}{\\partial \\sigma} = 1$，我们有 $\\dot{\\epsilon}^{p} = \\lambda$。因此，在弹性阶段 $\\lambda = 0$。\nKuhn-Tucker 条件要求 $\\lambda\\,f(\\sigma) = 0$ 和 $f(\\sigma) \\le 0$。由于 $\\lambda = 0$，对于严格的弹性响应，条件必须是 $f(\\sigma)  0$。对于拉伸加载（$\\sigma \\ge 0$），即为 $f(\\sigma) = \\sigma - Y  0$，这意味着 $\\sigma  Y$。\n\n应变演化由以下公式决定：\n- 总应变（给定）：$\\epsilon(t) = \\alpha\\,t$。\n- 应变分解：$\\epsilon(t) = \\epsilon^{e}(t) + \\epsilon^{p}(t)$。由于 $\\epsilon^{p}(t) = 0$，我们有 $\\epsilon^{e}(t) = \\epsilon(t) = \\alpha\\,t$。\n- 弹性定律：$\\sigma(t) = E\\,\\epsilon^{e}(t) = E\\,\\alpha\\,t$。\n\n当应力达到屈服强度 $Y$ 时，弹性阶段结束，塑性屈服开始，此时的时间为 $t_{y}$。\n$$ \\sigma(t_y) = Y $$\n$$ E\\,\\alpha\\,t_{y} = Y $$\n求解塑性起始时间 $t_{y}$：\n$$ t_{y} = \\frac{Y}{E\\,\\alpha} $$\n此时，总应变为屈服应变 $\\epsilon_y$：\n$$ \\epsilon_y = \\epsilon(t_y) = \\alpha\\,t_y = \\frac{Y}{E} $$\n对于 $t \\le t_y$，应变分量的演化为：\n$$ \\epsilon^{e}(t) = \\alpha\\,t $$\n$$ \\epsilon^{p}(t) = 0 $$\n\n**2. 塑性阶段：$t \\in [t_y, T]$**\n\n对于 $t > t_y$，材料发生塑性变形。根据 Kuhn-Tucker 条件，如果发生塑性流动（$\\lambda > 0$），则必须持续满足屈服条件，即 $f(\\sigma) = 0$。对于拉伸加载，这意味着：\n$$ \\sigma(t) = Y \\quad \\text{对于所有 } t \\ge t_y $$\n这就是理想塑性状态，在塑性流动期间，应力保持在屈服值上恒定不变。\n\n**一致性条件**要求在塑性加载期间，应力状态保持在屈服面上。以率的形式表示，这意味着 $\\dot{f} = 0$。对于我们的问题，这意味着 $\\dot{\\sigma} = 0$。\n让我们用这个条件来求应变率。对弹性定律关于时间求导可得 $\\dot{\\sigma} = E\\,\\dot{\\epsilon}^{e}$。由于在塑性阶段 $\\dot{\\sigma}=0$，因此：\n$$ \\dot{\\epsilon}^{e}(t) = 0 \\quad \\text{对于 } t > t_y $$\n这意味着弹性应变保持在屈服开始时的值不变：\n$$ \\epsilon^{e}(t) = \\epsilon^{e}(t_y) = \\frac{\\sigma(t_y)}{E} = \\frac{Y}{E} \\quad \\text{对于所有 } t \\ge t_y $$\n现在我们分析总应变率。给定的总应变为 $\\epsilon(t) = \\alpha\\,t$，所以其率为常数：\n$$ \\dot{\\epsilon}(t) = \\alpha $$\n使用应变率的加和分解 $\\dot{\\epsilon} = \\dot{\\epsilon}^{e} + \\dot{\\epsilon}^{p}$，我们可以求得塑性应变率：\n$$ \\alpha = 0 + \\dot{\\epsilon}^{p}(t) $$\n$$ \\dot{\\epsilon}^{p}(t) = \\alpha \\quad \\text{对于 } t > t_y $$\n为了求塑性应变 $\\epsilon^{p}(t)$，我们从塑性起始时间 $t_{y}$（此时 $\\epsilon^{p}(t_{y})=0$）开始对其率进行积分：\n$$ \\epsilon^{p}(t) = \\int_{t_y}^{t} \\dot{\\epsilon}^{p}(\\tau) \\,d\\tau = \\int_{t_y}^{t} \\alpha \\,d\\tau = \\alpha(t - t_y) $$\n代入 $t_y$ 的表达式：\n$$ \\epsilon^{p}(t) = \\alpha\\,t - \\alpha\\,t_y = \\alpha\\,t - \\frac{Y}{E} $$\n此表达式对 $t \\ge t_y$ 有效。\n\n**$t \\in [0, T]$ 期间的分段演化总结**：\n- 塑性起始时间为 $t_y = \\frac{Y}{E\\,\\alpha}$。\n- 对于 $t \\in [0, t_y]$（弹性区域）：\n  $$ \\epsilon^{e}(t) = \\alpha\\,t $$\n  $$ \\epsilon^{p}(t) = 0 $$\n- 对于 $t \\in [t_y, T]$（塑性区域）：\n  $$ \\epsilon^{e}(t) = \\frac{Y}{E} $$\n  $$ \\epsilon^{p}(t) = \\alpha \\left( t - t_y \\right) = \\alpha\\,t - \\frac{Y}{E} $$\n\n**3. 最终计算**\n\n我们需要计算最终塑性应变 $\\epsilon^{p}(T)$。首先，我们必须计算 $t_{y}$ 以确认在给定的时间区间 $T = 10\\,\\mathrm{s}$ 内会发生塑性。\n使用给定参数：$E = 100\\,\\mathrm{MPa}$, $Y = 1\\,\\mathrm{MPa}$, $\\alpha = 0.005\\,\\mathrm{s}^{-1}$。\n$$ t_{y} = \\frac{1\\,\\mathrm{MPa}}{(100\\,\\mathrm{MPa}) \\times (0.005\\,\\mathrm{s}^{-1})} = \\frac{1}{0.5}\\,\\mathrm{s} = 2\\,\\mathrm{s} $$\n由于 $t_y = 2\\,\\mathrm{s}  T = 10\\,\\mathrm{s}$，材料确实进入了塑性区域。\n\n现在我们可以使用为塑性阶段推导的表达式来计算最终塑性应变 $\\epsilon^{p}(T)$：\n$$ \\epsilon^{p}(T) = \\alpha (T - t_{y}) $$\n代入数值：\n$$ \\epsilon^{p}(10) = 0.005\\,\\mathrm{s}^{-1} \\times (10\\,\\mathrm{s} - 2\\,\\mathrm{s}) $$\n$$ \\epsilon^{p}(10) = 0.005 \\times 8 $$\n$$ \\epsilon^{p}(10) = 0.04 $$\n最终塑性应变为无量纲量。问题要求将答案四舍五入到四位有效数字。精确值为 $0.04$。表示为四位有效数字即为 $0.04000$。",
            "answer": "$$\\boxed{0.04000}$$"
        },
        {
            "introduction": "在真实世界的岩土工程问题中，材料通常处于复杂的三维应力状态下。本练习将理论从一维模型推广到三维分析，这是评估岩土材料稳定性的关键一步。你将学习如何计算应力不变量（如平均应力 $p$、偏应力 $q$ 和 Lode 角 $\\theta$），并利用它们来评估应用广泛的 Mohr–Coulomb 屈服准则，从而判断材料在给定应力状态下是否会发生塑性屈服 。",
            "id": "3554932",
            "problem": "考虑一个采用摩尔-库仑 (MC) 屈服准则的率无关塑性模型描述的岩土材料。采用岩土力学符号约定，即压应力为正。一个试样承受轴对称三轴应力状态，其主应力为 $\\sigma_1$、$\\sigma_2$ 和 $\\sigma_3$，其中 $\\sigma_2 = \\sigma_3$。所施加的应力为 $\\sigma_1 = 650 \\ \\text{kPa}$ 和 $\\sigma_2 = \\sigma_3 = 220 \\ \\text{kPa}$。材料参数为摩擦角 $\\phi = 30^{\\circ}$ 和粘聚力 $c = 5 \\ \\text{kPa}$。\n\n从平均应力 $p$ 和偏应力张量 $\\mathbf{s}$ 的基本定义，以及 $\\mathbf{s}$ 的第二和第三不变量 $J_2$ 和 $J_3$ 出发，推导应力不变量的表达式，并计算此应力状态下的标量度量 $p$、$q$（通过 $J_2$ 定义）和洛德角 $\\theta$。根据计算出的 $\\theta$ 值，确定活动子午线（三轴压缩或三轴拉伸）。在 $(p,q)$-不变量表示下，使用摩尔-库仑屈服面的相应子午线，评估给定应力状态下的塑性容许度量 $f$（即屈服函数值）。\n\n以千帕 ($\\text{kPa}$) 为单位表示 $f$ 的最终值，并将答案四舍五入至四位有效数字。在推导过程中，洛德角必须以度为单位报告。您提交的最终答案必须仅为 $f$ 的单个数值。",
            "solution": "该问题经评估为有效，因为它具有科学依据、提法明确、客观，并包含获得唯一解所需的所有必要信息。\n\n目标是评估给定轴对称三轴应力状态下的摩尔-库仑屈服函数 $f$。采用岩土力学符号约定，即压应力为正。\n\n首先，我们列出给定数据：\n主应力为 $\\sigma_1 = 650 \\ \\text{kPa}$ 和 $\\sigma_2 = \\sigma_3 = 220 \\ \\text{kPa}$。\n材料参数为摩擦角 $\\phi = 30^{\\circ}$ 和粘聚力 $c = 5 \\ \\text{kPa}$。\n\n求解过程首先计算应力不变量 $p$、$q$ 和洛德角 $\\theta$，然后利用这些值来评估屈服函数。\n\n1.  **应力不变量的计算**\n\n平均应力 $p$ 定义为应力张量 $\\boldsymbol{\\sigma}$ 的第一不变量除以三：\n$$p = \\frac{1}{3} \\text{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3}(\\sigma_1 + \\sigma_2 + \\sigma_3)$$\n代入给定值：\n$$p = \\frac{1}{3}(650 + 220 + 220) \\ \\text{kPa} = \\frac{1090}{3} \\ \\text{kPa}$$\n\n偏应力张量 $\\mathbf{s}$ 定义为 $\\mathbf{s} = \\boldsymbol{\\sigma} - p\\mathbf{I}$，其中 $\\mathbf{I}$ 是单位张量。其主分量为：\n$$s_i = \\sigma_i - p$$\n$$s_1 = 650 - \\frac{1090}{3} = \\frac{1950 - 1090}{3} = \\frac{860}{3} \\ \\text{kPa}$$\n$$s_2 = s_3 = 220 - \\frac{1090}{3} = \\frac{660 - 1090}{3} = -\\frac{430}{3} \\ \\text{kPa}$$\n\n偏应力张量的第二不变量 $J_2$ 为：\n$$J_2 = \\frac{1}{2}\\text{tr}(\\mathbf{s}^2) = \\frac{1}{2}(s_1^2 + s_2^2 + s_3^2)$$\n$$J_2 = \\frac{1}{2}\\left[\\left(\\frac{860}{3}\\right)^2 + \\left(-\\frac{430}{3}\\right)^2 + \\left(-\\frac{430}{3}\\right)^2\\right] = \\frac{1}{18}\\left(860^2 + 2 \\cdot 430^2\\right)$$\n由于 $860 = 2 \\cdot 430$，我们有：\n$$J_2 = \\frac{1}{18}\\left((2 \\cdot 430)^2 + 2 \\cdot 430^2\\right) = \\frac{1}{18}\\left(4 \\cdot 430^2 + 2 \\cdot 430^2\\right) = \\frac{6 \\cdot 430^2}{18} = \\frac{430^2}{3} \\ (\\text{kPa})^2$$\n\n偏应力量度 $q$ 通过 $J_2$ 定义为：\n$$q = \\sqrt{3J_2}$$\n$$q = \\sqrt{3 \\cdot \\frac{430^2}{3}} = \\sqrt{430^2} = 430 \\ \\text{kPa}$$\n对于轴对称应力状态，这等价于 $q = |\\sigma_1 - \\sigma_3| = |650 - 220| = 430 \\ \\text{kPa}$。\n\n偏应力张量的第三不变量 $J_3$ 为：\n$$J_3 = \\det(\\mathbf{s}) = s_1 s_2 s_3$$\n$$J_3 = \\left(\\frac{860}{3}\\right)\\left(-\\frac{430}{3}\\right)\\left(-\\frac{430}{3}\\right) = \\frac{2 \\cdot 430 \\cdot 430^2}{27} = \\frac{2 \\cdot 430^3}{27} \\ (\\text{kPa})^3$$\n\n洛德角 $\\theta$ 表征了偏应力状态的类型。一个标准的定义是：\n$$\\sin(3\\theta) = \\frac{3\\sqrt{3}}{2} \\frac{J_3}{J_2^{3/2}}$$\n我们有 $J_2^{3/2} = \\left(\\frac{430^2}{3}\\right)^{3/2} = \\frac{430^3}{3\\sqrt{3}}$。代入 $J_2^{3/2}$ 和 $J_3$：\n$$\\sin(3\\theta) = \\frac{3\\sqrt{3}}{2} \\frac{2 \\cdot 430^3 / 27}{430^3 / (3\\sqrt{3})} = \\frac{3\\sqrt{3}}{2} \\cdot \\frac{2 \\cdot 430^3}{27} \\cdot \\frac{3\\sqrt{3}}{430^3} = \\frac{3 \\cdot \\sqrt{3} \\cdot 2 \\cdot 3 \\cdot \\sqrt{3}}{2 \\cdot 27} = \\frac{54}{54} = 1$$\n因此，$\\sin(3\\theta) = 1$，这意味着 $3\\theta = 90^{\\circ}$，所以 $\\theta = 30^{\\circ}$。\n\n2.  **活动子午线的确定**\n\n洛德角 $\\theta = 30^{\\circ}$ 对应于三轴压缩 (TXC) 子午线，这与给定的应力状态 $\\sigma_1  \\sigma_2 = \\sigma_3$ 一致。\n\n3.  **摩尔-库仑屈服函数的评估**\n\n摩尔-库仑屈服准则可以用不变量 $p, q, \\theta$ 来表示。屈服函数 $f$ 的一种常见形式是：\n$$f(p, q, \\theta) = q - q_y$$\n其中 $q_y$ 是偏应力量度的屈服值。对于摩尔-库仑模型，$q_y$ 由下式给出：\n$$q_y = m(\\theta) \\left( p + c \\cot\\phi \\right)$$\n函数 $m(\\theta)$ 取决于洛德角和材料摩擦角：\n$$m(\\theta) = \\frac{6\\sin\\phi}{3 - \\sin\\phi\\sin(3\\theta)}$$\n由于活动应力路径位于三轴压缩子午线上，我们使用 $\\theta = 30^{\\circ}$，此时 $\\sin(3\\theta) = 1$。函数 $m(\\theta)$ 简化为 $m_c$：\n$$m_c = m(30^{\\circ}) = \\frac{6\\sin\\phi}{3 - \\sin\\phi}$$\n因此，三轴压缩子午线的屈服函数为：\n$$f = q - \\frac{6\\sin\\phi}{3 - \\sin\\phi} \\left( p + c \\cot\\phi \\right)$$\n现在我们代入已知值：\n$p = \\frac{1090}{3} \\ \\text{kPa}$\n$q = 430 \\ \\text{kPa}$\n$\\phi = 30^{\\circ} \\implies \\sin\\phi = \\frac{1}{2}$, $\\cot\\phi = \\sqrt{3}$\n$c = 5 \\ \\text{kPa}$\n\n首先，我们计算斜率参数 $m_c$：\n$$m_c = \\frac{6 \\cdot (1/2)}{3 - 1/2} = \\frac{3}{5/2} = \\frac{6}{5} = 1.2$$\n接下来，我们计算括号中的项：\n$$p + c\\cot\\phi = \\frac{1090}{3} + 5\\sqrt{3} \\ \\text{kPa}$$\n现在，我们可以计算屈服函数 $f$ 的值：\n$$f = 430 - 1.2 \\left( \\frac{1090}{3} + 5\\sqrt{3} \\right)$$\n$$f = 430 - \\left( 1.2 \\cdot \\frac{1090}{3} + 1.2 \\cdot 5\\sqrt{3} \\right)$$\n$$f = 430 - \\left( 0.4 \\cdot 1090 + 6\\sqrt{3} \\right)$$\n$$f = 430 - \\left( 436 + 6\\sqrt{3} \\right)$$\n$$f = 430 - 436 - 6\\sqrt{3}$$\n$$f = -6 - 6\\sqrt{3} \\ \\text{kPa}$$\n使用近似值 $\\sqrt{3} \\approx 1.73205$：\n$$f \\approx -6 - 6(1.73205) = -6 - 10.3923 = -16.3923 \\ \\text{kPa}$$\n负值表示应力状态位于屈服面内部，即处于弹性区域。\n按要求将结果四舍五入至四位有效数字：\n$$f \\approx -16.39 \\ \\text{kPa}$$",
            "answer": "$$\\boxed{-16.39}$$"
        },
        {
            "introduction": "计算岩土力学的核心在于将塑性理论转化为稳健的数值算法。本练习是一项综合性的计算实践，要求你设计并实现一个用于 Mohr–Coulomb 模型的应力更新算法，即“返回映射”算法。你将直面非光滑屈服面（角点和顶点）和非关联流动法则等高级挑战，这些都是开发能够准确模拟土体破坏和剪切带等复杂行为的数值模型的关键技能 。",
            "id": "3554851",
            "problem": "您的任务是为计算岩土力学中的Mohr–Coulomb模型设计并实现一个率无关弹塑性的算法应力更新。该更新必须在主应力空间中进行，并通过屈服函数的亚微分严格处理角点和顶点处的非光滑性。您编写的程序必须为一组固定的测试用例生成更新后的主应力。\n\n从以下小应变弹塑性的基本理论出发：\n- 柯西应力张量用 $\\boldsymbol{\\sigma}$ 表示，其主值为 $(\\sigma_1,\\sigma_2,\\sigma_3)$。\n- 线性各向同性弹性通过四阶弹性张量 $\\mathbb{D} = K \\,\\boldsymbol{I}\\otimes\\boldsymbol{I} + 2G\\,\\mathbb{I}^{\\text{dev}}$ 将应力增量与弹性应变增量联系起来，其中 $K$ 是体积模量，$G$ 是剪切模量，$\\boldsymbol{I}$ 是二阶单位张量，$\\mathbb{I}^{\\text{dev}}$ 是四阶偏张量投影算子。\n- 率无关塑性由 Karush–Kuhn–Tucker (KKT) 条件控制，包括屈服函数 $f(\\boldsymbol{\\sigma}) \\le 0$、塑性乘子 $\\lambda \\ge 0$、一致性条件 $\\lambda f(\\boldsymbol{\\sigma}) = 0$，以及流动法则 $d\\boldsymbol{\\varepsilon}^{p} = \\lambda\\,\\partial g(\\boldsymbol{\\sigma})$，其中 $g(\\boldsymbol{\\sigma})$ 是塑性势，当 $g$ 非光滑时 $\\partial g$ 是其亚微分。\n- 假设小应变、各向同性，且在返回映射过程中主方向保持共轴。\n\n在此基础上，推导并实现：\n- 一个在主应力空间 $(\\sigma_1,\\sigma_2,\\sigma_3)$ 中表达的Mohr–Coulomb屈服函数 $f(\\boldsymbol{\\sigma})$，该函数是分段线性的，并在定义角点和棱边的Lode角值处非光滑。视压缩为正。屈服取决于摩擦角 $\\varphi$ 和内聚力 $c$。您必须将此非光滑屈服明确表示为 $(\\sigma_1,\\sigma_2,\\sigma_3)$ 中有限个线性形式的逐点最大值，并通过活动线性形式（即达到最大值的形式）梯度的凸包来构造其亚微分 $\\partial f(\\boldsymbol{\\sigma})$。\n- 一个具有剪胀角 $\\psi$ 的非关联塑性势 $g(\\boldsymbol{\\sigma})$，其结构（面状线性形式）与屈服函数相似，其梯度或亚梯度提供了塑性流动方向。\n\n算法要求：\n- 在主应力空间中实现一个活动集返回映射算法，以将给定的弹性试探应力 $\\boldsymbol{\\sigma}^{\\text{tr}}$ 校正到容许集 $f(\\boldsymbol{\\sigma}) \\le 0$。使用来自 $\\partial g$ 的流动方向和弹性张量 $\\mathbb{D}$ 来推导应力校正量 $\\Delta\\boldsymbol{\\sigma} = -\\lambda\\,\\mathbb{D}:\\boldsymbol{n}$，其中 $\\boldsymbol{n} \\in \\partial g(\\boldsymbol{\\sigma})$ 是与活动集一致的亚梯度。对活动面强制执行屈服等式和KKT条件。在角点和顶点处，将 $\\boldsymbol{n}$ 视为活动面法向量的凸组合，并求解凸组合权重和 $\\lambda$，以使校正后的应力正好位于活动面定义的交线上。使用一个鲁棒的容差来检测多个活动面。\n- 显式处理面（一个活动线性形式）、棱（两个活动线性形式）和顶点（所有主应力相等且具有多个活动形式）。在顶点处，将亚微分识别为所有面法向量的凸包，并确保即使在不需要塑性校正时算法仍然是良定义的。\n\n您还必须通过偏应力的第二和第三不变量从主应力计算Lode角 $\\theta$，并确保活动集逻辑与Lode角边界处的非光滑性保持一致。角度单位必须是弧度。\n\n必须指定并一致地使用数值和物理单位：\n- 应力单位使用兆帕（MPa）。\n- 角度单位使用弧度。\n\n测试套件和输出规范：\n- 实现您的算法并将其应用于以下测试用例，所有用例均采用各向同性线弹性模型和压为正的符号约定：\n    1. 光滑面返回，参数：摩擦角 $\\varphi = \\pi/6$ (即 $0.5235987756$ 弧度)，剪胀角 $\\psi = \\pi/18$ (即 $0.1745329252$ 弧度)，内聚力 $c = 5$ MPa，体积模量 $K = 5000$ MPa，剪切模量 $G = 3000$ MPa，试探主应力 $(\\sigma_1^{\\text{tr}},\\sigma_2^{\\text{tr}},\\sigma_3^{\\text{tr}}) = (150,90,30)$ MPa。\n    2. 棱边情况返回，具有两个相等的主应力以触发两个活动面：摩擦角 $\\varphi = \\pi/6$，剪胀角 $\\psi = \\pi/18$，内聚力 $c = 5$ MPa，体积模量 $K = 5000$ MPa，剪切模量 $G = 3000$ MPa，试探主应力 $(\\sigma_1^{\\text{tr}},\\sigma_2^{\\text{tr}},\\sigma_3^{\\text{tr}}) = (200,60,60)$ MPa。\n    3. 顶点边界情况，所有主应力相等（预期无塑性校正，但亚微分必须是良定义的）：摩擦角 $\\varphi = \\pi/6$，剪胀角 $\\psi = \\pi/18$，内聚力 $c = 0$ MPa，体积模量 $K = 5000$ MPa，剪切模量 $G = 3000$ MPa，试探主应力 $(\\sigma_1^{\\text{tr}},\\sigma_2^{\\text{tr}},\\sigma_3^{\\text{tr}}) = (80,80,80)$ MPa。\n- 对每个测试用例，计算更新后的主应力 $(\\sigma_1,\\sigma_2,\\sigma_3)$，单位为 MPa。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个项目本身是更新后的主应力列表，四舍五入到三位小数，例如：$[\\,[\\sigma_1,\\sigma_2,\\sigma_3],\\,[\\sigma_1,\\sigma_2,\\sigma_3],\\,[\\sigma_1,\\sigma_2,\\sigma_3]\\,]$。\n\n确保科学真实性和数值鲁棒性，包括合理的停止容差和对退化情况的处理。不允许用户输入；所有参数和测试用例必须嵌入程序中。最终输出必须严格遵循指定的格式。",
            "solution": "我们从具有各向同性线弹性的小应变率无关弹塑性理论开始。弹性张量为 $\\mathbb{D} = K \\,\\boldsymbol{I}\\otimes\\boldsymbol{I} + 2G\\,\\mathbb{I}^{\\text{dev}}$，因此对于任意对称二阶张量 $\\boldsymbol{A}$，$\\mathbb{D}$ 的作用是\n$$\n\\mathbb{D}:\\boldsymbol{A} = K\\,\\text{tr}(\\boldsymbol{A})\\,\\boldsymbol{I} + 2G\\left(\\boldsymbol{A} - \\tfrac{1}{3}\\text{tr}(\\boldsymbol{A})\\,\\boldsymbol{I}\\right).\n$$\nMohr–Coulomb 屈服函数是非光滑的，可以在主应力空间中表示为捕捉摩擦破坏面的有限个线性形式的逐点最大值。在压为正的约定下，一个方便的表示方法是\n$$\nf(\\boldsymbol{\\sigma}) = \\max_{i\\neq j} \\left\\{\\, (1-\\sin\\varphi)\\,\\sigma_i - (1+\\sin\\varphi)\\,\\sigma_j - 2c\\cos\\varphi \\,\\right\\},\n$$\n其中 $(i,j)\\in\\{(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)\\}$。此形式编码了 $(\\sigma_1,\\sigma_2,\\sigma_3)$ 空间中的六个平面，总屈服面是它们的上包络面。当多个面同时活动，即达到最大值时，就会出现不可微性。\n\n用于非关联流动的塑性势 $g(\\boldsymbol{\\sigma})$ 的定义与此类似，但用剪胀角 $\\psi$ 代替了 $\\varphi$：\n$$\ng(\\boldsymbol{\\sigma}) = \\max_{i\\neq j} \\left\\{\\, (1-\\sin\\psi)\\,\\sigma_i - (1+\\sin\\psi)\\,\\sigma_j - 2c\\cos\\psi \\,\\right\\}.\n$$\n对于单个活动面 $(i,j)$，塑性势关于主应力的梯度是向量\n$$\n\\boldsymbol{n}^{(i,j)} = \\left(n_1,n_2,n_3\\right),\\quad n_k =\n\\begin{cases}\n(1-\\sin\\psi)  \\text{if } k=i,\\\\\n-(1+\\sin\\psi)  \\text{if } k=j,\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n在非光滑点（棱和顶点），亚微分 $\\partial g(\\boldsymbol{\\sigma})$ 是所有活动面梯度的凸包。如果两个面是活动的，$\\partial g$ 中的任何 $\\boldsymbol{n}$ 都可以写成 $\\boldsymbol{n} = \\alpha\\,\\boldsymbol{n}^{(i_1,j_1)} + (1-\\alpha)\\,\\boldsymbol{n}^{(i_2,j_2)}$，其中 $\\alpha\\in[0,1]$。如果三个或更多面是活动的（当 $\\sigma_1=\\sigma_2=\\sigma_3$ 时的顶点情况），我们有 $\\boldsymbol{n} = \\sum_{r=1}^m \\alpha_r\\,\\boldsymbol{n}^{(i_r,j_r)}$，其中 $\\alpha_r\\ge 0$ 且 $\\sum_r \\alpha_r = 1$。\n\n率无关流动法则是 $d\\boldsymbol{\\varepsilon}^{p} = \\lambda\\,\\boldsymbol{n}$，其中 $\\boldsymbol{n}\\in\\partial g$。返回映射步驟中的应力校正是通过强制与弹性张量保持弹塑性一致性来获得的。对于给定的试探应力 $\\boldsymbol{\\sigma}^{\\text{tr}}$，校正后的应力为\n$$\n\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{tr}} - \\lambda\\,\\mathbb{D}:\\boldsymbol{n}.\n$$\n写作主分量形式，并令 $t = \\text{tr}(\\boldsymbol{n})$，单位塑性乘子引起的主应力校正量为\n$$\n\\Delta\\sigma_k' \\equiv \\frac{d\\sigma_k}{d\\lambda} = -\\left[\\,K\\,t + 2G\\left(n_k - \\tfrac{1}{3}t\\right)\\,\\right],\\quad k\\in\\{1,2,3\\}.\n$$\n对于单个活动面 $(i,j)$，弹塑性一致性要求 $f^{(i,j)}(\\boldsymbol{\\sigma})=0$，即\n$$\n(1-\\sin\\varphi)\\,\\sigma_i - (1+\\sin\\varphi)\\,\\sigma_j - 2c\\cos\\varphi = 0.\n$$\n代入 $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{tr}} + \\lambda\\,\\Delta\\boldsymbol{\\sigma}'$，我们得到一个关于 $\\lambda$ 的线性方程：\n$$\n(1-\\sin\\varphi)\\,\\sigma_i^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_j^{\\text{tr}} - 2c\\cos\\varphi + \\lambda\\left[(1-\\sin\\varphi)\\,\\Delta\\sigma_i' - (1+\\sin\\varphi)\\,\\Delta\\sigma_j'\\right] = 0,\n$$\n解得\n$$\n\\lambda = \\frac{(1-\\sin\\varphi)\\,\\sigma_i^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_j^{\\text{tr}} - 2c\\cos\\varphi}{-\\left[(1-\\sin\\varphi)\\,\\Delta\\sigma_i' - (1+\\sin\\varphi)\\,\\Delta\\sigma_j'\\right]}.\n$$\n在具有两个活动面 $(i_1,j_1)$ 和 $(i_2,j_2)$ 的棱上，我们构造 $\\boldsymbol{n}(\\alpha) = \\alpha\\,\\boldsymbol{n}^{(i_1,j_1)} + (1-\\alpha)\\,\\boldsymbol{n}^{(i_2,j_2)}$。单位乘子对应的应力校正量则为 $\\Delta\\boldsymbol{\\sigma}'(\\alpha) = \\alpha\\,\\Delta\\boldsymbol{\\sigma}'^{(1)} + (1-\\alpha)\\,\\Delta\\boldsymbol{\\sigma}'^{(2)}$，其中 $\\Delta\\boldsymbol{\\sigma}'^{(r)}$ 是根据 $\\boldsymbol{n}^{(i_r,j_r)}$ 计算的。对两个活动面强制执行一致性条件，得到两个线性等式：\n$$\n(1-\\sin\\varphi)\\,\\sigma_{i_r}^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_{j_r}^{\\text{tr}} - 2c\\cos\\varphi + \\lambda\\left[(1-\\sin\\varphi)\\,\\Delta\\sigma_{i_r}'(\\alpha) - (1+\\sin\\varphi)\\,\\Delta\\sigma_{j_r}'(\\alpha)\\right] = 0,\\quad r=1,2.\n$$\n可以通过构造比率来组合这些等式以消去 $\\lambda$\n$$\n\\frac{(1-\\sin\\varphi)\\,\\Delta\\sigma_{i_1}'(\\alpha) - (1+\\sin\\varphi)\\,\\Delta\\sigma_{j_1}'(\\alpha)}{(1-\\sin\\varphi)\\,\\Delta\\sigma_{i_2}'(\\alpha) - (1+\\sin\\varphi)\\,\\Delta\\sigma_{j_2}'(\\alpha)} = \\frac{(1-\\sin\\varphi)\\,\\sigma_{i_1}^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_{j_1}^{\\text{tr}} - 2c\\cos\\varphi}{(1-\\sin\\varphi)\\,\\sigma_{i_2}^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_{j_2}^{\\text{tr}} - 2c\\cos\\varphi}.\n$$\n左侧是 $\\alpha$ 的线性函数，因为 $\\Delta\\boldsymbol{\\sigma}'(\\alpha)$ 是 $\\boldsymbol{n}(\\alpha)$ 的线性函数，从而给出了一个关于 $\\alpha$ 的简单线性方程。一旦求出 $\\alpha$，就可以从任一个面等式中获得 $\\lambda$，校正后的应力则为 $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{tr}} + \\lambda\\,\\Delta\\boldsymbol{\\sigma}'(\\alpha)$。\n\n在顶点处，当 $\\sigma_1 = \\sigma_2 = \\sigma_3$ 时，所有面产生相等的值，亚微分 $\\partial g$ 是所有面法向量的凸包。然而，对于没有封顶的 Mohr–Coulomb 模型，当 $c\\ge 0$ 时，静水压力状态通常是弹性的（因为面的表达式取决于主应力之差和由内聚力引起的恒定偏移），因此不需要塑性校正。算法必须仍然能够检测到多个活动面并保持良定义。\n\n为了严格处理特定 Lode 角值处的非光滑性，我们从主应力计算 Lode 角 $\\theta$。令 $p = (\\sigma_1 + \\sigma_2 + \\sigma_3)/3$ 为平均应力，$\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\,\\boldsymbol{I}$ 为偏应力张量。则\n$$\nJ_2 = \\tfrac{1}{2}\\left(s_1^2 + s_2^2 + s_3^2\\right),\\quad J_3 = s_1 s_2 s_3,\n$$\nLode 角定义为\n$$\n\\sin(3\\theta) = \\frac{3\\sqrt{3}}{2}\\,\\frac{J_3}{J_2^{3/2}},\\quad \\theta = \\tfrac{1}{3}\\arcsin\\left(\\sin(3\\theta)\\right),\n$$\n需要理解的是，在顶点处，$J_2 \\to 0$ 会导致不确定的 $\\theta$。在实践中，$\\theta$ 接近 $\\pm \\pi/6$ 处的非光滑性对应于两个面活动的棱；我们的活动集策略通过在容差范围内检测面最大值的相等情况来识别这些情况。\n\n算法设计：\n- 计算所有面值 $f^{(i,j)}(\\boldsymbol{\\sigma}^{\\text{tr}})$。\n- 如果在容差范围内 $\\max f^{(i,j)} \\le 0$，则状态为弹性；返回 $\\boldsymbol{\\sigma}^{\\text{tr}}$。\n- 否则，将所有在容差范围内达到最大值的面构成活动集 $\\mathcal{A}$。如果 $|\\mathcal{A}|=1$，通过求解 $\\lambda$ 并更新 $\\boldsymbol{\\sigma}$ 来执行单面返回。如果 $|\\mathcal{A}|\\ge 2$，从 $\\mathcal{A}$ 中选择两个面，并如上所述求解凸权重 $\\alpha$ 和 $\\lambda$；如果计算出的 $\\alpha$ 不在 $[0,1]$ 范围内或分母退化，则回退到占主导的单面。迭代活动集更新：重新计算 $f^{(i,j)}(\\boldsymbol{\\sigma})$，更新 $\\mathcal{A}$，并重复此过程，直到最大面值在容差范围内降至零或活动集稳定。在顶点处，要么不发生校正（弹性），要么算法平凡地终止，因为所有面值相等但非正。\n\n数值选择：\n- 使用 $10^{-9}$ 的容差进行相等检测和屈服满足判断。\n- 角度单位为弧度；应力单位为 MPa。\n- 在输出中将最终主应力四舍五入到三位小数。\n\n测试用例讨论：\n- 情况 1 主要在单个面上产生超应力；活动集算法找到一个活动面并执行单面返回。\n- 情况 2 中 $\\sigma_2 = \\sigma_3$，导致两个面 $(1,2)$ 和 $(1,3)$ 同等活动；算法计算面法向量的凸组合并返回到交线（棱）。\n- 情况 3 中 $\\sigma_1 = \\sigma_2 = \\sigma_3$ 且 $c = 0$ MPa；所有面值相等且非正，因此状态是弹性的；算法检测到顶点并返回试探应力不变，同时保持亚微分的良定义性。\n\n实现的程序对指定的测试套件执行这些步骤，并为每个情况打印一行包含更新后主应力的输出，用括号括起来并四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lode_angle(principals):\n    # Compute Lode angle theta from principal stresses\n    s = np.array(principals, dtype=float)\n    p = np.mean(s)\n    dev = s - p\n    J2 = 0.5 * np.sum(dev**2)\n    if J2  1e-16:\n        return 0.0  # Apex: undefined; return 0 by convention\n    J3 = dev[0]*dev[1]*dev[2]\n    sin3theta = (3.0*np.sqrt(3.0)/2.0) * (J3 / (J2**1.5))\n    # Clamp to [-1,1] for numerical safety\n    sin3theta = max(-1.0, min(1.0, sin3theta))\n    return (1.0/3.0) * np.arcsin(sin3theta)\n\ndef face_pairs():\n    # All ordered pairs (i,j), i != j\n    return [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]\n\ndef yield_face_value(sig, phi, c, pair):\n    i,j = pair\n    sphi = np.sin(phi)\n    cphi = np.cos(phi)\n    return (1.0 - sphi)*sig[i] - (1.0 + sphi)*sig[j] - 2.0*c*cphi\n\ndef yield_face_coeff_vector(phi, pair):\n    # y vector for yield plane linear form: y · sigma - 2c cos(phi)\n    i,j = pair\n    sphi = np.sin(phi)\n    y = np.zeros(3)\n    y[i] = (1.0 - sphi)\n    y[j] = -(1.0 + sphi)\n    return y\n\ndef potential_normal_vector(psi, pair):\n    # n vector (gradient of plastic potential) for a given face\n    i,j = pair\n    spsi = np.sin(psi)\n    n = np.zeros(3)\n    n[i] = (1.0 - spsi)\n    n[j] = -(1.0 + spsi)\n    return n\n\ndef D_contract_n(K, G, n):\n    # Compute D : n (principal components), then negate for per-unit lambda correction\n    t = np.sum(n)\n    # principal components: K*t + 2G*(n_k - t/3)\n    corr = np.empty(3)\n    for k in range(3):\n        corr[k] = K*t + 2.0*G*(n[k] - t/3.0)\n    # Stress correction per unit lambda is -corr\n    return -corr\n\ndef active_set_update_sigma(sig_trial, phi, psi, c, K, G, tol=1e-9, max_iter=50):\n    sig = np.array(sig_trial, dtype=float)\n    pairs = face_pairs()\n    # Iterative active-set loop\n    for _ in range(max_iter):\n        # Compute face values\n        fvals = np.array([yield_face_value(sig, phi, c, pr) for pr in pairs])\n        fmax = np.max(fvals)\n        # Elastic check\n        if fmax = tol:\n            return sig\n        # Active set within tolerance\n        active_indices = [idx for idx, fv in enumerate(fvals) if fv = fmax - tol]\n        # Compute n vectors and D:n corrections for active faces\n        n_list = [potential_normal_vector(psi, pairs[idx]) for idx in active_indices]\n        d_list = [D_contract_n(K, G, n) for n in n_list]\n        y_list = [yield_face_coeff_vector(phi, pairs[idx]) for idx in active_indices]\n        # Single-face return\n        if len(active_indices) == 1:\n            y = y_list[0]\n            d = d_list[0]\n            # Compute denominator: y · d restricted to the two nonzero components automatically handled by dot\n            denom = np.dot(y, d)\n            num = fvals[active_indices[0]]\n            # If denom nearly zero, fallback to small step; else compute lambda\n            if abs(denom)  1e-20:\n                # Fallback: tiny step to avoid stagnation\n                lam = 0.0\n            else:\n                lam = -num / denom\n            if lam  0.0:\n                # If negative due to numerical issues, clamp to zero\n                lam = 0.0\n            sig_new = sig + lam * d\n            sig = sig_new\n            # Continue loop to check if satisfied\n            continue\n        # Two-face edge return (use first two active faces)\n        # Construct linear functions A1(alpha) and A2(alpha) for denominators\n        idx1, idx2 = active_indices[0], active_indices[1]\n        y1, y2 = y_list[0], y_list[1]\n        d1, d2 = d_list[0], d_list[1]\n        # A_r(alpha) = y_r · (alpha d1 + (1-alpha) d2) = alpha y_r·d1 + (1-alpha) y_r·d2\n        a1 = np.dot(y1, d1) - np.dot(y1, d2)\n        b1 = np.dot(y1, d2)\n        a2 = np.dot(y2, d1) - np.dot(y2, d2)\n        b2 = np.dot(y2, d2)\n        # Ratio r = f1 / f2 (note fvals positive if overstressed)\n        f1 = fvals[idx1]\n        f2 = fvals[idx2]\n        # Solve for alpha from (a1 alpha + b1) = (f1/f2) (a2 alpha + b2)\n        # Handle degenerate f2 ~ 0\n        if abs(f2)  1e-20:\n            # Fallback to single-face return on idx1\n            y = y1\n            d = d1\n            denom = np.dot(y, d)\n            num = f1\n            lam = 0.0 if abs(denom)  1e-20 else -num / denom\n            if lam  0.0:\n                lam = 0.0\n            sig = sig + lam * d\n            continue\n        r = f1 / f2\n        denom_alpha = (a1 - r * a2)\n        if abs(denom_alpha)  1e-20:\n            # Degenerate: choose alpha = 0.5\n            alpha = 0.5\n        else:\n            alpha = (r * b2 - b1) / denom_alpha\n        # Clamp alpha to [0,1]; if out of bounds, fallback to nearer single face\n        if alpha  0.0 - 1e-12 or alpha  1.0 + 1e-12:\n            # Choose the face with larger fval\n            if f1 = f2:\n                y = y1\n                d = d1\n                num = f1\n            else:\n                y = y2\n                d = d2\n                num = f2\n            denom = np.dot(y, d)\n            lam = 0.0 if abs(denom)  1e-20 else -num / denom\n            if lam  0.0:\n                lam = 0.0\n            sig = sig + lam * d\n            continue\n        # Compute combined correction and lambda\n        d_comb = alpha * d1 + (1.0 - alpha) * d2\n        A1 = a1 * alpha + b1\n        lam = 0.0 if abs(A1)  1e-20 else -f1 / A1\n        if lam  0.0:\n            lam = 0.0\n        sig = sig + lam * d_comb\n        # Continue to next iteration\n    # If not converged within max_iter, return last state\n    return sig\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Smooth-face return\n        {\n            \"phi\": np.pi/6,      # radians\n            \"psi\": np.pi/18,     # radians\n            \"c\": 5.0,            # MPa\n            \"K\": 5000.0,         # MPa\n            \"G\": 3000.0,         # MPa\n            \"sigma_trial\": np.array([150.0, 90.0, 30.0])  # MPa\n        },\n        # Case 2: Edge-case return with sigma2 = sigma3\n        {\n            \"phi\": np.pi/6,\n            \"psi\": np.pi/18,\n            \"c\": 5.0,\n            \"K\": 5000.0,\n            \"G\": 3000.0,\n            \"sigma_trial\": np.array([200.0, 60.0, 60.0])\n        },\n        # Case 3: Apex boundary case, c = 0\n        {\n            \"phi\": np.pi/6,\n            \"psi\": np.pi/18,\n            \"c\": 0.0,\n            \"K\": 5000.0,\n            \"G\": 3000.0,\n            \"sigma_trial\": np.array([80.0, 80.0, 80.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sig_tr = case[\"sigma_trial\"]\n        phi = case[\"phi\"]\n        psi = case[\"psi\"]\n        c = case[\"c\"]\n        K = case[\"K\"]\n        G = case[\"G\"]\n        sig_upd = active_set_update_sigma(sig_tr, phi, psi, c, K, G, tol=1e-9, max_iter=50)\n        # Round to three decimals\n        sig_rounded = [float(f\"{x:.3f}\") for x in sig_upd]\n        results.append(sig_rounded)\n\n    # Final print statement in the exact required format.\n    # Format: [[s11,s12,s13],[s21,s22,s23],[s31,s32,s33]]\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.3f}\" for x in res) + \"]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}