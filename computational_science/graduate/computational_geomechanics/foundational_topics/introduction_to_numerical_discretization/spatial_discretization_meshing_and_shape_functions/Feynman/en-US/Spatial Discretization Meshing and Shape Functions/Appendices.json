{
    "hands_on_practices": [
        {
            "introduction": "The ability to compute strain from nodal displacements is the cornerstone of the finite element method in solid mechanics. This process begins with calculating the gradients of the element's shape functions. This exercise provides foundational practice by focusing on the simplest two-dimensional element, the linear triangle (T3), and deriving its constant strain-displacement relationship directly from its geometric definition.",
            "id": "3561763",
            "problem": "In a two-dimensional plane strain analysis of a soil deposit, consider a single linear three-node triangular finite element in physical coordinates with nodal positions given by $P_1=(x_1,y_1)=(0,0)$, $P_2=(x_2,y_2)=(3,1)$, and $P_3=(x_3,y_3)=(1,4)$. The linear shape functions $N_i(x,y)$, for $i\\in\\{1,2,3\\}$, are the barycentric coordinates associated with the triangle, and hence are affine functions that satisfy the Kronecker-delta property $N_i(P_j)=\\delta_{ij}$ and the partition of unity $\\sum_{i=1}^{3}N_i(x,y)=1$ for all $(x,y)$ in the element.\n\nStarting solely from the defining properties of linear triangular shape functions and the geometric definition of the signed area of a triangle, derive a general expression for the constant gradient $\\nabla N_i$ in terms of the nodal coordinates and the signed area $A$ of the triangle. Then, for the triangle defined above, compute the numerical values of the gradients $\\nabla N_1$, $\\nabla N_2$, and $\\nabla N_3$ in the physical $(x,y)$ coordinates.\n\nReport your final answer as a single row matrix containing the components in the order $\\left[\\frac{\\partial N_1}{\\partial x},\\frac{\\partial N_1}{\\partial y},\\frac{\\partial N_2}{\\partial x},\\frac{\\partial N_2}{\\partial y},\\frac{\\partial N_3}{\\partial x},\\frac{\\partial N_3}{\\partial y}\\right]$. Use exact values (no rounding).",
            "solution": "The user wants me to solve the following problem:\nIn a two-dimensional plane strain analysis of a soil deposit, consider a single linear three-node triangular finite element in physical coordinates with nodal positions given by $P_1=(x_1,y_1)=(0,0)$, $P_2=(x_2,y_2)=(3,1)$, and $P_3=(x_3,y_3)=(1,4)$. The linear shape functions $N_i(x,y)$, for $i\\in\\{1,2,3\\}$, are the barycentric coordinates associated with the triangle, and hence are affine functions that satisfy the Kronecker-delta property $N_i(P_j) = \\delta_{ij}$ and the partition of unity $\\sum_{i=1}^{3} N_i(x,y) = 1$ for all $(x,y)$ in the element.\n\nStarting solely from the defining properties of linear triangular shape functions and the geometric definition of the signed area of a triangle, derive a general expression for $\\nabla N_i$ in terms of nodal coordinates and the element's signed area $A$. Then, for the triangle defined above, compute the numerical values of $\\nabla N_1$, $\\nabla N_2$, and $\\nabla N_3$ for the given element.\n\nReport your final answer as a single row matrix of the six gradient components.\n\n### Step 1: Extract Givens\n- Element type: Linear three-node triangular finite element in 2D.\n- Analysis type: Plane strain.\n- Nodal coordinates: $P_1=(x_1,y_1)=(0,0)$, $P_2=(x_2,y_2)=(3,1)$, $P_3=(x_3,y_3)=(1,4)$.\n- Shape functions $N_i(x,y)$ for $i \\in \\{1,2,3\\}$ are:\n    - Linear (affine functions).\n    - Barycentric coordinates.\n    - Satisfy Kronecker-delta property: $N_i(P_j) = \\delta_{ij}$.\n    - Satisfy partition of unity: $\\sum_{i=1}^{3} N_i(x,y) = 1$.\n- Task, Part 1: Derive a general expression for $\\nabla N_i$ in terms of nodal coordinates and the element's signed area $A$.\n- Task, Part 2: Compute the numerical values of $\\nabla N_1$, $\\nabla N_2$, and $\\nabla N_3$ for the given element.\n- Output format: A single row matrix of the six gradient components.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a standard exercise in the Finite Element Method (FEM), a cornerstone of computational mechanics and engineering. All concepts (shape functions, barycentric coordinates, gradients) are fundamental to FEM.\n- **Well-Posed**: The problem provides all necessary information (nodal coordinates) and definitions to uniquely determine the shape functions and their gradients. A unique solution exists.\n- **Objective**: The language is precise and mathematical.\n- **Relevance**: The problem is directly related to spatial discretization and shape functions, which are core topics in computational geomechanics.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-posed, scientifically sound, and objective problem directly relevant to the specified field. I will proceed with the solution.\n\n### Derivation of the Gradient Expression\n\nA linear shape function $N_i(x,y)$ for a three-node triangle is an affine function of the spatial coordinates $(x,y)$, which can be written as:\n$$\nN_i(x,y) = c_{i,1} + c_{i,2}x + c_{i,3}y\n$$\nThe gradient of this function is constant over the element:\n$$\n\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} c_{i,2} \\\\ c_{i,3} \\end{pmatrix}\n$$\nThe problem states that the shape functions are the barycentric coordinates. The barycentric coordinate $N_1(x,y)$ of a point $P(x,y)$ with respect to the node $P_1$ is defined as the ratio of the area of the sub-triangle formed by points $P$, $P_2$, and $P_3$ to the total area of the main triangle $P_1P_2P_3$. Let $A$ be the signed area of triangle $P_1P_2P_3$, and $A_1$ be the signed area of triangle $PP_2P_3$. Then, $N_1(x,y) = A_1/A$.\n\nThe signed area of a triangle with vertices $(x_a, y_a)$, $(x_b, y_b)$, and $(x_c, y_c)$, ordered counter-clockwise, is given by the determinant formula:\n$$\n\\text{Area} = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b \\\\ 1 & x_c & y_c \\end{pmatrix}\n$$\nThe total signed area of the element is:\n$$\nA = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix} = \\frac{1}{2} [x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)]\n$$\nThe area $A_1$ for the sub-triangle $PP_2P_3$ is:\n$$\nA_1 = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x & y \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix} = \\frac{1}{2} [x(y_2 - y_3) + x_2(y_3 - y) + x_3(y - y_2)]\n$$\nWe can rearrange the terms in the expression for $A_1$ to highlight its dependence on $x$ and $y$:\n$$\nA_1 = \\frac{1}{2} [x(y_2 - y_3) + y(x_3 - x_2) + (x_2y_3 - x_3y_2)]\n$$\nNow we can write the expression for the shape function $N_1(x,y)$:\n$$\nN_1(x,y) = \\frac{A_1}{A} = \\frac{1}{2A} [x(y_2 - y_3) + y(x_3 - x_2) + (x_2y_3 - x_3y_2)]\n$$\nThis is an affine function of $x$ and $y$, as expected. The components of the gradient $\\nabla N_1$ are the coefficients of $x$ and $y$:\n$$\n\\frac{\\partial N_1}{\\partial x} = \\frac{y_2 - y_3}{2A}\n$$\n$$\n\\frac{\\partial N_1}{\\partial y} = \\frac{x_3 - x_2}{2A}\n$$\nSo, the gradient of the first shape function is:\n$$\n\\nabla N_1 = \\frac{1}{2A} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}\n$$\nThe expressions for $\\nabla N_2$ and $\\nabla N_3$ can be obtained by cyclic permutation of the indices $(1, 2, 3)$. For $N_2$, we apply the permutation $(1 \\to 2, 2 \\to 3, 3 \\to 1)$:\n$$\n\\nabla N_2 = \\frac{1}{2A} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}\n$$\nFor $N_3$, we apply the permutation again $(2 \\to 3, 3 \\to 1, 1 \\to 2)$:\n$$\n\\nabla N_3 = \\frac{1}{2A} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}\n$$\nThese are the general expressions for the gradients of the linear triangular shape functions.\n\n### Numerical Computation\n\nThe given nodal coordinates are $P_1=(x_1,y_1)=(0,0)$, $P_2=(x_2,y_2)=(3,1)$, and $P_3=(x_3,y_3)=(1,4)$.\n\nFirst, we compute the value of $2A$:\n$$\n2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)\n$$\n$$\n2A = 0(1 - 4) + 3(4 - 0) + 1(0 - 1) = 0 + 12 - 1 = 11\n$$\nThe area $A = \\frac{11}{2}$ is positive, indicating a counter-clockwise ordering of the vertices.\n\nNow we can compute the components of each gradient:\n\nFor $\\nabla N_1$:\n$$\n\\frac{\\partial N_1}{\\partial x} = \\frac{y_2 - y_3}{2A} = \\frac{1 - 4}{11} = -\\frac{3}{11}\n$$\n$$\n\\frac{\\partial N_1}{\\partial y} = \\frac{x_3 - x_2}{2A} = \\frac{1 - 3}{11} = -\\frac{2}{11}\n$$\n\nFor $\\nabla N_2$:\n$$\n\\frac{\\partial N_2}{\\partial x} = \\frac{y_3 - y_1}{2A} = \\frac{4 - 0}{11} = \\frac{4}{11}\n$$\n$$\n\\frac{\\partial N_2}{\\partial y} = \\frac{x_1 - x_3}{2A} = \\frac{0 - 1}{11} = -\\frac{1}{11}\n$$\n\nFor $\\nabla N_3$:\n$$\n\\frac{\\partial N_3}{\\partial x} = \\frac{y_1 - y_2}{2A} = \\frac{0 - 1}{11} = -\\frac{1}{11}\n$$\n$$\n\\frac{\\partial N_3}{\\partial y} = \\frac{x_2 - x_1}{2A} = \\frac{3 - 0}{11} = \\frac{3}{11}\n$$\n\nAs a check, the partition of unity property $\\sum_{i=1}^3 N_i = 1$ implies that the sum of the gradients must be zero: $\\sum_{i=1}^3 \\nabla N_i = \\mathbf{0}$.\nSum of x-components: $\\frac{\\partial N_1}{\\partial x} + \\frac{\\partial N_2}{\\partial x} + \\frac{\\partial N_3}{\\partial x} = -\\frac{3}{11} + \\frac{4}{11} - \\frac{1}{11} = \\frac{-3+4-1}{11} = 0$.\nSum of y-components: $\\frac{\\partial N_1}{\\partial y} + \\frac{\\partial N_2}{\\partial y} + \\frac{\\partial N_3}{\\partial y} = -\\frac{2}{11} - \\frac{1}{11} + \\frac{3}{11} = \\frac{-2-1+3}{11} = 0$.\nThe calculations are consistent.\n\nThe final answer is the row matrix of these six components.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} -\\frac{3}{11} & -\\frac{2}{11} & \\frac{4}{11} & -\\frac{1}{11} & -\\frac{1}{11} & \\frac{3}{11} \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While linear triangles have constant gradients, more versatile elements like the bilinear quadrilateral (Q4) feature shape functions whose gradients vary across the element. This requires moving from simple analytical formulas to numerical integration to compute element properties like stiffness and mass matrices. This practice introduces the essential technique of Gauss-Legendre quadrature in the context of an isoparametric Q4 element, allowing you to build intuition for the method's accuracy by comparing its result to an exact analytical solution .",
            "id": "3561798",
            "problem": "In the context of isoparametric finite elements used in computational geomechanics, consider the bilinear shape functions of a four-node quadrilateral (Q4) element defined on the parent square domain $\\{(\\xi,\\eta)\\,|\\, -1 \\le \\xi \\le 1, -1 \\le \\eta \\le 1\\}$. Let the nodal ordering be such that node $1$ is at $(\\xi,\\eta)=(-1,-1)$ and node $2$ is at $(\\xi,\\eta)=(1,-1)$. The associated bilinear shape functions are\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\qquad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta).\n$$\nDefine the integral\n$$\nI \\equiv \\int_{-1}^{1}\\int_{-1}^{1} N_1(\\xi,\\eta)\\,N_2(\\xi,\\eta)\\, d\\xi\\, d\\eta.\n$$\n(a) Evaluate $I$ numerically using the tensor-product two-point Gauss–Legendre quadrature (the $2\\times 2$ rule) on the parent domain, where the one-dimensional abscissae and weights are $\\xi=\\pm 1/\\sqrt{3}$ with unit weight $w=1$, and the two-dimensional weights are the products of the one-dimensional weights. \n(b) Evaluate $I$ analytically by exact integration over the parent domain.\nState the exact value of $I$. No rounding is required. Express your final answer as a reduced fraction.",
            "solution": "The problem requires the evaluation of the integral $I \\equiv \\int_{-1}^{1}\\int_{-1}^{1} N_1(\\xi,\\eta)\\,N_2(\\xi,\\eta)\\, d\\xi\\, d\\eta$, where $N_1$ and $N_2$ are bilinear shape functions for a four-node quadrilateral element. The given shape functions are:\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)\n$$\n$$\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\nFirst, we construct the integrand, which we denote as $f(\\xi,\\eta)$:\n$$\nf(\\xi,\\eta) = N_1(\\xi,\\eta)\\,N_2(\\xi,\\eta) = \\left(\\frac{1}{4}(1-\\xi)(1-\\eta)\\right) \\left(\\frac{1}{4}(1+\\xi)(1-\\eta)\\right)\n$$\nSimplifying this expression, we obtain:\n$$\nf(\\xi,\\eta) = \\frac{1}{16}(1-\\xi)(1+\\xi)(1-\\eta)(1-\\eta) = \\frac{1}{16}(1-\\xi^2)(1-\\eta)^2\n$$\nThe problem asks for the evaluation of $I$ by two methods: numerical quadrature and analytical integration.\n\n(a) Numerical evaluation using $2 \\times 2$ Gauss-Legendre quadrature.\nThe formula for two-dimensional numerical quadrature over the parent square domain is:\n$$\nI \\approx I_{num} = \\int_{-1}^{1}\\int_{-1}^{1} f(\\xi,\\eta)\\,d\\xi\\,d\\eta \\approx \\sum_{i=1}^{n} \\sum_{j=1}^{n} w_i w_j f(\\xi_i, \\eta_j)\n$$\nFor the specified $2 \\times 2$ rule ($n=2$), the one-dimensional abscissae are $\\xi_1 = -1/\\sqrt{3}$, $\\xi_2 = 1/\\sqrt{3}$, with corresponding weights $w_1=1$ and $w_2=1$. The same applies to the $\\eta$ coordinate: $\\eta_1 = -1/\\sqrt{3}$, $\\eta_2 = 1/\\sqrt{3}$, with weights $w_1=1$ and $w_2=1$.\nThis gives four quadrature points $(\\xi_i, \\eta_j)$ in the domain, each with a weight $w_i w_j = 1 \\times 1 = 1$. The points are:\n\\begin{itemize}\n    \\item $(\\xi_1, \\eta_1) = (-1/\\sqrt{3}, -1/\\sqrt{3})$\n    \\item $(\\xi_2, \\eta_1) = (1/\\sqrt{3}, -1/\\sqrt{3})$\n    \\item $(\\xi_1, \\eta_2) = (-1/\\sqrt{3}, 1/\\sqrt{3})$\n    \\item $(\\xi_2, \\eta_2) = (1/\\sqrt{3}, 1/\\sqrt{3})$\n\\end{itemize}\nThe numerical value of the integral is the sum of the integrand evaluated at these four points:\n$$\nI_{num} = f(-\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}}) + f(\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}}) + f(-\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}) + f(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}})\n$$\nLet's evaluate the integrand $f(\\xi, \\eta) = \\frac{1}{16}(1-\\xi^2)(1-\\eta)^2$ at each point. Notice that the term $(1-\\xi^2)$ is identical for $\\xi = \\pm 1/\\sqrt{3}$:\n$$\n1-\\xi^2 = 1 - (\\pm \\frac{1}{\\sqrt{3}})^2 = 1 - \\frac{1}{3} = \\frac{2}{3}\n$$\nSo, the integrand values depend only on the $\\eta$ coordinate:\n$$\nf(\\pm \\frac{1}{\\sqrt{3}}, \\eta) = \\frac{1}{16}\\left(\\frac{2}{3}\\right)(1-\\eta)^2 = \\frac{1}{24}(1-\\eta)^2\n$$\nNow we evaluate for $\\eta_1 = -1/\\sqrt{3}$ and $\\eta_2 = 1/\\sqrt{3}$:\n$$\nf(\\pm \\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}}) = \\frac{1}{24}(1-(-\\frac{1}{\\sqrt{3}}))^2 = \\frac{1}{24}(1+\\frac{1}{\\sqrt{3}})^2 = \\frac{1}{24}(1 + \\frac{2}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{24}(\\frac{4}{3} + \\frac{2}{\\sqrt{3}})\n$$\n$$\nf(\\pm \\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}) = \\frac{1}{24}(1-\\frac{1}{\\sqrt{3}})^2 = \\frac{1}{24}(1 - \\frac{2}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{24}(\\frac{4}{3} - \\frac{2}{\\sqrt{3}})\n$$\nSumming the values from the four points:\n$$\nI_{num} = 2 \\times f(\\xi_1, \\eta_1) + 2 \\times f(\\xi_1, \\eta_2) = 2 \\left[\\frac{1}{24}(\\frac{4}{3} + \\frac{2}{\\sqrt{3}})\\right] + 2 \\left[\\frac{1}{24}(\\frac{4}{3} - \\frac{2}{\\sqrt{3}})\\right]\n$$\n$$\nI_{num} = \\frac{2}{24} \\left[ (\\frac{4}{3} + \\frac{2}{\\sqrt{3}}) + (\\frac{4}{3} - \\frac{2}{\\sqrt{3}}) \\right] = \\frac{1}{12} \\left[ \\frac{4}{3} + \\frac{4}{3} \\right] = \\frac{1}{12} \\left( \\frac{8}{3} \\right) = \\frac{8}{36} = \\frac{2}{9}\n$$\n\n(b) Analytical evaluation by exact integration.\nThe integral to evaluate is:\n$$\nI = \\int_{-1}^{1}\\int_{-1}^{1} \\frac{1}{16}(1-\\xi^2)(1-\\eta)^2 \\, d\\xi\\, d\\eta\n$$\nSince the integrand is a product of functions of $\\xi$ and $\\eta$ alone (i.e., it is separable), the double integral can be written as the product of two single integrals:\n$$\nI = \\frac{1}{16} \\left( \\int_{-1}^{1} (1-\\xi^2) \\,d\\xi \\right) \\left( \\int_{-1}^{1} (1-\\eta)^2 \\,d\\eta \\right)\n$$\nWe evaluate each integral separately. The first integral is:\n$$\n\\int_{-1}^{1} (1-\\xi^2) \\,d\\xi = \\left[ \\xi - \\frac{\\xi^3}{3} \\right]_{-1}^{1} = \\left(1 - \\frac{1^3}{3}\\right) - \\left(-1 - \\frac{(-1)^3}{3}\\right) = \\left(1 - \\frac{1}{3}\\right) - \\left(-1 + \\frac{1}{3}\\right) = \\frac{2}{3} - \\left(-\\frac{2}{3}\\right) = \\frac{4}{3}\n$$\nThe second integral is:\n$$\n\\int_{-1}^{1} (1-\\eta)^2 \\,d\\eta = \\int_{-1}^{1} (1 - 2\\eta + \\eta^2) \\,d\\eta = \\left[ \\eta - \\eta^2 + \\frac{\\eta^3}{3} \\right]_{-1}^{1}\n$$\n$$\n= \\left(1 - 1^2 + \\frac{1^3}{3}\\right) - \\left(-1 - (-1)^2 + \\frac{(-1)^3}{3}\\right) = \\left(1 - 1 + \\frac{1}{3}\\right) - \\left(-1 - 1 - \\frac{1}{3}\\right) = \\frac{1}{3} - \\left(-\\frac{7}{3}\\right) = \\frac{8}{3}\n$$\nNow, we multiply these results to find $I$:\n$$\nI = \\frac{1}{16} \\left( \\frac{4}{3} \\right) \\left( \\frac{8}{3} \\right) = \\frac{32}{16 \\times 9} = \\frac{2}{9}\n$$\nBoth the numerical and analytical evaluations yield the same result. This is expected, as a $2$-point Gauss-Legendre quadrature rule can exactly integrate polynomials of degree up to $2n-1 = 2(2)-1 = 3$. The integrand component in $\\xi$ is $(1-\\xi^2)$, which is of degree $2$, and the component in $\\eta$ is $(1-\\eta)^2$, which is also of degree $2$. Since both degrees are less than or equal to $3$, the $2 \\times 2$ rule is exact for this integral.\n\nThe exact value of $I$ is $\\frac{2}{9}$.",
            "answer": "$$\n\\boxed{\\frac{2}{9}}\n$$"
        },
        {
            "introduction": "After formulating an element, a critical question arises: how can we be certain our implementation is correct? The patch test is a fundamental and necessary verification procedure in computational mechanics that ensures an element formulation can exactly reproduce a state of constant strain, a prerequisite for convergence. This capstone exercise challenges you to implement and run the patch test for both triangular and quadrilateral elements, bringing together the concepts of shape functions, strain calculation, and matrix assembly to validate your own implementation .",
            "id": "3561821",
            "problem": "Consider the patch test for displacement-based finite elements in two-dimensional small-strain linear elasticity under plane strain conditions. The patch test is a necessary consistency condition: when an element family is subjected to an imposed linear displacement field, the resulting finite element solution must reproduce a constant strain state exactly, and the nodal reaction forces at the constrained boundary must match the exact boundary tractions when expressed in nodal form.\n\nStarting from the fundamental principle of virtual work and kinematics of small strains:\n- Balance of linear momentum in absence of body forces: $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$ in $\\Omega$, with boundary traction $\\boldsymbol{t} = \\boldsymbol{\\sigma} \\, \\boldsymbol{n}$ on $\\partial \\Omega$.\n- Kinematics: $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{T})$.\n- Linear elasticity (isotropic, plane strain): $\\boldsymbol{\\sigma} = \\mathbb{D} \\, \\boldsymbol{\\varepsilon}$ with Lamé parameters $\\lambda$ and $\\mu$, where $\\lambda = \\dfrac{E \\, \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$.\n\nUsing a displacement-based finite element method with $C^{0}$-continuous shape functions, the consistent element stiffness arises from the virtual work statement. In the patch test setting, an imposed linear displacement field\n$\\boldsymbol{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix}$ with\n$u(x,y) = a_{0} + a_{1} x + a_{2} y$ and $v(x,y) = b_{0} + b_{1} x + b_{2} y$ produces a constant strain state:\n$\\varepsilon_{xx} = a_{1}$, $\\varepsilon_{yy} = b_{2}$, and the engineering shear strain $\\gamma_{xy} = a_{2} + b_{1}$, leading to a constant stress $\\boldsymbol{\\sigma}$.\n\nYour task is to implement a program that:\n1. Assembles the global stiffness matrix for two-dimensional linear elasticity (plane strain) using:\n   - Linear three-node triangles (commonly abbreviated as $T3$) with area coordinates.\n   - Bilinear four-node quadrilaterals (commonly abbreviated as $Q4$) with standard isoparametric mapping and $2 \\times 2$ Gaussian quadrature.\n2. Applies the imposed linear displacement field $\\boldsymbol{u}(x,y)$ at all mesh nodes (Dirichlet boundary prescribed everywhere).\n3. Computes:\n   - The element-wise strains (for $T3$ at the element level, for $Q4$ at the $2 \\times 2$ Gauss points) and the maximum absolute deviation from the exact constant strain components $\\left[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\right]^{T}$.\n   - The nodal reaction forces $\\boldsymbol{r} = \\mathbf{K}\\boldsymbol{u}$ and compares them against the exact nodal boundary force vector obtained by integrating the exact boundary traction $\\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n}$ along the domain boundary and distributing the consistent nodal line loads on each boundary edge. Use linear edge interpolation so that each two-node boundary edge contributes $\\tfrac{L}{2}\\boldsymbol{t}$ to each of its end nodes, where $L$ is the edge length and $\\boldsymbol{t}$ is constant along the edge due to constant $\\boldsymbol{\\sigma}$.\n4. Reports two floating-point error metrics for each test case:\n   - $e_{\\varepsilon} =$ the maximum absolute strain error over all evaluated points and components.\n   - $e_{r} =$ the relative $\\ell^{2}$-norm of the reaction force error, computed as $\\dfrac{\\lVert \\boldsymbol{r} - \\boldsymbol{f}_{\\text{exact}} \\rVert_{2}}{\\max(\\lVert \\boldsymbol{f}_{\\text{exact}} \\rVert_{2}, 1)}$.\n\nUse the following material parameters and imposed displacement coefficients (plane strain):\n- Young’s modulus $E = 3.0 \\times 10^{7}$, Poisson’s ratio $\\nu = 0.25$.\n- Coefficients: $a_{0} = 0.01$, $a_{1} = 0.2$, $a_{2} = -0.1$, $b_{0} = -0.02$, $b_{1} = 0.05$, $b_{2} = 0.15$.\n\nDefine the exact strain and stress implied by the imposed field:\n- Exact engineering strain vector $\\boldsymbol{\\varepsilon}_{\\text{exact}} = \\begin{bmatrix} a_{1} \\\\ b_{2} \\\\ a_{2} + b_{1} \\end{bmatrix}$.\n- Exact stress components under plane strain:\n  - $\\sigma_{xx} = (\\lambda + 2\\mu) a_{1} + \\lambda b_{2}$,\n  - $\\sigma_{yy} = \\lambda a_{1} + (\\lambda + 2\\mu) b_{2}$,\n  - $\\sigma_{xy} = \\mu (a_{2} + b_{1})$.\n\nTest Suite. Implement the following three test cases:\n- Case $1$ (Triangular mesh, regular patch): Domain $\\left[0,1\\right] \\times \\left[0,1\\right]$, mesh with $2 \\times 2$ square cells, each cell split into two $T3$ elements (total $8$ triangles, $9$ nodes). Report $e_{\\varepsilon}$ and $e_{r}$.\n- Case $2$ (Quadrilateral mesh, regular $Q4$): Domain $\\left[0,2\\right] \\times \\left[0,1\\right]$, mesh with $2 \\times 1$ $Q4$ elements (total $2$ quads, $6$ nodes). Use $2 \\times 2$ Gauss integration. Report $e_{\\varepsilon}$ and $e_{r}$.\n- Case $3$ (Triangular mesh, skinny elements): Domain $\\left[0,2\\right] \\times \\left[0,0.2\\right]$, mesh with $2 \\times 1$ rectangular cells, each split into two $T3$ elements (total $4$ triangles, $6$ nodes). Report $e_{\\varepsilon}$ and $e_{r}$.\n\nAll results should be dimensionless floating-point numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order: $\\left[e_{\\varepsilon}^{(1)}, e_{r}^{(1)}, e_{\\varepsilon}^{(2)}, e_{r}^{(2)}, e_{\\varepsilon}^{(3)}, e_{r}^{(3)}\\right]$.\n\nAngle units do not apply. No physical units are required in the output since the requested error metrics are dimensionless.",
            "solution": "The problem statement has been validated and is deemed valid. It is a standard verification procedure in computational mechanics known as the patch test, applied to two-dimensional linear elasticity. The problem is scientifically grounded, well-posed, objective, and provides all necessary information to construct a unique, verifiable solution. We now proceed with the detailed solution.\n\n### 1. Theoretical Framework\n\nThe patch test verifies an element's ability to reproduce a constant strain state exactly. For a displacement-based finite element formulation, this is a necessary condition for convergence. We are given an imposed linear displacement field over a patch of elements:\n$$\n\\boldsymbol{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix} = \\begin{bmatrix} a_{0} + a_{1} x + a_{2} y \\\\ b_{0} + b_{1} x + b_{2} y \\end{bmatrix}\n$$\nThis field corresponds to a state of constant strain. Using the small-strain kinematic relation $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{T})$, the exact engineering strain components are:\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x} = a_{1} \\\\\n\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y} = b_{2} \\\\\n\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} = a_{2} + b_{1}\n$$\nThe exact strain vector is constant throughout the domain: $\\boldsymbol{\\varepsilon}_{\\text{exact}} = \\begin{bmatrix} a_{1} & b_{2} & a_{2} + b_{1} \\end{bmatrix}^{T}$.\n\nThe material behavior is governed by the linear isotropic plane strain constitutive law, $\\boldsymbol{\\sigma} = \\mathbb{D} \\boldsymbol{\\varepsilon}$. The material stiffness matrix $\\mathbb{D}$ is given by:\n$$\n\\mathbb{D} = \\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}\n$$\nwhere $\\lambda$ and $\\mu$ are the Lamé parameters, derived from Young's modulus $E$ and Poisson's ratio $\\nu$:\n$$\n\\mu = \\frac{E}{2(1+\\nu)}, \\quad \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}\n$$\nThe exact stress vector $\\boldsymbol{\\sigma}_{\\text{exact}} = \\mathbb{D} \\boldsymbol{\\varepsilon}_{\\text{exact}}$ is also constant throughout the domain.\n\n### 2. Finite Element Discretization\n\nThe core of the finite element method is the assembly of a global stiffness matrix $\\mathbf{K}$ from element stiffness matrices $\\mathbf{k}^e$. The element stiffness matrix is computed by integrating over the element volume $V_e$:\n$$\n\\mathbf{k}^e = \\int_{V_e} \\mathbf{B}^T \\mathbb{D} \\mathbf{B} \\, dV\n$$\nwhere $\\mathbf{B}$ is the strain-displacement matrix, which relates the nodal displacements $\\boldsymbol{d}^e$ of an element to the strain field within it, $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\boldsymbol{d}^e$.\n\n#### 2.1. Linear Triangular Element (T3)\nFor a three-node triangular element with area $A$ and nodal coordinates $(x_1, y_1), (x_2, y_2), (x_3, y_3)$, the strain-displacement matrix $\\mathbf{B}$ is constant:\n$$\n\\mathbf{B} = \\frac{1}{2A}\n\\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\nThe element stiffness matrix (assuming unit thickness) is simply $\\mathbf{k}^e = A \\, \\mathbf{B}^T \\mathbb{D} \\mathbf{B}$. Since $\\mathbf{B}$ is constant, the strain computed from the nodal displacements, $\\boldsymbol{\\varepsilon}^e = \\mathbf{B} \\boldsymbol{d}^e$, is also constant over the element.\n\n#### 2.2. Bilinear Quadrilateral Element (Q4)\nFor a four-node quadrilateral element, an isoparametric formulation maps the element from physical coordinates $(x,y)$ to a reference square in natural coordinates $(\\xi, \\eta) \\in [-1,1] \\times [-1,1]$. The $\\mathbf{B}$ matrix is no longer constant but depends on $(\\xi, \\eta)$. The element stiffness matrix is computed using numerical quadrature, specifically $2 \\times 2$ Gaussian quadrature in this problem:\n$$\n\\mathbf{k}^e = \\sum_{i=1}^{4} w_i \\, \\mathbf{B}(\\xi_i, \\eta_i)^T \\mathbb{D} \\mathbf{B}(\\xi_i, \\eta_i) \\det(\\mathbf{J}(\\xi_i, \\eta_i))\n$$\nwhere $(\\xi_i, \\eta_i)$ are the Gauss points, $w_i$ are the corresponding weights (equal to $1$ for $2 \\times 2$ quadrature), and $\\mathbf{J}$ is the Jacobian of the coordinate transformation. The strains are also evaluated at these Gauss points.\n\n### 3. Patch Test Procedure and Error Calculation\n\n1.  **Mesh and Global Matrix Assembly**: For each test case, a mesh of nodes and elements is defined. The element stiffness matrices $\\mathbf{k}^e$ are computed and assembled into the global stiffness matrix $\\mathbf{K}$.\n\n2.  **Imposed Displacements**: A global displacement vector $\\boldsymbol{u}_{\\text{global}}$ is created by evaluating the imposed linear displacement field $\\boldsymbol{u}(x,y)$ at each node of the mesh.\n\n3.  **Strain Error ($e_{\\varepsilon}$)**: During the element processing loop, the strain is computed and compared against the exact strain $\\boldsymbol{\\varepsilon}_{\\text{exact}}$.\n    - For T3 elements, this is done once per element.\n    - For Q4 elements, this is done at each of the four Gauss points.\n    The maximum absolute difference over all elements, all evaluation points, and all three strain components is a single value, $e_{\\varepsilon}$.\n\n4.  **Reaction Force Error ($e_{r}$)**:\n    - **Numerical Reaction Forces**: The vector of nodal reaction forces $\\boldsymbol{r}$ consistent with the imposed displacements is calculated as $\\boldsymbol{r} = \\mathbf{K} \\boldsymbol{u}_{\\text{global}}$.\n    - **Exact Nodal Forces**: The exact nodal force vector $\\boldsymbol{f}_{\\text{exact}}$ is derived from the work done by the boundary tractions. The constant stress tensor $\\boldsymbol{\\sigma}_{\\text{exact}}$ gives a constant traction vector $\\boldsymbol{t} = \\boldsymbol{\\sigma}_{\\text{exact}} \\boldsymbol{n}$ on any boundary edge with outward normal $\\boldsymbol{n}$. For a boundary edge of length $L$ connecting two nodes, this traction results in a consistent nodal force of $\\frac{L}{2}\\boldsymbol{t}$ applied to each node. $\\boldsymbol{f}_{\\text{exact}}$ is the sum of these contributions over all boundary edges.\n    - **Error Metric**: The relative error in the forces is computed using the $\\ell^2$-norm:\n      $$\n      e_{r} = \\frac{\\lVert \\boldsymbol{r} - \\boldsymbol{f}_{\\text{exact}} \\rVert_{2}}{\\max(\\lVert \\boldsymbol{f}_{\\text{exact}} \\rVert_{2}, 1)}\n      $$\nSince both T3 and Q4 elements can exactly represent a linear displacement field, they are expected to pass the patch test. This implies that the computed strains should exactly match the constant strain field, and the computed nodal reaction forces should exactly balance the exact boundary tractions. Therefore, both error metrics, $e_{\\varepsilon}$ and $e_{r}$, are expected to be numerically zero (i.e., on the order of machine precision).\n\n### 4. Implementation Details\n\nThe provided Python script implements this procedure. It defines functions to generate the required meshes, compute element stiffness matrices and strains for both T3 and Q4 elements, assemble the global system, and compute the exact boundary forces. A main function orchestrates the three test cases, calculates the two error metrics for each, and formats the output as required. An edge-finding algorithm is used to identify boundary segments automatically, and care is taken to compute outward normals correctly based on the counter-clockwise winding of element nodes.",
            "answer": "```python\nimport numpy as np\nfrom collections import Counter\n\ndef get_plane_strain_d_matrix(E, nu):\n    \"\"\"Computes the plane strain material stiffness matrix D.\"\"\"\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    d11 = lmbda + 2 * mu\n    d12 = lmbda\n    d33 = mu\n    return np.array([\n        [d11, d12, 0],\n        [d12, d11, 0],\n        [0,   0,   d33]\n    ])\n\ndef get_t3_b_matrix(coords):\n    \"\"\"Computes the constant strain-displacement matrix B for a T3 element.\"\"\"\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    \n    area = 0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    if area <= 0:\n        raise ValueError(\"Element has zero or negative area, check node ordering.\")\n    \n    b = np.zeros((3, 6))\n    b[0, 0] = y2 - y3\n    b[0, 2] = y3 - y1\n    b[0, 4] = y1 - y2\n    b[1, 1] = x3 - x2\n    b[1, 3] = x1 - x3\n    b[1, 5] = x2 - x1\n    b[2, 0] = x3 - x2\n    b[2, 1] = y2 - y3\n    b[2, 2] = x1 - x3\n    b[2, 3] = y3 - y1\n    b[2, 4] = x2 - x1\n    b[2, 5] = y1 - y2\n    \n    return b / (2 * area), area\n\ndef get_q4_gauss_points():\n    \"\"\"Returns 2x2 Gauss quadrature points and weights.\"\"\"\n    p = 1.0 / np.sqrt(3.0)\n    points = [(-p, -p), (p, -p), (p, p), (-p, p)]\n    weights = [1.0, 1.0, 1.0, 1.0]\n    return points, weights\n\ndef get_q4_shape_functions_derivs(xi, eta):\n    \"\"\"Derivatives of Q4 shape functions wrt natural coords (xi, eta).\"\"\"\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return dN_dxi, dN_deta\n\ndef generate_mesh(domain_dims, grid_dims, elem_type):\n    \"\"\"Generates a structured mesh of T3 or Q4 elements.\"\"\"\n    lx, ly = domain_dims\n    nx, ny = grid_dims\n    \n    x_coords = np.linspace(0, lx, nx + 1)\n    y_coords = np.linspace(0, ly, ny + 1)\n    \n    nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n    \n    elements = []\n    if elem_type == 'Q4':\n        for j in range(ny):\n            for i in range(nx):\n                n1 = j * (nx + 1) + i\n                n2 = n1 + 1\n                n3 = (j + 1) * (nx + 1) + i + 1\n                n4 = n3 - 1\n                elements.append([n1, n2, n3, n4])\n    elif elem_type == 'T3':\n        for j in range(ny):\n            for i in range(nx):\n                n1 = j * (nx + 1) + i\n                n2 = n1 + 1\n                n3 = (j + 1) * (nx + 1) + i + 1\n                n4 = n3 - 1\n                # Split quad into two triangles (CCW ordering)\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n    \n    return nodes, np.array(elements)\n\ndef run_patch_test(E, nu, coeffs, case_params):\n    \"\"\"Runs a single patch test case.\"\"\"\n    # 1. Setup\n    d_matrix = get_plane_strain_d_matrix(E, nu)\n    \n    a0, a1, a2 = coeffs['a0'], coeffs['a1'], coeffs['a2']\n    b0, b1, b2 = coeffs['b0'], coeffs['b1'], coeffs['b2']\n    \n    exact_strain = np.array([a1, b2, a2 + b1])\n    exact_stress_vec = d_matrix @ exact_strain\n    exact_stress_tensor = np.array([\n        [exact_stress_vec[0], exact_stress_vec[2]],\n        [exact_stress_vec[2], exact_stress_vec[1]]\n    ])\n\n    nodes, elements = generate_mesh(case_params['domain'], case_params['grid'], case_params['type'])\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    \n    # 2. Impose displacements and assemble global stiffness\n    u_global = np.zeros(num_dofs)\n    for i, (x, y) in enumerate(nodes):\n        u_global[2*i] = a0 + a1 * x + a2 * y\n        u_global[2*i+1] = b0 + b1 * x + b2 * y\n    \n    K_global = np.zeros((num_dofs, num_dofs))\n    max_strain_error = 0.0\n\n    if case_params['type'] == 'T3':\n        for el_nodes in elements:\n            coords = nodes[el_nodes]\n            B, area = get_t3_b_matrix(coords)\n            k_e = area * B.T @ d_matrix @ B\n            \n            dofs = np.ravel([[2*n, 2*n+1] for n in el_nodes])\n            K_global[np.ix_(dofs, dofs)] += k_e\n\n            u_e = u_global[dofs]\n            strain = B @ u_e\n            max_strain_error = max(max_strain_error, np.max(np.abs(strain - exact_strain)))\n\n    elif case_params['type'] == 'Q4':\n        gauss_points, gauss_weights = get_q4_gauss_points()\n        for el_nodes in elements:\n            coords = nodes[el_nodes]\n            k_e = np.zeros((8, 8))\n            \n            for gp, weight in zip(gauss_points, gauss_weights):\n                xi, eta = gp\n                dN_dxi, dN_deta = get_q4_shape_functions_derivs(xi, eta)\n                \n                J = np.vstack((dN_dxi, dN_deta)) @ coords\n                detJ = np.linalg.det(J)\n                if detJ <= 0: raise ValueError(\"Invalid Jacobian.\")\n                \n                dN_dxy = np.linalg.inv(J) @ np.vstack((dN_dxi, dN_deta))\n                \n                B_gp = np.zeros((3, 8))\n                B_gp[0, 0::2] = dN_dxy[0, :]\n                B_gp[1, 1::2] = dN_dxy[1, :]\n                B_gp[2, 0::2] = dN_dxy[1, :]\n                B_gp[2, 1::2] = dN_dxy[0, :]\n                \n                k_e += weight * (B_gp.T @ d_matrix @ B_gp) * detJ\n                \n                dofs = np.ravel([[2*n, 2*n+1] for n in el_nodes])\n                u_e = u_global[dofs]\n                strain = B_gp @ u_e\n                max_strain_error = max(max_strain_error, np.max(np.abs(strain - exact_strain)))\n            \n            dofs = np.ravel([[2*n, 2*n+1] for n in el_nodes])\n            K_global[np.ix_(dofs, dofs)] += k_e\n\n    # 3. Compute Reaction Forces\n    r_numerical = K_global @ u_global\n\n    # 4. Compute Exact Nodal Forces\n    f_exact = np.zeros(num_dofs)\n    all_edges = []\n    for el_idx, el_nodes in enumerate(elements):\n        for i in range(len(el_nodes)):\n            n1 = el_nodes[i]\n            n2 = el_nodes[(i + 1) % len(el_nodes)]\n            # Store edge with consistent node ordering (min, max) for counting\n            all_edges.append(tuple(sorted((n1, n2))))\n    \n    edge_counts = Counter(all_edges)\n    boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n\n    # Find the original orientation of boundary edges for normal calculation\n    for el_idx, el_nodes in enumerate(elements):\n        for i in range(len(el_nodes)):\n            n1 = el_nodes[i]\n            n2 = el_nodes[(i + 1) % len(el_nodes)]\n            if tuple(sorted((n1,n2))) in boundary_edges:\n                p1, p2 = nodes[n1], nodes[n2]\n                dx, dy = p2 - p1\n                edge_len = np.sqrt(dx**2 + dy**2)\n                \n                # Outward normal for CCW element ordering\n                normal = np.array([dy, -dx]) / edge_len\n                \n                traction = exact_stress_tensor @ normal\n                nodal_force_contribution = 0.5 * edge_len * traction\n                \n                f_exact[2*n1] += nodal_force_contribution[0]\n                f_exact[2*n1+1] += nodal_force_contribution[1]\n                f_exact[2*n2] += nodal_force_contribution[0]\n                f_exact[2*n2+1] += nodal_force_contribution[1]\n\n    # 5. Calculate Errors\n    e_eps = max_strain_error\n    \n    norm_f_exact = np.linalg.norm(f_exact)\n    norm_force_err = np.linalg.norm(r_numerical - f_exact)\n    e_r = norm_force_err / max(norm_f_exact, 1.0)\n    \n    return e_eps, e_r\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    E = 3.0e7\n    nu = 0.25\n    coeffs = {'a0': 0.01, 'a1': 0.2, 'a2': -0.1, 'b0': -0.02, 'b1': 0.05, 'b2': 0.15}\n\n    test_cases = [\n        {'id': 1, 'domain': [1.0, 1.0], 'grid': [2, 2], 'type': 'T3'},\n        {'id': 2, 'domain': [2.0, 1.0], 'grid': [2, 1], 'type': 'Q4'},\n        {'id': 3, 'domain': [2.0, 0.2], 'grid': [2, 1], 'type': 'T3'}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        e_eps, e_r = run_patch_test(E, nu, coeffs, case)\n        all_results.extend([e_eps, e_r])\n\n    print(f\"[{','.join(f'{r:.15g}' for r in all_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}