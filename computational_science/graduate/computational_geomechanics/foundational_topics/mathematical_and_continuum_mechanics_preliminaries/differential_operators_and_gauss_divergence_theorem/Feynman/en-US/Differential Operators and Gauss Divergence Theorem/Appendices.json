{
    "hands_on_practices": [
        {
            "introduction": "The foundation of computational mechanics lies in translating continuous differential operators into discrete forms that a computer can solve. The Gauss divergence theorem offers a powerful and physically intuitive pathway for this translation, particularly for the divergence operator. In this first exercise , you will derive a discrete divergence operator based on the integral form of the theorem and then perform a \"patch test,\" a fundamental verification technique that ensures your discrete operator can exactly reproduce the behavior of simple, well-behaved physical fields.",
            "id": "3517016",
            "problem": "Consider a two-dimensional continuum domain with spatial coordinates denoted by $x$ and $y$, and let the Cauchy stress tensor field be $\\boldsymbol{\\sigma}(x,y)\\in\\mathbb{R}^{2\\times 2}$. The differential operator divergence applied to a second-order tensor is defined row-wise: for row $i\\in\\{1,2\\}$, the divergence is $(\\nabla\\cdot\\boldsymbol{\\sigma})_i=\\sum_{j=1}^{2}\\frac{\\partial \\sigma_{ij}}{\\partial x_j}$, where $x_1=x$ and $x_2=y$, and where each $\\sigma_{ij}$ is a component function of $x$ and $y$. The Gauss divergence theorem states that for any sufficiently smooth vector field $\\mathbf{a}(x,y)$,\n$$\n\\int_{\\Omega} \\nabla\\cdot \\mathbf{a}\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\mathbf{a}\\cdot\\mathbf{n}\\,\\mathrm{d}s,\n$$\nwhere $\\Omega\\subset\\mathbb{R}^2$ is an open set with piecewise smooth boundary $\\partial\\Omega$, $\\mathbf{n}$ is the outward unit normal on $\\partial\\Omega$, $\\mathrm{d}A$ is an area measure, and $\\mathrm{d}s$ is a line measure. In continuum mechanics, the traction vector on a boundary with unit normal $\\mathbf{n}$ derived from $\\boldsymbol{\\sigma}$ has components $t_i=\\sum_{j=1}^{2}\\sigma_{ij} n_j$, and the Gauss divergence theorem applied row-wise yields, for each $i\\in\\{1,2\\}$,\n$$\n\\int_{\\Omega} (\\nabla\\cdot\\boldsymbol{\\sigma})_i\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right)\\,\\mathrm{d}s.\n$$\n\nTasks:\n1. Starting from the definition of the derivative and the above row-wise definition of the divergence, demonstrate that for a spatially constant stress field $\\boldsymbol{\\sigma}(x,y)=\\boldsymbol{\\sigma}_0$ (where each $\\sigma_{ij}$ is independent of $x$ and $y$), the divergence $\\nabla\\cdot\\boldsymbol{\\sigma}$ vanishes everywhere in the domain.\n\n2. Construct a discrete divergence operator for a rectangular grid that is derived from the Gauss divergence theorem. Consider a single rectangular cell with side lengths $h_x$ in the $x$-direction and $h_y$ in the $y$-direction, area $A=h_x h_y$, and four faces: left and right (with normals $(-1,0)$ and $(1,0)$, respectively) and bottom and top (with normals $(0,-1)$ and $(0,1)$, respectively). Define the discrete divergence in each cell by approximating the boundary integral on each face via the midpoint evaluation of the traction components $t_i=\\sum_{j=1}^{2}\\sigma_{ij}n_j$, summing the four face contributions, and dividing by the cell area $A$. Implement this discrete operator on a uniform structured grid covering the domain.\n\n3. In computational geomechanics, a \"patch test\" verifies that a discrete operator reproduces exactly certain polynomial fields. Construct and verify a patch test in which body forces are balanced exactly by a stress field whose entries are at most linear in $x$ and $y$. Specifically, use a stress tensor of the form\n$$\n\\boldsymbol{\\sigma}(x,y) \\;=\\;\n\\begin{bmatrix}\na_{11} x + b_{11} y + c_{11} & a_{12} x + b_{12} y + c_{12} \\\\\na_{21} x + b_{21} y + c_{21} & a_{22} x + b_{22} y + c_{22}\n\\end{bmatrix},\n$$\nwhere all $a_{ij}$ and $b_{ij}$ have units of $\\mathrm{Pa/m}$ and all $c_{ij}$ have units of $\\mathrm{Pa}$. The analytical body force per unit volume (with units $\\mathrm{N/m^3}$) implied by $\\nabla\\cdot\\boldsymbol{\\sigma}$ is spatially constant and given by\n$$\n\\mathbf{b} \\;=\\;\n\\begin{bmatrix}\n\\frac{\\partial \\sigma_{11}}{\\partial x} + \\frac{\\partial \\sigma_{12}}{\\partial y} \\\\\n\\frac{\\partial \\sigma_{21}}{\\partial x} + \\frac{\\partial \\sigma_{22}}{\\partial y}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\na_{11} + b_{12} \\\\\na_{21} + b_{22}\n\\end{bmatrix}.\n$$\nUsing the discrete operator from Task $2$, verify that the discrete divergence computed per cell exactly matches $\\mathbf{b}$ for the following test suite.\n\nTest suite specifications and units:\n- All domains are rectangular with lengths specified in meters ($\\mathrm{m}$). Grid counts $N_x$ and $N_y$ are integers. All stress coefficients $a_{ij}$, $b_{ij}$ are in $\\mathrm{Pa/m}$, all $c_{ij}$ are in $\\mathrm{Pa}$. Error measures must be reported in $\\mathrm{N/m^3}$. Angles are not used in this problem.\n- Compute the maximum absolute discrepancy across all cells and both divergence components, denoted $E$ (with units $\\mathrm{N/m^3}$), between the discrete divergence and the analytical $\\mathbf{b}$. Also report whether the patch test is satisfied exactly within a tolerance $\\varepsilon=10^{-12}\\,\\mathrm{N/m^3}$, by outputting a boolean value that is $\\mathrm{True}$ if $E\\le\\varepsilon$ and $\\mathrm{False}$ otherwise.\n\nProvide the following three test cases:\n- Case $1$ (constant stress field; boundary condition sanity check):\n  - Domain: $L_x=2\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, grid: $N_x=4$, $N_y=2$.\n  - Coefficients: $a_{ij}=0\\,\\mathrm{Pa/m}$ and $b_{ij}=0\\,\\mathrm{Pa/m}$ for all $i,j$; $c_{11}=1000\\,\\mathrm{Pa}$, $c_{12}=-500\\,\\mathrm{Pa}$, $c_{21}=-500\\,\\mathrm{Pa}$, $c_{22}=2000\\,\\mathrm{Pa}$.\n  - Expected analytical divergence: identically zero; compute $E_1$.\n\n- Case $2$ (general linear stress; interior patch test):\n  - Domain: $L_x=3\\,\\mathrm{m}$, $L_y=2\\,\\mathrm{m}$, grid: $N_x=3$, $N_y=2$.\n  - Coefficients:\n    - $a_{11}=300\\,\\mathrm{Pa/m}$, $b_{11}=50\\,\\mathrm{Pa/m}$, $c_{11}=100\\,\\mathrm{Pa}$,\n    - $a_{12}=-20\\,\\mathrm{Pa/m}$, $b_{12}=10\\,\\mathrm{Pa/m}$, $c_{12}=30\\,\\mathrm{Pa}$,\n    - $a_{21}=45\\,\\mathrm{Pa/m}$, $b_{21}=-15\\,\\mathrm{Pa/m}$, $c_{21}=5\\,\\mathrm{Pa}$,\n    - $a_{22}=-60\\,\\mathrm{Pa/m}$, $b_{22}=25\\,\\mathrm{Pa/m}$, $c_{22}=70\\,\\mathrm{Pa}$.\n  - Analytical body force: $\\mathbf{b}=\\begin{bmatrix}310\\\\70\\end{bmatrix}\\,\\mathrm{N/m^3}$; compute $E_2$ and the boolean $B_2$ indicating whether $E_2\\le \\varepsilon$.\n\n- Case $3$ (anisotropic grid with boundary faces; mixed-zero linear stress):\n  - Domain: $L_x=5\\,\\mathrm{m}$, $L_y=0.5\\,\\mathrm{m}$, grid: $N_x=5$, $N_y=1$.\n  - Coefficients:\n    - $a_{11}=0\\,\\mathrm{Pa/m}$, $b_{11}=200\\,\\mathrm{Pa/m}$, $c_{11}=10\\,\\mathrm{Pa}$,\n    - $a_{12}=0\\,\\mathrm{Pa/m}$, $b_{12}=5\\,\\mathrm{Pa/m}$, $c_{12}=20\\,\\mathrm{Pa}$,\n    - $a_{21}=-80\\,\\mathrm{Pa/m}$, $b_{21}=0\\,\\mathrm{Pa/m}$, $c_{21}=15\\,\\mathrm{Pa}$,\n    - $a_{22}=0\\,\\mathrm{Pa/m}$, $b_{22}=0\\,\\mathrm{Pa/m}$, $c_{22}=40\\,\\mathrm{Pa}$.\n  - Analytical body force: $\\mathbf{b}=\\begin{bmatrix}5\\\\-80\\end{bmatrix}\\,\\mathrm{N/m^3}$; compute $E_3$ and the boolean $B_3$ indicating whether $E_3\\le \\varepsilon$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n  - $[E_1,E_2,B_2,E_3,B_3]$,\nwhere $E_1$, $E_2$, and $E_3$ are floats representing errors in $\\mathrm{N/m^3}$, and $B_2$ and $B_3$ are boolean values. No other text must be printed.",
            "solution": "The supplied problem is valid. It is scientifically grounded in continuum mechanics and numerical analysis, well-posed with a unique and verifiable solution, and all terms and conditions are specified completely and unambiguously.\n\nThe solution will be presented in three parts, corresponding to the tasks in the problem statement.\n\n### Task 1: Divergence of a Constant Stress Field\n\nThe first task is to demonstrate that the divergence of a spatially constant stress field, $\\boldsymbol{\\sigma}(x,y) = \\boldsymbol{\\sigma}_0$, is zero. The components of $\\boldsymbol{\\sigma}_0$ are constants, which we denote as $\\sigma_{ij,0}$. The row-wise definition of the tensor divergence is given as:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_i = \\sum_{j=1}^{2} \\frac{\\partial \\sigma_{ij}}{\\partial x_j} = \\frac{\\partial \\sigma_{i1}}{\\partial x} + \\frac{\\partial \\sigma_{i2}}{\\partial y} $$\nwhere $x_1=x$ and $x_2=y$.\n\nFor a constant stress field, each component $\\sigma_{ij}(x,y) = \\sigma_{ij,0}$ is a constant value, independent of the spatial coordinates $x$ and $y$. The partial derivative of a constant with respect to any variable is zero.\n$$ \\frac{\\partial \\sigma_{ij,0}}{\\partial x} = 0 \\quad \\text{and} \\quad \\frac{\\partial \\sigma_{ij,0}}{\\partial y} = 0 $$\nfor all $i,j \\in \\{1,2\\}$.\n\nSubstituting these into the definition of the divergence for the first component ($i=1$):\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_1 = \\frac{\\partial \\sigma_{11,0}}{\\partial x} + \\frac{\\partial \\sigma_{12,0}}{\\partial y} = 0 + 0 = 0 $$\nAnd for the second component ($i=2$):\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_2 = \\frac{\\partial \\sigma_{21,0}}{\\partial x} + \\frac{\\partial \\sigma_{22,0}}{\\partial y} = 0 + 0 = 0 $$\nTherefore, the divergence vector is the zero vector, $\\nabla\\cdot\\boldsymbol{\\sigma} = \\mathbf{0}$, for any constant stress field.\n\n### Task 2: Construction of the Discrete Divergence Operator\n\nThe second task is to construct a discrete divergence operator for a rectangular cell using the integral form of the Gauss divergence theorem. The theorem applied row-wise to the stress tensor $\\boldsymbol{\\sigma}$ over a cell domain $\\Omega_c$ is:\n$$ \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A = \\int_{\\partial\\Omega_c} (\\boldsymbol{\\sigma}\\mathbf{n})_i \\, \\mathrm{d}s $$\nwhere $(\\boldsymbol{\\sigma}\\mathbf{n})_i = \\sum_{j=1}^2 \\sigma_{ij}n_j$ is the $i$-th component of the traction vector.\n\nWe can approximate the cell-averaged divergence, which we call the discrete divergence $(\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c}$, by assuming the integrand on the left is constant over the cell:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} \\cdot A_c \\approx \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A $$\nwhere $A_c = h_x h_y$ is the area of the rectangular cell. This leads to the definition:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} = \\frac{1}{A_c} \\int_{\\partial\\Omega_c} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right) \\, \\mathrm{d}s $$\nThe boundary integral is evaluated by summing the contributions from the four faces of the cell: right (R), left (L), top (T), and bottom (B). Let the cell be centered at $(x_c, y_c)$. The face midpoints are located at $(x_c+h_x/2, y_c)$, $(x_c-h_x/2, y_c)$, $(x_c, y_c+h_y/2)$, and $(x_c, y_c-h_y/2)$, respectively. We use the midpoint rule to approximate the integral over each face.\n\nLet's derive the expression for the first component ($i=1$):\n- **Right Face (R)**: Normal $\\mathbf{n}=(1,0)$. Length $h_y$. Traction component $t_1 = \\sigma_{11}n_1 + \\sigma_{12}n_2 = \\sigma_{11}(1) + \\sigma_{12}(0) = \\sigma_{11}$. The integral is approximated as $\\sigma_{11}(x_c+h_x/2, y_c) \\cdot h_y$.\n- **Left Face (L)**: Normal $\\mathbf{n}=(-1,0)$. Length $h_y$. Traction component $t_1 = \\sigma_{11}(-1) + \\sigma_{12}(0) = -\\sigma_{11}$. The integral is approximated as $-\\sigma_{11}(x_c-h_x/2, y_c) \\cdot h_y$.\n- **Top Face (T)**: Normal $\\mathbf{n}=(0,1)$. Length $h_x$. Traction component $t_1 = \\sigma_{11}(0) + \\sigma_{12}(1) = \\sigma_{12}$. The integral is approximated as $\\sigma_{12}(x_c, y_c+h_y/2) \\cdot h_x$.\n- **Bottom Face (B)**: Normal $\\mathbf{n}=(0,-1)$. Length $h_x$. Traction component $t_1 = \\sigma_{11}(0) + \\sigma_{12}(-1) = -\\sigma_{12}$. The integral is approximated as $-\\sigma_{12}(x_c, y_c-h_y/2) \\cdot h_x$.\n\nSumming these contributions and dividing by $A_c = h_x h_y$:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{1}{h_x h_y} \\left[ \\sigma_{11}(x_c+\\frac{h_x}{2}, y_c)h_y - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)h_y + \\sigma_{12}(x_c, y_c+\\frac{h_y}{2})h_x - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})h_x \\right] $$\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\nThis is a standard second-order central difference approximation of $(\\nabla\\cdot\\boldsymbol{\\sigma})_1$ at the cell center.\n\nBy an identical procedure for the second component ($i=2$), we find:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{21}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{22}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{22}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\n\n### Task 3: Patch Test Verification\n\nThe third task is to verify that this discrete operator exactly reproduces the divergence of a stress field whose components are linear functions of $x$ and $y$: $\\sigma_{ij}(x,y) = a_{ij}x+b_{ij}y+c_{ij}$. The analytical divergence is $\\mathbf{b} = [a_{11}+b_{12}, a_{21}+b_{22}]^T$.\n\nLet's evaluate the first component of the discrete divergence using the linear stress field.\nThe first term is a finite difference of $\\sigma_{11}(x,y) = a_{11}x+b_{11}y+c_{11}$:\n$$ \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} = \\frac{[a_{11}(x_c+\\frac{h_x}{2}) + b_{11}y_c + c_{11}] - [a_{11}(x_c-\\frac{h_x}{2}) + b_{11}y_c + c_{11}]}{h_x} $$\n$$ = \\frac{a_{11}(x_c+\\frac{h_x}{2} - (x_c-\\frac{h_x}{2}))}{h_x} = \\frac{a_{11}h_x}{h_x} = a_{11} $$\nThe second term is a finite difference of $\\sigma_{12}(x,y) = a_{12}x+b_{12}y+c_{12}$:\n$$ \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} = \\frac{[a_{12}x_c + b_{12}(y_c+\\frac{h_y}{2}) + c_{12}] - [a_{12}x_c + b_{12}(y_c-\\frac{h_y}{2}) + c_{12}]}{h_y} $$\n$$ = \\frac{b_{12}(y_c+\\frac{h_y}{2} - (y_c-\\frac{h_y}{2}))}{h_y} = \\frac{b_{12}h_y}{h_y} = b_{12} $$\nSumming these two results, we get the first component of the discrete divergence:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = a_{11} + b_{12} $$\nThis exactly matches the first component of the analytical divergence vector $\\mathbf{b}$. The result is independent of the cell's location $(x_c, y_c)$ and dimensions $(h_x, h_y)$.\n\nRepeating this for the second component, $(\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c}$, using $\\sigma_{21}$ and $\\sigma_{22}$:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(\\dots) - \\sigma_{21}(\\dots)}{h_x} + \\frac{\\sigma_{22}(\\dots) - \\sigma_{22}(\\dots)}{h_y} = a_{21} + b_{22} $$\nThis also exactly matches the analytical result.\n\nThis confirms that the discrete divergence operator, constructed from the Gauss divergence theorem with a midpoint rule approximation for face integrals, passes the patch test for linear stress fields. Any difference between the computed discrete divergence and the analytical value will be due to floating-point arithmetic limitations, not a deficiency in the method.\n\nThe following Python code implements this verification. The `run_patch_test` function computes the discrete divergence for each cell in a grid according to the derived formula. It then calculates the maximum absolute difference between the computed and analytical divergence across all cells and both components. This error is compared against the given tolerance $\\varepsilon=10^{-12}$ to determine if the test is passed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the patch test verification for all given cases.\n    \"\"\"\n    epsilon = 1e-12\n\n    # Case 1: constant stress field\n    case1_params = {\n        \"Lx\": 2.0, \"Ly\": 1.0, \"Nx\": 4, \"Ny\": 2,\n        \"coeffs\": {\n            \"c11\": 1000.0, \"c12\": -500.0, \"c21\": -500.0, \"c22\": 2000.0\n        }\n    }\n    E1 = run_patch_test(**case1_params)\n\n    # Case 2: general linear stress\n    case2_params = {\n        \"Lx\": 3.0, \"Ly\": 2.0, \"Nx\": 3, \"Ny\": 2,\n        \"coeffs\": {\n            \"a11\": 300.0, \"b11\": 50.0, \"c11\": 100.0,\n            \"a12\": -20.0, \"b12\": 10.0, \"c12\": 30.0,\n            \"a21\": 45.0, \"b21\": -15.0, \"c21\": 5.0,\n            \"a22\": -60.0, \"b22\": 25.0, \"c22\": 70.0,\n        }\n    }\n    E2 = run_patch_test(**case2_params)\n    B2 = E2 <= epsilon\n\n    # Case 3: anisotropic grid with mixed-zero linear stress\n    case3_params = {\n        \"Lx\": 5.0, \"Ly\": 0.5, \"Nx\": 5, \"Ny\": 1,\n        \"coeffs\": {\n            \"a11\": 0.0, \"b11\": 200.0, \"c11\": 10.0,\n            \"a12\": 0.0, \"b12\": 5.0, \"c12\": 20.0,\n            \"a21\": -80.0, \"b21\": 0.0, \"c21\": 15.0,\n            \"a22\": 0.0, \"b22\": 0.0, \"c22\": 40.0,\n        }\n    }\n    E3 = run_patch_test(**case3_params)\n    B3 = E3 <= epsilon\n\n    results = [E1, E2, B2, E3, B3]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(Lx, Ly, Nx, Ny, coeffs):\n    \"\"\"\n    Computes discrete divergence on a grid and returns the maximum error.\n\n    Args:\n        Lx (float): Domain length in x-direction.\n        Ly (float): Domain length in y-direction.\n        Nx (int): Number of cells in x-direction.\n        Ny (int): Number of cells in y-direction.\n        coeffs (dict): Dictionary of stress coefficients a_ij, b_ij, c_ij.\n\n    Returns:\n        float: The maximum absolute error between discrete and analytical divergence.\n    \"\"\"\n    hx = Lx / Nx\n    hy = Ly / Ny\n\n    # Define stress component functions based on coefficients\n    # Use .get(key, 0.0) to handle missing coefficients (implicitly zero)\n    def s11(x, y): return coeffs.get('a11', 0.0)*x + coeffs.get('b11', 0.0)*y + coeffs.get('c11', 0.0)\n    def s12(x, y): return coeffs.get('a12', 0.0)*x + coeffs.get('b12', 0.0)*y + coeffs.get('c12', 0.0)\n    def s21(x, y): return coeffs.get('a21', 0.0)*x + coeffs.get('b21', 0.0)*y + coeffs.get('c21', 0.0)\n    def s22(x, y): return coeffs.get('a22', 0.0)*x + coeffs.get('b22', 0.0)*y + coeffs.get('c22', 0.0)\n\n    # Calculate analytical body force (divergence) vector\n    b_analytical_1 = coeffs.get('a11', 0.0) + coeffs.get('b12', 0.0)\n    b_analytical_2 = coeffs.get('a21', 0.0) + coeffs.get('b22', 0.0)\n\n    max_error = 0.0\n\n    # Iterate over all cells in the grid\n    for iy in range(Ny):\n        for ix in range(Nx):\n            # Coordinates of cell face midpoints\n            x_center = (ix + 0.5) * hx\n            y_center = (iy + 0.5) * hy\n            \n            x_right_face = (ix + 1.0) * hx\n            x_left_face = ix * hx\n            y_top_face = (iy + 1.0) * hy\n            y_bottom_face = iy * hy\n\n            # Evaluate stress components at face midpoints\n            s11_r = s11(x_right_face, y_center)\n            s11_l = s11(x_left_face, y_center)\n            s12_t = s12(x_center, y_top_face)\n            s12_b = s12(x_center, y_bottom_face)\n\n            s21_r = s21(x_right_face, y_center)\n            s21_l = s21(x_left_face, y_center)\n            s22_t = s22(x_center, y_top_face)\n            s22_b = s22(x_center, y_bottom_face)\n\n            # Compute discrete divergence for the cell\n            div_s_1 = (s11_r - s11_l) / hx + (s12_t - s12_b) / hy\n            div_s_2 = (s21_r - s21_l) / hx + (s22_t - s22_b) / hy\n\n            # Calculate error for this cell\n            error1 = abs(div_s_1 - b_analytical_1)\n            error2 = abs(div_s_2 - b_analytical_2)\n\n            # Update maximum error\n            max_error = max(max_error, error1, error2)\n\n    return max_error\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having established a locally accurate discrete operator, we now shift our focus to the global implications of the divergence theorem. A key consequence is that the total source or sink of a quantity within a domain must equal the net flux across its boundary. This practice  guides you through a numerical verification of this global conservation principle, demonstrating how the summation of local, cell-level fluxes telescopically cancels interior contributions, leaving only the boundary flux, a cornerstone of stable finite volume methods.",
            "id": "3516986",
            "problem": "Consider a computational geomechanics verification exercise in which a face-based Finite Volume Method (FVM) is used to approximate the divergence of a vector field over orthogonal grids in two and three dimensions. The aim is to construct tests where the exact solution has constant divergence and to verify that the discrete scheme reproduces the exact global flux to machine precision.\n\nYou are given a family of vector fields with components that depend only on their corresponding coordinate:\n- In two dimensions, define the velocity field $\\mathbf{v}(x,y) = \\left(v_x(x), v_y(y)\\right)$ with $v_x(x) = a_x x + b_x$ and $v_y(y) = a_y y + b_y$.\n- In three dimensions, define the velocity field $\\mathbf{v}(x,y,z) = \\left(v_x(x), v_y(y), v_z(z)\\right)$ with $v_x(x) = a_x x + b_x$, $v_y(y) = a_y y + b_y$, and $v_z(z) = a_z z + b_z$.\n\nFor these fields, the divergence $\\nabla \\cdot \\mathbf{v}$ is constant over the domain, equal to $a_x + a_y$ in two dimensions and $a_x + a_y + a_z$ in three dimensions.\n\nDiscretization is performed on orthogonal grids composed of axis-aligned rectangles (two dimensions) or rectangular bricks (three dimensions). Each grid is specified either by uniform counts in each direction, which imply equal cell widths, or by explicit lists of positive cell widths in each direction that sum to the corresponding domain length. The face-based FVM discrete divergence in a single cell is defined as the sum of outward face-normal fluxes across the cell faces divided by the cell measure (area in two dimensions, volume in three dimensions). The discrete global flux is defined as the sum of outward fluxes across all boundary faces of the domain, computed by evaluating the normal component of $\\mathbf{v}$ at the face center and multiplying by the face measure, summed over all boundary faces with outward normals.\n\nYour program must:\n1. Implement routines to construct orthogonal grids from given specifications in two and three dimensions. For uniform grids, use equal cell widths; for nonuniform grids, use the provided cell width arrays. Let the domain extents be $\\left[0,L_x\\right]\\times\\left[0,L_y\\right]$ in two dimensions and $\\left[0,L_x\\right]\\times\\left[0,L_y\\right]\\times\\left[0,L_z\\right]$ in three dimensions, with $L_x$, $L_y$, $L_z$ equal to the sum of the corresponding cell widths.\n2. Implement a face-based FVM discrete divergence operator that, for each cell, forms the sum of outward face-normal fluxes across the cell faces and divides by the cell area (two dimensions) or cell volume (three dimensions). Sum this discrete divergence times the cell measure over all cells to obtain the discrete global production.\n3. Compute the discrete global boundary flux by summing outward fluxes across all domain boundary faces using face-center evaluation of $\\mathbf{v}$ and face measures.\n4. Compute the exact volume integral of the divergence of $\\mathbf{v}$ over the domain for each test case based on the constant divergence and domain measure.\n5. Verify, for each test case, that both the discrete global production (sum over all cells) and the discrete global boundary flux agree with the exact volume integral of the divergence to machine precision, where the tolerance is $10^{-13}$ on the absolute difference.\n\nTest suite:\nEvaluate the following four test cases, each specified by the dimension, domain specification, grid, and coefficients of the velocity field.\n\n- Test case $1$ (two dimensions, uniform grid):\n  - Domain: $\\left[0, L_x\\right]\\times\\left[0, L_y\\right]$ with $L_x = 1$ and $L_y = 1$.\n  - Grid: $N_x = 10$, $N_y = 7$ (uniform widths).\n  - Field coefficients: $a_x = 2.0$, $b_x = -1.0$, $a_y = 3.0$, $b_y = 0.5$.\n\n- Test case $2$ (two dimensions, single cell):\n  - Domain: $\\left[0, L_x\\right]\\times\\left[0, L_y\\right]$ with $L_x = 2$ and $L_y = 3$.\n  - Grid: $N_x = 1$, $N_y = 1$ (uniform widths).\n  - Field coefficients: $a_x = 1.25$, $b_x = 0.0$, $a_y = -0.25$, $b_y = 0.0$.\n\n- Test case $3$ (three dimensions, uniform grid):\n  - Domain: $\\left[0, L_x\\right]\\times\\left[0, L_y\\right]\\times\\left[0, L_z\\right]$ with $L_x = 0.5$, $L_y = 0.2$, $L_z = 0.1$.\n  - Grid: $N_x = 4$, $N_y = 3$, $N_z = 2$ (uniform widths).\n  - Field coefficients: $a_x = 5.0$, $b_x = 0.0$, $a_y = -2.0$, $b_y = 1.0$, $a_z = 0.5$, $b_z = -0.3$.\n\n- Test case $4$ (two dimensions, nonuniform grid):\n  - Domain: $\\left[0, L_x\\right]\\times\\left[0, L_y\\right]$ with $L_x = 1.0$, $L_y = 1.0$.\n  - Grid: Nonuniform widths with $h_x = [0.1, 0.2, 0.3, 0.4]$ (summing to $L_x$) and $h_y = [0.25, 0.75]$ (summing to $L_y$).\n  - Field coefficients: $a_x = 0.3$, $b_x = 0.0$, $a_y = 0.7$, $b_y = 0.0$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a boolean indicating whether the test case passed the verification at tolerance $10^{-13}$ (for both discrete global production and discrete global boundary flux). For example, the output should look like $\\left[\\text{True},\\text{False},\\ldots\\right]$.",
            "solution": "The problem presents a verification exercise for a face-based Finite Volume Method (FVM) applied to vector fields with constant divergence on orthogonal grids. The core of the exercise is to confirm that two discrete approximations of the volume integral of the divergence match the exact analytical solution to within machine precision. This is a standard procedure in computational code verification, ensuring the implemented numerical scheme is correct for a specific class of problems where an exact solution is known.\n\nThe problem is scientifically and mathematically well-posed. It is grounded in the fundamental principles of vector calculus, specifically Gauss's divergence theorem, and its application in numerical methods. All required data and definitions are provided, and the problem is free of ambiguity or contradiction. We shall proceed with a formal solution.\n\n**1. Analytical Framework: The Divergence Theorem**\n\nThe foundation of this problem is Gauss's divergence theorem, which relates the total divergence within a volume $\\Omega$ to the net flux across its boundary $\\partial\\Omega$.\nIn two dimensions, for a domain $\\Omega \\subset \\mathbb{R}^2$ with boundary $\\partial\\Omega$, the theorem states:\n$$ \\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\,dA = \\oint_{\\partial\\Omega} (\\mathbf{v} \\cdot \\mathbf{n}) \\,ds $$\nIn three dimensions, for a volume $\\Omega \\subset \\mathbb{R}^3$ with boundary surface $\\partial\\Omega$, it is:\n$$ \\iiint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\,dV = \\oiint_{\\partial\\Omega} (\\mathbf{v} \\cdot \\mathbf{n}) \\,dS $$\nwhere $\\mathbf{n}$ is the outward-pointing unit normal vector to the boundary.\n\nThe problem defines specific linear vector fields for which the divergence is constant.\nIn two dimensions, $\\mathbf{v}(x,y) = (v_x(x), v_y(y))$ with $v_x(x) = a_x x + b_x$ and $v_y(y) = a_y y + b_y$. The divergence is:\n$$ \\nabla \\cdot \\mathbf{v} = \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} = a_x + a_y $$\nIn three dimensions, $\\mathbf{v}(x,y,z) = (v_x(x), v_y(y), v_z(z))$ with $v_x(x) = a_x x + b_x$, $v_y(y) = a_y y + b_y$, and $v_z(z) = a_z z + b_z$. The divergence is:\n$$ \\nabla \\cdot \\mathbf{v} = \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} + \\frac{\\partial v_z}{\\partial z} = a_x + a_y + a_z $$\nSince the divergence is constant across the entire domain $\\Omega$, the exact volume integral of the divergence, denoted $I_{exact}$, is simply the product of the constant divergence and the measure (area or volume) of the domain, $M(\\Omega)$:\n$$ I_{exact} = \\int_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\,d\\Omega = (\\nabla \\cdot \\mathbf{v}) \\cdot M(\\Omega) $$\n\n**2. Numerical Formulation: The Finite Volume Method**\n\nThe domain $\\Omega$ is discretized into a set of non-overlapping control volumes (cells) $\\{C_k\\}$. For an orthogonal grid, a 2D cell $C_{ij}$ is a rectangle $[x_i, x_{i+1}] \\times [y_j, y_{j+1}]$ with area $\\Delta A_{ij} = (x_{i+1}-x_i)(y_{j+1}-y_j) = \\Delta x_i \\Delta y_j$.\n\nThe FVM approximates the divergence within a cell by applying the divergence theorem to that cell:\n$$ \\int_{C_{ij}} (\\nabla \\cdot \\mathbf{v}) \\,dA = \\oint_{\\partial C_{ij}} (\\mathbf{v} \\cdot \\mathbf{n}) \\,ds $$\nThe average divergence in cell $C_{ij}$, denoted $(\\nabla \\cdot \\mathbf{v})_{ij}$, is approximated as:\n$$ (\\nabla \\cdot \\mathbf{v})_{ij} \\approx \\frac{1}{\\Delta A_{ij}} \\oint_{\\partial C_{ij}} (\\mathbf{v} \\cdot \\mathbf{n}) \\,ds \\approx \\frac{1}{\\Delta A_{ij}} \\sum_{f \\in \\partial C_{ij}} (\\mathbf{v}_f \\cdot \\mathbf{n}_f) M(f) $$\nwhere the sum is over the faces of the cell, $\\mathbf{v}_f$ is the velocity evaluated at the center of face $f$, $\\mathbf{n}_f$ is the outward normal to face $f$, and $M(f)$ is the measure (length) of face $f$.\n\nLet us analyze the sum of fluxes for a 2D cell $C_{ij}$:\n- **East face:** $x=x_{i+1}$, $\\mathbf{n}=(1,0)$, $M(f)=\\Delta y_j$. Face center is $(x_{i+1}, (y_j+y_{j+1})/2)$. Flux is $v_x(x_{i+1}) \\Delta y_j = (a_x x_{i+1} + b_x) \\Delta y_j$.\n- **West face:** $x=x_i$, $\\mathbf{n}=(-1,0)$, $M(f)=\\Delta y_j$. Face center is $(x_i, (y_j+y_{j+1})/2)$. Flux is $-v_x(x_i) \\Delta y_j = -(a_x x_i + b_x) \\Delta y_j$.\n- **North face:** $y=y_{j+1}$, $\\mathbf{n}=(0,1)$, $M(f)=\\Delta x_i$. Face center is $((x_i+x_{i+1})/2, y_{j+1})$. Flux is $v_y(y_{j+1}) \\Delta x_i = (a_y y_{j+1} + b_y) \\Delta x_i$.\n- **South face:** $y=y_j$, $\\mathbf{n}=(0,-1)$, $M(f)=\\Delta x_i$. Face center is $((x_i+x_{i+1})/2, y_j)$. Flux is $-v_y(y_j) \\Delta x_i = -(a_y y_j + b_y) \\Delta x_i$.\n\nSumming these fluxes gives the total outward flux for cell $C_{ij}$:\n$$ \\sum_{f} \\text{Flux}_f = (a_x x_{i+1} - a_x x_i)\\Delta y_j + (a_y y_{j+1} - a_y y_j)\\Delta x_i $$\n$$ = a_x (x_{i+1}-x_i) \\Delta y_j + a_y (y_{j+1}-y_j) \\Delta x_i = a_x \\Delta x_i \\Delta y_j + a_y \\Delta x_i \\Delta y_j = (a_x+a_y)\\Delta A_{ij} $$\nThe discrete divergence is therefore:\n$$ (\\nabla \\cdot \\mathbf{v})_{ij} = \\frac{(a_x+a_y)\\Delta A_{ij}}{\\Delta A_{ij}} = a_x+a_y $$\nThis demonstrates a critical property: for this specific linear velocity field, the face-center FVM approximation is exact. The discrete divergence in every cell is identical to the analytical divergence. An analogous derivation holds for the 3D case.\n\n**3. Verification Quantities**\n\nThe problem requires the calculation and comparison of three quantities:\n1.  **Exact Volume Integral ($I_{exact}$):** As derived, this is $(\\nabla \\cdot \\mathbf{v}) \\cdot M(\\Omega)$.\n2.  **Discrete Global Production ($I_{prod}$):** This is the sum of the divergence-measure product over all cells, which is equivalent to summing the fluxes from all faces of all cells.\n    $$ I_{prod} = \\sum_k (\\nabla \\cdot \\mathbf{v})_k M(C_k) = \\sum_k (a_x+a_y+\\dots) M(C_k) = (\\nabla \\cdot \\mathbf{v}) \\sum_k M(C_k) = (\\nabla \\cdot \\mathbf{v}) M(\\Omega) = I_{exact} $$\n    The calculation must be implemented by explicitly summing the face fluxes for each cell to verify the implementation.\n3.  **Discrete Global Boundary Flux ($I_{bound}$):** This is the sum of fluxes across only the faces lying on the domain boundary $\\partial\\Omega$.\n    $$ I_{bound} = \\sum_{f \\in \\partial\\Omega} (\\mathbf{v}_f \\cdot \\mathbf{n}_f) M(f) $$\n    Due to the telescoping sum property, when summing all cell fluxes to compute $I_{prod}$, fluxes across interior faces cancel perfectly (each interior face is shared by two cells with opposite normals). Thus, the sum of all cell fluxes reduces to the sum of fluxes on the boundary faces only.\n    $$ I_{prod} = I_{bound} $$\nTherefore, for a correct implementation, all three quantities must be equal to machine precision: $I_{exact} = I_{prod} = I_{bound}$. The verification check against a tolerance of $10^{-13}$ confirms the correctness of the FVM implementation for this manufactured solution.\n\nThe implementation will proceed by constructing the grid, defining the velocity field, and then computing these three quantities for each test case as specified. The final boolean result for each case will be true if and only if both $|I_{prod} - I_{exact}| < 10^{-13}$ and $|I_{bound} - I_{exact}| < 10^{-13}$. Given the analytical exactness, we anticipate all test cases will pass.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (2D, uniform grid)\n        {\n            \"dim\": 2,\n            \"domain_spec\": {\"Lx\": 1.0, \"Ly\": 1.0},\n            \"grid_spec\": {\"type\": \"uniform\", \"Nx\": 10, \"Ny\": 7},\n            \"coeffs\": {\"ax\": 2.0, \"bx\": -1.0, \"ay\": 3.0, \"by\": 0.5}\n        },\n        # Test case 2 (2D, single cell)\n        {\n            \"dim\": 2,\n            \"domain_spec\": {\"Lx\": 2.0, \"Ly\": 3.0},\n            \"grid_spec\": {\"type\": \"uniform\", \"Nx\": 1, \"Ny\": 1},\n            \"coeffs\": {\"ax\": 1.25, \"bx\": 0.0, \"ay\": -0.25, \"by\": 0.0}\n        },\n        # Test case 3 (3D, uniform grid)\n        {\n            \"dim\": 3,\n            \"domain_spec\": {\"Lx\": 0.5, \"Ly\": 0.2, \"Lz\": 0.1},\n            \"grid_spec\": {\"type\": \"uniform\", \"Nx\": 4, \"Ny\": 3, \"Nz\": 2},\n            \"coeffs\": {\"ax\": 5.0, \"bx\": 0.0, \"ay\": -2.0, \"by\": 1.0, \"az\": 0.5, \"bz\": -0.3}\n        },\n        # Test case 4 (2D, nonuniform grid)\n        {\n            \"dim\": 2,\n            \"domain_spec\": {\"Lx\": 1.0, \"Ly\": 1.0},\n            \"grid_spec\": {\n                \"type\": \"nonuniform\",\n                \"hx\": np.array([0.1, 0.2, 0.3, 0.4]),\n                \"hy\": np.array([0.25, 0.75])\n            },\n            \"coeffs\": {\"ax\": 0.3, \"bx\": 0.0, \"ay\": 0.7, \"by\": 0.0}\n        },\n    ]\n\n    results = [run_verification(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_verification(case):\n    \"\"\"\n    Runs the verification for a single test case.\n    \"\"\"\n    dim = case[\"dim\"]\n    coeffs = case[\"coeffs\"]\n    grid_spec = case[\"grid_spec\"]\n    domain_spec = case[\"domain_spec\"]\n    tolerance = 1e-13\n\n    # Define velocity field components\n    v_funcs = []\n    div_val = 0.0\n    dims_map = ['x', 'y', 'z']\n    for i in range(dim):\n        d = dims_map[i]\n        a, b = coeffs[f'a{d}'], coeffs[f'b{d}']\n        v_funcs.append(lambda x, a=a, b=b: a * x + b)\n        div_val += a\n    \n    # Grid construction\n    if grid_spec[\"type\"] == \"uniform\":\n        L = [domain_spec[f'L{d}'] for d in dims_map[:dim]]\n        N = [grid_spec[f'N{d}'] for d in dims_map[:dim]]\n        h = [np.full(N[i], L[i] / N[i]) for i in range(dim)]\n    else: # nonuniform\n        h = [grid_spec[f'h{d}'] for d in dims_map[:dim]]\n        L = [np.sum(h[i]) for i in range(dim)]\n\n    p = [np.concatenate(([0], np.cumsum(h_d))) for h_d in h]\n    \n    # 1. Exact volume integral of divergence\n    domain_measure = np.prod(L)\n    exact_integral = div_val * domain_measure\n\n    # 2. Discrete global production (sum of cell fluxes)\n    total_production = 0.0\n    if dim == 2:\n        px, py = p[0], p[1]\n        hx, hy = h[0], h[1]\n        v_x, v_y = v_funcs[0], v_funcs[1]\n        for i in range(len(hx)):\n            for j in range(len(hy)):\n                # Fluxes for cell (i, j)\n                flux_e = v_x(px[i+1]) * hy[j]\n                flux_w = -v_x(px[i]) * hy[j]\n                flux_n = v_y(py[j+1]) * hx[i]\n                flux_s = -v_y(py[j]) * hx[i]\n                total_production += (flux_e + flux_w + flux_n + flux_s)\n    elif dim == 3:\n        px, py, pz = p[0], p[1], p[2]\n        hx, hy, hz = h[0], h[1], h[2]\n        v_x, v_y, v_z = v_funcs[0], v_funcs[1], v_funcs[2]\n        for i in range(len(hx)):\n            for j in range(len(hy)):\n                for k in range(len(hz)):\n                    # Fluxes for cell (i, j, k)\n                    face_area_yz = hy[j] * hz[k]\n                    face_area_xz = hx[i] * hz[k]\n                    face_area_xy = hx[i] * hy[j]\n                    flux_e = v_x(px[i+1]) * face_area_yz\n                    flux_w = -v_x(px[i]) * face_area_yz\n                    flux_n = v_y(py[j+1]) * face_area_xz\n                    flux_s = -v_y(py[j]) * face_area_xz\n                    flux_t = v_z(pz[k+1]) * face_area_xy\n                    flux_b = -v_z(pz[k]) * face_area_xy\n                    total_production += (flux_e + flux_w + flux_n + flux_s + flux_t + flux_b)\n\n    # 3. Discrete global boundary flux\n    boundary_flux = 0.0\n    if dim == 2:\n        px, py = p[0], p[1]\n        hx, hy = h[0], h[1]\n        v_x, v_y = v_funcs[0], v_funcs[1]\n        # West and East boundaries (x=0, x=Lx)\n        for j in range(len(hy)):\n            boundary_flux += -v_x(px[0]) * hy[j]  # West\n            boundary_flux += v_x(px[-1]) * hy[j] # East\n        # South and North boundaries (y=0, y=Ly)\n        for i in range(len(hx)):\n            boundary_flux += -v_y(py[0]) * hx[i]  # South\n            boundary_flux += v_y(py[-1]) * hx[i] # North\n    elif dim == 3:\n        px, py, pz = p[0], p[1], p[2]\n        hx, hy, hz = h[0], h[1], h[2]\n        v_x, v_y, v_z = v_funcs[0], v_funcs[1], v_funcs[2]\n        # West/East boundaries (x dir)\n        for j in range(len(hy)):\n            for k in range(len(hz)):\n                face_area = hy[j] * hz[k]\n                boundary_flux += -v_x(px[0]) * face_area # West\n                boundary_flux += v_x(px[-1]) * face_area # East\n        # South/North boundaries (y dir)\n        for i in range(len(hx)):\n            for k in range(len(hz)):\n                face_area = hx[i] * hz[k]\n                boundary_flux += -v_y(py[0]) * face_area # South\n                boundary_flux += v_y(py[-1]) * face_area # North\n        # Bottom/Top boundaries (z dir)\n        for i in range(len(hx)):\n            for j in range(len(hy)):\n                face_area = hx[i] * hy[j]\n                boundary_flux += -v_z(pz[0]) * face_area # Bottom\n                boundary_flux += v_z(pz[-1]) * face_area # Top\n\n    # 4. Verification\n    err_prod = abs(total_production - exact_integral)\n    err_bound = abs(boundary_flux - exact_integral)\n    \n    return err_prod < tolerance and err_bound < tolerance\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While patch tests and verifications on ideal grids confirm the correctness of our numerical schemes, real-world geomechanical models often involve complex, non-linear fields and distorted computational meshes where such exactness is no longer guaranteed. This final practice  delves into the practical challenge of numerical accuracy by designing an experiment to quantify the error in the discrete divergence theorem. By systematically increasing mesh distortion, you will investigate how geometric imperfections impact numerical accuracy, a critical consideration for building reliable computational models.",
            "id": "3516994",
            "problem": "You are tasked with designing and implementing a numerical experiment to assess a discrete version of Gauss’s divergence theorem in the context of Darcy flow in porous media with anisotropic permeability. The goal is to quantify, for a single polyhedral control volume, the discrepancy between an approximate volume integral of the divergence of the Darcy flux and an approximate sum of fluxes through the control volume’s boundary faces as the control volume becomes increasingly distorted.\n\nStart from the following foundational base:\n- Darcy’s law for steady incompressible flow in porous media: the specific discharge (Darcy flux) is given by $\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h$, where $\\boldsymbol{K}$ is the symmetric positive definite permeability tensor and $h$ is the hydraulic head.\n- The divergence theorem: for a sufficiently smooth vector field $\\boldsymbol{q}$ on a control volume $K \\subset \\mathbb{R}^3$ with outer unit normal $\\boldsymbol{n}$,\n$$\n\\int_K \\nabla\\cdot\\boldsymbol{q}\\,dV \\;=\\; \\int_{\\partial K} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA \\;=\\; \\sum_{f\\subset\\partial K} \\int_f \\boldsymbol{q}\\cdot\\boldsymbol{n}\\,dA.\n$$\n\nExperiment design (must be followed exactly to ensure universality and testability):\n1. Geometry and distortion:\n   - Represent the control volume $K_{\\delta}$ as the affine image of the reference cube $[0,1]^3$ by $x(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi} + \\boldsymbol{b}$ with $\\boldsymbol{\\xi}\\in[0,1]^3$, $\\boldsymbol{b}=\\boldsymbol{0}$, and\n     $$\n     \\boldsymbol{A}(\\delta) \\;=\\; \\begin{bmatrix} 1 & \\delta & 0 \\\\[4pt] 0 & 1 & \\delta \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}\n     $$\n     Here $\\delta\\ge 0$ is a distortion parameter; $\\delta=0$ gives the unit cube and larger $\\delta$ produces increasingly sheared (and thus distorted) polyhedra. The volume is $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta))$.\n   - The six faces of $K_{\\delta}$ correspond to the planes $\\xi_i=0$ and $\\xi_i=1$ for $i\\in\\{1,2,3\\}$. For the face with fixed index $i$, denote the other indices in cyclic order by $(j,k)$ so that $(i,j,k)$ is a cyclic permutation of $(1,2,3)$.\n\n2. Anisotropic permeability and flux:\n   - Let $\\boldsymbol{K}$ be constant and anisotropic, constructed by rotating a diagonal tensor with eigenvalues $k_1>0$, $k_2>0$, $k_3>0$. Specifically, define\n     $$\n     \\boldsymbol{K}(\\theta, r) \\;=\\; \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top},\n     $$\n     where $\\theta$ is a rotation angle (in radians) about the fixed unit axis $\\boldsymbol{u} = \\frac{1}{\\sqrt{1^2+2^2+3^2}}[1,2,3]^{\\top}$, and $r\\ge 1$ is an anisotropy ratio. The rotation matrix $\\boldsymbol{R}(\\theta)$ should be formed with the Rodrigues formula and must be orthogonal with determinant $+1$.\n   - Define the hydraulic head field as the cubic polynomial\n     $$\n     h(x,y,z) \\;=\\; \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z,\n     $$\n     with fixed coefficients $\\alpha=0.7$, $\\beta=-0.2$, $\\gamma=0.5$, $\\delta_h=0.3$. The Darcy flux is $\\boldsymbol{q}(x) = -\\boldsymbol{K}\\,\\nabla h(x)$.\n\n3. Differential operators needed for the experiment:\n   - The gradient is\n     $$\n     \\nabla h(x,y,z) \\;=\\; \\begin{bmatrix} 3\\alpha\\,x^2 + \\delta_h\\,y\\,z \\\\[4pt] 3\\beta\\,y^2 + \\delta_h\\,x\\,z \\\\[4pt] 3\\gamma\\,z^2 + \\delta_h\\,x\\,y \\end{bmatrix}.\n     $$\n   - The Hessian matrix is\n     $$\n     \\nabla^2 h(x,y,z) \\;=\\; \\begin{bmatrix}\n     6\\alpha\\,x & \\delta_h\\,z & \\delta_h\\,y \\\\\n     \\delta_h\\,z & 6\\beta\\,y & \\delta_h\\,x \\\\\n     \\delta_h\\,y & \\delta_h\\,x & 6\\gamma\\,z\n     \\end{bmatrix}.\n     $$\n   - Since $\\boldsymbol{K}$ is constant in space, the divergence of the Darcy flux is\n     $$\n     \\nabla\\cdot\\boldsymbol{q}(x) \\;=\\; -\\mathrm{tr}\\big(\\boldsymbol{K}\\,\\nabla^2 h(x)\\big),\n     $$\n     which is an affine (linear) function of $x$.\n\n4. Discrete approximations to be compared:\n   - Approximate the volume integral by a one-point rule at the centroid $x_c$ of $K_{\\delta}$:\n     $$\n     \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV \\;\\approx\\; |K_{\\delta}| \\,\\big(\\nabla\\cdot\\boldsymbol{q}\\big)(x_c), \\quad x_c = \\boldsymbol{A}(\\delta)\\,\\begin{bmatrix} \\tfrac12 \\\\ \\tfrac12 \\\\ \\tfrac12 \\end{bmatrix}.\n     $$\n   - Approximate each face integral by a one-point rule at the physical face center. For face $\\xi_i=c$ with $c\\in\\{0,1\\}$, use the $\\boldsymbol{\\xi}$-center $\\boldsymbol{\\xi}_f = (1/2,1/2,1/2)^{\\top}$ with the $i$-th component replaced by $c$, and map it to $x_f=\\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}_f$. The oriented area vector for that face is\n     $$\n     \\boldsymbol{a}_{i,c} \\;=\\; s_{i,c}\\,\\big(\\partial_{\\xi_j}x \\times \\partial_{\\xi_k}x\\big) \\;=\\; s_{i,c}\\,\\big(\\boldsymbol{A}\\,\\boldsymbol{e}_j \\times \\boldsymbol{A}\\,\\boldsymbol{e}_k\\big),\n     $$\n     where $s_{i,c}=+1$ for $c=1$ and $s_{i,c}=-1$ for $c=0$, and $(i,j,k)$ is cyclic so that $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$. The discrete face flux is $\\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_{i,c}$. The discrete surface sum is the sum of these six face contributions.\n\n5. Error metric:\n   - Define the scalar discrepancy\n     $$\n     E \\;=\\; \\frac{\\big|\\;|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c) \\;-\\; \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_f\\;\\big|}{\\max\\big(1,\\;\\big|\\,|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c)\\,\\big|\\big)}.\n     $$\n     This is a dimensionless quantity. No physical units are required in the answer.\n\nYour program must implement the above and compute $E$ for each test case in the test suite below. Use the exact formulas from items 1–4 where indicated, with the one-point rules as stated. Do not use any external meshes or data files. Angles must be interpreted in radians.\n\nTest suite:\n- Case 1 (baseline, no geometric distortion, aligned anisotropy): $\\delta=0.0$, $r=10.0$, $\\theta=0.0$.\n- Case 2 (moderate distortion, rotated anisotropy): $\\delta=0.5$, $r=10.0$, $\\theta=0.7$.\n- Case 3 (strong distortion, rotated anisotropy): $\\delta=1.0$, $r=10.0$, $\\theta=1.4$.\n- Case 4 (extreme distortion, rotated anisotropy): $\\delta=2.0$, $r=10.0$, $\\theta=2.1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a floating-point number equal to $E$ for that case. No additional text should be printed. All computations must follow the definitions above, and no numerical integration beyond the specified one-point rules is permitted.",
            "solution": "The problem presented requires the design and implementation of a numerical experiment to evaluate the accuracy of a discrete formulation of Gauss's divergence theorem applied to Darcy flow in a porous medium. The core of the task is to compute the discrepancy between a single-point quadrature for the volume integral of the flux divergence and a sum of single-point quadratures for the flux over the boundary faces of a polyhedral control volume. This discrepancy is to be studied as a function of geometric distortion applied to the control volume.\n\nThe problem is computationally well-defined, scientifically grounded in the principles of fluid mechanics and numerical analysis, and all necessary parameters and equations are provided. It represents a valid and non-trivial exercise in computational science. The following steps detail the theoretical basis and computational strategy for arriving at the solution.\n\nFirst, we establish the physical and mathematical context. The flow is governed by Darcy's law, which relates the specific discharge (Darcy flux) $\\boldsymbol{q}$ to the hydraulic head $h$ via the permeability tensor $\\boldsymbol{K}$:\n$$\n\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h\n$$\nThe permeability tensor $\\boldsymbol{K}$ is specified as a constant, symmetric, and positive definite matrix. The divergence theorem connects the integral of the divergence of the flux over a volume $K_{\\delta}$ to the integral of the flux across its boundary $\\partial K_{\\delta}$:\n$$\n\\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA\n$$\nThe experiment is designed to quantify the error introduced by approximating both sides of this equation with low-order numerical quadrature rules.\n\nThe control volume $K_{\\delta}$ is a polyhedron defined as the affine image of the reference unit cube $[0,1]^3$. The mapping is given by $\\boldsymbol{x}(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}$, where $\\boldsymbol{\\xi} \\in [0,1]^3$ are the reference coordinates and $\\boldsymbol{x}$ are the physical coordinates. The transformation matrix is\n$$\n\\boldsymbol{A}(\\delta) = \\begin{bmatrix} 1 & \\delta & 0 \\\\ 0 & 1 & \\delta \\\\ 0 & 0 & 1 \\end{bmatrix}\n$$\nThe parameter $\\delta \\ge 0$ controls the degree of shearing distortion. The volume of the control volume is $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta)) = 1$ for all $\\delta$.\n\nThe hydraulic head $h$ is a prescribed cubic polynomial:\n$$\nh(x,y,z) = \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z\n$$\nwith given coefficients $\\alpha=0.7$, $\\beta=-0.2$, $\\gamma=0.5$, and $\\delta_h=0.3$.\nThe permeability tensor $\\boldsymbol{K}$ is anisotropic, defined by\n$$\n\\boldsymbol{K}(\\theta, r) = \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top}\n$$\nwhere $r \\ge 1$ is an anisotropy ratio and $\\boldsymbol{R}(\\theta)$ is a rotation matrix corresponding to a rotation by an angle $\\theta$ around the fixed axis $\\boldsymbol{u} = (1/\\sqrt{14})[1, 2, 3]^{\\top}$. The matrix $\\boldsymbol{R}(\\theta)$ is constructed using Rodrigues' rotation formula:\n$$\n\\boldsymbol{R}(\\theta) = \\boldsymbol{I}\\cos\\theta + (1-\\cos\\theta)(\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\sin\\theta\\,[\\boldsymbol{u}]_{\\times}\n$$\nwhere $\\boldsymbol{I}$ is the identity matrix, $\\boldsymbol{u} \\otimes \\boldsymbol{u}$ is the outer product, and $[\\boldsymbol{u}]_{\\times}$ is the cross-product matrix of $\\boldsymbol{u}$.\n\nSince $\\boldsymbol{K}$ is constant, the divergence of the flux is $\\nabla\\cdot\\boldsymbol{q} = -\\nabla\\cdot(\\boldsymbol{K}\\nabla h) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h)$, where $\\nabla^2 h$ is the Hessian matrix of $h$. The entries of $\\nabla^2 h$ are linear functions of the coordinates $(x,y,z)$, making $\\nabla\\cdot\\boldsymbol{q}$ a linear function of position.\n\nThe two terms of the discrete divergence theorem to be compared are:\n$1$. The approximation of the volume integral, $I_V = \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV$. This is approximated by a one-point quadrature rule at the centroid of the physical cell, $\\boldsymbol{x}_c = \\boldsymbol{A}(\\delta) [1/2, 1/2, 1/2]^{\\top}$:\n$$\nI_V \\approx \\tilde{I}_V = |K_{\\delta}| \\,(\\nabla\\cdot\\boldsymbol{q})(\\boldsymbol{x}_c)\n$$\nA crucial observation is that the one-point quadrature rule evaluated at the centroid is exact for any integral of a linear function over an arbitrary volume. Since $\\nabla\\cdot\\boldsymbol{q}$ is linear in $\\boldsymbol{x}$, this \"approximation\" yields the exact value of the volume integral, i.e., $\\tilde{I}_V = I_V$.\n\n$2$. The approximation of the surface integral, $I_S = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA$. This is the sum of fluxes over the six faces of $K_\\delta$:\n$$\nI_S \\approx \\tilde{I}_S = \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(\\boldsymbol{x}_f)\\cdot \\boldsymbol{a}_f\n$$\nHere, $\\boldsymbol{x}_f$ is the center of a face $f$, and $\\boldsymbol{a}_f$ is its oriented area vector. For a face corresponding to $\\xi_i=c$ (with $c \\in \\{0,1\\}$), its center is $\\boldsymbol{x}_f = \\boldsymbol{A}(\\delta)\\boldsymbol{\\xi}_f$, where $\\boldsymbol{\\xi}_f$ is $[1/2, 1/2, 1/2]^{\\top}$ with the $i$-th component set to $c$. The oriented area vector is $\\boldsymbol{a}_{i,c} = s_{i,c}(\\boldsymbol{A}\\boldsymbol{e}_j \\times \\boldsymbol{A}\\boldsymbol{e}_k)$, where $(i,j,k)$ is a cyclic permutation of $(1,2,3)$ such that $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$, and $s_{i,c}$ is $-1$ for $c=0$ and $+1$ for $c=1$. The flux $\\boldsymbol{q}(\\boldsymbol{x})$ is a quadratic function of position, so this one-point quadrature for the surface integral is generally not exact.\n\nThe entire discrepancy between the two sides of the discrete theorem arises from the error in the surface integral approximation. The error metric $E$ is defined as:\n$$\nE = \\frac{|\\tilde{I}_V - \\tilde{I}_S|}{\\max(1, |\\tilde{I}_V|)} = \\frac{|I_V - \\tilde{I}_S|}{\\max(1, |I_V|)}\n$$\nThis metric normalizes the absolute error of the surface integral approximation by the magnitude of the exact volume integral (or $1$ if the integral is small).\n\nThe computational procedure for each test case $(\\delta, r, \\theta)$ is as follows:\n$1$. Construct the matrices $\\boldsymbol{A}(\\delta)$ and $\\boldsymbol{K}(\\theta, r)$.\n$2$. Compute the exact volume integral term $\\tilde{I}_V$: find the cell centroid $\\boldsymbol{x}_c$, evaluate the Hessian $\\nabla^2 h(\\boldsymbol{x}_c)$, compute the divergence $\\nabla\\cdot\\boldsymbol{q}(\\boldsymbol{x}_c) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h(\\boldsymbol{x}_c))$, and scale by the volume $|K_{\\delta}|=1$.\n$3$. Compute the approximate surface integral term $\\tilde{I}_S$: iterate through the six faces of the control volume. For each face, determine its center $\\boldsymbol{x}_f$ and oriented area vector $\\boldsymbol{a}_f$. Evaluate the flux vector $\\boldsymbol{q}(\\boldsymbol{x}_f) = -\\boldsymbol{K}\\nabla h(\\boldsymbol{x}_f)$ and compute the dot product with the area vector. Sum these contributions.\n$4$. Calculate the final error metric $E$ using the formula above.\n\nThis procedure will be implemented and executed for the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix(axis, angle):\n    \"\"\"\n    Returns the rotation matrix for a rotation around a given axis by a given angle,\n    using Rodrigues' rotation formula.\n    \n    Args:\n        axis (np.ndarray): The 3D rotation axis (must be a unit vector).\n        angle (float): The rotation angle in radians.\n        \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n    t = 1 - c\n    x, y, z = axis\n    \n    # Cross-product matrix of the axis vector\n    K = np.array([[0, -z, y],\n                  [z, 0, -x],\n                  [-y, x, 0]])\n    \n    # Rodrigues' formula: R = c*I + t*(u u^T) + s*[u]_x\n    R = c * np.identity(3) + t * np.outer(axis, axis) + s * K\n    return R\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem by calculating the discrepancy E\n    for a set of test cases.\n    \"\"\"\n    # Define problem constants\n    alpha = 0.7\n    beta = -0.2\n    gamma = 0.5\n    delta_h = 0.3\n    # Rotation axis must be a unit vector\n    rot_axis_u = np.array([1.0, 2.0, 3.0]) / np.sqrt(1**2 + 2**2 + 3**2)\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (delta, r, theta)\n        (0.0, 10.0, 0.0),\n        (0.5, 10.0, 0.7),\n        (1.0, 10.0, 1.4),\n        (2.0, 10.0, 2.1),\n    ]\n\n    results = []\n    \n    # Function definitions for head gradient and Hessian\n    def grad_h(p):\n        x, y, z = p\n        return np.array([\n            3 * alpha * x**2 + delta_h * y * z,\n            3 * beta * y**2 + delta_h * x * z,\n            3 * gamma * z**2 + delta_h * x * y\n        ])\n\n    def hessian_h(p):\n        x, y, z = p\n        return np.array([\n            [6 * alpha * x, delta_h * z,   delta_h * y],\n            [delta_h * z,   6 * beta * y,  delta_h * x],\n            [delta_h * y,   delta_h * x,   6 * gamma * z]\n        ])\n\n    for delta, r, theta in test_cases:\n        # Step 1: Define Geometry and Permeability\n        A = np.array([[1.0, delta, 0.0],\n                      [0.0, 1.0,   delta],\n                      [0.0, 0.0,   1.0]])\n        \n        # Volume of the sheared cube is det(A) = 1\n        vol_K_delta = 1.0\n\n        # Construct permeability tensor K\n        R = get_rotation_matrix(rot_axis_u, theta)\n        D = np.diag([r, 1.0, 1.0/r])\n        K = R @ D @ R.T\n\n        # Step 2: Calculate Volume Integral Term (this approximation is exact)\n        xi_c = np.array([0.5, 0.5, 0.5])\n        x_c = A @ xi_c\n        \n        div_q_at_xc = -np.trace(K @ hessian_h(x_c))\n        vol_integral_term = vol_K_delta * div_q_at_xc\n\n        # Step 3: Calculate Surface Integral Term\n        surface_integral_term = 0.0\n        \n        # Loop over faces, defined by axis index i (1-based) and side c (0 or 1)\n        for i_ax in range(1, 4):\n            if i_ax == 1:\n                j_ax, k_ax = 2, 3\n            elif i_ax == 2:\n                j_ax, k_ax = 3, 1\n            else:  # i_ax == 3\n                j_ax, k_ax = 1, 2\n            \n            # Convert to 0-based indices for numpy array access\n            i, j, k = i_ax - 1, j_ax - 1, k_ax - 1\n\n            for c in range(2):  # side c=0 or c=1\n                s_ic = -1.0 if c == 0 else 1.0\n                \n                # Oriented area vector a_f = s * (A_ej x A_ek)\n                A_col_j = A[:, j]\n                A_col_k = A[:, k]\n                area_vec = s_ic * np.cross(A_col_j, A_col_k)\n                \n                # Physical location of the face center x_f\n                xi_f = np.array([0.5, 0.5, 0.5])\n                xi_f[i] = float(c)\n                x_f = A @ xi_f\n                \n                # Flux q at the face center x_f\n                q_at_xf = -K @ grad_h(x_f)\n                \n                # Add flux through the face to the sum\n                surface_integral_term += np.dot(q_at_xf, area_vec)\n        \n        # Step 4: Compute the Error Metric E\n        numerator = np.abs(vol_integral_term - surface_integral_term)\n        denominator = np.max([1.0, np.abs(vol_integral_term)])\n        error = numerator / denominator\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}