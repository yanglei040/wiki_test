{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基石。在深入研究复杂的生物信息学分析之前，我们必须首先掌握其核心的统计引擎。本练习将带您手动计算功能富集分析中最常用的超几何检验的 $p$ 值，并将其与基于模拟的置换检验结果进行比较。通过这个过程，您不仅能理解富集分析的数学原理，还能体会到理论精确性与经验估计之间的关系，为解读分析结果打下坚实的基础 。",
            "id": "2392301",
            "problem": "在一项功能富集分析中，考虑一个包含 $N=100$ 个基因的背景集，一个包含 $n=10$ 个基因的生物学通路，以及一个大小为 $k=5$ 的查询基因列表。在一次实验中，观测到查询基因列表与该通路之间的重叠基因为 $x=3$ 个。\n\n假设原假设成立，即查询基因列表是通过从 $N$ 个基因中无放回地均匀随机抽取 $k$ 个基因而形成的。\n\n使用组合计数的基本原理，计算单侧超几何 $p$ 值，该值定义为在原假设下，观测到至少有 $x$ 个基因重叠的概率。另外，通过从同一背景集中生成 $m=10{,}000$ 个大小为 $k$ 的独立随机基因列表，进行了一项基于置换的检验；在这些列表中，有 $h=61$ 个列表与该通路的重叠数量至少为 $x$。\n\n计算超几何 $p$ 值与基于置换的 $p$ 值估计值之间的绝对差。将最终答案以小数形式表示。将您的答案四舍五入至 $4$ 位有效数字。",
            "solution": "在尝试任何解答之前，本问题都经过了严格的验证。\n\n步骤 1：提取已知条件\n问题提供了以下参数：\n- 背景中的总基因数：$N=100$。\n- 生物学通路中的基因数（总体中的成功数）：$n=10$。\n- 查询基因列表的大小（样本量）：$k=5$。\n- 观测到的重叠数（样本中的成功数）：$x=3$。\n- 原假设：查询基因列表是从 $N$ 个基因的背景集中无放回抽取的、大小为 $k$ 的简单随机样本。\n- 单侧超几何 $p$ 值的定义：观测到*至少* $x$ 个基因重叠的概率。\n- 置换检验中的置换次数：$m=10,000$。\n- 重叠数至少为 $x$ 的置换列表数量：$h=61$。\n\n步骤 2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n- **科学性**：该问题描述了生物信息学中功能富集分析的一个经典场景。使用超几何分布来建模无放回抽样，以及使用置换检验的概念来经验性地估计显著性，是该领域的基础和标准方法。该设置在科学和数学上是合理的。\n- **良构性**：所需计算的所有必要参数（$N$, $n$, $k$, $x$, $m$, $h$）都已明确给出。所提出的问题——计算两种类型的 $p$ 值及其差异——是明确无误的，并能导出一个单一的、可验证的数值解。\n- **客观性**：问题以精确、定量的术语陈述，没有任何主观或有偏见的语言。\n\n该问题没有表现出任何诸如科学不合理、不完整、矛盾或歧义等缺陷。所提供的值对于一个模型问题是现实的。\n\n步骤 3：结论与行动\n该问题被判定为**有效**。现在将提供完整的解答。\n\n第一个任务是使用基本原理计算理论上的单侧 $p$ 值。在原假设下，从随机选择的查询列表中找到的来自通路的基因数量 $X$ 服从超几何分布。从 $N$ 个基因的背景集中选择 $k$ 个基因的总方式数由二项式系数 $\\binom{N}{k}$ 给出。从大小为 $n$ 的通路中选择 $i$ 个基因，并从剩余的 $N-n$ 个基因中选择 $k-i$ 个基因的方式数是 $\\binom{n}{i}\\binom{N-n}{k-i}$。\n\n观测到恰好 $i$ 个重叠基因的概率质量函数为：\n$$ P(X=i) = \\frac{\\binom{n}{i} \\binom{N-n}{k-i}}{\\binom{N}{k}} $$\n问题要求计算单侧 $p$ 值 $p_{\\text{hyper}}$，即观测到至少 $x=3$ 个重叠的概率。由于查询列表的大小为 $k=5$，因此可能的最大重叠数为 $\\min(n, k) = \\min(10, 5) = 5$。\n因此，我们必须计算累积概率 $P(X \\ge 3)$。\n$$ p_{\\text{hyper}} = P(X \\ge 3) = P(X=3) + P(X=4) + P(X=5) = \\sum_{i=3}^{5} \\frac{\\binom{10}{i} \\binom{100-10}{5-i}}{\\binom{100}{5}} $$\n我们计算这个和的各个组成部分。\n分母是大小为 $5$ 的可能查询基因列表的总数：\n$$ \\binom{N}{k} = \\binom{100}{5} = \\frac{100 \\times 99 \\times 98 \\times 97 \\times 96}{5 \\times 4 \\times 3 \\times 2 \\times 1} = 75,287,520 $$\n对于 $i=3, 4, 5$ 的分子分别是：\n- 对于 $i=3$：从通路中选择 $3$ 个基因并从通路外选择 $2$ 个基因的方式数。\n$$ \\binom{10}{3} \\binom{90}{2} = \\left(\\frac{10 \\times 9 \\times 8}{3 \\times 2 \\times 1}\\right) \\left(\\frac{90 \\times 89}{2 \\times 1}\\right) = (120)(4005) = 480,600 $$\n- 对于 $i=4$：从通路中选择 $4$ 个基因并从通路外选择 $1$ 个基因的方式数。\n$$ \\binom{10}{4} \\binom{90}{1} = \\left(\\frac{10 \\times 9 \\times 8 \\times 7}{4 \\times 3 \\times 2 \\times 1}\\right) (90) = (210)(90) = 18,900 $$\n- 对于 $i=5$：从通路中选择 $5$ 个基因并从通路外选择 $0$ 个基因的方式数。\n$$ \\binom{10}{5} \\binom{90}{0} = \\left(\\frac{10 \\times 9 \\times 8 \\times 7 \\times 6}{5 \\times 4 \\times 3 \\times 2 \\times 1}\\right) (1) = (252)(1) = 252 $$\n有利结果（重叠数 $\\ge 3$）的总数是这些分子的和：\n$$ 480,600 + 18,900 + 252 = 499,752 $$\n超几何 $p$ 值是有利结果数与总结果数的比率：\n$$ p_{\\text{hyper}} = \\frac{499,752}{75,287,520} \\approx 0.006637653 $$\n第二个任务是计算基于置换的 $p$ 值估计值 $p_{\\text{perm}}$。这是一个通过模拟得出的经验估计值。它由达到或超过观测统计量的置换次数 $h$ 与总置换次数 $m$ 的比率给出。\n$$ p_{\\text{perm}} = \\frac{h}{m} = \\frac{61}{10,000} = 0.0061 $$\n最后，我们计算理论超几何 $p$ 值与基于置换的估计值之间的绝对差。\n$$ \\text{Difference} = | p_{\\text{hyper}} - p_{\\text{perm}} | = | 0.006637653... - 0.0061 | = 0.000537653... $$\n问题要求将此结果四舍五入到 $4$ 位有效数字。第一位有效数字是 $5$，其后是 $3$、$7$ 和 $6$。随后的数字是 $5$，因此我们将最后一位有效数字向上取整。\n$$ \\text{Difference} \\approx 0.0005377 $$",
            "answer": "$$\\boxed{0.0005377}$$"
        },
        {
            "introduction": "在真实世界的生物学数据中，信号总是与噪声相伴。一个统计上显著的富集结果究竟有多可靠？它能否经受住数据中随机波动的考验？这个实践练习通过一个直观的模型，模拟了向一个已知的富集信号中逐渐引入随机噪声的过程。您的任务是编写代码，找到使富集信号变得不再显著的“临界点”，从而亲手量化一个富集信号的稳健性 。",
            "id": "2392264",
            "problem": "给定一个基因全集，建模为一个大小为 $N$ 的有限集；一个大小为 $M \\le N$ 的已知通路（基因集）；以及一组大小为 $K$ 的被选基因（例如差异基因），这些基因被怀疑在该通路中富集。在标准的过表达分析无效模型下，被选集合中观测到的通路基因数量（记为 $X$）遵循参数为 $(N, M, K)$ 的超几何分布。对于观测到的 $k$ 个重叠基因，其富集 $p$ 值是上尾概率 $\\mathbb{P}(X \\ge k)$，其中 $X \\sim \\text{Hypergeometric}(N, M, K)$。这是 Fisher 精确检验（FET）进行过表达推断的核心，该检验基于无放回抽样的假设。在零假设下，期望的重叠数量为 $\\mathbb{E}[X] = K \\cdot M / N$。\n\n你将按如下方式模拟随机噪声对初始富集信号的影响。假设初始被选集合包含 $k_0$ 个通路基因，其中 $k_0$ 通常超过零假设下的期望值 $K M / N$。通过从整个基因全集中均匀随机（无放回）地抽取基因，替换掉 $K$ 个被选基因中的一部分（比例为 $f \\in [0,1]$），从而引入随机噪声。在期望中，施加比例为 $f$ 的噪声后，通路重叠数的变化如下\n$$\nk(f) \\;=\\; (1 - f)\\,k_0 \\;+\\; f \\, K \\cdot \\frac{M}{N}.\n$$\n由于统计检验要求重叠数为整数，定义一个确定性代理\n$$\nk^\\star(f) \\;=\\; \\mathrm{round}\\!\\big(k(f)\\big),\n$$\n其中“round”表示使用标准规则四舍五入到最近的整数，即小数部分为一半时舍入到最近的偶数。对于每个 $f$，将富集 $p$ 值定义为\n$$\np(f) \\;=\\; \\mathbb{P}\\!\\big(X \\ge k^\\star(f)\\big), \\quad X \\sim \\text{Hypergeometric}(N, M, K).\n$$\n\n你的任务是，对每个测试用例，在一个固定的网格上确定最小的噪声比例 $f^\\star$，使得富集在显著性水平 $\\alpha$ 下变得不显著，即：\n$$\nf^\\star \\;=\\; \\min \\left\\{ f \\in \\{0, \\Delta f, 2\\Delta f, \\dots, 1\\} \\;:\\; p(f) \\ge \\alpha \\right\\}.\n$$\n如果 $p(0) \\ge \\alpha$，则 $f^\\star = 0$。如果对于所有直至 $f=1$ 的网格值，$p(f)  \\alpha$ 恒成立，则报告 $f^\\star = 1$。\n\n实现一个完整、可运行的程序，该程序：\n- 对于由步长 $\\Delta f$ 定义的每个网格值 $f$，使用超几何上尾概率 $\\mathbb{P}(X \\ge k^\\star(f))$ 计算 $p(f)$。\n- 返回满足不显著标准 $p(f^\\star) \\ge \\alpha$ 的最小 $f^\\star$。\n- 将每个 $f^\\star$ 四舍五入并报告至恰好三位小数。\n- 生成单行输出，其中包含所有按顺序排列的结果，形式为用方括号括起来的逗号分隔列表，例如 $[\\,0.125,0.003,1.000\\,]$。\n\n使用以下五个测试用例，每个用例指定为一个元组 $(N, M, K, k_0, \\alpha, \\Delta f)$：\n- $(20000, 300, 150, 60, 0.05, 0.01)$\n- $(20000, 300, 150, 2, 0.05, 0.01)$\n- $(500, 80, 40, 18, 0.01, 0.005)$\n- $(10000, 1000, 500, 120, 0.05, 0.02)$\n- $(100, 10, 10, 7, 0.001, 0.05)$\n\n所有输出必须是 $[0,1]$ 范围内的纯小数（而非百分比），并四舍五入到三位小数。程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[\\,0.125,0.003,1.000\\,]$）。",
            "solution": "该问题要求我们确定一个最小的噪声比例 $f^\\star$，它能使一个统计上显著的基因集富集变得不显著。这涉及到对富集信号的衰减进行建模，并反复应用统计检验来找到其显著性消失的点。该过程基于生物信息学中的过表达分析（ORA）原理，其在统计上通过超几何分布进行建模。\n\n该问题是有效的，因为它在科学上基于生物信息学中已建立的统计方法，在数学上是适定的（所有必要的参数和条件都已定义），并且是客观且可通过计算验证的。\n\n解决方案通过以下步骤制定：\n\n1.  **基因集过表达建模**\n    分析的基础是 Fisher 精确检验，它依赖于超几何分布。给定一个包含 $N$ 个基因的全集，一个包含其中 $M$ 个基因的特定通路，以及一个包含 $K$ 个基因的被选集合，在被选集合中观测到恰好 $x$ 个通路基因的概率由超几何概率质量函数（PMF）给出：\n    $$\n    \\mathbb{P}(X=x) = \\frac{\\binom{M}{x} \\binom{N-M}{K-x}}{\\binom{N}{K}}\n    $$\n    在这里，$X$ 是代表重叠基因数量的随机变量。该分布的参数是总体大小 $N$，总体中成功状态的数量 $M$（通路中的基因），以及抽样数量 $K$（被选基因）。我们将其写作 $X \\sim \\text{Hypergeometric}(N, M, K)$。\n\n2.  **定义统计显著性**\n    对于观测到的 $k$ 个重叠基因，通常通过计算上尾 $p$ 值来评估富集程度。这是在无关联的零假设下，观测到至少 $k$ 个重叠基因的概率。\n    $$\n    p = \\mathbb{P}(X \\ge k) = \\sum_{i=k}^{\\min(M,K)} \\mathbb{P}(X=i)\n    $$\n    这也被称为生存函数（SF），通常计算为 $1 - \\mathbb{P}(X \\le k-1)$。如果该 $p$ 值小于预定义的显著性水平 $\\alpha$，则认为观测结果是统计显著的。\n\n3.  **噪声导致的信号衰减建模**\n    问题引入了一个噪声模型，用以模拟初始富集信号的衰减。从大小为 $K$ 的被选集合中的 $k_0$ 个初始重叠基因开始，将这 $K$ 个基因中的一部分（比例为 $f$）替换为从整个 $N$ 个基因的全集中均匀随机抽取的基因。\n    替换后被选集合中通路基因的期望数量（记为 $k(f)$）可以表示为初始状态（$f=0$ 时）和完全随机化下的期望状态（$f=1$ 时）之间的线性插值。一个大小为 $K$ 的随机集合中通路基因的期望数量是零假设下的期望值 $\\mathbb{E}[X] = K \\cdot M/N$。\n    - 未被替换的 $(1-f)K$ 个基因平均贡献 $(1-f)k_0$ 个通路基因（假设这 $k_0$ 个通路基因来自原始的富集集合）。\n    - 新抽取的 $fK$ 个基因平均贡献 $fK \\cdot (M/N)$ 个通路基因。\n    问题陈述为最终的重叠数提供了简化的期望公式，该公式结合了这些效应：\n    $$\n    k(f) = (1 - f)k_0 + f \\frac{KM}{N}\n    $$\n    由于超几何检验要求重叠数为整数，我们通过将期望值 $k(f)$ 四舍五入到最近的整数来定义一个确定性的整数代理 $k^\\star(f)$，其中小数部分为一半时舍入到最近的偶数。\n    $$\n    k^\\star(f) = \\mathrm{round}(k(f))\n    $$\n    这个舍入规则对应于 Python 3 及以后版本的内置 `round()` 函数以及 `numpy.round()` 的行为。\n\n4.  **寻找 $f^\\star$ 的算法流程**\n    核心任务是从一个离散的数值网格 $\\{0, \\Delta f, 2\\Delta f, \\dots, 1\\}$ 中找到最小的噪声比例 $f^\\star$，使得富集 $p$ 值不再显著，即 $p(f) \\ge \\alpha$。\n    对于每个测试用例 $(N, M, K, k_0, \\alpha, \\Delta f)$，算法如下：\n    a. 构建步长为 $\\Delta f$、范围在 $[0, 1]$ 内的噪声比例 $f$ 的网格。\n    b. 计算零假设下的期望重叠数：$E = K \\cdot M / N$。\n    c. 从 $f=0$ 开始，遍历 $f$ 的网格值。\n    d. 对于每个 $f$：\n        i. 计算施加噪声后的期望重叠数：$k(f) = (1 - f)k_0 + f \\cdot E$。\n        ii. 确定整数重叠数：$k^\\star(f) = \\mathrm{int}(\\mathrm{round}(k(f)))$。\n        iii. 计算 $p$ 值：$p(f) = \\mathbb{P}(X \\ge k^\\star(f))$，其中 $X \\sim \\text{Hypergeometric}(N, M, K)$。这通过超几何分布的生存函数 `scipy.stats.hypergeom.sf(k_star - 1, N, M, K)` 来计算。\n        iv. 检查显著性条件：如果 $p(f) \\ge \\alpha$，则找到了临界噪声比例。设置 $f^\\star = f$ 并终止对此测试用例的搜索。\n    e. 如果循环完成，但对于所有直至（并包括）$f=1$ 的 $f$ 值，条件都未满足，问题规定 $f^\\star=1$。这可以通过将 $f^\\star$ 初始化为 $1$ 来处理，或者确保循环在 $f=1$ 满足条件时能正确找到该值。我们的实现将搜索整个网格，并在找到第一个合适的 $f$ 时中断。将 $f^\\star$ 的初始默认值设为 $1.0$ 覆盖了条件始终未满足的情况。\n\n    此流程系统地评估了统计显著性的衰减，并根据问题的定义正确地确定了所需的阈值 $f^\\star$。然后，将每个测试用例的最终值四舍五入到三位小数进行报告。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef solve():\n    \"\"\"\n    Computes the smallest noise fraction f_star for which a gene set enrichment\n    signal becomes non-significant, for a series of test cases.\n    \"\"\"\n    # Test cases defined as (N, M, K, k_0, alpha, delta_f) tuples.\n    # N: universe size, M: pathway size, K: selected set size\n    # k_0: initial overlap, alpha: significance level, delta_f: noise grid step\n    test_cases = [\n        (20000, 300, 150, 60, 0.05, 0.01),\n        (20000, 300, 150, 2, 0.05, 0.01),\n        (500, 80, 40, 18, 0.01, 0.005),\n        (10000, 1000, 500, 120, 0.05, 0.02),\n        (100, 10, 10, 7, 0.001, 0.05)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, M, K, k_0, alpha, delta_f = case\n\n        # The number of steps for the grid, ensuring 1.0 is included.\n        # Add a small epsilon to avoid floating point inaccuracies with the division.\n        num_steps = int(1.0 / delta_f + 1e-9) + 1\n        f_grid = np.linspace(0.0, 1.0, num_steps)\n\n        # Expected overlap under the null hypothesis (random selection)\n        null_expectation = K * M / N\n        \n        # Initialize f_star to 1.0. This value will be used if the p-value\n        # remains below alpha for all f on the grid.\n        f_star = 1.0\n\n        for f in f_grid:\n            # Calculate the expected overlap k(f) after applying noise fraction f.\n            # This is a linear interpolation between the initial overlap k_0 and\n            # the null expectation.\n            k_f = (1.0 - f) * k_0 + f * null_expectation\n\n            # Round k(f) to the nearest integer, with halves rounded to the\n            # nearest even integer, as specified. np.round and then casting to int\n            # achieves this.\n            k_star = int(np.round(k_f))\n\n            # The p-value is the probability of observing k_star or more overlaps,\n            # which is the survival function (1 - CDF).\n            # hypergeom.sf(k-1, N, M, K) computes P(X = k).\n            # scipy.stats.hypergeom takes parameters (M, n, k), which in our\n            # notation are (total population, number of type I items, number of draws)\n            # - (N, M, K).\n            if k_star  min(M, K):\n                # If the required overlap is impossibly large, p-value is 0.\n                p_value = 0.0\n            else:\n                p_value = hypergeom.sf(k_star - 1, N, M, K)\n\n            # Check if the p-value meets or exceeds the significance threshold alpha.\n            # If so, we have found the smallest f on the grid that satisfies the\n            # condition.\n            if p_value = alpha:\n                f_star = f\n                break\n        \n        results.append(f_star)\n\n    # Format the results as a list of strings, each rounded to 3 decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    \n    # Print the final output in the required single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "功能富集分析的结论在很大程度上取决于一个关键的、但常常被忽视的参数：背景基因集（或称“基因宇宙”）的选择。错误地定义背景集，例如仅使用在实验中表达的基因而非整个基因组的基因，可能会导致结果产生严重偏差。本练习将通过一个编程任务，让您量化这种“错误设定”对富集分析 $p$ 值的具体影响。通过对比不同背景下的分析结果，您将深刻理解为何在进行富集分析时，正确定义分析的上下文至关重要 。",
            "id": "2392318",
            "problem": "本题提供一个框架，用以量化在单侧超表示分析中使用错误指定的基因“全集”会如何改变富集显著性。考虑有限的基因集合，其中“全集”是指从中进行无放回抽样的基因集合，“术语”是全集的一个子集，用于定义成功状态，“选定集”是观测到的感兴趣的基因子集。对于一个给定的配置，设$N$为正确全集的大小，$K$为全集中注释到该术语的基因数量，$n$为属于全集的选定基因数量，$k$为选定基因中注释到该术语的数量。我们将富集 $p$ 值定义为：在包含 $K$ 个成功状态的 $N$ 个基因中，无放回随机抽样 $n$ 个基因，观测到至少 $k$ 次成功的概率。形式上，对于给定的$N$、$K$、$n$和$k$，富集$p$值为\n$$\np_{\\text{true}}(N,K,n,k) \\equiv \\sum_{i=k}^{\\min(n,K)} \\frac{\\binom{K}{i}\\binom{N-K}{n-i}}{\\binom{N}{n}}.\n$$\n现在，假设使用了一个错误指定的“表达”全集，该全集只包含被视为表达的基因。设$N'$为这个错误指定全集的大小，$K'$为这个错误指定全集中注释到该术语的基因数量，$n'$为这个错误指定全集中的选定基因数量，$k'$为这个错误指定全集中注释到该术语的选定基因数量。相应的富集 $p$ 值为\n$$\np_{\\text{mis}}(N',K',n',k') \\equiv \\sum_{i=k'}^{\\min(n',K')} \\frac{\\binom{K'}{i}\\binom{N'-K'}{n'-i}}{\\binom{N'}{n'}}.\n$$\n对于下方的每个测试用例，计算这些 $p$ 值之比的以10为底的对数，\n$$\nr \\equiv \\log_{10}\\!\\left(\\frac{p_{\\text{mis}}(N',K',n',k')}{p_{\\text{true}}(N,K,n,k)}\\right).\n$$\n正值 $r$ 表示错误指定的全集产生了更大的 $p$ 值（显著性更低），负值 $r$ 表示 $p$ 值更小（显著性更高），而 $r=0$ 表示没有变化。将每个 $r$ 作为十进制数返回，并四舍五入到6位小数。\n\n参数值测试套件：\n- 用例 A: $N=20000$, $K=500$, $n=200$, $k=12$; $N'=12000$, $K'=320$, $n'=180$, $k'=10$.\n- 用例 B: $N=15000$, $K=600$, $n=100$, $k=0$; $N'=9000$, $K'=400$, $n'=80$, $k'=0$.\n- 用例 C: $N=18000$, $K=150$, $n=40$, $k=30$; $N'=11000$, $K'=120$, $n'=35$, $k'=28$.\n- 用例 D: $N=25000$, $K=60$, $n=20$, $k=20$; $N'=10000$, $K'=30$, $n'=12$, $k'=12$.\n- 用例 E: $N=12000$, $K=400$, $n=150$, $k=8$; $N'=12000$, $K'=400$, $n'=150$, $k'=8$.\n\n你的程序应产生单行输出，其中包含一个用方括号括起来、以逗号分隔的结果列表，结果顺序与上述用例一致，且每个值都四舍五入到6位小数（例如，$[x_A,x_B,x_C,x_D,x_E]$，其中每个 $x_\\cdot$ 都是一个十进制数）。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，定义明确且客观。该问题描述了计算生物学中的一个标准流程——超表示分析——并将其正确地表述为一个超几何检验。任务的核心是量化当背景基因集（“全集”）被改变时统计显著性的变化，这是生物信息学中一个已知的重要问题。所有提供的参数都是一致的，并且足以得到唯一解。因此，我们着手推导计算解法。\n\n其基本原理是超几何概率分布。该分布为无放回抽样建模。给定一个大小为 $N$ 的总体，其中包含 $K$ 个感兴趣的项目（“成功”），从中抽取一个大小为 $n$ 的样本，该样本恰好包含 $i$ 次成功的概率由概率质量函数（PMF）给出：\n$$\nP(X=i) = \\frac{\\binom{K}{i}\\binom{N-K}{n-i}}{\\binom{N}{n}}\n$$\n其中 $X$ 是表示样本中成功次数的随机变量。\n\n问题将富集 $p$ 值定义为观测到至少 $k$ 次成功的概率。这对应于分布的尾概率，也称为生存函数（SF）。它通过对观测到 $k, k+1, \\dots, \\min(n,K)$ 次成功的概率求和来计算：\n$$\np(N,K,n,k) = P(X \\ge k) = \\sum_{i=k}^{\\min(n,K)} P(X=i)\n$$\n这就是为“真实”和“错误指定”参数集分别定义的 $p_{\\text{true}}$ 和 $p_{\\text{mis}}$ 的值。\n\n直接计算二项式系数 $\\binom{a}{b}$ 对于所涉及的大数（例如，$N=20000$）而言，在数值上是不稳定的，在计算上是不可行的。正确的计算方法是使用一个库函数，该函数利用对数伽马函数来实现超几何分布的性质，以确保稳定性。生存函数 $P(X \\ge k)$ 等价于 $1 - P(X \\le k-1)$，即 $SF(k-1)$。大多数科学计算库都提供此函数。我们将使用 `scipy` 库中的 `scipy.stats.hypergeom.sf`。此函数的参数是：分位数 $k-1$，总体大小 $M$（我们的 $N$），总体中的成功总数 $n$（我们的 $K$），以及样本大小 $N$（我们的 $n$）。\n\n算法如下：\n1.  对于每个测试用例，我们都给定一个“真实”参数集 $(N, K, n, k)$ 和一个“错误指定”参数集 $(N', K', n', k')$。\n2.  使用与真实全集对应的参数，通过超几何生存函数计算真实情况的 $p$ 值 $p_{\\text{true}}$：`hypergeom.sf(k-1, M=N, n=K, N=n)`。\n3.  同样，使用其对应的参数计算错误指定情况的 $p$ 值 $p_{\\text{mis}}$：`hypergeom.sf(k'-1, M=N', n=K', N=n')`。\n4.  目标是计算量 $r \\equiv \\log_{10}\\!\\left(\\frac{p_{\\text{mis}}}{p_{\\text{true}}}\\right)$。为保持数值精度，这可以计算为 $\\log_{10}(p_{\\text{mis}}) - \\log_{10}(p_{\\text{true}})$。\n5.  有两个特殊情况值得注意。首先，对于用例B，其中 $k=0$ 且 $k'=0$， $p$ 值是所有可能结果的概率总和，因此必须为 $1$。于是，$p_{\\text{true}}=1$ 且 $p_{\\text{mis}}=1$，导致 $r=0$。生存函数 `sf(k-1)` 能正确处理这种情况，因为当 $k=0$ 时，它会计算 `sf(-1)`，其定义为 $1$。\n6.  其次，对于用例E，“真实”和“错误指定”的参数是相同的。因此，$p_{\\text{true}} = p_{\\text{mis}}$，比值为 $1$，而 $r = \\log_{10}(1) = 0$。这可作为对实现的一个简单检查。\n7.  每个用例的最终值 $r$ 都被四舍五入到6位小数，并以所要求的列表格式呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef solve():\n    \"\"\"\n    Computes the log-ratio of p-values from a mis-specified universe\n    in a hypergeometric test for over-representation analysis.\n    \"\"\"\n\n    # Test cases are defined as tuples of:\n    # (N, K, n, k, N', K', n', k')\n    test_cases = [\n        # Case A\n        (20000, 500, 200, 12, 12000, 320, 180, 10),\n        # Case B\n        (15000, 600, 100, 0, 9000, 400, 80, 0),\n        # Case C\n        (18000, 150, 40, 30, 11000, 120, 35, 28),\n        # Case D\n        (25000, 60, 20, 20, 10000, 30, 12, 12),\n        # Case E\n        (12000, 400, 150, 8, 12000, 400, 150, 8),\n    ]\n\n    def calculate_p_value(N, K, n, k):\n        \"\"\"\n        Calculates the p-value for over-representation using the\n        hypergeometric survival function.\n\n        Args:\n            N (int): Population size (universe).\n            K (int): Number of successes in population (term size).\n            n (int): Sample size (selected set size).\n            k (int): Number of successes in sample.\n\n        Returns:\n            float: The p-value, P(X = k).\n        \"\"\"\n        # The probability P(X = k) is calculated by the survival function (sf)\n        # evaluated at k-1.\n        # Parameters for scipy.stats.hypergeom:\n        # M: The total number of items (our N, universe size).\n        # n: The total number of type I items (our K, term size).\n        # N: The number of items drawn (our n, selected set size).\n        return hypergeom.sf(k - 1, M=N, n=K, N=n)\n\n    results = []\n    for case in test_cases:\n        N, K, n, k, N_prime, K_prime, n_prime, k_prime = case\n\n        # Calculate p-value for the correct universe\n        p_true = calculate_p_value(N, K, n, k)\n\n        # Calculate p-value for the mis-specified universe\n        p_mis = calculate_p_value(N_prime, K_prime, n_prime, k_prime)\n        \n        # Guard against zero p-values to avoid issues with log.\n        # Based on problem validation, p_true is non-zero for all test cases.\n        if p_true == 0.0 or p_mis == 0.0:\n            if p_true == p_mis: # Both are 0\n                r = 0.0 # Define log(0/0) as 0, indicating no relative change\n            elif p_mis == 0.0:\n                 r = -np.inf # Transition to zero p-value\n            else: # p_true is 0, p_mis is not\n                 r = np.inf # Transition from impossible to possible\n        else:\n            # Compute the base-10 logarithm of the ratio\n            r = np.log10(p_mis / p_true)\n\n        results.append(r)\n\n    # Format output as a list of strings, with each number rounded to 6 decimal places.\n    # The f-string formatting handles rounding as required.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}