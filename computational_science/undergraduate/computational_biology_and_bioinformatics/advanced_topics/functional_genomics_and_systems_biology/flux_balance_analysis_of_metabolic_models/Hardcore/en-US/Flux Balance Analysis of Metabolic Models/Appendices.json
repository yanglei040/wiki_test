{
    "hands_on_practices": [
        {
            "introduction": "Flux Balance Analysis is a powerful tool for predicting cellular behavior based on the principle of optimizing a biological objective. This first exercise challenges you to model a classic biological phenomenon, catabolite repression, by determining which available carbon source allows for the fastest growth . By building a simple metabolic model from first principles and solving for maximal biomass, you will gain hands-on experience in translating biochemical reactions into a predictive computational framework.",
            "id": "2390906",
            "problem": "You are asked to implement a complete, runnable program that uses Flux Balance Analysis (FBA) to predict which of several available carbon sources a cell will consume first, under the hypothesis that regulatory catabolite repression selects the substrate that yields the highest maximal growth rate. Your implementation must start from first principles: steady-state mass balance and linear programming, with no shortcut formulas. You will encode a simplified, scientifically plausible metabolic network that tracks a carbon-precursor pool and adenosine triphosphate (ATP), and you will determine, for each offered set of substrates and environmental bounds, which substrate would be preferred based on its single-substrate maximal biomass production rate.\n\nFundamental base. Flux Balance Analysis (FBA) assumes a steady state of intracellular metabolite concentrations so that the net production of each internal metabolite is zero. If $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix and $v \\in \\mathbb{R}^{n}$ is the vector of reaction fluxes, the steady state constraint is $S v = 0$. Each flux $v_j$ is constrained by lower and upper bounds, and an objective (here, biomass production) is optimized. Solve a Linear Programming (LP) problem of maximizing the biomass reaction flux subject to mass balance and bounds.\n\nNetwork definition. Use the following internal metabolites: glucose (internal) $\\text{glc}_c$, acetate (internal) $\\text{ac}_c$, glycerol (internal) $\\text{glyc}_c$, oxygen (internal) $\\text{o2}_c$, carbon dioxide (internal) $\\text{co2}_c$, a generic carbon precursor pool $\\text{C}_c$, and ATP $\\text{atp}_c$. The following reactions comprise the network, written with stoichiometric coefficients for internal metabolites:\n\n- Substrate and oxygen imports (boundary sources with upper bounds):\n    - $r_0$: $\\emptyset \\rightarrow \\text{glc}_c$\n    - $r_1$: $\\emptyset \\rightarrow \\text{ac}_c$\n    - $r_2$: $\\emptyset \\rightarrow \\text{glyc}_c$\n    - $r_3$: $\\emptyset \\rightarrow \\text{o2}_c$\n\n- Carbon dioxide export (boundary sink with upper bound):\n    - $r_4$: $\\text{co2}_c \\rightarrow \\emptyset$\n\n- Assimilation and energy-yielding internal reactions (irreversible, non-negative fluxes):\n    - $r_5$: $\\text{glc}_c \\rightarrow 6\\, \\text{C}_c + 2\\, \\text{atp}_c$\n    - $r_6$: $\\text{glyc}_c \\rightarrow 3\\, \\text{C}_c + 1\\, \\text{atp}_c$\n    - $r_7$: $\\text{ac}_c \\rightarrow 2\\, \\text{C}_c$\n    - $r_8$: $\\text{C}_c + \\text{o2}_c \\rightarrow \\text{co2}_c + 10\\, \\text{atp}_c$  (aerobic respiration)\n    - $r_9$: $\\text{C}_c \\rightarrow \\text{co2}_c + 2\\, \\text{atp}_c$  (fermentation, anaerobic ATP production)\n\n- Biomass synthesis (objective reaction, irreversible):\n    - $r_{10}$: $5\\, \\text{C}_c + 20\\, \\text{atp}_c \\rightarrow \\text{biomass}$\n\nSteady-state mass balance must be enforced for the internal metabolites $\\text{glc}_c$, $\\text{ac}_c$, $\\text{glyc}_c$, $\\text{o2}_c$, $\\text{co2}_c$, $\\text{C}_c$, and $\\text{atp}_c$. The biomass pool is not a balanced metabolite; its production flux $v_{10}$ is the objective to be maximized.\n\nBounds. All internal reaction fluxes are non-negative, i.e., $v_j \\ge 0$ for $j \\in \\{5,6,7,8,9,10\\}$. The carbon dioxide export $r_4$ has bounds $0 \\le v_4 \\le 1000$. For imports $r_0$, $r_1$, $r_2$, and $r_3$, the bounds are $0 \\le v_j \\le U_j$ where $U_0 = U_{\\text{glc}}$, $U_1 = U_{\\text{ac}}$, $U_2 = U_{\\text{glyc}}$, and $U_3 = U_{\\text{O2}}$. All rates are to be interpreted as in mmol per gram dry weight per hour, but the final program’s output will be dimensionless integers as specified below.\n\nComputational task. Given a set of available carbon sources with specified import bounds and an oxygen import bound, predict which single carbon source would be consumed first according to the following decision rule: For each available carbon source $s$ in the set, compute the maximal biomass flux $v_{10}^{(s)}$ by solving the FBA problem with only that source’s import bound set to its specified $U_s$ (all other carbon source import bounds set to $0$ for that run), respecting the given oxygen bound $U_{\\mathrm{O2}}$. The preferred source is the one with the largest maximal biomass flux. In the case of a tie within a numerical tolerance of $10^{-7}$, choose the source with the smallest index according to the mapping below.\n\nSource index mapping:\n- Glucose $\\mapsto 0$\n- Acetate $\\mapsto 1$\n- Glycerol $\\mapsto 2$\n\nTest suite. Your program must hard-code and process the following five test cases. For each case, you are given the import bounds for glucose $U_{\\mathrm{glc}}$, acetate $U_{\\mathrm{ac}}$, glycerol $U_{\\mathrm{glyc}}$, and oxygen $U_{\\mathrm{O2}}$. A source is considered available in a case if and only if its $U_s > 0$.\n\n- Case A (abundant oxygen, glucose and acetate available): $U_{\\mathrm{glc}} = 10$, $U_{\\mathrm{ac}} = 10$, $U_{\\mathrm{glyc}} = 0$, $U_{\\mathrm{O2}} = 1000$.\n- Case B (abundant oxygen, acetate and glycerol available): $U_{\\mathrm{glc}} = 0$, $U_{\\mathrm{ac}} = 10$, $U_{\\mathrm{glyc}} = 10$, $U_{\\mathrm{O2}} = 1000$.\n- Case C (oxygen-limited, all three available): $U_{\\mathrm{glc}} = 10$, $U_{\\mathrm{ac}} = 10$, $U_{\\mathrm{glyc}} = 10$, $U_{\\mathrm{O2}} = 3$.\n- Case D (anaerobic, all three available): $U_{\\mathrm{glc}} = 10$, $U_{\\mathrm{ac}} = 10$, $U_{\\mathrm{glyc}} = 10$, $U_{\\mathrm{O2}} = 0$.\n- Case E (glucose scarce, glycerol abundant, aerobic): $U_{\\mathrm{glc}} = 2$, $U_{\\mathrm{ac}} = 0$, $U_{\\mathrm{glyc}} = 20$, $U_{\\mathrm{O2}} = 1000$.\n\nFinal output specification. Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets. The list must contain, in order, the preferred source index for Cases A through E. For example, an output might look like `[0,2,0,0,2]` (this is only an example placeholder; your program must compute the actual values).",
            "solution": "The problem statement has been evaluated and is deemed valid. It is a well-posed problem in computational systems biology, based on the established principles of Flux Balance Analysis (FBA). The metabolic network, while simplified, is scientifically plausible, and the task is a standard optimization problem that can be solved using linear programming.\n\nThe core principle of Flux Balance Analysis is the assumption of a pseudo-steady state for internal metabolite concentrations. This is expressed by the mass balance equation $S v = 0$, where $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix for $m$ metabolites and $n$ reactions, and $v \\in \\mathbb{R}^{n}$ is the vector of reaction fluxes. Each flux $v_j$ is further constrained by lower and upper bounds, $l_j \\le v_j \\le u_j$. The analysis seeks to optimize a cellular objective, which is formulated as a linear combination of fluxes, $Z = c^T v$. For this problem, the objective is to maximize the rate of biomass production, which corresponds to the flux of reaction $r_{10}$.\n\nThis constitutes a Linear Programming (LP) problem, which can be stated in canonical form as:\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & c^T v \\\\\n\\text{subject to} \\quad & S v = 0 \\\\\n& l \\le v \\le u\n\\end{aligned}\n$$\n\nWe must first construct the components of this LP problem for the given metabolic network.\n\nThe network consists of $m=7$ internal metabolites and $n=11$ reactions. Let us establish a consistent ordering for each.\nMetabolites:\n$0$: $\\text{glc}_c$ (internal glucose)\n$1$: $\\text{ac}_c$ (internal acetate)\n$2$: $\\text{glyc}_c$ (internal glycerol)\n$3$: $\\text{o2}_c$ (internal oxygen)\n$4$: $\\text{co2}_c$ (internal carbon dioxide)\n$5$: $\\text{C}_c$ (carbon precursor pool)\n$6$: $\\text{atp}_c$ (ATP)\n\nReactions (fluxes $v_j$):\n$v_0: r_0: \\emptyset \\rightarrow \\text{glc}_c$\n$v_1: r_1: \\emptyset \\rightarrow \\text{ac}_c$\n$v_2: r_2: \\emptyset \\rightarrow \\text{glyc}_c$\n$v_3: r_3: \\emptyset \\rightarrow \\text{o2}_c$\n$v_4: r_4: \\text{co2}_c \\rightarrow \\emptyset$\n$v_5: r_5: \\text{glc}_c \\rightarrow 6\\, \\text{C}_c + 2\\, \\text{atp}_c$\n$v_6: r_6: \\text{glyc}_c \\rightarrow 3\\, \\text{C}_c + 1\\, \\text{atp}_c$\n$v_7: r_7: \\text{ac}_c \\rightarrow 2\\, \\text{C}_c$\n$v_8: r_8: \\text{C}_c + \\text{o2}_c \\rightarrow \\text{co2}_c + 10\\, \\text{atp}_c$\n$v_9: r_9: \\text{C}_c \\rightarrow \\text{co2}_c + 2\\, \\text{atp}_c$\n$v_{10}: r_{10}: 5\\, \\text{C}_c + 20\\, \\text{atp}_c \\rightarrow \\text{biomass}$\n\nThe stoichiometric matrix $S$ of size $7 \\times 11$ is constructed by populating its entries $S_{ij}$ with the stoichiometric coefficient of metabolite $i$ in reaction $j$. Reactants have negative coefficients and products have positive coefficients.\n\n$$\nS =\n\\begin{pmatrix}\n% v0  v1  v2  v3  v4  v5  v6  v7  v8  v9 v10\n  1 &  0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 &  0 &  0 \\\\  % glc_c\n  0 &  1 &  0 &  0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 \\\\  % ac_c\n  0 &  0 &  1 &  0 &  0 &  0 & -1 &  0 &  0 &  0 &  0 \\\\  % glyc_c\n  0 &  0 &  0 &  1 &  0 &  0 &  0 &  0 & -1 &  0 &  0 \\\\  % o2_c\n  0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 &  1 &  1 &  0 \\\\  % co2_c\n  0 &  0 &  0 &  0 &  0 &  6 &  3 &  2 & -1 & -1 & -5 \\\\  % C_c\n  0 &  0 &  0 &  0 &  0 &  2 &  1 &  0 & 10 &  2 & -20   % atp_c\n\\end{pmatrix}\n$$\n\nThe objective is to maximize $v_{10}$. The objective vector $c$ is therefore a vector of zeros with a $1$ at the position corresponding to $v_{10}$.\n$$ c^T = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] $$\nSince standard LP solvers often minimize, we will minimize $-c^T v$.\n\nThe flux bounds are defined by the problem statement.\n- $0 \\le v_0 \\le U_{\\mathrm{glc}}$\n- $0 \\le v_1 \\le U_{\\mathrm{ac}}$\n- $0 \\le v_2 \\le U_{\\mathrm{glyc}}$\n- $0 \\le v_3 \\le U_{\\mathrm{O2}}$\n- $0 \\le v_4 \\le 1000$\n- $v_j \\ge 0$ for $j \\in \\{5, 6, 7, 8, 9, 10\\}$. The upper bounds for these internal fluxes are effectively infinite.\n\nThe computational task requires us to process five test cases. For each case, we must determine which single available carbon source (glucose, acetate, or glycerol) yields the highest maximal biomass production rate $v_{10}$. A source is available if its uptake bound $U_s > 0$. The procedure for each test case is as follows:\n\n1. Identify the set of available carbon sources based on their non-zero uptake bounds. The sources are mapped to indices: glucose $\\mapsto 0$, acetate $\\mapsto 1$, glycerol $\\mapsto 2$.\n\n2. For each available carbon source $s$, solve a separate FBA problem:\n   a. Set the upper bound for the import flux of source $s$ (i.e., $v_0$, $v_1$, or $v_2$) to its specified value $U_s$.\n   b. Set the upper bounds for the import fluxes of all other carbon sources to $0$. This ensures only one carbon source is consumed.\n   c. The oxygen uptake bound $v_3$ is set to the value $U_{\\mathrm{O2}}$ given for the test case.\n   d. All other bounds remain as specified.\n   e. Solve the LP to find the maximum possible flux for the biomass reaction, $v_{10}^{(s)}$.\n\n3. Compare the maximum biomass fluxes obtained for each available source. The preferred source is the one yielding the highest $v_{10}^{(s)}$.\n\n4. If two or more sources yield a maximal biomass flux that is equal within a tolerance of $10^{-7}$, the tie is broken by selecting the source with the smallest index ($0  1  2$).\n\nThis algorithm will be implemented in Python using the `scipy.optimize.linprog` function to solve the LP problems. For each of the five test cases, we will execute this procedure and determine the index of the preferred carbon source. The final output will be a list of these indices.\nThe program will hard-code the stoichiometric matrix, the objective vector, and the parameters for the five test cases. A function will be defined to set up and solve the LP for a given set of flux bounds. The main part of the program will iterate through the test cases, call the solver function for each available substrate, and apply the decision logic to find the optimal substrate for each case. The results will then be compiled and printed in the specified format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of Flux Balance Analysis problems to determine the preferred carbon source\n    for a simplified metabolic model under different environmental conditions.\n    \"\"\"\n\n    # Stoichiometric matrix S (7 metabolites x 11 reactions)\n    # Metabolites: glc_c, ac_c, glyc_c, o2_c, co2_c, C_c, atp_c\n    # Reactions: v0-v10\n    S = np.array([\n        # v0  v1  v2  v3  v4  v5  v6  v7  v8  v9 v10\n        [ 1,  0,  0,  0,  0, -1,  0,  0,  0,  0,  0],  # glc_c\n        [ 0,  1,  0,  0,  0,  0,  0, -1,  0,  0,  0],  # ac_c\n        [ 0,  0,  1,  0,  0,  0, -1,  0,  0,  0,  0],  # glyc_c\n        [ 0,  0,  0,  1,  0,  0,  0,  0, -1,  0,  0],  # o2_c\n        [ 0,  0,  0,  0, -1,  0,  0,  0,  1,  1,  0],  # co2_c\n        [ 0,  0,  0,  0,  0,  6,  3,  2, -1, -1, -5],  # C_c\n        [ 0,  0,  0,  0,  0,  2,  1,  0, 10,  2, -20]  # atp_c\n    ], dtype=np.float64)\n\n    # Objective function: maximize v_10 (biomass).\n    # linprog minimizes, so we minimize -v_10.\n    c = np.zeros(11, dtype=np.float64)\n    c[10] = -1.0\n\n    # Steady-state constraint: Sv = 0\n    b_eq = np.zeros(7, dtype=np.float64)\n\n    # Substrate mapping: name - (index, uptake_reaction_index)\n    substrates = {\n        'glucose': (0, 0),\n        'acetate': (1, 1),\n        'glycerol': (2, 2)\n    }\n\n    # Test cases: (U_glc, U_ac, U_glyc, U_O2)\n    test_cases = [\n        # Case A: abundant oxygen, glucose and acetate available\n        {'U_glc': 10.0, 'U_ac': 10.0, 'U_glyc': 0.0, 'U_O2': 1000.0},\n        # Case B: abundant oxygen, acetate and glycerol available\n        {'U_glc': 0.0, 'U_ac': 10.0, 'U_glyc': 10.0, 'U_O2': 1000.0},\n        # Case C: oxygen-limited, all three available\n        {'U_glc': 10.0, 'U_ac': 10.0, 'U_glyc': 10.0, 'U_O2': 3.0},\n        # Case D: anaerobic, all three available\n        {'U_glc': 10.0, 'U_ac': 10.0, 'U_glyc': 10.0, 'U_O2': 0.0},\n        # Case E: glucose scarce, glycerol abundant, aerobic\n        {'U_glc': 2.0, 'U_ac': 0.0, 'U_glyc': 20.0, 'U_O2': 1000.0}\n    ]\n\n    final_results = []\n    \n    # Process each test case\n    for case in test_cases:\n        uptake_bounds = {\n            'glucose': case['U_glc'],\n            'acetate': case['U_ac'],\n            'glycerol': case['U_glyc']\n        }\n        oxygen_bound = case['U_O2']\n        \n        # Identify available substrates for the current case\n        available_substrates = []\n        for name, u_bound in uptake_bounds.items():\n            if u_bound  0:\n                available_substrates.append(name)\n        \n        case_results = []\n\n        # Run FBA for each available substrate individually\n        for sub_name in available_substrates:\n            sub_idx, reaction_idx = substrates[sub_name]\n            \n            # Define flux bounds for this specific FBA run\n            bounds = [(0.0, None)] * 11\n            bounds[4] = (0.0, 1000.0)\n            \n            # Set carbon source bounds: only one is allowed to be non-zero\n            for name, (idx, rxn_idx) in substrates.items():\n                if name == sub_name:\n                    bounds[rxn_idx] = (0.0, uptake_bounds[name])\n                else:\n                    bounds[rxn_idx] = (0.0, 0.0)\n\n            # Set oxygen bound\n            bounds[3] = (0.0, oxygen_bound)\n            \n            # Solve the linear programming problem\n            res = linprog(c, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n            \n            max_biomass = 0.0\n            if res.success:\n                max_biomass = -res.fun\n            \n            case_results.append({'biomass': max_biomass, 'index': sub_idx})\n\n        # Determine the preferred substrate based on max biomass and tie-breaking rule\n        if not case_results:\n            # Should not happen with the given test cases, but good practice\n            # If no substrate is available, there's no preferred one.\n            # We can represent this with a placeholder like -1, but the problem\n            # guarantees at least one source.\n            continue\n            \n        max_biomass_val = -1.0\n        for r in case_results:\n            if r['biomass']  max_biomass_val:\n                max_biomass_val = r['biomass']\n\n        # Find all substrates that achieve the max biomass within tolerance\n        tied_winners = [r for r in case_results if abs(r['biomass'] - max_biomass_val)  1e-7]\n        \n        # Tie-break by choosing the one with the smallest index\n        best_substrate_idx = min(r['index'] for r in tied_winners)\n        final_results.append(best_substrate_idx)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond predicting optimal growth, FBA is instrumental in analyzing the robustness of metabolic networks. In this practice, you will learn to identify \"choke-point\" reactions—critical enzymes whose removal would cause a precursor metabolite to accumulate, leading to cellular toxicity or pathway breakdown . This technique of simulating reaction knockouts is fundamental to identifying potential drug targets and understanding metabolic vulnerabilities.",
            "id": "2390901",
            "problem": "You are given a series of steady-state metabolic networks and asked to identify, for a specified precursor metabolite, which reactions are \"choke-point\" consumers whose deletion would force the accumulation of that precursor. Work in the standard Flux Balance Analysis (FBA) setting from first principles.\n\nUse the following fundamental base:\n- Steady-state mass balance is represented by the stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$ and the flux vector $v \\in \\mathbb{R}^{n}$ via the linear constraints\n$$\nS\\,v = 0.\n$$\n- Each reaction $j \\in \\{0,1,\\dots,n-1\\}$ has lower and upper flux bounds $l_j \\le v_j \\le u_j$, collected as vectors $l, u \\in \\mathbb{R}^{n}$.\n- To represent the fact that a particular precursor metabolite $m^{\\star}$ is supplied by the environment or an upstream module at a strictly positive rate, a designated \"source reaction\" $s$ is required to satisfy the bound\n$$\nv_s \\ge p_{\\min},\n$$\nfor a given constant $p_{\\min} > 0$. All reaction indices are zero-based, i.e., $\\{0,1,\\dots,n-1\\}$.\n\nDefinition of choke-point consumer for $m^{\\star}$ used in this task:\n- A reaction $r$ is a candidate consumer of $m^{\\star}$ if and only if the stoichiometric coefficient $S_{m^{\\star}, r}  0$ and the upper bound $u_r > 0$ (so that consumption is directionally and capacity-wise possible).\n- A candidate consumer $r$ is a choke-point for $m^{\\star}$ if the following two conditions hold:\n  1. The baseline model with the enforced production of $m^{\\star}$ at rate at least $p_{\\min}$ is feasible, i.e., there exists $v$ such that $S v = 0$, $l \\le v \\le u$, and $v_s \\ge p_{\\min}$.\n  2. After deleting reaction $r$ by enforcing $v_r = 0$ (i.e., setting $l_r = u_r = 0$) while keeping all other constraints the same, the model becomes infeasible.\nIntuitively, if deletion of $r$ destroys steady-state feasibility under a strictly positive enforced production of $m^{\\star}$, then the network can no longer consume $m^{\\star}$ sufficiently, which would cause its accumulation in any dynamic relaxation.\n\nYour task:\n- For each test case below, determine the sorted list of indices (zero-based) of all choke-point consumers for the specified $m^{\\star}$.\n- If the baseline model (with $v_s \\ge p_{\\min}$) is infeasible for a test case, return the empty list for that case.\n\nTest suite:\nFor each case, you are given the matrix $S$, the bound vectors $l$ and $u$, the index $m^{\\star}$ of the target metabolite row, the index $s$ of the source reaction, and the value $p_{\\min}$. All entries are real numbers. The symbol $\\mathrm{DM}$ denotes a generic drain/export reaction to maintain steady state, modeled as a reaction consuming the indicated metabolite.\n\n- Case A (single consumer must carry all production):\n  - Metabolites ordered as $[M,\\;B]$, reactions ordered as $[R_0,R_1,R_2]$ with $R_0$ an uptake producing $M$, $R_1$ converting $M \\rightarrow B$, and $R_2$ a demand on $B$.\n  - Stoichiometry:\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1  -1  0 \\\\\n    0   +1  -1\n    \\end{bmatrix}.\n    $$\n  - Bounds:\n    $$\n    l = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\end{bmatrix}.\n    $$\n  - Target metabolite index $m^{\\star} = 0$ (row for $M$), source reaction index $s = 0$, and $p_{\\min} = 1$.\n\n- Case B (two parallel consumers, either suffices):\n  - Metabolites ordered as $[M,\\;B_1,\\;B_2]$, reactions ordered as $[R_0,R_1,R_2,R_3,R_4]$ with $R_0$ an uptake producing $M$, $R_1$ converting $M \\rightarrow B_1$, $R_2$ converting $M \\rightarrow B_2$, and $R_3,R_4$ demands on $B_1,B_2$ respectively.\n  - Stoichiometry:\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1  -1  -1  0   0 \\\\\n    0   +1  0    -1  0 \\\\\n    0   0   +1   0   -1\n    \\end{bmatrix}.\n    $$\n  - Bounds:\n    $$\n    l = \\begin{bmatrix} 2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\\\ 10 \\\\ 10 \\end{bmatrix}.\n    $$\n  - Target metabolite index $m^{\\star} = 0$ (row for $M$), source reaction index $s = 0$, and $p_{\\min} = 2$.\n\n- Case C (single reversible consumer):\n  - Metabolites ordered as $[M,\\;X]$, reactions ordered as $[R_0,R_1,R_2]$ with $R_0$ an uptake producing $M$, $R_1$ reversible interconversion $M \\rightleftharpoons X$, and $R_2$ a demand on $X$.\n  - Stoichiometry:\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1  -1  0 \\\\\n    0   +1  -1\n    \\end{bmatrix}.\n    $$\n  - Bounds:\n    $$\n    l = \\begin{bmatrix} 1 \\\\ -10 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\end{bmatrix}.\n    $$\n  - Target metabolite index $m^{\\star} = 0$, source reaction index $s = 0$, and $p_{\\min} = 1$.\n\n- Case D (capacity-limited alternative consumer):\n  - Metabolites ordered as $[M]$, reactions ordered as $[R_0,R_1,R_2]$ with $R_0$ an uptake producing $M$, and $R_1,R_2$ two distinct drains of $M$.\n  - Stoichiometry:\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1  -1  -1\n    \\end{bmatrix}.\n    $$\n  - Bounds:\n    $$\n    l = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\\\ 1 \\\\ 0.6 \\end{bmatrix}.\n    $$\n  - Target metabolite index $m^{\\star} = 0$, source reaction index $s = 0$, and $p_{\\min} = 1$.\n\n- Case E (baseline infeasible: no consumer exists):\n  - Metabolites ordered as $[M]$, reactions ordered as $[R_0]$ with $R_0$ an uptake producing $M$.\n  - Stoichiometry:\n    $$\n    S \\;=\\; \\begin{bmatrix}\n    +1\n    \\end{bmatrix}.\n    $$\n  - Bounds:\n    $$\n    l = \\begin{bmatrix} 1 \\end{bmatrix},\\quad\n    u = \\begin{bmatrix} 10 \\end{bmatrix}.\n    $$\n  - Target metabolite index $m^{\\star} = 0$, source reaction index $s = 0$, and $p_{\\min} = 1$.\n\nFinal output format:\n- Your program must output a single line containing a list of results, one per test case, aggregated in order as a comma-separated list enclosed in square brackets.\n- Each result must itself be a list of zero-based reaction indices of choke-point consumers for that test case, in ascending order.\n- The final printed line must therefore look like `[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]` with no spaces. For example, a valid output could be `[[1],[],[1],[1],[]]` if those are the results for Cases A through E respectively.",
            "solution": "We start from the steady-state assumption of Flux Balance Analysis (FBA), which imposes the linear constraints $S v = 0$ with flux bounds $l \\le v \\le u$. For a particular precursor metabolite $m^{\\star}$, the problem asks us to identify reactions whose deletion would force accumulation of $m^{\\star}$. Since FBA does not explicitly model dynamic accumulation (it enforces $S v = 0$), we instead enforce a strictly positive production of $m^{\\star}$ from a designated source reaction $s$ by requiring $v_s \\ge p_{\\min}$ for a given $p_{\\min}  0$. If after deleting a reaction $r$ the model becomes infeasible under these constraints, then it is impossible to maintain steady state with $v_s \\ge p_{\\min}$, which means that in any dynamic relaxation $m^{\\star}$ would accumulate (because the system cannot consume it sufficiently to balance its forced production). This is a standard way to diagnose accumulation risk within the static FBA framework.\n\nWe formalize the choke-point criterion as follows. A reaction $r$ is a candidate consumer if $S_{m^{\\star}, r}  0$ and $u_r  0$, which means the reaction can consume $m^{\\star}$ in the forward direction within its capacity. Then $r$ is a choke-point if:\n1. The baseline feasibility problem has a solution:\n$$\n\\text{find } v \\in \\mathbb{R}^{n} \\text{ such that } S v = 0,\\quad l \\le v \\le u,\\quad v_s \\ge p_{\\min}.\n$$\n2. The modified feasibility problem with $r$ deleted, i.e., with bounds replaced by $l_r = u_r = 0$, has no solution.\n\nThis yields a pure feasibility check. Computationally, this can be implemented as a linear program with a zero objective, i.e., minimize $0$ subject to the constraints above. A modern linear programming solver can determine feasibility for each case.\n\nAlgorithmic design:\n- For each test case, construct the matrix $S$, bounds $l, u$, the target index $m^{\\star}$, source index $s$, and the scalar $p_{\\min}$.\n- Define the baseline bounds by raising the lower bound at index $s$ to at least $p_{\\min}$, i.e., replace $l_s$ by $\\max(l_s, p_{\\min})$. Solve the linear program\n$$\n\\min\\ 0 \\quad \\text{s.t. } S v = 0,\\; l \\le v \\le u.\n$$\nIf infeasible, return the empty list for this case.\n- Otherwise, form the list of candidate consumers $\\mathcal{C} = \\{ r \\in \\{0,\\dots,n-1\\} \\mid S_{m^{\\star}, r}  0 \\text{ and } u_r  0 \\}$.\n- For each $r \\in \\mathcal{C}$, construct modified bounds with $l_r = u_r = 0$ and resolve the feasibility problem. If infeasible, add $r$ to the choke-point set.\n- Return the sorted list of choke-point indices.\n\nWhy this is correct under the stated definition:\n- If the baseline is infeasible, then the network cannot maintain steady state with enforced production, regardless of deletions; we return the empty list as specified.\n- If deletion of $r$ makes the system infeasible, then with $v_s \\ge p_{\\min}$ enforced, there is no way to satisfy $S v = 0$; $m^{\\star}$ cannot be consumed sufficiently by the remaining network. Therefore, $m^{\\star}$ would accumulate in any dynamic interpretation, and $r$ is a choke-point.\n- Conversely, if deletion of $r$ leaves the system feasible, then there exists a steady-state flux vector that balances the enforced production; hence no forced accumulation.\n\nNow we analyze the given cases.\n\nCase A:\n- $S$ and bounds allow $v_0 \\ge 1$, $v_1$ converts $M$ to $B$, and $v_2$ drains $B$. Mass balance for $M$ requires $v_0 - v_1 = 0$, so $v_1 = v_0 \\ge 1$ is feasible within $u_1 = 10$. The only consumer candidate for $M$ is $R_1$ (index $1$). Deleting $R_1$ enforces $v_1 = 0$, which makes $v_0 - v_1 = v_0 \\ge 1$ impossible to balance. Thus the modified system is infeasible. The choke-point set is $[1]$.\n\nCase B:\n- Baseline requires $v_0 \\ge 2$ and $v_1 + v_2 = v_0$, with $v_1, v_2 \\le 10$, and drains $v_3 = v_1$, $v_4 = v_2$. This is feasible. Consumers of $M$ are $R_1$ (index $1$) and $R_2$ (index $2$). Deleting either one still allows the other to carry the full $v_0 \\ge 2$ within capacity, so feasibility remains. The choke-point set is $[]$.\n\nCase C:\n- Baseline: $v_0 \\ge 1$, mass balance for $M$ gives $v_1 = v_0$, for $X$ gives $v_2 = v_1$, which is feasible within $v_1 \\in [-10,10]$ and $v_2 \\in [0,10]$. The only consumer of $M$ is $R_1$ (index $1$). Deleting $R_1$ forces $v_1 = 0$ and thus $v_0 = 0$, contradicting $v_0 \\ge 1$, causing infeasibility. The choke-point set is $[1]$.\n\nCase D:\n- Baseline: $v_0 \\ge 1$ with $v_1 + v_2 = v_0$, $0 \\le v_1 \\le 1$, $0 \\le v_2 \\le 0.6$. Feasible choices exist, e.g., $v_1 = 0.4$, $v_2 = 0.6$, $v_0 = 1$. Consumers are $R_1$ (index $1$) and $R_2$ (index $2$). Deleting $R_1$ leaves $v_2 \\le 0.6$ unable to balance $v_0 \\ge 1$, rendering infeasibility; deleting $R_2$ still permits $v_1 = 1$ to balance. Thus the choke-point set is $[1]$.\n\nCase E:\n- Baseline: $v_0 \\ge 1$ with no consumers, so $S v = 0$ cannot be satisfied. The baseline is infeasible by definition, so the result is the empty list $[]$.\n\nTherefore, the aggregated results for Cases A through E are\n$$\n[[1],[],[1],[1],[]].\n$$\n\nThe program implements the feasibility checks via linear programming with a zero objective and prints the final aggregated list in the required single-line, no-spaces format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\nfrom scipy.optimize import linprog\n\ndef is_feasible(S, l_bounds, u_bounds):\n    \"\"\"\n    Check feasibility of S v = 0 with bounds l = v = u by minimizing a zero objective.\n    Returns True if feasible, False otherwise.\n    \"\"\"\n    m, n = S.shape\n    c = np.zeros(n)\n    A_eq = S\n    b_eq = np.zeros(m)\n    bounds = list(zip(l_bounds, u_bounds))\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=\"highs\")\n    return res.status == 0\n\ndef find_choke_points(S, l, u, m_star, s_idx, p_min):\n    \"\"\"\n    Identify choke-point consumers for metabolite m_star.\n    - Enforce baseline feasibility with v_s = p_min (raise l_s if needed).\n    - Candidate consumers r satisfy S[m_star, r]  0 and u[r]  0.\n    - r is a choke-point if deleting r (setting its bounds to 0) makes the system infeasible.\n    Returns sorted list of reaction indices.\n    \"\"\"\n    S = np.array(S, dtype=float)\n    l = np.array(l, dtype=float)\n    u = np.array(u, dtype=float)\n\n    # Enforce the minimal production bound at the source reaction\n    l_base = l.copy()\n    l_base[s_idx] = max(l_base[s_idx], p_min)\n\n    # Baseline feasibility check\n    if not is_feasible(S, l_base, u):\n        return []\n\n    # Identify candidate consumers for m_star\n    consumers = [j for j in range(S.shape[1]) if S[m_star, j]  0 and u[j]  0]\n\n    choke = []\n    for r in consumers:\n        l_mod = l_base.copy()\n        u_mod = u.copy()\n        # Delete reaction r\n        l_mod[r] = 0.0\n        u_mod[r] = 0.0\n        if not is_feasible(S, l_mod, u_mod):\n            choke.append(r)\n\n    return sorted(choke)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A\n    S_A = np.array([\n        [ +1, -1,  0],\n        [  0, +1, -1],\n    ], dtype=float)\n    l_A = np.array([1, 0, 0], dtype=float)\n    u_A = np.array([10, 10, 10], dtype=float)\n    m_star_A = 0\n    s_A = 0\n    pmin_A = 1\n\n    # Case B\n    S_B = np.array([\n        [ +1, -1, -1,  0,  0],\n        [  0, +1,  0, -1,  0],\n        [  0,  0, +1,  0, -1],\n    ], dtype=float)\n    l_B = np.array([2, 0, 0, 0, 0], dtype=float)\n    u_B = np.array([10,10,10,10,10], dtype=float)\n    m_star_B = 0\n    s_B = 0\n    pmin_B = 2\n\n    # Case C\n    S_C = np.array([\n        [ +1, -1,  0],\n        [  0, +1, -1],\n    ], dtype=float)\n    l_C = np.array([1, -10, 0], dtype=float)\n    u_C = np.array([10, 10, 10], dtype=float)\n    m_star_C = 0\n    s_C = 0\n    pmin_C = 1\n\n    # Case D\n    S_D = np.array([\n        [ +1, -1, -1],\n    ], dtype=float)\n    l_D = np.array([1, 0, 0], dtype=float)\n    u_D = np.array([10, 1, 0.6], dtype=float)\n    m_star_D = 0\n    s_D = 0\n    pmin_D = 1\n\n    # Case E\n    S_E = np.array([\n        [ +1 ],\n    ], dtype=float)\n    l_E = np.array([1], dtype=float)\n    u_E = np.array([10], dtype=float)\n    m_star_E = 0\n    s_E = 0\n    pmin_E = 1\n\n    test_cases = [\n        (S_A, l_A, u_A, m_star_A, s_A, pmin_A),\n        (S_B, l_B, u_B, m_star_B, s_B, pmin_B),\n        (S_C, l_C, u_C, m_star_C, s_C, pmin_C),\n        (S_D, l_D, u_D, m_star_D, s_D, pmin_D),\n        (S_E, l_E, u_E, m_star_E, s_E, pmin_E),\n    ]\n\n    results = []\n    for S, l, u, m_star, s_idx, p_min in test_cases:\n        choke_list = find_choke_points(S, l, u, m_star, s_idx, p_min)\n        results.append(choke_list)\n\n    # Final print statement in the exact required format: no spaces.\n    print(json.dumps(results, separators=(',',':')))\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of much of systems biology is not just to understand, but to engineer. This final exercise places you in the role of a metabolic engineer, tasked with modifying a microorganism to produce a valuable biofuel instead of merely maximizing its own growth . You will explore how to use FBA as a design tool, searching for the minimum number of genetic interventions required to switch the cell's primary metabolic objective, a core task in modern synthetic biology.",
            "id": "2390851",
            "problem": "You are given a family of small metabolic networks specified for Flux Balance Analysis (FBA), where Flux Balance Analysis (FBA) assumes steady-state mass balance and linear reaction flux constraints. For each network, let there be a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$, a flux vector $v \\in \\mathbb{R}^{n}$, lower bounds $l \\in \\mathbb{R}^{n}$, and upper bounds $u \\in \\mathbb{R}^{n}$. The feasible flux space is defined by the steady-state constraints $S v = 0$ together with bound constraints $l \\le v \\le u$. Two linear objective functions are defined: biomass growth with objective vector $c^{\\mathrm{bm}} \\in \\mathbb{R}^{n}$ and biofuel production with objective vector $c^{\\mathrm{bf}} \\in \\mathbb{R}^{n}$. For any given bounds $(l,u)$, the maximum biomass is the optimal value of $c^{\\mathrm{bm}} \\cdot v$ subject to $S v = 0$, $l \\le v \\le u$, and the maximum biofuel is the optimal value of $c^{\\mathrm{bf}} \\cdot v$ subject to the same constraints. You are provided, for each test case, a finite set of allowable reaction bound edits. Each allowable edit is a triplet $(j, \\hat{l}_j, \\hat{u}_j)$ indicating that, if applied, the lower and upper bounds for reaction $j$ are changed to $\\hat{l}_j$ and $\\hat{u}_j$, respectively. Any subset of allowable edits may be applied, with the restriction that at most one edit per reaction can be active; if more than one edit targets the same reaction, such a selection is invalid. For a given test case, define two thresholds: a biofuel target $\\tau_{\\mathrm{bf}} \\in \\mathbb{R}_{\\ge 0}$ and a growth cap $\\tau_{\\mathrm{bm}} \\in \\mathbb{R}_{\\ge 0}$. Your task is, for each test case, to determine the minimum number of allowable edits required so that, under the edited bounds $(l',u')$, the maximum biomass is less than or equal to $\\tau_{\\mathrm{bm}}$ and the maximum biofuel is greater than or equal to $\\tau_{\\mathrm{bf}}$. If no selection of allowable edits can satisfy both conditions simultaneously, return $-1$ for that test case. All matrices, vectors, indices, and numbers are provided below and must be used exactly as specified.\n\nIn every test case below, the internal metabolites are $G$ (intracellular glucose) and $P$ (pyruvate). The reactions are ordered as follows: index $0$ is glucose uptake $\\text{EX_g}$, index $1$ is glycolysis $\\text{Gly}$, index $2$ is biomass drain $\\text{Biomass}$, index $3$ is biofuel drain $\\text{Biofuel}$, and index $4$ is pyruvate secretion $\\text{EX_p}$. The stoichiometric matrix $S \\in \\mathbb{R}^{2 \\times 5}$ is the same across all cases and is given by\n$$\nS = \\begin{bmatrix}\n+1  -1  0  0  0 \\\\\n0  +2  -1  -1  -1\n\\end{bmatrix}.\n$$\nThis encodes the relations: $\\text{EX_g}: \\emptyset \\rightarrow G$, $\\text{Gly}: G \\rightarrow 2P$, $\\text{Biomass}: P \\rightarrow \\emptyset$, $\\text{Biofuel}: P \\rightarrow \\emptyset$, and $\\text{EX_p}: P \\rightarrow \\emptyset$. The default lower and upper bounds for all reactions are specified per test case and use the convention of irreversible import and drains with nonnegative flux. The two objective vectors are:\n- Biomass objective $c^{\\mathrm{bm}} \\in \\mathbb{R}^{5}$: $c^{\\mathrm{bm}} = [0, 0, 1, 0, 0]$.\n- Biofuel objective $c^{\\mathrm{bf}} \\in \\mathbb{R}^{5}$: $c^{\\mathrm{bf}} = [0, 0, 0, 1, 0]$.\n\nThe four test cases are:\n\nTest case $1$ (general case): bounds and thresholds\n- Lower bounds $l = [0, 0, 0, 0, 0]$ and upper bounds $u = [10, 1000, 1000, 1000, 1000]$.\n- Biofuel target $\\tau_{\\mathrm{bf}} = 15$ and growth cap $\\tau_{\\mathrm{bm}} = 0$.\n- Allowable edits set $E$ contains exactly one edit: $(2, 0, 0)$, which sets the biomass reaction upper bound to zero.\n\nTest case $2$ (requires multiple edits): bounds and thresholds\n- Lower bounds $l = [0, 0, 0, 0, 0]$ and upper bounds $u = [10, 1000, 1000, 0, 1000]$ (the biofuel reaction is initially closed).\n- Biofuel target $\\tau_{\\mathrm{bf}} = 15$ and growth cap $\\tau_{\\mathrm{bm}} = 0$.\n- Allowable edits set $E$ has two edits: $(3, 0, 1000)$ to open the biofuel reaction, and $(2, 0, 0)$ to close the biomass reaction.\n\nTest case $3$ (impossible under given edits): bounds and thresholds\n- Lower bounds $l = [0, 0, 0, 0, 0]$ and upper bounds $u = [10, 0, 1000, 1000, 1000]$ (the glycolysis reaction is initially closed, preventing conversion from $G$ to $P$).\n- Biofuel target $\\tau_{\\mathrm{bf}} = 1$ and growth cap $\\tau_{\\mathrm{bm}} = 0$.\n- Allowable edits set $E$ has one edit: $(2, 0, 0)$ to close the biomass reaction. No edit is allowed to open glycolysis.\n\nTest case $4$ (zero edits suffice): bounds and thresholds\n- Lower bounds $l = [0, 0, 0, 0, 0]$ and upper bounds $u = [10, 1000, 0, 1000, 1000]$ (the biomass reaction is initially closed).\n- Biofuel target $\\tau_{\\mathrm{bf}} = 15$ and growth cap $\\tau_{\\mathrm{bm}} = 0$.\n- Allowable edits set $E$ is empty.\n\nYour program must compute, for each test case, the minimum number of allowable edits required to achieve a configuration in which the maximum biomass is less than or equal to $\\tau_{\\mathrm{bm}}$ and the maximum biofuel is greater than or equal to $\\tau_{\\mathrm{bf}}$, or return $-1$ if no such configuration exists.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3,result4]`), in the order of test cases $1$ through $4$. The outputs must be integers, with $-1$ indicating impossibility.",
            "solution": "The problem statement is critically evaluated and deemed valid. It is scientifically grounded in the principles of stoichiometric modeling and Flux Balance Analysis (FBA), a standard method in computational biology. The problem is well-posed, presenting a combinatorial optimization task layered upon a set of linear programming problems. All necessary data, including the stoichiometric matrix, objective vectors, reaction bounds, and specified edits, are provided completely and consistently for each test case. The problem is objective and free of any factual or logical inconsistencies.\n\nThe task is to find the minimum number of allowable reaction bound edits to satisfy two conditions simultaneously: a maximum biomass production less than or equal to a threshold $\\tau_{\\mathrm{bm}}$, and a maximum biofuel production greater than or equal to a threshold $\\tau_{\\mathrm{bf}}$. This requires a search over the power set of allowable edits. Since we seek the minimum number of edits, we can structure this as a breadth-first search, examining subsets of edits in increasing order of their size, starting from size $k=0$. For each valid subset of edits, we must determine the maximum possible flux for the biomass and biofuel reactions.\n\nA given set of reaction bounds, represented by a lower bound vector $l \\in \\mathbb{R}^5$ and an upper bound vector $u \\in \\mathbb{R}^5$, defines a feasible flux space for the flux vector $v = [v_0, v_1, v_2, v_3, v_4]^T$. The constraints on this space are given by the steady-state mass balance equation $S v = 0$ and the bound constraints $l \\le v \\le u$. The stoichiometric matrix is given as:\n$$\nS = \\begin{bmatrix}\n+1  -1  0  0  0 \\\\\n0  +2  -1  -1  -1\n\\end{bmatrix}\n$$\nThis matrix encodes two linear equality constraints on the fluxes:\n$1. \\quad v_0 - v_1 = 0 \\implies v_0 = v_1$\n$2. \\quad 2v_1 - v_2 - v_3 - v_4 = 0 \\implies 2v_1 = v_2 + v_3 + v_4$\n\nCombining these yields the core relationship $2v_0 = v_2 + v_3 + v_4$. This shows that the total output flux ($v_2 + v_3 + v_4$) is determined by twice the glucose uptake flux ($v_0$), which is equivalent to the flux through glycolysis ($v_1$).\n\nThe two optimization problems of interest are to maximize biomass flux, $v_2$, and biofuel flux, $v_3$. These are linear programs. However, for this simple network, we can derive an analytical solution. Let us consider the maximization of an arbitrary product flux $v_k$ where $k \\in \\{2, 3\\}$. Rearranging the stoichiometric constraint, we have $v_k = 2v_1 - \\sum_{j \\in \\{2,3,4\\}, j \\neq k} v_j$.\n\nTo maximize $v_k$, one must maximize the precursor supply, $2v_1$, while minimizing the flux diverted to competing pathways, $\\sum_{j \\neq k} v_j$. The flux $v_1$ is constrained by its own bounds $[l_1, u_1]$ and by the bounds on $v_0$ via $v_0=v_1$, so $\\max(l_0, l_1) \\le v_1 \\le \\min(u_0, u_1)$. The competing fluxes $v_j$ are minimized by setting them to their lower bounds, $l_j$. In all test cases provided, all lower bounds $l_i$ are initially $0$ and edits do not change this. Thus, we can set competing fluxes to $0$. The maximum supply through glycolysis is $v_{1, \\text{max}} = \\min(u_0, u_1)$.\n\nThe maximum theoretical flux for $v_2$ (biomass) is thus determined by maximizing $v_1$ and setting competing fluxes $v_3$ and $v_4$ to their lower bounds, $l_3$ and $l_4$.\n$$\n\\text{max } v_2^{\\text{potential}} = 2 \\cdot \\min(u_0, u_1) - l_3 - l_4\n$$\nThis potential maximum must also respect the intrinsic bounds on $v_2$, namely $[l_2, u_2]$. Since all $l_i \\ge 0$, any flux $v_i$ must be non-negative. The final maximum biomass flux is therefore:\n$$\nz_{\\mathrm{bm}}^* = \\max v_2 = \\min(u_2, \\max(0, 2 \\cdot \\min(u_0, u_1) - l_3 - l_4))\n$$\nBy symmetry, the maximum biofuel flux $z_{\\mathrm{bf}}^*$ is found by minimizing competing fluxes $v_2$ and $v_4$:\n$$\nz_{\\mathrm{bf}}^* = \\max v_3 = \\min(u_3, \\max(0, 2 \\cdot \\min(u_0, u_1) - l_2 - l_4))\n$$\nThese formulae allow for direct computation of the maximum objective values for any given set of bounds $(l, u)$, bypassing the need for a general-purpose linear programming solver.\n\nThe algorithm proceeds as follows for each test case:\n$1.$ Check if the initial bounds (zero edits, $k=0$) satisfy the conditions $z_{\\mathrm{bm}}^* \\le \\tau_{\\mathrm{bm}}$ and $z_{\\mathrm{bf}}^* \\ge \\tau_{\\mathrm{bf}}$. If so, the answer is $0$.\n$2.$ If not, iterate through the number of edits $k$ from $1$ up to the total count of available edits.\n$3.$ For each $k$, generate all unique combinations of $k$ edits from the allowable set.\n$4.$ For each combination, verify its validity (i.e., no two edits target the same reaction).\n$5.$ If valid, apply the edits to create new bound vectors $(l', u')$. Calculate $z_{\\mathrm{bm}}^*$ and $z_{\\mathrm{bf}}^*$ using the derived analytical formulae.\n$6.$ If the conditions $z_{\\mathrm{bm}}^* \\le \\tau_{\\mathrm{bm}}$ and $z_{\\mathrm{bf}}^* \\ge \\tau_{\\mathrm{bf}}$ are met, then $k$ is the minimum number of edits. The result for the test case is $k$.\n$7.$ If the loops complete without finding a solution, no combination of edits can satisfy the requirements, and the result is $-1$.\n\nWe apply this method to the test cases.\nFor test case $1$, with initial bounds, $\\min(u_0, u_1)=10$, leading to $z_{\\mathrm{bm}}^*=20$ and $z_{\\mathrm{bf}}^*=20$. The condition $z_{\\mathrm{bm}}^* \\le \\tau_{\\mathrm{bm}} = 0$ is not met. Applying the single available edit $(2, 0, 0)$ sets $u_2=0$, resulting in $z_{\\mathrm{bm}}^*=0$ and $z_{\\mathrm{bf}}^*=20$. The conditions $0 \\le 0$ and $20 \\ge 15$ are both satisfied. Thus, $1$ edit is required.\n\nFor test case $3$, the initial upper bound for glycolysis is $u_1=0$. This means $\\min(u_0, u_1)=0$. Consequently, $z_{\\mathrm{bm}}^*=0$ and $z_{\\mathrm{bf}}^*=0$, regardless of any other bounds. The only available edit affects the biomass reaction and does not change $u_1$. Therefore, it is impossible to achieve the biofuel target $\\tau_{\\mathrm{bf}}=1$, as the maximal biofuel production will always be $0$. The result is $-1$.\n\nThe other cases are resolved with similar logic. This systematic approach guarantees finding the minimum number of edits if a solution exists.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to define and solve all test cases for the FBA edit-minimization problem.\n    \"\"\"\n\n    # Shared stoichiometric matrix, objective vectors are implicit in the logic.\n    # S = np.array([[1, -1, 0, 0, 0], [0, 2, -1, -1, -1]])\n    # c_bm = np.array([0, 0, 1, 0, 0])\n    # c_bf = np.array([0, 0, 0, 1, 0])\n\n    test_cases = [\n        {\n            # Test case 1: general case\n            \"l\": np.array([0., 0., 0., 0., 0.]),\n            \"u\": np.array([10., 1000., 1000., 1000., 1000.]),\n            \"tau_bf\": 15.0,\n            \"tau_bm\": 0.0,\n            \"edits\": [(2, 0.0, 0.0)]\n        },\n        {\n            # Test case 2: requires multiple edits\n            \"l\": np.array([0., 0., 0., 0., 0.]),\n            \"u\": np.array([10., 1000., 1000., 0., 1000.]),\n            \"tau_bf\": 15.0,\n            \"tau_bm\": 0.0,\n            \"edits\": [(3, 0.0, 1000.0), (2, 0.0, 0.0)]\n        },\n        {\n            # Test case 3: impossible under given edits\n            \"l\": np.array([0., 0., 0., 0., 0.]),\n            \"u\": np.array([10., 0., 1000., 1000., 1000.]),\n            \"tau_bf\": 1.0,\n            \"tau_bm\": 0.0,\n            \"edits\": [(2, 0.0, 0.0)]\n        },\n        {\n            # Test case 4: zero edits suffice\n            \"l\": np.array([0., 0., 0., 0., 0.]),\n            \"u\": np.array([10., 1000., 0., 1000., 1000.]),\n            \"tau_bf\": 15.0,\n            \"tau_bm\": 0.0,\n            \"edits\": []\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_min_edits(case[\"l\"], case[\"u\"], case[\"edits\"], case[\"tau_bf\"], case[\"tau_bm\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_optima(l, u):\n    \"\"\"\n    Calculates the maximum biomass (v_2) and biofuel (v_3) fluxes\n    using an analytical solution derived from the network stoichiometry.\n\n    Args:\n        l (np.ndarray): Lower bounds for reaction fluxes.\n        u (np.ndarray): Upper bounds for reaction fluxes.\n\n    Returns:\n        tuple[float, float]: A tuple containing (max_biomass, max_biofuel).\n    \"\"\"\n    # From Sv=0, we have v_0 = v_1 and 2*v_1 = v_2 + v_3 + v_4.\n    # Max flux through glycolysis (v_1) is limited by glucose uptake (v_0).\n    v1_max = min(u[0], u[1])\n\n    # To maximize biomass (v_2), minimize competing fluxes v_3 and v_4 to their lower bounds.\n    # The problem specifies that all l_i are = 0.\n    max_v2 = min(u[2], max(0.0, 2 * v1_max - l[3] - l[4]))\n    \n    # To maximize biofuel (v_3), minimize competing fluxes v_2 and v_4 to their lower bounds.\n    max_v3 = min(u[3], max(0.0, 2 * v1_max - l[2] - l[4]))\n    \n    return max_v2, max_v3\n\ndef find_min_edits(l, u, edits, tau_bf, tau_bm):\n    \"\"\"\n    Finds the minimum number of edits required to satisfy the growth and biofuel targets.\n\n    Args:\n        l (np.ndarray): Initial lower bounds.\n        u (np.ndarray): Initial upper bounds.\n        edits (list): List of available edits as (reaction_index, new_l, new_u).\n        tau_bf (float): The target for minimum biofuel production.\n        tau_bm (float): The cap for maximum biomass production.\n\n    Returns:\n        int: The minimum number of edits, or -1 if impossible.\n    \"\"\"\n    # Check for k=0 edits\n    max_bm, max_bf = calculate_optima(l, u)\n    if max_bm = tau_bm and max_bf = tau_bf:\n        return 0\n\n    # Check for k  0 edits\n    for k in range(1, len(edits) + 1):\n        for edit_subset in itertools.combinations(edits, k):\n            # A valid subset of edits can only modify each reaction at most once.\n            edited_indices = [edit[0] for edit in edit_subset]\n            if len(edited_indices) != len(set(edited_indices)):\n                continue\n\n            # Apply the current subset of edits\n            l_prime, u_prime = l.copy(), u.copy()\n            for j, new_l, new_u in edit_subset:\n                l_prime[j] = new_l\n                u_prime[j] = new_u\n            \n            # Evaluate the system with the new bounds\n            max_bm_edited, max_bf_edited = calculate_optima(l_prime, u_prime)\n\n            # Check if conditions are met\n            if max_bm_edited = tau_bm and max_bf_edited = tau_bf:\n                return k\n\n    # If no combination of edits works, it's impossible.\n    return -1\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}