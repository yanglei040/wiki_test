{
    "hands_on_practices": [
        {
            "introduction": "任何古代DNA分析的第一步都是样本的真实性鉴定。古代DNA的标志性特征是在DNA片段末端存在着特定的损伤模式，尤其是胞嘧啶到胸腺嘧啶（$C \\to T$）的替换。本练习将引导你掌握一项核心的生物信息学技能：处理比对数据以量化这些损伤模式，这是验证古代样本真实性的关键步骤 。",
            "id": "2372718",
            "problem": "您的任务是实现一个程序，该程序从简化的、完全比对的读段中计算构成古代脱氧核糖核酸（DNA）分析中错配图（misincorporation plot）的原始数据，这些数据适用于模拟古代DNA损伤。在一个典型的二进制比对/图谱（BAM）文件中，读段与参考基因组之间的错配被用来量化替换频率，这些频率是关于读段$5'$端和$3'$端距离的函数。对于此问题，您将获得简化的比对记录来代替实际的BAM文件。每个比对记录包含三个字段：一个读段核苷酸字符串、一个等长的参考核苷酸字符串以及一个链指示符。这里只表示匹配和错配；没有缺口、插入或删除。\n\n待使用的定义：\n- 每个碱基是 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 中的一个。\n- 链是 $\\texttt{'+'}$ 或 $\\texttt{'-'}$。对于 $\\texttt{'+'}$ 链，$5'$ 端位于索引 $0$；对于 $\\texttt{'-'}$ 链，则位于索引 $L-1$，其中 $L$ 是读段长度。对于 $\\texttt{'+'}$ 链，$3'$ 端位于索引 $L-1$；对于 $\\texttt{'-'}$ 链，则位于索引 $0$。\n- 对于一个比对位置索引 $i$ ($0 \\le i \\le L-1$)，定义其到 $5'$ 端的距离为 $d_{5} = i$ (对于 $\\texttt{'+'}$ 链) 和 $d_{5} = L-1-i$ (对于 $\\texttt{'-'}$ 链)。定义其到 $3'$ 端的距离为 $d_{3} = L-1-i$ (对于 $\\texttt{'+'}$ 链) 和 $d_{3} = i$ (对于 $\\texttt{'-'}$ 链)。\n- 一个替换类型是一个有序对 $\\text{X}\\to\\text{Y}$，其中 $\\text{X},\\text{Y}\\in\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 且 $\\text{X}\\ne\\text{Y}$，它被解释为在同一比对位置上的参考碱基 $\\text{X}$ 和读段碱基 $\\text{Y}$。\n- 对于距 $5'$ 端（或 $3'$ 端）的每个距离 $d$，设 $N_{5}(d)$（或 $N_{3}(d)$）为所有读段中到该端距离等于 $d$ 且读段和参考碱基都在 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 内的比对位置总数。对于一个特定的替换类型 $\\text{X}\\to\\text{Y}$，设 $C^{\\text{X}\\to\\text{Y}}_{5}(d)$（或 $C^{\\text{X}\\to\\text{Y}}_{3}(d)$）为在距离 $d$ 处表现出该替换的此类位置的数量。定义在距 $5'$ 端距离 $d$ 处 $\\text{X}\\to\\text{Y}$ 的频率为 $f^{\\text{X}\\to\\text{Y}}_{5}(d) = C^{\\text{X}\\to\\text{Y}}_{5}(d) / N_{5}(d)$，类似地，$f^{\\text{X}\\to\\text{Y}}_{3}(d) = C^{\\text{X}\\to\\text{Y}}_{3}(d) / N_{3}(d)$。如果 $N_{5}(d) = 0$（或 $N_{3}(d) = 0$），则定义 $f^{\\text{X}\\to\\text{Y}}_{5}(d) = 0$（或 $f^{\\text{X}\\to\\text{Y}}_{3}(d) = 0$）。\n- 距离某端给定距离 $d$ 的总错配频率是 $f^{\\text{X}\\to\\text{Y}}_{\\cdot}(d)$ 在所有 $\\text{X}\\ne\\text{Y}$ 的替换类型 $\\text{X}\\to\\text{Y}$ 上的总和，其中 $\\cdot$ 表示 $5$ 或 $3$。\n\n您的程序必须根据提供的比对记录测试集，计算所有12种可能的替换类型的错配频率，这些频率是如上定义的 $d_{5}$ 和 $d_{3}$ 的函数。然后，为每个测试用例提取如下所述的特定标量值，并将所有结果打印在单行中。\n\n测试集（三个独立的数据集），其中每个比对记录是一个三元组 $(\\text{read}, \\text{ref}, \\text{strand})$：\n\n- 测试用例 1 (在末端附近有错配的一般情况)：\n  1. $(\\text{TAGTC}, \\text{CAGTC}, \\texttt{'+'})$\n  2. $(\\text{GGCCT}, \\text{GGCCC}, \\texttt{'-'})$\n  3. $(\\text{ATCGA}, \\text{ATCGG}, \\texttt{'+'})$\n  4. $(\\text{ATTTA}, \\text{GTTTA}, \\texttt{'-'})$\n\n- 测试用例 2 (在较大距离上无覆盖的边界条件)：\n  1. $(\\text{CAGT}, \\text{CAGT}, \\texttt{'+'})$\n  2. $(\\text{TGCA}, \\text{TGCA}, \\texttt{'-'})$\n\n- 测试用例 3 (无错配的边缘情况)：\n  1. $(\\text{ACGT}, \\text{ACGT}, \\texttt{'+'})$\n  2. $(\\text{GGGG}, \\text{GGGG}, \\texttt{'-'})$\n\n需要计算和报告的输出，按此确切顺序，以实数形式：\n- 来自测试用例 1：\n  1. $f^{\\text{C}\\to\\text{T}}_{5}(0)$。\n  2. $f^{\\text{G}\\to\\text{A}}_{3}(0)$。\n  3. 在 $5'$ 端距离 $0$ 处的总错配频率，即 $\\sum_{\\text{X}\\ne\\text{Y}} f^{\\text{X}\\to\\text{Y}}_{5}(0)$。\n\n- 来自测试用例 2：\n  4. $f^{\\text{C}\\to\\text{T}}_{5}(10)$。\n\n- 来自测试用例 3：\n  5. 在 $5'$ 端距离 $0$ 处的总错配频率。\n  6. $f^{\\text{G}\\to\\text{A}}_{3}(0)$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[\\text{result}_{1},\\text{result}_{2},\\dots]$）。不涉及任何物理单位。所有数值必须以十进制数输出。如果分母 $N_{5}(d)$ 或 $N_{3}(d)$ 等于 $0$，根据定义，相应的频率必须报告为 $0$。",
            "solution": "问题陈述经过了严格验证，并被确定是合理的。这是一个计算生物学领域中适定且有科学依据的问题，具体涉及古代DNA损伤模式的分析。所有定义在数学上都是精确的，所提供的数据是一致的，目标是明确的。任务是形式化并实现一个标准算法，用于从简化的比对数据中量化核苷酸错配频率。\n\n该解决方案通过一个系统的、两阶段的计算过程来实现。第一阶段涉及从原始比对数据中聚合计数。第二阶段根据这些聚合计数计算所需的频率。\n\n**1. 用于计数聚合的数据结构**\n\n为了高效地存储必要的计数，我们采用了两个主要的数据结构，一个用于 $5'$ 端，另一个用于 $3'$ 端。每个结构都是一个字典，它将整数距离 $d$ 映射到一个聚合数据记录。该记录包含两个组成部分：\n- 一个标量整数 $N(d)$，表示在距相应末端距离 $d$ 处观察到的核苷酸位置总数。\n- 一个 $4 \\times 4$ 矩阵 $C(d)$，其中条目 $C_{\\text{X},\\text{Y}}(d)$ 存储了在距离 $d$ 处观察到从参考碱基 $\\text{X}$ 到读段碱基 $\\text{Y}$ 的替换次数。对于此矩阵表示，碱基 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 被映射到索引 $\\{0, 1, 2, 3\\}$。\n\n我们将这些结构表示为 $\\mathcal{D}_5$ 和 $\\mathcal{D}_3$。因此，对于距 $5'$ 端的距离 $d$，相应的条目是 $\\mathcal{D}_5[d] = (N_5(d), C_5(d))$。\n\n**2. 算法流程**\n\n**阶段 1：计数聚合**\n算法遍历每个提供的比对记录，即一个（读段序列、参考序列、链）的三元组。对于比对中的每个位置 $i$（从 $0$ 到 $L-1$，其中 $L$ 是读段长度），执行以下步骤：\n1. 根据位置 $i$ 和链的方向计算到 $5'$ 端和 $3'$ 端的距离 $d_5$ 和 $d_3$。\n   - 对于 $\\texttt{'+'}$ 链读段：$d_5 = i$ 和 $d_3 = L-1-i$。\n   - 对于 $\\texttt{'-'}$ 链读段：$d_5 = L-1-i$ 和 $d_3 = i$。\n2. 针对计算出的距离增加总碱基计数：$N_5(d_5) \\mathrel{+}= 1$ 和 $N_3(d_3) \\mathrel{+}= 1$。\n3. 比较位置 $i$ 处的参考碱基 $\\text{X}$ 和读段碱基 $\\text{Y}$。如果它们不同 ($\\text{X} \\neq \\text{Y}$)，则表示发生了一次替换。矩阵 $C_5(d_5)$ 和 $C_3(d_3)$ 中相应的替换计数器将增加。具体来说，$C_{5, \\text{X},\\text{Y}}(d_5) \\mathrel{+}= 1$ 和 $C_{3, \\text{X},\\text{Y}}(d_3) \\mathrel{+}= 1$。\n\n在遍历完所有读段的所有位置后，字典 $\\mathcal{D}_5$ 和 $\\mathcal{D}_3$ 包含了计算频率所需的完整聚合计数。\n\n**阶段 2：频率计算**\n有了聚合计数，任何指定的频率都可以直接根据其定义进行计算。\n- 在距 $5'$ 端距离 $d$ 处，特定替换 $\\text{X}\\to\\text{Y}$ 的频率由以下公式给出：\n  $$f^{\\text{X}\\to\\text{Y}}_{5}(d) = \\frac{C_{5, \\text{X},\\text{Y}}(d)}{N_5(d)}$$\n  类似的公式适用于 $3'$ 端。根据规定，如果 $N_5(d) = 0$（或 $N_3(d)=0$），则频率定义为 $0$。\n- 在距离 $d$ 处的总错配频率是该距离处所有单个替换频率的总和：\n  $$\\sum_{\\text{X}\\ne\\text{Y}} f^{\\text{X}\\to\\text{Y}}_{5}(d) = \\frac{\\sum_{\\text{X}\\ne\\text{Y}} C_{5, \\text{X},\\text{Y}}(d)}{N_5(d)}$$\n  这等同于在距离 $d$ 处观察到的错配总数除以在相同距离处观察到的碱基总数。\n\n**测试用例 1 的计算示例**\n让我们从测试用例 1 计算第一个所需值 $f^{\\text{C}\\to\\text{T}}_{5}(0)$。\n相关距离是 $d_5=0$。我们必须首先找到 $N_5(0)$ 和 $C_{5, \\text{C},\\text{T}}(0)$。我们检查 4 个读段中每一个对这个距离的贡献。\n- 读段 1：$(\\text{TAGTC}, \\text{CAGTC}, \\texttt{'+'})$。链是 $\\texttt{'+'}$，所以 $d_5=0$ 对应于索引 $i=0$。在 $i=0$ 处，我们有 ref='C', read='T'，一次 $\\text{C}\\to\\text{T}$ 替换。\n- 读段 2：$(\\text{GGCCT}, \\text{GGCCC}, \\texttt{'-'})$。链是 $\\texttt{'-'}$，所以 $d_5=0$ 对应于索引 $i=L-1=4$。在 $i=4$ 处，我们有 ref='C', read='T'，一次 $\\text{C}\\to\\text{T}$ 替换。\n- 读段 3：$(\\text{ATCGA}, \\text{ATCGG}, \\texttt{'+'})$。链是 $\\texttt{'+'}$，$d_5=0$ 对应于 $i=0$。在 $i=0$ 处，我们有 ref='A', read='A'，一个匹配。\n- 读段 4：$(\\text{ATTTA}, \\text{GTTTA}, \\texttt{'-'})$。链是 $\\texttt{'-'}$，$d_5=0$ 对应于索引 $i=L-1=4$。在 $i=4$ 处，我们有 ref='A', read='A'，一个匹配。\n\n从此分析中：\n- 在距离 $d_5=0$ 处的位置总数是 $N_5(0) = 4$。\n- 在此距离处的 $\\text{C}\\to\\text{T}$ 替换总数是 $C_{5, \\text{C},\\text{T}}(0) = 2$。\n\n因此，频率是：\n$$f^{\\text{C}\\to\\text{T}}_{5}(0) = \\frac{C_{5, \\text{C},\\text{T}}(0)}{N_5(0)} = \\frac{2}{4} = 0.5$$\n\n其他所需值是通过将相同的严谨过程应用于相应的测试用例和参数来计算的。这种有原则的方法确保了正确性和可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the ancient DNA damage modeling problem by computing misincorporation frequencies.\n    \"\"\"\n    \n    BASE_TO_IDX = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    def compute_counts(records):\n        \"\"\"\n        Aggregates base and substitution counts from alignment records.\n\n        Args:\n            records: A list of tuples, where each tuple is (read_str, ref_str, strand_char).\n\n        Returns:\n            A tuple of two dictionaries (counts_5, counts_3).\n            Each dictionary maps distance `d` to a tuple `(N, C)`, where `N` is the\n            total base count and `C` is a 4x4 numpy array of substitution counts.\n        \"\"\"\n        counts_5 = defaultdict(lambda: [0, np.zeros((4, 4), dtype=int)])\n        counts_3 = defaultdict(lambda: [0, np.zeros((4, 4), dtype=int)])\n\n        for read, ref, strand in records:\n            read_len = len(read)\n            for i in range(read_len):\n                if strand == '+':\n                    d5 = i\n                    d3 = read_len - 1 - i\n                else:  # strand == '-'\n                    d5 = read_len - 1 - i\n                    d3 = i\n\n                ref_base = ref[i]\n                read_base = read[i]\n\n                # Update 5-prime counts\n                counts_5[d5][0] += 1\n                if ref_base != read_base:\n                    ref_idx = BASE_TO_IDX[ref_base]\n                    read_idx = BASE_TO_IDX[read_base]\n                    counts_5[d5][1][ref_idx, read_idx] += 1\n\n                # Update 3-prime counts\n                counts_3[d3][0] += 1\n                if ref_base != read_base:\n                    ref_idx = BASE_TO_IDX[ref_base]\n                    read_idx = BASE_TO_IDX[read_base]\n                    counts_3[d3][1][ref_idx, read_idx] += 1\n        \n        return dict(counts_5), dict(counts_3)\n\n    test_cases = [\n        # Test case 1\n        [\n            ('TAGTC', 'CAGTC', '+'),\n            ('GGCCT', 'GGCCC', '-'),\n            ('ATCGA', 'ATCGG', '+'),\n            ('ATTTA', 'GTTTA', '-')\n        ],\n        # Test case 2\n        [\n            ('CAGT', 'CAGT', '+'),\n            ('TGCA', 'TGCA', '-')\n        ],\n        # Test case 3\n        [\n            ('ACGT', 'ACGT', '+'),\n            ('GGGG', 'GGGG', '-')\n        ]\n    ]\n\n    results = []\n\n    # Process Test Case 1\n    counts_5_1, counts_3_1 = compute_counts(test_cases[0])\n    \n    # 1. f_C->T_5(0) for test case 1\n    n5_d0, c5_d0 = counts_5_1.get(0, (0, None))\n    if n5_d0 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['C'], BASE_TO_IDX['T']\n        res1 = c5_d0[ref_idx, read_idx] / n5_d0\n    else:\n        res1 = 0.0\n    results.append(res1)\n    \n    # 2. f_G->A_3(0) for test case 1\n    n3_d0, c3_d0 = counts_3_1.get(0, (0, None))\n    if n3_d0 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['G'], BASE_TO_IDX['A']\n        res2 = c3_d0[ref_idx, read_idx] / n3_d0\n    else:\n        res2 = 0.0\n    results.append(res2)\n\n    # 3. Total mismatch frequency at 5' distance 0 for test case 1\n    if n5_d0 > 0:\n        total_mismatches = c5_d0.sum()\n        res3 = total_mismatches / n5_d0\n    else:\n        res3 = 0.0\n    results.append(res3)\n\n    # Process Test Case 2\n    counts_5_2, _ = compute_counts(test_cases[1])\n    \n    # 4. f_C->T_5(10) for test case 2\n    n5_d10, c5_d10 = counts_5_2.get(10, (0, None))\n    if n5_d10 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['C'], BASE_TO_IDX['T']\n        res4 = c5_d10[ref_idx, read_idx] / n5_d10\n    else:\n        res4 = 0.0\n    results.append(res4)\n\n    # Process Test Case 3\n    counts_5_3, counts_3_3 = compute_counts(test_cases[2])\n    \n    # 5. Total mismatch frequency at 5' distance 0 for test case 3\n    n5_d0_3, c5_d0_3 = counts_5_3.get(0, (0, None))\n    if n5_d0_3 > 0:\n        total_mismatches_3 = c5_d0_3.sum()\n        res5 = total_mismatches_3 / n5_d0_3\n    else:\n        res5 = 0.0\n    results.append(res5)\n\n    # 6. f_G->A_3(0) for test case 3\n    n3_d0_3, c3_d0_3 = counts_3_3.get(0, (0, None))\n    if n3_d0_3 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['G'], BASE_TO_IDX['A']\n        res6 = c3_d0_3[ref_idx, read_idx] / n3_d0_3\n    else:\n        res6 = 0.0\n    results.append(res6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.1f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确认DNA损伤后，一个常见的处理策略是切除测序读段两端错误率较高的区域。然而，这个操作需要在“移除错误”和“保留有价值的序列信息”之间做出权衡。本练习要求你通过数学建模来分析这一权衡，并找到最优的切除长度，从而体验计算模型如何被用于优化古基因组学的数据处理流程 。",
            "id": "2691922",
            "problem": "给定一个关于古DNA末端损伤和读段修剪的数学模型。目标是选择一个整数修剪长度 $k$（单位为碱基对），从每条读段的两端移除，以最大化一个在保留真实单核苷酸多态性（SNPs）和避免损伤驱动的错误之间进行权衡的原则性目标。平均片段长度固定为 $45$ 个碱基对。\n\n基础建模假设和定义（所有参数均为非负数，且在古DNA分析和古基因组学中具有科学合理性）：\n\n- 末端损伤模型：距离读段末端位置为 $i$ 的碱基，其损伤的单位碱基概率呈指数衰减，即 $d(i) = d_{0} \\exp(-\\alpha i)$，其中 $i \\in \\{1,2,\\dots\\}$，$d_{0} \\in [0,1)$ 是末端损伤振幅，$\\alpha > 0$ 是衰减率。\n- 双末端损伤近似：对于一个长度为 $L$ 的片段中距离左端为 $j$ 的碱基，其损伤概率近似为来自两端的独立贡献之和（在小概率情况下，此方法在古DNA领域广泛使用），因此保留碱基的损伤概率近似为 $d_{0}\\exp(-\\alpha j) + d_{0}\\exp(-\\alpha (L-j+1))$。\n- 修剪：对每个片段的两端应用一个固定的整数 $k \\ge 0$；仅保留位置 $j \\in \\{k+1, k+2, \\dots, L-k\\}$。如果 $L \\le 2k$，则该片段不贡献任何保留位置。\n- 片段长度分布：读段长度 $L$ 被建模为在 $\\{1,2,\\dots\\}$ 上均值为 $\\mu = 45$ 的几何分布。这意味着 $P(L=\\ell) = q (1-q)^{\\ell - 1}$，其中 $q = 1/\\mu = 1/45$ 且 $1-q = 44/45$。\n- 真实变异密度：令 $p_{s} \\in [0,1]$ 为一个基因组位置是真实SNP（单核苷酸多态性）的单位碱基概率，视为与损伤无关。\n- 错误成本权重：令 $\\beta > 0$ 量化一个损伤驱动的错误相对于一个保留的真实SNP奖励的惩罚。目标函数应随保留的真实SNP数量增加而增加，随损伤驱动的错误的期望值增加而减少。\n\n仅使用这些假设和标准概率规则（期望的线性性、小概率的独立性近似），按以下步骤进行：\n\n1. 推导修剪 $k$ 后每个片段保留位置的期望数量的表达式，记为 $E[(L - 2k)_{+}]$，其中 $(x)_{+} = \\max\\{x,0\\}$。用 $q$ 和 $k$ 表示该期望值。\n2. 通过对保留索引上的双末端单位碱基损伤概率求和，并对 $L$ 的几何分布取期望，推导每个片段所有保留位置上的总期望损伤概率质量的表达式，该表达式是关于 $k$、$d_{0}$ 和 $\\alpha$ 的函数。\n3. 定义一个标量目标函数 $F(k)$，即保留的真实SNP的期望数量减去加权的损伤驱动错误的期望数量，即\n   $$F(k) = p_{s} \\,\\mathbb{E}\\big[(L - 2k)_{+}\\big] \\;-\\; \\beta \\,\\mathbb{E}\\big[\\text{total damage over retained positions}\\big].$$\n   您必须使用步骤1和2中推导出的期望来评估任何给定参数集的 $F(k)$。\n4. 对于下面测试套件中的每个参数集，计算使 $F(k)$ 最大化的整数 $k^{\\ast} \\in \\{0,1,2,\\dots\\}$。如果在数值容差范围内有多个 $k$ 达到相同的 $F(k)$ 最大值，选择最小的那个 $k$。\n5. 单位和格式：$k^{\\ast}$ 必须以碱基对为单位报告，形式为非负整数（输出中不要附加任何单位符号）。不涉及角度。像 $p_{s}$ 这样的量必须解释为小数，而不是百分比。\n\n您必须实现一个程序，该程序完全按照定义评估 $F(k)$，并在 $k \\in \\{0,1,2,\\dots,K_{\\max}\\}$ 的范围内进行搜索，其中 $K_{\\max}$ 是一个固定的足够大的上界，以确保在实践中 argmax 的收敛。使用 $K_{\\max} = 80$。\n\n测试套件（所有情况下平均长度 $\\mu = 45$ 固定；每个元组为 $(d_{0}, \\alpha, p_{s}, \\beta)$）：\n\n- 情况1：$(0.3, 0.5, 0.001, 0.05)$\n- 情况2：$(0.05, 0.5, 0.001, 0.05)$\n- 情况3：$(0.3, 1.2, 0.001, 0.05)$\n- 情况4：$(0.3, 0.5, 0.001, 0.2)$\n- 情况5：$(0.3, 0.5, 0.00001, 0.05)$\n\n您的程序应生成单行输出，其中包含五个最优修剪长度，形式为逗号分隔的列表，并用方括号括起来（例如，“[3,0,1,5,2]”）。仅打印此行。输出值必须是整数。修剪长度 $k$ 的单位是碱基对（bp）。",
            "solution": "该问题陈述科学严谨、定义明确且客观。它代表了古基因组学领域中一个简化但标准的定量问题，特别是关于古DNA的分析。DNA损伤模型和片段长度的统计分布是实践中使用的合理近似。目标函数提供了一种原则性的方法，来权衡保留有用遗传信息（单核苷酸多态性，即SNPs）和过滤掉人为产物（损伤引起的错误）之间的利弊。所有参数都已定义，目标是一个明确的优化任务。因此，该问题是有效的，我们可以进行形式化的推导和求解。\n\n目标是找到一个整数修剪长度 $k \\ge 0$，使得函数最大化：\n$$F(k) = p_{s} \\,\\mathbb{E}\\big[(L - 2k)_{+}\\big] \\;-\\; \\beta \\,\\mathbb{E}\\big[\\text{total damage over retained positions}\\big]$$\n其中 $(x)_{+} = \\max\\{x,0\\}$。这需要推导两个期望值作为 $k$ 的函数。\n\n首先，我们推导保留碱基对的期望数量的表达式，$\\mathbb{E}\\big[(L - 2k)_{+}\\big]$。片段长度 $L$ 服从集合 $\\{1, 2, 3, \\dots\\}$ 上的几何分布，均值为 $\\mu = 45$。其概率质量函数为 $P(L=\\ell) = q(1-q)^{\\ell-1}$，对于 $\\ell \\ge 1$，其中 $q = 1/\\mu = 1/45$。令 $p = 1-q$。如果 $\\ell > 2k$，保留的碱基数量为 $\\ell-2k$，否则为 $0$。\n因此，期望值为：\n$$\n\\mathbb{E}\\big[(L - 2k)_{+}\\big] = \\sum_{\\ell=1}^{\\infty} (\\ell-2k)_{+} P(L=\\ell) = \\sum_{\\ell=2k+1}^{\\infty} (\\ell-2k) q p^{\\ell-1}\n$$\n我们可以通过重新索引来计算这个和。令 $j = \\ell - (2k+1)$，这意味着 $\\ell = j+2k+1$ 和 $\\ell-2k = j+1$。求和变为：\n$$\n\\mathbb{E}\\big[(L - 2k)_{+}\\big] = q p^{2k} \\sum_{j=0}^{\\infty} (j+1) p^j\n$$\n和 $\\sum_{j=0}^{\\infty} (j+1) p^j$ 是几何级数分析中的一个已知结果，其值为 $1/(1-p)^2 = 1/q^2$。将其代回，我们得到：\n$$\n\\mathbb{E}\\big[(L - 2k)_{+}\\big] = q p^{2k} \\frac{1}{q^2} = \\frac{p^{2k}}{q} = \\frac{(1-q)^{2k}}{q}\n$$\n这是我们目标函数的第一个组成部分。\n\n其次，我们推导所有保留位置上的总期望损伤。在一个长度为 $L$ 的片段中，位置 $j$ 的单位碱基损伤概率由 $d(j, L) = d_0 \\exp(-\\alpha j) + d_0 \\exp(-\\alpha (L-j+1))$ 给出。保留的位置是从 $k+1$ 到 $L-k$。对于一个长度为 $L$ 的片段，我们记其总损伤为 $D_k(L)$，即在这些位置上的和，这在 $L \\ge 2k+1$ 时有效：\n$$\nD_k(L) = \\sum_{j=k+1}^{L-k} \\left( d_0 e^{-\\alpha j} + d_0 e^{-\\alpha (L-j+1)} \\right)\n$$\n由于求和指数的对称性，和中的两项相等。因此：\n$$\nD_k(L) = 2 d_0 \\sum_{j=k+1}^{L-k} e^{-\\alpha j} \\quad (\\text{对于 } L \\ge 2k+1)\n$$\n我们需要计算其期望，$\\mathbb{E}[D_k(L)] = \\sum_{\\ell=2k+1}^{\\infty} D_k(\\ell) P(L=\\ell)$。\n$$\n\\mathbb{E}[D_k(L)] = \\sum_{\\ell=2k+1}^{\\infty} \\left( 2 d_0 \\sum_{j=k+1}^{\\ell-k} e^{-\\alpha j} \\right) q p^{\\ell-1}\n$$\n我们可以改变求和顺序。求和区域由 $j \\ge k+1$ 和 $\\ell \\ge j+k$ 定义。\n$$\n\\mathbb{E}[D_k(L)] = 2 d_0 q \\sum_{j=k+1}^{\\infty} e^{-\\alpha j} \\left( \\sum_{\\ell=j+k}^{\\infty} p^{\\ell-1} \\right)\n$$\n内层和是一个几何级数尾部：$\\sum_{\\ell=j+k}^{\\infty} p^{\\ell-1} = p^{j+k-1} / (1-p) = p^{j+k-1} / q$。\n将此代入主表达式中得到：\n$$\n\\mathbb{E}[D_k(L)] = 2 d_0 q \\sum_{j=k+1}^{\\infty} e^{-\\alpha j} \\frac{p^{j+k-1}}{q} = 2 d_0 p^{k-1} \\sum_{j=k+1}^{\\infty} (p e^{-\\alpha})^j\n$$\n剩下的和是一个几何级数：$\\sum_{j=k+1}^{\\infty} (p e^{-\\alpha})^j = \\frac{(p e^{-\\alpha})^{k+1}}{1 - p e^{-\\alpha}}$。\n将这些部分组合起来，我们得到总期望损伤的最终表达式：\n$$\n\\mathbb{E}[D_k(L)] = 2 d_0 p^{k-1} \\frac{p^{k+1} e^{-\\alpha(k+1)}}{1 - p e^{-\\alpha}} = \\frac{2 d_0 p^{2k} e^{-\\alpha(k+1)}}{1 - p e^{-\\alpha}}\n$$\n代入 $p=1-q$：\n$$\n\\mathbb{E}[\\text{total damage}] = \\frac{2 d_0 (1-q)^{2k} e^{-\\alpha(k+1)}}{1 - (1-q)e^{-\\alpha}}\n$$\n\n推导出两个期望后，我们现在可以写出完整的目标函数 $F(k)$：\n$$\nF(k) = p_s \\frac{(1-q)^{2k}}{q} - \\beta \\frac{2 d_0 (1-q)^{2k} e^{-\\alpha(k+1)}}{1 - (1-q)e^{-\\alpha}}\n$$\n提出公因式 $(1-q)^{2k}$：\n$$\nF(k) = (1-q)^{2k} \\left( \\frac{p_s}{q} - \\frac{2 \\beta d_0 e^{-\\alpha} e^{-\\alpha k}}{1 - (1-q)e^{-\\alpha}} \\right)\n$$\n必须在非负整数 $k \\in \\{0, 1, 2, \\dots\\}$ 上最大化此函数。当 $k \\to \\infty$ 时，$(1-q)^{2k}$ 和 $e^{-\\alpha k}$ 两项都趋于零，确保 $F(k) \\to 0$。由于 $F(k)$ 并非总是为零，因此必然存在一个最大值。我们将通过在足够大的 $k$ 范围内进行搜索来找到最优值 $k^*$。问题指定了搜索范围为 $k \\in \\{0, 1, \\dots, 80\\}$，考虑到所涉及的衰减率，这个范围是足够的。问题还规定，如果 $F(k)$ 的最大值出现平局，应选择最小的 $k$。我们的算法通过保留找到的第一个最优 $k$ 来自然地遵守这一规定。\n\n为每个参数集找到 $k^*$ 的算法如下：\n1. 定义常数：平均片段长度 $\\mu=45$，概率 $q=1/45$。\n2. 对每组参数 $(d_0, \\alpha, p_s, \\beta)$：\n3. 初始化 `max_F` 为一个非常小的数（例如，负无穷大），`optimal_k` 为 $0$。\n4. 从 $0$ 到 $K_{\\max}=80$ 迭代 $k$。\n5. 在每次迭代中，使用推导出的公式计算 $F(k)$。\n6. 如果计算出的 $F(k)$ 大于当前的 `max_F`，则将 `max_F` 更新为 $F(k)$，并将 `optimal_k` 更新为当前的 $k$。\n7. 循环完成后，为给定参数找到一个 `optimal_k`。\n8. 为每个测试用例存储此整数结果。\n这个过程将在下面的Python程序中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal trimming length k* for ancient DNA reads.\n\n    The function iterates through a set of predefined test cases. For each case,\n    it calculates an objective function F(k) over a range of possible integer\n    trimming lengths k. The k that maximizes F(k) is chosen as the optimal\n    value k*.\n\n    The objective function F(k) is derived from a model of ancient DNA damage\n    and balances retaining true genetic variants (SNPs) against introducing\n    damage-related errors. It is defined as:\n\n    F(k) = p_s * E[retained length] - beta * E[total damage]\n\n    where the expectations are taken over a geometric distribution of DNA\n    fragment lengths. The analytical form derived is:\n\n    F(k) = (1-q)**(2*k) * (p_s/q - (2*beta*d0*exp(-alpha)*exp(-alpha*k)) /\n                                   (1 - (1-q)*exp(-alpha)))\n    \"\"\"\n    # Fixed parameters from the problem statement\n    mean_length = 45.0\n    q = 1.0 / mean_length\n    p = 1.0 - q\n    K_max = 80\n\n    # Test suite: each tuple is (d0, alpha, ps, beta)\n    test_cases = [\n        (0.3, 0.5, 0.001, 0.05),\n        (0.05, 0.5, 0.001, 0.05),\n        (0.3, 1.2, 0.001, 0.05),\n        (0.3, 0.5, 0.001, 0.2),\n        (0.3, 0.5, 0.00001, 0.05),\n    ]\n\n    optimal_k_results = []\n\n    for d0, alpha, ps, beta in test_cases:\n        max_F = -np.inf\n        optimal_k = 0\n\n        # Pre-calculate parts of the F(k) expression that are constant over k\n        term1 = ps / q\n        e_neg_alpha = np.exp(-alpha)\n        term2_numerator = 2 * beta * d0 * e_neg_alpha\n        term2_denominator = 1 - p * e_neg_alpha\n        term2_const = term2_numerator / term2_denominator\n\n        p_pow_2k = 1.0\n        e_pow_neg_alpha_k = 1.0\n        p_squared = p**2\n        \n        # Search for k* in the range [0, K_max]\n        for k in range(K_max + 1):\n            # Calculate F(k)\n            # F(k) = p**(2*k) * (term1 - term2_const * np.exp(-alpha * k))\n            # Iterative update is more efficient than repeated power/exp calls\n            F_k = p_pow_2k * (term1 - term2_const * e_pow_neg_alpha_k)\n\n            # Update optimal_k if a new maximum is found.\n            # The strict inequality '>' ensures the smallest k is chosen in case of a tie.\n            if F_k > max_F:\n                max_F = F_k\n                optimal_k = k\n            \n            # Update terms for next iteration\n            p_pow_2k *= p_squared\n            e_pow_neg_alpha_k *= e_neg_alpha\n\n        optimal_k_results.append(optimal_k)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, optimal_k_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与其简单地切除数据，一种更强大的方法是在我们的统计模型中明确地考虑损伤。贝叶斯推断使我们能够将关于损伤过程的先验知识（似然）与观测数据相结合，从而推断出真实的原始序列（后验概率）。在本练习中，你将亲手实现一个简化的、能够感知损伤的基因型确定算法，深入了解现代古基因组学工具如何从受损的DNA中获得更准确的分析结果 。",
            "id": "2372702",
            "problem": "基于一个简单的生成模型，实现一个用于古代脱氧核糖核酸（aDNA）的、能感知损伤的共有碱基确定程序。在单个基因组位置，给定四种核苷酸——腺嘌呤、胞嘧啶、鸟嘌呤和胸腺嘧啶——的观测读段计数（按此顺序），以及两个参数：基线测序错误率和固定的胞嘧啶到胸腺嘧啶的损伤率。假设如下：\n\n- 该位置的真实碱基用 $B \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 表示，是未知的，并且具有均匀先验概率 $P(B=\\mathrm{A})=P(B=\\mathrm{C})=P(B=\\mathrm{G})=P(B=\\mathrm{T})=\\frac{1}{4}$。\n- 在给定 $B$ 的条件下，各个读段中观测到的碱基调用是从一个分类分布中抽取的独立同分布样本，该分布的参数是特定于碱基的发射概率。\n- 设基线测序错误率为 $\\epsilon \\in [0,1)$ ，固定的胞嘧啶到胸腺嘧啶的损伤率为 $\\delta \\in [0,1-\\epsilon]$。\n- 对于 $B \\neq \\mathrm{C}$，发射概率如下：正确碱基的发射概率为 $1-\\epsilon$，其余三种错误碱基的发射概率均为 $\\epsilon/3$。\n- 对于 $B=\\mathrm{C}$，损伤将报告为 $\\mathrm{T}$ 的概率从 $\\epsilon/3$ 增加到 $\\delta+\\epsilon/3$，同时降低了正确发射 $\\mathrm{C}$ 的概率，以确保总概率和为 1。因此，当 $B=\\mathrm{C}$ 时：$P(\\mathrm{C}|\\mathrm{C})=1-(\\epsilon+\\delta)$，$P(\\mathrm{T}|\\mathrm{C})=\\delta+\\epsilon/3$，以及 $P(\\mathrm{A}|\\mathrm{C})=P(\\mathrm{G}|\\mathrm{C})=\\epsilon/3$。\n\n给定观测计数 $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$，将候选真实碱基 $b$ 下的数据似然视为一个多项式模型，其参数由 $b$ 对应的发射概率确定。使用均匀先验，通过贝叶斯法则（Bayes' rule）计算 $b \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 上的后验概率 $P(B=b \\mid \\mathbf{c}, \\epsilon, \\delta)$。共有碱基是使该后验概率最大化的碱基 $b$。如果出现精确的平局（即后验概率值在 $10^{-12}$ 的绝对容差范围内相等），则根据映射关系 $\\mathrm{A} \\mapsto 0$, $\\mathrm{C} \\mapsto 1$, $\\mathrm{G} \\mapsto 2$, $\\mathrm{T} \\mapsto 3$ 选择索引最小的碱基。\n\n您的程序必须从第一性原理出发实现此模型，并为每个测试用例输出：\n- 使用上述映射的共有碱基索引（整数），以及\n- 该共有碱基的后验概率，以四舍五入到 $6$ 位小数的小数形式表示。\n\n如果总读段计数为零，即 $c_{\\mathrm{A}}+c_{\\mathrm{C}}+c_{\\mathrm{G}}+c_{\\mathrm{T}}=0$，则后验概率是均匀的，每个碱基均为 $1/4$；此时应用上述的平局打破规则。\n\n测试套件：\n使用以下测试用例，每个用例指定为 $\\left(\\mathbf{c}, \\epsilon, \\delta\\right)$，其中 $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$。\n\n1. $\\left((2,8,1,5),\\, 0.01,\\, 0.20\\right)$\n2. $\\left((0,0,0,0),\\, 0.01,\\, 0.20\\right)$\n3. $\\left((0,0,0,10),\\, 0.01,\\, 0.30\\right)$\n4. $\\left((0,3,0,7),\\, 0.01,\\, 0.25\\right)$\n5. $\\left((1,1,1,1),\\, 0.01,\\, 0.20\\right)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并保持上述顺序。每个条目必须是形式为 $\\left[\\text{call\\_index}, \\text{posterior\\_rounded}\\right]$ 的双元素列表，其中 $\\text{call\\_index}$ 是一个整数，$\\text{posterior\\_rounded}$ 是一个四舍五入到 6 位小数的十进制数。全部输出必须是一个用方括号括起来的、以逗号分隔的列表，例如：$[[0,0.500000],[3,0.875000],\\dots]$。",
            "solution": "我们将该问题转化为一个规范的概率推断任务。设观测计数为 $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$，总数为 $N=c_{\\mathrm{A}}+c_{\\mathrm{C}}+c_{\\mathrm{G}}+c_{\\mathrm{T}}$。设基线测序错误率为 $\\epsilon \\in [0,1)$，固定的胞嘧啶到胸腺嘧啶的损伤率为 $\\delta \\in [0,1-\\epsilon]$。真实碱基 $B$ 具有均匀先验 $P(B=b)=\\frac{1}{4}$，适用于所有 $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。\n\n根据模型：\n- 对于 $b \\in \\{\\mathrm{A},\\mathrm{G},\\mathrm{T}\\}$，发射概率为\n$$\nP(\\mathrm{A}\\mid b)=\\begin{cases}\n1-\\epsilon  \\text{if } b=\\mathrm{A}\\\\\n\\epsilon/3  \\text{if } b\\neq \\mathrm{A}\n\\end{cases},\\quad\nP(\\mathrm{C}\\mid b)=\\begin{cases}\n1-\\epsilon  \\text{if } b=\\mathrm{C}\\\\\n\\epsilon/3  \\text{if } b\\neq \\mathrm{C}\n\\end{cases},\n$$\n对于 $\\mathrm{G}$ 和 $\\mathrm{T}$ 情况类似，正确碱基的概率为 $1-\\epsilon$，每个错误碱基的概率为 $\\epsilon/3$。\n- 对于 $b=\\mathrm{C}$，损伤修改了两个条目：\n$$\nP(\\mathrm{C}\\mid \\mathrm{C})=1-(\\epsilon+\\delta),\\quad\nP(\\mathrm{T}\\mid \\mathrm{C})=\\delta+\\epsilon/3,\\quad\nP(\\mathrm{A}\\mid \\mathrm{C})=\\epsilon/3,\\quad\nP(\\mathrm{G}\\mid \\mathrm{C})=\\epsilon/3.\n$$\n根据构造，如果 $\\delta \\in [0,1-\\epsilon]$，这些概率是非负的，并且总和为 1。\n\n给定 $b$，观测到 $\\mathbf{c}$ 的似然是多项式的：\n$$\n\\mathcal{L}(\\mathbf{c} \\mid B=b) \\propto \\prod_{x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} P(x\\mid b)^{c_x}.\n$$\n多项式系数不依赖于 $b$，在后验比率中会被抵消。在均匀先验下，未归一化的后验概率与似然成正比。因此，\n$$\nP(B=b \\mid \\mathbf{c},\\epsilon,\\delta) = \\frac{\\prod_{x} P(x\\mid b)^{c_x}}{\\sum_{b' \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} \\prod_{x} P(x\\mid b')^{c_x}}.\n$$\n为了数值稳定性和处理极小的概率，有利的做法是在对数空间中计算，利用性质：对于 $p>0$, $\\log\\left(\\prod_x p_x^{c_x}\\right) = \\sum_x c_x \\log p_x$。定义\n$$\n\\ell(b) = \\sum_{x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} c_x \\log P(x\\mid b).\n$$\n然后使用 log-sum-exp 恒等式进行归一化：\n$$\nP(B=b \\mid \\mathbf{c},\\epsilon,\\delta) = \\frac{\\exp\\left(\\ell(b) - m\\right)}{\\sum_{b'} \\exp\\left(\\ell(b') - m\\right)},\\quad \\text{其中 } m=\\max_{b'} \\ell(b').\n$$\n特殊情况：如果 $N=0$，则每个 $\\ell(b)=0$（空和），因此每个后验概率都是 $1/4$。对于确定共有碱基，选择 $b^\\star \\in \\arg\\max_b P(B=b \\mid \\mathbf{c},\\epsilon,\\delta)$。如果多个碱基在 $10^{-12}$ 的绝对容差范围内出现平局，则根据映射关系 $\\mathrm{A} \\mapsto 0$, $\\mathrm{C} \\mapsto 1$, $\\mathrm{G} \\mapsto 2$, $\\mathrm{T} \\mapsto 3$ 选择最小的索引。报告 $b^\\star$ 的索引及其对应的后验概率，四舍五入到 6 位小数。\n\n将此过程应用于每个测试用例，会得出一个确定的共有碱基索引和一个后验概率，该结果与指定的损伤感知生成模型一致，其中损伤特别地增加了相对于基线测序错误的 $\\mathrm{C} \\to \\mathrm{T}$ 观测值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping: A->0, C->1, G->2, T->3\nBASES = ['A', 'C', 'G', 'T']\n\ndef emission_probs_for_base(base_index: int, eps: float, delta: float) -> np.ndarray:\n    \"\"\"\n    Construct emission probabilities P(x | B = base_index) for x in {A,C,G,T}\n    under the simplified damage model:\n      - For B != C: correct base with 1 - eps; each incorrect base eps / 3\n      - For B == C: P(C|C) = 1 - (eps + delta)\n                     P(T|C) = delta + eps/3\n                     P(A|C) = P(G|C) = eps/3\n    \"\"\"\n    p = np.full(4, eps / 3.0, dtype=float)\n    if base_index == 1:  # C\n        p[1] = 1.0 - (eps + delta)\n        p[3] = delta + eps / 3.0\n    else:\n        p[base_index] = 1.0 - eps\n    return p\n\ndef log_likelihood(counts: np.ndarray, p: np.ndarray) -> float:\n    \"\"\"\n    Compute sum_i counts[i] * log(p[i]), returning -inf if any probability is zero where count > 0.\n    \"\"\"\n    # Handle zero probabilities explicitly\n    with np.errstate(divide='ignore'):\n        logs = np.log(p)\n    # If p[i] == 0 and counts[i] > 0, the term is -inf.\n    mask_positive_counts = counts > 0\n    if np.any((p == 0.0) & mask_positive_counts):\n        return -np.inf\n    return float(np.dot(counts[mask_positive_counts], logs[mask_positive_counts]))\n\ndef posterior_and_call(counts: np.ndarray, eps: float, delta: float, tol: float = 1e-12):\n    \"\"\"\n    Compute posterior over bases and return (call_index, posterior_of_call).\n    Tie-breaks by smallest index within absolute tolerance 'tol'.\n    \"\"\"\n    lls = []\n    for b in range(4):\n        p = emission_probs_for_base(b, eps, delta)\n        ll = log_likelihood(counts, p)\n        lls.append(ll)\n    lls = np.array(lls, dtype=float)\n\n    # Normalize using log-sum-exp\n    m = np.max(lls)\n    with np.errstate(over='ignore', under='ignore'):\n        w = np.exp(lls - m)\n    Z = float(np.sum(w))\n    post = w / Z if Z > 0.0 else np.full(4, 0.25)  # Fallback shouldn't trigger unless all -inf; N=0 handled naturally\n\n    # Determine call with tie-breaking\n    max_post = float(np.max(post))\n    candidate_indices = np.where(np.abs(post - max_post) <= tol)[0]\n    call_index = int(np.min(candidate_indices))\n\n    return call_index, float(post[call_index])\n\ndef format_results_list(results):\n    \"\"\"\n    Format results as a single-line string: [[idx,posterior],...]\n    with posterior rounded to 6 decimal places.\n    \"\"\"\n    parts = []\n    for idx, post in results:\n        parts.append(f\"[{idx},{format(round(post + 0.0, 6), '.6f')}]\")\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (counts[A,C,G,T], epsilon, delta)\n    test_cases = [\n        ((2, 8, 1, 5), 0.01, 0.20),\n        ((0, 0, 0, 0), 0.01, 0.20),\n        ((0, 0, 0, 10), 0.01, 0.30),\n        ((0, 3, 0, 7), 0.01, 0.25),\n        ((1, 1, 1, 1), 0.01, 0.20),\n    ]\n\n    results = []\n    for counts_tuple, eps, delta in test_cases:\n        counts = np.array(counts_tuple, dtype=float)\n        call_idx, post_call = posterior_and_call(counts, eps, delta, tol=1e-12)\n        results.append((call_idx, post_call))\n\n    # Final print statement in the exact required format.\n    print(format_results_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}