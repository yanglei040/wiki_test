{
    "hands_on_practices": [
        {
            "introduction": "A common challenge in population genetics is that standard genotyping methods provide unphased data, meaning we know which alleles an individual has at two different loci, but not which alleles are on the same chromosome. This creates phase ambiguity for double heterozygotes, preventing a simple count of haplotypes. This practice guides you through implementing the Expectation-Maximization (EM) algorithm, a cornerstone of statistical genetics, to infer the most likely haplotype frequencies from unphased genotype counts . Mastering this technique is crucial for understanding how foundational LD analyses are performed on real-world data.",
            "id": "2401311",
            "problem": "You are given unphased diploid genotype count data for two biallelic loci across a sample of individuals. The two loci have alleles $A/a$ and $B/b$, respectively. A haplotype is an ordered pair of alleles on the same chromosome across the two loci (e.g., $AB$, $Ab$, $aB$, $ab$). Each individual carries two haplotypes (a diplotype), and the unphased genotype at each locus records only the unordered allele counts: $AA$, $Aa$, or $aa$ at the first locus, and $BB$, $Bb$, or $bb$ at the second locus. The $3 \\times 3$ table of genotype counts $g_{ij}$ uses $i \\in \\{0,1,2\\}$ for the count of allele $A$ at the first locus ($aa$, $Aa$, $AA$) and $j \\in \\{0,1,2\\}$ for the count of allele $B$ at the second locus ($bb$, $Bb$, $BB$). The $(1,1)$ cell is the double heterozygote $(Aa,Bb)$ and is phase-ambiguous.\n\nStarting from the foundational assumptions that (i) haplotypes in a random-mating diploid population are sampled independently to form diplotypes and (ii) the sample is a collection of independent individuals, the likelihood of the observed $3 \\times 3$ genotype count table is a function of the four haplotype frequencies $p_{AB}$, $p_{Ab}$, $p_{aB}$, $p_{ab}$, which are nonnegative and sum to $1$. Implement the expectation–maximization (EM) algorithm to find the maximum-likelihood estimates of these haplotype frequencies from the unphased counts. After estimating the haplotype frequencies, compute the linkage disequilibrium (LD) summary $D = p_{AB} - p_A p_B$, where $p_A = p_{AB} + p_{Ab}$ and $p_B = p_{AB} + p_{aB}$, and then compute $r^2 = D^2 / \\left(p_A (1 - p_A) p_B (1 - p_B)\\right)$. If the denominator in $r^2$ is zero, define $r^2 = 0$.\n\nYour program must:\n- Implement EM from first principles under the assumptions above, without relying on closed-form shortcuts for ambiguous phases.\n- Use a convergence tolerance $\\epsilon$ (e.g., $\\epsilon = 10^{-10}$) on the change in haplotype frequencies between iterations, with a reasonable maximum number of iterations to guarantee termination.\n- Return, for each test case, a list of five floats in the order $[p_{AB}, p_{Ab}, p_{aB}, p_{ab}, r^2]$, each rounded to $6$ decimal places.\n\nTest suite (each case is a $3 \\times 3$ matrix of nonnegative integers $g_{ij}$, in row-major order: row $i \\in \\{0,1,2\\}$ for $aa$, $Aa$, $AA$ by column $j \\in \\{0,1,2\\}$ for $bb$, $Bb$, $BB$):\n- Case $1$ (general “happy path” with ambiguity present):\n  - Row $0$: $[7, 2, 8]$\n  - Row $1$: $[6, 20, 4]$\n  - Row $2$: $[5, 3, 10]$\n- Case $2$ (no ambiguity: zero double heterozygotes):\n  - Row $0$: $[3, 1, 1]$\n  - Row $1$: $[1, 0, 0]$\n  - Row $2$: $[1, 0, 3]$\n- Case $3$ (linkage equilibrium grid with many double heterozygotes, $N = 64$):\n  - Row $0$: $[4, 8, 4]$\n  - Row $1$: $[8, 16, 8]$\n  - Row $2$: $[4, 8, 4]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed, comma-separated list for one test case with no spaces. For example: $[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],[x_{31},x_{32},x_{33},x_{34},x_{35}]]$, where each $x_{ij}$ is a float rounded to $6$ decimal places. All probabilities must be expressed as decimals, not percentages.",
            "solution": "The problem presented is a standard and well-posed task in computational population genetics: the estimation of haplotype frequencies from unphased diploid genotype counts using the expectation–maximization (EM) algorithm. The problem is scientifically grounded, internally consistent, and provides all necessary information for a unique solution to be computed. It is therefore deemed valid.\n\nThe core of the problem is to find the maximum-likelihood estimates (MLE) for the frequencies of the four haplotypes ($AB, Ab, aB, ab$), which we denote as $p_{AB}, p_{Ab}, p_{aB}, p_{ab}$, respectively. These frequencies are non-negative and sum to $1$. The input data is a $3 \\times 3$ matrix of genotype counts, $g_{ij}$, where $i \\in \\{0, 1, 2\\}$ is the count of allele $A$ at the first locus and $j \\in \\{0, 1, 2\\}$ is the count of allele $B$ at the second locus.\n\nThe likelihood of observing the genotype counts $\\mathbf{g} = \\{g_{ij}\\}$ is given by a multinomial probability distribution, where the probability of each of the nine two-locus genotypes is a function of the haplotype frequencies. Under the assumption of random mating (i.e., Hardy-Weinberg Equilibrium at the diplotype level), the expected frequency $P_{ij}$ of each genotype is determined by the haplotype frequencies. For example, the genotype $(AA,BB)$, corresponding to the cell $g_{22}$, can only arise from the diplotype $AB/AB$, which has an expected frequency of $p_{AB}^2$. Most genotype frequencies can be expressed as simple products or squared terms of the haplotype frequencies.\n\nThe nine genotype probabilities $P_{ij}(\\mathbf{p})$ are:\n$$ P_{00} = p_{ab}^2 $$\n$$ P_{01} = 2 p_{aB} p_{ab} $$\n$$ P_{02} = p_{aB}^2 $$\n$$ P_{10} = 2 p_{Ab} p_{ab} $$\n$$ P_{11} = 2 p_{AB} p_{ab} + 2 p_{Ab} p_{aB} $$\n$$ P_{12} = 2 p_{AB} p_{aB} $$\n$$ P_{20} = p_{Ab}^2 $$\n$$ P_{21} = 2 p_{AB} p_{Ab} $$\n$$ P_{22} = p_{AB}^2 $$\n\nThe log-likelihood of the observed data is then:\n$$ \\ln L(\\mathbf{p} | \\mathbf{g}) = \\text{const} + \\sum_{i=0}^{2} \\sum_{j=0}^{2} g_{ij} \\ln P_{ij}(\\mathbf{p}) $$\nDirectly maximizing this function is complicated by the sum in the term for $P_{11}$, which corresponds to the phase-ambiguous double heterozygotes $(Aa,Bb)$. This genotype can be formed from two distinct diplotypes: $AB/ab$ (coupling or cis phase) and $Ab/aB$ (repulsion or trans phase). The EM algorithm is ideally suited for such problems involving missing data, where the missing information here is the phase of the $g_{11}$ individuals.\n\nThe EM algorithm is an iterative procedure consisting of two steps:\n1.  **Initialization**: Begin with an initial estimate of the haplotype frequencies, $\\mathbf{p}^{(0)}$. A robust choice is to assume linkage equilibrium, where haplotype frequencies are products of allele frequencies. The allele frequencies $p_A$ and $p_B$ can be estimated directly by counting alleles from the genotype table:\n    $$ p_A = \\frac{2\\sum_j g_{2j} + \\sum_j g_{1j}}{2N} \\quad \\text{and} \\quad p_B = \\frac{2\\sum_i g_{i2} + \\sum_i g_{i1}}{2N} $$\n    where $N = \\sum_{i,j} g_{ij}$ is the total number of individuals. The initial haplotype frequencies are then $p_{AB}^{(0)} = p_A p_B$, $p_{Ab}^{(0)} = p_A(1-p_B)$, $p_{aB}^{(0)} = (1-p_A)p_B$, and $p_{ab}^{(0)} = (1-p_A)(1-p_B)$.\n\n2.  **Expectation (E-step)**: In iteration $t+1$, using the current haplotype frequency estimates $\\mathbf{p}^{(t)}$, we calculate the expected counts of the two unobserved diplotypes that constitute the $g_{11}$ double heterozygotes. The conditional probability that a double heterozygote has the cis phase ($AB/ab$) is:\n    $$ \\pi_{cis} = P(AB/ab | AaBb, \\mathbf{p}^{(t)}) = \\frac{2 p_{AB}^{(t)} p_{ab}^{(t)}}{2 p_{AB}^{(t)} p_{ab}^{(t)} + 2 p_{Ab}^{(t)} p_{aB}^{(t)}} = \\frac{p_{AB}^{(t)} p_{ab}^{(t)}}{p_{AB}^{(t)} p_{ab}^{(t)} + p_{Ab}^{(t)} p_{aB}^{(t)}} $$\n    The expected count of cis-phase individuals is $E[g_{11,cis}] = g_{11} \\times \\pi_{cis}$. Similarly, the expected count of trans-phase individuals ($Ab/aB$) is $E[g_{11,trans}] = g_{11} \\times (1 - \\pi_{cis})$.\n\n3.  **Maximization (M-step)**: With the expected counts from the E-step, we effectively have \"complete\" data. The new MLE for the haplotype frequencies, $\\mathbf{p}^{(t+1)}$, is obtained by simply counting the expected number of each haplotype and dividing by the total number of haplotypes, $2N$. The expected haplotype counts ($h$) are:\n    $$ h_{AB} = 2g_{22} + g_{21} + g_{12} + E[g_{11,cis}] $$\n    $$ h_{Ab} = 2g_{20} + g_{21} + g_{10} + E[g_{11,trans}] $$\n    $$ h_{aB} = 2g_{02} + g_{12} + g_{01} + E[g_{11,trans}] $$\n    $$ h_{ab} = 2g_{00} + g_{10} + g_{01} + E[g_{11,cis}] $$\n    The updated frequencies are $p_{XY}^{(t+1)} = h_{XY} / (2N)$.\n\n4.  **Convergence**: The E- and M-steps are repeated until the haplotype frequency vector converges. Convergence is achieved when the change in frequencies between successive iterations is smaller than a specified tolerance $\\epsilon$ (e.g., $\\epsilon = 10^{-10}$).\n\nAfter the EM algorithm has converged to the final MLE of haplotype frequencies $\\mathbf{p}^* = (p_{AB}, p_{Ab}, p_{aB}, p_{ab})$, the linkage disequilibrium (LD) metrics are calculated.\nThe allele frequencies are recomputed from the estimated haplotype frequencies:\n$$ p_A = p_{AB} + p_{Ab} $$\n$$ p_B = p_{AB} + p_{aB} $$\nThe LD coefficient, $D$, measures the deviation from linkage equilibrium:\n$$ D = p_{AB} - p_A p_B $$\nFinally, the squared correlation coefficient, $r^2$, a common normalized measure of LD, is computed:\n$$ r^2 = \\frac{D^2}{p_A (1-p_A) p_B (1-p_B)} $$\nIf the denominator is zero (i.e., at least one of the loci is monomorphic), $r^2$ is defined as $0$. The final output consists of the four haplotype frequencies and the value of $r^2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_mle(g: np.ndarray, tol: float = 1e-10, max_iter: int = 10000) - list[float]:\n    \"\"\"\n    Calculates maximum-likelihood estimates of haplotype frequencies using the EM algorithm.\n\n    Args:\n        g: A 3x3 numpy array of genotype counts.\n           Rows correspond to allele counts for locus A (0: aa, 1: Aa, 2: AA).\n           Cols correspond to allele counts for locus B (0: bb, 1: Bb, 2: BB).\n        tol: Convergence tolerance for the EM algorithm.\n        max_iter: Maximum number of iterations for the EM algorithm.\n\n    Returns:\n        A list of five floats: [p_AB, p_Ab, p_aB, p_ab, r^2].\n    \"\"\"\n    g = g.astype(np.float64)\n    N = np.sum(g)\n\n    if N == 0:\n        return [0.0, 0.0, 0.0, 0.0, 0.0]\n\n    # Step 1: Initialization\n    # Estimate allele frequencies from observed genotype counts\n    n_A = 2 * np.sum(g[2, :]) + np.sum(g[1, :])\n    n_B = 2 * np.sum(g[:, 2]) + np.sum(g[:, 1])\n\n    p_A_init = n_A / (2 * N)\n    p_B_init = n_B / (2 * N)\n\n    # Initialize haplotype frequencies assuming linkage equilibrium\n    p = np.array([\n        p_A_init * p_B_init,             # p_AB\n        p_A_init * (1 - p_B_init),       # p_Ab\n        (1 - p_A_init) * p_B_init,       # p_aB\n        (1 - p_A_init) * (1 - p_B_init)  # p_ab\n    ])\n\n    # Step 2: EM Iteration\n    for _ in range(max_iter):\n        p_old = p.copy()\n\n        # E-step: Estimate expected counts of ambiguous diplotypes\n        # Denominator for cis/trans probability\n        # p[0]=p_AB, p[1]=p_Ab, p[2]=p_aB, p[3]=p_ab\n        d = p[0] * p[3] + p[1] * p[2]\n\n        g11_cis = 0.0\n        g11_trans = 0.0\n        if d  0:\n            g11_cis = g[1, 1] * (p[0] * p[3]) / d\n            g11_trans = g[1, 1] * (p[1] * p[2]) / d\n\n        # M-step: Update haplotype frequencies based on expected counts\n        h_AB = 2 * g[2, 2] + g[2, 1] + g[1, 2] + g11_cis\n        h_Ab = 2 * g[2, 0] + g[2, 1] + g[1, 0] + g11_trans\n        h_aB = 2 * g[0, 2] + g[1, 2] + g[0, 1] + g11_trans\n        h_ab = 2 * g[0, 0] + g[1, 0] + g[0, 1] + g11_cis\n\n        p = np.array([h_AB, h_Ab, h_aB, h_ab]) / (2 * N)\n\n        # Check for convergence\n        if np.sum(np.abs(p - p_old))  tol:\n            break\n            \n    # Step 3: Final calculations after convergence\n    p_AB, p_Ab, p_aB, p_ab = p\n\n    p_A = p_AB + p_Ab\n    p_B = p_AB + p_aB\n\n    D = p_AB - p_A * p_B\n\n    denom_r2 = p_A * (1 - p_A) * p_B * (1 - p_B)\n    r2 = 0.0\n    if denom_r2  1e-12: # Use a small epsilon for floating point safety\n        r2 = D**2 / denom_r2\n\n    return [p_AB, p_Ab, p_aB, p_ab, r2]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        np.array([[7, 2, 8], [6, 20, 4], [5, 3, 10]]),\n        np.array([[3, 1, 1], [1, 0, 0], [1, 0, 3]]),\n        np.array([[4, 8, 4], [8, 16, 8], [4, 8, 4]])\n    ]\n\n    results = []\n    for g_matrix in test_cases:\n        result_floats = calculate_mle(g_matrix)\n        rounded_res = [f\"{x:.6f}\" for x in result_floats]\n        results.append(f\"[{','.join(rounded_res)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Now that we can estimate haplotype frequencies, the next step is to quantify the association between variants using a standardized metric. The squared correlation coefficient, $r^2$, is the workhorse measure of LD, capturing the statistical dependency between alleles at two loci. This exercise involves the essential bioinformatics skill of parsing the ubiquitous Variant Call Format (VCF) and implementing the $r^2$ calculation from scratch to find strongly linked variants, or \"LD buddies\" . This is a core workflow in genome-wide association studies and evolutionary genetics.",
            "id": "2401344",
            "problem": "You are given the task of writing a complete program that, for each of several provided Variant Call Format (VCF) texts representing a single chromosome, identifies all \"Linkage Disequilibrium (LD) buddies\" of a specified target variant. A variant is considered an LD buddy of the target if the squared Pearson correlation of alternate allele counts across diploid individuals, denoted by $r^2$, strictly exceeds a given threshold $\\tau$. All computations must be derived from first principles as specified below, and all outputs must be in the format defined at the end of this statement.\n\nDefinitions. Consider a set of $S$ diploid individuals and a set of $M$ biallelic single-nucleotide variants on one chromosome. For variant $j \\in \\{1,\\dots,M\\}$ and individual $s \\in \\{1,\\dots,S\\}$, let the genotype call in the VCF field GT be one of the standard forms $0/0$, $0/1$, $1/0$, $1/1$, $0|0$, $0|1$, $1|0$, $1|1$, or missing (for example, $./.$). Define the alternate-allele count\n$$\nx^{(j)}_s \\in \\{0,1,2\\}\n$$\nas the number of alternate alleles in the genotype call for variant $j$ and individual $s$, where missing genotypes are treated as undefined. For a pair of variants $(j,k)$, define the set of individuals with non-missing genotypes at both variants as\n$$\n\\mathcal{I}_{jk} = \\{ s \\in \\{1,\\dots,S\\} \\mid x^{(j)}_s \\text{ and } x^{(k)}_s \\text{ are both defined} \\},\n$$\nand let\n$$\nn_{jk} = |\\mathcal{I}_{jk}|.\n$$\nIf $n_{jk}  2$, then $r^2$ for $(j,k)$ is undefined. Otherwise, define population means\n$$\n\\mu_j = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} x^{(j)}_s, \\qquad \\mu_k = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} x^{(k)}_s,\n$$\npopulation variances\n$$\n\\sigma_j^2 = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(j)}_s - \\mu_j\\right)^2, \\qquad \\sigma_k^2 = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(k)}_s - \\mu_k\\right)^2,\n$$\nand population covariance\n$$\n\\operatorname{Cov}_{jk} = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(j)}_s - \\mu_j\\right)\\left(x^{(k)}_s - \\mu_k\\right).\n$$\nIf $\\sigma_j^2 = 0$ or $\\sigma_k^2 = 0$, then $r^2$ for $(j,k)$ is undefined. Otherwise define the Pearson correlation\n$$\nr_{jk} = \\frac{\\operatorname{Cov}_{jk}}{\\sqrt{\\sigma_j^2 \\sigma_k^2}}\n$$\nand the linkage disequilibrium measure\n$$\nr_{jk}^2 = \\left(r_{jk}\\right)^2.\n$$\nFix a target variant index $t$, and a threshold $\\tau \\in (0,1)$. A variant $j \\neq t$ is an LD buddy of $t$ if and only if $r_{tj}^2 > \\tau$. Pairs with undefined $r_{tj}^2$ are not LD buddies.\n\nInput representation. Each test case consists of:\n- A single chromosome identifier (string) to select rows.\n- A VCF text whose header line starts with the fields CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, followed by $S$ sample columns. Only the GT subfield in FORMAT is relevant. All variants are biallelic, and all rows in a test case belong to the same chromosome.\n- A target variant position (an integer base-pair coordinate on the given chromosome).\n- A threshold $\\tau$ given as a decimal number in $(0,1)$.\n\nYour program must use the VCF texts and parameters provided in the test suite below as its internal data and must not require any user input or external files.\n\nTest suite. There are three test cases. For each case, use the specified chromosome string, target position, and threshold $\\tau = 0.8$, and the provided VCF content.\n\nTest case A:\n- Chromosome: \"1\"\n- Target position: 200\n- Threshold: $0.8$\n- VCF lines:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3 S4\"\n  - \"1 100 rs100 A G . . . GT 0/0 0/1 1/1 0/1\"\n  - \"1 200 rs200 A G . . . GT 0/0 0/1 1/1 0/1\"\n  - \"1 300 rs300 A G . . . GT 0/0 0/0 1/1 1/1\"\n\nTest case B:\n- Chromosome: \"1\"\n- Target position: 1000\n- Threshold: $0.8$\n- VCF lines:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3 S4 S5 S6\"\n  - \"1 1000 rs1000 A G . . . GT 0/0 0/1 1/1 0/1 0/0 1/1\"\n  - \"1 1010 rs1010 A G . . . GT 0/0 0/1 1/1 0/1 0/0 1/1\"\n  - \"1 1020 rs1020 A G . . . GT 0/0 0/0 0/0 0/0 0/0 0/0\"\n  - \"1 1030 rs1030 A G . . . GT 0/0 ./. 1/1 ./. 0/0 ./.\"\n  - \"1 1040 rs1040 A G . . . GT 0/0 0/0 1/1 1/1 0/0 1/1\"\n\nTest case C:\n- Chromosome: \"2\"\n- Target position: 5000\n- Threshold: $0.8$\n- VCF lines:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3\"\n  - \"2 5000 rs5000 A G . . . GT 0/0 0/0 0/0\"\n  - \"2 5010 rs5010 A G . . . GT 0/0 1/1 0/1\"\n  - \"2 5020 rs5020 A G . . . GT 0/1 1/1 0/0\"\n\nOutput specification. For each test case, output the sorted list (ascending by position) of all variant positions that are LD buddies of the target. Aggregate the three per-test-case lists into a single line of output formatted as a comma-separated list enclosed in square brackets, with no spaces, for example, \"[[a,b],[c],[]]\". The elements inside the inner lists must be integers. Your program should produce a single line of output containing exactly the aggregated results in this format.",
            "solution": "The problem is valid. It is scientifically grounded in population genetics, mathematically well-defined, and all necessary data and definitions are provided for a complete solution.\n\nThe objective is to identify \"Linkage Disequilibrium (LD) buddies\" for a specified target variant from Variant Call Format (VCF) data. A variant $j$ is an LD buddy of a target variant $t$ if the squared Pearson correlation coefficient, $r_{tj}^2$, calculated from their alternate allele counts across a population of diploid individuals, exceeds a given threshold $\\tau$. The solution must be derived from first principles as defined in the problem statement.\n\nThe algorithmic approach is structured into three main phases: data parsing and preparation, computation of the $r^2$ statistic, and identification and formatting of results.\n\nFirst, we must parse the provided VCF text for each test case. The VCF format represents genetic variations. For our purpose, we are interested in biallelic single-nucleotide variants. The crucial information is located in the `POS` (position) column and the `GT` (genotype) sub-field within the `FORMAT` and sample columns. We iterate through each non-header line of the VCF text. For each variant, we record its chromosomal position, an integer. The genotype calls, such as `$0/0$`, `$0/1$`, `$1/0$`, and `$1/1$`, must be converted into numerical alternate-allele counts, $x_s^{(j)} \\in \\{0, 1, 2\\}$. Specifically, `$0/0$` and `$0|0$` map to $0$, `$0/1$`, `$1/0$`, `$0|1$`, and `$1|0$` map to $1$, and `$1/1$` and `$1|1$` map to $2$. Missing genotypes, denoted `$./.$`, are treated as undefined and are represented by a special value, such as `np.nan`, to facilitate numerical computation. This process yields a set of position vectors and a corresponding genotype matrix of dimension $M \\times S$, where $M$ is the number of variants and $S$ is the number of individuals.\n\nThe core of the problem is the correct calculation of the $r^2$ statistic between the target variant, $t$, and every other candidate variant, $j$. The calculation must precisely follow the provided definitions. For any pair of variants $(t, j)$, we first identify the set of individuals, $\\mathcal{I}_{tj}$, for whom genotype data is available for both variants. Let $n_{tj} = |\\mathcal{I}_{tj}|$. The problem specifies that $r_{tj}^2$ is undefined if $n_{tj}  2$. In such cases, the pair is discarded.\n\nIf $n_{tj} \\ge 2$, we proceed to compute the necessary statistics using only the data from individuals in $\\mathcal{I}_{tj}$. Let the filtered allele-count vectors be $\\mathbf{x}^{(t)}$ and $\\mathbf{x}^{(j)}$. The population means are calculated as:\n$$\n\\mu_t = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} x^{(t)}_s, \\qquad \\mu_j = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} x^{(j)}_s\n$$\nThe population variances are:\n$$\n\\sigma_t^2 = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(t)}_s - \\mu_t\\right)^2, \\qquad \\sigma_j^2 = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(j)}_s - \\mu_j\\right)^2\n$$\nA critical edge case arises if a variant is monomorphic within the considered sub-population $\\mathcal{I}_{tj}$, meaning all individuals have the same allele count. In this situation, the variance is zero. The problem states that if $\\sigma_t^2 = 0$ or $\\sigma_j^2 = 0$, $r_{tj}^2$ is undefined, and the pair is not considered for LD buddies.\n\nIf both variances are non-zero, we compute the population covariance:\n$$\n\\operatorname{Cov}_{tj} = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(t)}_s - \\mu_t\\right)\\left(x^{(j)}_s - \\mu_j\\right)\n$$\nFinally, the squared Pearson correlation is computed as:\n$$\nr_{tj}^2 = \\left( \\frac{\\operatorname{Cov}_{tj}}{\\sqrt{\\sigma_t^2 \\sigma_j^2}} \\right)^2 = \\frac{(\\operatorname{Cov}_{tj})^2}{\\sigma_t^2 \\sigma_j^2}\n$$\nThis calculation is performed for the target variant $t$ against every other variant $j \\neq t$. If the computed $r_{tj}^2$ is a valid number and $r_{tj}^2  \\tau$, where $\\tau$ is the given threshold, then variant $j$ is an LD buddy of $t$. The position of variant $j$ is added to a list of results for the current test case.\n\nThe overall algorithm proceeds as follows:\n1.  Initialize an empty list to store the final results for all test cases.\n2.  For each test case, parse the VCF text to create a mapping from variant positions to their allele-count vectors across all samples.\n3.  Identify the allele-count vector for the target variant corresponding to the given target position.\n4.  Iterate through all other variants. For each candidate variant:\n    a. Apply pairwise deletion to handle missing data, creating filtered vectors for the target and candidate.\n    b. Check the validity conditions: $n_{tj} \\ge 2$, $\\sigma_t^2  0$, and $\\sigma_j^2  0$.\n    c. If valid, compute $r_{tj}^2$ using the population statistics formulas.\n    d. If $r_{tj}^2  \\tau$, add the candidate variant's position to a temporary list for the current test case.\n5.  After checking all candidates for a test case, sort the list of LD buddy positions in ascending order.\n6.  Append this sorted list to the main results list.\n7.  After processing all test cases, format the aggregated results into a single string of nested lists, as specified, e.g., `[[pos1,pos2],[pos3],[]]`, and output this string. This ensures compliance with the strict output format required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linkage disequilibrium buddy problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"chrom\": \"1\",\n            \"target_pos\": 200,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\tS4\n1\t100\trs100\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\n1\t200\trs200\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\n1\t300\trs300\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t1/1\t1/1\n\"\"\"\n        },\n        {\n            \"chrom\": \"1\",\n            \"target_pos\": 1000,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\tS4\tS5\tS6\n1\t1000\trs1000\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\t0/0\t1/1\n1\t1010\trs1010\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\t0/0\t1/1\n1\t1020\trs1020\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t0/0\t0/0\t0/0\t0/0\n1\t1030\trs1030\tA\tG\t.\t.\t.\tGT\t0/0\t./.\t1/1\t./.\t0/0\t./.\n1\t1040\trs1040\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t1/1\t1/1\t0/0\t1/1\n\"\"\"\n        },\n        {\n            \"chrom\": \"2\",\n            \"target_pos\": 5000,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\n2\t5000\trs5000\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t0/0\n2\t5010\trs5010\tA\tG\t.\t.\t.\tGT\t0/0\t1/1\t0/1\n2\t5020\trs5020\tA\tG\t.\t.\t.\tGT\t0/1\t1/1\t0/0\n\"\"\"\n        }\n    ]\n\n    aggregated_results = []\n    \n    for case in test_cases:\n        vcf_text = case[\"vcf_text\"]\n        target_pos = case[\"target_pos\"]\n        tau = case[\"tau\"]\n\n        # Parse VCF text\n        positions = []\n        genotypes_list = []\n        lines = vcf_text.strip().split('\\n')\n        \n        header_line = \"\"\n        data_lines = []\n        for line in lines:\n            if line.startswith('#CHROM'):\n                header_line = line\n            elif not line.startswith('##'):\n                data_lines.append(line)\n\n        header_fields = header_line.split('\\t')\n        format_col_idx = header_fields.index('FORMAT')\n        sample_cols_start_idx = format_col_idx + 1\n\n        for line in data_lines:\n            parts = line.split('\\t')\n            positions.append(int(parts[1]))\n            \n            format_str = parts[format_col_idx]\n            try:\n                gt_subfield_idx = format_str.split(':').index('GT')\n            except ValueError:\n                # This case implies GT field is missing, which is a malformed VCF for this problem.\n                # We assume valid VCFs as per problem context.\n                continue\n\n            allele_counts = []\n            for sample_gt_field in parts[sample_cols_start_idx:]:\n                gt_str = sample_gt_field.split(':')[gt_subfield_idx]\n                \n                if gt_str in ('0/0', '0|0'):\n                    allele_counts.append(0)\n                elif gt_str in ('0/1', '1/0', '0|1', '1|0'):\n                    allele_counts.append(1)\n                elif gt_str in ('1/1', '1|1'):\n                    allele_counts.append(2)\n                else: # Missing, e.g., './.'\n                    allele_counts.append(np.nan)\n            \n            genotypes_list.append(allele_counts)\n        \n        genotypes = np.array(genotypes_list, dtype=float)\n\n        # Identify target variant\n        try:\n            target_idx = positions.index(target_pos)\n        except ValueError:\n            aggregated_results.append([])\n            continue # Target not found, no buddies\n\n        target_vec = genotypes[target_idx, :]\n        \n        ld_buddies = []\n\n        # Find LD buddies\n        for j in range(len(positions)):\n            if j == target_idx:\n                continue\n            \n            candidate_pos = positions[j]\n            candidate_vec = genotypes[j, :]\n\n            # Filter for individuals with non-missing genotypes for both variants\n            valid_indices = ~np.isnan(target_vec)  ~np.isnan(candidate_vec)\n            \n            x_t_j_valid = target_vec[valid_indices]\n            x_k_j_valid = candidate_vec[valid_indices]\n            \n            n_jk = len(x_t_j_valid)\n\n            if n_jk  2:\n                continue\n\n            var_t = np.var(x_t_j_valid) # ddof=0 is default for population variance\n            var_k = np.var(x_k_j_valid)\n\n            if var_t == 0 or var_k == 0:\n                continue\n\n            # Calculate population covariance\n            # np.cov with ddof=0 ensures population covariance calculation\n            cov_matrix = np.cov(x_t_j_valid, x_k_j_valid, ddof=0)\n            cov_tk = cov_matrix[0, 1]\n\n            r_squared = (cov_tk ** 2) / (var_t * var_k)\n            \n            # Since floating point arithmetic can sometimes result in values slightly  1.0, clip it.\n            # e.g. for identical vectors.\n            if r_squared  1.0:\n                r_squared = 1.0\n\n            if r_squared  tau:\n                ld_buddies.append(candidate_pos)\n\n        ld_buddies.sort()\n        aggregated_results.append(ld_buddies)\n\n    # Format and print the final output\n    inner_lists_str = [f\"[{','.join(map(str, lst))}]\" for lst in aggregated_results]\n    print(f\"[{','.join(inner_lists_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Linkage disequilibrium is not uniform across the genome; instead, it forms discrete regions of high correlation known as haplotype blocks. These blocks, separated by historical recombination \"hotspots,\" are fundamental units of genomic architecture. In this practice, you will implement a classic algorithm based on the Four-Gamete Rule, a simple but powerful test for detecting evidence of recombination between loci . This exercise provides a concrete understanding of how the abstract concept of LD structure is translated into computationally defined units on a chromosome.",
            "id": "2401326",
            "problem": "Implement a program that, given phased biallelic haplotype data for a contiguous set of loci, partitions the loci into candidate haplotype blocks using the Four-Gamete Rule. The program must be written from first principles and must not rely on pre-built population genetics libraries. The algorithmic basis should start from core definitions of haplotypes, recombination, and the Four-Gamete Rule under the infinite-sites model, without shortcut formulas. The data are represented as a matrix of integers where rows are haplotypes and columns are loci. Each entry is in the set $\\{0,1\\}$ for observed alleles, with optional missing values denoted by $-1$. A block is defined as a maximal contiguous set of loci such that no pair of loci within the same block exhibits all four biallelic combinations across the observed haplotypes, ignoring rows with missing data at either locus. The task is to implement a greedy left-to-right algorithm that yields the coarsest partition into such blocks.\n\nDefinitions and constraints:\n- A haplotype matrix $H$ has shape $n \\times m$ with $n \\ge 1$ haplotypes (rows) and $m \\ge 1$ loci (columns). Entries are in $\\{0,1\\}$ or the missing symbol $-1$.\n- For two loci $i$ and $j$, enumerate observed allele pairs $(H_{r,i}, H_{r,j})$ across rows $r \\in \\{0,\\dots,n-1\\}$, ignoring any row where either value is $-1$. If the set of observed pairs equals $\\{(0,0),(0,1),(1,0),(1,1)\\}$, then loci $i$ and $j$ are said to exhibit four gametes (evidence of historical recombination or recurrent mutation under the infinite-sites model).\n- A valid block is a maximal contiguous index range $[s,e]$ with $0 \\le s \\le e \\le m-1$ such that for every pair $(i,j)$ with $s \\le i  j \\le e$, the observed pairs do not contain all four gametes.\n- The greedy partitioning algorithm must scan loci from left to right, growing the current block by attempting to add the next locus. If adding a locus $j$ would create any pair $(i,j)$ with four gametes for some $i$ already in the block, then the current block ends at $j-1$ and a new block starts at $j$. Continue until all loci are assigned to blocks. The result must be the list of blocks as index intervals $[s,e]$ using $0$-based inclusive indices.\n\nInput to be embedded in the program as a test suite:\n- Use the missing data symbol $-1$ exactly as specified.\n- All indices are $0$-based and inclusive.\n- Test matrices are listed row-wise; each inner list represents a row (haplotype).\n\nTest suite (five cases):\n1. Case T1 (no four-gamete evidence, single block):\n   - $H_1$ is $4 \\times 4$:\n     - Row $0$: $[0,0,0,0]$\n     - Row $1$: $[1,1,1,1]$\n     - Row $2$: $[0,0,0,0]$\n     - Row $3$: $[1,1,1,1]$\n   - Expected to produce a single block spanning indices $[0,3]$.\n\n2. Case T2 (one internal boundary due to four gametes when extending):\n   - $H_2$ is $6 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,0,0,1,1]$\n     - Row $2$: $[1,1,1,0,0]$\n     - Row $3$: $[1,1,1,1,1]$\n     - Row $4$: $[0,0,0,0,0]$\n     - Row $5$: $[1,1,1,1,1]$\n   - Adding locus index $3$ introduces all four gametes with earlier loci, creating a boundary between indices $2$ and $3$. The second block spans indices $[3,4]$.\n\n3. Case T3 (missing data prevent four-gamete detection, larger block):\n   - $H_3$ is $6 \\times 4$:\n     - Row $0$: $[0,0,0,0]$\n     - Row $1$: $[0,0,0,1]$\n     - Row $2$: $[1,1,1,0]$\n     - Row $3$: $[1,1,1,-1]$\n     - Row $4$: $[0,0,0,0]$\n     - Row $5$: $[1,1,1,-1]$\n   - Due to missing values $-1$ in the last column, not all four gametes are observed for any pair, yielding a single block $[0,3]$.\n\n4. Case T4 (every attempted extension triggers a boundary, single-locus blocks):\n   - $H_4$ is $4 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,1,0,1,0]$\n     - Row $2$: $[1,0,1,0,1]$\n     - Row $3$: $[1,1,1,1,1]$\n   - Alternating patterns ensure four gametes between adjacent loci when attempting to extend, producing blocks $[0,0]$, $[1,1]$, $[2,2]$, $[3,3]$, $[4,4]$.\n\n5. Case T5 (monomorphic locus within a block):\n   - $H_5$ is $6 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,0,0,0,0]$\n     - Row $2$: $[1,1,1,0,1]$\n     - Row $3$: $[1,1,1,0,1]$\n     - Row $4$: $[0,0,0,0,0]$\n     - Row $5$: $[1,1,1,0,1]$\n   - The fourth column is monomorphic with allele $0$, and all other columns are in perfect concordance, leading to a single block $[0,4]$.\n\nFinal output format:\n- For each test case, output the list of block intervals as a list of two-integer lists $[s,e]$.\n- Aggregate the five case results into a single top-level list in order T1, T2, T3, T4, T5.\n- Your program should produce a single line of output containing this aggregate as a comma-separated list enclosed in square brackets with no spaces, for example: $[[[0,3]],[[0,2],[3,4]],\\dots]$.\n- Each $s$ and $e$ must be $0$-based indices and inclusive.\n\nThe program must compute these partitions using the specified algorithm and print exactly one line matching the format above. No physical units or angle units are involved. Express any fractions or proportions as decimals if needed (not required here).",
            "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a clear computational task based on established principles in population genetics and bioinformatics. We may therefore proceed with the solution.\n\nThe problem requires the implementation of a greedy algorithm to partition a set of genetic loci into haplotype blocks. The criterion for this partition is the Four-Gamete Rule, a fundamental concept derived from the infinite-sites model of mutation.\n\nFirst, we must formalize the underlying scientific principle. The infinite-sites model posits that every new mutation occurs at a unique site along a chromosome that has not previously experienced a mutation in the sampled population. Consider two biallelic loci, located at positions $i$ and $j$, with alleles $\\{0,1\\}$. If no recombination has occurred between these two loci in the evolutionary history of the observed haplotypes, then at most three of the four possible two-locus gametes—$(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$—can exist. The appearance of the fourth gamete can only be explained by a recombination event between the loci or by a recurrent mutation at one of the sites, the latter of which is disallowed by the infinite-sites model. Thus, the presence of all four gametes, denoted as a \"four-gamete pair,\" is strong evidence for at least one historical recombination event between the loci.\n\nThe core of the algorithm is a function to test for this condition. Let the input haplotype data be represented by a matrix $H$ of size $n \\times m$, where $n$ is the number of haplotypes and $m$ is the number of loci. An entry $H_{r,k}$ represents the allele at locus $k$ for haplotype $r$, where $k \\in \\{0, \\dots, m-1\\}$ and $r \\in \\{0, \\dots, n-1\\}$. Alleles are in $\\{0,1\\}$, with $-1$ indicating missing data.\n\nTo determine if two loci, $i$ and $j$, constitute a four-gamete pair, we perform the following check:\n1. Initialize an empty set, $S_{i,j}$, to store unique, valid allele pairs.\n2. Iterate through each haplotype $r$ from $0$ to $n-1$.\n3. For each haplotype $r$, consider the allele pair $(H_{r,i}, H_{r,j})$.\n4. If either $H_{r,i} = -1$ or $H_{r,j} = -1$, this pair contains missing data and must be ignored.\n5. If the pair is valid, add it to the set $S_{i,j}$.\n6. After iterating through all $n$ haplotypes, the test for a four-gamete pair is positive if and only if the set $S_{i,j}$ is equal to $\\{(0,0), (0,1), (1,0), (1,1)\\}$. For biallelic data, this is equivalent to checking if the cardinality of the set, $|S_{i,j}|$, is equal to $4$.\n\nWith this test established, we can construct the greedy block partitioning algorithm as specified. The algorithm proceeds from left to right across the loci, extending a block as far as possible.\n\nLet $m$ be the total number of loci, indexed from $0$ to $m-1$.\n1. Initialize an empty list, $\\mathcal{B}$, to store the resulting block partitions.\n2. Initialize the starting index of the current block, $s$, to $0$.\n3. Iterate with a prospective locus index, $j$, from $1$ to $m-1$. For each $j$, we test if locus $j$ can be included in the current block that starts at index $s$.\n4. To perform this test, we must check for a four-gamete violation between locus $j$ and every locus $i$ already in the current block, where $i$ ranges from $s$ to $j-1$.\n5. A violation occurs if the four-gamete test is positive for any pair of loci $(i,j)$ within this range.\n6. If a violation is found for some locus $i \\in [s, j-1]$:\n   a. The current block is finalized. Its interval is $[s, j-1]$. This interval is added to the list $\\mathcal{B}$.\n   b. A new block must begin at the current locus $j$. The start index $s$ is updated to $j$.\n   c. The inner check for other loci $i$ is terminated, and the algorithm proceeds to the next prospective locus, $j+1$.\n7. If the inner loop over all $i \\in [s, j-1]$ completes without finding any four-gamete violation, locus $j$ is successfully added to the current block. The algorithm then proceeds to evaluate the next locus, $j+1$, without changing the block start $s$.\n8. After the main loop over $j$ completes, the final block, which starts at the current value of $s$ and extends to the last locus $m-1$, must be finalized and added to $\\mathcal{B}$. The interval is $[s, m-1]$.\n\nThis deterministic, greedy procedure produces a unique partition of the loci into contiguous blocks for any given haplotype matrix $H$. Each block is maximal in the sense that it could not be extended further to the right without violating the Four-Gamete Rule.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the block partitioning algorithm.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case T1\n        [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]],\n        # Case T2\n        [[0, 0, 0, 0, 0], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]],\n        # Case T3\n        [[0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 1, -1], [0, 0, 0, 0], [1, 1, 1, -1]],\n        # Case T4\n        [[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]],\n        # Case T5\n        [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1]],\n    ]\n\n    def check_four_gametes(locus1_col, locus2_col):\n        \"\"\"\n        Checks if two loci exhibit all four gametic types.\n        Missing data (-1) are ignored.\n        \n        Args:\n            locus1_col (np.ndarray): A 1D array representing allele data for the first locus.\n            locus2_col (np.ndarray): A 1D array representing allele data for the second locus.\n        \n        Returns:\n            bool: True if four gametes are observed, False otherwise.\n        \"\"\"\n        observed_pairs = set()\n        for i in range(len(locus1_col)):\n            allele1 = locus1_col[i]\n            allele2 = locus2_col[i]\n            \n            # Ignore haplotypes with missing data at either locus\n            if allele1 != -1 and allele2 != -1:\n                observed_pairs.add((allele1, allele2))\n        \n        # The condition is met if the number of unique pairs is exactly 4\n        return len(observed_pairs) == 4\n\n    def find_blocks(haplotype_matrix):\n        \"\"\"\n        Partitions loci into blocks using the greedy Four-Gamete Rule algorithm.\n        \n        Args:\n            haplotype_matrix (list of lists): The input matrix of haplotypes.\n            \n        Returns:\n            list of lists: A list of [start, end] intervals for each block.\n        \"\"\"\n        H = np.array(haplotype_matrix, dtype=np.int8)\n        _n_haplotypes, n_loci = H.shape\n\n        if n_loci == 0:\n            return []\n        if n_loci == 1:\n            return [[0, 0]]\n\n        blocks = []\n        block_start = 0\n\n        # Iterate through loci to decide where blocks end\n        for j in range(1, n_loci):\n            violation_found = False\n            # Check current locus j against all previous loci in the current block\n            for i in range(block_start, j):\n                if check_four_gametes(H[:, i], H[:, j]):\n                    # Violation found, end the current block here\n                    blocks.append([block_start, j - 1])\n                    # Start a new block at the current locus\n                    block_start = j\n                    violation_found = True\n                    break\n            if violation_found:\n                continue\n        \n        # Add the last block, which extends to the end of the loci\n        blocks.append([block_start, n_loci - 1])\n        \n        return blocks\n\n    results = []\n    for case in test_cases:\n        result = find_blocks(case)\n        results.append(result)\n\n    # Final print statement in the exact required format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}