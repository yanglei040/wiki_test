{
    "hands_on_practices": [
        {
            "introduction": "在进行复杂分析之前，一个基本问题是基因的表达是否呈现出任何空间格局。Moran's I 统计量是空间统计学的基石，它使我们能够量化空间自相关，判断相似的表达值是聚集在一起还是分散开来。本练习将带你从头开始计算这一关键指标，从而建立对如何检验数据中非随机空间组织的基本理解 。",
            "id": "2430178",
            "problem": "在一个简化的空间转录组学（ST）分析中，考虑一个在 $2 \\times 2$ 网格中排列的4个空间位点（标记为$1, 2, 3, 4$）上测量的组织切片。无向空间邻接性由对角线为零的对称空间权重矩阵 $W$ 编码：\n$$\nW \\;=\\; \\begin{pmatrix}\n0  1  1  0 \\\\\n1  0  0  1 \\\\\n1  0  0  1 \\\\\n0  1  1  0\n\\end{pmatrix}.\n$$\n一个基因集包含两个基因 $g_1$ 和 $g_2$。它们在4个位点上的归一化表达值如下：\n$$\ng_1: \\;(8,\\;7,\\;2,\\;3), \\qquad g_2: \\;(10,\\;9,\\;1,\\;2).\n$$\n定义位点基因集表达量 $x_i$ 为位点 $i$ 上两个基因表达量的算术平均值，即 $x_i = \\frac{1}{2}\\left(g_1(i) + g_2(i)\\right)$。令 $\\bar{x}$ 表示所有位点上 $x_i$ 的平均值。使用Moran’s $I$ 对单个变量在固定空间权重矩阵上未经行标准化的传统定义，\n$$\nI \\;=\\; \\frac{n}{S_0} \\cdot \\frac{\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}\\,\\bigl(x_i - \\bar{x}\\bigr)\\bigl(x_j - \\bar{x}\\bigr)}{\\sum_{i=1}^{n} \\bigl(x_i - \\bar{x}\\bigr)^2},\n$$\n其中 $n = 4$ 且 $S_0 = \\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}$，计算基因集平均表达量的Moran’s $I$统计量。将最终的Moran’s $I$表示为一个精确的简化分数（无量纲）。不要对答案进行四舍五入。",
            "solution": "问题陈述已经过严格验证。它内容完整，在应用于生物信息学的空间统计学领域有科学依据，并且在数学上是适定的。所有必要的数据和定义都已提供，没有歧义或矛盾。因此，该问题是有效的，我们继续进行完整、合理的解答。\n\n任务是计算给定基因集在 $n=4$ 个空间位点上的平均表达量的Moran's $I$统计量。Moran's $I$的公式如下：\n$$\nI \\;=\\; \\frac{n}{S_0} \\cdot \\frac{\\sum_{i=1}^{n}\\sum_{j=1}^{n} w_{ij}\\,\\bigl(x_i - \\bar{x}\\bigr)\\bigl(x_j - \\bar{x}\\bigr)}{\\sum_{i=1}^{n} \\bigl(x_i - \\bar{x}\\bigr)^2}\n$$\n\n首先，我们计算位点基因集表达量 $x_i$，它是每个位点 $i$ 上基因 $g_1$ 和 $g_2$ 表达量的算术平均值。基因表达值以位点 $1, 2, 3, 4$ 的向量形式给出：\n$$\ng_1: \\;(8,\\;7,\\;2,\\;3) \\\\\ng_2: \\;(10,\\;9,\\;1,\\;2)\n$$\n各个位点的平均表达量 $x_i$ 为：\n$$\nx_1 = \\frac{1}{2}(g_1(1) + g_2(1)) = \\frac{1}{2}(8 + 10) = 9 \\\\\nx_2 = \\frac{1}{2}(g_1(2) + g_2(2)) = \\frac{1}{2}(7 + 9) = 8 \\\\\nx_3 = \\frac{1}{2}(g_1(3) + g_2(3)) = \\frac{1}{2}(2 + 1) = \\frac{3}{2} \\\\\nx_4 = \\frac{1}{2}(g_1(4) + g_2(4)) = \\frac{1}{2}(3 + 2) = \\frac{5}{2}\n$$\n基因集表达量的向量为 $X = \\begin{pmatrix} 9  8  \\frac{3}{2}  \\frac{5}{2} \\end{pmatrix}^T$。\n\n接下来，我们计算所有 $n=4$ 个位点上的平均表达量 $\\bar{x}$：\n$$\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i = \\frac{1}{4} \\left(9 + 8 + \\frac{3}{2} + \\frac{5}{2}\\right) = \\frac{1}{4} \\left(17 + \\frac{8}{2}\\right) = \\frac{1}{4}(17 + 4) = \\frac{21}{4}\n$$\n\n现在，我们计算每个位点的表达量与平均值之间的偏差 $z_i = x_i - \\bar{x}$：\n$$\nz_1 = 9 - \\frac{21}{4} = \\frac{36 - 21}{4} = \\frac{15}{4} \\\\\nz_2 = 8 - \\frac{21}{4} = \\frac{32 - 21}{4} = \\frac{11}{4} \\\\\nz_3 = \\frac{3}{2} - \\frac{21}{4} = \\frac{6 - 21}{4} = -\\frac{15}{4} \\\\\nz_4 = \\frac{5}{2} - \\frac{21}{4} = \\frac{10 - 21}{4} = -\\frac{11}{4}\n$$\n令 $Z$ 为这些偏差的列向量：$Z = \\begin{pmatrix} \\frac{15}{4}  \\frac{11}{4}  -\\frac{15}{4}  -\\frac{11}{4} \\end{pmatrix}^T$。\n\n然后我们计算Moran's $I$分数的分母，即偏差的平方和：\n$$\n\\sum_{i=1}^{4} (x_i - \\bar{x})^2 = \\sum_{i=1}^{4} z_i^2 = \\left(\\frac{15}{4}\\right)^2 + \\left(\\frac{11}{4}\\right)^2 + \\left(-\\frac{15}{4}\\right)^2 + \\left(-\\frac{11}{4}\\right)^2 \\\\\n= \\frac{225}{16} + \\frac{121}{16} + \\frac{225}{16} + \\frac{121}{16} = \\frac{2 \\times (225 + 121)}{16} = \\frac{2 \\times 346}{16} = \\frac{346}{8} = \\frac{173}{4}\n$$\n\n接下来，我们计算分子中的各项。首先，$S_0$ 是矩阵 $W$ 中所有权重的总和：\n$$\nW = \\begin{pmatrix}\n0  1  1  0 \\\\\n1  0  0  1 \\\\\n1  0  0  1 \\\\\n0  1  1  0\n\\end{pmatrix}\n$$\n$$\nS_0 = \\sum_{i=1}^{4}\\sum_{j=1}^{4} w_{ij} = 1+1+1+1+1+1+1+1 = 8\n$$\n分子中的二次型可以用矩阵表示法写为 $Z^T W Z$：\n$$\n\\sum_{i=1}^{4}\\sum_{j=1}^{4} w_{ij}\\,(x_i - \\bar{x})(x_j - \\bar{x}) = Z^T W Z\n$$\n我们首先计算乘积 $W Z$：\n$$\nW Z = \\begin{pmatrix}\n0  1  1  0 \\\\\n1  0  0  1 \\\\\n1  0  0  1 \\\\\n0  1  1  0\n\\end{pmatrix}\n\\begin{pmatrix}\n15/4 \\\\\n11/4 \\\\\n-15/4 \\\\\n-11/4\n\\end{pmatrix} =\n\\begin{pmatrix}\n(1)(\\frac{11}{4}) + (1)(-\\frac{15}{4}) \\\\\n(1)(\\frac{15}{4}) + (1)(-\\frac{11}{4}) \\\\\n(1)(\\frac{15}{4}) + (1)(-\\frac{11}{4}) \\\\\n(1)(\\frac{11}{4}) + (1)(-\\frac{15}{4})\n\\end{pmatrix} =\n\\begin{pmatrix}\n-4/4 \\\\\n4/4 \\\\\n4/4 \\\\\n-4/4\n\\end{pmatrix} =\n\\begin{pmatrix}\n-1 \\\\\n1 \\\\\n1 \\\\\n-1\n\\end{pmatrix}\n$$\n现在我们计算最终的二次型：\n$$\nZ^T W Z = \\begin{pmatrix} \\frac{15}{4}  \\frac{11}{4}  -\\frac{15}{4}  -\\frac{11}{4} \\end{pmatrix}\n\\begin{pmatrix}\n-1 \\\\\n1 \\\\\n1 \\\\\n-1\n\\end{pmatrix} \\\\\n= \\left(\\frac{15}{4}\\right)(-1) + \\left(\\frac{11}{4}\\right)(1) + \\left(-\\frac{15}{4}\\right)(1) + \\left(-\\frac{11}{4}\\right)(-1) \\\\\n= -\\frac{15}{4} + \\frac{11}{4} - \\frac{15}{4} + \\frac{11}{4} = \\frac{-15+11-15+11}{4} = \\frac{-8}{4} = -2\n$$\n\n最后，我们将所有计算出的值代入Moran's $I$公式：\n$$\nI = \\frac{n}{S_0} \\cdot \\frac{Z^T W Z}{\\sum z_i^2} = \\frac{4}{8} \\cdot \\frac{-2}{173/4} = \\frac{1}{2} \\cdot \\frac{-2 \\times 4}{173} = \\frac{1}{2} \\cdot \\frac{-8}{173} = -\\frac{4}{173}\n$$\n结果是按要求给出的精确、简化的分数。负值表示给定基因集表达量存在负空间自相关，意味着相邻位点倾向于具有不相似的表达值。",
            "answer": "$$\n\\boxed{-\\frac{4}{173}}\n$$"
        },
        {
            "introduction": "细胞深受其邻居的影响，这种局部环境可以驱动同一细胞类型内出现不同的细胞状态。本实践介绍了一种探索这些微环境效应的强大方法，即根据细胞邻居的身份将其分为“边界”或“内部”细胞。通过实现这种分类并进行差异表达分析，你将学到一个实用的工作流程，用以识别与组织界面和细胞通讯热点相关的基因 。",
            "id": "2430130",
            "problem": "给定一组空间分辨的信使核糖核酸 (mRNA) 表达量测量值和单个细胞的二维 (2D) 坐标，考虑一个由整数 $t^\\star$ 标记的固定目标细胞类型。令 $X \\in \\mathbb{R}^{n \\times g}$ 表示非负表达矩阵，其包含 $n$ 行 (细胞) 和 $g$ 列 (基因)，其中条目 $x_{ij}$ 是基因 $j$ 在细胞 $i$ 中的表达量。令 $C \\in \\mathbb{R}^{n \\times 2}$ 表示坐标矩阵，其中第 $i$ 行给出细胞 $i$ 的二维位置。令 $T \\in \\{0,1,2,\\dots\\}^n$ 为整数细胞类型标签的向量。所有索引均从零开始；基因由 $j \\in \\{0,1,\\dots,g-1\\}$ 索引，细胞由 $i \\in \\{0,1,\\dots,n-1\\}$ 索引。\n\n将细胞 $i$ 的 $k$-最近邻 (KNN) 定义为恰好 $k$ 个其他细胞的不同索引的集合，这些细胞在坐标矩阵 $C$ 中与细胞 $i$ 的欧几里得距离最小。细胞 $i$ 和 $i'$ 之间的欧几里得距离为\n$$\nd(i,i') = \\sqrt{(C_{i,0} - C_{i',0})^2 + (C_{i,1} - C_{i',1})^2}.\n$$\n如果在第 $k$ 小的距离上出现并列，则通过对候选邻居按序对 $(d(i,i'), i')$ 进行升序字典序（距离优先，然后是索引）排序来确定性地打破并列，然后取前 $k$ 个索引。对于固定的 $t^\\star$，如果一个 $T_i = t^\\star$ 的细胞 $i$ 的 $k$-最近邻中至少有一个的标签不同于 $t^\\star$，则该细胞被称为边界细胞。如果一个 $T_i = t^\\star$ 的细胞 $i$ 的所有 $k$-最近邻的标签都恰好是 $t^\\star$，则该细胞被称为内部细胞。\n\n对于每个基因 $j$，定义边界集合 $B = \\{ i \\in \\{0,\\dots,n-1\\} : T_i = t^\\star \\text{ and } i \\text{ is boundary} \\}$ 和内部集合 $I = \\{ i \\in \\{0,\\dots,n-1\\} : T_i = t^\\star \\text{ and } i \\text{ is interior} \\}$。令\n$$\n\\mu_B(j) = \\frac{1}{|B|} \\sum_{i \\in B} x_{ij}, \\quad \\mu_I(j) = \\frac{1}{|I|} \\sum_{i \\in I} x_{ij},\n$$\n当 $|B| \\ge 1$ 且 $|I| \\ge 1$ 时。给定一个阈值 $\\tau > 0$，基因 $j$ 在（相同类型 $t^\\star$ 内的）边界细胞和内部细胞之间被称为差异表达 (DE)，当且仅当 $|B| \\ge 1$，$|I| \\ge 1$，且\n$$\n|\\mu_B(j) - \\mu_I(j)| \\ge \\tau.\n$$\n如果 $|B| = 0$ 或 $|I| = 0$，则没有基因被称为 DE，该测试用例的输出必须是空列表。\n\n你的任务是实现一个程序，对于每个提供的测试用例，计算满足上述 DE 标准的基因索引 $j$ 的排序列表。最终的程序输出必须将所有测试用例的结果聚合到单行中，该行包含一个由方括号括起来的逗号分隔列表序列，例如 $[[a],[b],[c]]$（在实际程序输出中没有空格）。\n\n测试套件（三个测试用例）：\n\n测试用例 1：\n- 参数：$t^\\star = 0$, $k = 2$, $\\tau = 3$。\n- 坐标：\n$$\nC = \\begin{bmatrix}\n0  0 \\\\\n1  0 \\\\\n2  0 \\\\\n1  1 \\\\\n2  1 \\\\\n3  0 \\\\\n0  1\n\\end{bmatrix}.\n$$\n- 标签：\n$$\nT = \\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 0\n\\end{bmatrix}.\n$$\n- 表达矩阵 ($n=7$, $g=3$)：\n$$\nX = \\begin{bmatrix}\n2  5  8 \\\\\n2  5  8 \\\\\n10  5  1 \\\\\n9  5  2 \\\\\n3  5  7 \\\\\n4  5  6 \\\\\n2  5  8\n\\end{bmatrix}.\n$$\n\n测试用例 2：\n- 参数：$t^\\star = 0$, $k = 2$, $\\tau = 3$。\n- 坐标：\n$$\nC = \\begin{bmatrix}\n0  0 \\\\\n0  1 \\\\\n0  2 \\\\\n10  0 \\\\\n10  1 \\\\\n10  2\n\\end{bmatrix}.\n$$\n- 标签：\n$$\nT = \\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 1\n\\end{bmatrix}.\n$$\n- 表达矩阵 ($n=6$, $g=2$)：\n$$\nX = \\begin{bmatrix}\n1  1 \\\\\n2  2 \\\\\n3  3 \\\\\n4  4 \\\\\n5  5 \\\\\n6  6\n\\end{bmatrix}.\n$$\n\n测试用例 3：\n- 参数：$t^\\star = 0$, $k = 1$, $\\tau = 3$。\n- 坐标：\n$$\nC = \\begin{bmatrix}\n0  0 \\\\\n1  0 \\\\\n0  1 \\\\\n-1  0\n\\end{bmatrix}.\n$$\n- 标签：\n$$\nT = \\begin{bmatrix}\n0 \\\\ 1 \\\\ 0 \\\\ 0\n\\end{bmatrix}.\n$$\n- 表达矩阵 ($n=4$, $g=2$)：\n$$\nX = \\begin{bmatrix}\n9  3 \\\\\n4  4 \\\\\n1  3 \\\\\n1  3\n\\end{bmatrix}.\n$$\n\n要求的最终输出格式：你的程序必须生成仅一行内容，该行包含所有测试用例列表的结果，以逗号分隔并用方括号括起来，且无空格；例如，如果三个答案是列表 $L_1$、$L_2$ 和 $L_3$，则打印 $[L_1,L_2,L_3]$。每个 $L_i$ 都必须是一个按升序排列的、从零开始的基因索引列表。",
            "solution": "该问题被评估为**有效**。它在计算生物学领域，特别是在空间转录组学分析方面，具有科学依据。所提供的定义在数学上是精确和客观的，从而能够得出一个唯一且可验证的解。该问题是适定的，提供了所有必要的数据和约束条件，包括用于最近邻识别的确定性平局打破规则。问题陈述中没有矛盾、歧义或事实错误。\n\n解决方案通过遵循一系列定义明确的计算步骤来实现。对于每个测试用例，我们给定一组细胞坐标 $C \\in \\mathbb{R}^{n \\times 2}$、一个表达矩阵 $X \\in \\mathbb{R}^{n \\times g}$、一个细胞类型标签向量 $T \\in \\{0,1,2,\\dots\\}^n$、一个目标细胞类型 $t^\\star$、一个邻居数 $k$ 和一个差异表达阈值 $\\tau > 0$。目标是找出在 $t^\\star$ 类型的边界细胞和内部细胞之间差异表达的所有基因。\n\n该算法按以下步骤进行：\n\n1.  **目标细胞和最近邻的识别**：\n    首先，我们识别目标类型 $t^\\star$ 的细胞索引集合，即 $S_{t^\\star} = \\{ i \\mid T_i = t^\\star \\}$。对于每个细胞 $i \\in S_{t^\\star}$，我们必须找到它的 $k$-最近邻 (KNN)。此过程始于计算从细胞 $i$ 到每个其他细胞 $i' \\neq i$ 的欧几里得距离 $d(i,i') = \\sqrt{(C_{i,0} - C_{i',0})^2 + (C_{i,1} - C_{i',1})^2}$。为了对所有细胞高效地执行此操作，我们可以预先计算一个 $n \\times n$ 的成对距离矩阵。问题指定了一个确定性的平局打破规则：如果在第 $k$ 个位置有多个细胞等距，则候选者按序对 $(d(i,i'), i')$ 进行字典序排序，并选择前 $k$ 个。这确保了每个细胞都有一组唯一的邻居。在计算上，这是通过基于主键（距离）和次键（细胞索引）执行字典序排序来实现的。\n\n2.  **目标细胞的分类**：\n    一旦识别出细胞 $i \\in S_{t^\\star}$ 的 $k$-最近邻，我们将其分类为边界细胞或内部细胞。令 $N_i$ 为细胞 $i$ 的 $k$-最近邻的索引集。\n    -   如果所有邻居 $i' \\in N_i$ 都具有与细胞 $i$ 相同的标签（即，对于所有 $i' \\in N_i$，$T_{i'} = t^\\star$），则细胞 $i$ 被分类为**内部**细胞。\n    -   如果至少有一个邻居 $i' \\in N_i$ 具有不同的标签（即，$T_{i'} \\neq t^\\star$），则细胞 $i$ 被分类为**边界**细胞。\n    此过程将目标细胞集 $S_{t^\\star}$ 划分为边界集 $B$ 和内部集 $I$。\n\n3.  **差异表达分析**：\n    仅当边界集 $B$ 和内部集 $I$ 均非空时（即 $|B| \\ge 1$ 且 $|I| \\ge 1$），分析才会进行。如果任一集合为空，则没有基因被认为是差异表达 (DE) 的，结果为空列表。\n    如果两个集合都非空，我们计算每个基因 $j \\in \\{0, \\dots, g-1\\}$ 在边界和内部细胞群体中的平均表达量：\n    $$\n    \\mu_B(j) = \\frac{1}{|B|} \\sum_{i \\in B} x_{ij}\n    $$\n    $$\n    \\mu_I(j) = \\frac{1}{|I|} \\sum_{i \\in I} x_{ij}\n    $$\n    如果这些平均表达值之间的绝对差达到或超过给定阈值 $\\tau$，则基因 $j$ 被识别为差异表达：\n    $$\n    |\\mu_B(j) - \\mu_I(j)| \\ge \\tau\n    $$\n\n4.  **最终结果**：\n    收集所有满足 DE 标准的基因的索引。每个测试用例的结果索引列表按升序排序。最终输出是这些列表的聚合。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"t_star\": 0, \"k\": 2, \"tau\": 3.0,\n            \"C\": np.array([\n                [0, 0], [1, 0], [2, 0], [1, 1], [2, 1], [3, 0], [0, 1]\n            ]),\n            \"T\": np.array([0, 0, 0, 0, 1, 1, 0]),\n            \"X\": np.array([\n                [2, 5, 8], [2, 5, 8], [10, 5, 1], [9, 5, 2],\n                [3, 5, 7], [4, 5, 6], [2, 5, 8]\n            ])\n        },\n        {\n            \"t_star\": 0, \"k\": 2, \"tau\": 3.0,\n            \"C\": np.array([\n                [0, 0], [0, 1], [0, 2], [10, 0], [10, 1], [10, 2]\n            ]),\n            \"T\": np.array([0, 0, 0, 1, 1, 1]),\n            \"X\": np.array([\n                [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6]\n            ])\n        },\n        {\n            \"t_star\": 0, \"k\": 1, \"tau\": 3.0,\n            \"C\": np.array([\n                [0, 0], [1, 0], [0, 1], [-1, 0]\n            ]),\n            \"T\": np.array([0, 1, 0, 0]),\n            \"X\": np.array([\n                [9, 3], [4, 4], [1, 3], [1, 3]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_spatial_de(\n            case[\"t_star\"], case[\"k\"], case[\"tau\"],\n            case[\"C\"], case[\"T\"], case[\"X\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required, with no spaces.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef analyze_spatial_de(t_star, k, tau, C, T, X):\n    \"\"\"\n    Analyzes a single spatial transcriptomics dataset to find differentially\n    expressed genes between boundary and interior cells of a target type.\n    \"\"\"\n    n, g = X.shape\n    \n    # Compute pairwise Euclidean distance matrix\n    # C is shape (n, 2). Reshape for broadcasting to (n, 1, 2) and (1, n, 2).\n    # The difference is (n, n, 2), representing coordinate differences.\n    # Sum squares along the coordinate axis and take sqrt.\n    diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n\n    # Exclude self-neighbors by setting diagonal distance to infinity.\n    np.fill_diagonal(dist_matrix, np.inf)\n\n    target_cell_indices = np.where(T == t_star)[0]\n    \n    boundary_cells = []\n    interior_cells = []\n    \n    all_indices = np.arange(n)\n\n    for i in target_cell_indices:\n        distances_from_i = dist_matrix[i, :]\n        \n        # Lexicographical sort on (distance, index) to break ties deterministically.\n        # np.lexsort sorts by the last key first.\n        sorted_neighbor_indices = np.lexsort((all_indices, distances_from_i))\n        \n        knn_indices = sorted_neighbor_indices[:k]\n        neighbor_labels = T[knn_indices]\n        \n        # If all neighbors have the same label as the target cell, it's interior.\n        if np.all(neighbor_labels == t_star):\n            interior_cells.append(i)\n        else:\n            boundary_cells.append(i)\n            \n    # If either set is empty, no DE genes can be found.\n    if not boundary_cells or not interior_cells:\n        return []\n\n    # Calculate mean expression for boundary and interior cells\n    X_boundary = X[boundary_cells, :]\n    X_interior = X[interior_cells, :]\n    \n    mu_B = np.mean(X_boundary, axis=0)\n    mu_I = np.mean(X_interior, axis=0)\n    \n    # Identify DE genes based on the threshold tau\n    diff_expression = np.abs(mu_B - mu_I)\n    de_gene_indices = np.where(diff_expression >= tau)[0]\n    \n    # The result must be a sorted list of indices. np.where provides this.\n    return de_gene_indices.tolist()\n\nsolve()\n```"
        },
        {
            "introduction": "超越静态模式，空间转录组学的一个关键目标是推断细胞间通讯的动态过程。本练习将指导你实现一个量化模型，该模型通过整合配体-受体表达与细胞间的物理距离来估算通讯强度。掌握这项实践将使你能够构建和解释细胞间相互作用网络，这是理解组织功能性结构的关键一步 。",
            "id": "2430164",
            "problem": "在空间转录组学背景下，您将获得一个用于细胞间通讯的形式化模型。存在 $N$ 个细胞，索引为 $i \\in \\{1,\\dots,N\\}$，每个细胞都位于一个二维坐标 $c_i \\in \\mathbb{R}^2$ 处。对于每个细胞 $i$，存在一个非负配体丰度向量 $L_i \\in \\mathbb{R}_{\\ge 0}^K$ 和一个非负受体丰度向量 $R_i \\in \\mathbb{R}_{\\ge 0}^K$，它们定义在相同的 $K$ 个配体-受体对上。对于一个固定的长度尺度参数 $\\lambda \\in \\mathbb{R}_{>0}$，在 $N$ 个细胞上定义一个有向加权图，从 $i$ 到 $j$ 的边权重由下式给出：\n$$\nw_{i \\to j} =\n\\begin{cases}\n\\left(\\sum_{k=1}^{K} L_{i,k}\\,R_{j,k}\\right)\\exp\\!\\left(-\\dfrac{\\lVert c_i-c_j\\rVert_2}{\\lambda}\\right),  i \\ne j \\\\\n0,  i=j\n\\end{cases}\n$$\n对于一个指定的目标细胞索引 $t \\in \\{1,\\dots,N\\}$，定义到 $t$ 的总传入通讯为：\n$$\nT_t \\;=\\; \\sum_{\\substack{i=1\\\\ i\\ne t}}^{N} w_{i \\to t}.\n$$\n您的任务是为以下每个测试用例计算 $T_t$。每个输出值必须四舍五入到小数点后 $6$ 位作为小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3]$），结果的顺序与下面的测试用例相同。\n\n测试套件：\n\n- 测试用例 $1$：\n  - $N=3$，$K=2$，$\\lambda=2$。\n  - 坐标：$c_1=(0,0)$，$c_2=(1,0)$，$c_3=(0,2)$。\n  - 配体：$L_1=(2,1)$，$L_2=(1,3)$，$L_3=(0,2)$。\n  - 受体：$R_1=(1,0)$，$R_2=(2,1)$，$R_3=(1,1)$。\n  - 目标索引：$t=2$。\n\n- 测试用例 $2$：\n  - $N=4$，$K=1$，$\\lambda=0.5$。\n  - 坐标：$c_1=(0,0)$，$c_2=(0,1)$，$c_3=(0,2)$，$c_4=(10,0)$。\n  - 配体：$L_1=(0)$，$L_2=(5)$，$L_3=(1)$，$L_4=(2)$。\n  - 受体：$R_1=(3)$，$R_2=(0)$，$R_3=(1)$，$R_4=(4)$。\n  - 目标索引：$t=3$。\n\n- 测试用例 $3$：\n  - $N=3$，$K=3$，$\\lambda=1$。\n  - 坐标：$c_1=(1,1)$，$c_2=(1,1)$，$c_3=(2,1)$。\n  - 配体：$L_1=(1,0,2)$，$L_2=(0,1,1)$，$L_3=(2,2,0)$。\n  - 受体：$R_1=(0,1,1)$，$R_2=(1,0,2)$，$R_3=(2,1,1)$。\n  - 目标索引：$t=1$。\n\n最终输出格式：\n\n- 您的程序必须输出单行：一个列表 $[T_1,T_2,T_3]$，其中每个 $T_\\ell$ 是测试用例 $\\ell$ 中指定目标细胞的总传入通讯的四舍五入值（保留 $6$ 位小数），顺序与上面列出的一致。不应打印额外的字符、列表中规定以外的空格或换行符。",
            "solution": "问题陈述已经过分析并被确定为有效。它具有科学依据，定义明确，客观，并包含唯一解所需的所有必要信息。所提出的模型是配体-受体介导的细胞间通讯在空间背景下的一个标准（尽管是简化的）数学公式，常用于计算生物学。测试用例 3 中存在共置细胞是所定义模型中的一个有效边缘情况，不构成矛盾或使其无效的缺陷。\n\n任务是计算到指定目标细胞 $t$ 的总传入通讯 $T_t$。该量被定义为系统中所有其他细胞的所有传入通讯权重之和。公式如下：\n$$\nT_t = \\sum_{\\substack{i=1\\\\ i \\ne t}}^{N} w_{i \\to t}\n$$\n其中 $N$ 是细胞总数。从源细胞 $i$ 到目标细胞 $j$ 的有向边权重 $w_{i \\to j}$ 定义为：\n$$\nw_{i \\to j} = \\left(\\sum_{k=1}^{K} L_{i,k}\\,R_{j,k}\\right)\\exp\\!\\left(-\\dfrac{\\lVert c_i-c_j\\rVert_2}{\\lambda}\\right) \\quad \\text{for } i \\ne j\n$$\n这里，$L_i \\in \\mathbb{R}_{\\ge 0}^K$ 是细胞 $i$ 的配体丰度向量，$R_j \\in \\mathbb{R}_{\\ge 0}^K$ 是细胞 $j$ 的受体丰度向量，$c_i, c_j \\in \\mathbb{R}^2$ 是它们各自的坐标，$\\lambda \\in \\mathbb{R}_{0}$ 是一个长度尺度参数，而 $K$ 是配体-受体对的数量。\n\n权重 $w_{i \\to j}$ 可以被概念化为两个项的乘积：一个相互作用势能和一个空间衰减因子。\n相互作用势能 $I_{i \\to j} = \\sum_{k=1}^{K} L_{i,k}\\,R_{j,k}$ 是点积 $L_i \\cdot R_j$。它模拟了两个细胞之间所有可能的配体-受体结合的总强度。\n空间衰减因子 $S_{i \\to j} = \\exp(-\\lVert c_i-c_j\\rVert_2 / \\lambda)$ 模拟了信号随着细胞间欧几里得距离 $\\lVert c_i-c_j\\rVert_2$ 增加而衰减的情况。\n\n我们现在将为三个指定的测试用例中的每一个计算 $T_t$。\n\n**测试用例 $1$**\n给定参数：$N=3$，$K=2$，$\\lambda=2$，以及目标细胞 $t=2$。\n坐标：$c_1=(0,0)$，$c_2=(1,0)$，$c_3=(0,2)$。\n配体：$L_1=(2,1)$，$L_2=(1,3)$，$L_3=(0,2)$。\n受体：$R_1=(1,0)$，$R_2=(2,1)$，$R_3=(1,1)$。\n\n到细胞 $t=2$ 的总传入通讯为 $T_2 = w_{1 \\to 2} + w_{3 \\to 2}$。\n首先，我们计算从细胞 $i=1$ 到目标 $t=2$ 的权重 $w_{1 \\to 2}$：\n相互作用势能为 $I_{1 \\to 2} = L_1 \\cdot R_2 = (2)(2) + (1)(1) = 5$。\n距离为 $d_{12} = \\lVert c_1-c_2\\rVert_2 = \\lVert (0,0)-(1,0)\\rVert_2 = \\sqrt{(0-1)^2 + (0-0)^2} = 1$。\n空间因子为 $S_{1 \\to 2} = \\exp(-d_{12}/\\lambda) = \\exp(-1/2)$。\n因此，$w_{1 \\to 2} = I_{1 \\to 2} \\cdot S_{1 \\to 2} = 5 \\exp(-0.5)$。\n\n接下来，我们计算从细胞 $i=3$ 到目标 $t=2$ 的权重 $w_{3 \\to 2}$：\n相互作用势能为 $I_{3 \\to 2} = L_3 \\cdot R_2 = (0)(2) + (2)(1) = 2$。\n距离为 $d_{32} = \\lVert c_3-c_2\\rVert_2 = \\lVert (0,2)-(1,0)\\rVert_2 = \\sqrt{(0-1)^2 + (2-0)^2} = \\sqrt{1+4} = \\sqrt{5}$。\n空间因子为 $S_{3 \\to 2} = \\exp(-d_{32}/\\lambda) = \\exp(-\\sqrt{5}/2)$。\n因此，$w_{3 \\to 2} = I_{3 \\to 2} \\cdot S_{3 \\to 2} = 2 \\exp(-\\sqrt{5}/2)$。\n\n总通讯为总和：$T_2 = 5 \\exp(-0.5) + 2 \\exp(-\\sqrt{5}/2) \\approx 3.68645353$。四舍五入到 $6$ 位小数，结果是 $3.686454$。\n\n**测试用例 $2$**\n给定参数：$N=4$，$K=1$，$\\lambda=0.5$，以及目标细胞 $t=3$。\n坐标：$c_1=(0,0)$，$c_2=(0,1)$，$c_3=(0,2)$，$c_4=(10,0)$。\n配体：$L_1=(0)$，$L_2=(5)$，$L_3=(1)$，$L_4=(2)$。\n受体：$R_1=(3)$，$R_2=(0)$，$R_3=(1)$，$R_4=(4)$。\n\n到细胞 $t=3$ 的总传入通讯为 $T_3 = w_{1 \\to 3} + w_{2 \\to 3} + w_{4 \\to 3}$。\n目标细胞的受体向量是 $R_3=(1)$。\n\n对于从细胞 $i=1$ 发出的权重 $w_{1 \\to 3}$：\n相互作用势能为 $I_{1 \\to 3} = L_1 \\cdot R_3 = (0)(1) = 0$。这意味着 $w_{1 \\to 3}=0$。\n\n对于从细胞 $i=2$ 发出的权重 $w_{2 \\to 3}$：\n相互作用势能为 $I_{2 \\to 3} = L_2 \\cdot R_3 = (5)(1) = 5$。\n距离为 $d_{23} = \\lVert c_2-c_3\\rVert_2 = \\lVert (0,1)-(0,2)\\rVert_2 = \\sqrt{(0-0)^2+(1-2)^2} = 1$。\n空间因子为 $S_{2 \\to 3} = \\exp(-d_{23}/\\lambda) = \\exp(-1/0.5) = \\exp(-2)$。\n因此，$w_{2 \\to 3} = 5 \\exp(-2)$。\n\n对于从细胞 $i=4$ 发出的权重 $w_{4 \\to 3}$：\n相互作用势能为 $I_{4 \\to 3} = L_4 \\cdot R_3 = (2)(1) = 2$。\n距离为 $d_{43} = \\lVert c_4-c_3\\rVert_2 = \\lVert (10,0)-(0,2)\\rVert_2 = \\sqrt{(10-0)^2+(0-2)^2} = \\sqrt{100+4} = \\sqrt{104}$。\n空间因子为 $S_{4 \\to 3} = \\exp(-d_{43}/\\lambda) = \\exp(-\\sqrt{104}/0.5) = \\exp(-2\\sqrt{104})$。\n因此，$w_{4 \\to 3} = 2 \\exp(-2\\sqrt{104})$。\n\n总通讯为总和：$T_3 = 0 + 5 \\exp(-2) + 2 \\exp(-2\\sqrt{104})$。$2 \\exp(-2\\sqrt{104})$ 这一项小到可以忽略不计。\n$T_3 \\approx 0.67667642$。四舍五入到 $6$ 位小数，结果是 $0.676676$。\n\n**测试用例 $3$**\n给定参数：$N=3$，$K=3$，$\\lambda=1$，以及目标细胞 $t=1$。\n坐标：$c_1=(1,1)$，$c_2=(1,1)$，$c_3=(2,1)$。\n配体：$L_1=(1,0,2)$，$L_2=(0,1,1)$，$L_3=(2,2,0)$。\n受体：$R_1=(0,1,1)$，$R_2=(1,0,2)$，$R_3=(2,1,1)$。\n\n到细胞 $t=1$ 的总传入通讯为 $T_1 = w_{2 \\to 1} + w_{3 \\to 1}$。\n目标细胞的受体向量是 $R_1=(0,1,1)$。\n\n对于从细胞 $i=2$ 发出的权重 $w_{2 \\to 1}$：\n相互作用势能为 $I_{2 \\to 1} = L_2 \\cdot R_1 = (0)(0) + (1)(1) + (1)(1) = 2$。\n距离为 $d_{21} = \\lVert c_2-c_1\\rVert_2 = \\lVert (1,1)-(1,1)\\rVert_2 = 0$。\n空间因子为 $S_{2 \\to 1} = \\exp(-d_{21}/\\lambda) = \\exp(-0/1) = \\exp(0) = 1$。\n因此，$w_{2 \\to 1} = 2 \\cdot 1 = 2$。\n\n对于从细胞 $i=3$ 发出的权重 $w_{3 \\to 1}$：\n相互作用势能为 $I_{3 \\to 1} = L_3 \\cdot R_1 = (2)(0) + (2)(1) + (0)(1) = 2$。\n距离为 $d_{31} = \\lVert c_3-c_1\\rVert_2 = \\lVert (2,1)-(1,1)\\rVert_2 = \\sqrt{(2-1)^2 + (1-1)^2} = 1$。\n空间因子为 $S_{3 \\to 1} = \\exp(-d_{31}/\\lambda) = \\exp(-1/1) = \\exp(-1)$。\n因此，$w_{3 \\to 1} = 2 \\exp(-1)$。\n\n总通讯为总和：$T_1 = 2 + 2 \\exp(-1) \\approx 2.73575888$。四舍五入到 $6$ 位小数，结果是 $2.735759$。\n\n总而言之，三个测试用例的计算结果如下：\n对于第一个用例（目标 $t=2$），其总传入通讯为 $T_2 \\approx 3.686454$。\n对于第二个用例（目标 $t=3$），其总传入通讯为 $T_3 \\approx 0.676676$。\n对于第三个用例（目标 $t=1$），其总传入通讯为 $T_1 \\approx 2.735759$。\n最终的程序实现了这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_total_incoming_communication(N, K, lambda_val, coords, ligands, receptors, target_index):\n    \"\"\"\n    Computes the total incoming communication T_t for a target cell t.\n    \"\"\"\n    total_comm = 0.0\n    # Adjust for 0-based indexing\n    t = target_index - 1\n    \n    c_t = coords[t]\n    R_t = receptors[t]\n    \n    for i in range(N):\n        if i == t:\n            continue\n            \n        c_i = coords[i]\n        L_i = ligands[i]\n        \n        # 1. Compute ligand-receptor interaction potential (dot product)\n        interaction = np.dot(L_i, R_t)\n        \n        # 2. Compute Euclidean distance\n        distance = np.linalg.norm(c_i - c_t)\n        \n        # 3. Compute spatial attenuation factor\n        spatial_factor = np.exp(-distance / lambda_val)\n        \n        # 4. Compute the edge weight w_{i - t}\n        w_i_to_t = interaction * spatial_factor\n        \n        # 5. Add to total incoming communication\n        total_comm += w_i_to_t\n        \n    return total_comm\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases according to the problem statement.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3, \"K\": 2, \"lambda\": 2.0, \"t\": 2,\n            \"coords\": np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 2.0]]),\n            \"ligands\": np.array([[2.0, 1.0], [1.0, 3.0], [0.0, 2.0]]),\n            \"receptors\": np.array([[1.0, 0.0], [2.0, 1.0], [1.0, 1.0]])\n        },\n        {\n            \"N\": 4, \"K\": 1, \"lambda\": 0.5, \"t\": 3,\n            \"coords\": np.array([[0.0, 0.0], [0.0, 1.0], [0.0, 2.0], [10.0, 0.0]]),\n            \"ligands\": np.array([[0.0], [5.0], [1.0], [2.0]]),\n            \"receptors\": np.array([[3.0], [0.0], [1.0], [4.0]])\n       },\n        {\n            \"N\": 3, \"K\": 3, \"lambda\": 1.0, \"t\": 1,\n            \"coords\": np.array([[1.0, 1.0], [1.0, 1.0], [2.0, 1.0]]),\n            \"ligands\": np.array([[1.0, 0.0, 2.0], [0.0, 1.0, 1.0], [2.0, 2.0, 0.0]]),\n            \"receptors\": np.array([[0.0, 1.0, 1.0], [1.0, 0.0, 2.0], [2.0, 1.0, 1.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_total_incoming_communication(\n            N=case[\"N\"],\n            K=case[\"K\"],\n            lambda_val=case[\"lambda\"],\n            coords=case[\"coords\"],\n            ligands=case[\"ligands\"],\n            receptors=case[\"receptors\"],\n            target_index=case[\"t\"]\n        )\n        # Round the result to 6 decimal places\n        results.append(round(result, 6))\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}