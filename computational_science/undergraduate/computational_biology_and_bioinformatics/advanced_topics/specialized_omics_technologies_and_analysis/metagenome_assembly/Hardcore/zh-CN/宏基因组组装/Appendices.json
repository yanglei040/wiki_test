{
    "hands_on_practices": [
        {
            "introduction": "宏基因组拼接的第一步通常会产生许多不连续的序列片段，我们称之为“重叠群”（contigs）。下一步的关键任务——“脚手架构建”（scaffolding），便是利用双端测序（paired-end）的读段信息将这些重叠群排列成正确的顺序和方向。在这个练习中，你将通过构建一个脚手架图来模拟这一过程，其中重叠群是节点，而连接它们的边的权重则由支持该连接的读段对数量决定。这是从片段化序列重建更完整基因组区域的基础步骤。",
            "id": "2405168",
            "problem": "给定一个有限的重叠群集合和一个有限的、在重叠群末端的双端 (PE) 读段映射集合。将支架推断问题建模为一个简单无向加权图。设重叠群集合表示为 $C=\\{1,2,\\dots,n\\}$，其中每个元素是一个整数标识符。设双端读段映射集合表示为 $P$，其中每个元素是一个有序六元组 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$，其分量如下：$c_1\\in C$，$c_2\\in C$，$e_1\\in\\{\\mathrm{L},\\mathrm{R}\\}$，$e_2\\in\\{\\mathrm{L},\\mathrm{R}\\}$，$s_1\\in\\{+,-\\}$，以及 $s_2\\in\\{+,-\\}$。符号 $\\mathrm{L}$ 表示重叠群的左端，$\\mathrm{R}$ 表示重叠群的右端；符号 $+$ 和 $-$ 分别表示相对于重叠群参考链的正向和反向读段方向。假设双端测序采用标准的内向片段方向模型（通常称为 FR）：当一个读段对中的一个读段以正向方向映射到一个右端，而另一个读段以反向方向映射到一个左端时，就在不同的重叠群之间产生了有效的连接。形式上，一个读段对 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$ 支持一个连接，当且仅当 $c_1\\neq c_2$ 且 $(e_1=\\mathrm{R}\\wedge s_1=+ \\wedge e_2=\\mathrm{L}\\wedge s_2=-)$ 或 $(e_1=\\mathrm{L}\\wedge s_1=- \\wedge e_2=\\mathrm{R}\\wedge s_2=+)$ 成立。\n\n定义支架图 $G=(V,E)$，其中 $V=C$。对于每个无序对 $\\{u,v\\}$（其中 $u,v\\in C$ 且 $u\\neq v$），定义边权重 $w(u,v)$ 为 $P$ 中根据上述规则支持 $u$ 和 $v$ 之间连接的读段对的数量。给定一个非负整数阈值参数 $\\tau$，当且仅当 $w(u,v)\\ge \\tau$ 时，在 $E$ 中包含一条连接 $u$ 和 $v$ 的无向边。$G$ 的输出表示必须是一个三元组列表，其中每个三元组是列表 $[u,v,w(u,v)]$ 且满足 $uv$，并且该三元组集合按 $(u,v)$ 的字典序升序排列。\n\n你的任务是编写一个程序，为以下每个测试用例构建相应的支架图，并为每个用例输出指定格式的、已排序的边三元组列表。将所有测试用例的结果按测试用例顺序汇总到一个列表中。\n\n测试用例 1：\n- 重叠群：$C=\\{1,2,3\\}$。\n- 阈值：$\\tau=2$。\n- 双端映射 $P$ 以以下六元组形式给出：\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,1,\\mathrm{R},+\\rangle$,\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{L},+,2,\\mathrm{R},-\\rangle$,\n  $\\langle 1,\\mathrm{R},+,3,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{R},+,1,\\mathrm{L},-\\rangle$。\n\n测试用例 2：\n- 重叠群：$C=\\{1,2\\}$。\n- 阈值：$\\tau=1$。\n- 双端映射 $P$：\n  $\\langle 1,\\mathrm{L},+,2,\\mathrm{R},-\\rangle$,\n  $\\langle 1,\\mathrm{R},+,1,\\mathrm{L},-\\rangle$。\n\n测试用例 3：\n- 重叠群：$C=\\{1,2,3,4\\}$。\n- 阈值：$\\tau=1$。\n- 双端映射 $P$：\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,1,\\mathrm{R},+\\rangle$,\n  $\\langle 2,\\mathrm{R},+,3,\\mathrm{L},-\\rangle$,\n  $\\langle 4,\\mathrm{L},-,3,\\mathrm{R},+\\rangle$,\n  $\\langle 3,\\mathrm{R},+,4,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{R},+,4,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{L},+,3,\\mathrm{R},-\\rangle$,\n  $\\langle 3,\\mathrm{R},+,3,\\mathrm{L},-\\rangle$。\n\n测试用例 4：\n- 重叠群：$C=\\{1,2,3\\}$。\n- 阈值：$\\tau=3$。\n- 双端映射 $P$：\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,1,\\mathrm{R},+\\rangle$,\n  $\\langle 1,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 1,\\mathrm{L},+,2,\\mathrm{R},-\\rangle$,\n  $\\langle 3,\\mathrm{R},+,2,\\mathrm{L},-\\rangle$,\n  $\\langle 2,\\mathrm{L},-,3,\\mathrm{R},+\\rangle$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个长度为 4 的列表。该列表的第 $i$ 个元素是测试用例 $i$ 的边三元组 $[u,v,w]$ 列表，并按 $(u,v)$ 排序。整行必须是一个用方括号括起来的列表，元素之间用逗号分隔，例如 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。输出中的所有标识符均为整数；不要打印任何字符串、单位或附加文本。",
            "solution": "该问题是有效的。它在科学上基于生物信息学的原理，特别是基因组组装，并且问题定义清晰、客观，阐述得很好。\n\n目标是基于一个重叠群集合 $C$ 和一个双端读段映射集合 $P$ 来构建一个支架图 $G=(V, E)$。图的顶点 $V$ 是重叠群本身。边 $E$ 及其对应的权重通过根据指定的生物学模型分析双端读段数据来确定。\n\n构建此图的算法流程概述如下：\n\n1.  **边权重的初始化**：该图是无向图，因此对于集合 $C=\\{1, 2, \\dots, n\\}$ 中每一对不同的重叠群的无序对 $\\{u, v\\}$，我们需要计算一个相关的权重 $w(u,v)$。完成此任务的合适数据结构是关联数组（或字典），它将边的规范表示（例如有序元组 $(\\min(u,v), \\max(u,v))$）映射到其整数权重。所有潜在的权重都隐式初始化为 $0$。\n\n2.  **处理双端读段映射**：我们遍历集合 $P$ 中提供的每个双端读段映射 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$。对于每个映射，我们必须确定它是否构成了两个不同重叠群之间的有效连接。\n\n3.  **连接支持的验证**：如果一个读段对遵循标准的内向片段方向模型（也称为 FR 模型），它就为支架连接提供了证据。问题精确地形式化了这一条件。一个读段对 $\\langle c_1,e_1,s_1,c_2,e_2,s_2\\rangle$ 支持重叠群 $c_1$ 和 $c_2$ 之间的连接，当且仅当满足两个标准：\n    a. 重叠群必须不同，即 $c_1 \\neq c_2$。在构建支架时，同一重叠群内部的映射将被忽略。\n    b. 映射配置必须匹配两种对称模式之一：\n        i.  $(e_1=\\mathrm{R} \\wedge s_1=+ \\wedge e_2=\\mathrm{L} \\wedge s_2=-)$：一个读段以正向方向映射到重叠群 $c_1$ 的右端，另一个读段以反向方向映射到重叠群 $c_2$ 的左端。\n        ii. $(e_1=\\mathrm{L} \\wedge s_1=- \\wedge e_2=\\mathrm{R} \\wedge s_2=+)$：对称情况，即一个读段映射到 $c_1$ 的左端（反向），另一个映射到 $c_2$ 的右端（正向）。\n    在物理上，这些模式表明重叠群 $c_1$ 和 $c_2$ 在源基因组中是相邻的，一个的右端靠近另一个的左端。\n\n4.  **权重聚合**：如果一个读段映射被验证为支持重叠群 $c_1$ 和 $c_2$ 之间的连接，我们就增加与这对重叠群关联的权重。使用规范表示，我们更新权重 $w(\\min(c_1, c_2), \\max(c_1, c_2))$。对 $P$ 中的所有映射重复此过程，为每个潜在连接聚合总证据。\n\n5.  **通过阈值化构建图**：处理完所有映射后，我们得到了一套完整的原始边权重。图 $G$ 的最终边集 $E$ 由给定的非负整数阈值 $\\tau$ 确定。当且仅当其聚合权重 $w(u, v) \\ge \\tau$ 时，边 $\\{u, v\\}$ 才被包含在 $E$ 中。此步骤过滤掉证据不足的连接，只保留那些由大量读段对支持的连接。\n\n6.  **生成输出**：图的最终表示要求为三元组 $[u, v, w(u,v)]$ 的列表，其中 $u  v$。此列表必须根据对 $(u, v)$ 按字典序升序排序。这可以通过遍历我们的权重字典的键（这些键已经是规范的并且可以排序）、根据阈值 $\\tau$ 进行筛选，并按指定格式格式化生成的边来完成。然后将所有测试用例的结果汇总到一个列表中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the scaffold graph construction problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"C\": {1, 2, 3}, \"tau\": 2, \"P\": [\n                (1, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 1, 'R', '+'),\n                (1, 'R', '+', 2, 'L', '-'),\n                (1, 'L', '+', 2, 'R', '-'),\n                (1, 'R', '+', 3, 'L', '-'),\n                (1, 'R', '+', 1, 'L', '-')\n            ]\n        },\n        {\n            \"C\": {1, 2}, \"tau\": 1, \"P\": [\n                (1, 'L', '+', 2, 'R', '-'),\n                (1, 'R', '+', 1, 'L', '-')\n            ]\n        },\n        {\n            \"C\": {1, 2, 3, 4}, \"tau\": 1, \"P\": [\n                (1, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 1, 'R', '+'),\n                (2, 'R', '+', 3, 'L', '-'),\n                (4, 'L', '-', 3, 'R', '+'),\n                (3, 'R', '+', 4, 'L', '-'),\n                (2, 'R', '+', 4, 'L', '-'),\n                (1, 'L', '+', 3, 'R', '-'),\n                (3, 'R', '+', 3, 'L', '-')\n            ]\n        },\n        {\n            \"C\": {1, 2, 3}, \"tau\": 3, \"P\": [\n                (1, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 1, 'R', '+'),\n                (1, 'R', '+', 2, 'L', '-'),\n                (1, 'L', '+', 2, 'R', '-'),\n                (3, 'R', '+', 2, 'L', '-'),\n                (2, 'L', '-', 3, 'R', '+')\n            ]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        tau = case[\"tau\"]\n        mappings = case[\"P\"]\n        weights = collections.defaultdict(int)\n\n        for mapping in mappings:\n            c1, e1, s1, c2, e2, s2 = mapping\n            \n            if c1 == c2:\n                continue\n\n            # A read pair supports a linkage if and only if c1 != c2 and \n            # one read maps to a right end (+) and the other to a left end (-),\n            # or vice versa.\n            valid_link_c1_to_c2 = (e1 == 'R' and s1 == '+' and e2 == 'L' and s2 == '-')\n            valid_link_c2_to_c1 = (e1 == 'L' and s1 == '-' and e2 == 'R' and s2 == '+')\n\n            # The problem can be interpreted as one mapping tuple can represent a link\n            # in either direction. e.g. mapping c1 to c2 or c2 to c1.\n            # So, we check for both configurations within a single mapping tuple.\n            if valid_link_c1_to_c2 or valid_link_c2_to_c1:\n                u, v = min(c1, c2), max(c1, c2)\n                weights[(u, v)] += 1\n\n        # Filter edges by threshold and sort\n        edge_list = []\n        # Sort keys for lexicographical order\n        sorted_keys = sorted(weights.keys())\n        \n        for u, v in sorted_keys:\n            w = weights[(u, v)]\n            if w >= tau:\n                edge_list.append([u, v, w])\n        \n        all_results.append(edge_list)\n\n    # Format the final output string to be completely space-free within lists.\n    outer_parts = []\n    for case_result in all_results:\n        inner_parts = []\n        for triple in case_result:\n            inner_parts.append(f\"[{triple[0]},{triple[1]},{triple[2]}]\")\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "将来自不同物种的基因组混合组装充满了挑战，而“嵌合体”（chimeric contigs）——即错误地将来自不同生物体的 DNA 连接在一起的序列——是一种常见的组装错误。本练习将引导你实现一个定量指标，通过检测重叠群上序列组成（$k$-mer 频率）和读段覆盖深度的突然变化来识别这些嵌合体。学习开发这类质量控制指标对于产出可靠的宏基因组研究结果至关重要。",
            "id": "2405143",
            "problem": "您的任务是定义并计算一个量化指标，通过联合评估连续组装序列（contig）的 $k$-mer 组成和其全长测序覆盖度的一致性，来衡量该序列是否可能为嵌合体。将一个 contig 视为一个长度为 $L$ 的字符串 $S$，其字母表为脱氧核糖核酸 (DNA) 字母表 $\\{A,C,G,T\\}$，由位置 $1,2,\\dots,L$ 索引。另有一个非负的每碱基覆盖度向量 $D \\in \\mathbb{R}_{\\ge 0}^L$，其分量 $D_j$ 表示位置 $j$ 的覆盖度。\n\n对于给定的正整数窗口长度 $W$ 和正整数 $k$-mer 长度 $k$，以及字母表大小 $|\\Sigma|=4$，定义如下：\n1. 将 contig 分割成 $M=\\left\\lfloor \\frac{L}{W} \\right\\rfloor$ 个长度相等的非重叠窗口：窗口 $i$ 覆盖位置 $((i-1)W+1)$ 到 $(iW)$，其中 $i \\in \\{1,2,\\dots,M\\}$。如果 $M  2$，按照约定，将最终得分定义为 $0$。\n2. 对每个窗口 $i$，定义 $k$-mer 计数函数 $c_i: \\Sigma^k \\to \\mathbb{N}_0$ 为每个精确的 $k$-mer（步幅为 $1$）完全包含在窗口内的出现次数。令 $N_i=\\max\\{W-k+1,0\\}$ 为当 $W \\ge k$ 时每个窗口中的 $k$-mer 位置数（否则为 $0$）。定义归一化 $k$-mer 频率向量 $p_i \\in \\mathbb{R}^{4^k}$ 为 $p_i(w)=\\frac{c_i(w)}{\\max\\{N_i,1\\}}$，其中 $w \\in \\Sigma^k$。\n3. 定义相邻窗口 $i$ 和 $(i+1)$ 之间的组成不一致性为欧几里得距离\n$$\nd_i=\\left\\|p_i-p_{i+1}\\right\\|_2=\\sqrt{\\sum_{w \\in \\Sigma^k}\\left(p_i(w)-p_{i+1}(w)\\right)^2}.\n$$\n使用分布的界限 $\\max d_i=\\sqrt{2}$ 对其进行归一化，并定义平均归一化组成不一致性\n$$\nI_{\\mathrm{comp}}=\\frac{1}{M-1}\\sum_{i=1}^{M-1}\\frac{d_i}{\\sqrt{2}}.\n$$\n4. 定义窗口 $i$ 内的平均覆盖度为\n$$\n\\bar{c}_i=\\frac{1}{W}\\sum_{j=(i-1)W+1}^{iW} D_j.\n$$\n定义相邻窗口 $i$ 和 $(i+1)$ 之间的相对覆盖度不一致性为\n$$\nr_i=\n\\begin{cases}\n0,  \\text{if }\\bar{c}_i+\\bar{c}_{i+1}=0 \\\\\n\\frac{\\left|\\bar{c}_{i+1}-\\bar{c}_i\\right|}{\\bar{c}_{i+1}+\\bar{c}_i},  \\text{otherwise.}\n\\end{cases}\n$$\n定义平均覆盖度不一致性\n$$\nI_{\\mathrm{cov}}=\\frac{1}{M-1}\\sum_{i=1}^{M-1} r_i.\n$$\n5. 定义嵌合性得分为凸组合\n$$\n\\mathrm{Score}=\\alpha I_{\\mathrm{comp}}+(1-\\alpha)I_{\\mathrm{cov}},\n$$\n其中 $\\alpha=\\frac{1}{2}$。\n\n计算以下每个测试用例的嵌合性得分。对于每个用例，除非另有说明，否则使用 $k=3$、窗口长度 $W=30$、如上所述的非重叠窗口以及 $\\alpha=\\frac{1}{2}$。所有序列均基于 $\\{A,C,G,T\\}$，所有覆盖度均为非负实数值。请完全按照规定构造序列和覆盖度向量：\n\n- 测试用例 1 (平衡组成和均匀覆盖度):\n  - 长度 $L_1=120$。\n  - 序列 $S_1$：无限周期性字符串 $\\text{\"ACGTACGT}\\dots\\text{\"}$ 的前 $L_1$ 个符号。\n  - 覆盖度 $D^{(1)}$: 对于所有 $j \\in \\{1,\\dots,L_1\\}$，$D^{(1)}_j=30$。\n\n- 测试用例 2 (中点处组成和覆盖度发生变化):\n  - 长度 $L_2=120$。\n  - 序列 $S_2$：位置 $1$ 到 $60$ 是无限周期性字符串 $\\text{\"GCGCGC}\\dots\\text{\"}$ 的前 $60$ 个符号；位置 $61$ 到 $120$ 是无限周期性字符串 $\\text{\"ATATAT}\\dots\\text{\"}$ 的前 $60$ 个符号。\n  - 覆盖度 $D^{(2)}$: 对于 $j \\in \\{1,\\dots,60\\}$，$D^{(2)}_j=40$；对于 $j \\in \\{61,\\dots,120\\}$，$D^{(2)}_j=10$。\n\n- 测试用例 3 (短 contig，少于两个窗口):\n  - 长度 $L_3=20$。\n  - 序列 $S_3$：无限周期性字符串 $\\text{\"ACGTACGT}\\dots\\text{\"}$ 的前 $L_3$ 个符号。\n  - 覆盖度 $D^{(3)}$: 对于所有 $j \\in \\{1,\\dots,L_3\\}$，$D^{(3)}_j=20$。\n\n- 测试用例 4 (两个窗口组成相同，覆盖度略有不同):\n  - 长度 $L_4=60$。\n  - 序列 $S_4$：位置 $1$ 到 $30$ 是无限周期性字符串 $\\text{\"ACGTACGT}\\dots\\text{\"}$ 的前 $30$ 个符号；位置 $31$ 到 $60$ 是同一个无限周期性字符串的前 $30$ 个符号。\n  - 覆盖度 $D^{(4)}$: 对于 $j \\in \\{1,\\dots,30\\}$，$D^{(4)}_j=20$；对于 $j \\in \\{31,\\dots,60\\}$，$D^{(4)}_j=22$。\n\n- 测试用例 5 (三个窗口，中间窗口组成发生变化，覆盖度均匀):\n  - 长度 $L_5=90$。\n  - 序列 $S_5$：位置 $1$ 到 $30$ 是无限周期性字符串 $\\text{\"ATATAT}\\dots\\text{\"}$ 的前 $30$ 个符号；位置 $31$ 到 $60$ 是无限周期性字符串 $\\text{\"GCGCGC}\\dots\\text{\"}$ 的前 $30$ 个符号；位置 $61$ 到 $90$ 是无限周期性字符串 $\\text{\"ATATAT}\\dots\\text{\"}$ 的前 $30$ 个符号。\n  - 覆盖度 $D^{(5)}$: 对于所有 $j \\in \\{1,\\dots,90\\}$，$D^{(5)}_j=30$。\n\n您的程序必须计算每个测试用例的嵌合性得分，并生成单行输出，其中包含一个逗号分隔的实数列表，该列表严格按照测试用例的顺序排列，并用方括号括起来。每个实数必须使用标准的四舍五入到最近的值（无需处理平局情况）的方法，保留 $6$ 位小数。因此，最终输出必须为 $[\\text{score}_1,\\text{score}_2,\\text{score}_3,\\text{score}_4,\\text{score}_5]$ 的形式，其中每个 $\\text{score}_i$ 都四舍五入到 $6$ 位小数。",
            "solution": "问题陈述具有科学依据，数学上定义明确且内部一致。它提供了一套完整的定义、参数和测试用例，用于计算 DNA contig 的确定性嵌合性得分。所定义的度量标准通过量化序列组成和测序覆盖度的不连续性，为宏基因组组装中识别嵌合序列提供了一种可行的方法。因此，该问题被认为是有效的。\n\n解决方案涉及对所提供公式的直接实现。对于每个测试用例，我们使用指定的参数计算嵌合性得分：$k$-mer 长度 $k=3$，窗口大小 $W=30$，以及凸组合权重 $\\alpha=\\frac{1}{2}$。\n\n算法的核心如下：\n1. 长度为 $L$ 的 contig 被划分为 $M=\\lfloor L/W \\rfloor$ 个非重叠窗口。如果 $M  2$，根据定义，得分为 $0$。\n2. 对于每个窗口 $i \\in \\{1, \\dots, M\\}$，我们计算一个归一化的 $k$-mer 频率向量 $p_i$ 和平均覆盖度 $\\bar{c}_i$。向量 $p_i$ 有 $4^k = 4^3 = 64$ 个分量。一个窗口中的 $k$-mer 数量为 $N_i = W-k+1 = 30-3+1 = 28$。\n3. 然后，我们计算相邻窗口 $i$ 和 $i+1$ 之间的两种不一致性，其中 $i \\in \\{1, \\dots, M-1\\}$：\n    a. 组成不一致性：$d_i = \\|p_i - p_{i+1}\\|_2$。\n    b. 相对覆盖度不一致性：$r_i = \\frac{|\\bar{c}_{i+1}-\\bar{c}_i|}{\\bar{c}_{i+1}+\\bar{c}_i}$，如果 $\\bar{c}_i+\\bar{c}_{i+1}=0$，则 $r_i=0$。\n4. 将这些值在所有 $M-1$ 个窗口过渡上取平均，得到 $I_{\\mathrm{comp}} = \\frac{1}{M-1}\\sum_{i=1}^{M-1}\\frac{d_i}{\\sqrt{2}}$ 和 $I_{\\mathrm{cov}} = \\frac{1}{M-1}\\sum_{i=1}^{M-1}r_i$。\n5. 最终得分为加权和：$\\mathrm{Score} = \\alpha I_{\\mathrm{comp}} + (1-\\alpha)I_{\\mathrm{cov}}$。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1:**\n- Contig 长度 $L_1=120$，窗口大小 $W=30$，因此我们有 $M = \\lfloor 120/30 \\rfloor = 4$ 个窗口。\n- 序列 $S_1$ 是 \"ACGT\" 的重复。每个窗口都是其他窗口的循环移位。在每个包含 28 个总 $k$-mer 的窗口内，每个 $k$-mer \"ACG\"、\"CGT\"、\"GTA\" 和 \"TAC\" 的出现次数为 7。所有其他 $k$-mer 的计数为 0。\n- 因此，所有窗口的归一化 $k$-mer 频率向量都相同：$p_1 = p_2 = p_3 = p_4$。这些向量中的每一个都有 4 个非零分量，每个分量的值为 $7/28 = 1/4$。\n- 组成不一致性为 $d_i = \\|p_i - p_{i+1}\\|_2 = 0$，其中 $i=1, 2, 3$。这得出 $I_{\\mathrm{comp}} = 0$。\n- 覆盖度 $D^{(1)}_j = 30$ 是均匀的。每个窗口的平均覆盖度为 $\\bar{c}_i = 30$。\n- 相对覆盖度不一致性对所有 $i$ 均为 $r_i = 0$。这得出 $I_{\\mathrm{cov}} = 0$。\n- 最终得分为 $\\mathrm{Score}_1 = \\frac{1}{2}(0) + \\frac{1}{2}(0) = 0$。\n\n**测试用例 2:**\n- Contig 长度 $L_2=120$，$W=30$，得到 $M=4$ 个窗口。\n- 窗口 1 和 2 由序列 \"GCGCGC...\" 组成，而窗口 3 和 4 由 \"ATATAT...\" 组成。\n- 对于窗口 1 和 2，唯一非零的 $k$-mer 频率是 \"GCG\" 和 \"CGC\"，每个频率为 $14/28 = 1/2$。因此，$p_1=p_2$。\n- 对于窗口 3 和 4，唯一非零的频率是 \"ATA\" 和 \"TAT\"，每个频率为 $14/28 = 1/2$。因此，$p_3=p_4$。\n- 组成不一致性为：\n    - $d_1 = \\|p_1-p_2\\|_2 = 0$。\n    - $d_2 = \\|p_2-p_3\\|_2 = \\sqrt{(1/2)^2 + (1/2)^2 + (-1/2)^2 + (-1/2)^2} = \\sqrt{4 \\cdot (1/4)} = 1$。$k$-mer 集合是不相交的。\n    - $d_3 = \\|p_3-p_4\\|_2 = 0$。\n- $I_{\\mathrm{comp}} = \\frac{1}{4-1} (\\frac{d_1}{\\sqrt{2}} + \\frac{d_2}{\\sqrt{2}} + \\frac{d_3}{\\sqrt{2}}) = \\frac{1}{3} (0 + \\frac{1}{\\sqrt{2}} + 0) = \\frac{1}{3\\sqrt{2}}$。\n- 覆盖度：$\\bar{c}_1 = \\bar{c}_2 = 40$ 且 $\\bar{c}_3 = \\bar{c}_4 = 10$。\n- 相对覆盖度不一致性为：\n    - $r_1 = \\frac{|40-40|}{40+40} = 0$。\n    - $r_2 = \\frac{|10-40|}{10+40} = \\frac{30}{50} = \\frac{3}{5}$。\n    - $r_3 = \\frac{|10-10|}{10+10} = 0$。\n- $I_{\\mathrm{cov}} = \\frac{1}{3} (0 + \\frac{3}{5} + 0) = \\frac{1}{5}$。\n- 最终得分为 $\\mathrm{Score}_2 = \\frac{1}{2} I_{\\mathrm{comp}} + \\frac{1}{2} I_{\\mathrm{cov}} = \\frac{1}{2}(\\frac{1}{3\\sqrt{2}}) + \\frac{1}{2}(\\frac{1}{5}) = \\frac{1}{6\\sqrt{2}} + \\frac{1}{10} \\approx 0.217851$。\n\n**测试用例 3:**\n- Contig 长度 $L_3=20$，$W=30$。窗口数量为 $M = \\lfloor 20/30 \\rfloor = 0$。\n- 根据问题定义，如果 $M  2$，则得分为 $0$。\n- 因此，$\\mathrm{Score}_3 = 0$。\n\n**测试用例 4:**\n- Contig 长度 $L_4=60$，$W=30$，得到 $M = \\lfloor 60/30 \\rfloor = 2$ 个窗口。\n- 两个窗口中的序列是相同的（30 个字符的 \"ACGT...\"）。这与测试用例 1 中的窗口相同。因此，$p_1 = p_2$。\n- 组成不一致性为 $d_1 = \\|p_1-p_2\\|_2 = 0$，得出 $I_{\\mathrm{comp}} = \\frac{1}{2-1}\\frac{0}{\\sqrt{2}}=0$。\n- 平均覆盖度为 $\\bar{c}_1=20$ 和 $\\bar{c}_2=22$。\n- 相对覆盖度不一致性为 $r_1 = \\frac{|22-20|}{22+20} = \\frac{2}{42} = \\frac{1}{21}$。\n- $I_{\\mathrm{cov}} = \\frac{1}{2-1} r_1 = \\frac{1}{21}$。\n- 最终得分为 $\\mathrm{Score}_4 = \\frac{1}{2}(0) + \\frac{1}{2}(\\frac{1}{21}) = \\frac{1}{42} \\approx 0.023810$。\n\n**测试用例 5:**\n- Contig 长度 $L_5=90$，$W=30$，得到 $M = 3$ 个窗口。\n- 窗口 1: \"ATATAT...\"，窗口 2: \"GCGCGC...\"，窗口 3: \"ATATAT...\"。\n- 从测试用例 2 中我们知道，\"ATATAT...\" ($p_1, p_3$) 的 $k$-mer 剖面与 \"GCGCGC...\" ($p_2$) 的 $k$-mer 剖面是不相交的。\n- 因此，$p_1=p_3$。\n- 组成不一致性为：\n    - $d_1 = \\|p_1-p_2\\|_2 = 1$。\n    - $d_2 = \\|p_2-p_3\\|_2 = \\|p_2-p_1\\|_2 = 1$。\n- $I_{\\mathrm{comp}} = \\frac{1}{3-1} (\\frac{d_1}{\\sqrt{2}} + \\frac{d_2}{\\sqrt{2}}) = \\frac{1}{2} (\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}}) = \\frac{1}{\\sqrt{2}}$。\n- 覆盖度是均匀的，$\\bar{c}_1 = \\bar{c}_2 = \\bar{c}_3 = 30$。\n- 所有相对覆盖度不一致性均为 $r_i=0$，所以 $I_{\\mathrm{cov}} = 0$。\n- 最终得分为 $\\mathrm{Score}_5 = \\frac{1}{2}(\\frac{1}{\\sqrt{2}}) + \\frac{1}{2}(0) = \\frac{1}{2\\sqrt{2}} \\approx 0.353553$。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef compute_chimericity_score(S, D, L, k, W, alpha):\n    \"\"\"\n    Computes the chimericity score for a contig based on k-mer composition and coverage.\n    \"\"\"\n    M = L // W\n    if M  2:\n        return 0.0\n\n    kmer_positions = max(W - k + 1, 0)\n    # The denominator for k-mer frequencies, as per the problem statement\n    # p_i(w) = c_i(w) / max(N_i, 1) where N_i = W-k+1\n    kmer_freq_denominator = float(max(kmer_positions, 1))\n\n    alphabet = 'ACGT'\n    all_kmers = sorted([''.join(p) for p in itertools.product(alphabet, repeat=k)])\n    kmer_to_idx = {kmer: i for i, kmer in enumerate(all_kmers)}\n    num_total_kmers = len(all_kmers)\n\n    window_p_vectors = []\n    window_mean_coverages = []\n\n    for i in range(M):\n        start_idx = i * W\n        end_idx = start_idx + W\n        \n        window_seq = S[start_idx:end_idx]\n        \n        # Calculate k-mer frequency vector p_i\n        counts = np.zeros(num_total_kmers, dtype=float)\n        if kmer_positions > 0:\n            for j in range(kmer_positions):\n                kmer = window_seq[j:j+k]\n                # In case of non-standard characters, though the problem restricts to ACGT\n                if kmer in kmer_to_idx:\n                    counts[kmer_to_idx[kmer]] += 1\n        \n        p_vector = counts / kmer_freq_denominator\n        window_p_vectors.append(p_vector)\n        \n        # Calculate mean coverage c_i\n        window_cov_data = D[start_idx:end_idx]\n        mean_cov = np.mean(window_cov_data)\n        window_mean_coverages.append(mean_cov)\n        \n    total_comp_inconsistency = 0.0\n    total_cov_inconsistency = 0.0\n    \n    for i in range(M - 1):\n        # Composition inconsistency\n        p_i = window_p_vectors[i]\n        p_i_plus_1 = window_p_vectors[i+1]\n        d_i = np.linalg.norm(p_i - p_i_plus_1)\n        total_comp_inconsistency += d_i / np.sqrt(2.0)\n        \n        # Coverage inconsistency\n        c_i = window_mean_coverages[i]\n        c_i_plus_1 = window_mean_coverages[i+1]\n        c_sum = c_i + c_i_plus_1\n        if c_sum == 0.0:\n            r_i = 0.0\n        else:\n            r_i = np.abs(c_i_plus_1 - c_i) / c_sum\n        total_cov_inconsistency += r_i\n    \n    I_comp = total_comp_inconsistency / (M - 1)\n    I_cov = total_cov_inconsistency / (M - 1)\n    \n    score = alpha * I_comp + (1 - alpha) * I_cov\n    return score\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute scores.\n    \"\"\"\n    k = 3\n    W = 30\n    alpha = 0.5\n\n    # Test case 1\n    L1 = 120\n    S1 = ('ACGT' * (L1 // 4 + 1))[:L1]\n    D1 = np.full(L1, 30.0)\n    \n    # Test case 2\n    L2 = 120\n    S2_part1 = ('GC' * (60 // 2 + 1))[:60]\n    S2_part2 = ('AT' * (60 // 2 + 1))[:60]\n    S2 = S2_part1 + S2_part2\n    D2 = np.concatenate([np.full(60, 40.0), np.full(60, 10.0)])\n    \n    # Test case 3\n    L3 = 20\n    S3 = ('ACGT' * (L3 // 4 + 1))[:L3]\n    D3 = np.full(L3, 20.0)\n    \n    # Test case 4\n    L4 = 60\n    S4_part = ('ACGT' * (30 // 4 + 2))[:30] # +2 ensures enough length\n    S4 = S4_part + S4_part\n    D4 = np.concatenate([np.full(30, 20.0), np.full(30, 22.0)])\n    \n    # Test case 5\n    L5 = 90\n    S5_part_AT = ('AT' * (30 // 2 + 1))[:30]\n    S5_part_GC = ('GC' * (30 // 2 + 1))[:30]\n    S5 = S5_part_AT + S5_part_GC + S5_part_AT\n    D5 = np.full(L5, 30.0)\n    \n    test_cases = [\n        (S1, D1, L1, k, W, alpha),\n        (S2, D2, L2, k, W, alpha),\n        (S3, D3, L3, k, W, alpha),\n        (S4, D4, L4, k, W, alpha),\n        (S5, D5, L5, k, W, alpha),\n    ]\n\n    results = []\n    for params in test_cases:\n        score = compute_chimericity_score(*params)\n        results.append(score)\n    \n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "基因组中的重复序列是组装算法面临的一大难题，它们常常在组装图中形成复杂的“缠结”（tangles），包含多条可能的解析路径。本练习将展示如何利用跨越重复区域的双端测序读段来解决这种模糊性。通过应用最大似然估计这一统计学框架，我们可以为不同路径评分，并选出数据支持度最高的路径，从而阐明一个用于精炼和完善组装结果的强大原则。",
            "id": "2405133",
            "problem": "给定一个数学抽象问题，需要利用双末端测序读段的内部距离，在串联重复纠缠区的多个备选基因组路径中做出决策。考虑一组候选路径，其索引为 $j \\in \\{0,1,\\dots,J-1\\}$，每条路径都有一个已知的总长度（以碱基对 bp 为单位），记作 $L_j$。此外，您还有 $N$ 个独立的内部距离测量值，记作 $y_1,\\dots,y_N$（以碱基对 bp 为单位），其中每个 $y_i$ 都被建模为对真实路径长度的带噪观测。噪声模型假设噪声为独立的、均值为零且标准差已知的高斯噪声。具体来说，对于每个观测值 $i \\in \\{1,\\dots,N\\}$，要么所有观测值共用一个标准差 $s$，要么为每个观测值提供单独的标准差 $s_i$。观测模型如下：\n$$\ny_i = L_{\\text{true}} + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0, s_i^2),\n$$\n其中，如果只给定一个共同标准差，则对所有 $i$ 都有 $s_i = s$。对于候选路径 $j$，观测到 $y_1,\\dots,y_N$ 的联合似然为：\n$$\n\\mathcal{L}_j = \\prod_{i=1}^{N} \\frac{1}{\\sqrt{2\\pi}\\, s_i}\\,\\exp\\!\\left(-\\frac{(y_i - L_j)^2}{2 s_i^2}\\right).\n$$\n您的任务是根据此似然值对候选路径进行评分和排序，并选出似然值最高的候选路径的索引 $j$。如果多个候选路径的似然值完全相同，您必须输出并列者中最小的索引。所有距离的单位均为碱基对 (bp)。要求的输出是索引，因此无单位。\n\n测试套件。对于下面的每个测试用例，都给出了候选路径长度、观测到的内部距离，以及单个共同标准差或每个观测值的标准差列表：\n- 测试用例 1：$L = [950,1000,1050]$，$y = [1003,980,990,1010]$，$s = 25$。\n- 测试用例 2：$L = [580,600,620]$，$y = [597,605,602,590,600]$，$s = 10$。\n- 测试用例 3：$L = [1200]$，$y = [1190,1210,1205]$，$s = 15$。\n- 测试用例 4：$L = [1000,1020]$，$y = [1010]$，$s = 10$。\n- 测试用例 5：$L = [400,450,500]$，$y = [460,430,490]$，$s = [5,50,5]$。\n\n答案规格：\n- 对于每个测试用例，输出使 $\\mathcal{L}_j$ 最大化的候选路径的从零开始的索引 $j$，并应用上述平局打破规则。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由方括号括起来的逗号分隔的整数列表（例如 $[j_1,j_2,j_3,j_4,j_5]$）。输出为无单位的索引。",
            "solution": "所提出的问题是统计推断中的一个标准任务，具体来说是最大似然估计。该问题是良定的，有科学依据，并为找到确定性解提供了所有必要信息。因此，我将继续进行分析。\n\n目标是给定一组 $N$ 个观测值 $y = \\{y_1, \\dots, y_N\\}$，选择使联合似然函数 $\\mathcal{L}_j$ 最大化的候选路径索引 $j$。对于长度为 $L_j$ 的候选路径，其似然函数由以下公式给出：\n$$\n\\mathcal{L}_j = \\prod_{i=1}^{N} \\frac{1}{\\sqrt{2\\pi}\\, s_i}\\,\\exp\\!\\left(-\\frac{(y_i - L_j)^2}{2 s_i^2}\\right)\n$$\n其中 $s_i$ 是与观测值 $y_i$ 相关联的标准差。\n\n直接计算这些小的浮点数的乘积容易导致数值下溢。标准做法是转而最大化对数似然 $\\ell_j = \\ln(\\mathcal{L}_j)$，因为自然对数是严格单调函数。最大化 $\\ell_j$ 等价于最大化 $\\mathcal{L}_j$。对数似然为：\n$$\n\\ell_j = \\ln \\left( \\prod_{i=1}^{N} \\frac{1}{\\sqrt{2\\pi}\\, s_i}\\,\\exp\\!\\left(-\\frac{(y_i - L_j)^2}{2 s_i^2}\\right) \\right) = \\sum_{i=1}^{N} \\ln \\left( \\frac{1}{\\sqrt{2\\pi}\\, s_i}\\,\\exp\\!\\left(-\\frac{(y_i - L_j)^2}{2 s_i^2}\\right) \\right)\n$$\n$$\n\\ell_j = \\sum_{i=1}^{N} \\left[ \\ln\\left(\\frac{1}{\\sqrt{2\\pi}\\, s_i}\\right) - \\frac{(y_i - L_j)^2}{2 s_i^2} \\right] = \\sum_{i=1}^{N} \\left[ -\\ln(\\sqrt{2\\pi}) - \\ln(s_i) - \\frac{(y_i - L_j)^2}{2 s_i^2} \\right]\n$$\n为了找到使 $\\ell_j$ 最大化的索引 $j$，我们可以舍弃所有相对于 $j$ 为常数的项。项 $\\sum_{i=1}^{N} [-\\ln(\\sqrt{2\\pi}) - \\ln(s_i)]$ 不依赖于候选路径长度 $L_j$，因此对所有候选路径都是相同的。因此，最大化 $\\ell_j$ 等价于最大化剩余项：\n$$\n\\underset{j}{\\text{argmax}} \\left( \\sum_{i=1}^{N} -\\frac{(y_i - L_j)^2}{2 s_i^2} \\right)\n$$\n这又等价于最小化其相反数，并且由于因子 2 是一个正常数，我们可以将目标简化为最小化精度加权的平方误差之和：\n$$\nQ_j = \\sum_{i=1}^{N} \\frac{(y_i - L_j)^2}{s_i^2}\n$$\n最优候选索引 $j^*$ 是使这个量 $Q_j$ 最小化的索引：\n$$\nj^* = \\underset{j}{\\text{argmin}} \\left( Q_j \\right)\n$$\n问题规定，如果多个候选路径得到相同的最小 $Q_j$ 值（也就是相同的最大似然），则必须选择并列者中最小的索引。此过程将应用于每个测试用例。\n\n现在，我们通过计算每个候选路径的分数 $Q_j$ 来计算每个测试用例的解。\n\n_测试用例 1_：$L = [950, 1000, 1050]$，$y = [1003, 980, 990, 1010]$，$s = 25$。\n标准差 $s$ 是恒定的，因此我们可以最小化 $\\sum_{i=1}^4 (y_i - L_j)^2$。\n对于 $j=0, L_0=950$：$Q_0 \\propto (1003-950)^2 + (980-950)^2 + (990-950)^2 + (1010-950)^2 = 2809+900+1600+3600 = 8909$。\n对于 $j=1, L_1=1000$：$Q_1 \\propto (1003-1000)^2 + (980-1000)^2 + (990-1000)^2 + (1010-1000)^2 = 9+400+100+100 = 609$。\n对于 $j=2, L_2=1050$：$Q_2 \\propto (1003-1050)^2 + (980-1050)^2 + (990-1050)^2 + (1010-1050)^2 = 2209+4900+3600+1600 = 12309$。\n最低分是 609，对应于索引 $j=1$。\n\n_测试用例 2_：$L = [580, 600, 620]$，$y = [597, 605, 602, 590, 600]$，$s = 10$。\n最小化 $\\sum_{i=1}^5 (y_i - L_j)^2$。\n对于 $j=0, L_0=580$：$Q_0 \\propto 17^2+25^2+22^2+10^2+20^2 = 289+625+484+100+400 = 1898$。\n对于 $j=1, L_1=600$：$Q_1 \\propto (-3)^2+5^2+2^2+(-10)^2+0^2 = 9+25+4+100+0 = 138$。\n对于 $j=2, L_2=620$：$Q_2 \\propto (-23)^2+(-15)^2+(-18)^2+(-30)^2+(-20)^2 = 529+225+324+900+400 = 2378$。\n最低分是 138，对应于索引 $j=1$。\n\n_测试用例 3_：$L = [1200]$，$y = [1190, 1210, 1205]$，$s = 15$。\n只有一个索引为 $j=0$ 的候选路径。根据定义，它必然是似然最高的那个。\n所选索引为 $j=0$。\n\n_测试用例 4_：$L = [1000, 1020]$，$y = [1010]$，$s = 10$。\n最小化 $(y_1 - L_j)^2$。\n对于 $j=0, L_0=1000$：$Q_0 \\propto (1010-1000)^2 = 10^2 = 100$。\n对于 $j=1, L_1=1020$：$Q_1 \\propto (1010-1020)^2 = (-10)^2 = 100$。\n分数相同。根据平局打破规则，我们选择最小的索引，即 $j=0$。\n\n_测试用例 5_：$L = [400, 450, 500]$，$y = [460, 430, 490]$，$s = [5, 50, 5]$。\n标准差 $s_i$ 不同。我们必须使用完整的加权和 $Q_j = \\sum_{i=1}^3 \\frac{(y_i - L_j)^2}{s_i^2}$。\n对于 $j=0, L_0=400$：$Q_0 = \\frac{(460-400)^2}{5^2} + \\frac{(430-400)^2}{50^2} + \\frac{(490-400)^2}{5^2} = \\frac{3600}{25} + \\frac{900}{2500} + \\frac{8100}{25} = 144 + 0.36 + 324 = 468.36$。\n对于 $j=1, L_1=450$：$Q_1 = \\frac{(460-450)^2}{5^2} + \\frac{(430-450)^2}{50^2} + \\frac{(490-450)^2}{5^2} = \\frac{100}{25} + \\frac{400}{2500} + \\frac{1600}{25} = 4 + 0.16 + 64 = 68.16$。\n对于 $j=2, L_2=500$：$Q_2 = \\frac{(460-500)^2}{5^2} + \\frac{(430-500)^2}{50^2} + \\frac{(490-500)^2}{5^2} = \\frac{1600}{25} + \\frac{4900}{2500} + \\frac{100}{25} = 64 + 1.96 + 4 = 69.96$。\n最低分是 68.16，对应于索引 $j=1$。\n\n最终的索引序列为 [1, 1, 0, 0, 1]。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum likelihood candidate path index for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Candidate lengths L, Observed distances y, Standard deviation(s) s)\n        ([950, 1000, 1050], [1003, 980, 990, 1010], 25),\n        ([580, 600, 620], [597, 605, 602, 590, 600], 10),\n        ([1200], [1190, 1210, 1205], 15),\n        ([1000, 1020], [1010], 10),\n        ([400, 450, 500], [460, 430, 490], [5, 50, 5]),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L_candidates, y_obs, s_vals = case\n        \n        # Convert inputs to numpy arrays for vectorized operations\n        L_candidates = np.array(L_candidates, dtype=np.float64)\n        y_obs = np.array(y_obs, dtype=np.float64)\n        \n        # Handle both scalar and list/array standard deviations\n        if np.isscalar(s_vals):\n            s_array = np.full_like(y_obs, s_vals, dtype=np.float64)\n        else:\n            s_array = np.array(s_vals, dtype=np.float64)\n\n        scores = []\n        for L_j in L_candidates:\n            # The task of maximizing likelihood is equivalent to minimizing the\n            # sum of precision-weighted squared errors (residuals).\n            # This avoids numerical underflow from multiplying small probabilities.\n            # The score to minimize is sum(((y_i - L_j) / s_i)^2).\n            \n            residuals = y_obs - L_j\n            weighted_squared_residuals = (residuals / s_array)**2\n            score = np.sum(weighted_squared_residuals)\n            scores.append(score)\n            \n        # np.argmin finds the index of the first occurrence of the minimum value,\n        # which correctly implements the specified tie-breaking rule.\n        best_index = np.argmin(scores)\n        results.append(best_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}