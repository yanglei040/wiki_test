{
    "hands_on_practices": [
        {
            "introduction": "Docking scores are often complex sums of different energy terms that approximate the physics of binding. A crucial component is the ligand's internal conformational strain, which quantifies the energetic cost of distorting the ligand from its ideal geometry to fit into the binding pocket. This exercise  gives you hands-on experience implementing this penalty from scratch, translating bond lengths, angles, and torsions into a key part of the total score.",
            "id": "2422877",
            "problem": "You are tasked with writing a complete program that computes a docking score with an explicit conformational strain penalty for a ligand in a bound pose. The total score for a given bound pose is defined as the sum of a provided base score and a penalty proportional to the internal strain energy of the ligand. Let the total score be denoted by $S_{\\mathrm{total}}$, the provided base score by $S_{\\mathrm{base}}$ (in kilocalories per mole), and the nonnegative weighting factor by $\\lambda$ (dimensionless). The strain energy is defined by a classical molecular mechanics model as the sum of bond stretching, angle bending, and torsional rotation contributions. The total score is given by\n$$\nS_{\\mathrm{total}} \\;=\\; S_{\\mathrm{base}} + \\lambda \\, E_{\\mathrm{strain}},\n$$\nwhere\n$$\nE_{\\mathrm{strain}} \\;=\\; \\sum_{\\text{bonds } i} \\frac{1}{2} \\, k_{b,i} \\, \\bigl(r_i - r_{0,i}\\bigr)^2 \\;+\\; \\sum_{\\text{angles } j} \\frac{1}{2} \\, k_{\\theta,j} \\, \\bigl(\\theta_j - \\theta_{0,j}\\bigr)^2 \\;+\\; \\sum_{\\text{torsions } k} k_{\\tau,k}\\,\\bigl(1 - \\cos\\left(n_k \\, (\\phi_k - \\phi_{0,k})\\right)\\bigr).\n$$\nHere, $k_{b,i}$ are bond force constants with units of kilocalories per mole per square angstrom, $r_i$ are bond lengths in angstroms, and $r_{0,i}$ are corresponding reference bond lengths in angstroms. The $k_{\\theta,j}$ are angle force constants with units of kilocalories per mole per radian squared, $\\theta_j$ are bond angles in radians, and $\\theta_{0,j}$ are corresponding reference angles in radians. The $k_{\\tau,k}$ are torsional force constants with units of kilocalories per mole, $n_k$ are positive integers denoting torsional periodicities, $\\phi_k$ are dihedral angles in radians, and $\\phi_{0,k}$ are corresponding reference dihedral angles in radians. All energy contributions are expressed in kilocalories per mole. All input angles for this problem are specified in degrees and must be interpreted as degrees; the trigonometric function $\\cos(\\cdot)$ uses radians, and all angle differences must be converted to radians before evaluating energies. The output total scores must be reported in kilocalories per mole.\n\nYour program must evaluate the following test suite. Each test case provides $S_{\\mathrm{base}}$, $\\lambda$, and three lists: bonds, angles, and torsions. Bonds are provided as triples $(k_b, r, r_0)$; angles are provided as triples $(k_\\theta, \\theta_{\\mathrm{deg}}, \\theta_{0,\\mathrm{deg}})$; torsions are provided as quadruples $(k_\\tau, n, \\phi_{\\mathrm{deg}}, \\phi_{0,\\mathrm{deg}})$. All distances $r$ and $r_0$ are in angstroms, all provided angles are in degrees, and all force constants are in the units stated in the energy definition above.\n\nUse the following test cases (each line is one test case):\n\n- Test case $1$:\n  - $S_{\\mathrm{base}} = -7.5$, $\\lambda = 0.25$\n  - Bonds: $(300.0, 1.54, 1.52)$, $(200.0, 1.34, 1.34)$\n  - Angles: $(60.0, 112.0, 109.5)$\n  - Torsions: $(0.5, 3, 60.0, 60.0)$, $(0.8, 3, 140.0, 60.0)$\n- Test case $2$:\n  - $S_{\\mathrm{base}} = -3.2$, $\\lambda = 1.0$\n  - Bonds: $(250.0, 1.50, 1.50)$\n  - Angles: $(50.0, 120.0, 120.0)$\n  - Torsions: $(1.2, 1, 180.0, 180.0)$\n- Test case $3$:\n  - $S_{\\mathrm{base}} = -10.0$, $\\lambda = 0.5$\n  - Bonds: $(250.0, 1.58, 1.50)$, $(350.0, 1.40, 1.34)$\n  - Angles: $(50.0, 130.0, 120.0)$, $(70.0, 100.0, 109.5)$\n  - Torsions: $(1.5, 2, 90.0, 0.0)$, $(0.3, 1, -180.0, 180.0)$\n- Test case $4$:\n  - $S_{\\mathrm{base}} = -1.0$, $\\lambda = 0.0$\n  - Bonds: $(300.0, 1.60, 1.50)$\n  - Angles: $(80.0, 140.0, 120.0)$\n  - Torsions: $(2.0, 3, 90.0, 60.0)$\n- Test case $5$:\n  - $S_{\\mathrm{base}} = 0.0$, $\\lambda = 2.0$\n  - Bonds: no entries\n  - Angles: no entries\n  - Torsions: no entries\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each score rounded to six decimal places, for example, `[x_1,x_2,x_3,x_4,x_5]`. The values must be in kilocalories per mole and must be rounded to six decimal places. Angles in the input are in degrees and must be interpreted as degrees; where needed, convert to radians for use in the formulas. No user input is required; the program must run as is and output the scores for the test cases above.",
            "solution": "The problem statement has been rigorously validated and found to be scientifically grounded, well-posed, and objective. It presents a standard, albeit simplified, formulation from computational chemistry for calculating the internal strain energy of a molecule, which is a component of a docking score. The problem is self-contained, with all necessary data and formulae provided. There are no logical contradictions, ambiguities, or factual inaccuracies. Therefore, a direct solution is not only possible but required.\n\nThe task is to compute the total docking score, $S_{\\mathrm{total}}$, for a series of ligand poses. The score is defined by the equation:\n$$\nS_{\\mathrm{total}} = S_{\\mathrm{base}} + \\lambda E_{\\mathrm{strain}}\n$$\nwhere $S_{\\mathrm{base}}$ is a given base score, $\\lambda$ is a dimensionless weighting factor, and $E_{\\mathrm{strain}}$ is the internal conformational strain energy of the ligand. The problem provides all necessary parameters for five distinct test cases. The calculation proceeds by first determining $E_{\\mathrm{strain}}$ and then substituting it into the equation for $S_{\\mathrm{total}}$.\n\nThe strain energy $E_{\\mathrm{strain}}$ is modeled using a classical molecular mechanics potential energy function, which is a sum of three contributions: bond stretching, angle bending, and torsional rotation.\n$$\nE_{\\mathrm{strain}} = E_{\\mathrm{bond}} + E_{\\mathrm{angle}} + E_{\\mathrm{torsion}}\n$$\nWe will now detail the calculation of each component.\n\nThe bond stretching energy, $E_{\\mathrm{bond}}$, is calculated by summing the contributions from all specified bonds. Each contribution is modeled as a harmonic potential, penalizing deviations from a reference bond length $r_{0,i}$. The formula is:\n$$\nE_{\\mathrm{bond}} = \\sum_{\\text{bonds } i} \\frac{1}{2} k_{b,i} (r_i - r_{0,i})^2\n$$\nHere, $k_{b,i}$ is the bond force constant in units of kcal/mol/Å², $r_i$ is the measured bond length in angstroms (Å), and $r_{0,i}$ is the reference bond length in Å. The calculation for each test case involves iterating through the provided list of bonds and accumulating the energy for each.\n\nThe angle bending energy, $E_{\\mathrm{angle}}$, is similarly calculated by summing harmonic potential terms for all specified angles. This term penalizes deviations of bond angles from their reference values $\\theta_{0,j}$.\n$$\nE_{\\mathrm{angle}} = \\sum_{\\text{angles } j} \\frac{1}{2} k_{\\theta,j} (\\theta_j - \\theta_{0,j})^2\n$$\nA critical detail for this calculation is the handling of units. The force constant $k_{\\theta,j}$ is given in kcal/mol/rad², which requires the angle difference $(\\theta_j - \\theta_{0,j})$ to be in radians (rad). The input angles, however, are provided in degrees. Therefore, a conversion is mandatory:\n$$\n\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}} \\times \\frac{\\pi}{180}\n$$\nThe algorithm must convert both $\\theta_j$ and $\\theta_{0,j}$ from degrees to radians before calculating their difference and the corresponding energy contribution.\n\nThe torsional, or dihedral, energy, $E_{\\mathrm{torsion}}$, is described by a periodic cosine function, which models the energetic barrier to rotation around a chemical bond.\n$$\nE_{\\mathrm{torsion}} = \\sum_{\\text{torsions } k} k_{\\tau,k} \\bigl(1 - \\cos\\left(n_k (\\phi_k - \\phi_{0,k})\\right)\\bigr)\n$$\nHere, $k_{\\tau,k}$ is the torsional force constant in kcal/mol, $n_k$ is the periodicity, and $\\phi_k$ and $\\phi_{0,k}$ are the measured and reference dihedral angles, respectively. As with the angle bending term, the trigonometric function $\\cos(\\cdot)$ operates on radians. The input dihedral angles are in degrees and must be converted to radians before their difference is taken and used in the argument of the cosine function.\n\nThe overall algorithm is as follows:\n$1$. For each test case, retrieve the parameters: $S_{\\mathrm{base}}$, $\\lambda$, and the lists of bond, angle, and torsion parameters.\n$2$. Initialize the total strain energy, $E_{\\mathrm{strain}}$, to $0$.\n$3$. Loop through the list of bonds. For each bond, calculate its energy using the bond stretching formula and add it to $E_{\\mathrm{strain}}$.\n$4$. Loop through the list of angles. For each angle, convert the degree values to radians, calculate the energy using the angle bending formula, and add it to $E_{\\mathrm{strain}}$.\n$5$. Loop through the list of torsions. For each torsion, convert the degree values to radians, calculate the energy using the torsional rotation formula, and add it to $E_{\\mathrm{strain}}$.\n$6$. With the total $E_{\\mathrm{strain}}$ computed, calculate the final score $S_{\\mathrm{total}} = S_{\\mathrm{base}} + \\lambda E_{\\mathrm{strain}}$.\n$7$. The computed score is then rounded to six decimal places as required. This process is repeated for all test cases. The final output is a single line containing a comma-separated list of these scores enclosed in square brackets. For cases where $\\lambda=0$, the calculation of $E_{\\mathrm{strain}}$ is technically unnecessary as its contribution to $S_{\\mathrm{total}}$ is zero, but a robust implementation will compute it regardless. For cases with no geometric terms (empty lists), $E_{\\mathrm{strain}}$ is trivially $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ligand docking score problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"S_base\": -7.5, \"lambda\": 0.25,\n            \"bonds\": [(300.0, 1.54, 1.52), (200.0, 1.34, 1.34)],\n            \"angles\": [(60.0, 112.0, 109.5)],\n            \"torsions\": [(0.5, 3, 60.0, 60.0), (0.8, 3, 140.0, 60.0)]\n        },\n        # Test case 2\n        {\n            \"S_base\": -3.2, \"lambda\": 1.0,\n            \"bonds\": [(250.0, 1.50, 1.50)],\n            \"angles\": [(50.0, 120.0, 120.0)],\n            \"torsions\": [(1.2, 1, 180.0, 180.0)]\n        },\n        # Test case 3\n        {\n            \"S_base\": -10.0, \"lambda\": 0.5,\n            \"bonds\": [(250.0, 1.58, 1.50), (350.0, 1.40, 1.34)],\n            \"angles\": [(50.0, 130.0, 120.0), (70.0, 100.0, 109.5)],\n            \"torsions\": [(1.5, 2, 90.0, 0.0), (0.3, 1, -180.0, 180.0)]\n        },\n        # Test case 4\n        {\n            \"S_base\": -1.0, \"lambda\": 0.0,\n            \"bonds\": [(300.0, 1.60, 1.50)],\n            \"angles\": [(80.0, 140.0, 120.0)],\n            \"torsions\": [(2.0, 3, 90.0, 60.0)]\n        },\n        # Test case 5\n        {\n            \"S_base\": 0.0, \"lambda\": 2.0,\n            \"bonds\": [],\n            \"angles\": [],\n            \"torsions\": []\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_base = case[\"S_base\"]\n        lambda_val = case[\"lambda\"]\n        bonds = case[\"bonds\"]\n        angles = case[\"angles\"]\n        torsions = case[\"torsions\"]\n\n        # Calculate strain energy\n        e_strain = 0.0\n\n        # Bond stretching energy\n        for k_b, r, r_0 in bonds:\n            e_strain += 0.5 * k_b * (r - r_0)**2\n\n        # Angle bending energy\n        for k_theta, theta_deg, theta_0_deg in angles:\n            theta_rad = np.deg2rad(theta_deg)\n            theta_0_rad = np.deg2rad(theta_0_deg)\n            e_strain += 0.5 * k_theta * (theta_rad - theta_0_rad)**2\n\n        # Torsional rotation energy\n        for k_tau, n, phi_deg, phi_0_deg in torsions:\n            phi_rad = np.deg2rad(phi_deg)\n            phi_0_rad = np.deg2rad(phi_0_deg)\n            e_strain += k_tau * (1 - np.cos(n * (phi_rad - phi_0_rad)))\n\n        # Calculate total score\n        s_total = s_base + lambda_val * e_strain\n        results.append(s_total)\n\n    # Format the final output string\n    # Round to six decimal places and format as a string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key goal of docking is to accurately predict the 3D orientation, or \"pose,\" of a ligand in a protein's binding site. To validate a prediction, we must compare it to an experimentally determined structure, and the Root Mean Square Deviation (RMSD) is the standard metric for this comparison. This practice  will guide you through the fundamental calculation of a pharmacophore-based RMSD, reinforcing the core principles of structural alignment and pose evaluation.",
            "id": "2422916",
            "problem": "A ligand presents three pharmacophore features: a hydrogen bond (H-bond) donor, a hydrogen bond (H-bond) acceptor, and an aromatic ring centroid. You are given their three-dimensional (3D) Cartesian coordinates, in ångström (Å), for a crystallographic reference pose and for a docked pose. The pharmacophore-based Root Mean Square Deviation (RMSD) is defined as the RMSD computed only over these pharmacophore feature positions, after applying the optimal rigid-body superposition (a rotation and a translation) that minimizes the RMSD over the selected features.\n\nCrystal pose feature coordinates (Å):\n- Donor: $\\left(1,\\,0,\\,0\\right)$\n- Acceptor: $\\left(0,\\,1,\\,0\\right)$\n- Aromatic centroid: $\\left(-1,\\,-1,\\,0\\right)$\n\nDocked pose feature coordinates (Å):\n- Donor: $\\left(0,\\,1,\\,0\\right)$\n- Acceptor: $\\left(-1,\\,0,\\,0\\right)$\n- Aromatic centroid: $\\left(1.1,\\,-1,\\,0\\right)$\n\nAssume the correspondence Donor $\\leftrightarrow$ Donor, Acceptor $\\leftrightarrow$ Acceptor, Aromatic centroid $\\leftrightarrow$ Aromatic centroid. Using the standard definition of RMSD,\n$$\\mathrm{RMSD} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left\\|\\mathbf{r}_{i}-\\mathbf{s}_{i}\\right\\|^{2}},$$\nwhere $N$ is the number of matched features and $\\mathbf{r}_{i},\\mathbf{s}_{i}$ are the optimally superposed coordinates of corresponding features, compute the pharmacophore-based RMSD between the docked and crystal poses. Perform the optimal rigid-body superposition that minimizes the RMSD over these three features.\n\nExpress your final answer as an exact analytical expression in ångström units. Do not round. The final reported value must be a single exact expression.",
            "solution": "The problem requires the calculation of the pharmacophore-based Root Mean Square Deviation (RMSD) between a crystal pose and a docked pose of a ligand. The RMSD is to be calculated over three specified feature points after optimal rigid-body superposition.\n\nLet the set of coordinates for the crystal pose be $P = \\{\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$ and for the docked pose be $Q = \\{\\mathbf{q}_1, \\mathbf{q}_2, \\mathbf{q}_3\\}$. The correspondence is given as:\n$\\mathbf{p}_1 = (1, 0, 0)$ (Donor) $\\leftrightarrow$ $\\mathbf{q}_1 = (0, 1, 0)$ (Donor)\n$\\mathbf{p}_2 = (0, 1, 0)$ (Acceptor) $\\leftrightarrow$ $\\mathbf{q}_2 = (-1, 0, 0)$ (Acceptor)\n$\\mathbf{p}_3 = (-1, -1, 0)$ (Aromatic) $\\leftrightarrow$ $\\mathbf{q}_3 = (1.1, -1, 0)$ (Aromatic)\n\nThe number of feature points is $N=3$. The RMSD is given by:\n$$ \\mathrm{RMSD} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i - \\mathbf{s}_i\\|^2} $$\nwhere $\\mathbf{r}_i$ and $\\mathbf{s}_i$ are the coordinates of the corresponding features after optimal superposition. This is achieved by finding the rotation matrix $R$ and translation vector $\\mathbf{t}$ that minimize the sum of squared distances $D^2 = \\sum_{i=1}^{N} \\| R\\mathbf{q}_i + \\mathbf{t} - \\mathbf{p}_i \\|^2$.\n\nThe standard procedure (Kabsch algorithm) involves the following steps:\n1.  **Translate both point sets to their centroids.**\n    The centroid of the crystal pose features, $\\mathbf{p}_c$, is:\n    $$ \\mathbf{p}_c = \\frac{1}{3}(\\mathbf{p}_1 + \\mathbf{p}_2 + \\mathbf{p}_3) = \\frac{1}{3}\\left((1,0,0) + (0,1,0) + (-1,-1,0)\\right) = \\frac{1}{3}(0,0,0) = (0,0,0) $$\n    The centroid of the docked pose features, $\\mathbf{q}_c$, is:\n    $$ \\mathbf{q}_c = \\frac{1}{3}(\\mathbf{q}_1 + \\mathbf{q}_2 + \\mathbf{q}_3) = \\frac{1}{3}\\left((0,1,0) + (-1,0,0) + (1.1, -1, 0)\\right) = \\frac{1}{3}(0.1, 0, 0) = \\left(\\frac{1}{30}, 0, 0\\right) $$\n    The optimal translation vector $\\mathbf{t}$ superimposes the centroids: $\\mathbf{t} = \\mathbf{p}_c - R\\mathbf{q}_c$. The problem then reduces to finding the optimal rotation $R$ for the centered coordinates.\n    The centered coordinates are $\\mathbf{x}_i = \\mathbf{p}_i - \\mathbf{p}_c$ and $\\mathbf{y}_i = \\mathbf{q}_i - \\mathbf{q}_c$.\n    Since $\\mathbf{p}_c = (0,0,0)$, we have $\\mathbf{x}_i = \\mathbf{p}_i$:\n    $$ \\mathbf{x}_1 = (1, 0, 0), \\quad \\mathbf{x}_2 = (0, 1, 0), \\quad \\mathbf{x}_3 = (-1, -1, 0) $$\n    The centered coordinates for the docked pose are:\n    $$ \\mathbf{y}_1 = (0, 1, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(-\\frac{1}{30}, 1, 0\\right) $$\n    $$ \\mathbf{y}_2 = (-1, 0, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(-\\frac{31}{30}, 0, 0\\right) $$\n    $$ \\mathbf{y}_3 = (1.1, -1, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(\\frac{11}{10} - \\frac{1}{30}, -1, 0\\right) = \\left(\\frac{32}{30}, -1, 0\\right) $$\n\n2.  **Calculate the minimum sum of squared errors.**\n    The minimum value of the sum of squared errors, $D^2_{\\min}$, is given by:\n    $$ D^2_{\\min} = \\sum_{i=1}^{N} \\|\\mathbf{x}_i\\|^2 + \\sum_{i=1}^{N} \\|\\mathbf{y}_i\\|^2 - 2 \\sum_{k=1}^{3} \\sigma'_k $$\n    where $\\sigma'_k$ are the singular values of the covariance matrix $C = \\sum_{i=1}^{N} \\mathbf{x}_i \\mathbf{y}_i^T$, with the smallest singular value's sign flipped if the optimal transformation is a reflection.\n\n    First, we compute the sum of squared norms of the centered vectors:\n    $$ \\sum_{i=1}^{3} \\|\\mathbf{x}_i\\|^2 = (1^2+0^2+0^2) + (0^2+1^2+0^2) + ((-1)^2+(-1)^2+0^2) = 1 + 1 + 2 = 4 $$\n    $$ \\sum_{i=1}^{3} \\|\\mathbf{y}_i\\|^2 = \\left(\\left(-\\frac{1}{30}\\right)^2 + 1^2\\right) + \\left(\\left(-\\frac{31}{30}\\right)^2\\right) + \\left(\\left(\\frac{32}{30}\\right)^2 + (-1)^2\\right) $$\n    $$ = \\frac{1}{900} + 1 + \\frac{961}{900} + \\frac{1024}{900} + 1 = 2 + \\frac{1+961+1024}{900} = 2 + \\frac{1986}{900} = 2 + \\frac{331}{150} = \\frac{631}{150} $$\n\n3.  **Construct the covariance matrix and find the sum of its singular values.**\n    All given coordinates lie on the $z=0$ plane, making this a 2D problem. We construct the $2 \\times 2$ covariance matrix $C'$ using the $x$ and $y$ components of $\\mathbf{x}_i$ and $\\mathbf{y}_i$:\n    $$ C' = \\sum_{i=1}^{3} \\begin{pmatrix} x_{i,1} \\\\ x_{i,2} \\end{pmatrix} \\begin{pmatrix} y_{i,1} & y_{i,2} \\end{pmatrix} $$\n    $$ C'_{jk} = \\sum_{i=1}^3 x_{i,j} y_{i,k} $$\n    $$ C'_{11} = (1)\\!\\left(-\\frac{1}{30}\\right) + (0)\\!\\left(-\\frac{31}{30}\\right) + (-1)\\!\\left(\\frac{32}{30}\\right) = -\\frac{1}{30}-\\frac{32}{30} = -\\frac{33}{30} = -\\frac{11}{10} $$\n    $$ C'_{12} = (1)(1) + (0)(0) + (-1)(-1) = 1+1=2 $$\n    $$ C'_{21} = (0)\\!\\left(-\\frac{1}{30}\\right) + (1)\\!\\left(-\\frac{31}{30}\\right) + (-1)\\!\\left(\\frac{32}{30}\\right) = -\\frac{31}{30}-\\frac{32}{30} = -\\frac{63}{30} = -\\frac{21}{10} $$\n    $$ C'_{22} = (0)(1) + (1)(0) + (-1)(-1) = 1 $$\n    So, the 2D covariance matrix is:\n    $$ C' = \\begin{pmatrix} -11/10 & 2 \\\\ -21/10 & 1 \\end{pmatrix} $$\n    The sum of signed singular values $\\sum \\sigma'_k$ corresponds to the maximum value of $\\mathrm{tr}(RC')$, where $R$ is a rotation matrix. For a 2D rotation $R(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$, the trace is:\n    $$ \\mathrm{tr}(R(\\theta)C') = (C'_{11}+C'_{22})\\cos\\theta + (C'_{21}-C'_{12})\\sin\\theta $$\n    Let $A = C'_{11}+C'_{22} = -11/10 + 1 = -1/10$ and $B = C'_{21}-C'_{12} = -21/10 - 2 = -41/10$.\n    The maximum value of $A\\cos\\theta+B\\sin\\theta$ is $\\sqrt{A^2+B^2}$. This value is equal to the sum of singular values $\\sigma_1 + \\sigma_2$, since $\\det(C') = (-11/10)(1) - (2)(-21/10) = -11/10 + 42/10 = 31/10 > 0$, ensuring the optimal transformation is a proper rotation.\n    $$ \\sum_{k=1}^2 \\sigma_k = \\sqrt{\\left(-\\frac{1}{10}\\right)^2 + \\left(-\\frac{41}{10}\\right)^2} = \\sqrt{\\frac{1}{100} + \\frac{1681}{100}} = \\sqrt{\\frac{1682}{100}} = \\frac{\\sqrt{1682}}{10} $$\n    Since $1682 = 2 \\times 841 = 2 \\times 29^2$, the sum is:\n    $$ \\sum_{k=1}^2 \\sigma_k = \\frac{\\sqrt{2 \\times 29^2}}{10} = \\frac{29\\sqrt{2}}{10} $$\n    The third singular value $\\sigma_3$ is $0$ as the problem is planar.\n\n4.  **Compute the RMSD.**\n    Now we substitute these values into the RMSD formula:\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{N} D^2_{\\min} = \\frac{1}{3} \\left( \\sum \\|\\mathbf{x}_i\\|^2 + \\sum \\|\\mathbf{y}_i\\|^2 - 2\\sum \\sigma_k \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{3} \\left( 4 + \\frac{631}{150} - 2\\left(\\frac{29\\sqrt{2}}{10}\\right) \\right) = \\frac{1}{3} \\left( \\frac{600}{150} + \\frac{631}{150} - \\frac{29\\sqrt{2}}{5} \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{3} \\left( \\frac{1231}{150} - \\frac{29\\sqrt{2} \\times 30}{5 \\times 30} \\right) = \\frac{1}{3} \\left( \\frac{1231 - 870\\sqrt{2}}{150} \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1231 - 870\\sqrt{2}}{450} $$\n    The final RMSD is the square root of this value:\n    $$ \\mathrm{RMSD} = \\sqrt{\\frac{1231 - 870\\sqrt{2}}{450}} $$\n    The argument of the square root is positive, as $870\\sqrt{2} \\approx 870 \\times 1.414 = 1230.18 < 1231$.",
            "answer": "$$ \\boxed{\\sqrt{\\frac{1231 - 870\\sqrt{2}}{450}}} $$"
        },
        {
            "introduction": "While powerful, docking scoring functions are approximations of complex physical reality and have inherent weaknesses. Understanding these limitations is critical for interpreting results and avoiding false positives. This advanced practice  challenges you to exploit a common flaw in simple scoring functions by designing a molecule that scores well but is physically unlikely to be a good binder, providing deep insight into concepts like desolvation penalties.",
            "id": "2422880",
            "problem": "You are given a simplified but scientifically plausible setup of a protein-ligand docking situation designed to study adversarial behavior against an empirical scoring function. A receptor is described by feature points in three-dimensional space (in Angstroms) for hydrogen bonding: receptor donors and receptor acceptors. A ligand is described analogously by ligand donors and ligand acceptors. A pair contributes to a hydrogen-bond contact when one is a donor and the other is an acceptor and the Euclidean distance between the points is within a specified cutoff. No angular dependence is considered in the empirical score, and there is no size penalty in the empirical score. Distances must be treated in Angstroms. Energies must be treated in kilocalories per mole.\n\nDefine the following for any constructed ligand and fixed receptor:\n\n- Empirical score (to be exploited):\n  - The empirical hydrogen-bond contact count is the total number of donor-acceptor pairs with distance less than or equal to a cutoff $d_{\\mathrm{hb}}$.\n  - The empirical clash count is the total number of ligand feature points (donor or acceptor) that are closer than a clash distance $d_{\\mathrm{clash}}$ to any receptor feature point (donor or acceptor).\n  - The empirical score is\n  $$S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}.$$\n\n- Physically motivated quality proxy (to detect poor binders):\n  - For each donor-acceptor pair across receptor and ligand, let the distance be $r$. Define a soft distance-dependent contact weight\n  $$g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right).$$\n  - The physical energy proxy is\n  $$E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum_{\\text{all receptor-ligand donor-acceptor pairs}} g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}},$$\n  where $n_{\\mathrm{polar}}$ is the number of ligand donors and acceptors (all counted as polar), $n_{\\mathrm{atoms}}$ is the total number of ligand donors and acceptors, and $N_{\\mathrm{clash,true}}$ is the same as $N_{\\mathrm{clash}}$ but used in the physical penalty. Lower $E_{\\mathrm{true}}$ indicates a better binder; here, a \"poor binder\" is one with $E_{\\mathrm{true}}$ exceeding a specified threshold. All energies must be expressed in kcal/mol.\n\nTask. You must construct, for each test case, a ligand that explicitly exploits the empirical score $S$ to be as high as possible, even if the physical proxy $E_{\\mathrm{true}}$ is poor. Your program must, for each test case, produce a boolean indicating whether you successfully produced a \"malicious\" ligand, defined as one satisfying both\n- $S \\ge S_{\\mathrm{target}}$ and\n- $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$,\nwhere $S_{\\mathrm{target}}$ and $E_{\\mathrm{bad}}$ are specified per test case below.\n\nFoundational bases to be used:\n- Empirical scores for docking often count contacts within a cutoff without angular terms. This is the basis for $N_{\\mathrm{hb}}$ with a hard distance cutoff $d_{\\mathrm{hb}}$.\n- Real physical favorability of hydrogen bonds is distance-sensitive around a preferred distance $r_0$ and is penalized by desolvation and conformational entropy costs proportional to the number of polar groups and flexible degrees of freedom. This is the basis for the Gaussian $g(r)$, the per-polar penalty $p_{\\mathrm{polar}}$, and the per-rotor proxy $p_{\\mathrm{rot}}$.\n\nGeometry and units:\n- All coordinates are given in Angstroms; your constructed ligand coordinates must be in Angstroms.\n- All energies must be computed in kilocalories per mole.\n- Angles are not used in this problem.\n\nFor all test cases, count distances using the standard Euclidean metric, with \"within cutoff\" defined as less than or equal to the cutoff.\n\nTest suite. For each test case, the receptor features, parameters, and thresholds are specified. Receptor donors and acceptors are given as lists of $[x,y,z]$ coordinates (Angstroms). There are no receptor hydrophobes in this simplified setup.\n\n- Test case 1 (happy path adversarial success):\n  - Receptor acceptors:\n    - $[0.0, 0.0, 0.0]$, $[4.0, 0.0, 0.0]$, $[0.0, 4.0, 0.0]$, $[0.0, 0.0, 4.0]$, $[3.0, 3.0, 0.0]$.\n  - Receptor donors: none.\n  - Empirical scoring parameters: $d_{\\mathrm{hb}} = 3.5$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$.\n  - Physical proxy parameters: $r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$.\n  - Thresholds: $S_{\\mathrm{target}} = 5$, $E_{\\mathrm{bad}} = 5.0$.\n\n- Test case 2 (boundary where exploitation should fail the \"poor binder\" criterion):\n  - Receptor acceptors:\n    - $[0.0, 0.0, 0.0]$, $[5.0, 0.0, 0.0]$.\n  - Receptor donors:\n    - $[0.0, 5.0, 0.0]$.\n  - Empirical scoring parameters: $d_{\\mathrm{hb}} = 2.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$.\n  - Physical proxy parameters: $r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$.\n  - Thresholds: $S_{\\mathrm{target}} = 3$, $E_{\\mathrm{bad}} = 2.0$.\n\n- Test case 3 (mixed features, larger cutoff, clear adversarial success):\n  - Receptor acceptors:\n    - $[0.0, 0.0, 0.0]$, $[2.0, 0.0, 0.0]$, $[0.0, 2.0, 0.0]$.\n  - Receptor donors:\n    - $[1.0, 1.0, 0.0]$, $[1.0, -1.0, 0.0]$, $[3.0, 1.0, 0.0]$.\n  - Empirical scoring parameters: $d_{\\mathrm{hb}} = 3.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$.\n  - Physical proxy parameters: $r_0 = 2.8$, $\\sigma = 0.35$, $e_{\\mathrm{hb}} = 2.8$, $p_{\\mathrm{polar}} = 2.0$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$.\n  - Thresholds: $S_{\\mathrm{target}} = 6$, $E_{\\mathrm{bad}} = 8.0$.\n\nYour program must, for each test case, construct a ligand (sets of donor and acceptor coordinates) intended to maximize the empirical score $S$ by placing complementary ligand features within the hydrogen-bond cutoff of as many receptor features as possible while avoiding empirical clashes if feasible, with no other constraints on the number of ligand atoms. Then compute $S$ and $E_{\\mathrm{true}}$ as defined above and return whether the malicious success criteria are met.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (e.g., \"[True,False,True]\"). The three booleans must correspond to Test case $1$, Test case $2$, and Test case $3$, in that order. No other text must be printed.",
            "solution": "The user has presented a problem in computational biology concerning the construction of adversarial ligands designed to maximize a simplified empirical docking score, $S$, while simultaneously possessing poor, physically-motivated binding characteristics, as measured by a proxy energy $E_{\\mathrm{true}}$. A ligand is deemed \"malicious\" if it satisfies both $S \\ge S_{\\mathrm{target}}$ and $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$ for given thresholds.\n\nThe problem is first validated for scientific soundness and logical consistency.\n\n**Step 1: Extraction of Givens**\n- **Receptor/Ligand Features**: Defined by spatial coordinates of hydrogen bond donors and acceptors.\n- **Empirical Score, $S$**: $S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}$.\n  - $N_{\\mathrm{hb}}$: Count of donor-acceptor pairs with distance $r \\le d_{\\mathrm{hb}}$.\n  - $N_{\\mathrm{clash}}$: Count of ligand feature points with distance $r < d_{\\mathrm{clash}}$ to any receptor feature point.\n- **Physical Energy Proxy, $E_{\\mathrm{true}}$**: $E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}}$.\n  - $g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right)$ is the soft contact weight for donor-acceptor pairs.\n  - $n_{\\mathrm{polar}}$: Number of ligand polar atoms (donors/acceptors).\n  - $n_{\\mathrm{atoms}}$: Total number of ligand feature points.\n  - $N_{\\mathrm{clash,true}}$: Same as $N_{\\mathrm{clash}}$.\n- **Task**: For each test case, construct a ligand to maximize $S$, then determine if it meets the \"malicious\" criteria: $S \\ge S_{\\mathrm{target}}$ and $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$.\n- **Test Cases**: Three distinct test cases are provided, each with specific receptor geometries, scoring parameters, and thresholds.\n\n**Step 2: Validation of Problem Statement**\nThe problem is scientifically grounded, modeling a known vulnerability in simple docking scoring functions where interactions are modeled with hard distance cutoffs. The physical proxy energy $E_{\\mathrm{true}}$ correctly introduces concepts like optimal interaction distance ($r_0$), desolvation penalties (related to $p_{\\mathrm{polar}}$), and conformational entropy costs (related to $p_{\\mathrm{rot}}$). The problem is well-posed, providing all necessary definitions, constants, and data. The terms are mathematically defined and objective. No contradictions or logical flaws are present.\n\n**Verdict**: The problem is valid and can be solved.\n\n**Step 3: Solution Design**\nThe objective is to construct a ligand that is adversarial. This implies a strategy to maximize the empirical score $S$ while simultaneously making the physical energy proxy $E_{\\mathrm{true}}$ as poor (high) as possible.\n\n**Analysis of Scores:**\n- To maximize $S = w_{\\mathrm{hb}} N_{\\mathrm{hb}} - w_{\\mathrm{clash}} N_{\\mathrm{clash}}$, we must maximize $N_{\\mathrm{hb}}$ and minimize $N_{\\mathrm{clash}}$. The maximum possible value for $N_{\\mathrm{hb}}$ corresponds to forming a hydrogen bond with every feature point on the receptor. A simple ligand construction that aims for this is to place one complementary ligand atom for each receptor atom. To avoid the penalty term, each ligand atom must be placed at a distance $r \\ge d_{\\mathrm{clash}}$ from all receptor atoms.\n- To maximize $E_{\\mathrm{true}}$, we must make the favorable energy term $- e_{\\mathrm{hb}} \\sum g(r)$ as small (close to zero) as possible. The function $g(r)$ is a Gaussian peaked at $r=r_0$, so to minimize its value, the interaction distance $r$ should be as far from $r_0$ as possible. The penalty terms involving $p_{\\mathrm{polar}}$, $p_{\\mathrm{rot}}$, and $p_{\\mathrm{clash}}$ should be maximized.\n\n**Adversarial Construction Strategy:**\nA rational adversarial strategy combines these objectives:\n1.  **Ligand Composition**: For each of the $N$ feature points on the receptor (donors and acceptors), we construct a ligand with one complementary feature point. This sets $n_{\\mathrm{atoms}} = n_{\\mathrm{polar}} = N$. This maximizes the potential for $N_{\\mathrm{hb}}$.\n2.  **Ligand Atom Placement**: To satisfy the conditions for both high $S$ and high $E_{\\mathrm{true}}$, we should place each ligand atom at a distance $r$ from its target receptor atom such that:\n    a. $d_{\\mathrm{clash}} \\le r \\le d_{\\mathrm{hb}}$ (to count for $N_{\\mathrm{hb}}$ and avoid an empirical clash for $S$).\n    b. $|r - r_0|$ is maximized (to minimize the favorable contribution to $E_{\\mathrm{true}}$). This means choosing $r$ at one of the boundaries of the allowed interval, i.e., $r = d_{\\mathrm{clash}}$ or $r = d_{\\mathrm{hb}}$. For all provided test cases, $|d_{\\mathrm{clash}} - r_0| > |d_{\\mathrm{hb}} - r_0|$, making $r = d_{\\mathrm{clash}}$ the optimal choice for an adversarial placement.\n    c. The placed ligand atom must not clash with any other receptor atom. Simple displacement along a fixed axis (e.g., x-axis) may lead to unintended clashes if receptor atoms are closely packed. A more robust method is to test several orthogonal displacement vectors and select the first one that results in no clashes with any receptor atom.\n\n**Algorithmic Implementation:**\nFor each test case:\n1.  Construct the ligand. For each receptor feature point $\\vec{p}_i$, find a valid position for a complementary ligand atom. A position $\\vec{p}'_i = \\vec{p}_i + \\vec{\\delta}$ is valid if the distance from $\\vec{p}'_i$ to any receptor atom $\\vec{p}_j$ is greater than or equal to $d_{\\mathrm{clash}}$. We test a series of orthogonal displacement vectors $\\vec{\\delta}$ of magnitude $d_{\\mathrm{clash}}$ (e.g., $(d_{\\mathrm{clash}}, 0, 0), (0, d_{\\mathrm{clash}}, 0), \\dots, (0, 0, -d_{\\mathrm{clash}})$) and use the first one that yields a valid, non-clashing position.\n2.  Calculate the scores for the constructed ligand.\n    a. Determine the coordinates of all ligand donors and acceptors based on the strategy above.\n    b. Compute $N_{\\mathrm{hb}}$ by counting all pairs of (receptor donor, ligand acceptor) and (receptor acceptor, ligand donor) whose distance is $\\le d_{\\mathrm{hb}}$.\n    c. Compute $\\sum g(r)$ over the same set of pairs.\n    d. Compute $N_{\\mathrm{clash}}$ by checking, for each ligand atom, if its minimum distance to any receptor atom is less than $d_{\\mathrm{clash}}$.\n    e. Substitute these values into the equations for $S$ and $E_{\\mathrm{true}}$.\n3.  Evaluate the maliciousness criteria: check if $S \\ge S_{\\mathrm{target}}$ and $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$. The boolean result is recorded.\n4.  The final output is a list of these boolean results for all test cases.\nThis systematic procedure ensures a consistent and logical approach to constructing an adversarial ligand and evaluating its properties according to the problem's definitions.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adversarial ligand construction problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"rec_acceptors\": np.array([\n                [0.0, 0.0, 0.0], [4.0, 0.0, 0.0], [0.0, 4.0, 0.0],\n                [0.0, 0.0, 4.0], [3.0, 3.0, 0.0]\n            ]),\n            \"rec_donors\": np.empty((0, 3)),\n            \"params\": {\n                \"d_hb\": 3.5, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 5, \"E_bad\": 5.0}\n        },\n        # Test case 2\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0]]),\n            \"rec_donors\": np.array([[0.0, 5.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 2.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 3, \"E_bad\": 2.0}\n        },\n        # Test case 3\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n            \"rec_donors\": np.array([[1.0, 1.0, 0.0], [1.0, -1.0, 0.0], [3.0, 1.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 3.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.35, \"e_hb\": 2.8, \"p_polar\": 2.0,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 6, \"E_bad\": 8.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ligand_donors, ligand_acceptors = construct_adversarial_ligand(case)\n        S, E_true = calculate_scores(\n            ligand_donors, ligand_acceptors,\n            case[\"rec_donors\"], case[\"rec_acceptors\"],\n            case[\"params\"]\n        )\n        \n        is_malicious = (S >= case[\"thresholds\"][\"S_target\"] and \n                        E_true >= case[\"thresholds\"][\"E_bad\"])\n        results.append(str(is_malicious))\n\n    print(f\"[{','.join(results)}]\")\n\ndef construct_adversarial_ligand(case_data):\n    \"\"\"\n    Constructs a ligand by placing complementary atoms near receptor features.\n    The placement strategy is adversarial: place at a distance d_clash\n    from the target atom in a direction that does not clash with other receptor atoms.\n    \"\"\"\n    params = case_data[\"params\"]\n    d_clash = params[\"d_clash\"]\n    \n    rec_acceptors = case_data[\"rec_acceptors\"]\n    rec_donors = case_data[\"rec_donors\"]\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0] > 0:\n        all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0] > 0:\n        all_rec_pts.append(rec_donors)\n    \n    if not all_rec_pts:\n        return np.empty((0,3)), np.empty((0,3))\n\n    all_rec_pts = np.vstack(all_rec_pts)\n\n    deltas = np.array([\n        [d_clash, 0, 0], [0, d_clash, 0], [0, 0, d_clash],\n        [-d_clash, 0, 0], [0, -d_clash, 0], [0, 0, -d_clash]\n    ])\n\n    def find_non_clashing_pos(target_rec_pt, all_rec_pts, deltas):\n        for delta in deltas:\n            candidate_pos = target_rec_pt + delta\n            is_clashing = False\n            # Check candidate against all receptor points\n            distances = np.linalg.norm(all_rec_pts - candidate_pos, axis=1)\n            if np.any(distances < d_clash):\n                is_clashing = True\n            \n            if not is_clashing:\n                return candidate_pos\n        # Fallback if no non-clashing position is found (unlikely for these test cases)\n        return target_rec_pt + deltas[0]\n\n    ligand_donors = []\n    for rec_acc in rec_acceptors:\n        pos = find_non_clashing_pos(rec_acc, all_rec_pts, deltas)\n        ligand_donors.append(pos)\n\n    ligand_acceptors = []\n    for rec_don in rec_donors:\n        pos = find_non_clashing_pos(rec_don, all_rec_pts, deltas)\n        ligand_acceptors.append(pos)\n        \n    return np.array(ligand_donors), np.array(ligand_acceptors)\n\n\ndef calculate_scores(lig_donors, lig_acceptors, rec_donors, rec_acceptors, params):\n    \"\"\"\n    Calculates the empirical score (S) and physical energy proxy (E_true).\n    \"\"\"\n    # Unpack parameters\n    d_hb = params[\"d_hb\"]\n    d_clash = params[\"d_clash\"]\n    w_hb = params[\"w_hb\"]\n    w_clash = params[\"w_clash\"]\n    r0 = params[\"r0\"]\n    sigma = params[\"sigma\"]\n    e_hb = params[\"e_hb\"]\n    p_polar = params[\"p_polar\"]\n    p_rot = params[\"p_rot\"]\n    p_clash = params[\"p_clash\"]\n    \n    # Ligand properties\n    n_atoms = len(lig_donors) + len(lig_acceptors)\n    n_polar = n_atoms\n    \n    # Calculate N_hb and sum of g(r)\n    N_hb = 0\n    sum_g_r = 0.0\n\n    def g(r, r0, sigma):\n        return np.exp(-((r - r0)**2) / (2 * sigma**2))\n\n    # Receptor Acceptors vs Ligand Donors\n    if rec_acceptors.shape[0] > 0 and lig_donors.shape[0] > 0:\n        for lig_d in lig_donors:\n            for rec_a in rec_acceptors:\n                dist = np.linalg.norm(lig_d - rec_a)\n                if dist <= d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n\n    # Receptor Donors vs Ligand Acceptors\n    if rec_donors.shape[0] > 0 and lig_acceptors.shape[0] > 0:\n        for lig_a in lig_acceptors:\n            for rec_d in rec_donors:\n                dist = np.linalg.norm(lig_a - rec_d)\n                if dist <= d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n                \n    # Calculate N_clash\n    N_clash = 0\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0] > 0: all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0] > 0: all_rec_pts.append(rec_donors)\n    all_rec_pts = np.vstack(all_rec_pts) if all_rec_pts else np.empty((0,3))\n\n    all_lig_pts = []\n    if lig_donors.shape[0] > 0: all_lig_pts.append(lig_donors)\n    if lig_acceptors.shape[0] > 0: all_lig_pts.append(lig_acceptors)\n    all_lig_pts = np.vstack(all_lig_pts) if all_lig_pts else np.empty((0,3))\n\n    if all_rec_pts.shape[0] > 0:\n        for lig_pt in all_lig_pts:\n            min_dist = np.min(np.linalg.norm(all_rec_pts - lig_pt, axis=1))\n            if min_dist < d_clash:\n                N_clash += 1\n\n    # Final score calculations\n    S = w_hb * N_hb - w_clash * N_clash\n    \n    E_true = -e_hb * sum_g_r \\\n             + p_polar * n_polar \\\n             + p_rot * max(n_atoms - 1, 0) \\\n             + p_clash * N_clash\n             \n    return S, E_true\n\nsolve()\n```"
        }
    ]
}