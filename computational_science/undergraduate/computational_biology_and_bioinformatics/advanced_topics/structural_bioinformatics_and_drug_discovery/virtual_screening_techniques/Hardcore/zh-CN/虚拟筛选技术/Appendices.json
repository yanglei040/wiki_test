{
    "hands_on_practices": [
        {
            "introduction": "虚拟筛选的威力在于其能够以计算高效的方式从数百万种化合物中快速筛选出少数有前景的候选分子。为了实现这一点，通常会采用一种“漏斗”策略，即分阶段筛选。此练习将指导您构建一个典型的三阶段筛选流程：从快速的二维相似性搜索开始，接着是更精细的三维药效团匹配，最后是对幸存的分子进行简化的分子对接。通过完成这个练习，您将亲手实现一个虚拟筛选的核心工作流，并理解在准确性和计算成本之间进行权衡的基本原理。",
            "id": "2440164",
            "problem": "实现一个完整的筛选级联，该级联按照虚拟筛选实践，分三个连续阶段运行：首先是 $2\\text{D}$ 相似性搜索，然后是 $3\\text{D}$ 药效团过滤器，最后是柔性对接阶段。您的程序必须是基于以下定义和规则的确定性实现，并且必须处理一个固定的参数集测试套件。所有距离必须以埃（angstroms，记为 $\\mathrm{\\mathring{A}}$）为单位表示，所有角度必须以弧度（radians）为单位表示。\n\n从以下基本依据和核心定义开始。\n\n1. $2\\text{D}$ 相似性即集合相似性。将每个分子和查询表示为一个固定长度的二进制指纹向量，该向量编码了分子亚结构。设 $A$ 和 $B$ 为两个二进制指纹，可解释为比特位为 $1$ 的索引集合。Tanimoto系数（对于二进制指纹也称为Jaccard指数）定义为\n$$\nT(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|} \\;=\\; \\frac{c}{a + b - c},\n$$\n其中 $a = |A|$，$b = |B|$，且 $c = |A \\cap B|$。如果 $T(A,B) \\ge \\tau_{\\mathrm{sim}}$，则分子通过 $2\\text{D}$ 过滤器，其中 $\\tau_{\\mathrm{sim}}$ 是给定的相似性阈值。\n\n2. $3\\text{D}$ 药效团即几何距离约束。药效团模板由一个有序的特征类型三元组及其目标配对距离指定。在本问题中，每个分子提供三个特征点，标记为 $\\mathrm{DON}$（氢键供体）、$\\mathrm{ACC}$（氢键受体）和 $\\mathrm{HYD}$（疏水基团），每个点都有一个以 $\\mathrm{\\mathring{A}}$ 为单位的三维坐标。设 $d_{XY}$ 表示特征 $X$ 和 $Y$ 之间的欧几里得距离。给定目标距离 $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$ 和一个以 $\\mathrm{\\mathring{A}}$ 为单位的非负容差 $\\delta$，一个分子当且仅当满足以下条件时，才能通过 $3\\text{D}$ 药效团过滤器：\n$$\n|d_{\\mathrm{DA}} - d^{\\star}_{\\mathrm{DA}}| \\le \\delta,\\quad\n|d_{\\mathrm{DH}} - d^{\\star}_{\\mathrm{DH}}| \\le \\delta,\\quad\n|d_{\\mathrm{AH}} - d^{\\star}_{\\mathrm{AH}}| \\le \\delta.\n$$\n\n3. 柔性对接即通过离散内部旋转最小化一个类能量得分。对于通过前两个阶段的每个分子，考虑一个具有以下组件的简化对接设置：\n- 刚性受体相互作用位点，其坐标 $S_{\\mathrm{DON}}$、$S_{\\mathrm{ACC}}$ 和 $S_{\\mathrm{HYD}}$ 固定，单位为 $\\mathrm{\\mathring{A}}$。配体的 $\\mathrm{DON}$ 特征是锚点，对于所有候选构象，该锚点都会被平移到 $S_{\\mathrm{DON}}$。\n- 单一的内部柔性，通过绕经过锚点 $S_{\\mathrm{DON}}$ 的 $z$ 轴旋转来建模。设 $\\theta \\in \\Theta$ 为一个离散的旋转角集合。对于每个 $\\theta$，使用标准的 $xy$ 平面旋转，将配体的 $\\mathrm{ACC}$ 和 $\\mathrm{HYD}$ 特征坐标绕锚点旋转 $\\theta$。\n- 一个由各向同性高斯项之和定义的吸引能：\n$$\nE_{\\mathrm{attr}}(\\theta) \\;=\\; -\\,w_{\\mathrm{ACC}} \\exp\\!\\Big(\\!-\\frac{\\|R_{\\theta}(P_{\\mathrm{ACC}}-P_{\\mathrm{DON}}) + S_{\\mathrm{DON}} - S_{\\mathrm{ACC}}\\|^2}{2\\sigma^2}\\Big) \\;-\\; w_{\\mathrm{HYD}} \\exp\\!\\Big(\\!-\\frac{\\|R_{\\theta}(P_{\\mathrm{HYD}}-P_{\\mathrm{DON}}) + S_{\\mathrm{DON}} - S_{\\mathrm{HYD}}\\|^2}{2\\sigma^2}\\Big),\n$$\n其中 $P_{\\mathrm{DON}}$、$P_{\\mathrm{ACC}}$ 和 $P_{\\mathrm{HYD}}$ 是分子的原始特征坐标，$R_{\\theta}$ 是绕 $z$ 轴旋转角度 $\\theta$ 的旋转操作，$\\sigma > 0$ 是一个以 $\\mathrm{\\mathring{A}}$ 为单位的长度尺度，$w_{\\mathrm{ACC}}, w_{\\mathrm{HYD}} > 0$ 是权重。\n- 空间冲突罚分。给定一个中心为 $C$、半径为 $R_{\\mathrm{clash}}$（单位为 $\\mathrm{\\mathring{A}}$）的排斥球体，如果任何变换后的特征点严格位于该球体内部，则对该 $\\theta$ 的能量加上一个罚分 $+\\lambda_{\\mathrm{clash}}$：\n$$\nE_{\\mathrm{clash}}(\\theta) \\;=\\; \n\\begin{cases}\n\\lambda_{\\mathrm{clash}},  \\text{if any } \\|Q(\\theta) - C\\| \\lt R_{\\mathrm{clash}},\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $Q(\\theta)$ 遍历在角度 $\\theta$ 下 $\\mathrm{DON}$、$\\mathrm{ACC}$ 和 $\\mathrm{HYD}$ 的变换后位置。总能量为\n$$\nE(\\theta) \\;=\\; E_{\\mathrm{attr}}(\\theta) \\;+\\; E_{\\mathrm{clash}}(\\theta).\n$$\n定义一个分子的对接得分为 $E(\\theta)$ 在 $\\theta \\in \\Theta$ 上的最小值。更低（更负）的值表示对接效果更好。\n\n筛选级联按顺序进行：应用 $2\\text{D}$ 过滤器，然后是 $3\\text{D}$ 药效团过滤器，接着为每个剩余的分子计算对接得分，并选择对接得分最低的分子。如果出现平分，选择索引最小的分子。\n\n您必须在一个固定的库和一个固定的查询上实现该级联，并使用下面描述的三个参数集组成的测试套件对其进行评估。对于每个参数集，您的程序必须根据上述规则输出所选分子的索引（单个整数），如果没有任何分子通过对接阶段，则输出 $-1$。最终的程序输出必须是包含所有三个结果的单行，格式为方括号内以逗号分隔的列表。\n\n使用以下固定的库和查询数据。\n\n- 查询指纹 $F_q$，长度为 $8$：$[1,1,0,1,0,1,0,0]$。\n\n- 包含 $4$ 个分子的库，索引从 $0$ 到 $3$：\n    - 分子 $0$：\n        - 指纹 $F_0 = [1,1,0,1,0,1,0,0]$。\n        - 特征（单位 $\\mathrm{\\mathring{A}}$）：$P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(3,0,0)$, $P_{\\mathrm{HYD}}=(0,4,0)$。\n    - 分子 $1$：\n        - 指纹 $F_1 = [1,0,1,1,0,0,1,0]$。\n        - 特征（单位 $\\mathrm{\\mathring{A}}$）：$P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(2.0,1.0,0)$, $P_{\\mathrm{HYD}}=(-1.0,3.5,0)$。\n    - 分子 $2$：\n        - 指纹 $F_2 = [0,1,0,1,1,0,0,1]$。\n        - 特征（单位 $\\mathrm{\\mathring{A}}$）：$P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(2.5,0.2,0)$, $P_{\\mathrm{HYD}}=(-0.5,4.2,0)$。\n    - 分子 $3$：\n        - 指纹 $F_3 = [0,0,0,1,0,1,0,1]$。\n        - 特征（单位 $\\mathrm{\\mathring{A}}$）：$P_{\\mathrm{DON}}=(0,0,0)$, $P_{\\mathrm{ACC}}=(2.7,0,0)$, $P_{\\mathrm{HYD}}=(0,4.1,0)$。\n\n- 受体相互作用位点（单位 $\\mathrm{\\mathring{A}}$）：$S_{\\mathrm{DON}}=(0,0,0)$, $S_{\\mathrm{ACC}}=(5,0,0)$, $S_{\\mathrm{HYD}}=(0,5,0)$。\n\n- 对所有测试用例通用的对接参数（除非另有说明）：高斯长度尺度 $\\sigma=1.5\\,\\mathrm{\\mathring{A}}$，权重 $w_{\\mathrm{ACC}}=1.0$，$w_{\\mathrm{HYD}}=0.8$，排斥球体中心 $C=(1.0,1.0,0.0)$，排斥半径 $R_{\\mathrm{clash}}=1.0\\,\\mathrm{\\mathring{A}}$，罚分 $\\lambda_{\\mathrm{clash}}=50.0$，以及旋转角集合 $\\Theta$ 由 $[0,2\\pi)$ 范围内的 $24$ 个均匀间隔的值组成。\n\n将测试套件实现为三个参数集，每个参数集指定 $2\\text{D}$ 相似性阈值 $\\tau_{\\mathrm{sim}}$、药效团目标距离 $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$（单位 $\\mathrm{\\mathring{A}}$）以及药效团容差 $\\delta$（单位 $\\mathrm{\\mathring{A}}$）：\n- 测试用例 $1$（理想路径）：$\\tau_{\\mathrm{sim}}=0.5$, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(3.0,4.0,5.0)$, $\\delta=0.3$。\n- 测试用例 $2$（$2\\text{D}$ 相似性的边界包含）：$\\tau_{\\mathrm{sim}}=0.4$, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(3.0,4.0,5.0)$, $\\delta=0.3$。\n- 测试用例 $3$（边缘情况，因严格的 $3\\text{D}$ 模板而无幸存者）：$\\tau_{\\mathrm{sim}}=0.3$, $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)=(2.4,2.4,2.4)$, $\\delta=0.05$。\n\n程序要求和输出格式：\n- 您的程序必须完全按照定义实现三阶段级联。\n- 对于每个测试用例，在通过过滤器的分子中，计算对接后得分最佳的单个分子的索引（从零开始）。如果没有分子幸存，则该测试用例输出 $-1$。\n- 您的程序应生成单行输出，其中包含方括号括起来的逗号分隔结果列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是测试用例 $i$ 的整数结果。",
            "solution": "该问题陈述是一个有效且定义明确的计算练习，其基础是生物信息学和计算化学中的虚拟筛选原理。它自成一体，提供了所有必需的数据、参数和数学定义。分阶段的流程模仿了一个真实（尽管简化了）的筛选级联，从计算密集度较低的方法（$2\\text{D}$ 相似性）逐步过渡到计算密集度较高的方法（$3\\text{D}$ 对接）。目标是实现这个确定性的级联，并针对一组给定的测试参数报告最优分子的索引，如果没有分子通过过滤器则报告 $-1$。该问题在科学上是一致的，在数学上是明确的。\n\n解决方案是通过遵循规定的三阶段级联来实现的。\n\n阶段 $1$：$2\\text{D}$ 相似性搜索\n\n此阶段根据分子与查询分子的结构相似性进行筛选，该相似性使用二进制指纹进行量化。指纹是一个由 $0$ 和 $1$ 组成的向量，表示特定亚结构的存在与否。两个分子（由其指纹集 $A$ 和 $B$ 表示）之间的相似性使用Tanimoto系数 $T(A,B)$ 计算。该系数定义为集合交集的大小除以并集的大小：\n$$\nT(A,B) = \\frac{|A \\cap B|}{|A \\cup B|}\n$$\n问题提供了等效的计算公式：$T(A,B) = \\frac{c}{a + b - c}$，其中 $a = |A|$，$b = |B|$，且 $c = |A \\cap B|$。一个指纹为 $F_{mol}$ 的分子，如果其与查询指纹 $F_q$ 的Tanimoto系数达到或超过给定的阈值 $\\tau_{\\mathrm{sim}}$，则通过此过滤器：\n$$\nT(F_{mol}, F_q) \\ge \\tau_{\\mathrm{sim}}\n$$\n\n阶段 $2$：$3\\text{D}$ 药效团过滤\n\n通过第一阶段的分子接下来会经过一个基于 $3\\text{D}$ 药效团模型的几何过滤器。药效团表示分子识别所需关键特征的空间排列。在本问题中，该模型包含三个特征——一个氢键供体（$\\mathrm{DON}$）、一个受体（$\\mathrm{ACC}$）和一个疏水基团（$\\mathrm{HYD}$）——以及它们之间的一组目标距离 $\\big(d^{\\star}_{\\mathrm{DA}}, d^{\\star}_{\\mathrm{DH}}, d^{\\star}_{\\mathrm{AH}}\\big)$。一个拥有其自身内部特征距离 $\\big(d_{\\mathrm{DA}}, d_{\\mathrm{DH}}, d_{\\mathrm{AH}}\\big)$ 的分子，如果其每个内部距离都在相应目标距离的指定容差 $\\delta$ 范围内，则被视为匹配。也就是说，必须满足以下所有三个条件：\n$$\n|d_{\\mathrm{DA}} - d^{\\star}_{\\mathrm{DA}}| \\le \\delta \\\\\n|d_{\\mathrm{DH}} - d^{\\star}_{\\mathrm{DH}}| \\le \\delta \\\\\n|d_{\\mathrm{AH}} - d^{\\star}_{\\mathrm{AH}}| \\le \\delta\n$$\n距离 $d_{XY}$ 是分子内特征 $X$ 和 $Y$ 坐标之间的标准欧几里得距离。\n\n阶段 $3$：柔性对接与评分\n\n最后一个阶段评估剩余分子与刚性受体模型的结合情况。这个简化的对接协议涉及单一的内部柔性自由度和一个类能量评分函数。\n\n- **构象生成**：为每个分子生成一组构象。分子的 $\\mathrm{DON}$ 特征被指定为锚点，并平移到受体对应的位点 $S_{\\mathrm{DON}}$。分子的其余部分随后绕通过此锚点的 $z$ 轴旋转。旋转在一组离散的角度 $\\Theta$ 上采样，该集合由 $[0, 2\\pi)$ 范围内的 $24$ 个均匀间隔的值组成。对于每个角度 $\\theta \\in \\Theta$，$\\mathrm{ACC}$ 和 $\\mathrm{HYD}$ 特征的坐标被变换。如果点 $P_X$ 是分子原始坐标系中的一个特征坐标，在将锚点 $P_{DON}$ 移动到 $S_{DON}$ 并旋转后，其变换后的坐标 $Q_X(\\theta)$ 为：\n  $$\n  Q_X(\\theta) = R_{\\theta}(P_X - P_{\\mathrm{DON}}) + S_{\\mathrm{DON}}\n  $$\n  其中 $R_{\\theta}$ 是绕 $z$ 轴旋转角度 $\\theta$ 的标准 $3\\text{D}$ 旋转矩阵。\n\n- **评分函数**：每个构象的拟合优度通过总能量得分 $E(\\theta)$ 进行评估，该得分是吸引项 $E_{\\mathrm{attr}}(\\theta)$ 和空间冲突罚分 $E_{\\mathrm{clash}}(\\theta)$ 的总和。\n\n  吸引能被建模为负高斯函数的和，用以奖励配体特征（$\\mathrm{ACC}$、$\\mathrm{HYD}$）与其各自受体位点（$S_{\\mathrm{ACC}}$、$S_{\\mathrm{HYD}}$）之间的接近程度：\n  $$\n  E_{\\mathrm{attr}}(\\theta) = -w_{\\mathrm{ACC}} \\exp\\left(-\\frac{\\|Q_{\\mathrm{ACC}}(\\theta) - S_{\\mathrm{ACC}}\\|^2}{2\\sigma^2}\\right) - w_{\\mathrm{HYD}} \\exp\\left(-\\frac{\\|Q_{\\mathrm{HYD}}(\\theta) - S_{\\mathrm{HYD}}\\|^2}{2\\sigma^2}\\right)\n  $$\n  此处，$w_X$ 是正权重，$\\sigma$ 是一个定义势阱宽度的长度尺度。\n\n  如果任何变换后的特征点 $Q_X(\\theta)$ 侵入一个被建模为中心为 $C$、半径为 $R_{\\mathrm{clash}}$ 的排斥体积，则施加空间冲突罚分。如果对于任何特征 $X \\in \\{\\mathrm{DON, ACC, HYD}\\}$，有 $\\|Q_X(\\theta) - C\\|  R_{\\mathrm{clash}}$，则为该角度 $\\theta$ 的能量增加一个大的正罚分 $\\lambda_{\\mathrm{clash}}$。否则，罚分为 $0$。\n  $$\n  E(\\theta) = E_{\\mathrm{attr}}(\\theta) + E_{\\mathrm{clash}}(\\theta)\n  $$\n\n- **对接得分**：一个分子的最终对接得分是在所有采样旋转中找到的最小能量构象：\n  $$\n  \\text{Score} = \\min_{\\theta \\in \\Theta} E(\\theta)\n  $$\n\n最终选择\n\n对每个测试用例顺序执行该级联。从通过所有三个阶段的分子集合中，选择对接得分最低（最负）的分子作为获胜者。如果有两个或多个分子获得相同的最低分，则选择原始索引较小（从 $0$ 到 $3$）的那个。如果没有分子能通过整个级联，结果报告为 $-1$。对所提供的所有三个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs the three-stage virtual screening cascade for the given test cases.\n    \"\"\"\n    \n    # --- Fixed Data and Parameters ---\n    \n    # Query fingerprint\n    F_Q = np.array([1, 1, 0, 1, 0, 1, 0, 0], dtype=int)\n\n    # Library of molecules\n    MOLECULES = [\n        {\n            \"id\": 0,\n            \"fp\": np.array([1, 1, 0, 1, 0, 1, 0, 0], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([3.0, 0.0, 0.0]),\n                \"HYD\": np.array([0.0, 4.0, 0.0]),\n            },\n        },\n        {\n            \"id\": 1,\n            \"fp\": np.array([1, 0, 1, 1, 0, 0, 1, 0], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.0, 1.0, 0.0]),\n                \"HYD\": np.array([-1.0, 3.5, 0.0]),\n            },\n        },\n        {\n            \"id\": 2,\n            \"fp\": np.array([0, 1, 0, 1, 1, 0, 0, 1], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.5, 0.2, 0.0]),\n                \"HYD\": np.array([-0.5, 4.2, 0.0]),\n            },\n        },\n        {\n            \"id\": 3,\n            \"fp\": np.array([0, 0, 0, 1, 0, 1, 0, 1], dtype=int),\n            \"coords\": {\n                \"DON\": np.array([0.0, 0.0, 0.0]),\n                \"ACC\": np.array([2.7, 0.0, 0.0]),\n                \"HYD\": np.array([0.0, 4.1, 0.0]),\n            },\n        },\n    ]\n\n    # Receptor and common docking parameters\n    RECEPTOR_SITES = {\n        \"DON\": np.array([0.0, 0.0, 0.0]),\n        \"ACC\": np.array([5.0, 0.0, 0.0]),\n        \"HYD\": np.array([0.0, 5.0, 0.0]),\n    }\n    DOCKING_PARAMS = {\n        \"sigma\": 1.5,\n        \"w_acc\": 1.0,\n        \"w_hyd\": 0.8,\n        \"clash_C\": np.array([1.0, 1.0, 0.0]),\n        \"clash_R\": 1.0,\n        \"clash_lambda\": 50.0,\n        \"angles\": np.linspace(0, 2 * np.pi, 24, endpoint=False),\n    }\n\n    # Test suite parameter sets\n    test_cases = [\n        # (tau_sim, (d_DA_star, d_DH_star, d_AH_star), delta)\n        (0.5, (3.0, 4.0, 5.0), 0.3),  # Test case 1\n        (0.4, (3.0, 4.0, 5.0), 0.3),  # Test case 2\n        (0.3, (2.4, 2.4, 2.4), 0.05), # Test case 3\n    ]\n\n    # --- Helper Functions ---\n    def tanimoto_coeff(fp_a, fp_b):\n        a = np.sum(fp_a)\n        b = np.sum(fp_b)\n        c = np.sum(np.logical_and(fp_a, fp_b))\n        if a + b - c == 0:\n            return 1.0\n        return c / (a + b - c)\n\n    def internal_distances(coords):\n        d_da = np.linalg.norm(coords[\"ACC\"] - coords[\"DON\"])\n        d_dh = np.linalg.norm(coords[\"HYD\"] - coords[\"DON\"])\n        d_ah = np.linalg.norm(coords[\"ACC\"] - coords[\"HYD\"])\n        return (d_da, d_dh, d_ah)\n\n    def docking_score(molecule, receptor_sites, params):\n        p_don = molecule[\"coords\"][\"DON\"]\n        p_acc = molecule[\"coords\"][\"ACC\"]\n        p_hyd = molecule[\"coords\"][\"HYD\"]\n\n        s_don = receptor_sites[\"DON\"]\n        s_acc = receptor_sites[\"ACC\"]\n        s_hyd = receptor_sites[\"HYD\"]\n\n        v_acc = p_acc - p_don\n        v_hyd = p_hyd - p_don\n\n        min_energy = float('inf')\n\n        for theta in params[\"angles\"]:\n            # 2D rotation matrix for rotation about z-axis\n            cos_t, sin_t = np.cos(theta), np.sin(theta)\n            \n            # Rotated relative vectors\n            rot_v_acc = np.array([v_acc[0] * cos_t - v_acc[1] * sin_t, v_acc[0] * sin_t + v_acc[1] * cos_t, v_acc[2]])\n            rot_v_hyd = np.array([v_hyd[0] * cos_t - v_hyd[1] * sin_t, v_hyd[0] * sin_t + v_hyd[1] * cos_t, v_hyd[2]])\n\n            # Transformed absolute coordinates\n            q_don = s_don\n            q_acc = rot_v_acc + s_don\n            q_hyd = rot_v_hyd + s_don\n            \n            # Attraction energy\n            dist_sq_acc = np.sum((q_acc - s_acc)**2)\n            dist_sq_hyd = np.sum((q_hyd - s_hyd)**2)\n            energy_attr = -params[\"w_acc\"] * np.exp(-dist_sq_acc / (2 * params[\"sigma\"]**2)) \\\n                          -params[\"w_hyd\"] * np.exp(-dist_sq_hyd / (2 * params[\"sigma\"]**2))\n\n            # Clash penalty\n            energy_clash = 0.0\n            clash_R_sq = params[\"clash_R\"]**2\n            clash_points = [q_don, q_acc, q_hyd]\n            for point in clash_points:\n                if np.sum((point - params[\"clash_C\"])**2)  clash_R_sq:\n                    energy_clash = params[\"clash_lambda\"]\n                    break\n            \n            total_energy = energy_attr + energy_clash\n            if total_energy  min_energy:\n                min_energy = total_energy\n        \n        return min_energy\n\n    # --- Main Cascade Logic ---\n    results = []\n    \n    # Pre-calculate molecule properties that don't depend on test case parameters\n    for mol in MOLECULES:\n        mol['tanimoto'] = tanimoto_coeff(mol['fp'], F_Q)\n        mol['distances'] = internal_distances(mol['coords'])\n\n    for case in test_cases:\n        tau_sim, d_star, delta = case\n        d_star_da, d_star_dh, d_star_ah = d_star\n\n        # Stage 1: 2D Similarity Filter\n        survivors_1 = []\n        for mol in MOLECULES:\n            if mol['tanimoto'] = tau_sim:\n                survivors_1.append(mol)\n\n        # Stage 2: 3D Pharmacophore Filter\n        survivors_2 = []\n        for mol in survivors_1:\n            d_da, d_dh, d_ah = mol['distances']\n            if (abs(d_da - d_star_da) = delta and\n                abs(d_dh - d_star_dh) = delta and\n                abs(d_ah - d_star_ah) = delta):\n                survivors_2.append(mol)\n        \n        # Stage 3: Docking and Selection\n        if not survivors_2:\n            results.append(-1)\n            continue\n            \n        best_score = float('inf')\n        best_mol_idx = -1\n\n        for mol in survivors_2:\n            score = docking_score(mol, RECEPTOR_SITES, DOCKING_PARAMS)\n            if score  best_score:\n                best_score = score\n                best_mol_idx = mol[\"id\"]\n        \n        results.append(best_mol_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "运行虚拟筛选后，我们如何判断其效果的好坏？这个练习将向您介绍评估筛选性能的关键指标，如受试者工作特征曲线下面积（$AUC$）和富集因子（$EF$）。通过实现这些指标，您将学会如何客观地评估一个筛选方法区分活性化合物和非活性化合物的能力。该练习还模拟了一个真实场景：比较使用高质量的实验结构与计算同源模建结构进行筛选的结果，这是药物发现中经常遇到的挑战。",
            "id": "2440123",
            "problem": "给定针对同一靶点蛋白的同一配体集的两次虚拟筛选的结果：一次使用X射线晶体结构，另一次使用高质量的同源模型。对于每次筛选，为每个配体提供了一个实值对接分数，其中分数越低表示预测的结合能力越强。此外，还为每个配体提供了一个二元活性标签，其中 $1$ 表示经实验确认的活性物， $0$ 表示非活性物。您必须使用以下定义来量化和比较两次筛选的排序质量。\n\n设配体索引集为 $\\{0,1,\\dots,N-1\\}$。设 $y(j) \\in \\{0,1\\}$ 为配体 $j$ 的真实活性标签，活性索引集为 $A = \\{ j \\mid y(j) = 1 \\}$，非活性索引集为 $I = \\{ j \\mid y(j) = 0 \\}$。设 $s_{C}(j)$ 为来自X射线晶体结构筛选的对接分数， $s_{H}(j)$ 为来自同源模型筛选的对接分数。分数越低越好。\n\n对于给定模型 $M \\in \\{C,H\\}$，其分数为 $s_{M}(j)$，定义如下：\n1. 受试者工作特征（ROC）曲线下面积（AUC）：\n   $$\\mathrm{AUC}(M) = \\frac{1}{|A|\\cdot|I|} \\sum_{a \\in A} \\sum_{i \\in I} \\phi\\big(s_{M}(a), s_{M}(i)\\big),$$\n   其中\n   $$\\phi(x,y) = \\begin{cases}\n   1  \\text{if } x  y,\\\\\n   \\tfrac{1}{2}  \\text{if } x = y,\\\\\n   0  \\text{if } x  y,\n   \\end{cases}$$\n   这反映了一个随机选择的活性物比一个随机选择的非活性物具有严格更好（更低）分数的概率，其中平局贡献为 $\\tfrac{1}{2}$。\n\n2. 在比例 $f \\in (0,1]$ 下的早期富集因子：\n   - 设 $T = f \\cdot N$（在下面的测试套件中假定为整数）。按 $s_{M}(j)$ 升序对配体进行排序。如果在选择边界处出现平局，则首先选择较小的索引来打破平局，以确保恰好选择 $T$ 个配体。\n   - 设 $\\mathrm{TP}_{f}(M)$ 为这些排名前 $T$ 的配体中的活性物数量。设 $|A|$ 为活性物总数。\n   - 定义\n     $$\\mathrm{EF}_{f}(M) = \\frac{\\mathrm{TP}_{f}(M)}{f \\cdot |A|}.$$\n\n3. 两个模型之间排名前 $K$ 的配体集的Jaccard指数：\n   - 对于每个模型，通过取分数最小的 $K$ 个配体（平局时首先选择较小的索引以获得恰好 $K$ 个配体）来形成排名前 $K$ 的集合。\n   - 设 $S_{C}^{(K)}$ 和 $S_{H}^{(K)}$ 为这两个集合。定义\n     $$J^{(K)} = \\frac{\\left| S_{C}^{(K)} \\cap S_{H}^{(K)} \\right|}{\\left| S_{C}^{(K)} \\cup S_{H}^{(K)} \\right|}.$$\n\n对于下方的每个测试用例，计算5元组\n$$\\left[ \\mathrm{AUC}(C),\\ \\mathrm{AUC}(H),\\ \\mathrm{EF}_{f}(C),\\ \\mathrm{EF}_{f}(H),\\ J^{(K)} \\right],$$\n所有值四舍五入到6位小数。\n\n测试套件（每个用例指定了 $N$、两个分数列表、活性标签、比例 $f$ 和整数 $K$）：\n\n- 用例 $1$：\n  - $N = 12$\n  - $s_{C} = [-9.8,\\ -7.3,\\ -10.5,\\ -6.8,\\ -8.1,\\ -9.1,\\ -7.0,\\ -8.7,\\ -6.5,\\ -10.2,\\ -7.9,\\ -8.3]$\n  - $s_{H} = [-9.0,\\ -7.5,\\ -9.8,\\ -7.2,\\ -8.4,\\ -8.9,\\ -7.1,\\ -8.5,\\ -6.8,\\ -9.7,\\ -7.6,\\ -8.0]$\n  - $y = [1,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0,\\ 0,\\ 1,\\ 0,\\ 0]$\n  - $f = 0.25$\n  - $K = 5$\n\n- 用例 $2$：\n  - $N = 10$\n  - $s_{C} = [-11.0,\\ -10.5,\\ -10.2,\\ -9.8,\\ -8.0,\\ -7.9,\\ -7.5,\\ -7.2,\\ -7.0,\\ -6.8]$\n  - $s_{H} = [-7.5,\\ -7.4,\\ -7.3,\\ -7.2,\\ -10.0,\\ -9.8,\\ -9.5,\\ -9.2,\\ -9.0,\\ -8.8]$\n  - $y = [1,\\ 1,\\ 1,\\ 1,\\ 0,\\ 0,\\ 0,\\ 0,\\ 0,\\ 0]$\n  - $f = 0.2$\n  - $K = 3$\n\n- 用例 $3$：\n  - $N = 8$\n  - $s_{C} = [-8.0,\\ -9.0,\\ -8.0,\\ -9.0,\\ -8.0,\\ -8.0,\\ -9.0,\\ -8.0]$\n  - $s_{H} = [-8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5,\\ -8.5]$\n  - $y = [0,\\ 1,\\ 0,\\ 1,\\ 0,\\ 0,\\ 1,\\ 0]$\n  - $f = 0.5$\n  - $K = 4$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个按用例划分的结果列表，每个用例的结果是上述的5元组，四舍五入到6位小数。该单行必须是一个有效的列表的列表，不含任何空格。例如：$[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],\\dots]$ 其中每个 $x_{ij}$ 是一个小数点后恰好有6位数字的十进制数。",
            "solution": "问题陈述已经过严格评估，被认为是有效的。它在计算药物发现领域具有科学依据，问题阐述清晰，具有精确的数学定义和明确的测试用例，并且其表述是客观的。所有必要的数据、条件和约束都已提供，不存在逻辑矛盾或含糊之处。因此，我将继续推导解决方案。\n\n任务是使用三个不同的指标来评估和比较两种虚拟筛选模型的性能——一种基于X射线晶体结构（$C$），另一种基于同源模型（$H$）：受试者工作特征曲线下面积（$\\mathrm{AUC}$）、早期富集因子（$\\mathrm{EF}_f$）和Jaccard指数（$J^{(K)}$）。解决方案要求系统地实现这些指标的算法，并严格遵守指定的平局打破规则。\n\n设所有 $N$ 个配体的集合由 $j \\in \\{0, 1, \\dots, N-1\\}$ 索引。对于每个配体 $j$，我们给定一个二元活性标签 $y(j)$ 和两个对接分数 $s_C(j)$ 和 $s_H(j)$。\n\n首先，我们根据活性标签定义辅助集：活性配体集 $A = \\{j \\mid y(j) = 1\\}$ 和非活性配体集 $I = \\{j \\mid y(j) = 0\\}$，其基数分别为 $|A|$ 和 $|I|$。\n\n计算每个所需量的算法方法如下：\n\n1.  **受试者工作特征曲线下面积（$\\mathrm{AUC}(M)$）**\n\n模型 $M \\in \\{C, H\\}$ 的 $\\mathrm{AUC}$ 是衡量其将活性配体排在非活性配体之前的能力的指标。所提供的公式是曼-惠特尼U检验统计量的直接实现，该统计量等价于 $\\mathrm{AUC}$：\n$$\n\\mathrm{AUC}(M) = \\frac{1}{|A|\\cdot|I|} \\sum_{a \\in A} \\sum_{i \\in I} \\phi\\big(s_{M}(a), s_{M}(i)\\big)\n$$\n其中函数 $\\phi(x, y)$ 在 $x  y$ 时值为 $1$，在 $x = y$ 时值为 $\\frac{1}{2}$，在 $x  y$ 时值为 $0$。这对应于一个随机选择的活性配体比一个随机选择的非活性配体有更好（更低）分数的概率。\n\n该算法是此公式的直接实现：\n- 将分数 $s_M$ 分为两组：活性分数 $\\{s_M(a) \\mid a \\in A\\}$ 和非活性分数 $\\{s_M(i) \\mid i \\in I\\}$。\n- 初始化一个总和 $\\Sigma_\\phi = 0$。\n- 对于每个活性分数 $s_M(a)$，遍历所有非活性分数 $s_M(i)$，并将 $\\phi(s_M(a), s_M(i))$ 加入总和 $\\Sigma_\\phi$。\n- 最终的 $\\mathrm{AUC}(M)$ 计算为 $\\frac{\\Sigma_\\phi}{|A| \\cdot |I|}$。必须对模型 $C$ 和 $H$ 都执行此计算。\n\n2.  **早期富集因子（$\\mathrm{EF}_{f}(M)$）**\n\n$\\mathrm{EF}_f$ 指标量化了在排序列表的前 $f$ 部分中发现了多少活性配体，与随机选择相比。\n$$\n\\mathrm{EF}_{f}(M) = \\frac{\\mathrm{TP}_{f}(M)}{f \\cdot |A|}\n$$\n此计算的关键是配体的正确排序。问题指定配体按分数 $s_M(j)$ 升序排列，平局时首先选择较小的配体索引 $j$ 来打破。\n\n该算法流程如下：\n- 对于给定模型 $M$，为所有配体 $j \\in \\{0, \\dots, N-1\\}$ 创建一个元组列表 $(s_M(j), j)$。\n- 对此列表进行稳定排序，首先按分数（升序），然后按索引（升序）。这正确地实现了指定的平局打破规则。\n- 确定要选择的配体数量 $T = f \\cdot N$。给定这是一个整数。\n- 从排序后的列表中选择前 $T$ 个配体。\n- 统计真阳性（true positives）的数量 $\\mathrm{TP}_f(M)$，即这个排名前 $T$ 的集合中活性配体（其中 $y(j)=1$）的数量。\n- 使用上述公式计算富集因子。分母 $f \\cdot |A|$ 代表在随机选择 $T$ 个配体时预期得到的活性物数量。\n\n3.  **Jaccard指数（$J^{(K)}$）**\n\nJaccard指数衡量由两个模型 $C$ 和 $H$ 预测的排名前 $K$ 配体集之间的相似性。\n$$\nJ^{(K)} = \\frac{\\left| S_{C}^{(K)} \\cap S_{H}^{(K)} \\right|}{\\left| S_{C}^{(K)} \\cup S_{H}^{(K)} \\right|}\n$$\n排名前 $K$ 的集合 $S_C^{(K)}$ 和 $S_H^{(K)}$ 是使用与富集因子相同的排序和平局打破程序构建的。\n\n该算法是：\n- 对于模型 $C$，生成配体的排序列表，并选择排名前 $K$ 配体的索引以形成集合 $S_C^{(K)}$。\n- 对模型 $H$ 重复此过程以形成集合 $S_H^{(K)}$。\n- 计算这两个集合交集的基数 $|S_C^{(K)} \\cap S_H^{(K)}|$。\n- 计算这两个集合并集的基数 $|S_C^{(K)} \\cup S_H^{(K)}|$。注意 $|S_C^{(K)} \\cup S_H^{(K)}| = |S_C^{(K)}| + |S_H^{(K)}| - |S_C^{(K)} \\cap S_H^{(K)}| = 2K - |S_C^{(K)} \\cap S_H^{(K)}|$。\n- Jaccard指数是这两个基数的比率。\n\n对于每个测试用例，将这三种算法应用于所提供的数据，以计算五个所需的值：$\\mathrm{AUC}(C)$、$\\mathrm{AUC}(H)$、$\\mathrm{EF}_f(C)$、$\\mathrm{EF}_f(H)$ 和 $J^{(K)}$。然后将结果四舍五入到6位小数，并按指定格式进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_top_n_indices(scores: np.ndarray, n: int) - list[int]:\n    \"\"\"\n    Ranks ligands by score (ascending) and index (ascending for ties)\n    and returns the indices of the top n ligands.\n    \"\"\"\n    N = len(scores)\n    # Create pairs of (score, index) for sorting.\n    indexed_scores = sorted([(scores[j], j) for j in range(N)])\n    # Extract indices from the top n sorted pairs.\n    top_indices = [index for score, index in indexed_scores[:n]]\n    return top_indices\n\ndef calculate_auc(scores: np.ndarray, y: np.ndarray) - float:\n    \"\"\"\n    Calculates the Area Under the ROC Curve (AUC).\n    \"\"\"\n    active_indices = np.where(y == 1)[0]\n    inactive_indices = np.where(y == 0)[0]\n\n    num_actives = len(active_indices)\n    num_inactives = len(inactive_indices)\n\n    if num_actives == 0 or num_inactives == 0:\n        return 0.5  # Per convention, AUC is 0.5 if one class is missing.\n\n    active_scores = scores[active_indices]\n    inactive_scores = scores[inactive_indices]\n\n    # Vectorized comparison\n    # Reshape for broadcasting: active_scores (num_actives, 1), inactive_scores (1, num_inactives)\n    # Resulting comparison matrices have shape (num_actives, num_inactives)\n    less_than_count = np.sum(active_scores[:, np.newaxis]  inactive_scores)\n    equal_to_count = np.sum(active_scores[:, np.newaxis] == inactive_scores)\n\n    phi_sum = less_than_count + 0.5 * equal_to_count\n    \n    auc = phi_sum / (num_actives * num_inactives)\n    return auc\n\ndef calculate_ef(scores: np.ndarray, y: np.ndarray, f: float) - float:\n    \"\"\"\n    Calculates the Early Enrichment Factor at fraction f.\n    \"\"\"\n    N = len(y)\n    num_actives_total = np.sum(y)\n    \n    if num_actives_total == 0:\n        return 0.0 # No actives to enrich.\n\n    T = int(f * N)\n    if T == 0:\n        return 0.0\n\n    top_indices = get_top_n_indices(scores, T)\n    \n    # Count true positives in the top T ligands\n    tp_f = np.sum(y[top_indices])\n    \n    # Denominator is the expected number of actives in a random selection of size T\n    ef = tp_f / (f * num_actives_total)\n    return ef\n\ndef calculate_jaccard(scores_c: np.ndarray, scores_h: np.ndarray, k: int) - float:\n    \"\"\"\n    Calculates the Jaccard index between the top-K sets of two models.\n    \"\"\"\n    if k == 0:\n        return 1.0 if len(scores_c) == 0 else 0.0\n\n    top_k_indices_c = get_top_n_indices(scores_c, k)\n    top_k_indices_h = get_top_n_indices(scores_h, k)\n\n    set_c = set(top_k_indices_c)\n    set_h = set(top_k_indices_h)\n    \n    intersection_size = len(set_c.intersection(set_h))\n    union_size = len(set_c.union(set_h))\n\n    if union_size == 0:\n        return 1.0 # By convention, Jaccard of two empty sets is 1.\n\n    jaccard = intersection_size / union_size\n    return jaccard\n\ndef process_case(s_c: list, s_h: list, y_labels: list, f: float, k: int) - list[float]:\n    \"\"\"\n    Processes a single test case and computes all required metrics.\n    \"\"\"\n    s_c_np = np.array(s_c)\n    s_h_np = np.array(s_h)\n    y_np = np.array(y_labels)\n\n    auc_c = calculate_auc(s_c_np, y_np)\n    auc_h = calculate_auc(s_h_np, y_np)\n\n    ef_c = calculate_ef(s_c_np, y_np, f)\n    ef_h = calculate_ef(s_h_np, y_np, f)\n    \n    jaccard_k = calculate_jaccard(s_c_np, s_h_np, k)\n\n    return [auc_c, auc_h, ef_c, ef_h, jaccard_k]\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the calculations, and prints the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 12,\n            \"s_C\": [-9.8, -7.3, -10.5, -6.8, -8.1, -9.1, -7.0, -8.7, -6.5, -10.2, -7.9, -8.3],\n            \"s_H\": [-9.0, -7.5, -9.8, -7.2, -8.4, -8.9, -7.1, -8.5, -6.8, -9.7, -7.6, -8.0],\n            \"y\": [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],\n            \"f\": 0.25,\n            \"K\": 5\n        },\n        {\n            \"N\": 10,\n            \"s_C\": [-11.0, -10.5, -10.2, -9.8, -8.0, -7.9, -7.5, -7.2, -7.0, -6.8],\n            \"s_H\": [-7.5, -7.4, -7.3, -7.2, -10.0, -9.8, -9.5, -9.2, -9.0, -8.8],\n            \"y\": [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],\n            \"f\": 0.2,\n            \"K\": 3\n        },\n        {\n            \"N\": 8,\n            \"s_C\": [-8.0, -9.0, -8.0, -9.0, -8.0, -8.0, -9.0, -8.0],\n            \"s_H\": [-8.5, -8.5, -8.5, -8.5, -8.5, -8.5, -8.5, -8.5],\n            \"y\": [0, 1, 0, 1, 0, 0, 1, 0],\n            \"f\": 0.5,\n            \"K\": 4\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result_tuple = process_case(case[\"s_C\"], case[\"s_H\"], case[\"y\"], case[\"f\"], case[\"K\"])\n        all_results.append(result_tuple)\n    \n    # Manually construct the output string to match the required format without spaces.\n    formatted_results = []\n    for res_tuple in all_results:\n        # Format each float to 6 decimal places and join into a string like \"[x.xxxxxx,y.yyyyyy,...]\"\n        formatted_tuple_str = f\"[{','.join([f'{v:.6f}' for v in res_tuple])}]\"\n        formatted_results.append(formatted_tuple_str)\n    \n    # Join the individual case strings into the final list-of-lists format \"[[...],[...]]\"\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "没有任何单一的对接程序或打分函数是完美的，它们各自都有其优势和局限性。提高虚拟筛选结果可靠性的一个有效策略是“共识打分”，即整合多种不同方法的排序结果。本练习将向您展示如何通过对不同打分函数输出进行归一化和加权聚合来合并它们，这是一种在实践中用于增强对高排名候选化合物信心的强大技术。",
            "id": "2440194",
            "problem": "您会获得由三个不同程序为同一组配体生成的三份独立的对接分数列表。每个程序的原始分数都有一个已知的方向性，用以指示值越高越好还是越低越好。请定义一种共识方法，该方法将分数转换为一个共同的、保序的、无量纲的尺度，然后将它们聚合为单个共识分数，以对配体进行重新排序。实现一个程序，将此方法应用于多个测试用例，并为每个用例返回按降序共识顺序排列的前$k$个配体的整数标识符。\n\n共识方法的数学规范：\n\n- 设存在 $n$ 个配体，由 $i \\in \\{1,\\dots,n\\}$ 索引，以及三个程序，由 $j \\in \\{1,2,3\\}$ 索引。对于程序 $j$，您会获得原始分数 $s_{ij} \\in \\mathbb{R}$ 和一个方向指示符 $d_j \\in \\{-1,+1\\}$，其中 $d_j = +1$ 表示“越高越好”，$d_j = -1$ 表示“越低越好”。\n- 定义方向校正分数 $t_{ij} = d_j \\cdot s_{ij}$，以便对于所有程序，更大的 $t_{ij}$ 表示更好的性能。\n- 将配体 $i$ 在程序 $j$ 中的排名 $r_{ij}$ 定义为按 $t_{\\cdot j}$ 降序排序下的“平均排名”。具体来说，如果所有 $t_{\\cdot j}$ 都按降序排序，平局者将共享它们所占据位置的平均值。因此，最佳值获得排名 $1$，最差值获得排名 $n$，而平局者则获得它们所跨越的连续整数排名的平均值。\n- 通过以下公式将每个排名映射到单位区间分数：\n$$\nq_{ij} =\n\\begin{cases}\n1 - \\dfrac{r_{ij} - 1}{n - 1},  \\text{if } n \\ge 2,\\\\\n1,  \\text{if } n = 1.\n\\end{cases}\n$$\n这使得在每个程序中，$q_{ij} \\in [0,1]$，其中 $1$ 代表最佳，$0$ 代表最差。\n- 设提供了非负权重 $w_j \\ge 0$。设 $S = \\sum_{j=1}^{3} w_j$。定义归一化权重：\n$$\n\\tilde{w}_j =\n\\begin{cases}\n\\dfrac{w_j}{S},  \\text{if } S  0,\\\\\n\\dfrac{1}{3},  \\text{if } S = 0.\n\\end{cases}\n$$\n- 将配体 $i$ 的共识分数定义为：\n$$\nc_i = \\sum_{j=1}^{3} \\tilde{w}_j \\, q_{ij}.\n$$\n- 按如下方式定义配体上的严格全序。固定一个平局容差 $\\varepsilon = 10^{-12}$。对于两个配体 $i$ 和 $k$：\n  1. 如果 $c_i  c_k + \\varepsilon$，则 $i$ 优先于 $k$；如果 $c_k  c_i + \\varepsilon$，则 $k$ 优先于 $i$。\n  2. 否则，按字典序比较排名三元组：$(r_{i1}, r_{i2}, r_{i3})$ 与 $(r_{k1}, r_{k2}, r_{k3})$，在第一个满足 $|r_{ij} - r_{kj}|  \\varepsilon$ 的索引 $j$ 处，优先选择较小者。\n  3. 如果仍然平局，则优先选择较小的配体标识符 $i$。\n\n您的程序必须精确实现上述定义，并为每个测试用例返回前$k$个配体标识符作为整数列表。\n\n测试套件：\n\n- 测试用例 A（一般情况，混合方向，归一化权重，$k = 3$）：\n  - $n = 5$，配体标识符从 $1$ 到 $5$。\n  - 程序 $1$ 分数（越低越好）：$[-8.5, -10.2, -7.1, -9.0, -6.6]$。\n  - 程序 $2$ 分数（越高越好）：$[62.0, 55.0, 78.0, 70.0, 65.0]$。\n  - 程序 $3$ 分数（越低越好）：$[-7.8, -8.0, -6.5, -9.5, -7.0]$。\n  - 方向 $(d_1, d_2, d_3) = (-1, +1, -1)$。\n  - 权重 $(w_1, w_2, w_3) = (0.5, 0.3, 0.2)$。\n  - $k = 3$。\n\n- 测试用例 B（权重归一化和通过排名处理平局，$k = 4$）：\n  - $n = 4$，配体标识符从 $1$ 到 $4$。\n  - 程序 $1$ 分数（越低越好）：$[-9.0, -8.0, -7.0, -6.0]$。\n  - 程序 $2$ 分数（越高越好）：$[50.0, 80.0, 60.0, 40.0]$。\n  - 程序 $3$ 分数（越低越好，有平局）：$[-8.5, -8.5, -6.0, -6.0]$。\n  - 方向 $(d_1, d_2, d_3) = (-1, +1, -1)$。\n  - 权重 $(w_1, w_2, w_3) = (2.0, 1.0, 1.0)$。\n  - $k = 4$。\n\n- 测试用例 C（一个程序中所有分数相等，另一个程序中有平局，$k = 3$）：\n  - $n = 3$，配体标识符从 $1$ 到 $3$。\n  - 程序 $1$ 分数（越低越好，所有分数相等）：$[-7.0, -7.0, -7.0]$。\n  - 程序 $2$ 分数（越高越好）：$[50.0, 60.0, 70.0]$。\n  - 程序 $3$ 分数（越低越好，有平局）：$[-9.0, -8.0, -8.0]$。\n  - 方向 $(d_1, d_2, d_3) = (-1, +1, -1)$。\n  - 权重 $(w_1, w_2, w_3) = (1.0, 1.0, 1.0)$。\n  - $k = 3$。\n\n- 测试用例 D（单配体边界情况，零和权重默认为均等，$k = 1$）：\n  - $n = 1$，配体标识符为 $1$。\n  - 程序 $1$ 分数（越低越好）：$[-8.0]$。\n  - 程序 $2$ 分数（越高越好）：$[65.0]$。\n  - 程序 $3$ 分数（越低越好）：$[-6.5]$。\n  - 方向 $(d_1, d_2, d_3) = (-1, +1, -1)$。\n  - 权重 $(w_1, w_2, w_3) = (0.0, 0.0, 0.0)$。\n  - $k = 1$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为单个括号列表，其中每个元素本身是该测试用例的前 $k$ 个配体标识符的括号分隔、逗号分隔列表，无额外空格。例如，一个包含两个假设结果的有效格式是 `[[1,2],[3,4,5]]`。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在计算药物发现领域具有科学依据，特别涉及虚拟筛选的共识评分方法。该问题定义明确，为算法提供了完整且无歧义的数学规范。所有术语都得到了精确定义，所提供的测试用例是自包含的，并与定义一致。任务是实现指定的算法并将其应用于测试用例。\n\n目标是从多个异构的评分列表中构建配体的共识排名。该过程是一个多步骤的数据融合过程，将按如下方式实现。\n\n设存在 $n$ 个配体，由 $i \\in \\{1, \\dots, n\\}$ 索引，以及 $J=3$ 个评分程序，由 $j \\in \\{1, \\dots, J\\}$ 索引。对于每个配体 $i$ 和程序 $j$，我们获得一个原始分数 $s_{ij}$。\n\n步骤 1：方向校正分数\n来自不同程序的原始分数 $s_{ij}$ 可能有不同的含义；对于某些程序，值越高越好，而对于其他程序，值越低越好。为每个程序提供一个方向指示符 $d_j \\in \\{-1, +1\\}$。我们通过定义一个方向校正分数 $t_{ij}$ 来统一这些分数，使得更高的值总是更好：\n$$t_{ij} = d_j \\cdot s_{ij}$$\n这确保了对于所有程序，排名将基于 $t_{ij}$ 的降序。\n\n步骤 2：排名\n为了使来自不同程序的分数具有可比性，我们将它们转换到一个共同的尺度上。此转换的第一部分涉及将分数转换为排名。对于每个程序 $j$，我们根据其 $t_{ij}$ 值按降序对配体进行排名。当分数相同时，我们使用“平均排名”（midrank）方法，其中平局项获得它们将占据的排名的平均值。设 $r_{ij}$ 为配体 $i$ 根据程序 $j$ 的排名。得分最高的配体获得排名 1（或从 1 开始的平均排名），得分最差的配体获得排名 $n$（或以 $n$ 结束的平均排名）。\n\n步骤 3：排名到分数的归一化\n排名 $r_{ij}$ 的范围是从 1 到 $n$，但它们仍然依赖于配体的数量 $n$。为了创建一个真正的无量纲分数，我们将每个排名映射到区间 $[0, 1]$。配体 $i$ 在程序 $j$ 中的归一化分数 $q_{ij}$ 定义为：\n$$\nq_{ij} =\n\\begin{cases}\n1 - \\dfrac{r_{ij} - 1}{n - 1},  \\text{if } n \\ge 2,\\\\\n1,  \\text{if } n = 1.\n\\end{cases}\n$$\n此转换保留了由排名建立的顺序。最佳排名（$r_{ij}=1$）映射到 $q_{ij}=1$，最差排名（$r_{ij}=n$）映射到 $q_{ij}=0$。\n\n步骤 4：权重归一化\n每个程序 $j$都被分配一个非负权重 $w_j \\ge 0$，以反映其被认为的可靠性或重要性。这些权重被归一化以使其总和为 1，确保最终的共识分数保持在一致的尺度上。设 $S = \\sum_{j=1}^{J} w_j$。归一化权重 $\\tilde{w}_j$ 为：\n$$\n\\tilde{w}_j =\n\\begin{cases}\n\\dfrac{w_j}{S},  \\text{if } S  0,\\\\\n\\dfrac{1}{J},  \\text{if } S = 0.\n\\end{cases}\n$$\n当没有给出明确权重时，$S=0$ 的特殊情况提供了默认的均等加权。\n\n步骤 5：共识分数计算\n每个配体 $i$ 的最终共识分数 $c_i$ 是其在所有程序中的归一化分数 $q_{ij}$ 的加权平均值：\n$$c_i = \\sum_{j=1}^{J} \\tilde{w}_j \\, q_{ij}$$\n此分数将一个配体在所有评估方法中的性能汇总为单个度量。\n\n步骤 6：最终排名与平局处理\n使用一套分层规则来建立配体排名的严格全序。对于任意两个配体 $i$ 和 $k$：\n1. 主要排序标准是共识分数 $c_i$。如果 $c_i  c_k + \\varepsilon$，则配体 $i$ 的排名高于配体 $k$，其中 $\\varepsilon = 10^{-12}$ 是用于处理浮点数比较的数值容差。\n2. 如果共识分数被视为相等（即 $|c_i - c_k| \\le \\varepsilon$），则应用次要的平局处理规则。排名向量 $(r_{i1}, r_{i2}, \\dots, r_{iJ})$ 和 $(r_{k1}, r_{k2}, \\dots, r_{kJ})$ 按字典序进行比较。在第一个不同的位置，排名较小的配体排名较高。使用比较 $|r_{ij} - r_{kj}|  \\varepsilon$。\n3. 如果排名向量也相同，则通过配体标识符来打破最终的平局。整数标识符较小的配体排名较高。\n\n该方法论为从多个来源生成最终统一的配体排名提供了一个稳健且确定性的程序。实现将精确遵循这些步骤，对每个提供的测试用例进行计算，以确定前$k$个配体。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import rankdata\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Test Case A\",\n            \"ligand_ids\": list(range(1, 6)),\n            \"scores\": [\n                [-8.5, -10.2, -7.1, -9.0, -6.6],\n                [62.0, 55.0, 78.0, 70.0, 65.0],\n                [-7.8, -8.0, -6.5, -9.5, -7.0],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [0.5, 0.3, 0.2],\n            \"k\": 3,\n        },\n        {\n            \"name\": \"Test Case B\",\n            \"ligand_ids\": list(range(1, 5)),\n            \"scores\": [\n                [-9.0, -8.0, -7.0, -6.0],\n                [50.0, 80.0, 60.0, 40.0],\n                [-8.5, -8.5, -6.0, -6.0],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [2.0, 1.0, 1.0],\n            \"k\": 4,\n        },\n        {\n            \"name\": \"Test Case C\",\n            \"ligand_ids\": list(range(1, 4)),\n            \"scores\": [\n                [-7.0, -7.0, -7.0],\n                [50.0, 60.0, 70.0],\n                [-9.0, -8.0, -8.0],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [1.0, 1.0, 1.0],\n            \"k\": 3,\n        },\n        {\n            \"name\": \"Test Case D\",\n            \"ligand_ids\": [1],\n            \"scores\": [\n                [-8.0],\n                [65.0],\n                [-6.5],\n            ],\n            \"directions\": [-1, 1, -1],\n            \"weights\": [0.0, 0.0, 0.0],\n            \"k\": 1,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_case(\n            case[\"ligand_ids\"],\n            case[\"scores\"],\n            case[\"directions\"],\n            case[\"weights\"],\n            case[\"k\"],\n        )\n        all_results.append(result)\n\n    # Format output as a single string per problem specification\n    # e.g., [[1,2],[3,4,5]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_case(ligand_ids, scores, directions, weights, k):\n    \"\"\"\n    Implements the consensus scoring and ranking method for a single test case.\n    \"\"\"\n    scores_np = np.array(scores, dtype=float).T\n    n_ligands, n_programs = scores_np.shape\n    \n    # Step 1: Orientation-corrected scores\n    directions_np = np.array(directions, dtype=float)\n    t_scores = scores_np * directions_np\n\n    # Step 2: Ranking\n    ranks = np.zeros_like(t_scores)\n    for j in range(n_programs):\n        # rankdata ranks ascending, so we rank the negative of the scores\n        # for descending rank.\n        ranks[:, j] = rankdata(-t_scores[:, j], method='average')\n\n    # Step 3: Rank-to-Score Normalization\n    if n_ligands = 2:\n        q_scores = 1 - (ranks - 1) / (n_ligands - 1)\n    else: # n_ligands == 1\n        q_scores = np.ones_like(ranks)\n\n    # Step 4: Weight Normalization\n    weights_np = np.array(weights, dtype=float)\n    sum_weights = np.sum(weights_np)\n    if sum_weights  0:\n        norm_weights = weights_np / sum_weights\n    else:\n        norm_weights = np.full(n_programs, 1.0 / n_programs)\n\n    # Step 5: Consensus Score Calculation\n    consensus_scores = np.dot(q_scores, norm_weights)\n\n    # Step 6: Final Ranking and Tie-Breaking\n    # Create a list of tuples (ligand_id, consensus_score, rank_tuple) for sorting\n    ligand_data = []\n    for i in range(n_ligands):\n        ligand_data.append((ligand_ids[i], consensus_scores[i], tuple(ranks[i, :])))\n    \n    # Define the custom comparison function for sorting\n    def compare_ligands(item1, item2):\n        id1, c1, r1_tuple = item1\n        id2, c2, r2_tuple = item2\n        epsilon = 1e-12\n\n        # Primary sort: consensus score (descending)\n        if c1  c2 + epsilon:\n            return -1\n        if c2  c1 + epsilon:\n            return 1\n\n        # Secondary sort: rank vectors (lexicographical, ascending)\n        for r1_j, r2_j in zip(r1_tuple, r2_tuple):\n            if r1_j  r2_j - epsilon:\n                return -1\n            if r2_j  r1_j - epsilon:\n                return 1\n\n        # Tertiary sort: ligand ID (ascending)\n        if id1  id2:\n            return -1\n        if id2  id1:\n            return 1\n        \n        return 0\n\n    # Sort using the custom comparison function\n    sorted_ligands = sorted(ligand_data, key=cmp_to_key(compare_ligands))\n    \n    # Extract the top-k ligand identifiers\n    top_k_ids = [item[0] for item in sorted_ligands[:k]]\n    \n    return top_k_ids\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}