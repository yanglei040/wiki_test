{
    "hands_on_practices": [
        {
            "introduction": "To begin our exploration of *ab initio* prediction, we start with a simplified yet powerful abstraction: the lattice model. This exercise challenges you to extend the classic Hydrophobic-Polar (HP) model to include charged residues, allowing you to model electrostatic interactions like salt bridges. By implementing and performing an exhaustive search on this model, you will gain fundamental, hands-on experience with defining a protein's conformation, formulating a simple energy function, and searching a complete sequence-structure space to find an optimal fold .",
            "id": "2369976",
            "problem": "You are asked to formalize and implement an extension of the two-dimensional ($2$D) Hydrophobic-Polar (HP) lattice protein model to a four-letter alphabet model that includes charged residues, denoted Hydrophobic, Polar, Negative, Cationic (HPNC). The goal is to search for a short polypeptide sequence and a self-avoiding $2$D conformation on a square lattice that together achieve a minimal additive contact energy while containing at least one salt bridge. A salt bridge is defined here as a non-consecutive nearest-neighbor lattice contact between a Negative and a Cationic residue.\n\nStart from first principles that are appropriate for lattice protein models used in ab initio protein structure prediction. The fundamental base must be the following facts, without using any shortcut formulas:\n- Proteins can be abstracted as self-avoiding walks on a lattice, where each residue occupies one lattice site and consecutive residues are adjacent on the lattice. Only non-consecutive nearest-neighbor residue pairs are considered as contact interactions.\n- The hydrophobic effect motivates a favorable attraction between hydrophobic residues when they are in contact, modeled by a negative contact energy contribution for hydrophobic-hydrophobic contacts.\n- Electrostatic interactions between charged residues motivate favorable energy for opposite-charge contacts and unfavorable energy for like-charge contacts. In a coarse-grained lattice model at lattice spacing as the unit length, one can approximate this with a constant negative contribution for unlike charges and a constant positive contribution for like charges, applied only to nearest-neighbor non-consecutive contacts.\n- Additivity assumption: the total energy is the sum over pairwise contact energies across all non-consecutive contacting residue pairs.\n\nYour program must implement the following precise model and search protocol.\n- Residue types are an alphabet of size $4$: Hydrophobic ($\\mathrm{H}$), Polar ($\\mathrm{P}$), Negative ($\\mathrm{N}$), and Cationic ($\\mathrm{C}$). A sequence is a string of length $L$ over this alphabet.\n- A conformation is a self-avoiding walk of length $L$ on the $2$D square lattice with coordinates in $\\mathbb{Z}^2$, specified as a list of lattice coordinates $\\left[(x_0,y_0),(x_1,y_1),\\dots,(x_{L-1},y_{L-1})\\right]$ with unit steps and no repeated coordinates. To avoid redundant symmetries, fix $(x_0,y_0)=(0,0)$ and $(x_1,y_1)=(1,0)$.\n- Define the contact set $\\mathcal{C}$ for a conformation as all unordered index pairs $(i,j)$ with $0 \\le i < j \\le L-1$, such that $|i-j| \\ge 2$ and the Manhattan distance between $(x_i,y_i)$ and $(x_j,y_j)$ equals $1$.\n- Define the pairwise contact energy function $\\varepsilon(a,b)$ for residue types $a$ and $b$ as follows, using parameters $e_{\\mathrm{HH}}$, $e_{\\mathrm{NC}}$, and $e_{\\mathrm{like}}$ supplied per test case. Let $\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$ for encoding. Then:\n  - $\\varepsilon(\\mathrm{H},\\mathrm{H})=\\varepsilon(0,0)=e_{\\mathrm{HH}}$.\n  - $\\varepsilon(\\mathrm{N},\\mathrm{C})=\\varepsilon(2,3)=\\varepsilon(\\mathrm{C},\\mathrm{N})=\\varepsilon(3,2)=e_{\\mathrm{NC}}$.\n  - $\\varepsilon(\\mathrm{N},\\mathrm{N})=\\varepsilon(2,2)=e_{\\mathrm{like}}$ and $\\varepsilon(\\mathrm{C},\\mathrm{C})=\\varepsilon(3,3)=e_{\\mathrm{like}}$.\n  - All other residue pairs have $\\varepsilon(a,b)=0$.\n- For a sequence $\\{t_i\\}_{i=0}^{L-1}$ and a conformation with contact set $\\mathcal{C}$, the total energy is\n  $$E=\\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon\\left(t_i,t_j\\right).$$\n- The salt bridge count is\n  $$S=\\left|\\left\\{(i,j)\\in\\mathcal{C}\\;:\\;\\{t_i,t_j\\}=\\{\\mathrm{N},\\mathrm{C}\\}\\right\\}\\right|.$$\n- A solution must have at least one salt bridge, i.e., $S \\ge 1$.\n\nSearch objective and tie-breaking:\n- Among all sequences of length $L$ over the HPNC alphabet and all valid conformations as defined above, find the pair that minimizes $E$ subject to $S \\ge 1$.\n- If multiple pairs achieve the same minimal $E$, choose the one with the largest $S$.\n- If there is still a tie, choose the lexicographically smallest sequence under the encoding $\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$, comparing the integer lists from left to right.\n- If there is still a tie, choose the conformation whose flattened coordinate list $\\left[x_0,y_0,x_1,y_1,\\dots,x_{L-1},y_{L-1}\\right]$ is lexicographically smallest.\n\nSequence encoding and output representation:\n- Encode a sequence as a list of $L$ integers in $\\{0,1,2,3\\}$ corresponding to $\\mathrm{H},\\mathrm{P},\\mathrm{N},\\mathrm{C}$ respectively.\n- Encode a conformation as a list of $L$ coordinate pairs, each coordinate pair being a list of two integers $\\left[x_i,y_i\\right]$.\n\nYour program must perform an exhaustive search that is guaranteed to find the exact optimum for the small test cases below by:\n- Enumerating all self-avoiding walks of length $L$ on the square lattice with the above anchoring.\n- Enumerating all sequences of length $L$ over the alphabet of size $4$.\n- Computing $E$ and $S$ exactly for each pair and applying the objective and tie-breaking rules.\n\nTest suite:\n- Case A (happy path): $L=6$, $e_{\\mathrm{HH}}=-1.0$, $e_{\\mathrm{NC}}=-2.0$, $e_{\\mathrm{like}}=+0.5$.\n- Case B (salt-bridge-dominant): $L=7$, $e_{\\mathrm{HH}}=0.0$, $e_{\\mathrm{NC}}=-2.5$, $e_{\\mathrm{like}}=+0.5$.\n- Case C (strong like-charge repulsion): $L=6$, $e_{\\mathrm{HH}}=-0.5$, $e_{\\mathrm{NC}}=-1.0$, $e_{\\mathrm{like}}=+1.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result corresponds to one test case, in the same order as listed above.\n- Each result must be a list of the form $[E_{\\min},S_{\\mathrm{best}},\\mathrm{seq},\\mathrm{coords}]$ where $E_{\\min}$ is the minimal energy rounded to three decimal places (as a real number), $S_{\\mathrm{best}}$ is the salt bridge count of the selected solution (as an integer), $\\mathrm{seq}$ is the chosen sequence encoded as a list of integers in $\\{0,1,2,3\\}$, and $\\mathrm{coords}$ is the chosen conformation encoded as a list of coordinate pairs as specified.\n- The final output must therefore be a single line containing something like $[\\mathrm{r}_\\mathrm{A},\\mathrm{r}_\\mathrm{B},\\mathrm{r}_\\mathrm{C}]$, where each $\\mathrm{r}_\\mathrm{X}$ is a list in the above format for the corresponding case. Do not print any other text.",
            "solution": "The problem presented is a constrained optimization task within the framework of computational protein structure prediction. It requires the formalization and implementation of a four-letter Hydrophobic-Polar-Negative-Cationic (HPNC) lattice model. The objective is to find a polypeptide sequence and a corresponding self-avoiding conformation on a two-dimensional, $2$D, square lattice that, in concert, achieve the minimum possible additive contact energy, under the constraint that the structure must contain at least one salt bridge. A salt bridge is defined as a non-covalent contact between a Negative ($\\mathrm{N}$) and a Cationic ($\\mathrm{C}$) residue.\n\nThe problem is well-posed, scientifically grounded in the principles of coarse-grained protein models, and provides all necessary definitions and parameters for a unique solution to be determined. The model is an extension of the classic Hydrophobic-Polar (HP) model, incorporating electrostatic effects, which is a standard approach in the field. Given the small sequence lengths specified ($L=6$ and $L=7$), an exhaustive search of the complete conformational and sequence space is computationally feasible and is the only method guaranteed to find the true global optimum as defined by the hierarchical objective function.\n\nThe solution is therefore designed as an exhaustive search algorithm that systematically explores all valid sequence-conformation pairs, evaluates them, and identifies the optimal pair according to the specified criteria. The algorithm proceeds as follows:\n\nFirst, we must generate the entire space of possible molecular entities. This space is the Cartesian product of the set of all unique, valid conformations and the set of all possible sequences of length $L$.\n\nA conformation is a self-avoiding walk of length $L$ on a $2$D square lattice. To generate all such conformations, we employ a recursive backtracking (depth-first search) algorithm. The walk is anchored with the first two residues at coordinates $(x_0,y_0)=(0,0)$ and $(x_1,y_1)=(1,0)$ to eliminate trivial rotational and translational symmetries. The recursion extends the walk one residue at a time, exploring all four cardinal directions, ensuring that the new lattice site is not already occupied. When a walk of length $L$ is completed, it is added to our list of valid conformations.\n\nA sequence is a string of length $L$ over the alphabet $\\{\\mathrm{H}, \\mathrm{P}, \\mathrm{N}, \\mathrm{C}\\}$, which we encode as integers $\\{0, 1, 2, 3\\}$. The total number of sequences is $4^L$. These are generated systematically, ensuring every possible sequence is considered. This can be achieved by iterating through all $L$-digit numbers in base $4$.\n\nFor each pair of a conformation and a sequence, we must calculate its total energy $E$ and its salt bridge count $S$. This evaluation is performed in two steps.\n1. Given a conformation, we first determine its set of contacts, $\\mathcal{C}$. A contact is an unordered pair of residue indices $(i,j)$ such that the residues are non-adjacent in the sequence ($|i-j| \\ge 2$) but occupy adjacent sites on the lattice. The adjacency is determined by checking if the Manhattan distance between their coordinates is equal to $1$.\n2. With the contact set $\\mathcal{C}$ and the sequence $\\{t_i\\}_{i=0}^{L-1}$, we calculate the total energy $E$ and salt bridge count $S$. The total energy is the sum of pairwise interaction energies, $E = \\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon(t_i, t_j)$. The energy function $\\varepsilon(a,b)$ is defined by the problem parameters $e_{\\mathrm{HH}}$, $e_{\\mathrm{NC}}$, and $e_{\\mathrm{like}}$, and is non-zero only for $\\mathrm{H}-\\mathrm{H}$, $\\mathrm{N}-\\mathrm{C}$, $\\mathrm{N}-\\mathrm{N}$, and $\\mathrm{C}-\\mathrm{C}$ contacts. The salt bridge count $S$ is the number of contacts in $\\mathcal{C}$ where the residue types are $\\{\\mathrm{N}, \\mathrm{C}\\}$.\n\nFinally, we identify the optimal solution. The search must adhere to a strict, four-level tie-breaking rule. We seek to:\n1. Minimize the total energy $E$.\n2. For a given minimal $E$, maximize the salt bridge count $S$.\n3. For a given $E$ and $S$, choose the lexicographically smallest sequence (using the integer encoding).\n4. As a final tie-breaker, choose the conformation whose flattened coordinate list is lexicographically smallest.\n\nThis hierarchical optimization is implemented by maintaining a single \"best-so-far\" solution throughout the exhaustive search. Each new valid candidate solution (i.e., where $S \\ge 1$) is compared to the current best. A candidate is deemed \"better\" if its corresponding objective tuple is lexicographically smaller than that of the current best. The objective tuple for a candidate consisting of a sequence $\\mathbf{t}$ and conformation $\\mathbf{x}$ is constructed as $(E, -S, \\mathbf{t}, \\mathbf{x}_{\\text{flat}})$, where $\\mathbf{t}$ is the tuple of integer-encoded residue types and $\\mathbf{x}_{\\text{flat}}$ is the flattened tuple of coordinates. The negation of $S$ correctly transforms the maximization of $S$ into a minimization problem, fitting the lexicographical comparison framework. By iterating through all sequence-conformation pairs and applying this comparison, the algorithm is guaranteed to converge on the unique optimal solution defined by the problem statement.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef generate_conformations(L):\n    \"\"\"\n    Generates all self-avoiding walks of length L on a 2D square lattice,\n    anchored at (0,0) and (1,0).\n    \"\"\"\n    if L < 2:\n        return []\n\n    # Anchored start as specified\n    path = [(0, 0), (1, 0)]\n    if L == 2:\n        return [tuple(path)]\n    \n    visited = set(path)\n    conformations = []\n    \n    def extend_walk(current_path, visited_sites):\n        if len(current_path) == L:\n            conformations.append(tuple(current_path))\n            return\n            \n        last_x, last_y = current_path[-1]\n        # Possible moves: North, South, East, West\n        moves = [(last_x, last_y + 1), (last_x, last_y - 1), (last_x + 1, last_y), (last_x - 1, last_y)]\n        \n        for next_pos in moves:\n            if next_pos not in visited_sites:\n                current_path.append(next_pos)\n                visited_sites.add(next_pos)\n                extend_walk(current_path, visited_sites)\n                visited_sites.remove(next_pos) # Backtrack\n                current_path.pop()\n\n    extend_walk(path, visited)\n    return conformations\n\ndef find_contacts(conf, L):\n    \"\"\"\n    Finds all non-consecutive nearest-neighbor contacts for a given conformation.\n    \"\"\"\n    contacts = []\n    for i in range(L - 1):\n        for j in range(i + 2, L):\n            xi, yi = conf[i]\n            xj, yj = conf[j]\n            if abs(xi - xj) + abs(yi - yj) == 1:\n                contacts.append((i, j))\n    return contacts\n\ndef make_energy_matrix(e_HH, e_NC, e_like):\n    \"\"\"\n    Creates the 4x4 pairwise energy matrix.\n    Encoding: H=0, P=1, N=2, C=3\n    \"\"\"\n    energy_matrix = np.zeros((4, 4), dtype=float)\n    energy_matrix[0, 0] = e_HH\n    energy_matrix[2, 3] = e_NC\n    energy_matrix[3, 2] = e_NC\n    energy_matrix[2, 2] = e_like\n    energy_matrix[3, 3] = e_like\n    return energy_matrix\n\ndef evaluate(seq, contacts, energy_matrix):\n    \"\"\"\n    Calculates total energy E and salt bridge count S for a sequence and its contacts.\n    \"\"\"\n    E = 0.0\n    S = 0\n    N_type, C_type = 2, 3\n    \n    for i, j in contacts:\n        type1, type2 = seq[i], seq[j]\n        E += energy_matrix[type1, type2]\n        if (type1 == N_type and type2 == C_type) or (type1 == C_type and type2 == N_type):\n            S += 1\n    return E, S\n\ndef find_optimal_structure(L, e_HH, e_NC, e_like):\n    \"\"\"\n    Performs the exhaustive search for the optimal sequence and conformation.\n    \"\"\"\n    energy_matrix = make_energy_matrix(e_HH, e_NC, e_like)\n    \n    all_conformations = generate_conformations(L)\n    \n    best_result_tuple = (float('inf'),)\n    best_solution_details = None\n\n    # Pre-calculate contacts for each conformation\n    conf_contacts = {conf: find_contacts(conf, L) for conf in all_conformations}\n    \n    # Iterate through all sequences and conformations to find the optimum\n    for seq in itertools.product(range(4), repeat=L):\n        seq_tuple = tuple(seq)\n        for conf in all_conformations:\n            contacts = conf_contacts[conf]\n            E, S = evaluate(seq_tuple, contacts, energy_matrix)\n\n            if S < 1:\n                continue\n\n            conf_flat_tuple = tuple(coord for pair in conf for coord in pair)\n            current_result_tuple = (E, -S, seq_tuple, conf_flat_tuple)\n\n            if best_solution_details is None or current_result_tuple < best_result_tuple:\n                best_result_tuple = current_result_tuple\n                best_solution_details = (E, S, seq_tuple, conf)\n    \n    E, S, seq, conf = best_solution_details\n    return E, S, list(seq), [list(c) for c in conf]\n\ndef format_result_list(res_list):\n    \"\"\"\n    Formats the final result list for one test case into the required string format.\n    \"\"\"\n    E, S, seq, coords = res_list\n    E_str = f\"{E:.3f}\"\n    seq_str = str(seq).replace(\" \", \"\")\n    coords_str = str(coords).replace(\" \", \"\")\n    return f\"[{E_str},{S},{seq_str},{coords_str}]\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (L, e_HH, e_NC, e_like)\n        (6, -1.0, -2.0, 0.5),  # Case A\n        (7, 0.0, -2.5, 0.5),  # Case B\n        (6, -0.5, -1.0, 1.0),  # Case C\n    ]\n    \n    results = []\n    for L, e_HH, e_NC, e_like in test_cases:\n        E_min, S_best, seq, coords = find_optimal_structure(L, e_HH, e_NC, e_like)\n        results.append([E_min, S_best, seq, coords])\n    \n    final_output_str_parts = [format_result_list(res) for res in results]\n    final_output = f\"[{','.join(final_output_str_parts)}]\"\n    print(final_output)\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "The search for a protein's native structure is conceptually equivalent to finding the global minimum on its free energy landscape. This problem moves from a discrete lattice to a continuous representation, allowing you to explore a tangible, two-dimensional surrogate of this landscape defined by the critical backbone dihedral angles, $\\phi$ and $\\psi$. By numerically minimizing a realistic energy function that includes terms for local propensities and steric clashes, you will develop an intuition for how the energy landscape's shape dictates the energetically favorable conformations of a polypeptide chain .",
            "id": "2369985",
            "problem": "You are given a coarse-grained, two-dimensional, periodic surrogate of a Rosetta-like energy for a peptide with $N$ residues, expressed as a function of a single pair of uniform backbone dihedral angles in degrees, $\\phi \\in [-180, 180]$ and $\\psi \\in [-180, 180]$. The objective is to compute, for each specified parameter set, the global minimizer $(\\phi^\\star, \\psi^\\star)$ and the corresponding minimal energy $E^\\star$ of the energy function over the domain $[-180, 180] \\times [-180, 180]$, assuming angular periodicity of period $360$ degrees in each dimension. The angles must be reported in degrees, and the energy in arbitrary units. All angles must be treated in degrees, and all angle differences must be computed using periodic wrapping as defined below.\n\nDefine the wrapped angular difference function $w(d)$ for any real-valued difference $d$ (in degrees) by\n$$\nw(d) \\equiv d - 360 \\cdot \\mathrm{round}\\!\\left(\\frac{d}{360}\\right),\n$$\nso that $w(d) \\in (-180, 180]$ is the shortest signed difference on the circle.\n\nLet the energy be\n$$\nE(\\phi,\\psi) = N \\left[ -a_\\alpha \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\alpha,\\phi})^2}{\\sigma_{\\alpha,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\alpha,\\psi})^2}{\\sigma_{\\alpha,\\psi}^2}\\right)\\right) - a_\\beta \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\beta,\\phi})^2}{\\sigma_{\\beta,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\beta,\\psi})^2}{\\sigma_{\\beta,\\psi}^2}\\right)\\right) \\right.\n\\left. + \\; p_{\\mathrm{clash}} \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{c,\\phi})^2}{\\sigma_{c}^2} + \\frac{w(\\psi - \\mu_{c,\\psi})^2}{\\sigma_{c}^2}\\right)\\right) \\right] + (N-4)\\, w_{\\mathrm{hb}} \\left[ -h_\\alpha \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\alpha,\\phi})^2}{\\sigma_{\\alpha,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\alpha,\\psi})^2}{\\sigma_{\\alpha,\\psi}^2}\\right)\\right) \\right].\n$$\n\nThe first bracket models residue-local Ramachandran propensities with two favorable wells (an $\\alpha$-helical basin centered at $(\\mu_{\\alpha,\\phi}, \\mu_{\\alpha,\\psi})$ and a $\\beta$-strand basin centered at $(\\mu_{\\beta,\\phi}, \\mu_{\\beta,\\psi})$) and a steric clash penalty centered at $(\\mu_{c,\\phi}, \\mu_{c,\\psi})$. The second bracket models the scaling of $i \\leftrightarrow i+4$ hydrogen bonds that are favored in helices. The constants $(\\sigma_{\\alpha,\\phi}, \\sigma_{\\alpha,\\psi})$, $(\\sigma_{\\beta,\\phi}, \\sigma_{\\beta,\\psi})$, and $\\sigma_c$ are width parameters in degrees.\n\nUse the fixed centers and widths\n- $\\mu_{\\alpha,\\phi} = -57$, $\\mu_{\\alpha,\\psi} = -47$,\n- $\\mu_{\\beta,\\phi} = -135$, $\\mu_{\\beta,\\psi} = 135$,\n- $\\mu_{c,\\phi} = 0$, $\\mu_{c,\\psi} = 0$,\n- $\\sigma_{\\alpha,\\phi} = 18$, $\\sigma_{\\alpha,\\psi} = 18$,\n- $\\sigma_{\\beta,\\phi} = 20$, $\\sigma_{\\beta,\\psi} = 20$,\n- $\\sigma_{c} = 15$.\n\nFor each parameter set $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha)$ listed below, compute\n- the global minimizer angles $(\\phi^\\star, \\psi^\\star)$ in degrees within $[-180,180] \\times [-180,180]$ (any representative within the periodic equivalence class is acceptable), and\n- the minimal energy $E^\\star = \\min_{\\phi,\\psi} E(\\phi,\\psi)$.\n\nTest suite (three parameter sets to be solved in sequence):\n1. $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha) = (30, 1.0, 0.8, 1.5, 0.2, 2.0)$.\n2. $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha) = (30, 1.0, 1.6, 1.5, 0.05, 2.0)$.\n3. $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha) = (30, 0.4, 0.4, 3.0, 0.25, 2.5)$.\n\nAngle unit requirement: all angles must be in degrees. Express $\\phi^\\star$ and $\\psi^\\star$ in degrees. The final numerical outputs must be rounded as follows:\n- $E^\\star$ rounded to $3$ decimal places,\n- $\\phi^\\star$ rounded to $1$ decimal place,\n- $\\psi^\\star$ rounded to $1$ decimal place.\n\nFinal output format: Your program should produce a single line of output containing a list of three lists, one per test case, where each inner list is ordered as $[E^\\star, \\phi^\\star, \\psi^\\star]$ after rounding, for example $[[e_1,\\phi_1,\\psi_1],[e_2,\\phi_2,\\psi_2],[e_3,\\phi_3,\\psi_3]]$.\n\nNo user input is provided; all values are as specified above. Your program must deterministically compute the global minimizers and minimal energies for the three parameter sets, respecting the periodicity of angles and the definitions above.",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Objective**: Find the global minimizer $(\\phi^\\star, \\psi^\\star)$ and minimal energy $E^\\star$ for a given energy function $E(\\phi, \\psi)$.\n- **Domain**: $(\\phi, \\psi) \\in [-180, 180] \\times [-180, 180]$ degrees, with periodic boundary conditions of period $360$ degrees.\n- **Wrapped Angular Difference**: $w(d) \\equiv d - 360 \\cdot \\mathrm{round}\\!\\left(\\frac{d}{360}\\right)$, with resulting range $w(d) \\in (-180, 180]$.\n- **Energy Function**:\n$$\nE(\\phi,\\psi) = N \\left[ -a_\\alpha G_\\alpha(\\phi, \\psi) - a_\\beta G_\\beta(\\phi, \\psi) + p_{\\mathrm{clash}} G_c(\\phi, \\psi) \\right] + (N-4)\\, w_{\\mathrm{hb}} \\left[ -h_\\alpha G_\\alpha(\\phi, \\psi) \\right]\n$$\nwhere the Gaussian terms are defined as:\n$$\nG_\\alpha(\\phi, \\psi) = \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\alpha,\\phi})^2}{\\sigma_{\\alpha,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\alpha,\\psi})^2}{\\sigma_{\\alpha,\\psi}^2}\\right)\\right)\n$$\n$$\nG_\\beta(\\phi, \\psi) = \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{\\beta,\\phi})^2}{\\sigma_{\\beta,\\phi}^2} + \\frac{w(\\psi - \\mu_{\\beta,\\psi})^2}{\\sigma_{\\beta,\\psi}^2}\\right)\\right)\n$$\n$$\nG_c(\\phi, \\psi) = \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{w(\\phi - \\mu_{c,\\phi})^2}{\\sigma_{c}^2} + \\frac{w(\\psi - \\mu_{c,\\psi})^2}{\\sigma_{c}^2}\\right)\\right)\n$$\n- **Fixed Constants** (all angles in degrees):\n  - $\\mu_{\\alpha,\\phi} = -57$, $\\mu_{\\alpha,\\psi} = -47$\n  - $\\mu_{\\beta,\\phi} = -135$, $\\mu_{\\beta,\\psi} = 135$\n  - $\\mu_{c,\\phi} = 0$, $\\mu_{c,\\psi} = 0$\n  - $\\sigma_{\\alpha,\\phi} = 18$, $\\sigma_{\\alpha,\\psi} = 18$\n  - $\\sigma_{\\beta,\\phi} = 20$, $\\sigma_{\\beta,\\psi} = 20$\n  - $\\sigma_{c} = 15$\n- **Parameter Sets** $(N, a_\\alpha, a_\\beta, p_{\\mathrm{clash}}, w_{\\mathrm{hb}}, h_\\alpha)$:\n  1. $(30, 1.0, 0.8, 1.5, 0.2, 2.0)$\n  2. $(30, 1.0, 1.6, 1.5, 0.05, 2.0)$\n  3. $(30, 0.4, 0.4, 3.0, 0.25, 2.5)$\n- **Output Formatting**:\n  - $E^\\star$ rounded to $3$ decimal places.\n  - $\\phi^\\star, \\psi^\\star$ rounded to $1$ decimal place.\n  - Final output: a list of lists `[[E_1, \\phi_1, \\psi_1], [E_2, \\phi_2, \\psi_2], [E_3, \\phi_3, \\psi_3]]`.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is scientifically grounded. It presents a simplified, coarse-grained energy function for a polypeptide, a standard modeling approach in computational structural biology. The terms correspond to Ramachandran propensities, steric clashes, and hydrogen bonding, which are fundamental interactions governing protein structure.\n- **Well-Posedness**: The problem is well-posed. The objective is to find the global minimum of a continuous function $E(\\phi, \\psi)$ over a compact domain, the two-dimensional torus $\\mathbb{T}^2$. By the Extreme Value Theorem, a global minimum is guaranteed to exist. The provided information is sufficient to uniquely determine this minimum energy value $E^\\star$.\n- **Objectivity**: The problem is stated in precise, objective mathematical language. All parameters and functions are explicitly defined.\n\nThere is a minor ambiguity in the definition of $w(d)$. The definition $w(d) = d - 360 \\cdot \\mathrm{round}(d/360)$ combined with the range $w(d) \\in (-180, 180]$ is inconsistent at $d = k \\cdot 180$ for odd integers $k$. For instance, using the standard 'round-half-to-even' convention, $\\mathrm{round}(-0.5)=0$, which yields $w(-180) = -180$. This lies outside the specified range $(-180, 180]$. However, this is a singularity at a single point on the boundary. Since the angles $\\phi=-180^\\circ$ and $\\phi=180^\\circ$ are equivalent under the specified periodicity, and the problem asks for any valid representative of the minimizer, this ambiguity is non-critical and does not impede finding a solution for a continuous energy function. The problem is not invalidated by this minor imprecision.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be provided.\n\n**Solution**\n\nThe task is to find the global minimum of the energy function $E(\\phi, \\psi)$ on the toroidal domain $(\\phi, \\psi) \\in [-180, 180] \\times [-180, 180]$.\n\nFirst, we simplify the expression for the energy $E(\\phi, \\psi)$. The terms involving the $\\alpha$-helical Gaussian $G_\\alpha(\\phi, \\psi)$ can be grouped.\n$$\nE(\\phi,\\psi) = -N a_\\alpha G_\\alpha(\\phi, \\psi) - N a_\\beta G_\\beta(\\phi, \\psi) + N p_{\\mathrm{clash}} G_c(\\phi, \\psi) - (N-4) w_{\\mathrm{hb}} h_\\alpha G_\\alpha(\\phi, \\psi)\n$$\nThis can be rewritten as:\n$$\nE(\\phi, \\psi) = -C_\\alpha G_\\alpha(\\phi, \\psi) - C_\\beta G_\\beta(\\phi, \\psi) + C_c G_c(\\phi, \\psi)\n$$\nwhere the effective coefficients are:\n$$\nC_\\alpha = N a_\\alpha + (N-4) w_{\\mathrm{hb}} h_\\alpha\n$$\n$$\nC_\\beta = N a_\\beta\n$$\n$$\nC_c = N p_{\\mathrm{clash}}\n$$\nNote that for all test cases, $N=30$, so the term $(N-4)$ is positive. The function $E(\\phi, \\psi)$ is therefore a sum of three periodic two-dimensional Gaussian functions. Two of these terms, scaled by $-C_\\alpha$ and $-C_\\beta$, are attractive potentials (energy wells), centered at $(\\mu_{\\alpha,\\phi}, \\mu_{\\alpha,\\psi})$ and $(\\mu_{\\beta,\\phi}, \\mu_{\\beta,\\psi})$ respectively. The third term, scaled by $C_c$, is a repulsive potential (energy barrier), centered at $(\\mu_{c,\\phi}, \\mu_{c,\\psi})$.\n\nThe global energy minimum $(\\phi^\\star, \\psi^\\star)$ must be located in the vicinity of one of the two attractive centers. The exact location is a result of the balance between the two attractive potentials and the repulsive one. An analytical solution for the minimum, obtained by setting the gradient $\\nabla E(\\phi, \\psi) = \\mathbf{0}$, is non-trivial due to the transcendental nature of the equations and the wrapped difference function $w(d)$.\n\nA robust numerical strategy is required. The energy landscape is continuous and has a limited number of significant local minima, corresponding to the basins of attraction of the $G_\\alpha$ and $G_\\beta$ terms. We will employ a local optimization algorithm to find the minima within these two main basins and then compare their energy values to identify the global minimum.\n\nThe methodology is as follows:\n1.  For each parameter set, calculate the coefficients $C_\\alpha$, $C_\\beta$, and $C_c$.\n2.  Define the energy function $E(\\phi, \\psi)$ for the specific parameter set.\n3.  Perform two separate numerical minimizations using the `scipy.optimize.minimize` function with the Nelder-Mead simplex algorithm. This method is suitable as it does not require gradient information, making it robust to the minor discontinuities in the gradient of $w(d)$.\n    -   The first minimization starts from the center of the $\\alpha$-helical well, $\\mathbf{x}_{0,\\alpha} = (\\mu_{\\alpha,\\phi}, \\mu_{\\alpha,\\psi}) = (-57, -47)$.\n    -   The second minimization starts from the center of the $\\beta$-strand well, $\\mathbf{x}_{0,\\beta} = (\\mu_{\\beta,\\phi}, \\mu_{\\beta,\\psi}) = (-135, 135)$.\n4.  The results of these two optimizations, $((\\phi_\\alpha^\\star, \\psi_\\alpha^\\star), E_\\alpha^\\star)$ and $((\\phi_\\beta^\\star, \\psi_\\beta^\\star), E_\\beta^\\star)$, are compared. The one with lower energy is the global minimum for the given parameters.\n5.  The final optimal angles $(\\phi^\\star, \\psi^\\star)$ are normalized to the interval $(-180, 180]$ using the periodic wrapping function to ensure a standard representation.\n6.  The final values for $E^\\star$, $\\phi^\\star$, and $\\psi^\\star$ are rounded according to the problem specification.\n\nThis procedure is repeated for all three test cases provided. The wrapped angular difference function $w(d)$ is implemented directly from its definition, using numerical rounding that rounds values of the form $k.5$ to the nearest even integer.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves for the global energy minimum of a peptide's surrogate energy function for three parameter sets.\n    \"\"\"\n\n    # --- Fixed constants ---\n    # Centers (mu) and widths (sigma) in degrees\n    mu_alpha_phi, mu_alpha_psi = -57.0, -47.0\n    mu_beta_phi, mu_beta_psi = -135.0, 135.0\n    mu_c_phi, mu_c_psi = 0.0, 0.0\n    \n    sigma_alpha_phi, sigma_alpha_psi = 18.0, 18.0\n    sigma_beta_phi, sigma_beta_psi = 20.0, 20.0\n    sigma_c = 15.0\n\n    # --- Test Cases ---\n    test_cases = [\n        # (N, a_alpha, a_beta, p_clash, w_hb, h_alpha)\n        (30, 1.0, 0.8, 1.5, 0.2, 2.0),\n        (30, 1.0, 1.6, 1.5, 0.05, 2.0),\n        (30, 0.4, 0.4, 3.0, 0.25, 2.5)\n    ]\n\n    results = []\n\n    # --- Helper functions ---\n    def w(d):\n        \"\"\"\n        Computes the wrapped angular difference in degrees.\n        d - 360 * round(d/360), result in [-180, 180]\n        \"\"\"\n        return d - 360.0 * np.round(d / 360.0)\n\n    def normalize_angle(angle):\n        \"\"\"\n        Normalizes an angle to the range (-180, 180].\n        \"\"\"\n        wrapped_angle = w(angle)\n        # Map -180 to 180 to conform to (-180, 180]\n        if wrapped_angle == -180.0:\n            return 180.0\n        return wrapped_angle\n\n    for params in test_cases:\n        N, a_alpha, a_beta, p_clash, w_hb, h_alpha = params\n\n        def energy_function(angles):\n            \"\"\"\n            The surrogate energy function E(phi, psi).\n            \"\"\"\n            phi, psi = angles[0], angles[1]\n            \n            # Gaussian term for alpha-helical region\n            term_alpha_exponent = -0.5 * (\n                (w(phi - mu_alpha_phi) / sigma_alpha_phi)**2 + \n                (w(psi - mu_alpha_psi) / sigma_alpha_psi)**2\n            )\n            g_alpha = np.exp(term_alpha_exponent)\n\n            # Gaussian term for beta-strand region\n            term_beta_exponent = -0.5 * (\n                (w(phi - mu_beta_phi) / sigma_beta_phi)**2 + \n                (w(psi - mu_beta_psi) / sigma_beta_psi)**2\n            )\n            g_beta = np.exp(term_beta_exponent)\n\n            # Gaussian term for steric clash region\n            term_clash_exponent = -0.5 * (\n                (w(phi - mu_c_phi) / sigma_c)**2 + \n                (w(psi - mu_c_psi) / sigma_c)**2\n            )\n            g_clash = np.exp(term_clash_exponent)\n            \n            # Ramachandran propensity term\n            e_rama = N * (-a_alpha * g_alpha - a_beta * g_beta + p_clash * g_clash)\n            \n            # Hydrogen-bond term\n            e_hb = 0.0\n            if N > 4:\n                e_hb = (N - 4) * w_hb * (-h_alpha * g_alpha)\n            \n            return e_rama + e_hb\n\n        # --- Optimization ---\n        # Starting points at the center of the two attractive wells\n        x0_alpha = np.array([mu_alpha_phi, mu_alpha_psi])\n        x0_beta = np.array([mu_beta_phi, mu_beta_psi])\n\n        # Minimize starting from the alpha-well\n        res_alpha = minimize(energy_function, x0_alpha, method='Nelder-Mead', options={'xatol': 1e-8, 'fatol': 1e-8})\n\n        # Minimize starting from the beta-well\n        res_beta = minimize(energy_function, x0_beta, method='Nelder-Mead', options={'xatol': 1e-8, 'fatol': 1e-8})\n\n        # Compare results to find the global minimum\n        if res_alpha.fun < res_beta.fun:\n            best_res = res_alpha\n        else:\n            best_res = res_beta\n            \n        e_star = best_res.fun\n        phi_star, psi_star = best_res.x\n\n        # --- Formatting Output ---\n        # Normalize angles to the (-180, 180] range\n        phi_final = normalize_angle(phi_star)\n        psi_final = normalize_angle(psi_star)\n\n        # Round values as specified\n        e_rounded = round(e_star, 3)\n        phi_rounded = round(phi_final, 1)\n        psi_rounded = round(psi_final, 1)\n\n        results.append([e_rounded, phi_rounded, psi_rounded])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "For any realistic protein, the conformational space is too vast to be searched exhaustively. This final practice introduces you to the sophisticated search strategies needed to tackle this complexity, using a more realistic off-lattice model defined by internal coordinates. You will implement a powerful metaheuristic method, Ant Colony Optimization (ACO), to navigate the energy landscape and find low-energy structures. This advanced exercise provides direct insight into how memory-guided, stochastic algorithms can efficiently explore high-dimensional search spaces, a core challenge in modern *ab initio* protein structure prediction .",
            "id": "2369960",
            "problem": "You are given a coarse-grained internal-coordinate model of a polypeptide backbone in three dimensions. Consider a chain of $N$ alpha carbon atoms connected by fixed bond length $b$ and fixed bond angle $\\theta$. The internal degrees of freedom are the backbone dihedral angles $\\{\\phi_i\\}$ for $i \\in \\{3,4,\\dots,N-1\\}$, one dihedral per newly added atom beyond the third. The chain is constructed as follows. Place the first three atoms at\n$p_0 = (0,0,0)$, $p_1 = (b,0,0)$, $p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$. For $i \\ge 3$, given $p_{i-3}, p_{i-2}, p_{i-1}$ and a dihedral angle $\\phi_i \\in [-\\pi,\\pi)$, define unit vectors $u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}$ and $v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$, the normal $n = \\frac{v \\times u}{\\|v \\times u\\|}$, and $m = u \\times n$. Then place\n$$\np_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right).\n$$\n\nDefine the total energy in reduced units for a conformation specified by dihedrals $\\Phi = (\\phi_3,\\dots,\\phi_{N-1})$ as\n$$\nE(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi),\n$$\nwhere the torsional term is\n$$\nE_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right),\n$$\nand the nonbonded term is a Lennard–Jones potential between non-adjacent atoms\n$$\nE_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\nwith $r_{ij} = \\|p_i - p_j\\|$. Use lengths in ångströms (Å), angles in radians, and energies in the same reduced units as $\\varepsilon$.\n\nConsider a discrete memory-based probabilistic constructive process over dihedral angles. For each dihedral index $k \\in \\{3,4,\\dots,N-1\\}$, discretize the domain $[-\\pi,\\pi)$ into $B$ equal-width bins with centers $\\{\\varphi_{k,b}\\}_{b=1}^B$. Maintain a nonnegative memory matrix (the “pheromone” memory) $T \\in \\mathbb{R}_{\\ge 0}^{(N-3)\\times B}$ with entries $T_{k,b}$, initialized uniformly to $T_{k,b} = \\tau_0$. Define a heuristic weight for each bin by\n$$\n\\eta_{k,b} = \\exp\\left(-\\frac{k_t\\left(1 + \\cos(3\\varphi_{k,b})\\right)}{T_h}\\right),\n$$\nwith temperature $T_h > 0$. For parameters $\\alpha > 0$ and $\\beta \\ge 0$, define the probability of choosing bin $b$ at dihedral index $k$ as\n$$\n\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k,b}^{\\alpha}\\,\\eta_{k,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k,b'}^{\\alpha}\\,\\eta_{k,b'}^{\\beta}}.\n$$\nAn iteration consists of generating $M$ complete angle sequences $\\Phi$ by independent sampling of one bin per dihedral according to the product distribution across indices $k$, evaluating $E(\\Phi)$ for each, selecting the single lowest-energy sample in the iteration with energy $E^\\star$, then updating the memory with evaporation rate $\\rho \\in (0,1)$ and a rank-$1$ deposition at the selected bins $\\{b_k^\\star\\}$:\n$$\nT_{k,b} \\leftarrow (1-\\rho) T_{k,b} \\quad \\text{for all } k,b,\n$$\n$$\nT_{k,b_k^\\star} \\leftarrow T_{k,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right) \\quad \\text{for all } k,\n$$\nfollowed by clamping $T_{k,b} \\leftarrow \\min\\{\\tau_{\\max}, \\max\\{\\tau_{\\min}, T_{k,b}\\}\\}$ with $\\tau_{\\min} > 0$ and $\\tau_{\\max} > \\tau_{\\min}$. Repeat for $I$ iterations, and return the lowest energy encountered across all samples and iterations.\n\nUse the following fixed physical and energetic constants for all runs:\n- Bond length $b = 3.8$ Å.\n- Bond angle $\\theta = 111.5^\\circ$ (use radians in computation; $\\theta \\approx 1.946$).\n- Lennard–Jones parameters $\\varepsilon = 0.1$ and $\\sigma = 4.0$ (in Å).\n- Torsional stiffness $k_t = 0.1$.\n- Heuristic temperature $T_h = 1.0$.\n- Deposition strength $Q = 1.0$ and deposition temperature $T_d = 1.0$.\n- Pheromone initialization $\\tau_0 = 1.0$, floor $\\tau_{\\min} = 10^{-6}$, and cap $\\tau_{\\max} = 100.0$.\n\nYour task is to implement the process above and execute it on the following test suite. For each test case, use an independent pseudorandom generator initialized with the given seed, and report the best (lowest) energy $E$ found. Express each answer as a floating-point number rounded to three decimal places.\n\nTest suite (angles in radians, lengths in Å, energies in the units of $\\varepsilon$):\n- Case A (general): $N = 8$, $M = 25$, $I = 40$, $B = 36$, $\\alpha = 1.0$, $\\beta = 2.0$, $\\rho = 0.1$, random seed $s = 1234$.\n- Case B (boundary length): $N = 4$, $M = 16$, $I = 25$, $B = 24$, $\\alpha = 1.0$, $\\beta = 1.0$, $\\rho = 0.3$, random seed $s = 202$.\n- Case C (different balance): $N = 10$, $M = 20$, $I = 30$, $B = 24$, $\\alpha = 1.5$, $\\beta = 1.0$, $\\rho = 0.2$, random seed $s = 999$.\n\nFinal output format: Your program should produce a single line of output containing the results for Cases A, B, and C as a comma-separated list enclosed in square brackets, for example, \"[x_A,x_B,x_C]\". Each $x$ must be the rounded floating-point value as specified above, with no additional text.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is a well-posed problem in computational structural biology, specifically *ab initio* protein structure prediction using a coarse-grained model. All physical parameters, mathematical formulae, and algorithmic definitions are provided, are scientifically sound, and are internally consistent. The problem is a standard energy minimization task, for which the specified metaheuristic, a variant of Ant Colony Optimization (ACO), is a suitable approach. The library `scipy` is not required, as all necessary functionality is provided by `numpy`.\n\nThe solution is implemented by following the specified procedure. The core of the problem is to find the set of dihedral angles $\\Phi = (\\phi_3, \\dots, \\phi_{N-1})$ that minimizes a total energy function $E(\\Phi)$.\n\n**1. Chain Geometry Construction**\n\nThe three-dimensional coordinates of the $N$ atoms, denoted $\\{p_i\\}_{i=0}^{N-1}$, are generated sequentially. The first three atoms, $p_0$, $p_1$, and $p_2$, establish an initial reference frame in the $xy$-plane:\n$$p_0 = (0,0,0)$$\n$$p_1 = (b,0,0)$$\n$$p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$$\nHere, $b$ is the fixed bond length and $\\theta$ is the fixed bond angle. For each subsequent atom $p_i$ ($i \\ge 3$), its position is determined by the positions of the preceding three atoms ($p_{i-3}, p_{i-2}, p_{i-1}$) and a single internal degree of freedom, the dihedral angle $\\phi_i$.\n\nThe construction of $p_i$ is based on defining a local coordinate system. Let $u$ be the unit vector along the bond $p_{i-2} \\to p_{i-1}$, and $v$ be the unit vector along the bond $p_{i-3} \\to p_{i-2}$.\n$$u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}, \\quad v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$$\nA normal vector $n$ to the plane containing these two bonds is given by their cross product, $n = \\text{normalize}(v \\times u)$. A third vector, $m = u \\times n$, completes a right-handed orthonormal basis $\\{u, m, n\\}$. The position of the new atom $p_i$ is then placed relative to $p_{i-1}$ such that the new bond vector $p_i - p_{i-1}$ has length $b$, makes an angle of $\\pi-\\theta$ with vector $p_{i-1}-p_{i-2}$ (thus maintaining the bond angle $\\theta$), and its projection onto the plane perpendicular to $u$ is rotated by the dihedral angle $\\phi_i$. This is captured by the given formula:\n$$p_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right)$$\nThis geometric construction is a standard method in molecular modeling, often referred to as a Natural Extension Reference Frame (NeRF) or similar internal coordinate building algorithm.\n\n**2. Energy Function**\n\nThe potential energy of a given conformation, specified by the set of dihedrals $\\Phi$, is the sum of two terms: a torsional term and a non-bonded interaction term.\n$$E(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi)$$\nThe torsional energy, $E_{\\text{tors}}$, accounts for the energetic barrier to rotation around the backbone bonds:\n$$E_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right)$$\nThe term $k_t$ represents the stiffness of the torsional spring. The $3\\phi_i$ dependence models the three-fold rotational symmetry common in alkane-like chains.\n\nThe non-bonded energy, $E_{\\text{nb}}$, models the van der Waals interactions between atoms that are not close neighbors in the chain. It is calculated using the Lennard-Jones $12-6$ potential:\n$$E_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]$$\nHere, $r_{ij}$ is the Euclidean distance between atoms $p_i$ and $p_j$. The parameters $\\varepsilon$ and $\\sigma$ define the depth and position of the potential well, respectively. The condition $j-i > 2$ correctly excludes bonded neighbors ($1,2$ pairs like $i, i+1$) and bond-angle neighbors ($1,3$ pairs like $i, i+2$), whose interactions are implicitly handled by the fixed bond length and angle constraints.\n\n**3. Ant Colony Optimization (ACO) Algorithm**\n\nThe high-dimensional and non-convex nature of the energy landscape makes finding the global minimum a non-trivial task. The problem specifies a stochastic optimization algorithm based on the ACO metaheuristic.\n\nFirst, the continuous domain $[-\\pi, \\pi)$ for each dihedral angle is discretized into $B$ bins. The search for the optimal conformation is then transformed into a search for the best sequence of bins.\n\nThe algorithm proceeds for $I$ iterations. In each iteration, $M$ candidate solutions (ants) are constructed. Each ant builds a complete sequence of dihedral angles, $\\Phi$, by making a probabilistic choice for each dihedral $\\phi_k$ ($k=3, \\dots, N-1$). The probability of choosing bin $b$ for dihedral $k$ is a function of two components:\n-   **Pheromone trail ($\\tau$)**: A memory matrix $T$ stores the \"desirability\" of choosing each bin for each dihedral, based on past successful solutions. The entry $T_{k,b}$ corresponds to the pheromone level for bin $b$ of dihedral $k$.\n-   **Heuristic information ($\\eta$)**: This term provides *a priori* knowledge about the quality of a choice, independent of the search history. Here, it is based on the local torsional energy of a dihedral angle: $\\eta_{k,b} = \\exp\\left(-\\frac{E_{\\text{tors}}(\\varphi_{k,b})}{T_h}\\right)$. Lower energy choices have higher heuristic value.\n\nThe probability of choosing bin $b$ for the $k$-th dihedral (corresponding to matrix row $k-3$) is given by:\n$$\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k-3,b}^{\\alpha}\\,\\eta_{k-3,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k-3,b'}^{\\alpha}\\,\\eta_{k-3,b'}^{\\beta}}$$\nThe parameters $\\alpha$ and $\\beta$ control the relative influence of the pheromone trail versus the heuristic information.\n\nAfter $M$ solutions are constructed and their energies evaluated, the single best solution of the iteration, with energy $E^\\star$, is used to update the pheromone matrix. The update has two phases:\n1.  **Evaporation**: All pheromone trails are uniformly decreased by a factor of $(1-\\rho)$, where $\\rho \\in (0,1)$ is the evaporation rate. This prevents premature convergence.\n$$T_{k,b} \\leftarrow (1-\\rho) T_{k,b}$$\n2.  **Deposition**: The trails corresponding to the choices made in the iteration's best solution $\\{b_k^\\star\\}$ are reinforced. The amount of deposited pheromone is inversely related to the energy $E^\\star$.\n$$T_{k-3,b_k^\\star} \\leftarrow T_{k-3,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right)$$\nFinally, the pheromone values are clamped between $\\tau_{\\min}$ and $\\tau_{\\max}$ to ensure stability. This entire process guides the search towards promising regions of the conformational space over successive iterations. The lowest energy found across all ants and all iterations is reported as the final result.\n\n**4. Implementation Strategy**\n\nThe described algorithm is implemented in Python using the `numpy` library for efficient numerical and vector operations. A primary function orchestrates the simulation for a given set of parameters $(N, M, I, B, \\alpha, \\beta, \\rho, s)$.\n-   A helper function `build_chain` takes a sequence of dihedral angles and generates the atomic coordinates $\\{p_i\\}$ according to the geometric construction rules.\n-   A second helper function `calculate_energy` takes the atomic coordinates and dihedral angles to compute the total energy $E(\\Phi)$. `numpy`'s vectorized operations are used to accelerate sums and potential calculations.\n-   The main ACO loop manages the state, including the pheromone matrix $T$ and the globally best-found energy. It uses a `numpy.random.Generator` instance, seeded for reproducibility, to perform the probabilistic sampling of dihedral bins.\nThe code is structured to first define all constants, then the helper functions, and finally the main simulation driver which is called for each test case as specified.",
            "answer": "```python\nimport numpy as np\n\n# Fixed physical and energetic constants\nBOND_LENGTH = 3.8  # b in Å\nBOND_ANGLE_DEG = 111.5\nBOND_ANGLE_RAD = np.deg2rad(BOND_ANGLE_DEG)  # theta in radians\nEPSILON = 0.1      # ε\nSIGMA = 4.0        # σ in Å\nKT = 0.1           # k_t\nT_H = 1.0          # T_h (Heuristic temperature)\nQ = 1.0            # Deposition strength\nT_D = 1.0          # Deposition temperature\nTAU_0 = 1.0        # Pheromone initialization\nTAU_MIN = 1e-6     # Pheromone floor\nTAU_MAX = 100.0    # Pheromone cap\n\ndef build_chain(dihedrals, N, b, theta):\n    \"\"\"Constructs the atomic coordinates for a given chain length and dihedrals.\"\"\"\n    if N == 0:\n        return np.array([])\n    \n    positions = np.zeros((N, 3))\n    if N > 1:\n        positions[1] = np.array([b, 0.0, 0.0])\n    if N > 2:\n        positions[2] = np.array([\n            b + b * np.cos(theta),\n            b * np.sin(theta),\n            0.0\n        ])\n\n    for i in range(3, N):\n        p_im1, p_im2, p_im3 = positions[i-1], positions[i-2], positions[i-3]\n        \n        # Define local frame vectors\n        u_vec = p_im1 - p_im2\n        u = u_vec / np.linalg.norm(u_vec)\n        \n        v_vec = p_im2 - p_im3\n        v = v_vec / np.linalg.norm(v_vec)\n        \n        cross_vu = np.cross(v, u)\n        n = cross_vu / np.linalg.norm(cross_vu)\n        \n        m = np.cross(u, n)\n        \n        phi_i = dihedrals[i - 3]\n        cos_phi = np.cos(phi_i)\n        sin_phi = np.sin(phi_i)\n\n        # Construct new atom position using the provided formula\n        new_bond_vector = -np.cos(theta) * u + np.sin(theta) * (cos_phi * m + sin_phi * n)\n        positions[i] = p_im1 + b * new_bond_vector\n        \n    return positions\n\ndef calculate_energy(positions, dihedrals, N, kt, eps, sigma):\n    \"\"\"Calculates the total energy of a conformation.\"\"\"\n    \n    # 1. Torsional energy\n    if dihedrals:\n        cos3_phi = np.cos(3 * np.array(dihedrals))\n        e_tors = kt * np.sum(1 + cos3_phi)\n    else:\n        e_tors = 0.0\n\n    # 2. Non-bonded Lennard-Jones energy\n    e_nb = 0.0\n    for i in range(N):\n        for j in range(i + 3, N):  # Condition j - i > 2\n            dist_sq = np.sum((positions[i] - positions[j])**2)\n            dist = np.sqrt(dist_sq)\n            \n            if dist > 0:\n                sigma_over_r = sigma / dist\n                sigma_over_r6 = sigma_over_r**6\n                sigma_over_r12 = sigma_over_r6**2\n                e_nb += 4 * eps * (sigma_over_r12 - sigma_over_r6)\n    \n    return e_tors + e_nb\n\ndef run_simulation(N, M, I, B, alpha, beta, rho, seed):\n    \"\"\"Runs the full ACO simulation for one test case.\"\"\"\n    \n    rng = np.random.default_rng(seed)\n    num_dihedrals = N - 3\n\n    if num_dihedrals <= 0:\n        # Fixed geometry, only possible LJ energy. \n        # For N<=3, no pair satisfies j-i>2, so energy is 0.\n        return 0.0\n    \n    # Discretize dihedral space\n    bin_width = 2 * np.pi / B\n    dihedral_bins = np.linspace(-np.pi + bin_width / 2, np.pi - bin_width / 2, B)\n\n    # Initialize pheromone matrix T\n    pheromone = np.full((num_dihedrals, B), TAU_0)\n    \n    # Pre-calculate heuristic matrix eta\n    torsional_heuristic_term = KT * (1 + np.cos(3 * dihedral_bins))\n    heuristic = np.exp(-torsional_heuristic_term / T_H)\n    \n    best_energy_global = float('inf')\n\n    for iteration in range(I):\n        iteration_samples = []\n        \n        # M ants construct solutions\n        for _ in range(M):\n            chosen_dihedrals = []\n            chosen_bin_indices = []\n            \n            for k in range(num_dihedrals):\n                probs = (pheromone[k] ** alpha) * (heuristic ** beta)\n                if np.sum(probs) > 0:\n                    probs /= np.sum(probs)\n                else: # Fallback to uniform if all probabilities are zero\n                    probs = np.ones(B) / B\n\n                chosen_bin_idx = rng.choice(B, p=probs)\n                chosen_bin_indices.append(chosen_bin_idx)\n                chosen_dihedrals.append(dihedral_bins[chosen_bin_idx])\n\n            # Evaluate the constructed conformation\n            positions = build_chain(chosen_dihedrals, N, BOND_LENGTH, BOND_ANGLE_RAD)\n            energy = calculate_energy(positions, chosen_dihedrals, N, KT, EPSILON, SIGMA)\n            \n            iteration_samples.append({'dihedrals': chosen_dihedrals, 'bins': chosen_bin_indices, 'energy': energy})\n\n        # Find best ant of the iteration\n        best_sample = min(iteration_samples, key=lambda x: x['energy'])\n        e_star = best_sample['energy']\n        \n        # Update global best energy\n        if e_star < best_energy_global:\n            best_energy_global = e_star\n\n        # Update pheromone trails\n        # 1. Evaporation\n        pheromone *= (1 - rho)\n\n        # 2. Deposition\n        deposition_amount = Q * np.exp(-e_star / T_D)\n        best_bins = best_sample['bins']\n        for k in range(num_dihedrals):\n            pheromone[k, best_bins[k]] += deposition_amount\n\n        # 3. Clamping\n        np.clip(pheromone, TAU_MIN, TAU_MAX, out=pheromone)\n\n    return best_energy_global\n\ndef solve():\n    \"\"\"Main solver function to run test cases.\"\"\"\n    \n    test_cases = [\n        # Case A: (N, M, I, B, alpha, beta, rho, seed)\n        (8, 25, 40, 36, 1.0, 2.0, 0.1, 1234),\n        # Case B\n        (4, 16, 25, 24, 1.0, 1.0, 0.3, 202),\n        # Case C\n        (10, 20, 30, 24, 1.5, 1.0, 0.2, 999),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, I, B, alpha, beta, rho, seed = case\n        best_energy = run_simulation(N, M, I, B, alpha, beta, rho, seed)\n        results.append(f\"{best_energy:.3f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}