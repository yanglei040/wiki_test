{
    "hands_on_practices": [
        {
            "introduction": "在我们开始计算RMSD之前，首先建立一个关于这个度量本身的深刻直觉是至关重要的。RMSD是一个总结整体结构差异的强大数值，但作为一个平均值，它有时可能会掩盖显著的局部偏差。这个思想实验将挑战你探索在给定的整体RMSD值下，单个原子可能的最大位移是多少，从而加深你对RMSD局限性和解释的理解。",
            "id": "2431541",
            "problem": "同一种蛋白质的两种构象，每种构象包含 $100$ 个残基，仅使用 alpha 碳（$\\mathrm{C}\\alpha$）原子通过刚体叠合进行最优比对。测得 $N=100$ 个匹配的 $\\mathrm{C}\\alpha$ 原子之间的均方根偏差（RMSD）为 $3.0$ Å。根据定义，$N$ 个原子的均方根偏差（RMSD）为\n$$\n\\mathrm{RMSD} \\equiv \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\|\\Delta \\mathbf{r}_{i}\\|^{2}},\n$$\n其中 $\\Delta \\mathbf{r}_{i}$ 是最优叠合后原子 $i$ 在两种构象之间的位移矢量，$\\|\\cdot\\|$ 表示欧几里得范数。在不假设除上述定义之外任何附加约束的情况下，确定与给定 RMSD 一致的单个原子 $j$ 的 $\\|\\Delta \\mathbf{r}_{j}\\|$ 的理论最大可能值。给出精确值，并以埃（Å）为单位表示您的答案。最终答案中不要包含单位。",
            "solution": "首先必须对问题陈述进行严格验证。\n\n步骤 1：提取已知条件。\n已知条件如下：\n- 残基数量为 $100$。\n- 用于叠合和 RMSD 计算的原子是 alpha 碳（$\\mathrm{C}\\alpha$）原子。\n- 用于 RMSD 计算的匹配原子数为 $N=100$。\n- 测得的均方根偏差为 $\\mathrm{RMSD} = 3.0$ Å。\n- RMSD 的定义为 $\\mathrm{RMSD} \\equiv \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\|\\Delta \\mathbf{r}_{i}\\|^{2}}$，其中 $\\Delta \\mathbf{r}_{i}$ 是原子 $i$ 的位移矢量。\n- 任务是求单个任意原子 $j$ 的 $\\|\\Delta \\mathbf{r}_{j}\\|$ 的理论最大可能值。\n- 问题陈述我们不得假设超出所提供定义之外的任何附加约束。\n\n步骤 2：使用提取的已知条件进行验证。\n根据验证标准对问题进行评估。\n- **科学性：** 该问题基于均方根偏差（RMSD）的标准定义，这是结构生物信息学中比较大分子结构的一个基本概念。所提供的值（$N=100$ 个原子，$\\mathrm{RMSD}=3.0$ Å）在物理上是现实的。\n- **适定性：** 该问题是一个适定的数学极值问题。它要求在给定整个集合的均方根约束下，求集合中一个分量的最大值。存在唯一解。\n- **客观性：** 问题以精确、客观的语言陈述，没有歧义。\n\n该问题不具有任何导致其无效的缺陷。它在科学上是合理的，可形式化的，完整的，并且是适定的。“最优叠合”的条件确立了测量 RMSD 的背景，但问题的核心是一个关于 RMSD 度量本身性质的数学问题，正如约束“在不假设除上述定义之外任何附加约束的情况下”所明确指出的那样。\n\n步骤 3：结论与行动。\n问题有效。将推导解答。\n\n解答从 RMSD 的定义开始。我们已知：\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} d_{i}^{2}}\n$$\n其中为简化符号，我们将原子 $i$ 位移的标量大小定义为 $d_{i} \\equiv \\|\\Delta \\mathbf{r}_{i}\\|$ 。我们已知 $N=100$ 且 $\\mathrm{RMSD}=3.0$。\n\n将已知值代入定义中：\n$$\n3.0 = \\sqrt{\\frac{1}{100}\\sum_{i=1}^{100} d_{i}^{2}}\n$$\n为分析该和，我们将方程两边平方：\n$$\n(3.0)^{2} = \\frac{1}{100}\\sum_{i=1}^{100} d_{i}^{2}\n$$\n$$\n9.0 = \\frac{1}{100}\\sum_{i=1}^{100} d_{i}^{2}\n$$\n这为位移平方和提供了一个固定约束：\n$$\n\\sum_{i=1}^{100} d_{i}^{2} = 9.0 \\times 100 = 900\n$$\n该量的单位是 Å$^{2}$。\n\n我们的目标是确定单个位移大小的理论最大可能值，我们将其表示为任意原子 $j$ 的 $d_{j}$。我们可以从和式中分离出 $d_{j}^{2}$ 项：\n$$\n\\sum_{i=1}^{100} d_{i}^{2} = d_{j}^{2} + \\sum_{i \\neq j} d_{i}^{2}\n$$\n将其代回我们的约束方程中：\n$$\nd_{j}^{2} + \\sum_{i \\neq j} d_{i}^{2} = 900\n$$\n为了最大化 $d_{j}$ 的值，进而最大化 $d_{j}^{2}$ 的值（因为 $d_{j}$ 是一个非负的大小），我们必须最小化从常数 $900$ 中减去的项的值。也就是说，我们必须最小化所有其他原子位移的平方和 $\\sum_{i \\neq j} d_{i}^{2}$。\n\n根据定义，矢量的大小 $d_{i} = \\|\\Delta \\mathbf{r}_{i}\\|$ 必须是非负的，即 $d_{i} \\ge 0$。因此，大小的平方也必须是非负的，即 $d_{i}^{2} \\ge 0$。每一项 $d_{i}^{2}$ 的最小可能值为 $0$。这对应于原子 $i$ 的位移为零的物理情况。\n\n当和式中的每一项都取其最小值时，和 $\\sum_{i \\neq j} d_{i}^{2}$ 达到其最小值。因此，我们对所有 $i \\neq j$ 设 $d_{i}^{2} = 0$。\n$$\n\\min\\left(\\sum_{i \\neq j} d_{i}^{2}\\right) = \\sum_{i \\neq j} 0 = 0\n$$\n将此最小值代回关于 $d_{j}^{2}$ 的方程中：\n$$\n(d_{j}^{2})_{\\max} + 0 = 900\n$$\n$$\n(d_{j}^{2})_{\\max} = 900\n$$\n取平方根求最大可能位移大小 $(d_{j})_{\\max}$：\n$$\n(d_{j})_{\\max} = \\sqrt{900} = 30\n$$\n这个结果对应于这样一种情景：其中 $N-1 = 99$ 个原子完全重合（对于 $i \\neq j$ 有 $d_{i}=0$），而偏差平方和完全由单个原子 $j$ 贡献。在给定总 RMSD 的情况下，这是任何单个原子偏差的理论上限。该值为 $30$ Å。",
            "answer": "$$\n\\boxed{30}\n$$"
        },
        {
            "introduction": "蛋白质结构的不同区域具有不同的灵活性；例如，柔性环区可能比刚性的结构核心表现出更大的构象变化。一个包含所有原子的RMSD值可能会被这些高度灵活的区域不成比例地影响。这项高级练习引导你实现一个迭代算法，用于识别两结构间可在给定RMSD阈值下叠合的最大原子子集，通过这种方式，我们可以识别出保守的结构核心，从而实现更精细和有意义的结构比较。",
            "id": "2431533",
            "problem": "实现一个程序。对于每一对给定的一一对应的三维原子点集，该程序需要识别出一个大小尽可能最大的匹配原子索引子集，使得存在一种刚体叠合，其在该子集上的均方根偏差 (RMSD) 小于或等于给定的阈值。刚体叠合定义为先通过一个行列式为+1的标准正交矩阵进行旋转（无镜像或缩放），然后进行一次平移。对于大小相同的两个子集 $\\{ \\mathbf{x}_i \\}_{i \\in S}$ 和 $\\{ \\mathbf{y}_i \\}_{i \\in S}$，在旋转 $\\mathbf{R}$ 和平移 $\\mathbf{t}$ 下的均方根偏差 (RMSD) 为\n$$\n\\mathrm{RMSD}(\\mathbf{R},\\mathbf{t};S) \\;=\\; \\sqrt{\\frac{1}{|S|} \\sum_{i \\in S} \\left\\| \\mathbf{R}\\,\\mathbf{x}_i + \\mathbf{t} - \\mathbf{y}_i \\right\\|_2^2 } \\,.\n$$\n您的任务是为每个测试用例确定一个索引子集 $S^\\star$，在满足约束条件 $\\min_{\\mathbf{R},\\mathbf{t}} \\mathrm{RMSD}(\\mathbf{R},\\mathbf{t};S) \\le \\tau$ 的前提下，使 $|S|$ 最大化。其中 $\\tau$ 是给定的阈值，$\\mathbf{R}$ 是一个行列式 $\\det(\\mathbf{R}) = +1$ 的旋转矩阵，$\\mathbf{t}$ 是 $\\mathbb{R}^3$ 中的平移向量。在所有基数最大的子集中，选择能达到最小可能 RMSD 的那一个；如果仍然存在平局，则选择其有序索引元组字典序最小的子集。角度以弧度为单位。坐标以埃（ångström）为单位，RMSD 也必须以埃为单位报告，并四舍五入到恰好6位小数。阈值约束使用“小于或等于”条件。\n\n所有输入数据均已在本问题中固定，无需外部输入。设基础结构 $A$ 由 $N$ 个原子组成，索引为 $0,1,\\dots,N-1$，笛卡尔坐标为 $\\mathbf{x}_i \\in \\mathbb{R}^3$。对应的结构 $B$ 对相同的索引具有坐标 $\\mathbf{y}_i \\in \\mathbb{R}^3$。\n\n用于所有测试用例的基础结构 A 的定义：\n- $N = 8$ 个原子，坐标单位为埃：\n  - 索引 $0$: $(0.0,\\,0.0,\\,0.0)$\n  - 索引 $1$: $(1.0,\\,0.0,\\,0.0)$\n  - 索引 $2$: $(0.0,\\,1.0,\\,0.0)$\n  - 索引 $3$: $(0.0,\\,0.0,\\,1.0)$\n  - 索引 $4$: $(1.0,\\,1.0,\\,0.0)$\n  - 索引 $5$: $(1.0,\\,0.0,\\,1.0)$\n  - 索引 $6$: $(0.0,\\,1.0,\\,1.0)$\n  - 索引 $7$: $(1.0,\\,1.0,\\,1.0)$\n\n定义以下旋转矩阵（角度单位为弧度）：\n- $$ \\mathbf{R}_z(\\theta_z) = \\begin{bmatrix}\n\\cos\\theta_z & -\\sin\\theta_z & 0\\\\\n\\sin\\theta_z & \\cos\\theta_z & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}, $$\n  $$ \\mathbf{R}_x(\\theta_x) = \\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & \\cos\\theta_x & -\\sin\\theta_x\\\\\n0 & \\sin\\theta_x & \\cos\\theta_x\n\\end{bmatrix}, $$\n和复合旋转 $\\mathbf{R} = \\mathbf{R}_x(\\theta_x)\\,\\mathbf{R}_z(\\theta_z)$。\n定义平移 $\\mathbf{t} = (0.5,\\,-0.3,\\,0.8)$。\n\n按如下方式构建测试套件：\n- 测试用例 1 (理想情况)：设 $B^{(1)}$ 是通过对 $A$ 应用刚性变换 $\\mathbf{R}$ 和 $\\mathbf{t}$ 得到的，即对每个索引 $i$，有 $\\mathbf{y}^{(1)}_i = \\mathbf{R}\\,\\mathbf{x}_i + \\mathbf{t}$。阈值 $\\tau_1 = 10^{-8}$ 埃。\n- 测试用例 2 (存在离群点)：从 $B^{(1)}$ 开始，通过仅向索引为 1 和 6 的原子添加位移向量 $\\mathbf{d} = (3.0,\\,-2.0,\\,1.5)$ 埃来定义 $B^{(2)}$：对于 $i \\in \\{1,6\\}$，设 $\\mathbf{y}^{(2)}_i = \\mathbf{y}^{(1)}_i + \\mathbf{d}$，对于所有其他索引 $i$，设 $\\mathbf{y}^{(2)}_i = \\mathbf{y}^{(1)}_i$。阈值 $\\tau_2 = 0.05$ 埃。\n- 测试用例 3 (退化的小集合)：定义一个包含两个原子（索引为0和1）的结构 $A^{(3)}$，其坐标分别为 $(0.0,\\,0.0,\\,0.0)$ 和 $(2.0,\\,0.0,\\,0.0)$ 埃。通过应用与上述相同的 $\\mathbf{R}$ 和 $\\mathbf{t}$ 来定义 $B^{(3)}$：$\\mathbf{y}^{(3)}_i = \\mathbf{R}\\,\\mathbf{x}^{(3)}_i + \\mathbf{t}$ 对于 $i \\in \\{0,1\\}$。阈值 $\\tau_3 = 10^{-8}$ 埃。\n\n对于每个测试用例，您的程序必须：\n- 确定大小最大的子集 $S^\\star$，使得在该子集 $S^\\star$ 上存在一个 RMSD $\\le \\tau$ 的刚体叠合。\n- 在所有大小最大的子集中，选择一个具有最小 RMSD 的；如果仍然存在平局，则选择字典序最小的有序索引元组。\n\n最终输出格式：\n- 对于每个测试用例 $j \\in \\{1,2,3\\}$，输出一个数对 $[k_j, r_j]$，其中 $k_j = |S^\\star|$ 是一个整数，$r_j$ 是在 $S^\\star$ 上可实现的最小 RMSD，四舍五入到恰好6位小数。\n- 您的程序应生成单行输出，其中包含按测试用例1、2、3顺序排列的结果，格式为方括号括起来的逗号分隔列表。例如：$[[k_1,r_1],[k_2,r_2],[k_3,r_3]]$。",
            "solution": "所述问题是有效的。这是一个在计算结构生物学领域中适定的、有科学依据的问题，没有矛盾或含糊之处。所有必要的数据和约束条件都已提供，足以得出一个唯一的、可验证的解。因此，我们将着手推导并实现一个解决方案。\n\n该问题要求我们找到一个大小尽可能最大的原子索引子集 $S^\\star$，使得存在一种刚体叠合（旋转 $\\mathbf{R}$ 和平移 $\\mathbf{t}$），能将两个对应的点集 $\\{\\mathbf{x}_i\\}_{i \\in S^\\star}$ 和 $\\{\\mathbf{y}_i\\}_{i \\in S^\\star}$ 对齐，且其均方根偏差 (RMSD) 不超过给定的阈值 $\\tau$。形式上，我们必须找到 $S^\\star$ 来解决以下优化问题：\n$$ S^\\star = \\arg\\max_{S \\subseteq \\{0, ..., N-1\\}} |S| \\quad \\text{subject to} \\quad \\min_{\\mathbf{R},\\mathbf{t}} \\mathrm{RMSD}(\\mathbf{R},\\mathbf{t};S) \\le \\tau $$\n其中 $\\det(\\mathbf{R})=+1$。问题还指定了打破平局的规则：在大小最大的子集中，选择 RMSD 最小的那个，然后选择字典序最小的排序索引元组。\n\n这个问题是一个寻找最优子集的组合搜索问题。在一般情况下，这是一个 NP-难问题，等价于在一个图中寻找最大团，其中顶点代表原子，而边连接在给定容差内可以相互叠合的原子对。然而，对于测试用例中给出的少量原子（$N=8$ 和 $N=2$），对所有可能的子集进行穷举搜索在计算上是可行的。\n\n因此，我们的策略如下：\n1.  从 $N$ 到 1，按降序遍历所有可能的子集大小 $k$。\n2.  对于给定的大小 $k$，生成该大小的所有索引子集。\n3.  对于每个子集，计算其对应点集之间的最小可能 RMSD。\n4.  如果计算出的 RMSD 小于或等于阈值 $\\tau$，则该子集是一个有效的候选者。\n5.  由于我们从最大的 $k$ 向下迭代，我们找到任何有效候选者的第一个大小 $k$ 就是最大可能基数 $|S^\\star|$。然后我们收集这个大小 $k$ 的所有有效候选者。\n6.  从这个最大大小的候选集合中，我们选择满足打破平局标准的那个：最小的 RMSD，然后是字典序最小的索引元组。\n\n此策略的核心部分是计算给定点集对的最小 RMSD。这是一个经典问题，可以通过 Kabsch 算法解决，该算法能找到最优的刚体变换。\n\n设给定大小为 $k$ 的子集 $S$ 的两组坐标为 $\\{\\mathbf{x}_i\\}_{i \\in S}$ 和 $\\{\\mathbf{y}_i\\}_{i \\in S}$。Kabsch 算法过程如下：\n\n首先，RMSD 的最小化可以解耦。最优平移 $\\mathbf{t}$ 取决于最优旋转 $\\mathbf{R}$。通过首先将两个点集都中心化到原点，可以最小化 RMSD 的平方。我们计算质心：\n$$ \\mathbf{c}_x = \\frac{1}{k} \\sum_{i \\in S} \\mathbf{x}_i \\quad \\text{和} \\quad \\mathbf{c}_y = \\frac{1}{k} \\sum_{i \\in S} \\mathbf{y}_i $$\n中心化后的坐标向量为 $\\mathbf{x}'_i = \\mathbf{x}_i - \\mathbf{c}_x$ 和 $\\mathbf{y}'_i = \\mathbf{y}_i - \\mathbf{c}_y$。问题简化为找到一个旋转 $\\mathbf{R}$，以最小化平方误差之和 $\\sum_{i \\in S} \\|\\mathbf{R}\\mathbf{x}'_i - \\mathbf{y}'_i\\|^2$。\n\n其次，我们构建 $3 \\times 3$ 的协方差矩阵 $H$。在矩阵表示法中，设 $X'$ 和 $Y'$ 是 $k \\times 3$ 的矩阵，其行是中心化的坐标向量 $\\{\\mathbf{x}'_i\\}$ 和 $\\{\\mathbf{y}'_i\\}$。协方差矩阵由下式给出：\n$$ H = (X')^T Y' $$\n\n第三，我们对协方差矩阵 $H$ 进行奇异值分解 (SVD)：\n$$ H = U \\Sigma V^T $$\n其中 $U$ 和 $V$ 是 $3 \\times 3$ 的正交矩阵，$\\Sigma$ 是非负奇异值的对角矩阵。\n\n第四，从SVD的分解结果中确定最优旋转矩阵。能够最大化重叠（从而最小化RMSD）的旋转是 $\\mathbf{R} = VU^T$。需要进行一个关键检查以确保这是一个真旋转（即没有镜像），这由条件 $\\det(\\mathbf{R})=+1$ 指定。如果 $\\det(VU^T) = -1$，则计算出的矩阵表示一个旋转反射。为了获得最接近的真旋转，我们必须对此进行校正。标准的校正方法是在重新计算 $\\mathbf{R}$ 之前，反转 $V$ 中与最小奇异值对应的列的符号。这能确保 $\\det(\\mathbf{R}) = +1$。设这个校正后的旋转为 $\\mathbf{R}^\\star$。\n\n最后，在确定了最优旋转 $\\mathbf{R}^\\star$ 后，最优平移由 $\\mathbf{t}^\\star = \\mathbf{c}_y - \\mathbf{R}^\\star\\mathbf{c}_x$ 给出。然后可以使用其定义直接计算最小 RMSD：\n$$ \\mathrm{RMSD}_{\\min} = \\sqrt{\\frac{1}{k} \\sum_{i \\in S} \\|\\mathbf{R}^\\star\\mathbf{x}_i + \\mathbf{t}^\\star - \\mathbf{y}_i\\|^2} $$\n\n此过程将被实现并应用于所有子集，如总体策略中所述，以找到每个测试用例的解。需要特别注意点数较少（$k<3$）的情况。对于 $k=1$ 或 $k=2$，最小 RMSD 始终为 0.0，因为一个或两个点总是可以完美叠合（假设点间距离保持不变，这在问题设置中是成立的）。通用的 Kabsch 算法实现对这些情况具有鲁棒性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the test cases and prints the final result.\n    \"\"\"\n\n    def calculate_rmsd(P, Q):\n        \"\"\"\n        Calculates the minimum RMSD for two sets of points P and Q using the Kabsch algorithm.\n        P and Q are numpy arrays of shape (k, 3), where k is the number of points.\n        \"\"\"\n        k = P.shape[0]\n        if k == 0:\n            return 0.0\n\n        # Center the point sets\n        c_P = np.mean(P, axis=0)\n        c_Q = np.mean(Q, axis=0)\n        P_c = P - c_P\n        Q_c = Q - c_Q\n\n        # For subsets of size 1, RMSD is trivially 0.\n        # For subsets of size 2, RMSD is also 0 as they can always be perfectly aligned.\n        # The Kabsch algorithm below should handle k=1,2,3... robustly, but this is a conceptual note.\n        # Let's test the k==1 edge case for robustness. P_c will be all zeros. H will be zeros.\n        # SVD of zeros is zeros. R will be identity. RMSD is 0. So it's fine.\n        \n        # Compute the covariance matrix\n        H = P_c.T @ Q_c\n\n        # Perform Singular Value Decomposition\n        try:\n            U, _, Vt = np.linalg.svd(H)\n        except np.linalg.LinAlgError:\n            # This can happen in degenerate cases, e.g., all points are identical.\n            # RMSD is essentially the std dev of the difference between point clouds.\n            return np.sqrt(np.mean(np.sum((P - Q)**2, axis=1)))\n\n        V = Vt.T\n\n        # Calculate the optimal rotation matrix\n        R = V @ U.T\n\n        # Check for and correct reflection (improper rotation)\n        if np.linalg.det(R) < 0:\n            V[:, -1] *= -1\n            R = V @ U.T\n\n        # Apply the rotation to the centered P point cloud\n        P_rot = (R @ P_c.T).T\n\n        # Calculate the RMSD\n        diff = P_rot - Q_c\n        rmsd = np.sqrt(np.sum(diff ** 2) / k)\n\n        return rmsd\n\n    def solve_case(A, B, tau):\n        \"\"\"\n        Finds the largest subset of atoms with RMSD <= tau.\n        \"\"\"\n        N = A.shape[0]\n\n        # Iterate from the largest possible subset size down to 1\n        for k in range(N, 0, -1):\n            candidate_subsets = []\n            \n            # Generate all combinations of indices of size k\n            for indices in combinations(range(N), k):\n                P = A[list(indices)]\n                Q = B[list(indices)]\n                \n                rmsd = calculate_rmsd(P, Q)\n                \n                if rmsd <= tau:\n                    candidate_subsets.append({'rmsd': rmsd, 'indices': indices})\n            \n            # If we found any valid subsets of size k, this is the maximal size.\n            if candidate_subsets:\n                # Sort candidates: first by RMSD (ascending), then by lexicographical order of indices\n                candidate_subsets.sort(key=lambda x: (x['rmsd'], x['indices']))\n                \n                best_candidate = candidate_subsets[0]\n                best_k = k\n                best_rmsd = best_candidate['rmsd']\n                \n                # Return the result for this test case\n                return [best_k, best_rmsd]\n\n        # This part should be unreachable as a subset of size 1 always has an RMSD of 0.\n        return [0, 0.0]\n\n    # --- SETUP ---\n    # Define rigid transformation parameters\n    theta_z = math.pi / 6.0\n    theta_x = math.pi / 9.0\n    \n    cos_tz, sin_tz = math.cos(theta_z), math.sin(theta_z)\n    cos_tx, sin_tx = math.cos(theta_x), math.sin(theta_x)\n\n    Rz = np.array([\n        [cos_tz, -sin_tz, 0],\n        [sin_tz,  cos_tz, 0],\n        [0,       0,      1]\n    ])\n    Rx = np.array([\n        [1, 0,       0],\n        [0, cos_tx, -sin_tx],\n        [0, sin_tx,  cos_tx]\n    ])\n    \n    R = Rx @ Rz\n    t = np.array([0.5, -0.3, 0.8])\n\n    # Base structure A for test cases 1 and 2 (vertices of a unit cube)\n    A1_A2 = np.array([\n        [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0],\n        [1.0, 1.0, 0.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0]\n    ])\n\n    results = []\n\n    # --- Test Case 1 ---\n    # Structure B is a perfect rigid transformation of A.\n    B1 = (R @ A1_A2.T).T + t\n    tau1 = 1e-8\n    k1, r1 = solve_case(A1_A2, B1, tau1)\n    results.append([k1, round(r1, 6)])\n\n    # --- Test Case 2 ---\n    # Structure B has two outliers.\n    d = np.array([3.0, -2.0, 1.5])\n    B2 = np.copy(B1)\n    B2[1] += d\n    B2[6] += d\n    tau2 = 0.05\n    k2, r2 = solve_case(A1_A2, B2, tau2)\n    results.append([k2, round(r2, 6)])\n\n    # --- Test Case 3 ---\n    # A small, two-atom structure.\n    A3 = np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]])\n    B3 = (R @ A3.T).T + t\n    tau3 = 1e-8\n    k3, r3 = solve_case(A3, B3, tau3)\n    results.append([k3, round(r3, 6)])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}