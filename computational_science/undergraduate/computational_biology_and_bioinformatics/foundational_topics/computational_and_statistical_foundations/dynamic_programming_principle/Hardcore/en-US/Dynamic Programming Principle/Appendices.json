{
    "hands_on_practices": [
        {
            "introduction": "Dynamic programming's power lies in its ability to guarantee a globally optimal solution, a feature that simpler, more intuitive methods often lack. This exercise provides a direct comparison between the rigorous Needleman-Wunsch algorithm and a \"greedy\" strategy that makes the best choice at each step. By working through this problem , you will see firsthand why looking ahead is essential for finding the true optimal alignment and avoiding locally attractive but ultimately suboptimal paths.",
            "id": "2387141",
            "problem": "An essential application of the dynamic programming principle in computational biology and bioinformatics is global sequence alignment. Consider the deoxyribonucleic acid alphabet $\\Sigma=\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\}$ and define a substitution scoring function $s:\\Sigma\\times\\Sigma\\to\\mathbb{R}$ by $s(x,y)=+2$ if $x=y$ and $s(x,y)=-1$ if $x\\neq y$. Use a linear gap penalty $g=-2$ for aligning any letter with a gap.\n\nLet the two sequences be $X=\\texttt{ACG}$ and $Y=\\texttt{AG}$. You will compare two strategies:\n\n1. A globally optimal alignment computed using the dynamic programming principle for global alignment (the Needlemanâ€“Wunsch algorithm), which relies on the optimal substructure property of prefixes.\n2. A greedy alignment strategy defined as follows: at each step, given the next unaligned letters $x_i$ and $y_j$, choose the action with the highest immediate score among the three possibilities: align $x_i$ with $y_j$ with score $s(x_i,y_j)$, align $x_i$ with a gap with score $g$, or align $y_j$ with a gap with score $g$. In case of ties, prefer aligning $x_i$ with $y_j$, and if still tied, prefer inserting a gap opposite $x_i$ rather than opposite $y_j$. Continue until both sequences are fully aligned.\n\nUsing only the dynamic programming principle and the definitions above (without invoking any unprovided formulas), compute:\n- the optimal global alignment score $F$ for aligning $X$ and $Y$ under $s$ and $g$,\n- the greedy alignment score $G$ produced by the greedy rule above,\n- and finally the difference $\\Delta=F-G$.\n\nReport only the value of $\\Delta$ as your final answer. No rounding is needed, and no units are required.",
            "solution": "The problem statement is subject to validation.\n\nStep 1: Extracted Givens\n- Alphabet: $\\Sigma=\\{\\texttt{A},\\texttt{C},\\texttt{G},\\texttt{T}\\}$\n- Substitution scoring function $s(x,y)$: $s(x,y)=+2$ if $x=y$ and $s(x,y)=-1$ if $x \\neq y$.\n- Linear gap penalty: $g=-2$.\n- Sequences: $X=\\texttt{ACG}$, $Y=\\texttt{AG}$.\n- Strategy 1: Globally optimal alignment using the dynamic programming principle. The score is denoted $F$.\n- Strategy 2: A specified greedy alignment strategy. The score is denoted $G$.\n- Greedy tie-breaking rules: In case of a tie in scores, the preferred order of operations is: first, align $x_i$ with $y_j$; second, align $x_i$ with a gap; third, align $y_j$ with a gap.\n- Objective: Compute the difference $\\Delta=F-G$.\n\nStep 2: Validation\nThe problem is scientifically grounded, as it concerns the Needleman-Wunsch algorithm, a fundamental concept in computational biology. It is well-posed, providing all necessary sequences, a complete scoring function, and unambiguous rules for both the optimal and greedy procedures. The language is objective and precise. The problem is self-contained and does not violate any physical or mathematical principles. All terms are clearly defined.\n\nStep 3: Verdict\nThe problem is valid. A complete solution will be developed.\n\nThe task requires the computation of two alignment scores for the sequences $X=\\texttt{ACG}$ and $Y=\\texttt{AG}$ based on the provided scoring scheme: $s(x,y)=+2$ for a match, $s(x,y)=-1$ for a mismatch, and a linear gap penalty $g=-2$.\n\nFirst, we will compute the optimal global alignment score, $F$, using the dynamic programming principle. Let $m$ be the length of sequence $X$ and $n$ be the length of sequence $Y$. Here, $m=3$ and $n=2$. We define a matrix $F(i,j)$ representing the score of the optimal alignment of the prefixes $X[1..i]$ and $Y[1..j]$. The value of $F(i,j)$ is derived from the optimal substructure property, which dictates that the optimal alignment of prefixes must be constructed from optimal alignments of smaller prefixes. The value of each cell is determined by the maximum of three possible preceding states:\n1. Aligning $X[i]$ with $Y[j]$: score is $F(i-1, j-1) + s(X[i], Y[j])$.\n2. Aligning $X[i]$ with a gap: score is $F(i-1, j) + g$.\n3. Aligning $Y[j]$ with a gap: score is $F(i, j-1) + g$.\n\nThus, the recurrence relation is:\n$$F(i,j) = \\max\\left\\{ F(i-1, j-1) + s(X[i], Y[j]),\\; F(i-1, j) + g,\\; F(i, j-1) + g \\right\\}$$\nThe base conditions are for alignments of a prefix with an empty string:\n$F(0,0) = 0$\n$F(i,0) = i \\times g$ for $i > 0$\n$F(0,j) = j \\times g$ for $j > 0$\n\nWe construct a $(m+1) \\times (n+1)$ or $4 \\times 3$ matrix.\nInitialization:\n$F(0,0) = 0$\n$F(1,0) = 1 \\times (-2) = -2$\n$F(2,0) = 2 \\times (-2) = -4$\n$F(3,0) = 3 \\times (-2) = -6$\n$F(0,1) = 1 \\times (-2) = -2$\n$F(0,2) = 2 \\times (-2) = -4$\n\nFilling the matrix for $i \\in \\{1,2,3\\}$ and $j \\in \\{1,2\\}$:\n$F(1,1)$: Align $X_1=\\texttt{A}$ and $Y_1=\\texttt{A}$. $s(\\texttt{A},\\texttt{A})=+2$.\n$F(1,1) = \\max\\{F(0,0)+2, F(0,1)-2, F(1,0)-2\\} = \\max\\{0+2, -2-2, -2-2\\} = 2$.\n\n$F(2,1)$: Align $X_2=\\texttt{C}$ and $Y_1=\\texttt{A}$. $s(\\texttt{C},\\texttt{A})=-1$.\n$F(2,1) = \\max\\{F(1,0)-1, F(1,1)-2, F(2,0)-2\\} = \\max\\{-2-1, 2-2, -4-2\\} = \\max\\{-3, 0, -6\\} = 0$.\n\n$F(3,1)$: Align $X_3=\\texttt{G}$ and $Y_1=\\texttt{A}$. $s(\\texttt{G},\\texttt{A})=-1$.\n$F(3,1) = \\max\\{F(2,0)-1, F(2,1)-2, F(3,0)-2\\} = \\max\\{-4-1, 0-2, -6-2\\} = \\max\\{-5, -2, -8\\} = -2$.\n\n$F(1,2)$: Align $X_1=\\texttt{A}$ and $Y_2=\\texttt{G}$. $s(\\texttt{A},\\texttt{G})=-1$.\n$F(1,2) = \\max\\{F(0,1)-1, F(0,2)-2, F(1,1)-2\\} = \\max\\{-2-1, -4-2, 2-2\\} = \\max\\{-3, -6, 0\\} = 0$.\n\n$F(2,2)$: Align $X_2=\\texttt{C}$ and $Y_2=\\texttt{G}$. $s(\\texttt{C},\\texttt{G})=-1$.\n$F(2,2) = \\max\\{F(1,1)-1, F(1,2)-2, F(2,1)-2\\} = \\max\\{2-1, 0-2, 0-2\\} = \\max\\{1, -2, -2\\} = 1$.\n\n$F(3,2)$: Align $X_3=\\texttt{G}$ and $Y_2=\\texttt{G}$. $s(\\texttt{G},\\texttt{G})=+2$.\n$F(3,2) = \\max\\{F(2,1)+2, F(2,2)-2, F(3,1)-2\\} = \\max\\{0+2, 1-2, -2-2\\} = \\max\\{2, -1, -4\\} = 2$.\n\nThe complete DP matrix is:\n$$\n\\begin{array}{c|ccc}\n & \\text{ } & \\texttt{A} & \\texttt{G} \\\\\n\\hline\n\\text{ } & 0 & -2 & -4 \\\\\n\\texttt{A} & -2 & 2 & 0 \\\\\n\\texttt{C} & -4 & 0 & 1 \\\\\n\\texttt{G} & -6 & -2 & 2\n\\end{array}\n$$\nThe optimal global alignment score is the value in the bottom-right cell, $F = F(3,2) = 2$.\n\nNext, we compute the greedy alignment score, $G$. The greedy strategy considers the next unaligned letters and chooses the action with the maximum immediate score. Let $i$ and $j$ be pointers to the current characters in $X$ and $Y$, starting at $i=1, j=1$. The total score $G$ is initialized to $0$.\n\nStep 1: $i=1, j=1$. Current letters are $X_1=\\texttt{A}, Y_1=\\texttt{A}$.\n- Action 1 (Align $X_1$ with $Y_1$): Score $s(\\texttt{A},\\texttt{A}) = +2$.\n- Action 2 (Align $X_1$ with gap): Score $g = -2$.\n- Action 3 (Align $Y_1$ with gap): Score $g = -2$.\nThe maximum score is $2$. We align $\\texttt{A}$ with $\\texttt{A}$.\n$G$ becomes $0+2=2$. We advance both pointers to $i=2, j=2$. The alignment is $\\texttt{A}$ -- $\\texttt{A}$.\n\nStep 2: $i=2, j=2$. Current letters are $X_2=\\texttt{C}, Y_2=\\texttt{G}$.\n- Action 1 (Align $X_2$ with $Y_2$): Score $s(\\texttt{C},\\texttt{G}) = -1$.\n- Action 2 (Align $X_2$ with gap): Score $g = -2$.\n- Action 3 (Align $Y_2$ with gap): Score $g = -2$.\nThe maximum score is $-1$. We align $\\texttt{C}$ with $\\texttt{G}$.\n$G$ becomes $2+(-1)=1$. We advance both pointers to $i=3, j=3$. The alignment is $\\texttt{AC}$ -- $\\texttt{AG}$.\n\nStep 3: $i=3, j=3$. Sequence $Y$ is exhausted as $j > n=2$.\nThe only remaining action is to align the rest of sequence $X$ with gaps. The remaining character is $X_3=\\texttt{G}$.\nWe align $\\texttt{G}$ with a gap, which has a score of $g=-2$.\n$G$ becomes $1+(-2)=-1$. We advance $i$ to $4$. The alignment is $\\texttt{ACG}$ -- $\\texttt{AG-}$.\n\nBoth sequences are now fully aligned. The final greedy alignment score is $G=-1$.\n\nFinally, we compute the difference $\\Delta=F-G$.\n$F = 2$\n$G = -1$\n$\\Delta = F - G = 2 - (-1) = 3$.\n\nThe difference between the optimal score obtained via dynamic programming and the score from the specified greedy strategy is $3$.",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "The dynamic programming principle is a versatile tool that can solve problems beyond direct sequence alignment. A key skill in bioinformatics is recognizing how to transform a new problem into a structure that dynamic programming can solve. This practice  challenges you to find the length of the longest palindromic subsequence within a DNA strand, revealing an elegant connection to the classic longest common subsequence (LCS) problem.",
            "id": "2387070",
            "problem": "A deoxyribonucleic acid (DNA) segment is modeled as a finite string $S$ over the alphabet $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$. A subsequence of $S$ is obtained by deleting zero or more characters of $S$ without changing the order of the remaining characters. A palindrome is a string that is identical to its reverse. Consider the DNA string $S = \\text{ACGTCAGCAT}$ of length $10$.\n\nUsing only the definitions above and the dynamic programming principle, determine the length of the longest palindromic subsequence of $S$ (not necessarily contiguous). Report the length as a single integer with no units. No rounding is required.",
            "solution": "The posed problem is subject to validation.\n\n**Step 1: Extract Givens**\n-   **Domain**: A deoxyribonucleic acid (DNA) segment is modeled as a finite string $S$ over the alphabet $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$.\n-   **Definition of Subsequence**: A subsequence of $S$ is obtained by deleting zero or more characters of $S$ without changing the order of the remaining characters.\n-   **Definition of Palindrome**: A palindrome is a string that is identical to its reverse.\n-   **Input String**: $S = \\text{ACGTCAGCAT}$.\n-   **Length of Input String**: $10$.\n-   **Objective**: Determine the length of the longest palindromic subsequence of $S$.\n-   **Constraint**: The solution must use the dynamic programming principle.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is assessed against the required criteria:\n-   **Scientific Grounding**: The problem is well-grounded in computational biology and computer science. The representation of DNA as a string and the analysis of its subsequences are standard and valid abstractions.\n-   **Well-Posedness**: The problem of finding the length of the longest palindromic subsequence is a classic, well-defined problem with a unique solution. All necessary data ($S$) and definitions are provided.\n-   **Objectivity**: The language is formal, precise, and devoid of any subjectivity or ambiguity.\n\n**Verdict:** The problem is valid. It is a standard exercise in dynamic programming, is self-contained, and scientifically sound. Proceeding to solution.\n\nThe problem is to find the length of the longest palindromic subsequence (LPS) of a given string $S$. A fundamental result from the theory of algorithms states that the length of the LPS of a string $S$ is equivalent to the length of the longest common subsequence (LCS) of $S$ and its reverse, denoted as $S_{rev}$. We will use dynamic programming to solve this equivalent LCS problem.\n\nLet the given string be $S = \\text{ACGTCAGCAT}$. Its length is $n=10$.\nThe reverse of $S$ is $S_{rev} = \\text{TACGACGTCA}$.\n\nLet $L(i, j)$ denote the length of the LCS of the prefix of $S$ of length $i$ (i.e., $S[1..i]$) and the prefix of $S_{rev}$ of length $j$ (i.e., $S_{rev}[1..j]$). Our goal is to compute $L(n, n) = L(10, 10)$.\n\nThe dynamic programming recurrence relation for $L(i, j)$ is as follows, for $i, j \\in \\{1, \\dots, n\\}$:\n$$\nL(i, j) =\n\\begin{cases}\n    L(i-1, j-1) + 1 & \\text{if } S[i] = S_{rev}[j] \\\\\n    \\max(L(i-1, j), L(i, j-1)) & \\text{if } S[i] \\neq S_{rev}[j]\n\\end{cases}\n$$\nThe base cases are $L(i, 0) = 0$ for all $i \\in \\{0, \\dots, n\\}$ and $L(0, j) = 0$ for all $j \\in \\{0, \\dots, n\\}$.\n\nWe construct an $(n+1) \\times (n+1)$ table to store the values of $L(i, j)$. The rows are indexed by characters of $S$ (from $i=1$ to $10$) and columns by characters of $S_{rev}$ (from $j=1$ to $10$). The $0$-th row and column are initialized to $0$.\n\nLet $S_i$ be the $i$-th character of $S$ and $(S_{rev})_j$ be the $j$-th character of $S_{rev}$.\n$S = \\text{A}_1 \\text{C}_2 \\text{G}_3 \\text{T}_4 \\text{C}_5 \\text{A}_6 \\text{G}_7 \\text{C}_8 \\text{A}_9 \\text{T}_{10}$\n$S_{rev} = \\text{T}_1 \\text{A}_2 \\text{C}_3 \\text{G}_4 \\text{A}_5 \\text{C}_6 \\text{G}_7 \\text{T}_8 \\text{C}_9 \\text{A}_{10}$\n\nThe table is populated as follows:\n$$\n\\begin{array}{c|ccccccccccc}\nL(i,j) & \\text{} & \\text{T}_1 & \\text{A}_2 & \\text{C}_3 & \\text{G}_4 & \\text{A}_5 & \\text{C}_6 & \\text{G}_7 & \\text{T}_8 & \\text{C}_9 & \\text{A}_{10} \\\\\n\\hline\n\\text{} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\text{A}_1 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\\n\\text{C}_2 & 0 & 0 & 1 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 \\\\\n\\text{G}_3 & 0 & 0 & 1 & 2 & 3 & 3 & 3 & 3 & 3 & 3 & 3 \\\\\n\\text{T}_4 & 0 & 1 & 1 & 2 & 3 & 3 & 3 & 3 & 4 & 4 & 4 \\\\\n\\text{C}_5 & 0 & 1 & 1 & 2 & 3 & 3 & 4 & 4 & 4 & 5 & 5 \\\\\n\\text{A}_6 & 0 & 1 & 2 & 2 & 3 & 4 & 4 & 4 & 4 & 5 & 6 \\\\\n\\text{G}_7 & 0 & 1 & 2 & 2 & 3 & 4 & 4 & 5 & 5 & 5 & 6 \\\\\n\\text{C}_8 & 0 & 1 & 2 & 3 & 3 & 4 & 5 & 5 & 5 & 6 & 6 \\\\\n\\text{A}_9 & 0 & 1 & 2 & 3 & 3 & 4 & 5 & 5 & 5 & 6 & 7 \\\\\n\\text{T}_{10} & 0 & 1 & 2 & 3 & 3 & 4 & 5 & 5 & 6 & 6 & 7 \\\\\n\\end{array}\n$$\nLet us verify a few key entries to ensure correctness.\n-   $L(6, 10)$: $S[6] = \\text{'A'}$ and $S_{rev}[10] = \\text{'A'}$. Thus, $L(6, 10) = L(5, 9) + 1 = 5 + 1 = 6$.\n-   $L(8, 9)$: $S[8] = \\text{'C'}$ and $S_{rev}[9] = \\text{'C'}$. Thus, $L(8, 9) = L(7, 8) + 1 = 5 + 1 = 6$.\n-   $L(9, 10)$: $S[9] = \\text{'A'}$ and $S_{rev}[10] = \\text{'A'}$. Thus, $L(9, 10) = L(8, 9) + 1 = 6 + 1 = 7$.\n-   $L(10, 10)$: $S[10] = \\text{'T'}$ and $S_{rev}[10] = \\text{'A'}$. They are not equal. Thus, $L(10, 10) = \\max(L(9, 10), L(10, 9)) = \\max(7, 6) = 7$.\n\nThe final entry in the table, $L(10, 10)$, gives the length of the LCS of $S$ and $S_{rev}$, which is the length of the LPS of $S$.\nFrom the table, the value of $L(10, 10)$ is $7$.\nA possible longest palindromic subsequence is $\\text{ACGAGCA}$. This can be constructed by tracking back the path in the table.\n\nThe length of the longest palindromic subsequence is $7$.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "In many biological scenarios, a single \"best\" answer is less informative than understanding the full range of high-scoring possibilities. This advanced exercise  moves beyond just calculating the optimal alignment score to enumerating all the distinct alignments that achieve it. By augmenting the dynamic programming algorithm to count these \"co-optimal\" paths, you will gain a deeper appreciation for the rich information encoded within the DP table.",
            "id": "2387132",
            "problem": "You are given two finite sequences $X = x_{1}x_{2}\\dots x_{n}$ and $Y = y_{1}y_{2}\\dots y_{m}$ over the alphabet $\\{A,C,G,T\\}$. An alignment path is defined as any finite sequence of unit moves from $(0,0)$ to $(n,m)$ in the integer lattice $\\{0,1,\\dots,n\\}\\times\\{0,1,\\dots,m\\}$ using only the following moves:\n- from $(i-1,j)$ to $(i,j)$, interpreted as aligning $x_{i}$ with a gap,\n- from $(i,j-1)$ to $(i,j)$, interpreted as aligning a gap with $y_{j}$,\n- from $(i-1,j-1)$ to $(i,j)$, interpreted as aligning $x_{i}$ with $y_{j}$.\n\nThe total alignment score of a path is the sum over its moves of the corresponding step scores. Each vertical or horizontal move contributes a gap penalty $g \\in \\mathbb{R}$. Each diagonal move contributes a pairwise substitution score $s(x_{i},y_{j})$ defined by\n$$\ns(a,b)=\n\\begin{cases}\nM & \\text{if } a=b,\\\\\n\\mu & \\text{if } a\\neq b,\n\\end{cases}\n$$\nfor fixed constants $M,\\mu \\in \\mathbb{R}$. Among all alignment paths from $(0,0)$ to $(n,m)$, define the optimal score as the maximum possible total alignment score. A co-optimal alignment path is any path that attains this maximum.\n\nFor each test case below, determine the number of distinct co-optimal alignment paths. Two paths are considered distinct if their sequences of moves (equivalently, their induced alignments) differ at least at one step. Express every answer as an integer.\n\nTest suite:\n1. $X=\\text{\"GATTACA\"}$, $Y=\\text{\"GCATGCT\"}$, $M=+1$, $\\mu=-1$, $g=-2$.\n2. $X=\\text{\"GA\"}$, $Y=\\text{\"AG\"}$, $M=+2$, $\\mu=-1$, $g=-1$.\n3. $X=\\text{\"AAA\"}$, $Y=\\text{\"AAA\"}$, $M=+2$, $\\mu=-1$, $g=-2$.\n4. $X=\\text{\"\"}$, $Y=\\text{\"ACGT\"}$, $M=+1$, $\\mu=-1$, $g=-1$.\n5. $X=\\text{\"\"}$, $Y=\\text{\"\"}$, $M=+1$, $\\mu=-1$, $g=-1$.\n6. $X=\\text{\"GCG\"}$, $Y=\\text{\"GCCG\"}$, $M=+1$, $\\mu=0$, $g=0$.\n\nYour program should produce a single line of output containing the results for the six test cases as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$).",
            "solution": "The problem of determining the number of co-optimal alignment paths for two sequences is a variant of the classical Needleman-Wunsch algorithm for global sequence alignment. The problem is well-defined and can be solved efficiently using the principle of dynamic programming. The solution requires not only finding the maximum alignment score but also counting the number of distinct paths that achieve this score. This calls for an augmentation of the standard dynamic programming approach.\n\nThe solution rests on constructing two matrices, or tables. Let the two sequences be $X = x_{1}x_{2}\\dots x_{n}$ and $Y = y_{1}y_{2}\\dots y_{m}$. We define a score matrix $S$ of size $(n+1) \\times (m+1)$ and a count matrix $C$ of the same dimensions. The entry $S(i,j)$ will store the optimal alignment score for the prefixes $X_i = x_{1}\\dots x_{i}$ and $Y_j = y_{1}\\dots y_{j}$. The entry $C(i,j)$ will store the number of distinct co-optimal paths that yield the score $S(i,j)$.\n\nThe value of $S(i,j)$ for $i > 0$ and $j > 0$ is determined by the recurrence relation based on the three possible moves ending at cell $(i,j)$:\n$$\nS(i,j) = \\max \\begin{cases}\nS(i-1, j-1) + s(x_{i}, y_{j}) & \\text{(from diagonal predecessor)} \\\\\nS(i-1, j) + g & \\text{(from predecessor above)} \\\\\nS(i, j-1) + g & \\text{(from predecessor to the left)}\n\\end{cases}\n$$\nwhere $s(x_{i}, y_{j})$ is the substitution score ($M$ for a match, $\\mu$ for a mismatch) and $g$ is the gap penalty.\n\nThe core of the problem is to derive the recurrence for the count matrix $C(i,j)$. A co-optimal path to $(i,j)$ must extend a co-optimal path from a predecessor cell $(i',j')$. The number of ways to reach $(i,j)$ optimally is the sum of the number of optimal paths from all predecessor cells that can lead to the score $S(i,j)$. Formally, let $S_{diag} = S(i-1, j-1) + s(x_{i}, y_{j})$, $S_{up} = S(i-1, j) + g$, and $S_{left} = S(i, j-1) + g$. We know that $S(i,j) = \\max(S_{diag}, S_{up}, S_{left})$. The value of $C(i,j)$ is then calculated by summing the counts from the predecessor cells whose corresponding move results in the score $S(i,j)$:\n$$\nC(i,j) = \\sum_{(i', j') \\in \\text{Pred}(i,j)} C(i', j')\n$$\nwhere $\\text{Pred}(i,j)$ is the set of predecessor cells that contribute to the optimal score $S(i,j)$. This can be written as:\nInitialize $C(i,j) = 0$.\nIf $S(i,j) = S_{diag}$, then $C(i,j) \\leftarrow C(i,j) + C(i-1, j-1)$.\nIf $S(i,j) = S_{up}$, then $C(i,j) \\leftarrow C(i,j) + C(i-1, j)$.\nIf $S(i,j) = S_{left}$, then $C(i,j) \\leftarrow C(i,j) + C(i, j-1)$.\nThese conditions are not mutually exclusive; if multiple move types yield the same maximal score, the path counts from all corresponding predecessors are added.\n\nThe base cases for the recurrences must be established. The alignment of two empty sequences has a score of $0$ and there is exactly one way to achieve this (the empty path). Thus, $S(0,0)=0$ and $C(0,0)=1$. The alignment of a prefix of length $i$ with an empty sequence consists of $i$ gaps.\nFor the first row and column of the matrices:\nFor $i$ from $1$ to $n$:\n$S(i,0) = i \\times g$. There is only one path to reach $(i,0)$ from $(0,0)$, consisting of $i$ consecutive vertical moves. Thus, $C(i,0) = 1$.\nFor $j$ from $1$ to $m$:\n$S(0,j) = j \\times g$. Similarly, there is only one path to reach $(0,j)$ from $(0,0)$, consisting of $j$ consecutive horizontal moves. Thus, $C(0,j) = 1$.\n\nThe algorithm proceeds by filling the matrices $S$ and $C$ from $i=1 \\dots n$ and $j=1 \\dots m$. After computing all entries up to $(n,m)$, the final answer is given by the value in the bottom-right cell of the count matrix, $C(n,m)$. For the given test cases, this includes handling empty sequences, where $n=0$ or $m=0$. In such cases, the algorithm correctly returns $1$, as there is only one alignment possible. The numeric values for $M$, $\\mu$, and $g$ are substituted as provided in each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_cooptimal_alignments(X, Y, M, mu, g):\n    \"\"\"\n    Calculates the number of co-optimal global alignments of two sequences X and Y.\n    This is based on the Needleman-Wunsch algorithm, extended to count paths.\n    \"\"\"\n    n = len(X)\n    m = len(Y)\n\n    # S stores the optimal scores.\n    # C stores the number of co-optimal paths.\n    S = np.zeros((n + 1, m + 1), dtype=np.int64)\n    C = np.zeros((n + 1, m + 1), dtype=np.int64)\n\n    # Initialize base cases for the dynamic programming matrices.\n    # The empty alignment has a score of 0 and there is 1 path (the empty path).\n    C[0, 0] = 1\n\n    # Aligning a sequence with gaps.\n    for i in range(1, n + 1):\n        S[i, 0] = i * g\n        C[i, 0] = 1  # Only one way to introduce i gaps.\n    for j in range(1, m + 1):\n        S[0, j] = j * g\n        C[0, j] = 1  # Only one way to introduce j gaps.\n\n    # Fill the matrices using the recurrence relations.\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # Calculate the score for a match or mismatch.\n            sub_score = M if X[i - 1] == Y[j - 1] else mu\n            \n            # Calculate the scores from the three possible predecessor cells.\n            score_diag = S[i - 1, j - 1] + sub_score\n            score_up = S[i - 1, j] + g\n            score_left = S[i, j - 1] + g\n            \n            # Determine the maximum score for the current cell.\n            max_score = max(score_diag, score_up, score_left)\n            S[i, j] = max_score\n            \n            # Update the count matrix C based on which predecessors lead to the max score.\n            # If a predecessor's path contributes to the optimal score, add its path count.\n            if max_score == score_diag:\n                C[i, j] += C[i - 1, j - 1]\n            if max_score == score_up:\n                C[i, j] += C[i - 1, j]\n            if max_score == score_left:\n                C[i, j] += C[i, j-1]\n    \n    # The total number of co-optimal paths is the value in the bottom-right cell.\n    return C[n, m]\n\ndef solve():\n    \"\"\"\n    Runs the defined test cases and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (X, Y, M, mu, g)\n        (\"GATTACA\", \"GCATGCT\", 1, -1, -2),\n        (\"GA\", \"AG\", 2, -1, -1),\n        (\"AAA\", \"AAA\", 2, -1, -2),\n        (\"\", \"ACGT\", 1, -1, -1),\n        (\"\", \"\", 1, -1, -1),\n        (\"GCG\", \"GCCG\", 1, 0, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        X, Y, M, mu, g = case\n        result = count_cooptimal_alignments(X, Y, M, mu, g)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}