{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a practical application of the divide-and-conquer strategy to a common task in sequence analysis: identifying biologically significant patterns. You will design an algorithm to find all reverse-complement palindromes, which often act as recognition sites for proteins. This practice  beautifully illustrates how a classic divide-and-conquer method, binary search, can be used to efficiently determine the maximum size of a pattern, transforming a potentially slow verification process into a highly optimized search.",
            "id": "2386095",
            "problem": "You are given the task of designing and implementing a divide and conquer (D&C) algorithm to find all reverse-complement palindromic substrings in a Deoxyribonucleic Acid (DNA) chromosome. A DNA chromosome will be modeled as a finite string over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$. Use the canonical base-pairing rules: $\\mathrm{A}$ pairs with $\\mathrm{T}$ and $\\mathrm{C}$ pairs with $\\mathrm{G}$. For any DNA string $s$, define its complement $\\operatorname{comp}(s)$ by applying these pairings characterwise, and its reverse complement $\\operatorname{rc}(s)$ by reversing $\\operatorname{comp}(s)$. A string $w$ is a reverse-complement palindrome if $w=\\operatorname{rc}(w)$. For indices, use $0$-based indexing. For a substring $s[i:j]$ (with $i$ inclusive and $j$ exclusive), its length is $j-i$.\n\nStarting from the fundamental definitions of string substrings and the DNA complementarity rules, and the well-tested fact that binary search is a canonical divide and conquer strategy that halves the search interval on each step, design an algorithm that:\n- Preprocesses the chromosome to enable constant-time substring-equality queries under a fixed encoding.\n- For each potential palindrome center, uses a divide and conquer strategy (binary search on the radius) to find the maximum radius such that the corresponding substring equals its reverse complement.\n- Enumerates all reverse-complement palindromic substrings of length at least $k$.\n\nThe algorithm must be framed purely in mathematical and logical terms and be implementable in any modern programming language. No biological wet-lab steps are involved. All answers are unitless. You must output all substrings satisfying the criterion as pairs $[i,\\ell]$, where $i$ is the starting index and $\\ell$ is the length, with $i$ in $0$-based indexing. Sort the pairs for each chromosome in ascending order by $i$, and for equal $i$, by $\\ell$. Because under standard DNA base-pairing, no nucleotide is its own complement, only even-length reverse-complement palindromes can exist; your method should discover this from first principles via the palindromicity test and not rely on a hard-coded special case.\n\nYou must implement the algorithm as a single, complete, runnable program that produces the results for the following test suite. For each case, compute all reverse-complement palindromic substrings of length at least $k$:\n\n- Test case $1$: chromosome $s=\\text{\"ATCGAT\"}$, $k=4$.\n- Test case $2$: chromosome $s=\\text{\"AAAAAA\"}$, $k=3$.\n- Test case $3$: chromosome $s=\\text{\"CGAATTCG\"}$, $k=4$.\n- Test case $4$: chromosome $s=\\text{\"AT\"}$, $k=2$.\n- Test case $5$: chromosome $s=\\text{\"ATAT\"}$, $k=2$.\n\nFinal output format: Your program must produce a single line of output containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of $[i,\\ell]$ pairs. For example, the general structure is $[[[i_1,\\ell_1],[i_2,\\ell_2],\\dots],[],\\dots]$. There must be no spaces anywhere in the output line.",
            "solution": "The problem is to devise and implement a divide and conquer algorithm to identify all reverse-complement palindromic substrings within a given Deoxyribonucleic Acid (DNA) sequence, subject to a minimum length constraint. The problem is well-posed, scientifically grounded in the principles of molecular biology and computational string analysis, and contains all necessary information for a unique solution.\n\nFirst, we formalize the definitions. A DNA sequence $s$ is a string over the alphabet $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$. The complementarity rules define a function $c: \\Sigma \\to \\Sigma$ where $c(\\mathrm{A})=\\mathrm{T}$, $c(\\mathrm{T})=\\mathrm{A}$, $c(\\mathrm{C})=\\mathrm{G}$, and $c(\\mathrm{G})=\\mathrm{C}$. For a string $s = s_0s_1\\dots s_{n-1}$, its complement is $\\operatorname{comp}(s) = c(s_0)c(s_1)\\dots c(s_{n-1})$, and its reverse is $\\operatorname{rev}(s) = s_{n-1}\\dots s_1s_0$. The reverse complement is defined as $\\operatorname{rc}(s) = \\operatorname{rev}(\\operatorname{comp}(s))$. A substring $w$ is a reverse-complement palindrome if it satisfies the condition $w = \\operatorname{rc}(w)$. Our task is to find all such substrings $w$ of a given chromosome $s$ where the length of $w$, denoted $|w|$, is at least a given integer $k$.\n\nA critical observation, derived from first principles as required, concerns the possible lengths of such palindromes. A palindrome $w$ of odd length, say $|w| = 2r+1$ for some integer $r \\ge 0$, has a central character $w_r$. The palindromic condition $w = \\operatorname{rc}(w)$ implies $w_i = c(w_{2r-i})$ for all $i \\in \\{0, \\dots, 2r\\}$. For the central character at $i=r$, this gives $w_r = c(w_r)$. However, for the canonical DNA bases, no base is its own complement: $c(x) \\neq x$ for any $x \\in \\Sigma$. Consequently, no character can satisfy the central condition, and thus no reverse-complement palindrome of odd length can exist. All such palindromes must have an even length, $|w| = 2r$ for $r \\ge 1$.\n\nAn even-length palindrome is centered between two characters. For a string $s$ of length $N$, there are $N-1$ possible centers for even-length palindromes, located between indices $i-1$ and $i$ for $i \\in \\{1, \\dots, N-1\\}$. For a given center $i$, a palindrome of radius $r \\ge 1$ is the substring $s[i-r : i+r]$, which has length $2r$. The condition for this substring to be a reverse-complement palindrome is $s[i-k] = c(s[i+k-1])$ for all $k \\in \\{1, \\dots, r\\}$.\n\nThe core of the specified algorithm is a divide and conquer strategy. For each potential center, we must find the maximal radius $R_{max}$ for which the palindromic property holds. The set of all valid palindromes for that center are then those with radii $r \\in \\{1, \\dots, R_{max}\\}$. The property of being a palindrome is monotonic: if it holds for a radius $r$, it must hold for any smaller radius $r' < r$. This structure permits the use of binary search—a classic divide and conquer technique—to find $R_{max}$ efficiently. For a center $i$, the search space for the radius $r$ is the interval $[0, \\min(i, N-i)]$.\n\nTo execute the binary search efficiently, each check for the palindromic property must be performed in constant time, $O(1)$. A naive character-by-character comparison for a radius $r$ would take $O(r)$ time, leading to an overall complexity of $O(N^2)$. The problem mandates preprocessing to achieve $O(1)$ substring-equality queries. Polynomial rolling hash is a standard method for this. The palindromic condition for radius $r$ at center $i$, $s[i-k] = c(s[i+k-1])$ for $k=1, \\dots, r$, is equivalent to the string equality $s[i-r : i] = \\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$.\n\nTo implement this check using hashing, we precompute hash values for two strings: the original string $s$, and its complete reverse complement, $s_{rc} = \\operatorname{rc}(s)$. Let $|s| = N$. The substring $s[i-r:i]$ is a simple substring of $s$. The substring $\\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$ is equivalent to a specific substring of $s_{rc}$. The reverse complement of $s[i:i+r]$ corresponds to the substring of $s_{rc}$ starting at index $N-(i+r)$ with length $r$, i.e., $s_{rc}[N-i-r : N-i]$. Thus, the palindromic check for radius $r$ at center $i$ reduces to comparing the hash of $s[i-r : i]$ with the hash of $s_{rc}[N-i-r : N-i]$. With precomputed prefix hashes for both $s$ and $s_{rc}$, this comparison takes $O(1)$ time. To minimize hash collisions, a dual-hashing scheme with two independent pairs of base and modulus is employed.\n\nThe complete algorithm proceeds as follows:\n1.  **Preprocessing ($O(N)$ time)**:\n    a. Given the input string $s$ of length $N$.\n    b. Construct its reverse complement, $s_{rc}$.\n    c. For both $s$ and $s_{rc}$, precompute two sets of prefix hashes and powers of the bases, using two different (base, modulus) pairs.\n\n2.  **Palindrome Search ($O(N \\log N)$ time)**:\n    a. Initialize an empty list, `results`, to store the found palindromes.\n    b. Iterate through each potential center $i \\in \\{1, \\dots, N-1\\}$.\n    c. For each center $i$, determine the maximum possible radius, $r_{lim} = \\min(i, N-i)$.\n    d. Perform a binary search on the radius $r \\in [1, r_{lim}]$ to find the maximal radius $R_{max}$ for which $s[i-r:i]$ and $\\operatorname{rev}(\\operatorname{comp}(s[i:i+r]))$ are identical. This check is performed in $O(1)$ by comparing the dual hash values of $s[i-r:i]$ and $s_{rc}[N-i-r:N-i]$.\n    e. After finding $R_{max}$, all substrings centered at $i$ with radii from $1$ to $R_{max}$ are reverse-complement palindromes. Their lengths are $2, 4, \\dots, 2R_{max}$.\n\n3.  **Result Enumeration and Formatting**:\n    a. For each center $i$ and its found $R_{max}$, iterate through radii $r$ from $\\lceil k/2 \\rceil$ to $R_{max}$. For each such $r$, a valid palindrome is found. Its length is $\\ell = 2r$ and its starting index is $j = i-r$. Add the pair $[j, \\ell]$ to the `results` list.\n    b. After iterating through all centers, sort the `results` list in ascending order of starting index $j$, and for equal $j$, by length $\\ell$.\n    c. Format the final output as specified.\n\nThe total time complexity of this algorithm is dominated by the search step, which is $O(N \\log N)$. The space complexity is $O(N)$ for storing the strings and their hash tables. This approach conforms to all requirements of the problem statement.",
            "answer": "```python\nclass DualStringHasher:\n    \"\"\"\n    Computes and provides rolling hashes for a string using two different\n    (base, modulus) pairs to minimize collisions.\n    \"\"\"\n    def __init__(self, s: str):\n        self.n = len(s)\n        self.p1, self.m1 = 31, 10**9 + 7\n        self.p2, self.m2 = 37, 10**9 + 9\n        \n        char_map = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n        # Using .get with a default value handles potential invalid characters\n        s_int = [char_map.get(c, 0) for c in s]\n\n        self.powers1 = [1] * (self.n + 1)\n        self.hashes1 = [0] * (self.n + 1)\n        self.powers2 = [1] * (self.n + 1)\n        self.hashes2 = [0] * (self.n + 1)\n\n        for i in range(self.n):\n            self.powers1[i+1] = (self.powers1[i] * self.p1) % self.m1\n            self.hashes1[i+1] = (self.hashes1[i] * self.p1 + s_int[i]) % self.m1\n            self.powers2[i+1] = (self.powers2[i] * self.p2) % self.m2\n            self.hashes2[i+1] = (self.hashes2[i] * self.p2 + s_int[i]) % self.m2\n\n    def get_hash_pair(self, i: int, j: int) -> tuple[int, int]:\n        \"\"\"\n        Returns the hash pair for the substring s[i:j].\n        \"\"\"\n        length = j - i\n        if length = 0:\n            return (0, 0)\n        h1 = (self.hashes1[j] - (self.hashes1[i] * self.powers1[length]) % self.m1 + self.m1) % self.m1\n        h2 = (self.hashes2[j] - (self.hashes2[i] * self.powers2[length]) % self.m2 + self.m2) % self.m2\n        return (h1, h2)\n\ndef find_palindromes(s: str, k: int) -> list[list[int]]:\n    \"\"\"\n    Finds all reverse-complement palindromic substrings of length at least k.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return []\n\n    comp_map = str.maketrans(\"ACGT\", \"TGCA\")\n    s_comp = s.translate(comp_map)\n    s_rc = s_comp[::-1]\n\n    hasher_s = DualStringHasher(s)\n    hasher_rc = DualStringHasher(s_rc)\n    \n    results = []\n\n    # Iterate through all possible centers for even-length palindromes.\n    # Center is between index i-1 and i.\n    for i in range(1, n):\n        # Binary search for the maximum radius r.\n        low, high = 0, min(i, n - i)\n        max_r = 0\n        \n        while low = high:\n            r = (low + high) // 2\n            if r == 0:\n                low = r + 1\n                continue\n\n            # Substring s[i-r:i]\n            hash1 = hasher_s.get_hash_pair(i - r, i)\n            # The reverse complement of s[i:i+r] is found in s_rc\n            # at index n-(i+r) with length r => s_rc[n-i-r : n-i]\n            hash2 = hasher_rc.get_hash_pair(n - i - r, n - i)\n\n            if hash1 == hash2:\n                max_r = r\n                low = r + 1\n            else:\n                high = r - 1\n        \n        # Collect all valid palindromes for this center\n        if max_r > 0:\n            # We need length 2r >= k, so r >= k/2\n            min_r_for_k = (k + 1) // 2\n            for r in range(min_r_for_k, max_r + 1):\n                start_index = i - r\n                length = 2 * r\n                results.append([start_index, length])\n    \n    # Sort results by start index, then by length\n    results.sort()\n    \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        (\"ATCGAT\", 4),\n        (\"AAAAAA\", 3),\n        (\"CGAATTCG\", 4),\n        (\"AT\", 2),\n        (\"ATAT\", 2),\n    ]\n\n    all_results = []\n    for s, k in test_cases:\n        case_result = find_palindromes(s, k)\n        all_results.append(case_result)\n\n    # Format the output string exactly as required, with no spaces.\n    # str(all_results) would introduce spaces, so we build it manually.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A defining challenge in modern bioinformatics is processing datasets that are far too large to fit into a computer's main memory. This problem  introduces a powerful and elegant divide-and-conquer approach to this challenge by partitioning the solution space itself, rather than the input data. By implementing an algorithm to count distinct $k$-mers under a strict memory budget, you will gain hands-on experience with an essential technique for designing scalable, \"out-of-core\" tools for large-scale genomics.",
            "id": "2386106",
            "problem": "You are given a multiset of deoxyribonucleic acid (DNA) strings over the alphabet $\\Sigma=\\{A,C,G,T\\}$. For an integer $k \\ge 1$, a $k$-mer is any length-$k$ contiguous substring composed only of characters in $\\Sigma$. Substrings containing any character not in $\\Sigma$ are not considered valid $k$-mers and must be ignored. For a collection of DNA strings, let $\\mathcal{K}_k$ denote the set of all valid $k$-mers that appear in at least one string from the collection. Your task is to compute $|\\mathcal{K}_k|$ exactly under a strict memory budget that models Random Access Memory (RAM). The memory budget is formalized as follows: at any instant, your program is not permitted to hold more than $B$ distinct $k$-mer keys in memory simultaneously. You may assume $B \\ge 1$ is an integer.\n\nDesign and implement a program that, given several parameter sets $(\\text{sequences}, k, B)$, returns the exact value of $|\\mathcal{K}_k|$ for each set, while ensuring that at no time does any data structure in your approach store more than $B$ distinct $k$-mers concurrently. The entire input may be larger than available RAM; your method must therefore proceed by structuring the computation so that the final exact result is obtained without exceeding the stated constraint on concurrently stored distinct keys. The input sequences should be treated as read-only strings; do not assume any specialized preprocessed index is available.\n\nUse the following test suite of parameter values inside your program. In each item below, the value $k$ and the budget $B$ are given, followed by the list of DNA strings. In all cases, ignore substrings containing characters outside $\\Sigma$.\n\n- Test case $1$: $k=3$, $B=2$, sequences = [\"ACGTACGT\",\"TACG\"].\n- Test case $2$: $k=2$, $B=4$, sequences = [\"AAAAAA\"].\n- Test case $3$: $k=2$, $B=1$, sequences = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"].\n- Test case $4$: $k=4$, $B=1$, sequences = [\"ATATATATAT\",\"TATATATATA\"].\n- Test case $5$: $k=1$, $B=1$, sequences = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"].\n- Test case $6$: $k=3$, $B=2$, sequences = [\"AC\",\"G\"].\n\nYour program must compute, for each test case, the integer $|\\mathcal{K}_k|$, where $\\mathcal{K}_k$ is defined as above. The required final output format is a single line containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases listed above, for example \"[x1,x2,x3,x4,x5,x6]\" where each $x_i$ is an integer equal to $|\\mathcal{K}_k|$ for test case $i$.",
            "solution": "The problem statement is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n-   **Alphabet**: $\\Sigma=\\{A,C,G,T\\}$\n-   **$k$-mer**: A contiguous substring of length $k \\ge 1$ composed only of characters from $\\Sigma$.\n-   **Invalid substrings**: Substrings containing characters not in $\\Sigma$ are to be ignored.\n-   **Input**: A multiset of strings, denoted `sequences`.\n-   **Input Parameter $k$**: An integer, the length of the $k$-mer, where $k \\ge 1$.\n-   **Input Parameter $B$**: An integer, the memory budget, representing the maximum number of distinct $k$-mer keys that can be stored concurrently. It is given that $B \\ge 1$.\n-   **Objective**: Compute $|\\mathcal{K}_k|$, the cardinality of the set $\\mathcal{K}_k$ of all unique, valid $k$-mers present in the input `sequences`.\n-   **Constraint**: The algorithm must not store more than $B$ distinct $k$-mers in memory at any given time.\n-   **Test Cases**:\n    -   Test case $1$: $k=3$, $B=2$, sequences = [\"ACGTACGT\",\"TACG\"].\n    -   Test case $2$: $k=2$, $B=4$, sequences = [\"AAAAAA\"].\n    -   Test case $3$: $k=2$, $B=1$, sequences = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"].\n    -   Test case $4$: $k=4$, $B=1$, sequences = [\"ATATATATAT\",\"TATATATATA\"].\n    -   Test case $5$: $k=1$, $B=1$, sequences = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"].\n    -   Test case $6$: $k=3$, $B=2$, sequences = [\"AC\",\"G\"].\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is well-grounded in computational biology and bioinformatics. $k$-mer counting is a fundamental task for applications such as genome assembly, sequence alignment, and metagenomic analysis. The use of the alphabet $\\Sigma=\\{A,C,G,T\\}$ and the concept of ignoring non-standard characters (like 'N') are standard conventions. The problem is a variant of the \"distinct elements problem\" from streaming algorithms, applied to bioinformatics under a specific memory model. It is scientifically and computationally sound.\n-   **Well-Posedness**: The problem is well-posed. The objective is to compute the cardinality of a uniquely defined set $\\mathcal{K}_k$. The inputs and constraints are specified clearly. For any valid set of inputs, a unique integer solution exists.\n-   **Objectivity**: The problem is stated using precise, objective, and formal mathematical language. It is free from ambiguity, subjectivity, or opinion-based claims.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a standard, well-defined computational problem with clear constraints and objectives. Proceeding to solution.\n\n**Principle-Based Solution**\n\nThe central challenge of this problem is the strict memory budget, $B$, which prohibits a naive approach. A direct solution, such as iterating through all sequences, extracting all $k$-mers, and inserting them into a single hash set, would fail if the total number of distinct $k$-mers, $|\\mathcal{K}_k|$, exceeds $B$. The problem therefore mandates an algorithm that can operate on data larger than the available memory, often termed an \"external memory\" or \"out-of-core\" algorithm.\n\nThe guiding principle for such a problem is **divide and conquer**. However, instead of partitioning the input data (the sequences), which is read-only, we must partition the problem space itself. The problem space is the set of all possible $4^k$ $k$-mers over the alphabet $\\Sigma$. By partitioning this space into disjoint subsets, we can count the distinct $k$-mers within each subset independently and sum the results. The disjoint nature of the partitions ensures that no $k$-mer is counted more than once.\n\nThe most effective partitioning strategy here is a recursive partitioning of the $k$-mer space based on prefixes. Let's define a function, $\\text{Count}(\\rho)$, which counts the number of distinct $k$-mers in the input sequences that start with a given prefix $\\rho$. The total number of distinct $k$-mers is then simply $\\text{Count}(\\text{\"\"})$, where $\\text{\"\"}$ is the empty prefix.\n\nThe algorithm is structured as a recursive function that attempts to solve $\\text{Count}(\\rho)$ within the memory budget $B$.\n\n$1$. **Attempt to Count**: To compute $\\text{Count}(\\rho)$, we iterate through all input sequences. For each valid $k$-mer found, we check if it begins with the prefix $\\rho$. If it does, we add it to an in-memory set, let's call it $S_{\\rho}$.\n\n$2$. **Memory Budget Check**: During this process, we continuously monitor the size of our set, $|S_{\\rho}|$.\n    - If the entire dataset is processed and $|S_{\\rho}|$ never exceeds $B$, we have successfully counted the distinct $k$-mers for this partition. The function returns $|S_{\\rho}|$. This forms the base case of our recursion.\n    - If at any point $|S_{\\rho}|$ becomes greater than $B$, it means the partition defined by prefix $\\rho$ is too large to be processed within the memory limit. We must \"spill,\" which in this context means abandoning the current count and subdividing the problem.\n\n$3$. **Recursive Subdivision (Divide Step)**: Upon a \"spill,\" we subdivide the partition corresponding to prefix $\\rho$ into four smaller, disjoint partitions based on the next character. The four new prefixes will be $\\rho+'A'$, $\\rho+'C'$, $\\rho+'G'$, and $\\rho+'T'$. The total count for prefix $\\rho$ is then the sum of the counts from these smaller partitions. This is expressed recursively:\n$$ \\text{Count}(\\rho) = \\text{Count}(\\rho+'A') + \\text{Count}(\\rho+'C') + \\text{Count}(\\rho+'G') + \\text{Count}(\\rho+'T') $$\nThis recursive call effectively initiates new passes over the data, each focused on a more specific subset of $k$-mers.\n\n$4$. **Termination**: The recursion is guaranteed to terminate. As the prefix length increases, the corresponding partition of the $k$-mer space becomes smaller. In the limiting case, the prefix length becomes $k$. A partition for a prefix of length $k$ can contain at most one unique $k$-mer (the prefix itself). Since the budget $B \\ge 1$, a spill cannot occur for a partition defined by a prefix of length $k$. Therefore, the recursion depth is at most $k$, and the base case (a successful count within budget) will always be reached.\n\nThis recursive, prefix-based divide-and-conquer strategy correctly computes the exact number of distinct $k$-mers while strictly adhering to the memory constraint at every stage of the computation. The cost of this memory-compliance is an increase in computational time, as the input sequences may need to be scanned multiple times.\n\nBefore processing, any characters not in $\\Sigma = \\{A, C, G, T\\}$ must be handled. A robust way to do this is to treat them as delimiters, splitting each input sequence into a set of contiguous substrings composed solely of valid characters. The $k$-mer extraction logic is then applied to these valid substrings only.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the k-mer counting problem for the predefined test suite.\n    \"\"\"\n    \n    test_cases = [\n        # (sequences, k, B)\n        ([\"ACGTACGT\", \"TACG\"], 3, 2),\n        ([\"AAAAAA\"], 2, 4),\n        ([\"NNNNN\", \"ACNGT\", \"ACGTTN\"], 2, 1),\n        ([\"ATATATATAT\", \"TATATATATA\"], 4, 1),\n        ([\"ACGTACGT\", \"GGGG\", \"TTTT\", \"CCCC\", \"AAAA\"], 1, 1),\n        ([\"AC\", \"G\"], 3, 2),\n    ]\n\n    results = []\n    for sequences, k, B in test_cases:\n        result = count_distinct_kmers(sequences, k, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef count_distinct_kmers(sequences, k, B):\n    \"\"\"\n    Main entry point for the k-mer counting algorithm. It initializes\n    the recursive counting process.\n\n    Args:\n        sequences (list[str]): The list of DNA sequences.\n        k (int): The length of the k-mer.\n        B (int): The memory budget (max number of distinct k-mers).\n\n    Returns:\n        int: The total count of distinct k-mers.\n    \"\"\"\n    if k = 0:\n        return 0\n\n    valid_chars = {'A', 'C', 'G', 'T'}\n    \n    # Pre-process sequences to handle invalid characters like 'N'.\n    # This creates a list of substrings containing only valid DNA characters.\n    valid_substrings = []\n    for seq in sequences:\n        current_sub = []\n        for char in seq:\n            if char in valid_chars:\n                current_sub.append(char)\n            else:\n                if current_sub:\n                    valid_substrings.append(\"\".join(current_sub))\n                    current_sub = []\n        if current_sub:\n            valid_substrings.append(\"\".join(current_sub))\n\n    return _count_recursive(valid_substrings, k, B, \"\", np.array(list(valid_chars)))\n\ndef _count_recursive(valid_substrings, k, B, prefix, alphabet):\n    \"\"\"\n    Recursively counts distinct k-mers using a divide-and-conquer approach.\n\n    Args:\n        valid_substrings (list[str]): A list of DNA segments with no invalid characters.\n        k (int): The k-mer length.\n        B (int): The memory budget.\n        prefix (str): The current prefix defining the k-mer partition to count.\n        alphabet (np.ndarray): The characters of the DNA alphabet.\n\n    Returns:\n        int: The count of distinct k-mers for the given partition.\n    \"\"\"\n    kmers_in_partition = set()\n    has_spilled = False\n\n    for sub_seq in valid_substrings:\n        if len(sub_seq)  k:\n            continue\n        for i in range(len(sub_seq) - k + 1):\n            # Potential k-mer\n            kmer = sub_seq[i:i+k]\n            if kmer.startswith(prefix):\n                kmers_in_partition.add(kmer)\n                if len(kmers_in_partition) > B:\n                    has_spilled = True\n                    break  # from inner loop\n        if has_spilled:\n            break  # from outer loop\n    \n    if has_spilled:\n        # Memory budget exceeded. Subdivide the problem and recurse.\n        # This logical branch should not be reachable if len(prefix) == k\n        # because the set would contain at most 1 element, and B >= 1.\n        # The check is an assertion of this logic.\n        if len(prefix) >= k:\n             # This indicates a logical error or an invalid state (e.g., B=0).\n             # Given problem constraints B>=1, this is unreachable.\n             return 1\n             \n        sub_count = 0\n        for char in alphabet:\n            new_prefix = prefix + char\n            sub_count += _count_recursive(valid_substrings, k, B, new_prefix, alphabet)\n        return sub_count\n    else:\n        # Base case: Succeeded in counting k-mers for this partition within the budget.\n        return len(kmers_in_partition)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Moving from implementation to interpretation is a critical step in becoming a computational biologist. This problem  challenges you to think critically about the practical limitations of divide-and-conquer algorithms, specifically in the context of sequence alignment. By analyzing how a memory-efficient alignment algorithm behaves when encountering tandem repeat expansions—a common feature in many genomes—you will learn why a mathematically optimal solution may not always be biologically informative, a crucial insight for accurately interpreting genomic data.",
            "id": "2386083",
            "problem": "You are aligning a patient’s sequence to a reference in the presence of a tandem repeat expansion associated with a neurological disorder. Let the reference be modeled as $R = \\alpha \\, u^{k} \\, \\beta$, where $u$ is a repeat unit of length $\\ell$, $k$ is the number of copies in the reference, and $\\alpha$ and $\\beta$ are unique flanking sequences. The patient’s sequence is $S = \\alpha \\, u^{k+\\Delta} \\, \\beta$, with $\\Delta  0$ indicating an expanded repeat count. You use a standard global alignment algorithm with affine gap costs (gap-open penalty $G  0$, per-residue gap-extension penalty $E  0$, mismatch penalty $M  0$, match reward $A  0$), implemented using a Divide and Conquer (DC) strategy that computes the same optimal alignment as full dynamic programming while reducing memory use (for example, the Hirschberg approach).\n\nWhich statement best describes how such a DC alignment algorithm handles this tandem repeat expansion and where it typically fails in practice?\n\nA. It will represent the expansion as a single long insertion relative to the reference between the conserved flanks $\\alpha$ and $\\beta$, because an affine gap cost favors one long gap over many small gaps; practical failures arise when the optimal path’s midpoint falls inside a long, low-complexity repeat with many equally scoring paths, making the split (and thus the traceback and inferred repeat count) non-unique, and when a banded DC variant is used, if the true path leaves the band due to a large net indel.\n\nB. It will distribute the expansion across many short gaps to balance penalties across the repeat copies; failures occur only when the repeat unit has odd length $\\ell$, because even-length units can be perfectly tiled.\n\nC. Before alignment, it compresses both sequences using run-length encoding of $u$ and aligns in the compressed domain; failures occur if the compression ratio differs between $S$ and $R$, which prevents consistent decoding of the alignment.\n\nD. It produces a unique optimal alignment that always pins down the exact number of repeated units inside the expansion from the dynamic programming traceback; failures occur only when the sequencing error rate exceeds a fixed threshold, regardless of repeat length or structure.",
            "solution": "The problem statement must first be validated for scientific and logical soundness.\n\n**Step 1: Extract Givens**\n-   Reference sequence: $R = \\alpha \\, u^{k} \\, \\beta$\n-   Repeat unit: $u$, of length $\\ell$\n-   Number of copies in reference: $k$\n-   Flanking sequences: $\\alpha$, $\\beta$ (unique)\n-   Patient's sequence: $S = \\alpha \\, u^{k+\\Delta} \\, \\beta$\n-   Expansion size: $\\Delta  0$\n-   Alignment algorithm: Standard global alignment with affine gap costs\n-   Gap-open penalty: $G  0$\n-   Gap-extension penalty: $E  0$\n-   Mismatch penalty: $M  0$\n-   Match reward: $A  0$\n-   Implementation strategy: Divide and Conquer (DC), for example, the Hirschberg algorithm.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem formulation is scientifically sound and well-posed.\n-   **Scientifically Grounded:** The model of a tandem repeat expansion as $S = \\alpha \\, u^{k+\\Delta} \\, \\beta$ is a standard and valid simplification used in bioinformatics to study such phenomena. Global alignment, affine gap penalties, and Divide and Conquer algorithms (specifically Hirschberg's) are all fundamental, textbook concepts in computational biology.\n-   **Well-Posed:** The question asks for a characterization of the algorithm's behavior and its practical failure modes in a clearly defined scenario. A meaningful, non-trivial answer can be derived from established principles of sequence alignment.\n-   **Objective:** The problem is stated using precise mathematical and algorithmic terminology, free from subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed with a full derivation and analysis.\n\n**Derivation of Algorithm Behavior**\n\nThe task is to perform a global alignment between the reference sequence $R = \\alpha \\, u^{k} \\, \\beta$ and the patient sequence $S = \\alpha \\, u^{k+\\Delta} \\, \\beta$. The alignment algorithm seeks to maximize a score, where matches are rewarded ($A$), and mismatches ($M$), gap openings ($G$), and gap extensions ($E$) are penalized.\n\n1.  **Alignment of Flanking Regions:** The sequences $R$ and $S$ share identical, unique flanking sequences $\\alpha$ and $\\beta$. The optimal global alignment will almost certainly align the $\\alpha$ from $R$ with the $\\alpha$ from $S$, and the $\\beta$ from $R$ with the $\\beta$ from $S$. This yields a high score from a long series of matches.\n\n2.  **Alignment of the Repeat Region:** The core of the alignment problem resides in aligning the repeat region $u^k$ from $R$ with $u^{k+\\Delta}$ from $S$. The sequence $u^{k+\\Delta}$ can be conceptually split into $u^k \\cdot u^\\Delta$. The optimal alignment will match the $u^k$ substring from $R$ with the first $u^k$ substring from $S$. This part of the alignment consists of $k \\times \\ell$ matches, contributing positively to the total score.\n\n3.  **Handling the Expansion:** The remaining portion is the $u^\\Delta$ substring in $S$ (of length $\\Delta \\cdot \\ell$), which has no corresponding counterpart in $R$. To complete the alignment, this substring must be aligned with gaps in $R$. This constitutes an insertion of length $\\Delta \\cdot \\ell$ relative to the reference.\n    The algorithm employs an affine gap cost model. The cost of a single gap of length $L$ is $-(G + L \\cdot E)$. The alternative would be to create multiple smaller gaps. For instance, creating $n$ small gaps of lengths $l_1, l_2, \\ldots, l_n$ such that $\\sum_{i=1}^{n} l_i = \\Delta \\cdot \\ell$ would incur a total penalty of $-\\sum_{i=1}^{n} (G + l_i \\cdot E) = -(n \\cdot G + (\\sum_{i=1}^{n} l_i) \\cdot E) = -(n \\cdot G + (\\Delta \\cdot \\ell) \\cdot E)$. Since $G  0$ and for multiple gaps $n  1$, the penalty for multiple gaps is strictly greater than the penalty for a single contiguous gap of the same total length, which is $-(G + (\\Delta \\cdot \\ell) \\cdot E)$. Therefore, the affine gap cost model ensures that the algorithm will represent the contiguous expansion $u^\\Delta$ as a single, long insertion.\n\n**Analysis of Divide and Conquer (DC) Implementation and Failure Modes**\n\nThe DC strategy (like Hirschberg's algorithm) is designed to find the exact same optimal alignment path as the standard quadratic-space dynamic programming algorithm, but using only linear memory space. It does this by recursively finding the midpoint of an optimal path and splitting the problem.\n\n1.  **Failure Mode 1: Non-uniqueness of Optimal Path:** In a repetitive region like $u^k$, the dynamic programming matrix contains large \"plateaus\" where many different alignment paths yield the exact same optimal score. For example, aligning `ATATAT` with `ATATAT`, a shift in the alignment of one `AT` unit can be compensated for elsewhere, leading to multiple degenerate optimal paths. The DC algorithm finds *a* midpoint on *an* optimal path. If multiple such midpoints exist (due to multiple optimal paths), the choice is arbitrary. This can lead to a reconstructed alignment path that, while having the correct optimal score, does not reflect the simple biological event of a single insertion. The traceback may appear as a complex mix of short matches and indels, making it difficult to reliably infer the true repeat count $\\Delta$. This is a well-known issue in low-complexity or repetitive regions.\n\n2.  **Failure Mode 2: Banded Alignment Variants:** In practice, for long sequences, DC algorithms are often combined with a \"banding\" heuristic to reduce computation time from $O(mn)$ to $O(m \\cdot w)$, where $w$ is the band width. This constrains the search for the optimal path to a narrow band around the main diagonal of the DP matrix. A tandem repeat expansion corresponds to a large net insertion, which causes the alignment path to deviate significantly from the diagonal (specifically, a long vertical segment). If the expansion is large, such that $\\Delta \\cdot \\ell$ exceeds the constraints imposed by the band width, the true optimal path will lie outside the band. The algorithm will fail to find it and instead return an incorrect, suboptimal alignment that remains within the band.\n\n**Evaluation of Options**\n\n-   **A. It will represent the expansion as a single long insertion relative to the reference between the conserved flanks $\\alpha$ and $\\beta$, because an affine gap cost favors one long gap over many small gaps; practical failures arise when the optimal path’s midpoint falls inside a long, low-complexity repeat with many equally scoring paths, making the split (and thus the traceback and inferred repeat count) non-unique, and when a banded DC variant is used, if the true path leaves the band due to a large net indel.**\n    This statement is perfectly aligned with the derivation. It correctly identifies the behavior dictated by the affine gap model. It also accurately describes two critical and common failure modes of DC-based alignment in this context: the non-uniqueness of the optimal path in repetitive regions and the failure of banded variants when the indel size is too large.\n    **Verdict: Correct.**\n\n-   **B. It will distribute the expansion across many short gaps to balance penalties across the repeat copies; failures occur only when the repeat unit has odd length $\\ell$, because even-length units can be perfectly tiled.**\n    This is incorrect. As derived, the affine gap cost model ($G  0$) actively penalizes multiple gaps and favors a single long one. The claim about odd versus even length $\\ell$ is nonsensical and has no basis in the principles of sequence alignment. The tiling of units is irrelevant to the gap penalty structure.\n    **Verdict: Incorrect.**\n\n-   **C. Before alignment, it compresses both sequences using run-length encoding of $u$ and aligns in the compressed domain; failures occur if the compression ratio differs between $S$ and $R$, which prevents consistent decoding of the alignment.**\n    This describes a specialized, non-standard algorithm. The problem specifies a \"standard global alignment algorithm\" implemented with DC. Standard algorithms like Needleman-Wunsch or Hirschberg operate directly on the character sequences, not on a compressed representation.\n    **Verdict: Incorrect.**\n\n-   **D. It produces a unique optimal alignment that always pins down the exact number of repeated units inside the expansion from the dynamic programming traceback; failures occur only when the sequencing error rate exceeds a fixed threshold, regardless of repeat length or structure.**\n    This statement is incorrect on multiple fronts. First, the optimal alignment *path* is often not unique in repetitive regions, so it cannot \"always pin down the exact number\". Second, failures are not *only* due to sequencing errors. The structural nature of the repeats and algorithmic heuristics like banding are fundamental sources of failure, even with perfect, error-free sequences as given in this problem.\n    **Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}