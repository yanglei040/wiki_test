{
    "hands_on_practices": [
        {
            "introduction": "基因表达是一个精确调控的过程，依赖于DNA上各功能元件的正确排列。就像一本书的章节必须按顺序排列才能讲述一个连贯的故事一样，基因的启动子、核糖体结合位点和编码序列也必须遵循严格的逻辑顺序。这项练习  将挑战你诊断一个常见的基因构建设计错误，从而加深对转录和翻译流程中每个元件核心作用的理解。",
            "id": "2058155",
            "problem": "一位合成生物学的学生正在设计一个基因构建体，用于在原核生物*大肠杆菌* (*Escherichia coli*)中表达绿色荧光蛋白（GFP）。目标是让细菌产生GFP，从而在紫外光下发光。在原核生物中进行表达，一个典型的功能性基因盒在DNA上需要几个关键元件，并按特定顺序排列。这些元件包括：\n\n-   **启动子**（Promoter）：一个招募RNA聚合酶以启动转录的DNA区域。\n-   **核糖体结合位点**（RBS）：DNA上的一个序列，当被转录成信使RNA（mRNA）时，作为核糖体结合以启动翻译的位点。\n-   **编码序列**（CDS）：编码蛋白质氨基酸序列的DNA序列。它以一个起始密码子开始，以一个终止密码子结束。\n-   **终止子**（Terminator）：一个标志转录结束的DNA序列。\n\n该学生按照以下元件排列方式组装了DNA构建体（从编码链的5'端到3'端读取）：\n\nRBS -> 启动子 -> CDS (GFP的) -> 终止子\n\n将此构建体导入*大肠杆菌*后，学生观察到菌落不发荧光，表明未能产生GFP蛋白。以下哪个陈述为这一结果提供了最准确和最主要的原因？\n\nA. 终止子序列位置不正确，这将导致核糖体过早地从mRNA上解离。\n\nB. 启动子上游的RBS序列会物理性地阻碍RNA聚合酶与启动子区域的结合。\n\nC. 由此构建体产生的mRNA转录本将不包含RBS序列，从而阻止核糖体结合和启动翻译。\n\nD. 转录将无法正常终止，导致产生不稳定、过长的mRNA分子，并被迅速降解。\n\nE. CDS内的起始密码子将被转录但不会被翻译，因为启动子序列不包含在mRNA中。",
            "solution": "在细菌的基因表达中，DNA上各元件的功能顺序必须是 启动子 → RBS → CDS → 终止子，才能进行正常的转录和翻译。启动子是一个招募RNA聚合酶并确定转录起始位点的DNA元件；关键在于，启动子序列不会被转录到mRNA中。核糖体结合位点（例如，Shine-Dalgarno序列）必须位于mRNA上起始密码子的上游，以便招募核糖体并将其正确定位以启动翻译。因此，RBS必须位于DNA上启动子的下游，这样它才会被包含在转录出的mRNA中。\n\n根据学生构建体的顺序：RBS → 启动子 → CDS → 终止子，从启动子开始的转录将产生一个包含CDS和源自终止子序列的mRNA，但不包括位于上游的RBS。因此，该mRNA缺少RBS，阻止了核糖体的结合和翻译的起始，所以没有GFP产生。\n\n逐一评估选项：\n- A是错误的，因为终止子影响的是转录终止，而不是翻译过程中核糖体的解离。\n- B是错误的，因为位于启动子上游的RBS不会物理性地阻碍RNA聚合酶与启动子的结合。\n- C是正确的，因为将RBS错误地置于启动子上游，导致它无法被包含在mRNA中，从而使翻译无法起始。\n- D是错误的，因为根据给定的排列方式，没有理由预期转录终止会失败。\n- E是错误的，因为启动子通常不包含在mRNA中，并且它在mRNA中的缺失不会阻止翻译；关键的缺失元件是mRNA上的RBS。\n\n因此，最主要的原因是mRNA缺少RBS，从而阻止了翻译的起始。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在确保基因元件顺序正确之后，下一步是精确调控蛋白质的产量。核糖体结合位点（RBS）是控制翻译起始效率的关键“旋钮”。这项练习  引入了一个简化的生物物理模型来量化RBS的强度，让你亲手计算序列的微小变化如何显著影响最终的蛋白质产量，从而揭示序列与功能之间的定量关系。",
            "id": "2058220",
            "problem": "一位合成生物学学生正在设计一个*大肠杆菌* (*Escherichia coli*)中的基因线路，以控制绿色荧光蛋白 (GFP) 的表达。蛋白质的表达水平关键取决于翻译起始的效率，而翻译起始效率由核糖体与信使RNA (mRNA) 分子上的核糖体结合位点 (RBS) 的结合所决定。这种结合通过RBS与16S核糖体RNA (rRNA) 上的一个互补序列（称为anti-Shine-Dalgarno (anti-SD) 序列）之间的碱基配对发生。\n\n为了量化和预测RBS的强度，该学生使用了一个简化的生物物理模型，该模型会给出一个翻译起始分数 (TIS)。该模型假设表达蛋白的最终稳态浓度与其TIS成正比。TIS是通过将9个核苷酸的RBS与9个核苷酸的anti-SD序列之间每个碱基对相互作用的分数相加来计算的。*大肠杆菌*中的anti-SD序列是 `3'-AUUCCUCCA-5'`。\n\n每个位置上碱基配对相互作用的评分规则如下：\n- G-C 碱基对：+2.0 分\n- A-U 碱基对：+1.5 分\n- G-U 摆动碱基对：+0.5 分\n- 任何其他组合（错配）：-1.0 分\n\n该学生首先考虑使用能提供最大表达的共有Shine-Dalgarno序列。这个“野生型”RBS序列是：\n`5'-UAAGGAGGU-3'`\n\n为了创建一个表达量较低的版本，该学生通过引入两个核苷酸变化设计了一个“突变型”RBS。这个突变型RBS的序列是：\n`5'-UACGGGGGU-3'`\n\n假设该模型是准确的，并且对于两种构建体，所有其他因素（如转录速率和降解速率）都相同，计算使用突变型RBS与野生型RBS相比，最终稳态GFP浓度的分数减少量。答案以小数形式表示，并四舍五入到三位有效数字。",
            "solution": "核糖体-mRNA的配对是反向平行的，因此 $5'$–$3'$ RBS 的每个位置都与 $3'$–$5'$ anti-SD 的相应位置配对。设 anti-SD 为 $3'$–AUUCCUCCA–$5'$，并将翻译起始分数 (TIS) 定义为每个位置分数的总和，其中 G–C 得 $+2.0$ 分，A–U 得 $+1.5$ 分，G–U 得 $+0.5$ 分，任何错配得 $-1.0$ 分。\n\n对于与 anti-SD 对齐的野生型 RBS $5'$–UAAGGAGGU–$3'$：\n- 位置 $1,2,3,6,9$：A–U 配对，每个 $+1.5$ 分。\n- 位置 $4,5,7,8$：G–C 配对，每个 $+2.0$ 分。\n因此，\n$$\n\\mathrm{TIS}_{\\mathrm{wt}} = 5 \\times 1.5 + 4 \\times 2.0 = 7.5 + 8.0 = 15.5\n$$\n\n对于与 anti-SD 对齐的突变型 RBS $5'$–UACGGGGGU–$3'$：\n- 位置 $1,2,9$：A–U 配对，每个 $+1.5$ 分。\n- 位置 $4,5,7,8$：G–C 配对，每个 $+2.0$ 分。\n- 位置 $6$：G–U 摆动配对，$+0.5$ 分。\n- 位置 $3$：C–U 错配，$-1.0$ 分。\n因此，\n$$\n\\mathrm{TIS}_{\\mathrm{mut}} = 3 \\times 1.5 + 4 \\times 2.0 + 0.5 - 1.0 = 4.5 + 8.0 + 0.5 - 1.0 = 12.0\n$$\n\n由于稳态 GFP 浓度与 TIS 成正比，使用突变型相对于野生型的分数减少量为\n$$\nf=\\frac{\\mathrm{TIS}_{\\mathrm{wt}}-\\mathrm{TIS}_{\\mathrm{mut}}}{\\mathrm{TIS}_{\\mathrm{wt}}}\n=\\frac{15.5-12.0}{15.5}=\\frac{3.5}{15.5}=\\frac{7}{31}\\approx 0.225806\\ldots\n$$\n四舍五入到三位有效数字，结果是 $0.226$。",
            "answer": "$$\\boxed{0.226}$$"
        },
        {
            "introduction": "掌握了单个基因元件的分析后，我们可以将视野扩展到基因组规模的调控信息解码。启动子是决定基因是否及何时被转录的关键区域，其序列特征在不同生命域中有所区别。这项高级练习  要求你实现一个算法，根据典型的基序（motif）来区分细菌和古菌的启动子，这体现了计算生物学在解析基因组调控密码中的强大应用。",
            "id": "2419472",
            "problem": "您将执行一项基于原核生物启动子结构的二元分类任务。在细菌（Bacteria）中，启动子通常包含一个 $-35$ 盒和一个 $-10$ 盒，通常由共有六聚体 $TTGACA$ 和 $TATAAT$ 近似表示，其起始位点间的偏移量接近 $17$。在古菌（Archaea）中，启动子通常包含一个 TATA 盒（此处简化为六聚体家族 $TATAWA$，其中 $W \\in \\{A,T\\}$）。您的任务是编写一个程序，对于每个给定的脱氧核糖核酸（DNA）序列（字母表为 $\\Sigma=\\{A,C,G,T\\}$），根据下文基于基序的定义，预测其更符合古菌启动子（标签 $1$）还是细菌启动子（标签 $0$）。\n\n定义：\n\n1. 基序表示。每个基序由一个位置特异性概率矩阵（也称位置权重矩阵）表示，即在每个位置上基于 $\\{A,C,G,T\\}$ 的一个概率分布。对于一个长度为 $\\ell$ 的基序，在特定起始位置观察到特定 $\\ell$-mer $x_{1:\\ell}$ 的概率定义为乘积 $\\prod_{p=1}^{\\ell} P(x_p \\mid \\text{基序位置 } p)$。为了数值稳定性和可比性，定义一个 $\\ell$-mer 在某个基序下的单位位置平均对数似然为：\n$$\nS(x_{1:\\ell}) = \\frac{1}{\\ell} \\sum_{p=1}^{\\ell} \\log P(x_p \\mid \\text{基序位置 } p)\n$$\n其中 $\\log$ 表示自然对数。\n\n2. 细菌启动子模型。它由两个六聚体基序组成：\n   - 共有序列为 $TTGACA$ 的 $-35$ 盒。\n   - 共有序列为 $TATAAT$ 的 $-10$ 盒。\n对于这两个基序中的每一个，在每个位置 $p \\in \\{1,2,3,4,5,6\\}$，共有核苷酸的概率为 $0.8$，每个非共有核苷酸的概率为 $0.06666666666666667$（因此每个位置的概率总和为 $1.0$）。当一个 $-35$ 盒起始于索引 $i$ 且一个 $-10$ 盒起始于索引 $j$，满足 $j-i \\in \\{16,17,18\\}$，并且两个基序都完全包含在序列边界内时，序列中就出现了一个细菌启动子实例。一个特定细菌实例的得分是这两个六聚体上单位位置对数似然的平均值，即：\n$$\nS_{\\text{bact}}(i,j) = \\frac{1}{12} \\Bigg( \\sum_{p=1}^{6} \\log P_{-35}(x_{i+p-1},p) + \\sum_{p=1}^{6} \\log P_{-10}(x_{j+p-1},p) \\Bigg)\n$$\n一个序列的细菌模型得分是 $S_{\\text{bact}}(i,j)$ 在所有满足 $j-i \\in \\{16,17,18\\}$ 的有效 $(i,j)$ 对上的最大值。\n\n3. 古菌启动子模型。它由一个具有共有模式 $TATAWA$ 的单一六聚体 TATA 盒基序组成。在位置 $p \\in \\{1,2,3,4,6\\}$，共有核苷酸的概率为 $0.8$，每个非共有核苷酸的概率为 $0.06666666666666667$。在位置 $p=5$，概率为 $P(A)=0.4$, $P(T)=0.4$, $P(C)=0.1$, $P(G)=0.1$。一个古菌启动子实例起始于任何索引 $k$，只要该六聚体完全包含在序列边界内即可。其得分为：\n$$\nS_{\\text{arch}}(k) = \\frac{1}{6} \\sum_{p=1}^{6} \\log P_{\\text{TATA}}(x_{k+p-1},p)\n$$\n一个序列的古菌模型得分是 $S_{\\text{arch}}(k)$ 在所有有效 $k$ 上的最大值。\n\n4. 分类规则。对于每个序列，计算其细菌模型得分（在有效配对中的最大平均对数似然）和其古菌模型得分（在有效起始位点中的最大平均对数似然）。如果古菌模型得分严格大于细菌模型得分，且差值至少为一个容差 $\\epsilon = 10^{-12}$，则输出整数 $1$。如果细菌模型得分超过古菌模型得分，且差值至少为 $\\epsilon$，则输出整数 $0$。如果绝对差值小于 $\\epsilon$，则输出整数 $0$。\n\n输入数据（测试套件）：\n\n您必须对以下 DNA 序列进行分类（每个都是 $\\{A,C,G,T\\}$ 上的单个连续字符串）：\n\n- 案例 1（典型的细菌启动子，具有 $-35/-10$ 配对且间距接近 $17$）：\n  \"ACGTATTGACAGCCGAGTTCGATATAATGCGTACCGTAGCGTGATCGGCTAACGTCG\"\n\n- 案例 2（典型的古菌启动子，具有显著的 TATA 盒实例）：\n  \"GCGGATCGTCTATAAATATATAAGCCGATCGATCGTACG\"\n\n- 案例 3（包含 $-35$ 和 $-10$ 盒，但间距不符合要求；包含 TATA 盒信号）：\n  \"AAACTTGACAGGGGGTATAATCCCCCTATAAAGGGG\"\n\n- 案例 4（边界情况，没有清晰的基序；富含 GC 的背景）：\n  \"GCGCGGCGGCCGCGGCGCCGCGGCGCCGCGGCG\"\n\n- 案例 5（类似细菌启动子，在 $-10$ 盒中存在一个单碱基突变，且间距符合要求）：\n  \"TTTATTTGACACCCCCCCCCCCTATGATAAAAAAAAAAA\"\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须为每个案例包含一个整数，顺序与上述相同。例如，五个案例的有效输出形式为“[a,b,c,d,e]”，其中 a,b,c,d,e 的值均为 $0$ 或 $1$。",
            "solution": "所述问题是有效的。这是一个基于分子生物学中计算基序发现的既定原则、定义明确且有科学依据的分类任务。序列模型、评分函数和分类规则的定义清晰明确且数学上精确。我们将着手提供一个解决方案。\n\n任务是将给定的脱氧核糖核酸（DNA）序列（字母表为 $\\Sigma=\\{A,C,G,T\\}$）分类，判断其更符合细菌启动子模型（标签 $0$）还是古菌启动子模型（标签 $1$）。分类决策基于分数的比较，每个分数代表相应模型下序列片段的最大单位位置平均对数似然。\n\n首先，我们通过为给定的基序构建位置特异性概率矩阵（PSPM）来形式化模型。为了数值稳定性和计算便利性，我们将使用这些概率的自然对数，从而形成对数-PSPM。定义一个字母表映射为 $\\{'A':0, 'C':1, 'G':2, 'T':3\\}$。共有核苷酸的概率为 $P_{cons} = 0.8$，而三种非共有核苷酸中每一种的概率为 $P_{non-cons} = (1 - P_{cons})/3 = 1/15$。\n\n细菌模型涉及两个六聚体基序：\n1.  共有序列为 $TTGACA$ 的 $-35$ 盒。\n2.  共有序列为 $TATAAT$ 的 $-10$ 盒。\n\n这两个 $6 \\times 4$ 矩阵中每一个的对数-PSPM是通过将 $\\log(0.8)$ 分配给每个位置上对应共有核苷酸的矩阵条目，并将 $\\log(1/15)$ 分配给非共有核苷酸的条目来构建的。\n\n古菌模型使用一个具有共有序列 $TATAWA$ 的单一六聚体 TATA 盒基序。\n该基序的对数-PSPM 的构建方式类似，但位置 $5$（对应‘W’，意为‘A’或‘T’）除外。在此位置，指定的概率为 $P(A)=0.4$，$P(T)=0.4$，$P(C)=0.1$ 和 $P(G)=0.1$。相应的对数概率用于 TATA 盒对数-PSPM 的第五行。\n\n定义了对数-PSPM 后，我们设计算法来计算每个模型的分数。\n\n为计算给定长度为 $L$ 的 DNA 序列的古菌模型得分 $S_A$：\n我们必须在 TATA 盒基序的所有可能实例中找到最高分。一个实例可以从任何索引 $k$ 开始，只要该六聚体包含在序列内，即 $k \\in \\{0, 1, \\dots, L-6\\}$。\n起始于 $k$ 的实例（对应于子序列 $x_{k:k+6}$）的得分由以下公式给出：\n$$S_{\\text{arch}}(k) = \\frac{1}{6} \\sum_{p=1}^{6} \\log P_{\\text{TATA}}(x_{k+p-1}, p)$$\n我们将最大得分变量 $S_{A,max}$ 初始化为 $-\\infty$。然后，我们从 $0$到 $L-6$ 迭代 $k$。在每次迭代中，我们通过对从 $k$ 开始的 6-mer，对 TATA 盒对数-PSPM 中相应的对数概率求和来计算 $S_{\\text{arch}}(k)$。我们更新 $S_{A,max} = \\max(S_{A,max}, S_{\\text{arch}}(k))$。如果序列长度 $L  6$，则不可能有实例，得分保持为 $-\\infty$。序列的最终古菌得分为 $S_A = S_{A,max}$。\n\n为计算长度为 $L$ 的序列的细菌模型得分 $S_B$：\n我们必须在所有有效间距的 $-35$ 和 $-10$ 盒配对中找到最高分。一个细菌启动子实例由 $-35$ 盒和 $-10$ 盒的一对起始索引 $(i,j)$ 定义，其中间距约束 $j-i \\in \\{16, 17, 18\\}$ 成立。两个基序都必须完全包含在序列内。\n特定配对 $(i,j)$ 的得分为：\n$$S_{\\text{bact}}(i,j) = \\frac{1}{12} \\left( \\sum_{p=1}^{6} \\log P_{-35}(x_{i+p-1}, p) + \\sum_{p=1}^{6} \\log P_{-10}(x_{j+p-1}, p) \\right)$$\n我们将最大得分变量 $S_{B,max}$ 初始化为 $-\\infty$。我们遍历 $-35$ 盒所有可能的起始索引 $i$。对于每个 $i$，我们遍历允许的间距 $d \\in \\{16, 17, 18\\}$。我们计算 $-10$ 盒的相应起始索引 $j=i+d$。然后我们检查从 $i$ 和 $j$ 开始的两个基序是否都在序列边界内（即 $i+6 \\le L$ 和 $j+6 \\le L$）。如果配对有效，我们通过对相应对数-PSPM 的对数概率求和并除以总长度 $12$ 来计算 $S_{\\text{bact}}(i,j)$。我们更新 $S_{B,max} = \\max(S_{B,max}, S_{\\text{bact}}(i,j))$。如果不存在有效的配对 $(i,j)$，得分保持为 $-\\infty$。序列的最终细菌得分为 $S_B = S_{B,max}$。\n\n最后，应用分类规则。给定计算出的得分 $S_A$ 和 $S_B$ 以及容差 $\\epsilon = 10^{-12}$：\n- 如果 $S_A > S_B + \\epsilon$，序列被分类为古菌，输出为 $1$。\n- 否则（即，如果 $S_B \\ge S_A - \\epsilon$），序列被分类为细菌，输出为 $0$。这种情况正确地包括了 $S_B$ 显著大于 $S_A$ 的情况，以及它们的绝对差值小于或等于 $\\epsilon$ 的情况。\n\n整个过程在一个单独的程序中实现，该程序处理提供的测试案例并以指定格式输出分类结果。使用 NumPy 可以高效地进行基于向量的基序得分计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the prokaryotic promoter classification problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"ACGTATTGACAGCCGAGTTCGATATAATGCGTACCGTAGCGTGATCGGCTAACGTCG\",\n        \"GCGGATCGTCTATAAATATATAAGCCGATCGATCGTACG\",\n        \"AAACTTGACAGGGGGTATAATCCCCCTATAAAGGGG\",\n        \"GCGCGGCGGCCGCGGCGCCGCGGCGCCGCGGCG\",\n        \"TTTATTTGACACCCCCCCCCCCTATGATAAAAAAAAAAA\",\n    ]\n\n    # --- Model and Algorithm Implementation ---\n\n    # Define base mapping to indices for matrix lookup\n    base_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    \n    def create_log_pspm(consensus, special_pos=None):\n        \"\"\"\n        Creates a log-Position Specific Probability Matrix (log-PSPM).\n        \n        Args:\n            consensus (str): The consensus sequence for the motif.\n            special_pos (dict): A dictionary for positions with special probabilities.\n                                Format: {pos_index: {'A':p, 'C':p, 'G':p, 'T':p}}\n        \n        Returns:\n            np.ndarray: A 6x4 numpy array of log-probabilities.\n        \"\"\"\n        motif_len = len(consensus)\n        log_pspm = np.zeros((motif_len, 4))\n        \n        p_cons = 0.8\n        p_non_cons = (1.0 - p_cons) / 3.0\n        \n        lp_cons = np.log(p_cons)\n        lp_non_cons = np.log(p_non_cons)\n\n        base_to_vec = {\n            'A': np.array([lp_cons, lp_non_cons, lp_non_cons, lp_non_cons]),\n            'C': np.array([lp_non_cons, lp_cons, lp_non_cons, lp_non_cons]),\n            'G': np.array([lp_non_cons, lp_non_cons, lp_cons, lp_non_cons]),\n            'T': np.array([lp_non_cons, lp_non_cons, lp_non_cons, lp_cons]),\n        }\n\n        for i, base in enumerate(consensus):\n            if special_pos and i in special_pos:\n                probs = special_pos[i]\n                log_pspm[i, :] = np.log(np.array([probs['A'], probs['C'], probs['G'], probs['T']]))\n            else:\n                log_pspm[i, :] = base_to_vec[base]\n                \n        return log_pspm\n\n    # Create log-PSPMs for all motifs\n    log_pspm_35 = create_log_pspm(\"TTGACA\")\n    log_pspm_10 = create_log_pspm(\"TATAAT\")\n    \n    # Special probabilities for the 'W' at position 5 (0-indexed 4) of TATAWA\n    tata_special = {4: {'A': 0.4, 'T': 0.4, 'C': 0.1, 'G': 0.1}}\n    log_pspm_tata = create_log_pspm(\"TATAWA\", tata_special)\n    \n    def get_archaeal_score(sequence, log_pspm, base_map):\n        \"\"\"Calculates the maximum archaeal model score for a sequence.\"\"\"\n        seq_len = len(sequence)\n        motif_len = 6\n        if seq_len  motif_len:\n            return -np.inf\n            \n        max_score = -np.inf\n        \n        indices = np.array([base_map[b] for b in sequence], dtype=int)\n        \n        for k in range(seq_len - motif_len + 1):\n            subseq_indices = indices[k : k + motif_len]\n            # Sum of log-probabilities for the 6-mer\n            current_sum_log_p = log_pspm[np.arange(motif_len), subseq_indices].sum()\n            # Per-position average log-likelihood\n            current_score = current_sum_log_p / motif_len\n            if current_score > max_score:\n                max_score = current_score\n        \n        return max_score\n\n    def get_bacterial_score(sequence, log_pspm35, log_pspm10, base_map):\n        \"\"\"Calculates the maximum bacterial model score for a sequence.\"\"\"\n        seq_len = len(sequence)\n        motif_len = 6\n        spacings = [16, 17, 18]\n        \n        # Minimum length required for a valid pair with max spacing\n        if seq_len  motif_len + spacings[-1] + motif_len:\n            # Check if any smaller spacing is possible\n            if seq_len  motif_len + spacings[0] + motif_len:\n                 return -np.inf\n\n        max_score = -np.inf\n\n        indices = np.array([base_map[b] for b in sequence], dtype=int)\n\n        for i in range(seq_len - motif_len + 1):\n            sum_log_p_35 = log_pspm35[np.arange(motif_len), indices[i:i+motif_len]].sum()\n            \n            for d in spacings:\n                j = i + d\n                if j + motif_len = seq_len:\n                    sum_log_p_10 = log_pspm10[np.arange(motif_len), indices[j:j+motif_len]].sum()\n                    \n                    # Total average log-likelihood over 12 positions\n                    current_score = (sum_log_p_35 + sum_log_p_10) / (2 * motif_len)\n                    if current_score > max_score:\n                        max_score = current_score\n        \n        return max_score\n\n    # --- Main Classification Loop ---\n    \n    results = []\n    epsilon = 1e-12\n\n    for seq in test_cases:\n        s_arch = get_archaeal_score(seq, log_pspm_tata, base_map)\n        s_bact = get_bacterial_score(seq, log_pspm_35, log_pspm_10, base_map)\n        \n        if s_arch > s_bact + epsilon:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}