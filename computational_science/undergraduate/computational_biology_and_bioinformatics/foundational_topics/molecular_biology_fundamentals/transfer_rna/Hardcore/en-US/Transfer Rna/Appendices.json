{
    "hands_on_practices": [
        {
            "introduction": "The process of protein synthesis relies on the precise recognition of messenger RNA (mRNA) codons by the anticodons of transfer RNA (tRNA). This exercise  explores the \"wobble hypothesis,\" a key principle that explains the degeneracy of the genetic code. By working through this problem, you will apply the specific pairing rules for the modified base inosine ($I$) to determine how a single tRNA can decode multiple codons, a crucial feature for translational efficiency.",
            "id": "1523836",
            "problem": "The genetic code is read by pairing the codons of a messenger RNA (mRNA) with the anticodons of a transfer RNA (tRNA). This pairing occurs in an antiparallel fashion. The first two positions of the codon pair with the last two positions of the anticodon according to standard Watson-Crick base pairing rules (A with U, G with C). However, the pairing between the third position of the codon (at the 3' end) and the first position of the anticodon (at the 5' end) is less strict, a phenomenon known as \"wobble.\"\n\nA special modified base, inosine (I), is sometimes found at the first position of the tRNA anticodon. Due to its unique structure, inosine at this \"wobble\" position can form hydrogen bonds with adenine (A), cytosine (C), or uracil (U) on the mRNA codon. It cannot pair with guanine (G).\n\nGiven a tRNA molecule with the anticodon 5'-IGU-3', identify all the possible mRNA codons it can recognize from the list below.\n\nA. 5'-ACA-3'\n\nB. 5'-ACG-3'\n\nC. 5'-ACU-3'\n\nD. 5'-ACC-3'\n\nE. 5'-GCA-3'\n\nF. 5'-UCA-3'\n\nSelect all the correct options.",
            "solution": "The codon-anticodon interaction is antiparallel, with strict Watson-Crick pairing at codon positions 1 and 2 (5' to 3') to anticodon positions 3 and 2 (3' to 5'), and wobble pairing at codon position 3 to anticodon position 1.\n\nLet the mRNA codon be written as $5'$-$b_{1}b_{2}b_{3}$-$3'$. The given anticodon is $5'$-IGU-$3'$, which, when written antiparallel for base pairing, is $3'$-UGI-$5'$.\n\nApplying pairing rules:\n- At codon position $1$, $b_{1}$ pairs with anticodon U (strict), so $b_{1}=A$.\n- At codon position $2$, $b_{2}$ pairs with anticodon G (strict), so $b_{2}=C$.\n- At codon position $3$, $b_{3}$ pairs with anticodon I (wobble), and inosine pairs with $A$, $C$, or $U$, but not $G$, so $b_{3}\\in\\{A,C,U\\}$.\n\nTherefore, the recognized codons are $5'$-ACA-$3'$, $5'$-ACC-$3'$, and $5'$-ACU-$3'$. From the provided options, these correspond to A, D, and C, respectively. Options B (ends with G), E (starts with G), and F (starts with U) do not satisfy the required pairings.",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "For translation to be accurate, each transfer RNA (tRNA) must be charged with its correct amino acid, a task performed by highly specific enzymes called aminoacyl-tRNA synthetases. This classic thought experiment  delves into the concept of \"tRNA identity,\" forcing you to consider which features of a tRNA molecule a synthetase actually recognizes. Understanding that crucial identity elements often exist outside the anticodon is essential for appreciating the fidelity of the entire protein synthesis system.",
            "id": "2346065",
            "problem": "In a molecular biology laboratory, a team is investigating the specificity of protein synthesis machinery. They perform a genetic engineering experiment on the gene encoding the transfer RNA for Alanine ($\\text{tRNA}^{\\text{Ala}}$). Using site-directed mutagenesis, they precisely alter the three nucleotides of the anticodon, changing them from the Alanine anticodon (5'-IGC-3', where I is Inosine) to the Glycine anticodon (5'-UCC-3'). All other regions of the tRNA molecule, including the acceptor stem, remain identical to the original $\\text{tRNA}^{\\text{Ala}}$.\n\nThis synthetic, chimeric tRNA is then placed in a controlled *in vitro* reaction mixture. The mixture contains all necessary components for tRNA charging, including an abundance of both Alanine and Glycine amino acids, as well as the full complement of functional aminoacyl-tRNA synthetases (aaRS), specifically including Alanyl-tRNA synthetase (AlaRS) and Glycyl-tRNA synthetase (GlyRS).\n\nWhich of the following statements most accurately predicts the fate of this chimeric tRNA in the reaction mixture?\n\nA. The chimeric tRNA will be exclusively charged with Glycine, as the anticodon is the primary and sole determinant for recognition by the correct aminoacyl-tRNA synthetase.\n\nB. The chimeric tRNA will be exclusively charged with Alanine, because critical recognition sites for the Alanine-tRNA synthetase exist outside of the anticodon loop.\n\nC. The chimeric tRNA will be charged with both Alanine and Glycine in approximately equal amounts, as the conflicting recognition signals will lead to non-specific charging by both synthetases.\n\nD. The chimeric tRNA will not be charged with any amino acid, because the contradictory features will prevent recognition by either the Alanine-tRNA synthetase or the Glycine-tRNA synthetase.\n\nE. The chimeric tRNA will be recognized by the ribosome but will fail to deliver an amino acid, causing translation to stall.",
            "solution": "The aminoacylation (charging) of a tRNA is determined by identity elements recognized by its cognate aminoacyl-tRNA synthetase (aaRS). While some aaRSs use the anticodon as a major identity determinant, many rely primarily on sequence and structural elements elsewhere, especially in the acceptor stem and the discriminator base.\n\nFor $\\text{tRNA}^{\\text{Ala}}$, the principal and historically well-defined identity determinant resides in the acceptor stem: the wobble base pair G3-U70. This single base pair is both necessary and sufficient for recognition by Alanyl-tRNA synthetase (AlaRS). Experimental evidence shows that:\n- Transplanting the G3-U70 pair into non-alanine tRNAs confers alanine charging by AlaRS.\n- Mutating G3-U70 in $\\text{tRNA}^{\\text{Ala}}$ abolishes alanine charging.\n- The anticodon of $\\text{tRNA}^{\\text{Ala}}$ is largely dispensable for recognition and charging by AlaRS.\n\nIn the engineered tRNA described, only the anticodon has been changed from the alanine anticodon to the glycine anticodon. All other regions, including the acceptor stem, remain identical to native $\\text{tRNA}^{\\text{Ala}}$. Therefore:\n1. AlaRS will still recognize the unchanged alanine identity elements (notably the G3-U70 base pair) in the acceptor stem and will charge this tRNA with alanine.\n2. Glycyl-tRNA synthetase (GlyRS) relies on glycine tRNA identity elements that include features outside the anticodon; since these are absent in this chimeric tRNA, GlyRS will not efficiently recognize or charge it, despite the presence of a glycine anticodon.\n3. Because aminoacylation specificity is dictated by the synthetaseâ€“tRNA interaction rather than by the anticodon alone, changing only the anticodon will not redirect charging to glycine.\n\nConsequently, the chimeric tRNA will be exclusively charged with alanine. Options proposing exclusive glycine charging (A), mixed charging (C), no charging (D), or ribosomal stalling without aminoacylation (E) contradict the established identity rules for $\\text{tRNA}^{\\text{Ala}}$ and the known dispensability of its anticodon for AlaRS recognition.\n\nThus, the correct prediction is that the chimeric tRNA will be charged with alanine due to recognition by AlaRS via identity elements outside the anticodon loop.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "The remarkable accuracy of protein synthesis is not just a matter of initial recognition, but also of active error correction. This exercise  allows you to computationally model the process of kinetic proofreading, a mechanism used by many aminoacyl-tRNA synthetases to ensure charging fidelity. By analyzing a simple kinetic scheme, you will quantify how the presence or absence of a proofreading domain impacts the overall fidelity ($F$) of tRNA charging, bridging biological principles with mathematical and computational analysis.",
            "id": "2437899",
            "problem": "You are given a minimal kinetic model for charging of transfer RNA (tRNA) by an aminoacyl-tRNA synthetase (aaRS). The enzyme processes two classes of substrates: the cognate amino acid that yields correctly charged tRNA and a near-cognate amino acid that can yield mischarged tRNA. In this model, the net formation of aminoacyl-tRNA for the cognate and near-cognate pathways occurs with pseudo-first-order rates $r_C$ and $r_N$ (in $\\mathrm{s^{-1}}$), respectively, which subsume both concentration and catalytic efficiency differences. For correctly charged tRNA, there is no proofreading. For mischarged tRNA, a post-transfer proofreading domain hydrolyzes the misacylated product with a first-order rate $k_{\\mathrm{edit}}$ (in $\\mathrm{s^{-1}}$) that competes with product release at rate $k_{\\mathrm{rel}}$ (in $\\mathrm{s^{-1}}$). Assume steady-state and that editing acts only on mischarged tRNA.\n\nUnder these assumptions:\n- The probability that a mischarged tRNA escapes editing and is released as product is\n$$\nP_{\\mathrm{esc}} = \\frac{k_{\\mathrm{rel}}}{k_{\\mathrm{rel}} + k_{\\mathrm{edit}}}.\n$$\n- The steady-state release fluxes of correctly and incorrectly charged tRNA, when proofreading is present, are\n$$\nJ_C^{(+)} = r_C,\\quad J_N^{(+)} = r_N \\, P_{\\mathrm{esc}}.\n$$\n- If the proofreading domain is deleted computationally, take $k_{\\mathrm{edit}} = 0$ so that $P_{\\mathrm{esc}} = 1$, and the fluxes become\n$$\nJ_C^{(-)} = r_C,\\quad J_N^{(-)} = r_N.\n$$\nDefine the charging fidelity as the fraction of released aminoacyl-tRNA that is correctly charged:\n$$\nF^{(+)} = \\frac{J_C^{(+)}}{J_C^{(+)} + J_N^{(+)}},\\qquad\nF^{(-)} = \\frac{J_C^{(-)}}{J_C^{(-)} + J_N^{(-)}}.\n$$\nThe quantity of interest is the fidelity loss upon deletion of the proofreading domain, defined as\n$$\nL = F^{(+)} - F^{(-)}.\n$$\nAll rates $r_C$, $r_N$, $k_{\\mathrm{rel}}$, and $k_{\\mathrm{edit}}$ are provided in $\\mathrm{s^{-1}}$. Express all outputs as unitless decimal fractions.\n\nWrite a complete program that, for each test case below, computes $L$ using the definitions above and outputs the results rounded to exactly $6$ digits after the decimal point.\n\nTest suite (each case is a quadruple $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}})$, all in $\\mathrm{s^{-1}}$):\n- Case A: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,5,\\,0.05,\\,2,\\,10\\,)$.\n- Case B: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,5,\\,0.5,\\,1,\\,0\\,)$.\n- Case C: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,2,\\,0.2,\\,1,\\,100\\,)$.\n- Case D: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,1,\\,1.5,\\,0.5,\\,1\\,)$.\n- Case E: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,3,\\,0.03,\\,0.01,\\,0.01\\,)$.\n- Case F: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,4,\\,0.04,\\,100,\\,1\\,)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above. For example, a valid output line has the form $[\\ell_A,\\ell_B,\\ell_C,\\ell_D,\\ell_E,\\ell_F]$ where each $\\ell$ is $L$ rounded to exactly $6$ decimal places.",
            "solution": "We start from the definitions of the kinetic model. Let $r_C$ and $r_N$ denote the net formation rates (in $\\mathrm{s^{-1}}$) of correctly and incorrectly aminoacylated transfer RNA (tRNA), respectively, prior to any proofreading. For mischarged tRNA, proofreading by the editing domain and product release compete as first-order processes with rates $k_{\\mathrm{edit}}$ and $k_{\\mathrm{rel}}$ (in $\\mathrm{s^{-1}}$). Under steady-state and memoryless (exponential waiting time) assumptions, the probability that a mischarged tRNA escapes editing and is released as product is the probability that release occurs before editing in a race of two exponential clocks. For two independent exponential processes with rates $k_{\\mathrm{rel}}$ and $k_{\\mathrm{edit}}$, the probability that release occurs first is\n$$\nP_{\\mathrm{esc}} = \\frac{k_{\\mathrm{rel}}}{k_{\\mathrm{rel}} + k_{\\mathrm{edit}}}.\n$$\nFor correctly charged tRNA, assume no editing, so every formed correctly charged tRNA is released. Therefore, the steady-state fluxes of released products with proofreading present are\n$$\nJ_C^{(+)} = r_C,\\qquad J_N^{(+)} = r_N \\, P_{\\mathrm{esc}} = r_N \\, \\frac{k_{\\mathrm{rel}}}{k_{\\mathrm{rel}} + k_{\\mathrm{edit}}}.\n$$\nIf the proofreading domain is deleted, then $k_{\\mathrm{edit}} = 0$ and thus $P_{\\mathrm{esc}} = 1$. The fluxes become\n$$\nJ_C^{(-)} = r_C,\\qquad J_N^{(-)} = r_N.\n$$\nDefine fidelity as the fraction of released product that is correct:\n$$\nF^{(+)} = \\frac{J_C^{(+)}}{J_C^{(+)} + J_N^{(+)}} = \\frac{r_C}{r_C + r_N \\, \\frac{k_{\\mathrm{rel}}}{k_{\\mathrm{rel}} + k_{\\mathrm{edit}}}},\n$$\n$$\nF^{(-)} = \\frac{J_C^{(-)}}{J_C^{(-)} + J_N^{(-)}} = \\frac{r_C}{r_C + r_N}.\n$$\nThe fidelity loss due to deletion is\n$$\nL = F^{(+)} - F^{(-)}.\n$$\nThis expression is nonnegative because removing proofreading cannot increase fidelity under the stated assumptions. For each test case, we compute $P_{\\mathrm{esc}}$, then $F^{(+)}$ and $F^{(-)}$, and finally $L$, rounding the result to exactly $6$ digits after the decimal point.\n\nNow we evaluate the provided test suite:\n\n- Case A: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,5,\\,0.05,\\,2,\\,10\\,)$. Then $P_{\\mathrm{esc}} = \\frac{2}{2+10} = \\frac{1}{6} \\approx 0.166666666667$. Next $F^{(+)} = \\frac{5}{5 + 0.05 \\cdot \\frac{1}{6}} = \\frac{5}{5 + 0.008333333333} \\approx 0.998336106489$, and $F^{(-)} = \\frac{5}{5 + 0.05} = \\frac{5}{5.05} \\approx 0.990099009901$. Therefore $L \\approx 0.008237096588$, which rounds to $0.008237$.\n\n- Case B: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,5,\\,0.5,\\,1,\\,0\\,)$. Then $P_{\\mathrm{esc}} = \\frac{1}{1+0} = 1$. Thus $F^{(+)} = \\frac{5}{5+0.5} \\approx 0.909090909091$ and $F^{(-)} = \\frac{5}{5+0.5} \\approx 0.909090909091$, yielding $L \\approx 0$, which rounds to $0.000000$.\n\n- Case C: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,2,\\,0.2,\\,1,\\,100\\,)$. Then $P_{\\mathrm{esc}} = \\frac{1}{1+100} = \\frac{1}{101} \\approx 0.009900990099$. Next $F^{(+)} = \\frac{2}{2+0.2 \\cdot \\frac{1}{101}} = \\frac{2}{2+0.001980198020} \\approx 0.999009900990$, and $F^{(-)} = \\frac{2}{2+0.2} = \\frac{2}{2.2} \\approx 0.909090909091$. Therefore $L \\approx 0.089918991899$, which rounds to $0.089919$.\n\n- Case D: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,1,\\,1.5,\\,0.5,\\,1\\,)$. Then $P_{\\mathrm{esc}} = \\frac{0.5}{0.5+1} = \\frac{1}{3} \\approx 0.333333333333$. Next $F^{(+)} = \\frac{1}{1 + 1.5 \\cdot \\frac{1}{3}} = \\frac{1}{1+0.5} = \\frac{1}{1.5} \\approx 0.666666666667$, and $F^{(-)} = \\frac{1}{1+1.5} = \\frac{1}{2.5} = 0.4$. Therefore $L \\approx 0.266666666667$, which rounds to $0.266667$.\n\n- Case E: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,3,\\,0.03,\\,0.01,\\,0.01\\,)$. Then $P_{\\mathrm{esc}} = \\frac{0.01}{0.01+0.01} = 0.5$. Next $F^{(+)} = \\frac{3}{3 + 0.03 \\cdot 0.5} = \\frac{3}{3.015} \\approx 0.995024875622$, and $F^{(-)} = \\frac{3}{3+0.03} = \\frac{3}{3.03} \\approx 0.990099009901$. Therefore $L \\approx 0.004925865721$, which rounds to $0.004926$.\n\n- Case F: $(r_C, r_N, k_{\\mathrm{rel}}, k_{\\mathrm{edit}}) = (\\,4,\\,0.04,\\,100,\\,1\\,)$. Then $P_{\\mathrm{esc}} = \\frac{100}{100+1} \\approx 0.990099009901$. Next $F^{(+)} = \\frac{4}{4 + 0.04 \\cdot 0.990099009901} = \\frac{4}{4.039603960396} \\approx 0.990196078431$, and $F^{(-)} = \\frac{4}{4+0.04} = \\frac{4}{4.04} \\approx 0.990099009901$. Therefore $L \\approx 0.000097068530$, which rounds to $0.000097$.\n\nThe program will implement these computations exactly using floating-point arithmetic and produce a single line with the six rounded values in order $[L_A,L_B,L_C,L_D,L_E,L_F]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fidelity_loss(r_c: float, r_n: float, k_rel: float, k_edit: float) -> float:\n    \"\"\"\n    Compute fidelity loss L = F_with_edit - F_without_edit\n    given rates r_c, r_n, k_rel, k_edit (all in s^-1).\n    \"\"\"\n    # Probability that mischarged tRNA escapes editing when editing is present\n    p_escape_with = k_rel / (k_rel + k_edit) if (k_rel + k_edit) > 0.0 else 0.0\n    # Fluxes with editing\n    j_c_with = r_c\n    j_n_with = r_n * p_escape_with\n    denom_with = j_c_with + j_n_with\n    f_with = j_c_with / denom_with if denom_with > 0.0 else 0.0\n\n    # Fluxes without editing (k_edit = 0 -> p_escape = 1)\n    j_c_no = r_c\n    j_n_no = r_n\n    denom_no = j_c_no + j_n_no\n    f_no = j_c_no / denom_no if denom_no > 0.0 else 0.0\n\n    # Fidelity loss due to deletion\n    return f_with - f_no\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (r_C, r_N, k_rel, k_edit), all in s^-1.\n    test_cases = [\n        (5.0, 0.05, 2.0, 10.0),     # Case A\n        (5.0, 0.5, 1.0, 0.0),       # Case B\n        (2.0, 0.2, 1.0, 100.0),     # Case C\n        (1.0, 1.5, 0.5, 1.0),       # Case D\n        (3.0, 0.03, 0.01, 0.01),    # Case E\n        (4.0, 0.04, 100.0, 1.0),    # Case F\n    ]\n\n    results = []\n    for r_c, r_n, k_rel, k_edit in test_cases:\n        L = fidelity_loss(r_c, r_n, k_rel, k_edit)\n        results.append(L)\n\n    # Final print statement in the exact required format with 6 decimal places.\n    formatted = \"[\" + \",\".join(f\"{x:.6f}\" for x in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}