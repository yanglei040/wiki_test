{
    "hands_on_practices": [
        {
            "introduction": "DNA 或 RNA 双螺旋的稳定性并非一成不变，而是高度依赖于其具体的碱基对序列。最近邻模型（nearest-neighbor model）是计算生物学中的一个基本工具，它通过累加相邻碱基对堆叠的能量贡献，让我们能够预测核酸螺旋的热力学稳定性。本练习将挑战你应用此模型来比较 DNA:DNA 双链与 RNA:DNA 杂合双链的稳定性，让你从定量的角度感受分子构成如何影响分离核酸链所需的能量 。",
            "id": "2440503",
            "problem": "一个短双链通过标准生成吉布斯自由能的最近邻加和性进行建模，其中双链形成的总标准吉布斯自由能变 $\\Delta G^{\\circ}_{\\mathrm{form}}$ 是沿链的逐步二核苷酸贡献的总和，忽略了起始和末端校正。考虑一个脱氧核糖核酸(DNA)序列 $5'$-$\\mathrm{GCGC}$-$3'$，它与其精确的沃森-克里克互补链 $3'$-$\\mathrm{CGCG}$-$5'$ 形成一个DNA:DNA双链，或者与DNA互补链 $3'$-$\\mathrm{CGCG}$-$5'$ 配对形成一个核糖核酸(RNA):DNA杂合螺旋，其中RNA链为 $5'$-$\\mathrm{GCGC}$-$3'$。假设在 $T=310\\ \\mathrm{K}$ 的标准条件下，并且分离一个双链所需的能量等于该双链形成的标准吉布斯自由能的绝对值。\n\n使用以下每个最近邻步骤的标准吉布斯自由能贡献（单位：$\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$）：\n\n- DNA:DNA步骤：\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) = -9.37$\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC}) = -9.08$\n\n- RNA:DNA步骤（记法 $\\mathrm{rXY}/\\mathrm{dZW}$ 表示RNA步骤 $\\mathrm{XY}$ 与互补的DNA步骤 $\\mathrm{ZW}$ 配对）：\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) = -11.30$\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC}) = -9.21$\n\n对于序列 $5'$-$\\mathrm{GCGC}$-$3'$，沿 $5'\\to 3'$ 方向遇到的三个最近邻步骤，对于DNA:DNA是 $\\mathrm{GC}/\\mathrm{CG}$、$\\mathrm{CG}/\\mathrm{GC}$ 和 $\\mathrm{GC}/\\mathrm{CG}$，类似地，对于RNA:DNA是 $\\mathrm{rGC}/\\mathrm{dCG}$、$\\mathrm{rCG}/\\mathrm{dGC}$ 和 $\\mathrm{rGC}/\\mathrm{dCG}$。\n\n计算对于此序列，分离RNA:DNA杂合体相对于DNA:DNA双链所需的额外能量，定义为\n$\\Delta E = E_{\\mathrm{sep}}(\\mathrm{RNA{:}DNA}) - E_{\\mathrm{sep}}(\\mathrm{DNA{:}DNA})$，\n并以 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$ 为单位表示您的最终答案。将您的答案四舍五入至4位有效数字。",
            "solution": "问题陈述基于已建立的核酸热力学最近邻模型，提出了一个定义明确的问题。所有必要的数据、条件和简化假设都已明确提供。该问题具有科学依据、客观且内容自洽。因此，该问题被认为是有效的，我们继续进行求解。\n\n核酸双链的热力学稳定性由其形成的标准吉布斯自由能变 $\\Delta G^{\\circ}_{\\mathrm{form}}$ 来量化。根据最近邻模型，这个总能量是来自相邻碱基对步骤的熵和焓贡献的总和，并按规定忽略了起始和末端效应。\n\n首先，我们计算DNA:DNA双链形成的标准吉布斯自由能。序列为 $5'$-$\\mathrm{GCGC}$-$3'$，有 $4-1=3$ 个最近邻步骤。如问题所述，这些步骤从5'端遍历到3'端，得到二核苷酸对序列：$\\mathrm{GC}/\\mathrm{CG}$、$\\mathrm{CG}/\\mathrm{GC}$ 和 $\\mathrm{GC}/\\mathrm{CG}$。\n\nDNA:DNA双链的总标准吉布斯自由能是这些步骤贡献的总和：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) + \\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC}) + \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG})\n$$\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = 2 \\cdot \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) + \\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC})\n$$\n代入以 $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$ 为单位的给定值：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = 2 \\cdot (-9.37) + (-9.08) = -18.74 - 9.08 = -27.82\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n\n接下来，我们对RNA:DNA杂合双链进行类似的计算。RNA链为 $5'$-$\\mathrm{GCGC}$-$3'$，DNA互补链为 $3'$-$\\mathrm{CGCG}$-$5'$。最近邻步骤为 $\\mathrm{rGC}/\\mathrm{dCG}$、$\\mathrm{rCG}/\\mathrm{dGC}$ 和 $\\mathrm{rGC}/\\mathrm{dCG}$。\n\nRNA:DNA杂合体的总标准吉布斯自由能为：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) + \\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC}) + \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG})\n$$\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = 2 \\cdot \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) + \\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC})\n$$\n代入所提供的值：\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = 2 \\cdot (-11.30) + (-9.21) = -22.60 - 9.21 = -31.81\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n\n问题将分离双链所需的能量 $E_{\\mathrm{sep}}$ 定义为其形成的标准吉布斯自由能的绝对值。由于双链形成是一个自发过程，$\\Delta G^{\\circ}_{\\mathrm{form}}$ 为负，因此分离能为正：\n$$\nE_{\\mathrm{sep}} = |\\Delta G^{\\circ}_{\\mathrm{form}}| = -\\Delta G^{\\circ}_{\\mathrm{form}}\n$$\n需要计算的量是分离RNA:DNA杂合体相对于DNA:DNA双链所需的额外能量，记为 $\\Delta E$：\n$$\n\\Delta E = E_{\\mathrm{sep}}(\\mathrm{RNA{:}DNA}) - E_{\\mathrm{sep}}(\\mathrm{DNA{:}DNA})\n$$\n代入 $E_{\\mathrm{sep}}$ 的表达式：\n$$\n\\Delta E = (-\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA})) - (-\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}))\n$$\n$$\n\\Delta E = \\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) - \\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA})\n$$\n我们现在可以代入计算出的自由能值：\n$$\n\\Delta E = (-27.82\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}) - (-31.81\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1})\n$$\n$$\n\\Delta E = -27.82 + 31.81 = 3.99\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n问题要求答案四舍五入到4位有效数字。计算值为 $3.99$。为了用四位有效数字表示，我们将其写为 $3.990$。$\\Delta E$ 的正值表明，对于这个特定序列，RNA:DNA杂合体比其对应的DNA:DNA双链更稳定，需要更多的能量来分离。",
            "answer": "$$\n\\boxed{3.990}\n$$"
        },
        {
            "introduction": "沃森-克里克碱基配对原则不仅决定了双螺旋的结构，也导致了具有深远生物学意义的序列依赖性。某些重复序列，特别是富含较弱的 $A-T$ 配对的序列，对 DNA 聚合酶来说可能很“滑”（slippery），从而增加移码突变的风险。本练习要求你开发一个程序来形式化这个概念，结合热力学标准（平均氢键数）和结构标准（重复基序），以筛选出 DNA 序列中这些潜在的问题区域 。",
            "id": "2440493",
            "problem": "编写一个完整程序，对于给定的由字母表 {\"A\",\"C\",\"G\",\"T\"} 构成的脱氧核糖核酸 (DNA) 序列，根据一个基于 Watson-Crick 碱基配对的模型，检测所有“滑移”窗口的起始索引。腺嘌呤-胸腺嘧啶碱基对贡献 $2$ 个氢键，鸟嘌呤-胞嘧啶碱基对贡献 $3$ 个氢键。如果一个窗口的每个碱基平均氢键数至多为一个指定的阈值，则该窗口被认为是“弱”的。一个窗口被认为是“滑移”的，当且仅当它是弱的，并且在同一窗口内存在 (i) 长度至少为一个指定整数的腺嘌呤或胸腺嘧啶同聚物长串，或 (ii) 至少重复一个指定整数次数的双核苷酸基序 \"AT\" 或 \"TA\" 的连续串联重复。\n\n形式上，设序列为一个长度为 $n$ 的字符串 $s$，其字符集为 $\\{A,C,G,T\\}$。设 $w$ 为用于滑动窗口评估的窗口长度，其中 $1 \\le w \\le n$；如果 $n  w$，则不存在窗口。对于每个起始索引 $i$（$0 \\le i \\le n-w$），我们考虑窗口 $s[i:i+w]$。定义 $N_{AT}(i)$ 为窗口中属于 $\\{A,T\\}$ 的字符计数，$N_{GC}(i)=w-N_{AT}(i)$。窗口中每个碱基的平均氢键数为\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3\\,N_{GC}(i)}{w}.\n$$\n给定一个实数阈值 $h_{\\max}$，如果 $\\bar{h}(i) \\le h_{\\max}$，则该窗口是弱的。在同一个窗口内，定义：\n- 一个同聚物条件 $H(i)$，当存在索引 $j$ 和一个整数长串长度 $\\ell \\ge L_{\\text{run}}$，使得 $s[j]=s[j+1]=\\cdots=s[j+\\ell-1]$ 且 $s[j]\\in\\{A,T\\}$ 并且 $[j, j+\\ell-1] \\subseteq [i, i+w-1]$ 时，该条件为真。\n- 一个双核苷酸重复条件 $D(i)$，当存在索引 $j$、一个基序 $m\\in\\{\\text{\"AT\"},\\text{\"TA\"}\\}$ 和一个整数 $r \\ge R_{\\text{rep}}$，使得子字符串 $s[j:j+2r]$ 等于 $m$ 自身连接 $r$ 次，并且 $[j, j+2r-1] \\subseteq [i, i+w-1]$ 时，该条件为真。\n\n一个窗口 $s[i:i+w]$ 是滑移的，当且仅当 $\\bar{h}(i) \\le h_{\\max}$ 并且 $\\big(H(i)\\ \\text{or}\\ D(i)\\big)$ 为真。索引是从0开始的。\n\n你的程序必须为每个测试用例输出所有满足 $s[i:i+w]$ 是滑移窗口的起始索引 $i$ 的列表。如果 $n  w$，则为该测试用例输出空列表。\n\n测试套件。你的程序必须按顺序评估以下测试用例，并将索引列表聚合成下面指定的单个输出行：\n- 用例 1：$s=\\text{\"GAAAAAAG\"}$, $w=8$, $h_{\\max}=2.25$, $L_{\\text{run}}=6$, $R_{\\text{rep}}=3$。\n- 用例 2：$s=\\text{\"CCCCCC\"}$, $w=4$, $h_{\\max}=2.4$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=2$。\n- 用例 3：$s=\\text{\"ATATATGC\"}$, $w=6$, $h_{\\max}=2.2$, $L_{\\text{run}}=5$, $R_{\\text{rep}}=3$。\n- 用例 4：$s=\\text{\"TTTTT\"}$, $w=3$, $h_{\\max}=2.0$, $L_{\\text{run}}=3$, $R_{\\text{rep}}=2$。\n- 用例 5：$s=\\text{\"AATTAATT\"}$, $w=4$, $h_{\\max}=2.0$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=2$。\n- 用例 6：$s=\\text{\"AT\"}$, $w=3$, $h_{\\max}=2.5$, $L_{\\text{run}}=2$, $R_{\\text{rep}}=2$。\n- 用例 7：$s=\\text{\"ATATATAT\"}$, $w=6$, $h_{\\max}=2.1$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=3$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的索引列表，并且行中任何地方都不能有空格。例如，一个包含三个测试用例的输出应如下所示：$[[i\\_1,\\dots],[\\dots],[]]$，不含任何空格。索引必须是整数。",
            "solution": "该问题要求在给定的脱氧核糖核酸 (DNA) 序列中识别出“滑移”窗口。一个窗口如果同时满足两个不同的标准，即基于氢键含量的“弱性”生物物理标准和与特定重复基序存在相关的结构标准，则被指定为滑移窗口。解决方案需要对所有指定长度的可能窗口进行系统性评估。\n\n算法通过在长度为 $n$ 的输入序列 $s$ 上滑动一个长度为 $w$ 的窗口来进行。对于每个可能的起始索引 $i$（$0 \\le i \\le n-w$），分析相应的子字符串 $s[i:i+w]$。如果 $n  w$，则不存在这样的窗口，结果是一个空的索引集合。\n\n对于每个窗口，我们首先评估其弱性标准。每个碱基的平均氢键数 $\\bar{h}(i)$ 是窗口内腺嘌呤-胸腺嘧啶碱基数 $N_{AT}(i)$ 和鸟嘌呤-胞嘧啶碱基数 $N_{GC}(i)$ 的函数。鉴于腺嘌呤-胸腺嘧啶对由 $2$ 个氢键连接，鸟嘌呤-胞嘧啶对由 $3$ 个氢键连接，其公式为：\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3\\,N_{GC}(i)}{w}\n$$\n由于 $N_{AT}(i) + N_{GC}(i) = w$，我们可以代入 $N_{GC}(i) = w - N_{AT}(i)$ 来得到一个简化的表达式：\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3(w - N_{AT}(i))}{w} \\;=\\; \\frac{3w - N_{AT}(i)}{w} \\;=\\; 3 - \\frac{N_{AT}(i)}{w}\n$$\n如果这个平均值不超过指定的阈值 $h_{\\max}$，则窗口被定义为弱窗口。即条件为 $\\bar{h}(i) \\le h_{\\max}$。如果一个窗口不满足此条件，它就不可能是滑移的，算法将继续处理下一个窗口。\n\n如果发现窗口是弱的，则对其进行结构标准的评估。如果子字符串 $s[i:i+w]$ 满足 $H(i)$ 或 $D(i)$ 两个条件中的任意一个，则该标准被满足。\n\n第一个结构条件，即同聚物条件 $H(i)$，在窗口包含一个单一碱基（腺嘌呤 'A' 或胸腺嘧啶 'T'）的连续长串，且该长串的长度 $\\ell$ 至少为一个指定的整数 $L_{\\text{run}}$ 时被满足。这等价于在窗口内检查是否存在子字符串 $'A' \\times L_{\\text{run}}$ 或 $'T' \\times L_{\\text{run}}$。\n\n第二个结构条件，即双核苷酸重复条件 $D(i)$，在窗口包含双核苷酸基序 'AT' 或 'TA' 的连续串联重复时被满足。重复的次数 $r$ 必须至少为一个指定的整数 $R_{\\text{rep}}$。这对应于在窗口内搜索子字符串 $('AT') \\times R_{\\text{rep}}$ 或 $('TA') \\times R_{\\text{rep}}$。\n\n一个从索引 $i$ 开始的窗口被正式归类为滑移窗口，当且仅当它是弱的，并且还满足逻辑析取 $(H(i) \\lor D(i))$。算法必须收集所有这样的索引 $i$。\n\n计算过程如下：\n$1$. 对于给定的测试用例及其参数 $s, w, h_{\\max}, L_{\\text{run}}, R_{\\text{rep}}$，确定序列的长度 $n$。如果 $n  w$，返回一个空列表。\n$2$. 为结构检查预先构建基序字符串：一个长度为 $L_{\\text{run}}$ 的 A-同聚物，一个长度为 $L_{\\text{run}}$ 的 T-同聚物，一个长度为 $2R_{\\text{rep}}$ 的 AT-双核苷酸重复，以及一个长度为 $2R_{\\text{rep}}$ 的 TA-双核苷酸重复。\n$3$. 使用索引 $i$ 从 $0$ 迭代到 $n-w$。对于每个 $i$：\n    a. 提取窗口子字符串 $s[i:i+w]$。\n    b. 计算 $N_{AT}(i)$，即窗口中 'A' 和 'T' 碱基的计数。\n    c. 检查弱性条件：$3w - N_{AT}(i) \\le h_{\\max} \\times w$。如果此条件为假，则继续处理下一个 $i$ 值。\n    d. 如果窗口是弱的，检查结构条件：确定是否有任何预先构建的基序字符串作为子字符串存在于窗口内。\n    e. 如果结构条件被满足，将索引 $i$ 添加到结果列表中。\n$4$. 循环完成后，收集到的索引的最终列表即为该测试用例的解。对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef find_slippery_windows(s: str, w: int, h_max: float, L_run: int, R_rep: int) - list[int]:\n    \"\"\"\n    Detects the starting indices of all \"slippery\" windows in a DNA sequence.\n\n    A window is slippery if it is \"weak\" (low average hydrogen bonds) and contains\n    either a long A/T homopolymer or a tandem AT/TA repeat.\n    \"\"\"\n    n = len(s)\n    if n  w:\n        return []\n\n    slippery_indices = []\n\n    # Pre-generate the search motifs to avoid repeated string construction.\n    # The homopolymer condition requires a run of length *at least* L_run.\n    # Searching for a substring of exactly length L_run is sufficient because if a\n    # longer run exists, it must contain a run of length L_run.\n    homopolymer_A = 'A' * L_run\n    homopolymer_T = 'T' * L_run\n    \n    # Similarly, for dinucleotide repeats of length at least R_rep.\n    repeat_AT = 'AT' * R_rep\n    repeat_TA = 'TA' * R_rep\n\n    for i in range(n - w + 1):\n        window = s[i : i + w]\n\n        # 1. Weakness criterion evaluation.\n        # The average hydrogen bond count is (2*N_AT + 3*N_GC) / w.\n        # N_GC = w - N_AT.\n        # So, h_avg = (2*N_AT + 3*(w - N_AT)) / w = (3w - N_AT) / w.\n        # Condition: h_avg = h_max  =>  (3w - N_AT) / w = h_max\n        # To maintain precision, we use integer/float arithmetic on the un-divided form:\n        # 3w - N_AT = h_max * w\n        n_at = window.count('A') + window.count('T')\n        \n        is_weak = (3 * w - n_at) = h_max * w\n        \n        if not is_weak:\n            continue\n\n        # 2. Structural motif evaluation.\n        # This condition is checked only if the window is weak.\n        # H(i): Homopolymer of 'A' or 'T' of length >= L_run.\n        homopolymer_found = (homopolymer_A in window) or (homopolymer_T in window)\n\n        # D(i): Tandem repeat of 'AT' or 'TA' with >= R_rep repetitions.\n        dinucleotide_repeat_found = (repeat_AT in window) or (repeat_TA in window)\n\n        if homopolymer_found or dinucleotide_repeat_found:\n            slippery_indices.append(i)\n            \n    return slippery_indices\n\ndef solve():\n    \"\"\"\n    Runs the validation and solution for all test cases provided in the problem.\n    \"\"\"\n    test_cases = [\n        # (s, w, h_max, L_run, R_rep)\n        (\"GAAAAAAG\", 8, 2.25, 6, 3),\n        (\"CCCCCC\", 4, 2.4, 4, 2),\n        (\"ATATATGC\", 6, 2.2, 5, 3),\n        (\"TTTTT\", 3, 2.0, 3, 2),\n        (\"AATTAATT\", 4, 2.0, 4, 2),\n        (\"AT\", 3, 2.5, 2, 2),\n        (\"ATATATAT\", 6, 2.1, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, w, h_max, l_run, r_rep = case\n        result = find_slippery_windows(s, w, h_max, l_run, r_rep)\n        results.append(result)\n\n    # Format the final output string to be exactly as specified, with no spaces.\n    # e.g., [[0],[],[0,1,2]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "生物技术和合成生物学的一项核心任务是设计行为可预测的功能性 DNA 序列。例如，DNA 条形码（DNA barcodes）必须是唯一可识别的，并且不能相互交叉杂交。这个问题将让你扮演序列设计师的角色，任务是从一个更大的序列库中选出“条形码”的最优子集。你的目标是最大化任意两条序列之间的最小“距离”，同时考虑直接相互作用和反向互补相互作用，这是将沃森-克里克配对原则直接应用于解决复杂设计优化问题的实践 。",
            "id": "2440515",
            "problem": "给定一个有限的有序脱氧核糖核酸 (DNA) 寡核苷酸序列集合，其字母表为 $\\Sigma=\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。每个寡核苷酸（oligo）的长度均为 $L$。设该集合为 $S=\\{s_0,s_1,\\ldots,s_{n-1}\\}$，其中 $n$ 是序列的数量，且 $s_i \\in \\Sigma^L$。Watson–Crick 互补配对规则为 $\\mathrm{A}\\leftrightarrow\\mathrm{T}$ 和 $\\mathrm{C}\\leftrightarrow\\mathrm{G}$。对于一个序列 $x=x_0x_1\\ldots x_{L-1}$，定义其反向互补序列为 $\\mathrm{rc}(x)=\\overline{x_{L-1}}\\ \\overline{x_{L-2}}\\ \\ldots\\ \\overline{x_0}$，其中 $\\overline{\\cdot}$ 表示核苷酸的 Watson–Crick 互补。对于任意两个序列 $x,y\\in\\Sigma^L$，定义汉明距离 $H(x,y)=|\\{i\\in\\{0,1,\\ldots,L-1\\}: x_i\\neq y_i\\}|$。对于一个子集 $B\\subseteq S$（其中 $|B|=k$ 且 $2\\le k\\le n$），定义其稳健性分数为\n$$\nD(B)=\\min_{\\{u,v\\}\\subseteq B,\\,u\\neq v}\\ \\min\\big(H(u,v),\\ H\\big(u,\\mathrm{rc}(v)\\big)\\big).\n$$\n您的任务是选择一个索引集 $I\\subseteq\\{0,1,\\ldots,n-1\\}$，其大小 $|I|=k$，以最大化 $D(\\{s_i: i\\in I\\})$。如果有多个索引集达到相同的最大 $D(\\cdot)$ 值，则选择其排序后的索引元组在 $\\mathbb{Z}$ 的自然序下字典序最小的那个。\n\n您的程序必须为以下每个测试用例实现此选择。在每个用例中，序列按给定顺序列出，这决定了索引 $0,1,\\ldots,n-1$。在给定用例中，所有序列的长度 $L$ 均相等。\n\n测试套件：\n- 用例 1：$L=6$, $k=4$，其中 $n=8$ 且\n  $s_0=\\mathrm{ACGTAC}$，\n  $s_1=\\mathrm{TGCATG}$，\n  $s_2=\\mathrm{GTACGT}$，\n  $s_3=\\mathrm{CAGTCA}$，\n  $s_4=\\mathrm{GACTGT}$，\n  $s_5=\\mathrm{ATGCAT}$，\n  $s_6=\\mathrm{CATGCA}$，\n  $s_7=\\mathrm{TATATA}$。\n- 用例 2：$L=5$, $k=2$，其中 $n=6$ 且\n  $s_0=\\mathrm{AAAAA}$，\n  $s_1=\\mathrm{AAAAT}$，\n  $s_2=\\mathrm{AAATA}$，\n  $s_3=\\mathrm{AATAA}$，\n  $s_4=\\mathrm{ATAAA}$，\n  $s_5=\\mathrm{TAAAA}$。\n- 用例 3：$L=6$, $k=3$，其中 $n=6$ 且\n  $s_0=\\mathrm{AACCGG}$，\n  $s_1=\\mathrm{CCGGTT}$，\n  $s_2=\\mathrm{TTGGCC}$，\n  $s_3=\\mathrm{ACACAC}$，\n  $s_4=\\mathrm{GTGTGT}$，\n  $s_5=\\mathrm{AGCTAG}$。\n- 用例 4：$L=3$, $k=2$，其中 $n=5$ 且\n  $s_0=\\mathrm{AAA}$，\n  $s_1=\\mathrm{TTT}$，\n  $s_2=\\mathrm{CGC}$，\n  $s_3=\\mathrm{GCG}$，\n  $s_4=\\mathrm{ATG}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有用例的结果，格式为一个用方括号括起来的逗号分隔列表。对于每个用例，输出一个列表，其第一个元素是最佳稳健性分数 $D^*$（一个整数），随后的 $k$ 个元素是按升序排列的所选索引。因此，整体输出格式为\n$[[D^*,i_1,\\ldots,i_k],\\ldots]$\n每个测试用例对应一个内部列表，顺序与上面列出的顺序相同，并且所有索引都使用从零开始的编号。不涉及物理单位，也不需要角度或百分比。",
            "solution": "用户提出了一个计算生物学领域的问题，具体涉及DNA序列设计。问题是从一个包含 $n$ 条长度为 $L$ 的序列的给定集合中，选出 $k$ 条寡核苷酸序列组成的子集，以使“稳健性分数”最大化。该分数的定义旨在防止不期望的杂交，包括序列之间的杂交以及序列与另一条序列的反向互补序列之间的杂交。\n\n首先，需要对问题陈述进行验证。\n\n**第1步：提取已知信息**\n\n- **字母表**：$\\Sigma=\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。\n- **输入集**：$S=\\{s_0,s_1,\\ldots,s_{n-1}\\}$，其中 $s_i \\in \\Sigma^L$，$n$ 为序列数量。\n- **Watson–Crick 互补**：$\\overline{\\mathrm{A}}=\\mathrm{T}, \\overline{\\mathrm{T}}=\\mathrm{A}, \\overline{\\mathrm{C}}=\\mathrm{G}, \\overline{\\mathrm{G}}=\\mathrm{C}$。\n- **反向互补**：对于序列 $x=x_0x_1\\ldots x_{L-1}$，其反向互补序列为 $\\mathrm{rc}(x)=\\overline{x_{L-1}}\\ \\overline{x_{L-2}}\\ \\ldots\\ \\overline{x_0}$。\n- **汉明距离**：对于两个序列 $x,y\\in\\Sigma^L$，$H(x,y)=|\\{i\\in\\{0,1,\\ldots,L-1\\}: x_i\\neq y_i\\}|$ 是对应位置上字符不同的位置数量。\n- **稳健性分数**：对于子集 $B\\subseteq S$ 且 $|B|=k$，分数为 $D(B)=\\min_{\\{u,v\\}\\subseteq B,\\,u\\neq v}\\ \\min\\big(H(u,v),\\ H\\big(u,\\mathrm{rc}(v)\\big)\\big)$。\n- **目标**：找到一个索引集 $I\\subseteq\\{0,1,\\ldots,n-1\\}$，其大小 $|I|=k$，以最大化分数 $D(\\{s_i: i\\in I\\})$。\n- **平局决胜规则**：若多个索引集产生相同的最高分，则选择其排序后的索引元组字典序最小的那个。\n- **测试用例**：提供了问题的四个具体实例，给定了参数 $L, k, n$ 和序列 $s_i$。\n\n**第2步：使用提取的已知信息进行验证**\n\n该问题根据所需标准进行分析：\n\n- **科学上合理**：所使用的概念——DNA序列、Watson-Crick配对、反向互补和汉明距离——在分子生物学和生物信息学中是基础且标准的概念。最大化最小成对差异性（包括反向互补相互作用）的目标是DNA条形码、探针和引物设计中的一个典型问题，其中最小化交叉杂交至关重要。因此，该问题在科学上是合理且相关的。\n- **定义明确**：该问题是一个定义明确的组合优化任务。搜索空间由 $S$ 的所有大小为 $k$ 的子集组成，该空间是有限的。此类子集的数量为 $\\binom{n}{k}$。目标函数 $D(B)$ 对任何此类子集都有精确定义。在有限集上最大化一个函数是一个定义明确的问题。平局决胜规则确保了解的唯一性。\n- **目标明确**：问题使用形式化的数学语言进行描述，没有任何主观或模棱两可的术语。\n\n该问题没有任何无效性缺陷。它是完整的、一致的、现实的且可验证的。\n\n**结论**：该问题被判定为有效。\n\n**解决方案设计**\n\n任务是找到一个包含 $k$ 个元素的索引子集 $I \\subseteq \\{0, 1, \\ldots, n-1\\}$，以最大化函数 $D_I = D(\\{s_i : i \\in I\\})$。这是一个经典的`最大-最小`优化问题。\n\n搜索空间是初始 $n$ 个序列集合中所有含 $k$ 个元素的子集的集合。该搜索空间的大小由二项式系数 $\\binom{n}{k}$ 给出。让我们针对提供的测试用例评估这个值：\n- 用例 1: $n=8, k=4 \\implies \\binom{8}{4} = 70$。\n- 用例 2: $n=6, k=2 \\implies \\binom{6}{2} = 15$。\n- 用例 3: $n=6, k=3 \\implies \\binom{6}{3} = 20$。\n- 用例 4: $n=5, k=2 \\implies \\binom{5}{2} = 10$。\n\n在所有用例中，候选子集的数量都非常小。这一观察结果决定了最合乎逻辑且最稳健的算法方法：对整个解空间进行直接的穷举搜索。更复杂的方法，例如对分数值进行二分搜索并结合最大团算法，对于这种规模的问题来说是不必要的，并且会引入不必要的复杂性。\n\n算法流程如下：\n\n1.  **预处理**：对于输入集 $S$ 中的每个序列 $s_i$，计算其反向互补序列 $\\mathrm{rc}(s_i)$。对每个序列只计算一次，以避免重复计算。\n\n2.  **枚举**：生成索引集 $\\{0, 1, \\ldots, n-1\\}$ 的所有可能的含 $k$ 个元素的子集。关键在于要按索引元组的字典序生成这些子集。这种排序是组合库中的标准做法，并且直接满足问题的平局决胜规则。\n\n3.  **评估**：对于每个生成的索引子集 $I$：\n    a. 计算其稳健性分数 $D_I$。这需要为 $I$ 中所有不同的索引对 $\\{i, j\\}$ 计算成对相互作用项。相互作用项为 $d_{ij} = \\min\\big(H(s_i, s_j), H(s_i, \\mathrm{rc}(s_j))\\big)$。\n    b. 子集 $I$ 的分数是所有 $\\binom{k}{2}$ 个对的 $d_{ij}$ 值中的最小值：$D_I = \\min_{i,j \\in I, i \\neq j} d_{ij}$。\n\n4.  **选择**：维护两个变量：`max_score`，用于存储迄今为止找到的最大分数；`best_indices`，用于存储对应的索引集。将 `max_score` 初始化为一个小于任何可能分数的值（例如-1）。\n    - 按字典序遍历生成的索引子集 $I$。\n    - 对于每个子集 $I$，计算其分数 $D_I$。\n    - 如果 $D_I > \\mathrm{max\\_score}$，则更新 $\\mathrm{max\\_score} = D_I$ 和 $\\mathrm{best\\_indices} = I$。\n    - 由于子集是按字典序处理的，因此第一次确定最大可能分数时，对应的索引集保证是所有达到此分数的集合中字典序最小的。任何后续达到相同分数的集合在字典序上都会更大，并被严格不等式 $D_I > \\mathrm{max\\_score}$ 正确忽略。\n\n5.  **定稿**：遍历完所有 $\\binom{n}{k}$ 个子集后，变量 `max_score` 和 `best_indices` 将保存最优分数和所需的索引集。然后将结果格式化为一个列表，其中包含分数和紧随其后的索引。\n\n对于给定的约束条件，这种穷举搜索方法简单、可靠且高效。实现时将需要用于计算反向互补和汉明距离的辅助函数。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the DNA sequence subset selection problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 6, \"k\": 4, \"n\": 8,\n            \"sequences\": [\n                \"ACGTAC\", \"TGCATG\", \"GTACGT\", \"CAGTCA\",\n                \"GACTGT\", \"ATGCAT\", \"CATGCA\", \"TATATA\"\n            ]\n        },\n        {\n            \"L\": 5, \"k\": 2, \"n\": 6,\n            \"sequences\": [\n                \"AAAAA\", \"AAAAT\", \"AAATA\", \"AATAA\",\n                \"ATAAA\", \"TAAAA\"\n            ]\n        },\n        {\n            \"L\": 6, \"k\": 3, \"n\": 6,\n            \"sequences\": [\n                \"AACCGG\", \"CCGGTT\", \"TTGGCC\", \"ACACAC\",\n                \"GTGTGT\", \"AGCTAG\"\n            ]\n        },\n        {\n            \"L\": 3, \"k\": 2, \"n\": 5,\n            \"sequences\": [\n                \"AAA\", \"TTT\", \"CGC\", \"GCG\", \"ATG\"\n            ]\n        }\n    ]\n\n    complement_map = str.maketrans(\"ACGT\", \"TGCA\")\n\n    def reverse_complement(seq: str) - str:\n        \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n        return seq.translate(complement_map)[::-1]\n\n    def hamming_distance(s1: str, s2: str) - int:\n        \"\"\"Computes the Hamming distance between two sequences of equal length.\"\"\"\n        # Using numpy for a concise representation.\n        # This is equivalent to sum(1 for c1, c2 in zip(s1, s2) if c1 != c2).\n        return np.sum(np.array(list(s1)) != np.array(list(s2)))\n\n    results = []\n    for case in test_cases:\n        k = case[\"k\"]\n        sequences = case[\"sequences\"]\n        n = case[\"n\"]\n        L = case[\"L\"]\n        \n        # Pre-compute reverse complements for efficiency\n        rc_sequences = [reverse_complement(s) for s in sequences]\n        \n        max_score = -1\n        best_indices = ()\n\n        # itertools.combinations generates sorted tuples in lexicographical order.\n        # This naturally handles the tie-breaking rule.\n        index_combinations = itertools.combinations(range(n), k)\n\n        for indices in index_combinations:\n            current_min_dist = L + 1 # Initialize with a value larger than any possible distance\n            \n            # Get all pairs of indices within the current combination\n            pair_indices = itertools.combinations(indices, 2)\n            \n            is_score_beaten = False\n            for i, j in pair_indices:\n                # Calculate the two relevant Hamming distances\n                h_direct = hamming_distance(sequences[i], sequences[j])\n                h_rc = hamming_distance(sequences[i], rc_sequences[j])\n                \n                dist = min(h_direct, h_rc)\n                \n                # Optimization: if a pair's distance is not better than the current max_score,\n                # the whole subset cannot be better. We can stop early.\n                if dist = max_score:\n                    is_score_beaten = True\n                    break\n                \n                if dist  current_min_dist:\n                    current_min_dist = dist\n            \n            if is_score_beaten:\n                continue\n\n            # If the score for this subset is strictly greater than the best score found so far,\n            # update the best score and indices.\n            if current_min_dist > max_score:\n                max_score = current_min_dist\n                best_indices = indices\n\n        # Format the result for this case as [D*, i_1, ..., i_k]\n        case_result = [max_score] + list(best_indices)\n        results.append(case_result)\n        \n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}