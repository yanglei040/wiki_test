{
    "hands_on_practices": [
        {
            "introduction": "孟德尔定律为遗传模式提供了简洁的数学预测，例如经典的基因比例。然而，在真实的遗传杂交实验中，观测数据很少能完美匹配这些理论比率。本练习旨在通过应用卡方（$\\chi^2$）拟合优度检验，让学生掌握一项基本技能：如何从统计学上判断观测到的后代基因型频率是否显著偏离了孟德尔遗传的预期，从而将理论模型与实验数据分析联系起来。",
            "id": "2403843",
            "problem": "给定一组来自受控杂交后代的独立遗传位点。对于每个位点，已使用高通量测序技术对后代进行基因分型，并已统计各基因型类别的观测计数。假设位点为双等位基因，且基因型判定为共显性（因此基因型类别可明确区分）。根据经典孟德尔遗传定律，对于特定的杂交设计，预期的基因型比例由分离定律和配子随机结合决定。\n\n对于每个测试用例，您必须在指定的显著性水平下，判断某一位点的观测计数是否与所声明的杂交设计的孟德尔分离定律相符。形式上，对于一个具有 $k$ 个基因型类别的位点，设观测计数为向量 $\\mathbf{O}=(O_1,\\dots,O_k)$，总数为 $N=\\sum_{i=1}^k O_i$；并设该杂交设计下的预期孟德尔比例为 $\\mathbf{p}=(p_1,\\dots,p_k)$，其中 $\\sum_{i=1}^k p_i=1$ 且对于所有 $i$ 都有 $p_i>0$。零假设是，该数据源于概率为 $\\mathbf{p}$ 的分类分布。您的程序必须为每个测试用例判断是否在显著性水平 $\\alpha$ 下拒绝零假设。\n\n支持的杂交设计及其预期基因型比例：\n- 杂交设计字符串 \"F2\" 表示由两个近交系亲本杂交得到的 $F_2$ 代互交，涉及单个双等位基因位点和共显性基因分型。预期的基因型比例向量（按 $AA$、$Aa$、$aa$ 顺序）为 $\\left(\\tfrac{1}{4},\\tfrac{1}{2},\\tfrac{1}{4}\\right)$。\n- 杂交设计字符串 \"BACKCROSS\" 表示在单个双等位基因位点上，将一个杂合子与一个纯合隐性个体进行回交，并采用共显性基因分型。预期的基因型比例向量（按 $Aa$、$aa$ 顺序）为 $\\left(\\tfrac{1}{2},\\tfrac{1}{2}\\right)$。\n\n解释和输出编码：\n- 对于每个测试用例，返回如下定义的整数决策代码 $d$：如果孟德尔分离定律的零假设在水平 $\\alpha$ 下被拒绝，则 $d=1$；如果在水平 $\\alpha$ 下不拒绝零假設，则 $d=0$；如果因观测类别计数向量的长度与所声明杂交设计的预期比例向量的长度不匹配，或因 $N=0$ 而导致测试无效，则 $d=-1$。\n\n您的程序必须硬编码并使用以下测试套件。每个测试用例是一个包含三个元素的元组：杂交设计字符串、该杂交设计指定顺序下各基因型类别的观测非负整数计数列表，以及显著性水平 $\\alpha$（以小数形式表示）：\n- 测试用例 1：杂交 \"F2\"，观测计数 $[20,40,20]$，$\\alpha=0.05$。\n- 测试用例 2：杂交 \"F2\"，观测计数 $[10,60,10]$，$\\alpha=0.05$。\n- 测试用例 3：杂交 \"BACKCROSS\"，观测计数 $[35,45]$，$\\alpha=0.05$。\n- 测试用例 4：杂交 \"BACKCROSS\"，观测计数 $[0,40]$，$\\alpha=0.01$。\n- 测试用例 5：杂交 \"F2\"，观测计数 $[0,4,0]$，$\\alpha=0.05$。\n- 测试用例 6：杂交 \"F2\"，观测计数 $[50,50]$，$\\alpha=0.05$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[1,0,1]”），结果顺序与上述测试用例的顺序一致。列表中的元素必须是如上定义的决策代码 $d$。\n\n所有数值答案均无单位。角度单位不适用。显著性水平必须以小数形式提供和解释，而不是百分号。最终输出必须是指定格式的单行文本。不要读取任何输入；仅使用此处提供的测试套件。",
            "solution": "所述问题已经过严格验证，并被认定为有效。它在科学上基于孟德尔遗传学和统计假设检验的原理，问题陈述清晰，其表述客观明确。因此，我们将着手提供一个完整的解决方案。\n\n任务是评估遗传杂交实验中观测到的基因型计数是否符合孟德尔定律预测的预期比例。这是一个经典的拟合优度问题，其标准统计工具是 Pearson 卡方（$\\chi^2$）检验。\n\n其核心原理是量化观测数据与特定零假设下预期数据之间的差异。零假设（记为 $H_0$）是：观测计数来自一个分类分布，其概率由给定杂交设计的孟德爾模型指定。\n\n对于每个测试用例，给定一组观测计数 $\\mathbf{O} = (O_1, O_2, \\dots, O_k)$，其中 $k$ 是基因型类别的数量。观测总数为 $N = \\sum_{i=1}^k O_i$。零假设 $H_0$ 提供了一个预期比例向量 $\\mathbf{p} = (p_1, p_2, \\dots, p_k)$，其中 $\\sum_{i=1}^k p_i = 1$ 且每个 $p_i > 0$。\n\n首先，我们对每个测试用例进行必要的初步验证。如果满足以下两个条件之一，则该测试用例被视为无效，并分配代码 $d = -1$：\n1. 观测类别的数量（即向量 $\\mathbf{O}$ 的长度）与指定杂交设计的预期类别数量（即向量 $\\mathbf{p}$ 的长度）不匹配。对于 `$F_2$` 杂交，我们预期有 $k=3$ 个类别（$AA, Aa, aa$）。对于 `BACKCROSS`，我们预期有 $k=2$ 个类别（$Aa, aa$）。\n2. 观测到的后代总数为零，即 $N=0$。没有数据的统计检验是无意义的。\n\n如果测试用例有效，我们继续进行计算。我们在零假设下计算每个类别的预期计数 $\\mathbf{E}$：\n$$ E_i = N \\times p_i $$\nPearson $\\chi^2$ 检验统计量衡量观测计数与预期计数之间的归一化平方偏差：\n$$ \\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i} $$\n$\\chi^2$ 的值越大，表示与孟德尔模型的偏差越大，因此提供了更强的反对 $H_0$ 的证据。\n\n在零假设下，该 $\\chi^2$ 统计量近似服从自由度为 $\\nu = k-1$ 的卡方分布。自由度的数量是类别数减一，因为总计数 $N$ 是固定的。\n\n为了做出决策，我们将计算出的 $\\chi^2$ 值与该分布进行比较。这是通过计算 p 值来完成的，p 值是在 $H_0$ 为真的前提下，观测到至少与计算出的检验统计量一样极端的统计量的概率。\n$$ \\text{p-value} = P(\\chi^2_{\\nu} \\ge \\chi^2_{\\text{calculated}}) $$\n最终决策是通过将 p 值与预先指定的显著性水平 $\\alpha$ 进行比较得出的：\n- 如果 p 值 $ \\alpha$，我们拒绝零假设 $H_0$。在 $\\alpha$ 显著性水平下，观测数据与孟德尔模型在统计上不一致。决策代码为 $d=1$。\n- 如果 p 值 $\\ge \\alpha$，我们不拒绝零假设 $H_0$。没有足够的统计证据得出数据偏离孟德尔模型的结论。决策代码为 $d=0$。\n\n必须指出，卡方分布是一种近似，当预期计数 $E_i$ 足够大时（例如 $E_i \\ge 5$），其准确性最高。问题陈述不要求我们基于此条件使测试无效，因此无论预期计数的大小如何，我们都将按形式化定义执行计算。\n\n算法如下：\n1. 对于每个由杂交设计、观测计数 $\\mathbf{O}$ 和显著性水平 $\\alpha$ 定义的测试用例，检索相应的预期比例 $\\mathbf{p}$。\n2. 验证测试用例。如果 `len(O)` $\\neq$ `len(p)` 或 $\\sum O_i = 0$，则结果为 $d=-1$。\n3. 如果用例有效，计算总计数 $N = \\sum O_i$。\n4. 计算预期计数向量 $\\mathbf{E} = N \\times \\mathbf{p}$。\n5. 使用自由度为 $\\nu = k-1$ 的卡方分布计算 $\\chi^2$ 统计量及其对应的 p 值。\n6. 将 p 值与 $\\alpha$ 进行比较，以确定决策代码是 $d=1$ 还是 $d=0$。\n7. 收集所有测试用例的决策代码，并按要求格式化。此过程将使用数值库来实现，以确保精度和效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates and solves a suite of genetic cross problems using the chi-squared test.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (cross_design, observed_counts, alpha)\n        (\"F2\", [20, 40, 20], 0.05),\n        (\"F2\", [10, 60, 10], 0.05),\n        (\"BACKCROSS\", [35, 45], 0.05),\n        (\"BACKCROSS\", [0, 40], 0.01),\n        (\"F2\", [0, 4, 0], 0.05),\n        (\"F2\", [50, 50], 0.05),\n    ]\n\n    # Define the expected genotype proportions for the supported cross designs.\n    mendelian_proportions = {\n        \"F2\": np.array([0.25, 0.5, 0.25]),\n        \"BACKCROSS\": np.array([0.5, 0.5])\n    }\n\n    results = []\n    for cross_design, observed_counts, alpha in test_cases:\n        # Step 1: Retrieve expected proportions for the cross design.\n        expected_proportions = mendelian_proportions[cross_design]\n\n        # Step 2: Validate the test case.\n        # Check for mismatch in the number of genotype categories.\n        if len(observed_counts) != len(expected_proportions):\n            results.append(-1)\n            continue\n        \n        # Calculate the total number of offspring.\n        N = sum(observed_counts)\n        \n        # Check if the total count is zero.\n        if N == 0:\n            results.append(-1)\n            continue\n\n        # Step 3: Calculate expected counts.\n        # The observed counts are converted to a NumPy array for vectorized operations.\n        observed_counts_np = np.array(observed_counts)\n        expected_counts = N * expected_proportions\n        \n        # Step 4: Perform Pearson's chi-squared goodness-of-fit test.\n        # The scipy.stats.chisquare function computes the statistic and the p-value.\n        # The degrees of freedom are calculated by the function as k-1.\n        chi2_statistic, p_value = stats.chisquare(f_obs=observed_counts_np, f_exp=expected_counts)\n        \n        # Step 5: Make a decision based on the p-value and significance level alpha.\n        if p_value  alpha:\n            # Reject the null hypothesis.\n            decision_code = 1\n        else:\n            # Do not reject the null hypothesis.\n            decision_code = 0\n            \n        results.append(decision_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了孟德尔的分离定律之后，我们自然会思考位于同一染色体上的基因是如何遗传的，这引出了连锁与互换定律。连锁基因之间的重组频率是推断它们在染色体上相对距离的关键。本练习要求学生实现两种经典的作图函数——Haldane作图函数和Kosambi作图函数，它们是将可观测的重组率$r$转换为遗传图距$D$的数学模型，从而深入理解基因连锁分析的核心原理。",
            "id": "2403810",
            "problem": "实现一个程序，对于遵循孟德尔分离定律的二倍体生物中两个基因座之间的每个给定重组频率 $r$，分别使用 Haldane 映射函数和 Kosambi 映射函数计算遗传图距。映射函数将重组率 $r \\in [0, 0.5)$ 转换为以厘摩（cM）为单位的遗传距离 $D$。遗传距离结果必须以厘摩（cM）为单位报告，并四舍五入到 $6$ 位小数。\n\n运行时不提供输入。相反，您的程序必须在内部评估一组固定的重组频率测试集。对 $r$ 使用以下测试集：$[0.0, 0.01, 0.1, 0.2, 0.3, 0.49]$。对于此列表中的每个 $r$，计算两个值：\n- $D_{\\mathrm{H}}(r)$：Haldane 距离，单位为厘摩（cM）。\n- $D_{\\mathrm{K}}(r)$：Kosambi 距离，单位为厘摩（cM）。\n\n按照下面描述的确切要求输出格式报告结果。如果 $r$ 在闭开区间 $[0, 0.5)$ 之外，则映射函数未定义，不得进行计算；这种情况在提供的测试集中不会发生。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身就是一个双元素列表 $[D_{\\mathrm{H}}(r), D_{\\mathrm{K}}(r)]$（单位为厘摩 cM），每个值都四舍五入到 $6$ 位小数。具体来说，输出必须如下所示：\n\"[[D_H(r_1),D_K(r_1)],[D_H(r_2),D_K(r_2)],...,[D_H(r_6),D_K(r_6)]]\"\n所有数字都四舍五入到 $6$ 位小数，且没有附加文本。",
            "solution": "所陈述的问题经过了严格的验证。\n\n### 第 1 步：提取已知条件\n- **任务**：使用 Haldane 和 Kosambi 映射函数，根据重组频率 $r$ 计算遗传图距 $D$。\n- **输入数据**：一组固定的重组频率 $r$：$[0.0, 0.01, 0.1, 0.2, 0.3, 0.49]$。\n- **$r$ 的定义域**：$r \\in [0, 0.5)$。提供的测试用例均在此定义域内。\n- **映射函数**：Haldane 函数 $D_{\\mathrm{H}}(r)$ 和 Kosambi 函数 $D_{\\mathrm{K}}(r)$。问题未提供具体公式，但假定它们是标准的领域知识。\n- **输出单位**：距离必须以厘摩（cM）为单位。\n- **精度**：结果必须四舍五入到 $6$ 位小数。\n- **输出格式**：表示列表之列表的单行字符串：`[[D_H(r_1),D_K(r_1)],...,[D_H(r_6),D_K(r_6)]]`。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于经典遗传学和群体遗传学的基本原理，特别是遗传连锁和作图。重组频率、图距、Haldane 函数和 Kosambi 函数的概念是该领域中标准的、成熟的模型。该问题在科学上是合理的。\n- **适定性**：对于指定的 $r$ 定义域，映射函数在数学上是适定的。对于每个有效的输入 $r$，都存在 $D_{\\mathrm{H}}(r)$ 和 $D_{\\mathrm{K}}(r)$ 的唯一、稳定的解。\n- **客观性**：问题以客观、正式的语言陈述。它要求基于已建立的科学模型进行定量计算。\n- **完整性**：虽然问题省略了映射函数的显式公式，但这些在遗传学中是经典公式。对于该领域的专家来说，省略这些公式并不会使问题变得不完整。这些公式被普遍认为是：\n    - Haldane 函数：$D_{\\mathrm{H}}(r) = -50 \\ln(1 - 2r)$ cM。\n    - Kosambi 函数：$D_{\\mathrm{K}}(r) = 25 \\ln\\left(\\frac{1+2r}{1-2r}\\right)$ cM。\n    有了这些领域特定知识，问题就完全明确了。\n- **其他缺陷**：该问题没有表现出其他缺陷，如矛盾、不可行性或不可验证性。\n\n### 第 3 步：结论与行动\n问题是**有效的**。我们将继续提供完整的解决方案。\n\n该问题要求使用两种不同的模型根据重组频率计算遗传图距。遗传图距 $D$ 量化了染色体上两个基因座之间的距离。它通常以厘摩（cM）为单位，其中 $1$ cM 对应于基因座之间 $1\\%$ 的重组机会。重组频率 $r$ 是可观察到的重组后代比例，对于非连锁基因座，其理论最大值为 $0.5$。映射函数提供了可观察的 $r$ 与理论图距 $D$ 之间的数学关系，该图距被定义为每次减数分裂的预期交换次数。\n\n图距的单位是摩根（Morgan），等于 $100$ 厘摩。以摩根为单位的距离，我们记为 $m$，与下面的函数直接相关。要求的输出以 cM 为单位，因此需要乘以系数 $100$。\n\n**Haldane 映射函数**\n该函数假设交换遵循泊松过程，即一个位置的交换不影响另一位置发生交换的概率（无干涉）。如果两个基因座之间发生奇数次交换，则会发生重组事件。重组频率 $r$ 与以摩根为单位的图距 $m$ 之间的关系为：\n$$r = \\frac{1}{2}(1 - e^{-2m})$$\n求解 $m$，我们得到以摩根为单位的距离：\n$$m = -\\frac{1}{2}\\ln(1-2r)$$\n为了以厘摩表示此距离，我们乘以 $100$。因此，Haldane 距离 $D_{\\mathrm{H}}(r)$ 为：\n$$D_{\\mathrm{H}}(r) = 100 \\times m = -50 \\ln(1-2r)$$\n该函数在 $1-2r > 0$（即 $r  0.5$）时有定义。\n\n**Kosambi 映射函数**\n该函数引入了交换干涉的概念，即一次交换的发生会降低附近发生另一次交换的概率。该模型得出以下关系：\n$$r = \\frac{1}{2}\\tanh(2m)$$\n其中 $\\tanh$ 是双曲正切函数。为了求出图距，我们求解 $m$：\n$$m = \\frac{1}{2}\\text{arctanh}(2r)$$\n其中 $\\text{arctanh}$ 是反双曲正切函数。利用恒等式 $\\text{arctanh}(x) = \\frac{1}{2}\\ln\\left(\\frac{1+x}{1-x}\\right)$，我们可以写出：\n$$m = \\frac{1}{2} \\times \\frac{1}{2} \\ln\\left(\\frac{1+2r}{1-2r}\\right) = \\frac{1}{4} \\ln\\left(\\frac{1+2r}{1-2r}\\right)$$\n转换为厘摩，Kosambi 距离 $D_{\\mathrm{K}}(r)$ 为：\n$$D_{\\mathrm{K}}(r) = 100 \\times m = 25 \\ln\\left(\\frac{1+2r}{1-2r}\\right)$$\n该函数在 $|2r|  1$ 时有定义，考虑到 $r \\ge 0$，这对应于 $r  0.5$。\n\n对于较小的 $r$ 值，两个函数都近似于 $D \\approx 100r$，这可以通过泰勒展开来证明。当 $r$ 接近 $0.5$ 时，预测的距离会发散，其中 Haldane 函数因其无干涉的假设会预测出更大的图距。\n\n**计算算法**\n解决方案的实现将按以下步骤进行：\n1.  定义待测试的重组频率 $r$ 列表：$[0.0, 0.01, 0.1, 0.2, 0.3, 0.49]$。\n2.  遍历测试集中的每个 $r$ 值。\n3.  对于每个 $r$：\n    a. 如果 $r = 0.0$，则 $D_{\\mathrm{H}}(0)$ 和 $D_{\\mathrm{K}}(0)$ 解析上均为 $0$。\n    b. 如果 $r  0$，计算 $D_{\\mathrm{H}}(r) = -50 \\ln(1-2r)$ 和 $D_{\\mathrm{K}}(r) = 25 \\ln\\left(\\frac{1+2r}{1-2r}\\right)$。\n4.  将每个计算出的距离四舍五入到 $6$ 位小数。\n5.  将每对结果 $[D_{\\mathrm{H}}(r), D_{\\mathrm{K}}(r)]$ 存储在一个列表中。\n6.  将最终的结果列表格式化为指定的字符串格式，确保不含空格。\n系统地应用这些公式将产生所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes genetic map distances using Haldane and Kosambi mapping functions\n    for a fixed suite of recombination frequencies.\n    \"\"\"\n    \n    # Define the test cases for recombination frequency r.\n    test_cases = [0.0, 0.01, 0.1, 0.2, 0.3, 0.49]\n\n    results = []\n    for r in test_cases:\n        # The recombination frequency r must be in the interval [0, 0.5).\n        # The problem statement guarantees this for the test suite.\n\n        # Handle the edge case r = 0 separately to avoid log(1) computation\n        # and potential floating point inaccuracies, though it would evaluate correctly.\n        # Both D_H(0) and D_K(0) are 0.\n        if r == 0.0:\n            d_h = 0.0\n            d_k = 0.0\n        else:\n            # Haldane's mapping function: D_H(r) = -50 * ln(1 - 2r) cM\n            # The distance D is measured in centiMorgans (cM).\n            # The map distance in Morgans is m = -0.5 * ln(1 - 2r).\n            # D = 100 * m.\n            d_h = -50.0 * np.log(1.0 - 2.0 * r)\n\n            # Kosambi's mapping function: D_K(r) = 25 * ln((1 + 2r) / (1 - 2r)) cM\n            # The map distance in Morgans is m = 0.5 * arctanh(2r)\n            # D = 100 * m = 50 * arctanh(2r).\n            # Using the identity arctanh(x) = 0.5 * ln((1+x)/(1-x)), this is equivalent to\n            # D = 25 * ln((1 + 2r) / (1 - 2r)).\n            d_k = 25.0 * np.log((1.0 + 2.0 * r) / (1.0 - 2.0 * r))\n\n        # Round results to 6 decimal places as required.\n        d_h_rounded = round(d_h, 6)\n        d_k_rounded = round(d_k, 6)\n        \n        results.append([d_h_rounded, d_k_rounded])\n\n    # Format the output string to match the exact requirement:\n    # \"[[D_H(r_1),D_K(r_1)],[D_H(r_2),D_K(r_2)],...,[D_H(r_6),D_K(r_6)]]\"\n    # Using str() and replace() is a robust way to match the specified format\n    # which has no spaces.\n    output_string = str(results).replace(\" \", \"\")\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "孟德尔遗传不仅解释了简单的性状遗传，其原理也构成了许多复杂生物学模式的基础，三色猫的毛色就是一个极佳的视觉案例。这种独特的斑块图案源于X染色体连锁遗传与随机的X染色体失活过程的结合。本练习将引导你构建一个计算模型，通过模拟细胞克隆性扩张来重现这一过程，让你亲身体验如何将基础遗传规则与发育过程相结合，从而理解简单基因型如何涌现出复杂的表型。",
            "id": "2403838",
            "problem": "您需要通过构建一个离散组织上X染色体随机失活的数学指定模型，来形式化并模拟家猫橙色基因座上杂合子雌性符合孟德尔遗传的X连锁镶嵌现象。考虑一个大小为 $N \\times N$ 的方形晶格，由整数坐标 $(i,j)$ 索引，其中 $i \\in \\{0,1,\\dots,N-1\\}$ 且 $j \\in \\{0,1,\\dots,N-1\\}$。每个晶格点代表观察时刻的一个体细胞。使用以给定非负整数种子 $r$ 初始化的伪随机数生成器（PRNG），从 $N^2$ 个晶格点中无放回地均匀随机选择一组 $M$ 个不同的创始点 $\\{s_k\\}_{k=1}^M$。每个创始点 $s_k$ 独立地使其两个X染色体中的一个失活，从而使得活化的X染色体在一个X连锁基因座上编码橙色或非橙色色素。将创始点的表达状态记为 $S_k \\in \\{0,1\\}$，其中 $S_k=1$ 表示橙色表达，$S_k=0$ 表示非橙色表达。随机变量 $S_k$ 服从参数为 $p \\in [0,1]$ 的伯努利分布 $\\mathrm{Bernoulli}(p)$，且对于不同的 $k$ 是独立的。\n\n按如下方式对克隆扩张进行几何建模。对于任意晶格点 $u=(i,j)$ 和任意创始点 $s_k=(x_k,y_k)$，定义曼哈顿距离\n$$\nd_1(u,s_k) = |i-x_k| + |j-y_k|.\n$$\n将每个晶格点 $u$ 分配给使 $d_1(u,s_k)$ 在 $k \\in \\{1,\\dots,M\\}$ 上最小化的创始点索引集合中的一个索引。如果最小化子是唯一的，则选择它。如果有多个最小化子，则使用以种子 $r$ 初始化的同一PRNG（并从其之前所有使用的状态继续）在这些最小化子中均匀随机选择一个。令 $f(u) \\in \\{1,\\dots,M\\}$ 表示为 $u$ 选择的创始点索引。那么点 $u$ 的表达状态为 $G(u) = S_{f(u)} \\in \\{0,1\\}$。将这些状态收集到一个 $N \\times N$ 的网格 $G$ 中，其中 $G_{ij} = G((i,j))$。\n\n对于下面测试套件中给出的每个参数集 $(N,M,p,r)$，计算以下四个定量输出：\n\n1) 橙色分数 $F$，定义为\n$$\nF = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} G_{ij}.\n$$\n报告 $F$ 的值，四舍五入到 $6$ 位小数。\n\n2) 橙色斑块数量 $C$，定义为在顶点集 $\\{(i,j) \\mid G_{ij}=1\\}$ 上，使用4-邻接（如果两个点的坐标在一个维度上恰好相差1，而在另一维度上相等，则它们是相邻的）的导出子图中的连通分量数。报告 $C$ 为一个整数。\n\n3) 平均橙色斑块面积 $A$，定义为\n$$\nA = \n\\begin{cases}\n\\frac{1}{C}\\sum_{c=1}^{C} |P_c|,  \\text{if } C \\ge 1,\\\\\n0,  \\text{if } C=0,\n\\end{cases}\n$$\n其中 $P_c$ 是属于第 $c$ 个橙色连通分量的晶格点集合，而 $|P_c|$ 是其基数。报告 $A$ 的值，四舍五入到 $6$ 位小数。\n\n4) 界面长度 $L$，定义为在4-邻接条件下，状态不同的相邻晶格点之间的边数：\n$$\nL = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-2} \\mathbf{1}[G_{i,j} \\ne G_{i,j+1}] \\;+\\; \\sum_{i=0}^{N-2}\\sum_{j=0}^{N-1} \\mathbf{1}[G_{i,j} \\ne G_{i+1,j}],\n$$\n报告为一个整数。\n\n所有随机性必须使用指定的、带有给定种子 $r$ 的PRNG生成，首先用于采样创始点位置，然后用于采样创始点状态，最后用于在将晶格点分配给创始点时解决任何距离平局问题。\n\n测试套件。严格按此顺序使用以下参数集：\n- 情况 $1$：$(N,M,p,r) = (8,5,0.5,42)$。\n- 情况 $2$：$(N,M,p,r) = (1,1,0.5,7)$。\n- 情况 $3$：$(N,M,p,r) = (10,1,0.5,123)$。\n- 情况 $4$：$(N,M,p,r) = (12,30,0.8,314159)$。\n- 情况 $5$：$(N,M,p,r) = (6,36,0.3,271828)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按顺序排列的每个情况的结果记录列表，且没有空格。每个记录都是该情况下的列表 $[F,C,A,L]$。因此，整个输出必须是形如 $[[F_1,C_1,A_1,L_1],[F_2,C_2,A_2,L_2],\\dots,[F_5,C_5,A_5,L_5]]$ 的单行，其中 $F_k$ 和 $A_k$ 四舍五入到 $6$ 位小数，而 $C_k$ 和 $L_k$ 是整数。",
            "solution": "其生物学基础是雌性哺乳动物中X连锁基因座上的孟德尔分离定律与随机X染色体失活相结合。一个基因型为 $X^O X^B$ 的杂合子雌性在一个X连锁色素基因座上携带两个等位基因：一个橙色等位基因和一个非橙色等位基因。在早期胚胎发生过程中，随机的X染色体失活导致每个体细胞谱系失活一个X染色体，从而在该谱系中固定了活化的等位基因。可观察到的镶嵌体是表达橙色或非橙色色素的克隆在空间上的混合。这个过程可以抽象为占据空间的独立创始谱系，并为每个谱系分配一个表达状态。\n\n我们将其形式化如下。考虑一个 $N \\times N$ 的离散晶格，代表被细胞占据的点。设 $\\{s_k\\}_{k=1}^M$ 是使用带有种子 $r$ 的固定种子伪随机数生成器（PRNG），从 $N^2$ 个晶格点中无放回地均匀随机放置的 $M$ 个创始点。每个创始点 $k$ 被分配一个独立的表达状态 $S_k \\in \\{0,1\\}$，其分布为 $\\mathrm{Bernoulli}(p)$，其中 $S_k=1$ 表示橙色等位基因活化（橙色表达），$S_k=0$ 表示非橙色等位基因活化（非橙色表达）。这模拟了孟德尔杂合状态与随机X失活的结合，其中 $p$ 允许存在可能的偏斜。\n\n为了将创始点映射到所有晶格点，我们为任意点 $u=(i,j)$ 和创始点 $s_k=(x_k,y_k)$ 定义曼哈顿距离\n$$\nd_1(u,s_k) = |i-x_k| + |j-y_k|.\n$$\n这在 $L_1$ 度量下产生了一个类似沃罗诺伊的划分：每个点 $u$ 被分配给使 $d_1(u,s_k)$ 在 $k \\in \\{1,\\dots,M\\}$ 上最小化的创始点索引集合中的一个索引。如果最小化子是唯一的，则选择它；如果有多个最小化子，则使用同一个PRNG（从其当前状态继续，从而使所有随机性都由单个种子 $r$ 全局耦合）随机选择一个。用 $f(u)$ 表示所选的创始点索引。那么 $u$ 处的表达为 $G(u) = S_{f(u)}$，产生一个网格 $G \\in \\{0,1\\}^{N \\times N}$，其中 $G_{ij} = G((i,j))$。\n\n根据 $G$，计算所需的四个输出：\n\n1) 橙色分数为\n$$\nF = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} G_{ij}.\n$$\n这是表达橙色的点的经验比例。在以随机创始点和状态为条件的期望中，$\\mathbb{E}[F]=p$，尽管有限尺寸的几何形状和决平局机制会引入围绕 $p$ 的采样变异性。报告值必须四舍五入到 $6$ 位小数。\n\n2) 橙色斑块的数量 $C$ 是由 $\\{(i,j) : G_{ij}=1\\}$ 使用4-邻接诱导的子图中的连通分量数。这通过扫描网格并对 $G_{ij}=1$ 的点执行广度优先或深度优先搜索来计算，标记已访问的点以避免重复计数。每次找到一个未访问的橙色点时，就启动一个新的分量，并访问所有可通过4-邻接移动到达的橙色点；此类启动的总数等于 $C$。\n\n3) 平均橙色斑块面积 $A$ 是\n$$\nA = \n\\begin{cases}\n\\frac{1}{C}\\sum_{c=1}^{C} |P_c|,  C \\ge 1,\\\\\n0,  C=0,\n\\end{cases}\n$$\n其中 $P_c$ 是第 $c$ 个橙色连通分量中的晶格点集。因为这些分量构成了橙色点的一个划分，所以 $\\sum_{c=1}^{C} |P_c| = \\sum_{i,j} G_{ij}$，因此当 $C \\ge 1$ 时，$A$ 等于橙色点的总数除以 $C$；当没有橙色点时，$A$ 等于 $0$。报告值必须四舍五入到 $6$ 位小数。\n\n4) 界面长度 $L$ 是在4-邻接下具有不同状态的相邻点对的数量。为避免重复计数，分别对水平差异和垂直差异求和：\n$$\nL = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-2} \\mathbf{1}[G_{i,j} \\ne G_{i,j+1}] \\;+\\; \\sum_{i=0}^{N-2}\\sum_{j=0}^{N-1} \\mathbf{1}[G_{i,j} \\ne G_{i+1,j}],\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。这将产生一个整数。\n\n带有种子 $r$ 的PRNG按顺序在三个地方一致地使用：无放回地采样 $M$ 个创始点，采样 $M$ 个独立的创始点状态 $S_k \\sim \\mathrm{Bernoulli}(p)$，以及在将点分配给创始点时解决任何距离平局问题。这完全确定了每个情况的 $G$ 和输出。最终程序必须输出一个单行，其中包含5个记录，每个测试用例一个，每个记录为 $[F,C,A,L]$，其中 $F$ 和 $A$ 四舍五入到6位小数， $C$ 和 $L$ 为整数，没有空格，并按测试套件中指定的顺序排列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sample_founders(N, M, rng):\n    # Sample M distinct lattice indices from N*N sites\n    total = N * N\n    flat_indices = rng.choice(total, size=M, replace=False)\n    rows = flat_indices // N\n    cols = flat_indices % N\n    founders = np.stack([rows, cols], axis=1)  # shape (M, 2)\n    return founders\n\ndef sample_founder_states(M, p, rng):\n    # Bernoulli(p) for each founder: True for orange (1), False for non-orange (0)\n    return rng.random(M)  p\n\ndef assign_sites_to_founders(N, founders, rng):\n    # For each site, compute Manhattan distances to all founders and choose minimizer\n    M = founders.shape[0]\n    assigned = np.empty((N, N), dtype=np.int32)\n    # Pre-extract founder coords for vectorized distance computation per cell\n    f_rows = founders[:, 0]\n    f_cols = founders[:, 1]\n    for i in range(N):\n        for j in range(N):\n            # Manhattan distances to all founders\n            dists = np.abs(f_rows - i) + np.abs(f_cols - j)\n            min_dist = dists.min()\n            candidates = np.flatnonzero(dists == min_dist)\n            if candidates.size == 1:\n                assigned[i, j] = candidates[0]\n            else:\n                # Randomly choose among ties\n                assigned[i, j] = rng.choice(candidates)\n    return assigned\n\ndef count_orange_components_and_sizes(grid):\n    # grid: boolean or 0/1 array of shape (N, N)\n    N = grid.shape[0]\n    visited = np.zeros_like(grid, dtype=bool)\n    comp_sizes = []\n    # 4-neighbor directions\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for i in range(N):\n        for j in range(N):\n            if grid[i, j] and not visited[i, j]:\n                # Start BFS\n                stack = [(i, j)]\n                visited[i, j] = True\n                size = 0\n                while stack:\n                    r, c = stack.pop()\n                    size += 1\n                    for dr, dc in dirs:\n                        rr, cc = r + dr, c + dc\n                        if 0 = rr  N and 0 = cc  N:\n                            if grid[rr, cc] and not visited[rr, cc]:\n                                visited[rr, cc] = True\n                                stack.append((rr, cc))\n                comp_sizes.append(size)\n    return len(comp_sizes), comp_sizes\n\ndef interface_length(grid):\n    # Count horizontal and vertical interfaces where neighbors differ\n    horiz = np.sum(grid[:, :-1] != grid[:, 1:])\n    vert = np.sum(grid[:-1, :] != grid[1:, :])\n    return int(horiz + vert)\n\ndef run_case(N, M, p, r):\n    rng = np.random.default_rng(r)\n    founders = sample_founders(N, M, rng)\n    founder_states = sample_founder_states(M, p, rng)\n    assigned = assign_sites_to_founders(N, founders, rng)\n    grid = founder_states[assigned].astype(np.int8)  # 1 for orange, 0 for non-orange\n\n    total_cells = N * N\n    orange_count = int(grid.sum())\n    F = orange_count / total_cells\n\n    C, sizes = count_orange_components_and_sizes(grid.astype(bool))\n    if C > 0:\n        A = orange_count / C\n    else:\n        A = 0.0\n\n    L = interface_length(grid)\n\n    # Round floats to 6 decimal places for output formatting\n    F = round(F + 0.0, 6)\n    A = round(A + 0.0, 6)\n\n    return (F, C, A, L)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, M, p, r)\n    test_cases = [\n        (8, 5, 0.5, 42),\n        (1, 1, 0.5, 7),\n        (10, 1, 0.5, 123),\n        (12, 30, 0.8, 314159),\n        (6, 36, 0.3, 271828),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, p, r = case\n        F, C, A, L = run_case(N, M, p, r)\n        results.append((F, C, A, L))\n\n    # Build exact output string with no spaces, floats with 6 decimals\n    record_strs = []\n    for F, C, A, L in results:\n        # Ensure fixed 6 decimal places for floats\n        record_strs.append(f\"[{F:.6f},{C},{A:.6f},{L}]\")\n    output = \"[\" + \",\".join(record_strs) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}