{
    "hands_on_practices": [
        {
            "introduction": "理解嘌呤和嘧啶是掌握分子生物学核心原理的第一步。DNA双螺旋结构的稳定性及其遗传信息的精确复制，都建立在碱基互补配对原则之上。本练习将通过一个基础的定量问题，帮助你实践和巩固由Erwin Chargaff发现的著名碱基配对规则，即腺嘌呤（A）与胸腺嘧啶（T）配对，鸟嘌呤（G）与胞嘧啶（C）配对。通过计算给定DNA分子中一种碱基的含量，你将能推导出另一种碱基的预期比例，从而加深对DNA化学计量的理解 。",
            "id": "1516170",
            "problem": "一位分子生物学家正在分析一种新发现的嗜极细菌的基因组。该基因组被发现由一个单一的线性双链脱氧核糖核酸 (DNA) 分子组成。通过碱基组成分析，确定胞嘧啶碱基占分子中总含氮碱基的22.0%。假设标准的Watson-Crick碱基配对原则决定了该DNA的结构，计算腺嘌呤碱基的预期比例。\n\n将您的答案以小数形式表示，并四舍五入到三位有效数字。",
            "solution": "设双链DNA中四种碱基的比例分别为 $p_{A}$、$p_{T}$、$p_{G}$ 和 $p_{C}$。标准的Watson-Crick配对蕴含了Chargaff’s rules：$p_{A} = p_{T}$ 且 $p_{G} = p_{C}$。这些比例的总和必须为1：\n$$\np_{A} + p_{T} + p_{G} + p_{C} = 1.\n$$\n已知 $p_{C} = 0.220$，则有 $p_{G} = p_{C} = 0.220$。因此\n$$\np_{A} + p_{T} = 1 - (p_{G} + p_{C}) = 1 - 2p_{C}.\n$$\n使用 $p_{A} = p_{T}$ 可得\n$$\n2p_{A} = 1 - 2p_{C} \\quad \\Rightarrow \\quad p_{A} = \\frac{1 - 2p_{C}}{2}.\n$$\n代入 $p_{C} = 0.220$，\n$$\np_{A} = \\frac{1 - 0.440}{2} = \\frac{0.560}{2} = 0.280.\n$$\n四舍五入到三位有效数字，腺嘌呤的预期比例为 $0.280$。",
            "answer": "$$\\boxed{0.280}$$"
        },
        {
            "introduction": "掌握了碱基配对的化学计量规则后，我们进一步探讨其在生物学功能中的物理意义。嘌呤与嘧啶的配对不仅仅是化学上的偏好，更是维持DNA双螺旋结构恒定宽度的几何要求。这个练习将引导你思考，当这一规则被打破时——例如，一个嘌呤错误地与另一个嘌呤配对——会在DNA聚合酶的活性位点内引发怎样的物理后果。通过分析这种错配引起的空间位阻，你将能更深刻地理解DNA复制保真度的结构基础 。",
            "id": "1516177",
            "problem": "考虑一个假设的DNA（脱氧核糖核酸）聚合酶，它在合成DNA方面功能正常，但完全缺乏3'到5'的外切酶活性，这意味着它没有校对能力。在以一条模板链进行DNA复制的过程中，该酶遇到了一个鸟嘌呤（G）碱基。聚合酶没有掺入正确的互补碱基胞嘧啶（C），而是在鸟嘌呤的对面，错误地将一个腺嘌呤（A）核苷酸掺入到正在增长的链中。\n\n下列哪个陈述最准确地描述了这种嘌呤-嘌呤错配会在聚合酶活性位点内对DNA双螺旋结构造成的主要物理扭曲？\n\nA. 产生的G-A配对比标准碱基对要宽得多，形成一个凸起，与活性位点的氨基酸残基产生空间位阻。\n\nB. G-A配对比标准碱基对要窄得多，导致DNA双螺旋向内塌陷，并与活性位点中的关键催化残基失去接触。\n\nC. 这种错配会阻止碱基之间形成任何氢键，导致新加入的腺嘌呤立即解离。\n\nD. 不正确的配对会在糖-磷酸骨架中引起一个剧烈、不自然的弯曲，从而在错配碱基的上游立即断开磷酸二酯键。\n\nE. G-A配对的宽度与正确的G-C配对相同，因此不会发生物理扭曲，但碱基之间的电子排斥会使酶不稳定。",
            "solution": "DNA双螺旋通过一个嘌呤与一个嘧啶配对来维持近乎恒定的螺旋直径；这保持了均匀的C1'-到-C1'距离，并符合聚合酶活性位点为识别和稳定而优化的Watson-Crick几何结构。像$G$与$A$相对这样的嘌呤-嘌呤错配，会将两个较大的双环碱基彼此相对放置，相对于一个标准的$G$-$C$配对，增加了局部碱基对的宽度。聚合酶活性位点为正确的Watson-Crick配对强制要求形状互补性和特定的几何结构；因此，一个加宽的嘌呤-嘌呤配对会产生一个空间凸起，与活性位点中的氨基酸残基发生冲突，并使复合物不稳定。\n\n根据这些原理评估选项：选项A正确地指出，$G$-$A$配对比标准碱基对更宽，并会在活性位点内造成空间位阻。选项B是错误的，因为嘌呤-嘌呤配对不会更窄。选项C是错误的，因为$G$-$A$错配可以采取摇摆或剪切几何构型，形成有限的氢键；立即解离并非活性位点内的主要效应。选项D是错误的，因为错配不会立即诱导磷酸二酯键断裂；骨架断裂需要特定的催化化学反应，并非仅由碱基对的几何结构驱动。选项E是错误的，因为$G$-$A$配对的宽度与$G$-$C$配对不同；主要的扭曲是空间扩张，而不仅仅是电子排斥。\n\n因此，最佳描述是嘌呤-嘌呤错配更宽，并导致一个凸起，从而在活性位点中引起空间位阻。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在，让我们将视角从单个碱基对的相互作用扩展到整个基因组序列的宏观分析。嘌呤和嘧啶这一简单的二元划分，实际上在基因组序列中蕴含着丰富的统计学特征，尤其是在区分编码区（外显子）和非编码区（内含子）等功能元件时。这个高级实践是一个计算生物学挑战，它要求你像生物信息学家一样思考，利用嘌呤/嘧啶序列景观的统计特性来构建一个线性分类器。请注意，该练习使用了一个假设性的数据集来清晰地阐释核心概念，其重点在于让你掌握如何将基础的化学特性转化为强大的计算分析工具 。",
            "id": "2423535",
            "problem": "您将获得一些短的脱氧核糖核酸 (DNA) 片段，并且必须构建一个程序，该程序仅使用从其局部嘌呤和嘧啶组成中提取的特征来学习区分蛋白质编码外显子和内含子。嘌呤是腺嘌呤或鸟嘌呤，嘧啶是胞嘧啶或胸腺嘧啶。训练集包含带标签的序列。测试集包含不带标签的序列。您的程序必须从嘌呤/嘧啶图景中计算特征，在训练集上拟合一个有原则的线性分类器，并按规定格式输出对测试集的预测。\n\n使用的基本依据和假设：\n- 编码理论：遗传密码以长度为 $3$ 的密码子读取，蛋白质编码外显子反映了密码子结构。内含子不编码氨基酸，缺乏密码子对齐的约束。\n- 定义：对于长度为 $L$ 的序列中的位置 $i$，将每个核苷酸映射到一个二元指示符 $x_i$，如果碱基是嘌呤（腺嘌呤或鸟嘌呤），则 $x_i = 1$；如果是嘧啶（胞嘧啶或胸腺嘧啶），则 $x_i = 0$。\n- 定义：从二元序列 $(x_1,\\dots,x_L)$ 中定义以下特征：\n  1. 嘌呤分数 $f_1 = \\frac{1}{L}\\sum_{i=1}^L x_i$。\n  2. 标准差 $f_2 = \\sqrt{\\frac{1}{L}\\sum_{i=1}^L (x_i - \\bar{x})^2}$，其中 $\\bar{x} = \\frac{1}{L}\\sum_{i=1}^L x_i$。\n  3. 滞后-$3$ 自相关系数 $f_3 = \\rho_3$，定义为\n     $$\\rho_3 = \\begin{cases}\n     \\dfrac{\\sum_{i=1}^{L-3} (x_i - \\bar{x})(x_{i+3} - \\bar{x})}{(L-3)\\, f_2^2},  \\text{若 } f_2^2 > 0,\\\\\n     0,  \\text{若 } f_2^2 = 0.\n     \\end{cases}$$\n  4. 游程长度对比度 $f_4 = \\mathbb{E}[L_R] - \\mathbb{E}[L_Y]$，其中 $\\mathbb{E}[L_R]$ 是嘌呤（$x_i = 1$）连续游程的平均长度，$\\mathbb{E}[L_Y]$ 是嘧啶（$x_i = 0$）连续游程的平均长度。如果一个序列不包含某种类型的游程，则按惯例将相应的平均值定义为 $0$。\n\n分类器设计要求：\n- 基于以下概率建模原则训练一个线性分类器：假设特征向量来自具有共享协方差矩阵和相等类先验概率的类条件多元正态分布；学习一个能够区分这两个类的线性决策规则。实现不得依赖于允许范围之外的任何外部数据或库。程序必须是完全确定性的。\n\n程序中需要硬编码的输入：\n- 训练集：八个带标签的序列，标签 $1$ 代表外显子， $0$ 代表内含子。每个序列都指定为一个基序的精确重复：\n  - 外显子序列（标签 $1$）：\n    1. 将基序 \"AAT\" 精确重复 $30$ 次。\n    2. 将基序 \"GAA\" 精确重复 $30$ 次。\n    3. 将基序 \"CCG\" 精确重复 $30$ 次。\n    4. 将基序 \"ATG\" 精确重复 $30$ 次。\n  - 内含子序列（标签 $0$）：\n    1. 将基序 \"ACGT\" 精确重复 $24$ 次。\n    2. 将基序 \"TCGA\" 精确重复 $24$ 次。\n    3. 将基序 \"TTTCCCTTTCCC\" 精确重复 $5$ 次。\n    4. 将基序 \"AGCT\" 精确重复 $24$ 次。\n\n- 测试套件：六个待分类的无标签序列，通过将指定的基序重复指定的次数来构建：\n  1. 将 \"AAT\" 精确重复 $20$ 次。\n  2. 将 \"ACGT\" 精确重复 $15$ 次。\n  3. 将 \"TTTCCCTTTCCC\" 精确重复 $3$ 次。\n  4. 将 \"ATG\" 精确重复 $20$ 次。\n  5. 一个由 $60$ 个腺嘌呤 (\"A\") 组成的序列。\n  6. 将 \"AGCT\" 精确重复 $15$ 次。\n\n算法和实现要求：\n- 使用嘌呤/嘧啶指示符的定义，将每个序列映射到 $(x_1,\\dots,x_L)$。\n- 为每个序列计算特征向量 $(f_1,f_2,f_3,f_4)$。\n- 在训练特征向量上，使用共享协方差高斯假设和相等的先验概率来拟合线性分类器，并用它来预测测试特征向量的标签。所有计算必须使用有限维线性代数执行。如果任何协方差矩阵是奇异的或病态的，您必须使用 Moore–Penrose 伪逆。\n- 所有中间量必须使用浮点运算进行计算。不涉及物理单位或角度。\n- 需明确处理的边界情况：\n  - 如果 $f_2^2 = 0$，则设 $\\rho_3 = 0$。\n  - 如果没有嘌呤游程或没有嘧啶游程，在计算 $f_4$ 时，将相应的平均游程长度设为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个测试序列的预测标签，形式为用方括号括起来的逗号分隔整数列表，例如，\"[1,0,1,1,0,0]\"。顺序必须与上面列出的顺序一致。\n\n答案规范：\n- 输出为集合 $\\{0,1\\}$ 中的整数。\n\n您的程序必须是完整且可直接运行的。它不得读取任何外部输入。它必须只使用指定的库。",
            "solution": "所提出的问题是计算生物学中的一个二元分类任务：区分对应于外显子的脱氧核糖核酸 (DNA) 序列与对应于内含子的序列。这项任务必须通过构建一个仅基于从序列的局部嘌呤和嘧啶组成中提取的特征的线性分类器来完成。该问题定义明确，有科学依据，并为获得唯一的、可验证的解决方案提供了所有必要的数据和约束。\n\n解决方案分为三个主要阶段。首先，我们形式化特征提取过程，将每个 DNA 序列转换为一个低维数值向量。其次，我们根据问题陈述的要求，从第一性原理推导线性分类器。第三，我们概述了训练分类器和预测测试序列标签的完整算法流程。\n\n**1. 从嘌呤-嘧啶含量中进行特征工程**\n\n核心假设是，由于编码区存在密码子结构，外显子和内含子之间嘌呤和嘧啶分布的统计特性有所不同。我们首先将一个长度为 $L$ 的给定 DNA 序列转换为一个二元数值序列。\n\n设一个 DNA 序列表示为 $S = (s_1, s_2, \\dots, s_L)$，其中 $s_i \\in \\{\\text{'A'}, \\text{'C'}, \\text{'G'}, \\text{'T'}\\}$。我们为从 $1$ 到 $L$ 的每个位置 $i$ 定义一个二元指示变量 $x_i$。该映射基于核苷酸的化学分类：\n- 腺嘌呤 ('A') 和鸟嘌呤 ('G') 是嘌呤。\n- 胞嘧啶 ('C') 和胸腺嘧啶 ('T') 是嘧啶。\n\n二元序列 $\\mathbf{x} = (x_1, x_2, \\dots, x_L)$ 定义为：\n$$\nx_i = \\begin{cases} 1  \\text{若 } s_i \\text{ 是嘌呤 (A 或 G)} \\\\ 0  \\text{若 } s_i \\text{ 是嘧啶 (C 或 T)} \\end{cases}\n$$\n从这个二元序列中，我们计算一个 $4$ 维特征向量 $\\mathbf{f} = (f_1, f_2, f_3, f_4)$。\n\n**特征 $f_1$：嘌呤分数**\n该特征衡量了整体上偏向嘌呤的组成偏倚。它是二元序列的均值。\n$$ f_1 = \\bar{x} = \\frac{1}{L} \\sum_{i=1}^L x_i $$\n\n**特征 $f_2$：标准差**\n该特征衡量了嘌呤/嘧啶含量的局部变化。它是二元序列的标准差。一个具有均一组成（全为嘌呤或全为嘧啶）的序列将有 $f_2 = 0$。\n$$ f_2 = \\sqrt{\\frac{1}{L} \\sum_{i=1}^L (x_i - \\bar{x})^2} $$\n对于伯努利变量序列，方差就是 $f_2^2 = \\bar{x}(1-\\bar{x})$，但计算时使用直接公式。\n\n**特征 $f_3$：滞后-$3$ 自相关系数**\n这是检测编码潜力的最关键特征。遗传密码以密码子（核苷酸三联体）的形式读取。这给外显子序列的统计特性施加了周期为 $3$ 的周期性，而这种周期性在内含子中是不存在的。滞后-$3$ 自相关 $\\rho_3$ 旨在捕捉这一信号。\n$$\nf_3 = \\rho_3 = \\begin{cases}\n     \\dfrac{\\sum_{i=1}^{L-3} (x_i - \\bar{x})(x_{i+3} - \\bar{x})}{(L-3)\\, f_2^2},  \\text{若 } f_2^2 > 0,\\\\\n     0,  \\text{若 } f_2^2 = 0.\n     \\end{cases}\n$$\n对于一个具有强周期为 $3$ 的信号的序列，我们期望 $x_i \\approx x_{i+3}$，从而导致 $\\rho_3$ 的值很高且为正。对于随机序列，我们期望 $\\rho_3 \\approx 0$。\n\n**特征 $f_4$：游程长度对比度**\n该特征量化了连续嘌呤段与连续嘧啶段长度的差异。设 $\\mathbb{E}[L_R]$ 为嘌呤游程（其中 $x_i=1$）的平均长度，$\\mathbb{E}[L_Y]$ 为嘧啶游程（其中 $x_i=0$）的平均长度。\n$$ f_4 = \\mathbb{E}[L_R] - \\mathbb{E}[L_Y] $$\n按照惯例，如果一个序列不包含某种类型的游程（例如，一个全嘌呤序列没有嘧啶游程），则相应的平均长度定义为 $0$。\n\n**2. 分类器设计：线性判别分析**\n\n该问题要求基于一个特定的生成模型来训练一个线性分类器。我们假设每个类别 $k \\in \\{0, 1\\}$（其中 $1$ 是外显子，$0$ 是内含子）的特征向量都来自多元正态分布，$p(\\mathbf{f}|C_k) = \\mathcal{N}(\\mathbf{f} | \\boldsymbol{\\mu}_k, \\boldsymbol{\\Sigma}_k)$。问题规定了两个关键约束：协方差矩阵是共享的（$\\boldsymbol{\\Sigma}_1 = \\boldsymbol{\\Sigma}_0 = \\boldsymbol{\\Sigma}$）并且类先验概率是相等的（$P(C_1) = P(C_0) = 0.5$）。这个模型被称为线性判别分析 (LDA)。\n\n首先，我们从训练集中估计模型参数，该训练集包含 $N$ 个特征向量 $\\{\\mathbf{f}_i\\}_{i=1}^N$ 及其对应的标签 $\\{y_i\\}_{i=1}^N$。设 $N_1$ 为外显子样本数，$N_0$ 为内含子样本数。\n\n类均值 $\\boldsymbol{\\mu}_1$ 和 $\\boldsymbol{\\mu}_0$ 通过每个类内特征向量的样本均值来估计：\n$$ \\boldsymbol{\\mu}_k = \\frac{1}{N_k} \\sum_{i: y_i=k} \\mathbf{f}_i \\quad \\text{对于 } k \\in \\{0, 1\\} $$\n\n共享协方差矩阵 $\\boldsymbol{\\Sigma}$ 通过两个类的合并协方差来估计。这是一个无偏估计：\n$$ \\boldsymbol{\\Sigma} = \\frac{1}{N_0 + N_1 - 2} \\left[ \\sum_{i: y_i=0} (\\mathbf{f}_i - \\boldsymbol{\\mu}_0)(\\mathbf{f}_i - \\boldsymbol{\\mu}_0)^T + \\sum_{i: y_i=1} (\\mathbf{f}_i - \\boldsymbol{\\mu}_1)(\\mathbf{f}_i - \\boldsymbol{\\mu}_1)^T \\right] $$\n\n对新特征向量 $\\mathbf{f}$ 的分类基于从贝叶斯定理导出的后验概率比。如果 $P(C_1|\\mathbf{f}) > P(C_0|\\mathbf{f})$，我们将其分类为类别 $1$，这等同于比较它们的对数比是否大于 $0$。\n$$ \\ln\\frac{P(C_1|\\mathbf{f})}{P(C_0|\\mathbf{f})} = \\ln\\frac{p(\\mathbf{f}|C_1)P(C_1)}{p(\\mathbf{f}|C_0)P(C_0)} > 0 $$\n在先验概率相等的情况下，这简化为 $\\ln p(\\mathbf{f}|C_1) - \\ln p(\\mathbf{f}|C_0) > 0$。代入多元正态概率密度函数并简化，$\\mathbf{f}$ 的二次项会抵消，从而产生一个线性决策规则。\n$$ (\\mathbf{f} - \\boldsymbol{\\mu}_0)^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{f} - \\boldsymbol{\\mu}_0) - (\\mathbf{f} - \\boldsymbol{\\mu}_1)^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{f} - \\boldsymbol{\\mu}_1) > 0 $$\n展开并重新排列各项，得到决策函数：\n$$ \\mathbf{w}^T \\mathbf{f} - c > 0 $$\n其中权重向量 $\\mathbf{w}$ 和阈值 $c$ 定义为：\n$$ \\mathbf{w} = \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{\\mu}_1 - \\boldsymbol{\\mu}_0) $$\n$$ c = \\frac{1}{2} (\\boldsymbol{\\mu}_1^T \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}_1 - \\boldsymbol{\\mu}_0^T \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}_0) = \\mathbf{w}^T \\left( \\frac{\\boldsymbol{\\mu}_0 + \\boldsymbol{\\mu}_1}{2} \\right) $$\n根据指示，如果矩阵 $\\boldsymbol{\\Sigma}$ 是奇异的或病态的，则使用其 Moore-Penrose 伪逆 $\\boldsymbol{\\Sigma}^{\\dagger}$ 代替 $\\boldsymbol{\\Sigma}^{-1}$。\n对于一个测试向量 $\\mathbf{f}_{\\text{test}}$，最终的预测 $\\hat{y}$ 是：\n$$ \\hat{y} = \\begin{cases} 1  \\text{若 } \\mathbf{w}^T \\mathbf{f}_{\\text{test}} > c \\\\ 0  \\text{否则} \\end{cases} $$\n\n**3. 算法流程**\n\n实现过程是上述原理的直接转换。\n\n1.  **数据表示**：通过重复指定的基序来生成训练和测试序列。\n2.  **特征计算**：\n    -   创建一个函数，将 DNA 序列字符串映射为其二元嘌呤/嘧啶表示。\n    -   创建第二个函数，为任何给定的二元序列计算 $4$ 维特征向量 $(f_1, f_2, f_3, f_4)$。该函数必须正确实现指定的公式，并处理 $f_3$（当 $f_2=0$ 时）和 $f_4$（当某种类型的游程不存在时）的边界情况。\n3.  **训练阶段**：\n    -   为所有 $N_1=4$ 个外显子训练序列和所有 $N_0=4$ 个内含子训练序列计算特征向量。\n    -   计算类均值向量 $\\boldsymbol{\\mu}_0$ 和 $\\boldsymbol{\\mu}_1$。\n    -   计算合并协方差矩阵 $\\boldsymbol{\\Sigma}$。\n    -   使用数值线性代数程序计算伪逆 $\\boldsymbol{\\Sigma}^{\\dagger}$。\n    -   确定分类器权重向量 $\\mathbf{w}$ 和决策阈值 $c$。\n4.  **预测阶段**：\n    -   对于 $6$ 个测试序列中的每一个，计算其特征向量 $\\mathbf{f}_{\\text{test}}$。\n    -   对于每个 $\\mathbf{f}_{\\text{test}}$，计算判别分数 $S = \\mathbf{w}^T \\mathbf{f}_{\\text{test}}$。\n    -   将分数 $S$ 与阈值 $c$ 进行比较，以获得预测标签 $1$ 或 $0$。\n5.  **输出**：按指定顺序收集测试序列的预测标签，并将其格式化为单个输出字符串。\n\n这个严谨、循序渐进的流程确保了解决方案既符合问题的约束，又基于成熟的统计学原理。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA sequence classification problem.\n    The solution involves feature extraction, training a Linear Discriminant Analysis (LDA)\n    classifier, and predicting labels for a test set.\n    \"\"\"\n\n    # --- 1. Data Definition ---\n    # Training set\n    train_exons_motifs = [(\"AAT\", 30), (\"GAA\", 30), (\"CCG\", 30), (\"ATG\", 30)]\n    train_introns_motifs = [(\"ACGT\", 24), (\"TCGA\", 24), (\"TTTCCCTTTCCC\", 5), (\"AGCT\", 24)]\n    \n    train_exons = [m * r for m, r in train_exons_motifs]\n    train_introns = [m * r for m, r in train_introns_motifs]\n    \n    # Test set\n    test_motifs = [\n        (\"AAT\", 20),\n        (\"ACGT\", 15),\n        (\"TTTCCCTTTCCC\", 3),\n        (\"ATG\", 20),\n        (\"A\", 60),\n        (\"AGCT\", 15),\n    ]\n    test_sequences = [m * r for m, r in test_motifs]\n\n    # --- 2. Feature Extraction ---\n    \n    def dna_to_binary(seq):\n        \"\"\"Maps a DNA sequence to a binary purine(1)/pyrimidine(0) sequence.\"\"\"\n        purines = {'A', 'G'}\n        return np.array([1 if base in purines else 0 for base in seq], dtype=np.float64)\n\n    def compute_features(seq_str):\n        \"\"\"Computes the 4-dimensional feature vector for a DNA sequence.\"\"\"\n        L = len(seq_str)\n        if L == 0:\n            return np.zeros(4)\n\n        x = dna_to_binary(seq_str)\n        \n        # f1: Purine fraction\n        f1 = np.mean(x)\n\n        # f2: Standard deviation\n        # use np.var to avoid floating point issues from (x_i - mean(x))^2\n        var_x = np.var(x)\n        f2 = np.sqrt(var_x)\n\n        # f3: Lag-3 autocorrelation\n        if var_x > 1e-12:  # Check for f2^2 > 0 with tolerance\n            x_minus_mean = x - f1\n            numerator = np.sum(x_minus_mean[:-3] * x_minus_mean[3:])\n            denominator = (L - 3) * var_x\n            f3 = numerator / denominator if denominator != 0 else 0.0\n        else:\n            f3 = 0.0\n\n        # f4: Run-length contrast\n        if L > 0:\n            runs_R = []\n            runs_Y = []\n            current_run_type = x[0]\n            current_run_length = 1\n            for i in range(1, L):\n                if x[i] == current_run_type:\n                    current_run_length += 1\n                else:\n                    if current_run_type == 1:\n                        runs_R.append(current_run_length)\n                    else:\n                        runs_Y.append(current_run_length)\n                    current_run_type = x[i]\n                    current_run_length = 1\n            # Add the last run\n            if current_run_type == 1:\n                runs_R.append(current_run_length)\n            else:\n                runs_Y.append(current_run_length)\n\n            mean_R = np.mean(runs_R) if runs_R else 0.0\n            mean_Y = np.mean(runs_Y) if runs_Y else 0.0\n            f4 = mean_R - mean_Y\n        else:\n            f4 = 0.0\n            \n        return np.array([f1, f2, f3, f4])\n\n    # --- 3. Training the LDA Classifier ---\n\n    # Compute feature vectors for training data\n    features_exons = np.array([compute_features(s) for s in train_exons])\n    features_introns = np.array([compute_features(s) for s in train_introns])\n    \n    # Estimate parameters\n    mu1 = np.mean(features_exons, axis=0) # Exon mean\n    mu0 = np.mean(features_introns, axis=0) # Intron mean\n\n    N1 = len(features_exons)\n    N0 = len(features_introns)\n    \n    # Pooled covariance matrix\n    S1 = np.zeros((4, 4))\n    for f in features_exons:\n        diff = (f - mu1).reshape(4, 1)\n        S1 += diff @ diff.T\n\n    S0 = np.zeros((4, 4))\n    for f in features_introns:\n        diff = (f - mu0).reshape(4, 1)\n        S0 += diff @ diff.T\n        \n    # Unbiased estimate of shared covariance\n    pooled_sigma = (S1 + S0) / (N1 + N0 - 2)\n    \n    # Use Moore-Penrose pseudoinverse for stability\n    sigma_inv = np.linalg.pinv(pooled_sigma)\n\n    # Calculate LDA weights and threshold\n    w = sigma_inv @ (mu1 - mu0)\n    c = w @ (mu1 + mu0) / 2.0\n\n    # --- 4. Prediction on Test Set ---\n    \n    predictions = []\n    for seq in test_sequences:\n        f_test = compute_features(seq)\n        score = w @ f_test\n        prediction = 1 if score > c else 0\n        predictions.append(prediction)\n        \n    # --- 5. Output ---\n    \n    print(f\"[{','.join(map(str, predictions))}]\")\n\nsolve()\n```"
        }
    ]
}