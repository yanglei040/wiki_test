{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握密码子适应指数（CAI），最直接的方法就是亲手计算一次。这个练习  将引导你完成一个基因序列的CAI计算，让你熟悉其核心公式——相对适应性权重的几何平均值。通过这个基础练习，你将把理论定义转化为具体的计算技能。",
            "id": "2843211",
            "problem": "在原核生物基因组中，密码子使用模式反映了对翻译效率和准确性的选择，其理论基础是分子生物学中心法则和遗传密码的简并性。在许多细菌中，高表达基因表现出对同义密码子的偏好性使用，这些密码子与细胞内丰富的转运核糖核酸（tRNA）种类相匹配。这一观察启发了一种定量衡量方法，用于评估一个基因的密码子组成与一组高表达基因参考集的匹配程度。密码子适应指数（CAI）是根据从参考集中派生的密码子特异性相对适应度值构建的。其中，每个密码子的相对适应度可以通过多种方式获得，例如，将其相对同义密码子使用度（RSCU）与其同义密码子中的最大RSCU值进行归一化。\n\n给定一个信使核糖核酸（mRNA）编码序列（阅读框$+1$），它代表一个推定的开放阅读框，以一个典型的起始密码子开始，并以一个终止密码子结束（显示终止密码子是为了完整性，但不计入CAI评分）。该编码序列按 $5'$ 到 $3'$ 方向书写如下：\nAUG GCU GCU GAA GAA UUU UUC CGU CGC AGA UGG GCG AAG UAA.\n\n已经使用该生物体的一组高表达基因参考集，计算出了上述序列中出现的密码子的生物体特异性相对适应度权重 $w(\\text{codon})$。这些权重如下：\n- 甲硫氨酸 (AUG): $1.00$。\n- 丙氨酸 (GCU): $0.35$；丙氨酸 (GCG): $0.80$。\n- 谷氨酸 (GAA): $0.65$。\n- 苯丙氨酸 (UUU): $0.55$；苯丙氨酸 (UUC): $1.00$。\n- 精氨酸 (CGU): $0.40$；精氨酸 (CGC): $0.95$；精氨酸 (AGA): $0.85$。\n- 色氨酸 (UGG): $1.00$。\n- 赖氨酸 (AAG): $1.00$。\n\n任务：\n1. 从遗传密码的简并性和高表达基因中密码子使用偏好性的基本观察出发，提供一个精确的、研究生水平的密码子适应指数（CAI）定义，解释其如何由密码子特异性相对适应度值构建，并论证为何使用长度归一化的乘法聚合（而非加法聚合）。\n2. 仅使用起始密码子和末端终止密码子之间的密码子（不包括终止密码子本身），根据上述标准构建方法，计算该开放阅读框的CAI。计算中，单密码子氨基酸（甲硫氨酸和色氨酸）的权重取 $1$。将最终数值答案四舍五入至四位有效数字。CAI是无量纲的，请将其报告为一个纯数。",
            "solution": "所呈现的问题陈述在科学上是合理的、表述清晰且客观的。它基于分子遗传学和生物信息学的既定原则，特别是中心法则、遗传密码的简并性以及密码子使用偏好性的概念。所提供的数据——一个信使核糖核酸（mRNA）序列和一组密码子特异性相对适应度权重——对于所需的计算是充分且一致的。任务定义明确且可形式化。因此，该问题是有效的，将提供解答。\n\n问题包括两个任务：首先，为密码子适应指数（CAI）提供一个正式定义；其次，为给定序列计算其值。\n\n任务1：密码子适应指数（CAI）的定义\n\n密码子适应指数（CAI）的理论基础在于分子生物学的一些基本观察。遗传密码是简并的，这意味着大多数氨基酸由多个密码子编码，这些密码子被称为同义密码子。经验观察表明，特别是在快速分裂的微生物中，同义密码子的使用频率并不均等。这种现象被称为密码子使用偏好。得到大量证据支持的主流假说认为，这种偏好是自然选择作用于优化翻译效率和准确性的结果。那些必须以极高水平表达的基因，如核糖体蛋白或糖酵解酶的基因，表现出强烈的偏向，倾向于使用特定的“最优”密码子子集。这些最优密码子被细胞中最丰富的转运RNA（tRNA）种类识别，从而促进快速高效的多肽链延伸。\n\n基于这些原则，CAI是一个定量指标，旨在评估一个基因在多大程度上利用了这些偏好密码子。它在假设翻译选择是塑造其密码子使用模式主导力量的前提下，预测基因的表达水平。较高的CAI值表明一个基因可能高表达。\n\nCAI的构建过程如下：\n\n1.  为特定生物体定义一个高表达基因的参考集。该参考集被假定为代表了该生物体的“最优”密码子用法。\n\n2.  从该参考集中，计算出每个密码子 $c$ 的相对适应度 $w_c$。对于给定的氨基酸，参考集中使用最频繁的密码子被赋予1.0的相对适应度。该氨基酸的任何其他同义密码子 $c_i$ 的相对适应度是其使用频率 $f_i$ 与最常用密码子频率 $f_{\\text{max}}$ 的比率。\n    $$w_{c_i} = \\frac{f_i}{f_{\\text{max}}}$$\n    对于仅由一个密码子编码的氨基酸（由`AUG`编码的甲硫氨酸和由`UGG`编码的色氨酸），不存在密码子选择，其相对适应度定义为1.0。\n\n3.  对于一个长度为 $L$ 个密码子（不包括终止密码子）的给定基因，其CAI被计算为编码序列中每个密码子相对适应度值的几何平均数。如果 $w_k$ 是基因中第 $k$ 个密码子的相对适应度，则CAI由以下公式给出：\n    $$ \\text{CAI} = \\left( \\prod_{k=1}^{L} w_k \\right)^{\\frac{1}{L}} $$\n    这也可以等效地用对数表示，这种方式在数值上通常更稳定：\n    $$ \\text{CAI} = \\exp\\left( \\frac{1}{L} \\sum_{k=1}^{L} \\ln(w_k) \\right) $$\n\n使用乘法聚合（几何平均数）而非加法聚合（算术平均数）是CAI的一个关键特征。蛋白质合成是一个顺序过程，每个密码子按序翻译。合成的整体速率可能受限于最慢的步骤，即翻译具有最低适应度（即被最稀有的tRNA识别）的密码子。算术平均数会掩盖这种“瓶颈”效应，因为少数几个高度优化的密码子可以在数值上补偿一个非常差的密码子。然而，几何平均数对低值非常敏感。单个密码子的相对适应度趋近于零，将导致整个CAI值趋近于零，从而正确反映单个限速步骤对整体翻译效率不成比例的负面影响。\n\n任务2：CAI的计算\n\n给定的mRNA序列为 $5'$-`AUG GCU GCU GAA GAA UUU UUC CGU CGC AGA UGG GCG AAG UAA`-$3'$。问题要求计算中排除终止密码子（`UAA`）。因此，要评分的编码序列从起始密码子`AUG`开始，到`AAG`结束。要评分的序列总长度为 $L = 13$ 个密码子。\n\n所提供的密码子序列及其对应的相对适应度权重 $w_k$ 如下：\n1.  密码子 1: `AUG`, $w_1 = 1.00$\n2.  密码子 2: `GCU`, $w_2 = 0.35$\n3.  密码子 3: `GCU`, $w_3 = 0.35$\n4.  密码子 4: `GAA`, $w_4 = 0.65$\n5.  密码子 5: `GAA`, $w_5 = 0.65$\n6.  密码子 6: `UUU`, $w_6 = 0.55$\n7.  密码子 7: `UUC`, $w_7 = 1.00$\n8.  密码子 8: `CGU`, $w_8 = 0.40$\n9.  密码子 9: `CGC`, $w_9 = 0.95$\n10. 密码子 10: `AGA`, $w_{10} = 0.85$\n11. 密码子 11: `UGG`, $w_{11} = 1.00$\n12. 密码子 12: `GCG`, $w_{12} = 0.80$\n13. 密码子 13: `AAG`, $w_{13} = 1.00$\n\nCAI是这13个权重的几何平均数：\n$$ \\text{CAI} = \\left( w_1 \\times w_2 \\times w_3 \\times \\dots \\times w_{13} \\right)^{\\frac{1}{13}} $$\n首先，我们计算这些权重的乘积：\n$$ \\prod_{k=1}^{13} w_k = (1.00) \\times (0.35) \\times (0.35) \\times (0.65) \\times (0.65) \\times (0.55) \\times (1.00) \\times (0.40) \\times (0.95) \\times (0.85) \\times (1.00) \\times (0.80) \\times (1.00) $$\n$$ \\prod_{k=1}^{13} w_k = (0.35)^2 \\times (0.65)^2 \\times 0.55 \\times 0.40 \\times 0.95 \\times 0.85 \\times 0.80 $$\n$$ \\prod_{k=1}^{13} w_k = (0.1225) \\times (0.4225) \\times (0.55) \\times (0.40) \\times (0.95) \\times (0.85) \\times (0.80) $$\n$$ \\prod_{k=1}^{13} w_k = 0.007353377625 $$\n现在，我们取该乘积的13次方根：\n$$ \\text{CAI} = (0.007353377625)^{\\frac{1}{13}} $$\n$$ \\text{CAI} \\approx 0.685304 $$\n问题要求将答案四舍五入到四位有效数字。\n$$ \\text{CAI} \\approx 0.6853 $$\n这个值介于0和1之间，表示在特定生物体翻译机制的背景下，该基因具有中等水平的密码子适应度。",
            "answer": "$$\\boxed{0.6853}$$"
        },
        {
            "introduction": "在计算了一个特定基因的CAI之后，一个自然而然的问题是：对于一个给定的氨基酸序列，其CAI的理论极限是多少？这个练习  将挑战你从具体计算转向理论推导，探索密码子优化的边界。通过确定CAI的最大和最小值，你将对该指数的动态范围及其在基因设计中的意义有更深刻的理解。",
            "id": "2379978",
            "problem": "在给定生物体中，一个编码序列仅使用有义密码子编码一种蛋白质，其长度为 $L$ 个密码子。设氨基酸组成为 $\\{n_{a}\\}_{a \\in \\mathcal{A}}$，其中 $\\mathcal{A}$ 是存在的氨基酸集合，$n_{a}$ 是氨基酸 $a$ 在蛋白质中出现的次数，且 $\\sum_{a \\in \\mathcal{A}} n_{a} = L$。该生物体的参考密码子使用频率为每个编码氨基酸 $a$ 的有义密码子 $c$ 定义了一个相对适应性权重 $w_{c}$，由下式给出\n$$\nw_{c} \\;=\\; \\frac{\\mathrm{RSCU}(c)}{\\max_{c' \\in S_{a}} \\mathrm{RSCU}(c')},\n$$\n其中 $S_{a}$ 是氨基酸 $a$ 的同义密码子集合，$\\mathrm{RSCU}$ 表示相对同义密码子使用频率 (RSCU)。根据此定义，对于每种氨基酸 $a$，有 $0  w_{c} \\leq 1$ 且 $\\max_{c \\in S_{a}} w_{c} = 1$。对于密码子序列为 $(c_{1},\\dots,c_{L})$ 的编码序列，其密码子适应指数 (CAI) 定义为其 $w$ 权重的几何平均值，\n$$\n\\mathrm{CAI} \\;=\\; \\left(\\prod_{i=1}^{L} w_{c_{i}}\\right)^{1/L}.\n$$\n假设除了翻译成指定的氨基酸组成 $\\{n_{a}\\}_{a \\in \\mathcal{A}}$ 外没有其他约束，请以闭合形式确定在所有能翻译成该组成的所有可能编码序列中，$\\mathrm{CAI}$ 的理论最小值和最大值。使用 $L$、计数 $\\{n_{a}\\}$ 和权重 $\\{w_{c}\\}$ 来表示您的答案。请提供精确表达式，无需四舍五入。将两个值一起作为您的最终答案报告。",
            "solution": "所述问题具有科学依据、是良定的和客观的。它基于计算生物学的标准定义，并包含了推导出唯一解所需的所有信息。因此，该问题是有效的，我们可以着手解决它。\n\n目标是确定一个长度为 $L$ 个密码子、具有指定氨基酸组成 $\\{n_a\\}_{a \\in \\mathcal{A}}$ 的编码序列的密码子适应指数 ($\\mathrm{CAI}$) 的理论最小值和最大值。$\\mathrm{CAI}$ 定义为其组成密码子的相对适应性权重 $w_c$ 的几何平均值：\n$$ \\mathrm{CAI} = \\left(\\prod_{i=1}^{L} w_{c_{i}}\\right)^{1/L} $$\n该序列必须编码一种蛋白质，其中每种氨基酸 $a \\in \\mathcal{A}$ 出现 $n_a$ 次，且 $\\sum_{a \\in \\mathcal{A}} n_a = L$。\n\n最大化或最小化 $\\mathrm{CAI}$ 等价于最大化或最小化权重的总乘积 $W = \\prod_{i=1}^{L} w_{c_{i}}$，因为函数 $f(x) = x^{1/L}$ 对于 $x > 0$ 是单调递增的。乘积 $W$ 可以通过根据密码子编码的氨基酸进行分组来分解。对于每种氨基酸 $a \\in \\mathcal{A}$，序列中有 $n_a$ 个密码子必须从其同义密码子集合 $S_a$ 中选择。总乘积 $W$ 可以写为：\n$$ W = \\prod_{a \\in \\mathcal{A}} \\left( \\prod_{j=1}^{n_a} w_{c_{a,j}} \\right) $$\n其中 $c_{a,j}$ 是为氨基酸 $a$ 选择的第 $j$ 个密码子，且 $c_{a,j} \\in S_a$。\n\n特定氨基酸 $a$ 的密码子选择与任何其他氨基酸 $b \\neq a$ 的密码子选择无关。因此，为了找到总乘积 $W$ 的最大值或最小值，我们可以独立地最大化或最小化每种氨基酸的贡献，我们将其表示为 $W_a$：\n$$ W_a = \\prod_{j=1}^{n_a} w_{c_{a,j}} $$\n\n**最大 CAI**\n\n为了最大化总乘积 $W$，我们必须为所有 $a \\in \\mathcal{A}$ 最大化每个项 $W_a$。为了最大化 $W_a$，我们必须从集合 $S_a$ 中为氨基酸 $a$ 选择 $n_a$ 个密码子，以使其权重 $w_c$ 最大化。\n\n根据问题定义，对于任何氨基酸 $a$，其同义密码子的权重满足 $0  w_c \\le 1$。此外，对于每个 $a$，存在至少一个密码子，我们称之为 $c_a^{\\text{opt}} \\in S_a$，其权重是最大的：\n$$ \\max_{c \\in S_a} w_c = 1 $$\n为了最大化 $W_a$，我们必须为氨基酸 $a$ 的 $n_a$ 次出现中的每一次都选择这个最优密码子 $c_a^{\\text{opt}}$。那么来自氨基酸 $a$ 对乘积的贡献是：\n$$ W_{a, \\text{max}} = \\prod_{j=1}^{n_a} 1 = 1^{n_a} = 1 $$\n最大总乘积 $W_{\\text{max}}$ 是蛋白质中存在的所有氨基酸的这些最大贡献的乘积：\n$$ W_{\\text{max}} = \\prod_{a \\in \\mathcal{A}} W_{a, \\text{max}} = \\prod_{a \\in \\mathcal{A}} 1 = 1 $$\n因此，可能的最大 $\\mathrm{CAI}$ 是：\n$$ \\mathrm{CAI}_{\\text{max}} = (W_{\\text{max}})^{1/L} = (1)^{1/L} = 1 $$\n\n**最小 CAI**\n\n为了最小化总乘积 $W$，我们必须为所有 $a \\in \\mathcal{A}$ 最小化每个项 $W_a$。为了最小化 $W_a$，我们必须从集合 $S_a$ 中为氨基酸 $a$ 选择 $n_a$ 个密码子，以使其权重 $w_c$ 最小化。\n\n对于每种氨基酸 $a$，我们将其同义密码子中的最小权重定义为 $w_{a, \\text{min}}$：\n$$ w_{a, \\text{min}} = \\min_{c \\in S_a} w_c $$\n为了最小化 $W_a$，我们必须为氨基酸 $a$ 的所有 $n_a$ 次出现都选择对应于这个最小权重 $w_{a, \\text{min}}$ 的密码子。来自氨基酸 $a$ 对乘积的最小贡献是：\n$$ W_{a, \\text{min}} = \\prod_{j=1}^{n_a} w_{a, \\text{min}} = (w_{a, \\text{min}})^{n_a} $$\n对于只有一个密码子的氨基酸（例如，甲硫氨酸、色氨酸），集合 $S_a$ 只包含一个元素。对于这样的氨基酸，$\\min_{c \\in S_a} w_c = \\max_{c \\in S_a} w_c = 1$，所以它对最小乘积的贡献是 $1^{n_a}=1$，这是正确的，因为没有选择的余地。\n\n最小总乘积 $W_{\\text{min}}$ 是蛋白质中存在的所有氨基酸的这些最小贡献的乘积：\n$$ W_{\\text{min}} = \\prod_{a \\in \\mathcal{A}} W_{a, \\text{min}} = \\prod_{a \\in \\mathcal{A}} (w_{a, \\text{min}})^{n_a} = \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} $$\n因此，可能的最小 $\\mathrm{CAI}$ 是：\n$$ \\mathrm{CAI}_{\\text{min}} = (W_{\\text{min}})^{1/L} = \\left( \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} \\right)^{1/L} $$\n此表达式使用指定的参数以闭合形式给出了理论上的最小 $\\mathrm{CAI}$。\n\n总之，$\\mathrm{CAI}$ 的理论最小值和最大值是：\n-   $\\mathrm{CAI}_{\\text{min}} = \\left( \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} \\right)^{1/L}$\n-   $\\mathrm{CAI}_{\\text{max}} = 1$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left( \\prod_{a \\in \\mathcal{A}} \\left( \\min_{c \\in S_a} w_c \\right)^{n_a} \\right)^{1/L} \\\\ 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "密码子适应指数不仅是一个描述性工具，更是一个在合成生物学中用于指导基因优化的实用指标。这个练习  将你置于基因工程师的角色，要求你找出一个基因中能够最大程度提升CAI的单个同义密码子替换。这不仅是一次计算挑战，更是一次算法思维的实践，展示了如何利用CAI来解决实际的生物工程问题。",
            "id": "2380006",
            "problem": "您的任务是计算密码子适应指数（Codon Adaptation Index, CAI），并为每个提供的基因确定能使CAI增幅达到最大值的单个同义密码子替换。密码子适应指数是一个衡量指标，源于一组高表达基因参考集中的密码子使用偏好性。它基于分子生物学中心法则的以下基本概念：脱氧核糖核酸（DNA）通过三联体密码子翻译成蛋白质，每个密码子指定一个氨基酸；多个密码子可以编码同一个氨基酸，并且在特定生物体或条件下，它们的使用可能存在偏好。\n\n定义和约束：\n- 假设一个编码DNA序列是一个由字母表 $\\{A,C,G,T\\}$ 构成的字符串，其长度可被 $3$ 整除，并被划分为 $n$ 个密码子。假定使用标准遗传密码，且序列内部不含终止密码子。\n- 对于每种氨基酸，有一个参考密码子使用表，为每个有义密码子 $c$ 指定一个非负参考值 $f(c)$，该值与该密码子在高表达基因中的使用频率成正比。\n- 对于每种氨基酸 $a$，令 $\\mathcal{S}(a)$ 为其同义有义密码子集合。密码子 $c \\in \\mathcal{S}(a)$ 的相对适应性权重 $w(c)$ 定义为 $w(c) = f(c) / \\max\\{f(c') : c' \\in \\mathcal{S}(a)\\}$。根据定义，对于只有单个密码子的氨基酸，$w(c) = 1$。\n- 一个由密码子 $(c_1, c_2, \\dots, c_n)$ 组成的基因，其密码子适应指数（CAI）是这些密码子相对适应性权重的几何平均值，即所有位置 $i \\in \\{1,\\dots,n\\}$ 上 $w(c_i)$ 乘积的 $n$ 次方根。\n- 单个密码子改变在此定义为：将基因中某个位置上的一个密码子精确地改变为编码相同氨基酸的另一个同义密码子（从而保持编码的氨基酸序列不变）。您可以选择任何同义密码子作为替换（不限于单核苷酸突变）。\n- 如果没有任何同义替换能增加CAI，则该基因所需的结果为 $0$，因为您可以选择不作任何改变。\n\n任务：\n- 以上述定义为基础，实现一个程序，为每个给定的基因计算通过在基因任意位置进行一次精确的同义密码子替换可获得的最大CAI增量。仅使用下面提供的参考密码子使用表。忽略标准遗传密码映射之外的起始和终止密码子特殊情况；严格根据基因中所有密码子的 $w(c)$ 值计算CAI。\n\n参考密码子使用表 $f(c)$（假设生物体，标准遗传密码，仅有义密码子）。对于每种氨基酸，其同义密码子集合内的 $f(c)$ 值与其使用量成正比：\n- 苯丙氨酸 (F): $TTT \\mapsto 0.3$, $TTC \\mapsto 0.7$.\n- 亮氨酸 (L): $TTA \\mapsto 0.05$, $TTG \\mapsto 0.1$, $CTT \\mapsto 0.1$, $CTC \\mapsto 0.2$, $CTA \\mapsto 0.05$, $CTG \\mapsto 0.5$.\n- 异亮氨酸 (I): $ATT \\mapsto 0.35$, $ATC \\mapsto 0.6$, $ATA \\mapsto 0.05$.\n- 甲硫氨酸 (M): $ATG \\mapsto 1.0$.\n- 缬氨酸 (V): $GTT \\mapsto 0.2$, $GTC \\mapsto 0.25$, $GTA \\mapsto 0.05$, $GTG \\mapsto 0.5$.\n- 丝氨酸 (S): $TCT \\mapsto 0.15$, $TCC \\mapsto 0.3$, $TCA \\mapsto 0.04$, $TCG \\mapsto 0.1$, $AGT \\mapsto 0.06$, $AGC \\mapsto 0.35$.\n- 脯氨酸 (P): $CCT \\mapsto 0.2$, $CCC \\mapsto 0.2$, $CCA \\mapsto 0.1$, $CCG \\mapsto 0.5$.\n- 苏氨酸 (T): $ACT \\mapsto 0.2$, $ACC \\mapsto 0.55$, $ACA \\mapsto 0.1$, $ACG \\mapsto 0.15$.\n- 丙氨酸 (A): $GCT \\mapsto 0.2$, $GCC \\mapsto 0.5$, $GCA \\mapsto 0.1$, $GCG \\mapsto 0.2$.\n- 酪氨酸 (Y): $TAT \\mapsto 0.3$, $TAC \\mapsto 0.7$.\n- 组氨酸 (H): $CAT \\mapsto 0.3$, $CAC \\mapsto 0.7$.\n- 谷氨酰胺 (Q): $CAA \\mapsto 0.3$, $CAG \\mapsto 0.7$.\n- 天冬酰胺 (N): $AAT \\mapsto 0.3$, $AAC \\mapsto 0.7$.\n- 赖氨酸 (K): $AAA \\mapsto 0.4$, $AAG \\mapsto 0.6$.\n- 天冬氨酸 (D): $GAT \\mapsto 0.4$, $GAC \\mapsto 0.6$.\n- 谷氨酸 (E): $GAA \\mapsto 0.6$, $GAG \\mapsto 0.4$.\n- 半胱氨酸 (C): $TGT \\mapsto 0.35$, $TGC \\mapsto 0.65$.\n- 色氨酸 (W): $TGG \\mapsto 1.0$.\n- 精氨酸 (R): $CGT \\mapsto 0.35$, $CGC \\mapsto 0.4$, $CGA \\mapsto 0.1$, $CGG \\mapsto 0.1$, $AGA \\mapsto 0.03$, $AGG \\mapsto 0.02$.\n- 甘氨酸 (G): $GGT \\mapsto 0.3$, $GGC \\mapsto 0.45$, $GGA \\mapsto 0.15$, $GGG \\mapsto 0.1$.\n\n测试套件：\n为以下每个基因计算所需量（通过一次同义密码子改变可实现的最大CAI增量）。所有序列均使用标准遗传密码，仅包含有义密码子，且长度可被 $3$ 整除。\n- 基因 $1$：$ATGAGGATATTATCAGAAGGTGTTAAACAT$。\n- 基因 $2$：$ATGCTGCGCAGCATCGTGCCGGCC$。\n- 基因 $3$：$ATGTGGATGTGGATGTGG$。\n\n输出规格：\n- 对于每个基因，输出一个实数，等于通过一次精确的同义密码子替换可实现的最大CAI增量（如果无法增加则为 $0$），四舍五入到小数点后恰好六位。\n- 您的程序应生成单行输出，其中包含三个基因的结果，格式为方括号内以逗号分隔的列表，且无空格。例如，格式必须与 $[x_1,x_2,x_3]$ 完全一样，其中每个 $x_i$ 是小数点后有六位的小数。\n- 此计算不涉及任何物理单位。不要使用百分号；请报告小数值。\n\n注：\n- 您必须为有义密码子实现标准遗传密码映射。\n- 您的实现必须对使用所提供参考表的任何有效输入基因具有通用性。",
            "solution": "该问题要求计算给定基因序列的密码子适应指数（CAI）通过单个同义密码子替换可实现的最大可能增量。该问题具有科学依据，定义明确，并为确定性解决方案提供了所有必要信息。\n\n首先，我们将所提供的定义形式化。一个基因是由 $n$ 个密码子组成的序列，$(c_1, c_2, \\dots, c_n)$。对于编码氨基酸 $a$ 的每个密码子 $c$，其相对适应性权重 $w(c)$ 定义为：\n$$ w(c) = \\frac{f(c)}{\\max\\{f(c') : c' \\in \\mathcal{S}(a)\\}} $$\n其中 $\\mathcal{S}(a)$ 是氨基酸 $a$ 的同义密码子集合，$f(c)$ 是一个参考频率值。根据此定义，对于任何氨基酸，都存在至少一个“最优”密码子 $c_{\\text{opt}}$，其 $w(c_{\\text{opt}}) = 1$。对于所有其他同义密码子 $c'$，$w(c') \\le 1$。对于只有单个密码子的氨基酸（甲硫氨酸、色氨酸），其权重定义为 $1$。\n\n基因的密码子适应指数（CAI）是这些权重的几何平均值：\n$$ \\text{CAI} = \\left( \\prod_{i=1}^{n} w(c_i) \\right)^{1/n} $$\n为了数值稳定性，最好使用对数进行计算：\n$$ \\ln(\\text{CAI}) = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i)) \\implies \\text{CAI} = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(w(c_i))\\right) $$\n\n我们的目标是找到最大增量 $\\Delta\\text{CAI}_{\\max}$，该增量是通过将某个位置 $j \\in \\{1, \\dots, n\\}$ 的一个密码子 $c_j$ 替换为同义密码子 $c_s \\in \\mathcal{S}(a_j)$ 而产生的，其中 $a_j$ 是由 $c_j$ 编码的氨基酸。\n\n设初始指数为 $\\text{CAI}_{\\text{initial}}$。如果我们将密码子 $c_j$ 替换为 $c_s$，新的指数 $\\text{CAI}_{\\text{new}}$ 由下式给出：\n$$ \\text{CAI}_{\\text{new}} = \\left( w(c_1) \\cdot \\dots \\cdot w(c_{j-1}) \\cdot w(c_s) \\cdot w(c_{j+1}) \\cdot \\dots \\cdot w(c_n) \\right)^{1/n} $$\n我们可以用初始CAI来表示它。权重乘积的变化因子为 $w(c_s)/w(c_j)$。\n$$ \\prod_{i=1, i \\ne j}^{n} w(c_i) \\cdot w(c_s) = \\left(\\prod_{i=1}^{n} w(c_i)\\right) \\cdot \\frac{w(c_s)}{w(c_j)} $$\n对两边取 $n$ 次方根，得到：\n$$ \\text{CAI}_{\\text{new}} = \\left(\\left(\\prod_{i=1}^{n} w(c_i)\\right) \\cdot \\frac{w(c_s)}{w(c_j)}\\right)^{1/n} = \\left(\\prod_{i=1}^{n} w(c_i)\\right)^{1/n} \\cdot \\left(\\frac{w(c_s)}{w(c_j)}\\right)^{1/n} = \\text{CAI}_{\\text{initial}} \\cdot \\left(\\frac{w(c_s)}{w(c_j)}\\right)^{1/n} $$\nCAI的增量为 $\\Delta\\text{CAI} = \\text{CAI}_{\\text{new}} - \\text{CAI}_{\\text{initial}} = \\text{CAI}_{\\text{initial}} \\left[ \\left(\\frac{w(c_s)}{w(c_j)}\\right)^{1/n} - 1 \\right]$。\n\n为了最大化这个增量，我们必须最大化 $\\left(w(c_s)/w(c_j)\\right)^{1/n}$ 这一项。由于对于给定基因，$n$ 是一个正常数，这等价于最大化比率 $w(c_s)/w(c_j)$。这必须在所有可能的位置 $j$ 和该位置上所有可能的同义替换 $c_s$ 上进行。\n\n我们来分析一下最大化的逻辑。对于任何给定的位置 $j$，密码子 $c_j$ 及其权重 $w(c_j)$ 是固定的。我们希望选择一个同义密码子 $c_s$ 来最大化 $w(c_s)$。如前所述，任何 $w(c)$ 的最大可能值为 $1$，这是通过该氨基酸的最优密码子 $c_{\\text{opt}}$ 实现的。因此，对于任何位置 $j$，最好的替换方法是用 $c_{\\text{opt}}$ 替换 $c_j$，使得新权重 $w(c_s) = 1$。由此得到的比率为 $1/w(c_j)$。\n\n现在我们必须选择能带来整体最大增量的位置 $j$。这意味着我们必须找到能最大化比率 $1/w(c_j)$ 的位置 $j$。这等价于找到具有最小权重 $w(c_j)$ 的位置 $j$。\n\n令 $w_{\\min} = \\min_{i=1, \\dots, n} \\{w(c_i)\\}$。这个最小权重对应于序列中适应性最低的密码子。通过用其最优同义密码子（权重为 $1$）替换该密码子，我们实现了单次替换可能达到的最大CAI。\n\n因此，算法如下：\n1.  **预计算**：\n    a. 根据标准遗传密码，构建从 $61$ 个有义密码子到其对应氨基酸的映射。\n    b. 使用提供的 $f(c)$ 值表，为每种氨基酸 $a$ 找到最大频率值 $\\max\\{f(c') : c' \\in \\mathcal{S}(a)\\}$。\n    c. 计算并存储每个有义密码子的相对适应性权重 $w(c)$。\n\n2.  **逐基因计算**：对每个输入的基因序列：\n    a. 将基因解析为其 $n$ 个密码子的序列 $(c_1, \\dots, c_n)$。\n    b. 使用预计算的表，创建对应的权重列表 $(w(c_1), \\dots, w(c_n))$。\n    c. 在此列表中找到最小权重 $w_{\\min}$。\n    d. 如果 $w_{\\min} \\ge 1.0$，则每个密码子都已是最优的，或属于单密码子家族。没有同义替换可以增加CAI。结果为 $0.0$。\n    e. 如果 $w_{\\min}  1.0$，则可能实现增长。首先，计算基因的初始CAI，即 $\\text{CAI}_{\\text{initial}}$。\n    f. 一次替换可达到的最大CAI为 $\\text{CAI}_{\\text{final}} = \\text{CAI}_{\\text{initial}} \\cdot (1/w_{\\min})^{1/n}$。\n    g. 最大增量为差值：$\\Delta\\text{CAI}_{\\max} = \\text{CAI}_{\\text{final}} - \\text{CAI}_{\\text{initial}}$。\n\n这个精炼的算法避免了为每个可能的突变重新计算完整的CAI，从而非常高效。它识别出影响最大的单个替换并计算其效果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum CAI increase for a list of genes.\n    \"\"\"\n    # Define the reference codon usage table f(c)\n    f_table = {\n        'TTT': 0.3, 'TTC': 0.7, 'TTA': 0.05, 'TTG': 0.1, 'CTT': 0.1, 'CTC': 0.2, 'CTA': 0.05, 'CTG': 0.5,\n        'ATT': 0.35, 'ATC': 0.6, 'ATA': 0.05, 'ATG': 1.0, 'GTT': 0.2, 'GTC': 0.25, 'GTA': 0.05, 'GTG': 0.5,\n        'TCT': 0.15, 'TCC': 0.3, 'TCA': 0.04, 'TCG': 0.1, 'AGT': 0.06, 'AGC': 0.35, 'CCT': 0.2, 'CCC': 0.2,\n        'CCA': 0.1, 'CCG': 0.5, 'ACT': 0.2, 'ACC': 0.55, 'ACA': 0.1, 'ACG': 0.15, 'GCT': 0.2, 'GCC': 0.5,\n        'GCA': 0.1, 'GCG': 0.2, 'TAT': 0.3, 'TAC': 0.7, 'CAT': 0.3, 'CAC': 0.7, 'CAA': 0.3, 'CAG': 0.7,\n        'AAT': 0.3, 'AAC': 0.7, 'AAA': 0.4, 'AAG': 0.6, 'GAT': 0.4, 'GAC': 0.6, 'GAA': 0.6, 'GAG': 0.4,\n        'TGT': 0.35, 'TGC': 0.65, 'TGG': 1.0, 'CGT': 0.35, 'CGC': 0.4, 'CGA': 0.1, 'CGG': 0.1,\n        'AGA': 0.03, 'AGG': 0.02, 'GGT': 0.3, 'GGC': 0.45, 'GGA': 0.15, 'GGG': 0.1\n    }\n\n    # Standard genetic code for sense codons\n    genetic_code = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M', 'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'AGT': 'S', 'AGC': 'S', 'CCT': 'P', 'CCC': 'P',\n        'CCA': 'P', 'CCG': 'P', 'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'GCT': 'A', 'GCC': 'A',\n        'GCA': 'A', 'GCG': 'A', 'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'TGT': 'C', 'TGC': 'C', 'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'AGA': 'R', 'AGG': 'R', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    # Pre-computation step 1: Group codons by amino acid\n    synonymous_codons = {}\n    for codon, aa in genetic_code.items():\n        if aa not in synonymous_codons:\n            synonymous_codons[aa] = []\n        synonymous_codons[aa].append(codon)\n\n    # Pre-computation step 2: Find max f(c) for each amino acid\n    max_f_table = {}\n    for aa, codons in synonymous_codons.items():\n        max_f = 0.0\n        for codon in codons:\n            if codon in f_table:\n                max_f = max(max_f, f_table[codon])\n        max_f_table[aa] = max_f\n\n    # Pre-computation step 3: Calculate w(c) for all codons\n    w_table = {}\n    for codon, aa in genetic_code.items():\n        max_f = max_f_table[aa]\n        if max_f > 0:\n            w_table[codon] = f_table[codon] / max_f\n        else: # Should not happen for sense codons with f_table data\n            w_table[codon] = 1.0\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"ATGAGGATATTATCAGAAGGTGTTAAACAT\",\n        \"ATGCTGCGCAGCATCGTGCCGGCC\",\n        \"ATGTGGATGTGGATGTGG\",\n    ]\n\n    results = []\n    for gene_seq in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        n = len(gene_seq) // 3\n        if n == 0:\n            results.append(f\"{0.0:.6f}\")\n            continue\n            \n        codons = [gene_seq[i:i+3] for i in range(0, len(gene_seq), 3)]\n        \n        weights = [w_table[c] for c in codons]\n        w_min = min(weights)\n        \n        # If w_min is 1.0 or greater, no improvement is possible.\n        if w_min >= 1.0:\n            result = 0.0\n        else:\n            # Calculate initial CAI using numerically stable log-exp method\n            log_weights = np.log(weights)\n            log_cai_initial = np.mean(log_weights)\n            cai_initial = np.exp(log_cai_initial)\n\n            # Calculate the increase from the single best substitution\n            #\n            # CAI_final = CAI_initial * (1/w_min)^(1/n)\n            # Increase = CAI_final - CAI_initial = CAI_initial * ( (1/w_min)^(1/n) - 1 )\n            \n            increase = cai_initial * (np.power(1.0 / w_min, 1.0 / n) - 1.0)\n            result = increase\n            \n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}