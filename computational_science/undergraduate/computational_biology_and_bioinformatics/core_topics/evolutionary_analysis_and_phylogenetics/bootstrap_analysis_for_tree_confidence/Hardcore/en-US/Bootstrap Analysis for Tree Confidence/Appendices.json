{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp bootstrap analysis, we must start with its fundamental mechanism: resampling sites from an alignment. This first exercise strips the process down to its essence, focusing on how a single, phylogenetically informative site contributes to the overall support for a clade. By calculating the exact change in support when this site is removed, you will gain a concrete understanding of how the bootstrap value is a direct consequence of sampling probabilities, laying the groundwork for interpreting more complex scenarios. ",
            "id": "2377065",
            "problem": "You are given a phylogenetic scenario with Deoxyribonucleic Acid (DNA) alignments of $4$ taxa, labeled $A$, $B$, $C$, and $D$. The goal is to precisely quantify how replacing a single, highly informative site with an ambiguous character $N$ (meaning \"unknown nucleotide\") alters the non-parametric bootstrap support for the clade $\\{A,B\\}$. Your program must compute the support for $\\{A,B\\}$ both before and after the $N$ replacement and report the drop in support. The computation must be based on first principles of bootstrap resampling and quartet inference, and results must be expressed as decimals (not as percentages).\n\nFundamental base and definitions:\n- A DNA alignment is a matrix with $4$ rows (taxa) and $L$ columns (sites). Each entry is one of $\\{A,C,G,T,N\\}$.\n- A bootstrap replicate is formed by sampling $L$ columns with replacement from the original alignment. This sampling is independent and identically distributed across positions, each original column having probability $1/L$ of being chosen on any draw.\n- For any replicate alignment, define the pairwise $p$-distance $d(X,Y)$ between taxa $X$ and $Y$ as the fraction of sites (over the $L$ sampled columns) where $X$ and $Y$ differ, ignoring any site where either $X$ or $Y$ has $N$. If a pair has zero valid sites after ignoring $N$, set $d(X,Y)=0$.\n- For the quartet $\\{A,B,C,D\\}$ in any replicate, infer the unrooted split by the strict four-point condition: select the split $\\{A,B\\}|\\{C,D\\}$ if and only if\n$$\nd(A,B) + d(C,D) \\lt \\min\\big(d(A,C)+d(B,D),\\ d(A,D)+d(B,C)\\big).\n$$\nIf the minimum is not achieved strictly (i.e., any tie), treat the replicate as providing no support for $\\{A,B\\}$.\n- The bootstrap support for $\\{A,B\\}$ is the fraction of bootstrap replicates whose inferred split is $\\{A,B\\}|\\{C,D\\}$. In this problem you must compute the exact value implied by the resampling scheme for the alignments provided, not an asymptotic confidence or a heuristic score.\n\nSite manipulation rule:\n- “Replacing a site with $N$” means: choose one specified column index and replace the character in that column with $N$ for all $4$ taxa. All other columns remain unchanged.\n\nTask requirements:\n- For each test case, compute two supports for the clade $\\{A,B\\}$: before and after replacing the specified column(s) with $N$ (the replacement set can be one or more columns, as specified in the test case). Then compute the drop as\n$$\n\\Delta = \\text{support}_{\\text{before}} - \\text{support}_{\\text{after}},\n$$\nexpressed as a decimal in $[0,1]$. Report each $\\Delta$ rounded to exactly $3$ decimal places.\n- Important constraint: All test cases below are constructed so that every site is either constant across all taxa or is a parsimony-informative site of the form $A/A$ versus $G/G$ on $\\{A,B\\}$ versus $\\{C,D\\}$ (no other informative patterns appear), and there are no $N$ symbols initially. Under these conditions, a bootstrap replicate supports $\\{A,B\\}$ if and only if at least one such informative site is sampled at least once in that replicate. Your program must use correct logic that is universally consistent with the definitions above.\n\nTest suite:\n- Test case $1$ (happy path with one decisive site):\n  - Taxa: $A,B,C,D$.\n  - Alignment length $L=20$.\n  - Alignment: all sites are $A$ for all taxa except at column index $3$ (zero-based), where $A$ and $B$ have $A$ and $C$ and $D$ have $G$.\n  - Replacement: replace column index $3$ with $N$ for all taxa.\n- Test case $2$ (robust signal with many decisive sites):\n  - Taxa: $A,B,C,D$.\n  - Alignment length $L=40$.\n  - Alignment: all sites are $A$ for all taxa except at the $10$ column indices $\\{1,5,9,13,17,21,25,29,33,37\\}$ (zero-based), where $A$ and $B$ have $A$ and $C$ and $D$ have $G$.\n  - Replacement: replace only column index $1$ with $N$ for all taxa.\n- Test case $3$ (boundary case with a single site):\n  - Taxa: $A,B,C,D$.\n  - Alignment length $L=1$.\n  - Alignment: at column index $0$, $A$ and $B$ have $A$ and $C$ and $D$ have $G$.\n  - Replacement: replace column index $0$ with $N$ for all taxa.\n\nFinal output format:\n- Your program should produce a single line of output containing the three drops $\\Delta$ for the test cases in order, as a comma-separated list enclosed in square brackets. Each value must be rounded to exactly $3$ decimal places. For example, an acceptable format is\n\"[0.123,0.456,0.789]\".",
            "solution": "The problem statement has been rigorously validated and found to be scientifically grounded, well-posed, and objective. It presents a standard, albeit simplified, scenario in phylogenetic inference, providing all necessary definitions and data to derive a unique, verifiable solution. The problem is valid and will be solved as stated.\n\nThe core of the problem is to compute the bootstrap support for a clade, which is the probability that a bootstrap replicate will satisfy a given topological condition. The analysis requires a derivation from first principles.\n\nFirst, let us formalize the condition for a replicate to support the split $\\{A,B\\}|\\{C,D\\}$. The problem specifies that this support exists if, and only if, the strict four-point condition is met:\n$$\nd(A,B) + d(C,D) < \\min\\big(d(A,C)+d(B,D),\\ d(A,D)+d(B,C)\\big)\n$$\nwhere $d(X,Y)$ is the pairwise $p$-distance. The problem is constrained such that all sites in the original alignment are either constant across all four taxa or parsimony-informative for the split $\\{A,B\\}|\\{C,D\\}$.\n\nLet us analyze the contribution of each site type to the pairwise distances in a bootstrap replicate of length $L$.\nA bootstrap replicate is formed by sampling $L$ columns, with replacement, from the original alignment. Let a given replicate contain $k_I$ informative sites, $k_C$ constant sites, and $k_N$ sites where all characters are $N$. The total number of sampled sites is $L=k_I + k_C + k_N$.\n\nThe $p$-distance $d(X,Y)$ is defined as the fraction of differing sites, ignoring any site where either taxon has an 'N'.\nFor any site of type $(c,c,c,c)$ (constant) or $(X,X,Y,Y)$ (informative for $\\{A,B\\}|\\{C,D\\}$), all characters are from $\\{A,C,G,T\\}$. For a site of type $(N,N,N,N)$, it is ignored for all distance calculations.\nThus, the number of valid sites for computing any pairwise distance $d(X,Y)$ is $L_{\\text{valid}} = k_I + k_C$.\n\nIf $L_{\\text{valid}} = 0$, which occurs if and only if a replicate consists solely of columns where all taxa are $N$, then all pairwise distances are defined to be $0$. The support condition becomes $0 < \\min(0,0)$, which is false. Such a replicate provides no support.\n\nIf $L_{\\text{valid}} > 0$:\n- For taxa $A$ and $B$, their sequences are identical at all informative and constant sites. The number of differences is $0$. Thus, $d(A,B) = 0/L_{\\text{valid}} = 0$.\n- Similarly, for taxa $C$ and $D$, their sequences are identical. Thus, $d(C,D) = 0$.\n- The left-hand side of the inequality is $d(A,B) + d(C,D) = 0$.\n\n- For taxa $A$ and $C$, their sequences are identical at constant sites but differ at all $k_I$ informative sites. The number of differences is $k_I$. Thus, $d(A,C) = k_I / L_{\\text{valid}}$.\n- By symmetry of the informative pattern, $d(B,D) = d(A,D) = d(B,C) = k_I / L_{\\text{valid}}$.\n- The right-hand side of the inequality is $\\min(d(A,C)+d(B,D), d(A,D)+d(B,C)) = \\min(2k_I/L_{\\text{valid}}, 2k_I/L_{\\text{valid}}) = 2k_I/L_{\\text{valid}}$.\n\nThe four-point condition for support becomes $0 < 2k_I/L_{\\text{valid}}$. This inequality holds if and only if $k_I > 0$. Therefore, a bootstrap replicate supports the clade $\\{A,B\\}$ if and only if it contains at least one informative site. This verifies the assertion made in the problem statement.\n\nThe task now reduces to a probability calculation. Let $L$ be the total number of sites in the alignment and $I$ be the number of informative sites. The remaining $L-I$ sites are non-informative (constant or all-$N$).\nThe probability of selecting a non-informative site in a single draw is $p_{\\text{non-I}} = (L-I)/L$.\nSince a bootstrap replicate consists of $L$ independent draws, the probability that all $L$ sites sampled are non-informative is:\n$$\nP(\\text{no support}) = \\left(\\frac{L-I}{L}\\right)^L\n$$\nThe bootstrap support is the probability of the complementary event, i.e., at least one informative site is sampled:\n$$\n\\text{Support}(L, I) = 1 - P(\\text{no support}) = 1 - \\left(\\frac{L-I}{L}\\right)^L\n$$\nThis formula provides the exact support value. We apply this to each test case.\n\nTest Case 1:\n- Alignment length $L=20$.\n- Before replacement: There is one informative site at column index $3$. Thus, $I_{\\text{before}} = 1$.\n  $\\text{Support}_{\\text{before}} = 1 - \\left(\\frac{20-1}{20}\\right)^{20} = 1 - (0.95)^{20}$.\n- After replacement: The informative site is replaced with $N$s, becoming non-informative. Thus, $I_{\\text{after}} = 0$.\n  $\\text{Support}_{\\text{after}} = 1 - \\left(\\frac{20-0}{20}\\right)^{20} = 1 - 1^{20} = 0$.\n- Drop in support: $\\Delta_1 = \\text{Support}_{\\text{before}} - \\text{Support}_{\\text{after}} = 1 - (0.95)^{20} \\approx 0.641514$.\n\nTest Case 2:\n- Alignment length $L=40$.\n- Before replacement: There are $10$ informative sites. Thus, $I_{\\text{before}} = 10$.\n  $\\text{Support}_{\\text{before}} = 1 - \\left(\\frac{40-10}{40}\\right)^{40} = 1 - (0.75)^{40}$.\n- After replacement: One of the informative sites is replaced with $N$s. $9$ informative sites remain. Thus, $I_{\\text{after}} = 9$.\n  $\\text{Support}_{\\text{after}} = 1 - \\left(\\frac{40-9}{40}\\right)^{40} = 1 - (0.775)^{40}$.\n- Drop in support: $\\Delta_2 = \\left(1 - (0.75)^{40}\\right) - \\left(1 - (0.775)^{40}\\right) = (0.775)^{40} - (0.75)^{40} \\approx 0.0000119$.\n\nTest Case 3:\n- Alignment length $L=1$.\n- Before replacement: The single site is informative. Thus, $I_{\\text{before}} = 1$.\n  $\\text{Support}_{\\text{before}} = 1 - \\left(\\frac{1-1}{1}\\right)^1 = 1 - 0^1 = 1$.\n- After replacement: The single informative site is removed. Thus, $I_{\\text{after}} = 0$.\n  $\\text{Support}_{\\text{after}} = 1 - \\left(\\frac{1-0}{1}\\right)^1 = 1 - 1^1 = 0$.\n- Drop in support: $\\Delta_3 = 1 - 0 = 1$.\n\nThe final results are these $\\Delta$ values, rounded to $3$ decimal places.\n$\\Delta_1 \\approx 0.642$\n$\\Delta_2 \\approx 0.000$\n$\\Delta_3 = 1.000$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the drop in bootstrap support for the clade {A,B} for three test cases.\n    The support is calculated based on the exact probability of sampling at least one \n    informative site in a bootstrap replicate.\n    \"\"\"\n\n    def calculate_support(L, I):\n        \"\"\"\n        Calculates the exact bootstrap support.\n\n        Args:\n            L (int): The total number of sites in the alignment.\n            I (int): The number of informative sites for the clade of interest.\n\n        Returns:\n            float: The bootstrap support value, a probability in [0, 1].\n        \"\"\"\n        if L <= 0:\n            return 0.0\n        if I <= 0:\n            return 0.0\n\n        # The probability of not sampling an informative site in a single draw.\n        prob_non_informative_draw = (L - I) / L\n        \n        # The probability of not sampling any informative site in L draws.\n        prob_no_support = np.power(prob_non_informative_draw, L)\n        \n        # The support is the complementary probability.\n        return 1.0 - prob_no_support\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (L, I_before, I_after)\n    test_cases = [\n        # Test Case 1: L=20, 1 informative site, which is then removed.\n        (20, 1, 0),\n        # Test Case 2: L=40, 10 informative sites, 1 of which is removed.\n        (40, 10, 9),\n        # Test Case 3: L=1, 1 informative site, which is then removed.\n        (1, 1, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, I_before, I_after = case\n        \n        support_before = calculate_support(L, I_before)\n        support_after = calculate_support(L, I_after)\n        \n        delta = support_before - support_after\n        results.append(delta)\n\n    # Format the results as specified: a list of strings rounded to 3 decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Phylogenetic data often contains conflicting signals, where different sites support mutually exclusive evolutionary histories. While methods like Maximum Likelihood will report a single \"best\" tree, bootstrap analysis is crucial for revealing underlying uncertainty. This practice challenges you to design a dataset that exemplifies this conflict, where the best-fit tree is fully resolved but the bootstrap consensus is completely unresolved. By calculating the exact probabilities of recovering competing topologies, you will learn to appreciate the bootstrap's power to diagnose instability and prevent overconfidence in a single topological estimate. ",
            "id": "2377058",
            "problem": "You are asked to construct and verify, by computation, a small multiple sequence alignment over four taxa for which the Maximum Likelihood (ML) tree inferred under the Jukes-Cantor (JC) model is fully resolved (binary), yet its nonparametric bootstrap majority-rule consensus is a completely unresolved star (no internal split meets the strict majority threshold).\n\nYour program must implement the following from first principles.\n\n1) Fundamental definitions to use as the base:\n- Nonparametric bootstrap for phylogenies resamples alignment columns with replacement to create replicate alignments, each of the same length as the original, and then infers a tree on each replicate. The frequency of an internal split across replicates is an estimator of its sampling support.\n- Maximum Likelihood (ML): Given a fixed tree topology and a substitution model, branch lengths maximize the likelihood of the observed alignment. Among candidate topologies, the ML tree is the topology with the highest optimized likelihood.\n- Jukes-Cantor (JC) model: For a branch of length $t$ (time in expected substitutions per site) and any pair of nucleotides $i$ and $j$, the transition probability under JC with rate $1$ is\n$$\nP_{ij}(t) =\n\\begin{cases}\n\\frac{1}{4} + \\frac{3}{4} e^{-\\frac{4}{3} t}, & i=j, \\\\\\\\\n\\frac{1}{4} - \\frac{1}{4} e^{-\\frac{4}{3} t}, & i\\neq j.\n\\end{cases}\n$$\nThe stationary distribution is uniform, $\\pi_i = \\frac{1}{4}$ for all $i$.\n- Felsenstein pruning algorithm: For a rooted tree and a site with observed leaf states, the site likelihood is\n$$\n\\mathcal{L}_{\\text{site}} = \\sum_{r\\in\\{A,C,G,T\\}} \\pi_r \\prod_{c \\in \\text{children(root)}} \\left( \\sum_{k} P_{rk}(t_{rc}) \\, L_c(k) \\right),\n$$\nwhere $L_c(k)$ is the partial likelihood at child $c$ given parent state $k$, and at a leaf with observed state $s$ we set $L_{\\text{leaf}}(k)=\\mathbb{I}[k=s]$. Time-reversibility ensures the likelihood is independent of the arbitrary root placement.\n\n2) Dataset design space and decision rule:\n- Consider four taxa, denoted $A$, $B$, $C$, and $D$. Restrict to the three fully resolved unrooted binary topologies, represented by their single internal split:\n  - $T_1$: $(A,B)\\mid(C,D)$,\n  - $T_2$: $(A,C)\\mid(B,D)$,\n  - $T_3$: $(A,D)\\mid(B,C)$.\n- Construct an alignment comprised only of parsimony-informative site patterns that strongly and symmetrically favor one of these splits under JC:\n  - Pattern supporting $T_1$: $A=A$, $B=A$, $C=G$, $D=G$ (encode as states $[0,0,2,2]$),\n  - Pattern supporting $T_2$: $A=A$, $C=A$, $B=G$, $D=G$ (encode as $[0,2,0,2]$),\n  - Pattern supporting $T_3$: $A=A$, $D=A$, $B=G$, $C=G$ (encode as $[0,2,2,0]$).\n- Let the alignment be determined by the counts $(c_1,c_2,c_3)$ of these three patterns. Denote $L=c_1+c_2+c_3$.\n- For the full dataset, compute the ML tree under JC by enumerating the three topologies $T_1$, $T_2$, and $T_3$, optimizing their branch lengths, and selecting the topology with the largest optimized log-likelihood. The tree is “fully resolved” if a single topology strictly maximizes the optimized log-likelihood.\n- For bootstrap analysis, replicate alignments are obtained by sampling $L$ columns with replacement from the original alignment. Each bootstrap replicate induces an ML topology chosen from $\\{T_1,T_2,T_3\\}$ by the same JC-ML procedure. The majority-rule consensus at strict threshold $0.5$ includes any split whose selection frequency across replicates is strictly greater than $0.5$. If no split satisfies this, the consensus is a star (completely unresolved).\n\n3) Exact evaluation of bootstrap selection frequencies:\n- Let the category probabilities be $p_i = c_i/L$ for $i\\in\\{1,2,3\\}$. A bootstrap replicate’s counts $(k_1,k_2,k_3)$ over the three informative categories follow a trinomial distribution:\n$$\n\\Pr[k_1,k_2,k_3] = \\frac{L!}{k_1!\\,k_2!\\,k_3!} \\, p_1^{k_1} p_2^{k_2} p_3^{k_3}, \\quad k_1+k_2+k_3=L, \\; k_i\\ge 0.\n$$\n- Assume that the topology decision on a replicate is determined by which of $k_1,k_2,k_3$ is maximal (this matches the ML outcome for the restricted patterns under the JC model). Break ties lexicographically in the fixed order $(T_1,T_2,T_3)$, i.e., select $T_1$ if $k_1\\ge k_2$ and $k_1\\ge k_3$, else select $T_2$ if $k_2>k_1$ and $k_2\\ge k_3$, else select $T_3$.\n- The exact selection probability of topology $T_i$ is obtained by summing the trinomial probabilities over the region of $(k_1,k_2,k_3)$ where $T_i$ is chosen under this rule. You must compute these probabilities exactly by enumeration and not by Monte Carlo.\n\n4) What you must compute and report:\n- You will be given a small test suite of $(m,\\delta)$ parameters defining $(c_1,c_2,c_3)=(m+\\delta,\\,m,\\,m)$, for which you must:\n  - Construct the alignment as described.\n  - Compute the ML topology on the full dataset via JC with branch length optimization using the Felsenstein pruning algorithm.\n  - Compute the exact bootstrap selection probabilities $(P_1,P_2,P_3)$ by trinomial enumeration with the above lexicographic tie-breaking rule.\n  - Decide whether the strict majority-rule bootstrap consensus is a star, i.e., whether $\\max(P_1,P_2,P_3) \\le 0.5$.\n  - Output, for each test case, a boolean indicating whether both conditions hold simultaneously: the full-data ML tree is fully resolved and the bootstrap strict majority-rule consensus is a star.\n\n5) Test suite:\nUse the following test cases, which exercise a balanced-but-biased “happy path,” a strongly biased “non-star” boundary, and a short alignment edge case:\n- Case $1$: $(m,\\delta)=(10,1)$, so $(c_1,c_2,c_3)=(11,10,10)$.\n- Case $2$: $(m,\\delta)=(10,20)$, so $(c_1,c_2,c_3)=(30,10,10)$.\n- Case $3$: $(m,\\delta)=(3,1)$, so $(c_1,c_2,c_3)=(4,3,3)$.\n\n6) Final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[result1,result2,result3]”), where each result is a boolean in the order of the test cases. No other text should be printed. Angles are not involved, and there are no physical units. All thresholds must be treated as pure decimals (e.g., $0.5$).\n\nYour program must be self-contained, perform the JC-ML optimization for each topology, compute bootstrap selection probabilities by exact trinomial enumeration, and apply the strict majority decision rule as specified, without reading input.",
            "solution": "The problem statement has been subjected to rigorous validation and is determined to be valid. It is scientifically grounded in the principles of molecular phylogenetics, specifically Maximum Likelihood (ML) inference and nonparametric bootstrapping. The problem is well-posed, providing unambiguous definitions, explicit models such as the Jukes-Cantor (JC) model, and a clear computational task with defined inputs and outputs. All terms are objective and precisely specified. There are no contradictions, missing data, or scientifically unsound premises. The computational task is feasible for the given parameters.\n\nThe objective is to determine, for specific multiple sequence alignments, if two conditions are met simultaneously:\n$1$. The ML tree estimated from the full alignment is fully resolved.\n$2$. The strict majority-rule consensus tree from a nonparametric bootstrap analysis is a completely unresolved star topology.\n\nThe solution proceeds by implementing the logic dictated by the problem statement. A critical simplification is provided: the ML topology, both for the full dataset and for any bootstrap replicate, is determined by identifying which of the three specified parsimony-informative site patterns has the highest count. This is stated to be a consequence of the symmetric construction of the problem under the JC model and allows us to bypass the computationally intensive step of explicit branch length optimization using the Felsenstein pruning algorithm.\n\nLet the counts of the three site patterns be $(c_1, c_2, c_3)$, corresponding to support for topologies $T_1$, $T_2$, and $T_3$ respectively. The total number of sites is $L = c_1 + c_2 + c_3$. The test cases are of the form $(c_1, c_2, c_3) = (m+\\delta, m, m)$ with $\\delta > 0$.\n\nFirst, we validate the condition of the full-data ML tree being \"fully resolved\". A topology is fully resolved if it uniquely maximizes the log-likelihood. According to the problem's simplification, the ML topology is the one corresponding to the maximal count. For the given test cases, $c_1 = m+\\delta$ is strictly greater than $c_2 = m$ and $c_3 = m$. Therefore, topology $T_1$ is the unique ML choice. The first condition—that the ML tree is fully resolved—is satisfied for all provided test cases.\n\nSecond, we evaluate the bootstrap consensus tree. The consensus is a star if no topology is selected in more than $50\\%$ of bootstrap replicates. This requires calculating the exact selection probability for each topology, $P_1, P_2, P_3$.\n\nA bootstrap replicate is generated by sampling $L$ sites with replacement from the original alignment. The counts of the three patterns in a replicate, denoted $(k_1, k_2, k_3)$, follow a trinomial distribution, where $k_1+k_2+k_3=L$. The probability of observing a specific set of counts is given by the probability mass function:\n$$ \\Pr[k_1, k_2, k_3] = \\frac{L!}{k_1!\\,k_2!\\,k_3!} p_1^{k_1} p_2^{k_2} p_3^{k_3} $$\nwhere $p_i = c_i/L$ are the proportions of the patterns in the original alignment.\n\nThe topology selected for a replicate with counts $(k_1, k_2, k_3)$ is determined by the following rule, which includes a lexicographical tie-break:\n- $T_1$ is selected if $k_1 \\ge k_2$ and $k_1 \\ge k_3$.\n- $T_2$ is selected if $k_2 > k_1$ and $k_2 \\ge k_3$.\n- $T_3$ is selected otherwise.\n\nThe total selection probability for topology $T_i$, denoted $P_i$, is the sum of $\\Pr[k_1, k_2, k_3]$ over all tuples $(k_1, k_2, k_3)$ that lead to the selection of $T_i$. We compute these probabilities by enumerating all possible integer partitions $(k_1, k_2, k_3)$ of $L$. For numerical stability, the calculation is performed using logarithms. The log of the trinomial probability is:\n$$ \\ln(\\Pr[k_1, k_2, k_3]) = \\ln(\\Gamma(L+1)) - \\sum_{i=1}^{3} \\ln(\\Gamma(k_i+1)) + \\sum_{i=1}^{3} k_i \\ln(p_i) $$\nwhere $\\Gamma$ is the gamma function, and $\\ln(\\Gamma(n+1)) = \\ln(n!)$.\n\nAfter computing $P_1, P_2$, and $P_3$, we check the condition for a star consensus: $\\max(P_1, P_2, P_3) \\le 0.5$.\n\nThe final boolean result for each test case is the logical AND of the two conditions. As the first condition is always true for the given test cases, the result simplifies to whether the bootstrap consensus is a star. The computation is performed for each of the specified $(m,\\delta)$ pairs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Constructs and verifies alignments for which the ML tree is resolved\n    but the bootstrap majority-rule consensus is a star.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 1),  # Case 1: (m,d)=(10,1) -> (c1,c2,c3)=(11,10,10)\n        (10, 20), # Case 2: (m,d)=(10,20) -> (c1,c2,c3)=(30,10,10)\n        (3, 1),   # Case 3: (m,d)=(3,1) -> (c1,c2,c3)=(4,3,3)\n    ]\n\n    results = []\n    for m, delta in test_cases:\n        # Full-data ML tree resolution check\n        # Counts are (m+delta, m, m). Since delta > 0, c1 is strictly maximal.\n        # The problem states this implies the ML topology is T1 and thus resolved.\n        ml_tree_is_resolved = True\n\n        # Bootstrap consensus check\n        c1, c2, c3 = m + delta, m, m\n        L = c1 + c2 + c3\n        \n        # Proportions of each site pattern\n        p1, p2, p3 = c1 / L, c2 / L, c3 / L\n\n        # Pre-compute logs for efficiency in the loops\n        log_L_fact = gammaln(L + 1)\n        # Note: All test cases have c_i > 0, so p_i > 0. No need to handle log(0).\n        log_p1 = np.log(p1)\n        log_p2 = np.log(p2)\n        log_p3 = np.log(p3)\n\n        # Probabilities for selecting T1, T2, T3\n        P = np.zeros(3)\n\n        # Enumerate all possible bootstrap replicate compositions (k1, k2, k3)\n        for k1 in range(L + 1):\n            for k2 in range(L - k1 + 1):\n                k3 = L - k1 - k2\n\n                # Calculate the trinomial probability for the composition (k1, k2, k3)\n                log_prob = (log_L_fact - gammaln(k1 + 1) - gammaln(k2 + 1) - gammaln(k3 + 1) +\n                            k1 * log_p1 + k2 * log_p2 + k3 * log_p3)\n                prob = np.exp(log_prob)\n\n                # Apply the specified topology selection rule with tie-breaking\n                if k1 >= k2 and k1 >= k3:\n                    P[0] += prob  # T1 is selected\n                elif k2 > k1 and k2 >= k3:\n                    P[1] += prob  # T2 is selected\n                else:\n                    P[2] += prob  # T3 is selected\n\n        # Check if the consensus is a star (no split has > 50% support)\n        is_star_consensus = np.max(P) <= 0.5\n\n        # The final result is the conjunction of the two conditions\n        results.append(ml_tree_is_resolved and is_star_consensus)\n\n    # Final print statement in the exact required format.\n    # The boolean values are automatically converted to \"True\" or \"False\" strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Bootstrap support values are not absolute truths but statistical estimates; their reliability depends on the number of replicates performed, $B$. A common practical question is, \"How many bootstrap replicates are enough?\" This final exercise tackles this question head-on, treating the estimation of support as a problem in statistical sampling. You will use both a rigorous concentration inequality and a Normal approximation to calculate the minimum number of replicates needed to guarantee a desired level of precision across all branches of a tree, a critical skill for designing and reporting robust phylogenetic analyses. ",
            "id": "2377053",
            "problem": "You are given a phylogenetic dataset with $50$ taxa and $1000$ aligned sites. In nonparametric bootstrap analysis for tree confidence, each bootstrap replicate resamples the $1000$ sites with replacement, reconstructs a tree, and records whether each internal clade (branch) in a reference tree is recovered. Treat each replicate, for a fixed clade, as generating an independent Bernoulli indicator with success probability $p$ that the clade is recovered. The bootstrap support estimate for a clade after $B$ replicates is the sample mean of these indicators over $B$ independent replicates.\n\nAssume an unrooted, fully resolved reference tree on $n$ taxa. The number of internal branches is $m = n - 3$. For $n = 50$, use $m = 47$. You are to determine the minimal number of bootstrap replicates $B$ required so that, simultaneously for all $m$ internal clades, the absolute error between the true support probability $p_i$ and its bootstrap estimate $\\hat{p}_i$ is at most a user-specified tolerance $\\varepsilon$, with a specified family-wise confidence level $1 - \\alpha$. Here the family-wise confidence level means that the probability that any internal clade’s estimate deviates by more than $\\varepsilon$ is at most $\\alpha$.\n\nFundamental base:\n- The bootstrap indicator for a fixed clade across replicates is a sequence of independent and identically distributed Bernoulli random variables with success probability $p$.\n- The sample mean of independent Bernoulli random variables is the estimator $\\hat{p}$ for $p$.\n- A distribution-free concentration inequality for bounded independent random variables provides an exponential tail bound for deviations of the sample mean from its expectation.\n- The Normal distribution approximation to the Binomial distribution provides an approximate two-sided confidence interval for a proportion with a user-specified coverage, and a Bonferroni correction can be used to control the family-wise error rate (FWER) across $m$ clades.\n\nTask:\n- Using the concentration-inequality approach that guarantees family-wise control without distributional assumptions beyond independence and boundedness, derive an explicit formula for the minimal integer $B$ that ensures the family-wise deviation bound $\\max_{1 \\le i \\le m} |\\hat{p}_i - p_i| \\le \\varepsilon$ with probability at least $1 - \\alpha$. Implement this as $B_{\\text{Ineq}}$, taking the minimal integer $B$ that satisfies the bound.\n- Using the Normal approximation to the Binomial distribution for a two-sided confidence interval and a Bonferroni correction across the $m$ clades, derive an explicit formula for the minimal integer $B$ that ensures the same family-wise deviation bound. Implement this as $B_{\\text{Norm}}$. For this approximation, use either:\n  - a worst-case variance assumption $p(1-p) \\le \\tfrac{1}{4}$ when no pilot support is given, or\n  - a user-provided pilot support $p_0 \\in (0,1)$ to substitute $p(1-p)$ with $p_0(1-p_0)$ when provided.\n- Always report $B$ as the smallest integer $B$ that satisfies the required guarantee (i.e., apply the ceiling operation).\n- Explain why the number of aligned sites ($1000$) does not directly enter into the calculation of $B$ under these assumptions.\n\nAngle units are not applicable. There are no physical units. All tolerance and confidence inputs are expressed as decimals, not as percentages.\n\nTest suite:\nFor all test cases below, use $n = 50$ taxa (so $m = 47$ internal clades for an unrooted, fully resolved tree). For each case, compute and report the pair $[B_{\\text{Ineq}}, B_{\\text{Norm}}]$.\n\n- Case $1$: $\\varepsilon = 0.02$, $\\alpha = 0.05$, no pilot support (use worst-case variance for the Normal approximation).\n- Case $2$: $\\varepsilon = 0.01$, $\\alpha = 0.05$, pilot support $p_0 = 0.8$.\n- Case $3$: $\\varepsilon = 0.03$, $\\alpha = 0.01$, no pilot support.\n- Case $4$: $\\varepsilon = 0.05$, $\\alpha = 0.10$, pilot support $p_0 = 0.7$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the pair $[B_{\\text{Ineq}},B_{\\text{Norm}}]$ for the corresponding test case, in the order listed above. For example, the program must print a line of the form\n[[B1_Ineq,B1_Norm],[B2_Ineq,B2_Norm],[B3_Ineq,B3_Norm],[B4_Ineq,B4_Norm]]\nwith no extra text.",
            "solution": "The problem statement is scientifically sound, well-posed, and contains all necessary information for a unique solution. It is based on established principles of statistical inference, specifically bootstrap theory, concentration inequalities, and hypothesis testing with family-wise error rate control. The problem is formalizable and objective. Therefore, I will proceed with the derivation and solution.\n\nThe objective is to find the minimum number of bootstrap replicates, $B$, required to ensure that for all $m$ internal clades of an unrooted phylogenetic tree, the absolute error between the true support probability $p_i$ and its bootstrap estimate $\\hat{p}_i$ is no more than a specified tolerance $\\varepsilon$, with a family-wise confidence level of $1 - \\alpha$. The number of taxa is $n=50$, which for a fully resolved unrooted tree implies $m = n - 3 = 47$ internal clades.\n\nThe core probabilistic statement to satisfy is:\n$$P\\left( \\max_{1 \\le i \\le m} |\\hat{p}_i - p_i| \\le \\varepsilon \\right) \\ge 1 - \\alpha$$\nThis is equivalent to controlling the family-wise error rate (FWER) such that the probability of at least one estimate having an error greater than $\\varepsilon$ is bounded by $\\alpha$:\n$$P\\left( \\bigcup_{i=1}^{m} \\{|\\hat{p}_i - p_i| > \\varepsilon\\} \\right) \\le \\alpha$$\nWe will use the union bound (also known as Boole's inequality) to control this FWER. The union bound states that for any set of events $A_1, A_2, \\ldots, A_m$:\n$$P\\left(\\bigcup_{i=1}^{m} A_i\\right) \\le \\sum_{i=1}^{m} P(A_i)$$\nIn our context, let $A_i$ be the event $\\{|\\hat{p}_i - p_i| > \\varepsilon\\}$. The condition becomes $\\sum_{i=1}^{m} P(|\\hat{p}_i - p_i| > \\varepsilon) \\le \\alpha$.\n\nThe estimate $\\hat{p}_i$ is the sample mean of $B$ independent Bernoulli random variables, each with expectation $p_i$. We now derive the formulas for $B$ using two different approaches.\n\n**1. Concentration Inequality Approach ($B_{\\text{Ineq}}$)**\n\nThis method uses a distribution-free bound. Hoeffding's inequality is appropriate here. For a sum of $B$ independent random variables bounded within an interval of width $W$, the sample mean $\\bar{X}$ deviates from the true mean $\\mu$ by at least $\\varepsilon$ with probability:\n$$P(|\\bar{X} - \\mu| > \\varepsilon) \\le 2 \\exp\\left(-\\frac{2 B \\varepsilon^2}{W^2}\\right)$$\nFor our Bernoulli indicators, the variables are in $\\{0, 1\\}$, so the width of the interval is $W = 1 - 0 = 1$. Thus, for a single clade $i$:\n$$P(|\\hat{p}_i - p_i| > \\varepsilon) \\le 2 \\exp(-2 B \\varepsilon^2)$$\nApplying the union bound across all $m$ clades:\n$$\\sum_{i=1}^{m} P(|\\hat{p}_i - p_i| > \\varepsilon) \\le \\sum_{i=1}^{m} 2 \\exp(-2 B \\varepsilon^2) = 2m \\exp(-2 B \\varepsilon^2)$$\nTo satisfy the family-wise confidence requirement, we set this upper bound to be less than or equal to $\\alpha$:\n$$2m \\exp(-2 B \\varepsilon^2) \\le \\alpha$$\nWe solve for $B$:\n$$\\exp(-2 B \\varepsilon^2) \\le \\frac{\\alpha}{2m}$$\n$$-2 B \\varepsilon^2 \\le \\ln\\left(\\frac{\\alpha}{2m}\\right)$$\n$$2 B \\varepsilon^2 \\ge -\\ln\\left(\\frac{\\alpha}{2m}\\right) = \\ln\\left(\\frac{2m}{\\alpha}\\right)$$\n$$B \\ge \\frac{\\ln\\left(\\frac{2m}{\\alpha}\\right)}{2 \\varepsilon^2}$$\nThe minimal integer number of replicates, $B_{\\text{Ineq}}$, is therefore the ceiling of this expression:\n$$B_{\\text{Ineq}} = \\left\\lceil \\frac{\\ln(2m / \\alpha)}{2 \\varepsilon^2} \\right\\rceil$$\n\n**2. Normal Approximation with Bonferroni Correction ($B_{\\text{Norm}}$)**\n\nThis method relies on the Central Limit Theorem, which states that for large $B$, the sample proportion $\\hat{p}_i$ is approximately normally distributed:\n$$\\hat{p}_i \\approx \\mathcal{N}\\left(p_i, \\frac{p_i(1 - p_i)}{B}\\right)$$\nThe standardized variable $Z_i = \\frac{\\hat{p}_i - p_i}{\\sqrt{p_i(1-p_i)/B}}$ follows a standard normal distribution, $\\mathcal{N}(0, 1)$.\nTo control the FWER at level $\\alpha$ across $m$ clades, we use the Bonferroni correction, which requires the error probability for each individual clade to be bounded by $\\alpha/m$.\n$$P(|\\hat{p}_i - p_i| > \\varepsilon) \\le \\frac{\\alpha}{m}$$\nIn terms of the standard normal variable $Z_i$, this becomes:\n$$P\\left(|Z_i| > \\frac{\\varepsilon}{\\sqrt{p_i(1 - p_i)/B}}\\right) \\le \\frac{\\alpha}{m}$$\nLet $z_{\\alpha/(2m)}$ be the critical value from the standard normal distribution such that the upper tail probability is $\\alpha/(2m)$, i.e., $P(Z > z_{\\alpha/(2m)}) = \\alpha/(2m)$. This corresponds to an inverse cumulative distribution function value of $\\Phi^{-1}(1 - \\alpha/(2m))$. For the two-sided inequality to hold, we require:\n$$\\frac{\\varepsilon}{\\sqrt{p_i(1 - p_i)/B}} \\ge z_{\\alpha/(2m)}$$\nSolving for $B$:\n$$\\frac{B \\varepsilon^2}{p_i(1-p_i)} \\ge (z_{\\alpha/(2m)})^2$$\n$$B \\ge \\frac{p_i(1-p_i) (z_{\\alpha/(2m)})^2}{\\varepsilon^2}$$\nThe term $p_i(1-p_i)$ is the variance of a single Bernoulli trial, which depends on the unknown true support $p_i$. The problem specifies two scenarios:\na) **No pilot support**: We use the worst-case variance. The function $f(p) = p(1-p)$ is maximized at $p=0.5$, giving $p(1-p) \\le 0.5(1-0.5) = 0.25$.\nb) **Pilot support $p_0$**: We use the variance estimate $p_0(1-p_0)$.\n\nThe final formula for $B_{\\text{Norm}}$ is the ceiling of the derived expression, substituting the appropriate variance term:\n$$B_{\\text{Norm}} = \\left\\lceil \\frac{\\sigma_{p}^2 (z_{\\alpha/(2m)})^2}{\\varepsilon^2} \\right\\rceil, \\quad \\text{where} \\quad z_{\\alpha/(2m)} = \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2m}\\right)$$\nand $\\sigma_{p}^2$ is either $0.25$ or $p_0(1-p_0)$.\n\n**Explanation for the Number of Aligned Sites**\n\nThe number of aligned sites, given as $1000$, does not appear in the formulas for $B_{\\text{Ineq}}$ or $B_{\\text{Norm}}$. This is because the problem is formulated at a higher level of abstraction. The analysis treats each bootstrap replicate as a single, independent Bernoulli trial that either succeeds (recovers a specific clade) or fails. The probability of success, $p_i$, is the parameter we wish to estimate.\n\nThe value of $p_i$ is indeed a function of the underlying biological data (including the number and nature of the $1000$ sites), the evolutionary model, and the tree-building algorithm. A dataset with more informative sites would likely lead to higher values of $p_i$ for the true clades. However, the task presented is not to determine $p_i$, but to determine the number of bootstrap replicates $B$ needed to estimate $p_i$ (whatever its value may be) to a given precision $\\varepsilon$ and confidence $1-\\alpha$.\n\nThe calculation of $B$ is therefore a problem in statistical sampling theory: how large must a sample be to estimate a proportion with a specified error margin and confidence? This depends only on the desired precision ($\\varepsilon$), the confidence level ($\\alpha$), the number of simultaneous estimates being made ($m$), and assumptions about the variance of the proportion (handled by the worst-case or pilot estimates). The characteristics of the original dataset that determine the value of $p_i$ are encapsulated within the parameter $p_i$ itself and are not directly part of the sample size calculation for its estimation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the minimal number of bootstrap replicates B for four test cases\n    using two different methods: a concentration inequality and a Normal approximation.\n    \"\"\"\n\n    def calculate_b(epsilon, alpha, n, pilot_p0=None):\n        \"\"\"\n        Calculates the minimal number of bootstrap replicates B.\n\n        Args:\n            epsilon (float): The maximum tolerated absolute error.\n            alpha (float): The family-wise error rate.\n            n (int): The number of taxa.\n            pilot_p0 (float, optional): Pilot support probability. Defaults to None.\n\n        Returns:\n            list[int, int]: A list containing [B_Ineq, B_Norm].\n        \"\"\"\n        # The number of internal clades for an unrooted, fully resolved tree\n        m = n - 3\n\n        # 1. Concentration Inequality Approach (Hoeffding's Inequality)\n        # B >= ln(2*m/alpha) / (2 * epsilon^2)\n        b_ineq_numerator = np.log(2.0 * m / alpha)\n        b_ineq_denominator = 2.0 * epsilon**2\n        b_ineq = np.ceil(b_ineq_numerator / b_ineq_denominator)\n\n        # 2. Normal Approximation with Bonferroni Correction\n        # B >= variance * (z_crit^2) / (epsilon^2)\n        \n        # Determine the variance term\n        if pilot_p0 is not None:\n            # Use variance based on pilot support p0\n            variance = pilot_p0 * (1.0 - pilot_p0)\n        else:\n            # Use worst-case variance, where p(1-p) is maximized at p=0.5\n            variance = 0.25\n\n        # Calculate the critical z-value with Bonferroni correction\n        # The probability for each tail in a two-sided test is alpha / (2 * m)\n        quantile = 1.0 - alpha / (2.0 * m)\n        z_crit = norm.ppf(quantile)\n\n        b_norm_numerator = variance * (z_crit**2)\n        b_norm_denominator = epsilon**2\n        b_norm = np.ceil(b_norm_numerator / b_norm_denominator)\n\n        return [int(b_ineq), int(b_norm)]\n\n    # Common parameter for all test cases\n    n_taxa = 50\n\n    # Define the test cases from the problem statement.\n    # Format: (epsilon, alpha, pilot_p0 or None)\n    test_cases = [\n        # Case 1: eps = 0.02, alpha = 0.05, no pilot support\n        {'epsilon': 0.02, 'alpha': 0.05, 'pilot_p0': None},\n        # Case 2: eps = 0.01, alpha = 0.05, pilot support p0 = 0.8\n        {'epsilon': 0.01, 'alpha': 0.05, 'pilot_p0': 0.8},\n        # Case 3: eps = 0.03, alpha = 0.01, no pilot support\n        {'epsilon': 0.03, 'alpha': 0.01, 'pilot_p0': None},\n        # Case 4: eps = 0.05, alpha = 0.10, pilot support p0 = 0.7\n        {'epsilon': 0.05, 'alpha': 0.10, 'pilot_p0': 0.7},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_b(case['epsilon'], case['alpha'], n_taxa, case['pilot_p0'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[B1_Ineq,B1_Norm],[B2_Ineq,B2_Norm],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}