{
    "hands_on_practices": [
        {
            "introduction": "CIGAR字符串是SAM记录的核心，它简明地描述了测序读段（read）如何与参考序列（reference）比对，包括匹配、插入和删除。这项练习旨在通过一个基本练习来巩固你对这些核心操作的理解：根据给定的CIGAR字符串直接计算读段的长度。掌握这项技能是解读任何比对结果的第一步。",
            "id": "2370597",
            "problem": "在序列比对/图谱 (Sequence Alignment/Map, SAM) 格式及其二进制版本，二进制比对/图谱 (Binary Alignment/Map, BAM) 中，每个比对都包含一个紧凑型特异性缺口比对报告 (Compact Idiosyncratic Gapped Alignment Report, CIGAR) 字符串，该字符串编码了比对操作的长度和类型。考虑 CIGAR 字符串 $15\\texttt{M}5\\texttt{I}10\\texttt{M}5\\texttt{D}15\\texttt{M}$。$\\texttt{M}$ 操作表示比对匹配或错配，并消耗读取序列 (read) 和参考序列 (reference) 的核苷酸；$\\texttt{I}$ 操作表示相对于参考序列的插入，并仅消耗读取序列的核苷酸；$\\texttt{D}$ 操作表示相对于参考序列的读取序列缺失，并仅消耗参考序列的核苷酸。每个操作前面的整数给出了该操作应用的核苷酸计数。假设不存在软剪切 ($\\texttt{S}$) 或硬剪切 ($\\texttt{H}$) 操作。\n\n当与某个参考序列比对时，能够产生此 CIGAR 字符串的 DNA 读取序列（查询序列）的最小可能长度（以核苷酸为单位）是多少？请以整数形式表示您的答案。",
            "solution": "该问题要求根据给定的 CIGAR 字符串确定 DNA 读取序列（或查询序列）的长度。CIGAR 字符串是“紧凑型特异性缺口比对报告”的缩写，它提供了比对的简洁表示。查询序列的总长度可以通过对所有消耗查询序列自身碱基的 CIGAR 操作的长度求和来得到。\n\n问题为三种操作类型提供了定义：\n- 操作 $\\texttt{M}$ (比对匹配或错配) 消耗查询序列和参考序列的碱基。\n- 操作 $\\texttt{I}$ (相对于参考序列的插入) 仅消耗查询序列的碱基。\n- 操作 $\\texttt{D}$ (相对于参考序列的读取序列缺失) 仅消耗参考序列的碱基。\n\n问题陈述明确排除了剪切操作（$\\texttt{S}$ 和 $\\texttt{H}$）的存在。这是一个关键的简化，因为它意味着由 CIGAR 字符串描述的序列长度是明确的。因此，“最小可能长度”这一短语等同于参与比对的序列片段的唯一确定长度。\n\n提供的 CIGAR 字符串是 $15\\texttt{M}5\\texttt{I}10\\texttt{M}5\\texttt{D}15\\texttt{M}$。设 $L_{\\text{read}}$ 为读取序列的长度（以核苷酸为单位）。我们必须通过解析 CIGAR 字符串，并对消耗读取序列的每个组成部分的贡献求和来计算 $L_{\\text{read}}$。\n\n各部分的贡献如下：\n- 组成部分 $15\\texttt{M}$ 对应于从读取序列中消耗的 $15$ 个碱基。\n- 组成部分 $5\\texttt{I}$ 对应于从读取序列中消耗的 $5$ 个碱基。\n- 组成部分 $10\\texttt{M}$ 对应于从读取序列中消耗的 $10$ 个碱基。\n- 组成部分 $5\\texttt{D}$ 对应于从读取序列中的一次缺失。它消耗参考序列的碱基，因此对读取序列的长度贡献为 $0$ 个碱基。\n- 组成部分 $15\\texttt{M}$ 对应于从读取序列中消耗的 $15$ 个碱基。\n\n为了求得总长度 $L_{\\text{read}}$，我们将这些值相加：\n$$L_{\\text{read}} = 15 + 5 + 10 + 0 + 15$$\n进行求和：\n$$L_{\\text{read}} = 20 + 10 + 15$$\n$$L_{\\text{read}} = 30 + 15$$\n$$L_{\\text{read}} = 45$$\n因此，产生给定 CIGAR 字符串的 DNA 读取序列的长度为 $45$ 个核苷酸。",
            "answer": "$$\\boxed{45}$$"
        },
        {
            "introduction": "除了比对结构，SAM/BAM格式还使用标签（tag）来提供丰富的比对细节，例如读段与参考序列之间的差异数量。练习将抽象的格式与具体的生物学事件——单核苷酸多态性（SNP）——联系起来。通过为一个包含SNP的读段确定其编辑距离（NM标签），你将学会基因组变异在比对数据中是如何被量化表示的。",
            "id": "2370616",
            "problem": "一个来自二倍体人类样本的读段（read）使用 SAM (Sequence Alignment/Map) 格式与参考基因组进行比对。该比对由一个 CIGAR (Concise Idiosyncratic Gapped Alignment Report) 字符串和一个 MD 标签表示。在此情境下，CIGAR 操作符 $M$ 表示比对匹配，可能为序列匹配或错配，且不使用 $=$ 或 $X$ 操作符。MD 标签将与参考序列完全匹配的连续碱基编码为非负整数，将单个错配的参考碱基写为字母，并将相对于参考序列的缺失编码为一个脱字符号后跟被缺失的参考碱基。相对于参考序列的插入不会出现在 MD 标签中。NM 标签是比对编辑距离，此处定义为读段-参考序列比对路径上错配碱基总数加上插入和缺失碱基的总数。\n\n一个长度为 $20$ 个核苷酸的读段从参考坐标 $100$（基于 1）开始与参考基因组比对。从坐标 $100$ 到 $119$（含）的参考子序列是：\nACGTACGTACGTACGTACGT\n\n如果在此区间内读段与参考序列之间没有序列差异，则比对的 CIGAR 字符串为 $20M$，MD 标签值为 $20$。\n\n现在假设被测序的个体在参考坐标 $108$ 处携带一个单核苷酸多态性 (SNP)，使得该位置的读段碱基为 $G$，而该位置的参考碱基仍为 $A$。假设没有其他差异（没有额外的错配、插入或缺失），没有软剪切或硬剪切，并且比对器的约定与上述描述完全一致。\n\n在这些假设下，确定此比对的 NM 标签值。请以单个整数形式提供最终答案，不带单位。",
            "solution": "该问题要求确定指定读段比对的 $NM$ 标签的值。$NM$ 标签定义为比对编辑距离，即错配碱基总数、插入碱基总数和缺失碱基总数之和。\n\n设 $N_{mismatch}$ 为错配碱基的数量，$N_{ins}$ 为读段相对于参考序列的插入碱基数量，$N_{del}$ 为读段相对于参考序列的缺失碱基数量。根据问题定义，$NM$ 标签的值由以下公式给出：\n$$NM = N_{mismatch} + N_{ins} + N_{del}$$\n\n问题给出了以下比对条件：\n$1$. 读段长度为 $20$ 个核苷酸。\n$2$. 读段比对到的参考子序列也跨越 $20$ 个核苷酸。\n$3$. 读段和参考序列之间存在一个差异点：在参考坐标 $108$ 处有一个单核苷酸多态性 (SNP)。在此位置，参考碱基为 $\\text{A}$，读段碱基为 $\\text{G}$。这恰好构成一个错配。因此，我们有 $N_{mismatch} = 1$。\n$4$. 问题明确指出：“假设没有其他差异（没有额外的错配、插入或缺失）”。这个陈述为我们的计算提供了所需的其余值。\n\n根据这个明确的约束，我们可以确定：\n- 插入数为零：$N_{ins} = 0$。\n- 缺失数为零：$N_{del} = 0$。\n\n将这些确定的值代入 $NM$ 标签的方程中，我们进行计算：\n$$NM = 1 + 0 + 0$$\n$$NM = 1$$\n\n因此，总编辑距离为 $1$。这一个单位的编辑距离完全来自于指定的 SNP。对于这样一个长度为 $20$ 个碱基且没有任何插入或缺失的比对，其 CIGAR 字符串正确表示为 $\\text{20M}$。MD 标签详细说明了与参考序列的错配和缺失，它将是 $\\text{8A11}$，对应于 $8$ 个匹配，一个参考碱基为 $\\text{A}$ 的错配，以及随后的 $11$ 个匹配。这与问题的设置是一致的。然而，$NM$ 标签只是简单地计算总编辑数，在本例中为一。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "对一种比对格式的真正掌握，不仅在于能够读取它，更在于能够生成它。这个高级练习将挑战你完成一项关键的生物信息学任务：将来自其他格式（如BLAST输出）的比对数据转换为有效的SAM字段。你需要综合运用关于比特标志（FLAG）、CIGAR字符串构建和坐标系统的知识，来正确生成一条SAM记录的核心组成部分。",
            "id": "2370602",
            "problem": "给定一组源自 Basic Local Alignment Search Tool (BLAST) 的表格形式比对结果，其中包括查询序列和参考序列的、明确的、带空位的成对比对字符串，以及参考序列的坐标和链信息。您的任务是将每个比对转换为 Sequence Alignment/Map (SAM) 记录中用以验证比对几何结构所必需的字段：位标志 FLAG、最左侧的参考位置 POS 和一个紧凑的 CIGAR 字符串。由于未提供序列和碱基质量，因此输出中不要求这些信息。Binary Alignment/Map (BAM) 对 CIGAR 操作符使用规范的整数编码；您必须使用这些代码将生成的 CIGAR 编码为一个由长度-操作符代码对组成的列表。\n\n形式上，对于每个比对记录，您会得到：\n- 一个查询名称字符串 $qname$ 和一个参考名称字符串 $rname$。\n- 一个链指示符 $strand \\in \\{\"+\",\"-\"\\}$，表示查询序列到参考序列的方向。\n- 参考序列的起始和结束坐标 $r_{start}$ 和 $r_{end}$，它们是 1-based 闭区间坐标，其跨度恰好等于带空位比对中参考序列符号的数量（即参考比对字符串中非空位字符的数量），当 $strand = \"+\"$ 时 $r_{start} \\le r_{end}$，当 $strand = \"-\"$ 时 $r_{start} \\ge r_{end}$。\n- 两个等长字符串 $aln\\_q$ 和 $aln\\_r$，仅由字符 $\\{\"A\",\"C\",\"G\",\"T\",\"-\"\\}$ 组成，用以描述比对后的查询序列和参考序列，其中空位字符 $\"-\"$ 代表插入或删除。\n\n您必须为每个比对生成以下 SAM 组件：\n- 位标志 FLAG，作为一个整数：如果 $strand = \"+\"$，则使用 $0$；如果 $strand = \"-\"$，则使用 $16$。所有其他位均未设置，因为这些比对是单端且已比对的。\n- POS 字段，作为 read 比对到参考序列上的 1-based 最左侧参考坐标。定义 $L = \\min(r_{start}, r_{end})$。通过从左到右扫描 $aln\\_q$ 和 $aln\\_r$ 并根据以下规则合并连续的操作来构建原始 CIGAR，仅使用操作符 $M$、 $I$ 和 $D$：\n  - 如果 $aln\\_q[i] \\neq \"-\"$ 且 $aln\\_r[i] \\neq \"-\"$，则产生一个长度为 $1$ 的 $M$（比对匹配或错配；不区分匹配与错配）。\n  - 如果 $aln\\_q[i] = \"-\"$ 且 $aln\\_r[i] \\neq \"-\"$，则产生一个长度为 $1$ 的 $D$（相对于查询序列的删除，消耗参考序列）。\n  - 如果 $aln\\_q[i] \\neq \"-\"$ 且 $aln\\_r[i] = \"-\"$，则产生一个长度为 $1$ 的 $I$（相对于参考序列的插入，消耗查询序列）。\n  - $aln\\_q[i] = \"-\"$ 且 $aln\\_r[i] = \"-\"$ 的情况不会发生。\n  - 将相邻的相同操作合并为单一的操作段，并将其长度相加。\n  构建此原始 CIGAR 操作段列表后，移除所有前导和尾随的 $D$ 操作段，因为有效的 SAM 比对不能以删除开始或结束。设 $d\\_{low}$ 为在第一个比对上的查询碱基之前，与比对的最左侧基因组坐标相邻的删除操作所消耗的参考碱基数。按如下方式计算 $d\\_{low}$：\n  - 如果 $strand = \"+\"$，则 $d\\_{low}$ 是从开头移除的前导 $D$ 操作段的长度（如果没有则为 $0$）。\n  - 如果 $strand = \"-\"$，则 $d\\_{low}$ 是从末尾移除的尾随 $D$ 操作段的长度（如果没有则为 $0$）。\n  最后，设置 $POS = L + d\\_{low}$。\n- 采用游程编码形式的 CIGAR，经过上述修剪后仅使用 $M$、$I$ 和 $D$。对于输出，使用 BAM 操作符代码对此 CIGAR 进行编码：$M \\mapsto 0$，$I \\mapsto 1$，$D \\mapsto 2$。将 CIGAR 表示为一个由 $[len,op]$ 对组成的列表，其中 $len$ 是一个正整数，而 $op \\in \\{0,1,2\\}$。\n\n假设比对质量不可用，如果需要报告，在 SAM 中会报告为 $MAPQ = 255$。由于未提供序列和碱基质量，$SEQ$ 和 $QUAL$ 不属于要求的输出。对于配对字段，假设是单端数据，因此在完整的 SAM 行中 $RNEXT = \"*\"$，$PNEXT = 0$，$TLEN = 0$；这些不会出现在要求的输出中。\n\n您必须实现一个程序，对于嵌入在程序中的以下固定测试套件，为每个测试用例生成一个包含三个元素的列表：整数 FLAG、整数 POS 和编码后的 CIGAR（一个使用上述操作符代码的 $[len,op]$ 对的列表）。将所有测试用例的结果聚合到一个列表中，并以方括号括起来的逗号分隔列表形式在一行上打印，嵌套列表使用相同的方括号格式。不应打印任何其他文本。\n\n测试套件（每个测试用例是一个元组，字段顺序为 $(qname, rname, strand, r_{start}, r_{end}, aln\\_q, aln\\_r)$）：\n- 用例 $1$（正向链，相对于参考序列有一个插入）：\n  - $qname = \\text{\"read1\"}$, $rname = \\text{\"chr1\"}$, $strand = \\text{\"+\"}$, $r_{start} = 7$, $r_{end} = 11$, $aln\\_q = \\text{\"ACTGAC\"}$, $aln\\_r = \\text{\"ACT-AC\"}$。\n- 用例 $2$（反向链，相对于查询序列有一个删除）：\n  - $qname = \\text{\"read2\"}$, $rname = \\text{\"chr2\"}$, $strand = \\text{\"-\"}$, $r_{start} = 100$, $r_{end} = 96$, $aln\\_q = \\text{\"A-CCT\"}$, $aln\\_r = \\text{\"AGCCT\"}$。\n- 用例 $3$（正向链，有前导删除和尾随插入）：\n  - $qname = \\text{\"read3\"}$, $rname = \\text{\"chr3\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1000$, $r_{end} = 1004$, $aln\\_q = \\text{\"--ACGT\"}$, $aln\\_r = \\text{\"TTACG-\"}$。\n- 用例 $4$（反向链，在低坐标端有尾随删除）：\n  - $qname = \\text{\"read4\"}$, $rname = \\text{\"chr4\"}$, $strand = \\text{\"-\"}$, $r_{start} = 500$, $r_{end} = 495$, $aln\\_q = \\text{\"AC-T--\"}$, $aln\\_r = \\text{\"ACCTGG\"}$。\n- 用例 $5$（正向链，仅有错配，无空位）：\n  - $qname = \\text{\"read5\"}$, $rname = \\text{\"chr5\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1$, $r_{end} = 3$, $aln\\_q = \\text{\"AGT\"}$, $aln\\_r = \\text{\"ACT\"}$。\n\n角度单位不适用。不涉及物理单位。所有输出均为整数或整数列表。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，例如 $[\\,[flag\\_1,POS\\_1,CIGAR\\_1],\\,[flag\\_2,POS\\_2,CIGAR\\_2],\\,\\dots\\,]$，其中每个 $CIGAR\\_i$ 本身是一个使用 BAM 操作符代码 $M \\mapsto 0$、$I \\mapsto 1$、$D \\mapsto 2$ 的 $[len,op]$ 对的列表。",
            "solution": "该问题陈述具有科学依据，定义明确且客观。它提出了一个清晰定义的算法任务，即将特定的表格比对格式转换为标准的 Sequence Alignment/Map (SAM) 字段。所提供的输入、规则和测试用例都是自包含的，并与生物信息学中的既定原则一致。因此，该问题是有效的，并将提供一个解决方案。\n\n将每个给定的比对记录转换为所需的 SAM 字段——位标志 $FLAG$、位置 $POS$ 和编码后的 $CIGAR$ 字符串——的过程分三个连续阶段执行。\n\n首先，确定位标志 $FLAG$。SAM 格式规范使用位标志来编码比对的属性。代表链的位是 $0x10$，即十进制的 $16$。根据问题描述，如果比对到正向链（$strand = \\text{\"+\"}$），则 $FLAG$ 设置为 $0$。如果比对到反向互补链（$strand = \\text{\"-\"}$），则 $FLAG$ 设置为 $16$。与配对、质量或补充状态相关的其他标志不予考虑，这与所提供的信息一致。\n\n其次，构建并编码 $CIGAR$ 字符串。$CIGAR$ 字符串提供了比对结构的紧凑表示。过程如下：\n$1$. 从左到右逐个字符地扫描比对字符串 $aln\\_q$（查询序列）和 $aln\\_r$（参考序列）。\n$2$. 对于每个位置 $i$，确定一个操作：如果 $aln\\_q[i]$ 和 $aln\\_r[i]$ 都是碱基，则为比对匹配/错配（$M$）；如果 $aln\\_q[i]$ 是一个空位（$\"-\"$），则为相对于参考序列的删除（$D$）；如果 $aln\\_r[i]$ 是一个空位（$\"-\"$），则为相对于参考序列的插入（$I$）。两者都是空位的情况是被禁止的。\n$3$. 然后，这个单字符操作序列被合并。连续的相同操作被合并为一个单一的操作，其长度相加。例如，序列 $M, M, M$ 变为 $3M$。这会产生一个原始的游程编码 $CIGAR$。\n$4$. 根据问题规范，有效的 SAM 比对不能以删除（$D$）开始或结束。因此，任何前导或尾随的 $D$ 操作段都会从原始 $CIGAR$ 中移除。这些被移除的操作段的长度会被记录下来，用于后续计算 $POS$ 字段。\n$5$. 最后，将修剪后的 $CIGAR$ 字符串转换为其在 BAM 格式中使用的二进制表示。操作符 $M$、$I$ 和 $D$ 分别映射到整数代码 $0$、$1$ 和 $2$。最终的 $CIGAR$ 是一个由 $[len, op]$ 对组成的列表，每个对包含一个长度和一个操作符代码。\n\n第三，计算 $POS$ 字段。SAM 格式中的 $POS$ 字段指定了主比对的 1-based 最左侧比对位置。其计算严重依赖于链信息和任何被修剪的删除。\n$1$. 确定比对范围的最左侧基因组坐标 $L$，即 $L = \\min(r_{start}, r_{end})$。请注意，对于正向链比对，$L = r_{start}$；对于反向链比对，$L = r_{end}$。\n$2$. 必须计算一个关键的调整因子 $d_{low}$。该因子用于解释那些属于原始比对块，但由于对应于查询序列起始或末端的删除而被从最终 $CIGAR$ 中修剪掉的参考碱基。$d_{low}$ 的定义取决于链：\n   - 对于正向链（$strand = \\text{\"+\"}$）比对，比对的“左”侧对应于 CIGAR 字符串的开头和较低的基因组坐标。因此，$d_{low}$ 是被移除的前导 $D$ 操作段的长度。\n   - 对于反向链（$strand = \\text{\"-\"}$）比对，比对的“左”侧（在基因组坐标中）对应于查询序列的末端，因此也对应于 CIGAR 字符串的末端。因此，$d_{low}$ 是被移除的尾随 $D$ 操作段的长度。\n$3$. 最终的 $POS$ 值计算为 $POS = L + d_{low}$。这将调整起始位置，以计入被与查询序列第一个比对碱基相邻的、修剪掉的删除操作所消耗的参考碱基。\n\n作为示范性例子，让我们将此过程应用于测试用例 $3$：\n- 输入：$strand = \\text{\"+\"}$，$r_{start} = 1000$，$r_{end} = 1004$，$aln\\_q = \\text{\"--ACGT\"}$，$aln\\_r = \\text{\"TTACG-\"}$。\n- $FLAG$：由于 $strand = \\text{\"+\"}$，$FLAG = 0$。\n- CIGAR 生成：\n  - 扫描 $aln\\_q$ 和 $aln\\_r$ 得出操作序列 $[D, D, M, M, M, I]$。\n  - 合并后得到原始 $CIGAR$：$2D3M1I$。\n  - 修剪前导/尾随的 $D$ 操作：前导的 $2D$ 被移除。得到的 $CIGAR$ 是 $3M1I$。\n  - 移除的前导 $D$ 操作段的长度是 $2$。\n  - 使用编码 $M \\mapsto 0, I \\mapsto 1$ 对 $3M1I$ 进行编码，得到 $[[3, 0], [1, 1]]$。\n- POS 计算：\n  - $L = \\min(1000, 1004) = 1000$。\n  - $strand$ 是 $\\text{\"+\"}$，所以 $d_{low}$ 是移除的前导 $D$ 操作段的长度，即 $2$。\n  - $POS = L + d_{low} = 1000 + 2 = 1002$。\n- 用例 $3$ 的最终结果：$[0, 1002, [[3, 0], [1, 1]]]$。\n\n将此严谨的、逐步的过程应用于每个测试用例，以生成最终所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting BLAST-like alignments to SAM fields.\n    \"\"\"\n    \n    # Test suite provided in the problem statement.\n    test_cases = [\n        # Case 1 (forward strand with an insertion relative to the reference):\n        (\"read1\", \"chr1\", \"+\", 7, 11, \"ACTGAC\", \"ACT-AC\"),\n        # Case 2 (reverse strand with a deletion relative to the query):\n        (\"read2\", \"chr2\", \"-\", 100, 96, \"A-CCT\", \"AGCCT\"),\n        # Case 3 (forward strand with leading deletions and a trailing insertion):\n        (\"read3\", \"chr3\", \"+\", 1000, 1004, \"--ACGT\", \"TTACG-\"),\n        # Case 4 (reverse strand with trailing deletions at the low-coordinate end):\n        (\"read4\", \"chr4\", \"-\", 500, 495, \"AC-T--\", \"ACCTGG\"),\n        # Case 5 (forward strand with mismatches only, no gaps):\n        (\"read5\", \"chr5\", \"+\", 1, 3, \"AGT\", \"ACT\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the test case tuple for clarity.\n        qname, rname, strand, r_start, r_end, aln_q, aln_r = case\n\n        # 1. Determine the bitwise FLAG\n        flag = 16 if strand == \"-\" else 0\n\n        # 2. Generate the raw CIGAR string\n        op_map = {'M': 0, 'I': 1, 'D': 2}\n        raw_ops = []\n        for q_char, r_char in zip(aln_q, aln_r):\n            if q_char != '-' and r_char != '-':\n                raw_ops.append('M')  # Match or Mismatch\n            elif q_char != '-' and r_char == '-':\n                raw_ops.append('I')  # Insertion to reference\n            elif q_char == '-' and r_char != '-':\n                raw_ops.append('D')  # Deletion from reference\n        \n        # Coalesce adjacent identical operations\n        if not raw_ops:\n            raw_cigar_list = []\n        else:\n            raw_cigar_list = []\n            current_op = raw_ops[0]\n            current_len = 1\n            for op in raw_ops[1:]:\n                if op == current_op:\n                    current_len += 1\n                else:\n                    raw_cigar_list.append([current_len, current_op])\n                    current_op = op\n                    current_len = 1\n            raw_cigar_list.append([current_len, current_op])\n        \n        # 3. Trim CIGAR and calculate POS\n        \n        # Record lengths of leading/trailing deletions before trimming\n        d_leading = 0\n        if raw_cigar_list and raw_cigar_list[0][1] == 'D':\n            d_leading = raw_cigar_list[0][0]\n        \n        d_trailing = 0\n        if raw_cigar_list and raw_cigar_list[-1][1] == 'D':\n            d_trailing = raw_cigar_list[-1][0]\n            \n        # Trim leading 'D'\n        trimmed_cigar = list(raw_cigar_list) # Make a copy\n        if trimmed_cigar and trimmed_cigar[0][1] == 'D':\n            trimmed_cigar.pop(0)\n            \n        # Trim trailing 'D'\n        if trimmed_cigar and trimmed_cigar[-1][1] == 'D':\n            trimmed_cigar.pop(-1)\n\n        # Calculate d_low based on strand\n        d_low = 0\n        if strand == '+':\n            d_low = d_leading\n        elif strand == '-':\n            # For reverse strand, trailing deletions in the alignment string\n            # correspond to the low-coordinate end of the reference alignment.\n            d_low = d_trailing\n            \n        # Calculate the leftmost genomic coordinate L\n        L = min(r_start, r_end)\n        \n        # Final POS calculation\n        pos = L + d_low\n        \n        # 4. Encode the final CIGAR using BAM operator codes\n        encoded_cigar = [[length, op_map[op]] for length, op in trimmed_cigar]\n        \n        results.append([flag, pos, encoded_cigar])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of lists includes spaces, which is\n    # consistent with the example format in the problem description.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}