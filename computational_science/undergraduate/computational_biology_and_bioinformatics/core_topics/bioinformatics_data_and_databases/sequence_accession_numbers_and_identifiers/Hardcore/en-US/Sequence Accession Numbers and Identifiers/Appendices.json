{
    "hands_on_practices": [
        {
            "introduction": "A core task in bioinformatics is processing large, mixed files of data from various sources. This practice challenges you to build a single, powerful regular expression to validate and parse identifiers from four different major databases simultaneously. Mastering this skill is essential for writing efficient and robust scripts that can handle the diversity of data formats you will encounter in real-world biological datasets. ",
            "id": "2428411",
            "problem": "A bioinformatics pipeline must validate a mixed stream of putative sequence identifiers and extract two fields from each valid identifier: a leading alphabetical prefix and the immediately following numeric part. The stream may contain identifiers from any of the following databases, and an identifier is considered valid if and only if it conforms exactly to one of these forms.\n\n- GenBank primary nucleotide accessions: either one uppercase letter followed by exactly five digits, or two uppercase letters followed by exactly six digits. No version suffixes or other decorations are allowed.\n- National Center for Biotechnology Information (NCBI) Reference Sequence (RefSeq) accessions: a two-letter prefix from the set {NM, NR, NP, NC, NG, NT, NW, XM, XR, XP, YP}, followed by an underscore, followed by one or more digits (the accession number), with an optional version suffix consisting of a dot and one or more digits. Only the two-letter code before the underscore is the prefix, and the numeric part is the digit sequence immediately after the underscore, not including the optional version.\n- Universal Protein Resource (UniProt) primary accessions (isoform suffixes excluded): either a six-character string consisting of one uppercase letter, one digit, three uppercase letters or digits, and one final digit, or a ten-character string consisting of one uppercase letter, one digit, and eight uppercase letters or digits. For this problem, the prefix is defined as the consecutive uppercase letters from the start up to (but not including) the first digit, and the numeric part is the maximal contiguous run of digits immediately following that prefix.\n- Protein Data Bank (PDB) identifiers: exactly four characters consisting of one digit followed by three uppercase letters or digits. For this problem, define the prefix as the empty string and the numeric part as the first digit.\n\nYou are to construct a single pattern using Perl Compatible Regular Expressions (PCRE) that, when applied to a candidate string, validates it against the four classes simultaneously and captures the two fields into consistently named capturing groups across all alternatives: the group named “prefix” must capture the prefix as defined above, and the group named “num” must capture the numeric part as defined above.\n\nAfter designing such a single regular expression, apply it conceptually (no code execution is required) to the following list of strings. For each string that matches, determine the length (in characters) of the captured numeric part and add these lengths. Let the resulting total be denoted by $S$. Report the value of $S$ as a plain integer.\n\n- M12345\n- AF123456\n- CP000001\n- AB12345\n- J012345\n- NM_000059.3\n- NP_123456\n- XR_98765.1\n- ZZ_123456\n- P12345\n- Q8N158\n- A0A023GPI8\n- B2R5Z7\n- 1ABC\n- 2C7A\n- A1BC\n- XP_1234\n- Q8N158-2\n- NR_001\n- YP_009724390.1\n\nAnswer form: Provide only the numerical value of $S$. No units are required. Do not round; $S$ is an integer by definition.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, and objective. It provides a clear, self-contained set of rules for identifying and parsing four specific classes of bioinformatics sequence identifiers. The definitions, while idiosyncratic for some classes, are unambiguous and facilitate the construction of a formal solution.\n\nThe task is to construct a single Perl Compatible Regular Expression (PCRE) to validate strings against the given formats and extract two named fields: `prefix` and `num`. Subsequently, this process is to be conceptually applied to a provided list of candidate strings to calculate a sum, $S$, which is the total length of all captured `num` fields from the valid strings.\n\nFirst, we design the regular expression. The overall pattern must match the entire string from beginning (`^`) to end (`$`) and will consist of four main alternatives, one for each database, combined with the `|` operator. We will use named capture groups `(?<prefix>...)` and `(?<num>...)`.\n\n1.  **GenBank Accessions**: The format is one uppercase letter and five digits (`[A-Z]\\d{5}`) or two uppercase letters and six digits (`[A-Z]{2}\\d{6}`). The prefix is the alphabetical part and the numeric part is the digit sequence. This translates to the following two-part alternative:\n    `(?<prefix>[A-Z])(?<num>\\d{5})` and `(?<prefix>[A-Z]{2})(?<num>\\d{6})`.\n    The combined sub-pattern for GenBank is:\n    `(?:(?<prefix>[A-Z])(?<num>\\d{5})|(?<prefix>[A-Z]{2})(?<num>\\d{6}))`\n\n2.  **NCBI RefSeq Accessions**: The format is a specific two-letter prefix, an underscore, one or more digits, and an optional version suffix. The prefix is the two-letter code, and the numeric part is the sequence of digits after the underscore. The allowed prefixes are `{NM, NR, NP, NC, NG, NT, NW, XM, XR, XP, YP}`.\n    The sub-pattern for RefSeq is:\n    `(?<prefix>NM|NR|NP|NC|NG|NT|NW|XM|XR|XP|YP)_(?<num>\\d+)(?:\\.\\d+)?`\n\n3.  **UniProt Accessions**: The format is either a six-character string `[A-Z]\\d[A-Z0-9]{3}\\d` or a ten-character string `[A-Z]\\d[A-Z0-9]{8}`. The prefix is defined as the leading alphabetical character, and the numeric part is the single digit immediately following it.\n    The sub-pattern for UniProt is:\n    `(?<prefix>[A-Z])(?<num>\\d)(?:[A-Z0-9]{3}\\d|[A-Z0-9]{8})`\n\n4.  **PDB Identifiers**: The format is a four-character string `\\d[A-Z0-9]{3}`. The prefix is defined as the empty string, and the numeric part is the leading digit.\n    The sub-pattern for PDB, capturing an empty prefix, is:\n    `(?<prefix>)(?<num>\\d)[A-Z0-9]{3}`\n\nCombining these four sub-patterns into a single, anchored PCRE gives the final expression:\n`^(?:(?:(?<prefix>[A-Z])(?<num>\\d{5})|(?<prefix>[A-Z]{2})(?<num>\\d{6}))|(?<prefix>NM|NR|NP|NC|NG|NT|NW|XM|XR|XP|YP)_(?<num>\\d+)(?:\\.\\d+)?|(?<prefix>[A-Z])(?<num>\\d)(?:[A-Z0-9]{3}\\d|[A-Z0-9]{8})|(?<prefix>)(?<num>\\d)[A-Z0-9]{3})$`\n\nNext, we apply these rules to the provided list of strings and calculate the sum $S$. For each string, we determine its validity and, if valid, the length of the captured `num` part.\n\n1.  `M12345`: Valid GenBank (`[A-Z]\\d{5}`). `num` = `12345`. Length = $5$.\n2.  `AF123456`: Valid GenBank (`[A-Z]{2}\\d{6}`). `num` = `123456`. Length = $6$.\n3.  `CP000001`: Valid GenBank (`[A-Z]{2}\\d{6}`). `num` = `000001`. Length = $6$.\n4.  `AB12345`: Invalid. Format `[A-Z]{2}\\d{5}` does not match any rule. Length = $0$.\n5.  `J012345`: Invalid. Format `[A-Z]\\d{6}` does not match any rule. Length = $0$.\n6.  `NM_000059.3`: Valid RefSeq. `num` = `000059`. Length = $6$.\n7.  `NP_123456`: Valid RefSeq. `num` = `123456`. Length = $6$.\n8.  `XR_98765.1`: Valid RefSeq. `num` = `98765`. Length = $5$.\n9.  `ZZ_123456`: Invalid. `ZZ` is not a permitted RefSeq prefix. Length = $0$.\n10. `P12345`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`). `num` = `1`. Length = $1$.\n11. `Q8N158`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`). `num` = `8`. Length = $1$.\n12. `A0A023GPI8`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{8}`). `num` = `0`. Length = $1$.\n13. `B2R5Z7`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`). `num` = `2`. Length = $1$.\n14. `1ABC`: Valid PDB (`\\d[A-Z0-9]{3}`). `num` = `1`. Length = $1$.\n15. `2C7A`: Valid PDB (`\\d[A-Z0-9]{3}`). `num` = `2`. Length = $1$.\n16. `A1BC`: Invalid. Does not match any rule. Length = $0$.\n17. `XP_1234`: Valid RefSeq. `num` = `1234`. Length = $4$.\n18. `Q8N158-2`: Invalid. The string contains a suffix `-2` not accounted for in any rule, and the pattern is anchored. Length = $0$.\n19. `NR_001`: Valid RefSeq. `num` = `001`. Length = $3$.\n20. `YP_009724390.1`: Valid RefSeq. `num` = `009724390`. Length = $9$.\n\nThe total sum $S$ is the sum of these lengths:\n$S = 5 + 6 + 6 + 0 + 0 + 6 + 6 + 5 + 0 + 1 + 1 + 1 + 1 + 1 + 1 + 0 + 4 + 0 + 3 + 9$\n$S = (5+5) + (6+6+6+6) + (1+1+1+1+1+1) + 4 + 3 + 9$\n$S = 10 + 24 + 6 + 4 + 3 + 9$\n$S = 34 + 6 + 4 + 3 + 9$\n$S = 40 + 4 + 3 + 9$\n$S = 44 + 3 + 9$\n$S = 47 + 9 = 56$\n\nThe final calculated value for $S$ is $56$.",
            "answer": "$$\\boxed{56}$$"
        },
        {
            "introduction": "Scientific data is not always perfect; errors from data migration, export processes, or manual entry are common. This exercise places you in the role of a data steward, tasking you with writing a program to detect and repair a specific, systematic corruption in a set of sequence identifiers. This practice emphasizes the importance of precise rule-based validation and programmatic data cleaning to ensure the quality and integrity of your data before analysis. ",
            "id": "2428362",
            "problem": "A data export from a biological database produced a systematic corruption in which the period separating the accession from the version in accession.version identifiers was replaced by a hyphen. Your task is to write a complete, runnable program that, given a fixed in-memory dataset of putative identifiers, detects and corrects only this specific corruption while leaving already valid identifiers unchanged and rejecting any strings that are not valid identifiers under the rules below. The program must not read external input and must use the exact test suite provided here.\n\nAn identifier is considered valid if and only if all of the following conditions hold simultaneously for a string $s$:\n- The string $s$ contains exactly one period character $.$ and zero hyphen characters $-$.\n- If $s$ is split at the period into a core part $c$ and a version part $v$, then:\n  1. The version $v$ is a base-$10$ numeral representing a positive integer, meaning $v$ consists only of digits $0$ through $9$, satisfies $\\lvert v \\rvert \\ge 1$, represents an integer value $\\ge 1$, and does not begin with the digit $0$ when $\\lvert v \\rvert \\ge 2$.\n  2. The core $c$ satisfies all of the following:\n     - The first character of $c$ is an uppercase letter in the set $\\{A,\\dots,Z\\}$.\n     - Every character of $c$ is either an uppercase letter in $\\{A,\\dots,Z\\}$, a digit in $\\{0,\\dots,9\\}$, or an underscore character $_$.\n     - The core $c$ contains at least one digit in $\\{0,\\dots,9\\}$.\n     - The last character of $c$ is not an underscore character $_$.\n\nA string is considered to be a corrupted identifier due solely to the migration error if and only if all of the following conditions hold for a string $s$:\n- The string $s$ contains exactly one hyphen character $-$ and zero period characters $.$.\n- If the unique hyphen in $s$ is replaced by a period $.$ to produce a new string $s'$, then $s'$ is a valid identifier as defined above.\n\nCorrection is performed by replacing the unique hyphen in a corrupted identifier with a period, producing the corresponding valid identifier. Strings that are already valid identifiers must remain unchanged. Any string that is neither a valid identifier nor a correctable corrupted identifier under the definitions above must be treated as invalid and left unchanged.\n\nYour program must process each test case independently and, for each test case, compute a list of four integers $[T, C, U, I]$, where:\n- $T$ is the total number of strings in the test case.\n- $C$ is the number of strings that were corrected (i.e., corrupted identifiers that were fixed).\n- $U$ is the number of strings that were already valid and thus left unchanged.\n- $I$ is the number of strings that are invalid under the rules and remain uncorrected.\n\nTest Suite:\n- Test case $1$:\n  - Input list:\n    - \"AY123456-1\"\n    - \"NM_000014-5\"\n    - \"NC_000001.11\"\n    - \"GCF_000001405-40\"\n    - \"XP_011518-0\"\n    - \"BADFORMAT-XYZ\"\n    - \"AY123456.1\"\n    - \"GCF_000001405.40\"\n    - \"abc123-1\"\n    - \"NR_000001-1-2\"\n- Test case $2$:\n  - Input list:\n    - \"A1-1\"\n    - \"AA000000-1\"\n    - \"A-1\"\n    - \"AA1.\"\n    - \"AA1-01\"\n    - \"AA1-10\"\n    - \"AA_1-2\"\n    - \"A1.1\"\n    - \"A1-1-1\"\n    - \"AA1-001\"\n- Test case $3$:\n  - Input list:\n    - \"WP_010885.1\"\n    - \"WP_010885-1\"\n    - \"ENST00000367770-2.3\"\n    - \"LRG_123t1-1\"\n    - \"XP_011518-1a\"\n    - \"-1\"\n    - \"A1-1-1\"\n    - \"B2-2\"\n    - \"C3.03\"\n    - \"D4-00\"\n    - \"E5-7\"\n    - \"F6_-1\"\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case’s $[T,C,U,I]$ list. Specifically, print a single line of the form:\n  - \"[[T1,C1,U1,I1],[T2,C2,U2,I2],[T3,C3,U3,I3]]\"\nAll integers must be printed in base-$10$ with no additional text or whitespace other than the commas and brackets implied by the format. No physical units are involved in this problem; all answers are integers.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the context of bioinformatics data processing, well-posed with a clear and internally consistent set of rules, and entirely objective. It presents a formal specification for a data-cleaning task, which is a common and legitimate problem in computational science. We may therefore proceed with a solution.\n\nThe task is to categorize a given list of strings into one of three classes: valid identifiers, correctable corrupted identifiers, and invalid strings. For each test case, we must report the total count of strings $T$, the count of corrected strings $C$, the count of unchanged valid strings $U$, and the count of invalid strings $I$. The sum of these counts must equal the total, i.e., $T = C + U + I$.\n\nThe methodological core of the solution is a deterministic validation function that precisely implements the provided rules for what constitutes a \"valid identifier\". This function will serve as the arbiter for the classification logic. Let us name this function `is_valid_identifier`. It will take a single string argument and return a Boolean value indicating its validity.\n\nThe `is_valid_identifier` function for a given string $s'$ must execute the following checks in sequence:\n$1$. **Separator Integrity**: The string $s'$ must contain exactly one period character ($.$) and zero hyphen characters ($-$). If this condition is not met, the string is not a valid identifier.\n$2$. **Structural Partition**: If the separator check passes, the string is split at the period into a core part $c$ and a version part $v$. Both parts must be non-empty.\n$3$. **Version Validation**: The version part $v$ must satisfy all of the following:\n    - It must consist exclusively of base-$10$ digits (`0` through `9`).\n    - Its length must be at least one, i.e., $\\lvert v \\rvert \\ge 1$.\n    - The integer it represents must be positive, i.e., $\\text{int}(v) \\ge 1$.\n    - It must not begin with a leading zero if its length is greater than one. That is, if $\\lvert v \\rvert \\ge 2$, its first character cannot be `$0$`.\n$4$. **Core Validation**: The core part $c$ must satisfy all of the following:\n    - The first character must be an uppercase letter from the set $\\{A, \\dots, Z\\}$.\n    - All subsequent characters must belong to the set of uppercase letters, digits, or the underscore character (`_`).\n    - It must contain at least one digit character.\n    - The final character must not be an underscore.\n\nA string that passes all these checks is considered a valid identifier.\n\nWith the `is_valid_identifier` function defined, we can construct the main classification algorithm. For each input string $s$ from a given test case, we apply the following logic:\n$1$. **Check for Validity**: We first call `is_valid_identifier(s)`. If it returns `True`, the string is already valid. It is left unchanged, and the counter $U$ is incremented.\n$2$. **Check for Corruptibility**: If the string is not valid, we test if it matches the specific corruption pattern. This pattern is defined as a string containing exactly one hyphen and zero periods.\n    - If it matches this pattern, we form a candidate string $s'$ by replacing the hyphen with a period.\n    - We then test this candidate string by calling `is_valid_identifier(s')`.\n    - If `is_valid_identifier(s')` returns `True`, the original string $s$ is a correctable corrupted identifier. The counter $C$ is incremented.\n    - If `is_valid_identifier(s')` returns `False`, the original string $s$ is invalid, as its corrected form does not meet the validity criteria. The counter $I$ is incremented.\n$3$. **Handle Other Invalid Strings**: If a string is not valid and does not match the specific corruption pattern (e.g., it contains multiple hyphens, or both a period and a hyphen), it is classified as invalid. The counter $I$ is incremented.\n\nThis process is repeated for every string in a test case. The final result for the test case is the list of integers $[T, C, U, I]$, where $T$ is the total number of strings processed. The results from all test cases are then aggregated into a final list of lists for output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bioinformatics identifier validation and correction problem.\n    \"\"\"\n\n    # The set of allowed characters in the core part of an identifier,\n    # excluding the first character which has a stricter rule.\n    ALLOWED_CORE_CHARS = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_')\n\n    def is_valid_identifier(s_prime: str) -> bool:\n        \"\"\"\n        Checks if a string s_prime is a valid identifier according to the problem rules.\n        \"\"\"\n        # Rule: The string s contains exactly one period character '.' and zero hyphen characters '-'.\n        if s_prime.count('.') != 1 or s_prime.count('-') != 0:\n            return False\n\n        # If s is split at the period into a core part c and a version part v...\n        parts = s_prime.split('.')\n        if len(parts) != 2:\n            # This case is technically covered by count('.') != 1 but is good for robustness.\n            return False\n        \n        c, v = parts\n\n        # Validate the version part v\n        if not v: # Must not be empty\n            return False\n        # v is a base-10 numeral representing a positive integer\n        if not v.isdigit():\n            return False\n        # v represents an integer value >= 1\n        if int(v) < 1:\n            return False\n        # v does not begin with the digit 0 when |v| >= 2\n        if len(v) >= 2 and v.startswith('0'):\n            return False\n\n        # Validate the core part c\n        if not c: # Must not be empty\n            return False\n            \n        # The first character of c is an uppercase letter\n        if not ('A' <= c[0] <= 'Z'):\n            return False\n        \n        # The last character of c is not an underscore character\n        if c.endswith('_'):\n            return False\n\n        has_digit = False\n        # Every character of c is either an uppercase letter, a digit, or an underscore\n        for char in c:\n            if char not in ALLOWED_CORE_CHARS:\n                return False\n            if char.isdigit():\n                has_digit = True\n        \n        # The core c contains at least one digit\n        if not has_digit:\n            return False\n        \n        return True\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [\n            \"AY123456-1\", \"NM_000014-5\", \"NC_000001.11\", \"GCF_000001405-40\",\n            \"XP_011518-0\", \"BADFORMAT-XYZ\", \"AY123456.1\", \"GCF_000001405.40\",\n            \"abc123-1\", \"NR_000001-1-2\"\n        ],\n        [\n            \"A1-1\", \"AA000000-1\", \"A-1\", \"AA1.\", \"AA1-01\",\n            \"AA1-10\", \"AA_1-2\", \"A1.1\", \"A1-1-1\", \"AA1-001\"\n        ],\n        [\n            \"WP_010885.1\", \"WP_010885-1\", \"ENST00000367770-2.3\", \"LRG_123t1-1\",\n            \"XP_011518-1a\", \"-1\", \"A1-1-1\", \"B2-2\",\n            \"C3.03\", \"D4-00\", \"E5-7\", \"F6_-1\"\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        T = len(case)\n        C, U, I = 0, 0, 0\n\n        for s in case:\n            if is_valid_identifier(s):\n                U += 1\n            # Check if it fits the corruption pattern\n            elif s.count('-') == 1 and s.count('.') == 0:\n                s_prime = s.replace('-', '.', 1)\n                if is_valid_identifier(s_prime):\n                    C += 1\n                else:\n                    I += 1\n            else:\n                I += 1\n        \n        results.append([T, C, U, I])\n\n    # Final print statement in the exact required format.\n    # The format [[T1,C1,U1,I1],[T2,C2,U2,I2],...] requires no spaces\n    # after commas. Using str() and replace() is a reliable way to achieve this.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "The world of biological data is constantly evolving, with databases updating sequences and identifier systems changing over time. This advanced practice simulates the crucial task of a bioinformatician: resolving a mix of legacy identifiers, gene synonyms, and different accession types to find the single, modern canonical protein sequence for each. Successfully completing this challenge demonstrates an understanding of how identifiers create a web of connections that ensures long-term reproducibility in science. ",
            "id": "2428399",
            "problem": "You are given a finite, self-contained registry that models how legacy biological identifiers map to modern canonical protein sequences under realistic conventions used by major sequence databases. Your task is to implement a program that, for each input token, resolves it to the modern canonical protein sequence and then reports a quantifiable result for verification.\n\nFoundational base and definitions:\n- The Central Dogma of molecular biology states that deoxyribonucleic acid (DNA) is transcribed to ribonucleic acid (RNA), which is translated to protein. In curated databases, proteins are represented as amino-acid sequences over a fixed alphabet (the standard twenty amino acids), which can be treated as strings over a finite set.\n- Accession identifiers serve as stable references. In the Reference Sequence (RefSeq) system, an accession such as NP_abcdef is paired with a version number $v \\in \\mathbb{N}$, written as NP_abcdef.$v$. The invariant is that the root portion NP_abcdef is stable for the record, while the version number $v$ increments when the underlying sequence changes; thus, the mapping from a root accession to a protein concept is version-independent.\n- GenInfo Identifier (GI) numbers from the National Center for Biotechnology Information (NCBI) are deprecated legacy identifiers that map deterministically to specific RefSeq accessions with versions. A GI number thus induces a mapping to a RefSeq root by stripping the version.\n- The Universal Protein Resource (UniProt) accessions include a primary accession and possibly one or more secondary accessions. Secondary accessions map bijectively to a single primary accession and are retained for backward compatibility.\n- Isoforms in UniProt are denoted by suffixes of the form “-i” for $i \\in \\mathbb{N}$. The canonical isoform convention we adopt is: if isoform “-1” exists for a primary accession, it is the canonical isoform; otherwise, the canonical isoform is the one with the smallest isoform index present in the registry.\n\nYour program must implement these rules to resolve each query to a unique, canonical protein sequence in the provided registry, without any external resources. To produce numerically verifiable outputs, compute for each resolved sequence its length $L \\in \\mathbb{N}$ and its unsigned $64$-bit FNV-1a hash $H \\in \\{0,1,\\dots,2^{64}-1\\}$ of the sequence encoded as American Standard Code for Information Interchange (ASCII) bytes, using the offset basis $14695981039346656037$ and the prime $1099511628211$. The FNV-1a recurrence is:\n- Initialize $h \\leftarrow 14695981039346656037$.\n- For each byte $b$ of the sequence: $h \\leftarrow (h \\oplus b) \\times 1099511628211 \\mod 2^{64}$.\n- The final $h$ is $H$.\n\nRegistry:\n- Primary UniProt accessions and isoform sequences (keys are “ACC-isoformIndex”):\n  - P04637-1: MEEPQSDPSVEPPLSQETFSDLWKLL\n  - P04637-2: MEEPQSDPSVEPPLSQETFSDLWKL\n  - P38398-1: MDLSALRVEEVQNVINAMQKILECPICLE\n  - P01106-1: MPLNVSFTNRNYDLDYDSVQPY\n  - P01106-2: MPLNVSFTNRNYDLDYDSVQP\n  - Q9Y243-1: MSSILPFTPPVKRLLGWKHPGKQL\n- Secondary UniProt to primary mappings:\n  - Q13616 → P04637\n  - Q65484 → P38398\n  - P12524 → P01106\n  - O15162 → Q9Y243\n- RefSeq root to primary UniProt mappings:\n  - NP_000537 → P04637\n  - NP_009225 → P38398\n  - NP_002458 → P01106\n  - NP_123456 → Q9Y243\n- GenInfo Identifier (GI) to RefSeq accession with version:\n  - gi|4557321 → NP_000537.2\n  - gi|8404561 → NP_009225.1\n  - gi|3154298 → NP_002458.1\n  - gi|15726711 → NP_123456.1\n- Gene symbol and synonym to primary UniProt mappings (case-insensitive):\n  - TP53, P53, TRP53 → P04637\n  - BRCA1, BRCC1 → P38398\n  - MYC, C-MYC → P01106\n  - SMAD7, MADH7 → Q9Y243\n\nResolution logic to implement:\n- Let the input token be a string $t$. Normalize $t$ by trimming whitespace.\n- Identify the token type in the following precedence:\n  1. If $t$ matches the GI pattern “gi|$d$” where $d$ is a nonempty sequence of digits, map to the RefSeq accession with version via the GI table, then drop the version to obtain the RefSeq root, then map the root to a primary UniProt accession.\n  2. Else if $t$ matches a RefSeq pattern of the form “NP_digits.version”, map the RefSeq root (the part before the dot) to a primary UniProt accession.\n  3. Else if $t$ matches a UniProt-like pattern with an isoform suffix “-i”: map the base accession to a primary (if it is secondary, first map secondary to primary), then select the canonical isoform for that primary as defined above.\n  4. Else if $t$ matches a UniProt-like accession without an isoform suffix: if it is secondary, map to the primary; if it is already primary, use it as-is.\n  5. Else treat $t$ as a gene symbol or synonym; map case-insensitively to the primary.\n- After obtaining a primary accession, select the canonical isoform for that primary as: if “ACC-1” exists, choose it; otherwise choose the isoform “ACC-i” with the smallest $i$ present in the registry keys.\n- If at any stage a mapping fails (missing key), the result for that test case is “not found”.\n\nQuantifiable outputs:\n- For each input token, output either:\n  - A two-element list $[L,H]$ where $L$ is the integer sequence length and $H$ is the unsigned $64$-bit FNV-1a hash in base-$10$, or\n  - The two-element list $[-1,-1]$ if the token cannot be resolved to any registry entry.\n\nTest suite:\n- Use the following input tokens, in order:\n  - \"TP53\"\n  - \"Q65484\"\n  - \"NP_002458.1\"\n  - \"gi|15726711\"\n  - \"P04637-2\"\n  - \"p53\"\n  - \"gi|99999999\"\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of two-element lists enclosed in square brackets (for example, \"[[L1,H1],[L2,H2],...]\" where each $L_i$ and $H_i$ are base-$10$ integers). No extra whitespace or text should be printed.",
            "solution": "The provided problem statement has been rigorously evaluated and is deemed valid. It is scientifically grounded in the principles of bioinformatics and molecular biology, well-posed with a deterministic resolution logic, and expressed with objective, unambiguous language. The task is to implement a resolution algorithm for biological identifiers based on a defined, self-contained registry and a set of explicit rules. We will now proceed with the formal solution.\n\nThe solution is structured into three primary components: data structure organization, implementation of the FNV-1a hash function, and the identifier resolution algorithm.\n\nFirst, we must represent the provided registry data in a computationally accessible format. Dictionaries, or associative arrays, are the appropriate data structure for these key-value mappings. We will define the following structures:\n\n1.  `ISOFORM_SEQUENCES`: Maps a composite key of the form \"ACC-isoformIndex\" (e.g., `P04637-1`) to its amino acid sequence string.\n2.  `UNIPROT_SECONDARY_TO_PRIMARY`: Maps a secondary UniProt accession to its corresponding primary accession.\n3.  `REFSEQ_TO_UNIPROT`: Maps a RefSeq root accession to a primary UniProt accession.\n4.  `GI_TO_REFSEQ`: Maps a GenInfo (GI) identifier to its full RefSeq accession, including the version.\n5.  `GENE_TO_UNIPROT`: Maps gene symbols and their synonyms to a primary UniProt accession. To accommodate the case-insensitivity requirement, all keys in this structure must be normalized, for instance, to uppercase, and lookup operations must be performed on the uppercase version of the input token.\n\nSecond, the FNV-1a hash function for an unsigned $64$-bit integer space must be implemented. The FNV-1a algorithm is defined by the following recurrence relation for a hash value $h$ and a sequence of bytes $b_1, b_2, \\dots, b_L$:\n- Initialization: $h_0 = \\text{offset\\_basis} = 14695981039346656037$\n- Recurrence: $h_i = (h_{i-1} \\oplus b_i) \\times \\text{prime} \\pmod{2^{64}}$ for $i=1, \\dots, L$.\n\nThe constants are the $64$-bit FNV prime, $p = 1099511628211$, and the $64$-bit FNV offset basis. The operations (XOR $\\oplus$, multiplication $\\times$) are performed using unsigned $64$-bit arithmetic, where overflow wraps around modulo $2^{64}$. This is a standard and deterministic procedure. The final hash value is $H = h_L$.\n\nThird, the core of the problem is the identifier resolution logic. This is an algorithm that processes an input token $t$ according to a strict hierarchy of rules to find a canonical protein sequence. Let us formalize the procedure.\n\n1.  **Normalization**: The input token $t$ is stripped of any leading or trailing whitespace.\n\n2.  **Type Identification and Resolution to Primary Accession**: A primary UniProt accession is derived by checking the token against patterns in a fixed order of precedence.\n    -   **Type 1 (GI)**: If $t$ matches the pattern `gi|d`, where $d$ is a sequence of digits, we look up `t` in the `GI_TO_REFSEQ` mapping. If successful, this yields a RefSeq accession with a version (e.g., `NP_000537.2`). We then extract the root part (e.g., `NP_000537`) by removing the `.version` suffix. This root is then used as a key in the `REFSEQ_TO_UNIPROT` map to obtain the primary UniProt accession. If any lookup fails, the resolution for this token terminates.\n    -   **Type 2 (RefSeq)**: If $t$ is not a GI number but matches the pattern `NP_digits.version`, we extract the root and proceed as in the latter part of the previous step, mapping the RefSeq root to a primary UniProt accession via `REFSEQ_TO_UNIPROT`.\n    -   **Type 3 (UniProt with Isoform)**: If $t$ matches the pattern `ACC-i`, we extract the base accession `ACC`. We must resolve `ACC` to a primary accession. If `ACC` is a secondary accession (i.e., a key in `UNIPROT_SECONDARY_TO_PRIMARY`), we map it to its primary accession. Otherwise, we assume `ACC` is itself the primary accession.\n    -   **Type 4 (UniProt without Isoform)**: If $t$ is a string that does not match the previous patterns, we check if it is a UniProt accession. If $t$ is found as a key in `UNIPROT_SECONDARY_TO_PRIMARY`, we map it to its primary accession. Otherwise, we assume $t$ is the primary accession.\n    -   **Type 5 (Gene Symbol)**: If all previous checks fail, we treat $t$ as a gene symbol. We convert $t$ to uppercase and look it up in the `GENE_TO_UNIPROT` map to find the primary UniProt accession.\n\n3.  **Canonical Isoform Selection**: After a primary UniProt accession, let us call it $P$, is successfully identified, we must select the corresponding canonical isoform sequence from the `ISOFORM_SEQUENCES` registry. The rule is as follows:\n    -   If an entry for the key `$P$-1` exists in the registry, its sequence is the canonical one.\n    -   Otherwise, we identify all existing isoforms for $P$ (i.e., all keys starting with `$P$-`). From this set, we select the one with the smallest isoform index $i$.\n    -   If no isoforms for $P$ are found in the registry, the resolution fails.\n\n4.  **Final Calculation and Output**: If a canonical sequence is successfully resolved, its length $L$ and its FNV-1a hash $H$ are calculated. The result is the pair $[L, H]$. If at any point the resolution fails (e.g., a key is not found in a map), the result is defined as $[-1, -1]$.\n\nFor example, consider the input token `\"P04637-2\"`.\n- It matches Type 3. The base accession is `P04637`. This is a primary accession.\n- The next step is to find the canonical isoform for `P04637`.\n- The registry contains `P04637-1`. According to the rule, since isoform `-1` exists, it is the canonical one.\n- The resolved sequence is thus the one associated with `P04637-1`, which is `MEEPQSDPSVEPPLSQETFSDLWKLL`.\n- The length is $L=26$, and its FNV-1a hash $H$ would be computed. The input's specified isoform `-2` is superseded by the rule to select the canonical isoform.\n\nThis procedure is deterministic and guarantees a unique result for every input token, given the provided registry. The implementation must follow these steps precisely.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\n\ndef solve():\n    # Registry data defined as per the problem statement\n    ISOFORM_SEQUENCES = {\n        \"P04637-1\": \"MEEPQSDPSVEPPLSQETFSDLWKLL\",\n        \"P04637-2\": \"MEEPQSDPSVEPPLSQETFSDLWKL\",\n        \"P38398-1\": \"MDLSALRVEEVQNVINAMQKILECPICLE\",\n        \"P01106-1\": \"MPLNVSFTNRNYDLDYDSVQPY\",\n        \"P01106-2\": \"MPLNVSFTNRNYDLDYDSVQP\",\n        \"Q9Y243-1\": \"MSSILPFTPPVKRLLGWKHPGKQL\",\n    }\n    \n    UNIPROT_SECONDARY_TO_PRIMARY = {\n        \"Q13616\": \"P04637\", \"Q65484\": \"P38398\", \"P12524\": \"P01106\", \"O15162\": \"Q9Y243\",\n    }\n    \n    REFSEQ_TO_UNIPROT = {\n        \"NP_000537\": \"P04637\", \"NP_009225\": \"P38398\", \"NP_002458\": \"P01106\", \"NP_123456\": \"Q9Y243\",\n    }\n    \n    GI_TO_REFSEQ = {\n        \"gi|4557321\": \"NP_000537.2\", \"gi|8404561\": \"NP_009225.1\", \"gi|3154298\": \"NP_002458.1\", \"gi|15726711\": \"NP_123456.1\",\n    }\n\n    # Gene symbol mapping is case-insensitive. We store keys in uppercase.\n    GENE_TO_UNIPROT = {\n        \"TP53\": \"P04637\", \"P53\": \"P04637\", \"TRP53\": \"P04637\",\n        \"BRCA1\": \"P38398\", \"BRCC1\": \"P38398\",\n        \"MYC\": \"P01106\", \"C-MYC\": \"P01106\",\n        \"SMAD7\": \"Q9Y243\", \"MADH7\": \"Q9Y243\",\n    }\n\n    # FNV-1a hash parameters\n    FNV_PRIME = np.uint64(1099511628211)\n    FNV_OFFSET_BASIS = np.uint64(14695981039346656037)\n\n    def fnv1a_hash(sequence_str):\n        \"\"\"Computes the 64-bit FNV-1a hash of a string.\"\"\"\n        h = FNV_OFFSET_BASIS\n        for byte in sequence_str.encode('ascii'):\n            h ^= np.uint64(byte)\n            h *= FNV_PRIME\n        return int(h)\n\n    def get_canonical_isoform_key(primary_acc):\n        \"\"\"Finds the canonical isoform for a given primary UniProt accession.\"\"\"\n        key_iso1 = f\"{primary_acc}-1\"\n        if key_iso1 in ISOFORM_SEQUENCES:\n            return key_iso1\n        \n        isoform_indices = []\n        for key in ISOFORM_SEQUENCES:\n            if key.startswith(f\"{primary_acc}-\"):\n                try:\n                    index_part = key.split('-')[1]\n                    isoform_indices.append(int(index_part))\n                except (ValueError, IndexError):\n                    continue\n        \n        if not isoform_indices:\n            return None\n        \n        min_index = min(isoform_indices)\n        return f\"{primary_acc}-{min_index}\"\n\n    def resolve_token(token):\n        \"\"\"Resolves an input token to a primary UniProt accession.\"\"\"\n        token = token.strip()\n        \n        # Rule 1: GI pattern\n        if token.startswith(\"gi|\") and len(token.split('|')) > 1 and token.split('|')[1].isdigit():\n            refseq_ver = GI_TO_REFSEQ.get(token)\n            if refseq_ver:\n                refseq_root = refseq_ver.split('.')[0]\n                return REFSEQ_TO_UNIPROT.get(refseq_root)\n            return None\n\n        # Rule 2: RefSeq pattern\n        if re.match(r\"^NP_\\d+\\.\\d+$\", token):\n            refseq_root = token.split('.')[0]\n            return REFSEQ_TO_UNIPROT.get(refseq_root)\n\n        # Rule 3: UniProt with isoform pattern\n        match = re.match(r\"^([A-Z0-9]+)-(\\d+)$\", token)\n        if match:\n            base_acc = match.group(1)\n            return UNIPROT_SECONDARY_TO_PRIMARY.get(base_acc, base_acc)\n\n        # Rule 4: UniProt without isoform\n        # A simple heuristic: if it's alphanumeric and in one of the relevant DBs\n        if re.match(r\"^[A-Z0-9]+$\", token):\n             # Check if it's secondary\n            if token in UNIPROT_SECONDARY_TO_PRIMARY:\n                return UNIPROT_SECONDARY_TO_PRIMARY[token]\n            # Check if it's a known primary through its isoforms\n            for key in ISOFORM_SEQUENCES:\n                if key.startswith(token + '-'):\n                    return token\n\n        # Rule 5: Gene symbol\n        primary_acc = GENE_TO_UNIPROT.get(token.upper())\n        if primary_acc:\n            return primary_acc\n\n        return None\n\n    def get_result(token):\n        \"\"\"Main logic to process one token and return the result.\"\"\"\n        primary_acc = resolve_token(token)\n        if not primary_acc:\n            return [-1, -1]\n        \n        canonical_key = get_canonical_isoform_key(primary_acc)\n        if not canonical_key:\n            return [-1, -1]\n            \n        sequence = ISOFORM_SEQUENCES.get(canonical_key)\n        if not sequence:\n            return [-1, -1]\n            \n        length = len(sequence)\n        hash_val = fnv1a_hash(sequence)\n        \n        return [length, hash_val]\n\n    # Test suite from the problem description\n    test_cases = [\n        \"TP53\",\n        \"Q65484\",\n        \"NP_002458.1\",\n        \"gi|15726711\",\n        \"P04637-2\",\n        \"p53\",\n        \"gi|99999999\"\n    ]\n\n    results = []\n    for case in test_cases:\n        result = get_result(case)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    # Using str().replace() ensures no spaces are included in the final output.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}