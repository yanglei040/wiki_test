{
    "hands_on_practices": [
        {
            "introduction": "深入理解一个算法的最好方法莫过于亲手实现它。这个练习将引导你从零开始构建渐进式比对的核心引擎：档案-档案比对（profile-profile alignment）。通过完成这项编码任务 ，你将亲身体验动态规划如何应用于比对两个序列集合，并巩固你对配对总和（Sum-of-Pairs）评分方案的理解。",
            "id": "2418810",
            "problem": "给定一个由脱氧核糖核酸 (DNA) 核苷酸组成的有限字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 和一个不属于 $\\Sigma$ 的空格符号 $-$。设配对替换计分函数 $S:\\left(\\Sigma \\cup \\{-\\}\\right)\\times\\left(\\Sigma \\cup \\{-\\}\\right)\\to\\mathbb{Z}$ 由以下规则定义：\n- 对于任意 $a \\in \\Sigma$，$S(a,a) = +1$。\n- 对于任意不同的 $a,b \\in \\Sigma$ 且 $a \\neq b$，$S(a,b) = -1$。\n- 对于任意 $a \\in \\Sigma$，$S(a,-) = S(-,a) = \\gamma$，其中 $\\gamma = -2$。\n- $S(-,-) = 0$。\n\n给定一棵有根的满二叉指导树，其叶节点由一组序列标识符进行单射标记，并且每个叶节点标签都映射到 $\\Sigma$ 上的一个有限字符串（可能为空字符串），多序列比对的定义如下。对于每个具有左子节点和右子节点的内部节点，通过在全局比对模型下，最大化所有跨档案叶节点对关于 $S$ 的配对分数总和，来合并两个子比对，形成一个合并后的比对。该模型允许在将一个档案的列与另一个档案的列进行比对时，在一个档案中插入由空格组成的列。当比对两个现有列时，对总分的贡献是所有有序对 $(x,y)$ 的 $S(x,y)$ 之和，其中 $x$ 是来自左列的字符（可能是从先前合并中继承的空格），$y$ 是来自右列的字符（也可能是从先前合并中继承的空格）。当将一列与为另一档案插入的空格列进行比对时，其贡献是该列中所有字符与另一档案中所有序列（作为空格）配对的得分总和。根节点的比对即为最终的多序列比对。\n\n为了在存在多个最优解时确保确定性，在每个内部节点的全局比对中应用以下平局打破顺序：优先选择列与列的比对，其次是左档案的列与右档案的空格列的比对，最后是左档案的空格列与右档案的列的比对。\n\n对于任意生成的包含 $N$ 条序列、比对后长度均为 $L$ 的多序列比对 $\\mathcal{A}$，定义配对总和 (SP) 分数为\n$$\n\\mathrm{SP}(\\mathcal{A}) \\;=\\; \\sum_{1 \\leq i  j \\leq N} \\;\\sum_{k=1}^{L} \\; S\\!\\left(\\mathcal{A}_{i,k}, \\mathcal{A}_{j,k}\\right),\n$$\n其中 $\\mathcal{A}_{i,k}$ 表示第 $i$ 条序列在比对位置 $k$ 处的字符（属于 $\\Sigma \\cup \\{-\\}$）。\n\n您的任务是编写一个完整的程序，根据每个指导树及其关联序列构建多序列比对，然后计算最终比对的 SP 分数。请使用上面给出的确切的 $S$ 和 $\\gamma$。树以叶标签上的完全括号化二元表达式形式指定。树中提到的所有叶节点都有对应的序列。\n\n测试套件。对于下方的每个测试用例，程序必须计算最终多序列比对的 SP 分数：\n\n- 测试用例 1:\n  - 序列:\n    - $s1 \\mapsto$ \"ACGT\"\n    - $s2 \\mapsto$ \"ACCT\"\n    - $s3 \\mapsto$ \"AGGT\"\n  - 指导树: $\\big((s1,s2),s3\\big)$\n\n- 测试用例 2:\n  - 序列:\n    - $t1 \\mapsto$ \"GATTACA\"\n    - $t2 \\mapsto$ \"GACTATA\"\n    - $t3 \\mapsto$ \"GACTACA\"\n  - 指导树: $\\big((t1,t2),t3\\big)$\n\n- 测试用例 3:\n  - 序列:\n    - $x1 \\mapsto$ \"AAA\"\n    - $x2 \\mapsto$ \"AAAA\"\n  - 指导树: $\\big(x1,x2\\big)$\n\n- 测试用例 4 (包含空序列的边界情况):\n  - 序列:\n    - $e1 \\mapsto$ \"\" (空字符串)\n    - $e2 \\mapsto$ \"AAA\"\n  - 指导树: $\\big(e1,e2\\big)$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中第 $i$ 个条目是按上述顺序列出的测试用例 $i$ 的 SP 分数（一个整数）。不涉及单位；所有值都是无量纲的整数。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它具有科学依据、良定、客观且内部一致。它描述了计算生物学中的一种标准算法——渐进式多序列比对——其所有参数、过程和打破平局的规则都已明确指定。因此，我们可以着手解决。\n\n任务是计算通过给定二叉树指导的渐进式策略构建的多序列比对的配对总和 (SP) 分数。该过程涉及对指导树进行递归的、自底向上的遍历。在每个内部节点处，其两个子节点对应的比对会通过一个称为档案-档案比对的过程进行比对。然后使用 SP 分数度量来评估树根处的最终比对。\n\n解决方案的基本组成部分如下：\n1.  一种解析括号化指导树结构的方法。\n2.  一个递归函数，用于遍历树并在每个内部节点执行比对。\n3.  一个基于动态规划的档案-档案比对算法，它构成了渐进式比对过程的核心。\n4.  一个计算根比对最终 SP 分数的函数。\n\n让我们按照规定定义计分函数 $S:\\left(\\Sigma \\cup \\{-\\}\\right)\\times\\left(\\Sigma \\cup \\{-\\}\\right)\\to\\mathbb{Z}$，其中 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$：\n-   对于任意 $a \\in \\Sigma$，$S(a,a) = +1$。\n-   对于任意不同的 $a,b \\in \\Sigma$，$S(a,b) = -1$。\n-   对于任意 $a \\in \\Sigma$，$S(a,-) = S(-,a) = \\gamma = -2$。\n-   $S(-,-) = 0$。\n\n一个档案，即一个序列子集的现有比对，可以表示为一组长度统一的比对后序列。设左档案 $\\mathcal{A}_1$ 包含 $N_1$ 条长度为 $L_1$ 的序列，右档案 $\\mathcal{A}_2$ 包含 $N_2$ 条长度为 $L_2$ 的序列。档案-档案比对的目标是通过在 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 中插入空格列来生成一个包含所有 $N_1+N_2$ 条序列的新的合并比对，以最大化一个定义好的分数。\n\n$\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 的比对是使用一种类似于用于双序列比对的 Needleman-Wunsch 算法的动态规划算法来执行的。我们构建一个大小为 $(L_1+1) \\times (L_2+1)$ 的动态规划矩阵 $M$，其中 $M_{i,j}$ 存储了 $\\mathcal{A}_1$ 长度为 $i$ 的前缀（即前 $i$ 列）与 $\\mathcal{A}_2$ 长度为 $j$ 的前缀进行比对的最大分数。\n\n比对两个档案列，或一个档案列与一列空格的分数必须被定义。问题陈述指出，这是所有跨档案叶节点对的分数之和。\n-   **列-列分数**：比对 $\\mathcal{A}_1$ 的第 $i$ 列与 $\\mathcal{A}_2$ 的第 $j$ 列的分数，记为 $\\text{score}_{\\text{col-col}}(i,j)$，由下式给出：\n    $$ \\text{score}_{\\text{col-col}}(i,j) = \\sum_{p=1}^{N_1} \\sum_{q=1}^{N_2} S\\left((\\mathcal{A}_1)_{p,i}, (\\mathcal{A}_2)_{q,j}\\right) $$\n    其中 $(\\mathcal{A}_k)_{r,c}$ 是比对 $\\mathcal{A}_k$ 中第 $r$ 条序列在第 $c$ 列的字符。\n-   **列-空格分数**：将一列与一列空格进行比对的分数，是为被插入空格的档案中每条序列的空格罚分之和。\n    -   将 $\\mathcal{A}_1$ 的第 $i$ 列与空格比对（针对 $\\mathcal{A}_2$ 中的所有 $N_2$ 条序列）：\n        $$ \\text{score}_{\\text{gap-R}}(i) = \\sum_{p=1}^{N_1} N_2 \\cdot S\\left((\\mathcal{A}_1)_{p,i}, -\\right) $$\n    -   将 $\\mathcal{A}_2$ 的第 $j$ 列与空格比对（针对 $\\mathcal{A}_1$ 中的所有 $N_1$ 条序列）：\n        $$ \\text{score}_{\\text{gap-L}}(j) = \\sum_{q=1}^{N_2} N_1 \\cdot S\\left(-, (\\mathcal{A}_2)_{q,j}\\right) $$\n\nDP 矩阵 $M$ 的填充方式如下：\n-   **初始化**：\n    $$ M_{0,0} = 0 $$\n    $$ M_{i,0} = M_{i-1,0} + \\text{score}_{\\text{gap-R}}(i) \\quad \\text{for } i \\in [1, L_1] $$\n    $$ M_{0,j} = M_{0,j-1} + \\text{score}_{\\text{gap-L}}(j) \\quad \\text{for } j \\in [1, L_2] $$\n-   **递推关系**：对于 $i \\in [1, L_1]$ 和 $j \\in [1, L_2]$，$M_{i,j}$ 的计算基于三种可能性：\n    1.  将 $\\mathcal{A}_1$ 的第 $i$ 列与 $\\mathcal{A}_2$ 的第 $j$ 列比对（对角线移动）：$S_{\\text{diag}} = M_{i-1, j-1} + \\text{score}_{\\text{col-col}}(i,j)$。\n    2.  将 $\\mathcal{A}_1$ 的第 $i$ 列与一个空格列比对（向下移动）：$S_{\\text{down}} = M_{i-1, j} + \\text{score}_{\\text{gap-R}}(i)$。\n    3.  将 $\\mathcal{A}_2$ 的第 $j$ 列与一个空格列比对（向右移动）：$S_{\\text{right}} = M_{i, j-1} + \\text{score}_{\\text{gap-L}}(j)$。\n\n    $$ M_{i,j} = \\max(S_{\\text{diag}}, S_{\\text{down}}, S_{\\text{right}}) $$\n\n为确保确定性结果，应用了平局打破规则。问题指定了偏好顺序：(1) 列-列比对，(2) 左档案列对比空格，(3) 右档案列对比空格。这对应于在 DP 矩阵中优先选择对角线移动，然后是向下移动，最后是向右移动。一个回溯矩阵 $T$ 与 $M$ 同时构建，以存储最优选择。\n\n一旦矩阵 $M$ 被填充完毕，最优比对通过使用存储在 $T$ 中的选择，从 $M_{L_1,L_2}$ 回溯到 $M_{0,0}$ 来重构。回溯中的每一步都对应于构建新的合并比对的一列。\n\n在指导树的根节点完成整个渐进式比对过程后，得到一个包含 $N$ 条长度为 $L$ 的序列的最终多序列比对 $\\mathcal{A}$。配对总和 (SP) 分数按规定计算：\n$$ \\mathrm{SP}(\\mathcalA) = \\sum_{1 \\leq i  j \\leq N} \\sum_{k=1}^{L} S(\\mathcal{A}_{i,k}, \\mathcal{A}_{j,k}) $$\n这可以通过遍历所有序列对并对它们的配对比对分数求和来计算，或者等价地，通过遍历每一列，计算该列内所有字符对的分数总和，然后将这些列分数相加来计算。\n\n整体算法的实现首先是将指导树解析成一个嵌套结构。然后，一个递归函数遍历该结构，在每个内部节点执行档案-档案比对并返回合并后的档案。递归的基线条件是叶节点，即单个序列。在根节点的递归最终结果是完整的多序列比对，然后计算其 SP 分数。",
            "answer": "```python\nimport numpy as np\nimport sys\nfrom collections import defaultdict\n\n# Set a higher recursion limit for deep trees, although not strictly necessary for test cases.\nsys.setrecursionlimit(2000)\n\n_S_SCORES = None\n_GAMMA = -2\n\ndef S(c1, c2):\n    \"\"\"Computes the substitution score S(c1, c2).\"\"\"\n    global _S_SCORES\n    if _S_SCORES is None:\n        _S_SCORES = defaultdict(lambda: defaultdict(int))\n        alphabet = ['A', 'C', 'G', 'T']\n        for char1 in alphabet:\n            for char2 in alphabet:\n                _S_SCORES[char1][char2] = 1 if char1 == char2 else -1\n            _S_SCORES[char1]['-'] = _GAMMA\n            _S_SCORES['-'][char1] = _GAMMA\n        _S_SCORES['-']['-'] = 0\n    return _S_SCORES[c1][c2]\n\ndef parse_tree(expr):\n    \"\"\"\n    Parses a Newick-like tree string into a nested tuple structure.\n    Example: '((s1,s2),s3)' - (('s1', 's2'), 's3')\n    \"\"\"\n    expr = expr.strip()\n    if expr.startswith('(') and expr.endswith(')'):\n        expr = expr[1:-1]\n        balance = 0\n        split_index = -1\n        for i, char in enumerate(expr):\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            elif char == ',' and balance == 0:\n                split_index = i\n                break\n        \n        if split_index != -1:\n            left = expr[:split_index]\n            right = expr[split_index+1:]\n            return (parse_tree(left), parse_tree(right))\n    return expr\n\ndef progressive_align(node, sequences):\n    \"\"\"\n    Recursively performs progressive alignment based on the guide tree.\n    `node`: a node from the parsed tree structure.\n    `sequences`: a dict mapping sequence IDs to sequences.\n    \n    Returns a profile (dict mapping seq_id to aligned sequence).\n    \"\"\"\n    if isinstance(node, str):  # Leaf node\n        return {node: sequences[node]}\n    \n    left_child, right_child = node\n    \n    left_profile = progressive_align(left_child, sequences)\n    right_profile = progressive_align(right_child, sequences)\n    \n    return profile_profile_align(left_profile, right_profile)\n\ndef profile_profile_align(prof1, prof2):\n    \"\"\"\n    Aligns two profiles using dynamic programming.\n    Profiles are dicts of {seq_id: aligned_sequence}.\n    \"\"\"\n    if not prof1: return prof2\n    if not prof2: return prof1\n\n    seqs1 = list(prof1.values())\n    seqs2 = list(prof2.values())\n\n    len1 = len(seqs1[0]) if seqs1 else 0\n    len2 = len(seqs2[0]) if seqs2 else 0\n    n1, n2 = len(seqs1), len(seqs2)\n\n    dp_matrix = np.zeros((len1 + 1, len2 + 1))\n    # 1: diag, 2: down (gap in prof2), 3: right (gap in prof1)\n    traceback_matrix = np.zeros((len1 + 1, len2 + 1), dtype=int)\n\n    # Calculate column-gap scores\n    prof1_cols = list(zip(*seqs1))\n    prof2_cols = list(zip(*seqs2))\n\n    gap_scores1 = np.array([sum(S(c, '-') for c in col) * n2 for col in prof1_cols])\n    gap_scores2 = np.array([sum(S(c, '-') for c in col) * n1 for col in prof2_cols])\n\n    # Initialize DP matrix\n    for i in range(1, len1 + 1):\n        dp_matrix[i, 0] = dp_matrix[i - 1, 0] + gap_scores1[i - 1]\n        traceback_matrix[i, 0] = 2\n    for j in range(1, len2 + 1):\n        dp_matrix[0, j] = dp_matrix[0, j - 1] + gap_scores2[j - 1]\n        traceback_matrix[0, j] = 3\n\n    # Fill DP matrix\n    for i in range(1, len1 + 1):\n        col1 = prof1_cols[i - 1]\n        for j in range(1, len2 + 1):\n            col2 = prof2_cols[j - 1]\n            \n            match_score = sum(S(c1, c2) for c1 in col1 for c2 in col2)\n            \n            s_diag = dp_matrix[i - 1, j - 1] + match_score\n            s_down = dp_matrix[i - 1, j] + gap_scores1[i - 1]\n            s_right = dp_matrix[i, j - 1] + gap_scores2[j - 1]\n            \n            scores = [s_diag, s_down, s_right]\n            max_score = max(scores)\n            \n            # Apply tie-breaking: diag  down  right\n            if max_score == s_diag:\n                dp_matrix[i, j] = s_diag\n                traceback_matrix[i, j] = 1\n            elif max_score == s_down:\n                dp_matrix[i, j] = s_down\n                traceback_matrix[i, j] = 2\n            else: # max_score == s_right\n                dp_matrix[i, j] = s_right\n                traceback_matrix[i, j] = 3\n    \n    # Traceback\n    merged_profile = {seq_id: [] for seq_id in list(prof1.keys()) + list(prof2.keys())}\n    i, j = len1, len2\n    \n    while i  0 or j  0:\n        move = traceback_matrix[i, j]\n        if move == 1:  # Diag\n            for k, seq_id in enumerate(prof1.keys()):\n                merged_profile[seq_id].append(seqs1[k][i-1])\n            for k, seq_id in enumerate(prof2.keys()):\n                merged_profile[seq_id].append(seqs2[k][j-1])\n            i -= 1\n            j -= 1\n        elif move == 2:  # Down\n            for k, seq_id in enumerate(prof1.keys()):\n                merged_profile[seq_id].append(seqs1[k][i-1])\n            for seq_id in prof2.keys():\n                merged_profile[seq_id].append('-')\n            i -= 1\n        elif move == 3:  # Right\n            for seq_id in prof1.keys():\n                merged_profile[seq_id].append('-')\n            for k, seq_id in enumerate(prof2.keys()):\n                merged_profile[seq_id].append(seqs2[k][j-1])\n            j -= 1\n            \n    final_merged = {seq_id: \"\".join(reversed(chars)) for seq_id, chars in merged_profile.items()}\n    return final_merged\n\ndef calculate_sp_score(alignment):\n    \"\"\"Calculates the Sum-of-Pairs score for a given final alignment.\"\"\"\n    if not alignment or len(alignment)  2:\n        return 0\n    \n    seq_ids = list(alignment.keys())\n    sequences = list(alignment.values())\n    \n    num_seqs = len(sequences)\n    if num_seqs == 0: return 0\n    \n    aln_len = len(sequences[0])\n    if aln_len == 0: return 0\n    \n    total_score = 0\n    # Sum of scores over columns\n    for k in range(aln_len):\n        col_score = 0\n        column = [sequences[i][k] for i in range(num_seqs)]\n        for i in range(num_seqs):\n            for j in range(i + 1, num_seqs):\n                col_score += S(column[i], column[j])\n        total_score += col_score\n        \n    return total_score\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        {\n            \"sequences\": {\"s1\": \"ACGT\", \"s2\": \"ACCT\", \"s3\": \"AGGT\"},\n            \"tree\": \"((s1,s2),s3)\"\n        },\n        {\n            \"sequences\": {\"t1\": \"GATTACA\", \"t2\": \"GACTATA\", \"t3\": \"GACTACA\"},\n            \"tree\": \"((t1,t2),t3)\"\n        },\n        {\n            \"sequences\": {\"x1\": \"AAA\", \"x2\": \"AAAA\"},\n            \"tree\": \"(x1,x2)\"\n        },\n        {\n            \"sequences\": {\"e1\": \"\", \"e2\": \"AAA\"},\n            \"tree\": \"(e1,e2)\"\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        sequences = case[\"sequences\"]\n        tree_expr = case[\"tree\"]\n        \n        parsed_tree = parse_tree(tree_expr)\n        final_alignment = progressive_align(parsed_tree, sequences)\n        sp_score = calculate_sp_score(final_alignment)\n        \n        results.append(int(sp_score))\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "渐进式比对是一种启发式算法，这意味着它不保证能找到最优的多序列比对结果。这个练习  通过一个关于“嵌合体”序列的思想实验，揭示了该算法的一个典型“陷阱”。通过分析这个“人造”序列如何破坏引导树的构建，你将对该算法的“贪婪”本质及其对输入数据质量的敏感性获得批判性的认识。",
            "id": "2418778",
            "problem": "给定五个长度为 $12$ 的DNA序列，它们由字母表 $\\{A,C,G,T\\}$ 构成。其中四个序列 $S_1,\\;S_2,\\;S_3,\\;S_4$ 来自两个进化分支：$S_1,\\;S_2$ 来自进化分支 $X$，$S_3,\\;S_4$ 来自进化分支 $Y$。第五个序列 $C$ 是一个嵌合体结构，由 $S_1$ 的前半部分（位置 $1$ 到 $6$）和 $S_3$ 的后半部分（位置 $7$ 到 $12$）拼接而成。这些序列是：\n- $S_1 = \\text{AAAAAACCCCCC}$\n- $S_2 = \\text{AAAAATCCCCCC}$\n- $S_3 = \\text{GGGGGGTTTTTT}$\n- $S_4 = \\text{GGGGTGTTTTTT}$\n- $C = \\text{AAAAAATTTTTT}$\n\n将使用算术平均非加权配对法（UPGMA）构建一个指导树，其基于成对距离 $d(i,j)$，定义为 $d(i,j)=1-\\text{pid}(i,j)$，其中 $\\text{pid}(i,j)$ 是序列 $i$ 和 $j$ 在逐位无间隙比较中相同字符的比例（这是合理的，因为所有序列长度均为 $12$ 且不考虑插入缺失）。然后，将根据这个 UPGMA 指导树，通过对齐序列和配置文件来构建一个渐进式多序列比对（MSA），不进行任何迭代优化或事后重新比对。\n\n哪个选项最能描述添加嵌合序列 $C$ 对 UPGMA 指导树拓扑结构以及下游渐进式多序列比对的影响？\n\nA. UPGMA 首先将 $(S_1,S_2)$ 和 $(S_3,S_4)$ 聚类，然后在与 $(S_1,S_2)$ 合并之前将 $C$ 附加到 $(S_3,S_4)$ 簇。因此，渐进式比对将 $(C,S_3,S_4)$ 的配置文件与 $(S_1,S_2)$ 的配置文件进行比对，使得 $(C,S_3,S_4)$ 富含 $T$ 的后半部分被迫与 $(S_1,S_2)$ 富含 $C$ 的后半部分对齐，而富含 $G$ 的前半部分则与富含 $A$ 的前半部分对齐，从而混合了不相关的片段，降低了两半部分的比对准确性。\n\nB. UPGMA 将 $C$ 作为一个与所有其他序列在根部等距的外群，使得渐进式比对相对于没有 $C$ 的比对实际上没有变化。\n\nC. UPGMA 首先将 $C$ 与 $S_1$ 聚类，然后将这对与 $S_2$ 合并形成进化分支 $X$，从而防止了干扰，因为 $C$ 与 $S_1$ 共享前半部分；最终的 MSA 在两半部分都保持最优。\n\nD. UPGMA 首先将 $S_1$ 与 $S_3$ 聚类，因为 $C$ 连接了它们并降低了它们的估计距离；尽管这在指导树中混合了进化分支，但渐进式比对器通过迭代优化来补偿以恢复正确的 MSA。",
            "solution": "首先将对所提供的问题进行科学性和逻辑完整性验证。\n\n### 步骤 1：提取已知信息\n问题提供了以下信息：\n-   一组五个长度为 $L=12$ 的DNA序列：$S_1, S_2, S_3, S_4, C$。\n-   序列定义：\n    -   $S_1 = \\text{AAAAAACCCCCC}$\n    -   $S_2 = \\text{AAAAATCCCCCC}$\n    -   $S_3 = \\text{GGGGGGTTTTTT}$\n    -   $S_4 = \\text{GGGGTGTTTTTT}$\n    -   $C = \\text{AAAAAATTTTTT}$\n-   进化分支关联：$(S_1, S_2)$ 属于进化分支 $X$；$(S_3, S_4)$ 属于进化分支 $Y$。\n-   $C$ 的嵌合来源：它由 $S_1$ 的前 $6$ 个位置和 $S_3$ 的后 $6$ 个位置构成。此定义与提供的 $C$ 序列一致。\n-   聚类算法：算术平均非加权配对法（UPGMA）。\n-   距离度量：$d(i,j) = 1 - \\text{pid}(i,j)$，其中 $\\text{pid}(i,j)$ 是相同位点的比例。鉴于所有序列的长度均为 $L=12$ 且无空位，这等同于 $d(i,j) = m(i,j)/12$，其中 $m(i,j)$ 是序列 $i$ 和 $j$ 之间的错配数。\n-   比对过程：基于 UPGMA 指导树的渐进式多序列比对。\n-   约束条件：不使用迭代优化或事后重新比对。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据标准科学准则评估问题陈述：\n-   **科学基础**：该问题植根于生物信息学的基本概念，即序列比对、距离计算、系统发育树构建（UPGMA）以及嵌合序列的混杂效应。所有方法和定义都是该领域的标准。\n-   **适定性**：该问题是适定的。提供的序列和算法（具有指定距离度量的UPGMA）足以生成唯一的指导树和可预测的比对结果。问题要求描述此结果。\n-   **客观性**：问题陈述客观、精确，没有歧义或主观因素。\n-   **内部一致性**：对嵌合序列 $C$ 的文字描述与明确提供的序列数据一致。所有数据和条件都是自洽的。\n\n### 步骤 3：结论和行动\n问题有效。可以推导出严谨的解决方案。\n\n### 解题推导\n\n解决方案需要两个主要步骤：1) 构建 UPGMA 指导树，以及 2) 分析由此产生的渐进式多序列比对（MSA）。\n\n**步骤 1：UPGMA 树的构建**\n\n首先，我们必须计算成对距离矩阵 $D$。距离为 $d(i,j) = m(i,j)/12$。\n\n错配数 $m(i,j)$ 如下：\n-   $m(S_1, S_2) = 1$ (在位置 $6$)\n-   $m(S_3, S_4) = 1$ (在位置 $6$)\n-   $m(S_1, S_3) = 12$\n-   $m(S_1, S_4) = 12$\n-   $m(S_2, S_3) = 12$\n-   $m(S_2, S_4) = 12$\n-   $m(S_1, C) = m(\\text{AAAAAACCCCCC}, \\text{AAAAAATTTTTT}) = 6$ (在位置 $7$-$12$ 处错配)\n-   $m(S_2, C) = m(\\text{AAAAATCCCCCC}, \\text{AAAAAATTTTTT}) = 7$ (在位置 $6$ 和位置 $7$-$12$ 处错配)\n-   $m(S_3, C) = m(\\text{GGGGGGTTTTTT}, \\text{AAAAAATTTTTT}) = 6$ (在位置 $1$-$6$ 处错配)\n-   $m(S_4, C) = m(\\text{GGGGTGTTTTTT}, \\text{AAAAAATTTTTT}) = 6$ (在位置 $1$-$6$ 处错配)\n\n距离矩阵 $D$ 是（错配矩阵的 $1/12$）：\n$$\nD = \\begin{pmatrix}\n  S_1  S_2  S_3  S_4  C \\\\\nS_1  0  1/12  12/12  12/12  6/12 \\\\\nS_2  1/12  0  12/12  12/12  7/12 \\\\\nS_3  12/12  12/12  0  1/12  6/12 \\\\\nS_4  12/12  12/12  1/12  0  6/12 \\\\\nC  6/12  7/12  6/12  6/12  0\n\\end{pmatrix}\n$$\n\n现在，我们应用 UPGMA 算法：\n\n-   **迭代 1**：最小的非零距离是 $d(S_1, S_2) = 1/12$ 和 $d(S_3, S_4) = 1/12$。我们可以合并这两对。\n    -   聚类 $U_X = (S_1, S_2)$。\n    -   聚类 $U_Y = (S_3, S_4)$。\n    问题简化为找到 $\\{U_X, U_Y, C\\}$ 的聚类。我们需要这三个实体之间的距离。\n\n-   **迭代 2**：我们计算新簇与剩余序列 $C$ 之间的距离。UPGMA 距离是算术平均值。\n    -   $d(C, U_X) = \\frac{d(C, S_1) + d(C, S_2)}{2} = \\frac{6/12 + 7/12}{2} = \\frac{13/12}{2} = 13/24$。\n    -   $d(C, U_Y) = \\frac{d(C, S_3) + d(C, S_4)}{2} = \\frac{6/12 + 6/12}{2} = \\frac{12/12}{2} = 1/2 = 12/24$。\n    -   原始非嵌合簇之间的距离是：\n        $d(U_X, U_Y) = \\frac{d(S_1,S_3)+d(S_1,S_4)+d(S_2,S_3)+d(S_2,S_4)}{4} = \\frac{1+1+1+1}{4} = 1 = 24/24$。\n\n-   **迭代 3**：我们比较距离 $\\{d(C, U_X), d(C, U_Y), d(U_X, U_Y)\\}$。\n    -   $d(C, U_Y) = 12/24$\n    -   $d(C, U_X) = 13/24$\n    -   $d(U_X, U_Y) = 24/24$\n    最小距离是 $d(C, U_Y) = 12/24$。因此，UPGMA 将 $C$ 与簇 $U_Y = (S_3, S_4)$ 合并。这创建了一个新的簇 $U_{YC} = ((S_3, S_4), C)$。\n\n-   **迭代 4**：最后一步是将簇 $U_X$ 与簇 $U_{YC}$ 合并。\n\n最终的 UPGMA 指导树拓扑结构是 $((S_1, S_2), ((S_3, S_4), C))$。\n\n**步骤 2：渐进式比对分析**\n\n渐进式 MSA 过程将遵循指导树的分支顺序：\n1.  比对 $S_1$ 和 $S_2$ 以创建配置文件 $P_{12}$。这些序列高度相似，从而产生一个代表进化分支 $X$ 的高质量配置文件。\n2.  比对 $S_3$ 和 $S_4$ 以创建配置文件 $P_{34}$。这些序列也高度相似，从而产生一个代表进化分支 $Y$ 的高质量配置文件。\n3.  将配置文件 $P_{34}$ 与序列 $C$ 比对以创建配置文件 $P_{C34}$。错误就是在这里引入的。\n    -   $P_{34}$ 的前半部分富含G（$\\text{GGGG(G/T)G}$）。$C$ 的前半部分富含A（$\\text{AAAAAA}$）。\n    -   $P_{34}$ 和 $C$ 的后半部分都富含T（$\\text{TTTTTT}$）。\n    -   配置文件 $P_{C34}$ 变成了一个混合物：其前半部分是G和A的复合物，而后半部分纯粹是T。\n4.  将配置文件 $P_{12}$ 与配置文件 $P_{C34}$ 比对。这是最后的比对步骤。\n    -   $P_{12}$ 的前半部分富含A（$\\text{AAAA(A/T)A}$）。它将与 $P_{C34}$ 的混合A/G前半部分进行比对。这迫使来自进化分支 $Y$ 的富含G的序列与来自进化分支 $X$ 的富含A的序列进行比对。\n    -   $P_{12}$ 的后半部分富含C（$\\text{CCCCCC}$）。它将与 $P_{C34}$ 的富含T的后半部分进行比对。这迫使进化分支 $X$ 的富含C的片段与进化分支 $Y$ 和 $C$ 的富含T的片段进行比对。\n\n嵌合序列 $C$ 在非同源区域之间起到了人为桥梁的作用。由于其与进化分支 $Y$ 的平均距离稍小，它被错误地分组。这导致指导树从根本上错误地表示了进化历史，致使渐进式比对算法产生了一个生物学上不正确的 MSA，其中序列的两半都被错误地比对。\n\n### 选项评估\n\n-   **A. UPGMA 首先将 $(S_1,S_2)$ 和 $(S_3,S_4)$ 聚类，然后在与 $(S_1,S_2)$ 合并之前将 $C$ 附加到 $(S_3,S_4)$ 簇。因此，渐进式比对将 $(C,S_3,S_4)$ 的配置文件与 $(S_1,S_2)$ 的配置文件进行比对，使得 $(C,S_3,S_4)$ 富含 $T$ 的后半部分被迫与 $(S_1,S_2)$ 富含 $C$ 的后半部分对齐，而富含 $G$ 的前半部分则与富含 $A$ 的前半部分对齐，从而混合了不相关的片段，降低了两半部分的比对准确性。**\n    -   对 UPGMA 树拓扑结构的描述与上面推导的完全一致。\n    -   对渐进式比对后果的描述也是正确的。关键的最后一步是将 $(C,S_3,S_4)$ 配置文件与 $(S_1,S_2)$ 配置文件进行比对。后半部分被迫对齐（`T`对`C`）的陈述是准确的。前半部分被迫对齐也有描述；虽然 $(C,S_3,S_4)$ 的配置文件是G和A的混合，但“富含G的前半部分”可以理解为指进化分支 $Y$ 序列的贡献，这些序列是富含G的。这种措辞正确地抓住了错位的本质：迫使进化分支 $Y$ 的前半部分与进化分支 $X$ 的前半部分对齐。混合不相关片段和降低准确性的结论是合理的。\n    -   **结论：正确。**\n\n-   **B. UPGMA 将 $C$ 作为一个与所有其他序列在根部等距的外群，使得渐进式比对相对于没有 $C$ 的比对实际上没有变化。**\n    -   我们的计算表明 $d(C, U_Y)  d(C, U_X)$，所以 $C$ 与其他簇不是等距的。它被明确地与 $(S_3, S_4)$ 组放在一起，而不是作为一个普遍的外群。\n    -   **结论：不正确。**\n\n-   **C. UPGMA 首先将 $C$ 与 $S_1$ 聚类，然后将这对与 $S_2$ 合并形成进化分支 $X$，从而防止了干扰，因为 $C$ 与 $S_1$ 共享前半部分；最终的 MSA 在两半部分都保持最优。**\n    -   初始最小距离是 $d(S_1, S_2) = 1/12$ 和 $d(S_3, S_4) = 1/12$，这两个都小于 $d(C, S_1) = 6/12$。因此，UPGMA 不会首先将 $C$ 与 $S_1$ 聚类。UPGMA 在计算距离时考虑整个序列，而不仅仅是半个序列。\n    -   **结论：不正确。**\n\n-   **D. UPGMA 首先将 $S_1$ 与 $S_3$ 聚类，因为 $C$ 连接了它们并降低了它们的估计距离；尽管这在指导树中混合了进化分支，但渐进式比对器通过迭代优化来补偿以恢复正确的 MSA。**\n    -   距离 $d(S_1, S_3) = 1$ 是可能的最大距离；它们将是最后被聚类的序列。$C$ 的存在不会改变其他序列之间计算的成对距离。\n    -   问题明确禁止使用迭代优化。\n    -   **结论：不正确。**\n\n唯一正确描述了 UPGMA 过程及其后果的选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "引导树不仅能决定比对的顺序，其本身也包含了序列间进化关系的宝贵信息。这个练习  将向你展示如何利用引导树的枝长来为序列计算权重。通过降低来自近缘序列的冗余信息的权重，这种方法有助于生成一个更具代表性的一致性序列（consensus sequence），从而展示了引导树在生物信息学分析中的多功能性。",
            "id": "2418795",
            "problem": "在渐进式多序列比对中，指导树不仅可以用来确定两两合并的顺序，还可以在从多序列比对（MSA; Multiple Sequence Alignment）计算一致序列时为序列分配权重。请考虑以下带有分支长度的有根二叉指导树和指定的多序列比对。\n\n指导树拓扑结构和分支长度（所有长度均以任意距离单位表示）：\n- 根节点 $R$ 分裂为两个内部节点 $X$ 和 $Y$，分支 $R \\to X$ 的长度为 $0.3$，$R \\to Y$ 的长度为 $0.6$。\n- 节点 $X$ 直接连接到叶节点 $S_1$ 和 $S_2$，分支 $X \\to S_1$ 的长度为 $0.4$，$X \\to S_2$ 的长度为 $0.4$。\n- 节点 $Y$ 直接连接到叶节点 $S_3$（分支 $Y \\to S_3$ 长度为 $0.7$）和内部节点 $Y_2$（分支 $Y \\to Y_2$ 长度为 $0.1$）。\n- 节点 $Y_2$ 直接连接到叶节点 $S_4$ 和 $S_5$，分支 $Y_2 \\to S_4$ 的长度为 $0.05$，$Y_2 \\to S_5$ 的长度为 $0.05$。\n\n每个叶节点（序列）$S_i$ 的基于树的权重 $w_i$ 定义如下。对于每个长度为 $L(e)$ 的分支 $e$，其所对的后代叶节点数量为 $D(e)$，则 $e$ 的每个后代叶节点获得一个量 $L(e)/D(e)$。叶节点 $S_i$ 的权重是其从根到 $S_i$ 的唯一路径上所有分支的该量之和：\n$$\nw_i \\;=\\; \\sum_{e \\in \\text{path}(R \\to S_i)} \\frac{L(e)}{D(e)}.\n$$\n\n长度为 6 列的多序列比对如下：\n- $S_1$: A  -  C  G  C  A\n- $S_2$: G  T  C  G  T  A\n- $S_3$: A  -  C  G  T  G\n- $S_4$: G  T  C  T  C  A\n- $S_5$: G  T  C  T  C  A\n\n每列的一致序列定义：\n- 未加权一致序列：选择在 $\\{$A, C, G, T, -$\\}$ 中未加权计数最高的字符。\n- 加权一致序列：选择总权重最高的字符，其中序列 $S_i$ 中出现的每个字符为其总权重贡献 $w_i$。\n- 平局（在任一规则中）通过字典序 A  C  G  T  - 确定性地打破。\n\n计算加权一致序列与未加权一致序列不同的比对列数（总共 6 列）。答案以无单位的整数形式表示。",
            "solution": "在尝试求解之前，必须对问题陈述进行严格的验证过程，以确定其科学和逻辑上的完整性。\n\n首先，我将逐字提取给定信息。\n已知条件：\n1.  一个有根二叉指导树及其拓扑结构和分支长度：\n    - 根节点 $R$。\n    - 分支 $R \\to X$ 长度 $L(R \\to X) = 0.3$。\n    - 分支 $R \\to Y$ 长度 $L(R \\to Y) = 0.6$。\n    - 分支 $X \\to S_1$ 长度 $L(X \\to S_1) = 0.4$。\n    - 分支 $X \\to S_2$ 长度 $L(X \\to S_2) = 0.4$。\n    - 分支 $Y \\to S_3$ 长度 $L(Y \\to S_3) = 0.7$。\n    - 分支 $Y \\to Y_2$ 长度 $L(Y \\to Y_2) = 0.1$。\n    - 分支 $Y_2 \\to S_4$ 长度 $L(Y_2 \\to S_4) = 0.05$。\n    - 分支 $Y_2 \\to S_5$ 长度 $L(Y_2 \\to S_5) = 0.05$。\n2.  叶节点（序列）$S_i$ 的序列权重 $w_i$ 的定义：\n    $$w_i = \\sum_{e \\in \\text{path}(R \\to S_i)} \\frac{L(e)}{D(e)}$$\n    其中 $L(e)$ 是分支 $e$ 的长度，$D(e)$ 是分支 $e$ 所对的后代叶节点的数量。\n3.  一个包含 5 个序列（$S_1$ 到 $S_5$）和 6 列的多序列比对（MSA）：\n    - $S_1$: A  -  C  G  C  A\n    - $S_2$: G  T  C  G  T  A\n    - $S_3$: A  -  C  G  T  G\n    - $S_4$: G  T  C  T  C  A\n    - $S_5$: G  T  C  T  C  A\n4.  一致序列定义：\n    - 未加权一致序列：列中频率最高的字符。\n    - 加权一致序列：列中总权重最高的字符，其权重由出现该字符的序列贡献。\n5.  平局打破规则：在计数或总权重相等的情况下，根据字典序 A  C  G  T  - 选择胜出者。\n6.  目标是找出加权和未加权一致序列字符不同的列数。\n\n接下来，我将验证问题。\n该问题具有科学依据。使用指导树进行渐进式多序列比对并推导序列权重的概念是生物信息学中的一个标准和基本技术，常用于像 Clustal 这样的软件中。所描述的权重方案是一种有效的方法，旨在降低親缘关系近的序列的权重并提高親缘关系远的序列的权重，从而纠正输入集中的采样偏差。问题提法得当；它提供了所有必要的数据（树、比对、权重公式、平局打破规则）和一个清晰、客观的问题。没有矛盾、歧义或缺失的信息。该问题是一个完全指定且可解的计算练习。\n\n结论：该问题有效。我现在将继续进行求解。\n\n求解过程分为两步：首先，计算每个序列 $S_i$ 的权重 $w_i$；其次，确定每一列的未加权和加权一致序列，并计算差异的数量。\n\n步骤 1：计算序列权重\n为了计算权重，我们首先需要确定树中每个分支 $e$ 的后代叶节点数量 $D(e)$。\n-   叶节点为 $S_1, S_2, S_3, S_4, S_5$。叶节点总数为 5。\n-   分支 $R \\to X$：其后代是根为 $X$ 的子树的叶节点，即 $S_1$ 和 $S_2$。因此，$D(R \\to X) = 2$。\n-   分支 $R \\to Y$：其后代是根为 $Y$ 的子树的叶节点，即 $S_3, S_4, S_5$。因此，$D(R \\to Y) = 3$。\n-   分支 $X \\to S_1$：唯一的后代是 $S_1$。因此，$D(X \\to S_1) = 1$。\n-   分支 $X \\to S_2$：唯一的后代是 $S_2$。因此，$D(X \\to S_2) = 1$。\n-   分支 $Y \\to S_3$：唯一的后代是 $S_3$。因此，$D(Y \\to S_3) = 1$。\n-   分支 $Y \\to Y_2$：其后代是根为 $Y_2$ 的子树的叶节点，即 $S_4$ 和 $S_5$。因此，$D(Y \\to Y_2) = 2$。\n-   分支 $Y_2 \\to S_4$：唯一的后代是 $S_4$。因此，$D(Y_2 \\to S_4) = 1$。\n-   分支 $Y_2 \\to S_5$：唯一的后代是 $S_5$。因此，$D(Y_2 \\to S_5) = 1$。\n\n现在我们对每个序列应用权重公式。\n-   序列 $S_1$ 的权重 $w_1$：路径为 $R \\to X \\to S_1$。\n    $$w_1 = \\frac{L(R \\to X)}{D(R \\to X)} + \\frac{L(X \\to S_1)}{D(X \\to S_1)} = \\frac{0.3}{2} + \\frac{0.4}{1} = 0.15 + 0.4 = 0.55$$\n-   序列 $S_2$ 的权重 $w_2$：路径为 $R \\to X \\to S_2$。\n    $$w_2 = \\frac{L(R \\to X)}{D(R \\to X)} + \\frac{L(X \\to S_2)}{D(X \\to S_2)} = \\frac{0.3}{2} + \\frac{0.4}{1} = 0.15 + 0.4 = 0.55$$\n-   序列 $S_3$ 的权重 $w_3$：路径为 $R \\to Y \\to S_3$。\n    $$w_3 = \\frac{L(R \\to Y)}{D(R \\to Y)} + \\frac{L(Y \\to S_3)}{D(Y \\to S_3)} = \\frac{0.6}{3} + \\frac{0.7}{1} = 0.2 + 0.7 = 0.9$$\n-   序列 $S_4$ 的权重 $w_4$：路径为 $R \\to Y \\to Y_2 \\to S_4$。\n    $$w_4 = \\frac{L(R \\to Y)}{D(R \\to Y)} + \\frac{L(Y \\to Y_2)}{D(Y \\to Y_2)} + \\frac{L(Y_2 \\to S_4)}{D(Y_2 \\to S_4)} = \\frac{0.6}{3} + \\frac{0.1}{2} + \\frac{0.05}{1} = 0.2 + 0.05 + 0.05 = 0.3$$\n-   序列 $S_5$ 的权重 $w_5$：路径为 $R \\to Y \\to Y_2 \\to S_5$。\n    $$w_5 = \\frac{L(R \\to Y)}{D(R \\to Y)} + \\frac{L(Y \\to Y_2)}{D(Y \\to Y_2)} + \\frac{L(Y_2 \\to S_5)}{D(Y_2 \\to S_5)} = \\frac{0.6}{3} + \\frac{0.1}{2} + \\frac{0.05}{1} = 0.2 + 0.05 + 0.05 = 0.3$$\n\n计算出的权重为：$w_1=0.55$, $w_2=0.55$, $w_3=0.9$, $w_4=0.3$, $w_5=0.3$。\n\n步骤 2：逐列进行一致序列比较\n我现在将分析 MSA 的 6 列中的每一列。\n\n第 1 列：(A, G, A, G, G)\n-   未加权计数：A: $2$，G: $3$。最大计数为 G。未加权一致序列：G。\n-   加权得分：\n    -   得分(A) = $w_1 + w_3 = 0.55 + 0.9 = 1.45$。\n    -   得分(G) = $w_2 + w_4 + w_5 = 0.55 + 0.3 + 0.3 = 1.15$。\n-   最高得分为 A。加权一致序列：A。\n-   一致序列字符不同 (G vs. A)。\n\n第 2 列：(-, T, -, T, T)\n-   未加权计数：T: $3$，-: $2$。最大计数为 T。未加权一致序列：T。\n-   加权得分：\n    -   得分(T) = $w_2 + w_4 + w_5 = 0.55 + 0.3 + 0.3 = 1.15$。\n    -   得分(-) = $w_1 + w_3 = 0.55 + 0.9 = 1.45$。\n-   最高得分为 -。加权一致序列：-。\n-   一致序列字符不同 (T vs. -)。\n\n第 3 列：(C, C, C, C, C)\n-   未加权计数：C: $5$。未加权一致序列：C。\n-   加权得分：所有序列都有 C，所以 C 的得分是所有权重的总和，这是最大的。加权一致序列：C。\n-   一致序列字符相同。\n\n第 4 列：(G, G, G, T, T)\n-   未加权计数：G: $3$，T: $2$。最大计数为 G。未加权一致序列：G。\n-   加权得分：\n    -   得分(G) = $w_1 + w_2 + w_3 = 0.55 + 0.55 + 0.9 = 2.0$。\n    -   得分(T) = $w_4 + w_5 = 0.3 + 0.3 = 0.6$。\n-   最高得分为 G。加权一致序列：G。\n-   一致序列字符相同。\n\n第 5 列：(C, T, T, C, C)\n-   未加权计数：C: $3$，T: $2$。最大计数为 C。未加权一致序列：C。\n-   加权得分：\n    -   得分(C) = $w_1 + w_4 + w_5 = 0.55 + 0.3 + 0.3 = 1.15$。\n    -   得分(T) = $w_2 + w_3 = 0.55 + 0.9 = 1.45$。\n-   最高得分为 T。加权一致序列：T。\n-   一致序列字符不同 (C vs. T)。\n\n第 6 列：(A, A, G, A, A)\n-   未加权计数：A: $4$，G: $1$。最大计数为 A。未加权一致序列：A。\n-   加权得分：\n    -   得分(A) = $w_1 + w_2 + w_4 + w_5 = 0.55 + 0.55 + 0.3 + 0.3 = 1.7$。\n    -   得分(G) = $w_3 = 0.9$。\n-   最高得分为 A。加权一致序列：A。\n-   一致序列字符相同。\n\n最后，我将统计一致序列不同的列数。\n一致序列字符在第 $1$、$2$ 和 $5$ 列不同。\n一致序列不同的总列数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        }
    ]
}