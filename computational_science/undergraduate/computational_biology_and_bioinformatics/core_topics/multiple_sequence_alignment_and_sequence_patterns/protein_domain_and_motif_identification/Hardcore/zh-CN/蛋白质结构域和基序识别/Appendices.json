{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳补充是动手实践。本节的第一个练习将从生物信息学中最基础也是最强大的工具之一——正则表达式开始。我们将通过一个具体的例子，学习如何将描述蛋白质结构域的生物学模式（包含保守残基和可变长度的间隔区）转化为精确的计算搜索指令，这对于从海量序列数据中快速筛选目标蛋白质至关重要。",
            "id": "2420143",
            "problem": "您必须编写一个完整、可运行的程序，该程序针对一组固定的人类候选蛋白质一级结构（基于标准氨基酸字母表），识别出哪些序列同时包含至少一次以下两种定义结构域的基序模式：一种脱氧核糖核酸(DNA)结合的$C_2H_2$锌指基序和一种E3泛素连接酶“真正有趣新基因”(RING)指基序。基序的存在纯粹定义为存在一个满足下述位置约束的连续子序列。字母表为 $\\Sigma = \\{ \\text{A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y, X} \\}$，其中$\\text{X}$表示一个未知残基，只能作为通用符号出现，并被视为在通配符位置匹配任何单个残基；它不满足明确要求特定残基的位置。以下是正式规范。\n\n模式的数学定义：给定一个序列 $S \\in \\Sigma^{*}$ 和一个描述为符号与有界通配符串联的模式，如果存在一个索引 $i$ 和一个长度 $L$，使得子串 $S[i\\,..\\,i+L-1]$ 与一个由字面残基和形如 $\\text{any}^{k}$（其中 $k$ 是一个非负整数，$\\text{any}$ 表示 $\\Sigma$ 中的任何单个符号）的通配符块串联而成的字符串完全相等，则存在匹配。字面位置必须匹配确切的残基符号，而通配符位置可以匹配 $\\Sigma$ 中的任何残基符号。\n\n基序定义：\n- DNA结合$C_2H_2$锌指基序（此处简称为C2H2）：一个字面值$\\text{C}$，后跟 $k_1$ 个任意残基，其中 $k_1 \\in \\{2,3,4\\}$，然后是一个字面值$\\text{C}$，接着是恰好 $12$ 个任意残基，然后是一个字面值$\\text{H}$，再后跟 $k_2$ 个任意残基，其中 $k_2 \\in \\{3,4,5\\}$，最后是一个字面值$\\text{H}$。形式化表示为 $\\text{C} \\cdot \\text{any}^{k_1} \\cdot \\text{C} \\cdot \\text{any}^{12} \\cdot \\text{H} \\cdot \\text{any}^{k_2} \\cdot \\text{H}$。\n- E3泛素连接酶RING指基序（此处简称为RING）：一个字面值$\\text{C}$，后跟恰好 $2$ 个任意残基，然后是一个字面值$\\text{C}$，接着是 $n_1$ 个任意残基，其中 $n_1 \\in [9,39]$，然后是一个字面值$\\text{C}$，再后跟 $n_2$ 个任意残基，其中 $n_2 \\in [1,3]$，然后是一个字面值$\\text{H}$，接着是 $n_3$ 个任意残基，其中 $n_3 \\in [2,3]$，然后是一个字面值$\\text{C}$，再后跟恰好 $2$ 个任意残基，然后是一个字面值$\\text{C}$，接着是 $n_4$ 个任意残基，其中 $n_4 \\in [4,48]$，然后是一个字面值$\\text{C}$，再后跟恰好 $2$ 个任意残基，最后是一个字面值$\\text{C}$。形式化表示为 $\\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_1} \\cdot \\text{C} \\cdot \\text{any}^{n_2} \\cdot \\text{H} \\cdot \\text{any}^{n_3} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_4} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C}$。\n\n您将获得一个固定的候选蛋白质序列列表 $S_0, S_1, \\dots, S_8$，每个序列都与一个从零开始的索引相关联。请精确构建以下可重用的构建块：\n- 定义 $Z_{\\min} =$ \"CAACAAAAAAAAAAAAHAAAH\"，它用 $k_1 = 2$ 和 $k_2 = 3$ 实例化了C2H2基序，即 $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{3} \\cdot \\text{H}$。\n- 定义 $Z_{\\max} =$ \"CAAAACAAAAAAAAAAAAHAAAAAH\"，它用 $k_1 = 4$ 和 $k_2 = 5$ 实例化了C2H2基序，即 $\\text{C} \\cdot \\text{A}^{4} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{5} \\cdot \\text{H}$。\n- 定义 $Z_{\\mathrm{exact}} =$ \"CAAACAAAAAAAAAAAAHAAAAH\"，它用 $k_1 = 3$ 和 $k_2 = 4$ 实例化了C2H2基序，即 $\\text{C} \\cdot \\text{A}^{3} \\cdot \\text{C} \\cdot \\text{A}^{12} \\cdot \\text{H} \\cdot \\text{A}^{4} \\cdot \\text{H}$。\n- 定义 $R_{\\min} =$ \"CAACAAAAAAAAACAHAACAACAAAACAAC\"，它用 $n_1 = 9$, $n_2 = 1$, $n_3 = 2$ 和 $n_4 = 4$ 实例化了RING基序，即 $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{9} \\cdot \\text{C} \\cdot \\text{A}^{1} \\cdot \\text{H} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{4} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C}$。\n- 定义 $R_{\\max}$ 为由 $\\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{39} \\cdot \\text{C} \\cdot \\text{A}^{3} \\cdot \\text{H} \\cdot \\text{A}^{3} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C} \\cdot \\text{A}^{48} \\cdot \\text{C} \\cdot \\text{A}^{2} \\cdot \\text{C}$ 构建的字符串（长度为 $107$）。\n- 定义 $Z_{\\mathrm{X}}$ 为字符串 $\\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{12} \\cdot \\text{H} \\cdot \\text{X}^{3} \\cdot \\text{H}$。\n- 定义 $R_{\\mathrm{X}}$ 为字符串 $\\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{9} \\cdot \\text{C} \\cdot \\text{X}^{1} \\cdot \\text{H} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C} \\cdot \\text{X}^{4} \\cdot \\text{C} \\cdot \\text{X}^{2} \\cdot \\text{C}$。\n\n现在按如下方式定义索引 $i \\in \\{0,1,2,3,4,5,6,7,8\\}$ 的序列 $S_i$：\n- $S_0 =$ 重复 $10$ 次 \"M\"，后跟 $Z_{\\min}$，再后跟重复 $5$ 次 \"G\"，接着是 $R_{\\min}$，最后是重复 $3$ 次 \"T\"。\n- $S_1 =$ 重复 $5$ 次 \"M\"，后跟 $Z_{\\max}$，再后跟重复 $5$ 次 \"Q\"。\n- $S_2 =$ 重复 $5$ 次 \"V\"，后跟 $R_{\\min}$，再后跟重复 $5$ 次 \"P\"。\n- $S_3 =$ 字面字符串 \"MKTLLILVVAAAAGGG\"。\n- $S_4 =$ 重复 $4$ 次 \"S\"，后跟 $Z_{\\max}$，再后跟重复 $5$ 次 \"N\"，接着是 $R_{\\max}$，最后是重复 $4$ 次 \"E\"。\n- $S_5 =$ 将 $Z_{\\min}$ 的最后一个字面值 $\\text{H}$ 替换为 $\\text{K}$ 得到的字符串（因此最后一个位置不再是 $\\text{H}$），后跟重复 $3$ 次 \"G\"，再后跟 $R_{\\min}$。\n- $S_6 =$ $Z_{\\mathrm{X}}$ 后跟 \"GG\"，再后跟 $R_{\\mathrm{X}}$。\n- $S_7 =$ $R_{\\min}$ 紧接着 $Z_{\\min}$。\n- $S_8 =$ 重复 $3$ 次 \"D\"，后跟 $Z_{\\mathrm{exact}}$，再后跟重复 $3$ 次 \"P\"，接着是 $R_{\\min}$，最后是重复 $3$ 次 \"K\"。\n\n模式参数化测试套件：\n- 测试用例 1：C2H2基序，其中 $k_1 \\in \\{2,3,4\\}$，$\\text{C}$ 和 $\\text{H}$ 之间恰好有 $12$ 个任意残基，且 $k_2 \\in \\{3,4,5\\}$；RING基序，其中 $n_1 \\in [9,39]$，$n_2 \\in [1,3]$，$n_3 \\in [2,3]$，且 $n_4 \\in [4,48]$。\n- 测试用例 2：C2H2基序与测试用例 1 相同；RING基序收紧为 $n_1 \\in [9,12]$ 和 $n_4 \\in [4,12]$，而 $n_2 \\in [1,3]$ 和 $n_3 \\in [2,3]$ 保持不变。\n- 测试用例 3：C2H2基序收紧为 $k_1 = 3$ 和 $k_2 = 4$，第二个 $\\text{C}$ 和第一个 $\\text{H}$ 之间恰好有 $12$ 个任意残基；RING基序与测试用例 1 相同。\n\n对于每个测试用例 $t \\in \\{1,2,3\\}$，确定索引集合 $I_t \\subseteq \\{0,1,\\dots,8\\}$，使得 $S_i$ 至少包含一个与测试用例 $t$ 指定的C2H2基序相匹配的子串，并且至少包含一个与测试用例 $t$ 指定的RING基序相匹配的子串。您的程序必须输出一行，包含以整数列表的列表形式聚合的三个结果，不含空格，顺序为 $[I_1, I_2, I_3]$，其中每个 $I_t$ 表示为一个由从零开始的索引组成的严格递增列表。例如，一个有效的输出格式可能看起来像 \"[[a_1,a_2],[b_1],[c_1,c_2,c_3]]\"，其中 $a_j$、$b_j$ 和 $c_j$ 是整数。不应打印任何其他文本。",
            "solution": "所提出的问题是生物信息学中的一个标准练习，特别是在序列分析和基序识别领域。它在计算上是适定的，在科学上是合理的。任务是从一组给定的蛋白质一级结构中，根据变化的参数约束，识别出那些包含两种不同基序实例的结构：一个C$_2$H$_2$锌指和一个RING指。\n\n解决这个问题的基本原理是字符串中的模式匹配。鉴于基序是由特定氨基酸残基序列与可变长度的任意残基片段交错定义的，最直接且计算效率最高的方法是使用正则表达式。正则表达式是一种用于指定搜索模式的形式语言，它直接适用于所提供的定义。\n\n该方法分三个阶段实施。\n\n首先，以编程方式构建输入。通过连接所提供的字面字符串和预定义的构建块（$Z_{\\min}$、$Z_{\\max}$ 等），精确地合成了从 $S_0$ 到 $S_8$ 的九个蛋白质序列。此步骤是简单的字符串操作。\n\n其次，制定参数化的模式匹配函数。需要两个核心函数：一个用于C$_2$H$_2$基序，另一个用于RING基序。\nC$_2$H$_2$基序定义为 $\\text{C} \\cdot \\text{any}^{k_1} \\cdot \\text{C} \\cdot \\text{any}^{12} \\cdot \\text{H} \\cdot \\text{any}^{k_2} \\cdot \\text{H}$。这可以转化为形式为 `C.{k1_min,k1_max}C.{12}H.{k2_min,k2_max}H` 的正则表达式模式，其中 $\\{k_1\\_{\\min}, k_1\\_{\\max}\\}$ 和 $\\{k_2\\_{\\min}, k_2\\_{\\max}\\}$ 定义了通配符片段长度的包含性整数范围。符号 `.` 是一个匹配任何单个字符的通配符，它正确地模拟了字母表 $\\Sigma$ 上的 `any` 符号，包括特殊残基 $\\text{X}$。模式中的字面字符 `C` 和 `H` 只会匹配它们自身，正确地强制了指定的保守残基。\n\n同样，RING指基序，形式化为 $\\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_1} \\cdot \\text{C} \\cdot \\text{any}^{n_2} \\cdot \\text{H} \\cdot \\text{any}^{n_3} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C} \\cdot \\text{any}^{n_4} \\cdot \\text{C} \\cdot \\text{any}^{2} \\cdot \\text{C}$，被翻译成正则表达式 `C..C.{n1_min,n1_max}C.{n2_min,n2_max}H.{n3_min,n3_max}C..C.{n4_min,n4_max}C..C`。参数 $n_1, n_2, n_3, n_4$ 作为每个测试用例的范围提供。\n\n第三，系统地评估每个序列与测试用例。一个主程序遍历三个指定的测试用例。对于每个测试用例，它使用相应的参数范围 $k_1, k_2, n_1, n_2, n_3, n_4$ 配置正则表达式模式。然后，它遍历每个序列 $S_i$（$i \\in \\{0, \\ldots, 8\\}$）。对于一个给定的测试用例，一个序列要被视为匹配，必须同时成功搜索到C$_2$H$_2$模式*和*RING模式。对于每个测试用例，收集所有满足此双重条件的序列的索引 $i$。\n\n最终输出是这些索引集的聚合，以所要求的列表的列表格式呈现。整个过程是正则表达式匹配和逻辑合取的确定性应用，产生唯一且正确的解决方案。",
            "answer": "```python\nimport re\nimport numpy as np  # numpy is specified as available but not used.\n# scipy is specified as available but not used.\n\ndef solve():\n    \"\"\"\n    Solves the protein motif identification problem by:\n    1. Constructing the target protein sequences from given building blocks.\n    2. Defining the parameter sets for three test cases.\n    3. Implementing helper functions to generate regular expressions for\n       C2H2 and RING motifs based on variable length parameters.\n    4. Iterating through each test case and each sequence, checking for the\n       presence of both required motifs.\n    5. Collecting and printing the indices of matching sequences in the\n       specified format.\n    \"\"\"\n\n    # Define reusable building blocks for sequences\n    Z_min = \"CAACAAAAAAAAAAAAHAAAH\"\n    Z_max = \"CAAAACAAAAAAAAAAAAHAAAAAH\"\n    Z_exact = \"CAAACAAAAAAAAAAAAHAAAAH\"\n    R_min = \"CAACAAAAAAAAACAHAACAACAAAACAAC\"\n    R_max = (\n        \"C\" + \"A\" * 2 + \"C\" + \"A\" * 39 + \"C\" + \"A\" * 3 + \"H\" + \"A\" * 3 +\n        \"C\" + \"A\" * 2 + \"C\" + \"A\" * 48 + \"C\" + \"A\" * 2 + \"C\"\n    )\n    Z_X = \"C\" + \"X\" * 2 + \"C\" + \"X\" * 12 + \"H\" + \"X\" * 3 + \"H\"\n    R_X = (\n        \"C\" + \"X\" * 2 + \"C\" + \"X\" * 9 + \"C\" + \"X\" * 1 + \"H\" + \"X\" * 2 +\n        \"C\" + \"X\" * 2 + \"C\" + \"X\" * 4 + \"C\" + \"X\" * 2 + \"C\"\n    )\n\n    # Define the list of candidate protein sequences S_0 to S_8\n    sequences = [\n        \"M\" * 10 + Z_min + \"G\" * 5 + R_min + \"T\" * 3,  # S_0\n        \"M\" * 5 + Z_max + \"Q\" * 5,                      # S_1\n        \"V\" * 5 + R_min + \"P\" * 5,                      # S_2\n        \"MKTLLILVVAAAAGGG\",                             # S_3\n        \"S\" * 4 + Z_max + \"N\" * 5 + R_max + \"E\" * 4,    # S_4\n        Z_min[:-1] + \"K\" + \"G\" * 3 + R_min,             # S_5\n        Z_X + \"GG\" + R_X,                               # S_6\n        R_min + Z_min,                                  # S_7\n        \"D\" * 3 + Z_exact + \"P\" * 3 + R_min + \"K\" * 3,  # S_8\n    ]\n\n    # Define the parameters for the three test cases\n    test_cases = [\n        {\n            \"c2h2\": {\"k1_range\": (2, 4), \"k2_range\": (3, 5)},\n            \"ring\": {\"n1_range\": (9, 39), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 48)},\n        },\n        {\n            \"c2h2\": {\"k1_range\": (2, 4), \"k2_range\": (3, 5)},\n            \"ring\": {\"n1_range\": (9, 12), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 12)},\n        },\n        {\n            \"c2h2\": {\"k1_range\": (3, 3), \"k2_range\": (4, 4)},\n            \"ring\": {\"n1_range\": (9, 39), \"n2_range\": (1, 3), \"n3_range\": (2, 3), \"n4_range\": (4, 48)},\n        },\n    ]\n\n    # Helper function to generate a regular expression for the C2H2 motif\n    def make_c2h2_regex(k1_range, k2_range):\n        pattern = f\"C.{{{k1_range[0]},{k1_range[1]}}}C.{{12}}H.{{{k2_range[0]},{k2_range[1]}}}H\"\n        return re.compile(pattern)\n\n    # Helper function to generate a regular expression for the RING motif\n    def make_ring_regex(n1_range, n2_range, n3_range, n4_range):\n        pattern = (\n            f\"C..C.{{{n1_range[0]},{n1_range[1]}}}C.{{{n2_range[0]},{n2_range[1]}}}\"\n            f\"H.{{{n3_range[0]},{n3_range[1]}}}C..C.{{{n4_range[0]},{n4_range[1]}}}C..C\"\n        )\n        return re.compile(pattern)\n\n    all_results = []\n    # Process each test case\n    for case_params in test_cases:\n        c2h2_regex = make_c2h2_regex(**case_params[\"c2h2\"])\n        ring_regex = make_ring_regex(**case_params[\"ring\"])\n        \n        current_case_indices = []\n        # Check each sequence against the current test case's motifs\n        for i, seq in enumerate(sequences):\n            has_c2h2 = c2h2_regex.search(seq) is not None\n            has_ring = ring_regex.search(seq) is not None\n            \n            # A sequence passes if it contains at least one of each motif\n            if has_c2h2 and has_ring:\n                current_case_indices.append(i)\n        \n        all_results.append(current_case_indices)\n\n    # Format the final output string as specified: [[a,b],[c,d,e],[f]]\n    # This construction avoids any spaces in the output.\n    result_str = \"[\" + \",\".join(f\"[{','.join(map(str, r))}]\" for r in all_results) + \"]\"\n    \n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在序列中找到一个基序（motif）的匹配，并不总是意味着一个功能性结构域的存在。进化过程中，一些结构域可能会因关键位点的突变而失去活性，形成“伪结构域”。这个练习将引导你处理一个更复杂的生物学问题：如何通过计算方法区分具有潜在活性的“规范结构域”和可能已失活的“伪结构域”。 通过结合多个基序的空间排列约束和对关键功能位点的检查，你将学习到一种更精细的、更贴近生物学现实的分析方法。",
            "id": "2420098",
            "problem": "您将获得一个计算任务，该任务基于以下观察：许多酶促蛋白结构域拥有高度保守的活性位点基序。特别是，蛋白激酶通常表现出三个保守的短基序，这些基序沿着一级序列按顺序出现，并具有特征性的间距：一个位于$\\beta_3$链附近的含赖氨酸基序，一个带有天冬氨酸的催化环基序，以及一个以天冬氨酸起始的激活环基序。您将检测遵守这些保守残基的规范结构域，并识别保留了基序上下文和间距但在一个或多个关键残基上有所偏离的伪结构域。\n\n形式化\n\n- 令 $\\Sigma$ 为 $20$ 种标准氨基酸单字母代码的集合。蛋白质序列是一个有限字符串 $S \\in \\Sigma^\\ast$，从位置 $0$ 开始索引。\n- 定义三个基序字符串：\n  - $M_1 = \\text{\"VAIK\"}$，\n  - $M_2 = \\text{\"HRD\"}$，\n  - $M_3 = \\text{\"DFG\"}$。\n- 定义基序长度 $\\ell_1 = 4$，$\\ell_2 = 3$，$\\ell_3 = 3$。\n- 定义一个有效三联体出现必须同时满足的间隙长度约束：\n  - $g_{12}^{\\min} = 50$, $g_{12}^{\\max} = 70$,\n  - $g_{23}^{\\min} = 20$, $g_{23}^{\\max} = 30$。\n- 对于在起始索引 $p_i$ (其中 $0 \\le p_i \\le |S| - \\ell_i$) 处出现的任何 $M_i$，间隙定义为\n  $$g_{12} = p_2 - (p_1 + \\ell_1), \\quad g_{23} = p_3 - (p_2 + \\ell_2)$$\n  一个有效的有序三联体满足 $p_1  p_2  p_3$ 以及\n  $$g_{12}^{\\min} \\le g_{12} \\le g_{12}^{\\max}, \\quad g_{23}^{\\min} \\le g_{23} \\le g_{23}^{\\max}$$\n- 关键残基定义在每个基序内的特定位置：\n  - 在 $M_1$ 中，位置 4 的残基（赖氨酸, $\\text{\"K\"}$）是关键的。\n  - 在 $M_2$ 中，位置 3 的残基（天冬氨酸, $\\text{\"D\"}$）是关键的。\n  - 在 $M_3$ 中，位置 1 的残基（天冬氨酸, $\\text{\"D\"}$）是关键的。\n- 通过仅将关键位置替换为可匹配任何残基的通配符，同时保持所有非关键位置不变，来定义宽松基序 $M_1^\\ast, M_2^\\ast, M_3^\\ast$：\n  - $M_1^\\ast = \\text{\"VAI?\"}$，\n  - $M_2^\\ast = \\text{\"HR?\"}$，\n  - $M_3^\\ast = \\text{\"?FG\"}$。\n- 如果在 $S$ 中存在至少一个对 $M_1, M_2, M_3$ 的精确匹配的有效有序三联体（使用上述定义的间隙），则称 $S$ 中存在一个规范结构域。\n- 如果在 $S$ 中存在至少一个对宽松基序 $M_1^\\ast, M_2^\\ast, M_3^\\ast$ 的匹配的有效有序三联体，该三联体满足相同的间隙约束，并且其中至少一个关键残基与其规范身份不同（即，在 $M_1, M_2, M_3$ 中相应关键位置的残基不全等于 $\\text{\"K\"}, \\text{\"D\"}, \\text{\"D\"}$），则称 $S$ 中存在一个伪结构域。规范结构域不得被计为伪结构域。\n\n测试套件的表示法\n\n- 对于任何字符 $X \\in \\Sigma$ 和整数 $n \\ge 0$，令 $X^n$ 表示由 $n$ 个重复的字符 $X$ 组成的字符串。\n- 字符串的连接通过简单并列表示。\n\n测试套件\n\n您必须评估以下五个序列。每个序列都使用重复表示法和简单连接来指定。所有重复都使用字符 $\\text{\"A\"}$。\n\n- $S_1 = \\text{\"A\"}^{10}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{50}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{5}.$\n- $S_2 = \\text{\"A\"}^{8}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{60}\\ \\text{\"HRN\"}\\ \\text{\"A\"}^{25}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{4}.$\n- $S_3 = \\text{\"A\"}^{12}\\ \\text{\"VAIR\"}\\ \\text{\"A\"}^{55}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{7}.$\n- $S_4 = \\text{\"A\"}^{9}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{10}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{30}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{6}.$\n- $S_5 = \\text{\"A\"}^{6}\\ \\text{\"VAIK\"}\\ \\text{\"A\"}^{52}\\ \\text{\"HRD\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{80}\\ \\text{\"VAIR\"}\\ \\text{\"A\"}^{60}\\ \\text{\"HRN\"}\\ \\text{\"A\"}^{20}\\ \\text{\"DFG\"}\\ \\text{\"A\"}^{3}.$\n\n答案规范\n\n- 对于每个序列 $S_k$，您必须确定两个布尔值：\n  - 根据上述定义，$S_k$ 中是否存在规范结构域；\n  - 根据上述定义，$S_k$ 中是否存在伪结构域。\n- 您的程序必须按 $S_1, S_2, S_3, S_4, S_5$ 的确切顺序处理这五个序列，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个序列，将结果对输出为一个双元素列表，形式为 $\\text{\"[True,False]\"}$、$\\text{\"[False,True]\"}$ 等，使用布尔字面量 $\\text{True}$ 和 $\\text{False}$。\n- 具体来说，最终输出必须是一个表示包含五对列表的单行字符串：$\\text{\"[[b_{11},b_{12}],[b_{21},b_{22}],[b_{31},b_{32}],[b_{41},b_{42}],[b_{51},b_{52}]]\"}$，其中每个 $b_{ij}$ 是如上定义的布尔值。\n\n您的程序必须是一个完整的、可运行的程序，无需任何用户输入或外部文件即可执行这些计算。",
            "solution": "该问题已经过严格验证，被认为是有效的。它在科学上基于计算生物学的原理，特别是通过保守序列基序来识别蛋白质结构域。该问题定义明确，所有参数、约束和目标都具有足够的数学和算法精度。没有逻辑矛盾、事实不健全或关键的模糊性。因此，可以推导出解决方案。\n\n任务是对于给定的蛋白质序列 $S$，确定“规范”和“伪”激酶结构域的存在。这些是通过特定基序的三联体的存在来定义的，这些基序由受约束的间隙长度分隔。\n\n基本方法是在序列中组合搜索有效的基序三联体。该算法分三个阶段进行：\n\n1.  **基序实例识别**：首先，我们必须识别三个基序的所有潜在位置。问题定义了三个规范基序，$M_1 = \\text{\"VAIK\"}$，$M_2 = \\text{\"HRD\"}$ 和 $M_3 = \\text{\"DFG\"}$。它还定义了宽松版本，$M_1^\\ast = \\text{\"VAI?\"}$，$M_2^\\ast = \\text{\"HR?\"}$ 和 $M_3^\\ast = \\text{\"?FG\"}$，其中通配符 '?' 可以匹配来自字母表 $\\Sigma$ 的任何氨基酸。我们将对输入序列 $S$ 进行三次独立的线性扫描，以找到 $M_1^\\ast$、$M_2^\\ast$ 和 $M_3^\\ast$ 的所有出现。对于每次匹配，我们记录其起始位置 $p_i$ 和在关键位置找到的特定氨基酸。设 $\\mathcal{P}_1$、$\\mathcal{P}_2$ 和 $\\mathcal{P}_3$ 为这些发现的集合，其中每个元素都是一个由从零开始的起始索引和关键残基组成的对 $(p_i, c_i)$。\n\n2.  **三联体枚举与验证**：然后我们通过从每个集合中取一个元素来枚举所有可能的基序实例三联体：$(p_1, c_1) \\in \\mathcal{P}_1$，$(p_2, c_2) \\in \\mathcal{P}_2$ 和 $(p_3, c_3) \\in \\mathcal{P}_3$。对于每个候选三联体，我们必须根据两组约束对其进行验证：\n    *   **顺序约束**：基序必须沿序列以正确的顺序出现，即 $p_1  p_2  p_3$。\n    *   **间隙长度约束**：分隔基序的残基数量必须在指定范围内。间隙定义为 $g_{12} = p_2 - (p_1 + \\ell_1)$ 和 $g_{23} = p_3 - (p_2 + \\ell_2)$，其中基序长度为 $\\ell_1 = 4$，$\\ell_2 = 3$ 和 $\\ell_3 = 3$。约束条件是 $g_{12}^{\\min} \\le g_{12} \\le g_{12}^{\\max}$ 和 $g_{23}^{\\min} \\le g_{23} \\le g_{23}^{\\max}$，给定值为 $g_{12}^{\\min} = 50$，$g_{12}^{\\max} = 70$，$g_{23}^{\\min} = 20$ 和 $g_{23}^{\\max} = 30$。\n    任何未能满足所有这些条件的三联体都将被丢弃。\n\n3.  **结构域分类**：满足所有顺序和间隙约束的基序实例三联体被视为“有效三联体”。然后根据其关键残基 $(c_1, c_2, c_3)$ 对每个有效三联体进行分类。规范的关键残基是 $M_1$ 的 'K'、$M_2$ 的 'D' 和 $M_3$ 的 'D'。\n    *   当且仅当 $c_1 = \\text{'K'}$，$c_2 = \\text{'D'}$ 且 $c_3 = \\text{'D'}$ 时，有效三联体是**规范的**。\n    *   如果有效三联体不是规范的，则它是**伪的**。这意味着其至少一个关键残基偏离了规范身份。\n\n最后，我们确定整个序列 $S$ 的属性。如果找到了至少一个规范三联体，则存在规范结构域。如果找到了至少一个伪三联体，则存在伪结构域。一个序列可能包含两者、其中之一或两者都不包含。两个布尔标志 `has_canonical` 和 `has_pseudo` 初始化为 false，在找到相应三联体类型的第一个实例时设置为 true。序列 $S$ 的最终输出是这两个布尔值的对。对五个提供的测试序列中的每一个重复整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein domain identification problem for a suite of test sequences.\n    \"\"\"\n\n    def generate_sequence(parts):\n        \"\"\"\n        Generates a full protein sequence string from a compact specification.\n        Example part: ('A', 10) for \"AAAAAAAAAA\", or ('VAIK', 1) for \"VAIK\".\n        \"\"\"\n        return \"\".join([char * count for char, count in parts])\n\n    def find_relaxed_matches(sequence, prefix, suffix, length, critical_offset_from_start):\n        \"\"\"\n        Finds all occurrences of a relaxed motif in a sequence.\n        A relaxed motif is defined by a prefix, a suffix, and a total length.\n        The single character between the prefix and suffix is the critical residue.\n        \n        Args:\n            sequence (str): The protein sequence to search.\n            prefix (str): The fixed prefix of the motif.\n            suffix (str): The fixed suffix of the motif.\n            length (int): The total length of the motif.\n            critical_offset_from_start (int): The 0-based index of the critical residue.\n            \n        Returns:\n            list: A list of tuples, where each tuple is (start_index, critical_residue).\n        \"\"\"\n        matches = []\n        len_prefix = len(prefix)\n        len_suffix = len(suffix)\n        \n        if len_prefix + len_suffix != length - 1:\n            raise ValueError(\"Prefix and suffix lengths do not match total length.\")\n\n        for i in range(len(sequence) - length + 1):\n            if sequence[i : i + len_prefix] == prefix and \\\n               sequence[i + length - len_suffix : i + length] == suffix:\n                critical_char = sequence[i + critical_offset_from_start]\n                matches.append((i, critical_char))\n        return matches\n\n    # Test cases defined using the compact notation from the problem statement.\n    test_specs = [\n        # S1\n        [('A', 10), ('VAIK', 1), ('A', 50), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 5)],\n        # S2\n        [('A', 8), ('VAIK', 1), ('A', 60), ('HRN', 1), ('A', 25), ('DFG', 1), ('A', 4)],\n        # S3\n        [('A', 12), ('VAIR', 1), ('A', 55), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 7)],\n        # S4\n        [('A', 9), ('VAIK', 1), ('A', 10), ('HRD', 1), ('A', 30), ('DFG', 1), ('A', 6)],\n        # S5\n        [('A', 6), ('VAIK', 1), ('A', 52), ('HRD', 1), ('A', 20), ('DFG', 1), ('A', 80), \n         ('VAIR', 1), ('A', 60), ('HRN', 1), ('A', 20), ('DFG', 1), ('A', 3)]\n    ]\n\n    sequences = [generate_sequence(spec) for spec in test_specs]\n    \n    # Problem constants\n    l1, l2 = 4, 3\n    g12_min, g12_max = 50, 70\n    g23_min, g23_max = 20, 30\n    crit1_char, crit2_char, crit3_char = 'K', 'D', 'D'\n\n    all_results = []\n\n    for S in sequences:\n        # Find all occurrences of the three relaxed motifs\n        # M1* = \"VAI?\", critical residue at 0-based index 3\n        matches1 = find_relaxed_matches(S, prefix=\"VAI\", suffix=\"\", length=4, critical_offset_from_start=3)\n        # M2* = \"HR?\", critical residue at 0-based index 2\n        matches2 = find_relaxed_matches(S, prefix=\"HR\", suffix=\"\", length=3, critical_offset_from_start=2)\n        # M3* = \"?FG\", critical residue at 0-based index 0\n        matches3 = find_relaxed_matches(S, prefix=\"\", suffix=\"FG\", length=3, critical_offset_from_start=0)\n\n        has_canonical = False\n        has_pseudo = False\n\n        # Iterate through all combinations of found motifs to find valid triplets\n        for p1, c1 in matches1:\n            for p2, c2 in matches2:\n                # Enforce order constraint p1  p2\n                if p1 >= p2:\n                    continue\n                \n                # Check gap constraint g12\n                g12 = p2 - (p1 + l1)\n                if not (g12_min = g12 = g12_max):\n                    continue\n\n                for p3, c3 in matches3:\n                    # Enforce order constraint p2  p3\n                    if p2 >= p3:\n                        continue\n                    \n                    # Check gap constraint g23\n                    g23 = p3 - (p2 + l2)\n                    if not (g23_min = g23 = g23_max):\n                        continue\n\n                    # At this point, a valid triplet (p1, p2, p3) has been found.\n                    # Now, classify it based on critical residues.\n                    is_canonical_triplet = (c1 == crit1_char and c2 == crit2_char and c3 == crit3_char)\n\n                    if is_canonical_triplet:\n                        has_canonical = True\n                    else:\n                        has_pseudo = True\n        \n        all_results.append([has_canonical, has_pseudo])\n\n    # Format the final output string exactly as specified.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "正则表达式和简单的基序搜索在处理高度保守的模式时非常有效，但当一个结构域家族内部存在较多变异时，它们就显得力不从心。为了解决这个问题，生物信息学家开发了更为强大和灵活的概率模型，其中隐马尔可夫模型（HMMs）是识别蛋白质家族和结构域的金标准。这个练习将让你亲身体验HMM在序列分析中的核心逻辑，你需要为一个给定的HMM实现一个类似Viterbi的算法，通过计算对数奇数比（log-odds score）来判断序列中是否存在一个特定的结构域。",
            "id": "2420110",
            "problem": "您将获得一个简化的、完全指定的轮廓隐马尔可夫模型 (HMM)，该模型针对病毒RNA依赖性RNA聚合酶的保守掌状结构域核心，并专注于三个标志性基序。该模型将用于判断蛋白质序列是否包含与此结构域一致的局部子序列。目标是计算每个给定序列是否存在一个连续子序列，其相对于均匀背景的对数几率得分至少达到指定的阈值。\n\n字母表和背景模型：\n- 氨基酸字母表是包含$20$个标准大写字母的集合 $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y} \\}$。\n- 此外，符号$\\mathrm{X}$表示一个未知残基，必须被视为具有与背景相同的发射概率。\n- 背景模型是一个独立同分布过程，对于$20$个字母的字母表中的每个字母，其概率为$1/20$。对于$\\mathrm{X}$，也使用$1/20$。\n- 所有对数都必须是自然对数。\n\nHMM 结构：\n- HMM 具有以下发射状态：$\\mathrm{MA1}, \\mathrm{MA2}, \\mathrm{MA3}, \\mathrm{MA4}, \\mathrm{MA5}, \\mathrm{IA}, \\mathrm{MB1}, \\mathrm{MB2}, \\mathrm{MB3}, \\mathrm{MB4}, \\mathrm{IB}, \\mathrm{MC1}, \\mathrm{MC2}, \\mathrm{MC3}$。\n- HMM 在发射$\\mathrm{MA1}$之前进入，并在发射$\\mathrm{MC3}$后立即退出。在发射过程中没有非发射状态；开始和结束是隐式的。\n- 允许的转移及其概率：\n  - $\\mathrm{MA1} \\to \\mathrm{MA2}$，概率为$1$。\n  - $\\mathrm{MA2} \\to \\mathrm{MA3}$，概率为$1$。\n  - $\\mathrm{MA3} \\to \\mathrm{MA4}$，概率为$1$。\n  - $\\mathrm{MA4} \\to \\mathrm{MA5}$，概率为$1$。\n  - $\\mathrm{MA5} \\to \\mathrm{MB1}$，概率为$0.7$。\n  - $\\mathrm{MA5} \\to \\mathrm{IA}$，概率为$0.3$。\n  - $\\mathrm{IA} \\to \\mathrm{IA}$，概率为$0.8$。\n  - $\\mathrm{IA} \\to \\mathrm{MB1}$，概率为$0.2$。\n  - $\\mathrm{MB1} \\to \\mathrm{MB2}$，概率为$1$。\n  - $\\mathrm{MB2} \\to \\mathrm{MB3}$，概率为$1$。\n  - $\\mathrm{MB3} \\to \\mathrm{MB4}$，概率为$1$。\n  - $\\mathrm{MB4} \\to \\mathrm{MC1}$，概率为$0.7$。\n  - $\\mathrm{MB4} \\to \\mathrm{IB}$，概率为$0.3$。\n  - $\\mathrm{IB} \\to \\mathrm{IB}$，概率为$0.8$。\n  - $\\mathrm{IB} \\to \\mathrm{MC1}$，概率为$0.2$。\n  - $\\mathrm{MC1} \\to \\mathrm{MC2}$，概率为$1$。\n  - $\\mathrm{MC2} \\to \\mathrm{MC3}$，概率为$1$。\n- 任何未列出的转移都是不允许的（概率为$0$）。\n\n发射：\n- 对于状态$\\mathrm{MA1}$、$\\mathrm{MB1}$、$\\mathrm{MC1}$、$\\mathrm{MC2}$和$\\mathrm{MC3}$，预期有一个共有残基。发射概率如下：\n  - 如果观测到的残基与共有字母相同，则发射概率为$0.9$。\n  - 如果观测到的残基是字母表中其他$19$个字母之一且不等于共有字母，则发射概率为$0.1/19$。\n  - 如果观测到的残基是$\\mathrm{X}$，则发射概率为$1/20$。\n- 共有字母如下：\n  - $\\mathrm{MA1}$ 预期为 $\\mathrm{D}$。\n  - $\\mathrm{MB1}$ 预期为 $\\mathrm{G}$。\n  - $\\mathrm{MC1}$ 预期为 $\\mathrm{G}$。\n  - $\\mathrm{MC2}$ 预期为 $\\mathrm{D}$。\n  - $\\mathrm{MC3}$ 预期为 $\\mathrm{D}$。\n- 对于所有其他发射状态$\\mathrm{MA2}, \\mathrm{MA3}, \\mathrm{MA4}, \\mathrm{MA5}, \\mathrm{MB2}, \\mathrm{MB3}, \\mathrm{MB4}, \\mathrm{IA}, \\mathrm{IB}$，发射分布在字母表上是均匀的，即对于$20$个字母中的任何一个，概率都是$1/20$。对于$\\mathrm{X}$，使用$1/20$。\n\n评分和决策规则：\n- 对于给定的蛋白质序列，考虑其每个连续子序列。对于任意长度为$L$的子序列，设$P_{\\mathrm{HMM}}$表示通过任何从$\\mathrm{MA1}$开始、在$\\mathrm{MC3}$结束、精确发射$L$个残基并遵守上述所有转移约束和发射概率的有效路径生成该子序列的最大概率。设$P_{\\mathrm{BG}}$表示在均匀独立模型下相同子序列的背景概率，即$P_{\\mathrm{BG}} = (1/20)^L$。\n- 将该子序列的对数几率得分定义为\n$$\n\\mathrm{LLR} = \\ln P_{\\mathrm{HMM}} - \\ln P_{\\mathrm{BG}}.\n$$\n- 对于该序列，将最终得分定义为其所有连续子序列中的最大$\\mathrm{LLR}$。\n- 使用阈值$T = 5.0$。如果最大$\\mathrm{LLR} \\ge T$，则将序列分类为包含该结构域（布尔值为$\\mathrm{True}$）；否则分类为不包含该结构域（布尔值为$\\mathrm{False}$）。\n\n测试套件：\n- 使用以下有序的蛋白质序列（字符串）列表。字母表如前所述受限，任何$\\mathrm{X}$都表示一个未知残基，需按规定处理。\n  - 案例 $1$：$\\mathrm{DAAAAGAAAGDD}$\n  - 案例 $2$：$\\mathrm{MTRNAVDPQMDKSTADGAAAGDDQL}$\n  - 案例 $3$：$\\mathrm{ACFLKPNRTSVYHMIQLKTAACFLKPNR}$\n  - 案例 $4$：$\\mathrm{DAAAADVVVVVLLLLLPPPPPSSSSSTTTTTGAAAVVVVVLLLLLPPPPPSSSSSTTTTTGDD}$\n  - 案例 $5$：$\\mathrm{XAAAADGAAAGDX}$\n  - 案例 $6$：$\\mathrm{DGGD}$\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与测试套件相同。每个结果必须是呈现为$\\mathrm{True}$或$\\mathrm{False}$的布尔值，例如$[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。",
            "solution": "所提出的问题要求根据一个代表保守蛋白质结构域的简化轮廓隐马尔可夫模型 (HMM) 来验证蛋白质序列。任务是确定每个序列中是否存在任何连续子序列，其对数几率得分至少达到给定阈值$T = 5.0$。该得分是通过比较子序列由HMM生成的最大概率$P_{\\mathrm{HMM}}$与其在均匀背景模型下的概率$P_{\\mathrm{BG}}$来计算的。\n\n首先，我们将问题形式化。对于长度为$L$的子序列$S'$，其对数几率得分LLR由以下公式给出：\n$$ \\mathrm{LLR} = \\ln P_{\\mathrm{HMM}}(S') - \\ln P_{\\mathrm{BG}}(S') $$\n背景模型是均匀的，所以$P_{\\mathrm{BG}}(S') = (1/20)^L$。其对数为$\\ln P_{\\mathrm{BG}}(S') = L \\ln(1/20) = -L \\ln(20)$。\nHMM概率$P_{\\mathrm{HMM}}(S')$是所有从状态$\\mathrm{MA1}$开始并在状态$\\mathrm{MC3}$结束的长度为$L$的可能路径$\\pi$中的最大概率：\n$$ P_{\\mathrm{HMM}}(S') = \\max_{\\pi: \\pi_0=\\mathrm{MA1}, \\pi_{L-1}=\\mathrm{MC3}} \\left( \\prod_{k=0}^{L-1} P_{\\text{emission}}(S'_k | \\pi_k) \\prod_{k=0}^{L-2} P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) $$\n将这些代入LLR方程，并利用对数的性质，我们得到：\n$$ \\mathrm{LLR} = \\max_{\\pi} \\left( \\sum_{k=0}^{L-1} \\ln P_{\\text{emission}}(S'_k | \\pi_k) + \\sum_{k=0}^{L-2} \\ln P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) + L \\ln(20) $$\n这可以重排为对数几率发射得分和对数转移概率的总和：\n$$ \\mathrm{LLR} = \\max_{\\pi} \\left( \\sum_{k=0}^{L-1} \\left( \\ln P_{\\text{emission}}(S'_k | \\pi_k) + \\ln(20) \\right) + \\sum_{k=0}^{L-2} \\ln P_{\\text{transition}}(\\pi_{k+1} | \\pi_k) \\right) $$\n设状态$k$中残基$c$的对数几率发射得分为$E(c, k) = \\ln(P_{\\text{emission}}(c | k) \\times 20)$，对数转移概率为$T(j, k) = \\ln P_{\\text{transition}}(k | j)$。问题是找到输入蛋白质的所有连续子序列中的最大LLR。\n\n遍历所有子序列的暴力方法在计算上是不可行的。一个更高效的解决方案是利用动态规划，具体来说是一种为局部比对检测而修改的类似Viterbi的算法。我们定义一个动态规划表$V[i][k]$，用于存储发射了输入序列$S$的第$i$个残基后，结束于状态$k$的任何路径的最大对数几率得分。比对的“局部”性质通过允许在序列的任何位置开始新的比对来处理，这对应于在起始状态$\\mathrm{MA1}$初始化一条路径。\n\nHMM的状态从$0$到$13$进行索引。设状态集为$\\mathcal{K} = \\{ \\mathrm{MA1}, \\dots, \\mathrm{MC3} \\}$。DP表$V$的维度为$N \\times |\\mathcal{K}|$，其中$N$是序列$S=S_0S_1...S_{N-1}$的长度。\n\n递推关系如下：\n对于初始状态$\\mathrm{MA1}$，比对可以从任何位置$i$开始：\n$$ V[i][\\mathrm{MA1}] = E(S_i, \\mathrm{MA1}) $$\n对于任何其他状态$k \\in \\mathcal{K} \\setminus \\{\\mathrm{MA1}\\}$，其得分是根据其前驱状态在上一位置$i-1$的得分计算的：\n$$ V[i][k] = E(S_i, k) + \\max_{j \\in \\text{Pred}(k)} \\left( V[i-1][j] + T(j, k) \\right) \\quad \\text{for } i > 0 $$\n其中$\\text{Pred}(k)$是可以转移到状态$k$的状态集合。对于$i=0$，$V[0][k] = -\\infty$ (对于$k \\ne \\mathrm{MA1}$)，因为任何路径都必须从$\\mathrm{MA1}$开始。\n\n对数几率发射得分$E(c, k)$是预先计算的：\n- 对于共有状态（$\\mathrm{MA1}, \\mathrm{MB1}, \\mathrm{MC1}, \\mathrm{MC2}, \\mathrm{MC3}$）：\n  - 匹配：$\\ln(0.9 \\times 20) = \\ln(18) \\approx 2.8904$\n  - 错配：$\\ln((0.1/19) \\times 20) = \\ln(2/19) \\approx -2.2513$\n  - 未知（‘$\\mathrm{X}$’）：$\\ln((1/20) \\times 20) = \\ln(1) = 0$\n- 对于均匀状态（所有其他状态）：\n  - 任何残基：$\\ln((1/20) \\times 20) = \\ln(1) = 0$\n\n对数转移概率$T(j, k)$也是预先计算的：\n- $P=1 \\implies T = \\ln(1) = 0$\n- $P=0.8 \\implies T = \\ln(0.8) \\approx -0.2231$\n- $P=0.7 \\implies T = \\ln(0.7) \\approx -0.3567$\n- $P=0.3 \\implies T = \\ln(0.3) \\approx -1.2040$\n- $P=0.2 \\implies T = \\ln(0.2) \\approx -1.6094$\n\n算法通过从$i=0$到$N-1$遍历序列来填充DP表$V$。在每个位置$i$，我们为所有状态$k$计算$V[i][k]$。问题规定，该结构域的有效路径必须在状态$\\mathrm{MC3}$结束。因此，在计算完位置$i$的所有得分后，我们用$V[i][\\mathrm{MC3}]$的值更新运行中的最大得分$\\mathrm{LLR}_{\\max}$。\n$$ \\mathrm{LLR}_{\\max} = \\max_{i \\in [0, N-1]} V[i][\\mathrm{MC3}] $$\n最初，$\\mathrm{LLR}_{\\max}$被设置为$-\\infty$。遍历整个序列后，将最终的$\\mathrm{LLR}_{\\max}$与阈值$T=5.0$进行比较。如果$\\mathrm{LLR}_{\\max} \\geq T$，则该序列被分类为包含该结构域（True）；否则，则不包含（False）。此过程将应用于测试套件中的每个序列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein domain identification problem using a Viterbi-like algorithm.\n    \"\"\"\n    \n    # Define problem parameters\n    THRESHOLD = 5.0\n    ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\n    STATES = [\n        \"MA1\", \"MA2\", \"MA3\", \"MA4\", \"MA5\", \"IA\", \n        \"MB1\", \"MB2\", \"MB3\", \"MB4\", \"IB\", \n        \"MC1\", \"MC2\", \"MC3\"\n    ]\n    CONSENSUS_SPEC = {\n        'MA1': 'D', 'MB1': 'G', 'MC1': 'G', 'MC2': 'D', 'MC3': 'D'\n    }\n    \n    TRANSITIONS = [\n        ('MA1', 'MA2', 1.0), ('MA2', 'MA3', 1.0), ('MA3', 'MA4', 1.0), ('MA4', 'MA5', 1.0),\n        ('MA5', 'MB1', 0.7), ('MA5', 'IA', 0.3),\n        ('IA', 'IA', 0.8), ('IA', 'MB1', 0.2),\n        ('MB1', 'MB2', 1.0), ('MB2', 'MB3', 1.0), ('MB3', 'MB4', 1.0),\n        ('MB4', 'MC1', 0.7), ('MB4', 'IB', 0.3),\n        ('IB', 'IB', 0.8), ('IB', 'MC1', 0.2),\n        ('MC1', 'MC2', 1.0), ('MC2', 'MC3', 1.0),\n    ]\n\n    # Pre-computation\n    # 1. Mappings\n    state_map = {name: i for i, name in enumerate(STATES)}\n    num_states = len(STATES)\n    char_map = {c: i for i, c in enumerate(ALPHABET)}\n    char_map['X'] = 20\n    \n    # 2. Log-odds emission scores\n    log_emission_scores = np.full((num_states, 21), 0.0) # Default is uniform, log-odds = 0\n    for state_name, cons_char in CONSENSUS_SPEC.items():\n        state_idx = state_map[state_name]\n        cons_char_idx = char_map[cons_char]\n        for char_code in range(21):\n            if char_code == 20: # 'X'\n                log_emission_scores[state_idx, char_code] = 0.0\n            elif char_code == cons_char_idx:\n                log_emission_scores[state_idx, char_code] = np.log(0.9 * 20) # Match\n            else:\n                log_emission_scores[state_idx, char_code] = np.log((0.1 / 19) * 20) # Mismatch\n\n    # 3. Log-transition probabilities and predecessor structure\n    predecessors = {i: [] for i in range(num_states)}\n    for from_s, to_s, prob in TRANSITIONS:\n        log_prob = np.log(prob)\n        predecessors[state_map[to_s]].append((state_map[from_s], log_prob))\n\n    test_cases = [\n        \"DAAAAGAAAGDD\",\n        \"MTRNAVDPQMDKSTADGAAAGDDQL\",\n        \"ACFLKPNRTSVYHMIQLKTAACFLKPNR\",\n        \"DAAAADVVVVVLLLLLPPPPPSSSSSTTTTTGAAAVVVVVLLLLLPPPPPSSSSSTTTTTGDD\",\n        \"XAAAADGAAAGDX\",\n        \"DGGD\",\n    ]\n\n    results = []\n    \n    s_idx_ma1 = state_map['MA1']\n    s_idx_mc3 = state_map['MC3']\n\n    for seq in test_cases:\n        seq_len = len(seq)\n        if seq_len == 0:\n            results.append(False)\n            continue\n\n        V = np.full((seq_len, num_states), -np.inf)\n        max_llr = -np.inf\n\n        for i in range(seq_len):\n            char_idx = char_map.get(seq[i])\n\n            # Recurrence for MA1 (start of a local alignment)\n            V[i, s_idx_ma1] = log_emission_scores[s_idx_ma1, char_idx]\n            \n            # Recurrence for other states\n            if i > 0:\n                for k in range(num_states):\n                    if k == s_idx_ma1: continue \n                    \n                    max_prev_score = -np.inf\n                    if predecessors[k]:\n                        for pred_idx, log_trans_prob in predecessors[k]:\n                            score = V[i-1, pred_idx] + log_trans_prob\n                            if score > max_prev_score:\n                                max_prev_score = score\n                    \n                    if max_prev_score > -np.inf:\n                         V[i, k] = max_prev_score + log_emission_scores[k, char_idx]\n            \n            # Check for new max score at the final state\n            if V[i, s_idx_mc3] > max_llr:\n                max_llr = V[i, s_idx_mc3]\n\n        results.append(max_llr >= THRESHOLD)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}