{
    "hands_on_practices": [
        {
            "introduction": "第一个动手实践是一个计算基因发现的基础练习。您将从零开始实现一个简单的、基于规则的 tRNA 查找器，将 tRNA 著名的三叶草二级结构转化为具体的算法。通过搜索受体臂和反密码子环等关键特征，您将直接体验生物信息学预测工具背后的核心逻辑，并学习如何使用精确率和召回率等标准指标来评估其性能 。",
            "id": "2438434",
            "problem": "您的任务是实现一个完整的、可运行的程序。该程序针对一个固定的、小型的合成脱氧核糖核酸（DNA）序列测试套件，执行基于规则的转运 RNA（tRNA）基因预测，并将其性能与一个由 transfer RNA scan - Search Engine（tRNAscan-SE）提供的基线进行比较。程序必须以单一、指定的输出格式报告每种方法在每个测试用例上的精确率和召回率。\n\n解决方案必须基于以下基本原理和广泛接受的生物学事实：\n- 分子生物学的中心法则指出，遗传信息从 DNA 流向核糖核酸（RNA），再到蛋白质。转运 RNA（tRNA）基因编码结构化的 RNA 分子，这些分子会折叠成具有保守特征的三叶草结构，包括在 $5^{\\prime}$ 和 $3^{\\prime}$ 末端之间形成碱基配对的受体臂、一个大小近似固定的环的反密码子臂，以及一个 T$\\Psi$C 环基序，其在 DNA 层面上的基序通常表现为三核苷酸 \"TTC\"。\n- 经典的 Watson–Crick 碱基配对在 DNA 中是 $A$–$T$ 和 $C$–$G$，而 RNA 中的摆动配对通常涉及 $G$–$U$；为了适应在 DNA 中的启发式检测，我们将在结构检查中允许 $G$–$T$ 作为一种额外的可容忍配对。\n\n您的程序必须实现一个简单的、基于规则的 tRNA 基因查找器，它扫描一个 DNA 字符串，并基于以下三个启发式特征提出候选基因区间：\n1) 反密码子发夹：检测一个发夹结构，其茎长 $s = 5$ 个核苷酸，侧翼为一个长度 $\\ell = 7$ 个核苷酸的环。两个茎必须在配对规则 $\\{A\\text{–}T, T\\text{–}A, C\\text{–}G, G\\text{–}C, G\\text{–}T, T\\text{–}G\\}$ 下是反向互补的，且最多允许 $m_s = 1$ 个错配。\n2) T$\\Psi$C 环 DNA 基序：要求 \"TTC\" 基序出现在候选窗口的最后 $d = 20$ 个核苷酸内（即，在窗口末端的上游）。\n3) 受体臂：在候选窗口内，要求前 $a = 7$ 个核苷酸和后 $a = 7$ 个核苷酸（或者，如果 \"CCA\" 出现在窗口的最末端，则为紧接在末端 \"CCA\" 前的 7 个核苷酸）在相同的配对规则集下是反向互补的，且最多允许 $m_a = 1$ 个错配。\n\n候选窗口必须根据每个检测到的发夹按如下方式形成：如果左侧茎起始于索引 $i_{\\ell}$，右侧茎结束于索引 $i_{r}$（末端不包含），则定义一个窗口 $[i_{\\ell} - w,\\, i_{r} + w)$，该窗口被裁剪至序列边界，其中 $w = 25$。丢弃长度在 $[60, 100]$ 个核苷酸之外的候选窗口。如果多个候选窗口显著重叠，则通过将 Jaccard 重叠度大于 $0.8$ 的任何一对合并为其并集区间来进行去重。\n\n在评估时，将每个预测区间视为一个索引集合，并使用 Jaccard 重叠度\n$$\nJ(I_p, I_t) \\;=\\; \\frac{|I_p \\cap I_t|}{|I_p \\cup I_t|}\n$$\n来将预测区间 $I_p$ 与真实区间 $I_t$ 进行匹配。如果一个预测与任何尚未匹配的真实区间的匹配度 $J \\ge \\tau$（其中 $\\tau = 0.5$），则该预测计为一个真阳性。否则，它是一个假阳性。任何未被任何预测匹配的真实区间都是一个假阴性。定义标准的计数：真阳性（$\\mathrm{TP}$）、假阳性（$\\mathrm{FP}$）和假阴性（$\\mathrm{FN}$）。精确率和召回率则为\n$$\n\\text{precision} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}, \\qquad\n\\text{recall} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}.\n$$\n使用此约定：如果 $\\mathrm{TP} + \\mathrm{FP} = 0$，则精确率定义为 $1.0$；如果 $\\mathrm{TP} + \\mathrm{FN} = 0$，则召回率定义为 $1.0$。\n\n坐标是基于零的半开区间 $[s,e)$，其中 $s$ 是起始索引，$e$ 是最后一个索引之后的位置，这与标准的编程字符串切片一致。\n\n您的程序必须为每个测试用例计算您的基于规则的查找器的精确率和召回率，以及归属于 transfer RNA scan - Search Engine (tRNAscan-SE) 的给定基线预测的精确率和召回率。所有字符串操作都基于 DNA 字母表 $\\{A, C, G, T\\}$。不涉及物理单位。\n\n测试套件（三个序列），每个均按以下形式提供：\n- DNA 序列字符串。\n- 真实 tRNA 基因区间，以 $[s,e)$ 列表的形式。\n- 基线区间（归属于 tRNAscan-SE），以 $[s,e)$ 列表的形式。\n\n请精确使用以下序列和注释：\n\n案例 1（一般成功路径）：\n- 序列：\n\"TTGACCGTTTGACCGTTTGACCGTTTGACCGTTTGACCGTGCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGTTCGAATGCTAAGCCCAGATCGATCGAGATCGATCGAGATCGATCGA\"\n- 真实标签：$[[40, 116)]$。\n- 基线 (tRNAscan-SE)：$[[40, 116)]$。\n\n案例 2（边界条件：基因位于起始位置，无编码的 CCA，缺失具有挑战性的 T 环基序）：\n- 序列：\n\"GCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGAAAGAATGCTAAGC\" + \"GCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGT\"\n- 真实标签：$[[0, 73)]$。\n- 基线 (tRNAscan-SE)：$[[0, 73)]$。\n\n案例 3（边缘情况：没有真实的 tRNA，但存在一个 tRNA 样子的诱饵基序）：\n- 序列：\n\"AACCGGTTAACCGGTTAACC\" + \"ATGCCGAAAGGGGATCGACCGTATGAATTTTACGGATCGAATCGAAAGCAGTAGGTTCGAATTCGGCATCCA\" + \"GATCGATCGATCGATCGATC\"\n- 真实标签：$[]$。\n- 基线 (tRNAscan-SE)：$[]$。\n\n程序输出规范：\n- 对于案例 1、2、3，按顺序计算四个浮点数，每个都四舍五入到恰好三位小数：您方法的精确率、您方法的召回率、基线精确率和基线召回率。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序为 $[\\text{P}_{1}, \\text{R}_{1}, \\text{P}^{\\mathrm{base}}_{1}, \\text{R}^{\\mathrm{base}}_{1}, \\text{P}_{2}, \\text{R}_{2}, \\text{P}^{\\mathrm{base}}_{2}, \\text{R}^{\\mathrm{base}}_{2}, \\text{P}_{3}, \\text{R}_{3}, \\text{P}^{\\mathrm{base}}_{3}, \\text{R}^{\\mathrm{base}}_{3}]$。\n\n输出中的所有数字都是无单位的实数，表示为四舍五入到小数点后三位的十进制字符串。不得打印任何额外文本。",
            "solution": "所提出的问题是生物信息学中一个明确定义的任务，特别是在基于规则的转运 RNA（tRNA）基因预测领域。目标是实现一个特定的、简化的算法，用于在合成 DNA 序列中识别 tRNA 基因，并根据给定的真实标签和基线预测集来评估其性能。\n\n### 问题验证\n\n问题陈述已经过验证，被认为是**有效的**。验证过程的详细分解如下。\n\n**步骤1：提取给定信息**\n所有参数、定义和数据均已从问题陈述中逐字提取：\n- **启发式特征**：\n    1. 反密码子发夹：茎长 $s=5$，环长 $\\ell=7$，茎中最多允许 $m_s=1$ 个错配。\n    2. T$\\Psi$C 环基序：DNA 序列 \"TTC\" 必须存在于候选窗口的最后 $d=20$ 个核苷酸内。\n    3. 受体臂：由窗口的前后各 $a=7$ 个核苷酸组成，最多允许 $m_a=1$ 个错配。如果窗口以 \"CCA\" 结尾，则有特殊情况。\n- **配对规则**：Watson-Crick 配对（$A$–$T$, $C$–$G$）加上类摆动配对（$G$–$T$）。\n- **候选生成**：围绕一个发夹结构形成一个 $[i_{\\ell} - w, i_{r} + w)$（其中 $w=25$）的窗口，筛选长度在 $[60, 100]$ 范围内的窗口，并在 Jaccard 重叠度超过 $0.8$ 时进行去重。\n- **评估**：性能由精确率和召回率衡量，匹配由 Jaccard 重叠度阈值 $\\tau = 0.5$ 确定。如果精确率和召回率各自的分母为零，则定义为 $1.0$。\n- **数据**：提供了三个测试用例，每个用例都包含 DNA 序列、真实标签区间和基线预测区间。\n\n**步骤2：使用提取的给定信息进行验证**\n根据所需标准对问题进行评估：\n- **有科学依据**：是。该问题使用了一个简化但生物学上合理的 tRNA 二级结构（三叶草）及其保守特征模型。基于模式匹配和启发式方法的算法途径是生物信息学中的一种标准技术。\n- **定义明确**：是。算法规则的参数被完整、无歧义地指定。输入已提供，期望的输出格式是精确的。可以推导出唯一的解。\n- **客观性**：是。问题以精确、定量的术语陈述，不含主观性。\n\n**潜在矛盾分析**：\n仔细检查发现，在某些测试用例中提供的真实标签注释不满足要实现的搜索规则。例如：\n- 在案例 1 中，真实标签基因 $[40, 116)$ 未能满足指定的受体臂互补规则（有 4 个错配，而最多只允许 $m_a=1$ 个）。\n- 在案例 2 中，真实标签基因 $[0, 73)$ 未能满足 T$\\Psi$C 环基序规则，因为它在所需区域内缺少 \"TTC\" 序列。\n\n这不是一个使问题无效的缺陷。相反，它被解释为问题设计的一个特意安排的特点。任务不是创建一个能完美地重新发现“真实”注释的算法，而是要精确地实现指定的规则集，然后评估其性能。这种差异凸显了简单的启发式模型相对于更复杂的现实（或像 tRNAscan-SE 这样更复杂的预测工具）的局限性，这是一个有价值的科学教训。该问题仍然是一个一致的、可解决的挑战。\n\n**步骤3：结论与行动**\n问题是**有效的**。将按规定继续实施该算法。\n\n### 算法解决方案设计\n\n该解决方案以系统化的流水线方式实现，将提供的规则转化为不同的计算步骤。\n\n1.  **基本数据结构和规则**：\n    - 将核苷酸配对规则 $\\{A\\text{–}T, T\\text{–}A, C\\text{–}G, G\\text{–}C, G\\text{–}T, T\\text{–}G\\}$ 编码到一个查找结构中，以便高效访问。\n    - 定义一个辅助函数 `count_mismatches(seq1, seq2_rev)`，用于根据这些配对规则量化两个茎序列之间的互补性。\n\n2.  **步骤1：反密码子发夹检测**：\n    程序扫描整个 DNA 序列以寻找潜在的反密码子发夹。发夹被定义为一个长度为 $s+\\ell+s = 5+7+5 = 17$ 个核苷酸的结构。对于每个这种长度的子序列，将其前 5 个核苷酸（左茎）与后 5 个核苷酸（右茎）的反向序列进行比较。如果错配数小于或等于 $m_s=1$，则记录发夹的起始和结束位置。\n\n3.  **步骤2：候选窗口生成和初步筛选**：\n    对于每个检测到的有效发夹，提出了一个更宽的候选窗口。如果发夹位于 $[i_{\\ell}, i_{r})$，则初始窗口定义为 $[i_{\\ell} - w, i_{r} + w)$，其中 $w=25$。这些坐标会被裁剪到 DNA 序列的边界内。检查每个结果窗口的长度，只保留长度在 $[60, 100]$ 范围内的窗口以进行进一步处理。\n\n4.  **步骤3：候选去重**：\n    为了处理冗余、重叠的候选，执行去重步骤。这被建模为一个图问题。每个候选窗口是一个节点，如果任意两个节点的 Jaccard 重叠度大于 $0.8$，则在它们之间画一条边。然后识别这个图的连通分量。单个分量内的所有候选窗口被合并成一个超区间，该超区间由该分量中所有区间的最小起始坐标和最大结束坐标定义。这样就得到了一组非冗余的候选区域。\n\n5.  **步骤4：基于特征的最终筛选**：\n    合并后的候选窗口将接受最后两个启发式检查：\n    - **T$\\Psi$C 环基序**：在每个候选序列的最后 $d=20$ 个核苷酸中搜索 \"TTC\" 基序是否存在。如果该基序不存在，则丢弃该候选。\n    - **受体臂**：将前 $a=7$ 个核苷酸与后 $a=7$ 个核苷酸进行反向互补性比较。特殊情况处理以 \"CCA\" 结尾的窗口，其中 $3^{\\prime}$ 茎取自紧接在 \"CCA\" 前的 7 个核苷酸。如果错配数 $m_a$ 超过 1，则丢弃该候选。\n\n6.  **步骤5：性能评估**：\n    基于规则的查找器产生的最终预测区间集和提供的基线区间集分别与真实标签进行比较评估。\n    - 计算真阳性（$\\mathrm{TP}$）、假阳性（$\\mathrm{FP}$）和假阴性（$\\mathrm{FN}$）。如果一个预测与一个真实区间的 Jaccard 重叠度至少为 $\\tau=0.5$，则它们匹配。为确保最佳的一对一映射，采用了一种贪婪匹配策略，即按 Jaccard 分数降序匹配预测区间和真实区间的对。\n    - 计算精确率（$\\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$）和召回率（$\\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}$）。问题规定了一个约定，即如果一个指标的分母为 0，则其值为 $1.0$。\n\n整个过程应用于三个测试用例中的每一个，收集并格式化每个案例产生的四个性能指标（实现的查找器和基线的精确率和召回率），用于最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a rule-based tRNA gene finder and evaluates its performance\n    against a baseline on a fixed test suite.\n    \"\"\"\n\n    # -- Constants from problem statement --\n    S_STEM = 5\n    L_LOOP = 7\n    M_S_MISMATCH = 1\n    D_TLOOP = 20\n    A_STEM = 7\n    M_A_MISMATCH = 1\n    W_EXTEND = 25\n    MIN_LEN = 60\n    MAX_LEN = 100\n    JACCARD_MERGE_THRESH = 0.8\n    JACCARD_EVAL_THRESH = 0.5\n    \n    # -- Base pairing rules as specified --\n    PAIRS = {\n        ('A', 'T'), ('T', 'A'),\n        ('C', 'G'), ('G', 'C'),\n        ('G', 'T'), ('T', 'G')\n    }\n\n    def is_complementary(n1, n2):\n        \"\"\"Checks if two nucleotides are complementary.\"\"\"\n        return (n1, n2) in PAIRS\n\n    def count_mismatches(seq1, seq2_rev):\n        \"\"\"Counts mismatches between a sequence and a reversed sequence.\"\"\"\n        mismatches = 0\n        for n1, n2 in zip(seq1, seq2_rev):\n            if not is_complementary(n1, n2):\n                mismatches += 1\n        return mismatches\n\n    def jaccard_overlap(interval1, interval2):\n        \"\"\"Calculates Jaccard overlap between two [start, end) intervals.\"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        intersection_start = max(s1, s2)\n        intersection_end = min(e1, e2)\n        \n        intersection_size = max(0, intersection_end - intersection_start)\n            \n        union_size = (e1 - s1) + (e2 - s2) - intersection_size\n        \n        if union_size == 0:\n            return 1.0 if intersection_size  0 else 0.0\n        \n        return intersection_size / union_size\n\n    def evaluate_predictions(predicted, true_intervals):\n        \"\"\"Calculates precision and recall.\"\"\"\n        # Handle cases with empty sets as per problem definition\n        if not true_intervals:\n            # TP=0, FN=0 - Recall = 1.0\n            # If nothing predicted, FP=0 - Precision = 1.0\n            # If something predicted, FP  0 - Precision = 0.0\n            return 1.0 if not predicted else 0.0, 1.0\n        if not predicted: # True intervals exist, but no predictions\n            # TP=0, FP=0 - Precision = 1.0\n            # TP=0, FN0 - Recall = 0.0\n            return 1.0, 0.0\n\n        n_pred = len(predicted)\n        n_true = len(true_intervals)\n        \n        # Greedily find best matches to solve assignment problem\n        potential_matches = []\n        for i, p_interval in enumerate(predicted):\n            for j, t_interval in enumerate(true_intervals):\n                j_score = jaccard_overlap(p_interval, t_interval)\n                if j_score = JACCARD_EVAL_THRESH:\n                    potential_matches.append((j_score, i, j))\n        \n        potential_matches.sort(key=lambda x: x[0], reverse=True)\n        \n        matched_preds = set()\n        matched_trues = set()\n        tp = 0\n        \n        for _, p_idx, t_idx in potential_matches:\n            if p_idx not in matched_preds and t_idx not in matched_trues:\n                tp += 1\n                matched_preds.add(p_idx)\n                matched_trues.add(t_idx)\n\n        fp = n_pred - tp\n        fn = n_true - tp\n        \n        precision = 1.0 if (tp + fp) == 0 else tp / (tp + fp)\n        recall = 1.0 if (tp + fn) == 0 else tp / (tp + fn)\n        \n        return precision, recall\n\n    def run_finder(sequence):\n        \"\"\"Executes the full tRNA finding algorithm.\"\"\"\n        seq_len = len(sequence)\n        \n        # 1. Anticodon hairpin detection\n        hairpins = []\n        hairpin_len = S_STEM + L_LOOP + S_STEM\n        for i in range(seq_len - hairpin_len + 1):\n            left_stem = sequence[i : i + S_STEM]\n            right_stem_rev = sequence[i + S_STEM + L_LOOP : i + hairpin_len][::-1]\n            \n            if count_mismatches(left_stem, right_stem_rev) = M_S_MISMATCH:\n                hairpins.append((i, i + hairpin_len))\n\n        # 2. Candidate window formation and length filtering\n        candidates = []\n        for start_pos, end_pos in hairpins:\n            win_start = max(0, start_pos - W_EXTEND)\n            win_end = min(seq_len, end_pos + W_EXTEND)\n            \n            if MIN_LEN = (win_end - win_start) = MAX_LEN:\n                candidates.append([win_start, win_end])\n        \n        if not candidates:\n            return []\n        \n        # 3. Deduplication via connected components\n        num_candidates = len(candidates)\n        adj = [[] for _ in range(num_candidates)]\n        for i in range(num_candidates):\n            for j in range(i + 1, num_candidates):\n                if jaccard_overlap(candidates[i], candidates[j])  JACCARD_MERGE_THRESH:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        visited = [False] * num_candidates\n        dedup_candidates = []\n        for i in range(num_candidates):\n            if not visited[i]:\n                component_indices = []\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head  len(q):\n                    u = q[head]; head += 1\n                    component_indices.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                \n                min_start = min(candidates[k][0] for k in component_indices)\n                max_end = max(candidates[k][1] for k in component_indices)\n                dedup_candidates.append([min_start, max_end])\n\n        # 4. Final filtering based on features\n        final_predictions = []\n        for start, end in dedup_candidates:\n            # T-loop motif filter\n            t_loop_search_region = sequence[max(start, end - D_TLOOP):end]\n            if \"TTC\" not in t_loop_search_region:\n                continue\n            \n            # Acceptor stem filter\n            window_slice = sequence[start:end]\n            if len(window_slice)  A_STEM * 2:\n                continue\n\n            stem5_prime = window_slice[:A_STEM]\n            \n            if window_slice.endswith(\"CCA\"):\n                stem3_prime_start_in_slice = len(window_slice) - 3 - A_STEM\n                stem3_prime_end_in_slice = len(window_slice) - 3\n                if stem3_prime_start_in_slice  0: continue\n                stem3_prime = window_slice[stem3_prime_start_in_slice:stem3_prime_end_in_slice]\n            else:\n                stem3_prime = window_slice[-A_STEM:]\n            \n            stem3_prime_rev = stem3_prime[::-1]\n            if len(stem5_prime) != len(stem3_prime_rev): continue\n\n            if count_mismatches(stem5_prime, stem3_prime_rev) = M_A_MISMATCH:\n                final_predictions.append([start, end])\n                \n        return final_predictions\n\n    # -- Test Suite Definition --\n    test_cases = [\n        {\n            \"seq\": \"TTGACCGTTTGACCGTTTGACCGTTTGACCGTTTGACCGTGCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGTTCGAATGCTAAGCCCAGATCGATCGAGATCGATCGAGATCGATCGA\",\n            \"true\": [[40, 116]],\n            \"base\": [[40, 116]]\n        },\n        {\n            \"seq\": \"GCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGAAAGAATGCTAAGCGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGT\",\n            \"true\": [[0, 73]],\n            \"base\": [[0, 73]]\n        },\n        {\n            \"seq\": \"AACCGGTTAACCGGTTAACCATGCCGAAAGGGGATCGACCGTATGAATTTTACGGATCGAATCGAAAGCAGTAGGTTCGAATTCGGCATCCAGATCGATCGATCGATCGATC\",\n            \"true\": [],\n            \"base\": []\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        my_predictions = run_finder(case[\"seq\"])\n        \n        my_prec, my_rec = evaluate_predictions(my_predictions, case[\"true\"])\n        base_prec, base_rec = evaluate_predictions(case[\"base\"], case[\"true\"])\n        \n        all_results.extend([my_prec, my_rec, base_prec, base_rec])\n\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建预测器只是成功的一半，确保其可靠性也同样至关重要。本实践将深入探讨验证这一基本过程，要求您构建一个“诱饵”数据库——一组通过算法设计来模仿 tRNA 结构特征但并非真实 tRNA 的序列。通过衡量一个简单预测器在这些诱饵序列上的假阳性率，您将探索如何量化和挑战生物信息学算法的特异性 。",
            "id": "2438448",
            "problem": "您的任务是数学上构建一个有限的诱饵脱氧核糖核酸（DNA）序列集，这些序列模拟转运核糖核酸（tRNA）基因的结构特征，然后量化一个简化预测器的假阳性率。所有字符串均基于字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。令沃森-克里克互补（Watson–Crick complement）由双射 $\\text{A}\\leftrightarrow \\text{T}$ 和 $\\text{C}\\leftrightarrow \\text{G}$ 定义。对于任意碱基 $b$，令 $\\overline{b}$ 表示其互补碱基，对于任意字符串 $w=w_0w_1\\ldots w_{m-1}$，定义其反向互补序列 $\\overline{w}^{\\mathrm{rev}}=\\overline{w_{m-1}}\\ldots \\overline{w_1}\\overline{w_0}$。\n\n每个诱饵序列必须具有以下形式和性质，这些形式和性质完全由整数 $L$、$p$ 和 $l$（其中 $L\\ge 2p+l$）以及一组反密码子三联体 $\\mathcal{S}$（长度为3的字符串）指定：\n\n1. 结构。序列是以下部分的拼接\n$$\n\\underbrace{T\\ldots T}_{a\\ \\text{个}}\\ \\cdot\\ \\text{left\\_arm}\\ \\cdot\\ \\text{loop}\\ \\cdot\\ \\text{right\\_arm}\\ \\cdot\\ \\underbrace{T\\ldots T}_{b\\ \\text{个}},\n$$\n其中 $a=\\left\\lfloor \\dfrac{L-(2p+l)}{2}\\right\\rfloor$ 且 $b=L-(2p+l)-a$。臂长为 $|\\text{left\\_arm}|=|\\text{right\\_arm}|=p$，环长为 $|\\text{loop}|=l$。右臂是左臂的反向互补序列，即 $\\text{right\\_arm}=\\overline{\\text{left\\_arm}}^{\\mathrm{rev}}$。\n\n2. 环与反密码子位置。对于选定的反密码子 $t\\in\\mathcal{S}$，令 $s=\\left\\lfloor\\dfrac{l-3}{2}\\right\\rfloor$。环是一个长度为 $l$ 的字符串，其在索引 $s,s+1,s+2$ 处等于 $t$，在所有其他索引处为 $\\text{A}$。\n\n3. 通过2-mer重复并施加鸟嘌呤-胞嘧啶（GC）约束来合成臂。令 $[g_{\\min},g_{\\max}]$ 为实数界限，满足 $0\\le g_{\\min}\\le g_{\\max}\\le 1$。考虑字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上所有2-mer的集合，并将一个2-mer的GC分数定义为等于 $\\text{G}$ 或 $\\text{C}$ 的位置数除以2。在GC分数位于 $[g_{\\min},g_{\\max}]$ 区间内的2-mer中，确定性地选择两个：\n- 变体A（最小GC臂）：选择GC分数最小的2-mer；如果存在多个，则选择字典序最小的。\n- 变体B（最大GC臂）：选择GC分数最大的2-mer；如果存在多个，则选择字典序最大的。\n对于每个变体，通过将所选的2-mer重复 $\\lceil p/2\\rceil$ 次并截断至长度 $p$ 来形成左臂。\n\n对于给定的参数集，诱饵集 $\\mathcal{D}$ 由为 $\\mathcal{S}$ 中的每个反密码子使用两种臂变体而得到的恰好 $2|\\mathcal{S}|$ 个序列组成。\n\n定义一个简化的预测器，该预测器使用参数 $p_{\\min}$、$l_{\\min}$、$l_{\\max}$、$g^{\\mathrm{pred}}_{\\min}$、$g^{\\mathrm{pred}}_{\\max}$ 和一个阈值 $T$，将任何序列 $x$ 映射到一个布尔值的“预测为tRNA”标签，具体如下。\n\n- 令 $n=|x|$。令 $\\mathrm{Ind}(x)$ 为索引 $i\\in\\{0,1,\\ldots,n-3\\}$ 的集合，使得长度为3的子字符串 $x[i:i+3]$ 是 $\\mathcal{S}$ 的一个元素。定义指示函数 $I(x)=1$ 如果 $\\mathrm{Ind}(x)\\neq\\varnothing$，否则 $I(x)=0$。\n- 对于每个 $i\\in \\mathrm{Ind}(x)$，对于每个整数 $l'\\in[l_{\\min},l_{\\max}]$（满足 $i+l'\\le n$），以及对于每个整数臂长 $p'\\ge p_{\\min}$（满足 $i-p'\\ge 0$ 和 $i+l'+p'\\le n$），定义左臂片段 $L(i,p')=x[i-p':i]$ 和右臂片段 $R(i,l',p')=x[i+l':i+l'+p']$。令\n$$\nM(i,l',p')=\\sum_{j=0}^{p'-1}\\mathbf{1}\\{\\overline{L(i,p')_{p'-1-j}}=R(i,l',p')_{j}\\},\n$$\n为当将反转的左片段与右片段对齐时，沃森-克里克互补碱基对的数量。令两个臂合并后的GC分数为\n$$\n\\mathrm{GC}(i,l',p')=\\frac{\\#\\{ \\text{G or C in }L(i,p')\\}+\\#\\{\\text{G or C in }R(i,l',p')\\}}{2p'}.\n$$\n仅考虑满足 $\\mathrm{GC}(i,l',p')\\in[g^{\\mathrm{pred}}_{\\min},g^{\\mathrm{pred}}_{\\max}]$ 的 $(i,l',p')$；对于所有其他三元组，忽略其 $M$ 值。定义\n$$\nS_{\\max}(x)=\\left(\\max_{\\substack{i\\in \\mathrm{Ind}(x),\\\\ l'\\in[l_{\\min},l_{\\max}],\\\\ p'\\ge p_{\\min}\\ \\text{feasible},\\\\ \\mathrm{GC}\\in[g^{\\mathrm{pred}}_{\\min},g^{\\mathrm{pred}}_{\\max}]}} M(i,l',p')\\right) + I(x),\n$$\n并约定空集上的最大值为 $0$。当且仅当 $S_{\\max}(x)\\ge T$ 时，预测器输出“预测为tRNA”。\n\n对于任何诱饵集 $\\mathcal{D}$，将假阳性率定义为\n$$\n\\mathrm{FPR}=\\frac{\\#\\{x\\in\\mathcal{D}: \\text{ 预测器对 }x\\text{ 输出阳性}\\}}{|\\mathcal{D}|},\n$$\n以小数形式表示。\n\n您的程序必须对以下每个测试用例，根据参数精确地构建 $\\mathcal{D}$，完全按照定义应用预测器，并计算 $\\mathrm{FPR}$。程序必须生成一行输出，其中包含三个 $\\mathrm{FPR}$ 值，以逗号分隔的列表形式并用方括号括起来，每个值都四舍五入到小数点后三位。\n\n测试套件：\n- 测试用例 1：\n  - $L=50$，$p=6$，$l=7$。\n  - $\\mathcal{S}=\\{\\text{\"GAA\"},\\text{\"TGC\"},\\text{\"CCA\"}\\}$。\n  - 生成器 GC 界限：$[g_{\\min},g_{\\max}]=[0.5,1.0]$。\n  - 预测器参数：$p_{\\min}=5$，$[l_{\\min},l_{\\max}]=[5,9]$，$[g^{\\mathrm{pred}}_{\\min},g^{\\mathrm{pred}}_{\\max}]=[0.4,1.0]$，$T=7$。\n- 测试用例 2：\n  - $L=30$，$p=4$，$l=5$。\n  - $\\mathcal{S}=\\{\\text{\"AAA\"}\\}$。\n  - 生成器 GC 界限：$[g_{\\min},g_{\\max}]=[0.0,1.0]$。\n  - 预测器参数：$p_{\\min}=5$，$[l_{\\min},l_{\\max}]=[4,7]$，$[g^{\\mathrm{pred}}_{\\min},g^{\\mathrm{pred}}_{\\max}]=[0.0,1.0]$，$T=3$。\n- 测试用例 3：\n  - $L=42$，$p=7$，$l=6$。\n  - $\\mathcal{S}=\\{\\text{\"GCT\"},\\text{\"CAT\"}\\}$。\n  - 生成器 GC 界限：$[g_{\\min},g_{\\max}]=[0.0,1.0]$。\n  - 预测器参数：$p_{\\min}=6$，$[l_{\\min},l_{\\max}]=[6,6]$，$[g^{\\mathrm{pred}}_{\\min},g^{\\mathrm{pred}}_{\\max}]=[0.0,0.6]$，$T=8$。\n\n最终输出格式要求：您的程序应生成一行输出，其中按顺序包含三个 $\\mathrm{FPR}$ 值，以逗号分隔的列表形式并用方括号括起来，每个值都四舍五入到小数点后三位（例如，$[\\text{1.000},\\text{0.000},\\text{0.500}]$）。不应打印任何其他文本。",
            "solution": "问题陈述是生物信息学领域中一个明确定义的计算任务，要求构建一个诱饵DNA序列集，并随后评估一个简化的基因预测器在该集合上的性能。所有参数、定义和过程都以数学精度指定，问题是自包含且内部一致的。\n\n问题的有效性验证如下：\n- **科学依据：** 构建模拟生物特征（带有茎和环的tRNA三叶草结构）的诱饵序列，并用它们来衡量预测器的假阳性率，是生物信息学中的一种标准且有效的方法。反向互补、GC含量、反密码子和茎环结构等概念是分子生物学和计算基因发现的基础。该问题是一个简化但科学上合理的模型。\n- **良态问题（Well-Posed）：** 生成诱饵序列和应用预测器的过程都是算法化和确定性的。对于任何给定的参数集，诱饵集 $\\mathcal{D}$ 是唯一的。预测器的评分函数 $S_{\\max}(x)$ 被明确定义，包括对边缘情况的处理（例如，空集上的最大值）。因此，对于每个测试用例，假阳性率（FPR）都有一个单一、可计算的值。\n- **客观性：** 问题以正式、客观的语言描述，没有歧义或主观论断。所有术语都有明确的定义。\n\n该问题没有表现出科学上不健全、不完整、矛盾或含糊不清等缺陷。因此，它被认为是**有效的**。解决方案通过实现指定的算法来推进。\n\n解决方案分为两个主要算法组件：诱饵序列生成器和简化预测器。\n\n**第1部分：诱饵序列生成**\n\n对于每个测试用例，根据参数 $L$（总长度）、$p$（臂长）、$l$（环长）、$\\mathcal{S}$（反密码子三联体集合）和 $[g_{\\min}, g_{\\max}]$（用于臂合成的GC分数界限）构建一个诱饵序列集 $\\mathcal{D}$。\n\n1.  **臂的合成：** tRNA样结构的基础是一个茎，由`left_arm`和`right_arm`组成。首先合成`left_arm`。\n    - 考虑所有 $4^2=16$ 种可能的2-mer（二聚体）的集合。计算每个2-mer的GC分数（例如，“AT”为0.0，“AG”为0.5，“GC”为1.0）。\n    - 对此集合进行筛选，只保留GC分数在给定范围 $[g_{\\min}, g_{\\max}]$ 内的2-mer。\n    - 从这个筛选后的集合中选择两个特定的2-mer，为每个诱饵创建两个臂变体：\n        - **变体A（最小GC臂）：** 选择GC分数最小的2-mer。如果存在多个这样的2-mer，则选择字典序最小的（例如，“AC”在“AG”之前）。\n        - **变体B（最大GC臂）：** 选择GC分数最大的2-mer。如果存在多个这样的2-mer，则选择字典序最大的（例如，“GG”在“GC”之后）。\n    - 通过将所选的2-mer重复 $\\lceil p/2 \\rceil$ 次并将结果截断至长度 $p$ 来形成长度为 $p$ 的`left_arm`。\n\n2.  **结构组装：** 对于每个反密码子三联体 $t \\in \\mathcal{S}$，组装两个完整的诱饵序列，每个臂变体一个。\n    - 核心结构是 `left_arm` $\\cdot$ `loop` $\\cdot$ `right_arm`。\n    - `right_arm`是`left_arm`的反向沃森-克里克互补序列，即 $\\text{right\\_arm} = \\overline{\\text{left\\_arm}}^{\\mathrm{rev}}$，以确保形成茎的潜力。其长度为 $|\\text{right\\_arm}| = p$。\n    - 通过将反密码子 $t$ 放置在中心位置来构建长度为 $l$ 的`loop`。$t$ 在环内的起始索引是 $s = \\lfloor (l-3)/2 \\rfloor$。环中的所有其他位置都用碱基 'A' 填充。\n    - 核心结构的总长度为 $2p+l$。剩余的长度 $L - (2p+l)$ 用 'T' 碱基填充，尽可能均匀地分为长度为 $a = \\lfloor (L-(2p+l))/2 \\rfloor$ 的左侧填充和长度为 $b = L - (2p+l) - a$ 的右侧填充。\n    - 最终的诱饵序列是这些部分的拼接：$(\\text{'T'}\\times a) \\cdot \\text{left\\_arm} \\cdot \\text{loop} \\cdot \\text{right\\_arm} \\cdot (\\text{'T'}\\times b)$。\n    - 完整的诱饵集 $\\mathcal{D}$ 包含 $2|\\mathcal{S}|$ 个序列。\n\n**第2部分：预测器与假阳性率计算**\n\n简化的预测器评估任何给定的序列 $x$，以确定它是否类似于tRNA基因，这基于其自己的一套参数：$p_{\\min}$（最小臂长）、$[l_{\\min}, l_{\\max}]$（环长范围）、$[g^{\\mathrm{pred}}_{\\min}, g^{\\mathrm{pred}}_{\\max}]$（臂的GC含量范围）和 $T$（分数阈值）。来自生成器的反密码子集 $\\mathcal{S}$ 也被预测器使用。\n\n1.  **反密码子搜索：** 预测器首先扫描序列 $x$ 以查找指定反密码子的所有出现位置。这些出现位置的起始索引集合表示为 $\\mathrm{Ind}(x)$。如果 $\\mathrm{Ind}(x)$ 非空，则指示变量 $I(x)$ 设置为1，否则为0。tRNA样结构的搜索以这些索引为锚点。\n\n2.  **结构评分：** 对于每个反密码子起始位置 $i \\in \\mathrm{Ind}(x)$，预测器搜索一个潜在的茎环结构。它会遍历在序列 $x$ 内几何上可能的所有有效环长 $l' \\in [l_{\\min}, l_{\\max}]$ 和臂长 $p' \\ge p_{\\min}$ 的组合。\n    - 对于每个有效的三元组 $(i, l', p')$，它定义一个假定的左臂片段 $L(i,p')=x[i-p':i]$ 和一个右臂片段 $R(i,l',p')=x[i+l':i+l'+p']$。\n    - 它首先检查GC含量约束。这两个片段的组合GC分数 $\\mathrm{GC}(i,l',p')$ 必须落在预测器的范围 $[g^{\\mathrm{pred}}_{\\min}, g^{\\mathrm{pred}}_{\\max}]$ 内。如果不满足，则丢弃此三元组。\n    - 如果满足GC约束，它会计算一个配对分数 $M(i,l',p')$，这是反转的左臂片段和右臂片段之间的沃森-克里克互补碱基对的数量。\n    - 预测器找到在所有锚点 $i \\in \\mathrm{Ind}(x)$ 上、所有有效三元组 $(i,l',p')$ 中实现的最大分数 $M_{\\max}$。如果不存在这样的有效三元组，则此最大值定义为0。\n\n3.  **预测与FPR：** 序列 $x$ 的最终分数为 $S_{\\max}(x) = M_{\\max} + I(x)$。当且仅当 $S_{\\max}(x) \\ge T$ 时，该序列被分类为“预测为tRNA”（阳性预测）。\n\n然后，为整个诱饵集 $\\mathcal{D}$ 计算假阳性率（FPR），即产生阳性预测的诱饵序列所占的比例：\n$$\n\\mathrm{FPR} = \\frac{\\#\\{x \\in \\mathcal{D} : \\text{预测器将 } x \\text{ 分类为阳性}\\}}{|\\mathcal{D}|}\n$$\n对每个测试用例重复此过程，以获得所需的FPR值。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the tRNA decoy analysis problem for a suite of test cases.\n    It constructs decoy sequences and evaluates a predictor's false positive rate.\n    \"\"\"\n\n    # --- Helper Data and Functions ---\n    COMPLEMENT = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n    def get_reverse_complement(seq: str) - str:\n        \"\"\"Computes the reverse Watson-Crick complement of a DNA sequence.\"\"\"\n        return \"\".join(COMPLEMENT.get(base, 'N') for base in reversed(seq))\n\n    def get_gc_content(seq: str) - float:\n        \"\"\"Calculates the GC content of a DNA sequence.\"\"\"\n        if not seq:\n            return 0.0\n        gc_count = seq.count('G') + seq.count('C')\n        return gc_count / len(seq)\n\n    # --- Part 1: Decoy Generation ---\n    def generate_decoys(L: int, p: int, l: int, S_codons: list[str], g_min: float, g_max: float) - list[str]:\n        \"\"\"\n        Generates a set of decoy tRNA-like sequences based on specified parameters.\n        \"\"\"\n        # 1. Select 2-mers for arms\n        bases = ['A', 'C', 'G', 'T']\n        all_2mers = sorted([b1 + b2 for b1 in bases for b2 in bases])\n        \n        valid_2mers_gc = []\n        for dimer in all_2mers:\n            gc_frac = get_gc_content(dimer)\n            if g_min = gc_frac = g_max:\n                valid_2mers_gc.append((gc_frac, dimer))\n\n        # Variant A (min-GC): min GC, then lexicographically smallest\n        min_gc_dimer = min(valid_2mers_gc, key=lambda x: (x[0], x[1]))[1]\n        \n        # Variant B (max-GC): max GC, then lexicographically largest\n        max_gc_val = max(gc for gc, dimer in valid_2mers_gc)\n        max_gc_candidates = [dimer for gc, dimer in valid_2mers_gc if gc == max_gc_val]\n        max_gc_dimer = max(max_gc_candidates)\n\n        # 2. Construct base arms\n        repeats = math.ceil(p / 2)\n        min_arm_base = (min_gc_dimer * repeats)[:p]\n        max_arm_base = (max_gc_dimer * repeats)[:p]\n        \n        decoys = []\n        \n        # 3. Assemble decoys for each anticodon\n        core_len = 2 * p + l\n        pad_total = L - core_len\n        a = math.floor(pad_total / 2)\n        b = pad_total - a\n        padding_left = 'T' * a\n        padding_right = 'T' * b\n        \n        s = math.floor((l - 3) / 2)\n        \n        for t in S_codons:\n            loop_list = ['A'] * l\n            loop_list[s:s+3] = list(t)\n            loop = \"\".join(loop_list)\n            \n            # Variant A (min-GC)\n            left_arm_A = min_arm_base\n            right_arm_A = get_reverse_complement(left_arm_A)\n            decoy_A = padding_left + left_arm_A + loop + right_arm_A + padding_right\n            decoys.append(decoy_A)\n            \n            # Variant B (max-GC)\n            left_arm_B = max_arm_base\n            right_arm_B = get_reverse_complement(left_arm_B)\n            decoy_B = padding_left + left_arm_B + loop + right_arm_B + padding_right\n            decoys.append(decoy_B)\n            \n        return decoys\n\n    # --- Part 2: Predictor ---\n    def run_predictor(x: str, p_min: int, l_min: int, l_max: int, g_pred_min: float, g_pred_max: float, T: int, S_codons_set: set[str]) - bool:\n        \"\"\"\n        Applies the simplified tRNA predictor to a sequence.\n        \"\"\"\n        n = len(x)\n        \n        # Find all starting indices of anticodons in the sequence\n        ind_x = [i for i in range(n - 2) if x[i:i+3] in S_codons_set]\n        I_x = 1 if ind_x else 0\n        \n        max_M = 0\n        \n        if not ind_x:\n            # S_max = (max over empty set) + I(x) = 0 + 0 = 0\n            return 0 = T\n\n        # For each anticodon found, search for the best stem-loop structure\n        for i in ind_x:\n            for l_prime in range(l_min, l_max + 1):\n                # Max possible arm length p' for this (i, l')\n                max_p_prime = min(i, n - (i + l_prime))\n                if p_min  max_p_prime:\n                    continue\n\n                for p_prime in range(p_min, max_p_prime + 1):\n                    L_seg = x[i - p_prime : i]\n                    R_seg = x[i + l_prime : i + l_prime + p_prime]\n                    \n                    # Check GC constraint\n                    gc_count = L_seg.count('G') + L_seg.count('C') + R_seg.count('G') + R_seg.count('C')\n                    if p_prime == 0: continue\n                    gc_frac = gc_count / (2 * p_prime)\n                    \n                    if g_pred_min = gc_frac = g_pred_max:\n                        L_seg_rev = L_seg[::-1]\n                        M = sum(1 for c1, c2 in zip(L_seg_rev, R_seg) if COMPLEMENT.get(c1) == c2)\n                        \n                        if M  max_M:\n                            max_M = M\n                            \n        S_max = max_M + I_x\n        return S_max = T\n\n\n    # --- Main Execution ---\n    test_cases = [\n        # Test case 1\n        {\n            \"gen\": {\"L\": 50, \"p\": 6, \"l\": 7, \"S_codons\": [\"GAA\", \"TGC\", \"CCA\"], \"g_min\": 0.5, \"g_max\": 1.0},\n            \"pred\": {\"p_min\": 5, \"l_min\": 5, \"l_max\": 9, \"g_pred_min\": 0.4, \"g_pred_max\": 1.0, \"T\": 7}\n        },\n        # Test case 2\n        {\n            \"gen\": {\"L\": 30, \"p\": 4, \"l\": 5, \"S_codons\": [\"AAA\"], \"g_min\": 0.0, \"g_max\": 1.0},\n            \"pred\": {\"p_min\": 5, \"l_min\": 4, \"l_max\": 7, \"g_pred_min\": 0.0, \"g_pred_max\": 1.0, \"T\": 3}\n        },\n        # Test case 3\n        {\n            \"gen\": {\"L\": 42, \"p\": 7, \"l\": 6, \"S_codons\": [\"GCT\", \"CAT\"], \"g_min\": 0.0, \"g_max\": 1.0},\n            \"pred\": {\"p_min\": 6, \"l_min\": 6, \"l_max\": 6, \"g_pred_min\": 0.0, \"g_pred_max\": 0.6, \"T\": 8}\n        }\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        gen_params = case[\"gen\"]\n        pred_params = case[\"pred\"]\n        \n        decoys = generate_decoys(gen_params[\"L\"], gen_params[\"p\"], gen_params[\"l\"],\n                                 gen_params[\"S_codons\"], gen_params[\"g_min\"], gen_params[\"g_max\"])\n        \n        S_codons_set = set(gen_params[\"S_codons\"])\n        \n        false_positives = 0\n        for decoy in decoys:\n            if run_predictor(decoy, pred_params[\"p_min\"], pred_params[\"l_min\"], pred_params[\"l_max\"],\n                             pred_params[\"g_pred_min\"], pred_params[\"g_pred_max\"],\n                             pred_params[\"T\"], S_codons_set):\n                false_positives += 1\n                \n        if not decoys:\n             fpr = 0.0\n        else:\n             fpr = false_positives / len(decoys)\n        \n        results.append(f\"{fpr:.3f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "大自然经常会呈现出挑战我们标准模型的例外情况。这个高级实践将向您介绍这样一种情况：重排 tRNA 基因，其基因的两半在基因组中被重新排列。您需要创造性地调整 tRNA 结构检测的基本原理，开发一种能够通过计算“重新组装”来识别这些非典型基因的算法，这突显了在生物信息学研究中采用灵活和创新方法的重要性 。",
            "id": "2438454",
            "problem": "要求您仅使用序列层面信息，来形式化并实现一个用于检测置换转移RNA（tRNA）基因的检测器。在一些古菌和少数细菌中，置换tRNA基因的编码方式是，其$3^{\\prime}$半部分在基因组中位于$5^{\\prime}$半部分之前，两个半部分由一个短连接子分隔。经过转录和加工后，这两个半部分被重新排序，生成一个标准的tRNA，并折叠成特征性的三叶草二级结构。您必须设计一种方法，在给定一个DNA序列的情况下，根据一个简化的、有原则的模型，判断该序列是更符合一个置换tRNA基因，还是更符合一个典型（非置换）tRNA基因。\n\n从以下基本原理和经过充分检验的事实出发：\n- 分子生物学中心法则指出，DNA被转录成RNA，RNA可以通过碱基配对折叠形成功能性结构；tRNA是一种结构化RNA，具有保守的臂和环。\n- 核酸中的沃森-克里克碱基配对规则是：在DNA中腺嘌呤与胸腺嘧啶配对（在RNA中腺嘌呤与尿嘧啶配对），胞嘧啶与鸟嘌呤配对。此处我们仅限于DNA，其经典配对为：A–T和C–G。\n- 在标准tRNA中，接受臂由$5^{\\prime}$和$3^{\\prime}$末端之间的碱基配对形成，通常包含约$7$个连续的经典碱基对。反密码子臂通常包含约$5$个碱基对，位于反密码子环的两侧。\n\n您将使用这些事实，基于以下简化的数学模型，构建一个检测算法：\n- 一个长度为$n$、基于字母表$\\{A,C,G,T\\}$的DNA序列$s$被称为类tRNA（tRNA-like），当且仅当同时满足两个条件。\n  1. 接受臂条件：存在非负整数$t$和$u$（满足$0 \\le t \\le g$，$0 \\le u \\le g$）以及一个整数$k_{\\mathrm{acc}}$，使得$k_{\\mathrm{acc}}$-聚体前缀$s[t \\dots t + k_{\\mathrm{acc}} - 1]$和$k_{\\mathrm{acc}}$-聚体后缀$s[n - u - k_{\\mathrm{acc}} \\dots n - u - 1]$在反向平行排列时，可以形成至少$k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$个沃森-克里克碱基对。形式上，令$\\operatorname{wc}(x,y)$在$x$和$y$是沃森-克里克互补碱基时为$1$，否则为$0$。分数\n  $$ S_{\\mathrm{acc}}(s,t,u) = \\sum_{i=0}^{k_{\\mathrm{acc}}-1} \\operatorname{wc}\\!\\Big(s[t+i],\\, s[n - u - 1 - i]\\Big) $$\n  必须对于在界限内的某组$t$和$u$满足$S_{\\mathrm{acc}}(s,t,u) \\ge k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$。\n  2. 反密码子臂条件：存在整数$i$和$\\ell$（满足$0 \\le i$，$\\, \\ell_{\\min} \\le \\ell \\le \\ell_{\\max}$，以及$i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} \\le n$），使得两个$k_{\\mathrm{anti}}$-聚体$s[i \\dots i + k_{\\mathrm{anti}} - 1]$和$s[i + k_{\\mathrm{anti}} + \\ell \\dots i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} - 1]$在反向平行排列时，形成至少$k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$个沃森-克里克碱基对。其相应分数为\n  $$ S_{\\mathrm{anti}}(s,i,\\ell) = \\sum_{j=0}^{k_{\\mathrm{anti}}-1} \\operatorname{wc}\\!\\Big(s[i+j],\\, s[i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} - 1 - j]\\Big), $$\n  该分数必须对于在界限内的某组$i$和$\\ell$满足$S_{\\mathrm{anti}}(s,i,\\ell) \\ge k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$。\n- 序列$s$旋转$p$个位置，记作$R_p(s)$，是指对于任意整数$p$（$0 \\le p  n$），其序列为$s[p] s[p+1] \\dots s[n-1] s[0] s[1] \\dots s[p-1]$。\n- 一个DNA序列$s$被判定为置换tRNA基因，当且仅当存在一个旋转$R_p(s)$（$1 \\le p \\le n-1$），在上述模型下是类tRNA的，而未旋转的序列$R_0(s)=s$不是类tRNA的。这体现了这样一个概念：环状置换的顺序揭示了一个标准的类tRNA结构，而给定的原始顺序则没有。\n\n使用以下固定参数值\n- $k_{\\mathrm{acc}} = 7$, $m_{\\mathrm{acc}} = 1$，以及修剪边界$g = 2$，\n- $k_{\\mathrm{anti}} = 5$, $m_{\\mathrm{anti}} = 1$，以及反密码子环边界$\\ell_{\\min} = 5$和$\\ell_{\\max} = 9$。\n此外，只有长度$n$满足$35 \\le n \\le 100$的序列才有资格进行类tRNA评估；超出此范围的序列应被分类为非置换。\n\n您的任务\n- 实现一个程序，对于每个提供的测试序列，根据上述模型和参数，输出一个布尔值，指示该序列是否为置换tRNA基因。\n- 必须仅使用经典配对A–T和C–G的DNA沃森-克里克互补规则。\n- 该算法必须具有通用性，且不得依赖于任何特定测试序列的硬编码坐标。\n\n测试套件\n在以下$5$个DNA序列（由A、C、G、T组成的字符串）上评估您的程序。这些序列是为检验决策逻辑而特意构建的。\n\n1. S1: GCGATTCTTTAGCAAGGTGTCATGAACCTTCCGTTTGAATCGC\n2. S2: CATGAACCTTCCGTTTGAATCGCATGCGATTCTTTAGCAAGGTGT\n3. S3: ACGTCGATGACAGTCAGTACGATCGATCGTACGAGTCTAAGCTAGTC\n4. S4: ACGTACGTACGT\n5. S5: CATGAACCTTCCGTTTGAATCGTATGCGATTCTTTAGCAAGGTGT\n\n解释说明\n- S1是此模型下的一个典型类tRNA结构。\n- S2和S5是一个类tRNA结构的环状置换变体，由一个长度为$2$的短连接子分隔，其中S5相对于理想情况，在接受臂配对中还包含一个错配。\n- S3是一个通用的非类tRNA序列。\n- S4因长度太短而不予考虑。\n\n最终输出格式\n您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表。例如，三个案例的输出可能看起来像[True,False,True]。请对上述五个序列按顺序应用此确切格式，生成一个长度为$5$的列表。",
            "solution": "问题陈述已经过严格验证。它在科学上基于分子生物学的原理，特别是转移RNA（tRNA）的结构和基因组织。所提供的模型是一个简化但数学上精确且定义明确的抽象，适合算法实现。所有参数和约束都已明确定义，使得问题自成体系，没有矛盾或歧义。因此，不仅可能，而且必须给出一个形式化的解决方案。\n\n任务是实现一个分类器，用于确定给定的DNA序列$s$是否代表一个置换tRNA基因。根据所提供的模型，一个序列$s$被分类为置换tRNA，当且仅当：\n$1$. 其长度$n$在闭区间$[35, 100]$内。\n$2$. 原始序列$s = R_0(s)$不是“类tRNA”的。\n$3$. 存在至少一个非平凡的环状置换$R_p(s)$（其中$p \\in \\{1, \\dots, n-1\\}$）是“类tRNA”的。\n\n因此，问题的核心是构建一个函数，用以测试任意序列是否为“类tRNA”的。一个序列被定义为类tRNA，如果它同时满足两个结构条件：接受臂条件和反密码子臂条件。因此，解决方案以模块化、层次化的方式设计。\n\n首先，我们定义一个布尔函数$\\operatorname{wc}(b_1, b_2)$，如果碱基$b_1, b_2 \\in \\{ \\text{A, C, G, T} \\}$构成一个经典的沃森-克里克配对（A-T或C-G），则返回$1$，否则返回$0$。\n\n接下来，我们形式化接受臂条件的算法。一个长度为$n$的序列$s$满足此条件，如果存在整数$t$和$u$（$0 \\le t \\le g$且$0 \\le u \\le g$），使得分数$S_{\\mathrm{acc}}(s,t,u) \\ge k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$。参数是固定的：接受臂长度$k_{\\mathrm{acc}}=7$，最大错配数$m_{\\mathrm{acc}}=1$，以及最大末端修剪长度$g=2$。因此，所需的分数阈值为$7-1=6$。算法必须系统地检查搜索空间$\\{0, 1, 2\\} \\times \\{0, 1, 2\\}$中所有可能的$(t,u)$对。对于每一对，计算其分数：\n$$ S_{\\mathrm{acc}}(s,t,u) = \\sum_{i=0}^{k_{\\mathrm{acc}}-1} \\operatorname{wc}\\!\\Big(s[t+i],\\, s[n - u - 1 - i]\\Big) $$\n如果任何一对$(t,u)$产生的分数至少为$6$，则该条件满足。\n\n然后，我们形式化反密码子臂条件的算法。一个序列$s$满足此条件，如果存在整数$i$和$\\ell$（满足$0 \\le i$，$\\ell_{\\min} \\le \\ell \\le \\ell_{\\max}$，以及$i + 2k_{\\mathrm{anti}} + \\ell \\le n$），使得分数$S_{\\mathrm{anti}}(s,i,\\ell) \\ge k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$。参数是固定的：反密码子臂长度$k_{\\mathrm{anti}}=5$，最大错配数$m_{\\mathrm{anti}}=1$，以及环长度边界$\\ell_{\\min}=5, \\ell_{\\max}=9$。所需的分数阈值为$5-1=4$。算法必须执行嵌套搜索。外层循环遍历可能的环长度$\\ell \\in \\{5, 6, 7, 8, 9\\}$。内层循环遍历臂环结构所有可能的起始位置$i$，从$i=0$到最大可能值$n - (2k_{\\mathrm{anti}} + \\ell)$。对于每一对$(i, \\ell)$，计算其分数：\n$$ S_{\\mathrm{anti}}(s,i,\\ell) = \\sum_{j=0}^{k_{\\mathrm{anti}}-1} \\operatorname{wc}\\!\\Big(s[i+j],\\, s[i + 2k_{\\mathrm{anti}} + \\ell - 1 - j]\\Big) $$\n如果任何一对$(i, \\ell)$产生的分数至少为$4$，则该条件满足。\n\n有了这两个组件函数，我们定义一个函数`is_tRNA_like(seq)`。当且仅当`seq`同时满足接受臂和反密码子臂条件时，该函数返回真。\n\n最后，对于给定的长度为$n$的序列$s$，主分类算法如下：\n$1$。检查$35 \\le n \\le 100$是否成立。如果不成立，该序列立即被分类为非置换tRNA，结果为假。\n$2$。评估`is_tRNA_like(s)`。如果为真，根据定义，该序列是一个典型的类tRNA结构，而不是置换tRNA。结果为假。\n$3$。对于从$1$到$n-1$的每个$p$，通过创建$R_p(s) = s[p:]s[:p]$来遍历所有非平凡的环状置换。对每个置换后的序列$R_p(s)$，评估`is_tRNA_like(R_p(s))`。\n$4$。如果对于任何$p$，此评估为真，则意味着置换后揭示了一个类tRNA结构。序列$s$被分类为置换tRNA基因，结果为真。搜索可以终止。\n$5$。如果循环完成仍未找到任何这样的置换，则该序列不是置换tRNA基因，结果为假。\n\n这种对形式模型的系统性应用，为所述问题提供了一个确定性的、符合科学原理的解决方案。实现将由一组直接反映此逻辑结构的函数组成。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the permuted tRNA gene detection problem based on the provided formal model.\n    \"\"\"\n\n    def wc_pair(b1, b2):\n        \"\"\"Checks for Watson-Crick base pairing (A-T, C-G).\"\"\"\n        pairs = {('A', 'T'), ('T', 'A'), ('C', 'G'), ('G', 'C')}\n        return (b1, b2) in pairs\n\n    def has_acceptor_stem(seq, k_acc, m_acc, g):\n        \"\"\"\n        Checks for the presence of a valid acceptor stem according to the model.\n        A score of at least k_acc - m_acc is required for some t, u in [0, g].\n        \"\"\"\n        n = len(seq)\n        threshold = k_acc - m_acc\n        if n  k_acc: \n            return False\n\n        for t in range(g + 1):\n            for u in range(g + 1):\n                # Ensure substrings are within bounds\n                if t + k_acc  n or n - u - k_acc  0:\n                    continue\n                \n                score = 0\n                for i in range(k_acc):\n                    base1 = seq[t + i]\n                    base2 = seq[n - u - 1 - i]\n                    if wc_pair(base1, base2):\n                        score += 1\n                \n                if score = threshold:\n                    return True\n        return False\n\n    def has_anticodon_stem(seq, k_anti, m_anti, l_min, l_max):\n        \"\"\"\n        Checks for the presence of a valid anticodon stem according to the model.\n        A score of at least k_anti - m_anti is required for some i and l.\n        \"\"\"\n        n = len(seq)\n        threshold = k_anti - m_anti\n\n        for l in range(l_min, l_max + 1):\n            structure_len = 2 * k_anti + l\n            if n  structure_len:\n                continue\n            \n            max_i = n - structure_len\n            for i in range(max_i + 1):\n                score = 0\n                for j in range(k_anti):\n                    base1 = seq[i + j]\n                    base2 = seq[i + structure_len - 1 - j]\n                    if wc_pair(base1, base2):\n                        score += 1\n                \n                if score = threshold:\n                    return True\n        return False\n\n    def is_tRNA_like(seq, params):\n        \"\"\"\n        Checks if a sequence is tRNA-like, meaning it satisfies both the\n        acceptor stem and anticodon stem conditions.\n        \"\"\"\n        # Unpack parameters from the dictionary\n        k_acc, m_acc, g = params['acceptor']\n        k_anti, m_anti, l_min, l_max = params['anticodon']\n\n        # Both conditions must hold simultaneously\n        return (has_acceptor_stem(seq, k_acc, m_acc, g) and\n                has_anticodon_stem(seq, k_anti, m_anti, l_min, l_max))\n\n    def is_permuted_tRNA(s, params):\n        \"\"\"\n        Determines if a sequence 's' is a permuted tRNA gene. This is true iff\n        's' is not tRNA-like, but at least one of its circular permutations is.\n        \"\"\"\n        n = len(s)\n        min_len, max_len = params['length_bounds']\n\n        if not (min_len = n = max_len):\n            return False\n\n        # The unrotated sequence must NOT be tRNA-like\n        if is_tRNA_like(s, params):\n            return False\n\n        # At least one non-trivial rotation must be tRNA-like\n        for p in range(1, n):\n            rotated_s = s[p:] + s[:p]\n            if is_tRNA_like(rotated_s, params):\n                return True\n        \n        return False\n\n    # Define all model parameters from the problem statement in a dictionary\n    params = {\n        'acceptor': (7, 1, 2),          # (k_acc, m_acc, g)\n        'anticodon': (5, 1, 5, 9),      # (k_anti, m_anti, l_min, l_max)\n        'length_bounds': (35, 100)\n    }\n\n    # The test suite provided in the problem statement\n    test_cases = [\n        \"GCGATTCTTTAGCAAGGTGTCATGAACCTTCCGTTTGAATCGC\",      # S1\n        \"CATGAACCTTCCGTTTGAATCGCATGCGATTCTTTAGCAAGGTGT\",      # S2\n        \"ACGTCGATGACAGTCAGTACGATCGATCGTACGAGTCTAAGCTAGTC\",  # S3\n        \"ACGTACGTACGT\",                                     # S4\n        \"CATGAACCTTCCGTTTGAATCGTATGCGATTCTTTAGCAAGGTGT\"       # S5\n    ]\n\n    results = []\n    for s in test_cases:\n        # Apply the classification logic to each test case\n        result = is_permuted_tRNA(s, params)\n        results.append(result)\n\n    # Format the final output as a single-line string: `[bool1,bool2,...]`\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}