{
    "hands_on_practices": [
        {
            "introduction": "在规划任何下一代测序（NGS）项目时，一个至关重要的第一步是估算所需资源，特别是数据存储。这个练习提供了一种实用的方法，将覆盖深度、读长和基因组大小等实验参数，转化为具体的、可量化的数据文件大小。通过这个计算，您可以更好地理解测序项目在计算基础设施方面的实际需求。",
            "id": "2417496",
            "problem": "一项全基因组测序实验使用150碱基对的双末端读段，在一个能以FASTQ（Fast All-in-one Sequence with Quality）文本格式输出原始读段的平台上，对大小为$3.2\\times 10^{9}$碱基对的单倍体人类基因组进行$30\\times$深度的测序。假设如下：\n\n- 覆盖深度定义为测序总碱基数除以单倍体基因组大小。\n- 每个读段长度为$L=150$个碱基，并以一个四行的FASTQ记录表示：一个以字符$@$开头的标题行；一个包含$L$个核苷酸字符的序列行；一个以字符$+$开头且不含额外注释的加号行；以及一个包含$L$个美国信息交换标准代码（ASCII）字符的质量行，用于编码每个碱基的质量得分。\n- 所有字符均为单字节ASCII，每行以一个1字节的换行符结尾。\n- 每个读段的标题行在换行符前恰好包含$40$个ASCII字符（包括初始的$@$）。\n- FASTQ文件是未压缩的。\n- 使用千兆字节的十进制定义，其中$1$千兆字节 = $10^{9}$字节。\n\n估算整个实验生成的总数据量（以千兆字节为单位）。将您的答案四舍五入到三位有效数字，并以千兆字节表示。",
            "solution": "该问题已经过验证。\n\n从问题陈述中逐字提取的已知条件：\n- 单倍体人类基因组大小：$G = 3.2 \\times 10^9$ 碱基对\n- 目标覆盖深度：$C = 30\\times$\n- 读段长度：$L = 150$ 碱基对\n- 读段类型：双末端\n- 输出格式：FASTQ\n- FASTQ记录结构：\n    - 标题行：$40$个字符（包括$@$） + $1$个换行符\n    - 序列行：$L$个字符 + $1$个换行符\n    - 加号行：$1$个字符（$+$） + $1$个换行符\n    - 质量行：$L$个字符 + $1$个换行符\n- 字符编码：单字节ASCII\n- 行终止符：$1$字节换行符\n- 文件格式：未压缩\n- 单位转换：$1$千兆字节 = $10^9$字节\n- 要求精度：将最终答案四舍五入到三位有效数字\n\n验证结论：\n该问题具有科学依据、提法得当且客观。它描述了一个用于全基因组测序的标准生物信息学场景。所提供的参数，如基因组大小（$G$）、覆盖深度（$C$）和读段长度（$L$），是人类测序项目的实际取值。对FASTQ格式的描述准确且足以进行计算。该问题是自洽的、一致的，并且需要一个直接、可形式化的计算。因此，该问题被视为有效，并将提供解决方案。\n\n目标是计算测序实验生成的总数据量（以千兆字节为单位）。\n\n首先，我们计算测序的总碱基数，记为$B_{total}$。它由基因组大小$G = 3.2 \\times 10^9$碱基对和覆盖深度$C = 30$的乘积给出。\n$$B_{total} = G \\times C$$\n代入给定值：\n$$B_{total} = (3.2 \\times 10^9) \\times 30 = 9.6 \\times 10^{10} \\text{ bases}$$\n\n接下来，我们确定单个读段的总数，$N_{reads}$。由于每个读段的长度为$L = 150$个碱基，因此读段总数是测序的总碱基数除以单个读段的长度。\n$$N_{reads} = \\frac{B_{total}}{L}$$\n代入$B_{total}$和$L$的值：\n$$N_{reads} = \\frac{9.6 \\times 10^{10}}{150} = \\frac{96 \\times 10^9}{150} = 0.64 \\times 10^9 = 6.4 \\times 10^8 \\text{ reads}$$\n每个读段对应一个FASTQ记录。因此，总共有$6.4 \\times 10^8$个FASTQ记录。\n\n现在，我们计算单个FASTQ记录的大小$S_{read}$（以字节为单位）。问题指明所有字符都是单字节ASCII（每个字符$1$字节），并且每行都以一个$1$字节的换行符结尾。FASTQ记录由$4$行组成：\n1.  标题行：该行在换行符前包含$40$个字符。总大小为$40$字节 + $1$字节 = $41$字节。\n2.  序列行：该行包含$L = 150$个核苷酸字符。总大小为$150$字节 + $1$字节 = $151$字节。\n3.  加号行：该行包含单个字符`$+$`。总大小为$1$字节 + $1$字节 = $2$字节。\n4.  质量行：该行包含$L = 150$个质量得分字符。总大小为$150$字节 + $1$字节 = $151$字节。\n\n一个FASTQ记录的总大小是这四行大小的总和：\n$$S_{read} = 41 + 151 + 2 + 151 = 345 \\text{ bytes}$$\n\n生成的总数据量$S_{total}$是读段总数$N_{reads}$与单个读段记录大小$S_{read}$的乘积。\n$$S_{total} = N_{reads} \\times S_{read}$$\n代入计算出的值：\n$$S_{total} = (6.4 \\times 10^8) \\times 345 = 2208 \\times 10^8 = 2.208 \\times 10^{11} \\text{ bytes}$$\n\n最后，我们使用给定的转换因子$1 \\text{ GB} = 10^9$字节，将总大小从字节转换为千兆字节（GB）。\n$$S_{total, \\text{GB}} = \\frac{S_{total}}{10^9} = \\frac{2.208 \\times 10^{11}}{10^9} = 2.208 \\times 10^2 = 220.8 \\text{ GB}$$\n\n问题要求将答案四舍五入到三位有效数字。数值$220.8$四舍五入到三位有效数字是$221$。",
            "answer": "$$\\boxed{221}$$"
        },
        {
            "introduction": "为了提高成本效益，研究人员通常会将多个样本混合在一起进行测序，这一过程称为“多重测序”（multiplexing）。这需要为每个样本贴上独特的DNA“条形码”（barcode），以便在分析时将其区分开。本练习将深入探讨设计这些条形码的关键原则，特别是如何利用编码理论来确保即使在出现测序错误时，样本也不会被混淆。",
            "id": "2417498",
            "problem": "你的任务是在替换错误模型下，为多重下一代测序 (NGS) 的数据解复用构建条形码集。设核苷酸字母表为有限集 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，其中 $\\lvert \\Sigma \\rvert = 4$。对于一个整数长度 $L \\ge 1$，一个条形码是任何字符串 $x \\in \\Sigma^{L}$。对于两个条形码 $x,y \\in \\Sigma^{L}$，它们的汉明距离定义为\n$$\nH(x,y) = \\lvert \\{ i \\in \\{1,\\dots,L\\} \\,:\\, x_i \\ne y_i \\} \\rvert.\n$$\n一个大小为 $\\lvert S \\rvert = N$ 的条形码集 $S \\subseteq \\Sigma^{L}$ 具有最小距离\n$$\n\\delta(S) = \\min_{\\substack{x,y \\in S \\\\ x \\ne y}} H(x,y).\n$$\n给定整数 $L$、$N$ 和 $d$，一个有效的集合必须满足 $\\delta(S) \\ge d$。在解复用过程中的单碱基替换错误模型下，至少为 $d=3$ 的最小汉明距离足以容忍每个读长（read）中出现一次替换错误。\n\n对于下面测试套件中的每个测试用例 $(L,N,d)$，构建任意一个满足 $\\delta(S) \\ge d$ 的条形码集 $S \\subseteq \\Sigma^{L}$，并报告在约束 $\\lvert S \\rvert \\le N$ 下实际达到的整数大小 $\\lvert S \\rvert$。如果没有一对不同的条形码能满足所需的距离，若 $N \\ge 1$，你可以输出 $\\lvert S \\rvert = 1$（因为单元素集没有违规对），若 $N=0$，则输出 $\\lvert S \\rvert = 0$。\n\n测试套件：\n- 案例 A（与 NGS 解复用相关的正常路径）：$(L,N,d) = (10,8,3)$。\n- 案例 B（紧凑的小实例可行性）：$(L,N,d) = (2,4,2)$。\n- 案例 C（字母表限制的边界情况）：$(L,N,d) = (1,5,1)$。\n- 案例 D（低于字母表容量的大型可行请求）：$(L,N,d) = (3,20,1)$。\n- 案例 E（距离超过长度；重要的边缘情况）：$(L,N,d) = (3,2,4)$。\n\n你的程序必须为每个案例计算如上定义的整数 $\\lvert S \\rvert$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[a,b,c,d,e]”）。结果必须按照测试套件案例 A 到 E 的顺序排列，且每个结果都必须是一个整数。",
            "solution": "所陈述的问题在科学上是合理的、提法得当且内部一致。它解决了下一代测序 (NGS) 实验设计中的一个基本任务：为样本多重化构建条形码集。核苷酸字母表 $\\Sigma$、长度为 $L$ 的字符串形式的条形码、汉明距离 $H(x,y)$ 以及集合的最小距离 $\\delta(S)$ 等概念，在编码理论及其在生物信息学中的应用中都是标准概念。该问题是有效的，并允许采用直接的构造性解法。\n\n任务是为给定的参数 $(L, N, d)$ 构建一个条形码集 $S \\subseteq \\Sigma^L$，其中 $L$ 是条形码长度，$d$ 是要求的最小汉明距离，$N$ 是期望的集合最大大小。我们需要报告所构建集合的实际大小 $\\lvert S \\rvert$，其中 $\\lvert S \\rvert \\le N$。问题允许构建*任何*这样的集合。这为我们采用确定性的贪心算法提供了自由度。\n\n提出的算法如下：\n1. 为条形码初始化一个空集 $S = \\emptyset$。字母表为 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$，我们可以用数字 $\\{0, 1, 2, 3\\}$ 来表示。\n2. 系统地生成所有长度为 $L$ 的可能条形码。共有 $4^L$ 个这样的条形码。固定的字典序生成方式可确保可复现性。\n3. 对于每个候选条形码 $x$，检查它是否可以被添加到集合 $S$ 中。如果满足以下两个条件，则可以添加：\n    a. 集合的当前大小小于目标大小，即 $\\lvert S \\rvert  N$。\n    b. $x$ 与 $S$ 中已有的每个条形码 $y$ 的汉明距离至少为 $d$，即对于所有 $y \\in S$，都有 $H(x,y) \\ge d$。\n4. 如果两个条件都满足，则将 $x$ 添加到 $S$ 中。\n5. 持续此过程，直到集合 $S$ 达到大小 $N$ 或所有 $4^L$ 个潜在的条形码都已被评估。\n6. 对于给定的 $(L, N, d)$，最终的大小 $\\lvert S \\rvert$ 即为结果。\n\n这种贪心策略保证能生成一个满足指定标准的有效集合。在整个构建过程中，显式约束 $\\lvert S \\rvert \\le N$ 始终得到遵守。\n\n对特定约束和测试用例的分析：\n- 对于任何 $N=0$ 的测试用例，唯一可能的集合是空集，因此 $\\lvert S \\rvert = 0$。\n- 对于最小距离 $d$ 大于条形码长度 $L$ 的情况（例如，案例 E $(L,N,d) = (3,2,4)$），不可能找到两个不同的条形码 $x, y$ 满足 $H(x,y) \\ge d$，因为可能的最大汉明距离是 $L$。问题陈述正确地为此场景提供了规则：如果 $N \\ge 1$，大小为 $\\lvert S \\rvert=1$ 的集合是一个有效的输出，因为单元素集没有不同元素的配对，因此空泛地满足任何最小距离条件。我们的贪心算法会自然地处理这种情况，即添加第一个有效的条形码，然后无法再添加任何其他条形码。由于在检查 $N=0$ 之后的所有此类测试用例中都有 $N \\ge 1$，结果将是 $1$。\n- 对于最小距离为 $d=1$ 的情况（例如，案例 C 和 D），条件 $H(x,y) \\ge 1$ 仅仅要求集合中的所有条形码都是不同的。问题于是简化为从 $4^L$ 个可用条形码的总池中选择最多 $N$ 个不同的条形码。因此，这种集合的最大大小是 $\\min(N, 4^L)$。\n- 对于案例 C，$(L,N,d) = (1,5,1)$，条形码总数为 $4^1 = 4$。期望的大小是 $N=5$。因此，最大可实现的大小是 $\\min(5, 4) = 4$。\n- 对于案例 D，$(L,N,d) = (3,20,1)$，条形码总数为 $4^3 = 64$。期望的大小是 $N=20$。最大可实现的大小是 $\\min(20, 64) = 20$。\n\n该实现将使用 NumPy 整数数组来表示条形码。所有可能的条形码的生成将由 `itertools.product` 处理，而汉明距离的计算则通过 NumPy 中的逐向量比较和求和来高效地执行。该算法将应用于每个测试用例，以生成最终的结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Constructs barcode sets for given parameters and reports their sizes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (L, N, d) where:\n    # L: barcode length\n    # N: maximum desired set size\n    # d: minimum Hamming distance\n    test_cases = [\n        (10, 8, 3),   # Case A: Standard NGS application\n        (2, 4, 2),    # Case B: Small, tight instance\n        (1, 5, 1),    # Case C: Alphabet-limited case\n        (3, 20, 1),   # Case D: Large feasible request\n        (3, 2, 4),    # Case E: Impossible distance requirement\n    ]\n\n    results = []\n    \n    # Process each test case\n    for L, N, d in test_cases:\n        # If the maximum desired size is 0, the set must be empty.\n        if N == 0:\n            results.append(0)\n            continue\n\n        # If the required minimum distance d is greater than the barcode length L,\n        # no two distinct barcodes can satisfy the condition.\n        # As per the problem, if N = 1, a set of size 1 is a valid result.\n        if d  L:\n            results.append(1)\n            continue\n\n        # Use a greedy algorithm to construct the barcode set.\n        barcode_set = []\n        \n        # The alphabet size is 4 (e.g., {A, C, G, T}).\n        # We represent nucleotides as integers {0, 1, 2, 3}.\n        alphabet_size = 4\n        \n        # Create an iterator that generates all possible barcodes of length L.\n        all_barcodes_iter = itertools.product(range(alphabet_size), repeat=L)\n\n        for bc_tuple in all_barcodes_iter:\n            # Stop if the set has reached the desired size N.\n            if len(barcode_set) == N:\n                break\n            \n            # Represent the candidate barcode as a NumPy array for efficient computation.\n            candidate_bc = np.array(bc_tuple, dtype=np.uint8)\n            \n            is_valid_to_add = True\n            # Check the candidate against all barcodes already in the set.\n            for existing_bc in barcode_set:\n                # Calculate the Hamming distance.\n                distance = np.sum(candidate_bc != existing_bc)\n                \n                # If the distance is less than the required minimum, the candidate is invalid.\n                if distance  d:\n                    is_valid_to_add = False\n                    break\n            \n            # If the candidate is valid, add it to the set.\n            if is_valid_to_add:\n                barcode_set.append(candidate_bc)\n                \n        # The result for this case is the size of the constructed set.\n        results.append(len(barcode_set))\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当从数百万个短读长中组装出基因组草图后，我们需要一种方法来衡量组装结果的连续性和完整性。NG50是评估基因组组装质量的行业标准指标，它反映了组装片段的连续性水平。这个练习将指导您完成NG50的计算过程，帮助您掌握评估基因组组装项目成果的核心技能。",
            "id": "2417502",
            "problem": "一个源自新一代测序 (NGS) 的基因组组装草图包含了一系列重叠群，其长度为 $\\{100, 50, 20, 5, 5\\}$ 千碱基对 (kbp)。估计的单倍体基因组大小为 $150$ 千碱基对 (kbp)。NG50统计量的定义如下：给定一个估计的基因组大小 $G$，将所有重叠群按长度非递增排序，并从最长的到最短的计算累计总和；NG50是指当累计总和首次等于或超过 $\\frac{1}{2}G$ 时的那个重叠群的长度 $L$。计算此组装的NG50。请以千碱基对 (kbp) 为单位表示答案。在解题过程中不要使用百分号。",
            "solution": "对题目陈述进行验证。\n\n逐字提取已知条件：\n1.  一组重叠群长度：$\\{100, 50, 20, 5, 5\\}$ 千碱基对 (kbp)。\n2.  估计的单倍体基因组大小：$150$ 千碱基对 (kbp)。\n3.  NG50的定义：给定一个估计的基因组大小 $G$，将所有重叠群按长度非递增排序，并从最长的到最短的计算累计总和；NG50是指当累计总和首次等于或超过 $\\frac{1}{2}G$ 时的那个重叠群的长度 $L$。\n\n验证结论：\n该问题有效。它具有科学依据，因为它涉及NG50统计量的计算，这是生物信息学中用于评估基因组组装连续性的一个标准且明确定义的指标。该问题提法得当，提供了所有必要的数据和清晰、无歧义的定义，可以得出一个唯一的解。所提供的数据是自洽且符合实际的。该问题是客观的，没有任何逻辑或事实上的缺陷。\n\n我们开始解题。\n\n任务是为一个给定的基因组组装草图计算NG50统计量。\n给定的重叠群长度集合为 $C = \\{100, 50, 20, 5, 5\\}$，单位为千碱基对 (kbp)。\n估计的单倍体基因组大小为 $G = 150$ kbp。\n\nNG50的定义要求我们找到一个重叠群长度 $L$，该重叠群使得长度的累计总和达到或超过估计基因组大小的50%。为了进行此计算，必须将重叠群按长度降序排列。\n\n首先，我们计算目标累计长度，即估计基因组大小的一半：\n$$\n\\text{Target Sum} = \\frac{1}{2} G = \\frac{1}{2} \\times 150 \\text{ kbp} = 75 \\text{ kbp}\n$$\n\n接下来，我们将给定的重叠群长度按非递增（降序）顺序排序。所提供的列表已经排好序：\n$L = [100, 50, 20, 5, 5]$。\n\n现在，我们从最长的重叠群开始计算这些长度的累计总和，并在每一步检查总和是否已达到或超过 $75$ kbp 的目标。\n\n设 $l_i$ 为排序后列表中第 $i$ 个重叠群的长度。\n设 $S_k$ 为前 $k$ 个重叠群的长度累计总和，即 $S_k = \\sum_{i=1}^{k} l_i$。我们在寻找满足 $S_k \\ge 75$ 的最小整数 $k$。NG50就是第 $k$ 个重叠群的长度 $l_k$。\n\n步骤1：考虑第一个（最长的）重叠群。\n其长度为 $l_1 = 100$ kbp。\n累计总和为 $S_1 = l_1 = 100$ kbp。\n\n我们检查累计总和是否满足条件：\n$S_1 \\ge 75$ kbp 吗？\n$100 \\ge 75$。是的，条件满足。\n\n由于第一个重叠群就满足了条件，计算过程在此停止。索引 $k$ 为 $1$。NG50统计量定义为这个特定重叠群的长度 $l_k$，也就是 $l_1$。\n\n因此，此组装的NG50是第一个重叠群的长度。\n$$\n\\text{NG50} = l_1 = 100 \\text{ kbp}\n$$\n问题要求以千碱基对为单位表示答案。计算出的值为 $100$。",
            "answer": "$$\n\\boxed{100}\n$$"
        }
    ]
}