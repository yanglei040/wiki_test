{
    "hands_on_practices": [
        {
            "introduction": "我们在研究计算复杂性时，一个有趣的思想实验是：如果我们给一个图灵机一个“外挂”（即预言机），它的计算能力会发生什么变化？这个练习探讨了一种基础情况：如果这个预言机本身只能解决一个我们已经能用多项式时间解决的“简单”问题，情况会如何？通过解决这个问题 ，你将亲手验证一个核心定理，即对于任何在$P$中的语言$A$，$P^A=P$，从而理解为何添加一个已知的、高效可解的预言机并不会增强确定性多项式时间图灵机的计算能力。",
            "id": "1417408",
            "problem": "在计算理论中，谕示图灵机（OTM）是一种用于研究判定问题的抽象机。它是一种标准的图灵机，增加了一个称为“谕示”的黑箱组件。在其计算的任何时刻，OTM 都可以将一个查询串 $w$ 写入一条特殊的谕示带，并进入一个查询状态。在一个计算步骤内，谕示会提供一个“是”或“否”的答案，指明查询串 $w$ 是否属于一个固定的语言 $A$，该语言被称为谕示语言。\n\n复杂度类 $P^A$ 被定义为所有能由一个带有谕示 $A$ 的确定性 OTM 在输入串长度的多项式步数内判定的语言集合。标准的复杂度类 $P$ 是所有能由一个标准的确定性图灵机（没有谕示）在多项式时间内判定的语言集合。\n\n设字母表为 $\\Sigma = \\{0, 1\\}$。考虑一个特定的谕示语言 $A$，它由所有奇数长度的二进制串组成。即，$A = \\{w \\in \\{0, 1\\}^* \\mid |w| \\text{ is odd}\\}$。\n\n下列哪个陈述正确描述了复杂度类 $P^A$（使用这个特定的谕示 $A$）与标准复杂度类 $P$ 之间的关系？\n\nA. $P^A = P$\n\nB. $P \\subset P^A$（意为 $P$ 是 $P^A$ 的真子集）\n\nC. $P^A \\subset P$（意为 $P^A$ 是 $P$ 的真子集）\n\nD. $P^A$ 和 $P$ 不可比（意为两个类都不是对方的子集）\n\nE. 在不知道 $P = NP$ 是否成立的情况下，无法确定此关系。",
            "solution": "问题要求确定复杂度类 $P$ 和 $P^A$ 之间的关系，其中谕示 $A$ 是所有奇数长度二进制串的语言。为了确定这种关系，我们必须检查双向的子集包含关系：即 $P \\subseteq P^A$ 是否成立，以及 $P^A \\subseteq P$ 是否成立。\n\n首先，我们来证明 $P \\subseteq P^A$。\n令 $L$ 为 $P$ 中的任意语言。根据 $P$ 的定义，存在一个标准的确定性图灵机 $M$ 在多项式时间内判定 $L$。假设 $M$ 在长度为 $n$ 的输入上的运行时间由一个多项式 $p(n)$ 限定。我们可以构造一个谕示图灵机 $M^A$ 来判定 $L$。这个机器 $M^A$ 只需模拟标准机器 $M$ 在其输入上的步骤，并完全忽略諭示。由于 $M$ 从不进行谕示查询，所以 $M^A$ 也永远不需要使用它的谕示。$M^A$ 的运行时间与 $M$ 的运行时间相同，即 $p(n)$。因此，$M^A$ 是一个在多项式时间内判定 $L$ 的谕示图灵机。这意味着 $L \\in P^A$。因为我们对 $L \\in P$ 的选择是任意的，所以我们可以得出结论 $P \\subseteq P^A$。请注意，这个包含关系对任何谕示语言 $A$ 都成立。\n\n接下来，我们来证明 $P^A \\subseteq P$。\n令 $L'$ 为 $P^A$ 中的任意语言。根据 $P^A$ 的定义，存在一个确定性谕示图灵机 $M^A$ 在多项式时间内判定 $L'$。假设 $M^A$ 在长度为 $n$ 的输入上的运行时间由一个多项式 $q(n)$ 限定。\n\n关键在于分析谕示 $A$。谕示语言是 $A = \\{w \\in \\{0, 1\\}^* \\mid |w| \\text{ is odd}\\}$。对给定字符串 $w$ 向这个谕示进行查询，就是请求确定 $w \\in A$ 是否成立。这等价于询问字符串 $w$ 的长度是否为奇数。\n这个检查可以通过一个标准算法来执行。一个标准的（非谕示）图灵机可以接收字符串 $w$作为输入，从头到尾读取它以计算其长度 $|w|$，然后确定数字 $|w|$ 是否为奇数。计算 $w$ 长度所需的时间与 $|w|$ 成正比，即 $O(|w|)$。检查得到的整数是否为奇数在计算上是微不足道的。因此，对字符串 $w$ 的谕示查询可以由一个标准图灵机在查询串 $w$ 长度的多项式时间内模拟。具体来说，语言 $A$ 属于 $P$（实际上，它属于线性时间，即 DTIME(O(n))）。\n\n现在，我们可以构造一个标准的确定性图灵机 $M'$，它无需谕示即可判定语言 $L'$。$M'$ 将模拟 $M^A$ 的执行过程。\n$M'$ 的操作如下：\n1. 它模拟 $M^A$ 的每一个计算步骤。\n2. 当模拟到达 $M^A$ 将要对字符串 $w$ 进行谕示查询的点时，$M'$ 暂停主模拟。\n3. 然后，它运行一个子程序来判定 $w \\in A$。如上所述，这个子程序计算 $w$ 的长度并检查其是否为奇数。\n4. 根据该子程序返回的“是”或“否”的结果，$M'$ 从相应的状态（“是”状态或“否”状态）恢复对 $M^A$ 的模拟，就像 $M^A$ 从其谕示接收到答案后所做的那样。\n\n最后，我们来分析 $M'$ 的运行时间。谕示机 $M^A$ 在长度为 $n$ 的输入上运行时间为 $q(n)$。在任何单个步骤中，$M^A$ 最多只能向其谕示带写入一个符号。因此，$M^A$ 产生的任何查询串 $w$ 的长度必须满足 $|w| \\le q(n)$。\n$M'$ 模拟对字符串 $w$ 的单个谕示查询的时间是 $|w|$ 的多项式，比如说 $O(|w|)$。由于 $|w| \\le q(n)$，模拟一次查询的时间受 $n$ 的一个多项式（例如 $O(q(n))$）的限制。\n在最坏的情况下，$M^A$ 可能在其计算的每一步都进行谕示查询。总步数最多为 $q(n)$。因此，$M'$ 的总时间是模拟 $M^A$ 的非查询步骤的时间加上模拟所有查询的总时间之和。\n$M'$ 的总运行时间 $\\approx (\\text{非查询步骤数}) + (\\text{查询次数}) \\times (\\text{每次查询模拟的时间})$。\n这个时间的上界为 $q(n) + q(n) \\times O(q(n)) = O(q(n)^2)$。\n由于 $q(n)$ 是 $n$ 的一个多项式，所以 $q(n)^2$ 也是 $n$ 的一个多项式。因此，$M'$ 是一个在多项式时间内判定语言 $L'$ 的标准确定性图灵机。\n这意味着 $L' \\in P$。因为我们对 $L' \\in P^A$ 的选择是任意的，所以我们可以得出结论 $P^A \\subseteq P$。\n\n既然我们已经证明了 $P \\subseteq P^A$ 和 $P^A \\subseteq P$，那么这两个类必然相等：$P^A = P$。这对应于选项 A。\n一般来说，复杂度理论中有一个有用的定理：对于任何语言 $A$，如果 $A \\in P$，那么 $P^A = P$。我们这个特定的谕示 $A$ 可以在线性时间内判定，所以 $A \\in P$，该定理直接导出了这个结果。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在了解了简单的预言机不会增强计算能力后，我们自然会问：一个“强大”的预言机会带来多大的提升？本练习  让你探索当一个多项式时间图灵机可以访问一个能解决PSPACE完全问题的预言机（具体来说是TQBF）时的情形。这个实践将揭示预言机与完备性理论之间的深刻联系，帮助你理解一个类的计算能力如何通过访问一个更高阶类的完全问题预言机而被“提升”到那个类的水平。",
            "id": "1417452",
            "problem": "一个理论计算机科学的研究小组正在探索“黑盒”计算的能力。他们正在研究一个模型，其中一个标准的多项式时间计算机可以访问一个特殊的硬件加速器，即“预言机”，该预言机可以瞬时解决真量化布尔公式（TQBF）问题的任何实例。已知TQBF问题是PSPACE完全的。\n\n我们来形式化地描述它。预言机图灵机是一种带有一条特殊的“预言机带”和一个“查询状态”的图灵机。当机器进入查询状态时，其预言机带上写的字符串会在一个计算步骤内被替换：如果该字符串属于预言机的语言，则替换为'1'，否则替换为'0'。\n\n对于一个复杂度类 $\\mathcal{C}$ 和一个语言 $A$，类 $\\mathcal{C}^A$ 被定义为可以由一台预言机图灵机判定的语言集合，该图灵机在 $\\mathcal{C}$ 的资源限制内运行，并使用一个针对语言 $A$ 的预言机。\n\n鉴于TQBF是PSPACE完全的，下列哪个陈述正确描述了类 $P^{\\text{TQBF}}$（可用TQBF预言机在多项式时间内判定的语言）与类PSPACE（可在多项式空间内判定的语言）之间的关系？\n\nA. $P^{\\text{TQBF}} = \\text{NP}$\n\nB. $P^{\\text{TQBF}} = \\text{PSPACE}$\n\nC. $P^{\\text{TQBF}} = \\text{EXPTIME}$\n\nD. $P^{\\text{TQBF}} = \\text{P}$\n\nE. 从给定的信息中无法确定此关系。",
            "solution": "我们使用预言机图灵机的定义以及TQBF的PSPACE完全性。\n\n首先，回顾一下，TQBF在多项式时间多一归约下是PSPACE完全的。也就是说，对于每个语言 $L \\in \\text{PSPACE}$，存在一个多项式时间可计算函数 $f$，使得对于所有输入 $x$ 都满足，\n$$\nx \\in L \\quad \\Longleftrightarrow \\quad f(x) \\in \\text{TQBF}.\n$$\n这直接给出了包含关系 $\\text{PSPACE} \\subseteq \\text{P}^{\\text{TQBF}}$：一个带有 $\\text{TQBF}$ 预言机的确定性多项式时间预言机可以通过在多项式时间内计算 $f(x)$ 并对 $\\text{TQBF}$ 进行一次预言机查询来判定 $L$。形式上，\n$$\n\\text{PSPACE} \\subseteq \\text{P}^{\\text{TQBF}}.\n$$\n\n对于反向包含关系，注意到 $\\text{TQBF} \\in \\text{PSPACE}$。设 $M$ 是任意一个带有 $\\text{TQBF}$ 预言机的确定性多项式时间预言机图灵机。我们用一个只使用多项式空间的确定性图灵机 $S$ 来模拟 $M$。模拟器 $S$ 维护 $M$ 的工作带，并且每当 $M$ 对字符串 $y$ 进行预言机查询时，$S$ 就使用一个针对 $\\text{TQBF}$ 的多项式空间算法来判定 $y \\in \\text{TQBF}$，将相应的比特位作为预言机的回答写下，然后继续模拟 $M$。因为：\n- $M$ 在多项式时间内运行，所以它最多进行多项式次查询，并且每个查询字符串的长度是输入大小的多项式。\n- 判定每次预言机查询使用的空间是 $|y|$ 的多项式，因此是原始输入大小的多项式。\n- 空间可以在不同查询之间重用。\n\n$S$ 使用的总空间是输入大小的多项式。因此，$\\text{P}^{\\text{TQBF}}$ 中的每个语言都在 $\\text{PSPACE}$ 中，即，\n$$\n\\text{P}^{\\text{EQBF}} \\subseteq \\text{PSPACE}.\n$$\n\n结合这两个包含关系可得\n$$\n\\text{P}^{\\text{TQBF}} = \\text{PSPACE}.\n$$\n\n在选项中，这对应于选项B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "前面的练习展示了“全有”或“全无”的情景：预言机要么毫无帮助，要么赋予了巨大的计算能力。现在，我们来探讨一种更精妙的用法：如果我们拥有一个强大的预言机，但限制它的使用次数，我们能解决哪些问题？这个练习  探索了$P^{\\text{SAT}[O(\\log n)]}$这一复杂度类，即对一个NP完全预言机（SAT）的查询次数被限制在对数级别。它展示了一种强大的算法设计范式，即如何将二分搜索等经典技巧与预言机查询相结合，从而高效地解决那些看似棘手的搜索和优化问题。",
            "id": "1417455",
            "problem": "令 $SAT$ 为所有可满足布尔公式的语言。预言图灵机是一种带有特殊“预言”带和查询状态的图灵机。为了查询预言机，机器在其预言带上写入一个字符串 $q$ 并进入查询状态。在一个计算步骤中，如果 $q \\in SAT$，预言机制会将预言带的内容替换为“1”；如果 $q \\notin SAT$，则替换为“0”。\n\n考虑一个复杂性类，我们将其表示为 $\\mathcal{C}_{\\log}$，它包含所有语言 $L$，对于这些语言，存在一个确定性多项式时间预言图灵机 $M$ 来判定 $L$，且满足以下条件：对于任意长度为 $n = |x|$ 的输入 $x$，机器 $M$ 最多向 $SAT$ 预言机进行 $c \\cdot \\log(n)$ 次查询，其中 $c > 0$ 是某个常数。\n\n以下哪种语言属于类 $\\mathcal{C}_{\\log}$？选择所有适用的选项。\n\nA. `MAX-CLIQUE-SIZE-IS-EVEN`：所有编码一个无向图 $G = (V, E)$ 的字符串的语言，其中 $G$ 中最大团的大小是偶数。对于此问题，输入大小 $n$ 被视作顶点的数量 $|V|$。\n\nB. `UNIQUE-SAT`：所有编码一个布尔公式 $\\phi$ 的字符串的语言，该公式恰好只有一个满足赋值。对于此问题，输入大小 $n$ 是该公式编码的长度 $|\\phi|$。\n\nC. `SAT-UNSAT`：所有编码一对布尔公式 $(\\phi_1, \\phi_2)$ 的字符串的语言，使得 $\\phi_1$ 是可满足的而 $\\phi_2$ 是不可满足的。对于此问题，输入大小 $n$ 是这对公式编码的长度 $|(\\phi_1, \\phi_2)|$。\n\nD. `MAJORITY-SAT`：所有编码一个包含 $k$ 个变量的布尔公式 $\\phi$ 的字符串的语言，使得 $\\phi$ 有严格多于 $2^{k-1}$ 个满足赋值。对于此问题，输入大小 $n$ 是该公式编码的长度 $|\\phi|$。",
            "solution": "我们回顾一下定义：一个语言 $L$ 属于 $\\mathcal{C}_{\\log}$，如果存在一个确定性多项式时间预言图灵机 $M$ 和一个常数 $c>0$，使得对于每个长度为 $n=|x|$ 的输入 $x$，$M$ 在判定 $x \\in L$ 的同时，最多向 $SAT$ 预言机进行 $c\\cdot \\log(n)$ 次查询。对数可以取任何固定的底，因为乘法常数可以被吸收到 $c$ 中。\n\n我们通过显式地构造一个最多使用 $O(\\log n)$ 次对 $SAT$ 的预言机查询并判定该语言的多项式时间过程来分析每个选项。\n\n**A. `MAX-CLIQUE-SIZE-IS-EVEN`**\n设输入编码一个图 $G=(V,E)$，并令 $n=|V|$。我们可以通过二分搜索找到最大团（Max Clique）的大小。首先，定义一个判定问题“$G$ 是否包含一个大小至少为 $k$ 的团？”。这个问题是 NP 完全的（它就是团问题 CLIQUE）。因此，存在一个多项式时间归约，可以将任何一个“$G$ 中是否存在大小为 $k$ 的团”的实例转换成一个布尔公式 $\\phi_{G,k}$，使得 $\\phi_{G,k}$ 可满足当且仅当 $G$ 中存在大小为 $k$ 的团。\n\n令 $P(k)$ 表示“$G$ 包含一个大小至少为 $k$ 的团”。这个性质是单调递减的：如果 $G$ 有一个大小为 $k$ 的团，它必然也有一个大小为 $k-1$ 的团。我们的目标是找到最大的 $k^{\\star}$ 使得 $P(k^{\\star})$ 为真。我们可以通过在区间 $[0, n]$ 上进行二分搜索来找到这个 $k^{\\star}$：\n1.  初始化下界 $\\ell = 0$ 和上界 $r = n$。\n2.  当 $\\ell \\le r$ 时，计算中点 $m = \\lfloor(\\ell+r)/2\\rfloor$。构造公式 $\\phi_{G,m}$ 并向 SAT 预言机查询它是否可满足。\n3.  如果 $\\phi_{G,m}$ 可满足（即 $P(m)$ 为真），说明最大团的大小至少是 $m$。我们将结果暂存，并尝试寻找更大的团，即令 $\\ell = m + 1$。\n4.  如果 $\\phi_{G,m}$ 不可满足（即 $P(m)$ 为假），说明最大团的大小小于 $m$。我们缩小搜索范围，令 $r = m - 1$。\n\n这个过程将搜索区间大小减半，最多需要 $O(\\log n)$ 次查询。结束后，我们就能得到最大团的大小 $k^{\\star}$。最后，我们检查 $k^{\\star}$ 是否为偶数。整个过程使用了 $O(\\log n)$ 次 SAT 查询，且其他计算都是多项式时间的。因此，该语言属于 $\\mathcal{C}_{\\log}$。\n\n**B. `UNIQUE-SAT`**\n给定一个布尔公式 $\\phi$，要判断它是否恰好只有一个满足赋值。我们可以通过两次 SAT 查询来解决这个问题：\n1.  **第一次查询**：查询 $\\phi$ 是否可满足。如果 $\\phi \\notin SAT$，则它有 0 个解，不满足条件，拒绝。\n2.  **第二次查询**：如果 $\\phi \\in SAT$，我们需要检查是否存在第二个不同的解。我们可以构造一个新公式 $\\Psi$。令 $x = (x_1, \\dots, x_k)$ 是公式 $\\phi$ 的变量。$\\Psi$ 的定义为：\n    $$ \\Psi(x, y) = \\phi(x) \\land \\phi(y) \\land (x \\neq y) $$\n    其中 $y=(y_1, \\dots, y_k)$ 是一组新的变量。$(x \\neq y)$ 表示 $x$ 和 $y$ 的赋值不完全相同，可以表达为 $\\bigvee_{i=1}^k (x_i \\oplus y_i)$。这个公式 $\\Psi$ 是可满足的，当且仅当存在两个不同的赋值 $x$ 和 $y$ 都能使 $\\phi$ 为真。因此，我们向 SAT 预言机查询 $\\Psi$ 是否可满足。\n    - 如果 $\\Psi \\in SAT$，说明 $\\phi$ 有至少两个满足赋值，不满足条件，拒绝。\n    - 如果 $\\Psi \\notin SAT$，说明 $\\phi$ 最多只有一个满足赋值。结合第一次查询的结果，我们知道它恰好有一个满足赋值。接受。\n\n这个算法总共进行了 2 次 SAT 查询。由于 $2$ 是一个常数，它满足 $O(\\log n)$ 的限制（对于足够大的 $n$）。因此，该语言属于 $\\mathcal{C}_{\\log}$。\n\n**C. `SAT-UNSAT`**\n给定一对公式 $(\\phi_1, \\phi_2)$，我们要判断 $\\phi_1$ 是否可满足且 $\\phi_2$ 是否不可满足。\n1.  **第一次查询**：查询 $\\phi_1$ 是否可满足。如果 $\\phi_1 \\notin SAT$，则条件不满足，拒绝。\n2.  **第二次查询**：如果 $\\phi_1 \\in SAT$，我们接着查询 $\\phi_2$ 是否可满足。\n    - 如果 $\\phi_2 \\in SAT$，那么“$\\phi_2$ 不可满足”的条件为假，拒绝。\n    - 如果 $\\phi_2 \\notin SAT$，那么两个条件都满足，接受。\n\n此过程需要 2 次 SAT 查询。同样，这满足 $O(\\log n)$ 的查询限制。因此，该语言属于 $\\mathcal{C}_{\\log}$。\n\n**D. `MAJORITY-SAT`**\n这个问题是判断一个布尔公式 $\\phi$ 的满足赋值数量是否严格大于所有可能赋值数量的一半 ($2^{k-1}$)。这是 PP 类（概率多项式时间）的一个典型完备问题。人们普遍认为，解决此类与“计数”相关的问题比解决 NP 问题（如 SAT）要困难得多。具体来说，$\\mathcal{C}_{\\log}$ 是 $P^{NP[O(\\log n)]}$（有时也记作 $\\Theta_2^P$），它位于多项式时间层级 (PH) 的第二层。而 PP 不被认为包含在 PH 的任何一层中。因此，没有已知的算法可以使用对数次 SAT 查询来解决 `MAJORITY-SAT`。将计数问题归约到判定问题通常需要多项式次而不是对数次的查询。因此，该语言不被认为属于 $\\mathcal{C}_{\\log}$。\n\n综上所述，选项 A、B 和 C 中的语言都属于 $\\mathcal{C}_{\\log}$。",
            "answer": "$$\\boxed{ABC}$$"
        }
    ]
}