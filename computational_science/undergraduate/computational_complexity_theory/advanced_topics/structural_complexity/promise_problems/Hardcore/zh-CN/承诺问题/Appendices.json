{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习旨在介绍一个可以被高效解决的基础承诺问题。通过解决这个问题，你将看到一个“承诺”如何能极大地简化手头的任务，使得一个简单的确定性算法能够在 **PromiseP** 这个复杂性类中正确工作。",
            "id": "1437636",
            "problem": "在计算复杂性理论中，一个标准的判定问题由一个语言 $L$ 定义，该语言是一个字符串集合，目标是确定给定的输入字符串 $x$ 是否在 $L$ 中。一个承诺问题是一种泛化，其中输入被保证（“承诺”）来自所有可能字符串的一个特定子集。\n\n一个承诺问题由一对不相交的字符串集合 $(\\Pi_{YES}, \\Pi_{NO})$ 正式定义。如果一个算法接受每个输入 $x \\in \\Pi_{YES}$ 并拒绝每个输入 $x \\in \\Pi_{NO}$，则称该算法解决了这个承诺问题。算法在不属于 $\\Pi_{YES} \\cup \\Pi_{NO}$ 的输入上的行为是不受约束的。集合 $\\Pi_{YES} \\cup \\Pi_{NO}$ 被称为承诺。\n\n复杂性类 **PromiseP** 包含所有可以由确定性算法在多项式时间内（相对于输入长度）解决的承诺问题。\n\n考虑以下计算问题，我们称之为 `ONE_ROOT`：\n\n-   **输入：** 一个整数系数多项式 $p(x) = a_n x^n + \\dots + a_1 x + a_0$，表示为其整数系数的列表 $\\langle p \\rangle = [a_0, a_1, \\dots, a_n]$。\n-   **承诺：** 输入多项式 $p(x)$ 保证恰好满足以下两个条件之一：要么 $p(1) = 0$，要么 $p(-1) = 0$。\n-   **问题：** 多项式 $p(x)$ 在 $x=1$ 处是否有根？\n\n这可以被构建为一个承诺问题 $(\\Pi_{YES}, \\Pi_{NO})$，其中 $\\Pi_{YES}$ 是“是”实例（即 $p(1)=0$），而 $\\Pi_{NO}$ 是“否”实例（即 $p(-1)=0$）。\n\n以下哪个陈述是正确的？\n\nA. `ONE_ROOT` 属于 **PromiseP**。\n\nB. `ONE_ROOT` 不属于 **PromiseP**，但它是可判定的。\n\nC. `ONE_ROOT` 是不可判定的。\n\nD. `ONE_ROOT` 的复杂性取决于多项式的次数，并且只有当次数被一个常数限制时，它才属于 **PromiseP**。",
            "solution": "我们给定一个整数系数多项式 $p(x)=a_{n}x^{n}+\\dots+a_{1}x+a_{0}$，其编码为 $\\langle p \\rangle=[a_{0},a_{1},\\dots,a_{n}]$，并承诺 $p(1)=0$ 或 $p(-1)=0$ 中恰好有一个成立。问题是问是否 $p(1)=0$。定义承诺问题 $(\\Pi_{\\mathrm{YES}},\\Pi_{\\mathrm{NO}})$ 如下：\n$$\n\\Pi_{\\mathrm{YES}}=\\{\\langle p\\rangle:\\ p(1)=0,\\ p(-1)\\neq 0\\},\\quad \\Pi_{\\mathrm{NO}}=\\{\\langle p\\rangle:\\ p(-1)=0,\\ p(1)\\neq 0\\}.\n$$\n一个算法如果接受 $\\Pi_{\\mathrm{YES}}$ 中的所有输入并拒绝 $\\Pi_{\\mathrm{NO}}$ 中的所有输入，那么它就解决了这个承诺问题；它在 $\\Pi_{\\mathrm{YES}}\\cup\\Pi_{\\mathrm{NO}}$ 之外的行为是无关紧要的。\n\n关键观察：在 $x=1$ 处对 $p$ 求值等价于对其系数求和：\n$$\np(1)=\\sum_{i=0}^{n}a_{i}.\n$$\n算法：给定 $\\langle p\\rangle=[a_{0},\\dots,a_{n}]$，计算\n$$\ns=\\sum_{i=0}^{n}a_{i},\n$$\n当且仅当 $s=0$ 时输出“是”（YES）；否则输出“否”（NO）。\n\n在承诺下的正确性：如果 $\\langle p\\rangle\\in\\Pi_{\\mathrm{YES}}$，根据定义有 $p(1)=0$，因此 $s=0$，算法输出“是”。如果 $\\langle p\\rangle\\in\\Pi_{\\mathrm{NO}}$，那么 $p(1)\\neq 0$，因此 $s\\neq 0$，算法输出“否”。因此，该算法在所有满足承诺的输入上都是正确的。它在 $p(1)=0$ 和 $p(-1)=0$ 同时成立（或都不成立）的输入上的行为不受承诺的约束；事实上，该算法对任何输入仍然能正确输出。\n\n运行时间：设总输入大小为 $N$，其度量为整数 $a_{0},\\dots,a_{n}$ 的位长度之和加上分隔符的编码开销。将两个位长度至多为 $L$ 的整数相加可以在 $O(L)$ 时间内完成。对 $n+1$ 个位长度受其输入大小限制的整数进行迭代求和所需时间是 $N$ 的多项式；中间和的位长度最多增加 $O(\\log(n+1))$，所以总时间是 $O\\!\\left(\\sum_{i=0}^{n}\\mathrm{len}(a_{i})+n\\log(n+1)\\right)$，这是 $N$ 的多项式。因此，该算法是确定性多项式时间算法。\n\n结论：该问题属于 **PromiseP**，因为存在一个确定性多项式时间算法，它能对所有满足承诺的输入做出正确判定。因此，陈述 A 是正确的。陈述 B 和 C 是错误的，因为该问题在确定性多项式时间内是可判定的。陈述 D 是错误的，因为该算法在多项式时间内运行，而不需要对次数有任何限制。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "接下来的练习将展示一个关于“承诺”力量的更引人注目的例子。它揭示了一个承诺如何能将一个著名的不可判定问题——停机问题——转变为一个可判定的问题。这个练习对于理解以下关键点至关重要：解决承诺问题的算法无需验证承诺本身，只需在承诺成立时正确工作即可。",
            "id": "1437602",
            "problem": "一个承诺问题 (promise problem) 是由一对不相交的字符串集合 $(L_{YES}, L_{NO})$ 定义的计算任务。如果一台图灵机 (TM) 对于任何输入字符串 $x$，当 $x \\in L_{YES}$ 时停机并接受，当 $x \\in L_{NO}$ 时停机并拒绝，那么我们称该图灵机判定此承诺问题。对于不在 $L_{YES} \\cup L_{NO}$ 中的输入，该图灵机的行为未被规定。\n\n令 $w_0$ 为固定的二进制字符串 \"0101\"。考虑一个与图灵机行为相关的承诺问题 $\\mathcal{P} = (L_{YES}, L_{NO})$。这个问题的输入是一台图灵机的编码，记作 $\\langle M \\rangle$。其承诺是，对于此问题的任何给定图灵机 $M$，保证它在所有长度等于 $w_0$ 长度的输入字符串 $w'$ 上都会停机（即 $|w'| = |w_0| = 4$）。\n\n承诺问题 $\\mathcal{P}$ 的集合定义如下：\n- $L_{YES} = \\{ \\langle M \\rangle \\mid \\text{图灵机 } M \\text{ 接受 } w_0 \\text{ 且在所有长度为 4 的字符串上停机} \\}$\n- $L_{NO} = \\{ \\langle M \\rangle \\mid \\text{图灵机 } M \\text{ 不接受 } w_0 \\text{ 且在所有长度为 4 的字符串上停机} \\}$\n\n问题在于，在输入始终属于 $L_{YES} \\cup L_{NO}$ 的承诺下，确定区分 $L_{YES}$ 和 $L_{NO}$ 中实例的计算性质。\n\n以下哪个陈述正确描述了此承诺问题 $\\mathcal{P}$ 的复杂度？\n\nA. 该承诺问题是可判定的。\n\nB. 该承诺问题是不可判定的，但属于复杂度类 RE (图灵可识别的)。\n\nC. 该承诺问题是不可判定的，但属于复杂度类 co-RE。\n\nD. 该承诺问题是不可判定的，且既不属于 RE 也不属于 co-RE。",
            "solution": "该问题要求判断承诺问题 $\\mathcal{P} = (L_{YES}, L_{NO})$ 的可判定性。如果一个算法能够在输入必属于这两者之一的保证下，正确地区分来自 $L_{YES}$ 和 $L_{NO}$ 的输入，那么该算法就判定了这个问题。\n\n让我们分析一下这个问题的结构。我们得到一台图灵机的编码 $\\langle M \\rangle$，并且得到承诺：该图灵机 $M$ 在所有长度为 4 的输入字符串上都会停机。所讨论的特定字符串是 $w_0 = \\text{\"0101\"}$，其长度为 4。\n\n这个承诺是关键信息。既然我们保证了 $M$ 在所有长度为 4 的字符串上停机，那么这个保证也特别适用于字符串 $w_0 = \\text{\"0101\"}$。因此，对于任何遵守该承诺的输入 $\\langle M \\rangle$，我们可以确定 $M$ 在输入 $w_0$ 上的计算将会终止。\n\n基于这一洞见，我们可以构造一台图灵机，称之为 $D$，来解决这个承诺问题。$D$ 的算法如下：\n对于输入 $\\langle M \\rangle$：\n1. $D$ 接收编码 $\\langle M \\rangle$ 和固定字符串 $w_0 = \\text{\"0101\"}$。\n2. $D$ 模拟图灵机 $M$ 在输入字符串 $w_0$ 上的执行过程。\n3. 因为输入 $\\langle M \\rangle$ 被承诺属于 $L_{YES} \\cup L_{NO}$，所以图灵机 $M$ 保证在 $w_0$ 上停机。因此，由 $D$ 执行的模拟也保证会终止。\n4. 当 $M(w_0)$ 的模拟停机时，$D$ 检查其结果：\n   - 如果 $M$ 在接受状态停机，这意味着 $\\langle M \\rangle \\in L_{YES}$。在这种情况下，$D$ 停机并接受。\n   - 如果 $M$ 在拒绝状态停机，这意味着 $M$ 不接受 $w_0$，因此 $\\langle M \\rangle \\in L_{NO}$。在这种情况下，$D$ 停机并拒绝。\n\n上述的图灵机 $D$ 可作为承诺问题 $\\mathcal{P}$ 的一个判定器。对于来自承诺集合 $L_{YES} \\cup L_{NO}$ 的任何输入 $\\langle M \\rangle$，$D$ 总是停机并给出正确答案：对于 $L_{YES}$ 中的输入，它接受；对于 $L_{NO}$ 中的输入，它拒绝。因此，承诺问题 $\\mathcal{P}$ 是可判定的。\n\n将此问题与相关的不可判定问题进行对比，以理解为什么其他选项是错误的，这一点很重要。\n- 如果没有这个承诺，判定一个任意图灵机 $M$ 是否接受固定字符串 $w_0$ 的问题（即语言 $A_{TM}^{w_0} = \\{ \\langle M \\rangle \\mid M \\text{ 接受 } w_0 \\}$）是不可判定的。然而，这个问题是图灵可识别的（属于 RE），因为可以模拟 $M$ 在 $w_0$ 上的运行，如果它接受，就接受。如果 $M$ 进入循环或拒绝，识别器可能不会停机。将我们的问题与这个标准问题混淆的学生可能会错误地选择选项 B。\n- 一个关键的错误是认为判定器 $D$ 必须首先验证承诺。验证承诺的问题，即判定语言 $P_4 = \\{ \\langle M \\rangle \\mid M \\text{ 在所有长度为 4 的字符串上停机} \\}$，本身是高度不可判定的（超越了 RE 和 co-RE）。一个判定 $P_4$ 的图灵机将不得不在 $2^4 = 16$ 个不同的输入上解决 $M$ 的停机问题。根据莱斯定理 (Rice's theorem)，图灵机语言的任何非平凡性质都是不可判定的。尽管这个承诺是关于图灵机的行为，而不仅仅是其语言，但它也可以被证明是不可判定的。认为必须验证承诺的人可能会错误地选择选项 D。\n\n然而，承诺问题的定义免除了我们验证的责任。我们被*给定*输入满足承诺，这一条件强大到足以使一个原本不可判定的问题变得可判定。\n\n因此，这个总会停机的判定器 $D$ 的存在证明了该承诺问题是可判定的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "我们的最后一个练习将视野扩展到随机计算领域。在这里，你将设计一个概率算法，用于在一个图要么是路径图要么是星形图的承诺下，区分这两种图。这个问题引入了复杂性类 **PromiseBPP**，并要求你思考如何约束错误概率，这是随机算法中的一个核心概念。",
            "id": "1437609",
            "problem": "考虑一个名为 `PATH_vs_STAR` 的承诺问题。该问题的输入是一个包含 $n \\ge 4$ 个顶点的无向图 $G = (V,E)$，以邻接矩阵的形式给出。我们得到一个承诺，即输入图 $G$ 要么是路径图 $P_n$，要么是星形图 $K_{1,n-1}$。\n\n- **路径图** $P_n$ 是一个图，其顶点可以按序列 $v_1, v_2, \\ldots, v_n$ 排列，使得边恰好是所有 $i = 1, \\ldots, n-1$ 的 $(v_i, v_{i+1})$。\n- **星形图** $K_{1,n-1}$ 是一个图，它有一个中心顶点连接到所有其他 $n-1$ 个顶点，且图中只有这些边。\n\n目标是设计一个算法来判断图 $G$ 属于哪种类型。具体来说，如果 $G$ 是路径图，算法应输出 'YES'；如果 $G$ 是星形图，算法应输出 'NO'。\n\n一个承诺问题 $(\\Pi_{YES}, \\Pi_{NO})$，其中 $\\Pi_{YES}$ 是 'YES' 实例的集合（这里是所有 $P_n$ 图），$\\Pi_{NO}$ 是 'NO' 实例的集合（所有 $K_{1,n-1}$ 图），如果它能被一个在多项式时间内运行的随机算法解决，并且对于任何有效输入 $G$ 都满足以下条件，则该问题属于复杂性类 **PromiseBPP**（有界错误概率多项式时间）：\n- 如果 $G \\in \\Pi_{YES}$，算法以至少 $2/3$ 的概率输出 'YES'。\n- 如果 $G \\in \\Pi_{NO}$，算法以至少 $2/3$ 的概率输出 'NO'。\n\n以下哪个随机算法能正确解决 `PATH_vs_STAR` 承诺问题，并证明对于所有 $n \\ge 4$，该问题属于 **PromiseBPP**？\n\nA. **算法 A：**\n1. 从 $V$ 中均匀随机选取一个顶点 $v$。\n2. 计算其度 $\\deg(v)$。\n3. 如果 $\\deg(v) = 2$，输出 'YES'。\n4. 否则，输出 'NO'。\n\nB. **算法 B：**\n1. 从 $V$ 中均匀随机选取两个不同的顶点 $u$ 和 $v$。\n2. 计算它们的度 $\\deg(u)$ 和 $\\deg(v)$。\n3. 如果 $\\deg(u)=1$ 且 $\\deg(v)=1$，输出 'NO'。\n4. 否则，输出 'YES'。\n\nC. **算法 C：**\n1. 重复 5 次：\n   a. 从 $V$ 中均匀随机选取一个顶点 $v$。\n   b. 如果 $\\deg(v) \\ge 3$，输出 'NO' 并停止。\n2. 如果循环完成而未停止，输出 'YES'。\n\nD. **算法 D：**\n1. 重复 $2n$ 次：\n   a. 从 $V$ 中均匀随机选取一个顶点 $v$。\n   b. 如果 $\\deg(v) \\ge 3$，输出 'NO' 并停止。\n2. 如果循环完成而未停止，输出 'YES'。\n\nE. **算法 E：**\n1. 计算所有 $n$ 个顶点的度。\n2. 如果恰好有两个顶点的度为 1，其余 $n-2$ 个顶点的度为 2，则准备输出 'YES'。否则，准备输出 'NO'。\n3. 抛一枚均匀的硬币。如果是正面，输出准备好的答案。如果是反面，输出与准备好的答案相反的结果。",
            "solution": "为了确定哪个算法能在 **PromiseBPP** 中解决 `PATH_vs_STAR` 承诺问题，我们必须针对所有 $n \\ge 4$ 的情况，根据问题的要求分析每个提出的算法。要求是：多项式运行时间，对于 YES 和 NO 实例的正确概率均 $\\ge 2/3$。从一个 $n \\times n$ 的邻接矩阵计算单个顶点的度的时间是 $O(n)$。\n\n首先，我们确定 $n \\ge 4$ 时图的度属性：\n- 路径图 $P_n$ 有两个度为 1 的顶点（端点）和 $n-2$ 个度为 2 的顶点。最大度为 2。\n- 星形图 $K_{1,n-1}$ 有一个度为 $n-1$ 的中心顶点和 $n-1$ 个度为 1 的叶顶点。由于 $n \\ge 4$，中心顶点的度为 $n-1 \\ge 3$。最大度为 $n-1$。\n\n关键区别在于路径图的最大度为 2，而星形图的最大度至少为 3。任何度 $\\ge 3$ 的顶点都能立即确定该图为星形图。任何度为 2 的顶点都能立即确定该图为路径图。\n\n**算法 A 的分析：**\n- **YES 实例 ($G=P_n$)：**只有当算法选取一个度为 2 的顶点时，它才会输出 'YES'。这样的顶点有 $n-2$ 个。输出 'YES' 的概率是 $\\frac{n-2}{n} = 1 - \\frac{2}{n}$。我们要求这个概率至少为 $2/3$。所以，$1 - \\frac{2}{n} \\ge \\frac{2}{3} \\implies \\frac{1}{3} \\ge \\frac{2}{n} \\implies n \\ge 6$。该算法在 $n=4$（概率=1/2）和 $n=5$（概率=3/5）时失败，因为这些概率小于 $2/3$。\n- **结论：**算法 A 不正确。\n\n**算法 B 的分析：**\n- **NO 实例 ($G=K_{1,n-1}$)：**如果算法选取两个度为 1 的顶点，它会输出 'NO'。这样的顶点有 $n-1$ 个。发生此事件的概率是 $\\frac{\\binom{n-1}{2}}{\\binom{n}{2}} = \\frac{(n-1)(n-2)/2}{n(n-1)/2} = \\frac{n-2}{n} = 1 - \\frac{2}{n}$。这是正确输出 'NO' 的概率。与算法 A 一样，这个概率仅在 $n \\ge 6$ 时才 $\\ge 2/3$。它在 $n=4, 5$ 时失败。\n- **结论：**算法 B 不正确。\n\n**算法 C 的分析：**\n- **YES 实例 ($G=P_n$)：**$P_n$ 的最大度为 2。条件 $\\deg(v) \\ge 3$ 永远不会满足。算法将总是完成循环并输出 'YES'。正确概率为 1，这 $\\ge 2/3$。这部分是正确的。\n- **NO 实例 ($G=K_{1,n-1}$)：**如果在全部 5 次试验中都未能选到唯一的中心顶点（度为 $n-1 \\ge 3$），算法就会出错。在一次试验中选到中心顶点的概率是 $1/n$。没有选到的概率是 $1 - 1/n$。错误概率（输出 'YES'）是在 5 次独立试验中都没有选到中心顶点的概率，即 $\\left(1 - \\frac{1}{n}\\right)^5$。我们需要这个错误概率 $\\le 1/3$。然而，当 $n$ 变大时，$\\left(1 - \\frac{1}{n}\\right)^5$ 趋近于 1。例如，如果 $n=10$，错误概率是 $(0.9)^5 \\approx 0.59$，大于 $1/3$。\n- **结论：**算法 C 不正确，因为它在 NO 实例上的错误概率对于所有 $n \\ge 4$ 并不以 $1/3$ 为界。\n\n**算法 D 的分析：**\n- **YES 实例 ($G=P_n$)：**与算法 C 类似，最大度为 2，因此条件 $\\deg(v) \\ge 3$ 永远不会满足。算法总是输出 'YES'。正确概率为 1。这是正确的。\n- **NO 实例 ($G=K_{1,n-1}$)：**如果在 $2n$ 次试验中都没有选到中心顶点，算法就会出错。错误概率是 $P(\\text{error}) = \\left(1 - \\frac{1}{n}\\right)^{2n}$。我们需要检查对于所有 $n \\ge 4$ 这个值是否 $\\le 1/3$。\n我们可以使用不等式 $1-x \\le \\exp(-x)$，它对所有实数 $x$ 成立。设 $x=1/n$，我们有 $1 - \\frac{1}{n} \\le \\exp(-1/n)$。\n因此，$P(\\text{error}) = \\left(1 - \\frac{1}{n}\\right)^{2n} \\le \\left(\\exp\\left(-\\frac{1}{n}\\right)\\right)^{2n} = \\exp(-2)$。\n$\\exp(-2)$ 的值约等于 $0.135$。由于 $0.135  1/3$，错误概率被适当地界定了。\n该算法的运行时间是 $2n$ 次迭代，每次迭代都涉及计算一个度，这需要 $O(n)$ 的时间。总运行时间是 $O(n \\cdot n) = O(n^2)$，这是 $n$ 的一个多项式。\n- **结论：**算法 D 在多项式时间内运行，并且对于所有 $n \\ge 4$ 的 YES 和 NO 实例都满足正确性概率。因此，这是一个正确的算法，将该问题置于 **PromiseBPP** 中。\n\n**算法 E 的分析：**\n- 前两个步骤描述了一个确定性的多项式时间算法，该算法计算图的完整度序列。这个过程能以 100% 的准确率正确区分 $P_n$ 和 $K_{1,n-1}$。我们将这个确定性部分的输出称为 $D(G)$。\n- 第三步引入了随机化：算法以 $1/2$ 的概率输出 $D(G)$，并以 $1/2$ 的概率输出其相反结果。\n- **YES 实例 ($G=P_n$)：**$D(G)$ 是 'YES'。算法以 $1/2$ 的概率输出 'YES'。这不满足 $\\ge 2/3$。\n- **NO 实例 ($G=K_{1,n-1}$)：**$D(G)$ 是 'NO'。算法以 $1/2$ 的概率输出 'NO'。这不满足 $\\ge 2/3$。\n- **结论：**算法 E 不正确，因为最后的随机化步骤将其成功概率降低到 $1/2$，低于所要求的 $2/3$ 阈值。\n\n根据分析，只有算法 D 能正确解决该问题。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}