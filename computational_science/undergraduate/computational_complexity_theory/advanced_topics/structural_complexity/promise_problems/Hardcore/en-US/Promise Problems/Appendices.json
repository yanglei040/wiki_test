{
    "hands_on_practices": [
        {
            "introduction": "Our first practice problem explores how a promise can dramatically simplify a computational task, making it solvable with a very efficient algorithm. We will examine a number-theoretic question where the promise allows us to bypass complex factorization methods and instead use a simple property of binary representations. This exercise  is a classic introduction to the power of promise problems and the complexity class PromiseP.",
            "id": "1437599",
            "problem": "In computational complexity theory, a **promise problem** is a generalization of a decision problem where the input is guaranteed to be from a specific subset of all possible inputs, called the \"promise\". A promise problem is defined by a pair of disjoint sets of inputs, $(\\Pi_{YES}, \\Pi_{NO})$. An algorithm is said to solve the promise problem if it accepts all inputs in $\\Pi_{YES}$ and rejects all inputs in $\\Pi_{NO}$. The algorithm's behavior on inputs outside the promise (i.e., not in $\\Pi_{YES} \\cup \\Pi_{NO}$) is not specified.\n\nConsider the following promise problem, which we will call `EVALUATE_BASE`:\n\n**Input:** An integer $n > 1$, provided as a binary string.\n\n**Promise:** The input integer $n$ is a perfect power of a single prime number. That is, $n = p^k$ for some prime number $p$ and some integer $k \\ge 1$.\n\n**Question:** Is the prime base $p$ of the input integer $n$ equal to 2?\n\nIdentify the lowest-complexity class from the options below that is known to contain the `EVALUATE_BASE` promise problem. For the purpose of this question, a class A is considered \"lower\" than class B if A is a known proper subset of B (for example, P is lower than NP).\n\nA. P (the class of problems solvable by a deterministic Turing machine in polynomial time)\n\nB. NP (the class of problems for which a 'yes' answer has a proof verifiable in polynomial time)\n\nC. co-NP (the class of problems for which a 'no' answer has a proof verifiable in polynomial time)\n\nD. NP-complete\n\nE. Undecidable",
            "solution": "We are given an input integer $n>1$ in binary, with the promise that there exist a prime $p$ and an integer $k \\ge 1$ such that $n = p^{k}$. The question is whether $p=2$.\n\nEquivalently, we must decide whether $n$ is a power of $2$, i.e., whether there exists an integer $t \\ge 1$ such that $n = 2^{t}$. Define the set\n$$\nS \\equiv \\{\\, 2^{t} : t \\ge 1 \\,\\}.\n$$\nThe promise problem asks whether $n \\in S$ under the given promise that $n$ is a prime power.\n\nKey characterization (binary test):\nFor any integer $m>0$,\n$$\nm \\in \\{ 2^{t} : t \\ge 0 \\} \\quad \\Longleftrightarrow \\quad \\text{the binary representation of } m \\text{ contains exactly one digit } 1.\n$$\nProof:\n- If $m=2^{t}$, then in base $2$, $m$ is $1$ followed by $t$ zeros, hence it has exactly one $1$.\n- Conversely, if the binary representation of $m$ has exactly one $1$, located at position $t$ (counting from $0$ for the least significant bit), then $m = 2^{t}$ by the uniqueness of base-$2$ representation.\n\nSince the input satisfies $n>1$, the relevant exponents are $t \\ge 1$. Therefore,\n$$\nn \\in S \\quad \\Longleftrightarrow \\quad \\text{the binary representation of } n \\text{ has exactly one } 1 \\text{ and length at least } 2.\n$$\n\nAlgorithm (deterministic):\n- On input the binary string $x$ encoding $n$, compute the count $c$ of the symbol $1$ in $x$ and the length $\\ell = |x|$.\n- Accept if and only if $c=1$ and $\\ell \\ge 2$.\n\nCorrectness under the promise:\n- If $p=2$, then $n=2^{k}$ with $k \\ge 1$, so $n \\in S$, and the binary representation of $n$ has exactly one $1$; the algorithm accepts.\n- If $p \\neq 2$, then $p$ is an odd prime and $n=p^{k}$ is odd and greater than $1$. Any odd integer greater than $1$ cannot be a power of $2$, hence its binary representation cannot have exactly one $1$. Thus the algorithm rejects. Therefore, on all promised inputs, the algorithm answers correctly.\n\nTime complexity:\nLet $\\ell=|x|$ denote the input length in bits. Counting the number of $1$ symbols in $x$ runs in $O(\\ell)$ time, which is polynomial in the input length. Hence the problem is solvable in deterministic polynomial time.\n\nConclusion:\nThe promise problem EVALUATE_BASE is in class P. Among the given options, P is the lowest class known to contain the problem.\n\nTherefore, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Moving beyond deterministic algorithms, this next exercise delves into the world of randomized computation and the class PromiseBPP. Here, the promise is used to create a clear distinction between two types of graphs, but finding the distinction requires a clever probabilistic approach. This problem  challenges you to think not just about correctness, but about achieving a high probability of correctness within polynomial time.",
            "id": "1437609",
            "problem": "Consider the promise problem known as `PATH_vs_STAR`. An input to this problem is an undirected graph $G = (V,E)$ on $n \\ge 4$ vertices, which is provided in the form of an adjacency matrix. You are given a promise that the input graph $G$ is either a path graph $P_n$ or a star graph $K_{1,n-1}$.\n\n- A **path graph** $P_n$ is a graph whose vertices can be listed in a sequence $v_1, v_2, \\ldots, v_n$ such that the edges are exactly $(v_i, v_{i+1})$ for all $i = 1, \\ldots, n-1$.\n- A **star graph** $K_{1,n-1}$ is a graph that has a central vertex connected to all other $n-1$ vertices, and these are the only edges.\n\nThe goal is to design an algorithm that decides which type of graph $G$ is. Specifically, if $G$ is a path graph, the algorithm should output 'YES', and if $G$ is a star graph, it should output 'NO'.\n\nA promise problem $(\\Pi_{YES}, \\Pi_{NO})$, where $\\Pi_{YES}$ is the set of 'YES' instances (here, all $P_n$ graphs) and $\\Pi_{NO}$ is the set of 'NO' instances (all $K_{1,n-1}$ graphs), belongs to the complexity class PromiseBPP (Bounded-error Probabilistic Polynomial time) if it can be solved by a randomized algorithm that runs in polynomial time and satisfies the following conditions for any valid input $G$:\n- If $G \\in \\Pi_{YES}$, the algorithm outputs 'YES' with a probability of at least $2/3$.\n- If $G \\in \\Pi_{NO}$, the algorithm outputs 'NO' with a probability of at least $2/3$.\n\nWhich of the following randomized algorithms correctly solves the `PATH_vs_STAR` promise problem and demonstrates that it is in PromiseBPP for all $n \\ge 4$?\n\nA. **Algorithm A:**\n1. Pick a single vertex $v$ uniformly at random from $V$.\n2. Compute its degree, $\\deg(v)$.\n3. If $\\deg(v) = 2$, output 'YES'.\n4. Otherwise, output 'NO'.\n\nB. **Algorithm B:**\n1. Pick two distinct vertices, $u$ and $v$, uniformly at random from $V$.\n2. Compute their degrees, $\\deg(u)$ and $\\deg(v)$.\n3. If both $\\deg(u)=1$ and $\\deg(v)=1$, output 'NO'.\n4. Otherwise, output 'YES'.\n\nC. **Algorithm C:**\n1. Repeat 5 times:\n   a. Pick a vertex $v$ uniformly at random from $V$.\n   b. If $\\deg(v) \\ge 3$, output 'NO' and halt.\n2. If the loop completes without halting, output 'YES'.\n\nD. **Algorithm D:**\n1. Repeat $2n$ times:\n   a. Pick a vertex $v$ uniformly at random from $V$.\n   b. If $\\deg(v) \\ge 3$, output 'NO' and halt.\n2. If the loop completes without halting, output 'YES'.\n\nE. **Algorithm E:**\n1. Compute the degree of all $n$ vertices.\n2. If exactly two vertices have degree 1 and the other $n-2$ vertices have degree 2, prepare to output 'YES'. Otherwise, prepare to output 'NO'.\n3. Flip a fair coin. If it is heads, output the prepared answer. If it is tails, output the opposite of the prepared answer.",
            "solution": "To determine which algorithm solves the `PATH_vs_STAR` promise problem in PromiseBPP, we must analyze each proposed algorithm against the problem's requirements for all $n \\ge 4$. The requirements are: polynomial runtime, probability of correctness $\\ge 2/3$ for both YES and NO instances. The time to compute the degree of a single vertex from an $n \\times n$ adjacency matrix is $O(n)$.\n\nFirst, let's establish the degree properties of the graphs for $n \\ge 4$:\n- A path graph $P_n$ has two vertices of degree 1 (the endpoints) and $n-2$ vertices of degree 2. The maximum degree is 2.\n- A star graph $K_{1,n-1}$ has one central vertex of degree $n-1$ and $n-1$ leaf vertices of degree 1. Since $n \\ge 4$, the degree of the central vertex is $n-1 \\ge 3$. The maximum degree is $n-1$.\n\nThe key distinction is that a path graph has a maximum degree of 2, while a star graph has a maximum degree of at least 3. Any vertex with degree $\\ge 3$ immediately identifies the graph as a star graph. Any vertex with degree 2 immediately identifies the graph as a path graph.\n\n**Analysis of Algorithm A:**\n- **YES instance ($G=P_n$):** The algorithm outputs 'YES' only if it picks a vertex of degree 2. There are $n-2$ such vertices. The probability of outputting 'YES' is $\\frac{n-2}{n} = 1 - \\frac{2}{n}$. We require this probability to be at least $2/3$. So, $1 - \\frac{2}{n} \\ge \\frac{2}{3} \\implies \\frac{1}{3} \\ge \\frac{2}{n} \\implies n \\ge 6$. The algorithm fails for $n=4$ (prob=$1/2$) and $n=5$ (prob=$3/5$), as these probabilities are less than $2/3$.\n- **Conclusion:** Algorithm A is incorrect.\n\n**Analysis of Algorithm B:**\n- **NO instance ($G=K_{1,n-1}$):** The algorithm outputs 'NO' if it picks two vertices of degree 1. There are $n-1$ such vertices. The probability of this event is $\\frac{\\binom{n-1}{2}}{\\binom{n}{2}} = \\frac{(n-1)(n-2)/2}{n(n-1)/2} = \\frac{n-2}{n} = 1 - \\frac{2}{n}$. This is the probability of correctly outputting 'NO'. As with Algorithm A, this probability is only $\\ge 2/3$ for $n \\ge 6$. It fails for $n=4, 5$.\n- **Conclusion:** Algorithm B is incorrect.\n\n**Analysis of Algorithm C:**\n- **YES instance ($G=P_n$):** The maximum degree in $P_n$ is 2. The condition $\\deg(v) \\ge 3$ is never met. The algorithm will always complete the loop and output 'YES'. The probability of correctness is 1, which is $\\ge 2/3$. This part is correct.\n- **NO instance ($G=K_{1,n-1}$):** The algorithm makes an error if it fails to pick the single central vertex (degree $n-1 \\ge 3$) in all 5 trials. The probability of picking the central vertex in one trial is $1/n$. The probability of not picking it is $1 - 1/n$. The probability of error (outputting 'YES') is the probability of not picking the center in 5 independent trials, which is $\\left(1 - \\frac{1}{n}\\right)^5$. We need this error probability to be $\\le 1/3$. However, as $n$ becomes large, $\\left(1 - \\frac{1}{n}\\right)^5$ approaches $1$. For example, if $n=10$, the error probability is $(0.9)^5 \\approx 0.59$, which is greater than $1/3$.\n- **Conclusion:** Algorithm C is incorrect because its error probability on NO instances is not bounded by $1/3$ for all $n \\ge 4$.\n\n**Analysis of Algorithm D:**\n- **YES instance ($G=P_n$):** Similar to Algorithm C, the maximum degree is 2, so the condition $\\deg(v) \\ge 3$ is never met. The algorithm always outputs 'YES'. The probability of correctness is 1. This is correct.\n- **NO instance ($G=K_{1,n-1}$):** The algorithm makes an error if it fails to pick the central vertex in any of the $2n$ trials. The probability of error is $P(\\text{error}) = \\left(1 - \\frac{1}{n}\\right)^{2n}$. We need to check if this is $\\le 1/3$ for all $n \\ge 4$.\nWe can use the inequality $1-x \\le \\exp(-x)$ for all real $x$. Setting $x=1/n$, we have $1 - \\frac{1}{n} \\le \\exp(-1/n)$.\nTherefore, $P(\\text{error}) = \\left(1 - \\frac{1}{n}\\right)^{2n} \\le \\left(\\exp\\left(-\\frac{1}{n}\\right)\\right)^{2n} = \\exp(-2)$.\nThe value of $\\exp(-2)$ is approximately $0.135$. Since $0.135  1/3$, the error probability is properly bounded.\nThe runtime of the algorithm is $2n$ iterations, and each iteration involves computing a degree, which takes $O(n)$ time. The total runtime is $O(n \\cdot n) = O(n^2)$, which is a polynomial in $n$.\n- **Conclusion:** Algorithm D runs in polynomial time and satisfies the correctness probabilities for both YES and NO instances for all $n \\ge 4$. Thus, it is a correct algorithm that places the problem in PromiseBPP.\n\n**Analysis of Algorithm E:**\n- The first two steps describe a deterministic polynomial-time algorithm that computes the entire degree sequence of the graph. This procedure correctly distinguishes between $P_n$ and $K_{1,n-1}$ with 100% accuracy. Let's call the output of this deterministic part $D(G)$.\n- The third step introduces randomization: the algorithm outputs $D(G)$ with probability $1/2$ and its opposite with probability $1/2$.\n- **YES instance ($G=P_n$):** $D(G)$ is 'YES'. The algorithm outputs 'YES' with probability $1/2$. This is not $\\ge 2/3$.\n- **NO instance ($G=K_{1,n-1}$):** $D(G)$ is 'NO'. The algorithm outputs 'NO' with probability $1/2$. This is not $\\ge 2/3$.\n- **Conclusion:** Algorithm E is incorrect because the final randomization step reduces its success probability to $1/2$, which is below the required threshold of $2/3$.\n\nBased on the analysis, only Algorithm D correctly solves the problem.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "This final practice problem reveals the most profound implication of promise problems: their ability to alter the very boundary of what is computable. We will confront a question related to the infamous Halting Problem, which is undecidable in its general form. By introducing a carefully crafted, non-trivial promise, we will see how this seemingly impossible task becomes decidable , highlighting the crucial role promises play in theoretical computer science.",
            "id": "1437602",
            "problem": "A promise problem is a computational task defined by a pair of disjoint sets of strings, $(L_{YES}, L_{NO})$. A Turing Machine (TM) is said to decide this promise problem if, for any input string $x$, it halts and accepts if $x \\in L_{YES}$, and it halts and rejects if $x \\in L_{NO}$. The behavior of the TM on inputs not in $L_{YES} \\cup L_{NO}$ is not specified.\n\nLet $w_0$ be the fixed binary string \"0101\". Consider a promise problem $\\mathcal{P} = (L_{YES}, L_{NO})$ related to the behavior of TMs. An input to this problem is the encoding of a TM, denoted $\\langle M \\rangle$. The promise is that any given TM $M$ for this problem is guaranteed to halt on all input strings $w'$ whose length is equal to the length of $w_0$ (i.e., $|w'| = |w_0| = 4$).\n\nThe sets for the promise problem $\\mathcal{P}$ are defined as follows:\n- $L_{YES} = \\{ \\langle M \\rangle \\mid \\text{TM } M \\text{ accepts } w_0 \\text{ and halts on all strings of length 4} \\}$\n- $L_{NO} = \\{ \\langle M \\rangle \\mid \\text{TM } M \\text{ does not accept } w_0 \\text{ and halts on all strings of length 4} \\}$\n\nThe question is to determine the computational nature of distinguishing between instances in $L_{YES}$ and $L_{NO}$, given the promise that the input is always in $L_{YES} \\cup L_{NO}$.\n\nWhich of the following statements correctly describes the complexity of this promise problem $\\mathcal{P}$?\n\nA. The promise problem is decidable.\n\nB. The promise problem is undecidable, but belongs to the complexity class RE (Turing-recognizable).\n\nC. The promise problem is undecidable, but belongs to the complexity class co-RE.\n\nD. The promise problem is undecidable, and belongs to neither RE nor co-RE.",
            "solution": "The problem asks for the decidability of a promise problem $\\mathcal{P} = (L_{YES}, L_{NO})$. An algorithm decides this problem if it correctly distinguishes inputs from $L_{YES}$ and $L_{NO}$, under the guarantee that the input will be one of these.\n\nLet's analyze the structure of the problem. We are given the encoding of a Turing Machine, $\\langle M \\rangle$, and we are promised that this TM $M$ halts on all input strings of length 4. The specific string in question is $w_0 = 0101$, which has length 4.\n\nThe promise is the key piece of information. Since we are guaranteed that $M$ halts on all strings of length 4, this guarantee applies specifically to the string $w_0 = 0101$. Therefore, for any input $\\langle M \\rangle$ that adheres to the promise, we know for certain that the computation of $M$ on input $w_0$ will terminate.\n\nBased on this insight, we can construct a Turing Machine, let's call it $D$, to solve this promise problem. The algorithm for $D$ is as follows:\nOn input $\\langle M \\rangle$:\n1. $D$ takes the encoding $\\langle M \\rangle$ and the fixed string $w_0 = 0101$.\n2. $D$ simulates the execution of the TM $M$ on the input string $w_0$.\n3. Because the input $\\langle M \\rangle$ is promised to be in $L_{YES} \\cup L_{NO}$, the TM $M$ is guaranteed to halt on $w_0$. Consequently, the simulation performed by $D$ is guaranteed to terminate.\n4. When the simulation of $M(w_0)$ halts, $D$ inspects the result:\n   - If $M$ halts in an accepting state, it means $\\langle M \\rangle \\in L_{YES}$. In this case, $D$ halts and accepts.\n   - If $M$ halts in a rejecting state, it means $M$ does not accept $w_0$, so $\\langle M \\rangle \\in L_{NO}$. In this case, $D$ halts and rejects.\n\nThe TM $D$ described above qualifies as a decider for the promise problem $\\mathcal{P}$. For any input $\\langle M \\rangle$ from the promised set $L_{YES} \\cup L_{NO}$, $D$ always halts and provides the correct answer: it accepts for inputs in $L_{YES}$ and rejects for inputs in $L_{NO}$. Therefore, the promise problem $\\mathcal{P}$ is decidable.\n\nIt is important to contrast this with related undecidable problems to understand why the other options are incorrect.\n- Without the promise, the problem of deciding whether an arbitrary TM $M$ accepts a fixed string $w_0$ (the language $A_{TM}^{w_0} = \\{ \\langle M \\rangle \\mid M \\text{ accepts } w_0 \\}$) is undecidable. This problem is, however, Turing-recognizable (in RE), as one can simulate $M$ on $w_0$ and accept if it accepts. If $M$ loops or rejects, the recognizer might not halt. A student confusing our problem with this standard one might incorrectly choose option B.\n- The crucial error would be to think that the decider $D$ must first verify the promise. The problem of verifying the promise, i.e., deciding the language $P_4 = \\{ \\langle M \\rangle \\mid M \\text{ halts on all strings of length 4} \\}$, is itself highly undecidable (beyond RE and co-RE). A TM that decides $P_4$ would have to solve the halting problem for $M$ on $2^4 = 16$ different inputs. By Rice's theorem, any non-trivial property of the language of a TM is undecidable. Even though this promise is about the TM's behavior, not just its language, it can be shown to be undecidable. One who thinks the promise must be verified might incorrectly choose option D.\n\nHowever, the definition of a promise problem absolves us of this responsibility. We are *given* that the input satisfies the promise, which is powerful enough to make an otherwise undecidable problem decidable.\n\nThus, the existence of the always-halting decider $D$ proves that the promise problem is decidable.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}