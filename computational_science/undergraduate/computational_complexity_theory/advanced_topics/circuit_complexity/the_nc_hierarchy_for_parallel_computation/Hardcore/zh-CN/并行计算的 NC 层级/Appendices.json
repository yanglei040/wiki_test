{
    "hands_on_practices": [
        {
            "introduction": "理解NC层次结构最好的方法之一就是对具体问题进行分类。这个练习着眼于NC层次结构中最基础的类别，$NC^0$。格雷码转换问题是一个绝佳的范例，因为它的计算具有高度的局部性，每个输出位仅依赖于常数个输入位，这使其可以被极高效率地并行化，完美诠释了常数深度电路的核心思想。",
            "id": "1459534",
            "problem": "在计算复杂性理论领域，NC 层次（Nick's Class）用于对被认为是“可高效并行化”的问题进行分类。如果一个问题可以由一个一致的布尔电路族解决，该电路族的规模是输入规模 $n$ 的多项式，深度是多对数，具体为 $O(\\log^k n)$，则称该问题属于类 $NC^k$。类 $NC^0$ 对应于可用常数深度、多项式规模的电路解决的问题，其中每个输出位仅依赖于常数个输入位。\n\n考虑将一个$n$位二进制整数转换为其对应的$n$位反射二进制码（也称为格雷码）的问题。设输入二进制表示为 $B = b_{n-1}b_{n-2}...b_1b_0$，输出格雷码为 $G = g_{n-1}g_{n-2}...g_1g_0$。转换由以下规则定义：\n- 最高有效位保持不变：$g_{n-1} = b_{n-1}$。\n- 对于所有其他位（其中 $0 \\le i  n-1$），格雷码位是相应二进制位与更高一位的二进制位的异或（XOR）：$g_i = b_i \\oplus b_{i+1}$。\n\n根据所提供的定义，确定此转换问题在 NC 层次中的最精确分类。\n\nA. 该问题在 $NC^0$ 中。\nB. 该问题在 $NC^1$ 中，但不在 $NC^0$ 中。\nC. 该问题在 $NC^2$ 中，但不在 $NC^1$ 中。\nD. 该问题是 P-完全的，因此被认为不属于任何 $NC^k$ 类。\nE. 分类取决于 $n$ 是否为 2 的幂。",
            "solution": "我们需要在 NC 层次中，对从一个 $n$ 位二进制数 $B = b_{n-1}b_{n-2}\\dots b_1b_0$ 到其 $n$ 位格雷码 $G = g_{n-1}g_{n-2}\\dots g_1g_0$ 的映射进行分类，该映射定义为\n$$\ng_{n-1} = b_{n-1}, \\quad g_i = b_i \\oplus b_{i+1} \\quad \\text{for } 0 \\leq i  n-1.\n$$\n根据定义，一个语言（或函数）属于 $NC^k$，如果存在一个规模为多项式、深度为 $O(\\log^k n)$ 的一致布尔电路族来计算它，且扇入有界。$NC^0$ 类由可通过一致的、具有有界扇入的常数深度、多项式规模电路计算的函数组成，等价地，其中每个输出位仅依赖于 $O(1)$ 个输入位。\n\n对于每个 $0 \\leq i  n-1$ 的 $i$，输出位 $g_i$ 仅依赖于两个输入位 $b_i$ 和 $b_{i+1}$，而对于 $i = n-1$，我们有 $g_{n-1}$ 仅依赖于 $b_{n-1}$。因此，每个输出位都依赖于常数个输入，与 $n$ 无关。此外，每个 $g_i$ 都可以由一个基于 $\\{\\land,\\lor,\\neg\\}$ 的常数深度、有界扇入电路计算，因为两个位的异或具有标准的布尔表达式\n$$\nb_i \\oplus b_{i+1} = (b_i \\land \\neg b_{i+1}) \\lor (\\neg b_i \\land b_{i+1}).\n$$\n该实现最多使用一层非门，其输出馈给一层二元 $\\land$ 门，再馈给一个二元 $\\lor$ 门，从而得到常数深度（例如，在有界扇入为 $2$ 的情况下深度为 $3$）。最高有效位 $g_{n-1} = b_{n-1}$ 是通过一根导线实现的。因此，并行计算所有 $n$ 个输出位得到的电路深度是一个与 $n$ 无关的固定常数，规模为 $O(n)$，即 $n$ 的多项式。\n\n关于一致性，布线模式是完全规则的：对于每个 $i$，计算 $g_i$ 的门仅连接到 $b_i$ 和 $b_{i+1}$（或当 $i = n-1$ 时仅连接到 $b_{n-1}$）。因此，一个标准的一致性条件（例如 DLOGTIME-uniformity）是满足的，因为一台确定性图灵机，在给定以二进制编码的 $n$ 和门索引时，可以在 $O(\\log n)$ 时间内计算出连接关系。\n\n因此，该转换映射可由一个一致的、常数深度、多项式规模、有界扇入的布尔电路族计算，其中每个输出位都依赖于 $O(1)$ 个输入位。因此，该问题属于 $NC^0$。由于 $NC^0 \\subseteq NC^1 \\subseteq NC^2 \\subseteq \\dots$，在给定的选项中，最精确的分类是它属于 $NC^0$。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在我们沿着NC层次结构向上移动到$NC^1$。与格雷码转换不同，许多问题的解决需要整合来自整个输入的信息，这看似是一个顺序过程。这个寻找二进制串中第一个“1”位置的练习，将向你展示一种强大的并行计算技巧——前缀扫描（prefix scan），它能让我们在对数时间内解决这类问题，揭示了看似顺序的问题背后所蕴含的并行性。",
            "id": "1459518",
            "problem": "在并行计算领域，理解一个问题内在的并行性对于设计高效算法至关重要。被称为尼克类（Nick's Class, NC）的复杂性类为此分析提供了一个框架。如果一个计算问题可以在并行计算机上，使用多项式于 $n$ 的处理器数量，在多对数时间（即时间与 $O(\\log^k n)$ 成正比，其中 $k$ 是某个常数，$n$ 是输入大小）内解决，则称该问题属于NC。更具体地说，如果一个问题的并行时间复杂度是 $O(\\log^k n)$，那么它就在 $NC^k$ 中。\n\n考虑基本的“找到第一个1”（First-One）问题，这是并行数据处理中一个常见的子程序。该问题定义如下：给定一个长度为 $n$ 的二进制字符串 $S$，表示为一个比特数组 $S[1..n]$，找到满足 $S[i]=1$ 的最小索引 $i$。如果字符串中不包含'1'，则输出应为0。\n\n根据这些定义，确定“找到第一个1”问题在NC层次结构中最精确的分类。\n\nA. 该问题属于 NC$^1$。\nB. 该问题是P-完备的，这意味着它不太可能属于NC。\nC. 即使在并行机上，解决该问题也需要 $\\Omega(n)$ 的时间，因此不属于NC。\nD. 该问题属于 NC$^2$ 但不属于 NC$^1$。",
            "solution": "我们回顾NC的定义：如果一个问题可以在 $O(\\log^k n)$ 时间内（对于某个固定的 $k \\in \\mathbb{N}$），使用多项式于 $n$ 的处理器数量解决，则该问题属于NC。$NC^1$ 类包含那些可以使用多项式数量的处理器和有界扇入，以 $O(\\log n)$ 的深度解决的问题。\n\n我们为“找到第一个1”函数构建一个深度为 $O(\\log n)$ 的并行算法。设输入为 $S[1],\\dots,S[n] \\in \\{0,1\\}$。定义前缀或（prefix-OR）数组 $Q[1],\\dots,Q[n]$ 为\n$$\nQ[i] \\equiv \\bigvee_{j=1}^{i} S[j].\n$$\n布尔或（OR）运算是可结合的，因此我们可以使用标准的并行前缀方法，在 $O(\\log n)$ 的深度和多项式的工作量内计算出所有的 $Q[i]$。一种具体的方法是递归倍增法（recursive doubling）：定义 $R^{(0)}[i] = S[i]$ 对所有 $i$ 成立，并且对于 $t=1,2,\\dots,\\lceil \\log_2 n \\rceil$ 设置\n$$\nR^{(t)}[i] = \\begin{cases}\nR^{(t-1)}[i] \\lor R^{(t-1)}[i-2^{t-1}],   \\text{if } i2^{t-1}, \\\\\nR^{(t-1)}[i],  \\text{otherwise}.\n\\end{cases}\n$$\n每个阶段只使用扇入为2的或门，因此具有常数深度，并且总共有 $\\lceil \\log_2 n \\rceil$ 个阶段。最后，$Q[i] = R^{(\\lceil \\log_2 n \\rceil)}[i]$ 对所有 $i$ 成立，总深度为 $O(\\log n)$，每个阶段使用 $O(n)$ 个处理器，因此总处理器数量是多项式的。\n\n引入 $Q[0] \\equiv 0$ 并定义标记数组 $M[1],\\dots,M[n]$ 为\n$$\nM[i] \\equiv S[i] \\land \\lnot Q[i-1] = Q[i] \\land \\lnot Q[i-1].\n$$\n根据构造，$M[i]=1$ 当且仅当 $i$ 是满足 $S[i]=1$ 的最小索引；否则 $M[i]=0$。如果字符串中没有1，那么 $Q[n]=0$，因此对所有 $i$ 都有 $M[i]=0$。\n\n我们现在将索引编码为 $\\{0,1,\\dots,n\\}$ 范围内的二进制数。令 $L \\equiv \\lceil \\log_2(n+1) \\rceil$。对于每个比特位置 $b \\in \\{0,1,\\dots,L-1\\}$，定义第 $b$ 个输出比特 $B[b]$ 为\n$$\nB[b] \\equiv \\bigvee_{i=1}^{n} \\left( M[i] \\land \\mathrm{bit}_{b}(i) \\right),\n$$\n其中 $\\mathrm{bit}_{b}(i) \\in \\{0,1\\}$ 是 $i$ 的第 $b$ 个二进制位。因为至多有一个 $M[i]$ 等于1，所以这些或规约（OR-reductions）操作只是选择了那个唯一索引的比特位；如果所有的 $M[i]=0$，那么所有的 $B[b]=0$，表示0。每个 $B[b]$ 是对 $n$ 项的或运算，可以通过组织成平衡二叉树的扇入为2的或门来实现，其深度为 $O(\\log n)$。所有 $L$ 个比特是并行计算的，所以这个阶段的深度仍然是 $O(\\log n)$，处理器数量为 $O(n L)$，这是 $n$ 的多项式。\n\n结合各个阶段，总并行时间（电路深度）为\n$$\nO(\\log n) + O(1) + O(\\log n) = O(\\log n),\n$$\n处理器数量是 $n$ 的多项式，且门具有有界扇入。因此，“找到第一个1”问题属于 $NC^1$。\n\n这表明选项A是正确的。选项B是错误的，因为该问题不是P-完备的；它有一个 $NC^1$ 算法。选项C是错误的，因为上述算法在并行机上以 $O(\\log n)$ 的时间运行。选项D是错误的，因为我们已经展示了一个 $NC^1$ 算法；此外，已知的类分离结果并未将其置于 $NC^1$ 之外。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了如何分析单个问题的并行复杂度后，我们来探讨一个更宏观的问题：如何构建复杂的并行算法。本练习将探讨NC类的一个基本“闭包”性质，即高效的并行算法在组合之后是否仍然高效。理解将$NC^1$中的算法模块组合起来，其结果仍然在$NC^1$中，这对于从模块化组件设计复杂的并行系统至关重要。",
            "id": "1459527",
            "problem": "在并行计算理论中，被称为尼克类（Nick's Class, NC）的复杂度类提供了一个框架，用于识别那些可以在并行计算机上高效解决的问题。如果一个问题可以由一个满足两个关键属性的一致布尔电路族解决，那么对于某个整数 $k \\ge 0$，该问题就被认为属于 $NC^k$ 类。对于大小为 $n$ 的输入，电路必须具备：\n1.  大小（门电路的数量）是 $n$ 的多项式，即 $n^{O(1)}$。\n2.  深度（从输入到输出的最长路径）是 $n$ 的多对数，具体为 $O(\\log^k n)$。\n这些电路中的门被假定具有恒定的扇入数（输入的数量，通常为 2）。\n\n考虑两个函数 $f$ 和 $g$，它们都将比特串映射到比特串。已知这两个函数都可以由属于复杂度类 $NC^1$ 的算法计算。通过将这两个函数链接在一起，创建了一个新的复合函数 $h$，使得对于任何输入的比特串 $x$，其输出为 $h(x) = g(f(x))$。\n\n根据电路复合的性质，对于复合函数 $h$ 最紧确和最准确的分类是什么？\n\nA. $NC^0$\nB. $NC^1$\nC. $NC^2$\nD. P\nE. 不必然属于任何 NC 类。",
            "solution": "设 $f:\\{0,1\\}^n \\to \\{0,1\\}^{m(n)}$ 和 $g:\\{0,1\\}^m \\to \\{0,1\\}^{\\ell(m)}$ 可由一致 $NC^1$ 电路族计算。根据定义，存在电路族 $\\{C_{f,n}\\}$ 和 $\\{C_{g,m}\\}$，它们具有以下性质：\n- 大小界限：$\\mathrm{size}(C_{f,n}) = n^{O(1)}$ 和 $\\mathrm{size}(C_{g,m}) = m^{O(1)}$。\n- 深度界限：$\\mathrm{depth}(C_{f,n}) = O(\\log n)$ 和 $\\mathrm{depth}(C_{g,m}) = O(\\log m)$。\n- 所有门都具有恒定的扇入数。\n\n由于 $C_{f,n}$ 的大小是关于 $n$ 的多项式，其输出位数 $m(n)$ 必须满足 $m(n) \\le n^{O(1)}$；否则，电路的多项式大小的描述甚至不足以表示那么多的输出位。\n\n定义复合函数 $h(x) = g(f(x))$。为了计算在长度为 $n$ 的输入上 $h$ 的值，我们构造电路 $C_{h,n}$，方法是将 $C_{f,n}$ 的 $m(n)$ 个输出作为 $C_{g,m(n)}$ 的 $m(n)$ 个输入。于是：\n- 大小满足\n$$\n\\mathrm{size}(C_{h,n}) \\le \\mathrm{size}(C_{f,n}) + \\mathrm{size}(C_{g,m(n)}) = n^{O(1)} + (m(n))^{O(1)} = n^{O(1)},\n$$\n因为 $m(n) \\le n^{O(1)}$ 意味着 $(m(n))^{O(1)} = n^{O(1)}$。\n- 深度满足\n$$\n\\mathrm{depth}(C_{h,n}) \\le \\mathrm{depth}(C_{f,n}) + \\mathrm{depth}(C_{g,m(n)}) = O(\\log n) + O(\\log m(n)).\n$$\n使用 $m(n) \\le n^c$（对于某个常数 $c > 0$），我们有\n$$\n\\log m(n) \\le \\log(n^c) = c \\log n,\n$$\n所以\n$$\n\\mathrm{depth}(C_{h,n}) = O(\\log n).\n$$\n复合电路保留了恒定的扇入数和一致性（标准的一致性概念，如对数空间一致性，在复合操作下是封闭的）。因此，$h$ 可由一个大小为多项式、深度为 $O(\\log n)$、扇入数为恒定的一致电路族计算，即 $h \\in NC^1$。\n\n这个分类是紧确的：通常情况下，复合两个非平凡的 $NC^1$ 函数不会使深度降至 $O(1)$，因此 $NC^0$ 太小；而 $NC^2$ 和 P 虽然是有效的超集，但它们不是最紧确的分类。\n\n因此，最紧确和最准确的分类是 $NC^1$。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}