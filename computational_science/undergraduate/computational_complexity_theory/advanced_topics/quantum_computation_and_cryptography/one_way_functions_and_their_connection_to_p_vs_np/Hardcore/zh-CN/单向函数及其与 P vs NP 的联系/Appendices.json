{
    "hands_on_practices": [
        {
            "introduction": "要真正理解什么让一个函数“难以求逆”，从一个明显容易求逆的函数开始会很有帮助。第一个练习  将研究一个简单的位操作函数。通过从输出反推输入，你将亲身体会到为什么具有简单、可预测的逆运算的函数不能被视为单向函数。",
            "id": "1433133",
            "problem": "在计算复杂性理论的研究中，单向函数是一种对每个输入都易于计算，但对随机输出平均而言难以求逆的函数。形式上，如果一个函数 $f$ 可以在多项式时间内计算，但没有概率多项式时间算法能够对不可忽略部分的输入 $x$ 找到 $f(x)$ 的一个原像，那么它就是单向函数的候选者。\n\n考虑一个为密码学应用提出的函数 `SHIFT_L(x, k, n)`。该函数接受一个 $n$ 位无符号整数 $x$，并将其二进制表示循环左移 $k$ 个位置。例如，如果 $n=8$ 且输入整数的二进制表示为 `11010010`，则当 $k=2$ 时，`SHIFT_L` 会产生二进制数 `01001011`。\n\n一位分析师的任务是评估此函数作为单向函数的适用性。他们得到了一个输出整数 $y=43$，这个数是通过对某个未知的原始整数 $x$ 计算 $y = \\text{SHIFT\\_L}(x, k, n)$ 生成的。使用的参数是 $n=8$ 和 $k=3$。为了证明该函数不是单向的，分析师必须高效地找到原始整数 $x$。\n\n原始整数 $x$ 的值是多少？",
            "solution": "我们将该操作形式化如下。设 $x$ 的一个 $n$ 位向量写为 $(x_{n-1},\\dots,x_{0})$，其中 $x_{n-1}$ 是最高有效位。定义循环左旋 $k$ 个位置的操作 $\\operatorname{LROT}_{n,k}$ 为\n$$\n\\operatorname{LROT}_{n,k}(x)_{i} = x_{(i-k)\\bmod n}, \\quad i\\in\\{0,1,\\dots,n-1\\}。\n$$\n这是对 $\\{0,1\\}^{n}$ 的一个置换，因此是可逆的，其逆运算由循环右旋 $k$ 个位置的操作 $\\operatorname{RROT}_{n,k}$ 给出：\n$$\n\\operatorname{RROT}_{n,k} = \\operatorname{LROT}_{n,k}^{-1}, \\qquad \\operatorname{RROT}_{n,k}(y)_{i} = y_{(i+k)\\bmod n}。\n$$\n给定 $y=\\operatorname{LROT}_{8,3}(x)$ 且 $y=43$，我们通过计算 $x=\\operatorname{RROT}_{8,3}(y)$ 来求逆。\n\n首先，将 $y$ 写成8位二进制形式。由于\n$$\n43 = 2^{5} + 2^{3} + 2^{1} + 2^{0}，\n$$\n其8位向量（最高有效位在前）是\n$$\ny = (y_{7},y_{6},y_{5},y_{4},y_{3},y_{2},y_{1},y_{0}) = (0,0,1,0,1,0,1,1)。\n$$\n应用 $n=8$ 和 $k=3$ 的逆旋转，\n$$\nx = \\operatorname{RROT}_{8,3}(y) = (y_{2},y_{1},y_{0},y_{7},y_{6},y_{5},y_{4},y_{3}) = (0,1,1,0,0,1,0,1)。\n$$\n将 $x$ 转换回十进制：\n$$\nx = 0\\cdot 2^{7} + 1\\cdot 2^{6} + 1\\cdot 2^{5} + 0\\cdot 2^{4} + 0\\cdot 2^{3} + 1\\cdot 2^{2} + 0\\cdot 2^{1} + 1\\cdot 2^{0} = 64 + 32 + 4 + 1 = 101。\n$$\n因此，原始整数是 $x=101$。",
            "answer": "$$\\boxed{101}$$"
        },
        {
            "introduction": "单向函数常常与著名难题（如整数分解）联系在一起，这可能导致一些常见的误解。这个问题  提出了一个基于乘法的函数，并挑战你找出它不能成为单向函数的那个微妙但关键的原因。这个分析将加深你对“难以求逆”性质精确要求的理解。",
            "id": "1433132",
            "problem": "在计算复杂性理论中，单向函数是一种易于计算但难以求逆的函数。更正式地说，如果一个函数 $f$ 满足以下两个性质，它就是一个候选的单向函数：\n1.  **易于计算**：存在一个多项式时间算法，对于任意给定的有效输入 $x$，该算法可以计算出输出 $f(x)$。这里的“时间”是根据输入的比特长度来衡量的。\n2.  **难以求逆**：对于任何随机化多项式时间算法，当从函数的值域中随机选择一个输出 $y$ 时，该算法成功找到*任何*一个原像 $x'$ 使得 $f(x') = y$ 的概率是可忽略的。\n\n考虑定义为 $f(x, y) = x \\cdot y$ 的函数 $f: \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\to \\mathbb{Z}^+$，其中 $\\mathbb{Z}^+$ 是正整数集合。乍一看，这个函数似乎是一个单向函数，因为它的计算（乘法）非常快，而对于一个合数 $n$ 的逆运算（找到因子 $x$ 和 $y$ 使得 $x \\cdot y = n$）是整数分解问题，该问题被认为对于大数是计算上困难的。\n\n尽管如此，如此定义的函数 $f(x, y) = x \\cdot y$ 绝对**不是**一个单向函数。以下哪个陈述为这一结论提供了最准确和最根本的原因？\n\nA. 整数分解问题已被证明可以在多项式时间内解决，这意味着该函数不难求逆。\n\nB. 该函数不是一对一（单射）的，因为对于任何一对不相等的整数 $x$ 和 $y$，$f(x, y) = f(y, x)$。一个真正的单向函数必须是单射的。\n\nC. 对于函数值域中的任何给定输出 $n$，总能在一个多项式时间内找到产生 $n$ 的特定输入对 $(x, y)$，这违反了“难以求逆”的性质。\n\nD. 当考虑整数的大小时，两个大整数的乘法不是一个多项式时间操作，这违反了“易于计算”的性质。",
            "solution": "我们已知函数 $f:\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}$，其定义为 $f(x,y)=x\\cdot y$。一个单向函数必须易于计算且难以求逆。难以求逆的要求是：给定 $f$ 值域中的一个 $y$，任何随机化多项式时间算法输出任何原像 $(x',y')$ 使得 $f(x',y')=y$ 的概率都应是可忽略的。\n\n考虑以下用于 $f$ 的确定性多项式时间求逆算法 $A$：\n- 对于输入 $n\\in\\mathbb{Z}^{+}$，输出数对 $(1,n)$。\n\n该算法是正确的，因为\n$$\nf(1,n)=1\\cdot n=n.\n$$\n因此，对于 $f$ 值域中的每一个 $n$，$A$ 都能产生一个有效的原像。$A$ 的运行时间是 $n$ 的比特长度的多项式时间，因为构造常数 $1$ 和复制 $n$ 的操作在 $|n|$ 上是多项式时间的。因此，$A$ 在值域中输出 $y$ 的任何分布上的成功概率都是 $1$，这违反了“难以求逆”的性质。\n\n因此，$f(x,y)=x\\cdot y$ 在 $\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}$ 上定义的函数不是单向函数的根本原因是其求逆是平凡的：给定 $n$，数对 $(1,n)$ 始终是一个可在多项式时间内计算出的有效原像。\n\n评估各个选项：\n- A 是错误的；整数分解问题尚未被证明可以在多项式时间内解决。\n- B 是不正确的；单向函数不必须是单射的，非单射性并不妨碍其成为单向函数。\n- C 是正确的；对于任何 $n$，都存在一个平凡的多项式时间原像查找器，即 $(1,n)$。\n- D 是错误的；整数乘法是可以在多项式时间内计算的。\n\n因此，最准确和最根本的原因是C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "单向函数的安全性依赖于它在“平均情况”下难以求逆，而不仅仅是在某些特定的、罕见的情况下。最后一个练习  探讨了一个假设的函数，它对于某个特定输出极难求逆，但对所有其他输出都易如反掌。通过分析其整体安全性，你将理解为什么在极小输出子集上的最坏情况困难度是不够的，以及为什么平均情况困难度的概念是根本性的。",
            "id": "1433092",
            "problem": "在计算复杂性理论中，单向函数（one-way function）是一种易于计算但平均情况下难以求逆的函数。更正式地说，如果一个函数 $f: \\{0,1\\}^* \\to \\{0,1\\}^*$ 满足以下两个性质，则它是一个单向函数：\n\n1.  **易于计算：** 存在一个多项式时间算法，对于任何输入 $x$ 都能计算出 $f(x)$。\n2.  **难以求逆：** 对于每一个概率多项式时间 (PPT) 算法 $\\mathcal{A}$，每一个正多项式 $p$，以及所有足够大的安全参数 $n$，算法 $\\mathcal{A}$ 成功找到 $f(x)$ 的一个原像的概率是可忽略的。也就是说，\n    $$ \\Pr_{x \\leftarrow \\{0,1\\}^n, \\text{coins of } \\mathcal{A}} [\\mathcal{A}(f(x)) \\in f^{-1}(f(x))]  \\frac{1}{p(n)} $$\n    其中 $x$ 是从所有 $n$ 位比特串的集合 $\\{0,1\\}^n$ 中均匀随机选择的。如果一个关于 $n$ 的函数比 $n$ 的任何多项式的倒数下降得更快，那么它被认为是可忽略的。\n\n考虑一个假设的密码学函数 `QuirkHash`，它将 $n$ 位比特串映射到 $n$ 位比特串。`QuirkHash` 已知可以在 $O(n^3)$ 时间内计算。该函数有一个特殊的性质：对于一个非常特定的输出字符串 $y_{special} = 1^n$（一个由 $n$ 个 1 组成的字符串），找到任何原像在计算上是不可行的，并且据信需要指数时间。然而，对于任何输出 $y \\neq y_{special}$，存在一个公开的、确定性的多项式时间算法 `EasyInvert`，可以在 $O(n^4)$ 时间内找到一个原像。\n\n此外，已知映射到特殊输出的输入集合 $C_n = \\{x \\in \\{0,1\\}^n \\mid \\text{QuirkHash}(x) = y_{special}\\}$ 的大小为 $|C_n| = \\lfloor n^2 \\ln(n) \\rfloor$。\n\n一个敌手构建了一个算法 $\\mathcal{A}$ 来求逆 `QuirkHash`。给定一个输出 $y = \\text{QuirkHash}(x)$（对于一个随机选择的 $n$ 位输入 $x$），$\\mathcal{A}$ 的操作如下：\n- 如果 $y \\neq y_{special}$，它运行 `EasyInvert(y)` 并返回结果。\n- 如果 $y = y_{special}$，它放弃并返回 'FAILURE'。\n\n根据单向函数的正式定义，以下哪个陈述正确地对 `QuirkHash` 进行了分类？\n\nA. `QuirkHash` 是一个单向函数，因为至少存在一个输出，其原像难以找到。\n\nB. `QuirkHash` 是一个单向函数，因为遇到难以求逆的情况的概率是可忽略的，这意味着该函数在平均情况下是难以求逆的。\n\nC. `QuirkHash` 不是一个单向函数，因为存在一个概率多项式时间算法能以不可忽略的概率对其求逆。\n\nD. `QuirkHash` 不是一个单向函数，因为单向函数必须对其值域中的每一个可能的输出都难以求逆。\n\nE. `QuirkHash` 的分类无法确定，因为对 $y_{special}$ 求逆的难度只是一个信念，而非一个已证明的事实。",
            "solution": "我们首先精确地重述单向函数的条件。一个函数 $f:\\{0,1\\}^{*}\\to\\{0,1\\}^{*}$ 是单向的，如果：\n- 它可以在多项式时间内计算。\n- 对于每个概率多项式时间 (PPT) 算法 $\\mathcal{A}$，每个正多项式 $p$，以及所有足够大的 $n$，其求逆成功概率是可忽略的，即，\n$$\n\\Pr_{x \\leftarrow \\{0,1\\}^{n},\\,\\text{coins of }\\mathcal{A}}\\left[\\mathcal{A}(f(x)) \\in f^{-1}(f(x))\\right]  \\frac{1}{p(n)}.\n$$\n\n`QuirkHash` 可在 $O(n^{3})$ 时间内计算，因此它满足易于计算的性质。\n\n定义 $y_{special} = 1^{n}$ 和 $C_{n} = \\{x \\in \\{0,1\\}^{n} : \\text{QuirkHash}(x) = y_{special}\\}$，其大小为 $|C_{n}| = \\lfloor n^{2}\\ln(n) \\rfloor$。对于任何 $y \\neq y_{special}$，存在一个确定性的多项式时间求逆器 `EasyInvert`，它可以在 $O(n^{4})$ 时间内找到一个原像。\n\n考虑所描述的 PPT 算法 $\\mathcal{A}$：\n- 对于均匀选择的 $x \\leftarrow \\{0,1\\}^{n}$ 的输入 $y = \\text{QuirkHash}(x)$，如果 $y \\neq y_{special}$，则输出 EasyInvert$(y)$；否则输出 FAILURE。\n这个 $\\mathcal{A}$ 在多项式时间内运行，因为 `EasyInvert` 在 $O(n^{4})$ 时间内运行，并且决策 $y \\stackrel{?}{=} y_{special}$ 是平凡的。\n\n计算其成功概率。由于当 $y \\neq y_{special}$ 时 $\\mathcal{A}$ 总是成功，而当 $y = y_{special}$ 时总是失败，我们有\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= \\Pr\\left[\\text{QuirkHash}(x) \\neq y_{special}\\right]\n= 1 - \\Pr\\left[\\text{QuirkHash}(x) = y_{special}\\right].\n$$\n因为 $x$ 在 $\\{0,1\\}^{n}$ 上是均匀分布的，\n$$\n\\Pr\\left[\\text{QuirkHash}(x) = y_{special}\\right] = \\frac{|C_{n}|}{2^{n}} = \\frac{\\lfloor n^{2}\\ln(n) \\rfloor}{2^{n}} \\leq \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\n因此\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n\\geq 1 - \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\n\n我们现在证明失败概率 $\\frac{n^{2}\\ln(n)}{2^{n}}$ 是可忽略的。利用当 $n$ 足够大时 $\\ln(n) \\leq n$ 这一事实，我们得到\n$$\n\\frac{n^{2}\\ln(n)}{2^{n}} \\leq \\frac{n^{3}}{2^{n}}\n$$\n对于所有足够大的 $n$。由于对于任何固定的 $k$，$\\lim_{n \\to \\infty} \\frac{n^{k}}{2^{n}} = 0$，因此 $\\frac{n^{3}}{2^{n}}$ 是可忽略的，所以 $\\frac{n^{2}\\ln(n)}{2^{n}}$ 也是可忽略的。因此，成功概率满足\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= 1 - \\text{negl}(n),\n$$\n这是不可忽略的。特别地，存在一个正多项式 $p$（例如，$p(n) = 2$），使得对于所有足够大的 $n$，\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right] \\geq \\frac{1}{p(n)}.\n$$\n因此，存在一个 PPT 算法能以不可忽略的概率对 `QuirkHash` 求逆。根据正式定义，这违反了单向函数所需的难以求逆的条件。\n\n评估选项：\n- A 是错误的：仅对单个输出难以求逆不足以构成单向性。\n- B 是错误的：难以处理的实例占比可忽略意味着该函数在平均情况下易于求逆，而非难以求逆。\n- C 是正确的：所描述的算法 $\\mathcal{A}$ 以不可忽略的（实际上是压倒性的）概率进行求逆。\n- D 是错误的：单向性是一个平均情况下的概念，而不是要求对每个输出都是最坏情况。\n- E 是错误的：分类不依赖于证明对 $y_{special}$ 求逆的难度；在绝大多数输出上存在高效的求逆器已经证明了该函数不是单向的。\n\n因此，正确的分类是 C。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}