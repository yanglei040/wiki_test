{
    "hands_on_practices": [
        {
            "introduction": "To truly understand what makes a function one-way, it is often most instructive to examine functions that fail to meet the criteria. This first practice  confronts a common misconception that ties the simple act of integer multiplication directly to the concept of one-wayness. By analyzing this seemingly simple function, you'll uncover a critical subtlety in the \"hard to invert\" property: the challenge for an adversary is to find *any* valid pre-image, not necessarily the specific prime factors of a number.",
            "id": "1433132",
            "problem": "In computational complexity theory, a one-way function is a function that is easy to compute but hard to invert. More formally, a function $f$ is a candidate one-way function if it satisfies two properties:\n1.  **Easy to Compute**: There exists a polynomial-time algorithm that, given any valid input $x$, can compute the output $f(x)$. The \"time\" is measured in terms of the bit-length of the input.\n2.  **Hard to Invert**: For any randomized polynomial-time algorithm, the probability of it successfully finding *any* preimage $x'$ such that $f(x') = y$ for a randomly chosen input $y$ from the function's range is negligible.\n\nConsider the function $f: \\mathbb{Z}^+ \\times \\mathbb{Z}^+ \\to \\mathbb{Z}^+$ defined as $f(x, y) = x \\cdot y$, where $\\mathbb{Z}^+$ is the set of positive integers. At first glance, this function might seem like a one-way function because its computation (multiplication) is very fast, while its inverse operation for a composite number $n$ (finding factors $x$ and $y$ such that $x \\cdot y = n$) is the integer factorization problem, which is believed to be computationally hard for large numbers.\n\nDespite this, the function $f(x, y) = x \\cdot y$ as defined is definitively **not** a one-way function. Which of the following statements provides the most accurate and fundamental reason for this conclusion?\n\nA. The integer factorization problem has been proven to be solvable in polynomial time, meaning the function is not hard to invert.\n\nB. The function is not one-to-one (injective) because for any pair of distinct integers $x$ and $y$, $f(x, y) = f(y, x)$. A true one-way function must be injective.\n\nC. For any given output $n$ in the range of the function, a specific pair of inputs $(x, y)$ that produces $n$ can always be found in polynomial time, violating the \"hard to invert\" property.\n\nD. The multiplication of two large integers is not a polynomial-time operation when considering the magnitude of the integers, violating the \"easy to compute\" property.",
            "solution": "We are given $f:\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}$ with $f(x,y)=x\\cdot y$. A one-way function must be easy to compute and hard to invert. The inversion requirement is: given $y$ in the range of $f$, any randomized polynomial-time algorithm should have only negligible probability of outputting any preimage $(x',y')$ such that $f(x',y')=y$. \n\nConsider the following deterministic polynomial-time inversion algorithm $A$ for $f$:\n- On input $n\\in\\mathbb{Z}^{+}$, output the pair $(1,n)$.\n\nThis algorithm is correct because\n$$\nf(1,n)=1\\cdot n=n.\n$$\nTherefore, for every $n$ in the range of $f$, $A$ produces a valid preimage. The running time of $A$ is polynomial in the bit-length of $n$, since constructing the constant $1$ and copying $n$ is polynomial-time in $|n|$. Consequently, the success probability of $A$ is $1$ over any distribution on outputs $y$ in the range, which violates the “hard to invert” property.\n\nHence, the fundamental reason $f(x,y)=x\\cdot y$ is not a one-way function as defined over $\\mathbb{Z}^{+}\\times\\mathbb{Z}^{+}$ is that inversion is trivial: given $n$, the pair $(1,n)$ is always a valid preimage computable in polynomial time. \n\nEvaluating the options:\n- A is false; the integer factorization problem has not been proven to be solvable in polynomial time.\n- B is incorrect; one-way functions need not be injective, and non-injectivity does not preclude being one-way.\n- C is correct; there is a trivial polynomial-time preimage finder $(1,n)$ for any $n$.\n- D is false; integer multiplication is computable in polynomial time.\n\nTherefore, the most accurate and fundamental reason is C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Having clarified the goal of an inverter, we now delve into the probabilistic nature of computational \"hardness.\" The formal definition requires a function to be hard to invert on average, not necessarily in every single case. This thought experiment  presents a hypothetical function that is extremely difficult to invert for a specific, yet very rare, class of outputs. Your task is to determine if this \"worst-case\" hardness is sufficient to make the function one-way, forcing you to engage with the crucial role of probabilities in the definition.",
            "id": "1433092",
            "problem": "In computational complexity theory, a one-way function is a function that is easy to compute but hard to invert on average. More formally, a function $f: \\{0,1\\}^* \\to \\{0,1\\}^*$ is a one-way function if it satisfies two properties:\n\n1.  **Easy to compute:** There exists a polynomial-time algorithm that computes $f(x)$ for any input $x$.\n2.  **Hard to invert:** For every probabilistic polynomial-time (PPT) algorithm $\\mathcal{A}$, every positive polynomial $p$, and all sufficiently large security parameters $n$, the probability that $\\mathcal{A}$ successfully finds a pre-image for $f(x)$ is negligible. That is,\n    $$ \\Pr_{x \\leftarrow \\{0,1\\}^n, \\text{coins of } \\mathcal{A}} [\\mathcal{A}(f(x)) \\in f^{-1}(f(x))]  \\frac{1}{p(n)} $$\n    where $x$ is chosen uniformly at random from the set of all $n$-bit strings, $\\{0,1\\}^n$. A function of $n$ is considered negligible if it decreases faster than the reciprocal of any polynomial in $n$.\n\nConsider a hypothetical cryptographic function, `QuirkHash`, which maps $n$-bit strings to $n$-bit strings. `QuirkHash` is known to be computable in $O(n^3)$ time. The function has a peculiar property: for a very specific output string, $y_{\\text{special}} = 1^n$ (a string of $n$ ones), finding any pre-image is computationally infeasible and believed to require exponential time. However, for any output $y \\neq y_{\\text{special}}$, there exists a public, deterministic polynomial-time algorithm, `EasyInvert`, that can find a pre-image in $O(n^4)$ time.\n\nFurthermore, it is known that the set of inputs $x \\in \\{0,1\\}^n$ that map to the special output, $C_n = \\{x \\in \\{0,1\\}^n \\mid \\text{QuirkHash}(x) = y_{\\text{special}}\\}$, has a size of $|C_n| = \\lfloor n^2 \\ln(n) \\rfloor$.\n\nAn adversary constructs an algorithm $\\mathcal{A}$ to invert `QuirkHash`. Given an output $y = \\text{QuirkHash}(x)$ (for a randomly chosen $n$-bit input $x$), $\\mathcal{A}$ operates as follows:\n- If $y \\neq y_{\\text{special}}$, it runs `EasyInvert(y)` and returns the result.\n- If $y = y_{\\text{special}}$, it gives up and returns 'FAILURE'.\n\nBased on the formal definition of a one-way function, which of the following statements correctly classifies `QuirkHash`?\n\nA. `QuirkHash` is a one-way function because there is at least one output for which it is hard to find a pre-image.\n\nB. `QuirkHash` is a one-way function because the probability of encountering the hard-to-invert case is negligible, meaning the function is hard to invert on average.\n\nC. `QuirkHash` is not a one-way function because there exists a probabilistic polynomial-time algorithm that inverts it with non-negligible probability.\n\nD. `QuirkHash` is not a one-way function because a one-way function must be hard to invert for every possible output in its range.\n\nE. The classification of `QuirkHash` cannot be determined because the hardness of inverting $y_{\\text{special}}$ is only a belief, not a proven fact.",
            "solution": "We first restate the one-way condition precisely. A function $f:\\{0,1\\}^{*}\\to\\{0,1\\}^{*}$ is one-way if:\n- It is computable in polynomial time.\n- For every probabilistic polynomial-time (PPT) algorithm $\\mathcal{A}$, every positive polynomial $p$, and all sufficiently large $n$, the inversion success probability is negligible, i.e.,\n$$\n\\Pr_{x \\leftarrow \\{0,1\\}^{n},\\,\\text{coins of }\\mathcal{A}}\\left[\\mathcal{A}(f(x)) \\in f^{-1}(f(x))\\right]  \\frac{1}{p(n)}.\n$$\n\nQuirkHash is computable in $O(n^{3})$ time, so it satisfies the easy-to-compute property.\n\nDefine $y_{\\text{special}} = 1^{n}$ and $C_{n} = \\{x \\in \\{0,1\\}^{n} : \\text{QuirkHash}(x) = y_{\\text{special}}\\}$ with $|C_{n}| = \\lfloor n^{2}\\ln(n) \\rfloor$. For any $y \\neq y_{\\text{special}}$ there is a deterministic polynomial-time inverter EasyInvert that finds a preimage in $O(n^{4})$ time.\n\nConsider the PPT algorithm $\\mathcal{A}$ described:\n- On input $y = \\text{QuirkHash}(x)$ for $x \\leftarrow \\{0,1\\}^{n}$ uniformly, if $y \\neq y_{\\text{special}}$, output EasyInvert$(y)$; otherwise output FAILURE.\nThis $\\mathcal{A}$ runs in polynomial time because EasyInvert runs in $O(n^{4})$ time and the decision $y \\stackrel{?}{=} y_{\\text{special}}$ is trivial.\n\nCompute its success probability. Since $\\mathcal{A}$ always succeeds when $y \\neq y_{\\text{special}}$ and always fails when $y = y_{\\text{special}}$, we have\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= \\Pr\\left[\\text{QuirkHash}(x) \\neq y_{\\text{special}}\\right]\n= 1 - \\Pr\\left[\\text{QuirkHash}(x) = y_{\\text{special}}\\right].\n$$\nBecause $x$ is uniform over $\\{0,1\\}^{n}$,\n$$\n\\Pr\\left[\\text{QuirkHash}(x) = y_{\\text{special}}\\right] = \\frac{|C_{n}|}{2^{n}} = \\frac{\\lfloor n^{2}\\ln(n) \\rfloor}{2^{n}} \\leq \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\nHence\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n\\geq 1 - \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\n\nWe now show that the failure probability $\\frac{n^{2}\\ln(n)}{2^{n}}$ is negligible. Using the fact that for sufficiently large $n$, $\\ln(n) \\leq n$, we obtain\n$$\n\\frac{n^{2}\\ln(n)}{2^{n}} \\leq \\frac{n^{3}}{2^{n}}\n$$\nfor all sufficiently large $n$. Since $\\lim_{n \\to \\infty} \\frac{n^{k}}{2^{n}} = 0$ for any fixed $k$, it follows that $\\frac{n^{3}}{2^{n}}$ is negligible, and therefore $\\frac{n^{2}\\ln(n)}{2^{n}}$ is negligible as well. Consequently, the success probability satisfies\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= 1 - \\text{negl}(n),\n$$\nwhich is non-negligible. In particular, there exists a positive polynomial $p$ (for example, $p(n) = 2$) such that for all sufficiently large $n$,\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right] \\geq \\frac{1}{p(n)}.\n$$\nTherefore, there exists a PPT algorithm that inverts QuirkHash with non-negligible probability. By the formal definition, this violates the hard-to-invert condition required for one-way functions.\n\nEvaluating the options:\n- A is false: hardness for a single output does not suffice for one-wayness.\n- B is false: a negligible fraction of hard instances implies the function is easy to invert on average, not hard.\n- C is true: the described $\\mathcal{A}$ inverts with non-negligible (indeed, overwhelming) probability.\n- D is false: one-wayness is an average-case notion, not a worst-case-for-every-output requirement.\n- E is false: the classification does not depend on proving hardness for $y_{\\text{special}}$; the existence of the efficient inverter on the overwhelming majority of outputs already certifies that the function is not one-way.\n\nHence the correct classification is C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "We now shift from analyzing existing functions to building new ones. A central theme in cryptography and complexity theory is the ability to construct complex, secure systems from simpler, trusted building blocks. This practice  asks you to determine if a new function $g$, built by applying a known one-way function $f$ to two separate inputs, inherits the one-way property. Answering this question will introduce you to the powerful and ubiquitous technique of proof by reduction, a fundamental method for demonstrating computational hardness.",
            "id": "1433150",
            "problem": "In the field of computational complexity theory, a one-way function is a function that is easy to compute but hard to invert. More formally, let's define a function $f: \\{0,1\\}^* \\to \\{0,1\\}^*$, which maps binary strings of any length to other binary strings. We call $f$ a **one-way function** if it satisfies two properties:\n1.  **Easy to Compute**: There exists a deterministic algorithm that computes $f(x)$ for any input $x$ in time that is polynomial in the length of $x$.\n2.  **Hard to Invert**: For any probabilistic algorithm $A$ that runs in time polynomial in the length of its input, the probability of $A$ succeeding in finding a preimage is negligible. That is, for a randomly chosen input $x$ of length $n$, the probability that $A(f(x))$ outputs an $x'$ such that $f(x') = f(x)$ tends to zero faster than any inverse polynomial in $n$.\n\nThe existence of one-way functions is a major open question in computer science. Their existence would imply that P is not equal to NP (where P is the class of problems solvable in polynomial time and NP is the class of problems verifiable in polynomial time), but the reverse is not known to be true.\n\nA cryptographer proposes a method to construct a new function from an existing one. Assume you are given a function $f$ which is guaranteed to be a one-way function according to the definition above. The new function, let's call it $g$, is defined on a pair of inputs $(x_1, x_2)$ of the same length, and its output is the concatenation of the individual outputs of $f$. That is, for inputs $x_1, x_2 \\in \\{0,1\\}^n$, the function $g$ is defined as:\n$$g(x_1, x_2) = (f(x_1), f(x_2))$$\nThe output is an ordered pair of strings.\n\nIs the newly constructed function $g$ also necessarily a one-way function?\n\nA. Yes, the function $g$ is always a one-way function.\n\nB. No, the function $g$ is never a one-way function.\n\nC. The function $g$ is a one-way function only if the function $f$ is also a permutation (i.e., a bijection).\n\nD. The function $g$ is a one-way function only if P = NP.\n\nE. Whether $g$ is a one-way function is an unresolved problem, and its proof would resolve the P versus NP problem.",
            "solution": "Let $f:\\{0,1\\}^{*}\\to\\{0,1\\}^{*}$ be a one-way function. By definition, for each input length $n$, $f$ is computable in time polynomial in $n$, and for every probabilistic polynomial-time (PPT) algorithm $A$, the inversion success probability\n$$\n\\Pr_{x\\leftarrow\\{0,1\\}^{n}}\\big[f(A(f(x)))=f(x)\\big]\n$$\nis negligible in $n$.\n\nDefine $g:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{*}\\times\\{0,1\\}^{*}$ by $g(x_{1},x_{2})=(f(x_{1}),f(x_{2}))$. We verify the two properties of one-wayness for $g$.\n\nEasy to compute: Since $f$ is computable in time polynomial in $n$, computing $f(x_{1})$ and $f(x_{2})$ takes time polynomial in $n$ each. Therefore, computing $g(x_{1},x_{2})$ takes time polynomial in $n$, hence polynomial in the input length $2n$.\n\nHard to invert: Assume for contradiction that there exists a PPT algorithm $A_{g}$ and a non-negligible function $\\epsilon(n)$ such that\n$$\n\\Pr_{(x_{1},x_{2})\\leftarrow\\{0,1\\}^{n}\\times\\{0,1\\}^{n}}\\Big[(x_{1}',x_{2}')\\leftarrow A_{g}(g(x_{1},x_{2}))\\ \\wedge\\ f(x_{1}')=f(x_{1})\\ \\wedge\\ f(x_{2}')=f(x_{2})\\Big]\\geq \\epsilon(n).\n$$\nWe build a PPT inverter $B_{f}$ for $f$ as follows. On input $y$ of the form $y=f(x)$ where $x\\leftarrow\\{0,1\\}^{n}$ is uniform (as in the one-wayness experiment for $f$), $B_{f}$:\n1. Samples $r\\leftarrow\\{0,1\\}^{n}$ uniformly at random.\n2. Computes $y_{2}=f(r)$.\n3. Runs $A_{g}$ on $(y,y_{2})$ to obtain $(x_{1}',x_{2}')$.\n4. Checks whether $f(x_{1}')=y$ and $f(x_{2}')=y_{2}$. If so, outputs $x_{1}'$; otherwise, outputs failure.\n\n$B_{f}$ runs in time polynomial in $n$, since each step is polynomial-time and $A_{g}$ is PPT. Consider the distribution of $(y,y_{2})$ input to $A_{g}$. We have $y=f(x)$ with $x\\leftarrow\\{0,1\\}^{n}$ uniform and $y_{2}=f(r)$ with $r\\leftarrow\\{0,1\\}^{n}$ independent uniform. Hence $(y,y_{2})$ is distributed identically to $g(x_{1},x_{2})$ for $(x_{1},x_{2})\\leftarrow\\{0,1\\}^{n}\\times\\{0,1\\}^{n}$. Therefore,\n$$\n\\Pr\\big[B_{f}\\text{ outputs }x'\\text{ with }f(x')=y\\big]\n=\n\\Pr_{(x_{1},x_{2})}\\Big[(x_{1}',x_{2}')\\leftarrow A_{g}(g(x_{1},x_{2}))\\ \\wedge\\ f(x_{1}')=f(x_{1})\\ \\wedge\\ f(x_{2}')=f(x_{2})\\Big]\n\\geq \\epsilon(n),\n$$\nwhich is non-negligible. This contradicts the one-wayness of $f$. Hence no PPT inverter for $g$ can succeed with non-negligible probability, establishing that $g$ is hard to invert.\n\nSince $g$ is both easy to compute and hard to invert under the assumed one-wayness of $f$, $g$ is a one-way function. None of the additional conditions in options C, D, or E are necessary, and option B is false.\n\nThus the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}