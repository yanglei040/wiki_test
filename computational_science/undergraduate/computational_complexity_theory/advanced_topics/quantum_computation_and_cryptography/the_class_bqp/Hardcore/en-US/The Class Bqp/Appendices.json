{
    "hands_on_practices": [
        {
            "introduction": "To begin our hands-on exploration of BQP, we start with one of the simplest yet most illuminating examples of quantum advantage: the Deutsch-Jozsa problem, simplified here to a single-bit input. This exercise walks you through the foundational Deutsch algorithm, which uses a single query to a \"black box\" function to determine a global property that would require two queries classically. By tracing the quantum state through the circuit, you will directly witness the power of quantum parallelism and phase kickback, core mechanisms that underpin many quantum algorithms. ",
            "id": "1451267",
            "problem": "You are tasked with characterizing an unknown computational module, which can be modeled as a \"black box\" or an \"oracle.\" This oracle implements a single, unknown Boolean function $f: \\{0, 1\\} \\to \\{0, 1\\}$. You are given a promise that the function $f$ belongs to one of two categories: it is either a **constant** function (meaning $f(0) = f(1)$) or a **balanced** function (meaning $f(0) \\neq f(1)$).\n\nTo determine the function's category, you use a simple quantum circuit. The procedure is as follows:\n\n1.  Two qubits, a data qubit and an ancillary qubit, are initialized to the state $|\\psi_0\\rangle = |0\\rangle|1\\rangle$.\n2.  A Hadamard gate, $H$, is applied to each qubit individually.\n3.  The quantum oracle, denoted by the unitary operator $U_f$, is applied to the two-qubit state. The action of the oracle is defined by the transformation $U_f: |x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$, where $x, y \\in \\{0, 1\\}$ and $\\oplus$ denotes addition modulo 2.\n4.  A Hadamard gate is applied to the data (first) qubit only.\n5.  The data (first) qubit is measured in the computational basis $\\{|0\\rangle, |1\\rangle\\}$.\n\nAfter running this procedure exactly once, the measurement of the data qubit yields the outcome `1`. Based on this result, what can you definitively conclude about the nature of the function $f$?\n\nA. The function $f$ must be constant.\n\nB. The function $f$ must be balanced.\n\nC. The function $f$ could be either constant or balanced.\n\nD. The measurement outcome `1` is impossible; there must be an error in the experiment.\n\nE. The function $f$ must be the identity function, $f(x) = x$.",
            "solution": "We begin with two qubits initialized as $|\\psi_{0}\\rangle = |0\\rangle|1\\rangle$. Applying a Hadamard gate $H$ to each qubit gives\n$$\nH|0\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}, \\quad H|1\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}.\n$$\nTherefore, after step 2 the state is\n$$\n|\\psi_{1}\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) \\otimes \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\otimes |-\\rangle,\n$$\nwhere $|-\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$.\n\nThe oracle acts as $U_{f}: |x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$. Its action on $|-\\rangle$ produces a phase kickback:\n$$\nU_{f}\\big(|x\\rangle|-\\rangle\\big) = U_{f}\\left(|x\\rangle\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) \n= \\frac{1}{\\sqrt{2}}\\left(|x\\rangle|f(x)\\rangle - |x\\rangle|1 \\oplus f(x)\\rangle\\right)\n= (-1)^{f(x)}|x\\rangle|-\\rangle.\n$$\nThus, after applying $U_{f}$ the state becomes\n$$\n|\\psi_{2}\\rangle = \\frac{1}{\\sqrt{2}}\\left((-1)^{f(0)}|0\\rangle + (-1)^{f(1)}|1\\rangle\\right)\\otimes |-\\rangle.\n$$\n\nNext, apply a Hadamard gate to the first (data) qubit only. Using $H|0\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}$ and $H|1\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$, we obtain\n$$\n|\\psi_{3}\\rangle = \\frac{1}{\\sqrt{2}}\\left((-1)^{f(0)}\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} + (-1)^{f(1)}\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right)\\otimes |-\\rangle\n= \\frac{1}{2}\\left(\\big((-1)^{f(0)} + (-1)^{f(1)}\\big)|0\\rangle + \\big((-1)^{f(0)} - (-1)^{f(1)}\\big)|1\\rangle\\right)\\otimes |-\\rangle.\n$$\n\nThe measurement on the first qubit yields outcome $0$ with amplitude $\\frac{1}{2}\\big((-1)^{f(0)} + (-1)^{f(1)}\\big)$ and outcome $1$ with amplitude $\\frac{1}{2}\\big((-1)^{f(0)} - (-1)^{f(1)}\\big)$. Since $f$ is promised to be either constant or balanced:\n- If $f$ is constant, then $f(0) = f(1)$, so $(-1)^{f(0)} = (-1)^{f(1)}$, the sum is $\\pm 2$ and the difference is $0$. Therefore the first qubit is $|0\\rangle$ with certainty.\n- If $f$ is balanced, then $f(0) \\neq f(1)$, so $(-1)^{f(0)} = -(-1)^{f(1)}$, the sum is $0$ and the difference is $\\pm 2$. Therefore the first qubit is $|1\\rangle$ with certainty.\n\nGiven that the measurement outcome is $1$, we can definitively conclude that $f$ is balanced. It is not necessarily the specific function $f(x) = x$, because $f(x) = 1 \\oplus x$ would give the same outcome. The outcome $1$ is not impossible, and $f$ is not constant.\n\nHence, the correct choice is B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "While the Deutsch algorithm provides a deterministic answer, the \"B\" in BQP stands for \"bounded-error,\" acknowledging that most quantum algorithms are probabilistic. This next practice problem makes this abstract concept concrete by connecting the formal error bounds of BQP to the physical parameters of a simple quantum circuit. You will calculate how the success probability of a 2-qubit algorithm depends on a tunable parameter $\\theta$ in its unitary gate, and then determine the minimum separation needed to reliably distinguish between a \"yes\" and \"no\" instance.  This is a crucial exercise for understanding the practical constraints and power of real-world quantum computation.",
            "id": "1451244",
            "problem": "A quantum computing device is used to distinguish between two hypotheses about a physical system, labeled 'yes' and 'no'. The 'yes' case corresponds to a system parameter being $\\theta_Y$, and the 'no' case to the parameter being $\\theta_N$. The device operates on a 2-qubit register, performing the following algorithm:\n1. Initialize the register to the state $|\\psi_{in}\\rangle = |00\\rangle$.\n2. Apply a unitary transformation $U(\\theta)$, where $\\theta$ is either $\\theta_Y$ or $\\theta_N$. The matrix for $U(\\theta)$ in the computational basis $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$ is given by:\n$$ U(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} $$\n3. Measure the first qubit in the computational basis. If the result is '1', the algorithm outputs 'yes'. Otherwise, it outputs 'no'.\n\nThis procedure is considered a valid algorithm for a problem in the complexity class Bounded-error Quantum Polynomial time (BQP) if the probability of outputting 'yes' is at least $2/3$ for a 'yes' instance, and at most $1/3$ for a 'no' instance.\n\nGiven that both $\\theta_Y$ and $\\theta_N$ are in the range $[0, \\pi/2]$, determine the minimum possible value of the difference $\\theta_Y - \\theta_N$. Express your answer as a closed-form analytic expression in radians.",
            "solution": "The input state is $|\\psi_{in}\\rangle=|00\\rangle$. Applying $U(\\theta)$ to $|00\\rangle$ is read from the first column of the given matrix:\n$$\nU(\\theta)|00\\rangle=\\cos\\theta\\,|00\\rangle-\\sin\\theta\\,|10\\rangle.\n$$\nMeasuring the first qubit in the computational basis, the outcome $1$ occurs if the post-unitary state has support on $|10\\rangle$ or $|11\\rangle$. From the above state, the only component with first qubit $1$ is $|10\\rangle$ with amplitude $-\\sin\\theta$, and there is no $|11\\rangle$ component. Therefore the acceptance probability (outputting 'yes') as a function of $\\theta$ is\n$$\np(\\theta)=\\sin^{2}\\theta.\n$$\n\nFor a valid BQP procedure, we require for the 'yes' instance that $p(\\theta_{Y})\\geq \\frac{2}{3}$ and for the 'no' instance that $p(\\theta_{N})\\leq \\frac{1}{3}$. Since $\\theta\\in[0,\\pi/2]$, the function $\\sin^{2}\\theta$ is monotonically nondecreasing because its derivative is $\\sin 2\\theta\\geq 0$ on $[0,\\pi/2]$. Hence, to minimize the difference $\\theta_{Y}-\\theta_{N}$ under these constraints, we saturate them:\n$$\n\\sin^{2}\\theta_{Y}=\\frac{2}{3},\\qquad \\sin^{2}\\theta_{N}=\\frac{1}{3}.\n$$\nBecause $\\theta\\in[0,\\pi/2]$ implies $\\sin\\theta\\geq 0$, we obtain\n$$\n\\theta_{Y}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\right),\\qquad \\theta_{N}=\\arcsin\\!\\left(\\sqrt{\\frac{1}{3}}\\right),\n$$\nso the minimal difference is\n$$\n\\Delta\\theta_{\\min}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\right)-\\arcsin\\!\\left(\\sqrt{\\frac{1}{3}}\\right).\n$$\nUsing the identity for $a,b\\in[0,1]$,\n$$\n\\arcsin a-\\arcsin b=\\arcsin\\!\\left(a\\sqrt{1-b^{2}}-b\\sqrt{1-a^{2}}\\right),\n$$\nand substituting $a=\\sqrt{\\frac{2}{3}}$ and $b=\\sqrt{\\frac{1}{3}}$, we get\n$$\n\\Delta\\theta_{\\min}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\sqrt{1-\\frac{1}{3}}-\\sqrt{\\frac{1}{3}}\\sqrt{1-\\frac{2}{3}}\\right)\n=\\arcsin\\!\\left(\\frac{2}{3}-\\frac{1}{3}\\right)=\\arcsin\\!\\left(\\frac{1}{3}\\right).\n$$\nThus the minimum possible value of $\\theta_{Y}-\\theta_{N}$ is $\\arcsin\\!\\left(\\frac{1}{3}\\right)$ radians.",
            "answer": "$$\\boxed{\\arcsin\\!\\left(\\frac{1}{3}\\right)}$$"
        },
        {
            "introduction": "Having explored how individual quantum algorithms work, we now shift our focus to a fundamental structural property of the complexity class BQP itself. This exercise guides you to prove that BQP is closed under complement, meaning that if a language $L$ is in BQP, its complement $\\bar{L}$ is also in BQP. You will discover that this powerful theoretical result stems from a remarkably simple physical operation: flipping the output qubit.  This demonstrates a profound link between the ability to manipulate quantum information and the computational power of the classes built upon it.",
            "id": "1451258",
            "problem": "A quantum algorithm, denoted as $\\mathcal{A}$, is designed to solve a decision problem for a language $L$. The algorithm operates on an input string $x$ and concludes by measuring a single, designated output qubit. If the measurement outcome is 1, the input string $x$ is considered \"accepted\"; if the outcome is 0, it is \"rejected\".\n\nThe performance of algorithm $\\mathcal{A}$ is precisely characterized by two probabilities:\n1.  For any string $x$ that is a member of the language $L$ (i.e., $x \\in L$), the probability of the algorithm outputting 1 is exactly $p_{yes}$.\n2.  For any string $x$ that is not a member of the language $L$ (i.e., $x \\notin L$), the probability of the algorithm outputting 1 is exactly $p_{no}$.\n\nFor the language $L$ to be considered in the complexity class Bounded-error Quantum Polynomial time (BQP), it is required that the \"success\" probability is high and the \"failure\" probability is low, with a sufficient gap between them. Typical bounds are $p_{yes} \\ge 2/3$ and $p_{no} \\le 1/3$.\n\nNow, a new quantum algorithm, $\\mathcal{A}'$, is constructed to solve the decision problem for the complement language, $\\bar{L}$, which contains all strings not in $L$. This new algorithm $\\mathcal{A}'$ is identical to $\\mathcal{A}$ in every way, except for one additional operation: a Pauli-X (NOT) gate is applied to the output qubit immediately before the measurement is performed.\n\nFor the new algorithm $\\mathcal{A}'$ deciding the language $\\bar{L}$, let the probability that $\\mathcal{A}'$ outputs 1 for an input string $y \\in \\bar{L}$ be denoted by $p'_{yes}$. Similarly, let the probability that $\\mathcal{A}'$ outputs 1 for an input string $z \\notin \\bar{L}$ be denoted by $p'_{no}$.\n\nExpress the pair of probabilities $(p'_{yes}, p'_{no})$ for the algorithm $\\mathcal{A}'$ in terms of the original probabilities $p_{yes}$ and $p_{no}$.",
            "solution": "Let's analyze the relationship between the output probabilities of the original algorithm $\\mathcal{A}$ and the new algorithm $\\mathcal{A}'$.\n\nThe original algorithm $\\mathcal{A}$ outputs 1 with probability $P_{\\mathcal{A}}(1|x)$ and 0 with probability $P_{\\mathcal{A}}(0|x)$ for a given input string $x$. Since there are only two outcomes, these probabilities must sum to 1.\n$$P_{\\mathcal{A}}(0|x) + P_{\\mathcal{A}}(1|x) = 1$$\n\nThe new algorithm $\\mathcal{A}'$ is constructed by taking the algorithm $\\mathcal{A}$ and applying a Pauli-X (NOT) gate to the output qubit just before measurement. The Pauli-X gate has the effect of flipping the state of the qubit: it transforms $|0\\rangle$ to $|1\\rangle$ and $|1\\rangle$ to $|0\\rangle$.\n\nConsequently, any computational basis state that would have resulted in a measurement outcome of 1 in algorithm $\\mathcal{A}$ will now result in an outcome of 0 in algorithm $\\mathcal{A}'$. Conversely, any state that would have resulted in an outcome of 0 in $\\mathcal{A}$ will now result in an outcome of 1 in $\\mathcal{A}'$. This means that the probability distributions of the outcomes are swapped.\n\nThe probability of algorithm $\\mathcal{A}'$ outputting 1, denoted $P_{\\mathcal{A}'}(1|x)$, is therefore equal to the probability of algorithm $\\mathcal{A}$ outputting 0.\n$$P_{\\mathcal{A}'}(1|x) = P_{\\mathcal{A}}(0|x)$$\nUsing the relation from the first step, we can express this in terms of the probability of $\\mathcal{A}$ outputting 1:\n$$P_{\\mathcal{A}'}(1|x) = 1 - P_{\\mathcal{A}}(1|x)$$\n\nNow we can determine $p'_{yes}$ and $p'_{no}$.\n\nFirst, let's find $p'_{yes}$. This is the probability that $\\mathcal{A}'$ outputs 1 for an input string $y$ that is in the complement language $\\bar{L}$. By definition of the complement language, if $y \\in \\bar{L}$, then $y \\notin L$.\n$$p'_{yes} = P_{\\mathcal{A}'}(1|y) \\quad \\text{where } y \\in \\bar{L}$$\nUsing our derived relationship:\n$$p'_{yes} = 1 - P_{\\mathcal{A}}(1|y)$$\nAccording to the problem statement, for any string not in $L$ (like $y$), the probability of algorithm $\\mathcal{A}$ outputting 1 is $p_{no}$. So, $P_{\\mathcal{A}}(1|y) = p_{no}$.\nSubstituting this in, we get:\n$$p'_{yes} = 1 - p_{no}$$\n\nNext, let's find $p'_{no}$. This is the probability that $\\mathcal{A}'$ outputs 1 for an input string $z$ that is not in the complement language $\\bar{L}$. If $z \\notin \\bar{L}$, this means that $z \\in L$.\n$$p'_{no} = P_{\\mathcal{A}'}(1|z) \\quad \\text{where } z \\notin \\bar{L}$$\nAgain, using our derived relationship:\n$$p'_{no} = 1 - P_{\\mathcal{A}}(1|z)$$\nAccording to the problem statement, for any string in $L$ (like $z$), the probability of algorithm $\\mathcal{A}$ outputting 1 is $p_{yes}$. So, $P_{\\mathcal{A}}(1|z) = p_{yes}$.\nSubstituting this in, we get:\n$$p'_{no} = 1 - p_{yes}$$\n\nTherefore, the pair of new probabilities $(p'_{yes}, p'_{no})$ is $(1 - p_{no}, 1 - p_{yes})$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 - p_{no} & 1 - p_{yes} \\end{pmatrix}}$$"
        }
    ]
}