{
    "hands_on_practices": [
        {
            "introduction": "为了探索计算的极限，我们常常使用“谕示机”（oracle）问题。本练习将介绍 Deutsch 算法，这是一个基础性范例，它展示了量子力学如何比任何经典方法更有效地解决特定问题。通过这个练习，你将亲身体验量子并行和量子干涉的力量，这是量子计算优势的两个核心来源。",
            "id": "1451267",
            "problem": "你的任务是描述一个未知的计算模块，该模块可以被建模为一个“黑箱”或“神谕”。这个神谕实现了一个单一的、未知的布尔函数 $f: \\{0, 1\\} \\to \\{0, 1\\}$。你得到了一个承诺，即函数 $f$ 属于以下两类之一：它要么是一个**常数**函数（意味着 $f(0) = f(1)$），要么是一个**平衡**函数（意味着 $f(0) \\neq f(1)$）。\n\n为了确定该函数的类别，你使用一个简单的量子电路。步骤如下：\n\n1.  两个量子比特，一个数据量子比特和一个辅助量子比特，被初始化到状态 $|\\psi_0\\rangle = |0\\rangle|1\\rangle$。\n2.  一个哈达玛门（Hadamard gate），$H$，分别作用于每个量子比特。\n3.  量子神谕，用酉算符 $U_f$ 表示，作用于这个双量子比特态。神谕的作用由变换 $U_f: |x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$ 定义，其中 $x, y \\in \\{0, 1\\}$ 且 $\\oplus$ 表示模2加法。\n4.  一个哈达玛门仅作用于数据（第一个）量子比特。\n5.  在计算基 $\\{|0\\rangle, |1\\rangle\\}$ 下测量数据（第一个）量子比特。\n\n在精确执行此过程一次后，对数据量子比特的测量得到结果 `1`。基于这个结果，关于函数 $f$ 的性质，你能得出什么确切的结论？\n\nA. 函数 $f$ 必须是常数函数。\n\nB. 函数 $f$ 必须是平衡函数。\n\nC. 函数 $f$ 可能是常数函数，也可能是平衡函数。\n\nD. 测量结果 `1` 是不可能的；实验中必定存在错误。\n\nE. 函数 $f$ 必须是恒等函数，$f(x) = x$。",
            "solution": "我们从两个初始化为 $|\\psi_{0}\\rangle = |0\\rangle|1\\rangle$ 的量子比特开始。对每个量子比特应用哈达玛门 $H$ 得到\n$$\nH|0\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}, \\quad H|1\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}.\n$$\n因此，在第2步之后，状态为\n$$\n|\\psi_{1}\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) \\otimes \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\otimes |-\\rangle,\n$$\n其中 $|-\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$。\n\n神谕的作用方式为 $U_{f}: |x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$。它对 $|-\\rangle$ 的作用会产生一个相位回踢（phase kickback）：\n$$\nU_{f}\\big(|x\\rangle|-\\rangle\\big) = U_{f}\\left(|x\\rangle\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) \n= \\frac{1}{\\sqrt{2}}\\left(|x\\rangle|f(x)\\rangle - |x\\rangle|1 \\oplus f(x)\\rangle\\right)\n= (-1)^{f(x)}|x\\rangle|-\\rangle.\n$$\n因此，在应用 $U_{f}$ 后，状态变为\n$$\n|\\psi_{2}\\rangle = \\frac{1}{\\sqrt{2}}\\left((-1)^{f(0)}|0\\rangle + (-1)^{f(1)}|1\\rangle\\right)\\otimes |-\\rangle.\n$$\n\n接下来，只对第一个（数据）量子比特应用哈达玛门。使用 $H|0\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}$ 和 $H|1\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$，我们得到\n$$\n|\\psi_{3}\\rangle = \\frac{1}{\\sqrt{2}}\\left((-1)^{f(0)}\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} + (-1)^{f(1)}\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right)\\otimes |-\\rangle\n= \\frac{1}{2}\\left(\\big((-1)^{f(0)} + (-1)^{f(1)}\\big)|0\\rangle + \\big((-1)^{f(0)} - (-1)^{f(1)}\\big)|1\\rangle\\right)\\otimes |-\\rangle.\n$$\n\n对第一个量子比特的测量，得到结果 $0$ 的振幅为 $\\frac{1}{2}\\big((-1)^{f(0)} + (-1)^{f(1)}\\big)$，得到结果 $1$ 的振幅为 $\\frac{1}{2}\\big((-1)^{f(0)} - (-1)^{f(1)}\\big)$。由于 $f$ 被承诺为常数函数或平衡函数：\n- 如果 $f$ 是常数函数，则 $f(0) = f(1)$，所以 $(-1)^{f(0)} = (-1)^{f(1)}$，和为 $\\pm 2$，差为 $0$。因此，第一个量子比特必然是 $|0\\rangle$。\n- 如果 $f$ 是平衡函数，则 $f(0) \\neq f(1)$，所以 $(-1)^{f(0)} = -(-1)^{f(1)}$，和为 $0$，差为 $\\pm 2$。因此，第一个量子比特必然是 $|1\\rangle$。\n\n鉴于测量结果为 $1$，我们可以确切地得出结论，$f$ 是平衡函数。它不一定是特定的函数 $f(x) = x$，因为 $f(x) = 1 \\oplus x$ 也会得到相同的结果。结果 $1$ 不是不可能的，并且 $f$ 不是常数函数。\n\n因此，正确选项是 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "BQP 的全称是“有界错误量子多项式时间”（Bounded-error Quantum Polynomial time），其核心在于对错误的严格限制。理解这些错误边界对于掌握 BQP 的定义至关重要。本练习提供了一个具体的量子电路场景，让你通过计算来确定满足 BQP 判定标准所需的物理参数，从而将抽象的概率定义与实际的量子操作联系起来。",
            "id": "1451244",
            "problem": "一个量子计算设备被用来区分关于一个物理系统的两种假设，标记为‘是’和‘否’。‘是’的情况对应于系统参数为 $\\theta_Y$，‘否’的情况对应于参数为 $\\theta_N$。该设备在一个双量子比特寄存器上运行，执行以下算法：\n1. 将寄存器初始化到状态 $|\\psi_{in}\\rangle = |00\\rangle$。\n2. 应用一个酉变换 $U(\\theta)$，其中 $\\theta$ 是 $\\theta_Y$ 或 $\\theta_N$。$U(\\theta)$ 在计算基 $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$ 下的矩阵由下式给出：\n$$ U(\\theta) = \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta  0 \\\\ 0  1  0  0 \\\\ -\\sin\\theta  0  \\cos\\theta  0 \\\\ 0  0  0  1 \\end{pmatrix} $$\n3. 在计算基中测量第一个量子比特。如果结果为‘1’，算法输出‘是’。否则，输出‘否’。\n\n如果对于一个‘是’实例，输出‘是’的概率至少为 $2/3$，而对于一个‘否’实例，其概率至多为 $1/3$，那么该过程被认为是复杂度类“有界错误量子多项式时间 (BQP)”中问题的一个有效算法。\n\n已知 $\\theta_Y$ 和 $\\theta_N$ 都在 $[0, \\pi/2]$ 的范围内，确定差值 $\\theta_Y - \\theta_N$ 的最小可能值。请用以弧度为单位的闭式解析表达式表示你的答案。",
            "solution": "输入态为 $|\\psi_{in}\\rangle=|00\\rangle$。将 $U(\\theta)$ 应用于 $|00\\rangle$ 的结果可从给定矩阵的第一列读出：\n$$\nU(\\theta)|00\\rangle=\\cos\\theta\\,|00\\rangle-\\sin\\theta\\,|10\\rangle.\n$$\n在计算基中测量第一个量子比特，如果酉变换后的状态在 $|10\\rangle$ 或 $|11\\rangle$ 上有分量，则测量结果为 $1$。从上述状态可知，第一个量子比特为 $1$ 的唯一分量是 $|10\\rangle$，其振幅为 $-\\sin\\theta$，而没有 $|11\\rangle$ 分量。因此，接受概率（输出‘是’）作为 $\\theta$ 的函数是\n$$\np(\\theta)=\\sin^{2}\\theta.\n$$\n\n对于一个有效的 BQP 过程，我们要求对于‘是’实例，$p(\\theta_{Y})\\geq \\frac{2}{3}$，对于‘否’实例，$p(\\theta_{N})\\leq \\frac{1}{3}$。由于 $\\theta\\in[0,\\pi/2]$，函数 $\\sin^{2}\\theta$ 是单调不减的，因为它的导数 $\\sin 2\\theta\\geq 0$ 在 $[0,\\pi/2]$ 上成立。因此，为了在这些约束条件下最小化差值 $\\theta_{Y}-\\theta_{N}$，我们使不等式取等：\n$$\n\\sin^{2}\\theta_{Y}=\\frac{2}{3},\\qquad \\sin^{2}\\theta_{N}=\\frac{1}{3}.\n$$\n因为 $\\theta\\in[0,\\pi/2]$ 意味着 $\\sin\\theta\\geq 0$，我们得到\n$$\n\\theta_{Y}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\right),\\qquad \\theta_{N}=\\arcsin\\!\\left(\\sqrt{\\frac{1}{3}}\\right),\n$$\n所以最小差值为\n$$\n\\Delta\\theta_{\\min}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\right)-\\arcsin\\!\\left(\\sqrt{\\frac{1}{3}}\\right).\n$$\n使用对于 $a,b\\in[0,1]$ 的恒等式，\n$$\n\\arcsin a-\\arcsin b=\\arcsin\\!\\left(a\\sqrt{1-b^{2}}-b\\sqrt{1-a^{2}}\\right),\n$$\n并代入 $a=\\sqrt{\\frac{2}{3}}$ 和 $b=\\sqrt{\\frac{1}{3}}$，我们得到\n$$\n\\Delta\\theta_{\\min}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\sqrt{1-\\frac{1}{3}}-\\sqrt{\\frac{1}{3}}\\sqrt{1-\\frac{2}{3}}\\right)\n=\\arcsin\\!\\left(\\frac{2}{3}-\\frac{1}{3}\\right)=\\arcsin\\!\\left(\\frac{1}{3}\\right).\n$$\n因此，$\\theta_{Y}-\\theta_{N}$ 的最小可能值为 $\\arcsin\\!\\left(\\frac{1}{3}\\right)$ 弧度。",
            "answer": "$$\\boxed{\\arcsin\\!\\left(\\frac{1}{3}\\right)}$$"
        },
        {
            "introduction": "在掌握了单个量子算法的特性后，我们可以进一步探讨 BQP 作为一个复杂性类的整体结构性质。一个重要的结构性质是它是否对“补运算”封闭。本练习通过对量子算法进行一个简单而巧妙的修改，证明了 BQP 等于 co-BQP，即 BQP 对补运算是封闭的，这揭示了量子计算模型的一个深刻特征。",
            "id": "1451258",
            "problem": "一个量子算法，记为 $\\mathcal{A}$，旨在为一个语言 $L$ 解决一个判定问题。该算法对一个输入字符串 $x$ 进行操作，并通过测量一个指定的单个输出量子比特来结束。如果测量结果为 1，则输入字符串 $x$ 被视为“接受”；如果结果为 0，则被视为“拒绝”。\n\n算法 $\\mathcal{A}$ 的性能由两个概率精确地刻画：\n1.  对于任何属于语言 $L$ 的字符串 $x$（即 $x \\in L$），该算法输出 1 的概率恰好是 $p_{yes}$。\n2.  对于任何不属于语言 $L$ 的字符串 $x$（即 $x \\notin L$），该算法输出 1 的概率恰好是 $p_{no}$。\n\n要使语言 $L$ 被认为属于复杂度类“有界错误量子多项式时间”（Bounded-error Quantum Polynomial time, BQP），要求其“成功”概率高，“失败”概率低，且两者之间有足够的差距。典型的界限是 $p_{yes} \\ge 2/3$ 和 $p_{no} \\le 1/3$。\n\n现在，构造一个新的量子算法 $\\mathcal{A}'$ 来解决补语言 $\\bar{L}$ 的判定问题，该语言包含所有不在 $L$ 中的字符串。这个新算法 $\\mathcal{A}'$ 与 $\\mathcal{A}$ 在各方面都完全相同，只有一个额外的操作：在进行测量之前，立即对输出量子比特施加一个 Pauli-X（非）门。\n\n对于决定语言 $\\bar{L}$ 的新算法 $\\mathcal{A}'$，令 $\\mathcal{A}'$ 对输入字符串 $y \\in \\bar{L}$ 输出 1 的概率记为 $p'_{yes}$。类似地，令 $\\mathcal{A}'$ 对输入字符串 $z \\notin \\bar{L}$ 输出 1 的概率记为 $p'_{no}$。\n\n将算法 $\\mathcal{A}'$ 的概率对 $(p'_{yes}, p'_{no})$ 用原始概率 $p_{yes}$ 和 $p_{no}$ 表示。",
            "solution": "让我们分析原始算法 $\\mathcal{A}$ 和新算法 $\\mathcal{A}'$ 的输出概率之间的关系。\n\n对于给定的输入字符串 $x$，原始算法 $\\mathcal{A}$ 以概率 $P_{\\mathcal{A}}(1|x)$ 输出 1，以概率 $P_{\\mathcal{A}}(0|x)$ 输出 0。由于只有两种结果，这些概率之和必须为 1。\n$$P_{\\mathcal{A}}(0|x) + P_{\\mathcal{A}}(1|x) = 1$$\n\n新算法 $\\mathcal{A}'$ 是通过取算法 $\\mathcal{A}$ 并在测量前对输出量子比特施加一个 Pauli-X（非）门来构造的。Pauli-X 门的作用是翻转量子比特的状态：它将 $|0\\rangle$ 变换为 $|1\\rangle$，将 $|1\\rangle$ 变换为 $|0\\rangle$。\n\n因此，任何在算法 $\\mathcal{A}$ 中会导致测量结果为 1 的计算基态，在算法 $\\mathcal{A}'$ 中现在将导致结果为 0。反之，任何在 $\\mathcal{A}$ 中会导致结果为 0 的状态，在 $\\mathcal{A}'$ 中现在将导致结果为 1。这意味着结果的概率分布被交换了。\n\n算法 $\\mathcal{A}'$ 输出 1 的概率，记为 $P_{\\mathcal{A}'}(1|x)$，因此等于算法 $\\mathcal{A}$ 输出 0 的概率。\n$$P_{\\mathcal{A}'}(1|x) = P_{\\mathcal{A}}(0|x)$$\n使用第一步中的关系，我们可以用 $\\mathcal{A}$ 输出 1 的概率来表示它：\n$$P_{\\mathcal{A}'}(1|x) = 1 - P_{\\mathcal{A}}(1|x)$$\n\n现在我们可以确定 $p'_{yes}$ 和 $p'_{no}$。\n\n首先，我们来求 $p'_{yes}$。这是 $\\mathcal{A}'$ 对属于补语言 $\\bar{L}$ 的输入字符串 $y$ 输出 1 的概率。根据补语言的定义，如果 $y \\in \\bar{L}$，那么 $y \\notin L$。\n$$p'_{yes} = P_{\\mathcal{A}'}(1|y) \\quad \\text{其中 } y \\in \\bar{L}$$\n使用我们推导出的关系：\n$$p'_{yes} = 1 - P_{\\mathcal{A}}(1|y)$$\n根据问题陈述，对于任何不在 $L$ 中的字符串（如 $y$），算法 $\\mathcal{A}$ 输出 1 的概率是 $p_{no}$。所以，$P_{\\mathcal{A}}(1|y) = p_{no}$。\n将此代入，我们得到：\n$$p'_{yes} = 1 - p_{no}$$\n\n接下来，我们来求 $p'_{no}$。这是 $\\mathcal{A}'$ 对不属于补语言 $\\bar{L}$ 的输入字符串 $z$ 输出 1 的概率。如果 $z \\notin \\bar{L}$，这意味着 $z \\in L$。\n$$p'_{no} = P_{\\mathcal{A}'}(1|z) \\quad \\text{其中 } z \\notin \\bar{L}$$\n再次使用我们推导出的关系：\n$$p'_{no} = 1 - P_{\\mathcal{A}}(1|z)$$\n根据问题陈述，对于任何在 $L$ 中的字符串（如 $z$），算法 $\\mathcal{A}$ 输出 1 的概率是 $p_{yes}$。所以，$P_{\\mathcal{A}}(1|z) = p_{yes}$。\n将此代入，我们得到：\n$$p'_{no} = 1 - p_{yes}$$\n\n因此，新的概率对 $(p'_{yes}, p'_{no})$ 是 $(1 - p_{no}, 1 - p_{yes})$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 - p_{no}  1 - p_{yes} \\end{pmatrix}}$$"
        }
    ]
}