{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a conceptual on-ramp to the world of Multi-Prover Interactive Proofs ($MIP$). We will explore the fundamental advantage of using two non-communicating provers: the ability to perform consistency checks. By designing queries for a simple 3-SAT clause, you'll see firsthand how a verifier can detect inconsistencies in a claimed solution, a core principle that underpins the power of $MIP$ systems .",
            "id": "1458993",
            "problem": "In the field of computational complexity theory, the $MIP = NEXP$ theorem establishes a remarkable connection between Multiprover Interactive Proof (MIP) systems and the complexity class NEXP (nondeterministic exponential time). A key element in the proof that NP is contained in MIP involves a verifier checking a claimed satisfying assignment for a 3-SAT formula by querying two non-communicating provers.\n\nConsider a verifier, $V$, interacting with two provers, $P_1$ and $P_2$. The provers claim to possess a satisfying assignment for a large 3-CNF formula, $\\phi$. The verifier's protocol involves randomly selecting a clause from $\\phi$ and performing a test to check for correctness and consistency.\n\nSuppose the verifier decides to test the specific clause $C = (\\neg x_1 \\lor x_2 \\lor \\neg x_3)$. Furthermore, suppose the provers' shared (but secret) assignment, let's call it $A$, is actually faulty and falsifies this particular clause. Specifically, for the variables in $C$, the assignment is $A(x_1) = 1$, $A(x_2) = 0$, and $A(x_3) = 1$.\n\nThe verifier must design its pair of queries, $(Q_1, Q_2)$, sent to $(P_1, P_2)$ respectively, to expose this discrepancy. Assume that the provers are committed to their assignment $A$ and will answer any query regarding the values of variables truthfully according to $A$.\n\nWhich of the following query pairs $(Q_1, Q_2)$ allows the verifier to deterministically conclude that the provided assignment values for clause $C$ are not satisfying?\n\nA. $Q_1$: \"Report the value of $x_1$.\" $Q_2$: \"Report the values of $x_2$ and $x_3$.\"\n\nB. $Q_1$: \"Report the value of $x_1$.\" $Q_2$: \"Report the value of $x_2$.\"\n\nC. $Q_1$: \"Report the value of $x_1$.\" $Q_2$: \"Report the value of $x_1$.\"\n\nD. $Q_1$: \"Is clause $C$ satisfied by your assignment?\" $Q_2$: \"Is clause $C$ satisfied by your assignment?\"",
            "solution": "We formalize the clause and the assignment. The clause is $C = (\\neg x_{1} \\lor x_{2} \\lor \\neg x_{3})$. The assignment given by the provers is $A(x_{1}) = 1$, $A(x_{2}) = 0$, $A(x_{3}) = 1$. Evaluating the literals under $A$ yields $\\neg x_{1} = 0$, $x_{2} = 0$, and $\\neg x_{3} = 0$. Therefore,\n$$\nC(A) \\;=\\; 0 \\lor 0 \\lor 0 \\;=\\; 0,\n$$\nso $C$ is falsified by $A$.\n\nA 3-CNF clause is unsatisfied if and only if all three of its literals are false. Thus, to deterministically conclude that $C$ is not satisfied, the verifier must obtain verified values establishing $x_{1} = 1$, $x_{2} = 0$, and $x_{3} = 1$ (equivalently, that $\\neg x_{1} = 0$, $x_{2} = 0$, and $\\neg x_{3} = 0$). The problem states that the provers will answer any query regarding the values of variables truthfully according to $A$, so the verifier can rely only on variable-value responses.\n\nNow we analyze each option with this requirement:\n\nOption A: $Q_{1}$ asks for $x_{1}$ and $Q_{2}$ asks for $x_{2}$ and $x_{3}$. From these answers the verifier obtains all three values $x_{1}, x_{2}, x_{3}$ and can compute the three literals $\\neg x_{1}, x_{2}, \\neg x_{3}$. Since the verifier learns that all three literals are $0$, it can deterministically conclude $C(A) = 0$.\n\nOption B: $Q_{1}$ asks for $x_{1}$ and $Q_{2}$ asks for $x_{2}$. The verifier does not learn $x_{3}$, hence cannot rule out the possibility $x_{3} = 0$, in which case $\\neg x_{3} = 1$ and $C$ would be satisfied. Therefore, no deterministic conclusion is possible.\n\nOption C: Both queries ask for $x_{1}$, which reveals no information about $x_{2}$ or $x_{3}$; the verifier cannot determine whether all three literals are false, so no deterministic conclusion is possible.\n\nOption D: Both queries ask whether $C$ is satisfied. The stated guarantee covers only queries about variable values; it does not assert truthful answers to satisfaction questions. Therefore, the verifier cannot rely on these yes/no responses to deterministically conclude unsatisfaction under the given assumptions.\n\nHence, only Option A ensures that the verifier obtains exactly the information needed (all three variable values for the clause) in a way guaranteed to be truthful, allowing a deterministic conclusion that $C$ is not satisfied.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Having seen the conceptual utility of multiple provers, we now delve into the core technical engine of the $MIP = NEXP$ theorem: arithmetization. This practice guides you through the process of converting a logical satisfiability problem into a system of polynomial equations over a finite field. You will learn how to represent logical clauses and boolean constraints algebraically and then combine them into a single, compact polynomial, which is the object the verifier actually checks .",
            "id": "1459025",
            "problem": "In the study of interactive proof systems, a common technique is to \"arithmetize\" a problem, converting a logical statement into a set of polynomial equations. This allows a Verifier to check a Prover's claim by performing algebraic tests over a finite field.\n\nConsider a Boolean satisfiability problem with three variables, $x_1, x_2, x_3$. A Prover claims to have an assignment of values from $\\{0, 1\\}$ to these variables that satisfies the following set of clauses:\n1. $C_1 = (x_1 \\lor \\neg x_2)$\n2. $C_2 = (\\neg x_1 \\lor x_2 \\lor x_3)$\n3. $C_3 = (\\neg x_2 \\lor \\neg x_3)$\n\nTo verify this claim, the system of constraints must be converted into polynomial equations over a large finite field. A valid assignment must satisfy two types of constraints:\n- **Clause Constraints**: Each clause must be satisfied. A clause is satisfied if its corresponding polynomial constraint evaluates to 0. This polynomial is constructed to be 1 only when the clause is *unsatisfied*, and 0 otherwise. A clause is unsatisfied if and only if all of its literals are false. The polynomial representing the 'false' condition for a positive literal $x_i$ is $(1-x_i)$, and for a negative literal $\\neg x_i$ is $x_i$. The constraint polynomial for a clause is the product of these 'false' condition polynomials for all literals in that clause.\n- **Boolean Constraints**: Each variable must be either 0 or 1. For each variable $x_i$, this is enforced by the equation $x_i^2 - x_i = 0$.\n\nInstead of checking each of these polynomial equations individually, the Verifier combines them into a single probabilistic check. The Verifier selects random coefficients $r_1, r_2, r_3, r_4, r_5, r_6$ from the underlying field and constructs a single polynomial $P(x_1, x_2, x_3)$ which is the linear combination of all the constraint polynomials. The coefficients $r_1, r_2, r_3$ correspond to the clauses $C_1, C_2, C_3$ respectively. The coefficients $r_4, r_5, r_6$ correspond to the Boolean constraints for $x_1, x_2, x_3$ respectively.\n\nYour task is to construct this combined polynomial $P(x_1, x_2, x_3)$. Express your final answer as a polynomial in the variables $x_1, x_2, x_3$, with coefficients written in terms of the symbolic random coefficients $r_1, \\dots, r_6$. The terms in your polynomial should be sorted first by total degree (highest to lowest), and then lexicographically for terms of the same total degree (e.g., $x_1^2$ before $x_1 x_2$, and $x_1 x_2$ before $x_2^2$).",
            "solution": "The goal is to construct a single polynomial $P(x_1, x_2, x_3)$ that is a random linear combination of several constraint polynomials. We must first identify all the constraint polynomials.\n\n**Step 1: Arithmetize the Clause Constraints**\n\nWe are given a rule to convert each clause into a polynomial constraint $p_i(x_1, x_2, x_3) = 0$. The polynomial is formed by multiplying the 'false' condition polynomials for each literal in the clause. The 'false' polynomial for a literal $x_i$ is $(1-x_i)$, and for $\\neg x_i$ it is $x_i$.\n\n1.  **Clause $C_1 = (x_1 \\lor \\neg x_2)$**: This clause is unsatisfied if $x_1$ is false AND $\\neg x_2$ is false.\n    -   The 'false' condition for $x_1$ is represented by the polynomial $(1-x_1)$.\n    -   The 'false' condition for $\\neg x_2$ is represented by the polynomial $x_2$.\n    -   The constraint polynomial is their product: $p_1(x_1, x_2, x_3) = (1-x_1)x_2 = x_2 - x_1 x_2$.\n\n2.  **Clause $C_2 = (\\neg x_1 \\lor x_2 \\lor x_3)$**: This clause is unsatisfied if $\\neg x_1$ is false AND $x_2$ is false AND $x_3$ is false.\n    -   The 'false' condition for $\\neg x_1$ is $x_1$.\n    -   The 'false' condition for $x_2$ is $(1-x_2)$.\n    -   The 'false' condition for $x_3$ is $(1-x_3)$.\n    -   The constraint polynomial is their product: $p_2(x_1, x_2, x_3) = x_1(1-x_2)(1-x_3) = x_1(1 - x_3 - x_2 + x_2 x_3) = x_1 - x_1 x_2 - x_1 x_3 + x_1 x_2 x_3$.\n\n3.  **Clause $C_3 = (\\neg x_2 \\lor \\neg x_3)$**: This clause is unsatisfied if $\\neg x_2$ is false AND $\\neg x_3$ is false.\n    -   The 'false' condition for $\\neg x_2$ is $x_2$.\n    -   The 'false' condition for $\\neg x_3$ is $x_3$.\n    -   The constraint polynomial is their product: $p_3(x_1, x_2, x_3) = x_2 x_3$.\n\n**Step 2: Define the Boolean Constraints**\n\nThe variables must take values in $\\{0, 1\\}$. This is enforced by the polynomial equation $x_i(x_i - 1) = 0$, or $x_i^2 - x_i = 0$.\n\n4.  For $x_1$: $p_4(x_1, x_2, x_3) = x_1^2 - x_1$.\n5.  For $x_2$: $p_5(x_1, x_2, x_3) = x_2^2 - x_2$.\n6.  For $x_3$: $p_6(x_1, x_2, x_3) = x_3^2 - x_3$.\n\n**Step 3: Construct the Combined Polynomial**\n\nThe Verifier's polynomial $P$ is the random linear combination of all six constraint polynomials:\n$$P(x_1, x_2, x_3) = \\sum_{i=1}^{6} r_i p_i(x_1, x_2, x_3)$$\nSubstituting the expressions for each $p_i$:\n$$P(x_1, x_2, x_3) = r_1(x_2 - x_1 x_2) + r_2(x_1 - x_1 x_2 - x_1 x_3 + x_1 x_2 x_3) + r_3(x_2 x_3) + r_4(x_1^2 - x_1) + r_5(x_2^2 - x_2) + r_6(x_3^2 - x_3)$$\n\n**Step 4: Expand and Collect Terms**\n\nNow, we expand the expression and group terms by the monomials of $x_1, x_2, x_3$.\n\n$P(x_1, x_2, x_3) = r_1 x_2 - r_1 x_1 x_2 + r_2 x_1 - r_2 x_1 x_2 - r_2 x_1 x_3 + r_2 x_1 x_2 x_3 + r_3 x_2 x_3 + r_4 x_1^2 - r_4 x_1 + r_5 x_2^2 - r_5 x_2 + r_6 x_3^2 - r_6 x_3$\n\nLet's collect coefficients for each monomial, ordering them by degree and then lexicographically:\n\n-   **Degree 3 terms:**\n    -   $x_1 x_2 x_3$: $r_2$\n\n-   **Degree 2 terms:**\n    -   $x_1^2$: $r_4$\n    -   $x_1 x_2$: $-r_1 - r_2$\n    -   $x_1 x_3$: $-r_2$\n    -   $x_2^2$: $r_5$\n    -   $x_2 x_3$: $r_3$\n    -   $x_3^2$: $r_6$\n\n-   **Degree 1 terms:**\n    -   $x_1$: $r_2 - r_4$\n    -   $x_2$: $r_1 - r_5$\n    -   $x_3$: $-r_6$\n\n-   **Degree 0 term (constant):** There is no constant term.\n\nCombining these results gives the final polynomial:\n$P(x_1, x_2, x_3) = r_2 x_1 x_2 x_3 + r_4 x_1^2 + r_5 x_2^2 + r_6 x_3^2 + (-r_1 - r_2)x_1 x_2 - r_2 x_1 x_3 + r_3 x_2 x_3 + (r_2 - r_4)x_1 + (r_1 - r_5)x_2 - r_6 x_3$.\nFollowing the specified sorting order: $x_1 x_2 x_3$ (degree 3), then $x_1^2, x_1 x_2, x_1 x_3, x_2^2, x_2 x_3, x_3^2$ (degree 2), then $x_1, x_2, x_3$ (degree 1).\nThe polynomial is:\n$P(x_1, x_2, x_3) = r_2 x_1 x_2 x_3 + r_4 x_1^2 + (-r_1 - r_2) x_1 x_2 - r_2 x_1 x_3 + r_5 x_2^2 + r_3 x_2 x_3 + r_6 x_3^2 + (r_2 - r_4) x_1 + (r_1 - r_5) x_2 - r_6 x_3$.",
            "answer": "$$\\boxed{r_2 x_1 x_2 x_3 + r_4 x_1^2 + (-r_1 - r_2) x_1 x_2 - r_2 x_1 x_3 + r_5 x_2^2 + r_3 x_2 x_3 + r_6 x_3^2 + (r_2 - r_4) x_1 + (r_1 - r_5) x_2 - r_6 x_3}$$"
        },
        {
            "introduction": "The security of a probabilistic protocol rests on the quality of its randomness. This final practice explores what happens when this assumption is weakened, forcing us to think about the protocol's soundness from an adversarial perspective. By analyzing a scenario where the verifier's queries are predictable, you will determine the minimum-degree polynomial that can \"fool\" the verifier, directly linking the algebraic properties of polynomials to the security guarantees of the interactive proof .",
            "id": "1459016",
            "problem": "In the study of computational complexity, a Multi-Prover Interactive Proof ($MIP$) system involves a probabilistic polynomial-time verifier interacting with two or more powerful, non-communicating provers to decide membership in a language. A cornerstone result, known as $MIP = NEXP$, establishes that this model captures the complexity class Nondeterministic Exponential Time ($NEXP$). Many such protocols rely on the provers committing to a low-degree multivariate polynomial over a finite field, which the verifier then spot-checks at random points.\n\nConsider a flawed $MIP$ protocol designed to operate over the finite field $\\mathbb{F}_p$ for some large prime $p$. The provers are supposed to commit to a function $A: \\mathbb{F}_p^n \\to \\mathbb{F}_p$ that they claim is a polynomial of a specified total degree. A critical vulnerability is discovered in the verifier's random number generator: instead of sampling points from the entire space $\\mathbb{F}_p^n$, all its queries are drawn from a smaller, publicly known set of points $Q = \\{q_1, q_2, \\ldots, q_M\\} \\subset \\mathbb{F}_p^n$, where $M$ is polynomial in $n$.\n\nMalicious provers can exploit this knowledge. To cheat a test that expects the zero polynomial as the correct answer, they can construct a polynomial $A_{\\text{cheat}}$ that is not identically the zero polynomial, but evaluates to zero on all points in the restricted query set $Q$. The complexity of constructing such a deceptive polynomial is related to its total degree.\n\nLet's analyze a specific instance of this scenario. Consider the case with $n=2$ variables over $\\mathbb{F}_p$. The known query set $Q$ is a rectangular grid of points defined as:\n$$\nQ = \\{ (i, j) \\in \\mathbb{F}_p^2 \\mid i \\in \\{0, 1, \\dots, k-1\\}, j \\in \\{0, 1, \\dots, k-1\\} \\}\n$$\nwhere $k$ is a positive integer such that $k < p$. The size of this set is $M = k^2$.\n\nFind an explicit formula for the minimum possible total degree of a non-zero polynomial $A(x, y)$ that vanishes on all points of this $k \\times k$ grid $Q$. Express your answer in terms of $k$.",
            "solution": "We work over the field $\\mathbb{F}_{p}$ with $k<p$, and consider the grid $Q=S\\times S$ where $S=\\{0,1,\\ldots,k-1\\}\\subset\\mathbb{F}_{p}$.\n\nFirst, we provide an explicit nonzero polynomial that vanishes on all of $Q$, giving an upper bound on the minimum possible total degree. Define\n$$\nF(x)=\\prod_{i=0}^{k-1}(x-i).\n$$\nThen $F(x)$ has degree $k$ (in one variable), hence total degree $k$ when regarded as a bivariate polynomial in $(x,y)$ that depends only on $x$. For every $(x,y)\\in Q$, we have $x\\in S$, so $F(x)=0$. Therefore $F(x)$ vanishes on $Q$, showing that the minimum total degree is at most $k$.\n\nNext, we show a matching lower bound. A fundamental principle over any field is that a nonzero univariate polynomial of degree $d$ has at most $d$ distinct roots. Suppose, toward contradiction, that there exists a nonzero bivariate polynomial $A(x,y)$ of total degree $d<k$ that vanishes on all of $Q$. Consider $A(x,y)$ as a univariate polynomial in $x$ with coefficients in $\\mathbb{F}_{p}[y]$:\n$$\nA(x,y)=\\sum_{r=0}^{R} c_{r}(y)\\,x^{r},\n$$\nwhere $R=\\deg_{x}A\\leq d<k$ and each $c_{r}(y)\\in\\mathbb{F}_{p}[y]$. For any fixed $y_{0}\\in S$, the univariate polynomial $x\\mapsto A(x,y_{0})$ has $k$ distinct roots $x\\in S$. Since $\\deg_{x}A<k$, it must be the zero polynomial in $x$ for each $y_{0}\\in S$, implying $c_{r}(y_{0})=0$ for all $r$ and all $y_{0}\\in S$. Hence, for each $r$, the coefficient polynomial $c_{r}(y)$ has at least $k$ distinct roots in $\\mathbb{F}_{p}$.\n\nMoreover, because the total degree of $A$ is $d$, each $c_{r}(y)$ has degree in $y$ at most $d-r\\leq d<k$. A nonzero univariate polynomial over a field of degree less than $k$ cannot have $k$ distinct roots; thus each $c_{r}(y)$ must be the zero polynomial. Therefore all coefficients $c_{r}$ vanish identically, forcing $A$ to be the zero polynomial, a contradiction.\n\nThis shows that any nonzero polynomial vanishing on $Q$ must have total degree at least $k$. Combined with the explicit example of degree $k$, the minimum possible total degree is exactly $k$.",
            "answer": "$$\\boxed{k}$$"
        }
    ]
}