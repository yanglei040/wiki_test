{
    "hands_on_practices": [
        {
            "introduction": "The power of multi-prover interactive proofs stems from the verifier's ability to cross-examine non-communicating provers. By asking different but related questions, the verifier can detect inconsistencies in the provers' claimed solution without having to trust them. This exercise () provides a concrete example of this principle, demonstrating how a simple query strategy can deterministically reveal a flaw in a claimed satisfying assignment for a 3-SAT clause.",
            "id": "1458993",
            "problem": "In the field of computational complexity theory, the $\\text{MIP} = \\text{NEXP}$ theorem establishes a remarkable connection between Multiprover Interactive Proof (MIP) systems and the complexity class NEXP (nondeterministic exponential time). A key element in the proof that $\\text{NP}$ is contained in $\\text{MIP}$ involves a verifier checking a claimed satisfying assignment for a 3-SAT formula by querying two non-communicating provers.\n\nConsider a verifier, $V$, interacting with two provers, $P_1$ and $P_2$. The provers claim to possess a satisfying assignment for a large 3-CNF formula, $\\phi$. The verifier's protocol involves randomly selecting a clause from $\\phi$ and performing a test to check for correctness and consistency.\n\nSuppose the verifier decides to test the specific clause $C = (\\neg x_1 \\lor x_2 \\lor \\neg x_3)$. Furthermore, suppose the provers' shared (but secret) assignment, let's call it $A$, is actually faulty and falsifies this particular clause. Specifically, for the variables in $C$, the assignment is $A(x_1) = 1$, $A(x_2) = 0$, and $A(x_3) = 1$.\n\nThe verifier must design its pair of queries, $(Q_1, Q_2)$, sent to $(P_1, P_2)$ respectively, to expose this discrepancy. Assume that the provers are committed to their assignment $A$ and will answer any query regarding the values of variables truthfully according to $A$.\n\nWhich of the following query pairs $(Q_1, Q_2)$ allows the verifier to deterministically conclude that the provided assignment values for clause $C$ are not satisfying?\n\nA. $Q_1$: \"Report the value of $x_1$.\" $Q_2$: \"Report the values of $x_2$ and $x_3$.\"\n\nB. $Q_1$: \"Report the value of $x_1$.\" $Q_2$: \"Report the value of $x_2$.\"\n\nC. $Q_1$: \"Report the value of $x_1$.\" $Q_2$: \"Report the value of $x_1$.\"\n\nD. $Q_1$: \"Is clause $C$ satisfied by your assignment?\" $Q_2$: \"Is clause $C$ satisfied by your assignment?\"",
            "solution": "We formalize the clause and the assignment. The clause is $C = (\\neg x_{1} \\lor x_{2} \\lor \\neg x_{3})$. The assignment given by the provers is $A(x_{1}) = 1$, $A(x_{2}) = 0$, $A(x_{3}) = 1$. Evaluating the literals under $A$ yields $\\neg x_{1} = 0$, $x_{2} = 0$, and $\\neg x_{3} = 0$. Therefore,\n$$\nC(A) \\;=\\; 0 \\lor 0 \\lor 0 \\;=\\; 0,\n$$\nso $C$ is falsified by $A$.\n\nA 3-CNF clause is unsatisfied if and only if all three of its literals are false. Thus, to deterministically conclude that $C$ is not satisfied, the verifier must obtain verified values establishing $x_{1} = 1$, $x_{2} = 0$, and $x_{3} = 1$ (equivalently, that $\\neg x_{1} = 0$, $x_{2} = 0$, and $\\neg x_{3} = 0$). The problem states that the provers will answer any query regarding the values of variables truthfully according to $A$, so the verifier can rely only on variable-value responses.\n\nNow we analyze each option with this requirement:\n\nOption A: $Q_{1}$ asks for $x_{1}$ and $Q_{2}$ asks for $x_{2}$ and $x_{3}$. From these answers the verifier obtains all three values $x_{1}, x_{2}, x_{3}$ and can compute the three literals $\\neg x_{1}, x_{2}, \\neg x_{3}$. Since the verifier learns that all three literals are $0$, it can deterministically conclude $C(A) = 0$.\n\nOption B: $Q_{1}$ asks for $x_{1}$ and $Q_{2}$ asks for $x_{2}$. The verifier does not learn $x_{3}$, hence cannot rule out the possibility $x_{3} = 0$, in which case $\\neg x_{3} = 1$ and $C$ would be satisfied. Therefore, no deterministic conclusion is possible.\n\nOption C: Both queries ask for $x_{1}$, which reveals no information about $x_{2}$ or $x_{3}$; the verifier cannot determine whether all three literals are false, so no deterministic conclusion is possible.\n\nOption D: Both queries ask whether $C$ is satisfied. The stated guarantee covers only queries about variable values; it does not assert truthful answers to satisfaction questions. Therefore, the verifier cannot rely on these yes/no responses to deterministically conclude unsatisfaction under the given assumptions.\n\nHence, only Option A ensures that the verifier obtains exactly the information needed (all three variable values for the clause) in a way guaranteed to be truthful, allowing a deterministic conclusion that $C$ is not satisfied.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "To scale up the verification process for exponentially complex problems, we translate the logical structure of a problem into the language of algebra, a technique called \"arithmetization\". This powerful method converts a set of logical constraints into a system of polynomial equations that must all evaluate to zero for a valid solution. This practice () guides you through the concrete steps of arithmetizing a small 3-SAT instance and demonstrates how to combine all constraints into a single probabilistic check.",
            "id": "1459025",
            "problem": "In the study of interactive proof systems, a common technique is to \"arithmetize\" a problem, converting a logical statement into a set of polynomial equations. This allows a Verifier to check a Prover's claim by performing algebraic tests over a finite field.\n\nConsider a Boolean satisfiability problem with three variables, $x_1, x_2, x_3$. A Prover claims to have an assignment of values from $\\{0, 1\\}$ to these variables that satisfies the following set of clauses:\n1. $C_1 = (x_1 \\lor \\neg x_2)$\n2. $C_2 = (\\neg x_1 \\lor x_2 \\lor x_3)$\n3. $C_3 = (\\neg x_2 \\lor \\neg x_3)$\n\nTo verify this claim, the system of constraints must be converted into polynomial equations over a large finite field. A valid assignment must satisfy two types of constraints:\n- **Clause Constraints**: Each clause must be satisfied. A clause is satisfied if its corresponding polynomial constraint evaluates to 0. This polynomial is constructed to be 1 only when the clause is *unsatisfied*, and 0 otherwise. A clause is unsatisfied if and only if all of its literals are false. The polynomial representing the 'false' condition for a positive literal $x_i$ is $(1-x_i)$, and for a negative literal $\\neg x_i$ is $x_i$. The constraint polynomial for a clause is the product of these 'false' condition polynomials for all literals in that clause.\n- **Boolean Constraints**: Each variable must be either 0 or 1. For each variable $x_i$, this is enforced by the equation $x_i^2 - x_i = 0$.\n\nInstead of checking each of these polynomial equations individually, the Verifier combines them into a single probabilistic check. The Verifier selects random coefficients $r_1, r_2, r_3, r_4, r_5, r_6$ from the underlying field and constructs a single polynomial $P(x_1, x_2, x_3)$ which is the linear combination of all the constraint polynomials. The coefficients $r_1, r_2, r_3$ correspond to the clauses $C_1, C_2, C_3$ respectively. The coefficients $r_4, r_5, r_6$ correspond to the Boolean constraints for $x_1, x_2, x_3$ respectively.\n\nYour task is to construct this combined polynomial $P(x_1, x_2, x_3)$. Express your final answer as a polynomial in the variables $x_1, x_2, x_3$, with coefficients written in terms of the symbolic random coefficients $r_1, \\dots, r_6$. The terms in your polynomial should be sorted first by total degree (highest to lowest), and then lexicographically for terms of the same total degree (e.g., $x_1^2$ before $x_1 x_2$, and $x_1 x_2$ before $x_2^2$).",
            "solution": "The goal is to construct a single polynomial $P(x_1, x_2, x_3)$ that is a random linear combination of several constraint polynomials. We must first identify all the constraint polynomials.\n\n**Step 1: Arithmetize the Clause Constraints**\n\nWe are given a rule to convert each clause into a polynomial constraint $p_i(x_1, x_2, x_3) = 0$. The polynomial is formed by multiplying the 'false' condition polynomials for each literal in the clause. The 'false' polynomial for a literal $x_i$ is $(1-x_i)$, and for $\\neg x_i$ it is $x_i$.\n\n1.  **Clause $C_1 = (x_1 \\lor \\neg x_2)$**: This clause is unsatisfied if $x_1$ is false AND $\\neg x_2$ is false.\n    -   The 'false' condition for $x_1$ is represented by the polynomial $(1-x_1)$.\n    -   The 'false' condition for $\\neg x_2$ is represented by the polynomial $x_2$.\n    -   The constraint polynomial is their product: $p_1(x_1, x_2, x_3) = (1-x_1)x_2 = x_2 - x_1 x_2$.\n\n2.  **Clause $C_2 = (\\neg x_1 \\lor x_2 \\lor x_3)$**: This clause is unsatisfied if $\\neg x_1$ is false AND $x_2$ is false AND $x_3$ is false.\n    -   The 'false' condition for $\\neg x_1$ is $x_1$.\n    -   The 'false' condition for $x_2$ is $(1-x_2)$.\n    -   The 'false' condition for $x_3$ is $(1-x_3)$.\n    -   The constraint polynomial is their product: $p_2(x_1, x_2, x_3) = x_1(1-x_2)(1-x_3) = x_1(1 - x_3 - x_2 + x_2 x_3) = x_1 - x_1 x_2 - x_1 x_3 + x_1 x_2 x_3$.\n\n3.  **Clause $C_3 = (\\neg x_2 \\lor \\neg x_3)$**: This clause is unsatisfied if $\\neg x_2$ is false AND $\\neg x_3$ is false.\n    -   The 'false' condition for $\\neg x_2$ is $x_2$.\n    -   The 'false' condition for $\\neg x_3$ is $x_3$.\n    -   The constraint polynomial is their product: $p_3(x_1, x_2, x_3) = x_2 x_3$.\n\n**Step 2: Define the Boolean Constraints**\n\nThe variables must take values in $\\{0, 1\\}$. This is enforced by the polynomial equation $x_i(x_i - 1) = 0$, or $x_i^2 - x_i = 0$.\n\n4.  For $x_1$: $p_4(x_1, x_2, x_3) = x_1^2 - x_1$.\n5.  For $x_2$: $p_5(x_1, x_2, x_3) = x_2^2 - x_2$.\n6.  For $x_3$: $p_6(x_1, x_2, x_3) = x_3^2 - x_3$.\n\n**Step 3: Construct the Combined Polynomial**\n\nThe Verifier's polynomial $P$ is the random linear combination of all six constraint polynomials:\n$$P(x_1, x_2, x_3) = \\sum_{i=1}^{6} r_i p_i(x_1, x_2, x_3)$$\nSubstituting the expressions for each $p_i$:\n$$P(x_1, x_2, x_3) = r_1(x_2 - x_1 x_2) + r_2(x_1 - x_1 x_2 - x_1 x_3 + x_1 x_2 x_3) + r_3(x_2 x_3) + r_4(x_1^2 - x_1) + r_5(x_2^2 - x_2) + r_6(x_3^2 - x_3)$$\n\n**Step 4: Expand and Collect Terms**\n\nNow, we expand the expression and group terms by the monomials of $x_1, x_2, x_3$.\n\n$P(x_1, x_2, x_3) = r_1 x_2 - r_1 x_1 x_2 + r_2 x_1 - r_2 x_1 x_2 - r_2 x_1 x_3 + r_2 x_1 x_2 x_3 + r_3 x_2 x_3 + r_4 x_1^2 - r_4 x_1 + r_5 x_2^2 - r_5 x_2 + r_6 x_3^2 - r_6 x_3$\n\nLet's collect coefficients for each monomial, ordering them by degree and then lexicographically:\n\n-   **Degree 3 terms:**\n    -   $x_1 x_2 x_3$: $r_2$\n\n-   **Degree 2 terms:**\n    -   $x_1^2$: $r_4$\n    -   $x_1 x_2$: $-r_1 - r_2$\n    -   $x_1 x_3$: $-r_2$\n    -   $x_2^2$: $r_5$\n    -   $x_2 x_3$: $r_3$\n    -   $x_3^2$: $r_6$\n\n-   **Degree 1 terms:**\n    -   $x_1$: $r_2 - r_4$\n    -   $x_2$: $r_1 - r_5$\n    -   $x_3$: $-r_6$\n\n-   **Degree 0 term (constant):** There is no constant term.\n\nCombining these results gives the final polynomial:\n$P(x_1, x_2, x_3) = r_2 x_1 x_2 x_3 + r_4 x_1^2 + r_5 x_2^2 + r_6 x_3^2 + (-r_1 - r_2)x_1 x_2 - r_2 x_1 x_3 + r_3 x_2 x_3 + (r_2 - r_4)x_1 + (r_1 - r_5)x_2 - r_6 x_3$.\nFollowing the specified sorting order: $x_1 x_2 x_3$ (degree 3), then $x_1^2, x_1 x_2, x_1 x_3, x_2^2, x_2 x_3, x_3^2$ (degree 2), then $x_1, x_2, x_3$ (degree 1).\nThe polynomial is:\n$P(x_1, x_2, x_3) = r_2 x_1 x_2 x_3 + r_4 x_1^2 + (-r_1 - r_2) x_1 x_2 - r_2 x_1 x_3 + r_5 x_2^2 + r_3 x_2 x_3 + r_6 x_3^2 + (r_2 - r_4) x_1 + (r_1 - r_5) x_2 - r_6 x_3$.",
            "answer": "$$\\boxed{r_2 x_1 x_2 x_3 + r_4 x_1^2 + (-r_1 - r_2) x_1 x_2 - r_2 x_1 x_3 + r_5 x_2^2 + r_3 x_2 x_3 + r_6 x_3^2 + (r_2 - r_4) x_1 + (r_1 - r_5) x_2 - r_6 x_3}$$"
        },
        {
            "introduction": "Once a problem is arithmetized into a polynomial, the verifier needs an efficient way to check if it is identically zero. The key is probabilistic testing, guaranteed by the Schwartz-Zippel lemma, which states that a non-zero polynomial is unlikely to evaluate to zero on a random input. This exercise () makes this abstract guarantee tangible by having you calculate the practical trade-off between the verifier's resources (the size of the field) and the protocol's reliability (the soundness error).",
            "id": "1459033",
            "problem": "A computer algebra system designer is implementing a probabilistic algorithm to verify if the determinant of a large symbolic matrix is identically zero. The matrix, denoted as $M(z_1, \\dots, z_k)$, is an $n \\times n$ matrix whose entries $M_{ij}$ are polynomials in $k$ variables $z_1, \\dots, z_k$. It is known that the total degree of each polynomial entry $M_{ij}(z_1, \\dots, z_k)$ is at most $\\delta$.\n\nThe verification protocol is as follows:\n1.  Choose a finite field $\\mathbb{F}$ of integer size $S$.\n2.  Select a point $\\mathbf{r} = (r_1, \\dots, r_k)$ uniformly at random from the set $\\mathbb{F}^k$.\n3.  Evaluate the determinant of the matrix at this point, $\\det(M(\\mathbf{r}))$.\n4.  If $\\det(M(\\mathbf{r})) = 0$, the protocol concludes that the determinant is identically zero. Otherwise, it concludes it is not.\n\nThe \"soundness error\" is the probability that the protocol incorrectly concludes the determinant is identically zero when it is, in fact, a non-zero polynomial. The system's design specification mandates that this soundness error must be strictly less than a tolerance $\\epsilon$.\n\nGiven the parameters $n = 80$, $\\delta = 5$, and a required tolerance of $\\epsilon = 3.9 \\times 10^{-9}$, what is the minimum integer size $S$ of the finite field $\\mathbb{F}$ that satisfies this requirement?",
            "solution": "Let $P(z_{1},\\dots,z_{k})=\\det(M(z_{1},\\dots,z_{k}))$. By the permutation expansion of the determinant,\n$$\nP(z_{1},\\dots,z_{k})=\\sum_{\\sigma\\in S_{n}}\\operatorname{sgn}(\\sigma)\\prod_{i=1}^{n}M_{i,\\sigma(i)}(z_{1},\\dots,z_{k}).\n$$\nEach entry $M_{ij}$ has total degree at most $\\delta$, so each product term has total degree at most $\\sum_{i=1}^{n}\\deg M_{i,\\sigma(i)}\\leq n\\delta$. Therefore the total degree satisfies\n$$\n\\deg P \\leq n\\delta.\n$$\n\nBy the Schwartz–Zippel–DeMillo–Lipton lemma, for a nonzero polynomial $P$ of total degree $D$ over a field $\\mathbb{F}$ with $|\\mathbb{F}|=S$, the probability over a uniform random choice $\\mathbf{r}\\in\\mathbb{F}^{k}$ that $P(\\mathbf{r})=0$ is at most $D/S$. Hence the soundness error is at most\n$$\n\\frac{\\deg P}{S} \\leq \\frac{n\\delta}{S}.\n$$\nTo ensure the error is strictly less than $\\epsilon$, it suffices to require\n$$\n\\frac{n\\delta}{S}<\\epsilon \\quad\\Longleftrightarrow\\quad S>\\frac{n\\delta}{\\epsilon}.\n$$\nSince $S$ must be an integer, the minimal valid choice is\n$$\nS_{\\min}=\\left\\lfloor\\frac{n\\delta}{\\epsilon}\\right\\rfloor+1.\n$$\n\nSubstituting $n=80$, $\\delta=5$, and $\\epsilon=3.9\\times 10^{-9}$ gives\n$$\n\\frac{n\\delta}{\\epsilon}=\\frac{400}{3.9\\times 10^{-9}}=\\left(\\frac{400}{3.9}\\right)\\times 10^{9}=\\left(\\frac{4000}{39}\\right)\\times 10^{9}=\\frac{4\\times 10^{12}}{39}.\n$$\nCompute the integer part:\n$$\n\\frac{4\\times 10^{12}}{39}=102{,}564{,}102{,}564+\\frac{4}{39},\n$$\nso\n$$\n\\left\\lfloor\\frac{n\\delta}{\\epsilon}\\right\\rfloor=102{,}564{,}102{,}564,\n$$\nand therefore\n$$\nS_{\\min}=102{,}564{,}102{,}564+1=102{,}564{,}102{,}565.\n$$\nThis choice guarantees the soundness error is strictly less than $\\epsilon$.",
            "answer": "$$\\boxed{102564102565}$$"
        }
    ]
}