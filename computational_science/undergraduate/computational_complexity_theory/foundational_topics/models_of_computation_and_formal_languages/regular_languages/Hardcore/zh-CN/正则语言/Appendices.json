{
    "hands_on_practices": [
        {
            "introduction": "确定性有限自动机（DFA）的真正威力在于其能够通过将信息编码到有限数量的状态中来识别模式。第一个练习将挑战你将一个数学属性——模运算——转化为DFA的语言。通过设计一个自动机来检查一个二进制数表示的整数是否与2模3同余，你将获得将抽象概念映射到具体状态转换的实践经验，这是计算理论中的一项核心技能。",
            "id": "1444116",
            "problem": "在计算理论中，一个语言是给定字母表上的字符串集合。考虑字母表 $\\Sigma = \\{0, 1\\}$。我们可以将任何非空二进制字符串 $w = b_k b_{k-1} \\dots b_1 b_0$（其中每个 $b_i \\in \\{0, 1\\}$）使用标准的二进制表示法解释为一个正整数 $N(w)$：\n$$N(w) = \\sum_{i=0}^{k} b_i \\cdot 2^i$$\n例如，字符串 \"101\" 表示数字 $1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 = 4 + 0 + 1 = 5$。\n\n设 $L$ 是由所有非空二进制字符串 $w$ 组成的语言，使得它们所表示的整数 $N(w)$ 满足条件 $N(w) \\equiv 2 \\pmod{3}$。例如，字符串 \"10\" 在 $L$ 中，因为它表示数字 2，且 $2 \\equiv 2 \\pmod{3}$。字符串 \"101\" 也在 $L$ 中，因为它表示数字 5，且 $5 \\equiv 2 \\pmod{3}$。字符串 \"11\" 不在 $L$ 中，因为它表示 3，且 $3 \\equiv 0 \\pmod{3}$。空字符串不在 $L$ 中。\n\n一个接受语言 $L$ 的确定性有限自动机 (DFA) 所需的最小状态数是多少？",
            "solution": "要解决这个问题，我们需要找出接受语言 $L$ 的最小确定性有限自动机 (DFA) 的状态数。语言 $L$ 由二进制字符串 $w$ 组成，其表示的数字 $N(w)$ 满足 $N(w) \\equiv 2 \\pmod{3}$。\n\nDFA 从左到右处理字符串。为了判断一个字符串是否在 $L$ 中，DFA 必须能有效地计算字符串所表示的数值模 3 的值。我们的 DFA 的状态可以表示当前数值模 3 的累积值。由于除以 3 有三种可能的余数（0、1 和 2），我们可以设计一个有三个状态的 DFA，称之为 $q_0, q_1, q_2$。状态 $q_i$ 将对应于目前已处理的、所表示数值与 $i \\pmod{3}$ 同余的字符串集合。\n\n让我们来定义这个 DFA 的组成部分：\n状态 $Q = \\{q_0, q_1, q_2\\}$。\n字母表 $\\Sigma = \\{0, 1\\}$。\n起始状态：处理过程在读取任何字符之前开始。这对应于空字符串，我们可以认为它代表数字 0。由于 $0 \\equiv 0 \\pmod{3}$，起始状态必须是 $q_0$。\n\n转移函数 $\\delta$：我们来分析当追加一个比特位时，数值（模 3）如何变化。假设我们已经处理了一个字符串 $w$，它代表数值 $N(w)$，并且 DFA 处于状态 $q_i$，这意味着 $N(w) \\equiv i \\pmod{3}$。\n如果我们读入一个 '0'，新的字符串是 $w0$。它的值是 $N(w0) = 2 \\cdot N(w) + 0$。模 3 后，这变为 $N(w0) \\equiv 2 \\cdot N(w) \\pmod{3}$。如果 $N(w) \\equiv i \\pmod{3}$，那么 $N(w0) \\equiv 2i \\pmod{3}$。\n如果我们读入一个 '1'，新的字符串是 $w1$。它的值是 $N(w1) = 2 \\cdot N(w) + 1$。模 3 后，这变为 $N(w1) \\equiv 2 \\cdot N(w) + 1 \\pmod{3}$。如果 $N(w) \\equiv i \\pmod{3}$，那么 $N(w1) \\equiv 2i + 1 \\pmod{3}$。\n\n使用这些规则，我们可以定义转移：\n- 状态 $q_0$ ($i=0$)：\n  - 输入 '0' 时：新状态是 $q_{(2 \\cdot 0) \\pmod{3}} = q_0$。所以 $\\delta(q_0, 0) = q_0$。\n  - 输入 '1' 时：新状态是 $q_{(2 \\cdot 0 + 1) \\pmod{3}} = q_1$。所以 $\\delta(q_0, 1) = q_1$。\n- 状态 $q_1$ ($i=1$)：\n  - 输入 '0' 时：新状态是 $q_{(2 \\cdot 1) \\pmod{3}} = q_2$。所以 $\\delta(q_1, 0) = q_2$。\n  - 输入 '1' 时：新状态是 $q_{(2 \\cdot 1 + 1) \\pmod{3}} = q_0$。所以 $\\delta(q_1, 1) = q_0$。\n- 状态 $q_2$ ($i=2$)：\n  - 输入 '0' 时：新状态是 $q_{(2 \\cdot 2) \\pmod{3}} = q_{4 \\pmod{3}} = q_1$。所以 $\\delta(q_2, 0) = q_1$。\n  - 输入 '1' 时：新状态是 $q_{(2 \\cdot 2 + 1) \\pmod{3}} = q_{5 \\pmod{3}} = q_2$。所以 $\\delta(q_2, 1) = q_2$。\n\n接受状态 $F$：语言 $L$ 接受满足 $N(w) \\equiv 2 \\pmod{3}$ 的字符串 $w$。因此，唯一的接受状态是 $q_2$。所以，$F = \\{q_2\\}$。\n\n问题陈述指明空字符串不在 $L$ 中。我们的起始状态是 $q_0$，它不是一个接受状态。因此，空字符串被拒绝，这是正确的。\n\n我们已经构建了一个三状态的 DFA。现在我们必须确认它是最小的。一个 DFA 是最小的，如果它的所有状态都可从起始状态到达，并且所有状态对都是可区分的。\n\n1.  可达性：\n    - $q_0$ 是起始状态，所以是可达的。\n    - $q_1$ 可在输入 \"1\" 时从 $q_0$ 到达。\n    - $q_2$ 可在输入 \"10\" 时从 $q_0$ 到达（$\\delta(q_0, 1) = q_1$，$\\delta(q_1, 0) = q_2$）。\n    所有三个状态都是可达的。\n\n2.  可区分性：两个状态是可区分的，如果存在一个字符串，它能将一个状态引导至接受状态，而将另一个状态引导至非接受状态。\n    - $q_0$ 和 $q_2$：$q_2$ 是接受状态而 $q_0$ 不是。它们可以由空字符串区分。\n    - $q_1$ 和 $q_2$：$q_2$ 是接受状态而 $q_1$ 不是。它们可以由空字符串区分。\n    - $q_0$ 和 $q_1$：从 $q_0$ 开始，输入 \"0\" 会到达 $q_0$（非接受状态）。从 $q_1$ 开始，输入 \"0\" 会到达 $q_2$（接受状态）。因此，$q_0$ 和 $q_1$ 是可区分的。\n\n由于所有三个状态都是可达的且两两可区分，我们构建的 DFA 是最小的。所需的最小状态数是 3。\n这个结果也可以由 Myhill-Nerode 定理预测，该定理指出，一个语言的最小 DFA 的状态数等于 Nerode 关系的等价类的数量。对于本语言，等价类对应于模 3 的三个可能的余数。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "虽然DFA功能强大，但它们也有其根本限制。泵引理是证明某些语言*不是*正则语言的关键理论工具。本练习提供了该引理的一个经典应用，要求你证明为何长度为素数的字符串所构成的语言无法被任何DFA识别。成功完成此证明将加深你对正则语言边界的理解。",
            "id": "1444112",
            "problem": "一位分析师正在研究一种通信协议，其中有效的信号是基于单字符字母表 $\\Sigma = \\{s\\}$ 的字符串。有效信号的语言，记作 $L$，被定义为所有字符串 $s^k$ 的集合，其中长度 $k$ 是一个素数。形式上，$L = \\{ s^k \\mid k \\text{ 是一个素数} \\}$。\n\n该分析师假设 $L$ 不是一个正则语言。为了证明这一点，他们决定使用正则语言的泵引理。该引理指出，对于任何正则语言，都存在一个泵长度 $p$，使得任何长度 $|w| \\ge p$ 的字符串 $w \\in L$ 都可以被分解为三部分 $w=xyz$，并满足三个条件：\n1. $|y| \\ge 1$\n2. $|xy| \\le p$\n3. 对于所有非负整数 $i$，字符串 $xy^iz$ 也必须在 $L$ 中。\n\n为了进行反证，该分析师假设 $L$ 是正则的，并且其泵长度为 $p=8$。他们选择字符串 $w = s^{13}$，该字符串在 $L$ 中，因为 13 是一个素数，并且其长度 13 大于假设的泵长度 $p=8$。根据泵引理，$w$ 可以被分解为 $xyz$，其中 $|xy| \\le 8$ 且 $|y| \\ge 1$。设子串 $y$ 的长度记为 $j$。\n\n对于泵整数 $i$ 的以下哪个选项，可以保证对于 $w$ 的*任何*可能的有效分解（即，对于任何满足 $1 \\le j \\le 8$ 的整数 $j$），所得到的字符串 $xy^iz$ 都*不*在语言 $L$ 中？\n\nA. $i=0$\nB. $i=2$\nC. $i=12$\nD. $i=13$\nE. $i=14$",
            "solution": "为进行反证，假设 $L$ 是正则的，其泵长度为 $p=8$。选择字符串 $w=s^{13}\\in L$，其长度为 $|w|=13 \\ge 8$。根据泵引理，$w$ 可以分解为 $w=xyz$，其中 $|y|\\ge 1$ 且 $|xy|\\leq 8$。在这个一元字母表上，可以写作\n$$\nx=s^{a},\\quad y=s^{j},\\quad z=s^{13-a-j},\n$$\n其中 $a \\ge 0$，$j \\ge 1$，且 $a+j \\le 8$。对于任何泵指数 $i \\ge 0$，泵出的字符串 $xy^iz$ 的长度为\n$$\n|xy^iz| = |x|+i|y|+|z| = a+ij+(13-a-j) = 13+(i-1)j.\n$$\n一个泵出的字符串 $xy^iz$ 在 $L$ 中，当且仅当 $13+(i-1)j$ 是素数。我们需要找到一个 $i$，使得对于每一个有效的分解（等价于对于每一个满足 $1\\leq j\\leq 8$ 的 $j$），数字 $13+(i-1)j$ 都不是素数。\n\n检查每个选项：\n- $i=0$：$13+(0-1)j=13-j$。对于 $j=2,6,8$，我们得到 $11,7,5$，这些都是素数。因此不能保证。\n- $i=2$：$13+(2-1)j=13+j$。对于 $j=4,6$，我们得到 $17,19$，这些都是素数。因此不能保证。\n- $i=12$：$13+(12-1)j=13+11j$。对于 $j=6,8$，我们得到 $79,101$，这些都是素数。因此不能保证。\n- $i=13$：$13+(13-1)j=13+12j$。对于 $j=2,4,5,7,8$，我们得到 $37,61,73,97,109$，这些都是素数。因此不能保证。\n- $i=14$：$13+(14-1)j=13+13j=13(1+j)$。对于所有 $j \\ge 1$，这个数都是 $13$ 的倍数且大于 $13$，因此是合数，所以对于每一个有效的分解，$xy^{14}z \\notin L$。\n\n因此，选择 $i=14$ 可以保证对于任何有效的分解，$xy^iz \\notin L$。",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "正则语言的理论特性具有深远的实际意义。最后的练习将超越单个自动机，探讨我们如何推理两个不同系统之间的关系，例如验证新防火墙是否符合旧有可信标准。你将通过组合标准的自动机运算来设计一个算法，以解决语言包含问题（$L(M_{new}) \\subseteq L(M_{legacy})$）。这个练习展示了闭包性质（如补集和交集）不仅仅是抽象概念，更是解决复杂验证任务的强大构建模块。",
            "id": "1444096",
            "problem": "一家网络安全公司的软件工程团队负责验证一个新的、高度优化的防火墙模块的行为。该防火墙用于识别恶意网络数据包的规则由一个确定性有限自动机（DFA）建模。设 $\\Sigma$ 是数据包头中所有可能字节的字母表。\n\n该公司有一个行为已经得到充分理解的、可信的旧版防火墙。它正确识别为恶意的所有数据包头的集合是一个正则语言 $L(M_{legacy})$，其中 $M_{legacy}$ 是一个DFA。新的、优化的防火墙实现了一套不同的规则，由另一个DFA $M_{new}$ 表示，它接受语言 $L(M_{new})$。\n\n部署的一个关键要求是“无漏报（no false negatives）”。也就是说，任何被新防火墙识别为恶意的数据包头也必须被可信的旧版防火墙识别为恶意的。形式上，这要求新防火墙接受的语言是旧版防火墙接受的语言的子集，即 $L(M_{new}) \\subseteq L(M_{legacy})$。\n\n你的任务是确定正确的算法流程，以判定对于任意给定的两个DFA，$M_{new}$ 和 $M_{legacy}$，这种包含关系是否成立。该流程必须由对有限自动机的标准、可判定的操作组成。\n\n以下哪一项描述了判定 $L(M_{new}) \\subseteq L(M_{legacy})$ 是否成立的正确且完整的算法？\n\nA. 构造一个识别语言 $L(M_{legacy})^c \\cap L(M_{new})$ 的DFA $M_{A}$。然后，检查 $L(M_{A})$ 是否为空。当且仅当 $L(M_{A})$ 为空时，包含关系成立。\n\nB. 构造一个识别语言 $L(M_{legacy}) \\cap L(M_{new})$ 的DFA $M_{B}$。然后，检查 $L(M_{B})$ 是否为空。当且仅当 $L(M_{B})$ 为空时，包含关系成立。\n\nC. 对于无限集 $L(M_{new})$ 中的每个字符串 $w$，模拟两个DFA以检查 $w$ 是否也在 $L(M_{legacy})$ 中。如果对于所有这样的字符串 $w$ 都成立，则包含关系成立。\n\nD. 构造一个识别语言 $L(M_{new})^c \\cap L(M_{legacy})$ 的DFA $M_{D}$。然后，检查 $L(M_{D})$ 是否为空。当且仅当 $L(M_{D})$ 为空时，包含关系成立。\n\nE. 构造一个识别语言 $L(M_{legacy}) \\cup L(M_{new})$ 的DFA $M_{E}$。然后，通过比较它们的状态图来检查这个新自动机是否等价于 $M_{new}$。当且仅当它们等价时，包含关系成立。",
            "solution": "我们必须判定是否 $L(M_{new}) \\subseteq L(M_{legacy})$。根据一个标准的集合论等价关系，对于同一字母表上的任意语言 $A$ 和 $B$，\n$$ A \\subseteq B \\iff A \\cap B^{c} = \\varnothing $$\n将此应用于 $A = L(M_{new})$ 和 $B = L(M_{legacy})$，我们得到\n$$ L(M_{new}) \\subseteq L(M_{legacy}) \\iff L(M_{new}) \\cap (L(M_{legacy}))^c = \\varnothing $$\n\nDFA在补集和交集运算下是封闭的，并且相应的构造是有效的：\n- 补集：给定一个完备的DFA $M_{legacy} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, F_{\\ell})$，其补集DFA是 $M_{\\ell}^{c} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, Q_{\\ell} \\setminus F_{\\ell})$，它识别语言 $\\Sigma^* \\setminus L(M_{legacy})$。如果 $M_{legacy}$ 不是完备的，首先添加一个陷阱状态使其成为全函数。\n- 交集：给定 $M_{new} = (Q_{n}, \\Sigma, \\delta_{n}, q_{0,n}, F_{n})$ 和如上所述的 $M_{\\ell}^{c}$，构造乘积DFA\n$$ M_{A} = (Q_{n} \\times Q_{\\ell}, \\Sigma, \\delta, (q_{0,n}, q_{0,\\ell}), F_{n} \\times (Q_{\\ell} \\setminus F_{\\ell})) $$\n其中对于所有 $a \\in \\Sigma$，$\\delta((q_{n}, q_{\\ell}), a) = (\\delta_{n}(q_{n}, a), \\delta_{\\ell}(q_{\\ell}, a))$。那么 $L(M_{A}) = L(M_{new}) \\cap (L(M_{legacy}))^{c}$。\n\nDFA语言的空性是可判定的：$L(M)$ 为空当且仅当没有接受状态可以从开始状态到达。这可以通过在 $M$ 的有限转移图上进行图的可达性搜索来检查。\n\n因此，算法如下：\n1. 构造 $M_{legacy}$ 的补集 $M_{\\ell}^{c}$。\n2. 构造识别 $L(M_{new}) \\cap (L(M_{legacy}))^{c}$ 的乘积DFA $M_{A}$。\n3. 通过可达性判定 $L(M_{A})$ 是否为空。如果为空，则包含关系成立；否则，一个可达的接受状态（及其对应的词）就是包含关系的一个反例。\n\n这个流程与选项A完全匹配。其他选项不正确的原因如下：\n- B 检查 $L(M_{legacy}) \\cap L(M_{new})$ 的空性，这是测试不相交性，而不是包含关系。\n- C 需要检查一个无限集中的所有字符串，这不能得出一个在所有情况下都能停机的一般性判定过程。\n- D 检查 $L(M_{new})^{c} \\cap L(M_{legacy})$ 的空性，这等价于 $L(M_{legacy}) \\subseteq L(M_{new})$，即反向的包含关系。\n- E 测试是否 $L(M_{legacy}) \\cup L(M_{new}) = L(M_{new})$，这也等价于 $L(M_{legacy}) \\subseteq L(M_{new})$，即反向的包含关系，而且“比较状态图”在没有形式化方法（如乘积构造或最小化）的情况下通常不是一个正确的等价性测试，并且在这里是不必要的。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}