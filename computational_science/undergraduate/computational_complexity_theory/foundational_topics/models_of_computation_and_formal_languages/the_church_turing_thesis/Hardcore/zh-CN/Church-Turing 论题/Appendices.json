{
    "hands_on_practices": [
        {
            "introduction": "为了领会图灵机的强大能力，首先理解更简单模型的局限性是很有帮助的。本练习探讨了为什么作为一种基础计算模型的有限状态自动机（FSA）无法达到丘奇-图灵论题所描述的通用计算能力。通过尝试解决一个看似简单的计数问题，我们将揭示有限状态自动机在内存方面的根本性限制。",
            "id": "1405449",
            "problem": "在丘奇-图灵论题的背景下，我们通常将图灵机（TM）与更简单的计算模型进行比较，以理解计算能力的层级。该论题假定，任何有算法的函数都可以由图灵机计算。\n\n一位初级软件工程师被分配了一项数据验证任务。该任务是为字母表 $\\Sigma = \\{0, 1\\}$ 上的语言 $L$ 构建一个识别器。该语言定义为 $L = \\{0^k 1^k \\mid k \\ge 1\\}$，它由一个或多个'0'后跟等量'1'的所有字符串组成。例如，'01'、'0011'和'000111'属于 $L$，而'011'、'001'和'10'则不属于。\n\n该工程师首先尝试使用有限状态自动机（FSA）（也称为有限自动机）来实现这个识别器。经过几次尝试，他们得出结论：无法为此任务构建任何FSA。下列哪个陈述提供了FSA无法识别语言 $L$ 的最根本原因，从而说明了为什么它是一种比图灵机计算能力更弱的模型？\n\nA. FSA由有限个状态定义。为了识别 $L$，机器必须记住它已处理的'0'的确切数量，而这个数量可以是任意大的。FSA的有限状态只提供了有限的内存，这不足以完成这种无界计数任务。相比之下，TM可以将其无限长的纸带用作无界内存。\n\nB. 语言 $L$ 本质上是非确定性的，因为 $k$ 的值是事先未知的。标准的确定性FSA无法处理这一点，虽然非确定性有限自动机（NFA）更强大，但只有TM才足够强大以解决 $L$ 所需的无界非确定性。\n\nC. FSA的主要限制是其读写头只能在输入上单向移动。TM之所以能成功，是因为其读写头是双向的，允许它在'0'块和'1'块之间来回移动，以确认它们的数量相等。\n\nD. TM可以识别 $L$ 是因为它能解决针对该特定语言的停机问题，而FSA不能。在读取'0'之后无法确定是否应该停机是FSA失败的主要原因。\n\nE. FSA失败是因为它不能写入或修改其输入。TM可以解决这个问题，因为它有写入能力，使其能够在匹配相应的'1'时标记掉每个'0'，从而跟踪计数。",
            "solution": "我们通过证明语言 $L = \\{0^k 1^k \\mid k \\ge 1\\}$ 不是正则语言来形式化地说明有限状态自动机（FSA）的局限性，这意味着没有FSA能够识别它。设 $M=(Q, \\Sigma, \\delta, q_0, F)$ 是在 $\\Sigma=\\{0,1\\}$ 上的任意一个FSA，且其状态数为 $|Q|=n$。考虑字符串 $w=0^n 1^n \\in L$。当 $M$ 读取前 $n$ 个符号 $0^n$ 时，它会经历 $n+1$ 个状态（包括读取任何符号之前的起始状态），因此根据鸽巢原理，存在索引 $0 \\le i  j \\le n$，使得机器在读取了前 $i$ 个和前 $j$ 个 '0' 之后处于同一状态。这意味着机器无法区分它看到了多少个 '0'。因此，如果机器接受合法的字符串 $0^n1^n$，它也必然会错误地接受字符串 $0^{n+(j-i)}1^n$，因为它可以重复遍历 $i$ 和 $j$ 之间的状态循环。但 $0^{n+(j-i)}1^n$ 并不在语言 $L$ 中，这构成了一个矛盾。因此，任何FSA都无法识别语言 $L$。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "丘奇-图灵论题的力量源于一个事实：许多表面上看起来不同的计算模型，最终在计算能力上被证明与图灵机是等价的。本实践通过研究双栈下推自动机（2-PDA）来阐释这一原则。你将发现，为一个标准的下推自动机增加第二个堆栈，如何将其能力提升至与图灵机相当的水平，从而为该论题的稳健性提供了有力证据。",
            "id": "1405422",
            "problem": "丘奇-图灵论题断言，任何可由算法计算的函数都可以由图灵机（TM）计算。这表明所有足够强大的计算模型都是等价的。其中一个这样的模型是双栈下推自动机（2-PDA），它是一种有限自动机，配备了两个独立的栈，每个栈都具有标准的弹出（pop）、压入（push）和读取栈顶（read-top）操作。TM 和 2-PDA 的计算等价性是计算理论中的一个基石性成果，它证明了在标准下推自动机上增加第二个栈会将其计算能力提升至与 TM 等价的水平。\n\n这种等价性是通过证明每种机器都可以模拟另一种机器来建立的。考虑用双栈下推自动机来模拟一个标准的单带图灵机。下列哪个陈述最准确有效地描述了 2-PDA 模拟 TM 的核心机制？\n\nA. 一个栈用于存储 TM 纸带上全部的非空白内容。第二个栈用于存储 TM 读写头的当前位置，该位置通过栈上符号的数量（例如，使用一元编码）来编码。\n\nB. 两个栈以读/写分离的方式工作。一个栈被指定为“读栈”，2-PDA 可以从中读取纸带符号；第二个是“写栈”，2-PDA 将要写入纸带的新符号压入此栈。\n\nC. 两个栈用于表示 TM 的纸带，概念上在读写头的当前位置处被分割。一个栈存储读写头左侧的纸带部分，另一个栈存储从读写头当前位置到右侧的纸带部分。移动 TM 读写头对应于从一个栈弹出一个符号并将其压入另一个栈。\n\nD. 2-PDA 在根本上比图灵机弱。虽然比单栈自动机更强大，但栈固有的后进先出（LIFO）特性妨碍了模拟 TM 读写头在其纸带上向任一方向自由移动到任意位置的能力。\n\nE. 第一个栈用于模拟 TM 的纸带。第二个栈用作控制栈，记录状态转移和写入符号的历史记录，从而允许 2-PDA 回溯并探索不同的计算分支。",
            "solution": "我们比较图灵机（TM）和双栈下推自动机（2-PDA）的能力，并探讨一种用 2-PDA 模拟 TM 的标准策略。\n\n一个单带 TM 的格局可以表示为一个三元组，包括当前状态、纸带内容和读写头位置。设纸带字母表为 $\\Gamma$，空白符号为 $\\sqcup$。设瞬时描述为一个字符串 $uav$，其中 $u \\in \\Gamma^*$ 是读写头左侧的有限内容，$a \\in \\Gamma$ 是读写头下方的当前符号，$v \\in \\Gamma^*$ 是读写头右侧的有限内容，其后是隐含的无限空白符。2-PDA 使用两个栈 $L$ 和 $R$ 来编码读写头周围的纸带：\n$$\nL = u^{\\text{rev}}, \\quad R = av\n$$\n其中 $u^{\\text{rev}}$ 表示 $u$ 的反转。因此，$L$ 的栈顶保存着读写头紧左侧的符号，而 $R$ 的栈顶保存着读写头下方的当前符号。如果某一边的栈为空，2-PDA 会将缺失的栈顶符号视为空白符 $\\sqcup$。\n\n2-PDA 一次模拟一个 TM 的转移。一个 TM 转移具有以下形式：\n$$\n\\delta(q, a) = (q', b, D)\n$$\n意为：在状态 $q$ 下读取符号 $a$，写入符号 $b$，向方向 $D \\in \\{\\text{L}, \\text{R}\\}$ 移动，并进入状态 $q'$。\n\n2-PDA 执行以下操作来模拟每一步这样的转移：\n\n1. 读取读写头符号：通过将空栈顶视为空白符 $\\sqcup$ 来确保 $R$ 不为空；读写头符号是 $\\text{top}(R)$。\n\n2. 写入操作：通过弹出 $\\text{top}(R)$ 并将 $b$ 压入 $R$ 来将读写头符号替换为 $b$。\n\n3. 读写头移动：\n- 如果 $D = \\text{R}$，将读写头向右移动一格，方法是弹出 $R$ 的（新）栈顶（即刚写入的 $b$）并将其压入 $L$，从而使 $R$ 上的下一个符号成为新的读写头符号；如果 $R$ 变为空，则将 $\\sqcup$ 压入 $R$ 以表示右侧的无限空白。\n- 如果 $D = \\text{L}$，将读写头向左移动一格，方法是弹出 $L$ 的栈顶（若为空则视为空白符 $\\sqcup$）并将其压入 $R$，从而使其成为新的读写头符号；如果 $L$ 变为空，则读写头左侧隐含为空白。\n\n这个方案仅使用两个栈的后进先出（LIFO）操作，就精确地捕捉了 TM 的双向读写头移动和读写能力：移动读写头对应于从一个栈弹出并压入另一个栈，而写入则对应于修改代表读写头位置的右栈的栈顶符号。\n\n相比之下：\n- 使用一个栈存储整个纸带，另一个栈作为一元编码的读写头位置计数器（选项 A），在没有随机访问能力的情况下（这是 2-PDA 所缺乏的），不允许在读写头位置进行局部覆写。\n- 将读和写分离到不同的栈（选项 B）没有模拟出 TM 纸带的双向移动和局部覆写结构。\n- 声称 2-PDA 比 TM 弱（选项 D）是错误的；两个栈在计算上与 TM 等价。\n- 使用第二个栈进行回溯控制（选项 E）是不必要的，也未能捕捉到关键的纸带分割机制；对于确定性 TM，该模拟是确定性的，不依赖于搜索历史。\n\n因此，准确的核心机制是在读写头处分割纸带，将左半部分反向存储在一个栈中，将当前单元格及右半部分存储在另一个栈中，并通过栈之间的转移来模拟读写头的移动。这正是选项 C 所描述的。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "丘奇-图灵论题不仅定义了什么是可计算的，也暗示了存在一些任何算法都无法从根本上解决的问题。本练习将介绍其中一个最著名的不可计算函数：忙碌的海狸函数（Busy Beaver function），表示为 $\\Sigma(n)$。通过一个巧妙的反证法，你将理解为什么无法构建任何图灵机来计算此函数，从而具体地见证了计算能力的绝对极限。",
            "id": "1405440",
            "problem": "丘奇-图灵论题断言，任何能通过有效过程计算的函数，都可以由图灵机计算。该论题的一个关键推论是存在定义明确但不可计算的函数。其中最著名的例子之一是忙碌的海狸函数 $\\Sigma(n)$，它被定义为一个停机的 $n$ 状态、2符号（其中一个为空白符）图灵机在停机前，能在初始为空白的纸带上写入的“1”的最大数量。$\\Sigma(n)$ 的不可计算性可以通过反证法来证明。\n\n考虑以下一个图灵机的假设性构造，我们称之为 $M_{paradox}$：\n\n首先，假设存在一个假设的图灵机 $M_{\\Sigma}$，它可以计算忙碌的海狸函数 $\\Sigma(n)$。这个机器 $M_{\\Sigma}$ 以纸带上的整数 $n$ 作为输入，当其计算完成后，它会停机，并将整数值 $\\Sigma(n)$ 写在纸带上。设这个机器 $M_{\\Sigma}$ 的状态数为一个固定常数 $c$。\n\n现在，我们通过将 $M_{\\Sigma}$ 的功能与其他组件相结合来构造机器 $M_{paradox}$。机器 $M_{paradox}$ 被设计为对其结构中硬编码的一个值 $N$ 进行操作。$M_{paradox}$ 的完整操作序列如下：\n1.  一个子机器 $M_{write}$ 将整数 $N$ 写入纸带。该组件需要固定数量的状态 $c_{write}$。\n2.  然后执行机器 $M_{\\Sigma}$（其拥有 $c$ 个状态），使用纸带上的值 $N$ 作为其输入来计算 $\\Sigma(N)$。\n3.  最后一个子机器 $M_{increment}$ 从纸带上读取值 $\\Sigma(N)$，然后在一个干净的纸带区域上总共写入 $\\Sigma(N) + 1$ 个“1”后停机。该组件需要固定数量的状态 $c_{inc}$。\n\n整个机器 $M_{paradox}$ 的总状态数是其组成部分状态数的总和，因此其状态数为 $N_{total} = c_{write} + c + c_{inc}$。为了制造这个悖论，操作步骤中使用的硬编码整数 $N$ 被设置为等于 $M_{paradox}$ 自身总状态数。也就是说，我们设置 $N = N_{total}$。已知非预言机组件的额外状态总和为 $c_{write} + c_{inc} = 38$。\n\n这个构造——一个拥有 $N_{total}$ 个状态且被设计为写入 $\\Sigma(N_{total}) + 1$ 个“1”的机器——与忙碌的海狸函数的定义本身相比，导出了一个根本性的矛盾，从而证明了最初的假设（$M_{\\Sigma}$ 的存在性）必定是错误的。\n\n下列哪个数学陈述正确地表示了从这个假设性构造中导出的矛盾？\n\nA. $\\Sigma(c+38) + 1 = \\Sigma(c) + \\Sigma(38)$\nB. $\\Sigma(c+38) \\le \\Sigma(c) + 38$\nC. $c+38 \\le \\Sigma(c+38)$\nD. $\\Sigma(c+38) + 1 \\le \\Sigma(c+38)$\nE. $\\Sigma(c) + 1 \\le \\Sigma(c)$",
            "solution": "根据忙碌的海狸函数的定义，对于任何一个从空白纸带开始、在停机前写入 $t$ 个“1”的停机 $n$ 状态、2 符号图灵机 $M$，都存在基本界限\n$$\nt \\le \\Sigma(n).\n$$\n假设存在一个有 $c$ 个状态的图灵机 $M_{\\Sigma}$，它在给定纸带上的输入 $n$ 后，会停机并在纸带上写下 $\\Sigma(n)$。通过组合以下部分来构造 $M_{paradox}$：\n- 一个写入器 $M_{write}$，使用 $c_{write}$ 个状态将一个硬编码的整数 $N$ 写入纸带，\n- 一个有 $c$ 个状态的预言机 $M_{\\Sigma}$，用于计算 $\\Sigma(N)$，\n- 一个增量器 $M_{increment}$，使用 $c_{inc}$ 个状态在一个干净的纸带区域上精确写入 $\\Sigma(N)+1$ 个“1”然后停机。\n\n$M_{paradox}$ 的总状态数为\n$$\nN_{total} = c_{write} + c + c_{inc}.\n$$\n我们已知 $c_{write} + c_{inc} = 38$，因此\n$$\nN_{total} = c + 38.\n$$\n设置硬编码输入为 $N = N_{total}$。那么 $M_{paradox}$ 是一个 $N$ 状态、2 符号的图灵机，它从空白纸带开始，停机，并精确写入 $\\Sigma(N) + 1$ 个“1”。将忙碌的海狸函数的定义界限应用于这个特定的 $N$ 状态停机机器，得出\n$$\n\\Sigma(N) + 1 \\le \\Sigma(N),\n$$\n这是一个矛盾。代入 $N = c + 38$ 得到明确的矛盾不等式\n$$\n\\Sigma(c+38) + 1 \\le \\Sigma(c+38).\n$$\n在给定的选项中，这正是陈述 D。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}