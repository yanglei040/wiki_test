{
    "hands_on_practices": [
        {
            "introduction": "This first practice explores the most direct link between optimization and decision problems. We'll see how having a tool that solves an optimization problem (finding the absolute best value) can be used to instantly answer a related decision question (\"is a good enough solution possible?\"). This exercise  highlights the fundamental principle that an optimization problem is often \"harder\" than its decision counterpart, as its solution can directly inform the decision version.",
            "id": "1437415",
            "problem": "In the field of network engineering and computational theory, we often distinguish between optimization problems and decision problems.\n\nConsider the following optimization problem:\n- **Problem Name**: `MAX_BANDWIDTH`\n- **Input**: A network represented as a graph $G$, where nodes are servers and weighted edges represent direct connection capacities.\n- **Output**: A single real number representing the maximum achievable data bandwidth between *any* pair of distinct nodes in the entire network.\n\nNow, consider the related decision problem:\n- **Problem Name**: `CAN_SUPPORT_SERVICE`\n- **Input**: A network graph $G$ and a required bandwidth threshold $B  0$.\n- **Output**: 'YES' if there exists at least one pair of nodes in the network that can support a communication bandwidth of at least $B$. Otherwise, the output is 'NO'.\n\nImagine you have access to a hypothetical \"oracle\"—a black-box computational device that can instantly solve the `MAX_BANDWIDTH` problem for any network graph $G$ you provide as input. Your task is to design an algorithm that uses this oracle to solve the `CAN_SUPPORT_SERVICE` decision problem.\n\nWhich of the following procedures correctly and most efficiently solves the `CAN_SUPPORT_SERVICE(G, B)` problem using the `MAX_BANDWIDTH` oracle?\n\nA.\n1. Provide the network graph $G$ as input to the `MAX_BANDWIDTH` oracle.\n2. Let the oracle's numerical output be $M$.\n3. If $M \\geq B$, the algorithm returns 'YES'.\n4. Otherwise, the algorithm returns 'NO'.\n\nB.\n1. Provide both the network graph $G$ and the threshold $B$ as input to the `MAX_BANDWIDTH` oracle.\n2. If the oracle returns a value greater than 0, the algorithm returns 'YES'.\n3. Otherwise, the algorithm returns 'NO'.\n\nC.\n1. Identify all unique pairs of nodes $(u, v)$ in the network graph $G$.\n2. For each pair, call the `MAX_BANDWIDTH` oracle with the graph $G$ as input.\n3. If any of these calls returns a value $M \\geq B$, the algorithm immediately returns 'YES'.\n4. If all pairs are checked and this condition is never met, the algorithm returns 'NO'.\n\nD.\n1. Provide the network graph $G$ as input to the `MAX_BANDWIDTH` oracle.\n2. Let the oracle's numerical output be $M$.\n3. If $M  B$, the algorithm returns 'YES'.\n4. Otherwise, the algorithm returns 'NO'.\n\nE.\n1. First, check if the number of edges in the graph $G$ is greater than or equal to the threshold $B$.\n2. If it is, call the `MAX_BANDWIDTH` oracle. If the oracle returns a positive number, the algorithm returns 'YES'.\n3. Otherwise, the algorithm returns 'NO'.",
            "solution": "We formalize the optimization oracle and the decision predicate to derive the correct reduction.\n\nLet $\\text{bw}(u,v)$ denote the maximum achievable bandwidth between nodes $u$ and $v$ in graph $G$. The optimization oracle for $\\text{MAX\\_BANDWIDTH}$ returns\n$$\nM^{\\ast}=\\max_{u\\neq v}\\text{bw}(u,v).\n$$\nThe decision problem $\\text{CAN\\_SUPPORT\\_SERVICE}(G,B)$ asks whether\n$$\n\\exists\\,(u,v)\\text{ with }u\\neq v\\text{ such that }\\text{bw}(u,v)\\geq B.\n$$\nBy the fundamental property of the maximum over a finite set, the following equivalence holds:\n$$\n\\left(\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\right)\\quad\\Longleftrightarrow\\quad \\max_{u\\neq v}\\text{bw}(u,v)\\geq B,\n$$\nthat is,\n$$\n\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\quad\\Longleftrightarrow\\quad M^{\\ast}\\geq B.\n$$\nTherefore, an algorithm that calls the $\\text{MAX\\_BANDWIDTH}$ oracle once to obtain $M^{\\ast}$ and returns 'YES' iff $M^{\\ast}\\geq B$ is correct.\n\nAmong the given procedures:\n- A implements exactly this single-call comparison $M\\geq B$, so it is correct and uses the oracle once, which is most efficient.\n- B is invalid because the oracle takes only $G$ as input, and it checks $M0$ instead of $M\\geq B$, which fails when $0MB$.\n- C redundantly calls the same oracle on the same $G$ for each pair, yielding the same $M$ each time; while it can return the correct answer, it is strictly less efficient than A.\n- D inverts the comparison (it returns 'YES' when $MB$), so it is incorrect.\n- E uses an unrelated edge-count heuristic and again checks $M0$, so it is incorrect.\n\nThus, the correct and most efficient procedure is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Building on the previous concept, this practice reverses the roles: we will use a decision oracle to solve an optimization problem. This scenario  demonstrates a powerful and widely applicable technique, binary search, which allows us to zero in on an optimal value by repeatedly asking \"yes/no\" questions. Your task is to determine the efficiency of this approach, showing how an optimization problem can be solved with a logarithmic number of calls to its corresponding decision version.",
            "id": "1437394",
            "problem": "A telecommunications company is designing an algorithm to find the optimal placement and power for a new broadcast tower. The tower must provide coverage to a set of $n$ designated service locations, represented by points in a 2D plane, $P = \\{p_1, p_2, \\dots, p_n\\}$, where each point is given by its coordinates $p_i = (x_i, y_i)$.\n\nTo minimize operational costs, the company wants to find the minimum possible broadcast radius, $R_{min}$, of a single circular coverage area that encompasses all $n$ locations. The center of this circle can be any point in the plane.\n\nThe engineering team has provided you with a powerful but costly-to-run simulation tool, which can be modeled as a \"black box\" oracle function, `CAN_COVER(P, r)`. This function takes the set of points $P$ and a radius $r$ as input. It returns `true` if there exists some circle of radius $r$ that encloses all points in $P$, and `false` otherwise. Each call to this oracle is considered one computational step.\n\nA preliminary analysis of the location data has determined a bounding value $C_{max}$ such that for all points $(x_i, y_i)$ in the set $P$, it is known that $|x_i| \\le C_{max}$ and $|y_i| \\le C_{max}$.\n\nYour task is to devise a strategy that uses the `CAN_COVER` oracle to find the minimum radius $R_{min}$. Specifically, determine the minimum number of calls to `CAN_COVER` that are required to guarantee finding an estimated radius, $R_{est}$, such that the absolute error is at most $\\epsilon$, i.e., $|R_{est} - R_{min}| \\le \\epsilon$, for a given precision $\\epsilon  0$.\n\nExpress your answer as a closed-form analytic expression in terms of $C_{max}$ and $\\epsilon$.",
            "solution": "Let $R_{min}$ be the minimum radius of a circle that covers all points in $P$. The oracle predicate $f(r) := \\texttt{CAN\\_COVER}(P, r)$ is monotone: $f(r) = \\text{false}$ for $r  R_{min}$ and $f(r) = \\text{true}$ for $r \\ge R_{min}$.\n\nA priori geometric bound: since every $p_{i}$ lies in the square $\\{(x,y): |x| \\le C_{max}, |y| \\le C_{max}\\}$, the circle centered at the origin with radius $C_{max}\\sqrt{2}$ covers the entire square, hence\n$$\n0 \\le R_{min} \\le C_{max}\\sqrt{2}.\n$$\nTherefore, we can initialize a search interval $[L_{0}, U_{0}] = [0, C_{max}\\sqrt{2}]$ that is guaranteed to contain $R_{min}$ without any oracle calls.\n\nUse binary search on $r \\in [L, U]$: at each step query the midpoint $m = \\frac{L+U}{2}$. If $f(m) = \\text{true}$, then $R_{min} \\le m$, so set $U \\leftarrow m$; otherwise $R_{min}  m$, so set $L \\leftarrow m$. By induction, after $t$ oracle calls the maintained interval $[L_{t}, U_{t}]$ contains $R_{min}$ and has length\n$$\nU_{t} - L_{t} \\le \\frac{U_{0} - L_{0}}{2^{t}} = \\frac{C_{max}\\sqrt{2}}{2^{t}}.\n$$\nIf we output the estimate as the midpoint $R_{est} = \\frac{L_{t} + U_{t}}{2}$, then the worst-case absolute error is at most half the bracket length:\n$$\n|R_{est} - R_{min}| \\le \\frac{U_{t} - L_{t}}{2} \\le \\frac{C_{max}\\sqrt{2}}{2^{t+1}}.\n$$\nTo guarantee $|R_{est} - R_{min}| \\le \\epsilon$, it suffices that\n$$\n\\frac{C_{max}\\sqrt{2}}{2^{t+1}} \\le \\epsilon\n\\quad \\Longleftrightarrow \\quad\nt \\ge \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right).\n$$\nSince the number of calls must be an integer, the minimum number of oracle calls required in the worst case is\n$$\n\\left\\lceil \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right) \\right\\rceil.\n$$\nThis bound is optimal: after $t$ binary oracle calls, any algorithm can confine $R_{min}$ to an interval of length at least $\\frac{C_{max}\\sqrt{2}}{2^{t}}$, so the best guaranteed absolute error (by choosing the midpoint) is at least $\\frac{C_{max}\\sqrt{2}}{2^{t+1}}$, yielding the same necessary condition.",
            "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right) \\right\\rceil}$$"
        },
        {
            "introduction": "Our final practice takes the concept of reduction a step further, moving from simply finding an optimal value to constructing an entire solution. Using a decision oracle that only confirms the existence of a flaw in a system, you will devise a method to reconstruct the specific sequence of events—the counterexample—that reveals the flaw. This powerful technique, demonstrated in , is central to fields like automated verification and illustrates the concept of a search-to-decision reduction.",
            "id": "1437398",
            "problem": "In the field of formal verification, model checking is a technique used to automatically verify if a model of a system meets a given specification. A common type of specification is a safety property, which asserts that \"something bad never happens.\"\n\nConsider a system modeled as a finite transition system, which can be formally described by a tuple $M = (S, s_{init}, T, B)$, where:\n- $S$ is a finite set of states.\n- $s_{init} \\in S$ is the initial state.\n- $T \\subseteq S \\times S$ is the transition relation. A pair $(s, s') \\in T$ means the system can transition from state $s$ to state $s'$.\n- $B \\subseteq S$ is a set of \"bad\" or unsafe states.\n\nA trace (or execution path) of the system is a sequence of states $\\pi = (\\pi_0, \\pi_1, \\dots, \\pi_m)$ where $\\pi_0 = s_{init}$ and for all $0 \\le i  m$, $(\\pi_i, \\pi_{i+1}) \\in T$. The length of this trace is $m$.\n\nA trace is called a \"violating trace\" if it contains at least one state from the set $B$. A model checker's task is often to find such a trace, which serves as a counterexample to the safety property.\n\nYou are given access to a black-box decision oracle, `CheckViolation(M, k)`. This oracle takes a system model $M = (S, s_{init}, T, B)$ and a non-negative integer $k$ as input. It returns `true` if there exists a violating trace of length at most $k$ starting from $s_{init}$ in the model $M$, and `false` otherwise. You can call this oracle as many times as you need, with any valid model and any integer $k$.\n\nYour task is to devise a procedure that uses this oracle to find a concrete counterexample.\n\nConsider the following specific transition system, $M_{spec}$:\n- Set of States $S = \\{s_0, s_1, s_2, s_3, s_4, s_5, s_6\\}$\n- Initial State $s_{init} = s_0$\n- Set of Bad States $B = \\{s_6\\}$\n- Transition Relation $T = \\{(s_0, s_1), (s_0, s_2), (s_1, s_3), (s_2, s_4), (s_3, s_5), (s_4, s_0), (s_5, s_6)\\}$\n\nDescribe a general algorithm that uses the `CheckViolation` oracle to find a shortest violating trace for any given finite transition system (assuming one exists). Then, apply your algorithm to the system $M_{spec}$ to find the shortest violating trace. Your final answer should be the sequence of state labels that constitute this trace.",
            "solution": "We first formalize what it means to search for a shortest counterexample using only the decision oracle. Let $M=(S,s_{init},T,B)$ be a finite transition system and define the predicate $V(k)$ as the oracle result $V(k)=\\text{CheckViolation}(M,k)$, which returns true if and only if there exists a violating trace of length at most $k$ from $s_{init}$. The predicate $V(k)$ is monotone in $k$, specifically if $V(k)$ is true then $V(k')$ is true for all $k'\\geq k$. Moreover, if any violating trace exists, then there exists a shortest violating trace whose length is at most $\\lvert S\\rvert-1$, because given any violating trace, if a state repeats before reaching $B$ then the intervening cycle can be removed without losing violation; any simple path in a graph with $\\lvert S\\rvert$ nodes has length at most $\\lvert S\\rvert-1$.\n\nGeneral algorithm to find a shortest violating trace:\n1. Length discovery (binary search). Define $U=\\lvert S\\rvert-1$ and first query $V(U)$. If $V(U)$ is false, then no violating trace exists. Otherwise, perform binary search on the interval $[0,U]$ to find the minimal $k^{\\ast}$ such that $V(k^{\\ast})$ is true. Correctness follows from the monotonicity of $V(k)$ and the upper bound on the shortest violating length.\n2. Path reconstruction by prefix extension using restricted initial states. Having determined $k^{\\ast}$, reconstruct a concrete path of length exactly $k^{\\ast}$ as follows. Maintain a current state $s$ and a remaining budget $r$, initialized as $s:=s_{init}$ and $r:=k^{\\ast}$. While $r0$ and $s\\notin B$, do:\n   - Enumerate $\\text{Post}(s)=\\{s'\\in S:(s,s')\\in T\\}$.\n   - For each $s'\\in\\text{Post}(s)$, form a modified model $M'=(S,s',T,B)$ that is identical to $M$ except with the initial state set to $s'$. Query $\\text{CheckViolation}(M',r-1)$.\n   - If for some $s'$ the oracle returns true, then there exists a violating trace of length at most $r-1$ from $s'$, hence there exists a shortest violating trace of length exactly $r$ from $s$ whose next state is $s'$. Append $s'$ to the path prefix, update $s:=s'$ and $r:=r-1$, and continue.\n   This procedure must succeed at each step because by definition of $k^{\\ast}$ there exists a length-$r$ violating suffix from $s$, so its immediate successor $s'$ at the next position will pass the oracle test with budget $r-1$. The loop terminates with $r=0$ and the current state in $B$, yielding a shortest violating trace.\n\nApplication to $M_{spec}$:\nWe have $S=\\{s_{0},s_{1},s_{2},s_{3},s_{4},s_{5},s_{6}\\}$, $s_{init}=s_{0}$, $B=\\{s_{6}\\}$, and $T=\\{(s_{0},s_{1}),(s_{0},s_{2}),(s_{1},s_{3}),(s_{2},s_{4}),(s_{3},s_{5}),(s_{4},s_{0}),(s_{5},s_{6})\\}$. The bound is $U=\\lvert S\\rvert-1=6$. Evaluate the oracle to find $k^{\\ast}$:\n- $\\text{CheckViolation}(M_{spec},3)$ is false, because any path from $s_{0}$ to $s_{6}$ must go through $s_{5}$, then $s_{3}$, then $s_{1}$, which requires at least $4$ transitions.\n- $\\text{CheckViolation}(M_{spec},5)$ is true, since there exists a path of length $4\\leq 5$ to $s_{6}$ (exhibited below).\n- By bisection, test $\\text{CheckViolation}(M_{spec},4)$, which is true; hence the minimal violating length is $k^{\\ast}=4$.\n\nReconstruct the path for $k^{\\ast}=4$:\n- Initialize $s:=s_{0}$ and $r:=4$. Compute $\\text{Post}(s_{0})=\\{s_{1},s_{2}\\}$.\n  - For $s_{1}$, form $M'=(S,s_{1},T,B)$ and query $\\text{CheckViolation}(M',3)$. This is true because $s_{1}\\to s_{3}\\to s_{5}\\to s_{6}$ reaches $B$ in $3$ steps. Choose $s_{1}$, set $s:=s_{1}$ and $r:=3$.\n- Now $s=s_{1}$, $r=3$, and $\\text{Post}(s_{1})=\\{s_{3}\\}$. For $s_{3}$, $\\text{CheckViolation}((S,s_{3},T,B),2)$ is true via $s_{3}\\to s_{5}\\to s_{6}$. Choose $s_{3}$, update $s:=s_{3}$, $r:=2$.\n- Now $s=s_{3}$, $r=2$, and $\\text{Post}(s_{3})=\\{s_{5}\\}$. For $s_{5}$, $\\text{CheckViolation}((S,s_{5},T,B),1)$ is true via $s_{5}\\to s_{6}$. Choose $s_{5}$, update $s:=s_{5}$, $r:=1$.\n- Now $s=s_{5}$, $r=1$, and $\\text{Post}(s_{5})=\\{s_{6}\\}$. For $s_{6}$, $\\text{CheckViolation}((S,s_{6},T,B),0)$ is true since $s_{6}\\in B$. Choose $s_{6}$, update $s:=s_{6}$, $r:=0$ and terminate.\nThe reconstructed shortest violating trace is $(s_{0},s_{1},s_{3},s_{5},s_{6})$.",
            "answer": "$$\\boxed{(s_0, s_1, s_3, s_5, s_6)}$$"
        }
    ]
}