{
    "hands_on_practices": [
        {
            "introduction": "Understanding the properties of a complexity class is as crucial as understanding its definition. Closure properties tell us how we can combine or manipulate problems within a class and be guaranteed that the result remains in the same class. This first exercise explores the closure of PSPACE under concatenation, a foundational operation on languages. You will devise a high-level algorithm that demonstrates the key principle of space reuse, a cornerstone of polynomial-space computation.",
            "id": "1454902",
            "problem": "In computational complexity theory, a complexity class is a set of problems that can be solved by a computational model under certain resource constraints. The class PSPACE (Polynomial Space) consists of all decision problems that can be solved by a deterministic Turing machine using a polynomial amount of space in relation to the size of the input.\n\nLet $L_1$ and $L_2$ be two languages decided by deterministic Turing machines $M_1$ and $M_2$ in space bounded by polynomials $p_1(n)$ and $p_2(n)$ respectively, where $n$ is the length of the input string. Thus, by definition, $L_1 \\in \\text{PSPACE}$ and $L_2 \\in \\text{PSPACE}$.\n\nThe concatenation of these two languages, denoted $L = L_1 \\circ L_2$, is defined as the set of all strings $w$ that can be formed by concatenating a string $x$ from $L_1$ with a string $y$ from $L_2$. That is, $L = \\{xy \\mid x \\in L_1 \\text{ and } y \\in L_2\\}$.\n\nWe wish to show that the class PSPACE is closed under the concatenation operation, meaning that if $L_1, L_2 \\in \\text{PSPACE}$, then $L_1 \\circ L_2 \\in \\text{PSPACE}$. This requires constructing a Turing machine $M$ that decides $L_1 \\circ L_2$ using only a polynomial amount of space.\n\nGiven an input string $w$ of length $n$, which of the following choices describes a correct high-level algorithm for a deterministic Turing machine $M$ to decide if $w \\in L$ while using only polynomial space?\n\nA. The machine $M$ first enumerates and stores on its tape all strings in $L_1$ of length up to $n$. It then enumerates and stores all strings in $L_2$ of length up to $n$. Finally, for every stored string $x$ from $L_1$ and every stored string $y$ from $L_2$, it checks if their concatenation $xy$ equals the input $w$. If a match is found, it accepts; otherwise, it rejects.\n\nB. The machine $M$ systematically tries every possible way to split the input string $w$ into two non-empty parts, $w = xy$. For each such split, $M$ first simulates the machine $M_1$ on the prefix $x$. If $M_1$ accepts, $M$ erases its work tape and then simulates machine $M_2$ on the suffix $y$. If $M_2$ also accepts, machine $M$ halts and accepts. If all possible splits are checked and none result in both simulations accepting, $M$ halts and rejects.\n\nC. The machine $M$ splits the input string $w$ exactly in half, into a prefix $x$ and a suffix $y$. It then uses a two-tape Turing machine to simulate $M_1$ on $x$ on the first tape and $M_2$ on $y$ on the second tape. If both simulations accept, $M$ accepts. Otherwise, $M$ rejects.\n\nD. Since the languages $L_1$ and $L_2$ could be infinite, it is impossible to check all possible pairs $(x, y)$ to see if their concatenation forms $w$. Therefore, the problem of deciding membership in $L_1 \\circ L_2$ is undecidable, and no such Turing machine $M$ can exist.",
            "solution": "We are given $L_{1},L_{2} \\in \\text{PSPACE}$ with deterministic deciders $M_{1}$ and $M_{2}$ using at most $p_{1}(n)$ and $p_{2}(n)$ space, respectively, on inputs of length $n$. For $w \\in \\Sigma^{*}$ of length $n$, $w \\in L_{1} \\circ L_{2}$ iff there exists an index $i$ with $0 \\leq i \\leq n$ such that the prefix $x = w[1..i] \\in L_{1}$ and the suffix $y = w[i+1..n] \\in L_{2}$. A deterministic machine $M$ can decide this by iterating over all splits $i$ and simulating $M_{1}$ on $x$ and $M_{2}$ on $y$.\n\nSpace analysis: define $p(n) = \\max\\{p_{1}(n),p_{2}(n)\\}$. For a fixed split $i$, $|x| = i \\leq n$ and $|y| = n - i \\leq n$, so the simulations use at most $p_{1}(i) \\leq p_{1}(n) \\leq p(n)$ space and $p_{2}(n-i) \\leq p_{2}(n) \\leq p(n)$ space. Since $M$ first simulates $M_{1}$ on $x$ and, only if it accepts, erases its work tape and simulates $M_{2}$ on $y$, the peak space used is at most $p(n)$ plus overhead to manage the split and the simulation. To feed $x$ and $y$ to the simulators, $M$ can either:\n- keep the input on a read-only tape and maintain a counter for the split index $i$, interpreting attempts by the simulated machine to read past the designated end as blanks; the counter uses $O(\\log n)$ space; or\n- copy the relevant substring onto a work tape before each simulation, which uses $O(n)$ space.\n\nIn both cases, the total space per split is bounded by\n$$\nq(n) = p(n) + O(n),\n$$\nwhich is polynomial in $n$. The loop over all $i \\in \\{0,1,\\dots,n\\}$ is sequential, so space does not accumulate across iterations; only time may blow up, which does not affect PSPACE membership. Therefore, this procedure decides $L_{1} \\circ L_{2}$ in polynomial space, establishing closure of PSPACE under concatenation.\n\nEvaluation of options:\n- A stores all strings up to length $n$ from $L_{1}$ and $L_{2}$, which requires exponential space in $n$, so it is not polynomial-space.\n- B describes the standard polynomial-space procedure: try each split, simulate $M_{1}$ on the prefix, and if it accepts, simulate $M_{2}$ on the suffix after erasing the work tape. This uses at most $q(n)$ space as argued. To cover all cases exactly matching the definition $L_{1} \\circ L_{2} = \\{xy : x \\in L_{1}, y \\in L_{2}\\}$, one should include the splits $i=0$ and $i=n$ as well; this is a trivial adjustment that does not change the space bound.\n- C only checks the split at $i = \\lfloor n/2 \\rfloor$, which is insufficient, since valid decompositions may occur at any $i$.\n- D is false: the membership problem for $L_{1} \\circ L_{2}$ is decidable in polynomial space by the algorithm above.\n\nHence the correct high-level algorithm is B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Many problems in computer science, particularly in AI and verification, can be modeled as reachability in a large state space. While the number of states can be exponential, this doesn't necessarily mean we need exponential space to solve the problem. This practice problem introduces a powerful recursive technique, analogous to the proof of Savitch's Theorem, for solving a reachability problem in polynomial space. By recursively searching for a \"mid-point\" configuration, you'll see how to verify a path's existence without ever storing the entire path, a non-intuitive but essential concept in PSPACE.",
            "id": "1454887",
            "problem": "Consider a computational system known as the \"$n$-bit Configuration Lock\". A \"configuration\" in this system is an $n$-bit binary string, which can be interpreted as an integer from $0$ to $2^n - 1$. The system evolves in discrete time steps. From any given configuration $C$, it can transition to a new configuration $C'$ in a single step through one of two possible non-deterministic operations. These operations are defined based on the integer value $v$ of the configuration string $C$:\n\n1.  Operation A: The new configuration's integer value is $v' = (3v + 1) \\pmod{2^n}$.\n2.  Operation B: The new configuration's integer value is $v' = (5v + 1) \\pmod{2^n}$.\n\nWe are interested in the reachability problem: can a starting configuration $C_{start}$ reach a target configuration $C_{target}$ in exactly $k$ steps?\n\nA recursive algorithm named `CanReach(C_1, C_2, t)` is proposed to solve this problem. It determines if configuration $C_2$ is reachable from $C_1$ in exactly $t$ steps. The logic of the algorithm is as follows:\n\n-   **Base Case:** If $t=1$, the function checks if $C_2$ can be reached from $C_1$ in a single step using either Operation A or Operation B. It returns `True` if a valid transition exists, and `False` otherwise.\n-   **Recursive Step:** If $t > 1$, the function iterates through all $2^n$ possible configurations for an intermediate state, `C_mid`. For each `C_mid`, it checks if `C_mid` is reachable from `C_1` in $\\lfloor t/2 \\rfloor$ steps AND `C_2` is reachable from `C_mid` in $\\lceil t/2 \\rceil$ steps by making two separate recursive calls. If both calls return `True` for any `C_mid`, the function immediately returns `True`. If the loop finishes without finding such a `C_mid`, the function returns `False`.\n\nYour task is to analyze the space complexity of this algorithm. An initial call is made to `CanReach(C_{start}, C_{target}, 2^n)`. Assume that storing one $n$-bit configuration requires space proportional to $n$, and storing the integer step count $t$ (which can be as large as $2^n$) also requires space proportional to $n$. The total space required by the recursion stack can be written in big-O notation as $O(f(n))$ for some function $f(n)$. Determine this function $f(n)$.",
            "solution": "We analyze the recursion stack space of the function call tree. Each activation record (stack frame) must store its parameters and loop state:\n- Each configuration parameter, $C_{1}$ and $C_{2}$, requires space proportional to $n$, so $c_{1} n$ and $c_{2} n$ for fixed positive constants $c_{1},c_{2}$.\n- The step count $t$ can be as large as $2^{n}$, which requires space proportional to $n$, say $c_{3} n$.\n- The loop iterates over all $2^{n}$ possible $C_{\\text{mid}}$, but at any time it only stores the current $C_{\\text{mid}}$, which requires space proportional to $n$, say $c_{4} n$.\n- Any additional control or constant-sized state is $O(1)$ and is subsumed in a constant $c_{5}$.\n\nThus the space per frame satisfies\n$$\ns(n) \\leq (c_{1}+c_{2}+c_{3}+c_{4})\\,n + c_{5} = a\\,n + c_{5}, \n$$\nfor some constant $a>0$, hence $s(n)=\\Theta(n)$.\n\nNext, we determine the maximum recursion depth. Let $D(t)$ denote the maximum depth for input step count $t$. The base case uses one frame, so $D(1)=1$. For $t>1$, the function makes two recursive calls with step counts $\\lfloor t/2 \\rfloor$ and $\\lceil t/2 \\rceil$ but evaluates them sequentially (the second only after the first returns). Therefore, the maximum stack depth at any time is\n$$\nD(t) = 1 + \\max\\!\\big(D(\\lfloor t/2 \\rfloor),\\, D(\\lceil t/2 \\rceil)\\big) \\leq 1 + D(\\lceil t/2 \\rceil).\n$$\nBy repeated halving, after $m$ such steps the argument size is at most $\\lceil t/2^{m} \\rceil$. The recursion stops when this becomes $1$, which occurs for the smallest $m$ with $t \\leq 2^{m}$, i.e., $m=\\lceil \\log_{2} t \\rceil$. Hence\n$$\nD(t) \\leq \\lceil \\log_{2} t \\rceil + 1.\n$$\n\nThe initial call has $t=2^{n}$, so\n$$\nD(2^{n}) \\leq \\lceil \\log_{2}(2^{n}) \\rceil + 1 = n + 1 = \\Theta(n).\n$$\n\nThe total recursion stack space is the product of the maximum depth and the per-frame space:\n$$\nS(n) \\leq D(2^{n}) \\cdot s(n) \\leq (n+1)\\,(a n + c_{5}) = a n^{2} + (a + c_{5}) n + c_{5}.\n$$\nTherefore $S(n) = O(n^{2})$. Since $S(n)$ is expressed as $O(f(n))$, we conclude\n$$\nf(n) = n^{2}.\n$$",
            "answer": "$$\\boxed{n^{2}}$$"
        },
        {
            "introduction": "The recursive, space-saving strategy is not limited to graph reachability; it is a versatile tool for exploring any large, structured search space. In this final practice, you'll apply this principle to a problem from logic: counting the number of satisfying assignments for a Boolean formula, but with a twist. By tracing a recursive algorithm that computes this count modulo 3, you'll get hands-on experience with how PSPACE techniques can be used to analyze properties of problems that are otherwise computationally hard, like #SAT.",
            "id": "1454907",
            "problem": "A central problem in computational complexity is counting the number of solutions to a given problem, often denoted by the prefix # (e.g., #SAT). While finding a single satisfying assignment for a 2-Conjunctive Normal Form (2-CNF) formula is solvable in polynomial time, counting all such assignments (#2-SAT) is #P-complete and thus considered intractable.\n\nThis problem explores a related question: determining the number of satisfying assignments modulo a small integer, specifically 3. A Boolean formula is given over a set of $n$ variables $\\{x_1, x_2, \\dots, x_n\\}$. A literal is a variable $x_i$ or its negation $\\neg x_i$. A 2-CNF formula is a conjunction (AND, denoted by $\\land$) of clauses, where each clause is a disjunction (OR, denoted by $\\lor$) of at most two literals. A satisfying assignment is a mapping of variables to {True, False} that makes the entire formula True.\n\nConsider the following recursive algorithm, `CountMod3(ψ, k, n)`, which computes the number of satisfying assignments for a formula $\\psi$ modulo 3. The variables in $\\psi$ are assumed to be a subset of $\\{x_k, x_{k+1}, \\dots, x_n\\}$.\n\n**Algorithm `CountMod3(ψ, k, n)`:**\n\n1.  **Base Case (Unsatisfiable):** If the formula $\\psi$ is determined to be unsatisfiable, return 0. A formula is unsatisfiable if it contains an empty clause `()`, which can result from a substitution simplifying a unit clause like `(x_i)` to `(False)`.\n2.  **Base Case (Tautology):** If the formula $\\psi$ contains no clauses, it is satisfied by any assignment to the remaining variables $\\{x_k, \\dots, x_n\\}$. The number of such assignments is $2^{n-k+1}$. The function should return $2^{n-k+1} \\pmod 3$.\n3.  **Recursive Step:** If neither base case is met, select variable $x_k$:\n    a.  Construct formula $\\psi_0$ from $\\psi$ by substituting $x_k = \\text{False}$. This involves replacing all instances of the literal $x_k$ with False and $\\neg x_k$ with True. The resulting formula is then simplified:\n        - Any clause containing True (e.g., `(True ∨ l)`) is removed.\n        - In any clause, any instance of False is removed (e.g., `(False ∨ l)` becomes `(l)`).\n    b.  Recursively compute $c_0 = \\text{CountMod3}(\\psi_0, k+1, n)$.\n    c.  Construct formula $\\psi_1$ from $\\psi$ by substituting $x_k = \\text{True}$ and simplifying in a similar manner.\n    d.  Recursively compute $c_1 = \\text{CountMod3}(\\psi_1, k+1, n)$.\n    e.  Return $(c_0 + c_1) \\pmod 3$.\n\nYou are given the following 2-CNF formula $\\phi$ over $n=4$ variables $\\{x_1, x_2, x_3, x_4\\}$:\n$$ \\phi = (\\neg x_1 \\lor x_2) \\land (\\neg x_2 \\lor x_3) \\land (\\neg x_3 \\lor x_4) \\land (\\neg x_4 \\lor \\neg x_1) \\land (x_1 \\lor x_3) $$\n\nDetermine the value returned by the initial call `CountMod3(φ, 1, 4)`.",
            "solution": "We apply CountMod3 to $\\phi=(\\neg x_{1}\\lor x_{2})\\land(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4}\\lor \\neg x_{1})\\land(x_{1}\\lor x_{3})$ with $(k,n)=(1,4)$. The formula is neither unsatisfiable nor empty, so we branch on $x_{1}$.\n\nCase $x_{1}=\\text{False}$: Substitute $x_{1}=\\text{False}$ so $\\neg x_{1}=\\text{True}$. Clauses simplify as follows:\n- $(\\neg x_{1}\\lor x_{2})\\to(\\text{True}\\lor x_{2})$ which is $\\text{True}$ and is removed.\n- $(\\neg x_{2}\\lor x_{3})$ unchanged.\n- $(\\neg x_{3}\\lor x_{4})$ unchanged.\n- $(\\neg x_{4}\\lor \\neg x_{1})\\to(\\neg x_{4}\\lor \\text{True})$ which is $\\text{True}$ and is removed.\n- $(x_{1}\\lor x_{3})\\to(\\text{False}\\lor x_{3})$ which is the unit clause $(x_{3})$.\nThus $\\psi_{0}=(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(x_{3})$, and we call CountMod3$(\\psi_{0},2,4)$ and branch on $x_{2}$.\n\nSubcase $x_{2}=\\text{False}$: In $\\psi_{0}$, $(\\neg x_{2}\\lor x_{3})\\to(\\text{True}\\lor x_{3})$ which is $\\text{True}$ and removed; the rest remains, giving $\\psi_{00}=(\\neg x_{3}\\lor x_{4})\\land(x_{3})$. Branch on $x_{3}$:\n- $x_{3}=\\text{False}$ makes the unit $(x_{3})$ become $\\text{False}$, i.e., an empty clause, so this branch is unsatisfiable and returns $0$.\n- $x_{3}=\\text{True}$ gives $(\\neg x_{3}\\lor x_{4})\\to(\\text{False}\\lor x_{4})=(x_{4})$ and removes $(x_{3})$, so we get $\\psi_{000}=(x_{4})$. Branch on $x_{4}$:\n  - $x_{4}=\\text{False}$ yields an empty clause, return $0$.\n  - $x_{4}=\\text{True}$ removes the clause and leaves no clauses; the tautology base returns $2^{n-(k+1)+1}=2^{4-5+1}=2^{0}=1$ modulo $3$, i.e., $1$.\nThus the $x_{2}=\\text{False}$ subcase contributes $0+1=1$.\n\nSubcase $x_{2}=\\text{True}$: $(\\neg x_{2}\\lor x_{3})\\to(\\text{False}\\lor x_{3})=(x_{3})$, so $\\psi_{01}=(x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(x_{3})$. Branch on $x_{3}$:\n- $x_{3}=\\text{False}$ gives an empty clause from $(x_{3})$, return $0$.\n- $x_{3}=\\text{True}$ yields $(\\neg x_{3}\\lor x_{4})\\to(x_{4})$ and removes the unit clauses, giving $(x_{4})$. Branch on $x_{4}$:\n  - $x_{4}=\\text{False}$ is unsatisfiable, return $0$.\n  - $x_{4}=\\text{True}$ yields no clauses, tautology returns $2^{0}=1$ modulo $3$, i.e., $1$.\nThus the $x_{2}=\\text{True}$ subcase contributes $0+1=1$.\n\nTherefore $c_{0}=\\text{CountMod3}(\\psi_{0},2,4)=1+1=2$ (and $2\\bmod 3=2$).\n\nCase $x_{1}=\\text{True}$: Substitute $x_{1}=\\text{True}$ so $\\neg x_{1}=\\text{False}$. Clauses simplify:\n- $(\\neg x_{1}\\lor x_{2})\\to(\\text{False}\\lor x_{2})=(x_{2})$.\n- $(\\neg x_{2}\\lor x_{3})$ unchanged.\n- $(\\neg x_{3}\\lor x_{4})$ unchanged.\n- $(\\neg x_{4}\\lor \\neg x_{1})\\to(\\neg x_{4}\\lor \\text{False})=(\\neg x_{4})$.\n- $(x_{1}\\lor x_{3})\\to(\\text{True}\\lor x_{3})$ which is $\\text{True}$ and removed.\nThus $\\psi_{1}=(x_{2})\\land(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4})$, and we call CountMod3$(\\psi_{1},2,4)$ and branch on $x_{2}$.\n\nSubcase $x_{2}=\\text{False}$: The unit $(x_{2})$ becomes $\\text{False}$, giving an empty clause; return $0$.\n\nSubcase $x_{2}=\\text{True}$: Remove $(x_{2})$, and $(\\neg x_{2}\\lor x_{3})\\to(\\text{False}\\lor x_{3})=(x_{3})$. We obtain $\\psi_{11}=(x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4})$. Branch on $x_{3}$:\n- $x_{3}=\\text{False}$ gives an empty clause from $(x_{3})$, return $0$.\n- $x_{3}=\\text{True}$ yields $(\\neg x_{3}\\lor x_{4})\\to(x_{4})$ and keeps $(\\neg x_{4})$, so we have $(x_{4})\\land(\\neg x_{4})$. Branch on $x_{4}$:\n  - $x_{4}=\\text{False}$ makes $(x_{4})$ false, empty clause, return $0$.\n  - $x_{4}=\\text{True}$ makes $(\\neg x_{4})$ false, empty clause, return $0$.\nThus this subcase contributes $0$.\n\nTherefore $c_{1}=\\text{CountMod3}(\\psi_{1},2,4)=0+0=0$.\n\nFinally, CountMod3$(\\phi,1,4)$ returns $(c_{0}+c_{1})\\bmod 3=(2+0)\\bmod 3=2$.",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}