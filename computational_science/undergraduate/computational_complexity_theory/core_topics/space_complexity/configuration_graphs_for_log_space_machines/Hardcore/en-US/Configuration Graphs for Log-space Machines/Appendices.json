{
    "hands_on_practices": [
        {
            "introduction": "Before analyzing the intricate paths within a configuration graph, we must first grasp its scale. This practice challenges you to quantify the total number of possible configurations for a log-space machine by meticulously counting the possibilities for each component of a configuration. By comparing two models that differ only in their work tape size, you will gain a concrete understanding of how space complexity exponentially impacts the size of the state space we need to analyze .",
            "id": "1418082",
            "problem": "A computational theorist is analyzing two models of a specialized Turing Machine designed for processing large datasets. These machines feature a read-only input tape and a separate read-write work tape.\n\nA complete configuration of such a machine is uniquely determined by the combination of its current internal state, the position of its head on the read-only input tape, the entire content of its work tape, and the position of its head on the work tape. The vertices of the machine's configuration graph correspond one-to-one with these unique configurations.\n\nThe machines share the following characteristics:\n- The size of the input on the read-only tape is $n$. The input tape head can be at any integer position from $1$ to $n$.\n- The set of internal states is $Q$, with a total of $q = |Q|$ states.\n- The work tape alphabet is $\\Gamma$, with a size of $k = |\\Gamma|$, where $k \\ge 2$.\n\nThe two models differ only in the size of their work tape, which depends on a positive design constant $c$.\n- **Model M1**: Uses a work tape of size $S_1 = c \\log_2(n)$. The work tape head can be at any integer position from $1$ to $S_1$.\n- **Model M2**: An upgraded version that uses a work tape of size $S_2 = c (\\log_2(n))^2$. The work tape head can be at any integer position from $1$ to $S_2$.\n\nCalculate the ratio of the total number of vertices in the configuration graph of Model M2 to that of Model M1. Express your answer as a symbolic expression in terms of $n$, $k$, and $c$.",
            "solution": "A configuration is uniquely determined by four components: the internal state, the input head position, the entire work tape content, and the work tape head position. For a work tape of length $S$ over alphabet $\\Gamma$ with $|\\Gamma|=k$, the number of possible work tape contents is $k^{S}$, and the number of work tape head positions is $S$. The input head has $n$ positions, and there are $q$ internal states. Therefore, the total number of configurations is\n$$\nV(S) = q \\cdot n \\cdot k^{S} \\cdot S.\n$$\nFor Model M1, $S_1 = c \\log_2(n)$, so\n$$\nV_1 = q \\cdot n \\cdot k^{c \\log_2(n)} \\cdot c \\log_2(n).\n$$\nFor Model M2, $S_2 = c (\\log_2(n))^{2}$, so\n$$\nV_2 = q \\cdot n \\cdot k^{c (\\log_2(n))^{2}} \\cdot c (\\log_2(n))^{2}.\n$$\nThe ratio of the number of vertices is\n$$\n\\frac{V_2}{V_1} = \\frac{q \\cdot n \\cdot k^{S_2} \\cdot S_2}{q \\cdot n \\cdot k^{S_1} \\cdot S_1} = k^{S_2 - S_1} \\cdot \\frac{S_2}{S_1}.\n$$\nSubstituting $S_2 - S_1 = c (\\log_2(n))^{2} - c \\log_2(n) = c \\log_2(n) (\\log_2(n) - 1)$ and $\\frac{S_2}{S_1} = \\frac{c (\\log_2(n))^{2}}{c \\log_2(n)} = \\log_2(n)$ gives\n$$\n\\frac{V_2}{V_1} = k^{c \\log_2(n) (\\log_2(n) - 1)} \\cdot \\log_2(n).\n$$\nThis is the required symbolic ratio in terms of $n$, $k$, and $c$.",
            "answer": "$$\\boxed{\\log_2(n)\\,k^{c\\,\\log_2(n)\\,(\\log_2(n)-1)}}$$"
        },
        {
            "introduction": "Having explored the size of the configuration space, we now turn to its structure and connectivity. While deterministic machines trace a single, unbranching path, non-deterministic machines can explore many computational paths simultaneously, which manifests as branching points in the configuration graph. This exercise asks you to analyze a simple non-deterministic machine and count its distinct \"accepting\" paths, providing a tangible feel for how the concept of non-deterministic choice translates into graph-theoretic paths .",
            "id": "1418046",
            "problem": "In the study of computational complexity, the behavior of a Turing Machine on a specific input can be visualized using a configuration graph. This problem explores the configuration graph for a particular Non-deterministic Turing Machine (NTM) designed for a simple decision problem.\n\nFirst, let's define the components of our model:\n-   **Machine Model**: We consider an NTM with a single, read-only input tape containing the input string $w$ of length $n$, and a single tape head that can read one symbol at a time. For the purpose of this problem, the machine does not use a separate work tape.\n-   **Configuration**: A configuration of this machine is fully described by a pair $(q, i)$, where $q$ is the current state of the machine's finite control, and $i \\in \\{1, 2, \\dots, n\\}$ is the position of the head on the input tape.\n-   **Configuration Graph**: For a given input string $w$, the configuration graph is a directed graph where each vertex is a possible configuration $(q, i)$. A directed edge exists from a vertex $C_1$ to a vertex $C_2$ if the machine can transition from configuration $C_1$ to $C_2$ in a single computation step.\n-   **Computation Path**: A computation path is a sequence of configurations $C_0, C_1, \\dots, C_k$ where $C_0$ is the initial configuration and there is an edge from $C_j$ to $C_{j+1}$ for all $0 \\le j < k$.\n\nNow, consider a specific NTM designed to decide if an input string $w \\in \\{0,1\\}^*$ contains at least one 1.\n-   **States**: The set of states is $Q = \\{q_{\\text{scan}}, q_{\\text{accept}}, q_{\\text{reject}}\\}$. The state $q_{\\text{scan}}$ is the main operational state, while $q_{\\text{accept}}$ and $q_{\\text{reject}}$ are terminal halting states.\n-   **Initial Configuration**: For an input of length $n$, the machine always starts in the configuration $(q_{\\text{scan}}, 1)$.\n-   **Transitions**: From any non-halting configuration $(q_{\\text{scan}}, i)$, where $1 \\le i \\le n$, the machine has the following choices for its next move. Let $w_i$ be the input symbol at position $i$.\n    1.  **Verify Choice**: The machine can choose to check the symbol $w_i$. This choice leads to a terminal state.\n        -   If $w_i = 1$, the machine transitions to the configuration $(q_{\\text{accept}}, i)$.\n        -   If $w_i = 0$, the machine transitions to the configuration $(q_{\\text{reject}}, i)$.\n    2.  **Move Choice**: If and only if $i < n$, the machine can choose to move its head one position to the right, transitioning to the configuration $(q_{\\text{scan}}, i+1)$. This choice is not available at the last position ($i=n$).\n-   **Halting**: Once the machine enters a configuration with state $q_{\\text{accept}}$ or $q_{\\text{reject}}$, it halts, and no further transitions are possible. An **accepting computation path** is a computation path that ends in a configuration with state $q_{\\text{accept}}$.\n\nConsider an input string $w$ of length $n=100$, defined as the pattern '10' repeated 50 times, i.e., $w = 101010...10$.\n\nCalculate the total number of distinct accepting computation paths for this NTM on the given input string $w$.",
            "solution": "We formalize the accepting paths of the given NTM on input $w$ of length $n=100$ with $w=10$ repeated $50$ times.\n\nFrom any non-halting configuration $(q_{\\text{scan}}, i)$ with $1 \\leq i \\leq n$, the machine has exactly two possible choices:\n- Verify Choice: transition to $(q_{\\text{accept}}, i)$ if $w_{i} = 1$, or to $(q_{\\text{reject}}, i)$ if $w_{i} = 0$. This halts immediately.\n- Move Choice: if and only if $i < n$, transition to $(q_{\\text{scan}}, i+1)$.\n\nAn accepting computation path must end in a configuration with state $q_{\\text{accept}}$. This is only possible if at some position $i$ with $w_{i} = 1$, the machine takes the Verify Choice. Because the Verify Choice halts, each accepting path is uniquely determined by the earliest position $i$ at which the Verify Choice is taken with $w_{i} = 1$. For any fixed such $i$, the path from the start $(q_{\\text{scan}}, 1)$ is uniquely the sequence of Move Choices from positions $1$ through $i-1$, followed by the Verify Choice at position $i$. There are no other nondeterministic branches along this path that can continue, since taking Verify earlier would have halted, and the Move Choice is unique when available.\n\nTherefore, the total number of distinct accepting computation paths equals the number of indices $i \\in \\{1,2,\\dots,n\\}$ such that $w_{i} = 1$:\n$$\n\\#\\text{Accepting Paths} = \\left|\\left\\{ i \\in \\{1,\\dots,n\\} : w_{i} = 1 \\right\\}\\right|.\n$$\nFor the specific input $w = 10$ repeated $50$ times, the positions with $w_{i} = 1$ are exactly the odd indices $i \\in \\{1,3,5,\\dots,99\\}$, of which there are $50$. At $i=100$, $w_{100} = 0$, so no accepting path can terminate there, and the Move Choice is unavailable at $i = n$.\n\nHence,\n$$\n\\#\\text{Accepting Paths} = 50.\n$$",
            "answer": "$$\\boxed{50}$$"
        },
        {
            "introduction": "The true power of the configuration graph model lies in its use as an analytical tool. Since the graph for a log-space machine has a polynomially-bounded number of vertices, we can design efficient algorithms to probe its structure and, in doing so, answer questions about the machine's computation. This culminating practice challenges you to think algorithmically about the graph itself, determining the complexity of finding a specific structural feature and connecting it back to fundamental complexity classes .",
            "id": "1418024",
            "problem": "In the study of computational complexity, the structure of a Turing machine's computation can be represented by a configuration graph. This problem investigates the complexity of identifying a specific small-scale feature within such a graph for a particular class of machines.\n\nConsider a deterministic Turing machine $M$ equipped with a read-only input tape and a single read/write work tape. The machine operates on an input string $w$ of length $n = |w|$. We define this machine as a \"log-space machine\" if there exists a constant $c > 0$ (dependent on $M$ but not on $w$) such that for any input $w$, $M$ never uses more than $c \\log_2 n$ cells on its work tape.\n\nA configuration of such a machine is completely described by the tuple $C = (q, i, \\gamma, j)$, where:\n- $q$ is the current state of $M$'s finite control.\n- $i$ is the position of the head on the input tape ($1 \\le i \\le n$).\n- $\\gamma$ is the entire content of the used portion of the work tape, represented as a string. The length of $\\gamma$ is at most $c \\log_2 n$.\n- $j$ is the position of the head on the work tape ($1 \\le j \\le |\\gamma|$).\n\nThe configuration graph $G(M, w)$ is a directed graph where each vertex represents a unique configuration of $M$ on input $w$. A directed edge exists from configuration $C_a$ to $C_b$ if and only if $M$ transitions from $C_a$ to $C_b$ in a single computation step.\n\nA directed cycle of length 3 (or a 3-cycle) is a sequence of three distinct configurations $C_1, C_2, C_3$ such that there are edges $(C_1, C_2)$, $(C_2, C_3)$, and $(C_3, C_1)$ in $G(M, w)$.\n\nLet's define the decision problem `D3CYCLE` as follows: Given the description of a deterministic log-space Turing machine $M$ and an input string $w$, does the configuration graph $G(M, w)$ contain a directed cycle of length 3?\n\nWhich of the following complexity classes best characterizes the `D3CYCLE` problem?\n\nA. L (Deterministic Logarithmic Space)\nB. NL (Nondeterministic Logarithmic Space)\nC. P (Polynomial Time)\nD. NP (Nondeterministic Polynomial Time)\nE. PSPACE (Polynomial Space)",
            "solution": "Let $n = |w|$, let $Q$ be the finite set of states of $M$ with $|Q| = s$, and let $\\Gamma$ be the finite work-tape alphabet with $|\\Gamma| = g$. The log-space bound asserts that there exists a constant $c > 0$ such that the work tape uses at most $c \\log_2 n$ cells on input $w$.\n\nA configuration is a tuple $C = (q, i, \\gamma, j)$ with $q \\in Q$, $1 \\leq i \\leq n$, $\\gamma \\in \\Gamma^{\\leq c \\log_2 n}$, and $1 \\leq j \\leq |\\gamma|$. The total number of possible $\\gamma$ is\n$$\n\\sum_{k=1}^{\\lfloor c \\log_2 n \\rfloor} g^k \\leq \\frac{g^{\\lfloor c \\log_2 n \\rfloor + 1} - g}{g - 1} = O(g^{c \\log_2 n}).\n$$\nUsing $a^{\\log_b n} = n^{\\log_b a}$, we get\n$$\ng^{c \\log_2 n} = n^{c \\log_2 g}.\n$$\nThus, the number of configurations is at most\n$$\n|Q| \\cdot n \\cdot \\left(\\sum_{k=1}^{\\lfloor c \\log_2 n \\rfloor} g^k\\right) \\cdot \\lfloor c \\log_2 n \\rfloor = O(n \\cdot n^{c \\log_2 g} \\cdot \\log n) = \\mathrm{poly}(n).\n$$\nBecause $M$ is deterministic, the configuration graph $G(M,w)$ has out-degree at most $1$ at every vertex. Let $f$ be the (partial) successor function mapping a configuration to its unique next configuration when it exists. A directed $3$-cycle is present if and only if there exists a configuration $C$ for which $f$ is defined on $C$, $f(C)$, and $f^2(C)$, the three configurations $C$, $f(C)$, $f^2(C)$ are pairwise distinct, and\n$$\nf^3(C) = C.\n$$\n\nWe design a deterministic log-space algorithm to decide whether such a $C$ exists.\n\n1. Enumerate all configurations $C = (q,i,\\gamma,j)$. This can be done in lexicographic order using nested counters over:\n   - $q \\in Q$,\n   - $i \\in \\{1,\\dots,n\\}$,\n   - length $\\ell \\in \\{1,\\dots,\\lfloor c \\log_2 n \\rfloor\\}$,\n   - $\\gamma \\in \\Gamma^{\\ell}$,\n   - $j \\in \\{1,\\dots,\\ell\\}$.\n   Each counter requires at most $O(\\log n)$ bits in total because the index space is polynomial in $n$. Reconstructing $\\gamma$ from its index uses $O(\\log n)$ space since $|\\gamma| = O(\\log n)$.\n\n2. For each enumerated $C$, compute its successors under $f$ up to three steps:\n   - Compute $C_1 = f(C)$ if defined by consulting the transition function of $M$ (read from the input), the input symbol at position $i$ in $w$ (read from the input), and the symbol at $j$ in $\\gamma$ (stored locally). If $C_1$ is undefined, continue to the next $C$.\n   - Compute $C_2 = f(C_1)$ similarly; if undefined, continue.\n   - Compute $C_3 = f(C_2)$ similarly; if undefined, continue.\n\n3. Check the $3$-cycle conditions:\n   - Verify $C_3 = C$ by component-wise comparison of tuples.\n   - Verify $C \\neq C_1$ and $C \\neq C_2$ (which implies $C_1 \\neq C_2$ in a functional graph when $f^3(C) = C$ and $C \\neq C_1$).\n\nSpace analysis:\n- Storing one configuration tuple $(q,i,\\gamma,j)$ uses $O(\\log n)$ space because $i$ and $j$ are at most $n$ and $c \\log_2 n$ respectively, and $\\gamma$ has length $O(\\log n)$ over a constant alphabet.\n- Maintaining enumeration counters over a polynomial range uses $O(\\log n)$ bits.\n- Successor computation uses only the current configuration and the read-only input $(M,w)$, so no extra asymptotic space is needed beyond $O(\\log n)$.\n- To compare $C_3$ with $C$, we keep a copy of $C$ while computing successors in another $O(\\log n)$ buffer; the total remains $O(\\log n)$.\n\nTherefore, the entire decision procedure runs in deterministic $O(\\log n)$ space. Consequently, the problem lies in the class L. Since L is contained in all larger listed classes, the tightest characterization among the options is L.\n\nHence, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}