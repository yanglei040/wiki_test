{
    "hands_on_practices": [
        {
            "introduction": "Immerman–Szelepcsényi 定理的核心是一种称为“归纳计数”的巧妙技术，它允许我们迭代地确定从起点可达状态的数量。为了直观地理解这个过程，让我们从一个具体的计算任务开始。这个练习将模拟在一个网络图中，通过逐层扩展来计算可达节点的集合大小，让你亲身体验归纳计数的“增长”特性。",
            "id": "1458177",
            "problem": "在一个大型分布式系统中，有一组 $N$ 个微服务，从 1 到 $N$ 连续编号，它们相互交互。这些交互由一个有向图 $G = (V, E)$ 描述，其中 $V = \\{1, 2, \\dots, N\\}$ 代表这些服务，一条有向边 $(u, v) \\in E$ 表示服务 $u$ 向服务 $v$ 发起网络调用。\n\n在一个特定的目标服务 $t$ 中检测到了一个严重故障。工程团队怀疑存在一个 bug，该 bug 可能源于任何一个存在到 $t$ 的服务调用路径的服务 $u$。为了识别所有可能存在故障的服务，他们采用了一种基于归纳计数原理的分析方法，该原理是 Immerman–Szelepcsényi 定理证明的核心。\n\n设 $B_i(t)$ 是可以通过长度至多为 $i$ 的路径到达服务 $t$ 的服务集合。设 $k_i = |B_i(t)|$ 是这类服务的数量。团队的自动化分析工具已经计算出了前几个步骤的 $k_i$ 值。\n\n给定以下系统配置：\n- 服务总数，$N = 8$。\n- 观察到故障的目标服务，$t = 8$。\n- 所有通信路径（边）的集合是：\n  $E = \\{(1, 3), (2, 3), (3, 5), (4, 5), (4, 6), (5, 7), (6, 7), (7, 8)\\}$。\n- 已知在至多 $i=2$ 步内可到达 $t$ 的服务数量为 $k_2 = 4$。\n\n计算在至多 $i=3$ 步内可到达服务 $t=8$ 的服务数量。换句话说，确定 $k_3$ 的值。",
            "solution": "我们给定一个有向图 $G=(V,E)$，其中 $V=\\{1,2,\\dots,8\\}$，目标节点 $t=8$，以及边集 $E=\\{(1,3),(2,3),(3,5),(4,5),(4,6),(5,7),(6,7),(7,8)\\}$。对于每个整数 $i\\geq 0$，定义 $B_{i}(t)$ 为可以通过长度至多为 $i$ 的有向路径到达 $t$ 的节点集合，并令 $k_{i}=|B_{i}(t)|$。归纳计数中使用的归纳步骤是：\n$$\nB_{i+1}(t)\\;=\\;B_{i}(t)\\;\\cup\\;\\{\\,u\\in V:\\exists\\,(u,v)\\in E\\text{ with }v\\in B_{i}(t)\\,\\}.\n$$\n我们还使用 $B_{0}(t)=\\{t\\}$（长度为 $0$ 的路径可达性是指从 $t$ 到其自身）。我们验证给定的 $k_{2}=4$，然后计算 $k_{3}$。\n\n首先，计算 $B_{0}(t)$：\n$$\nB_{0}(t)=\\{8\\}.\n$$\n\n接下来，通过添加 $8$ 的所有入邻点来计算 $B_{1}(t)$：\n唯一指向 $8$ 的边是 $(7,8)$，所以\n$$\nB_{1}(t)=B_{0}(t)\\cup\\{7\\}=\\{8,7\\},\n\\quad k_{1}=2.\n$$\n\n然后，通过添加 $B_{1}(t)$ 中节点的全部入邻点来计算 $B_{2}(t)$。\n$7$ 的入邻点是 $5$ 和 $6$，而 $8$ 的入邻点是 $7$，该点已包含在内。因此\n$$\nB_{2}(t)=\\{8,7,5,6\\},\n\\quad k_{2}=4,\n$$\n这与给定值相符。\n\n现在通过添加 $B_{2}(t)$ 中节点的全部入邻点来计算 $B_{3}(t)$。\n入邻点如下：\n- 对于 $5$：节点 $3$ 和 $4$ 通过边 $(3,5)$ 和 $(4,5)$，\n- 对于 $6$：节点 $4$ 通过 $(4,6)$，\n- 对于 $7$：节点 $5$ 和 $6$ 通过 $(5,7)$ 和 $(6,7)$（已在 $B_{2}(t)$ 中），\n- 对于 $8$：节点 $7$ 通过 $(7,8)$（已在 $B_{2}(t)$ 中）。\n因此唯一新增的节点是 $3$ 和 $4$，得到\n$$\nB_{3}(t)=\\{8,7,5,6,3,4\\},\n\\quad k_{3}=|B_{3}(t)|=6.\n$$\n\n因此，在至多 $3$ 步内可到达 $t=8$ 的服务数量为 $k_{3}=6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "归纳计数之所以有效，其关键在于它所处理的属性具有“单调性”——一旦一个节点被确认为可达，它在后续的计算中将永远保持可达。然而，并非所有图上的计数问题都具备这种美好的性质。这个练习通过对比两个算法，清晰地揭示了计算可达节点集合与计算路径数量之间的本质区别，从而帮助你理解为什么归纳计数适用于前者，而对后者则无能为力。",
            "id": "1458156",
            "problem": "一位工程师正在设计两种简单的迭代算法来分析一个小型通信网络。该网络被建模为一个有向图 `G`，其顶点集为 `V = {A, B, C, D}`，边集为 `E = {(A, B), (A, C), (B, D), (C, D)}`。顶点 `A` 是所有分析的指定起点。令 `n=4` 为图中的顶点数。工程师需要你确定两种不同算法的输出。\n\n**算法1：`ComputeReachableSetSize`**\n\n该算法正确计算从起始顶点 `A` 可达的唯一顶点总数。它通过迭代地扩展一个可达顶点集来工作。\n\n1.  用起始顶点初始化一个顶点集 `R`：`R = {A}`。\n2.  重复 `n` 次：\n    a. 创建一个临时集合 `N`，其中包含所有满足以下条件的顶点 `v`：在 `E` 中存在一条边 `(u, v)`，其中 `u` 是当前在集合 `R` 中的顶点。\n    b. 通过与临时集合取并集来更新集合 `R`：`R = R \\cup N`。\n3.  该算法的最终输出是最终集合 `R` 的大小（基数）。\n\n**算法2：`NaivePathAggregator`**\n\n该算法代表了一种有缺陷的路径计数尝试。它旨在汇总从 `A` 出发的路径计数，但其逻辑存在错误。它错误地将跟踪可达节点的逻辑与路径计数混合在一起。\n\n1.  初始化一个“已探索”顶点集 `S = {A}`。\n2.  初始化一个映射（例如，一个字典）`P`，用于存储每个顶点的计数。设置 `P[A] = 1`，对于 `V` 中所有其他顶点 `v`，设置 `P[v] = 0`。\n3.  重复 `n` 次：\n    a. 创建一个“新到达”顶点的临时集合 `T`，并初始化为空。\n    b. 对于当前在集合 `S` 中的每个顶点 `u`：\n        i. 对于 `E` 中以 `u` 为起点的每条边 `(u, v)`：\n            - 将目标顶点 `v` 添加到集合 `T`。\n            - 增加 `v` 的路径计数：`P[v] = P[v] + 1`。\n    c. 通过取并集来更新已探索顶点集：`S = S \\cup T`。\n4.  该算法的最终输出是为顶点 `D` 存储的计数，即值 `P[D]`。\n\n你的任务是在给定的图 `G` 上追踪这两种算法的执行过程。`ComputeReachableSetSize` 和 `NaivePathAggregator` 的最终输出值分别是什么？将你的答案表示为一个行矩阵 `[Result1, Result2]`，其中 `Result1` 是第一个算法的输出，`Result2` 是第二个算法的输出。",
            "solution": "给定一个有向图，其顶点集为 $V=\\{A,B,C,D\\}$，边集为 $E=\\{(A,B),(A,C),(B,D),(C,D)\\}$，起始顶点为 $A$，两种算法都进行 $n=4$ 次迭代。\n\n对于算法1 (ComputeReachableSetSize)，初始化 $R_{0}=\\{A\\}$。在每次迭代 $i$ 中，计算 $N_{i}=\\{v\\mid \\exists u\\in R_{i-1}:(u,v)\\in E\\}$，然后更新 $R_{i}=R_{i-1}\\cup N_{i}$。\n迭代1：$R_{0}=\\{A\\}$。从 $A$ 出发有到 $B$ 和 $C$ 的边，所以 $N_{1}=\\{B,C\\}$，$R_{1}=\\{A,B,C\\}$。\n迭代2：$R_{1}=\\{A,B,C\\}$。从 $A$ 我们得到 $B,C$，从 $B$ 我们得到 $D$，从 $C$ 我们得到 $D$，因此 $N_{2}=\\{B,C,D\\}$，$R_{2}=\\{A,B,C,D\\}$。\n迭代3：$R_{2}=\\{A,B,C,D\\}$。从 $A,B,C$ 出发的边再次产生 $N_{3}=\\{B,C,D\\}$，$R_{3}=\\{A,B,C,D\\}$。\n迭代4：同样的模式得到 $N_{4}=\\{B,C,D\\}$ 和 $R_{4}=\\{A,B,C,D\\}$。\n因此，最终输出为 $|R_{4}|=4$。\n\n对于算法2 (NaivePathAggregator)，初始化 $S_{0}=\\{A\\}$ 和路径计数 $P_{0}[A]=1$, $P_{0}[B]=0$, $P_{0}[C]=0$, $P_{0}[D]=0$。在每次迭代 $i$ 中，从 $T_{i}=\\varnothing$ 开始，然后对于每个 $u\\in S_{i-1}$ 和每条边 $(u,v)\\in E$，将 $v$ 添加到 $T_{i}$ 并将 $P[v]$ 增加1，最后设置 $S_{i}=S_{i-1}\\cup T_{i}$。\n迭代1：$S_{0}=\\{A\\}$。处理 $A$ 的边 $(A,B)$ 和 $(A,C)$ 得到 $T_{1}=\\{B,C\\}$，$P[B]=1$, $P[C]=1$, $P[D]=0$。更新 $S_{1}=\\{A,B,C\\}$。\n迭代2：$S_{1}=\\{A,B,C\\}$。处理 $A$ 会给 $P[B]$ 和 $P[C]$ 各加1；处理 $B$ 的边 $(B,D)$ 会给 $P[D]$ 加1；处理 $C$ 的边 $(C,D)$ 会再给 $P[D]$ 加1。因此 $P[B]=2$, $P[C]=2$, $P[D]=2$，且 $T_{2}=\\{B,C,D\\}$，所以 $S_{2}=\\{A,B,C,D\\}$。\n迭代3：$S_{2}=\\{A,B,C,D\\}$。处理 $A$ 会给 $P[B]$ 和 $P[C]$ 各加1；处理 $B$ 会给 $P[D]$ 加1；处理 $C$ 会再给 $P[D]$ 加1；$D$ 没有出边。因此 $P[B]=3$, $P[C]=3$, $P[D]=4$，且 $S_{3}=\\{A,B,C,D\\}$。\n迭代4：应用同样的更新，得到 $P[B]=4$, $P[C]=4$, $P[D]=6$，且 $S_{4}=\\{A,B,C,D\\}$。\n因此，算法2的最终输出是 $P[D]=6$。\n\n所需的结果行矩阵为 $\\begin{pmatrix}4  6\\end{pmatrix}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}4  6\\end{pmatrix}}$$"
        },
        {
            "introduction": "掌握了归纳计数的基本原理后，我们现在可以将其应用于解决一个典型的 $\\text{coNL}$ 完全问题：判断一个不确定性有限自动机（NFA）是否接受所有长度为 $k$ 的字符串。这个问题的挑战在于验证一个“全称”性质。这个练习将引导你思考如何利用归纳计数来构建一个非确定性的验证过程，它通过确认没有“反例”（即被拒绝的字符串）存在，从而证明该全称性质成立，这正是 Immerman–Szelepcsényi 定理证明的精髓所在。",
            "id": "1458147",
            "problem": "考虑这样一个问题：确定一个给定的非确定性有限自动机 (NFA) $M = (Q, \\Sigma, \\delta, q_0, F)$ 是否接受所有特定长度 $k$ 的字符串。设字母表为 $\\Sigma = \\{0, 1\\}$。这个问题，即判定语言 $ALL_{NFA,k}$，是复杂度类 coNL 中问题的一个经典例子。Immerman–Szelepcsényi 定理指出，非确定性空间有界复杂度类在补运算下是封闭的，这意味着 $ALL_{NFA,k}$ 也可以由一个仅使用对数空间的非确定性图灵机来判定。该定理的构造性证明依赖于一种称为“归纳计数”的技术。\n\n你的任务是分析一个使用此原理的非确定性算法。该算法在 NFA 的幂集构造（子集构造）的状态空间上操作，而不显式地构建完整的幂集自动机。这个空间中的一个状态，我们称之为“子集状态”，是 NFA 状态集 $Q$ 的一个子集。初始子集状态是 $S_0 = \\{q_0\\}$。从一个子集状态 $S$ 在一个输入符号 $\\sigma$ 上的转移会到达子集状态 $S' = \\bigcup_{q \\in S} \\delta(q, \\sigma)$。如果一个子集状态 $S$ 不包含原始 NFA 的任何最终状态，即 $S \\cap F = \\emptyset$，则它被定义为“拒绝的”。\n\n该问题等价于验证没有拒绝子集状态可以从初始子集状态 $S_0$ 在恰好 $k$ 步内到达。\n\n一个归纳计数算法首先计算每一步可达的子集状态的数量。设 $R_i$ 为从 $S_0$ 在恰好 $i$ 步内可达的所有子集状态的集合，并设 $c_i = |R_i|$。假设该算法已经成功计算出正确的计数序列 $c_0, c_1, \\ldots, c_k$。\n\n给定这些正确的计数，以下哪个过程准确地描述了一个非确定性算法的最终验证步骤，以确认 $M$ 确实接受所有长度为 $k$ 的字符串？\n\nA. 算法确定性地从 $S_0$ 开始，通过探索所有长度为 $k$ 的路径来构建集合 $R_k$。然后，它遍历 $R_k$ 中的每个状态 $S$，并检查是否有 $S \\cap F = \\emptyset$。如果找到这样的状态，它就拒绝；否则，它接受。\n\nB. 算法非确定性地猜测一个子集状态 $S$。然后它验证 $S$ 在 $k$ 步内是可达的。如果可达，它检查是否有 $S \\cap F = \\emptyset$。如果这个条件满足，算法就接受。如果算法的所有可能的非确定性路径都未能找到这样一个拒绝状态，机器就拒绝。\n\nC. 算法使用计数 $c_k$。它初始化一个计数器 `verified_count = 0`。然后，它遍历所有可能的子集状态 $S \\subseteq Q$。对于每个子集状态 $S$，它非确定性地尝试通过在 $R_{k-1}$ 中找到一个有效的前驱来验证 $S \\in R_k$（使用计数 $c_{k-1}$ 来确保所有前驱都被考虑到）。如果 $S$ 被验证在 $R_k$ 中，它将增加 `verified_count` 并检查是否有 $S \\cap F = \\emptyset$。如果这个条件在任何时候被满足，算法立即拒绝。如果外层循环完成且 `verified_count` 等于 $c_k$ 而没有发现任何拒绝状态，算法接受。\n\nD. 算法使用计数 $c_k$ 来非确定性地一次性猜测整个集合 $R_k$。它验证猜测的集合大小为 $c_k$。然后，它检查猜测集合的每个成员是否是拒绝状态。如果没有成员是拒绝状态，它就接受。",
            "solution": "我们将验证目标形式化。对于 NFA $M=(Q,\\Sigma,\\delta,q_{0},F)$，其中 $\\Sigma=\\{0,1\\}$，以及在 $2^{Q}$ 上的子集构造，定义在 $\\sigma\\in\\Sigma$ 上的子集状态转移为\n$$\n\\Delta(S,\\sigma)\\;=\\;\\bigcup_{q\\in S}\\delta(q,\\sigma).\n$$\n设 $S_{0}=\\{q_{0}\\}$，$R_{i}$ 为从 $S_{0}$ 恰好 $i$ 步可达的子集状态集合，且 $c_{i}=|R_{i}|$。如果 $S\\cap F=\\emptyset$，则子集状态 $S$ 是拒绝状态。性质“$M$ 接受所有长度为 $k$ 的字符串”等价于“$R_{k}$ 中没有拒绝子集状态”。\n\n假设我们已经有了正确的计数 $c_{0},c_{1},\\ldots,c_{k}$。根据 Immerman–Szelepcsényi 方法，最终的验证必须使用归纳计数：它必须确认恰好有 $c_{k}$ 个不同的子集状态构成了 $R_{k}$（完备性和非重复性），并且其中没有一个是拒绝状态。这可以在非确定性对数空间内完成，方法是扫描候选者 $S\\subseteq Q$，通过存在一个前驱 $T\\in R_{k-1}$ 和符号 $\\sigma\\in\\Sigma$ 使得 $\\Delta(T,\\sigma)=S$ 来验证成员关系 $S\\in R_{k}$，并使用先前验证过的计数 $c_{k-1}$ 来确保对 $R_{k}$ 的验证与已验证的 $R_{k-1}$ 一致，而不会遗漏或重复成员。具体来说，对于每个 $S\\subseteq Q$，非确定性地搜索 $T\\subseteq Q$ 和 $\\sigma\\in\\Sigma$ 使得 $T\\in R_{k-1}$ 且 $\\Delta(T,\\sigma)=S$。如果找到，则增加一个已验证的 $R_{k}$ 不同成员的计数器，并且如果 $S\\cap F=\\emptyset$ 则立即拒绝。仅当已验证的不同成员的总数等于 $c_{k}$ 且没有发现拒绝状态 $S$ 时才接受。这正是归纳计数风格的验证：它保证了 $R_{k}$ 的所有且仅有的 $c_{k}$ 个成员都得到了认证，并且没有一个是拒绝状态。\n\n我们现在评估这些选项：\n\nA. 确定性地通过探索所有长度为 $k$ 的路径来构建 $R_{k}$，通常需要指数级的时间和空间来枚举和存储子集状态，并且不符合非确定性对数空间方法，这是归纳计数的核心。它没有反映 coNL 验证技术。\n\nB. 非确定性地猜测一个 $S$，如果它是拒绝状态并且在 $k$ 步内可达，就接受，这决定了存在性属性“在 $R_{k}$ 中存在一个拒绝子集状态”，即补语言。它恰好在 $M$ 未能接受所有长度为 $k$ 的字符串时接受，这对目标语言来说是错误的接受标准。\n\nC. 遍历所有子集状态 $S\\subseteq Q$，通过在 $R_{k-1}$ 中的一个前驱非确定性地验证 $S\\in R_{k}$，同时维护一个已验证的不同成员的计数器等于 $c_{k}$，并在发现 $S\\cap F=\\emptyset$ 时立即拒绝，这与归纳计数验证范式相匹配。它使用计数 $c_{k-1}$ 和 $c_{k}$ 来确保完备性和非重复性，并确认 $R_{k}$ 中没有成员是拒绝状态。这是正确的 coNL 风格的验证步骤。\n\nD. 非确定性地一次性猜测整个集合 $R_{k}$ 并检查其大小是否为 $c_{k}$，需要表示一个指数级大的集合并验证猜测的全局正确性，这在对数空间内是不可行的，也不是归纳计数的进行方式。\n\n因此，与归纳计数证明技术一致的、描述最终验证步骤的正确过程是选项 C。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}