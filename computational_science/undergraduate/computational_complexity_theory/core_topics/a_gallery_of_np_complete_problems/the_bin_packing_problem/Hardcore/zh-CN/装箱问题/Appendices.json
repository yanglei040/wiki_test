{
    "hands_on_practices": [
        {
            "introduction": "首次适应（First-Fit, FF）算法是解决装箱问题最直接、最直观的方法之一。这项动手练习  将在一个实际场景中指导你应用FF算法，帮助你掌握其逐步执行的逻辑。通过将歌曲整理到播放列表中，你将对这个基础在线算法的运作方式有一个具体的理解。",
            "id": "1449885",
            "problem": "一家数字音乐服务商的任务是，将一批新收集的歌曲整理到一系列播放列表中。每个播放列表的严格最大时长为60分钟。该服务商使用一种特定的自动化流程将歌曲分配到播放列表中。歌曲按其标题的字母顺序逐一处理。对于每首歌曲，系统会尝试将其放入第一个有足够剩余容量的已创建播放列表（播放列表1，然后是播放列表2，以此类推）。如果没有现有的播放列表可以容纳这首歌曲，就会为它创建一个新的播放列表。\n\n给定以下歌曲及其时长列表，确定存储所有歌曲所需的播放列表总数。\n\n- \"Ambient Awakening\"：18分钟\n- \"Blockchain Blues\"：25分钟\n- \"Cybernetic Serenade\"：38分钟\n- \"Data-driven Dream\"：15分钟\n- \"Echoes of Entropy\"：22分钟\n- \"Fractal Fantasy\"：12分钟\n- \"Glitch in the Grid\"：29分钟\n- \"Holomorphic Harmony\"：7分钟",
            "solution": "我们将此过程建模为首次适应（First-Fit）装箱问题，箱子容量为 $C=60$。歌曲按所列的字母顺序进行处理。令 $r_{i}$ 表示每次放置后播放列表 $i$ 的剩余容量。\n\n1) \"Ambient Awakening\"，时长 $18$：\n- 不存在播放列表，创建播放列表 $1$。\n- 放入播放列表 $1$：$r_{1} = 60 - 18 = 42$。\n\n2) \"Blockchain Blues\"，时长 $25$：\n- 尝试播放列表 $1$：$25 \\leq r_{1}=42$，可以放入。\n- 更新：$r_{1} = 42 - 25 = 17$。\n\n3) \"Cybernetic Serenade\"，时长 $38$：\n- 尝试播放列表 $1$：$38 \\nleq 17$，无法放入。\n- 创建播放列表 $2$，并放入其中：$r_{2} = 60 - 38 = 22$。\n\n4) \"Data-driven Dream\"，时长 $15$：\n- 尝试播放列表 $1$：$15 \\leq r_{1}=17$，可以放入。\n- 更新：$r_{1} = 17 - 15 = 2$。\n\n5) \"Echoes of Entropy\"，时长 $22$：\n- 尝试播放列表 $1$：$22 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$22 \\leq r_{2}=22$，正好可以放入。\n- 更新：$r_{2} = 22 - 22 = 0$。\n\n6) \"Fractal Fantasy\"，时长 $12$：\n- 尝试播放列表 $1$：$12 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$12 \\nleq 0$，无法放入。\n- 创建播放列表 $3$，并放入其中：$r_{3} = 60 - 12 = 48$。\n\n7) \"Glitch in the Grid\"，时长 $29$：\n- 尝试播放列表 $1$：$29 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$29 \\nleq 0$，无法放入。\n- 尝试播放列表 $3$：$29 \\leq r_{3}=48$，可以放入。\n- 更新：$r_{3} = 48 - 29 = 19$。\n\n8) \"Holomorphic Harmony\"，时长 $7$：\n- 尝试播放列表 $1$：$7 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$7 \\nleq 0$，无法放入。\n- 尝试播放列表 $3$：$7 \\leq r_{3}=19$，可以放入。\n- 更新：$r_{3} = 19 - 7 = 12$。\n\n所有歌曲都被放入了播放列表 $1$–$3$。因此，所需的播放列表总数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "虽然首次适应算法很简单，但其他启发式算法如最佳适应（Best-Fit, BF）提供了不同的策略，它会寻找能容纳物品且剩余空间最小的箱子。本练习  旨在让你直接比较FF和BF算法在处理同一组物品时的表现。你会发现，它们独特的决策过程可能导致不同的装箱结果，这揭示了不同贪心策略之间的细微差别。",
            "id": "1449928",
            "problem": "装箱问题是计算机科学中的一个经典挑战，其目标是将一组不同大小的物品装入最少数量的箱子中，每个箱子都有固定的容量。解决这个问题的两种常见的在线近似算法是首次适应（First-Fit）和最佳适应（Best-Fit）。在线算法从给定的列表中逐一处理物品，而不知道未来的物品信息。\n\n这些算法的定义如下：\n- **首次适应（First-Fit, FF）**：对于列表中的每个物品，将其放入第一个（即索引最小的）有足够剩余容量的箱子中。如果没有现有的箱子可以容纳该物品，则打开一个新箱子并将物品放入其中。\n- **最佳适应（Best-Fit, BF）**：对于列表中的每个物品，将其放入具有最小足够剩余容量的箱子中（即最紧凑的匹配）。如果没有现有的箱子可以容纳该物品，则为其打开一个新箱子。如果出现平局，即多个箱子提供相同的最佳匹配，则将物品放入索引最小的箱子中。\n\n考虑一组相同的箱子，每个箱子的容量为 $C=10$。给定一个有序的物品列表，其尺寸如下：$L = (4, 8, 2, 4)$。\n\n设 $L_{FF}$ 是应用首次适应算法后各箱子（从箱1到最后打开的箱子）最终剩余容量的有序列表。同样，设 $L_{BF}$ 是应用最佳适应算法后最终剩余容量的有序列表。以下哪个陈述正确描述了 $L_{FF}$ 和 $L_{BF}$？\n\nA. $L_{FF} = (0, 2)$ 且 $L_{BF} = (2, 0)$\n\nB. $L_{FF} = (2, 0)$ 且 $L_{BF} = (0, 2)$\n\nC. $L_{FF} = (0, 2)$ 且 $L_{BF} = (0, 2)$\n\nD. $L_{FF} = (4, 2)$ 且 $L_{BF} = (2, 4)$\n\nE. 两种算法都导致打开三个箱子。",
            "solution": "我们使用箱子容量 $C=10$ 和物品列表 $L=(4,8,2,4)$，逐步模拟每种在线算法，并记录剩余容量。\n\n首次适应（FF）：\n1) 物品 $4$：没有现有箱子，打开箱子 $1$。剩余容量变为 $10-4=6$。状态：$(6)$。\n2) 物品 $8$：箱子 $1$ 的容量为 $6$，不足以容纳 $8$，因此打开箱子 $2$。剩余容量变为 $10-8=2$。状态：$(6,2)$。\n3) 物品 $2$：放入第一个能容纳的箱子，即容量为 $6$ 的箱子 $1$。箱子 $1$ 的新剩余容量为 $6-2=4$。状态：$(4,2)$。\n4) 物品 $4$：放入第一个能容纳的箱子，即容量为 $4$ 的箱子 $1$。箱子 $1$ 的新剩余容量为 $4-4=0$。最终状态：$(0,2)$。\n因此 $L_{FF}=(0,2)$。\n\n最佳适应（BF）：\n1) 物品 $4$：没有现有箱子，打开箱子 $1$。剩余容量变为 $10-4=6$。状态：$(6)$。\n2) 物品 $8$：箱子 $1$ 的容量为 $6$，不足以容纳 $8$，因此打开箱子 $2$。剩余容量变为 $10-8=2$。状态：$(6,2)$。\n3) 物品 $2$：在能容纳 $2$ 的箱子中，选择剩余容量最小的那个。箱子 $2$ 剩余 $2$，箱子 $1$ 剩余 $6$，所以选择箱子 $2$。箱子 $2$ 的新剩余容量为 $2-2=0$。状态：$(6,0)$。\n4) 物品 $4$：在能容纳 $4$ 的箱子中，只有剩余容量为 $6$ 的箱子 $1$ 符合条件。将其放入；新剩余容量为 $6-4=2$。最终状态：$(2,0)$。\n因此 $L_{BF}=(2,0)$。\n\n与选项比较，这与选项A匹配。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "启发式算法能提供快速的解决方案，但与完美的最佳解相比，它们的表现究竟如何？这项练习  通过一个精心设计的“最坏情况”场景，探讨了首次适应算法的性能局限。通过分析这个特定的装箱序列，你将量化贪心解与最优解之间的差距，这是理解和分析近似算法的关键一步。",
            "id": "1449894",
            "problem": "一家物流公司使用标准集装箱来管理货物运输，每个集装箱的标准化容量为1个单位。该公司需要运输两种特殊物品：“A类”物品，每件占用集装箱容量的 $2/3$；以及“B类”物品，每件占用集装箱容量的 $1/3$。\n\n在某一天，一个自动化装载系统接收到一批特定顺序的待包装物品。首先到达的是一批30件“B类”物品，随后是一批30件“A类”物品。该系统采用“首次适应”（First-Fit）贪心算法按物品到达的顺序进行包装。首次适应算法的工作原理如下：对于每件物品，它会尝试将其放入第一个（按开启顺序从1开始检查）有足够剩余容量的集装箱。如果没有现有的集装箱能容纳该物品，就会开启一个新的空集装箱，并将物品放入其中。\n\n一种最优的包装策略会通过可能地对物品重新排序，来达到所需集装箱数量的绝对最小值。\n\n计算首次适应算法对给定序列使用的集装箱数量与最优包装所需的集装箱数量之间的差值。",
            "solution": "设 $B_{FF}$ 为首次适应算法使用的集装箱数量，$B_{OPT}$ 为最优包装使用的集装箱数量。我们需要计算差值 $\\Delta B = B_{FF} - B_{OPT}$。\n\n**第1部分：计算首次适应算法使用的集装箱数量 ($B_{FF}$)**\n\n首次适应算法按给定的顺序处理物品：首先是30件“B类”物品（大小为 $1/3$），然后是30件“A类”物品（大小为 $2/3$）。\n\n**步骤1.1：包装30件“B类”物品。**\n每件“B类”物品的大小为 $1/3$。算法将顺序填充集装箱。\n- 第一件“B类”物品放入1号集装箱。剩余容量：$1 - 1/3 = 2/3$。\n- 第二件“B类”物品也放入1号集装箱。剩余容量：$2/3 - 1/3 = 1/3$。\n- 第三件“B类”物品也放入1号集装箱。剩余容量：$1/3 - 1/3 = 0$。1号集装箱现已装满。\n- 第四件“B类”物品无法放入1号集装箱，因此算法开启2号集装箱。\n这个模式会重复。每个集装箱可以正好容纳三件“B类”物品（$3 \\times 1/3 = 1$）。\n包装30件“B类”物品所需的集装箱数量为：\n$$N_{B} = \\frac{30 \\text{ 件物品}}{3 \\text{ 件物品/集装箱}} = 10 \\text{ 个集装箱}$$\n因此，在第一阶段之后，我们有10个完全装满的集装箱。\n\n**步骤1.2：包装30件“A类”物品。**\n现在，30件大小为 $2/3$ 的“A类”物品到达。\n首次适应算法会尝试将第一件“A类”物品放入现有集装箱中，从1号集装箱开始。\n- 1号到10号集装箱都已完全装满（剩余容量为0）。一件“A类”物品（大小为 $2/3$）无法放入其中任何一个。\n- 因此，对于第一件“A类”物品，算法必须开启一个新的集装箱，即11号集装箱。\n- 第一件“A类”物品被放入11号集装箱。剩余容量：$1 - 2/3 = 1/3$。\n- 当第二件“A类”物品到达时，算法检查现有集装箱。1号到10号集装箱已满。11号集装箱只剩下 $1/3$ 的容量，不足以容纳一个大小为 $2/3$ 的物品。\n- 因此，算法为第二件“A类”物品开启一个新的集装箱，即12号集装箱。\n这个逻辑适用于所有30件“A类”物品。每一件都需要一个新的集装箱，因为没有两个“A类”物品可以放在同一个集装箱里（$2 \\times 2/3 = 4/3  1$），并且装有一个“A类”物品的集装箱的剩余空间对于另一个来说太小了。\n“A类”物品所需的新集装箱数量为30个。\n$$N_{A} = 30 \\text{ 个集装箱}$$\n\n**步骤1.3：首次适应算法的总集装箱数。**\n首次适应算法使用的集装箱总数是两个阶段集装箱数量的总和。\n$$B_{FF} = N_{B} + N_{A} = 10 + 30 = 40$$\n\n**第2部分：计算最优包装的集装箱数量 ($B_{OPT}$)**\n\n对于最优包装，我们可以按任意顺序排列物品，以最小化使用的集装箱数量。包装这些物品最有效的方法是在一个集装箱中组合一件“A类”物品和一件“B类”物品。\n一件“A类”物品和一件“B类”物品的组合大小为：\n$$\\text{大小} = \\frac{2}{3} + \\frac{1}{3} = 1$$\n这种组合正好填满一个集装箱。我们有30件“A类”物品和30件“B类”物品。因此，我们可以组成30个这样的配对。\n每个配对将正好填满一个集装箱。因此，所需的最少集装箱数量为30。\n$$B_{OPT} = 30$$\n\n**第3部分：计算差值**\n\n首次适应算法使用的集装箱数量与最优数量之间的差值为：\n$$\\Delta B = B_{FF} - B_{OPT} = 40 - 30 = 10$$",
            "answer": "$$\\boxed{10}$$"
        }
    ]
}