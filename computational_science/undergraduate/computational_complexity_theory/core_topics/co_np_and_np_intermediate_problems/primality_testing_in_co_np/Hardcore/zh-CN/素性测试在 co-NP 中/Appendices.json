{
    "hands_on_practices": [
        {
            "introduction": "要掌握计算复杂性，第一步是透彻理解 **NP** 类的核心概念。一个问题属于 **NP**，意味着即使找到答案可能很难，但验证一个给定的答案（或“证书”）却相对容易。本练习  以“完美幂”这一直观的数学概念为例，引导你思考如何设计一个有效的证书和多项式时间验证机，从而为判定一个数是否为完美幂提供一个可快速检验的证明。",
            "id": "1436744",
            "problem": "在计算复杂性理论中，如果一个问题实例的提议解（称为“证书”）可以在多项式时间内被验证，那么该语言 $L$ 就属于 **NP** 类（非确定性多项式时间）。\n\n考虑完全幂语言 $L_{\\text{PP}}$，它由所有可以表示为 $a^k$（其中整数 $a, k \\ge 2$）的正整数 $n$ 组成。一个判断是否属于该语言的算法会接收一个整数 $n$ 作为输入。此输入的大小由表示 $n$ 所需的位数来衡量，我们记作 $B = \\lfloor \\log_2 n \\rfloor + 1$。如果一个验证机的运行时间以 $B$ 的多项式为界，则认为它在多项式时间内运行。\n\n一位计算机科学家正在为 $L_{\\text{PP}}$ 设计一个验证机。她有四个提案，每个提案都包含一个需要提供的证书和一个验证算法。以下哪个提案正确且最直接地证明了 $L_{\\text{PP}}$ 属于 **NP** 类？\n\nA. **证书：**一个整数 $k \\ge 2$。 **验证机：**在范围 $[2, n]$ 内对整数 $a$ 执行二分搜索，以检查是否有 $a^k = n$。\n\nB. **证书：**一个整数 $a \\ge 2$。 **验证机：**遍历从 $2$ 到 $n$ 的所有整数 $k$，并检查是否有 $a^k = n$。\n\nC. **证书：**一对整数 $\\langle a, k \\rangle$，其中 $a, k \\ge 2$。 **验证机：**计算 $a^k$ 并检查其是否等于 $n$。\n\nD. **证书：**$n$ 的完全素数分解，形式为 $p_1^{e_1} p_2^{e_2} \\cdots p_m^{e_m}$。 **验证机：**检查所有 $p_i$ 都是素数，它们的幂相乘得到 $n$，并且指数集合 $\\{e_1, e_2, \\dots, e_m\\}$ 的最大公约数大于 1。",
            "solution": "我们回顾一下 **NP** 验证机的定义：存在一个多项式 $p$，使得对于每个长度为 $|x|$ 的输入 $x$，存在一个证书 $y$（其长度 $|y| \\leq p(|x|)$）和一个确定性验证机 $V$，该验证机在 $|x|$ 的多项式时间内运行，并且当且仅当 $x$ 属于该语言时接受。在这里，输入是一个正整数 $n$，其位长度为 $B=\\lfloor \\log_{2} n \\rfloor + 1$。我们用 $M(B)$ 表示在标准 RAM 模型上两个 $B$ 位整数相乘所需的时间；$M(B)$ 是 $B$ 的多项式。通过重复平方的快速幂运算使用 $O(\\log k)$ 次乘法。\n\n我们根据 $B$ 来分析每个提案的证书长度和验证机运行时间。\n\nA. 证书：一个整数 $k \\geq 2$。由于 $n=a^{k}$ 且 $a \\geq 2$ 意味着 $2^{k} \\leq n$，任何有效的证书都满足 $k \\leq \\log_{2} n$，因此其位长度为 $O(\\log k) \\leq O(\\log \\log n)=O(\\log B)$，这是 $B$ 的多项式。验证机在 $[2,n]$ 范围内对 $a$ 进行二分搜索。函数 $f(a)=a^{k}$ 在 $a \\geq 1$ 时是严格递增的，所以二分搜索需要 $O(\\log n)=O(B)$ 次迭代。在每次迭代中，通过重复平方计算 $a^{k}$ 需要 $O(\\log k)$ 次乘法，并且如果中间值超过 $n$，我们可以提前中止，因此所有中间值最多有 $B$ 位。因此，单次幂运算的成本为 $O(M(B)\\log k) \\leq O(M(B)\\log B)$。总时间为 $O(B \\cdot M(B) \\cdot \\log B)$，这是 $B$ 的多项式。因此，A 是一个有效的 NP 验证过程。\n\nB. 证书：一个整数 $a \\geq 2$。证书长度为 $O(\\log a) \\leq O(B)$，但验证机需要从 $2$ 迭代到 $n$ 来遍历 $k$，这需要 $\\Theta(n)$ 次迭代。由于 $n$ 有 $B$ 位， $n$ 可以大到 $2^{B}$，因此一个长度为 $\\Theta(n)$ 的循环是 $B$ 的指数级而不是多项式级。因此，B 未能证明其属于 NP 类。\n\nC. 证书：一对整数 $\\langle a,k \\rangle$，其中 $a,k \\geq 2$。由于 $a^{k}=n$ 且 $a \\geq 2$ 意味着 $a \\leq n$ 和 $k \\leq \\log_{2} n$，证书长度为 $O(\\log a + \\log k) \\leq O(B + \\log B)=O(B)$。验证机通过重复平方计算 $a^{k}$，如果中间值超过 $n$ 则中止，确保所有中间值最多有 $B$ 位。这需要 $O(\\log k)$ 次乘法，所以时间为 $O(M(B)\\log k) \\leq O(M(B) B)$，外加与 $n$ 的一次 $O(B)$ 比较。因此，验证在 $B$ 的多项式时间内运行。这是最简单和最直接的 NP 证书：它恰好提供了见证 $\\langle a,k \\rangle$ 并检查 $a^{k}=n$。\n\nD. 证书：素数分解 $n=\\prod_{i=1}^{m} p_{i}^{e_{i}}$。此证书的大小为 $O\\!\\left(\\sum_{i=1}^{m} \\log p_{i} + \\sum_{i=1}^{m} \\log e_{i}\\right)$。由于 $\\sum \\log p_{i} \\leq \\log n = O(B)$ 且每个 $e_{i} \\leq \\log_{2} n$（其中 $m \\leq B$），我们有 $\\sum \\log e_{i} \\leq m \\log \\log n = O(B \\log B)$。因此，证书长度是 $B$ 的多项式。验证机在多项式时间内确定性地检查每个 $p_i$ 的素性（例如，通过 AKS 算法），在 $O(B \\cdot M(B))$ 时间内将 $\\prod p_{i}^{e_{i}}$ 相乘并与 $n$ 比较，并在 $\\log \\max e_{i} \\leq O(\\log B)$ 的多项式时间内计算 $\\gcd(e_{1},\\dots,e_{m})$。因此，D 也是一个有效的 NP 验证过程。\n\n在有效的提案中，C 是证明 $L_{\\text{PP}} \\in \\text{NP}$ 最直接的方式，因为它使用了自然的见证 $\\langle a,k \\rangle$ 和一个直接的多项式时间检查 $a^{k}=n$，而无需辅助的复杂子程序或额外的搜索。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在理解了 **NP** 的基本定义后，我们可以进一步探讨如何构建一个真正“可靠”的证书。设计证书的过程如同侦探提供证据，必须确保证据确凿无疑。本练习  挑战你为“至少包含两个不同素因子”的整数设计证书，你将学会区分哪些证据是充分的，哪些则可能存在漏洞，从而深化对健全性（soundness）和完备性（completeness）的理解。",
            "id": "1436748",
            "problem": "在计算复杂性理论中，一个关键概念是“证书”（certificate）或“见证”（witness）。对于一个给定的语言 $L$（一个字符串集合，在本例中是整数集合），输入 $n$ 的一个证书是一条信息 $y$，它能让一个验证算法高效地确认 $n$ 确实在 $L$ 中。一个验证器 $V(n, y)$ 必须在 $n$ 的大小（即 $\\log_2 n$）的多项式时间内运行，并且必须满足两个条件：\n1.  **完备性（Completeness）**: 对于每个 $n \\in L$，存在一个证书 $y$（其大小是 $\\log_2 n$ 的多项式），使得 $V(n,y)$ 接受。\n2.  **可靠性（Soundness）**: 对于任何 $n \\notin L$，验证器 $V(n,y)$ 必须对所有可能的证书 $y$ 都拒绝。\n\n考虑语言 $L$，它是由至少包含两个不同素因子的正整数组成的集合。例如，$12 = 2^2 \\cdot 3$ 在 $L$ 中，但 $17$（一个素数）和 $8 = 2^3$（一个素数的幂）不在 $L$ 中。\n\n以下哪项关于证书 $y$ 的提议是有效的，可以用来证明一个整数 $n$ 属于语言 $L$？\n\nA. 两个整数 $u,v$，满足 $u > 1$，$v > 1$，且 $n = uv$。\nB. 一个整数 $d$，满足 $1 \\lt d \\lt n$ 且 $d$ 整除 $n$。\nC. 两个整数 $u,v$，满足 $u > 1$，$v > 1$，$n = uv$，且它们的最大公约数 $\\gcd(u,v) = 1$。\nD. 一个整除 $n$ 的素数 $p$，以及一个整数 $m > 1$，满足 $m$ 也整除 $n$ 且 $\\gcd(p,m) = 1$。\nE. 两个都整除 $n$ 的不同素数 $p_1, p_2$。\n\n选择所有有效选项。",
            "solution": "我们将语言 $L$ 形式化为所有其素因数分解中包含至少两个不同素数的正整数的集合。等价地，$n \\in L$ 当且仅当存在不同的素数 $p_{1}$ 和 $p_{2}$ 使得 $p_{1} \\mid n$ 且 $p_{2} \\mid n$。\n\n对于 $n \\in L$ 的一个证书 $y$ 必须能让一个确定性验证器 $V(n,y)$ 在 $\\log_{2}(n)$ 的多项式时间内检查出 $n$ 确实有至少两个不同的素因子。我们对每个提议进行可靠性（它绝不能接受 $n \\notin L$）和完备性（对于每个 $n \\in L$，都存在这样的证书）两方面的评估，并确保验证工作在 $n$ 的比特长度上是多项式时间的。\n\n关于高效检查的预备知识：\n- 整除性检查“$a \\mid b$”、等式检查以及通过欧几里得算法计算 $\\gcd(a,b)$ 都在输入的比特长度的多项式时间内运行，因此在 $\\log_{2}(n)$ 上是多项式时间的。\n- 一个声称的素数的素性可以在其比特长度的多项式时间内确定性地验证（例如，AKS素性测试）。因此，在验证器的时间限制内检查一个整数是否为素数是可行的。\n- 证书大小必须是 $\\log_{2}(n)$ 的多项式；所有作为因子或素数提供的整数最多为 $n$，因此它们的编码是 $O(\\log_{2}(n))$ 比特。\n\n选项A：两个整数 $u,v$，满足 $u>1$，$v>1$，且 $n=uv$。\n- 验证：检查 $u>1$，$v>1$ 和 $uv=n$。这是多项式时间的。\n- 可靠性：失败。考虑一个素数的幂 $n$，例如 $n=2^{3}$。取 $u=2$，$v=2^{2}$ 满足 $u>1$，$v>1$ 和 $uv=n$，但 $n \\notin L$。因此，存在 $n \\notin L$ 却有一个会被接受的证书。所以A是不可靠的，是无效的。\n\n选项B：一个整数 $d$，满足 $1 \\lt d \\lt n$ 且 $d$ 整除 $n$。\n- 验证：检查 $1 \\lt d \\lt n$ 和 $n \\pmod{d}=0$。这是多项式时间的。\n- 可靠性：失败。此证书仅证明 $n$ 是合数。它不排除 $n$ 是素数的幂的可能性。例如，对于 $n=8=2^3$，证书 $d=2$ 或 $d=4$ 会被接受，但 $n \\notin L$。所以B是不可靠的，是无效的。\n\n选项C：两个整数 $u,v$，满足 $u > 1$，$v > 1$，$n = uv$，且它们的最大公约数 $\\gcd(u,v) = 1$。\n- 验证：检查 $u>1, v>1, uv=n$ 和 $\\gcd(u,v)=1$。所有这些都在多项式时间内完成。\n- 可靠性：可靠。如果 $\\gcd(u,v)=1$，那么 $u$ 和 $v$ 没有任何共同的素因子。由于 $u,v > 1$，它们各自必须至少有一个素因子。设 $p_1$ 是 $u$ 的一个素因子，$p_2$ 是 $v$ 的一个素因子。那么 $p_1 \\neq p_2$。由于 $u \\mid n$ 且 $v \\mid n$，我们有 $p_1 \\mid n$ 和 $p_2 \\mid n$。因此，$n$ 有至少两个不同的素因子。该验证器绝不会错误地接受 $n \\notin L$。\n- 完备性：完备。如果 $n \\in L$，那么 $n$ 至少有两个不同的素因子 $p_1, p_2$。我们可以选择 $u=p_1$ 和 $v=n/p_1$。由于 $p_2 \\mid (n/p_1)$，我们有 $v>1$。同时 $u>1$。$\\gcd(p_1, n/p_1)$ 可以是 1 或 $p_1$。如果它是 1，我们就找到了一个有效的证书。如果它是 $p_1$，我们选择 $u = p_1^{e_1}$（$p_1$ 在 $n$ 的分解中的最大幂）和 $v=n/u$。由于 $n$ 至少有另一个素因子 $p_2$，所以 $v>1$ 且 $\\gcd(u,v)=1$。因此，对于每个 $n \\in L$ 都存在一个有效的证书。所以C是有效的。\n\n选项D：一个整除 $n$ 的素数 $p$，以及一个整数 $m > 1$，满足 $m$ 也整除 $n$ 且 $\\gcd(p,m) = 1$。\n- 验证：检查 $p$ 的素性，检查 $p \\mid n$ 和 $m \\mid n$，检查 $m > 1$ 和 $\\gcd(p,m)=1$。所有这些都是多项式时间的。\n- 可靠性：可靠。由于 $\\gcd(p,m)=1$ 且 $m > 1$，$m$ 必须有至少一个不等于 $p$ 的素因子，我们称之为 $p_2$。由于 $p$ 和 $p_2$ 都整除 $n$，所以 $n$ 至少有两个不同的素因子。\n- 完备性：完备。如果 $n \\in L$，它有两个不同的素因子 $p_1$ 和 $p_2$。我们可以选择证书为 $y = \\langle p_1, p_2 \\rangle$。这里 $p_1$ 是素数，$m=p_2$ 是一个大于1的整数，$p_1 \\mid n$，$p_2 \\mid n$，且 $\\gcd(p_1, p_2)=1$。因此，对于每个 $n \\in L$ 都存在一个证书。所以D是有效的。\n\n选项E：两个都整除 $n$ 的不同素数 $p_1, p_2$。\n- 验证：检查 $p_1 \\neq p_2$，检查 $p_1, p_2$ 的素性，并检查 $p_1 \\mid n$ 和 $p_2 \\mid n$。所有这些检查都是多项式时间的。\n- 可靠性：可靠。这个证书直接证明了 $n$ 满足语言 $L$ 的定义。\n- 完备性：完备。如果 $n \\in L$，根据定义，它必须有两个不同的素因子。这两个素因子本身就构成了有效的证书。所以E是有效的。\n\n因此，有效的提议是C、D和E。",
            "answer": "$$\\boxed{CDE}$$"
        },
        {
            "introduction": "现在，让我们将目光转向 **NP** 的“镜像”——**co-NP** 类。如果说 **NP** 问题是有着易于验证的“是”答案，那么 **co-NP** 问题就是有着易于验证的“否”答案。本练习  要求你证明一个语言属于 **co-NP**，这需要你为其补集（complement）设计一个有效的 **NP** 证书。通过这个实践，你将亲身体验如何通过寻找一个“反例”来高效地证明某个实例不具备特定属性，这是理解素性测试为何属于 **co-NP** 的关键一步。",
            "id": "1436745",
            "problem": "考虑定义在正整数对 $\\langle n, k \\rangle$ 上的语言 $L$，其中 $n > 1$ 且 $k > 1$。一个输入字符串 $\\langle n, k \\rangle$ 属于语言 $L$ 当且仅当 $n$ 的所有素因子都大于或等于 $k$。\n\n复杂度类 **NP**（非确定性多项式时间）包含这样一类判定问题：对于“是”实例，给定一个称为证书或见证的合适信息串，可以在确定性图灵机上用多项式时间进行验证。复杂度类 **co-NP** 包含其补集在 **NP** 中的语言。\n\n为了证明语言 $L$ 属于 **co-NP**，必须证明其补集 $\\bar{L}$ 属于 **NP**。要证明 $\\bar{L} \\in \\text{NP}$，需要确定一个能证明其在 $\\bar{L}$ 中成员资格的证书，以及一个相对于输入 $\\langle n, k \\rangle$ 大小在多项式时间内运行的验证算法。回顾一下，一个输入 $\\langle n, k \\rangle$ 属于 $\\bar{L}$ 当且仅当存在至少一个 $n$ 的素因子严格小于 $k$。\n\n下列哪项描述了一个有效的证书以及一个多项式时间验证器为确认输入 $\\langle n, k \\rangle$ 是语言 $\\bar{L}$ 的成员而必须执行的相应检查？\n\nA. 证书是一个整数 $p$。验证算法检查是否 $p \\lt k$以及是否 $n \\pmod p = 0$。\n\nB. 证书是一个整数 $p$。验证算法检查是否 $p \\lt k$，是否 $n \\pmod p = 0$，以及 $p$ 是否为素数。\n\nC. 证书是 $n$ 的完整素因子分解。验证算法将这些因子相乘，确认其积等于 $n$，然后检查分解中是否至少有一个素因子 $p$ 满足 $p \\lt k$。\n\nD. 证书是一个整数对 $\\langle p, a \\rangle$。验证算法检查是否 $p \\lt k$，$p$ 是否为素数，以及 $p^a$ 是否是 $p$ 整除 $n$ 的最大幂。\n\nE. 不存在这样的多项式时间可验证的证书，因为找到一个整数的素因子被认为是计算上困难的问题，因此 $\\bar{L}$ 不在 **NP** 中。",
            "solution": "给定语言 $L=\\{\\langle n,k\\rangle: n>1, k>1, \\text{ 且 } n \\text{ 的每个素因子 } \\ge k\\}$。其补集是 $\\bar{L}=\\{\\langle n,k\\rangle: n>1, k>1, \\text{ 且存在 } n \\text{ 的一个素因子 } p \\text{ 满足 } p \\lt k\\}$。为了证明 $L \\in \\text{co-NP}$，我们需要证明 $\\bar{L} \\in \\text{NP}$。这意味着对于任何 $\\langle n,k \\rangle \\in \\bar{L}$，都必须存在一个可以在多项式时间内验证的简短证书。\n\n我们来评估每个选项：\n- **选项A**：证书是整数 $p$。验证器检查 $p \\lt k$ 和 $p \\mid n$。这个验证器是不可靠的。例如，考虑输入 $\\langle n=30, k=7 \\rangle$。$n$ 的素因子是2, 3, 5，都小于7，所以 $\\langle 30,7 \\rangle \\in \\bar{L}$。一个有效的证书是 $p=2, 3$ 或 $5$。但考虑一个不同的输入 $\\langle n=21, k=4 \\rangle$。$n$ 的素因子是3和7，都大于或等于4，所以 $\\langle 21,4 \\rangle \\notin \\bar{L}$。如果一个恶意的提议者提供证书 $p=3$，验证器会检查 $3 \\lt 4$ 和 $3 \\mid 21$，两者都为真，因此会错误地接受。错误在于证书 $p$ 不被要求为素数。一个更强的反例是 $\\langle n=10, k=6 \\rangle$，$n$ 的素因子是2和5，都小于6，所以 $\\langle 10,6 \\rangle \\in \\bar{L}$。现在考虑 $\\langle n=12, k=5 \\rangle$。$n=2^2 \\cdot 3$ 的素因子是2和3，都小于5，所以 $\\langle 12,5 \\rangle \\in \\bar{L}$。一个更好的反例：$\\langle n=55, k=6 \\rangle$。素因子是5和11。$5  6$，所以它在 $\\bar{L}$ 中。现在考虑 $\\langle n=33, k=4 \\rangle$。素因子是3和11。$3  4$，所以它在 $\\bar{L}$ 中。让我们重新考虑反例。设 $\\langle n,k \\rangle \\notin \\bar{L}$，即 $L$ 的所有素因子都 $\\ge k$。例如 $\\langle n=39, k=5 \\rangle$。素因子是3和13。$3  5$，所以它在 $\\bar{L}$ 中。好吧，让我们构造一个反例：令 $\\langle n, k \\rangle = \\langle 119, 8 \\rangle = \\langle 7 \\cdot 17, 8 \\rangle$。$n$ 的素因子是7和17。两者都不小于8。因此 $\\langle 119, 8 \\rangle \\notin \\bar{L}$。如果提议者提供证书 $p=7$，验证器会检查 $7 \\lt 8$ 和 $7 \\mid 119$，两者都为真，所以会错误地接受。证书必须是素数。哦，不对，我的反例是对的。对于 $\\langle n=21, k=4 \\rangle$，素因子是3和7。因为$34$，所以它在 $\\bar{L}$ 中。A的问题在于，如果 $p$ 是合数。例如，$\\langle n=77, k=8 \\rangle$。素因子是7和11。$78$，所以它在 $\\bar{L}$ 中。现在考虑 $\\langle n=51, k=10 \\rangle$。素因子是3和17。$310$，在 $\\bar{L}$ 中。反例：$\\langle n=91, k=8 \\rangle$。素因子是7和13。$78$，在 $\\bar{L}$ 中。反例：$\\langle n=143, k=12 \\rangle$。素因子是11和13。两者都不小于12，所以它不在 $\\bar{L}$ 中。如果提议者提供证书 $p=11$，验证器检查 $11 \\lt 12$ 和 $11 \\mid 143$，都为真。这里 $p=11$ 是素数。啊，选项A不要求 $p$ 是素数。那么，对于 $\\langle n=143, k=12 \\rangle$，如果提议者提供合数证书 $p=11$ 是不行的。如果提议者提供 $p=1$... 不，证书必须是素因子。A的错误在于它没有检查 $p$ 是素数。比如 $\\langle n=33, k=4 \\rangle$ 不在 $\\bar{L}$ 中，因为3和11都是素因子，且3  4。所以它在 $\\bar{L}$ 中。反例：$\\langle n=55, k=6 \\rangle$ 在 $\\bar{L}$ 中。$\\langle n=77, k=8 \\rangle$ 在 $\\bar{L}$ 中。让我们考虑 $\\langle n=169, k=10 \\rangle$。$n=13^2$。唯一的素因子是13，不小于10。所以它不在 $\\bar{L}$ 中。如果提议者提供证书 $p=1$，不满足 $p>1$。如果提议者提供证书 $p=13$，验证器检查 $13 \\lt 10$，为假，拒绝。如果提议者提供一个合数因子，比如 $n=51=3 \\times 17, k=4$。$34$，所以它在 $\\bar{L}$ 中。如果 $\\langle n,k \\rangle = \\langle 119, 10 \\rangle = \\langle 7 \\times 17, 10 \\rangle$。$710$，在 $\\bar{L}$ 中。反例：$\\langle n=221, k=15 \\rangle = \\langle 13 \\times 17, 15 \\rangle$。不在 $\\bar{L}$ 中。如果证书是 $p=13$，验证器检查 $13 \\lt 15$ 和 $13 \\mid 221$，都为真。但13是素数。所以A和B都可能接受。问题出在 $p$ 必须是 $n$ 的素因子。选项A和B只检查 $p$ 整除 $n$。让我们重新审视定义。$\\bar{L}$ 是存在一个 *素因子* $p  k$。选项A的证书 $p$ 不一定是素数。所以A是无效的。\n\n- **选项B**：证书是整数 $p$。验证器检查 $p \\lt k$，$p \\mid n$，以及 $p$ 是素数。这是正确的。如果 $\\langle n, k \\rangle \\in \\bar{L}$，那么根据定义，存在这样一个素数 $p$ 作为证书。如果 $\\langle n, k \\rangle \\notin \\bar{L}$，那么 $n$ 的所有素因子都 $\\ge k$。任何小于 $k$ 的素数都不会整除 $n$。任何整除 $n$ 的素数都不会小于 $k$。因此，没有证书能使验证器接受。检查 $p$ 的素性（例如通过AKS算法）需要多项式时间。因此，这是一个有效的验证过程。\n\n- **选项C**：证书是 $n$ 的完整素因子分解。验证器可以检查分解的正确性，然后检查是否有因子小于 $k$。这在理论上是有效的。然而，证书本身（素因子分解）被认为很难计算。但是 **NP** 的定义不关心证书的计算难度，只关心它的存在和验证。素因子分解的长度是多项式级的。所以这也是一个有效的证明。但是，它比B需要更多的信息。B只需要一个素因子，而C需要所有素因子。因此，B更直接。\n\n- **选项D**：证书是 $\\langle p, a \\rangle$。这提供了比B更多的信息（最大幂 $a$），这些信息对于证明成员资格不是必需的。验证 $\\langle n, k \\rangle \\in \\bar{L}$ 只需要存在一个素因子 $p \\lt k$。\n\n- **选项E**：这个陈述是错误的。它混淆了找到证书的难度（计算 `FACTOR(n)`）和验证证书的难度。**NP** 的定义正是基于验证是容易的，即使寻找可能很难。\n\n在所有选项中，B是证明 $\\bar{L} \\in \\text{NP}$ 的最精确和最简约的描述。它提供了必要且充分的证书，并且验证是多项式时间的。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}