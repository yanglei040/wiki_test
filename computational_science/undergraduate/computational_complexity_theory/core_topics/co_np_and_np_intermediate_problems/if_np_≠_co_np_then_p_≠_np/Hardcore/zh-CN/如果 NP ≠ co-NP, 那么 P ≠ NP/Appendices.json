{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个练习将引导你完成该核心定理的基本证明。通过反证法，假设 $P=NP$ 和 $NP \\neq co-NP$ 同时成立，你将发现一个逻辑上的矛盾，从而证明原定理的正确性。这是理论计算机科学中的一个经典证明技巧，能够加深你对这些复杂性类定义的理解。",
            "id": "1427439",
            "problem": "在计算复杂性理论中，我们研究解决计算问题所需的资源。让我们考虑三个基本的复杂性类别：\n- **P (多项式时间):** 可由确定性图灵机在输入规模的多项式时间内解决的判定问题类。\n- **NP (非确定性多项式时间):** 对于一个“是”实例，其存在一个可以在多项式时间内被确定性图灵机验证的证书（或证明）的判定问题类。\n- **$\\text{co-NP}$:** 对于一个“否”实例，其存在一个可以在多项式时间内被验证的证书（或证明/反例）的判定问题类。等价地，一个问题 $L$ 属于 $\\text{co-NP}$ 当且仅当它的补集 $\\bar{L}$（其中“是”和“否”实例互换）属于 NP。\n\n考虑一个假设情景，其中给你以下两个假设为真：\n1.  $P = NP$\n2.  $NP \\neq \\text{co-NP}$\n\n基于这两个假设，以下哪个陈述是最准确的逻辑推论？\n\nA. P 类在补运算下不是闭合的。\nB. 这两个假设导致逻辑矛盾。\nC. $\\text{co-NP}$ 类必须是 NP 的真子集（即 $\\text{co-NP} \\subset NP$）。\nD. NP 类必须是 $\\text{co-NP}$ 的真子集（即 $NP \\subset \\text{co-NP}$）。\nE. 存在至少一个 NP 中的问题，其补集不在 NP 中。",
            "solution": "假设 $P = NP$ 且 $NP \\neq \\text{co-NP}$。\n\n首先，证明 P 在补运算下是闭合的。设 $L \\in P$。那么存在一个确定性图灵机 $M$ 和一个多项式 $p$，使得对于所有输入 $x$，$M$ 在时间 $p(|x|)$ 内判定 $x$ 是否属于 $L$。定义一个机器 $M'$，它在输入 $x$ 上运行 $M(x)$ 并翻转其接受/拒绝的决定。那么 $M'$ 在时间 $p(|x|)$ 内判定 $\\overline{L}$，因此 $\\overline{L} \\in P$。因此 P 在补运算下是闭合的，即 $P = \\text{co-P}$。\n\n从 $P = NP$，对两边取补集可得 $\\text{co-P} = \\text{co-NP}$。使用刚刚建立的 $P = \\text{co-P}$，我们有\n$$\nNP = P = \\text{co-P} = \\text{co-NP},\n$$\n所以 $NP = \\text{co-NP}$。\n\n这直接与假设 $NP \\neq \\text{co-NP}$ 相矛盾。因此，这两个假设一起是不一致的；它们导致了逻辑矛盾。\n\n评估各个选项：\n- A 是错误的，因为 P 在补运算下是闭合的。\n- B 是正确的，如上所示。\n- C 和 D 与 $P = NP$ 蕴含 $NP = \\text{co-NP}$ 不相容。\n- E 在 $P = NP$ 的假设下是错误的，因为此时 $NP = P$，并且 P 在补运算下是闭合的。\n\n因此，正确选项是 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "上一个练习的证明依赖于一个关键属性：$P$ 类在补集运算下是封闭的。为了理解这一属性的重要性，这个思想实验将让你思考一个假设情景：如果 $P$ 等于一个在补集运算下*不*封闭的类（如 $RE$），会发生什么？这个练习将帮助你理解为什么该证明结构对 $NP$ 有效，但可能不适用于其他复杂性类。",
            "id": "1427408",
            "problem": "在计算复杂性理论中，我们根据解决问题所需的资源来研究问题类别。设 P 是确定性图灵机在多项式时间内可解的判定问题类。设 RE（递归可枚举）是这样一类判定问题：对于其中任何‘是’实例，存在一台图灵机能保证在有限时间内停机并接受；但对于任何‘否’实例，该图灵机可能会永远运行。\n\n一个基本结论是，P 类对补运算是封闭的。这意味着如果一个语言 $L$ 属于 P，那么它的补集 $\\bar{L}$（所有不属于 $L$ 的字符串集合）也属于 P。相反，根据可计算性理论，一个已知事实是 RE 对补运算不封闭，这意味着 $\\text{RE} \\neq \\text{co-RE}$，其中 co-RE 是其补集属于 RE 的语言类。\n\n现在，考虑两个学生之间的一段假设性讨论，他们正试图理解这些类别之间的关系。\n\nAlice 声称：“$P = \\text{RE}$ 这个假设从一开始就是无稽之谈，因为我们知道 P 是 RE 的一个真子集。例如，停机问题属于 RE 但不属于 P。”\n\nBob 回答：“我同意在我们所知的世界里这是错误的，但作为一个思想实验，我们应该探究这个假设的逻辑*后果*。我相信，如果我们假设性地认定 $P = \\text{RE}$，那么逻辑上必然会得出 $\\text{RE} = \\text{co-RE}$。”\n\n你的任务是评估 Bob 的主张。以下哪个陈述提供了最准确的评估和推理？\n\nA. Bob 是正确的。P 类被定义为对补运算封闭。如果 RE 等于 P，它必然会继承 P 的所有属性，包括对补运算的封闭性。这将直接意味着 $\\text{RE} = \\text{co-RE}$。\nB. Bob 是错误的。对补运算不封闭是 RE 类的一个内在特征，源于其基于单向停机的定义。$P = \\text{RE}$ 这个假设性的等式无法改变定义 RE 的机器模型这一基本属性。\nC. Bob 是正确的，但原因很琐碎，与复杂性理论无关。他的主张是一个“若 A 则 B”形式的蕴涵式，其中前提 A ($P = \\text{RE}$) 已知为假。在形式逻辑中，任何前提为假的蕴涵式都被认为是‘空洞真理’(vacuously true)，无论结论 B 是什么。\nD. Bob 是错误的。如果 $P = \\text{RE}$，那么对于 co-RE 中的任何语言 $L$，其补集 $\\bar{L}$ 属于 RE，因此也属于 P。由于 P 对补运算封闭， $L$ 本身也必须属于 P，因此也属于 RE。这只证明了 co-RE 是 RE 的一个子集，而不能证明它们相等。\nE. Bob 的主张无法评估。前提 $P = \\text{RE}$ 与已确立的可计算性定理（例如，停机问题的不可判定性）直接矛盾，使得任何基于它的进一步逻辑推论都是不健全的。",
            "solution": "我们分析假设 $P=\\text{RE}$ 的逻辑后果。\n\n已知事实：\n- $P$ 对补运算封闭：对于任意语言 $L$，如果 $L \\in P$，则 $\\overline{L} \\in P$。\n- $\\text{co-RE}$ 的定义为 $\\text{co-RE}=\\{L : \\overline{L} \\in \\text{RE}\\}$。\n\n假设 $P=\\text{RE}$。那么，由于 $P$ 对补运算封闭，$\\text{RE}$ 也必定对补运算封闭，因为类的相等性会传递封闭性属性：\n- 设 $L \\in \\text{RE}$。则 $L \\in P$ （根据 $P=\\text{RE}$），所以 $\\overline{L} \\in P$ （$P$ 的封闭性），因此 $\\overline{L} \\in \\text{RE}$ （再次根据 $P=\\text{RE}$）。所以 $\\text{RE}$ 对补运算是封闭的。\n\n从 $\\text{RE}$ 对补运算的封闭性，我们可以得到两个包含关系，从而得出等式 $\\text{RE}=\\text{co-RE}$：\n- $\\text{RE} \\subseteq \\text{co-RE}$：如果 $L \\in \\text{RE}$，那么 $\\overline{L} \\in \\text{RE}$ （封闭性），因此根据定义 $L \\in \\text{co-RE}$。\n- $\\text{co-RE} \\subseteq \\text{RE}$：如果 $L \\in \\text{co-RE}$，那么 $\\overline{L} \\in \\text{RE}$。利用 $P=\\text{RE}$ 和 $P$ 的封闭性，我们有 $\\overline{L} \\in P$，因此 $L \\in P$，所以 $L \\in \\text{RE}$。\n\n因此，在 $P=\\text{RE}$ 的假设下，我们得出结论 $\\text{RE}=\\text{co-RE}$。这为一个实质性原因直接支持了 Bob 的主张：与一个对补运算封闭的类相等，会强制该类也具有封闭性，从而意味着它与其补类相等。\n\n评估选项：\n- A 正确地抓住了这一推理过程（撇开其表述中称封闭性是 P 的定义而非属性这一点）。它指出，如果 $\\text{RE}=P$ 且 $P$ 对补运算封闭，那么 $\\text{RE}$ 会继承对补运算的封闭性，这意味着 $\\text{RE}=\\text{co-RE}$。\n- B 是错误的，因为像对补运算的封闭性这样的属性是语言集合的属性；如果两个类作为集合是相等的，那么无论其机器模型的描述如何，它们都共享这些属性。\n- C 引用了空洞真理，但在这里，这个蕴涵式为真，是出于一个非平凡的结构性原因，而不仅仅是空洞地为真。\n- D 只证明了 $\\text{co-RE}\\subseteq \\text{RE}$，却忽略了从同一假设也能得出 $\\text{RE}\\subseteq \\text{co-RE}$；因此它是不完整的，其结论具有误导性。\n- E 是错误的：人们可以一致地分析一个与事实相反的假设的后果；没有任何矛盾会阻止我们得出有效的条件性结论。\n\n因此，最准确的评估是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在之前练习的基础上，我们现在从类比转向使用计算复杂性理论中的标准工具——预言机（oracles）——进行形式化论证。这个更具挑战性的问题将你带入一个“相对化世界”，其中 $P$ 的一个版本（$P^A$）在补集运算下不封闭。你将探索由此带来的后果，并直接证明如果没有这个基础属性，“$P=NP \\implies NP=co-NP$” 这一著名推论将不再成立。",
            "id": "1427443",
            "problem": "在计算复杂性理论中，一个语言（language）是代表某个判定问题（decision problem）的“是”实例的字符串集合。一个语言 $L$ 的补集，记作 $\\bar{L}$，由（在某个固定的字母表上）所有不在 $L$ 中的字符串组成。如果对于复杂性类 $C$ 中的每一个语言 $L$，它的补集 $\\bar{L}$ 也在 $C$ 中，那么我们就说 $C$ “对补运算封闭”（closed under complement）。\n\n对于一个给定的谕示（oracle）$A$（它是一个固定的字符串集合），我们可以定义相对化复杂性类（relativized complexity classes）。类 $P^A$ 包含所有可由一台能够访问谕示 $A$ 的确定性图灵机在多项式时间内判定的语言。类 $NP^A$ 包含所有可由一台能够访问谕示 $A$ 的非确定性图灵机在多项式时间内判定的语言。类 $\\text{co-NP}^A$ 被定义为所有满足其补集 $\\bar{L}$ 在 $NP^A$ 中的语言 $L$ 的集合。\n\n在标准的、非相对化的设定（即没有谕示）下，一个著名的定理指出，如果 P = NP，那么 NP = co-NP。这个定理的证明从根本上依赖于 P 类对补运算封闭这一事实。为了证明这个封闭性质对该证明逻辑是不可或缺的，我们考虑一个假设的谕示 $A$，它建立了一个该性质不成立的“相对化的世界”。\n\n假设给定一个谕示 $A$，关于它，以下两个陈述是已确立的事实：\n1. $P^A = NP^A$。\n2. 类 $P^A$ 不对补运算封闭。也就是说，存在至少一个语言 $L_0 \\in P^A$，其补集 $\\overline{L_0} \\notin P^A$。\n\n仅基于这两个前提假设，以下哪个结论是逻辑上必然的？请选择所有有效的选项。\n\nA. $NP^A = \\text{co-NP}^A$。\nB. $NP^A \\neq \\text{co-NP}^A$。\nC. $P^A = PSPACE^A$，其中 $PSPACE^A$ 是可由一台能访问谕示 $A$ 的确定性图灵机在多项式空间内判定的语言类。\nD. 对于任何语言 $L \\in NP^A$，其补集 $\\bar{L}$ 也在 $NP^A$ 中。\nE. 存在某个语言 $L_1 \\in \\text{co-NP}^A$ 使得 $L_1 \\notin P^A$。",
            "solution": "我们被给予以下两个前提：\n(1) $P^{A} = NP^{A}$。\n(2) $P^{A}$ 不对补运算封闭，即 $\\exists L_{0} \\in P^{A}$ 使得 $\\overline{L_{0}} \\notin P^{A}$。\n\n首先，我们结合 (1) 来推导 (2) 的一个结论。因为 $L_{0} \\in P^{A}$ 且根据 (1) 有 $P^{A} = NP^{A}$，所以我们得到 $L_{0} \\in NP^{A}$。根据 $\\text{co-NP}^{A}$ 的定义，一个语言 $L$ 在 $\\text{co-NP}^{A}$ 中，当且仅当其补集 $\\overline{L}$ 在 $NP^{A}$ 中。将此定义应用于 $L = \\overline{L_{0}}$，我们有 $\\overline{\\overline{L_{0}}} = L_{0} \\in NP^{A}$，因此 $\\overline{L_{0}} \\in \\text{co-NP}^{A}$。根据 (2)，$\\overline{L_{0}} \\notin P^{A}$。因此，存在一个语言在 $\\text{co-NP}^{A}$ 中但不在 $P^{A}$ 中，这使得选项 E 成为逻辑上必然的结论。\n\n接下来，分析选项 A。使用反证法，假设 $NP^{A} = \\text{co-NP}^{A}$。那么根据 (1)，有 $P^{A} = NP^{A} = \\text{co-NP}^{A}$。任取一个 $L \\in P^{A}$。由于 $P^{A} = \\text{co-NP}^{A}$，我们有 $L \\in \\text{co-NP}^{A}$，根据定义这意味着 $\\overline{L} \\in NP^{A}$。利用 $NP^{A} = P^{A}$，我们得到 $\\overline{L} \\in P^{A}$。因此 $P^{A}$ 将对补运算封闭，这与 (2) 矛盾。所以 $NP^{A} \\neq \\text{co-NP}^{A}$ 必须成立，这使得选项 B 成为逻辑上必然的结论，而选项 A 是错误的。\n\n选项 D 断言，对于每个 $L \\in NP^{A}$，都有 $\\overline{L} \\in NP^{A}$，即 $NP^{A}$ 对补运算封闭。根据 $\\text{co-NP}^{A}$ 的定义，这意味着 $NP^{A} = \\text{co-NP}^{A}$，这与我们已证明的必然结论 $NP^{A} \\neq \\text{co-NP}^{A}$ 相矛盾。因此 D 不是必然的，实际上在这些前提下它是错误的。\n\n选项 C 声稱 $P^{A} = PSPACE^{A}$。前提 (1) 和 (2) 没有对 $P^{A}$ (或 $NP^{A}$) 和 $PSPACE^{A}$ 之间的关系施加任何限制。存在一些相对化的世界，在其中 $P^{A} = NP^{A}$ 但 $P^{A} \\neq PSPACE^{A}$。因此 C 不是 (1) 和 (2) 的逻辑必然结果。\n\n总之，必须成立的结论是 B 和 E。",
            "answer": "$$\\boxed{BE}$$"
        }
    ]
}