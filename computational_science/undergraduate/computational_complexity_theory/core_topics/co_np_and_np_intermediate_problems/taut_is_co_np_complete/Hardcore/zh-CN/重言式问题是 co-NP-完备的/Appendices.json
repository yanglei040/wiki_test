{
    "hands_on_practices": [
        {
            "introduction": "理解TAUT问题复杂性的第一步是揭示其与著名的SAT问题之间的深刻联系。本练习将引导你探索一个基本的对偶关系：一个布尔范式是不可满足的，当且仅当其否定形式是一个重言式。掌握这一转换是证明TAUT为co-NP完全问题的基石。",
            "id": "1449002",
            "problem": "在计算复杂性理论中，要证明一个问题对于某个复杂性类是难的，通常需要从一个已知的难问题进行归约。该领域的一个基石是可满足性问题与重言式问题之间的关系。\n\n假设一个布尔公式 $\\phi$ 是以 3-合取范式（3-CNF）给出的。一个公式是 3-CNF 形式的，如果它是一些子句的合取（AND），其中每个子句是恰好三个不同文字（一个变量或其否定）的析取（OR）。\n\n如果一个布尔公式对于其变量的所有可能真值赋值都求值为假（False），则称该公式是**不可满足的**。判断一个 3-CNF 公式是否不可满足的问题被称为 3-UNSAT。\n如果一个布尔公式对于其变量的所有可能真值赋值都求值为真（True），则称该公式是**重言式**。判断一个公式是否为重言式的问题被称为 TAUT。\n\n你的任务是找到一个通用的变换，从任意一个 3-CNF 公式 $\\phi$ 构建一个新的公式 $\\psi$，使得 $\\phi$ 是不可满足的当且仅当 $\\psi$ 是一个重言式。下列哪个构造正确地定义了这样的 $\\psi$？\n\nA. $\\psi = \\phi$\n\nB. $\\psi = \\neg \\phi$\n\nC. 设 $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$，其中每个 $C_i$ 是一个子句。新公式是 $\\psi = (\\neg C_1) \\land (\\neg C_2) \\land \\dots \\land (\\neg C_k)$。\n\nD. 设 $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$，其中每个 $C_i$ 是一个子句。新公式是 $\\psi = C_1 \\lor C_2 \\lor \\dots \\lor C_k$。\n\nE. 设 $x$ 是出现在 $\\phi$ 中的一个布尔变量。新公式是 $\\psi = \\phi \\land (x \\lor \\neg x)$。",
            "solution": "我们寻求一个变换，对于任意给定的 3-CNF 公式 $\\phi$，该变换能生成一个公式 $\\psi$，使得 $\\phi$ 是不可满足的当且仅当 $\\psi$ 是一个重言式。\n\n设 $\\sigma$ 遍历 $\\phi$ 的变量的所有真值赋值。用 $\\phi[\\sigma]$ 表示 $\\phi$ 在赋值 $\\sigma$ 下的真值。根据定义：\n- $\\phi$ 是不可满足的，当且仅当 $\\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False}$。\n- $\\psi$ 是一个重言式，当且仅当 $\\forall \\sigma,\\ \\psi[\\sigma] = \\mathrm{True}$。\n\n考虑变换 $\\psi = \\neg \\phi$。否定运算的布尔语义对于每一个 $\\sigma$ 都满足：\n$$(\\neg \\phi)[\\sigma] = \\neg\\big(\\phi[\\sigma]\\big).$$\n因此，\n$$\\phi \\text{ 不可满足} \\iff \\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False} \\iff \\forall \\sigma,\\ \\neg\\big(\\phi[\\sigma]\\big) = \\mathrm{True} \\iff \\forall \\sigma,\\ (\\neg \\phi)[\\sigma] = \\mathrm{True} \\iff \\neg \\phi \\text{ 是一个重言式}。$$\n因此，正确的构造是 $\\psi = \\neg \\phi$，即选项 B。\n\n为了确认其他选项是不正确的：\n- A: $\\psi = \\phi$ 通常不能满足双向蕴含关系，因为一个不可满足的公式永远不是重言式。\n- C: 如果 $\\phi = \\bigwedge_{i=1}^{k} C_{i}$，那么根据德摩根定律 $\\psi = \\bigwedge_{i=1}^{k} \\neg C_{i} = \\neg\\big(\\bigvee_{i=1}^{k} C_{i}\\big)$，这不等于 $\\neg \\phi = \\bigvee_{i=1}^{k} \\neg C_{i}$；因此它没有实现所要求的等价关系。\n- D: $\\psi = \\bigvee_{i=1}^{k} C_{i}$ 并不会在 $\\phi$ 不可满足时恰好成为重言式；$\\phi$ 的不可满足性并不意味着每个赋值都使得至少一个 $C_i$ 为真，而这是该析取式成为重言式所必需的。\n- E: $\\psi = \\phi \\land (x \\lor \\neg x)$ 与 $\\phi$ 逻辑等价，因为 $x \\lor \\neg x$ 是一个重言式，所以它不能在 $\\phi$ 不可满足时恰好将任意 $\\phi$ 转换为重言式。\n\n因此，选项中唯一正确的变换是 $\\psi = \\neg \\phi$（选项 B）。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在掌握了不可满足性与重言式之间的联系后，我们需进一步理解如何严格地运用它来构建一个复杂性证明。本练习通过分析一个常见但有缺陷的论证，让你辨析多项式时间归约的精确定义，并理解为何从NP完全问题归约只能证明NP困难性，而非co-NP困难性。纠正这类错误是掌握计算复杂性证明艺术的关键一步。",
            "id": "1448966",
            "problem": "在一门计算复杂性理论课上，一位名叫 Alex 的学生试图证明重言式问题 (TAUT) 是 co-NP-hard 的。TAUT 问题是询问一个给定的布尔公式是否为重言式，即它对于其变量的所有可能真值赋值都为真。\n\nAlex 提出了以下论证：\n\n“我们通过提供一个从布尔可满足性问题 (SAT) 出发的多项式时间归约来证明 TAUT 是 co-NP-hard 的。SAT 问题是确定是否存在一个真值赋值，使得给定的布尔公式为真。这是一个著名的 NP-complete 问题。\n\n我的归约函数 $f$ 接受一个布尔公式 $\\phi$作为输入，并输出其否定式 $\\neg\\phi$。这个函数显然可以在多项式时间内计算。\n\n现在，考虑这个关系：一个公式 $\\phi$ 有一个满足的赋值（即 $\\phi \\in \\text{SAT}$），当且仅当其否定式 $\\neg\\phi$ 是一个重言式（即 $f(\\phi) \\in \\text{TAUT}$）。既然我已将一个 NP-complete 问题 (SAT) 归约到 TAUT，这就证明了 TAUT 至少和 NP 问题的补集一样难，这意味着 TAUT 是 co-NP-hard 的。”\n\n下列哪个陈述对 Alex 的论证提供了最准确的评价？\n\nA. Alex 的论证是正确的。函数 $f$ 是一个从 SAT 到 TAUT 的有效多项式时间归约，并且由于 SAT 是 NP-complete 的，这证明了 TAUT 是 co-NP-hard 的。\n\nB. Alex 的论证存在缺陷，因为函数 $f(\\phi) = \\neg \\phi$ 需要指数时间来计算，因为它需要评估公式的所有可能真值赋值。\n\nC. Alex 的论证存在缺陷，因为已知 TAUT 属于 P，所以它不可能是 co-NP-hard 的（除非 P = co-NP）。因此，该归约本身必定是无效的。\n\nD. Alex 的论证存在缺陷，因为他提出的从 SAT 到 TAUT 的归约只能证明 TAUT 是 NP-hard 的，而不是 co-NP-hard 的。然而，该归约本身是有效的。\n\nE. Alex 的论证存在缺陷，因为函数 $f(\\phi) = \\neg \\phi$ 并不是一个从 SAT 到 TAUT 的归约。归约的核心条件没有被满足。",
            "solution": "我们回顾一下多项式时间多一 (Karp) 归约的定义。对于语言 $A$ 和 $B$，如果函数 $f$ 在输入规模的多项式时间内可计算，并且对于所有输入 $x$ 都满足以下条件，则 $f$ 是一个从 $A$ 到 $B$ 的归约：\n$$\nx \\in A \\Leftrightarrow f(x) \\in B.\n$$\n要证明一个语言 $B$ 在 Karp 归约下是 co-NP-hard 的，必须将一个 co-NP-complete 语言归约到 $B$（或者更一般地说，co-NP 中的每个语言都可以归约到 $B$）。一个标准的 co-NP-complete 语言是 $\\text{UNSAT}=\\overline{\\text{SAT}}$。\n\n让我们精确地定义这些问题。对于一个布尔公式 $\\phi$：\n- $\\phi \\in \\text{SAT} \\Leftrightarrow \\exists a:\\ \\phi(a)=\\text{true}$。\n- $\\psi \\in \\text{TAUT} \\Leftrightarrow \\forall a:\\ \\psi(a)=\\text{true}$。\n- $\\phi \\in \\text{UNSAT} \\Leftrightarrow \\forall a:\\ \\phi(a)=\\text{false}$。\n\n考虑 $f(\\phi)=\\neg \\phi$。通过对公式进行句法上的否定，函数 $f$ 可以在 $\\phi$ 的规模的多项式时间内计算；不需要对赋值进行评估。\n\n现在分析一个有效归约必须满足的关键逻辑关系。对于所有的 $\\phi$ 和所有的赋值 $a$，\n$$\n\\phi(a)=\\text{true} \\Rightarrow \\neg \\phi(a)=\\text{false}.\n$$\n因此，\n$$\n\\phi \\in \\text{SAT} \\Rightarrow \\neg \\phi \\notin \\text{TAUT}.\n$$\n反之，如果 $\\neg \\phi$ 是一个重言式，那么对于所有的 $a$，$\\neg \\phi(a)=\\text{true}$，因此对于所有的 $a$，$\\phi(a)=\\text{false}$，所以\n$$\n\\neg \\phi \\in \\text{TAUT} \\Rightarrow \\phi \\in \\text{UNSAT}.\n$$\n综合起来，我们得到正确的等价关系：\n$$\n\\phi \\in \\text{UNSAT} \\Leftrightarrow \\neg \\phi \\in \\text{TAUT}.\n$$\n因此，$f(\\phi)=\\neg \\phi$ 是一个从 $\\text{UNSAT}$ 到 $\\text{TAUT}$ 的有效 Karp 归约，从而证明了 $\\text{TAUT}$ 是 co-NP-hard 的（实际上是 co-NP-complete 的）。\n\n然而，Alex 声称了错误的等价关系\n$$\n\\phi \\in \\text{SAT} \\Leftrightarrow \\neg \\phi \\in \\text{TAUT},\n$$\n如上所示，这是不成立的。正确的关系是\n$$\n\\phi \\in \\text{SAT} \\Leftrightarrow \\neg \\phi \\notin \\text{TAUT}.\n$$\n因此，所提出的 $f$ 并不是一个从 $\\text{SAT}$ 到 $\\text{TAUT}$ 的有效归约，Alex 的推理无法通过那条路径来证明 co-NP-hardness。此外，即使有一个从 $\\text{SAT}$ 到 $\\text{TAUT}$ 的有效归约，那最多也只能证明 $\\text{TAUT}$ 是 NP-hard 的，而不是 co-NP-hard 的；要证明 co-NP-hardness，需要从 co-NP 语言进行归约。\n\n评估各个选项：\n- A 是错误的，因为核心等价关系是错的，所以 $f$ 不是一个从 $\\text{SAT}$ 到 $\\text{TAUT}$ 的有效归约。\n- B 是错误的，因为 $f$ 可在多项式时间内计算；不需要指数时间的评估。\n- C 是错误的；$\\text{TAUT}$ 并不属于 P（它是 co-NP-complete 的）。\n- D 是错误的，因为它断言归约是有效的；由于等价关系不成立，它并非有效的。\n- E 是正确的：$f(\\phi)=\\neg \\phi$ 不满足从 $\\text{SAT}$ 归约到 $\\text{TAUT}$ 所需的条件。\n\n因此，最准确的评价是 E。",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "最后的练习将向你展示一种称为“搜索-判定归约”的强大技术。你将学习如何利用一个能解决TAUT判定问题的假设性“黑箱”（预言机），为一个非重言式的公式系统性地找出一个具体的反例（即一个证伪赋值）。这个过程将一个简单的“是/否”答案转化为一个构造性的解决方案，揭示了判定问题和搜索问题之间的深刻联系。",
            "id": "1448990",
            "problem": "在计算复杂性理论中，一个判定问题的预言机（oracle）是一个假设性的黑箱，它可以在单一步骤内解决该问题。考虑一个预言机 `IS_TAUT`，它可以确定一个给定的布尔公式是否为重言式。如果一个公式对于其变量的每一种可能的真值赋值都求值为真（True），那么它就是一个重言式。\n\n假设给定一个包含 $n$ 个变量的布尔公式 $\\phi(x_1, x_2, \\ldots, x_n)$，并且你知道 $\\phi$ *不是*一个重言式。这意味着至少存在一个“证伪赋值”——即一组特定的真/假（True/False）值——使得公式 $\\phi$ 的求值为假（False）。\n\n存在一个标准的多项式时间算法，在能够访问 `IS_TAUT` 预言机的情况下，可以找到一个这样的证伪赋值。该算法通过从 $x_1$ 到 $x_n$ 依次确定每个变量的真值来运作。为此，它通过为变量代入真值来构造新公式，并查询预言机以决定哪条路径保留了存在证伪赋值的可能性。\n\n考虑下面定义的具体布尔公式 $\\phi(x_1, x_2, x_3, x_4)$：\n$$ \\phi = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4) $$\n使用标准的搜索到判定归约算法，按照 $x_1, x_2, x_3, x_4$ 的顺序确定变量赋值，找出该算法针对此公式 $\\phi$ 输出的特定证伪赋值。在这个标准算法中，在确定变量 $x_i$ 的值的每一步，算法首先检查将 $x_i$ 设置为真（True）是否能找到一个证伪赋值。\n\n令真值 1 代表真（True），0 代表假（False）。最终答案应为一个包含四个数字的序列，代表 $(x_1, x_2, x_3, x_4)$ 的真值。",
            "solution": "目标是使用一个重言式问题（TAUT）的预言机来为给定的布尔公式 $\\phi$ 找到一个证伪赋值。证伪赋值是使 $\\phi$ 求值为假（0）的一组 $(x_1, x_2, x_3, x_4)$ 的真值。指定的算法按顺序确定 $x_1, x_2, x_3, x_4$ 的值。对于每个变量 $x_i$，它首先尝试设置 $x_i=1$（真）。它通过代入这个值来构造一个新公式，并询问 `IS_TAUT` 预言机所得公式是否为重言式。如果预言机回答 `False`，意味着存在一个 $x_i=1$ 的证伪赋值，因此我们固定 $x_i=1$。如果预言机回答 `True`，那么原公式的任何证伪赋值都必须有 $x_i=0$，因此我们固定 $x_i=0$。\n\n初始公式为 $\\phi_0(x_1, x_2, x_3, x_4) = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4)$。\n我们可以简化蕴含式：$x_2 \\implies x_4 \\equiv (\\neg x_2) \\lor x_4$。\n所以，$\\phi_0 = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor ((\\neg x_2) \\lor x_4)$。\n\n**步骤 1：确定 $x_1$ 的值。**\n我们尝试设置 $x_1=1$。新公式 $\\phi_1$ 是将 $x_1=1$ 代入 $\\phi_0$ 得到的：\n$$ \\phi_1(x_2, x_3, x_4) = ((\\neg 1) \\land x_2) \\lor (1 \\land (\\neg x_3)) \\lor ((\\neg x_2) \\lor x_4) $$\n$$ \\phi_1 = (0 \\land x_2) \\lor (\\neg x_3) \\lor ((\\neg x_2) \\lor x_4) $$\n$$ \\phi_1 = 0 \\lor (\\neg x_3) \\lor (\\neg x_2) \\lor x_4 $$\n$$ \\phi_1 = (\\neg x_2) \\lor (\\neg x_3) \\lor x_4 $$\n我们查询预言机：`IS_TAUT`($\\phi_1$)？公式 $\\phi_1$ 不是一个重言式。例如，如果 $x_2=1, x_3=1, x_4=0$，那么 $\\phi_1 = (\\neg 1) \\lor (\\neg 1) \\lor 0 = 0 \\lor 0 \\lor 0 = 0$。由于 $\\phi_1$ 存在证伪赋值，所以它不是重言式。\n预言机返回 `False`。\n因此，算法固定 $b_1 = 1$。我们用于后续步骤的工作公式是 $\\phi_1$。\n\n**步骤 2：确定 $x_2$ 的值。**\n我们当前的公式是 $\\phi_1(x_2, x_3, x_4) = (\\neg x_2) \\lor (\\neg x_3) \\lor x_4$。\n我们尝试设置 $x_2=1$。新公式 $\\phi_2$ 是将 $x_2=1$ 代入 $\\phi_1$ 得到的：\n$$ \\phi_2(x_3, x_4) = (\\neg 1) \\lor (\\neg x_3) \\lor x_4 $$\n$$ \\phi_2 = 0 \\lor (\\neg x_3) \\lor x_4 $$\n$$ \\phi_2 = (\\neg x_3) \\lor x_4 $$\n我们查询预言机：`IS_TAUT`($\\phi_2$)？公式 $\\phi_2$ 不是重言式，因为它在 $x_3=1, x_4=0$ 时为假。\n预言机返回 `False`。\n因此，算法固定 $b_2 = 1$。我们用于下一步骤的工作公式是 $\\phi_2$。\n\n**步骤 3：确定 $x_3$ 的值。**\n我们当前的公式是 $\\phi_2(x_3, x_4) = (\\neg x_3) \\lor x_4$。\n我们尝试设置 $x_3=1$。新公式 $\\phi_3$ 是将 $x_3=1$ 代入 $\\phi_2$ 得到的：\n$$ \\phi_3(x_4) = (\\neg 1) \\lor x_4 $$\n$$ \\phi_3 = 0 \\lor x_4 $$\n$$ \\phi_3 = x_4 $$\n我们查询预言机：`IS_TAUT`($\\phi_3$)？公式 $\\phi_3=x_4$ 不是重言式，因为它在 $x_4=0$ 时为假。\n预言机返回 `False`。\n因此，算法固定 $b_3 = 1$。我们现在的工作公式是 $\\phi_3$。\n\n**步骤 4：确定 $x_4$ 的值。**\n我们当前的公式是 $\\phi_3(x_4) = x_4$。\n我们尝试设置 $x_4=1$。新公式 $\\phi_4$ 是将 $x_4=1$ 代入 $\\phi_3$ 得到的：\n$$ \\phi_4 = 1 $$\n我们查询预言机：`IS_TAUT`($\\phi_4$)？公式 `1`（或真）恒为真，所以根据定义它是一个重言式。\n预言机返回 `True`。\n因为设置 $x_4=1$ 导致了重言式，所以 $\\phi_3$ 的任何证伪赋值都必须满足 $x_4 \\neq 1$。\n因此，算法固定 $b_4 = 0$。\n\n综合所有步骤的结果，算法找到的证伪赋值为 $(b_1, b_2, b_3, b_4) = (1, 1, 1, 0)$。\n\n让我们验证这个结果。\n$\\phi(1, 1, 1, 0) = ((\\neg 1) \\land 1) \\lor (1 \\land (\\neg 1)) \\lor (1 \\implies 0)$\n$= (0 \\land 1) \\lor (1 \\land 0) \\lor 0$\n$= 0 \\lor 0 \\lor 0$\n$= 0$\n该赋值正确地证伪了公式。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1  1  1  0 \\end{pmatrix}}$$"
        }
    ]
}