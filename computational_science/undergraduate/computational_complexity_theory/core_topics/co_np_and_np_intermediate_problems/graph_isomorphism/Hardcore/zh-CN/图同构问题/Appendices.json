{
    "hands_on_practices": [
        {
            "introduction": "判断两个图是否同构，一个常见的起点是检查它们的基本“不变量”——即在同构映射下保持不变的属性。最明显的不变量是顶点的数量和边的数量。然而，仅凭这些简单属性是否足以判定同构？这个练习将通过一个具体的反例，帮助你建立一个关键的直觉：拥有相同数量的顶点和边的图，其结构可能完全不同。",
            "id": "1507594",
            "problem": "在图论中，简单图是一个不含自环或重边的无权无向图。如果存在一个双射（一一对应）$f: V_A \\to V_B$，使得$V_A$中的任意两个顶点$u$和$v$相邻当且仅当$G_B$中的顶点$f(u)$和$f(v)$相邻，那么称两个简单图$G_A = (V_A, E_A)$和$G_B = (V_B, E_B)$是同构的。本质上，同构图在结构上是相同的，只是顶点的标签不同。\n\n一个常见的误解是，如果两个简单图具有相同数量的顶点（相同的阶）和相同数量的边（相同的大小），那么它们必然同构。你的任务是找出一个反例来证伪这一命题。\n\n考虑以下四个简单图，它们都定义在顶点集 $V = \\{1, 2, 3, 4, 5, 6\\}$ 上。\n\n-   图 $G_1 = (V, E_1)$，其中 $E_1 = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,6\\}, \\{6,1\\}\\}$。\n-   图 $G_2 = (V, E_2)$，其中 $E_2 = \\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}, \\{4,5\\}, \\{5,6\\}, \\{6,4\\}\\}$。\n-   图 $G_3 = (V, E_3)$，其中 $E_3 = \\{\\{1,3\\}, \\{3,5\\}, \\{5,2\\}, \\{2,4\\}, \\{4,6\\}, \\{6,1\\}\\}$。\n-   图 $G_4 = (V, E_4)$，其中 $E_4 = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,5\\}, \\{5,6\\}\\}$。\n\n下列哪对图为命题“如果两个简单图具有相同数量的顶点和相同数量的边，那么它们是同构的”提供了一个有效的反例？\n\nA. 图对 $(G_1, G_2)$\n\nB. 图对 $(G_1, G_3)$\n\nC. 图对 $(G_2, G_4)$\n\nD. 图对 $(G_1, G_4)$\n\nE. 图对 $(G_3, G_4)$",
            "solution": "我们使用图同构不变量：任何同构都必须保持顶点数、边数、度序列和连通分量数不变。\n\n首先，计算边数并注意其连通性。\n-   对于 $G_{1}$，其边构成一个6圈，所以 $|E_{1}|=6$，每个顶点的度为2，且该图是连通的（一个连通分量）。\n-   对于 $G_{2}$，其边构成两个不相交的3圈，所以 $|E_{2}|=6$，每个顶点的度为2，且该图是不连通的（两个连通分量）。\n-   对于 $G_{3}$，其边构成一个6圈（例如，圈 $1-3-5-2-4-6-1$），所以 $|E_{3}|=6$，每个顶点的度为2，且该图是连通的。\n-   对于 $G_{4}$，其边构成一个6个顶点的路径，所以 $|E_{4}|=5$，该图是连通的，度序列为 $\\{1,2,2,2,2,1\\}$。\n\n评估每个选项：\n- A: $(G_{1},G_{2})$ 具有相同数量的顶点和边（$|V|=6$, $|E|=6$），但 $G_{1}$ 是连通的，而 $G_{2}$ 是不连通的。由于连通性（连通分量的数量）是一个同构不变量，因此 $G_{1}$ 和 $G_{2}$ 不是同构的。这对图是一个有效的反例。\n- B: $(G_{1},G_{3})$ 都是6圈，因此它们是同构的；不是反例。\n- C, D, E: 每个选项都涉及 $G_{4}$，它有 $|E_{4}|=5$ 条边，而配对的另一个图有6条边。这些图对甚至不满足前提条件（具有相同数量的边），因此它们不能作为该命题的反例。\n\n因此，只有选项A提供了一个有效的反例。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当我们面对一般图同构问题的复杂性时，一个有效的策略是研究其在特定图类上的表现。对于树这种结构，同构问题实际上可以高效解决。这个练习介绍了一种为有根树生成“规范字符串标签”的递归算法，它为每棵树的结构提供了独一无二的指纹。通过亲手实现这个算法，你将理解如何利用图的特殊结构来设计精确且高效的同构测试方法。",
            "id": "1425700",
            "problem": "在一个新的针对层级式数据的数据压缩方案中，有根树被编码成一种唯一的字符串表示。这种“规范字符串标签”（Canonical String Label, CSL）是通过一个特定的递归过程生成的。该过程定义如下：\n\n1.  对于任何叶节点（没有子节点的节点），其 CSL 是字符串 `()`。\n2.  对于任何非叶节点 `v`，其 CSL 的构造方法是：首先收集其所有直接子节点的 CSL。然后将这些子节点的 CSL 按字典序（即标准字母顺序）排序。将排序后的字符串按顺序连接成一个单一的字符串 `S`。节点 `v` 的 CSL 则定义为 `(` 后跟 `S` 再后跟 `)`。\n\n考虑以下三棵有根树，它们由各自的节点集、根节点和边集定义。一条边 `(u, v)` 表示 `v` 是 `u` 的子节点。\n\n**树 T1：**\n*   根节点：`A`\n*   边：`{(A, B), (A, C), (B, D), (B, E), (C, F)}`\n\n**树 T2：**\n*   根节点：`P`\n*   边：`{(P, Q), (P, R), (Q, S), (R, T), (R, U)}`\n\n**树 T3：**\n*   根节点：`X`\n*   边：`{(X, Y), (Y, Z), (Z, W), (Z, V), (Y, U)}`\n\n根据 CSL 的生成过程，以下哪个陈述是正确的？\n\nA. 树 T1 和树 T2 各自根节点的 CSL 相同。\n\nB. 树 T2 和树 T3 各自根节点的 CSL 相同。\n\nC. 树 T1 和树 T3 各自根节点的 CSL 相同。\n\nD. 三棵树各自根节点的 CSL 都不同。\n\nE. 三棵树各自根节点的 CSL 都相同。",
            "solution": "为了解决这个问题，我们必须通过自底向上的方式应用给定的过程，计算出每棵树 T1、T2 和 T3 根节点的规范字符串标签（CSL）。\n\n**1. 树 T1 的 CSL**\n\n首先，我们根据边集 `{(A, B), (A, C), (B, D), (B, E), (C, F)}` 和根节点 `A` 来确定树 T1 的结构。\n- `A` 的子节点是 `B` 和 `C`。\n- `B` 的子节点是 `D` 和 `E`。\n- `C` 的子节点是 `F`。\n- 节点 `D`、`E` 和 `F` 没有子节点，所以它们是叶节点。\n\n现在，我们从叶节点开始计算 CSL。\n- 叶节点 `D`、`E` 和 `F` 的 CSL 都是 `()`。\n- 为了计算节点 `C` 的 CSL，我们取其唯一子节点 `F` 的 CSL，即 `()`。子节点 CSL 列表为 `[()]`。该列表已经排好序。连接后得到 `()`。所以，CSL(`C`) = `(())`。\n- 为了计算节点 `B` 的 CSL，我们取其子节点 `D` 和 `E` 的 CSL。两者都是 `()`。子节点 CSL 列表为 `[(), ()]`。该列表按字典序已经排好序。将它们连接后得到 `()()`。所以，CSL(`B`) = `(()())`。\n- 最后，为了计算根节点 `A` 的 CSL，我们取其子节点 `B` 和 `C` 的 CSL。我们有 CSL(`B`) = `(()())` 和 CSL(`C`) = `(())`。子节点 CSL 列表为 `[(()()), (())]`。\n- 我们必须按字典序对此列表进行排序。比较 `(())` 和 `(()())`，字符串 `(())` 排在前面，因为在第二个字符处，`)` 在 `(` 之前。排序后的列表是 `[(()), (()())]`。\n- 连接排序后的字符串得到 `(())` + `(()())` = `(())(()())`。\n- 因此，根节点 `A` 的 CSL 是 `((())(()()))`。\n\n**2. 树 T2 的 CSL**\n\n接下来，我们根据边集 `{(P, Q), (P, R), (Q, S), (R, T), (R, U)}` 和根节点 `P` 来分析树 T2。\n- `P` 的子节点是 `Q` 和 `R`。\n- `Q` 的子节点是 `S`。\n- `R` 的子节点是 `T` 和 `U`。\n- 节点 `S`、`T` 和 `U` 是叶节点。\n\n我们自底向上计算 CSL。\n- 叶节点 `S`、`T` 和 `U` 的 CSL 都是 `()`。\n- 为了计算节点 `Q` 的 CSL，我们取其子节点 `S` 的 CSL，即 `()`。CSL(`Q`) = `(())`。\n- 为了计算节点 `R` 的 CSL，我们取其子节点 `T` 和 `U` 的 CSL，两者都是 `()`。排序后的子节点 CSL 列表是 `[(), ()]`。连接后得到 `()()`。所以，CSL(`R`) = `(()())`。\n- 为了计算根节点 `P` 的 CSL，我们取其子节点 `Q` 和 `R` 的 CSL。我们有 CSL(`Q`) = `(())` 和 CSL(`R`) = `(()())`。子节点 CSL 列表为 `[(()), (()())]`。\n- 按字典序对此列表排序，得到 `[(()), (()())]`，与 T1 的情况相同。\n- 连接排序后的字符串得到 `(())` + `(()())` = `(())(()())`。\n- 因此，根节点 `P` 的 CSL 是 `((())(()()))`。\n\n**3. 树 T3 的 CSL**\n\n最后，我们根据边集 `{(X, Y), (Y, Z), (Z, W), (Z, V), (Y, U)}` 和根节点 `X` 来分析树 T3。\n- `X` 的子节点是 `Y`。\n- `Y` 的子节点是 `Z` 和 `U`。\n- `Z` 的子节点是 `W` 和 `V`。\n- 节点 `W`、`V` 和 `U` 是叶节点。\n\n我们自底向上计算 CSL。\n- 叶节点 `W`、`V` 和 `U` 的 CSL 都是 `()`。\n- 为了计算节点 `Z` 的 CSL，我们使用其子节点 `W` 和 `V`。它们的 CSL 是 `()` 和 `()`。排序后的列表是 `[(), ()]`。连接后得到 `()()`。所以，CSL(`Z`) = `(()())`。\n- 为了计算节点 `Y` 的 CSL，我们使用其子节点 `Z` 和 `U`。我们有 CSL(`Z`) = `(()())` 和 CSL(`U`) = `()`。子节点 CSL 列表为 `[(()()), ()]`。\n- 按字典序对此列表排序，`()` 在 `(()())` 之前。排序后的列表是 `[(), (()())]`。\n- 连接排序后的字符串得到 `()` + `(()())` = `()(()())`。\n- 所以，CSL(`Y`) = `(()(()()))`。\n- 为了计算根节点 `X` 的 CSL，我们取其唯一子节点 `Y` 的 CSL。列表为 `[(()(()()))]`。连接后得到 `()(()())`。\n- 因此，根节点 `X` 的 CSL 是 `((()(()())))`。\n\n**4. 比较与结论**\n\n让我们比较这三棵树的根节点的 CSL：\n- CSL(T1 根 `A`) = `((())(()()))`\n- CSL(T2 根 `P`) = `((())(()()))`\n- CSL(T3 根 `X`) = `((()(()())))`\n\n我们可以看到 CSL(T1) 与 CSL(T2) 完全相同，但 CSL(T3) 与前两者都不同。这意味着，根据这种规范表示，T1 和 T2 在结构上是等价的（作为有根树是同构的），而 T3 具有不同的结构。\n\n评估给定的选项：\nA. 树 T1 和树 T2 各自根节点的 CSL 相同。（正确）\nB. 树 T2 和树 T3 各自根节点的 CSL 相同。（错误）\nC. 树 T1 和树 T3 各自根节点的 CSL 相同。（错误）\nD. 三棵树各自根节点的 CSL 都不同。（错误）\nE. 三棵树各自根节点的 CSL 都相同。（错误）\n\n唯一正确的陈述是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "对于一般图，由于尚无已知的多项式时间算法，我们常常依赖于强大的启发式算法，例如Weisfeiler-Leman (WL) 测试。这个练习将让你应用一维WL测试，并让你发现一对经典的、它无法区分的非同构图。这个挑战性的任务揭示了图同构问题的精妙之处，并展示了即便是强大的启发式算法也存在的局限性，这正是该问题在计算复杂性理论中如此引人入胜的原因。",
            "id": "1425705",
            "problem": "1维Weisfeiler-Leman (WL)测试，也称为颜色细化算法，是一种用于测试图同构的启发式方法。该算法迭代地细化图的顶点着色。如果两个图产生不同的最终着色（具体来说，是每种最终颜色的顶点数量不同），则它们保证是非同构的。如果它们产生相同的最终着色，它们可能同构，但这并不保证。\n\n算法流程如下：\n1.  **初始化（迭代0）：**为图中每个顶点分配相同的初始颜色 $c_0$。\n2.  **细化（迭代 $k \\ge 1$）：**对于每个顶点 $v$，根据其邻居在前一次迭代 $k-1$ 中的颜色多重集计算一个签名。形式上，$v$ 的签名是多重集 $S_k(v) = \\{\\{ C_{k-1}(u) \\mid u \\text{ 是 } v \\text{ 的邻居} \\}\\}$。\n3.  **更新颜色：**所有具有相同签名 $S_k(v)$ 的顶点被分配相同的新颜色 $C_k(v)$。具有不同签名的顶点被分配不同的新颜色。一种常见的分配新颜色的方法是将每个唯一的签名字符串映射到一个新的唯一颜色标签。\n4.  **终止：**当顶点到颜色类的划分在连续两次迭代之间不再改变时，算法终止。也就是说，如果在步骤 $k$ 时每个颜色类中的顶点数量与步骤 $k-1$ 时相同，则算法已稳定。\n\n一个图的“最终颜色签名”是其所有顶点的最终颜色的多重集。\n\n考虑两个3-正则图 $G_A$ 和 $G_B$，每个图都有6个顶点，标记为 $\\{1, 2, 3, 4, 5, 6\\}$。\n-   **图 $G_A$** 的边集为 $E_A = \\{(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)\\}$。\n-   **图 $G_B$** 的边集为 $E_B = \\{(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (1, 4), (2, 5), (3, 6)\\}$。\n\n对 $G_A$ 和 $G_B$ 应用1维WL测试。根据算法的结果和图的性质，以下哪个陈述是正确的？\n\nA. 算法为两个图生成了相同的最终颜色签名，证明它们是同构的。\n\nB. 算法为两个图生成了不同的最终颜色签名，证明它们是非同构的。\n\nC. 算法为两个图生成了相同的最终颜色签名，但这个结果对于它们的同构性是不确定的。事实上，这两个图是非同构的。\n\nD. 算法为两个图生成了相同的最终颜色签名，但这个结果对于它们的同构性是不确定的。事实上，这两个图是同构的。\n\nE. 算法对于至少一个图无法终止。",
            "solution": "我们将1维Weisfeiler-Leman (WL)颜色细化算法应用于两个图，从统一的初始着色开始。\n\n初始化（迭代0）：每个图中的每个顶点都获得相同的初始颜色，记为 $c_{0}$。因此，对于每个图，划分是一个大小为6的单一颜色类。\n\n在迭代 $k=1$ 时的细化：对于任一图中的任意顶点 $v$，其签名是其邻居在迭代 $k-1$ 时的颜色多重集。在 $G_{A}$ 和 $G_{B}$ 中，每个顶点的度都为3（两者都是3-正则图）。由于在迭代0时，每个顶点的所有邻居都具有颜色 $c_{0}$，所以每个顶点的签名是\n$$\nS_{1}(v)=\\{c_{0},c_{0},c_{0}\\}.\n$$\n所有顶点共享相同的签名，因此它们在迭代1时被分配相同的新颜色。将此颜色记为 $c_{1}$。因此，对于每个图，所有顶点 $v$ 都有 $C_{1}(v)=c_{1}$，并且划分仍然是一个大小为6的单一颜色类。\n\n在迭代 $k=2$ 时的细化与终止：重复同样的推理，在迭代1时所有顶点都具有相同的颜色 $c_{1}$，所以对于每个顶点 $v$，\n$$\nS_{2}(v)=\\{c_{1},c_{1},c_{1}\\}.\n$$\n同样，在迭代2时所有顶点都获得相同的颜色。因此，划分在迭代1和迭代2之间没有变化，算法稳定。每个图的最终颜色签名是由一个单一颜色重复6次组成的多重集，即 $\\{c^{*},c^{*},c^{*},c^{*},c^{*},c^{*}\\}$，其中 $c^{*}$ 是稳定后的颜色（例如 $c_{1}$）。\n\n关于WL结果的结论：该算法为 $G_{A}$ 和 $G_{B}$ 生成了相同的最终颜色签名。\n\n图同构状态：尽管WL签名相同，$G_{A}$ 和 $G_{B}$ 却不是同构的。图 $G_{A}$ 是完全二分图 $K_{3,3}$，它是二分图，因此不包含奇数长度的环。图 $G_{B}$ 包含一个3-环，例如由边 $(1,2),(2,3),(3,1)$ 构成的顶点 $\\{1,2,3\\}$ 上的环，因此它不是二分图。二分性是同构不变量，所以二分图不可能与非二分图同构。因此，$G_{A}$ 和 $G_{B}$ 是非同构的。\n\n综上所述，正确的陈述是，算法为两个图生成了相同的最终颜色签名，但这对于判断同构性是不确定的；事实上，这两个图是非同构的。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}