{
    "hands_on_practices": [
        {
            "introduction": "Before we can use a SAT solver, we must translate our problem into its required language: Conjunctive Normal Form (CNF). This exercise guides you through a fundamental conversion process, turning a common logical structure—equivalent to a basic circuit gate—into the set of CNF clauses that a SAT solver can understand. Mastering this technique is the first step to modeling complex systems as SAT instances. ",
            "id": "1462173",
            "problem": "In computational logic, converting arbitrary logical formulas into a standardized format is a crucial first step for many algorithms, particularly those designed to solve the Boolean satisfiability problem. One of the most common standard formats is the Conjunctive Normal Form (CNF).\n\nA formula is in CNF if it is a conjunction (AND, denoted by $\\land$) of one or more clauses, where a clause is a disjunction (OR, denoted by $\\lor$) of one or more literals. A literal is either a variable (e.g., $x$) or its negation (e.g., $\\neg x$).\n\nConsider the logical equivalence statement $z \\leftrightarrow (x \\land y)$. This type of statement is a fundamental building block when encoding complex logical circuits into a format suitable for a CNF-based solver. Your task is to convert this statement into a logically equivalent set of clauses.\n\nWhich of the following sets of clauses is logically equivalent to the expression $z \\leftrightarrow (x \\land y)$?\n\nA. $\\{ (\\neg x \\lor z), (\\neg y \\lor z), (\\neg z \\lor x \\lor y) \\}$\nB. $\\{ (\\neg x \\lor \\neg y \\lor z), (\\neg z \\lor x), (\\neg z \\lor y) \\}$\nC. $\\{ (x \\lor y \\lor \\neg z), (z \\lor \\neg x), (z \\lor \\neg y) \\}$\nD. $\\{ (\\neg x \\lor z), (\\neg y \\lor z), (\\neg z \\lor x), (\\neg z \\lor y) \\}$\nE. $\\{ (\\neg x \\lor \\neg y \\lor z) \\}$",
            "solution": "The goal is to convert the logical expression $z \\leftrightarrow (x \\land y)$ into an equivalent Conjunctive Normal Form (CNF). This involves transforming the expression into a conjunction of clauses, where each clause is a disjunction of literals.\n\nStep 1: Expand the biconditional.\nThe biconditional operator $A \\leftrightarrow B$ is logically equivalent to $(A \\rightarrow B) \\land (B \\rightarrow A)$.\nApplying this to our expression, we get:\n$$ (z \\rightarrow (x \\land y)) \\land ((x \\land y) \\rightarrow z) $$\n\nStep 2: Convert implications to disjunctions.\nThe implication operator $A \\rightarrow B$ is logically equivalent to $\\neg A \\lor B$. We apply this rule to both parts of our expression.\nFor the first part, $(z \\rightarrow (x \\land y))$, we get:\n$$ \\neg z \\lor (x \\land y) $$\nFor the second part, $((x \\land y) \\rightarrow z)$, we get:\n$$ \\neg(x \\land y) \\lor z $$\nCombining these, the full expression is now:\n$$ (\\neg z \\lor (x \\land y)) \\land (\\neg(x \\land y) \\lor z) $$\n\nStep 3: Apply De Morgan's Law.\nThe expression is a conjunction of two terms. Let's analyze each term to ensure it is in clause form (a disjunction of literals).\nThe second term, $\\neg(x \\land y) \\lor z$, contains a negation over a conjunction. We use De Morgan's Law, which states that $\\neg(A \\land B) \\equiv (\\neg A \\lor \\neg B)$.\nApplying this, the second term becomes:\n$$ (\\neg x \\lor \\neg y) \\lor z $$\nSince the $\\lor$ operator is associative, we can write this as a single clause:\n$$ (\\neg x \\lor \\neg y \\lor z) $$\n\nStep 4: Apply the Distributive Law.\nThe first term, $\\neg z \\lor (x \\land y)$, contains a conjunction within a disjunction. This is not a valid clause. We must use the distributive law, which states that $A \\lor (B \\land C) \\equiv (A \\lor B) \\land (A \\lor C)$.\nLet $A = \\neg z$, $B = x$, and $C = y$. Applying the law, the first term becomes:\n$$ (\\neg z \\lor x) \\land (\\neg z \\lor y) $$\nThis expression is a conjunction of two valid clauses: $(\\neg z \\lor x)$ and $(\\neg z \\lor y)$.\n\nStep 5: Combine the results.\nNow, we substitute the converted forms back into the main expression from Step 2.\nThe original expression is equivalent to:\n$$ ((\\neg z \\lor x) \\land (\\neg z \\lor y)) \\land (\\neg x \\lor \\neg y \\lor z) $$\nThis is a conjunction of three clauses. The set of clauses is therefore:\n$$ \\{ (\\neg z \\lor x), (\\neg z \\lor y), (\\neg x \\lor \\neg y \\lor z) \\} $$\n\nStep 6: Match with the given options.\nWe compare our resulting set of clauses with the provided options. The set $\\{ (\\neg z \\lor x), (\\neg z \\lor y), (\\neg x \\lor \\neg y \\lor z) \\}$ matches option B, noting that the order of clauses in a set and the order of literals in a clause do not matter.\n\nTherefore, the correct option is B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "The power of SAT lies in its ability to model real-world constraints, and this practice demonstrates how to translate rules from a practical scenario into a special, efficiently solvable variant called 2-SAT. You will learn how each constraint transforms into logical clauses and then into a network of implications. This process is key to understanding the structure that makes 2-SAT problems computationally tractable. ",
            "id": "1462201",
            "problem": "A university is designing an automated course registration system. To ensure students meet prerequisites and avoid conflicts, the system must satisfy a set of logical constraints. For a particular student, let the Boolean variables $A$, $B$, and $C$ represent enrollment in courses 'Advanced Algorithms', 'Bioinformatics', and 'Compilers', respectively. A variable is true if the student enrolls in the course and false otherwise. The registration constraints are as follows:\n\n1.  A student cannot enroll in both 'Advanced Algorithms' and 'Bioinformatics' in the same semester due to a time conflict.\n2.  If a student enrolls in 'Advanced Algorithms', they must also enroll in 'Compilers' as a co-requisite.\n3.  A student must enroll in at least one of 'Bioinformatics' or 'Compilers'.\n\nThese constraints can be modeled as a 2-Satisfiability (2-SAT) problem. In a 2-SAT problem, each logical clause of the form $(L_1 \\vee L_2)$, where $L_1$ and $L_2$ are literals (a variable or its negation), is equivalent to a pair of implications: $(\\neg L_1 \\implies L_2)$ and $(\\neg L_2 \\implies L_1)$. The collection of all such implications derived from all clauses in a formula is used to construct an implication graph.\n\nWhich of the following sets of implications correctly and completely represents the given registration constraints?\n\nA. { $A \\implies \\neg B$, $B \\implies \\neg A$, $A \\implies C$, $\\neg C \\implies \\neg A$, $\\neg B \\implies C$, $\\neg C \\implies B$ }\nB. { $A \\implies \\neg B$, $A \\implies C$, $\\neg B \\implies C$ }\nC. { $\\neg A \\implies B$, $\\neg B \\implies A$, $\\neg A \\implies C$, $C \\implies A$, $B \\implies C$, $C \\implies B$ }\nD. { $\\neg B \\implies A$, $\\neg A \\implies B$, $C \\implies A$, $\\neg A \\implies \\neg C$, $C \\implies \\neg B$, $B \\implies \\neg C$ }",
            "solution": "We define Boolean variables $A$, $B$, and $C$ for enrollment in 'Advanced Algorithms', 'Bioinformatics', and 'Compilers', respectively. Translate each constraint into a 2-CNF clause and then into implications using the 2-SAT rule that $(L_1 \\vee L_2)$ is equivalent to $(\\neg L_1 \\implies L_2)$ and $(\\neg L_2 \\implies L_1)$.\n\nConstraint 1: A student cannot enroll in both $A$ and $B$. This is $\\neg(A \\wedge B)$, which is equivalent by De Morgan's law to $(\\neg A \\vee \\neg B)$. Let $L_1=\\neg A$ and $L_2=\\neg B$. The implications are:\n$$\\neg(\\neg A) \\implies \\neg B \\;\\;\\Longleftrightarrow\\;\\; A \\implies \\neg B,$$\n$$\\neg(\\neg B) \\implies \\neg A \\;\\;\\Longleftrightarrow\\;\\; B \\implies \\neg A.$$\n\nConstraint 2: If $A$ then $C$, i.e., $A \\implies C$, which is equivalent to $(\\neg A \\vee C)$. Let $L_1=\\neg A$ and $L_2=C$. The implications are:\n$$\\neg(\\neg A) \\implies C \\;\\;\\Longleftrightarrow\\;\\; A \\implies C,$$\n$$\\neg C \\implies \\neg A.$$\n\nConstraint 3: At least one of $B$ or $C$: $(B \\vee C)$. Let $L_1=B$ and $L_2=C$. The implications are:\n$$\\neg B \\implies C,$$\n$$\\neg C \\implies B.$$\n\nCollecting all implications gives the set\n$$\\{\\,A \\implies \\neg B,\\; B \\implies \\neg A,\\; A \\implies C,\\; \\neg C \\implies \\neg A,\\; \\neg B \\implies C,\\; \\neg C \\implies B\\,\\},$$\nwhich matches option A exactly. Option B omits necessary contraposed implications and is incomplete. Option C corresponds to $(A \\vee B)$, $(A \\vee C)$, and $(\\neg B \\vee \\neg C)$, which do not represent the original constraints. Option D similarly does not match the required clauses and introduces implications inconsistent with the constraints.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Why is 3-SAT considered a \"hard\" problem? This exercise provides a hands-on demonstration by exploring the behavior of a simple, intuitive solving algorithm—a greedy local search. You will discover how such an algorithm can become \"trapped\" in a solution that appears optimal locally but is not a true solution, illustrating the rugged landscape of the search space and hinting at why more sophisticated methods are necessary to solve large SAT instances. ",
            "id": "1462193",
            "problem": "A Boolean formula is in Conjunctive Normal Form (CNF) if it is a conjunction (AND, represented by $\\land$) of one or more clauses, where each clause is a disjunction (OR, represented by $\\lor$) of literals. A literal is a Boolean variable or its negation. A 3-SAT instance is a Boolean formula in 3-CNF, where every clause contains exactly three literals over a set of variables $\\{x_1, x_2, \\dots, x_n\\}$. An assignment is a mapping of each variable to a value in $\\{\\text{true}, \\text{false}\\}$. An assignment satisfies a formula if it makes the formula evaluate to true. A 3-SAT instance is satisfiable if there exists at least one satisfying assignment.\n\nConsider a greedy local search algorithm, which we will call Greedy Single-Flip Ascent, designed to find a satisfying assignment for a 3-SAT instance. The algorithm proceeds as follows:\n1.  Start with a given initial assignment of truth values to the variables.\n2.  At each step, calculate the number of satisfied clauses. Then, consider all possible new assignments that can be reached by flipping the value of a single variable.\n3.  If any single flip results in a strictly greater number of satisfied clauses, choose the flip that leads to the largest increase. If there's a tie, any of the best flips can be chosen. The algorithm then moves to this new assignment and repeats from step 2.\n4.  If no single flip can increase the number of satisfied clauses, the algorithm terminates. The assignment at termination is called a local optimum.\n\nA global optimum is an assignment that satisfies all clauses of the formula. Your task is to identify a scenario where the Greedy Single-Flip Ascent algorithm becomes trapped in a local optimum that is not a global optimum.\n\nWhich of the following options correctly specifies a tuple $(\\phi, A_{start}, A_{local})$, where $\\phi$ is a satisfiable 3-SAT instance over three variables $\\{x_1, x_2, x_3\\}$, $A_{start}$ is an initial assignment, and $A_{local}$ is a local optimum in which the algorithm gets trapped, with $A_{local}$ not being a global optimum? We represent an assignment for $(x_1, x_2, x_3)$ as a 3-bit string, where the $i$-th bit is 1 for true and 0 for false.\n\nA. $\\phi = \\{ (x_1 \\lor x_1 \\lor x_2), (\\neg x_1 \\lor \\neg x_1 \\lor \\neg x_1), (\\neg x_2 \\lor \\neg x_2 \\lor \\neg x_3) \\}$, $A_{start} = 000$, $A_{local} = 000$\nB. $\\phi = \\{ (x_1 \\lor x_2 \\lor \\neg x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3) \\}$, $A_{start} = 000$, $A_{local} = 000$\nC. $\\phi = \\{ (x_1 \\lor x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (x_1 \\lor x_2 \\lor \\neg x_3) \\}$, $A_{start} = 000$, $A_{local} = 000$\nD. $\\phi = \\{ (x_1 \\lor x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (x_1 \\lor x_2 \\lor \\neg x_3) \\}$, $A_{start} = 100$, $A_{local} = 100$",
            "solution": "We must find an option where the given formula $\\phi$ is satisfiable, the algorithm starting from $A_{start}$ reaches a local optimum $A_{local}$ where no single-variable flip increases the number of satisfied clauses, and $A_{local}$ is not a global optimum (i.e., it does not satisfy all clauses).\n\nAnalyze option A: $\\phi = \\{(x_1 \\lor x_1 \\lor x_2), (\\neg x_1 \\lor \\neg x_1 \\lor \\neg x_1), (\\neg x_2 \\lor \\neg x_2 \\lor \\neg x_3)\\}$, $A_{start}=000$, $A_{local}=000$.\nSimplify clauses: $(x_1 \\lor x_1 \\lor x_2) \\equiv (x_1 \\lor x_2)$, $(\\neg x_1 \\lor \\neg x_1 \\lor \\neg x_1) \\equiv \\neg x_1$, $(\\neg x_2 \\lor \\neg x_2 \\lor \\neg x_3) \\equiv (\\neg x_2 \\lor \\neg x_3)$. The instance is satisfiable, e.g., $010$ satisfies all three. Evaluate at $000$: clause satisfaction counts to $2$. Consider single flips from $000$: flipping $x_2$ gives $010$ which satisfies $3$ clauses. Hence a strictly improving flip exists, so $000$ is not a local optimum. Therefore A is invalid.\n\nAnalyze option B: $\\phi = \\{(x_1 \\lor x_2 \\lor \\neg x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3)\\}$, $A_{start}=000$, $A_{local}=000$.\nAt $000$, each clause evaluates true: $(0\\lor 0\\lor 1)$, $(0\\lor 1\\lor 0)$, $(1\\lor 0\\lor 0)$, so all $3$ are satisfied. Thus $000$ is a global optimum, contradicting the requirement that $A_{local}$ not be a global optimum. Therefore B is invalid.\n\nAnalyze option C: $\\phi = \\{(x_1 \\lor x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (x_1 \\lor x_2 \\lor \\neg x_3)\\}$, $A_{start}=000$, $A_{local}=000$.\nFirst, $\\phi$ is satisfiable; for example, $111$ satisfies all four clauses. Evaluate at $000$: the first clause $(x_1 \\lor x_2 \\lor x_3)$ is false, while the other three $(\\neg x_1 \\lor x_2 \\lor x_3)$, $(x_1 \\lor \\neg x_2 \\lor x_3)$, $(x_1 \\lor x_2 \\lor \\neg x_3)$ are true, so exactly $3$ clauses are satisfied. Check all single flips:\n- Flip $x_1$ to $100$: clauses satisfied are $3$ (the second clause becomes false, the other three true).\n- Flip $x_2$ to $010$: clauses satisfied are $3$ (the third clause becomes false, the other three true).\n- Flip $x_3$ to $001$: clauses satisfied are $3$ (the fourth clause becomes false, the other three true).\nNo single flip increases the count beyond $3$, so $000$ is a local optimum. Since it does not satisfy all clauses, it is not a global optimum. Starting from $A_{start}=000$, the algorithm immediately terminates at this local optimum. Therefore C satisfies all requirements.\n\nAnalyze option D: same $\\phi$ as in C, $A_{start}=100$, $A_{local}=100$.\nAt $100$, $3$ clauses are satisfied. Flipping $x_2$ to $110$ yields all $4$ clauses satisfied, which strictly increases the count. Therefore $100$ is not a local optimum, so D is invalid.\n\nHence the correct option is C.",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}