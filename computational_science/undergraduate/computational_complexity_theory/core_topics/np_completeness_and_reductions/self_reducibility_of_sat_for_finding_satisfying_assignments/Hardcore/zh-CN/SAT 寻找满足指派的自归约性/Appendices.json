{
    "hands_on_practices": [
        {
            "introduction": "理解自可约性（self-reducibility）等理论概念的最佳方式是将其付诸实践。这个练习提供了一个理想化的场景，其中有一个特殊的“承诺SAT”预言机，它只在输入公式保证是唯一可满足或不可满足时才能正常工作。这个练习旨在帮助您分离并实践通过迭代固定变量来揭示唯一解的核心逻辑，从而为更复杂的问题打下坚实的基础。",
            "id": "1447134",
            "problem": "一位计算机科学家 Ada 正在使用一种作为神谕机（oracle）的特殊计算设备。这个神谕机被设计用来解决布尔可满足性问题（SAT）的一个承诺（promise）版本。它接受一个布尔公式作为输入，并有一个严格的承诺：该公式要么是不可满足的，要么恰好只有一个满足赋值。\n- 如果输入的公式是不可满足的，神谕机输出 `FALSE`。\n- 如果输入的公式有唯一的满足赋值，神谕机输出 `TRUE`。\n对于任何具有多于一个满足赋值的公式，神谕机的行为是未定义的。\n\n如果一个布尔公式是一个或多个子句的逻辑与（AND），其中每个子句是一个或多个文字（literal）的逻辑或（OR），则该公式处于合取范式（CNF）中。一个文字是一个变量或其否定。一个满足赋值是为变量赋上一组特定的 `TRUE`/`FALSE` 值，使得整个公式的求值为 `TRUE`。\n\nAda 得到了一个关于三个布尔变量 $x_1, x_2, x_3$ 的 CNF 公式 $\\Phi_0$：\n$$ \\Phi_0 = (x_1) \\land (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2) \\land (\\neg x_1 \\lor x_3) $$\n她得到保证，$\\Phi_0$ 恰好有一个满足赋值。她的目标是通过向神谕机进行一系列查询来确定这个唯一的赋值。\n\n描述一个使用神谕机找到 $\\Phi_0$ 唯一满足赋值的过程，并确定这个赋值。将你的答案表示为一个单行矩阵，按顺序表示 $(x_1, x_2, x_3)$ 的值，其中 `1` 代表 `TRUE`，`0` 代表 `FALSE`。",
            "solution": "我们有一个用于承诺问题的神谕机，对于任何保证是不可满足的或恰好有一个满足赋值的输入公式，它在后一种情况下输出 TRUE，在前一种情况下输出 FALSE；否则其行为是未定义的。原始公式\n$$\n\\Phi_0 = (x_1) \\land (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2) \\land (\\neg x_1 \\lor x_3)\n$$\n被承诺恰好有一个满足赋值。\n\n使用神谕机确定唯一赋值的一般过程：\n按顺序对每个变量 $x_i$ 进行处理，维持到目前为止已固定的部分赋值。为确定 $x_i$ 的值，将当前的部分赋值与 $x_i$ 合取构成一个新公式，然后用这个新公式对神谕机进行一次查询。如果神谕机返回 TRUE，则设 $x_i=1$；如果返回 FALSE，则设 $x_i=0$。这个过程在每一步都遵守了承诺，因为既然 $\\Phi_0$ 有一个唯一的满足赋值 $a$，那么对于任何被测试的变量 $x_i$，两种可能性 $x_i=1$ 或 $x_i=0$ 中，恰好有一个与 $a$ 一致。被测试的公式要么是唯一可满足的（如果测试值与 $a_i$ 匹配），要么是不可满足的（如果不匹配）。\n\n将此过程应用于 $\\Phi_0$：\n\n1) 确定 $x_1$。向神谕机查询\n$$\nF_1 \\equiv \\Phi_0 \\land x_1.\n$$\n由于 $\\Phi_0$ 包含子句 $(x_1)$，任何满足赋值都必须有 $x_1=1$，因此 $F_1$ 恰好有一个满足赋值。所以神谕机返回 TRUE，我们设定 $x_1=1$。\n\n2) 在 $x_1=1$ 的条件下确定 $x_2$。向神谕机查询\n$$\nF_2 \\equiv \\Phi_0 \\land x_1 \\land x_2.\n$$\n在 $x_1=1$ 和 $x_2=1$ 的情况下，子句 $(\\neg x_1 \\lor \\neg x_2)$ 的求值为 $0$，因此 $F_2$ 是不可满足的。所以神谕机返回 FALSE，我们设定 $x_2=0$。\n\n3) 在 $x_1=1$ 和 $x_2=0$ 的条件下确定 $x_3$。向神谕机查询\n$$\nF_3 \\equiv \\Phi_0 \\land x_1 \\land \\neg x_2 \\land x_3.\n$$\n在 $x_1=1, x_2=0, x_3=1$ 的条件下评估每个子句：\n- $(x_1)$ 变为 $1$，\n- $(x_1 \\lor x_2)$ 变为 $1 \\lor 0 = 1$，\n- $(\\neg x_1 \\lor \\neg x_2)$ 变为 $0 \\lor 1 = 1$，\n- $(\\neg x_1 \\lor x_3)$ 变为 $0 \\lor 1 = 1$。\n因此 $F_3$ 是可满足的，并且根据唯一性承诺，它恰好有一个满足赋值，所以神谕机返回 TRUE。因此 $x_3=1$。\n\n因此，唯一的满足赋值是 $(x_1,x_2,x_3)=(1,0,1)$。",
            "answer": "$$\\boxed{\\begin{pmatrix}1  0  1\\end{pmatrix}}$$"
        },
        {
            "introduction": "掌握了基本技术后，我们来探讨其灵活性。在许多实际问题中，除了标准的布尔约束外，还可能存在额外的要求。这个问题引入了标准SAT公式之外的成对不等式约束。解决此问题的关键在于学习如何将这些新规则“翻译”成合取范式（CNF）的语言，从而有效地将一个新问题归约为我们已经知道如何用预言机解决的问题。",
            "id": "1447152",
            "problem": "在计算复杂性理论中，布尔可满足性问题（SAT）是一个基础问题。给定一个合取范式（CNF）的布尔公式，该问题旨在确定是否存在对其变量的一组真值（真/假）赋值，使得整个公式的计算结果为真。\n\nSAT的一个关键特性是其自可约性。这个特性意味着，如果我们有一个可以解决判定问题（即对一个公式是否可满足回答“是”或“否”）的“黑箱”预言机，我们就可以用这个预言机为任何可满足的公式找到一个实际的满足赋值。标准算法的流程如下：对于一个具有变量 $x_1, x_2, \\ldots, x_n$ 的可满足公式 $\\phi$，它迭代地确定每个变量的值。为了找到 $x_1$ 的值，它询问预言机，将 $x_1$ 设为“真”后公式 $\\phi$ 是否可满足。如果是，我们就固定 $x_1 = \\text{True}$；否则，我们必须固定 $x_1 = \\text{False}$。对 $x_2, x_3, \\ldots, x_n$ 重复此过程，在每一步中代入已找到的变量的值。\n\n考虑SAT的一个变体，我们称之为 `UNEQUAL-SAT`。在一个 `UNEQUAL-SAT` 实例中，给定一个具有变量 $x_1, \\ldots, x_n$ 的标准CNF公式 $\\phi$，以及一组额外的成对不等式约束 $C = \\{(i_1, j_1), (i_2, j_2), \\ldots, (i_k, j_k)\\}$，其中每对 $(i, j)$ 代表变量 $x_i$ 和 $x_j$ 的真值必须不同（即 $x_i \\neq x_j$）的约束。\n\n假设你可以访问一个标准的SAT预言机（它只能判定标准CNF公式的可满足性），以下哪项描述了为给定的 `UNEQUAL-SAT` 实例 $(\\phi, C)$ 寻找满足赋值的正确且完整的过程？\n\nA. 对 $C$ 中的每个约束 $(i, j)$，将原始公式 $\\phi$ 与子句 $(x_i \\lor x_j)$ 和 $(\\neg x_i \\lor \\neg x_j)$ 进行逻辑与运算，从而构造一个新公式 $\\phi'$。然后，对新公式 $\\phi'$ 应用标准的自可约性算法。\n\nB. 首先，使用标准的自可约性算法为原始公式 $\\phi$ 找到一个满足赋值。然后，根据 $C$ 中的约束检查此赋值。如果一个约束 $x_i \\neq x_j$ 被违反，则翻转 $x_i$ 的值。重复此翻转过程，直到 $C$ 中的所有约束都得到满足。\n\nC. 在对变量 $x_k$ 进行自可约性循环期间，在预言机建议一个值（例如，$x_k = \\text{True}$）后，手动检查此赋值是否违反了任何不等式约束 $x_k \\neq x_j$，其中 $x_j$ 已在前一步中被赋值。如果违反，则忽略预言机的建议，并将 $x_k$ 设置为相反的值。否则，接受预言机的建议。\n\nD. 该问题无法用标准的SAT预言机解决。由于 `UNEQUAL-SAT` 问题的结构与SAT有根本不同，因此需要一个能够直接处理不等式约束的预言机。",
            "solution": "我们给定一个作用于变量 $x_{1},\\ldots,x_{n}$ 的CNF公式 $\\phi$，以及一组不等式约束 $C=\\{(i_{1},j_{1}),\\ldots,(i_{k},j_{k})\\}$，其中每个 $(i,j)\\in C$ 强制要求 $x_{i}\\neq x_{j}$。目标是仅使用标准的SAT预言机为实例 $(\\phi,C)$ 找到一个满足赋值。\n\n关键的观察是，每个不等式约束 $x_{i}\\neq x_{j}$ 都可以用CNF表示，而无需引入新变量。对于布尔变量，等价关系\n$$\nx_{i}\\neq x_{j}\\iff (x_{i}\\lor x_{j})\\land(\\neg x_{i}\\lor \\neg x_{j})\n$$\n成立。为了证明这个等价关系，请注意 $x_{i}\\neq x_{j}$ 意味着 $x_{i},x_{j}$ 中恰好有一个为真。合取项 $(x_{i}\\lor x_{j})$ 强制要求至少有一个为真，而 $(\\neg x_{i}\\lor \\neg x_{j})$ 强制要求至少有一个为假。两者结合起来，它们强制恰好有一个为真，这正是 $x_{i}\\neq x_{j}$ 的确切含义。反之，如果两个子句都成立，那么它们不可能都为假（被 $x_{i}\\lor x_{j}$ 排除），也不可能都为真（被 $\\neg x_{i}\\lor \\neg x_{j}$ 排除），所以必须恰好有一个为真，因此 $x_{i}\\neq x_{j}$ 成立。\n\n使用这个等价关系，我们构造一个标准的CNF公式\n$$\n\\phi' \\;=\\; \\phi \\;\\land\\; \\bigwedge_{(i,j)\\in C}\\Big((x_{i}\\lor x_{j})\\land(\\neg x_{i}\\lor \\neg x_{j})\\Big).\n$$\n根据构造，一个赋值满足 $\\phi'$ 当且仅当它满足 $\\phi$ 和 $C$ 中的所有不等式。因此，$(\\phi,C)$ 是可满足的当且仅当 $\\phi'$ 是可满足的，并且 $\\phi'$ 的任何满足赋值都是 $(\\phi,C)$ 的满足赋值，反之亦然。\n\n仅给定一个用于CNF公式的标准SAT预言机，我们现在可以直接对 $\\phi'$ 应用标准的SAT自可约性过程。设变量按 $x_{1},\\ldots,x_{n}$ 的顺序排列。初始化一个空的偏赋值。对于从1到n的每个k，通过将已固定的值 $x_{1}=v_{1},\\ldots,x_{k-1}=v_{k-1}$ 代入 $\\phi'$ 来定义部分赋值的公式，然后通过额外设置 $x_{k}=\\text{True}$ 得到的公式来查询预言机。如果预言机回答说结果公式是可满足的，则设置 $x_{k}=\\text{True}$；否则，设置 $x_{k}=\\text{False}$。这是SAT的标准自可约过程，它保证了如果 $\\phi'$ 是可满足的，该过程会产生一个满足 $\\phi'$ 的完整赋值。因为 $\\phi'$ 编码了 $\\phi$ 和 $C$ 中的不等式，所以最终的赋值满足原始的 UNEQUAL-SAT 实例 $(\\phi,C)$。\n\n选项B和C是不正确的，因为它们将 $C$ 的强制执行与 $\\phi$ 的可满足性分离开来，在翻转赋值或覆盖预言机引导的选择时，如果不重新检查可满足性，可能会破坏可满足性。选项D是不正确的，因为不等式约束可以用CNF表示，所以一个标准的SAT预言机就足够了。\n\n因此，正确且完整的过程是，将不等式约束编码为CNF子句，形成 $\\phi'$，然后对 $\\phi'$ 应用标准的SAT自可约性算法。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "自可约性的强大之处不仅在于找到*任意*一个解，通过精心设计预言机查询的顺序，我们可以寻找具有特定性质的解。最后的这个练习挑战您修改标准的搜索策略，以找到一个*最小*可满足赋值。这展示了自可约性概念在解决更精细、更有针对性的搜索问题时的高级应用，突显了其理论深度和实践价值。",
            "id": "1447155",
            "problem": "在计算复杂性理论中，布尔可满足性问题（SAT）是一个基础问题。给定一个在变量集合 $\\{x_1, x_2, \\ldots, x_n\\}$ 上的合取范式（CNF）布尔公式 $\\phi$，问题在于确定是否存在一组对变量的 TRUE 或 FALSE 赋值，使得整个公式的计算结果为 TRUE。\n\n假设你有一个名为 SAT 预言机的假设设备。这个预言机由函数 `is_sat(ψ)` 表示，它接受任何布尔公式 `ψ` 作为输入，如果 `ψ` 是可满足的，则立即返回 TRUE，否则返回 FALSE。虽然这样的预言机可以告诉你*是否*存在一个满足赋值，但它不直接提供这个赋值。\n\n一个称为自可约性的著名过程使用这个预言机为给定的可满足公式 $\\phi$ 找到一个满足赋值。然而，一个公式可以有许多满足赋值。我们感兴趣的是一种特定类型的赋值，称为*最小满足赋值*。一个满足赋值 $A$ 被定义为**最小的**，如果对于 $A$ 中任何被赋值为 TRUE 的变量 $x_i$，将其值翻转为 FALSE（同时保持所有其他变量的赋值不变）会导致一个不再满足 $\\phi$ 的赋值。\n\n你的任务是识别一个正确且有保证的算法，该算法使用 SAT 预言机为给定的可满足公式 $\\phi$ 找到一个这样的最小满足赋值。所考虑的算法从 $x_1$ 到 $x_n$ 逐个变量地构建赋值。在下面的描述中，$\\psi$ 表示一个逐步构建的公式，初始为 $\\psi = \\phi$。最终的赋值表示为 $A$。\n\n以下哪个算法能正确并保证为任何可满足的输入公式 $\\phi$ 找到一个最小满足赋值？\n\nA. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$:\n    如果 `is_sat`($\\psi \\land x_i$) 为 TRUE:\n        设置 $A(x_i) = \\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n    否则:\n        设置 $A(x_i) = \\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n返回 $A$。\n\nB. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$:\n    如果 `is_sat`($\\psi \\land \\neg x_i$) 为 TRUE:\n        设置 $A(x_i) = \\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n    否则:\n        设置 $A(x_i) = \\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n返回 $A$。\n\nC. 首先，使用标准的自可约性方法（算法 A）找到一个任意的满足赋值 $A_0$。\n初始化 $A = A_0$。\n对于 $i = 1, \\ldots, n$:\n    如果 $A(x_i)$ 为 TRUE:\n        令 $A'$ 为与 $A$ 相同但将 $x_i$ 设置为 FALSE 的赋值。\n        如果 $A'$ 满足 $\\phi$:\n            更新 $A \\leftarrow A'$。\n返回 $A$。\n\nD. 对于 $i = 1, \\ldots, n$:\n    令 $\\phi_T = \\phi \\land x_i$ 和 $\\phi_F = \\phi \\land \\neg x_i$。\n    如果 `is_sat`($\\phi_T$) 为 TRUE 且 `is_sat`($\\phi_F$) 为 TRUE:\n        设置 $A(x_i) = \\text{FALSE}$。\n    否则如果 `is_sat`($\\phi_T$) 为 TRUE:\n        设置 $A(x_i) = \\text{TRUE}$。\n    否则:\n        设置 $A(x_i) = \\text{FALSE}$。\n返回 $A$。",
            "solution": "我们想要一个算法，它总是返回一个满足赋值，并保证最小性，即对于输出中设置为 TRUE 的每个变量，将其翻转为 FALSE 同时保持所有其他变量不变，会使公式变得不可满足。\n\n算法 B:\n- 正确性（返回一个满足赋值）：维持不变量，即在第 $i$ 次迭代开始时，工作公式 $\\psi$ 等于 $\\phi$ 与 $x_{1},\\ldots,x_{i-1}$ 的固定值相合取，并且是可满足的。在步骤 $i$，算法查询 $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$。如果为 TRUE，它设置 $x_{i}=\\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_{i}$，根据预言机的回答，该公式仍然是可满足的。否则，它设置 $x_{i}=\\text{TRUE}$ 和 $\\psi \\leftarrow \\psi \\land x_{i}$。这是安全的，因为 $\\psi$ 是可满足的，并且 $\\psi \\equiv (\\psi \\land x_{i}) \\lor (\\psi \\land \\neg x_{i})$；如果 $\\psi \\land \\neg x_{i}$ 是不可满足的，那么 $\\psi \\land x_{i}$ 必须是可满足的（否则 $\\psi$ 将是不可满足的）。通过归纳法，在 $n$ 步之后，$\\psi$ 包含了所有变量的赋值并且是可满足的，因此生成的 $A$ 满足 $\\phi$。\n\n- 最小性：设 $i$ 是任何满足 $A(x_{i})=\\text{TRUE}$ 的索引。这种情况只在步骤 $i$ 中 $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$ 返回 FALSE 时发生，此时 $\\psi$ 已经包含了 $A$ 中 $x_{1},\\ldots,x_{i-1}$ 的固定值。预言机返回的 FALSE 意味着不存在对 $x_{i+1},\\ldots,x_{n}$ 的赋值可以满足 $\\psi \\land \\neg x_{i}$。特别地，如果我们取 $A$ 中使用的 $x_{i+1},\\ldots,x_{n}$ 的最终值，那么\n$$\n\\phi \\land \\bigwedge_{j",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}