{
    "hands_on_practices": [
        {
            "introduction": "库克-莱文定理证明的第一步是将图灵机的计算过程转化为布尔表达式。这个过程始于对初始状态的精确编码。本练习将帮助你思考如何用布尔变量不仅表示计算开始时读写头的位置，还要确保它没有出现在任何其他位置，这是保证编码严谨性的关键一步 ()。",
            "id": "1438663",
            "problem": "在Cook-Levin定理的背景下，一个关键步骤是构造一个布尔公式 $\\phi$，该公式是可满足的当且仅当一个给定的非确定性图灵机（NTM）$M$ 接受一个长度为 $n$ 的输入串 $w$。这是通过创建一个表示 $M$ 在 $w$ 上的计算历史的计算历史表（tableau）来实现的。\n\n假设非确定性图灵机 $M$ 保证在多项式 $p(n)$ 界定的步数内停机。我们可以用一个大小为 $p(n) \\times p(n)$ 的计算历史表来对计算进行建模，其中行代表时间步 $t$（从 $0$ 到 $p(n)-1$），列代表带单元索引 $i$（从 $0$ 到 $p(n)-1$）。\n\n为了描述机器的状态，我们引入一组布尔变量。设变量 $h_{t,i}$ 为真，如果机器的读写头在时间步 $t$ 位于单元格 $i$，否则为假。这里，$0 \\le t  p(n)$ 和 $0 \\le i  p(n)$。\n\n按照惯例，一个非确定性图灵机在时间 $t=0$ 开始计算，其读写头位于带的第一个单元格，即单元格 $i=0$。\n\n下列哪个布尔表达式正确且完整地将这个关于读写头位置的特定初始条件编码为整个起始配置公式 $\\phi_{start}$ 的一部分？\n\nA. $h_{0,0} \\land \\left( \\bigwedge_{i=1}^{p(n)-1} \\neg h_{0,i} \\right)$\n\nB. $\\bigvee_{i=0}^{p(n)-1} h_{0,i}$\n\nC. $h_{0,0}$\n\nD. $\\left(\\bigvee_{i=0}^{p(n)-1} h_{0,i}\\right) \\land \\left( \\bigwedge_{0 \\le i  j  p(n)} (\\neg h_{0,i} \\lor \\neg h_{0,j}) \\right)$\n\nE. $\\bigwedge_{i=0}^{p(n)-1} h_{0,i}$",
            "solution": "我们给定布尔变量 $h_{t,i}$，其中 $h_{t,i}$ 为真当且仅当读写头在时间 $t$ 位于单元格 $i$。初始条件规定在时间 $t=0$ 时，读写头位于单元格 $i=0$。为了完整地编码时间 $t=0$ 的这个特定条件，我们必须同时断言两件事：\n- 指定单元格为真：$h_{0,0}$ 必须为真。\n- 同一时间所有其他单元格为假：对于每一个满足 $1 \\le i \\le p(n)-1$ 的 $i$，$h_{0,i}$ 必须为假。\n\n这两个要求合在一起，由以下合取式表达：\n$$\nh_{0,0} \\land \\left( \\bigwedge_{i=1}^{p(n)-1} \\neg h_{0,i} \\right).\n$$\n这个公式是将读写头在时间 0 精确地固定在单元格 0 的充分必要条件。\n\n现在来评估各个选项：\n- 选项 A 正是上面的公式，因此它正确且完整地编码了读写头的初始位置。\n- 选项 B，$\\bigvee_{i=0}^{p(n)-1} h_{0,i}$，强制要求读写头在时间 0 位于某个位置，但并未强制它必须在 $i=0$。\n- 选项 C，$h_{0,0}$，强制要求读写头在 $i=0$，但没有排除某个 $i \\neq 0$ 的 $h_{0,i}$ 也为真的可能性；因此它是不完整的，除非在其他地方强制了互斥性。问题要求在 $\\phi_{start}$ 中对这个特定的初始条件进行完整编码，所以这个选项本身是不充分的。\n- 选项 D，$\\left(\\bigvee_{i=0}^{p(n)-1} h_{0,i}\\right) \\land \\left( \\bigwedge_{0 \\le i  j  p(n)} (\\neg h_{0,i} \\lor \\neg h_{0,j}) \\right)$，表达了在时间 0 恰好有一个 $h_{0,i}$ 为真，但它允许这个唯一的位置是任意的 $i$，而不必是 $i=0$。\n- 选项 E，$\\bigwedge_{i=0}^{p(n)-1} h_{0,i}$，错误地强制所有位置同时为真。\n\n因此，正确选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在编码了初始状态之后，我们必须确保计算的每一步都代表一个物理上可能且无歧义的机器配置。本练习探讨了一个常见的陷阱：忘记强制执行唯一性约束 ()。通过分析这个错误，你将理解为什么“最多一个”这样的条款不仅仅是形式上的要求，而是构建有效模拟的基石。",
            "id": "1438664",
            "problem": "在库克-列文定理的背景下，一种标准的证明技术是构造一个命题逻辑公式 $\\Phi$，该公式可满足当且仅当一个给定的非确定性图灵机 (NTM) $M$ 接受输入串 $w$。这个构造模拟了 $M$ 在 $w$ 上经过多项式数量的时间步 $P(|w|)$ 的计算过程。\n\n该公式通常使用布尔变量来描述机器在每个时间步 $t$（其中 $0 \\le t \\le P(|w|)$）的格局。这些变量包括：\n- `Q_{t,q}`: 如果 $M$ 在时间步 $t$ 处于状态 $q$，则为真。\n- `H_{t,k}`: 如果 $M$ 的带头在时间步 $t$ 位于位置 $k$，则为真。\n- `T_{t,k,s}`: 如果带单元 $k$ 在时间步 $t$ 包含符号 $s$，则为真。\n\n一名计算机科学专业的学生正试图实现这个构造。他正确地创建了公式 $\\Phi$ 中强制执行以下内容的部分：\n1.  机器从输入 $w$ 的正确起始格局开始。\n2.  机器的计算最终达到一个接受状态。\n3.  从时间 $t$ 的格局到 $t+1$ 的格局的每个转换都根据 $M$ 的转移函数是有效的。\n4.  在任何时间 $t$，每个带单元 $k$ 包含*恰好一个*符号。\n5.  在任何时间 $t$，机器处于*至少一个*状态，并且其带头位于*至少一个*位置。这是通过对所有状态 $q_i$ 使用诸如 $(Q_{t,q_1} \\lor Q_{t,q_2} \\lor \\dots)$ 的子句来实现的。\n\n然而，该学生忘记为机器的状态和带头位置添加“唯一性”或“至多一个”的子句。具体来说，对于任何给定的时间 $t$，所有形式为 $(\\neg Q_{t,q_i} \\lor \\neg Q_{t,q_j})$（对于不同的状态 $q_i, q_j$）和 $(\\neg H_{t,k_i} \\lor \\neg H_{t,k_j})$（对于不同的位置 $k_i, k_j$）的成对否定子句都已从公式 $\\Phi$ 中省略。\n\n以下哪一项描述了这种省略的潜在后果，即它可能被这个不完整公式的一个可满足赋值所表示？\n\nA. 可满足赋值可能对应于一个“计算”，其中机器在同一时间 `t` 处于多个不同的状态。\n\nB. 可满足赋值可能对应于一个“计算”，其中执行了从时间 `t` 到 `t+1` 的一个机器转移函数所不允许的转换。\n\nC. 可满足赋值可能对应于一个“计算”，该计算没有从正确的起始状态开始，且带上没有输入 `w`。\n\nD. 可满足赋值可能对应于一个“计算”，其中机器在某个特定时间 `t` 根本不处于任何状态。\n\nE. 可满足赋值可能对应于一个“计算”，该计算运行了 `P(|w|)` 步，但从未进入任何机器定义的接受状态。",
            "solution": "我们分析在保持库克-列文构造的所有其他部分不变的情况下，省略状态变量 $Q_{t,q}$ 和带头位置变量 $H_{t,k}$ 的“至多一个”(AMO)子句所带来的逻辑后果。\n\n首先，我们重申被强制执行的部分：\n1. 起始格局被强制执行：在 $t=0$ 时，带上编码了 $w$，带头和状态被设置为标准起始状态，所有其他格局位都与初始规范相匹配。\n2. 接受条件被强制执行：存在一个 $t \\in \\{0,\\dots,P(|w|)\\}$ 使得 $Q_{t,q_{\\text{acc}}}$ 为真。\n3. 转换有效性被强制执行：对于每个 $t,k,q,s$，都有形式为\n$$\n\\left(Q_{t,q} \\land H_{t,k} \\land T_{t,k,s}\\right) \\Rightarrow \\text{Next}_{t+1}(q,s,k),\n$$\n的子句，其中 $\\text{Next}_{t+1}(q,s,k)$ 断言了由转移函数 $\\delta(q,s)=(q',s',d)$ 规定的具体更新，即 $Q_{t+1,q'}$，$H_{t+1,k'}$（其中 $k'=k+d$），以及在单元格 $k$ 写入的符号 $T_{t+1,k,s'}$。\n4. 每个带单元恰好一个符号被强制执行：对于每个 $t,k$，我们既有一个“至少一个”子句 $\\bigvee_{s} T_{t,k,s}$，也有对于所有 $s \\neq s'$ 的成对互斥子句 $\\left(\\lnot T_{t,k,s} \\lor \\lnot T_{t,k,s'}\\right)$。\n5. 至少一个状态和至少一个带头位置被强制执行：对于每个 $t$，$\\bigvee_{q} Q_{t,q}$ 和 $\\bigvee_{k} H_{t,k}$ 都成立。\n\n被省略的正是 $Q$ 和 $H$ 的 AMO 约束：对于每个固定的 $t$，没有形式为 $\\left(\\lnot Q_{t,q_{i}} \\lor \\lnot Q_{t,q_{j}}\\right)$（对于 $q_{i} \\neq q_{j}$）的子句，也没有形式为 $\\left(\\lnot H_{t,k_{i}} \\lor \\lnot H_{t,k_{j}}\\right)$（对于 $k_{i} \\neq k_{j}$）的子句。\n\n我们现在评估每个选项：\n\nA. 在同一时间 t 处于多个不同的状态。\n因为缺少对 $Q_{t,q}$ 的 AMO 约束，该公式在语法上不禁止在同一时间 $t$ 将 $Q_{t,q_{1}}$ 和 $Q_{t,q_{2}}$ 都设置为真。唯一可能间接禁止这种情况的方式是，如果转换有效性加上带符号精确性产生了矛盾。然而，存在机器 $M$ 以及 $H_{t,k}$ 和 $T_{t,k,s}$ 的一致选择，使得不会产生矛盾。具体来说，假设在时间 $t$ 带头位于某个位置 $k$（$H_{t,k}$ 为真），扫描到的符号是 $s$（$T_{t,k,s}$ 为真）。如果两个不同的状态 $q_{1},q_{2}$ 满足 $\\delta(q_{1},s)=(q'_{1},s',d_{1})$ 和 $\\delta(q_{2},s)=(q'_{2},s',d_{2})$ 共享相同的写入符号 $s'$，那么蕴含式\n$$\n\\left(Q_{t,q_{1}} \\land H_{t,k} \\land T_{t,k,s}\\right) \\Rightarrow T_{t+1,k,s'} \\quad \\text{and} \\quad \\left(Q_{t,q_{2}} \\land H_{t,k} \\land T_{t,k,s}\\right) \\Rightarrow T_{t+1,k,s'}\n$$\n与时间 $t+1$ 时单元格 $k$ 的“恰好一个带符号”约束是一致的。后件 $Q_{t+1,q'_{1}}$ 和 $Q_{t+1,q'_{2}}$ 可以同时成立，因为对 $Q_{t+1,\\cdot}$ 没有 AMO 约束，同样地，多个 $H_{t+1,k'}$ 也可以被设置，因为对 $H_{t+1,\\cdot}$ 没有 AMO 约束。因此，存在一个可满足赋值，其中在同一时间 $t$ 有多个 $Q_{t,q}$ 为真。因此 A 是一个可能的后果。\n\nB. 从 $t$ 到 $t+1$ 的非法转换。\n该构造包含了转换有效性子句，对于每一个被激活的前件 $\\left(Q_{t,q} \\land H_{t,k} \\land T_{t,k,s}\\right)$，它强制执行的正是 $\\delta(q,s)$ 所允许的更新。缺少对 $Q$ 和 $H$ 的 AMO 约束并不会引入任何允许不在 $\\delta$ 中的转换的子句。它可能允许多个转换同时触发，但每个转换本身都是被允许的。因此，该公式仍然禁止任何不在转移函数中的单个转换。因此 B 不是一个后果。\n\nC. 不正确的起始格局。\n起始格局子句仍然存在，并强制在 $t=0$ 时具有正确的起始状态、带头位置和带上的输入。在其他时间缺少 AMO 约束并不会使其无效。因此 C 不是一个后果。\n\nD. 在某个时间 t 没有状态。\n“至少一个状态”子句 $\\bigvee_{q} Q_{t,q}$ 对每个 $t$ 都存在，因此不可能在任何时间 $t$ 让所有的 $Q_{t,q}$ 都为假。因此 D 不是一个后果。\n\nE. 从未进入接受状态。\n接受条件被强制执行（例如，通过 $\\bigvee_{t \\le P(|w|)} Q_{t,q_{\\text{acc}}}$），所以某个 $Q_{t,q_{\\text{acc}}}$ 必须为真。缺少 AMO 约束并不会移除这个要求。因此 E 不是一个后果。\n\n因此，省略 AMO 约束使得可满足赋值可以编码同时占据多个状态（以及同样地，多个带头位置），而不会违反其余的约束，所以 A 是正确的选择。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "构建证明的最后一部分，也是最具动态性的一部分，是编码机器的实际“移动”和状态变化。整个模拟的正确性取决于能否准确捕捉一个配置如何合法地演变到下一个配置。本练习将探讨实现 $\\phi_{move}$ 子句所需的最小信息量，从而揭示了证明中经典的 $2 \\times 3$ “窗口”设计的巧妙之处 ()。",
            "id": "1438642",
            "problem": "在库克-列文定理的背景下，一个非确定性图灵机在输入串上的计算过程由一个计算历史表 (tableau) 表示，它是一个矩形单元格网格。设该计算历史表的高度为 $p(n)$，宽度也为 $p(n)$，其中 $n$ 是输入的长度，$p$ 是一个多项式。每个单元格 $(i, j)$（第 $i$ 行，第 $j$ 列）包含一个来自集合 $\\Gamma \\cup (Q \\times \\Gamma)$ 的符号，其中 $\\Gamma$ 是带字母表，$Q$ 是状态集。\n\n向布尔可满足性问题 (SAT) 的归约涉及到创建一个布尔公式 $\\phi$，该公式是可满足的当且仅当图灵机接受该输入。此公式通常是四个部分的合取：$\\phi = \\phi_{cell} \\land \\phi_{start} \\land \\phi_{accept} \\land \\phi_{move}$。\n\n- $\\phi_{start}$ 确保计算历史表的第一行正确表示了初始格局。\n- $\\phi_{accept}$ 确保计算历史表中的某处出现了一个接受状态。\n- $\\phi_{cell}$ 确保每个单元格都恰好包含一个符号。\n- $\\phi_{move}$ 确保计算历史表的每一行都根据机器的转移规则合法地由前一行推导而来。\n\n$\\phi_{move}$ 子句的构造方式是断言对于计算历史表中的每一个 $2 \\times 3$ 单元格“窗口”，其格局都是局部有效的。一个以列 $j$ 为中心的窗口由单元格 $(i, j-1), (i, j), (i, j+1)$ 和 $(i+1, j-1), (i+1, j), (i+1, j+1)$ 组成。底部三个单元格的格局受顶部三个单元格的约束。\n\n考虑一个有缺陷的构造，其中 $\\phi_{move}$ 改为使用 $2 \\times 2$ 的单元格窗口来定义。对于任意行 $i$ 和列 $j$，该窗口由上一行的单元格 $(i, j), (i, j+1)$ 和下一行的单元格 $(i+1, j), (i+1, j+1)$ 组成。该公式将断言对于每一个这样的 $2 \\times 2$ 窗口，其格局都是合法的。\n\n下列哪项描述了这种修改后构造最关键的逻辑缺陷？\n\nA. 修改后的公式将允许存在一个可满足的赋值，该赋值对应于一个计算历史表，其中即使图灵机读写头在上一步中不在位置 $j-1$、$j$ 或 $j+1$，位置 $j$ 的带符号也被改变了。\n\nB. 该归约将变得无效，因为为 $\\phi_{move}$ 生成的子句数量将不再是输入规模 $n$ 的多项式。\n\nC. 修改后的公式将无法正确强制图灵机从其初始状态 $q_0$ 开始，并将输入串放在其带上。\n\nD. 修改后的公式将无法强制图灵机读写头在计算历史表的每行中恰好出现在一个单元格内。\n\nE. 即使计算历史表不包含接受状态 $q_{accept}$，修改后的公式也可能被满足。",
            "solution": "在库克-列文定理的证明中，$\\phi_{move}$ 子句的目的是确保图灵机格局从一个时间步到下一个时间步（即在计算历史表中从第 $i$ 行到第 $i+1$ 行）的演变是合法的。单元格 $(i+1, j)$ 的内容由其上一行的三个单元格 $(i, j-1)$、$(i, j)$ 和 $(i, j+1)$ 的内容决定。这是因为在时间步 $i$，机器的状态可能位于这三个位置中的任何一个，从而影响时间步 $i+1$ 时单元格 $(i+1, j)$ 的内容。\n\n让我们来分析为什么这个三单元格邻域是必要的：\n1.  **读写头在 $(i, j-1)$：** 如果读写头在位置 $j-1$，且转移函数指示向右移动，则新状态将出现在单元格 $(i+1, j)$ 中。\n2.  **读写头在 $(i, j)$：** 如果读写头在位置 $j$，转移函数将决定写回该位置带上的符号，该符号出现在单元格 $(i+1, j)$ 中。新状态可能会移动到 $(i+1, j-1)$ 或 $(i+1, j+1)$。\n3.  **读写头在 $(i, j+1)$：** 如果读写头在位置 $j+1$，且转移函数指示向左移动，则新状态将出现在单元格 $(i+1, j)$ 中。\n4.  **附近没有读写头：** 如果在时间步 $i$，读写头不在 $j-1, j,$ 或 $j+1$ 的任何一个位置，那么单元格 $(i+1, j)$ 中的符号必须与单元格 $(i, j)$ 中的符号相同。\n\n标准的 $2 \\times 3$ 窗口捕获了第 $i$ 行中所有这三个可能影响第 $i+1$ 行中某个单元格的“父”单元格。该窗口的逻辑公式实质上是说：“底部中间单元格 $(i+1, j)$ 的格局与源于上方三个单元格 $(i, j-1), (i, j), (i, j+1)$ 中状态和符号的某个可能的合法转移是一致的。”\n\n现在，让我们分析使用覆盖单元格 $(i, j), (i, j+1)$ 和 $(i+1, j), (i+1, j+1)$ 的 $2 \\times 2$ 窗口的有缺陷的构造。这个窗口被用来根据上一行的内容来约束单元格 $(i+1, j)$ 的内容。然而，这个窗口只能“看到”单元格 $(i, j)$ 和 $(i, j+1)$ 的内容。它没有关于单元格 $(i, j-1)$ 内容的任何信息。\n\n这就产生了一个关键的漏洞。假设在时间步 $i$，图灵机读写头位于位置 $j-1$，而位置 $j$ 和 $j+1$ 处的带符号比如说都是 '0'。$2 \\times 2$ 的窗口查看单元格 $(i, j)$ 和 $(i, j+1)$，看到两者中都只有 '0' 而没有状态，然后必须检查 $(i+1, j)$ 和 $(i+1, j+1)$ 的格局是否合法。它无法知道读写头实际上在位置 $j-1$ 处是活跃的，并且可能在下一步影响位置 $j$。\n\n这样做最严重的后果是，该公式无法再强制要求当读写头不在附近时，带上的一个单元格内容保持不变。例如，考虑一个读写头在很远的位置 $k$。在一个正确的计算历史表中，$(i+1, j)$ 中的符号必须与 $(i, j)$ 中的相同。$2 \\times 3$ 窗口通过验证单元格 $(i, j-1), (i, j)$ 或 $(i, j+1)$ 中不存在状态来强制这一点，这继而强制符号被复制。然而，$2 \\times 2$ 窗口无法检查单元格 $(i, j-1)$。因此，可能存在一个满足赋值，其中读写头在 $(i, j-1)$，$(i, j)$ 处的符号是 '0'，但 $(i+1, j)$ 处的符号却自发地变成了 '1'。局部的 $2 \\times 2$ 窗口子句会看到 $(i, j)$ 或 $(i, j+1)$ 处没有状态，并可能错误地允许这种改变。这破坏了模拟的基本逻辑。这与选项A完全对应。\n\n让我们评估一下其他选项：\n-   **B：** 子句的数量仍然是多项式的。窗口的数量与计算历史表的面积成正比，即 $p(n) \\times p(n)$。更小的窗口大小不会改变构造的多项式性质。\n-   **C：** 初始格局由 $\\phi_{start}$ 强制执行，它只涉及计算历史表的第一行。$\\phi_{move}$ 的窗口大小与公式的这一部分无关。\n-   **D：** 读写头每行恰好出现一次的约束是 $\\phi_{cell}$ 的一部分，它确保每一行都是一个合法的格局。虽然 $\\phi_{move}$ 与此相关，但主要的缺陷不在于读写头的数量，而在于带内容的错误演变。\n-   **E：** 对接受状态的检查由 $\\phi_{accept}$ 处理，它只是在计算历史表的任何单元格中搜索 $q_{accept}$ 的存在。这与 $\\phi_{move}$ 中的局部转移规则无关。\n\n因此，最关键的缺陷是无法阻止带上非法的、自发的变化，因为窗口对前一个格局的视野太有限了。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}