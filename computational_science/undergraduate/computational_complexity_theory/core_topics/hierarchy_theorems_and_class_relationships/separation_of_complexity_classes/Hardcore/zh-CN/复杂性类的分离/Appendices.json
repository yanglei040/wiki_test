{
    "hands_on_practices": [
        {
            "introduction": "在尝试分离复杂性类之前，我们必须首先理解它们之间的基本包含关系。这个练习将探讨确定性时间和确定性空间这两个最基本的计算资源之间的内在联系。理解一个算法的时间复杂度如何为其空间复杂度提供一个直接的上限，是描绘整个计算复杂性版图的第一步。",
            "id": "1447409",
            "problem": "在计算复杂性理论领域，我们根据在某种计算模型（通常是确定性图灵机）上解决问题所需的资源来对问题进行分类。复杂度类 $\\text{DTIME}(t(n))$ 包含所有可由确定性图灵机在最多 $O(t(n))$ 时间内解决的判定问题，其中 $n$ 是输入的大小。类似地，复杂度类 $\\text{DSPACE}(s(n))$ 包含所有可由确定性图灵机使用最多 $O(s(n))$ 空间（即磁带单元）解决的判定问题。\n\n一位计算机科学家正在分析一个针对某个问题新开发的算法。她已正式证明该算法在确定性单带图灵机上运行，并在与输入大小 $n$ 的立方成正比的步数内终止。也就是说，该问题属于复杂度类 $\\text{DTIME}(n^3)$。\n\n仅根据此信息以及标准确定性时间和空间复杂度类之间的基本既定关系，解决此问题所需空间复杂度的最紧*保证*上界是什么？\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n^{1.5})$\n\nD. $O(n^2)$\n\nE. $O(n^3)$\n\nF. $O(n^6)$\n\nG. $O(2^{O(n^3)})$",
            "solution": "设 $T(n)$ 表示给定确定性单带图灵机在长度为 $n$ 的输入上的时间复杂度（步数），$S(n)$ 表示空间复杂度（使用的磁带单元数）。\n\n基本事实：在单带图灵机的每一步计算中，读写头最多只能访问一个新的磁带单元。因此，在计算过程中可以访问的不同磁带单元的总数最多为总步数。因此，\n$$\nS(n) \\leq T(n) + c\n$$\n对于某个常数 $c$，这意味着：\n$$\nS(n) \\in O(T(n)).\n$$\n这得出了标准的复杂度类包含关系：\n$$\n\\text{DTIME}(t(n)) \\subseteq \\text{DSPACE}(t(n)).\n$$\n\n问题中给定算法的运行时间为 $T(n) \\in O(n^3)$，由此直接得出：\n$$\nS(n) \\in O(T(n)) \\subseteq O(n^3).\n$$\n\n保证的紧致性：仅基于时间界限，通常无法保证任何更严格的渐近空间界限，因为可以设计出在 $O(n^3)$ 时间内写入 $\\Theta(n^3)$ 个不同磁带单元的计算，从而需要 $\\Theta(n^3)$ 的空间。因此，从给定信息中可以推导出的最紧保证上界是 $O(n^3)$。\n\n因此，在这些选项中，最紧的保证上界是 $O(n^3)$。",
            "answer": "$$\\boxed{E}$$"
        },
        {
            "introduction": "预言机是理论计算机科学中的一种思想实验工具，它能帮助我们探索复杂性类之间关系的极限。这个练习将指导你理解如何通过一种名为“对角化”的强大证明技巧，精心构造一个预言机，从而明确地分离两个相对化的复杂性类 ($NP^A$ 和 $coNP^A$)。这不仅展示了一种经典的分离方法，也揭示了证明复杂性类分离的精妙之处。",
            "id": "1447430",
            "problem": "在计算复杂性理论中，预言机被用作一种理论工具来探索复杂度类之间的关系。一个针对语言 $A$ 的预言机可以被想象成一个“黑箱”，它可以在单个计算步骤内回答任何“字符串 $w$ 是否在语言 $A$ 中？”这样的成员资格查询。相对于预言机 $A$ 定义的复杂度类，如 $P^A$ 或 $NP^A$，包含所有可以由配备了该预言机访问权限的相应类型（例如，多项式时间确定性或非确定性）的机器判定的语言。\n\nNP类（非确定性多项式时间）包含这样的语言：对于其“是”实例，给定一个合适的证据，可以在多项式时间内进行验证。coNP类包含这样的语言：对于其“否”实例，可以在多项式时间内进行验证。一个语言 $L$ 属于 coNP 当且仅当其补集 $\\bar{L}$ 属于 NP。\n\n考虑以下依赖于预言机语言 $A$ 的语言模式：\n$$U_A = \\{1^n \\mid \\text{there exists a string } x \\text{ of length } n \\text{ such that } x \\in A\\}$$\n这里，$1^n$ 表示一个由 $n$ 个连续的'1'组成的字符串。一个已知的结论是，对于任何预言机 $A$ 的选择，语言 $U_A$ 都属于 $NP^A$ 类。\n\n你的任务是确定一个可以被构造出来以证明 $NP^A \\neq coNP^A$ 的预言机 $A$ 的关键特征。这是通过确保语言 $U_A$ *不*属于 $coNP^A$ 来实现的。$A$ 的构造是通过一个对角化论证来进行的，其中预言机被专门构建来击败每一个试图识别 $U_A$ 补集的可能的多项式时间机器。\n\n以下哪个陈述最好地描述了为实现这种分离而构造的预言机语言 $A$ 的本质属性？\n\nA. 语言 $A$ 是 PSPACE 完全的。\n\nB. 对于每个整数 $n \\ge 1$，语言 $A$ 必须恰好包含一个长度为 $n$ 的字符串。\n\nC. 对于每个整数 $n \\ge 1$，语言 $A$ 包含零个或恰好一个长度为 $n$ 的字符串，其选择是系统性地做出的，以对所有候选的 coNP 机器进行对角化。\n\nD. 语言 $A$ 是所有回文二进制字符串的集合。\n\nE. 语言 $A$ 是一个有限语言。",
            "solution": "我们给定一个依赖于预言机的语言\n$$U_A=\\{1^n\\mid \\exists x, |x|=n \\text{ and } x\\in A\\}.$$\n$U_A \\in NP^A$ 总是成立的，因为一台 $NP^A$ 机器在输入为 $1^n$ 时，可以非确定性地猜测一个长度为 $n$ 的字符串 $x$，并使用一次预言机查询在多项式时间内验证 $x \\in A$。\n\n为了将 $NP^A$ 与 $coNP^A$ 分离开，我们只需构造一个预言机 $A$ 使得 $U_A \\notin coNP^A$。对角化策略的工作方式是，确保对于每一台声称要判定 $\\overline{U_A}$ 的多项式时间预言机 $M_i^{(\\cdot)}$，我们选择一个新的长度 $n_i$，并在长度为 $n_i$ 的字符串上定义 $A$，使得 $M_i^A$ 在输入 $1^{n_i}$ 上出错。这里的 $\\overline{U_A}$ 是：\n$$ \\overline{U_A} = \\{1^n \\mid \\forall x, |x|=n \\Rightarrow x \\notin A\\} $$\n关键的组合优势来自于限制 $A$，使得对于每个长度 $n$，集合 $A \\cap \\{0,1\\}^n$ 的大小最多为一。在这个限制下，判定长度为 $n$ 的 $\\overline{U_A}$ 等同于证明没有长度为 $n$ 的字符串在 $A$ 中，即 $A \\cap \\{0,1\\}^n$ 是空的。一个进行至多多项式次预言机查询的多项式时间机器无法在 $2^n$ 个可能性中排除存在一个未被查询的字符串。这使得我们可以如下对抗性地定义 $A$。\n\n枚举所有的多项式时间预言图灵机 $\\{M_1, M_2, \\dots\\}$。在第 $i$ 阶段，选择一个之前未使用过的足够大的新长度 $n_i$。在输入 $1^{n_i}$ 上模拟 $M_i^A$，在模拟过程中，对任何关于长度为 $n_i$ 的字符串的查询都回答 0（即“不在 $A$ 中”），并对其他长度的查询与之前的设定保持一致地回答。由于 $M_i$ 的运行时间是 $n_i$ 的多项式，它最多发出多项式次长度为 $n_i$ 的查询。在 $M_i^A$ 停机后：\n- 如果 $M_i^A$ 接受（声称 $1^{n_i} \\in \\overline{U_A}$，即 $A \\cap \\{0,1\\}^{n_i}$ 为空），则选择某个未被查询过的长度为 $n_i$ 的字符串 $x$，并设定 $x \\in A$。这使得 $1^{n_i} \\in U_A$，与其接受的结果相矛盾。\n- 如果 $M_i^A$ 拒绝（声称 $1^{n_i} \\notin \\overline{U_A}$，即该集合非空），则保持 $A \\cap \\{0,1\\}^{n_i} = \\varnothing$。这使得 $1^{n_i} \\notin U_A$，与其拒绝的结果相矛盾。\n\n这总是可能的，因为在长度 $n_i$ 上总有未被查询的字符串，并且对于每个 $n$，$|A \\cap \\{0,1\\}^n| \\in \\{0,1\\}$ 的限制保证了跨阶段的一致性并防止了未来的冲突。因此，对于所构造的 $A$，$U_A \\notin coNP^A$，故而 $NP^A \\neq coNP^A$。\n\n在此构造中使用的 $A$ 的本质属性恰恰是：对于每个长度 $n$，$A$ 包含零个或恰好一个该长度的字符串，其选择是对抗性地（通过对角化）针对所有候选的 $coNP^A$ 机器做出的。在这些选项中，这由陈述 C 所描述。陈述 A、D 和 E 未能捕捉到这种使得对角化成为可能的“每长度稀疏性”，而陈述 B（每个长度恰好有一个字符串）将使 $U_A$ 变得平凡，因此无法分离这两个类。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在见识了预言机构造如何分离复杂性类之后，我们来探讨另一面：它同样可以使不同的类“坍缩”为一体。这个练习将揭示，通过选择一个拥有足够计算能力的预言机（例如一个 PSPACE 完全问题），我们可以证明 $P^A = NP^A$。这一结果是“相对化壁垒”的核心，它有力地说明了为何那些在预言机模型下同样有效的证明技术（即相对化的证明技术），无法解决悬而未决的 P 与 NP 问题。",
            "id": "1447404",
            "problem": "在计算复杂性理论的框架内，我们可以探讨在存在“预言机”（oracle）的情况下，复杂性类之间的关系如何变化。预言机是一种假设性设备，可以在单一步骤内解决特定语言的问题。预言机图灵机（OTM）是一种标准的图灵机，增加了特殊的查询带和查询状态。当机器进入查询状态，且查询带上有一个字符串 $w$ 时，如果 $w$ 属于预言机语言 $A$，它会立即转换到‘是’状态；否则，转换到‘否’状态。\n\n类 $P^A$ 包含所有可以由带有预言机 $A$ 的确定性预言机图灵机在多项式时间内判定的语言。类似地，$NP^A$ 是可以由带有预言机 $A$ 的非确定性预言机图灵机在多项式时间内判定的语言类。\n\n对于本问题，回想一下 PSPACE 是指可以由确定性图灵机在使用与输入长度成多项式关系的空间量内判定的语言类。一个语言 $L$ 被定义为 PSPACE-完全（PSPACE-complete），如果它在 PSPACE 中，并且 PSPACE 中的所有其他语言都可以在多项式时间内归约到 $L$。\n\n你的任务是找出一个*可判定*的预言机语言 $A$ 的属性，该属性确保这两个相对化的类崩溃，即保证 $P^A = NP^A$。以下关于语言 $A$ 的哪个属性是充分条件？\n\nA. 语言 $A$ 是 NP-完全的。\n\nB. 语言 $A$ 是 PSPACE-完全的。\n\nC. 语言 $A$ 可以在指数时间内判定，但不能在多项式时间内判定。\n\nD. 语言 $A$ 是有限的。\n\nE. 语言 $A$ 是正则但非有限的。",
            "solution": "目标是找到一个可判定预言机语言 $A$ 的属性，该属性保证 $P^A = NP^A$。我们将分析每个选项，但首先，我们将证明如果 $A$ 是 PSPACE-完全的，则等式成立。\n\n根据定义，确定性机器是非确定性机器的一种特例，因此 $P^A \\subseteq NP^A$ 总是成立的。为了证明相等，我们必须证明另一个方向：$NP^A \\subseteq P^A$。我们将通过证明这两个类都等于 $\\text{PSPACE}$ 来做到这一点。\n\n**步骤1：证明对于 PSPACE-完全的预言机 $A$，$NP^A \\subseteq \\text{PSPACE}$。**\n设 $L$ 是 $NP^A$ 中的一个语言。这意味着存在一个带有预言机 $A$ 的非确定性预言机图灵机（OTM）$M$，它能在多项式时间（对于长度为 $n$ 的输入，记为 $p(n)$）内判定 $L$。\n\n我们可以使用一台仅使用多项式空间的确定性图灵机 $S$ 来模拟 $M$ 在输入 $x$ 上的计算。机器 $S$ 将系统地探索非确定性机器 $M$ 的所有可能的计算路径。\n\n由于 $M$ 在 $p(n)$ 时间内运行，任何计算路径的长度最多为 $p(n)$。在任何步骤中，非确定性选择的数量是一个固定的常数。因此，$S$ 可以以深度优先的方式探索所有路径。这需要存储 $M$ 的当前格局（带上内容、读写头位置、状态）以及到目前为止所做的选择路径。存储单个格局所需的空间是 $n$ 的多项式。\n\n当 $M$ 的模拟达到对字符串 $w$ 的预言机 $A$ 的查询时，模拟器 $S$ 必须确定是否 $w \\in A$。因为 $A$ 是 PSPACE-完全的，所以它属于 $\\text{PSPACE}$。这意味着存在一个确定性图灵机，它使用多项式空间来判定在 $A$ 中的成员资格。因此，模拟器 $S$ 可以执行这个 PSPACE 算法作为一个子程序来解决预言机查询。查询字符串 $w$ 的长度最多为 $p(n)$（因为它必须在多项式时间内写在查询带上），所以判定 $w \\in A$ 需要的空间是 $|w|$ 的多项式，也即是 $n$ 的多项式。\n\n模拟器 $S$ 使用的总空间是管理计算路径搜索所需空间和解决预言机查询所需空间之和。两者都是 $n$ 的多项式，因此总空间是多项式。因此，$S$ 在多项式空间内判定 $L$。这意味着 $L \\in \\text{PSPACE}$。\n由于 $L$ 是 $NP^A$ 中的任意语言，我们已经证明了 $NP^A \\subseteq \\text{PSPACE}$。\n\n**步骤2：证明对于 PSPACE-完全的预言机 $A$，$\\text{PSPACE} \\subseteq P^A$。**\n设 $L$ 是 $\\text{PSPACE}$ 中的任意语言。根据 $A$ 是 PSPACE-完全的定义，任何这样的 $L$ 都可以多项式时间归约到 $A$（记作 $L \\le_p A$）。这意味着存在一个函数 $f$，可由确定性图灵机在多项式时间内计算，使得对于任何输入字符串 $x$，$x \\in L$ 当且仅当 $f(x) \\in A$。\n\n我们可以构造一个确定性预言机图灵机，称之为 $M'$，它使用预言机 $A$ 来判定 $L$。对于输入 $x$，机器 $M'$ 按如下方式操作：\n1. 计算字符串 $y = f(x)$。由于 $f$ 可在多项式时间内计算，此步骤需要多项式时间。设此时间为 $q(|x|)$。\n2. 用字符串 $y$ 对预言机 $A$ 进行单次查询。这需要一步。\n3. 如果预言机回答‘是’（意味着 $y \\in A$），$M'$ 接受。如果预言机回答‘否’，$M'$ 拒绝。\n\n$M'$ 的总运行时间是 $q(|x|) + 1$，这是 $|x|$ 的多项式。由于 $M'$ 是确定性的，并且在多项式时间内判定 $L$，因此 $L \\in P^A$。\n因为 $L$ 是 $\\text{PSPACE}$ 中的任意语言，我们已经证明了 $\\text{PSPACE} \\subseteq P^A$。\n\n**步骤3：结论。**\n从步骤1，我们得到 $NP^A \\subseteq \\text{PSPACE}$。从步骤2，我们得到 $\\text{PSPACE} \\subseteq P^A$。将两者结合起来，得到 $NP^A \\subseteq P^A$。\n再加上 $P^A \\subseteq NP^A$ 这个事实，我们得出结论 $P^A = NP^A$。\n因此，如果 $A$ 是 PSPACE-完全的，则等式成立。这意味着选项 B 是一个充分条件。\n\n**其他选项分析：**\n*   **A. 语言 $A$ 是 NP-完全的。** 如果 $A$ 是 NP-完全的（例如，SAT），那么 $P^A = P^{SAT}$ 且 $NP^A = NP^{SAT}$。$P^{SAT}=NP^{SAT}$ 是否相等是一个开放问题，与多项式谱系（polynomial hierarchy）的崩溃有关。它不是一个必然的结果。\n*   **C. 语言 $A$ 可以在指数时间内判定，但不能在多项式时间内判定。** 这不是充分条件。事实上，Baker、Gill 和 Solovay 的一个经典构造提供了一个这类预言机，对于该预言机 $P^A \\neq NP^A$。\n*   **D. 语言 $A$ 是有限的。** 任何有限语言都是正则的，并且在读取输入后可以在常数时间内判定（对于一个固定的语言而言），这是多项式时间的一种特例。所以，如果 $A$ 是有限的，则 $A \\in P$。一个 P 中的语言的预言机不会增加计算能力，意味着 $P^A=P$ 且 $NP^A=NP$。因此，$P^A=NP^A$ 就等价于 $P=NP$，而后者尚不知是否为真。\n*   **E. 语言 $A$ 是正则但非有限的。** 与 D 类似，所有正则语言都在 P 中。因此，这个预言机不增加计算能力，D 的推理也适用于此。\n\n所列出的唯一能保证 $P^A = NP^A$ 的属性是 $A$ 是 PSPACE-完全的。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}