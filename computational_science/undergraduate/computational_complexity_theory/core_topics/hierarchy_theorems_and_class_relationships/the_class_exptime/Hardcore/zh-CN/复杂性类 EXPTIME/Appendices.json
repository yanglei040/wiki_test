{
    "hands_on_practices": [
        {
            "introduction": "理解 EXPTIME 精确的数学定义是掌握这个复杂性类的第一步。本练习旨在检验您分辨哪些函数符合 EXPTIME 界限——即 $O(2^{p(n)})$，其中 $p(n)$ 是一个多项式——而哪些不符合的能力。通过分析一组常见的运行时复杂度，您将为在形式上理解“指数时间”的真正含义培养出实践直觉。",
            "id": "1452143",
            "problem": "在计算复杂性理论中，判定问题根据解决它们所需的资源被划分为不同的复杂性类别。其中一个基本的类别是 EXPTIME（指数时间）。如果存在一台确定性图灵机，其可以在 $O(2^{p(n)})$ 的时间复杂度内解决一个判定问题，那么该问题就属于 EXPTIME 类，其中 $n$ 是输入的大小，$p(n)$ 是关于 $n$ 的任意多项式函数。\n\n一位计算机科学专业的学生正在分析五个不同的算法，每个算法都为解决一个不同的问题而设计。这些算法的最坏情况时间复杂度已经确定为输入大小 $n$ 的函数。\n\n- 算法 A：$O(2^{n^4})$\n- 算法 B：$O(2^{\\sqrt{n}})$\n- 算法 C：$O(1.5^n)$\n- 算法 D：$O(2^{2^n})$\n- 算法 E：$O(n^{1000})$\n\n上面列出的时间复杂度中，哪一个对应的问题**不**保证属于 EXPTIME 类？",
            "solution": "EXPTIME 是指可以在时间 $O(2^{p(n)})$ 内由确定性图灵机解决的判定问题类，其中 $p(n)$ 是某个多项式。\n\n针对多项式 $p$ 的 $2^{p(n)}$ 形式，评估每个算法：\n- 算法 A 的时间复杂度为 $O(2^{n^{4}})$。这里 $p(n)=n^{4}$ 是一个多项式，因此 $O(2^{n^{4}})\\subseteq\\text{EXPTIME}$。\n\n- 算法 B 的时间复杂度为 $O(2^{\\sqrt{n}})$。由于对于所有 $n\\ge 1$，都有 $\\sqrt{n}\\le n$，因此我们有 $2^{\\sqrt{n}}\\le 2^{n}$，所以 $O(2^{\\sqrt{n}})\\subseteq O(2^{n})$，其中 $p(n)=n$ 是一个多项式。因此它在 EXPTIME 中。\n\n- 算法 C 的时间复杂度为 $O(1.5^{n})$。使用 $1.5^{n}=2^{(\\log_{2}(1.5))\\,n}$，其中常数 $\\log_{2}(1.5)\\le 1$，我们得到对于所有 $n\\ge 1$，都有 $1.5^{n}\\le 2^{n}$，所以 $O(1.5^{n})\\subseteq O(2^{n})$，其中 $p(n)=n$ 是一个多项式。因此它在 EXPTIME 中。\n\n- 算法 E 的时间复杂度为 $O(n^{1000})$。由于指数函数增长快于多项式函数，$\\lim_{n\\to\\infty}\\frac{n^{1000}}{2^{n}}=0$，因此存在一个 $N$，使得对于所有 $n\\ge N$，都有 $n^{1000}\\le 2^{n}$。因此 $O(n^{1000})\\subseteq O(2^{n})$，其中 $p(n)=n$ 是一个多项式，所以它在 EXPTIME 中。\n\n- 算法 D 的时间复杂度为 $O(2^{2^{n}})$。对于任何多项式 $p(n)$，对于所有足够大的 $n$，我们有 $2^{n}>p(n)$，这意味着最终会有 $2^{2^{n}}>2^{p(n)}$。因此，对于每一个多项式 $p$，都有 $2^{2^{n}}\\notin O(2^{p(n)})$，所以这个界不保证属于 EXPTIME。\n\n因此，只有双指数时间 $O(2^{2^{n}})$ 不保证属于 EXPTIME。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "现实世界中的算法其运行时间并不总是能与教科书上的定义完美匹配。本练习将从简单的模式匹配转向培养分析技巧。您将研究一个具有阶乘时间复杂度 $O(n!)$ 的算法是否属于 EXPTIME，这个问题需要您运用数学不等式将 $n!$ 与所需指数形式联系起来。",
            "id": "1452096",
            "problem": "两名计算机科学专业的学生，Alice和Bob，正在分析一种新颖的算法。该算法对于大小为 $n$ 的输入，其最坏情况时间复杂度为 $T(n) = O(n!)$。\n\nAlice声称，任何可以用该算法解决的问题都属于复杂度类 EXPTIME。Bob不同意，他认为阶乘函数 $n!$ 的增长速度远快于定义 EXPTIME 的函数。\n\n复杂度类 EXPTIME，即指数时间（Exponential Time）的简称，被定义为所有可由确定性图灵机在 $O(2^{p(n)})$ 时间内解决的判定问题的集合，其中 $p(n)$ 是关于输入大小 $n$ 的某个多项式函数。\n\n根据 EXPTIME 的形式化定义，以下哪个陈述是正确的？\n\nA. Bob是正确的。$n!$ 呈超指数级增长，对于任何多项式 $p(n)$，它都不能被 $O(2^{p(n)})$ 所界定。因此，时间复杂度为 $O(n!)$ 的问题不属于 EXPTIME。\n\nB. Alice是正确的。$n!$ 属于 $O(2^{n \\log_2 n})$，并且由于 $n \\log_2 n$ 是一个多项式，所以该问题属于 EXPTIME。\n\nC. Bob是正确的。尽管 $n!$ 被 $n^n$ 所界定，但函数 $n^n$ 本身对于任何多项式 $p(n)$ 都不能被 $O(2^{p(n)})$ 所界定，所以时间复杂度为 $O(n!)$ 的问题不属于 EXPTIME。\n\nD. Alice是正确的。对于所有 $n \\ge 1$，不等式 $n! \\le n^n$ 成立。这又可以被一个多项式的指数所界定，例如，对于足够大的 $n$，$n^n \\le 2^{n^2}$。因此，时间复杂度为 $O(n!)$ 的问题属于 EXPTIME。\n\nE. 情况尚不明确。对于一个多项式 $p(n)$，$n!$ 是否包含在 $O(2^{p(n)})$ 之内是复杂度理论中一个尚未解决的问题。",
            "solution": "我们回顾其定义：EXPTIME 是所有可由确定性图灵机在 $O\\!\\left(2^{p(n)}\\right)$ 时间内解决的判定问题所属的复杂度类，其中 $p(n)$ 是某个多项式函数。因此，要证明时间界限 $T(n)=O(n!)$ 属于 EXPTIME，只需给出一个多项式 $p(n)$ 和一个常数 $C>0$，使得对于所有足够大的 $n$，\n$$\nn! \\le C \\cdot 2^{p(n)}.\n$$\n\n我们通过一个多项式的指数来确定 $n!$ 的上界：\n1) 对于所有 $n \\ge 1$，\n$$\nn! \\;=\\; \\prod_{k=1}^{n} k \\;\\le\\; \\prod_{k=1}^{n} n \\;=\\; n^{n}.\n$$\n\n2) 对于所有 $n \\ge 1$，使用恒等式 $a^{b} = 2^{b \\log_{2}(a)}$ 重写\n$$\nn^{n} \\;=\\; 2^{\\,n \\log_{2}(n)}.\n$$\n\n3) 对于所有 $n \\ge 2$，我们有 $\\log_{2}(n) \\le n$，因此\n$$\nn \\log_{2}(n) \\;\\le\\; n \\cdot n \\;=\\; n^{2}.\n$$\n\n4) 结合以上不等式，对于所有 $n \\ge 2$，\n$$\nn! \\;\\le\\; n^{n} \\;=\\; 2^{\\,n \\log_{2}(n)} \\;\\le\\; 2^{\\,n^{2}}.\n$$\n\n5) 令 $p(n)=n^{2}$，这是一个多项式。那么 $n! \\in O\\!\\left(2^{p(n)}\\right)$，任何最坏情况时间为 $O(n!)$ 的算法都在 $O\\!\\left(2^{n^{2}}\\right)$ 时间内运行，根据定义，这将其置于 EXPTIME 中。\n\n因此，断言 $O(n!)$ 时间不属于 EXPTIME 的陈述是错误的。陈述B错误地通过声称 $n \\log_2 n$ 是一个多项式来证明其成员资格，但它并不是多项式。陈述D正确地观察到，对于足够大的 $n$，$n! \\le n^{n} \\le 2^{n^{2}}$ 成立，因此这类问题属于 EXPTIME。因此，正确选项是D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "复杂性理论不仅在于对单个问题进行分类，还在于理解它们之间的相互关系。本练习介绍多项式时间归约这一基本概念，它使我们能够比较问题的相对难度。您将探索证明一个问题可以归约到另一个问题如何为其复杂性建立一个可靠的上限，从而展示 EXPTIME 类的一个关键结构特性。",
            "id": "1452129",
            "problem": "在计算复杂性理论中，问题根据解决它们所需的资源（如时间或内存）进行分类。我们来定义两个重要的时间复杂度类：\n\n1.  **P (多项式时间)**：如果一个判定问题存在一个算法，其解决时间以输入大小 $n$ 的多项式为界，那么该问题就属于 P 类。也就是说，运行时间为 $O(n^k)$，其中 $k$ 是某个常数。\n2.  **EXPTIME (指数时间)**：如果一个判定问题存在一个算法，其解决时间以输入大小 $n$ 的多项式的指数函数为界，那么该问题就属于 EXPTIME 类。也就是说，运行时间为 $O(2^{p(n)})$，其中 $p(n)$ 是某个多项式。\n\n多项式时间归约是比较问题难度的关键概念。如果问题 $B$ 的算法可以用来解决问题 $A$，而只需多项式数量的额外工作，则称问题 $A$ 可多项式时间归约到问题 $B$，记作 $A \\leq_p B$。更形式化地说，存在一个可在多项式时间内计算的函数 $f$，它将问题 $A$ 的一个输入 $x$ 转换为问题 $B$ 的一个输入 $f(x)$，使得实例 $x$ 是 $A$ 的“是”实例当且仅当 $f(x)$ 是 $B$ 的“是”实例。\n\n假设我们正在研究两个问题，问题 `PHOTON_PATH` 和问题 `QUANTUM_SIM`。我们已经确定 `QUANTUM_SIM` 属于复杂度类 EXPTIME。然后，一位研究人员证明了从 `PHOTON_PATH` 到 `QUANTUM_SIM` 的多项式时间归约的存在性（即 `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM`）。\n\n仅基于这些信息，以下哪一项代表了包含 `PHOTON_PATH` 问题的最紧的**保证**上界复杂度类？\n\nA. P (多项式时间)\n\nB. NP (非确定性多项式时间)\n\nC. PSPACE (多项式空间)\n\nD. EXPTIME (指数时间)\n\nE. 该问题是不可判定的。",
            "solution": "问题要求在已知 `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM` 且 `QUANTUM_SIM` $\\in$ EXPTIME 的条件下，为问题 `PHOTON_PATH` 找出最紧的保证上界复杂度类。\n\n我们来分析多项式时间归约 `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM` 的含义。这个归约意味着我们可以构建一个算法，使用 `QUANTUM_SIM` 的算法作为子程序来解决 `PHOTON_PATH`。我们来描述一下对于 `PHOTON_PATH` 问题的任意输入 $x$ 的这个过程。\n\n步骤1：归约。\n归约是一个函数 $f$，它将 `PHOTON_PATH` 的输入 $x$ 转换为 `QUANTUM_SIM` 问题的一个新输入，我们称之为 $y = f(x)$。根据多项式时间归约的定义，这个函数 $f$ 必须在多项式时间内可计算。设输入 $x$ 的大小为 $n$。计算 $y=f(x)$ 的时间是 $O(n^c)$，其中 $c$ 是某个常数。一个重要的推论是，输出 $y$ 的大小也必须是 $n$ 的多项式，因为一个在 $O(n^c)$ 时间内运行的算法最多只能产生大小为 $O(n^c)$ 的输出。设 $y$ 的大小为 $m$。我们有 $m = |y| = |f(x)| \\leq O(n^c)$，这意味着 $m$ 也是 $n$ 的一个多项式。我们可以将其写为 $m = q(n)$，其中 $q$ 是一个多项式。\n\n步骤2：解决归约后的实例。\n我们已知 `QUANTUM_SIM` 问题属于 EXPTIME。这意味着存在一个算法，可以在 $O(2^{p(s)})$ 的时间内解决 `QUANTUM_SIM` 的任何实例，其中 $s$ 是 `QUANTUM_SIM` 算法的输入大小，$p$ 是某个多项式。在我们的情况下，`QUANTUM_SIM` 算法的输入是 $y$，其大小为 $m$。因此，解决输入为 $y$ 的 `QUANTUM_SIM` 问题所需的时间是 $O(2^{p(m)})$。\n\n步骤3：合并时间复杂度。\n解决大小为 $n$ 的输入 $x$ 的 `PHOTON_PATH` 问题的总时间是归约所需时间（步骤1）和解决 `QUANTUM_SIM` 实例所需时间（步骤2）之和。\n\n总时间 = (计算 $y=f(x)$ 的时间) + (在 $y$ 上解决 `QUANTUM_SIM` 的时间)\n\n我们用原始输入大小 $n$ 来表示这个时间。\n计算 $y=f(x)$ 的时间是 $O(n^c)$。\n在 $y$ 上解决 `QUANTUM_SIM` 的时间是 $O(2^{p(m)})$。因为 $m = q(n)$，其中 $q$ 是一个多项式，所以这部分时间变为 $O(2^{p(q(n))})$。\n两个多项式的复合 $p(q(n))$ 本身也是一个多项式。我们称这个新多项式为 $r(n) = p(q(n))$。所以，解决 `QUANTUM_SIM` 部分的时间是 $O(2^{r(n)})$。\n\n因此，解决 `PHOTON_PATH` 的总时间是：\n$T_{total}(n) = O(n^c) + O(2^{r(n)})$\n\n当我们分析渐近复杂度时，指数项 $O(2^{r(n)})$ 的增长速度远快于任何多项式项 $O(n^c)$。因此，指数项主导了整体复杂度。\n$T_{total}(n) = O(2^{r(n)})$\n\n根据定义，这个结果时间复杂度 $O(2^{\\text{poly}(n)})$ 正是 EXPTIME 复杂度类。因此，`PHOTON_PATH` 问题保证属于 EXPTIME。\n\n这是最紧的**保证**上界。`PHOTON_PATH` 可能是一个简单得多的问题（例如，属于 P），但归约只提供了一个上界。由于 `PHOTON_PATH` 可能是一个 EXPTIME-完全问题（其难度与 EXPTIME 中的任何其他问题一样），我们不能仅根据给定的信息保证它属于任何更小的类，如 P、NP 或 PSPACE。因此，包含 `PHOTON_PATH` 的最紧的保证复杂度类是 EXPTIME。\n\n与给定的选项比较：\nA. P: 不保证。`PHOTON_PATH` 可能更难。\nB. NP: 不保证。\nC. PSPACE: 不保证。虽然 PSPACE 包含在 EXPTIME 中，但我们不能确定 `PHOTON_PATH` 是否在 PSPACE 中。\nD. EXPTIME: 由上述推理保证。\nE. 该问题是不可判定的：不正确，因为我们刚刚展示了一个可以判定它的算法。\n\n因此，正确答案是 EXPTIME。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}