{
    "hands_on_practices": [
        {
            "introduction": "要真正理解浮点表示法，我们必须首先学习其基本的编码机制。本练习将指导您完成将一个标准的十进制数转换为自定义二进制浮点格式的过程。通过亲手处理符号位、指数和尾数，您将对计算机如何存储非整数值有一个具体的认识。",
            "id": "1937489",
            "problem": "一个工程师团队正在为一款嵌入式物联网（IoT）设备开发专用处理器。为了最小化功耗和电路复杂性，他们设计了一种自定义的10位浮点数格式来表示传感器读数。该格式遵循以下结构：\n- 1位用于符号（S），S=0表示正数，S=1表示负数。\n- 4位用于偏移指数（E）。指数偏移量为7。\n- 5位用于小数部分（F）。\n\n一个规格化数的值使用公式 $$ V = (-1)^{S} \\times (1.F)_2 \\times 2^{(E-7)} $$ 进行解释，其中 $(1.F)_2$ 表示带有隐藏前导'1'的有效数。完整的10位字结构为：首先是符号位，然后是指数位，最后是小数位，顺序为 `S EEEE FFFFF`。\n\n设备上的一个温度传感器返回一个等同于十进制值-13.5的读数。在所描述的自定义格式中，这个值的正确10位二进制表示是什么？\n\nA. 1101010110\n\nB. 0101010110\n\nC. 1101111011\n\nD. 1101001011\n\nE. 1100110110",
            "solution": "我们给定一个自定义的10位浮点数格式，包含以下字段：符号 $S$（1位）、指数 $E$（4位，偏移量为7）和小数部分 $F$（5位）。对于规格化数，其值为\n$$\nV = (-1)^{S} (1.F)_{2} 2^{(E-7)}.\n$$\n我们需要对 $V=-13.5$ 进行编码。\n\n步骤1：确定符号位。\n由于该值为负数，符号位为\n$$\nS=1.\n$$\n\n步骤2：将绝对值转换为二进制并进行规格化。\n绝对值为 $13.5$。用二进制表示，\n$$\n13.5 = 1101.1_{2}.\n$$\n规格化为 $(1.F)_{2} 2^{e}$ 的形式：\n$$\n1101.1_{2} = 1.1011_{2} \\times 2^{3}.\n$$\n因此，未偏移的指数为\n$$\ne = 3.\n$$\n\n步骤3：计算偏移指数并将其编码为4位。\n偏移量为 $7$，所以存储的指数为\n$$\nE = e + 7 = 3 + 7 = 10.\n$$\n用4位二进制表示，$10$ 是\n$$\nE = 1010.\n$$\n\n步骤4：确定5位的小数部分字段。\n从规格化的有效数 $1.1011_{2}$ 中，小数部分（二进制小数点后的位）是 $1011$。我们需要5位小数位；由于 $13.5$ 是可以精确表示的，我们追加一个尾随的零：\n$$\nF = 10110.\n$$\n\n步骤5：按顺序 $S\\,EEEE\\,FFFFF$ 连接字段。\n当 $S=1$，$E=1010$，$F=10110$ 时，10位字是\n$$\n1\\,1010\\,10110 \\;\\Rightarrow\\; 1101010110.\n$$\n\n这与选项A匹配。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "既然您已经了解了如何编码数字，认识到一个根本性的限制至关重要：大多数实数无法被精确表示。这种不可避免的差异被称为表示误差。本练习通过要求您计算存储一个简单分数时的精确误差，让您深入探究这一概念，并直面有限精度系统中的舍入现实。",
            "id": "2173559",
            "problem": "一个工程师团队正在修复一台 20 世纪 80 年代的复古音频合成器。该合成器使用一个定制的数字信号处理器（DSP）来生成波形。这个 DSP 使用一个简化的 9 位浮点数系统进行计算。该系统具有以下规格：\n-   一个符号位（$s$）。\n-   一个 4 位的指数场（$E$），偏置值为 7。有效指数计算为 $e = E - 7$。存储的指数值 $E=0$ 和 $E=15$ 保留给特殊情况（零、无穷大等），不用于规格化数。\n-   一个 4 位的尾数场（$f$）。\n-   数是规格化的，意味着它们表示为 $N = (-1)^{s} \\times (1.f)_2 \\times 2^{e}$ 的形式。有效数的首位 `1` 是隐含的，不被存储。\n-   该系统使用“舍入到最近，偶数优先”的舍入方案。这意味着如果一个数正好位于两个可表示值之间，它将被舍入到尾数最低有效位为 0 的那个值。\n\n为了测试 DSP 的算术单元，工程师们需要评估其精度。作为此测试的一部分，他们想要确定在表示纯五度的基频比（数学上等同于分数 $3/2$）时的误差。然而，由于测试工具中的寻址错误，为此计算加载的值被错误地指定为 $1/5$。\n\n计算 $1/5$ 的真实数学值与其在这个 9 位浮点系统中的表示之间的绝对误差。将你的最终答案表示为一个实数，并四舍五入到三位有效数字。",
            "solution": "该格式为一个 9 位浮点数，包含一个符号位 $s$，一个指数场 $E$（4 位，偏置值为 7），以及一个尾数场 $f$（4 位），并带有一个隐含的前导 $1$。规格化数的形式为 $N = (-1)^{s}(1.f)_{2}2^{e}$，其中 $e = E - 7$，$E \\in \\{1,\\dots,14\\}$。舍入规则是舍入到最近，偶数优先。\n\n我们在此系统中表示 $x = \\frac{1}{5}$。在二进制中，$\\frac{1}{5}$ 的展开式为循环小数 $0.\\overline{0011}_{2}$。规格化后，我们写作\n$$\n\\frac{1}{5} = 0.0011\\overline{0011}_{2} = 1.1001\\overline{1001}_{2} \\times 2^{-3}.\n$$\n因此，精确的有效数是 $1.10011001\\ldots_{2}$，指数是 $e = -3$，所以 $E = e + 7 = 4$，这对一个规格化数是有效的。\n\n由于有 4 个小数位，我们必须将 $1.1001\\overline{1001}_{2}$ 舍入到 5 位精度（包括隐含的前导 $1$）。前 4 个存储的小数位是 $1001$，下一位（保护位）是 $1$。由于保护位后面的位不全为零，该值严格大于中点，所以我们向上舍入：\n$$\n1.1001_{2} \\xrightarrow{\\text{round}} 1.1010_{2}.\n$$\n因此，存储的值是\n$$\n\\mathrm{fl}\\!\\left(\\tfrac{1}{5}\\right) = 1.1010_{2} \\times 2^{-3}.\n$$\n精确计算这个值：\n$$\n1.1010_{2} = 1 + \\frac{1}{2} + \\frac{1}{8} = \\frac{13}{8}, \\quad \\Rightarrow \\quad \\mathrm{fl}\\!\\left(\\tfrac{1}{5}\\right) = \\frac{13}{8} \\cdot 2^{-3} = \\frac{13}{64}.\n$$\n绝对误差是\n$$\n\\left|\\frac{1}{5} - \\frac{13}{64}\\right| = \\left|\\frac{64 - 65}{320}\\right| = \\frac{1}{320} = 0.003125.\n$$\n四舍五入到三位有效数字得到 $0.00313$。",
            "answer": "$$\\boxed{0.00313}$$"
        },
        {
            "introduction": "虽然单个的表示误差可能微不足道，但在冗长的计算中它们会不断累积，有时甚至导致科学计算中的灾难性失败。最后一个练习将从理论走向代码实践，挑战您通过实现 Kahan 求和算法来直面这个问题。通过将其结果与朴素求和方法的精度进行比较，您将亲眼见证一个巧妙的算法如何能够极大地减轻舍入误差的累积效应，这是数值分析中的一项关键技术。",
            "id": "3231651",
            "problem": "您需要通过实现两种实数序列求和算法来研究有限精度算术中的舍入误差。这些实数序列以硬件双精度表示，即采用“舍入到最近，偶数优先”规则的电子电气工程师协会（IEEE）754 binary64 格式。目的是通过计算和有原则的推理，证明补偿求和能够减少舍入误差对病态序列的影响。\n\n从以下基本基础开始：\n- 对于一次正确舍入的浮点运算，其 IEEE 754 舍入模型可以抽象地表示为 $ \\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta) $，其中基本运算 $ \\circ \\in \\{ +, -, \\times, \\div \\} $，$ |\\delta| \\le u $，$ u $ 是该格式的单位舍入误差。对于采用“舍入到最近”规则的 IEEE 754 binary64 格式，$ u = 2^{-53} $。\n- 在精确实数算术中，加法满足结合律和交换律。而在浮点算术中，由于舍入的存在，$ \\operatorname{fl}( (a+b)+c ) $ 不一定等于 $ \\operatorname{fl}( a+(b+c) ) $。\n\n任务：\n1. 实现两种对以 IEEE 754 binary64 表示的实数序列进行求和的程序：\n   - 一种朴素的从左到右求和，仅使用 $ + $ 将数值累加到一个运行总和中。\n   - 一种使用 Kahan 算法的补偿求和，该算法为丢失的低位比特维持一个运行补偿，以减少舍入误差。\n2. 对于每个提供的测试序列，计算两种算法的浮点结果，并与使用任意精度十进制算术在精确实数算术中计算出的高精度参考值进行比较。使用足够的十进制精度以确保参考值不是瓶颈；对于本任务，至少 $ 80 $ 位十进制数字是足够的。\n3. 对于每个测试，计算每种算法的绝对误差，公式为 $ |S_{\\mathrm{float}} - S_{\\mathrm{exact}}| $，其中 $ S_{\\mathrm{float}} $ 是算法的浮点结果，$ S_{\\mathrm{exact}} $ 是高精度参考值。\n\n测试套件：\n- 测试 A（带大枢轴的灾难性抵消）：\n  - 序列：$ [10^{16}, 1, -10^{16}] $。\n  - 精确实数和：$ 1 $。\n- 测试 B（许多微小增量后的抵消）：\n  - 令 $ N = 50000 $。\n  - 序列：$ [1] $ 后跟 $ N $ 个 $ 10^{-16} $，再跟一个 $ [-1] $；即 $ [1, \\underbrace{10^{-16}, \\ldots, 10^{-16}}_{N \\text{ 次}}, -1] $。\n  - 精确实数和：$ N \\cdot 10^{-16} $。\n- 测试 C（许多小项的顺序敏感性抵消）：\n  - 令 $ N = 50000 $。\n  - 序列：$ [\\underbrace{10^{-10}, \\ldots, 10^{-10}}_{N \\text{ 次}}, \\underbrace{-10^{-10}, \\ldots, -10^{-10}}_{N \\text{ 次}}] $。\n  - 精确实数和：$ 0 $。\n- 测试 D（增量远低于首位单位的类边界情况）：\n  - 令 $ N = 100000 $。\n  - 序列：$ [1] $ 后跟 $ N $ 个 $ 10^{-310} $；即 $ [1, \\underbrace{10^{-310}, \\ldots, 10^{-310}}_{N \\text{ 次}}] $。\n  - 精确实数和：$ 1 + N \\cdot 10^{-310} $。\n\n最终输出规范：\n- 对于每个测试，生成一个布尔值，表示补偿求和是否不劣于朴素求和，即 $ |S_{\\mathrm{Kahan}} - S_{\\mathrm{exact}}| \\le |S_{\\mathrm{naive}} - S_{\\mathrm{exact}}| $ 是否成立。\n- 您的程序应生成单行输出，其中包含这四个布尔值，形式为逗号分隔的列表，用方括号括起来，顺序为 A、B、C、D，例如 $ [\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True}] $。\n- 不需要用户输入。仅在涉及角度时使用弧度或角度；此处不涉及角度。本问题不涉及物理单位。\n\n交付成果：\n- 一个完整、可运行的程序，该程序实现两种求和算法，构建指定的测试序列，计算高精度参考和，评估绝对误差，并按指定格式打印所需的单行布尔值列表。",
            "solution": "该问题要求通过比较朴素求和算法与 Kahan 补偿求和算法，来研究浮点求和中的舍入误差效应。此分析将使用几个旨在暴露有限精度算术常见失效模式的测试序列，在 IEEE 754 binary64 浮点数上进行。\n\n### 浮点算术的理论基础\n\n数字计算机使用有限数量的比特来表示实数，这一系统由 IEEE 754 标准形式化。对于本问题，我们使用 binary64 格式（双精度），该格式为每个数字分配 $64$ 个比特：$1$ 个比特用于符号，$11$ 个比特用于指数，$52$ 个比特用于尾数。此格式可以表示极大范围的数字，但可表示的数字集合是有限的且非均匀分布的。\n\n当算术运算 $x \\circ y$（其中 $\\circ \\in \\{+, -, \\times, \\div\\}$）的结果无法精确表示时，必须将其舍入到最接近的可表示浮点数。这种舍入会引入误差。对于一个运算 $\\circ$ 及其浮点对应项 $\\operatorname{fl}(\\cdot)$，此误差的标准模型为：\n$$ \\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta) $$\n其中 $|\\delta| \\le u$。$u$ 项是单位舍入误差，对于采用“舍入到最近”模式的 IEEE 754 binary64，其值为 $u = 2^{-53}$。这种微小的相对误差几乎在每次浮点运算中都会引入。\n\n舍入的一个关键后果是浮点加法不满足结合律。也就是说，对于浮点数 $a$、$b$ 和 $c$，通常情况下 $\\operatorname{fl}(\\operatorname{fl}(a+b)+c) = \\operatorname{fl}(a+\\operatorname{fl}(b+c))$ 并不成立。运算的顺序会显著影响最终结果，尤其是在长序列求和或涉及数量级差异巨大的数时。\n\n### 算法 1：朴素求和\n\n朴素求和算法遍历一个数字序列 $\\{x_1, x_2, \\dots, x_n\\}$ 并将它们累加到一个运行总和中。形式上，如果 $S_k$ 是前 $k$ 个元素的和：\n$$ S_0 = 0 $$\n$$ S_k = \\operatorname{fl}(S_{k-1} + x_k) \\quad \\text{对于 } k = 1, \\dots, n $$\n最终的和是 $S_n$。该方法的主要弱点是其对舍入误差的敏感性。一种特别具有破坏性的误差是“吞没”，它发生在将一个数量级较小的数与一个数量级较大的数相加时。如果 $|x_k|$ 小于 $S_{k-1}$ 周围可表示数字之间的间距（与 $S_{k-1}$ 的“末位单位”或 ULP 相关），那么 $x_k$ 中的信息可能完全丢失，因为 $\\operatorname{fl}(S_{k-1} + x_k)$ 可能恰好等于 $S_{k-1}$。这些误差在多次运算中会累积。\n\n### 算法 2：Kahan 补偿求和\n\nKahan 求和算法旨在减轻舍入误差的累积。它通过引入一个补偿变量 $c$ 来实现这一点，该变量跟踪每次加法产生的误差，并将其并入下一次加法中。\n\n对于一个序列 $\\{x_1, x_2, \\dots, x_n\\}$，算法过程如下：\n1. 初始化和 $S = 0$ 和补偿 $c = 0$。\n2. 对于序列中的每个元素 $x_i$：\n   a. $y = x_i - c$。此步骤用前一次加法的误差来修正当前项 $x_i$。\n   b. $t = S + y$。这是主要的加法，舍入误差在此发生。$y$ 的低位比特可能会丢失。\n   c. $c = (t - S) - y$。这是关键步骤。在精确实数算术中，$(t - S)$ 将恰好等于 $y$，使得 $c$ 为零。在浮点算术中，$(t-S)$ 恢复了成功加到 $S$ 上的 $y$ 的那部分。因此，表达式 $(t-S)-y$ 计算出 $y$ 丢失部分的相反数（即舍入误差）。\n   d. $S = t$。更新和。\n3. 最终结果是 $S$。\n\n通过在每一步跟踪并重新整合丢失的部分，Kahan 求和极大地减少了总累积误差。其误差界通常与项数 $n$ 无关，这是对朴素求和 $O(n)$ 误差增长的显著改进。\n\n### 高精度参考值计算\n\n为了量化浮点算法的误差，我们需要一个“基准真相”或精确实数和 $S_{\\mathrm{exact}}$。由于输入数字本身（例如 $10^{-16}$）在二进制中可能无法精确表示，我们必须使用一个基于十进制的任意精度算术系统。Python 的 `decimal` 模块可用于此目的。通过设置高精度（例如 $80$ 位数字），我们可以计算出一个对于所有实际用途而言都是精确的参考和，浮点结果 $S_{\\mathrm{naive}}$ 和 $S_{\\mathrm{Kahan}}$ 可以与之进行比较。绝对误差则计算为 $|S_{\\mathrm{float}} - S_{\\mathrm{exact}}|$。\n\n### 测试用例分析\n\n我们将分析每种算法在所提供的测试套件上的预期性能。\n\n**测试 A：$[10^{16}, 1, -10^{16}]$，精确实数和 $S_{\\mathrm{exact}} = 1$。**\n- **朴素求和**：首先，计算 $\\operatorname{fl}(10^{16} + 1)$。在 binary64 中 $10^{16}$ 的末位单位 (ULP) 约为 $10^{16} \\times 2^{-52} \\approx 2.22$。由于 $1  2.22$，加 1 的操作由于吞没而完全丢失。因此，$\\operatorname{fl}(10^{16} + 1) = 10^{16}$。下一步操作是 $\\operatorname{fl}(10^{16} - 10^{16}) = 0$。朴素求和的结果是 $0$，导致绝对误差为 $|0 - 1| = 1$。\n- **Kahan 求和**：在第二步（加 $1$）中，算法计算 $t = \\operatorname{fl}(10^{16} + 1) = 10^{16}$。补偿变为 $c = \\operatorname{fl}(\\operatorname{fl}(10^{16} - 10^{16}) - 1) = -1$。在第三步中，它计算 $y = \\operatorname{fl}(-10^{16} - c) = \\operatorname{fl}(-10^{16} - (-1)) = \\operatorname{fl}(-10^{16} + 1)$。这次加法也受到吞没的影响，导致 $y = -10^{16}$。最终的和变为 $\\operatorname{fl}(10^{16} + (-10^{16})) = 0$。在这个特殊情况下，当吞没发生在校正步骤本身时，Kahan 求和未能改善朴素求和的结果。误差也是 $1$。\n- **比较**：$|S_{\\mathrm{Kahan}} - S_{\\mathrm{exact}}| = 1$ 且 $|S_{\\mathrm{naive}} - S_{\\mathrm{exact}}| = 1$。条件 $|S_{\\mathrm{Kahan}} - S_{\\mathrm{exact}}| \\le |S_{\\mathrm{naive}} - S_{\\mathrm{exact}}|$ 得到满足（$1 \\le 1$）。\n\n**测试 B：$[1, \\underbrace{10^{-16}, \\ldots, 10^{-16}}_{N=50000}, -1]$，精确实数和 $S_{\\mathrm{exact}} = 50000 \\cdot 10^{-16} = 5 \\times 10^{-12}$。**\n- **朴素求和**：求和从 $1$ 开始。$1$ 的 ULP 是 $2^{-52} \\approx 2.22 \\times 10^{-16}$。被加的项 $10^{-16}$ 小于 $1$ 的 ULP，因此在每次加法中都被吞没。在所有 $50000$ 个小项相加后，运行总和保持为 $1$。最后的操作是 $\\operatorname{fl}(1 - 1) = 0$。绝对误差为 $|0 - 5 \\times 10^{-12}| = 5 \\times 10^{-12}$。\n- **Kahan 求和**：Kahan 求和正是为这种情况设计的。每次将 $10^{-16}$ 加到接近 $1$ 的运行总和中被吞没时，补偿变量 $c$ 将捕获丢失的量。这个被捕获的误差将在下一步中重新引入。这使得微小的增量能够被有效地累积，从而得到一个非常接近精确和的结果。误差将显著减小。\n- **比较**：Kahan 求和将精确得多。条件 $|S_{\\mathrm{Kahan}} - S_{\\mathrm{exact}}| \\le |S_{\\mathrm{naive}} - S_{\\mathrm{exact}}|$ 将成立。\n\n**测试 C：$[\\underbrace{10^{-10}, \\ldots, 10^{-10}}_{N=50000}, \\underbrace{-10^{-10}, \\ldots, -10^{-10}}_{N=50000}]$，精确实数和 $S_{\\mathrm{exact}} = 0$。**\n- **朴素求和**：该测试涉及对大量中等大小的小值求和。和首先累加到 $50000 \\times 10^{-10} = 5 \\times 10^{-6}$，然后减去这个量。虽然没有单一步骤涉及剧烈的吞没，但 $100000$ 次加法中的每一次都会引入一个小的舍入误差。这些误差会累积，并且来自正数阶段和负数阶段的误差不太可能完美抵消。最终结果将是某个小的非零值。\n- **Kahan 求和**：Kahan 求和优越的误差特性意味着累积误差将小得多。补偿变量将使运行总和在每一步都更接近真实的部分和。最终结果将显著接近 $0$。\n- **比较**：Kahan 求和将更精确。条件将成立。\n\n**测试 D：$[1, \\underbrace{10^{-310}, \\ldots, 10^{-310}}_{N=100000}]$，精确实数和 $S_{\\mathrm{exact}} = 1 + 100000 \\cdot 10^{-310} = 1 + 10^{-305}$。**\n- **朴素求和**：这是一个极端的吞没情况。值 $10^{-310}$ 在 binary64 中是一个非规格化数，并且比 $1$ 的 ULP（约 $2.22 \\times 10^{-16}$）小得惊人。加法 $\\operatorname{fl}(1 + 10^{-310})$ 的结果将恰好是 $1$。所有 $100000$ 次对 $10^{-310}$ 的加法都丢失了。最终的朴素求和结果是 $1$。绝对误差为 $|1 - (1 + 10^{-305})| = 10^{-305}$。\n- **Kahan 求和**：与测试 B 中一样，Kahan 算法的补偿机制将在每一步捕获变量 $c$ 中丢失的 $10^{-310}$ 并重新引入它。这使得微小的增量能够被正确累积，从而得出一个非常接近精确值的最终和。\n- **比较**：Kahan 求和将精确得多。条件将成立。\n\n在所有四种情况下，Kahan 求和的性能预计至少与朴素求和一样好，并且在大多数情况下明显优于后者。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport decimal\n\ndef solve():\n    \"\"\"\n    Implements naive and Kahan summation, runs them on specified test cases,\n    and compares their accuracy against a high-precision reference.\n    \"\"\"\n    # Set precision for decimal module to compute a high-accuracy reference sum.\n    # 80 digits is sufficient to ensure the reference is not an error source.\n    decimal.getcontext().prec = 80\n\n    def naive_sum(seq):\n        \"\"\"\n        Performs a naive left-to-right summation of a sequence of\n        IEEE 754 binary64 numbers.\n        \"\"\"\n        s = np.float64(0.0)\n        for x in seq:\n            s += x\n        return s\n\n    def kahan_sum(seq):\n        \"\"\"\n        Performs a compensated summation using the Kahan algorithm for a\n        sequence of IEEE 754 binary64 numbers.\n        \"\"\"\n        s = np.float64(0.0)\n        c = np.float64(0.0)  # A running compensation for lost low-order bits.\n        for x in seq:\n            y = x - c\n            t = s + y\n            # (t - s) is the high-order part of y that was successfully added.\n            # ((t - s) - y) is the negative of the low-order part of y that was lost.\n            c = (t - s) - y\n            s = t\n        return s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"float_seq\": [np.float64(1e16), np.float64(1.0), np.float64(-1e16)],\n            \"decimal_seq\": [decimal.Decimal('1e16'), decimal.Decimal('1'), decimal.Decimal('-1e16')],\n        },\n        {\n            \"name\": \"B\",\n            \"N\": 50000,\n            \"float_seq_gen\": lambda N: [np.float64(1.0)] + [np.float64('1e-16')] * N + [np.float64(-1.0)],\n            \"decimal_seq_gen\": lambda N: [decimal.Decimal('1')] + [decimal.Decimal('1e-16')] * N + [decimal.Decimal('-1')],\n        },\n        {\n            \"name\": \"C\",\n            \"N\": 50000,\n            \"float_seq_gen\": lambda N: [np.float64('1e-10')] * N + [np.float64('-1e-10')] * N,\n            \"decimal_seq_gen\": lambda N: [decimal.Decimal('1e-10')] * N + [decimal.Decimal('-1e-10')] * N,\n        },\n        {\n            \"name\": \"D\",\n            \"N\": 100000,\n            \"float_seq_gen\": lambda N: [np.float64(1.0)] + [np.float64('1e-310')] * N,\n            \"decimal_seq_gen\": lambda N: [decimal.Decimal('1')] + [decimal.Decimal('1e-310')] * N,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate sequences if they are defined by a generator\n        if 'float_seq_gen' in case:\n            N = case['N']\n            float_seq = case['float_seq_gen'](N)\n            decimal_seq = case['decimal_seq_gen'](N)\n        else:\n            float_seq = case['float_seq']\n            decimal_seq = case['decimal_seq']\n\n        # 1. Compute high-precision reference sum\n        s_exact = sum(decimal_seq)\n\n        # 2. Compute floating-point sums using both algorithms\n        s_naive = naive_sum(float_seq)\n        s_kahan = kahan_sum(float_seq)\n\n        # 3. Compute absolute errors\n        # Convert float results to Decimal via string to avoid binary representation issues\n        err_naive = abs(decimal.Decimal(str(s_naive)) - s_exact)\n        err_kahan = abs(decimal.Decimal(str(s_kahan)) - s_exact)\n\n        # 4. Compare errors and store the boolean result\n        is_kahan_no_worse = err_kahan = err_naive\n        results.append(is_kahan_no_worse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}