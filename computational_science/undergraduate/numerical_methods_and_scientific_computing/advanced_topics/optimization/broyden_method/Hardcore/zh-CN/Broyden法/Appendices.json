{
    "hands_on_practices": [
        {
            "introduction": "在 Broyden 方法中，最基本的计算是根据当前点 $x_k$ 和雅可比矩阵的近似 $B_k$ 来求解下一步的迭代点 $x_{k+1}$。本练习 () 将引导你完成这一核心计算步骤，通过求解线性系统 $B_k s_k = -F(x_k)$ 来确定搜索方向并更新解，从而巩固你对算法执行流程的理解。",
            "id": "2158069",
            "problem": "考虑由 $F(x) = 0$ 给出的非线性方程组，其中 $x = (x_1, x_2)^T$，函数 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 定义为：\n$$\nF(x) = \\begin{pmatrix} x_1^2 - x_2 + 1 \\\\ x_1 + x_2^2 - 3 \\end{pmatrix}\n$$\n你需要执行一步称为 Broyden 方法的割线更新拟牛顿法，以找到根的一个改进近似值。从初始猜测值 $x_0 = (1, 1)^T$ 开始，并使用雅可比矩阵的初始近似\n$$\nB_0 = \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix},\n$$\n计算下一个迭代值 $x_1$。将你的答案表示为一个包含两个分量的向量。",
            "solution": "给定系统 $F(x) = 0$，其中 $F: \\mathbb{R}^{2} \\to \\mathbb{R}^{2}$ 定义为\n$$\nF(x) = \\begin{pmatrix} x_{1}^{2} - x_{2} + 1 \\\\ x_{1} + x_{2}^{2} - 3 \\end{pmatrix},\n$$\n一个初始猜测值 $x_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$，以及一个初始雅可比近似\n$$\nB_{0} = \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix}.\n$$\n在 Broyden 方法中，下一个迭代值 $x_{1}$ 是通过首先求解线性系统\n$$\nB_{0} s_{0} = -F(x_{0}),\n$$\n然后更新\n$$\nx_{1} = x_{0} + s_{0}.\n$$\n\n首先计算 $F(x_{0})$：\n$$\nF(x_{0}) = \\begin{pmatrix} 1^{2} - 1 + 1 \\\\ 1 + 1^{2} - 3 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n$$\n使用 $B_{0} s_{0} = -F(x_{0})$ 求解 $s_{0}$。由于 $B_{0} = 2 I$，我们有\n$$\ns_{0} = B_{0}^{-1}\\big(-F(x_{0})\\big) = \\frac{1}{2} I \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix}.\n$$\n那么，\n$$\nx_{1} = x_{0} + s_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{3}{2} \\end{pmatrix}.\n$$\n因此，下一个迭代值是分量为 $\\frac{1}{2}$ 和 $\\frac{3}{2}$ 的向量。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{3}{2} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在计算出新的迭代点后，拟牛顿法的精髓在于如何更新其对雅可比矩阵的近似。本练习 () 专注于 Broyden 方法的秩一更新，它利用上一步的位移 $s_k$ 和函数值的变化 $y_k$ 来修正线性模型。通过这个实践，你将掌握 Broyden 算法的“学习”机制，即如何利用新信息来迭代地改进雅可比矩阵。",
            "id": "2158053",
            "problem": "在数值求解非线性方程组 $F(x) = 0$（其中 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$）的过程中，采用了一种拟牛顿法。方程根的初始猜测值为向量 $x_0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。在此点，函数值为 $F(x_0) = \\begin{pmatrix} -1 \\\\ 2 \\end{pmatrix}$。\n\n雅可比矩阵的初始近似选择为 2x2 的单位矩阵 $B_0 = I$。经过迭代法的第一步，得到新点 $x_1 = \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix}$，其对应的函数值为 $F(x_1) = \\begin{pmatrix} 0.5 \\\\ 0.5 \\end{pmatrix}$。\n\n使用所提供的信息，通过应用单步 Broyden “好”方法来计算更新后的雅可比矩阵近似值 $B_1$。请将您的答案表示为一个 2x2 矩阵。",
            "solution": "我们应用 Broyden “好”更新，该方法强制执行割线方程 $B_{1}s_{0}=y_{0}$，并最小化 $B$ 在弗罗贝尼乌斯范数下的变化。更新公式为\n$$\nB_{1}=B_{0}+\\frac{\\left(y_{0}-B_{0}s_{0}\\right)s_{0}^{T}}{s_{0}^{T}s_{0}}。\n$$\n根据数据，计算步长和函数差值：\n$$\ns_{0}=x_{1}-x_{0}=\\begin{pmatrix}2 \\\\ -1\\end{pmatrix}-\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}=\\begin{pmatrix}1 \\\\ -2\\end{pmatrix},\\quad\ny_{0}=F(x_{1})-F(x_{0})=\\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{1}{2}\\end{pmatrix}-\\begin{pmatrix}-1 \\\\ 2\\end{pmatrix}=\\begin{pmatrix}\\tfrac{3}{2} \\\\ -\\tfrac{3}{2}\\end{pmatrix}。\n$$\n当 $B_{0}=I$ 时，我们有\n$$\nB_{0}s_{0}=s_{0}=\\begin{pmatrix}1 \\\\ -2\\end{pmatrix},\\quad y_{0}-B_{0}s_{0}=\\begin{pmatrix}\\tfrac{3}{2} \\\\ -\\tfrac{3}{2}\\end{pmatrix}-\\begin{pmatrix}1 \\\\ -2\\end{pmatrix}=\\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{1}{2}\\end{pmatrix},\n$$\n以及\n$$\ns_{0}^{T}s_{0}=1^{2}+(-2)^{2}=5。\n$$\n构造秩一修正项：\n$$\n\\frac{\\left(y_{0}-B_{0}s_{0}\\right)s_{0}^{T}}{s_{0}^{T}s_{0}}=\\frac{1}{5}\\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{1}{2}\\end{pmatrix}\\begin{pmatrix}1  -2\\end{pmatrix}\n=\\frac{1}{5}\\begin{pmatrix}\\tfrac{1}{2}  -1 \\\\ \\tfrac{1}{2}  -1\\end{pmatrix}\n=\\begin{pmatrix}\\tfrac{1}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  -\\tfrac{1}{5}\\end{pmatrix}。\n$$\n因此，\n$$\nB_{1}=I+\\begin{pmatrix}\\tfrac{1}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  -\\tfrac{1}{5}\\end{pmatrix}\n=\\begin{pmatrix}1+\\tfrac{1}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  1-\\tfrac{1}{5}\\end{pmatrix}\n=\\begin{pmatrix}\\tfrac{11}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  \\tfrac{4}{5}\\end{pmatrix}。\n$$\n快速检验可知 $B_{1}s_{0}=\\begin{pmatrix}\\tfrac{3}{2} \\\\ -\\tfrac{3}{2}\\end{pmatrix}=y_{0}$，这证实了割线条件。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\tfrac{11}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  \\tfrac{4}{5}\\end{pmatrix}}$$"
        },
        {
            "introduction": "Broyden 方法的一个惊人特性是，即使雅可比矩阵的近似序列 $B_k$ 没有收敛到解 $x^*$ 处的真实雅可比矩阵 $J(x^*)$，解的序列 $x_k$ 依然可以收敛到 $x^*$。这个高级实践 () 将通过一个精心设计的例子来揭示这一深刻现象。通过对比其在线性与非线性系统上的行为，你将深入理解该方法为何在不追求完美雅可比近似的情况下依然高效。",
            "id": "3211914",
            "problem": "你需要设计并实现一个程序，以演示用于求解非线性方程组的 Broyden 方法的一个核心现象：对于一个非线性二维系统，近似雅可比矩阵序列（记为 $B_k$）可以收敛到一个与解 $x^*$ 处的真实雅可比矩阵 $J(x^*)$ 不同的矩阵，而迭代点 $x_k$ 仍然收敛到根。你必须使用的基本原理是：通过迭代法求解向量值函数 $F:\\mathbb{R}^n \\to \\mathbb{R}^n$ 的方程 $F(x) = 0$ 的定义、使用雅可比矩阵的牛顿迭代法，以及作为 Broyden 方法等拟牛顿法基础的割线条件。在构建算法的推理过程中，除了这些核心定义，你不能假定任何特殊公式。你的程序必须实现标准的 Broyden 更新，该更新强制执行割线条件，并在每次迭代中寻求在弗罗贝尼乌斯范数意义下对近似雅可比矩阵的最小更改。\n\n使用 Broyden 方法为一个二维系统（即 $n = 2$）实现一个求解器，并满足以下要求：\n- 使用迭代 $x_{k+1} = x_k + s_k$，其中 $s_k$ 是 $B_k s_k = -F(x_k)$ 的解，而 $B_k$ 是当前对雅可比矩阵的近似。如果 $B_k$ 是奇异或接近奇异的，则使用通过伪逆计算的最小二乘步，或使用标准数值线性代数规则范围内的等效稳定回退方法。对步长使用简单的回溯策略，以确保序列 $\\|F(x_k)\\|_2$ 不会增加。\n- 在每一步使用经典的（所谓的“好”）Broyden 公式更新 $B_k$，该公式强制执行最近的割线方程，并在所有满足割线条件的秩一更新中，产生弗罗贝尼乌斯范数意义下 $B_k$ 的最小变化。不要硬编码任何与特定 $F$ 相关的特殊情况代数简化。\n- 当 $\\|F(x_k)\\|_2 \\le \\varepsilon_f$ 或 $\\|s_k\\|_2 \\le \\varepsilon_s$（其中 $\\varepsilon_f$ 和 $\\varepsilon_s$ 为预设容差）或达到最大迭代次数 $N_{\\max}$ 时终止。所有范数对向量是欧几里得范数，对矩阵是弗罗贝尼乌斯范数。\n\n你将在以下小型测试套件上测试你的实现，每个测试都带有完全指定的数据和用于比较的精确根。此任务不涉及物理单位。如果出现任何角度，都将以弧度为单位，但这里不需要对有量纲的角度使用三角函数。\n\n定义非线性系统 $F_{\\mathrm{nl}}:\\mathbb{R}^2 \\to \\mathbb{R}^2$ 为\n$$\nF_{\\mathrm{nl}}(x) =\n\\begin{bmatrix}\nx_1^2 + x_2 - 1 \\\\\nx_1 + x_2^2 - 1\n\\end{bmatrix},\n$$\n其解析雅可比矩阵为\n$$\nJ_{\\mathrm{nl}}(x) =\n\\begin{bmatrix}\n2 x_1  1 \\\\\n1  2 x_2\n\\end{bmatrix}.\n$$\n该系统有一个精确根位于 $x^*_{\\mathrm{nl}} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n定义线性系统 $F_{\\mathrm{lin}}:\\mathbb{R}^2 \\to \\mathbb{R}^2$ 为\n$$\nF_{\\mathrm{lin}}(x) = A x - b, \\quad A = \\begin{bmatrix} 3  1 \\\\ 1  2 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\n$$\n其常数雅可比矩阵为 $J_{\\mathrm{lin}}(x) \\equiv A$，精确根为 $x^*_{\\mathrm{lin}} = A^{-1} b$。\n\n你的程序必须按顺序运行这三个测试用例，使用指定的 Broyden 方法：\n- 测试 $1$ （理想路径，非线性）：使用 $F_{\\mathrm{nl}}$，初始猜测 $x_0 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$，初始近似雅可比矩阵 $B_0 = I_2$ （$2 \\times 2$ 单位矩阵），残差容差 $\\varepsilon_f = 10^{-10}$，步长容差 $\\varepsilon_s = 10^{-12}$，以及最大迭代次数 $N_{\\max} = 200$。终止后，计算两个输出：\n  - $d_1 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{nl}}\\|_2$,\n  - $e_1 = \\|B_{\\mathrm{final}} - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$.\n- 测试 $2$ （边界情况，从根开始）：使用 $F_{\\mathrm{nl}}$，初始猜测 $x_0 = x^*_{\\mathrm{nl}} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，初始近似雅可比矩阵 $B_0 = 2 I_2$，容差 $\\varepsilon_f = 10^{-10}$、$\\varepsilon_s = 10^{-12}$，以及最大迭代次数 $N_{\\max} = 200$。由于起始点是精确根，该方法应立即终止，不进行任何更新。计算：\n  - $d_2 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{nl}}\\|_2$,\n  - $e_2 = \\|B_{\\mathrm{final}} - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$.\n- 测试 $3$ （与线性系统对比）：使用 $F_{\\mathrm{lin}}$，初始猜测 $x_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$，初始近似雅可比矩阵 $B_0 = I_2$，容差 $\\varepsilon_f = 10^{-12}$、$\\varepsilon_s = 10^{-12}$，以及最大迭代次数 $N_{\\max} = 50$。计算：\n  - $d_3 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{lin}}\\|_2$,\n  - $e_3 = \\|B_{\\mathrm{final}} - A\\|_F$.\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，并按此确切顺序包含六个浮点值：\n$$\n[d_1, e_1, d_2, e_2, d_3, e_3].\n$$\n输出中不要包含任何空格。这些值应表示为十进制浮点数（科学记数法是可接受的）。不应打印任何额外文本。",
            "solution": "该问题要求实现 Broyden 方法来求解非线性方程组 $F(x) = 0$，并展示该方法的一个关键特性：即使迭代点 $x_k$ 收敛到根 $x^*$，近似雅可比矩阵序列 $B_k$ 也不一定会收敛到根处的真实雅可比矩阵 $J(x^*)$。\n\n**$1$. Broyden 方法：基础**\n\nBroyden 方法是一种拟牛顿法。求解 $F(x)=0$ 的牛顿法遵循迭代式 $x_{k+1} = x_k - J(x_k)^{-1} F(x_k)$，其中 $J(x_k)$ 是 $F$ 在 $x_k$ 处的雅可比矩阵。这需要在每一步计算和求逆雅可比矩阵，计算成本可能很高。\n\n拟牛顿法用一个近似值 $B_k$ 替代真实的雅可比矩阵 $J(x_k)$。迭代过程变为：\n$1$. 求解线性系统 $B_k s_k = -F(x_k)$ 以获得步长 $s_k$。\n$2$. 更新解：$x_{k+1} = x_k + s_k$。\n\n其核心思想是以一种计算开销小的方式将 $B_k$ 更新为 $B_{k+1}$，并融入关于函数 $F$ 的新信息。该更新基于割线条件，这是一维求根割线法的多维推广。割线条件要求新的近似雅可比矩阵 $B_{k+1}$ 能正确关联最近一步中 $x$ 的变化与 $F$ 的变化：\n$$B_{k+1} s_k = y_k$$\n其中 $s_k = x_{k+1} - x_k$ 且 $y_k = F(x_{k+1}) - F(x_k)$。\n\n**$2$. “好”Broyden 更新**\n\n有无穷多个矩阵 $B_{k+1}$ 满足割线方程。Broyden 的“好”方法选择在弗罗贝尼乌斯范数意义下最接近前一个近似 $B_k$ 的矩阵 $B_{k+1}$，并以割线条件为约束。这是一个约束优化问题：\n$$\\min_{B} \\|B - B_k\\|_F \\quad \\text{subject to} \\quad B s_k = y_k$$\n这个问题的解是对 $B_k$ 的一个秩-1 更新：\n$$B_{k+1} = B_k + \\frac{(y_k - B_k s_k) s_k^T}{s_k^T s_k}$$\n这个公式是我们实现中雅可比矩阵近似更新的核心。项 $y_k - B_k s_k$ 表示 $F$ 的实际变化与当前近似 $B_k$ 预测的变化之间的差异。这个差异被用来沿步长 $s_k$ 的方向“校正”$B_k$。\n\n**$3$. 算法实现**\n\n求解器被构建为一个迭代循环，在每次迭代 $k$ 中包含以下关键部分：\n\n*   **步长计算**：通过求解线性系统 $B_k s_k = -F(x_k)$ 来找到步长 $s_k$。为增强对迭代过程中可能出现的奇异或病态矩阵 $B_k$ 的鲁棒性，我们采用了一个最小二乘求解器。这等同于使用 Moore-Penrose 伪逆，找到最小化 $\\|B_k s_k + F(x_k)\\|_2$ 的解 $s_k = -B_k^\\dagger F(x_k)$。在 NumPy 中，`numpy.linalg.lstsq` 提供了此功能。\n\n*   **线搜索**：一个完整的步长 $s_k$ 可能不会导致残差范数 $\\|F(x)\\|_2$ 减小。为确保稳健收敛，使用了一个简单的回溯线搜索。我们从步长 $\\alpha=1$ 开始，并相继减小它（例如，每次减半），直到满足条件 $\\|F(x_k + \\alpha s_k)\\|_2   \\|F(x_k)\\|_2$。这确保了每一步都朝着解前进。最终采纳的步长是 $\\alpha s_k$。\n\n*   **雅可比矩阵更新**：在走出导致 $x_{k+1} = x_k + s_k$ 的步长 $s_k$ 后，使用上面提到的 Broyden 公式计算新的雅可比矩阵近似 $B_{k+1}$。为避免数值不稳定，如果步长范数 $\\|s_k\\|_2$ 接近 $0$，则跳过更新，因为这将涉及除以一个非常小的数。\n\n*   **终止条件**：当满足以下任一标准时，迭代停止：$1$. 残差的范数低于容差：$\\|F(x_k)\\|_2 \\le \\varepsilon_f$。$2$. 步长的范数低于容差：$\\|s_k\\|_2 \\le \\varepsilon_s$。这表明迭代点不再有显著变化。$3$. 达到了最大迭代次数 $N_{\\max}$。\n\n**$4$. 测试用例分析**\n\n该算法应用于 `$3$` 个测试用例以观察其行为。\n\n*   **测试 $1$ （非线性系统）**：从 $x_0 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$ 和 $B_0=I_2$ 开始，将该方法应用于非线性系统 $F_{\\mathrm{nl}}$。迭代点 $x_k$ 预期会收敛到根 $x^*_{\\mathrm{nl}} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，因此距离 $d_1 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{nl}}\\|_2$ 应接近 $0$。然而，随着迭代点的收敛，步长 $s_k$ 可能会在一个特定方向上变得对齐（子空间集中）。Broyden 更新只在这些方向上强制执行割线条件。因此， $B_k$ 中对应于正交方向的分量没有得到改进。所以，最终矩阵 $B_{\\mathrm{final}}$ 可能不等于真实雅可比矩阵 $J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})$，且误差 $e_1 = \\|B_{\\mathrm{final}} - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$ 预期为非 $0$。在根处的真实雅可比矩阵是 $J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}}) = \\begin{bmatrix} 2  1 \\\\ 1  0 \\end{bmatrix}$。\n\n*   **测试 $2$ （边界情况）**：该方法从精确根 $x_0 = x^*_{\\mathrm{nl}}$ 开始。初始残差 $\\|F(x_0)\\|_2$ 为 $0$。算法会正确识别这一点并在第一次检查时终止，不执行任何步骤或更新。因此，$x_{\\mathrm{final}} = x_0$ 且 $B_{\\mathrm{final}} = B_0$。距离 $d_2$ 将为 $0$。误差 $e_2 = \\|B_0 - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$ 将为非 $0$，计算为 $\\|2I_2 - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$。\n\n*   **测试 $3$ （线性系统）**：将该方法应用于线性系统 $F(x) = Ax-b$。对于线性系统，函数值的变化是 $y_k = F(x_{k+1}) - F(x_k) = A(x_{k+1}-x_k) = As_k$。Broyden 更新变为 $B_{k+1} = B_k + \\frac{(A-B_k)s_k s_k^T}{s_k^T s_k}$。这个更新具有 $(B_{k+1}-A)s_k=0$ 的性质。在 $n$ 维空间中，如果该方法生成了 $n$ 个线性无关的步长，$B_{n}$ 将等于 $A$。已知 Broyden 方法对于线性系统最多在 $2n$ 次迭代内终止。对于这个二维情况，收敛应该非常快，并且最终的近似 $B_{\\mathrm{final}}$ 预期会非常接近真实的（且恒定的）雅可比矩阵 $A$。误差 $d_3$ 和 $e_3$ 都应接近 $0$。\n\n这组结构化的测试阐明了 Broyden 方法在不同场景下的基本行为，特别突出了迭代点 $x_k$ 的收敛与近似雅可比矩阵 $B_k$ 的收敛之间的区别。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef broyden_solver(F, x0, B0, tol_f, tol_s, max_iter):\n    \"\"\"\n    Solves a system of nonlinear equations F(x) = 0 using Broyden's method.\n\n    Args:\n        F (callable): The vector-valued function to find a root of.\n        x0 (np.ndarray): The initial guess for the solution x.\n        B0 (np.ndarray): The initial guess for the Jacobian matrix.\n        tol_f (float): Tolerance for the norm of the residual F(x).\n        tol_s (float): Tolerance for the norm of the step s.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        tuple: A tuple (x, B) containing the final solution iterate and the\n               final approximate Jacobian.\n    \"\"\"\n    x = np.array(x0, dtype=float)\n    B = np.array(B0, dtype=float)\n    \n    Fx = F(x)\n    \n    for _ in range(max_iter):\n        # 1. Check termination on residual norm\n        if np.linalg.norm(Fx) = tol_f:\n            break\n            \n        # 2. Solve for the step s_trial = -B_k^{-1} F(x_k)\n        # We use lstsq for robustness against singularity.\n        try:\n            s_trial = np.linalg.lstsq(B, -Fx, rcond=None)[0]\n        except np.linalg.LinAlgError:\n            # This is a fallback, but lstsq should generally not fail.\n            # If it does, the matrix is extremely ill-conditioned. Stop iteration.\n            break\n\n        # 3. Check termination on step size (before backtracking)\n        if np.linalg.norm(s_trial) = tol_s:\n            break\n\n        # 4. Backtracking line search\n        alpha = 1.0\n        norm_Fx = np.linalg.norm(Fx)\n        x_next = x + alpha * s_trial\n        Fx_next = F(x_next)\n        \n        # Backtrack until the residual norm is not increasing. Limit to 10 steps.\n        for _ in range(10):\n            if np.linalg.norm(Fx_next)  norm_Fx:\n                break\n            alpha /= 2.0\n            x_next = x + alpha * s_trial\n            Fx_next = F(x_next)\n        else: # if loop finished without break, step is not productive\n            # Could indicate stalling, so we halt.\n            break\n\n        s = x_next - x\n        y = Fx_next - Fx\n        \n        # 5. Update Jacobian B using Broyden's \"good\" formula\n        # B_{k+1} = B_k + (y_k - B_k s_k)s_k^T / (s_k^T s_k)\n        s_norm_sq = np.dot(s, s)\n        if s_norm_sq > 1e-14: # Avoid division by zero for very small steps\n            update_vec = y - B @ s\n            B += np.outer(update_vec, s) / s_norm_sq\n            \n        # 6. Update x and Fx for the next iteration\n        x = x_next\n        Fx = Fx_next\n        \n    return x, B\n\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # --- Define Systems and Exact Solutions ---\n    def F_nl(x):\n        return np.array([\n            x[0]**2 + x[1] - 1.0, \n            x[0] + x[1]**2 - 1.0\n        ])\n\n    def J_nl(x):\n        return np.array([\n            [2.0 * x[0], 1.0], \n            [1.0, 2.0 * x[1]]\n        ])\n    \n    A = np.array([[3.0, 1.0], [1.0, 2.0]])\n    b = np.array([1.0, 0.0])\n    def F_lin(x):\n        return A @ x - b\n\n    x_star_nl = np.array([1.0, 0.0])\n    x_star_lin = np.linalg.solve(A, b)\n\n    results = []\n\n    # --- Test Case 1: Nonlinear system, standard start ---\n    x0_1 = [0.5, 0.5]\n    B0_1 = np.identity(2)\n    tol_f_1, tol_s_1, N_max_1 = 1e-10, 1e-12, 200\n    \n    x_final_1, B_final_1 = broyden_solver(F_nl, x0_1, B0_1, tol_f_1, tol_s_1, N_max_1)\n    \n    d1 = np.linalg.norm(x_final_1 - x_star_nl)\n    J_star_nl = J_nl(x_star_nl)\n    e1 = np.linalg.norm(B_final_1 - J_star_nl, ord='fro')\n    results.extend([d1, e1])\n\n    # --- Test Case 2: Nonlinear system, start at root ---\n    x0_2 = x_star_nl\n    B0_2 = 2.0 * np.identity(2)\n    tol_f_2, tol_s_2, N_max_2 = 1e-10, 1e-12, 200\n\n    x_final_2, B_final_2 = broyden_solver(F_nl, x0_2, B0_2, tol_f_2, tol_s_2, N_max_2)\n    \n    d2 = np.linalg.norm(x_final_2 - x_star_nl)\n    e2 = np.linalg.norm(B_final_2 - J_star_nl, ord='fro')\n    results.extend([d2, e2])\n\n    # --- Test Case 3: Linear system ---\n    x0_3 = [0.0, 0.0]\n    B0_3 = np.identity(2)\n    tol_f_3, tol_s_3, N_max_3 = 1e-12, 1e-12, 50\n\n    x_final_3, B_final_3 = broyden_solver(F_lin, x0_3, B0_3, tol_f_3, tol_s_3, N_max_3)\n    \n    d3 = np.linalg.norm(x_final_3 - x_star_lin)\n    e3 = np.linalg.norm(B_final_3 - A, ord='fro')\n    results.extend([d3, e3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}