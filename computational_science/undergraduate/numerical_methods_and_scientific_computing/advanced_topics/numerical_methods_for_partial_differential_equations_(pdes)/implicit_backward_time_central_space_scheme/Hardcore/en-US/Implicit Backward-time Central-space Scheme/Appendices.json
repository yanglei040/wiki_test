{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering any numerical method is to build it from the ground up. This practice focuses on implementing a versatile Backward-Time Central-Space (BTCS) solver for the one-dimensional diffusion equation. You will derive the discrete equations for both Dirichlet and Neumann boundary conditions, translating theory into a robust and flexible code that can handle a variety of physical scenarios .",
            "id": "3241116",
            "problem": "You are to design and implement a program that solves the one-dimensional diffusion equation using the implicit backward-time central-space (BTCS) scheme while flexibly switching between Dirichlet and Neumann boundary conditions on either boundary, controlled by a configuration object. The governing partial differential equation is the linear parabolic model on a bounded interval,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,L], \\ t \\in (0,T],\n$$\nwhere $u=u(x,t)$ is the scalar field of interest and $\\alpha>0$ is the diffusivity. The initial condition is\n$$\nu(x,0)=u_0(x), \\quad x \\in [0,L],\n$$\nand each boundary at $x=0$ and $x=L$ independently satisfies either a Dirichlet condition,\n$$\nu(0,t)=g_L(t) \\ \\text{or} \\ u(L,t)=g_R(t),\n$$\nor a Neumann condition,\n$$\n\\frac{\\partial u}{\\partial x}(0,t)=q_L(t) \\ \\text{or} \\ \\frac{\\partial u}{\\partial x}(L,t)=q_R(t).\n$$\nYour discretization must start from the following fundamental base: (i) the definition of the time derivative as a backward difference in time over a uniform time grid of step size $\\Delta t$, (ii) the definition of the second spatial derivative as a central second difference over a uniform spatial grid with mesh spacing $\\Delta x$, and (iii) the precise meaning of Dirichlet and Neumann boundary conditions. You may assume smoothness sufficient for second-order spatial accuracy and first-order temporal accuracy. Do not assume or use any formula not derivable from these bases.\n\nYou must derive and implement a fully implicit scheme consistent with the backward difference in time and the central difference in space at interior grid points. At boundaries, impose the Dirichlet or Neumann conditions in a way that is consistent with the same order of accuracy as the interior discretization, without introducing ghost unknowns in the final linear system. Your derivation must show clearly how boundary equations differ from interior equations and how boundary data $g_L(t)$, $g_R(t)$, $q_L(t)$, $q_R(t)$ enter the right-hand side. Use a uniform spatial mesh of $M$ nodes on $[0,L]$ (that is, $M$ includes both boundary nodes), so that $\\Delta x = L/(M-1)$. Use a uniform time step $\\Delta t$ and advance from time $t^n=n\\Delta t$ to $t^{n+1}=(n+1)\\Delta t$.\n\nYour program must:\n- Build a single linear system per time step for the vector of all nodal unknowns at time $t^{n+1}$, with coefficients determined by the BTCS discretization and the boundary condition types on the left and right ends.\n- Allow either boundary to be Dirichlet or Neumann, with corresponding data functions $g_L(t)$, $g_R(t)$, $q_L(t)$, $q_R(t)$ evaluated at $t^{n+1}$.\n- Accept a configuration-like data structure (hard-coded within your program; no files or external input are allowed) specifying $L$, $\\alpha$, $M$, $\\Delta t$, $T$, boundary condition types and data, and the initial condition function $u_0(x)$.\n- For verification, use manufactured exact solutions $u_{\\text{exact}}(x,t)$ for which both the interior equation and the chosen boundary conditions hold for all $t\\in[0,T]$. Initialize with $u_0(x)=u_{\\text{exact}}(x,0)$.\n\nTest suite. Implement and run the following five test cases, each specified by a configuration object inside your program. In every case, take the diffusivity $\\alpha=1$ unless otherwise stated, and report the maximum absolute error at the final time $T$ between the numerical and exact solutions over all grid nodes. The five cases are:\n- Case $1$ (Dirichlet–Dirichlet, homogeneous, sine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Dirichlet with $g_L(t)=0$, right boundary Dirichlet with $g_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$ with $\\lambda=1$.\n- Case $2$ (Neumann–Neumann, homogeneous, cosine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Neumann with $q_L(t)=0$, right boundary Neumann with $q_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$ with $\\lambda=1$.\n- Case $3$ (Dirichlet–Neumann, homogeneous, half-integer sine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Dirichlet with $g_L(t)=0$, right boundary Neumann with $q_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$ with $\\lambda=\\tfrac{1}{2}$.\n- Case $4$ (Neumann–Dirichlet, homogeneous, half-integer cosine mode): $L=\\pi$, $M=101$, $\\Delta t=5\\times 10^{-4}$, $T=5\\times 10^{-2}$, left boundary Neumann with $q_L(t)=0$, right boundary Dirichlet with $g_R(t)=0$, exact solution $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$ with $\\lambda=\\tfrac{1}{2}$.\n- Case $5$ (steady linear solution, mixed nonhomogeneous): $L=1$, $M=51$, $\\Delta t=10^{-2}$, $T=10^{-1}$, left boundary Dirichlet with $g_L(t)=2$, right boundary Neumann with $q_R(t)=-\\tfrac{3}{2}$, exact solution $u_{\\text{exact}}(x,t)=ax+b$ with $a=-\\tfrac{3}{2}$ and $b=2$ (time-independent).\n\nFinal output format. Your program should produce a single line of output containing the maximum absolute error at time $T$ for each of the five cases, as a comma-separated list of decimal numbers enclosed in square brackets, ordered as Cases $1$ through $5$. For example, an output for three hypothetical cases would look like\n$$\n[\\text{err}_1,\\text{err}_2,\\text{err}_3]\n$$\nbut your program must output five entries corresponding to the five cases above.",
            "solution": "The task is to derive and implement the implicit backward-time central-space (BTCS) scheme for the one-dimensional diffusion equation, $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$, on a bounded domain $x \\in [0,L]$ with options for Dirichlet or Neumann boundary conditions at each end. The derivation will proceed from first principles as specified.\n\nLet the spatial domain $[0,L]$ be discretized into a uniform grid with $M$ nodes, indexed by $i=0, 1, \\dots, M-1$. The grid points are $x_i = i\\Delta x$, where the mesh spacing is $\\Delta x = L/(M-1)$. The time domain is discretized with a uniform step size $\\Delta t$, with time levels denoted by $t^n = n\\Delta t$. The numerical approximation of the solution $u(x_i, t^n)$ is denoted by $u_i^n$.\n\nThe BTCS scheme is formulated by approximating the time derivative using a first-order backward finite difference and the spatial second derivative using a second-order central finite difference, both evaluated at the future time level $t^{n+1}$. The governing partial differential equation (PDE) is thus discretized as:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2}\n$$\nThis equation establishes a relationship between the known solution at time $t^n$ and the unknown solution at time $t^{n+1}$.\n\nLet's define the dimensionless parameter $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$. Rearranging the discretized equation to group the unknown terms (at level $n+1$) on the left-hand side (LHS) and known terms (at level $n$) on the right-hand side (RHS) gives the equation for an interior node $i \\in \\{1, 2, \\dots, M-2\\}$:\n$$\n-s u_{i-1}^{n+1} + (1+2s) u_i^{n+1} - s u_{i+1}^{n+1} = u_i^n\n$$\nThese equations form a system of linear equations for the unknown vector $\\mathbf{u}^{n+1} = [u_0^{n+1}, u_1^{n+1}, \\dots, u_{M-1}^{n+1}]^T$. The specific form of the first ($i=0$) and last ($i=M-1$) equations in the system depends on the boundary conditions.\n\nThe boundary conditions must be discretized with an accuracy consistent with the interior scheme, i.e., second-order in space. We will now derive the equations for each boundary without introducing ghost nodes into the final linear system.\n\n**Left Boundary ($x=0$, node $i=0$)**\n\n1.  **Dirichlet Condition**: $u(0,t) = g_L(t)$.\n    The condition is applied directly at the new time level $t^{n+1}$. The value of the unknown $u_0^{n+1}$ is explicitly given:\n    $$\n    u_0^{n+1} = g_L(t^{n+1})\n    $$\n    This translates into the first row of the linear system as $1 \\cdot u_0^{n+1} = g_L(t^{n+1})$.\n\n2.  **Neumann Condition**: $\\frac{\\partial u}{\\partial x}(0,t) = q_L(t)$.\n    To achieve second-order accuracy, we use a central difference for the spatial derivative around $x_0$. This requires a \"ghost\" node at $x_{-1} = -\\Delta x$. The derivative is approximated at $t^{n+1}$ as:\n    $$\n    \\frac{u_1^{n+1} - u_{-1}^{n+1}}{2\\Delta x} = q_L(t^{n+1})\n    $$\n    From this, we can express the ghost value $u_{-1}^{n+1}$ as $u_{-1}^{n+1} = u_1^{n+1} - 2\\Delta x q_L(t^{n+1})$. We then apply the general PDE discretization at the boundary node $i=0$:\n    $$\n    -s u_{-1}^{n+1} + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    Substituting the expression for $u_{-1}^{n+1}$ eliminates the ghost node:\n    $$\n    -s (u_1^{n+1} - 2\\Delta x q_L(t^{n+1})) + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    Grouping terms yields the final equation for the first row of the system:\n    $$\n    (1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - 2s\\Delta x q_L(t^{n+1})\n    $$\n    Noting that $2s\\Delta x = 2 \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\Delta x = \\frac{2\\alpha\\Delta t}{\\Delta x}$, the equation is $(1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$.\n\n**Right Boundary ($x=L$, node $i=M-1$)**\n\n1.  **Dirichlet Condition**: $u(L,t) = g_R(t)$.\n    Similar to the left boundary, the condition at $t^{n+1}$ provides the value for $u_{M-1}^{n+1}$ directly:\n    $$\n    u_{M-1}^{n+1} = g_R(t^{n+1})\n    $$\n    This defines the last row of the linear system as $1 \\cdot u_{M-1}^{n+1} = g_R(t^{n+1})$.\n\n2.  **Neumann Condition**: $\\frac{\\partial u}{\\partial x}(L,t) = q_R(t)$.\n    Using a central difference around $x_{M-1}$ requires a ghost node at $x_M = L+\\Delta x$:\n    $$\n    \\frac{u_M^{n+1} - u_{M-2}^{n+1}}{2\\Delta x} = q_R(t^{n+1})\n    $$\n    This gives the ghost value as $u_M^{n+1} = u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})$. Applying the PDE discretization at $i=M-1$:\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s u_M^{n+1} = u_{M-1}^n\n    $$\n    Substituting the expression for $u_M^{n+1}$:\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s (u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})) = u_{M-1}^n\n    $$\n    Grouping terms gives the final equation for the last row of the system:\n    $$\n    -2s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} = u_{M-1}^n + 2s\\Delta x q_R(t^{n+1})\n    $$\n    The term involving the boundary data is $\\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$.\n\n**Matrix System Formulation**\n\nAt each time step, we solve a linear system $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{u}^{n+1}$. The matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ are constructed as follows:\n\nLet $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$.\nThe matrix $\\mathbf{A}$ is an $M \\times M$ matrix, and $\\mathbf{b}$ is a vector of size $M$.\n\n**Interior Rows ($i = 1, \\dots, M-2$):**\n-   $A_{i,i-1} = -s$\n-   $A_{i,i} = 1+2s$\n-   $A_{i,i+1} = -s$\n-   $b_i = u_i^n$\n\n**First Row ($i=0$):**\n-   If Left BC is Dirichlet: $A_{0,0}=1$, and all other $A_{0,j}=0$. $b_0 = g_L(t^{n+1})$.\n-   If Left BC is Neumann: $A_{0,0}=1+2s$, $A_{0,1}=-2s$. $b_0 = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$.\n\n**Last Row ($i=M-1$):**\n-   If Right BC is Dirichlet: $A_{M-1,M-1}=1$, and all other $A_{M-1,j}=0$. $b_{M-1} = g_R(t^{n+1})$.\n-   If Right BC is Neumann: $A_{M-1,M-2}=-2s$, $A_{M-1,M-1}=1+2s$. $b_{M-1} = u_{M-1}^n + \\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$.\n\n**Overall Algorithm:**\n\n1.  Initialize parameters from the test case configuration.\n2.  Set up the spatial grid $x_i$ for $i=0, \\dots, M-1$.\n3.  Compute the initial solution vector $\\mathbf{u}^0$ using $u_i^0 = u_{\\text{exact}}(x_i, 0)$.\n4.  Iterate through time steps from $n=0$ until the final time $T$ is reached. In each step:\n    a. Determine the current time $t^{n+1} = (n+1)\\Delta t$.\n    b. Construct the matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ according to the specified boundary conditions and the formulas derived above.\n    c. Solve the linear system $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ to find the solution at the new time level.\n    d. Update the solution for the next iteration: $\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$.\n5.  After the final time step, compute the exact solution $\\mathbf{u}_{\\text{exact}}$ at time $T$.\n6.  Calculate the maximum absolute error between the final numerical solution and the exact solution: $\\max_i |u_i^{\\text{final}} - u_{\\text{exact}}(x_i, T)|$.\nThis process is repeated for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the BTCS diffusion solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Dirichlet-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.sin(1 * x)\n        },\n        # Case 2: Neumann-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.cos(1 * x)\n        },\n        # Case 3: Dirichlet-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.sin(0.5 * x)\n        },\n        # Case 4: Neumann-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.cos(0.5 * x)\n        },\n        # Case 5: Dirichlet-Neumann, non-homogeneous steady state\n        {\n            \"L\": 1.0, \"alpha\": 1.0, \"M\": 51, \"dt\": 1e-2, \"T\": 1e-1,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 2.0, \"g_R\": lambda t: 0.0,  # g_R not used\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: -1.5, # q_L not used\n            \"u_exact\": lambda x, t, alpha: -1.5 * x + 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_btcs_simulation(case)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_btcs_simulation(params):\n    \"\"\"\n    Executes a single simulation run for the 1D diffusion equation using BTCS.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the simulation.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    # Unpack parameters\n    L = params[\"L\"]\n    alpha = params[\"alpha\"]\n    M = params[\"M\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    \n    # Grid setup\n    dx = L / (M - 1)\n    x = np.linspace(0, L, M)\n    \n    # Dimensionless parameter\n    s = alpha * dt / (dx**2)\n    \n    # Time stepping\n    num_steps = int(round(T / dt))\n    \n    # Initial condition\n    u = params[\"u_exact\"](x, 0, alpha)\n\n    # Time evolution loop\n    for n in range(num_steps):\n        t_next = (n + 1) * dt\n        \n        # Setup the linear system A u_next = b\n        A = np.zeros((M, M))\n        b = np.zeros(M)\n        \n        # Interior points\n        for i in range(1, M - 1):\n            A[i, i-1] = -s\n            A[i, i]   = 1 + 2*s\n            A[i, i+1] = -s\n            b[i]      = u[i]\n            \n        # Boundary conditions\n        # Left boundary (i=0)\n        if params[\"bc_left_type\"] == \"dirichlet\":\n            A[0, 0] = 1.0\n            b[0] = params[\"g_L\"](t_next)\n        elif params[\"bc_left_type\"] == \"neumann\":\n            A[0, 0] = 1 + 2*s\n            A[0, 1] = -2*s\n            b[0] = u[0] - (2 * alpha * dt / dx) * params[\"q_L\"](t_next)\n\n        # Right boundary (i=M-1)\n        if params[\"bc_right_type\"] == \"dirichlet\":\n            A[M-1, M-1] = 1.0\n            b[M-1] = params[\"g_R\"](t_next)\n        elif params[\"bc_right_type\"] == \"neumann\":\n            A[M-1, M-2] = -2*s\n            A[M-1, M-1] = 1 + 2*s\n            b[M-1] = u[M-1] + (2 * alpha * dt / dx) * params[\"q_R\"](t_next)\n        \n        # Solve the system for the next time step\n        u_next = np.linalg.solve(A, b)\n        u = u_next\n\n    # Calculate final error\n    u_final_exact = params[\"u_exact\"](x, T, alpha)\n    max_error = np.max(np.abs(u - u_final_exact))\n    \n    return max_error\n\nsolve()\n```"
        },
        {
            "introduction": "A numerical solver is only as good as our confidence in its correctness. This exercise employs the Method of Manufactured Solutions, a powerful technique to rigorously verify the accuracy of your code . By performing systematic grid refinement studies, you will empirically confirm the theoretical convergence rates of the BTCS scheme, which is first-order in time ($O(\\Delta t)$) and second-order in space ($O((\\Delta x)^2)$), a critical skill for validating any scientific computing software.",
            "id": "3241236",
            "problem": "Consider the one-dimensional heat conduction model defined on the spatial interval $[0,1]$ and time interval $[0,T]$,\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t),\n$$\nwith Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$ for all $t \\in [0,T]$, and initial condition $u(x,0)=\\sin(\\pi x)$. Use the method of manufactured solutions to verify the accuracy of the Implicit Backward-Time Central-Space (BTCS) scheme, formally known as the Backward-Time Central-Space (BTCS) scheme.\n\nYou will start from the following fundamental bases:\n- The definition of the heat equation and central finite differences: for a sufficiently smooth function $u$, the spatial second derivative is approximated by\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t) \\approx \\frac{u(x_{i-1},t) - 2u(x_i,t) + u(x_{i+1},t)}{(\\Delta x)^2},\n$$\nand the backward Euler time derivative is\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_{n+1}) \\approx \\frac{u(x_i,t_{n+1}) - u(x_i,t_n)}{\\Delta t}.\n$$\n- The method of manufactured solutions: choose a smooth function $\\tilde{u}(x,t)$, substitute it into the partial differential equation, and define $f(x,t)$ so that $\\tilde{u}(x,t)$ becomes the exact solution to the forced problem.\n\nTask:\n1. Choose the manufactured solution $\\tilde{u}(x,t)=e^{t}\\sin(\\pi x)$ and, using calculus, derive the corresponding source term $f(x,t)$ so that $\\tilde{u}(x,t)$ exactly satisfies the model equation.\n2. Discretize the spatial domain with grid points $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N_x-1$, where $\\Delta x = 1/(N_x-1)$, and the time domain with time levels $t_n = n\\,\\Delta t$ for $n=0,1,\\dots,N_t$. Impose the Dirichlet boundary conditions $u_0^n = 0$ and $u_{N_x-1}^n=0$ for all $n$, and the initial condition $u_i^0 = \\sin(\\pi x_i)$ for $i=1,\\dots,N_x-2$.\n3. Derive and implement the BTCS linear system at each time step $t_{n+1}$ for the interior nodes $i=1,\\dots,N_x-2$ by combining the backward Euler time approximation and the central spatial approximation, and using the source $f$ evaluated at time $t_{n+1}$.\n4. Advance the solution from $t=0$ to $t=T$ by solving the resulting tridiagonal linear system at each time step. Compute the error at the final time $t=T$ by comparing the numerical solution $u_i^{N_t}$ with the exact $\\tilde{u}(x_i,T)$ using the discrete $L^2$ norm\n$$\nE_{L^2} \\;=\\; \\left(\\Delta x\\sum_{i=1}^{N_x-2}\\left(u_i^{N_t}-\\tilde{u}(x_i,T)\\right)^2\\right)^{1/2}\n$$\nand the discrete $L^\\infty$ norm\n$$\nE_{L^\\infty} \\;=\\; \\max_{1\\le i \\le N_x-2}\\left|u_i^{N_t}-\\tilde{u}(x_i,T)\\right|.\n$$\n\nEmpirical convergence verification:\n- To verify the time accuracy order $O(\\Delta t)$, use a very fine spatial grid to make the spatial error negligible and perform a time refinement study. Fix $\\alpha=0.1$, set $T=0.2$, choose $N_x=1001$, and run the BTCS scheme for the four time step counts $N_t\\in\\{10,20,40,80\\}$, corresponding to $\\Delta t\\in\\{0.02,0.01,0.005,0.0025\\}$. For each run, compute $E_{L^2}$ at $t=T$. Estimate the observed time-convergence order $p_t$ by fitting a line to $(\\log(\\Delta t),\\log(E_{L^2}))$ via least squares and taking the slope.\n- To verify the spatial accuracy order $O((\\Delta x)^2)$, use a very small time step to make the time error negligible and perform a spatial refinement study. Fix $\\alpha=0.1$, set $T=0.01$, choose $N_t=1000$ (so $\\Delta t=0.00001$), and run the BTCS scheme for $N_x\\in\\{33,65,129,257\\}$, corresponding to spatial steps halved each refinement. For each run, compute $E_{L^2}$ at $t=T$. Estimate the observed spatial-convergence order $p_x$ by fitting a line to $(\\log(\\Delta x),\\log(E_{L^2}))$ via least squares and taking the slope.\n- Edge case robustness check: test with a very coarse grid to ensure the linear system assembly and boundary handling are correct. Fix $\\alpha=0.1$, set $T=0.1$, choose $N_x=5$, and $N_t=5$ (so $\\Delta t=0.02$). Compute the final-time discrete infinity-norm error $E_{L^\\infty}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order $[p_t,p_x,E_{L^\\infty}]$. All three entries must be real numbers. No additional text should be printed.\n\nTest suite summary:\n- Time refinement (expected $O(\\Delta t)$): $\\alpha=0.1$, $T=0.2$, $N_x=1001$, $N_t\\in\\{10,20,40,80\\}$.\n- Space refinement (expected $O((\\Delta x)^2)$): $\\alpha=0.1$, $T=0.01$, $N_t=1000$, $N_x\\in\\{33,65,129,257\\}$.\n- Edge case: $\\alpha=0.1$, $T=0.1$, $N_x=5$, $N_t=5$.\n\nAll quantities are dimensionless; no physical units are required.",
            "solution": "The problem requires the derivation, implementation, and verification of the Backward-Time Central-Space (BTCS) scheme for the one-dimensional heat equation using the method of manufactured solutions. The solution is presented in four parts: derivation of the analytical source term, derivation of the discrete numerical scheme, an outline of the empirical verification process, and a summary of the algorithm.\n\n**Step 1: Derivation of the Source Term**\n\nThe method of manufactured solutions is employed to create a problem with a known analytical solution, which serves as a benchmark for verifying the numerical code. The governing partial differential equation (PDE) is:\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t)\n$$\nWe choose the manufactured solution $\\tilde{u}(x,t) = e^{t}\\sin(\\pi x)$. This function satisfies the boundary conditions $u(0,t)=e^t\\sin(0)=0$ and $u(1,t)=e^t\\sin(\\pi)=0$, and the initial condition $u(x,0)=e^0\\sin(\\pi x)=\\sin(\\pi x)$. To find the corresponding source term $f(x,t)$, we compute the partial derivatives of $\\tilde{u}(x,t)$:\nThe time derivative is:\n$$\n\\frac{\\partial \\tilde{u}}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( e^t \\sin(\\pi x) \\right) = e^t \\sin(\\pi x)\n$$\nThe second spatial derivative is:\n$$\n\\frac{\\partial^2 \\tilde{u}}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( e^t \\sin(\\pi x) \\right) = \\frac{\\partial}{\\partial x} \\left( \\pi e^t \\cos(\\pi x) \\right) = -\\pi^2 e^t \\sin(\\pi x)\n$$\nSubstituting these into the PDE allows us to solve for $f(x,t)$:\n$$\ne^t \\sin(\\pi x) = \\alpha \\left( -\\pi^2 e^t \\sin(\\pi x) \\right) + f(x,t)\n$$\n$$\nf(x,t) = e^t \\sin(\\pi x) + \\alpha \\pi^2 e^t \\sin(\\pi x) = (1 + \\alpha \\pi^2)e^t \\sin(\\pi x)\n$$\nThis derived source term ensures that $\\tilde{u}(x,t)$ is the exact solution to the problem.\n\n**Step 2: Derivation of the BTCS Discretization**\n\nThe BTCS scheme is formulated by discretizing the PDE on a grid with spatial points $x_i = i\\Delta x$ and time levels $t_n = n\\Delta t$. We approximate the time derivative using a first-order backward Euler difference and the spatial derivative using a second-order central difference, both evaluated at the future time level $t_{n+1}$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\alpha \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta x)^2} \\right) + f(x_i, t_{n+1})\n$$\nwhere $u_i^n \\approx u(x_i, t_n)$. This scheme is implicit, as it couples several unknown values at the time level $n+1$. To solve it, we rearrange the equation into a linear system. Let $c = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ be the diffusion number. We group all unknown terms (at time $n+1$) on the left-hand side (LHS) and known terms (at time $n$) on the right-hand side (RHS):\n$$\nu_i^{n+1} - c (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n + \\Delta t f_i^{n+1}\n$$\n$$\n-c u_{i-1}^{n+1} + (1 + 2c)u_i^{n+1} - c u_{i+1}^{n+1} = u_i^n + \\Delta t f_i^{n+1}\n$$\nThis equation is valid for all interior grid points, $i = 1, 2, \\dots, N_x-2$. Given the Dirichlet boundary conditions $u_0^{n+1}=0$ and $u_{N_x-1}^{n+1}=0$, these equations form a tridiagonal linear system $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$ for the vector of interior unknowns $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_{N_x-2}^{n+1}]^T$. The $(N_x-2) \\times (N_x-2)$ matrix $A$ is:\n$$\nA = \\begin{pmatrix}\n1+2c & -c & 0 & \\dots & 0 \\\\\n-c & 1+2c & -c & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & -c & 1+2c & -c \\\\\n0 & \\dots & 0 & -c & 1+2c\n\\end{pmatrix}\n$$\nThe RHS vector $\\mathbf{b}^n$ depends on the solution at the previous time step $n$ and the source term at step $n+1$. At each time step, this system must be solved to find the solution at the next time level.\n\n**Step 3: Empirical Convergence Verification**\n\nThe theoretical accuracy of the BTCS scheme is $O(\\Delta t)$ in time and $O((\\Delta x)^2)$ in space. The total error $E$ is approximately $E \\approx C_t (\\Delta t)^{p_t} + C_x (\\Delta x)^{p_x}$, where $p_t=1$ and $p_x=2$ are the convergence orders.\nTo empirically measure $p_t$, a time-refinement study is conducted. By using a very fine spatial grid ($N_x=1001$), the spatial error term $C_x (\\Delta x)^2$ becomes negligible. The error is then dominated by the time discretization, $E \\approx C_t (\\Delta t)^{p_t}$. Taking the logarithm gives $\\log(E) \\approx \\log(C_t) + p_t \\log(\\Delta t)$. The order $p_t$ is the slope of the line fitted to the $(\\log(\\Delta t), \\log(E))$ data points.\nSimilarly, to measure $p_x$, a spatial-refinement study is performed. By using a very small time step ($N_t=1000$), the temporal error term $C_t (\\Delta t)^{p_t}$ becomes negligible, so $E \\approx C_x (\\Delta x)^{p_x}$. The order $p_x$ is then the slope of the line fitted to the $(\\log(\\Delta x), \\log(E))$ data.\n\n**Step 4: Algorithmic Implementation**\n\nThe numerical solution is computed as follows:\n1.  Initialize parameters $\\alpha$, $T$, $N_x$, $N_t$ and calculate grid spacings $\\Delta x$ and $\\Delta t$.\n2.  Set up the spatial grid $x$ and initialize the solution vector $u$ using the initial condition $u(x,0)=\\sin(\\pi x)$.\n3.  Construct the constant tridiagonal matrix $A$ for the given parameters.\n4.  Iterate from $n=0$ to $N_t-1$. In each iteration:\n    a. Calculate the next time level $t_{n+1}$.\n    b. Assemble the RHS vector $\\mathbf{b}^n$ using the solution from the previous step, $u^n$, and the source term $f(x,t_{n+1})$.\n    c. Solve the linear system $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$ to get the solution at the interior points for the next time step.\n    d. Update the full solution vector, keeping the boundary values at $0$.\n5.  After the loop, compute the final error at $t=T$ using either the $L^2$ or $L^\\infty$ norm as required by comparing the final numerical solution to the exact manufactured solution.\n6.  For the convergence studies, repeat this process for each set of refinement parameters, collect the errors, and perform a linear least-squares fit on the log-log data to find the slopes $p_t$ and $p_x$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_btcs_and_get_error(alpha, T, Nx, Nt, error_norm_type):\n    \"\"\"\n    Runs the BTCS simulation for the 1D heat equation with a source term\n    and returns the specified error norm against the manufactured solution.\n\n    Args:\n        alpha (float): Thermal diffusivity constant.\n        T (float): Final time.\n        Nx (int): Number of spatial grid points.\n        Nt (int): Number of time steps.\n        error_norm_type (str): Type of error norm to compute ('L2' or 'L_inf').\n\n    Returns:\n        float: The computed error value.\n    \"\"\"\n    # Define the manufactured solution and the corresponding source term\n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    # Discretization parameters\n    dx = 1.0 / (Nx - 1)\n    dt = T / Nt\n    x = np.linspace(0, 1, Nx)\n    \n    # Grid for interior points\n    x_interior = x[1:-1]\n    M = Nx - 2  # Number of interior points\n\n    # Diffusion number\n    c = alpha * dt / (dx**2)\n\n    # Initial condition. The vector u_current includes boundary points.\n    u_current = u_exact(x, 0.0)\n    \n    # Construct the tridiagonal matrix A for a single time step.\n    # The matrix is constant for fixed parameters.\n    A = np.zeros((M, M))\n    np.fill_diagonal(A, 1.0 + 2.0 * c)\n    np.fill_diagonal(A[1:], -c)\n    np.fill_diagonal(A[:, 1:], -c)\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_next = (n + 1) * dt\n        \n        # Get the solution at interior points from the previous time step\n        u_current_interior = u_current[1:-1]\n        \n        # Construct the RHS vector b = u_current_interior + dt * f(t_next)\n        f_vec = f_source(x_interior, t_next, alpha)\n        b = u_current_interior + dt * f_vec\n        \n        # Dirichlet boundary conditions u(0,t)=0 and u(1,t)=0 are handled implicitly\n        # because the terms involving u_0 and u_{Nx-1} are zero and do not\n        # contribute to the RHS vector for the interior problem.\n        \n        # Solve the linear system A * u_next_interior = b\n        u_next_interior = np.linalg.solve(A, b)\n        \n        # Update solution vector for the next time step. Boundaries remain zero.\n        u_current[1:-1] = u_next_interior\n        \n    # At t=T, u_current holds the final numerical solution\n    u_numerical_final = u_current\n    \n    # Calculate the exact solution at the final time T\n    u_exact_final = u_exact(x, T)\n\n    # Calculate the error vector at interior points\n    error_vec = u_numerical_final[1:-1] - u_exact_final[1:-1]\n    \n    # Compute the requested error norm\n    if error_norm_type == 'L2':\n        error_val = np.sqrt(dx * np.sum(error_vec**2))\n    elif error_norm_type == 'L_inf':\n        error_val = np.max(np.abs(error_vec))\n    else:\n        raise ValueError(\"Invalid error_norm_type specified.\")\n        \n    return error_val\n\ndef solve():\n    \"\"\"\n    Performs the three specified tasks: time refinement, space refinement,\n    and an edge case test, printing the results in the required format.\n    \"\"\"\n    # --- Task 1: Time refinement study to find p_t ---\n    alpha_t = 0.1\n    T_t = 0.2\n    Nx_t = 1001\n    Nt_t_vals = [10, 20, 40, 80]\n    \n    dt_vals = [T_t / N for N in Nt_t_vals]\n    errors_t = []\n    for Nt_t in Nt_t_vals:\n        error = run_btcs_and_get_error(alpha_t, T_t, Nx_t, Nt_t, 'L2')\n        errors_t.append(error)\n        \n    # Fit a line to (log(dt), log(error)) to find the convergence order p_t\n    log_dt = np.log(dt_vals)\n    log_errors_t = np.log(errors_t)\n    p_t = np.polyfit(log_dt, log_errors_t, 1)[0]\n\n    # --- Task 2: Spatial refinement study to find p_x ---\n    alpha_x = 0.1\n    T_x = 0.01\n    Nt_x = 1000\n    Nx_x_vals = [33, 65, 129, 257]\n    \n    dx_vals = [1.0 / (N - 1) for N in Nx_x_vals]\n    errors_x = []\n    for Nx_x in Nx_x_vals:\n        error = run_btcs_and_get_error(alpha_x, T_x, Nx_x, Nt_x, 'L2')\n        errors_x.append(error)\n        \n    # Fit a line to (log(dx), log(error)) to find the convergence order p_x\n    log_dx = np.log(dx_vals)\n    log_errors_x = np.log(errors_x)\n    p_x = np.polyfit(log_dx, log_errors_x, 1)[0]\n\n    # --- Task 3: Edge case robustness check ---\n    alpha_e = 0.1\n    T_e = 0.1\n    Nx_e = 5\n    Nt_e = 5\n    E_Linf = run_btcs_and_get_error(alpha_e, T_e, Nx_e, Nt_e, 'L_inf')\n\n    # Final print statement in the exact required format\n    print(f\"[{p_t},{p_x},{E_Linf}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond stability and accuracy, different numerical schemes have unique qualitative properties that make them suitable for different problems. This practice investigates the important concept of positivity-preservation by comparing the BTCS scheme with the popular Crank-Nicolson method . You will discover how BTCS can guarantee non-negative solutions for non-negative initial data, a crucial feature for modeling physical quantities like temperature or concentration, while other schemes may produce non-physical oscillations.",
            "id": "3241221",
            "problem": "Consider the one-dimensional heat equation with homogeneous Dirichlet boundary conditions on a unit interval, modeled as a pure diffusion process. Let $u(x,t)$ satisfy $u_t = \\alpha u_{xx}$ for $x \\in (0,1)$ and $t > 0$, with $u(0,t) = 0$ and $u(1,t) = 0$, and an initial condition that is nonnegative and sharply localized. You will compare the positivity behavior of two time-stepping schemes for this problem: Backward-Time Central-Space (BTCS) and Crank-Nicolson (CN), when the initial data have sharp gradients.\n\nYour task is to implement a fully discrete scheme on a uniform grid of $N$ interior points with grid spacing $\\Delta x = 1/(N+1)$, using a single time step. Use the following fundamental base:\n- The partial differential equation $u_t = \\alpha u_{xx}$.\n- The backward difference in time to approximate a time derivative, defined by replacing $u_t$ at a new time level by a backward finite difference.\n- The central difference in space to approximate a second derivative, defined by replacing $u_{xx}$ by a second-order central difference stencil over nearest neighbors.\n- The Crank-Nicolson time discretization is obtained by applying the trapezoidal rule in time to the spatial operator, averaging its value at the old and new time levels.\n\nUse a standard staggered-in-space formulation with $N$ interior points and homogeneous Dirichlet boundary conditions incorporated directly into the discrete operator. Represent the second spatial derivative with the canonical three-point central difference stencil on the interior grid.\n\nImplement both schemes as linear systems for the new time level:\n- BTCS (an implicit backward Euler time step with central space differencing).\n- CN (a trapezoidal-in-time average of the spatial operator with the same central space differencing).\n\nTo probe positivity, choose a discrete initial condition that has a sharp gradient: set $u_i^0 = 1$ at exactly one interior node (the unique center index when $N$ is odd) and $u_i^0 = 0$ for all other interior nodes. This is a discrete, nonnegative spike with zero boundary values. Use dimensionless variables with $\\alpha = 1$.\n\nDefine the dimensionless mesh Fourier number $r = \\alpha \\Delta t / \\Delta x^2$. For each test, select $\\Delta t$ to realize a specified $r$ exactly, using the fixed grid and $\\alpha = 1$. Evolve exactly one time step for each scheme from this initial data.\n\nFor each test case $r$, determine the minimum value after one time step for each scheme. Declare that a scheme exhibits an undershoot if the minimum value is strictly negative within a tight numerical tolerance (use an absolute tolerance of $10^{-12}$). For each test case $r$, return a boolean that is true precisely when BTCS avoids undershoot while CN exhibits undershoot.\n\nTest suite:\n- Use $N = 99$ interior points (so there is a unique centered spike).\n- Use $\\alpha = 1$ (dimensionless).\n- Use one time step only ($1$ step).\n- Use $r$ values in the set $\\{0.2, 1.0, 1.2, 2.5\\}$.\n\nOutput specification:\n- For each $r$ in the order listed above, compute a boolean value equal to true if and only if BTCS has no undershoot (minimum value greater than or equal to zero within tolerance) and CN has an undershoot (minimum value strictly less than zero within tolerance).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the same order as the test suite $r$ values. For example, an output could look like $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$.\n\nAll quantities are dimensionless; no physical units are required. Angles are not involved. Percentages are not involved; no percentage-based quantities appear in this task.",
            "solution": "The problem requires a comparison of the positivity-preserving properties of the Backward-Time Central-Space (BTCS) and Crank-Nicolson (CN) schemes when solving the one-dimensional heat equation, $u_t = \\alpha u_{xx}$. We will discretize the equation for $N$ interior points and analyze the behavior of each scheme after a single time step, starting from a sharp, non-negative initial condition.\n\nLet $\\mathbf{u}^n = [u_1^n, \\dots, u_N^n]^T$ be the vector of solution values at the interior grid points at time $t_n$. The spatial second derivative with homogeneous Dirichlet boundary conditions is approximated by the matrix operator $\\alpha \\mathbf{L}$, where $\\mathbf{L}$ is the standard tridiagonal discrete Laplacian with entries on the order of $1/\\Delta x^2$. The semi-discretized system is $\\frac{d\\mathbf{u}}{dt} = \\alpha \\mathbf{L} \\mathbf{u}$.\n\n**1. Backward-Time Central-Space (BTCS) Scheme**\n\nThe BTCS scheme applies the backward Euler method for time integration:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\alpha \\mathbf{L} \\mathbf{u}^{n+1}\n$$\nRearranging to solve for the unknown vector $\\mathbf{u}^{n+1}$, we get the linear system:\n$$\n(\\mathbf{I} - \\alpha \\Delta t \\mathbf{L}) \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\nLet $r = \\alpha \\Delta t / \\Delta x^2$ be the mesh Fourier number. The system matrix, $\\mathbf{A}_{\\text{BTCS}} = (\\mathbf{I} - \\alpha \\Delta t \\mathbf{L})$, is a tridiagonal matrix with $(1+2r)$ on the main diagonal and $-r$ on the super- and sub-diagonals. For any $r>0$, this is a strictly diagonally dominant M-matrix. A key property of M-matrices is that their inverses contain only non-negative entries. Therefore, if the right-hand side $\\mathbf{u}^n$ is non-negative, the solution $\\mathbf{u}^{n+1} = \\mathbf{A}_{\\text{BTCS}}^{-1} \\mathbf{u}^n$ is also guaranteed to be non-negative. This proves that BTCS is unconditionally positivity-preserving.\n\n**2. Crank-Nicolson (CN) Scheme**\n\nThe CN scheme applies the trapezoidal rule for time integration, averaging the spatial operator at time levels $n$ and $n+1$:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} (\\alpha \\mathbf{L} \\mathbf{u}^{n+1} + \\alpha \\mathbf{L} \\mathbf{u}^n)\n$$\nRearranging gives the linear system:\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^n\n$$\nThe positivity of the solution $\\mathbf{u}^{n+1}$ now depends on the operator on the right-hand side. The matrix on the right, $\\mathbf{B}_{\\text{CN}} = (\\mathbf{I} + \\frac{\\alpha \\Delta t}{2} \\mathbf{L})$, has $(1-r)$ on its main diagonal and $r/2$ on the off-diagonals. For the output vector $\\mathbf{B}_{\\text{CN}}\\mathbf{u}^n$ to be guaranteed non-negative for any non-negative input $\\mathbf{u}^n$, all entries of $\\mathbf{B}_{\\text{CN}}$ must be non-negative. This requires $1-r \\ge 0$, which means $r \\le 1$.\n\nIf $r > 1$, the diagonal elements of $\\mathbf{B}_{\\text{CN}}$ become negative. When this operator is applied to a sharp initial condition like a single spike, it can introduce negative values into the right-hand side vector, leading to non-physical oscillations and negative values (undershoots) in the final solution $\\mathbf{u}^{n+1}$. Thus, the CN scheme is only conditionally positivity-preserving.\n\nThe implementation will construct these linear systems, solve them for one time step with the specified spike initial condition for various values of $r$, and check the minimum value of the resulting solution vector to test these theoretical predictions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Compares the positivity of BTCS and Crank-Nicolson schemes for the 1D heat equation.\n    \"\"\"\n\n    # --- Test Suite Parameters ---\n    N = 99  # Number of interior grid points\n    alpha = 1.0  # Diffusion coefficient\n    r_values = [0.2, 1.0, 1.2, 2.5]  # Dimensionless mesh Fourier numbers\n    tolerance = 1e-12\n\n    # --- Initial Condition ---\n    # Sharply localized spike at the center of the grid.\n    # N=99 is odd, so there is a unique center index.\n    u0 = np.zeros(N)\n    center_index = (N - 1) // 2\n    u0[center_index] = 1.0\n\n    results = []\n    for r in r_values:\n        # --- BTCS (Backward-Time Central-Space) Scheme ---\n        # The system is A_btcs * u1 = u0\n        \n        # Construct the tridiagonal matrix A_btcs\n        diag_main_btcs = (1 + 2 * r) * np.ones(N)\n        diag_off_btcs = -r * np.ones(N - 1)\n        A_btcs = np.diag(diag_main_btcs) + np.diag(diag_off_btcs, k=1) + np.diag(diag_off_btcs, k=-1)\n\n        # Right-hand side is simply the initial condition\n        b_btcs = u0\n\n        # Solve for the new time step\n        u1_btcs = np.linalg.solve(A_btcs, b_btcs)\n\n        # Check for undershoot\n        min_btcs = np.min(u1_btcs)\n        btcs_no_undershoot = (min_btcs >= -tolerance)\n\n        # --- Crank-Nicolson (CN) Scheme ---\n        # The system is A_cn * u1 = B_cn * u0\n        \n        # Construct the left-hand side matrix A_cn\n        diag_main_cn = (1 + r) * np.ones(N)\n        diag_off_cn = -r / 2.0 * np.ones(N - 1)\n        A_cn = np.diag(diag_main_cn) + np.diag(diag_off_cn, k=1) + np.diag(diag_off_cn, k=-1)\n        \n        # Construct the right-hand side vector b_cn = B_cn * u0.\n        # Since u0 is a spike at center_index, b_cn is just the center_index'th\n        # column of B_cn, where B_cn has diagonals (1-r) and off-diagonals (r/2).\n        b_cn = np.zeros(N)\n        b_cn[center_index] = 1.0 - r\n        if center_index > 0:\n            b_cn[center_index - 1] = r / 2.0\n        if center_index < N - 1:\n            b_cn[center_index + 1] = r / 2.0\n\n        # Solve for the new time step\n        u1_cn = np.linalg.solve(A_cn, b_cn)\n\n        # Check for undershoot\n        min_cn = np.min(u1_cn)\n        cn_undershoot = (min_cn < -tolerance)\n\n        # --- Evaluate Condition ---\n        # The condition is True if BTCS has no undershoot AND CN has an undershoot.\n        final_result = btcs_no_undershoot and cn_undershoot\n        results.append(final_result)\n\n    # Final print statement in the exact required format.\n    # Python's str(True) is 'True', which matches the format implied by the example.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}