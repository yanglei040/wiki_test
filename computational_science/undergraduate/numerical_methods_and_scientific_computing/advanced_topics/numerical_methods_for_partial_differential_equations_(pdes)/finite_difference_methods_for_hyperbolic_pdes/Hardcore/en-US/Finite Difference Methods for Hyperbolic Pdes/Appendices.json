{
    "hands_on_practices": [
        {
            "introduction": "The simplest hyperbolic PDE, the linear advection equation, describes how a quantity is transported at a constant speed without changing its shape. A robust numerical scheme must respect the direction of this transport, a principle known as \"upwinding,\" which is a direct consequence of the method of characteristics. This practice challenges you to implement a scheme that correctly captures this directional information flow by adapting its spatial stencil based on the sign of the wave speed, providing a foundational understanding of how to build physically-motivated finite difference methods .",
            "id": "3229222",
            "problem": "Consider the linear first-order advection equation $u_t + a\\,u_x = 0$ on the periodic spatial domain $x \\in [0,1)$ with a smooth, localized, dimensionless initial profile. The second-order wave equation $u_{tt} = c^2\\,u_{xx}$ admits the D'Alembert representation $u(x,t) = f(x - c t) + g(x + c t)$, which can be interpreted as superposition of two solutions to the first-order advection equation, traveling with speeds $a = +c$ and $a = -c$, respectively. In this problem, you will algorithmically simulate advection for negative and positive speeds and interpret the resulting propagation directions in the context of the wave equation's left- and right-moving components.\n\nStarting from fundamental principles, use the periodic domain $[0,1)$ and the following dimensionless initial condition:\n$$\nu(x,0) \\equiv u_0(x) = \\exp\\!\\big(-50\\,d(x)^2\\big),\\quad d(x) = \\left[(x - 0.5) - \\mathrm{round}(x - 0.5)\\right],\n$$\nwhere $\\mathrm{round}(\\cdot)$ maps a real number to the nearest integer, so that $d(x)$ is the minimal periodic distance to $0.5$. This produces a single, smooth, localized “bump” centered at $x=0.5$ with a periodic extension.\n\nYour tasks are:\n- Derive, from first principles appropriate for hyperbolic conservation laws and characteristics, a first-order accurate, monotone upwind finite difference method tailored to $u_t + a\\,u_x = 0$ that respects periodic boundary conditions on $[0,1)$. The discretization must select the correct spatial difference direction based on the sign of $a$ and satisfy the Courant–Friedrichs–Lewy (CFL) condition.\n- Implement this method on a uniform grid with $N=400$ points, grid spacing $\\Delta x = 1/N$, and time step $\\Delta t$ chosen via a specified CFL number $\\nu$ according to the requirement that $|a|\\,\\Delta t / \\Delta x = \\nu$ when $|a|>0$. When $|a|=0$, take $\\Delta t = \\nu\\,\\Delta x$. Advance the solution to a final time $T$ exactly by using an integer number of time steps.\n- Use periodic boundary conditions and compute the analytical solution $u(x,T) = u_0(x - a T \\,\\mathrm{mod}\\, 1)$ by evaluating $u_0$ pointwise at shifted coordinates (with periodic wrapping), and then compute the discrete $L^2$ error\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\big(u_i^{\\text{num}} - u_i^{\\text{exact}}\\big)^2\\right)^{1/2}.\n$$\n- Infer the simulated propagation direction by comparing the centroid (first moment) of the numerical solution at $t=0$ and $t=T$. Let\n$$\nx_{\\mathrm{cm}}(t) = \\frac{\\sum_{i} x_i\\,u_i(t)}{\\sum_{i} u_i(t)}.\n$$\nDefine the direction flag $D$ as $D=\\mathrm{sign}\\big(x_{\\mathrm{cm}}(T) - x_{\\mathrm{cm}}(0)\\big)$ with the convention that $D \\in \\{-1,0,+1\\}$, where $-1$ indicates leftward propagation, $+1$ indicates rightward propagation, and $0$ indicates stationary behavior (use a small threshold to treat negligible displacements as $0$).\n\nAll quantities are dimensionless. Angles do not appear. No physical units are required.\n\nTest suite:\n- Case $1$: $a=-1.0$, $\\nu=0.9$, $T=0.25$.\n- Case $2$: $a=-2.0$, $\\nu=0.8$, $T=0.10$.\n- Case $3$: $a=+1.0$, $\\nu=0.9$, $T=0.25$.\n- Case $4$: $a=0.0$, $\\nu=0.9$, $T=0.25$.\n- Case $5$: $a=-1.0$, $\\nu=1.0$, $T=0.25$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E_1,D_1,E_2,D_2,E_3,D_3,E_4,D_4,E_5,D_5]$, where $E_k$ are floats and $D_k$ are integers for the corresponding cases, evaluated on the specified grid with the specified method and parameters, to the exact final time $T$.",
            "solution": "The problem requires the numerical simulation of the one-dimensional linear advection equation, $u_t + a u_x = 0$, on a periodic domain, and the analysis of the results. The problem statement is validated to be self-contained, scientifically sound, and well-posed.\n\n### Derivation of the First-Order Upwind Method\n\nThe governing partial differential equation (PDE) is the linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the conserved quantity and $a$ is the constant advection speed.\n\nThis equation belongs to the class of hyperbolic PDEs. Its solutions can be understood through the method of characteristics. The characteristic curves are lines in the $(x,t)$-plane along which the solution $u$ is constant. These curves are defined by the ordinary differential equation:\n$$\n\\frac{dx}{dt} = a\n$$\nAlong these curves, the total derivative of $u$ is:\n$$\n\\frac{d}{dt} u(x(t), t) = \\frac{\\partial u}{\\partial t} + \\frac{dx}{dt} \\frac{\\partial u}{\\partial x} = u_t + a u_x = 0\n$$\nThis implies that $u$ is invariant along the characteristics. Therefore, the value of the solution at a point $(x_i, t_n + \\Delta t)$ is equal to the value of the solution at the point $(x_i - a\\Delta t, t_n)$, which lies on the same characteristic curve at the previous time step.\n$$\nu(x_i, t_n + \\Delta t) = u(x_i - a\\Delta t, t_n)\n$$\nTo create a finite difference scheme, we must approximate the value $u(x_i - a\\Delta t, t_n)$ using the known values at the grid points $\\{x_j\\}$ at time $t_n$. The upwind method arises from a first-order interpolation that respects the direction of information flow.\n\nWe use a uniform grid with spatial spacing $\\Delta x$ and time step $\\Delta t$. Let $u_i^n \\approx u(x_i, t_n)$.\n\n**Case 1: $a > 0$ (Rightward Propagation)**\nThe information propagates from left to right. The point $x_i - a\\Delta t$ is located to the left of $x_i$. For a stable scheme, the Courant–Friedrichs–Lewy (CFL) condition requires the domain of dependence of the numerical scheme to contain that of the PDE. This leads to the condition $a \\frac{\\Delta t}{\\Delta x} \\le 1$. With this, the point $x_i - a\\Delta t$ lies within the interval $[x_{i-1}, x_i]$.\n\nThe upwind principle dictates approximating the spatial derivative $\\frac{\\partial u}{\\partial x}$ at $x_i$ using values from the \"upwind\" direction, which is the negative $x$-direction in this case. We use a first-order backward difference approximation:\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x_i, t_n} \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\nDiscretizing the time derivative with a forward Euler step, $\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$, the PDE becomes:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_i^n - u_{i-1}^n}{\\Delta x} \\right) = 0\n$$\nSolving for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n)\n$$\nDefining the CFL number as $\\nu = |a|\\frac{\\Delta t}{\\Delta x} = a\\frac{\\Delta t}{\\Delta x}$ for $a > 0$, the scheme is:\n$$\nu_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)\n$$\n\n**Case 2: $a  0$ (Leftward Propagation)**\nThe information propagates from right to left. The point $x_i - a\\Delta t$ is to the right of $x_i$. The upwind direction is now the positive $x$-direction. We use a first-order forward difference for the spatial derivative:\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x_i, t_n} \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\nThe semi-discretized equation is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_{i+1}^n - u_i^n}{\\Delta x} \\right) = 0\n$$\nSolving for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n$$\nHere, the CFL number is $\\nu = |a|\\frac{\\Delta t}{\\Delta x} = -a\\frac{\\Delta t}{\\Delta x}$, so $a\\frac{\\Delta t}{\\Delta x} = -\\nu$. The scheme becomes:\n$$\nu_i^{n+1} = u_i^n - (-\\nu) (u_{i+1}^n - u_i^n) = u_i^n + \\nu (u_{i+1}^n - u_i^n)\n$$\n\n**Case 3: $a = 0$ (Stationary)**\nThe PDE simplifies to $u_t = 0$. The solution is constant in time. The numerical scheme should reflect this:\n$$\nu_i^{n+1} = u_i^n\n$$\nBoth derived formulas correctly reduce to this result when $a=0$ (and thus $\\nu=0$ based on the problem's CFL definition for $a \\neq 0$, although for $a=0$ our update logic will just perform $u_i^{n+1} = u_i^n$).\n\nThe stability condition for this explicit first-order upwind scheme is $0 \\le \\nu \\le 1$.\n\n### Implementation Details\n\n**Numerical Grid and Time Stepping:**\nThe spatial domain $[0,1)$ is discretized into $N=400$ points, $x_i = i \\Delta x$ for $i=0, \\dots, N-1$, with $\\Delta x = 1/N$. Periodic boundary conditions are enforced by taking indices modulo $N$.\nThe final time $T$ must be reached in an integer number of steps. Given a CFL number $\\nu$, the base time step is calculated as $\\Delta t_{base} = \\nu \\Delta x / |a|$ for $a \\neq 0$ and $\\Delta t_{base} = \\nu \\Delta x$ for $a=0$. The number of integer steps is $N_t = \\lceil T / \\Delta t_{base} \\rceil$. The actual time step used for the simulation is then adjusted to $\\Delta t = T / N_t$, which ensures the simulation ends exactly at time $T$ while satisfying the CFL stability condition, since $\\Delta t \\le \\Delta t_{base}$.\n\n**Initial Condition:**\nThe initial condition is $u(x,0) = \\exp(-50\\,d(x)^2)$. The function $d(x) = (x-0.5) - \\mathrm{round}(x-0.5)$ represents the signed periodic distance from $x$ to the domain center $0.5$. For $x \\in [0,1)$, this simplifies to $d(x) = x-0.5$. Thus, the initial profile is $u_i^0 = \\exp(-50 (x_i - 0.5)^2)$.\n\n**Analytical Solution:**\nThe analytical solution to the advection equation is a simple translation of the initial profile: $u(x,t) = u_0(x-at)$. On the periodic domain, this becomes $u(x,t) = u_0((x-at) \\pmod 1)$. The exact solution at the grid points is:\n$$\nu_i^{\\text{exact}} = \\exp\\left(-50 \\left( ((x_i - aT) \\pmod 1) - 0.5 \\right)^2\\right)\n$$\n\n**Error and Direction Calculation:**\nThe discrete $L^2$ error is computed as specified:\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\big(u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T)\\big)^2\\right)^{1/2}\n$$\nThe propagation direction is inferred from the change in the centroid (first moment) of the distribution, $x_{\\mathrm{cm}}(t) = \\frac{\\sum_i x_i u_i(t)}{\\sum_i u_i(t)}$. The direction flag $D$ is:\n$$\nD = \\mathrm{sign}\\big(x_{\\mathrm{cm}}(T) - x_{\\mathrm{cm}}(0)\\big)\n$$\nA small threshold is used to set $D=0$ for negligible displacement, accounting for floating-point inaccuracies and the stationary case.\n\nThe algorithm is implemented for each test case, and the resulting error $E$ and direction flag $D$ are collected.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a first-order upwind scheme\n    for a set of test cases and computes the L2 error and propagation direction.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, nu, T)\n        (-1.0, 0.9, 0.25),\n        (-2.0, 0.8, 0.10),\n        (+1.0, 0.9, 0.25),\n        ( 0.0, 0.9, 0.25),\n        (-1.0, 1.0, 0.25),\n    ]\n\n    results = []\n    \n    # Grid parameters\n    N = 400\n    dx = 1.0 / N\n    x = np.linspace(0.0, 1.0, N, endpoint=False)\n\n    for a, nu, T in test_cases:\n        # 1. Initial Condition\n        # The definition d(x) = (x-0.5) - round(x-0.5) for x in [0,1) simplifies\n        # to d(x) = x - 0.5 because round(x-0.5) is 0 in this range.\n        u = np.exp(-50.0 * (x - 0.5)**2)\n        u_initial = np.copy(u)\n\n        # 2. Time-stepping parameters\n        if a == 0.0:\n            # For a=0, time step is defined differently.\n            # The equation is u_t = 0, so the solution is stationary.\n            # We still set up time steps to match final time T.\n            dt_base = nu * dx if nu * dx > 0 else 1e-9 # Avoid division by zero if T=0\n        else:\n            # CFL condition: nu = |a| * dt / dx\n            dt_base = nu * dx / abs(a)\n\n        # Calculate number of steps to reach T exactly\n        # Note: If T=0, n_steps=0. The loop won't run, u remains u_initial.\n        n_steps = math.ceil(T / dt_base) if T > 0 else 0\n        dt = T / n_steps if n_steps > 0 else 0.0\n        \n        # 3. Compute initial centroid\n        x_cm0 = np.sum(x * u_initial) / np.sum(u_initial)\n\n        # 4. Time evolution loop\n        # The update uses vectorized numpy operations for efficiency.\n        # np.roll(u, 1) gets u_{i-1} at index i (periodic)\n        # np.roll(u, -1) gets u_{i+1} at index i (periodic)\n        \n        cfl_factor = a * dt / dx\n\n        for _ in range(n_steps):\n            if a > 0:\n                # Backward difference for u_x: (u_i - u_{i-1}) / dx\n                # u_new = u - (a*dt/dx) * (u - np.roll(u,1))\n                u = u - cfl_factor * (u - np.roll(u, 1))\n            elif a  0:\n                # Forward difference for u_x: (u_{i+1} - u_i) / dx\n                # u_new = u - (a*dt/dx) * (np.roll(u,-1) - u)\n                u = u - cfl_factor * (np.roll(u, -1) - u)\n            # If a == 0.0, u is unchanged.\n        \n        u_numerical = u\n\n        # 5. Compute final centroid and propagation direction\n        x_cmT = np.sum(x * u_numerical) / np.sum(u_numerical)\n        \n        delta_cm = x_cmT - x_cm0\n        # Use a small threshold for determining stationary behavior\n        if abs(delta_cm)  1e-9:\n            D = 0\n        else:\n            D = int(np.sign(delta_cm))\n        \n        # Correct for periodic wrapping in direction calculation.\n        # The provided test cases do not involve wrapping, so simple sign suffices.\n        # A more robust method would check the shortest periodic distance.\n        # For example: if delta_cm > 0.5, D should be -1. if delta_cm  -0.5, D should be 1.\n        # This is not needed for the given test values of a and T.\n            \n        # 6. Compute analytical solution and error\n        x_shifted = (x - a * T) % 1.0\n        # The simplified form of d(x) applies here as well.\n        u_exact = np.exp(-50.0 * (x_shifted - 0.5)**2)\n\n        # Discrete L2 error\n        error = np.sqrt(dx * np.sum((u_numerical - u_exact)**2))\n\n        results.extend([error, D])\n\n    # Final print statement in the exact required format.\n    # Convert results to string with desired formatting\n    formatted_results = []\n    for item in results:\n        if isinstance(item, int):\n            formatted_results.append(str(item))\n        else:\n            # Standard float formatting for consistency\n            formatted_results.append(f\"{item:.15g}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Numerical methods, while powerful, are approximations that can introduce non-physical errors. A critical artifact in wave simulations is numerical dispersion, where different frequency components of a wave propagate at incorrect speeds, distorting the solution over time. This exercise demonstrates how to design a \"numerical experiment\" to expose and quantify this error in a second-order scheme by simulating a deliberately \"malicious\" initial condition—the highest frequency wave the grid can resolve, known as the Nyquist mode . By probing the scheme at its limit, you will gain a tangible understanding of its dispersive properties and how they depend on simulation parameters like the Courant number.",
            "id": "3229319",
            "problem": "Consider the one-dimensional linear wave Partial Differential Equation (PDE) $u_{tt} = c^2 u_{xx}$ posed on a periodic interval $[0,L)$, where $u(x,t)$ is twice differentiable in time and space, $c$ is the constant wave speed, and $L$ is the domain length. The numerical task is to investigate the dispersion properties of a standard second-order explicit finite difference method when the initial condition is deliberately chosen to be the highest frequency that can be represented on a given spatial grid.\n\nYou will work with a uniform grid with $N$ points, spatial step $\\Delta x = L/N$, and time step $\\Delta t$. Let the grid points be $x_i = i \\,\\Delta x$ for $i = 0,1,\\dots,N-1$, and time levels $t^n = n \\,\\Delta t$ for integer $n \\ge 0$. Use periodic boundary conditions, meaning indices wrap modulo $N$. The highest representable wavenumber on this grid (the Nyquist mode) is $k_{\\max} = \\pi/\\Delta x$. Define the \"malicious\" initial displacement as $u(x,0) = \\cos(k_{\\max} x)$ and the initial velocity as $u_t(x,0) = 0$. This initial condition maximizes susceptibility to numerical dispersion because it sits at the edge of the discrete spectrum.\n\nImplement a second-order accurate explicit finite difference method that is consistent with $u_{tt} = c^2 u_{xx}$, using central differences in both time and space on the above grid. Use periodic boundary conditions when approximating spatial derivatives. Initialize $u^0$ from $u(x,0)$, and construct $u^1$ using $u_t(x,0)$ and the method’s consistency with the PDE so that the overall scheme remains second-order accurate in time.\n\nFor each simulation, estimate the numerical angular frequency $\\omega_{\\text{num}}$ associated with the Nyquist mode by exploiting the discrete temporal behavior of the mode at a fixed grid point or by correlating the evolving solution $u^n$ with the initial spatial pattern $\\phi_i = \\cos(k_{\\max} x_i)$. Specifically, for an approximately single-mode time series, use the identity for cosine sequences to estimate $\\cos(\\omega_{\\text{num}} \\Delta t)$ from the sequence $\\{u^n\\}$, and average this estimate over multiple time levels to reduce numerical noise. Compute the exact angular frequency $\\omega_{\\text{exact}} = c\\,k_{\\max}$ induced by the continuous PDE for this mode. Define the dispersion error metric as the dimensionless float\n$$\nE = \\left| \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{exact}}} - 1 \\right|.\n$$\n\nAll physical quantities must be treated with appropriate units: choose $L$ in meters, $c$ in meters per second, and $\\Delta t$ in seconds; the angle in trigonometric functions is in radians. The Courant–Friedrichs–Lewy (CFL) condition should be respected for stability; define the Courant number $s = \\frac{c\\,\\Delta t}{\\Delta x}$, which is unitless, and use values with $s \\le 1$.\n\nYour program must:\n- Construct the malicious initial condition using $k_{\\max} = \\pi/\\Delta x$.\n- Advance the solution using a second-order explicit centered finite difference method under periodic boundary conditions.\n- Estimate $\\omega_{\\text{num}}$ from the time series and compute $E$ for each test case.\n- Round each $E$ to $8$ decimal places.\n\nUse the following test suite, which varies the Courant number $s$ to explore dispersion across regimes while holding $L$ and $c$ fixed:\n- Case $1$: $L = 1$ (meters), $c = 1$ (meters per second), $N = 128$, $s = 0.2$, $n_{\\text{steps}} = 200$.\n- Case $2$: $L = 1$ (meters), $c = 1$ (meters per second), $N = 128$, $s = 0.5$, $n_{\\text{steps}} = 200$.\n- Case $3$: $L = 1$ (meters), $c = 1$ (meters per second), $N = 128$, $s = 0.9$, $n_{\\text{steps}} = 200$.\n- Case $4$: $L = 1$ (meters), $c = 1$ (meters per second), $N = 128$, $s = 1.0$, $n_{\\text{steps}} = 200$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the above test cases. For example, the output format must be\n$[E_1,E_2,E_3,E_4]$,\nwhere each $E_j$ is the dispersion error for case $j$, rounded to $8$ decimal places.",
            "solution": "The problem requires an investigation into the numerical dispersion of a standard second-order explicit finite difference method for the one-dimensional linear wave equation, $u_{tt} = c^2 u_{xx}$. The analysis focuses on a specific initial condition, the Nyquist mode, which is the highest frequency mode representable on a discrete grid. This choice maximally exposes the scheme's dispersive errors.\n\nFirst, we define the computational domain and discretization. The spatial domain is a periodic interval $[0,L)$ discretized into $N$ points $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$, with a grid spacing of $\\Delta x = L/N$. Time is discretized into levels $t^n = n \\Delta t$, where $\\Delta t$ is the time step. The solution at grid point $x_i$ and time $t^n$ is denoted by $u_i^n \\approx u(x_i, t^n)$.\n\nThe partial differential equation $u_{tt} = c^2 u_{xx}$ is approximated using second-order accurate central finite differences for both the time and space derivatives:\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\bigg|_{i,n} \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{i,n} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\nSubstituting these expressions into the PDE and rearranging yields the explicit time-marching scheme, commonly known as the leapfrog method:\n$$\nu_i^{n+1} = 2u_i^n - u_i^{n-1} + \\left(\\frac{c \\Delta t}{\\Delta x}\\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nLet $s = \\frac{c \\Delta t}{\\Delta x}$ be the dimensionless Courant number. The scheme can be written as:\n$$\nu_i^{n+1} = 2(1-s^2)u_i^n + s^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}\n$$\nPeriodic boundary conditions are enforced, meaning that indices are taken modulo $N$, such that $u_N^n = u_0^n$ and $u_{-1}^n = u_{N-1}^n$. This scheme is stable for $s \\le 1$.\n\nThe initial conditions are specified as a \"malicious\" mode designed to probe the worst-case dispersion. The initial displacement is $u(x,0) = \\cos(k_{\\max}x)$, where $k_{\\max} = \\pi/\\Delta x$ is the Nyquist wavenumber. On the discrete grid, this becomes:\n$$\nu_i^0 = u(x_i, 0) = \\cos(k_{\\max} x_i) = \\cos\\left(\\frac{\\pi}{\\Delta x} i \\Delta x\\right) = \\cos(i\\pi) = (-1)^i\n$$\nThis initial condition corresponds to a sawtooth or checkerboard pattern, the highest frequency wave that can be represented on the grid. The initial velocity is $u_t(x,0)=0$.\n\nThe leapfrog scheme is a three-level method, requiring data from two previous time steps, $u^n$ and $u^{n-1}$, to compute $u^{n+1}$. To find the solution at the first time step, $u^1$, we must use a different approach that maintains the scheme's second-order accuracy. A Taylor series expansion of $u(x,t)$ around $t=0$ is used:\n$$\nu(x, \\Delta t) = u(x,0) + \\Delta t \\, u_t(x,0) + \\frac{(\\Delta t)^2}{2} u_{tt}(x,0) + O((\\Delta t)^3)\n$$\nUsing the initial condition $u_t(x,0)=0$ and the PDE itself, $u_{tt}(x,0) = c^2 u_{xx}(x,0)$, we get:\n$$\nu(x, \\Delta t) \\approx u(x,0) + \\frac{c^2 (\\Delta t)^2}{2} u_{xx}(x,0)\n$$\nDiscretizing this expression in space gives the formula for $u_i^1$:\n$$\nu_i^1 = u_i^0 + \\frac{s^2}{2} (u_{i+1}^0 - 2u_i^0 + u_{i-1}^0) = (1-s^2)u_i^0 + \\frac{s^2}{2}(u_{i+1}^0 + u_{i-1}^0)\n$$\nWith $u^0$ and $u^1$ established, the main leapfrog loop can proceed for all subsequent time steps.\n\nTo quantify the dispersion error, we must estimate the numerical angular frequency, $\\omega_{\\text{num}}$, and compare it to the exact angular frequency, $\\omega_{\\text{exact}}$. For a wave with wavenumber $k$, the continuous PDE implies a linear dispersion relation $\\omega = c k$. For the Nyquist mode, this gives:\n$$\n\\omega_{\\text{exact}} = c k_{\\max} = \\frac{c \\pi}{\\Delta x}\n$$\nThe numerical solution for the specified initial condition is expected to evolve as $u_i^n \\approx (-1)^i \\cos(\\omega_{\\text{num}} n \\Delta t)$. The time-varying amplitude of this mode, $A_n = \\cos(\\omega_{\\text{num}} n \\Delta t)$, can be isolated by projecting the numerical solution vector $U^n = \\{u_i^n\\}_{i=0}^{N-1}$ onto the initial mode shape vector $\\phi = \\{(-1)^i\\}_{i=0}^{N-1}$:\n$$\nA_n = \\frac{1}{N} \\sum_{i=0}^{N-1} u_i^n \\phi_i\n$$\nThe sequence $\\{A_n\\}$ follows the three-term recurrence relation for cosines: $A_{n+1} + A_{n-1} = 2 A_n \\cos(\\omega_{\\text{num}} \\Delta t)$. We can rearrange this to estimate the cosine of the phase step:\n$$\n\\cos(\\omega_{\\text{num}} \\Delta t) = \\frac{A_{n+1} + A_{n-1}}{2 A_n}\n$$\nBy computing this quantity for each time step $n$ (where $A_n$ is not close to zero) and averaging the results, we obtain a robust estimate, $\\cos_{\\text{est}}$. The numerical angular frequency is then recovered via:\n$$\n\\omega_{\\text{num}} = \\frac{1}{\\Delta t} \\arccos(\\cos_{\\text{est}})\n$$\nFinally, the dispersion error metric $E$ is calculated as the relative difference between the numerical and exact frequencies:\n$$\nE = \\left| \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{exact}}} - 1 \\right|\n$$\nThis procedure is repeated for each given set of parameters to analyze how the dispersion error changes with the Courant number $s$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the wave equation for the Nyquist mode to analyze numerical dispersion.\n    \"\"\"\n    # test_cases: (L, c, N, s, n_steps)\n    test_cases = [\n        (1.0, 1.0, 128, 0.2, 200),\n        (1.0, 1.0, 128, 0.5, 200),\n        (1.0, 1.0, 128, 0.9, 200),\n        (1.0, 1.0, 128, 1.0, 200),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, c, N, s, n_steps = case\n\n        # Grid and simulation parameters\n        dx = L / N\n        dt = s * dx / c\n        \n        # Store solution history\n        u_history = np.zeros((n_steps + 1, N))\n\n        # Initial condition u^0: Nyquist mode u(x,0) = cos(pi*x/dx)\n        # u_i^0 = cos(pi * i*dx / dx) = cos(i*pi) = (-1)^i\n        u_curr = np.array([(-1)**i for i in range(N)], dtype=float)\n        u_history[0, :] = u_curr\n        \n        # First time step u^1, using u_t(x,0) = 0\n        # u_i^1 = (1-s^2)u_i^0 + (s^2/2)(u_{i+1}^0 + u_{i-1}^0)\n        u_prev = np.copy(u_curr) # This will be u^0\n        u_ip1 = np.roll(u_curr, -1)\n        u_im1 = np.roll(u_curr, 1)\n        u_curr = (1 - s**2) * u_curr + (s**2 / 2.0) * (u_ip1 + u_im1)\n        u_history[1, :] = u_curr\n\n        # Main loop (leapfrog scheme)\n        for n in range(1, n_steps):\n            u_ip1 = np.roll(u_curr, -1)\n            u_im1 = np.roll(u_curr, 1)\n            u_next = 2.0 * (1.0 - s**2) * u_curr + s**2 * (u_ip1 + u_im1) - u_prev\n            \n            u_prev = np.copy(u_curr)\n            u_curr = np.copy(u_next)\n            u_history[n + 1, :] = u_curr\n\n        # Post-processing: Estimate numerical frequency\n        # Initial mode shape\n        phi = np.array([(-1)**i for i in range(N)], dtype=float)\n        \n        # Project solution onto the mode shape to get amplitudes A_n\n        # A_n = dot(u_n, phi) / N\n        amplitudes = np.dot(u_history, phi) / N\n\n        cos_estimates = []\n        # Estimate cos(omega_num * dt) from the amplitude recurrence\n        # cos(theta) = (A_{n+1} + A_{n-1}) / (2 * A_n)\n        for n in range(1, n_steps):\n            # Avoid division by zero or small numbers\n            if abs(amplitudes[n]) > 1e-10:\n                cos_est = (amplitudes[n+1] + amplitudes[n-1]) / (2.0 * amplitudes[n])\n                cos_estimates.append(cos_est)\n\n        if not cos_estimates:\n             # Fallback if no valid estimates could be made (highly unlikely)\n             # Use the analytical dispersion relation for the Nyquist mode\n             avg_cos_est = 1.0 - 2.0 * s**2\n        else:\n             avg_cos_est = np.mean(cos_estimates)\n\n        # Clip to handle potential floating-point errors pushing value outside [-1, 1]\n        avg_cos_est = np.clip(avg_cos_est, -1.0, 1.0)\n        \n        omega_num = np.arccos(avg_cos_est) / dt\n\n        # Calculate exact frequency and dispersion error\n        k_max = np.pi / dx\n        omega_exact = c * k_max\n        \n        # Ensure omega_exact is not zero to avoid division errors\n        if abs(omega_exact)  1e-12:\n            dispersion_error = 0.0 if abs(omega_num)  1e-12 else np.inf\n        else:\n            dispersion_error = abs(omega_num / omega_exact - 1.0)\n            \n        results.append(round(dispersion_error, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from abstract equations to a tangible physical system, this practice applies the finite difference method to simulate the vibrations of a plucked string with fixed ends. The goal extends beyond simply watching the wave propagate; it is to verify that the simulation accurately captures the rich harmonic content—the \"timbre\"—of the string's sound. This capstone exercise bridges the gap between time-domain simulation and frequency-domain analysis, challenging you to use the Discrete Fourier Transform (DFT) to compare the spectrum of your numerical solution against the analytical Fourier series of the initial triangular shape .",
            "id": "3229336",
            "problem": "Consider the one-dimensional wave equation with fixed ends describing the transverse displacement of an ideal string,\n$$\nu_{tt}(x,t) = c^2\\, u_{xx}(x,t), \\qquad 0  x  L, \\quad t  0,\n$$\nsubject to fixed-end boundary conditions\n$$\nu(0,t) = 0, \\qquad u(L,t) = 0,\n$$\nand the \"plucked\" initial displacement\n$$\nu(x,0) = u_0(x) = \n\\begin{cases}\n\\dfrac{A_0}{p L}\\, x,  0 \\le x \\le p L, \\\\\n\\dfrac{A_0}{(1-p) L}\\,(L - x),  p L \\le x \\le L,\n\\end{cases}\n\\qquad u_t(x,0) = 0,\n$$\nwhere $L$ is the string length (in $\\mathrm{m}$), $c$ is the wave speed (in $\\mathrm{m/s}$), $A_0$ is the pluck amplitude (in $\\mathrm{m}$), and $p \\in (0,1)$ is the normalized pluck location measured from $x=0$.\n\nYou will approximate the solution using a uniform finite difference grid in space and time. Let there be $N_x$ spatial grid points with spacing $\\Delta x = L/(N_x-1)$ and time step $\\Delta t$. Use the explicit second-order central difference scheme,\n$$\nu_j^{n+1} = 2 u_j^n - u_j^{n-1} + \\lambda^2 \\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right),\n$$\nwhere $u_j^n$ approximates $u(x_j, t_n)$ at $x_j = j\\,\\Delta x$ and $t_n = n\\,\\Delta t$, and $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$. Initialize using the second-order accurate Taylor expansion for zero initial velocity,\n$$\nu_j^1 = u_j^0 + \\frac{1}{2}\\,\\lambda^2 \\left(u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0\\right).\n$$\n\nThe analytical modal expansion for fixed-end boundary conditions is\n$$\nu(x,t) = \\sum_{n=1}^{\\infty} A_n \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\cos\\!\\left(\\omega_n t\\right),\n\\qquad \\omega_n = \\frac{n\\pi c}{L}, \\qquad f_n = \\frac{\\omega_n}{2\\pi} = \\frac{n c}{2L},\n$$\nwhere $A_n$ are the sine series coefficients of the initial profile $u_0(x)$:\n$$\nA_n = \\frac{2}{L}\\int_0^L u_0(x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\,dx.\n$$\n\nTask 1 (derivation): Starting from the above definition of $A_n$ and the plucked initial shape $u_0(x)$, derive a closed-form expression for $A_n$ in terms of $A_0$, $p$, $L$, and $n$, and then derive the analytical amplitude at an observation point $x_\\mathrm{obs}$ for mode $n$ as\n$$\nB_n^\\mathrm{(theory)} = \\left|A_n \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right)\\right|.\n$$\nUse angles in radians.\n\nTask 2 (algorithm design): Starting from the wave equation and the explicit scheme given above, explain how to choose $\\Delta t$ and the total simulated time $T_\\mathrm{total}$ to obtain a numerically well-resolved frequency spectrum that aligns discrete Fourier Transform (DFT) bins with the analytical modal frequencies $f_n$. Use the Courant–Friedrichs–Lewy (CFL) number definition $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$, and ensure $\\lambda = 1$ so that\n$$\n\\Delta t = \\frac{\\Delta x}{c}, \\qquad T_\\mathrm{total} = M\\,T_1 = \\frac{M}{f_1} = M\\,\\frac{2L}{c},\n$$\nfor a chosen integer $M \\ge 1$. With this choice, the DFT bin for the $n$-th mode will be an integer index, enabling direct comparison of spectral magnitudes across modes.\n\nTask 3 (implementation and comparison): Implement a program that\n- Constructs the spatial grid and initializes $u_j^0$ with the plucked shape $u_0(x)$, and $u_j^1$ using the given formula.\n- Advances the solution in time using the explicit update for $n=1,2,\\dots,N_t-1$, with $N_t = \\lfloor T_\\mathrm{total}/\\Delta t\\rfloor$.\n- Records the time series $u(x_\\mathrm{obs}, t)$ at a fixed observation point $x_\\mathrm{obs}$ by choosing the nearest grid index.\n- Computes the DFT of the recorded time series and extracts numerical spectral magnitudes at the analytical modal frequencies by reading the DFT at bin indices $k_n = n M$ for $n=1,\\dots,K$, where $K$ is the number of modes to compare.\n- Constructs the theoretical amplitude vector $B_n^\\mathrm{(theory)}$ from Task 1 for $n=1,\\dots,K$.\n- Normalizes the numerical and theoretical amplitude vectors by dividing each vector by its own maximum entry to focus on relative spectral shape.\n- Computes the mean absolute difference between the normalized numerical and theoretical vectors, yielding a single float error metric for the test case:\n$$\nE = \\frac{1}{K}\\sum_{n=1}^K \\left| \\frac{B_n^\\mathrm{(num)}}{\\max_m B_m^\\mathrm{(num)}} - \\frac{B_n^\\mathrm{(theory)}}{\\max_m B_m^\\mathrm{(theory)}} \\right|.\n$$\n\nPhysical units: $L$ must be in $\\mathrm{m}$, $c$ in $\\mathrm{m/s}$, $A_0$ in $\\mathrm{m}$, $T_\\mathrm{total}$ in $\\mathrm{s}$. All angles in sine functions are in radians. The final error metric $E$ is dimensionless.\n\nTest Suite: Your program must evaluate the following three cases and output one float per case, each computed as described above.\n- Case 1 (center pluck, odd-harmonic dominance): $L = 1.0\\,\\mathrm{m}$, $c = 1.0\\,\\mathrm{m/s}$, $A_0 = 1.0\\,\\mathrm{m}$, $N_x = 129$, $p = 0.5$, $x_\\mathrm{obs} = 0.31\\,\\mathrm{m}$, $M = 32$, $K = 8$.\n- Case 2 (off-center pluck, mixed harmonics): $L = 1.0\\,\\mathrm{m}$, $c = 2.0\\,\\mathrm{m/s}$, $A_0 = 1.0\\,\\mathrm{m}$, $N_x = 129$, $p = 0.3$, $x_\\mathrm{obs} = 0.37\\,\\mathrm{m}$, $M = 32$, $K = 10$.\n- Case 3 (near-end pluck, stronger high-frequency content): $L = 1.0\\,\\mathrm{m}$, $c = 1.5\\,\\mathrm{m/s}$, $A_0 = 1.0\\,\\mathrm{m}$, $N_x = 257$, $p = 0.1$, $x_\\mathrm{obs} = 0.83\\,\\mathrm{m}$, $M = 16$, $K = 12$.\n\nFinal Output Format: Your program should produce a single line of output containing the three error metrics for the above cases as a comma-separated list enclosed in square brackets, for example, $\"[e_1,e_2,e_3]\"$, where each $e_i$ is a float.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the physics of wave propagation and the mathematics of partial differential equations and Fourier analysis. It is well-posed, with a complete and consistent set of equations, boundary conditions, initial conditions, and parameters. The tasks are objective, clearly defined, and lead to a verifiable numerical result.\n\n### Task 1: Derivation of Analytical Modal Amplitudes\n\nThe first task is to derive a closed-form expression for the Fourier sine series coefficients, $A_n$, of the initial displacement profile $u_0(x)$. The coefficient $A_n$ is defined as:\n$$\nA_n = \\frac{2}{L}\\int_0^L u_0(x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\,dx\n$$\nThe initial shape, $u_0(x)$, is a piecewise linear function:\n$$\nu_0(x) = \n\\begin{cases}\n\\dfrac{A_0}{p L}\\, x,  0 \\le x \\le p L, \\\\\n\\dfrac{A_0}{(1-p) L}\\,(L - x),  p L \\le x \\le L,\n\\end{cases}\n$$\nWe substitute $u_0(x)$ into the integral for $A_n$ and split the integral into two parts corresponding to the piecewise definition:\n$$\nA_n = \\frac{2}{L} \\left[ \\int_0^{pL} \\frac{A_0}{pL} x \\sin\\!\\left(\\frac{n\\pi x}{L}\\right) dx + \\int_{pL}^{L} \\frac{A_0}{(1-p)L} (L-x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right) dx \\right]\n$$\nLet's evaluate the two integrals, which we denote $I_1$ and $I_2$. For brevity, let $k = \\frac{n\\pi}{L}$.\n\nThe first integral is:\n$$\nI_1 = \\frac{2A_0}{pL^2} \\int_0^{pL} x \\sin(kx) \\,dx\n$$\nUsing integration by parts, $\\int x \\sin(kx) \\,dx = -\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx) + C$:\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left[ -\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx) \\right]_0^{pL}\n$$\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left( \\left(-\\frac{pL}{k}\\cos(kpL) + \\frac{1}{k^2}\\sin(kpL)\\right) - (0) \\right)\n$$\nSubstituting $k = \\frac{n\\pi}{L}$ and $kpL = n\\pi p$:\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left( -\\frac{pL^2}{n\\pi}\\cos(n\\pi p) + \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) = \\frac{2A_0 \\sin(n\\pi p)}{p(n\\pi)^2} - \\frac{2A_0 \\cos(n\\pi p)}{n\\pi}\n$$\nThe second integral is:\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\int_{pL}^{L} (L-x) \\sin(kx) \\,dx = \\frac{2A_0}{(1-p)L^2} \\left[ L\\int_{pL}^L \\sin(kx)dx - \\int_{pL}^L x\\sin(kx)dx \\right]\n$$\nEvaluating the terms:\n$$\n\\int \\sin(kx)dx = -\\frac{1}{k}\\cos(kx)\n$$\n$$\n\\int (L-x)\\sin(kx)dx = -\\frac{L}{k}\\cos(kx) - \\left(-\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx)\\right) = \\frac{x-L}{k}\\cos(kx) - \\frac{1}{k^2}\\sin(kx)\n$$\nSo, for the second integral part of $A_n$:\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left[ \\frac{x-L}{k}\\cos(kx) - \\frac{1}{k^2}\\sin(kx) \\right]_{pL}^L\n$$\nAt the upper limit $x=L$: $\\left[ 0 - \\frac{1}{k^2}\\sin(n\\pi) \\right] = 0$.\nAt the lower limit $x=pL$: $\\left[ \\frac{pL-L}{k}\\cos(n\\pi p) - \\frac{1}{k^2}\\sin(n\\pi p) \\right] = \\left[ -\\frac{(1-p)L}{k}\\cos(n\\pi p) - \\frac{1}{k^2}\\sin(n\\pi p) \\right]$.\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left( 0 - \\left( -\\frac{(1-p)L^2}{n\\pi}\\cos(n\\pi p) - \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) \\right)\n$$\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left( \\frac{(1-p)L^2}{n\\pi}\\cos(n\\pi p) + \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) = \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} + \\frac{2A_0 \\sin(n\\pi p)}{(1-p)(n\\pi)^2}\n$$\nNow, we sum the two contributions: $A_n = I_1 + I_2$.\n$$\nA_n = \\left( \\frac{2A_0 \\sin(n\\pi p)}{p(n\\pi)^2} - \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} \\right) + \\left( \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} + \\frac{2A_0 \\sin(n\\pi p)}{(1-p)(n\\pi)^2} \\right)\n$$\nThe cosine terms cancel, yielding:\n$$\nA_n = \\frac{2A_0 \\sin(n\\pi p)}{(n\\pi)^2} \\left( \\frac{1}{p} + \\frac{1}{1-p} \\right) = \\frac{2A_0 \\sin(n\\pi p)}{(n\\pi)^2} \\left( \\frac{1-p+p}{p(1-p)} \\right)\n$$\nThis simplifies to the final closed-form expression for $A_n$:\n$$\nA_n = \\frac{2A_0 \\sin(n\\pi p)}{n^2\\pi^2 p(1-p)}\n$$\nThe analytical amplitude of mode $n$ at the observation point $x_\\mathrm{obs}$, denoted $B_n^\\mathrm{(theory)}$, is the magnitude of the $n$-th term in the series expansion at $t=0$ (since $\\cos(\\omega_n t)$ is at its maximum at $t=0$ if we only consider the time envelope):\n$$\nB_n^\\mathrm{(theory)} = \\left|A_n \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right)\\right| = \\left| \\frac{2A_0 \\sin(n\\pi p)}{n^2\\pi^2 p(1-p)} \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right) \\right|\n$$\n\n### Task 2: Algorithmic Design for Spectral Analysis\n\nThe goal is to choose the numerical parameters $\\Delta t$ and $T_\\mathrm{total}$ to facilitate a direct comparison between the numerical spectrum from a Discrete Fourier Transform (DFT) and the analytical modal frequencies.\n\nThe analytical modal frequencies are $f_n = n \\frac{c}{2L}$ for $n=1, 2, \\dots$. The fundamental frequency is $f_1 = c/(2L)$, with a corresponding period $T_1 = 1/f_1 = 2L/c$.\n\nThe frequency resolution of a DFT on a time series of total duration $T_\\mathrm{total}$ is $\\Delta f = 1/T_\\mathrm{total}$. The frequency corresponding to the $k$-th DFT bin (with $k$ being an integer index) is $f^\\mathrm{(DFT)}_k = k \\cdot \\Delta f = k/T_\\mathrm{total}$.\n\nTo ensure that the analytical frequencies $f_n$ align with specific DFT bins, we require $f_n = f^\\mathrm{(DFT)}_{k_n}$ for some set of integer bin indices $k_n$.\n$$\nn \\frac{c}{2L} = \\frac{k_n}{T_\\mathrm{total}} \\implies T_\\mathrm{total} = k_n \\frac{2L}{nc}\n$$\nTo make the bin index $k_n$ a simple integer multiple of the mode number $n$, we can set $k_n = n M$ for some integer $M \\ge 1$. This leads to the choice for the total simulation time:\n$$\nT_\\mathrm{total} = (nM) \\frac{2L}{nc} = M \\frac{2L}{c} = M T_1\n$$\nThis choice ensures the simulation runs for an integer number of fundamental periods, $M$. With this $T_\\mathrm{total}$, the frequency of the $n$-th mode, $f_n = n \\frac{c}{2L}$, corresponds to the DFT bin frequency $f^\\mathrm{(DFT)}_{nM} = (nM) / T_\\mathrm{total} = (nM) / (M \\frac{2L}{c}) = n \\frac{c}{2L} = f_n$. Thus, the amplitude of the $n$-th mode can be extracted from the DFT at bin index $k_n = nM$.\n\nThe problem specifies using the Courant–Friedrichs–Lewy (CFL) number $\\lambda = \\frac{c\\Delta t}{\\Delta x} = 1$. This value is at the limit of stability for the explicit scheme and, for the 1D wave equation, it provides an exact solution on the grid (d'Alembert's solution). This choice dictates the time step:\n$$\n\\Delta t = \\frac{\\Delta x}{c} = \\frac{L/(N_x-1)}{c} = \\frac{L}{c(N_x-1)}\n$$\nThe total number of time steps, $N_t$, required for the simulation is then determined:\n$$\nN_t = \\left\\lfloor \\frac{T_\\mathrm{total}}{\\Delta t} \\right\\rfloor = \\left\\lfloor \\frac{M \\frac{2L}{c}}{\\frac{L}{c(N_x-1)}} \\right\\rfloor = \\lfloor 2M(N_x-1) \\rfloor = 2M(N_x-1)\n$$\nSince $M$ and $N_x$ are integers, the floor operation is not strictly necessary.\n\n### Task 3: Implementation and Comparison\n\nThe implementation proceeds as follows:\n1.  **Grid and Parameter Setup:** For each test case, define $L, c, A_0, N_x, p, x_\\mathrm{obs}, M, K$. From these, calculate $\\Delta x = L/(N_x-1)$, $\\Delta t = \\Delta x/c$, and $N_t = 2M(N_x-1)$. The spatial grid is $x_j = j\\Delta x$ for $j=0, \\dots, N_x-1$. The observation point $x_\\mathrm{obs}$ is mapped to the nearest grid index $j_\\mathrm{obs}$.\n\n2.  **Theoretical Amplitudes:** A vector $B^\\mathrm{(theory)}$ of length $K$ is computed. For each mode $n=1,\\dots,K$, the element $B_n^\\mathrm{(theory)}$ is calculated using the formula derived in Task 1.\n\n3.  **Initialization:**\n    *   The solution at time $n=0$, $u_j^0$, is initialized on the grid according to the piecewise function $u_0(x_j)$.\n    *   The solution at time $n=1$, $u_j^1$, is computed using the second-order accurate starter: $u_j^1 = u_j^0 + \\frac{1}{2}\\lambda^2 (u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0)$. Since we set $\\lambda=1$, this becomes $u_j^1 = u_j^0 + \\frac{1}{2} (u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0)$. Boundary conditions $u_0^n = u_{N_x-1}^n = 0$ are enforced for all $n$.\n\n4.  **Time Evolution:** The solution is advanced in time for $n=1, 2, \\dots, N_t-1$. The update rule for the interior points ($j=1, \\dots, N_x-2$) is:\n    $$\n    u_j^{n+1} = 2 u_j^n - u_j^{n-1} + \\lambda^2 (u_{j+1}^n - 2 u_j^n + u_{j-1}^n)\n    $$\n    With $\\lambda=1$, this simplifies significantly to:\n    $$\n    u_j^{n+1} = u_{j+1}^n + u_{j-1}^n - u_j^{n-1}\n    $$\n    At each time step $n$, the value of the solution at the observation point, $u_{j_\\mathrm{obs}}^n$, is stored in a time series array.\n\n5.  **Spectral Analysis:**\n    *   The DFT of the recorded time series is computed.\n    *   The DFT is typically complex-valued. The numerical spectral amplitude for mode $n$, $B_n^\\mathrm{(num)}$, is extracted from the magnitude of the DFT at bin index $k_n = nM$. A normalization factor is required. For a real signal of length $N_t$, the amplitude of a sinusoidal component is given by $2|\\mathrm{DFT}[k]|/N_t$. Thus, $B_n^\\mathrm{(num)} = \\frac{2}{N_t} |\\mathrm{DFT}[nM]|$. A vector $B^\\mathrm{(num)}$ of length $K$ is constructed.\n\n6.  **Normalization and Error Calculation:**\n    *   Both vectors, $B^\\mathrm{(theory)}$ and $B^\\mathrm{(num)}$, are normalized by dividing each by its own maximum element. Let these be $\\hat{B}^\\mathrm{(theory)}$ and $\\hat{B}^\\mathrm{(num)}$.\n    *   The error metric $E$ is computed as the mean absolute difference between these normalized vectors:\n    $$\n    E = \\frac{1}{K}\\sum_{n=1}^K \\left| \\hat{B}_n^\\mathrm{(num)} - \\hat{B}_n^\\mathrm{(theory)} \\right|\n    $$\nThis process is repeated for each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation using a finite difference method and compares\n    the numerical frequency spectrum to the analytical solution for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: center pluck, odd-harmonic dominance\n        {'L': 1.0, 'c': 1.0, 'A0': 1.0, 'Nx': 129, 'p': 0.5, 'x_obs': 0.31, 'M': 32, 'K': 8},\n        # Case 2: off-center pluck, mixed harmonics\n        {'L': 1.0, 'c': 2.0, 'A0': 1.0, 'Nx': 129, 'p': 0.3, 'x_obs': 0.37, 'M': 32, 'K': 10},\n        # Case 3: near-end pluck, stronger high-frequency content\n        {'L': 1.0, 'c': 1.5, 'A0': 1.0, 'Nx': 257, 'p': 0.1, 'x_obs': 0.83, 'M': 16, 'K': 12},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        L = case['L']\n        c = case['c']\n        A0 = case['A0']\n        Nx = case['Nx']\n        p = case['p']\n        x_obs = case['x_obs']\n        M = case['M']\n        K = case['K']\n\n        # --- Task 1: Theoretical Amplitudes ---\n        n_modes = np.arange(1, K + 1)\n        \n        # Derived formula for An\n        # An = (2 * A0 * sin(n*pi*p)) / ( (n*pi)^2 * p * (1-p) )\n        numerator = 2 * A0 * np.sin(n_modes * np.pi * p)\n        denominator = (n_modes * np.pi)**2 * p * (1 - p)\n        # Handle cases where sin(n*pi*p) is zero, to avoid 0/0 if p makes denominator zero\n        An = np.divide(numerator, denominator, out=np.zeros_like(numerator), where=denominator!=0)\n\n        # Theoretical amplitude at observation point\n        B_theory = np.abs(An * np.sin(n_modes * np.pi * x_obs / L))\n        \n        # --- Task 2  3: Numerical Simulation and Comparison ---\n        \n        # Grid and time parameters\n        dx = L / (Nx - 1)\n        # CFL lambda = 1 is specified\n        dt = dx / c\n        # Total simulation time T_total = M * 2*L/c\n        # Total number of time steps Nt = T_total / dt\n        Nt = 2 * M * (Nx - 1)\n        \n        x_grid = np.linspace(0, L, Nx)\n        j_obs = np.argmin(np.abs(x_grid - x_obs))\n\n        # Initial condition u(x,0)\n        u0 = np.zeros(Nx)\n        pluck_pos = p * L\n        mask1 = x_grid = pluck_pos\n        mask2 = x_grid > pluck_pos\n        \n        # Apply piecewise definition\n        u0[mask1] = (A0 / pluck_pos) * x_grid[mask1] if p > 0 else 0\n        u0[mask2] = (A0 / (L - pluck_pos)) * (L - x_grid[mask2]) if (1-p) > 0 else 0\n\n        # Initial condition for the first time step u(x, dt)\n        # using u_j^1 = u_j^0 + 0.5 * lambda^2 * (u_{j+1}^0 - 2*u_j^0 + u_{j-1}^0)\n        # for lambda = 1\n        u1 = u0.copy()\n        u1[1:-1] = u0[1:-1] + 0.5 * (u0[2:] - 2*u0[1:-1] + u0[:-2])\n        # Boundaries are fixed at 0, which is naturally handled.\n\n        # Time evolution\n        u_prev = u0.copy()\n        u_curr = u1.copy()\n        time_series = np.zeros(Nt)\n        time_series[0] = u_prev[j_obs]\n        time_series[1] = u_curr[j_obs]\n\n        # FDM loop with lambda=1 simplified update rule\n        # u_j^{n+1} = u_{j+1}^n + u_{j-1}^n - u_j^{n-1}\n        for n in range(1, Nt - 1):\n            u_next = np.zeros(Nx)\n            u_next[1:-1] = u_curr[2:] + u_curr[:-2] - u_prev[1:-1]\n            u_prev, u_curr = u_curr, u_next\n            time_series[n + 1] = u_curr[j_obs]\n\n        # Spectral analysis of the numerical result\n        dft_result = np.fft.fft(time_series)\n        k_indices = n_modes * M\n        \n        # DFT amplitude normalization for a real signal\n        B_num = (2.0 / Nt) * np.abs(dft_result[k_indices])\n\n        # Normalization and error calculation\n        max_B_theory = np.max(B_theory)\n        if max_B_theory > 0:\n            B_theory_norm = B_theory / max_B_theory\n        else: # Handle case where all theoretical values are zero\n            B_theory_norm = B_theory\n            \n        max_B_num = np.max(B_num)\n        if max_B_num > 0:\n            B_num_norm = B_num / max_B_num\n        else: # Handle case where all numerical values are zero\n            B_num_norm = B_num\n\n        error = np.mean(np.abs(B_num_norm - B_theory_norm))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}