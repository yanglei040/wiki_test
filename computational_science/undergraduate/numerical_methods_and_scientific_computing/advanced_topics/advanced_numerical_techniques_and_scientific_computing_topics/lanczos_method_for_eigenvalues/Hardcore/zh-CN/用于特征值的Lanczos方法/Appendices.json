{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的代码实现之前，为兰索斯算法的核心机制建立坚实的直觉至关重要。第一个练习将要求你为一个特殊结构的矩阵手动执行兰索斯迭代的初始步骤 。通过亲手进行向量运算并计算系数 $\\alpha_1$、$\\beta_2$ 和 $\\alpha_2$，你将具体地理解算法如何构建三对角矩阵 $T$，这个小矩阵可以看作是原始大矩阵 $A$ 的一个缩影。",
            "id": "2184040",
            "problem": "兰索斯算法是一种用于求解大型对称矩阵的特征值和特征向量的数值方法。该算法通过为克雷洛夫子空间构建一个标准正交基，并在此过程中生成一个对称三对角矩阵，该矩阵的特征值近似于原始矩阵的特征值。\n\n考虑一个对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，它被定义为一个秩一矩阵 $A = vv^\\mathsf{T}$，其中 $v \\in \\mathbb{R}^n$ 是一个单位范数的列向量，即 $v^\\mathsf{T} v = 1$。\n\n兰索斯算法以一个起始向量 $q_1$ 开始，该向量也是一个单位向量（$q_1^\\mathsf{T} q_1 = 1$）。已知起始向量 $q_1$ 与 $v$ 不正交。记这两个向量之间夹角的余弦为 $c = v^\\mathsf{T} q_1$。给定 $0  c  1$。\n\n该算法迭代生成一个标准正交向量序列 $q_1, q_2, \\dots$ 以及一个对称三对角矩阵 $T_k$ 的元素。两步迭代的过程如下：\n1.  计算 $w_1 = A q_1$。\n2.  计算 $\\alpha_1 = q_1^\\mathsf{T} w_1$。\n3.  计算 $w'_2 = w_1 - \\alpha_1 q_1$。\n4.  计算 $\\beta_2 = \\|w'_2\\|$。若 $\\beta_2=0$，则算法终止。否则，计算 $q_2 = w'_2 / \\beta_2$。\n5.  计算 $w_2 = A q_2$。\n6.  计算 $\\alpha_2 = q_2^\\mathsf{T} w_2$。\n\n你的任务是确定经过算法两次完整迭代后生成的 $2 \\times 2$ 对称三对角矩阵 $T_2$。\n$$\nT_2 = \\begin{pmatrix}\n\\alpha_1  \\beta_2 \\\\\n\\beta_2  \\alpha_2\n\\end{pmatrix}\n$$\n将你的最终答案表示为一个矩阵，其元素是 $c$ 的函数。",
            "solution": "我们有 $A = v v^{\\mathsf{T}}$ 且 $v^{\\mathsf{T}} v = 1$，以及一个单位起始向量 $q_{1}$ 满足 $c = v^{\\mathsf{T}} q_{1} \\in (0,1)$。应用给定的兰索斯步骤。\n\n计算\n$$\nw_{1} = A q_{1} = v(v^{\\mathsf{T}} q_{1}) = c v.\n$$\n然后\n$$\n\\alpha_{1} = q_{1}^{\\mathsf{T}} w_{1} = q_{1}^{\\mathsf{T}} (c v) = c (q_{1}^{\\mathsf{T}} v) = c^{2}.\n$$\n构造\n$$\nw'_{2} = w_{1} - \\alpha_{1} q_{1} = c v - c^{2} q_{1}.\n$$\n将 $v$ 分解为与 $q_{1}$ 平行和正交的分量：\n$$\nv = c q_{1} + r, \\quad r = v - c q_{1}, \\quad q_{1}^{\\mathsf{T}} r = 0, \\quad \\|r\\| = \\sqrt{1 - c^{2}}.\n$$\n令 $u = r / \\|r\\|$，则 $u$ 是单位向量且与 $q_{1}$ 正交。定义 $s = \\sqrt{1 - c^{2}}$，于是 $v = c q_{1} + s u$。那么\n$$\nw'_{2} = c(c q_{1} + s u) - c^{2} q_{1} = c s u,\n$$\n因此\n$$\n\\beta_{2} = \\|w'_{2}\\| = c s = c \\sqrt{1 - c^{2}},\n$$\n且\n$$\nq_{2} = \\frac{w'_{2}}{\\beta_{2}} = u.\n$$\n接下来，\n$$\nw_{2} = A q_{2} = v(v^{\\mathsf{T}} q_{2}) = v\\big((c q_{1} + s u)^{\\mathsf{T}} u\\big) = v s,\n$$\n所以\n$$\n\\alpha_{2} = q_{2}^{\\mathsf{T}} w_{2} = u^{\\mathsf{T}} (s v) = s\\, u^{\\mathsf{T}} v = s(c q_{1}^{\\mathsf{T}} u + s u^{\\mathsf{T}} u) = s^{2} = 1 - c^{2}.\n$$\n因此，两次迭代后的三对角矩阵为\n$$\nT_{2} = \\begin{pmatrix}\n\\alpha_{1}  \\beta_{2} \\\\\n\\beta_{2}  \\alpha_{2}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc^{2}  c \\sqrt{1 - c^{2}} \\\\\nc \\sqrt{1 - c^{2}}  1 - c^{2}\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}c^{2}  c\\sqrt{1-c^{2}} \\\\ c\\sqrt{1-c^{2}}  1-c^{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "兰索斯方法的有效性取决于它所构建的克雷洛夫子空间，但如果这个子空间对矩阵的某些特征向量“视而不见”，会发生什么呢？这个动手编程练习  旨在探讨初始向量在决定算法能找到哪些特征值时所扮演的关键角色。通过实验性地选择与特定特征向量正交或对齐的初始向量，你将亲眼见证算法如何可能完全错过一个特征值，或者以惊人的效率立即捕获它。",
            "id": "3246991",
            "problem": "考虑一个实对称矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$，其特征分解为 $\\mathbf{A} = \\mathbf{U}\\mathbf{\\Lambda}\\mathbf{U}^\\mathsf{T}$，其中 $\\mathbf{U}$ 是正交矩阵，其列向量 $\\mathbf{u}_j$ 构成一个特征向量的标准正交基，$\\mathbf{\\Lambda} = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_n)$ 包含所有实特征值。对于任意单位向量 $\\mathbf{v} \\in \\mathbb{R}^n$，由 $\\mathbf{v}$ 导出的谱测度在特征值 $\\lambda_j$ 处赋予的质量为 $w_j = |\\mathbf{u}_j^\\mathsf{T} \\mathbf{v}|^2$。由 $(\\mathbf{A},\\mathbf{v})$ 生成的 $k$ 阶 Krylov 子空间为 $\\mathcal{K}_k(\\mathbf{A},\\mathbf{v}) = \\mathrm{span}\\{\\mathbf{v},\\mathbf{A}\\mathbf{v},\\dots,\\mathbf{A}^{k-1}\\mathbf{v}\\}$。Lanczos 方法通过一个三项递推关系为 $\\mathcal{K}_m(\\mathbf{A},\\mathbf{v})$ 构建一个标准正交基 $\\{\\mathbf{q}_1,\\dots,\\mathbf{q}_m\\}$，使得 $\\mathbf{A}$ 在此基下的表示为一个对称三对角矩阵 $\\mathbf{T}_m$，其对角元为 $\\alpha_j$，非对角元为 $\\beta_j$；$\\mathbf{T}_m$ 的特征值是 $\\mathbf{A}$ 限制在 $\\mathcal{K}_m(\\mathbf{A},\\mathbf{v})$ 上的特征值的 Rayleigh-Ritz (RR) 近似值。如果对于某个 $j$，有 $w_j = 0$，那么对于所有的 $k$，$\\mathbf{u}_j$ 都与 $\\mathcal{K}_k(\\mathbf{A},\\mathbf{v})$ 正交，并且 $\\lambda_j$ 不会出现在从 $\\mathbf{v}$ 开始的 Lanczos 过程所得到的 RR 值中。反之，如果 $\\mathbf{v}$ 等于一个特征向量 $\\mathbf{u}_j$，那么 Lanczos 方法会立即终止，得到 $\\mathbf{T}_1 = [\\lambda_j]$，从而在一步之内精确捕获 $\\lambda_j$。\n\n你的任务是实现 Lanczos 方法，在一个小的、完全指定的例子上具体地展示这些现象。处理以下矩阵\n$$\n\\mathbf{A} = \\mathrm{diag}(1,2,3,4) \\in \\mathbb{R}^{4\\times 4},\n$$\n其标准正交特征向量为标准基 $\\{\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_3,\\mathbf{e}_4\\}$，特征值为 $\\lambda_1=1$, $\\lambda_2=2$, $\\lambda_3=3$, $\\lambda_4=4$。使用单位起始向量 $\\mathbf{v}_1$ 实现经典的 Lanczos 三项递推，构建三对角矩阵 $\\mathbf{T}_m$ 直到在第一个满足 $\\beta_m \\le \\varepsilon$（其中 $\\varepsilon = 10^{-12}$）的索引 $m$ 处中断，然后计算 $\\mathbf{T}_m$ 的特征值作为 RR 值。使用成员资格容差 $\\delta = 10^{-10}$ 来检验某个特定特征值是否出现在 RR 值中。\n\n你必须从第一性原理出发，论证并测试以下情况：\n- 情况 1（边界条件：零谱质量）。令 $\\mathbf{v}_1^{(\\mathrm{no3})} = \\frac{1}{\\sqrt{3}}(1,1,0,1)^\\top$，因此在 $\\lambda_3$ 上的谱质量为 $w_3 = |\\mathbf{e}_3^\\mathsf{T} \\mathbf{v}_1^{(\\mathrm{no3})}|^2 = 0$。运行 Lanczos 直到中断，并检查 $\\mathbf{T}_m$ 的 RR 值是否在容差 $\\delta$ 内包含 $\\lambda_3$。预期的现象是 $\\lambda_3$ 不会出现，因为 $\\mathcal{K}_k(\\mathbf{A},\\mathbf{v}_1^{(\\mathrm{no3})})$ 包含在 $\\mathrm{span}\\{\\mathbf{e}_1,\\mathbf{e}_2,\\mathbf{e}_4\\}$ 中。\n- 情况 2（边缘情况：立即捕获）。令 $\\mathbf{v}_1^{(\\mathrm{exact3})} = \\mathbf{e}_3$。运行 Lanczos 并报告直到中断的步数 $m$。预期的现象是 $m=1$ 且唯一的 RR 值精确等于 $\\lambda_3$。\n- 情况 3（理想路径：非零谱质量）。令 $\\mathbf{v}_1^{(\\mathrm{all})} = \\frac{1}{2}(1,1,1,1)^\\top$，因此 $w_3 = \\left|\\mathbf{e}_3^\\mathsf{T} \\mathbf{v}_1^{(\\mathrm{all})}\\right|^2 = \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{4}$。运行 Lanczos 直到中断，并检查 $\\mathbf{T}_m$ 的 RR 值是否在容差 $\\delta$ 内包含 $\\lambda_3$。预期的现象是，一旦 Krylov 子空间张成整个不变子空间，$\\lambda_3$ 就会出现在 RR 值中。\n\n你的实现必须遵守以下规范：\n- 通过记录标量 $\\alpha_j = \\mathbf{q}_j^\\mathsf{T} \\mathbf{A}\\mathbf{q}_j$ 和 $\\beta_j = \\lVert \\mathbf{w}_j \\rVert_2$ 来构造 $\\mathbf{T}_m$，其中 $\\mathbf{w}_j = \\mathbf{A}\\mathbf{q}_j - \\alpha_j \\mathbf{q}_j - \\beta_{j-1}\\mathbf{q}_{j-1}$，且 $\\beta_0 = 0$、$\\mathbf{q}_0 = \\mathbf{0}$。当 $\\beta_j  \\varepsilon$ 时，$\\mathbf{q}_{j+1} = \\mathbf{w}_j / \\beta_j$。当 $\\beta_j \\le \\varepsilon$ 时停止。\n- 将 $\\mathbf{T}_m$ 的特征值计算为 RR 值。\n- 使用指定的容差 $\\varepsilon = 10^{-12}$ 和 $\\delta = 10^{-10}$。\n\n测试套件与最终输出规范：\n- 将该方法应用于上述三种情况。对于情况1，你的程序必须返回一个布尔值，指示 $\\lambda_3$ 是否出现在 RR 值中（预期为 false）。对于情况2，你的程序必须返回一个整数，该整数等于 Lanczos 直到中断的步数 $m$（预期为 $1$）。对于情况3，你的程序必须返回一个布尔值，指示 $\\lambda_3$ 是否出现在 RR 值中（预期为 true）。\n- 你的程序应生成单行输出，其中包含按 $[\\text{情况1结果}, \\text{情况2结果}, \\text{情况3结果}]$ 顺序排列、用逗号分隔并括在方括号内的结果，例如 $[b_1,i_2,b_3]$，其中 $b_1$ 和 $b_3$ 是布尔值，$i_2$ 是整数。\n\n本问题中的所有量都是无量纲的，不涉及物理单位或角度单位。",
            "solution": "该问题要求实现 Lanczos 三项递推，以寻找给定实对称矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 的特征值的 Rayleigh-Ritz 近似值。我们将使用此实现来具体展示 Lanczos 方法与起始向量谱测度相关的三个基本性质。指定的矩阵为 $\\mathbf{A} = \\mathrm{diag}(1,2,3,4)$，其特征值为 $\\lambda_j = j$（$j=1,2,3,4$），对应的标准正交特征向量为标准基向量 $\\{\\mathbf{e}_1, \\mathbf{e}_2, \\mathbf{e}_3, \\mathbf{e}_4\\}$。\n\n### Lanczos 算法\n\nLanczos 算法是一种迭代方法，它为 $m$ 阶 Krylov 子空间 $\\mathcal{K}_m(\\mathbf{A}, \\mathbf{v}_1) = \\mathrm{span}\\{\\mathbf{v}_1, \\mathbf{A}\\mathbf{v}_1, \\dots, \\mathbf{A}^{m-1}\\mathbf{v}_1\\}$ 生成一个标准正交基 $\\{\\mathbf{q}_1, \\dots, \\mathbf{q}_m\\}$，其中 $\\mathbf{v}_1$ 是给定的单位起始向量。在此基下，$\\mathbf{A}$ 在子空间 $\\mathcal{K}_m$ 上的作用由一个对称三对角矩阵 $\\mathbf{T}_m$ 表示。\n\n该算法通过以下三项递推进行，初始条件为 $\\mathbf{q}_1 = \\mathbf{v}_1$，$\\beta_0=0$ 和 $\\mathbf{q}_0 = \\mathbf{0}$：\n对于 $j = 1, 2, \\dots, m$：\n1.  计算矩阵向量乘积：$\\mathbf{z}_j = \\mathbf{A} \\mathbf{q}_j$。\n2.  计算 $\\mathbf{T}_m$ 的对角元：$\\alpha_j = \\mathbf{q}_j^\\mathsf{T} \\mathbf{z}_j$。\n3.  计算未归一化的下一个 Lanczos 向量：$\\mathbf{w}_j = \\mathbf{z}_j - \\alpha_j \\mathbf{q}_j - \\beta_{j-1} \\mathbf{q}_{j-1}$。\n4.  计算 $\\mathbf{T}_m$ 的非对角元：$\\beta_j = \\lVert \\mathbf{w}_j \\rVert_2$。\n5.  如果 $\\beta_j$ 小于给定的容差 $\\varepsilon$，则称算法发生（理想）中断。这表明 Krylov 子空间在 $\\mathbf{A}$ 的作用下是不变的。我们令 $m=j$ 并终止。所生成子空间的维数是 $m$。\n6.  如果 $\\beta_j  \\varepsilon$，则进行归一化以找到下一个 Lanczos 向量：$\\mathbf{q}_{j+1} = \\mathbf{w}_j / \\beta_j$。\n\n经过 $m$ 步后，此过程产生对称三对角矩阵：\n$$\n\\mathbf{T}_m = \\begin{pmatrix}\n\\alpha_1  \\beta_1     \\\\\n\\beta_1  \\alpha_2  \\beta_2   \\\\\n  \\beta_2  \\ddots  \\ddots  \\\\\n    \\ddots  \\alpha_{m-1}  \\beta_{m-1} \\\\\n      \\beta_{m-1}  \\alpha_m\n\\end{pmatrix} \\in \\mathbb{R}^{m \\times m}\n$$\n$\\mathbf{T}_m$ 的特征值，被称为 Rayleigh-Ritz (RR) 值，是 $\\mathbf{A}$ 的特征值的近似值。\n\n### 测试用例分析\n\n现在我们将此算法应用于矩阵 $\\mathbf{A} = \\mathrm{diag}(1,2,3,4)$，中断容差为 $\\varepsilon = 10^{-12}$，特征值隶属度容差为 $\\delta = 10^{-10}$。\n\n**情况 1：零谱质量**\n\n起始向量为 $\\mathbf{v}_1^{(\\mathrm{no3})} = \\frac{1}{\\sqrt{3}}(1,1,0,1)^\\top$。此向量引出的谱测度在特征值 $\\lambda_j$ 处赋予的质量为 $w_j = |\\mathbf{e}_j^\\mathsf{T} \\mathbf{v}_1^{(\\mathrm{no3})}|^2$。对于 $\\lambda_3=3$，质量为 $w_3 = |\\mathbf{e}_3^\\mathsf{T} \\mathbf{v}_1^{(\\mathrm{no3})}|^2 = |0|^2 = 0$。\n\n从第一性原理可知，由于起始向量 $\\mathbf{v}_1^{(\\mathrm{no3})}$ 仅是 $\\{\\mathbf{e}_1, \\mathbf{e}_2, \\mathbf{e}_4\\}$ 的线性组合，它位于子空间 $S = \\mathrm{span}\\{\\mathbf{e}_1, \\mathbf{e}_2, \\mathbf{e}_4\\}$ 中。因为 $\\mathbf{A}$ 是对角矩阵，所以该子空间是 $\\mathbf{A}$ 的一个不变子空间，这意味着对于任何向量 $\\mathbf{x} \\in S$，$\\mathbf{A}\\mathbf{x}$ 也属于 $S$。因此，Krylov 序列中的所有向量 $\\mathbf{A}^k \\mathbf{v}_1^{(\\mathrm{no3})}$ 都保持在 $S$ 内部。Lanczos 过程对这些向量进行线性组合，将生成一个同样完全位于 $S$ 内部的标准正交基 $\\{\\mathbf{q}_j\\}$。所得的三对角矩阵 $\\mathbf{T}_m$ 是 $\\mathbf{A}$ 在 Krylov 子空间 $\\mathcal{K}_m(\\mathbf{A}, \\mathbf{v}_1^{(\\mathrm{no3})}) \\subseteq S$ 上的表示。$\\mathbf{A}$ 限制在 $S$ 上的特征值是 $\\{\\lambda_1, \\lambda_2, \\lambda_4\\} = \\{1, 2, 4\\}$。因此，作为 $\\mathbf{T}_m$ 特征值的 RR 值，只能逼近或精确等于 $\\{1, 2, 4\\}$ 中的成员。特征值 $\\lambda_3=3$ 不可能出现在 RR 值中。当 Krylov 子空间张成 $S$ 时，算法应在 $m=3$ 处中断。实现将运行 Lanczos 算法，并检查计算出的任何 RR 值是否在 $\\lambda_3=3$ 的容差 $\\delta$ 范围内。预期结果为 `False`。\n\n**情况 2：以精确特征向量为起始**\n\n起始向量是 $\\mathbf{v}_1^{(\\mathrm{exact3})} = \\mathbf{e}_3$，即对应于 $\\lambda_3=3$ 的特征向量。\n\n阶数 $k1$ 的 Krylov 子空间没有明确定义，因为向量立即变得线性相关。$\\mathcal{K}_1(\\mathbf{A}, \\mathbf{e}_3) = \\mathrm{span}\\{\\mathbf{e}_3\\}$。向量 $\\mathbf{A}\\mathbf{e}_3 = \\lambda_3 \\mathbf{e}_3 = 3\\mathbf{e}_3$ 与 $\\mathbf{e}_3$ 线性相关。我们来追踪 Lanczos 算法的第一步：\n- 初始化：$\\mathbf{q}_1 = \\mathbf{e}_3 = (0,0,1,0)^\\top$。\n- 步骤 $j=1$：\n  - $\\mathbf{z}_1 = \\mathbf{A}\\mathbf{q}_1 = \\mathbf{A}\\mathbf{e}_3 = 3\\mathbf{e}_3 = (0,0,3,0)^\\top$。\n  - $\\alpha_1 = \\mathbf{q}_1^\\mathsf{T} \\mathbf{z}_1 = \\mathbf{e}_3^\\mathsf{T} (3\\mathbf{e}_3) = 3$。\n  - $\\mathbf{w}_1 = \\mathbf{z}_1 - \\alpha_1\\mathbf{q}_1 = 3\\mathbf{e}_3 - 3\\mathbf{e}_3 = \\mathbf{0}$。\n  - $\\beta_1 = \\lVert \\mathbf{w}_1 \\rVert_2 = 0$。\n由于 $\\beta_1=0 \\le \\varepsilon$，算法在 $m=1$ 处中断。得到的矩阵是 $\\mathbf{T}_1 = [\\alpha_1] = [3]$。唯一的 RR 值是 $3$，即精确的特征值。过程在一步内终止。任务是报告步数，即 $m=1$。\n\n**情况 3：非零谱质量**\n\n起始向量是 $\\mathbf{v}_1^{(\\mathrm{all})} = \\frac{1}{2}(1,1,1,1)^\\top$。该向量在每个特征向量 $\\mathbf{e}_j$ 方向上都有非零分量。在 $\\lambda_3=3$ 上的谱质量为 $w_3 = |\\mathbf{e}_3^\\mathsf{T} \\mathbf{v}_1^{(\\mathrm{all})}|^2 = |1/2|^2 = 1/4 \\neq 0$。\n\n因为起始向量在任何特征向量方向上都没有缺失分量，所以 Krylov 子空间 $\\mathcal{K}_k(\\mathbf{A}, \\mathbf{v}_1^{(\\mathrm{all})})$ 的维数会随着每一步增加，直到张成整个空间 $\\mathbb{R}^4$。这是因为矩阵 $\\mathbf{A}$ 具有互不相同的特征值。因此，Lanczos 算法将运行 $m=4$ 步，为 $\\mathbb{R}^4$ 生成一个基。得到的矩阵 $\\mathbf{T}_4$ 将是一个 $4 \\times 4$ 的三对角矩阵。Lanczos 关系式为 $\\mathbf{A} \\mathbf{Q}_4 = \\mathbf{Q}_4 \\mathbf{T}_4$，其中 $\\mathbf{Q}_4$ 是以 $\\{\\mathbf{q}_1, \\mathbf{q}_2, \\mathbf{q}_3, \\mathbf{q}_4\\}$ 为列的正交矩阵。这意味着 $\\mathbf{T}_4 = \\mathbf{Q}_4^\\mathsf{T} \\mathbf{A} \\mathbf{Q}_4$，因此 $\\mathbf{T}_4$ 与 $\\mathbf{A}$ 正交相似。所以，$\\mathbf{T}_4$ 必须与 $\\mathbf{A}$ 具有相同的特征值，即 $\\{1, 2, 3, 4\\}$。算法应在 $m=4$ 处终止，因为 $\\mathcal{K}_4$ 是一个不变子空间（即整个 $\\mathbb{R}^4$），这导致 $\\beta_4=0$。RR 值的集合将包含 $\\lambda_3=3$。实现将通过检查是否有任何 RR 值在 $3$ 的 $\\delta$ 容差范围内来证实这一点。预期结果为 `True`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lanczos(A, v_start, epsilon):\n    \"\"\"\n    Implements the Lanczos three-term recurrence.\n\n    Args:\n        A (np.ndarray): The real symmetric matrix.\n        v_start (np.ndarray): The starting unit vector.\n        epsilon (float): The breakdown tolerance for beta.\n\n    Returns:\n        tuple: A tuple containing:\n            - m (int): The number of steps until breakdown.\n            - T_m (np.ndarray): The m x m symmetric tridiagonal matrix.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Ensure v_start is a unit vector\n    q = v_start / np.linalg.norm(v_start)\n    q_prev = np.zeros(n)\n    \n    alphas = []\n    betas_off_diag = []\n    \n    m = 0\n    beta_prev = 0\n    \n    for j in range(n):  # Loop corresponds to j=1, 2, ..., n\n        z = A @ q\n        alpha = q.T @ z\n        alphas.append(alpha)\n        \n        # w = z - alpha*q - beta_{j-1}*q_{j-1}\n        w = z - alpha * q\n        if j > 0:\n            w -= betas_off_diag[-1] * q_prev\n        \n        beta = np.linalg.norm(w)\n        \n        m = j + 1\n        if beta = epsilon:\n            break\n        \n        betas_off_diag.append(beta)\n        q_prev = q\n        q = w / beta\n    \n    # Construct the tridiagonal matrix T_m of size m x m\n    T_m = np.diag(alphas)\n    if m > 1:\n        T_m += np.diag(betas_off_diag, k=1)\n        T_m += np.diag(betas_off_diag, k=-1)\n        \n    return m, T_m\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three specified cases.\n    \"\"\"\n    # Define matrix, target eigenvalue, and tolerances\n    A = np.diag([1.0, 2.0, 3.0, 4.0])\n    lambda3 = 3.0\n    epsilon = 1e-12\n    delta = 1e-10\n\n    # Define starting vectors for the three cases\n    v_no3 = np.array([1.0, 1.0, 0.0, 1.0]) / np.sqrt(3.0)\n    v_exact3 = np.array([0.0, 0.0, 1.0, 0.0])\n    v_all = np.array([1.0, 1.0, 1.0, 1.0]) / 2.0\n    \n    test_cases = [\n        {\"name\": \"Case 1\", \"vector\": v_no3},\n        {\"name\": \"Case 2\", \"vector\": v_exact3},\n        {\"name\": \"Case 3\", \"vector\": v_all},\n    ]\n\n    results = []\n\n    # Process Case 1: Zero spectral mass on lambda_3\n    m1, T1 = lanczos(A, test_cases[0][\"vector\"], epsilon)\n    rr_values1 = np.linalg.eigvalsh(T1)\n    case1_result = np.any(np.isclose(rr_values1, lambda3, atol=delta))\n    results.append(case1_result)\n\n    # Process Case 2: Exact eigenvector start\n    m2, T2 = lanczos(A, test_cases[1][\"vector\"], epsilon)\n    case2_result = m2\n    results.append(case2_result)\n\n    # Process Case 3: Non-zero spectral mass on lambda_3\n    m3, T3 = lanczos(A, test_cases[2][\"vector\"], epsilon)\n    rr_values3 = np.linalg.eigvalsh(T3)\n    case3_result = np.any(np.isclose(rr_values3, lambda3, atol=delta))\n    results.append(case3_result)\n    \n    # Convert booleans to lowercase strings for printing, if needed,\n    # but standard str() gives 'True'/'False'. The example format\n    # '[b_1,i_2,b_3]' implies placeholders. Using standard str() representation.\n    # The `map(str, ...)` handles conversion of all types.\n    print(f\"[{','.join(str(r).lower() if isinstance(r, bool) else str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的科学计算中，迭代方法很少会运行固定的步数，而是会一直运行直到达到预期的精度。这个高级练习  将挑战你将基础的兰索斯迭代升级为一个精巧的自适应求解器。你将从算法的基本递推关系中推导出一个有理论依据的停止准则，并将其付诸实践，从而实现一个能够自动确定所需步数以在指定容差内找到特征值的强大工具。",
            "id": "3247013",
            "problem": "您需要设计并实现一个基于 Lanczos 方法的自适应算法，该算法能自动确定达到指定精度所需​​的步数 $k$，以近似实对称矩阵的最大特征值。该算法必须基于 Krylov 子空间方法和实对称矩阵理论的第一性原理。\n\n从以下基本原理出发：\n- 一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 具有 $n$ 个实特征值，并拥有一组规范正交的特征向量基。\n- 对于一个给定的非零初始向量 $q_1 \\in \\mathbb{R}^n$，由 $A$ 和 $q_1$ 生成的 $k$ 维 Krylov 子空间为 $\\mathcal{K}_k(A,q_1) = \\operatorname{span}\\{q_1, Aq_1, A^2 q_1, \\dots, A^{k-1} q_1\\}$。\n- 使用针对实对称矩阵调整的 Gram–Schmidt 过程对序列 $\\{q_1, Aq_1, A^2 q_1, \\dots\\}$ 进行规范正交化，会产生 $\\mathcal{K}_k(A,q_1)$ 的一个规范正交基 $\\{q_1, q_2, \\dots, q_k\\}$，该基满足一个包含实标量 $\\alpha_j$ 和 $\\beta_j$ 的三项递推关系。\n\n基于这些原理，推导并实现一个自适应 Lanczos 迭代，该迭代需满足：\n- 构建规范正交基向量 $\\{q_j\\}$ 和相应的实对称三对角矩阵 $T_k \\in \\mathbb{R}^{k \\times k}$，其对角线元素为 $\\alpha_1, \\dots, \\alpha_k$，次对角线和超对角线元素为 $\\beta_1, \\dots, \\beta_{k-1}$。\n- 在每次迭代 $k$ 中，计算 $T_k$ 的特征值和特征向量（即 Ritz 对），选取最大的 Ritz 值 $\\theta_{\\max}^{(k)}$，并使用一个基于原理的残差估计来决定是停止还是继续。\n\n您的停止准则必须从第一性原理推导，且不得依赖任何预先给定的简化公式。具体而言，您的停止决策应基于从 Lanczos 关系推导出的 Ritz 对的残差，并用第 $k$ 步迭代的内蕴量来表示。当最大 Ritz 对的残差估计小于或等于用户指定的容差 $\\tau$ 时，或者当遇到有数学依据的 breakdown 条件时（例如，当规范正交化所需的范数为零，导致无法生成下一个基向量时），或者当迭代达到上限 $k_{\\max} = n$ 时，算法应终止。\n\n实现约束：\n- 输入矩阵必须是实对称的。\n- 初始向量必须是 $q_1 = \\frac{\\mathbf{1}}{\\|\\mathbf{1}\\|_2}$，其中 $\\mathbf{1}$ 是 $\\mathbb{R}^n$ 中的全一向量。\n- 对于所提供的测试套件，算法必须是完全确定性的。\n\n测试套件：\n实现您的算法并将其应用于以下四个测试用例。对于每个用例，报告三元组 $[k, \\theta_{\\max}, r]$，其中 $k$ 是终止时使用的 Lanczos 步数（整数），$\\theta_{\\max}$ 是终止时的最大 Ritz 值（浮点数），$r$ 是用于停止的残差估计（浮点数）。在所有情况下，最终输出中的浮点数均需四舍五入到小数点后 10 位。\n\n1. 正常情况用例：$A_1 \\in \\mathbb{R}^{10 \\times 10}$ 定义为 $A_1 = \\frac{G + G^{\\mathsf{T}}}{2}$，其中 $G$ 的元素是使用以 $42$ 为种子的伪随机数生成器生成的独立标准正态分布。使用容差 $\\tau_1 = 10^{-8}$。\n2. 边界条件：$A_2 = I_8$（$8 \\times 8$ 的单位矩阵）。使用容差 $\\tau_2 = 10^{-12}$。\n3. 结构化边界用例：$A_3 \\in \\mathbb{R}^{50 \\times 50}$ 是一个三对角 Toeplitz 矩阵，其主对角线元素为 $2$，次对角线和超对角线元素为 $-1$。使用容差 $\\tau_3 = 10^{-10}$。\n4. 接近机器精度的严苛容差：$A_4 \\in \\mathbb{R}^{12 \\times 12}$ 定义为 $A_4 = \\frac{H + H^{\\mathsf{T}}}{2}$，其中 $H$ 的元素是使用以 $7$ 为种子的伪随机数生成器生成的独立标准正态分布。使用容差 $\\tau_4 = 10^{-14}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的三元组 $[k,\\theta_{\\max},r]$，顺序为 $A_1, A_2, A_3, A_4$。例如，输出应如下所示：\n$[\\,[k_1,\\theta_{\\max,1},r_1],[k_2,\\theta_{\\max,2},r_2],[k_3,\\theta_{\\max,3},r_3],[k_4,\\theta_{\\max,4},r_4]\\,]$.\n所有浮点数必须四舍五入到小数点后 10 位，所有整数必须是精确的。",
            "solution": "该问题要求设计并实现一个自适应 Lanczos 算法，以近似实对称矩阵 $A$ 的最大特征值。任务的核心是根据 Lanczos 过程的基本关系推导出一个基于原理的停止准则，并用它来自动确定必要的迭代次数 $k$。\n\n我们首先建立理论基础。Lanczos 算法是针对实对称矩阵的 Arnoldi 迭代的一个特例。它为 $k$ 维 Krylov 子空间 $\\mathcal{K}_k(A, q_1) = \\operatorname{span}\\{q_1, A q_1, \\dots, A^{k-1} q_1\\}$ 构建一个规范正交基 $\\{q_1, q_2, \\dots, q_k\\}$，其中 $q_1$ 是一个给定的初始向量，满足 $\\|q_1\\|_2 = 1$。由于矩阵 $A$ 的对称性，规范正交化过程简化为一个三项递推关系。\n\n令 $Q_k = [q_1, q_2, \\dots, q_k]$ 是一个 $n \\times k$ 的矩阵，其列为 Lanczos 向量。三项递推关系如下：\n$$ \\beta_j q_{j+1} = A q_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1} $$\n对于 $j = 1, 2, \\dots, k$，初始条件为 $\\beta_0 = 0$ 和 $q_0 = \\mathbf{0}$。系数按如下方式确定：\n- 对角系数 $\\alpha_j$ 的选择是为了使下一个向量 $A q_j - \\alpha_j q_j$ 与 $q_j$ 正交。由于先前的向量 $\\{q_i\\}_{ij}$ 已经通过构造正交，我们只需要强制 $A q_j - \\alpha_j q_j$ 与 $q_j$ 正交。这导致 $\\alpha_j = q_j^\\mathsf{T} A q_j$。\n- 次对角系数 $\\beta_j$ 是下一个向量的范数，即 $\\beta_j = \\|A q_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1}\\|_2$。它被用作归一化因子，以确保 $\\|q_{j+1}\\|_2=1$。如果 $\\beta_j = 0$，算法终止。\n\n这些关系可以紧凑地写成矩阵形式。对于 $j=1, \\dots, k$，递推关系可以表示为 $A q_j = \\beta_{j-1} q_{j-1} + \\alpha_j q_j + \\beta_j q_{j+1}$。将这些列关系组合起来，得到\n$$ A Q_k = Q_k T_k + \\beta_k q_{k+1} e_k^\\mathsf{T} $$\n其中 $T_k$ 是 $k \\times k$ 的实对称三对角矩阵，其对角线为 $\\{\\alpha_j\\}$，次对角线为 $\\{\\beta_j\\}$。$e_k$ 是第 $k$ 个标准基向量。\n\nRayleigh-Ritz 方法在子空间 $\\mathcal{K}_k$ 中寻找近似特征对。这相当于求解 $T_k$ 的特征问题：$T_k s_i = \\theta_i s_i$。得到的特征值 $\\theta_i$ 是 Ritz 值，它们是 $A$ 的特征值的近似。相应的 Ritz 向量 $y_i = Q_k s_i$ 是 $A$ 的特征向量的近似。\n\n现在，我们推导停止准则。我们需要估计 Ritz 对 $(\\theta_i, y_i)$ 的残差范数 $\\|A y_i - \\theta_i y_i\\|_2$。\n从 Lanczos 关系式出发，我们有 $A Q_k = Q_k T_k + \\beta_k q_{k+1} e_k^\\mathsf{T}$。\n将两边乘以 $s_i$：\n$$ A Q_k s_i = Q_k T_k s_i + \\beta_k q_{k+1} e_k^\\mathsf{T} s_i $$\n使用 $y_i = Q_k s_i$ 和 $T_k s_i = \\theta_i s_i$：\n$$ A y_i = Q_k (\\theta_i s_i) + \\beta_k q_{k+1} (s_i(k)) $$\n其中 $s_i(k)$ 是特征向量 $s_i$ 的第 $k$ 个（即最后一个）分量。\n将 $\\theta_i y_i = \\theta_i Q_k s_i$ 代入，得到\n$$ A y_i = \\theta_i y_i + \\beta_k s_i(k) q_{k+1} $$\n因此，残差向量为：\n$$ r_i = A y_i - \\theta_i y_i = \\beta_k s_i(k) q_{k+1} $$\n由于 $q_{k+1}$ 是一个单位向量，残差范数为：\n$$ \\|r_i\\|_2 = \\|A y_i - \\theta_i y_i\\|_2 = |\\beta_k s_i(k)| $$\n这个公式非常强大，因为它允许我们仅使用 Lanczos 过程在第 $k$ 步计算出的量（$\\beta_k$）和 $T_k$ 的一个特征向量的最后一个分量（$s_i(k)$）来廉价地计算出 Ritz 对的残差范数。\n\n对于自适应算法，我们在每次迭代 $k$ 中：\n1.  计算 $\\alpha_k$ 和 $\\beta_k$。\n2.  构建 $T_k$。\n3.  求解 $T_k$ 的特征问题以获得其所有特征对 $(\\theta_i, s_i)$。\n4.  选择我们感兴趣的 Ritz 对。对于这个问题，是具有最大 Ritz 值 $\\theta_{\\max}^{(k)}$ 的那个。\n5.  计算其残差范数估计值 $r_k = |\\beta_k s_{\\max}(k)|$。\n6.  如果 $r_k \\le \\tau$（给定的容差），则算法收敛，我们停止并返回 $k$、$\\theta_{\\max}^{(k)}$ 和 $r_k$。\n7.  如果 $\\beta_k$ 小于数值零（breakdown 条件），我们也停止。\n8.  否则，我们计算 $q_{k+1}$ 并继续下一次迭代。\n\n这种方法将 Lanczos 过程从一个固定步数的算法转变为一个目标导向的、自适应的求解器。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_lanczos(A: np.ndarray, tol: float):\n    \"\"\"\n    Performs the adaptive Lanczos iteration to find the largest eigenvalue\n    of a real symmetric matrix A.\n\n    Args:\n        A (np.ndarray): The real symmetric matrix.\n        tol (float): The tolerance for the stopping criterion.\n\n    Returns:\n        A tuple (k, theta_max, residual_est) containing:\n        - k (int): The number of iterations performed.\n        - theta_max (float): The largest approximate eigenvalue (Ritz value).\n        - residual_est (float): The final residual norm estimate.\n    \"\"\"\n    n = A.shape[0]\n    \n    q_curr = np.ones(n) / np.sqrt(n)\n    q_prev = np.zeros(n)\n    \n    alphas = []\n    betas_off_diag = [] # Betas for T_k: beta_1, ..., beta_{k-1}\n    \n    beta_prev = 0.0\n\n    # Numerical zero for breakdown condition\n    numerical_zero = 1e-15\n\n    for k in range(1, n + 1):\n        v = A @ q_curr\n        alpha = np.dot(q_curr.T, v)\n        alphas.append(alpha)\n\n        w = v - alpha * q_curr - beta_prev * q_prev\n        beta_curr = np.linalg.norm(w)\n\n        # Construct T_k\n        T_k = np.diag(alphas)\n        if k > 1:\n            T_k += np.diag(betas_off_diag, k=1) + np.diag(betas_off_diag, k=-1)\n\n        # Find eigenpairs of T_k\n        eigvals, eigvecs = np.linalg.eigh(T_k)\n        \n        theta_max = eigvals[-1]\n        s_max = eigvecs[:, -1]\n        s_max_k = s_max[-1]\n\n        # Residual estimate for the largest Ritz pair\n        residual_est = np.abs(beta_curr * s_max_k)\n        \n        # Check termination conditions\n        if residual_est = tol or k == n or beta_curr = numerical_zero:\n            return k, theta_max, residual_est\n\n        # Prepare for next iteration\n        betas_off_diag.append(beta_curr)\n        q_next = w / beta_curr\n        \n        q_prev = q_curr\n        q_curr = q_next\n        beta_prev = beta_curr\n        \n    # Fallback, should not be reached due to k == n condition in the loop.\n    return n, theta_max, residual_est\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for the adaptive Lanczos algorithm.\n    \"\"\"\n    \n    # Test Case 1: Normal case\n    seed1 = 42\n    n1 = 10\n    tol1 = 1e-8\n    rng1 = np.random.default_rng(seed1)\n    G = rng1.standard_normal((n1, n1))\n    A1 = (G + G.T) / 2.0\n    \n    # Test Case 2: Boundary condition\n    n2 = 8\n    tol2 = 1e-12\n    A2 = np.identity(n2)\n    \n    # Test Case 3: Structured boundary case\n    n3 = 50\n    tol3 = 1e-10\n    diag_main = 2.0 * np.ones(n3)\n    diag_off = -1.0 * np.ones(n3 - 1)\n    A3 = np.diag(diag_main) + np.diag(diag_off, k=1) + np.diag(diag_off, k=-1)\n\n    # Test Case 4: Tight tolerance\n    seed4 = 7\n    n4 = 12\n    tol4 = 1e-14\n    rng4 = np.random.default_rng(seed4)\n    H = rng4.standard_normal((n4, n4))\n    A4 = (H + H.T) / 2.0\n    \n    test_cases = [\n        (A1, tol1),\n        (A2, tol2),\n        (A3, tol3),\n        (A4, tol4),\n    ]\n\n    results = []\n    for A, tol in test_cases:\n        k, theta_max, r = adaptive_lanczos(A, tol)\n        \n        theta_max_rounded = f\"{theta_max:.10f}\"\n        r_rounded = f\"{r:.10f}\"\n        \n        results.append(f\"[{k},{theta_max_rounded},{r_rounded}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}