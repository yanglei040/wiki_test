{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导你为线性平流方程实现最基础的有限体积格式——一阶迎风格式。这是一个基础练习，让你从零开始构建一个求解器，并直接观察一种关键的数值产物，即数值扩散。通过量化一个尖锐的阶跃函数如何随时间变得模糊，你将对简单数值格式的内在局限性获得直观的理解 。",
            "id": "2394306",
            "problem": "考虑一维线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n其定义在长度为 $L$ 的周期性域上，即 $x \\in [0,L)$，并采用周期性边界条件。平流速度 $a$ 是一个正常数。从积分守恒律和均匀网格上有限体积平均的定义出发，推导一个与 $a0$ 时信息传播物理特性相符的一阶、显式、守恒的有限体积方法。\n\n你将通过模拟块状阶跃函数的平流来研究数值扩散，并量化界面随时间的弥散程度。使用一个包含 $N$ 个单元的均匀网格，空间步长为 $\\Delta x = L/N$，单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，$i=0,1,\\dots,N-1$。设初始条件为块状函数\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $x_L = 0.2\\,L$ 且 $x_R = 0.7\\,L$。使用一阶有限体积格式演化该解，其显式时间步长 $\\Delta t$ 的选择应满足预设的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。在给定模拟的所有时间步中，使用相同的常数 $\\nu$。让模拟运行至一个预设的最终时间 $T$；使用整数个时间步 $n = \\text{round}(T/\\Delta t)$，使得模拟时间为 $t_n = n\\,\\Delta t$。\n\n将在时间 $t_n$ 处下降界面的“弥散宽度”定义为：从单元中心剖面下穿 $\\theta_{\\text{hi}} = 0.9$ 水平的点，到其后下穿 $\\theta_{\\text{lo}} = 0.1$ 水平的点之间的最小空间距离（沿周期性域测量）。使用相邻单元中心的单元中心值进行线性插值来计算这些交叉点。当存在多个下降界面时（由于周期性），计算每个下降界面周围的弥散宽度，并报告最小宽度。用与 $L$ 相同的无量纲长度单位表示该宽度。\n\n在单个程序中实现模拟和宽度测量。对于下方的每个测试用例，输出在时间 $t_n$ 测得的弥散宽度，并四舍五入到 $8$ 位小数。\n\n使用以下测试套件，参数为 $(N,\\ \\nu,\\ T,\\ a,\\ L)$：\n- 用例 1: $(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 2: $(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 3: $(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 4: $(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 5: $(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。例如，它应如下所示\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\n其中每个 $\\text{result}_k$ 是用例 $k$ 的弥散宽度，四舍五入到 $8$ 位小数。不允许有其他输出。",
            "solution": "我们从平流方程的积分守恒形式开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a0.\n$$\n令 $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ 为一个控制体积，其宽度均匀为 $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$，单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，并采用周期性索引。定义单元平均值\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\n将守恒律在 $\\mathcal{C}_i$ 上积分可得\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\n等价地，\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\n其中 $f_{i\\pm \\tfrac{1}{2}}$ 是通过单元交界面的通量。采用时间步长为 $\\Delta t$ 的一阶显式时间离散可得\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\n其中数值通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n$ 与物理特性一致。对于 $a0$ 的线性平流，信息从左向右传播，每个界面处的精确 Riemann 解仅依赖于左侧状态。因此，Godunov 迎风数值通量为\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a0.\n$$\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$，更新格式简化为一阶迎风格式\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a0,\n$$\n其中索引 $i$ 采用周期性。\n\n为了将此离散方法与连续过程联系起来并揭示数值扩散，我们进行修正方程分析。记 $\\bar{u}_i^n \\approx u(x_i,t^n)$，其中 $t^n = n\\Delta t$。在时间上进行泰勒展开可得\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\n对后向差分在空间上进行泰勒展开可得\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\n代入格式中可得\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\n两边同除以 $\\Delta t$ 并回顾 $\\nu = a\\Delta t/\\Delta x$，\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\n主导修正项是一个扩散项，其有效（或人为）扩散系数为\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\n因此，对于 $0  \\nu  1$，一阶迎风法会引入数值扩散，它将间断弥散开来，其宽度增长趋势如同 $\\sqrt{D_{\\text{num}}\\,t}$，而当 $\\nu=1$ 时，主导扩散项消失，该方法简化为网格上的纯粹平移算子。\n\n为了量化阶跃的弥散程度，我们定义 $10$–$90$ 厚度。考虑一个下降界面，在该界面上 $u$ 的值从接近 $1$ 降至接近 $0$。令 $\\theta_{\\text{hi}} = 0.9$ 和 $\\theta_{\\text{lo}} = 0.1$。在分段常数的单元中心剖面 $\\{\\bar{u}_i^n\\}$ 上，我们通过在相邻单元中心之间进行线性插值来确定 $u=\\theta$ 的近似位置。具体来说，对于下降前缘上满足 $\\bar{u}_i^n \\ge \\theta  \\bar{u}_{i+1}^n$ 的一对相邻索引 $(i,i+1)$，\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\n我们在整个区域内（考虑周期性）收集所有向下的 $\\theta_{\\text{hi}}$ 交叉点和所有向下的 $\\theta_{\\text{lo}}$ 交叉点，对于每个 $\\theta_{\\text{hi}}$ 交叉点，我们确定沿周期坐标到后续 $\\theta_{\\text{lo}}$ 交叉点的距离。此类距离的最小值，记作 $w_{10\\text{–}90}$，即为测得的弥散宽度。该宽度以与 $L$ 相同的长度单位报告。\n\n算法设计：\n- 空间离散化：均匀单元、周期性边界条件、对于 $a0$ 的一阶迎风通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$。\n- 时间步进：采用前向欧拉法，固定 $\\Delta t$ 以满足预设的 $\\nu = a\\,\\Delta t/\\Delta x$；推进 $n=\\text{round}(T/\\Delta t)$ 步。\n- 初始化：在 $[0.2L, 0.7L)$ 上为块状函数 $u(x,0)=1$，在 $[0,L)$ 的其他位置为 $0$，在单元中心处采样。\n- 宽度测量：使用单元中心值的线性插值计算 $w_{10\\text{–}90}$，并取下降界面上 $\\theta_{\\text{hi}}$ 和 $\\theta_{\\text{lo}}$ 交叉点之间的最小下游距离；使用周期性展开来处理 $x=0$ 附近的界面。\n\n基于 $D_{\\text{num}}$ 的定性预期：对于固定的 $a$、$L$ 和 $T$，更精细的网格（更小的 $\\Delta x$）会减小 $D_{\\text{num}}$，从而减少弥散；更大的 $\\nu$（更接近 $1$）也会减小 $D_{\\text{num}}$，产生更窄的界面；在 $\\nu=1$ 时，主导扩散项消失，界面基本上被限制在网格尺度的厚度。程序精确地实现了该格式和测量方法，并对每个指定的测试用例 $(N,\\nu,T,a,L)$，输出弥散宽度 $w_{10\\text{–}90}(t_n)$，四舍五入到 $8$ 位小数，并按要求将结果汇总为单行列表。",
            "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a > 0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x >= xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i > u_ip1 (strict to avoid degenerate flat segments)\n        if u_i > u_ip1:\n            # theta_hi crossing: u_i >= theta_hi > u_ip1\n            if (u_i >= theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i >= theta_lo > u_ip1\n            if (u_i >= theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions) > 0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions) > 0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists) > 0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在了解了一阶格式的局限性后，一个自然的想法是提高其精度阶数。本练习通过比较一阶迎风法和无限制的二阶格式来探索这一思路。你会发现数值方法中一个关键的权衡：虽然二阶格式对光滑解更精确，但它会在间断附近引入非物理的振荡，有时甚至导致更大的总误差 。这解释了为何像通量限制器这样的高级技术对于高分辨率方法至关重要。",
            "id": "2394314",
            "problem": "您的任务是比较线性平流方程的两种守恒型有限体积离散化方法，并量化说明在何种情况下，由于在间断附近的伪振荡，二阶线性重构方法的性能会劣于一阶方法。\n\n考虑在周期性区域 $[0,1)$ 上的线性平流方程\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n其中平流速度 $a0$ 为常数。设将区域均匀剖分为 $N$ 个单元，界面为 $x_{i\\pm \\frac{1}{2}}$，且 $x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}=\\Delta x$，单元中心为 $x_i = \\frac{1}{2}\\left(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}}\\right)$。单元平均值定义为\n$$\nu_i^n \\equiv \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t^n)\\,dx.\n$$\n守恒更新格式为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n其中，当 $a0$ 时，迎风数值通量为 $F_{i+\\frac{1}{2}}^n = a\\,u_{i+\\frac{1}{2}}^{-,n}$，其中 $u_{i+\\frac{1}{2}}^{-,n}$ 是在 $x_{i+\\frac{1}{2}}$ 处由单元 $i$ 重构出的左侧迹。假设索引是周期性的，因此 $u_{i+N}^n = u_i^n$ 且 $u_{i-N}^n = u_i^n$。\n\n您必须实现并比较：\n- 一阶重构（分片常数），定义为 $u_{i+\\frac{1}{2}}^{-,n} = u_i^n$。\n- 无任何限制器的二阶线性重构，由斜率 $s_i^n = \\frac{1}{2}\\left(u_{i+1}^n - u_{i-1}^n\\right)$ 定义，且 $u_{i+\\frac{1}{2}}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$。\n\n使用一个固定的 Courant-Friedrichs-Lewy (CFL) 数 $\\nu \\in (0,1)$ 通过\n$$\n\\Delta t = \\nu \\frac{\\Delta x}{a}.\n$$\n来设置时间步长。如果最终时间 $T$ 不是 $\\Delta t$ 的整数倍，则最后一步采用一个缩小的 $\\Delta t$，以确保总积分时间恰好等于 $T$。\n\n对于下方的每个测试用例，用每种方法计算在时间 $T$ 的数值解，然后计算在时间 $T$ 的单元平均精确解，该精确解由\n$$\nu(x,T) = u_0\\big((x - a T) \\bmod 1\\big),\n$$\n给出，其单元平均值为\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(y,T)\\,dy.\n$$\n使用单元平均值的离散 $L^1$ 范数量化误差：\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|.\n$$\n\n所有用例均使用 $a = 1$ 和 $\\nu = 0.9$。所有用例的区域均为 $[0,1)$，并带有周期性边界条件。测试套件的初始条件 $u_0(x)$、单元数 $N$ 和最终时间 $T$ 如下：\n\n- 测试用例 1（间断高帽函数，非对齐）：$N=200$，$T=0.25$，以及\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [0.2, 0.4),\\\\\n  0,  \\text{其它情况,}\n  \\end{cases}\n  $$\n  在 $[0,1)$ 上作周期性解释。\n\n- 测试用例 2（光滑波）：$N=80$，$T=0.5$，以及\n  $$\n  u_0(x) = \\sin(2\\pi x).\n  $$\n\n- 测试用例 3（与网格间距相关的窄高帽函数）：$N=80$，$T=0.3$，以及\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [x_0, x_0 + 3\\Delta x),\\\\\n  0,  \\text{其它情况,}\n  \\end{cases}\n  $$\n  其中 $x_0 = 0.33$ 且 $\\Delta x = 1/N$；将 $[x_0, x_0+3\\Delta x)$ 解释为模 1。\n\n对于每个测试用例，计算一阶方法的 $E_1^{(1)}$ 和无任何限制器的二阶线性重构方法的 $E_1^{(2)}$。对于每个测试用例，如果 $E_1^{(2)}  E_1^{(1)}$，则返回整数 $1$，否则返回整数 $0$。\n\n您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的整数，格式为方括号括起来的逗号分隔列表（例如，$[1,0,1]$）。不应产生任何额外输出。",
            "solution": "所提出的问题要求对一维线性平流方程 $\\partial_t u + a\\,\\partial_x u = 0$ 的两种有限体积法离散格式进行比较分析。该比较基于离散 $L^1$ 误差范数，该范数是针对光滑初始剖面和间断初始剖面的数值解与精确解之差计算的。该分析旨在阐明守恒律数值方法中的一个基本权衡：高阶格式在光滑解上的准确性，与其在未配备斜率限制器时在间断附近产生伪振荡的趋势之间的矛盾。\n\n首先，我们建立离散框架。空间区域 $[0,1)$ 被剖分为 $N$ 个均匀单元，每个单元的宽度为 $\\Delta x = 1/N$。单元 $i$ 覆盖区间 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i+1/2} = (i+1)\\Delta x$（对于 $i=-1, \\dots, N-1$）。单元中心为 $x_i = (i+1/2)\\Delta x$。函数 $f(x)$ 在单元 $i$ 上的单元平均值记为 $f_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) \\, dx$。\n\n有限体积法通过守恒公式将时间 $t^n$ 的单元平均值 $u_i^n$ 演化到 $t^{n+1}=t^n+\\Delta t$：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n这里，$F_{i+1/2}^n$ 是界面 $x_{i+1/2}$ 处的数值通量。对于速度为 $a0$ 的线性平流方程，通量是纯迎风的，意味着它仅依赖于界面左侧的状态。这得到 $F_{i+1/2}^n = a \\cdot u_{i+1/2}^{-,n}$，其中 $u_{i+1/2}^{-,n}$ 是从单元 $i$ 的数据在界面 $x_{i+1/2}$ 左侧重构的解值。时间步长 $\\Delta t$ 由固定的 CFL 数 $\\nu = a \\Delta t / \\Delta x$ 决定，因此 $\\Delta t = \\nu \\Delta x / a$。问题指定 $a=1$ 和 $\\nu=0.9$。更新方程简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu \\left( u_{i+1/2}^{-,n} - u_{i-1/2}^{-,n} \\right)\n$$\n施加周期性边界条件，因此索引以 $N$ 为模进行处理。\n\n我们研究两种用于 $u_{i+1/2}^{-,n}$ 的重构方法：\n\n1.  **一阶迎风法**：此方法在每个单元内使用分片常数重构，$u(x) = u_i^n$ 对 $x \\in [x_{i-1/2}, x_{i+1/2}]$。界面 $x_{i+1/2}$ 左侧的值就是单元 $i$ 的单元平均值：\n    $$\n    u_{i+1/2}^{-,n} = u_i^n\n    $$\n    将此代入更新公式，得到经典的一阶迎风格式：\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( u_i^n - u_{i-1}^n \\right)\n    $$\n    已知该格式在 $\\nu \\in [0,1]$ 时是总变差减小 (TVD) 的，这可以防止产生新的振荡。然而，其精度仅为一阶，导致显著的数值耗散，从而抹平尖锐特征。\n\n2.  **二阶线性重构（无限制）**：此方法在每个单元内使用分片线性重构，$u(x) = u_i^n + s_i^n(x - x_i)$。问题根据指定的斜率公式定义了界面上的重构，我们将其解释为无量纲斜率。重构值为 $u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$，其中 $s_i^n = \\frac{1}{2}(u_{i+1}^n - u_{i-1}^n)$。将它们结合起来得到：\n    $$\n    u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{4}\\left( u_{i+1}^n - u_{i-1}^n \\right)\n    $$\n    对于光滑解，此重构在空间上以二阶精度逼近点值 $u(x_{i+1/2})$。更新公式变为：\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left[ \\left( u_i^n + \\frac{1}{4}(u_{i+1}^n - u_{i-1}^n) \\right) - \\left( u_{i-1}^n + \\frac{1}{4}(u_i^n - u_{i-2}^n) \\right) \\right]\n    $$\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( \\frac{3}{4}u_i^n - \\frac{5}{4}u_{i-1}^n + \\frac{1}{4}u_{i+1}^n + \\frac{1}{4}u_{i-2}^n \\right)\n    $$\n    这是一个涉及单元 $i-2, i-1, i, i+1$ 的四点模板的线性格式。虽然它在光滑解上达到二阶精度，但它不是 TVD 的，并且已知具有色散性，会在间断附近产生伪振荡 (Gibbs 现象)。本练习的目的是量化这些振荡何时会导致比耗散性的一阶格式更大的误差。\n\n为了进行分析，我们首先通过在每个单元上对初始条件 $u_0(x)$ 进行积分来计算初始单元平均值 $u_i^0$。\n- 对于在区间 $[b_1, b_2)$ 上为 1、其他地方为 0 的高帽函数 $u_0(x)$，单元平均值为 $u_i^0 = \\frac{1}{\\Delta x} \\text{length}([x_{i-1/2}, x_{i+1/2}] \\cap [b_1, b_2))$。\n- 对于光滑函数 $u_0(x) = \\sin(2\\pi x)$，积分可以解析地计算：\n  $$\n  u_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} \\sin(2\\pi x) dx = \\frac{\\cos(2\\pi i\\Delta x) - \\cos(2\\pi(i+1)\\Delta x)}{2\\pi\\Delta x} = \\frac{\\sin(\\pi\\Delta x)}{\\pi\\Delta x}\\sin(2\\pi x_i)\n  $$\n\n平流方程的精确解是 $u(x,T) = u_0((x-aT)\\pmod 1)$。最终时间 $T$ 的精确单元平均值通过在每个单元上对此精确解进行积分来计算：\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u_0((x-aT)\\pmod 1) \\,dx\n$$\n此计算类似于求初始单元平均值，但初始剖面被平移了 $aT$。\n\n时间积分使用固定的时间步长 $\\Delta t = \\nu \\Delta x / a$ 进行 $N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$ 个完整步长。如果存在剩余时间 $\\Delta t_{\\text{final}} = T - N_{\\text{steps}}\\Delta t  0$，则采用一个更小的时间步长来精确达到时间 $T$。\n\n最后，每种方法的误差使用离散 $L^1$ 范数进行量化：\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|\n$$\n对于每个测试用例，我们计算一阶方法的误差 $E_1^{(1)}$ 和二阶方法的误差 $E_1^{(2)}$。然后我们确定是否 $E_1^{(2)}  E_1^{(1)}$。\n\n- **测试用例 1（间断高帽函数）**：初始条件是间断的。二阶方法将在高帽函数的边缘产生显著的过冲和下冲。一阶方法将抹平边缘。与耗散但非振荡的一阶格式相比，二阶格式产生的大的、非衰减的振荡预计将导致更大的 $L^1$ 误差。因此，我们预期 $E_1^{(2)}  E_1^{(1)}$。\n- **测试用例 2（光滑波）**：初始条件是 $C^\\infty$。对于此类解，二阶方法的优越精度将清晰可见。它将以比高度耗散的一阶方法小得多的误差来逼近正弦波。我们预期 $E_1^{(2)}  E_1^{(1)}$。\n- **测试用例 3（窄高帽函数）**：这是另一个间断情况，由于特征的宽度仅为几个网格单元（$3\\Delta x$），因此更具挑战性。这突显了无限制线性重构的缺陷，因为用于斜率计算的模板跨越了特征的很大一部分。我们再次预期会出现大振荡且 $E_1^{(2)}  E_1^{(1)}$。\n\n实现将通过创建一个可配置为任一方法的通用有限体积求解器来进行。该求解器将应用于每个测试用例，计算误差，并按要求进行比较。",
            "answer": "```python\nimport numpy as np\n\ndef get_box_averages(N, box_start, box_end):\n    \"\"\"\n    Computes cell averages for a function that is 1 on [box_start, box_end)\n    and 0 otherwise, on a periodic domain [0,1).\n    \"\"\"\n    dx = 1.0 / N\n    cell_starts = np.arange(N) * dx\n    cell_ends = (np.arange(N) + 1) * dx\n    u_avg = np.zeros(N)\n\n    # Handle multiple integer wrappings of the interval\n    num_wraps = np.floor(box_end) - np.floor(box_start)\n    s_mod = box_start % 1.0\n    e_mod = box_end % 1.0\n\n    if num_wraps == 0: # Interval does not cross an integer\n        s, e = s_mod, e_mod\n        if e = s: # e.g. [0.2, 0.1) or [0.2, 0.2)\n            return u_avg\n        overlap = np.maximum(0, np.minimum(cell_ends, e) - np.maximum(cell_starts, s))\n        u_avg += overlap\n    else: # Interval crosses at least one integer\n        # Part from start to 1.0\n        overlap1 = np.maximum(0, np.minimum(cell_ends, 1.0) - np.maximum(cell_starts, s_mod))\n        u_avg += overlap1\n        # Part from 0.0 to end\n        overlap2 = np.maximum(0, np.minimum(cell_ends, e_mod) - np.maximum(cell_starts, 0.0))\n        u_avg += overlap2\n        # Full wraps\n        if num_wraps > 1:\n            u_avg += (num_wraps - 1) * dx\n\n    return u_avg / dx\n\ndef run_fvm(u_initial, N, T, a, nu_fixed, method):\n    \"\"\"\n    Solves the linear advection equation using the finite volume method.\n    \"\"\"\n    u = u_initial.copy()\n    dx = 1.0 / N\n    \n    dt_fixed = nu_fixed * dx / a\n    if dt_fixed = 0:\n        return u\n        \n    num_steps = int(T / dt_fixed) if T > 0 else 0\n    t = 0.0\n\n    # Perform full time steps\n    for _ in range(num_steps):\n        nu = nu_fixed\n        if method == 'first':\n            # First-order upwind\n            u = u - nu * (u - np.roll(u, 1))\n        elif method == 'second':\n            # Second-order unlimited linear reconstruction\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu * flux_diff\n        t += dt_fixed\n    \n    # Perform final, smaller time step if needed\n    dt_final = T - t\n    if dt_final > 1e-12:\n        nu_final = a * dt_final / dx\n        if method == 'first':\n            u = u - nu_final * (u - np.roll(u, 1))\n        elif method == 'second':\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu_final * flux_diff\n            \n    return u\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # (N, T, initial_condition_type, params)\n        (200, 0.25, 'top-hat', {'start': 0.2, 'end': 0.4}),\n        (80, 0.5, 'sine-wave', {}),\n        (80, 0.3, 'narrow-top-hat', {'x0': 0.33}),\n    ]\n\n    a = 1.0\n    nu_fixed = 0.9\n    results = []\n\n    for N, T, u0_type, params in test_cases:\n        dx = 1.0 / N\n        x_centers = (np.arange(N) + 0.5) * dx\n\n        # --- Initial Conditions ---\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_initial = get_box_averages(N, start, end)\n        elif u0_type == 'sine-wave':\n            # Use analytical formula for cell-averaged sine\n            factor = np.sinc(dx) # np.sinc(x) = sin(pi*x)/(pi*x)\n            u_initial = factor * np.sin(2 * np.pi * x_centers)\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_initial = get_box_averages(N, start, end)\n\n        # --- Run Simulations ---\n        u_final_1st = run_fvm(u_initial, N, T, a, nu_fixed, 'first')\n        u_final_2nd = run_fvm(u_initial, N, T, a, nu_fixed, 'second')\n        \n        # --- Exact Solution ---\n        shift = (a * T) % 1.0\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_exact = get_box_averages(N, start + shift, end + shift)\n        elif u0_type == 'sine-wave':\n            # u(x,T) = sin(2*pi*(x-aT))\n            # For T=0.5, a=1, this is sin(2*pi*x - pi) = -sin(2*pi*x)\n            factor = np.sinc(dx)\n            u_exact = factor * np.sin(2 * np.pi * (x_centers - a * T))\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_exact = get_box_averages(N, start + shift, end + shift)\n\n        # --- Compute Errors and Compare ---\n        e1_1st = dx * np.sum(np.abs(u_final_1st - u_exact))\n        e1_2nd = dx * np.sum(np.abs(u_final_2nd - u_exact))\n        \n        results.append(1 if e1_2nd > e1_1st else 0)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现实世界中的物理现象，如流体动力学中的激波，通常是呈非线性的。本练习将带领你从线性平流方程过渡到非线性的无粘性伯格斯方程，这是一个研究激波和稀疏波的经典原型。你将实现并比较简单的迎风通量和更复杂的 Harten-Lax-van Leer (HLL) 近似黎曼求解器，从而在捕捉非线性守恒律中出现的复杂波现象方面获得实践经验 。",
            "id": "2394328",
            "problem": "针对无粘伯格斯方程，使用两种不同的数值通量实现一个一维有限体积求解器，并比较它们捕捉激波和稀疏波的能力。求解的起点是守恒律及其积分形式。从基本守恒声明开始：对于密度为 $u(x,t)$、通量为 $f(u)$ 的守恒量，其局域守恒律为 $u_t + f(u)_x = 0$。在控制体 $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上，其积分形式为 $\\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx + \\left.f(u)\\right|_{x_{i+\\frac{1}{2}}} - \\left.f(u)\\right|_{x_{i-\\frac{1}{2}}} = 0$。将此方程离散化，得到在时间 $t^n$、时间步长为 $\\Delta t$、网格宽度为 $\\Delta x$ 的条件下，网格平均值 $U_i^n$ 的一阶有限体积更新格式。其中，界面上的物理通量由近似局部黎曼问题解的数值通量替代。问题陈述中未提供额外的公式；您必须从这些原理推导出离散更新格式和数值通量。\n\n使用特定的守恒律 $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$，即通量为 $f(u)=\\frac{1}{2}u^2$ 的无粘伯格斯方程。在每个网格界面上，基于左、右状态 $u_L$ 和 $u_R$ 实现两种数值通量：\n- 一种 Harten–Lax–van Leer (HLL) 近似黎曼求解器，通过最小和最大特征速度来限定信号速度，并对近似的黎曼扇进行积分推导得出。对于标量情况，当波被左、右特征速度正确定界时，该通量可简化为一种Godunov型通量。\n- 一种基本的迎风通量，通过使用由界面状态计算出的单一平流速度对非线性通量进行局部线性化，并根据该速度的符号应用施主网格迎风法则获得。\n\n算法要求：\n- 在区域 $[x_L,x_R] = [-1,1]$ 上使用包含 $N$ 个网格的均匀网格，网格中心位于 $x_i = x_L + \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中 $i=0,1,\\dots,N-1$，$ \\Delta x = \\frac{x_R - x_L}{N}$。\n- 初始化一个在 $x=0$ 处存在间断的黎曼问题：当 $x  0$ 时 $u(x,0) = u_L$，当 $x \\ge 0$ 时 $u(x,0) = u_R$。\n- 使用显式向前欧拉法对有限体积更新格式进行时间推进，直至最终时间 $T$，并在每个时间步长中，基于区域内的最大特征速度 $|f'(u)| = |u|$ 强制执行 Courant–Friedrichs–Lewy (CFL) 稳定性条件。使用 $\\Delta t \\le \\nu \\frac{\\Delta x}{\\max_i |u_i|}$，其中所选的 CFL 数 $\\nu$ 严格小于 $1$。\n- 应用透射（零梯度）边界条件，通过在每侧设置一个虚拟网格实现，即在每个时间步将最近的内部值复制到相应的虚拟网格中。\n\n用于误差评估的参考解：\n- 推导并使用无粘伯格斯方程的精确自相似黎曼解，以计算网格中心的参考值 $u(x_i,T)$。对于 $u_L  u_R$ 的情况，解是一个激波，其移动速度由 Rankine–Hugoniot 条件给出。对于 $u_L  u_R$ 的情况，解是一个中心稀疏扇，其在左、右特征速度之间呈线性分布。\n\n测试套件与输出：\n- 所有测试均使用 $N=400$，$\\nu=0.9$，区域 $[x_L,x_R]=[-1,1]$，间断点位于 $x=0$，最终时间 $T=0.3$。定义三种初始状态 $(u_L,u_R)$：\n  1. $u_L=2.0$, $u_R=0.0$ (激波主导情况)。\n  2. $u_L=0.0$, $u_R=2.0$ (扩张稀疏波情况)。\n  3. $u_L=-1.0$, $u_R=1.0$ (跨音速稀疏波情况)。\n- 对于每个测试用例 $k \\in \\{1,2,3\\}$，计算每种数值通量格式相对于精确解的离散 $L^1$ 误差：\n  $$E_{\\mathrm{HLL}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{HLL}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|,$$\n  $$E_{\\mathrm{UP}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{UP}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|.$$\n- 对于每个测试，还需计算一个指示符 $I^{(k)}$，如果 $E_{\\mathrm{HLL}}^{(k)}  E_{\\mathrm{UP}}^{(k)}$，则其为整数 $1$，否则为 $0$。\n\n单位：所有量均为无量纲；仅报告无量纲数。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个方括号括起来的逗号分隔列表，按以下顺序包含九个结果：\n  $$\\left[ E_{\\mathrm{HLL}}^{(1)}, E_{\\mathrm{UP}}^{(1)}, I^{(1)}, E_{\\mathrm{HLL}}^{(2)}, E_{\\mathrm{UP}}^{(2)}, I^{(2)}, E_{\\mathrm{HLL}}^{(3)}, E_{\\mathrm{UP}}^{(3)}, I^{(3)} \\right],$$\n  其中每个误差 $E_{\\mathrm{HLL}}^{(k)}$ 和 $E_{\\mathrm{UP}}^{(k)}$ 必须四舍五入到恰好六位小数，每个指示符 $I^{(k)}$ 是一个整数。例如，打印的字符串应类似于 $[\\dots]$，包含恰好九个逗号分隔的条目，无任何附加文本。",
            "solution": "本问题的求解始于守恒量 $u$ 在一个宽度为 $\\Delta x = x_{i+1/2} - x_{i-1/2}$ 的控制体（或网格）$C_i = [x_{i-1/2}, x_{i+1/2}]$ 上的积分形式守恒律：\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0\n$$\n我们将 $u$ 在网格 $C_i$ 上的网格平均值定义为 $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t) dx$。将此定义代入积分守恒律，假设网格均匀（$\\Delta x$ 为常数），得到一个关于网格平均值演化的精确方程：\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} (f_{i+1/2} - f_{i-1/2})\n$$\n其中 $f_{i \\pm 1/2}$ 表示在网格界面 $x_{i \\pm 1/2}$ 处的瞬时物理通量 $f(u)$。有限体积法的核心是用数值通量 $\\hat{f}_{i \\pm 1/2}$ 替换未知的物理通量，该数值通量是相邻网格平均状态的函数，即 $\\hat{f}_{i+1/2} = \\hat{f}(U_i, U_{i+1})$。为了得到全离散格式，我们使用显式向前欧拉法对时间进行离散。对于时间步长 $\\Delta t$，时间步 $n+1$ 的网格平均值由时间步 $n$ 的值给出：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n此为一阶精度更新公式。问题指定了无粘伯格斯方程 $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$，其通量为 $f(u) = \\frac{1}{2}u^2$，特征速度为 $f'(u) = u$。对于一阶格式，界面两侧的重构状态就是相邻网格的平均值。\n\n**基本迎风通量**：该通量基于对非线性通量的局部线性化。我们定义一个单一的局部平流速度 $a(u_L, u_R)$。一个常见的选择是算术平均值，这也对应于该方程的Roe平均速度：$a(u_L, u_R) = \\frac{u_L + u_R}{2}$。迎风通量根据该速度的符号，选择来自“上游”侧的通量：\n$$\n\\hat{f}_{\\text{upwind}}(u_L, u_R) = \\begin{cases} f(u_L)  \\text{若 } a(u_L, u_R) \\ge 0 \\\\ f(u_R)  \\text{若 } a(u_L, u_R)  0 \\end{cases}\n$$\n\n**Harten-Lax-van Leer (HLL) 通量**：HLL通量基于一个假设为双波模型的近似黎曼求解器。它假定界面处的解由三个常数状态（$u_L$、$u^*$、$u_R$）构成，由两个速度为 $S_L$ 和 $S_R$ 的波分隔。对于标量伯格斯方程，真实的波速被 $\\min(u_L, u_R)$ 和 $\\max(u_L, u_R)$ 所界定，因此我们选择这两个值作为信号速度的估计：$S_L = \\min(u_L, u_R)$ 且 $S_R = \\max(u_L, u_R)$。HLL通量的公式取决于波相对于网格界面的传播方向：\n- 如果 $S_L \\ge 0$，整个波结构向右传播，通量为 $\\hat{f}_{\\text{HLL}} = f(u_L)$。\n- 如果 $S_R \\le 0$，整个结构向左传播，通量为 $\\hat{f}_{\\text{HLL}} = f(u_R)$。\n- 如果 $S_L  0  S_R$，界面位于两个波之间，此时通量为：\n  $$\n  \\hat{f}_{\\text{HLL}}(u_L, u_R) = \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L}\n  $$\n\n伯格斯方程黎曼问题的**精确解**是自相似的，仅依赖于变量 $\\xi = x/t$。\n- **激波 ($u_L  u_R$)**：形成一个单一的间断，以速度 $s = \\frac{u_L + u_R}{2}$ 移动。解为：\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{若 } x/t  s \\\\ u_R,  \\text{若 } x/t  s \\end{cases}\n  $$\n- **稀疏波 ($u_L \\le u_R$)**：解是一个连接左、右状态的连续“扇形”，跨越特征速度 $u_L$ 和 $u_R$ 之间的区域。完整的解为：\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{若 } x/t \\le u_L \\\\ x/t,  \\text{若 } u_L  x/t  u_R \\\\ u_R,  \\text{若 } x/t \\ge u_R \\end{cases}\n  $$\n这个精确解将作为计算数值格式 $L^1$ 误差的参考。\n\n数值算法遵循问题规范实现：区域为 $[-1, 1]$，含 $N=400$ 个网格单元及两侧各一个虚拟单元用于施加透射边界条件 ($U_0^n = U_1^n, U_{N+1}^n = U_N^n$)。时间步长 $\\Delta t$ 在每步动态计算以满足 CFL 条件 $\\Delta t = \\nu \\frac{\\Delta x}{\\max_i |U_i^n|}$，其中 $\\nu=0.9$。模拟运行至 $T=0.3$。对于每个测试用例和通量类型，离散 $L^1$ 误差计算为 $E = \\Delta x \\sum_{i=0}^{N-1} |U_{i,\\text{num}}(T) - u_{\\text{exact}}(x_i,T)|$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    \n    # Problem Parameters\n    N = 400\n    x_L, x_R = -1.0, 1.0\n    T_final = 0.3\n    nu = 0.9  # CFL number\n    \n    test_cases = [\n        (2.0, 0.0),  # Case 1: Shock\n        (0.0, 2.0),  # Case 2: Rarefaction\n        (-1.0, 1.0), # Case 3: Transonic Rarefaction\n    ]\n\n    all_results = []\n\n    for k, (u_L, u_R) in enumerate(test_cases):\n        \n        # Run simulation with HLL flux\n        u_hll = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'hll')\n        \n        # Run simulation with Upwind flux\n        u_upwind = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'upwind')\n        \n        # Compute L1 errors\n        dx = (x_R - x_L) / N\n        x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n        # Error for HLL\n        u_exact_vals = exact_solution(x_centers, T_final, u_L, u_R)\n        e_hll = dx * np.sum(np.abs(u_hll - u_exact_vals))\n        \n        # Error for Upwind\n        e_upwind = dx * np.sum(np.abs(u_upwind - u_exact_vals))\n\n        # Indicator\n        indicator = 1 if e_hll  e_upwind else 0\n\n        # Append results for this test case\n        all_results.extend([round(e_hll, 6), round(e_upwind, 6), indicator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, flux_type):\n    \"\"\"\n    Runs a single 1D FVM simulation for the Burgers equation.\n    \n    Args:\n        N (int): Number of cells.\n        x_L (float): Left boundary of the domain.\n        x_R (float): Right boundary of the domain.\n        T_final (float): Final simulation time.\n        nu (float): CFL number.\n        u_L (float): Initial left state.\n        u_R (float): Initial right state.\n        flux_type (str): 'hll' or 'upwind'.\n        \n    Returns:\n        numpy.ndarray: The solution array u_n at the final time in the physical domain.\n    \"\"\"\n    dx = (x_R - x_L) / N\n    x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n    # Initialize solution array with 1 ghost cell on each side\n    u_n = np.zeros(N + 2)\n    u_n[1:-1] = np.where(x_centers  0, u_L, u_R)\n\n    t = 0.0\n    \n    flux_func = get_flux_function(flux_type)\n\n    while t  T_final:\n        # Apply transmissive (zero-gradient) boundary conditions\n        u_n[0] = u_n[1]\n        u_n[-1] = u_n[-2]\n\n        # Calculate time step based on CFL condition\n        max_abs_u = np.max(np.abs(u_n))\n        if max_abs_u  1e-9:\n            max_abs_u = 1e-9 # Avoid division by zero\n            \n        dt = nu * dx / max_abs_u\n        if t + dt > T_final:\n            dt = T_final - t\n\n        # Calculate fluxes at interfaces\n        # F[j] is the flux at the interface between cell j and j+1 (in the padded array)\n        fluxes = np.zeros(N + 1)\n        for j in range(N + 1):\n            fluxes[j] = flux_func(u_n[j], u_n[j+1])\n        \n        # Update solution using first-order finite volume scheme\n        u_np1 = np.copy(u_n)\n        u_np1[1:-1] = u_n[1:-1] - (dt / dx) * (fluxes[1:] - fluxes[:-1])\n\n        u_n = u_np1\n        t += dt\n\n    return u_n[1:-1] # Return only the physical domain\n\ndef get_flux_function(flux_type):\n    \"\"\"Returns the chosen numerical flux function.\"\"\"\n    if flux_type == 'hll':\n        return hll_flux\n    elif flux_type == 'upwind':\n        return upwind_flux\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\ndef flux(u):\n    \"\"\"Physical flux for Burgers' equation.\"\"\"\n    return 0.5 * u**2\n\ndef upwind_flux(u_l, u_r):\n    \"\"\"Computes the basic upwind flux.\"\"\"\n    a = 0.5 * (u_l + u_r) # Roe average speed\n    if a >= 0:\n        return flux(u_l)\n    else:\n        return flux(u_r)\n\ndef hll_flux(u_l, u_r):\n    \"\"\"Computes the HLL flux.\"\"\"\n    if np.isclose(u_l, u_r):\n        return flux(u_l)\n        \n    f_l = flux(u_l)\n    f_r = flux(u_r)\n    \n    # Estimate signal speeds\n    s_l = min(u_l, u_r)\n    s_r = max(u_l, u_r)\n    \n    if s_l >= 0:\n        return f_l\n    elif s_r = 0:\n        return f_r\n    else: # s_l  0  s_r\n        return (s_r * f_l - s_l * f_r + s_l * s_r * (u_r - u_l)) / (s_r - s_l)\n\ndef exact_solution(x, t, u_l, u_r):\n    \"\"\"Computes the exact Riemann solution for the Burgers equation.\"\"\"\n    if np.isclose(t, 0):\n        return np.where(x  0, u_l, u_r)\n    \n    if u_l > u_r:  # Shock\n        s = 0.5 * (u_l + u_r)\n        return np.where(x / t  s, u_l, u_r)\n    else:  # Rarefaction\n        xi = x / t\n        solution = np.piecewise(xi, [xi = u_l, (xi > u_l)  (xi  u_r), xi >= u_r],\n                                [u_l, lambda val: val, u_r])\n        return solution\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}