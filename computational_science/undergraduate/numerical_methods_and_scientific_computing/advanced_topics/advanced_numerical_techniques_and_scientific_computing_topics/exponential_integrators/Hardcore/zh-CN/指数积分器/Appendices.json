{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式就是亲手实践。本节的第一个练习将指导你推导并比较两种基本的一阶指数积分器：Lawson 方法和指数欧拉方法。这项练习将通过一个简单的标量问题，让你清晰地聚焦于方法的构建以及它们处理非线性项的不同方式，从而为你打下坚实的基础。通过这个过程 ，你将深入理解常数变易公式中对常微分方程进行拆分和近似积分的核心思想。",
            "id": "3227424",
            "problem": "您需要推导、实现和测试两种用于形式为 $y' = A y + N(y)$ 的半线性常微分方程的一阶指数积分器。推导基于常数变易公式和线性算子指数的基本定义。在标量情况下进行，其中 $A$ 由实数标量参数 $-\\lambda$ 表示（$\\lambda > 0$），非线性项为 $N(y) = \\mu y - \\mu y^2$。初始值为 $y(0) = y_0$。\n\n1. 推导任务。从常数变易公式和线性算子指数的定义出发，推导：\n   - 一阶 Lawson 方法：通过随时间变化的变量替换来消除线性部分，然后在变换后的坐标系中应用显式欧拉法得到。\n   - 一阶指数欧拉法：通过对常数变易公式中的积分应用一阶求积法得到。\n\n   您的推导必须明确指出以步长 $h$、 $A$ 的矩阵指数（在标量情况下为数的指数）和非线性项 $N(\\cdot)$ 表示的离散时间更新公式。\n\n2. 精确参考解。对于标量问题 $y' = -\\lambda y + \\mu y - \\mu y^2$ 及初始条件 $y(0) = y_0$，求得一个封闭形式的精确解 $y(t)$，您将用它作为计算误差的参考。用 $\\lambda$、$\\mu$、$y_0$ 和 $t$ 表示 $y(t)$。确保您的表达式涵盖了一般情况 $\\mu - \\lambda \\neq 0$ 和极限情况 $\\mu - \\lambda = 0$。\n\n3. 实现任务。实现一个程序，该程序：\n   - 使用推导出的两种格式，在步长为 $h = T/m$（$m$ 为指定的正整数）的均匀网格上对标量问题进行积分，直至最终时间 $T$，并返回 $t=T$ 时的数值解。\n   - 通过与第2部分的精确解进行比较，计算 $t=T$ 时的绝对全局误差。\n   - 使用两次步长减半的连续网格加密来计算观测阶估计：如果 $e(h)$ 和 $e(h/2)$ 分别是步长为 $h$ 和 $h/2$ 时的误差，则将观测阶 $p$ 估计为 $p \\approx \\log\\left(e(h)/e(h/2)\\right) / \\log(2)$。\n\n4. 测试套件。使用以下三组参数集和步数：\n   - 情况 A（理想路径，中度刚性）：$(\\lambda, \\mu, y_0, T) = (50, 1, 0.1, 1)$，步数 $m \\in \\{50, 100, 200, 400\\}$。\n   - 情况 B（边界情况，净线性增长消失）：$(\\lambda, \\mu, y_0, T) = (1, 1, 0.5, 1)$，步数 $m \\in \\{50, 100, 200, 400\\}$。\n   - 情况 C（高度刚性，短时间范围）：$(\\lambda, \\mu, y_0, T) = (200, 2, 0.9, 0.5)$，步数 $m \\in \\{50, 100, 200, 400\\}$。\n\n   对于每种情况：\n   - 计算两种方法在 $m=200$ 和 $m=400$ 时于 $t=T$ 处的绝对全局误差，并用这些误差如上所述地估计每种方法的观测阶 $p$。\n   - 在最细步数 $m=400$ 时，计算 Lawson 方法误差与指数欧拉法误差之比。\n\n5. 输出规范。您的程序必须生成单行输出，其中包含一个由9个浮点数组成的扁平列表，顺序如下：\n   - 对于情况 A：使用 $(m=200, m=400)$ 计算的 Lawson 方法观测阶，使用 $(m=200, m=400)$ 计算的指数欧拉法观测阶，以及在 $m=400$ 时的 Lawson 误差与指数欧拉误差之比。\n   - 对于情况 B：使用 $(m=200, m=400)$ 计算的 Lawson 方法观测阶，使用 $(m=200, m=400)$ 计算的指数欧拉法观测阶，以及在 $m=400$ 时的 Lawson 误差与指数欧拉误差之比。\n   - 对于情况 C：使用 $(m=200, m=400)$ 计算的 Lawson 方法观测阶，使用 $(m=200, m=400)$ 计算的指数欧拉法观测阶，以及在 $m=400$ 时的 Lawson 误差与指数欧拉误差之比。\n\n   因此，最终输出行必须采用 $[p_{L,A}, p_{E,A}, r_A, p_{L,B}, p_{E,B}, r_B, p_{L,C}, p_{E,C}, r_C]$ 的形式，其中每个条目都是一个浮点数。不涉及物理单位，也未使用角度。\n\n程序必须是完整且可直接运行的，不得需要任何用户输入或外部文件。它必须实现您推导的算法，并且只能使用执行环境中指定的库。程序打印的最后一行必须严格符合上述列表的描述，即条目由逗号分隔，并用方括号括起来，不得有任何附加文本。",
            "solution": "问题陈述经审阅后被认定为有效。它在科学上基于常微分方程数值方法的理论，是适定的、客观的，并为推导、实现和测试提供了一套完整且一致的要求。\n\n该问题围绕标量半线性常微分方程 (ODE)展开：\n$$\ny'(t) = -\\lambda y(t) + (\\mu y(t) - \\mu y(t)^2)\n$$\n初始条件为 $y(0) = y_0$，其中 $\\lambda > 0$、$\\mu$ 和 $y_0$ 是实数参数。该方程的形式为 $y' = Ay + N(y)$，其中线性算子 $A = -\\lambda$，非线性部分 $N(y) = \\mu y - \\mu y^2$。\n\n### 1. 数值格式的推导\n\n指数积分器的基础是常数变易公式，它给出了 $y' = Ay + N(y)$ 在长度为 $h = t_{n+1} - t_n$ 的时间区间 $[t_n, t_{n+1}]$ 上的精确解：\n$$\ny(t_{n+1}) = e^{Ah} y(t_n) + \\int_{0}^{h} e^{A(h-s)} N(y(t_n+s)) ds\n$$\n其中 $y_n$ 是 $y(t_n)$ 的近似值。对积分项的不同近似会导出不同的指数积分格式。\n\n#### 1.1 一阶 Lawson 方法\nLawson 方法引入变量替换以消除刚性线性部分。令 $v(t) = e^{-At} y(t)$，这意味着 $y(t) = e^{At} v(t)$。对 $v(t)$ 关于时间求导可得：\n$$\nv'(t) = -A e^{-At} y(t) + e^{-At} y'(t)\n$$\n代入 $y'(t) = Ay(t) + N(y(t))$：\n$$\nv'(t) = -A e^{-At} y(t) + e^{-At} (Ay(t) + N(y(t))) = e^{-At} N(y(t))\n$$\n代入 $y(t) = e^{At} v(t)$：\n$$\nv'(t) = e^{-At} N(e^{At} v(t))\n$$\n一阶 Lawson 方法将显式（前向）欧拉法应用于这个变换后关于 $v(t)$ 的方程：\n$$\nv_{n+1} = v_n + h v'(t_n) = v_n + h e^{-At_n} N(e^{At_n}v_n)\n$$\n注意到 $y_n = e^{At_n} v_n$，我们有 $N(e^{At_n}v_n) = N(y_n)$。代入 $v_n = e^{-At_n} y_n$ 和 $v_{n+1} = e^{-At_{n+1}} y_{n+1}$：\n$$\ne^{-At_{n+1}} y_{n+1} = e^{-At_n} y_n + h e^{-At_n} N(y_n)\n$$\n两边同乘以 $e^{At_n}$ 得：\n$$\ne^{A(t_n - t_{n+1})} y_{n+1} = y_n + h N(y_n)\n$$\n因为 $t_n - t_{n+1} = -h$，我们得到 $e^{-Ah} y_{n+1} = y_n + h N(y_n)$。一阶 Lawson 方法的最终更新公式是：\n$$\ny_{n+1} = e^{Ah} (y_n + h N(y_n))\n$$\n对于给定的标量问题，$A = -\\lambda$ 且 $N(y_n) = \\mu y_n - \\mu y_n^2$。更新公式变为：\n$$\ny_{n+1} = e^{-\\lambda h} (y_n + h (\\mu y_n - \\mu y_n^2))\n$$\n\n#### 1.2 一阶指数欧拉法\n该方法通过对常数变易公式中的积分应用简单的一阶求积法来推导。我们通过假设非线性项 $N(y(t_n+s))$ 在区间 $[0, h]$ 上为常数，且等于其初始值 $N(y_n)$，来近似被积函数。\n$$\ny_{n+1} \\approx e^{Ah} y_n + \\int_{0}^{h} e^{A(h-s)} N(y_n) ds\n$$\n由于 $N(y_n)$ 相对于积分变量 $s$ 是常数，我们可以将其从积分中提出：\n$$\ny_{n+1} = e^{Ah} y_n + \\left( \\int_{0}^{h} e^{A(h-s)} ds \\right) N(y_n)\n$$\n该积分可以精确计算。令 $u=h-s$，则 $du = -ds$。积分上下限由 $s$ 的 $(0, h)$ 变为 $u$ 的 $(h, 0)$。\n$$\n\\int_{0}^{h} e^{A(h-s)} ds = \\int_{h}^{0} e^{Au} (-du) = \\int_{0}^{h} e^{Au} du = A^{-1}(e^{Ah} - I)\n$$\n这要求 $A$ 是可逆的，因为 $A = -\\lambda$ 且 $\\lambda > 0$，所以该条件成立。这个积分通常使用 $\\phi_1$ 函数表示，$\\phi_1(z) = (e^z-1)/z$。\n指数欧拉法（也称为 ETD1）的更新公式为：\n$$\ny_{n+1} = e^{Ah} y_n + A^{-1}(e^{Ah} - I) N(y_n)\n$$\n对于标量问题，$e^{Ah} = e^{-\\lambda h}$ 且 $A^{-1}(e^{Ah}-I) = (-\\lambda)^{-1}(e^{-\\lambda h}-1) = \\frac{1-e^{-\\lambda h}}{\\lambda}$。更新公式为：\n$$\ny_{n+1} = e^{-\\lambda h} y_n + \\frac{1-e^{-\\lambda h}}{\\lambda} (\\mu y_n - \\mu y_n^2)\n$$\n\n### 2. 精确参考解\n给定的 ODE 是 $y' = (\\mu - \\lambda)y - \\mu y^2$。这是一个伯努利微分方程，形式为 $y' + P(t)y = Q(t)y^n$，其中 $P(t) = \\lambda - \\mu$，$Q(t) = -\\mu$，$n=2$。我们通过代换 $u(t) = y(t)^{1-n} = y(t)^{-1}$ 来求解它。这得到 $u' = -y^{-2}y'$。\n原方程可以写成 $y' + (\\lambda-\\mu)y = -\\mu y^2$。两边同除以 $y^2$ 得：\n$$\ny^{-2}y' + (\\lambda-\\mu)y^{-1} = -\\mu\n$$\n代入 $u$ 和 $u'$：\n$$\n-u' + (\\lambda-\\mu)u = -\\mu \\implies u' - (\\lambda-\\mu)u = \\mu\n$$\n这是一个关于 $u(t)$ 的一阶线性 ODE。\n\n情况 1：$\\lambda \\neq \\mu$。\n积分因子是 $I(t) = \\exp\\left(-\\int (\\lambda-\\mu) dt\\right) = e^{-(\\lambda-\\mu)t}$。\n将关于 $u$ 的 ODE 乘以 $I(t)$ 得到 $(u e^{-(\\lambda-\\mu)t})' = \\mu e^{-(\\lambda-\\mu)t}$。从 $0$ 到 $t$ 积分：\n$$\nu(t)e^{-(\\lambda-\\mu)t} - u(0) = \\int_0^t \\mu e^{-(\\lambda-\\mu)\\tau} d\\tau = \\mu \\left[ \\frac{e^{-(\\lambda-\\mu)\\tau}}{-(\\lambda-\\mu)} \\right]_0^t = \\frac{\\mu}{-(\\lambda-\\mu)} (e^{-(\\lambda-\\mu)t} - 1)\n$$\n利用 $u(0) = y_0^{-1}$，解出 $u(t)$ 得：\n$$\nu(t) = u(0)e^{(\\lambda-\\mu)t} + \\frac{\\mu}{\\lambda-\\mu}(e^{(\\lambda-\\mu)t} - 1) = \\left(\\frac{1}{y_0} + \\frac{\\mu}{\\lambda-\\mu}\\right)e^{(\\lambda-\\mu)t} - \\frac{\\mu}{\\lambda-\\mu}\n$$\n因为 $y(t) = u(t)^{-1}$，精确解为：\n$$\ny(t) = \\left( \\left(\\frac{1}{y_0} + \\frac{\\mu}{\\lambda-\\mu}\\right)e^{(\\lambda-\\mu)t} - \\frac{\\mu}{\\lambda-\\mu} \\right)^{-1}\n$$\n\n情况 2：$\\lambda = \\mu$。\n关于 $u$ 的 ODE 简化为 $u' = \\mu$。\n从 $0$ 到 $t$ 积分得到 $u(t) - u(0) = \\mu t$。\n利用 $u(0) = y_0^{-1}$，我们有 $u(t) = y_0^{-1} + \\mu t$。\n这种情况下的精确解为：\n$$\ny(t) = \\frac{1}{y_0^{-1} + \\mu t} = \\frac{y_0}{1 + \\mu t y_0}\n$$\n\n### 3. 实现与分析\n实现将包括每种数值方法和精确解的函数。主程序将遍历所提供的测试用例。对于每种情况，它将运行步数为 $m=200$ 和 $m=400$ 的模拟来计算最终时间误差。观测收敛阶 $p$ 是使用两次连续加密的误差 $e(h)$ 和 $e(h/2)$ 来估计的，公式如下：\n$$\np \\approx \\frac{\\log(e(h) / e(h/2))}{\\log(2)}\n$$\n这里，$h$ 对应于 $m=200$，$h/2$ 对应于 $m=400$。将在最精细的分辨率（$m=400$）下计算 Lawson 方法和指数欧拉法之间的误差比。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests two first-order exponential integrators.\n    \"\"\"\n\n    def exact_solution(lam, mu, y0, t):\n        \"\"\"Computes the exact solution y(t).\"\"\"\n        if lam == mu:\n            if 1.0 + mu * t * y0 == 0:\n                return np.inf  # or handle as a singularity\n            return y0 / (1.0 + mu * t * y0)\n        else:\n            c = lam - mu\n            term1 = (1.0 / y0 + mu / c) * np.exp(c * t)\n            term2 = mu / c\n            denominator = term1 - term2\n            if denominator == 0:\n                return np.inf\n            return 1.0 / denominator\n\n    def integrate_lawson(lam, mu, y0, T, m):\n        \"\"\"Integrates the ODE using the first-order Lawson method.\"\"\"\n        h = T / m\n        y = y0\n        exp_term = np.exp(-lam * h)\n        \n        for _ in range(m):\n            N_y = mu * y - mu * y**2\n            y = exp_term * (y + h * N_y)\n        return y\n\n    def integrate_exp_euler(lam, mu, y0, T, m):\n        \"\"\"Integrates the ODE using the first-order exponential Euler method.\"\"\"\n        h = T / m\n        y = y0\n        exp_term = np.exp(-lam * h)\n        \n        # The phi_1 function term: (e^(Ah) - I) / A\n        # h * phi_1(Ah) = h * (e^(Ah)-1)/(Ah) = (e^(-lam*h)-1)/(-lam) = (1-e^(-lam*h))/lam\n        # Use np.expm1 for numerical stability for small lam*h\n        if lam == 0: # Should not happen based on problem spec (lam > 0)\n            phi1_term = h\n        else:\n            phi1_term = -np.expm1(-lam * h) / lam\n\n        for _ in range(m):\n            N_y = mu * y - mu * y**2\n            y = exp_term * y + phi1_term * N_y\n        return y\n\n    def calculate_metrics(params, m1, m2):\n        \"\"\"Calculates errors, order, and ratio for a given parameter set.\"\"\"\n        lam, mu, y0, T = params\n        \n        y_exact_T = exact_solution(lam, mu, y0, T)\n\n        # Lawson method calculations\n        y_L1 = integrate_lawson(lam, mu, y0, T, m1)\n        y_L2 = integrate_lawson(lam, mu, y0, T, m2)\n        error_L1 = np.abs(y_L1 - y_exact_T)\n        error_L2 = np.abs(y_L2 - y_exact_T)\n        \n        # Exponential Euler method calculations\n        y_E1 = integrate_exp_euler(lam, mu, y0, T, m1)\n        y_E2 = integrate_exp_euler(lam, mu, y0, T, m2)\n        error_E1 = np.abs(y_E1 - y_exact_T)\n        error_E2 = np.abs(y_E2 - y_exact_T)\n\n        # Observed order calculation\n        # p = log(e(h)/e(h/2)) / log(2)\n        p_L = np.log(error_L1 / error_L2) / np.log(2) if error_L2 > 0 else 0.0\n        p_E = np.log(error_E1 / error_E2) / np.log(2) if error_E2 > 0 else 0.0\n        \n        # Error ratio at finest grid (m2)\n        ratio = error_L2 / error_E2 if error_E2 > 0 else np.inf\n        \n        return p_L, p_E, ratio\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case A: (lambda, mu, y0, T) = (50, 1, 0.1, 1)\n        (50.0, 1.0, 0.1, 1.0),\n        # Case B: (lambda, mu, y0, T) = (1, 1, 0.5, 1)\n        (1.0, 1.0, 0.5, 1.0),\n        # Case C: (lambda, mu, y0, T) = (200, 2, 0.9, 0.5)\n        (200.0, 2.0, 0.9, 0.5),\n    ]\n    \n    m_coarse = 200\n    m_fine = 400\n\n    results = []\n    for case in test_cases:\n        p_L, p_E, r = calculate_metrics(case, m_coarse, m_fine)\n        results.extend([p_L, p_E, r])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的问题往往涉及比简单标量更复杂的线性算子。第二个练习将带你处理一个线性部分为“亏损”矩阵的系统，这种矩阵无法被对角化。这是一个极好的测试，可以检验指数积分器框架的鲁棒性，并要求你理解如何为这些更具挑战性的情况计算矩阵函数（如矩阵指数）。这项练习  将巩固你对底层矩阵函数理论的理解。",
            "id": "3227484",
            "problem": "考虑自治常微分方程（ODE）系统 $u'(t) = L u(t) + G(u(t))$，其中 $u(t) \\in \\mathbb{R}^2$，线性算子 $L$ 是一个 $2 \\times 2$ 的亏损若尔当块，\n$$\nL = \\begin{pmatrix} \\lambda  s \\\\ 0  \\lambda \\end{pmatrix},\n$$\n其中 $\\lambda \\in \\mathbb{R}$ 且 $s \\in \\mathbb{R}$。非线性项 $G(u)$ 按分量定义为\n$$\nG(u) = \\begin{pmatrix} 0 \\\\ \\beta \\, u_1^2 \\end{pmatrix},\n$$\n其中 $u_1$ 表示 $u$ 的第一个分量，$\\beta \\in \\mathbb{R}$ 是一个给定参数。初始条件为 $u(0) = u_0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，终止时间为 $T > 0$。\n\n您的任务是基于常数变易公式，为该系统实现一个一阶指数时间差分（ETD）格式（称为 ETD 欧拉法）。从基本恒等式\n$$\nu(t+h) = e^{h L} u(t) + \\int_0^h e^{(h - \\tau) L} G(u(t + \\tau)) \\, d\\tau,\n$$\n出发，通过在每个时间步长上将 $G(u)$ 视为常数，即对于 $\\tau \\in [0,h]$，$G(u(t + \\tau)) \\approx G(u(t))$，来构造 ETD 欧拉近似。使用第一个 $\\varphi$-函数的积分定义，\n$$\n\\varphi_1(A) = \\int_0^1 e^{(1 - \\theta) A} \\, d\\theta,\n$$\n对于矩阵 $A$，将 ETD 欧拉更新表示为矩阵指数 $e^{hL}$ 和 $\\varphi_1(hL)$ 的形式。您必须推导并实现适用于上述亏损矩阵 $L$ 的表达式，并确保当 $\\lambda = 0$ 时该方法仍是良定义的。\n\n为了评估性能，使用经典的四阶 Runge-Kutta 方法（RK4）和均匀步长 $h_{\\text{ref}}$，对完整的 ODE $u'(t) = L u(t) + G(u(t))$ 进行求解，以近似参考解 $u_{\\text{ref}}(T)$。RK4 参考解应具有足够高的分辨率，以作为误差测量的基准。\n\n对于给定的参数集，将最终时刻的全局误差定义为\n$$\nE = \\| u_{\\text{ETD}}(T) - u_{\\text{ref}}(T) \\|_2,\n$$\n其中 $\\| \\cdot \\|_2$ 表示 $\\mathbb{R}^2$ 中的欧几里得范数。\n\n实现一个程序，为以下每个测试用例计算 $E$（这些值构成了测试套件）：\n\n- 情况 1：$\\lambda = -2$, $s = 1$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$。\n- 情况 2：$\\lambda = -8$, $s = 1$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$。\n- 情况 3：$\\lambda = 0$, $s = 1$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$。\n- 情况 4：$\\lambda = -2$, $s = 0$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$ (非亏损边界)。\n- 情况 5：$\\lambda = -2$, $s = 1$, $h = 0.20$, $T = 1.0$, $\\beta = 0.5$ (较大步长压力测试)。\n\n在所有情况下，RK4 参考解的步长取 $h_{\\text{ref}} = 10^{-4}$，并确保 $T$ 是 $h$ 和 $h_{\\text{ref}}$ 的整数倍。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5]\"）。每个 $result_i$ 都必须是一个实数（浮点数），等于按上述顺序列出的相应情况的最终时刻误差 $E$。不涉及物理单位；报告原始数值。程序必须是完全自包含的，并且不需要用户输入。",
            "solution": "用户希望使用一阶指数时间差分（ETD）方法求解一个常微分方程（ODE）系统，并将其精度与高分辨率的经典四阶 Runge-Kutta（RK4）方法进行比较。\n\n### **问题陈述分析**\n\n该问题在数学和科学上是合理的。它提出了一个针对半线性 ODE 系统的良定义初值问题：\n$$\nu'(t) = L u(t) + G(u(t)), \\quad u(0) = u_0\n$$\n其中 $u(t) \\in \\mathbb{R}^2$，线性部分 $L$ 是一个 $2 \\times 2$ 的若尔当块，非线性部分 $G(u)$ 是其中一个分量的二次函数。任务是实现 ETD 欧拉格式，这需要为特定的亏损矩阵 $L$ 推导并计算矩阵函数（指数函数和第一个 $\\varphi$-函数）。该问题还明确要求对 $L$ 的特征值 $\\lambda$ 为零的情况进行稳健处理，这是研究 $\\varphi$-函数时的标准考虑因素。使用小步长的 RK4 方法生成参考解是数值误差分析中的一种标准技术。所有参数都已指定，误差度量也已明确定义。该问题是有效的、良态的，并且需要对数值分析原理进行不简单的应用。\n\n### **理论推导**\n\n**1. ETD 欧拉格式**\n\nETD 欧拉格式由精确的常数变易公式推导而来：\n$$\nu(t_{n+1}) = e^{hL} u(t_n) + \\int_0^h e^{(h - \\tau)L} G(u(t_n + \\tau)) \\, d\\tau\n$$\n通过在区间 $[t_n, t_{n+1}]$ 上将非线性项近似为常数，即 $G(u(t_n + \\tau)) \\approx G(u_n)$，可得：\n$$\nu_{n+1} = e^{hL} u_n + \\left( \\int_0^h e^{(h - \\tau)L} \\, d\\tau \\right) G(u_n)\n$$\n该积分可以用 $\\varphi_1$ 函数表示。通过变量替换 $\\theta = \\tau/h$，积分变为 $h \\int_0^1 e^{(1-\\theta)hL} d\\theta$。根据定义，该积分为 $h \\varphi_1(hL)$。\n因此，ETD 欧拉更新规则为：\n$$\nu_{n+1} = e^{hL} u_n + h \\varphi_1(hL) G(u_n)\n$$\n其中 $u_n$ 是 $u(t_n)$ 的数值近似，而 $h$ 是时间步长。\n\n**2. 若尔当块的矩阵函数**\n\n实现的核心在于计算矩阵 $A = hL = \\begin{pmatrix} h\\lambda  hs \\\\ 0  h\\lambda \\end{pmatrix}$ 的矩阵函数 $e^{A}$ 和 $\\varphi_1(A)$。对于一个函数 $f$ 和一个特征值为 $z$、非对角线元素为 $c$ 的 $2 \\times 2$ 若尔当块，该矩阵的函数由下式给出：\n$$\nf\\left(\\begin{pmatrix} z  c \\\\ 0  z \\end{pmatrix}\\right) = \\begin{pmatrix} f(z)  c f'(z) \\\\ 0  f(z) \\end{pmatrix}\n$$\n该公式依赖于函数 $f$ 在矩阵周围的泰勒展开。\n\n**a. 矩阵指数 $e^{hL}$**\n\n令 $A = hL$，$z = h\\lambda$，$c = hs$ 及 $f(z) = e^z$。则 $f'(z) = e^z$。\n$$\ne^{hL} = e^A = \\begin{pmatrix} e^{h\\lambda}  hs e^{h\\lambda} \\\\ 0  e^{h\\lambda} \\end{pmatrix}\n$$\n该公式对所有 $\\lambda \\in \\mathbb{R}$ 均有效。\n\n**b. 矩阵函数 $\\varphi_1(hL)$**\n\n令 $A = hL$，$z = h\\lambda$，$c = hs$ 及 $f(z) = \\varphi_1(z)$。我们需要 $\\varphi_1(z)$ 及其导数 $\\varphi_1'(z)$ 的表达式。\n\n当 $z \\neq 0$ 时：\n$$\n\\varphi_1(z) = \\frac{e^z - 1}{z}\n$$\n$$\n\\varphi_1'(z) = \\frac{d}{dz}\\left(\\frac{e^z - 1}{z}\\right) = \\frac{ze^z - (e^z - 1)}{z^2}\n$$\n因此，对于 $\\lambda \\neq 0$（也即 $z \\neq 0$）：\n$$\n\\varphi_1(hL) = \\begin{pmatrix} \\varphi_1(h\\lambda)  hs \\varphi_1'(h\\lambda) \\\\ 0  \\varphi_1(h\\lambda) \\end{pmatrix} = \\begin{pmatrix} \\frac{e^{h\\lambda}-1}{h\\lambda}  hs \\frac{h\\lambda e^{h\\lambda} - e^{h\\lambda} + 1}{(h\\lambda)^2} \\\\ 0  \\frac{e^{h\\lambda}-1}{h\\lambda} \\end{pmatrix}\n$$\n\n当 $z = 0$（即 $\\lambda = 0$）时：\n上述公式是不定式。我们必须使用 $z \\to 0$ 时的极限，这可以从泰勒级数 $\\varphi_1(z) = 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\dots$ 中找到。\n$$\n\\varphi_1(0) = \\lim_{z \\to 0} \\frac{e^z - 1}{z} = 1\n$$\n$$\n\\varphi_1'(0) = \\lim_{z \\to 0} \\frac{ze^z - e^z + 1}{z^2} = \\lim_{z \\to 0} \\frac{e^z + ze^z - e^z}{2z} = \\lim_{z \\to 0} \\frac{e^z}{2} = \\frac{1}{2}\n$$\n所以，对于 $\\lambda = 0$（也即 $z=0$）：\n$$\n\\varphi_1(hL) = \\begin{pmatrix} \\varphi_1(0)  hs \\varphi_1'(0) \\\\ 0  \\varphi_1(0) \\end{pmatrix} = \\begin{pmatrix} 1  hs/2 \\\\ 0  1 \\end{pmatrix}\n$$\n对 $\\lambda = 0$ 的这种特殊处理对于确保正确性至关重要。\n\n### **数值实现计划**\n\n1.  **RK4 参考解**：为完整的 ODE 系统 $u' = f(u) = Lu + G(u)$ 实现一个标准的 RK4 求解器。该求解器将使用一个精细的步长 $h_{\\text{ref}} = 10^{-4}$ 来生成一个高精度的参考解 $u_{\\text{ref}}(T)$。\n\n2.  **ETD 欧拉解**：实现 ETD 欧拉格式。对于每个测试用例，在时间步进循环开始前，一次性计算常数矩阵 $E = e^{hL}$ 和 $P = h\\varphi_1(hL)$。然后，循环迭代地应用更新规则 $u_{n+1} = E u_n + P G(u_n)$。\n\n3.  **误差计算**：对于每个测试用例，计算两种方法得到的最终时刻解之差的欧几里得范数：$E = \\| u_{\\text{ETD}}(T) - u_{\\text{ref}}(T) \\|_2$。\n\n4.  **主循环**：一个主函数遍历所提供的五个测试用例，调用求解器，为每个用例计算误差，并存储结果。\n\n5.  **输出**：将最终的误差列表格式化为指定的字符串 `\"[result1,result2,...]\"`。\n\n该方法将推导出的数学公式系统地转化为计算算法，确保正确处理问题中指定的所有情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the global error of the ETD Euler method for a given ODE system\n    by comparing it to a high-resolution RK4 reference solution.\n    \"\"\"\n\n    # Define test cases: (lambda, s, h, T, beta)\n    test_cases = [\n        (-2.0, 1.0, 0.05, 1.0, 0.5), # Case 1\n        (-8.0, 1.0, 0.05, 1.0, 0.5), # Case 2\n        (0.0, 1.0, 0.05, 1.0, 0.5),  # Case 3\n        (-2.0, 0.0, 0.05, 1.0, 0.5), # Case 4\n        (-2.0, 1.0, 0.20, 1.0, 0.5)  # Case 5\n    ]\n\n    # Reference step size for RK4\n    h_ref = 1e-4\n\n    # Initial condition\n    u0 = np.array([1.0, 0.0])\n\n    # --- Helper function for the ODE's right-hand side f(u) = Lu + G(u) ---\n    def f_ode(u, lam, s, beta):\n        u1, u2 = u\n        du1_dt = lam * u1 + s * u2\n        du2_dt = lam * u2 + beta * u1**2\n        return np.array([du1_dt, du2_dt])\n\n    # --- Solver for the reference solution using RK4 ---\n    def compute_reference_solution(lam, s, T, beta):\n        \"\"\"Computes the solution at time T using the RK4 method.\"\"\"\n        u = u0.copy()\n        num_steps = int(T / h_ref)\n        for _ in range(num_steps):\n            k1 = f_ode(u, lam, s, beta)\n            k2 = f_ode(u + h_ref / 2.0 * k1, lam, s, beta)\n            k3 = f_ode(u + h_ref / 2.0 * k2, lam, s, beta)\n            k4 = f_ode(u + h_ref * k3, lam, s, beta)\n            u += (h_ref / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        return u\n\n    # --- Solver for the ETD Euler solution ---\n    def compute_etd_solution(lam, s, h, T, beta):\n        \"\"\"Computes the solution at time T using the ETD Euler method.\"\"\"\n        u = u0.copy()\n        num_steps = int(T / h)\n\n        # Pre-compute the matrices for the ETD step, E = exp(hL) and P = h*phi_1(hL)\n        z = h * lam\n        exp_z = np.exp(z)\n        \n        # Matrix E = exp(hL)\n        E = exp_z * np.array([[1.0, h * s], [0.0, 1.0]])\n\n        # Matrix P = h * phi_1(hL)\n        # Handle the case lambda = 0 separately to avoid division by zero.\n        if lam == 0.0:\n            # For z=0, phi_1(z)=1 and phi_1'(z)=1/2.\n            # Thus, phi_1(hL) = I + 0.5*hL\n            phi1_mat = np.array([\n                [1.0, h * s / 2.0],\n                [0.0, 1.0]\n            ])\n        else:\n            # For z != 0, use standard formulas for phi_1(z) and its derivative.\n            phi1_val = (exp_z - 1.0) / z\n            phi1_prime_val = (z * exp_z - exp_z + 1.0) / z**2\n            phi1_mat = np.array([\n                [phi1_val, h * s * phi1_prime_val],\n                [0.0, phi1_val]\n            ])\n        \n        P = h * phi1_mat\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            u1, _ = u\n            G_u = np.array([0.0, beta * u1**2])\n            u = E @ u + P @ G_u\n            \n        return u\n\n    results = []\n    for params in test_cases:\n        lam, s, h, T, beta = params\n        \n        # Compute reference solution\n        u_ref = compute_reference_solution(lam, s, T, beta)\n        \n        # Compute ETD solution\n        u_etd = compute_etd_solution(lam, s, h, T, beta)\n        \n        # Calculate the L2 norm of the error\n        error = np.linalg.norm(u_etd - u_ref)\n        results.append(error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "掌握了固定步长方法后，构建一个兼具效率和鲁棒性的求解器是顺理成章的下一步。最后一个练习  将指导你构建一个更高阶的嵌入式指数龙格-库塔（ERK）方法对。这种方法的主要优势在于能够以极小的额外计算成本估算局部误差，从而实现自适应步长控制，这也是现代高质量求解器的核心工作方式。",
            "id": "3227510",
            "problem": "考虑半线性初值问题 $y'(t) = A y(t) + g(y(t), t)$，其中 $y(t_0) = y_0$，$A$ 是一个常数矩阵，$g$ 是一个充分光滑的非线性函数。其基本出发点是用于线性-非线性分裂的常数变易公式，该公式表明，对于任意步长 $h > 0$，\n$$\ny(t_0 + h) = e^{h A} y(t_0) + \\int_{0}^{h} e^{(h - \\tau) A} \\, g\\!\\big(y(t_0 + \\tau), t_0 + \\tau\\big) \\, d\\tau.\n$$\n定义 $\\varphi$-函数如下：\n$$\n\\varphi_0(z) = e^{z}, \\quad\n\\varphi_1(z) = \\frac{e^{z} - 1}{z}, \\quad\n\\varphi_2(z) = \\frac{e^{z} - z - 1}{z^2},\n$$\n约定当 $z = 0$ 时使用其极限值（相应的极限存在且等于其泰勒展开式的首项）。\n\n您的任务是：\n\n1. 从常数变易公式出发，推导一个阶数为 $1/2$ 的嵌入式指数龙格-库塔（ERK）方法对：一个一阶方法和一个共享函数求值的二阶方法。两种方法都必须仅使用作用于 $h A$ 的 $\\varphi_k$ 函数和非线性函数 $g$ 的求值来表示。请提供清晰的论证，说明高阶方法达到2阶精度，而嵌入方法达到1阶精度。\n\n2. 设计一个自适应步长控制器，该控制器使用二阶和一阶更新量之差作为误差估计器。您的控制器必须明确说明如何使用估计的局部截断误差，必须指定一个步长的接受和拒绝标准，并且必须提供一个更新步长 $h$ 的公式。使用基于范数的误差度量，其中包含绝对容差 $\\mathrm{atol}$ 和相对容差 $\\mathrm{rtol}$。步长更新公式中的指数必须根据局部误差阶数从第一性原理出发进行论证。使用一个安全因子。该控制器必须依赖于嵌入式ERK方法对所需的 $\\varphi_k$ 求值，并且必须避免额外的、不必要的函数求值。三角函数中出现的角度必须以弧度处理。\n\n3. 实现一个完整、可运行的程序，使用您推导的嵌入式ERK方法对和自适应控制器对以下测试套件进行积分。在所有情况下，$A$ 都是对角矩阵，因此矩阵函数 $e^{h A}$、$\\varphi_1(h A)$ 和 $\\varphi_2(h A)$ 作用于向量上是逐元素的。为了数值稳定性，当 $hA$ 的对角线元素 $z$ 很小时，请使用泰勒级数的前几项来计算 $\\varphi_1(z)$ 和 $\\varphi_2(z)$。\n\n   测试用例（角度以弧度为单位）：\n   - 用例1（理想情况，刚性线性部分）：$A = [-10]$（一个 $1 \\times 1$ 的对角矩阵），$g(y,t) = \\sin(t)$，$t_0 = 0$，$t_{\\text{end}} = 1$，$y_0 = [1]$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n   - 用例2（边界情况，零线性部分和非线性增长）：$A = [0]$，$g(y,t) = y^2$，$t_0 = 0$，$t_{\\text{end}} = 0.5$，$y_0 = [0.1]$，$\\mathrm{rtol} = 10^{-7}$，$\\mathrm{atol} = 10^{-12}$。\n   - 用例3（边缘情况，混合刚性/非刚性分量）：$A = \\mathrm{diag}([-5, 0])$，$g(y,t) = [0, \\cos(t)]$，$t_0 = 0$，$t_{\\text{end}} = 2$，$y_0 = [2, 0]$，$\\mathrm{rtol} = 10^{-7}$，$\\mathrm{atol} = 10^{-12}$。\n\n   为了验证，请将数值解 $y(t_{\\text{end}})$ 与 $t_{\\text{end}}$ 处的精确解进行比较：\n   - 用例1：求解 $y'(t) = -10 y(t) + \\sin(t)$，初值为 $y(0) = 1$。精确解为\n     $$\n     y(t) = e^{-10 t}\\left(y_0 + \\frac{1}{101}\\right) + \\frac{10 \\sin(t) - \\cos(t)}{101}.\n     $$\n   - 用例2：求解 $y'(t) = y(t)^2$，初值为 $y(0) = 0.1$。精确解为\n     $$\n     y(t) = \\frac{y_0}{1 - y_0 t}.\n     $$\n   - 用例3：求解 $y_1'(t) = -5 y_1(t)$（初值为 $y_1(0) = 2$）和 $y_2'(t) = \\cos(t)$（初值为 $y_2(0) = 0$）。精确解为\n     $$\n     y_1(t) = 2 e^{-5 t}, \\quad y_2(t) = \\sin(t).\n     $$\n\n   您的程序必须计算每种情况下在 $t_{\\text{end}}$ 处的无穷范数绝对误差。最终输出格式必须是单行，结果表示为用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3]$，其中 $e_i$ 是一个浮点数。\n\n确保整个过程的科学真实性和自洽性。不要在问题陈述中使用或引用快捷公式；请从常数变易公式和核心定义出发。最终的程序必须是自包含的，不需要用户输入或外部文件，并对三角函数使用弧度。",
            "solution": "该问题要求推导、分析并实现一种嵌入式指数龙格-库塔（ERK）方法，用于求解形式为 $y'(t) = A y(t) + g(y(t), t)$ 且初始条件为 $y(t_0) = y_0$ 的半线性初值问题。推导过程必须从常数变易公式开始。\n\n常数变易公式给出了从 $t_n$ 到 $t_{n+1} = t_n + h$ 的一个时间步长 $h > 0$ 内的精确解：\n$$\ny(t_{n+1}) = e^{h A} y(t_n) + \\int_{0}^{h} e^{(h - \\tau) A} \\, g(y(t_n + \\tau), t_n + \\tau) \\, d\\tau.\n$$\n通过使用换元法 $s = \\tau/h$，该积分可以改写为：\n$$\ny(t_{n+1}) = e^{h A} y_n + h \\int_{0}^{1} e^{(1-s)h A} \\, g(y(t_n + sh), t_n + sh) \\, ds,\n$$\n其中 $y_n$ 是对 $y(t_n)$ 的数值近似。指数积分器是通过近似积分项来构建的。方法的精度取决于对被积函数 $g(y(t_n + sh), t_n + sh)$ 的近似精度。定义为\n$$\n\\varphi_k(z) = \\int_0^1 e^{(1-s)z} \\frac{s^{k-1}}{(k-1)!} ds,\n$$\n的 $\\varphi$-函数从这个公式中自然产生。对于 $k=0, 1, 2$，它们的常用形式是：\n$$\n\\varphi_0(z) = e^z, \\quad \\varphi_1(z) = \\frac{e^z - 1}{z}, \\quad \\varphi_2(z) = \\frac{e^z - z - 1}{z^2}.\n$$\n它们在 $z \\to 0$ 时的极限值由其泰勒级数展开给出：$\\varphi_1(0) = 1$ 和 $\\varphi_2(0) = 1/2$。\n\n### 第1部分：嵌入式 1(2) 阶 ERK 方法对的推导\n\n一个嵌入式方法对由两个不同阶数但共享函数求值的方法组成，从而可以进行高效的误差估计。我们将推导一个一阶方法和一个二阶方法。\n\n**一阶方法 ($y_1^{(1)}$)**\n\n对被积函数最简单的近似是假设其在区间 $[t_n, t_{n+1}]$ 上是常数：\n$$\ng(y(t_n + sh), t_n + sh) \\approx g(y_n, t_n) \\equiv g_n.\n$$\n将此代入积分形式可得：\n$$\ny_1^{(1)} = \\varphi_0(hA) y_n + h \\int_{0}^{1} e^{(1-s)hA} g_n \\, ds.\n$$\n该积分是 $g_n$（相对于 $s$ 是常数）乘以 $\\int_0^1 e^{(1-s)hA} ds$。根据定义，这个积分是 $\\varphi_1(hA)$。因此，一阶 ERK 方法，也称为指数欧拉（Exponential Euler）或 ETD1 方法，是：\n$$\ny_1^{(1)} = \\varphi_0(hA) y_n + h \\varphi_1(hA) g_n.\n$$\n为验证其阶数，我们将 $y_1^{(1)}$ 的泰勒展开与精确解 $y(t_n+h)$ 进行比较。令 $z = hA$。\n$$\n\\varphi_0(z) = I + z + \\frac{z^2}{2} + O(z^3) \\implies \\varphi_0(hA) = I + hA + \\frac{h^2 A^2}{2} + O(h^3).\n$$\n$$\n\\varphi_1(z) = I + \\frac{z}{2} + \\frac{z^2}{6} + O(z^3) \\implies h \\varphi_1(hA) = hI + \\frac{h^2 A}{2} + \\frac{h^3 A^2}{6} + O(h^4).\n$$\n将这些代入 $y_1^{(1)}$ 的公式中：\n$$\ny_1^{(1)} = \\left(I + hA + \\frac{h^2A^2}{2}\\right)y_n + \\left(hI + \\frac{h^2A}{2}\\right)g_n + O(h^3)\n$$\n$$\ny_1^{(1)} = y_n + h(Ay_n + g_n) + \\frac{h^2}{2}(A(Ay_n+g_n)) + O(h^3) = y_n + h y'(t_n) + \\frac{h^2}{2} A y'(t_n) + O(h^3).\n$$\n精确解展开为：\n$$\ny(t_n+h) = y_n + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + O(h^3).\n$$\n其中 $y''(t) = \\frac{d}{dt}(Ay+g) = A y' + \\frac{dg}{dt}$。在 $t_n$ 处，$y''(t_n) = A y'(t_n) + \\frac{dg}{dt}|_n$。\n局部截断误差为：\n$$\nLTE_1 = y(t_n+h) - y_1^{(1)} = \\frac{h^2}{2} (y''(t_n) - A y'(t_n)) + O(h^3) = \\frac{h^2}{2}\\frac{dg}{dt}\\Big|_n + O(h^3).\n$$\n局部误差为 $O(h^2)$，因此该方法是1阶的。\n\n**二阶方法 ($y_1^{(2)}$)**\n\n为了达到二阶精度，我们需要对被积函数 $g$ 进行更好的近似。我们可以借鉴霍恩（Heun）方法的思想，使用一种预测-校正方法。我们使用一阶解 $y_1^{(1)}$ 作为 $t_{n+1}$ 时刻状态的预测值：\n$$\ng_1 = g(y_1^{(1)}, t_n+h).\n$$\n然后我们用 $g_n = g(y_n, t_n)$ 和我们的近似值 $g_1$ 之间的线性插值来近似被积函数 $g(y(t_n + sh), t_n + sh)$：\n$$\ng(y(t_n + sh), t_n + sh) \\approx (1-s)g_n + s g_1.\n$$\n将此代入积分形式，得到二阶更新量 $y_1^{(2)}$：\n$$\ny_1^{(2)} = \\varphi_0(hA) y_n + h \\int_{0}^{1} e^{(1-s)hA} ((1-s)g_n + s g_1) \\, ds\n$$\n$$\ny_1^{(2)} = \\varphi_0(hA) y_n + h g_n \\int_{0}^{1} (1-s)e^{(1-s)hA} ds + h g_1 \\int_{0}^{1} s e^{(1-s)hA} ds.\n$$\n使用 $\\varphi$-函数的积分定义，我们识别出第二个积分为 $\\varphi_2(hA)$。对于第一个积分，我们使用恒等式 $\\int_0^1 (1-s) e^{(1-s)z} ds = \\varphi_1(z) - \\varphi_2(z)$。因此，该方法变为：\n$$\ny_1^{(2)} = \\varphi_0(hA) y_n + h (\\varphi_1(hA) - \\varphi_2(hA)) g_n + h \\varphi_2(hA) g_1.\n$$\n我们可以通过重用一阶结果来重写此式。\n$$\ny_1^{(1)} = \\varphi_0(hA) y_n + h \\varphi_1(hA) g_n.\n$$\n所以，\n$$\ny_1^{(2)} = (\\varphi_0(hA) y_n + h \\varphi_1(hA) g_n) - h \\varphi_2(hA) g_n + h \\varphi_2(hA) g_1\n$$\n$$\ny_1^{(2)} = y_1^{(1)} + h \\varphi_2(hA) (g_1 - g_n).\n$$\n这是一个突显“校正”项的优雅形式。该方法是一个二阶ERK方法，通常称为ETD2-RK。$g$ 的线性近似误差为 $O(h^2)$，积分后得到的局部截断误差为 $O(h^3)$。因此，该方法是2阶的。\n\n因此，嵌入式方法对的步骤如下：\n1. 计算 $g_n = g(y_n, t_n)$。\n2. 计算一阶解：$y_1^{(1)} = \\varphi_0(hA) y_n + h \\varphi_1(hA) g_n$。\n3. 计算 $g_1 = g(y_1^{(1)}, t_n+h)$。\n4. 计算二阶解：$y_1^{(2)} = y_1^{(1)} + h \\varphi_2(hA) (g_1 - g_n)$。\n\n### 第2部分：自适应步长控制器\n\n自适应步长控制器通过调整步长 $h$ 将局部误差保持在指定容差范围内，从而同时确保效率和精度。\n\n**误差估计器：** 高阶解与低阶解之差为低阶方法的局部截断误差提供了一个估计。\n$$\nE = y_1^{(2)} - y_1^{(1)} = h \\varphi_2(hA) (g(y_1^{(1)}, t_n+h) - g(y_n, t_n)).\n$$\n一阶方法的局部截断误差为 $LTE_1 = y(t_n+h) - y_1^{(1)} = O(h^2)$。二阶方法的局部截断误差为 $LTE_2 = y(t_n+h) - y_1^{(2)} = O(h^3)$。误差估计为 $E = LTE_1 - LTE_2 = O(h^2)$。因此，$E$ 是一阶方法误差的一个渐近正确的估计器。\n\n**误差度量与容差：** 我们使用混合的绝对-相对容差标准。标量误差度量 $err$ 是向量 $E$ 的无穷范数：\n$$\nerr = \\|E\\|_\\infty = \\|y_1^{(2)} - y_1^{(1)}\\|_\\infty.\n$$\n可接受容差 $Tol$ 定义为：\n$$\nTol = \\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(\\|y_n\\|_\\infty, \\|y_1^{(2)}\\|_\\infty),\n$$\n其中 $\\mathrm{atol}$ 是绝对容差，$\\mathrm{rtol}$ 是相对容差。\n\n**接受与拒绝标准：**\n*   如果 $err \\le Tol$，则接受该步。我们推进解：$y_{n+1} = y_1^{(2)}$ 且 $t_{n+1} = t_n + h$。\n*   如果 $err > Tol$，则拒绝该步。我们保留当前时刻 $t_n$ 的解 $y_n$，并用一个更小的步长 $h$ 重试该步。\n\n**步长更新公式：** 目标是选择一个新的步长 $h_{new}$，使得新步长的估计误差 $err_{new}$ 大约等于期望的容差 $Tol$。嵌入式方法的局部误差阶数为 $p+1$，其中 $p=1$ 是低阶方法的阶数。因此，对于某个常数 $C$，$err \\approx C h^{p+1} = C h^2$。\n对于当前步：$err \\approx C h^2$。\n对于新步：$Tol \\approx C h_{new}^2$。\n将两个方程相除得到 $\\frac{h_{new}^2}{h^2} \\approx \\frac{Tol}{err}$，这导致：\n$$\nh_{new} = h \\left( \\frac{Tol}{err} \\right)^{1/(p+1)} = h \\left( \\frac{Tol}{err} \\right)^{1/2}.\n$$\n指数 $1/2$ 是合理的，因为误差估计器的阶数为 $p+1=2$。为了防止过于激进的步长变化并确保可靠性，引入了一个安全因子 $S < 1$（例如，$S=0.9$）。此外，步长变化通常受最小和最大因子（例如，$0.2$ 和 $5.0$）的限制。最终的更新公式是：\n$$\nh_{new} = S \\cdot h \\cdot \\left( \\frac{Tol}{err} \\right)^{1/2}.\n$$\n\n### 第3部分：实现细节\n\n实现遵循所推导的方法和控制器。按照规定，对于对角矩阵 $A=\\mathrm{diag}(\\lambda_i)$，矩阵函数 $\\varphi_k(hA)$ 也是对角矩阵，$\\varphi_k(hA) = \\mathrm{diag}(\\varphi_k(h\\lambda_i))$。像 $\\varphi_k(hA)v$ 这样的运算变成了逐元素的向量乘积。\n\n为了数值稳定性，当 $|z|$ 很小（例如，$|z| < 10^{-8}$）时，使用泰勒级数展开来计算 $\\varphi_k(z)$ 函数，以避免相消误差和除以一个很小的数。\n$$\n\\varphi_1(z) = 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\dots\n$$\n$$\n\\varphi_2(z) = \\frac{1}{2} + \\frac{z}{6} + \\frac{z^2}{24} + \\frac{z^3}{120} + \\dots\n$$\n控制器对测试用例进行积分，直到 $t_{\\text{end}}$，然后将最终的数值解与提供的精确解进行比较，以计算无穷范数下的绝对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef phi(z, k):\n    \"\"\"\n    Computes the phi_k functions for a vector of arguments z.\n    Handles small z using Taylor series expansion to avoid numerical issues.\n    \"\"\"\n    # Using a threshold for small |z|\n    small_z_threshold = 1e-8\n    \n    # Initialize results array\n    res = np.zeros_like(z, dtype=float)\n    \n    # Identify small and large z values\n    is_small = np.abs(z)  small_z_threshold\n    is_large = ~is_small\n\n    z_large = z[is_large]\n\n    if k == 0:\n        res[is_large] = np.exp(z_large)\n        # Taylor for small z: 1 + z + z^2/2 + ...\n        res[is_small] = 1.0 + z[is_small] * (1.0 + z[is_small] / 2.0)\n    elif k == 1:\n        res[is_large] = (np.exp(z_large) - 1.0) / z_large\n        # Taylor for small z: 1 + z/2 + z^2/6 + z^3/24 + ...\n        z_s = z[is_small]\n        res[is_small] = 1.0 + z_s / 2.0 * (1.0 + z_s / 3.0 * (1.0 + z_s / 4.0))\n    elif k == 2:\n        res[is_large] = (np.exp(z_large) - z_large - 1.0) / (z_large**2)\n        # Taylor for small z: 1/2 + z/6 + z^2/24 + z^3/120 + ...\n        z_s = z[is_small]\n        res[is_small] = 0.5 + z_s / 6.0 * (1.0 + z_s / 4.0 * (1.0 + z_s / 5.0))\n    else:\n        raise ValueError(\"k must be 0, 1, or 2.\")\n        \n    return res\n\ndef solve_one_case(A_diag, g_func, t0, tend, y0, rtol, atol):\n    \"\"\"\n    Solves one instance of the semilinear IVP using the adaptive ERK 1(2) method.\n    \"\"\"\n    t = t0\n    y = np.array(y0, dtype=float)\n    \n    # Controller parameters\n    h = 0.01  # Initial step size\n    safety_factor = 0.9\n    min_factor = 0.2\n    max_factor = 5.0\n    \n    while t  tend:\n        # Ensure the last step does not overshoot tend\n        if t + h > tend:\n            h = tend - t\n\n        # Perform one step of the embedded ERK 1(2) method\n        z = h * A_diag\n        \n        phi0_hA = phi(z, 0)\n        phi1_hA = phi(z, 1)\n        phi2_hA = phi(z, 2)\n        \n        g_n = g_func(y, t)\n        \n        # Lower-order solution (order 1)\n        y_low = phi0_hA * y + h * phi1_hA * g_n\n\n        # Higher-order solution (order 2)\n        g_1 = g_func(y_low, t + h)\n        y_high = y_low + h * phi2_hA * (g_1 - g_n)\n        \n        # Error estimation\n        err_est_vec = y_high - y_low\n        err_norm = np.linalg.norm(err_est_vec, ord=np.inf)\n        \n        # Tolerance calculation\n        y_norm = np.linalg.norm(y, ord=np.inf)\n        y_high_norm = np.linalg.norm(y_high, ord=np.inf)\n        tol = atol + rtol * max(y_norm, y_high_norm)\n        \n        if err_norm = tol:\n            # Step is accepted\n            y = y_high\n            t += h\n            # Update step size for the next step (can increase)\n            if err_norm == 0.0:\n                 q = max_factor\n            else:\n                 q = safety_factor * (tol / err_norm)**0.5\n            h *= min(max_factor, max(min_factor, q))\n        else:\n            # Step is rejected\n            # Update step size (must decrease) and retry\n            q = safety_factor * (tol / err_norm)**0.5\n            h *= min(max_factor, max(min_factor, q))\n            # loop continues with new h, same t and y\n\n    return y\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"A_diag\": np.array([-10.0]),\n            \"g_func\": lambda y, t: np.array([math.sin(t)]),\n            \"t0\": 0.0, \"tend\": 1.0, \"y0\": np.array([1.0]),\n            \"rtol\": 1e-6, \"atol\": 1e-12,\n            \"exact_sol\": lambda t, y0: np.array([(y0[0] + 1.0/101.0) * math.exp(-10.0*t) + (10.0*math.sin(t) - math.cos(t))/101.0]),\n        },\n        {\n            \"A_diag\": np.array([0.0]),\n            \"g_func\": lambda y, t: y**2,\n            \"t0\": 0.0, \"tend\": 0.5, \"y0\": np.array([0.1]),\n            \"rtol\": 1e-7, \"atol\": 1e-12,\n            \"exact_sol\": lambda t, y0: np.array([y0[0] / (1.0 - y0[0]*t)]),\n        },\n        {\n            \"A_diag\": np.array([-5.0, 0.0]),\n            \"g_func\": lambda y, t: np.array([0.0, math.cos(t)]),\n            \"t0\": 0.0, \"tend\": 2.0, \"y0\": np.array([2.0, 0.0]),\n            \"rtol\": 1e-7, \"atol\": 1e-12,\n            \"exact_sol\": lambda t, y0: np.array([y0[0] * math.exp(-5.0*t), math.sin(t)]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        y_final = solve_one_case(\n            case[\"A_diag\"], case[\"g_func\"], case[\"t0\"], \n            case[\"tend\"], case[\"y0\"], case[\"rtol\"], case[\"atol\"]\n        )\n        \n        y_exact = case[\"exact_sol\"](case[\"tend\"], case[\"y0\"])\n        \n        error = np.linalg.norm(y_final - y_exact, ord=np.inf)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}