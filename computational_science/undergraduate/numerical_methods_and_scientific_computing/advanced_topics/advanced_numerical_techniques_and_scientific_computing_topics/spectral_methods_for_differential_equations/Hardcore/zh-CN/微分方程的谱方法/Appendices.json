{
    "hands_on_practices": [
        {
            "introduction": "在求解与时间相关的偏微分方程时，时间积分器的选择与空间离散化方法同等重要。本练习将以扩散方程这一典型的“刚性”问题为例，引导你探索傅里叶谱方法与不同时间积分方案的结合。通过比较显式的四阶龙格-库塔（RK4）方法和隐式的克兰克-尼科尔森（Crank–Nicolson）方法，你将亲身体会谱方法背景下的稳定性约束，并加深对精度与计算效率之间权衡的理解。",
            "id": "3277778",
            "problem": "您需要实现并比较两种时间积分格式，它们将与傅里叶谱方法空间离散相结合，用于求解一维扩散方程\n$$\nu_t(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in [0,2\\pi), \\ t \\ge 0,\n$$\n该方程具有周期性边界条件和光滑的周期性初始条件。这两种格式分别是经典的四阶龙格-库塔(RK4)方法和Crank-Nicolson方法，两者都应用于通过傅里叶谱方法得到的空间离散系统。目标是量化和比较在小粘性系数下的精度和实际稳定性表现。\n\n基本基础与设置：\n- 在周期性域上使用标准的傅里叶级数表示，其中微分对应于傅里叶空间中的乘法。具体来说，对于波数为 $k$ 的模式，二阶导数算子对应于乘以 $-k^2$。使用快速傅里叶变换(FFT)实现空间离散化。\n- 使用经典的RK4方法和Crank-Nicolson方法的定义作为应用于半离散系统的时间积分器。不要假设任何预先推导出的傅里叶空间中的闭式更新公式；从定义中推导出必要的内容。\n- 空间域为 $[0,2\\pi)$，具有周期性边界条件。角度以弧度为单位。\n- 初始条件为\n$$\nu(x,0) = \\sin(3x) + 0.5\\cos(5x) + 0.25\\sin(16x).\n$$\n\n实现要求：\n- 在 $[0,2\\pi)$ 上使用包含 $N$ 个点的均匀网格，$x_j = \\frac{2\\pi j}{N}$，其中 $j \\in \\{0,1,\\dots,N-1\\}$。\n- 使用傅里叶谱离散化方法计算 $u_{xx}$ 如下：如果 $\\widehat{u}$ 表示 $u$ 的离散傅里叶变换，那么 $u_{xx}$ 的傅里叶变换是 $-(k^2)\\widehat{u}$，其中 $k$ 是与根据 $[0,2\\pi)$ 上的FFT频率约定得到的每个傅里叶模式相关的整数值波数。\n- 为半离散系统实现两个时间步进器：\n  1. 经典的四阶龙格-库塔(RK4)方法，使用通过谱方法导数计算的半离散右端项 $f(u) = \\nu u_{xx}$。\n  2. Crank-Nicolson方法，应用于线性半离散系统，利用傅里叶谱方法带来的傅里叶空间中的对角化，在每个步骤中对每个傅里叶模式精确求解。\n- 对于每次运行，使用大小为 $\\Delta t = T/n$ 的 $n$ 个精确步长从时间 $t=0$ 推进到时间 $t=T$。对于下面给出的测试套件，$T/\\Delta t$ 是一个整数，因此 $\\Delta t$ 无需调整。\n- 通过在闭式形式下对初始谱逐个模式地在精确线性流下演化，以谱方法计算 $t=T$ 时的参考解。具体来说，如果 $\\widehat{u}_k(0)$ 表示模式 $k$ 处初始条件的傅里叶系数，则使用线性常微分方程的基本解得到 $\\widehat{u}_k(T)$，然后进行逆变换得到 $u(x,T)$。\n- 将每种方法的误差度量为最终时间的相对离散 $L^2$ 误差，\n$$\nE = \\frac{\\left\\| u_{\\text{num}}(\\cdot,T) - u_{\\text{exact}}(\\cdot,T) \\right\\|_2}{\\left\\| u_{\\text{exact}}(\\cdot,T) \\right\\|_2},\n$$\n其中离散 $L^2$ 范数是在网格点上计算的。使用一致的归一化，以便任何公共比例常数在比率中被抵消。\n- 如果RK4数值解表现出不稳定性（例如，在时间步进过程中的非有限值或明显非物理的无界增长），则报告一个大的有限误差，例如 $10^{99}$，而不是一个非有限值。\n\n测试套件：\n对于下面的每个参数集 $(N,\\nu,\\Delta t,T)$，计算两个数：RK4的相对误差和Crank-Nicolson的相对误差，按此顺序。\n\n- 测试 $1$：$N=64$，$\\nu=10^{-3}$，$\\Delta t=5\\times 10^{-3}$， $T=5\\times 10^{-2}$。\n- 测试 $2$：$N=64$，$\\nu=10^{-5}$，$\\Delta t=5\\times 10^{-2}$， $T=5\\times 10^{-1}$。\n- 测试 $3$：$N=256$，$\\nu=10^{-3}$，$\\Delta t=5\\times 10^{-3}$， $T=5\\times 10^{-2}$。\n- 测试 $4$：$N=512$，$\\nu=10^{-3}$，$\\Delta t=4\\times 10^{-2}$， $T=2\\times 10^{-1}$。\n- 测试 $5$：$N=512$，$\\nu=10^{-3}$，$\\Delta t=6\\times 10^{-2}$， $T=3\\times 10^{-1}$。\n\n最终输出规格：\n- 您的程序必须按顺序运行所有五个测试，并生成一行输出，其中包含一个由10个浮点数组成的逗号分隔的扁平列表，用方括号括起来，顺序如下：\n$$\n[\\ E_{\\text{RK4}}^{(1)},\\ E_{\\text{CN}}^{(1)},\\ E_{\\text{RK4}}^{(2)},\\ E_{\\text{CN}}^{(2)},\\ E_{\\text{RK4}}^{(3)},\\ E_{\\text{CN}}^{(3)},\\ E_{\\text{RK4}}^{(4)},\\ E_{\\text{CN}}^{(4)},\\ E_{\\text{RK4}}^{(5)},\\ E_{\\text{CN}}^{(5)}\\ ].\n$$\n- 全程角度必须以弧度处理。\n- 每个浮点数应以标准十进制或科学记数法打印。除了指定的列表格式外，不要打印任何额外的文本或字符。",
            "solution": "我们从周期性扩散方程开始\n$$\nu_t(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in [0,2\\pi), \\ t \\ge 0,\n$$\n其具有周期性边界条件和初始条件\n$$\nu(x,0) = \\sin(3x) + 0.5\\cos(5x) + 0.25\\sin(16x),\n$$\n其中所有角度均以弧度为单位。傅里叶谱方法将 $u(x,t)$ 表示为在 $N$ 个点 $x_j = 2\\pi j/N$, $j \\in \\{0,1,\\dots,N-1\\}$ 的均匀网格上的有限傅里叶级数。设 $\\widehat{u}_k(t)$ 表示波数为 $k$ 的离散傅里叶系数，其中整数 $k$ 由快速傅里叶变换(FFT)的约定确定。对于足够光滑的解，物理空间中的微分对应于傅里叶空间中乘以 $ik$ 的幂。特别地，\n$$\n\\mathcal{F}\\{u_{xx}\\}(k,t) = -(k^2)\\widehat{u}_k(t),\n$$\n因此傅里叶系数满足线性常微分方程(ODE)\n$$\n\\frac{d}{dt}\\widehat{u}_k(t) = -\\nu k^2 \\widehat{u}_k(t).\n$$\n这个方程按模式解耦。根据线性常微分方程的基本定理，每个模式的精确解由下式给出：\n$$\n\\widehat{u}_k(t) = e^{-\\nu k^2 t}\\,\\widehat{u}_k(0).\n$$\n因此，通过对 $u(x,0)$ 进行FFT计算 $\\widehat{u}_k(0)$，将每个系数乘以 $e^{-\\nu k^2 T}$，然后通过逆FFT变换回来，即可获得时间 $T$ 的精确解。\n\n为了对半离散系统进行时间步进，我们以谱方法计算 $u_{xx}$。给定一个网格函数 $u$，我们计算其离散傅里叶变换 $\\widehat{u}$，逐个模式地乘以 $-(k^2)$ 以获得 $u_{xx}$ 的傅里叶表示，然后变换回实数空间。这对足够光滑的 $u$ 以谱精度的方式实现了半离散右端项\n$$\nf(u) = \\nu\\,u_{xx}。\n$$\n\n时间积分器：\n\n1.  经典的四阶龙格-库塔(RK4)方法：给定 $u^n \\approx u(\\cdot,t_n)$ 和时间步长 $\\Delta t$，RK4计算\n    $$\n    \\begin{aligned}\n    k_1 = f(u^n),\\\\\n    k_2 = f\\!\\left(u^n + \\tfrac{\\Delta t}{2} k_1\\right),\\\\\n    k_3 = f\\!\\left(u^n + \\tfrac{\\Delta t}{2} k_2\\right),\\\\\n    k_4 = f\\!\\left(u^n + \\Delta t\\, k_3\\right),\\\\\n    u^{n+1} = u^n + \\tfrac{\\Delta t}{6}\\left(k_1 + 2k_2 + 2k_3 + k_4\\right).\n    \\end{aligned}\n    $$\n    对于线性模式 $y'=\\lambda y$，RK4的放大因子是\n    $$\n    G_{\\text{RK4}}(z) = 1 + z + \\tfrac{z^2}{2} + \\tfrac{z^3}{6} + \\tfrac{z^4}{24}, \\quad z=\\lambda \\Delta t.\n    $$\n    在我们的情况下，$\\lambda_k = -\\nu k^2$ 是实数且非正数，稳定性要求对所有相关 $k$ 都有 $|G_{\\text{RK4}}(z_k)| \\le 1$。沿着负实轴，这对 $\\Delta t$ 施加了一个与 $1/(\\nu k_{\\max}^2)$ 成正比的上限。如果 $\\Delta t$ 太大，数值解可能会因超出稳定区域而爆炸；在这种情况下，我们检测到非有限值或爆炸性增长，并报告一个大的有限误差替代值。\n\n2.  Crank-Nicolson方法：将梯形法则应用于线性常微分方程 $u_t = \\nu u_{xx}$ 得到\n    $$\n    \\left(I - \\tfrac{\\Delta t}{2}\\nu \\partial_{xx}\\right) u^{n+1} = \\left(I + \\tfrac{\\Delta t}{2}\\nu \\partial_{xx}\\right) u^n.\n    $$\n    在傅里叶空间中，由于 $\\partial_{xx}$ 以符号 $-k^2$ 对角化，每个模式的更新变为\n    $$\n    \\widehat{u}^{\\,n+1}_k = \\frac{1 - \\tfrac{\\Delta t}{2}\\nu k^2}{1 + \\tfrac{\\Delta t}{2}\\nu k^2}\\,\\widehat{u}^{\\,n}_k.\n    $$\n    对于扩散方程，这是无条件稳定的，因为对于 $\\nu > 0$ 和 $k \\ne 0$，因子的模严格小于或等于 $1$。该方法在时间上是二阶精确的。\n\n参考解与误差：\n精确的最终谱为 $\\widehat{u}_k(T) = e^{-\\nu k^2 T}\\widehat{u}_k(0)$。逆变换回来得到 $u_{\\text{exact}}(\\cdot,T)$。对于数值解 $u_{\\text{num}}(\\cdot,T)$，定义相对离散 $L^2$ 误差\n$$\nE = \\frac{\\left(\\sum_{j=0}^{N-1} \\left|u_{\\text{num}}(x_j,T) - u_{\\text{exact}}(x_j,T)\\right|^2\\right)^{1/2}}{\\left(\\sum_{j=0}^{N-1} \\left|u_{\\text{exact}}(x_j,T)\\right|^2\\right)^{1/2}}.\n$$\n由于分子和分母使用相同的网格和均匀权重，求积中的任何公共因子都在比率中抵消了。\n\n算法设计：\n- 在 $[0,2\\pi)$ 上建立均匀网格，包含 $N$ 个点，并使用FFT频率约定预先计算波数数组 $k$，缩放为角波数，使得 $\\partial_x$ 的傅里叶符号为 $ik$，$\\partial_{xx}$ 的傅里叶符号为 $-k^2$。\n- 实现一个函数，通过FFT将实网格函数 $u$ 映射到 $u_{xx}$，通过与 $-k^2$ 进行对角乘法，然后进行逆FFT并取实部。\n- 实现一个RK4步进，调用谱方法右端项 $f(u)=\\nu u_{xx}$。\n- 实现一个Crank-Nicolson步进，通过乘以以上导出的有理因子，在傅里叶空间中逐模式操作。\n- 对于每个测试案例 $(N,\\nu,\\Delta t,T)$，构造 $u(x,0)$，通过使用 $e^{-\\nu k^2 T}$ 演化初始谱来计算 $u_{\\text{exact}}(\\cdot,T)$，用RK4和Crank-Nicolson方法推进 $n=T/\\Delta t$ 步，并计算两个相对误差。如果RK4表现出不稳定性（非有限值或与扩散不一致的爆炸性增长），则将其误差设置为一个大的有限替代值，如 $10^{99}$。\n- 按规定的顺序和格式，将五个测试的10个误差输出为一个扁平列表。\n\n预期定性结果：\n- 对于 $\\Delta t$ 足够小的测试，两种方法都应是稳定的，RK4表现出四阶时间精度，Crank-Nicolson表现出二阶时间精度；因此，当稳定时，RK4在相同的 $\\Delta t$ 下应更精确。\n- 靠近RK4稳定性边界时，RK4误差通常会增加，如果 $\\Delta t$ 相对于 $\\nu$ 和最大可分辨波数太大，可能会发生不稳定性。由于其对线性扩散的无条件稳定性，Crank-Nicolson对所有步长都保持稳定，尽管其时间精度仍为二阶。\n\n这完成了与傅里叶谱方法和两种时间积分器特性一致的推导和算法计划。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_wavenumbers(N, L=2*np.pi):\n    # Angular wavenumbers on [0, L) so that d/dx -> i*k and d2/dx2 -> -(k^2)\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=L / N)\n    return k\n\ndef laplacian_spectral(u, k2):\n    # Compute u_xx via FFT: F(u_xx) = -(k^2) * F(u)\n    u_hat = np.fft.fft(u)\n    lap_hat = -(k2) * u_hat\n    lap = np.fft.ifft(lap_hat).real\n    return lap\n\ndef rk4_step(u, dt, nu, k2):\n    # One RK4 step for u_t = nu * u_xx, spatial operator via spectral method\n    k1 = nu * laplacian_spectral(u, k2)\n    k2v = nu * laplacian_spectral(u + 0.5 * dt * k1, k2)\n    k3v = nu * laplacian_spectral(u + 0.5 * dt * k2v, k2)\n    k4v = nu * laplacian_spectral(u + dt * k3v, k2)\n    return u + (dt / 6.0) * (k1 + 2.0 * k2v + 2.0 * k3v + k4v)\n\ndef cn_step(u, dt, nu, k2):\n    # One Crank–Nicolson step in Fourier space\n    u_hat = np.fft.fft(u)\n    # Per-mode factor: (1 - 0.5*dt*nu*k^2)/(1 + 0.5*dt*nu*k^2)\n    factor_num = 1.0 - 0.5 * dt * nu * k2\n    factor_den = 1.0 + 0.5 * dt * nu * k2\n    G = factor_num / factor_den\n    u_hat_new = G * u_hat\n    return np.fft.ifft(u_hat_new).real\n\ndef exact_solution(u0, T, nu, k2):\n    # Exact spectral evolution: u_hat(T) = exp(-nu*k^2*T) * u_hat(0)\n    u0_hat = np.fft.fft(u0)\n    decay = np.exp(-nu * k2 * T)\n    uT_hat = decay * u0_hat\n    uT = np.fft.ifft(uT_hat).real\n    return uT\n\ndef rel_l2_error(u_num, u_ref):\n    num = np.linalg.norm(u_num - u_ref)\n    den = np.linalg.norm(u_ref)\n    # Guard against den = 0 (should not happen for given IC and parameters)\n    if den == 0.0:\n        return float('inf') if num != 0.0 else 0.0\n    return num / den\n\ndef initial_condition(x):\n    # Angles in radians\n    return np.sin(3.0 * x) + 0.5 * np.cos(5.0 * x) + 0.25 * np.sin(16.0 * x)\n\ndef run_case(N, nu, dt, T):\n    L = 2.0 * np.pi\n    x = np.linspace(0.0, L, N, endpoint=False)\n    k = spectral_wavenumbers(N, L=L)\n    k2 = k * k\n\n    u0 = initial_condition(x)\n    u_exact = exact_solution(u0, T, nu, k2)\n\n    # Time stepping parameters (T/dt is integer by construction in test suite)\n    nsteps = int(round(T / dt))\n    dt_eff = T / nsteps  # exactly equals dt for provided test cases\n\n    # RK4 time stepping\n    u_rk4 = u0.copy()\n    rk4_unstable = False\n    for _ in range(nsteps):\n        u_rk4 = rk4_step(u_rk4, dt_eff, nu, k2)\n        # Detect instability: non-finite or explosive growth (non-physical for diffusion)\n        if not np.all(np.isfinite(u_rk4)) or np.max(np.abs(u_rk4)) > 1e12:\n            rk4_unstable = True\n            break\n    if rk4_unstable:\n        err_rk4 = 1e99\n    else:\n        err_rk4 = rel_l2_error(u_rk4, u_exact)\n\n    # Crank–Nicolson time stepping\n    u_cn = u0.copy()\n    for _ in range(nsteps):\n        u_cn = cn_step(u_cn, dt_eff, nu, k2)\n    err_cn = rel_l2_error(u_cn, u_exact)\n\n    return err_rk4, err_cn\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, nu, dt, T)\n    test_cases = [\n        (64, 1e-3, 5e-3, 5e-2),   # Test 1\n        (64, 1e-5, 5e-2, 5e-1),   # Test 2\n        (256, 1e-3, 5e-3, 5e-2),  # Test 3\n        (512, 1e-3, 4e-2, 2e-1),  # Test 4\n        (512, 1e-3, 6e-2, 3e-1),  # Test 5 (RK4 expected near/over stability limit)\n    ]\n\n    results = []\n    for N, nu, dt, T in test_cases:\n        err_rk4, err_cn = run_case(N, nu, dt, T)\n        results.append(err_rk4)\n        results.append(err_cn)\n\n    # Final print statement in the exact required format.\n    # Use scientific notation for reproducibility.\n    print(\"[\" + \",\".join(f\"{val:.12e}\" for val in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然傅里叶级数是处理周期性问题的完美工具，但许多现实世界的问题都涉及有界的非周期性区域。本练习将介绍切比雪夫谱配置法，这是解决非周期性问题的有力工具。你将学习如何构建切比雪夫微分矩阵，并用它来求解一个二阶边值问题，从而掌握处理狄利克雷（Dirichlet）边界条件和分析算子条件数的核心技能。",
            "id": "3277690",
            "problem": "考虑使用Chebyshev谱配置法，在区间$[-1,1]$上利用Chebyshev–Gauss–Lobatto点来近似导数。目标是基于这些点构建一个一阶Chebyshev微分矩阵，用它来组装一个满足齐次Dirichlet边界条件的离散二阶导数算子，然后针对一个模型问题，研究由此产生的线性系统的条件数与精度。\n\n从以下基本依据出发：\n- 第一类Chebyshev多项式满足$T_k(x) = \\cos(k \\arccos x)$，其中$k \\ge 0$为整数。\n- 区间$[-1,1]$上的Chebyshev–Gauss–Lobatto配置点定义为$x_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right)$，其中整数索引$j = 0,1,\\dots,N-1$，$N$是配置点的数量。\n- 在Lagrange基中的多项式插值表示一个近似函数$p(x) = \\sum_{j=0}^{N-1} u_j \\ell_j(x)$，其中$\\ell_j(x)$是在配置点上的Lagrange基多项式，而节点处的微分通过一个微分矩阵$D$实现，其元素来自于对插值函数求导并在节点处求值。\n- 二阶导数的谱配置法构建一个矩阵$D^{(2)} = D D$，该矩阵将节点值映射到插值函数的节点二阶导数值。\n- 一个非奇异矩阵$A$的$2$-范数条件数是$\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$。\n- 三角函数应以弧度为单位进行解释。\n\n任务：\n1. 对于给定的整数$N \\ge 3$，构建在$[-1,1]$上的Chebyshev–Gauss–Lobatto配置点$x_j$，其中$j = 0,1,\\dots,N-1$。\n2. 使用Lagrange插值的定义以及插值函数在节点处的导数可以通过微分矩阵表达的恒等式，推导并实现Chebyshev一阶微分矩阵$D \\in \\mathbb{R}^{N \\times N}$。该矩阵的非对角线元素是关于节点的有理函数，其对角线元素通过要求每行和为零来确保插值函数在节点处的精确微分。\n3. 形成离散二阶导数矩阵$D^{(2)} = D D$，并通过限制于内部索引$1,2,\\dots,N-2$来施加齐次Dirichlet边界条件$u(-1) = 0$和$u(1) = 0$，从而产生内部算子$A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$，该算子是通过删除$D^{(2)}$的第一行和最后一行以及第一列和最后一列得到的。\n4. 考虑在$[-1,1]$上的边值问题$u''(x) = f(x)$，其中$u(-1)=0$和$u(1)=0$，$f(x) = \\pi^2 \\sin(\\pi x)$，精确解为$u(x) = \\sin(\\pi x)$。通过在内部节点$x_j$（$j=1,2,\\dots,N-2$）处计算$f(x)$的值来组装内部右端向量，并求解线性系统$A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$以获得内部节点值$\\mathbf{u}_{\\mathrm{int}}$。通过将端点值设为零并将内部解置于相应索引处来恢复完整的节点向量。\n5. 计算$2$-范数条件数$\\kappa_2(A)$和最大绝对节点误差$\\max_{0 \\le j \\le N-1} |u(x_j) - u_j|$，其中$u(x) = \\sin(\\pi x)$是精确解，$u_j$是计算得到的节点值。所有三角函数求值必须使用弧度。\n6. 为以下$N$值的测试套件提供结果：$N \\in \\{3,8,20,64\\}$。这些值共同探究了一个具有最小内部点数的边界情况（$N=3$）、一个小问题（$N=8$）、一个中等问题（$N=20$）和一个较大问题（$N=64$），以检验条件数的增长和精度的趋势。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序汇总测试套件中每个$N$值的结果，首先是条件数$\\kappa_2(A)$（浮点数），然后是最大绝对节点误差（浮点数）。最终列表的长度应为$2 \\times 4 = 8$，遵循顺序$[\\kappa_2(A;N{=}3), \\mathrm{err}(N{=}3), \\kappa_2(A;N{=}8), \\mathrm{err}(N{=}8), \\kappa_2(A;N{=}20), \\mathrm{err}(N{=}20), \\kappa_2(A;N{=}64), \\mathrm{err}(N{=}64)]$。",
            "solution": "用户提供了一个数值分析领域中定义明确的计算问题，具体涉及应用Chebyshev谱配置法求解二阶边值问题。该问题具有科学依据、内容自洽且逻辑一致。在验证过程中未发现任何缺陷。\n\n该问题要求构建一个Chebyshev微分矩阵，并用其离散化一个微分算子，然后针对一个模型问题求解得到的线性系统，并对一组指定的问题规模分析其条件数和精度。\n\n解决方案通过执行问题陈述中概述的步骤来进行。\n\n**第1步：Chebyshev–Gauss–Lobatto配置点**\n\n对于给定的配置点数$N$，区间$[-1, 1]$上的Chebyshev–Gauss–Lobatto (CGL) 点被定义为$(N-1)$次Chebyshev多项式$T_{N-1}(x)$的极值点。这些点由以下公式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right) \\quad \\text{for } j = 0, 1, \\dots, N-1.\n$$\n这些点的索引方式使得$x_0 = 1$和$x_{N-1} = -1$。点集$\\{x_j\\}$关于原点对称。为了应用齐次Dirichlet边界条件，内部点为$\\{x_j\\}_{j=1}^{N-2}$。\n\n**第2步：一阶Chebyshev微分矩阵 ($D$)**\n\n在CGL网格$\\{x_j\\}$上近似的函数$u(x)$由一个唯一的、次数至多为$N-1$的多项式插值函数$p(x)$表示，该插值函数穿过节点值$\\{u_j\\}$，其中$u_j = u(x_j)$。该插值函数的导数在网格点处求值时，可以表示为矩阵向量乘积$\\mathbf{p}' = D\\mathbf{u}$，其中$\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$，$\\mathbf{p}' = [p'(x_0), p'(x_1), \\dots, p'(x_{N-1})]^T$。矩阵$D \\in \\mathbb{R}^{N \\times N}$即为Chebyshev一阶微分矩阵。\n\n$D$的元素，记作$D_{kj}$，由标准公式给出。非对角线元素（$k \\neq j$）为：\n$$\nD_{kj} = \\frac{c_k}{c_j} \\frac{(-1)^{k+j}}{x_k - x_j}, \\quad k, j = 0, \\dots, N-1,\n$$\n其中权重$c_k$定义为：\n$$\nc_k = \\begin{cases} 2  \\text{if } k=0 \\text{ or } k=N-1 \\\\ 1  \\text{otherwise} \\end{cases}\n$$\n问题指定对角线元素$D_{kk}$由微分矩阵必须将常数函数映射为其零导数的性质来确定。这意味着对于任意行$k$，其元素之和必须为零：$\\sum_{j=0}^{N-1} D_{kj} = 0$。因此，对角线元素可以计算为：\n$$\nD_{kk} = - \\sum_{j=0, j \\neq k}^{N-1} D_{kj}.\n$$\n此过程允许稳健地构建微分矩阵$D$。\n\n**第3步：用于Dirichlet边界条件的二阶算子 ($A$)**\n\n插值函数的二阶导数可以通过将一阶微分矩阵应用两次来获得。相应的二阶微分矩阵是$D^{(2)} = D \\cdot D$。微分方程$u''(x) = f(x)$在节点处的离散化变为线性系统$D^{(2)} \\mathbf{u} = \\mathbf{f}$。\n\n问题指定了齐次Dirichlet边界条件，$u(-1) = 0$和$u(1) = 0$。在我们的网格中，这对应于$u(x_{N-1})=0$和$u(x_0)=0$，即$u_{N-1}=0$和$u_0=0$。这些条件被施加于代数系统上。我们只需要求解内部节点处的未知值$\\{u_j\\}_{j=1}^{N-2}$。\n\n对于内部节点$i=1, \\dots, N-2$的方程是：\n$$\n\\sum_{j=0}^{N-1} (D^{(2)})_{ij} u_j = f_i\n$$\n代入已知的边界值$u_0 = 0$和$u_{N-1} = 0$，系统简化为：\n$$\n\\sum_{j=1}^{N-2} (D^{(2)})_{ij} u_j = f_i\n$$\n这可以写成一个更小的线性系统$A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$，其中：\n- $A$ 是通过选择索引为$1, \\dots, N-2$的行和列从$D^{(2)}$中获得的$(N-2) \\times (N-2)$子矩阵。\n- $\\mathbf{u}_{\\mathrm{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$ 是未知内部节点值的向量。\n- $\\mathbf{f}_{\\mathrm{int}} = [f_1, f_2, \\dots, f_{N-2}]^T$ 是强迫函数$f(x)$在内部节点处求值的向量。\n\n**第4步：求解模型边值问题**\n\n具体的边值问题是$u''(x) = \\pi^2 \\sin(\\pi x)$在$[-1, 1]$上，且$u(-1) = u(1) = 0$。给定的精确解是$u(x) = \\sin(\\pi x)$。\n强迫函数是$f(x) = \\pi^2 \\sin(\\pi x)$。向量$\\mathbf{f}_{\\mathrm{int}}$通过在内部CGL点处计算$f(x)$来构建：\n$$\nf_j = \\pi^2 \\sin(\\pi x_j) \\quad \\text{for } j = 1, \\dots, N-2.\n$$\n然后求解线性系统$A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$以找到内部节点处的数值解$\\mathbf{u}_{\\mathrm{int}}$。完整的解向量$\\mathbf{u}$通过将$\\mathbf{u}_{\\mathrm{int}}$与零边界值进行扩充来组装：$\\mathbf{u} = [0, u_1, \\dots, u_{N-2}, 0]^T$。\n\n**第5步：计算条件数和误差**\n\n计算两个量来分析该方法的性能：\n1.  **条件数：** 内部算子$A$的$2$-范数条件数，$\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$。这衡量了线性系统解对右端项扰动的敏感性。大的条件数表示可能存在数值不稳定性。\n2.  **最大节点误差：** 谱方法的精度通过将计算出的节点值$u_j$与精确解的值$u(x_j) = \\sin(\\pi x_j)$进行比较来评估。所有节点上的最大绝对误差计算如下：\n    $$\n    E_{\\max} = \\max_{0 \\le j \\le N-1} |u(x_j) - u_j|.\n    $$\n\n**第6步：执行测试套件**\n\n对测试套件$\\{3, 8, 20, 64\\}$中的每个$N$值执行步骤1-5中描述的过程。对于每个$N$，计算并存储结果对$(\\kappa_2(A), E_{\\max})$。最终输出是这些结果对按指定顺序的汇总。对于$N=3$，内部算子$A$是一个$1 \\times 1$矩阵（一个标量），因此其条件数为$1$。在唯一的内部点$x_1=0$处，右端项为$f(0)=0$，这导致数值解$u_1=0$，该解是精确的，所以误差为$0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Chebyshev spectral collocation problem for a set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [3, 8, 20, 64]\n    results = []\n\n    for N in test_cases:\n        # Step 1: Construct Chebyshev–Gauss–Lobatto collocation points\n        j = np.arange(N)\n        x = np.cos(np.pi * j / (N - 1))\n\n        # Step 2: Construct the Chebyshev first-order differentiation matrix D\n        D = np.zeros((N, N))\n        c = np.ones(N)\n        c[0] = 2.0\n        c[-1] = 2.0\n\n        for k in range(N):\n            for i in range(N):\n                if k != i:\n                    D[k, i] = (c[k] / c[i]) * ((-1)**(k + i)) / (x[k] - x[i])\n        \n        # Enforce zero row sums by setting diagonal elements\n        for k in range(N):\n            D[k, k] = -np.sum(D[k, :])\n\n        # Step 3: Form the discrete second derivative matrix and interior operator A\n        D2 = D @ D\n        A = D2[1:-1, 1:-1]\n\n        # Step 4: Assemble the RHS and solve the linear system for the BVP\n        # BVP: u''(x) = pi^2 * sin(pi*x) with u(-1)=0, u(1)=0\n        x_int = x[1:-1]\n        f_int = (np.pi**2) * np.sin(np.pi * x_int)\n        \n        # For N=3, the interior is one point (x=0), so f_int is a scalar 0.\n        # np.linalg.solve handles 1x1 systems correctly.\n        u_int = np.linalg.solve(A, f_int)\n        \n        # Recover the full nodal solution vector\n        u_computed = np.zeros(N)\n        u_computed[1:-1] = u_int\n\n        # Step 5: Compute the condition number of A and the maximum nodal error\n        # For N=3, A is a scalar, so cond(A) is 1.0.\n        if N == 3:\n            cond_A = 1.0\n        else:\n            cond_A = np.linalg.cond(A, 2)\n            \n        u_exact = np.sin(np.pi * x)\n        max_error = np.max(np.abs(u_exact - u_computed))\n\n        # Append results for the current N\n        results.append(cond_A)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了线性问题后，我们将转向更具挑战性的非线性偏微分方程。本练习将通过一个一维伯格斯方程（Burgers' equation）的模拟，来演示“伪谱法”的实现及其一个主要陷阱——混叠误差（aliasing error）。你将亲自实现并测试两种常见的稳定化技术：三分之二去混叠规则和超粘性方法，直观地了解它们如何抑制非物理的能量回流，保证模拟的准确性。",
            "id": "3277726",
            "problem": "考虑一个在一维周期性域上的无粘性伯格斯湍流替代模型，该模型带有可选的超粘性稳定器。其控制方程为\n$$\n\\partial_t u(x,t) + \\partial_x \\left(\\tfrac{1}{2} u(x,t)^2\\right) \\;=\\; - \\nu_p \\, (-\\Delta)^p u(x,t),\n$$\n该方程建立在区间 $[0,2\\pi]$ 上，具有周期性边界条件，其中 $x \\in [0,2\\pi]$（角度以弧度为单位），$t \\ge 0$，$\\nu_p \\ge 0$ 是一个超粘性系数，$p \\in \\mathbb{N}$ 控制超粘性的阶数。域的长度为 $2\\pi$。初始条件为\n$$\nu(x,0) \\;=\\; \\sin(x) + \\tfrac{1}{2}\\sin(2x).\n$$\n您的任务是基于以下基本原理和定义，设计并实现一个全谱伪谱求解器。\n\n1) 基本的谱表示与微分。用截断的复傅里叶级数在 $N$ 个等距网格点 $x_j = 2\\pi j/N$（其中 $j = 0,1,\\dots,N-1$）上表示 $u(x,t)$。用 $\\widehat{u}_k(t)$ 表示离散傅里叶变换，其由整数波数 $k \\in \\{-N/2+1,\\dots,-1,0,1,\\dots,N/2\\}$ 索引（当 $N$ 为偶数时，采用通常的环绕处理）。空间导数遵循谱法则\n$$\n\\widehat{\\partial_x u}_k(t) = i k \\, \\widehat{u}_k(t),\n$$\n因为在 $[0,2\\pi]$ 上有 $\\partial_x e^{i k x} = i k e^{i k x}$。\n\n2) 非线性项与混淆。非线性项是守恒形式 $-\\partial_x \\left(\\tfrac{1}{2} u^2\\right)$。在伪谱法中，通过逆变换计算 $u(x_j,t)$，逐点生成 $q(x_j,t) = \\tfrac{1}{2} u(x_j,t)^2$，将其变换为 $\\widehat{q}_k(t)$，然后将非线性谱项设置为\n$$\n\\widehat{\\mathcal{N}}_k(t) = - i k \\, \\widehat{q}_k(t).\n$$\n在有限分辨率 $N$ 下，这种逐点乘积会导致混淆误差，这会破坏能量传递并导致非物理的反向散射。一种经典的稳定化方法是 2/3 反混淆规则：定义一个谱掩码，在计算非线性项时，将所有 $|k| > N/3$ 的模态置零。具体来说，当启用反混淆时，在非线性项的计算中使用该掩码两次：首先，在变换到物理空间之前，将 $\\widehat{u}_k$ 的高阶模态置零；然后，在乘以 $i k$ 之前，将 $\\widehat{q}_k$ 的高阶模态置零。\n\n3) 超粘性稳定器。超粘性算子在谱空间上定义为\n$$\n-\\nu_p \\left(-\\Delta\\right)^p u \\;\\;\\Longleftrightarrow\\;\\; - \\nu_p \\, |k|^{2p}\\, \\widehat{u}_k \\quad \\text{for each mode } k,\n$$\n因为在一维空间 $[0,2\\pi]$ 上，$-\\Delta$ 的傅里叶符号为 $|k|^2$。该项提供了尺度选择性阻尼，可以抑制高波数的振荡。\n\n4) 时间离散化。使用四阶定步长显式龙格－库塔方法（经典龙格－库塔法），在区间 $[0,T]$ 上以恒定的时间步长 $\\Delta t$ 对半离散系统 $\\partial_t \\widehat{u}_k = \\widehat{\\mathcal{N}}_k - \\nu_p |k|^{2p} \\widehat{u}_k$ 进行推进。所有变换都应在同一网格上进行一致的计算。当启用反混淆时，在每个完整的时间步之后，还需将更新后的 $\\widehat{u}_k$ 投影到保留的 2/3 模态集合上，方法是将所有 $|k| > N/3$ 的模态置零。\n\n5) 能量诊断。将时间 $t$ 的总能量定义为空间平均值\n$$\nE(t) = \\tfrac{1}{2} \\,\\frac{1}{2\\pi}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx,\n$$\n在具有 $N$ 个点的离散伪谱法中，其计算公式为\n$$\nE(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N} \\sum_{j=0}^{N-1} u(x_j,t)^2.\n$$\n同时定义一个低波数带能量\n$$\nE_{\\mathrm{low}}(t) = \\tfrac{1}{2} \\sum_{1 \\le |k| \\le k_{\\ast}} \\mathcal{E}_k(t),\n$$\n其中 $\\mathcal{E}_k(t)$ 是与帕塞瓦尔定理一致的离散谱能量密度。为避免歧义，使用离散傅里叶系数 $\\widehat{u}_k(t)$ 计算 $E_{\\mathrm{low}}(t)$，公式为\n$$\nE_{\\mathrm{low}}(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N^2} \\sum_{1 \\le |k| \\le k_{\\ast}} \\left|\\widehat{u}_k(t)\\right|^2,\n$$\n根据离散帕塞瓦尔定理，这与 $E(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N^2}\\sum_k |\\widehat{u}_k(t)|^2$ 和 $E(t) = \\tfrac{1}{2}\\cdot \\frac{1}{N}\\sum_j u(x_j,t)^2$ 是一致的。使用 $k_{\\ast} = 4$。\n\n6) 研究目标。您将通过比较几种不同配置下的总能量漂移和低波数带能量漂移，来研究混淆驱动的反向散射以及超粘性的稳定效应。对于每种配置，计算以下两个量化诊断指标：\n- $\\Delta E = E(T) - E(0)$，\n- $\\Delta E_{\\mathrm{low}} = E_{\\mathrm{low}}(T) - E_{\\mathrm{low}}(0)$。\n\n7) 实现与测试套件。实现上述完整程序，并使用以下参数集运行它。所有角度均以弧度为单位。在所有情况下，均使用 $N=64$，$T=0.4$ 和 $\\Delta t = 5\\times 10^{-4}$，并采用相同的初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。\n- 情况 A（有混淆，无超粘性）：禁用反混淆；$\\nu_p = 0$。\n- 情况 B（反混淆，无超粘性）：启用 2/3 规则的反混淆；$\\nu_p = 0$。\n- 情况 C（有混淆，有超粘性）：禁用反混淆；启用超粘性，参数为 $p=4$ 和 $\\nu_p = 10^{-18}$。\n- 情况 D（反混淆，有超粘性）：启用 2/3 规则的反混淆；启用超粘性，参数为 $p=4$ 和 $\\nu_p = 10^{-18}$。\n\n8) 最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含以下八个浮点数\n$$\n[\\Delta E_{A}, \\Delta E_{\\mathrm{low},A}, \\Delta E_{B}, \\Delta E_{\\mathrm{low},B}, \\Delta E_{C}, \\Delta E_{\\mathrm{low},C}, \\Delta E_{D}, \\Delta E_{\\mathrm{low},D}].\n$$\n每个数字必须呈现为最多包含 10 位有效数字的十进制浮点值。不得打印任何其他文本。\n\n您的实现必须是一个完整的、可运行的程序，它在内部执行所有计算，无需外部输入，遵循上述原则，并严格遵守指定的输出格式。",
            "solution": "该问题要求在一个周期性域上，实现一个用于求解一维无粘性伯格斯方程（增加了超粘性项）的伪谱求解器。该求解方案将在四种不同配置下进行验证，以研究混淆和超粘性对能量守恒的影响。下文详细阐述了该求解器的理论和数值基础。\n\n控制方程为：\n$$\n\\partial_t u(x,t) + \\partial_x \\left(\\tfrac{1}{2} u(x,t)^2\\right) \\;=\\; - \\nu_p \\, (-\\Delta)^p u(x,t)\n$$\n该方程定义在域 $x \\in [0,2\\pi]$ 上，具有周期性边界条件和初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。\n\n### 第 1 步：问题验证\n根据指定标准对问题陈述进行了严格评估。\n\n-   **提取已知信息：** 已逐字提取所有参数、方程、初始条件、数值程序（离散化、时间积分、反混淆）和诊断定义。这包括控制偏微分方程、初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$、数值参数 $N=64$, $T=0.4$, $\\Delta t = 5\\times 10^{-4}$、超粘性参数 $p=4, \\nu_p \\in \\{0, 10^{-18}\\}$，以及由反混淆和超粘性状态定义的四种模拟情况（A, B, C, D）。伪谱法、龙格－库塔时间步进、2/3 反混淆规则和能量诊断的定义都已明确提供。\n-   **验证检查：**\n    1.  **科学基础：** 该问题基于伯格斯方程，这是流体动力学中的一个标准模型，并采用了成熟的数值技术（伪谱法、RK4、超粘性、反混淆）。它在科学上是合理的。\n    2.  **适定性：** 该问题构成一个适定的初边值问题。数值任务已通过所有必要的参数和定义明确规定，确保给定算法有一个唯一且可计算的解。\n    3.  **客观性：** 问题陈述是精确的、定量的，并且没有主观或含糊的语言。\n-   **结论：** 该问题是**有效的**。它在偏微分方程数值方法领域是一个结构良好、有科学依据且计算上可行的 tractable 问题。\n\n### 第 2 步：方法与实现\n求解方法在空间上采用伪谱法，在时间上采用四阶龙格－库塔方法。\n\n**空间离散化与傅里叶表示**\n空间域 $[0,2\\pi]$ 被离散化为 $N=64$ 个等距点，$x_j = 2\\pi j/N$，其中 $j=0, 1, \\dots, N-1$。函数 $u(x,t)$ 由其在该网格上的值 $u_j(t) = u(x_j, t)$ 表示。谱表示基于截断的傅里叶级数。离散傅里叶系数 $\\widehat{u}_k(t)$ 通过离散傅里叶变换 (DFT) 及其逆变换与网格点值 $u_j(t)$ 相关联：\n$$\n\\widehat{u}_k(t) = \\sum_{j=0}^{N-1} u_j(t) e^{-i k x_j}, \\quad u_j(t) = \\frac{1}{N} \\sum_{k} \\widehat{u}_k(t) e^{i k x_j}\n$$\n对 $k$ 的求和是针对整数波数集合进行的。对于偶数点数 $N$，这些波数通常取为 $k \\in \\{-N/2, -N/2+1, \\dots, N/2-1\\}$。在实现中，我们使用标准的 `numpy.fft` 约定，其中波数的排序为 $k=0, 1, \\dots, N/2-1, -N/2, \\dots, -1$，并通过 `k = numpy.fft.fftfreq(N) * N` 获得。\n\n在傅里叶空间中，空间导数 $\\partial_x$ 变为简单的乘以 $ik$：\n$$\n\\widehat{\\partial_x u}_k = ik \\widehat{u}_k\n$$\n\n**偏微分方程的半离散化**\n对控制方程应用傅里叶变换，得到关于系数 $\\widehat{u}_k(t)$ 的常微分方程组 (ODEs)：\n$$\n\\frac{d\\widehat{u}_k}{dt} = \\widehat{\\mathcal{N}}_k[\\widehat{u}] + \\widehat{\\mathcal{L}}_k[\\widehat{u}]\n$$\n其中 $\\widehat{\\mathcal{N}}_k$ 是非线性项的傅里叶变换，$\\widehat{\\mathcal{L}}_k$ 是超粘性项。\n\n**超粘性项（线性部分）**\n超粘性算子 $-\\nu_p(-\\Delta)^p$ 在傅里叶空间中有一个简单的表示。由于拉普拉斯算子 $\\Delta = \\partial_{xx}$ 对应于乘以 $(ik)^2 = -k^2$，算子 $-\\Delta$ 对应于乘以 $k^2 = |k|^2$。因此，超粘性项为：\n$$\n\\widehat{\\mathcal{L}}_k[\\widehat{u}] = -\\nu_p |k|^{2p} \\widehat{u}_k\n$$\n该项对 $\\widehat{u}_k$ 是线性的，并施加了对大波数（小尺度）具有高度选择性的阻尼。\n\n**非线性项（伪谱部分）**\n非线性项为 $\\mathcal{N}(u) = -\\partial_x (\\frac{1}{2} u^2)$。其傅里叶系数通过伪谱法计算：\n1.  使用快速傅里叶逆变换 (IFFT) 将 $\\widehat{u}_k(t)$ 变换到物理空间，得到 $u_j(t)$。\n2.  在每个网格点上计算量 $q_j(t) = \\frac{1}{2}u_j(t)^2$。\n3.  使用快速傅里叶变换 (FFT) 将 $q_j(t)$ 变换回傅里叶空间，得到 $\\widehat{q}_k(t)$。\n4.  应用谱导数以找到非线性贡献：$\\widehat{\\mathcal{N}}_k = -ik \\widehat{q}_k(t)$。\n\n**反混淆**\n逐点乘积 $u_j \\cdot u_j$ 会产生混淆误差，其中高波数分量会伪装成低波数分量。2/3 反混淆规则可以减轻这种情况。创建一个谱滤波器（掩码），将所有波数 $|k| > K_{\\text{max}}$ 的傅里叶模态置零，其中 $K_{\\text{max}} = \\lfloor N/3 \\rfloor$。对于 $N=64$，$K_{\\text{max}}=21$。当启用反混淆时，非线性项的计算程序被修改为：\n1.  在 IFFT 之前，对 $\\widehat{u}_k$ 应用反混淆掩码。\n2.  像之前一样计算 $u_j$ 和 $q_j$。\n3.  通过 FFT 计算出 $\\widehat{q}_k$ 后，在乘以 $-ik$ 之前再次应用反混淆掩码。\n此外，在每个完整的时间步之后，通过应用掩码将解 $\\widehat{u}_k$ 投影回未混淆的模态上。\n\n**时间积分**\n半离散系统 $\\frac{d\\widehat{u}}{dt} = F(\\widehat{u})$ 使用经典的四阶龙格－库塔 (RK4) 方法以固定的时间步长 $\\Delta t$ 进行时间推进：\n$$\n\\begin{align*}\n\\mathbf{k}_1 = F(\\widehat{u}_n) \\\\\n\\mathbf{k}_2 = F(\\widehat{u}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = F(\\widehat{u}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = F(\\widehat{u}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\widehat{u}_{n+1} = \\widehat{u}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n这里，$\\widehat{u}$ 是所有傅里叶系数的向量，$F(\\widehat{u})$ 是计算右端项（非线性项和超粘性项之和）的函数。\n\n**初始条件**\n初始条件为 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。利用恒等式 $\\sin(\\theta) = (e^{i\\theta} - e^{-i\\theta})/(2i)$，我们可以找到精确的连续傅里叶级数系数。DFT 系数 $\\widehat{u}_k(0)$ 与这些系数成正比，并且可以从正交关系推导得出：\n$$\n\\widehat{u}_k(0) = \\begin{cases} -iN/2  \\text{if } k=1 \\\\ iN/2  \\text{if } k=-1 \\\\ -iN/4  \\text{if } k=2 \\\\ iN/4  \\text{if } k=-2 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n这允许在傅里叶空间中进行精确、无采样误差的初始化。\n\n**能量诊断**\n计算总能量 $E(t)$ 和低波数带能量 $E_{\\mathrm{low}}(t)$。根据帕塞瓦尔定理，能量可以从傅里叶系数计算得出，这通常更精确且与谱方法一致。公式为：\n$$\nE(t) = \\frac{1}{2 N^2} \\sum_{k} |\\widehat{u}_k(t)|^2\n$$\n$$\nE_{\\mathrm{low}}(t) = \\frac{1}{2 N^2} \\sum_{1 \\le |k| \\le k_{\\ast}} |\\widehat{u}_k(t)|^2, \\quad \\text{with } k_{\\ast}=4\n$$\n每种情况下需要报告的诊断指标是 $\\Delta E = E(T) - E(0)$ 和 $\\Delta E_{\\mathrm{low}} = E_{\\mathrm{low}}(T) - E_{\\mathrm{low}}(0)$。对于无粘性、无外力的伯格斯方程，总能量应该是守恒的。数值解中的任何偏差都表示误差，例如由混淆引起的误差。低频带能量的变化追踪了能量在大尺度和小尺度之间的传递情况。\n\n总体算法的流程是：在傅里叶空间中设置初始状态，计算初始能量，然后迭代 RK4 时间步进循环，执行所需的步数。对于四种情况中的每一种，相应地配置反混淆和超粘性的参数。最后，计算最终能量，并计算和汇总所需的诊断指标以供输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation with optional hyperviscosity\n    using a pseudospectral method and investigates aliasing effects.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 64\n    T = 0.4\n    dt = 5e-4\n    k_star = 4\n\n    test_cases = [\n        {'name': 'A', 'dealias': False, 'nu_p': 0.0, 'p': 4},\n        {'name': 'B', 'dealias': True,  'nu_p': 0.0, 'p': 4},\n        {'name': 'C', 'dealias': False, 'nu_p': 1e-18, 'p': 4},\n        {'name': 'D', 'dealias': True,  'nu_p': 1e-18, 'p': 4},\n    ]\n\n    # --- Grid and Wavenumber Setup ---\n    # Wavenumbers corresponding to numpy's FFT output order\n    k = np.fft.fftfreq(N) * N\n\n    # --- De-aliasing Mask (2/3 rule) ---\n    k_cutoff = int(np.floor(N / 3.0))\n    dealias_mask = np.ones_like(k, dtype=bool)\n    dealias_mask[np.abs(k) > k_cutoff] = False\n    \n    # --- Energy Calculation Functions ---\n    def calc_E(u_hat):\n        \"\"\"Computes total energy from spectral coefficients.\"\"\"\n        return 0.5 / (N**2) * np.sum(np.abs(u_hat)**2)\n\n    def calc_E_low(u_hat):\n        \"\"\"Computes low-wavenumber band energy.\"\"\"\n        mask = (np.abs(k) >= 1)  (np.abs(k) = k_star)\n        return 0.5 / (N**2) * np.sum(np.abs(u_hat[mask])**2)\n\n    # --- RHS of the ODE in Fourier space: d(u_hat)/dt = F(u_hat) ---\n    def rhs(u_hat, hypervisc_op, dealias_flag):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete equation.\n        F(u_hat) = NonlinearTerm(u_hat) + LinearTerm(u_hat)\n        \"\"\"\n        # Linear (hyperviscosity) term\n        du_dt_linear = hypervisc_op * u_hat\n        \n        # Nonlinear (pseudospectral) term\n        u_hat_dealiased = u_hat.copy()\n        if dealias_flag:\n            u_hat_dealiased[~dealias_mask] = 0.0\n            \n        u_phys = np.fft.ifft(u_hat_dealiased)\n        \n        # Ensure physical space solution is real before squaring\n        # Small imaginary parts can arise from floating point errors\n        q_phys = 0.5 * np.real(u_phys)**2 \n        \n        q_hat = np.fft.fft(q_phys)\n        \n        if dealias_flag:\n            q_hat[~dealias_mask] = 0.0\n            \n        du_dt_nonlinear = -1j * k * q_hat\n        \n        return du_dt_nonlinear + du_dt_linear\n\n    # --- Main Simulation Loop ---\n    all_results = []\n    num_steps = int(round(T / dt))\n\n    for case in test_cases:\n        dealias_flag = case['dealias']\n        nu_p = case['nu_p']\n        p = case['p']\n\n        # --- Initial Condition in Fourier Space ---\n        u_hat0 = np.zeros(N, dtype=complex)\n        # Using numpy's array indexing for negative wavenumbers\n        u_hat0[1] = -1j * N / 2.0\n        u_hat0[N-1] = 1j * N / 2.0  # k = -1\n        u_hat0[2] = -1j * N / 4.0\n        u_hat0[N-2] = 1j * N / 4.0  # k = -2\n        \n        u_hat = u_hat0.copy()\n\n        # --- Calculate Initial Energies ---\n        E0 = calc_E(u_hat)\n        E_low0 = calc_E_low(u_hat)\n\n        # Pre-compute the hyperviscosity operator for efficiency\n        hypervisc_op = -nu_p * np.abs(k)**(2*p)\n\n        # --- Time-stepping with RK4 ---\n        for _ in range(num_steps):\n            k1 = rhs(u_hat, hypervisc_op, dealias_flag)\n            k2 = rhs(u_hat + dt / 2.0 * k1, hypervisc_op, dealias_flag)\n            k3 = rhs(u_hat + dt / 2.0 * k2, hypervisc_op, dealias_flag)\n            k4 = rhs(u_hat + dt * k3, hypervisc_op, dealias_flag)\n            u_hat += dt / 6.0 * (k1 + 2*k2 + 2*k3 + k4)\n\n            # Post-step projection for de-aliased runs\n            if dealias_flag:\n                u_hat[~dealias_mask] = 0.0\n        \n        # --- Calculate Final Energies and Diagnostics ---\n        ET = calc_E(u_hat)\n        E_lowT = calc_E_low(u_hat)\n\n        delta_E = ET - E0\n        delta_E_low = E_lowT - E_low0\n\n        all_results.extend([delta_E, delta_E_low])\n\n    # --- Final Output Formatting ---\n    # Format numbers to specifications (up to 10 significant digits)\n    formatted_results = [f\"{val:.10g}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}