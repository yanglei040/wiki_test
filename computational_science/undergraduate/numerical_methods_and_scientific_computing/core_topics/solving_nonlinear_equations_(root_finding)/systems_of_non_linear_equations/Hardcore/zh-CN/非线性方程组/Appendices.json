{
    "hands_on_practices": [
        {
            "introduction": "掌握非线性方程组的数值解法，第一步是亲手实践其核心算法。本练习将引导你完成牛顿法的一次完整迭代，这是一个基础但至关重要的训练。通过计算雅可比矩阵 (Jacobian matrix)、求解线性修正方程并更新近似解，你将对该方法的运作机制建立起直观而深刻的理解。",
            "id": "2207863",
            "problem": "考虑以下二元非线性方程组：\n$$\n\\begin{cases}\n2x^2 + y = 11 \\\\\nx + 2y^2 = 10\n\\end{cases}\n$$\n我们寻求使用多元牛顿法来求解该方程组的近似解。从初始猜测 $(x_0, y_0) = (3, 1)$ 开始，进行一次迭代以找到下一个近似值 $(x_1, y_1)$。\n\n求 $(x_1, y_1)$ 的坐标。将每个坐标表示为最简分数形式。",
            "solution": "定义向量函数 $\\mathbf{F}(x,y)$ 及其雅可比矩阵 $J(x,y)$ 如下：\n$$\n\\mathbf{F}(x,y)=\\begin{pmatrix} 2x^{2}+y-11 \\\\ x+2y^{2}-10 \\end{pmatrix}, \n\\quad\nJ(x,y)=\\begin{pmatrix} \\frac{\\partial}{\\partial x}(2x^{2}+y-11)  \\frac{\\partial}{\\partial y}(2x^{2}+y-11) \\\\ \\frac{\\partial}{\\partial x}(x+2y^{2}-10)  \\frac{\\partial}{\\partial y}(x+2y^{2}-10) \\end{pmatrix}\n=\\begin{pmatrix} 4x  1 \\\\ 1  4y \\end{pmatrix}.\n$$\n多元牛顿法通过求解以下方程来计算更新量 $\\mathbf{s}=(s_{x},s_{y})^{T}$：\n$$\nJ(x_{0},y_{0})\\,\\mathbf{s}=-\\mathbf{F}(x_{0},y_{0}),\n$$\n然后设置 $(x_{1},y_{1})=(x_{0},y_{0})+\\mathbf{s}$。\n\n在点 $(x_{0},y_{0})=(3,1)$ 处，计算：\n$$\n\\mathbf{F}(3,1)=\\begin{pmatrix} 2\\cdot 3^{2}+1-11 \\\\ 3+2\\cdot 1^{2}-10 \\end{pmatrix}\n=\\begin{pmatrix} 8 \\\\ -5 \\end{pmatrix},\n\\quad\nJ(3,1)=\\begin{pmatrix} 4\\cdot 3  1 \\\\ 1  4\\cdot 1 \\end{pmatrix}\n=\\begin{pmatrix} 12  1 \\\\ 1  4 \\end{pmatrix}.\n$$\n求解以下方程中的 $\\mathbf{s}$：\n$$\n\\begin{pmatrix} 12  1 \\\\ 1  4 \\end{pmatrix}\\begin{pmatrix} s_{x} \\\\ s_{y} \\end{pmatrix}\n=-\\begin{pmatrix} 8 \\\\ -5 \\end{pmatrix}\n=\\begin{pmatrix} -8 \\\\ 5 \\end{pmatrix},\n$$\n即线性方程组：\n$$\n\\begin{cases}\n12s_{x}+s_{y}=-8, \\\\\ns_{x}+4s_{y}=5.\n\\end{cases}\n$$\n由 $s_{x}=5-4s_{y}$ 并代入第一个方程，可得：\n$$\n12(5-4s_{y})+s_{y}=-8\n\\;\\Rightarrow\\;\n60-48s_{y}+s_{y}=-8\n\\;\\Rightarrow\\;\n-47s_{y}=-68\n\\;\\Rightarrow\\;\ns_{y}=\\frac{68}{47}.\n$$\n则\n$$\ns_{x}=5-4\\cdot \\frac{68}{47}\n=\\frac{235}{47}-\\frac{272}{47}\n=-\\frac{37}{47}.\n$$\n更新近似值：\n$$\nx_{1}=x_{0}+s_{x}=3-\\frac{37}{47}=\\frac{141}{47}-\\frac{37}{47}=\\frac{104}{47}, \n\\quad\ny_{1}=y_{0}+s_{y}=1+\\frac{68}{47}=\\frac{47}{47}+\\frac{68}{47}=\\frac{115}{47}.\n$$\n因此，下一个牛顿迭代点是 $\\left(\\frac{104}{47}, \\frac{115}{47}\\right)$，两个坐标都已是最简分数形式。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{104}{47}  \\frac{115}{47}\\end{pmatrix}}$$"
        },
        {
            "introduction": "仅仅掌握算法的计算步骤是不够的，理解其成功或失败背后的原理同样重要。本练习将挑战你从“如何计算”转向“为何如此”，通过分析一个具体案例，探讨为何某些初始猜测点对于牛顿法是“坏”的选择。这个过程将加深你对雅可比矩阵在算法稳定性和收敛性中所扮演的关键角色的认识。",
            "id": "2207871",
            "problem": "一位工程师的任务是为一个模拟稳态物理系统的非线性方程组寻找数值解。方程如下：\n$$f_1(x, y) = x^2 - y^2 - 4 = 0$$\n$$f_2(x, y) = xy - 3 = 0$$\n该工程师决定使用方程组的牛顿法。该方法的迭代公式为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - [J(\\mathbf{x}_k)]^{-1} \\mathbf{F}(\\mathbf{x}_k)$，其中 $\\mathbf{x} = (x, y)^T$，$\\mathbf{F} = (f_1, f_2)^T$，而 $J(\\mathbf{x})$ 是 $\\mathbf{F}$ 的雅可比矩阵。\n\n经过一些尝试，该工程师观察到，对于这个特定系统，选择位于 x 轴（$y_0 = 0$）或 y 轴（$x_0 = 0$）上的初始猜测值 $\\mathbf{x}_0 = (x_0, y_0)$ 是一个糟糕的策略。下列哪个陈述为这种糟糕的表现提供了最准确和根本的原因？\n\nA. 对于坐标轴上的任何初始猜测值，牛顿法的第一次迭代产生的点也位于坐标轴上，这使得算法永远无法向解移动，因为解不位于坐标轴上。\n\nB. 对于坐标轴上的任何初始猜测值，函数向量 $\\mathbf{F}(\\mathbf{x}_0)$ 是一个零向量，这会错误地向算法发出已找到解的信号。\n\nC. 对于 x 轴或 y 轴上的任何点，雅可比矩阵都是奇异的，导致该方法因无法计算矩阵的逆而立即失败。\n\nD. 点 $(0,0)$ 是雅可比矩阵奇异的唯一位置。坐标轴上靠近原点的初始猜测值会导致雅可比矩阵近乎奇异，使得后续迭代产生一个距离真解极远的点，表明其收敛行为不佳。\n\nE. 该方程组没有实数解，因此无论初始猜测值如何，牛顿法都将无法收敛。",
            "solution": "给定方程组\n$$\nf_{1}(x,y)=x^{2}-y^{2}-4,\\qquad f_{2}(x,y)=xy-3,\n$$\n其向量函数为 $\\mathbf{F}(x,y)=(f_{1}(x,y),f_{2}(x,y))^{T}$，雅可比矩阵为\n$$\nJ(x,y)=\\begin{pmatrix}\n\\frac{\\partial f_{1}}{\\partial x}  \\frac{\\partial f_{1}}{\\partial y}\\\\[4pt]\n\\frac{\\partial f_{2}}{\\partial x}  \\frac{\\partial f_{2}}{\\partial y}\n\\end{pmatrix}\n=\\begin{pmatrix}\n2x  -2y\\\\\ny  x\n\\end{pmatrix}.\n$$\n牛顿法更新公式为 $\\mathbf{x}_{k+1}=\\mathbf{x}_{k}-J(\\mathbf{x}_{k})^{-1}\\mathbf{F}(\\mathbf{x}_{k})$，这要求雅可比矩阵 $J$ 在迭代点处是可逆的。\n\n首先，计算雅可比矩阵的行列式：\n$$\n\\det J(x,y)=(2x)(x)-(-2y)(y)=2x^{2}+2y^{2}=2(x^{2}+y^{2}).\n$$\n因此，$J(x,y)$ 是奇异的当且仅当 $(x,y)=(0,0)$。特别地，$J$ 在坐标轴上的一般点处（除了原点）不是奇异的。这立即表明选项 C 是错误的。\n\n接下来，计算 $\\mathbf{F}$ 在坐标轴上的值。在 x 轴上，当 $y=0$ 时，\n$$\n\\mathbf{F}(x,0)=\\bigl(x^{2}-4,\\,-3\\bigr),\n$$\n这永远不是零向量。在 y 轴上，当 $x=0$ 时，\n$$\n\\mathbf{F}(0,y)=\\bigl(-y^{2}-4,\\,-3\\bigr),\n$$\n这也永远不是零向量。因此选项 B 是错误的。\n\n现在检查牛顿法经过一次迭代后是否仍停留在坐标轴上。使用由 $J\\mathbf{s}=-\\mathbf{F}$ 定义的牛顿步长 $\\mathbf{s}$。在 x 轴上（$y=0$），我们有\n$$\nJ(x,0)=\\begin{pmatrix}2x  0\\\\ 0  x\\end{pmatrix},\\qquad \\mathbf{F}(x,0)=\\begin{pmatrix}x^{2}-4\\\\ -3\\end{pmatrix}.\n$$\n然后\n$$\n\\mathbf{s}=-J^{-1}\\mathbf{F}=-\\begin{pmatrix}\\frac{1}{2x}  0\\\\[2pt] 0  \\frac{1}{x}\\end{pmatrix}\\begin{pmatrix}x^{2}-4\\\\ -3\\end{pmatrix}\n=\\begin{pmatrix}-\\frac{x^{2}-4}{2x}\\\\[4pt]\\frac{3}{x}\\end{pmatrix},\n$$\n所以下一个迭代点是\n$$\nx_{1}=x-\\frac{x^{2}-4}{2x}=\\frac{x}{2}+\\frac{2}{x},\\qquad y_{1}=0+\\frac{3}{x}=\\frac{3}{x}.\n$$\n由于对于任何有限的 $x$，$y_{1}=\\frac{3}{x}\\neq 0$，迭代点会立即离开坐标轴。在 y 轴上（$x=0$）进行类似的计算，求解\n$$\n\\begin{pmatrix}0  -2y\\\\ y  0\\end{pmatrix}\\begin{pmatrix}s_{x}\\\\ s_{y}\\end{pmatrix}=-\\begin{pmatrix}-y^{2}-4\\\\ -3\\end{pmatrix}=\\begin{pmatrix}y^{2}+4\\\\ 3\\end{pmatrix},\n$$\n得出 $s_{x}=\\frac{3}{y}$ 和 $s_{y}=-\\frac{y^{2}+4}{2y}$，所以\n$$\nx_{1}=0+\\frac{3}{y}=\\frac{3}{y},\\qquad y_{1}=y-\\frac{y^{2}+4}{2y}=\\frac{y}{2}-\\frac{2}{y}.\n$$\n迭代点同样立即离开坐标轴。因此选项 A 是错误的。\n\n为了排除选项 E，我们检查是否存在实数解。由 $xy=3$ 可得 $y=\\frac{3}{x}$，代入 $x^{2}-y^{2}=4$ 得到\n$$\nx^{2}-\\frac{9}{x^{2}}=4\\;\\;\\Longrightarrow\\;\\; x^{4}-4x^{2}-9=0.\n$$\n令 $t=x^{2}$。则 $t^{2}-4t-9=0$，所以 $t=2\\pm\\sqrt{13}$。可接受的根是 $t=2+\\sqrt{13}0$，因此\n$$\nx=\\pm\\sqrt{2+\\sqrt{13}},\\qquad y=\\frac{3}{x}=\\pm\\frac{3}{\\sqrt{2+\\sqrt{13}}},\n$$\n这表明存在两个实数解。因此选项 E 是错误的。\n\n剩下的就是确定为什么坐标轴是糟糕的初始猜测值选择。由于\n$$\n\\det J(x,y)=2(x^{2}+y^{2}),\n$$\n雅可比矩阵在 $(0,0)$ 处是奇异的，并且当 $(x,y)$ 靠近原点时变得病态。其显式逆矩阵为\n$$\nJ(x,y)^{-1}=\\frac{1}{2(x^{2}+y^{2})}\\begin{pmatrix}x  2y\\\\ -y  2x\\end{pmatrix},\n$$\n该矩阵的元素与 $x$ 和 $y$ 的线性函数乘以 $\\frac{1}{x^{2}+y^{2}}$ 成比例。在原点附近，这会产生巨大的牛顿步长。特别是在坐标轴上，上面推导出的牛顿更新量包含诸如 $\\frac{3}{x}$ 或 $\\frac{3}{y}$ 的项，当初始猜测值位于坐标轴上且靠近原点时，这些项的幅值会变得非常大。这种病态性解释了观察到的糟糕表现，而这正是选项 D 所描述的。\n\n因此，最准确和根本的原因是雅可比矩阵在原点处是奇异的，并且对于靠近原点的沿坐标轴的初始猜测值是近乎奇异的，这导致了不稳定性和收敛性不佳。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "牛顿法不仅是强大的求解工具，它还能揭示出令人惊叹的数学之美。本项高级实践将带你探索一个经典问题——牛顿分形 (Newton fractal)，其中不同解的吸引盆地 (basins of attraction) 形成了复杂的几何图案。你将需要从第一性原理出发推导迭代格式，并编写程序进行计算分析，这不仅能巩固你的理论知识，更能让你体验到理论与现代科学计算相结合的魅力。",
            "id": "3280962",
            "problem": "考虑一个由复多项式映射 $g(z)=z^3-1$ 的实部和虚部定义的、包含两个实变量的非线性方程组，其中 $z=x+\\mathrm{i}y$ 且 $\\mathrm{i}^2=-1$。定义向量值函数 $f:\\mathbb{R}^2\\to\\mathbb{R}^2$ 如下：\n$$\nf(x,y)=\\begin{bmatrix}\nx^3-3xy^2-1\\\\\n3x^2y-y^3\n\\end{bmatrix}.\n$$\n$f$ 的零点对应于 $g(z)=0$ 的根，即以下三个点：\n$$\nr_1=\\begin{bmatrix}1\\\\0\\end{bmatrix},\\quad\nr_2=\\begin{bmatrix}-\\tfrac{1}{2}\\\\\\tfrac{\\sqrt{3}}{2}\\end{bmatrix},\\quad\nr_3=\\begin{bmatrix}-\\tfrac{1}{2}\\\\-\\tfrac{\\sqrt{3}}{2}\\end{bmatrix}.\n$$\n应用于 $f$ 的牛顿法在平面上呈现出分形吸引盆，这意味着收敛到给定根的初始猜测点集合其边界具有分形结构。从多元微积分的基本原理和系统牛顿法的定义出发，利用 $f$ 的雅可比矩阵推导求解 $f(x,y)=\\mathbf{0}$ 的迭代格式。设计并实现一个算法，对于给定的初始猜测点 $(x_0,y_0)$，该算法执行牛顿迭代，直到满足收敛准则或达到最大迭代次数。\n\n在分析部分，量化寻找一个根的计算成本，将其表示为初始猜测点精度的函数。设初始猜测点位于围绕根 $r_1$ 的一个半径为 $\\varepsilon$ 的圆上，即：\n$$\n(x_0(\\theta),y_0(\\theta))=r_1+\\varepsilon\\begin{bmatrix}\\cos\\theta\\\\ \\sin\\theta\\end{bmatrix},\n$$\n其中 $\\theta$ 是一个均匀采样的角度，$\\theta_k=\\tfrac{2\\pi k}{K}$，$k\\in\\{0,1,\\dots,K-1\\}$，且 $K$ 是一个固定的正整数。角度必须以弧度为单位进行解释。对于每个 $\\varepsilon$，从这 $K$ 个初始猜测点开始运行算法，并计算：\n- 在固定的迭代预算内收敛的那些初始猜测点所花费的平均迭代次数。\n- 在预算内收敛的初始猜测点的比例，表示为区间 $[0,1]$ 内的一个小数。\n\n收敛准则定义如下：如果一个迭代点 $(x,y)$ 的残差范数满足 $\\|f(x,y)\\|_2\\le \\tau_f$，或者其与最近的精确根的距离满足 $\\min_{j\\in\\{1,2,3\\}}\\|[x,y]^T-r_j\\|_2\\le \\tau_r$，则认为该迭代点已收敛。如果在给定的 $\\varepsilon$ 下没有任何初始猜测点在迭代预算内收敛，则报告该 $\\varepsilon$ 的平均迭代次数为最大迭代次数 $M$。\n\n推导过程必须仅从基本定义开始，即一阶多元泰勒展开和雅可比矩阵。不要使用牛顿法的现成公式；需明确推导迭代法则。通过使用合理的参数值和鲁棒的停止规则来确保科学真实性。\n\n使用以下精度半径测试集：\n$$\n\\varepsilon\\in\\{0,\\;10^{-8},\\;0.2,\\;0.6,\\;1.2,\\;2.0\\}.\n$$\n使用 $K=64$ 个角度，最大迭代次数 $M=50$，残差容差 $\\tau_f=10^{-12}$，根邻近容差 $\\tau_r=10^{-8}$，如果迭代点离开以原点为中心、半径为 $R_{\\max}=10$ 的球体，则声明为发散。所有角度必须以弧度为单位处理。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，格式需严格遵循：\n$$\n\\text{[[m}_1,\\text{m}_2,\\dots,\\text{m}_6],[p_1,p_2,\\dots,p_6]},\n$$\n其中每个 $m_i$ 是对应 $\\varepsilon$ 的平均迭代次数（一个浮点数），每个 $p_i$ 是收敛的初始猜测点的比例（一个在 $[0,1]$ 区间内的浮点数）。输出必须按照测试集中给定的六个 $\\varepsilon$ 值的相同顺序计算。",
            "solution": "用户希望使用牛顿法求解非线性方程组 $f(x,y)=0$。我将首先从基本原理出发推导迭代公式。\n\n设 $\\mathbf{x} = \\begin{bmatrix}x\\\\y\\end{bmatrix}$ 为 $\\mathbb{R}^2$ 中的一个向量。该非线性方程组由向量值函数 $f(\\mathbf{x})=\\mathbf{0}$ 给出。牛顿法是一种迭代算法，它生成一系列近似值 $\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2, \\dots$，在适当条件下，这些近似值会收敛到 $f$ 的一个根。\n\n推导从 $f$ 在当前迭代点 $\\mathbf{x}_k$ 附近的一阶多元泰勒展开开始：\n$$\nf(\\mathbf{x}) \\approx f(\\mathbf{x}_k) + J_f(\\mathbf{x}_k)(\\mathbf{x} - \\mathbf{x}_k)\n$$\n其中 $J_f(\\mathbf{x}_k)$ 是 $f$ 在 $\\mathbf{x}_k$ 处求值的雅可比矩阵。我们寻求下一个迭代点 $\\mathbf{x}_{k+1}$，使得 $f(\\mathbf{x}_{k+1}) = \\mathbf{0}$。通过用 $\\mathbf{x}_{k+1}$ 替换 $\\mathbf{x}$ 并将近似值设为零，我们得到：\n$$\n\\mathbf{0} \\approx f(\\mathbf{x}_k) + J_f(\\mathbf{x}_k)(\\mathbf{x}_{k+1} - \\mathbf{x}_k)\n$$\n这个方程可以重排以求解更新步长 $\\Delta\\mathbf{x}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$：\n$$\nJ_f(\\mathbf{x}_k)\\Delta\\mathbf{x}_k = -f(\\mathbf{x}_k)\n$$\n假设雅可比矩阵是可逆的，我们可以解出 $\\Delta\\mathbf{x}_k$：\n$$\n\\Delta\\mathbf{x}_k = -[J_f(\\mathbf{x}_k)]^{-1}f(\\mathbf{x}_k)\n$$\n牛顿迭代则由以下更新规则定义：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta\\mathbf{x}_k = \\mathbf{x}_k - [J_f(\\mathbf{x}_k)]^{-1}f(\\mathbf{x}_k)\n$$\n现在，我们将这个通用公式应用于问题中给出的具体函数：\n$$\nf(x,y) = \\begin{bmatrix} f_1(x,y) \\\\ f_2(x,y) \\end{bmatrix} = \\begin{bmatrix} x^3 - 3xy^2 - 1 \\\\ 3x^2y - y^3 \\end{bmatrix}\n$$\n雅可比矩阵 $J_f(x,y)$ 由 $f$ 各分量的偏导数组成：\n$$\nJ_f(x,y) = \\begin{bmatrix} \\frac{\\partial f_1}{\\partial x}  \\frac{\\partial f_1}{\\partial y} \\\\ \\frac{\\partial f_2}{\\partial x}  \\frac{\\partial f_2}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} 3x^2 - 3y^2  -6xy \\\\ 6xy  3x^2 - 3y^2 \\end{bmatrix}\n$$\n为了求雅可比矩阵的逆，我们首先计算它的行列式：\n$$\n\\det(J_f(x,y)) = (3x^2 - 3y^2)(3x^2 - 3y^2) - (-6xy)(6xy) = 9(x^2 - y^2)^2 + 36x^2y^2\n$$\n$$\n\\det(J_f(x,y)) = 9(x^4 - 2x^2y^2 + y^4) + 36x^2y^2 = 9(x^4 + 2x^2y^2 + y^4) = 9(x^2 + y^2)^2\n$$\n只有当 $x^2 + y^2 = 0$ 时，行列式才为零，这种情况只发生在原点 $(x,y)=(0,0)$。在该点，雅可比矩阵是奇异的，牛顿步长未定义。这与 $(0,0)$ 是底层复映射 $g(z)=z^3-1$ 的一个临界点相符，因为其导数 $g'(z)=3z^2$ 在 $z=0$ 处为零。\n\n对于任意 $(x,y) \\neq (0,0)$，一个 $2 \\times 2$ 矩阵的逆由 $[J_f]^{-1} = \\frac{1}{\\det(J_f)}\\begin{bmatrix} d  -b \\\\ -c  a \\end{bmatrix}$ 给出。将其应用于我们的雅可比矩阵得到：\n$$\n[J_f(x,y)]^{-1} = \\frac{1}{9(x^2+y^2)^2} \\begin{bmatrix} 3x^2 - 3y^2  6xy \\\\ -6xy  3x^2 - 3y^2 \\end{bmatrix} = \\frac{1}{3(x^2+y^2)^2} \\begin{bmatrix} x^2 - y^2  2xy \\\\ -2xy  x^2 - y^2 \\end{bmatrix}\n$$\n牛顿更新步长 $\\Delta\\mathbf{x}_k = \\begin{bmatrix} \\Delta x_k \\\\ \\Delta y_k \\end{bmatrix}$ 通过求解线性系统 $J_f \\Delta\\mathbf{x} = -f$ 计算。使用显式逆矩阵：\n$$\n\\begin{bmatrix} \\Delta x_k \\\\ \\Delta y_k \\end{bmatrix} = -\\frac{1}{3(x_k^2+y_k^2)^2} \\begin{bmatrix} x_k^2 - y_k^2  2x_ky_k \\\\ -2x_ky_k  x_k^2 - y_k^2 \\end{bmatrix} \\begin{bmatrix} x_k^3 - 3x_ky_k^2 - 1 \\\\ 3x_k^2y_k - y_k^3 \\end{bmatrix}\n$$\n执行矩阵-向量乘法可以得到更新的简化表达式：\n$$\nx_{k+1} = x_k + \\Delta x_k = \\frac{2}{3}x_k + \\frac{x_k^2 - y_k^2}{3(x_k^2+y_k^2)^2}\n$$\n$$\ny_{k+1} = y_k + \\Delta y_k = \\frac{2}{3}y_k - \\frac{2x_ky_k}{3(x_k^2+y_k^2)^2}\n$$\n这些是从基本原理推导出的显式迭代公式。\n\n将要实现的算法将对每个指定的 $\\varepsilon$ 值执行以下步骤：\n1.  初始化总迭代次数和收敛轨迹数的计数器。\n2.  使用公式 $(x_0,y_0) = (1+\\varepsilon\\cos\\theta, \\varepsilon\\sin\\theta)$（其中 $\\theta_k = \\frac{2\\pi k}{K}$，$k \\in \\{0, 1, \\dots, K-1\\}$），在以根 $r_1=(1,0)$ 为中心、半径为 $\\varepsilon$ 的圆上生成 $K=64$ 个初始点 $(x_0, y_0)$。\n3.  对于每个初始点，执行牛顿法迭代，最多 $M=50$ 次。\n4.  在每次迭代中，检查是否收敛。如果一个迭代点 $(x,y)$ 的残差欧几里得范数 $\\|f(x,y)\\|_2$ 小于或等于 $\\tau_f=10^{-12}$，或者其与最近已知根的距离小于或等于 $\\tau_r=10^{-8}$，则认为该迭代点已收敛。如果在第 $i$ 次迭代时发生收敛，则该轨迹的迭代次数记录为 $i$，并更新计数器。\n5.  如果迭代点的范数 $\\|(x,y)\\|_2$ 超过 $R_{\\max}=10$，则认为迭代是发散的。如果一个初始猜测点在 $M$ 次迭代内未能收敛，则计为不收敛。\n6.  处理完给定 $\\varepsilon$ 的所有 $K$ 个初始点后，计算成功收敛轨迹的平均迭代次数。如果没有轨迹收敛，则报告此平均值为 $M$。\n7.  计算收敛轨迹的比例。\n8.  最终输出将是两个列表：一个包含平均迭代次数，另一个包含指定 $\\varepsilon$ 值序列的收敛比例。\n对于 $\\varepsilon=0$ 的情况，初始猜测点是 $(1,0)$，它本身就是一个根。算法应正确地将其识别为在 0 次迭代后收敛。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Newton's method for the system of equations derived\n    from the complex polynomial g(z) = z^3 - 1.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    epsilons = [0.0, 1e-8, 0.2, 0.6, 1.2, 2.0]\n    K = 64\n    M = 50\n    tau_f = 1e-12\n    tau_r = 1e-8\n    R_max = 10.0\n\n    # --- Problem Definitions ---\n    # The three roots of z^3 - 1 = 0 in the complex plane, as (x,y) coordinates.\n    r1 = np.array([1.0, 0.0])\n    r2 = np.array([-0.5, np.sqrt(3.0) / 2.0])\n    r3 = np.array([-0.5, -np.sqrt(3.0) / 2.0])\n    roots = np.array([r1, r2, r3])\n\n    def f(p: np.ndarray) - np.ndarray:\n        \"\"\"\n        Calculates the vector-valued function f(x, y).\n        p is a numpy array [x, y].\n        \"\"\"\n        x, y = p\n        f1 = x**3 - 3.0 * x * y**2 - 1.0\n        f2 = 3.0 * x**2 * y - y**3\n        return np.array([f1, f2])\n\n    # Lists to store the final results\n    mean_iters_list = []\n    conv_frac_list = []\n\n    for eps in epsilons:\n        total_iters = 0\n        converged_count = 0\n        \n        # Generate K initial guesses on a circle of radius eps around root r1\n        angles = np.linspace(0.0, 2.0 * np.pi, K, endpoint=False)\n        \n        for theta in angles:\n            # Current initial guess\n            p0 = r1 + eps * np.array([np.cos(theta), np.sin(theta)])\n            p = p0.copy()\n            \n            is_converged = False\n            iterations_for_path = 0\n\n            # Newton's method loop\n            for i in range(M + 1):\n                # 1. Check for divergence (leaving a large ball around the origin)\n                if np.linalg.norm(p)  R_max:\n                    break\n\n                # 2. Check for convergence\n                # Criterion 2a: Residual norm is small\n                if np.linalg.norm(f(p)) = tau_f:\n                    iterations_for_path = i\n                    is_converged = True\n                    break\n                \n                # Criterion 2b: Proximity to an exact root is small\n                dist_to_roots = np.linalg.norm(p - roots, axis=1)\n                if np.min(dist_to_roots) = tau_r:\n                    iterations_for_path = i\n                    is_converged = True\n                    break\n\n                # 3. If max iterations reached, the path has not converged\n                if i == M:\n                    break\n                \n                # 4. Perform the Newton iteration step\n                x, y = p\n                \n                # Denominator corresponds to 3*|z|^4, where z=x+iy\n                denom_part = x**2 + y**2\n                \n                # Handle singularity at the origin (z=0)\n                if denom_part  1e-24: # Effectively zero, prevent division by zero\n                    break\n                    \n                denom = 3.0 * denom_part**2\n                \n                # Update formulas derived in the solution\n                x_new = (2.0 / 3.0) * x + (x**2 - y**2) / denom\n                y_new = (2.0 / 3.0) * y - (2.0 * x * y) / denom\n                \n                p = np.array([x_new, y_new])\n\n            if is_converged:\n                converged_count += 1\n                total_iters += iterations_for_path\n        \n        # Calculate the required metrics for the current epsilon\n        if converged_count  0:\n            mean_iters = float(total_iters) / converged_count\n        else:\n            # As per problem specification\n            mean_iters = float(M)\n            \n        conv_frac = float(converged_count) / K\n        \n        mean_iters_list.append(mean_iters)\n        conv_frac_list.append(conv_frac)\n\n    # Format the final output string exactly as required\n    mean_iters_str = ','.join(map(str, mean_iters_list))\n    conv_frac_str = ','.join(map(str, conv_frac_list))\n    \n    print(f\"[[{mean_iters_str}],[{conv_frac_str}]]\")\n\nsolve()\n```"
        }
    ]
}