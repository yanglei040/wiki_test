{
    "hands_on_practices": [
        {
            "introduction": "掌握任何数值方法的第一步都是理解其核心计算机制。这个练习将试位法分解为一个单一、可控的步骤，让你亲手计算连接区间端点的割线与x轴的交点。通过这个基础计算，你将为理解完整的迭代过程奠定坚实的基础。",
            "id": "2217545",
            "problem": "在一个自调节热力系统的简化模型中，非平凡平衡温度由超越方程 $f(x) = \\exp(-x) - x = 0$ 的正根描述，其中 $x$ 是一个无量纲的温度参数。根据物理约束，已知一个根位于区间 $[0, 1]$ 内。\n\n为了逼近这个根，采用了一种单步数值方法。第一次近似值，记为 $x_1$，是通过找到连接曲线 $y=f(x)$ 上对应区间端点的两点的割线的x轴截距来确定的。\n\n计算这个第一次近似值 $x_1$ 的值。将你的最终答案四舍五入至四位有效数字。",
            "solution": "给定 $f(x) = \\exp(-x) - x$ 和区间 $[0,1]$。经过点 $(0,f(0))$ 和 $(1,f(1))$ 的割线斜率为\n$$\nm=\\frac{f(1)-f(0)}{1-0} = \\left(\\exp(-1)-1\\right) - 1 = \\exp(-1) - 2.\n$$\n这条割线的方程是\n$$\ny = f(0) + m(x-0) = 1 + \\left(\\exp(-1) - 2\\right)x.\n$$\n第一次近似值 $x_{1}$ 是这条线的x轴截距，通过令 $y=0$ 并求解 $x$ 得到：\n$$\n0 = 1 + \\left(\\exp(-1) - 2\\right)x \\quad \\Longrightarrow \\quad x_{1} = \\frac{1}{2 - \\exp(-1)}.\n$$\n为了得到所需的数值，计算\n$$\n\\exp(-1) \\approx 0.3678794412,\\quad 2 - \\exp(-1) \\approx 1.6321205588,\\quad x_{1} \\approx \\frac{1}{1.6321205588} \\approx 0.6126998368.\n$$\n四舍五入到四位有效数字，得到 $x_{1} \\approx 0.6127$。",
            "answer": "$$\\boxed{0.6127}$$"
        },
        {
            "introduction": "在掌握了基本计算之后，一个更深层次的问题是：试位法总是高效的吗？这个练习将引导你从“如何做”转向“为什么会这样”。通过构建一个特定的函数，你将揭示试位法一个著名的收敛性陷阱——“端点停滞”现象，并从函数曲率（凸性）的角度理解其几何根源。",
            "id": "3251415",
            "problem": "考虑使用试位法（也称为 regula falsi 法）来寻找一个连续函数的根。该方法维持一个满足 $f(a_n)f(b_n)0$ 的包围区间 $\\left[a_n,b_n\\right]$。在每次迭代中，该方法构造一条通过点 $\\left(a_n,f(a_n)\\right)$ 和 $\\left(b_n,f(b_n)\\right)$ 的直线，确定其在 $\\left[a_n,b_n\\right]$ 内的唯一零点 $c_n$，并通过替换与 $f(c_n)$ 符号相同的端点来选择下一个包围区间；根据介值定理（IVT），$f$ 在 $\\left[a_n,b_n\\right]$ 上的连续性以及 $f(a_n)f(b_n)0$ 的条件保证了根始终被包围。\n\n构造一个显式的二阶连续可微函数 $f(x)$，并使用初始区间 $\\left[a_0,b_0\\right]=\\left[0,2\\right]$，使得：\n1) $f$ 在 $\\left[0,2\\right]$ 上是严格单调递增且严格凸的，\n2) $f(0)f(2)0$，因此根据介值定理，在 $\\left(0,2\\right)$ 内存在一个根，\n3) 当试位法以 $\\left[a_0,b_0\\right]=\\left[0,2\\right]$ 初始化时，对于所有迭代 $n>1$，右端点 $b_n$ 保持不变（即，对于所有 $n \\geq 1$，$b_n=b_0$）。\n\n从凸性的基本原理和线性插值的几何意义出发，严格证明为何对于你选择的函数 $f$，右端点对于所有 $n\\geq 1$ 都保持不变。提供这样一个 $f(x)$ 的一个显式闭式表达式作为你的最终答案。不需要进行数值舍入。",
            "solution": "我们选择函数 $f(x) = \\exp(x) - 2$ 和初始区间 $[a_0, b_0] = [0, 2]$。\n\n1) **函数性质验证**：\n - **单调性**：$f'(x) = \\exp(x)$。由于对于所有实数 $x$，$f'(x) > 0$，所以 $f(x)$ 在 $[0, 2]$ 上是严格单调递增的。\n - **凸性**：$f''(x) = \\exp(x)$。由于对于所有实数 $x$，$f''(x) > 0$，所以 $f(x)$ 在 $[0, 2]$ 上是严格凸的。\n\n2) **初始区间验证**：\n - $f(0) = \\exp(0) - 2 = 1 - 2 = -1$。\n - $f(2) = \\exp(2) - 2 \\approx 7.389 - 2 = 5.389$。\n - 因此，$f(0) \\cdot f(2)  0$，满足试位法的初始条件，保证在 $(0, 2)$ 内存在一个根。\n\n3) **证明端点停滞**：\n根据严格凸性的定义，对于区间 $[a, b]$ 内的任意一点 $x \\in (a, b)$，函数图像上的点 $(x, f(x))$ 位于连接端点 $(a, f(a))$ 和 $(b, f(b))$ 的割线下方。\n设 $L_n(x)$ 为通过 $(a_n, f(a_n))$ 和 $(b_n, f(b_n))$ 的割线。在第一次迭代中，区间为 $[a_0, b_0] = [0, 2]$。\n试位法计算的下一个近似点 $c_n$ 是割线 $L_n(x)$ 与x轴的交点，即 $L_n(c_n) = 0$。\n设函数的真实根为 $r$，即 $f(r)=0$。由于函数是严格凸的，对于 $x \\in (a_n, b_n)$，有 $f(x)  L_n(x)$。特别地，在真实根 $r$ 处，我们有 $0 = f(r)  L_n(r)$。\n因为割线 $L_n(x)$ 是单调递增的（因为 $f$ 是单调递增的，所以 $f(b_n) > f(a_n)$），并且 $L_n(c_n)=0  L_n(r)$，所以必然有 $c_n  r$。\n由于 $f(x)$ 是严格单调递增的，从 $c_n  r$ 可得 $f(c_n)  f(r) = 0$。\n根据试位法的更新规则，如果 $f(c_n)$ 与 $f(a_n)$ 同号（在此例中均为负），则新的左端点 $a_{n+1}$ 被更新为 $c_n$，右端点 $b_{n+1}$ 保持为 $b_n$。\n在我们的例子中，$f(a_0)  0$。我们已经证明，对于任何迭代 $n$，只要 $f(a_n)  0$ 且函数是凸的，$f(c_n)$ 也将为负。通过归纳法，由于 $a_0$ 处的函数值为负，所有后续的 $a_n$（即 $c_{n-1}$）的函数值都将为负。\n因此，更新规则总是选择 $a_{n+1} = c_n$ 和 $b_{n+1} = b_n$。\n这证明了从第一次迭代开始（$n=0$），右端点 $b_1 = b_0 = 2$。通过归纳法，对于所有的 $n \\geq 1$，$b_n = b_0$ 保持不变。\n因此，函数 $f(x) = \\exp(x) - 2$ 在区间 $[0, 2]$ 上满足所有要求。",
            "answer": "$$\\boxed{\\exp(x)-2}$$"
        },
        {
            "introduction": "识别算法的弱点是改进它的第一步。最后的这个实践将带你从分析走向综合，任务是设计一个更“智能”的混合算法。你将结合试位法的快速收敛潜力和二分法的稳健性，来克服在前一个练习中发现的端点停滞问题，这在数值计算领域中是一种常见的优化策略。",
            "id": "3251464",
            "problem": "设计并实现一个完整的、可运行的程序，该程序通过一种混合区间法计算连续实值函数的根。该方法主要使用试位法 (regula falsi)，并在区间的某个端点连续两次迭代保持不变时，临时切换到二分步骤。该方法必须作用于闭区间 $[a,b]$ 上的连续函数 $f$，且满足 $f(a)\\cdot f(b)\\le 0$，因此根据介值定理，在 $[a,b]$ 内至少存在一个根。程序不得依赖任何用户输入。\n\n您必须从基本原理出发构建算法。从以下基础开始：\n- 函数 $f$ 在 $[a,b]$ 上的连续性以及介值定理保证了当 $f(a)\\cdot f(b)\\le 0$ 时，在 $[a,b]$ 中至少存在一个 $x^\\star$ 使得 $f(x^\\star)=0$。\n- 对 $(a,f(a))$ 和 $(b,f(b))$ 进行线性插值的概念可以得出一个 $x$ 坐标，该坐标是插值线与水平轴的交点，可作为 $[a,b]$ 内的一个候选点，用于以保持异号的方式更新区间。\n- 通过区间中点（二分法）对区间进行划分，可以保持一个异号区间，并将区间宽度减小为原来的 $2$ 分之一。\n\n您的混合方法必须满足以下所有要求。\n- 初始化与区间设定：\n  - 接受一个连续函数 $f$、一个满足 $f(a)\\cdot f(b)\\le 0$ 的初始区间 $[a,b]$、一个函数值绝对容差 $\\tau_f0$、一个区间长度绝对容差 $\\tau_x0$ 以及一个最大迭代次数 $N_{\\max}\\in\\mathbb{N}$。\n  - 如果在初始化时 $f(a)=0$ 或 $f(b)=0$，则立即返回该端点作为根的近似值。\n- 迭代与更新规则：\n  - 在每次迭代中，通过对 $(a,f(a))$ 和 $(b,f(b))$ 进行线性插值来计算 $[a,b]$ 内的一个候选点，以此作为主要步骤。利用候选点处 $f$ 的符号来选择保留异号的新子区间，并相应地更新区间端点。\n  - 跟踪每次迭代中更新的是哪个端点。如果连续两次迭代更新了同一个端点，则意味着另一个端点已连续两次保持不变。在这种情况下，下一次迭代必须执行一次二分法更新，而不是线性插值更新，并且在这次二分更新后，必须重置用于跟踪端点停滞状态的计数器。\n  - 为保证数值稳健性，如果线性插值步骤由于分母（例如 $|f(b)-f(a)|$）有效消失（低于机器精度）而变得不适定，则该次迭代应改为执行二分法更新。\n- 终止条件与返回值：\n  - 当当前候选点 $c$ 处的函数值满足 $|f(c)|\\le \\tau_f$ 时，或当前区间宽度满足 $b-a\\le \\tau_x$ 时，或迭代计数器达到 $N_{\\max}$ 时，终止迭代。返回最新的候选点 $c$（如果在初始化时检测到精确的端点根，则返回该端点）。\n- 角度单位：当使用三角函数时，将角度视为弧度。\n- 输出格式：对于下面测试套件中的每个测试用例，返回计算出的根的近似值，形式为浮点数，并四舍五入到 $10$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，格式为 $[r_1,r_2,\\dots]$，不含空格。\n\n测试套件。实现您的程序，使其按此确切顺序计算以下 $5$ 个案例的根近似值，每个案例均使用 $\\tau_x=10^{-10}$、$\\tau_f=10^{-12}$ 和 $N_{\\max}=100$。\n- 案例 1：$f(x)=x^3-x-2$ 于 $[1,2]$ 上。\n- 案例 2：$f(x)=e^{-x}-x$ 于 $[0,1]$ 上。\n- 案例 3：$f(x)=(x-1)(x-2)$ 于 $[1,3]$ 上。\n- 案例 4：$f(x)=\\cos(x)-x$ 于 $[0,1]$ 上；将 $x$ 解释为弧度。\n- 案例 5：$f(x)=x^3$ 于 $[-1,1]$ 上。\n\n您的程序必须按上述顺序计算五个根的近似值，并打印一行包含列表 $[r_1,r_2,r_3,r_4,r_5]$ 的内容，其中每个 $r_i$ 均按要求四舍五入到 $10$ 位小数。不得打印任何额外文本。",
            "solution": "该问题陈述经评估是有效的。它在科学上基于数值分析的原理，特别是介值定理、试位法（regula falsi）和二分法。该问题是适定的，为设计一种混合求根算法提供了一套完整且一致的要求。语言客观，测试用例定义明确，适合用于验证算法的实现。\n\n任务是为闭区间 $[a, b]$ 上的连续函数 $f(x)$ 设计并实现一种混合求根算法，其中保证 $f(a) \\cdot f(b) \\le 0$。因此，根据介值定理，可以确保在 $[a, b]$ 中至少存在一个根 $x^\\star$。该算法主要使用试位法，但引入了二分步骤，以缓解因某个区间端点停滞不动而可能导致的收敛缓慢问题。\n\n试位法的核心是线性插值。给定两个包含根的点 $(a, f(a))$ 和 $(b, f(b))$，该算法用连接这两点的直线（割线）来近似函数 $f(x)$。根的下一个近似值 $c$ 是这条割线的 $x$ 轴截距。$c$ 的公式由直线的点斜式导出，形式如下：\n$$\nc = a - f(a) \\frac{b - a}{f(b) - f(a)}\n$$\n当 $a$ 和 $b$ 值很大且彼此接近时，这种形式比另一种形式 $c = \\frac{a f(b) - b f(a)}{f(b) - f(a)}$ 更不易发生灾难性抵消，因此在数值稳定性上通常更受青睐。\n\n二分法提供了一种稳健但速度较慢的替代方案。它通过反复将区间对半分割并选择保持异号的子区间来保证收敛。中点 $c$ 的计算公式为：\n$$\nc = a + \\frac{1}{2}(b - a)\n$$\n\n问题中指定的混合算法结合了这两种方法。迭代过程如下：\n1.  **初始化**：给定函数 $f$、区间 $[a, b]$、容差 $\\tau_f > 0$ 和 $\\tau_x > 0$ 以及最大迭代次数 $N_{\\max}$。计算 $f_a = f(a)$ 和 $f_b = f(b)$。如果 $|f_a| \\le \\tau_f$ 或 $|f_b| \\le \\tau_f$，则返回相应的端点作为根。初始化两个计数器 `stagnant_a` 和 `stagnant_b` 为 $0$，用于跟踪端点连续保持不变的迭代次数。\n\n2.  **迭代循环**：循环最多执行 $N_{\\max}$ 次。在每次迭代中，计算一个新的候选根 $c$。\n\n3.  **步骤选择**：\n    -   **停滞检查**：如果 `stagnant_a` 或 `stagnant_b` 大于或等于 $2$，表明一个端点已连续两次迭代保持不变。此时执行一次二分步骤，并将两个停滞计数器重置为 $0$。\n    -   **稳健性检查**：如果试位法公式中的分母 $|f(b) - f(a)|$ 接近于零（例如，小于机器精度），则执行一次二分步骤以防止数值不稳定。在这种情况下，不重置停滞计数器。\n    -   **默认步骤**：如果以上条件均不满足，则执行标准的试位法步骤。\n\n4.  **候选点评估与终止**：在新的候选点 $c$ 处计算函数值 $f_c = f(c)$。如果函数值足够接近零，即 $|f_c| \\le \\tau_f$，算法终止并返回 $c$。\n\n5.  **区间更新与计数器管理**：如果算法不终止，则更新区间。\n    -   如果 $f_a$ 和 $f_c$ 同号（即 $f_a \\cdot f_c > 0$），则根必在 $[c, b]$ 内。因此，将 $a$ 更新为 $c$，并将 $f_a$ 更新为 $f_c$。由于 $b$ 保持不变，`stagnant_b` 增加，`stagnant_a` 重置为 $0$。\n    -   否则，根必在 $[a, c]$ 内。因此，将 $b$ 更新为 $c$，并将 $f_b$ 更新为 $f_c$。由于 $a$ 保持不变，`stagnant_a` 增加，`stagnant_b` 重置为 $0$。\n\n6.  **区间宽度终止**：更新区间后，检查新区间的宽度 $b-a$。如果 $b-a \\le \\tau_x$，则认为区间足够小。算法终止，并返回当前迭代的候选点 $c$。\n\n7.  **最大迭代次数**：如果循环在未满足任何其他终止条件的情况下完成了 $N_{\\max}$ 次迭代，则终止并返回最后计算的候选点 $c$。\n\n这种结构化方法利用了试位法的速度，同时使用二分法来避免其性能不佳的情况，从而确保了稳健的收敛。指定的测试用例将验证此逻辑的实现，包括诸如初始端点即为根以及易于导致停滞的函数等边缘情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hybrid_root_finder(f, a, b, tau_f, tau_x, n_max):\n    \"\"\"\n    Computes a root of a function f on an interval [a, b] using a hybrid\n    of the method of false position and the bisection method.\n\n    Args:\n        f (callable): The function for which to find a root.\n        a (float): The lower bound of the bracketing interval.\n        b (float): The upper bound of the bracketing interval.\n        tau_f (float): The absolute function value tolerance for convergence.\n        tau_x (float): The absolute interval width tolerance for convergence.\n        n_max (int): The maximum number of iterations.\n\n    Returns:\n        float: The approximated root.\n    \"\"\"\n    fa = f(a)\n    fb = f(b)\n\n    # Initial check if endpoints are roots\n    if abs(fa) = tau_f:\n        return a\n    if abs(fb) = tau_f:\n        return b\n\n    # Ensure the initial interval brackets a root\n    if fa * fb > 0:\n        raise ValueError(\"The initial interval [a, b] does not bracket a root.\")\n\n    stagnant_a_counter = 0\n    stagnant_b_counter = 0\n    \n    # Initialize c to a value within the interval for safety in case of early termination\n    c = a\n\n    for _ in range(n_max):\n        # 1. Determine step type and calculate the new candidate point 'c'\n        use_bisection_stagnation = stagnant_a_counter >= 2 or stagnant_b_counter >= 2\n        \n        denom = fb - fa\n        use_bisection_robustness = abs(denom)  np.finfo(float).eps\n\n        if use_bisection_stagnation:\n            c = a + 0.5 * (b - a)\n            # Reset counters after a stagnation-induced bisection step\n            stagnant_a_counter = 0\n            stagnant_b_counter = 0\n        elif use_bisection_robustness:\n            c = a + 0.5 * (b - a)\n        else:\n            # Method of False Position (Regula Falsi)\n            c = a - fa * (b - a) / denom\n\n        fc = f(c)\n\n        # 2. Check for convergence based on function value at c\n        if abs(fc) = tau_f:\n            return c\n\n        # 3. Update the bracketing interval and stagnation counters\n        if fa * fc > 0:\n            # Root is in [c, b], so update the left endpoint 'a'\n            a, fa = c, fc\n            stagnant_b_counter += 1\n            stagnant_a_counter = 0\n        else:\n            # Root is in [a, c], so update the right endpoint 'b'\n            b, fb = c, fc\n            stagnant_a_counter += 1\n            stagnant_b_counter = 0\n            \n        # 4. Check for convergence based on the width of the new interval\n        if b - a = tau_x:\n            return c\n\n    # Return the last computed candidate if max iterations reached\n    return c\n\ndef solve():\n    \"\"\"\n    Solves the defined test cases and prints the results in the specified format.\n    \"\"\"\n    # Define common parameters for all test cases\n    tau_x = 1e-10\n    tau_f = 1e-12\n    n_max = 100\n\n    # Define the functions for the test cases\n    def f1(x): return x**3 - x - 2\n    def f2(x): return np.exp(-x) - x\n    def f3(x): return (x - 1) * (x - 2)\n    def f4(x): return np.cos(x) - x\n    def f5(x): return x**3\n\n    # Define the test cases as a list of tuples: (function, a, b)\n    test_cases = [\n        (f1, 1.0, 2.0),\n        (f2, 0.0, 1.0),\n        (f3, 1.0, 3.0),\n        (f4, 0.0, 1.0),\n        (f5, -1.0, 1.0),\n    ]\n\n    results = []\n    for func, a_val, b_val in test_cases:\n        root = hybrid_root_finder(func, a_val, b_val, tau_f, tau_x, n_max)\n        results.append(root)\n\n    # Format the results rounded to 10 decimal places\n    formatted_results = [f'{round(r, 10):.10f}' for r in results]\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}