{
    "hands_on_practices": [
        {
            "introduction": "在数值求解领域，我们常常面临多种方法选择。一个自然而然的问题是：“哪种方法是最好的？” 这个问题的答案通常在于计算成本和所获精度之间的权衡。本练习将引导您亲手实现并比较几种不同阶的龙格-库塔方法，通过量化分析它们的计算成本（以函数评估次数衡量）与全局误差，让您直观地理解高阶方法在达到相同精度时为何常常更有效率。这个基础实践是评估和选择数值积分方法的核心技能。",
            "id": "3205643",
            "problem": "您需要研究在将固定步长的显式龙格-库塔方法应用于一个耦合、非刚性、线性常微分方程（ODEs）组时，计算成本与精度之间的权衡。考虑以下系统的初值问题：\n$$\n\\begin{cases}\n\\frac{d y_1}{d t} = - y_1, \\\\[4pt]\n\\frac{d y_2}{d t} = y_1 - 2 y_2, \\\\[4pt]\n\\frac{d y_3}{d t} = y_2 - 3 y_3,\n\\end{cases}\n\\quad t \\in [0,T], \\quad\n\\mathbf{y}(0) = \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\\\ y_3(0) \\end{bmatrix}\n= \\begin{bmatrix} 1.3 \\\\ -0.9 \\\\ 0.7 \\end{bmatrix},\n\\quad T = 4.0.\n$$\n\n您的任务是：\n- 实现三种用于常微分方程组的显式龙格-库塔方法：\n  - 二阶方法（显式中点法），\n  - 三阶方法（经典三阶库塔法），\n  - 四阶方法（经典四阶龙格-库塔法）。\n- 每次模拟使用固定的时间步长，并将数值解从 $t=0$ 传播到 $t=T$。\n- 将一次运行的计算成本定义为函数求值的总次数（常微分方程组右端项的求值次数）。对于一个具有 $N$ 个步长的 $s$ 级龙格-库塔方法，成本为 $s \\cdot N$。\n- 将精度衡量为在 $t=T$ 时全局误差的欧几里得范数，即 $\\|\\mathbf{y}_{\\text{num}}(T) - \\mathbf{y}_{\\text{true}}(T) \\|_2$。\n\n为进行误差评估，请使用从第一性原理为该三角线性系统得到的精确解。设 $a = y_1(0)$，$b = y_2(0)$ 和 $c = y_3(0)$。在时间 $t$ 时的精确解分量为：\n$$\ny_1(t) = a e^{-t},\n$$\n$$\ny_2(t) = a e^{-t} + (b - a) e^{-2t},\n$$\n$$\ny_3(t) = \\frac{a}{2} e^{-t} + (b - a) e^{-2t} + \\left(c - b + \\frac{a}{2}\\right) e^{-3t}.\n$$\n\n使用以下测试套件来探究成本与精度的关系。对于每种方法，使用 $N \\in \\{1, 2, 5, 10, 20, 40\\}$ 个均匀步长在 $[0, T]$ 上进行模拟：\n- 对于二阶方法（显式中点法），使用 $N \\in \\{1, 2, 5, 10, 20, 40\\}$。\n- 对于三阶方法（经典三阶库塔法），使用 $N \\in \\{1, 2, 5, 10, 20, 40\\}$。\n- 对于四阶方法（经典法），使用 $N \\in \\{1, 2, 5, 10, 20, 40\\}$。\n\n对于每次运行，记录数据对 $[m, e]$，其中 $m$ 是函数求值的总次数，$e$ 是在 $t=T$ 时全局误差的欧几里得范数。最终程序输出必须按以下顺序将所有结果聚合到一个列表中：\n- 首先按上述 $N$ 的顺序，列出二阶方法的所有结果，\n- 然后按上述 $N$ 的顺序，列出三阶方法的所有结果，\n- 最后按上述 $N$ 的顺序，列出四阶方法的所有结果。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[[m1,e1],[m2,e2],...]`）。此问题不涉及物理单位，任何可能出现的角度都应被视为无量纲实数。所有数值答案必须在输出列表中以原始十进制数形式报告，不带任何附加文本。",
            "solution": "用户的要求是分析将三种不同的显式龙格-库塔（RK）方法应用于一个线性常微分方程（ODEs）组时的计算成本与精度。该问题定义明确，科学上合理，并且内容自洽，提供了常微分方程组、初始条件、时间区间、具体的数值方法、成本和误差的定义，以及用于验证的精确解析解。因此，该问题被判定为**有效**。\n\n问题的核心在于对以下形式的初值问题（IVP）进行数值积分：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y}), \\quad \\mathbf{y}(t_0) = \\mathbf{y}_0\n$$\n其中 $\\mathbf{y}(t) \\in \\mathbb{R}^3$。给定的系统是：\n$$\n\\mathbf{f}(t, \\mathbf{y}) = \\begin{bmatrix} -y_1 \\\\ y_1 - 2y_2 \\\\ y_2 - 3y_3 \\end{bmatrix}\n$$\n在区间 $t \\in [0, 4.0]$ 上的初始条件为 $\\mathbf{y}(0) = [1.3, -0.9, 0.7]^T$。\n\n一个 $s$ 级显式龙格-库塔方法使用以下通用公式将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^s b_i \\mathbf{k}_i\n$$\n其中，各个阶段 $\\mathbf{k}_i$ 是顺序计算的：\n$$\n\\mathbf{k}_i = \\mathbf{f}\\left(t_n + c_i h, \\mathbf{y}_n + h \\sum_{j=1}^{i-1} a_{ij} \\mathbf{k}_j\\right)\n$$\n每次计算 $\\mathbf{k}_i$ 都构成对函数 $\\mathbf{f}$ 的一次求值。因此，对于单个时间步长，一个 $s$ 级方法需要 $s$ 次函数求值。在 $N$ 个步长上，函数求值的总次数（定义为计算成本 $m$）为 $m = s \\cdot N$。\n\n精度通过最终时间 $T$ 时的全局误差的欧几里得范数来衡量，$e = \\|\\mathbf{y}_{\\text{num}}(T) - \\mathbf{y}_{\\text{true}}(T) \\|_2$。\n\n三种指定的方法是：\n\n1.  **二阶方法（显式中点法）**：这是一个 $2$ 级方法（$s=2$），阶数为 $p=2$。其更新公式为：\n    $$\n    \\begin{align*}\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{1}{2}h, \\mathbf{y}_n + \\frac{1}{2}h\\mathbf{k}_1\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\mathbf{k}_2\n    \\end{align*}\n    $$\n\n2.  **三阶方法（经典库塔法）**：这是一个 $3$ 级方法（$s=3$），阶数为 $p=3$。使用的具体变体为：\n    $$\n    \\begin{align*}\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{1}{2}h, \\mathbf{y}_n + \\frac{1}{2}h\\mathbf{k}_1\\right) \\\\\n    \\mathbf{k}_3 = \\mathbf{f}\\left(t_n + h, \\mathbf{y}_n - h\\mathbf{k}_1 + 2h\\mathbf{k}_2\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 4\\mathbf{k}_2 + \\mathbf{k}_3)\n    \\end{align*}\n    $$\n\n3.  **四阶方法（经典RK4）**：这是一个 $4$ 级方法（$s=4$），阶数为 $p=4$。其公式为：\n    $$\n    \\begin{align*}\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) \\\\\n    \\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{1}{2}h, \\mathbf{y}_n + \\frac{1}{2}h\\mathbf{k}_1\\right) \\\\\n    \\mathbf{k}_3 = \\mathbf{f}\\left(t_n + \\frac{1}{2}h, \\mathbf{y}_n + \\frac{1}{2}h\\mathbf{k}_2\\right) \\\\\n    \\mathbf{k}_4 = \\mathbf{f}\\left(t_n + h, \\mathbf{y}_n + h\\mathbf{k}_3\\right) \\\\\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{align*}\n    $$\n\n用于误差计算的解析解已提供，并可实现为一个关于时间 $t$ 的函数。设 $a=y_1(0)$，$b=y_2(0)$ 和 $c=y_3(0)$：\n$$\n\\begin{align*}\ny_1(t) = a e^{-t} \\\\\ny_2(t) = a e^{-t} + (b - a) e^{-2t} \\\\\ny_3(t) = \\frac{a}{2} e^{-t} + (b - a) e^{-2t} + \\left(c - b + \\frac{a}{2}\\right) e^{-3t}\n\\end{align*}\n$$\n\n该解是通过创建一个通用的求解器函数来实现的，该函数接受一个步进函数（即龙格-库塔方法之一）作为参数。一个主循环遍历三种方法，并对每种方法，遍历指定的步数列表 $N \\in \\{1, 2, 5, 10, 20, 40\\}$。对于每次运行，固定的时间步长为 $h = T/N$。求解器将解从 $t=0$ 传播到 $t=T$。最后，计算成本 $m$ 和误差 $e$ 并存储。所有运行的结果按规定聚合到一个列表中。需要注意的是，对于显式方法，步长 $h$ 必须足够小以保持在绝对稳定域内。该系统矩阵的特征值为 $\\lambda = -1, -2, -3$。对于最严格的特征值 $\\lambda = -3$，稳定性要求 $h \\le 2/3$。因此，使用大步长（$N=1, h=4.0$；$N=2, h=2.0$；$N=5, h=0.8$）的模拟预计会不稳定并产生非常大的误差。这种行为是分析的一部分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ODE system using three Runge-Kutta methods and calculates\n    the cost-vs-accuracy trade-off for various step counts.\n    \"\"\"\n    \n    # Problem parameters\n    T = 4.0\n    y0 = np.array([1.3, -0.9, 0.7])\n    a, b, c = y0[0], y0[1], y0[2]\n    N_values = [1, 2, 5, 10, 20, 40]\n\n    # Define the ODE system dy/dt = f(t, y)\n    def f(t, y):\n        \"\"\"\n        Right-hand side of the ODE system.\n        \"\"\"\n        # The 't' argument is unused as the system is autonomous, but it is\n        # included for compatibility with general-purpose ODE solver signatures.\n        dydt = np.zeros_like(y, dtype=float)\n        dydt[0] = -y[0]\n        dydt[1] = y[0] - 2.0 * y[1]\n        dydt[2] = y[1] - 3.0 * y[2]\n        return dydt\n\n    # Define the exact analytical solution\n    def y_true_func(t):\n        \"\"\"\n        Calculates the exact solution at a given time t.\n        \"\"\"\n        exp_t = np.exp(-t)\n        exp_2t = np.exp(-2.0 * t)\n        exp_3t = np.exp(-3.0 * t)\n        \n        y1_t = a * exp_t\n        y2_t = a * exp_t + (b - a) * exp_2t\n        y3_t = (a / 2.0) * exp_t + (b - a) * exp_2t + (c - b + a / 2.0) * exp_3t\n        \n        return np.array([y1_t, y2_t, y3_t])\n\n    # --- Runge-Kutta Stepper Functions ---\n    # Each stepper function advances the solution by one time step h.\n    \n    def rk2_step(f_func, t, y, h):\n        \"\"\"Explicit Midpoint (2 stages, 2nd order)\"\"\"\n        k1 = f_func(t, y)\n        k2 = f_func(t + 0.5 * h, y + 0.5 * h * k1)\n        return y + h * k2\n\n    def rk3_step(f_func, t, y, h):\n        \"\"\"Classic Kutta (3 stages, 3rd order)\"\"\"\n        k1 = f_func(t, y)\n        k2 = f_func(t + 0.5 * h, y + 0.5 * h * k1)\n        k3 = f_func(t + h, y - h * k1 + 2.0 * h * k2)\n        return y + (h / 6.0) * (k1 + 4.0 * k2 + k3)\n\n    def rk4_step(f_func, t, y, h):\n        \"\"\"Classical Runge-Kutta (4 stages, 4th order)\"\"\"\n        k1 = f_func(t, y)\n        k2 = f_func(t + 0.5 * h, y + 0.5 * h * k1)\n        k3 = f_func(t + 0.5 * h, y + 0.5 * h * k2)\n        k4 = f_func(t + h, y + h * k3)\n        return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    # General-purpose ODE solver for a fixed number of steps\n    def solve_ivp(stepper, f_func, y_initial, t_final, n_steps):\n        h = t_final / n_steps\n        y = y_initial.copy()\n        t = 0.0\n        for _ in range(n_steps):\n            y = stepper(f_func, t, y, h)\n            t += h\n        return y\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    \n    methods = [\n        (rk2_step, 2),  # (stepper_function, number_of_stages)\n        (rk3_step, 3),\n        (rk4_step, 4)\n    ]\n    \n    y_exact_at_T = y_true_func(T)\n    \n    for stepper, s in methods:\n        for N in N_values:\n            # Calculate numerical solution at T\n            y_num_at_T = solve_ivp(stepper, f, y0, T, N)\n            \n            # Calculate Euclidean norm of the global error\n            error = np.linalg.norm(y_num_at_T - y_exact_at_T)\n            \n            # Calculate computational cost (total function evaluations)\n            cost = s * N\n            \n            all_results.append([cost, error])\n\n    # Format the results into a single string `[[m1,e1],[m2,e2],...]`\n    # This manual formatting ensures no spaces are included.\n    string_parts = [f\"[{m},{e}]\" for m, e in all_results]\n    final_output = f\"[{','.join(string_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "一个优秀的数值模拟不仅应在数值上逼近真实解，更应尊重所模拟系统背后的基本物理或生物学定律，例如质量守恒或能量守恒。然而，标准的数值方法在长时间积分后，往往会因为累积误差而破坏这些“不变量”。本练习将带您探索一个重要的高级主题：几何数值积分。您将为一个经典的SIR流行病模型，在标准的龙格-库塔方法基础上，设计并实现一个投影校正步骤，以强制数值解在每一步都精确地保持总人口数守恒，从而显著提升模拟结果的长期定性准确性。",
            "id": "3205637",
            "problem": "考虑一个形式为 $\\mathbf{y}'(t) = \\mathbf{f}(t, \\mathbf{y}(t))$ 的常微分方程组（ODEs），其中 $\\mathbf{y}(t) \\in \\mathbb{R}^m$ 且 $\\mathbf{f} : \\mathbb{R} \\times \\mathbb{R}^m \\to \\mathbb{R}^m$ 是充分光滑的。一个线性不变量是形如 $\\mathbf{c}^\\top \\mathbf{y}(t)$ 的一个量，其中 $\\mathbf{c} \\in \\mathbb{R}^m$ 是一个固定向量，使得沿着精确解，$\\frac{d}{dt}(\\mathbf{c}^\\top \\mathbf{y}(t)) = 0$。易感-感染-康复（SIR）模型是一个著名的流行病学系统，其状态为 $\\mathbf{y}(t) = [S(t), I(t), R(t)]^\\top$，参数为 $\\beta  0$（感染率）和 $\\gamma  0$（恢复率），由以下常微分方程组控制：\n$$\n\\frac{dS}{dt} = -\\beta S I, \\quad \\frac{dI}{dt} = \\beta S I - \\gamma I, \\quad \\frac{dR}{dt} = \\gamma I,\n$$\n对于该系统，总人口 $S(t) + I(t) + R(t)$ 是精确守恒的，即对于所有 $t \\ge 0$，有 $S(t) + I(t) + R(t) = S(0) + I(0) + R(0)$。在这种情况下，不变量为 $\\mathbf{c}^\\top \\mathbf{y} = S + I + R$，其中 $\\mathbf{c} = [1, 1, 1]^\\top$。\n\n经典的四阶显式龙格-库塔方法（RK4）通过四次中间斜率的计算，将数值状态从 $\\mathbf{y}_n \\approx \\mathbf{y}(t_n)$ 推进到 $\\mathbf{y}_{n+1} \\approx \\mathbf{y}(t_{n+1})$。通常，像RK4这样的非辛显式方法在应用于非线性系统时，不保证能精确保持线性不变量，即使常微分方程的精确解确实保持了这些不变量。然而，在计算一个标准的RK4步长得到中间值 $\\mathbf{y}_{n+1}^\\ast$ 后，可以对 $\\mathbf{y}_{n+1}^\\ast$ 施加一个最小的修正，以在离散层面上精确地强制执行线性不变量 $\\mathbf{c}^\\top \\mathbf{y} = \\text{constant}$。\n\n你的任务是：\n- 为上述的SIR系统实现标准的RK4方法。\n- 推导并实现一个单标量修正，在每个RK4步之后应用，该修正在每个离散步长上精确地强制执行不变量 $\\mathbf{c}^\\top \\mathbf{y} = \\mathbf{c}^\\top \\mathbf{y}_0$（其中 $\\mathbf{c} = [1, 1, 1]^\\top$）。该修正应在欧几里得范数下最小化对 $\\mathbf{y}_{n+1}^\\ast$ 的改变，同时在每一步强制执行 $\\mathbf{c}^\\top \\mathbf{y}_{n+1} = \\mathbf{c}^\\top \\mathbf{y}_n$。\n- 对于下方的每个测试用例，在指定的时间区间内使用固定的时间步长，运行标准的RK4方法和不变量修正的RK4方法。对于每种方法和每个测试用例，报告由该方法计算的所有离散时间 $t_n$ 上，$S(t_n) + I(t_n) + R(t_n)$ 相对于初始值 $S(0) + I(0) + R(0)$ 的最大绝对偏差。由于变量 S、I 和 R 代表人口比例，它们是无量纲的；因此，所有报告的偏差必须是无量纲的实数。\n- 你的程序必须生成单行输出，包含所有测试用例的结果，并采用指定的顺序和格式。\n\n使用以下测试套件，表示为元组 $(\\beta, \\gamma, S_0, I_0, R_0, h, T)$，其中h是固定的时间步长，T是最终时间：\n1. 测试用例A（一般情况）：$(\\beta, \\gamma, S_0, I_0, R_0, h, T) = (0.3, 0.1, 0.99, 0.01, 0.0, 0.5, 100.0)$。\n2. 测试用例B（感染率为零的边界条件）：$(\\beta, \\gamma, S_0, I_0, R_0, h, T) = (0.0, 0.2, 0.6, 0.4, 0.0, 1.0, 50.0)$。\n3. 测试用例C（大时间步长压力测试）：$(\\beta, \\gamma, S_0, I_0, R_0, h, T) = (0.5, 0.1, 0.7, 0.3, 0.0, 5.0, 50.0)$。\n4. 测试用例D（无初始感染的边缘情况）：$(\\beta, \\gamma, S_0, I_0, R_0, h, T) = (0.3, 0.1, 1.0, 0.0, 0.0, 0.1, 40.0)$。\n\n对于每个测试用例，计算两个值：标准RK4方法的最大绝对不变量偏差和不变量修正RK4方法的最大绝对不变量偏差。你的程序应生成单行输出，其中包含这些结果，格式为方括号内以逗号分隔的列表，顺序如下：\n$$\n[\\text{A\\_RK4}, \\text{A\\_corr}, \\text{B\\_RK4}, \\text{B\\_corr}, \\text{C\\_RK4}, \\text{C\\_corr}, \\text{D\\_RK4}, \\text{D\\_corr}],\n$$\n其中每个条目都是一个浮点数。",
            "solution": "该问题要求实现和比较两种用于求解易感-感染-康复（SIR）模型的数值方案：标准的四阶龙格-库塔方法（RK4）和一种强制执行总人口守恒的修正RK4方法。目标是量化未修正方法偏离此守恒定律的程度，并与旨在精确保持该定律的修正方法进行对比。\n\n首先，我们定义SIR模型的常微分方程组（ODEs）。设状态向量为 $\\mathbf{y}(t) = [S(t), I(t), R(t)]^\\top$，分别表示易感、感染和康复人群的比例。其动力学由以下方程控制：\n$$\n\\frac{d}{dt}\\mathbf{y}(t) = \n\\begin{pmatrix} dS/dt \\\\ dI/dt \\\\ dR/dt \\end{pmatrix} = \n\\begin{pmatrix} -\\beta S I \\\\ \\beta S I - \\gamma I \\\\ \\gamma I \\end{pmatrix}\n= \\mathbf{f}(\\mathbf{y}(t))\n$$\n其中 $\\beta  0$ 是感染率，$\\gamma  0$ 是恢复率。\n\n该系统拥有一个线性不变量。各分量之和代表总人口，并且是守恒的。我们可以通过对各导数求和来验证这一点：\n$$\n\\frac{d}{dt}(S(t) + I(t) + R(t)) = \\frac{dS}{dt} + \\frac{dI}{dt} + \\frac{dR}{dt} = (-\\beta S I) + (\\beta S I - \\gamma I) + (\\gamma I) = 0\n$$\n这意味着对于所有时间 $t \\ge 0$，$S(t) + I(t) + R(t) = \\text{constant}$。该常数由初始条件确定：$S(t) + I(t) + R(t) = S(0) + I(0) + R(0)$。用向量表示法，这个不变量可以写成 $\\mathbf{c}^\\top \\mathbf{y}(t) = \\mathbf{c}^\\top \\mathbf{y}(0)$，其中 $\\mathbf{c} = [1, 1, 1]^\\top$。\n\n标准的四阶显式龙格-库塔（RK4）方法用于数值近似求解。给定时间 $t_n$ 的状态 $\\mathbf{y}_n$，时间 $t_{n+1} = t_n + h$ 的状态 $\\mathbf{y}_{n+1}$ 通过四个中间阶段计算得出：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1\\right) \\\\\n\\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2\\right) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h \\mathbf{k}_3)\n\\end{aligned}\n$$\n下一个状态，我们将其记为标准未修正步骤的 $\\mathbf{y}_{n+1}^\\ast$，由下式给出：\n$$\n\\mathbf{y}_{n+1}^\\ast = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n对于像SIR模型这样的非线性系统，该方法通常不保持线性不变量，即 $\\mathbf{c}^\\top \\mathbf{y}_{n+1}^\\ast \\neq \\mathbf{c}^\\top \\mathbf{y}_n$。误差的产生是因为函数 $\\mathbf{f}$ 在不一定满足不变量的中间点上进行求值。\n\n为了强制执行不变量，我们寻求对临时状态 $\\mathbf{y}_{n+1}^\\ast$ 的一个最小修正 $\\delta \\in \\mathbb{R}^3$，使得修正后的状态 $\\mathbf{y}_{n+1} = \\mathbf{y}_{n+1}^\\ast + \\delta$ 精确满足相对于初始总人口 $C_0 = \\mathbf{c}^\\top \\mathbf{y}_0$ 的不变量。问题是在约束条件 $\\mathbf{c}^\\top(\\mathbf{y}_{n+1}^\\ast + \\delta) = C_0$ 下，找到使欧几里得范数 $\\|\\delta\\|_2$ 最小化的 $\\delta$。这是一个约束优化问题。\n\n我们使用拉格朗日乘子法。目标是最小化 $\\frac{1}{2}\\|\\delta\\|_2^2 = \\frac{1}{2}\\delta^\\top\\delta$。拉格朗日函数为：\n$$\n\\mathcal{L}(\\delta, \\lambda) = \\frac{1}{2}\\delta^\\top\\delta + \\lambda \\left( \\mathbf{c}^\\top(\\mathbf{y}_{n+1}^\\ast + \\delta) - C_0 \\right)\n$$\n为求最小值，我们将关于 $\\delta$ 的梯度设为零：\n$$\n\\nabla_\\delta \\mathcal{L} = \\delta + \\lambda \\mathbf{c} = 0 \\implies \\delta = -\\lambda \\mathbf{c}\n$$\n最优修正 $\\delta$ 与向量 $\\mathbf{c}$ 成正比。我们通过将其代回约束方程来求解标量拉格朗日乘子 $\\lambda$：\n$$\n\\mathbf{c}^\\top(\\mathbf{y}_{n+1}^\\ast - \\lambda \\mathbf{c}) = C_0 \\implies \\mathbf{c}^\\top \\mathbf{y}_{n+1}^\\ast - \\lambda (\\mathbf{c}^\\top \\mathbf{c}) = C_0\n$$\n求解 $\\lambda$ 可得：\n$$\n\\lambda = \\frac{\\mathbf{c}^\\top \\mathbf{y}_{n+1}^\\ast - C_0}{\\mathbf{c}^\\top \\mathbf{c}}\n$$\n在我们的具体情况下，$\\mathbf{c} = [1, 1, 1]^\\top$，所以 $\\mathbf{c}^\\top \\mathbf{c} = 1^2 + 1^2 + 1^2 = 3$。初始不变量值为 $C_0 = S_0 + I_0 + R_0$。RK4步骤后的临时和为 $\\mathbf{c}^\\top \\mathbf{y}_{n+1}^\\ast = S_{n+1}^\\ast + I_{n+1}^\\ast + R_{n+1}^\\ast$。因此，标量 $\\lambda$ 为：\n$$\n\\lambda = \\frac{(S_{n+1}^\\ast + I_{n+1}^\\ast + R_{n+1}^\\ast) - (S_0 + I_0 + R_0)}{3}\n$$\n然后，按分量计算修正后的状态 $\\mathbf{y}_{n+1} = \\mathbf{y}_{n+1}^\\ast - \\lambda \\mathbf{c}$：\n$$\n\\begin{aligned}\nS_{n+1} = S_{n+1}^\\ast - \\lambda \\\\\nI_{n+1} = I_{n+1}^\\ast - \\lambda \\\\\nR_{n+1} = R_{n+1}^\\ast - \\lambda\n\\end{aligned}\n$$\n根据构造，$S_{n+1} + I_{n+1} + R_{n+1}$ 的和将精确等于 $S_0 + I_0 + R_0$，在浮点精度限制内。\n\n对于每个测试用例，我们在时间区间 $[0, T]$ 上使用固定的步长 $h$ 进行两次模拟。一次模拟使用标准的RK4方法，另一次使用修正的RK4方法。在每次模拟中，我们跟踪所有计算步长中不变量的最大绝对偏差 $\\max_n |(S_n + I_n + R_n) - (S_0 + I_0 + R_0)|$。\n\n需要特别关注测试用例 B 和 D。\n对于情况 B，其中 $\\beta=0$，SIR 系统变成一个线性常微分方程组。已知显式龙格-库塔方法能保持线性常微分方程组的线性不变量，因此，标准RK4方法的偏差预计接近机器精度。\n对于情况 D，其中 $I_0=0$，初始状态是该常微分方程组的一个平衡点。所有导数均为零，因此精确解是常数。RK4方法将精确地复现这一点，导致两种方法的偏差均为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares standard and invariant-corrected RK4 methods for the SIR model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (beta, gamma, S0, I0, R0, h, T)\n        (0.3, 0.1, 0.99, 0.01, 0.0, 0.5, 100.0),  # Case A\n        (0.0, 0.2, 0.6, 0.4, 0.0, 1.0, 50.0),   # Case B\n        (0.5, 0.1, 0.7, 0.3, 0.0, 5.0, 50.0),   # Case C\n        (0.3, 0.1, 1.0, 0.0, 0.0, 0.1, 40.0),    # Case D\n    ]\n\n    def sir_ode(y, beta, gamma):\n        \"\"\"\n        Defines the SIR system of ODEs.\n        y: state vector [S, I, R]\n        beta: infection rate\n        gamma: recovery rate\n        \"\"\"\n        S, I, R = y\n        dS_dt = -beta * S * I\n        dI_dt = beta * S * I - gamma * I\n        dR_dt = gamma * I\n        return np.array([dS_dt, dI_dt, dR_dt])\n\n    results = []\n    \n    for case in test_cases:\n        beta, gamma, S0, I0, R0, h, T = case\n        \n        y0 = np.array([S0, I0, R0])\n        inv_0 = np.sum(y0)\n        num_steps = int(round(T / h))\n\n        # 1. Standard RK4 Simulation\n        y_rk4 = np.copy(y0)\n        max_dev_rk4 = 0.0\n        for _ in range(num_steps):\n            k1 = sir_ode(y_rk4, beta, gamma)\n            k2 = sir_ode(y_rk4 + 0.5 * h * k1, beta, gamma)\n            k3 = sir_ode(y_rk4 + 0.5 * h * k2, beta, gamma)\n            k4 = sir_ode(y_rk4 + h * k3, beta, gamma)\n            y_rk4 += (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            \n            current_inv = np.sum(y_rk4)\n            max_dev_rk4 = max(max_dev_rk4, abs(current_inv - inv_0))\n        \n        results.append(max_dev_rk4)\n\n        # 2. Invariant-Corrected RK4 Simulation\n        y_corr = np.copy(y0)\n        max_dev_corr = 0.0\n        c = np.array([1.0, 1.0, 1.0])\n        c_dot_c = np.dot(c, c)\n        \n        for _ in range(num_steps):\n            k1 = sir_ode(y_corr, beta, gamma)\n            k2 = sir_ode(y_corr + 0.5 * h * k1, beta, gamma)\n            k3 = sir_ode(y_corr + 0.5 * h * k2, beta, gamma)\n            k4 = sir_ode(y_corr + h * k3, beta, gamma)\n            y_star = y_corr + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            \n            # Apply the minimal correction\n            inv_star = np.sum(y_star)\n            lambda_corr = (inv_star - inv_0) / c_dot_c\n            y_corr = y_star - lambda_corr * c\n\n            current_inv = np.sum(y_corr)\n            max_dev_corr = max(max_dev_corr, abs(current_inv - inv_0))\n            \n        results.append(max_dev_corr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在许多科学和工程应用中，我们会遇到所谓的“刚性”（stiff）微分方程组，其解的不同分量在时间尺度上存在巨大差异。对于这类问题，我们之前讨论的显式方法会面临严峻的稳定性挑战，迫使我们采用极小的步长，导致计算效率低下。本练习将引导您进入求解刚性问题的核心领域，通过实现一个隐式龙格-库塔方法来应对这一挑战。您将使用牛顿法求解每个时间步中产生的非线性代数方程组，这是处理刚性问题的标准高级技术，也是体验隐式方法强大功能与复杂内部机制的绝佳实践。",
            "id": "3205606",
            "problem": "您必须编写一个完整、可运行的程序，该程序使用牛顿法在每个时间步求解非线性阶段方程，以实现常微分方程组的隐式龙格-库塔方法。所要实现的方法必须支持 $s=2$ 阶或 $s=3$ 阶的 Radau IIA 格式。本任务的基础是常微分方程组初值问题的定义：给定一个连续可微函数 $f:\\mathbb{R}\\times \\mathbb{R}^m\\rightarrow \\mathbb{R}^m$ 和一个初始条件 $y(t_0)=y_0$，求解满足 $\\frac{dy}{dt}=f(t,y)$（对于 $t\\in [t_0,T]$）的 $y(t)$。隐式龙格-库塔方法由阶段变量定义，这些变量在每个步骤中满足一个非线性系统，该系统必须通过牛顿法，使用 $f$ 关于 $y$ 的雅可比矩阵来求解。您的实现必须为这些阶段构建并求解耦合的非线性代数系统，并将解更新到下一个时间层级。不需要步长自适应；请使用固定的步长。\n\n您必须使用以下给定的 Butcher 表（系数）作为 Radau IIA 方法的常数，这些方法是公认的，并在本问题中作为给定数据：\n\n1.  对于 $s=2$（三阶）：\n- $c=\\left[\\frac{1}{3},\\,1\\right]$,\n- $A=\\begin{bmatrix}\\frac{5}{12}  -\\frac{1}{12}\\\\ \\frac{3}{4}  \\frac{1}{4}\\end{bmatrix}$,\n- $b=\\left[\\frac{3}{4},\\,\\frac{1}{4}\\right]$。\n\n2.  对于 $s=3$（五阶），其中 $\\sqrt{6}$ 理解为主平方根：\n- $c=\\left[\\frac{4-\\sqrt{6}}{10},\\,\\frac{4+\\sqrt{6}}{10},\\,1\\right]$,\n- $A=\\begin{bmatrix}\n\\frac{11}{45}-\\frac{7\\sqrt{6}}{360}  \\frac{37}{225}-\\frac{169\\sqrt{6}}{1800}  -\\frac{2}{225}+\\frac{\\sqrt{6}}{75}\\\\\n\\frac{37}{225}+\\frac{169\\sqrt{6}}{1800}  \\frac{11}{45}+\\frac{7\\sqrt{6}}{360}  -\\frac{2}{225}-\\frac{\\sqrt{6}}{75}\\\\\n\\frac{4}{9}-\\frac{\\sqrt{6}}{36}  \\frac{4}{9}+\\frac{\\sqrt{6}}{36}  \\frac{1}{9}\n\\end{bmatrix}$,\n- $b=\\left[\\frac{4}{9}-\\frac{\\sqrt{6}}{36},\\,\\frac{4}{9}+\\frac{\\sqrt{6}}{36},\\,\\frac{1}{9}\\right]$。\n\n您的牛顿求解器必须：\n- 组装阶段残差的完整分块雅可比矩阵，其块的形式为 $\\delta_{ij}I - h\\,a_{ij}\\,J_i$，其中 $h$ 是步长，$a_{ij}$ 是 $A$ 的元素，$I$ 是 $m\\times m$ 单位矩阵，$J_i=\\partial f/\\partial y$ 是在第 $i$ 个阶段状态和阶段时间处计算的值。\n- 使用基于右端项的阶段变量的初始猜测，例如，对所有阶段重复使用 $f(t_n,y_n)$。\n- 迭代直到阶段修正量的无穷范数低于某个容差或达到最大迭代次数。\n- 可选地，如果完整的牛顿步没有减小残差，则应用简单的阻尼以增强鲁棒性。\n\n角度必须以弧度表示。\n\n实现您的求解器，并将其应用于以下测试套件。对于每个测试用例，按描述计算所需的输出量。所有输出必须是实数，并且您的程序必须将最终结果打印在单行中，格式如末尾所指定。\n\n测试套件：\n1. 标量刚性线性系统：\n- 问题：$y'(t)=\\lambda y(t)$，其中 $\\lambda=-15$，$y(0)=1$。\n- 使用固定步长 $h=0.25$ 和 $s=2$ 的 Radau IIA 方法，从 $t_0=0$ 积分到 $T=1$。\n- 输出量：$y(T)$ 的数值，作为浮点数。\n\n2. 谐振子系统：\n- 问题：$y_1'(t)=y_2(t)$，$y_2'(t)=-y_1(t)$，其中 $y_1(0)=1$，$y_2(0)=0$。\n- 使用固定步长 $h=\\frac{2\\pi}{200}$ 和 $s=3$ 的 Radau IIA 方法，从 $t_0=0$ 积分到 $T=2\\pi$。角度以弧度为单位。\n- 参考精确解：$y_1(T)=\\cos(T)$，$y_2(T)=-\\sin(T)$。\n- 输出量：在 $T$ 处的误差向量的欧几里得范数，即 $\\sqrt{(y_1(T)-\\cos(T))^2+(y_2(T)+\\sin(T))^2}$，作为浮点数。\n\n3. 中等刚性的非线性 Van der Pol 系统：\n- 问题：$y_1'(t)=y_2(t)$，$y_2'(t)=\\mu\\,(1-y_1(t)^2)\\,y_2(t)-y_1(t)$，其中 $\\mu=3$，$y_1(0)=2$，$y_2(0)=0$。\n- 使用固定步长 $h=0.05$ 和 $s=3$ 的 Radau IIA 方法，从 $t_0=0$ 积分到 $T=6$。\n- 输出量：$y_1(T)$ 的数值，作为浮点数。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，以逗号分隔列表形式并用方括号括起来，保留十位小数，例如，\"[0.1234567890,0.2222222222,1.0000000000]\"。不应打印任何其他文本。",
            "solution": "问题陈述经评估有效。它在数值分析领域内提供了一个定义明確、具有科学依据的任务。它是自洽的，提供了所有必要的数据、常数和测试用例。该问题要求实现一个隐式龙格-库塔 (IRK) 求解器，特别是针对 Radau IIA 方法族，并将其应用于一套测试问题。该实现必须使用牛顿法在每个时间步求解阶段值的非线性代数方程组。\n\n对于自治初值问题 $\\mathbf{y}'(t) = \\mathbf{f}(\\mathbf{y}(t))$, $\\mathbf{y}(t_0) = \\mathbf{y}_0$，一个 s 阶隐式龙格-库塔方法使用以下公式将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i \\mathbf{k}_i $$\n阶段导数 $\\mathbf{k}_i \\in \\mathbb{R}^m$ 由以下方程组定义：\n$$ \\mathbf{k}_i = \\mathbf{f}\\left(t_n + c_i h, \\mathbf{y}_n + h \\sum_{j=1}^{s} a_{ij} \\mathbf{k}_j\\right), \\quad i = 1, \\dots, s $$\n其中 $m$ 是系统的维度，$h$ 是步长，系数 $A = [a_{ij}]$、$b = [b_i]$ 和 $c = [c_i]$ 由方法的 Butcher 表给出。由于隐式方法的矩阵 $A$ 不是严格下三角矩阵，因此 $\\mathbf{k}_i$ 的方程是耦合的，通常形成一个包含 $s \\times m$ 个非线性代数方程的系统。\n\n这个系统必须在每个时间步求解未知的阶段导数 $\\mathbf{k}_1, \\dots, \\mathbf{k}_s$。为此，我们采用牛顿法。让我们定义一个包含所有阶段导数的向量 $\\mathbf{K} = [\\mathbf{k}_1^T, \\mathbf{k}_2^T, \\dots, \\mathbf{k}_s^T]^T \\in \\mathbb{R}^{sm}$。然后我们可以定义一个残差函数 $\\mathbf{G}: \\mathbb{R}^{sm} \\to \\mathbb{R}^{sm}$，其根是我们寻求的解：\n$$ G_i(\\mathbf{K}) = \\mathbf{k}_i - \\mathbf{f}\\left(t_n + c_i h, \\mathbf{y}_n + h \\sum_{j=1}^{s} a_{ij} \\mathbf{k}_j\\right) = 0, \\quad i = 1, \\dots, s $$\n牛顿法通过从一个初始猜测 $\\mathbf{K}^{(0)}$ 开始迭代来找到根。在每次迭代 $p$ 中，我们求解线性系统：\n$$ \\mathcal{J}_{\\mathbf{G}}(\\mathbf{K}^{(p)}) \\Delta\\mathbf{K}^{(p)} = -\\mathbf{G}(\\mathbf{K}^{(p)}) $$\n并更新解：\n$$ \\mathbf{K}^{(p+1)} = \\mathbf{K}^{(p)} + \\Delta\\mathbf{K}^{(p)} $$\n矩阵 $\\mathcal{J}_{\\mathbf{G}}$ 是残差函数 $\\mathbf{G}$ 关于 $\\mathbf{K}$ 的雅可比矩阵。它是一个 $s \\times s$ 的分块矩阵，其中每个分块 $(i, j)$ 是一个由 $\\frac{\\partial G_i}{\\partial \\mathbf{k}_j}$ 给出的 $m \\times m$ 矩阵。使用链式法则：\n$$ \\frac{\\partial G_i}{\\partial \\mathbf{k}_j} = \\frac{\\partial \\mathbf{k}_i}{\\partial \\mathbf{k}_j} - \\frac{\\partial}{\\partial \\mathbf{k}_j} \\mathbf{f}\\left(t_n + c_i h, \\mathbf{y}_n + h \\sum_{l=1}^{s} a_{il} \\mathbf{k}_l\\right) $$\n$$ \\frac{\\partial G_i}{\\partial \\mathbf{k}_j} = \\delta_{ij}I_m - \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}\\bigg|_{Y_i} \\cdot \\frac{\\partial}{\\partial \\mathbf{k}_j}\\left(\\mathbf{y}_n + h \\sum_{l=1}^{s} a_{il} \\mathbf{k}_l\\right) $$\n其中 $Y_i = \\mathbf{y}_n + h \\sum_{l=1}^{s} a_{il} \\mathbf{k}_l$ 是第 $i$ 个阶段值，$I_m$ 是 $m \\times m$ 单位矩阵，$\\delta_{ij}$ 是克罗内克δ。令 $J_i = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}|_{Y_i}$ 为在第 $i$ 个阶段处计算的 $\\mathbf{f}$ 的雅可比矩阵。表达式简化为：\n$$ \\left(\\mathcal{J}_{\\mathbf{G}}\\right)_{ij} = \\delta_{ij}I_m - h a_{ij} J_i $$\n这个公式精确匹配问题陈述中指定的雅可比矩阵结构。单个时间步的算法如下：\n1. 给定在时间 $t_n$ 处的 $\\mathbf{y}_n$。使用步长 $h$。\n2. 为阶段导数提供一个初始猜测。如建议所示，我们使用 $\\mathbf{K}^{(0)}$，其中每个 $\\mathbf{k}_i^{(0)} = \\mathbf{f}(t_n, \\mathbf{y}_n)$。\n3. 开始牛顿迭代循环（对于 $p = 0, 1, 2, \\dots$）：\n    a. 计算所有阶段值 $Y_i^{(p)} = \\mathbf{y}_n + h \\sum_{j=1}^{s} a_{ij} \\mathbf{k}_j^{(p)}$。\n    b. 计算函数导数 $\\mathbf{f}(t_n+c_ih, Y_i^{(p)})$ 及其雅可比矩阵 $J_i = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}|_{Y_i^{(p)}}$。\n    c. 形成残差向量 $\\mathbf{G}(\\mathbf{K}^{(p)})$。\n    d. 组装牛顿矩阵 $\\mathcal{J}_{\\mathbf{G}}(\\mathbf{K}^{(p)})$。\n    e. 求解 $sm \\times sm$ 线性系统 $\\mathcal{J}_{\\mathbf{G}} \\Delta\\mathbf{K} = -\\mathbf{G}$ 以获得修正量 $\\Delta\\mathbf{K}$。\n    f. 更新阶段导数：$\\mathbf{K}^{(p+1)} = \\mathbf{K}^{(p)} + \\Delta\\mathbf{K}$。\n    g. 检查收敛性。如果 $||\\Delta\\mathbf{K}||_{\\infty}$ 低于指定的容差（例如 $10^{-12}$）或达到最大迭代次数（例如 $10$），则迭代停止。\n4. 一旦找到收敛的阶段导数 $\\mathbf{k}_i$，计算下一个时间步的解：$\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i \\mathbf{k}_i$。\n5. 设置 $t_{n+1} = t_n + h$ 并进行下一步。\n\n该实现将应用此算法到三个测试用例，使用指定的 Radau IIA 系数。对于线性问题（测试用例 1 和 2），$\\mathbf{f}$ 的雅可比矩阵是常数，使得牛顿系统是线性的。因此，一次迭代即可达到收敛。对于非线性 Van der Pol 系统（测试用例 3），雅可比矩阵是状态依赖的，需要真正的迭代求解。\n\n**测试用例 1：标量刚性线性系统**\n问题是 $y'(t) = \\lambda y(t)$，其中 $\\lambda = -15$ 和 $y(0) = 1$。我们使用 $s=2$ 的 Radau IIA 方法，以 $h=0.25$ 从 $t_0=0$ 积分到 $T=1$。ODE 是 1 维的（$m=1$）。雅可比矩阵就是常数 $J=\\lambda=-15$。牛顿系统是一个 $2 \\times 2$ 的线性系统。\n\n**测试用例 2：谐振子**\n系统是 $y_1'(t) = y_2(t)$，$y_2'(t) = -y_1(t)$，其中 $\\mathbf{y}(0) = [1, 0]^T$。我们使用 $s=3$ 的 Radau IIA 方法，以 $h=2\\pi/200$ 从 $t_0=0$ 积分到 $T=2\\pi$。这是一个 2 维系统（$m=2$）。$\\mathbf{f}(\\mathbf{y}) = [y_2, -y_1]^T$ 的雅可比矩阵是常数矩阵 $J = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$。牛顿系统是一个 $6 \\times 6$ 的线性系统。在 $t=T$ 处，根据精确解 $\\mathbf{y}(t) = [\\cos(t), -\\sin(t)]^T$ 计算误差。\n\n**测试用例 3：非线性 Van der Pol 系统**\n系统是 $y_1'(t) = y_2(t)$，$y_2'(t) = \\mu(1-y_1(t)^2)y_2(t) - y_1(t)$，其中 $\\mu=3$ 和 $\\mathbf{y}(0)=[2, 0]^T$。我们使用 $s=3$ 的 Radau IIA 方法，以 $h=0.05$ 从 $t_0=0$ 积分到 $T=6$。这是一个 2 维系统（$m=2$）。雅可比矩阵是状态依赖的：$J(\\mathbf{y}) = \\begin{bmatrix} 0  1 \\\\ -2\\mu y_1 y_2 - 1  \\mu(1-y_1^2) \\end{bmatrix}$。牛顿求解器将在 120 个时间步中的每一步进行迭代，以找到阶段导数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef radau_solver(f, Df, t_span, y0, h, butcher_tableau):\n    \"\"\"\n    Implicit Runge-Kutta solver for systems of ODEs y' = f(t, y)\n    using Radau IIA methods and Newton's method for stage equations.\n    \"\"\"\n    A, b, c = butcher_tableau['A'], butcher_tableau['b'], butcher_tableau['c']\n    s = len(c)\n    m = len(y0)\n    \n    t0, T = t_span\n    t = t0\n    y = y0.copy()\n    \n    # Use a small tolerance for floating point comparisons\n    TOL = 1e-9\n    num_steps = int(round((T - t0) / h))\n    \n    # Newton's method parameters\n    NEWTON_TOL = 1e-12\n    MAX_ITER = 10\n\n    for step_idx in range(num_steps):\n        # Ensure the last step lands exactly on T\n        if abs(t + h - T)  TOL and abs(h) > TOL:\n            h = T - t\n        elif t + h > T: # If overshooting due to accumulated error, also correct\n            h = T - t\n\n        # Newton's method to find stage derivatives k_i\n        # Let K be the flattened vector [k1, k2, ..., ks]\n        \n        # Initial guess for stage derivatives K\n        f_eval_y0 = f(t, y)\n        K = np.tile(f_eval_y0, s)\n\n        for _ in range(MAX_ITER):\n            # Calculate stage values Y_i and Jacobians J_i\n            Y_stages = np.zeros((s, m))\n            J_stages = np.zeros((s, m, m))\n            f_eval_stages = np.zeros((s, m))\n\n            for i in range(s):\n                sum_a_k = np.zeros(m)\n                for j in range(s):\n                    k_j = K[j*m:(j+1)*m]\n                    sum_a_k += A[i, j] * k_j\n                \n                Y_i = y + h * sum_a_k\n                Y_stages[i, :] = Y_i\n                J_stages[i, :, :] = Df(t + c[i]*h, Y_i)\n                f_eval_stages[i, :] = f(t + c[i]*h, Y_i)\n\n            # Form residual G(K) = K - F(K)\n            G = K - f_eval_stages.flatten()\n\n            # Form Newton matrix (Jacobian of G)\n            # Block (i,j) is delta_ij*I - h*a_ij*J_i\n            newton_matrix = np.zeros((s*m, s*m))\n            I_m = np.identity(m)\n            for i in range(s):\n                for j in range(s):\n                    block = -h * A[i, j] * J_stages[i, :, :]\n                    if i == j:\n                        block += I_m\n                    newton_matrix[i*m:(i+1)*m, j*m:(j+1)*m] = block\n            \n            # Solve for update dK\n            try:\n                dK = np.linalg.solve(newton_matrix, -G)\n            except np.linalg.LinAlgError:\n                # In case of singular matrix, break and hope for the best\n                dK = np.zeros_like(K)\n\n            # Update K and check for convergence\n            K += dK\n            if np.linalg.norm(dK, ord=np.inf)  NEWTON_TOL:\n                break\n        \n        # Update solution y\n        y_update = np.zeros(m)\n        for i in range(s):\n            k_i = K[i*m:(i+1)*m]\n            y_update += b[i] * k_i\n        \n        y += h * y_update\n        t += h\n\n    return y\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases.\n    \"\"\"\n    # Radau IIA s=2 Butcher Tableau\n    s2_A = np.array([[5/12, -1/12], [3/4, 1/4]])\n    s2_b = np.array([3/4, 1/4])\n    s2_c = np.array([1/3, 1])\n    radau_s2 = {'A': s2_A, 'b': s2_b, 'c': s2_c}\n\n    # Radau IIA s=3 Butcher Tableau\n    s6 = np.sqrt(6)\n    s3_A = np.array([\n        [11/45 - 7*s6/360, 37/225 - 169*s6/1800, -2/225 + s6/75],\n        [37/225 + 169*s6/1800, 11/45 + 7*s6/360, -2/225 - s6/75],\n        [4/9 - s6/36, 4/9 + s6/36, 1/9]\n    ])\n    s3_b = np.array([4/9 - s6/36, 4/9 + s6/36, 1/9])\n    s3_c = np.array([(4 - s6)/10, (4 + s6)/10, 1])\n    radau_s3 = {'A': s3_A, 'b': s3_b, 'c': s3_c}\n    \n    results = []\n\n    # --- Test Case 1: Scalar stiff linear system ---\n    lam = -15.0\n    f1 = lambda t, y: lam * y\n    Df1 = lambda t, y: np.array([[lam]])\n    y0_1 = np.array([1.0])\n    t_span_1 = (0.0, 1.0)\n    h1 = 0.25\n    y_final_1 = radau_solver(f1, Df1, t_span_1, y0_1, h1, radau_s2)\n    results.append(y_final_1[0])\n\n    # --- Test Case 2: Harmonic oscillator system ---\n    f2 = lambda t, y: np.array([y[1], -y[0]])\n    Df2 = lambda t, y: np.array([[0.0, 1.0], [-1.0, 0.0]])\n    y0_2 = np.array([1.0, 0.0])\n    T2 = 2 * np.pi\n    h2 = T2 / 200.0\n    t_span_2 = (0.0, T2)\n    y_final_2 = radau_solver(f2, Df2, t_span_2, y0_2, h2, radau_s3)\n    y_exact_2 = np.array([np.cos(T2), -np.sin(T2)])\n    error_2 = np.linalg.norm(y_final_2 - y_exact_2)\n    results.append(error_2)\n\n    # --- Test Case 3: Nonlinear Van der Pol system ---\n    mu = 3.0\n    def f3(t, y):\n        return np.array([y[1], mu * (1 - y[0]**2) * y[1] - y[0]])\n    def Df3(t, y):\n        return np.array([\n            [0.0, 1.0],\n            [-2.0 * mu * y[0] * y[1] - 1.0, mu * (1.0 - y[0]**2)]\n        ])\n    y0_3 = np.array([2.0, 0.0])\n    t_span_3 = (0.0, 6.0)\n    h3 = 0.05\n    y_final_3 = radau_solver(f3, Df3, t_span_3, y0_3, h3, radau_s3)\n    results.append(y_final_3[0])\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]:.10f},{results[1]:.10f},{results[2]:.10f}]\")\n\nsolve()\n```"
        }
    ]
}