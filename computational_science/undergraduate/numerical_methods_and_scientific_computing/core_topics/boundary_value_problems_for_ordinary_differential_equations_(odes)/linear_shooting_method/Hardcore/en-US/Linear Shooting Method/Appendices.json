{
    "hands_on_practices": [
        {
            "introduction": "Before diving into numerical algorithms, it's crucial to understand the theoretical backbone of the linear shooting method: the principle of superposition. This exercise challenges you to apply this principle to analytically determine the precise initial slope needed to solve a boundary value problem, without resorting to numerical integration. By working through this problem , you will see how linearity allows us to transform a boundary value problem into a simple algebraic one for the unknown initial condition.",
            "id": "3248440",
            "problem": "Consider the boundary value problem for the linear ordinary differential equation (ODE)\n$$\ny''(x) + \\frac{1}{x}\\,y'(x) = 0,\\quad x \\in [1, L],\n$$\nwith boundary conditions\n$$\ny(1)=A,\\quad y(L)=B,\n$$\nwhere $L1$ and $A,B \\in \\mathbb{R}$. Starting only from the linearity of the ODE operator and the uniqueness of solutions to initial value problems (IVPs) with continuous coefficients, apply the linear shooting method to determine the unique initial slope $s = y'(1)$ that produces a solution satisfying the boundary condition at $x=L$. Derive $s$ explicitly in closed form in terms of $A$, $B$, and $L$. Your final answer must be a single closed-form expression. Do not provide a numerical approximation.",
            "solution": "The user-provided problem has been validated and is determined to be a valid, well-posed mathematical problem.\n\nThe problem asks for the determination of the initial slope $s = y'(1)$ for the boundary value problem (BVP)\n$$\ny''(x) + \\frac{1}{x}\\,y'(x) = 0,\\quad x \\in [1, L]\n$$\nwith boundary conditions\n$$\ny(1)=A,\\quad y(L)=B\n$$\nusing the linear shooting method. The derivation is to be based on the principles of linearity and uniqueness of solutions to initial value problems (IVPs).\n\nThe linear shooting method transforms the BVP into an IVP by guessing the initial slope $s=y'(1)$. We then solve the IVP and adjust the value of $s$ until the solution satisfies the boundary condition at $x=L$. For a linear ODE, this adjustment can be done analytically without iteration.\n\nLet us define the linear differential operator $L$ as\n$$\nL[y] = y''(x) + \\frac{1}{x}\\,y'(x)\n$$\nThe BVP can be written as $L[y] = 0$ with $y(1)=A$ and $y(L)=B$. The coefficients of the ODE are continuous on the interval $[1, L]$ since $L1$.\n\nWe consider the related IVP where the initial slope $s$ is a parameter:\n$$\nL[y] = 0, \\quad y(1) = A, \\quad y'(1) = s\n$$\nLet the unique solution to this IVP be denoted by $y(x; s)$. Our goal is to find the value of $s$ for which $y(L; s) = B$.\n\nThe core of the linear shooting method lies in the principle of superposition, which applies because the operator $L$ is linear. We can express the solution $y(x; s)$ as a linear combination of solutions to two simpler, fundamental IVPs.\n\nLet $y_1(x)$ be the solution to the IVP:\n$$\nL[y_1] = 0, \\quad y_1(1) = 1, \\quad y_1'(1) = 0\n$$\nAnd let $y_2(x)$ be the solution to the IVP:\n$$\nL[y_2] = 0, \\quad y_2(1) = 0, \\quad y_2'(1) = 1\n$$\nThe existence and uniqueness of $y_1(x)$ and $y_2(x)$ on $[1, L]$ are guaranteed by the Picard-Lindelöf theorem, as the ODE coefficients are continuous on this interval.\n\nNow, consider the function $Y(x) = A y_1(x) + s y_2(x)$.\nBy linearity of $L$:\n$$\nL[Y] = L[A y_1(x) + s y_2(x)] = A L[y_1(x)] + s L[y_2(x)] = A \\cdot 0 + s \\cdot 0 = 0\n$$\nThe initial conditions for $Y(x)$ at $x=1$ are:\n$$\nY(1) = A y_1(1) + s y_2(1) = A \\cdot 1 + s \\cdot 0 = A\n$$\n$$\nY'(1) = A y_1'(1) + s y_2'(1) = A \\cdot 0 + s \\cdot 1 = s\n$$\nThus, $Y(x)$ solves the same IVP as $y(x; s)$. By the uniqueness of solutions to IVPs, we must have $y(x; s) = Y(x) = A y_1(x) + s y_2(x)$.\n\nWe now impose the second boundary condition, $y(L; s) = B$, on this solution:\n$$\ny(L; s) = A y_1(L) + s y_2(L) = B\n$$\nThis is a linear algebraic equation for the unknown slope $s$. Solving for $s$, we get:\n$$\ns y_2(L) = B - A y_1(L)\n$$\nAssuming $y_2(L) \\neq 0$, we find\n$$\ns = \\frac{B - A y_1(L)}{y_2(L)}\n$$\nTo obtain an explicit closed-form expression for $s$, we must find the analytical forms of $y_1(x)$ and $y_2(x)$. The given ODE is $y'' + \\frac{1}{x}y' = 0$. This equation can be recognized as the product rule derivative:\n$$\n\\frac{d}{dx}\\left(x y'(x)\\right) = 1 \\cdot y'(x) + x \\cdot y''(x) = x \\left( y'' + \\frac{1}{x} y' \\right) = 0\n$$\nIntegrating $\\frac{d}{dx}(x y') = 0$ with respect to $x$ gives:\n$$\nx y'(x) = C_1\n$$\nwhere $C_1$ is a constant of integration. Dividing by $x$ (which is permissible as $x \\ge 1$), we have:\n$$\ny'(x) = \\frac{C_1}{x}\n$$\nIntegrating again with respect to $x$ yields the general solution:\n$$\ny(x) = \\int \\frac{C_1}{x} dx = C_1 \\ln(x) + C_2\n$$\n\nNow we apply the initial conditions for $y_1(x)$ and $y_2(x)$ to this general solution.\n\nFor $y_1(x)$:\nThe general form is $y_1(x) = C_1 \\ln(x) + C_2$.\nThe condition $y_1(1) = 1$ implies $C_1 \\ln(1) + C_2 = 1$, which gives $C_2 = 1$.\nThe derivative is $y_1'(x) = \\frac{C_1}{x}$. The condition $y_1'(1) = 0$ implies $\\frac{C_1}{1} = 0$, so $C_1=0$.\nThus, the solution is $y_1(x) = 1$.\n\nFor $y_2(x)$:\nThe general form is $y_2(x) = D_1 \\ln(x) + D_2$.\nThe condition $y_2(1) = 0$ implies $D_1 \\ln(1) + D_2 = 0$, which gives $D_2 = 0$.\nThe derivative is $y_2'(x) = \\frac{D_1}{x}$. The condition $y_2'(1) = 1$ implies $\\frac{D_1}{1} = 1$, so $D_1=1$.\nThus, the solution is $y_2(x) = \\ln(x)$.\n\nNow we evaluate these solutions at $x=L$:\n$$\ny_1(L) = 1\n$$\n$$\ny_2(L) = \\ln(L)\n$$\nSince $L1$, we have $\\ln(L)  0$, so $y_2(L) \\neq 0$, and the expression for $s$ is well-defined.\n\nSubstituting these values into the formula for $s$:\n$$\ns = \\frac{B - A \\cdot y_1(L)}{y_2(L)} = \\frac{B - A \\cdot 1}{\\ln(L)}\n$$\n$$\ns = \\frac{B - A}{\\ln(L)}\n$$\nThis is the required closed-form expression for the initial slope $s$.",
            "answer": "$$\n\\boxed{\\frac{B-A}{\\ln(L)}}\n$$"
        },
        {
            "introduction": "Many problems in physics and engineering are naturally posed on semi-infinite domains, presenting a unique challenge for numerical methods that require finite boundaries. This practice guides you through implementing a shooting method to solve such a problem by truncating the domain and applying an appropriate boundary condition at a large, finite distance. This exercise  will develop your skills in approximating complex boundary conditions and implementing robust numerical integrators like the fourth-order Runge-Kutta method.",
            "id": "3248457",
            "problem": "Implement a program that uses the linear shooting method to approximate solutions of linear, second-order Ordinary Differential Equations (ODEs) posed as Boundary Value Problems (BVPs) on a semi-infinite domain. The fundamental base consists of the definition of a linear, second-order ODE and the superposition principle for linear systems: any linear combination of solutions to the homogeneous equation is also a solution, and a general solution can be constructed by adding a particular solution of the nonhomogeneous problem. The target BVPs are of the form\n$$\ny''(x) + p(x)\\,y'(x) + q(x)\\,y(x) = r(x), \\quad x \\in [a,\\infty),\n$$\nwith boundary conditions\n$$\ny(a) = \\alpha, \\quad \\lim_{x\\to\\infty} y(x) = 0.\n$$\nTo handle the boundary at infinity, approximate the semi-infinite domain by truncating at a large finite point $L$ and enforce either a Dirichlet condition $y(L)=0$ or an asymptotically motivated Robin condition $y'(L) + \\kappa\\,y(L) = 0$ with a suitable positive constant $\\kappa$ derived from the limiting behavior of the coefficients as $x\\to\\infty$ when applicable.\n\nYou must derive from first principles why the linear shooting method applies to this class of problems and how it exploits linear superposition to avoid nonlinear root-finding. Then, implement the method as follows:\n- Reformulate the second-order ODE as a first-order system for $y$ and $v=y'$.\n- Use the superposition principle to build the solution as a sum of a particular solution and a homogeneous solution scaled by a constant chosen to satisfy the boundary condition at $x=L$.\n- Integrate the Initial Value Problems (IVPs) using the classical fourth-order Runge–Kutta method with a fixed stepsize $h$.\n\nYour program must handle a linear functional boundary condition at $x=L$ of the form\n$$\nc_1\\,y(L) + c_2\\,y'(L) = \\gamma,\n$$\nwhere $c_1$, $c_2$, and $\\gamma$ are given constants. For a Robin condition approximating decay with rate $\\kappa$, use $c_1=\\kappa$, $c_2=1$, and $\\gamma=0$. For a Dirichlet truncation, use $c_1=1$, $c_2=0$, and $\\gamma=0$.\n\nCompute the approximate value of $y(x^\\star)$ for each test case below. Use the same fixed stepsize $h$ on $[a,L]$ and choose $h$ so that both $L$ and $x^\\star$ lie on the computational grid. Use the Linear Shooting Method (LSM) with one particular IVP and one homogeneous IVP, and the classical fourth-order Runge–Kutta (RK4) integrator for the IVPs.\n\nTest suite:\n- Case $1$ (constant coefficients, Robin approximation):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=0$, $q(x)=-1$, $r(x)=0$,\n  - boundary at $L$: $y'(L)+\\kappa y(L)=0$ with $\\kappa=1$.\n- Case $2$ (faster decay, Robin approximation):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=0$, $q(x)=-4$, $r(x)=0$,\n  - boundary at $L$: $y'(L)+\\kappa y(L)=0$ with $\\kappa=2$.\n- Case $3$ (variable coefficients, Robin approximation):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=\\dfrac{2}{1+x}$, $q(x)=-1$, $r(x)=0$,\n  - boundary at $L$: $y'(L)+\\kappa y(L)=0$ with $\\kappa=1$.\n- Case $4$ (Dirichlet truncation at $L$):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=0$, $q(x)=-1$, $r(x)=0$,\n  - boundary at $L$: $y(L)=0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, print\n$[y_1,y_2,y_3,y_4]$,\nwhere $y_k$ is the numerical approximation of $y(x^\\star)$ for test case $k$, in this order.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and complete. It presents a standard numerical task—solving a linear second-order boundary value problem (BVP) on a semi-infinite domain using the linear shooting method with a fourth-order Runge-Kutta integrator. All parameters and functions are clearly defined, and the domain truncation approach is a valid and common technique in numerical analysis. The problem is therefore deemed **valid**.\n\nThe theoretical basis for the linear shooting method rests on the superposition principle for linear ordinary differential equations (ODEs). We are tasked with solving the BVP:\n$$\ny''(x) + p(x) y'(x) + q(x) y(x) = r(x), \\quad x \\in [a, \\infty)\n$$\nsubject to the boundary conditions:\n$$\ny(a) = \\alpha, \\quad \\lim_{x\\to\\infty} y(x) = 0\n$$\nThe problem on the semi-infinite domain $[a, \\infty)$ is approximated by truncating the domain at a sufficiently large value $x=L$ and imposing an approximate boundary condition at this point. The BVP is thus transformed into:\n$$\ny''(x) + p(x) y'(x) + q(x) y(x) = r(x), \\quad x \\in [a, L]\n$$\n$$\ny(a) = \\alpha\n$$\n$$\nc_1 y(L) + c_2 y'(L) = \\gamma\n$$\nwhere the constants $c_1$, $c_2$, and $\\gamma$ define the condition at the truncated boundary $x=L$.\n\nThe linear shooting method recasts this BVP as a pair of initial value problems (IVPs). This is possible due to the linearity of the governing ODE. The superposition principle states that if $y_1(x)$ and $y_2(x)$ are solutions to a linear homogeneous ODE, then any linear combination $C_1 y_1(x) + C_2 y_2(x)$ is also a solution. Furthermore, the general solution to a non-homogeneous linear ODE is the sum of any particular solution to the non-homogeneous equation and the general solution to the corresponding homogeneous equation.\n\nWe construct the solution $y(x)$ to the BVP as a linear combination of the solutions of two specific IVPs. Let $y_1(x)$ be the solution to the non-homogeneous ODE subject to the first boundary condition and a convenient, arbitrary condition on its derivative. A standard choice is:\n$$\n\\text{IVP 1:} \\quad y_1''(x) + p(x) y_1'(x) + q(x) y_1(x) = r(x), \\quad \\text{with} \\quad y_1(a) = \\alpha, \\quad y_1'(a) = 0\n$$\nLet $y_2(x)$ be the solution to the corresponding homogeneous ODE, with initial conditions chosen to ensure it is linearly independent from any trivial solution and does not interfere with the $y(a)=\\alpha$ condition. A standard choice is:\n$$\n\\text{IVP 2:} \\quad y_2''(x) + p(x) y_2'(x) + q(x) y_2(x) = 0, \\quad \\text{with} \\quad y_2(a) = 0, \\quad y_2'(a) = 1\n$$\nNow, we propose a solution to the BVP of the form:\n$$\ny(x) = y_1(x) + C y_2(x)\n$$\nwhere $C$ is a constant to be determined. Let us verify that this form satisfies the ODE and the boundary conditions.\nFirst, substituting $y(x)$ into the ODE:\n$$\ny'' + p y' + q y = (y_1'' + C y_2'') + p (y_1' + C y_2') + q (y_1 + C y_2)\n$$\n$$\n= (y_1'' + p y_1' + q y_1) + C (y_2'' + p y_2' + q y_2)\n$$\n$$\n= r(x) + C \\cdot 0 = r(x)\n$$\nThus, $y(x)$ is a solution to the non-homogeneous ODE for any value of $C$.\n\nSecond, we check the boundary condition at $x=a$:\n$$\ny(a) = y_1(a) + C y_2(a) = \\alpha + C \\cdot 0 = \\alpha\n$$\nThis condition is satisfied for any value of $C$. The choice of initial conditions for the two IVPs guarantees this outcome.\n\nFinally, the constant $C$ is determined by enforcing the second boundary condition at $x=L$:\n$$\nc_1 y(L) + c_2 y'(L) = \\gamma\n$$\nSubstituting $y(L) = y_1(L) + C y_2(L)$ and $y'(L) = y_1'(L) + C y_2'(L)$:\n$$\nc_1 (y_1(L) + C y_2(L)) + c_2 (y_1'(L) + C y_2'(L)) = \\gamma\n$$\nThis is a linear algebraic equation for $C$. Rearranging the terms to solve for $C$:\n$$\nc_1 y_1(L) + c_2 y_1'(L) + C (c_1 y_2(L) + c_2 y_2'(L)) = \\gamma\n$$\n$$\nC = \\frac{\\gamma - c_1 y_1(L) - c_2 y_1'(L)}{c_1 y_2(L) + c_2 y_2'(L)}\n$$\nThis determines the unique value of $C$ that ensures the solution $y(x)$ satisfies the boundary condition at $x=L$, provided the denominator is non-zero. A zero denominator would imply that the homogeneous BVP has a non-trivial solution, indicating that the original BVP may not have a unique solution.\n\nFor numerical implementation, each second-order ODE is converted into a system of two first-order ODEs. Let $\\mathbf{u}(x) = [y(x), y'(x)]^T = [u_1(x), u_2(x)]^T$. The second-order ODE becomes:\n$$\n\\frac{d\\mathbf{u}}{dx} = \\begin{pmatrix} u_1' \\\\ u_2' \\end{pmatrix} = \\begin{pmatrix} u_2 \\\\ r(x) - p(x)u_2 - q(x)u_1 \\end{pmatrix} = \\mathbf{f}(x, \\mathbf{u})\n$$\nThe two IVPs are solved numerically from $x=a$ to $x=L$ using the classical fourth-order Runge-Kutta (RK4) method. For a step size $h$, the update rule from $x_i$ to $x_{i+1} = x_i + h$ for a generic system $\\mathbf{u}' = \\mathbf{f}(x, \\mathbf{u})$ is:\n$$\n\\mathbf{u}_{i+1} = \\mathbf{u}_i + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere\n$$\n\\mathbf{k}_1 = \\mathbf{f}(x_i, \\mathbf{u}_i), \\quad \\mathbf{k}_2 = \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + h/2 \\cdot \\mathbf{k}_1), \\quad \\mathbf{k}_3 = \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + h/2 \\cdot \\mathbf{k}_2), \\quad \\mathbf{k}_4 = \\mathbf{f}(x_i + h, \\mathbf{u}_i + h \\cdot \\mathbf{k}_3)\n$$\nThe algorithm proceeds as follows:\n1.  Define the IVPs for $y_1$ and $y_2$ as first-order systems. For $y_1$, the system is $\\mathbf{u}_1' = [u_{1,2}, r - p u_{1,2} - q u_{1,1}]^T$ with $\\mathbf{u}_1(a) = [\\alpha, 0]^T$. For $y_2$, the system is $\\mathbf{u}_2' = [u_{2,2}, -p u_{2,2} - q u_{2,1}]^T$ with $\\mathbf{u}_2(a) = [0, 1]^T$.\n2.  Integrate both systems from $x=a$ to $x=L$ using the RK4 method. This yields the numerical approximations for $\\{y_1(L), y_1'(L)\\}$ and $\\{y_2(L), y_2'(L)\\}$. During integration, the values $y_1(x^\\star)$ and $y_2(x^\\star)$ are also stored.\n3.  Calculate the constant $C$ using the derived formula and the numerical values from step 2.\n4.  Compute the final approximate solution at $x=x^\\star$ via superposition: $y(x^\\star) \\approx y_1(x^\\star) + C y_2(x^\\star)$.\n\nThis procedure is applied to each test case specified in the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the linear shooting method to solve a set of BVPs\n    and prints the results in the specified format.\n    \"\"\"\n\n    def linear_shooting(p_func, q_func, r_func, a, L, h, alpha, c1, c2, gamma, x_star):\n        \"\"\"\n        Solves a linear second-order BVP using the linear shooting method with RK4.\n\n        The method solves two IVPs:\n        1. y1'' + p*y1' + q*y1 = r,  with y1(a) = alpha, y1'(a) = 0\n        2. y2'' + p*y2' + q*y2 = 0,  with y2(a) = 0,     y2'(a) = 1\n\n        The solution is y = y1 + C*y2, where C is chosen to satisfy the BC at L.\n        \"\"\"\n        \n        N = int(round((L - a) / h))\n        x_grid = np.linspace(a, L, N + 1)\n        x_star_idx = int(round((x_star - a) / h))\n\n        def rk4_step(f, x, u, h_step):\n            k1 = f(x, u)\n            k2 = f(x + h_step / 2.0, u + (h_step / 2.0) * k1)\n            k3 = f(x + h_step / 2.0, u + (h_step / 2.0) * k2)\n            k4 = f(x + h_step, u + h_step * k3)\n            return u + (h_step / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n        # System for IVP 1 (non-homogeneous)\n        def f1(x, u):\n            y, v = u\n            return np.array([v, r_func(x) - p_func(x) * v - q_func(x) * y])\n\n        # System for IVP 2 (homogeneous)\n        def f2(x, u):\n            y, v = u\n            return np.array([v, -p_func(x) * v - q_func(x) * y])\n\n        # Initial conditions\n        u1 = np.array([alpha, 0.0])  # [y1(a), y1'(a)]\n        u2 = np.array([0.0, 1.0])    # [y2(a), y2'(a)]\n\n        y1_at_x_star = 0.0\n        y2_at_x_star = 0.0\n\n        # Integrate both IVPs from a to L\n        for i in range(N):\n            if i == x_star_idx:\n                y1_at_x_star = u1[0]\n                y2_at_x_star = u2[0]\n\n            u1 = rk4_step(f1, x_grid[i], u1, h)\n            u2 = rk4_step(f2, x_grid[i], u2, h)\n\n        # Values at L are the final state of u1 and u2\n        y1_L, v1_L = u1\n        y2_L, v2_L = u2\n\n        # Calculate the constant C\n        # C = (gamma - c1*y1(L) - c2*y1'(L)) / (c1*y2(L) + c2*y2'(L))\n        numerator = gamma - c1 * y1_L - c2 * v1_L\n        denominator = c1 * y2_L + c2 * v2_L\n\n        if abs(denominator)  1e-15:\n            # This case corresponds to non-unique or no solutions.\n            # Return NaN for robustness, though not expected in this problem.\n            return float('nan')\n        \n        C = numerator / denominator\n\n        # Final solution at x_star by superposition\n        y_at_x_star = y1_at_x_star + C * y2_at_x_star\n\n        return y_at_x_star\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: y'' - y = 0, y(0)=1, y'(8)+y(8)=0\n        {\n            'p': lambda x: 0.0, 'q': lambda x: -1.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 1.0, 'c2': 1.0, 'gamma': 0.0\n        },\n        # Case 2: y'' - 4y = 0, y(0)=1, y'(8)+2y(8)=0\n        {\n            'p': lambda x: 0.0, 'q': lambda x: -4.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 2.0, 'c2': 1.0, 'gamma': 0.0\n        },\n        # Case 3: y'' + (2/(1+x))y' - y = 0, y(0)=1, y'(8)+y(8)=0\n        {\n            'p': lambda x: 2.0 / (1.0 + x), 'q': lambda x: -1.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 1.0, 'c2': 1.0, 'gamma': 0.0\n        },\n        # Case 4: y'' - y = 0, y(0)=1, y(8)=0\n        {\n            'p': lambda x: 0.0, 'q': lambda x: -1.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 1.0, 'c2': 0.0, 'gamma': 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = linear_shooting(\n            p_func=case['p'],\n            q_func=case['q'],\n            r_func=case['r'],\n            a=case['a'],\n            L=case['L'],\n            h=case['h'],\n            alpha=case['alpha'],\n            c1=case['c1'],\n            c2=case['c2'],\n            gamma=case['gamma'],\n            x_star=case['x_star']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The standard shooting method can become numerically unstable when applied over long intervals, especially when the underlying differential equation has solutions that grow rapidly. This exercise introduces multiple shooting, a powerful technique that circumvents this instability by breaking the problem into smaller, more manageable segments. By implementing and comparing both single and multiple shooting for a classic unstable problem , you will gain a firsthand understanding of the method's limitations and the importance of choosing a numerically stable algorithm.",
            "id": "3248449",
            "problem": "You are to implement and test a multiple shooting (also known as parallel or segment-wise shooting) method for linear two-point boundary value problems to overcome the instability and ill-conditioning that can appear in standard single shooting over long intervals. Work with the following boundary value problem:\nGiven $L \\in \\mathbb{R}_{0}$ and boundary data $\\alpha, \\beta \\in \\mathbb{R}$, find $y:[0,L] \\to \\mathbb{R}$ such that\n$\ny''(x) - y(x) = 0,\\quad x \\in [0,L],\\quad y(0) = \\alpha,\\quad y(L) = \\beta.\n$\nFor verification, the exact solution is\n$\ny(x) = \\alpha\\,\\frac{\\sinh(L-x)}{\\sinh(L)} + \\beta\\,\\frac{\\sinh(x)}{\\sinh(L)}.\n$\n\nStarting from the fundamental base that any scalar second-order linear ordinary differential equation can be rewritten as a first-order system, recast the boundary value problem as the first-order linear system\n$\n\\mathbf{u}'(x) = A(x)\\,\\mathbf{u}(x),\\quad \\mathbf{u}(x) \\in \\mathbb{R}^2,\n$\nwhere $\\mathbf{u}(x) = \\begin{bmatrix}y(x)\\\\y'(x)\\end{bmatrix}$ and $A(x) = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$ is constant. Use the linear initial value problem flow and the state transition matrix to derive a multiple shooting formulation on a uniform partition of $[0,L]$ into $m$ subintervals with nodes $x_k = k\\,h$, $h = L/m$, $k=0,1,\\dots,m$. On each subinterval $[x_k,x_{k+1}]$, approximate the state transition matrix $\\Phi_k$ that maps $\\mathbf{u}(x_k)$ to $\\mathbf{u}(x_{k+1})$ by numerically integrating the matrix differential equation\n$\n\\frac{d}{dx}\\Phi(x) = A(x)\\,\\Phi(x),\\quad \\Phi(x_k) = I,\n$\nusing the classical Runge–Kutta method of order $4$ with a fixed number of steps per subinterval. Assemble a linear block system that enforces:\n- continuity across internal nodes, i.e., $\\mathbf{u}(x_{k+1}) - \\Phi_k\\,\\mathbf{u}(x_k) = \\mathbf{0}$ for $k=0,1,\\dots,m-1$, and\n- the boundary conditions $y(0) = \\alpha$ and $y(L) = \\beta$,\nand solve it for the unknown nodal states $\\mathbf{u}(x_k)$, $k=0,1,\\dots,m-1$. Recover $y$ at the grid nodes $x_k$ from these states and the final propagation on the last subinterval. Compute the maximum absolute error at the grid nodes $x_k$ by comparing the numerical $y(x_k)$ to the exact $y(x_k)$.\n\nAlso implement a standard single shooting baseline. Use the linear superposition principle: integrate two initial value problems across $[0,L]$ with initial data $\\mathbf{u}^{(1)}(0) = \\begin{bmatrix}\\alpha\\\\0\\end{bmatrix}$ and $\\mathbf{u}^{(2)}(0) = \\begin{bmatrix}0\\\\1\\end{bmatrix}$ to determine the initial slope needed to satisfy $y(L)=\\beta$, then integrate once from $x=0$ to $x=L$ with that initial slope and record the values $y(x_k)$ at the same grid nodes. Use the same Runge–Kutta method of order $4$ with a fixed number of steps per subinterval to build the state transition matrices for this baseline.\n\nImplement a program that, for each test case, returns a two-element list containing:\n- the maximum absolute nodal error for single shooting, and\n- the maximum absolute nodal error for multiple shooting,\neach as a floating-point number.\n\nTest suite:\n- Test case $1$: $L=20$, $\\alpha=0$, $\\beta=1$, $m=10$, steps per subinterval for multiple shooting $=40$, steps per subinterval for single shooting $=40$.\n- Test case $2$: $L=20$, $\\alpha=1$, $\\beta=2$, $m=1$, steps per subinterval for multiple shooting $=2000$, steps per subinterval for single shooting $=2000$.\n- Test case $3$: $L=10$, $\\alpha=0.5$, $\\beta=1.5$, $m=5$, steps per subinterval for multiple shooting $=50$, steps per subinterval for single shooting $=50$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list in the order described above. For example, a valid output looks like\n$\n[[e_{1,\\text{single}},e_{1,\\text{multi}}],[e_{2,\\text{single}},e_{2,\\text{multi}}],[e_{3,\\text{single}},e_{3,\\text{multi}}]].\n$",
            "solution": "The user wants to solve a linear two-point boundary value problem using both single and multiple shooting methods and compare their accuracy.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Boundary Value Problem (BVP):**\n  - Equation: $y''(x) - y(x) = 0$, for $x \\in [0,L]$.\n  - Boundary Conditions: $y(0) = \\alpha$, $y(L) = \\beta$.\n  - Parameters: $L \\in \\mathbb{R}_{0}$, $\\alpha, \\beta \\in \\mathbb{R}$.\n- **First-Order System:**\n  - State Vector: $\\mathbf{u}(x) = [y(x), y'(x)]^T$.\n  - System: $\\mathbf{u}'(x) = A\\mathbf{u}(x)$ with $A = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$.\n- **Numerical Methods:**\n  - Both methods must use the classical Runge-Kutta method of order 4 (RK4).\n  - **Multiple Shooting:** Partition $[0,L]$ into $m$ subintervals $[x_k, x_{k+1}]$ where $x_k = k(L/m)$. A block linear system is to be formed based on continuity conditions $\\mathbf{u}(x_{k+1}) = \\Phi_k \\mathbf{u}(x_k)$ (where $\\Phi_k$ is the state transition matrix on the subinterval) and the boundary conditions.\n  - **Single Shooting:** Use linear superposition by solving two initial value problems (or equivalently, by using the state transition matrix over the full interval $[0,L]$) to find the correct initial slope $y'(0)$, then perform a single integration run over $[0,L]$.\n- **Error Metric:**\n  - Maximum absolute error at the grid nodes $x_k$ for $k=0, \\dots, m$.\n- **Test Suite:**\n  - Case 1: $L=20, \\alpha=0, \\beta=1, m=10$, steps per subinterval $=40$.\n  - Case 2: $L=20, \\alpha=1, \\beta=2, m=1$, steps per subinterval $=2000$.\n  - Case 3: $L=10, \\alpha=0.5, \\beta=1.5, m=5$, steps per subinterval $=50$.\n- **Exact Solution for Verification:**\n  - $y(x) = \\alpha\\,\\frac{\\sinh(L-x)}{\\sinh(L)} + \\beta\\,\\frac{\\sinh(x)}{\\sinh(L)}$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is a well-established linear BVP with constant coefficients. The provided exact solution is correct, as verified by substituting it into the differential equation and boundary conditions. The reformulation as a first-order system and the application of shooting methods are standard techniques in numerical analysis. The choice of the equation $y''-y=0$ is classic for demonstrating the failure of single shooting over long intervals, as its fundamental solutions $e^x$ and $e^{-x}$ have vastly different growth rates, leading to ill-conditioning.\n- **Well-Posed:** The BVP is linear and well-posed. The single shooting method is well-posed as long as the associated fundamental solution component is non-zero at the right boundary, which holds true here since $\\sinh(L) \\ne 0$ for $L > 0$. The multiple shooting method results in a large, sparse, block-structured linear system. For a well-posed BVP, this system is non-singular.\n- **Objective:** The problem is stated using precise mathematical and computational language.\n- **Completeness and Consistency:** The problem provides all necessary data and methodological constraints. The test cases are fully specified. A minor ambiguity exists in the description of the multiple shooting system assembly, but a standard \"all-at-once\" formulation where the states at all nodes are treated as unknowns is a valid and robust interpretation. Test case 2, where $m=1$, serves as a consistency check, as multiple shooting should behave very similarly to single shooting in this configuration.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-posed, scientifically sound, and clearly defined task in the field of numerical methods for differential equations. I will now proceed with the solution.\n\n### Principle-Based Design of the Solution\n\nThe core of the problem lies in the numerical solution of a boundary value problem, which contrasts with the more straightforward numerical solution of an initial value problem (IVP). Shooting methods convert a BVP into one or more IVPs.\n\n**1. System Formulation and State Transition Matrix**\n\nThe second-order ODE $y'' - y = 0$ is converted to a first-order system $\\mathbf{u}' = A\\mathbf{u}$ where $\\mathbf{u} = [y, y']^T$ and $A = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$. The solution to this linear, autonomous system can be expressed using the state transition matrix (or fundamental matrix) $\\Phi(x)$, which propagates a solution from an initial point $x_0$ to a point $x$: $\\mathbf{u}(x) = \\Phi(x-x_0)\\mathbf{u}(x_0)$. The matrix $\\Phi$ itself satisfies the matrix differential equation $\\Phi' = A\\Phi$ with the initial condition $\\Phi(0) = I$, where $I$ is the identity matrix.\n\nWe will numerically approximate $\\Phi$ over a given interval by integrating its governing differential equation using the classical fourth-order Runge-Kutta (RK4) method. This will be a core utility function, `compute_phi`.\n\n**2. Single Shooting Method**\n\nThe principle of single shooting is to find the correct, unknown initial condition, $y'(0)$, that \"hits\" the target boundary condition at $x=L$.\nThe solution at $x=L$ relates to the initial conditions at $x=0$ via the state transition matrix over the entire interval, $\\Phi(L)$:\n$$ \\begin{bmatrix} y(L) \\\\ y'(L) \\end{bmatrix} = \\Phi(L) \\begin{bmatrix} y(0) \\\\ y'(0) \\end{bmatrix} $$\nWe know $y(0) = \\alpha$ and we require $y(L)=\\beta$. Expanding the first row gives:\n$$ \\beta = \\Phi_{11}(L)\\alpha + \\Phi_{12}(L)y'(0) $$\nWe can solve for the unknown initial slope:\n$$ y'(0) = \\frac{\\beta - \\Phi_{11}(L)\\alpha}{\\Phi_{12}(L)} $$\nOnce the complete initial vector $\\mathbf{u}(0) = [\\alpha, y'(0)]^T$ is known, the BVP is reduced to a single IVP. We solve this IVP from $x=0$ to $x=L$ using RK4, storing the solution $y(x_k)$ at the specified grid nodes.\nThe key vulnerability of this method arises from the properties of matrix $A$. Its eigenvalues are $\\pm 1$, leading to solutions containing $e^x$ and $e^{-x}$. For large $L$, the entries of $\\Phi(L)$ become enormous (e.g., $\\cosh(L)$), making the calculation of $y'(0)$ prone to catastrophic cancellation and rendering the IVP stiff and difficult to solve accurately.\n\n**3. Multiple Shooting Method**\n\nMultiple shooting mitigates this issue by dividing the long interval $[0,L]$ into $m$ smaller, more manageable subintervals $[x_k, x_{k+1}]$.\nOn each subinterval, we relate the states at the endpoints via a local state transition matrix $\\Phi_k$:\n$$ \\mathbf{u}(x_{k+1}) = \\Phi_k \\mathbf{u}(x_k), \\quad \\text{for } k=0, 1, \\dots, m-1 $$\nIn this problem, since $A$ is constant and the subintervals have equal length $h=L/m$, all $\\Phi_k$ are identical.\nWe treat the state vectors $\\mathbf{u}(x_0), \\mathbf{u}(x_1), \\dots, \\mathbf{u}(x_m)$ as unknowns. This gives $2(m+1)$ scalar variables. We assemble a system of $2(m+1)$ linear equations:\n- **Boundary condition at $x=0$**: $y(x_0) = \\alpha$. (1 equation)\n- **Continuity across internal nodes**: $\\mathbf{u}(x_{k+1}) - \\Phi_k \\mathbf{u}(x_k) = \\mathbf{0}$ for $k=0, \\dots, m-1$. ($2m$ equations)\n- **Boundary condition at $x=L$**: $y(x_m) = \\beta$. (1 equation)\n\nThis forms a large, sparse, block-structured linear system of the form $M\\mathbf{S} = \\mathbf{b}$, where $\\mathbf{S} = [\\mathbf{u}(x_0)^T, \\dots, \\mathbf{u}(x_m)^T]^T$. This system can be solved using a standard linear algebra library routine. Since the state transition matrices $\\Phi_k$ are computed over short intervals, their elements remain small, and the overall system $M$ is well-conditioned, avoiding the numerical stability issues of single shooting. The solution vector $\\mathbf{S}$ directly provides the numerical approximations for $y(x_k)$ at all grid nodes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # This is the ODE system function u' = f(u) = A @ u\n    def ode_system_f(u, A):\n        return A @ u\n\n    # Generic RK4 stepper for a vector or matrix state Y, solving Y' = A @ Y\n    def rk4_step(A, Y, h):\n        k1 = h * ode_system_f(Y, A)\n        k2 = h * ode_system_f(Y + 0.5 * k1, A)\n        k3 = h * ode_system_f(Y + 0.5 * k2, A)\n        k4 = h * ode_system_f(Y + k3, A)\n        return Y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n\n    # Computes the state transition matrix Phi over an interval.\n    def compute_phi(A, interval_len, n_steps):\n        h_rk = interval_len / n_steps\n        # Start with the identity matrix\n        Phi = np.identity(A.shape[0], dtype=float)\n        for _ in range(n_steps):\n            Phi = rk4_step(A, Phi, h_rk)\n        return Phi\n\n    # Exact solution of the BVP for verification\n    def exact_solution(x, L, alpha, beta):\n        # The problem statement guarantees L > 0, so sinh(L) is not zero.\n        # numpy's sinh handles large arguments up to ~709, returning 'inf' beyond that.\n        # This is sufficient for the test cases provided.\n        sinh_L = np.sinh(L)\n        return alpha * np.sinh(L - x) / sinh_L + beta * np.sinh(x) / sinh_L\n\n    def solve_single_shooting(L, alpha, beta, m, steps_per_sub):\n        A = np.array([[0.0, 1.0], [1.0, 0.0]])\n        total_steps = m * steps_per_sub\n        x_nodes = np.linspace(0, L, m + 1)\n\n        # 1. Find the initial slope y'(0) using the shooting condition.\n        # This requires the state transition matrix over the full interval [0, L].\n        Phi_L = compute_phi(A, L, total_steps)\n        phi_11 = Phi_L[0, 0]\n        phi_12 = Phi_L[0, 1]\n        \n        # Check for singularity. For this problem, phi_12 = sinh(L) which is non-zero for L>0.\n        if abs(phi_12)  1e-15:\n            return np.inf\n\n        # From y(L) = beta = phi_11*y(0) + phi_12*y'(0), solve for y'(0).\n        y0_prime = (beta - phi_11 * alpha) / phi_12\n        u0 = np.array([alpha, y0_prime], dtype=float)\n\n        # 2. Integrate the IVP with the correct initial condition u0.\n        y_numeric = np.zeros(m + 1, dtype=float)\n        y_numeric[0] = alpha\n        h_rk = L / total_steps\n        u_current = u0.copy()\n        \n        for k in range(m):\n            # Integrate over one subinterval [x_k, x_{k+1}]\n            for _ in range(steps_per_sub):\n                u_current = rk4_step(A, u_current, h_rk)\n            y_numeric[k + 1] = u_current[0]\n            \n        # 3. Compute the maximum absolute error at the nodes.\n        y_exact = exact_solution(x_nodes, L, alpha, beta)\n        max_error = np.max(np.abs(y_numeric - y_exact))\n        \n        return max_error\n\n    def solve_multiple_shooting(L, alpha, beta, m, steps_per_sub):\n        if m == 0: return np.nan\n\n        A = np.array([[0.0, 1.0], [1.0, 0.0]])\n        h_sub = L / m\n        x_nodes = np.linspace(0, L, m + 1)\n        \n        # 1. Compute state transition matrix for a subinterval.\n        # Because A is constant, Phi is the same for all subintervals.\n        Phi = compute_phi(A, h_sub, steps_per_sub)\n        \n        # 2. Assemble and solve the block linear system M*S = b.\n        # Unknowns S = [u0, u1, ..., um]^T. Total size is 2*(m+1).\n        N = 2 * (m + 1)\n        M = np.zeros((N, N), dtype=float)\n        b = np.zeros(N, dtype=float)\n        I = np.identity(2, dtype=float)\n        \n        # BC at x=0: y(0) = alpha\n        M[0, 0] = 1.0\n        b[0] = alpha\n        \n        # Continuity conditions: u_{k+1} - Phi * u_k = 0\n        for k in range(m):\n            row_idx = 1 + 2 * k\n            col_idx_k = 2 * k\n            col_idx_k_plus_1 = 2 * (k + 1)\n            \n            M[row_idx:row_idx+2, col_idx_k:col_idx_k+2] = -Phi\n            M[row_idx:row_idx+2, col_idx_k_plus_1:col_idx_k_plus_1+2] = I\n        \n        # BC at x=L: y(L) = beta (which is y_m)\n        M[N-1, N-2] = 1.0\n        b[N-1] = beta\n        \n        try:\n            S = np.linalg.solve(M, b)\n        except np.linalg.LinAlgError:\n            return np.inf\n\n        # 3. Extract solution and compute error.\n        y_numeric = S[0::2] # Extract y_k values from solution vector\n        y_exact = exact_solution(x_nodes, L, alpha, beta)\n        max_error = np.max(np.abs(y_numeric - y_exact))\n        \n        return max_error\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, beta, m, steps_per_subinterval)\n        (20.0, 0.0, 1.0, 10, 40),\n        (20.0, 1.0, 2.0, 1, 2000),\n        (10.0, 0.5, 1.5, 5, 50),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, beta, m, steps = case\n        err_single = solve_single_shooting(L, alpha, beta, m, steps)\n        err_multi = solve_multiple_shooting(L, alpha, beta, m, steps)\n        results.append([err_single, err_multi])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces, which str() adds by default for lists.\n    # So we build the string manually.\n    formatted_results = []\n    for res_pair in results:\n        formatted_results.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}