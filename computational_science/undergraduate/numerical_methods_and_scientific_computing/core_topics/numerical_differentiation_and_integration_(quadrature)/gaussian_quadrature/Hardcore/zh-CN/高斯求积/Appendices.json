{
    "hands_on_practices": [
        {
            "introduction": "我们将从一个基础练习开始，旨在揭示高斯求积法的核心思想。通过应用最简单的单点高斯-勒让德求积法则 ()，你将亲身体验如何通过一个精心选择的节点和权重来获得积分的精确近似。这个练习为你理解更复杂的高斯求积方法奠定了直观的基础。",
            "id": "2175493",
            "problem": "在数值分析中，高斯求积是近似计算函数定积分的一种强大方法。其一般形式为 $\\int_{-1}^1 f(x) \\, dx \\approx \\sum_{i=1}^n w_i f(x_i)$，其中 $n$ 是点数，$x_i$ 是节点，$w_i$ 是权重。最简单的版本是单点高斯-勒让德求积法则，其节点为 $x_1 = 0$，权重为 $w_1 = 2$。\n\n考虑一根长度为 2 米的细直杆，沿着 x 轴从 $x=-1$ 到 $x=1$ 放置。该杆的线性质量密度（单位长度的质量）$\\lambda(x)$ 沿其长度根据函数 $\\lambda(x) = k (x + 1/5)^3$ 变化，其中 $k$ 是一个具有适当单位的正常数。杆的总质量 $M$ 由其密度函数在其长度上的积分给出：$M = \\int_{-1}^1 \\lambda(x) \\, dx$。\n\n使用所提供的单点高斯-勒让德求积法则，计算杆的近似总质量。将您的答案表示为常数 $k$ 的分数倍。",
            "solution": "我们被要求近似计算总质量\n$$\nM=\\int_{-1}^{1}\\lambda(x)\\,dx=\\int_{-1}^{1}k\\left(x+\\frac{1}{5}\\right)^{3}\\,dx\n$$\n使用区间 $[-1,1]$ 上的单点高斯-勒让德求积法则，该法则表明\n$$\n\\int_{-1}^{1}f(x)\\,dx\\approx w_{1}f(x_{1}),\\quad x_{1}=0,\\quad w_{1}=2.\n$$\n这里，$f(x)=\\lambda(x)=k\\left(x+\\frac{1}{5}\\right)^{3}$。因此，\n$$\nM\\approx 2\\,\\lambda(0)=2\\,k\\left(0+\\frac{1}{5}\\right)^{3}=2k\\left(\\frac{1}{5}\\right)^{3}.\n$$\n计算立方：\n$$\n\\left(\\frac{1}{5}\\right)^{3}=\\frac{1}{125},\n$$\n所以近似值变为\n$$\nM\\approx 2k\\cdot\\frac{1}{125}=\\frac{2k}{125}.\n$$\n这是 $k$ 的一个分数倍，符合要求。",
            "answer": "$$\\boxed{\\frac{2}{125}k}$$"
        },
        {
            "introduction": "现实世界中的科学和工程问题通常涉及在任意区间上的积分，而不仅仅是标准的 $[-1, 1]$ 区间。本练习 () 将指导你掌握两项关键技术：区间变换和复合求积法则。这些方法极大地扩展了高斯求积法的适用性，使其成为解决各类实际问题的强大工具。",
            "id": "2175463",
            "problem": "在材料科学领域，我们正在研究拉伸一种新型非线性弹性聚合物所需的能量。实验数据表明，当聚合物从其平衡长度拉伸距离 $x$ 时，其产生的阻力 $F(x)$ 可以用以下函数建模：\n$$F(x) = F_0 \\exp(\\alpha x^2)$$\n其中 $F_0$ 是在 $x=0$ 时的初始阻力，$\\alpha$ 是一个材料常数。\n\n将此聚合物从位置 $x=a$ 拉伸到 $x=b$ 所做的功 $W$ 由以下积分给出：\n$$W = \\int_a^b F(x) dx$$\n\n您的任务是使用数值积分技术来近似所做的功。具体来说，您需要应用复合两点高斯-勒让德求积法则。为此计算，您必须将总积分区间 $[a, b]$ 分成两个相等的子区间。\n\n在区间 $[-1, 1]$ 上的标准两点高斯-勒让德法则由下式给出：\n$$\\int_{-1}^{1} g(t) dt \\approx g\\left(-\\frac{1}{\\sqrt{3}}\\right) + g\\left(\\frac{1}{\\sqrt{3}}\\right)$$\n\n给定以下参数：\n- 初始力, $F_0 = 10.0$ N\n- 材料常数, $\\alpha = 0.50$ m$^{-2}$\n- 初始位置, $a = 0.0$ m\n- 最终位置, $b = 2.0$ m\n\n计算所做的总功 $W$。您的答案应以焦耳（J）为单位，并四舍五入到四位有效数字。",
            "solution": "物理原理是功等于力沿位移的线积分：$W=\\int_{a}^{b}F(x)\\,dx$。我们使用复合两点高斯-勒让德法则在两个相等的子区间上近似该积分。将 $[a,b]$ 划分成 $n=2$ 个长度为 $h=(b-a)/2$ 的子区间。对于第 $i$ 个子区间 $[x_{i-1},x_{i}]$，其中点为 $m_{i}=(x_{i-1}+x_{i})/2$，从 $[-1,1]$ 映射的两点高斯-勒让德法则给出\n$$\n\\int_{x_{i-1}}^{x_{i}}F(x)\\,dx \\approx \\frac{h}{2}\\left[F\\!\\left(m_{i}-\\frac{h}{2\\sqrt{3}}\\right)+F\\!\\left(m_{i}+\\frac{h}{2\\sqrt{3}}\\right)\\right].\n$$\n因此，当 $n=2$ 时，复合规则为\n$$\nW \\approx \\sum_{i=1}^{2}\\frac{h}{2}\\left[F\\!\\left(m_{i}-\\frac{h}{2\\sqrt{3}}\\right)+F\\!\\left(m_{i}+\\frac{h}{2\\sqrt{3}}\\right)\\right].\n$$\n根据给定数据 $F(x)=F_{0}\\exp(\\alpha x^{2})$，$F_{0}=10.0$，$\\alpha=0.50$，$a=0.0$，$b=2.0$，我们有 $h=1$，$m_{1}=\\frac{1}{2}$，$m_{2}=\\frac{3}{2}$，以及节点偏移量 $\\delta=\\frac{h}{2\\sqrt{3}}=\\frac{1}{2\\sqrt{3}}$。四个求值点是\n$$\nx_{1,-}=\\frac{1}{2}-\\frac{1}{2\\sqrt{3}},\\quad x_{1,+}=\\frac{1}{2}+\\frac{1}{2\\sqrt{3}},\\quad\nx_{2,-}=\\frac{3}{2}-\\frac{1}{2\\sqrt{3}},\\quad x_{2,+}=\\frac{3}{2}+\\frac{1}{2\\sqrt{3}}.\n$$\n它们的平方可以精确地写为\n$$\nx_{1,-}^{2}=\\frac{1}{3}-\\frac{1}{2\\sqrt{3}},\\quad x_{1,+}^{2}=\\frac{1}{3}+\\frac{1}{2\\sqrt{3}},\\quad\nx_{2,-}^{2}=\\frac{7}{3}-\\frac{3}{2\\sqrt{3}},\\quad x_{2,+}^{2}=\\frac{7}{3}+\\frac{3}{2\\sqrt{3}}.\n$$\n由于 $\\alpha=\\frac{1}{2}$，指数为\n$$\n\\alpha x_{1,-}^{2}=\\frac{1}{6}-\\frac{1}{4\\sqrt{3}},\\quad \\alpha x_{1,+}^{2}=\\frac{1}{6}+\\frac{1}{4\\sqrt{3}},\\quad\n\\alpha x_{2,-}^{2}=\\frac{7}{6}-\\frac{3}{4\\sqrt{3}},\\quad \\alpha x_{2,+}^{2}=\\frac{7}{6}+\\frac{3}{4\\sqrt{3}}.\n$$\n因此，\n$$\nW \\approx \\frac{h}{2}\\left[F_{0}\\exp\\!\\left(\\frac{1}{6}-\\frac{1}{4\\sqrt{3}}\\right)+F_{0}\\exp\\!\\left(\\frac{1}{6}+\\frac{1}{4\\sqrt{3}}\\right)+F_{0}\\exp\\!\\left(\\frac{7}{6}-\\frac{3}{4\\sqrt{3}}\\right)+F_{0}\\exp\\!\\left(\\frac{7}{6}+\\frac{3}{4\\sqrt{3}}\\right)\\right].\n$$\n代入 $h=1$ 和 $F_{0}=10.0$ 并进行数值计算，\n$$\n\\exp\\!\\left(\\frac{1}{6}-\\frac{1}{4\\sqrt{3}}\\right)\\approx 1.022580249,\\quad\n\\exp\\!\\left(\\frac{1}{6}+\\frac{1}{4\\sqrt{3}}\\right)\\approx 1.364794995,\n$$\n$$\n\\exp\\!\\left(\\frac{7}{6}-\\frac{3}{4\\sqrt{3}}\\right)\\approx 2.082676640,\\quad\n\\exp\\!\\left(\\frac{7}{6}+\\frac{3}{4\\sqrt{3}}\\right)\\approx 4.951444581.\n$$\n因此，\n$$\nW \\approx \\frac{1}{2}\\cdot 10\\left(1.022580249+1.364794995+2.082676640+4.951444581\\right)\n= \\frac{1}{2}\\cdot 10 \\cdot 9.421496465 \\approx 47.10748233.\n$$\n四舍五入到四位有效数字，总功为 $47.11$ 焦耳。",
            "answer": "$$\\boxed{47.11}$$"
        },
        {
            "introduction": "作为一项综合性实践，本练习 () 将带你深入高斯求积法的核心。你将不再仅仅是使用给定的节点和权重，而是通过从头开始实现经典的 Golub-Welsch 算法来亲自生成它们。此过程将正交多项式和矩阵特征值问题的抽象理论与具体的计算方法联系起来，让你深刻理解高斯求积工具的构建原理及其数值稳定性。",
            "id": "3234000",
            "problem": "您的任务是实现一个完整的程序，该程序使用 Golub–Welsch 算法计算区间 $[-1,1]$ 上勒让德权重的高斯求积节点和权重，然后量化对于较大的 $n$，该求积方法对节点浮点舍入的敏感性。该实现必须从头开始，基于正交多项式和高斯求积的核心定义和经过充分检验的事实，不得使用任何预打包的求积例程。\n\n基础理论：\n- 对于区间上某一正权重函数 $w(x)$ 的正交多项式族 $\\{p_k(x)\\}_{k=0}^{\\infty}$，存在一种三项递推关系，形式如下\n$$x\\,p_k(x) = \\alpha_k\\,p_k(x) + \\beta_{k+1}\\,p_{k+1}(x) + \\beta_k\\,p_{k-1}(x),$$\n其中，当 $k \\ge 1$ 时，系数 $\\alpha_k$ 为实数，$\\beta_k$ 为正数，且 $p_{-1} \\equiv 0$。\n- 对于区间 $[-1,1]$ 上的权重 $w(x) = 1$（勒让德权重），当 $\\{p_k\\}$ 是标准正交多项式时，对称性意味着 $\\alpha_k = 0$，且由这些系数构建的三对角雅可比矩阵是实对称的。\n- 根据谱定理，该 $n \\times n$ 雅可比矩阵的特征值是实的、单重的，并且位于区间 $[-1,1]$ 内。高斯求积节点即为这些特征值，而相应的权重与归一化特征向量的第一个分量的平方成正比。对于 $[-1,1]$ 上的 $w(x) = 1$，总质量为 $\\mu_0 = \\int_{-1}^{1} 1\\,dx = 2$。\n\n程序要求：\n1) 使用双精度算術，实现 Golub–Welsch 算法，计算 $n$ 阶高斯-勒让德求积的节点 $\\{x_i\\}_{i=1}^n$ 和权重 $\\{w_i\\}_{i=1}^n$。您必须推导并使用标准正交勒让德多项式的三项递推系数来构建对称三对角雅可比矩阵，然后计算其特征值和特征向量以获得 $(x_i,w_i)$。\n\n2) 使用您的实现，评估以下测试套件，该套件涵盖了精确性、对光滑函数的准确性以及对节点浮点舍入的敏感性：\n- 测试 A (对最高 $2n-1$ 次多项式的精确性)：对于 $n = 4$，计算积分 $\\int_{-1}^{1} x^k\\,dx$（其中 $k$ 为 $0 \\le k \\le 7$ 的所有整数）的求积近似值。返回求积结果与精确积分值（可由 $x^k$ 在 $[-1,1]$ 上的反导数得出）之间的最大绝对偏差。预期的精确积分为：当 $k$ 为奇数时为 $0$，当 $k$ 为偶数时为 $2/(k+1)$。\n- 测试 B (光滑函数准确性)：对于 $n = 32$，使用您的高斯-勒让德节点和权重近似计算 $\\int_{-1}^{1} e^x\\,dx$，并返回与精确值 $e - e^{-1}$ 相比的绝对误差。\n- 测试 C (大 $n$ 时对节点舍入的敏感性)：对于 $n = 128$，使用双精度节点计算 $\\int_{-1}^{1} e^x\\,dx$ 的求积近似值 $Q$。然后，通过将每个节点舍入为单精度（$32$-位）浮点数再转换回双精度，形成舍入后的节点 $\\{\\hat{x}_i\\}$，并使用相同的权重但计算 $e^{\\hat{x}_i}$ 来计算 $\\hat{Q}$。返回绝对差 $|Q - \\hat{Q}|$。\n- 测试 D (最差情况下的节点扰动幅度)：对于相同的 $n = 128$，返回 $\\max_i |x_i - \\hat{x}_i|$，其中 $\\hat{x}_i$ 是与测试 C 中相同的单精度舍入节点。\n\n角度单位：如果使用任何三角函数，其参数必须以弧度为单位。在此测试套件中，仅使用了指数函数 $e^x$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [测试 A 结果, 测试 B 结果, 测试 C 结果, 测试 D 结果]。例如：\"[rA,rB,rC,rD]\"。\n- 报告的每个值都必须是实数（浮点数）。不应打印任何其他文本。",
            "solution": "所述问题是有效的。它在科学上基于成熟的高斯求积和正交多项式理论，特别是用于计算节点和权重的 Golub-Welsch 算法。该问题是适定的，提供了所有必要的定义、约束和一组明确的任务，这些任务将导出一个唯一的、可验证的数值结果。它是客观的，没有歧义。因此，我们可以着手给出一个正式的解法。\n\n目标是使用 Golub-Welsch 算法计算高斯-勒让德求积法则并分析其性质。该方法将寻找求积节点（即正交多项式的根）的问题，重新表述为一个矩阵特征值问题，这种方法数值稳定且效率很高。\n\n一个 $n$ 点高斯求积法则将关于权重函数 $w(x)$ 在区间 $[a, b]$ 上的积分近似为一个有限和：\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n如果 $f(x)$ 是一个次数最高为 $2n-1$ 的多项式，则此近似是精确的。节点 $\\{x_i\\}_{i=1}^n$ 是由正交条件定义的一族正交多项式 $\\{p_k(x)\\}_{k=0}^{\\infty}$ 中 $n$ 次多项式 $p_n(x)$ 的根：\n$$\n\\int_{a}^{b} w(x) p_j(x) p_k(x) \\,dx = C_k \\delta_{jk}\n$$\n其中 $\\delta_{jk}$ 是克罗内克δ符号，$C_k$ 是一个归一化常数。如果多项式是标准正交的，则 $C_k=1$。\n\n正交多项式的一个基本性质是它们满足一个三项递推关系。对于标准正交多项式 $\\{p_k(x)\\}$，该关系的形式为：\n$$\nx p_k(x) = \\beta_{k+1} p_{k+1}(x) + \\alpha_k p_k(x) + \\beta_k p_{k-1}(x)\n$$\n其中 $p_{-1}(x) \\equiv 0$，$p_0(x)$ 为常数。系数 $\\alpha_k$ 和 $\\beta_k$ 是实数。这个递推关系可以写成矩阵形式。如果我们考虑前 $n$ 个多项式组成的向量 $\\mathbf{P}(x) = [p_0(x), p_1(x), \\dots, p_{n-1}(x)]^T$，对于 $k=0, \\dots, n-1$ 的这组递推关系可以表示为：\n$$\nx \\mathbf{P}(x) = J_n \\mathbf{P}(x) + \\beta_n p_n(x) \\mathbf{e}_n\n$$\n其中 $\\mathbf{e}_n = [0, \\dots, 0, 1]^T$，$J_n$ 是 $n \\times n$ 的对称三对角雅可比矩阵：\n$$\nJ_n = \\begin{pmatrix}\n \\alpha_0  \\beta_1  0  \\dots  0 \\\\\n \\beta_1  \\alpha_1  \\beta_2  \\dots  0 \\\\\n 0  \\beta_2  \\alpha_2  \\ddots  \\vdots \\\\\n \\vdots  \\vdots  \\ddots  \\ddots  \\beta_{n-1} \\\\\n 0  0  \\dots  \\beta_{n-1}  \\alpha_{n-1}\n\\end{pmatrix}\n$$\n求积节点 $\\{x_i\\}_{i=1}^n$ 是 $p_n(x)$ 的根。在这些根处，$p_n(x_i)=0$，递推关系简化为一个特征值方程：$x_i \\mathbf{P}(x_i) = J_n \\mathbf{P}(x_i)$。这表明求积节点恰好是雅可比矩阵 $J_n$ 的特征值。这就是 Golub-Welsch 算法的核心。\n\n对于高斯-勒让德求积，区间是 $[-1, 1]$，权重函数是 $w(x)=1$。相应的正交多项式是勒让德多项式。为了构建雅可比矩阵，我们需要*标准正交*勒让德多项式的系数 $\\alpha_k$ 和 $\\beta_k$。由 $P_k(1)=1$ 归一化的标准勒让德多项式 $P_k(x)$ 满足递推关系 $(k+1)P_{k+1}(x) = (2k+1)x P_k(x) - k P_{k-1}(x)$，其范数为 $\\int_{-1}^1 (P_k(x))^2 dx = \\frac{2}{2k+1}$。标准正交多项式为 $p_k(x) = \\sqrt{\\frac{2k+1}{2}} P_k(x)$。将此代入 $P_k(x)$ 的递推关系并重新整理，得到 $p_k(x)$ 的递推关系：\n$$\nx p_k(x) = \\frac{k+1}{\\sqrt{(2k+1)(2k+3)}} p_{k+1}(x) + \\frac{k}{\\sqrt{(2k-1)(2k+1)}} p_{k-1}(x)\n$$\n将其与一般形式进行比较，我们确定标准正交勒让德多项式的系数为：\n$$\n\\alpha_k = 0 \\quad \\text{for all } k\n$$\n$$\n\\beta_k = \\frac{k}{\\sqrt{4k^2 - 1}} \\quad \\text{for } k \\ge 1\n$$\n因此，高斯-勒让德求积的雅可比矩阵 $J_n$ 是一个对称三对角矩阵，其主对角线元素为零，次对角线和超对角线上的元素为 $\\beta_k$（其中 $k=1, \\dots, n-1$）。\n\n求积权重 $\\{w_i\\}_{i=1}^n$ 与 $J_n$ 的特征向量有关。如果 $\\mathbf{v}_i$ 是对应于特征值 $x_i$ 的归一化特征向量，则权重 $w_i$ 由下式给出：\n$$\nw_i = \\mu_0 (v_{i,1})^2\n$$\n其中 $v_{i,1}$ 是 $\\mathbf{v}_i$ 的第一个分量，$\\mu_0$ 是权重函数的总质量，$\\mu_0 = \\int_{-1}^1 1 \\,dx = 2$。\n\n该算法包括以下步骤：\n1.  对于给定的阶数 $n$，使用系数 $\\alpha_k=0$ 和 $\\beta_k = k/\\sqrt{4k^2-1}$ 构建 $n \\times n$ 的雅可比矩阵 $J_n$。\n2.  计算 $J_n$ 的特征值以及归一化特征向量的第一个分量。这可以通过使用针对对称矩阵的数值特征求解器高效完成。特征值即为节点 $\\{x_i\\}$。\n3.  使用公式 $w_i = 2(v_{i,1})^2$ 计算权重 $\\{w_i\\}$。\n\n实施此过程以解决指定的四个测试用例：\n-   **测试 A：** 对于 $n=4$，求积法则对最高 $2n-1=7$ 次的多项式是精确的。我们计算 $k=0, \\dots, 7$ 时的 $\\int_{-1}^1 x^k dx$，并找出与精确解析值（偶数 $k$ 为 $2/(k+1)$，奇数 $k$ 为 $0$）的最大偏差。这个偏差应该在机器精度的数量级上。\n-   **测试 B：** 对于 $n=32$，我们近似计算 $\\int_{-1}^1 e^x dx$。由于 $e^x$ 是解析函数，高斯求积呈指数收敛。计算与精确值 $e - e^{-1}$ 的绝对误差，以展示其高精度。\n-   **测试 C：** 对于 $n=128$，我们量化求积和对节点舍入误差的敏感性。我们使用双精度节点 $\\{x_i\\}$ 计算总和 $Q = \\sum w_i e^{x_i}$。然后我们将节点舍入为单精度以获得 $\\{\\hat{x}_i\\}$，并重新计算总和 $\\hat{Q} = \\sum w_i e^{\\hat{x}_i}$。差值 $|Q - \\hat{Q}|$ 衡量了这种扰动的影响。这是评估大 $n$ 时求和计算数值稳定性的一个实用指标。\n-   **测试 D：** 对于 $n=128$，我们计算扰动本身的最大幅度 $\\max_i |x_i - \\hat{x}_i|$，以了解节点中引入的浮点舍入误差的大小。这对应于每个节点值周围的可表示单精度数之间间隙的半宽度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Golub-Welsch algorithm for Gauss-Legendre quadrature\n    and runs the specified test suite.\n    \"\"\"\n\n    def golub_welsch(n: int):\n        \"\"\"\n        Computes the n-point Gauss-Legendre quadrature nodes and weights.\n\n        Args:\n            n: The order of the quadrature rule.\n\n        Returns:\n            A tuple (nodes, weights), where each is a numpy array of length n.\n        \"\"\"\n        if n == 0:\n            return np.array([]), np.array([])\n        \n        # Calculate the off-diagonal elements (beta_k) of the Jacobi matrix\n        # for orthonormal Legendre polynomials.\n        # beta_k = k / sqrt(4*k^2 - 1) for k = 1, 2, ..., n-1.\n        k = np.arange(1, n, dtype=np.float64)\n        beta = k / np.sqrt(4 * k**2 - 1)\n        \n        # The Jacobi matrix J_n is symmetric and tridiagonal with zeros on the diagonal\n        # and beta_k on the off-diagonals.\n        # numpy.linalg.eigh is optimized for symmetric/Hermitian matrices.\n        J = np.diag(beta, k=1) + np.diag(beta, k=-1)\n        \n        # Eigenvalues are the quadrature nodes.\n        # Eigenvectors are needed for the weights.\n        # 'eigh' returns eigenvalues in ascending order.\n        nodes, evecs = np.linalg.eigh(J)\n        \n        # The weights are derived from the first component of the normalized eigenvectors.\n        # w_i = mu_0 * (v_{i,1})^2, where mu_0 = integral of weight function from -1 to 1.\n        # For w(x)=1, mu_0 = 2.\n        # The first components of all eigenvectors are in the first row of the evecs matrix.\n        weights = 2.0 * evecs[0, :]**2\n        \n        return nodes, weights\n\n    results = []\n\n    # Test A: Exactness for polynomials up to degree 2n-1\n    n_A = 4\n    nodes_A, weights_A = golub_welsch(n_A)\n    max_dev = 0.0\n    for k in range(2 * n_A):\n        # Quadrature approximation of integral(x^k) from -1 to 1\n        quad_approx = np.sum(weights_A * (nodes_A**k))\n        \n        # Exact integral\n        if k % 2 != 0:\n            exact_integral = 0.0\n        else:\n            exact_integral = 2.0 / (k + 1.0)\n            \n        max_dev = max(max_dev, abs(quad_approx - exact_integral))\n    results.append(max_dev)\n\n    # Test B: Accuracy for a smooth function\n    n_B = 32\n    nodes_B, weights_B = golub_welsch(n_B)\n    quad_approx_B = np.sum(weights_B * np.exp(nodes_B))\n    exact_integral_B = np.exp(1.0) - np.exp(-1.0)\n    abs_error_B = abs(quad_approx_B - exact_integral_B)\n    results.append(abs_error_B)\n\n    # Test C  D: Sensitivity to node rounding for large n\n    n_C = 128\n    nodes_C, weights_C = golub_welsch(n_C)\n    \n    # Calculate the quadrature sum with double-precision nodes\n    Q = np.sum(weights_C * np.exp(nodes_C))\n    \n    # Round nodes to single-precision and back to double-precision\n    # to simulate using single-precision nodes in a double-precision calculation\n    rounded_nodes_C = np.array(np.float32(nodes_C), dtype=np.float64)\n    \n    # Calculate the quadrature sum with the rounded nodes\n    Q_hat = np.sum(weights_C * np.exp(rounded_nodes_C))\n    \n    # Test C result: absolute difference |Q - Q_hat|\n    diff_Q = abs(Q - Q_hat)\n    results.append(diff_Q)\n    \n    # Test D result: maximum absolute perturbation |x_i - x_hat_i|\n    max_node_pert = np.max(np.abs(nodes_C - rounded_nodes_C))\n    results.append(max_node_pert)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}