{
    "hands_on_practices": [
        {
            "introduction": "复合求积法则的误差分析通常假设被积函数具有足够的光滑性。但如果函数在积分区间内存在导数不连续点，将会发生什么？本练习将通过一个经典例子 $f(x)=|x-0.5|$ 来探讨这一问题，它将经验性地展示标准方法在这种情形下的精度下降，并引导你通过在奇点处分割积分域的策略来恢复高精度。",
            "id": "3214983",
            "problem": "考虑区间 $\\left[0,1\\right]$ 上的函数 $f(x)=\\lvert x-0.5 \\rvert$。$f(x)$ 的导数在 $x=0.5$ 处存在间断点，这对那些误差分析假设函数足够光滑的求积法则构成了挑战。\n\n从数值求积的基本定义出发，即通过在子区间上对被积函数的低阶多项式插值进行积分来近似定积分，设计并实现复合牛顿-柯特斯（Newton–Cotes）求积法则，并分析它们在处理这个非光滑函数时的行为。\n\n您必须实现以下三种方法：\n\n1. 复合梯形法则，严格基于在 $\\left[0,1\\right]$ 上的 $N$ 个等长子区间上对 1 次插值（分段线性）进行积分。\n\n2. 复合辛普森法则，基于在将 $\\left[0,1\\right]$ 均匀划分为 $N$ 个子区间上对 2 次插值（分段二次）进行积分，要求 $N$ 为偶数，以便该法则以两个子区间为一组进行应用。\n\n3. 分段复合辛普森法则，首先在 $c=0.5$ 处将 $\\left[0,1\\right]$ 分割为 $\\left[0,0.5\\right]$ 和 $\\left[0.5,1\\right]$，然后分别在每个子区间上应用复合辛普森法则。为确保辛普森分组的有效性，您必须为每个半区间分配偶数个子区间，并尽可能使子区间总数之和等于原始的 $N$。具体而言：\n   - 如果 $N$ 是奇数，则分段复合辛普森法则不适用。\n   - 如果 $N$ 是偶数且可被 4 整除，则使用 $N_{\\text{left}}=N/2$ 和 $N_{\\text{right}}=N/2$。\n   - 如果 $N$ 是偶数但不能被 4 整除，则选择 $N_{\\text{left}}=N/2-1$ 和 $N_{\\text{right}}=N/2+1$。\n   - 如果 $N_{\\text{left}}$ 或 $N_{\\text{right}}$ 为非正数，则分段复合辛普森法则不适用。\n\n为了进行误差评估，请使用定积分的核心微积分定义和绝对值的性质，推导积分 $\\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx$ 的精确值，并使用此精确值计算绝对误差。对于任何方法和任何 $N$，绝对误差定义为\n$$\nE_N = \\left\\lvert Q_N - I \\right\\rvert,\n$$\n其中 $Q_N$ 是使用 $N$ 个子区间的数值求积结果，$I$ 是精确积分值。\n\n为了进行经验收敛性分析，对于每种方法和每对 $(N,2N)$，定义经验阶为\n$$\np = \\frac{\\log\\left(E_N / E_{2N}\\right)}{\\log(2)}.\n$$\n如果某个方法对于给定的 $N$ 不适用，或者 $E_N$ 或 $E_{2N}$ 在数值上与 $0$ 无法区分（使用阈值 $10^{-15}$），则将经验阶报告为哨兵值 $-1.0$。\n\n您的程序必须为下面的每个测试用例计算一个包含九个浮点数的列表，顺序如下：\n- 复合梯形法则的 $E_N$，\n- 复合梯形法则的 $E_{2N}$，\n- 复合梯形法则的 $p$，\n- 在整个区间上复合辛普森法则的 $E_N$，\n- 在整个区间上复合辛普森法则的 $E_{2N}$，\n- 在整个区间上复合辛普森法则的 $p$，\n- 分段复合辛普森法则的 $E_N$，\n- 分段复合辛普森法则的 $E_{2N}$，\n- 分段复合辛普森法则的 $p$。\n\n如果某个方法对于给定的 $N$ 不适用，请对相应的误差或阶使用 $-1.0$。此问题不涉及角度；因此，无需指定角度单位。不涉及物理单位。\n\n测试套件：\n为以下 $(N,2N)$ 对计算上述输出：\n- $(2,4)$,\n- $(4,8)$,\n- $(6,12)$,\n- $(5,10)$,\n- $(8,16)$.\n\n这些案例涵盖了粗分辨率、$x=0.5$ 与辛普森分组边界重合的情况、$x=0.5$ 位于辛普森分组内部的情况，以及一个 $N$ 为奇数导致基于辛普森法则的方法在 $N$ 时不适用的情况。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由每个测试用例的列表组成的逗号分隔列表，不含空格，并用方括号括起来。例如，最终输出应类似于\n$[ [\\text{案例1的九个数字}],[\\text{案例2的九个数字}],\\ldots ]$，\n使用您的程序计算出的确切数值代替占位符。",
            "solution": "该问题是有效的。它提出了一个数值分析中定义明确的任务，其基础是数值求积的既定原则。函数、区间、方法和评估标准都具有足够的精度，并且在科学上是合理的。该问题是一个经典的演示，说明了被积函数的光滑性如何影响数值积分方案的收敛速度。\n\n### 1. 精确积分计算\n\n计算误差需要积分 $I = \\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx$ 的精确值作为参考。绝对值函数是分段定义的。我们在绝对值参数变号的点（即 $x=0.5$）处分割积分。\n\n$$\nI = \\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx = \\int_{0}^{0.5} -(x-0.5) \\, dx + \\int_{0.5}^{1} (x-0.5) \\, dx\n$$\n\n$$\nI = \\int_{0}^{0.5} (0.5-x) \\, dx + \\int_{0.5}^{1} (x-0.5) \\, dx\n$$\n\n计算这两个定积分：\n$$\n\\int_{0}^{0.5} (0.5-x) \\, dx = \\left[ 0.5x - \\frac{x^2}{2} \\right]_{0}^{0.5} = \\left( 0.5(0.5) - \\frac{(0.5)^2}{2} \\right) - (0) = 0.25 - \\frac{0.25}{2} = 0.125\n$$\n\n$$\n\\int_{0.5}^{1} (x-0.5) \\, dx = \\left[ \\frac{x^2}{2} - 0.5x \\right]_{0.5}^{1} = \\left( \\frac{1^2}{2} - 0.5(1) \\right) - \\left( \\frac{(0.5)^2}{2} - 0.5(0.5) \\right) = (0.5 - 0.5) - (0.125 - 0.25) = 0 - (-0.125) = 0.125\n$$\n\n积分的精确值是这两部分之和：\n$$\nI = 0.125 + 0.125 = 0.25\n$$\n从几何上看，这代表了两个相同的直角三角形的面积，每个三角形的底为 $0.5$，高为 $0.5$。面积为 $2 \\times \\frac{1}{2} \\times 0.5 \\times 0.5 = 0.25$。\n\n### 2. 数值求积方法\n\n设区间为 $[a, b]$，划分为 $N$ 个宽度为 $h = (b-a)/N$ 的等长子区间。节点为 $x_i = a + i h$，其中 $i=0, 1, \\ldots, N$。被积函数为 $f(x) = \\lvert x-0.5 \\rvert$。\n\n#### 2.1. 复合梯形法则\n该法则通过对每个子区间 $[x_i, x_{i+1}]$ 上的线性插值形成的梯形面积求和来近似积分。公式为：\n$$\nQ_N^{\\text{trap}} = h \\left( \\frac{f(x_0) + f(x_N)}{2} + \\sum_{i=1}^{N-1} f(x_i) \\right)\n$$\n假设被积函数是二次连续可微的（$f \\in C^2$），梯形法则的标准误差阶为 $O(h^2)$。我们的函数 $f(x)$ 仅属于 $C^0$，其一阶导数有跳跃间断点。然而，梯形法则对线性函数是精确的。当 $N$ 是偶数时，其中一个网格点 $x_{N/2}$ 将与 $x=0.5$ 处的间断点重合。由于 $f(x)$ 在 $[0, 0.5]$ 和 $[0.5, 1]$ 上是线性的，并且节点关于 $x=0.5$ 对称，梯形法则将精确地计算分段线性段的面积之和。因此，对于任何偶数 $N$，数值结果都将是精确的，误差 $E_N$ 将为 $0$。对于奇数 $N$，$x=0.5$ 位于一个子区间内，预计会产生非零误差。\n\n#### 2.2. 复合辛普森法则\n该法则对成对的子区间（分组）上的分段二次插值进行积分。它要求子区间数量 $N$ 为偶数。公式为：\n$$\nQ_N^{\\text{simp}} = \\frac{h}{3} \\left( f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right)\n$$\n假设 $f \\in C^4$，标准误差为 $O(h^4)$。由于我们的函数不光滑，无法达到这个收敛速度。辛普森法则对最高三次的多项式是精确的。关键因素在于 $x=0.5$ 处的间断点是落在分组边界上还是分组内部。对于 $N$ 个子区间，有 $N/2$ 个分组 $[x_{2k}, x_{2k+2}]$。如果 $x=0.5$ 是某个整数 $k$ 的节点 $x_{2k}$，则间断点位于分组边界上。这种情况发生在 $N$ 是 4 的倍数时。在这种情况下，函数在每个分组内都是线性的（例如，在 $[0, 0.5]$ 和 $[0.5, 1]$ 上），由于辛普森法则对线性函数是精确的，因此在每个半区间上的积分都是精确的，总误差为 $0$。如果 $N$ 是偶数但不是 4 的倍数（例如，$N=2, 6, 10, \\dots$），则点 $x=0.5$ 落在一个分组内部，二次插值无法捕捉到这个“拐点”，导致显著误差。在这种情况下，收敛速度会降至 $O(h^2)$。\n\n#### 2.3. 分段复合辛普森法则\n这种自适应策略明确地处理了间断点。定义域 $[0, 1]$ 被分割为 $[0, 0.5]$ 和 $[0.5, 1]$。然后，复合辛普森法则分别应用于每个子域。\n$$\nQ_N^{\\text{split}} = Q_{N_{\\text{left}}}^{\\text{simp}}(f, [0, 0.5]) + Q_{N_{\\text{right}}}^{\\text{simp}}(f, [0.5, 1])\n$$\n根据问题规则，总区间数 $N$ 被划分为 $N_{\\text{left}}$ 和 $N_{\\text{right}}$，确保两者都是正偶数。在每个子域 $[0, 0.5]$ 和 $[0.5, 1]$ 内，函数 $f(x)$ 是一个简单的线性函数。由于辛普森法则对最高三次的多项式提供精确结果，因此它对这些线性段也是精确的。因此，只要此方法适用，$Q_N^{\\text{split}}$ 将等于精确积分 $I$，误差 $E_N$ 将为 $0$。该方法不适用于奇数 $N$ 或 $N=2$（根据指定的分区规则，$N_{\\text{left}}$ 会变为非正数）。\n\n### 3. 误差和收敛性分析\n\n绝对误差为 $E_N = \\lvert Q_N - I \\rvert$。经验收敛阶 $p$ 使用来自两个分辨率 $N$ 和 $2N$ 的误差计算：\n$$\np = \\frac{\\log(E_N / E_{2N})}{\\log(2)}\n$$\n该公式估计了误差关系 $E_N \\approx C h^p \\propto C (1/N)^p$ 中的指数。如果 $E_N$ 或 $E_{2N}$ 在数值上为零（低于阈值 $10^{-15}$），或者如果方法对给定的 $N$ 不适用，则经验阶 $p$ 被赋予哨兵值 $-1.0$。\n\n### 4. 算法实现\n\n解决方案用 Python 实现。\n1.  定义函数 $f(x)$ 和精确积分值 $I=0.25$。\n2.  实现三个独立的函数：`composite_trapezoidal`、`composite_simpson` 和 `split_composite_simpson`。每个函数都接受被积函数、区间限制和子区间数 $N$ 作为输入。如果方法的先决条件未满足（例如，辛普森法则的 $N$ 为奇数），它们返回数值积分结果或一个哨兵值（例如 $-1.0$）。\n3.  `split_composite_simpson` 函数封装了将 $N$ 划分为 $N_{\\text{left}}$ 和 $N_{\\text{right}}$ 的特定逻辑，并在两个子域上调用 `composite_simpson` 函数。\n4.  一个辅助函数计算经验阶 $p$，处理返回哨兵值 $-1.0$ 的指定条件。\n5.  程序的主体部分遍历测试用例列表 $(N, 2N)$。对于每个用例，它为三种方法中的每一种计算九个所需值：$(E_N, E_{2N}, p)$。\n6.  结果被存储并格式化为最终的列表之列表字符串。低于 $10^{-15}$ 阈值的误差在报告时被视为 $0.0$，但会触发 $p=-1.0$ 的条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for f(x) = |x - 0.5| on [0, 1].\n    \"\"\"\n    \n    # Define the function, its exact integral, and the zero threshold.\n    f = lambda x: np.abs(x - 0.5)\n    I_EXACT = 0.25\n    ZERO_THRESHOLD = 1e-15\n\n    def composite_trapezoidal(func, a, b, N):\n        \"\"\"Computes the integral using the composite trapezoidal rule.\"\"\"\n        if N == 0:\n            return np.nan  # Invalid input\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        integral = h * (np.sum(y) - 0.5 * (y[0] + y[-1]))\n        return integral\n\n    def composite_simpson(func, a, b, N):\n        \"\"\"Computes the integral using the composite Simpson's rule.\"\"\"\n        if N == 0 or N % 2 != 0:\n            return -1.0  # Sentinel for non-applicability\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        # Sum of terms with odd indices (y_1, y_3, ...)\n        s1 = np.sum(y[1:-1:2])\n        # Sum of terms with even indices (y_2, y_4, ...)\n        s2 = np.sum(y[2:-2:2])\n        integral = (h / 3.0) * (y[0] + 4.0 * s1 + 2.0 * s2 + y[-1])\n        return integral\n\n    def split_composite_simpson(func, a, b, c, N):\n        \"\"\"Computes the integral using the split-composite Simpson's rule.\"\"\"\n        if N % 2 != 0:\n            return -1.0\n        \n        if N % 4 == 0:\n            N_left = N // 2\n            N_right = N // 2\n        else: # N is even but not divisible by 4\n            N_left = N // 2 - 1\n            N_right = N // 2 + 1\n\n        if N_left = 0 or N_right = 0:\n            return -1.0\n            \n        I_left = composite_simpson(func, a, c, N_left)\n        I_right = composite_simpson(func, c, b, N_right)\n        \n        # This check is redundant given N_left/right logic but kept for robustness\n        if I_left == -1.0 or I_right == -1.0:\n            return -1.0\n            \n        return I_left + I_right\n\n    def calculate_p(E_N, E_2N):\n        \"\"\"Calculates the empirical order of convergence.\"\"\"\n        if E_N == -1.0 or E_2N == -1.0:\n            return -1.0\n        if E_N  ZERO_THRESHOLD or E_2N  ZERO_THRESHOLD:\n            return -1.0\n        return np.log(E_N / E_2N) / np.log(2.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 4),\n        (4, 8),\n        (6, 12),\n        (5, 10),\n        (8, 16)\n    ]\n\n    all_results = []\n    for N, N2 in test_cases:\n        case_results = []\n\n        # 1. Composite Trapezoidal Rule\n        Q_trap_N = composite_trapezoidal(f, 0.0, 1.0, N)\n        E_trap_N = np.abs(Q_trap_N - I_EXACT)\n        \n        Q_trap_N2 = composite_trapezoidal(f, 0.0, 1.0, N2)\n        E_trap_N2 = np.abs(Q_trap_N2 - I_EXACT)\n        \n        p_trap = calculate_p(E_trap_N, E_trap_N2)\n        case_results.extend([E_trap_N, E_trap_N2, p_trap])\n\n        # 2. Composite Simpson Rule\n        Q_simp_N = composite_simpson(f, 0.0, 1.0, N)\n        E_simp_N = -1.0 if Q_simp_N == -1.0 else np.abs(Q_simp_N - I_EXACT)\n        \n        Q_simp_N2 = composite_simpson(f, 0.0, 1.0, N2)\n        E_simp_N2 = -1.0 if Q_simp_N2 == -1.0 else np.abs(Q_simp_N2 - I_EXACT)\n        \n        p_simp = calculate_p(E_simp_N, E_simp_N2)\n        case_results.extend([E_simp_N, E_simp_N2, p_simp])\n\n        # 3. Split-Composite Simpson Rule\n        Q_split_N = split_composite_simpson(f, 0.0, 1.0, 0.5, N)\n        E_split_N = -1.0 if Q_split_N == -1.0 else np.abs(Q_split_N - I_EXACT)\n\n        Q_split_N2 = split_composite_simpson(f, 0.0, 1.0, 0.5, N2)\n        E_split_N2 = -1.0 if Q_split_N2 == -1.0 else np.abs(Q_split_N2 - I_EXACT)\n        \n        p_split = calculate_p(E_split_N, E_split_N2)\n        case_results.extend([E_split_N, E_split_N2, p_split])\n        \n        # Clean up near-zero errors for reporting\n        cleaned_results = [val if abs(val) > ZERO_THRESHOLD else 0.0 for val in case_results]\n        # Restore sentinel values\n        for i, val in enumerate(case_results):\n            if val == -1.0:\n                cleaned_results[i] = -1.0\n\n        all_results.append(cleaned_results)\n\n    # Final print statement in the exact required format.\n    formatted_output = '[' + ','.join([f'[{\",\".join(map(str, case))}]' for case in all_results]) + ']'\n    print(formatted_output)\n\nsolve()\n```"
        },
        {
            "introduction": "当被积函数在积分端点趋于无穷大时，标准的求积公式便无法直接应用，这类积分被称为瑕积分。本练习将教你一种处理此类问题的有效技巧：变量替换。通过一个巧妙的代换 $x=t^k$，你可以将一个在端点处具有奇性的被积函数“正则化”，使其变成一个在整个积分域上都表现良好的光滑函数，从而能用标准的辛普森法则高效求解。",
            "id": "3214941",
            "problem": "考虑一个在有限区间上的幂律奇异被积函数的广义积分，其定义为黎曼积分 $$I=\\int_{0}^{1} x^{-0.3}\\,dx.$$ 被积函数在左端点处发散，这使得直接使用需要在端点求值的复合数值积分公式变得复杂。通过变量代换可以正则化其端点行为。令 $$x=t^{k},$$ 其中 $$k0,$$ 并应用链式法则将积分用新变量 $$t\\in[0,1]$$ 表示。请确定变换后以 $$t$$ 和 $$k$$ 表示的被积函数，并找出使该被积函数在 $$t=0$$ 处连续且在闭区间 $$[0,1]$$ 上为有限值的 $$k$$ 所需满足的条件。\n\n从黎曼积分的定义和通过多项式插值构造的牛顿-柯特斯公式思想出发，设计并实现复合辛普森法则，以近似计算在 $$t$$-域上的变换后积分。使用区间的均匀划分，划分为偶数个子区间 $$N,$$ 步长为 $$h=(b-a)/N.$$ 确保算法在两个端点和所有内部节点上都对变换后的被积函数进行求值。如果 $$k$$ 的正则性条件不满足（即变换后的被积函数在 $$t=0$$ 处发散），则通过将下限 $$0$$ 替换为 $$a=10^{-8}$$ 来进行截断，并在 $$[a,1]$$ 上应用复合辛普森法则。\n\n使用微积分基本定理求得 $$I$$ 的精确解析值，并报告每个数值近似值相对于此精确值的绝对误差，作为每个测试用例的最终标量输出。计算不涉及角度，也没有物理单位；请将数值结果以十进制浮点数形式报告。\n\n您的实现必须对以下测试套件产生结果，该套件涵盖一个边界情况（精确正则化阈值）、典型的正则化情况以及一个需要截断的非正则化情况：\n\n- 测试用例 1: $$k=\\frac{10}{7},\\ N=2.$$\n- 测试用例 2: $$k=1.5,\\ N=20.$$\n- 测试用例 3: $$k=2.0,\\ N=20.$$\n- 测试用例 4: $$k=1.2,\\ N=200.$$ (此情况不满足正则性条件，因此必须使用 $$a=10^{-8}$$ 进行截断。)\n- 测试用例 5: $$k=3.0,\\ N=10.$$\n\n您的程序必须计算并打印单行输出，其中包含所有五个测试用例的绝对误差列表，格式为方括号括起来的逗号分隔列表，每个数字四舍五入到十二位有效数字。例如，一个有效的输出格式为 $$[e_{1},e_{2},e_{3},e_{4},e_{5}],$$ 其中每个 $$e_{i}$$ 是第 $$i$$-个测试用例绝对误差的十进制表示。",
            "solution": "该问题要求对广义积分\n$$I = \\int_{0}^{1} x^{-0.3}\\,dx$$\n进行分析和数值近似。分析过程包括将积分变换为正则形式，确定此正则化的条件，并实现一种数值积分方案（复合辛普森法则）来近似该积分。数值结果需要与精确解析值进行比较。\n\n### 步骤1：积分的解析求值\n\n该积分为广义积分，因为被积函数 $f(x) = x^{-0.3}$ 在积分下限 $x=0$ 处有一条垂直渐近线。然而，由于指数 $-0.3$ 大于 $-1$，该积分是收敛的。我们可以使用微积分基本定理求出其精确值。\n$$I = \\int_{0}^{1} x^{-0.3}\\,dx = \\lim_{a \\to 0^+} \\int_{a}^{1} x^{-0.3}\\,dx$$\n$x^{-0.3}$ 的原函数是 $\\frac{x^{-0.3+1}}{-0.3+1} = \\frac{x^{0.7}}{0.7}$。\n计算该定积分：\n$$I = \\lim_{a \\to 0^+} \\left[ \\frac{x^{0.7}}{0.7} \\right]_{a}^{1} = \\lim_{a \\to 0^+} \\left( \\frac{1^{0.7}}{0.7} - \\frac{a^{0.7}}{0.7} \\right)$$\n由于 $0.7  0$，$\\lim_{a \\to 0^+} a^{0.7} = 0$。因此，\n$$I = \\frac{1}{0.7} - 0 = \\frac{10}{7}.$$\n该积分的精确解析值为 $I_{\\text{exact}} = \\frac{10}{7}$。\n\n### 步骤2：变量代换与正则化\n\n为了在数值上处理 $x=0$ 处的奇点，我们应用变量代换 $x = t^k$，其中某个 $k  0$。\n微分为 $dx = k t^{k-1} dt$。\n$t$ 的积分限可以通过变换 $x$ 的积分限得到：\n- 当 $x=0$ 时，$t^k=0 \\implies t=0$。\n- 当 $x=1$ 时，$t^k=1 \\implies t=1$。\n$t$ 的积分区间仍为 $[0, 1]$。\n\n将 $x$ 和 $dx$ 代入积分，我们得到以 $t$ 表示的变换后积分：\n$$I = \\int_{0}^{1} (t^k)^{-0.3} (k t^{k-1}) dt$$\n变换后的被积函数，我们称之为 $g(t, k)$，是：\n$$g(t, k) = t^{-0.3k} \\cdot k t^{k-1} = k t^{k-1-0.3k} = k t^{0.7k-1}$$\n积分现在表示为：\n$$I = \\int_{0}^{1} k t^{0.7k-1} dt$$\n\n### 步骤3：正则性条件\n\n变换的目的是得到一个在闭区间 $[0, 1]$ 上连续且有限的被积函数 $g(t, k)$。潜在的问题点在 $t=0$ 处。当 $t \\to 0^+$ 时，$g(t,k)$ 的行为取决于指数 $p = 0.7k-1$ 的符号。\n1.  如果 $p  0$：当 $t \\to 0^+$ 时，$t^p$ 项趋于无穷大。被积函数在 $t=0$ 处是奇异的。\n2.  如果 $p = 0$：$g(t, k) = k t^0 = k$，这是一个常数，因此对于所有 $t$ 都是有限且连续的。\n3.  如果 $p  0$：当 $t \\to 0^+$ 时，$t^p$ 项趋于 $0$。被积函数是连续的，并且在 $t=0$ 处的值为 $0$。\n\n为了使变换后的被积函数在闭区间 $[0, 1]$ 上连续且有限，其指数必须为非负数。这导出了正则性条件：\n$$0.7k - 1 \\geq 0$$\n$$0.7k \\geq 1$$\n$$k \\geq \\frac{1}{0.7} \\implies k \\geq \\frac{10}{7}$$\n\n如果不满足此条件（即 $k  10/7$），变换后的被积函数 $g(t, k)$ 在 $t=0$ 处仍然是奇异的，问题规定积分域应截断为 $[10^{-8}, 1]$。\n\n### 步骤4：使用复合辛普森法则进行数值近似\n\n复合辛普森法则用于近似积分 $\\int_a^b f(t) dt$。区间 $[a, b]$ 被划分为偶数个子区间 $N$，每个子区间的宽度为 $h = (b-a)/N$。节点为 $t_i = a + ih$，其中 $i=0, 1, \\dots, N$。其公式为：\n$$S_N = \\frac{h}{3} \\left[ f(t_0) + 4\\sum_{i=1}^{N/2} f(t_{2i-1}) + 2\\sum_{i=1}^{N/2-1} f(t_{2i}) + f(t_N) \\right]$$\n\n每个测试用例 $(k, N)$ 的算法如下：\n1.  设置精确值 $I_{\\text{exact}} = 10/7$。\n2.  定义变换后的被积函数 $g(t, k) = k t^{0.7k-1}$。\n3.  检查正则性条件。\n    - 如果 $k \\geq 10/7$：积分为正则。积分区间为 $[a, b] = [0, 1]$。在此区间上计算 $g(t, k)$ 的数值近似值 $I_{\\text{approx}} = S_N$。\n    - 如果 $k  10/7$：被积函数为奇异。积分区间被截断为 $[a, b] = [10^{-8}, 1]$。在此截断的区间上计算 $g(t, k)$ 的数值近似值 $I_{\\text{approx}} = S_N$。\n4.  计算绝对误差：$E = |I_{\\text{approx}} - I_{\\text{exact}}|$。\n\n将此过程应用于所提供的五个测试用例中的每一个。对于 $k=10/7$ 的情况，被积函数是常数函数 $g(t) = 10/7$。辛普森法则对次数最高为3的多项式是精确的，因此它对于常数函数也将是精确的，从而产生的绝对误差为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for a set of test cases.\n    The solution involves a change of variables to regularize a singular integral,\n    followed by approximation using composite Simpson's rule. The absolute error\n    of the approximation is calculated against the exact analytic value.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10.0/7.0, 2),    # Case 1: k at regularization threshold\n        (1.5, 20),        # Case 2: Regularized case\n        (2.0, 20),        # Case 3: Regularized case\n        (1.2, 200),       # Case 4: Non-regularized, requires truncation\n        (3.0, 10),        # Case 5: Regularized case\n    ]\n\n    # The exact value of the integral I = integral(x^-0.3, dx, 0, 1) is 10/7.\n    i_exact = 10.0 / 7.0\n\n    # The critical value of k for regularization.\n    k_critical = 10.0 / 7.0\n\n    results = []\n\n    def composite_simpson(f, a, b, N):\n        \"\"\"\n        Calculates the definite integral of a function f from a to b\n        using composite Simpson's rule with N subintervals.\n        N must be an even integer.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"Number of subintervals N must be even.\")\n        \n        h = (b - a) / N\n        t_nodes = np.linspace(a, b, N + 1)\n        y_nodes = f(t_nodes)\n\n        # Simpson's rule formula:\n        # h/3 * [y_0 + 4*y_1 + 2*y_2 + ... + 2*y_{N-2} + 4*y_{N-1} + y_N]\n        integral = (h / 3.0) * (\n            y_nodes[0] + \n            y_nodes[-1] + \n            4.0 * np.sum(y_nodes[1:-1:2]) + \n            2.0 * np.sum(y_nodes[2:-2:2])\n        )\n        return integral\n\n    for k, N in test_cases:\n        # The exponent in the transformed integrand g(t) = k*t^p\n        p = 0.7 * k - 1.0\n\n        # Create the transformed integrand function.\n        # Numpy handles powers of 0 correctly:\n        # 0**p = 0 for p > 0\n        # 0**0 = 1\n        # t is never 0 for p  0 due to truncation.\n        g = lambda t: k * t**p\n\n        # Determine integration interval based on regularity condition.\n        if k >= k_critical:\n            # Regular case: integrate over [0, 1]\n            a, b = 0.0, 1.0\n        else:\n            # Singular case: integrate over truncated interval [1e-8, 1]\n            a, b = 1e-8, 1.0\n        \n        # Approximate the integral using composite Simpson's rule\n        i_approx = composite_simpson(g, a, b, N)\n        \n        # Calculate the absolute error against the true value of the original integral\n        error = np.abs(i_approx - i_exact)\n        results.append(error)\n\n    # Format the results to 12 significant digits and join them into a string.\n    # The 'g' format specifier handles scientific and fixed-point notation appropriately.\n    formatted_results = [f\"{res:.12g}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于像高斯函数这样在大部分区域平坦、仅在局部有剧烈变化的函数，使用均匀网格进行积分是低效的。本练习将引导你实现并探索一种更智能的策略：自适应辛普森方法。通过将其与传统的均匀复合辛普森方法进行对比，你将直观地看到自适应算法如何通过递归地加密“有趣”的区域来集中计算资源，从而以更少的计算量达到更高的精度。",
            "id": "3214881",
            "problem": "考虑在区间 $[0,1]$ 上对函数 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ 的定积分进行数值评估。任务是实现两种基于辛普森法则的复合数值积分方法，并比较它们的精度和计算量：\n\n1. 一种均匀复合辛普森方法，将 $[0,1]$ 划分为 $N$ 个相等的子区间，其中 $N$ 是一个偶数。如果提供了奇数 $N$，实现时必须将其增加1，以使该法则适用。\n\n2. 一种具有局部误差控制的自适应复合辛普森方法，该方法递归地细分一个区间，直到满足指定的局部绝对容差 $\\text{tol}$。局部误差控制必须通过比较一个区间上的辛普森近似值与其两个半区间上辛普森近似值之和来实施，并通过在子区间上分配容差的方式来确保全局绝对误差得到控制。\n\n该实现应基于以下基本原理构建：\n\n- 多项式插值：通过三个点用二次插值多项式逼近一个区间上足够光滑的函数，并对该插值多项式进行精确积分。\n- 基于复合多项式的求积误差行为：对于足够光滑的 $f$，辛普森法则在单个面板上的截断误差与区间长度的五次方成正比，当均匀应用时，产生四阶全局收敛率。\n\n使用高斯函数的已知反导数（以误差函数表示）计算积分的真实值，并将其用作误差计算的基准真相。\n\n对于每种方法，报告：\n- 相对于真实积分的绝对误差。\n- 所使用的函数求值次数。\n\n程序必须实现这两种方法，并运行以下测试套件，其中每个测试用例是一对 $(\\text{tol}, N)$：\n\n- 测试用例1（正常路径）：$\\text{tol} = 10^{-6}$，$N = 100$。\n- 测试用例2（更严格的容差，更精细的网格）：$\\text{tol} = 10^{-8}$，$N = 1000$。\n- 测试用例3（更宽松的容差，更粗糙的网格）：$\\text{tol} = 10^{-4}$，$N = 10$。\n- 测试用例4（具有最少均匀面板的边缘情况）：$\\text{tol} = 10^{-10}$，$N = 2$。\n- 测试用例5（非常严格的容差）：$\\text{tol} = 10^{-12}$，$N = 200$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。此列表的每个元素对应一个测试用例，并且本身必须是按以下顺序排列的四个值的列表：$[\\text{自适应绝对误差}, \\text{自适应求值次数}, \\text{均匀绝对误差}, \\text{均匀求值次数}]$。例如，两个用例的输出形式为 $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$。\n\n此问题不涉及物理单位，也不需要角度或百分比。最终输出值必须是实数或整数（视情况而定），不带任何附加文本。",
            "solution": "用户提供了一个有效的问题陈述。\n\n### 步骤1：提取给定信息\n- **待积分函数**：$f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$\n- **积分区间**：$[0, 1]$\n- **方法1**：均匀复合辛普森法则，使用 $N$ 个相等的子区间。如果 $N$ 是奇数，则必须加1。\n- **方法2**：自适应复合辛普森法则，具有局部绝对容差 $\\text{tol}$。局部误差通过比较同一区间上的单面板辛普森法则近似值（$S_1$）与双面板近似值（$S_2$）来估计。\n- **真实值**：使用误差函数 $\\text{erf}(x)$ 计算。\n- **每种方法的输出**：相对于真实值的绝对误差和总函数求值次数。\n- **测试套件**：一系列测试用例，每个用例由一对 $(\\text{tol}, N)$ 定义：\n    1. $(\\text{tol} = 10^{-6}, N = 100)$\n    2. $(\\text{tol} = 10^{-8}, N = 1000)$\n    3. $(\\text{tol} = 10^{-4}, N = 10)$\n    4. $(\\text{tol} = 10^{-10}, N = 2)$\n    5. $(\\text{tol} = 10^{-12}, N = 200)$\n- **输出格式**：一行文本：`[[自适应绝对误差, 自适应求值次数, 均匀绝对误差, 均匀求值次数], ...]`，包含所有测试用例。\n\n### 步骤2：使用提取的给定信息进行验证\n问题被评估为**有效**。\n\n- **科学依据**：该问题是数值分析中的一个标准练习，涉及实现和比较成熟的求积法则（复合辛普森法则，自适应求积）。该函数是一个高斯函数，它是解析的，因此是无限可微的（$C^\\infty$），使其成为高阶积分方法的理想选择。通过误差函数计算真实值的方法在数学上是合理的。\n- **适定性**：问题定义清晰。函数、区间、方法和参数都已指定。对于每个测试用例，都可以计算出唯一的数值结果。\n- **客观性**：语言精确，没有主观或模糊的术语。\n- **完整性和一致性**：问题是自包含的。提供了实现解决方案和运行测试所需的所有必要信息。没有内部矛盾。\n- **可行性**：所需的计算是标准的，并且在计算上是可行的。\n\n### 步骤3：结论和行动\n问题是有效的。将开发一个完整的解决方案。\n\n### 基于原理的解决方案\n任务是使用复合辛普森法则的两种变体来评估定积分 $I = \\int_0^1 f(x) \\,dx$，其中 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$，并比较它们的效率。\n\n**1. 积分的真实值**\n\n高斯函数的积分可以用误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$ 来表示。\n令 $I = \\int_0^1 \\exp\\left(-100(x - 0.3)^2\\right) \\,dx$。\n我们进行换元。令 $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$。这意味着 $du = 10 \\,dx$，或者 $dx = \\frac{1}{10} \\,du$。\n$u$ 的积分上下限是：\n- 当 $x = 0$ 时，$u = 10(0 - 0.3) = -3$。\n- 当 $x = 1$ 时，$u = 10(1 - 0.3) = 7$。\n\n积分变为：\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\n使用误差函数的定义：\n$$ \\int_a^b e^{-t^2} \\,dt = \\int_0^b e^{-t^2} \\,dt - \\int_0^a e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\n当 $a = -3$ 和 $b = 7$ 时，我们得到：\n$$ I = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] $$\n使用性质 $\\text{erf}(-z) = -\\text{erf}(z)$，真实值为：\n$$ I_{true} = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\n该值将作为我们计算数值方法绝对误差的基准真相。\n\n**2. 均匀复合辛普森法则**\n\n辛普森法则通过对通过点 $(a, f(a))$, $((a+b)/2, f((a+b)/2))$ 和 $(b, f(b))$ 的二次插值多项式进行积分，来近似函数 $f(x)$ 在区间 $[a, b]$ 上的积分。公式为：\n$$ S(a, b) = \\frac{b-a}{6} \\left[ f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right] $$\n复合辛普森法则是将此公式应用于积分区间的一个划分上。对于将 $[a, b]$ 均匀划分为 $N$ 个等宽子区间，宽度为 $h = (b-a)/N$（其中 $N$ 必须是偶数），点为 $x_i = a + ih$，其中 $i = 0, 1, \\dots, N$。积分近似为：\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right] $$\n此方法的函数求值次数为 $N+1$。根据问题要求，如果给定的 $N$ 是奇数，则将其增加到 $N+1$，使得求值次数为 $N+2$。\n\n**3. 自适应复合辛普森法则**\n\n自适应求积方法根据被积函数的局部行为调整求值点的密度。函数 $f(x)$ 在 $x=0.3$ 附近有一个尖峰，在其他地方几乎为零，这使其成为自适应方法的首选对象。该方法工作如下：\n\n对于一个区间 $[a, b]$，我们计算两个近似值：\n- 一个“粗略”近似值 $S_1$，使用 $[a, b]$ 上的单个辛普森面板。\n- 一个“精细”近似值 $S_2$，通过对半区间 $[a, m]$ 和 $[m, b]$ 上的两个辛普森面板求和得到，其中 $m = (a+b)/2$。\n\n在宽度为 $h=b-a$ 的区间上，单面板辛普森法则的误差约为 $E_1 \\approx -\\frac{h^5}{2880} f^{(4)}(\\xi)$。双面板近似的误差为 $E_2 \\approx 2 \\times \\left(-\\frac{(h/2)^5}{2880} f^{(4)}(\\eta)\\right) \\approx \\frac{1}{16} E_1$。\n真实积分 $I$可以写成 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。\n假设 $f^{(4)}$ 在 $[a, b]$ 上几乎是常数，我们可以在近似值和更精细的近似值误差 $E_2$ 之间建立关系：\n$$ S_2 - S_1 \\approx E_1 - E_2 \\approx 16 E_2 - E_2 = 15 E_2 $$\n因此，$S_2$ 的局部误差估计为 $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$。\n\n自适应算法是递归的：\n1.  对于给定的区间 $[a, b]$ 和局部容差 $\\text{tol}_{local}$，计算 $S_1$ 和 $S_2$。\n2.  计算误差估计 $\\text{err} = \\frac{|S_2 - S_1|}{15}$。\n3.  如果 $\\text{err}  \\text{tol}_{local}$，则该区间已充分解析。我们接受结果，并且为了提高精度，返回理查森外推值 $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$。这是对该区间上积分更准确的估计。\n4.  如果 $\\text{err} \\ge \\text{tol}_{local}$，则该区间未解析。将其细分为 $[a, m]$ 和 $[m, b]$。在每个子区间上递归调用算法，但每个子区间的容差减半：$\\text{tol}_{local}/2$。总积分是两次递归调用结果的总和。\n\n为确保全局误差控制，容差按区间宽度成比例分配。初始调用使用全局容差 $\\text{tol}$。在半区间上的每个递归步骤使用其父区间容差的一半。\n\n为避免冗余计算，端点和中点的函数值通过递归向下传递。在 $[a, b]$ 上的一个递归步骤，如果已知 $f(a)$、$f((a+b)/2)$ 和 $f(b)$，则只需要计算两个新值：$f((a+m)/2)$ 和 $f((m+b)/2)$。在整个递归过程中跟踪函数求值的总次数。\n\n这种自适应策略将计算量集中在高斯函数峰值周围的区域（$x \\approx 0.3$），即函数变化迅速的地方，而在 $x=0$ 和 $x=1$ 附近的平坦区域使用很少的求值，从而实现高效率。",
            "answer": "```python\n# 完整且可运行的 Python 3 代码位于此处。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    实现并比较用于积分高斯函数的均匀和自适应辛普森法则，然后运行一组测试用例。\n    \"\"\"\n    \n    # 1. 定义待积分的函数\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. 使用误差函数计算积分的“真实”值\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # 令 u = 10*(x-0.3)，则 du = 10*dx。\n    # 积分限：x=0 -> u=-3; x=1 -> u=7。\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # 使用 erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. 均匀复合辛普森法则的实现\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        使用均匀复合辛普森法则计算定积分。\n        \n        Args:\n            func: 待积分的函数。\n            a, b: 积分区间。\n            N: 子区间的数量（必须是偶数，如果不是则进行调整）。\n            \n        Returns:\n            一个元组 (积分值, 求值次数)。\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # 辛普森公式：h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # 切片：y[1:-1:2] 获取奇数索引，y[2:-2:2] 获取偶数索引。\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. 自适应复合辛普森法则的实现\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        递归自适应辛普森法则积分器的包装函数。\n        \n        Args:\n            func: 待积分的函数。\n            a, b: 积分区间。\n            tol: 期望的绝对误差容差。\n            \n        Returns:\n            一个元组 (积分值, 求值次数)。\n        \"\"\"\n        \n        eval_count = [0] # 使用列表作为可变计数器\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # 初始函数求值\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"自适应辛普森法则的递归辅助函数。\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # 粗略近似（1个面板）\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # 更精细的近似（2个面板）需要2次新的函数求值\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # 误差估计：|(S2 - S1) / 15| 是 S2 中误差的估计值。\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate  tol:\n            # 理查森外推法以获得更准确的结果\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # 细分并递归，分配容差\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. 定义测试用例\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. 运行测试套件\n    for tol, N in test_cases:\n        # 运行自适应方法\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # 运行均匀方法\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # 存储此测试用例的结果\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. 格式化并打印最终输出\n    # 输出格式必须精确：[[v1,v2,v3,v4],[v5,v6,v7,v8]]，不含空格。\n    # repr() 提供正确的括号/逗号结构，.replace 删除空格。\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}