{
    "hands_on_practices": [
        {
            "introduction": "切比雪夫节点的基本定义是在 $[-1, 1]$ 区间上。然而，在科学和工程的实际应用中，我们处理的区间往往是任意的，例如时间、长度或温度范围。因此，将标准的切比雪夫节点映射到任意区间 $[a, b]$ 是一项基本且至关重要的技能。本练习将通过一个具体实例，指导你完成这个映射过程，为在实际问题中应用切比雪夫插值奠定基础。",
            "id": "2187273",
            "problem": "一个结构工程师团队的任务是监测一根新的10米长复合梁在静载荷下的挠度。他们计划使用二次多项式来建模挠度剖面 $d(x)$，其中 $x$ 是沿梁从 $x=0$ 到 $x=10$ 米的位置。由于预算限制，他们只能放置三个挠度传感器。为了构建最稳健的多项式模型，该模型能为任何表现良好的挠度函数最小化最大可能插值误差，他们决定将传感器放置在称为切比雪夫节点的特定位置。\n\n计算梁上三个传感器的最佳位置，这些位置对应于区间 $[0, 10]$ 上二次插值的切比雪夫节点。将您的答案表示为一个行矩阵，其中包含三个位置（单位：米），按从小到大的顺序排列。提供精确的数值。",
            "solution": "我们寻求在区间 $[0,10]$ 上进行二次（2次）插值的三个切比雪夫节点。对于 $N=n+1=3$ 个插值节点，在 $[-1,1]$ 上的第一类切比雪夫节点为\n$$\nt_{k}=\\cos\\left(\\frac{(2k-1)\\pi}{2N}\\right), \\quad k=1,2,3.\n$$\n在 $[-1,1]$ 上所有 $N$ 个节点的选择中，这些节点可以最小化最大插值误差。为了将它们映射到区间 $[a,b]=[0,10]$，使用仿射变换\n$$\nx=\\frac{a+b}{2}+\\frac{b-a}{2}\\,t=\\frac{0+10}{2}+\\frac{10-0}{2}\\,t=5+5t.\n$$\n计算 $t_{k}$ 的值：\n- 对于 $k=1$：$t_{1}=\\cos\\left(\\frac{\\pi}{6}\\right)=\\frac{\\sqrt{3}}{2}$。\n- 对于 $k=2$：$t_{2}=\\cos\\left(\\frac{3\\pi}{6}\\right)=\\cos\\left(\\frac{\\pi}{2}\\right)=0$。\n- 对于 $k=3$：$t_{3}=\\cos\\left(\\frac{5\\pi}{6}\\right)=-\\frac{\\sqrt{3}}{2}$。\n\n通过 $x=5+5t$ 将每个值映射到 $[0,10]$：\n$$\nx_{1}=5+5\\cdot\\frac{\\sqrt{3}}{2}=5+\\frac{5\\sqrt{3}}{2},\\quad\nx_{2}=5+5\\cdot 0=5,\\quad\nx_{3}=5+5\\cdot\\left(-\\frac{\\sqrt{3}}{2}\\right)=5-\\frac{5\\sqrt{3}}{2}.\n$$\n从小到大排序得到：\n$$\n5-\\frac{5\\sqrt{3}}{2},\\quad 5,\\quad 5+\\frac{5\\sqrt{3}}{2}.\n$$\n这些就是三个传感器的精确位置（单位：米）。",
            "answer": "$$\\boxed{\\begin{pmatrix}5-\\frac{5\\sqrt{3}}{2}  5  5+\\frac{5\\sqrt{3}}{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "切比雪夫节点不仅仅是避免龙格现象的“好”点，它们还与最佳逼近理论有着深刻的联系。通过对一个简单的函数 $f(x) = x^3$ 进行插值，本练习将揭示一个出人意料的简洁结果。这个过程清晰地展示了切比雪夫插值是如何有效地“提取”出原函数的主要部分，并得到一个更低阶的逼近多项式，从而加深我们对切比雪夫多项式作为基函数强大作用的理解。",
            "id": "2187288",
            "problem": "在数值分析中，使用切比雪夫节点进行插值是比使用等距点更优的替代方法，尤其是在避免龙格现象 (Runge's phenomenon) 方面。该方法选择的插值点是切比雪夫多项式的根，这些点聚集在区间的端点附近。\n\n考虑在区间 $[-1, 1]$ 上的函数 $f(x) = x^3$。你的任务是求出最高次数为2的唯一多项式，记作 $P_2(x)$，它在该区间上的三个切比雪夫节点处对 $f(x)$ 进行插值。这些节点被定义为3次第一类切比雪夫多项式 $T_3(x)$ 的根。\n\n将你的答案 $P_2(x)$ 表示为一个关于 $x$ 的简化多项式。",
            "solution": "我们给定在 $[-1,1]$ 上的函数 $f(x)=x^{3}$，并且必须找到最高次数为2的唯一多项式 $P_{2}(x)$，该多项式在 $[-1,1]$ 上的三个切比雪夫节点处对 $f$ 进行插值，这些节点被定义为3次第一类切比雪夫多项式 $T_{3}(x)$ 的根。\n\n使用恒等式 $T_{3}(x)=\\cos\\!\\big(3\\arccos x\\big)=4x^{3}-3x$。$T_{3}$ 的根即为三个切比雪夫节点：\n$$\nT_{3}(x)=4x^{3}-3x=x\\big(4x^{2}-3\\big)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\n设 $P_{2}(x)=A x^{2}+B x+C$。在每个节点 $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$ 处，插值条件为 $P_{2}(\\xi)=\\xi^{3}$。\n\n1) 当 $x=0$ 时：\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) 设 $a=\\frac{\\sqrt{3}}{2}$。当 $x=a$ 和 $x=-a$ 时：\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\n将这两个方程相加可以消去 $B$：\n$$\n\\big(A a^{2}+B a\\big)+\\big(A a^{2}-B a\\big)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{由于 }a\\neq 0).\n$$\n将 $A=0$ 代入 $A a^{2}+B a=a^{3}$ 以求解 $B$：\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\n由于 $a=\\frac{\\sqrt{3}}{2}$，我们有\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\n因此，\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\n快速检验：$P_{2}(0)=0=f(0)$，且 $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$，因此在所有三个切比雪夫节点上，插值条件都得到满足。\n\n因此，最高次数为2的唯一插值多项式是 $P_{2}(x)=\\frac{3}{4}x$。",
            "answer": "$$\\boxed{\\frac{3}{4}x}$$"
        },
        {
            "introduction": "理论告诉我们，使用等距节点进行高次多项式插值可能会导致在区间端点附近出现剧烈的振荡，即龙格现象，而切比雪夫节点能够有效抑制这种现象。本练习将让你从理论走向实践，通过编写代码来亲手复现这一经典数值实验。你将对臭名昭著的龙格函数使用等距节点和切比雪夫-洛巴托节点分别进行插值，并定量地比较它们的误差和振荡行为，从而直观地感受切比雪夫节点在提高插值稳定性和准确性方面的巨大优势。",
            "id": "3212557",
            "problem": "您需要研究函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在区间 $[-1,1]$ 上的多项式插值的 Runge 现象，通过比较两种节点选择：等距节点和 Chebyshev–Lobatto 节点。您的实现必须是一个完整的、可运行的程序，该程序能以数值方式执行计算，并报告能够清晰比较这两种节点选择的量化指标。所有角度都必须以弧度为单位。\n\n仅使用基础定义和经过充分检验的事实作为您的出发点：\n- 插值问题是：给定 $[-1,1]$ 中的节点 $\\{x_j\\}_{j=0}^n$ 和数据值 $y_j=f(x_j)$，构造一个次数至多为 $n$ 的唯一多项式 $p_n$，使得对所有 $j$ 均有 $p_n(x_j)=y_j$。\n- 第一类 Chebyshev 多项式 $\\{T_k\\}_{k\\ge 0}$ 定义为 $T_k(\\cos\\theta)=\\cos(k\\theta)$，其中 $\\theta\\in\\mathbb{R}$。Chebyshev–Lobatto 节点是 $T_n$ 的极值点，即 $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$，$\\pi$ 以弧度为单位。\n- Runge 现象指的是在 $[-1,1]$ 上使用等距节点对解析函数进行高次多项式插值时，可能出现的端点处的大幅振荡。\n\n您的任务是：\n1. 对于每种节点族和每个次数 $n$，构造插值多项式 $p_n$，不得使用任何预先存在的黑盒插值例程。您可以使用任何与多项式插值定义一致、数学上等价且数值稳定的公式（例如，Lagrange 插值的重心坐标实现，或由均差构造的 Newton 形式）。请确保数值稳定性。\n2. 通过在 $[-1,1]$ 上的一个包含 $M$ 个点的均匀网格上对 $p_n$ 和 $f$ 进行采样，来近似 $[-1,1]$ 上的一致误差 $\\lVert f-p_n\\rVert_{\\infty}$。使用 $M=20001$。\n3. 在端点窗口的并集 $[-1,-1+w]\\cup[1-w,1]$（其中 $w=0.1$）上，使用两个度量来量化端点行为：\n   - 端点误差幅度 $E_{\\mathrm{end}}=\\max_{x\\in[-1,-1+w]\\cup[1-w,1]} |f(x)-p_n(x)|$。\n   - 端点振荡计数，定义为 $p_n$ 的离散导数在限制于 $[-1,-1+w]\\cup[1-w,1]$ 的采样网格上的严格符号变化次数。通过在均匀网格上使用中心有限差分计算导数，并通过将绝对值 $\\le \\tau$ 的值声明为零来对小量级进行阈值处理，其中 $\\tau=10^{-8}$。每当两个连续的非零导数样本符号相反时，计为一个严格符号变化。零值应被忽略（不计算涉及零的转换；在确定变化时，通过沿用最后一个非零符号来压缩连续的零）。\n4. 对于每个 $n$，使用上述指标比较等距节点和 Chebyshev–Lobatto 节点。\n\n测试套件和参数：\n- 使用次数 $n\\in\\{5,10,20\\}$。\n- 对于每个 $n$，使用两种节点族：\n  - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,1,\\dots,n$。\n  - Chebyshev–Lobatto 节点：$x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$，$\\pi$ 以弧度为单位。\n\n每个次数 $n$ 的必需输出：\n- 对于等距节点：按此顺序的三个值 $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{振荡计数})$。\n- 对于 Chebyshev–Lobatto 节点：按此顺序的三个值 $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{振荡计数})$。\n- 因此，对于每个 $n$，报告六个值。对于所有三个 $n$ 值，总共报告 18 个值。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含所有 18 个结果，以逗号分隔列表的形式置于方括号内，按 $n=5$，$n=10$，$n=20$ 的顺序排列，在每个 $n$ 内部，先是等距节点的三元组，然后是 Chebyshev–Lobatto 节点的三元组。例如，您的输出应如下所示：\n  $[a_1,a_2,a_3,a_4,a_5,a_6,\\ a_7,a_8,a_9,a_{10},a_{11},a_{12},\\ a_{13},a_{14},a_{15},a_{16},a_{17},a_{18}]$，\n  其中所有 $a_i$ 都是按指定顺序排列的数字。\n- 将所有浮点输出表示为四舍五入到 $8$ 位小数；振荡计数必须是整数。\n\n角度单位规范：\n- 凡是使用余弦函数定义节点的地方，其参数必须以弧度为单位。",
            "solution": "我们从多项式插值的定义开始。对于节点 $\\{x_j\\}_{j=0}^n\\subset[-1,1]$ 和值 $y_j=f(x_j)$，存在唯一的 $p_n\\in\\mathbb{P}_n$ 多项式，使得对所有 $j$ 都有 $p_n(x_j)=y_j$。任何与此定义一致的表示都是可接受的。从数值方法的角度来看，一种稳健的方法是使用重心 Lagrange 公式，它实现了相同的插值多项式，同时与朴素的 Lagrange 公式相比提高了数值稳定性。\n\n使用的基础事实：\n1. 插值误差恒等式：对于 $f\\in C^{n+1}([-1,1])$，点态误差可以表示为\n   $$ f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\prod_{j=0}^n (x-x_j), $$\n   对于某个依赖于 $x$ 的 $\\xi_x\\in(-1,1)$。该恒等式表明，节点布局 $\\{x_j\\}$ 决定了因子 $\\prod_{j=0}^n(x-x_j)$ 的形态，从而影响误差的大小和分布。\n2. 第一类 Chebyshev 多项式 $\\{T_k\\}$ 满足 $T_k(\\cos\\theta)=\\cos(k\\theta)$，其中 $\\theta\\in\\mathbb{R}$。$T_n$ 的极值点出现在 $x_k=\\cos\\left(\\frac{k\\pi}{n}\\right)$，$k=0,\\dots,n$，这些就是 Chebyshev–Lobatto 节点。这些节点在端点附近聚集，并且已知相对于等距节点，它们能抑制 $[-1,1]$ 上 $\\prod_{j=0}^n(x-x_j)$ 的量级。\n3. 随着 $n$ 的增长，Runge 现象在等距节点上表现得尤为突出，即使对于解析函数 $f$，它也会放大端点附近的振荡。Chebyshev–Lobatto 节点通过根据映射 $x=\\cos\\theta$（其中 $\\theta$ 均匀分布）所导出的密度来分布节点，从而缓解了这一现象。\n\n算法设计：\n- 函数与网格：\n  - 在 $[-1,1]$ 上定义 $f(x)=\\dfrac{1}{1+25x^2}$。\n  - 使用一个包含 $M=20001$ 个点、横跨 $[-1,1]$ 的均匀网格 $\\{x^{\\mathrm{eval}}_i\\}_{i=0}^{M-1}$，通过采样来近似 $\\lVert f-p_n\\rVert_{\\infty}$。\n- 节点生成：\n  - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,\\dots,n$。\n  - Chebyshev–Lobatto 节点：$x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,\\dots,n$，$\\pi$ 以弧度为单位。\n- 插值构造：\n  - 使用重心 Lagrange 插值多项式（它在数学上等价于唯一的插值多项式），其权重为 $w_j=\\left(\\prod_{m\\ne j}(x_j-x_m)\\right)^{-1}$。将所有 $w_j$ 乘以一个共同的非零因子不会改变插值多项式，这可用于归一化权重以提高数值稳定性。\n  - 对于在点 $x$ 处的求值，第一重心公式为\n    $$ p_n(x)=\\frac{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j} y_j}{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j}}, $$\n    约定如果 $x=x_j$（在数值容差范围内），则 $p_n(x)=y_j$ 以确保插值并避免除以零。\n  - 为提高效率，对整个网格 $\\{x^{\\mathrm{eval}}_i\\}$ 的求值进行向量化。\n- 误差指标：\n  - 计算采样误差 $e_i=|f(x^{\\mathrm{eval}}_i)-p_n(x^{\\mathrm{eval}}_i)|$，并通过 $\\max_i e_i$ 近似 $\\lVert f-p_n\\rVert_{\\infty}$。\n  - 将宽度为 $w=0.1$ 的端点窗口定义为 $[-1,-1+w]\\cup[1-w,1]$，即 $[-1,-0.9]\\cup[0.9,1]$，并计算 $E_{\\mathrm{end}}=\\max\\{e_i: x^{\\mathrm{eval}}_i\\in[-1,-0.9]\\cup[0.9,1]\\}$。\n- 振荡指标：\n  - 通过中心有限差分在网格上近似 $p_n$ 的导数，即在均匀网格上使用带边界处理的标准二阶精度离散导数。\n  - 使用 $\\tau=10^{-8}$ 对小的导数量级进行阈值处理：将绝对值 $\\le \\tau$ 的值映射为 0，其他值保持不变。应用阈值处理后，定义符号序列 $s_i=\\mathrm{sign}(p_n'(x^{\\mathrm{eval}}_i))$。\n  - 限制在端点窗口并集中的索引。通过将序列压缩为非零元素来移除零，并计算严格符号变化的次数：即两个连续非零符号不同（即它们的乘积为负）的索引数量。这将为端点区域得出一个整数的振荡计数。\n- 测试套件：\n  - 次数 $n\\in\\{5,10,20\\}$。对于每个 $n$，首先为等距节点计算三元组 $(\\lVert f-p_n\\rVert_{\\infty}, E_{\\mathrm{end}}, \\text{振荡计数})$，然后为 Chebyshev–Lobatto 节点计算。\n- 输出格式化：\n  - 对于每个 $n$，将等距节点的三元组与 Chebyshev–Lobatto 节点的三元组连接起来，每个 $n$ 产生 6 个值，当 $n=5,10,20$ 按顺序处理时，总共产生 18 个值。\n  - 将所有浮点输出四舍五入到 8 位小数；保持振荡计数为整数。\n  - 以方括号内逗号分隔列表的形式打印单行。\n\n为何这能揭示 Runge 现象：\n- 根据误差恒等式，随着 $n$ 的增长，等距节点无法控制 $\\max_{x\\in[-1,1]}\\left|\\prod_{j=0}^n(x-x_j)\\right|$，即使对于解析函数 $f$ 也会导致大的端点振荡。Chebyshev–Lobatto 节点源于 $T_n$ 的极值点，在缩放因子内有效地最小化了节点多项式的上确界范数，使误差分布更均匀，并抑制了端点误差的急剧增长。全局上确界范数误差和端点误差幅度直接量化了这些效应。振荡计数检测了 $p_n$ 在端点附近的伪振荡行为，这种行为在 $f$（在每个端点窗口上是单调的）中是不存在的，从而提供了一个补充性的定性评估，该评估表明，相对于等距节点，Chebyshev–Lobatto 节点的振荡更少。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x):\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef equispaced_nodes(n):\n    # n: degree, so n+1 nodes including endpoints\n    j = np.arange(n + 1, dtype=float)\n    return -1.0 + 2.0 * j / n\n\ndef chebyshev_lobatto_nodes(n):\n    # x_k = cos(k*pi/n), k=0..n, with radians\n    k = np.arange(n + 1, dtype=float)\n    return np.cos(np.pi * k / n)\n\ndef barycentric_weights(x):\n    # Compute first-form barycentric weights: w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # Normalize to avoid overflow/underflow; overall scaling cancels in formula.\n    x = np.asarray(x, dtype=float)\n    m = x.size\n    w = np.empty(m, dtype=float)\n    for j in range(m):\n        diffs = x[j] - np.delete(x, j)\n        w[j] = 1.0 / np.prod(diffs)\n    # Normalize weights to unit max absolute value\n    maxabs = np.max(np.abs(w))\n    if maxabs == 0.0 or not np.isfinite(maxabs):\n        return w\n    return w / maxabs\n\ndef barycentric_interpolate(x_nodes, y_nodes, w, x_eval, atol=1e-14):\n    # Vectorized first-form barycentric interpolation\n    x_nodes = np.asarray(x_nodes, dtype=float)\n    y_nodes = np.asarray(y_nodes, dtype=float)\n    w = np.asarray(w, dtype=float)\n    x_eval = np.asarray(x_eval, dtype=float)\n    # Compute differences matrix\n    Xdiff = x_eval[:, None] - x_nodes[None, :]\n    # Identify exact matches to nodes within tolerance\n    mask_eq = np.isclose(Xdiff, 0.0, rtol=0.0, atol=atol)\n    any_eq = np.any(mask_eq, axis=1)\n    # For non-matching points, compute barycentric formula\n    # Avoid division by zero by masking those rows later\n    with np.errstate(divide='ignore', invalid='ignore'):\n        tmp = w[None, :] / Xdiff\n        num = np.dot(tmp, y_nodes)\n        den = np.sum(tmp, axis=1)\n        y = num / den\n    # Fix rows where x_eval equals a node\n    if np.any(any_eq):\n        idxs = np.where(any_eq)[0]\n        # For each such row, pick the corresponding node value\n        # If multiple trues due to tolerance, take the first\n        j_star = np.argmax(mask_eq[idxs, :], axis=1)\n        y[idxs] = y_nodes[j_star]\n    return y\n\ndef endpoint_masks(x_grid, w=0.1):\n    left = x_grid = (-1.0 + w)\n    right = x_grid >= (1.0 - w)\n    return left | right\n\ndef count_strict_sign_changes(values, tol=1e-8):\n    # values: derivative samples on a 1D grid\n    v = np.asarray(values, dtype=float)\n    s = np.sign(v)\n    s[np.abs(v) = tol] = 0.0\n    nonzero = s[s != 0.0]\n    if nonzero.size = 1:\n        return 0\n    # Count transitions where consecutive signs differ\n    return int(np.sum(nonzero[1:] * nonzero[:-1]  0.0))\n\ndef interpolation_metrics(n, node_kind, x_eval, f_eval, tau=1e-8):\n    # node_kind: 'equispaced' or 'cheb_lobatto'\n    if node_kind == 'equispaced':\n        x_nodes = equispaced_nodes(n)\n    elif node_kind == 'cheb_lobatto':\n        x_nodes = chebyshev_lobatto_nodes(n)\n    else:\n        raise ValueError(\"Unknown node kind\")\n\n    y_nodes = f(x_nodes)\n    w = barycentric_weights(x_nodes)\n    p_eval = barycentric_interpolate(x_nodes, y_nodes, w, x_eval)\n\n    # Errors\n    err = np.abs(f_eval - p_eval)\n    E_inf = float(np.max(err))\n\n    # Endpoint window metrics\n    mask_end = endpoint_masks(x_eval, w=0.1)\n    E_end = float(np.max(err[mask_end]))\n\n    # Oscillation count via discrete derivative\n    # Use np.gradient with x grid for better edge approximation\n    dp = np.gradient(p_eval, x_eval, edge_order=2)\n    osc_count = count_strict_sign_changes(dp[mask_end], tol=tau)\n\n    return E_inf, E_end, osc_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    degrees = [5, 10, 20]  # n values\n    # Evaluation grid\n    M = 20001\n    x_eval = np.linspace(-1.0, 1.0, M, dtype=float)\n    f_eval = f(x_eval)\n\n    results = []\n    for n in degrees:\n        # Equispaced nodes metrics\n        E_inf_e, E_end_e, osc_e = interpolation_metrics(n, 'equispaced', x_eval, f_eval, tau=1e-8)\n        # Chebyshev–Lobatto nodes metrics\n        E_inf_c, E_end_c, osc_c = interpolation_metrics(n, 'cheb_lobatto', x_eval, f_eval, tau=1e-8)\n\n        # Round floats to 8 decimal places as required; integers unchanged\n        results.extend([\n            f\"{np.round(E_inf_e, 8):.8f}\",\n            f\"{np.round(E_end_e, 8):.8f}\",\n            str(int(osc_e)),\n            f\"{np.round(E_inf_c, 8):.8f}\",\n            f\"{np.round(E_end_c, 8):.8f}\",\n            str(int(osc_c)),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}