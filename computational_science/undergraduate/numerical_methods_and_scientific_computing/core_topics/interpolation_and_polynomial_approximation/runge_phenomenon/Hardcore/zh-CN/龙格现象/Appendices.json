{
    "hands_on_practices": [
        {
            "introduction": "为了从根本上理解龙格现象，我们可以探究其背后的数学机制。使用等距节点进行多项式插值的不稳定性，可以通过分析重心权重的大小来量化。本练习将引导你计算一个具体案例中，区间中心与端点节点的重心权重之比，从而揭示为何等距节点会导致不稳定的插值。",
            "id": "2199710",
            "problem": "在多项式插值的研究中，插值点（节点）的选择显著影响所得多项式的准确性和稳定性。重心插值公式提供了一种数值稳定的方法来评估插值多项式，其性质与称为重心权的量密切相关。\n\n考虑在区间 $[-1, 1]$ 上的 $n+1$ 个均匀分布的插值节点 $x_j$，其中 $j=0, 1, \\ldots, n$。节点由公式 $x_j = -1 + j \\cdot h$ 给出，其中步长为 $h = \\frac{2}{n}$。\n\n节点 $x_j$ 的重心权 $w_j$ 定义为：\n$$\nw_j = \\left(\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)\\right)^{-1}\n$$\n\n对于 $n=10$ 的特定情况，这将产生 11 个插值节点，请确定比值 $\\frac{|w_{10}|}{|w_5|}$ 的精确值。该比值比较了区间右端点（$x_{10}=1$）的重心权大小与区间中心（$x_5=0$）的重心权大小。\n\n将最终答案表示为最简分数形式。",
            "solution": "我们有均匀分布的节点 $x_{j}=-1+jh$，其中 $h=\\frac{2}{n}$ 且 $j=0,1,\\ldots,n$。重心权为\n$$\nw_{j}=\\left(\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})\\right)^{-1}.\n$$\n对于均匀间距，\n$$\nx_{j}-x_{k}=(-1+jh)-(-1+kh)=(j-k)h,\n$$\n因此，对 $n$ 个项（不包括 $k=j$）的乘积可以分解为\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})=h^{n}\\prod_{k=0,\\,k\\neq j}^{n}(j-k).\n$$\n因此\n$$\nw_{j}=h^{-n}\\left(\\prod_{k=0,\\,k\\neq j}^{n}(j-k)\\right)^{-1}.\n$$\n通过在 $j$ 处拆分来计算整数乘积：\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(j-k)=\\left(\\prod_{k=0}^{j-1}(j-k)\\right)\\left(\\prod_{k=j+1}^{n}(j-k)\\right)\n=j!\\cdot\\left[\\prod_{m=1}^{n-j}(-m)\\right]=(-1)^{n-j}j!(n-j)!.\n$$\n因此，取绝对值，\n$$\n|w_{j}|^{-1} = h^{n}j!(n-j)!.\n$$\n对于 $n=10$，我们分别计算 $j=10$（端点）和 $j=5$（中心）时的值。\n对于端点节点 $x_{10}$：\n$$\n|w_{10}|^{-1} = h^{10} \\cdot 10! \\cdot (10-10)! = h^{10} \\cdot 10! \\cdot 0! = h^{10} \\cdot 10!\n$$\n对于中心节点 $x_5$：\n$$\n|w_5|^{-1} = h^{10} \\cdot 5! \\cdot (10-5)! = h^{10} \\cdot 5! \\cdot 5!\n$$\n我们要求比值 $\\frac{|w_{10}|}{|w_5|}$。利用 $|a|/|b| = |b|^{-1}/|a|^{-1}$，我们得到：\n$$\n\\frac{|w_{10}|}{|w_5|} = \\frac{|w_5|^{-1}}{|w_{10}|^{-1}} = \\frac{h^{10} \\cdot 5! \\cdot 5!}{h^{10} \\cdot 10!} = \\frac{(5!)^2}{10!}\n$$\n使用 $10!=10\\cdot 9\\cdot 8\\cdot 7\\cdot 6\\cdot 5!$ 和 $5!=120$ 进行化简：\n$$\n\\frac{(5!)^2}{10!} = \\frac{5! \\cdot 5!}{10 \\cdot 9 \\cdot 8 \\cdot 7 \\cdot 6 \\cdot 5!} = \\frac{5!}{10 \\cdot 9 \\cdot 8 \\cdot 7 \\cdot 6} = \\frac{120}{30240} = \\frac{1}{252}.\n$$\n因此，精确的比值为 $\\frac{1}{252}$。",
            "answer": "$$\\boxed{\\frac{1}{252}}$$"
        },
        {
            "introduction": "龙格现象最直观的表现，就是插值多项式在区间端点附近产生的剧烈振荡。这种振荡不仅影响区间内的精度，更使得在区间外进行预测（即外插）变得极其危险。本练习通过计算一个具体的外插值并与真实值对比，让你亲身体会到这种由振荡引发的灾难性误差。",
            "id": "2199743",
            "problem": "考虑函数 $f(x) = \\frac{1}{1 + 25x^2}$。在区间 $[-1, 1]$ 内（包括端点）取五个等距节点 $x_i$，通过计算该函数在这些点上的值，生成一组五个点 $(x_i, y_i)$。设 $P(x)$ 是经过这五个点的次数最小的唯一多项式。计算在点 $x = 1.1$ 处，该多项式的值与函数值之间的绝对差。即，计算 $|P(1.1) - f(1.1)|$。将最终答案四舍五入到三位有效数字。",
            "solution": "在 $[-1,1]$ 区间内（包括端点）的五个等距节点是 $x=-1,-\\tfrac{1}{2},0,\\tfrac{1}{2},1$。由于函数 $f(x)=\\frac{1}{1+25x^{2}}$ 是偶函数，且节点是对称的，因此次数最多为 $4$ 的唯一插值多项式也是偶函数，可以写作\n$$\nP(x)=a+bx^{2}+cx^{4}.\n$$\n插值得出以下条件\n$$\nP(0)=a=f(0)=1,\n$$\n$$\nP\\left(\\tfrac{1}{2}\\right)=a+\\frac{b}{4}+\\frac{c}{16}=f\\left(\\tfrac{1}{2}\\right)=\\frac{1}{1+25/4}=\\frac{4}{29},\n$$\n$$\nP(1)=a+b+c=f(1)=\\frac{1}{1+25}=\\frac{1}{26}.\n$$\n代入 $a=1$，我们得到一个关于 $b$ 和 $c$ 的线性方程组：\n$$\n\\begin{cases} \\frac{b}{4}+\\frac{c}{16} = \\frac{4}{29}-1 = -\\frac{25}{29} \\\\ b+c = \\frac{1}{26}-1 = -\\frac{25}{26} \\end{cases} \\implies \\begin{cases} 4b+c = -\\frac{400}{29} \\\\ b+c = -\\frac{25}{26} \\end{cases}\n$$\n将第一个等式减去第二个等式：\n$$\n3b=-\\frac{400}{29}-\\left(-\\frac{25}{26}\\right) = -\\frac{400 \\cdot 26 - 25 \\cdot 29}{29 \\cdot 26} = -\\frac{10400 - 725}{754} = -\\frac{9675}{754} \\implies b=-\\frac{3225}{754}\n$$\n然后求 $c$：\n$$\nc=-\\frac{25}{26}-b=-\\frac{25}{26}+\\frac{3225}{754}=\\frac{-25 \\cdot 29 + 3225}{754}=\\frac{-725+3225}{754}=\\frac{2500}{754}=\\frac{1250}{377}.\n$$\n因此，插值多项式为：\n$$\nP(x)=1-\\frac{3225}{754}x^{2}+\\frac{1250}{377}x^{4}.\n$$\n在 $x=1.1 = \\frac{11}{10}$ 处求值：\n$$\nP(1.1)=1-\\frac{3225}{754}\\left(\\frac{11}{10}\\right)^{2}+\\frac{1250}{377}\\left(\\frac{11}{10}\\right)^{4} = 1-\\frac{3225 \\cdot 121}{754 \\cdot 100}+\\frac{1250 \\cdot 14641}{377 \\cdot 10000}\n$$\n化简各项：\n$$\nP(1.1) = 1-\\frac{129 \\cdot 121}{3016}+\\frac{14641}{3016} = 1-\\frac{15609}{3016}+\\frac{14641}{3016} = \\frac{3016-15609+14641}{3016}=\\frac{2048}{3016}=\\frac{256}{377}.\n$$\n函数在 $x=1.1$ 的真实值为：\n$$\nf(1.1)=\\frac{1}{1+25(1.1)^2}=\\frac{1}{1+25 \\cdot 1.21}=\\frac{1}{1+30.25}=\\frac{1}{31.25}=\\frac{100}{3125}=\\frac{4}{125}.\n$$\n计算绝对差：\n$$\n|P(1.1)-f(1.1)|=\\left|\\frac{256}{377}-\\frac{4}{125}\\right|=\\left|\\frac{256 \\cdot 125 - 4 \\cdot 377}{377 \\cdot 125}\\right|=\\frac{|32000 - 1508|}{47125}=\\frac{30492}{47125}\\approx 0.647045\\ldots\n$$\n四舍五入到三位有效数字，结果是 $0.647$。",
            "answer": "$$\\boxed{0.647}$$"
        },
        {
            "introduction": "在认识到等距节点的问题后，自然会引出一个问题：我们如何改进？本练习将带你从理论走向实践，通过编写代码来探索一种名为“自适应节点加密”的先进策略。你将实现一个算法，它能够智能地在误差较大的区域（特别是区间端点附近）增加插值节点，从而有效“驯服”振荡，显著提升插值精度。",
            "id": "3188715",
            "problem": "您需要通过在区间 $[-1,1]$ 上的单变量多项式插值中的自适应节点细化来研究龙格现象。从 $n$ 个等距节点开始，通过中点处的残差来估计局部插值误差，在残差最大的端点附近添加节点，并数值检验自适应性是否减少了端点振荡。该研究必须以纯粹的数学和逻辑术语表达，并实现为一个完整、可运行的程序。\n\n定义与设置：\n- 令 $f(x)$ 为定义在 $[-1,1]$ 上的实值函数。\n- 对于给定的整数 $n \\geq 2$，定义等距节点 $x_i = -1 + \\frac{2i}{n-1}$，其中 $i=0,1,\\dots,n-1$。\n- 令 $p_n(x)$ 表示次数至多为 $n-1$ 的唯一多项式，它对所有 $i$ 满足 $p_n(x_i) = f(x_i)$。\n- 定义残差 $r(x) = p_n(x) - f(x)$。\n- 对于窗口宽度 $w$（满足 $0 < w < 1$），定义端点窗口集 $E_w = [-1,-1+w] \\cup [1-w,1]$。\n- 定义端点振荡得分 $S = \\max_{x \\in E_w} |r(x)|$，该值在 $[-1,1]$ 上一个大小为 $N_{\\text{grid}}$ 的足够稠密的网格上进行评估。\n\n自适应节点细化（单步）：\n- 给定当前节点集 $\\{x_i\\}$ 和相关的插值多项式 $p_n(x)$，对每对相邻节点 $(x_i, x_{i+1})$ 计算中点 $m_i = \\frac{x_i + x_{i+1}}{2}$。\n- 评估中点残差 $|r(m_i)| = |p_n(m_i) - f(m_i)|$。\n- 定义加权指标 $I_i = |r(m_i)| \\cdot \\left(1 + \\alpha \\cdot |m_i|\\right)$，其中 $\\alpha > 0$ 使选择偏向于端点（因为当 $x$ 接近 $\\pm 1$ 时， $|m_i|$ 更大）。\n- 选择最多 $k$ 个具有最大 $I_i$ 值的中点，并将它们添加到节点集中。\n- 在细化后的节点集上重新计算插值多项式 $\\hat{p}(x)$ 和新的残差 $\\hat{r}(x) = \\hat{p}(x) - f(x)$。\n- 使用与之前相同的稠密网格计算新的端点振荡得分 $\\hat{S} = \\max_{x \\in E_w} |\\hat{r}(x)|$。\n- 定义改进率，当 $S > 0$ 时 $R = \\frac{S - \\hat{S}}{S}$，当 $S = 0$ 时 $R = 0$。\n\n您的程序必须实现上述过程，并对每个测试用例输出一个布尔值，指示自适应细化是否将端点振荡减少了至少一个指定的阈值 $\\tau$，即 $R \\geq \\tau$ 是否成立。\n\n测试套件与参数：\n对每个测试用例，参数以元组 $(f\\_\\text{id}, n, k, \\alpha, w, N_{\\text{grid}}, \\tau)$ 的形式给出，其中：\n- $f\\_\\text{id}$ 按如下方式指定函数 $f(x)$：\n  - $f\\_\\text{id} = \\text{\"runge25\"}$ 表示 $f(x) = \\frac{1}{1 + 25 x^2}$。\n  - $f\\_\\text{id} = \\text{\"cubic\"}$ 表示 $f(x) = x^3$。\n- $n$ 是 $[-1,1]$ 上初始等距节点的数量。\n- $k$ 是在自适应步骤中添加的最大中点数。\n- $\\alpha$ 是指标 $I_i$ 中的端点偏置参数。\n- $w$ 是定义 $E_w$ 的端点窗口宽度。\n- $N_{\\text{grid}}$ 是用于在 $[-1,1]$ 上近似 $S$ 和 $\\hat{S}$ 中最大值的网格点数。\n- $\\tau$ 是所需的改进率阈值，以小数形式表示。\n\n使用以下测试套件：\n1. $(\\text{\"runge25\"},\\, 10,\\, 8,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.2)$。\n2. $(\\text{\"runge25\"},\\, 10,\\, 2,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.05)$。\n3. $(\\text{\"cubic\"},\\, 10,\\, 8,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.2)$。\n4. $(\\text{\"runge25\"},\\, 10,\\, 8,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.9)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{False}]$。不应打印任何额外文本。",
            "solution": "该算法实现了一种单步自适应节点细化策略，以减轻多项式插值中的龙格现象。以下是该方法的逐步说明，与提供的代码实现相对应。\n\n1.  **初始插值与误差评估**:\n    *   首先，在区间 $[-1,1]$ 上创建 $n$ 个等距的初始节点 $\\{x_i\\}$。\n    *   在这些节点上计算给定函数 $f(x)$ 的值 $\\{y_i = f(x_i)\\}$。\n    *   使用这些点 $(x_i, y_i)$ 构建一个初始插值多项式 $p_n(x)$。代码中使用数值稳定的重心插值法 `BarycentricInterpolator` 来实现。\n    *   为了量化插值的误差，特别是在端点处的振荡，我们定义了一个稠密的评估网格。在该网格上计算残差 $r(x) = p_n(x) - f(x)$。\n    *   初始端点振荡得分 $S$ 被计算为在指定端点窗口 $E_w$ 内残差的最大绝对值。\n\n2.  **自适应节点选择**:\n    *   该策略的核心是在误差最大的地方添加新节点。我们通过检查现有节点区间的中点来估计误差。\n    *   对于每对相邻的初始节点 $(x_i, x_{i+1})$，计算中点 $m_i = (x_i+x_{i+1})/2$ 处的残差 $|r(m_i)|$。\n    *   为了优先处理龙格现象最严重的端点区域，我们使用一个加权指标 $I_i = |r(m_i)| \\cdot (1 + \\alpha \\cdot |m_i|)$。参数 $\\alpha > 0$ 给予 $|m_i|$ 值较大（即靠近 $\\pm 1$）的中点更高的权重。\n    *   根据这些指标值，选择具有最大 $I_i$ 的 $k$ 个中点作为要添加的新节点。\n\n3.  **细化与重新评估**:\n    *   将选定的新节点添加到初始节点集中，形成一个更大的、非均匀分布的节点集。\n    *   使用这个新的节点集构建一个新的插值多项式 $\\hat{p}(x)$。\n    *   与初始步骤类似，计算新的残差 $\\hat{r}(x) = \\hat{p}(x) - f(x)$，并在相同的端点窗口 $E_w$ 内计算新的振荡得分 $\\hat{S}$。\n\n4.  **性能评估**:\n    *   通过改进率 $R = (S - \\hat{S}) / S$ 来衡量该策略的有效性。这个值表示端点振荡得分的相对减少量。\n    *   如果 $R$ 大于或等于给定的阈值 $\\tau$，则认为该自适应步骤成功地将振荡减少到所需水平，结果为 `True`；否则为 `False`。\n\n5.  **特殊情况处理**:\n    *   对于 `f_id = \"cubic\"` 和 $n=10$ 的测试用例，初始的次数为 $9$ 的插值多项式 $p_{10}(x)$ 将精确等于 $x^3$。因此，初始残差 $r(x)$ 在所有点上均为零，导致 $S=0$。根据问题定义，此时改进率 $R$ 也为零。由于阈值 $\\tau=0.2 > 0$，因此测试 $R \\geq \\tau$ 的结果为 `False`，这正确地反映了没有误差需要改进。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"runge25\", 10, 8, 1.5, 0.2, 5001, 0.2),\n        (\"runge25\", 10, 2, 1.5, 0.2, 5001, 0.05),\n        (\"cubic\", 10, 8, 1.5, 0.2, 5001, 0.2),\n        (\"runge25\", 10, 8, 1.5, 0.2, 5001, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_one_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.lower() for r in map(str, results)]))}]\")\n\ndef run_one_case(f_id, n, k, alpha, w, N_grid, tau):\n    \"\"\"\n    Implements the adaptive node refinement procedure for a single test case.\n\n    Args:\n        f_id (str): Function identifier (\"runge25\" or \"cubic\").\n        n (int): Initial number of equispaced nodes.\n        k (int): Maximum number of midpoints to add.\n        alpha (float): Endpoint bias parameter.\n        w (float): Endpoint window width.\n        N_grid (int): Number of points in the dense evaluation grid.\n        tau (float): Improvement ratio threshold.\n\n    Returns:\n        bool: True if the improvement ratio is >= tau, False otherwise.\n    \"\"\"\n    # 1. Define the function f(x) based on the identifier.\n    if f_id == \"runge25\":\n        def f(x):\n            return 1.0 / (1.0 + 25.0 * x**2)\n    elif f_id == \"cubic\":\n        def f(x):\n            return x**3\n    else:\n        raise ValueError(\"Unknown function identifier\")\n\n    # 2. Define the dense evaluation grid and the endpoint window.\n    x_grid = np.linspace(-1.0, 1.0, N_grid)\n    endpoint_mask = (x_grid = -1.0 + w) | (x_grid >= 1.0 - w)\n\n    # 3. Initial interpolation setup.\n    x_nodes_initial = np.linspace(-1.0, 1.0, n)\n    y_nodes_initial = f(x_nodes_initial)\n    p_n = BarycentricInterpolator(x_nodes_initial, y_nodes_initial)\n\n    # 4. Calculate the initial residual and endpoint oscillation score S.\n    f_vals_grid = f(x_grid)\n    p_n_vals_grid = p_n(x_grid)\n    r_vals_grid = p_n_vals_grid - f_vals_grid\n    \n    s_val = np.max(np.abs(r_vals_grid[endpoint_mask]))\n\n    # If initial error is effectively zero, improvement R is 0.\n    if np.isclose(s_val, 0.0):\n        return 0.0 >= tau\n\n    # 5. Adaptive refinement: compute indicators and select new nodes.\n    midpoints = (x_nodes_initial[:-1] + x_nodes_initial[1:]) / 2.0\n    r_midpoints = p_n(midpoints) - f(midpoints)\n    indicators = np.abs(r_midpoints) * (1.0 + alpha * np.abs(midpoints))\n    \n    num_to_add = min(k, len(midpoints))\n    top_indices = np.argsort(indicators)[-num_to_add:]\n    nodes_to_add = midpoints[top_indices]\n    \n    x_nodes_refined = np.sort(np.union1d(x_nodes_initial, nodes_to_add))\n    y_nodes_refined = f(x_nodes_refined)\n\n    # 6. Recompute interpolant on the refined node set.\n    p_hat = BarycentricInterpolator(x_nodes_refined, y_nodes_refined)\n\n    # 7. Calculate the new endpoint oscillation score S_hat.\n    p_hat_vals_grid = p_hat(x_grid)\n    r_hat_vals_grid = p_hat_vals_grid - f_vals_grid\n    s_hat_val = np.max(np.abs(r_hat_vals_grid[endpoint_mask]))\n\n    # 8. Compute the improvement ratio R and compare with the threshold tau.\n    improvement_ratio = (s_val - s_hat_val) / s_val\n    \n    return improvement_ratio >= tau\n\nsolve()\n```"
        }
    ]
}