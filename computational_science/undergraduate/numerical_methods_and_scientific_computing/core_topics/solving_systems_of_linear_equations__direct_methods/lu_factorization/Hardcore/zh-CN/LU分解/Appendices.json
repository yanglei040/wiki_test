{
    "hands_on_practices": [
        {
            "introduction": "掌握LU分解的第一步是亲手完成一次完整的计算。这个练习  将指导你使用经典的Doolittle方法，将一个给定的方阵$A$分解为一个单位下三角矩阵$L$和一个上三角矩阵$U$的乘积。通过这个基础实践，你将熟悉LU分解的核心算法流程，并为解决更复杂的问题奠定坚实的基础。",
            "id": "2161051",
            "problem": "在数值线性代数中，LU分解是求解线性方程组、矩阵求逆和计算行列式的一种基本技巧。对于一个方阵 $A$，Doolittle LU分解是一种形式为 $A = LU$ 的因式分解，其中 $L$ 是一个单位下三角矩阵（即主对角线元素全为1的下三角矩阵），$U$ 是一个上三角矩阵。\n\n考虑矩阵 $A$ 如下：\n$$\nA = \\begin{pmatrix} 2   1   -1 \\\\ 4   5   -1 \\\\ -2   8   8 \\end{pmatrix}\n$$\n您的任务是首先确定 $A$ 的Doolittle LU分解。在找到矩阵 $L$ 和 $U$ 之后，您必须接着求出上三角矩阵的逆矩阵 $U^{-1}$。\n\n请将您的最终答案 $U^{-1}$ 以一个3x3矩阵的形式呈现。",
            "solution": "我们寻求 $A$ 的Doolittle LU分解，因此写作 $A=LU$，其中\n$$\nL=\\begin{pmatrix} 1  0  0 \\\\ \\ell_{21}  1  0 \\\\ \\ell_{31}  \\ell_{32}  1 \\end{pmatrix},\\quad\nU=\\begin{pmatrix} u_{11}  u_{12}  u_{13} \\\\ 0  u_{22}  u_{23} \\\\ 0  0  u_{33} \\end{pmatrix}.\n$$\n使用Doolittle方法：\n- 从 $U$ 的第一行，我们设定 $u_{11}=a_{11}=2$，$u_{12}=a_{12}=1$，$u_{13}=a_{13}=-1$。\n- 计算乘子 $\\ell_{21}=\\frac{a_{21}}{u_{11}}=\\frac{4}{2}=2$ 和 $\\ell_{31}=\\frac{a_{31}}{u_{11}}=\\frac{-2}{2}=-1$。\n- 计算 $u_{22}=a_{22}-\\ell_{21}u_{12}=5-2\\cdot 1=3$ 和 $u_{23}=a_{23}-\\ell_{21}u_{13}=-1-2\\cdot(-1)=1$。\n- 计算 $\\ell_{32}=\\frac{a_{32}-\\ell_{31}u_{12}}{u_{22}}=\\frac{8-(-1)\\cdot 1}{3}=\\frac{9}{3}=3$。\n- 计算 $u_{33}=a_{33}-\\ell_{31}u_{13}-\\ell_{32}u_{23}=8-(-1)\\cdot(-1)-3\\cdot 1=4$。\n\n因此\n$$\nL=\\begin{pmatrix} 1  0  0 \\\\ 2  1  0 \\\\ -1  3  1 \\end{pmatrix},\\quad\nU=\\begin{pmatrix} 2  1  -1 \\\\ 0  3  1 \\\\ 0  0  4 \\end{pmatrix}.\n$$\n为了求 $U^{-1}$，我们逐列求解 $U X=I$。设 $X$ 的列向量为 $x^{(1)},x^{(2)},x^{(3)}$，求解 $U x^{(j)}=e_{j}$。\n\n对于 $j=1$：\n$$\n4x_{31}^{(1)}=0\\Rightarrow x_{31}^{(1)}=0,\\quad 3x_{21}^{(1)}+x_{31}^{(1)}=0\\Rightarrow x_{21}^{(1)}=0,\\quad 2x_{11}^{(1)}+x_{21}^{(1)}-x_{31}^{(1)}=1\\Rightarrow x_{11}^{(1)}=\\frac{1}{2}.\n$$\n因此 $x^{(1)}=(\\frac{1}{2},0,0)^{\\mathsf{T}}$。\n\n对于 $j=2$：\n$$\n4x_{32}^{(2)}=0\\Rightarrow x_{32}^{(2)}=0,\\quad 3x_{22}^{(2)}+x_{32}^{(2)}=1\\Rightarrow x_{22}^{(2)}=\\frac{1}{3},\\quad 2x_{12}^{(2)}+x_{22}^{(2)}-x_{32}^{(2)}=0\\Rightarrow x_{12}^{(2)}=-\\frac{1}{6}.\n$$\n因此 $x^{(2)}=(-\\frac{1}{6},\\frac{1}{3},0)^{\\mathsf{T}}$。\n\n对于 $j=3$：\n$$\n4x_{33}^{(3)}=1\\Rightarrow x_{33}^{(3)}=\\frac{1}{4},\\quad 3x_{23}^{(3)}+x_{33}^{(3)}=0\\Rightarrow x_{23}^{(3)}=-\\frac{1}{12},\\quad 2x_{13}^{(3)}+x_{23}^{(3)}-x_{33}^{(3)}=0\\Rightarrow x_{13}^{(3)}=\\frac{1}{6}.\n$$\n因此 $x^{(3)}=(\\frac{1}{6},-\\frac{1}{12},\\frac{1}{4})^{\\mathsf{T}}$。\n\n将这些列向量组合起来得到\n$$\nU^{-1}=\\begin{pmatrix}\n\\frac{1}{2}   -\\frac{1}{6}   \\frac{1}{6}\\\\\n0   \\frac{1}{3}   -\\frac{1}{12}\\\\\n0   0   \\frac{1}{4}\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2}  -\\frac{1}{6}  \\frac{1}{6}\\\\0  \\frac{1}{3}  -\\frac{1}{12}\\\\0  0  \\frac{1}{4}\\end{pmatrix}}$$"
        },
        {
            "introduction": "虽然基本的LU分解算法很强大，但它并非万能的，特别是在分解过程中遇到零主元时。这个练习  揭示了标准算法的一个关键限制，并引入了“部分主元法”的核心思想——使用置换矩阵进行行交换。理解和应用置换矩阵是确保LU分解算法在更广泛矩阵上稳健运行的关键一步。",
            "id": "12984",
            "problem": "在线性代数中，方阵 $A$ 的 LU 分解是一种形式为 $A = LU$ 的因式分解，其中 $L$ 是一个下三角矩阵，$U$ 是一个上三角矩阵。然而，如果不首先对 $A$ 的行进行重排，这种分解并非总是可能的。具体来说，如果在高斯消元过程中，对角线上遇到零（一个“主元”元素），标准的 LU 分解算法就会失败。\n\n为了处理这种情况，我们引入一个置换矩阵 $P$。置换矩阵是通过对单位矩阵的行进行置换而得到的方阵。当我们将一个矩阵 $A$ 左乘一个置换矩阵 $P$ 时，其效果是对 $A$ 的行进行重排。然后将因式分解应用于重排后的矩阵，得到 $PA = LU$。\n\n考虑一个通用 $2 \\times 2$ 矩阵 $A$，其形式如下：\n$$\nA = \\begin{pmatrix} 0  a \\\\ b  c \\end{pmatrix}\n$$\n其中 $a$ 和 $b$ 是非零常数。标准的 LU 分解算法无法开始，因为第一行第一列的主元元素 $A_{11}$ 为零。\n\n推导必须应用于 $A$ 的特定 $2 \\times 2$ 置换矩阵 $P$，使得得到的矩阵 $A' = PA$ 在 $(1,1)$ 位置上有一个非零元素，从而允许 LU 分解继续进行。",
            "solution": "我们寻求一个置换矩阵 $P$，使得\n$$ A' = PA = \\begin{pmatrix} P_{11}  P_{12} \\\\ P_{21}  P_{22} \\end{pmatrix} \\begin{pmatrix} 0  a \\\\ b  c \\end{pmatrix} $$\n的 $(1,1)$ 项非零。\n\n1. 一个 $2\\times2$ 的置换矩阵必须每行每列都恰好有一个“1”，其余位置为零。唯一的候选矩阵是单位矩阵\n$$I = \\begin{pmatrix}1  0 \\\\ 0  1\\end{pmatrix}$$\n和行交换矩阵\n$$S = \\begin{pmatrix}0  1 \\\\ 1  0\\end{pmatrix}.$$\n\n2. 应用 $I$ 会使 $A$ 保持不变，所以 $(1,1)$ 项仍然为零。因此我们选择\n$$P = S = \\begin{pmatrix}0  1 \\\\ 1  0\\end{pmatrix}.$$\n\n3. 验证：\n$$ PA = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 0  a \\\\ b  c \\end{pmatrix} = \\begin{pmatrix} b  c \\\\ 0  a \\end{pmatrix}, $$\n确实 $(PA)_{11}=b\\neq0$，这使得 LU 分解可以继续进行。",
            "answer": "$$\\boxed{\\begin{pmatrix}0   1\\\\1   0\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了手动计算之后，我们将转向更贴近科研和工程实践的计算分析。这个编程练习  要求你对著名的病态矩阵——希尔伯特矩阵——进行LU分解，并分析其数值特性。通过实现Doolittle和Crout两种分解方法，你将深入探索元素增长、舍入误差和数值稳定性等在科学计算中至关重要的问题。",
            "id": "3249691",
            "problem": "开发一个完整、可运行的程序，分析在对 Hilbert 矩阵应用两种经典的无主元选择的 LU（Lower-Upper）分解算法时，所产生的三角因子中元素幅值的增长情况。您的程序必须从第一性原理直接实现 Doolittle 和 Crout 两种 LU 分解变体，并报告针对一小组 Hilbert 矩阵测试套件的增长和残差的量化指标。\n\n您必须使用的基本依据是：\n- 对于一个非奇异方阵 $A \\in \\mathbb{R}^{n \\times n}$，LU 分解是将其分解为 $A = L U$ 的过程，其中 $L$ 是下三角矩阵，$U$ 是上三角矩阵。\n- 在 Doolittle 变体中，$L$ 是单位对角下三角矩阵，即对所有 $i$ 都有 $L_{ii} = 1$，而 $U$ 是具有通用对角元的上三角矩阵。\n- 在 Crout 变体中，$U$ 是单位对角上三角矩阵，即对所有 $i$ 都有 $U_{ii} = 1$，而 $L$ 是具有通用对角元的下三角矩阵。\n- Hilbert 矩阵 $H_n \\in \\mathbb{R}^{n \\times n}$ 的分量由 $[H_n]_{ij} = \\frac{1}{i + j - 1}$ 给出，其中 $1 \\leq i,j \\leq n$。对于所有正整数 $n$，矩阵 $H_n$ 都是对称正定且非奇异的。\n\n从这些定义出发，在您的解决方案中，逐步推导如何获得 $L$ 和 $U$ 的元素，确保在无主元选择的情况下其正确性。推导过程应通过等同 $A = L U$ 中的元素，并以与三角结构兼容的顺序求解未知数，不假设任何已有的快捷公式。\n\n您的程序必须：\n- 对集合 $\\{1,2,5,10\\}$ 中的每个 $n$，使用双精度浮点算术构造 $H_n$。\n- 为每个 $n$ 计算两种分解：\n  - Doolittle 分解 $H_n = L^{(D)} U^{(D)}$，其中 $L^{(D)}$ 是单位对角矩阵。\n  - Crout 分解 $H_n = L^{(C)} U^{(C)}$，其中 $U^{(C)}$ 是单位对角矩阵。\n- 对每种分解，计算：\n  - 下三角因子中的最大绝对值元素幅值，$g_L = \\max_{i,j} |L_{ij}|$。\n  - 上三角因子中的最大绝对值元素幅值，$g_U = \\max_{i,j} |U_{ij}|$。\n  - 分解的无穷范数残差，$r_{\\infty} = \\|H_n - L U\\|_{\\infty}$，其中 $\\|X\\|_{\\infty} = \\max_{1 \\le i \\le n} \\sum_{j=1}^n |X_{ij}|$。\n- 请注意，对于 Hilbert 矩阵，$\\max_{i,j} |[H_n]_{ij}| = 1$，因此原始幅值 $g_L$ 和 $g_U$ 已可作为相对于 $H_n$ 最大元素的归一化增长度量。\n\n科学真实性和数值稳健性要求：\n- 严格在无主元选择的情况下进行计算。\n- 仅使用标准双精度浮点算术。\n- 不涉及物理单位。\n- 不适用角度单位。\n\n测试套件和输出规范：\n- 使用测试套件 $n \\in \\{1,2,5,10\\}$。\n- 对每个 $n$，生成一个形式为 $[n, g_L^{(D)}, g_U^{(D)}, g_L^{(C)}, g_U^{(C)}, r_{\\infty}^{(D)}, r_{\\infty}^{(C)}]$ 的结果列表，其中上标 $(D)$ 和 $(C)$ 分别代表 Doolittle 和 Crout。\n- 您的程序应生成单行输出，其中包含所有 $n$ 的结果，形式为一个由这些列表组成的、以逗号分隔的列表，并用方括号括起来。例如，一个语法上有效的形状是 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$，其中的点代表数值条目。\n\n最后一行必须是且仅是一行，不含任何额外注释。",
            "solution": "**1. 问题陈述分析与验证**\n\n该问题要求实现并分析 LU 分解的两种变体，即 Doolittle 方法和 Crout 方法，并将它们应用于大小为 $n \\in \\{1, 2, 5, 10\\}$ 的 Hilbert 矩阵 $H_n$。分析重点在于三角因子 $L$ 和 $U$ 中元素幅值的增长，以及分解的残差。算法将在无主元选择的情况下实现，这是允许的且数值稳定的，因为 Hilbert 矩阵是对称正定（SPD）的。\n\n该问题具有科学依据，提法恰当且完整。所有定义——Hilbert 矩阵 $[H_n]_{ij} = (i+j-1)^{-1}$、Doolittle 分解（$L_{ii}=1$）、Crout 分解（$U_{ii}=1$）以及无穷范数 $\\|X\\|_{\\infty} = \\max_i \\sum_j |X_{ij}|$——在数值线性代数中都是标准的。所提供的 $H_n$ 是对称正定的性质是正确且至关重要的，因为它保证了无主元选择的 LU 分解存在、唯一且数值稳定。该任务是数值分析中的一个标准练习，可以得出一个清晰、可验证且非平凡的计算结果。因此，该问题被认为是有效的。\n\n**2. 从第一性原理推导 LU 分解算法**\n\n目标是对于给定的方阵 $A \\in \\mathbb{R}^{n \\times n}$，找到一个下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $A = LU$。该矩阵乘法的元素级定义为：\n$$A_{ij} = \\sum_{k=1}^{n} L_{ik} U_{kj}$$\n由于 $L$ ($L_{ik}=0$ 当 $ki$) 和 $U$ ($U_{kj}=0$ 当 $kj$) 的三角性质，求和可简化为：\n$$A_{ij} = \\sum_{k=1}^{\\min(i,j)} L_{ik} U_{kj}$$\n为了确保分解的唯一性，必须从 $A$ 的元素提供的 $n^2$ 个方程中确定 $L$ 和 $U$ 中的 $n^2$ 个未知元素。$L$ 和 $U$ 中有 $n^2+n$ 个潜在未知数。因此，必须施加 $n$ 个额外约束，通常通过将 $L$ 或 $U$ 的对角元素设置为 1 来实现。\n\n**2.1. Doolittle 算法 ($L_{ii}=1$)**\n\n在 Doolittle 变体中，$L$ 是一个单位下三角矩阵，即对所有 $i=1, \\dots, n$ 都有 $L_{ii} = 1$。未知数是 $L$ 的次对角线元素和 $U$ 的所有元素。我们可以通过分离未知量来推导出一个序贯算法。一种常见的方法是交替计算 $U$ 的行和 $L$ 的列。\n\n对于从 $1$ 到 $n$ 的每个 $p$：\n1.  **计算 $U$ 的第 $p$ 行**：对于 $j = p, \\dots, n$，我们有：\n    $$A_{pj} = \\sum_{k=1}^{p} L_{pk} U_{kj} = \\sum_{k=1}^{p-1} L_{pk} U_{kj} + L_{pp} U_{pj}$$\n    由于 $L_{pp} = 1$，我们可以求解 $U_{pj}$：\n    $$U_{pj} = A_{pj} - \\sum_{k=1}^{p-1} L_{pk} U_{kj}$$\n    在第 $p$ 步，所需的元素 $L_{pk}$（对于 $k",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes LU factorization (Doolittle and Crout) for Hilbert matrices.\n    \"\"\"\n\n    def create_hilbert(n):\n        \"\"\"Constructs an n x n Hilbert matrix.\"\"\"\n        H = np.zeros((n, n), dtype=np.float64)\n        for i in range(n):\n            for j in range(n):\n                H[i, j] = 1.0 / (i + j + 1)\n        return H\n\n    def doolittle_lu(A):\n        \"\"\"\n        Computes the Doolittle LU factorization of matrix A (L is unit lower triangular).\n        Derived from first principles.\n        \"\"\"\n        n = A.shape[0]\n        L = np.eye(n, dtype=np.float64)\n        U = np.zeros((n, n), dtype=np.float64)\n\n        for p in range(n):\n            # Row p of U\n            for j in range(p, n):\n                # Summation part: sum(L[p, k] * U[k, j] for k in 0..p-1)\n                sum_val = np.dot(L[p, :p], U[:p, j])\n                U[p, j] = A[p, j] - sum_val\n\n            # Column p of L\n            if np.abs(U[p, p])  1e-16: # Avoid division by zero\n                # This should not happen for a positive definite matrix like Hilbert\n                # but is good practice for a general LU implementation.\n                raise np.linalg.LinAlgError(\"Zero pivot encountered in Doolittle LU\")\n\n            for i in range(p + 1, n):\n                # Summation part: sum(L[i, k] * U[k, p] for k in 0..p-1)\n                sum_val = np.dot(L[i, :p], U[:p, p])\n                L[i, p] = (A[i, p] - sum_val) / U[p, p]\n        \n        return L, U\n\n    def crout_lu(A):\n        \"\"\"\n        Computes the Crout LU factorization of matrix A (U is unit upper triangular).\n        Derived from first principles.\n        \"\"\"\n        n = A.shape[0]\n        L = np.zeros((n, n), dtype=np.float64)\n        U = np.eye(n, dtype=np.float64)\n\n        for p in range(n):\n            # Column p of L\n            for i in range(p, n):\n                # Summation part: sum(L[i, k] * U[k, p] for k in 0..p-1)\n                sum_val = np.dot(L[i, :p], U[:p, p])\n                L[i, p] = A[i, p] - sum_val\n            \n            # Row p of U\n            if np.abs(L[p, p])  1e-16: # Avoid division by zero\n                raise np.linalg.LinAlgError(\"Zero pivot encountered in Crout LU\")\n            \n            for j in range(p + 1, n):\n                # Summation part: sum(L[p, k] * U[k, j] for k in 0..p-1)\n                sum_val = np.dot(L[p, :p], U[:p, j])\n                U[p, j] = (A[p, j] - sum_val) / L[p, p]\n        \n        return L, U\n\n    test_cases_n = [1, 2, 5, 10]\n    results = []\n\n    for n in test_cases_n:\n        Hn = create_hilbert(n)\n\n        # Doolittle factorization\n        L_d, U_d = doolittle_lu(Hn)\n        g_L_d = np.max(np.abs(L_d))\n        g_U_d = np.max(np.abs(U_d))\n        residual_d = Hn - L_d @ U_d\n        r_inf_d = np.linalg.norm(residual_d, ord=np.inf)\n\n        # Crout factorization\n        L_c, U_c = crout_lu(Hn)\n        g_L_c = np.max(np.abs(L_c))\n        g_U_c = np.max(np.abs(U_c))\n        residual_c = Hn - L_c @ U_c\n        r_inf_c = np.linalg.norm(residual_c, ord=np.inf)\n        \n        # Assemble result list for this n\n        current_result = [n, g_L_d, g_U_d, g_L_c, g_U_c, r_inf_d, r_inf_c]\n        results.append(current_result)\n\n    # Format the final output string as a list of lists.\n    # The default str() representation of a list is used for the inner lists.\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    \n    # Final print statement must be exactly this single line\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}