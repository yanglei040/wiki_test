{
    "hands_on_practices": [
        {
            "introduction": "The journey from a continuous partial differential equation to a discrete linear system begins at the element level. This first practice dives into the core mechanics of assembling a single element stiffness matrix, a fundamental building block in any finite element code. You will bridge the gap between theory and computation by first deriving a matrix entry analytically and then verifying your result using numerical quadrature, reinforcing the principles of coordinate transformation and integration on a reference element. ",
            "id": "3098496",
            "problem": "Consider the steady diffusion model $-\\nabla \\cdot (\\mathbf{A} \\nabla u) = f$ on a rectangular domain, and focus on assembling the element stiffness matrix using the Finite Element Method (FEM). For a single $4$-node bilinear quadrilateral element whose physical coordinates are the rectangle with vertices at $(0,0)$, $(2,0)$, $(2,1)$, and $(0,1)$, let the material conductivity tensor be $$ \\mathbf{A} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix} $$ The element mapping from the reference square $[-1,1] \\times [-1,1]$ is given by $x(\\xi,\\eta) = 1 + \\xi$ and $y(\\xi,\\eta) = \\tfrac{1}{2} + \\tfrac{1}{2}\\eta$. The standard bilinear shape functions on the reference square are\n$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta)$, and $N_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta)$.\n\nStarting from the weak form definition of the element stiffness matrix, the $(i,j)$-entry is\n$$K_{e,ij} = \\int_{\\Omega_e} \\nabla N_i(x,y)^{\\top} \\mathbf{A} \\, \\nabla N_j(x,y) \\, \\mathrm{d}\\Omega,$$\nwhere $\\Omega_e$ is the physical element domain. Using only the core definitions above, do all of the following:\n- Derive analytically the value of the diagonal entry $K_{e,11}$ by mapping the integral to the reference domain and applying the chain rule for gradients.\n- Assemble $K_{e,11}$ numerically using tensor-product Gauss quadrature with $2$ points per direction on the reference square (use the standard abscissae $\\xi, \\eta = \\pm 1/\\sqrt{3}$ and weights $w_{\\xi} = w_{\\eta} = 1$), including the Jacobian determinant factor, and show it matches your analytic result.\n\nReport the single real number $K_{e,11}$. No rounding is required and no units are to be included in the answer.",
            "solution": "We begin from the weak form definition of the element stiffness matrix entry\n$$K_{e,11} = \\int_{\\Omega_e} \\nabla N_1(x,y)^{\\top} \\mathbf{A} \\, \\nabla N_1(x,y)\\, \\mathrm{d}\\Omega.$$\nWe will compute $K_{e,11}$ analytically and then by numerical quadrature on the reference square to verify agreement.\n\nAnalytic derivation:\nThe mapping from the reference coordinates $(\\xi,\\eta)$ to the physical coordinates $(x,y)$ is\n$$x(\\xi,\\eta) = 1 + \\xi,\\qquad y(\\xi,\\eta) = \\tfrac{1}{2} + \\tfrac{1}{2}\\eta.$$\nThe Jacobian matrix of this mapping is\n$$\\mathbf{J} = \\begin{pmatrix} \\dfrac{\\partial x}{\\partial \\xi} & \\dfrac{\\partial x}{\\partial \\eta} \\\\ \\dfrac{\\partial y}{\\partial \\xi} & \\dfrac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & \\tfrac{1}{2} \\end{pmatrix},\\quad \\det(\\mathbf{J}) = \\tfrac{1}{2}.$$\nThe gradient transformation follows from $\\nabla_{x} N = \\mathbf{J}^{-T} \\nabla_{\\xi} N$, so\n$$\\mathbf{J}^{-T} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix},\\qquad \\nabla_{x} N_1 = \\begin{pmatrix} \\dfrac{\\partial N_1}{\\partial x} \\\\ \\dfrac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix} \\begin{pmatrix} \\dfrac{\\partial N_1}{\\partial \\xi} \\\\ \\dfrac{\\partial N_1}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\dfrac{\\partial N_1}{\\partial \\xi} \\\\ 2 \\dfrac{\\partial N_1}{\\partial \\eta} \\end{pmatrix}.$$\nFor the bilinear shape function\n$$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),$$\nthe derivatives are\n$$\\dfrac{\\partial N_1}{\\partial \\xi} = -\\tfrac{1}{4}(1-\\eta),\\qquad \\dfrac{\\partial N_1}{\\partial \\eta} = -\\tfrac{1}{4}(1-\\xi).$$\nThus, in physical coordinates,\n$$\\dfrac{\\partial N_1}{\\partial x} = -\\tfrac{1}{4}(1-\\eta),\\qquad \\dfrac{\\partial N_1}{\\partial y} = 2\\left(-\\tfrac{1}{4}(1-\\xi)\\right) = -\\tfrac{1}{2}(1-\\xi).$$\nWith $$ \\mathbf{A} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}, $$ the integrand becomes\n$$\\nabla N_1^{\\top} \\mathbf{A} \\nabla N_1 = 2\\left(\\dfrac{\\partial N_1}{\\partial x}\\right)^{2} + 1\\left(\\dfrac{\\partial N_1}{\\partial y}\\right)^{2} = 2\\left(\\tfrac{(1-\\eta)^{2}}{16}\\right) + \\left(\\tfrac{(1-\\xi)^{2}}{4}\\right) = \\tfrac{(1-\\eta)^{2}}{8} + \\tfrac{(1-\\xi)^{2}}{4}.$$\nTransforming the integral to the reference domain yields\n$$K_{e,11} = \\int_{\\Omega_e} \\nabla N_1^{\\top} \\mathbf{A} \\nabla N_1 \\, \\mathrm{d}\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} \\left(\\tfrac{(1-\\eta)^{2}}{8} + \\tfrac{(1-\\xi)^{2}}{4}\\right) \\det(\\mathbf{J})\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta.$$\nSince $\\det(\\mathbf{J}) = \\tfrac{1}{2}$,\n$$K_{e,11} = \\tfrac{1}{2} \\left[ \\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta + \\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta \\right].$$\nSeparate the integrals:\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{8}\\left( \\int_{-1}^{1} (1-\\eta)^{2}\\, \\mathrm{d}\\eta \\right)\\left( \\int_{-1}^{1} \\mathrm{d}\\xi \\right),$$\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{4}\\left( \\int_{-1}^{1} (1-\\xi)^{2}\\, \\mathrm{d}\\xi \\right)\\left( \\int_{-1}^{1} \\mathrm{d}\\eta \\right).$$\nCompute the $1$-dimensional integrals:\n$$\\int_{-1}^{1} (1-\\eta)^{2}\\, \\mathrm{d}\\eta = \\int_{-1}^{1} (1 - 2\\eta + \\eta^{2})\\, \\mathrm{d}\\eta = \\left[\\eta - \\eta^{2} + \\tfrac{\\eta^{3}}{3}\\right]_{-1}^{1} = \\tfrac{8}{3},$$\n$$\\int_{-1}^{1} \\mathrm{d}\\xi = 2,\\qquad \\int_{-1}^{1} (1-\\xi)^{2}\\, \\mathrm{d}\\xi = \\tfrac{8}{3},\\qquad \\int_{-1}^{1} \\mathrm{d}\\eta = 2.$$\nTherefore,\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{8}\\cdot \\tfrac{8}{3}\\cdot 2 = \\tfrac{2}{3},$$\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{4}\\cdot \\tfrac{8}{3}\\cdot 2 = \\tfrac{4}{3}.$$\nThen\n$$K_{e,11} = \\tfrac{1}{2}\\left( \\tfrac{2}{3} + \\tfrac{4}{3} \\right) = \\tfrac{1}{2}\\cdot \\tfrac{6}{3} = \\tfrac{1}{2}\\cdot 2 = 1.$$\n\nNumerical quadrature verification:\nUsing $2$-point Gauss quadrature in each direction on $[-1,1]$, with abscissae $\\xi,\\eta = \\pm \\tfrac{1}{\\sqrt{3}}$ and weights $w_{\\xi} = w_{\\eta} = 1$, the tensor-product rule gives\n$$K_{e,11}^{\\text{(quad)}} = \\det(\\mathbf{J})\\sum_{k=1}^{2}\\sum_{\\ell=1}^{2} w_{\\xi_k} w_{\\eta_{\\ell}} \\left[ \\tfrac{(1-\\eta_{\\ell})^{2}}{8} + \\tfrac{(1-\\xi_{k})^{2}}{4} \\right].$$\nBecause $w_{\\xi_k} = w_{\\eta_{\\ell}} = 1$, we can separate sums:\n$$\\sum_{\\ell=1}^{2} (1-\\eta_{\\ell})^{2} = \\left(1 - \\tfrac{1}{\\sqrt{3}}\\right)^{2} + \\left(1 + \\tfrac{1}{\\sqrt{3}}\\right)^{2} = \\left(1 - \\tfrac{2}{\\sqrt{3}} + \\tfrac{1}{3}\\right) + \\left(1 + \\tfrac{2}{\\sqrt{3}} + \\tfrac{1}{3}\\right) = 2 + \\tfrac{2}{3} = \\tfrac{8}{3},$$\n$$\\sum_{k=1}^{2} (1-\\xi_{k})^{2} = \\tfrac{8}{3},\\qquad \\sum_{k=1}^{2} 1 = 2,\\qquad \\sum_{\\ell=1}^{2} 1 = 2.$$\nHence,\n$$\\sum_{k,\\ell}\\left[ \\tfrac{(1-\\eta_{\\ell})^{2}}{8} + \\tfrac{(1-\\xi_{k})^{2}}{4} \\right] = \\tfrac{1}{8}\\left(\\tfrac{8}{3}\\right)\\cdot 2 + \\tfrac{1}{4}\\left(\\tfrac{8}{3}\\right)\\cdot 2 = \\tfrac{2}{3} + \\tfrac{4}{3} = 2.$$\nMultiplying by $\\det(\\mathbf{J}) = \\tfrac{1}{2}$ gives\n$$K_{e,11}^{\\text{(quad)}} = \\tfrac{1}{2}\\cdot 2 = 1.$$\nThus, the numerical assembly using $2\\times 2$ Gauss quadrature exactly matches the analytic value.\n\nTherefore, the requested entry is\n$$K_{e,11} = 1.$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Once individual element matrices are understood, the next step is to assemble them into a global system representing the entire problem domain. This practice moves from a single element to a full 1D system, introducing a common and critical bug related to mesh connectivity. By intentionally creating disconnected components in the mesh data, you will learn to diagnose these structural problems by analyzing the singularity of the assembled stiffness matrix, providing a tangible link between linear algebra and physical stability. ",
            "id": "3098508",
            "problem": "Consider the one-dimensional steady diffusion problem on the interval $[0,1]$: find $u$ such that\n$$- \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) = f(x),$$\nwhere $a$ is a positive scalar diffusion coefficient and $f(x)$ is a given source. Use the Galerkin finite element method with continuous, piecewise-linear basis functions on a mesh defined by point coordinates and two-node elements. You will assemble the global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ from elemental contributions derived from the weak form. Intentionally introduce a bug into some test meshes by duplicating the Degree of Freedom (DOF) indices at shared physical vertices to create disconnected components. Detect the bug by checking the singularity (rank deficiency) of the assembled $\\mathbf{K}$ restricted to unknown DOFs after imposing Dirichlet boundary conditions.\n\nStarting from the weak form and the definition of the standard linear \"hat\" basis functions, derive the elemental stiffness matrix and a consistent elemental load rule. Implement an assembly routine that:\n- Builds the global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ from all elements.\n- Imposes homogeneous Dirichlet boundary conditions (i.e., $u=0$ on the specified DOFs) by eliminating the corresponding rows and columns in $\\mathbf{K}$ and entries in $\\mathbf{F}$.\n- Detects singularity by computing the number of near-zero eigenvalues (the nullity) of the reduced symmetric matrix. A matrix is considered to have a zero eigenvalue if its eigenvalue magnitude is less than a tolerance proportional to the largest eigenvalue.\n\nUse $a=1$ and $f(x)=x$. The geometry is dimensionless, and no physical units are required. The mesh is represented by:\n- A coordinate array of DOF positions $x_i$.\n- An element connectivity list of pairs $(i,j)$, each referring to DOF indices in the coordinate array.\n\nYour program must process the following test suite of meshes and boundary condition sets and output the nullity (an integer count of near-zero eigenvalues) for each case:\n\n- Test case $1$ (happy path, correct assembly):\n  - Coordinates: $[0,\\,0.5,\\,1]$.\n  - Elements: $(0,1)$ and $(1,2)$.\n  - Dirichlet set: $\\{0\\}$.\n  - Expected behavior: the reduced $\\mathbf{K}$ should be positive definite with nullity $0$.\n\n- Test case $2$ (buggy mesh with duplicated shared vertex, causing an unanchored component):\n  - Coordinates: $[0,\\,0.5,\\,0.5,\\,1]$ (the middle vertex at $x=0.5$ is represented by two distinct DOFs).\n  - Elements: $(0,1)$ and $(2,3)$.\n  - Dirichlet set: $\\{0\\}$.\n  - Expected behavior: the reduced $\\mathbf{K}$ should be singular with nullity $1$ due to an unanchored disconnected component.\n\n- Test case $3$ (buggy mesh but fully anchored):\n  - Coordinates: $[0,\\,0.5,\\,0.5,\\,1]$.\n  - Elements: $(0,1)$ and $(2,3)$.\n  - Dirichlet set: $\\{0,\\,3\\}$.\n  - Expected behavior: the reduced $\\mathbf{K}$ should be positive definite with nullity $0$ because all components are anchored by Dirichlet conditions.\n\n- Test case $4$ (buggy mesh with no Dirichlet conditions, multiple floating components):\n  - Coordinates: $[0,\\,0.5,\\,0.5,\\,1]$.\n  - Elements: $(0,1)$ and $(2,3)$.\n  - Dirichlet set: $\\{\\}$.\n  - Expected behavior: the reduced $\\mathbf{K}$ should be singular with nullity $2$ (one rigid mode per disconnected component).\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the test cases in the order listed above. For example, $[n_1,n_2,n_3,n_4]$, where each $n_k$ is the integer nullity for test case $k$.",
            "solution": "The task is to perform a numerical analysis on a one-dimensional steady diffusion problem using the Finite Element Method (FEM). We must derive the elemental matrices, implement an assembly procedure, and then use eigenvalue analysis of the assembled stiffness matrix to detect a specific type of mesh bug: disconnected components resulting from duplicated degrees of freedom (DOFs).\n\nThe governing differential equation is the one-dimensional diffusion equation on the interval $[0,1]$:\n$$\n- \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) = f(x)\n$$\nwhere $u(x)$ is the unknown function, $a$ is the diffusion coefficient (given as $a=1$), and $f(x)$ is the source term (given as $f(x)=x$).\n\n**1. Weak Formulation**\n\nTo derive the weak form, we multiply the governing equation by a suitable test function $v(x)$ and integrate over the domain $\\Omega = [0,1]$.\n$$\n- \\int_{0}^{1} v \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) dx = \\int_{0}^{1} v f(x) dx\n$$\nApplying integration by parts to the left-hand side term:\n$$\n\\int_{0}^{1} a \\frac{dv}{dx} \\frac{du}{dx} dx - \\left[ v a \\frac{du}{dx} \\right]_{0}^{1} = \\int_{0}^{1} v f(x) dx\n$$\nThe term $\\left[ v a \\frac{du}{dx} \\right]_{0}^{1}$ represents the natural (Neumann) boundary conditions. For the purpose of this problem, where we impose Dirichlet boundary conditions, we select test functions $v(x)$ that are zero at the Dirichlet boundaries. This makes the boundary term vanish.\n\nThe weak form is: find $u \\in V$ such that for all $v \\in \\hat{V}$:\n$$\nB(v, u) = L(v)\n$$\nwhere $V$ is the trial function space and $\\hat{V}$ is the test function space. The bilinear form $B(v, u)$ and the linear functional $L(v)$ are defined as:\n$$\nB(v, u) = \\int_{0}^{1} a \\frac{dv}{dx} \\frac{du}{dx} dx\n$$\n$$\nL(v) = \\int_{0}^{1} v(x) f(x) dx\n$$\n\n**2. Finite Element Discretization**\n\nWe discretize the domain $[0,1]$ into a mesh of elements. The solution $u(x)$ is approximated by a linear combination of piecewise-linear basis functions $\\phi_j(x)$, often called \"hat\" functions:\n$$\nu_h(x) = \\sum_{j=1}^{N_{dof}} U_j \\phi_j(x)\n$$\nHere, $N_{dof}$ is the total number of degrees of freedom (nodes), and $U_j$ are the unknown nodal values of the solution. The basis function $\\phi_j(x)$ has the property that it is equal to $1$ at node $j$ and $0$ at all other nodes.\n\nIn the Galerkin method, the test functions $v(x)$ are chosen from the same space as the basis functions, i.e., $v = \\phi_i(x)$ for $i=1, \\dots, N_{dof}$. Substituting this into the weak form yields a system of linear equations $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$, where:\n- $K_{ij} = B(\\phi_i, \\phi_j) = \\int_{0}^{1} a \\frac{d\\phi_i}{dx} \\frac{d\\phi_j}{dx} dx$ is the global stiffness matrix.\n- $F_i = L(\\phi_i) = \\int_{0}^{1} \\phi_i(x) f(x) dx$ is the global load vector.\n\n**3. Elemental Matrices Derivation**\n\nThe global matrices are assembled from contributions from each element. Let's consider a generic element $e$ connecting node $A$ at coordinate $x_A$ to node $B$ at coordinate $x_B$. The element length is $h_e = x_B - x_A$. Within this element, only two basis functions, $\\phi_A(x)$ and $\\phi_B(x)$, are non-zero.\n\nThe local basis functions on the element are:\n$$\n\\phi_A(x) = \\frac{x_B - x}{h_e} \\quad \\text{and} \\quad \\phi_B(x) = \\frac{x - x_A}{h_e}\n$$\nTheir derivatives are constant over the element:\n$$\n\\frac{d\\phi_A}{dx} = -\\frac{1}{h_e} \\quad \\text{and} \\quad \\frac{d\\phi_B}{dx} = \\frac{1}{h_e}\n$$\n\n**Elemental Stiffness Matrix $\\mathbf{k}^e$**:\nThe $2 \\times 2$ elemental stiffness matrix $\\mathbf{k}^e$ has entries $k^e_{ij} = \\int_{x_A}^{x_B} a \\frac{d\\phi_i}{dx} \\frac{d\\phi_j}{dx} dx$. Given $a=1$:\n$$\nk^e_{11} = \\int_{x_A}^{x_B} 1 \\cdot \\left(-\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = \\frac{1}{h_e^2} \\int_{x_A}^{x_B} dx = \\frac{h_e}{h_e^2} = \\frac{1}{h_e}\n$$\n$$\nk^e_{12} = \\int_{x_A}^{x_B} 1 \\cdot \\left(-\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = -\\frac{1}{h_e^2} \\int_{x_A}^{x_B} dx = -\\frac{1}{h_e}\n$$\nBy symmetry, $k^e_{21} = k^e_{12} = -1/h_e$, and $k^e_{22} = 1/h_e$. Thus, the elemental stiffness matrix is:\n$$\n\\mathbf{k}^e = \\frac{1}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n\n**Elemental Load Vector $\\mathbf{f}^e$**:\nThe elemental load vector $\\mathbf{f}^e$ for a source term $f(x)=x$ has entries $f^e_i = \\int_{x_A}^{x_B} x \\cdot \\phi_i(x) dx$.\n$$\nf^e_1 = \\int_{x_A}^{x_B} x \\left(\\frac{x_B - x}{h_e}\\right) dx = \\frac{1}{h_e} \\left[ x_B \\frac{x^2}{2} - \\frac{x^3}{3} \\right]_{x_A}^{x_B} = \\frac{h_e}{6}(2x_A + x_B)\n$$\n$$\nf^e_2 = \\int_{x_A}^{x_B} x \\left(\\frac{x - x_A}{h_e}\\right) dx = \\frac{1}{h_e} \\left[ \\frac{x^3}{3} - x_A \\frac{x^2}{2} \\right]_{x_A}^{x_B} = \\frac{h_e}{6}(x_A + 2x_B)\n$$\nSo, the consistent elemental load vector for $f(x)=x$ is:\n$$\n\\mathbf{f}^e = \\frac{h_e}{6} \\begin{pmatrix} 2x_A + x_B \\\\ x_A + 2x_B \\end{pmatrix}\n$$\n\n**4. Assembly and Boundary Conditions**\n\nThe assembly process involves iterating through each element, calculating its $\\mathbf{k}^e$ and $\\mathbf{f}^e$, and adding their values to the appropriate locations in the global $\\mathbf{K}$ and $\\mathbf{F}$ matrices, mapping local element nodes to global DOF indices.\n\nAfter assembly, homogeneous Dirichlet boundary conditions ($u_k=0$ for DOFs $k$ in a given set) are imposed. For the purpose of analyzing the matrix singularity, we are interested in the system corresponding to the *unknown* DOFs. Let $I$ be the set of indices for unknown DOFs. We form a reduced stiffness matrix, $\\mathbf{K}_{red}$, by selecting only the rows and columns of $\\mathbf{K}$ that correspond to the indices in $I$.\n\n**5. Singularity Detection**\n\nThe stiffness matrix $\\mathbf{K}$ for a diffusion problem without any Dirichlet boundary conditions is always singular (for a connected mesh, its nullity is $1$, corresponding to a constant \"rigid-body\" mode). Applying a Dirichlet condition at one node \"anchors\" the solution and makes the reduced matrix for the remaining unknowns non-singular (positive definite), assuming the mesh is connected.\n\nThe problem introduces a bug where a physically connected mesh is represented by disconnected components in the data structure (e.g., coordinates $[0, 0.5, 0.5, 1]$ and elements $(0,1), (2,3)$). This creates two separate graphs. Each disconnected component that is not anchored by a Dirichlet boundary condition will contribute a rigid-body mode, and thus a zero eigenvalue, to the stiffness matrix. The nullity (the dimension of the null space) of the reduced matrix $\\mathbf{K}_{red}$ is the number of such unanchored components.\n\nWe can compute the nullity by finding the number of eigenvalues of $\\mathbf{K}_{red}$ that are numerically zero. Since $\\mathbf{K}_{red}$ is symmetric and positive semi-definite, its eigenvalues are real and non-negative. We calculate all eigenvalues and count how many have a magnitude smaller than a tolerance, defined as a small fraction of the largest eigenvalue's magnitude (e.g., $|\\lambda_i| < 10^{-12} |\\lambda_{max}|$). This count gives the nullity of $\\mathbf{K}_{red}$.",
            "answer": "```python\nimport numpy as np\n\ndef assemble_and_check(coords, elements, dirichlet_dofs):\n    \"\"\"\n    Assembles the stiffness matrix and load vector for a 1D diffusion problem,\n    imposes Dirichlet boundary conditions, and computes the nullity of the\n    reduced stiffness matrix.\n\n    Args:\n        coords (list or np.ndarray): Nodal coordinates.\n        elements (list of tuples): Element connectivity (pairs of DOF indices).\n        dirichlet_dofs (set): Set of DOF indices with Dirichlet boundary conditions.\n\n    Returns:\n        int: The nullity of the reduced stiffness matrix.\n    \"\"\"\n    n_dofs = len(coords)\n    K = np.zeros((n_dofs, n_dofs))\n    # The load vector F is not required for singularity check but is assembled for completeness.\n    F = np.zeros(n_dofs)\n    \n    # Constant diffusion coefficient\n    a = 1.0\n\n    # Assembly loop\n    for elem in elements:\n        dof1, dof2 = elem\n        x1, x2 = coords[dof1], coords[dof2]\n        \n        # Ensure h is positive, although order doesn't matter for stiffness matrix.\n        h = abs(x2 - x1)\n        if h &lt; 1e-15:\n            # Avoid division by zero for zero-length elements, though not in test cases.\n            continue\n            \n        # Elemental stiffness matrix for a=1\n        k_elem = (a / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Elemental load vector for f(x)=x\n        # f_elem = (h/6) * [2*x_A + x_B, x_A + 2*x_B]\n        # Use min/max to ensure x_A < x_B for the formula\n        x_A, x_B = min(x1, x2), max(x1, x2)\n        f_elem_vals = (h / 6.0) * np.array([2 * x_A + x_B, x_A + 2 * x_B])\n        # The order of f_elem must match the dof order in the element tuple\n        if x1 &gt; x2:\n            f_elem = np.array([f_elem_vals[1], f_elem_vals[0]])\n        else:\n            f_elem = f_elem_vals\n        \n        # Add to global matrices\n        ix = np.ix_([dof1, dof2], [dof1, dof2])\n        K[ix] += k_elem\n        F[[dof1, dof2]] += f_elem\n\n    # Identify unknown DOFs\n    all_dofs = set(range(n_dofs))\n    unknown_dofs = sorted(list(all_dofs - set(dirichlet_dofs)))\n\n    if not unknown_dofs:\n        return 0 # No unknown DOFs, reduced matrix is empty, nullity is 0.\n    \n    # Extract reduced stiffness matrix\n    K_reduced = K[np.ix_(unknown_dofs, unknown_dofs)]\n    \n    if K_reduced.shape[0] == 0:\n        return 0\n\n    # Compute eigenvalues of the symmetric reduced matrix\n    eigenvalues = np.linalg.eigh(K_reduced)[0]\n    \n    # Determine the tolerance for a \"zero\" eigenvalue\n    max_eig_abs = np.max(np.abs(eigenvalues)) if eigenvalues.size > 0 else 0.0\n    \n    # If the largest eigenvalue is itself near zero, all are zero.\n    # The tolerance must be absolute in this case.\n    if max_eig_abs < 1e-12:\n        return K_reduced.shape[0]\n\n    # Relative tolerance based on the largest eigenvalue\n    tolerance = max_eig_abs * 1e-12\n    \n    # Count eigenvalues smaller than the tolerance\n    nullity = np.sum(np.abs(eigenvalues) < tolerance)\n    \n    return int(nullity)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results.\n    \"\"\"\n    # Test case 1 (happy path, correct assembly)\n    test_case_1 = {\n        \"coords\": [0.0, 0.5, 1.0],\n        \"elements\": [(0, 1), (1, 2)],\n        \"dirichlet_dofs\": {0}\n    }\n\n    # Test case 2 (buggy mesh with duplicated shared vertex, causing an unanchored component)\n    test_case_2 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": {0}\n    }\n\n    # Test case 3 (buggy mesh but fully anchored)\n    test_case_3 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": {0, 3}\n    }\n\n    # Test case 4 (buggy mesh with no Dirichlet conditions, multiple floating components)\n    test_case_4 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": set()\n    }\n    \n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    \n    results = []\n    for case in test_cases:\n        nullity = assemble_and_check(\n            case[\"coords\"], case[\"elements\"], case[\"dirichlet_dofs\"]\n        )\n        results.append(nullity)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The correctness of a finite element assembly depends not only on topological connectivity but also on geometric consistency. This practice addresses a subtle but pervasive bug in 2D and 3D codes: errors arising from inconsistent element orientation (i.e., clockwise vs. counter-clockwise vertex ordering). You will implement an assembly for a boundary flux term and learn to ensure that element normals are always pointing outward, using the Divergence Theorem as a powerful tool for verification. ",
            "id": "3098532",
            "problem": "Consider a two-dimensional triangular mesh used in the Finite Element Method (FEM) to assemble edge-based contributions for a scalar problem where the boundary load vector is induced by a flux term. The mathematical foundation is the Divergence Theorem from vector calculus: for a sufficiently smooth vector field $\\mathbf{f}(x,y)$ on a planar domain $\\Omega$, one has\n$$\n\\int_{\\partial\\Omega} \\mathbf{f}\\cdot\\mathbf{n}\\,ds \\;=\\; \\int_{\\Omega} \\nabla\\cdot \\mathbf{f}\\,dA,\n$$\nwhere $\\mathbf{n}$ is the outward unit normal and $\\nabla\\cdot\\mathbf{f}$ denotes the divergence. For a linear vector field $\\mathbf{f}(x,y) = \\big(a_1 x + b_1 y + c_1,\\; a_2 x + b_2 y + c_2\\big)$, the divergence $\\nabla\\cdot\\mathbf{f}$ equals the constant $a_1 + b_2$.\n\nEdge-based assembly computes the boundary integral by summing contributions over element edges. Let a triangular element have vertices $\\mathbf{v}_0$, $\\mathbf{v}_1$, $\\mathbf{v}_2$ given in the element’s local ordering. For an oriented edge with tangent vector $\\mathbf{t} = \\mathbf{v}_j - \\mathbf{v}_i$, define the unnormalized left normal by a rotation of $+\\pi/2$ (angle unit specified as radians), namely\n$$\nR_{+\\pi/2}(\\mathbf{t}) = \\begin{bmatrix} -t_y \\\\ t_x \\end{bmatrix},\n$$\nwhose magnitude equals the edge length. The per-edge contribution based on the midpoint rule is\n$$\n\\big(\\mathbf{f}(\\tfrac{\\mathbf{v}_i+\\mathbf{v}_j}{2})\\big)\\cdot R_{+\\pi/2}(\\mathbf{t}),\n$$\nand summing such contributions over all edges of all elements reproduces the boundary integral when each edge normal is outward with respect to the element. However, when some elements are oriented clockwise and others counterclockwise (alternating orientation), using $R_{+\\pi/2}$ blindly for all edges creates orientation-related sign errors: for clockwise elements, the left normal points inward rather than outward, flipping the sign of contributions.\n\nYour task is to:\n- Implement a naive assembly that uses $R_{+\\pi/2}$ for all edges without accounting for the element orientation.\n- Identify the orientation-related sign error by comparing the naive assembly’s total flux with the Divergence Theorem’s prediction.\n- Implement a corrected assembly that ensures outward normals for every element edge by consistently handling element orientation.\n- For each test case, output a boolean indicating whether the naive assembly is incorrect (beyond a small tolerance) and the corrected assembly is correct (within the tolerance), based on the Divergence Theorem.\n\nUse the following test suite. Each test case provides a mesh and a linear vector field. Vertices are listed as $(x,y)$ points. Triangles are given as tuples of vertex indices $(i,j,k)$ using zero-based indexing. Some triangles are intentionally clockwise to induce alternating orientation. For all cases below, the angle unit is radians.\n\nTest case $1$:\n- Vertices: [(0,0),(1,0),(1,1),(0,1)].\n- Triangles: [(0,1,2),(3,2,0)].\n- Vector field: $\\mathbf{f}(x,y) = (x + 0\\cdot y + 0,\\; 0\\cdot x + 2 y + 0)$, so $a_1 = 1$, $b_1 = 0$, $c_1 = 0$, $a_2 = 0$, $b_2 = 2$, $c_2 = 0$, and $\\nabla\\cdot\\mathbf{f} = 1 + 2 = 3$. The domain area is $1$, hence the expected total flux equals $3$.\n\nTest case $2$:\n- Vertices: [(0,0),(1,0),(2,0),(0,1),(1,1),(2,1),(0,2),(1,2)].\n- Triangles: [(0,1,4),(3,4,0),(1,2,5),(4,5,1),(3,4,7),(6,7,3)].\n- Vector field: $\\mathbf{f}(x,y) = (2x + 1 y + 0,\\; -1 x + 3 y + 0)$, so $a_1 = 2$, $b_1 = 1$, $c_1 = 0$, $a_2 = -1$, $b_2 = 3$, $c_2 = 0$, and $\\nabla\\cdot\\mathbf{f} = 2 + 3 = 5$. The domain area is $3$, hence the expected total flux equals $15$.\n\nTest case $3$:\n- Vertices: [(0,0),(3,0),(3,0.2),(0,0.2),(1.5,0),(1.5,0.2)].\n- Triangles: [(0,4,5),(3,5,0),(4,1,2),(5,2,4)].\n- Vector field: $\\mathbf{f}(x,y) = (3x + (-1) y + 0,\\; 0 x + 4 y + 0)$, so $a_1 = 3$, $b_1 = -1$, $c_1 = 0$, $a_2 = 0$, $b_2 = 4$, $c_2 = 0$, and $\\nabla\\cdot\\mathbf{f} = 3 + 4 = 7$. The domain area is $0.6$, hence the expected total flux equals $4.2$.\n\nProgram requirements:\n- Compute the naive total flux by summing midpoint-based edge contributions using $R_{+\\pi/2}$ for all edges.\n- Compute the corrected total flux by ensuring outward edge normals for each element consistently, regardless of clockwise or counterclockwise vertex ordering.\n- Compute the expected flux as $(a_1 + b_2)\\times(\\text{total area})$, where total area is the sum of absolute triangle areas.\n- Use a tolerance of $10^{-10}$ for comparisons.\n- For each test case, output a boolean that is true if the naive flux deviates from the expected flux by more than the tolerance and the corrected flux matches the expected flux within the tolerance; otherwise output false.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., [`result`_1,`result`_2,`result`_3]). Each `result`_i must be a boolean value computed for the $i$-th test case.",
            "solution": "The problem is assessed to be valid. It is scientifically sound, well-posed, and all necessary data and definitions for a unique solution are provided. The task is to implement and compare two methods for calculating the total flux of a vector field across a triangular mesh, demonstrating a common pitfall related to element orientation in the Finite Element Method (FEM).\n\nThe theoretical foundation of this problem is the Divergence Theorem, which states that for a vector field $\\mathbf{f}$ on a domain $\\Omega$ with boundary $\\partial\\Omega$, the integral of the divergence of $\\mathbf{f}$ over the domain is equal to the flux of $\\mathbf{f}$ across the boundary:\n$$\n\\int_{\\Omega} (\\nabla\\cdot \\mathbf{f}) \\,dA = \\int_{\\partial\\Omega} \\mathbf{f}\\cdot\\mathbf{n}\\,ds\n$$\nwhere $\\mathbf{n}$ is the outward unit normal to the boundary $\\partial\\Omega$. The problem considers a linear vector field of the form $\\mathbf{f}(x,y) = (a_1 x + b_1 y + c_1, a_2 x + b_2 y + c_2)$, for which the divergence $\\nabla\\cdot\\mathbf{f} = \\frac{\\partial f_x}{\\partial x} + \\frac{\\partial f_y}{\\partial y}$ is a constant value, $\\nabla\\cdot\\mathbf{f} = a_1 + b_2$. In this case, the domain integral simplifies to:\n$$\n\\int_{\\Omega} (\\nabla\\cdot \\mathbf{f}) \\,dA = (a_1 + b_2) \\int_{\\Omega} dA = (a_1 + b_2) \\times \\text{Area}(\\Omega)\n$$\nThis value serves as the ground truth, or the `expected flux`.\n\nIn FEM, the domain $\\Omega$ is discretized into a mesh of elements, in this case, triangles $T_e$. The total integral over $\\Omega$ can be expressed as the sum of integrals over each element:\n$$\n\\int_{\\Omega} (\\nabla\\cdot \\mathbf{f}) \\,dA = \\sum_{e} \\int_{T_e} (\\nabla\\cdot \\mathbf{f}) \\,dA\n$$\nApplying the Divergence Theorem to each element $T_e$ individually relates the integral of the divergence over the element's area to the flux across the element's boundary $\\partial T_e$:\n$$\n\\int_{T_e} (\\nabla\\cdot \\mathbf{f}) \\,dA = \\int_{\\partial T_e} \\mathbf{f} \\cdot \\mathbf{n}_e \\,ds\n$$\nHere, $\\mathbf{n}_e$ must be the normal vector pointing *outward* from the element $T_e$. Summing these element-wise boundary integrals gives the total expected flux:\n$$\n\\sum_{e} \\int_{\\partial T_e} \\mathbf{f} \\cdot \\mathbf{n}_e \\,ds = \\sum_{e} (a_1 + b_2) \\times \\text{Area}(T_e) = (a_1 + b_2) \\times \\text{Total Area}\n$$\nThe problem requires the calculation of the edge integrals $\\int \\mathbf{f} \\cdot \\mathbf{n}_e \\,ds$ using the midpoint rule. For a straight edge between vertices $\\mathbf{v}_i$ and $\\mathbf{v}_j$ and a linear vector field $\\mathbf{f}$, this rule is exact. The contribution from one edge is given by $\\mathbf{f}(\\mathbf{m}) \\cdot \\mathbf{N}$, where $\\mathbf{m} = (\\mathbf{v}_i + \\mathbf{v}_j)/2$ is the edge midpoint and $\\mathbf{N}$ is a normal vector whose magnitude is the edge length. The problem defines this normal as the \"unnormalized left normal\" $R_{+\\pi/2}(\\mathbf{t})$, where $\\mathbf{t} = \\mathbf{v}_j - \\mathbf{v}_i$ is the tangent vector.\n\nThe core of the problem lies in the orientation of elements. The `naive assembly` applies the left normal rule blindly to all edges of all elements, following the vertex order specified for each triangle (e.g., edges $(\\mathbf{v}_0, \\mathbf{v}_1)$, $(\\mathbf{v}_1, \\mathbf{v}_2)$, $(\\mathbf{v}_2, \\mathbf{v}_0)$).\n- If a triangle's vertices $(\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2)$ are ordered counter-clockwise (CCW), traversing the edges in this order means the \"left normal\" consistently points outward from the triangle. The sum of contributions for this element correctly calculates $\\int_{T_e} (\\nabla\\cdot\\mathbf{f}) \\,dA = (a_1+b_2) \\times \\text{Area}(T_e)$.\n- If a triangle's vertices are ordered clockwise (CW), the \"left normal\" consistently points *inward*. The resulting sum is therefore the negative of the true flux: $-\\int_{T_e} (\\nabla\\cdot\\mathbf{f}) \\,dA = -(a_1+b_2) \\times \\text{Area}(T_e)$.\n\nThe orientation of a triangle with vertices $\\mathbf{v}_0 = (x_0, y_0)$, $\\mathbf{v}_1 = (x_1, y_1)$, and $\\mathbf{v}_2 = (x_2, y_2)$ can be determined by its signed area:\n$$A_e^{\\text{signed}} = \\frac{1}{2} \\det\\begin{pmatrix} x_1-x_0 & x_2-x_0 \\\\ y_1-y_0 & y_2-y_0 \\end{pmatrix}\n$$\nA positive sign indicates CCW orientation, while a negative sign indicates CW orientation. The naive flux calculation thus sums to:\n$$\n\\text{Flux}_{\\text{naive}} = \\sum_e (a_1+b_2) \\times A_e^{\\text{signed}} = (a_1+b_2) \\sum_e A_e^{\\text{signed}}\n$$\nWith alternating orientations as given in the test cases, the sum of signed areas is close to or exactly $0$, leading to a grossly incorrect total flux.\n\nThe `corrected assembly` rectifies this. For each element, it first determines the orientation by computing the sign of the signed area, $\\sigma_e = \\text{sign}(A_e^{\\text{signed}})$. The correct outward normal for an edge is then $\\sigma_e \\times (\\text{left normal})$. Using this consistently outward-pointing normal, the contribution from each element becomes $(a_1+b_2) \\times |A_e^{\\text{signed}}| = (a_1+b_2) \\times \\text{Area}(T_e)$. Summing these contributions yields the corrected total flux:\n$$\n\\text{Flux}_{\\text{corrected}} = \\sum_e (a_1+b_2) \\times \\text{Area}(T_e) = (a_1+b_2) \\times \\text{Total Area}\n$$\nThis result correctly matches the expected flux derived from the Divergence Theorem applied to the entire domain. The implementation will follow this logic for each test case, using a tolerance of $10^{-10}$ for floating-point comparisons to determine the final boolean output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases.\n    It implements a naive and a corrected flux assembly for a given mesh and vector field,\n    and compares the results against the prediction from the Divergence Theorem.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"vertices\": np.array([[0,0],[1,0],[1,1],[0,1]]),\n            \"triangles\": [[0,1,2],[3,2,0]],\n            \"f_params\": {\"a1\": 1, \"b1\": 0, \"c1\": 0, \"a2\": 0, \"b2\": 2, \"c2\": 0},\n            \"expected_flux\": 3.0\n        },\n        {\n            \"vertices\": np.array([\n                [0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,2],[1,2]\n            ]),\n            \"triangles\": [[0,1,4],[3,4,0],[1,2,5],[4,5,1],[3,4,7],[6,7,3]],\n            \"f_params\": {\"a1\": 2, \"b1\": 1, \"c1\": 0, \"a2\": -1, \"b2\": 3, \"c2\": 0},\n            \"expected_flux\": 15.0\n        },\n        {\n            \"vertices\": np.array([\n                [0,0],[3,0],[3,0.2],[0,0.2],[1.5,0],[1.5,0.2]\n            ]),\n            \"triangles\": [[0,4,5],[3,5,0],[4,1,2],[5,2,4]],\n            \"f_params\": {\"a1\": 3, \"b1\": -1, \"c1\": 0, \"a2\": 0, \"b2\": 4, \"c2\": 0},\n            \"expected_flux\": 4.2\n        }\n    ]\n\n    results = []\n    tolerance = 1e-10\n\n    for case in test_cases:\n        vertices = case[\"vertices\"]\n        triangles = case[\"triangles\"]\n        f_params = case[\"f_params\"]\n        expected_flux = case[\"expected_flux\"]\n\n        def vector_field(x, y):\n            fx = f_params['a1'] * x + f_params['b1'] * y + f_params['c1']\n            fy = f_params['a2'] * x + f_params['b2'] * y + f_params['c2']\n            return np.array([fx, fy])\n\n        naive_total_flux = 0.0\n        corrected_total_flux = 0.0\n        \n        # Although expected flux is given, we can recalculate it for verification\n        # based on the sum of absolute areas.\n        # total_area = 0.0\n        # div_f = f_params['a1'] + f_params['b2']\n\n        for tri_indices in triangles:\n            v0, v1, v2 = vertices[tri_indices]\n            \n            # Calculate signed area to determine orientation\n            # Area = 0.5 * det([v1-v0, v2-v0])\n            edge1 = v1 - v0\n            edge2 = v2 - v0\n            signed_area = 0.5 * (edge1[0] * edge2[1] - edge1[1] * edge2[0])\n            orientation_sign = np.sign(signed_area)\n            if orientation_sign == 0: # Degenerate triangle\n                continue\n                \n            # total_area += abs(signed_area)\n\n            edges = [(v0, v1), (v1, v2), (v2, v0)]\n            \n            for v_start, v_end in edges:\n                tangent = v_end - v_start\n                # Unnormalized left normal (rotation by +pi/2)\n                left_normal = np.array([-tangent[1], tangent[0]])\n                \n                midpoint = 0.5 * (v_start + v_end)\n                f_at_midpoint = vector_field(midpoint[0], midpoint[1])\n                \n                # Naive assembly: always use the left normal\n                naive_edge_contrib = np.dot(f_at_midpoint, left_normal)\n                naive_total_flux += naive_edge_contrib\n                \n                # Corrected assembly: ensure normal is outward\n                outward_normal = left_normal * orientation_sign\n                corrected_edge_contrib = np.dot(f_at_midpoint, outward_normal)\n                corrected_total_flux += corrected_edge_contrib\n\n        is_naive_wrong = abs(naive_total_flux - expected_flux) &gt; tolerance\n        is_corrected_right = abs(corrected_total_flux - expected_flux) &lt;= tolerance\n\n        result = is_naive_wrong and is_corrected_right\n        results.append(result)\n        \n    # The final print must be in the exact format requested.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}