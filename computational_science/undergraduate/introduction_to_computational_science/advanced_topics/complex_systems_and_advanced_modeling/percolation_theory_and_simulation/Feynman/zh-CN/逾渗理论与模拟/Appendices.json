{
    "hands_on_practices": [
        {
            "introduction": "在二维晶格系统中，对偶性是一个优美而深刻的概念，它为我们理解渗流现象提供了强有力的理论工具。对于一个平面矩形网格，其上的“主”渗流构型（例如，连接左右边界的通路）与其“对偶”构型（连接上下边界的通路）的出现是互斥的。这个几何特性直接导出了二维方格晶格键渗流的临界概率恰好为 $p_c = 1/2$ 的著名结果。本练习将引导你通过计算模拟，亲手验证这一深刻的几何定理，并直观地感受临界点附近的行为。",
            "id": "3171640",
            "problem": "考虑方形晶格上的独立键渗流：每条边以概率 $p \\in [0,1]$ 独立地被声明为开放，否则为闭合。设原始图为 $H \\times W$ 顶点矩形阵列上的常规网格图，其边为最近邻连接（水平和垂直）。对偶图的顶点对应于原始图的面，其对偶边与原始边相交。在渗流叠加中，当且仅当对应的原始边是闭合时，声明一条对偶边为开放，因此对偶渗流参数为 $1-p$。原始图的左右贯穿是指存在一条开放路径，连接左侧（所有列索引为 $0$ 的顶点）和右侧（所有列索引为 $W-1$ 的顶点）。对偶图的上下贯穿是指在对偶图中存在一条开放路径，连接对偶顶部边界和对偶底部边界，其中对偶边界顶点由与原始边界边的邻接关系定义。\n\n您的任务是编写一个完整、可运行的程序，通过在参数 $p$ 和 $1-p$ 下叠加原始和对偶构型，来经验性地验证平面上的对偶性，并检查“原始图左右贯穿”和“对偶图上下贯穿”这两个事件是否是互斥且穷尽的。此外，对于自对偶点（$H=W$ 的方形区域且参数 $p=1/2$），数值上检验原始图左右贯穿事件的贯穿概率。\n\n从以下基础出发：\n- 键的独立性：每条边的状态是一个参数为 $p$ 的独立伯努利随机变量。\n- 平面性与对偶性：在平面矩形网格中，对于任何固定的原始边开放/闭合构型，对偶图的开放边恰好是原始图的闭合边。一个经过充分验证的事实是，对于一个矩形，要么在原始图中存在一个开放的左右贯穿，要么在对偶图中存在一个开放的上下贯穿，并且这两个事件是不相交的。\n- 算法原语：使用广度优先搜索（BFS）检测原始图的连通性，使用并查集（DSU）检测对偶图的连通性。\n\n实现以下算法规范：\n- 使用固定的伪随机数生成器种子 $42$ 以确保可复现性，通过以概率 $p$ 独立抽样水平和垂直边为开放来生成原始边状态。对偶边状态被确定性地定义为相应原始边状态的补集。\n- 使用广度优先搜索（BFS）检测原始图的左右开放贯穿，从左边界顶点开始，仅沿着开放边进行探索；如果到达任何右边界顶点，则声明成功。\n- 通过使用并查集（DSU）在面上建立对偶连通性来检测对偶图的上下开放贯穿。添加两个特殊对偶节点，分别代表顶部和底部边界。对于每条闭合的原始边：\n  - 如果它是顶部边界上的一条水平边，则将顶部边界节点与相邻面进行合并。\n  - 如果它是内部的一条水平边，则将该边上方和下方的面进行合并。\n  - 如果它是底部边界上的一条水平边，则将底部边界节点与相邻面进行合并。\n  - 如果它是内部的一条垂直边（不在最左侧或最右侧边界上），则将该边左侧和右侧的面进行合并。\n如果顶部和底部对偶边界节点在 DSU 结构中是连通的，则声明存在对偶图的上下贯穿。\n- 对于每个构型，记录是否恰好发生两个事件中的一个。对每个测试用例的多个独立试验结果进行汇总。\n\n使用以下具有指定参数 $(H,W,p,\\text{trials})$ 的测试套件：\n- 测试 $1$：$(20,20,0.5,500)$ 是一个自对偶方形情况（$H=W$ 且 $p=1/2$）。\n- 测试 $2$：$(20,20,0.3,400)$ 是一个类亚临界情况。\n- 测试 $3$：$(20,20,0.7,400)$ 是一个类超临界情况。\n- 测试 $4$：$(10,30,0.5,500)$ 是一个矩形自对偶参数情况（$p=1/2$）但非方形（$H \\ne W$）。\n- 测试 $5$：$(3,3,0.5,1000)$ 是一个小型方形自对偶情况。\n\n对于每个测试用例，您的程序必须计算：\n- 一个布尔值，表示所有试验中的互斥性，当且仅当对于每次试验都恰好发生其中一个事件时，该值为真。\n- 经验性的原始图左右贯穿概率，以 $[0,1]$ 范围内的小数表示。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n  $[$exclusivity\\_1, primal\\_prob\\_1, exclusivity\\_2, primal\\_prob\\_2, exclusivity\\_3, primal\\_prob\\_3, exclusivity\\_4, primal\\_prob\\_4, exclusivity\\_5, primal\\_prob\\_5$]$。\n- 所有概率必须是小数（而非百分比）。\n\n不允许外部输入。程序必须是自包含的，并能按规定运行。",
            "solution": "我们描述了将键渗流中的平面-对偶性与通过模拟进行的算法验证联系起来的基于原理的设计。\n\n基础定义。在 $H \\times W$ 矩形网格上的独立键渗流中，每条边以概率 $p$ 开放，以概率 $1-p$ 闭合，且各边独立。对偶图的顶点对应于原始图的面。每条对偶边恰好与一条原始边相交。当原始边闭合时声明对偶边开放，这将在参数 $p$ 和 $1-p$ 下叠加构型。\n\n核心对偶性质。在平面矩形中，一个经过充分验证的事实是，对于任何固定的构型，以下两个事件中恰好发生一个：原始图中的开放左右贯穿，或对偶图中的开放上下贯穿。其原因是几何上的。任何原始图的左右开放路径，如果与对偶图的上下开放路径同时存在，将迫使一条开放的原始边与其相交的开放对偶边相交，这是不可能的，因为对偶边与原始边相交意味着该原始边是闭合的。反之，如果不存在原始图的左右开放路径，那么闭合的原始边集合中必然包含一条将左侧与右侧分隔开的对偶上下开放路径；在平面图中，这种分隔对应于存在一条通过与闭合边相邻的面连接顶部和底部边界的对偶路径。因此，这两个事件是不相交的且是穷尽的：对于每种构型，异或关系（一个成立而另一个不成立）都成立。\n\n$p=1/2$ 时的自对偶对称性。当 $p=1/2$ 且区域为方形（$H=W$）时，渗流模型在 $90^\\circ$ 旋转并交换开放和闭合状态（这在 $p=1/2$ 时保持了分布不变）的操作下是对称的。因此，原始图左右开放贯穿的概率等于对偶图上下开放贯穿的概率，并且根据互斥性，每个概率都为 $1/2$。在有限的模拟中，抽样误差会导致一个接近 $1/2$ 的估计值。\n\n算法设计。我们实现两个检测器：\n- 通过广度优先搜索（BFS）检测原始图左右贯穿。用所有左边界顶点 $(r,0)$（其中 $r \\in \\{0,\\dots,H-1\\}$）初始化一个队列。当队列不为空时，弹出一个顶点，并将所有可通过开放原始边（水平或垂直）到达的邻居推入队列。如果到达一个列索引为 $W-1$ 的顶点，则声明存在贯穿。此方法探索开放子图中左边界站点的连通分量，每次试验的时间复杂度为 $O(HW)$。\n- 通过并查集（DSU）检测对偶图上下贯穿。为所有 $(H-1) \\times (W-1)$ 个面构建对偶节点，并为顶部和底部额外添加两个边界节点。对于每条闭合的原始边：\n  - 位于行 $r=0$（顶部边界）的水平边将顶部边界节点与其下方的面连接起来。\n  - 位于 $1 \\le r \\le H-2$（内部）的水平边将上方的面与下方的面连接起来。\n  - 位于 $r=H-1$（底部边界）的水平边将底部边界节点与其上方的面连接起来。\n  - 位于 $1 \\le c \\le W-2$（内部）的垂直边将左侧的面与右侧的面连接起来。\n我们不需要表示左侧或右侧的对偶边界节点，因为它们与上下连通性无关。在合并操作之后，如果 DSU 发现顶部和底部边界节点在同一个集合中，我们声明存在对偶图的上下贯穿。该算法的运行时间在面和边的数量上接近线性。\n\n模拟协议。对于每个测试用例 $(H,W,p,\\text{trials})$：\n- 用种子 $42$ 初始化一个伪随机数生成器以保证可复现性。\n- 对于每次试验，通过将均匀随机数与 $p$ 进行比较，来抽样开放的原始边（水平形状为 $H \\times (W-1)$，垂直形状为 $(H-1) \\times W$）。\n- 通过 BFS 判断原始图左右贯穿，并通过在补集（闭合的原始边）上使用 DSU 判断对偶图上下贯穿。\n- 如果两个事件相等（都为真或都为假），则记录一次违规。根据对偶性，违规次数应为零。\n- 统计原始图贯穿次数以估计经验贯穿概率。\n\n输出设计。对于每个测试用例 $i$，输出两个值：\n- 一个布尔互斥标志，指示是否所有试验都满足互斥性（零违规）。\n- 经验性的原始图左右贯穿概率，以小数形式表示。\n\n将所有测试用例的结果汇总为规定的单行格式：\n$[$exclusivity\\_1, primal\\_prob\\_1, exclusivity\\_2, primal\\_prob\\_2, exclusivity\\_3, primal\\_prob\\_3, exclusivity\\_4, primal\\_prob\\_4, exclusivity\\_5, primal\\_prob\\_5$]$。\n\n正确性与期望。由于平面-对偶性，所有测试的互斥标志都应为真。对于自对偶方形情况（$H=W$ 且 $p=1/2$），经验原始贯穿概率应接近 $1/2$，其偏差与抽样误差一致。对于显著低于或高于 $1/2$ 的 $p$ 值，在有限网格上，贯穿概率应分别反映出类亚临界或类超临界行为。\n\n计算方面的考虑。每次试验的 BFS 和 DSU 操作时间复杂度为 $O(HW)$，且整个测试套件的总试验次数适中，确保了快速执行。固定的种子保证了可复现的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\nclass DSU:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x: int) -> int:\n        # Path compression\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n\n    def union(self, a: int, b: int):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra == rb:\n            return\n        # Union by rank\n        if self.rank[ra]  self.rank[rb]:\n            self.parent[ra] = rb\n        elif self.rank[ra] > self.rank[rb]:\n            self.parent[rb] = ra\n        else:\n            self.parent[rb] = ra\n            self.rank[ra] += 1\n\ndef sample_edges(H: int, W: int, p: float, rng: np.random.Generator):\n    # Horizontal edges: H rows, W-1 columns\n    h_open = rng.random((H, W - 1))  p\n    # Vertical edges: H-1 rows, W columns\n    v_open = rng.random((H - 1, W))  p\n    return h_open, v_open\n\ndef primal_lr_crossing(H: int, W: int, h_open: np.ndarray, v_open: np.ndarray) -> bool:\n    # BFS from all left boundary vertices (r, 0)\n    visited = np.zeros((H, W), dtype=bool)\n    q = deque()\n    for r in range(H):\n        visited[r, 0] = True\n        q.append((r, 0))\n    while q:\n        r, c = q.popleft()\n        if c == W - 1:\n            return True\n        # Left neighbor via horizontal edge\n        if c > 0 and h_open[r, c - 1] and not visited[r, c - 1]:\n            visited[r, c - 1] = True\n            q.append((r, c - 1))\n        # Right neighbor via horizontal edge\n        if c  W - 1 and h_open[r, c] and not visited[r, c + 1]:\n            visited[r, c + 1] = True\n            q.append((r, c + 1))\n        # Up neighbor via vertical edge\n        if r > 0 and v_open[r - 1, c] and not visited[r - 1, c]:\n            visited[r - 1, c] = True\n            q.append((r - 1, c))\n        # Down neighbor via vertical edge\n        if r  H - 1 and v_open[r, c] and not visited[r + 1, c]:\n            visited[r + 1, c] = True\n            q.append((r + 1, c))\n    return False\n\ndef dual_tb_crossing(H: int, W: int, h_open: np.ndarray, v_open: np.ndarray) -> bool:\n    # Dual graph over faces: (H-1) x (W-1) faces, plus top and bottom boundary nodes\n    F_rows = H - 1\n    F_cols = W - 1\n    num_faces = F_rows * F_cols\n    TOP = num_faces\n    BOTTOM = num_faces + 1\n    dsu = DSU(num_faces + 2)\n\n    def face_id(fr: int, fc: int) -> int:\n        return fr * F_cols + fc\n\n    # Process horizontal primal edges (rows r=0..H-1, cols c=0..W-2)\n    # Closed primal edges become open dual edges\n    for r in range(H):\n        for c in range(W - 1):\n            if not h_open[r, c]:\n                if r == 0:\n                    # Top boundary: connect TOP with face below (0, c)\n                    dsu.union(TOP, face_id(0, c))\n                elif r == H - 1:\n                    # Bottom boundary: connect BOTTOM with face above (H-2, c)\n                    dsu.union(BOTTOM, face_id(H - 2, c))\n                else:\n                    # Interior: connect face above (r-1, c) with face below (r, c)\n                    dsu.union(face_id(r - 1, c), face_id(r, c))\n\n    # Process vertical primal edges (rows r=0..H-2, cols c=0..W-1)\n    # Only interior vertical edges contribute to dual face connectivity between left/right faces\n    for r in range(H - 1):\n        for c in range(1, W - 1):\n            if not v_open[r, c]:\n                dsu.union(face_id(r, c - 1), face_id(r, c))\n\n    # Check if TOP and BOTTOM are connected in the dual\n    return dsu.find(TOP) == dsu.find(BOTTOM)\n\ndef run_trials(H: int, W: int, p: float, trials: int, rng: np.random.Generator):\n    primal_count = 0\n    dual_count = 0\n    violations = 0\n    for _ in range(trials):\n        h_open, v_open = sample_edges(H, W, p, rng)\n        primal_lr = primal_lr_crossing(H, W, h_open, v_open)\n        dual_tb = dual_tb_crossing(H, W, h_open, v_open)\n        if primal_lr:\n            primal_count += 1\n        if dual_tb:\n            dual_count += 1\n        # Exclusivity requires exactly one to be true\n        if primal_lr == dual_tb:\n            violations += 1\n    return primal_count, dual_count, violations\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (H, W, p, trials)\n        (20, 20, 0.5, 500),   # Self-dual square\n        (20, 20, 0.3, 400),   # Subcritical-like\n        (20, 20, 0.7, 400),   # Supercritical-like\n        (10, 30, 0.5, 500),   # Rectangular, self-dual parameter\n        (3, 3, 0.5, 1000),    # Small square self-dual\n    ]\n\n    rng = np.random.default_rng(42)\n    results = []\n    for H, W, p, trials in test_cases:\n        primal_count, dual_count, violations = run_trials(H, W, p, trials, rng)\n        exclusivity_ok = (violations == 0)\n        primal_prob = primal_count / trials\n        results.append(exclusivity_ok)\n        results.append(primal_prob)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了临界点之后，一个自然的问题是：系统在临界状态下的结构是怎样的？在临界点 $p_c$ 处，系统表现出标度不变性，其上形成的“初生无限簇”既不是简单的一维线条，也不是填充空间的二维图形，而是一个分形。本练习将介绍两种测量分形维数的经典方法——盒子计数法和质量标度法，让你通过计算来估算临界簇的分形维数 $d_f$，这是一个描述其复杂几何结构的关键普适指数。",
            "id": "3171745",
            "problem": "你将实现一个计算实验，以估计二维方格晶格上位点逾渗在逾渗阈值 $p_c$ 处的初生无限簇的分形维数 $d_f$。从一个基本前提开始：临界状态下的标度不变性意味着在不同尺度下测量的计数之间存在幂律关系，而分形维数 $d_f$ 量化了具有统计自相似性的簇的质量随空间尺度的标度关系。在具有开放边界的 $L \\times L$ 晶格上使用最近邻连接（冯·诺依曼，$4$-连通）。\n\n定义和约束：\n- 方格晶格上的位点逾渗以概率 $p$ 独立地占据每个位点。二维方格晶格上位点逾渗的逾渗阈值为 $p_c \\approx 0.592746$。\n- 簇是通过最近邻键（上、下、左、右）连接的一组被占据的位点。\n- 如果一个簇同时接触到晶格的顶部和底部边界，或者同时接触到左侧和右侧边界，则称其为跨越簇。\n- 在有限尺寸下，初生无限簇在操作上通过选择跨越簇来近似（如果存在的话）；否则，选择质量（其包含的位点数量）最大的簇。\n- 通过两种源自标度不变性的独立方法来估计 $d_f$：\n  1. 盒子计数法：计算在尺度 $s$ 下，被占据的盒子数量如何随尺度的变化而变化。\n  2. 质量标度法：计算距离参考点的欧几里得半径 $R$ 内的质量如何随 $R$ 的变化而变化。\n\n算法要求：\n1. 生成一个 $L \\times L$ 的布尔晶格，其中每个位点以概率 $p$ 被占据，使用固定的伪随机种子以确保可复现性。使用开放边界。\n2. 使用广度优先搜索 (BFS) 识别连接的簇。记录每个簇的质量、是否接触上、下、左、右边界及其位点坐标。\n3. 如果至少存在一个跨越簇，则选择质量最大的跨越簇作为目标簇；否则，选择质量最大的簇。\n4. 盒子计数法维数估计：\n   - 对于选为晶格尺寸内2的幂次的尺度 $s$（例如，$s \\in \\{2, 4, 8, 16, \\dots\\}$ 且 $s \\le \\lfloor L/2 \\rfloor$），将晶格划分为边长为 $s$ 的不重叠盒子。\n   - 统计包含至少一个选定簇位点的盒子数量。仅使用选定簇的位点进行覆盖计数。\n   - 对标度不变性所蕴含的适当对数变量进行线性回归，使用自然对数，从斜率中获得 $d_f$。\n5. 质量标度法维数估计：\n   - 选择选定簇的几何中心（簇中所有位点行、列索引的算术平均值）作为参考点。\n   - 对于选为晶格尺寸一小部分内2的幂次的半径 $R$（例如，$R \\in \\{2, 4, 8, 16, \\dots\\}$ 且 $R \\le \\lfloor L/4 \\rfloor$），统计与参考点的欧几里得距离小于或等于 $R$ 的簇位点数量。\n   - 对标度不变性所蕴含的适当对数变量进行线性回归，使用自然对数，从斜率中获得 $d_f$。\n6. 如果任一方法可用于回归的尺度数量少于 $2$ 个，则该方法的估计值应返回一个非数值浮点数。\n\n数值选择：\n- 使用自然对数。\n- 使用普通最小二乘法 (OLS) 线性回归来估计每种方法中产生 $d_f$ 的斜率。\n\n测试套件：\n在以下测试用例上运行你的程序，每个用例指定为 $(L, p, \\text{seed}, \\text{method})$，其中 $\\text{method} \\in \\{\\text{\"box\"}, \\text{\"mass\"}\\}$：\n- 用例 $1$：$(64, 0.592746, 1234, \\text{\"box\"})$。\n- 用例 $2$：$(64, 0.592746, 1234, \\text{\"mass\"})$。\n- 用例 $3$：$(128, 0.592746, 42, \\text{\"box\"})$。\n- 用例 $4$：$(128, 0.592746, 42, \\text{\"mass\"})$。\n- 用例 $5$：$(32, 0.592746, 7, \\text{\"box\"})$。\n- 用例 $6$：$(32, 0.58, 7, \\text{\"mass\"})$。\n\n答案规范：\n- 对于每个用例，输出一个浮点数，等于所选方法估计的 $d_f$ 值，四舍五入到 $3$ 位小数。\n- 最终输出格式：你的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来（例如，$[$d_1,d_2,d_3,d_4,d_5,d_6$]$），其中每个 $d_i$ 是用例 $i$ 的浮点数结果。",
            "solution": "该问题要求估计二维位点逾渗中初生无限簇的分形维数 $d_f$。这是计算统计物理学中的一个经典问题。解决方案涉及生成一个逾渗系统，识别临界簇，然后应用两种源自临界点标度不变性原理的不同方法：盒子计数法和质量标度法。\n\n基本原理是，在逾渗阈值 $p=p_c$ 处，系统具有统计自相似性。这意味着其几何性质与观察它们的长度尺度无关。这种自相似性或标度不变性是分形的特征。分形维数 $d_f$ 是一个指数，它量化了物体的“质量”或“内容”如何随其线性尺寸变化。对于一个 $d$ 维欧几里得物体，其质量随半径 $R$ 的标度关系为 $M \\propto R^d$。对于一个分形物体，这个关系被推广为 $M(R) \\propto R^{d_f}$，其中 $d_f$ 通常为非整数。对于二维逾渗中的初生无限簇，理论预测 $d_f = 91/48 \\approx 1.8958$。\n\n总体的计算流程如下：\n1. 生成一个随机的 $L \\times L$ 晶格，其中每个位点以概率 $p$ 被占据。\n2. 使用图遍历算法，即广度优先搜索 (BFS)，识别所有由被占据位点组成的连通簇。\n3. 选择一个单一的“目标簇”，作为初生无限簇的有限尺寸近似。如果存在跨越簇，则选择质量最大的那个；否则，选择质量最大的簇。\n4. 应用两种不同的方法来估计该目标簇的 $d_f$。\n\n**方法1：质量标度法维数**\n\n此方法直接使用质量分形的定义关系。包含在距离中心点欧几里得半径 $R$ 内的簇的质量 $M(R)$ 预计遵循幂律标度关系：\n$M(R) \\propto R^{d_f}$\n为了提取指数 $d_f$，我们可以通过对两边取自然对数来线性化这个关系：\n$\\ln(M(R)) = d_f \\ln(R) + C$\n其中 $C$ 是一个常数。这个方程具有直线 $y = mx + c$ 的形式，其中因变量是 $y = \\ln(M(R))$，自变量是 $x = \\ln(R)$，斜率是 $m = d_f$。\n\n因此，算法如下：\n1. 通过计算目标簇所有位点坐标的算术平均值，来确定其几何中心。\n2. 对于一系列递增的半径 $R$（选择为2的幂，最大到 $L/4$），计算位于距中心欧几里得距离为 $R$ 内的簇位点数量 $M(R)$。\n3. 对点集 $(\\ln(R), \\ln(M(R)))$ 进行普通最小二乘法 (OLS) 线性回归。\n4. 所得回归线的斜率即为分形维数 $d_f$ 的估计值。\n\n**方法2：盒子计数法维数**\n\n盒子计数法提供了另一种测量分形维数的方法。它量化了覆盖物体所需给定尺寸 $s$ 的“盒子”数量如何随 $s$ 变化。对于一个分形物体，这个数量 $N(s)$ 遵循幂律标度关系：\n$N(s) \\propto \\left(\\frac{1}{s}\\right)^{d_f} = s^{-d_f}$\n随着 $s$ 减小，覆盖物体所需的盒子数量增加。同样，我们通过取自然对数来线性化它：\n$\\ln(N(s)) = -d_f \\ln(s) + C'$\n这也是一个线性方程 $y = mx + c$，其中 $y = \\ln(N(s))$，$x = \\ln(s)$，斜率是 $m = -d_f$。因此，分形维数可以估计为 $d_f = -m$。\n\n算法如下：\n1. 对于一系列盒子尺寸 $s$（选择为2的幂，最大到 $L/2$），将 $L \\times L$ 晶格划分为一个不重叠的 $s \\times s$ 盒子网格。\n2. 统计包含至少一个属于目标簇位点的盒子数量 $N(s)$。\n3. 对点集 $(\\ln(s), \\ln(N(s)))$ 进行 OLS 线性回归。\n4. 分形维数的估计值是回归线斜率的负值，即 $d_f = -m$。\n\n**实现细节**\n\n晶格是使用 `numpy.random.default_rng` 和指定的种子生成的，以保证可复现性。簇的识别是通过遍历晶格的所有位点来完成的。如果一个被占据的位点尚未被访问，则从该位点启动广度优先搜索 (BFS) 来寻找属于该簇的所有连通位点，并将它们标记为已访问。在 BFS 过程中，收集簇的属性（质量、位点坐标以及是否接触四个边界）。找到所有簇后，根据指定规则选择目标簇。线性回归使用 `scipy.stats.linregress` 函数执行，该函数提供了 OLS 的稳健实现。如果某种方法产生的回归数据点少于两个，则按规定返回一个非数值 (`nan`)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\nfrom collections import deque\n\ndef _bfs_cluster_find(grid, start_node, visited):\n    \"\"\"\n    Performs a Breadth-First Search to find a single cluster.\n    \"\"\"\n    L = grid.shape[0]\n    q = deque([start_node])\n    visited[start_node] = True\n    \n    cluster_sites = []\n    mass = 0\n    touches_top = False\n    touches_bottom = False\n    touches_left = False\n    touches_right = False\n    \n    while q:\n        r, c = q.popleft()\n        \n        cluster_sites.append((r, c))\n        mass += 1\n        \n        if r == 0: touches_top = True\n        if r == L - 1: touches_bottom = True\n        if c == 0: touches_left = True\n        if c == L - 1: touches_right = True\n        \n        # Von Neumann neighbors\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 = nr  L and 0 = nc  L and grid[nr, nc] and not visited[nr, nc]:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n                \n    return {\n        \"mass\": mass,\n        \"sites\": cluster_sites,\n        \"touches_top\": touches_top,\n        \"touches_bottom\": touches_bottom,\n        \"touches_left\": touches_left,\n        \"touches_right\": touches_right,\n    }\n\ndef find_clusters(grid):\n    \"\"\"\n    Identifies all connected clusters in the grid using BFS.\n    \"\"\"\n    L = grid.shape[0]\n    visited = np.zeros_like(grid, dtype=bool)\n    clusters = []\n    \n    for r in range(L):\n        for c in range(L):\n            if grid[r, c] and not visited[r, c]:\n                cluster = _bfs_cluster_find(grid, (r, c), visited)\n                clusters.append(cluster)\n    return clusters\n\ndef select_target_cluster(clusters, L):\n    \"\"\"\n    Selects the target cluster based on spanning/mass criteria.\n    \"\"\"\n    if not clusters:\n        return None\n        \n    spanning_clusters = []\n    for c in clusters:\n        is_spanning_v = c['touches_top'] and c['touches_bottom']\n        is_spanning_h = c['touches_left'] and c['touches_right']\n        if is_spanning_v or is_spanning_h:\n            spanning_clusters.append(c)\n            \n    if spanning_clusters:\n        return max(spanning_clusters, key=lambda c: c['mass'])\n    else:\n        return max(clusters, key=lambda c: c['mass'])\n\ndef estimate_df_box(cluster, L):\n    \"\"\"\n    Estimates fractal dimension using the box counting method.\n    \"\"\"\n    sites = cluster['sites']\n    \n    log_s_vals = []\n    log_N_vals = []\n    \n    s = 2\n    while s = L // 2:\n        if s > 0:\n            occupied_boxes = set()\n            for r, c in sites:\n                occupied_boxes.add((r // s, c // s))\n            \n            N_s = len(occupied_boxes)\n            if N_s > 0:\n                log_s_vals.append(np.log(s))\n                log_N_vals.append(np.log(N_s))\n        s *= 2\n        \n    if len(log_s_vals)  2:\n        return np.nan\n        \n    slope, _, _, _, _ = stats.linregress(log_s_vals, log_N_vals)\n    return -slope\n\ndef estimate_df_mass(cluster, L):\n    \"\"\"\n    Estimates fractal dimension using the mass scaling method.\n    \"\"\"\n    sites_arr = np.array(cluster['sites'])\n    if sites_arr.shape[0] == 0:\n        return np.nan\n        \n    center = np.mean(sites_arr, axis=0)\n    distances = np.sqrt(np.sum((sites_arr - center)**2, axis=1))\n    \n    log_R_vals = []\n    log_M_vals = []\n    \n    R = 2\n    while R = L // 4:\n        if R > 0:\n            mass_in_radius = np.sum(distances = R)\n            if mass_in_radius > 0:\n                log_R_vals.append(np.log(R))\n                log_M_vals.append(np.log(mass_in_radius))\n        R *= 2\n        \n    if len(log_R_vals)  2:\n        return np.nan\n\n    slope, _, _, _, _ = stats.linregress(log_R_vals, log_M_vals)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute fractal dimensions.\n    \"\"\"\n    test_cases = [\n        (64, 0.592746, 1234, \"box\"),\n        (64, 0.592746, 1234, \"mass\"),\n        (128, 0.592746, 42, \"box\"),\n        (128, 0.592746, 42, \"mass\"),\n        (32, 0.592746, 7, \"box\"),\n        (32, 0.58, 7, \"mass\"),\n    ]\n\n    results = []\n    lattice_cache = {}\n\n    for L, p, seed, method in test_cases:\n        cache_key = (L, p, seed)\n        \n        if cache_key in lattice_cache:\n            target_cluster = lattice_cache[cache_key]\n        else:\n            # 1. Generate grid\n            rng = np.random.default_rng(seed)\n            grid = rng.random((L, L))  p\n            \n            # 2. Find clusters\n            clusters = find_clusters(grid)\n            \n            # 3. Select target cluster\n            target_cluster = select_target_cluster(clusters, L)\n            lattice_cache[cache_key] = target_cluster\n        \n        df_estimate = np.nan\n        if target_cluster is not None:\n            if method == \"box\":\n                df_estimate = estimate_df_box(target_cluster, L)\n            elif method == \"mass\":\n                df_estimate = estimate_df_mass(target_cluster, L)\n        \n        results.append(df_estimate)\n\n    formatted_results = []\n    for r in results:\n        if np.isnan(r):\n            formatted_results.append(\"nan\")\n        else:\n            formatted_results.append(f\"{r:.3f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "临界点处复杂的分形几何结构对材料的宏观物理性质有着决定性的影响。通过将渗流系统映射为一个随机电阻网络，我们可以研究其电导特性。当占据概率 $p  p_c$ 时，材料是绝缘体；而当 $p$ 刚刚超过 $p_c$ 时，电导率如何从零开始增长？本练习将引导你探索这个过程，它由另一个普适的临界指数 $t$ 所描述，从而将抽象的几何相变与可测量的物理输运现象联系起来。",
            "id": "3171738",
            "problem": "您将编写一个完整、可运行的程序，通过将逾渗映射到一个随机电阻网络来估计二维键逾渗的电导率临界指数 $t$。在该网络中，每个被占据的键的电导为 $g=1$，而每个未被占据的键则不存在。该估计必须通过计算方形晶格在逾渗阈值 $p_c$ 附近两个相对侧之间的有效体电导率 $\\sigma(p)$，然后对 $p>p_c$ 的情况拟合标度关系 $\\sigma(p) \\propto (p-p_c)^t$ 来完成。\n\n基本原理和假设。使用以下经过充分检验的基本原理：\n- 欧姆定律描述了通过一个电导为 $g$ 的电阻器的电流 $I$ 和电压差 $\\Delta V$ 之间的关系：$I=g\\,\\Delta V$。\n- 基尔霍夫电流定律指出，对于电阻网络的任何内部节点，当系统处于稳态时，离开该节点的电流的代数和为 $0$。\n- 在固定边界电压下，网络解可通过求解由基尔霍夫电流定律和欧姆定律导出的离散泊松方程（带有狄利克雷边界条件的图拉普拉斯算子）获得。\n- 对于无限方形晶格上的键逾渗，其键逾渗阈值为 $p_c=\\tfrac{1}{2}$（这是一个精确已知且被广泛接受的事实）。\n\n定义和数值设置。考虑一个 $L \\times L$ 的方形节点晶格，其中键仅存在于最近邻（水平和垂直）之间。每个可能的键都以概率 $p \\in (0,1)$ 独立地被占据，每个被占据的键被赋予电导 $g=1$，而未被占据的键则不存在。在左边界（列索引 $x=0$）的所有节点上施加狄利克雷边界条件 $V=1$，在右边界（列索引 $x=L-1$）的所有节点上施加 $V=0$。顶部和底部边界（行索引 $y=0$ 和 $y=L-1$）是电学自由的（无固定电势）。对于任何一次实现，有效电导率 $\\sigma(p)$ 定义为在施加的单位电压降 $\\Delta V=1$ 下，从左边界注入的总净电流，这等于以任意单位表示的左右边界之间的有效两端电导。\n\n为确保数值可解性，任何未连接到左边界或右边界的内部节点连通分量都应从线性系统中排除，因为在狄利克雷边界条件下，其电势是未定的。实际上，您必须将求解限制在通过被占据的键连接到两个狄利克雷边界中至少一个的内部节点集合上。\n\n指数 $t$ 的估计器。对于每个测试用例，您将：\n- 对于一组给定的高于 $p_c$ 的 $p$ 值中的每一个，生成多个独立的网络实现，并为每一个计算有效电导率 $\\sigma(p)$，然后取样本均值 $\\overline{\\sigma}(p)$。\n- 仅使用那些 $\\overline{\\sigma}(p)>0$ 的 $p$ 值，通过普通最小二乘法（未加权）将 $\\log \\overline{\\sigma}(p)$ 作为 $\\log(p-p_c)$ 的函数来拟合线性关系 $\\log \\overline{\\sigma}(p) = t\\log(p-p_c)+C$，以估计 $t$。对数可以取任意底；为明确起见，请使用自然对数。\n- 如果 $\\overline{\\sigma}(p)>0$ 的不同 $p$ 值少于 2 个，则该测试用例返回哨兵值 $-1.0$。\n\n程序必须遵循的实现细节：\n- 在连接到至少一个狄利克雷边界的内部节点集合上构建图拉普拉斯算子。对于一个内部节点 $i$，对角线元素等于其到所有被占据邻居的电导之和，而非对角线元素对于连接到其他内部节点的被占据的键等于 $-g$。对右手边 $\\mathbf{b}$ 的贡献来自于连接到具有固定电压的边界节点的被占据的键（$+gV_{\\text{boundary}}$）。\n- 求解稀疏线性系统 $A\\mathbf{v}=\\mathbf{b}$ 以获得内部节点电压 $\\mathbf{v}$；然后计算从左边界注入的净电流，其值为所有连接左边界节点与其最近邻内部节点的被占据的键上 $g(1-V_{\\text{neighbor}})$ 的总和。\n- 对每个被占据的键使用 $g=1$，对未被占据的键使用 $g=0$。\n- 使用逾渗阈值 $p_c=\\tfrac{1}{2}$。\n- 使用带有受控种子的伪随机数生成器以确保可复现性。对于测试用例索引 $k\\in\\{0,1,2\\}$ 和样本索引 $s\\in\\{0,1,\\dots,S-1\\}$，将种子设置为 $12345+1000k+s$。\n\n测试套件。您的程序必须为以下三个测试用例估计 $t$，其中每个用例都使用指定的晶格尺寸 $L$、占据概率 $p$ 的集合（每个都严格大于 $p_c$），以及每个 $p$ 对应的独立样本数 $S$：\n- 用例 0：$L=24$，$p\\in\\{0.55, 0.60, 0.65, 0.70\\}$，$S=12$。\n- 用例 1：$L=16$，$p\\in\\{0.52, 0.56, 0.60, 0.64\\}$，$S=12$。\n- 用例 2：$L=12$，$p\\in\\{0.505, 0.530, 0.560, 0.620\\}$，$S=20$。\n\n可量化输出。对于每个用例，输出是一个实数：通过上述线性拟合得到的估计指数 $t$，使用自然对数计算。如果在通过 $\\overline{\\sigma}(p)>0$ 进行筛选后，可用的 $p$ 值少于 2 个，则该用例输出哨兵值 $-1.0$。最终的数值输出没有物理单位，并且必须打印并四舍五入到三位小数。\n\n最终输出格式。您的程序应生成单行输出，其中按用例顺序列出三个结果，格式为用方括号括起来的逗号分隔列表，例如：$[1.234,1.289,1.301]$。不应打印任何其他文本。",
            "solution": "我们概述一种基于基本电网络理论和逾渗定义的、有原理的计算方法来估计电导率指数 $t$。\n\n目标标度关系是，对于二维方形晶格上接近其逾渗阈值 $p_c$ 的键逾渗，当 $p$ 从上方趋近于 $p_c$ 时，有效体电导率的行为符合 $\\sigma(p) \\propto (p-p_c)^t$。取对数可得 $\\log \\sigma(p) = t \\log(p-p_c) + C$，这启发我们将 $t$ 估计为 $p>p_c$ 时 $\\log \\sigma(p)$ 相对于 $\\log(p-p_c)$ 的斜率。\n\n我们完全基于欧姆定律和基尔霍夫电流定律，通过逾渗获得的随机电阻网络来构造 $\\sigma(p)$，具体如下。考虑一个 $L \\times L$ 的方形节点网格，其中键存在于水平和垂直方向的最近邻之间。每个可能的键都以概率 $p$ 独立地被占据。每个被占据的键被赋予电导 $g=1$（任意单位），而未被占据的键则不存在（$g=0$）。通过将左边界所有节点的电势设置为 $V=1$、右边界所有节点的电势设置为 $V=0$ 来施加狄利克雷边界条件。顶部和底部边界是电学自由的（无固定电势）。对于给定的网络实现，内部节点电压由每个内部节点 $i$ 处的基尔霍夫电流定律确定：\n$$\n\\sum_{j\\in \\mathcal{N}(i)} g_{ij}\\,(V_i - V_j) = 0,\n$$\n其中 $\\mathcal{N}(i)$ 表示节点 $i$ 的邻居集合，$g_{ij}\\in\\{0,1\\}$ 是 $i$ 和 $j$ 之间键的电导。这就产生了一个关于内部节点电压 $\\mathbf{v}$ 的线性系统 $A\\mathbf{v}=\\mathbf{b}$，其中 $A$ 是限制在内部节点上的图拉普拉斯算子，$\\mathbf{b}$ 收集了从被占据的键到狄利克雷边界节点的贡献。具体来说，对于一个内部节点 $i$，$A$ 的对角线元素是 $i$ 到其所有被占据邻居的电导之和，每个非对角线元素 $A_{ij}$ 对于内部节点 $i$ 和 $j$ 之间的被占据的键为 $-g_{ij}$。右手边项 $b_i$ 是 $\\sum_{j\\in \\partial \\Omega} g_{ij}\\,V_j$，即对从 $i$ 到具有固定电势 $V_j$ 的边界节点 $j$ 的所有被占据的键进行求和。\n\n如果一个内部连通分量没有连接到任何狄利克雷边界，就会出现一个微妙的问题：该分量内的电势在相差一个加性常数的情况下是未定的，且该分量对应的子矩阵是奇异的。为避免此问题，我们将线性系统的域限制在通过被占据的键连接到至少一个狄利克雷边界（左或右）的内部节点集合上。这通过图遍历（例如广度优先搜索）实现，从左边界和右边界出发，跨越被占据的键进行搜索，并保留从任一侧可达的内部节点的并集。未连接到任一边界的节点被从 $A$ 和 $\\mathbf{b}$ 中排除，因为它们不影响边界之间的电流。\n\n在求解 $A\\mathbf{v}=\\mathbf{b}$ 后，我们使用欧姆定律计算从左边界注入的总电流，该电流流过连接左边界节点（固定在 $V=1$）与其直接内部邻居的被占据的键。如果一个被占据的键连接了一个左边界节点和一个电势为 $V_{\\text{n}}$ 的内部节点，则通过该键从左到内的电流为 $g(1 - V_{\\text{n}})$。对所有此类键求和得到净注入电流 $I_{\\text{L}}$。由于右边界固定在 $V=0$，边界间的总电压降为 $\\Delta V=1$，因此有效电导（在这些任意单位下的体电导率）等于 $\\sigma = I_{\\text{L}}$。\n\n为了估计 $t$，我们对每个测试用例按以下步骤进行：\n- 对于一组给定的占据概率 $p>p_c$ 和独立样本数 $S$，我们使用伪随机数生成器生成 $S$ 个独立的键构型，其种子确定性地设置为 $12345+1000k+s$，其中 $k$ 是测试用例索引，$s\\in\\{0,1,\\dots,S-1\\}$ 是样本索引。对于每个构型，我们如上所述计算 $\\sigma(p)$。然后我们计算 $S$ 个样本的样本均值 $\\overline{\\sigma}(p)$。\n- 我们舍弃任何 $\\overline{\\sigma}(p)\\le 0$ 的 $p$ 值（这可能是由于有限尺寸效应或在 $p_c$ 附近采样不足造成的）。如果至少还剩下 2 个 $p$ 值，我们使用自然对数通过普通最小二乘回归拟合线性模型 $\\log \\overline{\\sigma}(p) = t \\log(p - p_c) + C$。拟合的斜率就是我们对 $t$ 的估计。如果可用的点少于 2 个，我们输出哨兵值 $-1.0$。\n\n方形晶格上键逾渗的逾渗阈值为 $p_c=\\tfrac{1}{2}$，我们对所有测试用例都使用这个值。测试套件包括三个用例：\n- 用例 0：$L=24$，$p\\in\\{0.55, 0.60, 0.65, 0.70\\}$，$S=12$。\n- 用例 1：$L=16$，$p\\in\\{0.52, 0.56, 0.60, 0.64\\}$，$S=12$。\n- 用例 2：$L=12$，$p\\in\\{0.505, 0.530, 0.560, 0.620\\}$，$S=20$。\n\n这些用例分别探究：一个中等规模的系统，其多个 $p$ 值均安全地高于 $p_c$；一个较小的系统，包含更接近 $p_c$ 的 $p$ 值，以测试灵敏度和潜在的有限尺寸效应；以及一个小型系统，通过增加采样来减轻 $p_c$ 附近的噪声。最终程序将以精确格式 $[t_0, t_1, t_2]$ (例如 $[1.234, 1.289, 1.301]$) 打印一行包含三个估计斜率（四舍五入到三位小数）的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom collections import deque\n\ndef generate_bonds(L, p, rng):\n    \"\"\"\n    Generate occupied bond arrays for an LxL lattice.\n    Horizontal bonds H[y, x] connect (x,y) - (x+1,y) for x in [0..L-2], y in [0..L-1].\n    Vertical bonds V[y, x] connect (x,y) - (x,y+1) for y in [0..L-2], x in [0..L-1].\n    Returns boolean arrays H (shape L x (L-1)) and V ((L-1) x L).\n    \"\"\"\n    H = rng.random((L, L - 1))  p\n    V = rng.random((L - 1, L))  p\n    return H, V\n\ndef bfs_reachable(L, H, V, from_left=True):\n    \"\"\"\n    BFS to find nodes reachable from the left (x=0) or right (x=L-1) boundary via occupied bonds.\n    Returns a boolean array reach[y, x] of shape (L, L).\n    \"\"\"\n    reach = np.zeros((L, L), dtype=bool)\n    q = deque()\n    if from_left:\n        x0 = 0\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n    else:\n        x0 = L - 1\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n\n    while q:\n        x, y = q.popleft()\n        # Left neighbor\n        if x  0 and H[y, x - 1]:\n            nx, ny = x - 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Right neighbor\n        if x  L - 1 and H[y, x]:\n            nx, ny = x + 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Up neighbor\n        if y  0 and V[y - 1, x]:\n            nx, ny = x, y - 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Down neighbor\n        if y  L - 1 and V[y, x]:\n            nx, ny = x, y + 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n\n    return reach\n\ndef build_system(L, H, V, reach_union):\n    \"\"\"\n    Build the sparse linear system A v = b for interior nodes that are reachable from either boundary.\n    Interior nodes are those with x in [1..L-2]. Boundary nodes at x=0 (V=1) and x=L-1 (V=0) are Dirichlet.\n    reach_union is boolean mask of nodes reachable from left or right boundaries.\n    Returns (A_csr, b, node_index, index_to_node).\n    node_index maps (x,y) - idx in [0..n-1] for interior reachable nodes.\n    index_to_node is list mapping idx - (x,y).\n    \"\"\"\n    # Map interior reachable nodes to indices\n    node_index = {}\n    index_to_node = []\n    for y in range(L):\n        for x in range(1, L - 1):\n            if reach_union[y, x]:\n                node_index[(x, y)] = len(index_to_node)\n                index_to_node.append((x, y))\n\n    n = len(index_to_node)\n    if n == 0:\n        # Empty system\n        A = coo_matrix((0, 0), dtype=float).tocsr()\n        b = np.zeros((0,), dtype=float)\n        return A, b, node_index, index_to_node\n\n    rows = []\n    cols = []\n    data = []\n    b = np.zeros(n, dtype=float)\n\n    def add_entry(i, j, val):\n        rows.append(i)\n        cols.append(j)\n        data.append(val)\n\n    for idx, (x, y) in enumerate(index_to_node):\n        diag = 0.0\n\n        # Neighbor to the left: (x-1, y) via H[y, x-1]\n        if x - 1 = 0 and H[y, x - 1]:\n            diag += 1.0\n            if x - 1 == 0:\n                # Left boundary at V=1\n                b[idx] += 1.0 * 1.0\n            else:\n                # Interior node at (x-1, y)\n                if reach_union[y, x - 1]:\n                    jdx = node_index[(x - 1, y)]\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Not in system (should not happen for an occupied bond unless excluded)\n                    pass\n\n        # Neighbor to the right: (x+1, y) via H[y, x]\n        if x  L - 1 and H[y, x]:\n            diag += 1.0\n            if x + 1 == L - 1:\n                # Right boundary at V=0 = no contribution to b\n                pass\n            else:\n                if reach_union[y, x + 1]:\n                    jdx = node_index[(x + 1, y)]\n                    add_entry(idx, jdx, -1.0)\n\n        # Neighbor above: (x, y-1) via V[y-1, x]\n        if y - 1 = 0 and V[y - 1, x]:\n            diag += 1.0\n            if reach_union[y - 1, x]:\n                jdx = node_index.get((x, y - 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Could be boundary column (but y-1 same column), handled by reach mask\n                    pass\n\n        # Neighbor below: (x, y+1) via V[y, x]\n        if y  L - 1 and V[y, x]:\n            diag += 1.0\n            if reach_union[y + 1, x]:\n                jdx = node_index.get((x, y + 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n\n        # Diagonal entry\n        add_entry(idx, idx, diag)\n\n    A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float).tocsr()\n    return A, b, node_index, index_to_node\n\ndef compute_sigma(L, p, seed):\n    \"\"\"\n    Compute effective conductance sigma for one random instance at given L, p, with RNG seed.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    H, V = generate_bonds(L, p, rng)\n\n    # Reachable from left and right boundaries\n    reach_left = bfs_reachable(L, H, V, from_left=True)\n    reach_right = bfs_reachable(L, H, V, from_left=False)\n    reach_union = np.logical_or(reach_left, reach_right)\n\n    # Build and solve system\n    A, b, node_index, index_to_node = build_system(L, H, V, reach_union)\n\n    if A.shape[0] == 0:\n        # No interior reachable nodes = no conduction\n        return 0.0\n\n    try:\n        v = spsolve(A, b)\n    except Exception:\n        # Numerical fallback: treat as zero conductance if solve fails\n        return 0.0\n\n    # Map voltages back for easy lookup\n    volt = {}\n    for idx, (x, y) in enumerate(index_to_node):\n        volt[(x, y)] = v[idx]\n\n    # Net current injected at left boundary across occupied bonds to column x=1\n    total_current = 0.0\n    x_left_neighbor = 1\n    for y in range(L):\n        if H[y, 0]:  # Bond between (0,y) and (1,y)\n            vn = volt.get((x_left_neighbor, y))\n            if vn is not None:\n                total_current += (1.0 - vn)  # g=1\n\n    # sigma equals total current for unit voltage drop\n    return float(total_current)\n\ndef mean_sigma_over_samples(L, p, case_index, S):\n    \"\"\"\n    Compute mean sigma over S samples for given L and p with deterministic seeding.\n    \"\"\"\n    sigmas = []\n    for s in range(S):\n        seed = 12345 + 1000 * case_index + s\n        sigmas.append(compute_sigma(L, p, seed))\n    return float(np.mean(sigmas))\n\ndef estimate_t(p_values, sigma_means, pc=0.5):\n    \"\"\"\n    Estimate exponent t by linear regression of log(sigma) vs log(p - pc).\n    Returns -1.0 if fewer than two usable points.\n    \"\"\"\n    x = []\n    y = []\n    for p, sm in zip(p_values, sigma_means):\n        if sm  0.0 and p  pc:\n            x.append(np.log(p - pc))\n            y.append(np.log(sm))\n    if len(x)  2:\n        return -1.0\n    x = np.array(x)\n    y = np.array(y)\n    # Ordinary least squares fit: y = t * x + c\n    t, c = np.polyfit(x, y, 1)\n    return float(t)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (case_index, L, p_list, samples S)\n        (0, 24, [0.55, 0.60, 0.65, 0.70], 12),\n        (1, 16, [0.52, 0.56, 0.60, 0.64], 12),\n        (2, 12, [0.505, 0.530, 0.560, 0.620], 20),\n    ]\n\n    pc = 0.5\n    results = []\n    for case_index, L, p_list, S in test_cases:\n        sigma_means = []\n        for p in p_list:\n            m = mean_sigma_over_samples(L, p, case_index, S)\n            sigma_means.append(m)\n        t_est = estimate_t(p_list, sigma_means, pc=pc)\n        # Round to three decimals for output\n        if np.isnan(t_est) or np.isinf(t_est):\n            t_est = -1.0\n        t_est_rounded = f\"{t_est:.3f}\"\n        results.append(t_est_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}