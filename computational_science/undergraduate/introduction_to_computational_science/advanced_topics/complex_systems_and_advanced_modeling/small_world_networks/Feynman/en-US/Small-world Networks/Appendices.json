{
    "hands_on_practices": [
        {
            "introduction": "One of the defining features of small-world networks is high local clustering, meaning your friends are likely to be friends with each other. We quantify this 'cliquishness' using the local clustering coefficient, $C_i$. This first practice guides you through the fundamental calculation of $C_i$ on a simple, regular graph, and then explores how rewiring a single edge affects this local structure, providing a foundational skill for analyzing network topology. ",
            "id": "1707846",
            "problem": "The local clustering coefficient of a node $i$ in a network is a measure of how tightly knit the neighbors of that node are. It is defined by the formula:\n$$C_i = \\frac{2 E_i}{k_i(k_i - 1)}$$\nwhere $k_i$ is the number of neighbors (the degree) of node $i$, and $E_i$ is the number of edges that exist between the neighbors of node $i$.\n\nConsider an undirected network consisting of 8 nodes, labeled $v_0, v_1, \\dots, v_7$. Initially, the network is a regular graph where each node $v_i$ is connected to four other nodes: $v_{(i-2) \\pmod 8}$, $v_{(i-1) \\pmod 8}$, $v_{(i+1) \\pmod 8}$, and $v_{(i+2) \\pmod 8}$.\n\nFirst, calculate the local clustering coefficient for node $v_0$ in this initial network configuration.\n\nNext, the network structure is modified. The single edge connecting node $v_0$ to node $v_2$ is removed. A new edge is then created, connecting node $v_0$ to node $v_5$. All other edges in the network remain unchanged.\n\nCalculate the new local clustering coefficient for node $v_0$ in this modified network.\n\nProvide the initial and the rewired clustering coefficients for node $v_0$. Your answer should consist of two exact fractions.",
            "solution": "The problem asks for two values: the local clustering coefficient of node $v_0$ before and after a specified edge rewiring. The formula for the local clustering coefficient of a node $i$ is given as $C_i = \\frac{2 E_i}{k_i(k_i - 1)}$.\n\n**Part 1: Initial Clustering Coefficient Calculation**\n\nFirst, we analyze the initial network to find the clustering coefficient for node $v_0$, which we'll call $C_0^{\\text{initial}}$.\n\n1.  **Identify the neighbors of $v_0$**: According to the rule, node $v_i$ is connected to $v_{(i \\pm 1) \\pmod 8}$ and $v_{(i \\pm 2) \\pmod 8}$. For $i=0$, the neighbors are:\n    *   $v_{(0-1) \\pmod 8} = v_7$\n    *   $v_{(0+1) \\pmod 8} = v_1$\n    *   $v_{(0-2) \\pmod 8} = v_6$\n    *   $v_{(0+2) \\pmod 8} = v_2$\n    The set of neighbors of $v_0$ is $N_0 = \\{v_1, v_2, v_6, v_7\\}$.\n\n2.  **Determine the degree of $v_0$**: The number of neighbors is $k_0 = |N_0| = 4$.\n\n3.  **Calculate the denominator**: The maximum possible number of edges between the neighbors is $\\frac{k_0(k_0-1)}{2} = \\frac{4(3)}{2} = 6$. The denominator of the formula is $k_0(k_0 - 1) = 4 \\times 3 = 12$.\n\n4.  **Count the existing edges between neighbors ($E_0$)**: We need to check which pairs of nodes in $N_0 = \\{v_1, v_2, v_6, v_7\\}$ are connected in the original network.\n    *   **Edge $(v_1, v_2)$**: Node $v_1$ is connected to $v_{(1\\pm1)\\pmod 8} = \\{v_0, v_2\\}$. So, yes, there is an edge between $v_1$ and $v_2$.\n    *   **Edge $(v_1, v_6)$**: The neighbors of $v_1$ are $v_0, v_2, v_3, v_7$. Node $v_6$ is not in this set. No edge.\n    *   **Edge $(v_1, v_7)$**: The neighbors of $v_1$ are $v_0, v_2, v_3, v_7$. Node $v_7$ is in this set. Yes, there is an edge.\n    *   **Edge $(v_2, v_6)$**: The neighbors of $v_2$ are $v_0, v_1, v_3, v_4$. Node $v_6$ is not in this set. No edge.\n    *   **Edge $(v_2, v_7)$**: The neighbors of $v_2$ are $v_0, v_1, v_3, v_4$. Node $v_7$ is not in this set. No edge.\n    *   **Edge $(v_6, v_7)$**: Node $v_6$ is connected to $v_{(6\\pm1)\\pmod 8} = \\{v_5, v_7\\}$. So, yes, there is an edge between $v_6$ and $v_7$.\n    The existing edges between the neighbors of $v_0$ are $(v_1, v_2)$, $(v_1, v_7)$, and $(v_6, v_7)$. Thus, the number of such edges is $E_0 = 3$.\n\n5.  **Calculate $C_0^{\\text{initial}}$**:\n    $C_0^{\\text{initial}} = \\frac{2 E_0}{k_0(k_0 - 1)} = \\frac{2 \\times 3}{12} = \\frac{6}{12} = \\frac{1}{2}$.\n\n**Part 2: Rewired Clustering Coefficient Calculation**\n\nNow, we analyze the modified network to find the new clustering coefficient for node $v_0$, which we'll call $C_0^{\\text{rewired}}$. The edge $(v_0, v_2)$ is removed and the edge $(v_0, v_5)$ is added.\n\n1.  **Identify the new neighbors of $v_0$**: The old neighbor set was $\\{v_1, v_2, v_6, v_7\\}$. Node $v_2$ is removed and $v_5$ is added. The new set of neighbors is $N'_0 = \\{v_1, v_5, v_6, v_7\\}$.\n\n2.  **Determine the new degree of $v_0$**: The number of neighbors is unchanged, so $k'_0 = |N'_0| = 4$.\n\n3.  **Calculate the denominator**: The denominator is also unchanged: $k'_0(k'_0 - 1) = 4 \\times 3 = 12$.\n\n4.  **Count the existing edges between new neighbors ($E'_0$)**: We check for edges between pairs in $N'_0 = \\{v_1, v_5, v_6, v_7\\}$. Note that the connections between nodes other than $v_0$ are based on the original network's rules.\n    *   **Edge $(v_1, v_5)$**: The neighbors of $v_1$ are $v_0, v_2, v_3, v_7$. Node $v_5$ is not in this set. No edge.\n    *   **Edge $(v_1, v_6)$**: The neighbors of $v_1$ are $v_0, v_2, v_3, v_7$. Node $v_6$ is not in this set. No edge.\n    *   **Edge $(v_1, v_7)$**: The neighbors of $v_1$ include $v_7$. Yes, this edge exists.\n    *   **Edge $(v_5, v_6)$**: The neighbors of $v_5$ are $v_{(5\\pm1)\\pmod 8}=\\{v_4, v_6\\}$ and $v_{(5\\pm2)\\pmod 8}=\\{v_3, v_7\\}$. The set is $\\{v_3, v_4, v_6, v_7\\}$. Node $v_6$ is in this set. Yes, this edge exists.\n    *   **Edge $(v_5, v_7)$**: The neighbors of $v_5$ include $v_7$. Yes, this edge exists.\n    *   **Edge $(v_6, v_7)$**: The neighbors of $v_6$ include $v_7$. Yes, this edge exists.\n    The existing edges are $(v_1, v_7)$, $(v_5, v_6)$, $(v_5, v_7)$, and $(v_6, v_7)$. Thus, the number of edges is $E'_0 = 4$.\n\n5.  **Calculate $C_0^{\\text{rewired}}$**:\n    $C_0^{\\text{rewired}} = \\frac{2 E'_0}{k'_0(k'_0 - 1)} = \\frac{2 \\times 4}{12} = \\frac{8}{12} = \\frac{2}{3}$.\n\nThe initial clustering coefficient is $\\frac{1}{2}$ and the rewired clustering coefficient is $\\frac{2}{3}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2} & \\frac{2}{3} \\end{pmatrix}}$$"
        },
        {
            "introduction": "The second key characteristic of a small-world network is a surprisingly short average path length, $L$, which measures the typical 'degrees of separation' between any two nodes. This exercise provides a striking demonstration of the small-world phenomenon by showing how adding just one long-range 'shortcut' to a regular ring lattice drastically reduces the network's overall travel time. Calculating this change will help you build a strong intuition for how these networks achieve global efficiency. ",
            "id": "1707847",
            "problem": "A simple model for a network consists of $N=10$ nodes, labeled $v_0, v_1, \\dots, v_9$. Initially, these nodes are arranged in a regular one-dimensional ring lattice where each node $v_i$ is connected only to its two immediate neighbors, $v_{i-1 \\pmod{10}}$ and $v_{i+1 \\pmod{10}}$.\n\nThe average path length, $L$, of a network is defined as the average of the shortest path distances over all possible pairs of distinct nodes.\n\nFirst, consider the initial ring lattice and denote its average path length as $L_{initial}$. Then, the network is modified by adding a single 'shortcut' edge that directly connects the diametrically opposite nodes $v_0$ and $v_5$. Let the average path length of this new, modified network be $L_{final}$.\n\nCalculate the ratio $\\frac{L_{final}}{L_{initial}}$. Express your answer as a fraction in simplest form.",
            "solution": "We have the 10-node cycle graph (each node has degree 2). For the initial ring lattice $C_{10}$ with $N=10=2m$ and $m=5$, the shortest-path distance between a fixed node and the others is distributed as: $2$ nodes at each distance $d=1,2,3,4$, and $1$ node at distance $5$. Therefore, the sum of distances from one node to all others is\n$$\nS_{\\text{per node}}=2\\sum_{d=1}^{4} d + 5 = 2\\cdot 10 + 5 = 25 = m^{2}.\n$$\nThe total sum over unordered pairs is then\n$$\n\\text{Sum}_{\\text{init}}=\\frac{N\\cdot S_{\\text{per node}}}{2}=\\frac{10\\cdot 25}{2}=125,\n$$\nand the number of unordered pairs is $\\binom{10}{2}=45$, so\n$$\nL_{\\text{initial}}=\\frac{125}{45}=\\frac{25}{9}.\n$$\n\nAfter adding the shortcut edge $(v_{0},v_{5})$, the graph becomes two $6$-cycles sharing the edge $(0,5)$. Distances within each of the two $6$-cycles are as in $C_{6}$, and paths between the two sides go through the shared edge optimally.\n\nBy symmetry, there are three node types: type A $\\{0,5\\}$, type B $\\{1,4,9,6\\}$, and type C $\\{2,3,8,7\\}$. Compute the sum of distances from one representative of each type to all other nodes:\n\n- From $0$ (type A): distances to $\\{1,5,9\\}$ are $1$, to $\\{2,4,6,8\\}$ are $2$, and to $\\{3,7\\}$ are $3$. Hence\n$$\nS_{0}=3\\cdot 1+4\\cdot 2+2\\cdot 3=17.\n$$\n\n- From $1$ (type B): distances to $\\{0,2\\}$ are $1$, to $\\{3,5,9\\}$ are $2$, to $\\{4,8,6\\}$ are $3$, and to $\\{7\\}$ is $4$. Hence\n$$\nS_{1}=2\\cdot 1+3\\cdot 2+3\\cdot 3+1\\cdot 4=21.\n$$\n\n- From $2$ (type C): distances to $\\{1,3\\}$ are $1$, to $\\{0,4\\}$ are $2$, to $\\{5,9\\}$ are $3$, to $\\{8,6\\}$ are $4$, and to $\\{7\\}$ is $5$. Hence\n$$\nS_{2}=2\\cdot 1+2\\cdot 2+2\\cdot 3+2\\cdot 4+1\\cdot 5=25.\n$$\n\nBy symmetry, the ordered total sum of distances over all nodes is\n$$\nS_{\\text{tot, ordered}}=2\\cdot S_{0}+4\\cdot S_{1}+4\\cdot S_{2}=2\\cdot 17+4\\cdot 21+4\\cdot 25=34+84+100=218.\n$$\nThus the unordered sum is $218/2=109$, so\n$$\nL_{\\text{final}}=\\frac{109}{45}.\n$$\n\nTherefore, the required ratio is\n$$\n\\frac{L_{\\text{final}}}{L_{\\text{initial}}}=\\frac{\\frac{109}{45}}{\\frac{25}{9}}=\\frac{109}{45}\\cdot\\frac{9}{25}=\\frac{109}{125}.\n$$",
            "answer": "$$\\boxed{\\frac{109}{125}}$$"
        },
        {
            "introduction": "Moving from manual calculations to algorithmic thinking, this practice challenges you to write a program that simulates the creation of a small-world network. You will start with a regular lattice and implement a greedy algorithm that iteratively adds shortcuts between the most distant nodes until a target average path length, $\\hat L$, is achieved. This computational exercise solidifies the link between random rewiring and network efficiency, bridging the gap between theoretical understanding and practical network engineering. ",
            "id": "3194029",
            "problem": "You are given an undirected, unweighted graph construction known as a ring lattice. The ring lattice has $N$ nodes labeled $0,1,\\dots,N-1$ arranged on a circle so that each node connects to its $k/2$ nearest neighbors on each side (that is, node $i$ connects to nodes $(i \\pm s) \\bmod N$ for $s = 1, 2, \\dots, k/2$). Assume $k$ is even and satisfies $2 \\le k < N$. The average path length $L(G)$ of a connected undirected graph $G=(V,E)$ is defined from first principles as the mean of all shortest-path distances among unordered node pairs:\n$$\nL(G) \\equiv \\frac{2}{N(N-1)} \\sum_{0 \\le u < v \\le N-1} d(u,v),\n$$\nwhere $d(u,v)$ is the length (in number of edges) of a shortest path between nodes $u$ and $v$.\n\nA shortcut edge is defined as an additional undirected edge between two distinct nodes that are not already adjacent. Starting from the ring lattice, you will iteratively add shortcut edges to reduce the average path length. At each iteration, apply the following deterministic greedy policy:\n- Compute all-pairs shortest paths using Breadth-First Search (BFS) to obtain $d(u,v)$ for all pairs $(u,v)$.\n- Among all nonadjacent pairs $(u,v)$ with $u < v$, select the pair with the maximum current shortest-path distance $d(u,v)$. If there are ties, break ties by choosing the lexicographically smallest pair, that is, the smallest $u$, and if $u$ is equal then the smallest $v$.\n- Add the selected edge $\\{u,v\\}$ to the graph.\n- Recompute the average path length $L(G)$ exactly from the updated distances.\n\nGiven a target average path length $\\hat L$ with $\\hat L \\ge 1$, define $t^*$ to be the minimal number of shortcut edges that must be added under the greedy farthest-pair policy so that, after $t^*$ additions, the resulting graph $G_{t^*}$ has $L(G_{t^*}) \\le \\hat L$. If the initial ring lattice already satisfies $L(G_0) \\le \\hat L$, then $t^* = 0$. If necessary, this process can continue until the graph becomes complete; a complete graph has average path length $1$.\n\nFundamental base:\n- Use the definition of shortest-path distance and compute it via Breadth-First Search (BFS).\n- Use the All-Pairs Shortest Paths (APSP) distances to compute $L(G)$ exactly from its definition.\n\nTask:\n- Implement a complete program that, for each test case, constructs the ring lattice with parameters $(N,k)$, and then performs the greedy farthest-pair shortcut addition policy described above until $L(G) \\le \\hat L$, returning the integer $t^*$.\n\nConstraints:\n- $N$ is an integer with $N \\ge 4$.\n- $k$ is an even integer with $2 \\le k < N$.\n- $\\hat L$ is a real number with $\\hat L \\ge 1$.\n- All edges are undirected and unweighted.\n- Distances are measured in edge counts (unitless graph-theoretic distance).\n\nTest suite:\nProvide results for the following parameter sets:\n- Case $1$: $N=20$, $k=4$, $\\hat L=3.0$.\n- Case $2$: $N=10$, $k=2$, $\\hat L=2.0$.\n- Case $3$: $N=30$, $k=4$, $\\hat L=50.0$.\n- Case $4$: $N=16$, $k=4$, $\\hat L=1.0$.\n\nFinal output format:\nYour program should produce a single line of output containing the results $[t^*_1,t^*_2,t^*_3,t^*_4]$ as a comma-separated list enclosed in square brackets, in the same order as the test cases above. Each $t^*_i$ must be an integer.",
            "solution": "The user-provided problem is a well-defined computational task in the domain of network science, an interdisciplinary field within computational science. The problem asks for the implementation of a deterministic greedy algorithm to add \"shortcut\" edges to a ring lattice graph until its average shortest path length falls below a specified target. This process is a simplified, deterministic variant of the Watts-Strogatz model for generating small-world networks. The problem is scientifically grounded, mathematically consistent, and algorithmically formalizable.\n\nThe solution process involves an iterative simulation. Each iteration consists of calculating all-pairs shortest paths, identifying the best candidate edge to add based on a \"farthest-pair\" greedy policy, updating the graph, and re-evaluating the average path length.\n\nHere is a step-by-step breakdown of the methodology.\n\n**Step 1: Graph Representation and Initialization**\nThe graph is undirected and unweighted, comprising $N$ nodes. An adjacency matrix, denoted as $A$, is a suitable representation for this problem, given the relatively small size of $N$ in the test cases. The matrix $A$ is an $N \\times N$ matrix where $A_{uv} = 1$ if an edge exists between nodes $u$ and $v$, and $A_{uv} = 0$ otherwise. Since the graph is undirected, $A$ is symmetric ($A_{uv} = A_{vu}$).\n\nThe initial graph is a ring lattice. It is constructed as follows: for each node $i \\in \\{0, 1, \\dots, N-1\\}$, edges are created to connect it to its $k/2$ nearest neighbors on each side. The neighbors of node $i$ are the nodes $(i \\pm s) \\pmod N$ for all $s \\in \\{1, 2, \\dots, k/2\\}$. The modulo $N$ operation ensures the circular topology of the lattice.\n\n**Step 2: All-Pairs Shortest Paths (APSP) Calculation**\nThe core of the algorithm requires knowing the shortest-path distance $d(u,v)$ between all pairs of nodes $(u,v)$. Since the graph is unweighted, the most efficient method for finding shortest paths from a single source node is the Breadth-First Search (BFS) algorithm.\n\nTo compute the all-pairs shortest paths, we can execute a separate BFS starting from each node $s \\in \\{0, 1, \\dots, N-1\\}$. A single BFS run from source $s$ works as follows:\n1. Initialize a distance array `dist` of size $N$, with `dist[s] = 0` and `dist[v] = \\infty$ for all $v \\neq s$.\n2. Initialize a queue and add the source node $s$ to it.\n3. While the queue is not empty, dequeue a node $u$.\n4. For each neighbor $v$ of $u$ (i.e., for each $v$ such that $A_{uv}=1$):\n   - If $v$ has not been visited (i.e., `dist[v] == \\infty`), set its distance `dist[v] = dist[u] + 1` and enqueue $v$.\n\nBy running this process for every node as the source, we can populate an $N \\times N$ distance matrix $D$, where $D_{uv} = d(u,v)$.\n\n**Step 3: Average Path Length Calculation**\nThe average path length $L(G)$ is calculated precisely from its definition using the computed distance matrix $D$. The formula is:\n$$\nL(G) = \\frac{1}{\\binom{N}{2}} \\sum_{0 \\le u < v \\le N-1} d(u,v) = \\frac{2}{N(N-1)} \\sum_{0 \\le u < v \\le N-1} D_{uv}\n$$\nThis is computed by summing all the elements in the upper triangle of the distance matrix $D$ and dividing by the total number of unique pairs, which is $N(N-1)/2$.\n\n**Step 4: The Iterative Greedy Algorithm**\nThe main logic is an iterative loop that adds one shortcut edge at each step. Let $t$ be the count of added shortcuts, initialized to $t=0$. Let $G_t$ be the graph after $t$ additions.\n\nInitialize:\n1. Construct the initial ring lattice $G_0$.\n2. Set $t=0$.\n\nLoop:\n1. Compute the distance matrix $D_t$ for the current graph $G_t$ using the APSP (BFS-based) method.\n2. Calculate the average path length $L(G_t)$ from $D_t$.\n3. **Termination Check**: If $L(G_t) \\le \\hat L$, the process terminates. The required number of shortcuts is $t^* = t$. A special case is when $L(G_0) \\le \\hat L$, which means $t^*=0$.\n4. **Farthest Pair Selection**: If $L(G_t) > \\hat L$, we must add a new shortcut. We identify the best candidate edge $\\{u,v\\}$ according to the greedy policy:\n   a. Consider all pairs of distinct nodes $(u,v)$ with $u < v$ that are not already connected in $G_t$ (i.e., $A_{uv}=0$).\n   b. Among these non-adjacent pairs, find the one that maximizes the shortest-path distance $d(u,v)$.\n   c. If there is a tie for the maximum distance, the tie is broken by selecting the lexicographically smallest pair. That is, we choose the pair $(u,v)$ that has the smallest $u$, and for that $u$, the smallest $v$. This tie-breaking is naturally handled by iterating through $u$ from $0$ to $N-2$ and $v$ from $u+1$ to $N-1$ and selecting the first pair that achieves the maximum observed distance.\n5. **Graph Update**: Add the selected shortcut edge $\\{u,v\\}$ to the graph, updating the adjacency matrix ($A_{uv}=1$ and $A_{vu}=1$).\n6. Increment the shortcut counter: $t \\leftarrow t+1$.\n7. Repeat the loop.\n\nThis process is guaranteed to terminate because adding an edge can only decrease or maintain path lengths, so $L(G)$ is a non-increasing function of $t$. In the worst case, the process continues until the graph becomes complete, at which point $L(G)=1$. Since the problem specifies $\\hat L \\ge 1$, the target is always reachable.\n\n**Step 5: Analysis of Test Cases**\n- **Case 1 ($N=20, k=4, \\hat L=3.0$):** The initial average path length of the ring lattice must be computed. It is expected to be greater than $3.0$, requiring a non-zero number of iterations.\n- **Case 2 ($N=10, k=2, \\hat L=2.0$):** The initial graph is a $10$-node cycle. Its average path length is exactly $L(G_0) = \\frac{1}{10 \\cdot 9 / 2} \\sum_{i=1}^5 i \\cdot (\\text{number of pairs at distance } i) = \\frac{2}{90} (1 \\cdot 10 + 2 \\cdot 10 + 3 \\cdot 10 + 4 \\cdot 10 + 5 \\cdot 5) = 2.5$. Since $2.5 > 2.0$, we expect $t^* > 0$.\n- **Case 3 ($N=30, k=4, \\hat L=50.0$):** The maximum possible average path length in any connected graph of $30$ nodes is much less than $50.0$. The initial ring lattice will have an $L(G_0)$ value significantly lower than this target. Thus, the condition $L(G_0) \\le \\hat L$ will be met immediately, yielding $t^*=0$.\n- **Case 4 ($N=16, k=4, \\hat L=1.0$):** The only connected graph with an average path length of $1.0$ is a complete graph. This case asks for the number of edges required to make the initial lattice complete using the greedy strategy. The initial number of edges is $N k / 2 = 16 \\cdot 4 / 2 = 32$. A complete graph $K_{16}$ has $N(N-1)/2 = 16 \\cdot 15 / 2 = 120$ edges. The number of shortcuts to be added is $120 - 32 = 88$. The greedy algorithm will continue until no non-adjacent pairs exist, at which point the graph is complete, so $t^*=88$.\n\nThe implementation will follow this logic to provide precise answers for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef run_simulation(N, k, L_hat):\n    \"\"\"\n    Computes the number of shortcuts to reach a target average path length.\n\n    Args:\n        N (int): Number of nodes.\n        k (int): Number of neighbors for each node in the initial ring lattice (must be even).\n        L_hat (float): Target average path length.\n\n    Returns:\n        int: The minimal number of shortcuts (t*).\n    \"\"\"\n\n    # Step 1: Initialize the ring lattice using an adjacency matrix\n    adj_matrix = np.zeros((N, N), dtype=int)\n    half_k = k // 2\n    for i in range(N):\n        for s in range(1, half_k + 1):\n            neighbor_fwd = (i + s) % N\n            neighbor_bwd = (i - s + N) % N\n            adj_matrix[i, neighbor_fwd] = 1\n            adj_matrix[i, neighbor_bwd] = 1\n\n    t = 0\n    while True:\n        # Step 2: Compute All-Pairs Shortest Paths (APSP) using BFS\n        # A value of -1 indicates unreachable nodes\n        dist_matrix = -1 * np.ones((N, N), dtype=int)\n        \n        for start_node in range(N):\n            dist_matrix[start_node, start_node] = 0\n            q = deque([start_node])\n            \n            while q:\n                u = q.popleft()\n                # Find neighbors of u using the adjacency matrix\n                neighbors = np.where(adj_matrix[u] == 1)[0]\n                for v in neighbors:\n                    if dist_matrix[start_node, v] == -1:\n                        dist_matrix[start_node, v] = dist_matrix[start_node, u] + 1\n                        q.append(v)\n        \n        # Check for disconnected components (should not happen for k>=2)\n        if np.any(dist_matrix == -1):\n            raise RuntimeError(\"Graph is not connected.\")\n\n        # Step 3: Calculate the current average path length\n        # Summing the upper triangle of the distance matrix\n        num_pairs = N * (N - 1) / 2\n        total_distance = np.sum(np.triu(dist_matrix, k=1))\n        avg_path_len = total_distance / num_pairs\n\n        # Step 4: Check for termination\n        if avg_path_len = L_hat:\n            return t\n\n        # Step 5: Find the farthest non-adjacent pair\n        max_dist = -1\n        best_pair = (-1, -1)\n        \n        # Iterate in lexicographical order to handle tie-breaking automatically\n        for u in range(N):\n            for v in range(u + 1, N):\n                if adj_matrix[u, v] == 0:\n                    current_dist = dist_matrix[u, v]\n                    if current_dist > max_dist:\n                        max_dist = current_dist\n                        best_pair = (u, v)\n        \n        # If no non-adjacent pair is found, the graph is complete.\n        if best_pair == (-1, -1):\n            if avg_path_len = L_hat:\n                return t\n            else:\n                # This should only happen if L_hat  1, which is disallowed\n                raise RuntimeError(\"Graph is complete but L > L_hat.\")\n\n        # Step 6: Add the shortcut edge to the graph\n        u, v = best_pair\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n        t += 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (20, 4, 3.0),\n        (10, 2, 2.0),\n        (30, 4, 50.0),\n        (16, 4, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, k, L_hat = case\n        result = run_simulation(N, k, L_hat)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}