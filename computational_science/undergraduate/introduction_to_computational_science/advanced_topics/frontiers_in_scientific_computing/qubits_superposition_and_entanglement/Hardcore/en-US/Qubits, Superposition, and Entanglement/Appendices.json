{
    "hands_on_practices": [
        {
            "introduction": "The power of a qubit lies not just in its ability to be in a superposition of states, but in our ability to control the complex amplitudes of that superposition. This exercise explores how a relative phase, which is invisible to direct measurement, can be made observable through the phenomenon of quantum interference. By building a simple circuit known as a quantum interferometer, you will see how a final basis change can transform phase information into a measurable change in probabilities, a principle that is fundamental to many quantum algorithms. ",
            "id": "3182365",
            "problem": "You will write a complete program that simulates a single-qubit circuit to study interference arising from relative phase and its relationship to the Discrete Fourier Transform (DFT). Use the following fundamental base and definitions.\n\nA qubit state is a unit vector in $\\mathbb{C}^2$. The computational basis is $\\{\\lvert 0 \\rangle, \\lvert 1 \\rangle\\}$, represented as column vectors $\\lvert 0 \\rangle = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$ and $\\lvert 1 \\rangle = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$. Gates are unitary matrices acting by left-multiplication on state vectors. Measurement in the computational basis follows the Born rule: if $\\lvert \\psi \\rangle = \\alpha \\lvert 0 \\rangle + \\beta \\lvert 1 \\rangle$, then the probability of observing outcome $\\lvert 0 \\rangle$ is $\\lvert \\alpha \\rvert^2$ and the probability of observing outcome $\\lvert 1 \\rangle$ is $\\lvert \\beta \\rvert^2$.\n\nUse the Hadamard gate $H$ and the phase rotation gate about the $z$-axis $R_z(\\phi)$ defined by\n$$\nH = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1  1 \\\\ 1  -1\\end{bmatrix}, \\qquad\nR_z(\\phi) = e^{-i\\phi Z/2} = \\begin{bmatrix} e^{-i\\phi/2}  0 \\\\ 0  e^{i\\phi/2} \\end{bmatrix},\n$$\nwhere $Z = \\begin{bmatrix}1  0 \\\\ 0  -1\\end{bmatrix}$ is the Pauli-$Z$ matrix and $i$ is the imaginary unit. Angles $\\phi$ are given in radians.\n\nStart from $\\lvert 0 \\rangle$ and consider the following two scenarios:\n- Scenario $\\mathrm{A}$ (no final transform): apply $H$ then $R_z(\\phi)$ and measure in the computational basis.\n- Scenario $\\mathrm{B}$ (with final transform): apply $H$ then $R_z(\\phi)$ then $H$ again and measure in the computational basis.\n\nIn both scenarios, compute the probabilities of outcomes $\\lvert 0 \\rangle$ and $\\lvert 1 \\rangle$ using the Born rule. Then, explain how Scenario $\\mathrm{B}$ realizes a length-$2$ Discrete Fourier Transform (DFT) of the complex two-sample vector formed by the post-$R_z(\\phi)$ amplitudes, and how this produces interference dependent on $\\phi$.\n\nYour program must:\n- Implement the simulation by explicit matrix-vector multiplication using the definitions above.\n- For each test value of $\\phi$, output four numbers in the fixed order [$p^{\\mathrm{A}}_0, p^{\\mathrm{A}}_1, p^{\\mathrm{B}}_0, p^{\\mathrm{B}}_1$], where $p^{\\mathrm{A}}_b$ is the probability of outcome $\\lvert b \\rangle$ in Scenario $\\mathrm{A}$ and $p^{\\mathrm{B}}_b$ is the probability of outcome $\\lvert b \\rangle$ in Scenario $\\mathrm{B}$.\n- Round each probability to exactly six decimal places and express them as decimals (no percentage sign).\n\nTest suite (angles in radians):\n$$\n\\phi \\in \\left\\{ 0, \\frac{\\pi}{2}, \\pi, \\frac{3\\pi}{2}, 2\\pi, -\\frac{\\pi}{3} \\right\\}.\n$$\n\nFinal output format:\nYour program should produce a single line of output that is a list of entries, where each entry corresponds to one $\\phi$ in the order above and is itself a list [$p^{\\mathrm{A}}_0, p^{\\mathrm{A}}_1, p^{\\mathrm{B}}_0, p^{\\mathrm{B}}_1$]. The entire output must be a single bracketed list with comma-separated entries and no spaces. For example, a valid format looks like $[[a,b,c,d],[e,f,g,h]]$ where $a,b,c,d,e,f,g,h$ stand for the rounded decimals produced by your program.",
            "solution": "The problem statement is scientifically grounded, well-posed, and objective. It provides a complete set of definitions and constraints necessary for a unique and meaningful solution. The problem explores fundamental concepts of quantum computing, specifically superposition, relative phase, interference, and the relationship between the Hadamard gate and the Discrete Fourier Transform (DFT). All provided definitions and matrices are standard in the field. Therefore, the problem is deemed valid and a solution will be presented.\n\nThe goal is to analyze a single-qubit circuit under two different scenarios, compute the measurement outcome probabilities, and explain the underlying quantum principles. The simulation will be performed through explicit matrix-vector multiplication.\n\nThe computational basis states are given by the vectors $\\lvert 0 \\rangle = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$ and $\\lvert 1 \\rangle = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$. The initial state for both scenarios is $\\lvert \\psi_0 \\rangle = \\lvert 0 \\rangle$.\n\nThe first operation is the application of the Hadamard gate, $H = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1  1 \\\\ 1  -1\\end{bmatrix}$. This transforms the initial state into a superposition:\n$$\n\\lvert \\psi_1 \\rangle = H \\lvert \\psi_0 \\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1  1 \\\\ 1  -1\\end{bmatrix} \\begin{bmatrix}1 \\\\ 0\\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1 \\\\ 1\\end{bmatrix} = \\frac{1}{\\sqrt{2}}(\\lvert 0 \\rangle + \\lvert 1 \\rangle)\n$$\nThis state, often denoted $\\lvert + \\rangle$, has equal probability amplitudes for the $\\lvert 0 \\rangle$ and $\\lvert 1 \\rangle$ basis states.\n\nThe second operation is the application of the phase rotation gate, $R_z(\\phi) = \\begin{bmatrix} e^{-i\\phi/2}  0 \\\\ 0  e^{i\\phi/2} \\end{bmatrix}$. Applying this to $\\lvert \\psi_1 \\rangle$ yields:\n$$\n\\lvert \\psi_2 \\rangle = R_z(\\phi) \\lvert \\psi_1 \\rangle = \\begin{bmatrix} e^{-i\\phi/2}  0 \\\\ 0  e^{i\\phi/2} \\end{bmatrix} \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1 \\\\ 1\\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}e^{-i\\phi/2} \\\\ e^{i\\phi/2}\\end{bmatrix}\n$$\nThe state can be written in ket notation as $\\lvert \\psi_2 \\rangle = \\frac{e^{-i\\phi/2}}{\\sqrt{2}} \\lvert 0 \\rangle + \\frac{e^{i\\phi/2}}{\\sqrt{2}} \\lvert 1 \\rangle$. This operation introduces a relative phase of $\\phi$ between the two computational basis components, as the state is physically equivalent to $\\frac{1}{\\sqrt{2}}(\\lvert 0 \\rangle + e^{i\\phi} \\lvert 1 \\rangle)$ after factoring out the unobservable global phase $e^{-i\\phi/2}$.\n\nAt this point, the two scenarios diverge.\n\n**Scenario A: Measurement after $R_z(\\phi)$**\n\nIn this scenario, we measure the state $\\lvert \\psi_A \\rangle = \\lvert \\psi_2 \\rangle$ in the computational basis. The amplitudes are $\\alpha = \\frac{e^{-i\\phi/2}}{\\sqrt{2}}$ for outcome $\\lvert 0 \\rangle$ and $\\beta = \\frac{e^{i\\phi/2}}{\\sqrt{2}}$ for outcome $\\lvert 1 \\rangle$.\n\nAccording to the Born rule, the probabilities of observing outcomes $\\lvert 0 \\rangle$ and $\\lvert 1 \\rangle$ are:\n$$\np^{\\mathrm{A}}_0 = |\\alpha|^2 = \\left| \\frac{e^{-i\\phi/2}}{\\sqrt{2}} \\right|^2 = \\frac{1}{2} |e^{-i\\phi/2}|^2 = \\frac{1}{2}\n$$\n$$\np^{\\mathrm{A}}_1 = |\\beta|^2 = \\left| \\frac{e^{i\\phi/2}}{\\sqrt{2}} \\right|^2 = \\frac{1}{2} |e^{i\\phi/2}|^2 = \\frac{1}{2}\n$$\nFor any value of $\\phi$, both probabilities are fixed at $0.5$. This demonstrates that a relative phase between basis states is not directly observable through measurement in that same basis.\n\n**Scenario B: Final Hadamard transform before measurement**\n\nIn this scenario, a second Hadamard gate is applied to $\\lvert \\psi_2 \\rangle$ before measurement. The final state is $\\lvert \\psi_B \\rangle = H \\lvert \\psi_2 \\rangle$.\n$$\n\\lvert \\psi_B \\rangle = H \\lvert \\psi_2 \\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1  1 \\\\ 1  -1\\end{bmatrix} \\left( \\frac{1}{\\sqrt{2}}\\begin{bmatrix}e^{-i\\phi/2} \\\\ e^{i\\phi/2}\\end{bmatrix} \\right) = \\frac{1}{2}\\begin{bmatrix}e^{-i\\phi/2} + e^{i\\phi/2} \\\\ e^{-i\\phi/2} - e^{i\\phi/2}\\end{bmatrix}\n$$\nUsing Euler's identities, $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$ and $e^{-i\\theta} - e^{i\\theta} = -2i\\sin\\theta$, we can simplify the components of the state vector:\n$$\ne^{-i\\phi/2} + e^{i\\phi/2} = 2\\cos(\\phi/2)\n$$\n$$\ne^{-i\\phi/2} - e^{i\\phi/2} = -2i\\sin(\\phi/2)\n$$\nSubstituting these back into the expression for $\\lvert \\psi_B \\rangle$:\n$$\n\\lvert \\psi_B \\rangle = \\frac{1}{2}\\begin{bmatrix}2\\cos(\\phi/2) \\\\ -2i\\sin(\\phi/2)\\end{bmatrix} = \\begin{bmatrix}\\cos(\\phi/2) \\\\ -i\\sin(\\phi/2)\\end{bmatrix} = \\cos(\\phi/2)\\lvert 0 \\rangle - i\\sin(\\phi/2)\\lvert 1 \\rangle\n$$\nNow, we measure this state in the computational basis. The new amplitudes are $\\alpha' = \\cos(\\phi/2)$ and $\\beta' = -i\\sin(\\phi/2)$. The probabilities are:\n$$\np^{\\mathrm{B}}_0 = |\\alpha'|^2 = |\\cos(\\phi/2)|^2 = \\cos^2(\\phi/2)\n$$\n$$\np^{\\mathrm{B}}_1 = |\\beta'|^2 = |-i\\sin(\\phi/2)|^2 = |-i|^2|\\sin(\\phi/2)|^2 = \\sin^2(\\phi/2)\n$$\nThese probabilities are now dependent on the phase $\\phi$. The sequence of gates $H \\dots H$ has transformed the unobservable relative phase into an observable change in the measurement statistics. This phenomenon is quantum interference.\n\n**Relationship to the Discrete Fourier Transform (DFT)**\n\nThe $N$-point DFT transforms a complex vector $x=(x_0, x_1, \\dots, x_{N-1})$ into a vector $y=(y_0, y_1, \\dots, y_{N-1})$ where $y_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} x_j e^{-i2\\pi jk/N}$. For $N=2$, the transformation is:\n$$\n\\begin{bmatrix}y_0 \\\\ y_1\\end{bmatrix} = \\frac{1}{\\sqrt{2}} \\begin{bmatrix}1  1 \\\\ 1  -1\\end{bmatrix} \\begin{bmatrix}x_0 \\\\ x_1\\end{bmatrix}\n$$\nThe transformation matrix is identical to the Hadamard gate $H$. Thus, the Hadamard gate implements the 2-point DFT.\n\nIn Scenario B, the final $H$ gate acts on the state $\\lvert \\psi_2 \\rangle$, whose amplitudes form the \"two-sample vector\" $\\begin{bmatrix} \\frac{e^{-i\\phi/2}}{\\sqrt{2}} \\\\ \\frac{e^{i\\phi/2}}{\\sqrt{2}} \\end{bmatrix}$. The action of $H$ is therefore equivalent to computing the DFT of these amplitudes. This coherent summation (and subtraction) of the amplitudes is the mathematical basis for interference.\n\nFor the $\\lvert 0 \\rangle$ component of the final state, the amplitudes add: $\\frac{1}{\\sqrt{2}}(x_0 + x_1)$. Depending on their relative phase $\\phi$, they can add constructively (e.g., if $\\phi=0$, $x_0=x_1$) or destructively (e.g., if $\\phi=\\pi$, $x_0 = -x_1$). This interference effect, made manifest by the final DFT (Hadamard gate), is what makes the final measurement probabilities sensitive to $\\phi$. The circuit $H R_z(\\phi) H$ serves as a basic interferometer.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a single-qubit interference circuit to compute measurement\n    probabilities for two scenarios based on a relative phase phi.\n    \"\"\"\n    # Define the test cases for the angle phi in radians.\n    test_cases = [\n        0,\n        np.pi / 2,\n        np.pi,\n        3 * np.pi / 2,\n        2 * np.pi,\n        -np.pi / 3\n    ]\n\n    # Define the initial state and the Hadamard gate.\n    # Computational basis state |0\n    psi_0 = np.array([[1], [0]], dtype=complex)\n    \n    # Hadamard gate H\n    H = (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=complex)\n\n    all_results = []\n    \n    for phi in test_cases:\n        # Define the R_z(phi) gate for the current angle phi.\n        # R_z(phi) = [[exp(-i*phi/2), 0], [0, exp(i*phi/2)]]\n        Rz_phi = np.array([\n            [np.exp(-1j * phi / 2), 0],\n            [0, np.exp(1j * phi / 2)]\n        ], dtype=complex)\n\n        # --- Circuit Simulation ---\n        # 1. Apply the first Hadamard gate to the initial state |0.\n        # psi_1 = H |0 = |+\n        psi_1 = H @ psi_0\n\n        # 2. Apply the R_z(phi) gate to introduce a relative phase.\n        # psi_2 = R_z(phi) H |0\n        psi_2 = Rz_phi @ psi_1\n\n        # --- Scenario A: Measure after R_z(phi) ---\n        # The state to measure is psi_2.\n        psi_A = psi_2\n        \n        # Amplitudes for |0 and |1 outcomes.\n        alpha_A = psi_A[0, 0]\n        beta_A = psi_A[1, 0]\n\n        # Probabilities calculated using the Born rule: p = |amplitude|^2\n        pA0 = np.abs(alpha_A)**2\n        pA1 = np.abs(beta_A)**2\n\n        # --- Scenario B: Apply final H gate, then measure ---\n        # 3. Apply the second Hadamard gate to induce interference.\n        # psi_B = H R_z(phi) H |0\n        psi_B = H @ psi_2\n        \n        # Amplitudes for |0 and |1 outcomes.\n        alpha_B = psi_B[0, 0]\n        beta_B = psi_B[1, 0]\n\n        # Probabilities calculated using the Born rule.\n        pB0 = np.abs(alpha_B)**2\n        pB1 = np.abs(beta_B)**2\n\n        # Round each probability to exactly six decimal places and format as a string.\n        # Using f-string formatting ensures correct rounding and inclusion of trailing zeros.\n        current_case_results = [\n            f\"{pA0:.6f}\",\n            f\"{pA1:.6f}\",\n            f\"{pB0:.6f}\",\n            f\"{pB1:.6f}\"\n        ]\n        \n        # Format the list of results for the current case.\n        all_results.append(f\"[{','.join(current_case_results)}]\")\n\n    # Final print statement in the exact required format.\n    # The output is a single line: a list of lists, with no spaces.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While superposition is a key feature of single qubits, entanglement is the quintessential property of multi-qubit systems, describing correlations with no classical analogue. But given the mathematical description of a two-qubit state, how can we definitively determine if it is entangled? This practice introduces a powerful algorithmic tool: the Peres-Horodecki positive partial transpose (PPT) criterion. You will implement this test to distinguish entangled states from separable ones, gaining hands-on experience with a crucial diagnostic method in quantum information science. ",
            "id": "3182282",
            "problem": "You are to implement a program that decides separability of bipartite quantum states for two-qubit systems using the Peres–Horodecki positive partial transpose (PPT) criterion. Work entirely in the computational basis $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$ for two qubits, which corresponds to a Hilbert space of dimension $4$. A quantum state is represented by a density matrix $\\rho$, which is a $4\\times 4$ complex, Hermitian, positive semidefinite matrix with unit trace acting on $\\mathcal{H}_A \\otimes \\mathcal{H}_B$, where both subsystems $A$ and $B$ are qubits of dimension $2$.\n\nFundamental base and definitions to use:\n- A density operator $\\rho$ on a composite system $\\mathcal{H}_A \\otimes \\mathcal{H}_B$ has elements $\\rho_{i_A i_B; j_A j_B}$ in the computational basis, where $i_A, j_A \\in \\{0,1\\}$ index subsystem $A$ and $i_B, j_B \\in \\{0,1\\}$ index subsystem $B$.\n- The partial transpose with respect to subsystem $B$, denoted $\\rho^{T_B}$, is defined by transposing only the $B$ indices in that basis. In index notation,\n$$\n\\left(\\rho^{T_B}\\right)_{i_A i_B; j_A j_B} \\equiv \\rho_{i_A j_B; j_A i_B}.\n$$\n- The Peres–Horodecki separability criterion states that for $2\\times 2$ systems, a state is separable if and only if its partial transpose is positive semidefinite, i.e., all eigenvalues of $\\rho^{T_B}$ are greater than or equal to $0$.\n\nYour tasks:\n1. Implement a function that computes the partial transpose $\\rho^{T_B}$ for a given $4\\times 4$ density matrix $\\rho$ by applying the index mapping above. You must assume the basis ordering $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$, so that a vector $|\\psi\\rangle = [\\psi_{00}, \\psi_{01}, \\psi_{10}, \\psi_{11}]^\\top$ corresponds to that ordering.\n2. Compute the eigenvalues of $\\rho^{T_B}$ and decide whether there exists an eigenvalue strictly less than $0$, up to a numerical tolerance parameter $\\tau$. Use the decision rule: a state is entangled if and only if $\\min \\text{eig}(\\rho^{T_B})  -\\tau$. Use $\\tau = 10^{-9}$.\n3. Apply your implementation to the following test suite of states. For each, return a boolean indicating whether the state is entangled ($\\text{True}$) or separable ($\\text{False}$). Angles, when present, must be interpreted in radians.\n\nTest suite (all states are $4\\times 4$ density matrices):\n- Case $1$ (pure product state): $\\rho_1 = |00\\rangle\\langle 00|$, where $|00\\rangle = [1,0,0,0]^\\top$.\n- Case $2$ (maximally entangled Bell state): $\\rho_2 = |\\Phi^+\\rangle\\langle \\Phi^+|$, where $|\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)$.\n- Case $3$ (Werner state at the PPT boundary): $\\rho_3 = (1-p)\\frac{I_4}{4} + p|\\Psi^-\\rangle\\langle \\Psi^-|$ with $p = \\frac{1}{3}$, $I_4$ the $4\\times 4$ identity, and $|\\Psi^-\\rangle = \\frac{1}{\\sqrt{2}}(|01\\rangle - |10\\rangle)$.\n- Case $4$ (Werner state deep in the entangled region): $\\rho_4 = (1-p)\\frac{I_4}{4} + p|\\Psi^-\\rangle\\langle \\Psi^-|$ with $p = 0.8$.\n- Case $5$ (classically correlated separable mixture): $\\rho_5 = \\frac{1}{2}|00\\rangle\\langle 00| + \\frac{1}{2}|11\\rangle\\langle 11|$.\n- Case $6$ (generic pure product state from local superpositions): Let $|a\\rangle = \\cos\\theta|0\\rangle + \\sin\\theta|1\\rangle$ and $|b\\rangle = \\cos\\phi|0\\rangle + \\sin\\phi|1\\rangle$ with $\\theta = \\pi/5$ and $\\phi = \\pi/7$ (angles in radians). Set $\\rho_6 = (|a\\rangle\\langle a|) \\otimes (|b\\rangle\\langle b|)$.\n- Case $7$ (partially entangled pure state in Schmidt form): $\\rho_7 = |\\psi_\\lambda\\rangle\\langle \\psi_\\lambda|$ with $|\\psi_\\lambda\\rangle = \\sqrt{\\lambda}|00\\rangle + \\sqrt{1-\\lambda}|11\\rangle$ and $\\lambda = 0.7$.\n\nImplementation notes:\n- You must treat each $\\rho_k$ as an exact matrix built from the definitions above.\n- Use the decision rule with $\\tau = 10^{-9}$, so that borderline numerical artifacts are handled consistently.\n- Angles in Case $6$ must be interpreted in radians.\n- No physical units are involved in this problem.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above. For example, for seven boolean results $b_1,\\dots,b_7$, print exactly the string\n$$\n[ b_1, b_2, b_3, b_4, b_5, b_6, b_7 ]\n$$\nbut without spaces after commas, i.e., in the format $[b_1,b_2,b_3,b_4,b_5,b_6,b_7]$.\n- Each $b_k$ must be either the boolean $\\text{True}$ or $\\text{False}$.",
            "solution": "The problem requires the implementation of the Peres–Horodecki criterion to determine if a two-qubit quantum state is separable or entangled. The criterion is necessary and sufficient for systems of dimension $2 \\otimes 2$ (two-qubit) and $2 \\otimes 3$. A state described by a density matrix $\\rho$ is separable if and only if its partial transpose, $\\rho^{T_B}$, is a positive semidefinite matrix. This means all eigenvalues of $\\rho^{T_B}$ must be non-negative.\n\nThe solution proceeds in three main steps:\n1.  Construction of the density matrix $\\rho$ for each test case.\n2.  Implementation of the partial transpose operation with respect to subsystem $B$, denoted $\\rho \\to \\rho^{T_B}$.\n3.  Calculation of the eigenvalues of $\\rho^{T_B}$ and application of the decision rule for entanglement.\n\n**1. State Representation and Basis**\n\nWe operate in the four-dimensional Hilbert space $\\mathcal{H} = \\mathcal{H}_A \\otimes \\mathcal{H}_B$, where $\\mathcal{H}_A$ and $\\mathcal{H}_B$ are the two-dimensional spaces for qubit $A$ and qubit $B$, respectively. The computational basis is given as $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$, where $|i_A i_B\\rangle \\equiv |i_A\\rangle_A \\otimes |i_B\\rangle_B$. The basis vectors in their matrix representation are:\n$$\n|00\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n|01\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad\n|10\\rangle = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad\n|11\\rangle = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\nA general pure state $|\\psi\\rangle = c_{00}|00\\rangle + c_{01}|01\\rangle + c_{10}|10\\rangle + c_{11}|11\\rangle$ is represented by a column vector $[c_{00}, c_{01}, c_{10}, c_{11}]^T$. The corresponding density matrix is $\\rho = |\\psi\\rangle\\langle\\psi|$. Mixed states are represented by convex combinations of such pure state density matrices, $\\rho = \\sum_i p_i |\\psi_i\\rangle\\langle\\psi_i|$. A density matrix $\\rho$ is a $4 \\times 4$ matrix whose elements are indexed by basis states, e.g., $\\rho_{i,j} = \\langle \\text{basis}_i | \\rho | \\text{basis}_j \\rangle$.\n\n**2. The Partial Transpose Operation**\n\nThe partial transpose with respect to subsystem $B$, denoted $\\rho^{T_B}$, acts by transposing the matrix indices corresponding to subsystem $B$ only. Given the ordered basis $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$, an element of the density matrix $\\rho$ is written as $\\rho_{i_A i_B; j_A j_B}$. The problem defines partial transpose as:\n$$\n(\\rho^{T_B})_{i_A i_B; j_A j_B} \\equiv \\rho_{i_A j_B; j_A i_B}\n$$\nTo implement this, we map the $4 \\times 4$ matrix indices $i, j \\in \\{0, 1, 2, 3\\}$ to the qubit indices $(i_A, i_B)$ and $(j_A, j_B)$. For the specified basis order, this mapping is:\n$i \\to (i_A, i_B) = (\\lfloor i/2 \\rfloor, i \\pmod 2)$\n$j \\to (j_A, j_B) = (\\lfloor j/2 \\rfloor, j \\pmod 2)$\n\nLet $\\rho'_{ij}$ be an element of the partially transposed matrix $\\rho^{T_B}$. The definition implies that $\\rho'_{ij}$ is sourced from an element $\\rho_{kl}$ of the original matrix. The source row index $k$ corresponds to the qubit indices $(i_A, j_B)$, and the source column index $l$ corresponds to $(j_A, i_B)$. Thus:\n$k = i_A \\cdot 2 + j_B = \\lfloor i/2 \\rfloor \\cdot 2 + (j \\pmod 2)$\n$l = j_A \\cdot 2 + i_B = \\lfloor j/2 \\rfloor \\cdot 2 + (i \\pmod 2)$\n\nThis index mapping is implemented by iterating through all elements of the $4 \\times 4$ matrix. Since the original density matrix $\\rho$ is Hermitian, the resulting matrix $\\rho^{T_B}$ is also Hermitian, guaranteeing real eigenvalues.\n\n**3. Eigenvalue Analysis and Decision Rule**\n\nThe Peres–Horodecki criterion states that the state $\\rho$ is separable if and only if $\\rho^{T_B}$ is positive semidefinite. A matrix is positive semidefinite if all of its eigenvalues are non-negative. To account for numerical floating-point inaccuracies, a small negative tolerance $\\tau = 10^{-9}$ is used. The decision rule is:\n- If $\\min \\text{eig}(\\rho^{T_B}) \\ge -\\tau$, the state is considered separable (result: $\\text{False}$).\n- If $\\min \\text{eig}(\\rho^{T_B})  -\\tau$, the state is entangled (result: $\\text{True}$).\n\nThe algorithm proceeds as follows for each test case:\na. Construct the $4 \\times 4$ complex matrix $\\rho_k$ according to its definition.\nb. Compute $\\rho_k^{T_B}$ using the index-swapping logic derived above.\nc. Calculate the eigenvalues of the Hermitian matrix $\\rho_k^{T_B}$.\nd. Find the minimum eigenvalue and compare it to $-\\tau$ to determine if the state is entangled.\n\nThe test cases are constructed as follows:\n- **Case 1 ($\\rho_1$):** A pure product state $|00\\rangle\\langle 00|$. This is separable by definition.\n- **Case 2 ($\\rho_2$):** The maximally entangled Bell state $|\\Phi^+\\rangle\\langle\\Phi^+|$.\n- **Case 3 ($\\rho_3$):** A Werner state, which is a mixture of a maximally mixed state $I_4/4$ and a Bell state projector $|\\Psi^-\\rangle\\langle\\Psi^-|$ with mixing parameter $p=1/3$. This value of $p$ is known to be the boundary between separable and entangled Werner states.\n- **Case 4 ($\\rho_4$):** A Werner state with $p=0.8$, which is deep in the entangled region.\n- **Case 5 ($\\rho_5$):** A classical mixture of two product states, which is a separable state.\n- **Case 6 ($\\rho_6$):** A pure product state formed by the tensor product of two arbitrary single-qubit pure states. This is separable by construction.\n- **Case 7 ($\\rho_7$):** A partially entangled pure state whose entanglement is controlled by a parameter $\\lambda=0.7$. For $\\lambda \\in (0,1)$, this state is entangled.\n\nThe final program implements these steps for all seven cases and formats the boolean results as a comma-separated list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum state separability problem using the Peres-Horodecki criterion.\n    \"\"\"\n\n    def partial_transpose_B(rho):\n        \"\"\"\n        Computes the partial transpose of a 4x4 density matrix with respect to subsystem B.\n        The basis is assumed to be {|00, |01, |10, |11}.\n        \n        Args:\n            rho (np.ndarray): A 4x4 complex numpy array representing the density matrix.\n\n        Returns:\n            np.ndarray: The partially transposed 4x4 density matrix.\n        \"\"\"\n        rho_pt = np.zeros_like(rho, dtype=complex)\n        for i in range(4):\n            for j in range(4):\n                # Decompose matrix indices i, j into qubit indices (i_A, i_B), (j_A, j_B)\n                i_A = i  1  # Integer division by 2\n                i_B = i  1   # Modulo 2\n                j_A = j  1\n                j_B = j  1\n                \n                # Construct source indices k, l based on the partial transpose definition\n                # (rho^T_B)_{i_A i_B; j_A j_B} = rho_{i_A j_B; j_A i_B}\n                k = (i_A  1) | j_B  # k = i_A * 2 + j_B\n                l = (j_A  1) | i_B  # l = j_A * 2 + i_B\n                \n                rho_pt[i, j] = rho[k, l]\n                \n        return rho_pt\n\n    def is_entangled(rho, tau=1e-9):\n        \"\"\"\n        Determines if a state is entangled using the Peres-Horodecki criterion.\n\n        Args:\n            rho (np.ndarray): The 4x4 density matrix.\n            tau (float): The numerical tolerance for the eigenvalue check.\n\n        Returns:\n            bool: True if the state is entangled, False if separable.\n        \"\"\"\n        rho_ptb = partial_transpose_B(rho)\n        \n        # The partial transpose of a Hermitian matrix is Hermitian.\n        # eigvalsh is efficient and numerically stable for Hermitian matrices.\n        eigenvalues = np.linalg.eigvalsh(rho_ptb)\n        \n        min_eigenvalue = np.min(eigenvalues)\n        \n        return min_eigenvalue  -tau\n\n    # Define single-qubit basis vectors\n    q0 = np.array([[1], [0]], dtype=complex)\n    q1 = np.array([[0], [1]], dtype=complex)\n    \n    # Define two-qubit basis vectors using Kronecker product\n    q00 = np.kron(q0, q0)\n    q01 = np.kron(q0, q1)\n    q10 = np.kron(q1, q0)\n    q11 = np.kron(q1, q1)\n\n    # --- Construct and store test cases ---\n    test_cases = []\n\n    # Case 1: Pure product state |0000|\n    rho1 = q00 @ q00.T.conj()\n    test_cases.append(rho1)\n\n    # Case 2: Maximally entangled Bell state |Phi+Phi+|\n    phi_plus = (q00 + q11) / np.sqrt(2)\n    rho2 = phi_plus @ phi_plus.T.conj()\n    test_cases.append(rho2)\n    \n    # Case 3: Werner state at the PPT boundary (p = 1/3)\n    I4 = np.identity(4, dtype=complex)\n    psi_minus = (q01 - q10) / np.sqrt(2)\n    p3 = 1/3\n    rho3 = (1 - p3) * I4 / 4 + p3 * (psi_minus @ psi_minus.T.conj())\n    test_cases.append(rho3)\n    \n    # Case 4: Entangled Werner state (p = 0.8)\n    p4 = 0.8\n    rho4 = (1 - p4) * I4 / 4 + p4 * (psi_minus @ psi_minus.T.conj())\n    test_cases.append(rho4)\n    \n    # Case 5: Classically correlated separable mixture\n    rho5 = 0.5 * (q00 @ q00.T.conj()) + 0.5 * (q11 @ q11.T.conj())\n    test_cases.append(rho5)\n    \n    # Case 6: Generic pure product state\n    theta = np.pi / 5\n    phi = np.pi / 7\n    state_a = np.cos(theta) * q0 + np.sin(theta) * q1\n    state_b = np.cos(phi) * q0 + np.sin(phi) * q1\n    rho_a = state_a @ state_a.T.conj()\n    rho_b = state_b @ state_b.T.conj()\n    rho6 = np.kron(rho_a, rho_b)\n    test_cases.append(rho6)\n    \n    # Case 7: Partially entangled pure state\n    lam = 0.7\n    psi_lambda = np.sqrt(lam) * q00 + np.sqrt(1 - lam) * q11\n    rho7 = psi_lambda @ psi_lambda.T.conj()\n    test_cases.append(rho7)\n\n    # --- Analyze each case and collect results ---\n    results = []\n    for rho in test_cases:\n        results.append(is_entangled(rho))\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our theoretical models often assume quantum systems are perfectly isolated, but real-world qubits are susceptible to decoherence from environmental interactions. This exercise moves beyond ideal unitary evolution to model amplitude damping, a common noise process where a qubit loses energy to its surroundings. You will use the formalism of Kraus operators to simulate this quantum channel and compute the fidelity, a measure of how well the quantum state is preserved. This practice provides essential insight into the central challenge of building fault-tolerant quantum computers: protecting quantum information from noise. ",
            "id": "3182325",
            "problem": "Consider a single-qubit quantum system described by a two-dimensional complex Hilbert space. A pure state is represented by a state vector $|\\psi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle$ with $|\\alpha|^2 + |\\beta|^2 = 1$, and by the corresponding density matrix $\\rho = |\\psi\\rangle \\langle \\psi|$. A general quantum channel is a Completely Positive Trace-Preserving (CPTP) map that transforms a density matrix $\\rho$ to a new density matrix $\\rho'$ via a Kraus decomposition, $\\rho' = \\sum_i K_i \\rho K_i^\\dagger$, where $\\{K_i\\}$ are Kraus operators satisfying $\\sum_i K_i^\\dagger K_i = I$. In amplitude damping (energy relaxation) with damping parameter $\\gamma \\in [0,1]$, the Kraus operators are\n$$\nK_0=\\begin{pmatrix}10\\\\0\\sqrt{1-\\gamma}\\end{pmatrix},\\quad\nK_1=\\begin{pmatrix}0\\sqrt{\\gamma}\\\\00\\end{pmatrix}.\n$$\nThe initial superposition state is parameterized on the Bloch sphere by angles $\\theta$ and $\\phi$ (in radians) as\n$$\n|\\psi(\\theta,\\phi)\\rangle = \\cos\\left(\\frac{\\theta}{2}\\right)|0\\rangle + e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right)|1\\rangle,\n$$\nwith corresponding density matrix $\\rho(\\theta,\\phi) = |\\psi(\\theta,\\phi)\\rangle\\langle\\psi(\\theta,\\phi)|$. The fidelity between two quantum states $\\rho$ and $\\sigma$ is the Uhlmann fidelity defined by\n$$\nF(\\rho,\\sigma) = \\left(\\mathrm{Tr}\\sqrt{\\sqrt{\\rho}\\,\\sigma\\,\\sqrt{\\rho}}\\right)^2,\n$$\nwhich quantifies the closeness between $\\rho$ and $\\sigma$.\n\nTask: Write a complete, runnable program that, for each test case below, constructs the initial pure state $\\rho(\\theta,\\phi)$, applies amplitude damping with parameter $\\gamma$ via the Kraus operators $\\{K_0,K_1\\}$ to obtain $\\rho'$, and computes the fidelity $F\\big(\\rho(\\theta,\\phi),\\rho'\\big)$. All angles must be interpreted in radians. The final numeric answers must be reported as decimal floats rounded to $10$ decimal places.\n\nTest Suite:\n- Case $1$: $(\\theta,\\phi,\\gamma) = (0,\\,0,\\,0)$.\n- Case $2$: $(\\theta,\\phi,\\gamma) = (\\pi,\\,0,\\,1)$.\n- Case $3$: $(\\theta,\\phi,\\gamma) = \\left(\\frac{\\pi}{2},\\,0,\\,\\frac{1}{2}\\right)$.\n- Case $4$: $(\\theta,\\phi,\\gamma) = \\left(\\frac{\\pi}{2},\\,\\frac{\\pi}{2},\\,\\frac{1}{4}\\right)$.\n- Case $5$: $(\\theta,\\phi,\\gamma) = \\left(\\frac{\\pi}{4},\\,\\pi,\\,\\frac{3}{4}\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the fidelity for Case $i$, rounded to $10$ decimal places, with no spaces anywhere in the output.",
            "solution": "The problem requires the computation of the Uhlmann fidelity between an initial single-qubit pure state and the state that results from applying an amplitude damping quantum channel. The solution involves a sequence of steps: constructing the initial state representations, applying the channel's Kraus operators to find the final state, and then evaluating the fidelity.\n\nFirst, we formalize the initial state of the quantum system. The qubit state is parameterized by the polar angle $\\theta \\in [0, \\pi]$ and the azimuthal angle $\\phi \\in [0, 2\\pi)$ on the Bloch sphere. In the computational basis $\\{|0\\rangle, |1\\rangle\\}$, where $|0\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$ and $|1\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$, the state vector $|\\psi(\\theta, \\phi)\\rangle$ is given by:\n$$\n|\\psi(\\theta,\\phi)\\rangle = \\cos\\left(\\frac{\\theta}{2}\\right)|0\\rangle + e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right)|1\\rangle = \\begin{pmatrix} \\cos(\\frac{\\theta}{2}) \\\\ e^{i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix}\n$$\nThis is a pure state, and its corresponding density matrix $\\rho$ is the outer product $\\rho = |\\psi\\rangle\\langle\\psi|$.\n$$\n\\rho(\\theta,\\phi) = \\begin{pmatrix} \\cos(\\frac{\\theta}{2}) \\\\ e^{i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} \\begin{pmatrix} \\cos(\\frac{\\theta}{2})  e^{-i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} = \\begin{pmatrix} \\cos^2(\\frac{\\theta}{2})  e^{-i\\phi}\\cos(\\frac{\\theta}{2})\\sin(\\frac{\\theta}{2}) \\\\ e^{i\\phi}\\cos(\\frac{\\theta}{2})\\sin(\\frac{\\theta}{2})  \\sin^2(\\frac{\\theta}{2}) \\end{pmatrix}\n$$\n\nNext, we apply the amplitude damping channel to this initial density matrix $\\rho$. A quantum channel is a Completely Positive Trace-Preserving (CPTP) map, which can be represented by a set of Kraus operators $\\{K_i\\}$. The transformation is given by the Kraus decomposition:\n$$\n\\rho' = \\sum_i K_i \\rho K_i^\\dagger\n$$\nFor amplitude damping with parameter $\\gamma$, the Kraus operators are:\n$$\nK_0=\\begin{pmatrix}10\\\\0\\sqrt{1-\\gamma}\\end{pmatrix}, \\quad K_1=\\begin{pmatrix}0\\sqrt{\\gamma}\\\\00\\end{pmatrix}\n$$\nThe final density matrix $\\rho'$ is therefore:\n$$\n\\rho' = K_0 \\rho K_0^\\dagger + K_1 \\rho K_1^\\dagger\n$$\n\nThe final step is to compute the fidelity $F(\\rho, \\rho')$ between the initial state $\\rho$ and the final state $\\rho'$. The problem provides the Uhlmann fidelity definition:\n$$\nF(\\rho, \\sigma) = \\left(\\mathrm{Tr}\\sqrt{\\sqrt{\\rho}\\,\\sigma\\,\\sqrt{\\rho}}\\right)^2\n$$\nA significant simplification exists when one of the states, say $\\rho$, is a pure state. Since $\\rho=|\\psi\\rangle\\langle\\psi|$ is a projection operator, it is idempotent, meaning $\\rho^2 = \\rho$. Consequently, $\\sqrt{\\rho} = \\rho$. The expression inside the trace becomes:\n$$\n\\sqrt{\\rho}\\,\\sigma\\,\\sqrt{\\rho} = |\\psi\\rangle\\langle\\psi| \\, \\sigma \\, |\\psi\\rangle\\langle\\psi| = |\\psi\\rangle (\\langle\\psi|\\sigma|\\psi\\rangle) \\langle\\psi|\n$$\nThe term $\\langle\\psi|\\sigma|\\psi\\rangle$ is a scalar, which we can denote as $c$. The expression simplifies to $c|\\psi\\rangle\\langle\\psi| = c\\rho$. Its square root is $\\sqrt{c\\rho} = \\sqrt{c}\\sqrt{\\rho} = \\sqrt{c}\\rho$. The trace is then $\\mathrm{Tr}(\\sqrt{c}\\rho) = \\sqrt{c} \\mathrm{Tr}(\\rho) = \\sqrt{c}$, since $\\mathrm{Tr}(\\rho)=1$.\nTherefore, the fidelity simplifies to:\n$$\nF(\\rho, \\sigma) = (\\sqrt{c})^2 = c = \\langle\\psi|\\sigma|\\psi\\rangle\n$$\nApplying this to our specific problem, with $\\sigma = \\rho'$, the fidelity is $F(\\rho, \\rho') = \\langle\\psi|\\rho'|\\psi\\rangle$. We can expand this using the Kraus representation of $\\rho'$:\n$$\nF(\\rho, \\rho') = \\langle\\psi| (K_0 \\rho K_0^\\dagger + K_1 \\rho K_1^\\dagger) |\\psi\\rangle\n$$\nSubstituting $\\rho=|\\psi\\rangle\\langle\\psi|$ yields:\n$$\nF = |\\langle\\psi|K_0|\\psi\\rangle|^2 + |\\langle\\psi|K_1|\\psi\\rangle|^2\n$$\nThis form is computationally advantageous. Let's evaluate the two terms.\nFirst term:\n$$\n\\langle\\psi|K_0|\\psi\\rangle = \\begin{pmatrix} \\cos(\\frac{\\theta}{2})  e^{-i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} \\begin{pmatrix}10\\\\0\\sqrt{1-\\gamma}\\end{pmatrix} \\begin{pmatrix} \\cos(\\frac{\\theta}{2}) \\\\ e^{i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} \\cos(\\frac{\\theta}{2})  e^{-i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} \\begin{pmatrix} \\cos(\\frac{\\theta}{2}) \\\\ \\sqrt{1-\\gamma}e^{i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} = \\cos^2\\left(\\frac{\\theta}{2}\\right) + \\sqrt{1-\\gamma}\\sin^2\\left(\\frac{\\theta}{2}\\right)\n$$\nThis expression is real, so its squared magnitude is simply its square.\n$$\n|\\langle\\psi|K_0|\\psi\\rangle|^2 = \\left(\\cos^2\\left(\\frac{\\theta}{2}\\right) + \\sqrt{1-\\gamma}\\sin^2\\left(\\frac{\\theta}{2}\\right)\\right)^2\n$$\nSecond term:\n$$\n\\langle\\psi|K_1|\\psi\\rangle = \\begin{pmatrix} \\cos(\\frac{\\theta}{2})  e^{-i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} \\begin{pmatrix}0\\sqrt{\\gamma}\\\\00\\end{pmatrix} \\begin{pmatrix} \\cos(\\frac{\\theta}{2}) \\\\ e^{i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} \\cos(\\frac{\\theta}{2})  e^{-i\\phi}\\sin(\\frac{\\theta}{2}) \\end{pmatrix} \\begin{pmatrix} \\sqrt{\\gamma}e^{i\\phi}\\sin(\\frac{\\theta}{2}) \\\\ 0 \\end{pmatrix} = \\sqrt{\\gamma}\\cos\\left(\\frac{\\theta}{2}\\right)e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right)\n$$\nThe squared magnitude is:\n$$\n|\\langle\\psi|K_1|\\psi\\rangle|^2 = \\left|\\sqrt{\\gamma}\\cos\\left(\\frac{\\theta}{2}\\right)e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right)\\right|^2 = \\gamma\\cos^2\\left(\\frac{\\theta}{2}\\right)\\sin^2\\left(\\frac{\\theta}{2}\\right)\n$$\nThe final expression for fidelity is the sum of these two terms. It is independent of the angle $\\phi$, which is expected due to the axial symmetry of the amplitude damping channel.\n$$\nF(\\theta, \\gamma) = \\left(\\cos^2\\left(\\frac{\\theta}{2}\\right) + \\sqrt{1-\\gamma}\\sin^2\\left(\\frac{\\theta}{2}\\right)\\right)^2 + \\gamma\\cos^2\\left(\\frac{\\theta}{2}\\right)\\sin^2\\left(\\frac{\\theta}{2}\\right)\n$$\nThis analytical formula is implemented to compute the fidelity for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum fidelity problem for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (theta, phi, gamma) in radians.\n    test_cases = [\n        (0.0, 0.0, 0.0),\n        (np.pi, 0.0, 1.0),\n        (np.pi / 2, 0.0, 1.0 / 2.0),\n        (np.pi / 2, np.pi / 2, 1.0 / 4.0),\n        (np.pi / 4, np.pi, 3.0 / 4.0),\n    ]\n\n    results = []\n    for theta, phi, gamma in test_cases:\n        # The fidelity F between an initial pure state |psi and its evolution rho'\n        # under a quantum channel with Kraus operators {K_i} is given by\n        # F = sum_i |psi|K_i|psi|^2.\n        #\n        # For amplitude damping, this leads to the analytical formula:\n        # F(theta, gamma) = (cos^2(theta/2) + sqrt(1-gamma)sin^2(theta/2))^2 + gamma*cos^2(theta/2)*sin^2(theta/2)\n        # Note that the fidelity is independent of phi.\n\n        # Calculate trigonometric terms\n        cos_half_theta = np.cos(theta / 2.0)\n        sin_half_theta = np.sin(theta / 2.0)\n        \n        c2 = cos_half_theta**2\n        s2 = sin_half_theta**2\n\n        # Calculate the two main components of the fidelity formula\n        term1_base = c2 + np.sqrt(1.0 - gamma) * s2\n        term1 = term1_base**2\n        \n        term2 = gamma * c2 * s2\n\n        # Sum the terms to get the final fidelity\n        fidelity = term1 + term2\n        \n        # Format the result as a string with 10 decimal places.\n        results.append(f\"{fidelity:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}