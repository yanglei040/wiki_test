{
    "hands_on_practices": [
        {
            "introduction": "高斯消元法是求解线性方程组的基石。然而，在计算机上实现该算法时，我们必须考虑数值稳定性，以避免被接近于零的数字除，这可能导致巨大的误差。部分主元法是一种关键策略，通过在每一步选择绝对值最大的元素作为主元来增强算法的稳健性。这个练习将带你亲手操作带部分主元法的高斯消元法的一个完整步骤，让你深入理解其力学原理和它在确保解的准确性方面的重要性。",
            "id": "2207645",
            "problem": "考虑由以下增广矩阵 $[A|b]$ 表示的线性方程组：\n\n$$\n\\left(\n\\begin{array}{ccc|c}\n1  2  3  1 \\\\\n4  5  6  2 \\\\\n2  1  1  3\n\\end{array}\n\\right)\n$$\n\n您的任务是对此矩阵应用带有部分主元策略的高斯消去法。执行此算法的第一个完整步骤，该步骤对应于第一列的操作（即，在第一列中确定主元，执行任何必要的行交换，然后使用主元行消去第一列主元下方的元素）。\n\n完成这第一步后，请给出所得修改后增广矩阵第三行的四个元素。这些元素应表示为一个行向量 $[c_1, c_2, c_3, c_4]$。",
            "solution": "我们对第一列应用带部分主元的高斯消去法。第一列的元素为 $1$, $4$, $2$，因此选择绝对值最大的元素作为主元，即第二行中的 $4$。交换第 $1$ 行和第 $2$ 行：\n$$\n\\begin{pmatrix}\n4  5  6  2 \\\\\n1  2  3  1 \\\\\n2  1  1  3\n\\end{pmatrix}\n$$\n使用主元行来消去第一列中主元下方的元素。对于新的第 $2$ 行，乘数为 $m_{21}=\\frac{1}{4}$，因此\n$$\nR_{2}\\leftarrow R_{2}-\\frac{1}{4}R_{1}:\\quad\n\\begin{cases}\n0,\\\\\n2-\\frac{1}{4}\\cdot 5=\\frac{3}{4},\\\\\n3-\\frac{1}{4}\\cdot 6=\\frac{3}{2},\\\\\n1-\\frac{1}{4}\\cdot 2=\\frac{1}{2}.\n\\end{cases}\n$$\n对于第 $3$ 行，乘数为 $m_{31}=\\frac{1}{2}$，因此\n$$\nR_{3}\\leftarrow R_{3}-\\frac{1}{2}R_{1}:\\quad\n\\begin{cases}\n0,\\\\\n1-\\frac{1}{2}\\cdot 5=-\\frac{3}{2},\\\\\n1-\\frac{1}{2}\\cdot 6=-2,\\\\\n3-\\frac{1}{2}\\cdot 2=2.\n\\end{cases}\n$$\n因此，在第一步之后，修改后的增广矩阵的第三行为 $[0,-\\frac{3}{2},-2,2]$。",
            "answer": "$$\\boxed{\\begin{pmatrix}0  -\\frac{3}{2}  -2  2\\end{pmatrix}}$$"
        },
        {
            "introduction": "当我们用数值方法求解一个方程组后，我们如何判断解的质量？由于计算机的有限精度算术，计算出的解通常只是一个近似值。后向误差分析为此提供了一个强有力的视角，它将问题从“我们的解离真实解有多近？”转变为“我们的解是一个多小的扰动问题的精确解？”。通过这个练习，你将学会计算相对后向误差，这是评估数值解可靠性的一个基本而实用的工具。",
            "id": "2207654",
            "problem": "在数值分析中，通常通过确定原始问题需要多大的扰动才能使近似解成为精确解，来评估线性方程组的近似解。\n\n考虑线性方程组 $A\\mathbf{x} = \\mathbf{b}$，其中矩阵 $A$ 和向量 $\\mathbf{b}$ 由下式给出：\n$$\nA = \\begin{pmatrix}\n4  1  -1 \\\\\n1  5  2 \\\\\n-1  2  6\n\\end{pmatrix}, \\quad \\mathbf{b} = \\begin{pmatrix}\n8 \\\\\n-3 \\\\\n1\n\\end{pmatrix}\n$$\n一个数值算法提供了一个近似解 $\\tilde{\\mathbf{x}}$：\n$$\n\\tilde{\\mathbf{x}} = \\begin{pmatrix}\n2.75 \\\\\n-1.60 \\\\\n1.15\n\\end{pmatrix}\n$$\n这个近似解 $\\tilde{\\mathbf{x}}$ 可以被认为是形式为 $A\\mathbf{x} = \\mathbf{b} + \\mathbf{\\delta b}$ 的扰动系统的精确解，其中 $\\mathbf{\\delta b}$ 是加到 $\\mathbf{b}$ 上的扰动向量。\n\n计算此扰动的相对大小，其定义为扰动向量 $\\mathbf{\\delta b}$ 的欧几里得范数与原始向量 $\\mathbf{b}$ 的欧几里得范数之比。将您的答案表示为一个实数，并四舍五入到四位有效数字。",
            "solution": "我们寻求扰动向量 $\\delta \\mathbf{b}$，使得 $A\\tilde{\\mathbf{x}}=\\mathbf{b}+\\delta \\mathbf{b}$，这意味着 $\\delta \\mathbf{b}=A\\tilde{\\mathbf{x}}-\\mathbf{b}$。相对大小定义为 $\\|\\delta \\mathbf{b}\\|_{2}/\\|\\mathbf{b}\\|_{2}$。\n\n通过将 $\\tilde{\\mathbf{x}}=\\begin{pmatrix}11/4 \\\\ -8/5 \\\\ 23/20\\end{pmatrix}$ 来精确计算 $A\\tilde{\\mathbf{x}}$：\n$$\nA\\tilde{\\mathbf{x}}=\n\\begin{pmatrix}\n4\\cdot \\frac{11}{4}+1\\cdot\\left(-\\frac{8}{5}\\right)-1\\cdot\\frac{23}{20} \\\\\n1\\cdot \\frac{11}{4}+5\\cdot\\left(-\\frac{8}{5}\\right)+2\\cdot\\frac{23}{20} \\\\\n-1\\cdot \\frac{11}{4}+2\\cdot\\left(-\\frac{8}{5}\\right)+6\\cdot\\frac{23}{20}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{33}{4} \\\\\n-\\frac{59}{20} \\\\\n\\frac{19}{20}\n\\end{pmatrix}\n$$\n因此，\n$$\n\\delta \\mathbf{b}=A\\tilde{\\mathbf{x}}-\\mathbf{b}\n=\n\\begin{pmatrix}\n\\frac{33}{4}-8 \\\\\n-\\frac{59}{20}-(-3) \\\\\n\\frac{19}{20}-1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{1}{4} \\\\\n\\frac{1}{20} \\\\\n-\\frac{1}{20}\n\\end{pmatrix}\n$$\n计算欧几里得范数：\n$$\n\\|\\delta \\mathbf{b}\\|_{2}=\\sqrt{\\left(\\frac{1}{4}\\right)^{2}+\\left(\\frac{1}{20}\\right)^{2}+\\left(-\\frac{1}{20}\\right)^{2}}\n=\\sqrt{\\frac{1}{16}+\\frac{1}{400}+\\frac{1}{400}}\n=\\sqrt{\\frac{27}{400}}\n=\\frac{3\\sqrt{3}}{20},\n$$\n$$\n\\|\\mathbf{b}\\|_{2}=\\sqrt{8^{2}+(-3)^{2}+1^{2}}=\\sqrt{64+9+1}=\\sqrt{74}\n$$\n因此，相对大小为\n$$\n\\frac{\\|\\delta \\mathbf{b}\\|_{2}}{\\|\\mathbf{b}\\|_{2}}=\\frac{\\frac{3\\sqrt{3}}{20}}{\\sqrt{74}}=\\frac{3\\sqrt{3}}{20\\sqrt{74}}\n$$\n数值上，\n$$\n\\frac{3\\sqrt{3}}{20\\sqrt{74}}\\approx 0.0302020226\\ldots\n$$\n四舍五入到四位有效数字，结果为 $0.03020$。",
            "answer": "$$\\boxed{0.03020}$$"
        },
        {
            "introduction": "对于那些矩阵元素尺度差异巨大或接近奇异的病态系统，即使是带主元分解的标准LU分解也可能得出不准确的结果。这个高级实践练习将挑战你编写一个程序，来探索一种名为“均衡”的预处理技术，它通过重新缩放方程组来改善其数值属性。通过比较使用和不使用均衡技术得到的解的精度，你将对如何处理病态问题以及计算实验在数值分析中的作用获得深刻的实践理解。",
            "id": "3199896",
            "problem": "您的任务是编写一个完整、可运行的程序，用于在元素尺度差异悬殊的矩阵上，比较使用和不使用对角平衡两种情况下，通过带部分主元法的 LU (Lower-Upper) 分解求解线性系统 $Ax = b$ 的数值稳定性。该研究必须基于基础数值分析：线性方程组 $Ax = b$ 的定义、基于电气和电子工程师协会 754 浮点（IEEE 754 FP）模型的浮点运算概念，以及成熟的矩阵范数和条件数概念。稳定性评估必须基于从第一性原理推导出的前向误差度量，而不是依赖简便公式。您的程序必须是自包含、可复现的，并符合下文描述的输出规范。\n\n背景与基础。一个线性方程组 $Ax = b$（其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $b \\in \\mathbb{R}^{n}$）在有限精度算术中进行计算求解。在 IEEE 754 FP 模型下，每次算术运算都会引入舍入误差，因此计算解 $\\hat{x}$ 通常与精确解 $x$ 不同。求解 $Ax = b$ 的数值方法的稳定性通过其前向误差来评估，通常使用向量 $2$-范数定义为 $\\frac{\\|\\hat{x} - x\\|_{2}}{\\|x\\|_{2}}$；其后向误差则通过相对残差 $\\frac{\\|A \\hat{x} - b\\|_{2}}{\\|b\\|_{2}}$ 来评估。带部分主元法的 LU 分解是求解 $Ax = b$ 的一种标准直接法。对角平衡是一种预处理步骤，它构造对角矩阵 $D_{r}$ 和 $D_{c}$ 分别对行和列进行缩放，形成平衡后的系统 $(D_{r} A D_{c}) y = D_{r} b$，并通过 $x = D_{c} y$ 将解映射回去。平衡旨在减小 $A$ 中元素的动态范围，从而在有限精度下减轻主元增长并提高数值稳定性。条件数 $\\kappa_{2}(A) = \\|A\\|_{2} \\|A^{-1}\\|_{2}$ 提供了衡量解对扰动敏感性的指标，但您的程序不得计算或依赖此量作为捷径；相反，它应直接比较两种方法获得的前向误差。\n\n您的任务。为 $Ax = b$ 实现两个求解器：\n- 一个使用不带任何平衡的、带部分主元法的 LU 分解的直接求解器。\n- 一个求解器，首先应用对角行缩放 $D_{r}$，然后应用对角列缩放 $D_{c}$，形成 $A_{\\text{hat}} = D_{r} A D_{c}$ 和 $b_{\\text{hat}} = D_{r} b$，通过带部分主元法的 LU 分解求解 $A_{\\text{hat}} y = b_{\\text{hat}}$，并返回 $x = D_{c} y$。\n\n使用以下经过充分测试的方法定义 $D_{r}$ 和 $D_{c}$：对于每一行 $i$，当最大值非零时，设置 $(D_{r})_{ii} = \\frac{1}{\\max_{j} |A_{ij}|}$，否则设置 $(D_{r})_{ii} = 1$；应用行缩放后，对于每一列 $j$，当最大值非零时，设置 $(D_{c})_{jj} = \\frac{1}{\\max_{i} |(D_{r} A)_{ij}|}$，否则设置 $(D_{c})_{jj} = 1$。\n\n稳定性度量。对于每个测试用例，通过设置 $b = A x_{\\text{true}}$ 使用已知的 $x_{\\text{true}}$ 构造 $b$。计算非平衡解 $\\hat{x}_{\\text{noeq}}$ 的前向误差为 $e_{\\text{noeq}} = \\frac{\\|\\hat{x}_{\\text{noeq}} - x_{\\text{true}}\\|_{2}}{\\|x_{\\text{true}}\\|_{2}}$，平衡解 $\\hat{x}_{\\text{eq}}$ 的前向误差为 $e_{\\text{eq}} = \\frac{\\|\\hat{x}_{\\text{eq}} - x_{\\text{true}}\\|_{2}}{\\|x_{\\text{true}}\\|_{2}}$。对于每个测试用例，以浮点数形式报告比率 $r = \\frac{e_{\\text{noeq}}}{e_{\\text{eq}}}$。$r  1$ 的值表示平衡改善了前向误差。\n\n计算环境。所有计算必须在双精度（64位）浮点运算中执行。此问题不涉及任何物理单位或角度单位。\n\n测试套件。使用固定的随机种子 $42$ 以确保可复现性。实现以下纯数学定义的测试用例：\n- 用例 1（悬殊的行和列尺度，方形随机矩阵）：设 $n = 40$。抽取一个元素为独立标准正态分布的矩阵 $A_{0} \\in \\mathbb{R}^{n \\times n}$。定义行尺度 $r_{i} = 10^{\\alpha_{i}}$ 和列尺度 $c_{j} = 10^{\\beta_{j}}$，其中 $(\\alpha_{i})_{i=1}^{n}$ 和 $(\\beta_{j})_{j=1}^{n}$ 是从 -8 到 8（含两端）的等距向量的随机排列。设置 $A = \\operatorname{diag}(r) \\, A_{0} \\, \\operatorname{diag}(c)$。抽取一个元素为独立标准正态分布的向量 $x_{\\text{true}} \\in \\mathbb{R}^{n}$ 并设置 $b = A x_{\\text{true}}$。\n- 用例 2（带有微小耦合的近奇异对角矩阵）：设 $n = 25$。定义对角元素 $d_{i} = 10^{\\gamma_{i}}$，其中 $(\\gamma_{i})_{i=1}^{n}$ 是从 -12 到 0 的等距序列。设置 $A = \\operatorname{diag}(d) + \\delta$，其中 $\\delta$ 的元素为乘以 $10^{-12}$ 的独立标准正态分布。抽取一个标准正态分布的 $x_{\\text{true}}$ 并设置 $b = A x_{\\text{true}}$。\n- 用例 3（平衡的正交矩阵）：设 $n = 40$。抽取一个元素为独立标准正态分布的矩阵 $M \\in \\mathbb{R}^{n \\times n}$，并计算其 QR 分解 $M = Q R$，其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵。设置 $A = Q$。抽取一个标准正态分布的 $x_{\\text{true}}$ 并设置 $b = A x_{\\text{true}}$。\n- 用例 4（带列缩放的希尔伯特矩阵）：设 $n = 12$。定义希尔伯特矩阵 $H \\in \\mathbb{R}^{n \\times n}$，其元素为 $H_{ij} = \\frac{1}{i + j - 1}$。定义列尺度 $c_{j} = 10^{j - 1}$。设置 $A = H \\, \\operatorname{diag}(c)$。抽取一个标准正态分布的 $x_{\\text{true}}$ 并设置 $b = A x_{\\text{true}}$。\n- 用例 5（带有耦合的双尺度分块矩阵）：设 $n_{1} = 15$, $n_{2} = 15$，且 $n = n_{1} + n_{2} = 30$。分别抽取大小为 $n_{1} \\times n_{1}$ 和 $n_{2} \\times n_{2}$ 的、元素为独立标准正态分布的矩阵 $A_{1}, A_{2}$。设置 $\\tilde{A}_{1} = 10^{-9} A_{1}$ 和 $\\tilde{A}_{2} = 10^{9} A_{2}$。构成块对角矩阵 $B = \\operatorname{diag}(\\tilde{A}_{1}, \\tilde{A}_{2})$。抽取一个大小为 $n \\times n$ 的、元素为乘以 $10^{-3}$ 的独立标准正态分布的耦合矩阵 $C$，并设置 $A = B + C$。抽取一个标准正态分布的 $x_{\\text{true}}$ 并设置 $b = A x_{\\text{true}}$。\n\n答案规范。对于每个用例，计算比率 $r = \\frac{e_{\\text{noeq}}}{e_{\\text{eq}}}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 1 到 5 的顺序排列。每个比率必须以六位有效数字的科学记数法打印（例如，$[1.234560\\mathrm{e}{+02},3.210000\\mathrm{e}{-05}]$）。该行必须只包含列表，不得有任何额外文本。",
            "solution": "该问题要求对求解线性方程组 $Ax = b$ 的数值稳定性进行比较分析，使用两种不同的方法：带部分主元法的直接 LU 分解，以及在应用了特定的对角平衡预处理步骤后使用相同方法。分析将在五个测试矩阵上进行，这些矩阵旨在展现出对数值求解器构成挑战的特性，如不良缩放或病态。整个研究必须在双精度浮点运算的框架内进行。\n\n所研究的基本原理是，求解线性系统的数值算法的稳定性可能对矩阵 $A$ 的性质高度敏感。在有限精度算术（如指定的 IEEE 754 64位标准）中，舍入误差会累积，并严重降低计算解 $\\hat{x}$ 的准确性。平衡是一种旨在减轻此类影响的预处理技术。\n\n问题为给定的系统 $Ax = b$（其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $b \\in \\mathbb{R}^{n}$）指定了两种求解路径。对于每个测试用例，使用一个已知的真解 $x_{\\text{true}}$ 来构造右侧向量 $b = Ax_{\\text{true}}$。计算解 $\\hat{x}$ 的准确性则通过相对前向误差来量化，该误差由向量 $2$-范数定义为 $e = \\frac{\\|\\hat{x} - x_{\\text{true}}\\|_{2}}{\\|x_{\\text{true}}\\|_{2}}$。\n\n两种计算方法如下：\n1.  **不使用平衡**：直接求解系统 $Ax = b$。我们使用 `scipy.linalg.lu_factor` 和 `scipy.linalg.lu_solve` 函数中实现的带部分主元法的 LU 分解来求得计算解 $\\hat{x}_{\\text{noeq}}$。相应的前向误差为 $e_{\\text{noeq}} = \\frac{\\|\\hat{x}_{\\text{noeq}} - x_{\\text{true}}\\|_{2}}{\\|x_{\\text{true}}\\|_{2}}$。\n\n2.  **使用平衡**：在求解前对系统进行预处理。这涉及构造两个对角矩阵：行缩放矩阵 $D_{r}$ 和列缩放矩阵 $D_{c}$。根据问题规范，它们的对角元素是顺序定义的。首先，对于每一行 $i$，如果最大值非零，则 $(D_{r})_{ii} = (\\max_{j} |A_{ij}|)^{-1}$，否则 $(D_{r})_{ii} = 1$。在概念上应用此行缩放后，确定列缩放。对于每一列 $j$，如果最大值非零，则 $(D_{c})_{jj} = (\\max_{i} |(D_{r}A)_{ij}|)^{-1}$，否则 $(D_{c})_{jj} = 1$。\n这将原始系统 $Ax = b$ 转换为平衡后的系统 $(D_{r} A D_{c}) y = D_{r} b$。我们记 $A_{\\text{hat}} = D_{r} A D_{c}$ 和 $b_{\\text{hat}} = D_{r} b$。我们使用相同的带部分主元法的 LU 分解方法求解 $A_{\\text{hat}} y = b_{\\text{hat}}$ 以得到 $y$。然后通过关系 $x = D_{c} y$ 恢复原始系统的解。设此计算解为 $\\hat{x}_{\\text{eq}}$。相应的前向误差为 $e_{\\text{eq}} = \\frac{\\|\\hat{x}_{\\text{eq}} - x_{\\text{true}}\\|_{2}}{\\|x_{\\text{true}}\\|_{2}}$。\n\n比较度量是这些前向误差的比率：$r = \\frac{e_{\\text{noeq}}}{e_{\\text{eq}}}$。$r  1$ 的值表示平衡过程提高了计算解的准确性。\n\n实现将首先定义函数以按规定构造五个测试用例。固定的随机种子 42 确保了可复现性。程序的核心是一个函数，它接受一个矩阵 $A$ 和一个真解 $x_{\\text{true}}$，计算 $b$，使用两种方法求解系统，计算各自的前向误差，并返回它们的比率。然后将此函数应用于五个测试用例中的每一个。所有矩阵和向量操作，包括随机数生成和范数计算，都使用 `numpy` 库执行。LU 分解和求解器来自 `scipy.linalg` 包，因为这一选择明确提供了对所需算法的访问。最终结果被格式化为具有六位有效数字的科学记数法，并作为单个逗号分隔的列表打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    def get_error_ratio(A: np.ndarray, x_true: np.ndarray) - float:\n        \"\"\"\n        Computes the ratio of forward errors for solving Ax=b with and without\n        equilibration.\n\n        Args:\n            A: The matrix of the linear system.\n            x_true: The known true solution.\n\n        Returns:\n            The ratio e_noeq / e_eq.\n        \"\"\"\n        # Ensure all computations are done in double precision.\n        A = np.array(A, dtype=np.float64)\n        x_true = np.array(x_true, dtype=np.float64)\n\n        # Construct b from the known x_true. This is done in finite precision.\n        b = A @ x_true\n        \n        norm_x_true = np.linalg.norm(x_true, 2)\n        if norm_x_true == 0:\n            # This should not happen with the given test cases.\n            return np.nan\n\n        # Method 1: Solve Ax=b without equilibration.\n        try:\n            lu, piv = linalg.lu_factor(A)\n            x_noeq = linalg.lu_solve((lu, piv), b)\n            e_noeq = np.linalg.norm(x_noeq - x_true, 2) / norm_x_true\n        except np.linalg.LinAlgError:\n            e_noeq = np.inf\n\n\n        # Method 2: Solve Ax=b with diagonal equilibration.\n        n = A.shape[0]\n\n        # Construct row scaling matrix Dr.\n        dr_diag = np.ones(n, dtype=np.float64)\n        row_maxs = np.max(np.abs(A), axis=1)\n        nonzero_rows = row_maxs  0\n        dr_diag[nonzero_rows] = 1.0 / row_maxs[nonzero_rows]\n        Dr = np.diag(dr_diag)\n\n        # Apply row scaling.\n        A_prime = Dr @ A\n\n        # Construct column scaling matrix Dc.\n        dc_diag = np.ones(n, dtype=np.float64)\n        col_maxs = np.max(np.abs(A_prime), axis=0)\n        nonzero_cols = col_maxs  0\n        dc_diag[nonzero_cols] = 1.0 / col_maxs[nonzero_cols]\n        Dc = np.diag(dc_diag)\n\n        # Form the equilibrated system.\n        A_hat = A_prime @ Dc\n        b_hat = Dr @ b\n\n        # Solve the equilibrated system for y.\n        try:\n            lu_hat, piv_hat = linalg.lu_factor(A_hat)\n            y_hat = linalg.lu_solve((lu_hat, piv_hat), b_hat)\n\n            # Map the solution y back to x.\n            x_eq = Dc @ y_hat\n            e_eq = np.linalg.norm(x_eq - x_true, 2) / norm_x_true\n        except np.linalg.LinAlgError:\n            e_eq = np.inf\n\n        # Compute the ratio of forward errors.\n        if e_eq == 0:\n            return np.inf if e_noeq  0 else 1.0\n            \n        return e_noeq / e_eq\n\n    def generate_test_cases():\n        \"\"\"\n        Generates the five test cases as specified in the problem statement.\n        \"\"\"\n        rng = np.random.default_rng(42)\n        test_cases = []\n\n        # Case 1: Wild row and column scales\n        n = 40\n        A0 = rng.standard_normal(size=(n, n))\n        alphas = rng.permutation(np.linspace(-8, 8, num=n))\n        betas = rng.permutation(np.linspace(-8, 8, num=n))\n        r = 10.0**alphas\n        c = 10.0**betas\n        A1 = np.diag(r) @ A0 @ np.diag(c)\n        x_true1 = rng.standard_normal(size=n)\n        test_cases.append((A1, x_true1))\n\n        # Case 2: Nearly singular diagonal with tiny coupling\n        n = 25\n        gammas = np.linspace(-12, 0, num=n)\n        d = 10.0**gammas\n        A2 = np.diag(d) + 1e-12 * rng.standard_normal(size=(n, n))\n        x_true2 = rng.standard_normal(size=n)\n        test_cases.append((A2, x_true2))\n\n        # Case 3: Balanced orthogonal matrix\n        n = 40\n        M = rng.standard_normal(size=(n, n))\n        Q, _ = np.linalg.qr(M)\n        A3 = Q\n        x_true3 = rng.standard_normal(size=n)\n        test_cases.append((A3, x_true3))\n\n        # Case 4: Hilbert matrix with column scaling\n        n = 12\n        i_indices = np.arange(1, n + 1).reshape(n, 1)\n        j_indices = np.arange(1, n + 1).reshape(1, n)\n        H = 1.0 / (i_indices + j_indices - 1)\n        c_diag = 10.0**np.arange(n)\n        A4 = H @ np.diag(c_diag)\n        x_true4 = rng.standard_normal(size=n)\n        test_cases.append((A4, x_true4))\n\n        # Case 5: Two-scale block matrix with coupling\n        n1, n2 = 15, 15\n        n = n1 + n2\n        A1_block = rng.standard_normal(size=(n1, n1))\n        A2_block = rng.standard_normal(size=(n2, n2))\n        B = np.zeros((n, n), dtype=np.float64)\n        B[:n1, :n1] = 1e-9 * A1_block\n        B[n1:, n1:] = 1e9 * A2_block\n        C = 1e-3 * rng.standard_normal(size=(n, n))\n        A5 = B + C\n        x_true5 = rng.standard_normal(size=n)\n        test_cases.append((A5, x_true5))\n        \n        return test_cases\n\n    test_cases = generate_test_cases()\n    results = []\n    for A, x_true in test_cases:\n        ratio = get_error_ratio(A, x_true)\n        results.append(ratio)\n    \n    # Format results as specified\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}