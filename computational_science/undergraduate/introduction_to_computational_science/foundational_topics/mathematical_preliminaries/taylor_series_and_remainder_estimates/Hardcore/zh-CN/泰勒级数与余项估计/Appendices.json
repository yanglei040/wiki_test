{
    "hands_on_practices": [
        {
            "introduction": "这个练习将一个熟悉的几何概念——椭圆的面积——与泰勒级数联系起来。我们将以偏心率 $e$ 为变量，探究当一个椭圆从一个完美的圆形发生轻微变形时，其面积是如何变化的。对于更复杂的公式，这是一个很好的起点，展示了如何运用泰勒多项式来创建简单而有效的近似模型 。",
            "id": "2442188",
            "problem": "考虑由隐式方程 $x^{2}/a^{2} + y^{2}/b^{2} = 1$ 定义的椭圆，其半长轴为 $a0$，半短轴为 $b0$，离心率 $e \\in [0,1)$ 定义为 $e = \\sqrt{1 - b^{2}/a^{2}}$。椭圆的面积 $A(e)$ 可以使用积分求面积公式写为\n$$\nA(e) = 4 \\int_{0}^{a} b \\sqrt{1 - \\frac{x^{2}}{a^{2}}} \\, dx,\n$$\n其中 $b = a \\sqrt{1 - e^{2}}$。\n\n将 $A(e)$ 视为 $e$ 的函数。求 $A(e)$ 在 $e=0$ 处的四阶泰勒多项式 $T_{4}(e)$，结果纯粹用 $a$、$\\pi$ 和 $e$ 表示。最终答案以单一闭合形式表达式给出。不要对答案进行四舍五入，且不包括单位。",
            "solution": "首先，我们必须严格验证问题陈述。\n\n第 1 步：提取已知条件\n问题提供了以下信息：\n- 椭圆隐式方程：$\\frac{x^{2}}{a^{2}} + \\frac{y^{2}}{b^{2}} = 1$。\n- 半长轴：$a  0$。\n- 半短轴：$b  0$。\n- 离心率：$e \\in [0,1)$，定义为 $e = \\sqrt{1 - \\frac{b^{2}}{a^{2}}}$。\n- 面积作为离心率的函数 $A(e)$：$A(e) = 4 \\int_{0}^{a} b \\sqrt{1 - \\frac{x^{2}}{a^{2}}} \\, dx$。\n- $b$与$e$的关系：$b = a \\sqrt{1 - e^{2}}$。\n- 目标：求 $A(e)$ 在 $e=0$ 处的四阶泰勒多项式 $T_{4}(e)$，用 $a$、$\\pi$ 和 $e$ 表示。\n\n第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题进行验证。\n- **科学上合理**：该问题基于欧几里得几何以及微积分学的标准、公认原理。椭圆、其离心率和面积的定义都是正确和标准的。\n- **适定性**：函数 $A(e)$ 在 $e \\in [0,1)$ 上是良定义的且无穷可微，确保在 $e=0$ 处存在唯一的任意阶泰勒多项式。目标陈述清晰。\n- **客观性**：问题以精确的数学语言陈述，没有歧义或主观解释。\n- **一致性**：给定的关系 $b = a \\sqrt{1-e^2}$ 是离心率定义的直接推论。面积的积分公式也是正确的。我们可以验证这一点：将 $b = a\\sqrt{1-e^2}$ 代入面积公式，得到 $A(e) = 4a\\sqrt{1-e^2} \\int_0^a \\sqrt{1-x^2/a^2} dx$。积分 $\\int_0^a \\sqrt{1-x^2/a^2} dx = \\frac{1}{a} \\int_0^a \\sqrt{a^2-x^2} dx$ 是半径为 $a$ 的四分之一圆面积的 $\\frac{1}{a}$ 倍，即 $\\frac{1}{a} (\\frac{\\pi a^2}{4}) = \\frac{\\pi a}{4}$。因此，$A(e) = 4a\\sqrt{1-e^2} (\\frac{\\pi a}{4}) = \\pi a^2 \\sqrt{1-e^2}$。这恰好是 $\\pi ab$，即椭圆的正确面积。问题是内部一致的。\n- **完备性**：提供了解决问题所需的所有必要信息。\n\n第 3 步：结论与行动\n该问题被认为是科学上合理、适定、客观且自洽的。没有任何缺陷。因此，该问题是**有效的**。我们开始求解。\n\n椭圆的面积作为离心率 $e$ 的函数，由 $A(e) = \\pi a^{2} \\sqrt{1 - e^{2}}$ 给出。为了求 $A(e)$ 在 $e=0$ 处的四阶泰勒多项式 $T_{4}(e)$，我们需要 $A(e)$ 的麦克劳林级数展开式，直到 $e^4$ 阶项。\n\n最直接的方法是使用关于 $(1+u)^{\\alpha}$ 的广义二项式定理，其表述为：\n$$\n(1+u)^{\\alpha} = \\sum_{k=0}^{\\infty} \\binom{\\alpha}{k} u^{k} = 1 + \\alpha u + \\frac{\\alpha(\\alpha-1)}{2!}u^{2} + \\frac{\\alpha(\\alpha-1)(\\alpha-2)}{3!}u^{3} + \\dots\n$$\n该级数在 $|u|  1$ 时收敛。\n\n我们的函数是 $A(e) = \\pi a^{2} (1 - e^{2})^{\\frac{1}{2}}$。我们确定 $\\alpha = \\frac{1}{2}$ 且 $u = -e^{2}$。由于展开式是关于 $e=0$ 的，且问题指定 $e \\in [0,1)$，条件 $|u| = |-e^2| = e^2  1$ 被满足。\n\n我们将项 $(1 - e^{2})^{\\frac{1}{2}}$ 展开到包含 $e^4$ 的项。这需要二项式级数中 $k=0, 1, 2$ 的项。\n当 $k=0$ 时：\n$$\n\\binom{\\frac{1}{2}}{0} (-e^{2})^{0} = 1 \\cdot 1 = 1\n$$\n当 $k=1$ 时：\n$$\n\\binom{\\frac{1}{2}}{1} (-e^{2})^{1} = \\frac{1}{2} (-e^{2}) = -\\frac{1}{2} e^{2}\n$$\n当 $k=2$ 时：\n$$\n\\binom{\\frac{1}{2}}{2} (-e^{2})^{2} = \\frac{(\\frac{1}{2})(\\frac{1}{2}-1)}{2!} (e^{4}) = \\frac{(\\frac{1}{2})(-\\frac{1}{2})}{2} e^{4} = -\\frac{1}{8} e^{4}\n$$\n级数中的下一项（当 $k=3$ 时）将包含 $(-e^2)^3 = -e^6$，其阶数高于 $T_{4}(e)$ 所要求的阶数。\n\n结合这些项，平方根项的展开式为：\n$$\n(1 - e^{2})^{\\frac{1}{2}} = 1 - \\frac{1}{2} e^{2} - \\frac{1}{8} e^{4} + O(e^{6})\n$$\n四阶泰勒多项式是通过在 $e^4$ 项后截断级数得到的。我们将此多项式乘以常数因子 $\\pi a^{2}$：\n$$\nT_{4}(e) = \\pi a^{2} \\left( 1 - \\frac{1}{2} e^{2} - \\frac{1}{8} e^{4} \\right)\n$$\n这就是所求的椭圆面积作为其离心率函数、以 $e=0$ 为中心的四阶泰勒多项式。",
            "answer": "$$\n\\boxed{\\pi a^{2} \\left(1 - \\frac{1}{2} e^{2} - \\frac{1}{8} e^{4}\\right)}\n$$"
        },
        {
            "introduction": "泰勒级数提供了绝佳的*局部*近似，但其精度在远离展开中心时会迅速下降。本练习要求你比较在 $x=\\pi$ 附近对 $\\sin(x)$ 函数的两种近似，这两种近似分别使用两个不同的展开中心：一个局部中心（$a=\\pi$）和一个远距离中心（$a=0$）。通过分析结果，你将更深刻地理解选择合适展开点的重要性，并学会如何利用对称性等函数性质来简化问题 。",
            "id": "3200380",
            "problem": "在计算实践中，人们经常在某个感兴趣的点附近，用一个低阶泰勒多项式来代替一个光滑函数，以获得一个带有可量化余项（误差）的快速局部近似。考虑函数 $f(x) = \\sin(x)$ 和两个中心点：$a = \\pi$ 和 $a = 0$。令 $p^{(a)}_n(x)$ 表示函数 $f$ 在 $x=a$ 处的 $n$ 阶泰勒多项式。定义区间 $I = [\\pi - 0.1, \\,\\pi + 0.1]$。\n\n仅使用泰勒多项式的定义、带有拉格朗日余项的泰勒定理、正弦函数的周期性和对称性以及导数的界，判断下列哪些陈述是正确的。选择所有适用的选项。\n\nA. 对于所有 $x \\in I$，在 $a=\\pi$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。\n\nB. 对于所有 $x \\in I$，在 $a=0$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(0)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。\n\nC. 记 $x = \\pi + h$，其中 $\\lvert h \\rvert \\le 0.1$，恒等式 $\\sin(x) = -\\sin(h)$ 意味着两个线性化在平移后是一致的，即 $p^{(\\pi)}_1(\\pi + h) = -\\,p^{(0)}_1(h)$。\n\nD. 使用相同的变量代换 $x=\\pi+h$，对于任意固定的整数 $n \\ge 0$ 且 $\\lvert h \\rvert$ 足够小，$\\sin(x)$ 在 $a=\\pi$ 处的 $n$ 阶泰勒近似在 $x=\\pi+h$ 的余项，与 $-\\sin(h)$ 在 $h=0$ 处的 $n$ 阶泰勒近似在 $h$ 的余项具有相同的绝对值。因此，为 $\\sin$ 的麦克劳林余项得到的任何绝对值界都可以直接转移到在 $a=\\pi$ 处的展开。\n\nE. 在区间 $I$ 上，在 $a=\\pi$ 处的一阶泰勒近似的最大绝对误差至多为 $0.005$，而在 $a=0$ 处的一阶泰勒近似的最大绝对误差超过 $3.0$。\n\nF. 因为 $\\sin(\\pi) = 0$，所以在泰勒多项式的意义下，常数多项式 $p(x) \\equiv 0$ 是在 $a=\\pi$ 处的最佳线性化。\n\nG. 对于 $a \\in \\{0,\\pi\\}$，一阶泰勒近似的误差的真实最低阶行为是关于与 $a$ 的位移的三次函数；也就是说，记 $h=x-a$，当 $h$ 很小时，误差表现为 $C\\,h^3$（对于某个非零常数 $C$），尽管基于二阶导数的一般余项界只给出了一个二次上界。",
            "solution": "问题陈述已经过验证，并且在科学上是合理的、良定的、客观的，并包含评估给定陈述所需的所有必要信息。\n\n所考虑的函数是 $f(x) = \\sin(x)$。其导数为 $f'(x) = \\cos(x)$，$f''(x) = -\\sin(x)$，$f'''(x) = -\\cos(x)$，依此类推。一个关键性质是，对于任意整数 $k \\ge 0$，$k$ 阶导数 $f^{(k)}(x)$ 的绝对值以 1 为界，即对于所有 $x \\in \\mathbb{R}$，$\\lvert f^{(k)}(x) \\rvert \\le 1$。\n\n函数 $f$ 在中心点 $x=a$ 处的 $n$ 阶泰勒多项式由 $p_n^{(a)}(x) = \\sum_{k=0}^n \\dfrac{f^{(k)}(a)}{k!}(x-a)^k$ 给出。\n余项或误差为 $R_n^{(a)}(x) = f(x) - p_n^{(a)}(x)$。带有拉格朗日余项的泰勒定理指出，$R_n^{(a)}(x) = \\dfrac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}$，其中 $c$ 是介于 $a$ 和 $x$ 之间的某个值。\n这给出了误差绝对值的一个界：$\\lvert R_n^{(a)}(x) \\rvert \\le \\dfrac{M_{n+1}}{(n+1)!}\\lvert x-a \\rvert^{n+1}$，其中 $M_{n+1}$ 是当 $t$ 介于 $a$ 和 $x$ 之间时 $\\lvert f^{(n+1)}(t) \\rvert$ 的一个上界。对于 $f(x) = \\sin(x)$，我们对任意 $k$ 始终可以使用 $M_k=1$。\n\n感兴趣的区间是 $I = [\\pi - 0.1, \\,\\pi + 0.1]$。对于任意 $x \\in I$，与 $a=\\pi$ 的位移为 $\\lvert x-\\pi \\rvert \\le 0.1$。\n\n**A. 对于所有 $x \\in I$，在 $a=\\pi$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。**\n\n在 $a=\\pi$ 处的一阶泰勒近似是 $p^{(\\pi)}_1(x) = f(\\pi) + f'(\\pi)(x-\\pi)$。\n我们有 $f(\\pi) = \\sin(\\pi) = 0$ 和 $f'(\\pi) = \\cos(\\pi) = -1$。\n所以，$p^{(\\pi)}_1(x) = 0 + (-1)(x-\\pi) = \\pi - x$。\n误差是余项 $R_1^{(\\pi)}(x) = \\sin(x) - p^{(\\pi)}_1(x)$。\n使用 $n=1$ 和 $a=\\pi$ 的拉格朗日余项形式：\n$$R_1^{(\\pi)}(x) = \\dfrac{f''(c)}{2!}(x-\\pi)^2 = \\dfrac{-\\sin(c)}{2}(x-\\pi)^2$$\n其中 $c$ 介于 $\\pi$ 和 $x$ 之间。\n误差的绝对值是 $\\lvert R_1^{(\\pi)}(x) \\rvert = \\left\\lvert \\dfrac{-\\sin(c)}{2}(x-\\pi)^2 \\right\\rvert = \\dfrac{\\lvert \\sin(c) \\rvert}{2}(x-\\pi)^2$。\n我们可以使用一般界 $\\lvert \\sin(c) \\rvert \\le 1$。\n对于 $x \\in I$，我们有 $\\lvert x-\\pi \\rvert \\le 0.1$。\n代入这些界，我们得到：\n$$\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{1}{2}(\\lvert x-\\pi \\rvert)^2 \\le \\dfrac{1}{2}(0.1)^2$$\n该陈述是泰勒余项定理的直接应用。\n\n结论：**正确**。\n\n**B. 对于所有 $x \\in I$，在 $a=0$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(0)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。**\n\n在 $a=0$ 处的一阶泰勒近似（麦克劳林多项式）是 $p^{(0)}_1(x) = f(0) + f'(0)(x-0)$。\n我们有 $f(0)=\\sin(0)=0$ 和 $f'(0)=\\cos(0)=1$。所以，$p^{(0)}_1(x) = x$。\n误差是 $\\lvert \\sin(x) - x \\rvert$。$x$ 的区间是 $I = [\\pi-0.1, \\pi+0.1]$。\n所给不等式中的表达式 $\\dfrac{(0.1)^2}{2}$ 表明应用了余项定理，其中与中心的距离至多为 $0.1$。展开中心是 $a=0$。对于 $x \\in I$，与中心的距离是 $\\lvert x-a \\rvert = \\lvert x-0 \\rvert = x$，约等于 $\\pi \\approx 3.14159$。这个值远大于 $0.1$。\n让我们计算在 $x=\\pi \\in I$ 处的误差。\n误差 = $\\lvert \\sin(\\pi) - \\pi \\rvert = \\lvert 0 - \\pi \\rvert = \\pi \\approx 3.14159$。\n所给的界是 $\\dfrac{(0.1)^2}{2} = \\dfrac{0.01}{2} = 0.005$。\n显然，$\\pi  0.005$。该陈述是错误的。对于接近 $\\pi$ 的 $x$，近似 $p^{(0)}_1(x)=x$ 非常差。\n\n结论：**错误**。\n\n**C. 记 $x = \\pi + h$，其中 $\\lvert h \\rvert \\le 0.1$，恒等式 $\\sin(x) = -\\sin(h)$ 意味着两个线性化在平移后是一致的，即 $p^{(\\pi)}_1(\\pi + h) = -\\,p^{(0)}_1(h)$。**\n\n让我们计算所提等式的两边。\n左边：根据分析A，在 $a=\\pi$ 处的线性化是 $p^{(\\pi)}_1(x) = \\pi - x$。\n代入 $x = \\pi + h$，我们得到 $p^{(\\pi)}_1(\\pi+h) = \\pi - (\\pi+h) = -h$。\n右边：首先，我们需要函数 $f(y)=\\sin(y)$ 在 $y=0$ 处的线性化。根据分析B，这等于 $p^{(0)}_1(y)=y$。\n因此表达式 $-p^{(0)}_1(h)$ 就是 $-h$。\n由于左边和右边都等于 $-h$，等式 $p^{(\\pi)}_1(\\pi + h) = -\\,p^{(0)}_1(h)$ 对任意 $h$ 都成立。\n\n结论：**正确**。\n\n**D. 使用相同的变量代换 $x=\\pi+h$，对于任意固定的整数 $n \\ge 0$ 且 $\\lvert h \\rvert$ 足够小，$\\sin(x)$ 在 $a=\\pi$ 处的 $n$ 阶泰勒近似在 $x=\\pi+h$ 的余项，与 $-\\sin(h)$ 在 $h=0$ 处的 $n$ 阶泰勒近似在 $h$ 的余项具有相同的绝对值。因此，为 $\\sin$ 的麦克劳林余项得到的任何绝对值界都可以直接转移到在 $a=\\pi$ 处的展开。**\n\n令 $g(x) = \\sin(x)$ 且 $f(h) = -\\sin(h)$。我们比较 $g(x)$ 在 $a=\\pi$ 处的泰勒展开和 $f(h)$ 在 $a=0$ 处的泰勒展开。\n$g(x)$ 在 $x=\\pi$ 处的泰勒系数由 $g^{(k)}(\\pi)$ 给出。\n$f(h)$ 在 $h=0$ 处的泰勒系数由 $f^{(k)}(0)$ 给出。\n让我们比较这些导数。使用链式法则和三角恒等式：\n$g^{(k)}(x) = \\dfrac{d^k}{dx^k}\\sin(x) = \\sin(x + k\\pi/2)$。在 $x=\\pi$ 处，$g^{(k)}(\\pi) = \\sin(\\pi + k\\pi/2) = \\sin(\\pi)\\cos(k\\pi/2) + \\cos(\\pi)\\sin(k\\pi/2) = -\\sin(k\\pi/2)$。\n$f^{(k)}(h) = \\dfrac{d^k}{dh^k}(-\\sin(h)) = -\\sin(h + k\\pi/2)$。在 $h=0$ 处，$f^{(k)}(0) = -\\sin(k\\pi/2)$。\n所以，$g^{(k)}(\\pi) = f^{(k)}(0)$ 对所有整数 $k \\ge 0$ 成立。\n$g(x)$ 在 $a=\\pi$ 处的泰勒多项式，在 $x=\\pi+h$ 处的值为 $p_{g,n}^{(\\pi)}(\\pi+h) = \\sum_{k=0}^n \\frac{g^{(k)}(\\pi)}{k!} h^k$。\n$f(h)$ 在 $a=0$ 处的泰勒多项式，在 $h$ 处的值为 $p_{f,n}^{(0)}(h) = \\sum_{k=0}^n \\frac{f^{(k)}(0)}{k!} h^k$。\n由于系数相同，多项式也相同：$p_{g,n}^{(\\pi)}(\\pi+h) = p_{f,n}^{(0)}(h)$。\n现在我们研究余项。\n$g(x)$ 的余项是 $R_{g,n}^{(\\pi)}(\\pi+h) = g(\\pi+h) - p_{g,n}^{(\\pi)}(\\pi+h) = \\sin(\\pi+h) - p_{g,n}^{(\\pi)}(\\pi+h)$。使用恒等式 $\\sin(\\pi+h)=-\\sin(h)$，这变成 $-\\sin(h) - p_{g,n}^{(\\pi)}(\\pi+h)$。\n$f(h)$ 的余项是 $R_{f,n}^{(0)}(h) = f(h) - p_{f,n}^{(0)}(h) = -\\sin(h) - p_{f,n}^{(0)}(h)$。\n由于多项式相等，余项也相等：$R_{g,n}^{(\\pi)}(\\pi+h) = R_{f,n}^{(0)}(h)$。\n因此，它们的绝对值相等：$\\lvert R_{g,n}^{(\\pi)}(\\pi+h) \\rvert = \\lvert R_{f,n}^{(0)}(h) \\rvert$。\n$f(h)=-\\sin(h)$ 的余项恰好是 $\\sin(h)$ 的余项的相反数，所以它们的绝对值相同。这意味着 $\\sin(h)$ 的麦克劳林余项的界也是 $\\sin(x)$ 在 $\\pi$ 处展开的余项的界。\n\n结论：**正确**。\n\n**E. 在区间 $I$ 上，在 $a=\\pi$ 处的一阶泰勒近似的最大绝对误差至多为 $0.005$，而在 $a=0$ 处的一阶泰勒近似的最大绝对误差超过 $3.0$。**\n\n第一部分：$a=\\pi$ 的最大误差。\n根据分析A，对于任意 $x \\in I$，误差满足 $\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{1}{2}(0.1)^2 = 0.005$。因此，最大绝对误差至多为 $0.005$。这部分是正确的。\n\n第二部分：$a=0$ 的最大误差。\n误差是 $\\lvert \\sin(x) - p^{(0)}_1(x) \\rvert = \\lvert \\sin(x) - x \\rvert$，其中 $x \\in I = [\\pi-0.1, \\pi+0.1]$。因为在此区间内 $x0$，我们有 $x  \\sin(x)$，所以误差是 $x - \\sin(x)$。\n令 $E(x) = x-\\sin(x)$。其导数是 $E'(x) = 1-\\cos(x)$。对于 $x \\in I$，$x$ 接近 $\\pi$，所以 $\\cos(x)$ 接近 -1。因此 $E'(x) = 1-\\cos(x)  0$。误差函数 $E(x)$ 在 $I$ 上是严格递增的。\n最大误差将出现在区间的右端点，$x = \\pi+0.1$。\n最大误差 = $(\\pi+0.1) - \\sin(\\pi+0.1) = \\pi + 0.1 - (-\\sin(0.1)) = \\pi + 0.1 + \\sin(0.1)$。\n使用近似值 $\\pi \\approx 3.14159$ 和 $\\sin(0.1) \\approx 0.09983$：\n最大误差 $\\approx 3.14159 + 0.1 + 0.09983 = 3.34142$。\n由于 $3.34142  3.0$，最大绝对误差确实超过了 $3.0$。陈述的两个部分都为真。\n\n结论：**正确**。\n\n**F. 因为 $\\sin(\\pi) = 0$，所以在泰勒多项式的意义下，常数多项式 $p(x) \\equiv 0$ 是在 $a=\\pi$ 处的最佳线性化。**\n\n在泰勒级数的语境下，“最佳线性化”是指一阶泰勒多项式，$p_1^{(a)}(x)$。\n根据分析A，在 $a=\\pi$ 处的线性化是 $p_1^{(\\pi)}(x) = \\pi - x$。这是一个非常数多项式。\n多项式 $p(x) \\equiv 0$ 是零阶泰勒多项式，$p_0^{(\\pi)}(x) = \\sin(\\pi) = 0$。这是在 $x=\\pi$ 附近最好的*常数*近似，但“线性化”意味着一阶多项式，它要考虑函数的斜率。$\\sin(x)$ 在 $x=\\pi$ 处的斜率是 $\\cos(\\pi)=-1$，这是非零的。因此，最佳线性近似不是一个常数函数。\n\n结论：**错误**。\n\n**G. 对于 $a \\in \\{0,\\pi\\}$，一阶泰勒近似的误差的真实最低阶行为是关于与 $a$ 的位移的三次函数；也就是说，记 $h=x-a$，当 $h$ 很小时，误差表现为 $C\\,h^3$（对于某个非零常数 $C$），尽管基于二阶导数的一般余项界只给出了一个二次上界。**\n\n一阶泰勒近似的误差是 $R_1^{(a)}(x) = f(x) - p_1^{(a)}(x)$。\n泰勒级数可以扩展到更高阶：$f(x) = p_1^{(a)}(x) + \\dfrac{f''(a)}{2!}(x-a)^2 + \\dfrac{f'''(a)}{3!}(x-a)^3 + \\dots$\n所以，误差是 $R_1^{(a)}(x) = \\dfrac{f''(a)}{2!}(x-a)^2 + \\dfrac{f'''(a)}{3!}(x-a)^3 + \\dots$\n\n让我们检查当 $a \\in \\{0, \\pi\\}$ 时 $f''(a)$ 的值。二阶导数是 $f''(x) = -\\sin(x)$。\n对于 $a=0$，$f''(0) = -\\sin(0) = 0$。\n对于 $a=\\pi$，$f''(\\pi) = -\\sin(\\pi) = 0$。\n在这两种情况下，$(x-a)^2$ 项的系数为零。\n这意味着误差的最低阶项是 $(x-a)^3$ 项。\n$R_1^{(a)}(x) = \\dfrac{f'''(a)}{3!}(x-a)^3 + \\dfrac{f^{(4)}(a)}{4!}(x-a)^4 + \\dots$\n让我们检查三阶导数系数。$f'''(x) = -\\cos(x)$。\n对于 $a=0$，$f'''(0) = -\\cos(0) = -1 \\ne 0$。\n对于 $a=\\pi$，$f'''(\\pi) = -\\cos(\\pi) = -(-1) = 1 \\ne 0$。\n所以对于小的 $h=x-a$，误差表现为 $R_1^{(a)}(a+h) \\approx \\dfrac{f'''(a)}{6}h^3$。\n对于 $a=0$，误差约为 $-\\frac{1}{6}h^3$。对于 $a=\\pi$，误差约为 $\\frac{1}{6}h^3$。\n在这两种情况下，最低阶行为是三次的，且系数 $C$ 非零。\n该陈述还正确地指出，一个一般的余项界 $\\lvert R_1(x) \\rvert \\le \\frac{M_2}{2}(x-a)^2$（其中 $M_2$ 是 $\\lvert f''(c)\\rvert$ 的一个界）暗示了一个二次上界，这是正确的，但在 $f''(a)=0$ 的这种特殊情况下，它不如实际的三次行为那么精确。\n\n结论：**正确**。",
            "answer": "$$\n\\boxed{ACDEG}\n$$"
        },
        {
            "introduction": "从理论走向实践，这最后一个练习旨在解决在计算机上实现 $\\sin(x)$ 函数这一真实挑战。你将发现，对于较大的输入值，直接使用麦克劳林级数会因数值不稳定性而导致灾难性的失败。解决方案在于设计一个“自变量约化”（argument reduction）算法，这是一种计算科学中的标准技术，它将泰勒级数与函数的周期性相结合，以确保在所有输入上都能获得准确和稳定的结果 。",
            "id": "2442233",
            "problem": "你需要编写一个完整、可运行的程序，该程序使用麦克劳林级数计算正弦函数，并严格控制截断误差，同时分析此方法对于大自变量的数值稳定性。计算过程完全使用弧度制。\n\n从以下基本原理出发：\n- 解析函数的麦克劳林级数定义以及拉格朗日余项形式。对于一个充分可微的函数 $f$，其在 $x=0$ 处的 $m$ 次麦克劳林多项式的余项为 $R_{m}(x) = \\dfrac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n- 三角函数的周期性和奇偶性恒等式：对于任意整数 $k$，有 $ \\sin(x + 2\\pi k) = \\sin(x)$；以及和角与象限对称性，这些性质可以将 $ \\sin(x)$ 与一个小的余量 $r$ 的 $ \\sin(r)$ 或 $ \\cos(r)$ 相关联，该余量是通过减去 $ \\dfrac{\\pi}{2}$ 的整数倍得到的。\n\n你的任务：\n1) 根据麦克劳林定义和拉格朗日余项公式，推导出一个停止准则，用于截断 $ \\sin(x)$ 和 $ \\cos(x)$ 的麦克劳林级数，以达到用户指定的绝对误差容限 $ \\varepsilon  0$。具体来说，利用 $ \\sin(x)$ 或 $ \\cos(x)$ 的任意阶导数的绝对值在实数线上最大为 $1$ 这一事实，来证明形如下式的不等式\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}, \n\\qquad\n\\left| R_{2N}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!},\n$$\n然后，构建一个过程，对于给定的一个很小的自变量 $z$，找到最小的整数 $N \\ge 0$，使得相应的余项上界小于或等于 $ \\varepsilon$。\n\n2) 设计并实现一个自变量约减策略。对于任意实数 $x$，使用 $ \\dfrac{\\pi}{2}$ 的整数倍将 $x$ 映射到一个余量 $r$（位于区间 $[-\\dfrac{\\pi}{4}, \\dfrac{\\pi}{4}]$）和一个象限索引 $q \\in \\{0,1,2,3\\}$，使得\n$$\n\\sin(x) = \n\\begin{cases}\n\\phantom{-}\\sin(r),   q \\equiv 0 \\ (\\text{mod } 4),\\\\\n\\phantom{-}\\cos(r),   q \\equiv 1 \\ (\\text{mod } 4),\\\\\n-\\sin(r),  q \\equiv 2 \\ (\\text{mod } 4),\\\\\n-\\cos(r),  q \\equiv 3 \\ (\\text{mod } 4).\n\\end{cases}\n$$\n利用此映射关系，选择应在小余量 $r$ 处计算哪个麦克劳林级数（正弦或余弦）。使用任务1中的停止准则，确定保证截断误差不超过 $ \\varepsilon$ 所需的最少级数项数。\n\n3) 从第一性原理出发，解释为什么直接对大的 $|x|$ 进行麦克劳林求值是数值不稳定的：分析在阶乘增长占主导地位之前，中间项的量级如何变化，以及有限精度算术如何加剧相消误差。然后，将其与自变量约减策略的稳定性进行对比，并解释其局限性，即当 $|x|$ 极大时，由于尾数位的限制，浮点数约减 $x \\mapsto r$ 本身可能会损失精度。\n\n4) 为一组测试输入实现以下程序化输出。对于每个测试用例参数对 $(x, \\varepsilon)$：\n- 使用你的自变量约减麦克劳林方法计算 $s_{\\text{approx}}$。\n- 计算一个布尔值 $b_{\\text{ok}}$，当且仅当 $|s_{\\text{approx}} - \\sin(x)| \\le \\varepsilon$ 时为真，其中右侧的 $ \\sin(x)$ 使用高质量的库函数作为参考值进行计算。\n- 报告所选级数实际求和的最小非零麦克劳林项数，记为 $T$（对于 $ \\sin$，这是 $T = N+1$，对应于次数 $1,3,\\dots,2N+1$；对于 $ \\cos$，这是 $T = N+1$，对应于次数 $0,2,\\dots,2N$）。\n- 评估在相同容限下，一个朴素的、未经约减的 $ \\sin(x)$ 麦克劳林级数是否在实践中不可用。检查标准为：在余项上界降至 $ \\varepsilon$ 以下之前，是否需要超过 $T_{\\max} = 1000$ 个非零项的上限，或者中间余项是否溢出为非有限值。如果不可用，则将布尔值 $b_{\\text{naive\\_impractical}}$ 记录为真，否则为假。\n\n角度单位：弧度。无物理单位。所有百分比（如有）必须表示为小数。\n\n测试套件：\n- 案例1：$(x, \\varepsilon) = (100.0, 10^{-12})$。\n- 案例2：$(x, \\varepsilon) = (10^{6} + 0.1, 10^{-12})$。\n- 案例3：$(x, \\varepsilon) = (10^{16} + 0.1, 10^{-12})$。\n- 案例4：$(x, \\varepsilon) = \\left(\\dfrac{\\pi}{2} + 10^{-8}, 10^{-15}\\right)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于上述顺序中的第 $k$ 个测试用例，输出三元组 $[b_{\\text{ok},k}, T_k, b_{\\text{naive\\_impractical},k}]$，并将这些三元组按测试用例顺序展平成一个单一列表。例如，最终行应如下所示\n$[b_{\\text{ok},1}, T_{1}, b_{\\text{naive\\_impractical},1}, b_{\\text{ok},2}, T_{2}, b_{\\text{naive\\_impractical},2}, b_{\\text{ok},3}, T_{3}, b_{\\text{naive\\_impractical},3}, b_{\\text{ok},4}, T_{4}, b_{\\text{naive\\_impractical},4}]$。",
            "solution": "所述问题定义明确、内部一致，并基于数值分析和微积分的基本原理。它既不含糊也不存在科学上的不健全之处。因此，我们将按要求进行严格的推导和实现。\n\n任务是实现一种数值稳定的方法，利用麦克劳林级数展开来计算正弦函数 $\\sin(x)$，并分析其与朴素直接求值方法的性能对比。解决方案分为三个主要部分：级数截断准则的推导、自变量约减策略的开发以及数值稳定性的分析。\n\n**1. 截断准则的推导**\n\n一个解析函数 $f(x)$ 在 $x=0$ 附近展开的麦克劳林级数由 $f(x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(0)}{k!} x^k$ 给出。当此级数在 $m$ 次项后被截断时，结果为麦克劳林多项式 $P_m(x)$，误差为余项 $R_m(x)$。根据拉格朗日余项形式，$R_m(x) = \\frac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n\n对于 $f(x) = \\sin(x)$，其导数是周期性的：$\\sin'(x) = \\cos(x)$，$\\sin''(x) = -\\sin(x)$，依此类推。关键在于，对于任意整数 $k \\ge 0$，其 $k$ 阶导数满足 $|f^{(k)}(x)| \\le 1$ 对所有实数 $x$ 成立。$\\sin(x)$ 的麦克劳林级数只包含 $x$ 的奇次幂：\n$$\n\\sin(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k+1)!} x^{2k+1} + R_{2N+1}(x)\n$$\n这里，我们在对应于 $k=N$ 的项（即 $2N+1$ 次项）之后截断了级数。多项式部分 $P_{2N+1}(x)$ 与 $P_{2N+2}(x)$ 相同，因为 $x^{2N+2}$ 的系数为零。因此，余项为 $R_{2N+2}(x)$，由下式给出：\n$$\nR_{2N+2}(x) = \\frac{f^{(2N+3)}(\\xi)}{(2N+3)!} x^{2N+3}\n$$\n其中 $f^{(2N+3)}(x)$ 是 $\\pm\\sin(x)$ 或 $\\pm\\cos(x)$。利用界 $|f^{(2N+3)}(\\xi)| \\le 1$，我们为在 $2N+1$ 次截断的正弦级数建立误差界：\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| = \\left| R_{2N+2}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}\n$$\n这证实了问题陈述中给出的不等式。\n\n对于 $f(x) = \\cos(x)$，其麦克劳林级数只包含 $x$ 的偶次幂：\n$$\n\\cos(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k)!} x^{2k} + R_{2N}(x)\n$$\n多项式 $P_{2N}(x)$ 与 $P_{2N+1}(x)$ 相同。余项为 $R_{2N+1}(x)$：\n$$\nR_{2N+1}(x) = \\frac{f^{(2N+2)}(\\xi)}{(2N+2)!} x^{2N+2}\n$$\n再次利用界 $|f^{(2N+2)}(\\xi)| \\le 1$，我们得到在 $2N$ 次截断的余弦级数的误差界：\n$$\n\\left| R_{2N}^{\\cos}(x) \\right| = \\left| R_{2N+1}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!}\n$$\n这也证实了问题的表述。\n\n为了满足给定的绝对误差容限 $\\varepsilon > 0$（对于小自变量 $z$），我们必须找到最小的非负整数 $N$，使得误差界不超过 $\\varepsilon$。\n对于 $\\sin(z)$，我们必须找到最小的 $N \\ge 0$ 使得 $\\frac{|z|^{2N+3}}{(2N+3)!} \\le \\varepsilon$。\n对于 $\\cos(z)$，我们必须找到最小的 $N \\ge 0$ 使得 $\\frac{|z|^{2N+2}}{(2N+2)!} \\le \\varepsilon$。\n这需要一个迭代搜索，从 $N=0$ 开始，递增 $N$ 直到条件满足。然后，要求和的非零项数为 $T = N+1$。\n\n**2. 自变量约减策略**\n\n对于大的 $|x|$，直接计算麦克劳林级数是低效且数值不稳定的。一种标准且稳健的技术是自变量约减，它利用了三角函数的周期性。任何实数 $x$ 都可以表示为 $x = q \\cdot \\frac{\\pi}{2} + r$，其中 $q$ 是一个整数，$r$ 是一个小的余量。我们选择 $q$ 为最接近 $x / (\\pi/2)$ 值的整数，这确保了余量 $r$ 位于区间 $[-\\frac{\\pi}{4}, \\frac{\\pi}{4}]$ 内。\n该过程如下：\n1. 计算 $y = x / (\\pi/2)$。\n2. 找到最近的整数 $q = \\text{round}(y)$。\n3. 计算余量 $r = x - q \\cdot (\\pi/2)$。根据构造，有 $|r| \\le \\frac{1}{2} \\cdot \\frac{\\pi}{2} = \\frac{\\pi}{4}$。\n\n$\\sin(x)$ 的值随后根据 $q$ 模 $4$ 的值与 $\\sin(r)$ 或 $\\cos(r)$ 相关联。令 $q_{\\text{mod} 4} = q \\pmod 4$。我们使用和角恒等式：\n- 如果 $q_{\\text{mod} 4} = 0$：$\\sin(x) = \\sin(4k \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + r) = \\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 1$：$\\sin(x) = \\sin((4k+1) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{\\pi}{2} + r) = \\cos(r)$。\n- 如果 $q_{\\text{mod} 4} = 2$：$\\sin(x) = \\sin((4k+2) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\pi + r) = -\\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 3$：$\\sin(x) = \\sin((4k+3) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{3\\pi}{2} + r) = -\\cos(r)$。\n\n该策略将计算任意 $x$ 的 $\\sin(x)$ 的问题，简化为计算小自变量 $|r| \\le \\pi/4$ 的 $\\sin(r)$ 或 $\\cos(r)$。对于这样的小自变量，麦克劳林级数收敛迅速，并且可以高效地应用前一节推导的截断准则来确定所需的项数。\n\n**3. 数值稳定性分析**\n\n对于大的 $|x|$ 直接计算 $\\sin(x)$ 的麦克劳林级数是数值不稳定的，原因主要有两个：中间项溢出和灾难性相消。\n\n- **中间项增长与溢出**：$\\sin(x)$ 级数的第 $k$ 项是 $t_k = \\frac{(-1)^k x^{2k+1}}{(2k+1)!}$。这些项的量级最初随着 $k$ 的增加而迅速增长。最大项的量级出现在比率 $|t_{k+1}/t_k| = \\frac{|x|^2}{(2k+2)(2k+3)} \\approx 1$ 时，这意味着 $2k+2 \\approx |x|$。对于像 $x=100$ 这样的大值，项会增长到天文数字级别（例如，对于 $k=49$，项的量级约为 $100^{99}/99!$，这很容易超过标准双精度浮点数的范围，约 $10^{308}$）。\n\n- **灾难性相消**：最终结果 $\\sin(x)$ 必须位于 $[-1, 1]$ 区间内。对于大的 $x$，级数求值涉及对非常大的正项和负项进行求和，以产生一个很小的最终结果。标准浮点数具有固定数量的有效数字（尾数）。当两个大的、几乎相等的数相减时，前面的有效数字会抵消，导致结果的有效数字位数大大减少。这种相对精度的损失被称为灾难性相消，并使最终结果变得毫无意义。\n\n自变量约减策略完全规避了这些问题。自变量 $r$ 很小（$|r| \\le \\pi/4 \\approx 0.785$），因此麦克劳林级数项 $\\frac{r^k}{k!}$ 的量级从一开始就是单调递减的。不存在中间项的增长，因此也没有灾难性相消。该方法是数值稳定的。\n\n然而，自变量约减本身也有其局限性。当 $x$ 极大时，步骤 $r = x - q \\cdot (\\pi/2)$ 可能会遭受灾难性相消。原因是标准浮点表示的 $\\pi$ 精度有限。对于一个非常大的 $x$（例如，$x=10^{16}+0.1$），$x$ 本身在标准 `float64` 算术中可能就会被舍入（对于 $10^{16}$，最低有效位的值大于 $0.1$，因此 $10^{16}+0.1$ 被存储为精确的 $10^{16}$）。即使 $x$ 是可表示的，乘积 $q \\cdot (\\pi/2)$ 也将是一个接近 $x$ 的大数。`float64` 表示的 $\\pi$ 的有限精度会给这个乘积带来一个与 $q$ 成正比的绝对误差。当 $x$ 很大时，$q$ 也很大，这个误差可能变得非常显著，甚至可能大于 $\\pi/2$ 本身。减法 $x - q \\cdot (\\pi/2)$ 随后会抵消大多数有效数字，导致得到的 $r$ 值几乎没有（或完全没有）正确的数字。这显示了在处理极大自变量时，定点精度算术计算的根本限制。这种现象预计将导致 $x = 10^{16} + 0.1$ 的测试用例无法通过精度检查。\n\n所提供的程序实现了这些原理，用于计算正弦函数并分析其在指定测试用例中的数值特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef get_required_terms_sin(z_abs, epsilon):\n    \"\"\"\n    Calculates the minimum number of terms T for the sin Maclaurin series.\n    The error bound after T terms (degree 2T-1) is |z|^(2T+1)/(2T+1)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 1)\n    bound = (z_abs**3) / 6.0\n    T = 1\n    \n    denom_fac1 = 4\n    denom_fac2 = 5\n    \n    while bound  epsilon:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T  1000: # Safety break\n            return T\n            \n    return T\n\ndef get_required_terms_cos(z_abs, epsilon):\n    \"\"\"\n    Calculates the minimum number of terms T for the cos Maclaurin series.\n    The error bound after T terms (degree 2T-2) is |z|^(2T)/(2T)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 0)\n    bound = z2 / 2.0\n    T = 1\n    \n    denom_fac1 = 3\n    denom_fac2 = 4\n\n    while bound  epsilon:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T  1000: # Safety break\n            return T\n            \n    return T\n\ndef eval_sin_series(z, T):\n    \"\"\"Evaluates the sin Maclaurin series for T terms.\"\"\"\n    if z == 0.0:\n        return 0.0\n\n    z2 = z * z\n    term = z\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k)(2k+1))\n        term *= -z2 / ((2 * k) * (2 * k + 1))\n        total += term\n    return total\n\ndef eval_cos_series(z, T):\n    \"\"\"Evaluates the cos Maclaurin series for T terms.\"\"\"\n    z2 = z * z\n    term = 1.0\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k-1)(2k))\n        term *= -z2 / ((2 * k - 1) * (2 * k))\n        total += term\n    return total\n\ndef compute_sin_reduced(x, epsilon):\n    \"\"\"\n    Computes sin(x) using argument reduction and Maclaurin series.\n    Returns the computed value and the number of terms used.\n    \"\"\"\n    pi_over_2 = np.pi / 2.0\n    \n    # Argument reduction\n    q_float = x / pi_over_2\n    q = np.round(q_float)\n    r = x - q * pi_over_2\n    \n    q_int = int(q)\n    quadrant = q_int % 4\n    \n    r_abs = abs(r)\n\n    if quadrant == 0:  # sin(r)\n        T = get_required_terms_sin(r_abs, epsilon)\n        val = eval_sin_series(r, T)\n        return val, T\n    elif quadrant == 1:  # cos(r)\n        T = get_required_terms_cos(r_abs, epsilon)\n        val = eval_cos_series(r, T)\n        return val, T\n    elif quadrant == 2:  # -sin(r)\n        T = get_required_terms_sin(r_abs, epsilon)\n        val = eval_sin_series(r, T)\n        return -val, T\n    else:  # quadrant == 3, -cos(r)\n        T = get_required_terms_cos(r_abs, epsilon)\n        val = eval_cos_series(r, T)\n        return -val, T\n\ndef check_naive_impractical(x, epsilon, T_max):\n    \"\"\"\n    Checks if a naive Maclaurin series evaluation of sin(x) is impractical.\n    Impractical if > T_max terms are needed or if intermediate terms overflow.\n    \"\"\"\n    x_abs = abs(x)\n    if x_abs == 0.0:\n        return False\n        \n    x2 = x_abs * x_abs\n    \n    # Check terms and remainder bound iteratively for T = 1, 2, ...\n    \n    # T=1 term magnitude (|x|)\n    term_mag = x_abs\n    if np.isinf(term_mag):\n        return True # Overflow\n\n    # Remainder bound for T=1 term\n    remainder_bound = term_mag * x2 / 6.0\n    if remainder_bound = epsilon:\n        return False # Practical\n    \n    for T in range(2, T_max + 1):\n        # Magnitude of the T-th term\n        # term_mag(T) = term_mag(T-1) * x^2 / ((2T-2)*(2T-1))\n        term_mag *= x2 / ((2*T - 2) * (2*T - 1))\n        if np.isinf(term_mag):\n            return True # Overflow of intermediate term\n\n        # Remainder bound for T terms\n        # bound(T) = term_mag(T) * x^2 / ((2T)*(2T+1))\n        remainder_bound = term_mag * x2 / ((2*T) * (2*T + 1))\n        if np.isinf(remainder_bound):\n            # This can happen if term_mag is huge but finite\n            # and gets multiplied by a large x2\n            return True\n            \n        if remainder_bound = epsilon:\n            return False # Practical, convergence within T_max terms\n\n    return True # Not converged within T_max terms\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 1e-12),\n        (10**6 + 0.1, 1e-12),\n        (10**16 + 0.1, 1e-12),\n        (np.pi/2 + 1e-8, 1e-15),\n    ]\n\n    results = []\n    for x, epsilon in test_cases:\n        # 1. Compute s_approx and T using the reduced method.\n        s_approx, T = compute_sin_reduced(x, epsilon)\n        \n        # 2. Compute b_ok by comparing with a high-quality reference.\n        # Use np.longdouble for reference calculation where precision matters\n        ref_val = np.sin(np.longdouble(x))\n        b_ok = np.abs(s_approx - ref_val) = epsilon\n        \n        # 3. Assess if naive method is impractical.\n        T_max = 1000\n        b_naive_impractical = check_naive_impractical(x, epsilon, T_max)\n        \n        results.extend([b_ok, T, b_naive_impractical])\n\n    # Final print statement in the exact required format.\n    # Python's str() for a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}