{
    "hands_on_practices": [
        {
            "introduction": "这项实践练习将连接介值定理 (IVT) 所保证的根的理论存在性与找到这些根的实际挑战。我们将探索如何系统地扫描一个区间以寻找根，并利用罗尔定理（中值定理的一个变种）来理解根的数量与函数形状之间的关系。这个练习将指导你从基本原理出发，构建一个完整的求根算法，展示理论保证如何成为稳健数值代码的基石。 ",
            "id": "3145023",
            "problem": "你需要设计并实现一个完整的、可运行的程序，该程序演示一个连续、可微、非单调函数 $f$ 如何在单个闭区间内拥有多个实根，利用罗尔定理获得容纳给定数量根所需的局部极值点数量的下界，并通过在子区间上结合采样和介值定理（IVT）来找到所有这些根。\n\n你可以假定的基本理论包括：连续性和可微性的定义、介值定理（IVT）、中值定理（MVT）、罗尔定理、极值定理以及关于驻点的费马引理。你不得假定或使用任何其他专门的定理或黑箱求解器。\n\n你的程序需要完成以下任务：\n\n1) 通过罗尔定理得到理论下界。考虑一个在闭区间 $[a,b]$ 上连续且在开区间 $(a,b)$ 上可微的函数 $f$。假设 $f$ 在 $[a,b]$ 中有 $m$ 个不同的实根。从所述定理的第一性原理出发，推导出一个关于 $f$ 在 $[a,b]$ 中必须具有的局部极值点最小数量的通用表达式。你的程序必须根据其数值上找到的不同根的整数数量 $m$ 来实现这个下界，而不是预先假定该界。\n\n2) 通过采样和介值定理进行根的隔离与精化。设计一种采样策略，该策略：\n- 在 $[a,b]$ 上建立一个均匀网格，\n- 检测出子区间 $[x_i,x_{i+1}]$，其中 $f(x_i) \\cdot f(x_{i+1})  0$，根据介值定理，每个这样的子区间至少包含一个根，\n- 将任何满足 $f(x_i)=0$ 的端点 $x_i$ 作为根包含进来，并且\n- 使用二分法程序对每个符号变化的区间进行精化，以逼近一个根，直到绝对误差小于预设的容差。\n因为介值定理仅在有符号变化的子区间中保证根的存在，并且本任务中的函数只有单根，所以必须使用足够精细的网格来确保每个单根都与至少一对符号变化的采样点相邻。对于三角函数，请使用弧度制。\n\n3) 数值容差与输出。在根的精化中使用 $10^{-12}$ 的二分法容差，然后将每个近似根四舍五入到 $6$ 位小数。当两个数值上找到的根彼此之间的差值在 $10^{-6}$ 以内时，将它们视为同一个根。对每个测试用例，将根按严格递增顺序排序。所有角度均以弧度表示。\n\n测试套件。你的程序必须能在以下纯粹以数学术语指定的测试用例上运行：\n- Case $1$: $f(x)=x^3-x$ on $[-2,2]$。\n- Case $2$: $f(x)=(x-1)\\,(x-1.5)\\,(x-2.5)$ on $[0,3]$。\n- Case $3$: $f(x)=\\sin(5x)-0.2$ on $[0,2\\pi]$，其中 $x$ 以弧度度量。\n- Case $4$: $f(x)=(x-0.2)\\,(x-0.8)$ on $[0,1]$。\n- Case $5$: $f(x)=(x+1)\\,(x-2)$ on $[-1,2]$。\n\n对于每个用例，你的程序必须：\n- 生成区间内不同实根的排序列表（四舍五入到 $6$ 位小数），以及\n- 仅根据你找到的不同实根的整数数量 $m$，计算区间内所需局部极值点最小数量的推导下界。\n\n最终输出格式。你的程序必须生成单行输出，该输出是一个由方括号括起来的、逗号分隔的结果列表，每个测试用例一个结果，每个结果的格式为：\n- 一个双元素列表，其中第一个元素是四舍五入后的根列表，第二个元素是任务1中的整数下界。\n\n具体来说，你的程序必须打印单行形式为\n$[\\,[\\,[r_{1,1},\\ldots,r_{1,k_1}],b_1],\\,[\\,[r_{2,1},\\ldots,r_{2,k_2}],b_2],\\,\\ldots,\\,\\,[\\,[r_{5,1},\\ldots,r_{5,k_5}],b_5]\\,]$\n的文本，其中不含空格，$r_{i,j}$ 是精确打印到 $6$ 位小数的浮点数，$b_i$ 是整数。不得打印任何其他文本。",
            "solution": "我们从第一性原理出发，将数学定理与具体算法联系起来。\n\n基本原理。设 $f$ 在 $[a,b]$ 上连续，在 $(a,b)$ 上可微。\n- 介值定理 (IVT)：如果 $f$ 在 $[a,b]$ 上连续，且 $f(a)$ 和 $f(b)$ 符号相反，则存在 $c\\in(a,b)$ 使得 $f(c)=0$。\n- 中值定理 (MVT)：如果 $f$ 在 $[a,b]$ 上连续，在 $(a,b)$ 上可微，则存在 $c\\in(a,b)$ 使得 $f'(c)=\\dfrac{f(b)-f(a)}{b-a}$。\n- 罗尔定理：如果 $f$ 在 $[a,b]$ 上连续，在 $(a,b)$ 上可微，且 $f(a)=f(b)$，则存在 $c\\in(a,b)$ 使得 $f'(c)=0$。\n- 极值定理：如果 $f$ 在紧区间 $[a,b]$ 上连续，则 $f$ 在 $[a,b]$ 上取得最大值和最小值。\n- 费马引理：如果 $f$ 在内点 $c\\in(a,b)$ 处有局部极值，且在 $c$ 点可微，则 $f'(c)=0$。\n\nA部分：关于局部极值数量与根数量关系的下界。假设 $f$ 在 $[a,b]$ 中有 $m\\ge 1$ 个不同的实根，记为 $r_1",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bisection(f, a, b, tol=1e-12, max_iter=100):\n    fa = f(a)\n    fb = f(b)\n    if abs(fa)  tol:\n        return a\n    if abs(fb)  tol:\n        return b\n    # Ensure there is a sign change\n    if fa * fb > 0:\n        # No sign change; bisection not applicable\n        return None\n    left, right = a, b\n    f_left, f_right = fa, fb\n    for _ in range(max_iter):\n        mid = 0.5 * (left + right)\n        f_mid = f(mid)\n        if abs(f_mid)  tol or 0.5 * (right - left)  tol:\n            return mid\n        # Choose the subinterval that preserves sign change\n        if f_left * f_mid = 0:\n            right, f_right = mid, f_mid\n        else:\n            left, f_left = mid, f_mid\n    return 0.5 * (left + right)\n\ndef isolate_and_refine_roots(f, a, b, n_grid, bisect_tol=1e-12, merge_tol=1e-6):\n    xs = np.linspace(a, b, n_grid)\n    fs = f(xs)\n    # Collect root candidates from endpoint zeros\n    candidates = []\n\n    # Check exact/near-zero samples\n    for xi, fi in zip(xs, fs):\n        if np.isfinite(fi) and abs(fi)  1e-12:\n            candidates.append(float(xi))\n\n    # Check sign changes on consecutive intervals\n    for i in range(len(xs) - 1):\n        x0, x1 = xs[i], xs[i + 1]\n        f0, f1 = fs[i], fs[i + 1]\n        if not (np.isfinite(f0) and np.isfinite(f1)):\n            continue\n        prod = f0 * f1\n        if prod  0.0:\n            r = bisection(f, x0, x1, tol=bisect_tol, max_iter=200)\n            if r is not None:\n                candidates.append(float(r))\n\n    # Deduplicate close roots\n    if not candidates:\n        roots = []\n    else:\n        candidates = sorted(candidates)\n        roots = [candidates[0]]\n        for r in candidates[1:]:\n            if abs(r - roots[-1]) = merge_tol:\n                # Merge by averaging for stability\n                roots[-1] = 0.5 * (roots[-1] + r)\n            else:\n                roots.append(r)\n\n    # Sort and round to 6 decimals for final reporting\n    roots.sort()\n    roots = [round(r, 12) for r in roots]  # preserve accuracy before formatting\n    return roots\n\ndef format_output(all_results):\n    # all_results is a list of tuples: (roots_list, bound_int)\n    # We must output a single line with no spaces, floats with exactly 6 decimals.\n    def fmt_float(x):\n        return f\"{x:.6f}\"\n\n    parts = []\n    for roots, bound in all_results:\n        roots_str = \"[\" + \",\".join(fmt_float(r) for r in roots) + \"]\"\n        part = \"[\" + roots_str + \",\" + str(int(bound)) + \"]\"\n        parts.append(part)\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define test cases (functions and intervals)\n    # Case 1: f(x) = x^3 - x on [-2, 2]\n    def f1(x):\n        return x**3 - x\n\n    # Case 2: f(x) = (x - 1)*(x - 1.5)*(x - 2.5) on [0, 3]\n    def f2(x):\n        return (x - 1.0) * (x - 1.5) * (x - 2.5)\n\n    # Case 3: f(x) = sin(5x) - 0.2 on [0, 2π] (radians)\n    def f3(x):\n        return np.sin(5.0 * x) - 0.2\n\n    # Case 4: f(x) = (x - 0.2)*(x - 0.8) on [0, 1]\n    def f4(x):\n        return (x - 0.2) * (x - 0.8)\n\n    # Case 5: f(x) = (x + 1)*(x - 2) on [-1, 2]\n    def f5(x):\n        return (x + 1.0) * (x - 2.0)\n\n    # Sampling densities chosen to reliably capture all simple roots\n    test_cases = [\n        (f1, -2.0, 2.0, 40001),               # fine grid for cubic\n        (f2, 0.0, 3.0, 40001),                # fine grid for cubic with three roots\n        (f3, 0.0, 2.0 * np.pi, 60001),        # dense grid for sin wave crossings\n        (f4, 0.0, 1.0, 20001),                # quadratic with two interior roots\n        (f5, -1.0, 2.0, 30001),               # linear factors, roots at endpoints\n    ]\n\n    results = []\n    for f, a, b, n_grid in test_cases:\n        roots = isolate_and_refine_roots(f, a, b, n_grid=n_grid, bisect_tol=1e-12, merge_tol=1e-6)\n        # Compute bound on minimum number of local extrema required: max(m - 1, 0)\n        m = len(roots)\n        bound = max(m - 1, 0)\n        results.append((roots, bound))\n\n    # Print in exact required single-line format with no spaces and floats with 6 decimals\n    print(format_output(results))\n\nsolve()\n```"
        },
        {
            "introduction": "虽然介值定理是证明根存在性的强大工具，但一个简单的基于网格的方法有其局限性。这项实践将基于介值定理的求根计数方法与一种精确的代数方法——施图姆定理——进行对比。通过比较两种方法的结果，你将更深刻地理解数值采样在何种情况下可能无法探测到所有的根（例如偶数重根或紧密聚集的根），从而磨练你对数值方法的批判性判断力。 ",
            "id": "3144944",
            "problem": "您需要实现两种计算方法，利用微积分的基本结果来证明并计数一个实系数多项式 $p(x)$ 在闭区间 $[a,b]$ 上的实根。第一种方法使用 Sturm 序列来精确计算区间内不同实根的数量。第二种方法对 $[a,b]$ 的一个规则网格划分进行采样，并利用介值定理 (IVT)，通过检测 $p(x)$ 在相邻网格点上的符号变化来验证哪些子区间必然包含至少一个根。然后，对于几个测试用例，比较经 IVT 验证的子区间数量与 Sturm 精确根计数。\n\n本任务的基本原理：\n- 多项式的连续性：任何实系数多项式 $p(x)$ 在 $\\mathbb{R}$ 上都是连续的，因此在任何 $[a,b]$ 上也连续。\n- 介值定理 (IVT)：如果一个连续函数 $f$ 在 $[a,b]$ 上的 $f(a)$ 和 $f(b)$ 符号相反，那么存在一个 $c \\in (a,b)$ 使得 $f(c)=0$。\n- 中值定理 (MVT) 和 Rolle 定理：如果一个可微函数 $f$ 满足 $f(a)=f(b)$，那么存在一个 $c \\in (a,b)$ 使得 $f'(c)=0$。对于多项式，在 $p(x)$ 的任意两个不同实根之间，至少存在一个 $p'(x)$ 的实根。\n- 多项式欧几里得算法：对于多项式 $A(x)$ 和 $B(x)$，存在商式 $Q(x)$ 和余式 $R(x)$ 使得 $A(x) = Q(x)B(x) + R(x)$，其中 $\\deg R  \\deg B$。\n\n定义和任务：\n1. 为 $p(x)$ 构建 Sturm 序列：\n   - 令 $p_0(x) = p(x)$ 和 $p_1(x) = p'(x)$。\n   - 对于 $k \\ge 1$，定义 $p_{k+1}(x) = -\\operatorname{rem}(p_{k-1}(x),p_k(x))$，其中 $\\operatorname{rem}$ 表示 $p_{k-1}$ 除以 $p_k$ 的多项式欧几里得除法的余式。\n   - 持续此过程，直到产生一个常数多项式且下一个余式为零。\n   - 对于任意 $x \\in \\mathbb{R}$，定义 $V(x)$ 为序列 $\\{p_i(x)\\}$ 中符号变化的次数，计算前需从序列中移除精确的零（即，压缩掉等于零的项，并计算连续非零值之间的符号翻转次数）。\n   - 根据 Sturm 定理，$p(x)$ 在 $(a,b)$ 内的不同实根数量等于 $V(a) - V(b)$，前提是变号数的计算如上所述移除了零；即使 $a$ 或 $b$ 是根，此约定也能得到正确的极限计数。\n2. 在均匀网格上实现基于 IVT 的验证：\n   - 将 $[a,b]$ 划分为子区间 $[x_i, x_{i+1}]$，其中 $x_i = a + i h$，$h0$ 是网格间距，$i=0,1,\\dots,N$，满足 $N h \\le b-a$ 并包含 $x_N=b$。\n   - 在每个网格节点上计算 $p(x_i)$。\n   - 一个经 IVT 验证的子区间是任意满足 $p(x_i)$ 和 $p(x_{i+1})$ 符号严格相反（即 $p(x_i) \\cdot p(x_{i+1})  0$）的相邻对 $[x_i, x_{i+1}]$。这证明了在 $(x_i, x_{i+1})$ 中至少存在一个根。\n   - 为了数值稳健性，使用一个小的阈值 $\\tau$ 将 $|p(x)| \\le \\tau$ 的值视为零；但是，除非端点之间存在严格的符号变化，否则不要计算端点为数值零的区间。换句话说，仅在将近似零的值替换为精确零之后，计算具有严格符号变化的子区间，并忽略用于验证的零端点。\n3. 对于下面的每个测试用例，计算：\n   - 网格中经 IVT 验证的子区间的整数数量。\n   - 使用 Sturm 序列计算的 $(a,b)$ 内不同实根的整数数量。\n4. 输出格式：\n   - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且是一个包含两个整数的列表 $[C_{\\mathrm{IVT}}, C_{\\mathrm{Sturm}}]$。例如，一个可能的输出是 $[[2,3],[1,2],[0,0]]$。\n\n数值细节：\n- 在 Sturm 求值的符号变号计数和 IVT 验证中将网格端点值视为零时，当 $|p(x)| \\le \\tau$ 时，均使用零阈值 $\\tau = 10^{-12}$。\n- 不涉及角度，也不涉及物理单位。\n\n测试套件：\n实现上述算法，并将其应用于以下多项式、区间和网格间距。系数按 $x$ 的降幂给出。\n- 案例 1 (不同的单根，部分落在网格节点上)：$p(x) = x^3 - x$，区间 $[a,b]=[-2,2]$，网格间距 $h=0.4$。\n- 案例 2 (包含一个偶数重根，该根附近没有符号变化)：$p(x) = (x-1)^2(x+2) = x^3 - 3x + 2$，区间 $[a,b]=[-3,3]$，网格间距 $h=0.6$。\n- 案例 3 (具有多个实根的高次多项式，粗网格)：$p(x) = x^5 - x$，区间 $[a,b]=[-10,10]$，网格间距 $h=4.7$。\n- 案例 4 (三个实根聚集)：$p(x) = (x-0.2)(x-0.25)(x+0.75) = x^3 + 0.3 x^2 - 0.2875 x + 0.0375$，区间 $[a,b]=[-1,1]$，网格间距 $h=0.5$。\n- 案例 5 (无实根)：$p(x) = x^2 + 1$，区间 $[a,b]=[-5,5]$，网格间距 $h=1.0$。\n\n答案规范：\n- 对每个案例，返回数对 $[C_{\\mathrm{IVT}}, C_{\\mathrm{Sturm}}]$，其中 $C_{\\mathrm{IVT}}$ 是经 IVT 验证的子区间数量，$C_{\\mathrm{Sturm}}$ 是 $(a,b)$ 内不同实根的精确数量。\n- 您的程序应生成单行输出，其中包含按顺序排列的五个数组对，形式为用方括号括起来的逗号分隔列表，例如：$[[C_{\\mathrm{IVT,1}},C_{\\mathrm{Sturm,1}}],[C_{\\mathrm{IVT,2}},C_{\\mathrm{Sturm,2}}],[C_{\\mathrm{IVT,3}},C_{\\mathrm{Sturm,3}}],[C_{\\mathrm{IVT,4}},C_{\\mathrm{Sturm,4}}],[C_{\\mathrm{IVT,5}},C_{\\mathrm{Sturm,5}}]]$。",
            "solution": "问题陈述在形式上是有效的。它在科学上基于已确立的数学原理（Sturm 定理，介值定理），问题设定良好，具有完整且一致的定义和数据，并且表述客观。我们将着手提供一个解决方案。\n\n任务是实现并比较两种不同的方法，用于计算多项式 $p(x)$ 在给定区间 $[a,b]$ 内的实根数量。第一种方法基于 Sturm 定理，提供不同实根的精确数量。第二种方法基于介值定理 (IVT)，提供经证明包含至少一个根的子区间数量。\n\n**方法 1：通过 Sturm 定理进行根计数**\n\nSturm 定理提供了一种鲁棒的算法，用于确定实系数多项式在给定区间 $(a,b)$ 内不同实根的精确数量。该方法的核心是构建一个称为 Sturm 序列的特殊多项式序列。\n\n对于一个给定的多项式 $p(x)$，其标准 Sturm 序列构建如下：\n1. 前两个元素是 $p_0(x) = p(x)$ 及其一阶导数 $p_1(x) = p'(x)$。\n2. 后续元素使用多项式欧几里得算法生成。对于 $k \\ge 1$，我们将 $p_{k+1}(x)$ 定义为 $p_{k-1}(x)$ 除以 $p_k(x)$ 的余式的相反数：\n$$p_{k+1}(x) = -\\operatorname{rem}(p_{k-1}(x), p_k(x))$$\n重复此过程，直到余式为零多项式，此时序列终止。\n\n一旦 Sturm 序列 $\\{p_0(x), p_1(x), \\dots, p_m(x)\\}$ 构建完成，我们定义 $V(x_0)$ 为求值后的数字序列 $\\{p_0(x_0), p_1(x_0), \\dots, p_m(x_0)\\}$ 中的符号变化次数。在计算 $V(x_0)$ 时，任何精确为零的项都会在计数符号变化之前从序列中省略。\n\nSturm 定理指出，对于一个在端点 $a$ 或 $b$ 没有重根的多项式 $p(x)$，其在区间 $(a,b)$ 内的不同实根的数量由端点处的符号变化数之差给出：\n$$C_{\\mathrm{Sturm}} = V(a) - V(b)$$\n即使 $a$ 或 $b$ 是 $p(x)$ 或任何 $p_i(x)$ 的根，从求值序列中移除零的指定约定也确保了该定理的成立。\n\n实现将使用 `numpy` 库。多项式由其系数按降幂顺序排列的数组表示。导数 $p'(x)$ 使用 `numpy.polyder` 计算。多项式除法和余数计算使用 `numpy.polydiv` 执行。在特定点 $a$ 和 $b$ 的多项式求值是使用 `numpy.polyval` 完成的。用于识别零值的数值容差为 $\\tau = 10^{-12}$。\n\n**方法 2：通过介值定理进行根的验证**\n\n介值定理 (IVT) 指出，如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，且 $y_0$ 是 $f(a)$ 和 $f(b)$ 之间的任意值，则至少存在一个 $c \\in (a,b)$ 使得 $f(c) = y_0$。一个用于求根的直接推论是，如果 $f(a)$ 和 $f(b)$ 的符号相反（即 $f(a) \\cdot f(b)  0$），则在开区间 $(a,b)$ 中必定至少存在一个根。\n\n由于所有多项式在 $\\mathbb{R}$ 上都是连续的，所以该定理适用。算法流程如下：\n1. 将区间 $[a,b]$ 划分为一组子区间。以指定的间距 $h$ 生成一个规则的网格点 $x_i$。网格点定义为 $x_0=a, x_1=a+h, \\dots, x_k=a+kh$，其中 $a+kh \\le b$，并且如果端点 $x_{N}=b$ 尚不存在，则明确包含它。这将产生子区间 $[x_i, x_{i+1}]$。\n2. 在每个网格点 $x_i$ 处对多项式 $p(x)$进行求值。\n3. 对于每个子区间 $[x_i, x_{i+1}]$，我们检查端点之间是否存在严格的符号变化，即 $p(x_i) \\cdot p(x_{i+1})  0$。在检查符号时，绝对值小于或等于容差 $\\tau=10^{-12}$ 的值被视为零。严格的符号变化要求两个端点都非零。\n4. 总计数 $C_{\\mathrm{IVT}}$ 是检测到此类严格符号变化的子区间的数量。\n\n该方法给出了根数量的下界。它有已知的局限性：\n-   它无法检测偶数重根（例如 $(x-c)^2$），因为函数在 $x=c$ 处接触坐标轴但没有改变符号。\n-   如果一对（或任意偶数个）不同的、紧密间隔的根都落入单个子区间 $[x_i, x_{i+1}]$ 内，且使得 $p(x_i)$ 和 $p(x_{i+1})$ 符号相同，则该方法可能会漏掉它们。\n-   由于要求严格的符号变化，如果根恰好落在网格点上，该方法将不会计数。\n\n实现将按规定生成网格点，并使用 `numpy.polyval` 对多项式求值。符号变化计数的逻辑将遵循指定的对数值容差 $\\tau$ 的处理方式。\n\n最后的流程包括将两种算法应用于提供的测试用例，并为每个用例报告计数对 $[C_{\\mathrm{IVT}}, C_{\\mathrm{Sturm}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Sturm's theorem and an IVT-based method for\n    counting real roots of polynomials on an interval.\n    \"\"\"\n    \n    TAU = 1e-12\n\n    def trim_poly(p):\n        \"\"\"Removes leading zero coefficients from a polynomial representation.\"\"\"\n        p = np.atleast_1d(p)\n        non_zeros = np.flatnonzero(p)\n        if non_zeros.size == 0:\n            return np.array([0.0])\n        return p[non_zeros[0]:]\n\n    def build_sturm_sequence(p_coeffs):\n        \"\"\"Constructs the Sturm sequence for a given polynomial.\"\"\"\n        p0 = trim_poly(p_coeffs)\n        if len(p0) == 1 and p0[0] == 0:\n            return []\n        \n        p1 = np.polyder(p0)\n        \n        sturm_seq = [p0, p1]\n        \n        pk_minus_1 = p0\n        pk = p1\n        \n        while True:\n            # The sequence terminates if pk is a zero polynomial\n            if len(pk) == 1 and np.isclose(pk[0], 0):\n                break\n            \n            # Use np.polydiv for polynomial long division\n            _quot, rem = np.polydiv(pk_minus_1, pk)\n            pk_plus_1 = -trim_poly(rem)\n            \n            # Check if the new polynomial (remainder) is zero\n            if len(pk_plus_1) == 1 and np.isclose(pk_plus_1[0], 0):\n                break\n            \n            sturm_seq.append(pk_plus_1)\n            \n            pk_minus_1 = pk\n            pk = pk_plus_1\n            \n        return sturm_seq\n\n    def count_sign_variations(sturm_seq, x, tau):\n        \"\"\"Counts the number of sign changes in the Sturm sequence evaluated at x.\"\"\"\n        if not sturm_seq:\n            return 0\n        \n        values = [np.polyval(p, x) for p in sturm_seq]\n        \n        # Filter out values that are numerically zero\n        non_zero_values = [v for v in values if abs(v) > tau]\n        \n        changes = 0\n        for i in range(len(non_zero_values) - 1):\n            if non_zero_values[i] * non_zero_values[i+1]  0:\n                changes += 1\n                \n        return changes\n\n    def sturm_root_count(p_coeffs, a, b, tau):\n        \"\"\"\n        Calculates the number of distinct real roots in (a, b) using Sturm's Theorem.\n        \"\"\"\n        seq = build_sturm_sequence(p_coeffs)\n        Va = count_sign_variations(seq, a, tau)\n        Vb = count_sign_variations(seq, b, tau)\n        return Va - Vb\n\n    def ivt_root_count(p_coeffs, a, b, h, tau):\n        \"\"\"\n        Counts subintervals with a certified root using the Intermediate Value Theorem.\n        \"\"\"\n        if a > b:\n            a, b = b, a\n        \n        # Generate grid points\n        num_full_steps = np.floor((b - a) / h)\n        grid_points = a + np.arange(num_full_steps + 1) * h\n        \n        # Ensure the endpoint b is included\n        if not np.isclose(grid_points[-1], b):\n            grid_points = np.append(grid_points, b)\n        \n        # Evaluate polynomial at grid points\n        p_values = np.polyval(p_coeffs, grid_points)\n        \n        # Determine signs, treating near-zeros as 0\n        signs = np.sign(p_values)\n        signs[np.abs(p_values) = tau] = 0\n        \n        ivt_count = 0\n        for i in range(len(signs) - 1):\n            # Check for a strict sign change (product is -1)\n            if signs[i] * signs[i+1]  0:\n                ivt_count += 1\n                \n        return ivt_count\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p_coeffs': [1, 0, -1, 0], 'a': -2, 'b': 2, 'h': 0.4},\n        {'p_coeffs': [1, 0, -3, 2], 'a': -3, 'b': 3, 'h': 0.6},\n        {'p_coeffs': [1, 0, 0, 0, -1, 0], 'a': -10, 'b': 10, 'h': 4.7},\n        {'p_coeffs': [1, 0.3, -0.2875, 0.0375], 'a': -1, 'b': 1, 'h': 0.5},\n        {'p_coeffs': [1, 0, 1], 'a': -5, 'b': 5, 'h': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        p, a, b, h = case['p_coeffs'], case['a'], case['b'], case['h']\n        \n        c_ivt = ivt_root_count(p, a, b, h, TAU)\n        c_sturm = sturm_root_count(p, a, b, TAU)\n        \n        results.append([c_ivt, c_sturm])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "中值定理经常出现在数值方法的误差项中，并涉及一个未知的点 $\\xi$。这项实践通过逆向思考来揭开 $\\xi$ 的神秘面纱：我们将首先计算一个有限差分公式的数值误差，然后反解出 $\\xi$ 的确切值。这个练习将抽象的误差公式具体化，并让你直观地洞察函数的局部性质如何决定其数值近似的精度。 ",
            "id": "3251117",
            "problem": "设计并实现一个完整的程序，该程序对于一个给定的光滑函数，能够数值上定位由导数中值定理所保证存在的点 $\\,\\xi \\in (x-h,x+h)\\,$，使得在点 $\\,x\\,$ 处步长为 $\\,h\\,$ 的一阶导数中心差分近似的误差可以表示为拉格朗日余项形式。此任务分为三个部分：\n\n1) 仅从基本定义和带有拉格朗日余项形式的泰勒展开出发，推导一阶导数中心差分公式的精确主阶误差表达式。你必须确定正确的比例常数和符号，并在函数 $\\,f\\,$ 于 $\\,x\\,$ 的邻域内三阶连续可微的假设下，将误差表示为某个 $\\,\\xi \\in (x-h,x+h)\\,$ 处的 $\\,f^{(3)}(\\xi)\\,$ 的形式。不要使用任何现成的误差公式，必须从第一性原理进行推导。\n\n2) 基于你的推导，针对给定的函数 $\\,f\\,$、其一阶导数 $\\,f'\\,$ 和三阶导数 $\\,f^{(3)}\\,$，在点 $\\,x\\,$ 和步长 $\\,h0\\,$ 的情况下，提出一个计算有效 $\\,\\xi\\,$ 的数值步骤。你的方法必须基于导数中值定理和介值定理给出逻辑证明：如果你的推导表明中心差分误差可以写成一个常数乘以 $\\,f^{(3)}(\\xi)\\,$，请解释如何变换观测到的误差，然后求解方程 $\\,f^{(3)}(\\xi)=y^\\star\\,$ 以获得 $\\,\\xi \\in [x-h,x+h]\\,$，其中 $\\,y^\\star\\,$ 是你根据观测误差计算出的一个量。你的数值方法应满足：\n- 当 $\\,f^{(3)}\\,$ 在 $[x-h,x+h]$ 上单调时，通过构造保证 $\\,\\xi \\in [x-h,x+h]\\,$，此时 $\\,y^\\star\\,$ 被端点值 $\\,f^{(3)}(x-h)\\,$ 和 $\\,f^{(3)}(x+h)\\,$ 所包围。\n- 处理 $\\,f^{(3)}\\,$ 在 $[x-h,x+h]$ 上为（近似）常数的退化情况；在这种情况下，需要论证返回 $\\,\\xi=x\\,$ 作为一个有效的数值代表是合理的。\n- 当 $\\,h\\,$ 很小但不为零时，方法应能稳健地处理浮点效应。\n\n3) 在一个单一、可运行的程序中实现该方法，该程序为一个小型测试集计算并报告距离 $\\,|\\xi - x|\\,$。对于下方的每个测试用例，计算指定列表中每个 $\\,h\\,$ 对应的 $\\,\\xi\\,$，并按给定顺序记录相应的 $\\,|\\xi-x|\\,$ 值。测试集如下：\n\n- 用例 A（$\\,f^{(3)}\\,$ 递增）：$\\,f(t)=e^{t}\\,$, $\\,f'(t)=e^{t}\\,$, $\\,f^{(3)}(t)=e^{t}\\,$, $\\,x=0.7\\,$, $\\,h \\in \\{0.2,\\,0.1,\\,0.05,\\,0.025\\}\\,$。\n- 用例 B（$\\,f^{(3)}\\,$ 线性）：$\\,f(t)=t^{4}\\,$, $\\,f'(t)=4t^{3}\\,$, $\\,f^{(3)}(t)=24t\\,$, $\\,x=-0.3\\,$, $\\,h \\in \\{0.2,\\,0.1,\\,0.05,\\,0.025\\}\\,$。\n- 用例 C（$\\,f^{(3)}\\,$ 递减）：$\\,f(t)=-e^{t}\\,$, $\\,f'(t)=-e^{t}\\,$, $\\,f^{(3)}(t)=-e^{t}\\,$, $\\,x=0.2\\,$, $\\,h \\in \\{0.2,\\,0.1,\\,0.05,\\,0.025\\}\\,$。\n- 用例 D（$\\,f^{(3)}\\,$ 为常数）：$\\,f(t)=t^{3}\\,$, $\\,f'(t)=3t^{2}\\,$, $\\,f^{(3)}(t)=6\\,$, $\\,x=1.1\\,$, $\\,h \\in \\{0.5,\\,0.25,\\,0.125,\\,0.0625\\}\\,$。\n\n对于每个用例和每个 $\\,h\\,$，计算中心差分近似\n$$\nD_{c}(f;x,h)=\\frac{f(x+h)-f(x-h)}{2h},\n$$\n观测误差 $\\,E=f'(x)-D_{c}(f;x,h)\\,$，将其转换为你的推导所蕴含的适当目标值 $\\,y^\\star\\,$，然后求解 $\\,f^{(3)}(\\xi)=y^\\star\\,$ 以得到 $\\,\\xi \\in [x-h,x+h]\\,$。最后，按以下顺序，将绝对距离 $\\,|\\xi-x|\\,$ 的序列输出为包含16个浮点数的单一扁平列表：\n\n$[\\,$用例 A 对应的 $\\,h=0.2,\\,0.1,\\,0.05,\\,0.025;\\,$ 用例 B 对应的 $\\,h=0.2,\\,0.1,\\,0.05,\\,0.025;\\,$ 用例 C 对应的 $\\,h=0.2,\\,0.1,\\,0.05,\\,0.025;\\,$ 用例 D 对应的 $\\,h=0.5,\\,0.25,\\,0.125,\\,0.0625\\,]$。\n\n你的程序应该生成一行输出，其中包含这个扁平列表，格式为带方括号、逗号分隔的 Python 风格列表，例如：\"[v1,v2,...,v16]\"。所有实数必须以默认浮点格式打印。本问题不涉及任何物理单位或角度单位。",
            "solution": "本问题要求推导中心有限差分公式的误差项，设计一种数值方法来寻找误差项中的点 $\\xi$，并为一组给定的测试用例实现该方法。整个过程基于 Taylor 定理和连续函数的性质。\n\n### 第一部分：中心差分误差公式的推导\n\n任务是推导一阶导数的中心差分近似 $D_{c}(f;x,h) = \\frac{f(x+h) - f(x-h)}{2h}$ 的误差项。误差定义为 $E = f'(x) - D_{c}(f;x,h)$。我们假设函数 $f$ 在点 $x$ 的邻域内三阶连续可微，即 $f \\in C^3$。\n\n我们从 $f(x+h)$ 和 $f(x-h)$ 在 $x$ 点的泰勒展开开始。根据带有拉格朗日余项的 Taylor 定理，对于某个 $\\xi_1 \\in (x, x+h)$ 和 $\\xi_2 \\in (x-h, x)$，我们可以写出：\n$$\nf(x+h) = f(x) + f'(x)h + \\frac{f''(x)}{2!}h^2 + \\frac{f^{(3)}(\\xi_1)}{3!}h^3\n$$\n$$\nf(x-h) = f(x) - f'(x)h + \\frac{f''(x)}{2!}h^2 - \\frac{f^{(3)}(\\xi_2)}{3!}h^3\n$$\n从第一个展开式中减去第二个展开式，可以消去含有 $f(x)$ 和 $f''(x)$ 的项：\n$$\nf(x+h) - f(x-h) = \\left( f'(x)h - (-f'(x)h) \\right) + \\left( \\frac{f^{(3)}(\\xi_1)}{6}h^3 - \\left(-\\frac{f^{(3)}(\\xi_2)}{6}h^3\\right) \\right)\n$$\n$$\nf(x+h) - f(x-h) = 2f'(x)h + \\frac{h^3}{6} \\left( f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2) \\right)\n$$\n为了得到中心差分公式的表达式，我们两边除以 $2h$（因为 $h  0$）：\n$$\n\\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{12} \\left( f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2) \\right)\n$$\n这给出了近似的截断误差，$D_{c}(f;x,h) - f'(x)$。问题将误差定义为 $E = f'(x) - D_{c}(f;x,h)$，因此我们有：\n$$\nE = - \\frac{h^2}{12} \\left( f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2) \\right)\n$$\n为了将此误差用单一点 $\\xi$ 表示，我们使用介值定理。由于假设 $f$ 是 $C^3$ 的，其三阶导数 $f^{(3)}$ 是一个连续函数。点 $\\xi_1$ 和 $\\xi_2$ 位于区间 $(x-h, x+h)$ 内。表达式 $\\frac{1}{2}(f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2))$ 代表了连续函数 $f^{(3)}$ 在区间 $(\\xi_2, \\xi_1) \\subset (x-h, x+h)$ 上两个值的平均值。根据介值定理，必定存在一个点 $\\xi \\in (\\xi_2, \\xi_1)$，因此也存在于 $\\xi \\in (x-h, x+h)$ 中，使得：\n$$\nf^{(3)}(\\xi) = \\frac{f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2)}{2}\n$$\n将此结果代回我们的误差 $E$ 的表达式中：\n$$\nE = - \\frac{h^2}{12} \\left( 2 f^{(3)}(\\xi) \\right)\n$$\n这得到了误差项的最终形式：\n$$\nE = f'(x) - D_{c}(f;x,h) = -\\frac{h^2}{6} f^{(3)}(\\xi)\n$$\n对于某个 $\\xi \\in (x-h, x+h)$。推导至此完成。\n\n### 第二部分：计算 $\\xi$ 的数值步骤\n\n基于推导出的误差公式，我们可以设计一个数值步骤来找到 $\\xi$。\n输入是函数 $f$、$f'$、$f^{(3)}$、一个点 $x$ 和步长 $h  0$。\n\n1.  **计算观测误差**：首先，我们计算中心差分近似 $D_{c}(f;x,h)$，然后计算“观测”误差 $E_{obs}$，由于 $f'(x)$ 已知，我们可以得到 $E_{obs}$ 的精确值：\n    $$\n    E_{obs} = f'(x) - \\frac{f(x+h) - f(x-h)}{2h}\n    $$\n2.  **确定目标值 $y^\\star$**：我们将观测误差与理论误差表达式相等：\n    $$\n    E_{obs} = -\\frac{h^2}{6} f^{(3)}(\\xi)\n    $$\n    我们可以解出 $f^{(3)}(\\xi)$，以找到我们期望的点 $\\xi$ 必须满足的目标值 $y^\\star$：\n    $$\n    y^\\star = f^{(3)}(\\xi) = -\\frac{6 E_{obs}}{h^2} = -\\frac{6}{h^2} \\left( f'(x) - \\frac{f(x+h) - f(x-h)}{2h} \\right)\n    $$\n3.  **求解 $\\xi$**：问题现在简化为在区间 $[x-h, x+h]$ 内求解方程 $f^{(3)}(t) - y^\\star = 0$ 的根。\n\n    -   **单调情况**：对于 $f^{(3)}(t)$ 在 $[x-h, x+h]$ 上单调的测试用例，理论保证 $y^\\star$ 位于 $f^{(3)}(x-h)$ 和 $f^{(3)}(x+h)$ 两个值之间。这是因为 $y^\\star$ 是 $f^{(3)}$ 在两个内部点 $\\xi_1$ 和 $\\xi_2$ 处的平均值。因此，对于函数 $G(t) = f^{(3)}(t) - y^\\star$，我们有了一个有根区间。在这种情况下，二分法是寻找唯一根 $\\xi$ 的一个鲁棒且合适的选择。我们迭代地缩小区间 $[a, b]$（初始为 $[x-h, x+h]$），直到达到 $\\xi$ 所需的精度。\n\n    -   **常数情况**：如果 $f^{(3)}(t)$ 在区间上是常数，例如 $f^{(3)}(t) = C$，那么推导意味着 $y^\\star = \\frac{C+C}{2} = C$。方程变为 $C=C$，这对任意 $t \\in [x-h, x+h]$ 都成立。在这种退化情况下，技术上区间内的任何 $\\xi$ 值都是正确的。根据问题的指示，并作为一个合理的代表点选择，我们选择区间的中心点 $\\xi = x$。这也与4次多项式（其 $f^{(3)}$ 是线性的）的精确解析结果 $\\xi = x$ 一致，并且当 $h \\to 0$ 时，这个选择提供了一个连续的极限。\n\n数值算法实现如下：首先，计算 $y^\\star$。然后，检查 $f^{(3)}(x-h)$ 和 $f^{(3)}(x+h)$ 是否足够接近（在数值公差范围内）可以被认为是相等的，如果是，则返回 $\\xi=x$。否则，在区间 $[x-h, x+h]$ 上对 $G(t) = f^{(3)}(t) - y^\\star$ 应用二分法以找到 $\\xi$。\n\n### 第三部分：实现\n\n完整的程序实现了上述步骤。一个函数 `compute_xi` 接收函数 $f$、$f'$、$f^{(3)}$ 以及参数 $x$ 和 $h$ 作为输入，并返回计算出的 $\\xi$ 值。主函数 `solve` 遍历四个指定的测试用例及其各自的 $h$ 值列表。对于每种组合，它调用 `compute_xi` 并计算距离 $|\\xi - x|$。这些距离被收集到一个单一的扁平列表中，并以要求的格式打印出来。为简洁起见，每个用例的函数都使用 lambda 表达式定义。对于常数情况 $f^{(3)}(t)=6$，函数被定义为 `lambda t: 6.0 + 0*t` 以确保它是一个接受参数的有效可调用对象，这是一种良好的编程实践。二分法被实现为固定迭代次数（100次），这足以达到双精度准确度。最终输出是一个包含16个浮点数的列表，对应于所有指定测试的 $|\\xi-x|$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_xi(f, df, d3f, x, h, tol=1e-15, max_iter=100):\n    \"\"\"\n    Numerically computes the point xi in the Lagrange remainder form of the\n    central difference error.\n\n    Error E = f'(x) - D_c(f;x,h) = -h^2/6 * f'''(xi).\n\n    Args:\n        f (callable): The function.\n        df (callable): The first derivative of the function.\n        d3f (callable): The third derivative of the function.\n        x (float): The point at which to approximate the derivative.\n        h (float): The step size.\n        tol (float): The tolerance for the bisection method.\n        max_iter (int): The maximum number of iterations for bisection.\n\n    Returns:\n        float: The computed value of xi.\n    \"\"\"\n    # Step 1: Compute the central difference and the observed error.\n    d_c = (f(x + h) - f(x - h)) / (2.0 * h)\n    error_obs = df(x) - d_c\n\n    # Step 2: Compute the target value y_star for f'''(xi).\n    # f'''(xi) = -6 * error_obs / h^2\n    y_star = -6.0 * error_obs / (h**2)\n\n    # Step 3: Handle the (nearly) constant f''' case.\n    # We check if the values of f''' at the interval endpoints are close.\n    g_a_val = d3f(x - h)\n    g_b_val = d3f(x + h)\n    if np.isclose(g_a_val, g_b_val):\n        # For constant f''', any xi in (x-h, x+h) is valid. We choose x\n        # as a representative central point, as instructed.\n        return x\n\n    # Step 4: Solve f'''(xi) = y_star using the bisection method.\n    # We need to find the root of G(t) = f'''(t) - y_star.\n    a, b = x - h, x + h\n    G = lambda t: d3f(t) - y_star\n    \n    val_a = G(a)\n    val_b = G(b)\n\n    # The theory guarantees a root exists in (a, b). Floating point errors may\n    # cause y_star to be slightly outside [d3f(a), d3f(b)], but for the given\n    # well-behaved problems, this shouldn't be an issue.\n    if np.sign(val_a) == np.sign(val_b):\n        # This case suggests numerical precision issues or a non-monotonic f'''.\n        # For robustness, we could clamp, but for this problem we assume it won't happen.\n        # As a fallback, return the endpoint whose d3f value is closer to y_star.\n        if abs(val_a)  abs(val_b):\n            return a\n        else:\n            return b\n\n    # Bisection loop\n    for _ in range(max_iter):\n        mid = a + (b - a) / 2.0\n        val_mid = G(mid)\n\n        if abs(b - a) / 2.0  tol or val_mid == 0:\n            return mid\n\n        if np.sign(val_a) != np.sign(val_mid):\n            b = mid\n        else:\n            a = mid\n            val_a = val_mid # Update the boundary value for the next iteration\n            \n    return a + (b - a) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: f(t) = exp(t), increasing f'''\n        {'f': np.exp, 'df': np.exp, 'd3f': np.exp,\n         'x': 0.7, 'h_list': [0.2, 0.1, 0.05, 0.025]},\n        # Case B: f(t) = t^4, linear f'''\n        {'f': lambda t: t**4, 'df': lambda t: 4*t**3, 'd3f': lambda t: 24*t,\n         'x': -0.3, 'h_list': [0.2, 0.1, 0.05, 0.025]},\n        # Case C: f(t) = -exp(t), decreasing f'''\n        {'f': lambda t: -np.exp(t), 'df': lambda t: -np.exp(t), 'd3f': lambda t: -np.exp(t),\n         'x': 0.2, 'h_list': [0.2, 0.1, 0.05, 0.025]},\n        # Case D: f(t) = t^3, constant f'''\n        {'f': lambda t: t**3, 'df': lambda t: 3*t**2, 'd3f': lambda t: 6.0 + 0*t,\n         'x': 1.1, 'h_list': [0.5, 0.25, 0.125, 0.0625]}\n    ]\n\n    results = []\n    for case in test_cases:\n        f, df, d3f = case['f'], case['df'], case['d3f']\n        x, h_list = case['x'], case['h_list']\n        for h in h_list:\n            xi = compute_xi(f, df, d3f, x, h)\n            distance = abs(xi - x)\n            results.append(distance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}