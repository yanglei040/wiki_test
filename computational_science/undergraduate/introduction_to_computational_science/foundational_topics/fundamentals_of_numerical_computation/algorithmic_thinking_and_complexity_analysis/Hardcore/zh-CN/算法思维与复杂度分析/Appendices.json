{
    "hands_on_practices": [
        {
            "introduction": "渐近复杂度为我们选择算法提供了理论指导，但在实践中，常数因子和硬件特性同样关键。本练习将引导您比较直接卷积（$O(N^2)$）与基于快速傅里叶变换（FFT）的卷积（$O(N \\log N)$），通过建立一个包含算术运算和缓存未命中成本的精细性能模型，您将亲手计算出在真实世界中，渐近更优的算法从哪个问题规模开始真正超越传统算法。",
            "id": "3096816",
            "problem": "一个在大小为 $N$ 的均匀网格上的一维偏微分方程（PDE）求解器，计算一个完全线性卷积（等效于乘以一个由格林函数（Green's function）导出的稠密托普利兹（Toeplitz）算子）。有两种可用的算法策略：直接实空间卷积和基于快速傅里叶变换（FFT）的卷积。基于FFT的方法可以通过实数到复数FFT（利用厄米对称性（Hermitian symmetry））或通过对补零后的实数数据执行复数FFT来实现。\n\n使用以下基本依据：\n- 算法复杂度的定义：直接实空间卷积执行的基本算术运算次数的尺度为 $O(N^{2})$，而基于FFT的卷积执行的基本算术运算次数的尺度为 $O(N \\log N)$。\n- 在一个简化的中央处理器（CPU）缓存模型中，总挂钟时间被建模为算术时间和因缓存未命中导致的数据移动惩罚之和：$T = \\alpha \\times (\\text{number of floating-point operations}) + \\tau \\times (\\text{number of cache misses})$。\n- 对于该求解器，通过FFT进行的线性卷积使用补零至长度 $M = 2N$。一个 Cooley–Tukey FFT执行 $\\log_{2}(M)$ 个阶段，每个阶段包含一次对长度为$M$的数组的连续流式遍历。每次对长度为$X$的数组进行流式遍历会产生大约 $X / w$ 次缓存未命中，其中$w$是每个缓存行中的双精度浮点值的数量。\n- 算术成本和常数：\n  - 直接实空间卷积使用大约 $2 N^{2}$ 次浮点运算（每对数进行一次乘法和一次加法）。\n  - 长度为$M$的实数到复数FFT每次变换大约需要 $k_{rc} \\, M \\log_{2}(M)$ 次浮点运算，而复数FFT每次变换大约需要 $k_{c} \\, M \\log_{2}(M)$ 次浮点运算。假设 $k_{rc} = 2.5$ 和 $k_{c} = 5.0$。\n  - 使用实数到复数FFT时，逐点谱乘法需要 $b_{rc} \\, M$ 次浮点运算；使用复数FFT时，需要 $b_{c} \\, M$ 次浮点运算。假设 $b_{rc} = 3$ 和 $b_{c} = 6$。\n- 缓存未命中惩罚和硬件参数：\n  - 每次浮点运算时间 $\\alpha = 1.0 \\times 10^{-9}$ 秒。\n  - 每次缓存未命中惩罚 $\\tau = 2.0 \\times 10^{-8}$ 秒。\n  - 每个缓存行容纳 $w = 8$ 个双精度值。\n\n将缓存未命中次数建模如下：\n- 直接实空间卷积（稠密的、朴素的双循环实现）：两个输入数组每个被流式读取 $N$ 次，产生大约 $\\frac{2 N^{2}}{w}$ 次未命中，输出数组被写入一次，产生大约 $\\frac{N}{w}$ 次未命中。\n- 长度为 $M = 2N$ 的基于FFT的卷积：\n  - 三次FFT变换（两次正向和一次逆向）每次变换产生大约 $\\frac{M}{w} \\log_{2}(M)$ 次未命中，总共为 $\\frac{3 M}{w} \\log_{2}(M)$。\n  - 一次逐点谱乘法过程产生大约 $\\frac{M}{w}$ 次未命中。\n\n任务：\n1. 从给定的定义和事实出发，分别推导直接卷积、基于实数到复数FFT的卷积和基于复数FFT的卷积的显式时间模型 $T_{\\text{direct}}(N)$、$T_{\\text{rc}}(N)$ 和 $T_{\\text{cpx}}(N)$，以 $N$、$\\alpha$、$\\tau$、$w$、$k_{rc}$、$k_{c}$、$b_{rc}$ 和 $b_{c}$ 表示。\n2. 比较 $T_{\\text{rc}}(N)$ 和 $T_{\\text{cpx}}(N)$，以确定在所提供的模型下，对于所有相关的$N$，哪种FFT变体具有较小的常数因子。\n3. 使用较快的FFT变体，求解最小的整数网格大小 $N^{\\ast}$，使得对于所有 $N \\ge N^{\\ast}$，基于FFT的卷积时间严格小于直接卷积时间，即 $T_{\\text{FFT}}(N)  T_{\\text{direct}}(N)$。将 $N^{\\ast}$ 作为单个整数提供。$N^{\\ast}$ 不需要单位。\n\n最终答案必须是一个数字。",
            "solution": "用户要求我解决一个问题，该问题涉及为两种不同的卷积算法的性能建模，并找出它们执行时间的交叉点。\n\n### 步骤1：提取已知条件\n\n- **问题类型**：大小为 $N$ 的均匀网格上的一维PDE求解器。\n- **核心操作**：完全线性卷积。\n- **算法**：\n  1. 直接实空间卷积 ($T_{\\text{direct}}$)。\n  2. 基于FFT的卷积，有两种变体：\n     a. 实数到复数FFT ($T_{\\text{rc}}$)。\n     b. 对补零实数数据进行复数FFT ($T_{\\text{cpx}}$)。\n- **渐近复杂度**：\n  - 直接法：$O(N^2)$ 次运算。\n  - 基于FFT：$O(N \\log N)$ 次运算。\n- **时间模型**：$T = \\alpha \\times (\\text{number of floating-point operations}) + \\tau \\times (\\text{number of cache misses})$。\n- **FFT参数**：从长度 $N$ 补零到 $M = 2N$。FFT有 $\\log_{2}(M)$ 个阶段，每个阶段都是一次流式遍历。\n- **缓存未命中模型**：\n  - 遍历长度 $X$：$X/w$ 次未命中。\n  - 直接卷积未命中次数：$\\frac{2N^2}{w} + \\frac{N}{w}$。\n  - 基于FFT的卷积未命中次数（3次变换和1次逐点操作）：$3 \\frac{M}{w} \\log_{2}(M) + \\frac{M}{w}$。\n- **算术成本（浮点运算次数）**：\n  - 直接卷积：$2N^2$。\n  - 长度为 $M$ 的实数到复数FFT：每次变换 $k_{rc} M \\log_{2}(M)$，其中 $k_{rc} = 2.5$。\n  - 长度为 $M$ 的复数FFT：每次变换 $k_c M \\log_{2}(M)$，其中 $k_c = 5.0$。\n  - 逐点谱乘法（实数到复数）：$b_{rc} M$，其中 $b_{rc} = 3$。\n  - 逐点谱乘法（复数）：$b_c M$，其中 $b_c = 6$。\n- **硬件参数**：\n  - $\\alpha = 1.0 \\times 10^{-9}$ 秒/浮点运算。\n  - $\\tau = 2.0 \\times 10^{-8}$ 秒/未命中。\n  - $w = 8$ 个双精度数/缓存行。\n\n### 步骤2：使用提取的已知条件进行验证\n\n该问题具有科学依据。它提出了一个简化但标准的性能模型，用于在计算科学中比较算法。模型组件——算术成本（浮点运算次数）和内存访问成本（缓存未命中）——是性能工程的基础。直接卷积和基于FFT的卷积的渐近复杂度和具体操作计数是标准估计。缓存未命中模型基于一个合理的流式访问模式。所有参数都明确定义且量纲一致。该问题是适定的，具有明确的目标和足够的信息来为指定任务推导出唯一解。语言客观而精确。因此，该问题被认为是有效的。\n\n### 步骤3：行动\n\n问题是有效的。我现在开始解题。\n\n根据任务要求，解答分为三个部分。\n\n**任务1：推导显式时间模型。**\n\n首先，我们推导直接实空间卷积的总时间表达式 $T_{\\text{direct}}(N)$。\n浮点运算次数（FLOPs）给定为 $2N^2$。\n缓存未命中次数给定为 $\\frac{2N^2}{w} + \\frac{N}{w}$。\n总时间 $T_{\\text{direct}}(N)$ 是算术时间和缓存未命中惩罚之和：\n$$T_{\\text{direct}}(N) = \\alpha \\cdot (2N^2) + \\tau \\cdot \\left(\\frac{2N^2}{w} + \\frac{N}{w}\\right)$$\n按 $N$ 的幂次对项进行分组：\n$$T_{\\text{direct}}(N) = \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N^2 + \\left(\\frac{\\tau}{w}\\right)N$$\n\n接下来，我们推导基于FFT的卷积的时间。对两个长度为$N$的实信号进行卷积的整个过程包括：\n1. 将两个输入信号补零至长度 $M=2N$。\n2. 执行两次正向FFT。\n3. 对频谱进行逐点乘法。\n4. 执行一次逆向FFT。\n这总共需要3次变换。\n\n对于基于实数到复数FFT的方法，$T_{\\text{rc}}(N)$：\n3次长度为 $M=2N$ 的变换的浮点运算次数为 $3 \\cdot (k_{rc} M \\log_2(M)) = 3k_{rc}(2N)\\log_2(2N) = 6k_{rc}N\\log_2(2N)$。\n逐点谱乘法的浮点运算次数为 $b_{rc}M = 2b_{rc}N$。\n总浮点运算次数 = $6k_{rc}N\\log_2(2N) + 2b_{rc}N$。\n3次变换的缓存未命中次数为 $3 \\cdot (\\frac{M}{w} \\log_2(M)) = 3\\frac{2N}{w}\\log_2(2N) = \\frac{6N}{w}\\log_2(2N)$。\n逐点遍历的缓存未命中次数为 $\\frac{M}{w} = \\frac{2N}{w}$。\n总未命中次数 = $\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}$。\n总时间 $T_{\\text{rc}}(N)$ 为：\n$$T_{\\text{rc}}(N) = \\alpha \\left(6k_{rc}N\\log_2(2N) + 2b_{rc}N\\right) + \\tau \\left(\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}\\right)$$\n按项分组：\n$$T_{\\text{rc}}(N) = \\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)N\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{2\\tau}{w}\\right)N$$\n\n对于基于复数FFT的方法，$T_{\\text{cpx}}(N)$，结构相同，但使用常数$k_c$和$b_c$：\n浮点运算次数为 $6k_{c}N\\log_2(2N) + 2b_{c}N$。\n缓存未命中模型与实数到复数情况相同，因为它取决于数据移动，而不是所执行的算术运算。总未命中次数 = $\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}$。\n总时间 $T_{\\text{cpx}}(N)$ 为：\n$$T_{\\text{cpx}}(N) = \\alpha \\left(6k_{c}N\\log_2(2N) + 2b_{c}N\\right) + \\tau \\left(\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}\\right)$$\n按项分组：\n$$T_{\\text{cpx}}(N) = \\left(6\\alpha k_{c} + \\frac{6\\tau}{w}\\right)N\\log_2(2N) + \\left(2\\alpha b_{c} + \\frac{2\\tau}{w}\\right)N$$\n\n**任务2：比较FFT变体。**\n\n我们比较 $T_{\\text{rc}}(N)$ 和 $T_{\\text{cpx}}(N)$。\n$T_{\\text{rc}}(N) = C_{1,rc} N\\log_2(2N) + C_{2,rc} N$\n$T_{\\text{cpx}}(N) = C_{1,cpx} N\\log_2(2N) + C_{2,cpx} N$\n系数为：\n$C_{1,rc} = 6\\alpha k_{rc} + \\frac{6\\tau}{w}$\n$C_{1,cpx} = 6\\alpha k_{c} + \\frac{6\\tau}{w}$\n$C_{2,rc} = 2\\alpha b_{rc} + \\frac{2\\tau}{w}$\n$C_{2,cpx} = 2\\alpha b_{c} + \\frac{2\\tau}{w}$\n\n给定 $k_{rc} = 2.5$ 和 $k_c = 5.0$，所以 $k_{rc}  k_c$。因为 $\\alpha > 0$，可得 $C_{1,rc}  C_{1,cpx}$。\n给定 $b_{rc} = 3$ 和 $b_c = 6$，所以 $b_{rc}  b_c$。因为 $\\alpha > 0$，可得 $C_{2,rc}  C_{2,cpx}$。\n由于实数到复数FFT变体的两个系数都较小，且 $N > 0$，因此对于所有 $N \\ge 1$ 都有 $T_{\\text{rc}}(N)  T_{\\text{cpx}}(N)$。\n较快的FFT变体是实数到复数FFT方法。我们将其时间表示为 $T_{\\text{FFT}}(N) = T_{\\text{rc}}(N)$。\n\n**任务3：找到交叉点网格大小 $N^{\\ast}$。**\n\n我们需要找到最小的整数 $N^{\\ast}$，使得对于所有 $N \\ge N^{\\ast}$ 都有 $T_{\\text{FFT}}(N)  T_{\\text{direct}}(N)$。这即为不等式：\n$$T_{\\text{rc}}(N)  T_{\\text{direct}}(N)$$\n$$\\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)N\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{2\\tau}{w}\\right)N  \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N^2 + \\left(\\frac{\\tau}{w}\\right)N$$\n对于 $N > 0$，我们可以将不等式两边同除以 $N$：\n$$\\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{2\\tau}{w}\\right)  \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N + \\frac{\\tau}{w}$$\n重新整理各项以分离出 $N$ 项：\n$$\\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{\\tau}{w}\\right)  \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N$$\n现在，代入给定的数值：$\\alpha = 1.0 \\times 10^{-9}$，$\\tau = 2.0 \\times 10^{-8}$，$w=8$，$k_{rc}=2.5$，$b_{rc}=3$。\n\n计算不等式的系数：\n- $\\log_2(2N)$ 的系数：\n$6\\alpha k_{rc} + \\frac{6\\tau}{w} = 6(1.0 \\times 10^{-9})(2.5) + \\frac{6(2.0 \\times 10^{-8})}{8} = 15 \\times 10^{-9} + 1.5 \\times 10^{-8} = 15 \\times 10^{-9} + 15 \\times 10^{-9} = 30 \\times 10^{-9}$。\n- 左侧的常数项：\n$2\\alpha b_{rc} + \\frac{\\tau}{w} = 2(1.0 \\times 10^{-9})(3) + \\frac{2.0 \\times 10^{-8}}{8} = 6 \\times 10^{-9} + 0.25 \\times 10^{-8} = 6 \\times 10^{-9} + 2.5 \\times 10^{-9} = 8.5 \\times 10^{-9}$。\n- 右側 $N$ 的系数：\n$2\\alpha + \\frac{2\\tau}{w} = 2(1.0 \\times 10^{-9}) + \\frac{2(2.0 \\times 10^{-8})}{8} = 2 \\times 10^{-9} + 0.5 \\times 10^{-8} = 2 \\times 10^{-9} + 5 \\times 10^{-9} = 7 \\times 10^{-9}$。\n\n不等式变为：\n$$(30 \\times 10^{-9})\\log_2(2N) + (8.5 \\times 10^{-9})  (7 \\times 10^{-9})N$$\n我们可以将整个不等式同除以 $10^{-9}$：\n$$30\\log_2(2N) + 8.5  7N$$\n这是一个超越不等式，我们通过测试 $N$ 的整数值来求解。令 $f(N) = 7N - 30\\log_2(2N) - 8.5$。我们寻找使 $f(N)>0$ 的最小整数 $N$。函数 $f(N)$ 在 $N > \\frac{30}{7\\ln(2)} \\approx 6.2$ 时单调递增，所以一旦我们找到交叉点，该不等式将对所有更大的 $N$ 成立。\n让我们测试 $N$ 的整数值：\n- 对于 $N=25$：\n$f(25) = 7(25) - 30\\log_2(50) - 8.5 \\approx 175 - 30(5.6439) - 8.5 = 175 - 169.317 - 8.5 = -2.817  0$。\n所以对于 $N=25$，$T_{\\text{direct}}(25)  T_{\\text{FFT}}(25)$。\n- 对于 $N=26$：\n$f(26) = 7(26) - 30\\log_2(52) - 8.5 \\approx 182 - 30(5.7004) - 8.5 = 182 - 171.012 - 8.5 = 2.488 > 0$。\n所以对于 $N=26$，$T_{\\text{FFT}}(26)  T_{\\text{direct}}(26)$。\n\n基于FFT的方法严格快于直接法的最小整数网格大小是 $N=26$。由于 $O(N^2)$ 的直接法成本比 $O(N\\log N)$ 的FFT方法成本增长得更快，因此对于所有 $N \\ge 26$，FFT方法将保持更快。因此，$N^\\ast = 26$。",
            "answer": "$$\\boxed{26}$$"
        },
        {
            "introduction": "不存在普遍最优的算法，算法的选择往往取决于数据的内在特性。本练习将探讨一个经典的邻近搜索问题，比较两种空间数据结构——均匀网格哈希和 k-d 树。您将推导出一个“盈亏平衡”的粒子密度阈值，在该阈值之上或之下，两种算法的效率会发生反转，从而深刻理解数据分布对算法性能的决定性影响。",
            "id": "3096897",
            "problem": "一个模拟将 $n$ 个粒子独立且均匀随机地放置在一个面积为 $A$ 的二维（$2$-D）方形区域中。如果两个粒子间的欧几里得距离小于一个固定的相互作用半径 $r$（其中 $r \\ll \\sqrt{A}$），则它们发生相互作用。你必须对所有粒子执行邻居查询，以识别所有相互作用的粒子对。\n\n考虑以下两种算法策略：\n\n- 使用哈希的均匀网格：将区域划分为边长为 $\\ell = r$ 的方形单元格。每个粒子根据其单元格索引被插入一个哈希表中。对一个粒子的邻居查询会扫描该粒子所在单元格及其相邻单元格组成的 $3 \\times 3$ 区块（即 $9$ 个单元格）中的所有粒子。\n\n- $k$维树（k-d tree）：为该点集构建一个二元空间分割树，每个粒子执行一个半径为 $r$ 的固定半径范围查询。\n\n假设使用以下以基本操作为单位度量的成本模型：\n\n- 均匀网格：\n  - 每个粒子的构建成本：$c_{b,g}$。\n  - 每次查询的固定开销（不包括距离检查）：$c_{o,g}$。\n  - 每个候选点的距离检查成本：$c_{d,g}$。\n\n- k-d 树：\n  - 每个粒子的构建成本与 $\\log_{2}(n)$ 成正比：$c_{b,k} \\log_{2}(n)$。\n  - 每次查询的开销与 $\\log_{2}(n)$ 成正比：$c_{o,k} \\log_{2}(n)$。\n  - 每个邻居的距离检查成本：$c_{d,k}$。\n\n使用以下基本事实：大O表示法 $O(\\cdot)$ 对增长率进行分类；在均匀分布下，任何区域内点的期望数量等于密度乘以该区域的面积，其中密度为 $\\rho = n/A$；半径为 $r$ 的圆的面积是 $\\pi r^{2}$。\n\n在以下假设下，使用上述常数，为每种方法在所有 $n$ 次查询中的期望总操作数建立模型：\n\n- 均匀网格的 $3 \\times 3$ 单元格邻域面积为 $9 \\ell^{2} = 9 r^{2}$，因此每次查询的期望候选点数为 $9 \\rho r^{2}$。\n- k-d 树精确返回半径 $r$ 内的点，每次查询的期望数量为 $\\rho \\pi r^{2}$。\n\n推导盈亏平衡密度阈值 $\\rho^{*}$（作为一个封闭形式的解析表达式），在该阈值下，均匀网格和 k-d 树的期望总操作数相等。用 $n$、$r$ 以及常数 $c_{b,g}$、$c_{o,g}$、$c_{d,g}$、$c_{b,k}$、$c_{o,k}$ 和 $c_{d,k}$ 来表示你的最终答案。不需要数值近似，最终表达式中也不应包含任何单位。",
            "solution": "目标是推导一个密度阈值 $\\rho^{*}$，在该阈值下，均匀网格和$k$维树（k-d tree）的期望总操作数相等。我们从基本定义开始：\n\n- 大O表示法 $O(\\cdot)$ 描述渐近增长率，但在这里我们保留显式的常数因子，以获得一个具体的盈亏平衡表达式。\n- 对于密度为 $\\rho = n/A$ 的独立均匀分布的点，一个可测区域内的期望点数等于 $\\rho$ 乘以该区域的面积。\n- 半径为 $r$ 的圆的面积是 $\\pi r^{2}$。\n\n我们现在将算法行为转换为期望操作模型：\n\n使用哈希的均匀网格：\n- 构建阶段将每个粒子根据其单元格索引插入哈希表，每个粒子的成本为 $c_{b,g}$。对于 $n$ 个粒子，期望构建成本为 $n c_{b,g}$。\n- 对于每个粒子的查询，会产生一个固定的常数开销 $c_{o,g}$，用于识别和遍历包含 $9$ 个单元格的固定大小邻域。这些单元格并集中的期望候选点数是密度乘以邻域的面积。由于单元格边长为 $\\ell = r$，邻域面积为 $9 \\ell^{2} = 9 r^{2}$，因此每次查询的期望候选点数是 $9 \\rho r^{2}$。每个候选点会产生一次成本为 $c_{d,g}$ 的距离检查。因此，每次查询的期望成本是\n$$\nc_{o,g} + c_{d,g} \\cdot 9 \\rho r^{2}.\n$$\n对所有 $n$ 次查询求和，期望查询成本是\n$$\nn c_{o,g} + n c_{d,g} \\cdot 9 \\rho r^{2}.\n$$\n因此，网格方法的期望总操作数是\n$$\nT_{\\text{grid}} = n c_{b,g} + n c_{o,g} + 9 n c_{d,g} \\rho r^{2}.\n$$\n\nk-d 树：\n- 构建阶段每个粒子产生的成本为 $c_{b,k} \\log_{2}(n)$，得到期望构建成本为 $n c_{b,k} \\log_{2}(n)$。\n- 每次查询遍历树会产生 $c_{o,k} \\log_{2}(n)$ 的开销，外加每个返回邻居的成本。在均匀性假设下，半径 $r$ 内的真实邻居的期望数量是密度乘以半径为 $r$ 的圆盘面积，即 $\\rho \\pi r^{2}$。每个被检查的邻居成本为 $c_{d,k}$，所以每次查询的期望成本是\n$$\nc_{o,k} \\log_{2}(n) + c_{d,k} \\cdot \\rho \\pi r^{2}.\n$$\n对所有 $n$ 次查询求和，期望查询成本是\n$$\nn c_{o,k} \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n因此，k-d 树方法的期望总操作数是\n$$\nT_{\\text{kdtree}} = n c_{b,k} \\log_{2}(n) + n c_{o,k} \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n我们可以将 $\\log_{2}(n)$ 项组合起来：\n$$\nT_{\\text{kdtree}} = n \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n\n盈亏平衡条件：\n令 $T_{\\text{grid}} = T_{\\text{kdtree}}$，解出 $\\rho$：\n$$\nn c_{b,g} + n c_{o,g} + 9 n c_{d,g} \\rho r^{2} = n \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n两边同除以 $n$：\n$$\nc_{b,g} + c_{o,g} + 9 c_{d,g} \\rho r^{2} = \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) + c_{d,k} \\rho \\pi r^{2}.\n$$\n将含 $\\rho$ 的项收集到左边，常数项收集到右边：\n$$\n\\left( 9 c_{d,g} - \\pi c_{d,k} \\right) \\rho r^{2} = \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) - \\left( c_{b,g} + c_{o,g} \\right).\n$$\n假设 $9 c_{d,g} \\neq \\pi c_{d,k}$ 以使 $\\rho$ 的系数非零，解出盈亏平衡密度 $\\rho^{*}$：\n$$\n\\rho^{*} = \\frac{ \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) - \\left( c_{b,g} + c_{o,g} \\right) }{ \\left( 9 c_{d,g} - \\pi c_{d,k} \\right) r^{2} }.\n$$\n\n相对于 $O(n)$ 与 $O(n \\log n)$ 的解释：\n- 对于网格，主要项是关于 $n$ 的线性项，而依赖于邻居的项按 $n \\rho r^{2}$ 的比例变化。当 $\\rho$ 低于 $\\rho^{*}$ 时，网格的总成本更低，并且在 $r$ 固定且 $\\rho r^{2}$ 有界的情况下，其行为表现为 $O(n)$。\n- 对于 k-d 树，存在一个来自构建和每次查询遍历的固有 $n \\log_{2}(n)$ 开销。当 $\\rho$ 超过 $\\rho^{*}$ 时，邻居项可能占主导地位，但在低于 $\\rho^{*}$ 时，$\\log_{2}(n)$ 项是决定性的，总成本为 $O(n \\log n)$。\n\n因此，封闭形式的盈亏平衡密度阈值就是上面推导出的表达式。",
            "answer": "$$\\boxed{\\frac{\\left(c_{b,k}+c_{o,k}\\right)\\log_{2}(n)-\\left(c_{b,g}+c_{o,g}\\right)}{\\left(9c_{d,g}-\\pi c_{d,k}\\right) r^{2}}}$$"
        },
        {
            "introduction": "对算法的全面理解不仅包括其平均性能，还必须洞察其性能的“软肋”。本练习将引导您进行一次“对抗性思考”，通过构建一个高度对称的数据集，来揭示 k-d 树在最近邻搜索中的最坏情况性能。您将证明，在这种特殊情况下，k-d 树的查询效率会从对数时间退化为线性时间，这凸显了在设计稳健系统时考虑最坏情况的重要性。",
            "id": "3096826",
            "problem": "考虑欧几里得度量空间 $\\mathbb{R}^{2}$，其距离定义为 $d(\\mathbf{x},\\mathbf{y}) = \\|\\mathbf{x}-\\mathbf{y}\\|_{2}$。你将分析在一个 $k$-d 树和一个平衡的 vantage-point 树（VP-树）中的最近邻查询，仅使用以下基本依据：(i) $k$-d 树的定义，即一种轴对齐的二元空间分割树，它通过在阈值处交替使用坐标轴来分割点集，(ii) VP-树的定义，即一种度量树，它通过到选定基准点的距离（作为半径）来分割点集，以及 (iii) 任何度量都满足的三角不等式 $d(\\mathbf{x},\\mathbf{z}) \\le d(\\mathbf{x},\\mathbf{y}) + d(\\mathbf{y},\\mathbf{z})$ 和反三角不等式 $|d(\\mathbf{x},\\mathbf{z}) - d(\\mathbf{x},\\mathbf{y})| \\le d(\\mathbf{y},\\mathbf{z})$。假设两种树的每个叶节点都恰好存储一个点，并且最近邻搜索对每个访问到的叶节点点 $\\mathbf{p}$ 计算一次 $d(\\mathbf{q},\\mathbf{p})$，同时维护当前最优距离 $\\tau$，并仅基于几何信息来决定是否进行剪枝。\n\n构建一个对抗性数据集，使得在 $k$-d 树中查询需要线性时间，从而说明平衡 VP-树作为一种缓解方法的优势，然后分析其最坏情况下的界限。具体而言：\n\n给定一个偶数 $n \\ge 4$ 和一个半径 $R  0$，令 $P = \\{\\mathbf{p}_{k}\\}_{k=1}^{n}$ 是位于以原点为中心、半径为 $R$ 的圆上的 $n$ 个点的集合，其中 $\\mathbf{p}_{k} = \\big(R\\cos(2\\pi k/n),\\, R\\sin(2\\pi k/n)\\big)$。设查询点为 $\\mathbf{q} = (0,0)$。构建：\n- 一个平衡的 $k$-d 树，通过在等于节点中各点坐标值中位数的阈值处，递归地沿交替的坐标轴进行分割，以及\n- 一个平衡的 vantage-point 树（VP-树），通过递归地选择节点中的任意数据点作为基准点，并选择分割半径等于该基准点到节点中其余点距离的中位数。\n\n对于这两种树，考虑标准的回溯最近邻搜索算法：该算法首先下降到包含 $\\mathbf{q}$ 的一侧，到达叶节点时更新 $\\tau$，然后在内部节点回溯时，当且仅当几何上不排除存在距离严格小于当前最优值 $\\tau$ 的点的可能性时，才探索另一侧的子节点。\n\n任务：\n- 仅使用上述定义和欧几里得几何，从第一性原理出发，推导每种树的搜索所使用的几何剪枝条件（用 $d(\\mathbf{q},\\cdot)$、$\\tau$ 和节点的分割几何来表示），不得借助任何已有的算法快捷公式。\n- 证明对于数据集 $P$ 和查询 $\\mathbf{q}$，平衡 $k$-d 树的最近邻搜索会访问每个叶节点，因此计算 $T_{\\mathrm{kd}}(n)$ 次点到查询的距离，其中 $T_{\\mathrm{kd}}(n)$ 是表示为 $n$ 的函数的叶节点距离计算的精确次数。\n- 证明对于相同的 $P$ 和 $\\mathbf{q}$，平衡 VP-树的最近邻搜索同样会访问每个叶节点，因此计算 $T_{\\mathrm{vp}}(n)$ 次点到查询的距离，其中 $T_{\\mathrm{vp}}(n)$ 是表示为 $n$ 的函数的叶节点距离计算的精确次数。\n- 定义比率 $\\rho(n) = T_{\\mathrm{kd}}(n) / T_{\\mathrm{vp}}(n)$ 并确定其精确值。\n\n你的最终答案必须是 $\\rho(n)$ 的精确值，以单个实数形式表示。不需要四舍五入，也没有单位。将最终答案表示为单个数字。",
            "solution": "该问题被评估为有效，因为它内容自洽，在计算几何学方面有科学依据，并提出了一组明确定义的任务。其前提导向一个唯一的、可验证的解。\n\n解题过程按要求分为四个部分：推导剪枝条件，分析 $k$-d 树搜索，分析 VP-树搜索，以及计算最终的比率。\n\n### 第一部分：几何剪枝条件的推导\n\n设 $\\mathbf{q}$ 为查询点，$\\tau$ 为到目前为止找到的最近邻的当前最优距离。搜索算法当且仅当一个子节点所代表的空间区域无法从几何上证明不包含比 $\\tau$ 更靠近 $\\mathbf{q}$ 的点时，才会探索该子节点。这意味着，如果从 $\\mathbf{q}$ 到该区域中任何一点的最小可能距离大于或等于 $\\tau$，我们便剪除该区域。\n\n**$k$-d 树剪枝条件：**\n$k$-d 树中的一个节点用一个轴对齐的超平面（例如 $x_j=s$）将空间划分为两个子区域：$H_1 = \\{\\mathbf{x} \\in \\mathbb{R}^2 \\mid x_j \\le s\\}$ 和 $H_2 = \\{\\mathbf{x} \\in \\mathbb{R}^2 \\mid x_j  s\\}$。设搜索算法首先探索包含 $\\mathbf{q}$ 的“近”侧子节点。假设 $\\mathbf{q}$ 在 $H_1$ 中，因此其第 $j$ 个坐标 $q_j$ 满足 $q_j \\le s$。为了决定是否探索对应于区域 $H_2$ 的“远”侧子节点，我们必须找到从 $\\mathbf{q}$ 到 $H_2$ 中任意点 $\\mathbf{p}$ 的最小距离。\n欧几里得距离的平方为 $d(\\mathbf{q}, \\mathbf{p})^2 = (q_1 - p_1)^2 + (q_2 - p_2)^2$。对于 $\\mathbf{p} \\in H_2$，其第 $j$ 个坐标 $p_j$ 满足 $p_j  s$。当 $\\mathbf{p}$ 是 $\\mathbf{q}$ 在 $H_2$ 边界（即直线 $x_j=s$）上的正交投影时，距离 $d(\\mathbf{q}, \\mathbf{p})$ 最小。$H_2$ 中离 $\\mathbf{q}$ 最近的点无限接近于分割线上的一点，该点的坐标与 $\\mathbf{q}$ 相同，除了在第 $j$ 维上为 $s$。因此，最小距离就是 $\\mathbf{q}$ 到分割超平面的距离：\n$$ \\min_{\\mathbf{p} \\in H_2} d(\\mathbf{q}, \\mathbf{p}) = |q_j - s| $$\n如果这个最小距离大于或等于当前最优距离 $\\tau$，搜索就剪除远侧子区域 ($H_2$)。因此，当且仅当以下条件成立时，才会探索另一侧子节点：\n$$ |q_j - s|  \\tau $$\n\n**Vantage-Point (VP) 树剪枝条件：**\nVP-树中的一个节点使用一个基准点 $\\mathbf{v}$ 和一个半径 $\\mu$ 来划分空间。两个子区域分别是“内部”区域 $R_{in} = \\{\\mathbf{p} \\in \\mathbb{R}^2 \\mid d(\\mathbf{p}, \\mathbf{v}) \\le \\mu\\}$ 和“外部”区域 $R_{out} = \\{\\mathbf{p} \\in \\mathbb{R}^2 \\mid d(\\mathbf{p}, \\mathbf{v})  \\mu\\}$。如果未访问的子区域不能被剪枝，搜索就会探索它。\n\n1.  **剪除内部区域 ($R_{in}$):** 从查询点 $\\mathbf{q}$ 到 $R_{in}$ 中任意点 $\\mathbf{p}$ 的最小距离，是由 $\\mathbf{q}$ 到球 $B(\\mathbf{v}, \\mu)$ 的距离给出的。根据三角不等式，这个距离是 $\\min_{\\mathbf{p} \\in R_{in}} d(\\mathbf{q}, \\mathbf{p}) = \\max(0, d(\\mathbf{q}, \\mathbf{v}) - \\mu)$。如果这个最小距离 $\\ge \\tau$，我们就剪除 $R_{in}$，这要求 $d(\\mathbf{q}, \\mathbf{v}) - \\mu \\ge \\tau$，即：\n    $$ d(\\mathbf{q}, \\mathbf{v}) \\ge \\mu + \\tau $$\n2.  **剪除外部区域 ($R_{out}$):** 从 $\\mathbf{q}$ 到 $R_{out}$ 中任意点 $\\mathbf{p}$ 的最小距离，是 $\\mathbf{q}$ 到球 $B(\\mathbf{v}, \\mu)$ 外部的距离。这个距离是 $\\min_{\\mathbf{p} \\in R_{out}} d(\\mathbf{q}, \\mathbf{p}) = \\max(0, \\mu - d(\\mathbf{q}, \\mathbf{v}))$。如果这个最小值 $\\ge \\tau$，我们就剪除 $R_{out}$，这要求 $\\mu - d(\\mathbf{q}, \\mathbf{v}) \\ge \\tau$，即：\n    $$ d(\\mathbf{q}, \\mathbf{v}) \\le \\mu - \\tau $$\n\n### 第二部分：$k$-d 树搜索分析\n\n数据集为 $P = \\{\\mathbf{p}_{k}\\}_{k=1}^{n}$，其中 $\\mathbf{p}_{k} = (R\\cos(2\\pi k/n), R\\sin(2\\pi k/n))$，$n$ 为偶数且 $n \\ge 4$，$R  0$。查询点为 $\\mathbf{q} = (0,0)$。对于 $P$ 中的任意点 $\\mathbf{p}_k$，其到查询点的距离为 $d(\\mathbf{q}, \\mathbf{p}_k) = \\sqrt{(R\\cos(2\\pi k/n))^2 + (R\\sin(2\\pi k/n))^2} = \\sqrt{R^2} = R$。\n\n搜索算法会下降到第一个叶节点，计算其点到查询点的距离，并设置初始最优距离 $\\tau = R$。由于 $P$ 中所有点到 $\\mathbf{q}$ 的距离都为 $R$，$\\tau$ 在整个搜索过程中将保持为 $R$。\n\n在任何内部节点，树会以该节点中点集在某个交替坐标（$x_1$ 或 $x_2$）上的中位数 $s$ 进行分割。查询点为 $\\mathbf{q}=(0,0)$，其坐标为 $q_1=0$ 和 $q_2=0$。跨越分割线 $x_j=s$ 探索远侧子节点的条件是 $|q_j - s|  \\tau$，即 $|0 - s|  R$，或 $|s|  R$。\n\n我们必须证明，对于树中的任何分割，中位数 $s$ 都满足 $|s|  R$。\n分割在包含点子集 $S \\subseteq P$（其中 $|S| \\ge 2$）的节点上执行。$S$ 中的所有点都位于半径为 $R$ 的圆上。假设分割是基于第 $j$ 个坐标。$S$ 中各点的坐标值为 $\\{p_j \\mid \\mathbf{p} \\in S\\}$。由于 $S$ 中的每个点 $\\mathbf{p}$ 都在圆上，其坐标满足 $|p_j| \\le R$。这些值的中位数 $s$ 被定义为 $S$ 中某个点的坐标，或两个这样坐标的平均值。无论哪种情况，中位数 $s$ 必须在坐标值的范围内，因此 $|s| \\le \\max_{\\mathbf{p} \\in S} |p_j| \\le R$。\n\n要发生剪枝，需要 $|s| \\ge \\tau=R$。鉴于 $|s| \\le R$，这意味着需要 $|s| = R$。对于 $x_1=s$ 的分割，这将要求 $s \\in \\{-R, R\\}$。要使 $s=R$ 成为 $S$ 中各点 $x_1$ 坐标的中位数，$S$ 中至少有一半的点必须具有 $x_1$ 坐标为 $R$。在整个集合 $P$ 中，唯一 $x_1=R$ 的点是 $\\mathbf{p}_n = (R,0)$。由于每个叶节点存储一个唯一的点，一个包含 $|S| \\ge 2$ 个点的节点不可能有半数或更多的点是 $\\mathbf{p}_n$。因此，$x_1$ 坐标的中位数不可能是 $R$。同理，中位数也不可能是 $-R$， $y$ 坐标的中位数也不可能是 $\\pm R$。因此，对于树中的任何分割，中位数 $s$ 必须严格满足 $|s|  R$。\n\n由于不剪枝的条件 $|s|  \\tau=R$ 总是被满足，搜索算法从不进行剪枝。在每个内部节点，它都会探索两个子节点。这意味着搜索会访问树中的每个节点，包括所有叶节点。\n题目规定树的每个叶节点恰好有一个点，所以有 $n$ 个叶节点。距离计算的次数就是访问的叶节点数量。\n因此，$T_{\\mathrm{kd}}(n) = n$。\n\n### 第三部分：VP-树搜索分析\n\n数据集、查询点 $\\mathbf{q}=(0,0)$ 以及得到的最优距离 $\\tau=R$ 与之前相同。\n在任何内部节点，都会选择一个基准点 $\\mathbf{v} \\in P$。由于 $\\mathbf{v}$ 位于以原点为中心、半径为 $R$ 的圆上，它到查询点的距离为 $d(\\mathbf{q}, \\mathbf{v}) = R$。分割半径 $\\mu$ 是从 $\\mathbf{v}$ 到该节点子集中其他点的距离的中位数。\n\n将 $d(\\mathbf{q}, \\mathbf{v}) = R$ 和 $\\tau = R$ 代入剪枝条件：\n1.  剪除内部区域：$R \\ge \\mu + R \\implies \\mu \\le 0$。\n2.  剪除外部区域：$R \\le \\mu - R \\implies \\mu \\ge 2R$。\n\n我们来分析根节点处的分割半径 $\\mu$。基准点 $\\mathbf{v}$ 可以是 $P$ 中的任意点；出于对称性，我们选择 $\\mathbf{v} = \\mathbf{p}_n = (R,0)$。我们需要找到对于 $k \\in \\{1, 2, \\dots, n-1\\}$ 的 $n-1$ 个距离 $d(\\mathbf{p}_k, \\mathbf{v})$ 的中位数。\n距离的平方是：\n$d(\\mathbf{p}_k, \\mathbf{v})^2 = (R\\cos(2\\pi k/n) - R)^2 + (R\\sin(2\\pi k/n) - 0)^2$\n$d(\\mathbf{p}_k, \\mathbf{v})^2 = R^2(\\cos^2(2\\pi k/n) - 2\\cos(2\\pi k/n) + 1 + \\sin^2(2\\pi k/n))$\n$d(\\mathbf{p}_k, \\mathbf{v})^2 = R^2(2 - 2\\cos(2\\pi k/n)) = 4R^2\\sin^2(\\pi k/n)$\n$d(\\mathbf{p}_k, \\mathbf{v}) = 2R\\sin(\\pi k/n)$，因为 $k \\in \\{1, \\dots, n-1\\}$ 保证了 $\\sin(\\pi k/n) > 0$。\n\n距离集合为 $\\{ 2R\\sin(\\pi k/n) \\}_{k=1}^{n-1}$。由于正弦函数的对称性，$\\sin(\\pi k/n) = \\sin(\\pi(n-k)/n)$，所以 $k$ 和 $n-k$ 对应的距离是相同的。这组值由每个出现两次的 $d_k$（对于 $k \\in \\{1, \\dots, n/2-1\\}$）和出现一次的 $d_{n/2} = 2R\\sin(\\pi/2)=2R$ 组成。总距离数量为 $2(n/2-1)+1=n-1$。\n我们需要这个包含 $n-1$ 个数的列表的中位数。我们将它们排序以找到位于第 $(n-1+1)/2 = n/2$ 位置的项。排序后的唯一值为 $v_j = 2R\\sin(j\\pi/n)$，其中 $j=1, \\dots, n/2$。完整的排序列表是 $v_1, v_1, v_2, v_2, \\dots$。第 $m$ 个位置的元素是 $v_{\\lceil m/2 \\rceil}$。对于中位数，我们需要第 $m=n/2$ 个位置的元素。\n中位数半径为 $\\mu = v_{\\lceil (n/2)/2 \\rceil} = v_{\\lceil n/4 \\rceil} = 2R\\sin(\\lceil n/4 \\rceil \\pi / n)$。\n\n令 $\\theta = \\lceil n/4 \\rceil \\pi / n$。我们需要检查是否 $\\mu \\le 0$ 或 $\\mu \\ge 2R$。\n由于 $n \\ge 4$，我们有 $n/4 \\ge 1$，所以 $\\lceil n/4 \\rceil \\ge 1$，这意味着 $\\theta > 0$ 且 $\\sin(\\theta)>0$，因此 $\\mu > 0$。“内部”区域永远不会被剪枝。\n对于“外部”区域，我们检查是否 $\\mu \\ge 2R$，即 $2R\\sin(\\theta) \\ge 2R \\implies \\sin(\\theta) \\ge 1$。\n由于 $\\sin(\\theta) \\le 1$，这将要求 $\\sin(\\theta) = 1$，即 $\\theta = \\pi/2$。这意味着 $\\lceil n/4 \\rceil / n = 1/2$，或 $\\lceil n/4 \\rceil = n/2$。\n令 $x = n/4$。我们需要 $\\lceil x \\rceil = 2x$。如果 $x$ 是整数，则 $x=2x \\implies x=0 \\implies n=0$，这是不允许的。如果 $x$ 不是整数，令 $x=k+\\epsilon$，其中 $k$ 为整数且 $0  \\epsilon  1$。$\\lceil k+\\epsilon \\rceil = k+1$。所以 $k+1 = 2(k+\\epsilon) \\implies k+1=2k+2\\epsilon \\implies k=1-2\\epsilon$。由于 $k$ 是整数，这对于 $0  \\epsilon  1$ 是不可能的。\n实际上，对于 $x \\in (0, 1/2]$ 且 $x=k/2$ 的情况，$\\lceil x \\rceil = 2x$ 成立，例如 $x=1/2$。$\\lceil 1/2 \\rceil = 1$，$2(1/2)=1$。所以 $n/4 = 1/2 \\implies n=2$。\n然而，问题指定了 $n \\ge 4$。对于 $n \\ge 4$，$n/4 \\ge 1$，所以 $\\lceil n/4 \\rceil = n/2$ 是不可能的。\n因此，$\\sin(\\theta)  1$，这意味着 $\\mu  2R$。\n\n在根节点处，两个剪枝条件（$\\mu \\le 0$ 或 $\\mu \\ge 2R$）都不能满足。相同的逻辑适用于任何子问题。树的任何层级的节点都包含 $P$ 的一个子集，所有点仍然位于半径为 $R$ 的圆上。查询点仍然是 $\\mathbf{q}=(0,0)$，找到的最优距离将永远是 $\\tau=R$。任何子问题的中位数半径 $\\mu$ 也将是一条弦长，因此严格介于 $0$ 和 $2R$ 之间。\n因此，在 VP-树的搜索中也从不发生剪枝。搜索必须访问每个叶节点。由于树有 $n$ 个叶节点，距离计算的次数是：\n$T_{\\mathrm{vp}}(n) = n$。\n\n### 第四部分：比率 $\\rho(n)$ 的计算\n\n比率 $\\rho(n)$ 定义为 $T_{\\mathrm{kd}}(n) / T_{\\mathrm{vp}}(n)$。\n使用前面部分的结果：\n$$ \\rho(n) = \\frac{T_{\\mathrm{kd}}(n)}{T_{\\mathrm{vp}}(n)} = \\frac{n}{n} = 1 $$\n该比率精确为 $1$。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}