{
    "hands_on_practices": [
        {
            "introduction": "掌握了理论之后，首要任务是将其应用于实际问题。本练习将指导您在一个简单的网格上，对一个包含平流和扩散项的稳态方程进行离散化。通过使用迎风格式处理平流项 ，您将练习如何将一个微分方程转化为一个线性方程组，并求解特定点的数值解，这是数值方法中的一项基本功。",
            "id": "1127421",
            "problem": "考虑定义域 $x \\in [0, L]$ 上的一维稳态对流扩散方程：\n$$\nu \\frac{d\\phi}{dx} - \\Gamma \\frac{d^2\\phi}{dx^2} = S_0\n$$\n其中，$u  0$ 为恒定速度，$\\Gamma  0$ 为恒定扩散系数，$S_0$ 为恒定源项。边界条件由 $\\phi(0) = \\phi_A$ 和 $\\phi(L) = \\phi_B$ 给出。\n\n该域使用包含 $N=4$ 个区间的均匀网格进行离散化，得到网格点 $x_i = i\\Delta x$，其中 $i=0, 1, 2, 3, 4$，$\\Delta x = L/N$。令 $\\phi_i$ 表示 $\\phi(x_i)$ 的数值近似解。\n\n使用有限差分法求解内部节点（$i=1, 2, 3$）处的 $\\phi_i$ 值。扩散项使用二阶中心差分格式进行近似。由于该问题是对流主导的，对流项使用一阶迎风格式（或“迎风差分格式”，UDS）进行近似。已知 $u0$，流动方向从左到右。\n\n使用此数值格式，确定域中点 $\\phi_2 = \\phi(x_2 = L/2)$ 处的解的值。将您的答案表示为由给定参数 $u, \\Gamma, S_0, L, \\phi_A$ 和 $\\phi_B$ 组成的单个符号表达式。",
            "solution": "问题要求解给定对流扩散方程在网格点 $x_2=L/2$ 处的数值解 $\\phi_2$。该域被离散为 $N=4$ 个区间，因此网格间距为 $\\Delta x = L/4$。网格点为 $x_0=0, x_1=L/4, x_2=L/2, x_3=3L/4, x_4=L$。未知数为内部节点处的值：$\\phi_1, \\phi_2, \\phi_3$。边界值为已知：$\\phi_0 = \\phi_A$ 和 $\\phi_4 = \\phi_B$。\n\n稳态对流扩散方程为：\n$$u \\frac{d\\phi}{dx} - \\Gamma \\frac{d^2\\phi}{dx^2} = S_0$$\n\n我们在内部网格点 $x_i$ 处对此方程进行离散化。\n扩散项使用二阶中心差分格式进行离散化：\n$$ \\left.\\frac{d^2\\phi}{dx^2}\\right|_{x_i} \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2} $$\n对流项使用一阶迎风格式进行离散化。由于 $u  0$，流动方向从左到右，因此我们使用“迎风”方向（即左侧）的值：\n$$ \\left.\\frac{d\\phi}{dx}\\right|_{x_i} \\approx \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} $$\n\n将这些近似代入偏微分方程（PDE），我们得到内部节点 $i$ 的离散方程：\n$$ u \\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right) - \\Gamma \\left(\\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{(\\Delta x)^2}\\right) = S_0 $$\n该方程对 $i=1, 2, 3$ 成立。\n\n为简化起见，我们将整个方程乘以 $(\\Delta x)^2$：\n$$ u \\Delta x (\\phi_i - \\phi_{i-1}) - \\Gamma (\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}) = S_0 (\\Delta x)^2 $$\n现在，我们按 $\\phi_{i-1}$、$\\phi_i$ 和 $\\phi_{i+1}$ 对各项进行分组：\n$$ (-u \\Delta x - \\Gamma) \\phi_{i-1} + (u \\Delta x + 2\\Gamma) \\phi_i - \\Gamma \\phi_{i+1} = S_0 (\\Delta x)^2 $$\n该方程可以写成一个三对角系统。我们为每个内部节点（$i=1, 2, 3$）写出该方程：\n\n对于 $i=1$：\n$$ (-u \\Delta x - \\Gamma) \\phi_0 + (u \\Delta x + 2\\Gamma) \\phi_1 - \\Gamma \\phi_2 = S_0 (\\Delta x)^2 $$\n由于 $\\phi_0 = \\phi_A$，我们有：\n$$ (u \\Delta x + 2\\Gamma) \\phi_1 - \\Gamma \\phi_2 = S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A \\quad (1) $$\n\n对于 $i=2$：\n$$ (-u \\Delta x - \\Gamma) \\phi_1 + (u \\Delta x + 2\\Gamma) \\phi_2 - \\Gamma \\phi_3 = S_0 (\\Delta x)^2 \\quad (2) $$\n\n对于 $i=3$：\n$$ (-u \\Delta x - \\Gamma) \\phi_2 + (u \\Delta x + 2\\Gamma) \\phi_3 - \\Gamma \\phi_4 = S_0 (\\Delta x)^2 $$\n由于 $\\phi_4 = \\phi_B$，我们有：\n$$ (-u \\Delta x - \\Gamma) \\phi_2 + (u \\Delta x + 2\\Gamma) \\phi_3 = S_0 (\\Delta x)^2 + \\Gamma \\phi_B \\quad (3) $$\n\n我们得到了一个关于三个未知数 $\\phi_1, \\phi_2, \\phi_3$ 的三元线性方程组。我们需要求解 $\\phi_2$。使用代入法很方便。我们从(1)式中分离出 $\\phi_1$，从(3)式中分离出 $\\phi_3$：\n\n由(1)式得：\n$$ \\phi_1 = \\frac{S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A + \\Gamma \\phi_2}{u \\Delta x + 2\\Gamma} $$\n\n由(3)式得：\n$$ \\phi_3 = \\frac{S_0 (\\Delta x)^2 + \\Gamma \\phi_B + (u \\Delta x + \\Gamma) \\phi_2}{u \\Delta x + 2\\Gamma} $$\n\n现在，将 $\\phi_1$ 和 $\\phi_3$ 的表达式代入方程(2)：\n$$ -(u \\Delta x + \\Gamma) \\left( \\frac{S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A + \\Gamma \\phi_2}{u \\Delta x + 2\\Gamma} \\right) + (u \\Delta x + 2\\Gamma) \\phi_2 - \\Gamma \\left( \\frac{S_0 (\\Delta x)^2 + \\Gamma \\phi_B + (u \\Delta x + \\Gamma) \\phi_2}{u \\Delta x + 2\\Gamma} \\right) = S_0 (\\Delta x)^2 $$\n\n将整个方程乘以 $(u \\Delta x + 2\\Gamma)$ 以消去分母：\n$$ -(u \\Delta x + \\Gamma) \\left[ S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma) \\phi_A + \\Gamma \\phi_2 \\right] + (u \\Delta x + 2\\Gamma)^2 \\phi_2 - \\Gamma \\left[ S_0 (\\Delta x)^2 + \\Gamma \\phi_B + (u \\Delta x + \\Gamma) \\phi_2 \\right] = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) $$\n\n现在，将所有含 $\\phi_2$ 的项收集到左侧，所有其他项收集到右侧：\n$$ \\phi_2 \\left[ -(u \\Delta x + \\Gamma)\\Gamma + (u \\Delta x + 2\\Gamma)^2 - \\Gamma(u \\Delta x + \\Gamma) \\right] = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + (u \\Delta x + \\Gamma)(S_0 (\\Delta x)^2 + (u \\Delta x + \\Gamma)\\phi_A) + \\Gamma(S_0 (\\Delta x)^2 + \\Gamma\\phi_B) $$\n\n简化 $\\phi_2$ 的系数：\n$$ \\text{Coeff}(\\phi_2) = (u \\Delta x + 2\\Gamma)^2 - 2\\Gamma(u \\Delta x + \\Gamma) $$\n$$ = (u^2(\\Delta x)^2 + 4u\\Delta x\\Gamma + 4\\Gamma^2) - (2u\\Delta x\\Gamma + 2\\Gamma^2) $$\n$$ = u^2(\\Delta x)^2 + 2u\\Delta x\\Gamma + 2\\Gamma^2 $$\n\n简化右侧项 (RHS)：\n$$ \\text{RHS} = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + S_0 (\\Delta x)^2(u \\Delta x + \\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + S_0 (\\Delta x)^2 \\Gamma + \\Gamma^2 \\phi_B $$\n$$ = S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma + u \\Delta x + \\Gamma + \\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = S_0 (\\Delta x)^2 (2u \\Delta x + 4\\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = 2S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n\n现在，求解 $\\phi_2$：\n$$ \\phi_2 = \\frac{2S_0 (\\Delta x)^2 (u \\Delta x + 2\\Gamma) + (u \\Delta x + \\Gamma)^2 \\phi_A + \\Gamma^2 \\phi_B}{u^2(\\Delta x)^2 + 2u\\Delta x\\Gamma + 2\\Gamma^2} $$\n\n最后，我们代入 $\\Delta x = L/4$：\n$u \\Delta x = uL/4$ 且 $(\\Delta x)^2 = L^2/16$。\n\n分子：\n$$ \\text{Num} = 2S_0 \\frac{L^2}{16} \\left(\\frac{uL}{4} + 2\\Gamma\\right) + \\left(\\frac{uL}{4} + \\Gamma\\right)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = \\frac{S_0 L^2}{8} \\left(\\frac{uL+8\\Gamma}{4}\\right) + \\left(\\frac{uL+4\\Gamma}{4}\\right)^2 \\phi_A + \\Gamma^2 \\phi_B $$\n$$ = \\frac{S_0 L^2(uL+8\\Gamma)}{32} + \\frac{(uL+4\\Gamma)^2}{16} \\phi_A + \\Gamma^2 \\phi_B $$\n为了合并各项，使用公分母 32：\n$$ = \\frac{1}{32} \\left[ S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B \\right] $$\n\n分母：\n$$ \\text{Denom} = u^2 \\left(\\frac{L^2}{16}\\right) + 2u\\left(\\frac{L}{4}\\right)\\Gamma + 2\\Gamma^2 $$\n$$ = \\frac{u^2 L^2}{16} + \\frac{uL\\Gamma}{2} + 2\\Gamma^2 $$\n使用公分母 16：\n$$ = \\frac{1}{16} \\left[ u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2 \\right] $$\n\n现在，计算分数 $\\phi_2 = \\text{Num}/\\text{Denom}$：\n$$ \\phi_2 = \\frac{\\frac{1}{32} \\left[ S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B \\right]}{\\frac{1}{16} \\left[ u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2 \\right]} $$\n$$ \\phi_2 = \\frac{16}{32} \\frac{S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B}{u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2} $$\n$$ \\phi_2 = \\frac{S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B}{2(u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2)} $$\n这就是 $\\phi_2$ 的最终表达式。",
            "answer": "$$ \\boxed{\\frac{S_0 L^2(uL+8\\Gamma) + 2(uL+4\\Gamma)^2 \\phi_A + 32\\Gamma^2 \\phi_B}{2(u^2 L^2 + 8uL\\Gamma + 32\\Gamma^2)}} $$"
        },
        {
            "introduction": "数值格式的稳定性是其是否可靠的关键。这个练习将通过一个“反例”来加深您对稳定性的理解：分析一个使用了不恰当时间步进方向的迎风格式 。通过冯·诺依曼稳定性分析，您将亲手计算放大因子，并从物理上解释为什么违背信息传播方向的离散格式会导致不稳定，从而揭示数值格式与物理现实匹配的重要性。",
            "id": "3201511",
            "problem": "考虑周期域上的一维线性平流方程 $u_t + a\\,u_x = 0$，其中 $a0$ 是一个恒定的平流速度。使用间距为 $\\Delta x$、网格索引为 $j \\in \\mathbb{Z}$ 的均匀空间网格，并在离散时间 $t^n$ 对解进行采样。为了从 $t^n$ 向后步进一个时间步到 $t^{n-1} = t^n - \\Delta t_b$（其中 $\\Delta t_b  0$），假设您应用适用于 $a0$ 的标准显式前向时间、空间迎风离散格式，但步长为负，即使用\n$$\nu^{n-1}_j \\;=\\; u^{n}_j \\;+\\; \\mu\\left(u^{n}_j - u^{n}_{j-1}\\right),\n$$\n其中 $\\mu = \\dfrac{a\\,\\Delta t_b}{\\Delta x}$。\n\n从控制方程和上述离散更新式出发，使用 von Neumann 傅里叶稳定性分析（傅里叶模态放大分析）推导单个后向步的放大因子 $G(\\theta)$，其中 $\\theta$ 是与傅里叶模态 $e^{i\\theta j}$ 相关的无量纲波数。然后确定 $|G(\\theta)|$ 在所有 $\\theta \\in [-\\pi,\\pi]$ 上的最大值，并对 $a=1$，$\\Delta x = 0.1$ 和 $\\Delta t_b = 0.03$ 的情况数值计算该最大值。提供您最终的数值答案，四舍五入到四位有效数字。不需要物理单位。\n\n此外，运用数值输运的第一性原理，简要论证为何尝试使用迎风离散格式来反转平流会导致此后向步的不稳定性。",
            "solution": "首先，我们使用 von Neumann 稳定性分析推导给定格式的放大因子 $G(\\theta)$。我们考虑在时间层 $n$ 和空间网格点 $j$ 处解的单个傅里叶模态：\n$$u_j^n = \\hat{u}^n(\\theta) e^{i\\theta j}$$\n其中 $\\theta = k \\Delta x$ 是无量纲波数，$k$ 是波数，$\\hat{u}^n(\\theta)$ 是在时间 $t^n$ 时该模态的振幅。该格式将解从时间 $t^n$推进到更早的时间 $t^{n-1}$。新时间层 $n-1$ 的解通过放大因子 $G(\\theta)$ 与旧时间层 $n$ 的解相关联：\n$$u_j^{n-1} = G(\\theta) u_j^n = G(\\theta) \\hat{u}^n(\\theta) e^{i\\theta j}$$\n我们将这些傅里叶模态表示代入给定的有限差分格式：\n$$u^{n-1}_j = u^{n}_j + \\mu\\left(u^{n}_j - u^{n}_{j-1}\\right)$$\n$$G(\\theta) \\hat{u}^n(\\theta) e^{i\\theta j} = \\hat{u}^n(\\theta) e^{i\\theta j} + \\mu\\left(\\hat{u}^n(\\theta) e^{i\\theta j} - \\hat{u}^n(\\theta) e^{i\\theta (j-1)}\\right)$$\n将整个方程除以 $\\hat{u}^n(\\theta) e^{i\\theta j}$（非零），我们得到放大因子 $G(\\theta)$ 的表达式：\n$$G(\\theta) = 1 + \\mu\\left(1 - e^{-i\\theta}\\right)$$\n使用欧拉公式 $e^{-i\\theta} = \\cos(\\theta) - i\\sin(\\theta)$，我们可以将 $G(\\theta)$ 写成其实部和虚部的形式：\n$$G(\\theta) = (1 + \\mu(1 - \\cos(\\theta))) + i(\\mu\\sin(\\theta))$$\n\n接下来，我们确定放大因子的模 $|G(\\theta)|$。模的平方由 $|G(\\theta)|^2 = (\\text{Re}[G(\\theta)])^2 + (\\text{Im}[G(\\theta)])^2$ 给出：\n$$|G(\\theta)|^2 = \\left(1 + \\mu(1 - \\cos(\\theta))\\right)^2 + (\\mu\\sin(\\theta))^2$$\n$$|G(\\theta)|^2 = 1 + 2\\mu(1 - \\cos(\\theta)) + \\mu^2(1 - \\cos(\\theta))^2 + \\mu^2\\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 + 2\\mu - 2\\mu\\cos(\\theta) + \\mu^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta)) + \\mu^2\\sin^2(\\theta)$$\n$$|G(\\theta)|^2 = 1 + 2\\mu - 2\\mu\\cos(\\theta) + \\mu^2 - 2\\mu^2\\cos(\\theta) + \\mu^2(\\cos^2(\\theta) + \\sin^2(\\theta))$$\n使用恒等式 $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$：\n$$|G(\\theta)|^2 = 1 + 2\\mu - 2\\mu\\cos(\\theta) + \\mu^2 - 2\\mu^2\\cos(\\theta) + \\mu^2$$\n$$|G(\\theta)|^2 = 1 + 2\\mu + 2\\mu^2 - (2\\mu + 2\\mu^2)\\cos(\\theta)$$\n$$|G(\\theta)|^2 = (1 + 2\\mu + 2\\mu^2) - 2\\mu(1+\\mu)\\cos(\\theta)$$\n为了找到 $|G(\\theta)|$ 在所有 $\\theta \\in [-\\pi, \\pi]$ 上的最大值，我们必须找到使 $|G(\\theta)|^2$ 最大化的 $\\theta$ 值。问题陈述 $a0$，$\\Delta x0$ 和 $\\Delta t_b0$，这意味着 $\\mu = \\frac{a\\,\\Delta t_b}{\\Delta x}  0$。因此，乘以 $\\cos(\\theta)$ 的项 $2\\mu(1+\\mu)$ 是正的。因此，当 $\\cos(\\theta)$ 取最小值时， $|G(\\theta)|^2$ 取最大值。在区间 $[-\\pi, \\pi]$ 内，$\\cos(\\theta)$ 的最小值为 $-1$，这在 $\\theta = \\pm \\pi$ 时出现。\n将 $\\cos(\\theta) = -1$ 代入 $|G(\\theta)|^2$ 的表达式中：\n$$\\max_{\\theta} |G(\\theta)|^2 = (1 + 2\\mu + 2\\mu^2) - 2\\mu(1+\\mu)(-1)$$\n$$\\max_{\\theta} |G(\\theta)|^2 = 1 + 2\\mu + 2\\mu^2 + 2\\mu + 2\\mu^2$$\n$$\\max_{\\theta} |G(\\theta)|^2 = 1 + 4\\mu + 4\\mu^2 = (1+2\\mu)^2$$\n模 $|G(\\theta)|$ 的最大值是该表达式的平方根：\n$$\\max_{\\theta} |G(\\theta)| = \\sqrt{(1+2\\mu)^2} = |1+2\\mu|$$\n由于 $\\mu  0$，这可以简化为：\n$$\\max_{\\theta} |G(\\theta)| = 1 + 2\\mu$$\n\n现在，我们使用给定值 $a=1$，$\\Delta x = 0.1$ 和 $\\Delta t_b = 0.03$ 对该最大值进行数值计算。首先，我们计算 Courant 数 $\\mu$：\n$$\\mu = \\frac{a\\,\\Delta t_b}{\\Delta x} = \\frac{1 \\times 0.03}{0.1} = 0.3$$\n将此 $\\mu$ 值代入最大放大因子的表达式中：\n$$\\max_{\\theta} |G(\\theta)| = 1 + 2(0.3) = 1 + 0.6 = 1.6$$\n按要求四舍五入到四位有效数字，该值为 $1.600$。\n\n最后，我们论证为什么这个后向步是不稳定的。控制偏微分方程 $u_t + a u_x = 0$（其中 $a0$）描述了随着时间增加，信息从左向右（沿正 $x$ 方向）传播的波。要逆转此过程，并从较晚时间 $t^n$ 的数据中找到较早时间 $t^{n-1}$ 的解，必须在时间上向后追溯信息流。这意味着要在 $(x_j, t^{n-1})$ 处求值，需要知道在较晚时间位于其右侧某点，特别是 $(x_j+a\\Delta t_b, t^n)$ 处的解。因此，对于这个时间反演问题，一个稳定的数值方法必须使用右侧网格点（例如 $u^n_j$ 和 $u^n_{j+1}$）的信息来计算 $u^{n-1}_j$。\n所提供的格式 $u^{n-1}_j = u^{n}_j + \\mu(u^{n}_j - u^{n}_{j-1})$ 使用了后向空间差分，整合了来自网格点 $j$ 和 $j-1$ 的信息。对于 $a0$ 的正向时间问题，这是一个“迎风”模板。然而，对于时间反演问题，它实际上是一个“顺风”模板，因为它相对于特征线从错误的方向获取信息。对于显式平流格式使用顺风模板违反了 Courant-Friedrichs-Lewy (CFL) 条件，因为物理依赖域完全位于数值依赖域之外。von Neumann 分析证实了这种不稳定性，表明放大因子 $|G(\\theta)|$ 的最大值为 $1+2\\mu$，对于任何 $\\mu  0$ 都严格大于 $1$。任何具有非零振幅的数值模态都将在单步内被放大，导致指数级误差增长和无条件不稳定性。",
            "answer": "$$\n\\boxed{1.600}\n$$"
        },
        {
            "introduction": "从理论到实践的飞跃是计算科学学习中的关键一步。本练习要求您编写一个完整的程序来实现一阶迎风格式，并通过一系列单元测试来验证其核心数学特性 。您将通过编码来检验格式的守恒性、有界性以及在特定条件下的精确性，这不仅能巩固您对理论的理解，还能培养严谨的科学计算软件开发习惯。",
            "id": "3201531",
            "problem": "您需要实现并验证一维线性平流方程在一维周期性域上的一阶迎风有限差分法。控制偏微分方程为 $u_t + a\\,u_x = 0$，其中平流速度 $a$ 为常数，$u(x,t)$ 是被平流的场。离散化应在长度为 $L$ 的周期性区间上的均匀网格上进行，该网格包含 $N$ 个点，网格点为 $x_i = i\\,\\Delta x$，$i \\in \\{0,1,\\dots,N-1\\}$，且 $\\Delta x = L/N$。假设 $a  0$ 并施加周期性边界条件，使得索引 $0$ 的左邻点为索引 $N-1$。时间积分必须使用与一阶迎风差分相一致的单步显式方法；等效地，使用时间步长为 $\\Delta t$ 的 Courant-Friedrichs-Lewy (CFL) 数 $C = a\\,\\Delta t/\\Delta x$ 来进行计算，并实现典型的正速度迎风更新。您不能假设任何特定的解析解；相反，您需要验证离散化本身的性质。\n\n您的任务是编写一个完整的程序，该程序能够：\n1. 在周期性网格上为 $a0$ 和给定的 CFL 数 $C$ 实现一阶迎风格式。\n2. 执行以下四个单元测试，每个测试使用下面指定的确切参数值，并返回一个表示通过或失败的布尔值。所有涉及浮点运算的比较都必须使用 $\\varepsilon = 10^{-12}$ 的容差。\n\n测试 A (常数平移下的不变性):\n- 参数: $N = 200$, $L = 1$, $a = 1$, $C = 0.3$, 时间步数 $K = 100$.\n- 网格: $x_i = i\\,\\Delta x$  且 $\\Delta x = L/N$。\n- 初始条件 $u^0_i = \\sin(2\\pi x_i) + 0.2\\cos(4\\pi x_i)$。\n- 常数平移 $\\kappa = 0.7$。\n- 对 $u^0$ 和 $u^0 + \\kappa$ 分别运行该格式 $K$ 步。令 $u^{K}$ 和 $\\tilde{u}^{K}$ 表示两个最终状态。如果 $\\max_i \\left| \\left(\\tilde{u}^{K}_i - u^{K}_i\\right) - \\kappa \\right| \\le \\varepsilon$，则测试通过。\n\n测试 B (周期性边界下的守恒性):\n- 参数: $N = 256$, $L = 2$, $a = 0.8$, $C = 0.6$, 时间步数 $K = 150$。\n- 网格: $x_i = i\\,\\Delta x$ 且 $\\Delta x = L/N$。\n- 初始条件 $u^0_i = 0.5 + 0.25\\sin\\!\\left(2\\pi x_i/L\\right) + 0.1\\cos\\!\\left(6\\pi x_i/L\\right)$。\n- 运行该格式 $K$ 步以获得 $u^{K}$。如果 $\\left| \\sum_{i=0}^{N-1} u^{K}_i - \\sum_{i=0}^{N-1} u^{0}_i \\right| \\le \\varepsilon$，则测试通过。\n\n测试 C ($0 \\le C \\le 1$ 时的有界性保持):\n- 参数: $N = 300$, $L = 1$, $a = 1$, $C = 0.95$, 时间步数 $K = 400$。\n- 网格: $x_i = i\\,\\Delta x$ 且 $\\Delta x = L/N$。\n- 初始条件 $u^0_i = 0.3 + 0.4\\sin^2(2\\pi x_i)$，因此 $\\min_i u^0_i = 0.3$ 且 $\\max_i u^0_i = 0.7$。\n- 运行该格式 $K$ 步，在每一步 $n$ 后检查 $\\min_i u^n_i \\ge 0.3 - \\varepsilon$ 和 $\\max_i u^n_i \\le 0.7 + \\varepsilon$ 是否成立。如果这两个不等式对所有步数 $n \\in \\{1,2,\\dots,K\\}$ 都成立，则测试通过。\n\n测试 D ($C=1$ 时阶跃平移的精确性):\n- 参数: $N = 128$, $L = 1$, $a = 1$, $C = 1$, 时间步数 $K = 37$。\n- 通过选择 $m_0 = 40$ 并在网格索引上定义一个阶跃初始条件，如果 $i  m_0$ 则设 $u^0_i = 1$，否则 $u^0_i = 0$。\n- 运行该格式 $K$ 步以获得 $u^{K}$。对于 $C = 1$ 和 $a  0$，迎风更新变为每步一个网格单元的纯循环移位。如果对于所有 $i$，$u^{K}_i = u^0_{(i-K)\\bmod N}$ 在容差 $\\varepsilon$ 内成立，则测试通过；等效地，如果 $\\max_i |u^{K}_i - u^0_{(i-K)\\bmod N}| \\le \\varepsilon$。\n\n实现要求：\n- 仅使用均匀周期性网格和适用于 $a0$ 的一阶迎风差分。\n- 完全按照上面给出的值使用指定的参数。\n- 对所有浮点比较使用容差 $\\varepsilon = 10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 A、B、C 和 D 的四个布尔结果，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，\"[True,False,True,True]\"）。程序必须是自包含的，并且不得读取任何输入。\n\n注意：本问题无需物理单位。三角函数中出现的所有角度均以弧度为单位。要求的输出值严格为布尔值。",
            "solution": "该问题是有效的，因为它提出了一个来自计算科学领域的适定 (well-posed) 且科学上合理的任务：实现并验证用于线性平流方程的一阶迎风法。所有参数和条件都得到了充分指定且一致。\n\n解决方案首先推导数值格式，然后实现四个指定的测试，每个测试都旨在验证离散化的一个基本性质。\n\n控制偏微分方程 (PDE) 是一维线性平流方程：\n$$\nu_t + a\\,u_x = 0\n$$\n其中 $u(x,t)$ 是被平流的标量场，$t$ 是时间，$x$ 是空间坐标，$a$ 是恒定的平流速度，给定为正值 ($a  0$)。该方程在一个长度为 $L$ 的周期性域上求解。\n\n该域被离散化为一个具有 $N$ 个点的均匀网格，索引为 $i \\in \\{0, 1, \\dots, N-1\\}$。网格点位于 $x_i = i\\,\\Delta x$，其中网格间距为 $\\Delta x = L/N$。在时间 $t_n = n\\,\\Delta t$ 时该网格上的解用向量 $u^n$ 表示，其分量为 $u_i^n \\approx u(x_i, t_n)$。\n\n为了推导数值更新规则，我们逐项对PDE进行离散化。对于时间导数 $u_t$，我们使用一阶前向欧拉格式：\n$$\nu_t \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n对于空间导数 $u_x$，我们使用一阶迎风法。由于平流速度 $a$ 为正，信息流（或“风”）从左向右（从较小的 $x$ 到较大的 $x$）流动。因此，网格点 $x_i$ 处的空间导数应使用 $x_i$ 处的值及其“迎风”邻点 $x_{i-1}$ 处的值来近似。这对应于一阶后向差分：\n$$\nu_x \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n将这些离散近似代入 PDE，得到完全离散化的方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_i^n - u_{i-1}^n}{\\Delta x} \\right) = 0\n$$\n整理以求解下一个时间步的解 $u_i^{n+1}$，得到：\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n)\n$$\n我们定义 Courant-Friedrichs-Lewy (CFL) 数为无量纲量 $C = a\\,\\Delta t/\\Delta x$。将 $C$ 代入方程，得到最终的更新规则：\n$$\nu_i^{n+1} = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\n这可以重写为：\n$$\nu_i^{n+1} = (1 - C)u_i^n + C u_{i-1}^n\n$$\n这种形式特别有启发性。问题指定了周期性边界条件，这意味着域是环形的。对于网格点 $i=0$，其左邻点 $i-1$ 是网格上的最后一个点 $i=N-1$。这可以通过对索引使用模运算或更高效地通过对解向量使用循环移位操作来实现。\n\n四个测试验证了此数值格式的关键性质。\n\n测试 A (常数平移下的不变性)：该格式是作用于解向量 $u^n$ 的一个线性算子。设单步时间演化的算子为 $S_C$，则 $u^{n+1} = S_C(u^n)$。$K$ 步的算子是 $S_C^K$。线性意味着 $S_C^K(u^0 + \\kappa \\mathbf{1}) = S_C^K(u^0) + S_C^K(\\kappa \\mathbf{1})$，其中 $\\mathbf{1}$ 是全为1的向量，$\\kappa$ 是一个常数。对于一个常数场 $u_i^n = \\kappa$ (对所有 $i$)，更新规则给出 $u_i^{n+1} = (1-C)\\kappa + C\\kappa = \\kappa$。因此，常数场是一个稳态，且 $S_C^K(\\kappa \\mathbf{1}) = \\kappa \\mathbf{1}$。所以，初始平移场的最终状态应该是原始场最终状态的平移：$\\tilde{u}^K = u^K + \\kappa$。该测试通过检查 $\\max_i |(\\tilde{u}^K_i - u^K_i) - \\kappa|$ 是否接近于零来验证此性质。\n\n测试 B (守恒性)：该格式在周期性域上守恒总“质量”（或量的总和）。将更新规则在所有网格点 $i$ (从 $0$ 到 $N-1$)上求和：\n$$\n\\sum_{i=0}^{N-1} u_i^{n+1} = \\sum_{i=0}^{N-1} \\left( (1-C)u_i^n + C u_{i-1}^n \\right) = (1-C)\\sum_{i=0}^{N-1} u_i^n + C \\sum_{i=0}^{N-1} u_{i-1}^n\n$$\n由于周期性，值集合 $\\{u_{i-1}^n\\}_{i=0}^{N-1}$ 只是 $\\{u_i^n\\}_{i=0}^{N-1}$ 的一个循环置换，因此它们的和是相同的：$\\sum_{i=0}^{N-1} u_{i-1}^n = \\sum_{i=0}^{N-1} u_i^n$。于是方程变为：\n$$\n\\sum_{i=0}^{N-1} u_i^{n+1} = (1-C)\\sum_{i=0}^{N-1} u_i^n + C \\sum_{i=0}^{N-1} u_i^n = \\sum_{i=0}^{N-1} u_i^n\n$$\n总和在每个时间步都是守恒的。该测试通过比较初始状态的总和 $\\sum u_i^0$ 与最终状态的总和 $\\sum u_i^K$ 来验证这一点。\n\n测试 C (有界性保持)：一阶迎风格式在 CFL 条件 $0 \\le C \\le 1$ 满足时是保正和单调的。在这种情况下，更新规则 $u_i^{n+1} = (1-C)u_i^n + C u_{i-1}^n$ 中的两个系数 $(1-C)$ 和 $C$ 都是非负的。新值 $u_i^{n+1}$ 是前一时间步两个值 $u_i^n$ 和 $u_{i-1}^n$ 的凸组合。这意味着新值不能小于时间 $n$ 时所有值的最小值，也不能大于最大值。设 $m^n = \\min_i u_i^n$ 和 $M^n = \\max_i u_i^n$。那么对所有 $i$ 都有 $m^n \\le u_i^{n+1} \\le M^n$。因此，$m^{n+1} \\ge m^n$ 且 $M^{n+1} \\le M^n$，这意味着解值的范围不会随时间扩大。该测试使用 $C=0.95$，满足该条件。它正确地验证了解在所有时间步长内都保持在初始条件设定的界限内。\n\n测试 D ($C=1$ 时的精确性)：当 CFL 数恰好为 $C=1$ 时，更新规则急剧简化：\n$$\nu_i^{n+1} = (1-1)u_i^n + (1)u_{i-1}^n = u_{i-1}^n\n$$\n这意味着每个网格点 $i$ 的值都被其左邻点 $i-1$ 的值所取代。这对应于在每个时间步将整个解剖面精确地向右平移一个网格单元，而没有任何形状变化（即没有数值扩散）。经过 $K$ 个时间步后，初始剖面 $u^0$ 将向右精确平移 $K$ 个网格单元。该测试通过将数值解 $u^K$ 与循环移位 $K$ 个位置的初始解 $u^0_{(i-K)\\bmod N}$ 进行比较来验证此性质。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the first-order upwind finite difference method\n    for the 1D linear advection equation by running four unit tests.\n    \"\"\"\n    EPSILON = 1e-12\n\n    def upwind_step(u, C):\n        \"\"\"\n        Performs one step of the first-order upwind scheme for a  0.\n        The update rule is u_i^{n+1} = (1-C)u_i^n + C u_{i-1}^n.\n        This uses u_{i-1}, which means data is flowing from the left (smaller index).\n        np.roll(u, 1) shifts the array to the right, so the new element at index `i`\n        is the old element from index `i-1` (with periodic wrap-around at the boundary).\n        \"\"\"\n        u_prev = np.roll(u, 1)\n        return (1.0 - C) * u + C * u_prev\n\n    def run_simulation(u0, C, K, check_bounds_params=None):\n        \"\"\"\n        Runs the advection simulation for K steps.\n        If check_bounds_params is provided, it performs a check at every step.\n        \"\"\"\n        u = u0.copy()\n        if check_bounds_params:\n            initial_min, initial_max = check_bounds_params\n            for _ in range(K):\n                u = upwind_step(u, C)\n                if np.min(u)  initial_min - EPSILON or np.max(u) > initial_max + EPSILON:\n                    return False  # Indicate bound violation\n            return True  # Indicate all bounds were respected\n        else:\n            for _ in range(K):\n                u = upwind_step(u, C)\n            return u\n\n    def test_a():\n        \"\"\"Test A: Invariance under constant shift.\"\"\"\n        N, L, a, C, K = 200, 1.0, 1.0, 0.3, 100\n        kappa = 0.7\n        x = L * np.arange(N) / N\n        \n        u0 = np.sin(2 * np.pi * x) + 0.2 * np.cos(4 * np.pi * x)\n        u0_shifted = u0 + kappa\n        \n        uK = run_simulation(u0, C, K)\n        uK_tilde = run_simulation(u0_shifted, C, K)\n        \n        max_error = np.max(np.abs((uK_tilde - uK) - kappa))\n        return max_error = EPSILON\n\n    def test_b():\n        \"\"\"Test B: Conservation under periodic boundaries.\"\"\"\n        N, L, a, C, K = 256, 2.0, 0.8, 0.6, 150\n        x = L * np.arange(N) / N\n        \n        u0 = 0.5 + 0.25 * np.sin(2 * np.pi * x / L) + 0.1 * np.cos(6 * np.pi * x / L)\n        \n        uK = run_simulation(u0, C, K)\n        \n        sum_initial = np.sum(u0)\n        sum_final = np.sum(uK)\n        \n        error = np.abs(sum_final - sum_initial)\n        return error = EPSILON\n\n    def test_c():\n        \"\"\"Test C: Bound preservation for 0 = C = 1.\"\"\"\n        N, L, a, C, K = 300, 1.0, 1.0, 0.95, 400\n        x = L * np.arange(N) / N\n        \n        u0 = 0.3 + 0.4 * np.sin(2 * np.pi * x)**2\n        initial_min = 0.3\n        initial_max = 0.7\n        \n        return run_simulation(u0, C, K, check_bounds_params=(initial_min, initial_max))\n\n    def test_d():\n        \"\"\"Test D: Exactness at C=1 for step translation.\"\"\"\n        N, L, a, C, K = 128, 1.0, 1.0, 1.0, 37\n        m0 = 40\n        \n        u0 = np.zeros(N)\n        u0[:m0] = 1.0\n        \n        uK = run_simulation(u0, C, K)\n        \n        # For C=1, the update is u_i^{n+1} = u_{i-1}^n, a pure shift.\n        # After K steps, the solution should be shifted by K grid points to the right.\n        uK_expected = np.roll(u0, K)\n        \n        max_error = np.max(np.abs(uK - uK_expected))\n        return max_error = EPSILON\n\n    results = [\n        test_a(),\n        test_b(),\n        test_c(),\n        test_d(),\n    ]\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}