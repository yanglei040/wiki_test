{
    "hands_on_practices": [
        {
            "introduction": "三次样条的“光滑性”体现在其数学构造中，即在节点处二阶导数连续。对于自然样条，其核心任务是求解这些节点上的二阶导数值$M_i$。这个练习将引导你建立并求解一个关键的线性方程，这是构建任何自然三次样条的基础步骤。",
            "id": "2164958",
            "problem": "函数 $S(x)$ 是一个对一组数据点进行插值的自然三次样条。根据定义，三次样条是由三次多项式组成的分段函数，它本身及其一阶和二阶导数都是连续的。一个“自然”三次样条具有额外的性质，即其二阶导数在插值区间的两个端点处为零。\n\n考虑一个通过以下三个数据点的自然三次样条 $S(x)$：$(x_0, y_0) = (0, 0)$，$(x_1, y_1) = (1, 1)$ 和 $(x_2, y_2) = (2, 0)$。\n\n计算该样条在 $x=1$ 处的二阶导数的值，记为 $S''(1)$。",
            "solution": "设 $x_0=0$, $x_1=1$, $x_2=2$ 且 $y_0=0$, $y_1=1$, $y_2=0$。对于自然三次样条，其在节点处的二阶导数 $M_i=S''(x_i)$ 满足 $M_0=0$ 和 $M_2=0$，内部方程为\n$$\nh_{i-1}M_{i-1}+2(h_{i-1}+h_{i})M_{i}+h_{i}M_{i+1}\n=6\\left(\\frac{y_{i+1}-y_{i}}{h_{i}}-\\frac{y_{i}-y_{i-1}}{h_{i-1}}\\right),\n$$\n对于 $i=1,\\ldots,n-1$，其中 $h_i=x_{i+1}-x_i$。这里 $h_0=x_1-x_0=1$ 且 $h_1=x_2-x_1=1$，在 $i=1$ 处有一个唯一的内部方程：\n$$\n1\\cdot M_0+2(1+1)M_1+1\\cdot M_2\n=6\\left(\\frac{y_2-y_1}{1}-\\frac{y_1-y_0}{1}\\right).\n$$\n代入 $M_0=0$，$M_2=0$，$y_2-y_1=0-1=-1$ 和 $y_1-y_0=1-0=1$ 可得\n$$\n4M_1=6(-1-1)=6(-2)=-12,\n$$\n因此\n$$\nM_1=-3.\n$$\n因此 $S''(1)=M_1=-3$。",
            "answer": "$$\\boxed{-3}$$"
        },
        {
            "introduction": "一旦确定了二阶导数值，我们就可以构建分段三次多项式，并用它来插值。这个练习不仅会带你走完构建样条并求值的完整过程，还会将其结果与更简单的分段线性插值进行对比。通过这种对比，你可以直观地理解样条插值在生成光滑曲线方面的独特优势。",
            "id": "2164998",
            "problem": "一位工程师正在为一个薄而柔韧的杆的形状建模，该杆被约束以穿过二维笛卡尔平面中的三个点：$P_0=(-1, 1)$、$P_1=(0, 0)$ 和 $P_2=(1, 1)$。提出了两种简单的模型来估计杆在其他水平位置 $x$ 处的垂直位置 $y$。\n\n模型 A 是一个分段线性插值，它用直线段连接指定的点。\n模型 B 是一个自然三次样条插值，它通过在内部点匹配一阶和二阶导数来确保曲线的光滑性，并在端点处具有零二阶导数。\n\n计算由模型 A 和模型 B 预测的杆在 $x=0.5$ 处的垂直位置。令这些值分别为 $y_A$ 和 $y_B$。请将您的答案表示为一对精确分数 $(y_A, y_B)$。",
            "solution": "我们将节点标记为 $x_0=-1$、$x_1=0$、$x_2=1$，对应的值为 $y_0=1$、$y_1=0$、$y_2=1$。\n\n模型 A (分段线性插值)：对于 $x \\in [x_1,x_2]$，穿过 $(0,0)$ 和 $(1,1)$ 的直线的斜率为\n$$\nm=\\frac{y_2-y_1}{x_2-x_1}=\\frac{1-0}{1-0}=1,\n$$\n所以插值函数为\n$$\ny(x)=y_1+m(x-x_1)=0+1\\cdot(x-0)=x.\n$$\n在 $x=\\frac{1}{2}$ 处求值可得\n$$\ny_A=y\\left(\\frac{1}{2}\\right)=\\frac{1}{2}.\n$$\n\n模型 B (自然三次样条插值)：令 $M_i=S''(x_i)$。自然边界条件给出 $M_0=0$ 和 $M_2=0$。在 $h_0=x_1-x_0=1$ 和 $h_1=x_2-x_1=1$ 的情况下，内部节点 $i=1$ 处的三次样条方程组为\n$$\nh_0M_0+2(h_0+h_1)M_1+h_1M_2=6\\left(\\frac{y_2-y_1}{h_1}-\\frac{y_1-y_0}{h_0}\\right).\n$$\n代入这些值，\n$$\n1\\cdot 0+2(1+1)M_1+1\\cdot 0=6\\left(\\frac{1-0}{1}-\\frac{0-1}{1}\\right)=6(1-(-1))=12,\n$$\n所以\n$$\n4M_1=12 \\quad \\Rightarrow \\quad M_1=3.\n$$\n在区间 $[x_1,x_2]=[0,1]$ 上，样条函数为\n$$\nS(x)=\\frac{M_1}{6h_1}(x_2-x)^{3}+\\frac{M_2}{6h_1}(x-x_1)^{3}+\\left(y_1-\\frac{M_1h_1^{2}}{6}\\right)\\frac{x_2-x}{h_1}+\\left(y_2-\\frac{M_2h_1^{2}}{6}\\right)\\frac{x-x_1}{h_1}.\n$$\n当 $h_1=1$，$M_1=3$，$M_2=0$，$y_1=0$ 且 $y_2=1$时，上式简化为\n$$\nS(x)=\\frac{3}{6}(1-x)^{3}+0+\\left(0-\\frac{3}{6}\\right)(1-x)+\\left(1-0\\right)x\n=\\frac{1}{2}(1-x)^{3}-\\frac{1}{2}(1-x)+x.\n$$\n展开并合并同类项，\n$$\nS(x)=\\frac{1}{2}-\\frac{3}{2}x+\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}-\\frac{1}{2}+\\frac{1}{2}x+x\n=\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}.\n$$\n在 $x=\\frac{1}{2}$ 处求值可得\n$$\ny_B=S\\left(\\frac{1}{2}\\right)=\\frac{3}{2}\\left(\\frac{1}{2}\\right)^{2}-\\frac{1}{2}\\left(\\frac{1}{2}\\right)^{3}\n=\\frac{3}{2}\\cdot\\frac{1}{4}-\\frac{1}{2}\\cdot\\frac{1}{8}\n=\\frac{3}{8}-\\frac{1}{16}\n=\\frac{5}{16}.\n$$\n\n因此，所求的数对为 $\\left(\\frac{1}{2},\\frac{5}{16}\\right)$。",
            "answer": "$$\\boxed{\\left(\\frac{1}{2}, \\frac{5}{16}\\right)}$$"
        },
        {
            "introduction": "真正的精通源于实践。这个高级练习将指导你编写一个完整的自然三次样条插值程序，包括使用高效的算法求解其特有的三对角线性方程组。通过这个练习，你将把理论知识转化为解决实际问题的代码，从而彻底掌握样条插值的完整流程。",
            "id": "2384309",
            "problem": "给定在严格递增节点上采样的一维数据。对于一组节点 $x_0  x_1  \\dots  x_n$ 及其对应的值 $y_0, y_1, \\dots, y_n$，考虑由以下性质定义的唯一自然三次样条 $S(x)$：在每个区间 $[x_i, x_{i+1}]$ 上，函数 $S(x)$ 是一个三次多项式；函数 $S(x)$ 满足插值条件 $S(x_i) = y_i$（对于所有 $0 \\le i \\le n$）；一阶导数 $S'(x)$ 在 $[x_0, x_n]$ 上连续；二阶导数 $S''(x)$ 在 $[x_0, x_n]$ 上连续；以及满足自然边界条件 $S''(x_0) = 0$ 和 $S''(x_n) = 0$。您的任务是编写一个完整的程序，对下面的每个测试用例，为所提供的数据集构建唯一的自然三次样条 $S(x)$，并在指定的查询点 $x_q$ 处计算 $S(x)$ 的值。\n\n测试套件中的所有输入均在下方明确给出。每个测试用例都是独立的。在每种情况下，使用提供的数组 $x$ 和 $y$ 作为精确数据来构建 $S(x)$，然后计算标量值 $S(x_q)$。不允许也不需要任何外部数据源。所有计算都是纯数值和无量纲的；不适用任何物理单位。\n\n测试套件（每一项都是一个三元组 $(x, y, x_q)$，需按给定顺序独立处理）：\n- 测试用例 $1$：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 1.3$。\n- 测试用例 $2$：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 0.0$。\n- 测试用例 $3$：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 3.0$。\n- 测试用例 $4$：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 2.2$。\n- 测试用例 $5$：$x = [\\,-1.0,\\,2.0\\,]$，$y = [\\,-1.0,\\,4.0\\,]$，$x_q = 0.5$。\n\n您的程序必须按顺序计算上述 5 个用例中每个用例的 $S(x_q)$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。输出列表中的每个数字必须是精确到 8 位小数的浮点值。例如，要求的输出格式为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是第 $i$ 个测试用例中 $S(x_q)$ 四舍五入到 8 位小数的值。",
            "solution": "目标是根据给定的数据 $(x_i, y_i)$（其中 $0 \\le i \\le n$ 且 $x_0  x_1  \\dots  x_n$）构建唯一的自然三次样条 $S(x)$。根据定义，$S(x)$ 在每个区间 $[x_i, x_{i+1}]$ 上是分段三次的，插值数据点 $S(x_i) = y_i$，并且在 $[x_0, x_n]$ 上具有连续的一阶和二阶导数，同时满足自然边界条件 $S''(x_0) = 0$ 和 $S''(x_n) = 0$。\n\n一种标准的构建方法是引入节点上的二阶导数未知向量，记为 $M_i = S''(x_i)$（$0 \\le i \\le n$）。步长为 $h_i = x_{i+1} - x_i$（$0 \\le i \\le n-1$）。对于内部索引 $i$（$1 \\le i \\le n-1$），$S'(x)$ 和 $S''(x)$ 在节点间的连续性导出了一个关于内部二阶导数 $M_1, M_2, \\dots, M_{n-1}$ 的线性方程组：\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\n以及自然边界条件 $M_0 = 0$ 和 $M_n = 0$。当 $n=1$（即两个节点）时，没有内部未知数，自然三次样条精确地退化为两点之间的线性插值，这与 $M_0 = 0$ 和 $M_1 = 0$ 一致。\n\n该方程组关于 $(M_1, \\dots, M_{n-1})$ 的系数矩阵是三对角的，对于 $1 \\le i \\le n-1$，其元素如下：\n- 主对角线：$b_i = 2(h_{i-1} + h_i)$。\n- 次对角线：$a_i = h_{i-1}$（$i \\ge 2$）。\n- 超对角线：$c_i = h_i$（$i \\le n-2$）。\n右侧项为 $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$。\n\n对于严格递增的 $x_i$（即 $h_i > 0$），该线性系统是严格对角占优的，从而保证了唯一解的存在。一个在 $\\mathcal{O}(n)$ 时间内求解三对角线性系统的有效且精确的方法包括一个消除次对角线元素的正向消元阶段，以及一个恢复未知数的回代阶段。具体来说，设方程组用紧凑形式表示为\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{对于 } i = 1, 2, \\dots, n-1,\n$$\n其中约定 $a_1 = 0$ 且 $c_{n-1} = 0$。正向消元步骤构造修正后的对角线和右侧项：\n对于 $i = 2, 3, \\dots, n-1$，\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\n然后，回代过程计算\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{对于 } i = n-2, n-3, \\dots, 1.\n$$\n最后，设置 $M_0 = 0$ 和 $M_n = 0$ 以获得完整的向量 $(M_0, M_1, \\dots, M_n)$。\n\n在已知二阶导数的情况下，可以使用类似 Hermite 的表示法在区间 $[x_i, x_{i+1}]$ 上对任意 $x \\in [x_i, x_{i+1}]$ 计算样条值\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\n其中 $h_i = x_{i+1} - x_i$，$A = \\frac{x_{i+1} - x}{h_i}$，以及 $B = \\frac{x - x_i}{h_i}$。通过构造，该表示法满足 $S(x_i) = y_i$、$S(x_{i+1}) = y_{i+1}$ 以及连续性条件。如果 $n = 1$，则所有索引的 $M_i = 0$，公式简化为线性插值 $S(x) = A y_0 + B y_1$。\n\n要计算 $S(x_q)$，首先确定使 $x_q \\in [x_i, x_{i+1}]$ 的区间 $[x_i, x_{i+1}]$。如果 $x_q = x_n$，则选择最后一个区间 $[x_{n-1}, x_n]$。通过上述公式计算 $A$、$B$，然后计算 $S(x_q)$。对每个测试用例重复此过程，即可生成所需的标量输出。每个结果最终都四舍五入到恰好 8 位小数，并按指定顺序以单个方括号括起来的逗号分隔列表形式输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n  1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    if b[-1] == 0.0:\n        raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        if b[i] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq = x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] = xq  x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left = right:\n            mid = (left + right) // 2\n            if x[mid] = xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        # Should not happen for strictly increasing knots, but for robustness\n        return y[i]\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}