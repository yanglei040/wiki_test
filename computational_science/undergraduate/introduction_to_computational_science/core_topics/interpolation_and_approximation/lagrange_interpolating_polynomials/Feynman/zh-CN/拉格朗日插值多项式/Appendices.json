{
    "hands_on_practices": [
        {
            "introduction": "理解插值的第一步是掌握其最基本的构建方法。这个练习将引导你通过给定的数据点，建立并求解一个线性方程组，从而确定一个二次插值多项式的系数。这个过程不仅能加深你对多项式插值定义的理解，也为你将来处理更复杂问题奠定了坚实的代数基础。",
            "id": "2183505",
            "problem": "一个函数 $f(x)$ 在三个点上取值：$(x_0, f(x_0)) = (0, \\exp(-1))$，$(x_1, f(x_1)) = (1, 1)$ 和 $(x_2, f(x_2)) = (2, \\exp(1))$。利用这三个点构造一个二次拉格朗日插值多项式 $P_2(x)$ 来近似 $f(x)$。该多项式可以写成标准形式 $P_2(x) = ax^2 + bx + c$。确定系数 $a$ 的精确值。常数 $e$ 是自然对数的底。",
            "solution": "设多项式 $P_2(x)=ax^2+bx+c$ 插值这三个点。代入插值条件：\n1) $P_2(0)=c=\\exp(-1)$。\n2) $P_2(1)=a+b+c=1$，因此 $a+b=1-\\exp(-1)$。\n3) $P_2(2)=4a+2b+c=\\exp(1)$，因此 $4a+2b=\\exp(1)-\\exp(-1)$。\n\n将 $a+b=1-\\exp(-1)$ 乘以 $2$ 得到 $2a+2b=2-2\\exp(-1)$。从 $4a+2b=\\exp(1)-\\exp(-1)$ 中减去此式：\n$$\n(4a+2b)-(2a+2b)=\\left[\\exp(1)-\\exp(-1)\\right]-\\left[2-2\\exp(-1)\\right],\n$$\n化简为\n$$\n2a=\\exp(1)-2+\\exp(-1).\n$$\n因此，\n$$\na=\\frac{1}{2}\\left(\\exp(1)-2+\\exp(-1)\\right)=\\frac{\\exp(1)+\\exp(-1)}{2}-1.\n$$",
            "answer": "$$\\boxed{\\frac{\\exp(1)+\\exp(-1)}{2}-1}$$"
        },
        {
            "introduction": "在掌握了基本计算之后，理解拉格朗日插值的核心理论同样重要。本练习旨在揭示插值多项式“唯一性”定理的威力，它告诉你，在某些情况下，通过巧妙的逻辑推理可以避免复杂的计算。通过这个思想实验，你将学会如何利用理论知识来验证模型并找到解决问题的捷径。",
            "id": "2183527",
            "problem": "已知某一物理量可由一个多项式函数 $f(x)$ 描述。为了确定这个函数，进行了一项实验，得到了四个数据点 $(x_i, y_i)$:\n- $(x_0, y_0) = (0, 7)$\n- $(x_1, y_1) = (1, 7)$\n- $(x_2, y_2) = (-1, -3)$\n- $(x_3, y_3) = (2, 9)$\n\n设 $P(x)$ 是穿过这四个数据点的、次数最多为3的唯一拉格朗日插值多项式。在构建此多项式后，发现描述该物理量的真实函数恰好是 $f(x) = 2x^3 - 5x^2 + 3x + 7$。\n\n计算 $P(3)$ 的值。",
            "solution": "我们被给予了四个数据点，以及信息 $P(x)$ 是插值这些点的次数最多为 $3$ 的唯一多项式。真实的控制函数是 $f(x) = 2x^3 - 5x^2 + 3x + 7$。根据次数最多为 $3$ 的拉格朗日插值多项式的唯一性，如果 $f(x)$ 经过这相同的四个点，那么对于所有的 $x$ 都有 $P(x)=f(x)$。\n\n验证对于每个给定的点都有 $f(x_i)=y_i$：\n1) 当 $x_0=0$ 时：$f(0)=2(0)^3-5(0)^2+3(0)+7=7=y_0$。\n2) 当 $x_1=1$ 时：$f(1)=2(1)^3-5(1)^2+3(1)+7=2-5+3+7=7=y_1$。\n3) 当 $x_2=-1$ 时：$f(-1)=2(-1)^3-5(-1)^2+3(-1)+7=-2-5-3+7=-3=y_2$。\n4) 当 $x_3=2$ 时：$f(2)=2(2)^3-5(2)^2+3(2)+7=16-20+6+7=9=y_3$。\n\n由于 $f(x)$ 与所有四个数据点匹配且次数为 $3$，唯一性性质意味着 $P(x)=f(x)$。因此，\n$$\nP(3)=f(3)=2(3)^3-5(3)^2+3(3)+7=54-45+9+7=25.\n$$",
            "answer": "$$\\boxed{25}$$"
        },
        {
            "introduction": "现在，让我们将理论应用于解决一个真实的计算科学问题。均匀分布的节点在插值时可能导致“龙格现象”，即在区间端点附近产生剧烈振荡，而切比雪夫节点是应对此问题的专业解决方案。本练习要求你为传感器校准曲线进行建模，并通过编写代码来量化插值误差，这让你能亲身体验数值方法在工程实践中的强大作用。",
            "id": "3150109",
            "problem": "一位校准工程师将仪器的电压响应建模为电流的函数，表示为非线性曲线 $V(I)$。根据多项式插值的基础定义，对于 $n$ 个不同的输入电流 $I_k$ 和测量的电压 $V_k$，存在一个唯一的、次数至多为 $n-1$ 的多项式，该多项式在指定点与给定的数据对匹配。您的任务是使用旨在减少大幅振荡的节点来构造这样一个多项式插值。请使用 $n$ 个第一类切比雪夫节点，将它们从标准区间 $[-1,1]$ 线性映射到指定的电流范围 $[I_{\\min}, I_{\\max}]$。插值多项式必须从插值的第一性原理出发显式构建，确保它在所选节点处的电压值完全匹配，然后在电流范围内的密集均匀网格上进行评估，以量化最大绝对校准误差。校准误差是真实 $V(I)$ 与插值之间的绝对差，需要报告的量是该误差在网格上的上确界（通过数值近似得到）。三角函数中出现的所有角度都必须以弧度为单位进行解释。报告所有误差，单位为伏特，四舍五入到 $8$ 位小数。\n\n实现一个完整、可运行的程序，该程序：\n- 在 $[-1,1]$ 上生成 $n$ 个第一类切比雪夫节点，将它们线性映射到 $[I_{\\min}, I_{\\max}]$，在这些映射后的节点上对真实的 $V(I)$ 进行采样，构造与这些样本匹配的唯一的、次数 $\\le n-1$ 的多项式插值，并在 $[I_{\\min}, I_{\\max}]$ 上的一个包含 $M$ 个点的均匀网格上评估该插值和真实曲线。\n- 对每个测试用例，计算最大绝对校准误差 $\\max_{I \\in \\text{grid}} \\left| V(I) - P_n(I) \\right|$，其中 $P_n$ 是多项式插值。\n- 生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是第 $i$ 个测试用例的最大绝对误差（单位为伏特），四舍五入到 $8$ 位小数。输出不得包含单位符号和任何额外文本。\n\n使用以下四个科学上合理的测试用例组成的测试套件，这些用例共同检验了一个典型场景、一个边界条件、一个包含负电流的边缘范围以及一个多项式精确性检验：\n- 用例 1（典型情况）：$I_{\\min} = 0$, $I_{\\max} = 10$, $n = 8$, $M = 10001$，且\n  $$V(I) = \\ln(1 + I) + \\frac{0.02 I^3}{1 + I^2} + 0.1 \\sin(I)。$$\n- 用例 2（$n$ 的边界条件）：$I_{\\min} = 0$, $I_{\\max} = 10$, $n = 1$, $M = 10001$，且\n  $$V(I) = e^{0.1 I} + 0.5 \\cos(I)。$$\n- 用例 3（范围包含负电流）：$I_{\\min} = -5$, $I_{\\max} = 5$, $n = 20$, $M = 20001$，且\n  $$V(I) = \\frac{1}{1 + 25 I^2} + 0.2 I。$$\n- 用例 4（多项式精确性检验）：$I_{\\min} = -2$, $I_{\\max} = 2$, $n = 4$, $M = 10001$，且\n  $$V(I) = 0.7 + 1.2 I - 0.5 I^2 + 0.03 I^3。$$\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，按上述用例顺序排列，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个以伏特为单位的浮点值，四舍五入到 $8$ 位小数。$\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 中的角度应解释为弧度。数值代表伏特级别的误差；输出中不要包含单位符号。",
            "solution": "该问题要求为代表电压响应的给定函数 $V(I)$，在指定的电流区间 $[I_{\\min}, I_{\\max}]$ 上，构建一个多项式插值 $P_n(I)$。插值需在 $n$ 个被称为切比雪夫节点的离散点上进行。最终目标是计算最大绝对校准误差，该误差定义为 $|V(I) - P_n(I)|$ 在区间内一个精细均匀网格上的最大值。解决方案的步骤是：定义节点，构建插值多项式，然后评估误差。\n\n### 步骤 1：切比雪夫节点生成\n在数值分析中，使用切比雪夫节点是一种标准技术，用以最小化多项式插值的误差，特别是为了避免使用等距节点时可能在区间端点附近出现的大幅振荡（即龙格现象）。\n\n$n$ 个第一类切比雪夫节点，记为 $x_k$，在标准区间 $[-1, 1]$ 上被定义为 $n$ 次第一类切比雪夫多项式 $T_n(x)$ 的根。这些根由以下公式给出：\n$$\nx_k = \\cos\\left(\\frac{2k-1}{2n}\\pi\\right), \\quad \\text{其中 } k = 1, 2, \\ldots, n\n$$\n这些节点并非均匀分布；它们在区间端点 $-1$ 和 $1$ 附近更为密集。\n\n为了在任意区间 $[I_{\\min}, I_{\\max}]$ 上使用这些节点进行插值，我们必须应用一个线性（仿射）变换，将标准区间 $[-1, 1]$ 映射到 $[I_{\\min}, I_{\\max}]$。一个点 $x \\in [-1, 1]$ 通过以下公式映射到一个点 $I \\in [I_{\\min}, I_{\\max}]$：\n$$\nI(x) = \\frac{I_{\\max} - I_{\\min}}{2} x + \\frac{I_{\\max} + I_{\\min}}{2}\n$$\n将此映射应用于每个标准切比雪夫节点 $x_k$，即可得到目标电流范围内的 $n$ 个插值节点集合 $\\{I_k\\}_{k=1}^n$：\n$$\nI_k = \\frac{I_{\\max} - I_{\\min}}{2} \\cos\\left(\\frac{2k-1}{2n}\\pi\\right) + \\frac{I_{\\max} + I_{\\min}}{2}\n$$\n\n### 步骤 2：拉格朗日多项式插值\n给定 $n$ 个不同的插值节点 $I_k$ 和相应的测量电压值 $V_k = V(I_k)$，多项式插值基本定理保证存在一个唯一的、次数至多为 $n-1$ 的多项式 $P_n(I)$，使得对所有 $k = 1, \\ldots, n$，都有 $P_n(I_k) = V_k$。\n\n这个唯一的多项式可以使用拉格朗日形式显式构建，它将 $P_n(I)$ 表示为拉格朗日基多项式 $L_k(I)$ 的线性组合：\n$$\nP_n(I) = \\sum_{k=1}^{n} V_k L_k(I)\n$$\n基多项式定义为：\n$$\nL_k(I) = \\prod_{\\substack{j=1 \\\\ j \\neq k}}^{n} \\frac{I - I_j}{I_k - I_j}\n$$\n根据构造，每个基多项式 $L_k(I)$ 都具有在节点 $I_k$ 处等于 $1$，而在所有其他节点 $I_j$ (其中 $j \\neq k$) 处等于 $0$ 的性质，即 $L_k(I_j) = \\delta_{kj}$，其中 $\\delta_{kj}$ 是克罗内克 δ。此性质确保了插值多项式 $P_n(I)$ 精确地通过每个数据点 $(I_k, V_k)$。为了进行高效且数值稳定的计算，最好使用其重心坐标形式来评估该多项式，这是拉格朗日公式的一种代数重排。\n\n### 步骤 3：误差评估\n在任意电流 $I$ 处的校准误差是绝对差 $|V(I) - P_n(I)|$。为了找到整个区间的最大误差，我们在一个包含 $M$ 个点的密集均匀网格上评估这个差值。该网格 $\\{I'_j\\}_{j=0}^{M-1}$ 定义为：\n$$\nI'_j = I_{\\min} + j \\frac{I_{\\max} - I_{\\min}}{M-1}, \\quad \\text{其中 } j = 0, 1, \\ldots, M-1\n$$\n最大绝对校准误差 $E_{\\max}$ 随后通过取该网格上的最大值来近似：\n$$\nE_{\\max} = \\max_{j \\in \\{0, \\ldots, M-1\\}} |V(I'_j) - P_n(I'_j)|\n$$\n该值可作为误差函数真实上确界范数 $\\|V - P_n\\|_{\\infty}$ 的数值近似。\n\n### 步骤 4：特定测试用例分析\n提供的测试用例旨在针对不同条件验证实现：\n- **用例 1（$n=8$，典型情况）：** 这代表了一个典型应用，其中切比雪夫插值有望提供一个良好近似，误差虽小但非零。\n- **用例 2（$n=1$，$n$ 的边界条件）：** 当只有一个节点 $I_1 = (I_{\\min} + I_{\\max})/2$ 时，插值是一个常数多项式 $P_1(I) = V(I_1)$。其次数为 $0$，满足次数 $\\le n-1$ 的条件。\n- **用例 3（$n=20$，范围包含负电流）：** 函数 $V(I)$ 是著名的龙格函数的一个变体，该函数对于等距节点插值是有问题的。使用 $n=20$ 个切比雪夫节点预计能有效抑制振荡，从而获得低误差，展示了其优越性。\n- **用例 4（$n=4$，多项式精确性检验）：** 函数 $V(I)$ 是一个 $3$ 次多项式。由于我们使用 $n=4$ 个节点，唯一的次数至多为 $n-1=3$ 的插值多项式必须与 $V(I)$ 本身完全相同。因此，理论插值误差应精确为 $0$。计算结果应为一个在机器浮点精度量级上的值，四舍五入后为 $0.0$。此用例是对算法正确性的关键检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the maximum absolute error of a polynomial\n    interpolant constructed using Chebyshev nodes.\n    \"\"\"\n\n    # Define the true voltage functions V(I) for each case.\n    v_funcs = [\n        lambda i: np.log(1 + i) + (0.02 * i**3) / (1 + i**2) + 0.1 * np.sin(i),\n        lambda i: np.exp(0.1 * i) + 0.5 * np.cos(i),\n        lambda i: 1 / (1 + 25 * i**2) + 0.2 * i,\n        lambda i: 0.7 + 1.2 * i - 0.5 * i**2 + 0.03 * i**3\n    ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (I_min, I_max, n, M, v_func)\n        (0.0, 10.0, 8, 10001, v_funcs[0]),\n        # Case 2\n        (0.0, 10.0, 1, 10001, v_funcs[1]),\n        # Case 3\n        (-5.0, 5.0, 20, 20001, v_funcs[2]),\n        # Case 4\n        (-2.0, 2.0, 4, 10001, v_funcs[3])\n    ]\n\n    results = []\n    for case in test_cases:\n        I_min, I_max, n, M, v_func = case\n\n        # Step 1: Generate n Chebyshev nodes of the first kind\n        # Generate canonical nodes on the interval [-1, 1]\n        k = np.arange(1, n + 1)\n        x_cheb = np.cos((2 * k - 1) * np.pi / (2 * n))\n        \n        # Linearly map the canonical nodes to the target interval [I_min, I_max]\n        # These are the interpolation nodes I_k\n        I_nodes = 0.5 * (I_max - I_min) * x_cheb + 0.5 * (I_max + I_min)\n\n        # Step 2: Sample the true function V(I) at the interpolation nodes\n        # These are the corresponding values V_k\n        V_nodes = v_func(I_nodes)\n\n        # Construct the unique polynomial interpolant P_n(I).\n        # We use scipy's BarycentricInterpolator, which is a numerically stable\n        # and efficient implementation of the Lagrange interpolating polynomial.\n        # This adheres to the \"first principles\" requirement as it is a direct\n        # representation of the Lagrange polynomial in its barycentric form.\n        interpolant = BarycentricInterpolator(I_nodes, V_nodes)\n        \n        # Step 3: Evaluate on a dense uniform grid and compute error\n        # Create the uniform evaluation grid of M points\n        I_grid = np.linspace(I_min, I_max, M)\n        \n        # Evaluate the true function V(I) on the grid\n        V_true_on_grid = v_func(I_grid)\n        \n        # Evaluate the interpolating polynomial P_n(I) on the grid\n        V_interp_on_grid = interpolant(I_grid)\n        \n        # Compute the maximum absolute calibration error\n        max_error = np.max(np.abs(V_true_on_grid - V_interp_on_grid))\n        \n        # Store the result, rounded to 8 decimal places\n        results.append(f\"{max_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}