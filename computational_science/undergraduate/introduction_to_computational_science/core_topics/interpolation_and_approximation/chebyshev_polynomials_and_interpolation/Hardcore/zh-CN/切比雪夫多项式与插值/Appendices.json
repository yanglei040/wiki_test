{
    "hands_on_practices": [
        {
            "introduction": "多项式插值是一种强大的技术，但选择正确的插值点对于最小化误差至关重要。切比雪夫节点是在给定区间上进行多项式插值的最佳选择，它们被定义为切比雪夫多项式的根。本练习将通过从基本定义出发，直接计算这些关键节点，为您进行高质量的多项式近似奠定基础 。",
            "id": "2187308",
            "problem": "在数值逼近领域，为多项式插值选择函数求值点对于最小化误差至关重要。对于定义在区间 $[-1, 1]$ 上的函数，使最大可能插值误差最小化的点集被称为切比雪夫节点。对于使用最高 $n$ 次多项式进行插值，这 $n+1$ 个切比雪夫节点是 $n+1$ 次第一类切比雪夫多项式（记作 $T_{n+1}(x)$）的根。\n\n对于整数 $k \\ge 0$，切比雪夫多项式由关系式 $T_k(x) = \\cos(k \\arccos(x))$ 定义。\n\n确定对最高 3 次多项式进行最优插值所需的节点集。这对应于求 $T_4(x)$ 的根。求这四个节点的精确值。按升序列出这些节点。",
            "solution": "我们要求解在 $[-1,1]$ 上对最高 3 次多项式进行最优插值的节点。根据切比雪夫准则，这些节点是 $T_{4}(x)$ 的 4 个根，其中 $T_{k}(x)$ 由 $T_{k}(x)=\\cos(k\\arccos(x))$ 定义。\n\n令 $x=\\cos\\theta$，其中 $\\theta=\\arccos(x)$。则\n$$\nT_{4}(x)=\\cos(4\\theta).\n$$\n$T_{4}(x)$ 的根出现在\n$$\n\\cos(4\\theta)=0\n$$\n时。在 $\\theta\\in[0,\\pi]$ 中的通解为\n$$\n4\\theta=\\frac{(2m-1)\\pi}{2},\\quad m=1,2,3,4,\n$$\n所以\n$$\n\\theta_{m}=\\frac{(2m-1)\\pi}{8},\\quad m=1,2,3,4.\n$$\n因此节点为\n$$\nx_{m}=\\cos\\left(\\frac{(2m-1)\\pi}{8}\\right),\\quad m=1,2,3,4,\n$$\n即\n$$\n\\cos\\left(\\frac{\\pi}{8}\\right),\\ \\cos\\left(\\frac{3\\pi}{8}\\right),\\ \\cos\\left(\\frac{5\\pi}{8}\\right),\\ \\cos\\left(\\frac{7\\pi}{8}\\right).\n$$\n使用恒等式 $\\cos\\left(\\frac{5\\pi}{8}\\right)=-\\cos\\left(\\frac{3\\pi}{8}\\right)$ 和 $\\cos\\left(\\frac{7\\pi}{8}\\right)=-\\cos\\left(\\frac{\\pi}{8}\\right)$，以及半角值\n$$\n\\cos\\left(\\frac{\\pi}{8}\\right)=\\frac{1}{2}\\sqrt{2+\\sqrt{2}},\\quad \\cos\\left(\\frac{3\\pi}{8}\\right)=\\frac{1}{2}\\sqrt{2-\\sqrt{2}},\n$$\n按升序排列的四个节点是\n$$\n-\\frac{1}{2}\\sqrt{2+\\sqrt{2}},\\ -\\frac{1}{2}\\sqrt{2-\\sqrt{2}},\\ \\frac{1}{2}\\sqrt{2-\\sqrt{2}},\\ \\frac{1}{2}\\sqrt{2+\\sqrt{2}}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{1}{2}\\sqrt{2+\\sqrt{2}} & -\\frac{1}{2}\\sqrt{2-\\sqrt{2}} & \\frac{1}{2}\\sqrt{2-\\sqrt{2}} & \\frac{1}{2}\\sqrt{2+\\sqrt{2}}\\end{pmatrix}}$$"
        },
        {
            "introduction": "在确定了最佳插值节点之后，下一步自然是利用这些节点来构建插值多项式。本练习将演示如何用一个低阶多项式来近似一个给定的函数（在此为 $f(x) = x^3$），并确保该多项式在切比雪夫节点上的值与原函数完全匹配。通过这个具体的例子，您将对切比雪夫插值如何有效捕捉函数行为同时最小化误差有一个切实的理解 。",
            "id": "2187288",
            "problem": "在数值分析中，使用切比雪夫节点进行插值是优于使用等距点的一种方法，特别是在避免龙格现象方面。该方法选择的插值点是切比雪夫多项式的根，这些根聚集在区间的端点附近。\n\n考虑区间 $[-1, 1]$ 上的函数 $f(x) = x^3$。您的任务是找到一个唯一的、次数至多为 2 的多项式，我们称之为 $P_2(x)$，它在此区间上的三个切比雪夫节点处对 $f(x)$ 进行插值。这些节点被定义为 3 次第一类切比雪夫多项式 $T_3(x)$ 的根。\n\n请将您的答案 $P_2(x)$ 表示为一个关于 $x$ 的简化多项式。",
            "solution": "给定区间 $[-1,1]$ 上的函数 $f(x)=x^{3}$，我们必须找到唯一的、次数至多为 $2$ 的多项式 $P_{2}(x)$，该多项式在 $[-1,1]$ 上的三个切比雪夫节点处对 $f$ 进行插值，这些节点定义为 3 次第一类切比雪夫多项式 $T_{3}(x)$ 的根。\n\n使用恒等式 $T_{3}(x)=\\cos\\!\\big(3\\arccos x\\big)=4x^{3}-3x$。$T_{3}$ 的根即为三个切比雪夫节点：\n$$\nT_{3}(x)=4x^{3}-3x=x\\big(4x^{2}-3\\big)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\n设 $P_{2}(x)=A x^{2}+B x+C$。插值条件为在每个节点 $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$ 处，都有 $P_{2}(\\xi)=\\xi^{3}$。\n\n1) 在 $x=0$ 处：\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) 设 $a=\\frac{\\sqrt{3}}{2}$。在 $x=a$ 和 $x=-a$ 处：\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\n将这两个方程相加可以消去 $B$：\n$$\n\\big(A a^{2}+B a\\big)+\\big(A a^{2}-B a\\big)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{since }a\\neq 0).\n$$\n将 $A=0$ 代入 $A a^{2}+B a=a^{3}$ 来解出 $B$：\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\n由于 $a=\\frac{\\sqrt{3}}{2}$，我们有\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\n因此，\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\n快速检验一下：$P_{2}(0)=0=f(0)$，并且 $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$，因此在所有三个切比雪夫节点上，插值条件都得到满足。\n\n因此，唯一的、次数至多为 2 的插值多项式是 $P_{2}(x)=\\frac{3}{4}x$。",
            "answer": "$$\\boxed{\\frac{3}{4}x}$$"
        },
        {
            "introduction": "在实际应用中，我们经常需要处理高阶多项式近似，因此其求值速度至关重要。这个高级练习将挑战您实现克伦肖算法（Clenshaw's algorithm），这是一种用于计算切比雪夫级数的高效且数值稳定的后向递推方法。掌握这项技术对于开发高性能计算代码至关重要，本练习将引导您完成其推导、实现和性能分析的全过程 。",
            "id": "3105806",
            "problem": "要求你构建一个完整、可运行的程序，该程序能够准确高效地评估切比雪夫级数，并分析其理论性能特征。请完全使用纯数学术语进行阐述。所有角度必须以弧度为单位。你的程序必须实现一个基于从切比雪夫多项式定义递推中导出的稳定反向递推的矢量化求值器，以及一个使用余弦恒等式的朴素求值器。你必须对照一个可信的参考来量化正确性，并计算理论上的运算和调用次数，以及在一个简单模型下的理想化单指令多数据（SIMD）加速比。你的最终输出必须是包含所有测试用例聚合结果的一行，打印为一个无空格的方括号列表。\n\n背景和基本定义\n- 第一类切比雪夫多项式，记作 $T_k(x)$，由以下递推关系定义\n  $$\n  T_0(x) = 1,\\quad T_1(x) = x,\\quad T_{k+1}(x) = 2x\\,T_k(x) - T_{k-1}(x)\\quad\\text{for } k \\ge 1.\n  $$\n- 等价地，对于 $x \\in [-1,1]$ 和 $\\theta = \\arccos(x)$（以弧度为单位），它们满足以下恒等式\n  $$\n  T_k(x) = \\cos(k\\,\\theta).\n  $$\n- 一个 $n$ 次的切比雪夫级数是\n  $$\n  S(x) = \\sum_{k=0}^{n} c_k\\,T_k(x).\n  $$\n\n任务\n1) 仅从 $T_k(x)$ 的递推关系和级数定义出发，推导出一个稳定的反向递推，以并发地在多个点 $x$ 上求值 $S(x)$，并以矢量化的方式实现它，使其能对整个数组进行操作，而无需在 Python 中对求值点进行循环。该矢量化算法必须基于一个累积两个先前状态的反向递推，并且不得对求值点执行任何显式的 Python 级循环。\n\n2) 使用余弦恒等式 $T_k(x) = \\cos(k\\,\\arccos(x))$（以弧度为单位）实现一个朴素求值器。该方法应通过对 $k = 0,\\dots,n$ 的 $c_k \\cos(k\\,\\arccos(x))$ 求和来直接构造 $S(x)$。\n\n3) 对于下方的每个测试用例，计算两种求值器的结果，并使用一个稳健的切比雪夫级数求值器计算一个可信的参考值。报告每种方法与参考值之间的最大绝对误差。\n\n4) 对于每个测试用例，计算以下理论复杂度和性能量：\n   - 朴素方法中的反余弦求值次数，等于求值点数 $m$。\n   - 朴素方法中的余弦求值次数，等于 $(n+1)\\,m$。\n   - 矢量化反向递推方法的浮点运算次数（将每次加法和乘法视为一次浮点运算），遵循以下模型：\n     - 以 $m$ 次乘法的代价预计算一次 $\\alpha = 2x$。\n     - 对于从 $n$ 到 $1$ 的每个 $k$，用 $m$ 次乘法和 $2m$ 次加法计算 $b_k = \\alpha\\,b_{k+1} - b_{k+2} + c_k$。\n     - 用 $m$ 次乘法和 $2m$ 次加法将结果组合为 $S(x) = c_0 + x\\,b_1 - b_2$。\n     - 因此，总计等于 $(3n+3)\\,m$ 次浮点运算。\n   - 宽度 $W=4$ 和 $W=8$ 的理想化 SIMD（单指令多数据）加速比，定义为在完美矢量化且无停顿的情况下，相对于标量通道的理想吞吐量倍数 $\\min\\{m, W\\}$。\n\n5) 输出规范：对于每个测试用例，按此确切顺序输出一个包含以下七个条目的列表：\n   - 矢量化反向递推方法相对于参考值的最大绝对误差，作为浮点数，四舍五入至十二位有效数字。\n   - 朴素余弦方法相对于参考值的最大绝对误差，作为浮点数，四舍五入至十二位有效数字。\n   - 朴素方法中的 $\\arccos$ 调用次数，作为整数。\n   - 朴素方法中的 $\\cos$ 调用次数，作为整数。\n   - 矢量化反向递推方法的总浮点运算次数，作为整数。\n   - $W=4$ 时的理想化 SIMD 加速比，作为整数。\n   - $W=8$ 时的理想化 SIMD 加速比，作为整数。\n   将三个测试用例的列表聚合为一个单一列表，并精确地打印一行包含此聚合结果的内容，格式化为一个无空格的方括号列表，例如：[[...],[...],[...]]。\n\n测试套件\n使用以下三个独立的测试用例。所有角度均以弧度为单位。所有 $x$ 均在 $[-1,1]$ 区间内。\n\n- 测试用例 1（边界，常数级数）：\n  - 次数 $n = 0$。\n  - 系数 $c = [2.5]$。\n  - 求值点 $x = [-1.0,\\,-0.5,\\,0.0,\\,0.5,\\,1.0]$。\n- 测试用例 2（中等次数和网格）：\n  - 次数 $n = 5$。\n  - 系数 $c = [0.5,\\,-1.0,\\,0.75,\\,-0.25,\\,0.125,\\,-0.0625]$。\n  - 求值点 $x = [-1.0,\\,-0.75,\\,-0.5,\\,-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0]$。\n- 测试用例 3（压力测试，高次数和密集网格）：\n  - 次数 $n = 200$。\n  - 系数由 $c_k = \\dfrac{(-1)^k}{(k+1)^2}$ 定义，其中 $k = 0,\\dots,200$。\n  - 求值点为 $[-1,1]$ 区间内（含两端）的 $m=2001$ 个等距点。\n\n最终输出格式和类型要求\n- 你的程序必须生成单行输出，其中包含一个逗号分隔的三个测试用例列表的列表，该列表用一对无空格的方括号括起来。\n- 条目的类型必须严格按照上述规定为浮点数或整数。\n- 每个浮点数在打印前必须四舍五入至十二位有效数字。",
            "solution": "### 1. 矢量化反向递推的推导（Clenshaw 算法变体）\n\n目标是高效地求值切比雪夫级数 $S(x) = \\sum_{k=0}^{n} c_k T_k(x)$。求值过程被分为常数项 $c_0 T_0(x) = c_0$ 和高阶项之和。令 $S_{1..n}(x) = \\sum_{k=1}^{n} c_k T_k(x)$，因此 $S(x) = c_0 + S_{1..n}(x)$。\n\n我们使用一种反向递推关系，这项技术被称为 Clenshaw 算法。让我们定义一个辅助序列 $b_k$，其中 $k=n, n-1, \\dots, 1$，由以下递推关系控制：\n$$\nb_k = c_k + 2x\\,b_{k+1} - b_{k+2}\n$$\n其初始条件为 $b_{n+1} = 0$ 和 $b_{n+2} = 0$。这个关系可以重排以表示系数 $c_k$：\n$$\nc_k = b_k - 2x\\,b_{k+1} + b_{k+2}\n$$\n将此 $c_k$ 的表达式代入和 $S_{1..n}(x)$ 中：\n$$\nS_{1..n}(x) = \\sum_{k=1}^{n} \\left(b_k - 2x\\,b_{k+1} + b_{k+2}\\right) T_k(x)\n$$\n我们可以将其拆分为三个独立的和：\n$$\nS_{1..n}(x) = \\sum_{k=1}^{n} b_k T_k(x) - \\sum_{k=1}^{n} 2x\\,b_{k+1} T_k(x) + \\sum_{k=1}^{n} b_{k+2} T_k(x)\n$$\n切比雪夫多项式的定义递推关系是 $T_{k+1}(x) = 2x\\,T_k(x) - T_{k-1}(x)$，可以写作 $2x\\,T_k(x) = T_{k+1}(x) + T_{k-1}(x)$。我们关注乘以每个 $b_j$ 的系数。\n让我们收集与给定辅助系数 $b_j$ 相关的所有项，其中 $j \\in \\{1, 2, \\dots, n+2\\}$：\n- 对于 $j \\in \\{3, \\dots, n\\}$， $b_j$ 的系数是 $T_j(x)$（来自第一个和），$-2x\\,T_{j-1}(x)$（来自第二个和，其中 $k=j-1$），以及 $T_{j-2}(x)$（来自第三个和，其中 $k=j-2$）。总系数为 $T_j(x) - 2x\\,T_{j-1}(x) + T_{j-2}(x)$。根据切比雪夫递推关系 $T_{j}(x) = 2x\\,T_{j-1}(x) - T_{j-2}(x)$，这个表达式恒等于零。因此，所有中间项 $b_3, \\dots, b_n$ 都抵消了，产生类似伸缩求和的效果。\n\n- 未抵消的项位于求和索引的边界处：$j=1, 2$ 和 $j=n+1, n+2$。\n- $b_1$ 的系数：唯一的项是来自第一个和的 $b_1 T_1(x)$。\n- $b_2$ 的系数：来自第一个和的项是 $b_2 T_2(x)$。来自第二个和（其中 $k=1$）的项是 $-2x\\,b_2 T_1(x)$。\n- $b_{n+1}$ 的系数：来自第二个和（其中 $k=n$）的项是 $-2x\\,b_{n+1} T_n(x)$。来自第三个和（其中 $k=n-1$）的项是 $b_{n+1} T_{n-1}(x)$。\n- $b_{n+2}$ 的系数：来自第三个和（其中 $k=n$）的项是 $b_{n+2} T_n(x)$。\n\n给定初始条件 $b_{n+1} = 0$ 和 $b_{n+2} = 0$，所有涉及这些系数的项都消失了。和简化为只涉及 $b_1$ 和 $b_2$ 的项：\n$$\nS_{1..n}(x) = b_1 T_1(x) + b_2 T_2(x) - 2x\\,b_2 T_1(x)\n$$\n使用 $T_1(x) = x$ 和 $T_2(x) = 2x^2 - 1$：\n$$\nS_{1..n}(x) = b_1 x + b_2 (2x^2 - 1) - 2x\\,b_2 x = b_1 x + 2x^2 b_2 - b_2 - 2x^2 b_2 = x\\,b_1 - b_2\n$$\n最后，完整的级数和是：\n$$\nS(x) = c_0 + S_{1..n}(x) = c_0 + x\\,b_1 - b_2\n$$\n这证实了问题陈述中指定的算法。对于矢量化，求值点 $x$ 被视为一个数组。辅助状态 $b_k$ 也是同样大小的数组，递推使用 NumPy 中的逐元素数组操作来应用，从而避免了对求值点的显式 Python 循环。\n\n### 2. 朴素余弦恒等式方法\n该方法直接使用恒等式 $T_k(x) = \\cos(k\\,\\theta)$（其中 $\\theta = \\arccos(x)$）来实现定义 $S(x) = \\sum_{k=0}^{n} c_k T_k(x)$。对于一个求值点向量 $x$，我们首先计算向量 $\\theta = \\arccos(x)$。然后，对于每个 $k \\in \\{0, \\dots, n\\}$，我们计算项 $c_k \\cos(k\\,\\theta)$ 并将这些项相加。这可以通过创建一个 $\\cos(k \\theta)$ 值的矩阵，并与系数 $c_k$ 进行矩阵-向量乘积来实现矢量化。\n\n### 3. 误差分析\n两种实现方法的准确性通过与一个可信的参考 `numpy.polynomial.chebyshev.chebval` 进行比较来评估，该参考提供了一个用于评估切比雪夫级数的稳健且高度优化的实现。误差被量化为每个测试用例中所有求值点上计算值与参考值之间的最大绝对差。\n\n### 4. 复杂度和性能分析\n分析遵循问题陈述中提供的模型。\n- **朴素方法**:\n  - `arccos` 调用次数：`m`（在大小为 `m` 的数组上进行一次矢量化调用）。\n  - `cos` 调用次数：`(n+1)m`（在大小为 `(n+1) x m` 的矩阵上进行一次矢量化调用）。\n- **递推方法**:\n  - 浮点运算（flops）：问题指定总共有 $(3n+3)m$ 次浮点运算，这包括了预计算、反向递推循环和最终的组合步骤。\n- **理想化 SIMD 加速比**:\n  - 对于 SIMD 宽度 $W$，加速比由简单模型 $\\min\\{m, W\\}$ 给出，其中 $m$ 是求值点的数量。这代表了在完美矢量化、无内存停顿或其他开销的情况下的最大吞吐量增益。\n\n现在，实现将继续为指定的测试用例计算这些量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Chebyshev series evaluation problem by implementing and\n    analyzing two methods: a vectorized backward recurrence and a naive\n    cosine identity sum.\n    \"\"\"\n\n    def process_case(c, x):\n        \"\"\"\n        Processes a single test case: evaluates the series, calculates errors,\n        and computes theoretical complexity metrics.\n\n        Args:\n            c (np.ndarray): Array of Chebyshev coefficients.\n            x (np.ndarray): Array of evaluation points in [-1, 1].\n\n        Returns:\n            list: A list of 7 result metrics for the test case.\n        \"\"\"\n        n = len(c) - 1 if len(c) > 0 else -1\n        m = len(x)\n\n        # Handle trivial case of empty input points\n        if m == 0:\n            return [0.0, 0.0, 0, 0, 0, 0, 0]\n\n        # 1. Vectorized backward recurrence method\n        if n < 0:  # Empty series\n            y_recurrence = np.zeros_like(x)\n        elif n == 0:\n            y_recurrence = np.full_like(x, c[0])\n        else:  # n >= 1\n            alpha = 2.0 * x\n            b1 = np.zeros_like(x)  # Stores b_{k+1}\n            b2 = np.zeros_like(x)  # Stores b_{k+2}\n            for k in range(n, 0, -1):\n                # b_k = c_k + 2x*b_{k+1} - b_{k+2}\n                b0 = c[k] + alpha * b1 - b2\n                b2 = b1\n                b1 = b0\n            # After loop, b1 holds b_1, b2 holds b_2 from derivation\n            y_recurrence = c[0] + x * b1 - b2\n\n        # 2. Naive evaluator using cosine identity\n        if n < 0:\n            y_naive = np.zeros_like(x)\n        else:\n            theta = np.arccos(x)\n            # Use broadcasting for full vectorization over k and x\n            k_vals = np.arange(n + 1).reshape(-1, 1)  # Shape (n+1, 1)\n            c_col = c.reshape(-1, 1)                 # Shape (n+1, 1)\n            # theta has shape (m,). k_vals*theta broadcasts to (n+1, m)\n            T_matrix = np.cos(k_vals * theta)\n            y_naive = np.sum(c_col * T_matrix, axis=0) # Shape (m,)\n\n        # 3. Reference solution and error calculation\n        y_ref = np.polynomial.chebyshev.chebval(x, c)\n        err_recurrence = np.max(np.abs(y_recurrence - y_ref))\n        err_naive = np.max(np.abs(y_naive - y_ref))\n\n        # 4. Theoretical complexity and performance quantities\n        arccos_calls = m\n        if n < 0:\n            cos_calls = 0\n            flops_recurrence = 0\n        else:\n            cos_calls = (n + 1) * m\n            # Use the flop count formula from the problem statement\n            flops_recurrence = (3 * n + 3) * m\n\n        simd_4 = min(m, 4)\n        simd_8 = min(m, 8)\n\n        # 5. Assemble results list\n        return [\n            err_recurrence,\n            err_naive,\n            int(arccos_calls),\n            int(cos_calls),\n            int(flops_recurrence),\n            int(simd_4),\n            int(simd_8)\n        ]\n\n    # --- Test Cases ---\n    \n    # Test case 1\n    c1 = np.array([2.5])\n    x1 = np.array([-1.0, -0.5, 0.0, 0.5, 1.0])\n    res1 = process_case(c1, x1)\n\n    # Test case 2\n    c2 = np.array([0.5, -1.0, 0.75, -0.25, 0.125, -0.0625])\n    x2 = np.array([-1.0, -0.75, -0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0])\n    res2 = process_case(c2, x2)\n\n    # Test case 3\n    n3 = 200\n    k3 = np.arange(n3 + 1)\n    c3 = ((-1.0)**k3) / ((k3 + 1.0)**2)\n    m3 = 2001\n    x3 = np.linspace(-1.0, 1.0, m3)\n    res3 = process_case(c3, x3)\n\n    all_results = [res1, res2, res3]\n\n    def format_list_item(item):\n        \"\"\"Formats list items to spec: float to 12 sig-dig string, int to string.\"\"\"\n        if isinstance(item, float):\n            return f\"{item:.12g}\"\n        return str(item)\n\n    # Manually construct the final string to match format requirements\n    # (no spaces, 12 significant digits for floats)\n    result_strings = []\n    for res_list in all_results:\n        formatted_items = [format_list_item(item) for item in res_list]\n        result_strings.append(f\"[{','.join(formatted_items)}]\")\n\n    print(f\"[[{','.join(result_strings)}]]\")\n\nsolve()\n```"
        }
    ]
}