{
    "hands_on_practices": [
        {
            "introduction": "数值积分不仅是数学上的抽象概念，它在药物动力学等科学领域中扮演着核心角色，用于计算“曲线下面积”（Area Under the Curve, AUC）等关键指标。这个练习将让你亲手实现复合梯形法则，并将其应用于一个模拟药物在体内浓度变化的实际模型 。你将通过探索不同采样策略如何影响计算精度，直观地理解离散化误差的来源以及非均匀网格在实际问题中的重要性。",
            "id": "3108753",
            "problem": "你需要研究复合梯形积分法则在应用于分段指数药代动力学浓度-时间曲线时的准确性。目标是量化不同采样方案如何影响浓度-时间曲线下面积（Area Under the Curve, AUC）的估算误差。请完全使用纯数学术语进行分析，并实现一个完整的、可运行的程序来产生所要求的输出。使用以下科学上真实的模型和规范。\n\n浓度-时间模型是区间 $[0,T]$ 上的一个连续分段指数函数，具有两个转折点。设 $T = 24$ 小时，转折点位于 $t_1 = 1.5$ 小时和 $t_2 = 6.0$ 小时。设初始浓度为 $C_0 = 10$ 毫克/升，指数衰减率在 $[0,t_1)$ 上为 $k_0 = 1.2$ /小时，在 $[t_1,t_2)$ 上为 $k_1 = 0.25$ /小时，在 $[t_2,T]$ 上为 $k_2 = 0.05$ /小时。浓度 $c(t)$ 被定义为 $[0,T]$ 上的唯一函数，该函数是连续的，并且在每个子区间上都呈 $A \\exp(-k (t-t_{\\mathrm{start}}))$ 的形式，其构造如下：\n- 在 $[0,t_1)$ 上：$c(t) = C_0 \\exp(-k_0 t)$。\n- 在 $[t_1,t_2)$ 上：$c(t) = c(t_1)\\,\\exp(-k_1 (t - t_1))$，其中 $c(t_1) = C_0 \\exp(-k_0 t_1)$ 确保在 $t_1$ 处的连续性。\n- 在 $[t_2,T]$ 上：$c(t) = c(t_2)\\,\\exp(-k_2 (t - t_2))$，其中 $c(t_2) = c(t_1)\\,\\exp(-k_1 (t_2 - t_1))$ 确保在 $t_2$ 处的连续性。\n\n你的任务是：\n- 从黎曼积分的定义和分段线性近似的概念出发，实现复合梯形法则，以使用任意非递减采样方案 $0 = t_0 \\le t_1 \\le \\dots \\le t_n = T$ 来近似 $c(t)$ 在 $[0,T]$ 上的积分。该法则必须能正确处理非均匀步长。\n- 使用指数函数的反导数和积分在相邻区间上的可加性，从第一性原理出发，推导出精确 AUC 的解析表达式，记为 $I_{\\mathrm{exact}} = \\int_0^T c(t)\\,dt$。这通过对三个子区间 $[0,t_1]$、$[t_1,t_2]$ 和 $[t_2,T]$ 上的贡献求和得到。\n- 使用你实现的复合梯形法则，对下面测试套件中列出的每个采样方案，在相同区间上估算 AUC，并计算绝对误差 $E = \\lvert I_{\\mathrm{trap}} - I_{\\mathrm{exact}} \\rvert$，单位为毫克·小时/升。\n\n所有物理量必须统一使用小时作为时间单位，毫克/升作为浓度单位。AUC 以毫克·小时/升表示。绝对误差必须以毫克·小时/升报告。不涉及角度单位。不涉及百分比。\n\n采样方案测试套件（每个都是以小时为单位的时间列表）：\n- 方案 A（均匀精细）：$t_j = 0, 0.1, 0.2, \\dots, 24$。\n- 方案 B（均匀粗糙）：$t_j = 0, 4, 8, 12, 16, 20, 24$。\n- 方案 C（早期密集稀疏）：$[0, 0.05, 0.1, 0.2, 0.5, 1.0, 1.5, 2.0, 4.0, 8.0, 12.0, 16.0, 24.0]$。\n- 方案 D（对数间隔，加端点）：构造 $m = 18$ 个点，通过 $t_i = 10^{a + i\\,(b-a)/(m-1)}$（其中 $i = 0, 1, \\dots, m-1$，$a = -3$，$b = \\log_{10}(24)$），然后与 $\\{0, 24\\}$ 取并集，去除重复项并按升序排序。\n- 方案 E（仅端点）：$[0, 24]$。\n- 方案 F（与转折点对齐）：$[0.0, 0.75, 1.5, 3.75, 6.0, 12.0, 24.0]$。\n\n你的程序必须：\n- 完全按照定义实现 $c(t)$，确保在 $t_1$ 和 $t_2$ 处的连续性。\n- 通过在每个子区间上积分并求和，根据模型定义解析计算 $I_{\\mathrm{exact}}$。\n- 对每个方案，使用给定的时间和在这些时间点的精确 $c(t)$ 值，通过复合梯形法则计算 $I_{\\mathrm{trap}}$。\n- 对每个方案，计算绝对误差 $E$，结果为浮点数，单位为毫克·小时/升，并将每个误差四舍五入到 $10$ 位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序为 [方案 A 误差, 方案 B 误差, 方案 C 误差, 方案 D 误差, 方案 E 误差, 方案 F 误差]，例如 \"[$e_A$,$e_B$,$e_C$,$e_D$,$e_E$,$e_F$]\"。每个 $e_{\\cdot}$ 必须是四舍五入到 $10$ 位小数的十进制字符串。",
            "solution": "该问题被评估为科学上合理、问题陈述清晰，并包含唯一解所需的所有信息。我们继续进行推导和实现。\n\n该问题要求计算一个表示药代动力学浓度随时间变化的分段指数函数的精确解析积分与使用复合梯形法则得到的数值近似之间的绝对误差。\n\n浓度-时间模型 $c(t)$ 定义在区间 $[0, T]$ 上，其中 $T=24$ 小时。该函数是连续的，并且是分段定义的，转折点在 $t_1 = 1.5$ 小时和 $t_2 = 6.0$ 小时。定义参数为初始浓度 $C_0 = 10$ mg/L，以及指数衰减率 $k_0 = 1.2$ hr$^{-1}$，$k_1 = 0.25$ hr$^{-1}$ 和 $k_2 = 0.05$ hr$^{-1}$。\n\n函数 $c(t)$ 的构造如下：\n- 对于 $t \\in [0, t_1)$，浓度为 $c(t) = C_0 \\exp(-k_0 t)$。\n- 对于 $t \\in [t_1, t_2)$，浓度为 $c(t) = c(t_1) \\exp(-k_1 (t - t_1))$。通过定义 $c(t_1) = C_0 \\exp(-k_0 t_1)$ 来确保在 $t_1$ 处的连续性。\n- 对于 $t \\in [t_2, T]$，浓度为 $c(t) = c(t_2) \\exp(-k_2 (t - t_2))$。通过定义 $c(t_2) = c(t_1) \\exp(-k_1 (t_2 - t_1))$ 来确保在 $t_2$ 处的连续性。\n\n首先，我们推导精确曲线下面积（AUC）的解析表达式，记为 $I_{\\mathrm{exact}}$。AUC 是 $c(t)$ 从 $0$ 到 $T$ 的定积分。\n$$I_{\\mathrm{exact}} = \\int_0^T c(t) \\, dt$$\n由于积分的可加性，我们可以将积分拆分到由转折点定义的子区间上：\n$$I_{\\mathrm{exact}} = \\int_0^{t_1} c(t) \\, dt + \\int_{t_1}^{t_2} c(t) \\, dt + \\int_{t_2}^{T} c(t) \\, dt$$\n我们分别对每个部分进行积分。\n\n1.  在 $[0, t_1]$ 上的积分：\n    $$I_1 = \\int_0^{t_1} C_0 \\exp(-k_0 t) \\, dt = C_0 \\left[ -\\frac{1}{k_0} \\exp(-k_0 t) \\right]_0^{t_1} = C_0 \\left( -\\frac{1}{k_0} \\exp(-k_0 t_1) - \\left(-\\frac{1}{k_0} \\exp(0)\\right) \\right) = \\frac{C_0}{k_0} (1 - \\exp(-k_0 t_1))$$\n\n2.  在 $[t_1, t_2]$ 上的积分：\n    设 $c(t_1) = C_0 \\exp(-k_0 t_1)$ 是时间 $t_1$ 时的浓度。\n    $$I_2 = \\int_{t_1}^{t_2} c(t_1) \\exp(-k_1 (t - t_1)) \\, dt = c(t_1) \\left[ -\\frac{1}{k_1} \\exp(-k_1(t - t_1)) \\right]_{t_1}^{t_2}$$\n    $$I_2 = c(t_1) \\left( -\\frac{1}{k_1} \\exp(-k_1(t_2 - t_1)) - \\left(-\\frac{1}{k_1} \\exp(0)\\right) \\right) = \\frac{c(t_1)}{k_1} (1 - \\exp(-k_1(t_2 - t_1)))$$\n\n3.  在 $[t_2, T]$ 上的积分：\n    设 $c(t_2) = c(t_1) \\exp(-k_1 (t_2 - t_1))$ 是时间 $t_2$ 时的浓度。\n    $$I_3 = \\int_{t_2}^{T} c(t_2) \\exp(-k_2 (t - t_2)) \\, dt = c(t_2) \\left[ -\\frac{1}{k_2} \\exp(-k_2(t - t_2)) \\right]_{t_2}^{T}$$\n    $$I_3 = c(t_2) \\left( -\\frac{1}{k_2} \\exp(-k_2(T - t_2)) - \\left(-\\frac{1}{k_2} \\exp(0)\\right) \\right) = \\frac{c(t_2)}{k_2} (1 - \\exp(-k_2(T - t_2)))$$\n\n总的精确 AUC 是三者之和 $I_{\\mathrm{exact}} = I_1 + I_2 + I_3$。\n\n接下来，我们为非均匀采样方案 $t_0, t_1, \\dots, t_n$（其中 $0 = t_0 \\le t_1 \\le \\dots \\le t_n = T$）定义复合梯形法则。该积分通过对每个子区间 $[t_{i-1}, t_i]$ 上形成的梯形面积求和来近似。\n$$I_{\\mathrm{trap}} = \\sum_{i=1}^{n} \\frac{c(t_{i-1}) + c(t_i)}{2} (t_i - t_{i-1})$$\n该公式被实现用于为每个给定的采样方案计算数值近似值 $I_{\\mathrm{trap}}$。\n\n最后，对每个方案，绝对误差 $E$ 计算如下：\n$$E = |I_{\\mathrm{trap}} - I_{\\mathrm{exact}}|$$\n\n整个过程如下：\n1.  定义常数 $C_0, k_0, k_1, k_2, t_1, t_2, T$。\n2.  根据其定义实现连续的分段函数 $c(t)$。\n3.  使用推导出的解析公式计算精确积分 $I_{\\mathrm{exact}}$。\n4.  对每个测试方案（A 到 F）：\n    a.  生成时间点数组 $t_0, t_1, \\dots, t_n$。\n    b.  在每个时间点计算浓度 $c(t_i)$。\n    c.  使用复合梯形法则计算近似积分 $I_{\\mathrm{trap}}$。\n    d.  计算绝对误差 $E = |I_{\\mathrm{trap}} - I_{\\mathrm{exact}}|$。\n    e.  将误差 $E$ 四舍五入到 10 位小数。\n5.  收集四舍五入后的误差，并将其格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacokinetic AUC error analysis problem.\n    \"\"\"\n    # Define model parameters\n    C0 = 10.0  # mg/L\n    k0 = 1.2   # 1/hr\n    k1 = 0.25  # 1/hr\n    k2 = 0.05  # 1/hr\n    t1 = 1.5   # hr\n    t2 = 6.0   # hr\n    T = 24.0   # hr\n\n    # Pre-calculate concentrations at breakpoints for the c(t) function\n    c_at_t1 = C0 * np.exp(-k0 * t1)\n    c_at_t2 = c_at_t1 * np.exp(-k1 * (t2 - t1))\n\n    def concentration(t):\n        \"\"\"\n        Calculates the concentration c(t) at time t or for a numpy array of times.\n        The function is vectorized using numpy.piecewise.\n        \"\"\"\n        t = np.asarray(t)\n        \n        # Conditions for the piecewise function\n        condlist = [t  t1, (t = t1)  (t  t2), t = t2]\n        \n        # Functions for each piece\n        funclist = [\n            lambda t: C0 * np.exp(-k0 * t),\n            lambda t: c_at_t1 * np.exp(-k1 * (t - t1)),\n            lambda t: c_at_t2 * np.exp(-k2 * (t - t2))\n        ]\n        \n        return np.piecewise(t, condlist, funclist)\n\n    def analytic_auc():\n        \"\"\"\n        Calculates the exact area under the curve (AUC) from t=0 to T.\n        \"\"\"\n        # Integral over [0, t1]\n        I1 = (C0 / k0) * (1.0 - np.exp(-k0 * t1))\n        \n        # Integral over [t1, t2]\n        I2 = (c_at_t1 / k1) * (1.0 - np.exp(-k1 * (t2 - t1)))\n        \n        # Integral over [t2, T]\n        I3 = (c_at_t2 / k2) * (1.0 - np.exp(-k2 * (T - t2)))\n        \n        return I1 + I2 + I3\n\n    def composite_trapezoidal_rule(time_points, concentrations):\n        \"\"\"\n        Implements the composite trapezoidal rule for non-uniform grid spacing.\n        \"\"\"\n        if len(time_points)  2:\n            return 0.0\n        \n        time_diffs = np.diff(time_points) # h_i = t_i - t_{i-1}\n        conc_sums = concentrations[:-1] + concentrations[1:] # c(t_{i-1}) + c(t_i)\n        \n        return np.sum(time_diffs * conc_sums / 2.0)\n\n    # --- Define Test Suite of Sampling Schedules ---\n\n    # Schedule A: uniform fine\n    schedule_A = np.linspace(0.0, 24.0, 241)\n\n    # Schedule B: uniform coarse\n    schedule_B = np.linspace(0.0, 24.0, 7)\n    \n    # Schedule C: early-heavy sparse\n    schedule_C = np.array([0.0, 0.05, 0.1, 0.2, 0.5, 1.0, 1.5, 2.0, 4.0, 8.0, 12.0, 16.0, 24.0])\n\n    # Schedule D: log-spaced, plus endpoints\n    m = 18\n    a = -3\n    b = np.log10(T)\n    # Generate log-spaced points, then form the union with endpoints to ensure they are included\n    log_points = np.logspace(a, b, num=m, base=10.0)\n    schedule_D = np.union1d(log_points, [0.0, T])\n\n    # Schedule E: endpoints only\n    schedule_E = np.array([0.0, 24.0])\n\n    # Schedule F: aligned with change-points\n    schedule_F = np.array([0.0, 0.75, 1.5, 3.75, 6.0, 12.0, 24.0])\n    \n    test_cases = [\n        schedule_A,\n        schedule_B,\n        schedule_C,\n        schedule_D,\n        schedule_E,\n        schedule_F\n    ]\n    \n    # --- Perform Calculations ---\n    \n    # Calculate the exact integral once\n    I_exact = analytic_auc()\n    \n    results = []\n    for schedule in test_cases:\n        # Evaluate concentrations at the sampling times\n        conc_values = concentration(schedule)\n        \n        # Compute the integral using the trapezoidal rule\n        I_trap = composite_trapezoidal_rule(schedule, conc_values)\n        \n        # Compute the absolute error\n        error = np.abs(I_trap - I_exact)\n        \n        # Round the error to 10 decimal places as required\n        rounded_error = round(error, 10)\n        \n        results.append(rounded_error)\n\n    # Format the final output string\n    # Using f-strings with a format specifier to ensure 10 decimal places are shown\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了单个积分的计算之后，让我们将视野拓宽，思考一个更复杂但更常见的情景：当数值积分成为一个更庞大计算系统（如优化算法）的“内循环”时会发生什么？本练习将引导你将复合积分法则嵌入到一个梯度下降优化器中 。你将亲眼见证积分的离散化误差如何转化为“噪声”，干扰梯度的计算，并最终影响整个优化过程的收敛性和稳定性，从而深刻理解不同数值方法间的相互作用。",
            "id": "3108801",
            "problem": "您将研究复合数值积分的离散化误差如何传播到基于梯度的优化循环中，并影响其收敛性。考虑最小化泛函的标量优化问题：\n$$\nJ(a) \\;=\\; \\int_{0}^{1} \\left(a\\,x^{2} - \\sin(2\\pi x)\\right)^{2}\\,dx,\n$$\n其中正弦函数的参数以弧度为单位。外部优化循环对标量参数 $a$ 使用梯度下降法，而内部目标函数求值则使用复合数值积分法则。您的任务是实现一个程序，展示复合积分法则和网格分辨率的选择如何通过带噪声的梯度影响下降过程。\n\n必需的组件和约束：\n\n- 基本基础：\n  - 使用复合梯形法则和复合辛普森法则，这两种都是标准的 Newton–Cotes 公式。\n  - 使用中心有限差分公式来近似由求积法得到的目标函数关于 $a$ 的导数。\n  - 使用固定步长梯度下降作为外部优化器。\n\n- 需要实现的数学定义：\n  1. 在 $[0,1]$ 上使用 $N$ 个子区间的复合梯形法则：\n     - 设 $h = \\frac{1-0}{N}$ 且 $x_{i} = 0 + i\\,h$（$i=0,1,\\dots,N$）。对于给定函数 $f(x)$，\n       $$\n       \\int_{0}^{1} f(x)\\,dx \\;\\approx\\; h\\left(\\tfrac{1}{2}f(x_{0}) + \\sum_{i=1}^{N-1} f(x_{i}) + \\tfrac{1}{2}f(x_{N})\\right).\n       $$\n  2. 在 $[0,1]$ 上使用 $N$ 个子区间的复合辛普森法则：\n     - 要求 $N$ 为偶数。使用相同的 $h$ 和节点 $x_{i}$，\n       $$\n       \\int_{0}^{1} f(x)\\,dx \\;\\approx\\; \\frac{h}{3}\\left(f(x_{0}) + f(x_{N}) + 4\\sum_{i=1,\\,\\text{odd}}^{N-1} f(x_{i}) + 2\\sum_{i=2,\\,\\text{even}}^{N-2} f(x_{i})\\right).\n       $$\n  3. 使用步长为 $\\delta$ 的中心有限差分对外部循环进行梯度近似：\n     $$\n     \\frac{dJ}{da}(a) \\;\\approx\\; \\frac{J_{\\text{quad}}(a+\\delta) - J_{\\text{quad}}(a-\\delta)}{2\\,\\delta},\n     $$\n     其中 $J_{\\text{quad}}$ 是使用复合法则之一对 $J$ 进行的求积近似。\n  4. 使用固定学习率 $\\eta$ 的梯度下降更新：\n     $$\n     a_{k+1} \\;=\\; a_{k} \\;-\\; \\eta\\,g_{k}, \\quad \\text{where } g_{k} \\text{ is the finite-difference gradient at } a_{k}.\n     $$\n\n- 终止与稳定性：\n  - 初始化为 $a_{0} = 0$。\n  - 使用梯度容差 $\\varepsilon_{g} = 10^{-8}$ 和参数容差 $\\varepsilon_{a} = 10^{-9}$。\n  - 使用最大迭代次数 $K_{\\max} = 10000$。\n  - 如果循环超过 $K_{\\max}$ 仍未满足容差，或者$|a_{k}|$增长超过 $10^{6}$，则声明为不收敛。\n\n- 用于误差评估的参考最优值：\n  - 由于 $J(a)$ 是关于 $a$ 的二次泛函，其精确最小值点 $a_{\\star}$ 可以通过标准微积分方法，对精确积分关于 $a$ 进行最小化来获得。解析地计算这个 $a_{\\star}$，并仅用它来报告绝对误差 $|a_{\\text{final}} - a_{\\star}|$；不要用它来指导优化器。\n\n- 测试套件：\n  - 对每个测试用例，使用指定的复合法则、子区间数 $N$、学习率 $\\eta$ 和有限差分步长 $\\delta$ 来运行优化器：\n    1. 复合梯形法则, $N=16$, $\\eta=0.5$, $\\delta=10^{-4}$。\n    2. 复合梯形法则, $N=64$, $\\eta=0.5$, $\\delta=10^{-4}$。\n    3. 复合辛普森法则, $N=16$ (偶数), $\\eta=0.5$, $\\delta=10^{-4}$。\n    4. 复合梯形法则, $N=4$, $\\eta=0.5$, $\\delta=10^{-4}$。\n    5. 复合梯形法则, $N=16$, $\\eta=1.6$, $\\delta=10^{-4}$。\n\n- 必需的最终输出格式：\n  - 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n  - 对于每个测试用例，输出一个形式为 $[\\text{converged}, \\text{iterations}, a_{\\text{final}}, \\text{abs\\_error}]$ 的列表，其中：\n    - 如果根据定义的容差发生了收敛（即 $|g_k|  \\varepsilon_g$ 或 $|a_{k+1} - a_k|  \\varepsilon_a$），则 $\\text{converged}$ 为 $1$，否则为 $0$。\n    - $\\text{iterations}$ 是所用的迭代次数（一个整数）。\n    - $a_{\\text{final}}$ 是 $a$ 的最终估计值，四舍五入到六位小数。\n    - $\\text{abs\\_error}$ 是 $|a_{\\text{final}} - a_{\\star}|$，四舍五入到六位小数。\n  - 示例模式（非实际值）：$[[1,123,-0.750000,0.010000],[0,10000,-0.300000,0.400000],\\dots]$。\n\n注意事项：\n- 所有三角函数求值必须使用弧度。\n- 此问题不涉及物理单位。\n- 您的实现必须是自包含的，并且不得读取任何输入。",
            "solution": "我们从数值分析基本原理和基础微积分中推导出所需的组件，然后组装一个算法来演示复合积分误差如何扰动梯度下降。\n\n1. 目标结构和精确最小值点。泛函为\n$$\nJ(a) \\;=\\; \\int_{0}^{1} \\left(a\\,x^{2} - \\sin(2\\pi x)\\right)^{2}\\,dx.\n$$\n展开平方项表明 $J(a)$ 是一个关于 $a$ 的二次多项式。将精确积分对 $a$ 微分，并将导数设为零，得到一阶最优性条件\n$$\n\\frac{dJ}{da}(a) \\;=\\; 2\\int_{0}^{1} \\left(a\\,x^{2} - \\sin(2\\pi x)\\right) x^{2}\\,dx \\;=\\; 0,\n$$\n这意味着\n$$\na_{\\star}\\int_{0}^{1} x^{4}\\,dx \\;=\\; \\int_{0}^{1} x^{2}\\sin(2\\pi x)\\,dx.\n$$\n左侧的积分是初等的：\n$$\n\\int_{0}^{1} x^{4}\\,dx \\;=\\; \\left.\\frac{x^{5}}{5}\\right|_{0}^{1} \\;=\\; \\frac{1}{5}.\n$$\n对于右侧，定义 $k = 2\\pi$。使用两次分部积分或一个已知的原函数，可以得到\n$$\n\\int x^{2}\\sin(kx)\\,dx \\;=\\; -\\frac{x^{2}\\cos(kx)}{k} + \\frac{2x\\sin(kx)}{k^{2}} + \\frac{2\\cos(kx)}{k^{3}} + C.\n$$\n在 $k=2\\pi$ 的条件下，从 $x=0$ 到 $x=1$ 求值，其中 $\\cos(2\\pi)=1$ 且 $\\sin(2\\pi)=0$，得到\n$$\n\\int_{0}^{1} x^{2}\\sin(2\\pi x)\\,dx \\;=\\; -\\frac{1}{2\\pi}.\n$$\n因此，\n$$\na_{\\star} \\;=\\; \\frac{\\int_{0}^{1} x^{2}\\sin(2\\pi x)\\,dx}{\\int_{0}^{1} x^{4}\\,dx} \\;=\\; \\frac{-\\frac{1}{2\\pi}}{\\frac{1}{5}} \\;=\\; -\\frac{5}{2\\pi}.\n$$\n这个精确的 $a_{\\star}$ 为量化数值方法得到的 $a_{\\text{final}}$ 的误差提供了一个参考。\n\n2. 复合积分法则。对于区间 $[0,1]$ 上的函数 $f(x)$，使用包含 $N$ 个子区间的均匀网格，间距为 $h = \\frac{1}{N}$，定义节点 $x_{i} = i\\,h$（$i=0,1,\\dots,N$）。\n- 复合梯形法则：\n$$\n\\int_{0}^{1} f(x)\\,dx \\;\\approx\\; h\\left(\\tfrac{1}{2}f(x_{0}) + \\sum_{i=1}^{N-1} f(x_{i}) + \\tfrac{1}{2}f(x_{N})\\right).\n$$\n对于足够光滑的 $f$，该法则的全局截断误差为 $O(h^{2})$ 阶。\n- 复合辛普森法则（$N$ 为偶数）：\n$$\n\\int_{0}^{1} f(x)\\,dx \\;\\approx\\; \\frac{h}{3}\\left(f(x_{0}) + f(x_{N}) + 4\\sum_{\\substack{i=1\\\\ i \\text{ odd}}}^{N-1} f(x_{i}) + 2\\sum_{\\substack{i=2\\\\ i \\text{ even}}}^{N-2} f(x_{i})\\right).\n$$\n对于足够光滑的 $f$，该法则的全局截断误差为 $O(h^{4})$ 阶。\n\n在我们的设定中，被积函数是\n$$\nf(x;a) \\;=\\; \\left(a\\,x^{2} - \\sin(2\\pi x)\\right)^{2},\n$$\n该函数在 $x$ 和 $a$ 上是光滑的，因此两种复合法则都适用。\n\n3. 通过有限差分得到的带噪声的梯度。在外部优化循环中，通常会使用梯度。如果目标函数是通过求积计算的，求积误差会使得目标函数 $J_{\\text{quad}}(a)$ 仅仅是 $J(a)$ 的一个近似。完全从这些近似的目标函数值中获得梯度估计的一个直接方法是中心有限差分\n$$\ng(a) \\;\\approx\\; \\frac{J_{\\text{quad}}(a+\\delta) - J_{\\text{quad}}(a-\\delta)}{2\\,\\delta}.\n$$\n这个 $g(a)$ 从 $J_{\\text{quad}}$ 继承了由离散化引起的粗糙性。随着子区间数 $N$ 的增加（$h$ 减小），近似效果得到改善，梯度噪声也变得更小。对于相同的 $N$，辛普森法则通常比梯形法则有更小的误差。\n\n4. 梯度下降更新与终止。给定当前估计值 $a_{k}$、固定学习率 $\\eta$ 和梯度估计值 $g_{k}$，执行\n$$\na_{k+1} \\;=\\; a_{k} \\;-\\; \\eta\\,g_{k}.\n$$\n如果梯度大小很小（$|g_{k}|  \\varepsilon_{g}$），或者参数更新很微小（$|a_{k+1} - a_{k}|  \\varepsilon_{a}$），则停止。同时，通过在 $|a_{k}| > 10^{6}$ 或 $k$ 达到 $K_{\\max}$ 时中止来防止发散。\n\n5. 测试套件设计和预期效果。\n- 使用复合梯形法则和粗网格（例如 $N=4$）时，求积误差较大，有限差分梯度噪声更大，收敛可能会很慢，或者根据 $\\eta$ 的值，可能在迭代预算内无法收敛。\n- 将 $N$ 增加到 $N=16$ 或 $N=64$ 会减少求积误差，因此梯度变得更平滑，从而改善收敛行为。\n- 对于相同的 $N$，复合辛普森法则（$N$ 为偶数，例如 $N=16$）通常会产生更精确的目标函数和噪声更小的梯度，与梯形法则相比，这应该会加速收敛。\n- 大的学习率（例如 $\\eta=1.6$）会使下降过程不稳定，而噪声会加剧这种情况，可能引发振荡或发散。\n\n6. 程序输出。对于每个指定的测试用例，程序运行外部循环并报告一个列表 $[\\text{converged}, \\text{iterations}, a_{\\text{final}}, \\text{abs\\_error}]$，其中 $\\text{abs\\_error} = |a_{\\text{final}} - a_{\\star}|$ 且 $a_{\\star} = -\\frac{5}{2\\pi}$。单行程序输出是按给定顺序排列的这些列表的列表。这种安排允许跨不同法则和 $N$ 值进行直接比较，揭示复合积分选择和网格大小如何通过梯度噪声影响优化器。",
            "answer": "```python\nimport numpy as np\n\ndef composite_trapezoid(f, a, b, N):\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    fx = f(x)\n    return h * (0.5 * fx[0] + fx[1:-1].sum() + 0.5 * fx[-1])\n\ndef composite_simpson(f, a, b, N):\n    if N % 2 != 0:\n        raise ValueError(\"Simpson's rule requires an even N.\")\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    fx = f(x)\n    # odd indices 1..N-1 step 2, even indices 2..N-2 step 2\n    odd_sum = fx[1:-1:2].sum()\n    even_sum = fx[2:-1:2].sum()\n    return (h / 3.0) * (fx[0] + fx[-1] + 4.0 * odd_sum + 2.0 * even_sum)\n\ndef objective_quadrature(a_param, rule, N):\n    # integrand: (a x^2 - sin(2π x))^2\n    def integrand(x):\n        return (a_param * x**2 - np.sin(2.0 * np.pi * x))**2\n    if rule == \"trap\":\n        return composite_trapezoid(integrand, 0.0, 1.0, N)\n    elif rule == \"simp\":\n        return composite_simpson(integrand, 0.0, 1.0, N)\n    else:\n        raise ValueError(\"Unknown rule\")\n\ndef finite_diff_grad(a_param, rule, N, delta):\n    # centered finite difference\n    jp = objective_quadrature(a_param + delta, rule, N)\n    jm = objective_quadrature(a_param - delta, rule, N)\n    return (jp - jm) / (2.0 * delta)\n\ndef gradient_descent(rule, N, eta, delta,\n                     a0=0.0, tol_g=1e-8, tol_a=1e-9, max_iter=10000, blowup=1e6):\n    a = a0\n    converged = False\n    iters = 0\n    for k in range(max_iter):\n        g = finite_diff_grad(a, rule, N, delta)\n        # update\n        a_new = a - eta * g\n        iters = k + 1\n        if not np.isfinite(a_new) or abs(a_new)  blowup:\n            converged = False\n            a = a_new\n            break\n        # termination checks\n        if abs(g)  tol_g or abs(a_new - a)  tol_a:\n            converged = True\n            a = a_new\n            break\n        a = a_new\n    # If loop ends without break by convergence, check last state\n    return converged, iters, a\n\ndef main():\n    # Analytical minimizer a* = -5 / (2π)\n    a_star = -5.0 / (2.0 * np.pi)\n\n    # Test cases: (rule, N, eta, delta)\n    test_cases = [\n        (\"trap\", 16, 0.5, 1e-4),\n        (\"trap\", 64, 0.5, 1e-4),\n        (\"simp\", 16, 0.5, 1e-4),\n        (\"trap\", 4, 0.5, 1e-4),\n        (\"trap\", 16, 1.6, 1e-4),\n    ]\n\n    results = []\n    for rule, N, eta, delta in test_cases:\n        # Ensure Simpson has even N (already ensured in the suite)\n        try:\n            converged, iters, a_final = gradient_descent(rule, N, eta, delta)\n        except Exception:\n            converged, iters, a_final = (False, 0, float(\"nan\"))\n        abs_err = abs(a_final - a_star) if np.isfinite(a_final) else float(\"inf\")\n        # Prepare formatted result: [converged(int), iterations(int), a_final(6dp), abs_error(6dp)]\n        results.append((1 if converged else 0, iters, a_final, abs_err))\n\n    # Format output exactly as specified: list of lists on one line, comma-separated, no extra text\n    out_items = []\n    for conv, iters, a_fin, err in results:\n        # Round floats to 6 decimals; if not finite, print \"nan\" or \"inf\" consistently\n        if np.isfinite(a_fin):\n            a_str = f\"{a_fin:.6f}\"\n        else:\n            a_str = \"nan\" if np.isnan(a_fin) else \"inf\"\n        if np.isfinite(err):\n            e_str = f\"{err:.6f}\"\n        else:\n            e_str = \"nan\" if np.isnan(err) else \"inf\"\n        out_items.append(f\"[{conv},{iters},{a_str},{e_str}]\")\n    print(\"[\" + \",\".join(out_items) + \"]\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "introduction": "在真实世界的计算任务中，我们常常面临着时间和计算资源的严格限制。这个练习将挑战你从一个方法的使用者转变为一个算法的设计者，构建一个能够在有限预算内持续优化结果的“随时（anytime）”积分算法 。通过巧妙地利用复合梯形法则在不同精度下的递推关系，你将发现一种无需额外计算函数值就能获得更高阶辛普森法则精度的优雅技巧，这揭示了深入理解算法结构如何能带来计算效率的巨大飞跃。",
            "id": "3108814",
            "problem": "您的任务是为实时控制场景设计并实现一个基于复合积分法则的随时数值积分方案。在这类场景中，标量函数 $f(x)$ 在有限闭区间 $[a,b]$ 上的积分必须在严格的截止时间内完成近似计算。为了以纯数学方式对此约束进行建模，定义一个计算预算 $N_{\\max}$，其为函数 $f(x)$ 的最大允许求值次数，即在 $[a,b]$ 区间内计算 $f(x)$ 的不同点的总数。目标是构建一个能够增量式地优化估算值，并且在达到预算上限之前的任何时刻都能输出一个有效近似值的算法。\n\n从定积分作为黎曼和的极限的定义以及分段多项式插值的概念出发。请考虑以下要求：\n\n- 对区间 $[a,b]$ 使用二分加密方法，从单个子区间（$n=1$）开始，然后重复地将子区间数量加倍（$n \\to 2n$），以构建一个均匀划分。在每次从 $n$ 到 $2n$ 的加密步骤中，仅在每个子区间二等分所引入的 $n$ 个新中点处对 $f(x)$ 进行求值。始终重用所有先前网格点上已计算的 $f(x)$ 值。\n- 同时维护两种复合近似：\n  1. 在当前具有 $n$ 个子区间的均匀划分上的复合梯形法则近似。\n  2. 一个复合辛普森法则近似，该近似在划分具有偶数个子区间（即可以表示为相邻子区间的配对）时定义。\n- 随时特性要求算法可以在超出 $N_{\\max}$ 之前的任何时刻被中断，并仍然返回当前可用的最佳梯形近似。当存在足够的加密以形成至少一个辛普森法则块（偶数个子区间）时，也应生成辛普森近似，并增量更新，作为当前可用的最佳辛普森估算值返回。如果 $N_{\\max}$ 太小无法形成辛普森近似，算法仍应返回梯形近似。\n\n设计算法时应使用的基本原理：\n- 定积分作为黎曼和极限的定义。\n- 通过在每个子区间上对局部多项式插值函数进行积分而产生复合积分法则的原理。\n- 计算成本模型，其中函数求值主导时间成本；在每个不同点上对 $f(x)$ 的一次求值消耗一个单位的预算。\n\n角度单位说明：\n- 对于三角函数 $\\sin(x)$ 的任何使用，将 $x$ 解释为弧度。\n\n测试套件：\n在以下测试用例上实现并评估您的随时算法。对于每个用例，计算复合梯形随时近似和复合辛普森随时近似（如果在预算内可用），将两者与精确积分进行比较，并报告在给定预算下，辛普森近似的绝对误差是否严格小于梯形近似的绝对误差（如果预算内辛普森近似不可用，则报告其性能未优于梯形近似）。每个用例的精确积分都是解析已知的。\n\n- 用例 1：函数 $f_1(x) = \\sin(x)$，区间 $[a,b] = [0,\\pi]$，预算 $N_{\\max} = 3$。$\\sin(x)$ 使用弧度。\n- 用例 2：函数 $f_2(x) = \\sin(x)$，区间 $[a,b] = [0,\\pi]$，预算 $N_{\\max} = 2$。$\\sin(x)$ 使用弧度。\n- 用例 3：函数 $f_3(x) = e^{x}$，区间 $[a,b] = [0,1]$，预算 $N_{\\max} = 5$。\n- 用例 4：函数 $f_4(x) = |x - 0.3|$，区间 $[a,b] = [0,1]$，预算 $N_{\\max} = 9$。\n\n输出规格：\n- 对于每个用例，符号化地计算精确积分 $I_{\\text{true}}$ 和随时近似值。令 $E_{\\mathrm{trap}} = |I_{\\mathrm{trap}} - I_{\\text{true}}|$ 为梯形近似的绝对误差，令 $E_{\\mathrm{simp}} = |I_{\\mathrm{simp}} - I_{\\text{true}}|$ 为辛普森近似的绝对误差（如果可用）。输出一个布尔值，指示在给定预算下辛普森近似是否严格优于梯形近似，即，如果 $E_{\\mathrm{simp}}  E_{\\mathrm{trap}}$ 且预算内存在辛普森近似，则输出 $\\text{True}$；否则输出 $\\text{False}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$）。结果必须与上述用例的顺序一致。\n\n覆盖性设计：\n- 测试套件包括一个预期高阶法则能发挥作用的通用光滑用例（用例 3），两个具有三角函数行为且预算不同（包括一个最小边界预算）的用例（用例 1 和 2），以及一个在区间内部有尖点的非光滑用例（用例 4）。这覆盖了理想路径、边界条件和一个重要的边缘情况。\n\n您的实现必须是一个完整、可运行的程序，执行上述计算并按指定格式生成输出。",
            "solution": "用户要求设计并实现一个随时数值积分算法。该算法必须能够增量式地优化定积分 $I = \\int_a^b f(x) dx$ 的近似值，并在达到指定的计算预算 $N_{\\max}$（定义为函数求值的最大次数）之前的任何时刻提供一个估算值。该方案必须同时维护复合梯形法则和复合辛普森法则的近似值。\n\n该问题是有效的，因为它在科学上基于数值分析的原理，具有明确的目标和约束，是适定的，并且表述客观。\n\n该解决方案基于二分加密策略构建，该策略既计算高效，又天然适用于积分近似值的递归更新。\n\n**1. 算法框架：二分加密**\n\n该算法从区间 $[a,b]$ 的最粗糙划分开始，该划分由单个子区间（$n=1$）组成，然后通过对每个现有子区间进行二等分来迭代地加密它。这种在每一步中将子区间数量加倍（$n \\to 2n$）的过程被称为二分加密。在加密级别 $k$（对于 $k=0, 1, 2, \\dots$），划分由 $n = 2^k$ 个均匀的子区间组成，每个子区间的宽度为 $h_k = (b-a)/2^k$。\n\n一个关键要求是高效利用计算预算。在每次从 $n$ 个子区间加密到 $2n$ 个子区间的步骤中，我们仅在先前子区间的 $n$ 个新中点处对函数 $f(x)$ 进行求值。所有先前在现有网格点上计算的函数值都会被重用。\n\n截至加密级别 $k$ 所求值的不同点的总数为 $N_k = 2^k + 1$。只要所需的函数求值次数不超过预算 $N_{\\max}$，算法就会继续执行级别 $k=0, 1, 2, \\dots$ 的加密。\n\n**2. 复合梯形法则与递归更新**\n\n复合梯形法则通过对每个子区间上的梯形面积求和来近似积分。对于一个具有 $n$ 个宽度为 $h = (b-a)/n$ 的子区间的划分，其近似值为：\n$$ T_n = h \\left[ \\frac{1}{2}f(x_0) + \\sum_{i=1}^{n-1} f(x_i) + \\frac{1}{2}f(x_n) \\right] $$\n其中 $x_i = a + i \\cdot h$。\n\n我们的二分加密方案的一个关键方面是能够从 $T_n$ 高效地计算 $T_{2n}$。当我们从 $n$ 个子区间加密到 $2n$ 个子区间时，新的步长变为 $h' = h/2$。新的网格点集包括所有旧点以及每个旧子区间的中点。这导出了众所周知的递归公式：\n$$ T_{2n} = \\frac{1}{2} T_n + h' \\sum_{i=1}^{n} f(x'_{2i-1}) $$\n其中 $h' = (b-a)/(2n)$ 是新的步长，求和项是针对 $n$ 个新求值的中点。这个公式使我们能够在每个加密级别更新梯形近似，而无需对所有点重新求和，从而遵守了重用计算的原则。\n\n随时梯形近似值 $I_{\\mathrm{trap}}$ 是在预算 $N_{\\max}$ 内计算出的最新的梯形值 $T_{2^k}$。\n\n**3. 通过理查森外推法得到复合辛普森法则**\n\n当子区间数量 $n$ 为偶数时，复合辛普森法则适用。它是通过在相邻子区间对上对局部二次插值函数进行积分得到的。对于 $n$ 个宽度为 $h=(b-a)/n$ 的子区间，其公式为：\n$$ S_n = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right] $$\n\n在我们的加密方案中，直接求和是低效的，取而代之的是，我们可以从两个连续加密级别的梯形法则近似值中推导出辛普森法则近似值。这种关系是龙贝格积分的基石，可以看作是理查森外推法的一个应用。其公式为：\n$$ S_{2n} = \\frac{4T_{2n} - T_n}{3} $$\n这个绝妙的恒等式使我们能够仅使用两个最新的梯形近似值 $T_{2n}$ 和 $T_n$ 来计算辛普森近似值 $S_{2n}$，而无需任何额外的函数求值。\n\n辛普森近似值 $I_{\\mathrm{simp}}$ 在级别 $k=1$（当形成 $n=2$ 个子区间时）首次可用，并随后在每次加密时更新。随时辛普森近似值是在预算内计算出的最新值 $S_{2^k}$。如果预算 $N_{\\max}  3$ 不足以完成 $k=1$ 级别的加密（即），则 $I_{\\mathrm{simp}}$ 不可用。\n\n**4. 随时算法的实现**\n\n算法流程如下：\n\n1.  **初始化 ($k=0$)：**\n    - 如果预算 $N_{\\max}  2$，则无法进行近似计算。否则，计算 $f(a)$ 和 $f(b)$。求值次数为 $N=2$。\n    - 计算初始梯形近似值 $T_1 = \\frac{b-a}{2}(f(a)+f(b))$。这是当前最佳的梯形估算值 $I_{\\mathrm{trap}}$。\n    - 此时尚无辛普森近似值。\n\n2.  **加密循环 (对于 $k=1, 2, \\dots$)：**\n    - 确定此级别所需的新函数求值次数：$2^{k-1}$。\n    - 如果当前求值次数加上新的求值次数超过 $N_{\\max}$，则终止循环。当前最佳估算值 $I_{\\mathrm{trap}}$ 和 $I_{\\mathrm{simp}}$（如果可用）即为给定预算下的最终结果。\n    - 否则，继续进行加密：\n        - 将当前梯形近似值 $T_{2^{k-1}}$ 存储为 $T_{\\text{previous}}$。\n        - 在 $2^{k-1}$ 个新中点处计算 $f(x)$，并将结果求和到项 $M_k$ 中。\n        - 更新总求值次数 $N$。\n        - 计算新的梯形近似值 $T_{2^k} = \\frac{1}{2}T_{\\text{previous}} + h_k M_k$，其中 $h_k = (b-a)/2^k$。这成为新的 $I_{\\mathrm{trap}}$。\n        - 计算新的辛普森近似值 $S_{2^k} = \\frac{4T_{2^k} - T_{\\text{previous}}}{3}$。这成为新的 $I_{\\mathrm{simp}}$。\n\n3.  **最终比较：**\n    - 循环因预算限制而终止后，计算给定测试用例的真实积分值 $I_{\\text{true}}$。\n    - 计算绝对误差 $E_{\\mathrm{trap}} = |I_{\\mathrm{trap}} - I_{\\text{true}}|$，以及（如果计算了辛普森近似）$E_{\\mathrm{simp}} = |I_{\\mathrm{simp}} - I_{\\text{true}}|$。\n    - 该测试用例的最终结果是表达式（$I_{\\mathrm{simp}}$ 可用 且 $E_{\\mathrm{simp}}  E_{\\mathrm{trap}}$）的布尔值。\n\n该算法满足了所有问题要求：它是随时的，使用二分加密，重用函数求值，同时维护梯形和辛普森近似，并遵守指定的计算预算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates an anytime numerical integration scheme\n    based on composite trapezoidal and Simpson's rules with dyadic refinement.\n    \"\"\"\n\n    def f1(x):\n        return np.sin(x)\n\n    def f2(x):\n        return np.sin(x)\n\n    def f3(x):\n        return np.exp(x)\n\n    def f4(x):\n        return np.abs(x - 0.3)\n\n    test_cases = [\n        # Case 1: sin(x) on [0, pi] with budget N_max = 3\n        {'func': f1, 'a': 0.0, 'b': np.pi, 'N_max': 3, 'I_true': 2.0},\n        # Case 2: sin(x) on [0, pi] with budget N_max = 2\n        {'func': f2, 'a': 0.0, 'b': np.pi, 'N_max': 2, 'I_true': 2.0},\n        # Case 3: exp(x) on [0, 1] with budget N_max = 5\n        {'func': f3, 'a': 0.0, 'b': 1.0, 'N_max': 5, 'I_true': np.e - 1.0},\n        # Case 4: |x - 0.3| on [0, 1] with budget N_max = 9\n        {'func': f4, 'a': 0.0, 'b': 1.0, 'N_max': 9, 'I_true': 0.29},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f = case['func']\n        a = case['a']\n        b = case['b']\n        N_max = case['N_max']\n        I_true = case['I_true']\n\n        # Anytime algorithm state variables\n        num_evals = 0\n        trap_approx = 0.0\n        simp_approx = None \n        simpson_available = False\n\n        # --- Algorithm Implementation ---\n\n        # Initialization (k=0, n=1)\n        if N_max  2:\n            # Not enough budget for the most basic approximation\n            trap_approx = np.nan\n        else:\n            f_a = f(a)\n            f_b = f(b)\n            num_evals = 2\n            \n            h = b - a\n            T_current = h * (f_a + f_b) / 2.0\n            trap_approx = T_current\n\n        # Refinement loop\n        k = 0\n        while True:\n            k += 1\n            n_prev = 2**(k - 1)\n            num_new_evals = n_prev\n            \n            # Check if budget for next refinement is available\n            if num_evals + num_new_evals  N_max:\n                break\n            \n            # Commit to the refinement\n            T_previous = T_current\n            \n            n_current = 2**k\n            h_current = (b - a) / n_current\n            \n            midpoint_sum = 0.0\n            for i in range(1, n_prev + 1):\n                midpoint_x = a + (2 * i - 1) * h_current\n                midpoint_sum += f(midpoint_x)\n            \n            num_evals += num_new_evals\n            \n            # Update trapezoidal approximation\n            T_current = 0.5 * T_previous + h_current * midpoint_sum\n            trap_approx = T_current\n            \n            # Update Simpson's approximation (now available)\n            simp_approx = (4.0 * T_current - T_previous) / 3.0\n            simpson_available = True\n        \n        # --- End of Algorithm ---\n\n        # Final comparison based on the problem statement\n        if simpson_available:\n            E_trap = np.abs(trap_approx - I_true)\n            E_simp = np.abs(simp_approx - I_true)\n            \n            # Output True if Simpson's rule is strictly better\n            result = E_simp  E_trap\n        else:\n            # Simpson's was not available within budget\n            result = False\n        \n        results.append(result)\n\n    # Format the final output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}