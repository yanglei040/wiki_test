{
    "hands_on_practices": [
        {
            "introduction": "掌握任何数值算法的第一步都是亲手实现它。本练习  将指导你从 Cholesky 分解的数学定义 $A = LL^\\top$ 出发，将其转化为可执行的代码。你还将学习如何构建一个全面的测试框架，以验证实现的正确性，并处理各种输入矩阵，包括非对称或非正定的情况。",
            "id": "3106422",
            "problem": "您需要编写一个完整、可运行的程序。该程序在给定一个实方阵 $A$ 的情况下，尝试计算一个下三角矩阵 $L$ 使得 $A = L L^\\top$，并验证对于对称正定（SPD）矩阵的 Cholesky 分解至关重要的两个属性：(i) $L$ 的对角线元素严格为正，以及 (ii) $L L^\\top$ 在指定的容差范围内重构 $A$。您的设计必须从对称性和正定性的基本定义出发，并且不得依赖任何预先封装的分解例程。您的程序必须通过评估一个小型矩阵测试套件，将这些检查集成到一个测试驱动的工作流中，并为每个测试报告一个布尔值，以指示该测试的所有必需检查是否均已通过。\n\n用作基础的基本定义：\n- 一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称的，如果 $A = A^\\top$。\n- 一个对称矩阵 $A$ 是对称正定（SPD）的，如果对于所有非零向量 $x \\in \\mathbb{R}^n$，都有 $x^\\top A x > 0$。\n- Cholesky 分解断言，对于 SPD 矩阵 $A$，存在一个唯一的、具有正对角线元素的下三角矩阵 $L$，使得 $A = L L^\\top$。\n\n您的程序必须：\n- 实现一个函数，该函数从上述定义出发，仅根据需要使用基本运算和线性代数，从输入 $A$ 尝试计算一个下三角因子 $L$。该函数不得调用内置的 Cholesky 分解。\n- 实现错误检查以确保：\n  1) 使用 $A - A^\\top$ 的最大逐元素绝对偏差，在容差 $\\tau_{\\mathrm{sym}}$ 内检查对称性。\n  2) 相对于一个正性阈值 $\\tau_{\\mathrm{pos}}$，检查 $L$ 的对角线元素的严格正性。\n  3) 使用相对 Frobenius 范数误差 $\\lVert A - L L^\\top \\rVert_F / \\lVert A \\rVert_F$，在容差 $\\tau_{\\mathrm{rec}}$ 内检查重构精度。\n- 为每个测试用例返回一个布尔判定结果：当且仅当所有三项检查都通过并且成功构造了一个有效的 $L$ 时，返回 true；否则返回 false。\n\n角度或物理单位在此不适用。\n\n测试套件：\n对于以下每个案例，程序必须应用指定的容差并报告一个布尔值。测试套件必须按以下顺序执行。\n\n- 测试 $1$（理想情况，小型 SPD）：\n  - 矩阵 $A_1 = \\begin{bmatrix} 4  2  2 \\\\ 2  3  1 \\\\ 2  1  3 \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $2$（病态但为 SPD，3 阶 Hilbert 矩阵）：\n  - 矩阵 $A_2$ 的元素为 $(A_2)_{ij} = \\dfrac{1}{i + j - 1}$，其中 $i,j \\in \\{1,2,3\\}$，即 $A_2 = \\begin{bmatrix} 1  \\tfrac{1}{2}  \\tfrac{1}{3} \\\\ \\tfrac{1}{2}  \\tfrac{1}{3}  \\tfrac{1}{4} \\\\ \\tfrac{1}{3}  \\tfrac{1}{4}  \\tfrac{1}{5} \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $3$（对称但非正定）：\n  - 矩阵 $A_3 = \\begin{bmatrix} 1  2 \\\\ 2  1 \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $4$（非对称输入）：\n  - 矩阵 $A_4 = \\begin{bmatrix} 2  1 \\\\ 0  2 \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $5$（5 阶随机 SPD 矩阵，生成过程可复现）：\n  - 通过以下算法流程构造 $A_5$：设置一个显式随机种子 $s = 0$，抽取一个元素为独立标准正态分布的矩阵 $M \\in \\mathbb{R}^{5 \\times 5}$，然后设置 $A_5 = M^\\top M + \\alpha I$，其中 $\\alpha = 10^{-6}$，$I$ 为 $5 \\times 5$ 单位矩阵。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $6$（近似对称的 SPD 矩阵，在对称性容差下可通过）：\n  - 按如下方式构造一个基础 SPD 矩阵 $S$：令 $Q = \\begin{bmatrix} 1  2  3 \\\\ 0  1  4 \\\\ 5  6  0 \\end{bmatrix}$，设置 $S = Q^\\top Q + \\beta I$，其中 $\\beta = 10^{-3}$，$I$ 为 $3 \\times 3$ 单位矩阵。然后通过取 $S$ 并仅向元素 $(1,2)$（使用基于 1 的索引）添加一个微小扰动来定义 $A_6$：设置 $(A_6)_{1,2} \\leftarrow (A_6)_{1,2} + \\varepsilon$，其中 $\\varepsilon = 10^{-11}$，保持所有其他元素与 $S$ 相同。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-10}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含从测试 $1$ 到测试 $6$ 的布尔结果，结果为逗号分隔的列表，并用方括号括起来。例如，一个有效的输出应类似于 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{False}]$（这仅是一个示例）。",
            "solution": "已根据指定的验证协议对问题陈述进行了分析。所有给定的信息、定义、约束和测试用例都已被提取和评估。问题被确定为**有效**。它在科学上基于数值线性代数的原理，特别是 Cholesky 分解。它是适定的、客观的、自包含的，并且可以算法形式化。测试套件定义明确，可以实现确定性且可验证的解决方案。\n\n核心任务是根据第一性原理实现 Cholesky 分解的函数，并用它来验证几个测试矩阵的属性。Cholesky 分解指出，任何实对称正定（SPD）矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 都可以被唯一地分解为乘积 $A = LL^\\top$，其中 $L$ 是一个具有严格正对角线元素的下三角矩阵。\n\n计算 $L = (l_{ij})$ 元素的算法可以通过将 $A = (a_{ij})$ 的元素与乘积 $LL^\\top$ 的元素相等来推导。$LL^\\top$ 的第 $(i, j)$ 个元素由 $(LL^\\top)_{ij} = \\sum_{k=1}^{j} l_{ik} l_{jk}$ 给出，假设 $j \\le i$。\n\n我们可以逐列计算 $L$ 的元素，对于 $j = 0, 1, \\dots, n-1$。\n\n对于对角线元素 $l_{jj}$：\n对角线元素 $a_{jj}$ 的方程为：\n$$a_{jj} = \\sum_{k=0}^{j} l_{jk} l_{jk} = \\left( \\sum_{k=0}^{j-1} l_{jk}^2 \\right) + l_{jj}^2$$\n求解 $l_{jj}$，我们得到：\n$$l_{jj} = \\sqrt{a_{jj} - \\sum_{k=0}^{j-1} l_{jk}^2}$$\n为了使 $L$ 为实矩阵，平方根下的项必须为非负。为了使其具有严格正的对角线元素，该项必须严格为正。如果在任何步骤中此项小于或等于 $0$，则矩阵 $A$ 不是对称正定的，分解失败。这为正定性提供了一个算法测试。\n\n对于非对角线元素 $l_{ij}$，其中 $i > j$：\n非对角线元素 $a_{ij}$ 的方程为：\n$$a_{ij} = \\sum_{k=0}^{j} l_{ik} l_{jk} = \\left( \\sum_{k=0}^{j-1} l_{ik} l_{jk} \\right) + l_{ij} l_{jj}$$\n在 $l_{jj} > 0$ 的条件下求解 $l_{ij}$：\n$$l_{ij} = \\frac{1}{l_{jj}} \\left( a_{ij} - \\sum_{k=0}^{j-1} l_{ik} l_{jk} \\right)$$\n这些公式定义了 Cholesky-Banachiewicz 算法。重要的是要注意，这些推导假设 $A$ 是对称的（即，$a_{ij} = a_{ji}$）。所得算法仅需访问 $A$ 的下三角部分和对角线（即 $i \\ge j$ 的元素 $a_{ij}$）。我们的实现将遵循这一标准惯例。对于一个不完全对称的输入矩阵，该算法将对其下三角部分进行操作。\n\n每个测试矩阵 $A$ 的总体验证过程包括三个检查：\n\n$1$. **对称性检查**：在尝试分解之前，我们在容差 $\\tau_{\\mathrm{sym}}$ 内验证 $A$ 是否对称。我们计算 $A$ 与其转置 $A^\\top$ 之间的最大逐元素绝对差。如果 $\\max_{i,j} |a_{ij} - a_{ji}| \\le \\tau_{\\mathrm{sym}}$，则检查通过。如果此检查失败，则认为该矩阵在给定容差下是非对称的，测试判定为 `False`。\n\n$2$. **对角线正性检查**：成功计算出下三角矩阵 $L$ 后，我们必须验证其所有对角线元素 $l_{ii}$ 都是严格为正的。此检查是相对于一个正性阈值 $\\tau_{\\mathrm{pos}}$ 进行的，即我们要求对于所有 $i=0, \\dots, n-1$ 都有 $l_{ii} > \\tau_{\\mathrm{pos}}$。如果一个 $l_{ii}$ 的值是正数但未超过此阈值，则表示检查失败。这可能发生在接近奇异的矩阵上。\n\n$3$. **重构精度检查**：为确保计算出的因子 $L$ 是正确的，我们将其重构为 $L L^\\top$ 并与原始矩阵 $A$ 进行比较。误差使用相对 Frobenius 范数进行量化：\n$$\\text{err}_{\\mathrm{rec}} = \\frac{\\lVert A - L L^\\top \\rVert_F}{\\lVert A \\rVert_F}$$\n其中 $\\lVert M \\rVert_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$。如果此相对误差小于指定的重构容差 $\\tau_{\\mathrm{rec}}$，则检查通过。\n\n当且仅当输入矩阵通过对称性检查，Cholesky 分解算法成功生成矩阵 $L$，并且此 $L$ 随后通过了对角线正性检查和重构精度检查时，一个测试用例返回 `True`。否则，该测试用例返回 `False`。\n\n该逻辑被封装在一个程序中，用于评估所提供的测试套件。对于测试 3，矩阵是对称的但非正定，因此分解算法预计会失败。对于测试 4，矩阵是非对称的，因此预计会未通过初始的对称性检查。对于测试 6，矩阵被构造成近似对称，因此它将在给定容差 $\\tau_{\\mathrm{sym}} = 10^{-10}$ 下通过对称性检查。由于所实现的算法从输入矩阵的下三角部分读取数据，它将有效地对底层的 SPD 矩阵进行操作，成功计算出因子，并通过所有后续检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_cholesky(A):\n    \"\"\"\n    Attempts to compute the Cholesky decomposition of a matrix A.\n\n    This function implements the Cholesky-Banachiewicz algorithm, which computes\n    the lower-triangular matrix L column by column, such that A = L L^T.\n    The algorithm assumes A is symmetric and will only access the lower-triangular\n    part of A.\n\n    Args:\n        A (np.ndarray): A square numpy array.\n\n    Returns:\n        np.ndarray or None: The lower-triangular factor L if the decomposition is\n        successful, otherwise None (if the matrix is not positive definite).\n    \"\"\"\n    n = A.shape[0]\n    if A.shape[1] != n:\n        raise ValueError(\"Input matrix must be square.\")\n\n    L = np.zeros_like(A, dtype=float)\n\n    for j in range(n):\n        # Compute the diagonal element L[j, j]\n        # s = sum_{k=0}^{j-1} L[j, k]^2\n        s = L[j, :j] @ L[j, :j].T\n        \n        # Argument for square root\n        d = A[j, j] - s\n        \n        # Check for positive definiteness. If d is non-positive, the algorithm fails.\n        if d = 0:\n            return None\n        \n        L[j, j] = np.sqrt(d)\n        \n        # Compute the off-diagonal elements in column j\n        for i in range(j + 1, n):\n            # s_ij = sum_{k=0}^{j-1} L[i,k] * L[j,k]\n            s_ij = L[i, :j] @ L[j, :j].T\n            L[i, j] = (A[i, j] - s_ij) / L[j, j]\n            \n    return L\n\ndef test_cholesky(A, tau_sym, tau_pos, tau_rec):\n    \"\"\"\n    Performs Cholesky decomposition and verifies a set of properties.\n\n    Args:\n        A (np.ndarray): The input matrix for testing.\n        tau_sym (float): Tolerance for the symmetry check.\n        tau_pos (float): Threshold for diagonal entry positivity.\n        tau_rec (float): Tolerance for reconstruction accuracy.\n\n    Returns:\n        bool: True if A passes all checks, False otherwise.\n    \"\"\"\n    if A.ndim != 2 or A.shape[0] != A.shape[1]:\n        return False\n\n    # 1. Symmetry check\n    sym_err = np.max(np.abs(A - A.T))\n    if sym_err >= tau_sym:\n        return False\n\n    # Attempt to compute Cholesky factor\n    L = compute_cholesky(A)\n    \n    # If decomposition fails, L is None\n    if L is None:\n        return False\n        \n    # 2. Diagonal positivity check\n    if not np.all(np.diag(L) > tau_pos):\n        return False\n        \n    # 3. Reconstruction accuracy check\n    A_reconstructed = L @ L.T\n    norm_A = np.linalg.norm(A, 'fro')\n    \n    if norm_A == 0: # Handle zero matrix case\n        if np.linalg.norm(A - A_reconstructed, 'fro') == 0:\n            rec_err = 0.0\n        else:\n            return False # Non-zero error for a zero matrix\n    else:\n        rec_err = np.linalg.norm(A - A_reconstructed, 'fro') / norm_A\n\n    if rec_err >= tau_rec:\n        return False\n        \n    # All checks passed\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report the test suite results.\n    \"\"\"\n    # Test 1: Happy path, small SPD\n    A1 = np.array([[4, 2, 2], [2, 3, 1], [2, 1, 3]], dtype=float)\n    tols1 = (1e-15, 1e-15, 1e-12)\n\n    # Test 2: Ill-conditioned but SPD (Hilbert matrix)\n    A2 = np.array([[1, 1/2, 1/3], [1/2, 1/3, 1/4], [1/3, 1/4, 1/5]], dtype=float)\n    tols2 = (1e-15, 1e-15, 1e-12)\n\n    # Test 3: Symmetric but not positive definite\n    A3 = np.array([[1, 2], [2, 1]], dtype=float)\n    tols3 = (1e-15, 1e-15, 1e-12)\n\n    # Test 4: Non-symmetric input\n    A4 = np.array([[2, 1], [0, 2]], dtype=float)\n    tols4 = (1e-15, 1e-15, 1e-12)\n\n    # Test 5: Random SPD matrix\n    np.random.seed(0)\n    M = np.random.randn(5, 5)\n    A5 = M.T @ M + 1e-6 * np.eye(5)\n    tols5 = (1e-15, 1e-15, 1e-12)\n\n    # Test 6: Nearly symmetric SPD matrix\n    Q = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]], dtype=float)\n    S = Q.T @ Q + 1e-3 * np.eye(3)\n    A6 = S.copy()\n    A6[0, 1] += 1e-11 # Perturb upper triangle (index (0,1) is entry (1,2))\n    tols6 = (1e-10, 1e-15, 1e-12)\n    \n    test_cases = [\n        (A1, *tols1),\n        (A2, *tols2),\n        (A3, *tols3),\n        (A4, *tols4),\n        (A5, *tols5),\n        (A6, *tols6),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, ts, tp, tr = case\n        result = test_cholesky(A, ts, tp, tr)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在现实世界的应用中，我们遇到的矩阵往往不满足理想的正定条件，导致标准的 Cholesky 分解失败。本练习  将教你一种强大且常用的技术：自适应正则化。你将实现一个稳健的求解器，它能通过迭代地增加一个微小的对角元素 $\\lambda I$ 来确保矩阵最终变为正定，从而保证分解的成功。",
            "id": "3106437",
            "problem": "您需要实现一个用于对称矩阵的鲁棒数值程序，该程序通过带有对角正则化的 Cholesky 分解来计算一个下三角因子。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实对称矩阵。根据定义，如果对于所有非零 $x \\in \\mathbb{R}^n$ 都有 $x^\\top A x > 0$，则该矩阵是对称正定 (SPD) 的。对于一个 SPD 矩阵 $A$，存在一个唯一的、对角项为正的下三角矩阵 $L$，使得 $A = L L^\\top$。当 $A$ 不是 SPD 矩阵时，计算科学中的一种常用技术是添加对角正则化（也称为对角移位），即考虑 $A + \\lambda I$，其中 $\\lambda \\ge 0$，$I$ 是单位矩阵。\n\n您的任务是设计并实现一个鲁棒的求解器，该求解器在给定一个实对称矩阵 $A$ 的情况下，尝试计算其 Cholesky 因子，并自适应地增加一个标量对角正则化参数 $\\lambda$，直到分解成功且根据最小对角线阈值判断其数值稳定。求解器必须遵循以下原则和约束。\n\n- 从核心定义出发：$A$ 的对称性、SPD 矩阵的 Cholesky 分解的存在性和唯一性，以及加上 $\\lambda I$ 会使 $A$ 的每个特征值都增加 $\\lambda$ 这一事实。\n- 算法必须从 $\\lambda = 0$ 开始，尝试对 $A + \\lambda I$ 进行 Cholesky 分解。如果分解计算失败，则增加 $\\lambda$ 并重试。如果分解成功，但得到的下三角因子 $L$ 的最小对角项低于预设阈值，则利用观测到的最小对角项 $L_{ii}$ 的信息来增加 $\\lambda$ 并重试。持续此过程，直到分解成功且 $L$ 的最小对角项达到或超过该阈值。\n- $\\lambda$ 的增加必须有合理的逻辑依据，不能依赖任何黑箱捷径。具体而言：\n  - 如果尚无一次分解成功，为 $\\lambda$ 选择一个足以使 $A + \\lambda I$ 按行成为严格对角占优且带有一个小的正裕度的增量，这保证了对称矩阵的所有特征值为正。具体来说，对每一行 $i$，令 $r_i = \\sum_{j \\ne i} |a_{ij}|$ 且 $a_{ii}$ 为对角项。严格对角占优的一个充分条件是 $a_{ii} + \\lambda > r_i$。您的实现必须通过设置以下公式，将此作为 $\\lambda$ 的安全下界：\n    $$\n    \\lambda \\leftarrow \\max\\left(\\lambda, \\max_i \\max\\{0, r_i - a_{ii} + \\eta\\}\\right),\n    $$\n    其中 $\\eta > 0$ 是一个下方指定的小安全裕度。\n  - 如果对于某个 $\\lambda$ 分解已经成功，令 $\\ell_{\\min}$ 为 $L$ 中观测到的最小对角项。如果 $\\ell_{\\min}$ 小于阈值 $\\tau > 0$，则使用 $\\ell_{\\min}$ 自适应地增加 $\\lambda$，以使下一次尝试的目标是获得更大的 $\\ell_{\\min}$。为确保在仅有对角线的情况下取得进展，您至少需要将 $\\lambda$ 增加 $(\\tau - \\ell_{\\min})^2$；为确保严格单调性，至少增加 $\\eta$：\n    $$\n    \\lambda \\leftarrow \\lambda + \\max\\left\\{(\\tau - \\ell_{\\min})^2, \\eta\\right\\}。\n    $$\n- 在继续之前，始终通过将 $A$ 替换为 $(A + A^\\top)/2$ 来将其视为对称矩阵。最多尝试 $100$ 次；然而，对于提供的测试，正确的实现应远在此限制内成功。\n\n使用的参数：\n- Cholesky 因子的最小可接受对角线阈值：$\\tau = 10^{-5}$。\n- 用于对角占优和单调性的安全裕度：$\\eta = 10^{-12}$。\n- 最大尝试次数：$100$。\n\n测试套件：\n对于下面的每个矩阵，您的程序必须计算并报告在最后一次成功尝试中算法所使用的最终标量 $\\lambda \\ge 0$。对每种情况都使用相同的 $\\tau$ 和 $\\eta$。这些矩阵是：\n\n- 情况 1 (已为 SPD，条件适中):\n  $$\n  A_1 = \\begin{bmatrix}\n  4  1  2 \\\\\n  1  3  0.5 \\\\\n  2  0.5  5\n  \\end{bmatrix}.\n  $$\n- 情况 2 (对称不定):\n  $$\n  A_2 = \\begin{bmatrix}\n  0  1 \\\\\n  1  0\n  \\end{bmatrix}.\n  $$\n- 情况 3 (对称半正定，秩亏):\n  $$\n  A_3 = \\begin{bmatrix}\n  1  1  1 \\\\\n  1  1  1 \\\\\n  1  1  1\n  \\end{bmatrix}.\n  $$\n- 情况 4 (零矩阵):\n  $$\n  A_4 = \\begin{bmatrix}\n  0  0 \\\\\n  0  0\n  \\end{bmatrix}.\n  $$\n- 情况 5 (病态 SPD，对角元素极小):\n  $$\n  A_5 = \\begin{bmatrix}\n  10^{-12}  0 \\\\\n  0  1\n  \\end{bmatrix}.\n  $$\n\n程序要求：\n- 您的程序应实现上述鲁棒过程。它不能依赖任何外部输入。\n- 对每种情况，计算成功尝试中实际使用的最终 $\\lambda$。\n- 最终输出格式：您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的十进制数列表。例如，输出行必须类似于 $[x_1,x_2,x_3,x_4,x_5]$，不含空格。每个 $x_i$ 都应是四舍五入到 $10$ 位有效数字的浮点字面量。",
            "solution": "用户提供的问题陈述已经过验证，被认为是合理、适定且客观的。任务是为实对称矩阵实现一个鲁棒的 Cholesky 分解算法，其中包含一个自适应的对角正则化方案。\n\nCholesky 分解的核心原理是，一个对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是正定的，当且仅当它有一个唯一的分解 $A = LL^\\top$，其中 $L$ 是一个对角项严格为正的下三角矩阵。如果对于所有非零向量 $x \\in \\mathbb{R}^n$，都有 $x^\\top A x > 0$，则矩阵 $A$ 是对称正定 (SPD) 的。这等价于 $A$ 的所有特征值都为正。\n\n当一个对称矩阵 $A$ 不是 SPD（即，它是半正定或不定的，具有零或负特征值）时，标准的 Cholesky 算法会失败。一个常见的补救方法是对角正则化，即我们考虑矩阵 $A' = A + \\lambda I$，其中 $\\lambda \\ge 0$ 是一个标量，$I$ 是单位矩阵。加上 $\\lambda I$ 会使 $A$ 的每个特征值都增加 $\\lambda$。因此，通过选择一个足够大的 $\\lambda$，我们可以确保 $A'$ 的所有特征值都为正，从而使其成为 SPD 矩阵，进而适用于 Cholesky 分解。\n\n所要求的算法将此正则化过程形式化为一个迭代和自适应的程序。\n\n**1. 对称化**\n作为一个预备步骤，输入矩阵 $A$ 被显式地对称化。这可以处理输入中潜在的浮点数不精确性。该操作为 $A \\leftarrow \\frac{1}{2}(A + A^\\top)$。由于问题是为对称矩阵定义的，此步骤确保了数值表示严格满足该属性。\n\n**2. 迭代正则化与分解**\n该算法迭代地尝试寻找一个合适的正则化参数 $\\lambda$，以得到一个成功且数值稳定的 Cholesky 分解。\n\n该过程从 $\\lambda = 0$ 的初始猜测开始，对应于尝试分解原始矩阵。算法在一个循环内进行，最多尝试 $100$ 次。\n\n在每次迭代中，执行以下步骤：\n1.  构造正则化矩阵 $A' = A + \\lambda I$。\n2.  尝试计算 $A'$ 的 Cholesky 因子 $L$，使得 $A' = LL^\\top$。这通常使用一个库函数来完成，如果矩阵非正定，该函数会引发错误。\n\n可能出现两种结果：分解失败或成功。\n\n**3. 处理分解失败**\n如果 $A' = A + \\lambda I$ 的 Cholesky 分解失败，这意味着 $A'$ 不是正定矩阵。为保证后续尝试成功，必须增加 $\\lambda$。规定的更新规则基于使矩阵严格对角占优，这是对称矩阵为正定的一个充分（但不必要）条件。\n\n一个对称矩阵 $M$ 是严格对角占优的，如果对于每一行 $i$，对角元素的绝对值大于该行非对角元素绝对值之和：$|M_{ii}| > \\sum_{j \\neq i} |M_{ij}|$。对于我们的正则化矩阵 $A'$，此条件变为 $a_{ii} + \\lambda > \\sum_{j \\neq i} |a_{ij}|$。\n\n为了对所有行满足此条件并带有一个小的安全裕度 $\\eta > 0$，我们必须选择 $\\lambda$，使得对于所有 $i$，都有 $\\lambda > (\\sum_{j \\neq i} |a_{ij}|) - a_{ii}$。因此，$\\lambda$ 的更新规则被设置为一个能确保此条件满足的值，同时也确保 $\\lambda$ 不会减小：\n$$\n\\lambda \\leftarrow \\max\\left(\\lambda_{old}, \\max_i \\max\\{0, r_i - a_{ii} + \\eta\\}\\right)\n$$\n其中 $r_i = \\sum_{j \\neq i} |a_{ij}|$。一旦 $\\lambda$ 更新到此值，后续对 $A + \\lambda I$ 的 Cholesky 分解尝试保证会成功。此规则是为“尚无一次分解成功”的情况指定的，但它为任何分解失败提供了鲁棒的后备方案。\n\n**4. 处理成功但不稳定的分解**\n如果 Cholesky 分解成功，生成了下三角矩阵 $L$，我们必须评估其数值稳定性。$L$ 中存在非常小的对角项是数值不稳定的一个常见指标。这些小对角项可能导致 $L^{-1}$ 中出现大元素，并在后续计算（例如，解线性系统）中放大误差。\n\n算法将 $L$ 的最小对角项（记为 $\\ell_{\\min} = \\min_i L_{ii}$）与预设阈值 $\\tau > 0$ 进行比较。如果 $\\ell_{\\min}  \\tau$，则认为分解不稳定，必须增加 $\\lambda$ 以在下一次迭代中生成一个“更正定”的矩阵。\n\n针对这种情况的自适应更新规则是：\n$$\n\\lambda \\leftarrow \\lambda_{old} + \\max\\left\\{(\\tau - \\ell_{\\min})^2, \\eta\\right\\}\n$$\n这个更新是启发式的，但有其动机。对于一个简单的 $1 \\times 1$ 矩阵 $A = [a]$，$L = [\\sqrt{a}]$。如果我们想将 $L$ 从 $\\ell_{\\min}$ 变为 $\\tau$，我们需要将 $a$ 改变 $\\tau^2 - \\ell_{\\min}^2 = (\\tau - \\ell_{\\min})(\\tau + \\ell_{\\min})$。$(\\tau - \\ell_{\\min})^2$ 这一项作为一个相关且易于计算的增量。包含 $\\eta$ 确保了 $\\lambda$ 在每一步都严格增加，从而保证了进展并最终终止。\n\n**5. 终止**\n当 Cholesky 分解计算成功且得到的因子 $L$ 满足稳定性准则（即 $\\min_i L_{ii} \\ge \\tau$）时，迭代过程成功终止。在这次成功尝试中使用的最终 $\\lambda$ 值就是给定矩阵 $A$ 的结果。如果超过最大尝试次数（100次），循环也会终止，这表示算法失败。对于指定的测试用例，预期解应远在此限制内找到。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef robust_cholesky_lambda(A, tau, eta, max_attempts):\n    \"\"\"\n    Computes a regularized Cholesky decomposition of a symmetric matrix A.\n\n    Args:\n        A (np.ndarray): The input matrix.\n        tau (float): The minimum acceptable diagonal threshold for the Cholesky factor.\n        eta (float): The safety margin for regularization updates.\n        max_attempts (int): The maximum number of attempts.\n\n    Returns:\n        float: The final regularization parameter lambda used.\n    \"\"\"\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n    \n    # Symmetrize the matrix A\n    A_sym = (A + A.T) / 2.0\n    n = A_sym.shape[0]\n    \n    current_lambda = 0.0\n    \n    # Flag to track if a successful factorization has occurred yet.\n    # The problem describes different update rules based on this.\n    # However, the diagonal dominance update rule makes the next attempt succeed,\n    # so we will only use it once if the first attempt(s) fail.\n    \n    for _ in range(max_attempts):\n        A_reg = A_sym + current_lambda * np.identity(n)\n        \n        try:\n            L = np.linalg.cholesky(A_reg)\n            \n            # --- Factorization succeeded ---\n            min_diag_L = np.min(np.diag(L))\n            \n            if min_diag_L >= tau:\n                # Success and stable: terminate\n                return current_lambda\n            else:\n                # Success but unstable: update lambda and retry\n                increment = max((tau - min_diag_L)**2, eta)\n                current_lambda += increment\n                \n        except np.linalg.LinAlgError:\n            # --- Factorization failed ---\n            # Update lambda based on making the matrix diagonally dominant.\n            \n            # This rule is specified for \"if no factorization has succeeded yet\".\n            # After this update, factorization should succeed.\n            \n            row_sums = np.sum(np.abs(A_sym), axis=1) - np.abs(np.diag(A_sym))\n            diag_diffs = row_sums - np.diag(A_sym)\n            \n            # For rows where a_ii > r_i already, max(0, ...) is 0.\n            lambda_dd = np.max(np.maximum(0, diag_diffs)) + eta\n\n            # The rule is lambda - max(lambda, lambda_dd)\n            # This ensures lambda does not decrease. If the first lambda=0 failed, \n            # the new lambda will be lambda_dd.\n            current_lambda = max(current_lambda, lambda_dd)\n\n    # If the loop finishes, max attempts were reached without a stable factor.\n    raise RuntimeError(f\"Robust Cholesky failed to converge in {max_attempts} attempts.\")\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Parameters from the problem statement\n    tau = 1e-5\n    eta = 1e-12\n    max_attempts = 100\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [4.0, 1.0, 2.0],\n            [1.0, 3.0, 0.5],\n            [2.0, 0.5, 5.0]\n        ]),\n        np.array([\n            [0.0, 1.0],\n            [1.0, 0.0]\n        ]),\n        np.array([\n            [1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0]\n        ]),\n        np.array([\n            [0.0, 0.0],\n            [0.0, 0.0]\n        ]),\n        np.array([\n            [1e-12, 0.0],\n            [0.0, 1.0]\n        ])\n    ]\n\n    results = []\n    for A in test_cases:\n        final_lambda = robust_cholesky_lambda(A, tau, eta, max_attempts)\n        # Format to 10 significant digits using the 'g' format specifier\n        formatted_result = f'{final_lambda:.10g}'\n        results.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单的修正，我们还可以利用分解过程本身来诊断矩阵的性质。这项进阶练习  将展示如何通过监控分解过程中的“主元”大小，来修改 Cholesky 算法以判断矩阵的数值秩。这种方法能够实现一种更精细的、靶向性的正则化，只对矩阵中存在问题的方向进行修正。",
            "id": "3106439",
            "problem": "您的任务是在计算科学导论的背景下，设计并实现一个基于 Cholesky 分解的、用于对称矩阵数值秩检测和正则化的原理性算法。您的解决方案必须是一个完整、可运行的程序。请从基本原理和核心定义出发，不要依赖任何专门的快捷公式。\n\n假设与核心定义：\n- 如果对于所有非零向量 $x \\in \\mathbb{R}^{n}$，都有 $x^{\\top} A x \\ge 0$ 成立，那么矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 被称为对称半正定 (SPSD) 矩阵。\n- 对于一个对称正定 (SPD) 矩阵 $A$，其 Cholesky 分解为 $A = L L^{\\top}$，其中 $L$ 是一个对角线元素严格为正的下三角矩阵。\n- 在浮点运算中，分解过程中出现的极小主元表明可能存在近奇异方向。数值秩的概念使用一个容差来判断某个方向是否有效为零。\n\n请基于以下基本原理设计算法：\n- SPD 矩阵存在 $A = L L^{\\top}$ 分解的事实以及 Schur 补的定义。\n- 在一个左向 Cholesky 过程中，第 $k$ 步的临时主元的平方是 $t_k = A_{kk} - \\sum_{i=0}^{k-1} L_{k i}^2$，该值等于当前 Schur 补的 $(k,k)$ 项。\n- 当 $t_k \\le \\tau \\cdot p_{\\max}$ 时，一个阈值测试将主元声明为“数值上为零”，其中 $\\tau \\in (0,1)$ 是一个相对容差，而 $p_{\\max} = \\max_j A_{jj}$ 是问题的尺度。\n\n您的任务：\n1) 对给定的对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和容差 $\\tau \\in (0,1)$，实现一个不使用主元选择的截断 Cholesky 分解：\n   - 初始化一个全零的下三角矩阵 $L$ 和一个布尔类型的丢弃掩码 $d \\in \\{ \\text{False}, \\text{True} \\}^n$。\n   - 对于 $k = 0, 1, \\dots, n-1$ 执行：\n     - 计算 $s_k = \\sum_{i=0}^{k-1} L_{k i}^2$ 和 $t_k = A_{k k} - s_k$。\n     - 令 $p_{\\max} = \\max_j A_{j j}$。如果 $t_k \\le \\tau \\cdot p_{\\max}$，则设置 $L_{k k} = 0$，标记 $d_k = \\text{True}$，并跳过计算 $j > k$ 的 $L_{j k}$。\n     - 否则，设置 $L_{k k} = \\sqrt{\\max(t_k, 0)}$，并对每个 $j = k+1, \\dots, n-1$ 计算\n       $$\n       u_{j k} = A_{j k} - \\sum_{i=0}^{k-1} L_{j i} L_{k i}, \\quad L_{j k} = \\frac{u_{j k}}{L_{k k}}.\n       $$\n   - 将数值秩估计定义为 $\\hat{r} = \\#\\{k : L_{k k} > 0\\}$。\n\n2) 定义截断近似 $A_{\\text{trunc}} = L L^{\\top}$。\n\n3) 定义一个仅作用于被丢弃方向的方向感知正则化：\n   - 构建一个对角投影算子 $P \\in \\mathbb{R}^{n \\times n}$，其中如果 $d_k = \\text{True}$ 则 $P_{k k} = 1$，否则 $P_{k k} = 0$。\n   - 对于正则化强度 $\\lambda > 0$，定义正则化矩阵\n     $$\n     A_{\\text{reg}} = A_{\\text{trunc}} + \\lambda P.\n     $$\n\n4) 对于下方的每个测试用例，计算并返回以下四个量：\n   - 估计的数值秩 $\\hat{r}$ (一个整数)。\n   - Frobenius 范数重构误差 $e_F = \\lVert A - A_{\\text{trunc}} \\rVert_F$ (一个浮点数)。\n   - $A_{\\text{reg}}$ 的最小特征值 (一个浮点数)。\n   - $A_{\\text{reg}}$ 的谱条件数，定义为 $\\kappa_2(A_{\\text{reg}}) = \\lambda_{\\max}(A_{\\text{reg}}) / \\lambda_{\\min}(A_{\\text{reg}})$ (一个浮点数)。\n\n测试套件：\n提供以下所有用例的结果。所有常数和数字必须在标准实数算术中解释。\n\n- 用例 1 (良态 SPD)：\n  $$\n  A_1 = \\begin{bmatrix}\n  5  1  0  0 \\\\\n  1  4  1  0 \\\\\n  0  1  3  1 \\\\\n  0  0  1  2\n  \\end{bmatrix}, \\quad \\tau = 10^{-12}, \\quad \\lambda = 10^{-6}.\n  $$\n\n- 用例 2 (含有一个极小方向的对角矩阵)：\n  $$\n  A_2 = \\operatorname{diag}(1, 10^{-8}, 10^{-12}), \\quad \\tau = 10^{-10}, \\quad \\lambda = 10^{-6}.\n  $$\n\n- 用例 3 (恰好为秩-1)：\n  $$\n  v = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}, \\quad A_3 = v v^{\\top}, \\quad \\tau = 10^{-12}, \\quad \\lambda = 10^{-6}.\n  $$\n\n- 用例 4 (具有非对角结构的近奇异矩阵)：\n  令 $\\varepsilon = 10^{-8}$ 且\n  $$\n  B = \\begin{bmatrix}\n  1  1 - \\varepsilon  0 \\\\\n  0  1  \\varepsilon \\\\\n  0  0  \\varepsilon\n  \\end{bmatrix}, \\quad A_4 = B B^{\\top}, \\quad \\tau = 10^{-10}, \\quad \\lambda = 10^{-6}.\n  $$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。该列表必须恰好包含四个嵌套列表，每个测试用例一个，顺序与上文相同。每个嵌套列表的形式必须为 $[\\hat{r}, e_F, \\lambda_{\\min}(A_{\\text{reg}}), \\kappa_2(A_{\\text{reg}})]$。例如：\n\"[ [r1,err1,min1,cond1],[r2,err2,min2,cond2],[r3,err3,min3,cond3],[r4,err4,min4,cond4] ]\"\n每个嵌套列表中的所有四个条目都必须是数值标量（$\\hat{r}$ 为整数，其他为浮点数）。此问题不涉及任何物理单位。",
            "solution": "该问题是有效的。这是一个在数值线性代数领域中定义明确的练习，它基于矩阵分解和正则化的既定原理。算法、参数和测试用例的规定是完整且一致的，从而可以得到唯一且可验证的解。\n\n这个问题的核心是实现一个专门的 Cholesky 分解算法，该算法旨在处理可能数值秩亏的对称半正定 (SPSD) 矩阵。然后，我们将使用此分解的输出来分析和正则化输入矩阵。\n\n### Cholesky 分解的原理\n\n对于一个对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其 Cholesky 分解为 $A = L L^{\\top}$，其中 $L \\in \\mathbb{R}^{n \\times n}$ 是一个对角线元素严格为正的下三角矩阵。$L$ 的元素可以通过令 $A$ 的元素与 $L L^{\\top}$ 的元素相等来导出。乘积 $L L^{\\top}$ 的元素为 $(L L^{\\top})_{jk} = \\sum_{i=0}^{n-1} L_{ji} L_{ki}^{\\top} = \\sum_{i=0}^{\\min(j,k)} L_{ji} L_{ki}$。\n\n我们来考虑计算 $L$ 的第 $k$ 列，假设第 $0, \\dots, k-1$ 列已知。这被称为左向或上向算法。\n对于对角线元素 $L_{kk}$，我们有：\n$$\nA_{kk} = (L L^{\\top})_{kk} = \\sum_{i=0}^{k} L_{ki}^2 = \\sum_{i=0}^{k-1} L_{ki}^2 + L_{kk}^2\n$$\n整理可得 $L_{kk}$：\n$$\nL_{kk} = \\sqrt{A_{kk} - \\sum_{i=0}^{k-1} L_{ki}^2}\n$$\n平方根下的项 $t_k = A_{kk} - \\sum_{i=0}^{k-1} L_{ki}^2$ 是临时主元。对于 SPD 矩阵，$t_k$ 保证为正。该项也是 $A$ 的左上角 $(k-1) \\times (k-1)$ 子块的 Schur 补的 $(k,k)$ 项，如果 $A$ 是正定的，那么这个 Schur 补也必须是正定的。\n\n对于 $j > k$ 的非对角线元素 $L_{jk}$，我们有：\n$$\nA_{jk} = (L L^{\\top})_{jk} = \\sum_{i=0}^{k} L_{ji} L_{ki} = \\sum_{i=0}^{k-1} L_{ji} L_{ki} + L_{jk} L_{kk}\n$$\n整理可得 $L_{jk}$：\n$$\nL_{jk} = \\frac{1}{L_{kk}} \\left( A_{jk} - \\sum_{i=0}^{k-1} L_{ji} L_{ki} \\right)\n$$\n这要求 $L_{kk} > 0$，对于 SPD 矩阵该条件成立。\n\n### 用于秩检测的截断 Cholesky 分解\n\n如果 $A$ 是 SPSD 但非 SPD（即，它是奇异的），那么至少有一个主元 $t_k$ 将为零。在浮点运算中，对于近奇异矩阵，主元 $t_k$ 可能成为一个非常小的正数。标准的 Cholesky 算法可能会继续进行，但得到的因子 $L$ 可能是病态的，随后除以一个很小的 $L_{kk}$ 会引入巨大的数值误差。\n\n指定的算法引入了一个阈值测试来优雅地处理这种情况。如果一个主元 $t_k \\le \\tau \\cdot p_{\\max}$，它就被认为是数值上为零，其中 $\\tau$ 是一个小的相对容差，$p_{\\max} = \\max_j A_{jj}$ 提供了一个依赖于问题的尺度。使用相对容差对于使该方法对输入矩阵 $A$ 的缩放具有鲁棒性至关重要。\n\n当一个主元 $t_k$ 被视为数值上为零时：\n1. 我们设置 $L_{kk} = 0$。这表示第 $k$ 个方向依赖于之前的方向 $0, \\dots, k-1$。\n2. 我们设置一个标志 $d_k = \\text{True}$，将此列标记为“已丢弃”。\n3. 我们不计算该列的其余部分（对于 $j > k$ 的 $L_{jk}$）。由于 $L$ 被初始化为零矩阵，这些元素保持为零。这在数学上是一致的，因为将 $L$ 的一列乘以 $0$ 对后续步骤没有影响。\n\n数值秩 $\\hat{r}$ 则是未被丢弃的列数，即我们为其找到了足够大主元的列数，也就是 $\\hat{r} = \\#\\{k : L_{k k} > 0\\}$。\n\n### 矩阵近似与正则化\n\n从计算出的截断因子 $L$，我们可以构成原始矩阵的近似 $A_{\\text{trunc}} = L L^{\\top}$。如果 $A$ 是秩亏的，并且算法正确地识别了零空间方向，那么 $A_{\\text{trunc}}$ 将是 $A$ 的一个低秩近似。差值的 Frobenius 范数 $e_F = \\lVert A - A_{\\text{trunc}} \\rVert_F$ 量化了这种近似的误差。对于一个精确秩亏的矩阵（如用例 3），这个误差可能在机器精度范围内为零。\n\n矩阵 $A_{\\text{trunc}}$ 根据其构造是 SPSD 但奇异的，因为它在与 $L$ 的已丢弃列相对应的行和列上为零。对于许多应用，需要一个严格正定的矩阵。所提出的方向感知正则化通过只“提升”零方向来实现这一点。我们构造一个对角投影算子 $P$，其中仅对已丢弃的方向（即 $d_k = \\text{True}$ 的方向）设置 $P_{kk}=1$。正则化后的矩阵是：\n$$\nA_{\\text{reg}} = A_{\\text{trunc}} + \\lambda P\n$$\n其中 $\\lambda > 0$ 是一个小的正则化参数。此操作等同于将 $\\lambda$ 加到 $A_{\\text{trunc}}$ 中与已识别的零空间方向相对应的对角线元素上。结果 $A_{\\text{reg}}$ 保证是 SPD。它的最小特征值 $\\lambda_{\\min}(A_{\\text{reg}})$ 将严格为正，其谱条件数 $\\kappa_2(A_{\\text{reg}}) = \\lambda_{\\max}(A_{\\text{reg}}) / \\lambda_{\\min}(A_{\\text{reg}})$ 变得良定义且有限。这种正则化比向原始矩阵添加 $\\lambda I$ 更具针对性，因为它不会扰动矩阵的良定义部分。\n\n### 算法实现\n\n我们现在将实现这个过程。主函数将以 $A$、$\\tau$ 和 $\\lambda$ 作为输入。\n1. 初始化一个 $n \\times n$ 的全零矩阵 $L$ 和一个长度为 $n$、所有元素为 `False` 的丢弃掩码 $d$。\n2. 计算尺度因子 $p_{\\max} = \\max_{j} A_{jj}$。\n3. 迭代 $k$ 从 $0$ 到 $n-1$：\n    a. 计算点积 $s_k = \\sum_{i=0}^{k-1} L_{ki}^2 = L[k, :k] \\cdot L[k, :k]$。\n    b. 计算临时主元 $t_k = A_{kk} - s_k$。\n    c. 如果 $t_k \\le \\tau \\cdot p_{\\max}$：设置 $L_{kk}=0$ 和 $d_k=\\text{True}$。\n    d. 否则：设置 $L_{kk} = \\sqrt{t_k}$ (注意，`max(t_k, 0)` 是为了鲁棒性而使用的，但在这里 $t_k$ 是正的)，然后计算该列的其余部分：$u_{jk} = A_{jk} - \\sum_{i=0}^{k-1} L_{ji} L_{ki}$ 可以被向量化为矩阵-向量乘积 `A[j>k, k] - L[j>k, :k] @ L[k, :k]`，然后进行除法 $L_{jk} = u_{jk} / L_{kk}$。\n4. 循环结束后，计算所需的四个量：\n    a. 秩 $\\hat{r}$：`np.diag(L) > 0` 中 `True` 值的数量。\n    b. 截断矩阵 $A_{\\text{trunc}} = L L^{\\top}$。\n    c. 重构误差 $e_F = \\lVert A - A_{\\text{trunc}} \\rVert_F$。\n    d. 从掩码 $d$ 构造投影算子 $P$。\n    e. 正则化矩阵 $A_{\\text{reg}} = A_{\\text{trunc}} + \\lambda P$。\n    f. $A_{\\text{reg}}$ 的特征值 (对对称矩阵使用 `numpy.linalg.eigvalsh`)。\n    g. $\\lambda_{\\min}(A_{\\text{reg}})$ 和条件数 $\\kappa_2(A_{\\text{reg}})$。\n\n此过程将应用于提供的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef truncated_cholesky_regularization(A, tau, lambda_reg):\n    \"\"\"\n    Performs truncated Cholesky factorization, regularization, and analysis.\n\n    Args:\n        A (np.ndarray): The symmetric input matrix.\n        tau (float): The relative tolerance for rank detection.\n        lambda_reg (float): The regularization strength.\n\n    Returns:\n        tuple: A tuple containing (r_hat, e_F, min_eig_reg, cond_reg).\n    \"\"\"\n    n = A.shape[0]\n    L = np.zeros((n, n), dtype=float)\n    d = np.zeros(n, dtype=bool)\n\n    # The problem statement defines p_max based on the original matrix A.\n    # This ensures a consistent scale throughout the factorization.\n    diag_A = np.diag(A)\n    # Handle the edge case of a zero matrix, where max would fail.\n    p_max = np.max(diag_A) if diag_A.size > 0 else 1.0\n    if p_max = 0: # Handle non-positive diagonal for robustness\n        p_max = 1.0\n\n    threshold = tau * p_max\n\n    for k in range(n):\n        # Compute s_k = sum_{i=0}^{k-1} L_ki^2\n        # This is the dot product of the k-th row of L up to column k-1\n        s_k = np.dot(L[k, :k], L[k, :k])\n        \n        # Compute the provisional pivot t_k\n        t_k = A[k, k] - s_k\n\n        if t_k = threshold:\n            L[k, k] = 0.0\n            d[k] = True\n            # The rest of column k (L[j>k, k]) remains zero as initialized.\n        else:\n            # L_kk is guaranteed to be positive.\n            # max(t_k, 0) is a safeguard against minor fp errors pushing t_k negative\n            L[k, k] = np.sqrt(max(t_k, 0))\n            \n            # Compute remaining elements in column k\n            if k  n - 1:\n                # u_jk = A_jk - sum_{i=0}^{k-1} L_ji L_ki\n                # This is a vector operation for all j > k\n                u_col_k = A[k+1:n, k] - np.dot(L[k+1:n, :k], L[k, :k])\n                L[k+1:n, k] = u_col_k / L[k, k]\n\n    # 1) Estimated numerical rank\n    r_hat = np.sum(np.diag(L) > 0)\n\n    # 2) Truncated approximation and reconstruction error\n    A_trunc = np.dot(L, L.T)\n    e_F = np.linalg.norm(A - A_trunc, 'fro')\n\n    # 3) Direction-aware regularization\n    P = np.diag(d.astype(float))\n    A_reg = A_trunc + lambda_reg * P\n\n    # 4) Smallest eigenvalue and condition number of A_reg\n    # A_reg is symmetric by construction, use eigvalsh for efficiency and stability.\n    eigenvalues_reg = np.linalg.eigvalsh(A_reg)\n    \n    min_eig_reg = np.min(eigenvalues_reg)\n    max_eig_reg = np.max(eigenvalues_reg)\n\n    if min_eig_reg = 0:\n        # This case should ideally not happen with lambda > 0,\n        # but as a safeguard against catastrophic cancellation or zero lambda.\n        cond_reg = np.inf\n    else:\n        cond_reg = max_eig_reg / min_eig_reg\n\n    return [int(r_hat), float(e_F), float(min_eig_reg), float(cond_reg)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1\n    A1 = np.array([\n        [5, 1, 0, 0],\n        [1, 4, 1, 0],\n        [0, 1, 3, 1],\n        [0, 0, 1, 2]\n    ], dtype=float)\n    tau1 = 1e-12\n    lambda1 = 1e-6\n    \n    # Case 2\n    A2 = np.diag([1.0, 1e-8, 1e-12])\n    tau2 = 1e-10\n    lambda2 = 1e-6\n    \n    # Case 3\n    v3 = np.array([1, 2, 3], dtype=float).reshape(-1, 1)\n    A3 = np.dot(v3, v3.T)\n    tau3 = 1e-12\n    lambda3 = 1e-6\n    \n    # Case 4\n    eps4 = 1e-8\n    B4 = np.array([\n        [1, 1 - eps4, 0],\n        [0, 1, eps4],\n        [0, 0, eps4]\n    ], dtype=float)\n    A4 = np.dot(B4, B4.T)\n    tau4 = 1e-10\n    lambda4 = 1e-6\n    \n    test_cases = [\n        (A1, tau1, lambda1),\n        (A2, tau2, lambda2),\n        (A3, tau3, lambda3),\n        (A4, tau4, lambda4),\n    ]\n\n    results = []\n    for A, tau, lambda_reg in test_cases:\n        result = truncated_cholesky_regularization(A, tau, lambda_reg)\n        results.append(result)\n\n    # Format the final output string\n    # Convert each inner list to a string representation\n    results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    # Join the inner list strings into the final format\n    final_output = f\"[{','.join(results_str)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}