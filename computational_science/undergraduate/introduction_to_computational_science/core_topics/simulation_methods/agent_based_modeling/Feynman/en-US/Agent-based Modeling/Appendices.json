{
    "hands_on_practices": [
        {
            "introduction": "Understanding agent-based models begins with mastering their core mechanics: how individual agents, following simple rules, interact with each other and their environment over discrete time steps. This first practice exercise  provides a hands-on opportunity to do just that by manually simulating a small-scale ecological scenario. By tracing the behavior of a few hermit crabs searching for new shells, you will gain a concrete understanding of concepts like agent states, sequential updating, and how carefully specified rules lead to deterministic outcomes.",
            "id": "1840928",
            "problem": "An ecologist is developing a simple agent-based model to simulate the behavior of hermit crabs searching for new shells. The model takes place in a one-dimensional environment consisting of 10 tide pools, indexed sequentially from 1 to 10.\n\nThe simulation begins with three hermit crabs (Crab A, Crab B, Crab C) and four empty shells at specific locations. Each crab and shell has an integer 'size' value.\n\n**Initial State (Time t=0):**\n*   **Crabs:**\n    *   Crab A: Size 10, located at tide pool 2.\n    *   Crab B: Size 12, located at tide pool 9.\n    *   Crab C: Size 8, located at tide pool 5.\n*   **Empty Shells:**\n    *   A shell of size 11 at tide pool 3.\n    *   A shell of size 13 at tide pool 8.\n    *   A shell of size 9 at tide pool 6.\n    *   A shell of size 10 at tide pool 7.\n\nThe simulation proceeds in discrete time steps. Within each time step, the crabs act according to the following rules:\n\n1.  **Order of Action:** The crabs are processed sequentially in alphabetical order: Crab A, then Crab B, then Crab C. The state of the environment (shell locations) is updated after each crab's turn.\n2.  **Goal:** A crab with a current shell of size $S$ will only search for a new, empty shell of the ideal size $S+1$.\n3.  **Search Protocol:** A crab at position $P$ first searches for an ideal shell in its current tide pool ($P$). If an ideal shell is not in pool $P$, it then searches the adjacent pools, $P-1$ and $P+1$, if they exist within the bounds of the environment (pools 1 to 10).\n4.  **Action Rule:**\n    *   If an ideal shell is found in the crab's current pool ($P$), the crab switches into the new shell. Its old shell is left empty in pool $P$. The crab's turn then ends.\n    *   If no ideal shell is in pool $P$, but one is found in an adjacent pool, the crab moves to that location and switches shells. If ideal shells are present in both $P-1$ and $P+1$, the crab prioritizes the location with the lower index. After moving and switching, the crab's old shell is left empty in its *original* pool. The crab's turn then ends.\n    *   If no ideal shell is found in the current or adjacent pools, the crab does not move or switch shells, and its turn ends.\n\nBased on these rules, determine the size of the shell occupied by Crab C after the simulation has run for two full time steps.",
            "solution": "We simulate two discrete time steps following the stated rules. Let each crab have size and position denoted by $s_{X}(t)$ and $p_{X}(t)$ for crab $X \\in \\{A,B,C\\}$ at time $t$, and let the set of empty shells at time $t$ be $E_{t}=\\{(P,\\text{size})\\}$.\n\nInitial state at $t=0$:\n- $s_{A}(0)=10$, $p_{A}(0)=2$; $s_{B}(0)=12$, $p_{B}(0)=9$; $s_{C}(0)=8$, $p_{C}(0)=5$.\n- $E_{0}=\\{(3,11),(8,13),(6,9),(7,10)\\}$.\n\nTime step 1 (process A, then B, then C, updating after each action):\n- Crab A: Ideal size is $s_{A}(0)+1=11$. Search pool $p_{A}(0)=2$: no $(2,11)$ in $E_{0}$. Adjacent pools are $1$ and $3$. Pool $3$ has $(3,11)\\in E_{0}$. Action: move to $3$ and switch. Update:\n  - $s_{A}(1)=11$, $p_{A}(1)=3$.\n  - Shell updates: remove $(3,11)$ from $E_{0}$ and add A’s old shell $(2,10)$. After A: $E=\\{(2,10),(8,13),(6,9),(7,10)\\}$.\n- Crab B: Ideal size is $s_{B}(0)+1=13$. Search pool $p_{B}(0)=9$: no $(9,13)$. Adjacent pools $8$ and $10$. Pool $8$ has $(8,13)$. Action: move to $8$ and switch. Update:\n  - $s_{B}(1)=13$, $p_{B}(1)=8$.\n  - Shell updates: remove $(8,13)$ and add B’s old shell $(9,12)$. After B: $E=\\{(2,10),(9,12),(6,9),(7,10)\\}$.\n- Crab C: Ideal size is $s_{C}(0)+1=9$. Search pool $p_{C}(0)=5$: no $(5,9)$. Adjacent pools $4$ and $6$. Pool $6$ has $(6,9)$. Action: move to $6$ and switch. Update:\n  - $s_{C}(1)=9$, $p_{C}(1)=6$.\n  - Shell updates: remove $(6,9)$ and add C’s old shell $(5,8)$.\nAfter time step $1$: $E_{1}=\\{(2,10),(9,12),(7,10),(5,8)\\}$ and $(s_{A}(1),p_{A}(1))=(11,3)$, $(s_{B}(1),p_{B}(1))=(13,8)$, $(s_{C}(1),p_{C}(1))=(9,6)$.\n\nTime step 2 (again A, then B, then C, using $E_{1}$):\n- Crab A: Ideal size $s_{A}(1)+1=12$. Search pool $p_{A}(1)=3$, then adjacent $2$ and $4$. Neither $(3,12)$, $(2,12)$, nor $(4,12)$ is in $E_{1}$. No action:\n  - $s_{A}(2)=11$, $p_{A}(2)=3$, $E$ unchanged.\n- Crab B: Ideal size $s_{B}(1)+1=14$. Search pool $p_{B}(1)=8$, then adjacent $7$ and $9$. Neither $(8,14)$, $(7,14)$, nor $(9,14)$ is in $E_{1}$. No action:\n  - $s_{B}(2)=13$, $p_{B}(2)=8$, $E$ unchanged.\n- Crab C: Ideal size $s_{C}(1)+1=10$. Search pool $p_{C}(1)=6$: no $(6,10)$ in $E_{1}$. Adjacent pools $5$ and $7$. Pool $7$ has $(7,10)$. Action: move to $7$ and switch. Update:\n  - $s_{C}(2)=10$, $p_{C}(2)=7$.\n  - Shell updates: remove $(7,10)$ and add C’s old shell $(6,9)$. Final empty shells set becomes $\\{(2,10),(9,12),(5,8),(6,9)\\}$.\n\nTherefore, after two full time steps, Crab C occupies a shell of size $s_{C}(2)=10$.",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "While many simple models are deterministic, the real power of agent-based modeling often lies in capturing the role of chance. This exercise  introduces probability into a simple spatial model of a clonal organism. Instead of manually tracing exact outcomes, your goal will be to calculate the expected size of the population, learning how to apply principles of probability to predict the average behavior of a system governed by stochastic rules.",
            "id": "1840962",
            "problem": "Consider a simple model for the spatial spread of a clonal organism on a one-dimensional habitat, represented as an infinitely long line of discrete cells, indexed by integers $k \\in \\mathbb{Z}$.\n\nAt time $t=0$, the habitat is empty except for a single founding agent located at cell $k=0$. The population evolves in discrete time steps ($t=1, 2, 3, \\ldots$).\n\nThe rule for population growth is as follows: At each time step, every agent present in the population independently attempts to place a new offspring in *each* of its adjacent, *empty* cells. An agent at cell $k$ has adjacent cells at $k-1$ and $k+1$. Each such reproductive attempt is successful with a fixed probability $p$, where $0 < p < 1$. Agents are immortal and do not move. If a cell is occupied, it remains occupied for all subsequent times.\n\nFor example, at $t=1$, the agent at cell 0 will attempt to place an offspring in the empty cell $-1$ with probability $p$, and will also attempt to place an offspring in the empty cell $1$ with probability $p$. These two attempts are independent.\n\nCalculate the expected total number of occupied cells at time $t=2$. Express your answer as a function of $p$.",
            "solution": "Let $X_{2}$ be the total number of occupied cells by time $t=2$. By linearity of expectation,\n$$\n\\mathbb{E}[X_{2}] = \\sum_{k=-2}^{2} \\mathbb{P}(\\text{cell } k \\text{ is occupied by } t=2).\n$$\nCells outside $\\{-2,-1,0,1,2\\}$ cannot be reached by $t=2$.\n\nWe compute these probabilities:\n- Cell $0$ is occupied with probability $1$.\n- For cells $-1$ and $1$: each can be occupied by $t=2$ if at least one of the two independent attempts from cell $0$ (at $t=1$ and $t=2$) succeeds. Thus\n$$\n\\mathbb{P}(\\text{cell } \\pm 1 \\text{ occupied by } t=2) = 1 - (1-p)^{2} = 2p - p^{2}.\n$$\n- For cells $-2$ and $2$: to be occupied at $t=2$, the adjacent inner cell ($-1$ or $1$) must have been occupied at $t=1$ (which occurs with probability $p$), and then that new agent must successfully reproduce outward at $t=2$ (probability $p$). Hence\n$$\n\\mathbb{P}(\\text{cell } \\pm 2 \\text{ occupied by } t=2) = p \\cdot p = p^{2}.\n$$\n\nSumming,\n$$\n\\mathbb{E}[X_{2}] = 1 + 2(2p - p^{2}) + 2 p^{2} = 1 + 4p.\n$$",
            "answer": "$$\\boxed{1+4p}$$"
        },
        {
            "introduction": "The previous exercises laid the conceptual groundwork; this final practice challenges you to apply it by building and analyzing a full-scale computational model of a complex system. You will implement a stochastic wildfire model  that incorporates environmental heterogeneity and external forces like wind. Your task is not just to build the model, but to use it as a virtual laboratory to perform an experiment: estimating the system's percolation threshold, a critical 'tipping point' that determines whether a fire can spread across the entire landscape.",
            "id": "3096201",
            "problem": "Consider an agent-based model (ABM) of wildfire on a two-dimensional square lattice of size $L \\times L$. Each lattice site is an agent with a discrete state in $\\{ \\text{empty}, \\text{fuel}, \\text{burning}, \\text{burned} \\}$. Fuel heterogeneity is modeled by two independent random fields per run: a fuel-occupancy field and a dryness field. The fuel-occupancy field is a Bernoulli field with parameter $p \\in [0,1]$; a site is fuel with probability $p$ and empty otherwise. The dryness field assigns to every site a scalar $s \\in [0,1]$ sampled independently as $s \\sim \\mathrm{Uniform}(1-h,1)$ where $h \\in [0,1]$ controls heterogeneity. A constant wind field vector is given by $\\vec{w} = (w_x,w_y) \\in \\mathbb{R}^2$. Fire dynamics evolve in discrete time steps. At time $t=0$, all fuel sites on the leftmost column (column index $0$) are ignited (state burning). At each subsequent time step $t \\to t+1$, every burning site attempts to ignite each of its four nearest-neighbor sites in the cardinal directions $\\mathcal{N} = \\{\\text{east},\\text{west},\\text{south},\\text{north}\\}$, after which it becomes burned. A neighbor site that is fuel (not empty, not burned, and not already burning) is ignited with a probability that accounts for wind alignment and local dryness.\n\nDefine the unit direction vectors for the four cardinal directions as $\\vec{d}_\\text{east}=(1,0)$, $\\vec{d}_\\text{west}=(-1,0)$, $\\vec{d}_\\text{south}=(0,1)$, and $\\vec{d}_\\text{north}=(0,-1)$, with coordinates aligned so that the $x$-axis increases to the right and the $y$-axis increases downward. Let $q_0 \\in [0,1]$ be a baseline ignition-probability component and $\\gamma \\ge 0$ be a wind sensitivity parameter. For direction $d \\in \\mathcal{N}$, define the directional ignition-probability component\n$$\nq_d = \\mathrm{clip}\\left(q_0 + \\gamma \\cdot a(\\vec{w},\\vec{d}),\\,0,\\,1\\right),\n$$\nwhere\n$$\na(\\vec{w},\\vec{d}) = \\begin{cases}\n\\frac{\\vec{w} \\cdot \\vec{d}}{\\|\\vec{w}\\|}, & \\|\\vec{w}\\| > 0,\\\\\n0, & \\|\\vec{w}\\| = 0,\n\\end{cases}\n$$\nand $\\mathrm{clip}(x,0,1)$ truncates $x$ to the interval $[0,1]$. If multiple burning neighbors attempt to ignite the same fuel site, assume independence of attempts and combine them via the complement rule. If site $(i,j)$ has dryness $s_{i,j}$ and receives ignition attempts from a subset $\\mathcal{A} \\subseteq \\mathcal{N}$ of directions, its ignition probability in the next time step is\n$$\nP^\\text{ignite}_{i,j} = 1 - \\prod_{d \\in \\mathcal{A}} \\left(1 - s_{i,j} \\, q_d\\right).\n$$\nEdges are reflecting in the sense that sites outside the lattice do not exist and produce no ignition attempts. The fire terminates when no sites are burning. Define that a run achieves crossing if any site in the rightmost column (column index $L-1$) ever becomes burning or burned during the run.\n\nFrom the perspective of percolation, define the empirical crossing probability at a given fuel occupancy $p$ as the fraction of independent runs (with independently resampled fuel and dryness fields) that achieve crossing. The percolation threshold estimate $p^\\ast$ for this ABM is operationally defined, on a discrete scan $p \\in \\{p_{\\min}, p_{\\min}+\\Delta p, \\dots, p_{\\max}\\}$, as the smallest scanned $p$ whose empirical crossing probability is at least $0.5$. If no scanned $p$ meets this criterion, define $p^\\ast = p_{\\max} + \\Delta p$ as a sentinel that indicates the threshold lies above the scanned range. For the same lattice topology, bond percolation on the square lattice has exact bond percolation threshold $p_c^\\text{bond} = 0.5$. For each test case, compare the ABM threshold $p^\\ast$ to $p_c^\\text{bond}$ by reporting the difference $p^\\ast - p_c^\\text{bond}$.\n\nImplement the ABM exactly as specified above and estimate $p^\\ast$ using a discrete scan and repeated runs. Use the following test suite; each test case is a tuple $(L, w_x, w_y, h, q_0, \\gamma, p_{\\min}, p_{\\max}, \\Delta p, N_\\text{runs})$:\n- Test case $1$: $(40, 0.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$.\n- Test case $2$: $(40, 2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$.\n- Test case $3$: $(40, -2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$.\n- Test case $4$: $(30, 1.0, 0.5, 0.4, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output two floats rounded to $3$ decimals: first the estimated ABM threshold $p^\\ast$, then the difference $p^\\ast - p_c^\\text{bond}$. The final output list aggregates all test cases in order, resulting in $8$ numbers:\n$$\n\\left[ p^\\ast_1,\\; p^\\ast_1 - 0.5,\\; p^\\ast_2,\\; p^\\ast_2 - 0.5,\\; p^\\ast_3,\\; p^\\ast_3 - 0.5,\\; p^\\ast_4,\\; p^\\ast_4 - 0.5 \\right].\n$$\nAll quantities are dimensionless; no physical units are required. Angles, if implicitly referenced via dot products and normalization, are handled via unitless alignment factors; no explicit angle units are used.",
            "solution": "The problem requires the implementation of a stochastic agent-based model (ABM) for wildfire spread on a two-dimensional lattice and the subsequent estimation of its percolation threshold, $p^\\ast$. The solution is developed by first constructing a computational model that meticulously follows the specified dynamics, and then deploying this model within a statistical framework to determine $p^\\ast$.\n\n### 1. Model Formulation and State Representation\nThe system is a square lattice of size $L \\times L$. Each site $(i,j)$ is an agent whose state belongs to the set $\\{\\text{empty}, \\text{fuel}, \\text{burning}, \\text{burned}\\}$. For computational implementation, these discrete states are mapped to integer values: empty $\\to 0$, fuel $\\to 1$, burning $\\to 2$, and burned $\\to 3$. The state of the entire lattice is represented by an $L \\times L$ NumPy array.\n\nTwo sources of quenched disorder are specified:\n1.  **Fuel-Occupancy Field**: A Bernoulli field with parameter $p$ determines the initial placement of fuel. This is implemented by generating an $L \\times L$ array of uniform random numbers in $[0,1]$ and designating sites as fuel where the random number is less than $p$.\n2.  **Dryness Field**: A scalar dryness $s_{i,j} \\in [0,1]$ is assigned to each site, sampled independently from a uniform distribution $\\mathrm{Uniform}(1-h,1)$. This is represented by a separate $L \\times L$ floating-point NumPy array.\n\nThese two fields are generated once at the beginning of each simulation run.\n\n### 2. Pre-computation of Directional Ignition Probabilities\nThe model incorporates wind effects by modulating the baseline ignition probability. The wind is a constant vector $\\vec{w} = (w_x, w_y)$. Its influence on ignition in a cardinal direction $d \\in \\{\\text{east}, \\text{west}, \\text{north}, \\text{south}\\}$ depends on the alignment between the wind and that direction. The alignment factor is given by $a(\\vec{w},\\vec{d}) = (\\vec{w} \\cdot \\vec{d}) / \\|\\vec{w}\\|$ for $\\|\\vec{w}\\| > 0$, and $0$ otherwise. The direction vectors are defined as $\\vec{d}_\\text{east}=(1,0)$, $\\vec{d}_\\text{west}=(-1,0)$, $\\vec{d}_\\text{south}=(0,1)$, and $\\vec{d}_\\text{north}=(0,-1)$, with the y-axis pointing downwards.\n\nThe directional ignition-probability component, $q_d$, is then calculated as $q_d = \\mathrm{clip}(q_0 + \\gamma \\cdot a(\\vec{w},\\vec{d}), 0, 1)$, where $q_0$ is a baseline probability component and $\\gamma$ is the wind sensitivity. Since $\\vec{w}$, $q_0$, and $\\gamma$ are constant for all runs within a single test case, the four values $\\{q_{\\text{east}}, q_{\\text{west}}, q_{\\text{north}}, q_{\\text{south}}\\}$ are pre-computed before initiating the simulation runs.\n\n### 3. Simulation Algorithm\nA single simulation run evolves the state of the lattice over discrete time steps according to the specified rules.\n\n**Initialization**:\nA run begins by setting up the lattice as described in Section 1. After generating the fuel and dryness fields, the initial fire is started by changing the state of all fuel sites in the leftmost column (column index $0$) to 'burning' (state $2$).\n\n**Time Evolution**:\nThe simulation proceeds in a loop that continues as long as there are 'burning' sites. The state updates are synchronous, meaning they are calculated based on the state of the lattice at time $t$ to determine the state at $t+1$.\n\n1.  **Identify Igniters**: A boolean mask `is_burning` is created to locate all sites currently in state $2$.\n2.  **Calculate Ignition Probabilities**: The core of the simulation is calculating the ignition probability $P^\\text{ignite}_{i,j}$ for each fuel site. The problem states that for a site $(i,j)$ with dryness $s_{i,j}$ and ignition attempts from a set of neighbors $\\mathcal{A}$, the total probability of ignition is $P^\\text{ignite}_{i,j} = 1 - \\prod_{d \\in \\mathcal{A}} (1 - s_{i,j} q_d)$. This formula correctly combines independent probabilistic events.\n    To implement this efficiently, we first calculate the probability of *not* being ignited. An $L \\times L$ array, `prob_no_ignition`, is initialized to ones. For each cardinal direction, we identify the fuel sites that are neighbors to burning sites in that direction. This is done using vectorized NumPy operations by shifting the `is_burning` mask. For example, to find fuel sites to the east of burning sites, the `is_burning` mask is shifted one position to the left. For each of these targeted fuel sites, their `prob_no_ignition` value is multiplied by the corresponding factor $(1 - s_{i,j} q_d)$. This is repeated for all four directions.\n3.  **Stochastic Ignition**: After accounting for all neighboring fire sources, the final ignition probability for each fuel site is `ignite_prob = 1.0 - prob_no_ignition`. A random number is then drawn for each site from $\\mathrm{Uniform}(0,1)$. A fuel site becomes newly ignited if its drawn random number is less than its calculated `ignite_prob`.\n4.  **State Updates**: A synchronous update is performed. All sites that were 'burning' at the start of the time step transition to 'burned' (state $3$). All 'fuel' sites that were newly ignited transition to 'burning' (state $2$).\n5.  **Termination and Crossing**: A run terminates if either the fire extinguishes (no sites are in the 'burning' state) or if crossing is achieved. Crossing is defined as any site in the rightmost column (index $L-1$) entering either the 'burning' or 'burned' state. A boolean flag tracks whether crossing has occurred. If it occurs, the simulation for that run is stopped immediately, and the run is recorded as a success. If the fire dies out without reaching the rightmost column, the run is a failure.\n\n### 4. Percolation Threshold Estimation\nThe primary objective is to estimate the percolation threshold $p^\\ast$. This is achieved through a systematic scan over a discrete range of fuel occupancy probabilities, $p \\in \\{p_{\\min}, p_{\\min}+\\Delta p, \\dots, p_{\\max}\\}$. For each value of $p$:\n1.  A fixed number of independent simulation runs, $N_\\text{runs}$, is performed.\n2.  The number of runs that result in crossing is counted.\n3.  The empirical crossing probability is calculated as (number of successful runs) / $N_\\text{runs}$.\n4.  This probability is compared to the threshold of $0.5$. The first value of $p$ in the scan for which the empirical crossing probability is at least $0.5$ is defined as the estimated percolation threshold, $p^\\ast$. The scan is then terminated.\n5.  If the scan completes without the crossing probability ever reaching $0.5$, $p^\\ast$ is assigned the sentinel value $p_{\\max} + \\Delta p$.\n\n### 5. Final Output Calculation\nFor each test case, the estimated threshold $p^\\ast$ is determined as described above. The final reported quantities are $p^\\ast$ itself and the difference $p^\\ast - p_c^\\text{bond}$, where the reference bond percolation threshold is given as $p_c^\\text{bond}=0.5$. These two values are calculated for each test case, rounded to three decimal places, and aggregated into a single list for the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, p, h, q_coeffs):\n    \"\"\"\n    Executes a single run of the wildfire ABM.\n\n    Args:\n        L (int): Lattice size.\n        p (float): Fuel occupancy probability.\n        h (float): Dryness heterogeneity parameter.\n        q_coeffs (tuple): Tuple of (q_E, q_W, q_N, q_S) ignition probabilities.\n\n    Returns:\n        bool: True if the fire crosses the lattice, False otherwise.\n    \"\"\"\n    # State mapping: 0=empty, 1=fuel, 2=burning, 3=burned\n    states = np.zeros((L, L), dtype=np.int8)\n    \n    # 1. Initialization\n    is_fuel_mask = np.random.rand(L, L) < p\n    states[is_fuel_mask] = 1\n    \n    dryness = np.random.uniform(1 - h, 1.0, size=(L, L))\n    \n    q_E, q_W, q_N, q_S = q_coeffs\n    \n    # Ignite the leftmost column where there is fuel\n    leftmost_fuel = states[:, 0] == 1\n    states[leftmost_fuel, 0] = 2\n    \n    # Check for immediate crossing (for L=1 or if no fuel on left edge)\n    if not np.any(leftmost_fuel):\n        return False\n    if np.any(states[:, -1] >= 2):\n        return True\n\n    # 2. Time evolution loop\n    while True:\n        is_burning = (states == 2)\n        if not np.any(is_burning):\n            break  # Fire has extinguished\n\n        is_fuel = (states == 1)\n        prob_no_ignition = np.ones((L, L), dtype=np.float64)\n\n        # Vectorized calculation of ignition probabilities from all 4 directions\n        # Igniters from West influence their Eastern neighbors\n        igniters_W = np.zeros_like(is_burning)\n        igniters_W[:, 1:] = is_burning[:, :-1]\n        ignitable_E = igniters_W & is_fuel\n        if q_E > 0:\n            prob_no_ignition[ignitable_E] *= (1.0 - dryness[ignitable_E] * q_E)\n\n        # Igniters from East influence their Western neighbors\n        igniters_E = np.zeros_like(is_burning)\n        igniters_E[:, :-1] = is_burning[:, 1:]\n        ignitable_W = igniters_E & is_fuel\n        if q_W > 0:\n            prob_no_ignition[ignitable_W] *= (1.0 - dryness[ignitable_W] * q_W)\n            \n        # Igniters from North influence their Southern neighbors\n        igniters_N = np.zeros_like(is_burning)\n        igniters_N[1:, :] = is_burning[:-1, :]\n        ignitable_S = igniters_N & is_fuel\n        if q_S > 0:\n            prob_no_ignition[ignitable_S] *= (1.0 - dryness[ignitable_S] * q_S)\n        \n        # Igniters from South influence their Northern neighbors\n        igniters_S = np.zeros_like(is_burning)\n        igniters_S[:-1, :] = is_burning[1:, :]\n        ignitable_N = igniters_S & is_fuel\n        if q_N > 0:\n            prob_no_ignition[ignitable_N] *= (1.0 - dryness[ignitable_N] * q_N)\n\n        ignite_prob = 1.0 - prob_no_ignition\n        \n        # Stochastic ignition event\n        rand_vals = np.random.rand(L, L)\n        newly_ignited = (rand_vals < ignite_prob) & is_fuel\n\n        # 3. Synchronous state update\n        states[is_burning] = 3   # Burning sites become burned\n        states[newly_ignited] = 2 # Newly ignited sites start burning\n        \n        # 4. Check for crossing\n        if np.any(states[:, -1] >= 2):  # burning (2) or burned (3)\n            return True\n\n    return False # Fire extinguished without crossing\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (40, 0.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (40, 2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (40, -2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (30, 1.0, 0.5, 0.4, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n    ]\n\n    results = []\n    p_c_bond = 0.5\n\n    for case in test_cases:\n        L, w_x, w_y, h, q_0, gamma, p_min, p_max, delta_p, N_runs = case\n\n        # Pre-compute directional ignition components\n        w_norm = np.sqrt(w_x**2 + w_y**2)\n        ax, ay = 0.0, 0.0\n        if w_norm > 1e-9:\n            ax = w_x / w_norm\n            ay = w_y / w_norm\n        \n        q_E = np.clip(q_0 + gamma * ax, 0, 1)\n        q_W = np.clip(q_0 + gamma * -ax, 0, 1)\n        q_S = np.clip(q_0 + gamma * ay, 0, 1) # y-axis increases downwards\n        q_N = np.clip(q_0 + gamma * -ay, 0, 1)\n\n        q_coeffs = (q_E, q_W, q_N, q_S)\n\n        p_values = np.arange(p_min, p_max + delta_p / 2, delta_p)\n        p_star = p_max + delta_p # Sentinel value\n\n        for p in p_values:\n            cross_count = 0\n            for _ in range(N_runs):\n                if run_simulation(L, p, h, q_coeffs):\n                    cross_count += 1\n            \n            empirical_prob = cross_count / N_runs\n            \n            if empirical_prob >= 0.5:\n                p_star = p\n                break\n        \n        results.append(p_star)\n        results.append(p_star - p_c_bond)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{val:.3f}' for val in results])}]\")\n\nsolve()\n```"
        }
    ]
}