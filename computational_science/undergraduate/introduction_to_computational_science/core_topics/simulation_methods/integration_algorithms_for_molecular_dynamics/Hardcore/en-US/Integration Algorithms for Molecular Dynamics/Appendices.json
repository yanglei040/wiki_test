{
    "hands_on_practices": [
        {
            "introduction": "Every complex molecular dynamics simulation is fundamentally composed of simple, repetitive integration steps. Before writing code to simulate thousands of atoms for millions of steps, it is crucial to understand the mechanics of a single step. This exercise  provides a focused, analytical walkthrough of the widely used velocity Verlet algorithm, allowing you to master its core update equations for position and velocity in a controlled setting.",
            "id": "204367",
            "problem": "Within the Born-Oppenheimer approximation, the motion of nuclei in a molecule can be modeled using classical mechanics on a potential energy surface (PES), $V$, which is determined by solving the time-independent electronic Schrödinger equation for a fixed nuclear geometry. For a diatomic molecule, this PES, $V(R)$, depends only on the internuclear distance $R$.\n\nConsider a diatomic molecule with reduced mass $\\mu$. Its vibrational motion is governed by a harmonic potential, $V(R) = \\frac{k}{2}(R-R_e)^2$, where $k$ is the force constant and $R_e$ is the equilibrium bond length. This molecule is subjected to an external, time-dependent electric field, such as from a laser, which introduces an additional force $F_{ext}(t) = F_0 \\cos(\\omega t)$. The total force on the system is the sum of the internal (restoring) force from the potential and the external force.\n\nThe classical trajectory of the internuclear distance, $R(t)$, can be simulated using a numerical integration algorithm. One of the most common algorithms for molecular dynamics is the velocity Verlet algorithm. For a one-dimensional system with position $R(t)$, velocity $v(t)$, and acceleration $a(t) = F(R(t), t)/\\mu$, a single integration step of duration $\\Delta t$ is performed as follows:\n\n1.  Calculate the position at the new time step:\n    $$ R(t+\\Delta t) = R(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2 $$\n2.  Calculate the force $F(R(t+\\Delta t), t+\\Delta t)$ and acceleration $a(t+\\Delta t)$ at the new position and new time.\n3.  Calculate the velocity at the new time step:\n    $$ v(t+\\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t+\\Delta t)]\\Delta t $$\n\nSuppose the molecule is initially at rest ($v(0)=0$) at its equilibrium internuclear distance ($R(0)=R_e$).\n\nUsing the velocity Verlet algorithm, calculate the velocity of the system, $v(\\Delta t)$, after a single integration step of duration $\\Delta t$. Express your answer in terms of the given parameters $\\mu, k, R_e, F_0, \\omega$, and $\\Delta t$.",
            "solution": "1. Relevant equations  \n   Velocity Verlet for one step:  \n   $$R(t+\\Delta t)=R(t)+v(t)\\,\\Delta t+\\tfrac12a(t)\\,(\\Delta t)^2,$$  \n   $$v(t+\\Delta t)=v(t)+\\tfrac12\\bigl[a(t)+a(t+\\Delta t)\\bigr]\\,\\Delta t.$$  \n   Internal restoring force: $F_{\\rm int}=-k\\,(R-R_e)$.  \n   External force: $F_{\\rm ext}(t)=F_0\\cos(\\omega t)$.  \n   Total acceleration: $a(t)=F(t)/\\mu$.\n\n2. Initial conditions at $t=0$:  \n   $$R(0)=R_e,\\quad v(0)=0,\\quad F_{\\rm int}(0)=-k(R_e-R_e)=0,\\quad F_{\\rm ext}(0)=F_0.$$  \n   $$F(0)=F_0,\\quad a(0)=\\frac{F_0}{\\mu}.$$\n\n3. Position at $t=\\Delta t$:  \n   $$R(\\Delta t)=R_e+0\\cdot\\Delta t+\\tfrac12\\frac{F_0}{\\mu}(\\Delta t)^2\n     =R_e+\\frac{F_0\\,(\\Delta t)^2}{2\\mu}.$$\n\n4. Force and acceleration at $t=\\Delta t$:  \n   $$F_{\\rm int}(\\Delta t)=-k\\bigl(R(\\Delta t)-R_e\\bigr)\n     =-k\\,\\frac{F_0\\,(\\Delta t)^2}{2\\mu},$$  \n   $$F_{\\rm ext}(\\Delta t)=F_0\\cos(\\omega\\Delta t),$$  \n   $$F(\\Delta t)=-\\frac{kF_0\\,(\\Delta t)^2}{2\\mu}+F_0\\cos(\\omega\\Delta t),$$  \n   $$a(\\Delta t)=\\frac{F(\\Delta t)}{\\mu}\n     =-\\frac{kF_0\\,(\\Delta t)^2}{2\\mu^2}+\\frac{F_0}{\\mu}\\cos(\\omega\\Delta t).$$\n\n5. Velocity at $t=\\Delta t$:  \n   $$v(\\Delta t)=0+\\tfrac12\\Bigl[a(0)+a(\\Delta t)\\Bigr]\\Delta t\n     =\\tfrac12\\Bigl[\\frac{F_0}{\\mu}\n     -\\frac{kF_0\\,(\\Delta t)^2}{2\\mu^2}+\\frac{F_0}{\\mu}\\cos(\\omega\\Delta t)\\Bigr]\\Delta t$$  \n   $$\\quad=\\frac{F_0\\Delta t}{2\\mu}\\bigl(1+\\cos(\\omega\\Delta t)\\bigr)\n     -\\frac{kF_0\\,(\\Delta t)^3}{4\\mu^2}.$$",
            "answer": "$$\\boxed{\\frac{F_0\\Delta t}{2\\mu}\\bigl(1+\\cos(\\omega\\Delta t)\\bigr)-\\frac{kF_0\\,(\\Delta t)^3}{4\\mu^2}}$$"
        },
        {
            "introduction": "The velocity Verlet algorithm is part of a powerful family of integrators known as symplectic methods, which are prized for their excellent long-term energy conservation. In this practice , you will implement and compare velocity Verlet with its close cousin, the leapfrog method, which uses a 'staggered' time grid for velocities. By observing that they produce nearly identical trajectories, you will not only confirm their mathematical equivalence but also gain a practical appreciation for the subtle yet unavoidable effects of floating-point arithmetic in computational science.",
            "id": "3144527",
            "problem": "Consider a one-dimensional chain of $N$ identical point masses connected by linear springs, with fixed (Dirichlet) boundary conditions at both ends. The masses are unit mass and the springs have unit stiffness, so all quantities are nondimensional. Let $x_i(t)$ denote the displacement of mass $i$ from its equilibrium position at time $t$, where $i \\in \\{1,2,\\dots,N\\}$. Assume the endpoints are pinned at zero displacement, so the neighbors of $x_1$ and $x_N$ beyond the chain are fixed at $0$. Starting from Newton's Second Law and the definition of acceleration, derive the governing second-order ordinary differential equations for the chain. Then, from fundamental time-discretization principles (Taylor expansions and centered differences), derive two integrators for these equations: the leapfrog method with staggered velocities and the velocity Verlet method with velocities defined on the same time grid as positions. Ensure that the staggered velocity initialization is consistent with the on-grid initial conditions so that, in exact arithmetic, both schemes produce the same position updates at each integer time step.\n\nYour implementation must:\n- Compute the accelerations $a_i(t)$ from the current positions $x_i(t)$ using nearest-neighbor spring forces and fixed endpoints, all in nondimensional units.\n- Implement the leapfrog method with staggered velocities, with a consistent half-step initialization derived from the on-grid initial state.\n- Implement the velocity Verlet method with on-grid velocities.\n- Advance both methods step-by-step from the same initial conditions, and at each integer time, compute the maximum absolute difference between the two position vectors across all masses. Accumulate the largest such difference over the duration of the simulation. Report this single scalar per test case.\n\nScientific assumptions and derivation base:\n- Use Newton's Second Law $m\\,d^2x_i/dt^2 = F_i$, with $m=1$ and unit spring stiffness.\n- Use well-tested centered-difference discretizations derived from Taylor expansions in time.\n\nAngle units are not applicable. All quantities are nondimensional, so no physical units are required. Results must be pure numbers.\n\nTest suite:\n- Case $1$ (general, normal mode): $N=8$, time step $\\Delta t=0.01$, number of steps $=5000$. Initial positions $x_i(0) = \\sin\\!\\big(\\pi\\frac{i}{N+1}\\big)$ for $i\\in\\{1,\\dots,N\\}$, and initial velocities $v_i(0)=0$ for all $i$.\n- Case $2$ (boundary case, rest state): $N=5$, time step $\\Delta t=0.10$, number of steps $=100$. Initial positions $x_i(0)=0$ and initial velocities $v_i(0)=0$ for all $i$.\n- Case $3$ (near stability limit, mixed initial state): $N=3$, time step $\\Delta t=0.90$, number of steps $=1000$. Initial positions $[x_1(0),x_2(0),x_3(0)] = [0.10,-0.05,0.07]$ and initial velocities $[v_1(0),v_2(0),v_3(0)] = [0.05,0.00,-0.02]$.\n- Case $4$ (long-time accumulation): $N=6$, time step $\\Delta t=0.005$, number of steps $=40000$. Initial positions $x_i(0) = \\sin\\!\\big(\\pi\\frac{i}{N+1}\\big)$ for $i\\in\\{1,\\dots,N\\}$, and initial velocities $v_i(0)=0$ for all $i$.\n\nAlgorithmic requirements:\n- For the leapfrog method, use staggered velocities $v_{i}(t+\\Delta t/2)$ and positions $x_{i}(t)$ on integer times. Initialize the half-step velocities in a manner consistent with the on-grid initial conditions and acceleration at $t=0$.\n- For the velocity Verlet method, use positions $x_i(t)$ and velocities $v_i(t)$ both on integer times, and update them using the acceleration computed from positions.\n\nYour program must produce, for each case, the single scalar equal to the maximum absolute difference between the leapfrog and velocity Verlet position trajectories over all times and masses in that case. The final output format must be a single line containing a comma-separated list of these scalars enclosed in square brackets, for example $[r_1,r_2,r_3,r_4]$, where each $r_k$ is a floating-point number for case $k$ in the order listed above.",
            "solution": "The problem is well-posed and scientifically sound, describing a canonical model from mechanics and computational physics—a one-dimensional chain of harmonic oscillators. We will first derive the equations of motion, then derive the two specified numerical integration schemes (leapfrog and velocity Verlet), establish their mathematical equivalence for position updates, and finally describe the implementation that computes the numerical difference arising from floating-point arithmetic.\n\n### 1. Derivation of the Equations of Motion\n\nConsider a chain of $N$ point masses, each of unit mass, $m_i=1$. The masses are connected by linear springs, each of unit stiffness, $k=1$. Let $x_i(t)$ be the displacement of the $i$-th mass from its equilibrium position. The masses are indexed $i \\in \\{1, 2, \\dots, N\\}$. The chain has fixed (Dirichlet) boundary conditions, meaning the displacements at the ends are held at zero. This can be modeled by assuming fictitious masses $i=0$ and $i=N+1$ with fixed positions $x_0(t) = 0$ and $x_{N+1}(t) = 0$ for all time $t$.\n\nThe force exerted on mass $i$ by its neighbors is governed by Hooke's Law. The net force on mass $i$ is the sum of forces from the spring connecting it to mass $i-1$ and the spring connecting it to mass $i+1$.\nThe force from the spring on the right (between $i$ and $i+1$) is $F_{i \\leftarrow i+1} = k(x_{i+1} - x_i)$.\nThe force from the spring on the left (between $i$ and $i-1$) is $F_{i \\leftarrow i-1} = k(x_{i-1} - x_i)$.\n\nThe total force on mass $i$ is:\n$$ F_i = F_{i \\leftarrow i+1} + F_{i \\leftarrow i-1} = k(x_{i+1} - x_i) + k(x_{i-1} - x_i) = k(x_{i+1} - 2x_i + x_{i-1}) $$\n\nAccording to Newton's Second Law, $F_i = m_i \\ddot{x}_i$, where $\\ddot{x}_i = d^2x_i/dt^2$ is the acceleration. With unit mass ($m_i=1$) and unit spring stiffness ($k=1$), the equation of motion for mass $i$ becomes:\n$$ \\ddot{x}_i(t) = x_{i+1}(t) - 2x_i(t) + x_{i-1}(t) $$\nThis set of $N$ coupled second-order ordinary differential equations (ODEs), along with the boundary conditions $x_0(t)=0$ and $x_{N+1}(t)=0$, governs the dynamics of the system. The acceleration of each mass, $a_i = \\ddot{x}_i$, is a function of the positions of itself and its nearest neighbors.\n\n### 2. Derivation of Numerical Integrators\n\nWe discretize time with a step size $\\Delta t$, such that $t_n = n \\Delta t$. We denote the position, velocity, and acceleration of mass $i$ at time $t_n$ as $x_i^n$, $v_i^n$, and $a_i^n$, respectively. The core of the derivation relies on Taylor series expansions of the position $x(t)$ around time $t_n$:\n$$ x(t_n + \\Delta t) = x(t_n) + v(t_n)\\Delta t + \\frac{1}{2} a(t_n)\\Delta t^2 + O(\\Delta t^3) $$\n$$ v(t_n + \\Delta t) = v(t_n) + a(t_n)\\Delta t + O(\\Delta t^2) $$\n\n#### 2.1. Leapfrog Method with Staggered Velocities\n\nThe leapfrog method staggers the time grid, evaluating positions at integer time steps $t_n$ and velocities at half-integer time steps $t_{n \\pm 1/2} = t_n \\pm \\Delta t/2$. The update rules are based on centered-difference approximations:\nThe velocity update (a \"kick\") is:\n$$ v^{n+1/2} = v^{n-1/2} + a^n \\Delta t $$\nThe position update (a \"drift\") is:\n$$ x^{n+1} = x^n + v^{n+1/2} \\Delta t $$\nHere, $a^n$ is the acceleration computed from positions $x^n$.\n\nTo initialize this scheme, we are given $x^0$ and $v^0$ (on-grid). We need the first half-step velocity $v^{1/2}$ (or the preceding $v^{-1/2}$). A consistent initialization can be derived by approximating the velocity at the half-step:\n$$ v^{1/2} = v(t_0+\\Delta t/2) \\approx v(t_0) + a(t_0) \\frac{\\Delta t}{2} $$\nThus, the initial kick to get the velocity on the staggered grid is:\n$$ v^{1/2} = v^0 + \\frac{1}{2} a^0 \\Delta t $$\nwhere $a^0$ is computed from the initial positions $x^0$. The time evolution proceeds by repeatedly applying the kick and drift steps.\n\n#### 2.2. Velocity Verlet Method\n\nThe velocity Verlet method is a widely used algorithm that keeps positions $x^n$ and velocities $v^n$ on the same integer time grid. It is derived to be time-reversible and symplectic, sharing many favorable properties with leapfrog.\n\nThe update proceeds in two stages:\n1. Update positions to the next full time step:\n$$ x^{n+1} = x^n + v^n \\Delta t + \\frac{1}{2} a^n \\Delta t^2 $$\nThis is a Taylor expansion to second order.\n2. Update velocities using an average of the old and new accelerations:\n$$ v^{n+1} = v^n + \\frac{1}{2} (a^n + a^{n+1}) \\Delta t $$\nTo implement this, one first computes $x^{n+1}$, then uses this new position to compute the new acceleration $a^{n+1} = a(x^{n+1})$, and finally computes the new velocity $v^{n+1}$.\n\n#### 2.3. Equivalence of Position Updates\n\nThe problem requires a demonstration of the equivalence of the position updates in exact arithmetic. Let us assume at step $n$ that the states of the two methods are related as follows: $x_{\\text{LF}}^n = x_{\\text{VV}}^n = x^n$ and the leapfrog half-step velocity is related to the Verlet on-grid velocity by $v_{\\text{LF}}^{n-1/2} = v_{\\text{VV}}^n - \\frac{1}{2} a^n \\Delta t$.\n\nThe velocity Verlet position update is:\n$$ x_{\\text{VV}}^{n+1} = x^n + v_{\\text{VV}}^n \\Delta t + \\frac{1}{2} a^n \\Delta t^2 $$\n\nFor the leapfrog method, we first update the velocity from $v_{\\text{LF}}^{n-1/2}$ to $v_{\\text{LF}}^{n+1/2}$:\n$$ v_{\\text{LF}}^{n+1/2} = v_{\\text{LF}}^{n-1/2} + a^n \\Delta t = \\left(v_{\\text{VV}}^n - \\frac{1}{2} a^n \\Delta t\\right) + a^n \\Delta t = v_{\\text{VV}}^n + \\frac{1}{2} a^n \\Delta t $$\nNext, we update the leapfrog position:\n$$ x_{\\text{LF}}^{n+1} = x_{\\text{LF}}^n + v_{\\text{LF}}^{n+1/2} \\Delta t = x^n + \\left(v_{\\text{VV}}^n + \\frac{1}{2} a^n \\Delta t\\right) \\Delta t = x^n + v_{\\text{VV}}^n \\Delta t + \\frac{1}{2} a^n \\Delta t^2 $$\nComparing the expressions for $x_{\\text{VV}}^{n+1}$ and $x_{\\text{LF}}^{n+1}$, we see they are identical.\n\nThe initial condition for the equivalence is $x_{\\text{LF}}^0 = x_{\\text{VV}}^0 = x^0$. The consistent initialization for leapfrog gives $v_{\\text{LF}}^{1/2} = v^0 + \\frac{1}{2} a^0 \\Delta t$, while the first Verlet velocity after one step would be related to its half-step counterpart by $v_{\\text{VV}}^1 = v_{\\text{LF}}^{1/2} + \\frac{1}{2} a^1 \\Delta t$. Effectively, the initialization $v^{1/2} = v^0 + \\frac{1}{2}a^0\\Delta t$ ensures that the inductive step holds from the very beginning.\n\nSince the position update formulas are mathematically identical, any difference observed between the trajectories computed by the two methods in a floating-point implementation is due to the accumulation of round-off errors. Specifically, the order of operations in floating-point arithmetic can lead to small discrepancies that may grow over time. The problem asks to quantify this maximum discrepancy.\n\n### 3. Algorithmic Implementation\n\nFor each test case, we initialize two separate simulations, one for leapfrog and one for velocity Verlet, with identical initial conditions $(x^0, v^0)$.\n- The acceleration function `compute_acceleration(x)` is implemented to calculate $a_i = x_{i-1} - 2x_i + x_{i+1}$ for all $i$, respecting the boundary conditions $x_0=0$ and $x_{N+1}=0$.\n- In a loop for the specified number of time steps:\n    1. The state of the leapfrog simulation is advanced one step using its update rules and the consistent half-step velocity.\n    2. The state of the velocity Verlet simulation is advanced one step using its update rules.\n    3. After both positions $x_{\\text{LF}}^{n+1}$ and $x_{\\text{VV}}^{n+1}$ are computed, the maximum absolute difference across all masses is calculated: $d_n = \\max_i |x_{i, \\text{LF}}^{n+1} - x_{i, \\text{VV}}^{n+1}|$.\n    4. A running maximum, $\\max_n d_n$, is maintained throughout the simulation.\n- The final value of this running maximum is the result for the test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing leapfrog and velocity Verlet integrators\n    for a 1D chain of masses.\n    \"\"\"\n    test_cases = [\n        # Case 1: General, normal mode\n        {\n            'N': 8, 'dt': 0.01, 'steps': 5000,\n            'x0_func': lambda N: np.sin(np.pi * np.arange(1, N + 1) / (N + 1)),\n            'v0_func': lambda N: np.zeros(N)\n        },\n        # Case 2: Boundary case, rest state\n        {\n            'N': 5, 'dt': 0.10, 'steps': 100,\n            'x0_func': lambda N: np.zeros(N),\n            'v0_func': lambda N: np.zeros(N)\n        },\n        # Case 3: Near stability limit, mixed initial state\n        {\n            'N': 3, 'dt': 0.90, 'steps': 1000,\n            'x0_func': lambda N: np.array([0.10, -0.05, 0.07]),\n            'v0_func': lambda N: np.array([0.05, 0.00, -0.02])\n        },\n        # Case 4: Long-time accumulation\n        {\n            'N': 6, 'dt': 0.005, 'steps': 40000,\n            'x0_func': lambda N: np.sin(np.pi * np.arange(1, N + 1) / (N + 1)),\n            'v0_func': lambda N: np.zeros(N)\n        }\n    ]\n\n    results = []\n\n    def compute_acceleration(x: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes acceleration for the 1D mass-spring chain with fixed ends.\n        a_i = x_{i-1} - 2*x_i + x_{i+1}\n        \"\"\"\n        N = len(x)\n        # Pad with fixed zero-displacement ends\n        x_padded = np.zeros(N + 2)\n        x_padded[1:N+1] = x\n        \n        # Acceleration from nearest-neighbor forces\n        a = x_padded[:-2] + x_padded[2:] - 2 * x_padded[1:-1]\n        return a\n\n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        steps = case['steps']\n        x0 = case['x0_func'](N)\n        v0 = case['v0_func'](N)\n\n        max_abs_diff = 0.0\n\n        # --- Leapfrog Simulation Initialization ---\n        x_lf = x0.copy()\n        v_lf = v0.copy()\n        a_lf_current = compute_acceleration(x_lf)\n        # Initial half-step velocity for consistency with on-grid v0\n        v_lf_half_step = v_lf + 0.5 * a_lf_current * dt\n\n        # --- Velocity Verlet Simulation Initialization ---\n        x_vv = x0.copy()\n        v_vv = v0.copy()\n        a_vv_current = compute_acceleration(x_vv)\n        \n        for _ in range(steps):\n            # --- Leapfrog Step ---\n            # Drift positions using half-step velocity\n            x_lf += v_lf_half_step * dt\n            # Compute new acceleration\n            a_lf_new = compute_acceleration(x_lf)\n            # Kick velocity to the next half-step\n            v_lf_half_step += a_lf_new * dt\n\n            # --- Velocity Verlet Step ---\n            # Update positions\n            x_vv += v_vv * dt + 0.5 * a_vv_current * dt**2\n            # Compute new acceleration\n            a_vv_new = compute_acceleration(x_vv)\n            # Update velocities using average acceleration\n            v_vv += 0.5 * (a_vv_current + a_vv_new) * dt\n            # Store new acceleration for the next step\n            a_vv_current = a_vv_new\n\n            # --- Comparison ---\n            # Compute the max absolute difference for the current step\n            current_diff = np.max(np.abs(x_lf - x_vv))\n            if current_diff  max_abs_diff:\n                max_abs_diff = current_diff\n\n        results.append(max_abs_diff)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A numerical integrator is only useful if it produces a stable trajectory; otherwise, the simulation yields nonsensical results as energy accumulates and particles are flung to infinity. This hands-on problem  challenges you to push the integrator to its breaking point, exploring the critical relationship between the time step $\\Delta t$ and the physical properties of the system, such as bond stiffness and atomic mass. By diagnosing the onset of instability in a system with a realistic Morse potential, you will develop an essential skill for any computational scientist: choosing a time step that balances computational efficiency with physical accuracy.",
            "id": "3144487",
            "problem": "Consider a one-dimensional two-atom dimer interacting via a Morse potential in reduced, dimensionless units. The Morse potential is defined by the function $$U(r) = D_e \\left(1 - e^{-a(r - r_e)}\\right)^2,$$ where $r$ is the scalar separation between the two atoms, $D_e$ is the well depth, $a$ controls the stiffness (curvature) near the minimum, and $r_e$ is the equilibrium bond length. The atoms have masses $m_1$ and $m_2$, and their positions along the line are $x_1$ and $x_2$. The force is $-\\nabla U$, and the equation of motion for each atom follows Newton's second law, $$m_i \\frac{d^2 x_i}{dt^2} = F_i,\\quad i \\in \\{1,2\\}.$$ Molecular Dynamics (MD) refers to integrating these equations of motion in time. Use reduced units throughout, and do not attach any physical units; all quantities are dimensionless.\n\nStarting from the fundamental laws and definitions (Newton's second law, the definition of velocity as $v = dx/dt$, and the definition of acceleration as $a = dv/dt$), derive a second-order, time-reversible, symplectic integration scheme consistent with these laws, and implement it to advance the atomic positions and velocities. Initialize the dimer at positions $x_1(0) = -r_0/2$ and $x_2(0) = r_0/2$ with zero initial velocities $v_1(0) = 0$ and $v_2(0) = 0$, where $r_0 = r_e + \\delta r$ and $\\delta r$ is a small positive displacement from equilibrium. At each time step, compute the total energy $$E(t) = \\frac{1}{2} m_1 v_1(t)^2 + \\frac{1}{2} m_2 v_2(t)^2 + U\\left(|x_2(t) - x_1(t)|\\right).$$\n\nDefine a simulation to be numerically stable if, over the entire trajectory, all of the following criteria hold:\n- The separation magnitude remains bounded within $$0.2\\, r_e \\le |x_2(t) - x_1(t)| \\le 2.0\\, r_e.$$\n- No numerical overflow or undefined values occur (no $\\mathrm{NaN}$ or $\\infty$).\n- The fractional energy drift, defined as $$\\Delta_E = \\frac{\\max_t E(t) - \\min_t E(t)}{\\overline{E}},$$ where $\\overline{E}$ is the time average of $E(t)$ over the trajectory, satisfies $$\\Delta_E \\le 0.2.$$\n\nYour program must implement the above and evaluate the stability for each test case below. To explore failure modes of the integrator at large time step $dt$, and how mass-scaling or smaller $dt$ alleviates instabilities, use the following fixed parameters for the Morse potential and initial displacement:\n- $D_e = 10$\n- $a = 8$\n- $r_e = 1$\n- $\\delta r = 0.05$\nSet the base mass to $m = 1$ and define the actual atomic masses by a mass scaling factor $s$ via $m_1 = s \\cdot m$ and $m_2 = s \\cdot m$.\n\nTest Suite (each test case is a tuple $(dt, s, N)$ where $dt$ is the time step, $s$ is the mass scale factor, and $N$ is the number of integration steps):\n1. $(0.01, 1, 2000)$: small time step, base mass.\n2. $(0.15, 1, 1000)$: large time step, base mass.\n3. $(0.15, 100, 1000)$: large time step, heavy mass scaling.\n4. $(0.04, 1, 2000)$: near the stability boundary, base mass.\n5. $(0.50, 100, 500)$: extremely large time step, heavy mass scaling.\n\nFor each test case, run the simulation for $N$ steps and return a boolean indicating stability according to the criteria above.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is a boolean corresponding to the test cases in the order given.",
            "solution": "The problem requires the derivation and implementation of a numerical integration scheme to simulate the dynamics of a one-dimensional two-atom system interacting via a Morse potential. This is a classic problem in computational science, specifically in the field of molecular dynamics (MD). The objectives are to implement a stable and accurate integrator, run simulations for a set of given parameters, and evaluate the numerical stability of each simulation based on prescribed criteria.\n\nFirst, we validate the problem statement.\n\n### Step 1: Extract Givens\n-   **Potential Energy Function:** $U(r) = D_e \\left(1 - e^{-a(r - r_e)}\\right)^2$, with $r = |x_2 - x_1|$.\n-   **Equations of Motion:** $m_i \\frac{d^2 x_i}{dt^2} = F_i$ for atoms $i \\in \\{1,2\\}$.\n-   **Force Definition:** The force is the negative gradient of the potential, $F = -\\nabla U$.\n-   **Initial Conditions:** $x_1(0) = -r_0/2$, $x_2(0) = r_0/2$, with $r_0 = r_e + \\delta r$. Initial velocities are $v_1(0) = 0$ and $v_2(0) = 0$.\n-   **Total Energy:** $E(t) = \\frac{1}{2} m_1 v_1(t)^2 + \\frac{1}{2} m_2 v_2(t)^2 + U\\left(|x_2(t) - x_1(t)|\\right)$.\n-   **Fixed Parameters:** $D_e = 10$, $a = 8$, $r_e = 1$, $\\delta r = 0.05$.\n-   **Mass Scaling:** $m_1 = m_2 = s$, where $s$ is a given mass scale factor.\n-   **Stability Criteria:**\n    1.  Bounded separation: $0.2 \\cdot r_e \\le |x_2(t) - x_1(t)| \\le 2.0 \\cdot r_e$.\n    2.  No numerical overflow (e.g., $\\mathrm{NaN}$ or $\\infty$).\n    3.  Fractional energy drift $\\Delta_E = \\frac{\\max_t E(t) - \\min_t E(t)}{\\overline{E}} \\le 0.2$.\n-   **Test Suite:** A list of $5$ tuples $(dt, s, N)$, where $dt$ is the time step, $s$ is the mass scale factor, and $N$ is the number of steps.\n    1.  $(0.01, 1, 2000)$\n    2.  $(0.15, 1, 1000)$\n    3.  $(0.15, 100, 1000)$\n    4.  $(0.04, 1, 2000)$\n    5.  $(0.50, 100, 500)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, using the well-established Morse potential and Newton's laws of motion. It is a standard exercise in molecular dynamics simulation. The problem is well-posed, providing all necessary physical parameters, initial conditions, and numerical parameters for each test case. The stability criteria are defined with objective, quantitative metrics. There are no contradictions, ambiguities, or scientifically unsound premises. The problem is a substantive task requiring both theoretical derivation and computational implementation.\n\n### Step 3: Verdict and Action\nThe problem is valid. We proceed with the solution.\n\n### Derivation and Implementation of the Integration Algorithm\n\nThe problem asks for a second-order, time-reversible, symplectic integration scheme. The Velocity Verlet algorithm satisfies these properties and is a standard choice for MD simulations. We derive it from the Taylor series expansion of the position $x(t)$.\n\nFor a particle of mass $m$, its position $x(t)$ evolves according to Newton's second law, $\\ddot{x}(t) = a(t) = F(x(t))/m$. The Taylor series expansion for the position at time $t+dt$ is:\n$$x(t+dt) = x(t) + \\dot{x}(t)dt + \\frac{1}{2}\\ddot{x}(t)dt^2 + O(dt^3)$$\nRecognizing that $\\dot{x}(t) = v(t)$ and $\\ddot{x}(t) = a(t)$, we can write a position update rule:\n$$x(t+dt) = x(t) + v(t)dt + \\frac{1}{2}a(t)dt^2$$\nThis update is accurate to second order in $dt$. To maintain this accuracy for the overall algorithm, the velocity update must also be second-order. A simple forward Euler update for velocity, $v(t+dt) = v(t) + a(t)dt$, is only first-order and would degrade the overall accuracy. Instead, we can use an average of the accelerations at the beginning and end of the time step:\n$$v(t+dt) = v(t) + \\frac{a(t) + a(t+dt)}{2}dt$$\nThis set of equations defines the Velocity Verlet algorithm. However, its direct implementation is implicit since $a(t+dt)$ depends on $x(t+dt)$, which has not yet been fully determined. The \"leapfrog\" variant of Velocity Verlet rearranges the calculation into an explicit, computationally efficient sequence:\n\n1.  Calculate the velocity at a half-time step, $t+dt/2$:\n    $$v(t + dt/2) = v(t) + \\frac{1}{2}a(t)dt$$\n2.  Update the position for the full time step $dt$ using this half-step velocity:\n    $$x(t+dt) = x(t) + v(t+dt/2)dt$$\n3.  Compute the new force $F(x(t+dt))$ and acceleration $a(t+dt)$ at the new position.\n4.  Complete the velocity update for the second half of the time step:\n    $$v(t+dt) = v(t+dt/2) + \\frac{1}{2}a(t+dt)dt$$\n\nThis scheme is algebraically equivalent to the original formulation, is explicit, and has excellent properties for MD: it is second-order accurate, time-reversible, and symplectic, which leads to good long-term energy conservation.\n\n### Application to the Two-Atom System\n\nWe apply this algorithm to each of the two atoms, indexed by $i \\in \\{1,2\\}$. The force on each atom arises from the Morse potential, which depends on the interatomic separation $r = |x_2 - x_1|$. The force on atom $i$ is $F_i = -\\frac{\\partial U}{\\partial x_i}$. Using the chain rule, with $r = |x_2 - x_1|$:\n$$F_1 = -\\frac{dU}{dr}\\frac{\\partial r}{\\partial x_1} = -\\frac{dU}{dr}(-\\text{sgn}(x_2 - x_1)) = \\text{sgn}(x_2 - x_1)\\frac{dU}{dr}$$\n$$F_2 = -\\frac{dU}{dr}\\frac{\\partial r}{\\partial x_2} = -\\frac{dU}{dr}(\\text{sgn}(x_2 - x_1)) = -\\text{sgn}(x_2 - x_1)\\frac{dU}{dr}$$\nNote that Newton's third law, $F_1 = -F_2$, is satisfied. The derivative of the Morse potential is:\n$$\\frac{dU}{dr} = 2aD_e \\left(1 - e^{-a(r - r_e)}\\right) e^{-a(r - r_e)}$$\nThe accelerations are then $a_1 = F_1/m_1$ and $a_2 = F_2/m_2$. In this problem, $m_1 = m_2 = s$.\n\nThe simulation proceeds as follows:\n1.  Initialize positions $x_1 = -r_0/2$, $x_2 = r_0/2$ and velocities $v_1 = 0$, $v_2 = 0$.\n2.  Calculate the initial forces $F_1, F_2$ and accelerations $a_1, a_2$.\n3.  Store the initial interatomic distance $r(0) = |x_2 - x_1|$ and total energy $E(0)$.\n4.  Loop for $N$ time steps:\n    a. For each atom $i$, update velocity to the half-step: $v_i(t+dt/2) = v_i(t) + \\frac{1}{2}a_i(t)dt$.\n    b. For each atom $i$, update position to the full-step: $x_i(t+dt) = x_i(t) + v_i(t+dt/2)dt$.\n    c. Calculate the new separation $r(t+dt)$ and the new forces $F_i(t+dt)$ and accelerations $a_i(t+dt)$. During this step, check for numerical overflow which would immediately invalidate the simulation.\n    d. For each atom $i$, complete the velocity update: $v_i(t+dt) = v_i(t+dt/2) + \\frac{1}{2}a_i(t+dt)dt$.\n    e. Store the new separation $r(t+dt)$ and total energy $E(t+dt)$.\n5. After $N$ steps, analyze the stored trajectory data ($r(t)$ and $E(t)$) against the three stability criteria to determine the final boolean outcome.\n\nThis procedure is implemented for each test case provided in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(dt, s, N):\n    \"\"\"\n    Runs a molecular dynamics simulation for a two-atom dimer.\n\n    Args:\n        dt (float): The time step for integration.\n        s (float): The mass scale factor for the atoms.\n        N (int): The number of integration steps.\n\n    Returns:\n        bool: True if the simulation is stable, False otherwise.\n    \"\"\"\n    # Fixed parameters for the Morse potential and initial displacement\n    De = 10.0\n    a = 8.0\n    re = 1.0\n    delta_r = 0.05\n    \n    # Initial conditions\n    r0 = re + delta_r\n    x1, x2 = -r0 / 2.0, r0 / 2.0\n    v1, v2 = 0.0, 0.0\n    m1, m2 = float(s), float(s)\n\n    # History storage\n    r_hist = np.zeros(N + 1)\n    E_hist = np.zeros(N + 1)\n\n    # --- Utility functions ---\n    def calculate_forces_and_separation(x1_pos, x2_pos):\n        r_vec = x2_pos - x1_pos\n        r_mag = np.abs(r_vec)\n        \n        if r_mag == 0:\n            return np.inf, -np.inf, r_mag\n        \n        # This term can overflow if r_mag gets too small.\n        # -a * (r_mag - re) becomes large and positive.\n        exp_arg = -a * (r_mag - re)\n        if exp_arg  np.log(np.finfo(float).max): # Avoid overflow in exp\n             return np.inf, -np.inf, r_mag\n\n        exp_term = np.exp(exp_arg)\n        \n        # dU/dr\n        F_grad = 2 * a * De * (1 - exp_term) * exp_term\n\n        # Forces on atoms 1 and 2\n        F1 = np.sign(r_vec) * F_grad\n        F2 = -F1\n        \n        return F1, F2, r_mag\n\n    def potential_energy(r_mag):\n        return De * (1 - np.exp(-a * (r_mag - re)))**2\n\n    def kinetic_energy(vel1, vel2, mass1, mass2):\n        return 0.5 * mass1 * vel1**2 + 0.5 * mass2 * vel2**2\n\n    # --- Simulation setup (t=0) ---\n    F1_curr, F2_curr, r_mag_curr = calculate_forces_and_separation(x1, x2)\n    acc1_curr, acc2_curr = F1_curr / m1, F2_curr / m2\n\n    r_hist[0] = r_mag_curr\n    E_hist[0] = kinetic_energy(v1, v2, m1, m2) + potential_energy(r_mag_curr)\n\n    # --- Main integration loop ---\n    for i in range(N):\n        # Velocity Verlet: half-step velocity update\n        v1_half = v1 + 0.5 * acc1_curr * dt\n        v2_half = v2 + 0.5 * acc2_curr * dt\n\n        # Velocity Verlet: full-step position update\n        x1 = x1 + v1_half * dt\n        x2 = x2 + v2_half * dt\n\n        # Calculate new forces and accelerations\n        F1_new, F2_new, r_mag_new = calculate_forces_and_separation(x1, x2)\n        \n        # Stability Check 2: Numerical overflow\n        if np.isinf(F1_new) or np.isnan(F1_new):\n            return False\n            \n        acc1_new = F1_new / m1\n        acc2_new = F2_new / m2\n\n        # Velocity Verlet: second half-step velocity update\n        v1 = v1_half + 0.5 * acc1_new * dt\n        v2 = v2_half + 0.5 * acc2_new * dt\n        \n        # Update accelerations for the next iteration\n        acc1_curr, acc2_curr = acc1_new, acc2_new\n\n        # Store diagnostics for analysis\n        r_hist[i+1] = r_mag_new\n        E_hist[i+1] = kinetic_energy(v1, v2, m1, m2) + potential_energy(r_mag_new)\n        \n        if np.isinf(E_hist[i+1]) or np.isnan(E_hist[i+1]):\n            return False\n\n    # --- Post-simulation stability analysis ---\n\n    # Stability Check 1: Separation magnitude bounds\n    min_r = np.min(r_hist)\n    max_r = np.max(r_hist)\n    if not (0.2 * re = min_r and max_r = 2.0 * re):\n        return False\n        \n    # Stability Check 3: Fractional energy drift\n    avg_E = np.mean(E_hist)\n    if avg_E == 0: # Should not occur in this problem\n        if np.max(E_hist) - np.min(E_hist)  1e-9: # Tolerate zero drift if energy is always zero\n            return False\n    else:\n        delta_E = (np.max(E_hist) - np.min(E_hist)) / avg_E\n        if delta_E  0.2:\n            return False\n            \n    # If all checks pass, the simulation is stable\n    return True\n\ndef solve():\n    test_cases = [\n        (0.01, 1, 2000),      # small time step, base mass.\n        (0.15, 1, 1000),      # large time step, base mass.\n        (0.15, 100, 1000),    # large time step, heavy mass scaling.\n        (0.04, 1, 2000),      # near the stability boundary, base mass.\n        (0.50, 100, 500),     # extremely large time step, heavy mass scaling.\n    ]\n\n    results = []\n    for case in test_cases:\n        dt, s, N = case\n        is_stable = run_simulation(dt, s, N)\n        results.append(is_stable)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}