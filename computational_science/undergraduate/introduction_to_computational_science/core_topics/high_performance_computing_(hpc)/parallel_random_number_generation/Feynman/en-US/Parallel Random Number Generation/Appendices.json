{
    "hands_on_practices": [
        {
            "introduction": "Before building robust parallel systems, it is crucial to understand what can go wrong. This first practice serves as a diagnostic tool, guiding you through common but critical errors in multithreaded random number generation, such as using identical seeds or sharing a single generator state without care. By implementing these faulty patterns and observing the resulting deterministic correlations, you will gain a concrete understanding of why proper stream management is not just a theoretical concern but a practical necessity for valid simulations .",
            "id": "3178991",
            "problem": "You are asked to write a complete, runnable program that demonstrates, quantitatively and deterministically, how accidental sharing of pseudo-random number generator state in multithreaded code can create dependent streams, and how to isolate streams per thread to prevent this. The context is pseudo-random number generation in introduction to computational science, and the task must be solved using basic principles about deterministic state machines and empirical statistical comparison. A pseudo-random number generator is a deterministic finite-state machine with a state update function and an output function. If two threads consume from the same state machine, their outputs belong to one underlying stream and are not independent. If two threads each create their own state machine from the same seed, they will produce identical streams. Proper isolation requires deriving per-thread initial states from a master seed without overlap.\n\nFundamental principles to use:\n- A pseudo-random number generator (PRNG) is a deterministic finite-state machine: there exists a state update function $F$ and an output function $G$ such that, given an initial state $s_0$, the state evolves by $s_{t+1} = F(s_t)$ and produces outputs $x_t = G(s_t)$. Determinism implies that two consumers of the same state machine produce parts of one unique sequence $\\{x_t\\}$, hence their outputs are dependent through the shared state. Independence of streams requires distinct, non-overlapping initial states.\n- Empirical comparison of independence can be performed with the Pearson correlation coefficient $r$ between two sequences of real numbers, computed from the standard definition on finite samples. Independence of two independent, identically distributed Uniform(0,1) sequences implies that $r$ concentrates near $0$ for sufficiently large sample size $n$, while perfect identity of sequences yields $r = 1$.\n- Deterministic reproducibility in such experiments is obtained by fixing the seed and carefully controlling the schedule by which the shared state is consumed.\n\nYour program must implement three multithreaded experiments that each create two streams of pseudo-random numbers with $n$ draws per stream, using the Permuted Congruential Generator (PCG) engine (PCG64) available in standard numerical libraries. All numerical quantities and variables must be interpreted as pure numbers, with no physical units.\n\nExperiments to implement:\n1) Accidental “same-seed per thread” bug. Create $2$ worker threads. Each thread creates its own local PRNG instance but both threads use the same fixed seed $s$. Each thread produces $n$ real numbers in $[0,1)$. Compute the empirical Pearson correlation coefficient $r_1$ between the two length-$n$ sequences. Because both threads are producing the same deterministic sequence, this $r_1$ should equal $1$ when computed exactly on identical sequences.\n2) Shared global generator with enforced alternation. Create $2$ worker threads that share a single global PRNG instance seeded with $s$. Enforce a strict alternating schedule so that the threads draw in the exact order $A_0, B_0, A_1, B_1, \\dots, A_{n-1}, B_{n-1}$, where $A_i$ are the draws assigned to thread $A$ and $B_i$ to thread $B$. Separately, from the same seed $s$, generate a single-threaded reference sequence $Z$ of length $2n$. Construct the merged sequence $M$ by interleaving the two threaded outputs in the same alternation order. Output a boolean $b_2$ indicating whether $M$ is elementwise identical to $Z$. A value $b_2 = \\text{True}$ demonstrates that the two threaded streams are deterministically dependent subsequences of a single stream.\n3) Proper per-thread stream isolation via a master seed. Use a single master seed $s$ to initialize a master seed-sequence object, then derive two independent child seed-sequences for two per-thread PRNG instances (PCG64) so that the two streams are non-overlapping by construction. Run $2$ threads, each generating $n$ real numbers in $[0,1)$ from its own PRNG. Compute the empirical Pearson correlation coefficient $r_3$ between the two sequences. For sufficiently large $n$, this $r_3$ should be close to $0$ in magnitude.\n\nTest suite and parameters:\n- Use the following three test cases, each a triple $(\\text{scenario}, n, s)$:\n  - $\\big($\"same\\_seed\\_per\\_thread\", $4096$, $123456789\\big)$\n  - $\\big($\"shared\\_generator\\_interleaved\", $4096$, $123456789\\big)$\n  - $\\big($\"spawn\\_isolated\\_per\\_thread\", $4096$, $123456789\\big)$\n- For the correlation coefficients $r_1$ and $r_3$, report them as floating-point numbers rounded to $6$ decimal places.\n- For the equality check in experiment $2$, report the boolean $b_2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered to correspond to the test suite above, i.e., $[r_1, b_2, r_3]$, where $r_1$ and $r_3$ are floats rounded to exactly $6$ decimals, and $b_2$ is a boolean literal. For example, a syntactically valid output would look like $[1.000000,True,0.001234]$.",
            "solution": "The problem requires a deterministic, quantitative demonstration of the effects of pseudo-random number generator (PRNG) state management in multithreaded programs. The core principle is that a PRNG is a deterministic finite-state machine. Its sequence of outputs is entirely determined by its initial state, or seed. Correct parallel PRNG usage demands that each thread of execution operates on an independent stream of random numbers, which requires that each thread's PRNG be initialized with a state that guarantees its sequence will not overlap with others.\n\nA PRNG can be modeled by a state space $S$, an initial state $s_0 \\in S$, a state transition function $F: S \\to S$, and an output function $G: S \\to \\mathbb{R}$. The sequence of states is given by $s_{t+1} = F(s_t)$, and the sequence of pseudo-random numbers is $x_t = G(s_t)$.\n\nTo empirically assess the independence of two random number streams, we use the Pearson correlation coefficient, $r$. For two sample sequences $X = \\{x_i\\}_{i=1}^n$ and $Y = \\{y_i\\}_{i=1}^n$ with sample means $\\bar{x}$ and $\\bar{y}$ respectively, the correlation is:\n$$\nr = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^n (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^n (y_i - \\bar{y})^2}}\n$$\nFor perfectly correlated sequences (i.e., identical up to a linear transformation), $|r|=1$. For statistically independent sequences, $r$ is expected to be close to $0$ for a large sample size $n$.\n\nWe will implement three experiments using the PCG64 generator provided by the `numpy` library, with a sample size of $n=4096$ per thread and a seed of $s=123456789$.\n\n1.  **Experiment 1: Same Seed per Thread.**\n    This experiment simulates a common error where two threads, $T_A$ and $T_B$, each create a new PRNG instance but use the identical seed $s$. Because the PRNG is deterministic, both threads initialize an identical state machine: $(F, G, s_0=s)$. Consequently, both threads will generate the exact same sequence of $n$ numbers. The sequence from $T_A$, let us call it $X_A$, will be element-wise identical to the sequence $X_B$ from $T_B$. Calculating the Pearson correlation coefficient $r_1$ between $X_A$ and $X_B$ will therefore yield a value of exactly $r_1=1$, demonstrating a complete lack of independence.\n\n2.  **Experiment 2: Shared Global Generator with Enforced Alternation.**\n    This experiment demonstrates the consequence of two threads, $T_A$ and $T_B$, sharing a single PRNG instance. The state of the PRNG, $s_t$, becomes a shared resource. To make the outcome deterministic and verifiable, we enforce a strict alternating schedule for draws using synchronization primitives (semaphores). $T_A$ draws, then $T_B$, then $T_A$, and so on. The sequence of draws across both threads is $\\{A_0, B_0, A_1, B_1, \\dots, A_{n-1}, B_{n-1}\\}$. This interleaved process is equivalent to a single thread drawing $2n$ numbers. To prove this, we generate a reference sequence $Z$ of length $2n$ using a single thread initialized with the same seed $s$. We then construct a merged sequence $M$ by interleaving the outputs from $T_A$ and $T_B$. We expect the boolean comparison $b_2 = (M \\equiv Z)$ to be True, which confirms that the threads did not produce independent streams but rather disjoint subsequences of a single, underlying stream.\n\n3.  **Experiment 3: Proper Stream Isolation via Spawning.**\n    This experiment demonstrates the correct methodology for creating independent random number streams in parallel applications. Instead of using the same seed directly, we use a master seed $s$ to initialize a `SeedSequence` object. This object acts as a factory for generating cryptographically strong, independent seed data for multiple PRNGs. We use its `spawn(2)` method to create two child `SeedSequence` objects, $ss_A$ and $ss_B$. These children are guaranteed to initialize PRNGs that produce non-overlapping, statistically independent sequences. Thread $T_A$ uses a PRNG initialized from $ss_A$, and thread $T_B$ uses one initialized from $ss_B$. The resulting sequences, $X_A$ and $X_B$, will be statistically independent. The computed Pearson correlation coefficient $r_3$ between them will be close to zero, reflecting this independence. The magnitude of $r_3$ is expected to be on the order of $1/\\sqrt{n}$. For $n=4096$, we expect $|r_3| \\approx 1/\\sqrt{4096} \\approx 0.0156$.\n\nThe program below implements these three experiments, calculates the required metrics ($r_1$, $b_2$, $r_3$), and formats the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport threading\n\ndef solve():\n    \"\"\"\n    Runs three experiments to demonstrate PRNG state management in multithreading.\n    1. Same seed per thread -> correlated streams.\n    2. Shared generator -> dependent streams.\n    3. Spawning child seeds -> independent streams.\n    \"\"\"\n    \n    # Define the test parameters from the problem statement.\n    # n and s are the same for all three experiments.\n    n = 4096\n    s = 123456789\n\n    # --- Experiment 1: \"same_seed_per_thread\" ---\n    # Each thread creates its own PRNG from the same seed.\n    def worker_exp1(seed, size, out_array):\n        \"\"\"Worker for experiment 1: creates a local PRNG.\"\"\"\n        rng = np.random.Generator(np.random.PCG64(seed))\n        out_array[:] = rng.random(size)\n\n    stream1_exp1 = np.empty(n, dtype=np.float64)\n    stream2_exp1 = np.empty(n, dtype=np.float64)\n    \n    thread1 = threading.Thread(target=worker_exp1, args=(s, n, stream1_exp1))\n    thread2 = threading.Thread(target=worker_exp1, args=(s, n, stream2_exp1))\n    \n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n\n    # The streams should be identical, so correlation is 1.0.\n    r1 = np.corrcoef(stream1_exp1, stream2_exp1)[0, 1]\n\n    # --- Experiment 2: \"shared_generator_interleaved\" ---\n    # Threads share one PRNG, with access ordered by semaphores.\n    def worker_A_exp2(rng, size, sem_a, sem_b, out_array):\n        \"\"\"Worker A: acquires sem_a, releases sem_b.\"\"\"\n        for i in range(size):\n            sem_a.acquire()\n            out_array[i] = rng.random()\n            sem_b.release()\n\n    def worker_B_exp2(rng, size, sem_a, sem_b, out_array):\n        \"\"\"Worker B: acquires sem_b, releases sem_a.\"\"\"\n        for i in range(size):\n            sem_b.acquire()\n            out_array[i] = rng.random()\n            sem_a.release()\n\n    shared_rng = np.random.Generator(np.random.PCG64(s))\n    stream_a_exp2 = np.empty(n, dtype=np.float64)\n    stream_b_exp2 = np.empty(n, dtype=np.float64)\n\n    # Semaphores to enforce strict A, B, A, B... alternation.\n    sem_a = threading.Semaphore(1)\n    sem_b = threading.Semaphore(0)\n\n    thread_a = threading.Thread(target=worker_A_exp2, args=(shared_rng, n, sem_a, sem_b, stream_a_exp2))\n    thread_b = threading.Thread(target=worker_B_exp2, args=(shared_rng, n, sem_a, sem_b, stream_b_exp2))\n    \n    thread_a.start()\n    thread_b.start()\n    thread_a.join()\n    thread_b.join()\n\n    # Interleave the results from the two threads.\n    merged_sequence = np.empty(2 * n, dtype=np.float64)\n    merged_sequence[0::2] = stream_a_exp2\n    merged_sequence[1::2] = stream_b_exp2\n    \n    # Generate the single-threaded reference sequence.\n    ref_rng = np.random.Generator(np.random.PCG64(s))\n    reference_sequence = ref_rng.random(2 * n)\n\n    # The interleaved threaded sequence should be identical to the reference.\n    b2 = np.array_equal(merged_sequence, reference_sequence)\n\n    # --- Experiment 3: \"spawn_isolated_per_thread\" ---\n    # Each thread gets an independent PRNG from a spawned SeedSequence.\n    def worker_exp3(rng, size, out_array):\n        \"\"\"Worker for experiment 3: uses a pre-made PRNG.\"\"\"\n        out_array[:] = rng.random(size)\n\n    # Create a master SeedSequence and spawn two independent children.\n    ss = np.random.SeedSequence(s)\n    child_sequences = ss.spawn(2)\n    \n    rng1_exp3 = np.random.Generator(np.random.PCG64(child_sequences[0]))\n    rng2_exp3 = np.random.Generator(np.random.PCG64(child_sequences[1]))\n\n    stream1_exp3 = np.empty(n, dtype=np.float64)\n    stream2_exp3 = np.empty(n, dtype=np.float64)\n\n    thread1_exp3 = threading.Thread(target=worker_exp3, args=(rng1_exp3, n, stream1_exp3))\n    thread2_exp3 = threading.Thread(target=worker_exp3, args=(rng2_exp3, n, stream2_exp3))\n    \n    thread1_exp3.start()\n    thread2_exp3.start()\n    thread1_exp3.join()\n    thread2_exp3.join()\n    \n    # The streams should be independent, so correlation is near 0.\n    r3 = np.corrcoef(stream1_exp3, stream2_exp3)[0, 1]\n\n    # Final print statement in the exact required format.\n    print(f\"[{r1:.6f},{b2},{r3:.6f}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having seen the dangers of naive approaches, we now explore a foundational and robust technique for parallelizing stateful generators like Linear Congruential Generators (LCGs). This exercise challenges you to implement a \"skip-ahead\" function, which allows a process to efficiently jump forward in a pseudorandom number generator (PRNG) sequence to find the unique starting point for its workload . By applying this to a Monte Carlo estimation of $\\pi$, you will prove that simulations can yield bit-for-bit identical results, regardless of how many parallel processes are used, achieving perfect reproducibility.",
            "id": "3170099",
            "problem": "You are asked to design and implement a principled scheme for assigning independent Pseudorandom Number Generator (PRNG) streams to $p$ Message Passing Interface (MPI) processes using block-splitting, and to verify the reproducibility of a Monte Carlo estimator of $\\hat{\\pi}$ across different process counts. The entire solution must be expressed as a complete, runnable program.\n\nFundamental principles to use:\n- Definition of a Pseudorandom Number Generator (PRNG) stream as a deterministic sequence $\\{x_n\\}$ produced by a state update rule.\n- A linear congruential generator (LCG) with modulus $m$ is defined by the recurrence $x_{n+1} = (a x_n + c) \\bmod m$, with initial state $x_0$.\n- Mapping a uniform integer state to a uniform real variate in $[0,1)$ via taking the high-order bits and scaling by an appropriate power of $2$ to produce a floating-point number.\n- Monte Carlo estimation of $\\pi$ by sampling $(x,y)$ uniformly in $[0,1]^2$ and counting hits inside the quarter unit circle, with estimator $\\hat{\\pi} = 4 H / N$, where $H$ is the number of hits and $N$ is the total number of trials.\n\nDesign goals:\n1. Assign each of the $p$ processes a disjoint contiguous block of trial indices so that, for a fixed total number $N$ of trials, the union of all assigned trials is exactly $\\{0,1,\\dots,N-1\\}$ independent of $p$, and no two processes share an index. Use block-splitting with unequal last blocks as needed. A standard contiguous partition is defined by letting $q = \\lfloor N/p \\rfloor$ and $r = N \\bmod p$, so that process $i$ is assigned block start $S_i = i q + \\min(i,r)$ and block length $L_i = q + 1$ if $i < r$ and $L_i = q$ otherwise.\n2. Each trial index $t$ corresponds to two PRNG draws $(u_{2t}, u_{2t+1})$ to form $(x, y)$. Therefore, process $i$ must start its PRNG stream at position $2 S_i$ and consume $2 L_i$ values. To enable this efficiently, implement a skip-ahead routine for the LCG to move the state forward by $k$ steps without iterating one-by-one.\n\nScientific and algorithmic requirements:\n- Use an LCG with modulus $m = 2^{64}$, multiplier $a = 6364136223846793005$, and increment $c = 1442695040888963407$, with an arbitrary but fixed seed $x_0$ in $\\{0,1,\\dots,m-1\\}$. These constants yield a full-period LCG modulo $2^{64}$ when $c$ is odd, which is a well-tested configuration.\n- Derive and implement an efficient skip-ahead method using composition of affine transforms. For a single step, $T(x) = a x + c \\bmod m$ is an affine map. Show how to compute $T^k(x) = A_k x + C_k \\bmod m$ using exponentiation by squaring and transform composition, avoiding modular division.\n- Map each $x_n$ to a double-precision real $u_n \\in [0,1)$ by taking the top $53$ bits of $x_n$ and multiplying by $2^{-53}$, ensuring uniformity on the double grid.\n- Simulate the Monte Carlo estimator $\\hat{\\pi}$ by assigning trials via block-splitting to $p$ simulated processes, advancing each process’s PRNG state appropriately via skip-ahead, and accumulating hits $H$ across all processes.\n\nTest suite:\n- For each test case, the program must return a boolean indicating whether the reproducibility or block assignment property holds, as specified. There are four test cases:\n    1. Happy path reproducibility: $N = 200000$, process counts $p \\in \\{1,2,4,8\\}$. Verify that all $\\hat{\\pi}$ estimates are exactly equal as floating-point numbers.\n    2. Non-divisible $N$ reproducibility: $N = 123457$, process counts $p \\in \\{3,5,7\\}$. Verify equal $\\hat{\\pi}$ across all $p$.\n    3. Boundary case with many processes relative to trials: $N = 64$, process counts $p \\in \\{1,64,128\\}$. Verify equal $\\hat{\\pi}$ across all $p$ and correct handling of zero-length blocks.\n    4. Block assignment correctness: $N = 1000$, $p = 33$. Verify that the block-splitting partition covers exactly the set of trial indices $\\{0,\\dots,999\\}$ with no overlaps. The test returns `True` if blocks are contiguous, disjoint, and fully cover the index set.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,result_3,result_4]$).\n- For the four test cases above, the outputs must be four booleans in order, corresponding to tests $1$ through $4$.\n\nAll computations are purely mathematical and have no physical units involved. Angles are not used. Percentages are not used. The entire program must be self-contained, must not read input, and must be deterministic given the fixed seed $x_0$. The implementation language is unrestricted in the problem statement, but your submitted final answer must be a complete, runnable Python program as specified separately.",
            "solution": "The core of this problem lies in demonstrating that a Monte Carlo simulation can yield bit-for-bit identical results regardless of how the computational work is partitioned among parallel processes, provided the partitioning of the underlying pseudorandom number stream is mathematically exact. We will design a system that achieves this by combining three key components: a robust method for partitioning the workload (block-splitting), an efficient algorithm for navigating the pseudorandom number stream (LCG skip-ahead), and a deterministic Monte Carlo procedure for estimating $\\pi$.\n\nFirst, we establish the mathematical foundation for advancing a Linear Congruential Generator (LCG) by an arbitrary number of steps, $k$, without explicit iteration. An LCG is defined by the recurrence relation:\n$$\nx_{n+1} = (a x_n + c) \\pmod m\n$$\nwhere $x_n$ is the state at step $n$, and $a$, $c$, and $m$ are the multiplier, increment, and modulus, respectively. This is an affine transformation $T(x) = ax + c$ over the ring of integers modulo $m$. Applying the generator $k$ times is equivalent to composing the transformation with itself $k$ times, resulting in $T^k(x)$.\n\nLet the transformation for a single step be represented by the pair of coefficients $(a, c)$. Composition of two such transformations, $(a_1, c_1)$ and $(a_2, c_2)$, yields a new transformation:\n$$\n(T_1 \\circ T_2)(x) = T_1(T_2(x)) = a_1(a_2 x + c_2) + c_1 = (a_1 a_2) x + (a_1 c_2 + c_1)\n$$\nThe resulting transformation is defined by the new pair $(a_1 a_2, a_1 c_2 + c_1)$. This composition is associative. This algebraic structure allows us to compute the parameters for the $k$-step transformation, $(A_k, C_k)$, where $T^k(x) = A_k x + C_k \\pmod m$, using binary exponentiation (also known as exponentiation by squaring).\n\nThe algorithm to find $(A_k, C_k)$ for a given number of steps $k$ is as follows:\n$1$. Initialize a \"total\" transform to the identity, $(A_{total}, C_{total}) = (1, 0)$.\n$2$. Initialize a \"current\" transform to the single-step LCG parameters, $(A_{current}, C_{current}) = (a, c)$.\n$3$. While $k > 0$:\n    a. If $k$ is odd, compose the total transform with the current transform: $(A_{total}, C_{total}) \\leftarrow (A_{total} A_{current}, A_{total} C_{current} + C_{total})$.\n    b. Square the current transform: $(A_{current}, C_{current}) \\leftarrow (A_{current}^2, A_{current} C_{current} + C_{current})$.\n    c. Update $k \\leftarrow \\lfloor k/2 \\rfloor$.\nAll arithmetic is performed modulo $m$. For this problem, $m = 2^{64}$, so we use unsigned $64$-bit integer arithmetic. The final state after $k$ steps is then $x_k = (A_k x_0 + C_k) \\pmod m$.\n\nSecond, we address the workload distribution. The problem specifies a block-splitting strategy to partition $N$ total Monte Carlo trials among $p$ processes. The formulas given are:\n- $q = \\lfloor N/p \\rfloor$\n- $r = N \\bmod p$\n- For process $i \\in \\{0, 1, \\dots, p-1\\}$:\n  - Start trial index: $S_i = i q + \\min(i, r)$\n  - Number of trials: $L_i = q + 1$ if $i < r$, and $L_i = q$ otherwise.\nThis standard partitioning scheme creates a set of contiguous, disjoint blocks of trial indices $\\{[S_i, S_i + L_i - 1]\\}_{i=0}^{p-1}$ whose union is exactly the set of all trial indices $\\{0, 1, \\dots, N-1\\}$.\n\nThird, we link the parallel scheme to the PRNG. Each Monte Carlo trial $t$ requires two random variates, $(u_{2t}, u_{2t+1})$, to form the coordinate pair $(x,y)$. Therefore, process $i$, which is assigned trial indices starting from $S_i$, must begin generating random numbers at index $2S_i$ in the global PRNG stream. It will consume a total of $2L_i$ random numbers. By using the skip-ahead algorithm derived above with $k=2S_i$, each process can directly calculate its unique starting state $x_{2S_i}$ from the global seed $x_0$ and then proceed to generate its local sequence of $2L_i$ pseudorandom numbers.\n\nThe conversion from the $64$-bit integer state $x_n$ to a double-precision floating-point number $u_n \\in [0,1)$ is performed by taking the most significant $53$ bits of $x_n$ and scaling by $2^{-53}$. This is expressed as `(x_n >> 11) * (2**-53)`, which maps the integer state to the grid of double-precision representable numbers in the interval.\n\nThe Monte Carlo estimation of $\\pi$ proceeds by generating $N$ points $(x, y)$ in the unit square $[0,1)^2$ and counting the number of \"hits,\" $H$, that fall within the quarter unit circle, i.e., $x^2 + y^2 < 1$. The estimator is $\\hat{\\pi} = 4H/N$. Because our parallel scheme ensures that the total set of random pairs $\\{(u_{2t}, u_{2t+1})\\}_{t=0}^{N-1}$ generated is identical regardless of the number of processes $p$, the total number of hits $H = \\sum_{i=0}^{p-1} H_i$ (where $H_i$ are the hits counted by process $i$) will be invariant. Consequently, the final estimate $\\hat{\\pi}$ must be bit-for-bit identical across different values of $p$.\n\nThe implementation will consist of functions to perform the LCG skip-ahead, to calculate the block splits, and to run the full simulation for a given $(N, p)$ pair. The test suite will then call these functions to verify the required properties of reproducibility and correct partitioning. For all tests, we use the specified LCG parameters $m=2^{64}$, $a=6364136223846793005$, $c=1442695040888963407$, and a fixed initial seed $x_0 = 42$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for parallel random number generation.\n    \"\"\"\n\n    # LCG parameters from the problem statement.\n    # m = 2**64, but we use a mask for 64-bit unsigned arithmetic.\n    M_64_MASK = (1 << 64) - 1\n    A = 6364136223846793005\n    C = 1442695040888963407\n    # An arbitrary but fixed seed.\n    X0 = 42\n\n    def lcg_skip_ahead(k, a, c, mask):\n        \"\"\"\n        Computes the parameters (A_k, C_k) for an LCG skip of k steps.\n        The k-step transformation is T^k(x) = A_k * x + C_k (mod m).\n        This is equivalent to computing M^k where M is the matrix [[a, c], [0, 1]].\n        We do this via binary exponentiation on the transform parameters.\n\n        Args:\n            k (int): The number of steps to skip ahead.\n            a (int): The LCG multiplier.\n            c (int): The LCG increment.\n            mask (int): The mask for modulo 2**64 arithmetic.\n\n        Returns:\n            tuple[int, int]: The effective multiplier and increment (A_k, C_k).\n        \"\"\"\n        if k == 0:\n            return 1, 0\n\n        # total_a, total_c represent the composed transform so far.\n        # Identity transform: 1*x + 0.\n        total_a, total_c = 1, 0\n        \n        # current_a, current_c represent the transform for powers of 2 steps.\n        # Starts with the 1-step transform.\n        current_a, current_c = a, c\n\n        while k > 0:\n            if k & 1:\n                # Compose total transform with current: total_new = current o total_old\n                # T_new(x) = current_a * (total_a * x + total_c) + current_c\n                # T_new(x) = (current_a * total_a) * x + (current_a * total_c + current_c)\n                # We use the equivalent composition T_new = total_old o current.\n                # T_new(x) = total_a * (current_a * x + current_c) + total_c\n                # T_new(x) = (total_a * current_a) * x + (total_a * current_c + total_c)\n                \n                total_c = (total_a * current_c + total_c) & mask\n                total_a = (total_a * current_a) & mask\n\n            # Square the current transform: current_new = current o current\n            # T_new(x) = a'(a'x + c') + c' = (a'^2)x + (a'c' + c')\n            current_c = (current_a * current_c + current_c) & mask\n            current_a = (current_a * current_a) & mask\n            \n            k >>= 1\n        \n        return total_a, total_c\n\n    def get_block_split(N, p, i):\n        \"\"\"\n        Calculates the start index and length of the block for process i.\n\n        Args:\n            N (int): Total number of trials.\n            p (int): Total number of processes.\n            i (int): The process rank (0-indexed).\n\n        Returns:\n            tuple[int, int]: (start_trial, num_trials) for process i.\n        \"\"\"\n        q = N // p\n        r = N % p\n        start_trial = i * q + min(i, r)\n        num_trials = q + 1 if i < r else q\n        return start_trial, num_trials\n\n    def run_simulation(N, p, x0, a, c, mask):\n        \"\"\"\n        Runs the Monte Carlo simulation for pi with N trials on p processes.\n\n        Args:\n            N (int): Total number of trials.\n            p (int): Number of simulated processes.\n            x0 (int): The initial seed for the entire stream.\n            a (int): LCG multiplier.\n            c (int): LCG increment.\n            mask (int): Modulo mask.\n\n        Returns:\n            float: The estimated value of pi.\n        \"\"\"\n        total_hits = 0\n        \n        # Scale for converting 53 high bits to a float in [0,1)\n        scale = 1.0 / (1 << 53)\n        \n        for i in range(p):\n            start_trial, num_trials = get_block_split(N, p, i)\n            \n            if num_trials == 0:\n                continue\n\n            # Each trial needs 2 random numbers.\n            skip_steps = 2 * start_trial\n            A_k, C_k = lcg_skip_ahead(skip_steps, a, c, mask)\n            \n            # This is the starting state for process i's PRNG stream.\n            x = (A_k * x0 + C_k) & mask\n            \n            local_hits = 0\n            for _ in range(num_trials):\n                # Generate u1 (for x-coordinate)\n                x = (a * x + c) & mask\n                u1 = (x >> 11) * scale\n                \n                # Generate u2 (for y-coordinate)\n                x = (a * x + c) & mask\n                u2 = (x >> 11) * scale\n                \n                if u1 * u1 + u2 * u2 < 1.0:\n                    local_hits += 1\n            \n            total_hits += local_hits\n            \n        if N == 0:\n            return 0.0  # Or other sensible value for N=0\n        \n        return 4.0 * total_hits / N\n\n    def test_reproducibility(N, p_list, x0, a, c, mask):\n        \"\"\"Helper to test reproducibility across different process counts.\"\"\"\n        if not p_list:\n            return True\n        results = [run_simulation(N, p, x0, a, c, mask) for p in p_list]\n        return len(set(results)) == 1\n\n    def test_block_assignment(N, p):\n        \"\"\"Verify that block splitting creates a correct partition.\"\"\"\n        current_pos = 0\n        total_len = 0\n        for i in range(p):\n            start, length = get_block_split(N, p, i)\n            if start != current_pos:\n                return False  # Partition is not contiguous\n            current_pos += length\n            total_len += length\n        \n        # Check if the partition covers the entire set and only the set\n        return current_pos == N and total_len == N\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Happy path reproducibility\n        lambda: test_reproducibility(200000, [1, 2, 4, 8], X0, A, C, M_64_MASK),\n        # Test 2: Non-divisible N reproducibility\n        lambda: test_reproducibility(123457, [3, 5, 7], X0, A, C, M_64_MASK),\n        # Test 3: Boundary case with p > N\n        lambda: test_reproducibility(64, [1, 64, 128], X0, A, C, M_64_MASK),\n        # Test 4: Block assignment correctness\n        lambda: test_block_assignment(1000, 33)\n    ]\n\n    results = []\n    for test_func in test_cases:\n        results.append(test_func())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While managing stateful streams is a powerful technique, modern parallel programming often benefits from an even more flexible approach: stateless, counter-based generators. In this final practice, you will implement a PRNG where each random number is a pure function of a unique counter and a seed, completely eliminating the need to manage and advance state . You will verify the profound implication of this design: the generated random numbers are invariant to the execution order, providing guaranteed reproducibility even with complex parallel schedules like loop tiling or dynamic task scheduling.",
            "id": "3170077",
            "problem": "You are given a nested parallel loop structure over indices $i$ and $j$ with $i \\in \\{0, 1, \\dots, N-1\\}$ and $j \\in \\{0, 1, \\dots, K-1\\}$. The task is to construct a deterministic stream labeling scheme for pseudorandom number generation that is invariant under changes to the loop execution schedule, such as loop tiling and loop fusion. The construction must use a counter-based mapping from the pair $(i, j)$ to a single integer counter $c$ defined by $c = i \\cdot K + j$. The pseudorandom number generator must be stateless and must derive the output exclusively from the seed $s$ and the counter $c$.\n\nFundamental principles:\n- A Pseudorandom Number Generator (PRNG) is a deterministic algorithm that maps a seed $s$ and a state to an output. For counter-based PRNGs, the state is a counter $c$ and the output is $F(s, c)$ for a fixed function $F$.\n- Deterministic functions $F(s, c)$ yield the same output for the same inputs regardless of execution schedule or parallel ordering.\n- The mapping $c = i \\cdot K + j$ is a bijection between pairs $(i, j)$ with $i \\in \\{0, 1, \\dots, N-1\\}$ and $j \\in \\{0, 1, \\dots, K-1\\}$ and integers $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$, with inverse $i = \\left\\lfloor \\frac{c}{K} \\right\\rfloor$ and $j = c \\bmod K$.\n\nYour program must:\n1. Implement a stateless, counter-based PRNG defined as $F(s, c)$ that produces a $64$-bit unsigned integer from $s$ and $c$. The function must depend only on $s$ and $c$, and the program must demonstrate reproducibility under different loop traversal orders.\n2. Use the mapping $c = i \\cdot K + j$ to label streams for all $(i, j)$ pairs. The PRNG output for a given $(i, j)$ must be identical across different schedules because the value depends solely on $c$ and $s$.\n3. Verify reproducibility under:\n   - Row-major nested loops.\n   - Loop tiling with tile sizes $T_i$ and $T_j$.\n   - Loop fusion into a single loop over $c$.\n   - Arbitrary reordering by permuting the sequence of counters $c$.\n4. Verify the effect of changing the seed $s$ by showing that outputs change when $s$ changes, while reproducibility holds when $s$ is fixed.\n\nTest suite:\n- The program must run the following five test cases and return a boolean for each case indicating whether the required property holds.\n  - Test $1$ (Row-major vs tiled):\n    - Parameters: $N = 4$, $K = 5$, $T_i = 2$, $T_j = 3$, $s = 0x0123456789ABCDEF$.\n    - Property: For all $(i, j)$, the outputs from row-major traversal and from tiled traversal are identical.\n  - Test $2$ (Nested vs fused):\n    - Parameters: $N = 5$, $K = 7$, $s = 0x0123456789ABCDEF$.\n    - Property: For all $(i, j)$, outputs from nested traversal and fused traversal over $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ are identical.\n  - Test $3$ (Boundary case $K = 1$):\n    - Parameters: $N = 8$, $K = 1$, $s = 0x0123456789ABCDEF$.\n    - Property: For all $i$, outputs from nested traversal and fused traversal over $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ are identical, where $c = i$ when $K = 1$.\n  - Test $4$ (Seed change vs reproducibility):\n    - Parameters: $N = 3$, $K = 4$, $s_1 = 0x0123456789ABCDEF$, $s_2 = 0xF0E1D2C3B4A59687$.\n    - Properties: \n      - With fixed $s_1$, outputs under row-major and tiled traversals are identical for all $(i, j)$.\n      - With $s_1 \\ne s_2$, there exists at least one $(i, j)$ for which $F(s_1, c) \\ne F(s_2, c)$.\n    - The test returns `True` only if both properties are satisfied.\n  - Test $5$ (Arbitrary permutation):\n    - Parameters: $N = 3$, $K = 7$, $s = 0x0123456789ABCDEF$.\n    - Property: For all $(i, j)$, outputs under an arbitrary permutation of counters $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ match the outputs under row-major traversal.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[result_1,result_2,result_3,result_4,result_5]$, where each $result_k$ is either $True$ or $False$. No additional text should be printed.\n- The program must be self-contained, require no input, and must be runnable as-is in a modern environment.\n\nThere are no physical units or angles involved in this problem, so no unit conversion is required.",
            "solution": "The solution is founded on two core principles: the creation of a stateless, deterministic pseudorandom number generator (PRNG) and the application of a bijective mapping from the multi-dimensional loop space to a one-dimensional counter space.\n\n**1. Principle of Stateless Determinism**\n\nA PRNG is typically a stateful function, where each call updates an internal state to produce the next number in a sequence. This approach is problematic in parallel settings, as concurrent updates to a shared state require synchronization, which introduces overhead and non-determinism in the output sequence depending on thread scheduling.\n\nThe solution is to use a stateless PRNG, which is a pure function $F(s, c)$ whose output depends exclusively on its inputs: a global seed $s$ and a counter $c$. It maintains no internal state between calls. Consequently, for a given seed $s$ and counter value $c$, the function $F(s, c)$ will always produce the exact same output, regardless of when or on which processor it is executed.\n\nFor this problem, we implement such a function $F(s, c)$ that generates a $64$-bit unsigned integer. A robust choice is a function based on the `splitmix64` algorithm. This function combines the seed $s$ and counter $c$ into an initial value and then applies a series of bitwise shifts, XOR operations, and multiplications with large, pre-determined prime constants. These operations effectively mix the bits of the input to produce an output that exhibits good statistical randomness. All arithmetic is performed using $64$-bit unsigned integer operations, ensuring wrap-around on overflow, which is critical for the algorithm's properties.\n\nLet $s$ and $c$ be $64$-bit unsigned integers. The function $F(s, c)$ is defined as follows, where all operations are performed modulo $2^{64}$:\n1.  Initialize state: $x = s + c$.\n2.  First mixing round: $x = (x \\oplus (x \\gg 30)) \\cdot 0xBF58476D1CE4E5B9$.\n3.  Second mixing round: $x = (x \\oplus (x \\gg 27)) \\cdot 0x94D049BB133111EB$.\n4.  Final mixing: $x = x \\oplus (x \\gg 31)$.\nThe result is the final value of $x$.\n\n**2. Principle of Bijective Mapping**\n\nTo make the stateless PRNG useful for a multi-dimensional problem space, such as a nested loop over indices $(i, j)$, we must uniquely label each point in that space. The problem specifies a bijective mapping from the pair of loop indices $(i, j)$ to a single integer counter $c$. The given mapping is a standard row-major linearization:\n$$c = i \\cdot K + j$$\nwhere $i \\in \\{0, 1, \\dots, N-1\\}$ and $j \\in \\{0, 1, \\dots, K-1\\}$. This function guarantees that every unique index pair $(i, j)$ maps to a unique counter $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$. This uniqueness is the key to decoupling the random number generation from the loop execution order.\n\n**3. Invariance Under Schedule Changes**\n\nBy composing the bijective mapping and the stateless PRNG, we obtain a function $G(s, i, j) = F(s, i \\cdot K + j)$ that generates a pseudorandom number for each point $(i, j)$ in the loop's iteration space.\n\nDifferent loop execution schedules, such as:\n-   **Row-major traversal**: Iterating through $j$ for each $i$.\n-   **Loop tiling**: Breaking the iteration space into smaller rectangular tiles and iterating through those.\n-   **Loop fusion**: Collapsing the nested loop into a single loop over the counter $c$.\n-   **Arbitrary permutation**: Visiting the points $(i, j)$ in a shuffled, non-sequential order.\n\nare simply different orderings for evaluating the function $G(s, i, j)$ for all pairs $(i, j)$. Since the value of $G(s, i, j)$ for any specific pair is independent of the evaluation order of any other pair, the final set of generated numbers, when organized into an $N \\times K$ grid, will be identical across all schedules.\n\nThe provided test suite verifies this invariance.\n-   **Test 1 & 4**: Compare row-major traversal to tiled traversal. The generated values for each $(i, j)$ are based on the same $c = i \\cdot K + j$, so the resulting collections of numbers must be identical.\n-   **Test 2 & 3**: Compare nested row-major traversal to a fused loop over $c$. The fused loop directly uses $c$, while the nested loop first computes $c = i \\cdot K + j$. The inverse mapping $i = \\lfloor c/K \\rfloor, j = c \\pmod K$ ensures that the value computed for a given $c$ is placed in the correct $(i, j)$ location. The results must match.\n-   **Test 4**: Verifies that changing the seed $s$ alters the output, confirming the PRNG's sensitivity to the seed, which is a fundamental requirement.\n-   **Test 5**: Compares row-major traversal to an arbitrarily permuted order of execution. This is the strongest demonstration of schedule invariance, proving that as long as every counter value $c$ from $0$ to $N \\cdot K - 1$ is processed exactly once, the final result is deterministic.\n\nThe implementation will confirm that all these properties hold, resulting in a `True` value for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef F(s, c):\n    \"\"\"\n    A stateless, counter-based PRNG that produces a 64-bit unsigned integer.\n    The function is based on the splitmix64 algorithm.\n    It is a pure function of the seed 's' and the counter 'c'.\n    \"\"\"\n    # Ensure inputs and all intermediate calculations use 64-bit unsigned integers.\n    s_64 = np.uint64(s)\n    c_64 = np.uint64(c)\n\n    # Combine seed and counter to initialize the state.\n    state = s_64 + c_64\n\n    # The splitmix64 mixing function.\n    state = (state ^ (state >> np.uint64(30))) * np.uint64(0xbf58476d1ce4e5b9)\n    state = (state ^ (state >> np.uint64(27))) * np.uint64(0x94d049bb133111eb)\n    state = state ^ (state >> np.uint64(31))\n    \n    return state\n\ndef generate_row_major(N, K, s):\n    \"\"\"Generates PRNs in a row-major nested loop traversal.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for i in range(N):\n        for j in range(K):\n            c = i * K + j\n            results[i, j] = F(s, c)\n    return results\n\ndef generate_tiled(N, K, Ti, Tj, s):\n    \"\"\"Generates PRNs in a tiled loop traversal.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for i_tile in range(0, N, Ti):\n        for j_tile in range(0, K, Tj):\n            for i in range(i_tile, min(i_tile + Ti, N)):\n                for j in range(j_tile, min(j_tile + Tj, K)):\n                    c = i * K + j\n                    results[i, j] = F(s, c)\n    return results\n\ndef generate_fused(N, K, s):\n    \"\"\"Generates PRNs in a single, fused loop over the counter 'c'.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for c in range(N * K):\n        i = c // K\n        j = c % K\n        results[i, j] = F(s, c)\n    return results\n\ndef generate_permuted(N, K, s):\n    \"\"\"Generates PRNs by processing counters in a permuted, arbitrary order.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    counters = np.arange(N * K, dtype=np.uint64)\n    \n    # Use a fixed seed for the permutation to ensure the test is deterministic.\n    rng = np.random.default_rng(seed=42)\n    rng.shuffle(counters)\n    \n    for c in counters:\n        c_int = int(c)\n        i = c_int // K\n        j = c_int % K\n        results[i, j] = F(s, c)\n    return results\n\ndef solve():\n    \"\"\"\n    Runs the test suite to verify the properties of the stateless,\n    counter-based PRNG scheme.\n    \"\"\"\n    test_cases = [\n        # Test 1: Row-major vs. Tiled\n        {'N': 4, 'K': 5, 'Ti': 2, 'Tj': 3, 's': 0x0123456789ABCDEF},\n        # Test 2: Nested vs. Fused\n        {'N': 5, 'K': 7, 's': 0x0123456789ABCDEF},\n        # Test 3: Boundary case K=1\n        {'N': 8, 'K': 1, 's': 0x0123456789ABCDEF},\n        # Test 4: Seed change vs. reproducibility\n        {'N': 3, 'K': 4, 's1': 0x0123456789ABCDEF, 's2': 0xF0E1D2C3B4A59687},\n        # Test 5: Arbitrary permutation\n        {'N': 3, 'K': 7, 's': 0x0123456789ABCDEF},\n    ]\n\n    results = []\n\n    # --- Test 1: Row-major vs. Tiled ---\n    p = test_cases[0]\n    res_row_major = generate_row_major(p['N'], p['K'], p['s'])\n    res_tiled = generate_tiled(p['N'], p['K'], p['Ti'], p['Tj'], p['s'])\n    results.append(np.array_equal(res_row_major, res_tiled))\n\n    # --- Test 2: Nested vs. Fused ---\n    p = test_cases[1]\n    res_nested = generate_row_major(p['N'], p['K'], p['s'])\n    res_fused = generate_fused(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_nested, res_fused))\n\n    # --- Test 3: Boundary case K=1 ---\n    p = test_cases[2]\n    res_nested = generate_row_major(p['N'], p['K'], p['s'])\n    res_fused = generate_fused(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_nested, res_fused))\n    \n    # --- Test 4: Seed change vs. reproducibility ---\n    p = test_cases[3]\n    # Tiling requires tile sizes. We use a reasonable choice for the test.\n    Ti_t4, Tj_t4 = 2, 2\n    # Property 1: Reproducibility with fixed seed s1\n    res_row_major_s1 = generate_row_major(p['N'], p['K'], p['s1'])\n    res_tiled_s1 = generate_tiled(p['N'], p['K'], Ti_t4, Tj_t4, p['s1'])\n    prop1 = np.array_equal(res_row_major_s1, res_tiled_s1)\n    # Property 2: Different outputs for different seeds\n    res_row_major_s2 = generate_row_major(p['N'], p['K'], p['s2'])\n    prop2 = not np.array_equal(res_row_major_s1, res_row_major_s2)\n    results.append(prop1 and prop2)\n\n    # --- Test 5: Arbitrary permutation ---\n    p = test_cases[4]\n    res_row_major = generate_row_major(p['N'], p['K'], p['s'])\n    res_permuted = generate_permuted(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_row_major, res_permuted))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}