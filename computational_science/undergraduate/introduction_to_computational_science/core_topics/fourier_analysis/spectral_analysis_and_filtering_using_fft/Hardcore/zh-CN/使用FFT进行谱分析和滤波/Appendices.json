{
    "hands_on_practices": [
        {
            "introduction": "当我们使用截断的傅里叶级数来近似不连续函数（如方波）时，会在不连续点附近观察到一种持续的过冲现象，这被称为吉布斯现象。本练习 () 将引导您亲手重现这一效应，并向您介绍一种实用的缓解方法——谱滤波。通过这个过程，您将深入理解信号近似中的一个基本权衡关系。",
            "id": "3282429",
            "problem": "考虑一个 $2\\pi$-周期函数 $f(\\theta)$，其定义为：当 $0 \\le \\theta  \\pi$ 时，$f(\\theta)=1$；当 $\\pi \\le \\theta  2\\pi$ 时，$f(\\theta)=-1$，并进行周期性延拓。任务是使用通过快速傅里叶变换 (FFT) 算法计算的傅里叶部分和 $S_N(\\theta)$ 来分析吉布斯现象，并应用谱指数滤波器来减少不连续点附近的过冲。整个过程完全使用弧度制。\n\n使用以下基本原理和约束：\n\n- $2\\pi$-周期函数 $f(\\theta)$ 的傅里叶级数由复傅里叶系数构成，截断的部分和 $S_N(\\theta)$ 保留频率指数绝对值最大为 $N$ 的模式。\n- 采样数据的离散傅里叶变换 (DFT) 为等距网格上的傅里叶系数提供了一致的数值近似，而快速傅里叶变换 (FFT) 算法以 $\\mathcal{O}(M \\log M)$ 的时间复杂度计算 $M$ 个样本的 DFT。\n- 谱指数滤波器的定义是：将每个保留的、对应于频率指数 $k$（其中 $1 \\le |k| \\le N$）的复傅里叶系数乘以因子 $\\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)$，并保持零频模式不变。使用 $\\alpha=36$ 和 $p=8$。\n\n实现以下步骤：\n\n1. 在一个包含 $M$ 个点的均匀网格上对 $f(\\theta)$ 进行采样，其中 $M=4096$，采样点为 $\\theta_j = \\frac{2\\pi j}{M}$，对于 $j=0,1,2,\\dots,M-1$。\n2. 使用快速傅里叶变换 (FFT) 从样本中计算离散谱。通过将除了频率大小 $\\le N$ 的指数对应的 DFT 系数之外的所有系数都置零来构造 $S_N(\\theta)$（对称地保留正频率和负频率，并包括零频模式）。在同一网格上通过逆变换重构 $S_N(\\theta)$。\n3. 在进行逆变换之前，将参数为 $\\alpha=36$ 和 $p=8$ 的指数滤波器应用于保留的系数，以构造滤波后的部分和 $S_N^{\\mathrm{filt}}(\\theta)$，并保持零频模式不变。\n4. 对于每个 $N$，量化以下两个指标：\n   - 过冲幅度，定义为 $\\max_{\\theta} S_N(\\theta) - 1$，并从下方以 $0$ 截断，以确保报告的幅度为非负值。\n   - 均方根 (RMS) 误差，定义为 $\\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S_N(\\theta_j) - f(\\theta_j)\\right)^2}$。\n   对 $S_N^{\\mathrm{filt}}(\\theta)$ 也进行这两项测量。\n5. 使用测试集 $N \\in \\{0,1,8,32,128,512\\}$，并报告测试集中每个 $N$ 值对应的未滤波过冲幅度、滤波后过冲幅度、未滤波 RMS 误差和滤波后 RMS 误差。\n\n您的程序应生成单行输出，其中包含一个由五个列表组成的逗号分隔列表，没有空格，并严格按照以下顺序：$N$ 值列表、未滤波过冲幅度列表、滤波后过冲幅度列表、未滤波 RMS 误差列表和滤波后 RMS 误差列表。例如，要求的格式为 `[[N_list],[unfiltered_overshoots],[filtered_overshoots],[unfiltered_rms],[filtered_rms]]`，其中每个方括号项都是一个数字列表。所有角度都以弧度为单位，所有报告的数值均为无单位的浮点数。",
            "solution": "该问题要求对一个 $2\\pi$-周期方波的吉布斯现象及其使用谱指数滤波器的缓解方法进行数值研究。分析将使用快速傅里叶变换 (FFT) 算法来计算截断的傅里叶级数近似。\n\n所考虑的函数是一个在区间 $[0, 2\\pi)$ 上定义的 $2\\pi$-周期方波：\n$$\nf(\\theta) = \\begin{cases}\n    1   \\text{for } 0 \\le \\theta  \\pi \\\\\n    -1  \\text{for } \\pi \\le \\theta  2\\pi\n\\end{cases}\n$$\n该函数在任何整数 $n$ 的 $\\theta = n\\pi$ 处具有跳跃不连续点。当用截断的傅里叶级数近似时，这些不连续点会导致吉布斯现象，其特征是在跳跃点附近存在持续的过冲。\n\n分析的核心依赖于离散傅里叶变换 (DFT)，它通过 FFT 进行高效计算。步骤如下：\n\n首先，我们对域 $[0, 2\\pi)$ 进行离散化。函数 $f(\\theta)$ 在一个由 $M=4096$ 个点组成的均匀网格上进行采样，采样点由 $\\theta_j = \\frac{2\\pi j}{M}$ 给出，其中 $j=0, 1, \\dots, M-1$。这将产生一个样本向量 $f_j = f(\\theta_j)$。根据函数定义，这导致当 $j=0, \\dots, M/2-1$ 时 $f_j = 1$，当 $j=M/2, \\dots, M-1$ 时 $f_j = -1$。\n\n其次，我们计算采样信号 $\\{f_j\\}$ 的 DFT 以获得其频谱 $\\{\\hat{f}_k\\}$。DFT 定义为 $\\hat{f}_k = \\sum_{j=0}^{M-1} f_j \\exp(-i 2\\pi jk/M)$。对于 FFT 算法的输出数组，可以获得相应的整数频率模式（波数）$k$。对于长度为 $M$ 的输入，频率对应于序列 $k = 0, 1, \\dots, M/2-1, -M/2, \\dots, -1$。\n\n第三，对于测试集 $\\{0, 1, 8, 32, 128, 512\\}$ 中的每个截断参数 $N$，我们构造 $f(\\theta)$ 的两种不同近似。\n\n未滤波的傅里叶部分和 $S_N(\\theta)$ 是从一个截断频谱 $\\hat{S}_{N}$ 构造的。该频谱是通过将所有绝对频率指数 $|k|$ 超过截断极限 $N$ 的系数 $\\hat{f}_k$ 置零得到的：\n$$\n\\hat{S}_{N,k} = \\begin{cases}\n    \\hat{f}_k   \\text{if } |k| \\le N \\\\\n    0   \\text{if } |k| > N\n\\end{cases}\n$$\n然后，通过对频谱系数 $\\{\\hat{S}_{N,k}\\}$ 应用逆离散傅里叶变换 (IDFT) 来恢复其空间表示 $S_N(\\theta_j)$。IDFT 由 $S_N(\\theta_j) = \\frac{1}{M} \\sum_{k=0}^{M-1} \\hat{S}_{N,k} \\exp(i 2\\pi jk/M)$ 给出。\n\n滤波后的部分和 $S_N^{\\mathrm{filt}}(\\theta)$ 是为了减少吉布斯振荡而构造的。这是通过在进行逆变换之前对截断频谱应用谱滤波器来实现的。滤波后的频谱 $\\hat{S}_{N,k}^{\\mathrm{filt}}$ 的定义是将保留的系数乘以一个滤波器因子 $\\sigma_k$：\n$$\n\\hat{S}_{N,k}^{\\mathrm{filt}} = \\sigma_k \\hat{S}_{N,k} \\quad \\text{where} \\quad \\sigma_k = \\begin{cases}\n    1   \\text{if } k=0 \\\\\n    \\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)   \\text{if } 1 \\le |k| \\le N \\\\\n    1   \\text{if } |k| > N \\text{ (but } \\hat{S}_{N,k}=0 \\text{ anyway)}\n\\end{cases}\n$$\n滤波器参数给定为 $\\alpha=36$ 和 $p=8$。然后，通过对 $\\{\\hat{S}_{N,k}^{\\mathrm{filt}}\\}$ 应用 IDFT 来恢复其空间表示 $S_N^{\\mathrm{filt}}(\\theta_j)$。对于 $N=0$ 的特殊情况，滤波条件 $1 \\le |k| \\le N$ 永远不会满足，因此没有模式会被滤波器因子修改。\n\n第四，我们量化两种近似的性能。对每个 $N$ 值计算两个指标：\n1. 过冲幅度，定义为重构信号的最大值减去函数的真实最大值（$1$），并从下方以零截断以确保结果为非负：\n   $$ \\text{Overshoot} = \\max\\left(0, \\left(\\max_j S(\\theta_j)\\right) - 1\\right) $$\n2. 均方根 (RMS) 误差，它衡量了整个网格上与真实函数的平均偏差：\n   $$ \\text{RMS Error} = \\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S(\\theta_j) - f(\\theta_j)\\right)^2} $$\n这两个指标分别对未滤波和 $S_N(\\theta_j)$ 和滤波和 $S_N^{\\mathrm{filt}}(\\theta_j)$ 进行计算。\n\n该算法通过迭代指定的 $N$ 值，执行这些计算，并收集结果以用于最终的格式化输出。数据将表明，虽然未滤波的和表现出显著且持续的过冲（吉布斯现象），但谱滤波器有效地抑制了这些振荡，从而导致过冲幅度大大减小。然而，这种在减少局部误差方面的改进，可能会以全局误差（通过 RMS 值衡量）的轻微增加为代价。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes unfiltered and filtered Fourier partial sums for a square wave\n    to analyze the Gibbs phenomenon and the effect of a spectral filter.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    M = 4096\n    alpha = 36\n    p = 8\n    test_cases = [0, 1, 8, 32, 128, 512] # These are the values for N\n\n    # --- Main Logic ---\n\n    # Step 1: Sample the function f(theta)\n    # The function is f(theta) = 1 for 0 = theta  pi and f(theta) = -1 for pi = theta  2pi.\n    # On a grid of M points theta_j = 2*pi*j/M, this corresponds to\n    # f_j = 1 for j=0..M/2-1 and f_j = -1 for j=M/2..M-1.\n    f_samples = np.ones(M)\n    f_samples[M // 2:] = -1.0\n\n    # Step 2: Compute the DFT of the sampled signal\n    f_hat = np.fft.fft(f_samples)\n    # Get the corresponding integer frequency modes k for the DFT output array.\n    # np.fft.fftfreq(M) * M gives [0, 1, ..., M/2-1, -M/2, ..., -1]\n    k_freqs = np.fft.fftfreq(M) * M\n\n    # Store results for each N\n    results_unfiltered_overshoot = []\n    results_filtered_overshoot = []\n    results_unfiltered_rms = []\n    results_filtered_rms = []\n\n    for N in test_cases:\n        # Construct unfiltered partial sum S_N by truncating the spectrum\n        S_N_hat = f_hat.copy()\n        # Zero out coefficients for frequencies with magnitude > N\n        S_N_hat[np.abs(k_freqs) > N] = 0.0\n        \n        # Reconstruct S_N via inverse FFT\n        # The result should be real-valued; .real discards negligible imaginary parts from numerical error.\n        S_N = np.fft.ifft(S_N_hat).real\n\n        # Construct filtered partial sum S_N_filt\n        S_N_filt_hat = S_N_hat.copy() # Start with the same truncated spectrum\n        if N > 0:\n            # Create a mask for modes to be filtered (1 = |k| = N)\n            filter_mask = (np.abs(k_freqs) > 0)  (np.abs(k_freqs) = N)\n            \n            # Get the k values of the modes to be filtered\n            k_vals_to_filter = np.abs(k_freqs[filter_mask])\n            \n            # Calculate the exponential filter factors\n            sigma_k = np.exp(-alpha * (k_vals_to_filter / N)**p)\n            \n            # Apply the filter by element-wise multiplication\n            S_N_filt_hat[filter_mask] *= sigma_k\n        \n        # Reconstruct S_N_filt via inverse FFT\n        S_N_filt = np.fft.ifft(S_N_filt_hat).real\n\n        # Quantify overshoot and RMS error for both cases\n        # For S_N (unfiltered)\n        overshoot_unfiltered = np.maximum(0.0, np.max(S_N) - 1.0)\n        rms_unfiltered = np.sqrt(np.mean((S_N - f_samples)**2))\n        \n        # For S_N_filt (filtered)\n        overshoot_filtered = np.maximum(0.0, np.max(S_N_filt) - 1.0)\n        rms_filtered = np.sqrt(np.mean((S_N_filt - f_samples)**2))\n\n        # Append results to lists\n        results_unfiltered_overshoot.append(overshoot_unfiltered)\n        results_filtered_overshoot.append(overshoot_filtered)\n        results_unfiltered_rms.append(rms_unfiltered)\n        results_filtered_rms.append(rms_filtered)\n\n    # Final print statement in the exact required format.\n    all_results = [\n        test_cases,\n        results_unfiltered_overshoot,\n        results_filtered_overshoot,\n        results_unfiltered_rms,\n        results_filtered_rms\n    ]\n    \n    # Convert each inner list of numbers into a comma-separated string, enclosed in brackets.\n    stringified_lists = [f\"[{','.join(map(str, lst))}]\" for lst in all_results]\n    \n    # Join these stringified lists into the final output format: [[list1],[list2],...]\n    print(f\"[{','.join(stringified_lists)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在数字信号处理中，改变信号的采样率是一项常见任务，而降采样是其中关键一环。本实践 () 聚焦于一个核心问题：为防止在降采样过程中出现频谱失真（即混叠），必须使用抗混叠滤波器。您将亲自实现这一过程，并定量地验证所施加的滤波是否足够，从而在实践中巩固对奈奎斯特-香农采样定理的理解。",
            "id": "3195872",
            "problem": "给定一个一维实值离散时间信号，其采样频率为 $F_{s}$ 赫兹 (Hz)。该信号有 $N$ 个在时间上均匀采集的样本，采样间隔为 $\\Delta t = 1 / F_{s}$ 秒，其时间样本为 $x[n]$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。$x[n]$ 的离散傅里叶变换 (DFT) 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi nk/N},\n$$\n其中离散频率点为 $f_{k} = k \\, F_{s}/N$，对于 $k \\in \\{0,1,\\dots,N-1\\}$，而快速傅里叶变换 (FFT) 是计算 DFT 的一种高效算法。Nyquist-Shannon 采样定理指出，对于采样频率 $F_{s}$，奈奎斯特频率为 $F_{s}/2$。\n\n任务是利用快速傅里叶变换 (FFT) 将频域滤波与降采样（抽取）相结合。具体来说，您必须：\n- 在频域中应用一个理想低通滤波器，将所有 $|f| > F_{s}/4$ 的频谱分量置零。\n- 将滤波后的时域信号以因子 $4$ 进行降采样（即，每四个样本保留一个），以获得采样频率为 $F_{s}' = F_{s}/4$ 的新信号。\n- 使用降采样前滤波后信号的频谱，验证滤波后剩余的频谱内容完全位于新的奈奎斯特频带 $|f| \\leq F_{s}'/2 = F_{s}/8$ 内。验证必须基于一个量化标准：\n  - 计算比率 $R$，定义如下\n    $$\n    R = \\frac{\\sum_{k \\, : \\, |f_{k}| > F_{s}/8} |X_{\\text{filt}}[k]|}{\\sum_{k=0}^{N-1} |X_{\\text{filt}}[k]|},\n    $$\n    其中 $X_{\\text{filt}}[k]$ 是滤波后信号的 DFT。如果 $R \\leq 10^{-6}$，则将验证布尔值声明为 $\\text{True}$，否则为 $\\text{False}$。该标准确保新奈奎斯特频带外的任何残余能量都可以忽略不计。比率 $R$ 是无量纲的。\n\n所有角度计算均使用弧度。所有频率必须以赫兹 (Hz) 为单位指定。假设所有正弦分量均为零相位。\n\n使用以下信号测试套件实现上述操作，所有信号均以 $F_{s} = 1024$ Hz 的频率采样，包含 $N = 2048$ 个样本：\n- 测试用例 1 (正常路径)：频率分别为 $50$ Hz 和 $100$ Hz、振幅分别为 $1.0$ 和 $0.5$ 的正弦波之和。此用例的内容严格低于 $F_{s}/8 = 128$ Hz。\n- 测试用例 2 (失败用例)：频率为 $200$ Hz、振幅为 $1.0$ 的单个正弦波。此内容位于 $F_{s}/8 = 128$ Hz 和 $F_{s}/4 = 256$ Hz 之间，将通过滤波器，但不应满足验证标准。\n- 测试用例 3 (边界用例)：频率恰好为 $F_{s}/8 = 128$ Hz、振幅为 $1.0$ 的单个正弦波。将 $|f| \\leq F_{s}/8$ 视为可接受的；此用例应满足验证标准。\n- 测试用例 4 (混合内容)：频率分别为 $60$ Hz、 $140$ Hz 和 $220$ Hz、振幅均为 $0.8$ 的正弦波之和。只有 $60$ Hz 分量严格低于 $F_{s}/8$；其他分量将通过 $F_{s}/4$ 滤波器，并应导致验证失败。\n\n您的程序必须：\n- 为每个测试用例构建指定的信号 $x[n] = \\sum_{m} A_{m} \\sin(2\\pi f_{m} n / F_{s})$，其中 $A_{m}$ 是振幅，$f_{m}$ 是频率。\n- 计算 FFT，应用截止频率为 $F_{s}/4$ 的理想频域低通滤波器，将 FFT 逆变换回时域，然后按 $4$ 进行抽取。\n- 根据滤波后的频谱 $X_{\\text{filt}}[k]$ 计算验证比率 $R$，并为每个测试用例返回上述布尔值。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[True,False,True,False]”），其中每个结果是对应测试用例验证的布尔值 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "用户提供的问题被评估为 **有效**。它在科学上是合理的、定义明确的，并且为获得唯一解提供了所有必要信息。\n\n### 物理原理简介\n\n这个问题探讨了数字信号处理 (DSP) 中的一个基本概念：**抽取** (decimation) 或降采样 (downsampling)，及其与 **Nyquist-Shannon 采样定理** 的关系。当一个以频率 $F_s$ 采样的离散时间信号 $x[n]$ 被一个整数因子 $M$ 降采样时，新的采样率变为 $F_s' = F_s/M$。根据采样定理，为避免**混叠**（aliasing）——即高频被错误地表示为低频——信号必须不含任何高于新奈奎斯特频率 $F_s'/2 = F_s/(2M)$ 的频率内容。\n\n因此，抽取的一个关键先决条件是应用**抗混叠滤波器**，这是一种低通滤波器，旨在降采样操作发生前去除所有频率 $|f| > F_s/(2M)$ 的分量。\n\n本问题设置了一个场景来测试这一原理。一个信号将按因子 $M=4$ 进行降采样。因此，所需的抗混叠滤波器应具有 $F_s/(2 \\times 4) = F_s/8$ 的截止频率。然而，问题指定使用一个具有更高截止频率 $F_s/4$ 的理想低通滤波器。这个滤波器不足以保证防止混叠。任务是*验证*信号内容在通过这个次优滤波器后，是否恰好位于无混叠抽样的可接受频带内，即 $|f| \\leq F_s/8$。\n\n问题陈述中存在一个微小的歧义，其指定了“零相位”，但提供了使用 $\\sin(x)$ 的信号生成公式，这对应于相对于 $\\cos(x)$ 的 $-\\pi/2$ 相位。这是一个可以忽略不计的不一致之处，因为所提供的公式 $x[n] = \\sum_{m} A_{m} \\sin(2\\pi f_{m} n / F_{s})$ 是明确的，并应以此为准。此外，分析仅依赖于幅度谱 $|X[k]|$，它不受此恒定相移的影响。\n\n### 算法解决方案\n\n解决方案通过为一套四个测试用例实现指定的信号处理链和验证测试来进行。通用参数为采样频率 $F_s = 1024$ Hz 和信号长度 $N = 2048$ 个样本。\n\n1.  **信号生成**：对于每个测试用例，根据公式合成离散时间信号 $x[n]$（$n \\in \\{0, 1, \\dots, N-1\\}$）：\n    $$\n    x[n] = \\sum_{m} A_{m} \\sin(2\\pi f_{m} n / F_{s})\n    $$\n    其中 $\\{A_m, f_m\\}$ 是给定的振幅和频率。\n\n2.  **频谱分析 (FFT)**：使用快速傅里叶变换 (FFT) 算法计算信号的离散傅里叶变换 (DFT) $X[k]$。这将信号转换到频域。每个点 $k$ 对应的频率由 $f_k$ 给出。这些频率被排列以表示正负频谱分量，通常由像 `numpy.fft.fftfreq` 这样的函数处理。\n\n3.  **频域滤波**：理想低通滤波器直接在频域中应用。这是通过创建一个频谱掩码来实现的，对于所有超过滤波器截止频率 $F_{c} = F_s/4 = 256$ Hz 的频率 $|f_k|$，掩码为零，否则为一。滤波后的频谱 $X_{\\text{filt}}[k]$ 是通过将原始频谱 $X[k]$ 与此掩码进行逐元素相乘得到的：\n    $$\n    X_{\\text{filt}}[k] = \\begin{cases} X[k]   \\text{if } |f_k| \\leq F_s/4 \\\\ 0   \\text{if } |f_k| > F_s/4 \\end{cases}\n    $$\n\n4.  **频谱验证**：问题的核心是验证滤波后的信号是否适合以因子 $M=4$ 进行降采样。这要求其频谱内容被限制在新的奈奎斯特频带内，即 $|f| \\leq F_s' / 2 = F_s/8 = 128$ Hz。通过计算比率 $R$ 来执行验证：\n    $$\n    R = \\frac{\\sum_{k \\, : \\, |f_{k}| > F_{s}/8} |X_{\\text{filt}}[k]|}{\\sum_{k=0}^{N-1} |X_{\\text{filt}}[k]|}\n    $$\n    该比率测量了滤波后信号频谱幅度中位于目标频带（$|f| > 128$ Hz）之外的部分所占的比例。\n\n5.  **决策**：如果 $R$ 小于或等于数值容差 $10^{-6}$，则验证被声明为成功（$\\text{True}$），表示任何带外能量都可以忽略不计。否则，声明为失败（$\\text{False}$）。请注意，问题的概念步骤包括逆 FFT 和抽取，但计算 $R$ 值并不需要这些步骤，因为 $R$ 完全从滤波后的频谱 $X_{\\text{filt}}[k]$ 中导出。\n\n### 测试用例分析\n\n-   **测试用例 1 (正常路径)**：频率为 $50$ Hz 和 $100$ Hz。两者均小于 $128$ Hz 的验证截止频率和 $256$ Hz 的滤波器截止频率。滤波器会通过这些分量，并且由于它们在目标频带内，$R$ 的分子将近似为零（除数值精度误差外）。验证预计会通过（$\\text{True}$）。\n\n-   **测试用例 2 (失败用例)**：频率为 $200$ Hz。该频率大于 $128$ Hz 但小于 $256$ Hz。该分量将通过滤波器。然而，它位于目标验证频带之外。$R$ 的分子将包含此分量的幅度，使得 $R$ 值显著（接近 $1$）。验证预计会失败（$\\text{False}$）。\n\n-   **测试用例 3 (边界用例)**：频率恰好为 $128$ Hz。这等于验证截止频率 $F_s/8$，并小于滤波器截止频率 $F_s/4$。该分量通过滤波器。分子的验证条件是严格不等式 $|f_k| > 128$ Hz。由于信号能量恰好在 $128$ Hz，它不被包含在分子的总和中。因此，$R$ 将接近于零。验证预计会通过（$\\text{True}$）。\n\n-   **测试用例 4 (混合内容)**：频率为 $60$ Hz、 $140$ Hz 和 $220$ Hz。所有频率都低于 $256$ Hz 的滤波器截止频率，并将出现在 $X_{\\text{filt}}[k]$ 中。对于验证，$60$ Hz 分量在目标频带内（$|f| \\leq 128$ Hz），但 $140$ Hz 和 $220$ Hz 分量在带外。这些带外分量将贡献于 $R$ 的分子，使其占总幅度的一个重要部分（约 $2/3$）。验证预计会失败（$\\text{False}$）。\n\n实现将针对每个用例遵循此逻辑，以生成最终的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs frequency-domain filtering and spectral verification for a set of test signals.\n    \"\"\"\n    # Define the global parameters from the problem statement.\n    Fs = 1024.0  # Sampling frequency in Hz\n    N = 2048     # Number of samples\n\n    # Define the test cases. Each case is a list of tuples, where each tuple\n    # contains the amplitude (A_m) and frequency (f_m) of a sinusoidal component.\n    test_cases_params = [\n        # Test case 1 (happy path): Content below Fs/8\n        [(1.0, 50.0), (0.5, 100.0)],\n        # Test case 2 (failure case): Content between Fs/8 and Fs/4\n        [(1.0, 200.0)],\n        # Test case 3 (boundary case): Content at exactly Fs/8\n        [(1.0, 128.0)],\n        # Test case 4 (mixed content): Components both inside and outside the Fs/8 band\n        [(0.8, 60.0), (0.8, 140.0), (0.8, 220.0)]\n    ]\n\n    results = []\n\n    # Pre-calculate constants and arrays used in the loop.\n    n = np.arange(N)\n    freqs = np.fft.fftfreq(N, d=1/Fs)\n    \n    filter_cutoff = Fs / 4.0\n    verification_cutoff = Fs / 8.0\n    verification_threshold = 1e-6\n\n    # Process each test case.\n    for params in test_cases_params:\n        # 1. Construct the signal x[n]\n        x = np.zeros(N, dtype=np.float64)\n        for A, f in params:\n            x += A * np.sin(2 * np.pi * f * n / Fs)\n\n        # 2. Compute the FFT of the signal.\n        X = np.fft.fft(x)\n\n        # 3. Apply the ideal low-pass filter in the frequency domain.\n        # Create a copy to store the filtered spectrum.\n        X_filt = X.copy()\n        # Create a boolean mask for frequencies to be zeroed out.\n        filter_mask = np.abs(freqs) > filter_cutoff\n        # Apply the filter by setting the corresponding spectral components to zero.\n        X_filt[filter_mask] = 0.0\n\n        # 4. Perform the verification step.\n        # This step checks if the filtered signal is suitable for downsampling by 4.\n        \n        # Calculate the sum of magnitudes of components outside the new Nyquist band (|f| > Fs/8).\n        indices_outside = np.abs(freqs) > verification_cutoff\n        sum_outside = np.sum(np.abs(X_filt[indices_outside]))\n\n        # Calculate the total sum of magnitudes of all components in the filtered signal.\n        sum_total = np.sum(np.abs(X_filt))\n\n        # Calculate the ratio R. Handle the case of a zero-energy signal.\n        if sum_total == 0.0:\n            R = 0.0\n        else:\n            R = sum_outside / sum_total\n\n        # 5. Compare R to the threshold to get the boolean result.\n        verification_passed = (R = verification_threshold)\n        results.append(verification_passed)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean True/False to strings 'True'/'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们探索一个更高级的应用，它展示了FFT在信号重建中的强大能力。本练习 () 将探究当信号存在样本缺失时会发生什么，以及这种情况如何破坏其频谱。您将实现一个迭代算法，该算法利用信号在频谱上具有稀疏性的假设，来“修复”或填充缺失的数据点——这项技术是现代信号处理与压缩感知领域的核心思想之一。",
            "id": "3195883",
            "problem": "您的任务是分析离散时间信号中缺失样本的谱效应，然后使用一种基于快速傅里叶变换（FFT）的修复方法来减轻这些效应。请完全在离散时间域中进行操作，并使用定义明确的数学结构来表达所有步骤。使用离散傅里叶变换（DFT）的定义作为您的根本基础。\n\n从离散傅里叶变换（DFT）的基本定义开始：对于一个长度为 $N$ 的信号 $x[n]$，其 DFT 为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}, \\quad k = 0,1,\\dots,N-1.\n$$\n设 $m[n]$ 为一个取值为 $\\{0,1\\}$ 的二元采样掩码，其中 $m[n]=1$ 表示观测样本，$m[n]=0$ 表示缺失样本。观测信号为 $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$。DFT的卷积性质意味着时域中的乘法对应于频域中的循环卷积：如果 $M[k]$ 是 $m[n]$ 的 DFT，那么 $x_{\\mathrm{mask}}[n]$ 的频谱是 $X_{\\mathrm{mask}}[k] = (X * M)[k]$，这将能量重新分布到各个频率上，可能产生谱伪影。\n\n设计并实现一个程序，对下面指定的每个测试用例执行以下步骤：\n\n1. 构造一个长度为 $N$ 的合成实值信号 $x[n]$，作为具有整数频率仓的余弦和：\n   $$\n   x[n] = \\sum_{i=1}^{K} A_i \\cos\\!\\left( \\frac{2\\pi f_i n}{N} \\right), \\quad n = 0,1,\\dots,N-1,\n   $$\n   其中 $K$ 是音调的数量，$A_i$ 是幅度，$f_i$ 是满足 $0  f_i  \\frac{N}{2}$ 的不同整数频率仓。\n\n2. 使用指定的随机种子以保证可复现性，随机选择比例为 $p_{\\mathrm{miss}}$ 的索引设为缺失（$m[n]=0$）。通过对缺失样本进行补零来形成 $x_{\\mathrm{mask}}[n]$，即如果 $m[n]=1$，则 $x_{\\mathrm{mask}}[n] = x[n]$；如果 $m[n]=0$，则 $x_{\\mathrm{mask}}[n]=0$。\n\n3. 使用快速傅里叶变换（FFT）计算 $x_{\\mathrm{mask}}[n]$ 的 DFT $X_{\\mathrm{mask}}[k]$。将真实谱支撑集 $\\mathcal{S}$ 定义为与已知音调频率及其对于实信号的对称对应部分相对应的频率仓集合：\n   $$\n   \\mathcal{S} = \\{ f_1, f_2, \\dots, f_K \\} \\cup \\{ (-f_1) \\bmod N, \\dots, (-f_K) \\bmod N \\}.\n   $$\n   计算修复前的伪影能量比\n   $$\n   r_{\\mathrm{zero}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{mask}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{mask}}[k]|^2},\n   $$\n   约定如果分母为0，则该比率为 $0$。\n\n4. 通过迭代FFT阈值处理执行谱修复：\n   - 初始化 $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$。\n   - 在每次迭代 $t = 0,1,2,\\dots$ 中：\n     - 计算 $Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$。\n     - 通过保留 $K_{\\mathrm{keep}}$ 个幅度最大的系数并将其余系数置零，在频域中进行硬阈值处理，产生 $\\tilde{Y}^{(t)}[k]$。\n     - 计算逆DFT $\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$，取其实部，并在观测样本上强制执行数据一致性：\n       $$\n       y^{(t+1)}[n] = \\begin{cases}\n       x[n]   \\text{if } m[n]=1, \\\\\n       \\tilde{y}^{(t)}[n]   \\text{if } m[n]=0.\n       \\end{cases}\n       $$\n     - 当相对变化 $\\frac{\\|y^{(t+1)} - y^{(t)}\\|_2}{\\|y^{(t)}\\|_2}$ 小于容差 $\\varepsilon$，或达到最大迭代次数 $T_{\\max}$ 时停止。\n\n5. 计算最终修复信号 $y^{(\\ast)}[n]$ 的 DFT $X_{\\mathrm{rec}}[k]$ 和相应的伪影能量比\n   $$\n   r_{\\mathrm{inpaint}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{rec}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{rec}}[k]|^2},\n   $$\n   约定同上。同时计算归一化重建误差\n   $$\n   e = \\frac{\\|y^{(\\ast)} - x\\|_2}{\\|x\\|_2}。\n   $$\n\n您的实现必须使用下面指定的测试套件。对于每个测试用例，返回一个包含三个浮点数的列表 $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$，四舍五入到 $6$ 位小数。程序的最终输出必须是单行，包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，其中每个元素本身是对应测试用例的三个浮点数的列表，例如 $[[a_1,b_1,c_1],[a_2,b_2,c_2]]$。\n\n测试套件：\n- 案例 $1$ (正常路径): $N=1024$, $K=3$, 频率 $[50, 123, 300]$, 幅度 $[1.0, 0.8, 0.6]$, 缺失比例 $p_{\\mathrm{miss}}=0.2$, $K_{\\mathrm{keep}}=6$, 容差 $\\varepsilon=10^{-8}$, 最大迭代次数 $T_{\\max}=200$, 随机种子 $1$。\n- 案例 $2$ (边界情况，无缺失样本): $N=1024$, $K=3$, 频率 $[50, 123, 300]$, 幅度 $[1.0, 0.8, 0.6]$, 缺失比例 $p_{\\mathrm{miss}}=0.0$, $K_{\\mathrm{keep}}=6$, 容差 $\\varepsilon=10^{-8}$, 最大迭代次数 $T_{\\max}=200$, 随机种子 $2$。\n- 案例 $3$ (边缘情况，大量缺失): $N=2048$, $K=5$, 频率 $[15, 77, 221, 400, 650]$, 幅度 $[1.0, 0.5, 0.7, 0.9, 0.4]$, 缺失比例 $p_{\\mathrm{miss}}=0.5$, $K_{\\mathrm{keep}}=10$, 容差 $\\varepsilon=10^{-8}$, 最大迭代次数 $T_{\\max}=300$, 随机种子 $3$。\n- 案例 $4$ (边缘情况，单音调和严重缺失): $N=512$, $K=1$, 频率 $[64]$, 幅度 $[1.0]$, 缺失比例 $p_{\\mathrm{miss}}=0.7$, $K_{\\mathrm{keep}}=2$, 容差 $\\varepsilon=10^{-8}$, 最大迭代次数 $T_{\\max}=300$, 随机种子 $42$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，其中每个元素是对应一个测试用例的列表 $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$，每个浮点数四舍五入到 $6$ 位小数，例如：\n$[[0.123456,0.000789,0.012345],[\\dots],[\\dots],[\\dots]]$。",
            "solution": "用户提供的问题陈述已经过仔细验证，被确定为合理、适定且有科学依据。它提出了一个计算信号处理中的明确任务，具体来说是使用迭代谱方法从不完整的测量中恢复稀疏信号。所有参数、定义和过程都以足够的严谨性进行了规定，从而能够得出一个唯一且可验证的解。\n\n解决方案通过实现所述算法来推进。问题的核心在于认识到由少数几个正弦波组成的信号在频域中具有稀疏表示。通过快速傅里叶变换（FFT）高效计算的离散傅里叶变换（DFT）是在时域和频域之间转换的工具。\n\n初始信号 $x[n]$ 被构造为 $K$ 个余弦函数之和，其频率 $f_i$ 是基频 $1/N$ 的整数倍。这确保了信号在频域中的能量完全集中在与 $\\pm f_i$ 对应的DFT频率仓上。由于共轭对称性质 $X[k] = X[N-k]^*$，这个实值信号的DFT $X[k]$ 将有 $2K$ 个非零系数。这些非零频率仓的集合表示为 $\\mathcal{S}$。\n\n当样本缺失时，通过将信号 $x[n]$ 与一个二元掩码 $m[n]$ 相乘来建模，得到的信号是 $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$。根据DFT的卷积定理，时域中的这种乘法对应于频域中的循环卷积：$X_{\\mathrm{mask}}[k] = (X * M)[k]$，其中 $M[k]$ 是掩码的DFT。掩码的频谱 $M[k]$ 通常不稀疏，并且在所有频率上都具有显著能量。卷积将 $X[k]$ 的稀疏能量扩散到整个频谱上，从而产生伪影。初始伪影能量比 $r_{\\mathrm{zero}}$ 量化了这种谱泄漏。\n\n解决方案的核心是迭代修复算法，它是迭代硬阈值（IHT）算法的一个变体。该算法利用了原始信号在频域中是稀疏的这一先验知识。过程如下：\n\n1.  **初始化**：算法从补零信号 $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$ 开始。\n\n2.  **迭代**：对于每一步 $t$：\n    a.  **转换到频域**：计算当前估计的DFT，$Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$。在此阶段，由于数据缺失，$Y^{(t)}[k]$ 通常不稀疏。\n    b.  **硬阈值处理**：该算法通过仅保留 $K_{\\mathrm{keep}}$ 个幅度最大的系数并将所有其他系数置零来强制执行稀疏性假设。$K_{\\mathrm{keep}}$ 设置为 $2K$，即原始信号中已知的非零谱分量的数量。这一步，$\\tilde{Y}^{(t)}[k] = \\mathrm{Threshold}(Y^{(t)}[k])$，是在频域中对稀疏信号集合的投影。\n    c.  **返回时域**：对经过阈值处理的频谱应用逆FFT，$\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$。由于数值误差可能会引入一个小的虚部，我们取结果的实部。\n    d.  **强制数据一致性**：这是一个关键步骤。解必须与已知测量值一致。下一个迭代 $y^{(t+1)}[n]$ 的值通过重新插入 $x[n]$ 中掩码 $m[n]$ 为 $1$ 的原始已知样本来更新。对于缺失的样本（其中 $m[n]=0$），我们使用稀疏估计 $\\tilde{y}^{(t)}[n]$ 的值。\n        $$\n        y^{(t+1)}[n] = m[n] \\cdot x[n] + (1 - m[n]) \\cdot \\tilde{y}^{(t)}[n]\n        $$\n\n3.  **终止**：重复该过程，直到解稳定（通过连续迭代之间的相对变化小于容差 $\\varepsilon = 10^{-8}$ 来衡量），或达到最大迭代次数 $T_{\\max}$。\n\n最后，评估重建的质量。修复后的伪影能量比 $r_{\\mathrm{inpaint}}$ 衡量了算法将谱能量重新集中回真实支撑集 $\\mathcal{S}$ 的成功程度。归一化重建误差 $e$ 衡量了重建信号 $y^{(\\ast)}[n]$ 和原始信号 $x[n]$ 之间的欧几里得距离，提供了时域准确度的直接度量。该实现使用 `NumPy` 进行高效的数组操作、FFT计算和线性代数范数计算。",
            "answer": "```python\nimport numpy as np\n\ndef run_case(N, K, freqs, amps, p_miss, K_keep, epsilon, T_max, seed):\n    \"\"\"\n    Runs a single test case for spectral inpainting.\n    \"\"\"\n    # Step 1: Construct the synthetic signal x[n]\n    n_space = np.arange(N)\n    x = np.zeros(N, dtype=np.float64)\n    for i in range(K):\n        x += amps[i] * np.cos(2 * np.pi * freqs[i] * n_space / N)\n\n    # Step 2: Create the masked signal x_mask[n]\n    rng = np.random.default_rng(seed)\n    num_missing = int(np.round(p_miss * N))\n    if num_missing > 0:\n        missing_indices = rng.choice(N, size=num_missing, replace=False)\n    else:\n        missing_indices = np.array([], dtype=int)\n        \n    m = np.ones(N)\n    m[missing_indices] = 0\n    x_mask = x * m\n\n    # Step 3: Compute artifact energy ratio before inpainting (r_zero)\n    X_mask = np.fft.fft(x_mask)\n    \n    # Define the true spectral support S\n    S = set(freqs) | set((N - f) % N for f in freqs)\n    \n    is_in_S = np.zeros(N, dtype=bool)\n    is_in_S[list(S)] = True\n    \n    total_energy_mask = np.sum(np.abs(X_mask)**2)\n    if total_energy_mask == 0:\n        r_zero = 0.0\n    else:\n        artifact_energy_mask = np.sum(np.abs(X_mask[~is_in_S])**2)\n        r_zero = artifact_energy_mask / total_energy_mask\n\n    # Step 4: Perform spectral inpainting via iterative FFT thresholding\n    y_current = x_mask.copy()\n    y_rec = y_current\n    \n    for _ in range(T_max):\n        Y_current = np.fft.fft(y_current)\n        \n        # Hard-threshold in the frequency domain\n        largest_indices = np.argsort(np.abs(Y_current))[-K_keep:]\n        Y_tilde = np.zeros_like(Y_current, dtype=complex)\n        Y_tilde[largest_indices] = Y_current[largest_indices]\n        \n        # Inverse transform and take real part\n        y_tilde_real = np.real(np.fft.ifft(Y_tilde))\n        \n        # Create next iterate\n        y_next = y_tilde_real.copy()\n        # Enforce data consistency on observed samples\n        y_next[m == 1] = x[m == 1]\n        \n        # Check for convergence\n        norm_y_current = np.linalg.norm(y_current)\n        if norm_y_current > 0:\n            relative_change = np.linalg.norm(y_next - y_current) / norm_y_current\n            if relative_change  epsilon:\n                y_rec = y_next\n                break\n        elif np.linalg.norm(y_next) == 0: # y_current is zero, check if y_next is also zero\n            y_rec = y_next\n            break\n        \n        y_current = y_next\n    else: # Loop finished without break\n        y_rec = y_current\n\n    # Step 5: Compute metrics for the inpainted signal (r_inpaint, e)\n    X_rec = np.fft.fft(y_rec)\n    \n    total_energy_rec = np.sum(np.abs(X_rec)**2)\n    if total_energy_rec == 0:\n        r_inpaint = 0.0\n    else:\n        artifact_energy_rec = np.sum(np.abs(X_rec[~is_in_S])**2)\n        r_inpaint = artifact_energy_rec / total_energy_rec\n        \n    norm_x = np.linalg.norm(x)\n    if norm_x == 0:\n        e = 0.0 if np.linalg.norm(y_rec) == 0 else np.inf\n    else:\n        e = np.linalg.norm(y_rec - x) / norm_x\n        \n    return [r_zero, r_inpaint, e]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.2, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 1},\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.0, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 2},\n        {'N': 2048, 'K': 5, 'freqs': [15, 77, 221, 400, 650], 'amps': [1.0, 0.5, 0.7, 0.9, 0.4], 'p_miss': 0.5, 'K_keep': 10, 'epsilon': 1e-8, 'T_max': 300, 'seed': 3},\n        {'N': 512, 'K': 1, 'freqs': [64], 'amps': [1.0], 'p_miss': 0.7, 'K_keep': 2, 'epsilon': 1e-8, 'T_max': 300, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            N=case['N'],\n            K=case['K'],\n            freqs=case['freqs'],\n            amps=case['amps'],\n            p_miss=case['p_miss'],\n            K_keep=case['K_keep'],\n            epsilon=case['epsilon'],\n            T_max=case['T_max'],\n            seed=case['seed']\n        )\n        results.append(result)\n\n    # Format the final output string as specified.\n    inner_strs = []\n    for res_list in results:\n        formatted_nums = [f'{v:.6f}' for v in res_list]\n        inner_strs.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(inner_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}