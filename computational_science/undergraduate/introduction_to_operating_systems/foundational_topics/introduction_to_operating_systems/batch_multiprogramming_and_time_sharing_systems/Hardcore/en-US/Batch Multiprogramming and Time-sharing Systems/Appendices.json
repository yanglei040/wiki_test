{
    "hands_on_practices": [
        {
            "introduction": "The journey from simple batch processing to modern multitasking begins with a fundamental question: why run multiple programs at once? This exercise provides the answer by exploring the core motivation for multiprogramming. Using a simple but powerful probabilistic model, you will derive the relationship between the number of concurrent processes and Central Processing Unit (CPU) utilization, giving you a quantitative understanding of how multiprogramming transforms idle time into productive work .",
            "id": "3623637",
            "problem": "A time-sharing, multiprogrammed operating system runs a fixed degree of multiprogramming of $n$ independent user programs. At any randomly chosen instant, each program is independently in an Input/Output (I/O) wait state with probability $p \\in (0,1)$ and is ready to compute with probability $1-p$. Assume the scheduler is ideal: whenever at least one program is ready, the Central Processing Unit (CPU) is immediately kept busy (no dispatch overheads or preemption delays). Use only basic probability principles (independence and complement events) as your starting point.\n\n(a) Let $U(n,p)$ denote the long-run CPU utilization, defined as the probability the CPU is busy at an arbitrary instant. Derive $U(n,p)$ in terms of $n$ and $p$ from first principles.\n\n(b) Using your expression, justify mathematically why increasing $n$ strictly improves $U(n,p)$ for fixed $p \\in (0,1)$, and why $U(n,p)$ approaches full utilization as $n$ grows large. Your justification must proceed from the definition you derived in part (a) and properties of probabilities of independent events.\n\n(c) For a given I/O-wait probability $p=0.7$, determine the smallest integer $n$ such that the utilization target $U(n,p) \\ge 0.99$ is achieved. Provide the exact inequality you solve and the steps to obtain $n$. The final answer must be a single integer. No rounding instruction is needed because the answer is an exact integer.",
            "solution": "The problem will be addressed by first validating its premises and then solving each part in sequence using fundamental principles of probability theory.\n\n(a) Derivation of CPU utilization $U(n,p)$.\n\nThe system consists of $n$ independent user programs. At any given instant, each program $i$ (where $i \\in \\{1, 2, \\dots, n\\}$) is in one of two states:\n1.  In an Input/Output (I/O) wait state, with probability $p$. Let this event be denoted by $W_i$. Thus, $P(W_i) = p$.\n2.  Ready to compute, with probability $1-p$. Let this event be denoted by $R_i$. Thus, $P(R_i) = 1-p$.\n\nThe problem states that the scheduler is ideal, meaning the Central Processing Unit (CPU) is busy if and only if at least one program is in the ready state. The CPU utilization, $U(n,p)$, is defined as the probability that the CPU is busy.\n\nIt is more direct to first calculate the probability of the complement event: the CPU is idle. The CPU is idle if and only if *all* $n$ programs are simultaneously in the I/O wait state. Let the event \"CPU is idle\" be denoted by $I_{CPU}$.\n$$ I_{CPU} \\iff W_1 \\cap W_2 \\cap \\dots \\cap W_n $$\nThe problem specifies that the programs are independent. Therefore, the probability of the intersection of these events is the product of their individual probabilities:\n$$ P(I_{CPU}) = P(W_1 \\cap W_2 \\cap \\dots \\cap W_n) = P(W_1) \\times P(W_2) \\times \\dots \\times P(W_n) $$\nSince $P(W_i) = p$ for all $i$, this becomes:\n$$ P(I_{CPU}) = \\prod_{i=1}^{n} P(W_i) = p \\times p \\times \\dots \\times p \\text{ ($n$ times)} = p^n $$\nThe event \"CPU is busy\" is the complement of the event \"CPU is idle\". Therefore, the CPU utilization $U(n,p)$ is:\n$$ U(n,p) = 1 - P(I_{CPU}) $$\nSubstituting the expression for $P(I_{CPU})$, we get the expression for CPU utilization from first principles:\n$$ U(n,p) = 1 - p^n $$\n\n(b) Mathematical justification for the behavior of $U(n,p)$.\n\nFirst, we will show that increasing the degree of multiprogramming $n$ strictly improves the CPU utilization $U(n,p)$ for a fixed $p \\in (0,1)$. This requires showing that $U(n+1, p) > U(n, p)$ for any integer $n \\ge 1$.\n\nFrom our derived expression:\n$$ U(n+1, p) = 1 - p^{n+1} $$\n$$ U(n, p) = 1 - p^n $$\nThe inequality $U(n+1, p) > U(n, p)$ is therefore equivalent to:\n$$ 1 - p^{n+1} > 1 - p^n $$\nSubtracting $1$ from both sides gives:\n$$ -p^{n+1} > -p^n $$\nMultiplying both sides by $-1$ reverses the inequality sign:\n$$ p^{n+1}  p^n $$\nSince $p \\in (0,1)$, $p$ is strictly positive, so we can divide both sides by $p^n$ without changing the direction of the inequality:\n$$ \\frac{p^{n+1}}{p^n}  \\frac{p^n}{p^n} $$\n$$ p  1 $$\nThis final inequality is true by the problem's definition that $p \\in (0,1)$. Thus, it is mathematically proven that $U(n,p)$ is a strictly increasing function of $n$.\n\nSecond, we will show that $U(n,p)$ approaches full utilization (i.e., $1$) as $n$ grows large. This requires evaluating the limit of $U(n,p)$ as $n \\to \\infty$.\n$$ \\lim_{n \\to \\infty} U(n,p) = \\lim_{n \\to \\infty} (1 - p^n) $$\nWe can write this as:\n$$ \\lim_{n \\to \\infty} 1 - \\lim_{n \\to \\infty} p^n $$\nFor any real number $p$ such that $|p|  1$, the limit of $p^n$ as $n \\to \\infty$ is $0$. The problem states $p \\in (0,1)$, which satisfies this condition.\n$$ \\lim_{n \\to \\infty} p^n = 0 $$\nTherefore, the limit of the utilization is:\n$$ \\lim_{n \\to \\infty} U(n,p) = 1 - 0 = 1 $$\nThis demonstrates that as the degree of multiprogramming becomes very large, the CPU utilization approaches $100\\%$.\n\n(c) Calculation of the minimum degree of multiprogramming $n$.\n\nWe are given the I/O-wait probability $p=0.7$ and a target utilization of at least $0.99$. We need to find the smallest integer $n$ such that $U(n, 0.7) \\ge 0.99$.\n\nThe inequality to solve is:\n$$ 1 - (0.7)^n \\ge 0.99 $$\nWe proceed to solve for $n$. First, isolate the term containing $n$:\n$$ -(0.7)^n \\ge 0.99 - 1 $$\n$$ -(0.7)^n \\ge -0.01 $$\nMultiply by $-1$ and reverse the inequality:\n$$ (0.7)^n \\le 0.01 $$\nTo solve for the exponent $n$, we apply the natural logarithm to both sides. Since the natural logarithm function, $\\ln(x)$, is strictly increasing for $x > 0$, the direction of the inequality is preserved.\n$$ \\ln((0.7)^n) \\le \\ln(0.01) $$\nUsing the logarithm power rule $\\ln(a^b) = b \\ln(a)$:\n$$ n \\ln(0.7) \\le \\ln(0.01) $$\nNow, we must divide by $\\ln(0.7)$. It is critical to note that since $0.7  1$, the value of $\\ln(0.7)$ is negative. Dividing an inequality by a negative number reverses the direction of the inequality sign.\n$$ n \\ge \\frac{\\ln(0.01)}{\\ln(0.7)} $$\nWe can compute the numerical value of the right-hand side:\n$$ \\ln(0.01) \\approx -4.60517 $$\n$$ \\ln(0.7) \\approx -0.35667 $$\n$$ n \\ge \\frac{-4.60517}{-0.35667} \\approx 12.911 $$\nSo, we must have $n \\ge 12.911$. Since the degree of multiprogramming $n$ must be an integer, the smallest integer value for $n$ that satisfies this condition is the next integer greater than $12.911$, which is $13$.\nTo verify:\nFor $n=12$, $U(12, 0.7) = 1 - (0.7)^{12} \\approx 1 - 0.01384 = 0.98616$, which is less than $0.99$.\nFor $n=13$, $U(13, 0.7) = 1 - (0.7)^{13} \\approx 1 - 0.009688 = 0.99031$, which is greater than or equal to $0.99$.\nTherefore, the smallest integer $n$ is $13$.",
            "answer": "$$\\boxed{13}$$"
        },
        {
            "introduction": "Once multiple processes are ready to run, the operating system's scheduler must decide the order of execution, a choice with profound performance implications. This practice uses a deliberately constructed workload to illustrate the \"convoy effect,\" a classic performance pitfall where short processes get stuck behind a long one in simple schedulers like First-Come, First-Served ($FCFS$). By comparing its performance to the preemptive Shortest Remaining Time ($SRT$) policy, you will see how intelligent scheduling can dramatically improve system efficiency and fairness .",
            "id": "3623594",
            "problem": "Consider a single-processor operating system that schedules processes using either First-Come, First-Served (FCFS) or Shortest Remaining Time (SRT). There is no context-switch overhead, the processor is non-idling, and each process consists of a single, non-blocking Central Processing Unit (CPU) burst with no input/output. The workload is deliberately constructed to trigger the convoy effect under $FCFS$: one long process $J_{0}$ arrives at time $t=0$ with a required CPU burst of $100$ milliseconds, and $10$ short processes $J_{1},J_{2},\\dots,J_{10}$ arrive at times $t=1,2,\\dots,10$ respectively, each requiring a CPU burst of $1$ millisecond.\n\nUse the following foundational definitions: the completion time $C_{i}$ of process $J_{i}$ is the time at which its CPU burst finishes, the arrival time is $A_{i}$, and the turnaround time is $T_{i}=C_{i}-A_{i}$. The mean turnaround time is the arithmetic mean of $T_{i}$ over all processes in the workload.\n\n(a) Under $FCFS$, determine the completion times for all processes and compute the mean turnaround time.\n\n(b) Under $SRT$, determine the completion times for all processes and compute the mean turnaround time. Assume that preemption occurs immediately when a process with a strictly shorter remaining time arrives, and that ties are broken in favor of the most recently arrived shorter job when a scheduling decision is made at the exact instant of its arrival.\n\n(c) Define the improvement factor as the ratio\n$$I=\\frac{\\text{mean turnaround time under }FCFS}{\\text{mean turnaround time under }SRT}.$$\nCompute $I$ for this workload. Express the final improvement factor as a pure number (dimensionless) and round your answer to four significant figures.",
            "solution": "The system has one long process $J_{0}$ with arrival $A_{0}=0$ and CPU burst $100$, and ten short processes $J_{k}$ with arrivals $A_{k}=k$ for $k\\in\\{1,2,\\dots,10\\}$ and CPU bursts $1$.\n\nWe begin from the definitions: completion time $C_{i}$ is when the process finishes its CPU burst, and turnaround time is $T_{i}=C_{i}-A_{i}$. The mean turnaround time is $\\frac{1}{n}\\sum_{i=0}^{10}T_{i}$, where $n=11$ is the total number of processes.\n\nPart (a): $FCFS$ is non-preemptive and schedules the earliest-arrived process at the head of the ready queue until it completes. Since $J_{0}$ arrives at $t=0$, it starts immediately and runs uninterrupted for $100$ milliseconds. Therefore,\n- $J_{0}$ runs from $t=0$ to $t=100$, so $C_{0}=100$ and $T_{0}=100-0=100$.\n\nAll short processes $J_{k}$ arrive during the interval $t\\in[1,10]$, but under $FCFS$ they cannot preempt $J_{0}$. They queue behind $J_{0}$ and are served in order of arrival once $J_{0}$ completes. After $t=100$, the processes $J_{1},J_{2},\\dots,J_{10}$ each require $1$ millisecond and are executed in arrival order. Thus, their completion times are\n- $J_{1}$: $C_{1}=100+1=101$, so $T_{1}=101-1=100$,\n- $J_{2}$: $C_{2}=102$, so $T_{2}=102-2=100$,\n- $\\dots$\n- $J_{10}$: $C_{10}=110$, so $T_{10}=110-10=100$.\n\nTherefore, every process has turnaround time $100$ under $FCFS$. The mean turnaround time under $FCFS$ is\n$$\\overline{T}_{\\text{FCFS}}=\\frac{1}{11}\\sum_{i=0}^{10}T_{i}=\\frac{1}{11}\\cdot 11\\cdot 100=100.$$\nThis exhibits the convoy effect: the single long process at the head causes all subsequent short processes to wait, inflating their turnaround times.\n\nPart (b): $SRT$ is preemptive and always runs the process with the shortest remaining time. At $t=0$, $J_{0}$ is the only ready process, so it starts. At $t=1$, $J_{1}$ arrives with remaining time $1$, which is strictly less than the remaining time of $J_{0}$, so $J_{0}$ is preempted and $J_{1}$ runs.\n\nWe trace the schedule:\n- From $t=0$ to $t=1$, $J_{0}$ runs for $1$ millisecond, leaving it with $99$ milliseconds remaining.\n- At $t=1$, $J_{1}$ arrives and runs from $t=1$ to $t=2$, finishing at $C_{1}=2$. Its turnaround time is $T_{1}=2-1=1$.\n- At $t=2$, $J_{2}$ arrives exactly when $J_{1}$ completes. By the stated tie-breaking rule, $J_{2}$ runs from $t=2$ to $t=3$, finishing at $C_{2}=3$. Its turnaround time is $T_{2}=3-2=1$.\n- This pattern continues: for each $k\\in\\{3,4,\\dots,10\\}$, $J_{k}$ arrives at $t=k$ and runs immediately for $1$ millisecond, finishing at $C_{k}=k+1$ with turnaround time $T_{k}=(k+1)-k=1$.\n\nDuring the intervals between arrivals, there is no slack because each short process finishes exactly at the next integer time when the next short process arrives, so $J_{0}$ does not make progress between $t=1$ and $t=11$. After $J_{10}$ completes at $t=11$, $J_{0}$ resumes with $99$ milliseconds remaining and runs uninterrupted to completion at $t=110$. Therefore,\n- $C_{0}=110$ and $T_{0}=110-0=110$.\n\nCollecting the turnaround times under $SRT$:\n- For $J_{0}$: $T_{0}=110$,\n- For each $J_{k}$ with $k\\in\\{1,2,\\dots,10\\}$: $T_{k}=1$.\n\nThe mean turnaround time under $SRT$ is\n$$\\overline{T}_{\\text{SRT}}=\\frac{1}{11}\\left(T_{0}+\\sum_{k=1}^{10}T_{k}\\right)=\\frac{1}{11}\\left(110+10\\cdot 1\\right)=\\frac{120}{11}.$$\n\nPart (c): The improvement factor is defined as\n$$I=\\frac{\\overline{T}_{\\text{FCFS}}}{\\overline{T}_{\\text{SRT}}}=\\frac{100}{120/11}=\\frac{100\\cdot 11}{120}=\\frac{1100}{120}=\\frac{11}{1.2}.$$\nNumerically, $\\frac{11}{1.2}=9.16\\overline{6}$. Rounding to four significant figures gives $I\\approx 9.167$.",
            "answer": "$$\\boxed{9.167}$$"
        },
        {
            "introduction": "For time-sharing systems, providing a responsive interactive experience is a primary design goal. This hands-on problem puts you in the shoes of an OS developer tuning a system for interactivity. You will analyze a Round-Robin ($RR$) scheduler and determine the maximum time quantum ($q$) that still guarantees a worst-case response time for an interactive task, even amidst competing background jobs. This exercise illuminates the critical trade-offs between the time quantum, context-switch overhead, and user-perceived performance in a real-world scenario .",
            "id": "3623608",
            "problem": "A time-sharing system uses a Round-Robin (RR) scheduler with a fixed time quantum $q$ and a non-overlapped context switch time $s$ per switch. There are $N$ background ready processes that will each require up to $c_i$ of Central Processing Unit (CPU) service before they either block for input/output or complete, where $i \\in \\{1,\\dots,N\\}$. A newly arrived interactive process generates an echo event that requires $e$ of CPU time to produce the character echo and then blocks. Assume that scheduling is strict RR over the ready queue, that the interactive process arrives at the worst possible time (i.e., it is appended to the tail of the ready queue behind all $N$ background processes), and that a context switch penalty $s$ is paid at every preemption or process completion, including the switch into the interactive process.\n\nFrom first principles of time-sharing and RR scheduling, determine the maximum quantum $q_{\\max}$ (in milliseconds) that still guarantees the worst-case echo response time $R_{\\text{echo}}$ (from the interactive processâ€™s arrival to completion of the echo) is no more than $100$ ms. Use the following parameters and process CPU demands:\n- $s = 1$ ms,\n- $N = 8$,\n- $e = 2$ ms,\n- $(c_1,\\dots,c_8) = (22,\\ 25,\\ 19,\\ 30,\\ 24,\\ 21,\\ 27,\\ 23)$ ms.\n\nExpress your final answer as a single numerical value for $q_{\\max}$ in milliseconds. Do not include units in your final answer. No rounding is required; provide the exact value.",
            "solution": "The echo response time, $R_{\\text{echo}}$, is the total time elapsed from the arrival of the interactive process to the completion of its $e$ ms of CPU work. To find the worst-case $R_{\\text{echo}}$, we assume the interactive process arrives to find all $N$ background processes in the ready queue. It is placed at the tail of the queue.\n\nThe response time is the sum of the time spent waiting for the CPU and the time spent executing on the CPU. The analysis depends on whether the required echo time $e$ is greater than the quantum $q$.\n\n**Case 1: $q \\ge e$**\n\nIn this case, the interactive process will complete its CPU burst of length $e$ in a single time slice and will not be preempted.\nThe response time $R_{\\text{echo}}$ consists of two parts:\n1.  The waiting time for the $N$ background processes that are ahead in the queue to receive their time slices.\n2.  The execution time $e$ of the interactive process itself.\n\nFor each of the $N$ background processes, the scheduler will run it for a duration of $\\min(c_i, q)$. After each process's time slice, a context switch of duration $s$ occurs. The total waiting time before the interactive process starts is the sum of these execution times and context switch times for all $N$ processes.\n\n$$T_{\\text{wait}} = \\sum_{i=1}^{N} \\left( \\min(c_i, q) + s \\right) = \\left( \\sum_{i=1}^{N} \\min(c_i, q) \\right) + Ns$$\n\nThe total response time is the waiting time plus the echo execution time $e$:\n$$R_{\\text{echo}}(q) = T_{\\text{wait}} + e = \\left( \\sum_{i=1}^{N} \\min(c_i, q) \\right) + Ns + e$$\n\nWe are given $e=2$ ms. The background process CPU times $c_i$ are all greater than or equal to $19$ ms. Thus, for any $q$ in the range $e \\le q \\le \\min(c_i)$, which is $2 \\le q \\le 19$, the term $\\min(c_i, q)$ simplifies to $q$ for all $i$.\n\nIn this range, the response time is:\n$$R_{\\text{echo}}(q) = \\left( \\sum_{i=1}^{N} q \\right) + Ns + e = Nq + Ns + e$$\n\nSubstituting the given values $N=8$, $s=1$ ms, and $e=2$ ms:\n$$R_{\\text{echo}}(q) = 8q + 8(1) + 2 = 8q + 10$$\n\nThe problem imposes the constraint $R_{\\text{echo}} \\le 100$ ms.\n$$8q + 10 \\le 100$$\n$$8q \\le 90$$\n$$q \\le \\frac{90}{8} = \\frac{45}{4} = 11.25 \\text{ ms}$$\n\nThis result $q \\le 11.25$ is consistent with the assumption for this case, which was $2 \\le q \\le 19$. Therefore, any quantum $q$ in the interval $[2, 11.25]$ is a valid solution. The maximum value in this range is $11.25$.\n\nIf we were to consider $q > 19$, the function $R_{\\text{echo}}(q)$ would continue to increase. For any $q > 11.25$, $R_{\\text{echo}}(q) = 8(11.25) + 10 + \\delta = 100 + \\delta$ where $\\delta > 0$, so $R_{\\text{echo}}(q) > 100$. For example, at $q=12$, $R_{\\text{echo}}(12)=8(12)+10=106 > 100$. Thus, no solution exists for $q > 11.25$.\n\n**Case 2: $q  e$**\n\nIn this case ($q  2$ ms), the interactive process will be preempted at least once before it can complete its $e=2$ ms of work. It will require $k = \\lceil e/q \\rceil = \\lceil 2/q \\rceil$ time slices.\n\nLet's analyze the response time. The function $R_{\\text{echo}}(q)$ is discontinuous at points where $k$ changes (i.e., where $q=e/m$ for integers $m \\ge 2$). For any interval $(\\frac{e}{m}, \\frac{e}{m-1}]$, $k=m$ is constant. Within such an interval, $R_{\\text{echo}}(q)$ is a monotonically increasing function of $q$.\n\nLet's analyze the interval $q \\in (1, 2)$. Here, $k=\\lceil 2/q \\rceil = 2$.\nThe response time calculation is as follows:\n1.  Initial wait for $N$ processes: $T_{\\text{wait},1} = \\sum_{i=1}^N(\\min(c_i, q) + s) = N(q+s)$.\n2.  First CPU burst for interactive process: duration $q$.\n3.  Context switch out: duration $s$.\n4.  Wait for $N$ processes again: duration $N(q+s)$.\n5.  Second (and final) CPU burst: duration $e-q = 2-q$.\n\nThe total response time is the sum of these durations:\n$$R_{\\text{echo}}(q) = N(q+s) + q + s + N(q+s) + (e-q)$$\n$$R_{\\text{echo}}(q) = (2N+1)(q+s) + e - q$$\nSubstituting $N=8, s=1, e=2$:\n$$R_{\\text{echo}}(q) = (17)(q+1) + 2 - q = 17q + 17 + 2 - q = 16q + 19$$\nThe constraint is $16q+19 \\le 100$, which gives $16q \\le 81$, or $q \\le 5.0625$. The intersection with the interval $q \\in (1, 2)$ is the entire interval $(1, 2)$.\n\nThe maximum value of $R_{\\text{echo}}(q)$ in this interval occurs as $q \\to 2^-$, which is $16(2)+19 = 51$ ms. Since $51  100$, all $q \\in (1, 2)$ are valid.\n\nWe can systematically analyze intervals for smaller $q$. In each interval $(\\frac{e}{m}, \\frac{e}{m-1}]$, the response time is an increasing function of $q$. The maximum response time within these intervals generally increases as $q$ decreases (i.e., as $m$ increases for $m \\ge 3$). However, these analyses will yield maximum values of $q$ strictly less than $2$.\n\nThe set of all valid quantum values $q$ is a union of disjoint intervals. We seek the global maximum $q$ over this entire set. From our analysis:\n- The interval $[2, 11.25]$ is part of the solution set.\n- The interval $(1, 2)$ is part of the solution set.\n- Intervals for smaller $q$ are also part of the solution set.\n\nThe union of all solution intervals is of the form $(q_{\\text{min}}, q_1] \\cup (q_1, q_2] \\cup \\dots \\cup (1, 2) \\cup [2, 11.25]$. The supremum (the least upper bound) of this set is $11.25$.\n\nTherefore, the maximum quantum $q_{\\max}$ that guarantees a worst-case echo response time of no more than $100$ ms is $11.25$ ms.",
            "answer": "$$\\boxed{11.25}$$"
        }
    ]
}