{
    "hands_on_practices": [
        {
            "introduction": "理解中断延迟对于构建实时和高性能系统至关重要。本练习将挑战您超越理论，通过编写一个模拟程序来量化中断延迟。通过对中断禁用周期和微架构开销等因素进行建模，您将对中断响应延迟的来源获得定量的认识，从而深化对操作系统底层性能的理解 。",
            "id": "3640054",
            "problem": "设计并实现一个完整的、可运行的程序，该程序在一个简化的处理器模型中通过对中断处理程序的入口点和出口点进行插桩来模拟中断延迟的测量。你的程序应该为一组测试用例计算测量到的延迟，并报告每个用例的最坏情况延迟。其目标是根据操作系统中异常和陷阱处理的第一性原理进行推理，并产生可量化的输出。\n\n需要假设的基本和核心定义如下：\n- 中断是一个异步事件，它使处理器转向执行一个中断服务程序 (ISR)。中断延迟定义为从中断请求被触发的瞬间到 ISR 序言的第一条指令实际执行之间所经过的时间。\n- 当中断被屏蔽 (禁用) 时，中断请求会被延迟。因此，ISR 必须等到处理器到达一个中断被启用的点才能开始执行。\n- 在响应一个中断时，存在用于向量化和上下文保存的固定的微架构开销。我们将此开销建模为四个组成部分的恒定总和：向量化延迟、序言上下文保存时间、流水线刷新时间，以及缓存或转译后备缓冲器 (TLB) 冷未命中惩罚。\n- 更高优先级的陷阱或中断可以阻止较低优先级的中断启动。在下面的简化模型中，任何正在服务中的更高优先级陷阱都会阻止目标 ISR 启动，其效果等同于为该 ISR 禁用了中断。\n\n简化的仿真模型：\n- 时间以周期为单位进行测量，你必须将所有时间表示为整数个周期。\n- 处理器时间线表示为一系列连续的段。每个段都有一个类型和持续时间。类型包括：\n  - EN (中断启用)：目标中断在到达时可以立即被分派。\n  - DI (中断禁用)：目标中断不能被分派；它必须等到该段以及任何后续的非 EN 段结束。\n  - HI (更高优先级的处理程序正在服务中)：目标中断不能被分派；它必须等到该段以及任何后续的非 EN 段结束。\n- 设段由 $i \\in \\{1,\\dots,N\\}$ 索引，其持续时间为 $L_i$ 个周期，类型为 $T_i \\in \\{\\mathrm{EN}, \\mathrm{DI}, \\mathrm{HI}\\}$。总时间线长度为 $S = \\sum_{i=1}^{N} L_i$ 个周期。在每个段内，时间被建模为半开区间，因此一个跨越 $[a,b)$ 的段包含其起始点 $a$ 但不包含其结束点 $b$。\n- 设一个中断在时间 $t$（从调度开始计算的周期数）到达。定义合格性函数 $f(t)$，如果在时间 $t$ 处理器当前处于类型为 $\\mathrm{EN}$ 的段中，则 $f(t)$ 为 $1$，否则为 $0$。定义最早合格时间 $e(t)$，如果 $f(t)=1$，则为 $t$，否则为严格大于或等于 $t$ 的、下一个类型为 $\\mathrm{EN}$ 的段开始的最小边界时间。插桩的处理程序入口被建模为在 $e(t) + O$ 时刻发生，其中 $O$ 是四个非负开销组件的总和：\n  - 向量化延迟 $V$，\n  - 序言上下文保存时间 $P$，\n  - 流水线刷新时间 $F$，\n  - 缓存或转译后备缓冲器 (TLB) 惩罚 $C$。\n  因此，测量的中断延迟为\n  $$L(t) = \\left(e(t) - t\\right) + O,$$\n  其中 $O = V + P + F + C$。\n- 你的程序必须为指定的到达时间计算 $L(t)$，并为每个测试用例生成其所有到达时间中的最大测量延迟，即\n  $$L_{\\max} = \\max_{t \\in \\mathcal{A}} L(t),$$\n  其中 $\\mathcal{A}$ 是该用例的有限到达时间集合。\n- 插桩要求：概念上，该模型对到达时间 $t$ 和处理程序入口时间 $e(t)$ 进行插桩以计算 $L(t)$。尽管计算延迟不需要处理程序的退出时间，但假定它在 $e(t)+H$ 时刻被插桩，其中 $H \\ge 0$ 个周期是某个处理程序的运行时间；$H$ 的值与延迟无关，因此不需要作为输入。\n\n你的实现规则：\n- 你必须在一个不需要任何输入的单一程序中精确地实现上述模型。\n- 对于下面的每个测试用例，使用该模型计算所有到达时间的延迟，然后返回每个测试用例的最坏情况延迟。\n\n需要实现的测试套件：\n- 用例 1 (正常路径)：段 $[\\mathrm{EN}, \\mathrm{DI}, \\mathrm{EN}]$，持续时间为 $[100, 30, 70]$ 个周期；向量化 $V=12$，序言 $P=18$，刷新 $F=10$，缓存惩罚 $C=5$，因此 $O=V+P+F+C$。到达时间 $\\mathcal{A}=\\{0, 50, 110, 150, 199\\}$ 个周期。\n- 用例 2 (长屏蔽窗口边界)：段 $[\\mathrm{EN}, \\mathrm{DI}, \\mathrm{EN}]$，持续时间为 $[10, 200, 20]$ 个周期；$V=8$, $P=7$, $F=3$, $C=2$。到达时间 $\\mathcal{A}=\\{0, 5, 10, 50, 209\\}$ 个周期。\n- 用例 3 (更高优先级处理程序阻塞)：段 $[\\mathrm{EN}, \\mathrm{HI}, \\mathrm{EN}]$，持续时间为 $[50, 80, 40]$ 个周期；$V=5$, $P=6$, $F=2$, $C=2$。到达时间 $\\mathcal{A}=\\{0, 25, 50, 60, 129, 149\\}$ 个周期。\n- 用例 4 (最小开销，始终启用)：段 $[\\mathrm{EN}]$，持续时间为 $[100]$ 个周期；$V=0$, $P=0$, $F=0$, $C=0$。到达时间 $\\mathcal{A}=\\{0, 99\\}$ 个周期。\n\n要求的最终输出格式：\n- 你的程序应产生单行输出，其中包含四个测试用例的最坏情况延迟，格式为方括号括起来的逗号分隔的整数列表，按用例 $1$ 到 $4$ 的顺序排列（例如 $[l_1,l_2,l_3,l_4]$）。所有时间都必须是以周期为单位的整数。",
            "solution": "在尝试解决方案之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n\n**基本定义：**\n-   **中断延迟**：从中断请求在时间 $t$ 被触发到中断服务程序 (ISR) 序言的第一条指令实际执行之间所经过的时间。\n-   **中断屏蔽**：当中断被屏蔽 (禁用) 时，请求会被延迟，直到中断被启用。\n-   **处理器时间线**：一系列连续的段，由 $i \\in \\{1,\\dots,N\\}$ 索引。每个段 $i$ 都有一个持续时间 $L_i$（以周期为单位）和一个类型 $T_i \\in \\{\\mathrm{EN}, \\mathrm{DI}, \\mathrm{HI}\\}$。\n    -   $\\mathrm{EN}$：中断启用。\n    -   $\\mathrm{DI}$：中断禁用。\n    -   $\\mathrm{HI}$：一个更高优先级的处理程序正在服务中 (等同于 $\\mathrm{DI}$)。\n-   **段区间**：一个段跨越一个半开区间 $[a,b)$，包含 $a$ 但不包含 $b$。\n-   **合格性函数 $f(t)$**：如果在时间 $t$ 处理器处于一个 $\\mathrm{EN}$ 段中，则 $f(t)=1$；否则 $f(t)=0$。\n-   **最早合格时间 $e(t)$**：如果 $f(t)=1$，那么 $e(t) = t$。否则，$e(t)$ 是严格大于或等于 $t$ 的、下一个 $\\mathrm{EN}$ 段开始的最小边界时间。\n-   **微架构开销 $O$**：一个固定的常数，是四个非负组件的总和：\n    -   向量化延迟 $V$。\n    -   序言上下文保存时间 $P$。\n    -   流水线刷新时间 $F$。\n    -   缓存或转译后备缓冲器 (TLB) 惩罚 $C$。\n    -   $O = V + P + F + C$。\n-   **测量的中断延迟公式**：$L(t) = (e(t) - t) + O$。\n-   **目标**：对于每个测试用例，计算最大测量延迟 $L_{\\max} = \\max_{t \\in \\mathcal{A}} L(t)$，其中 $\\mathcal{A}$ 是给定的到达时间集合。\n\n**测试套件数据：**\n-   **用例 1**：\n    -   段：$[\\mathrm{EN}, \\mathrm{DI}, \\mathrm{EN}]$，持续时间为 $[100, 30, 70]$ 个周期。\n    -   开销：$V=12$, $P=18$, $F=10$, $C=5$。\n    -   到达时间 $\\mathcal{A}$：$\\{0, 50, 110, 150, 199\\}$ 个周期。\n-   **用例 2**：\n    -   段：$[\\mathrm{EN}, \\mathrm{DI}, \\mathrm{EN}]$，持续时间为 $[10, 200, 20]$ 个周期。\n    -   开销：$V=8$, $P=7$, $F=3$, $C=2$。\n    -   到达时间 $\\mathcal{A}$：$\\{0, 5, 10, 50, 209\\}$ 个周期。\n-   **用例 3**：\n    -   段：$[\\mathrm{EN}, \\mathrm{HI}, \\mathrm{EN}]$，持续时间为 $[50, 80, 40]$ 个周期。\n    -   开销：$V=5$, $P=6$, $F=2$, $C=2$。\n    -   到达时间 $\\mathcal{A}$：$\\{0, 25, 50, 60, 129, 149\\}$ 个周期。\n-   **用例 4**：\n    -   段：$[\\mathrm{EN}]$，持续时间为 $[100]$ 个周期。\n    -   开销：$V=0$, $P=0$, $F=0$, $C=0$。\n    -   到达时间 $\\mathcal{A}$：$\\{0, 99\\}$ 个周期。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准分析问题陈述。\n\n-   **科学上成立**：该问题提出了一个简化但有效的关于计算机体系结构和操作系统中中断处理的抽象。诸如中断屏蔽、被更高优先级事件抢占以及微架构开销（$V, P, F, C$）等概念在该领域都是标准概念。该模型在科学上是合理的。\n-   **良构的**：该问题以数学精度进行了规定。所有输入（段类型、持续时间、开销、到达时间）都已明确提供。延迟函数 $L(t)$ 通过最早合格时间 $e(t)$ 被确定性地定义，而 $e(t)$ 本身也有明确的规定。这种结构保证了每个测试用例都有唯一且可计算的解。\n-   **客观的**：该问题以正式的、定量的语言陈述，没有主观性或歧义。\n\n该问题没有任何使其无效的缺陷。它在科学上是成立的、良构的、客观的、完整的、一致的并且计算上是可行的。这些定义是正式的，并允许直接实现。\n\n### 步骤 3：结论和行动\n\n问题陈述是**有效的**。将开发一个解决方案。\n\n### 解决方案推导\n\n目标是为四个测试用例中的每一个计算最大中断延迟 $L_{\\max}$。在时间 $t$ 到达的单个中断的延迟由 $L(t) = (e(t) - t) + O$ 给出。问题的核心是根据处理器的执行段时间线来确定最早合格时间 $e(t)$。\n\n首先，我们表示时间线。对于一组具有持续时间 $L_1, L_2, \\ldots, L_N$ 的 $N$ 个段，我们可以定义每个段的开始时间。设 $S_0 = 0$。段 $i$（对于 $i \\in \\{1, \\ldots, N\\}$）的开始时间是 $S_{i-1} = \\sum_{j=1}^{i-1} L_j$，其结束时间是 $S_i = \\sum_{j=1}^{i} L_j$。因此，段 $i$ 占据时间区间 $[S_{i-1}, S_i)$。\n\n对于任何给定的中断到达时间 $t$，我们必须首先确定哪个段 $k$ 包含此时间。这通过找到索引 $k$ 以使 $S_{k-1} \\le t  S_k$ 来完成。\n\n一旦确定了段 $k$ 及其类型 $T_k$，我们应用 $e(t)$ 的定义：\n1.  如果 $T_k = \\mathrm{EN}$（中断启用），处理器可以立即开始服务中断。因此，最早合格时间是到达时间本身：$e(t) = t$。\n2.  如果 $T_k = \\mathrm{DI}$ 或 $T_k = \\mathrm{HI}$（中断禁用或被抢占），处理器必须延迟中断。根据定义，$e(t)$ 是“严格大于或等于 $t$ 的、下一个类型为 $\\mathrm{EN}$ 的段开始的最小边界时间”。这需要从当前段 $k$ 向前搜索。我们必须找到第一个段 $j \\ge k$，使得 $T_j = \\mathrm{EN}$。该段的开始时间是 $S_{j-1}$。因此，$e(t) = S_{j-1}$。\n\n在确定 $e(t)$ 后，延迟计算为 $L(t) = (e(t) - t) + O$，其中总微架构开销 $O$ 是给定组件的总和：$O = V + P + F + C$。\n\n对于每个测试用例，此过程将对指定集合 $\\mathcal{A}$ 中的所有到达时间 $t$ 重复。计算出的延迟中的最大值即为该用例的结果，$L_{\\max} = \\max_{t \\in \\mathcal{A}} L(t)$。\n\n我们现在将此过程应用于每个测试用例。\n\n**用例 1**：\n-   段：$[\\mathrm{EN}, 100], [\\mathrm{DI}, 30], [\\mathrm{EN}, 70]$。\n-   时间线：$\\mathrm{EN}$ 在 $[0, 100)$ 上，$\\mathrm{DI}$ 在 $[100, 130)$ 上，$\\mathrm{EN}$ 在 $[130, 200)$ 上。\n-   开销：$O = 12 + 18 + 10 + 5 = 45$。\n-   到达时间 $\\mathcal{A}=\\{0, 50, 110, 150, 199\\}$。\n    -   $t=0$：在 $\\mathrm{EN}$ 段中。$e(0)=0$。$L(0) = (0-0) + 45 = 45$。\n    -   $t=50$：在 $\\mathrm{EN}$ 段中。$e(50)=50$。$L(50) = (50-50) + 45 = 45$。\n    -   $t=110$：在 $\\mathrm{DI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $130$ 开始。$e(110)=130$。$L(110) = (130-110) + 45 = 20 + 45 = 65$。\n    -   $t=150$：在 $\\mathrm{EN}$ 段中。$e(150)=150$。$L(150) = (150-150) + 45 = 45$。\n    -   $t=199$：在 $\\mathrm{EN}$ 段中。$e(199)=199$。$L(199) = (199-199) + 45 = 45$。\n-   $L_{\\max} = \\max\\{45, 45, 65, 45, 45\\} = 65$。\n\n**用例 2**：\n-   段：$[\\mathrm{EN}, 10], [\\mathrm{DI}, 200], [\\mathrm{EN}, 20]$。\n-   时间线：$\\mathrm{EN}$ 在 $[0, 10)$ 上，$\\mathrm{DI}$ 在 $[10, 210)$ 上，$\\mathrm{EN}$ 在 $[210, 230)$ 上。\n-   开销：$O = 8 + 7 + 3 + 2 = 20$。\n-   到达时间 $\\mathcal{A}=\\{0, 5, 10, 50, 209\\}$。\n    -   $t=0$：在 $\\mathrm{EN}$ 段中。$e(0)=0$。$L(0) = (0-0) + 20 = 20$。\n    -   $t=5$：在 $\\mathrm{EN}$ 段中。$e(5)=5$。$L(5) = (5-5) + 20 = 20$。\n    -   $t=10$：在 $\\mathrm{DI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $210$ 开始。$e(10)=210$。$L(10) = (210-10) + 20 = 200 + 20 = 220$。\n    -   $t=50$：在 $\\mathrm{DI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $210$ 开始。$e(50)=210$。$L(50) = (210-50) + 20 = 160 + 20 = 180$。\n    -   $t=209$：在 $\\mathrm{DI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $210$ 开始。$e(209)=210$。$L(209) = (210-209) + 20 = 1 + 20 = 21$。\n-   $L_{\\max} = \\max\\{20, 20, 220, 180, 21\\} = 220$。\n\n**用例 3**：\n-   段：$[\\mathrm{EN}, 50], [\\mathrm{HI}, 80], [\\mathrm{EN}, 40]$。\n-   时间线：$\\mathrm{EN}$ 在 $[0, 50)$ 上，$\\mathrm{HI}$ 在 $[50, 130)$ 上，$\\mathrm{EN}$ 在 $[130, 170)$ 上。\n-   开销：$O = 5 + 6 + 2 + 2 = 15$。\n-   到达时间 $\\mathcal{A}=\\{0, 25, 50, 60, 129, 149\\}$。\n    -   $t=0$：在 $\\mathrm{EN}$ 段中。$e(0)=0$。$L(0) = (0-0) + 15 = 15$。\n    -   $t=25$：在 $\\mathrm{EN}$ 段中。$e(25)=25$。$L(25) = (25-25) + 15 = 15$。\n    -   $t=50$：在 $\\mathrm{HI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $130$ 开始。$e(50)=130$。$L(50) = (130-50) + 15 = 80 + 15 = 95$。\n    -   $t=60$：在 $\\mathrm{HI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $130$ 开始。$e(60)=130$。$L(60) = (130-60) + 15 = 70 + 15 = 85$。\n    -   $t=129$：在 $\\mathrm{HI}$ 段中。下一个 $\\mathrm{EN}$ 段在 $130$ 开始。$e(129)=130$。$L(129) = (130-129) + 15 = 1 + 15 = 16$。\n    -   $t=149$：在 $\\mathrm{EN}$ 段中。$e(149)=149$。$L(149) = (149-149) + 15 = 15$。\n-   $L_{\\max} = \\max\\{15, 15, 95, 85, 16, 15\\} = 95$。\n\n**用例 4**：\n-   段：$[\\mathrm{EN}, 100]$。\n-   时间线：$\\mathrm{EN}$ 在 $[0, 100)$ 上。\n-   开销：$O = 0 + 0 + 0 + 0 = 0$。\n-   到达时间 $\\mathcal{A}=\\{0, 99\\}$。\n    -   $t=0$：在 $\\mathrm{EN}$ 段中。$e(0)=0$。$L(0) = (0-0) + 0 = 0$。\n    -   $t=99$：在 $\\mathrm{EN}$ 段中。$e(99)=99$。$L(99) = (99-99) + 0 = 0$。\n-   $L_{\\max} = \\max\\{0, 0\\} = 0$。\n\n最终结果是四个用例按顺序的最大延迟：65, 220, 95 和 0。",
            "answer": "[65, 220, 95, 0]"
        },
        {
            "introduction": "系统调用必须是原子的：它们要么完全成功，要么完全不产生任何效果。但是，当内核在部分修改数据后发生故障时，我们该如何保证这一点？本练习提出了一个典型场景，即在系统调用执行中途发生缺页故障，要求您设计一种能够保证数据完整性的回滚或提交策略 。",
            "id": "3639994",
            "problem": "在某个操作系统（OS）上，一个用户进程调用系统调用 `update_acl`，以替换由文件描述符引用的文件的访问控制列表（ACL）。内核的实现过程在单个 inode 锁 $L$ 的保护下，按以下逻辑步骤进行：\n\n1. 验证文件描述符并获取锁 $L$。\n2. 增加 inode 版本计数器 $v$ 的值，以反映待处理的 ACL 变更。\n3. 从 inode 的 ACL 列表中移除当前的 ACL 条目，并减少它们的全局引用计数 $r$。\n4. 将 $n$ 个 ACL 条目从虚拟地址 $U$ 处的用户提供缓冲区复制到内核暂存缓冲区。\n5. 将暂存的 ACL 条目安装到 inode 中，并相应地更新全局引用计数 $r$。\n6. 释放锁 $L$ 并向调用者返回成功，可选择性地将摘要信息复制到用户内存地址 $W$ 处。\n\n假设已启用请求分页，并且在内核中执行第 4 步时，在第 2 步和第 3 步已部分修改内核数据后，访问位于虚拟地址 $U$ 的用户缓冲区可能会触发同步页面错误。内核的异常处理器可能会通过加载缺失的页面来解决此错误，也可能判定该错误不可恢复（例如，由于访问控制失败），在这种情况下，该异常与当前进程关联，并且系统调用必须以错误终止。\n\n操作系统必须始终保持以下不变式：\n- $I_1$：inode 的 ACL 引用计数 $r$ 等于当前与该 inode 关联的 ACL 条目数量。\n- $I_2$：版本计数器 $v$ 仅在 ACL 成功替换时增加；如果系统调用失败，$v$ 必须保持其调用前的值不变。\n- $I_3$：ACL 条目的移除和安装必须是平衡的；失败不能留下“半应用”的更改。\n\n从以下核心定义出发：\n- 同步异常（陷阱）由中央处理器（CPU）在当前进程执行指令时引发，在内核模式下处理，并且控制必须返回到与进程语义一致的明确定义的点。\n- 系统调用对于进程可见的状态应是原子的：要么所有预期的更改都发生，要么都不发生。\n- 由于与内核内部一致性无关的虚拟内存条件，内核-用户内存传输可能会出错。\n\n在所描述的故障情况下，哪种回滚语义和顺序的设计选择能确保不变式 $I_1$、$I_2$ 和 $I_3$，同时保持原子系统调用语义并避免死锁？\n\nA. 引入一个针对每个系统调用的撤销日志：在进行任何内核端修改之前，记录其逆操作；重新排序操作序列，在增加 $v$ 或更改 ACL 列表之前，执行所有用户内存验证并将数据从 $U$ 拷入内核暂存缓冲区。如果在第 4 步发生不可恢复的故障，则以错误中止并反向应用撤销日志以恢复调用前状态，从而确保 $I_1$、$I_2$ 和 $I_3$。\n\nB. 持有锁 $L$，执行步骤 2 和 3，如果访问 $U$ 时发生不可恢复的故障，则终止进程而不进行回滚。依赖后台协调程序最终修复引用计数和版本计数器，接受瞬时的不变式违反为正常现象。\n\nC. 在获取锁 $L$ 之前，使用预取错误机制锁定（pin）用户地址 $U$ 处的页面，这样随后的拷入操作就不会出错；然后按原始顺序继续。如果锁定失败，则不作任何更改并返回错误。如果锁定成功，则提交更改，并在最后将数据拷出到 $W$，无需额外的回滚机制。\n\nD. 将 `update_acl` 标记为可重启的：在内核内部发生故障时，带错误返回用户模式，但保留内核的部分状态。在随后的重试中，从失败点恢复，假设幂等应用将收敛到一致性，而无需显式回滚。\n\n选择最佳答案。",
            "solution": "用户提供了一个关于操作系统设计中系统调用原子性和异常处理的问题陈述。我将首先验证该问题陈述，然后进行完整解答。\n\n### 第 1 步：提取已知信息\n\n问题陈述提供了以下信息：\n-   **系统调用**：一个用户进程调用系统调用 `update_acl` 来替换文件的访问控制列表（$\\text{ACL}$）。\n-   **输入**：该调用使用一个文件描述符和一个位于虚拟地址 $U$ 的用户提供缓冲区，其中包含 $n$ 个 $\\text{ACL}$ 条目。\n-   **内核锁**：内核实现使用一个单一的 inode 锁 $L$。\n-   **逻辑步骤**：内核在锁 $L$ 的保护下执行以下序列：\n    1.  验证文件描述符并获取锁 $L$。\n    2.  增加 inode 版本计数器 $v$。\n    3.  移除当前的 $\\text{ACL}$ 条目并减少它们的全局引用计数 $r$。\n    4.  从位于 $U$ 的用户缓冲区复制 $n$ 个 $\\text{ACL}$ 条目到内核暂存缓冲区。\n    5.  安装暂存的 $\\text{ACL}$ 条目并更新全局引用计数 $r$。\n    6.  释放锁 $L$ 并返回，可选择性地将数据拷出到用户内存地址 $W$。\n-   **故障条件**：在访问位于 $U$ 的用户缓冲区时，在第 4 步期间可能发生同步页面错误。此故障发生在第 2 步和第 3 步已修改内核数据结构之后。该故障可能是可恢复的（页面被加载）或不可恢复的（例如，访问违规），在后一种情况下，系统调用必须失败。\n-   **不变式**：操作系统必须维护三个不变式：\n    -   $I_1$：inode 的 $\\text{ACL}$ 引用计数 $r$ 必须等于与该 inode 关联的 $\\text{ACL}$ 条目数。\n    -   $I_2$：版本计数器 $v$ 必须仅在 $\\text{ACL}$ 成功替换时增加。如果失败，$v$ 必须保持调用前的值不变。\n    -   $I_3$：$\\text{ACL}$ 条目的移除和安装必须是平衡的；失败时不允许出现“半应用”的更改。\n-   **核心定义**：\n    -   同步异常在内核中处理，控制必须返回到一个明确定义的点。\n    -   从进程的角度来看，系统调用应是原子的。\n    -   由于虚拟内存问题，内核-用户内存传输是可能出错的。\n-   **问题**：任务是确定哪种设计选择能在发生所述故障时，确保不变式 $I_1$、$I_2$ 和 $I_3$，保持系统调用的原子性，并避免死锁。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n对问题陈述进行严格评估如下：\n-   **科学性**：该问题牢固地植根于计算机科学的基本原理，特别是操作系统设计的原理。像系统调用、inode、访问控制列表、请求分页、页面错误、内核锁和原子性等概念都是该领域的标准和核心内容。所描述的场景是内核开发者面临的经典且现实的挑战。它没有任何伪科学或事实错误。\n-   **问题明确**：问题定义清晰。它提出了一个操作序列、一个特定的失败模式（部分状态修改后的页面错误）、一组约束（不变式），并要求找到一种设计模式来解决这个冲突。可以从已建立的操作系统设计原则中推导出一个逻辑上确定的答案。\n-   **客观性**：语言技术性强、精确且无歧义。正确解决方案的标准（$I_1, I_2, I_3$, 原子性）是客观的，允许对所提议的选项进行严格评估。\n-   **完整性和一致性**：问题是自包含的。它提供了关于初始状态、操作、失败点和期望的最终状态属性的所有必要细节。核心矛盾——在验证所有输入之前修改状态——是问题的本质，而不是其表述中的矛盾。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。这是一个关于操作系统内核设计关键方面的、表述良好的问题。我现在将进行解决方案推导和选项分析。\n\n### 解决方案推导\n\n在 `update_acl` 的描述实现中，根本问题是违反了原子性。从调用进程的角度来看，一个系统调用应该像一个单一的、不可分割的（原子的）操作：要么它成功完成，其所有效果都永久生效，要么它失败，并且对系统的可见状态没有影响。\n\n所提供的步骤序列是：\n$1$. 获取锁 $\\rightarrow$ $2$. 修改 $v$ $\\rightarrow$ $3$. 修改 $\\text{ACL}$ 列表 $\\rightarrow$ $4$. 访问用户内存 $U$（潜在故障） $\\rightarrow$ ...\n\n问题之所以出现，是因为对共享内核数据进行了不可逆（或难以逆转）的修改（步骤 2 和 3），而这些修改是在所有输入都得到验证*之前*执行的。位于 $U$ 的用户空间缓冲区的可访问性是一个输入条件，只在步骤 4 才被检查。如果在步骤 4 发生不可恢复的页面错误，系统调用必须中止。然而，此时 inode 处于不一致状态：\n-   版本计数器 $v$ 已增加，由于调用失败，这违反了不变式 $I_2$。\n-   旧的 $\\text{ACL}$ 已被移除，但新的尚未安装，这违反了不变式 $I_3$。根据在中间状态下如何管理 $r$，不变式 $I_1$ 也可能被违反。\n\n一个正确的设计必须确保如果系统调用在任何点失败，状态都会回滚到调用开始之前的状态。实现这一点的最有效方法是在所有可能失败的操作（如访问用户内存）成功完成之前，不执行任何状态修改。这一原则将“验证”阶段与“提交”阶段分开。\n\n### 逐项分析选项\n\n**A. 引入一个针对每个系统调用的撤销日志：在进行任何内核端修改之前，记录其逆操作；重新排序操作序列，在增加 $v$ 或更改 ACL 列表之前，执行所有用户内存验证并将数据从 $U$ 拷入内核暂存缓冲区。如果在第 4 步发生不可恢复的故障，则以错误中止并反向应用撤销日志以恢复调用前状态，从而确保 $I_1$、$I_2$ 和 $I_3$。**\n\n这个选项提出了解决此类问题的经典方案。关键的洞见在于**重排操作顺序**。正确的序列应该是：\n$1$. 验证文件描述符。\n$2$. 将新的 $\\text{ACL}$ 数据从位于 $U$ 的用户缓冲区复制到一个临时的内核空间缓冲区。\n$3$. 如果复制失败（例如，由于不可恢复的页面错误），系统调用可以立即返回一个错误（例如，`EFAULT`）。此时，没有对 inode 进行任何修改，因此所有不变式都得以保持，原子性也得到维护。\n$4. 如果复制成功，则获取 inode 锁 $L$。\n$5$. 对 inode 进行修改（增加 $v$，移除旧的 $\\text{ACL}$，从内核缓冲区安装新的 $\\text{ACL}$）。由于所有数据现在都在内核中，这些操作不会受到访问用户内存所引起的页面错误的影响，并且可以原子地完成。\n$6$. 释放锁 $L$ 并返回成功。\n\n这种重排序完美地实现了“全有或全无”的语义。提及“撤销日志”正确地将问题置于事务语义的框架中；而重排序是这一原则的高效实现，因为它通过防止不一致状态的产生，使得显式的运行时撤销日志变得不必要。这种设计是健壮、安全的（因为它防止了 TOCTTOU 攻击），并且正确地维护了所有指定的不变式。\n\n结论：**正确**。\n\n**B. 持有锁 $L$，执行步骤 2 和 3，如果访问 $U$ 时发生不可恢复的故障，则终止进程而不进行回滚。依赖后台协调程序最终修复引用计数和版本计数器，接受瞬时的不变式违反为正常现象。**\n\n这种方法存在根本性缺陷。它明确允许系统进入一个已知的不一致状态，并推卸了系统调用本身维护不变式的责任。依赖一个后台进程（如 `fsck`）来清理系统调用中可预见的常规错误是糟糕的设计。这会导致文件元数据在一段时间内是损坏的，如果其他进程访问该 inode，可能会导致数据丢失、行为不正确或安全漏洞。它公然违反了系统调用原子性原则以及不变式 $I_2$ 和 $I_3$。\n\n结论：**不正确**。\n\n**C. 在获取锁 $L$ 之前，使用预取错误机制锁定（pin）用户地址 $U$ 处的页面，这样随后的拷入操作就不会出错；然后按原始顺序继续。如果锁定失败，则不作任何更改并返回错误。如果锁定成功，则提交更改，并在最后将数据拷出到 $W$，无需额外的回滚机制。**\n\n这描述了操作系统中使用的另一种有效技术。“锁定”一个页面涉及将其标记为不能被换出，从而确保对它的任何访问都不会产生页面错误。通过在获取锁和修改 inode 之前锁定位于 $U$ 的页面，此方法也确保了第 4 步不会失败。如果锁定本身失败，调用可以干净地中止。这种方法也正确地解决了原子性问题。\n\n然而，与选项 A 相比，它可能不是*最佳*的设计选择。\n$1$. **安全性**：它容易受到检查时-使用时（Time-Of-Check-To-Time-Of-Use, TOCTTOU）竞争条件的影响。用户进程中的另一个线程可能在内核验证了位于 $U$ 的缓冲区中的数据之后，但在内核使用完这些数据*之前*修改它。选项 A 中的“拷入到内核缓冲区”策略通过创建一个供内核使用的私有、不可变的副本来防止这种情况。\n$2$. **复杂性**：管理锁定的页面给内存管理子系统增加了复杂性和开销。页面不能无限期地锁定，内核必须小心地在所有可能的退出路径上解除锁定。\n\n因为选项 A 的策略通常更安全，并且在概念上通常更简单，所以它代表了一种更健壮、更优越的设计模式。\n\n结论：**不正确**（因为它是一个可行的，但与 A 相比不是*最佳*的设计选择）。\n\n**D. 将 `update_acl` 标记为可重启的：在内核内部发生故障时，带错误返回用户模式，但保留内核的部分状态。在随后的重试中，从失败点恢复，假设幂等应用将收敛到一致性，而无需显式回滚。**\n\n这是对可重启系统调用概念的误用。可重启系统调用通常用于那些在产生任何永久性副作用*之前*被中断（例如，被信号中断）的操作。一个已经进行了非幂等性更改（如移除旧的 $\\text{ACL}$）的系统调用不能简单地“重启”。“从失败点恢复”的逻辑将非常复杂和脆弱。它要求内核知道自己的部分状态，并且用户必须知道它必须重试调用。这打破了原子系统调用的抽象，对用户而言，系统调用应该要么完全成功，要么完全失败且无副作用。这种设计在初次失败时违反了不变式 $I_2$ 和 $I_3$。\n\n结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "一个健壮的内核甚至必须为处理异常时再次发生异常做好准备。此练习深入探讨了双重故障这一关键场景，它通常是灾难性系统重启的前兆。您将探索 x86-64 架构提供的特定机制，以创建一个即使在主内核栈不可用时也能正常工作的“故障安全”处理程序 。",
            "id": "3640031",
            "problem": "一个在现代 x86 $64$ 位中央处理器 (CPU) 上运行的操作系统内核使用带有保护页的内核模式栈来检测溢出。当内核栈溢出时，第一个故障通常是访问不存在的保护页时触发的页错误。如果内核在仍然使用溢出的栈的情况下尝试处理该页错误，中央处理器 (CPU) 可能会在尝试推入异常帧时生成第二个故障，从而导致双重故障。在双重故障分发期间发生第三个故障会导致三重故障，这会重置中央处理器 (CPU)。内核的异常分发使用中断描述符表 (IDT)。x86 $64$ 位上的任务状态段 (TSS) 存储着称为中断栈表 (IST) 的特殊指针，可用于选定的异常处理程序，以确保在已知良好的栈上进行分发。\n\n从硬件异常、特权级转换以及中央处理器 (CPU) 通过中断描述符表 (IDT) 和任务状态段 (TSS) 分发异常的方式的定义出发，思考一个安全的设计来处理由内核栈溢出专门引起的双重故障。你的设计必须确保一个最小化的、安全的处理程序路径，该路径不依赖于损坏的栈，并避免升级为三重故障。选择最能正确描述这种用于现代 x86 $64$ 位内核策略的选项。\n\nA. 在中断描述符表 (IDT) 中配置双重故障（向量 $8$）条目，使其使用一个指向每 CPU 应急栈的中断栈表 (IST) 槽位。在处理程序中，立即在应急栈上运行，禁用中断，避免任何动态内存分配或复杂的日志记录，将最少的诊断信息写入一个安全的接收端，并强制执行一次可控的内核恐慌以停止运行，从而避免三重故障。\n\nB. 将双重故障保留为使用当前内核栈的普通中断门；在处理程序中，通过内核内存分配来分配一个更大的栈，将旧栈内容复制到新栈中，重新启用中断，并在出错指令处恢复执行。\n\nC. 通过将双重故障向量安装为不可屏蔽中断 (NMI) 的别名，将双重故障重定向到 NMI，切换到用户模式，终止当前进程，并使用相同的栈继续执行内核。\n\nD. 将双重故障处理程序配置为一个任务门，该任务门执行硬件任务切换到一个具有已知良好栈的任务状态段 (TSS)；在处理程序中，保存寄存器，禁用中断，打印诊断信息，然后重启或停止。\n\nE. 通过在中断描述符表 (IDT) 条目中设置中断标志来屏蔽双重故障，以便中央处理器 (CPU) 将处理推迟到正常中断之后，从而在内核增长栈并恢复执行时防止三重故障。",
            "solution": "该问题要求为现代 x86 $64$ 位架构上的双重故障异常制定一种安全的处理策略，特别是在双重故障是内核栈溢出的后果时。\n\n### 第一步：提取已知条件\n- 系统是在现代 x86 $64$ 位中央处理器 (CPU) 上运行的操作系统内核。\n- 内核模式栈受保护页保护。\n- 内核栈溢出首先会在访问保护页时触发页错误（向量 $14$）。\n- 在溢出的栈上尝试处理此页错误会导致第二个故障，即双重故障（向量 $8$），因为 CPU 无法推入异常帧。\n- 在分发双重故障处理程序期间发生的第三个故障会导致三重故障，这会引起 CPU 的硬件复位。\n- 异常分发由中断描述符表 (IDT) 管理。\n- 任务状态段 (TSS) 包含一个中断栈表 (IST)，它为特定的异常处理程序提供指向备用栈的指针。\n- 目标是为双重故障设计一个最小化的、安全的处理程序路径，该路径不使用损坏的栈并能防止三重故障。\n\n### 第二步：使用提取的已知条件进行验证\n问题陈述是有效的。它准确地描述了 x86 $64$ 位 CPU 文档完备的异常处理架构，包括从内核栈溢出到页错误，再到双重故障，并可能导致三重故障的事件序列。IDT、TSS 和 IST 的概念都是标准的体系结构特性。该问题在科学上是合理的、阐述清晰且客观的，提出了底层操作系统设计中一个经典而关键的挑战。未发现任何缺陷。\n\n### 第三步：基于原理的推导\n双重故障，在 x86 架构上指定为异常向量 $8$，发生在 CPU 在尝试调用前一个异常的处理程序时检测到第二个异常。在所描述的场景中，序列是：\n1.  **初始事件**：内核栈溢出。栈指针寄存器 `RSP` 现在指向有效栈区域下方不存在的保护页。\n2.  **第一个故障**：一条指令试图将数据推入内核栈（例如，在系统调用或中断进入期间）。这次对保护页地址的访问触发了页错误（向量 $14$）。\n3.  **第二个故障（双重故障）**：CPU 试图调用页错误处理程序。为此，它必须将一个异常帧（包含 `SS`、`RSP`、`RFLAGS`、`CS`、`RIP` 和一个错误码）推入当前的内核栈。然而，栈已经溢出，`RSP` 指向一个无效地址。这个推入操作失败，触发了第二个更严重的异常：双重故障（向量 $8$）。\n\n关键问题是，CPU 现在正试图调用双重故障处理程序。如果它再次尝试使用同一个已损坏的内核栈，那么为双重故障异常帧进行的推入操作也将失败。调用双重故障处理程序的失败构成了第三个、不可恢复的故障，称为三重故障。三重故障导致 CPU 进入关闭状态，这通常表现为系统重置。\n\n为了防止三重故障，双重故障处理程序**必须**在一个不同的、已知良好的栈上被调用。专为此目的设计的标准 x86 $64$ 位架构机制是中断栈表 (IST)。每个 CPU 的 TSS 包含多达七个指向备用栈基址的指针。任何给定异常的 IDT 条目都可以配置一个指向 IST 的索引（从 $1$ 到 $7$）。\n\n当发生一个其 IDT 门指定了 IST 索引的异常时，CPU 在调用处理程序*之前*会执行以下关键操作：\n1.  它暂时保存当前的栈指针 (`SS:RSP`)。\n2.  它从当前 TSS 中指定的 IST 条目加载一个新的栈指针。\n3.  它将保存的 `SS:RSP` 推到这个新的、已知良好的栈上。\n4.  然后，它继续将异常帧的其余部分（`RFLAGS`、`CS`、`RIP` 和错误码）推到新栈上。\n5.  最后，它跳转到 IDT 中指定的处理程序地址。\n\n这种由硬件管理的栈切换保证了双重故障处理程序在干净的、预分配的应急栈上开始执行，完全避免了使用损坏的栈，从而防止了三重故障。\n\n一旦在这个应急栈上运行，处理程序的环境就非常不稳定。由于栈损坏，内核的状态是未知的，并且很可能是不一致的。因此，处理程序必须是最小化的并且极其小心。安全的操作包括：\n- 立即禁用中断（`cli`）以防止任何其他事件干扰。\n- 避免任何复杂的内核函数，特别是那些可能分配内存、获取锁或依赖于一致内核数据结构的函数。\n- 将最少的诊断信息（例如，寄存器状态）记录到一个安全的、预分配的、无锁的位置（例如基于 RAM 的日志缓冲区或直接写入显存）。\n- 通过可控的内核恐慌有意地停止系统。试图恢复或继续执行是不安全的，并有数据损坏的风险。\n\n### 逐项分析选项\n\n**A. 在中断描述符表 (IDT) 中配置双重故障（向量 $8$）条目，使其使用一个指向每 CPU 应急栈的中断栈表 (IST) 槽位。在处理程序中，立即在应急栈上运行，禁用中断，避免任何动态内存分配或复杂的日志记录，将最少的诊断信息写入一个安全的接收端，并强制执行一次可控的内核恐慌以停止运行，从而避免三重故障。**\n这个选项正确地指出了使用 IST 作为确保双重故障处理程序在安全栈上运行的主要机制。应急栈的每 CPU 分配也是标准做法，因为每个 CPU 核心都可能独立发生故障。为处理程序描述的后续操作——禁用中断、避免复杂操作、最小化日志记录和引发恐慌——正是安全健壮实现所需的步骤。此策略直接解决了问题并防止了三重故障。\n**结论：正确**\n\n**B. 将双重故障保留为使用当前内核栈的普通中断门；在处理程序中，通过内核内存分配来分配一个更大的栈，将旧栈内容复制到新栈中，重新启用中断，并在出错指令处恢复执行。**\n这个选项根本上是错误的。“使用当前内核栈”这个前提正是导致三重故障的原因。处理程序代码甚至永远不会开始执行，因为 CPU 试图将异常帧推入损坏的栈会失败。因此，所有后续提议的操作（内存分配、复制栈、恢复执行）都是无法到达的，并且在任何情况下，在双重故障的上下文中都是极其不明智的。\n**结论：不正确**\n\n**C. 通过将双重故障向量安装为不可屏蔽中断 (NMI) 的别名，将双重故障重定向到 NMI，切换到用户模式，终止当前进程，并使用相同的栈继续执行内核。**\n这个选项在体系结构上是不连贯的。双重故障硬连线到向量 $8$，而 NMI 硬连线到向量 $2$；它们不能以所述方式“别名”。此外，从内核级的灾难性故障切换到用户模式是不可能的，并且在逻辑上毫无意义。如果栈溢出发生在全局上下文（例如，中断处理程序）中，终止当前进程可能无法解决问题。最后，试图使用“相同的栈”是导致三重故障的原始错误。\n**结论：不正确**\n\n**D. 将双重故障处理程序配置为一个任务门，该任务门执行硬件任务切换到一个具有已知良好栈的任务状态段 (TSS)；在处理程序中，保存寄存器，禁用中断，打印诊断信息，然后重启或停止。**\n使用任务门是 i386 架构上可用的一种机制，用于切换到新上下文，包括新栈。虽然这种机制在 x86 $64$ 位的传统/兼容模式下仍然存在，但对于异常处理，它已在很大程度上被更轻量级和高效的 IST 机制所取代。现代 $64$ 位操作系统（Linux、Windows、macOS）不使用硬件任务切换进行异常处理。在*现代* x86 $64$ 位 CPU 上，IST 是惯用且预期的解决方案。因此，虽然技术上提供了新栈，但对于现代内核来说，这不是最正确或标准的策略。\n**结论：不正确**\n\n**E. 通过在中断描述符表 (IDT) 条目中设置中断标志来屏蔽双重故障，以便中央处理器 (CPU) 将处理推迟到正常中断之后，从而在内核增长栈并恢复执行时防止三重故障。**\n这个选项表现出对 CPU 异常模型的误解。诸如双重故障之类的故障是同步的，不能被中断标志（`RFLAGS` 中的 `IF`）屏蔽。CPU 必须立即处理它们；它们不能被推迟。IDT 门中的标志位控制的是*进入处理程序时*是否禁用中断，而不是异常本身是否被生成。整个前提在体系结构上是不可能的。\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}