{
    "hands_on_practices": [
        {
            "introduction": "The Compare-And-Swap (CAS) primitive is a cornerstone of nonblocking algorithms, but it is susceptible to a subtle bug known as the ABA problem. This exercise will guide you through a quantitative analysis of a common solution: tagged pointers. By calculating the necessary tag width to prevent failures within a given time frame, you will develop a practical understanding of how to design robust lock-free data structures that are safe under high concurrency .",
            "id": "3663893",
            "problem": "A lock-free stack implemented with Atomic Compare-and-Swap (CAS) uses a tagged pointer in a single $64$-bit word to mitigate the ABA problem. The head field consists of a pointer and a version tag that increments by $1$ on every successful CAS that changes the head (both push and pop). The version tag is stored modulo $2^{b}$, where $b$ is the number of tag bits. The system’s worst-case rate of successful head updates is $N$ updates per second. To ensure that an ABA cannot be hidden by a tag wraparound during a target no-wrap interval of length $T$, the tag must not wrap within any interval of length $T$.\n\nAssume the following:\n- The worst-case sustained rate of successful head updates is $N = 1.2 \\times 10^{8}$ per second.\n- The required no-wrap interval is $T = 3$ hours.\n\nUsing only the standard semantics of Atomic Compare-and-Swap (CAS), the definition of the ABA problem, and the arithmetic relationship between rate and count over time, determine the minimal integer tag width $b$ (in bits) that guarantees no tag wraparound within any interval of length $T$. Express your answer as an exact integer number of bits. Do not include any units in your final answer.",
            "solution": "The problem requires determining the minimum integer number of bits, $b$, for a version tag to prevent a wraparound within a specified time interval, $T$, given a worst-case rate of updates, $N$. This is a classic problem in designing lock-free data structures to mitigate the ABA problem.\n\nFirst, we formalize the given parameters.\nThe worst-case sustained rate of successful head updates is $N = 1.2 \\times 10^{8}$ updates per second.\nThe required no-wrap interval is $T = 3$ hours.\nThe version tag is an integer counter stored in $b$ bits, which increments with each successful update. This tag can represent $2^b$ distinct values, from $0$ to $2^b - 1$. A wraparound occurs when the counter increments $2^b$ times, causing its value to reset to the starting value (modulo $2^b$).\n\nThe core principle is that to guarantee no wraparound within the interval $T$, the total number of updates that can occur during this interval must be strictly less than the number of unique states the tag can represent.\n\nLet $U_{max}$ be the maximum number of updates that can occur in the time interval $T$. This is calculated by multiplying the rate of updates $N$ by the duration of the interval $T$.\nFirst, we must express $T$ in a consistent unit with $N$, which is seconds.\nGiven $T = 3$ hours, we convert it to seconds:\n$$T_{\\text{seconds}} = 3 \\text{ hours} \\times \\frac{60 \\text{ minutes}}{1 \\text{ hour}} \\times \\frac{60 \\text{ seconds}}{1 \\text{ minute}} = 3 \\times 3600 \\text{ seconds} = 10800 \\text{ s}$$\n\nNext, we calculate the total maximum number of updates, $U_{max}$, over this interval:\n$$U_{max} = N \\times T_{\\text{seconds}}$$\n$$U_{max} = (1.2 \\times 10^{8} \\text{ s}^{-1}) \\times (10800 \\text{ s})$$\n$$U_{max} = 1.2 \\times 10^{8} \\times 1.08 \\times 10^{4}$$\n$$U_{max} = 1.296 \\times 10^{12}$$\n\nThe number of distinct states a $b$-bit tag can represent is $2^b$. To prevent a wraparound, the total number of updates, $U_{max}$, must be less than $2^b$.\n$$U_{max} < 2^b$$\n$$1.296 \\times 10^{12} < 2^b$$\n\nTo find the minimum integer value of $b$ that satisfies this inequality, we take the base-$2$ logarithm of both sides:\n$$\\log_{2}(1.296 \\times 10^{12}) < \\log_{2}(2^b)$$\n$$\\log_{2}(1.296 \\times 10^{12}) < b$$\n\nWe can evaluate the logarithm:\n$$\\log_{2}(1.296 \\times 10^{12}) = \\frac{\\ln(1.296 \\times 10^{12})}{\\ln(2)}$$\nUsing computational tools for precision:\n$$\\ln(1.296 \\times 10^{12}) \\approx 27.890270$$\n$$\\ln(2) \\approx 0.693147$$\n$$b > \\frac{27.890270}{0.693147} \\approx 40.236606$$\n\nSince $b$ must be an integer, the smallest integer value for $b$ that satisfies the condition $b > 40.236606$ is $41$.\nTherefore, a minimum of $b=41$ bits are required for the version tag to ensure it does not wrap around within any $3$-hour interval under the given worst-case update rate.\nIf $b=40$, the number of states is $2^{40} \\approx 1.0995 \\times 10^{12}$. This is less than the required $1.296 \\times 10^{12}$ updates, so a wraparound could occur.\nIf $b=41$, the number of states is $2^{41} \\approx 2.1990 \\times 10^{12}$. This is greater than $1.296 \\times 10^{12}$, thus satisfying the no-wrap condition.",
            "answer": "$$\\boxed{41}$$"
        },
        {
            "introduction": "Transactional Memory (TM) offers a higher-level abstraction that promises to simplify concurrent programming by grouping memory operations into atomic transactions. However, this powerful model must interact safely with non-transactional parts of the system, such as asynchronous signal handlers that perform irreversible I/O. This problem challenges you to reason about these interactions and determine the most viable strategy to preserve atomicity and isolation, a critical skill in designing real-world systems that blend different concurrency models .",
            "id": "3663950",
            "problem": "In an operating system that supports Transactional Memory (TM), consider a single process with multiple threads. A given thread executes a transaction, denoted by $T$, that updates a shared data structure. The operating system also supports Portable Operating System Interface (POSIX) signals. A signal, denoted by $S$, can be delivered to a specific thread and causes a user-level signal handler, denoted by $H$, to run on that same thread. The signal handler $H$ may perform input/output, read the shared data structure, and modify thread-local state.\n\nAssume the following fundamental definitions and system facts as a base:\n- Atomicity and isolation of a transaction $T$: either all memory effects of $T$ take effect at commit, or none do (all-or-nothing), and no other code observes partial effects of $T$. Formally, if $M_0$ is the memory state when $T$ starts and $M_1$ is the state if $T$ commits, then visible memory transitions are either $M_0 \\rightarrow M_1$ on commit or $M_0 \\rightarrow M_0$ on abort; there must be no externally visible intermediate state.\n- A signal $S$ is an asynchronous event. Under POSIX semantics, the handler $H$ executes as an asynchronous control transfer on the interrupted thread and may only safely call functions designated as asynchronous-signal-safe. Input/output effects produced by $H$ are externally visible and cannot be rolled back by TM.\n- Hardware Transactional Memory (HTM) and Software Transactional Memory (STM) both provide speculative execution of $T$ and detect conflicts, but speculative writes of $T$ are not externally visible until commit. Neither HTM nor STM generally provides a mechanism to make input/output transactional or to suspend and later resume a transaction across arbitrary asynchronous handler execution without aborting.\n- Liveness requirement for signal delivery: while immediate delivery is not guaranteed, the system should not allow unbounded deferral of $S$ such that $H$ may never run if the thread remains in a transaction for an extended period.\n\nSuppose $S$ arrives while the thread is in the middle of executing $T$, and $H$ may touch memory that $T$ reads or writes. Which semantics for handling $S$ best preserve TM guarantees (atomicity and isolation), avoid exposing uncommitted state to $H$ or the outside world, and maintain reasonable liveness, without assuming unrealistic new hardware capabilities?\n\nChoose the best option(s).\n\n- A. Execute $H$ immediately inside $T$, so that all of $H$'s memory accesses and input/output become part of the same speculative context as $T$. If $T$ commits, both $T$ and $H$ effects become visible atomically; if $T$ aborts, all effects, including input/output, are rolled back.\n\n- B. Automatically abort $T$ upon receipt of $S$, discard all speculative effects of $T$, and then deliver $H$ on the same thread outside of any transaction. After $H$ returns, the runtime may optionally retry $T$ according to programmer policy.\n\n- C. Defer delivery of $S$ until the next transaction boundary after $T$ commits successfully, and then run $H$. If $T$ keeps retrying due to contention, $S$ remains pending until a commit occurs.\n\n- D. Interrupt $T$ and deliver $H$ outside of any transaction, while the system snapshots the speculative state of $T$ and later resumes $T$ from the interruption point with its speculative read and write sets intact, as if $T$ had never been interrupted. The handler $H$ must refrain from accessing any memory in the speculative read or write set of $T$.\n\n- E. Force a commit of $T$ at the moment $S$ arrives, making all effects of $T$ visible immediately, then run $H$ outside of $T$ to ensure prompt handling without aborting work already done by $T$.",
            "solution": "The problem requires an analysis of how to handle an asynchronous POSIX signal, $S$, that arrives while a thread is executing a memory transaction, $T$. The goal is to find the semantic model that best preserves the guarantees of Transactional Memory (TM), namely atomicity and isolation, while also ensuring liveness for signal delivery and not depending on unrealistic system capabilities.\n\nLet us analyze the problem based on the fundamental principles provided.\n\nA transaction $T$ is defined by its atomic nature. The memory state transition must be from a consistent state $M_0$ to another consistent state $M_1$ (on commit) or back to the original state $M_0$ (on abort). No intermediate, partially-modified state should ever be visible to any other part of the system. This property is paramount.\n\nA POSIX signal handler, $H$, represents an asynchronous control flow. Crucially, the problem states that $H$ can perform input/output (I/O). I/O operations are side effects that are external to the program's memory state and are generally irreversible. For instance, data written to a file or sent over a network cannot be \"taken back\" if the transaction that issued the I/O is later aborted. This non-transactional nature of I/O is a critical constraint. As stated: \"Input/output effects produced by $H$ are externally visible and cannot be rolled back by TM.\"\n\nThe problem also introduces a liveness requirement: \"the system should not allow unbounded deferral of $S$.\" This prevents solutions that might postpone signal handling indefinitely.\n\nFinally, we must operate within the realistic constraints of common Hardware Transactional Memory (HTM) and Software Transactional Memory (STM) implementations, which do not support transactional I/O or the general ability to suspend and resume a transaction across an asynchronous event.\n\nWith these principles established, we can systematically evaluate each proposed option.\n\n**A. Execute $H$ immediately inside $T$, so that all of $H$'s memory accesses and input/output become part of the same speculative context as $T$. If $T$ commits, both $T$ and $H$ effects become visible atomically; if $T$ aborts, all effects, including input/output, are rolled back.**\nThis option contains a fundamental contradiction with the problem's premises. It claims that input/output performed by $H$ can be rolled back. However, the problem definition explicitly states that I/O effects \"cannot be rolled back by TM\". If $H$ were to execute within $T$, perform an I/O operation (e.g., print to the console), and then $T$ were to abort, the I/O effect would remain. This violates the all-or-nothing atomicity guarantee that is the cornerstone of transactions. The system would be in a state where part of the speculative execution (the I/O) has had a permanent external effect, while the other part (the memory changes) has been discarded. This is an inconsistent and unacceptable outcome.\n**Verdict: Incorrect.**\n\n**B. Automatically abort $T$ upon receipt of $S$, discard all speculative effects of $T$, and then deliver $H$ on the same thread outside of any transaction. After $H$ returns, the runtime may optionally retry $T$ according to programmer policy.**\nThis approach provides a clean and safe separation between the transactional context and the signal handling context.\n1.  **Atomicity and Isolation:** By aborting $T$, the system upholds the atomicity guarantee. An abort is a valid transactional outcome, returning the memory to its state $M_0$ prior to the transaction. All of $T$'s speculative and uncommitted effects are discarded, so isolation is perfectly maintained.\n2.  **Signal Handler Execution:** The handler $H$ then executes in a normal, non-transactional state. It sees the consistent memory state $M_0$. Any I/O it performs is non-speculative and correctly reflects the program's state at that time.\n3.  **Liveness:** The signal $S$ is handled promptly after the abort. There is no unbounded deferral, satisfying the liveness requirement.\n4.  **Realism:** This \"pessimistic\" approach is a widely adopted and practical strategy in real-world TM systems because it is simple, safe, and does not require any special hardware or complex software machinery. The cost is the performance penalty of discarding the work done in $T$, but this is the necessary price for correctness and safety in the face of asynchronous, non-transactional events.\n**Verdict: Correct.**\n\n**C. Defer delivery of $S$ until the next transaction boundary after $T$ commits successfully, and then run $H$. If $T$ keeps retrying due to contention, $S$ remains pending until a commit occurs.**\nThis option cleanly separates the transaction from the signal handler. However, it fails the liveness requirement. The problem explicitly considers the case where a transaction might be long-running or subject to repeated retries due to contention. In such scenarios, \"if $T$ keeps retrying due to contention, $S$ remains pending until a commit occurs\" leads to a situation where the signal might be deferred for an arbitrarily long time. This unbounded deferral is a direct violation of the stated liveness requirement. For some signals (e.g., `SIGTERM`, `SIGINT`), such a long delay is unacceptable.\n**Verdict: Incorrect.**\n\n**D. Interrupt $T$ and deliver $H$ outside of any transaction, while the system snapshots the speculative state of $T$ and later resumes $T$ from the interruption point with its speculative read and write sets intact, as if $T$ had never been interrupted. The handler $H$ must refrain from accessing any memory in the speculative read or write set of $T$.**\nThis option proposes a \"suspend and resume\" mechanism for transactions. The problem statement itself casts doubt on this, noting that TM systems do not \"generally provide a mechanism to suspend and later resume a transaction\". This would indeed require complex and \"unrealistic\" hardware or software support not commonly available. Furthermore, it imposes a condition that \"$H$ must refrain from accessing any memory in the speculative read or write set of $T$.\" This is problematic for two reasons. First, the problem states that $H$ *may* touch memory that $T$ reads or writes, so this constraint contradicts the problem's setup. Second, enforcing such a constraint at runtime would be difficult and non-standard. This option describes a hypothetical, advanced system, not a realistic solution within the given constraints.\n**Verdict: Incorrect.**\n\n**E. Force a commit of $T$ at the moment $S$ arrives, making all effects of $T$ visible immediately, then run $H$ outside of $T$ to ensure prompt handling without aborting work already done by $T$.**\nThis option violates the very essence of a transaction. A transaction is a logical unit of work defined by the programmer, intended to execute to completion to ensure data consistency. Forcing a commit at an arbitrary, premature point (upon signal arrival) would make an incomplete set of memory modifications permanent. This would almost certainly corrupt the shared data structure, violating the application's invariants. For example, if $T$ is transferring funds by debiting one account and crediting another, a forced commit after the debit but before the credit would result in lost money. This breaks the atomicity of the intended operation and is a catastrophic failure of correctness.\n**Verdict: Incorrect.**\n\nBased on the rigorous application of the stated principles, only option B provides a viable, safe, and realistic mechanism for handling signals during a transaction. It prioritizes correctness and system stability by aborting the transaction, thereby creating a clean state for the signal handler to execute, and fully complies with all constraints given in the problem statement.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Moving from theory to practice, this final exercise requires you to implement a simulator for a nonblocking, transactional memory allocator. You will use fundamental atomic operations to manage shared state, enforce transactional semantics, and correctly handle complex cases like irrevocable operations. This hands-on coding challenge will solidify your understanding of how high-level transactional memory concepts are built upon low-level, lock-free primitives to ensure both consistency and progress .",
            "id": "3663912",
            "problem": "You are to design and implement a nonblocking, transactional, per-thread memory allocator simulator that enforces consistent global accounting across threads and correctly handles irrevocable deallocation operations. The program you produce must be a complete, runnable program that outputs a single line in the exact format described below.\n\nFundamental base and core definitions:\n- Atomic read-modify-write using compare-and-swap (CAS) is a widely accepted primitive that provides linearizable updates without locks. Model this by an atomic integer that can be incremented and compared-exchanged.\n- In a transactional memory model, a thread executes a transaction that accumulates a write-set delta, here the net memory change, and commits atomically. Let the global total allocated bytes be $G$, the per-thread local allocated bytes be $L_i$, and the per-transaction net change be $\\Delta_i$. A correct commit must preserve $G_{\\text{final}} = G_{\\text{initial}} + \\sum \\Delta_i^{\\text{committed}}$ and $G_{\\text{final}} = \\sum L_j^{\\text{final}}$.\n- Nonblocking progress means that no thread holds locks; progress is achieved via atomic operations and abort/retry. An irrevocable operation is one that cannot be safely rolled back. An irrevocable $free()$ call must be serialized globally to preserve correctness; only one thread may perform it at a time.\n- A transaction must also abort if it would cause the local allocation to become negative upon commit. Formally, a commit is permitted only if $L_i + \\Delta \\ge 0$.\n- On successful commit, apply $\\Delta$ atomically to $G$ and update $L_i \\leftarrow L_i + \\Delta$, releasing any irrevocable ownership if held. On abort, leave $G$ and $L_i$ unchanged and release any irrevocable ownership if acquired.\n\nDeterministic tie-breaking for irrevocable free:\n- To avoid nondeterminism and livelock in this exercise, a single global tie-breaker identifies the thread identifier allowed to acquire the irrevocable right next. Only the thread whose identifier equals this tie-breaker may acquire the irrevocable right when it attempts an irrevocable free; other threads attempting an irrevocable free must abort immediately. If the tie-breaker is set to $-1$, all threads are allowed to attempt acquisition, but in this problem’s test suite the tie-breaker is set to a specific thread identifier wherever multiple threads perform irrevocable free operations concurrently.\n\nYour program must:\n- Simulate the above transactional per-thread allocator semantics using atomic operations only (no locks), utilizing threads for concurrency. You must use integer bytes, with all accounting in bytes.\n- Produce a single line of output containing the aggregated results for the provided test suite in the exact specified format.\n\nTest suite to implement:\n- Test case $1$ (happy path, no irrevocable operations):\n  - Threads: $2$; tie-breaker $=-1$.\n  - Initial locals: $L_0 = 0$, $L_1 = 0$; set $G = 0$.\n  - Operations:\n    - Thread $0$: allocate $100$, allocate $50$, free $70$.\n    - Thread $1$: allocate $30$, free $10$, allocate $5$.\n  - Expected properties: both transactions commit; final accounting must be consistent.\n- Test case $2$ (irrevocable free serialization):\n  - Threads: $3$; tie-breaker $=0$.\n  - Initial locals: $L_0 = 200$, $L_1 = 150$, $L_2 = 0$; set $G = 350$.\n  - Operations:\n    - Thread $0$: irrevocable free $200$.\n    - Thread $1$: irrevocable free $150$.\n    - Thread $2$: allocate $60$.\n  - Expected properties: thread $0$ commits its irrevocable free; thread $1$ aborts on attempting irrevocable free due to the tie-breaker; thread $2$ commits; final accounting must be consistent.\n- Test case $3$ (zero net delta, commit succeeds):\n  - Threads: $1$; tie-breaker $=-1$.\n  - Initial locals: $L_0 = 100$; set $G = 100$.\n  - Operations:\n    - Thread $0$: allocate $100$, free $100$.\n  - Expected properties: commit succeeds with $\\Delta = 0$; final accounting must be consistent.\n- Test case $4$ (safety abort on negative local):\n  - Threads: $1$; tie-breaker $=-1$.\n  - Initial locals: $L_0 = 50$; set $G = 50$.\n  - Operations:\n    - Thread $0$: free $60$.\n  - Expected properties: transaction aborts because $L_0 + \\Delta = 50 - 60 = -10$ would be negative; final accounting must be consistent.\n\nRequired output format:\n- For each test case $i$, compute the final global total bytes $G_i$ (an integer), the number of committed transactions $C_i$ (an integer), the number of aborted transactions $A_i$ (an integer), and a consistency indicator $B_i$ (a boolean expressed as $1$ for true and $0$ for false) for whether $G_i = \\sum L_j^{\\text{final}}$ holds.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact order: $[G_1,C_1,A_1,B_1,G_2,C_2,A_2,B_2,G_3,C_3,A_3,B_3,G_4,C_4,A_4,B_4]$.\n\nAll answers are integers. No user input is allowed; all data is hardcoded as specified above.",
            "solution": "The problem requires the design and implementation of a deterministic simulation for a nonblocking, transactional memory allocator. The solution adheres to the specified behavioral rules, employing atomic operations for concurrency control as mandated. The core of the solution is a C program that simulates four distinct test cases, each involving multiple threads executing transactions, and then aggregates the results into a single formatted output line.\n\nThe logical design is founded on the following principles:\n\n1.  **State Representation**: The system's state is partitioned into shared global state and per-thread local state.\n    -   The global total of allocated bytes, $G$, is represented by an `_Atomic long` variable. This ensures that updates from concurrent committing transactions are correctly serialized and applied without data races.\n    -   The ownership for irrevocable free operations is managed by a single global `_Atomic int` variable, `irrevocable_owner`. A value of $-1$ signifies that the right is unowned. A thread with ID $i$ acquires the right by successfully executing a compare-and-swap (CAS) operation to change the value from $-1$ to $i$.\n    -   Per-thread local allocations, $L_i$, are stored in a standard `long` array. Since each thread $i$ exclusively modifies its own element $L_i$ (and only upon a successful commit), direct atomic operations on this array are not necessary. Access by the main thread for verification occurs only after all worker threads have terminated, thus preventing race conditions.\n    -   Aggregate statistics for each test case—the number of committed transactions $C_i$ and aborted transactions $A_i$—are also modeled as `_Atomic int` counters to allow for safe concurrent increments.\n\n2.  **Transactional Execution Model**: Each thread's execution is modeled as a single, all-or-nothing transaction. A dedicated thread function implements this logic.\n    -   **Accumulation Phase**: The thread first processes its assigned sequence of operations (`allocate`, `free`, `irrevocable free`). It calculates the net change in allocation, $\\Delta$, in a private local variable.\n    -   **Abort Conditions**: The transaction is designed to abort immediately under specific conditions, ensuring forward progress and correctness without locks.\n        -   **Irrevocable Free Failure**: An attempt to perform an `irrevocable free` triggers an abort if (a) a `tie_breaker` is active and the thread's ID does not match, or (b) the thread fails to acquire the global irrevocable ownership via CAS because it is already held.\n        -   **Safety Violation**: Before committing, the transaction verifies that the commit would not result in a negative local allocation. If $L_i + \\Delta < 0$, the transaction must abort.\n    -   **Commit/Abort Logic**:\n        -   **On Commit**: If no abort conditions are met, the transaction commits. The calculated $\\Delta$ is atomically added to the global total $G$ using `atomic_fetch_add`. The thread's local allocation is updated: $L_i \\leftarrow L_i + \\Delta$. If the thread had acquired the irrevocable right, it releases it by atomically setting `irrevocable_owner` back to $-1$. Finally, the global commit counter $C_i$ is atomically incremented.\n        -   **On Abort**: The global state $G$ and the local state $L_i$ remain unchanged. If the thread had acquired the irrevocable right during the transaction attempt, it must release it to prevent deadlock. The global abort counter $A_i$ is atomically incremented.\n\n3.  **Concurrency and Determinism**: The simulation utilizes the C `threads.h` library to create and manage threads, thereby modeling the specified concurrent environment. However, the problem's strict rules, including a fixed sequence of operations for each thread and a deterministic tie-breaker for irrevocable operations, eliminate runtime nondeterminism. This ensures that the simulation yields a single, predictable, and verifiable outcome for each test case.\n\n4.  **Verification**: After all threads for a given test case have completed their execution and are joined, the main thread performs a final consistency check. It calculates the sum of all final per-thread local allocations, $\\sum L_j^{\\text{final}}$, and compares it to the final global allocation total, $G_i$. The result of this check is stored as a boolean indicator, $B_i$, which must be true ($1$) if the simulation is correct. This validates the fundamental invariant $G = \\sum L_j$.\n\nThe implementation systematically applies these principles to each of the four test cases. A `TestCase` data structure is defined to hold the initial parameters ($L_i$ values, tie-breaker) and the list of operations for each thread. The main program iterates through these test cases, sets up the initial state, runs the concurrent simulation, and collects the final results ($G_i, C_i, A_i, B_i$). Finally, it prints all collected results in the precisely specified comma-separated format.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// #include <math.h>\n// #include <complex.h>\n#include <threads.h>\n#include <stdatomic.h>\n\n// Enum and structs for defining operations and test cases.\ntypedef enum { ALLOC, FREE, IRREVOCABLE_FREE } OpType;\n\ntypedef struct {\n    OpType type;\n    long amount;\n} Operation;\n\ntypedef struct {\n    int num_threads;\n    int tie_breaker;\n    const long* initial_local_bytes;\n    const int* ops_per_thread;\n    Operation const* const* ops_list;\n} TestCase;\n\n// Struct for passing arguments to each thread.\ntypedef struct {\n    int thread_id;\n    int num_ops;\n    const Operation* ops;\n\n    // Shared state pointers\n    _Atomic long* global_total;\n    long* local_bytes_array;\n    _Atomic int* irrevocable_owner;\n    int tie_breaker;\n    _Atomic int* committed_count;\n    _Atomic int* aborted_count;\n} ThreadArgs;\n\n// The function executed by each thread to run one transaction.\nint run_transaction(void* arg) {\n    ThreadArgs* args = (ThreadArgs*)arg;\n    \n    long delta = 0;\n    int must_abort = 0;\n    int acquired_irrevocable_right = 0;\n    const int UNOWNED = -1;\n\n    // 1. Process operation sequence to compute delta and check for abort conditions.\n    for (int i = 0; i < args->num_ops; ++i) {\n        Operation op = args->ops[i];\n        switch (op.type) {\n            case ALLOC:\n                delta += op.amount;\n                break;\n            case FREE:\n                delta -= op.amount;\n                break;\n            case IRREVOCABLE_FREE:\n                // Tie-breaker check\n                if (args->tie_breaker != -1 && args->thread_id != args->tie_breaker) {\n                    must_abort = 1;\n                    goto end_op_loop;\n                }\n                \n                // CAS to acquire ownership\n                int expected_owner = UNOWNED;\n                if (!atomic_compare_exchange_strong(args->irrevocable_owner, &expected_owner, args->thread_id)) {\n                    must_abort = 1;\n                    goto end_op_loop;\n                }\n                \n                acquired_irrevocable_right = 1;\n                delta -= op.amount;\n                break;\n        }\n    }\nend_op_loop:;\n\n    // 2. Further pre-commit check for negative local allocation.\n    if (!must_abort) {\n        if (args->local_bytes_array[args->thread_id] + delta < 0) {\n            must_abort = 1;\n        }\n    }\n    \n    // 3. Commit or Abort.\n    if (must_abort) {\n        // ABORT\n        atomic_fetch_add(args->aborted_count, 1);\n        if (acquired_irrevocable_right) {\n            atomic_store(args->irrevocable_owner, UNOWNED);\n        }\n    } else {\n        // COMMIT\n        atomic_fetch_add(args->global_total, delta);\n        args->local_bytes_array[args->thread_id] += delta;\n        \n        if (acquired_irrevocable_right) {\n            atomic_store(args->irrevocable_owner, UNOWNED);\n        }\n        \n        atomic_fetch_add(args->committed_count, 1);\n    }\n    \n    return thrd_success;\n}\n\nint main(void) {\n    // Define the test case data statically.\n    // Test Case 1 Data\n    const Operation tc1_t0_ops[] = {{ALLOC, 100}, {ALLOC, 50}, {FREE, 70}};\n    const Operation tc1_t1_ops[] = {{ALLOC, 30}, {FREE, 10}, {ALLOC, 5}};\n    Operation const* const tc1_ops_list[] = {tc1_t0_ops, tc1_t1_ops};\n    const long tc1_initial_locals[] = {0, 0};\n    const int tc1_ops_per_thread[] = {3, 3};\n\n    // Test Case 2 Data\n    const Operation tc2_t0_ops[] = {{IRREVOCABLE_FREE, 200}};\n    const Operation tc2_t1_ops[] = {{IRREVOCABLE_FREE, 150}};\n    const Operation tc2_t2_ops[] = {{ALLOC, 60}};\n    Operation const* const tc2_ops_list[] = {tc2_t0_ops, tc2_t1_ops, tc2_t2_ops};\n    const long tc2_initial_locals[] = {200, 150, 0};\n    const int tc2_ops_per_thread[] = {1, 1, 1};\n\n    // Test Case 3 Data\n    const Operation tc3_t0_ops[] = {{ALLOC, 100}, {FREE, 100}};\n    Operation const* const tc3_ops_list[] = {tc3_t0_ops};\n    const long tc3_initial_locals[] = {100};\n    const int tc3_ops_per_thread[] = {2};\n\n    // Test Case 4 Data\n    const Operation tc4_t0_ops[] = {{FREE, 60}};\n    Operation const* const tc4_ops_list[] = {tc4_t0_ops};\n    const long tc4_initial_locals[] = {50};\n    const int tc4_ops_per_thread[] = {1};\n\n    TestCase test_cases[] = {\n        {2, -1, tc1_initial_locals, tc1_ops_per_thread, tc1_ops_list},\n        {3, 0, tc2_initial_locals, tc2_ops_per_thread, tc2_ops_list},\n        {1, -1, tc3_initial_locals, tc3_ops_per_thread, tc3_ops_list},\n        {1, -1, tc4_initial_locals, tc4_ops_per_thread, tc4_ops_list}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long results[num_cases * 4];\n\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase* tc = &test_cases[i];\n        \n        // Initialize shared state\n        _Atomic long global_total;\n        long initial_global = 0;\n        long* local_bytes_array = (long*)malloc(tc->num_threads * sizeof(long));\n        for(int j = 0; j < tc->num_threads; ++j) {\n            local_bytes_array[j] = tc->initial_local_bytes[j];\n            initial_global += tc->initial_local_bytes[j];\n        }\n        atomic_init(&global_total, initial_global);\n\n        _Atomic int irrevocable_owner;\n        atomic_init(&irrevocable_owner, -1);\n        _Atomic int committed_count;\n        atomic_init(&committed_count, 0);\n        _Atomic int aborted_count;\n        atomic_init(&aborted_count, 0);\n        \n        thrd_t* threads = (thrd_t*)malloc(tc->num_threads * sizeof(thrd_t));\n        ThreadArgs* args = (ThreadArgs*)malloc(tc->num_threads * sizeof(ThreadArgs));\n\n        // Create and launch threads\n        for (int j = 0; j < tc->num_threads; ++j) {\n            args[j] = (ThreadArgs){\n                .thread_id = j,\n                .num_ops = tc->ops_per_thread[j],\n                .ops = tc->ops_list[j],\n                .global_total = &global_total,\n                .local_bytes_array = local_bytes_array,\n                .irrevocable_owner = &irrevocable_owner,\n                .tie_breaker = tc->tie_breaker,\n                .committed_count = &committed_count,\n                .aborted_count = &aborted_count\n            };\n            thrd_create(&threads[j], run_transaction, &args[j]);\n        }\n        \n        // Wait for all threads to complete\n        for (int j = 0; j < tc->num_threads; ++j) {\n            thrd_join(threads[j], NULL);\n        }\n\n        // Collect results\n        results[i * 4 + 0] = atomic_load(&global_total);\n        results[i * 4 + 1] = atomic_load(&committed_count);\n        results[i * 4 + 2] = atomic_load(&aborted_count);\n        \n        // Consistency check\n        long final_local_sum = 0;\n        for (int j = 0; j < tc->num_threads; ++j) {\n            final_local_sum += local_bytes_array[j];\n        }\n        results[i * 4 + 3] = (atomic_load(&global_total) == final_local_sum);\n\n        free(threads);\n        free(args);\n        free(local_bytes_array);\n    }\n\n    // Print the results in the EXACT required format.\n    printf(\"[\");\n    for (int i = 0; i < num_cases * 4 - 1; ++i) {\n        printf(\"%ld,\", results[i]);\n    }\n    printf(\"%ld]\\n\", results[num_cases * 4 - 1]);\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}