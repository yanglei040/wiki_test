{
    "hands_on_practices": [
        {
            "introduction": "To effectively use load-linked and store-conditional primitives, it is crucial to understand their underlying hardware mechanism. An LL/SC pair does not operate on an infinitesimally small point in memory, but rather on a \"reservation granule,\" which is often the size of a cache line. This practice guides you through a simulation to explore how an interfering store to a different address within the same granule can cause an SC to fail, providing a concrete model for this important behavior. ",
            "id": "3654106",
            "problem": "You are asked to formalize the semantics of load-linked and store-conditional primitives using a simplified and scientifically realistic model, and then implement a program that simulates an experiment to infer the monitor scope. The core scientific base you must rely on is the following definition: a load-linked operation sets a reservation on a reservation granule containing an address, and a subsequent store-conditional to that same address will succeed if and only if no store to any byte in that granule has occurred since the reservation was established. The reservation granule size is unknown a priori and is the quantity that determines the monitor scope.\n\nIn this problem, assume the following fundamental model that abstracts common hardware behavior:\n- A memory line has size $L$ bytes.\n- Addresses inside a line are word-aligned with word size $W$ bytes, yielding $n = L / W$ aligned target addresses per line at byte offsets $t_i = i \\cdot W$ for $i \\in \\{0, 1, \\dots, n-1\\}$.\n- A load-linked on a target offset $t_i$ sets a reservation on the reservation granule of size $g$ bytes that contains $t_i$. Define the granule index function $G(x; g) = \\left\\lfloor x / g \\right\\rfloor$.\n- Between the load-linked and store-conditional, an adversary issues a set of interfering stores at byte offsets $S = \\{s_0, s_1, \\dots, s_{m-1}\\}$. An interfering store $s_j$ is considered “in the same line” if and only if $0 \\le s_j < L$; otherwise it is to a different line and does not affect the reservation.\n- Under this model, the store-conditional to $t_i$ fails if and only if there exists at least one interfering store $s_j \\in S$ with $0 \\le s_j < L$ such that $G(s_j; g) = G(t_i; g)$. Otherwise, it succeeds.\n\nYour task is to implement an experiment simulator for a given memory line size $L$, word size $W$, and set $S$ of interfering store offsets. The simulator must iterate over all aligned targets $t_i = i \\cdot W$ for $i \\in \\{0, \\dots, n-1\\}$, determine whether the store-conditional fails under hypothesized reservation granule sizes $g \\in \\{8, 16, 64\\}$ bytes, and count the number of failures across all $n$ targets for each hypothesized $g$.\n\nTest suite:\nYou must hard-code the following test cases, each specified by $(L, W, S)$ with $L$ in bytes, $W$ in bytes, and $S$ a set of byte offsets:\n- Test A: $L = 64$, $W = 8$, $S = \\{16\\}$.\n- Test B: $L = 64$, $W = 4$, $S = \\{80\\}$.\n- Test C: $L = 64$, $W = 16$, $S = \\{31\\}$.\n- Test D: $L = 64$, $W = 64$, $S = \\{8\\}$.\n- Test E: $L = 64$, $W = 4$, $S = \\{4, 20, 36, 52\\}$.\n\nFor each test case, compute the number of store-conditional failures across all $n = L/W$ aligned targets for each $g \\in \\{8, 16, 64\\}$. An interfering store affects the outcome for a target only if it is within the same line, that is, if $0 \\le s_j < L$. The answers for each test case are thus three integers representing the failure counts for $g = 8$, $g = 16$, and $g = 64$, respectively.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the results for all tests concatenated in the order A, B, C, D, E, and, within each test, in the order $g = 8$, then $g = 16$, then $g = 64$. For example, the output format is\n`[a8,a16,a64,b8,b16,b64,c8,c16,c64,d8,d16,d64,e8,e16,e64]`\nwhere each symbol such as $a8$ denotes the integer failure count for the specified test and granule size.\n\nYour solution must be a complete, runnable program that implements this simulation exactly as specified and prints only the single line described above. No user input is required or permitted. All answers are integers; no physical units or angles are involved.",
            "solution": "The problem has been validated and is determined to be a well-posed, scientifically grounded exercise in modeling a fundamental concept in computer science and operating systems. The provided model for load-linked and store-conditional primitives, while simplified, captures the essential mechanics of reservation-based atomic operations found in many processor architectures. We will now proceed with a formal solution.\n\n### Principle-Based Model Formalization\n\nThe problem is centered on a formal model of how load-linked/store-conditional (LL/SC) operations interact with interfering memory stores. The key elements of this model are:\n\n1.  **Memory Layout**: A memory line is of size $L$ bytes. Accesses are made to word-aligned addresses. With a word size of $W$ bytes, there are $n = L/W$ possible target addresses within the line. These target byte offsets are given by $t_i = i \\cdot W$ for the target index $i \\in \\{0, 1, \\dots, n-1\\}$.\n\n2.  **Reservation Granule**: A `load-linked` operation on a target address $t_i$ establishes a reservation on a \"reservation granule\" of size $g$ bytes. The model defines the granule containing a byte offset $x$ by its index, computed by the function $G(x; g) = \\lfloor x / g \\rfloor$. This corresponds to integer division for non-negative offsets.\n\n3.  **Interference and Failure Condition**: A subsequent `store-conditional` operation to the target address $t_i$ is subject to interference from a set of adversarial stores occurring at byte offsets $S = \\{s_0, s_1, \\dots, s_{m-1}\\}$. A store $s_j$ is considered a potential interference only if it is within the same memory line as the targets, i.e., $0 \\le s_j < L$. The `store-conditional` to $t_i$ fails if and only if at least one such in-line store $s_j$ falls within the same reservation granule as the target $t_i$. Formally, failure occurs if:\n    $$ \\exists s_j \\in S \\text{ such that } (0 \\le s_j < L) \\land (G(s_j; g) = G(t_i; g)) $$\n    Otherwise, the `store-conditional` succeeds.\n\nOur task is to simulate this process for a given test suite, calculating the total number of target addresses for which the `store-conditional` would fail, for each hypothesized granule size $g \\in \\{8, 16, 64\\}$ bytes.\n\n### Algorithmic Solution\n\nThe simulation follows a direct implementation of the model's rules. For each test case defined by $(L, W, S)$ and for each hypothesized granule size $g$, the algorithm is as follows:\n\n1.  Initialize a failure counter for the current test case and granule size to $0$.\n2.  Calculate the number of aligned targets, $n = L/W$.\n3.  Iterate through each target index $i$ from $0$ to $n-1$.\n    a. Determine the target offset $t_i = i \\cdot W$.\n    b. Calculate the granule index for this target: $G_t = \\lfloor t_i / g \\rfloor$.\n    c. Set a flag, `failure_for_this_target`, to false.\n    d. Iterate through each store offset $s_j$ in the set $S$.\n        i. Check if the store is within the line: $0 \\le s_j < L$.\n        ii. If it is, calculate the store's granule index: $G_s = \\lfloor s_j / g \\rfloor$.\n        iii. If $G_s = G_t$, the condition for failure is met. Set `failure_for_this_target` to true and break the inner loop over the stores, as one interference is sufficient.\n    e. If `failure_for_this_target` is true, increment the failure counter.\n4.  After iterating through all targets, the value of the failure counter is the result for the given $(L, W, S, g)$.\n\n### Worked Example: Test Case C\n\nLet's apply this algorithm to Test Case C: $L = 64$, $W = 16$, $S = \\{31\\}$.\n-   Number of targets $n = L/W = 64/16 = 4$.\n-   Target offsets $t_i$: $\\{t_0, t_1, t_2, t_3\\} = \\{0, 16, 32, 48\\}$.\n-   Interfering store $s_0 = 31$. This is in-line, since $0 \\le 31 < 64$. We must check for interference from this store.\n\n**Case 1: Granule Size $g=8$**\n-   Granule index of the store: $G(31; 8) = \\lfloor 31 / 8 \\rfloor = 3$.\n-   Granule indices of the targets:\n    -   $G(t_0; 8) = G(0; 8) = 0$.\n    -   $G(t_1; 8) = G(16; 8) = 2$.\n    -   $G(t_2; 8) = G(32; 8) = 4$.\n    -   $G(t_3; 8) = G(48; 8) = 6$.\n-   The store's granule index ($3$) does not match any of the targets' granule indices ($\\{0, 2, 4, 6\\}$).\n-   Result: **$0$ failures**.\n\n**Case 2: Granule Size $g=16$**\n-   Granule index of the store: $G(31; 16) = \\lfloor 31 / 16 \\rfloor = 1$.\n-   Granule indices of the targets:\n    -   $G(t_0; 16) = G(0; 16) = 0$.\n    -   $G(t_1; 16) = G(16; 16) = 1$. (Match)\n    -   $G(t_2; 16) = G(32; 16) = 2$.\n    -   $G(t_3; 16) = G(48; 16) = 3$.\n-   The store's granule index ($1$) matches the granule index for target $t_1$.\n-   Result: **$1$ failure**.\n\n**Case 3: Granule Size $g=64$**\n-   Granule index of the store: $G(31; 64) = \\lfloor 31 / 64 \\rfloor = 0$.\n-   Granule indices of the targets:\n    -   $G(t_0; 64) = G(0; 64) = 0$. (Match)\n    -   $G(t_1; 64) = G(16; 64) = 0$. (Match)\n    -   $G(t_2; 64) = G(32; 64) = 0$. (Match)\n    -   $G(t_3; 64) = G(48; 64) = 0$. (Match)\n-   The store's granule index ($0$) matches the granule index for all $4$ targets.\n-   Result: **$4$ failures**.\n\nThe computed results for Test Case C are thus $[0, 1, 4]$. By applying this same procedure to all test cases, we obtain the complete set of results.\n\n### Summary of Calculated Results\n\n-   **Test A** ($L=64, W=8, S=\\{16\\}$): $[1, 2, 8]$\n-   **Test B** ($L=64, W=4, S=\\{80\\}$): $[0, 0, 0]$ (store is out of line)\n-   **Test C** ($L=64, W=16, S=\\{31\\}$): $[0, 1, 4]$\n-   **Test D** ($L=64, W=64, S=\\{8\\}$): $[0, 1, 1]$\n-   **Test E** ($L=64, W=4, S=\\{4, 20, 36, 52\\}$): $[8, 16, 16]$\n\nThe final program will concatenate these results in the specified order.",
            "answer": "```c\n// The complete and compilable C program.\n// Headers adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int L;               // Memory line size in bytes\n    int W;               // Word size in bytes\n    const int* S;        // Pointer to an array of interfering store offsets\n    int s_count;         // Number of elements in the store offset array S\n} TestCase;\n\nint main(void) {\n    // Define the interfering store sets for each test case.\n    static const int S_A[] = {16};\n    static const int S_B[] = {80};\n    static const int S_C[] = {31};\n    static const int S_D[] = {8};\n    static const int S_E[] = {4, 20, 36, 52};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {64, 8,  S_A, sizeof(S_A) / sizeof(S_A[0])}, // Test A\n        {64, 4,  S_B, sizeof(S_B) / sizeof(S_B[0])}, // Test B\n        {64, 16, S_C, sizeof(S_C) / sizeof(S_C[0])}, // Test C\n        {64, 64, S_D, sizeof(S_D) / sizeof(S_D[0])}, // Test D\n        {64, 4,  S_E, sizeof(S_E) / sizeof(S_E[0])}  // Test E\n    };\n    \n    // Define hypothesized reservation granule sizes.\n    const int granule_sizes[] = {8, 16, 64};\n    const int num_granules = sizeof(granule_sizes) / sizeof(granule_sizes[0]);\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases * num_granules];\n    int result_idx = 0;\n\n    // Calculate the result for each test case and each granule size.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase current_case = test_cases[i];\n        int L = current_case.L;\n        int W = current_case.W;\n        const int* S = current_case.S;\n        int s_count = current_case.s_count;\n\n        for (int j = 0; j < num_granules; ++j) {\n            int g = granule_sizes[j];\n            int failure_count = 0;\n            \n            // Number of aligned targets per line.\n            int n = L / W;\n\n            // Iterate over all aligned targets.\n            for (int k = 0; k < n; ++k) {\n                int target_offset = k * W;\n                int target_granule = target_offset / g;\n                \n                int has_failed = 0; // Using int as boolean as stdbool.h is not specified.\n\n                // Check for interference from any store.\n                for (int m = 0; m < s_count; ++m) {\n                    int store_offset = S[m];\n\n                    // An interfering store must be in the same line.\n                    if (store_offset >= 0 && store_offset < L) {\n                        int store_granule = store_offset / g;\n                        \n                        // Condition for store-conditional failure.\n                        if (store_granule == target_granule) {\n                            has_failed = 1;\n                            break; // One interfering store is sufficient.\n                        }\n                    }\n                }\n\n                if (has_failed) {\n                    failure_count++;\n                }\n            }\n            results[result_idx++] = failure_count;\n        }\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases * num_granules; ++i) {\n        printf(\"%d\", results[i]);\n        if (i < (num_cases * num_granules - 1)) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "With a grasp of the LL/SC mechanism, we can now apply it to build fundamental synchronization tools. This exercise challenges you to implement a concurrent, modular fetch-and-add operation—a cornerstone of many lock-free data structures—using a classic LL/SC retry loop. You will verify its correctness against the formal property of linearizability, considering practical details like integer wraparound, spurious SC failures, and the behavior under multi-threaded contention. ",
            "id": "3654150",
            "problem": "You are given the task to determine, by construction and verification, whether the abstract Load-Linked (LL) and Store-Conditional (SC) primitives can implement a correct modular fetch-add operation under concurrent execution, while properly handling integer wraparound and spurious failure, and while preserving linearizability. The verification must be expressed as a runnable program that operates purely on mathematical and logical constructs, with no external inputs. The program must implement a simulated LL/SC-based modular fetch-add, execute a bounded set of concurrent operations, and then decide correctness based on formal criteria derived from first principles.\n\nDefinitions and foundational base:\n- A shared memory location is a single-writer variable that can be read and written atomically. Define the shared state as an unsigned integer in the set $\\{0,1,\\dots,M-1\\}$ where $M = 2^w$ for a given bit-width $w$.\n- Load-Linked (LL) reads the current value $x$ of a shared memory location and links it, making a subsequent store-conditional conditional upon no intervening write occurring.\n- Store-Conditional (SC) attempts to write a new value $y$ to the same location and succeeds only if no intervening write occurred since the paired Load-Linked. Store-Conditional may also fail spuriously even if there was no intervening write.\n- A modular fetch-add on integer modulo $M$ with addend $a$ maps state $x$ to new state $(x + a) \\bmod M$ and returns the old state $x$ to the caller. The sequential specification for $N$ such operations from initial state $x_0$ yields the sequence of returned values $r_i = (x_0 + i \\cdot a) \\bmod M$ for $i \\in \\{0,1,\\dots,N-1\\}$ and the final state $x_N = (x_0 + N \\cdot a) \\bmod M$.\n- Linearizability requires each operation to appear as if it took effect at a single instant between its invocation and response, and the overall effect must be equivalent to the sequential specification described above.\n- The wraparound behavior is modeled exactly by arithmetic modulo $M = 2^w$. Integer overflow is not an error; it manifests as wraparound due to the modulo operation. Short cycles arise when $\\gcd(a, M) > 1$, giving a cycle length $L = \\frac{M}{\\gcd(a, M)}$; after $L$ operations, the sequence of returned values repeats.\n\nYour program must:\n- Implement a simulated LL/SC-based modular fetch-add function that:\n  - Reads the current value $x$.\n  - Computes $y = (x + a) \\bmod M$.\n  - Attempts a conditional store of $y$, looping until successful. The function may inject deterministic spurious failures of Store-Conditional with a specified periodicity to model that Store-Conditional can fail even without interference.\n  - Returns the old value $x$ observed on the successful Store-Conditional.\n- Execute a set of concurrent threads, each performing a specified number of fetch-add operations with the same addend $a$ on the shared counter modulo $M$ starting from initial state $x_0$.\n- Collect all returned old values and verify the following correctness criteria for linearizability and wraparound:\n  1. The final value equals $x_N = (x_0 + N \\cdot a) \\bmod M$, where $N$ is the total number of operations performed across all threads.\n  2. The multiset of returned old values equals the multiset $\\{(x_0 + i \\cdot a) \\bmod M \\mid i = 0,1,\\dots,N-1\\}$, accounting for wraparound and possible cycle repetition when $\\gcd(a, M) > 1$.\n\nTest suite:\nProvide the following test cases, each defined by the tuple $(w, x_0, a, T, K, s)$ where $w$ is the bit-width, $x_0$ is the initial state, $a$ is the addend, $T$ is the number of threads, $K$ is the number of operations per thread, and $s$ is the spurious-failure periodicity (with $s = 0$ meaning disabled). Let $M = 2^w$ and $N = T \\cdot K$.\n- Test case $1$: $(w, x_0, a, T, K, s) = (8, 5, 1, 4, 10, 0)$. This is a general case; $N = 40$; no wraparound occurs since $5 + 40 < 256$.\n- Test case $2$: $(w, x_0, a, T, K, s) = (8, 250, 1, 2, 10, 0)$. This exercises wraparound; $N = 20$; the final value is $(250 + 20) \\bmod 256 = 14$.\n- Test case $3$: $(w, x_0, a, T, K, s) = (8, 3, 2, 3, 60, 0)$. This emphasizes cycle repetition since $\\gcd(2, 256) = 2$; the cycle length is $L = \\frac{256}{2} = 128$, so duplicates arise in the returned values multiset when $N = 180 > 128$.\n- Test case $4$: $(w, x_0, a, T, K, s) = (8, 0, 1, 3, 50, 2)$. This injects deterministic spurious Store-Conditional failures every $2$ attempts while still requiring progress; $N = 150$; final value is $(0 + 150) \\bmod 256 = 150$.\n\nOutput specification:\n- For each test case $i \\in \\{1,2,3,4\\}$, the program must compute a boolean indicator $b_i$ equal to $1$ if both correctness criteria hold and equal to $0$ otherwise.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact format $[b_1,b_2,b_3,b_4]$.",
            "solution": "We begin from the fundamental definitions of Load-Linked and Store-Conditional. Load-Linked (LL) reads the current value and establishes a link that can be invalidated by any intervening write. Store-Conditional (SC) attempts to write a new value and succeeds only if this link remains valid. Importantly, Store-Conditional may fail spuriously, even if there was no intervening write. The atomic modular fetch-add with addend $a$ and modulus $M = 2^w$ is specified such that an operation reading state $x$ produces new state $y = (x + a) \\bmod M$ and returns the old state $x$.\n\nThe sequential specification across $N$ operations, starting from state $x_0$, yields:\n- Returned values sequence: $r_i = (x_0 + i \\cdot a) \\bmod M$ for $i \\in \\{0,1,\\dots,N-1\\}$.\n- Final state: $x_N = (x_0 + N \\cdot a) \\bmod M$.\n\nLinearizability requires that each operation appears to occur at an instant between its invocation and response, and the set of completed operations must be equivalent to the sequential specification. In LL/SC, each successful Store-Conditional is the linearization point, because the write occurs atomically only when no intervening write invalidated the link. Spurious failure does not compromise linearizability since no write occurs; the operation simply retries until success.\n\nAlgorithmic realization:\n- We simulate LL/SC using a loop composed of an atomic load, a computation of the new value modulo $M$, and an atomic conditional store that succeeds only if the previously read value remains current. Within each attempt, we optionally inject a deterministic spurious failure periodicity $s$: if the global attempt counter satisfies $\\text{attempt} \\bmod s = 0$ (and $s > 0$), we fail the Store-Conditional attempt without writing and retry. This models spurious failure while ensuring progress when $s$ is finite.\n- When the conditional store succeeds, we return the old value.\n\nCorrectness criteria derivation:\n1. Final state: Because each successful operation writes $y = (x + a) \\bmod M$ and the Store-Conditional constitutes the linearization point, and because the arithmetic is modulo $M$, after $N$ successful operations, the final state must be $x_N = (x_0 + N \\cdot a) \\bmod M$. Spurious failures increase the number of attempts but do not change the number of successful operations $N$ being executed, so they do not affect the final state.\n2. Returned values multiset: Each successful operation returns the old value $x$ that was read and linked by LL and that remained unchanged until SC. As the operations linearize in some order, there exists a permutation $\\pi$ of $\\{0,1,\\dots,N-1\\}$ such that the returned multiset equals $\\{(x_0 + i \\cdot a) \\bmod M \\mid i = 0,1,\\dots,N-1\\}$. Concurrency alters the order (the permutation) but not the multiset. When $\\gcd(a, M) > 1$, the sequence $r_i$ repeats with cycle length $L = \\frac{M}{\\gcd(a, M)}$. Thus duplicates in the multiset are expected whenever $N > L$. Our verification compares the observed multiset counts against the predicted counts from the sequential specification; equality establishes linearizability for the returned values.\n\nImplementation details:\n- We choose $w = 8$ for all test cases, so $M = 2^w = 256$. Masking by $M - 1$ implements wraparound in each update and guarantees that integer overflow manifests as modular reduction, as required.\n- For test case $1$, with $(w, x_0, a, T, K, s) = (8, 5, 1, 4, 10, 0)$, we have $N = 40$ and $x_N = (5 + 40) \\bmod 256 = 45$. No wraparound occurs and the multiset contains the consecutive values $5,6,\\dots,44$.\n- For test case $2$, with $(8, 250, 1, 2, 10, 0)$, we have $N = 20$ and $x_N = (250 + 20) \\bmod 256 = 14$. Wraparound occurs; the multiset contains values $250,251,\\dots,255,0,1,\\dots,13$.\n- For test case $3$, with $(8, 3, 2, 3, 60, 0)$, we have $N = 180$ and $x_N = (3 + 180 \\cdot 2) \\bmod 256 = 107$. Since $\\gcd(2, 256) = 2$, the cycle length is $L = 128$. Thus the multiset repeats after $128$ terms and the last $52$ terms duplicate the first $52$ terms.\n- For test case $4$, with $(8, 0, 1, 3, 50, 2)$, we have $N = 150$ and $x_N = 150$. Spurious failures every $2$ attempts do not change the multiset or the final state; they only increase attempts.\n\nVerification method:\n- After all threads complete, we load the final state and compute the expected $x_N$. We compare for equality.\n- We form the observed counts of returned values across $\\{0,1,\\dots,M-1\\}$. We form the predicted counts by enumerating $r_i = (x_0 + i \\cdot a) \\bmod M$ for $i = 0$ to $N - 1$. Equality of these histograms establishes the multiset property.\n- If both checks pass, we output $1$ for that test case; otherwise, we output $0$.\n\nThe final output is a single line $[b_1,b_2,b_3,b_4]$, where each $b_i$ is the boolean result for test case $i$ as defined above. This program concretely demonstrates that LL/SC correctly implements modular fetch-add with wraparound, handles integer overflow via modulo arithmetic, and preserves linearizability, including nuances arising from cycle length determined by $\\gcd(a, M)$ and deterministic spurious Store-Conditional failures.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <threads.h>\n#include <stdatomic.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    unsigned int w;            // bit width\n    unsigned long init;        // initial value x0\n    unsigned long inc;         // addend a\n    int threads;               // number of threads T\n    int ops_per_thread;        // operations per thread K\n    int spurious_every;        // periodicity for spurious SC failures (0 disables)\n} TestCase;\n\n// Global shared counter per test case will be passed as pointer.\n// We inject deterministic spurious failures via a global attempt counter per test case.\ntypedef struct {\n    atomic_ulong *counter;\n    unsigned long mask;             // M-1 where M=2^w\n    unsigned long inc;\n    int ops;                        // operations to perform in this worker\n    int spurious_every;\n    atomic_ulong *attempt_counter;  // global attempt counter for spurious failure injection\n    unsigned long *out;             // output array to store returned old values\n    int offset;                     // starting index in the output array\n} WorkerArgs;\n\n// Simulated LL/SC-based modular fetch-add.\n// Returns the old value. Uses compare_exchange_strong to mimic SC.\n// Injects deterministic spurious failure every spurious_every attempts (if >0).\nstatic unsigned long llsc_fetch_add_mod(atomic_ulong *addr,\n                                        unsigned long inc,\n                                        unsigned long mask,\n                                        int spurious_every,\n                                        atomic_ulong *attempt_counter) {\n    for (;;) {\n        // Load-Linked: read the current value.\n        unsigned long old = atomic_load_explicit(addr, memory_order_acquire);\n        unsigned long newv = (old + inc) & mask;\n\n        // Simulate an attempt number; increment global counter.\n        unsigned long attempt = atomic_fetch_add_explicit(attempt_counter, 1UL, memory_order_relaxed) + 1UL;\n\n        // Deterministic spurious failure: skip the store on periodic attempts.\n        if (spurious_every > 0) {\n            unsigned long se = (unsigned long)spurious_every;\n            if (se > 0UL && (attempt % se) == 0UL) {\n                // Simulate SC failure (no store), retry.\n                continue;\n            }\n        }\n\n        // Store-Conditional: succeed only if no intervening write occurred since load.\n        unsigned long expected = old;\n        if (atomic_compare_exchange_strong_explicit(addr,\n                                                    &expected,\n                                                    newv,\n                                                    memory_order_acq_rel,\n                                                    memory_order_acquire)) {\n            // Successful SC: linearization point.\n            return old;\n        }\n        // Else, someone else wrote since our LL; retry.\n    }\n}\n\n// Worker thread function: performs ops and records returned old values.\nstatic int worker(void *arg) {\n    WorkerArgs *a = (WorkerArgs *)arg;\n    for (int i = 0; i < a->ops; ++i) {\n        unsigned long old = llsc_fetch_add_mod(a->counter, a->inc, a->mask,\n                                               a->spurious_every, a->attempt_counter);\n        a->out[a->offset + i] = old;\n    }\n    return 0;\n}\n\n// Compute expected counts of returned values for the sequential spec: r_i = (init + i*inc) mod M.\nstatic void compute_expected_counts(unsigned long M,\n                                    unsigned long init,\n                                    unsigned long inc,\n                                    int N,\n                                    unsigned int *counts) {\n    for (unsigned long v = 0; v < M; ++v) counts[v] = 0U;\n    unsigned long mask = M - 1UL;\n    unsigned long base = init & mask;\n    unsigned long step = inc & mask;\n    unsigned long val = base;\n    // We will accumulate r_i for i=0..N-1 iteratively to avoid overflow concerns.\n    for (int i = 0; i < N; ++i) {\n        counts[val] += 1U;\n        val = (val + step) & mask;\n    }\n}\n\n// Compute observed counts from results array.\nstatic void compute_observed_counts(unsigned long M,\n                                    const unsigned long *results,\n                                    int N,\n                                    unsigned int *counts) {\n    for (unsigned long v = 0; v < M; ++v) counts[v] = 0U;\n    unsigned long mask = M - 1UL;\n    for (int i = 0; i < N; ++i) {\n        unsigned long v = results[i] & mask;\n        counts[v] += 1U;\n    }\n}\n\n// Verify final value and multiset equality.\nstatic int verify_case(const TestCase *tc,\n                       const unsigned long *results,\n                       atomic_ulong *counter) {\n    unsigned long M = 1UL << tc->w;\n    unsigned long mask = M - 1UL;\n    int N = tc->threads * tc->ops_per_thread;\n\n    // Verify final value.\n    unsigned long final_val = atomic_load_explicit(counter, memory_order_acquire);\n    unsigned long expected_final = (tc->init + (unsigned long)N * tc->inc) & mask;\n    int final_ok = (final_val == expected_final);\n\n    // Verify multiset equality via histogram comparison.\n    unsigned int *expected_counts = (unsigned int *)malloc((size_t)M * sizeof(unsigned int));\n    unsigned int *observed_counts = (unsigned int *)malloc((size_t)M * sizeof(unsigned int));\n    if (!expected_counts || !observed_counts) {\n        // On allocation failure, be conservative: mark failure.\n        if (expected_counts) free(expected_counts);\n        if (observed_counts) free(observed_counts);\n        return 0;\n    }\n    compute_expected_counts(M, tc->init, tc->inc, N, expected_counts);\n    compute_observed_counts(M, results, N, observed_counts);\n\n    int counts_ok = 1;\n    for (unsigned long v = 0; v < M; ++v) {\n        if (expected_counts[v] != observed_counts[v]) {\n            counts_ok = 0;\n            break;\n        }\n    }\n\n    free(expected_counts);\n    free(observed_counts);\n\n    return final_ok && counts_ok;\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        { 8U, 5UL,   1UL, 4, 10, 0 },  // Case 1\n        { 8U, 250UL, 1UL, 2, 10, 0 },  // Case 2\n        { 8U, 3UL,   2UL, 3, 60, 0 },  // Case 3\n        { 8U, 0UL,   1UL, 3, 50, 2 }   // Case 4: spurious every 2 attempts\n    };\n\n    int num_cases = (int)(sizeof(test_cases) / sizeof(test_cases[0]));\n    int results_pass[num_cases];\n\n    for (int ci = 0; ci < num_cases; ++ci) {\n        const TestCase *tc = &test_cases[ci];\n        unsigned long M = 1UL << tc->w;\n        unsigned long mask = M - 1UL;\n        int N = tc->threads * tc->ops_per_thread;\n\n        // Shared counter and attempt counter for spurious failures.\n        atomic_ulong counter;\n        atomic_ulong attempt_counter;\n        atomic_store_explicit(&counter, tc->init & mask, memory_order_release);\n        atomic_store_explicit(&attempt_counter, 0UL, memory_order_relaxed);\n\n        // Allocate array to collect returned old values.\n        unsigned long *returned = (unsigned long *)malloc((size_t)N * sizeof(unsigned long));\n        if (!returned) {\n            // If allocation fails, mark case as failed.\n            results_pass[ci] = 0;\n            continue;\n        }\n\n        // Create threads.\n        thrd_t *threads = (thrd_t *)malloc((size_t)tc->threads * sizeof(thrd_t));\n        WorkerArgs *args = (WorkerArgs *)malloc((size_t)tc->threads * sizeof(WorkerArgs));\n        if (!threads || !args) {\n            results_pass[ci] = 0;\n            free(returned);\n            if (threads) free(threads);\n            if (args) free(args);\n            continue;\n        }\n\n        // Assign work: contiguous segments for each thread.\n        for (int t = 0; t < tc->threads; ++t) {\n            args[t].counter = &counter;\n            args[t].mask = mask;\n            args[t].inc = tc->inc;\n            args[t].ops = tc->ops_per_thread;\n            args[t].spurious_every = tc->spurious_every;\n            args[t].attempt_counter = &attempt_counter;\n            args[t].out = returned;\n            args[t].offset = t * tc->ops_per_thread;\n            thrd_create(&threads[t], worker, &args[t]);\n        }\n\n        // Join threads.\n        for (int t = 0; t < tc->threads; ++t) {\n            thrd_join(threads[t], NULL);\n        }\n\n        // Verify this test case.\n        int pass = verify_case(tc, returned, &counter);\n        results_pass[ci] = pass;\n\n        // Cleanup.\n        free(threads);\n        free(args);\n        free(returned);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    // Single line: [b1,b2,b3,b4]\n    printf(\"[%d,%d,%d,%d]\\n\",\n           results_pass[0],\n           results_pass[1],\n           results_pass[2],\n           results_pass[3]);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Implementing correct lock-free algorithms with LL/SC is only half the battle; ensuring they perform well under contention is equally important. Since SC can fail, algorithms must retry, but how long should they wait? This practice moves from implementation to analysis, asking you to model the retry process mathematically and determine an optimal exponential backoff strategy that minimizes the total expected time to success. ",
            "id": "3654148",
            "problem": "A multicore system uses load-linked (LL) and store-conditional (SC) primitives to update a single shared memory word. Consider a single thread that repeatedly attempts the update until it succeeds. The interference from other cores that can invalidate the reservation is modeled as a homogeneous Poisson process of conflicting writes with rate $\\lambda$ per second, independent of the thread’s behavior.\n\nEach LL/SC attempt by the thread consists of immediately performing the LL followed by the SC, taking a deterministic time of $s$ seconds from the start of the LL to the end of the SC. The attempt succeeds if and only if no conflicting write occurs during this $s$-second interval; otherwise, the SC fails. On failure of the $i$-th attempt (for $i \\in \\{0,1,2,\\dots\\}$ with the first attempt indexed by $i=0$), the thread waits a backoff time $b(i+1) = c \\cdot 2^{i+1}$ seconds before trying again, where $c \\ge 0$ is a constant parameter to be chosen. The first attempt at $i=0$ incurs no backoff.\n\nAssuming that attempts continue until the first success, and using only fundamental properties of Poisson processes and basic probability, derive the expected total elapsed time from the start of the first attempt until the first successful SC as a function of $c$, $\\lambda$, and $s$. Then determine the value $c^{\\star} \\ge 0$ that minimizes this expected time. Express $c^{\\star}$ in seconds. If the expected time diverges for some parameter ranges, you must account for that in your minimization. No numerical approximations are required, and no rounding is needed.",
            "solution": "The problem asks for the expected total elapsed time for a thread to successfully update a shared memory word using load-linked (LL) and store-conditional (SC) primitives, and to find the backoff parameter $c$ that minimizes this time. The validation of the problem statement finds it to be scientifically grounded, well-posed, and objective. We may proceed with a formal solution.\n\nLet us begin by defining the parameters of a single LL/SC attempt. An attempt takes a deterministic time $s$. It fails if one or more conflicting writes occur during this interval. The conflicting writes are modeled as a homogeneous Poisson process with rate $\\lambda$. The number of conflicting writes, $N(s)$, in an interval of length $s$ follows a Poisson distribution with mean $\\mu = \\lambda s$.\nThe probability of success for a single attempt, $p$, is the probability of zero conflicting writes occurring in the $s$-second interval:\n$$p = P(N(s)=0) = \\frac{(\\lambda s)^0 \\exp(-\\lambda s)}{0!} = \\exp(-\\lambda s)$$\nThe probability of failure for a single attempt is $q = 1 - p = 1 - \\exp(-\\lambda s)$.\n\nThe thread repeatedly attempts the update until it succeeds. This can be modeled as a sequence of independent Bernoulli trials, each with a success probability of $p$. Let $K$ be the random variable representing the number of failed attempts before the first successful attempt. $K$ follows a geometric distribution with parameter $p$:\n$$P(K=k) = (1-p)^k p = q^k p, \\quad k \\in \\{0, 1, 2, \\dots\\}$$\n\nNow, let's determine the total time elapsed, $T_k$, if the process experiences $k$ failures followed by one success. This corresponds to a total of $k+1$ attempts. Each attempt takes $s$ seconds, so the total time spent executing the LL/SC pairs is $(k+1)s$.\nIn addition, after each of the $k$ failures, the thread waits for a backoff period. The $i$-th failure (for $i=0, 1, \\dots, k-1$) is followed by the $(i+1)$-th attempt, which is preceded by a backoff of $b(i+1) = c \\cdot 2^{i+1}$ seconds. The total backoff time for $k$ failures is the sum of the first $k$ backoff periods:\n$$\\text{Total Backoff Time} = \\sum_{j=1}^{k} b(j) = \\sum_{j=1}^{k} c \\cdot 2^j$$\nNote that this sum is empty (and thus equals $0$) if $k=0$, which is correct as there is no backoff before the first attempt.\nThe total elapsed time for $k$ failures is the sum of the time for the attempts and the backoff periods:\n$$T_k = (k+1)s + \\sum_{j=1}^{k} c \\cdot 2^j$$\n\nThe expected total elapsed time, $E[T]$, is found by summing $T_k$ over all possible values of $k$, weighted by their respective probabilities:\n$$E[T] = \\sum_{k=0}^{\\infty} T_k P(K=k) = \\sum_{k=0}^{\\infty} \\left( (k+1)s + \\sum_{j=1}^{k} c \\cdot 2^j \\right) q^k p$$\nWe can split this expectation into two parts:\n$$E[T] = s \\sum_{k=0}^{\\infty} (k+1) q^k p + c \\sum_{k=0}^{\\infty} \\left( \\sum_{j=1}^{k} 2^j \\right) q^k p$$\n\nThe first term is $s$ times the expected number of trials until the first success in a geometric distribution, which is $1/p$.\n$$s \\sum_{k=0}^{\\infty} (k+1) q^k p = s \\cdot E[K+1] = s \\cdot \\frac{1}{p} = s \\exp(\\lambda s)$$\n\nThe second term involves the backoff costs. Let's analyze the double summation:\n$$c p \\sum_{k=0}^{\\infty} q^k \\sum_{j=1}^{k} 2^j = c p \\sum_{k=1}^{\\infty} q^k \\sum_{j=1}^{k} 2^j$$\nWe can change the order of summation. The sum is over pairs $(j,k)$ such that $1 \\le j \\le k < \\infty$. This is equivalent to summing over $j \\ge 1$ and $k \\ge j$:\n$$c p \\sum_{j=1}^{\\infty} \\sum_{k=j}^{\\infty} q^k 2^j = c p \\sum_{j=1}^{\\infty} 2^j \\left( \\sum_{k=j}^{\\infty} q^k \\right)$$\nThe inner sum is a geometric series: $\\sum_{k=j}^{\\infty} q^k = q^j + q^{j+1} + \\dots = \\frac{q^j}{1-q} = \\frac{q^j}{p}$.\nSubstituting this back, we get:\n$$c p \\sum_{j=1}^{\\infty} 2^j \\left( \\frac{q^j}{p} \\right) = c \\sum_{j=1}^{\\infty} (2q)^j$$\nThis is another geometric series. It converges if and only if its ratio $|2q|$ is less than $1$. Since $q = 1-\\exp(-\\lambda s) \\ge 0$, the condition is $2q < 1$. If convergence holds, the sum is $\\frac{\\text{first term}}{1-\\text{ratio}} = \\frac{2q}{1-2q}$.\nThe condition $2q < 1$ translates to $2(1-\\exp(-\\lambda s)) < 1$, which simplifies to $1 - \\exp(-\\lambda s) < 1/2$, or $\\exp(-\\lambda s) > 1/2$. Taking the natural logarithm of both sides gives $-\\lambda s > \\ln(1/2) = -\\ln(2)$, which implies $\\lambda s < \\ln(2)$.\n\nThus, for $\\lambda s < \\ln(2)$, the expected total elapsed time is:\n$$E[T](c) = \\frac{s}{p} + c \\frac{2q}{1-2q} = s \\exp(\\lambda s) + c \\frac{2(1-\\exp(-\\lambda s))}{1 - 2(1-\\exp(-\\lambda s))} = s \\exp(\\lambda s) + c \\frac{2(1-\\exp(-\\lambda s))}{2\\exp(-\\lambda s) - 1}$$\nThis is the first part of the required derivation.\n\nNow, we must account for the case where the expectation may diverge.\nIf $\\lambda s \\ge \\ln(2)$, then $2q \\ge 1$.\nIf $c > 0$, the terms of the series $c \\sum (2q)^j$ are positive and do not tend to zero, so the series diverges. Since all terms in the original sum for $E[T]$ are non-negative, $E[T]$ diverges to infinity.\nIf $c=0$, the backoff term is zero for all $k$. In this case, $E[T]$ is simply the expectation of the time spent in attempts, which is $s/p = s \\exp(\\lambda s)$, a finite value.\n\nTo summarize the expected time as a function of $c$, $\\lambda$, and $s$ for $c \\ge 0$:\n$$E[T](c) = \\begin{cases} s \\exp(\\lambda s) + c \\frac{2(1-\\exp(-\\lambda s))}{2\\exp(-\\lambda s) - 1} & \\text{if } \\lambda s < \\ln(2) \\\\ s \\exp(\\lambda s) & \\text{if } \\lambda s \\ge \\ln(2) \\text{ and } c=0 \\\\ \\infty & \\text{if } \\lambda s \\ge \\ln(2) \\text{ and } c > 0 \\end{cases}$$\n\nThe second task is to find the value $c^{\\star} \\ge 0$ that minimizes $E[T](c)$. We analyze two cases.\n\nCase 1: $\\lambda s < \\ln(2)$\nIn this regime, $E[T](c)$ is a linear function of $c$. Let's examine the slope:\n$$\\frac{\\partial E[T]}{\\partial c} = \\frac{2(1-\\exp(-\\lambda s))}{2\\exp(-\\lambda s) - 1}$$\nThe numerator, $2(1-\\exp(-\\lambda s))$, is positive since $\\lambda > 0$ and $s > 0$.\nThe denominator, $2\\exp(-\\lambda s) - 1$, is also positive because the condition $\\lambda s < \\ln(2)$ implies $\\exp(-\\lambda s) > 1/2$.\nSince the slope is positive, $E[T](c)$ is a strictly increasing function of $c$ for $c \\ge 0$. The minimum value is therefore achieved at the smallest possible value of $c$, which is $c^{\\star}=0$.\n\nCase 2: $\\lambda s \\ge \\ln(2)$\nIn this regime, the expected time $E[T](c)$ is finite only at a single point in its domain $c \\ge 0$, namely at $c=0$, where $E[T](0) = s \\exp(\\lambda s)$. For any $c > 0$, the expected time is infinite. The minimum finite value of the expected time is thus achieved at $c^{\\star}=0$.\n\nIn both cases, the analysis leads to the same conclusion: the optimal value for the backoff parameter is $c^{\\star} = 0$. This result stems from the problem's key assumption that the interference process is independent of the thread's actions. Waiting does not increase the probability of success for the next attempt, so any time spent in backoff only increases the total expected time. The optimal strategy is to retry immediately upon failure.",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}