{
    "hands_on_practices": [
        {
            "introduction": "理论知识只有通过实践才能巩固。我们从一个基本但至关重要的问题开始：一个内存页究竟能容纳多少个对象？这个练习  将指导你计算在给定开销和对齐约束下，单个 slab 页面的对象容量，并量化由此产生的内部碎片。掌握这项技能是理解 slab 分配器空间效率的基础。",
            "id": "3683553",
            "problem": "在一个操作系统课程关于内存管理的 slab 分配场景中，考虑一个具有以下参数的固定大小对象的缓存：对象大小 $s=40$ 字节，页面大小 $P=4096$ 字节，每页 slab 头部大小 $h=64$ 字节，以及对齐要求 $a=8$ 字节。每个 slab 由一个页面支持，slab 头部占用页面的前 $h$ 个字节。对象必须在是 $a$ 字节倍数的地址处开始，并且每个对象槽的大小必须使其起始和结束都遵守 $a$ 字节的对齐约束。任何对齐填充，包括头部之后为对齐第一个对象所需的任何填充，以及因将 $s$ 向上舍入到对齐边界而产生的任何每个对象的填充，都不可用于有效载荷，并计为内部碎片。在放置最大数量的对象槽后，页面有效载荷中剩余的、不足以容纳另一个槽的任何残余空间也必须被视作内部碎片。slab 头部 $h$ 不计为内部碎片。\n\n根据这些规则，确定：\n1. 一个 slab 页面中可以容纳的对象数量。\n2. 内部碎片占可用有效载荷空间 $P-h$ 的小数比例。\n\n将最终答案以一个包含两个条目的行矩阵形式报告，其中第一个条目是对象计数，第二个条目是内部碎片比例。将内部碎片表示为无单位的小数，并四舍五入到四位有效数字。不要在最终的方框答案中包含任何单位。",
            "solution": "slab 分配器在页面内排列固定大小的对象槽，同时考虑对齐和元数据。我们从以下基本定义和事实开始：\n- 一个页面提供 $P$ 字节的总容量。\n- slab 头部从页面开始处消耗 $h$ 字节，且不计入内部碎片。\n- 对齐到 $a$ 字节要求每个对象槽的起始地址是 $a$ 的倍数，并且槽的大小需要向上填充到不小于逻辑对象大小 $s$ 的 $a$ 的最小倍数。\n- slab 有效载荷内的内部碎片包括：头部之后为对齐第一个对象的填充、因对齐而产生的每个对象的填充，以及在打包最大数量的对象槽后任何剩余的不可用有效载荷空间。它是相对于可用有效载荷 $P-h$ 来衡量的。\n\n首先，计算头部之后的可用有效载荷：\n$$\nU = P - h = 4096 - 64 = 4032.\n$$\n接下来，计算对齐后的对象槽大小。对于对齐量 $a$，填充后的槽大小 $s'$ 是不小于 $s$ 的 $a$ 的最小倍数：\n$$\ns' = a \\times \\left\\lceil \\frac{s}{a} \\right\\rceil.\n$$\n当 $s=40$ 和 $a=8$ 时，我们有\n$$\n\\frac{s}{a} = \\frac{40}{8} = 5,\n$$\n所以\n$$\ns' = 8 \\times \\left\\lceil 5 \\right\\rceil = 8 \\times 5 = 40.\n$$\n因此，每个对象槽为 $s' = 40$ 字节，每个对象的填充为 $s' - s = 40 - 40 = 0$ 字节。\n\n我们还必须确保第一个对象在头部之后是对齐的。头部结束于偏移量 $h$；如果 $h$ 不是 $a$ 的倍数，我们需要顶部填充 $p_{0}$ 来达到下一个 $a$ 的倍数。所需的顶部填充是\n$$\np_{0} = (a - (h \\bmod a)) \\bmod a.\n$$\n计算 $h \\bmod a$：\n$$\nh \\bmod a = 64 \\bmod 8 = 0,\n$$\n所以\n$$\np_{0} = (8 - 0) \\bmod 8 = 0.\n$$\n因此，对齐第一个对象不需要额外的填充。\n\n对象槽的数量 $n$ 是满足 $n s' \\leq U - p_{0}$ 的最大整数。因此，\n$$\nn = \\left\\lfloor \\frac{U - p_{0}}{s'} \\right\\rfloor = \\left\\lfloor \\frac{4032 - 0}{40} \\right\\rfloor = \\left\\lfloor 100.8 \\right\\rfloor = 100.\n$$\n打包 $n$ 个槽后剩余的未使用有效载荷为\n$$\nr = (U - p_{0}) - n s' = 4032 - 100 \\times 40 = 4032 - 4000 = 32.\n$$\n有效载荷内的总内部碎片包括三个部分：\n- 顶部对齐填充 $p_{0}$，\n- 每个对象的填充 $n (s' - s)$，\n- 剩余的不可填充的尾部 $r$。\n\n因此，总浪费字节数 $W$ 为\n$$\nW = p_{0} + n (s' - s) + r = 0 + 100 \\times (40 - 40) + 32 = 32.\n$$\n我们将内部碎片量化为可用有效载荷 $U = P - h$ 的一个分数：\n$$\nf = \\frac{W}{U} = \\frac{32}{4032}.\n$$\n我们可以简化这个分数。注意 $4032 = 32 \\times 126$，所以\n$$\nf = \\frac{32}{32 \\times 126} = \\frac{1}{126}.\n$$\n表示为小数，即\n$$\nf = \\frac{1}{126} \\approx 0.0079365079365079\\ldots\n$$\n四舍五入到四位有效数字，我们得到\n$$\nf \\approx 0.007937.\n$$\n因此，对象数量为 $n = 100$，按要求四舍五入到四位有效数字后，内部碎片比例为 $f \\approx 0.007937$。",
            "answer": "$$\\boxed{\\begin{pmatrix}100 & 0.007937\\end{pmatrix}}$$"
        },
        {
            "introduction": "理解了对象的静态布局后，我们转向动态管理策略。当对象被释放后，分配器如何管理这些空闲对象？这个思想实验  将探讨后进先出（LIFO）与先进先出（FIFO）两种空闲列表管理策略，对系统性能（如空间局部性）和内存回收效率产生的深远影响。通过分析这个权衡，你将更深入地理解内存分配器设计中的关键决策。",
            "id": "3683573",
            "problem": "一个内核对单一对象类型使用 slab 分配器。每个 slab 包含 $m$ 个固定大小的对象，并在三种状态之间转换：满（没有空闲对象）、部分（有一些空闲对象）和空（所有 $m$ 个对象都空闲）。当一个 slab 变为空时，分配器会将其物理页面返回给页面分配器。分配器为每个处理器维护一个对象指针的空闲列表，并通过从此空闲列表中移除下一个指针来服务分配请求。空闲列表的策略是后进先出（LIFO）或先进先出（FIFO）。考虑一个长期运行的工作负载，其中 $S$ 个独立的流重复地分配一个对象，执行一个简短的操作，然后释放它。在对象级别，被释放对象的身份在当前已分配的对象中近似均匀分布，因此释放操作有效地、无偏向地分散在各个 slab 上。假设没有跨处理器的争用，并且分配总是来自本地空闲列表。\n\n仅使用以下基础：\n- 空间局部性的定义：从内存中相近的地址（例如，来自同一个 slab）进行的连续分配比分散在不同 slab 上的分配具有更高的空间局部性。\n- 空闲列表策略的定义：LIFO首先返回最近释放的对象；FIFO首先返回最先释放的对象。\n- slab 返回给系统的条件：它必须达到 $0$ 个已分配对象（即，所有 $m$ 个对象同时都处于空闲状态）。\n\n比较 LIFO 和 FIFO 在 (i) 连续分配的空间局部性和 (ii) 某个特定 slab 达到空状态并被返回给页面分配器的稳态可能性。哪个陈述最准确？\n\nA. LIFO 通过优先重用同一 slab 内最近释放的对象来增加空间局部性，并降低任何 slab 变为空的可能性；FIFO 降低空间局部性并增加 slab 变为空并可被返回的可能性。\n\nB. LIFO 通过将分配分散到各个 slab 来降低空间局部性，并增加 slab 变为空的可能性；FIFO 提高局部性并减少变空的可能性。\n\nC. 在均匀随机释放的稳态下，空闲列表的顺序（LIFO 与 FIFO）是无关紧要的，因此空间局部性和 slab 变空的可能性都是相同的。\n\nD. LIFO 增加了空间局部性，但也增加了 slab 变为空的可能性，因为它比 FIFO 更频繁地将释放集中在同一个 slab 中。\n\nE. FIFO 通过重用最近的释放来增加空间局部性，因此相对于 LIFO 降低了 slab 变为空的可能性。",
            "solution": "问题陈述要求在一个 slab 分配系统内，比较两种空闲列表策略：后进先出（LIFO）和先进先出（FIFO）。比较基于两个指标：(i) 连续分配的空间局部性，以及 (ii) 一个 slab 变为空并被返回给系统的可能性。\n\n### 推导\n\n让我们分析在每种空闲列表策略下系统的行为。\n\n**1. LIFO (后进先出) 策略**\n\n*   **机制：** 当一个对象被释放时，其指针被放置在空闲列表的头部。当一个对象被分配时，指针从空闲列表的头部取出。因此，最近释放的对象是第一个被重新分配的。\n*   **对空间局部性的影响：** 这在释放操作和随后的分配操作之间创建了紧密的时间耦合。一个被释放的对象很可能就是下一个被分配的对象。对于执行快速分配-使用-释放循环的工作负载，这意味着同一小组“热”对象将被不断回收。由于这些对象很可能位于同一个 slab（或少数几个 slab）中，连续的分配将从一个受限的内存区域中进行。这种行为直接对应于高空间局部性的定义。因此，LIFO **增加空间局部性**。\n*   **对 slab 变空的影响：** 一小组热对象的不断回收对 slab 的状态有重要影响。包含热对象的 slab 中的对象被释放后会很快被重新分配。这阻止了该 slab 中空闲对象数量的增长。要使一个 slab 变为空（`empty`），其所有 $m$ 个对象必须同时在空闲列表上。LIFO 的行为与此相悖；它通过不断重用部分对象来使`部分`（partial）状态的 slab 保持在`部分`状态，而不是让它们完全排空。因此，LIFO **降低了** slab 达到`空`（empty）状态的可能性。\n\n**2. FIFO (先进先出) 策略**\n\n*   **机制：** 当一个对象被释放时，其指针被放置在空闲列表的尾部。当一个对象被分配时，指针从空闲列表的头部取出。因此，空闲时间最长的对象是第一个被分配的。\n*   **对空间局部性的影响：** 该策略强制在整个空闲对象池中进行轮换。从 slab $A$ 释放的对象会排到队列的末尾。下一次分配将是来自队列头部的对象，该对象可能在早得多的时间被释放，并且可能属于一个完全不同的 slab $B$。因此，连续的分配很可能是针对在内存中彼此相距很远的对象，在不同的 slab 之间循环。这种跨所有部分 slab 的内存空间分散分配对应于低空间局部性。因此，FIFO **降低了空间局部性**。\n*   **对 slab 变空的影响：** FIFO 的“最旧空闲优先”策略意味着，一旦一个对象被释放，它必须等待所有先前释放的对象都被分配后才能被重用。问题陈述中提到，释放操作在所有已分配对象中是均匀分布的。这种释放的分散性，结合 FIFO 从“最旧”端系统性地排空空闲列表的方式，增加了一个 slab 内所有对象在其第一个对象循环回到空闲列表头部以供重新分配之前全部被释放的机会。这使得一个 slab 从`部分`（partial）状态转换到`空`（empty）状态在统计上更有可能。因此，FIFO **增加了** slab 变为空并被返回给页面分配器的可能性。这对于内存回收是有益的，因为它允许系统更有效地整合空闲内存。\n\n**比较总结：**\n- **LIFO：** 高空间局部性，低 slab 变空可能性。\n- **FIFO：** 低空间局部性，高 slab 变空可能性。\n\n### 逐项分析\n\n*   **A. LIFO 通过优先重用同一 slab 内最近释放的对象来增加空间局部性，并降低任何 slab 变为空的可能性；FIFO 降低空间局部性并增加 slab 变为空并可被返回的可能性。**\n    该陈述与我们的推导结论完全一致。LIFO 促进局部性并保持 slab 活跃。FIFO 降低局部性，但更擅长回收整个 slab。\n    **结论：正确。**\n\n*   **B. LIFO 通过将分配分散到各个 slab 来降低空间局部性，并增加 slab 变为空的可能性；FIFO 提高局部性并减少变空的可能性。**\n    该陈述与我们的发现完全相反。它错误地交换了 LIFO 和 FIFO 的属性。\n    **结论：错误。**\n\n*   **C. 在均匀随机释放的稳态下，空闲列表的顺序（LIFO 与 FIFO）是无关紧要的，因此空间局部性和 slab 变空的可能性都是相同的。**\n    这从根本上是错误的。空闲列表策略是决定下一次分配选择哪个空闲对象的直接机制。将此策略从 LIFO 更改为 FIFO 对系统行为有深远且可预测的影响，正如分析所示。\n    **结论：错误。**\n\n*   **D. LIFO 增加了空间局部性，但也增加了 slab 变为空的可能性，因为它比 FIFO 更频繁地将释放集中在同一个 slab 中。**\n    第一部分“LIFO 增加了空间局部性”是正确的。第二部分“但也增加了 slab 变为空的可能性”是错误的。LIFO 将重新分配集中到最近使用的 slab 中，这恰恰*阻止*了这些 slab 变空。\n    **结论：错误。**\n\n*   **E. FIFO 通过重用最近的释放来增加空间局部性，因此相对于 LIFO 降低了 slab 变为空的可能性。**\n    这个陈述错误地描述了 FIFO。FIFO 重用*最不*近（最旧）的空闲对象，而不是最近的。这个行为会降低而非增加空间局部性。因此，它会增加而非减少 slab 变空的可能性。\n    **结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Slab 分配器的设计不仅关乎性能，也关乎健壮性。现代内核利用 slab 分配器的内部机制来帮助开发者发现棘手的内存错误。这个练习  将带你进入一个真实的调试场景，学习如何利用“slab 中毒”技术来捕获一个常见的“释放后使用”（use-after-free）缺陷。通过这个实践，你将看到理论知识如何转化为强大的调试工具。",
            "id": "3683664",
            "problem": "您正在调试一个内核模块，该模块使用了由 Linux 内核 slab 分配器创建的缓存。该模块通过分配器的调试功能启用了 slab 中毒。请考虑以下支配带中毒功能的 slab 分配的基本原理：slab 缓存管理固定大小的对象；对象在空闲和使用中两种状态之间转换；分配器通过写入已知的“毒药”模式来强制执行不变量，并在状态转换时检查这些模式。具体来说，当一个对象转换到空闲状态时，分配器会用毒药字节模式 $0x6B$ 填充该对象，并记住它期望的是空闲状态模式；当一个对象转换到使用中状态（在分配时），分配器会用毒药字节模式 $0x5A$ 填充该对象，并记住它期望的是使用中状态模式。这些模式用于检测对已释放对象的写入以及其他误用情况。您怀疑您的模块中存在“释放后拷贝”（copy-after-free）缺陷，即向一个先前已释放的指针中拷贝内存。您需要一个最小化的、科学严谨的步骤追踪，以便可靠地重现此错误，然后解释其中毒证据。\n\n假设有一个单一缓存 $C$，它提供大小为 $s$ 字节的对象，其中 $s$ 是一个小的固定值（例如，一个头部大小的内核对象）。令 $x$ 表示从 $C$ 获取的对象指针。令 $P$ 表示大小为 $n$ 字节的任意数据负载，其中 $0 \\lt n \\le s$，您的模块可能会将其拷贝到一个对象中。令 $t_0, t_1, t_2, t_3$ 表示测试序列中连续的逻辑时间，其顺序严格递增 $t_0 \\lt t_1 \\lt t_2 \\lt t_3$。您的目标是选择一个足以暴露该缺陷的序列，并得出与中毒签名 $0x6B$ 和 $0x5A$ 一致的解释。\n\n哪个选项正确地指定了重现对 slab 对象进行“释放后拷贝”写入的最小步骤追踪，并正确地解释了中毒签名？\n\nA. 在时间 $t_0$，从 $C$ 分配 $x$。在时间 $t_1$，释放 $x$。在时间 $t_2$，错误地将 $n$ 字节从一个活动缓冲区拷贝到 $x$ 中（一次“释放后拷贝”写入）。在时间 $t_3$，从同一缓存 $C$ 中分配任意对象，以触发分配器对包含 $x$ 的 slab 进行空闲状态中毒检查。解释：等于 $0x6B$ 的字节表示预期的空闲状态毒药；等于 $0x5A$ 的字节表示预期的使用中状态毒药。覆盖已释放对象中的 $0x6B$ 模式表明存在“释放后写入”（write-after-free），并将在下一次从 $C$ 分配时报告为中毒不匹配。\n\nB. 在时间 $t_0$，从 $C$ 分配 $x$。在时间 $t_1$，将 $n$ 字节拷贝到 $x$ 中。在时间 $t_2$，在不释放 $x$ 的情况下从 $C$ 分配第二个对象 $y$。在时间 $t_3$，检查中毒情况并得出结论：$0x5A$ 表示空闲状态毒药，而 $0x6B$ 表示使用中状态毒药。解释：在新分配的对象中出现 $0x5A$ 证明了存在“释放后拷贝”。\n\nC. 在时间 $t_0$，从 $C$ 分配 $x$。在时间 $t_1$，释放 $x$。在时间 $t_2$，从 $x$ 读取 $n$ 字节并将其拷贝到一个独立的目标缓冲区 $D$ 中。在时间 $t_3$，依赖 slab 中毒产生分配器错误，因为从已释放对象中读取会把毒药从 $0x6B$ 变为 $0x5A$。解释：$D$ 中存在 $0x6B$ 表示 $x$ 被错误地当作使用中状态。\n\nD. 在时间 $t_0$，从 $C$ 分配 $x$。在时间 $t_1$，释放 $x$。在时间 $t_2$，错误地将 $n$ 字节拷贝到 $x$ 中。在时间 $t_3$，从一个不同的缓存 $C'$ 分配一个新对象，以触发跨缓存的中毒检查。解释：$0x5A$ 标记一个红区区域，$0x6B$ 标记一个哨兵对象区域；在已释放的对象中发现 $0x5A$ 表明存在跨缓存的“释放后拷贝”。",
            "solution": "这个问题的核心是理解 slab 分配器中的“中毒”机制如何帮助检测“释放后使用”（use-after-free）类型的内存错误。让我们一步步分析。\n\n**1. Slab 中毒机制回顾**\n- **目的**: 检测内存的非法使用，例如对已释放内存的写入（write-after-free）或读取（read-after-free），以及缓冲区溢出等。\n- **工作原理**: 分配器在对象状态转换时，用特定的、已知的字节模式（“毒药”）填充内存。\n    - **释放时**: 当一个对象被释放（`free`）时，分配器用“空闲毒药”模式（本例中为 `0x6B`）填充该对象的内存区域。这标记着该内存现在是空闲的，不应被访问。\n    - **分配时**: 当一个对象被分配（`alloc`）时，分配器首先会检查该内存区域是否仍然保持着完整的“空闲毒药”模式 `0x6B`。如果模式被破坏，说明在对象被释放后，有非法写入操作发生。检查通过后，分配器可能会用“使用中毒药”模式（本例中为 `0x5A`）填充该区域，然后再将对象返回给调用者。这个 `0x5A` 模式本身也可以用于检测未初始化的使用。\n\n**2. \"释放后拷贝\" 缺陷场景分析**\n“释放后拷贝”（copy-after-free）是“释放后写入”的一种。我们需要一个能触发上述检测机制的事件序列。\n\n**3. 选项 A 的分析**\n序列:\n- **$t_0$: 分配 $x$。** `x` 指向的内存被标记为“使用中”。在返回给调用者前，它可能被 `0x5A` 模式填充。\n- **$t_1$: 释放 $x$。** `x` 现在是一个悬垂指针。分配器收回该内存，并用“空闲毒药”模式 `0x6B` 填充它。\n- **$t_2$: 错误地将数据拷贝到 $x$ 中。** 这是缺陷所在。程序通过悬垂指针 `x` 向已释放的内存写入数据。这将覆盖掉分配器精心设置的 `0x6B` 毒药模式。\n- **$t_3$: 从同一缓存 $C$ 分配新对象。** 这是触发检测的关键一步。当分配器试图重用包含 `x` 的内存槽来满足新的分配请求时，它会执行例行检查：该槽的内容是否仍然是 `0x6B`？由于在 $t_2$ 时内容已被破坏，检查会失败，分配器将立即报告一个“slab 中毒”错误。\n\n**结论**: 序列 A 准确地描述了如何重现并检测到“释放后写入”缺陷。其解释也是正确的：对已释放对象中 `0x6B` 模式的破坏是该缺陷的直接证据，并在下一次分配时被捕获。\n\n**4. 其他选项为什么错误**\n- **选项 B**: 没有释放操作，因此不可能发生“释放后拷贝”。它描述的场景与缺陷无关。\n- **选项 C**: 描述的是“释放后读取”（read-after-free）。虽然这也是一种缺陷，但读取 `0x6B` 毒药值本身不会改变它，因此不会触发分配器在下一次分配时的检查失败。它只是将毒药值拷贝到了别处。\n- **选项 D**: 从一个*不同*的缓存 `C'` 分配对象，通常不会触发对缓存 `C` 中空闲对象的检查。中毒检查是缓存内部的。此外，它对毒药值的解释（红区、哨兵）与问题描述不符。\n\n因此，选项 A 提供了最准确和最小化的步骤来重现和解释这个特定的缺陷。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}