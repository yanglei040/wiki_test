{
    "hands_on_practices": [
        {
            "introduction": "节能调度的一个基本思想是在性能和功耗之间进行权衡。本练习将探讨最直接的功耗管理技术之一：空闲注入。通过这个练习，你将学习如何通过在一个固定的时间窗口内强制处理器进入低功耗空闲状态来满足功率上限，并量化这种策略对计算密集型任务所造成的性能损失。",
            "id": "3639085",
            "problem": "一个以固定时钟频率运行的单处理器禁用了动态电压和频率缩放（DVFS）。操作系统通过空闲注入（idle injection）来强制执行功率上限：在每个持续时间为 $T$ 的执行窗口内，它强制处理器在 $\\alpha$ 的时间比例内进入深度空闲状态，并允许其在剩余的 $1-\\alpha$ 的时间比例内执行工作负载。假设处理器在执行时，其瞬时功耗为常数 $P_{\\text{busy}}$，而在被强制置于空闲状态时，其功耗为常数 $P_{\\text{idle}}$。\n\n工作负载是计算密集型的，因此其指令吞吐量与处理器在固定频率下执行的时间比例成正比。忽略进入和退出空闲状态的任何开销。\n\n给定 $P_{\\text{busy}} = 44\\,\\text{W}$，$P_{\\text{idle}} = 8\\,\\text{W}$，以及功率上限 $P_{\\text{cap}} = 29\\,\\text{W}$，确定能确保每个窗口的平均功率满足 $P_{\\text{avg}} \\le P_{\\text{cap}}$ 的最小空闲时间比例 $\\alpha$。然后，评估性能损失，其定义为无上限基线吞吐量的一个分数 $L$，$L = 1 - \\frac{\\text{throughput under cap}}{\\text{throughput without cap}}$。\n\n以数对 $\\left(\\alpha, L\\right)$ 的形式报告您的答案，保留四位有效数字。将两个值都表示为不带单位的纯数。",
            "solution": "首先验证问题陈述的正确性和完整性。\n\n**第1步：提取已知条件**\n- 执行窗口持续时间：$T$\n- 空闲时间比例：$\\alpha$\n- 执行时间比例：$1-\\alpha$\n- 执行期间的瞬时功耗：$P_{\\text{busy}} = 44\\,\\text{W}$\n- 强制空闲期间的瞬时功耗：$P_{\\text{idle}} = 8\\,\\text{W}$\n- 功率上限约束：$P_{\\text{avg}} \\le P_{\\text{cap}}$，其中 $P_{\\text{cap}} = 29\\,\\text{W}$\n- 吞吐量模型：吞吐量与处理器执行时间的比例成正比。\n- 性能损失定义：$L = 1 - \\frac{\\text{throughput under cap}}{\\text{throughput without cap}}$\n- 目标：确定最小空闲时间比例 $\\alpha$ 及相应的性能损失 $L$。\n\n**第2步：使用提取的已知条件进行验证**\n该问题提出了一个简化的、但属于标准范畴的操作系统通过空闲注入进行功耗管理的模型。给定的功耗值对于处理器来说是物理上合理的。对于固定频率下的计算密集型工作负载，执行时间与吞吐量之间的关系是一个标准假设。所有必要的参数都已提供，且目标明确。该问题是自洽的，在其领域内具有科学依据，并且是适定（well-posed）的。\n\n**第3步：结论与行动**\n问题被认为是有效的。将推导解答。\n\n**空闲时间比例 $\\alpha$ 的推导**\n在一个持续时间为 $T$ 的执行窗口内，平均功率 $P_{\\text{avg}}$ 是在繁忙和空闲状态下消耗功率的加权和。处理器在 $(1-\\alpha)T$ 的时间内处于繁忙状态，在 $\\alpha T$ 的时间内处于空闲状态。\n\n在该窗口内消耗的总能量 $E$ 为：\n$$E = P_{\\text{busy}} \\cdot (1-\\alpha)T + P_{\\text{idle}} \\cdot \\alpha T$$\n\n平均功率是该能量除以窗口持续时间 $T$：\n$$P_{\\text{avg}} = \\frac{E}{T} = P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha$$\n\n问题施加了平均功率不得超过功率上限 $P_{\\text{cap}}$ 的约束：\n$$P_{\\text{avg}} \\le P_{\\text{cap}}$$\n代入 $P_{\\text{avg}}$ 的表达式：\n$$P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha \\le P_{\\text{cap}}$$\n\n我们要求满足此条件的最小空闲时间比例 $\\alpha$。由于 $P_{\\text{busy}} > P_{\\text{idle}}$，不等式的左侧是 $\\alpha$ 的单调递减函数。因此，满足不等式的最小 $\\alpha$ 值是使等式两边相等的值。我们建立等式：\n$$P_{\\text{busy}}(1-\\alpha) + P_{\\text{idle}}\\alpha = P_{\\text{cap}}$$\n\n现在我们求解 $\\alpha$：\n$$P_{\\text{busy}} - \\alpha P_{\\text{busy}} + \\alpha P_{\\text{idle}} = P_{\\text{cap}}$$\n$$P_{\\text{busy}} - P_{\\text{cap}} = \\alpha (P_{\\text{busy}} - P_{\\text{idle}})$$\n$$\\alpha = \\frac{P_{\\text{busy}} - P_{\\text{cap}}}{P_{\\text{busy}} - P_{\\text{idle}}}$$\n\n代入给定的数值：\n$$P_{\\text{busy}} = 44\\,\\text{W}$$\n$$P_{\\text{idle}} = 8\\,\\text{W}$$\n$$P_{\\text{cap}} = 29\\,\\text{W}$$\n\n$$\\alpha = \\frac{44 - 29}{44 - 8} = \\frac{15}{36} = \\frac{5}{12}$$\n\n以小数表示，$\\alpha = 0.41666...$。保留四位有效数字，得到 $\\alpha = 0.4167$。\n\n**性能损失 $L$ 的推导**\n问题陈述指令吞吐量与处理器执行的时间比例成正比。设吞吐量为 $\\Theta$，比例常数为 $k$。\n$$\\Theta = k \\times (\\text{execution fraction})$$\n\n基线（无上限）情景对应于处理器始终在执行，因为工作负载是计算密集型的。因此，执行时间比例为 $1$。\n$$\\Theta_{\\text{without cap}} = k \\times 1 = k$$\n\n在功率上限下，处理器在 $1-\\alpha$ 的时间比例内执行。\n$$\\Theta_{\\text{under cap}} = k \\times (1-\\alpha)$$\n\n性能损失 $L$ 定义为：\n$$L = 1 - \\frac{\\Theta_{\\text{under cap}}}{\\Theta_{\\text{without cap}}}$$\n代入吞吐量的表达式：\n$$L = 1 - \\frac{k(1-\\alpha)}{k} = 1 - (1-\\alpha) = \\alpha$$\n\n因此，性能损失分数 $L$ 在数值上等于所需的空闲时间比例 $\\alpha$。\n$$L = \\alpha = \\frac{5}{12} \\approx 0.41666...$$\n\n保留四位有效数字，性能损失为 $L = 0.4167$。\n\n最终答案是数对 $(\\alpha, L)$。\n$$\\alpha \\approx 0.4167$$\n$$L \\approx 0.4167$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.4167  0.4167 \\end{pmatrix}}$$"
        },
        {
            "introduction": "现代多核处理器的节能策略比简单的“开关”模式要复杂得多，它涉及到动态电压频率缩放（DVFS）和静态泄漏功耗等关键因素。本练习引导你分析一个核心的调度决策：是将工作负载整合到少数几个核心上高频运行，还是将其分散到多个核心上低频运行。通过推导決定这两种策略优劣的关键泄漏功耗阈值，你将深刻理解静态功耗在现代处理器能效管理中的重要作用。",
            "id": "3639071",
            "problem": "操作系统调度器必须在两种策略之间做出选择：一种是将工作负载整合到少数几个处理器核心上（休眠其余核心），另一种是将其以较低的频率分散到多个核心上运行，同时需要考虑泄漏功率。考虑一个具有 $M$ 个相同核心的对称多核处理器。一个作业需要 $X$ 个时钟周期，并且必须在截止时间 $D$ 之前完成。假设理想并行扩展且无开销：如果 $N$ 个核心处于活跃状态，每个核心都以相同的时钟频率 $f$ 运行该作业的一部分，总吞吐量为 $N f$，因此完成时间为 $T = X/(N f)$。为了在截止时间约束下最小化能耗，调度器会选择满足 $T \\leq D$ 的最小频率。\n\n使用以下广泛接受的物理模型来描述互补金属氧化物半导体（CMOS）的动态功率和动态电压与频率缩放（DVFS）：\n- 每个活跃核心的动态功率为 $P_{\\text{dyn}} = C V^{2} f$，其中 $C$ 是有效开关电容，$V$ 是电源电压。\n- 在我们关心的工作范围内，电压与频率近似成正比：$V = \\beta f$，其中 $\\beta$ 是一个与技术相关的常数。\n\n在此模型中，每个活跃核心的泄漏功率是一个不依赖于 $f$ 的常数 $P_{\\text{leak}}$。休眠核心的泄漏可忽略不计。消耗的能量是功率对时间的积分；在执行期间频率 $f$ 恒定的情况下，能量是功率与执行时间的乘积。\n\n基于以上前提，推导临界泄漏功率 $P_{\\text{leak}}^{\\star}$ 的闭式解析表达式，该值使得在所有 $M$ 个核心上以最小频率运行作业的总能耗，等于在单个核心上以相应的最小频率运行该作业的总能耗。以瓦特（Watts）为单位表示您的最终答案。不要计算数值；仅提供精确的符号表达式。",
            "solution": "问题陈述经评估有效。它基于CMOS功耗的标准简化模型，具有科学依据，问题本身表述清晰、目标明确、信息充分，并使用客观、正式的语言。我们可以开始求解。\n\n目标是找到每个核心的临界泄漏功率，记为 $P_{\\text{leak}}^{\\star}$，在该值下，在单个核心上完成一个作业所消耗的总能量等于在处理器的所有 $M$ 个核心上完成同一作业所消耗的总能量。\n\n首先，我们建立一个在使用 $N$ 个活跃核心时总能耗 $E$ 的通用模型。总功率 $P_{\\text{total}}(N, f)$ 是所有活跃核心的动态功率和泄漏功率的总和。休眠核心的功耗可以忽略不计。\n一个以频率 $f$ 运行的活跃核心的功率是动态功率 $P_{\\text{dyn}}$ 和泄漏功率 $P_{\\text{leak}}$ 的和。\n$$P_{\\text{core}} = P_{\\text{dyn}} + P_{\\text{leak}}$$\n动态功率由公式 $P_{\\text{dyn}} = C V^2 f$ 给出，其中 $V$ 是电源电压。电压通过 $V = \\beta f$ 与频率相关。将此关系代入动态功率方程，得到：\n$$P_{\\text{dyn}} = C (\\beta f)^2 f = C \\beta^2 f^3$$\n因此，单个核心的功率为 $P_{\\text{core}}(f) = C \\beta^2 f^3 + P_{\\text{leak}}$。对于 $N$ 个活跃核心，总功率为：\n$$P_{\\text{total}}(N, f) = N \\cdot P_{\\text{core}}(f) = N (C \\beta^2 f^3 + P_{\\text{leak}})$$\n该作业需要 $X$ 个时钟周期才能完成。当有 $N$ 个核心以频率 $f$ 运行时，总吞吐量为每秒 $Nf$ 个周期。执行时间 $T$ 为：\n$$T(N, f) = \\frac{X}{Nf}$$\n调度器必须满足截止时间 $D$，因此 $T \\leq D$。为最小化能耗，调度器选择满足此约束的最低可能频率。这发生在执行时间恰好等于截止时间时：\n$$T = \\frac{X}{Nf} = D$$\n由此，我们可以解出作为活跃核心数 $N$ 的函数的运行频率 $f$：\n$$f(N) = \\frac{X}{ND}$$\n现在，我们可以表示总能耗 $E(N)$，它是总功率和执行时间的乘积，即 $E(N) = P_{\\text{total}}(N, f(N)) \\times T$。由于时间固定为 $T=D$：\n$$E(N) = P_{\\text{total}}(N, f(N)) \\cdot D$$\n代入 $P_{\\text{total}}$ 和 $f(N)$ 的表达式：\n$$E(N) = N \\left( C \\beta^2 \\left( \\frac{X}{ND} \\right)^3 + P_{\\text{leak}} \\right) D$$\n$$E(N) = N \\left( C \\beta^2 \\frac{X^3}{N^3 D^3} + P_{\\text{leak}} \\right) D$$\n$$E(N) = \\frac{C \\beta^2 X^3}{N^2 D^2} + N P_{\\text{leak}} D$$\n这是总能耗作为活跃核心数 $N$ 的函数的通用表达式。\n\n我们现在将此通用表达式应用于问题中定义的两种具体情况。\n\n情况1：作业在单个核心上运行（$N=1$）。\n将 $N=1$ 代入通用能量表达式，得到能耗 $E_1$：\n$$E_1 = E(1) = \\frac{C \\beta^2 X^3}{1^2 D^2} + (1) P_{\\text{leak}} D = \\frac{C \\beta^2 X^3}{D^2} + P_{\\text{leak}} D$$\n\n情况2：作业在所有 $M$ 个核心上运行（$N=M$）。\n将 $N=M$ 代入，得到能耗 $E_M$：\n$$E_M = E(M) = \\frac{C \\beta^2 X^3}{M^2 D^2} + M P_{\\text{leak}} D$$\n\n临界泄漏功率 $P_{\\text{leak}}^{\\star}$ 定义为使 $E_1 = E_M$ 成立时的 $P_{\\text{leak}}$ 值。我们建立这个等式，用 $P_{\\text{leak}}^{\\star}$ 替换 $P_{\\text{leak}}$：\n$$\\frac{C \\beta^2 X^3}{D^2} + P_{\\text{leak}}^{\\star} D = \\frac{C \\beta^2 X^3}{M^2 D^2} + M P_{\\text{leak}}^{\\star} D$$\n现在，我们求解 $P_{\\text{leak}}^{\\star}$。首先，将包含 $P_{\\text{leak}}^{\\star}$ 的项移到等式一侧，其余项移到另一侧：\n$$M P_{\\text{leak}}^{\\star} D - P_{\\text{leak}}^{\\star} D = \\frac{C \\beta^2 X^3}{D^2} - \\frac{C \\beta^2 X^3}{M^2 D^2}$$\n提取等式两边的公因式：\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\left( 1 - \\frac{1}{M^2} \\right)$$\n简化括号中的项：\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\left( \\frac{M^2-1}{M^2} \\right)$$\n使用恒等式 $M^2 - 1 = (M-1)(M+1)$：\n$$P_{\\text{leak}}^{\\star} D (M-1) = \\frac{C \\beta^2 X^3}{D^2} \\frac{(M-1)(M+1)}{M^2}$$\n对于多核处理器，我们假设 $M \\ge 2$，这意味着 $M-1 \\neq 0$。因此，我们可以将等式两边同时除以 $D(M-1)$：\n$$P_{\\text{leak}}^{\\star} = \\frac{1}{D(M-1)} \\left( \\frac{C \\beta^2 X^3}{D^2} \\frac{(M-1)(M+1)}{M^2} \\right)$$\n$$P_{\\text{leak}}^{\\star} = \\frac{C \\beta^2 X^3}{D^3} \\frac{M+1}{M^2}$$\n这就是临界泄漏功率的最终闭式解析表达式。",
            "answer": "$$\n\\boxed{C \\beta^2 \\frac{X^3}{D^3} \\frac{M+1}{M^2}}\n$$"
        },
        {
            "introduction": "将理论模型转化为实际的调度策略是操作系统设计的关键一步。当处理器预测到一段I/O等待时间时，它必须从多个具有不同唤醒延迟和功耗特性的睡眠状态（C-states）中做出最优选择。本练习要求你设计并实现一个决策程序，通过计算和比较不同睡眠状态下的总能耗，来模拟一个真实的节能调度器如何根据预测的空闲窗口长度选择最佳的睡眠深度。",
            "id": "3639092",
            "problem": "您的任务是为一款节能调度器设计一个决策过程，当处理器进入空闲状态，预计有持续时间为 $W$ 的输入/输出 (I/O) 等待时，该决策过程需要选择一个睡眠状态深度 $d$，以在保证空闲窗口结束时系统就绪的前提下，最大限度地减少能耗。该决策必须基于每个睡眠深度的唤醒延迟 $\\ell(d)$ 和转换能量 $E_{tr}(d)$。目标是将此决策编码为一个完整的、可运行的程序，该程序能为一组固定的测试套件生成指定的输出。\n\n使用以下基本原理：\n- 功率是能量消耗的速率，因此能量是功率对时间的积分。在功率恒定的时间间隔内，能量等于功率乘以时间。即，$E = \\int P(t)\\, dt$，对于恒定的 $P$，$E = P \\cdot t$。\n- 就绪约束：如果一个睡眠状态的唤醒延迟为 $\\ell(d)$，那么为了在空闲窗口结束时恰好准备就绪，窗口的最后 $\\ell(d)$ 秒必须用于唤醒过程。\n\n系统模型：\n- 基准活动空闲功率为 $P_{idle}$ 瓦特（焦耳/秒）。\n- 有 $D$ 个可用的睡眠状态，索引为 $d \\in \\{1, \\dots, D\\}$。每个状态 $d$ 具有：\n  - 唤醒延迟 $\\ell(d)$，单位为秒。\n  - 转换能量 $E_{tr}(d)$，单位为焦耳。这是在空闲窗口期间进入和退出该状态的一次性能量开销。\n  - 稳态睡眠功率 $P_s(d)$，单位为瓦特，是在窗口中处于睡眠状态部分期间的功率。\n- 基准“不睡眠”选项可建模为状态 $d = 0$，其 $\\ell(0) = 0$，$E_{tr}(0) = 0$，$P_s(0) = P_{idle}$，并且始终是可行的。\n\n决策策略约束：\n- 只有当 $\\ell(d) \\le W$ 时，睡眠状态 $d \\ge 1$ 才是可行的（这样唤醒过程才能在窗口结束前完成）。\n- 如果所有可行的睡眠状态的能耗都大于或等于在整个窗口期间保持基准空闲状态的能耗，则调度器必须选择 $d = 0$。\n- 如果多个状态的能耗相等，出现平局，则选择最小的 $d$。\n\n您的程序必须针对每个具有预测空闲窗口 $W$ 的测试用例，计算出所选的睡眠深度 $d$，该深度能在满足就绪约束和上述平局打破规则的同时，使总能耗最小化。您需要使用基本原理来确定每种可行选择下所消耗的能量。所有物理量都必须使用正确的单位处理：时间单位为秒，功率单位为瓦特，能量单位为焦耳。\n\n参数：\n- 基准功率：$P_{idle} = 15$ 瓦特。\n- 睡眠状态（$D = 3$）：\n  - $d = 1$：$\\ell(1) = 0.005$ 秒，$E_{tr}(1) = 0.2$ 焦耳，$P_s(1) = 8$ 瓦特。\n  - $d = 2$：$\\ell(2) = 0.02$ 秒，$E_{tr}(2) = 0.5$ 焦耳，$P_s(2) = 4$ 瓦特。\n  - $d = 3$：$\\ell(3) = 0.05$ 秒，$E_{tr}(3) = 1.2$ 焦耳，$P_s(3) = 1.5$ 瓦特。\n\n测试套件（预测的空闲窗口 $W$，单位为秒）：\n- 案例 A（边界）：$W = 0.0$。\n- 案例 B（短窗口，所有更深的状态都不可行）：$W = 0.003$。\n- 案例 C（小窗口，浅层状态勉强可行）：$W = 0.010$。\n- 案例 D（中等窗口，浅层和中等深度状态可行，深层状态勉强可行）：$W = 0.060$。\n- 案例 E（中等窗口）：$W = 0.100$。\n- 案例 F（较长窗口）：$W = 0.300$。\n- 案例 G（非常长的窗口）：$W = 2.0$。\n- 案例 H（在更深状态延迟处的边界）：$W = 0.050$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按给定顺序排列的上述测试用例所选的睡眠深度，格式为方括号内以逗号分隔的列表。该列表必须只包含整数，且没有空格。例如，使用格式 $[\\text{result1},\\text{result2},\\dots]$。\n\n您的代码必须是自包含的，不能读取任何输入，并且必须使用上述固定的参数和测试套件。输出是代表所选睡眠深度的无单位整数。",
            "solution": "用户希望我扮演一位严谨的 STEM 教授，验证一个问题，然后提供一个解决方案。\n\n### 问题验证\n\n以下是对所提供问题陈述的逐步验证。\n\n**第 1 步：提取已知条件**\n\n- **目标**：对于给定的持续时间为 $W$ 的空闲窗口，选择一个睡眠状态深度 $d$ 以最小化总能耗。\n- **基本原理**：\n    - 能量 $E = \\int P(t) \\, dt$。\n    - 对于恒定功率 $P$，能量 $E = P \\cdot t$。\n- **就绪约束**：如果唤醒延迟为 $\\ell(d)$，则空闲窗口的最后 $\\ell(d)$ 秒用于唤醒。\n- **系统模型**：\n    - 基准活动空闲功率：$P_{idle} = 15$ 瓦特。\n    - 睡眠状态数量：$D = 3$，索引为 $d \\in \\{1, 2, 3\\}$。\n    - 状态 $d=1$：$\\ell(1) = 0.005$ 秒, $E_{tr}(1) = 0.2$ 焦耳, $P_s(1) = 8$ 瓦。\n    - 状态 $d=2$：$\\ell(2) = 0.02$ 秒, $E_{tr}(2) = 0.5$ 焦耳, $P_s(2) = 4$ 瓦。\n    - 状态 $d=3$：$\\ell(3) = 0.05$ 秒, $E_{tr}(3) = 1.2$ 焦耳, $P_s(3) = 1.5$ 瓦。\n    - 基准（“不睡眠”）建模为状态 $d=0$：$\\ell(0) = 0$, $E_{tr}(0) = 0$, $P_s(0) = P_{idle}$。\n- **决策策略约束**：\n    1. 只有当 $\\ell(d) \\le W$ 时，睡眠状态 $d \\ge 1$ 才是可行的。\n    2. 如果所有可行的睡眠状态的能耗都大于或等于保持基准空闲状态的能耗，则选择 $d=0$。\n    3. 如果能耗相同，出现平局，则选择最小的 $d$。\n- **测试套件**：\n    - 案例 A: $W = 0.0$ 秒\n    - 案例 B: $W = 0.003$ 秒\n    - 案例 C: $W = 0.010$ 秒\n    - 案例 D: $W = 0.060$ 秒\n    - 案例 E: $W = 0.100$ 秒\n    - 案例 F: $W = 0.300$ 秒\n    - 案例 G: $W = 2.0$ 秒\n    - 案例 H: $W = 0.050$ 秒\n\n**第 2 步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在能源和功率的物理学（$E=P \\cdot t$）方面有充分的依据，并代表了计算机系统中动态电源管理的标准（尽管是简化的）模型。参数在物理上是合理的。\n- **问题的适定性**：该问题是适定的。它指定了一个明确的目标函数（最小化能量）和一组离散的选择。约束条件和打破平局的规则是明确的，确保对于任何给定的 $W$ 都存在一个唯一的、有意义的解。\n- **客观性**：问题陈述使用了精确、客观和定量的语言。没有主观或基于意见的元素。\n- **设置不完整或矛盾**：问题是自包含的。虽然没有明确定义唤醒阶段消耗的功率，但在所提供的模型中，唯一合乎逻辑且一致的解释是，在此期间处理器消耗基准活动空闲功率 $P_{idle}$。任何其他假设都需要额外的、未说明的参数，这将使问题无法解决。这种隐含的假设是此类简化模型的标准特征，而不是缺陷。\n- **不切实际或不可行**：物理量及其值对于处理器睡眠状态（C-states）是现实的。\n- **其他缺陷**：该问题不是不适定的、伪深刻的、琐碎的，也不在科学可验证性领域之外。它是一个基于物理模型的直接优化问题。\n\n**第 3 步：结论与行动**\n\n该问题是**有效**的。这是一个在操作系统和计算机体系结构领域内定义明确、科学上合理的问​​题。我现在将着手提供解决方案。\n\n### 形式化解决方案\n\n任务是找到最优的睡眠状态深度 $d^*$，以最小化在持续时间为 $W$ 的空闲窗口期间的总能耗。$d$ 的可能选择集合为 $\\{0, 1, 2, 3\\}$。\n\n**1. 能耗模型**\n\n首先，我们为每个可能的睡眠深度选择 $d$ 推导出总能耗的数学表达式 $E_{total}(d, W)$。\n\n**基准能量（不睡眠，$d=0$）：**\n如果调度器选择不进入睡眠状态，处理器将在整个持续时间 $W$ 内保持活动空闲状态。功耗恒定为 $P_{idle}$。\n使用原理 $E = P \\cdot t$，总能耗为：\n$$E_{total}(0, W) = P_{idle} \\cdot W$$\n给定 $P_{idle} = 15 \\frac{J}{s}$，即 $E_{total}(0, W) = 15 \\cdot W$。\n\n**睡眠状态能量 ($d \\ge 1$)：**\n要选择一个睡眠状态 $d \\ge 1$，它必须是可行的。可行性约束是唤醒延迟不能超过空闲窗口的持续时间：\n$$W \\ge \\ell(d)$$\n如果满足此条件，总能耗是三个组成部分的总和：\n1.  **转换能量 ($E_{trans}$):** 这是进入和退出睡眠状态的固定能量成本 $E_{tr}(d)$。\n2.  **睡眠阶段能量 ($E_{sleep}$):** 根据就绪约束，处理器必须在窗口结束前 $\\ell(d)$ 秒开始唤醒。因此，在低功耗睡眠状态下花费的时间为 $t_{sleep} = W - \\ell(d)$。在此期间，功耗为 $P_s(d)$。消耗的能量是：\n    $$E_{sleep} = P_s(d) \\cdot (W - \\ell(d))$$\n3.  **唤醒阶段能量 ($E_{wakeup}$):** 最后的 $\\ell(d)$ 秒用于从睡眠状态转换回活动状态。在此唤醒期间，处理器是活动的。由于问题没有明确指定一个独特的唤醒功率，我们必须从给定的模型参数中推断。唯一提供的活动、非睡眠功率是 $P_{idle}$。因此，一个必要且标准的建模假设是，唤醒期间的功耗为 $P_{idle}$。此阶段消耗的能量是：\n    $$E_{wakeup} = P_{idle} \\cdot \\ell(d)$$\n\n结合这三个组成部分，一个可行的睡眠状态 $d \\ge 1$ 的总能量为：\n$$E_{total}(d, W) = E_{tr}(d) + P_s(d) \\cdot (W - \\ell(d)) + P_{idle} \\cdot \\ell(d)$$\n\n**2. 决策算法**\n\n对于给定的空闲窗口 $W$，调度器必须在所有有效的 $d$ 选择中，选择使 $E_{total}(d, W)$ 最小化的深度 $d^*$。\n\n算法如下：\n1.  初始化迄今为止找到的最小能量 $E_{min}$ 为基准能量：$E_{min} = E_{total}(0, W) = P_{idle} \\cdot W$。\n2.  初始化迄今为止找到的最佳睡眠深度 $d_{best}$ 为 $0$。\n3.  遍历可用的睡眠状态 $d = 1, 2, ..., D$。\n4.  对于每个状态 $d$：\n    a. 检查可行性：是否 $W \\ge \\ell(d)$？\n    b. 如果状态可行，使用上面推导的公式计算其总能耗 $E_{current} = E_{total}(d, W)$。\n    c. 将此能量与迄今为止找到的最小能量进行比较。根据决策策略，如果 $E_{current}  E_{min}$，则更新选择：$E_{min} = E_{current}$ 且 $d_{best} = d$。\n5.  检查完所有状态后，$d_{best}$ 的最终值就是最优睡眠深度 $d^*$。\n\n该算法正确地实现了策略规则。通过用 $d=0$ 进行初始化，如果没有状态能提供改进，它会自然地默认为不睡眠。通过按 $d$ 的递增顺序迭代，并且仅在严格不等式（$E_{current}  E_{min}$）成立时更新，它正确地处理了平局打破规则（选择最小的 $d$）。\n\n此过程将被编码到一个程序中，以计算给定测试套件的结果。",
            "answer": "[0,0,0,1,1,2,3,1]"
        }
    ]
}