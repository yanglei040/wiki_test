{
    "hands_on_practices": [
        {
            "introduction": "在持久内存文件系统中，原子更新对于保证数据完整性至关重要，因为崩溃可能在任何操作中途发生。这项练习旨在让你批判性地评估几种行业标准协议——写时复制（Copy-on-Write）和日志记录（Journaling）——如何确保文件更新的“全有或全无”特性。通过分析不同的崩溃场景，你将深化对持久化和排序原语的理解。",
            "id": "3669193",
            "problem": "一个构建在非易失性双列直插式内存模块 (NVDIMM) 上的持久内存 (PMem) 文件系统必须原子地更新一个文件：替换一个 $4\\,\\mathrm{KiB}$ 数据块的内容，并更新存储指向该块的指针和文件长度的 inode 元数据。该机器有一个带有易失性缓存的中央处理器 (CPU)；一次存储操作只有在相应的缓存行被显式写回到 PMem 并且这些写操作通过持久化屏障进行排序后，才能达到持久化。假设以下被广泛接受的原语和事实作为基础：\n- 缓存行写回 (CLWB) 或优化缓存行刷新 (CLFLUSHOPT) 会使指定的缓存行被写回到 PMem，但其本身并不保证与后续存储操作的顺序。\n- 存储屏障 (SFENCE) 对先前的缓存行写回和存储操作与后续的存储操作进行排序，在持久化顺序中创建一个 happens-before 关系。\n- 在 $t_c$ 时刻发生崩溃时，持久化状态等于在 $t_c$ 之前到达 PMem 的缓存行写回序列的某个前缀；易失性缓存的状态会丢失。\n- 不要假设多千字节的原子持久性；只假设在写回完成后，在缓存行级别具有失败原子性。\n\n设旧状态由 $(B_{\\text{old}},P_{\\text{old}},L_{\\text{old}})$ 描述，其中 $B_{\\text{old}}$ 是旧数据块内容，$P_{\\text{old}}$ 是指向旧块的 inode 指针，$L_{\\text{old}}$ 是旧长度。新的目标状态是 $(B_{\\text{new}},P_{\\text{new}},L_{\\text{new}})$，其中 $B_{\\text{new}}$ 是新数据块内容，$P_{\\text{new}}$ 指向新块，$L_{\\text{new}}$ 是新长度。崩溃一致性不变量 $I$ 是：在 $t_c$ 时刻发生任何崩溃后，恢复的文件必须呈现 $(B_{\\text{old}},P_{\\text{old}},L_{\\text{old}})$ 或 $(B_{\\text{new}},P_{\\text{new}},L_{\\text{new}})$，但绝不能是像 $(B_{\\text{old}},P_{\\text{new}},L_{\\text{new}})$ 或 $(B_{\\text{new}},P_{\\text{old}},L_{\\text{old}})$ 这样的混合状态。\n\n考虑以下候选的更新与恢复设计。每个选项都描述了一个协议以及在元数据和数据更新之间的任何时间点发生崩溃时的恢复过程。选择所有既能保证不变量 $I$ 又能根据所述基础陈述准确恢复过程的选项。\n\nA. 使用有序持久化的写时复制。为 $B_{\\text{new}}$ 分配一个新块，将新内容写入其中，对新块的所有缓存行发出 CLWB，然后发出 SFENCE。接下来，将 inode 字段更新为 $(P_{\\text{new}},L_{\\text{new}})$，对 inode 所在的缓存行发出 CLWB，然后发出 SFENCE。恢复过程描述：如果在第一个 SFENCE 完成前发生崩溃，inode 保持在 $(P_{\\text{old}},L_{\\text{old}})$，读取者看到 $B_{\\text{old}}$；如果在第一个 SFENCE 之后但在第二个 SFENCE 完成前发生崩溃，inode 仍然指向 $P_{\\text{old}}$，因此读取者看到 $B_{\\text{old}}$；如果在第二个 SFENCE 完成后发生崩溃，读取者看到 $(P_{\\text{new}},L_{\\text{new}})$ 和 $B_{\\text{new}}$。在任何情况下，$(P_{\\text{new}},L_{\\text{new}})$ 都不会在 $B_{\\text{new}}$ 未持久化的情况下可见。\n\nB. 元数据优先的原地更新。首先，将 inode 更新为 $(P_{\\text{new}},L_{\\text{new}})$，对 inode 所在的缓存行发出 CLWB，然后发出 SFENCE。接下来，用 $B_{\\text{new}}$ 覆盖旧数据块，对其缓存行发出 CLWB，然后发出 SFENCE。恢复过程描述：如果在第一个 SFENCE 之后但在第二个 SFENCE 完成前发生崩溃，inode 可能已持久化为 $(P_{\\text{new}},L_{\\text{new}})$，而数据块仍包含 $B_{\\text{old}}$ 或部分数据，因此读取者可能会观察到混合状态。\n\nC. 没有中间屏障的写时复制。分配一个新块并将 $B_{\\text{new}}$ 写入其中；对新块的所有缓存行发出 CLWB，但尚不发出屏障。立即将 inode 更新为 $(P_{\\text{new}},L_{\\text{new}})$，对 inode 所在的缓存行发出 CLWB，然后在末尾发出单个 SFENCE。恢复过程描述：因为首先对数据使用了 CLWB，所以持久化顺序得到保证，因此崩溃绝不会在没有 $B_{\\text{new}}$ 的情况下暴露 $(P_{\\text{new}},L_{\\text{new}})$。\n\nD. 使用提交机制的预写重做日志 (日志记录)。组合一条重做日志记录，包含新内容 $B_{\\text{new}}$ 和元数据更改 $(P_{\\text{new}},L_{\\text{new}})$ 以及一个校验和。将该记录追加到重做日志中，对其所有缓存行发出 CLWB，然后发出 SFENCE。接下来，为该记录追加一个提交标记，对提交标记所在的行发出 CLWB，然后发出 SFENCE。在提交持久化之后，以任何顺序在任何稍后的时间将原地更改应用于数据块和 inode，为接触到的行发出 CLWB；可以选择将这些操作与稍后的 SFENCE 一起批量处理。恢复过程描述：崩溃时，系统只重放已提交且校验和有效的日志记录，幂等地安装 $B_{\\text{new}}$ 和 $(P_{\\text{new}},L_{\\text{new}})$；未提交的记录将被忽略。因此，恢复后，文件要么处于旧状态，要么处于新状态，绝不会是混合状态，即使崩溃发生在安装了一个字段但未安装另一个字段之后。",
            "solution": "问题陈述在科学上和逻辑上都是有效的。它基于计算机体系结构和操作系统的既定原则，特别是关于使用持久内存 (PMem) 的文件系统中的崩溃一致性。所提供的原语——`CLWB`/`CLFLUSHOPT`、`SFENCE` 以及一个明确定义的崩溃模型——准确地反映了在 x86-64 等架构上进行真实世界 PMem 编程的一个标准的、简化的模型。目标是确保一次原子更新，该更新由不变量 $I$ 定义，它要求文件操作从一个一致的旧状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$ 过渡到一个一致的新状态 $(B_{\\text{new}}, P_{\\text{new}}, L_{\\text{new}})$，而在从崩溃中恢复时不会暴露任何中间的、不一致的混合状态。这个问题提得很好，为评估所提出协议的正确性提供了足够的信息。我们现在将逐一分析每个选项。\n\n**选项 A 分析：使用有序持久化的写时复制。**\n协议如下：\n1.  将新数据 $B_{\\text{new}}$ 写入新分配的块。\n2.  为 $B_{\\text{new}}$ 的所有缓存行发出 `CLWB`。\n3.  发出 `SFENCE`。\n4.  将 inode 更新为 $(P_{\\text{new}}, L_{\\text{new}})$。\n5.  为 inode 所在的缓存行发出 `CLWB`。\n6.  发出 `SFENCE`。\n\n该协议实现了写时复制 (CoW) 策略。关键特征是在刷新新数据块之后和更新 inode 指针*之前*使用了 `SFENCE` 指令（步骤 3）。根据问题的定义，`SFENCE` 在持久化顺序中创建了一个 happens-before 关系。这确保了 $B_{\\text{new}}$ 的所有缓存行写回在 inode 的后续写回可以被持久化之前都已持久化。\n\n让我们分析崩溃的可能性：\n- 如果在第一个 `SFENCE`（步骤 3）完成前的任何时刻发生崩溃，新数据块 $B_{\\text{new}}$ 的持久性无法保证。然而，inode 的更新尚未被持久化，因此文件系统指针 $P_{\\text{old}}$ 仍然指向旧块 $B_{\\text{old}}$。恢复后，系统看到的是原始状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$。新分配的块实际上是不可达的垃圾。\n- 如果在第一个 `SFENCE` 完成后、第二个 `SFENCE` 完成前发生崩溃，新数据 $B_{\\text new}$ 被保证是完全持久化的。对 inode 的更新 $(P_{\\text{new}}, L_{\\text{new}})$ 可能已经持久化，也可能没有。如果还没有，系统恢复到旧状态 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$。如果 inode 的更新*已经*持久化，系统恢复到新状态 $(B_{\\text{new}}, P_{\\text{new}}, L_{\\text{new}})$。在这种情况下，由于 inode 指向 $P_{\\text{new}}$，该位置的数据 $B_{\\text{new}}$ 已经被保证是持久的。\n在任何情况下，持久化的 inode 都不可能指向一个非持久化或部分持久化的数据块。因此，不变量 $I$ 得以保证。\n\n该选项中提供的恢复过程描述与此分析一致。它正确地指出，如果在最终状态提交之前发生崩溃，inode 将指向旧块，并且关键属性是，在新数据持久化之前，新指针绝不会可见。\n结论：**正确**。\n\n**选项 B 分析：元数据优先的原地更新。**\n协议是：\n1.  将 inode 更新为 $(P_{\\text{new}}, L_{\\text{new}})$。\n2.  对 inode 发出 `CLWB`。\n3.  发出 `SFENCE`。\n4.  用 $B_{\\text{new}}$ 覆盖数据块。\n5.  对数据块发出 `CLWB`。\n6.  发出 `SFENCE`。\n\n该协议优先持久化元数据更新。在步骤 3 完成后、步骤 6 完成前发生崩溃会造成严重故障。在这个时间窗口内，inode 被持久地更新为 $(P_{\\text{new}}, L_{\\text{new}})$，但数据块（大小为 $4\\,\\mathrm{KiB}$，因此跨越多个缓存行）可能只被部分更新。例如，inode 可能指向一个包含 $B_{\\text{old}}$ 和 $B_{\\text{new}}$ 混合内容的块，这是一种损坏的状态。这直接导致了混合的、不一致的状态，违反了不变量 $I$。\n\n问题要求选择*保证不变量 I*的选项。该协议未能做到这一点。尽管其附带的恢复过程描述准确地描述了这一失败，但协议本身存在缺陷，不能代表原子更新问题的有效解决方案。\n结论：**不正确**。\n\n**选项 C 分析：没有中间屏障的写时复制。**\n协议是：\n1.  将新数据 $B_{\\text{new}}$ 写入一个新块。\n2.  为 $B_{\\text{new}}$ 的所有缓存行发出 `CLWB`。\n3.  将 inode 更新为 $(P_{\\text{new}}, L_{\\text{new}})$。\n4.  为 inode 所在的缓存行发出 `CLWB`。\n5.  发出 `SFENCE`。\n\n该协议省略了在刷新数据和刷新元数据之间的关键 `SFENCE`。问题陈述指明 `CLWB` “本身不保证顺序”。内存硬件可以自由地对到 PMem 的写操作进行重排序。如果没有中间的 `SFENCE`，inode 的 `CLWB`（步骤 4）可能在数据块 $B_{\\text{new}}$ 的 `CLWB`（步骤 2）之前被持久化，即使它是在之后发出的。\n\n如果在 inode 被持久化之后但在 $B_{\\text new}$ 完全持久化之前发生崩溃，系统将恢复到一个状态，其中 inode 具有 $(P_{\\text{new}}, L_{\\text{new}})$，但指向一个部分写入的、损坏的数据块。这违反了不变量 $I$。恢复过程描述中声称“持久化顺序得到保证”是基于问题本身的定义来看是事实错误的，因为它误解了 `CLWB` 的行为。\n结论：**不正确**。\n\n**选项 D 分析：使用提交机制的预写重做日志 (日志记录)。**\n该协议是使用重做日志的标准两阶段提交方案：\n1.  **日志 (Log)**：将包含所有更改（$B_{\\text{new}}$ 和 $(P_{\\text{new}}, L_{\\text{new}})$）的日志记录追加到日志中，并将其持久化（`CLWB` + `SFENCE`）。\n2.  **提交 (Commit)**：为该日志记录追加一个提交标记，并将其持久化（`CLWB` + `SFENCE`）。\n3.  **应用 (Apply)**：提交后，将日志中的更改应用到它们的原始位置。\n\n该协议通过使提交记录的持久化成为原子决策点来实现原子性。\n- **恢复**：恢复过程会扫描日志。\n    - 如果找到没有相应提交标记的日志记录，它将被忽略。如果崩溃发生在步骤 2 完成之前，就会发生这种情况。数据和 inode 的原始位置保持不变，因此系统处于 $(B_{\\text{old}}, P_{\\text{old}}, L_{\\text{old}})$ 状态。\n    - 如果找到已提交的日志记录，恢复过程会重放日志中指定的更改，将它们应用到其原始位置。这种重放必须是幂等的，意味着可以安全地重复而不会改变结果。例如，将 $B_{\\text{new}}$ 写入一个块是幂等的。如果在这个“应用”阶段发生崩溃，恢复过程将在下次启动时简单地重新启动并重新应用更改，最终将系统带到完整的新状态 $(B_{\\text{new}}, P_{\\text{new}}, L_{\\text{new}})$。\n\n从恢复后用户的角度来看，该机制确保文件系统从旧状态原子地转换到新状态。恢复过程描述正确地描述了这个过程及其结果。该协议是健全的，并正确地保证了不变量 $I$。\n结论：**正确**。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "在理解了写时复制和撤销日志（undo logging）等协议的概念差异之后，一个关键的工程决策是为特定工作负载选择性能最佳的方案。本练习将带你从定性理解转向定量分析。你将基于底层硬件延迟构建一个成本模型，以确定一个协议在何种条件下比另一个更高效，这是系统设计中性能调优的一项关键技能。",
            "id": "3669271",
            "problem": "一个操作系统将非易失性存储器（NVM）集成到其内存层次结构中。一个简单的持久化键值映射存储为大小为 $S$ 字节的单个连续区域，并通过写时复制或撤销日志实现崩溃一致性。硬件暴露的缓存行大小为 $L$ 字节。假设记录大小 $s$ 和区域大小 $S$ 都是 $L$ 的整数倍，即对于某些正整数 $q$ 和 $m$，有 $s = qL$ 和 $S = mL$。该平台提供两种原语：(i) 缓存行持久化操作，使单个缓存行以延迟 $t_{p}$ 变为持久化状态；(ii) 存储栅栏，其延迟为 $t_{sf}$，用于对先前发出的持久化操作进行排序并等待其完成持久化。所有其他成本（例如，分配和计算）均可忽略不计。假设操作是串行执行的，并且持久化延迟没有重叠。\n\n考虑一个执行 $N$ 次更新的事务，每次更新都精确地修改一个大小为 $s$ 字节且与缓存行边界对齐的记录。实现了两种更新协议：\n\n- 写时复制（CoW）：系统分配整个映射区域的一个全新副本，复制整个区域，持久化新区域，然后安装一个指向该副本区域的新根指针并持久化该指针。在所有持久化操作之后，会发出一个存储栅栏，以确保在返回成功之前数据已持久化。\n\n- 撤销日志（Undo Logging）：对于每次更新，系统会写入一条包含被覆盖的 $s$ 字节的撤销日志记录，持久化该日志记录以确保其在原地更新之前是持久且有序的，然后执行记录的原地更新并持久化修改后的数据。每次更新都会发出一个存储栅栏，以强制撤销日志在原地数据写入被视为完成之前是持久的，并且在所有更新之后还会发出一个额外的最终存储栅栏，以确保所有修改的数据在返回成功之前都已持久化。\n\n仅使用以下基本事实：\n- 崩溃一致性要求，在新数据被部分持久化的情况下，旧状态必须是可恢复的。这可以通过在安装指针之前持久化一个备用副本（写时复制）或在原地更新之前持久化一条撤销日志来实现。\n- 一个缓存行只有在其持久化操作完成后才变为持久状态；跨缓存行的持久化顺序需要通过存储栅栏来保证。\n- 时间成本是所有缓存行持久化延迟的总和加上所有存储栅栏延迟的总和，以累加方式计算，\n\n从第一性原理推导出一个闭式表达式，用于计算最小整数阈值 $N_{\\text{th}}$，使得对于 $N$ 次更新，撤销日志协议的总持久化成本（持久化延迟加栅栏延迟）大于或等于写时复制协议的总持久化成本，即，写时复制变得不比撤销日志更昂贵的最小 $N$ 值。\n\n用符号 $S$、$s$、$L$、$t_{p}$ 和 $t_{sf}$ 表示 $N_{\\text{th}}$。你的最终答案必须是一个单一的闭式解析表达式。最终答案中不要包含单位。",
            "solution": "用户提供了一个有效且定义明确的问题陈述。它描述了操作系统中的一个性能建模场景，基于持久性内存、崩溃一致性协议及其相关成本的标准概念。我将进行严格的推导。\n\n目标是找到最小整数阈值 `$N_{\\text{th}}$`，使得对于 `$N$` 次更新，撤销日志协议的总持久化成本（表示为 `$T_{\\text{undo}}$`）大于或等于写时复制协议的总持久化成本（表示为 `$T_{\\text{CoW}}$`）。这可以表示为满足不等式 `$T_{\\text{undo}} \\ge T_{\\text{CoW}}$` 的最小整数 `$N$`。\n\n首先，我将推导写时复制（CoW）协议的总成本 `$T_{\\text{CoW}}$` 的表达式。该成本是所有必需的持久化操作和存储栅栏操作的延迟总和。\n1.  **持久化新区域副本：**区域大小为 `$S$` 字节，缓存行大小为 `$L$` 字节。由于 `$S$` 是 `$L$` 的整数倍，区域中的缓存行数量为 `$\\frac{S}{L}$`。持久化一个缓存行的延迟是 `$t_p$`。因此，使整个新区域持久化的成本是 `$\\frac{S}{L} t_p$`。\n2.  **持久化根指针：**问题陈述中提到系统“持久化该指针”。基本的硬件原语是缓存行持久化操作。我们假设该指针包含在单个缓存行内。因此，持久化该指针会产生一次缓存行持久化操作的成本，即 `$t_p$`。\n3.  **存储栅栏：**协议在所有持久化操作发出后，会发出一个存储栅栏。这会增加 `$t_{sf}$` 的延迟。\n\n由于操作是串行执行的，CoW 协议的总成本是这些成本的总和：\n$$T_{\\text{CoW}} = \\frac{S}{L} t_p + t_p + t_{sf} = \\left(\\frac{S}{L} + 1\\right) t_p + t_{sf}$$\n\n接下来，我将推导包含 `$N$` 次更新的事务中，撤销日志协议的总成本 `$T_{\\text{undo}}$` 的表达式。\n该协议指定了为 `$N$` 次更新中的每一次所执行的一系列操作，外加一个最终操作。\n对于 `$N$` 次更新中的每一次：\n1.  **持久化撤销日志记录：**写入一个大小为 `$s$` 字节的撤销日志记录。由于 `$s$` 是 `$L$` 的整数倍，这需要持久化 `$\\frac{s}{L}$` 个缓存行。成本为 `$\\frac{s}{L} t_p$`。\n2.  **存储栅栏：**发出一个存储栅栏以确保撤销日志在原地更新前是持久的。成本为 `$t_{sf}$`。\n3.  **持久化修改后的数据：**原地更新修改了一个大小为 `$s$` 的记录，跨越 `$\\frac{s}{L}$` 个缓存行。持久化这些修改后的数据行成本为 `$\\frac{s}{L} t_p$`。\n\n单次更新的成本是这些延迟的总和：`$\\frac{s}{L} t_p + t_{sf} + \\frac{s}{L} t_p = 2\\frac{s}{L} t_p + t_{sf}$`。\n因为有 `$N$` 次这样的更新，所有更新的累计成本是 `$N \\left(2\\frac{s}{L} t_p + t_{sf}\\right)$`。\n最后，协议在所有更新完成后发出“一个额外的最终存储栅栏”。这会增加 `$t_{sf}$` 的成本。\n\n撤销日志协议的总成本是：\n$$T_{\\text{undo}} = N \\left(2\\frac{s}{L} t_p + t_{sf}\\right) + t_{sf}$$\n\n现在，我将建立不等式 `$T_{\\text{undo}} \\ge T_{\\text{CoW}}$` 并求解 `$N$`。\n$$N \\left(2\\frac{s}{L} t_p + t_{sf}\\right) + t_{sf} \\ge \\left(\\frac{S}{L} + 1\\right) t_p + t_{sf}$$\n两边的 `$t_{sf}$` 项可以消掉：\n$$N \\left(2\\frac{s}{L} t_p + t_{sf}\\right) \\ge \\left(\\frac{S}{L} + 1\\right) t_p$$\n项 `$\\left(2\\frac{s}{L} t_p + t_{sf}\\right)$` 是延迟和大小的总和，这些都是正量。因此，该项本身是正的，我们可以用它来除不等式两边而不改变不等号的方向。\n$$N \\ge \\frac{\\left(\\frac{S}{L} + 1\\right) t_p}{2\\frac{s}{L} t_p + t_{sf}}$$\n为了简化表达式，我将分子和分母同乘以 `$L$`：\n$$N \\ge \\frac{L \\left(\\frac{S}{L} + 1\\right) t_p}{L \\left(2\\frac{s}{L} t_p + t_{sf}\\right)}$$\n$$N \\ge \\frac{(S + L) t_p}{2s t_p + L t_{sf}}$$\n问题要求满足此条件的最小*整数*阈值 `$N_{\\text{th}}$`。这正是对不等式右侧应用向上取整函数的定义。\n因此，`$N_{\\text{th}}$` 的表达式为：\n$$N_{\\text{th}} = \\left\\lceil \\frac{(S + L) t_p}{2s t_p + L t_{sf}} \\right\\rceil$$\n这是撤销日志成本达到或超过写时复制成本时的最小整数 `$N$` 的闭式解析表达式。",
            "answer": "$$\\boxed{\\left\\lceil \\frac{(S + L) t_p}{2s t_p + L t_{sf}} \\right\\rceil}$$"
        },
        {
            "introduction": "崩溃一致性的理论知识必须转化为具体、健壮的代码。像“撕裂写入”（torn writes）这样的底层问题——即多字节写入操作被崩溃中断——如果处理不当，很容易导致数据损坏。这个动手编码挑战让你从零开始实现一个容错数据结构。通过构建一个能利用复制和完整性校验在撕裂写入后幸存的持久化单调计数器，你将在为持久内存设计和实现面向恢复的逻辑方面获得宝贵实践经验。",
            "id": "3669254",
            "problem": "您被要求形式化并实现一个存储在持久内存（PMem）中的单调计数器，该计数器通过使用一种每半边带有一位奇偶校验的两阶段更新协议来抵御撕裂写。在此问题中，单调计数器是一个在每次成功更新时仅增加 $1$ 的值。内存模型如下：存在两个不相交的半区，表示为 $S_0$ 和 $S_1$，每个半区存储一个三元组 $(v_i, p_i, ph_i)$，其中 $v_i$ 是无符号计数值，$p_i \\in \\{0,1\\}$ 是一个奇偶校验位，$ph_i \\in \\{0,1\\}$ 是一个在每次成功更新时翻转的相位位。假设在一个崩溃故障模型中，崩溃可能在更新过程中的任何时候发生，可能导致一个半区被部分更新，从而使得存储的奇偶校验值与计数值不再匹配。目标是提供数学上合理的恢复步骤，以在崩溃后协调不匹配的半区并选择正确的计数值。\n\n基本原理和假设：\n- 持久内存（PMem）是字节可寻址且非易失性的。崩溃可能会中断一个写序列，导致一个撕裂写状态，即一个半区的某些字段已更新而其他字段未更新。然而，不相交的半区 $S_0$ 和 $S_1$ 是在不同的步骤中写入的。\n- 单调计数器在每次完整更新后增加 $1$，并且根据设计永远不会减少。\n- 一个简单的数据完整性检查是存储值的奇偶性：定义奇偶校验函数 $\\pi(v)$ 为 $v$ 的所有比特位相加后对 $2$ 取模，即 $$\\pi(v) = \\left( \\sum_{j=0}^{b-1} b_j \\right) \\bmod 2,$$ 其中 $b$ 是 $v$ 的位宽（实现时使用标准的无符号整数类型），$b_j$ 是 $v$ 在位置 $j$ 上的比特值。\n- 两阶段更新协议将新值写入一个半区并将其持久化（值、其奇偶校验位和翻转后的相位位），然后将相同的内容写入另一个半区并持久化。更新操作会将共享的相位位从 $ph$ 翻转为 $ph' = 1 - ph$。\n\n恢复过程必须从这些基础推导得出。设崩溃后观测到的状态为 $(v_0, p_0, ph_0)$ 和 $(v_1, p_1, ph_1)$。通过存储的奇偶校验值是否等于重新计算的奇偶校验值来定义半区的有效性，即 $$\\text{valid}_i = \\left[ \\pi(v_i) = p_i \\right].$$ 一个科学上合理的恢复例程必须：\n- 优先选择奇偶校验值与计数值匹配的半区。\n- 如果两个半区都有效且相位和值都相等，则接受该值。\n- 如果两个半区都有效但在相位或值上不同，则根据单调性约束，恢复的值应为两者中较大的值。\n- 如果只有一个半区有效，则接受其值。\n- 如果两个半区都无效，则返回两者中较小的值，以避免在没有完整性证据的情况下捏造一个未来的值，并将状态标记为已降级。\n\n此外，请提出协调步骤，以便在下一次更新之前将不匹配的半区重新同步回一致状态。对于此问题，将协调计划定义为：\n- 一个布尔标志（表示为整数），用于指示是否需要重新同步，$$\\text{needs\\_resync} \\in \\{0,1\\},$$ 如果存在任何不匹配（奇偶校验、相位或值），则为 $1$，否则为 $0$。\n- 一个整数，用于指示首先更新哪个半区以修复状态，$$\\text{first\\_half\\_to\\_update} \\in \\{0,1\\},$$ 其中 $0$ 表示首先更新 $S_0$，$1$ 表示首先更新 $S_1$。如果两个半区都有效但不同，则首先更新持有较小值的半区。如果只有一个半区无效，则首先更新无效的半区。如果两个半区都无效，则首先更新持有较小值的半区。如果不需要重新同步，则选择 $0$。\n\n您的任务是编写一个完整的程序，该程序在给定嵌入代码中的固定测试套件的情况下，应用恢复算法并为每个测试用例输出一个三元组 $[v,\\ \\text{needs\\_resync},\\ \\text{first\\_half\\_to\\_update}]$，其中 $v$ 是恢复的整数计数值。程序必须生成单行输出，其中包含这些三元组的列表，格式为用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 案例 1（正常路径，两个半区一致）：$S_0: v_0 = 42, p_0 = \\pi(42), ph_0 = 0$; $S_1: v_1 = 42, p_1 = \\pi(42), ph_1 = 0$。\n- 案例 2（在两阶段之间崩溃，左边是新值，右边是旧值）：$S_0: v_0 = 43, p_0 = \\pi(43), ph_0 = 1$; $S_1: v_1 = 42, p_1 = \\pi(42), ph_1 = 0$。\n- 案例 3（左半区发生撕裂写，奇偶校验不正确）：$S_0: v_0 = 43, p_0 \\neq \\pi(43)$ 设为 $p_0 = 1 - \\pi(43), ph_0 = 1$; $S_1: v_1 = 42, p_1 = \\pi(42), ph_1 = 0$。\n- 案例 4（右半区发生撕裂写，奇偶校验不正确）：$S_0: v_0 = 43, p_0 = \\pi(43), ph_0 = 1$; $S_1: v_1 = 43, p_1 \\neq \\pi(43)$ 设为 $p_1 = 1 - \\pi(43), ph_1 = 1$。\n- 案例 5（两者奇偶校验均有效但值不同，相位相同，属于损坏的边缘情况）：$S_0: v_0 = 100, p_0 = \\pi(100), ph_0 = 0$; $S_1: v_1 = 99, p_1 = \\pi(99), ph_1 = 0$。\n- 案例 6（两个奇偶校验均无效）：$S_0: v_0 = 7, p_0 = 0$ 尽管 $\\pi(7) = 1$, $ph_0 = 0$; $S_1: v_1 = 8, p_1 = 0$ 尽管 $\\pi(8) = 1$, $ph_1 = 0$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含结果，形式为每个测试用例的三元组的逗号分隔列表，每个三元组的格式为 $[v,\\text{needs\\_resync},\\text{first\\_half\\_to\\_update}]$，整个列表用方括号括起来。例如，格式为 $$[[v_1,\\text{needs}_1,\\text{first}_1],[v_2,\\text{needs}_2,\\text{first}_2],\\dots].$$",
            "solution": "该问题要求对存储在持久内存（PMem）中的容错单调计数器进行恢复与协调算法的形式化和实现。计数器的状态被复制到两个不相交的半区 $S_0$ 和 $S_1$ 中，以防止更新期间因撕裂写导致的数据损坏。\n\n对于 $i \\in \\{0, 1\\}$，每个半区 $S_i$ 的状态是一个三元组 $(v_i, p_i, ph_i)$，其中 $v_i$ 是计数值，$p_i$ 是其奇偶校验位，$ph_i$ 是相位位。解决方案的核心在于一个系统性的、基于原则的流程，用于解释崩溃后 $S_0$ 和 $S_1$ 可能不一致的状态，并确定计数器的正确当前值以及恢复一致性所需的必要步骤。\n\n恢复过程的基础是由奇偶校验位提供的数据完整性检查。我们定义一个奇偶校验函数 $\\pi(v)$，它计算值 $v$ 的所有比特位相加后对 2 取模的结果。如果一个半区 $S_i$ 存储的奇偶校验值 $p_i$ 与其值 $v_i$ 重新计算出的奇偶校验值相匹配，则该半区被认为是“有效的”。此检查表示为一个布尔条件：$\\text{valid}_i = [\\pi(v_i) = p_i]$。\n\n恢复和协调算法分两个主要阶段进行：状态评估以确定恢复的值，以及规划同步以恢复一致状态。\n\n**1. 状态评估与值恢复**\n\n第一步是为 $S_0$ 和 $S_1$ 崩溃后的状态计算 $\\text{valid}_0$ 和 $\\text{valid}_1$。基于两个半区的有效性，我们应用一套基于单调性和数据完整性原则的规则来确定正确的计数值 $v$。\n\n- **情况 1：两个半区都有效 ($\\text{valid}_0 \\land \\text{valid}_1$)。**\n如果两个半区都有正确的奇偶校验，我们就信任它们的值。两阶段更新协议意味着一个半区可能存储旧值，而另一个半区存储新的、已递增的值。由于单调计数器属性（值只增不减），正确的状态是值较大的那一个。因此，恢复的值为 $v = \\max(v_0, v_1)$。这条规则也能正确处理两个半区完全相同的“正常路径”（$v_0 = v_1$），因为 $\\max(v_0, v_0) = v_0$。\n\n- **情况 2：只有一个半区有效 ($\\text{valid}_0 \\oplus \\text{valid}_1$)。**\n如果一个半区具有有效的奇偶校验而另一个没有，则无效的半区被认为是被撕裂写所损坏。我们必须丢弃损坏的数据，并信任完好的那个半区。如果 $S_i$ 是有效的半区，则恢复的值为 $v = v_i$。\n\n- **情况 3：两个半区都无效 ($\\neg \\text{valid}_0 \\land \\neg \\text{valid}_1$)。**\n这是最严重的故障情况，表明两个半区可能都已损坏。在没有任何完整性证据的情况下，我们无法可靠地确定正确的最新值。为避免捏造一个可能从未达到过的未来状态，算法必须采用一种保守的回退策略。问题强制要求选择两个值中较小的一个，$v = \\min(v_0, v_1)$。这一选择代表了回滚到“最安全”的可能状态，并承认系统状态已降级。\n\n**2. 协调计划**\n\n在恢复计数值之后，系统必须恢复到一个两个半区完全一致的状态。协调计划由两个部分组成：一个指示是否需要操作的标志（$\\text{needs\\_resync}$），以及一个关于首先更新哪个半区的指令（$\\text{first\\_half\\_to\\_update}$）。\n\n- **$\\text{needs\\_resync} \\in \\{0, 1\\}$**：如果两个半区 $S_0$ 和 $S_1$ 不相同，则需要重新同步。仅当 $v_0 = v_1$, $p_0 = p_1$ 且 $ph_0 = ph_1$ 时，状态才是一致的且无需重新同步。在所有其他情况下，$\\text{needs\\_resync}$ 设置为 $1$。\n\n- **$\\text{first\\_half\\_to\\_update} \\in \\{0, 1\\}$**：如果需要重新同步，此值决定了操作的顺序。其逻辑源自相同的状态评估：\n    - 如果不需要重新同步，此值按惯例设置为 $0$。\n    - 如果两个半区都有效但不同（在值或相位上）：必须更新包含较旧（较小）值的半区，使其与较新（较大）的半区匹配。因此，我们首先更新 $v_i = \\min(v_0, v_1)$ 的那个半区 $S_i$。如果 $v_0 = v_1$ 但相位不同，则必须使用确定性的打破平局规则；我们选择首先更新 $S_0$。\n    - 如果只有一个半区 $S_i$ 无效：无效的半区是需要修复的那个。我们必须首先更新 $S_i$。\n    - 如果两个半区都无效：必须用恢复的状态覆盖两个半区。规则是首先更新持有较小值的半区。如果 $v_0=v_1$，我们使用相同的打破平局规则，首先更新 $S_0$。\n\n这个完整的算法提供了一种严谨且确定性的方法，以确保单调计数器在发生崩溃故障时仍能保持可用和一致。最终的实现将此逻辑转化为一个处理给定测试用例的程序。",
            "answer": "$$\\boxed{[[42, 0, 0], [43, 1, 1], [42, 1, 0], [43, 1, 1], [100, 1, 1], [7, 1, 0]]}$$"
        }
    ]
}