{
    "hands_on_practices": [
        {
            "introduction": "为了优化I/O性能，我们首先必须能够对其进行测量。这个练习将挑战你像系统分析师一样思考，将总I/O延迟分解为它在操作系统内部经过的各个不同阶段。通过定义精确的测量点，你将能够定位瓶颈并理解时间具体消耗在哪里。",
            "id": "3648623",
            "problem": "在一个类 Linux 操作系统中，一个单线程应用程序发起了一个同步文件读取的系统调用。该请求按顺序穿过以下软件和硬件层：系统调用边界、文件系统层、块 I/O 层、设备驱动程序和存储设备。为便于分析，假设此路径发生一次且无重试，并且各层按顺序执行，没有重叠。允许您在内核和驱动程序边界放置跟踪探针。您的目标是设计测量点的位置，并使用提供的跟踪数据来计算端到端延迟。\n\n任务：\n- 提出具体的测量点，在 I/O 路径上每个相邻层之间的边界处以及设备完成信号处各设一个，以便将每个层所花费的时间捕获为不重叠的时间间隔，并且各层时间之和等于从系统调用进入到返回用户空间的总时间。简要说明您选择的测量点为何能使各层持续时间可相加且不相交。\n- 一次内核跟踪捕获了这样一次 I/O 的以下时间戳，按时间顺序排列。所有时间戳都以微秒为单位，相对于一个任意的参考点。设有序点为 $P_{0}, P_{1}, P_{2}, P_{3}, P_{4}, P_{5}, P_{6}, P_{7}, P_{8}, P_{9}$，其数值如下：\n  - $P_{0} = 0$\n  - $P_{1} = 8$\n  - $P_{2} = 33$\n  - $P_{3} = 73$\n  - $P_{4} = 85$\n  - $P_{5} = 285$\n  - $P_{6} = 300$\n  - $P_{7} = 310$\n  - $P_{8} = 319$\n  - $P_{9} = 325$\n  假设 $P_{0}$ 对应于系统调用进入内核的时刻，$P_{9}$ 对应于系统调用返回用户空间的时刻。中间点对应于内部层边界和设备完成，与您所提议的良好检测的 I/O 路径一致。\n- 使用您提议的测量点映射到给定的 $P_{i}$ 序列，计算从系统调用进入到返回的端到端延迟。\n\n以微秒表示最终延迟，并将您的答案四舍五入到四位有效数字。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **应用程序**：一个单线程应用程序发起了一个同步文件读取的系统调用。\n- **操作系统**：一个类 Linux 操作系统。\n- **I/O 路径层级**：该请求按顺序穿过：系统调用边界、文件系统层、块 I/O 层、设备驱动程序和存储设备。\n- **执行模型**：各层按顺序执行，没有重叠；路径发生一次且无重试。\n- **测量任务**：在每个边界处提出具体的测量点，以将每个层所花费的时间捕获为不重叠的时间间隔，使其总和等于总时间。\n- **跟踪数据**：按时间顺序排列的时间戳序列 $P_{0}, P_{1}, \\dots, P_{9}$，单位为微秒 ($\\mu s$)。\n  - $P_{0} = 0$\n  - $P_{1} = 8$\n  - $P_{2} = 33$\n  - $P_{3} = 73$\n  - $P_{4} = 85$\n  - $P_{5} = 285$\n  - $P_{6} = 300$\n  - $P_{7} = 310$\n  - $P_{8} = 319$\n  - $P_{9} = 325$\n- **时间戳映射**：\n  - $P_{0}$ 对应于系统调用进入内核。\n  - $P_{9}$ 对应于系统调用返回用户空间。\n  - 中间点 $P_1, \\dots, P_8$ 对应于内部层边界和设备完成。\n- **计算任务**：计算从系统调用进入到返回的端到端延迟。\n- **输出要求**：以微秒表示最终延迟，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定的验证标准对问题进行评估。\n- **科学依据**：该问题描述了 I/O 请求处理路径，这是操作系统中的一个基本概念，也是计算机科学与工程领域的核心学科。指定的层级（文件系统、块 I/O、设备驱动程序）以及使用探针进行跟踪的概念是标准的且符合事实。\n- **适定性**：该问题是适定的。它要求对测量点进行概念设计，并进行一项具体计算，而所有必要的数据（$P_0$ 和 $P_9$）都已明确提供。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n- **缺陷分析**：\n  1.  **科学或事实不准确**：无。该模型是用于分析的有效简化。所提供的时间戳对于像 SSD 这样的快速存储设备是合理的。\n  2.  **不可形式化或不相关**：该问题是可形式化的，并且与其所述主题——*操作系统导论*中的*I/O 请求处理路径*直接相关。\n  3.  **设置不完整或矛盾**：无。问题提供了计算端到端延迟所需的所有信息。定义测量点的概念性任务是自洽的，与计算不冲突。\n  4.  **不切实际或不可行**：无。物理模型和数据与现代硬件的现实情况一致。\n  5.  **不适定或结构不良**：无。问题清晰，并允许一个唯一、稳定的解。\n  6.  **故作高深、琐碎或同义反复**：最终的计算是直接的，因为它直接从提供的开始和结束时间戳导出。然而，这被嵌入到一个需要操作系统 I/O 栈概念知识的任务中。这种结构测试了仔细阅读和领域知识，不被认为是一个缺陷，而是一种有效的教学方法。整个问题并非微不足道。\n  7.  **超出科学可验证性**：无。概念和计算都是可验证的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个合理的解决方案。\n\n---\n\n### 解决方案\n\n该问题需要完成两个主要任务：首先，提出一组测量点，将总 I/O 延迟划分为与 I/O 栈不同层级相对应的、不相交且可相加的组件；其次，使用提供的跟踪数据计算端到端延迟。\n\n#### 任务 1：提出测量点\n\n一个同步 I/O 请求涉及一个请求路径（从软件栈向下到硬件）和一个完成路径（从硬件向上返回用户进程）。为了捕获每个不同阶段所花费的时间，我们必须在每个层的进入点和退出点为两个路径都放置探针。设测量点用 $M_i$ 表示。\n\n1.  $M_0$：**系统调用入口**。执行上下文从用户模式切换到内核模式以处理读系统调用的时刻。这对应于给定的 $P_0$。\n2.  $M_1$：**文件系统入口（请求路径）**。通用系统调用处理程序已将请求分派给虚拟文件系统（VFS）层。区间 $[M_0, M_1]$ 表示系统调用的前端开销。\n3.  $M_2$：**块 I/O 层入口（请求路径）**。文件系统已完成其任务（例如，路径解析、权限检查、将文件偏移量转换成逻辑块地址）并向块 I/O 层发出请求。区间 $[M_1, M_2]$ 是在请求路径上文件系统花费的时间。\n4.  $M_3$：**设备驱动程序入口（请求路径）**。块 I/O 层已处理请求（例如，I/O 调度、请求合并）并将其分派给相应的设备驱动程序。区间 $[M_2, M_3]$ 是在块 I/O 层花费的时间。\n5.  $M_4$：**向硬件发出请求**。设备驱动程序已通过 I/O 命令对硬件控制器进行编程。此时，当设备忙碌时，CPU 可以被调度去执行其他任务。区间 $[M_3, M_4]$ 是在请求路径上驱动程序花费的时间。\n6.  $M_5$：**设备完成中断**。存储设备已完成读取操作，并通过中断向 CPU 发出信号。区间 $[M_4, M_5]$ 代表硬件服务时间，包括任何设备上的排队时间。\n7.  $M_6$：**通知块 I/O 层（完成路径）**。设备驱动程序的中断处理程序已完成其工作（例如，检查状态、确认中断）并正在将完成信号向上传播到块 I/O 层。区间 $[M_5, M_6]$ 是驱动程序内的中断处理时间。\n8.  $M_7$：**通知文件系统（完成路径）**。块 I/O 层已完成其后处理（例如，唤醒等待的进程、处理请求队列更新）并通知文件系统。区间 $[M_6, M_7]$ 是块层的完成处理时间。\n9.  $M_8$：**系统调用终结**。文件系统已完成其最终任务（例如，将读取的数据从内核缓冲区复制到用户空间缓冲区，更新文件元数据如访问时间）。系统调用现在准备返回。区间 $[M_7, M_8]$ 是文件系统的完成处理时间。\n10. $M_9$：**系统调用返回**。内核完成系统调用执行，上下文切换回用户模式，解除应用程序的阻塞。这对应于给定的 $P_9$。区间 $[M_8, M_9]$ 代表系统调用后端和上下文切换的开销。\n\n这十个测量点，$M_0$ 到 $M_9$，定义了九个连续的、不重叠的时间间隔。每个阶段 $k$ 的持续时间为 $T_k = M_k - M_{k-1}$，其中 $k \\in \\{1, 2, \\dots, 9\\}$。总的端到端延迟是这些持续时间的总和：\n$$ \\text{Total Latency} = \\sum_{k=1}^{9} (M_k - M_{k-1}) $$\n这构成了一个伸缩求和：\n$$ (M_1 - M_0) + (M_2 - M_1) + \\dots + (M_9 - M_8) = M_9 - M_0 $$\n因此，这些不相交区间的持续时间总和恰好等于从系统调用进入（$M_0$）到系统调用返回（$M_9$）所经过的总时间，满足了问题的要求。\n\n#### 任务 2：计算端到端延迟\n\n问题要求计算从系统调用进入到返回的端到端延迟。根据定义，这是这两个事件之间经过的总时间。\n\n给定的跟踪数据包括：\n- $P_0 = 0 \\, \\mu s$：系统调用进入的时间戳。\n- $P_9 = 325 \\, \\mu s$：系统调用返回的时间戳。\n\n中间点 $P_1$ 到 $P_8$ 对应于上面提出的内部测量点 $M_1$ 到 $M_8$。虽然这些点对于分析单个层的性能是必要的，但计算*总端到端延迟*并不需要它们。\n\n端到端延迟 $L$ 直接计算为最终和初始时间戳之间的差值：\n$$ L = P_9 - P_0 $$\n代入给定值：\n$$ L = 325 \\, \\mu s - 0 \\, \\mu s = 325 \\, \\mu s $$\n问题要求答案四舍五入到四位有效数字。数字 $325$ 有三位有效数字。为了用四位有效数字表示这个值，我们将其写为 $325.0$。\n\n因此，端到端延迟为 $325.0 \\, \\mu s$。",
            "answer": "$$\n\\boxed{325.0}\n$$"
        },
        {
            "introduction": "并非所有的I/O请求都是相同的；许多请求可以通过页面缓存直接从内存中服务，从而避免缓慢的设备访问。这项实践引入了一个概率模型，用以量化缓存带来的性能优势。通过推导期望延迟 ()，你将掌握一个强大的工具，来理解缓存命中率如何影响系统的整体响应能力。",
            "id": "3648639",
            "problem": "一个通用操作系统上的进程发出对固定大小页面的同步读取请求。该操作系统采用页面缓存：对于每次读取，所请求的页面要么已在内存中（缓存命中），要么必须从存储设备中获取（缓存未命中）。考虑单次读取的输入/输出（I/O）请求处理路径如下：\n- 缓存命中时，路径为：应用程序 $\\rightarrow$ 内核页面缓存 $\\rightarrow$ 内存复制到用户空间。端到端延迟为一个常数 $L_{\\text{cache}}$。\n- 缓存未命中时，路径为：应用程序 $\\rightarrow$ 虚拟文件系统层 $\\rightarrow$ 文件系统 $\\rightarrow$ 块层 $\\rightarrow$ 设备驱动程序 $\\rightarrow$ 存储设备 $\\rightarrow$ 通过内核返回完成并进行内存复制。端到端延迟为一个常数 $L_{\\text{device}}$。\n\n为进行高级分析，假设以下科学上合理且常用的建模假设：\n- 每次读取独立地具有缓存命中概率 $\\Pr(\\text{hit}) = p$ 和缓存未命中概率 $\\Pr(\\text{miss}) = 1 - p$。\n- 延迟 $L_{\\text{cache}}$ 和 $L_{\\text{device}}$ 分别是各自路径的确定性常数。\n- 不存在排队重叠或并发；孤立地分析单次读取。\n\n从概率论中期望的公理化定义和全期望定律出发，推导单次读取的期望延迟 $E[L]$ 关于 $p$、$L_{\\text{cache}}$ 和 $L_{\\text{device}}$ 的通用表达式。然后，使用参数 $p = 0.93$、$L_{\\text{cache}} = 0.12$ 毫秒和 $L_{\\text{device}} = 7.4$ 毫秒，对你的表达式进行数值计算。将最终数值答案四舍五入到四位有效数字。以毫秒为单位表示最终延迟。",
            "solution": "问题陈述具有科学依据、提法恰当、客观，并包含了唯一解所需的所有必要信息。所描述的模型是计算机操作系统中 I/O 延迟的一个标准简化表示，给定的参数是符合实际的。因此，该问题是有效的，我们可以继续进行求解。\n\n设 $L$ 为表示单次读取请求的端到端延迟的随机变量。问题描述了这次读取的两个互斥且穷尽的结果：缓存命中或缓存未命中。设 $H$ 表示缓存命中事件，$M$ 表示缓存未命中事件。事件集合 $\\{H, M\\}$ 构成了样本空间的一个划分。\n\n根据问题陈述，这些事件的概率如下：\n- 缓存命中的概率为 $\\Pr(H) = p$。\n- 缓存未命中的概率为 $\\Pr(M) = 1 - p$。\n\n读取的延迟是取决于发生哪个事件的确定性常数：\n- 如果发生缓存命中（事件 $H$），延迟为 $L | H = L_{\\text{cache}}$。\n- 如果发生缓存未命中（事件 $M$），延迟为 $L | M = L_{\\text{device}}$。\n\n我们的任务是从基本原理出发，特别是使用全期望定律，推导期望延迟 $E[L]$。全期望定律指出，对于任何随机变量 $X$ 和样本空间的一个划分 $\\{A_i\\}$， $X$ 的期望值由下式给出：\n$$E[X] = \\sum_i E[X | A_i] \\Pr(A_i)$$\n\n将此定律应用于我们的随机变量 $L$ 和划分 $\\{H, M\\}$，我们可以将期望延迟写为：\n$$E[L] = E[L | H] \\Pr(H) + E[L | M] \\Pr(M)$$\n\n接下来，我们必须计算条件期望 $E[L | H]$ 和 $E[L | M]$。一个以概率 $1$ 取单一值 $c$ 的离散随机变量 $Y$ 的期望的公理化定义是 $E[Y] = c \\cdot 1 = c$。\n在我们的情况下，随机变量‘给定缓存命中时的延迟’（$L|H$）仅取单一常数值 $L_{\\text{cache}}$。因此，其期望值为：\n$$E[L | H] = L_{\\text{cache}}$$\n类似地，随机变量‘给定缓存未命中时的延迟’（$L|M$）仅取单一常数值 $L_{\\text{device}}$。其期望值为：\n$$E[L | M] = L_{\\text{device}}$$\n\n将这些条件期望和给定的概率代入 $E[L]$ 的表达式中：\n$$E[L] = (L_{\\text{cache}}) \\cdot \\Pr(H) + (L_{\\text{device}}) \\cdot \\Pr(M)$$\n这就得出了期望延迟的通用表达式：\n$$E[L] = p \\cdot L_{\\text{cache}} + (1 - p) \\cdot L_{\\text{device}}$$\n\n现在，我们使用提供的参数对此表达式进行数值计算：\n- $p = 0.93$\n- $L_{\\text{cache}} = 0.12$ 毫秒\n- $L_{\\text{device}} = 7.4$ 毫秒\n\n将这些值代入我们推导出的公式中：\n$$E[L] = (0.93) \\cdot (0.12) + (1 - 0.93) \\cdot (7.4)$$\n$$E[L] = (0.93) \\cdot (0.12) + (0.07) \\cdot (7.4)$$\n\n我们分别计算每一项：\n- 来自缓存命中的贡献： $(0.93) \\cdot (0.12) = 0.1116$ 毫秒。\n- 来自缓存未命中的贡献： $(0.07) \\cdot (7.4) = 0.518$ 毫秒。\n\n将两部分贡献相加，得到总的期望延迟：\n$$E[L] = 0.1116 + 0.518 = 0.6296 \\text{ milliseconds}$$\n\n问题要求将最终答案四舍五入到四位有效数字。计算出的值 $0.6296$ 已经恰好是四位有效数字（数字 $6$、$2$、$9$、$6$），因此无需进一步四舍五入。",
            "answer": "$$\\boxed{0.6296}$$"
        },
        {
            "introduction": "在多任务系统中，I/O调度器必须智能地仲裁竞争应用程序对存储设备的访问。本练习深入探讨了加权公平队列（Weighted Fair Queuing, WFQ），这是一种常见的调度策略，并使用排队论来预测不同流量类别的性能。这种建模方法对于设计能够提供服务质量（QoS）保证的系统至关重要 ()。",
            "id": "3648722",
            "problem": "一个操作系统的块I/O调度器使用加权公平队列（Weighted Fair Queuing, WFQ）来仲裁三个请求类别之间的服务，这些请求都汇入一个单一的磁盘设备。WFQ被建模为通用处理器共享（Generalized Processor Sharing, GPS）的近似：当多个类别出现积压时，类别 $i$ 被保证获得设备服务容量的一个最小部分，该部分与其权重 $w_i$ 成正比，即份额 $\\phi_i$ 由其权重与总权重之比给出。当设备连续工作时，它可以以每秒 $C$ 个请求的总速率完成请求。假设每个类别都以泊松过程（Poisson process）生成请求，到达率为每秒 $\\lambda_i$ 个请求，且每个请求的服务时间是独立且呈指数分布的。假设调度器连续强制执行最小速率份额，因此当类别 $i$ 积压时，它会经历一个有效服务率为 $\\mu_i = \\phi_i C$ 的专用服务器。\n\n使用以下参数：\n- 类别权重：$w_1 = 2$， $w_2 = 1$， $w_3 = 3$。\n- 设备容量：$C = 30000$ 个请求/秒。\n- 到达率：$\\lambda_1 = 9000$ 个请求/秒，$\\lambda_2 = 3500$ 个请求/秒，$\\lambda_3 = 12000$ 个请求/秒。\n\n从WFQ份额映射的核心定义和具有泊松到达和指数服务的单服务器队列的标准生灭分析出发，根据第一性原理推导出在该调度器模型下每个类别 $i$ 的稳态平均请求延迟（逗留时间）$T_i$ 的解析表达式，然后计算 $T_1$、$T_2$ 和 $T_3$ 的数值。将每个延迟表示为毫秒，并将答案四舍五入到四位有效数字。按 $(T_1, T_2, T_3)$ 的顺序，将这三个延迟报告在单行中。",
            "solution": "首先验证问题，以确保其科学性、适定性和客观性。\n\n### 步骤 1：提取已知条件\n- 调度器模型：加权公平队列（WFQ），建模为通用处理器共享（GPS）的近似。\n- 请求类别数：$3$。\n- 类别权重：$w_1 = 2$, $w_2 = 1$, $w_3 = 3$。\n- 总设备容量：$C = 30000$ 个请求/秒。\n- 到达过程：每个类别 $i$ 为泊松过程，速率为 $\\lambda_i$。\n- 到达率：$\\lambda_1 = 9000$ 个请求/秒, $\\lambda_2 = 3500$ 个请求/秒, $\\lambda_3 = 12000$ 个请求/秒。\n- 服务时间分布：每个请求独立且呈指数分布。\n- 积压类别 $i$ 的有效服务率：$\\mu_i = \\phi_i C$，其中份额 $\\phi_i = \\frac{w_i}{\\sum_j w_j}$。\n- 目标：推导每个类别的稳态平均请求延迟（逗留时间）$T_i$ 的解析表达式，并计算 $T_1$, $T_2$, 和 $T_3$ 的数值（以毫秒为单位），四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了计算机系统性能分析中的一个标准场景，特别是排队论在I/O调度中的应用。该模型（WFQ近似为GPS，从而产生独立的M/M/1队列）是一个成熟且科学可靠的框架。所有必要参数（$\\lambda_i$, $w_i$, $C$）均已提供。\n\n我们必须验证系统的稳定性。总权重为 $W = w_1 + w_2 + w_3 = 2 + 1 + 3 = 6$。\n保证的服务份额为：\n- $\\phi_1 = \\frac{w_1}{W} = \\frac{2}{6} = \\frac{1}{3}$\n- $\\phi_2 = \\frac{w_2}{W} = \\frac{1}{6}$\n- $\\phi_3 = \\frac{w_3}{W} = \\frac{3}{6} = \\frac{1}{2}$\n\n每个类别的有效服务率为：\n- $\\mu_1 = \\phi_1 C = \\frac{1}{3} \\times 30000 \\text{ s}^{-1} = 10000 \\text{ s}^{-1}$\n- $\\mu_2 = \\phi_2 C = \\frac{1}{6} \\times 30000 \\text{ s}^{-1} = 5000 \\text{ s}^{-1}$\n- $\\mu_3 = \\phi_3 C = \\frac{1}{2} \\times 30000 \\text{ s}^{-1} = 15000 \\text{ s}^{-1}$\n\n为使队列稳定，其到达率必须小于其服务率。我们检查每个类别的利用率 $\\rho_i = \\lambda_i / \\mu_i$：\n- $\\rho_1 = \\frac{\\lambda_1}{\\mu_1} = \\frac{9000}{10000} = 0.9$。因为 $0.9  1$，所以类别1是稳定的。\n- $\\rho_2 = \\frac{\\lambda_2}{\\mu_2} = \\frac{3500}{5000} = 0.7$。因为 $0.7  1$，所以类别2是稳定的。\n- $\\rho_3 = \\frac{\\lambda_3}{\\mu_3} = \\frac{12000}{15000} = 0.8$。因为 $0.8  1$，所以类别3是稳定的。\n\n由于所有单个队列都是稳定的，所描述的系统是适定的，并且存在稳态解。该问题是完整的、一致的且科学可靠的。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答推导\n问题陈述指明，WFQ调度器的模型是：当类别 $i$ 有请求积压时，它会经历一个速率恒为 $\\mu_i$ 的有效专用服务器。每个类别的到达是泊松过程，服务时间呈指数分布。这使我们能够将每个类别 $i$ 建模为一个独立的M/M/1队列，其到达率为 $\\lambda_i$，服务率为 $\\mu_i$。我们将从第一性原理推导通用M/M/1队列的平均逗留时间。\n\nM/M/1队列可以用连续时间马尔可夫链来描述，具体来说是一个生灭过程，其中状态 $n$ 表示系统中的请求数量（排队中加服务中）。\n设 $p_n$ 为处于状态 $n$ 的稳态概率。状态转换由以下规则控制：\n- 出生（到达）：从状态 $n$ 转换到 $n+1$ 的速率是恒定的到达率 $\\lambda$。\n- 死亡（服务完成）：对于 $n \\ge 1$，从状态 $n$ 转换到 $n-1$ 的速率是恒定的服务率 $\\mu$。\n\n在稳态下，流出任何状态的速率必须等于流入该状态的速率。对于状态集合 $\\{0, 1, \\dots, n-1\\}$，平衡方程为 $\\lambda p_{n-1} = \\mu p_n$（对于 $n \\ge 1$）。\n这产生了一个递推关系：$p_n = (\\frac{\\lambda}{\\mu}) p_{n-1}$。令 $\\rho = \\frac{\\lambda}{\\mu}$ 为服务器的利用率。那么 $p_n = \\rho p_{n-1} = \\rho^2 p_{n-2} = \\dots = \\rho^n p_0$。\n\n为了找到 $p_0$，我们使用归一化条件，即所有概率之和必须为 $1$：\n$$ \\sum_{n=0}^{\\infty} p_n = 1 $$\n$$ p_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\n这是一个几何级数，当 $|\\rho|  1$ 时收敛，这是稳定性的条件。其和为 $\\frac{1}{1-\\rho}$。\n因此，$p_0 \\left( \\frac{1}{1-\\rho} \\right) = 1$，这给出 $p_0 = 1 - \\rho$。\n稳态概率分布为 $p_n = (1-\\rho)\\rho^n$（对于 $n \\ge 0$）。\n\n系统中的平均请求数 $L$ 是 $n$ 的期望值：\n$$ L = E[n] = \\sum_{n=0}^{\\infty} n p_n = \\sum_{n=0}^{\\infty} n (1-\\rho)\\rho^n = (1-\\rho) \\sum_{n=0}^{\\infty} n \\rho^n $$\n我们识别出这个和 $\\sum_{n=0}^{\\infty} n \\rho^n = \\rho \\frac{d}{d\\rho} \\left( \\sum_{n=0}^{\\infty} \\rho^n \\right) = \\rho \\frac{d}{d\\rho} \\left( \\frac{1}{1-\\rho} \\right) = \\rho \\frac{1}{(1-\\rho)^2}$。\n将此代回 $L$ 的表达式中：\n$$ L = (1-\\rho) \\left( \\frac{\\rho}{(1-\\rho)^2} \\right) = \\frac{\\rho}{1-\\rho} $$\n\n平均请求延迟（逗留时间）$T$ 是请求在系统中花费的平均时间。根据利特尔定律（Little's Law），稳定系统中请求的平均数量是到达率与平均在系统逗留时间的乘积：$L = \\lambda T$。\n解出 $T$，我们得到：\n$$ T = \\frac{L}{\\lambda} = \\frac{\\rho/(1-\\rho)}{\\lambda} = \\frac{(\\lambda/\\mu)/(1 - \\lambda/\\mu)}{\\lambda} = \\frac{\\lambda/\\mu}{\\lambda((\\mu-\\lambda)/\\mu)} = \\frac{1}{\\mu - \\lambda} $$\n这个表达式是M/M/1队列的平均逗留时间。\n\n现在我们将此结果应用于每个类别 $i$，代入特定的参数 $\\lambda_i$ 和 $\\mu_i$：\n$$ T_i = \\frac{1}{\\mu_i - \\lambda_i} $$\n\n### 数值计算\n首先，我们确认每个类别的 $\\lambda_i$ 和 $\\mu_i$ 的值：\n- 类别 1: $\\lambda_1 = 9000 \\text{ s}^{-1}$, $\\mu_1 = 10000 \\text{ s}^{-1}$\n- 类别 2: $\\lambda_2 = 3500 \\text{ s}^{-1}$, $\\mu_2 = 5000 \\text{ s}^{-1}$\n- 类别 3: $\\lambda_3 = 12000 \\text{ s}^{-1}$, $\\mu_3 = 15000 \\text{ s}^{-1}$\n\n现在我们计算每个类别的平均延迟 $T_i$（以秒为单位）：\n- $T_1 = \\frac{1}{\\mu_1 - \\lambda_1} = \\frac{1}{10000 - 9000} = \\frac{1}{1000} \\text{ s}$\n- $T_2 = \\frac{1}{\\mu_2 - \\lambda_2} = \\frac{1}{5000 - 3500} = \\frac{1}{1500} \\text{ s}$\n- $T_3 = \\frac{1}{\\mu_3 - \\lambda_3} = \\frac{1}{15000 - 12000} = \\frac{1}{3000} \\text{ s}$\n\n最后，我们将这些延迟转换为毫秒（$1 \\text{ s} = 1000 \\text{ ms}$），并按要求四舍五入到四位有效数字：\n- $T_1 = \\frac{1}{1000} \\text{ s} \\times 1000 \\frac{\\text{ms}}{\\text{s}} = 1 \\text{ ms}$。四舍五入到四位有效数字，即 $1.000$ 毫秒。\n- $T_2 = \\frac{1}{1500} \\text{ s} \\times 1000 \\frac{\\text{ms}}{\\text{s}} = \\frac{2}{3} \\text{ ms} \\approx 0.66666... \\text{ ms}$。四舍五入到四位有效数字，即 $0.6667$ 毫秒。\n- $T_3 = \\frac{1}{3000} \\text{ s} \\times 1000 \\frac{\\text{ms}}{\\text{s}} = \\frac{1}{3} \\text{ ms} \\approx 0.33333... \\text{ ms}$。四舍五入到四位有效数字，即 $0.3333$ 毫秒。\n\n最终的延迟为 $(T_1, T_2, T_3) = (1.000, 0.6667, 0.3333)$ 毫秒。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1.000  0.6667  0.3333 \\end{pmatrix}}$$"
        }
    ]
}