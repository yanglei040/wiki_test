{
    "hands_on_practices": [
        {
            "introduction": "在多处理器系统中，一个看似微不足道的硬件细节——缓存行伪共享（false sharing）——可能会对性能产生巨大影响。当不同核心上的任务频繁写入同一个缓存行的不同部分时，缓存一致性协议会引发大量的通信开销。本练习将引导你从第一性原理出发，量化分析一个核心调度决策的利弊：是将这些任务绑定在同一核心上以避免缓存一致性开销，还是将它们分散以减少资源竞争。",
            "id": "3653757",
            "problem": "一个操作系统调度器必须决定如何将两个计算密集型任务放置在一个对称多处理器上，该处理器拥有私有一级缓存并采用写-失效缓存一致性协议（CCP）。考虑两个任务 $T_1$ 和 $T_2$，它们都对同一个缓存行内不相交的字进行写操作，这是一种伪共享的情况。系统拥有多个相同的中央处理器（CPU）核心；调度器可以将 $T_1$ 和 $T_2$ 固定在同一个核心上（共同放置）或不同的核心上（分开放置）。\n\n假设以下基于科学依据的模型：\n- 每个任务的写操作生成为一个独立的泊松过程：$T_1$ 的速率为每秒 $\\lambda_1$ 次写操作，$T_2$ 的速率为每秒 $\\lambda_2$ 次写操作。\n- 当 $T_1$ 和 $T_2$ 分开固定在不同核心上时，缓存行所有权在核心间的变更会引起额外的一致性流量；将由此产生的平均惩罚建模为每次所有权变更导致 $m$ 次额外的缓存未命中，每次未命中因未命中延迟和相关停顿而产生平均时间成本 $M$（秒）。\n- 当 $T_1$ 和 $T_2$ 共同固定在同一个核心上时，跨核心的所有权变更被消除；然而，共同驻留会引入竞争。将其建模为由于核心资源（例如，流水线、缓存端口、调度器引起的抢占效应）的竞争加剧，每次写操作会产生平均为 $K$（秒）的额外时间成本。\n\n仅使用经过充分检验的事实和核心定义作为基本依据：写-失效协议下的缓存一致性确保了每个缓存行的单一写入者所有权；当不同任务写入同一缓存行内的不同字并在分开部署时引发所有权变更，即发生伪共享；独立泊松过程的叠加本身也是一个泊松过程，其事件源身份由各自的速率决定。\n\n从第一性原理出发，推导竞争阈值 $K^{*}$ 的一个闭式解析表达式，使得共同放置与分开放置两种策略的每单位时间期望开销相等。您的表达式必须以 $M$、$m$、$\\lambda_1$ 和 $\\lambda_2$ 表示。无需进行数值计算；将最终的 $K^{*}$ 报告为一个解析表达式。无需取整。",
            "solution": "该问题要求推导一个竞争阈值 $K^*$，在该阈值下，两种调度策略——将任务 $T_1$ 和 $T_2$ 固定在同一个核心上（“共同”放置）与将它们固定在不同核心上（“分开”放置）——的每单位时间期望时间开销相同。推导将从第一性原理出发，使用所提供的模型参数。\n\n设 $C_{together}$ 为“共同”放置配置下每单位时间的期望开销，设 $C_{apart}$ 为“分开”放置配置下每单位时间的期望开销。需要求解的条件是，当竞争成本 $K = K^*$ 时，$C_{together} = C_{apart}$。\n\n首先，我们分析“共同”放置配置。在这种情况下，任务 $T_1$ 和 $T_2$ 共同驻留在一个核心上。问题陈述指出，由于资源竞争，这会为每次写操作引入一个平均为 $K$（秒）的额外时间成本。总的写操作流是两个独立任务写操作流的叠加。任务 $T_1$ 的写操作生成为一个速率为 $\\lambda_1$ 的泊松过程，任务 $T_2$ 的写操作生成为一个速率为 $\\lambda_2$ 的泊松过程。核心上的总写操作速率是各个速率之和：$\\lambda_{total} = \\lambda_1 + \\lambda_2$。每次写操作都会产生 $K$ 的开销。因此，每单位时间的总期望开销是总写操作速率与单次写操作开销成本的乘积。\n$$C_{together} = (\\lambda_1 + \\lambda_2)K$$\n\n接下来，我们分析“分开”放置配置。在这种情况下，任务 $T_1$ 和 $T_2$ 被固定在不同的核心上。开销源于两个任务访问的单个缓存行上发生的伪共享。系统采用写-失效缓存一致性协议，这意味着在任何给定时间只有一个核心可以拥有该缓存行的写所有权。当一个核心上的任务执行写操作，而对该行的上一次写操作是由另一个核心上的任务执行时，就需要将缓存行的所有权从一个核心转移到另一个核心，从而产生开销。\n\n为了确定这些所有权变更的速率，我们考虑来自 $T_1$ 和 $T_2$ 的组合写操作流。根据独立泊松过程的叠加原理，组合流也是一个泊松过程，其总速率为 $\\lambda_{total} = \\lambda_1 + \\lambda_2$。对于这个组合流中的任何给定的写事件，它源于任务 $T_1$ 的概率是 $p_1 = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}$，源于任务 $T_2$ 的概率是 $p_2 = \\frac{\\lambda_2}{\\lambda_1 + \\lambda_2}$。关键在于，每个写事件的来源与先前事件的来源是独立的。\n\n如果一次来自 $T_1$ 的写操作之后紧跟着一次来自 $T_2$ 的写操作，或者一次来自 $T_2$ 的写操作之后紧跟着一次来自 $T_1$ 的写操作，就会发生所有权变更。在组合流中，任意两个连续写操作之间发生所有权变更的概率 $P_{change}$ 是这两种互斥序列的概率之和：\n$$P_{change} = P(\\text{from } T_1 \\text{ then from } T_2) + P(\\text{from } T_2 \\text{ then from } T_1)$$\n由于叠加泊松过程中事件来源的独立性：\n$$P_{change} = p_1 p_2 + p_2 p_1 = 2 p_1 p_2$$\n代入 $p_1$ 和 $p_2$ 的表达式：\n$$P_{change} = 2 \\left( \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2} \\right) \\left( \\frac{\\lambda_2}{\\lambda_1 + \\lambda_2} \\right) = \\frac{2 \\lambda_1 \\lambda_2}{(\\lambda_1 + \\lambda_2)^2}$$\n所有权变更的速率 $\\lambda_{change}$ 是总写操作速率乘以每次写事件发生所有权变更的概率。\n$$\\lambda_{change} = \\lambda_{total} \\times P_{change} = (\\lambda_1 + \\lambda_2) \\left( \\frac{2 \\lambda_1 \\lambda_2}{(\\lambda_1 + \\lambda_2)^2} \\right) = \\frac{2 \\lambda_1 \\lambda_2}{\\lambda_1 + \\lambda_2}$$\n问题陈述指出，每次所有权变更会导致平均 $m$ 次额外的缓存未命中，并且每次未命中会产生平均时间成本 $M$。因此，每次所有权变更的总时间成本为 $m M$。“分开”放置配置下每单位时间的期望开销是所有权变更的速率乘以每次变更的成本。\n$$C_{apart} = \\lambda_{change} \\times (m M) = \\left( \\frac{2 \\lambda_1 \\lambda_2}{\\lambda_1 + \\lambda_2} \\right) m M$$\n\n为了找到竞争阈值 $K^*$，我们令两个开销相等，并设 $K = K^*$：\n$$C_{together} = C_{apart}$$\n$$(\\lambda_1 + \\lambda_2) K^* = \\frac{2 \\lambda_1 \\lambda_2 m M}{\\lambda_1 + \\lambda_2}$$\n最后，我们求解 $K^*$：\n$$K^* = \\frac{1}{\\lambda_1 + \\lambda_2} \\left( \\frac{2 \\lambda_1 \\lambda_2 m M}{\\lambda_1 + \\lambda_2} \\right)$$\n$$K^* = \\frac{2 \\lambda_1 \\lambda_2 m M}{(\\lambda_1 + \\lambda_2)^2}$$\n这个表达式代表了每次写操作的竞争开销的临界值。如果实际的竞争成本 $K$ 大于 $K^*$，那么将任务分开固定更高效。如果 $K$ 小于 $K^*$，那么将它们共同固定更高效。",
            "answer": "$$\\boxed{\\frac{2 \\lambda_1 \\lambda_2 m M}{(\\lambda_1 + \\lambda_2)^{2}}}$$"
        },
        {
            "introduction": "一个高效的负载均衡器不仅要考虑CPU的繁忙程度，还必须与系统的其他部分（如优先级调度器）协同工作。如果一个均衡器为了均分负载而频繁迁移一个高优先级的交互式任务，可能会因破坏其缓存亲和性（cache affinity）而增加其响应时间，这实际上是一种变相的“优先级反转”。本练习将探讨如何设计一个既能保持系统“功守恒”（work-conserving）以实现高吞吐率，又能保护高优先级任务响应性的智能均衡策略。",
            "id": "3653846",
            "problem": "考虑一个具有 $2$ 个相同核心的对称多处理器系统，该系统采用抢占式固定优先级调度：每当一个高优先级任务在某个核心上变为可运行时，它会立即抢占当前在该核心上执行的任何较低优先级的任务。一个负载均衡器会尝试使用两个核心。以下经过充分检验的基本事实和定义适用：\n- 任何执行段的响应时间 $R$ 等于 $R = W + S$，其中 $W$ 是等待时间，$S$ 是服务时间。\n- 在抢占式固定优先级调度下，对于一个独立的高优先级任务，如果在段开始时有任何核心可用，其等待时间 $W$ 约等于 $0$，因为该段会立即在某个核心上被调度执行。\n- 将一个执行段迁移到与同一任务前一个段不同的核心上，会引发冷缓存惩罚，该惩罚被建模为附加到该段服务时间 $S$ 上的开销 $o$（第一个段由于冷启动也会产生 $o$ 的开销）。如果该段与前一个段在同一核心上执行，并且段之间的间隔很短，则冷缓存惩罚可以忽略不计（在本模型中假设为 $0$）。\n\n一个高优先级的交互式任务 $H$ 执行 $k$ 个短暂的中央处理器（CPU）脉冲，这些脉冲之间由I/O思考时间隔开；同时，一个低优先级的批处理任务 $L$ 是计算密集型的。具体来说：\n- 任务 $H$ 有 $k = 8$ 个CPU脉冲，每个脉冲的基础服务时间为 $b = 2$，脉冲之间由长度为 $z = 1$ 的I/O思考时间隔开。\n- 任务 $L$ 的总CPU需求为 $B_L = 40$。\n- 任务 $H$ 每次核心变更的冷缓存开销为每个脉冲 $o = 3$（包括第一个脉冲）。除非明确说明，否则假设默认策略不会迁移任务 $L$。\n\n默认的负载均衡器在每次脉冲时交替使用 $H$ 的核心，以均衡短期的核心利用率，并且由于 $L$ 是低优先级，所以不会迁移它。当 $H$ 在 $C_1$ 上运行时，它会立即抢占 $C_1$ 上的 $L$，但默认策略不会将 $L$ 迁移到 $C_2$，因此 $C_2$ 可能会空闲。当 $H$ 在 $C_2$ 上运行时，$L$ 继续在 $C_1$ 上运行。\n\n仅使用上述基本事实，从第一性原理出发回答以下问题。对于给定的参数，哪种均衡规则可以防止脉冲级别的优先级反转（此处定义为由迁移引起的冷启动导致 $H$ 的每次脉冲响应时间膨胀），同时保持系统是功守恒的（当存在可运行的工作时，从不让核心空闲），并解释原因？\n\n选择最佳备选方案：\n\nA. 保持默认策略：每次脉冲时交替在核心间运行 $H$ 以均衡负载；从不迁移 $L$，因为它是低优先级。\n\nB. 反反转规则：将 $H$ 绑定到它预热的第一个核心，如果两个核心都有可运行的工作，则将 $L$ 迁移到另一个核心以避免空闲；仅当预测的 $H$ 等待时间减少量超过 $o$ 时才迁移 $H$（对于抢占式优先级，在脉冲开始时此减少量为 $0$），因此在这种情况下，$H$ 在预热后永不迁移。\n\nC. 将 $L$ 绑定到其当前核心以保持其缓存热度，并将 $H$ 的每个新脉冲发送到负载最低的核心，即使这会迫使 $H$ 每次都迁移。\n\nD. 以相等的概率在核心间随机放置 $H$ 的每个脉冲，以避免确定性振荡；从不迁移 $L$。",
            "solution": "用户要求对问题陈述进行严格验证，然后推导解决方案并评估给定的选项。\n\n**问题验证**\n\n**步骤1：提取给定信息**\n- 系统：具有 $2$ 个相同核心的对称多处理器系统。\n- 调度：抢占式固定优先级。\n- 响应时间：$R = W + S$，其中 $W$ 是等待时间，$S$ 是服务时间。\n- 高优先级任务（$H$）的等待时间：如果有核心可用，$W \\approx 0$。\n- 迁移开销：如果一个执行段迁移到不同的核心（或在第一个段上），服务时间 $S$ 会增加一个冷缓存惩罚 $o$。如果没有发生迁移且间隔很短，惩罚为 $0$。\n- 任务 $H$（高优先级）：\n    - CPU脉冲数量：$k = 8$。\n    - 每个脉冲的基础服务时间：$b = 2$。\n    - 脉冲间的I/O思考时间：$z = 1$。\n- 任务 $L$（低优先级）：\n    - 总CPU需求：$B_L = 40$。\n- $H$ 的冷缓存开销：每个脉冲 $o = 3$。\n- 默认均衡器策略：每次脉冲时为 $H$ 交替核心；不迁移 $L$。\n- 抢占行为：当 $H$ 在一个核心上抢占 $L$ 时，$L$ 默认不被迁移，可能导致另一个核心空闲。\n- 问题：找出哪种均衡规则可以防止“优先级反转”（定义为通过迁移开销使 $H$ 的每次脉冲响应时间膨胀），同时保持“功守恒”（当存在可运行的工作时，从不让核心空闲）。\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学依据**：是的。所提出的概念——多处理器调度、抢占、缓存亲和性、负载均衡、功守恒和优先级反转——是计算机科学，特别是操作系统和计算机体系结构中的基本且公认的主题。所提供的模型虽然简化，却是分析系统性能权衡的标准有效方法。\n- **适定性**：是的。该问题提供了一个清晰、自洽的模型，包含了所有必要的数值参数（$k, b, z, B_L, o$）以及任务和调度器的行为规则。目标（防止 $H$ 的响应时间膨胀，维持一个功守恒的系统）被明确定义，从而构成了一个可解的优化问题。\n- **客观性**：是的。语言精确且技术性强。问题上下文中提供了“优先级反转”和“功守恒”的定义，消除了歧义。\n\n**缺陷清单评估：**\n1.  **科学上不健全**：无。该模型是一个有效的抽象。\n2.  **无法形式化**：无。该问题是可量化和形式化的。\n3.  **不完整/矛盾**：无。对于问题的范围而言，参数和规则是完整且一致的。\n4.  **不切实际/不可行**：无。条件 $o > b$ ($3 > 2$) 特别突出且现实，代表了短任务的迁移成本超过瞬时负载均衡好处的情况。\n5.  **不适定**：无。通过根据既定标准分析选项，可以确定一个唯一的最佳备选方案。\n\n**步骤3：结论与行动**\n问题陈述是**有效的**。可以从提供的原则和数据中推导出解决方案。\n\n**解决方案推导**\n\n目标是找到一个满足两个标准的策略：\n1.  **防止优先级反转**：这被定义为防止因迁移引起的冷启动导致任务 $H$ 的响应时间膨胀。一个 $H$ 脉冲的基础服务时间是 $b = 2$。发生迁移（冷缓存）时，服务时间变为 $S_H = b + o = 2 + 3 = 5$。由于 $H$ 是高优先级，其等待时间 $W_H$ 约等于 $0$。因此，其响应时间为 $R_H \\approx S_H$。为防止这种性能膨胀，策略应旨在通过避免对第 $2$ 到第 $k=8$ 个脉冲进行迁移，使 $R_H \\approx 2$。\n2.  **保持功守恒**：这被定义为当存在可运行的工作时，从不让核心空闲。任务 $L$ 是一个计算密集型任务，并且始终是可运行的（直到其总需求 $B_L = 40$ 被满足）。因此，只有当两个核心都已忙于更高优先级的工作时，核心才应该空闲。由于 $H$ 是单个任务，它一次只能占用一个核心。因此，一个功守恒的策略必须确保每当 $H$ 在一个核心上运行时，$L$ 就在另一个核心上运行。它还必须确保在 $H$ 的I/O思考时间内，没有核心是空闲的（即 $L$ 应该在运行）。\n\n我们现在将根据这两个标准分析每个选项。\n\n**A. 保持默认策略：每次脉冲时交替在核心间运行 $H$ 以均衡负载；从不迁移 $L$，因为它是低优先级。**\n\n- **优先级反转**：该策略明确地在每次脉冲时为 $H$ 交替核心。假设第一个脉冲在核心 $C_1$ 上，其 $S_H = b + o = 5$。第二个脉冲在核心 $C_2$ 上，这是一次迁移，所以其服务时间也是 $S_H = 5$。这种模式对所有 $k=8$ 个脉冲都持续。$H$ 的响应时间一直膨胀到 $5$，比其基础服务时间 $2$ 高出 $150\\%$。该策略*导致*了它本应防止的优先级反转。\n- **功守恒**：该策略规定“从不迁移 $L$”。假设 $L$ 在 $C_1$ 上启动。当 $H$ 的第一个脉冲被放置在 $C_1$ 上时，它抢占了 $L$。因为 $L$ 没有被迁移，核心 $C_2$ 变为空闲，尽管 $L$ 是可运行的。这违反了功守恒原则。\n- **结论**：**不正确**。该策略在两个标准上都失败了。\n\n**B. 反反转规则：将 $H$ 绑定到它预热的第一个核心，如果两个核心都有可运行的工作，则将 $L$ 迁移到另一个核心以避免空闲；仅当预测的 $H$ 等待时间减少量超过 $o$ 时才迁移 $H$（对于抢占式优先级，在脉冲开始时此减少量为 $0$），因此在这种情况下，$H$ 在预热后永不迁移。**\n\n- **优先级反转**：该策略在第一个脉冲后将 $H$ 绑定到单个核心（例如 $C_1$）。\n    - 脉冲1：$H$ 在 $C_1$ 上运行。这是一个冷启动，所以 $R_H \\approx S_H = b + o = 5$。\n    - 脉冲2-8：$H$ 再次在 $C_1$ 上运行。缓存是热的。$R_H \\approx S_H = b = 2$。\n    该策略会产生不可避免的初始冷启动惩罚，但能防止任何后续的惩罚。它成功地防止了 $H$ 响应时间的*持续*膨胀，这是可以达到的最佳结果。\n- **功守恒**：该策略明确规定“将 $L$ 迁移到另一个核心以避免空闲”。当 $H$ 在其绑定的核心 $C_1$ 上运行时，它抢占了 $L$。系统随后将 $L$ 迁移到 $C_2$，因此两个核心都保持忙碌。当 $H$ 处于其I/O思考时间时，它不是可运行的。$L$ 是可运行的，并且可以在任一或两个核心上执行，确保没有核心空闲。\n- **结论**：**正确**。该策略成功地解决了问题中定义的两个标准。\n\n**C. 将 $L$ 绑定到其当前核心以保持其缓存热度，并将 $H$ 的每个新脉冲发送到负载最低的核心，即使这会迫使 $H$ 每次都迁移。**\n\n- **优先级反转**：“即使这会迫使 $H$ 每次都迁移”这句话表明，该策略不优先考虑 $H$ 的缓存热度，从而导致 $H$ 的响应时间膨胀。虽然一种解释可能导致 $H$ 被隐式地绑定到 $L$ 不在的核心上，但该策略的描述表明愿意接受 $H$ 的迁移成本。更关键的是，该策略在第二个标准上失败了。\n- **功守恒**：该策略“将 $L$ 绑定到其当前核心”。假设 $L$ 被绑定到 $C_1$。当 $H$ 处于其I/O思考时间（$z=1$）时，$H$ 不是可运行的。$L$ 是可运行的，并在 $C_1$ 上执行。核心 $C_2$ 保持空闲，尽管存在可运行的工作（$L$）。因此，该系统不是功守恒的。\n- **结论**：**不正确**。该策略未能满足功守恒标准。\n\n**D. 以相等的概率在核心间随机放置 $H$ 的每个脉冲，以避免确定性振荡；从不迁移 $L$。**\n\n- **优先级反转**：在第一个脉冲之后，对于每个后续脉冲，有 $0.5$ 的概率落在同一个核心上（热缓存，$S_H=2$），有 $0.5$ 的概率落在另一个核心上（冷缓存，$S_H=5$）。第 $2$ 到第 $8$ 个脉冲的期望服务时间是 $E[S_H] = 0.5 \\times (b) + 0.5 \\times (b+o) = 0.5 \\times 2 + 0.5 \\times 5 = 1 + 2.5 = 3.5$。这相对于基础时间 $2$ 来说是响应时间的显著膨胀。该策略不是防止——而是概率性地导致——优先级反转。\n- **功守恒**：该策略规定“从不迁移 $L$”。与选项A一样，如果 $L$ 在 $C_1$ 上，而 $H$ 被放置在 $C_1$ 上（有 $50\\%$ 的机会），$L$ 就会被抢占，而 $C_2$ 变为空闲。这违反了功守恒原则。\n- **结论**：**不正确**。该策略在两个标准上都失败了。\n\n**总结**\n\n只有选项B成功满足了问题的所有严格要求。它通过利用缓存亲和性（绑定）来防止高优先级任务 $H$ 的响应时间持续膨胀，并通过确保在低优先级任务 $L$ 有工作可做时没有核心空闲（通过迁移实现功守恒）来维持高系统吞吐量。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "负载均衡决策的质量取决于其输入数据的准确性，但在现代处理器中，获取准确的性能数据本身就是一个挑战。硬件性能计数器（HPC）是关键的数据来源，但推测执行（speculative execution）等复杂特性可能会严重扭曲原始计数，导致对线程行为的误判。本练习要求你扮演一名系统性能分析师，通过分析一组真实的HPC数据，揭示基于发行指令数和原始缓存未命中数的朴素度量如何产生误导，并探索更可靠的、基于退休指令和停顿周期的度量方法。",
            "id": "3653865",
            "problem": "考虑一个多处理器操作系统中的负载均衡器，该系统运行在一台拥有 $2$ 个插槽（socket）的机器上，每个插槽有 $8$ 个核心和一个共享的末级缓存 (LLC)。该均衡器每 $0.1$ 秒采样一次硬件性能计数器 (HPC)，以决定是否在插槽之间迁移可运行的线程，从而缓解内存压力并提高吞吐量。当前，它为每个线程使用两个指标：一个定义为每周期发射的微操作数的“IPC$^\\ast$”，以及每周期原始 LLC 未命中数。具体来说，在一个包含 $C$ 个周期的采样窗口内，它计算 $IPC^\\ast = U_{\\text{issued}}/C$ 和 $M_{\\text{rate}} = M_{\\text{LLC}}/C$，其中 $U_{\\text{issued}}$ 是发射的微操作数，$M_{\\text{LLC}}$ 是计数器捕获的 LLC 加载未命中数，这包括了可能稍后被冲刷的推测性加载。均衡器会将具有高 $IPC^\\ast$ 和高 $M_{\\text{rate}}$ 的线程迁移到当前内存带宽利用率较低的插槽。\n\n现给定一个场景，其中有两个线程 $T_A$ 和 $T_B$，在一个插槽上于单个 $0.1$ 秒的窗口内进行测量。对于每个线程，HPC 报告如下：\n- 对于 $T_A$：$C = 1.0 \\times 10^9$ 周期，$U_{\\text{issued}} = 4.0 \\times 10^9$ 微操作，$I_{\\text{ret}} = 1.6 \\times 10^9$ 退役指令，$M_{\\text{LLC}} = 1.2 \\times 10^8$ LLC 加载未命中（事件计数包括推测性加载），$L_{\\text{ret}} = 7.0 \\times 10^8$ 退役加载指令，$B_{\\text{mispred}} = 8.0 \\times 10^7$ 分支预测错误，$S_{\\text{mem\\_stall}} = 3.5 \\times 10^8$ 后端因内存停顿的周期数。\n- 对于 $T_B$：$C = 1.0 \\times 10^9$ 周期，$U_{\\text{issued}} = 1.8 \\times 10^9$ 微操作，$I_{\\text{ret}} = 1.7 \\times 10^9$ 退役指令，$M_{\\text{LLC}} = 8.0 \\times 10^7$ LLC 加载未命中（事件计数包括推测性加载），$L_{\\text{ret}} = 6.0 \\times 10^8$ 退役加载指令，$B_{\\text{mispred}} = 1.0 \\times 10^7$ 分支预测错误，$S_{\\text{mem\\_stall}} = 3.0 \\times 10^8$ 后端因内存停顿的周期数。\n\n基本定义和事实：\n- 作为有效吞吐量度量的每周期指令数 (IPC) 是根据退役指令定义的，即 $IPC_{\\text{ret}} = I_{\\text{ret}}/C$；未退役的指令对程序的有效进展没有贡献。\n- 推测执行可能会发射微操作并执行内存访问，如果分支预测错误，这些操作稍后会被冲刷；一些 HPC 事件会统计推测性行为，而另一些只统计已退役的行为。\n- 内存受限行为反映在后端因等待内存而停顿的时间比例，以及每次退役加载的按需（非推测性）未命中次数上；推测性加载会夸大原始未命中计数，而不会增加有效工作。\n\n均衡器观察到 $T_A$ 的 $IPC^\\ast = 4.0$ 且 $M_{\\text{rate}} = 0.12$ 次未命中/周期，而 $T_B$ 的 $IPC^\\ast = 1.8$ 且 $M_{\\text{rate}} = 0.08$。基于其策略，它决定将 $T_A$ 迁移到另一个插槽，以“给它更多内存带宽”。\n\n以下关于由推测执行引起的错误解读以及提议的修正方法的陈述中，哪些是正确的？\n\nA. 当分支预测错误频繁时，使用 $U_{\\text{issued}}/C$ 作为吞吐量的代理指标可能会产生误导，因为推测性微操作会夸大 $U_{\\text{issued}}$ 而不贡献于已退役的工作；通过 $I_{\\text{ret}}/C$ 计算 $IPC$ 并通过按需（已退役）加载来归一化内存压力可以减少这种偏差。\n\nB. $T_A$ 的高 $M_{\\text{rate}}$ 明确地表明了真实的内存受限行为，因为推测性加载不影响 LLC 未命中事件；因此，每周期原始未命中数是可靠的，不受推测执行影响。\n\nC. 一个更可靠的内存压力指标是因内存而停顿的周期比例 $S_{\\text{mem\\_stall}}/C$，因为它直接测量了因内存延迟损失的时间；将此指标纳入均衡决策可以纠正错误解读。\n\nD. 为消除推测效应，均衡器应将 $U_{\\text{issued}}$ 乘以因子 $1 - B_{\\text{mispred}}/I_{\\text{ret}}$，这将产生一个与 $I_{\\text{ret}}/C$ 等效的精确 $IPC$。\n\nE. 均衡器应引入分支预测错误率 $B_{\\text{mispred}}/I_{\\text{ret}}$ 作为一个警戒指标：当该率很高时，降低 $IPC^\\ast$ 的优先级，并依赖基于退役和基于停顿的指标，以避免推测偏差。\n\nF. 仅增加采样窗口时长就能保证消除 $U_{\\text{issued}}$ 和 $M_{\\text{LLC}}$ 中由推测引起的偏差，因为更长的窗口会完全平均掉分支预测错误。\n\n选择所有适用项。",
            "solution": "该问题陈述已经过验证，被认为是具有科学依据、提法得当且内部一致的。它呈现了一个操作系统和计算机体系结构领域的真实场景，涉及在存在推测执行的情况下，如何为负载均衡解读硬件性能计数器。所有提供的数据足以进行严谨的分析。\n\n问题的核心在于负载均衡器使用了易受推测执行偏差影响的指标。均衡器使用“IPC$^\\ast$”（$IPC^\\ast = U_{\\text{issued}}/C$）和原始 LLC 未命中率（$M_{\\text{rate}} = M_{\\text{LLC}}/C$）来表征线程。问题陈述明确指出，用于发射的微操作（$U_{\\text{issued}}$）和 LLC 未命中（$M_{\\text{LLC}}$）的计数器包含了推测性事件。我们必须分析为线程 $T_A$ 和 $T_B$ 提供的数据，以确定均衡器的解读是否正确，并评估所提出的各个陈述。\n\n首先，我们分析均衡器所计算的指标。\n对于线程 $T_A$：\n$IPC^\\ast_A = U_{\\text{issued},A} / C = (4.0 \\times 10^9) / (1.0 \\times 10^9) = 4.0$\n$M_{\\text{rate},A} = M_{\\text{LLC},A} / C = (1.2 \\times 10^8) / (1.0 \\times 10^9) = 0.12$\n\n对于线程 $T_B$：\n$IPC^\\ast_B = U_{\\text{issued},B} / C = (1.8 \\times 10^9) / (1.0 \\times 10^9) = 1.8$\n$M_{\\text{rate},B} = M_{\\text{LLC},B} / C = (8.0 \\times 10^7) / (1.0 \\times 10^9) = 0.08$\n\n基于这些指标，均衡器将 $T_A$ 识别为一个具有非常高吞吐量和高内存压力的线程，从而决定迁移 $T_A$。\n\n现在，我们使用基于退役的指标进行更深入的分析，这些指标衡量的是有效工作，且不易受到推测引起的偏差影响。指令吞吐量的真实度量是基于退役指令的每周期指令数，$IPC_{\\text{ret}} = I_{\\text{ret}}/C$。\n\n对于线程 $T_A$：\n真实吞吐量：$IPC_{\\text{ret},A} = I_{\\text{ret},A} / C = (1.6 \\times 10^9) / (1.0 \\times 10^9) = 1.6$。\n$IPC^\\ast_A = 4.0$ 和 $IPC_{\\text{ret},A} = 1.6$ 之间的巨大差异表明存在大量的、被浪费的推测性工作。一个主要原因是分支预测错误。\n分支预测错误率：$B_{\\text{mispred},A} / I_{\\text{ret},A} = (8.0 \\times 10^7) / (1.6 \\times 10^9) = 0.05$ 次预测错误/退役指令。这是一个极高的比率，并证实了发生了大量的推测执行，而这些推测执行随后被冲刷。\n\n对于线程 $T_B$：\n真实吞吐量：$IPC_{\\text{ret},B} = I_{\\text{ret},B} / C = (1.7 \\times 10^9) / (1.0 \\times 10^9) = 1.7$。\n在这里，$IPC^\\ast_B = 1.8$ 非常接近 $IPC_{\\text{ret},B} = 1.7$，表明被浪费的工作极少。\n分支预测错误率：$B_{\\text{mispred},B} / I_{\\text{ret},B} = (1.0 \\times 10^7) / (1.7 \\times 10^9) \\approx 0.0059$ 次预测错误/退役指令。这是一个低的、健康的比率。\n\n此分析揭示，$T_B$ 的有效吞吐量（$1.7$）略高于 $T_A$（$1.6$）。因此，均衡器的评估是一种错误解读：它将 $T_A$ 的狂热但基本上无用的推测性活动误认为是高性能。\n\n现在我们评估每个选项：\n\n**A. 当分支预测错误频繁时，使用 $U_{\\text{issued}}/C$ 作为吞吐量的代理指标可能会产生误导，因为推测性微操作会夸大 $U_{\\text{issued}}$ 而不贡献于已退役的工作；通过 $I_{\\text{ret}}/C$ 计算 $IPC$ 并通过按需（已退役）加载来归一化内存压力可以减少这种偏差。**\n这个陈述完全准确。我们对 $T_A$ 的分析恰好显示了这个问题：其高分支预测错误率导致了被高度夸大的 $U_{\\text{issued}}$ 和一个误导性的 $IPC^\\ast$。使用 $I_{\\text{ret}}/C$ 提供了真实的、有效的吞吐量，纠正了这种错误解读。将内存指标（如未命中数）按退役指令或退役加载进行归一化，是分析与有效进展相关的内存压力的标准方法，从而过滤掉来自推测性内存访问的“噪声”。\n**结论：正确**\n\n**B. $T_A$ 的高 $M_{\\text{rate}}$ 明确地表明了真实的内存受限行为，因为推测性加载不影响 LLC 未命中事件；因此，每周期原始未命中数是可靠的，不受推测执行影响。**\n这个陈述在事实上是错误的。其核心前提“推测性加载不影响 LLC 未命中事件”是错误的。沿错误预测路径的推测执行可以发射在缓存层次结构（包括 LLC）中未命中的加载指令。这些未命中会贡献给 $M_{\\text{LLC}}$ 计数。问题陈述本身证实了这一点：“$M_{\\text{LLC}}$...包括推测性加载”。因为 $T_A$ 的分支预测错误率非常高，所以其 $1.2 \\times 10^8$ 次 LLC 未命中中有很大一部分很可能是推测性的，并且不对应于有效工作所需的内存。因此，高 $M_{\\text{rate}}$ 是模棱两可的，而不是明确的。\n**结论：不正确**\n\n**C. 一个更可靠的内存压力指标是因内存而停顿的周期比例 $S_{\\text{mem\\_stall}}/C$，因为它直接测量了因内存延迟损失的时间；将此指标纳入均衡决策可以纠正错误解读。**\n这个陈述建议使用内存停顿周期作为一个更稳健的指标。让我们为两个线程计算这个值。\n对于 $T_A$：$S_{\\text{mem\\_stall},A} / C = (3.5 \\times 10^8) / (1.0 \\times 10^9) = 0.35$。\n对于 $T_B$：$S_{\\text{mem\\_stall},B} / C = (3.0 \\times 10^8) / (1.0 \\times 10^9) = 0.30$。\n这些指标显示，两个线程都花费了相当大一部分时间（$35\\%$ 和 $30\\%$）在内存上停顿。这直接衡量了内存延迟对性能的影响。与原始未命中计数（被 $T_A$ 的无害推测性未命中夸大）不同，停顿周期计数反映了真实的性能瓶颈。尽管 $M_{\\text{rate}}$ 指标表明 $T_A$ ($0.12$) 的内存密集程度比 $T_B$ ($0.08$) 高出 $50\\%$，但停顿指标显示它们在内存性能影响方面更为接近（$0.35$ vs $0.30$）。纳入此指标将为均衡器提供一个更细致、更准确的视图，有助于纠正源于 $M_{\\text{rate}}$ 的错误解读。\n**结论：正确**\n\n**D. 为消除推测效应，均衡器应将 $U_{\\text{issued}}$ 乘以因子 $1 - B_{\\text{mispred}}/I_{\\text{ret}}$，这将产生一个与 $I_{\\text{ret}}/C$ 等效的精确 $IPC$。**\n这个陈述提出了一个特定的数学公式来“修正”$U_{\\text{issued}}$。让我们在最需要修正的 $T_A$ 上测试它。\n缩放因子是 $1 - B_{\\text{mispred},A}/I_{\\text{ret},A} = 1 - 0.05 = 0.95$。\n修正后的 $IPC^\\ast$ 将是 $(U_{\\text{issued},A}/C) \\times 0.95 = 4.0 \\times 0.95 = 3.8$。\n实际的退役 IPC 是 $IPC_{\\text{ret},A} = 1.6$。公式的计算结果 $3.8$ 与正确值 $1.6$ 相去甚远。该公式没有物理或体系结构基础；预测错误和浪费的微操作之间的关系要复杂得多，无法用这样一个简单的线性缩放因子来捕捉。该公式未能提供准确的修正。\n**结论：不正确**\n\n**E. 均衡器应引入分支预测错误率 $B_{\\text{mispred}}/I_{\\text{ret}}$ 作为一个警戒指标：当该率很高时，降低 $IPC^\\ast$ 的优先级，并依赖基于退役和基于停顿的指标，以避免推测偏差。**\n这个陈述为负载均衡器提出了一个实用的启发式方法。分支预测错误率是其他指标中“推测性噪声”水平的一个绝佳代理指标。对于 $T_A$，该率很高（$0.05$），因此启发式方法会被触发。均衡器随后会不信任 $IPC^\\ast_A=4.0$，而是依赖像 $IPC_{\\text{ret},A}=1.6$ 和内存停顿比例 $0.35$ 这样的指标。对于 $T_B$，该率很低（$\\approx 0.0059$），因此其基于发射的指标可以被信任（而且实际上 $IPC^\\ast_B=1.8$ 与 $IPC_{\\text{ret},B}=1.7$ 很接近）。这种策略直接解决了错误解读的根本原因，并引导均衡器使用更可靠的数据，从而做出更好的决策。这代表了一种解决该问题的合理工程方法。\n**结论：正确**\n\n**F. 仅增加采样窗口时长就能保证消除 $U_{\\text{issued}}$ 和 $M_{\\text{LLC}}$ 中由推测引起的偏差，因为更长的窗口会完全平均掉分支预测错误。**\n这个陈述是不正确的。来自推测的偏差是系统性误差，而非随机误差。如果一个程序的代码包含 CPU 预测器本身就难以处理的分支，它将持续表现出高的预测错误率。一个更长的采样窗口将产生一个更稳定的*有偏差*指标的平均值，但它不会消除偏差本身。$U_{\\text{issued}}$ 与 $I_{\\text{ret}}$ 的比率将保持很高。平均法对随机噪声有效，但对源于程序行为的系统性测量伪影无效。声称这能*保证消除*偏差是错误的。\n**结论：不正确**\n\n总而言之，正确的陈述是 A、C 和 E，因为它们正确地诊断了推测偏差的问题，并为其缓解提出了有效的方法。",
            "answer": "$$\\boxed{ACE}$$"
        }
    ]
}