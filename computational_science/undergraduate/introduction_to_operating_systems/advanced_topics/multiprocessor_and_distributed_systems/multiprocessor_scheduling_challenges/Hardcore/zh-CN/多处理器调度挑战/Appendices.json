{
    "hands_on_practices": [
        {
            "introduction": "在现代多处理器系统中，并非所有的内存访问都生而平等。本练习  挑战你像操作系统设计者一样，为非统一内存访问（NUMA）架构的机器进行思考，在这种架构中，线程在何处运行的决策会对性能产生深远影响。你将分析不同的负载均衡策略，以驾驭在最大化数据局部性与确保高 CPU 利用率之间的经典权衡。",
            "id": "3661196",
            "problem": "一个双插槽多处理器系统，每个插槽有 $N=8$ 个核心。每个插槽拥有一个容量为 $C=16$ MiB 的共享末级缓存 (LLC) 和本地动态随机存取存储器 (DRAM)。该机器实现了非统一内存访问 (NUMA) 架构，并采用首次接触 (first-touch) 分配策略：页面被放置在首次访问它的插槽的本地 DRAM 中。一组 $T=16$ 个相同的用户线程执行一个通过屏障同步的循环。在每次迭代中，一个线程会重复遍历大小为 $w=1$ MiB 的私有工作集，然后参与一个屏障同步，之后它会扫描一个大小为 $D=4$ MiB、由同一进程中所有线程使用的以读为主的共享数据集。由于输入/输出导致的短暂阻塞事件会使一个随机的线程子集（平均占 $25\\%$）阻塞约 $5$ ms；为了在这些事件中保持接近完全的利用率，操作系统 (OS) 必须在大约 $1$ ms 的时间间隔内，在所选择的任何平衡域内执行负载均衡。\n\n假设以下基本事实和定义：\n- 当引用的数据自上次访问以来仍保留在缓存中时，发生缓存命中；当聚合的活跃使用数据超过缓存容量时，发生容量引发的未命中。\n- 如果在相关的重用窗口期间，竞争给定 LLC 的聚合工作集小于 LLC 容量，则命中率很高；如果超过容量，命中率会因驱逐而降低。\n- 在首次接触放置策略下，将线程迁移到不同的插槽会使其后续的页面访问变为远程访问，直到页面被迁移为止；远程 DRAM 访问比本地 DRAM 访问慢。\n- 此处“最大化局部性”的目标是指最大化内存引用中属于 LLC 命中或在 LLC 未命中时由本地 DRAM 而非远程 DRAM 服务的预期比例。\n\n您正在评估调度器平衡范围选项 $S$，以在所述的利用率要求下最大化局部性。请考虑以下候选策略：\n\nA. 系统范围的每核心均衡：一个跨越两个插槽的单一全局域，每 $1$ ms 重新平衡运行队列，不优先考虑插槽局部性。\n\nB. 每插槽均衡：每个插槽有独立的平衡域，每 $1$ ms 在各自插槽内重新平衡；仅在每 $100$ ms 发生罕见的跨插槽重新平衡，以纠正长期存在的不平衡。\n\nC. 初始随机放置后不重新平衡：每个线程永久固定在其最初选择的核心上。\n\nD. 跨插槽配对核心均衡：每 $1$ ms 在跨越插槽的固定核心对（对于每个索引 $i$，插槽 $0$ 的核心 $i$ 与插槽 $1$ 的核心 $i$ 配对）内执行均衡，允许在每对核心内进行频繁的跨插槽迁移。\n\n哪种 $S$ 的选择在满足利用率要求的同时，最好地最大化了如上定义的局部性？\n\n选择一项：\n\nA. 系统范围的每核心均衡\n\nB. 每插槽均衡\n\nC. 初始随机放置后不重新平衡\n\nD. 跨插槽配对核心均衡",
            "solution": "问题陈述在科学上是健全的、定义良好的、客观的。它描述了在非统一内存访问 (NUMA) 架构上的操作系统调度中的一个现实场景。所给参数是一致的，并且足以对所提出的调度策略进行比较分析。该问题是有效的。\n\n核心挑战是在两个相互竞争的目标之间取得平衡：最大化内存局部性和维持高 CPU 利用率。局部性，如定义所述，包括缓存命中（最快）和本地 DRAM 访问（较慢，但远快于远程 DRAM 访问）。必须通过负载均衡来应对阻塞线程，以维持利用率。\n\n让我们分析系统参数。有 $2$ 个插槽，每个插槽有 $N=8$ 个核心，总共有 $16$ 个核心。有 $T=16$ 个线程，这在初始时允许线程与核心之间的一一映射。我们假设初始的平衡布局为每个插槽上各有 $8$ 个线程。\n\n在这种布局下，我们分析每个插槽的内存占用。每个插槽承载 $8$ 个线程。一个插槽上的总私有数据大小为 $8 \\times w = 8 \\times 1 \\text{ MiB} = 8 \\text{ MiB}$。所有线程还访问一个大小为 $D=4 \\text{ MiB}$ 的共享数据集。因此，竞争一个插槽 LLC 的总活动工作集为 $8 \\text{ MiB} + 4 \\text{ MiB} = 12 \\text{ MiB}$。\n每个插槽的 LLC 容量为 $C=16 \\text{ MiB}$。由于活动工作集（$12 \\text{ MiB}$）小于 LLC 容量（$16 \\text{ MiB}$），如果线程保持在其初始插槽上，它们在初始预热阶段之后将体验到很高的 LLC 命中率。此外，由于首次接触策略，每个线程的私有数据将被分配在其插槽的本地 DRAM 中。这种配置代表了局部性的理想状态。\n\n复杂性来自于负载均衡。平均有 $25\\%$ 的 $16$ 个线程，即 $4$ 个线程，在任何时候都处于阻塞状态。这会产生空闲核心，操作系统必须以 $1 \\text{ ms}$ 的间隔将运行中的线程迁移到这些核心上以维持利用率。平衡范围 $S$ 的选择决定了这种迁移如何影响局部性。\n\n现在，我们评估每个候选策略。\n\nA. 系统范围的每核心均衡\n该策略在所有 $16$ 个核心上创建一个单一的平衡域。为了利用一个空闲核心，调度器可以将任何运行中的线程从任何核心迁移到任何其他核心。一个最初在插槽 $0$ 上的线程可能会被迁移到插槽 $1$ 上的一个空闲核心。这对局部性有严重的负面影响：\n1.  **NUMA 局部性**：线程的私有数据（$w=1 \\text{ MiB}$）被分配在插槽 $0$ 的 DRAM 中，现在必须从插槽 $1$ 进行远程访问。这明显更慢。\n2.  **缓存局部性**：线程失去了它在插槽 $0$ 的 LLC 中的所有数据的好处。它现在必须开始填充插槽 $1$ 的 LLC，导致缓存未命中并可能驱逐对插槽 $1$ 上其他线程有用的数据。\n考虑到 $1 \\text{ ms}$ 的频繁重新平衡间隔，线程会不断地在插槽之间迁移，这种情况被称为“缓存和 NUMA 颠簸”，它通过最小化 LLC 命中和本地 DRAM 访问来严重破坏性能。该策略为了利用率而完全牺牲了局部性。\n结论：**不正确**。\n\nB. 每插槽均衡\n该策略为每个含 $8$ 个核心的插槽建立两个独立的平衡域。$1 \\text{ ms}$ 间隔的负载均衡只在*插槽内*发生。插槽 $0$ 上的线程只能被迁移到插槽 $0$ 上的其他核心。\n1.  **NUMA 局部性**：因为线程从不离开其插槽，其私有数据始终保留在本地 DRAM 中。NUMA 局部性被完美保留。\n2.  **缓存局部性**：一个插槽上的所有 $8$ 个核心共享同一个 $16 \\text{ MiB}$ 的 LLC。当一个线程在同一插槽的核心之间迁移时，它继续访问同一个 LLC。该插槽上 $8$ 个线程的聚合工作集保持在 $12 \\text{ MiB}$，这在 LLC 容量之内。因此，高缓存命中率得以维持。\n该策略智能地解决了负载不平衡问题。平均而言，每个插槽上将有 $2$ 个线程阻塞，剩下 $6$ 个运行线程和 $2$ 个空闲核心。插槽内均衡器可以在这 $8$ 个核心中分配这 $6$ 个线程以维持利用率，而不会产生任何跨插槽迁移的惩罚。罕见的在 $100 \\text{ ms}$ 间隔的跨插槽重新均衡作为对长期统计不平衡的纠正措施，但其频率足够低以避免颠簸。这种方法正确地将插槽识别为自然的局部性域，并尊重它。\n结论：**正确**。\n\nC. 初始随机放置后不重新平衡\n该策略将每个线程永久固定到一个核心。这提供了可能的最大局部性，因为线程的执行上下文永远不会被移动。然而，它完全无法满足问题明确提出的利用率要求。当一个核心上的线程阻塞时，该核心在阻塞期间（约 $5 \\text{ ms}$）保持空闲。平均有 $4$ 个线程阻塞，意味着 $16$ 个核心中的 $4$ 个（$25\\%$）将处于空闲状态，导致利用率低下。问题要求操作系统*必须*执行负载均衡以维持利用率。\n结论：**不正确**。\n\nD. 跨插槽配对核心均衡\n该策略创建了 $8$ 个小而刚性的平衡域，每个域由一对核心组成，一个来自每个插槽（例如，插槽 $0$ 的核心 $i$ 和插槽 $1$ 的核心 $i$）。$1 \\text{ ms}$ 间隔的均衡仅在这些核心对内发生。这实际上是一种受限形式的系统范围均衡，并存在同样根本性的缺陷。如果插槽 $0$ 核心 $i$ 上的一个线程阻塞，来自插槽 $1$ 核心 $i$ 的一个运行中线程可能会被迁移过去。这是一次跨插槽迁移，它破坏了 NUMA 和缓存局部性，就像选项 A 一样。此外，该策略在系统范围的负载均衡方面表现不佳。如果分配给一个核心对的两个线程都阻塞了，那么该域中的两个核心都将变为空闲，而该策略没有机制从其他更繁忙的核心对中拉取工作。\n结论：**不正确**。\n\n总之，每插槽均衡是唯一一种通过频繁的负载均衡满足利用率要求，同时又能保留系统架构所提供的关键 NUMA 和缓存局部性的策略。它通过将频繁的迁移限制在局部性域（即插槽）内，正确地平衡了这种权衡。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "操作系统对公平性的承诺可能会因其运行的硬件而变得复杂。本问题  深入探讨了同步多线程（SMT）技术的微妙之处，其中单个核心上的多个硬件线程会共享资源，从而导致性能干扰。通过计算与理想资源分配的偏差，你将对调度策略如何与复杂的微架构现实相互作用有一个具体的理解。",
            "id": "3661255",
            "problem": "一个系统拥有 $N=3$ 个相同的处理器核心，每个核心支持两个同时多线程（SMT）硬件线程。操作系统采用加权公平性：在没有干扰的情况下，一个权重为 $w_i$ 的可运行软件线程 $i$ 应获得总处理器容量的一部分，该部分等于 $w_i$ 除以所有可运行线程的权重之和。然而，在SMT资源共享下，每个硬件线程 $k$ 会表现出一个测得的共享标量 $s_k \\in (0,1]$，该标量会乘以绑定到其上的任何软件线程的实际服务速率，这反映了对共享流水线和缓存资源的争用。假设调度器继续按与 $w_i$ 成比例的方式分配时间片，但实际服务速率变为与 $w_i s_{k(i)}$ 成正比，其中 $k(i)$ 表示托管软件线程 $i$ 的硬件线程。那么，实际容量分数就是将 $w_i s_{k(i)}$ 的值通过所有可运行线程的总和进行归一化得到的结果。\n\n考虑五个可运行的软件线程 $i \\in \\{1,2,3,4,5\\}$，其权重分别为 $w_1=1.0$，$w_2=2.0$，$w_3=1.5$，$w_4=1.0$ 和 $w_5=3.0$。它们被固定到三个核心上的硬件线程，具体如下：线程 $1$ 固定到硬件线程 $k=1$，线程 $2$ 固定到 $k=2$，线程 $3$ 固定到 $k=3$，线程 $4$ 固定到 $k=4$，线程 $5$ 固定到 $k=5$；同级的 $k=6$ 处于空闲状态。活动硬件线程的测量共享标量为 $s_1=0.58$，$s_2=0.62$，$s_3=0.55$，$s_4=0.60$ 和 $s_5=0.98$。\n\n将线程 $i$ 的理想加权份额定义为 $p_i = \\frac{w_i}{\\sum_{j=1}^{5} w_j}$，将在SMT争用下的实际份额定义为 $f_i = \\frac{w_i s_{k(i)}}{\\sum_{j=1}^{5} w_j s_{k(j)}}$。使用与理想值的平方偏差之和，\n$$L \\;=\\; \\sum_{i=1}^{5} \\left(f_i - p_i\\right)^{2},$$\n计算该系统的 $L$。将 $L$ 的最终值表示为一个无单位的纯数，并将您的答案四舍五入到四位有效数字。",
            "solution": "其基本原理是处理器容量的加权公平性定义，以及同时多线程（SMT）资源共享会缩放每个线程的实际服务速率这一观察结果。在理想的加权公平分配中，对于总可运行权重 $\\sum_{j=1}^{5} w_j$，每个线程 $i$ 应获得的分数为\n$$p_i \\;=\\; \\frac{w_i}{\\sum_{j=1}^{5} w_j}.$$\n在SMT干扰下，实际服务速率与 $w_i s_{k(i)}$ 成正比，因此实际分数为归一化后的量\n$$f_i \\;=\\; \\frac{w_i s_{k(i)}}{\\sum_{j=1}^{5} w_j s_{k(j)}}.$$\n所要求的公平性损失度量是平方偏差之和\n$$L \\;=\\; \\sum_{i=1}^{5} \\left(f_i - p_i\\right)^{2}.$$\n\n步骤1：通过对权重求和来计算理想份额 $p_i$。总权重为\n$$\\sum_{j=1}^{5} w_j \\;=\\; 1.0 + 2.0 + 1.5 + 1.0 + 3.0 \\;=\\; 8.5.$$\n因此，\n$$p_1 \\;=\\; \\frac{1.0}{8.5} \\;=\\; \\frac{2}{17}, \\quad p_2 \\;=\\; \\frac{2.0}{8.5} \\;=\\; \\frac{4}{17}, \\quad p_3 \\;=\\; \\frac{1.5}{8.5} \\;=\\; \\frac{3}{17}, \\quad p_4 \\;=\\; \\frac{1.0}{8.5} \\;=\\; \\frac{2}{17}, \\quad p_5 \\;=\\; \\frac{3.0}{8.5} \\;=\\; \\frac{6}{17}.$$\n\n步骤2：计算实际分配的分子 $w_i s_{k(i)}$ 及其总和。使用给定的 $s_k$ 值和映射关系，\n$$w_1 s_{k(1)} \\;=\\; 1.0 \\cdot 0.58 \\;=\\; 0.58,$$\n$$w_2 s_{k(2)} \\;=\\; 2.0 \\cdot 0.62 \\;=\\; 1.24,$$\n$$w_3 s_{k(3)} \\;=\\; 1.5 \\cdot 0.55 \\;=\\; 0.825,$$\n$$w_4 s_{k(4)} \\;=\\; 1.0 \\cdot 0.60 \\;=\\; 0.60,$$\n$$w_5 s_{k(5)} \\;=\\; 3.0 \\cdot 0.98 \\;=\\; 2.94.$$\n这五项的总和是\n$$\\sum_{j=1}^{5} w_j s_{k(j)} \\;=\\; 0.58 + 1.24 + 0.825 + 0.60 + 2.94 \\;=\\; 6.185.$$\n\n步骤3：将实际份额 $f_i$ 计算为归一化分数：\n$$f_1 \\;=\\; \\frac{0.58}{6.185}, \\quad\nf_2 \\;=\\; \\frac{1.24}{6.185}, \\quad\nf_3 \\;=\\; \\frac{0.825}{6.185}, \\quad\nf_4 \\;=\\; \\frac{0.60}{6.185}, \\quad\nf_5 \\;=\\; \\frac{2.94}{6.185}.$$\n\n步骤4：使用小数近似值计算偏差 $d_i = f_i - p_i$ 和损失 $L$。\n$$p \\approx [0.117647, 0.235294, 0.176471, 0.117647, 0.352941]$$\n$$f \\approx [0.093775, 0.200485, 0.133387, 0.097009, 0.475344]$$\n$$d_1 \\approx 0.093775 - 0.117647 = -0.023872$$\n$$d_2 \\approx 0.200485 - 0.235294 = -0.034809$$\n$$d_3 \\approx 0.133387 - 0.176471 = -0.043084$$\n$$d_4 \\approx 0.097009 - 0.117647 = -0.020638$$\n$$d_5 \\approx 0.475344 - 0.352941 = 0.122403$$\n（注：为避免舍入误差，精确计算使用了分数。）\n$$L \\;=\\; (-0.023872)^2 + (-0.034809)^2 + (-0.043084)^2 + (-0.020638)^2 + (0.122403)^2$$\n$$L \\approx 0.000570 + 0.001212 + 0.001856 + 0.000426 + 0.014982 \\approx 0.019046$$\n\n使用分数进行更精确的计算：\n总权重和: $8.5 = \\frac{17}{2}$\n加权服务率和: $6.185 = \\frac{1237}{200}$\n$d_1 = \\frac{0.58}{6.185} - \\frac{1.0}{8.5} = \\frac{116}{1237} - \\frac{2}{17} = \\frac{1972 - 2474}{21029} = -\\frac{502}{21029}$\n$d_2 = \\frac{1.24}{6.185} - \\frac{2.0}{8.5} = \\frac{248}{1237} - \\frac{4}{17} = \\frac{4216 - 4948}{21029} = -\\frac{732}{21029}$\n$d_3 = \\frac{0.825}{6.185} - \\frac{1.5}{8.5} = \\frac{165}{1237} - \\frac{3}{17} = \\frac{2805 - 3711}{21029} = -\\frac{906}{21029}$\n$d_4 = \\frac{0.60}{6.185} - \\frac{1.0}{8.5} = \\frac{120}{1237} - \\frac{2}{17} = \\frac{2040 - 2474}{21029} = -\\frac{434}{21029}$\n$d_5 = \\frac{2.94}{6.185} - \\frac{3.0}{8.5} = \\frac{588}{1237} - \\frac{6}{17} = \\frac{9996 - 7422}{21029} = \\frac{2574}{21029}$\n\n$$L \\;=\\; \\sum_{i=1}^{5} d_i^{2} \\;=\\; \\frac{502^{2} + 732^{2} + 906^{2} + 434^{2} + 2574^{2}}{21029^{2}}.$$\n$$L \\;=\\; \\frac{252004 + 535824 + 820836 + 188356 + 6625476}{442218841} \\;=\\; \\frac{8422496}{442218841} \\;\\approx\\; 0.019045991\\ldots.$$\n\n根据要求四舍五入到四位有效数字，\n$$L \\;\\approx\\; 0.01905.$$",
            "answer": "$$\\boxed{0.01905}$$"
        },
        {
            "introduction": "有效的调度不仅与硬件有关，还与理解应用程序的结构息息相关。这个动手编程练习  聚焦于并行编程中的一个基本模型——“分叉-连接”（fork-join）模式。你的任务是实现一个策略，通过智能地平衡并行任务的负载来最小化总作业完成时间，从而展示应用感知调度的一个关键原则。",
            "id": "3661208",
            "problem": "给定一个在具有 $N$ 个相同核心的对称多处理器系统上运行的单一分叉-连接作业。该作业的结构如下：一个持续时间为 $a$ 个时间单位的严格串行前缀，随后分叉为 $J$ 个独立任务，最后是一个产生 $s$ 个时间单位同步开销的连接操作。$J$ 个并行任务中的每一个都有一个整数处理时间，且任务是不可抢占的。串行前缀必须在任何并行任务开始之前完成。连接开销 $s$ 是一个纯粹的等待延迟，不占用核心，但在所有并行任务完成后会增加到作业的完工时间中。所有核心速度相同，在任何时刻，一个核心最多只能处理一个任务。放置决策将每个并行任务分配给一个核心，而协同调度决策确定一个核心按顺序执行的任务集。所有任务在串行前缀完成后立即变为可执行状态。\n\n您的目标是确定一种放置和协同调度策略，以最小化总完工时间（作业完成的时间）。该策略必须遵循以下原则：核心是相同的，一旦分叉发生任务就是独立的，并且连接操作会等待所有并行任务完成。假设在同一核心上切换任务的开销为零，并且除了任务处理之外，唯一的额外开销是连接同步开销 $s$。\n\n仅使用基本的操作系统定义和调度原则。特别地，不要假设任何专门的调度公式。从完工时间的定义和分叉-连接执行的结构出发进行推理。\n\n编写一个完整的程序，针对下面的每个测试用例，计算上述模型下可能的最小完工时间。您的程序不能读取输入。它必须对测试套件进行编码，并以确切要求的格式打印结果。\n\n测试套件（每个用例由 $(N, a, s, J, \\text{tasks})$ 指定，任务时间以时间单位计）：\n- 用例 1：$(N, a, s, J, \\text{tasks}) = (\\,4,\\,3,\\,2,\\,6,\\,[\\,4,\\,4,\\,2,\\,2,\\,1,\\,1\\,]\\,)$。\n- 用例 2：$(\\,2,\\,0,\\,1,\\,3,\\,[\\,5,\\,3,\\,3\\,]\\,)$。\n- 用例 3：$(\\,1,\\,2,\\,0,\\,4,\\,[\\,3,\\,2,\\,2,\\,2\\,]\\,)$。\n- 用例 4：$(\\,10,\\,1,\\,5,\\,3,\\,[\\,7,\\,1,\\,1\\,]\\,)$。\n- 用例 5：$(\\,3,\\,0,\\,0,\\,6,\\,[\\,2,\\,2,\\,2,\\,2,\\,2,\\,2\\,]\\,)$。\n- 用例 6：$(\\,2,\\,5,\\,3,\\,5,\\,[\\,4,\\,4,\\,4,\\,4,\\,4\\,]\\,)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序与上述用例相同。每个结果必须是整数。例如，一个包含三个结果的输出行应如下所示：$[r_1,r_2,r_3]$（不含空格）。\n\n约束和澄清：\n- 将所有时间量视为无单位整数。\n- 持续时间为 $a$ 的串行前缀在一个核心上精确占用 $a$ 个时间单位，并且必须在任何并行任务开始之前完成。\n- 连接同步开销 $s$ 是在所有并行任务完成后发生的纯粹延迟，不使用核心。\n- 每个任务必须在单个核心上完整运行，不可抢占；一个核心可以按顺序执行多个任务。\n- 核心是相同的；核心上任务的执行顺序不改变该核心执行时间的总和。\n\n您的任务是为每个用例计算在上述模型下任何放置和协同调度策略可实现的最小完工时间，并以指定的确切输出格式打印这些最小完工时间的列表。",
            "solution": "用户提供的问题陈述已经过分析，并被确定为**有效**。这是一个在多处理器调度领域内提法得当、有科学依据的问题，没有矛盾或含糊不清之处。因此，我们可以进行形式化的求解。\n\n目标是找到最小可能的完工时间 $T_{makespan}$，对于一个分叉-连接作业。该作业的执行包括三个不同的顺序阶段：串行前缀、并行执行阶段和连接同步。总完工时间是这些阶段持续时间的总和：\n$$T_{makespan} = T_{serial} + T_{parallel} + T_{join}$$\n根据问题描述，我们已知 $T_{serial} = a$ 和 $T_{join} = s$。因此，问题简化为最小化并行阶段的持续时间 $T_{parallel}$。\n\n并行阶段涉及在 $N$ 个相同的核心上调度 $J$ 个独立的、不可抢占的任务。所有任务在串行前缀完成后同时可用。一个核心在同一时间最多只能执行一个任务。在单个核心上执行多个任务的时间是它们各自处理时间的总和。只有当最后一个任务在它被分配的任何核心上执行完毕时，并行阶段才算完成。\n\n设 $J$ 个任务的处理时间集合为 $\\mathcal{P} = \\{p_1, p_2, \\ldots, p_J\\}$。我们必须找到这个集合的一个划分为 $N$ 个不相交的子集，$\\mathcal{S}_1, \\mathcal{S}_2, \\ldots, \\mathcal{S}_N$，其中每个子集 $\\mathcal{S}_i$ 代表分配给核心 $i$ 的任务。核心 $i$ 上的总处理时间或负载为 $L_i = \\sum_{p \\in \\mathcal{S}_i} p$。\n\n由于所有并行任务在时间 $a$ 之后开始，并且核心并行工作，因此并行阶段在最繁忙的核心完成其工作时结束。所以，并行阶段的持续时间由所有核心中的最大负载决定：\n$$T_{parallel} = \\max_{i=1, \\ldots, N} \\{L_i\\}$$\n最小化 $T_{makespan}$ 等价于找到一个能最小化此最大负载的任务划分。这是计算机科学中的一个经典优化问题，称为多处理器调度问题，它是NP难的。然而，对于小规模的问题实例，可以找到最优调度。解决此问题的一个高效且广泛使用的启发式算法是最长处理时间优先（LPT）算法。该算法首先按处理时间的降序对任务进行排序，然后逐个将每个任务分配给当前累积负载最低的核心。在许多情况下，包括所提供的这些用例，这种贪心方法都能产生最优解。\n\nLPT算法如下：\n1.  按处理时间的降序对任务 $\\mathcal{P}$ 进行排序。\n2.  将 $N$ 个核心的负载初始化为零：$L_i = 0$ for $i=1, \\ldots, N$。\n3.  对于排序列表中的每个任务 $p_j$，找到当前负载最小的核心 $k$，即 $L_k = \\min_{i=1, \\ldots, N} \\{L_i\\}$。\n4.  通过更新其负载，将任务 $p_j$ 分配给核心 $k$：$L_k \\leftarrow L_k + p_j$。\n5.  在所有任务都分配完毕后，最小并行完工时间为 $T_{parallel} = \\max_{i=1, \\ldots, N} \\{L_i\\}$。\n\n我们现在将此方法应用于每个测试用例。\n\n**用例 1:** $(N, a, s, J, \\text{tasks}) = (4, 3, 2, 6, [4, 4, 2, 2, 1, 1])$\n任务降序排序：$[4, 4, 2, 2, 1, 1]$。核心负载 $L = \\{0, 0, 0, 0\\}$。\n- 分配任务 $4$：$L = \\{4, 0, 0, 0\\}$\n- 分配任务 $4$：$L = \\{4, 4, 0, 0\\}$\n- 分配任务 $2$：$L = \\{4, 4, 2, 0\\}$\n- 分配任务 $2$：$L = \\{4, 4, 2, 2\\}$\n- 分配任务 $1$：$L = \\{4, 4, 3, 2\\}$\n- 分配任务 $1$：$L = \\{4, 4, 3, 3\\}$\n最终负载为 $\\{4, 4, 3, 3\\}$。最大负载为 $T_{parallel} = \\max(4, 4, 3, 3) = 4$。\n$T_{makespan} = a + T_{parallel} + s = 3 + 4 + 2 = 9$。\n\n**用例 2:** $(N, a, s, J, \\text{tasks}) = (2, 0, 1, 3, [5, 3, 3])$\n任务降序排序：$[5, 3, 3]$。核心负载 $L = \\{0, 0\\}$。\n- 分配任务 $5$：$L = \\{5, 0\\}$\n- 分配任务 $3$：$L = \\{5, 3\\}$\n- 分配任务 $3$：$L = \\{5, 6\\}$\n最终负载为 $\\{5, 6\\}$。最大负载为 $T_{parallel} = \\max(5, 6) = 6$。\n$T_{makespan} = a + T_{parallel} + s = 0 + 6 + 1 = 7$。\n\n**用例 3:** $(N, a, s, J, \\text{tasks}) = (1, 2, 0, 4, [3, 2, 2, 2])$\n由于只有 $N=1$ 个核心，所有并行任务必须在该核心上顺序执行。\n单个核心上的总负载是所有任务时间的总和：$3 + 2 + 2 + 2 = 9$。\n所以，$T_{parallel} = 9$。\n$T_{makespan} = a + T_{parallel} + s = 2 + 9 + 0 = 11$。\n\n**用例 4:** $(N, a, s, J, \\text{tasks}) = (10, 1, 5, 3, [7, 1, 1])$\n有 $J=3$ 个任务和 $N=10$ 个核心。由于核心数量多于任务数量，每个任务都可以分配到其专用的核心上。任务完全并行运行。\n并行阶段的持续时间由最长的任务决定。\n$T_{parallel} = \\max(7, 1, 1) = 7$。\n$T_{makespan} = a + T_{parallel} + s = 1 + 7 + 5 = 13$。\n\n**用例 5:** $(N, a, s, J, \\text{tasks}) = (3, 0, 0, 6, [2, 2, 2, 2, 2, 2])$\n有 $J=6$ 个持续时间为 $2$ 的相同任务和 $N=3$ 个核心。\n总工作量为 $6 \\times 2 = 12$。每个核心的理想平均负载是 $12 / 3 = 4$。\n通过为每个核心分配两个任务可以完美实现这一点。\n$L_1 = 2+2=4$, $L_2 = 2+2=4$, $L_3 = 2+2=4$。\n最大负载为 $T_{parallel} = 4$。\n$T_{makespan} = a + T_{parallel} + s = 0 + 4 + 0 = 4$。\n\n**用例 6:** $(N, a, s, J, \\text{tasks}) = (2, 5, 3, 5, [4, 4, 4, 4, 4])$\n任务降序排序：$[4, 4, 4, 4, 4]$。核心负载 $L = \\{0, 0\\}$。\n- 分配任务 $4$：$L = \\{4, 0\\}$\n- 分配任务 $4$：$L = \\{4, 4\\}$\n- 分配任务 $4$：$L = \\{8, 4\\}$\n- 分配任务 $4$：$L = \\{8, 8\\}$\n- 分配任务 $4$：$L = \\{12, 8\\}$\n最终负载为 $\\{12, 8\\}$。最大负载为 $T_{parallel} = \\max(12, 8) = 12$。\n总工作量为 $5 \\times 4 = 20$。对于 $N=2$ 个核心，最优划分应为 $\\{10, 10\\}$，但这是不可能的，因为所有任务时间都是 $4$ 的倍数。可以实现的最接近的划分总和是 $\\{12, 8\\}$。\n$T_{makespan} = a + T_{parallel} + s = 5 + 12 + 3 = 20$。\n\n计算得出的测试用例最小完工时间为 $[9, 7, 11, 13, 4, 20]$。",
            "answer": "[9,7,11,13,4,20]"
        }
    ]
}