{
    "hands_on_practices": [
        {
            "introduction": "除了系统级策略，我们还需要工具来分析单个组件的可靠性。本实践介绍了如何使用连续时间马尔可夫链 (Continuous-Time Markov Chains, CTMC) 来为单个副本的生命周期建模 。通过计算稳态可用性，你将掌握一个强大的量化工具，用于评估系统从故障中恢复的速度（这取决于故障率 $\\lambda$ 和修复率 $\\mu$），这是容错设计的关键考量。",
            "id": "3641355",
            "problem": "一个操作系统服务采用复制技术以实现容错。考虑单个副本，其运行状态随时间根据一个连续时间马尔可夫链 (CTMC) 演变。该副本恰好可以处于 $3$ 种状态：健康 ($H$)、恢复中 ($R$) 或故障 ($F$)。系统仅在副本处于健康状态 $H$ 时提供服务；恢复中状态 $R$ 和故障状态 $F$ 均不可用。\n\n假设如下，这些假设基于指数分布停留时间的无记忆性以及 CTMC 的定义：\n- 在健康状态下，副本的故障时间服从速率为 $\\lambda \\gt 0$ 的指数分布，状态从 $H$ 转换到 $F$。\n- 修复过程分两个指数阶段，每个阶段的速率均为 $\\mu \\gt 0$，分别对应诊断/启动和状态重建。具体来说，该链以速率 $\\mu$ 从 $F$ 转换到 $R$，并以速率 $\\mu$ 从 $R$ 转换回 $H$。\n\n仅使用 CTMC 的基本定义和稳态（长时）概率，建立这个 $3$ 状态 CTMC 的模型，并推导稳态可用性 $A(\\lambda,\\mu)$，该可用性定义为副本处于状态 $H$ 的平稳概率。将您的最终结果表示为关于 $\\lambda$ 和 $\\mu$ 的单个简化的闭式代数表达式。无需四舍五入，最终表达式中不应包含任何单位。",
            "solution": "该问题是有效的，因为它描述了一个标准的、适定的连续时间马尔可夫链 (CTMC) 模型，这是可靠性工程和操作系统分析中的一种基本工具。所有必要的参数均已提供，问题具有科学依据，并且存在唯一、稳定的解。\n\n该系统被建模为一个状态空间为 $S = \\{H, R, F\\}$ 的 CTMC，其中 $H$ 表示健康状态，$R$ 表示恢复中状态，$F$ 表示故障状态。这些状态之间的转换由具有给定速率的指数分布停留时间决定。转换可总结如下：\n1.  从状态 $H$ 到状态 $F$，速率为 $\\lambda$。\n2.  从状态 $F$ 到状态 $R$，速率为 $\\mu$。\n3.  从状态 $R$ 到状态 $H$，速率为 $\\mu$。\n\n我们旨在求得该链的稳态（或平稳）概率分布。设 $\\pi_H$、$\\pi_R$ 和 $\\pi_F$ 分别为系统在状态 $H$、$R$ 和 $F$ 中度过的长时间比例。这些概率在稳态下是恒定的，这意味着对于每个状态，流入该状态的速率必须等于流出该状态的速率。该原则导出了一组平衡方程。\n\n每个状态的平衡方程构建如下：\n- 对于状态 $H$：流入状态 $H$ 的流量来自状态 $R$，速率为 $\\mu$。流出状态 $H$ 的流量去往状态 $F$，速率为 $\\lambda$。因此，平衡方程为：\n$$ \\mu \\pi_R = \\lambda \\pi_H $$\n\n- 对于状态 $R$：流入状态 $R$ 的流量来自状态 $F$，速率为 $\\mu$。流出状态 $R$ 的流量去往状态 $H$，速率为 $\\mu$。因此，平衡方程为：\n$$ \\mu \\pi_F = \\mu \\pi_R $$\n该方程可简化为：\n$$ \\pi_F = \\pi_R $$\n\n- 对于状态 $F$：流入状态 $F$ 的流量来自状态 $H$，速率为 $\\lambda$。流出状态 $F$ 的流量去往状态 $R$，速率为 $\\mu$。因此，平衡方程为：\n$$ \\lambda \\pi_H = \\mu \\pi_F $$\n\n注意到这三个方程是线性相关的。我们可以使用其中任意两个。我们使用 $\\mu \\pi_R = \\lambda \\pi_H$ 和 $\\pi_F = \\pi_R$。从第一个方程，我们可以用 $\\pi_H$ 表示 $\\pi_R$：\n$$ \\pi_R = \\frac{\\lambda}{\\mu} \\pi_H $$\n由于 $\\pi_F = \\pi_R$，我们同样有：\n$$ \\pi_F = \\frac{\\lambda}{\\mu} \\pi_H $$\n\n为了找到唯一解，我们必须使用归一化条件，即所有平稳概率之和必须等于 $1$：\n$$ \\pi_H + \\pi_R + \\pi_F = 1 $$\n\n现在，我们将用 $\\pi_H$ 表示的 $\\pi_R$ 和 $\\pi_F$ 的表达式代入归一化方程中：\n$$ \\pi_H + \\left(\\frac{\\lambda}{\\mu} \\pi_H\\right) + \\left(\\frac{\\lambda}{\\mu} \\pi_H\\right) = 1 $$\n\n提取公因子 $\\pi_H$：\n$$ \\pi_H \\left(1 + \\frac{\\lambda}{\\mu} + \\frac{\\lambda}{\\mu}\\right) = 1 $$\n$$ \\pi_H \\left(1 + \\frac{2\\lambda}{\\mu}\\right) = 1 $$\n\n为了解出 $\\pi_H$，我们首先合并括号内的项：\n$$ \\pi_H \\left(\\frac{\\mu + 2\\lambda}{\\mu}\\right) = 1 $$\n\n最后，我们解出 $\\pi_H$：\n$$ \\pi_H = \\frac{\\mu}{\\mu + 2\\lambda} $$\n\n问题将稳态可用性 $A(\\lambda, \\mu)$ 定义为副本处于健康状态 $H$ 的平稳概率。因此，$A(\\lambda, \\mu) = \\pi_H$。\n\n得到的稳态可用性表达式为：\n$$ A(\\lambda, \\mu) = \\frac{\\mu}{\\mu + 2\\lambda} $$\n这是一个用给定参数 $\\lambda$ 和 $\\mu$ 表示的闭式代数表达式。",
            "answer": "$$\\boxed{\\frac{\\mu}{\\mu + 2\\lambda}}$$"
        },
        {
            "introduction": "理论模型必须面对现实世界中硬件故障的复杂性。本题探讨了存储系统中一个微妙但关键的问题——“撕裂写”(torn writes)，以及它如何破坏复制日志。你将分析诸如校验和与基于法定人数 (quorum-based) 的协议等机制如何协同工作，以检测数据损坏并正确地重建最新的已提交状态 ，从而深入了解健壮的生产级系统的设计。",
            "id": "3641407",
            "problem": "考虑一个操作系统存储子系统中的副本化仅追加日志。存在 $n$ 个副本，当至少从 $q$ 个副本接收到确认时，一次写入被视为已提交。每条日志记录由一个序列号 $S$、一个大小为 $L$ 字节的有效负载 $P$ 以及一个存储了序对 $(L,H)$ 的定长头部组成，其中 $H$ 是根据 $(S,P)$ 计算的校验和。该校验和函数是一个 $b$ 位的循环冗余校验（CRC），并且我们假设它在有效输入上表现得像一个均匀分布的哈希函数。磁盘以大小为 $\\sigma$ 字节的扇区进行写入，电源故障可能导致扇区的部分写入，从而产生一个撕裂扇区，其中只有扇区的前缀是持久化的。\n\n在恢复时，系统必须检测到撕裂写入并重建最新的已提交记录。恢复过程从头开始扫描每个副本的日志，通过检查接下来的 $L$ 字节是否存在以及重新计算的校验和 $H'$ 是否等于存储的 $H$ 来验证每条记录。当一条记录验证失败时，扫描停止，并且该副本的日志在最后一条有效记录处被截断。假设存在崩溃-停止故障（副本要么忠实地存储它们尝试写入的位，要么因撕裂扇区而丢失后缀；副本不是恶意的），并且确认仅在头部 $(L,H)$ 和有效负载 $P$ 已通过适当的写屏障发往设备后才发送。\n\n假设 $n=5$，$q=3$，$\\sigma=4096$ 字节，$b=32$。分析部分写入（撕裂扇区）对副本正确性的影响，并提出校验和加长度的成帧方式如何能够从法定人数中进行修复。下列哪些陈述是正确的？选择所有适用的选项。\n\nA. 仅靠多数法定人数就足以在没有任何完整性机制的情况下掩盖撕裂扇区，因为任何两个多数法定人数都会相交，相交的副本可以消除正确尾部的歧义。\n\nB. 对于一个均匀分布的 $b$ 位校验和，一个随机的撕裂有效负载恰好与存储的 $L$ 和 $H$ 都匹配的概率最多为 $2^{-b}$，这使得对于 $b=32$ 的情况，未被检测到的损坏可以忽略不计。\n\nC. 在修复中，读取任意 $q$ 个副本并选择其中校验和出现最频繁的有效负载，总是能返回最新的已提交有效负载。\n\nD. 一个健全的修复规则是：在具有有效 $(L,H)$ 的候选项中，找到最大的序列号 $S$，使得序对 $(L,H)$ 在至少 $q$ 个副本上完全相同地出现；声明该有效负载已提交，并重写所有其他副本以匹配；在崩溃-停止故障和可通过成帧检测到的撕裂扇区的情况下，这会重建已提交的记录。\n\nE. 将记录与扇区大小 $\\sigma$ 对齐可以消除撕裂扇区，因此如果 $L$ 是 $\\sigma$ 的倍数，则校验和加长度的成帧方式是不必要的。",
            "solution": "用户提供了一个关于操作系统存储子系统中副本化仅追加日志的问题陈述。任务是验证该问题陈述，然后评估所给出的五个陈述的正确性。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n-   系统：副本化仅追加日志。\n-   副本数量：$n$。\n-   写入法定人数大小：$q$。一次写入若被 $\\ge q$ 个副本确认，则视为已提交。\n-   日志记录：\n    -   序列号 $S$。\n    -   大小为 $L$ 字节的有效负载 $P$。\n    -   头部：$(L, H)$，其中 $L$ 是有效负载大小，$H$ 是校验和。\n-   校验和：\n    -   函数：$b$ 位的循环冗余校验（CRC）。\n    -   计算对象：$(S, P)$。\n    -   假设：表现得像一个均匀分布的哈希函数。\n-   存储特性：\n    -   扇区大小：$\\sigma$ 字节。\n    -   故障模式：电源故障可导致扇区的部分写入，产生撕裂扇区。\n-   故障模型：\n    -   崩溃-停止故障：副本行为不具恶意。它们要么正确存储数据，要么因撕裂写入而丢失日志的后缀。\n-   提交-确认协议：确认仅在头部 $(L, H)$ 和有效负载 $P$ 已通过适当的写屏障发往存储设备后才发送。\n-   恢复过程：\n    1.  从头开始扫描每个副本的日志。\n    2.  验证每条记录，方法是检查：\n        a. 接下来的 $L$ 字节（有效负载）是否存在。\n        b. 重新计算的校验和 $H'$ 是否等于存储的校验和 $H$。\n    3.  如果验证失败，则将副本的日志在最后一条有效记录处截断。\n-   问题常数：$n=5$, $q=3$, $\\sigma=4096$ 字节, $b=32$。\n-   问题：分析正确性和修复机制，并确定所提供的陈述中哪些是正确的。\n\n**步骤2：使用提取的给定信息进行验证**\n-   **科学依据：** 该问题牢固地植根于分布式系统和容错存储的原理。基于法定人数的复制（如 Paxos 或 Raft）、用于数据完整性的校验和（如 CRC）以及像撕裂写入这样的物理故障模式，都是计算机科学与工程中标准且被充分理解的概念。\n-   **适定性：** 该问题是适定的。它描述了一个系统模型、一个故障模型和一个恢复目标。参数都已定义，任务是评估关于系统行为的特定主张，这是一个可解的分析任务。\n-   **客观性：** 语言技术性强、精确且客观，没有主观或含糊的陈述。\n-   **完整性与一致性：** 该问题为分析这些陈述提供了足够的信息。崩溃-停止模型、法定人数条件（$q>n/2$ 因为 $3 > 5/2$）、撕裂写入的性质以及校验和的作用都得到了明确说明。没有内部矛盾。\n\n**步骤3：结论与行动**\n该问题陈述是**有效的**。这是一个分析容错分布式系统的标准练习。我将继续进行解决方案推导和选项分析。\n\n### 解决方案和选项分析\n\n该系统使用多数法定人数（$n=5, q=3$）。多数法定人数系统的一个关键特性是，任意两个法定人数集合都有非空交集。具体来说，对于任意两个法定人数集合 $Q_1, Q_2$，我们有 $|Q_1 \\cap Q_2| \\ge |Q_1|+|Q_2|-n = q+q-n = 3+3-5=1$。这个交集对于确保能够检索到关于最新已提交状态的信息至关重要。问题围绕这个法定人数属性如何与物理数据损坏（撕裂扇区）以及用于检测它的机制（校验和加长度的成帧方式）相互作用展开。\n\n**A. 仅靠多数法定人数就足以在没有任何完整性机制的情况下掩盖撕裂扇区，因为任何两个多数法定人数都会相交，相交的副本可以消除正确尾部的歧义。**\n\n这个陈述是**不正确的**。法定人数交集属性旨在解决不同*有效*日志版本之间的冲突，而不是检测或纠正数据损坏。撕裂扇区会导致数据损坏、无效。如果没有像校验和这样的完整性机制，就不可能区分有效记录与记录前缀或部分写入留下的其他随机数据。两个法定人数交集中的副本本身可能包含损坏的、撕裂的数据。依赖这样的副本进行“消除歧义”会传播损坏。例如，如果序列号为 $S_k$ 的写入被副本 $\\{R_1, R_2, R_3\\}$ 确认并提交，随后尝试对 $S_{k+1}$ 进行新的写入，电源故障可能导致 $R_1$ 上有 $S_{k+1}$ 的撕裂写入，而 $R_2$ 和 $R_3$ 从未开始写入。在恢复时，如果我们轮询一个法定人数集合 $\\{R_1, R_4, R_5\\}$，副本 $R_1$ 含有损坏的数据。如果没有校验和，恢复协议无法确定 $R_1$ 的尾部已损坏且必须被截断。因此，完整性机制是必不可少的，仅靠法定人数是不够的。\n\n**B. 对于一个均匀分布的 $b$ 位校验和，一个随机的撕裂有效负载恰好与存储的 $L$ 和 $H$ 都匹配的概率最多为 $2^{-b}$，这使得对于 $b=32$ 的情况，未被检测到的损坏可以忽略不计。**\n\n这个陈述是**正确的**。校验和加长度的成帧机制在恢复时的工作方式如下：读取一个头部 $(L, H)$，读取随后的 $L$ 字节以获得有效负载 $P$，并验证 `checksum(S, P) == H` 是否成立。如果磁盘上一段损坏的字节序列被意外地解释为一条有效记录，就会发生未检测到的错误。这要求损坏的数据能被解析为一个看起来有效的头部 $(L_{corr}, H_{corr})$ 和一个长度为 $L_{corr}$ 的有效负载 $P_{corr}$，并且重新计算的校验和与 $H_{corr}$ 匹配。保护的核心在于校验和。假设校验和函数的行为像一个随机预言机（如“均匀分布的哈希”所暗示的），对于任何任意输入数据（如损坏的有效负载），其 $b$ 位校验和计算出特定预定值的概率是 $1/2^b$。因此，随机损坏通过校验和验证的概率是 $2^{-b}$。当 $b=32$ 时，这个概率是 $1/2^{32} \\approx 2.3 \\times 10^{-10}$，这是一个极小的值。对于大多数应用来说，这个风险被认为是可忽略的。该陈述正确地描述了校验和的这一基本属性。\n\n**C. 在修复中，读取任意 $q$ 个副本并选择其中校验和出现最频繁的有效负载，总是能返回最新的已提交有效负载。**\n\n这个陈述是**不正确的**。这描述了一种简单的投票机制，已知是有缺陷的。它可能导致选择一个从未被提交的写入。考虑以下场景：最新的已提交记录是 $S_k$，存在于所有 $n=5$ 个副本上。一个新的记录 $S_{k+1}$ 的写入被启动。它成功写入到 2 个副本 $\\{R_1, R_2\\}$，这少于法定人数大小 $q=3$。因此，$S_{k+1}$ *未被*提交。此时发生电源故障。在恢复并截断部分写入后，日志尾部的状态是：\n-   $R_1$：包含有效记录 $S_{k+1}$。\n-   $R_2$：包含有效记录 $S_{k+1}$。\n-   $R_3, R_4, R_5$：包含有效记录 $S_k$。\n现在，一个修复过程读取一个由 $q=3$ 个副本组成的法定人数集合，例如 $\\{R_1, R_2, R_3\\}$。它观察到两个 $S_{k+1}$ 的校验和实例和一个 $S_k$ 的校验和实例。按照所提议的规则，它会选择 $S_{k+1}$ 作为正确的状态，因为它的校验和出现得最频繁。然而，$S_{k+1}$ 从未被提交。这将通过复活未提交的数据来违反系统的正确性。\n\n**D. 一个健全的修复规则是：在具有有效 $(L,H)$ 的候选项中，找到最大的序列号 $S$，使得序对 $(L,H)$ 在至少 $q$ 个副本上完全相同地出现；声明该有效负载已提交，并重写所有其他副本以匹配；在崩溃-停止故障和可通过成帧检测到的撕裂扇区的情况下，这会重建已提交的记录。**\n\n这个陈述是**正确的**。这个规则是像 Paxos 或 Raft 这样的系统中使用的读取/恢复协议的简化版本。让我们分析其逻辑：\n1.  一条记录的写入只有在它被成功存储在 $q$ 个副本的法定人数集合上时才算提交。\n2.  序对 `(L,H)` 作为记录特定版本（序列号 $S$）内容的唯一标识符。\n3.  该规则搜索最高的序列号 $S_{max}$，其记录内容（由 $(L,H)$ 标识）存在于至少 $q$ 个副本上。\n4.  因为任何对序列号 $S_{commit}$ 的已提交写入都必须已存储在一个法定人数集合 $Q_{write}$ 上，并且恢复过程读取其自己的法定人数集合 $Q_{read}$，所以交集 $Q_{write} \\cap Q_{read}$ 是非空的。这确保了恢复过程将能看到任何已提交写入的证据。\n5.  通过对给定的记录 $(S, (L,H))$ 要求一个完整的法定人数（$q$），该规则确保它只考虑那些*可能已经*提交的记录。\n6.  通过选择*最大*的此类序列号，它找到了保证稳定的最新状态。任何序列号更高但出现在少于 $q$ 个副本上的记录，根据定义，都未被提交，必须回滚。任何序列号较低的记录都是被这个更新的已提交状态所取代的日志前缀的一部分。这个过程正确地识别了已提交日志的头部。\n\n**E. 将记录与扇区大小 $\\sigma$ 对齐可以消除撕裂扇区，因此如果 $L$ 是 $\\sigma$ 的倍数，则校验和加长度的成帧方式是不必要的。**\n\n这个陈述是**不正确的**。其前提“对齐可以消除撕裂扇区”是错误的。“撕裂扇区”是一种物理现象，即单个扇区的写入被中断。问题陈述明确允许这种情况。即使一次记录写入只涉及一个扇区（即，$L  \\sigma$ 并且记录包含在一个扇区内），该扇区本身也可能在电源故障时被撕裂。如果一条记录跨越多个扇区（即，$L > \\sigma$），电源故障可能在写入部分扇区之后、但在全部写入之前发生，从而留下不完整的（撕裂的）记录。写入 $k=\\lceil L/\\sigma \\rceil$ 个扇区的操作通常不是一个原子操作。因此，对齐并不能消除记录被部分写入的可能性。因此，像校验和加长度的成帧这样的完整性机制仍然是必要的，以检测这种部分写入，并区分有效、完整的记录与损坏、不完整的记录。",
            "answer": "$$\\boxed{BD}$$"
        }
    ]
}