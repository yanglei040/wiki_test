{
    "hands_on_practices": [
        {
            "introduction": "While the access matrix provides a clean theoretical model, real-world systems rely on practical implementations like Access Control Lists (ACLs). This exercise explores the crucial details of how ACLs are processed, demonstrating that the order of rules can dramatically change the outcome of an access request. By working through this scenario , you will gain a deeper appreciation for the importance of canonical ordering in enforcing a consistent security policy, such as \"deny overrides allow,\" and contrast this with denial patterns in capability-based systems.",
            "id": "3674094",
            "problem": "Consider an object $O$ protected by a Discretionary Access Control List (DACL), which is a specialized Access Control List (ACL) for objects in certain operating systems. The DACL consists of Access Control Entries (ACEs), each of which associates a principal with a set of permitted or denied rights. Let a user $u$ be a member of a group $g$. The DACL on $O$ has the following explicit ACEs in this non-canonical order (top to bottom as listed):\n\n$1.$ Allow $W$ to $u$.\n$2.$ Allow $R$ to $g$.\n$3.$ Deny $W$ to $g$.\n$4.$ Deny $R$ to $u$.\n\nAssume the canonical ACL ordering for this system sorts all explicit deny ACEs before all explicit allow ACEs, and places inherited ACEs after explicit ACEs. There are no inherited ACEs in this scenario. The rights are standard read $R$ and write $W$.\n\nStarting from core access control concepts in the access matrix model, convert the DACL to its canonical order and reason about the effective access when $u$ requests only $R$, only $W$, and the implications of ACE ordering on the access check. Then, compare how denial is expressed in capability-based systems that represent authority as unforgeable tokens rather than per-object ACLs.\n\nWhich of the following statements are correct?\n\nA. With the non-canonical ACE order given above, a request by $u$ for only $W$ succeeds and a request by $u$ for only $R$ succeeds; with the canonical order, both fail because deny ACEs are evaluated first.\n\nB. In canonical ACLs, a specific allow ACE for $u$ overrides a deny ACE for $g$ even if $u \\in g$, so $u$ can write to $O$ despite the group deny, independent of ACE order.\n\nC. In capability systems, there is no native “deny” at access-check time; to prevent $W$ after a capability has been distributed, common patterns avoid issuing the $W$ capability or use indirection to a revocable reference, enabling revocation without combining “denies” across principals.\n\nD. Canonicalization does not change effective access because the system computes the union of all allow rights minus the union of all deny rights regardless of ACE order.\n\nE. Canonicalization reduces the dimensionality of the access matrix by collapsing multiple principals into a single ACE, which is why it changes effective access.\n\nSelect all that apply.",
            "solution": "The problem statement describes a scenario in Discretionary Access Control (DAC) involving an object $O$, a user $u$, and a group $g$, where $u$ is a member of $g$ (denoted $u \\in g$). The access rights are controlled by a Discretionary Access Control List (DACL), and the fundamental task is to determine the effective permissions for user $u$ under two different orderings of Access Control Entries (ACEs) and to compare the ACL model with capability-based systems.\n\n### Step 1: Extract Givens\n\n-   Object: $O$\n-   User: $u$\n-   Group: $g$\n-   Membership: $u \\in g$\n-   Rights: Read ($R$) and Write ($W$)\n-   Non-Canonical DACL on $O$:\n    $1.$ Allow $W$ to $u$.\n    $2.$ Allow $R$ to $g$.\n    $3.$ Deny $W$ to $g$.\n    $4.$ Deny $R$ to $u$.\n-   Canonical Ordering Rule: All explicit deny ACEs are sorted before all explicit allow ACEs.\n-   Inherited ACEs: None.\n-   Access Check Model: The problem implies a sequential evaluation of ACEs, where the access check algorithm stops at the first ACE that determines the outcome for the requested access right. This is standard behavior for systems like Windows NT, from which this model is derived.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is based on core, well-established concepts in operating systems security, specifically the access matrix model and its practical implementations: Access Control Lists (ACLs) and capabilities. The described behavior of DACLs, canonical ordering, and the \"deny overrides allow\" principle are standard features in real-world operating systems. The problem is firmly grounded in computer science principles.\n-   **Well-Posed**: The problem provides a complete set of rules and initial conditions. The given ACEs, the user-group relationship, and the rule for canonical ordering are sufficient to derive a unique set of effective permissions for the user $u$.\n-   **Objective**: The problem uses precise, standard terminology from the field of computer security. There are no subjective or ambiguous statements.\n\nThe problem statement is valid. It is a well-formed conceptual problem in operating systems security.\n\n### Step 3: Derivation and Analysis\n\n**Analysis of Non-Canonical ACE Order**\n\nThe system evaluates the ACEs in the specified order: $1, 2, 3, 4$. When user $u$ requests access, the system checks for ACEs pertaining to $u$ directly and to any groups $u$ belongs to, in this case, $g$.\n\n1.  **Request by $u$ for Write ($W$) access:**\n    The system scans the ACL:\n    -   ACE $1$: `Allow W to u`. This ACE explicitly matches the user $u$ and the requested right $W$. Access is granted. The evaluation process terminates.\n    -   **Result:** The request for $W$ access is **granted**.\n\n2.  **Request by $u$ for Read ($R$) access:**\n    The system scans the ACL:\n    -   ACE $1$: `Allow W to u`. This does not match the requested right $R$. The scan continues.\n    -   ACE $2$: `Allow R to g`. Since $u \\in g$, this ACE matches the user's group membership and the requested right $R$. Access is granted. The evaluation process terminates.\n    -   **Result:** The request for $R$ access is **granted**.\n\nIn summary, with the non-canonical ordering, user $u$ is granted both $R$ and $W$ access to object $O$.\n\n**Analysis of Canonical ACE Order**\n\nThe canonicalization rule requires placing all deny ACEs before all allow ACEs.\n-   Deny ACEs: `3. Deny W to g` and `4. Deny R to u`.\n-   Allow ACEs: `1. Allow W to u` and `2. Allow R to g`.\n\nThe canonical DACL becomes (the sub-ordering within the deny and allow blocks does not affect the outcome in this case):\n$1'.$ `Deny W to g` (from original $3$)\n$2'.$ `Deny R to u` (from original $4$)\n$3'.$ `Allow W to u` (from original $1$)\n$4'.$ `Allow R to g` (from original $2$)\n\nNow, we re-evaluate user $u$'s access requests against this canonical list.\n\n1.  **Request by $u$ for Write ($W$) access:**\n    The system scans the canonical ACL:\n    -   ACE $1'$: `Deny W to g`. Since $u \\in g$, this ACE matches the user's group and the requested right $W$. Access is denied. The evaluation process terminates.\n    -   **Result:** The request for $W$ access is **denied**.\n\n2.  **Request by $u$ for Read ($R$) access:**\n    The system scans the canonical ACL:\n    -   ACE $1'$: `Deny W to g`. This does not match the requested right $R$. The scan continues.\n    -   ACE $2'$: `Deny R to u`. This ACE explicitly matches the user $u$ and the requested right $R$. Access is denied. The evaluation process terminates.\n    -   **Result:** The request for $R$ access is **denied**.\n\nIn summary, with the canonical ordering, user $u$ is denied both $R$ and $W$ access. The \"deny overrides allow\" policy is enforced by this ordering.\n\n**Evaluation of Options**\n\n**A. With the non-canonical ACE order given above, a request by $u$ for only $W$ succeeds and a request by $u$ for only $R$ succeeds; with the canonical order, both fail because deny ACEs are evaluated first.**\n-   As derived above, with the non-canonical order, the request for $W$ succeeds due to ACE $1$, and the request for $R$ succeeds due to ACE $2$.\n-   As derived above, with the canonical order, the request for $W$ fails due to the `Deny W to g` ACE, and the request for $R$ fails due to the `Deny R to u` ACE. Both fail because the deny ACEs are encountered and processed before the allow ACEs.\n-   This statement is fully consistent with our analysis.\n-   **Verdict: Correct**\n\n**B. In canonical ACLs, a specific allow ACE for $u$ overrides a deny ACE for $g$ even if $u \\in g$, so $u$ can write to $O$ despite the group deny, independent of ACE order.**\n-   This statement makes two incorrect claims. First, it suggests that specificity (an ACE for $u$ vs. an ACE for $g$) is the dominant rule. However, the problem states the canonical ordering rule is based on the access type (deny vs. allow). In our canonical evaluation for the $W$ right, `Deny W to g` is evaluated before `Allow W to u`, causing access to be denied. The specific allow for $u$ does *not* override the group deny for $g$. Second, it claims this is \"independent of ACE order,\" which is demonstrably false; our analysis shows that the order is precisely what changes the outcome.\n-   **Verdict: Incorrect**\n\n**C. In capability systems, there is no native “deny” at access-check time; to prevent $W$ after a capability has been distributed, common patterns avoid issuing the $W$ capability or use indirection to a revocable reference, enabling revocation without combining “denies” across principals.**\n-   This statement accurately describes a fundamental aspect of capability-based security. Access is granted based on the possession of an unforgeable token (the capability), which cryptographically binds a principal to an object with specific rights. If a principal does not possess a capability permitting an operation, access is impossible. There is no concept of a separate \"deny\" list on the object. The problem of revocation (taking back a right that was granted) is a classic challenge in capability systems, and the statement correctly identifies two primary solutions: careful initial distribution (principle of least privilege) and the use of indirection through a proxy object, which allows a right to be revoked centrally.\n-   **Verdict: Correct**\n\n**D. Canonicalization does not change effective access because the system computes the union of all allow rights minus the union of all deny rights regardless of ACE order.**\n-   This statement describes a different, set-based model of access evaluation. If this model were used, the rights would be calculated as: (Rights from `Allow W to u` $\\cup$ Rights from `Allow R to g`) $-$ (Rights from `Deny W to g` $\\cup$ Rights from `Deny R to u`). For user $u$, this would be $(\\{W\\} \\cup \\{R\\}) - (\\{W\\} \\cup \\{R\\}) = \\emptyset$. This model would yield no rights for $u$. However, our analysis of the non-canonical, sequential evaluation shows that $u$ *does* get rights. Since canonicalization demonstrably changes the effective access in the model described by the problem (from $\\{R, W\\}$ to $\\emptyset$), this statement's premise is false.\n-   **Verdict: Incorrect**\n\n**E. Canonicalization reduces the dimensionality of the access matrix by collapsing multiple principals into a single ACE, which is why it changes effective access.**\n-   This statement is conceptually flawed. Canonicalization is an *ordering* process applied to the set of ACEs in an ACL; it does not \"collapse\" principals or ACEs. The access matrix is a theoretical model with dimensions (principals, objects); an ACL is a column in this matrix. Reordering the entries in a column does not change the dimensionality of the matrix. The reason canonicalization changes effective access is due to the sequential nature of the evaluation algorithm, not due to any change in the underlying structure of the access matrix itself.\n-   **Verdict: Incorrect**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "Security policies in modern operating systems are rarely static; group memberships and permissions can change at any moment. This dynamism creates a window for a classic and dangerous vulnerability: the Time-Of-Check-To-Time-Of-Use (TOCTTOU) race condition. This practice challenges you to think like a systems designer, analyzing how a change in authorization state between a security check and the resource access can undermine security, and evaluating realistic architectural patterns that enforce immediate and atomic revocation .",
            "id": "3674083",
            "problem": "A multi-user operating system implements access control using the access matrix model, where the access matrix $M$ maps a subject $s$ and an object $o$ to a set of rights $R = M[s,o]$. Objects carry Access Control Lists (ACLs), and subjects may be members of groups. The ACL of object $o$ authorizes a set of principals (users and groups) for rights on $o$. Group membership is provided by a dynamic group membership service that maintains a function $G(s,t)$ giving the set of groups to which subject $s$ belongs at time $t$. The system’s authorization rule at time $t$ is: subject $s$ may exercise right $r$ on object $o$ if and only if the intersection $G(s,t) \\cap \\text{ACL}_o(r)$ is nonempty.\n\nThe protection goals are to preserve integrity of authorization decisions and to enforce immediate revocation: if a subject $s$ is removed from an authorizing group at time $t_r$, then any operation by $s$ that has not yet committed by time $t_r$ must not succeed based on the revoked membership. Consider a typical Time-Of-Check-To-Time-Of-Use (TOCTTOU) race: a user-level process initiates an operation at time $t_c$; the kernel checks authorization using $G(s,t_c)$ and $\\text{ACL}_o$; before the operation commits at time $t_u$, the group service updates $G(s,t)$ at $t_r$ with $t_c < t_r < t_u$.\n\nSelect all design choices that eliminate the TOCTTOU race for authorization with immediate revocation under dynamic group membership while keeping the system scientifically realistic. In each case, assume the kernel has access to authoritative state for ACLs and group membership.\n\nA) Perform authorization and the resource operation within a single kernel entry while holding a consistency primitive over the relevant policy state: the kernel reads a version $v$ that covers both $\\text{ACL}_o$ and the relevant groups in $G$, authorizes, performs the operation, then rechecks that the version is still $v$ before committing; policy updates (ACL edits or group membership changes) increment the version atomically by $1$. If the version changed, abort and retry in-kernel as a single operation.\n\nB) Split authorization and use into two separate system calls: the first call checks membership in user space and returns a boolean, and the second call performs the operation if the boolean was true. Rely on the scheduler to avoid preemption between the calls.\n\nC) Cache positive authorization results in user space with a time-to-live $\\tau$: if the operation starts within time $\\tau$ from the cached check, skip reauthorization; if not, reauthorize.\n\nD) Maintain a per-object ACL generation counter $g_o$ and, optionally, per-subject group-membership generation $g_s$. When the kernel authorizes an operation on $o$ for subject $s$, it binds the observed $(g_o, g_s)$ to the resulting handle or in-flight operation descriptor. Every use validates that the current generations equal the bound ones; any ACL edit to $o$ or group-membership change for $s$ increments the corresponding generation atomically by $1$, invalidating stale handles, and forcing reauthorization before use.\n\nChoose all that apply.",
            "solution": "The problem statement describes a classic Time-Of-Check-To-Time-Of-Use (TOCTTOU) race condition in an operating system's access control mechanism. The system's state is dynamic due to a group membership service, $G(s,t)$. An authorization check is performed at time $t_c$, but the underlying authorization state (group membership) changes at time $t_r$ before the operation is completed at time $t_u$, where $t_c < t_r < t_u$. The security goal is to enforce \"immediate revocation,\" meaning the operation at $t_u$ must not succeed if its authorization basis was invalidated at $t_r$.\n\nFirst, the problem statement is validated.\n**Step 1: Extract Givens**\n- Access matrix: $M$, where $M[s,o] = R$ for a subject $s$, object $o$, and set of rights $R$.\n- Implementation: Objects have Access Control Lists (ACLs). Subjects have group memberships.\n- Group membership: A function $G(s,t)$ gives the set of groups for subject $s$ at time $t$.\n- Authorization rule: Subject $s$ has right $r$ on object $o$ at time $t$ if and only if the intersection $G(s,t) \\cap \\text{ACL}_o(r)$ is nonempty, where $\\text{ACL}_o(r)$ is the set of principals authorized for right $r$ on $o$.\n- Protection Goal: Immediate revocation. If subject $s$ is removed from a group at time $t_r$, any uncommitted operation by $s$ starting before $t_r$ must fail if its authorization depended on that group membership.\n- Scenario: A TOCTTOU race where an authorization check occurs at $t_c$, a revocation at $t_r$, and the use of the resource at $t_u$, with the time ordering $t_c < t_r < t_u$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is scientifically grounded, well-posed, and objective. It formalizes a well-known security vulnerability (TOCTTOU) in the context of dynamic access control policies, a standard topic in operating systems security. The concepts used (ACLs, group membership, access matrix, atomicity) are standard. The problem is self-contained and does not contain contradictions or factual errors.\n\n**Step 3: Verdict and Action**\nThe problem is valid. I will proceed to analyze each proposed solution. The core challenge is to ensure that the state of the system used for the authorization decision at $t_c$ remains valid through the completion of the operation at $t_u$. Any change to that state, such as the revocation at $t_r$, must be detected and must lead to the failure of the operation.\n\n**Option-by-Option Analysis**\n\n**A) Perform authorization and the resource operation within a single kernel entry while holding a consistency primitive over the relevant policy state: the kernel reads a version $v$ that covers both $\\text{ACL}_o$ and the relevant groups in $G$, authorizes, performs the operation, then rechecks that the version is still $v$ before committing; policy updates (ACL edits or group membership changes) increment the version atomically by $1$. If the version changed, abort and retry in-kernel as a single operation.**\n\nThis option describes an optimistic concurrency control (OCC) mechanism. The entire critical section, from check to use, is performed within a single atomic-appearing block. The atomicity is achieved not by locking, but by versioning and validation.\n1.  At the start of the operation (before $t_c$), the kernel reads the current version $v$ of the policy state.\n2.  The authorization check is performed based on this version.\n3.  The operation on the resource is performed tentatively.\n4.  At time $t_r$, a policy update occurs, which involves atomically incrementing the version from $v$ to $v+1$.\n5.  Before committing the operation's result (at time $t_u$), the kernel re-validates by comparing the version it read initially, $v$, with the current version, $v+1$.\n6.  Since $v \\neq v+1$, the validation fails, and the operation is aborted.\n\nThis sequence correctly prevents the operation from succeeding based on stale authorization, thus satisfying the immediate revocation requirement. The use of atomic version counters and a check-act-validate pattern within a single kernel entry is a standard, scientifically realistic technique for resolving race conditions.\n\n**Verdict: Correct**\n\n**B) Split authorization and use into two separate system calls: the first call checks membership in user space and returns a boolean, and the second call performs the operation if the boolean was true. Rely on the scheduler to avoid preemption between the calls.**\n\nThis design is fundamentally flawed.\n1.  **Exposing the Race Window:** Separating the check and use into two system calls with a return to user space in between is the canonical structure that creates a TOCTTOU vulnerability. The time between the first call returning and the second call executing *is* the race window.\n2.  **Unreliable Mitigation:** \"Relying on the scheduler\" is not a security mechanism. A scheduler's behavior is complex, non-deterministic from a user program's perspective, and not designed to enforce security policies. On a multi-processor system, a policy change can occur on a different CPU core without any preemption of the subject's process. Therefore, even disabling preemption would not be a sufficient mitigation.\n3.  **Violates Complete Mediation:** This design violates the security principle of complete mediation, which requires that every access to every object be checked for authority. The second system call (the \"use\") would be proceeding without a timely authorization check, based on a stale result passed from user space.\n\nThis option describes the problem, not a solution.\n\n**Verdict: Incorrect**\n\n**C) Cache positive authorization results in user space with a time-to-live $\\tau$: if the operation starts within time $\\tau$ from the cached check, skip reauthorization; if not, reauthorize.**\n\nThis option fails to meet the \"immediate revocation\" requirement.\n1.  **Time-Based vs. Event-Based Revocation:** A Time-To-Live (TTL) mechanism provides eventual consistency, not immediate revocation. Suppose a check is performed at $t_c$ and the result is cached. A revocation occurs at $t_r$. If an operation is attempted at time $t_{op}$ such that $t_c < t_r < t_{op} < t_c + \\tau$, the cached positive result will be considered valid. The operation will be permitted to proceed, directly violating the requirement that the revocation at $t_r$ be effective immediately. The time period from $t_r$ until $t_c + \\tau$ constitutes a window of vulnerability.\n2.  **User-Space Caching:** Placing security-critical information like an authorization cache in user space is insecure. A malicious or buggy user process could manipulate this cache to gain unauthorized access.\n\nWhile caching is a valid performance optimization, it represents a trade-off where the immediacy of revocation is sacrificed. Therefore, it is not a solution for a system with a strict immediate revocation goal.\n\n**Verdict: Incorrect**\n\n**D) Maintain a per-object ACL generation counter $g_o$ and, optionally, per-subject group-membership generation $g_s$. When the kernel authorizes an operation on $o$ for subject $s$, it binds the observed $(g_o, g_s)$ to the resulting handle or in-flight operation descriptor. Every use validates that the current generations equal the bound ones; any ACL edit to $o$ or group-membership change for $s$ increments the corresponding generation atomically by $1$, invalidating stale handles, and forcing reauthorization before use.**\n\nThis option describes a robust and flexible versioning mechanism.\n1.  **State Versioning:** The relevant policy states (ACLs and group memberships) are versioned using atomically-incremented generation counters ($g_o$ and $g_s$).\n2.  **Binding at Check:** At the time of the initial authorization check (e.g., during an `open()` call at $t_c$), the kernel records the current values of the counters $(g_o, g_s)$ and associates them with the returned handle (e.g., a file descriptor).\n3.  **Invalidation by Update:** At time $t_r$, when a group membership for subject $s$ is revoked, the counter $g_s$ is atomically incremented.\n4.  **Validation at Use:** For every subsequent operation using the handle (e.g., a `read()` call at $t_u$), the kernel first compares the counter values stored in the handle with the current global counter values. In our scenario, it would find that the stored $g_s$ does not match the current global $g_s$. This mismatch indicates that the authorization basis may have changed. The kernel then denies the operation and can require the process to re-authorize.\n\nThis mechanism correctly detects the policy change at $t_r$ before executing the use at $t_u$, thereby enforcing immediate revocation. It effectively closes the TOCTTOU window. This is a scientifically realistic and common design pattern in secure operating systems, as it allows for the separation of check (e.g., `open`) from use (e.g., `read`, `write`) while maintaining security.\n\n**Verdict: Correct**\n\nIn conclusion, both options A and D describe valid, scientifically sound methods for eliminating the specified TOCTTOU race condition and enforcing immediate revocation.",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "A robust protection system cannot be designed in isolation; it must integrate seamlessly with other core operating system components. This hands-on problem delves into the critical intersection of security and memory management, specifically how a capability-based protection model interacts with the efficient copy-on-write (COW) mechanism during process creation. By analyzing how to correctly manage rights during a COW fault , you will learn how to uphold the principle of least privilege and prevent unintended permission escalation in a complex, multi-faceted operation.",
            "id": "3674060",
            "problem": "An operating system uses capability-based protection for memory frames. Each protected object is a physical frame identified by an object identifier, and each domain (process) holds a set of capabilities. A capability is an unforgeable token of the form $\\langle o, R, \\tau \\rangle$, where $o$ is an object identifier, $R \\subseteq \\{r, w, x, g\\}$ is the rights set allowing read ($r$), write ($w$), execute ($x$), and grant ($g$) rights, and $\\tau \\in \\{\\text{normal}, \\text{cow}\\}$ is a tag indicating whether the mapping is a standard mapping or a copy-on-write mapping. The operating system enforces protection via an access matrix $A$ whose conceptual entry $A[d, o]$ is the rights set that domain $d$ has to object $o$, and realizes this via per-domain capability lists. The system implements process creation by duplicating address spaces with copy-on-write: initially, the parent and child share frames, and upon the first write by either, the writer receives a private copy.\n\nThe protection goals are to preserve integrity (no unintended modifications of shared frames) and least privilege (no domain acquires write rights it did not have). Consider a fork of a process $P$ creating a child $C$, where the parent initially has a capability $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$ for a frame $o$. After the fork, both processes map $o$ in a copy-on-write fashion. The kernel itself holds full rights to all frames. The copy-on-write mechanism must ensure that if $C$ only has read access to the shared frame, then $C$ does not gain unintended write rights to $o$ or cause any derived page to inherit $w$ rights beyond what is intended.\n\nWhich design most correctly enforces, in terms of the access matrix model and capability semantics, that derived pages created by copy-on-write do not inherit unintended $w$ rights, while still allowing correct and efficient copy-on-write behavior?\n\nA. Attenuate capabilities at fork by replacing any $\\langle o, R, \\text{normal} \\rangle$ mapping in both $P$ and $C$ with a derived capability $\\langle o, R \\cap \\{r, x\\}, \\text{cow} \\rangle$ that lacks $w$ and $g$. On a write fault by a domain $d \\in \\{P, C\\}$ to $o$, the kernel allocates a new frame $o'$, copies the contents of $o$ into $o'$, updates $A[d, o']$ to include $\\{r, w\\}$ by handing $d$ a new capability $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$, and leaves all other domains’ capabilities to $o$ unchanged as $\\langle o, R \\cap \\{r, x\\}, \\text{cow} \\rangle$.\n\nB. Preserve the original capabilities after fork. On a write fault by domain $d$ to $o$, the kernel temporarily augments $d$’s capability to $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$ so that $d$ can copy the data from $o$ into a new frame $o'$ in user space, then revokes the temporary $w$ right to $o$ and finally gives $d$ a capability $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$.\n\nC. Ensure both $P$ and $C$ retain $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$ after fork, but mark the page tables read-only to induce copy-on-write faults. On a write fault by domain $d$ to $o$, the kernel uses the fact that $d$ has $w$ to $o$ to authorize the operation, then copies to a new frame $o'$ and returns $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$ to $d$.\n\nD. Replace capabilities with an access control list on $o$ listing both $P$ and $C$ with only $r$. On a write fault by domain $d$, temporarily add $w$ for $d$ on $o$ in the access control list, allow $d$ to copy the data to a new frame $o'$, then remove $w$ for $d$ on $o$ and grant $d$ full rights on $o'$.\n\nSelect the best option. Justify your choice by appealing to the definitions of the access matrix, capability attenuation, and copy-on-write semantics, and by analyzing how each alternative affects $A[d, o]$ and the rights propagation to derived objects $o'$ with respect to confidentiality and integrity goals.",
            "solution": "We begin from the definitions and protection goals. In the access matrix $A$, each domain $d$ has a set of rights $A[d, o]$ to each object $o$. Capability-based protection implements $A$ by giving each domain $d$ unforgeable capabilities $\\langle o, R, \\tau \\rangle$ so that $R = A[d, o]$ and the kernel enforces that requests requiring right $r$ or $w$ to object $o$ are authorized only if $r \\in R$ or $w \\in R$, respectively. The protection goals here are integrity (preventing unauthorized modification to shared frame $o$) and least privilege (ensuring no domain acquires $w$ unless explicitly intended). Copy-on-write aims to allow $2$ domains to share an immutable view of data until one intends to modify it, at which time a new object $o'$ is created and the writer is given write access to $o'$ only.\n\nCapability systems support attenuation of privilege: a domain can be given a capability with a subset of rights (e.g., removing $w$) and with additional metadata (e.g., a copy-on-write tag) that does not confer extra authority. A key principle is that capabilities are unforgeable and that a domain cannot increase its rights to an object $o$ without possessing an appropriate grant ($g$) or without a trusted kernel acting with authority separate from that domain. For copy-on-write, the kernel must perform the copy operation, because copying a frame requires either reading from $o$ and writing into $o'$ or temporarily gaining $w$ to $o$ to stage the copy, which risks violating integrity if not carefully controlled.\n\nWe analyze each option in terms of its effect on $A[d, o]$ and rights propagation.\n\nOption A: This design explicitly attenuates rights at fork. For each domain $d \\in \\{P, C\\}$, the mapping to $o$ becomes $\\langle o, R_d \\cap \\{r, x\\}, \\text{cow} \\rangle$, where $R_d$ was the original rights set (for $P$, $R_P = \\{r, w\\}$; for $C$, $R_C = \\{r\\}$ by construction). The removal of $w$ ensures $A[P, o] \\subseteq \\{r, x\\}$ and $A[C, o] \\subseteq \\{r, x\\}$, so neither domain can write the shared frame $o$, preserving integrity. The absence of $g$ ensures no domain can mint a capability with $w$ to $o$ or delegate such rights. The copy-on-write tag $\\tau = \\text{cow}$ is an attenuated reference: it authorizes the kernel to perform a copy-on-write fault handler, but does not itself confer $w$ to $o$. On a write fault by domain $d$, the kernel, which holds authority to allocate frames, creates a new object $o'$ and sets $A[d, o'] = \\{r, w\\}$ by handing out $\\langle o', \\{r, w\\}, \\text{normal} \\rangle$ only to $d$. All other domains retain only read to the original $o$ and do not gain any rights to $o'$. Thus, the derived page $o'$ does not inherit rights from $o$ automatically; it is a fresh object with rights granted only where intended. Confidentiality is preserved because no additional readers are added, and integrity is preserved because no unintended $w$ is propagated to $o$ or to other domains. This aligns with capability attenuation and with the access matrix update being a controlled kernel operation. Therefore, Option A enforces the goals correctly.\n\nOption B: This option proposes temporarily augmenting $A[d, o]$ to include $w$ in order for $d$ to perform the copy in user space, then revoking $w$. There are multiple issues. First, temporarily setting $A[d, o] \\supseteq \\{w\\}$ violates least privilege during the window, creating a time-of-check-to-time-of-use risk: $d$ could write to $o$ or, if it holds $g$, delegate $w$ to others before revocation. Even if the kernel strips $g$ first, changing capabilities in place violates the property that capabilities are unforgeable and immutable from the domain’s perspective; retroactive revocation is complex and error-prone. Second, delegating the copy to user space requires granting rights that were not originally held, and any bug in revocation leaves a permanent elevation. Hence, this mechanism risks unintended $w$ on $o$ and does not reliably ensure that no derived page $o'$ inherits unintended rights, because the temporary elevation is a violation of the principle of least privilege. Therefore, Option B is incorrect.\n\nOption C: Here, both domains retain $\\langle o, \\{r, w\\}, \\text{normal} \\rangle$, but the page tables are marked read-only so that writes fault. Conceptually, in the access matrix, $A[P, o]$ and $A[C, o]$ include $w$. Even though the page tables prevent writes until the kernel intercedes, the possession of $w$ in $A$ is an authorization to modify $o$. This violates the access matrix semantics used to reason about security: the right exists and could be activated by misconfiguration or a bug. It also violates least privilege because $C$ is granted $w$ to $o$ that it does not need and must never exercise. Moreover, retaining $w$ enables unintended delegation if $g$ is present. This design conflates page-table-level enforcement with authorization at the access-matrix level and therefore does not ensure that derived pages avoid inheriting unintended $w$ rights. Option C is incorrect.\n\nOption D: Switching to an access control list on $o$ with temporary $w$ grants similarly introduces a window in which $A[d, o]$ includes $w$. Although the mechanism uses an access control list instead of capabilities, the fundamental problem remains: temporarily elevating $A[d, o]$ to include $w$ to the original shared object $o$ violates least privilege and risks integrity during the window. Additionally, the design description does not specify a kernel-only copy; if the copy is done by $d$, the same delegation and misuse risks arise as in Option B. Even if the kernel performs the copy, the temporary modification of $A[d, o]$ is unnecessary and unsafe; the kernel can read $o$ using its own authority without granting $w$ to $d$ on $o$. Therefore, Option D does not meet the requirement to prevent unintended $w$ rights on $o$ or derived pages. Option D is incorrect.\n\nBy appealing to access matrix semantics and capability attenuation, only Option A maintains $A[d, o] \\subseteq \\{r, x\\}$ for all non-kernel domains until a new object $o'$ is created, at which point only the faulting domain’s $A[d, o']$ includes $\\{r, w\\}$. No unintended $w$ propagates to $o$ or to other domains, and derived objects receive only intended rights. Hence, Option A is the correct design.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}