{
    "hands_on_practices": [
        {
            "introduction": "Understanding deadlock detection begins with mastering the foundational algorithms. This first exercise  provides hands-on practice with the detection algorithm used in systems with multiple instances of each resource type, a scenario where a simple Wait-For Graph is insufficient. By manually executing the algorithm with the given $\\mathbf{Allocation}$, $\\mathbf{Request}$, and $\\mathbf{Available}$ states, you will trace how an OS can methodically check for a safe state and pinpoint exactly which processes are deadlocked.",
            "id": "3632410",
            "problem": "Consider an Operating System (OS) with $n=6$ processes $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ competing for $m=4$ resource types $\\{R_1,R_2,R_3,R_4\\}$, each with multiple instances. The system state is characterized by the resource allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$, the outstanding request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$, and the currently available instances vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$, all given below. Each row corresponds to a process $P_i$, and each column corresponds to a resource type $R_j$.\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1  0  1  0\n\\end{pmatrix}.\n$$\n\nUse the classical deadlock detection algorithm for multiple-instance resources that iteratively searches for an unfinished process $P_i$ whose request vector $Request_i$ satisfies $Request_i \\leq Work$ (with $Work$ initialized to $\\mathbf{Available}$), and when found, treats $P_i$ as able to complete and release its allocation, updating $Work \\leftarrow Work + Allocation_i$. Continue until no such $P_i$ exists; the processes that remain unfinished at that point are deemed unfinishable.\n\nDefine the quantity $S$ to be the sum of the indices of all unfinishable processes, i.e., if the unfinishable set is $\\{P_{i_1}, P_{i_2}, \\dots\\}$ then $S = i_1 + i_2 + \\dots$. Compute $S$. Provide your final answer as an exact integer. No rounding is required.",
            "solution": "The problem is validated as being scientifically grounded, well-posed, and objective. It describes a standard scenario in operating systems and asks for the application of the classical deadlock detection algorithm. All necessary data is provided, and the problem is free of contradictions or ambiguities.\n\nThe task is to determine the set of unfinishable processes in a system with $n=6$ processes and $m=4$ resource types. The state of the system is given by the $\\mathbf{Allocation}$ matrix, the $\\mathbf{Request}$ matrix, and the $\\mathbf{Available}$ vector.\n\nThe givens are:\n- Number of processes: $n=6$, $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$.\n- Number of resource types: $m=4$, $\\{R_1,R_2,R_3,R_4\\}$.\n- Allocation matrix $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- Request matrix $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- Available vector $\\mathbf{Available} \\in \\mathbb{Z}^{4}$:\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}\n$$\n\nWe apply the deadlock detection algorithm. Let $\\mathbf{Work}$ be a vector of length $m$ and $\\mathbf{Finish}$ be a boolean vector of length $n$. The vector inequality $\\mathbf{A} \\leq \\mathbf{B}$ holds if and only if $A_k \\leq B_k$ for all components $k$.\n\n**Step 1: Initialization**\nInitialize $\\mathbf{Work}$ to $\\mathbf{Available}$ and $\\mathbf{Finish}_i$ to false for all processes $i = 0, \\dots, 5$.\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix} $$\n\n**Step 2: Iterative Search and Update**\nThe algorithm proceeds by finding an index $i$ such that $\\mathbf{Finish}_i$ is false and its request vector $\\mathbf{Request}_i \\leq \\mathbf{Work}$. If found, the process can theoretically finish, so we release its resources by updating $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ and setting $\\mathbf{Finish}_i \\leftarrow \\text{true}$. This process is repeated until no such process can be found.\n\n**Iteration 1:**\nWe search for a process $P_i$ with $\\mathbf{Finish}_i = \\text{false}$ and $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$.\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} \\leq \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$. This condition is met.\nLet's select $P_0$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_0 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 2:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$.\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$. This condition is met.\nLet's select $P_1$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_1 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 3:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for the second resource, $1 > 0$.\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$. This condition is met.\nLet's select $P_3$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_3 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{false}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 4:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$.\n- $P_2$: $\\mathbf{Request}_2$ is still not satisfiable.\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix} \\leq \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$. This condition is met.\nLet's select $P_4$.\nUpdate $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$.\nUpdate $\\mathbf{Finish}$: $\\mathbf{Finish}_4 \\leftarrow \\text{true}$.\nThe current state is $\\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ and $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$.\n\n**Iteration 5:**\nWe search for an unfinished process $P_i$ with $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$. The remaining unfinished processes are $P_2$ and $P_5$.\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$. This is not $\\leq \\mathbf{Work}$ because for $R_2$, $1 > 0$.\n\n**Step 3: Termination**\nNo remaining unfinished process can have its request satisfied with the current $\\mathbf{Work}$ vector. The algorithm terminates.\n\n**Step 4: Identify Unfinishable Processes and Calculate S**\nThe processes for which $\\mathbf{Finish}_i$ remains false are considered unfinishable. From the final $\\mathbf{Finish}$ vector $\\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$, the unfinishable processes are $\\{P_2, P_5\\}$.\n\nThe problem defines $S$ as the sum of the indices of all unfinishable processes.\n$$ S = 2 + 5 = 7 $$\nThe physical reason for the deadlock is that both $P_2$ and $P_5$ are requesting an instance of resource $R_2$. There are $0$ instances of $R_2$ available, and no other process that can finish holds any instances of $R_2$ to release. Thus, $P_2$ and $P_5$ will wait indefinitely.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "While detection is critical, an operating system must also be able to recover. This practice  models the entire process for systems with single-instance resources. You will first act as the OS, constructing a Wait-For Graph (WFG) from a snapshot of process requests and resource holdings. Then, you will tackle the recovery phase by solving the classic graph problem of finding a minimal set of 'victims' to preempt, thereby breaking the deadlock and allowing the system to proceed.",
            "id": "3632133",
            "problem": "An operating system monitors a snapshot of resource allocation in a system using the Resource Allocation Graph (RAG) and its derived Wait-For Graph (WFG). Under the single-instance resource model with the logical \"AND\" request semantics, an edge from process $P_{i}$ to process $P_{j}$ appears in the WFG if and only if $P_{i}$ is currently blocked and is requesting at least one resource that is held by $P_{j}$. A deadlock exists if and only if the WFG contains at least one directed cycle. The system can perform resource preemption for recovery: preempting a process $P_{v}$ immediately releases all resources held by $P_{v}$ and removes $P_{v}$ and all incident edges from the WFG.\n\nConsider the following scientifically plausible snapshot with $7$ processes $\\{P_1,P_2,P_3,P_4,P_5,P_6,P_7\\}$ and $8$ single-instance resources $\\{R_1,R_2,R_3,R_4,R_5,R_6,R_8\\}$ (note that resource identifiers need not be consecutive):\n\n- Current holdings (each resource is held by exactly one process):\n  - $R_3$ held by $P_1$.\n  - $R_1$ held by $P_2$.\n  - $R_2$ held by $P_3$.\n  - $R_4$ held by $P_4$.\n  - $R_5$ held by $P_5$.\n  - $R_6$ held by $P_6$.\n  - $R_8$ held by $P_7$.\n\n- Current pending requests (each bullet indicates a process that is blocked, requesting all listed resources simultaneously, each of which is currently held by the stated holder above):\n  - $P_1$ requests $\\{R_1\\}$.\n  - $P_2$ requests $\\{R_2,R_5\\}$.\n  - $P_3$ requests $\\{R_3,R_4\\}$.\n  - $P_4$ requests $\\{R_5,R_8\\}$.\n  - $P_5$ requests $\\{R_2,R_6\\}$.\n  - $P_6$ requests $\\{R_1\\}$.\n  - $P_7$ requests $\\{R_4\\}$.\n\nUsing only the fundamental definitions above:\n- Construct the Wait-For Graph by introducing a directed edge $P_i \\to P_j$ for each requested resource by $P_i$ that is currently held by $P_j$.\n- Reason about deadlock by identifying directed cycles in the WFG.\n- Under the stated preemption model, interpret deadlock recovery as selecting a set of processes (victims) whose preemption breaks all directed cycles in the WFG.\n\nDetermine the minimal possible number of processes that must be preempted so that the resulting WFG is acyclic. Report your answer as a single integer. No rounding is required and no units are needed. The final answer must be a single real-valued number.",
            "solution": "The problem provides a snapshot of a system with multiple processes and single-instance resources and asks for the minimum number of processes to preempt to resolve all deadlocks. The problem is scientifically grounded, well-posed, and objective, based on standard principles of operating systems and graph theory. Therefore, it is a valid problem.\n\nThe solution proceeds in three steps:\n1.  Construct the Wait-For Graph (WFG) from the given process holdings and requests.\n2.  Identify all directed cycles in the WFG, as cycles indicate the presence of deadlocks.\n3.  Determine the minimum set of vertices (processes) whose removal breaks all cycles. This is equivalent to finding the minimum feedback vertex set of the WFG.\n\n**Step 1: Construct the Wait-For Graph (WFG)**\n\nThe vertices of the WFG are the set of processes $V = \\{P_1, P_2, P_3, P_4, P_5, P_6, P_7\\}$.\nA directed edge $P_i \\to P_j$ exists if process $P_i$ is requesting a resource held by process $P_j$. We analyze the given requests to determine the edge set $E$ of the graph.\n\n-   Process $P_1$ requests $\\{R_1\\}$. Resource $R_1$ is held by $P_2$. This creates an edge $P_1 \\to P_2$.\n-   Process $P_2$ requests $\\{R_2, R_5\\}$. Resource $R_2$ is held by $P_3$, and $R_5$ is held by $P_5$. This creates edges $P_2 \\to P_3$ and $P_2 \\to P_5$.\n-   Process $P_3$ requests $\\{R_3, R_4\\}$. Resource $R_3$ is held by $P_1$, and $R_4$ is held by $P_4$. This creates edges $P_3 \\to P_1$ and $P_3 \\to P_4$.\n-   Process $P_4$ requests $\\{R_5, R_8\\}$. Resource $R_5$ is held by $P_5$, and $R_8$ is held by $P_7$. This creates edges $P_4 \\to P_5$ and $P_4 \\to P_7$.\n-   Process $P_5$ requests $\\{R_2, R_6\\}$. Resource $R_2$ is held by $P_3$, and $R_6$ is held by $P_6$. This creates edges $P_5 \\to P_3$ and $P_5 \\to P_6$.\n-   Process $P_6$ requests $\\{R_1\\}$. Resource $R_1$ is held by $P_2$. This creates an edge $P_6 \\to P_2$.\n-   Process $P_7$ requests $\\{R_4\\}$. Resource $R_4$ is held by $P_4$. This creates an edge $P_7 \\to P_4$.\n\nThe complete set of edges in the WFG is:\n$E = \\{ (P_1, P_2), (P_2, P_3), (P_2, P_5), (P_3, P_1), (P_3, P_4), (P_4, P_5), (P_4, P_7), (P_5, P_3), (P_5, P_6), (P_6, P_2), (P_7, P_4) \\}$.\n\n**Step 2: Identify Directed Cycles**\n\nA deadlock exists if and only if there is at least one directed cycle in the WFG. By inspection of the graph defined by $V$ and $E$, we can identify the following fundamental cycles:\n\n1.  $C_1: P_1 \\to P_2 \\to P_3 \\to P_1$. This cycle involves processes $\\{P_1, P_2, P_3\\}$.\n2.  $C_2: P_2 \\to P_5 \\to P_3 \\to P_1 \\to P_2$. This cycle involves processes $\\{P_1, P_2, P_3, P_5\\}$.\n3.  $C_3: P_2 \\to P_5 \\to P_6 \\to P_2$. This cycle involves processes $\\{P_2, P_5, P_6\\}$.\n4.  $C_4: P_4 \\to P_7 \\to P_4$. This cycle involves processes $\\{P_4, P_7\\}$.\n5.  $C_5: P_3 \\to P_4 \\to P_5 \\to P_3$. This cycle involves processes $\\{P_3, P_4, P_5\\}$.\n\nSince there are multiple cycles, the system is in a state of deadlock. All $7$ processes are part of at least one cycle.\n\n**Step 3: Determine the Minimum Number of Preemptions**\n\nTo recover from deadlock, we must preempt a set of processes (victims) such that their removal from the WFG eliminates all directed cycles. This is the Minimum Feedback Vertex Set problem. For a graph of this size, we can determine the minimum number by direct analysis.\n\nFirst, we check if preempting a single process is sufficient.\n-   Preempting $P_1$: Breaks cycles $C_1$ and $C_2$. Cycles $C_3$, $C_4$, and $C_5$ remain.\n-   Preempting $P_2$: Breaks cycles $C_1$, $C_2$, and $C_3$. Cycles $C_4$ and $C_5$ remain.\n-   Preempting $P_3$: Breaks cycles $C_1$, $C_2$, and $C_5$. Cycles $C_3$ and $C_4$ remain.\n-   Preempting $P_4$: Breaks cycles $C_4$ and $C_5$. Cycles $C_1$, $C_2$, and $C_3$ remain.\n-   Preempting $P_5$: Breaks cycles $C_2$, $C_3$, and $C_5$. Cycles $C_1$ and $C_4$ remain.\n-   Preempting $P_6$: Breaks only cycle $C_3$.\n-   Preempting $P_7$: Breaks only cycle $C_4$.\n\nSince no single preemption can break all cycles, the minimum number of victims must be greater than $1$.\n\nNext, we check if preempting two processes is sufficient. We need to find a pair of processes $\\{P_i, P_j\\}$ that together are part of every cycle.\nLet's analyze the cycles each process participates in:\n-   $P_1$: in $\\{C_1, C_2\\}$\n-   $P_2$: in $\\{C_1, C_2, C_3\\}$\n-   $P_3$: in $\\{C_1, C_2, C_5\\}$\n-   $P_4$: in $\\{C_4, C_5\\}$\n-   $P_5$: in $\\{C_2, C_3, C_5\\}$\n-   $P_6$: in $\\{C_3\\}$\n-   $P_7$: in $\\{C_4\\}$\n\nConsider the set of victims $\\{P_2, P_4\\}$.\n-   Preempting $P_2$ breaks cycles $C_1$, $C_2$, and $C_3$.\n-   The remaining cycles to be broken are $C_4$ and $C_5$.\n-   Preempting $P_4$ breaks both cycles $C_4$ and $C_5$.\n\nThus, preempting the set of processes $\\{P_2, P_4\\}$ is sufficient to break all cycles in the WFG.\nSince $1$ preemption is insufficient and $2$ are sufficient, the minimal possible number of processes that must be preempted is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "The abstract principles of deadlock detection find powerful application in real-world systems like databases. This exercise  delves into the nuances of deadlock detection within a database that uses two-phase locking, with both shared ($S$) and exclusive ($X$) locks. You will explore how seemingly simple requests, such as upgrading a lock from shared to exclusive, can create a specific type of 'conversion deadlock' and how policies like oldest-first priority can be implemented to resolve them.",
            "id": "3632180",
            "problem": "In a database system using Two-Phase Locking (2PL), consider a snapshot of the lock table with transactions $T_1, T_2, T_3, T_4, T_5, T_6$ and resources $R_a, R_b, R_c$. Locks can be Shared ($S$) or Exclusive ($X$), and a transaction can request an upgrade from $S$ to $X$ on a resource it already holds in $S$. A request waits if and only if it conflicts with currently held locks according to the standard lock compatibility for $S$ and $X$: $S$ is compatible with $S$, and $X$ is incompatible with both $S$ and $X$. The snapshot is the following.\n\n- On resource $R_a$: current holders are $T_1$ with $S$ and $T_2$ with $S$. The pending queue is, in order, $T_1$ requesting an upgrade from $S$ to $X$, then $T_3$ requesting a fresh $X$ lock.\n- On resource $R_b$: current holders are $T_3$ with $S$. The pending queue is, in order, $T_2$ requesting $X$, then $T_4$ requesting $X$.\n- On resource $R_c$: current holders are $T_4$ with $S$ and $T_5$ with $S$. The pending queue is, in order, $T_4$ requesting an upgrade from $S$ to $X$, then $T_5$ requesting an upgrade from $S$ to $X$, then $T_6$ requesting a fresh $X$ lock.\n\nAssume that no transaction is in its shrinking phase, i.e., no held lock will be released until commit or abort as per Two-Phase Locking (2PL). Let the transaction start times be $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$, where smaller $s(\\cdot)$ means older.\n\nTask:\n1. Using the definition of a Wait-For Graph (WFG), where a directed edge $T_i \\to T_j$ exists if and only if transaction $T_i$ is currently blocked by a lock held by transaction $T_j$, construct the WFG for the snapshot above. In this construction, consider only conflicts with currently held locks (not queued but ungranted requests), and include upgrade requests as conflicts with any other transaction currently holding incompatible locks on the same resource.\n2. Run a simple deadlock detector that identifies deadlocks by finding directed cycles via strongly connected components (a strongly connected component of size at least $2$ indicates a cycle and hence a deadlock in the WFG under 2PL).\n3. Now, reason from first principles why lock upgrade requests can induce phantom cycles in the WFG when multiple transactions simultaneously hold $S$ on a resource and both request $X$ upgrades. Propose an improvement to avoid such phantom cycles that remains compatible with 2PL. Specifically, adopt an oldest-first upgrade ordering on a single resource based on the start times $s(T_i)$: for simultaneous $S \\to X$ upgrade requests on one resource, direct any wait-for relation from the younger upgrader toward the older upgrader and eliminate the reverse edge between those upgraders when the only mutual conflict arises from their shared locks on that same resource.\n4. Apply the improvement in part $3$ to the snapshot above and recompute the count of strongly connected components of the WFG that have size at least $2$.\n\nExpress your final answer as the integer count from part $4$. No rounding is needed. The final answer must be a single real-valued number.",
            "solution": "The problem requires the analysis of a database system snapshot for deadlocks, first using a standard Wait-For Graph (WFG) construction and then using a modified construction rule designed to handle lock upgrade requests.\n\nFirst, the givens are validated. The problem provides a set of transactions $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$, a set of resources $\\{R_a, R_b, R_c\\}$, the state of held locks and pending requests for each resource, and the start times $s(T_i)$ for each transaction. The rules for lock compatibility ($S$ with $S$; $X$ with none), WFG edge creation, and a specific improvement for handling upgrade deadlocks are all explicitly defined. The problem is scientifically grounded in database concurrency control theory, well-posed, objective, and internally consistent. It is therefore deemed a valid problem.\n\nThe transaction start times are given as: $s(T_1)=10$, $s(T_2)=20$, $s(T_3)=15$, $s(T_4)=40$, $s(T_5)=35$, $s(T_6)=50$. The age ordering of transactions, from oldest to youngest, is therefore: $T_1  T_3  T_2  T_5  T_4  T_6$.\n\n### Part 1: Construction of the Initial Wait-For Graph (WFG)\n\nA directed edge $T_i \\to T_j$ is added to the WFG if transaction $T_i$ requests a lock that conflicts with a lock currently held by transaction $T_j$. We analyze the conflicts for each resource based on the provided snapshot.\n\n**Resource $R_a$**:\n- Current state: $T_1$ holds $S$, $T_2$ holds $S$.\n- Pending requests:\n    1. $T_1$ requests an upgrade from $S$ to $X$. This request conflicts with the $S$ lock held by $T_2$. An $X$ lock is incompatible with an $S$ lock. Thus, $T_1$ must wait for $T_2$. This creates the edge $T_1 \\to T_2$.\n    2. $T_3$ requests an $X$ lock. This request conflicts with the $S$ locks held by both $T_1$ and $T_2$. Thus, $T_3$ must wait for both $T_1$ and $T_2$. This creates the edges $T_3 \\to T_1$ and $T_3 \\to T_2$.\n\n**Resource $R_b$**:\n- Current state: $T_3$ holds $S$.\n- Pending requests:\n    1. $T_2$ requests an $X$ lock. This conflicts with the $S$ lock held by $T_3$. Thus, $T_2$ waits for $T_3$. This creates the edge $T_2 \\to T_3$.\n    2. $T_4$ requests an $X$ lock. This also conflicts with the $S$ lock held by $T_3$. Thus, $T_4$ waits for $T_3$. This creates the edge $T_4 \\to T_3$.\n\n**Resource $R_c$**:\n- Current state: $T_4$ holds $S$, $T_5$ holds $S$.\n- Pending requests:\n    1. $T_4$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_5$. Thus, $T_4$ waits for $T_5$, creating the edge $T_4 \\to T_5$.\n    2. $T_5$ requests an upgrade from $S$ to $X$. This conflicts with the $S$ lock held by $T_4$. Thus, $T_5$ waits for $T_4$, creating the edge $T_5 \\to T_4$.\n    3. $T_6$ requests an $X$ lock. This conflicts with the $S$ locks held by both $T_4$ and $T_5$. Thus, $T_6$ waits for both $T_4$ and $T_5$. This creates the edges $T_6 \\to T_4$ and $T_6 \\to T_5$.\n\nThe complete set of edges in the initial WFG is:\n$E = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_5, T_4), (T_6, T_4), (T_6, T_5) \\}$.\n\n### Part 2: Deadlock Detection in the Initial WFG\n\nA deadlock is indicated by a cycle in the WFG, which corresponds to a strongly connected component (SCC) of size at least $2$. We inspect the graph for such cycles.\n\n- **Cycle 1**: $T_1 \\to T_2 \\to T_3 \\to T_1$. The edge $T_1 \\to T_2$ is from the conflict on $R_a$. The edge $T_2 \\to T_3$ is from $R_b$. The edge $T_3 \\to T_1$ is from $R_a$. This forms a cycle involving three transactions. The set $\\{T_1, T_2, T_3\\}$ is an SCC of size $3$.\n- **Cycle 2**: $T_4 \\to T_5 \\to T_4$. Both edges arise from the simultaneous upgrade requests on resource $R_c$. This is a classic conversion deadlock. The set $\\{T_4, T_5\\}$ is an SCC of size $2$.\n\nThus, in the initial WFG, there are two deadlocks.\n\n### Part 3: Rationale for Phantom Cycles and the Proposed Improvement\n\nThe problem refers to \"phantom cycles\" induced by lock upgrades. This term describes the situation on resource $R_c$, where two transactions, $T_4$ and $T_5$, both hold an $S$ lock and subsequently both request an $X$ lock upgrade. $T_4$'s upgrade request is blocked by $T_5$'s held $S$ lock (creating edge $T_4 \\to T_5$), and symmetrically, $T_5$'s upgrade request is blocked by $T_4$'s held $S$ lock (creating edge $T_5 \\to T_4$). This results in a cycle $T_4 \\leftrightarrow T_5$. This is a genuine deadlock state, but it is sometimes called a \"resolvable\" deadlock because it has a special structure that can be broken by a deterministic policy in the lock manager, unlike more complex deadlocks spanning multiple resources.\n\nThe proposed improvement is one such policy: an `oldest-first` upgrade ordering. For simultaneous upgrade requests on a single resource, the wait relationship is not symmetric. Instead, priority is given to the oldest transaction. The rule states that the wait-for edge should be directed from the younger upgrader to the older one, and the reverse edge is eliminated. This breaks the symmetry and prevents the cycle from forming in the WFG.\n\n### Part 4: Application of the Improvement and Final Count\n\nWe apply the `oldest-first` rule to the snapshot. The only place this rule is applicable is on resource $R_c$, where both $T_4$ and $T_5$ request upgrades.\n- The start times are $s(T_4) = 40$ and $s(T_5) = 35$.\n- $T_5$ is older than $T_4$.\n- According to the rule, the younger transaction ($T_4$) must wait for the older one ($T_5$). This establishes the edge $T_4 \\to T_5$.\n- The reverse edge, $T_5 \\to T_4$, which would represent the older transaction waiting for the younger one, is eliminated.\n\nAll other wait-for relationships remain as they were in Part 1. The new, improved WFG has the following set of edges:\n$E' = \\{ (T_1, T_2), (T_3, T_1), (T_3, T_2), (T_2, T_3), (T_4, T_3), (T_4, T_5), (T_6, T_4), (T_6, T_5) \\}$.\nThis is the original set $E$ with the edge $(T_5, T_4)$ removed.\n\nNow we find the SCCs of size $\\ge 2$ in this modified graph:\n- The cycle $T_1 \\to T_2 \\to T_3 \\to T_1$ is entirely unaffected by the change, as it involves different transactions and resources. Therefore, $\\{T_1, T_2, T_3\\}$ remains an SCC of size $3$. This corresponds to one deadlock.\n- The cycle $T_4 \\to T_5 \\to T_4$ has been broken by the removal of the edge $T_5 \\to T_4$. There is now only a path from $T_4$ to $T_5$, but no path from $T_5$ back to $T_4$. The nodes $\\{T_4, T_5, T_6\\}$ do not form or belong to any other cycles. The subgraph induced by these nodes is a directed acyclic graph (DAG).\n- Therefore, the only SCC with size $\\ge 2$ in the modified WFG is $\\{T_1, T_2, T_3\\}$.\n\nThe number of strongly connected components of size at least $2$ in the improved WFG is $1$.",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}