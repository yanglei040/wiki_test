{
    "hands_on_practices": [
        {
            "introduction": "在掌握了基本的安全状态检查后，让我们来深入探讨安全序列本身。这个练习  不仅要求你判断一个状态是否安全，还要求你找出所有可能的安全序列。通过这个过程，你会更深刻地理解，系统的安全性并不依赖于某个特定的执行顺序，而是取决于是否存在至少一条能让所有进程顺利完成的路径。",
            "id": "3678785",
            "problem": "考虑一个系统，其中有 $n=3$ 个进程，分别标记为 $P_0$、$P_1$ 和 $P_2$，以及 $m=1$ 种可重用资源类型。当前快照显示有 $Available=1$ 个空闲实例，当前的 $Allocation$ 向量为 $[1,0,0]$，分别对应于进程 $P_0$、$P_1$、$P_2$，以及 $Max$ 向量为 $[2,1,1]$，表示每个进程声明的最大需求。假设在标准设置下，当一个进程完成时，它会立即释放其持有的所有实例，并且一个状态是安全的当且仅当存在一个所有进程的排序，使得每个进程都能从当前可用的资源加上先前已完成进程将释放的资源中，获得其剩余所需的实例。\n定义 $S$ 为在标准安全检查下，从给定快照出发可行的不同安全序列（所有3个进程的完整排序）的数量。接下来，对于每个 $i \\in \\{0,1,2\\}$，考虑一个来自进程 $P_i$ 的大小为1的假设性立即单实例请求（在此快照中，每个此类请求都在进程的剩余需求范围内）。令 $U$ 为满足“立即批准该请求（并相应更新快照）将使系统进入不安全状态”的索引 $i$ 的数量。\n计算单个整数 $S - U$。以不带单位的整数形式表示您的最终答案。无需四舍五入。",
            "solution": "为了解决这个问题，我们需要分步计算 $S$（安全序列的数量）和 $U$（导致不安全状态的请求数量）。\n\n### 第1步：计算初始状态的 $Need$ 向量\n\n每个进程还需要的资源数量由 $Need$ 向量给出，其中 $Need_i = Max_i - Allocation_i$。\n- $Need_0 = Max_0 - Allocation_0 = 2 - 1 = 1$\n- $Need_1 = Max_1 - Allocation_1 = 1 - 0 = 1$\n- $Need_2 = Max_2 - Allocation_2 = 1 - 0 = 1$\n所以，$Need$ 向量是 $[1, 1, 1]$。\n\n### 第2步：计算 $S$，即安全序列的数量\n\n我们使用安全算法来检查初始状态。\n- 初始工作向量 $Work = Available = 1$。\n- 我们寻找一个进程 $P_i$，其 $Need_i \\le Work$。\n- 检查 $P_0$：$Need_0 = 1 \\le Work = 1$。可以执行。\n- 检查 $P_1$：$Need_1 = 1 \\le Work = 1$。可以执行。\n- 检查 $P_2$：$Need_2 = 1 \\le Work = 1$。可以执行。\n由于所有三个进程都可以作为序列的第一个进程，我们分别探讨。\n\n1.  **以 $P_0$ 开始**：$P_0$ 执行后，释放其资源。$Work = Work + Allocation_0 = 1 + 1 = 2$。剩下的进程是 $P_1$ 和 $P_2$。它们的需求都是1，小于 $Work=2$。所以它们可以按任意顺序执行。这产生了2个序列：$\\langle P_0, P_1, P_2 \\rangle$ 和 $\\langle P_0, P_2, P_1 \\rangle$。\n2.  **以 $P_1$ 开始**：$P_1$ 执行后，释放其资源。$Work = Work + Allocation_1 = 1 + 0 = 1$。剩下的进程是 $P_0$ 和 $P_2$。它们的需求都是1，等于 $Work=1$。所以它们可以按任意顺序执行。这产生了2个序列：$\\langle P_1, P_0, P_2 \\rangle$ 和 $\\langle P_1, P_2, P_0 \\rangle$。\n3.  **以 $P_2$ 开始**：情况与以 $P_1$ 开始对称。$P_2$ 执行后，$Work = Work + Allocation_2 = 1 + 0 = 1$。剩下的 $P_0$ 和 $P_1$ 可以按任意顺序执行。这产生了2个序列：$\\langle P_2, P_0, P_1 \\rangle$ 和 $\\langle P_2, P_1, P_0 \\rangle$。\n\n总共有 $2 + 2 + 2 = 6$ 个不同的安全序列。因此，$S = 6$。\n\n### 第3步：计算 $U$，即导致不安全状态的请求数量\n\n我们需要逐一检查每个进程请求1个实例的情况。\n- **情况1：$P_0$ 请求1个实例。**\n    - 合法性检查：$Request_0 = 1 \\le Need_0 = 1$ 且 $Request_0 = 1 \\le Available = 1$。请求合法。\n    - 模拟分配：$Available' = 1 - 1 = 0$，$Allocation_0' = 1 + 1 = 2$，$Need_0' = 1 - 1 = 0$。\n    - 新状态：$Available' = 0$，$Allocation' = [2, 0, 0]$，$Need' = [0, 1, 1]$。\n    - 安全检查：$Work = 0$。只有 $P_0$ 的 $Need_0' = 0$ 可以执行。执行后，$Work = 0 + Allocation_0' = 2$。剩下的 $P_1$ 和 $P_2$ 需求都是1，小于 $Work=2$，可以完成。因此，状态是**安全**的。\n- **情况2：$P_1$ 请求1个实例。**\n    - 合法性检查：$Request_1 = 1 \\le Need_1 = 1$ 且 $Request_1 = 1 \\le Available = 1$。请求合法。\n    - 模拟分配：$Available' = 1 - 1 = 0$，$Allocation_1' = 0 + 1 = 1$，$Need_1' = 1 - 1 = 0$。\n    - 新状态：$Available' = 0$，$Allocation' = [1, 1, 0]$，$Need' = [1, 0, 1]$。\n    - 安全检查：$Work = 0$。只有 $P_1$ 的 $Need_1' = 0$ 可以执行。执行后，$Work = 0 + Allocation_1' = 1$。剩下的 $P_0$ 和 $P_2$ 需求都是1，等于 $Work=1$，可以完成。因此，状态是**安全**的。\n- **情况3：$P_2$ 请求1个实例。**\n    - 与情况2对称，模拟分配后的状态将是安全的。\n\n由于所有三种可能的请求都不会导致不安全状态，所以满足条件的索引数量为0。因此，$U = 0$。\n\n### 第4步：最终计算\n\n$S - U = 6 - 0 = 6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "最后的这个练习将我们从单纯的状态分析，带入到更具实践意义的资源管理问题中。在这里，你不再是简单地判断一个状态是否安全，而是要去计算需要增加多少资源才能使一个不安全的系统转变为安全状态 。这个练习突显了可用资源向量 $Available$ 在安全决策中的关键作用，并展示了银行家算法如何为资源容量规划提供理论依据。",
            "id": "3678749",
            "problem": "一个操作系统正在管理 $m=2$ 种不同的资源类型，表示为 $R_1$ 和 $R_2$。有 $n=3$ 个独立进程 $P_0$、$P_1$ 和 $P_2$。系统范围内的资源总量为 $R_1^{\\text{tot}}=100$ 和 $R_2^{\\text{tot}}=3$。系统的当前状态由每个进程当前的“已分配”向量和其声明的“最大需求”向量指定，以有序对 $(R_1,R_2)$ 的形式给出：\n- $P_0$：已分配 $(10,1)$，最大需求 $(20,3)$。\n- $P_1$：已分配 $(15,1)$，最大需求 $(25,3)$。\n- $P_2$：已分配 $(5,1)$，最大需求 $(15,3)$。\n\n不存在其他进程。假设您唯一可以做的改变是将 $R_2$ 的总量增加一个整数 $\\Delta \\ge 0$（使得 $R_2^{\\text{tot}}$ 变为 $3+\\Delta$），而已分配和最大需求不变。目标是利用资源分配系统中安全状态的标准概念：如果存在某个进程完成序列，使得序列中的每个进程都能在轮到它时从可用资源中获取其剩余所需资源，并在完成后释放其已分配的资源，从而可能使下一个进程得以执行，直到所有进程都完成，则该状态是安全的。\n\n确定最小整数 $\\Delta$，使得仅将 $R_2^{\\text{tot}}$ 增加 $\\Delta$ 后，所得状态是安全的。将 $\\Delta$ 的值报告为单个整数。无需四舍五入。",
            "solution": "为了找到能使系统进入安全状态的最小整数 $\\Delta$，我们需要应用银行家算法。\n\n### 第1步：形式化系统状态\n\n- **进程**：$P_0, P_1, P_2$ ($n=3$)\n- **资源**：$R_1, R_2$ ($m=2$)\n- **总资源**：$E = (100, 3+\\Delta)$\n\n- **已分配矩阵 ($A$)**：\n$$ A = \\begin{pmatrix} 10 & 1 \\\\ 15 & 1 \\\\ 5 & 1 \\end{pmatrix} $$\n\n- **最大需求矩阵 ($M$)**：\n$$ M = \\begin{pmatrix} 20 & 3 \\\\ 25 & 3 \\\\ 15 & 3 \\end{pmatrix} $$\n\n### 第2步：计算 $Need$ 矩阵和 $Available$ 向量\n\n- **需求矩阵 ($N$)**：$N_i = M_i - A_i$\n    - $N_0 = (20, 3) - (10, 1) = (10, 2)$\n    - $N_1 = (25, 3) - (15, 1) = (10, 2)$\n    - $N_2 = (15, 3) - (5, 1) = (10, 2)$\n$$ N = \\begin{pmatrix} 10 & 2 \\\\ 10 & 2 \\\\ 10 & 2 \\end{pmatrix} $$\n\n- **可用向量 ($Available$ 或 $V$)**：\n    - 已分配资源总量 = $(10+15+5, 1+1+1) = (30, 3)$。\n    - $Available = \\text{总资源} - \\text{已分配资源总量} = (100, 3+\\Delta) - (30, 3) = (70, \\Delta)$。\n\n### 第3步：应用安全算法确定最小 $\\Delta$\n\n安全算法要求我们找到一个进程序列，使得每个进程的需求都能被满足。\n1.  初始工作向量 $Work = Available = (70, \\Delta)$。\n2.  为了让系统安全，必须存在至少一个进程 $P_i$ 能够开始执行，这意味着它的需求 $Need_i$ 必须小于或等于 $Work$。\n3.  对于系统中的所有进程 $i \\in \\{0, 1, 2\\}$，它们的需求都是 $N_i = (10, 2)$。\n4.  因此，我们必须满足条件 $N_i \\le Work$，即 $(10, 2) \\le (70, \\Delta)$。\n5.  这个向量比较可以分解为两个独立的条件：\n    - $10 \\le 70$ (该条件始终为真)\n    - $2 \\le \\Delta$\n6.  要使任何一个进程能够开始执行，$\\Delta$ 必须至少为2。如果 $\\Delta  2$（例如 $\\Delta=0$ 或 $\\Delta=1$），那么 $Available$ 向量的第二个分量将小于所有进程对 $R_2$ 的需求（2），导致没有进程可以启动，系统立即处于不安全状态。\n7.  因此，$\\Delta$ 的最小可能整数值为2。\n\n### 第4步：验证当 $\\Delta=2$ 时系统是否安全\n\n- 设 $\\Delta = 2$，则 $Available = (70, 2)$。\n- 初始工作向量 $Work = (70, 2)$。\n- 我们可以选择任何一个进程开始，例如 $P_0$，因为 $N_0 = (10, 2) \\le Work = (70, 2)$。\n- $P_0$ 执行完毕后释放资源，更新 $Work$：\n  $Work = Work + A_0 = (70, 2) + (10, 1) = (80, 3)$。\n- 接下来，我们可以选择 $P_1$，因为 $N_1 = (10, 2) \\le Work = (80, 3)$。\n- $P_1$ 执行完毕后，更新 $Work$：\n  $Work = Work + A_1 = (80, 3) + (15, 1) = (95, 4)$。\n- 最后，执行 $P_2$，因为 $N_2 = (10, 2) \\le Work = (95, 4)$。\n- 由于我们找到了一个安全序列（例如 $\\langle P_0, P_1, P_2 \\rangle$），系统在 $\\Delta=2$ 时是安全的。\n\n因此，使系统安全的最小整数 $\\Delta$ 是2。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}