{
    "hands_on_practices": [
        {
            "introduction": "在实时系统中，确保任务能够在截止日期前完成至关重要，但这不应以饿死低优先级任务为代价。本练习将引导你通过计算处理器利用率来分析饥饿现象，这是一个核心的调度概念。你将确定一个临界条件，在该条件下，高优先级任务的需求恰好耗尽所有处理器资源，从而导致低优先级后台线程无限期阻塞。",
            "id": "3649175",
            "problem": "考虑一个使用固定优先级、完全抢占式调度的单处理器操作系统。三个独立的实时任务，表示为 $\\tau_1$、$\\tau_2$ 和 $\\tau_3$，其优先级严格高于一个背景维护线程 $M$，而 $M$ 的优先级最低。每个任务 $\\tau_i$ 都是周期性的，其到达间隔时间（周期）为 $T_i$，最坏情况执行时间为 $C_i$。假设所有任务在时间 $t=0$ 时同步释放，截止时间等于周期，没有输入或输出阻塞，也没有自挂起；任何时候只要有更高优先级的任务就绪，它就会抢占任何更低优先级的任务。\n\n背景线程 $M$ 的无限期阻塞（饿死）意味着 $M$ 在一个无界的时间间隔内得不到任何处理器时间。仅根据处理器容量和工作保持型抢占式调度的基本定义，分析由更高优先级任务产生的总处理器需求。然后，确定临界值 $T_3^{\\star}$，使得当 $T_3 \\leq T_3^{\\star}$ 时，背景线程 $M$ 可能会无限期饿死，而当 $T_3 > T_3^{\\star}$ 时，背景线程 $M$ 必然会无限多次地获得一些处理器时间。\n\n任务参数如下：\n- $\\tau_1$：$C_1 = 2 \\,\\mathrm{ms}$，$T_1 = 5 \\,\\mathrm{ms}$，\n- $\\tau_2$：$C_2 = 1.5 \\,\\mathrm{ms}$，$T_2 = 4 \\,\\mathrm{ms}$，\n- $\\tau_3$：$C_3 = 1 \\,\\mathrm{ms}$，$T_3$ 未知。\n\n根据更高优先级任务的总处理器需求刚好等于处理器容量这一要求，计算 $T_3^{\\star}$。将 $T_3^{\\star}$ 的最终数值答案四舍五入到四位有效数字，并以毫秒为单位表示。",
            "solution": "问题要求确定实时任务 $\\tau_3$ 的临界周期 $T_3^{\\star}$，该周期标志着低优先级背景线程 $M$ 无限期饿死的边界。该系统在单处理器上运行，采用固定优先级、抢占式调度。\n\n主导此问题的基本原理是处理器利用率。对于单个处理器，总可用处理能力被归一化为 $1$。一组周期性任务只有在它们的总利用率小于或等于 $1$ 的情况下，才能在不使处理器过载的情况下被调度。\n\n一个周期性任务 $\\tau_i$（其最坏情况执行时间为 $C_i$，周期为 $T_i$）的利用率 $U_i$ 被定义为它在长期运行中消耗的处理器时间的分数：\n$$ U_i = \\frac{C_i}{T_i} $$\n背景线程 $M$ 具有最低的优先级。根据工作保持型抢占式调度规则，$M$ 只有在没有更高优先级的任务（$\\tau_1, \\tau_2, \\tau_3$）准备运行时，才会被分配处理器时间。如果在任何无界的时间间隔内，处理器被更高优先级的任务完全消耗，$M$ 就会发生无限期饿死。如果总处理器需求，即任务 $\\tau_1, \\tau_2$ 和 $\\tau_3$ 的利用率之和，等于或大于总处理器容量，则此条件成立。\n\n设 $U_{total}$ 为更高优先级任务的总利用率：\n$$ U_{total} = U_1 + U_2 + U_3 = \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3} $$\n$M$ 无限期饿死的条件是 $U_{total} \\geq 1$。相反，如果 $U_{total}  1$，就会有空闲的处理器容量，这些容量将被分配给 $M$，从而防止饿死。\n\n问题要求解临界值 $T_3^{\\star}$，使得当 $T_3 \\leq T_3^{\\star}$ 时，可能发生饿死。这个临界边界对应于总处理器需求恰好等于处理器容量的情况。因此，我们将总利用率设为 $1$：\n$$ \\frac{C_1}{T_1} + \\frac{C_2}{T_2} + \\frac{C_3}{T_3^{\\star}} = 1 $$\n我们可以解这个方程来求 $T_3^{\\star}$。首先，我们分离出包含 $T_3^{\\star}$ 的项：\n$$ \\frac{C_3}{T_3^{\\star}} = 1 - \\left( \\frac{C_1}{T_1} + \\frac{C_2}{T_2} \\right) $$\n然后，我们求解 $T_3^{\\star}$：\n$$ T_3^{\\star} = \\frac{C_3}{1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2}} $$\n这个表达式有效的条件是分母为正，即 $1 - \\frac{C_1}{T_1} - \\frac{C_2}{T_2}  0$。\n\n现在，我们代入给定的任务参数：\n- $\\tau_1$：$C_1 = 2 \\,\\mathrm{ms}$，$T_1 = 5 \\,\\mathrm{ms}$\n- $\\tau_2$：$C_2 = 1.5 \\,\\mathrm{ms}$，$T_2 = 4 \\,\\mathrm{ms}$\n- $\\tau_3$：$C_3 = 1 \\,\\mathrm{ms}$\n\n首先，我们计算 $\\tau_1$ 和 $\\tau_2$ 的利用率：\n$$ U_1 = \\frac{C_1}{T_1} = \\frac{2}{5} = 0.4 $$\n$$ U_2 = \\frac{C_2}{T_2} = \\frac{1.5}{4} = \\frac{3/2}{4} = \\frac{3}{8} = 0.375 $$\n这些利用率的和是：\n$$ U_1 + U_2 = 0.4 + 0.375 = 0.775 $$\n在达到饱和之前，可供任务 $\\tau_3$ 使用的剩余处理器容量为 $1 - 0.775 = 0.225$。当任务 $\\tau_3$ 的利用率恰好为这个值时，达到临界条件：\n$$ U_3^{\\star} = \\frac{C_3}{T_3^{\\star}} = 0.225 $$\n代入 $C_3 = 1 \\,\\mathrm{ms}$：\n$$ \\frac{1}{T_3^{\\star}} = 0.225 $$\n求解 $T_3^{\\star}$：\n$$ T_3^{\\star} = \\frac{1}{0.225} = \\frac{1}{225/1000} = \\frac{1000}{225} $$\n将分子和分母同除以它们的最大公约数 $25$ 来化简分数：\n$$ T_3^{\\star} = \\frac{1000 \\div 25}{225 \\div 25} = \\frac{40}{9} \\,\\mathrm{ms} $$\n其小数值为 $T_3^{\\star} = 4.4444... \\,\\mathrm{ms}$。问题要求将最终答案四舍五入到四位有效数字。\n$$ T_3^{\\star} \\approx 4.444 \\,\\mathrm{ms} $$\n如果 $T_3$ 小于或等于此值，高优先级任务的总利用率将大于或等于 $1$，不会为背景线程 $M$ 留下任何处理器时间。如果 $T_3$ 大于此值，总利用率将小于 $1$，从而保证 $M$ 能获得一些处理器时间。",
            "answer": "$$ \\boxed{4.444} $$"
        },
        {
            "introduction": "并非所有饥饿都是确定性的；有时，它源于“坏运气”的累积，即使在看似公平的调度策略下也是如此。本练习探讨了这种情况，即调度器在等待的线程中进行随机选择。你将推导出一个精确的数学表达式，来量化一个特定线程在给定时间预算内被持续“忽略”的概率，从而加深对随机性与公平性之间微妙关系的理解。",
            "id": "3649142",
            "problem": "一个共享互斥锁（mutex）保护一个系统中的单个临界区，该系统有 $N$ 个并发线程可能等待获取该锁。当互斥锁被释放时，调度器从当前等待线程集合中均匀随机地选择下一个获取者，并且这些选择在连续的释放事件中是相互独立的。考虑一个指定的等待线程，记为 $W$，它在被选中之前一直留在等待集合中，被选中后永久离开。系统通过在每次选择后立即接纳一个新到达的线程来将等待集合的大小维持在 $N$，从而使集合大小始终保持为 $N$。\n\n在操作系统的意义上，当一个线程在有效的时间预算内未被调度以获取共享资源时，就会发生无限期阻塞（也称为饿死）。对于本问题，将 $W$ 的饿死定义为 $W$ 在 $T$ 次连续的互斥锁交接中未被选中，其中 $T$ 是一个固定的正整数，代表以释放事件为单位衡量的时间预算。\n\n仅从上述核心定义（选择的独立性、均匀随机选择以及饿死定义为超过时间预算）出发，推导 $W$ 在此预算下经历饿死的概率的精确封闭形式表达式。将你的最终答案表示为一个仅含 $N$ 和 $T$ 的简化解析表达式。无需进行数值计算，也不涉及单位。",
            "solution": "互斥锁的交接定义了一系列独立的选择事件。在每次交接中，指定线程 $W$ 被选中的概率是 $p = \\frac{1}{N}$，因为调度器从 $N$ 个等待者中均匀随机地选择，并且 $W$ 在被选中之前一直是该集合的成员。因此，在某一次交接中 $W$ 未被选中的概率是 $1 - p = 1 - \\frac{1}{N}$。\n\n设 $X$ 为 $W$ 首次被选中前的交接次数。在独立性和恒定成功概率 $p$ 的假设下，这些试验构成了一系列成功概率为 $p$ 的独立伯努利事件，等待时间 $X$ 服从参数为 $p$ 的几何分布。$W$ 在预算下饿死的事件对应于 $X  T$，即 $W$ 在前 $T$ 次交接中均未被选中。\n\n因为选择事件是独立的，所以 $W$ 在第一次交接中未被选中的概率是 $1 - \\frac{1}{N}$，每次后续交接也是如此。因此，$W$ 在前 $T$ 次交接中均未被选中的概率是 $T$ 个相同概率的乘积：\n$$\n\\Pr(X  T) = \\left(1 - \\frac{1}{N}\\right)^{T}.\n$$\n根据所述的饿死定义（在 $T$ 次交接内未被选中），$\\Pr(X  T)$ 正是 $W$ 在给定预算下的饿死概率。因此，所求的表达式为\n$$\n\\left(1 - \\frac{1}{N}\\right)^{T}.\n$$\n这个封闭形式仅依赖于 $N$ 和 $T$，符合要求。为了完整起见，请注意，当 $T \\to \\infty$ 时，该概率的极限为 $0$，这反映了在无限时间范围内，尽管由于不幸的抽签可能发生有限时间范围内的饿死，但在独立均匀随机选择下，无限期阻塞的概率为零。",
            "answer": "$$\\boxed{\\left(1 - \\frac{1}{N}\\right)^{T}}$$"
        },
        {
            "introduction": "理解饥饿的原因后，下一步是设计能够主动防止饥饿的机制。“老化”是一种经典技术，它通过动态提升等待线程的优先级来实现。在这个实践中，你将扮演系统设计者的角色，不仅要提出一个优先级老化方案，还要通过严谨的数学推导，计算出保证最低优先级线程最终能获得服务的最小老化速率。",
            "id": "3649191",
            "problem": "一个操作系统在单个中央处理器（CPU）上使用抢占式的、基于优先级的调度器，其时间片长度固定，为 $\\Delta$。每个线程 $i$ 都有一个基础优先级 $b_{i} \\in (0,1)$ 和一个有效优先级 $p_{i}(t)$。有效优先级在每个时间片结束时更新，以防止无限期阻塞（饥饿）。你需要形式化一个优先级衰减机制，该机制需避免振荡的优先级动态，同时保证在存在较高基础优先级的线程时，较低基础优先级的线程不会发生饥饿。\n\n从核心定义出发——饥饿是服务的无限期延迟，老化是等待时有效优先级的单调增加——按以下步骤进行：\n\n- 提出一个具有单一速率参数 $\\lambda0$ 的连续时间衰减函数 $d(t)$，它将经过的时间 $t$ 映射为作用于 $p_{i}(t)$ 与 $b_{i}$ 之间距离的乘性衰减因子，以使得在每个时间片结束时所引发的离散时间更新是单调且非振荡的。\n\n- 给定你提出的 $d(t)$，假设每个时间片的更新规则为\n$$\np_{i}^{+} \\;=\\; d(\\Delta)\\,p_{i} \\;+\\; \\bigl(1-d(\\Delta)\\bigr)\\,b_{i} \\;+\\; \\mu\\,\\Delta\\,\\mathbf{1}\\{\\text{线程 $i$ 在该时间片内等待}\\},\n$$\n其中 $\\mu0$ 是一个恒定的老化速率，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。调度器在每个时间片开始时总是运行有效优先级最高的线程，并任意解决优先级相同的情况。\n\n- 考虑恰好两个线程，$H$ 和 $L$，其基础优先级为 $b_{H}$ 和 $b_{L}$，满足 $b_{H}b_{L}$。初始时 $p_{H}(0)=b_{H}$ 且 $p_{L}(0)=b_{L}$。分析 $L$ 的最坏情况调度，即只要 $p_{H}\\ge p_{L}$，$H$ 就会持续运行。仅使用上述定义和第一性原理的线性时不变推理，推导出一个关于 $b_{H},b_{L},\\lambda$ 和 $\\Delta$ 的闭式表达式，用于表示能保证 $L$ 不会饥饿的最小老化速率 $\\mu_{\\min}$。\n\n你的最终答案必须是 $\\mu_{\\min}$ 的单个闭式解析表达式。不要四舍五入。无需单位。",
            "solution": "该问题被认为是有效的，因为它在操作系统理论方面有科学依据，是适定的、客观的，并包含足够的信息以获得唯一解。我们开始推导。\n\n问题要求我们形式化一个优先级更新机制以防止饥饿。这包括三个主要步骤：提出一个合适的衰减函数，为双线程场景建立系统动态，以及推导最小老化速率 $\\mu_{\\min}$ 以保证低优先级线程不会饥饿。\n\n首先，我们必须提出一个具有单一速率参数 $\\lambda  0$ 的连续时间衰减函数 $d(t)$。在没有老化的情况下，优先级 $p_{i}$ 的更新规则是 $p_{i}^{+} = d(\\Delta)p_{i} + (1-d(\\Delta))b_{i}$，其中 $p_i$ 是当前优先级，$p_i^+$ 是经过一个时长为 $\\Delta$ 的时间片后的优先级。这可以重写为 $p_{i}^{+} - b_{i} = d(\\Delta)(p_{i} - b_{i})$，表明有效优先级与基础优先级的偏差在每个时间步长内以因子 $d(\\Delta)$ 衰减。此离散一阶过程的连续时间模拟是一阶线性常微分方程：\n$$ \\frac{d}{dt} \\left( p_{i}(t) - b_{i} \\right) = -\\lambda \\left( p_{i}(t) - b_{i} \\right) $$\n其中 $\\lambda0$ 是衰减率。该方程的解为：\n$$ p_{i}(t) - b_{i} = (p_{i}(0) - b_{i}) \\exp(-\\lambda t) $$\n这描述了优先级偏差在时间间隔 $t$ 内的演化。施加于偏差随时间 $t$ 演化的乘性衰减因子显然是 $\\exp(-\\lambda t)$。因此，最自然和最合适的衰减函数选择是：\n$$ d(t) = \\exp(-\\lambda t) $$\n该函数具有单一速率参数 $\\lambda  0$。对于一个时间片 $\\Delta$ 上的离散更新，该因子为 $d(\\Delta) = \\exp(-\\lambda\\Delta)$。由于 $\\lambda  0$ 且 $\\Delta  0$，我们有 $0  \\exp(-\\lambda\\Delta)  1$。在线性递推关系中，此范围内的特征根可确保单调、非振荡的收敛，满足问题要求。为方便表示，我们定义常数 $\\gamma = d(\\Delta) = \\exp(-\\lambda\\Delta)$。\n\n接下来，我们分析低优先级线程 $L$ 的最坏情况。我们有两个线程，$H$（高基础优先级）和 $L$（低基础优先级），且 $b_{H}  b_{L}$。初始条件为 $p_{H}(0) = b_{H}$ 和 $p_{L}(0) = b_{L}$。令 $p_{H,k}$ 和 $p_{L,k}$ 分别表示在第 $k$ 个时间片结束时（即时间 $t=k\\Delta$）线程 $H$ 和 $L$ 的有效优先级。初始状态为 $p_{H,0} = b_{H}$ 和 $p_{L,0} = b_{L}$。\n\n在第一个时间片开始时（$k=0$），我们有 $p_{H,0}  p_{L,0}$，因此调度器运行线程 $H$。对 $L$ 而言的最坏情况是，只要 $H$ 的优先级大于或等于 $L$ 的优先级，即对于所有后续步骤 $k$ 都有 $p_{H,k} \\ge p_{L,k}$，$H$ 就会持续运行。在此假设下，对于每个时间片 $k+1$（从 $t=k\\Delta$到 $t=(k+1)\\Delta$），线程 $H$ 运行，线程 $L$ 等待。\n\n每个时间片结束时的优先级更新规则如下：\n对于运行的线程 $H$：\n$p_{H,k+1} = \\gamma p_{H,k} + (1-\\gamma)b_{H} + \\mu \\Delta \\cdot 0 = \\gamma p_{H,k} + (1-\\gamma)b_{H}$\n对于等待的线程 $L$：\n$p_{L,k+1} = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu \\Delta \\cdot 1 = \\gamma p_{L,k} + (1-\\gamma)b_{L} + \\mu\\Delta$\n\n我们现在求解这两个线性递推关系。\n对于线程 $H$，初始条件是 $p_{H,0}=b_{H}$。对于 $k=0$：\n$p_{H,1} = \\gamma p_{H,0} + (1-\\gamma)b_{H} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$。\n通过归纳法，如果 $p_{H,k}=b_{H}$，则 $p_{H,k+1} = \\gamma b_{H} + (1-\\gamma)b_{H} = b_{H}$。因此，只要 $H$ 持续运行，其优先级保持不变：\n$$ p_{H,k} = b_{H} \\quad \\text{for all } k \\ge 0 $$\n\n对于线程 $L$，我们有递推关系 $p_{L,k+1} = \\gamma p_{L,k} + C$，其中 $C = (1-\\gamma)b_{L} + \\mu\\Delta$。这是一个标准的一阶非齐次递推关系。其解由一个齐次部分和一个特解组成。不动点（特解）$p_{L}^*$ 满足 $p_{L}^* = \\gamma p_{L}^* + C$，这给出 $p_{L}^* = \\frac{C}{1-\\gamma}$。\n$$ p_{L}^* = \\frac{(1-\\gamma)b_{L} + \\mu\\Delta}{1-\\gamma} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\n通解的形式为 $p_{L,k} = A\\gamma^k + p_{L}^*$，其中 $A$ 是由初始条件 $p_{L,0}=b_{L}$ 决定的常数。\n$p_{L,0} = A\\gamma^0 + p_{L}^* = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}$。\n$b_{L} = A + b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} \\implies A = - \\frac{\\mu\\Delta}{1-\\gamma}$。\n因此，$p_{L,k}$ 的闭式解为：\n$$ p_{L,k} = \\left(b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}\\right) - \\left(\\frac{\\mu\\Delta}{1-\\gamma}\\right)\\gamma^k = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}(1-\\gamma^k) $$\n\n如果线程 $L$ 被无限期推迟，就会发生饥饿。在我们的模型中，这意味着对于所有 $k \\ge 0$ 都有 $p_{L,k} \\le p_{H,k}$。为保证 $L$ 不会饥饿，其优先级最终必须超过 $H$ 的优先级。由于 $p_{L,k}$ 是 $k$ 的单调递增函数（因为 $0  \\gamma  1$），如果它一旦超过 $p_{H,k}=b_H$，那么只要老化项持续作用，它就会超过并保持在 $b_H$ 之上。保证不发生饥饿的条件是 $p_{L,k}$ 的渐近极限必须严格大于 $b_H$。\n$$ \\lim_{k\\to\\infty} p_{L,k}  b_{H} $$\n当 $k \\to \\infty$ 时，因为 $0  \\gamma  1$，所以 $\\gamma^k \\to 0$。因此，极限为：\n$$ \\lim_{k\\to\\infty} p_{L,k} = b_{L} + \\frac{\\mu\\Delta}{1-\\gamma} $$\n防止饥饿的条件变为：\n$$ b_{L} + \\frac{\\mu\\Delta}{1-\\gamma}  b_{H} $$\n我们对这个不等式求解 $\\mu$：\n$$ \\frac{\\mu\\Delta}{1-\\gamma}  b_{H} - b_{L} $$\n$$ \\mu  \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\n最小老化速率 $\\mu_{\\min}$ 是满足此条件的所有 $\\mu$ 值集合的下确界，它对应于该不等式的边界。\n$$ \\mu_{\\min} = \\frac{(1-\\gamma)(b_{H} - b_{L})}{\\Delta} $$\n最后，我们代回 $\\gamma = \\exp(-\\lambda\\Delta)$:\n$$ \\mu_{\\min} = \\frac{(1 - \\exp(-\\lambda\\Delta))(b_{H} - b_{L})}{\\Delta} $$\n如果将 $\\mu$ 设置为此值，$p_{L,k}$ 将从下方渐近地趋近于 $b_H$，在有限时间内永远不会达到它。因此，任何 $\\mu  \\mu_{\\min}$ 都将保证 $p_{L,k}$ 在有限步数后超过 $b_H$，从而防止饥饿。问题要求的是能建立这一保证的最小速率 $\\mu_{\\min}$。",
            "answer": "$$\\boxed{\\frac{\\left(1 - \\exp(-\\lambda\\Delta)\\right)\\left(b_{H} - b_{L}\\right)}{\\Delta}}$$"
        }
    ]
}