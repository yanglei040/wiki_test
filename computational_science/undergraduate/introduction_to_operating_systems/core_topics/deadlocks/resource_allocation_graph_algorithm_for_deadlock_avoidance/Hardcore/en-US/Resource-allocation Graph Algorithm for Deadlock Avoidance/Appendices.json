{
    "hands_on_practices": [
        {
            "introduction": "Understanding deadlock avoidance begins with a clear picture of how deadlocks form in the first place. This exercise guides you through a step-by-step simulation of a system with several processes and resources. By tracking the state of the Resource-Allocation Graph over time, you will identify the precise moment a deadlock-inducing cycle emerges, providing a foundational understanding of the problem we aim to solve .",
            "id": "3677751",
            "problem": "An Operating System (OS) maintains a Resource-Allocation Graph (RAG) with processes and resources as nodes. A process $P_i$ is drawn as a circle and a resource $R_j$ as a square. A directed edge $P_i \\rightarrow R_j$ is a request edge indicating that process $P_i$ is waiting for resource $R_j$. A directed edge $R_j \\rightarrow P_i$ is an assignment edge indicating that resource $R_j$ is currently allocated to process $P_i$. A claim edge $P_i \\rightarrow R_j$ indicates that process $P_i$ may request $R_j$ in the future; claim edges exist before a request is issued and are converted into request edges when the process actually requests the resource. If a request is granted and the resource is free, the request edge is converted into an assignment edge; if the resource is not free, the request edge remains. When a process releases a resource, the assignment edge $R_j \\rightarrow P_i$ is removed and the corresponding claim edge $P_i \\rightarrow R_j$ is restored. In a system where each resource type has exactly one instance, the existence of a directed cycle among request and assignment edges is both necessary and sufficient for deadlock.\n\nConsider three processes $P_1, P_2, P_3$ and two resources $R_a, R_b$, each with exactly one instance. The initial claim edges at time $t=0$ are:\n- $P_1 \\rightarrow R_a$, $P_1 \\rightarrow R_b$,\n- $P_2 \\rightarrow R_a$, $P_2 \\rightarrow R_b$,\n- $P_3 \\rightarrow R_b$.\n\nThe system then evolves in discrete time slots $t=1,2,3,\\dots$ according to the following events. At each time $t$, the OS immediately grants the request if the resource is free; otherwise, the request edge is added and remains until the resource becomes free. No deadlock-avoidance decision is applied.\n\n- At $t=1$, $P_1$ issues a request for $R_a$.\n- At $t=2$, $P_2$ issues a request for $R_b$.\n- At $t=3$, $P_1$ issues a request for $R_b$.\n- At $t=4$, $P_2$ issues a request for $R_a$.\n- At $t=5$, $P_3$ issues a request for $R_b$.\n\nAssume no releases occur in $t \\in \\{1,2,3,4,5\\}$. By convention for this problem, when determining whether a cycle exists, consider only request and assignment edges and ignore claim edges.\n\nUsing only the fundamental definitions above and the given event schedule, determine the smallest positive integer $t^\\*$ at which the graph of request and assignment edges first contains a directed cycle. Report $t^\\*$ as an exact integer with no units. No rounding is required.",
            "solution": "The problem requires us to determine the smallest positive integer time, denoted as $t^\\*$, at which a directed cycle first appears in the Resource-Allocation Graph (RAG) for a given system of processes and resources. The RAG consists of process nodes $\\{P_1, P_2, P_3\\}$, resource nodes $\\{R_a, R_b\\}$, and two types of directed edges relevant for cycle detection: request edges ($P_i \\rightarrow R_j$) and assignment edges ($R_j \\rightarrow P_i$). According to the problem statement, for resources with a single instance each, the existence of such a cycle is a necessary and sufficient condition for deadlock. We will trace the evolution of the RAG step-by-step according to the specified event schedule.\n\nLet the set of request and assignment edges in the graph at time $t$ be denoted by $E_t$.\n\n**Initial State at $t=0$:**\nThe system begins with three processes, $P_1, P_2, P_3$, and two single-instance resources, $R_a$ and $R_b$. Both resources are initially free and available. There are no active requests or allocations.\n- Edge set: $E_0 = \\emptyset$.\n- The graph contains no edges, and thus, no cycles.\n\n**Time step $t=1$:**\n- **Event:** Process $P_1$ issues a request for resource $R_a$.\n- **Analysis:** At this time, resource $R_a$ is free. According to the rules, the OS grants the request immediately. This action converts the transient request edge into a permanent assignment edge.\n- **State Update:** An assignment edge $R_a \\rightarrow P_1$ is added to the graph. Resource $R_a$ is now allocated to $P_1$.\n- **Edge Set:** $E_1 = \\{R_a \\rightarrow P_1\\}$.\n- **Cycle Check:** The graph contains a single edge. No directed cycle can be formed.\n\n**Time step $t=2$:**\n- **Event:** Process $P_2$ issues a request for resource $R_b$.\n- **Analysis:** Resource $R_b$ is free. The request is granted immediately.\n- **State Update:** An assignment edge $R_b \\rightarrow P_2$ is added to the graph. Resource $R_b$ is now allocated to $P_2$.\n- **Edge Set:** $E_2 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2\\}$.\n- **Cycle Check:** The graph consists of two disjoint paths of length $1$. No directed cycle exists.\n\n**Time step $t=3$:**\n- **Event:** Process $P_1$ issues a request for resource $R_b$.\n- **Analysis:** Resource $R_b$ is not free; it is currently allocated to process $P_2$ (as indicated by the edge $R_b \\rightarrow P_2$). The request cannot be granted.\n- **State Update:** A request edge $P_1 \\rightarrow R_b$ is added to the graph, indicating that $P_1$ is now waiting for $R_b$.\n- **Edge Set:** $E_3 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2, P_1 \\rightarrow R_b\\}$.\n- **Cycle Check:** We can trace a path from the existing assignment edge $R_a \\rightarrow P_1$ to the new request edge $P_1 \\rightarrow R_b$, and then to the other assignment edge $R_b \\rightarrow P_2$. This forms a directed path $R_a \\rightarrow P_1 \\rightarrow R_b \\rightarrow P_2$. There is no edge leading from $P_2$ back to any node already in this path. Therefore, no directed cycle exists.\n\n**Time step $t=4$:**\n- **Event:** Process $P_2$ issues a request for resource $R_a$.\n- **Analysis:** Resource $R_a$ is not free; it is currently allocated to process $P_1$ (as indicated by the edge $R_a \\rightarrow P_1$). The request cannot be granted.\n- **State Update:** A request edge $P_2 \\rightarrow R_a$ is added to the graph, indicating that $P_2$ is now waiting for $R_a$.\n- **Edge Set:** $E_4 = \\{R_a \\rightarrow P_1, R_b \\rightarrow P_2, P_1 \\rightarrow R_b, P_2 \\rightarrow R_a\\}$.\n- **Cycle Check:** Let us examine the paths in the graph.\n  1. Process $P_1$ is waiting for resource $R_b$: this is the edge $P_1 \\rightarrow R_b$.\n  2. Resource $R_b$ is held by process $P_2$: this is the edge $R_b \\rightarrow P_2$.\n  3. Process $P_2$ is waiting for resource $R_a$: this is the new edge $P_2 \\rightarrow R_a$.\n  4. Resource $R_a$ is held by process $P_1$: this is the edge $R_a \\rightarrow P_1$.\nCombining these edges, we can construct the following sequence of nodes and edges: $P_1 \\rightarrow R_b \\rightarrow P_2 \\rightarrow R_a \\rightarrow P_1$. This sequence forms a closed loop, which is a directed cycle in the RAG. This cycle involves processes $P_1$ and $P_2$ and resources $R_a$ and $R_b$. Specifically, $P_1$ holds $R_a$ and requests $R_b$, while $P_2$ holds $R_b$ and requests $R_a$, a classic deadlock condition.\n\nSince a directed cycle first appears at $t=4$, this is the value we are seeking. The analysis can be terminated here as the question asks for the smallest such positive integer.\n\nThe smallest positive integer $t^\\*$ at which the graph of request and assignment edges first contains a directed cycle is $4$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "The core of the Resource-Allocation Graph algorithm is its simple but powerful rule: deny any request that would create a cycle. This practice challenges you to apply this rule in a complex scenario where the system is on the verge of deadlock. You will act as the operating system, evaluating several potential resource requests to determine which can be safely granted and which must be denied to maintain system stability .",
            "id": "3677767",
            "problem": "You are testing the Resource-Allocation Graph (RAG) algorithm for deadlock avoidance in the case where each resource type has a single instance. Consider a system with processes $P_1, P_2, P_3, P_4, P_5$ and resources $R_1, R_2, R_3, R_4, R_5$, each resource having exactly one instance. The current graph has the following assignment edges (resource to process) and request edges (process to resource):\n- Assignment edges: $R_1 \\to P_2$, $R_2 \\to P_3$, $R_3 \\to P_4$, $R_4 \\to P_5$, $R_5 \\to P_1$.\n- Request edges: $P_1 \\to R_1$, $P_2 \\to R_2$, $P_3 \\to R_3$, $P_4 \\to R_4$.\n\nThere are claim edges for the following potential requests that may be issued next (i.e., these are the only additional request edges that can be added): $P_5 \\to R_5$, $P_3 \\to R_5$, $P_5 \\to R_2$, $P_2 \\to R_4$, $P_4 \\to R_1$. No other claim edges exist beyond those already realized as the listed request edges.\n\nObserve that the current graph contains a simple path of length $L = 8$ edges:\n$$\nP_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5,\n$$\nwhich is not yet a cycle but would become a cycle if augmented with a suitable additional edge.\n\nUnder the deadlock-avoidance rule for the Resource-Allocation Graph algorithm (i.e., deny any request whose addition would create a cycle in the graph), determine how many of the listed pending requests must be denied because their addition would extend an existing path into a cycle. Express your final answer as the integer $D$. No rounding is needed.",
            "solution": "The problem requires us to analyze a set of potential resource requests and determine, for each, whether granting it would create a cycle in the resource-allocation graph. In a system where each resource type has only one instance, the RAG algorithm for deadlock avoidance dictates that a request by process $P_i$ for resource $R_j$, represented by a request edge $P_i \\to R_j$, can be granted only if adding this edge to the graph does not create a cycle. A cycle would be formed if there is already an existing path from $R_j$ to $P_i$.\n\nFirst, let's represent the current state of the system graph, composed of processes $P_k$, resources $R_k$, and the existing edges.\n\nThe set of processes is $\\mathcal{P} = \\{P_1, P_2, P_3, P_4, P_5\\}$.\nThe set of resources is $\\mathcal{R} = \\{R_1, R_2, R_3, R_4, R_5\\}$.\n\nThe current edges in the graph are:\n1.  **Assignment Edges** (resource held by process):\n    - $R_1 \\to P_2$ ($P_2$ holds $R_1$)\n    - $R_2 \\to P_3$ ($P_3$ holds $R_2$)\n    - $R_3 \\to P_4$ ($P_4$ holds $R_3$)\n    - $R_4 \\to P_5$ ($P_5$ holds $R_4$)\n    - $R_5 \\to P_1$ ($P_1$ holds $R_5$)\n2.  **Request Edges** (process waiting for resource):\n    - $P_1 \\to R_1$ ($P_1$ wants $R_1$)\n    - $P_2 \\to R_2$ ($P_2$ wants $R_2$)\n    - $P_3 \\to R_3$ ($P_3$ wants $R_3$)\n    - $P_4 \\to R_4$ ($P_4$ wants $R_4$)\n\nThe current graph does not contain a cycle. It contains a long path as noted in the problem statement: $P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$.\n\nWe must now evaluate each of the five potential requests to see if adding it would close a cycle.\n\n**1. Request: $P_5 \\to R_5$**\nTo check if this request creates a cycle, we must determine if there is an existing path from resource $R_5$ to process $P_5$.\n- Path from $R_5$: $R_5 \\to P_1$ (assignment)\n- Path from $P_1$: $P_1 \\to R_1$ (request)\n- Path from $R_1$: $R_1 \\to P_2$ (assignment)\n- Path from $P_2$: $P_2 \\to R_2$ (request)\n- Path from $R_2$: $R_2 \\to P_3$ (assignment)\n- Path from $P_3$: $P_3 \\to R_3$ (request)\n- Path from $R_3$: $R_3 \\to P_4$ (assignment)\n- Path from $P_4$: $P_4 \\to R_4$ (request)\n- Path from $R_4$: $R_4 \\to P_5$ (assignment)\nConcatenating these, we find the path: $R_5 \\to P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$.\nSince a path from $R_5$ to $P_5$ exists, adding the edge $P_5 \\to R_5$ would create a cycle.\n**Verdict: Denied.**\n\n**2. Request: $P_3 \\to R_5$**\nWe check for an existing path from $R_5$ to $P_3$.\n- Path from $R_5$: $R_5 \\to P_1$ (assignment)\n- Path from $P_1$: $P_1 \\to R_1$ (request)\n- Path from $R_1$: $R_1 \\to P_2$ (assignment)\n- Path from $P_2$: $P_2 \\to R_2$ (request)\n- Path from $R_2$: $R_2 \\to P_3$ (assignment)\nThe path is $R_5 \\to P_1 \\to R_1 \\to P_2 \\to R_2 \\to P_3$.\nA path from $R_5$ to $P_3$ exists. Adding the edge $P_3 \\to R_5$ would create a cycle.\n**Verdict: Denied.**\n\n**3. Request: $P_5 \\to R_2$**\nWe check for an existing path from $R_2$ to $P_5$.\n- Path from $R_2$: $R_2 \\to P_3$ (assignment)\n- Path from $P_3$: $P_3 \\to R_3$ (request)\n- Path from $R_3$: $R_3 \\to P_4$ (assignment)\n- Path from $P_4$: $P_4 \\to R_4$ (request)\n- Path from $R_4$: $R_4 \\to P_5$ (assignment)\nThe path is $R_2 \\to P_3 \\to R_3 \\to P_4 \\to R_4 \\to P_5$.\nA path from $R_2$ to $P_5$ exists. Adding the edge $P_5 \\to R_2$ would create a cycle.\n**Verdict: Denied.**\n\n**4. Request: $P_2 \\to R_4$**\nWe check for an existing path from $R_4$ to $P_2$.\n- The only outgoing edge from $R_4$ is the assignment edge $R_4 \\to P_5$.\n- From $P_5$, there are no outgoing edges in the current graph (as $P_5$ is not currently requesting any resource).\nTherefore, no path exists from $R_4$ to any other process, including $P_2$. Adding the edge $P_2 \\to R_4$ would not create a cycle.\n**Verdict: Granted.**\n\n**5. Request: $P_4 \\to R_1$**\nWe check for an existing path from $R_1$ to $P_4$.\n- Path from $R_1$: $R_1 \\to P_2$ (assignment)\n- Path from $P_2$: $P_2 \\to R_2$ (request)\n- Path from $R_2$: $R_2 \\to P_3$ (assignment)\n- Path from $P_3$: $P_3 \\to R_3$ (request)\n- Path from $R_3$: $R_3 \\to P_4$ (assignment)\nThe path is $R_1 \\to P_2 \\to R_2 \\to P_3 \\to R_3 \\to P_4$.\nA path from $R_1$ to $P_4$ exists. Adding the edge $P_4 \\to R_1$ would create a cycle.\n**Verdict: Denied.**\n\nIn summary:\n- Request $P_5 \\to R_5$: Denied\n- Request $P_3 \\to R_5$: Denied\n- Request $P_5 \\to R_2$: Denied\n- Request $P_2 \\to R_4$: Granted\n- Request $P_4 \\to R_1$: Denied\n\nThe number of requests that must be denied, $D$, is the count of the \"Denied\" verdicts. We have $4$ such requests.\nThus, $D=4$.",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "How does an operating system actually \"check for a cycle\"? This abstract rule is implemented using concrete graph traversal algorithms. This final exercise bridges theory and practice by having you perform a cycle check using a Depth-First Search (DFS), a standard method for this task. By tracing the DFS algorithm on a Resource-Allocation Graph, you will see exactly how a back-edge signals the formation of a cycle, making the deadlock avoidance mechanism transparent .",
            "id": "3677764",
            "problem": "You are given a directed bipartite graph $G$ that represents a Resource-Allocation Graph (RAG). Process nodes are $\\{P_1, P_2, P_3\\}$ and resource nodes are $\\{R_a, R_b, R_c\\}$. All resources are single-instance. An edge $R_x \\to P_y$ indicates an assignment of resource $R_x$ to process $P_y$, and an edge $P_y \\to R_x$ indicates a request by process $P_y$ for resource $R_x$. The current adjacency lists of $G$ (with neighbor exploration order exactly as listed) are:\n- $P_1: [R_b]$\n- $P_2: [\\,]$\n- $P_3: [R_a]$\n- $R_a: [P_1]$\n- $R_b: [P_2]$\n- $R_c: [P_3]$\n\nA request edge $P_2 \\to R_c$ is proposed. Using Depth-First Search (DFS), where neighbors are explored in the exact order provided and where the color-state method is used to detect cycles (white $=$ unvisited, gray $=$ discovered and in the current recursion stack, black $=$ finished), perform an on-the-fly cycle check starting from $P_2$ immediately after adding the edge $P_2 \\to R_c$. If a back-edge to a gray node is encountered, the system is unsafe under the single-instance assumption and the request must be denied.\n\nDefine $L$ to be the length (number of distinct directed edges) of the first simple directed cycle that is detected by DFS via a back-edge when starting at $P_2$ after adding $P_2 \\to R_c$. Compute $L$. Express your final answer as an integer with no units.",
            "solution": "The problem asks us to simulate a Depth-First Search (DFS) on a Resource-Allocation Graph (RAG) to detect a cycle after a new request edge is added.\n\nFirst, let's establish the full structure of the graph after the proposed change.\nThe set of vertices is $V = \\{P_1, P_2, P_3, R_a, R_b, R_c\\}$.\nThe initial edges, based on the problem's adjacency lists, are:\n- Request edges (Process $\\to$ Resource): $(P_1, R_b)$, $(P_3, R_a)$.\n- Assignment edges (Resource $\\to$ Process): $(R_a, P_1)$, $(R_b, P_2)$, $(R_c, P_3)$.\nA new request edge $(P_2, R_c)$ is added.\nThe complete set of directed edges in the graph $G$ is $E = \\{(P_1, R_b), (P_3, R_a), (R_a, P_1), (R_b, P_2), (R_c, P_3), (P_2, R_c)\\}$.\nThe updated adjacency list for $P_2$ is now $P_2: [R_c]$.\n\nNext, we perform a Depth-First Search (DFS) starting from node $P_2$ to detect a cycle. We will track the color of each node (initially WHITE) and the parent of each node in the DFS tree.\n\n1.  **Initialize**: `color[v] = WHITE` for all $v \\in V$. `parent[v] = NULL` for all $v \\in V$.\n2.  **Start DFS**: Call `DFS-Visit(P_2)`.\n\n**Trace of `DFS-Visit`:**\n\n- **Call `DFS-Visit(P_2)`**:\n    - Set `color[P_2] = GRAY`.\n    - `parent[P_2] = NULL`.\n    - Explore neighbors of $P_2$. The adjacency list is $[R_c]$.\n    - The neighbor is $R_c$. `color[R_c]` is WHITE. This is a tree edge.\n    - Set `parent[R_c] = P_2`.\n    - Recursively call `DFS-Visit(R_c)`.\n\n- **Call `DFS-Visit(R_c)`**:\n    - Set `color[R_c] = GRAY`.\n    - Explore neighbors of $R_c$. The adjacency list is $[P_3]$.\n    - The neighbor is $P_3$. `color[P_3]` is WHITE. This is a tree edge.\n    - Set `parent[P_3] = R_c`.\n    - Recursively call `DFS-Visit(P_3)`.\n\n- **Call `DFS-Visit(P_3)`**:\n    - Set `color[P_3] = GRAY`.\n    - Explore neighbors of $P_3$. The adjacency list is $[R_a]$.\n    - The neighbor is $R_a$. `color[R_a]` is WHITE. This is a tree edge.\n    - Set `parent[R_a] = P_3`.\n    - Recursively call `DFS-Visit(R_a)`.\n\n- **Call `DFS-Visit(R_a)`**:\n    - Set `color[R_a] = GRAY`.\n    - Explore neighbors of $R_a$. The adjacency list is $[P_1]$.\n    - The neighbor is $P_1$. `color[P_1]` is WHITE. This is a tree edge.\n    - Set `parent[P_1] = R_a`.\n    - Recursively call `DFS-Visit(P_1)`.\n\n- **Call `DFS-Visit(P_1)`**:\n    - Set `color[P_1] = GRAY`.\n    - Explore neighbors of $P_1$. The adjacency list is $[R_b]$.\n    - The neighbor is $R_b$. `color[R_b]` is WHITE. This is a tree edge.\n    - Set `parent[R_b] = P_1`.\n    - Recursively call `DFS-Visit(R_b)`.\n\n- **Call `DFS-Visit(R_b)`**:\n    - Set `color[R_b] = GRAY`.\n    - Explore neighbors of $R_b$. The adjacency list is $[P_2]$.\n    - The neighbor is $P_2$. We check its color: `color[P_2]` is GRAY.\n    - Since $P_2$ is a GRAY node (it is in the current recursion stack), the edge $(R_b, P_2)$ is a back-edge. A cycle has been detected. The DFS algorithm terminates its search and reports the cycle.\n\nThe first cycle is detected upon finding the back-edge $(R_b, P_2)$. The cycle consists of this edge plus the path in the DFS tree from the destination node $P_2$ to the source node $R_b$. We can reconstruct this path by tracing the `parent` pointers from $R_b$ back to $P_2$.\n\n- `parent[R_b] = P_1`\n- `parent[P_1] = R_a`\n- `parent[R_a] = P_3`\n- `parent[P_3] = R_c`\n- `parent[R_c] = P_2`\n\nThe path from $P_2$ to $R_b$ is $P_2 \\to R_c \\to P_3 \\to R_a \\to P_1 \\to R_b$.\nAppending the back-edge $(R_b, P_2)$ closes the cycle:\n$P_2 \\to R_c \\to P_3 \\to R_a \\to P_1 \\to R_b \\to P_2$.\n\nThe problem asks for $L$, the length of this cycle, which is the number of distinct directed edges it contains. The edges are:\n1. $(P_2, R_c)$\n2. $(R_c, P_3)$\n3. $(P_3, R_a)$\n4. $(R_a, P_1)$\n5. $(P_1, R_b)$\n6. $(R_b, P_2)$\n\nThere are $6$ edges in this simple directed cycle. Therefore, the length $L$ is $6$.",
            "answer": "$$\\boxed{6}$$"
        }
    ]
}