{
    "hands_on_practices": [
        {
            "introduction": "理论是基础，但真正的理解来自于实践。本练习将指导你手动模拟一个多线程环境中的死锁检测过程。通过追踪一系列锁请求事件，你将亲手构建一个等待图（Wait-For Graph, WFG），并利用它来识别是否存在死锁，这个练习旨在加深你对循环等待条件与等待图中循环之间直接关系的理解 。",
            "id": "3632429",
            "problem": "一个操作系统 (OS) 管理着 $n=6$ 个并发线程 $\\{T_1,T_2,T_3,T_4,T_5,T_6\\}$，它们竞争六个不同的非可重入互斥锁 $\\{\\ell_A,\\ell_B,\\ell_C,\\ell_D,\\ell_E,\\ell_F\\}$，所有锁初始时均为空闲状态。该操作系统使用一种基于等待图 (WFG) 的死锁检测算法。图中存在一条有向边 $T_i \\to T_j$ 当且仅当线程 $T_i$ 正在等待某个由线程 $T_j$ 当前持有的锁。当且仅当WFG包含至少一个有向环时，存在死锁。当一个线程被阻塞时，它会继续持有其之前已获取的所有锁。当一个线程终止时，操作系统会立即释放该线程持有的所有锁。\n\n请按顺序处理以下事件序列。如果请求的锁是空闲的，请求线程将获取它；否则，该线程将阻塞并等待该锁变为可用。\n\n- 事件 $1$：$T_1$ 请求 $\\ell_A$ 并获取 $\\ell_A$。\n- 事件 $2$：$T_2$ 请求 $\\ell_B$ 并获取 $\\ell_B$。\n- 事件 $3$：$T_3$ 请求 $\\ell_C$ 并获取 $\\ell_C$。\n- 事件 $4$：$T_1$ 请求 $\\ell_B$；由于 $\\ell_B$ 被 $T_2$ 持有，$T_1$ 阻塞等待 $\\ell_B$。\n- 事件 $5$：$T_2$ 请求 $\\ell_C$；由于 $\\ell_C$ 被 $T_3$ 持有，$T_2$ 阻塞等待 $\\ell_C$。\n- 事件 $6$：$T_3$ 请求 $\\ell_A$；由于 $\\ell_A$ 被 $T_1$ 持有，$T_3$ 阻塞等待 $\\ell_A$。\n- 事件 $7$：$T_4$ 请求 $\\ell_D$ 并获取 $\\ell_D$。\n- 事件 $8$：$T_5$ 请求 $\\ell_E$ 并获取 $\\ell_E$。\n- 事件 $9$：$T_6$ 请求 $\\ell_F$ 并获取 $\\ell_F$。\n- 事件 $10$：$T_4$ 请求 $\\ell_E$；由于 $\\ell_E$ 被 $T_5$ 持有，$T_4$ 阻塞等待 $\\ell_E$。\n- 事件 $11$：$T_5$ 请求 $\\ell_F$；由于 $\\ell_F$ 被 $T_6$ 持有，$T_5$ 阻塞等待 $\\ell_F$。\n- 事件 $12$：$T_6$ 请求 $\\ell_D$；由于 $\\ell_D$ 被 $T_4$ 持有，$T_6$ 阻塞等待 $\\ell_D$。\n\n处理完事件 $12$ 后，构建由最终状态所蕴含的等待图 (WFG)。确认此时WFG中是否存在特定环路 $C: T_1 \\to T_2 \\to T_3 \\to T_1$。然后，假设终止任何线程都会立即释放其持有的所有锁，并且不会再发生其他事件，计算为确保系统摆脱死锁并能够继续运行而必须终止的最小线程数 $k$。你的最终答案只应提供 $k$ 的值。请给出精确的整数，不要四舍五入。",
            "solution": "问题要求我们分析多线程环境中的一个事件序列，以确定死锁状态以及为解决死锁所需终止的最小线程数。分析过程将首先跟踪锁和线程的状态，然后构建等待图 (WFG)，识别其中的环路，最后确定为使图无环所需移除的最小顶点数。\n\n首先，我们通过给定的 $12$ 个事件序列来追踪系统的状态。系统状态由哪些线程持有哪些锁以及哪些线程正在等待其他线程来定义。\n\n- **初始状态**：所有六个锁 $\\{\\ell_A, \\ell_B, \\ell_C, \\ell_D, \\ell_E, \\ell_F\\}$ 均为空闲。所有六个线程 $\\{T_1, T_2, T_3, T_4, T_5, T_6\\}$ 均为就绪状态。\n\n- **事件 $1-3$**：线程 $T_1$、$T_2$ 和 $T_3$ 分别获取锁 $\\ell_A$、$\\ell_B$ 和 $\\ell_C$。\n  - 事件 $1$ 后：$T_1$ 持有 $\\ell_A$。\n  - 事件 $2$ 后：$T_2$ 持有 $\\ell_B$。\n  - 事件 $3$ 后：$T_3$ 持有 $\\ell_C$。\n\n- **事件 $4-6$**：在 $T_1, T_2, T_3$ 之间建立了一组循环依赖关系。\n  - 事件 $4$：$T_1$ 请求 $\\ell_B$，该锁由 $T_2$ 持有。$T_1$ 阻塞。这建立了一个等待依赖关系：$T_1 \\to T_2$。\n  - 事件 $5$：$T_2$ 请求 $\\ell_C$，该锁由 $T_3$ 持有。$T_2$ 阻塞。这建立了一个等待依赖关系：$T_2 \\to T_3$。\n  - 事件 $6$：$T_3$ 请求 $\\ell_A$，该锁由 $T_1$ 持有。$T_3$ 阻塞。这建立了一个等待依赖关系：$T_3 \\to T_1$。\n\n- **事件 $7-9$**：线程 $T_4$、$T_5$ 和 $T_6$ 分别获取锁 $\\ell_D$、$\\ell_E$ 和 $\\ell_F$。\n  - 事件 $7$ 后：$T_4$ 持有 $\\ell_D$。\n  - 事件 $8$ 后：$T_5$ 持有 $\\ell_E$。\n  - 事件 $9$ 后：$T_6$ 持有 $\\ell_F$。\n\n- **事件 $10-12$**：在 $T_4, T_5, T_6$ 之间建立了第二组循环依赖关系。\n  - 事件 $10$：$T_4$ 请求 $\\ell_E$，该锁由 $T_5$ 持有。$T_4$ 阻塞。这建立了一个等待依赖关系：$T_4 \\to T_5$。\n  - 事件 $11$：$T_5$ 请求 $\\ell_F$，该锁由 $T_6$ 持有。$T_5$ 阻塞。这建立了一个等待依赖关系：$T_5 \\to T_6$。\n  - 事件 $12$：$T_6$ 请求 $\\ell_D$，该锁由 $T_4$ 持有。$T_6$ 阻塞。这建立了一个等待依赖关系：$T_6 \\to T_4$。\n\n处理完所有 $12$ 个事件后，系统状态如下：\n- **持锁者**：\n  - $T_1$ 持有 $\\ell_A$。\n  - $T_2$ 持有 $\\ell_B$。\n  - $T_3$ 持有 $\\ell_C$。\n  - $T_4$ 持有 $\\ell_D$。\n  - $T_5$ 持有 $\\ell_E$。\n  - $T_6$ 持有 $\\ell_F$。\n- **等待线程**：\n  - $T_1$ 正在等待 $\\ell_B$（由 $T_2$ 持有）。\n  - $T_2$ 正在等待 $\\ell_C$（由 $T_3$ 持有）。\n  - $T_3$ 正在等待 $\\ell_A$（由 $T_1$ 持有）。\n  - $T_4$ 正在等待 $\\ell_E$（由 $T_5$ 持有）。\n  - $T_5$ 正在等待 $\\ell_F$（由 $T_6$ 持有）。\n  - $T_6$ 正在等待 $\\ell_D$（由 $T_4$ 持有）。\n\n接下来，我们构建等待图 $G=(V, E)$，其中顶点集 $V$ 是线程集合，如果线程 $T_i$ 正在等待线程 $T_j$ 持有的锁，则存在一条有向边 $(T_i, T_j) \\in E$。\n- 顶点集：$V = \\{T_1, T_2, T_3, T_4, T_5, T_6\\}$。\n- 边集：$E = \\{(T_1, T_2), (T_2, T_3), (T_3, T_1), (T_4, T_5), (T_5, T_6), (T_6, T_4)\\}$。\n\n当且仅当WFG包含至少一个有向环时，存在死锁。我们检查图中的环路。\n边集清晰地定义了两个不同的环路：\n1.  环路 $C_1$：$T_1 \\to T_2 \\to T_3 \\to T_1$。该环路由边 $(T_1, T_2)$、$(T_2, T_3)$ 和 $(T_3, T_1)$ 构成。\n2.  环路 $C_2$：$T_4 \\to T_5 \\to T_6 \\to T_4$。该环路由边 $(T_4, T_5)$、$(T_5, T_6)$ 和 $(T_6, T_4)$ 构成。\n\n问题明确要求确认环路 $C: T_1 \\to T_2 \\to T_3 \\to T_1$ 的存在。根据我们构建的WFG，这个环路是存在的，并且是系统中两个死锁之一。\n\n最后的任务是计算为消除所有死锁而必须终止的最小线程数 $k$。终止一个线程对应于从WFG中移除其对应的顶点。要打破有向图中的所有环路，我们必须找到一个最小反馈顶点集，这是一个最小的顶点集合，移除该集合中的顶点可以使图变为无环图。\n\n在这个问题中，WFG由两个顶点不相交的组件构成，每个组件都是一个简单环。\n- 第一个组件涉及顶点 $\\{T_1, T_2, T_3\\}$ 并形成环路 $C_1$。\n- 第二个组件涉及顶点 $\\{T_4, T_5, T_6\\}$ 并形成环路 $C_2$。\n\n由于这两个环路是顶点不相交的，从一个环路中移除一个顶点不会影响另一个环路。因此，要打破所有环路，我们必须独立地打破每个环路。\n- 要打破环路 $C_1$，我们必须终止集合 $\\{T_1, T_2, T_3\\}$ 中的至少一个线程。所需的最小数量是 $1$。\n- 要打破环路 $C_2$，我们必须终止集合 $\\{T_4, T_5, T_6\\}$ 中的至少一个线程。所需的最小数量是 $1$。\n\n需要终止的最小线程总数 $k$ 是打破每个不相交环路所需的最小数量之和。\n$$k = (\\text{打破 } C_1 \\text{ 所需最小线程数}) + (\\text{打破 } C_2 \\text{ 所需最小线程数}) = 1 + 1 = 2$$\n例如，终止线程 $T_1$ 和 $T_4$ 将是一个可能的最小终止集合。终止 $T_1$ 会释放 $\\ell_A$，从而打破环路 $C_1$。终止 $T_4$ 会释放 $\\ell_D$，从而打破环路 $C_2$。最终的系统将没有死锁。\n\n因此，必须终止的最小线程数是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "当系统中的资源有多个实例时，简单的等待图便不足以描述资源竞争关系。本练习将带你进入一个更普遍的场景，并应用处理多实例资源的经典死锁检测算法。你需要利用给定的资源分配矩阵、请求矩阵和可用资源向量，逐步执行算法，以确定系统中的哪些进程处于死锁状态，这个实践将让你熟练掌握这种更为强大和通用的检测技术 。",
            "id": "3632410",
            "problem": "考虑一个操作系统 (OS)，其中有 $n=6$ 个进程 $\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$ 竞争 $m=4$ 种资源类型 $\\{R_1,R_2,R_3,R_4\\}$，每种资源有多个实例。系统状态由资源分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$、未完成的请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$ 和当前可用实例向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$ 来表征，具体如下所示。每一行对应一个进程 $P_i$，每一列对应一种资源类型 $R_j$。\n\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix},\n\\quad\n\\mathbf{Available} =\n\\begin{pmatrix}\n1  0  1  0\n\\end{pmatrix}.\n$$\n\n使用经典的多实例资源死锁检测算法。该算法迭代地搜索一个未完成的进程 $P_i$，其请求向量 $Request_i$ 满足 $Request_i \\leq Work$（其中 $Work$ 初始化为 $\\mathbf{Available}$）。当找到这样的进程时，就认为 $P_i$ 能够完成并释放其所分配的资源，然后更新 $Work \\leftarrow Work + Allocation_i$。持续此过程直到不存在这样的 $P_i$ 为止；此时仍未完成的进程被认为是不可完成的。\n\n定义量 $S$ 为所有不可完成进程的索引之和，即，如果不可完成进程的集合是 $\\{P_{i_1}, P_{i_2}, \\dots\\}$，则 $S = i_1 + i_2 + \\dots$。请计算 $S$。您的最终答案应为一个精确的整数，无需四舍五入。",
            "solution": "该问题被验证为具有科学依据、问题定义明确且客观。它描述了操作系统中的一个标准场景，并要求应用经典的死锁检测算法。所有必要的数据都已提供，问题没有矛盾或含糊之处。\n\n任务是确定在一个有 $n=6$ 个进程和 $m=4$ 种资源类型的系统中，不可完成进程的集合。系统状态由 $\\mathbf{Allocation}$ 矩阵、$\\mathbf{Request}$ 矩阵和 $\\mathbf{Available}$ 向量给出。\n\n已知条件如下：\n- 进程数量：$n=6$，$\\{P_0,P_1,P_2,P_3,P_4,P_5\\}$。\n- 资源类型数量：$m=4$，$\\{R_1,R_2,R_3,R_4\\}$。\n- 分配矩阵 $\\mathbf{Allocation} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Allocation} =\n\\begin{pmatrix}\n1  0  0  1 \\\\\n0  0  1  0 \\\\\n0  2  0  0 \\\\\n1  0  0  0 \\\\\n0  0  1  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 请求矩阵 $\\mathbf{Request} \\in \\mathbb{Z}^{6 \\times 4}$:\n$$\n\\mathbf{Request} =\n\\begin{pmatrix}\n0  0  1  0 \\\\\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1 \\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n- 可用向量 $\\mathbf{Available} \\in \\mathbb{Z}^{4}$:\n$$\n\\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}\n$$\n\n我们应用死锁检测算法。设 $\\mathbf{Work}$ 是一个长度为 $m$ 的向量，$\\mathbf{Finish}$ 是一个长度为 $n$ 的布尔向量。向量不等式 $\\mathbf{A} \\leq \\mathbf{B}$ 成立当且仅当对于所有分量 $k$ 都有 $A_k \\leq B_k$。\n\n**步骤 1：初始化**\n将 $\\mathbf{Work}$ 初始化为 $\\mathbf{Available}$，并将所有进程 $i = 0, \\dots, 5$ 的 $\\mathbf{Finish}_i$ 初始化为 false。\n$$ \\mathbf{Work} = \\mathbf{Available} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} $$\n$$ \\mathbf{Finish} = \\begin{pmatrix} \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix} $$\n\n**步骤 2：迭代搜索与更新**\n算法的流程是找到一个索引 $i$，满足 $\\mathbf{Finish}_i$ 为 false 并且其请求向量 $\\mathbf{Request}_i \\leq \\mathbf{Work}$。如果找到，该进程理论上可以完成，因此我们通过更新 $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_i$ 并设置 $\\mathbf{Finish}_i \\leftarrow \\text{true}$ 来释放其资源。重复此过程，直到找不到这样的进程为止。\n\n**迭代 1：**\n我们搜索一个进程 $P_i$，满足 $\\mathbf{Finish}_i = \\text{false}$ 且 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$。\n- $P_0$: $\\mathbf{Request}_0 = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} \\leq \\begin{pmatrix} 1  0  1  0 \\end{pmatrix}$。此条件满足。\n我们选择 $P_0$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_0 = \\begin{pmatrix} 1  0  1  0 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_0 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 2：**\n我们搜索一个未完成的进程 $P_i$，其请求 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。\n- $P_1$: $\\mathbf{Request}_1 = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  1  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_1$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_1 = \\begin{pmatrix} 2  0  1  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_1 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{false}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 3：**\n我们搜索一个未完成的进程 $P_i$，其请求 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于第二种资源，有 $1 > 0$。\n- $P_3$: $\\mathbf{Request}_3 = \\begin{pmatrix} 0  0  0  0 \\end{pmatrix} \\leq \\begin{pmatrix} 2  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_3$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_3 = \\begin{pmatrix} 2  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_3 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{false}  \\text{false} \\end{pmatrix}$。\n\n**迭代 4：**\n我们搜索一个未完成的进程 $P_i$，其请求 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。\n- $P_2$: $\\mathbf{Request}_2$ 仍然无法满足。\n- $P_4$: $\\mathbf{Request}_4 = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix} \\leq \\begin{pmatrix} 3  0  2  1 \\end{pmatrix}$。此条件满足。\n我们选择 $P_4$。\n更新 $\\mathbf{Work}$: $\\mathbf{Work} \\leftarrow \\mathbf{Work} + \\mathbf{Allocation}_4 = \\begin{pmatrix} 3  0  2  1 \\end{pmatrix} + \\begin{pmatrix} 0  0  1  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。\n更新 $\\mathbf{Finish}$: $\\mathbf{Finish}_4 \\leftarrow \\text{true}$。\n当前状态为 $\\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$ 且 $\\mathbf{Finish} = \\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$。\n\n**迭代 5：**\n我们搜索一个未完成的进程 $P_i$，其请求 $\\mathbf{Request}_i \\leq \\mathbf{Work} = \\begin{pmatrix} 3  0  3  2 \\end{pmatrix}$。剩余未完成的进程是 $P_2$ 和 $P_5$。\n- $P_2$: $\\mathbf{Request}_2 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，有 $1 > 0$。\n- $P_5$: $\\mathbf{Request}_5 = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}$。这不满足 $\\leq \\mathbf{Work}$，因为对于 $R_2$，有 $1 > 0$。\n\n**步骤 3：终止**\n没有任何剩余的未完成进程的请求能够被当前的 $\\mathbf{Work}$ 向量满足。算法终止。\n\n**步骤 4：识别不可完成的进程并计算 S**\n$\\mathbf{Finish}_i$ 仍然为 false 的进程被认为是不可完成的。从最终的 $\\mathbf{Finish}$ 向量 $\\begin{pmatrix} \\text{true}  \\text{true}  \\text{false}  \\text{true}  \\text{true}  \\text{false} \\end{pmatrix}$，不可完成的进程是 $\\{P_2, P_5\\}$。\n\n问题将 $S$ 定义为所有不可完成进程的索引之和。\n$$ S = 2 + 5 = 7 $$\n死锁的物理原因是 $P_2$ 和 $P_5$ 都在请求资源 $R_2$ 的一个实例。而 $R_2$ 的可用实例为 0，并且没有其他能够完成的进程持有任何 $R_2$ 的实例可以释放。因此，$P_2$ 和 $P_5$ 将无限期地等待下去。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "在真实世界的操作系统中，一个关键挑战是区分真正的、持久的死锁和那些会自行消失的瞬时资源等待。本练习是一个思想实验，旨在探讨一种更符合实际的检测策略，该策略要求一个循环在连续的检测周期中持续存在才被确认为死锁。通过分析这个场景，你将学会批判性地思考死锁检测的时间维度，以及如何设计算法以避免误报，从而提升系统的稳定性和效率 。",
            "id": "3632528",
            "problem": "考虑一个用于操作系统中死锁检测的等待图 (WFG) $G=(V,E)$。在WFG中，每个顶点代表一个进程，一条有向边 $P_i \\rightarrow P_j$ 表示进程 $P_i$ 正在等待进程 $P_j$ 释放资源。一个基本事实是，WFG中的环是循环等待条件在图论上的体现。当边代表实际的阻塞等待时，环意味着环上的所有进程都相互阻塞，因此无法取得进展；这就是死锁条件。\n\n设顶点集为 $V=\\{P_1,P_2,P_3,P_4,P_5,P_6,P_7\\}$，其中 $\\lvert V \\rvert = 7$。构造边集 $E$，使其恰好包含一个有向环，并且环中的一个进程还存在一条到叶子节点（出度为0的顶点）的路径。一种这样的选择是\n$$\nE=\\{(P_1,P_2),(P_2,P_3),(P_3,P_1),(P_2,P_4),(P_3,P_4),(P_5,P_6),(P_6,P_7),(P_6,P_4),(P_1,P_7)\\},\n$$\n其中唯一的环是 $P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$。注意，$P_4$ 和 $P_7$ 是叶子节点（没有出边），而 $P_2$（位于环上）有一条指向叶子节点 $P_4$ 的出边。\n\n假设边的行为具有以下基于时间的特性，这反映了现实的进程执行和资源释放情况：\n- 三条环边 $(P_1,P_2)$、$(P_2,P_3)$、$(P_3,P_1)$ 是阻塞等待，一旦出现，它们将持续至少 $T_c$ 时间。\n- 每条指向叶子节点的边都对应于等待一个将在有限时间内释放其资源的进程完成：用 $\\tau_4$ 表示检测器采样WFG时 $P_4$ 完成所需的剩余时间，用 $\\tau_7$ 表示 $P_7$ 完成所需的剩余时间。因此，等待 $(P_2,P_4)$、$(P_3,P_4)$、$(P_6,P_4)$ 和 $(P_1,P_7)$ 将分别在 $\\tau_4$ 或 $\\tau_7$ 时间内解除。\n- 检测算法以周期 $\\Delta t$ 运行，并采用一种广泛应用的实用策略：仅当在相隔 $\\Delta t$ 的两个连续WFG快照中发现同一个环时，才声明存在死锁。该策略旨在避免对快速消失的瞬时等待做出反应，而专注于持续存在的环。\n\n在这些假设下，以下哪个陈述正确描述了检测器对上述图 $G$ 的报告结果？\n\nA. 如果 $T_c \\ge 2\\Delta t$ 且 $\\tau_4  \\Delta t$、$\\tau_7  \\Delta t$，那么检测器将在两次连续运行后报告一个涉及 $\\{P_1,P_2,P_3\\}$ 的死锁，并且不会将任何指向 $P_4$ 或 $P_7$ 的链误判为死锁，因为在第二次快照前，环持续存在而指向叶子节点的等待已经解除。\n\nB. 如果 $\\Delta t  \\min\\{\\tau_4, \\tau_7\\}$，那么在第二次运行时，检测器会将链 $P_5\\rightarrow P_6\\rightarrow P_7$ 误判为死锁，因为当等待持续时间超过 $\\Delta t$ 时，长度为3的路径足以推断出死锁。\n\nC. 如果 $T_c  \\Delta t$，检测器在两次运行后仍会报告环 $P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$ 为死锁，因为在第一次运行时存在环就足够了，不需要持续存在。\n\nD. 环上顶点到叶子节点的一条额外出边（例如 $P_2 \\rightarrow P_4$）的存在，会阻止检测器将环 $\\{P_1,P_2,P_3\\}$ 报告为死锁，因为在WFG中，非简单环不能构成死锁。",
            "solution": "用户提供了一个关于在操作系统中使用等待图 (WFG) 进行死锁检测的问题。我将首先验证问题陈述，然后进行详细的解答。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n-   图模型：一个等待图 (WFG) $G=(V,E)$，其中顶点是进程，有向边 $P_i \\rightarrow P_j$ 表示 $P_i$ 正在等待 $P_j$。\n-   死锁条件：WFG中的环意味着死锁。\n-   顶点集：$V=\\{P_1,P_2,P_3,P_4,P_5,P_6,P_7\\}$，其中 $\\lvert V \\rvert = 7$。\n-   边集：$E=\\{(P_1,P_2),(P_2,P_3),(P_3,P_1),(P_2,P_4),(P_3,P_4),(P_5,P_6),(P_6,P_7),(P_6,P_4),(P_1,P_7)\\}$。\n-   图结构属性：\n    -   恰好存在一个有向环：$P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$。\n    -   $P_4$ 和 $P_7$ 是叶子节点（出度为0）。\n    -   环中的一个进程 $P_2$ 有一条到叶子节点 $P_4$ 的路径（一条边）。\n-   边的持续行为：\n    -   环边 $(P_1,P_2)$、$(P_2,P_3)$、$(P_3,P_1)$ 持续至少 $T_c$ 时间。\n    -   对叶子节点 $P_4$ 的等待，即边 $(P_2,P_4)$、$(P_3,P_4)$、$(P_6,P_4)$，在 $\\tau_4$ 时间内解除。\n    -   对叶子节点 $P_7$ 的等待，即边 $(P_1,P_7)$ 和 $(P_6,P_7)$，在 $\\tau_7$ 时间内解除。注意：问题文本将 $(P_1,P_7)$ 列为在 $\\tau_7$ 内解除的边的一个例子。边集还包括 $(P_6,P_7)$，它也会在 $\\tau_7$ 时间内解除。\n-   检测算法策略：\n    -   算法以周期 $\\Delta t$ 运行。\n    -   仅当在相隔 $\\Delta t$ 的*两个连续*WFG快照中发现*同一个环*时，它才报告死锁。\n\n**步骤2：使用提取的信息进行验证**\n\n-   **科学基础：** 该问题基于操作系统理论的基本概念。使用等待图 (WFG)（其中环表示死锁）是一种标准模型，尤其适用于单实例资源。持久环与瞬时环的概念是现实世界死锁检测器中的一个实际考虑因素。该模型是科学合理的。\n-   **适定性：** 图被明确定义，死锁条件清晰（一个环），检测策略明确。选项中的问题基于时间参数之间特定的量化关系，使得每种情况下都能得出唯一的结论。该问题是适定的。\n-   **客观性：** 问题以精确的技术语言陈述，没有主观或含糊的术语。\n-   **内部一致性：**\n    -   边集 $E$ 确实包含环 $P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$。\n    -   从其他顶点（如 $P_5 \\rightarrow P_6 \\rightarrow P_7$ 或 $P_5 \\rightarrow P_6 \\rightarrow P_4$）追踪路径，没有发现其他环。唯一环的说法是正确的。\n    -   各顶点的出度为：out-degree($P_1$)$=2$，out-degree($P_2$)$=2$，out-degree($P_3$)$=2$，out-degree($P_4$)$=0$，out-degree($P_5$)$=1$，out-degree($P_6$)$=2$，out-degree($P_7$)$=0$。关于 $P_4$ 和 $P_7$ 是叶子节点的陈述是正确的。\n    -   $P_2$ 在环中，并有一条到叶子节点 $P_4$ 的边 $(P_2,P_4)$。这也是正确的。\n    -   问题陈述内部一致，没有矛盾。\n\n**步骤3：结论与行动**\n\n问题陈述有效。它科学合理、适定、客观且内部一致。我将继续推导解决方案。\n\n### 解答推导\n\n问题的核心是在不同的时间条件下，将给定的死锁检测策略应用于指定的等待图 $G$。该策略规定，当且仅当在相隔时间间隔 $\\Delta t$ 的两个连续快照中检测到*同一个环*时，才报告死锁。\n\n在第一个快照（时间 $t_0$）时，WFG $G$ 恰好包含一个环 $C = P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$。根据策略，当且仅当这个相同的环 $C$ 也存在于第二个快照（时间 $t_0 + \\Delta t$）的WFG中时，才会报告死锁。\n\n一条边 $(P_i, P_j)$ 从时间 $t_0$ 到 $t_0 + \\Delta t$ 的持续性取决于它所代表的等待的性质：\n-   环边 $\\{(P_1,P_2), (P_2,P_3), (P_3,P_1)\\}$ 持续至少 $T_c$ 的时间。如果在 $t_0$ 时它们的剩余生命周期大于 $\\Delta t$，那么它们将在 $t_0 + \\Delta t$ 时仍然存在。由于它们持续*至少* $T_c$ 时间，因此它们在 $t_0 + \\Delta t$ 时存在的充分条件是 $T_c > \\Delta t$。\n-   指向叶子节点 $P_4$ 的边在 $\\tau_4$ 时间内解除。如果 $\\tau_4  \\Delta t$，它们将在 $t_0 + \\Delta t$ 之前消失。\n-   指向叶子节点 $P_7$ 的边在 $\\tau_7$ 时间内解除。如果 $\\tau_7  \\Delta t$，它们将在 $t_0 + \\Delta t$ 之前消失。\n\n现在，我将评估每个选项。\n\n**选项A分析**\n\n-   **陈述：** 如果 $T_c \\ge 2\\Delta t$ 且 $\\tau_4  \\Delta t$、$\\tau_7  \\Delta t$，那么检测器将在两次连续运行后报告一个涉及 $\\{P_1,P_2,P_3\\}$ 的死锁，并且不会将任何指向 $P_4$ 或 $P_7$ 的链误判为死锁，因为在第二次快照前，环持续存在而指向叶子节点的等待已经解除。\n-   **分析：**\n    1.  **环的持续性：** 条件是 $T_c \\ge 2\\Delta t$，这意味着 $T_c > \\Delta t$。环边持续至少 $T_c$ 时间。因此，环 $C = P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$ 保证在第一个快照（时间 $t_0$）和第二个快照（时间 $t_0+\\Delta t$）时都存在。\n    2.  **叶子节点等待的解除：** 条件 $\\tau_4  \\Delta t$ 意味着进程 $P_4$ 保证在第二个快照之前完成。因此，所有指向 $P_4$ 的等待边，即 $(P_2,P_4)$、$(P_3,P_4)$ 和 $(P_6,P_4)$，将在 $t_0+\\Delta t$ 时从WFG中移除。同样，条件 $\\tau_7  \\Delta t$ 意味着进程 $P_7$ 完成，边 $(P_1,P_7)$ 和 $(P_6,P_7)$ 被移除。\n    3.  **检测器的结论：** 在 $t_0$ 时，检测器发现环 $C$。在 $t_0+\\Delta t$ 时，它发现了同一个环 $C$。策略被满足。检测器将报告一个涉及环中进程 $\\{P_1,P_2,P_3\\}$ 的死锁。\n    4.  **误判：** 指向 $P_4$ 和 $P_7$ 的“链”（即路径）不是环。根据定义，基于环的检测器不能将路径分类为死锁。因此，它不会“误判”它们。该陈述是正确的。选项中给出的理由也是合理的。\n-   **结论：** **正确**。\n\n**选项B分析**\n\n-   **陈述：** 如果 $\\Delta t  \\min\\{\\tau_4, \\tau_7\\}$，那么在第二次运行时，检测器会将链 $P_5\\rightarrow P_6\\rightarrow P_7$ 误判为死锁，因为当等待持续时间超过 $\\Delta t$ 时，长度为3的路径足以推断出死锁。\n-   **分析：**\n    1.  在WFG中进行死锁检测的基本原则是需要一个**环**。序列 $P_5\\rightarrow P_6\\rightarrow P_7$ 是一条有向**路径**，而不是一个环，因为没有从 $P_7$ 返回到 $P_5$ 或 $P_6$ 的边。\n    2.  一个通过寻找环来运行的死锁检测算法永远不会将路径识别为死锁。声称它会“将链...误判为死锁”是根本错误的。\n    3.  “长度为3的路径足以推断出死锁”这一理由是错误的。路径的长度无关紧要；只有环的存在才重要。条件 $\\Delta t  \\min\\{\\tau_4, \\tau_7\\}$ 仅确保对 $P_4$ 和 $P_7$ 的等待（以及路径 $P_5\\rightarrow P_6\\rightarrow P_7$）很可能在两次快照之间持续存在，但持续存在并不会将路径变成死锁。\n-   **结论：** **不正确**。\n\n**选项C分析**\n\n-   **陈述：** 如果 $T_c  \\Delta t$，检测器在两次运行后仍会报告环 $P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$ 为死锁，因为在第一次运行时存在环就足够了，不需要持续存在。\n-   **分析：**\n    1.  这个陈述直接与问题陈述中给出的死锁检测策略相矛盾：“仅当在相隔 $\\Delta t$ 的*两个连续*WFG快照中发现*同一个环*时，才声明存在死锁”。\n    2.  该策略明确要求环在 $\\Delta t$ 时间间隔内持续存在。根据问题规则，“在第一次运行时存在环就足够了，不需要持续存在”这一理由在事实上是不正确的。\n    3.  条件 $T_c  \\Delta t$ 使得环可能是瞬时的，并在第二次快照拍摄前解除（甚至很有可能，取决于等待何时开始）。如果环在第二次快照时不存在，检测器将*不会*报告死锁。\n-   **结论：** **不正确**。\n\n**选项D分析**\n\n-   **陈述：** 环上顶点到叶子节点的一条额外出边（例如 $P_2 \\rightarrow P_4$）的存在，会阻止检测器将环 $\\{P_1,P_2,P_3\\}$ 报告为死锁，因为在WFG中，非简单环不能构成死锁。\n-   **分析：**\n    1.  所提供的理由是有缺陷的。一个**简单环**是一条起点和终点相同，且除起点/终点外不包含重复顶点的路径。环 $P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$ *是*一个简单环。外部边 $(P_2, P_4)$ 的存在不改变构成环的子图的属性。边 $(P_2, P_4)$ 本身不是环的一部分。\n    2.  边 $(P_2,P_4)$ 的存在并不会打破死锁。它意味着进程 $P_2$ 处于等待两个不同进程的状态：$P_3$（环所必需的）和 $P_4$。$P_1, P_2, P_3$ 之间的循环等待条件仍然存在。无论是否存在其他等待，它们都相互阻塞。一个环检测器将正确识别环 $P_1 \\rightarrow P_2 \\rightarrow P_3 \\rightarrow P_1$。\n    3.  因此，环中顶点存在一条额外的出边并不会阻止该环被检测为死锁。\n-   **结论：** **不正确**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}