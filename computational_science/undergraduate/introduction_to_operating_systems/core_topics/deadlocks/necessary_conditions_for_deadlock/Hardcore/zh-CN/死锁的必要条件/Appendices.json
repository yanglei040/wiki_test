{
    "hands_on_practices": [
        {
            "introduction": "“持有并等待”是死锁发生的四大必要条件之一。一种理论上彻底的预防方法是破坏这一条件：要求进程在执行前一次性申请其所需的所有资源。本练习  将通过一个假设的场景，让你亲手计算和比较这种“一次性分配”策略与传统的“增量分配”策略在系统性能上的差异，从而深刻理解死锁预防并非没有代价，它往往伴随着资源利用率的牺牲。",
            "id": "3662788",
            "problem": "考虑以下系统，其中进程竞争访问两个不可抢占的互斥设备，表示为 $R_1$ 和 $R_2$。使用设备的进程在其使用期间独占该设备，且设备不可被抢占。操作系统中的死锁经典地定义为：一组进程被永久阻塞，因为该组中的每个进程都在等待一个只能由该组中另一个进程引起的事件。众所周知的死锁四个必要条件是：互斥、占有并等待、不可抢占和循环等待。\n\n该系统强制执行一个禁止“占有并等待”的策略：每个进程必须在执行前声明其将需要的所有设备，并且只有在所有声明的设备都空闲时才被接纳；一旦被接纳，它将持有所有声明的设备直到完成，即使在某些阶段它并未活跃使用其中一些设备。如果在接纳时某个声明的设备不空闲，则该进程在不持有任何设备的情况下等待。\n\n现有 $3$ 个进程 $P_1$、$P_2$ 和 $P_3$，其总运行时间（从接纳到完成）和设备使用区间均相对于各自进程的开始时间给出：\n\n- 进程 $P_1$ 运行 $10$ 个时间单位。它在 $[2,4]$ 和 $[8,9]$ 期间使用 $R_1$，在 $[5,7]$ 期间使用 $R_2$。\n- 进程 $P_2$ 运行 $8$ 个时间单位。它在 $[1,2]$ 期间使用 $R_1$，在 $[6,8]$ 期间使用 $R_2$。\n- 进程 $P_3$ 运行 $6$ 个时间单位。它在 $[2,3]$ 期间使用 $R_2$。\n\n假设所有区间表示连续使用，其长度等于端点之差，并且没有进程同时使用两个设备。在上述禁止“占有并等待”的策略下，$P_1$ 和 $P_2$ 必须声明 $\\{R_1, R_2\\}$，$P_3$ 必须声明 $\\{R_2\\}$。在增量（传统）分配策略下，进程仅在需要时请求和释放设备，并且可能在等待另一设备时持有一个设备，同样受到不可抢占和互斥的约束。\n\n选择所有正确选项：\n\nA. 在该系统中消除“占有并等待”破坏了死锁的一个必要条件；因此，无论请求模式如何，死锁都不会发生。\n\nB. 对于给定的工作负载，两个设备的总繁忙时间固定为 $9$ 个时间单位。在禁止“占有并等待”的策略下，完工时间为 $24$ 个时间单位，产生的双设备利用率为 $3/16$。存在一个可行的增量调度，其完工时间为 $12$，产生的双设备利用率为 $3/8$。\n\nC. 因为在禁止“占有并等待”的策略下资源被预先保留，所以相对于增量分配，吞吐量严格增加；因此设备被更充分地利用。\n\nD. 在禁止“占有并等待”的策略下，进程饥饿是不可能发生的，因为等待的进程不持有任何设备。",
            "solution": "我们从标准的基本原理开始：操作系统中的死锁需要以下必要条件（Coffman 条件）同时存在：互斥、占有并等待、不可抢占和循环等待。如果这些条件中的任何一个不满足，死锁就不会发生。\n\n在给定的策略下，“占有并等待”被明确禁止：一个进程要么 (i) 被接纳并从开始到完成持有所有声明的设备，要么 (ii) 在不持有任何设备的情况下等待，直到所有声明的设备同时变为空闲。这意味着持有设备的进程不会等待更多设备，而等待的进程不持有任何设备。因此，“占有并等待”条件不满足，破坏了死锁的一个必要条件。由于死锁需要所有必要条件同时满足，因此在该策略下死锁不会发生。这直接证明了选项 A 的正确性。\n\n接下来，我们分析利用率。将双设备利用率 $U$ 定义为\n$$\nU \\;=\\; \\frac{\\text{total busy time across both devices}}{\\text{number of devices} \\times \\text{makespan}}.\n$$\n两个设备的总繁忙时间仅取决于所有进程的实际使用区间的总和；它不依赖于分配策略。根据给定的区间：\n\n- 对于 $R_1$：$P_1$ 使用 $[2,4]$（长度 $4-2=2$）和 $[8,9]$（长度 $9-8=1$），总计 $2+1=3$ 个单位。$P_2$ 使用 $[1,2]$（长度 $2-1=1$）计 $1$ 个单位。$P_3$ 不使用 $R_1$。因此，$R_1$ 的总繁忙时间是 $3+1=4$ 个单位。\n- 对于 $R_2$：$P_1$ 使用 $[5,7]$（长度 $7-5=2$）计 $2$ 个单位。$P_2$ 使用 $[6,8]$（长度 $8-6=2$）计 $2$ 个单位。$P_3$ 使用 $[2,3]$（长度 $3-2=1$）计 $1$ 个单位。因此，$R_2$ 的总繁忙时间是 $2+2+1=5$ 个单位。\n\n因此，两个设备的总繁忙时间是 $4+5=9$ 个单位。这个值在不同策略下是不变的，因为它加总了实际的使用时长。\n\n在禁止“占有并等待”的策略下，$P_1$ 和 $P_2$ 声明 $\\{R_1, R_2\\}$，一旦被接纳，它们将在整个运行期间持有这两个设备。$P_3$ 声明 $\\{R_2\\}$，如果被接纳，它将在整个运行期间持有 $R_2$。因为 $P_1$ 或 $P_2$ 在其全部运行期间都持有 $R_1$ 和 $R_2$，所以需要任一设备的其他进程都不能与它们重叠。特别是，$P_3$ 不能与 $P_1$ 或 $P_2$ 重叠，因为它需要 $R_2$，而这两个进程在其整个运行期间都持有 $R_2$，即使在它们不活跃使用 $R_2$ 的阶段也是如此。因此，$\\{P_1, P_2\\}$ 中至多只有一个能同时运行，并且 $P_3$ 也必须与它们串行执行。因此，该策略下的完工时间是它们运行时间的总和：$10+8+6=24$。\n\n因此，在禁止“占有并等待”策略下的双设备利用率为\n$$\nU_{\\text{one-shot}} \\;=\\; \\frac{9}{2 \\times 24} \\;=\\; \\frac{9}{48} \\;=\\; \\frac{3}{16}.\n$$\n\n我们现在论证，存在一个完工时间更短、利用率更高的可行增量调度。考虑在增量分配下的以下开始时间：$P_1$ 在 $t=0$ 开始，$P_3$ 在 $t=0$ 开始，$P_2$ 在 $t=4$ 开始。验证设备使用不重叠：\n\n- 对于 $R_1$：$P_1$ 使用 $[2,4]$ 和 $[8,9]$（绝对时间，因为 $P_1$ 从 $t=0$ 开始）。$P_2$ 从 $t=4$ 开始，在其自身开始时间的 $[1,2]$ 期间使用 $R_1$，即绝对时间 $[5,6]$。这些区间与 $[2,4]$ 或 $[8,9]$ 不重叠。\n- 对于 $R_2$：$P_3$（从 $t=0$ 开始）使用绝对时间 $[2,3]$。$P_1$ 使用绝对时间 $[5,7]$。$P_2$ 在其从 $t=4$ 开始的相对时间 $[6,8]$ 内使用，即绝对时间 $[10,12]$。这些区间两两不相交。\n\n因为在此调度中，所有设备使用窗口在进程间都是不重叠的，所以没有发生设备争用，因此没有进程等待设备。所有三个进程可以在时间上重叠而没有资源冲突。完成时间为：$P_1$ 在 $t=10$ 完成，$P_3$ 在 $t=6$ 完成，$P_2$ 在 $t=4+8=12$ 完成。因此完工时间为 $\\max\\{10,6,12\\}=12$。\n\n在这个可行的增量调度下，双设备利用率为\n$$\nU_{\\text{incremental}} \\;=\\; \\frac{9}{2 \\times 12} \\;=\\; \\frac{9}{24} \\;=\\; \\frac{3}{8}.\n$$\n因此，对于此工作负载，增量分配下的利用率严格更高，因为分母（完工时间乘以设备数量）更小，而分子（总繁忙时间）相同。这证明了选项 B 的正确性。\n\n我们现在分析其余选项：\n\n- 选项 C 声称，在禁止“占有并等待”的策略下，吞吐量严格增加，因为设备被更充分地利用。这是不正确的。上面的例子显示了相反的现象：资源被保留但在很长一段时间内处于空闲状态，阻止了其他进程在需要时使用它们。完工时间从 $12$（增量）增加到 $24$（禁止占有并等待），利用率从 $3/8$ 下降到 $3/16$。\n\n- 选项 D 声称，在禁止“占有并等待”的策略下，饥饿是不可能发生的，因为等待的进程不持有任何设备。这是不正确的。饥饿是一个调度属性，并不能仅仅通过消除“占有并等待”来消除。例如，考虑一个声明 $\\{R_1, R_2\\}$ 的长进程流，它们总是在一个声明 $\\{R_2\\}$ 的短进程之前被接纳；如果接纳或优先级规则永久性地偏向新到达的进程，那么这个短进程可能会无限期地等待。等待的进程不持有设备这一事实防止了死锁，但并不能防止饥饿。\n\n结论：\n\n- A：正确。通过禁止“占有并等待”，死锁的一个必要条件不满足，因此死锁不会发生。\n- B：正确。计算表明，对于完工时间 $24$，一次性分配策略的利用率 $U_{\\text{one-shot}}=3/16$，而一个可行的增量调度在完工时间为 $12$ 时产生的利用率 $U_{\\text{incremental}}=3/8$。\n- C：不正确。该策略通过保留空闲设备可能降低利用率和吞吐量。\n- D：不正确。即使等待的进程不持有任何设备，饥饿仍然可能由于调度/接纳策略而发生。",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "从系统级策略转向具体的编程实践，嵌套锁是多线程程序中常见的死锁来源。本练习  探究了一种在代码中规避死锁的实用模式：使用非阻塞的`try_lock`尝试获取第二个锁，若失败则释放已持有的锁并进行退避重试。通过分析此模式，你将了解它如何巧妙地破坏“持有并等待”条件，同时也会思考其可能带来的新问题，如活锁和性能开销。",
            "id": "3662708",
            "problem": "考虑一个通用操作系统（OS）上的多线程程序，该程序使用名为 $A$ 和 $B$ 的两个互斥锁来保护一个共享数据结构。原始代码路径以嵌套方式获取锁：首先执行 $lock(A)$，然后执行 $lock(B)$，接着执行一个临界区，最后按相反顺序释放锁。如果线程 $T_1$ 执行 $lock(A)$ 后等待 $lock(B)$，而线程 $T_2$ 执行 $lock(B)$ 后等待 $lock(A)$，就可能出现死锁。一项提议的修改将锁的获取方式更改为对第二个锁进行非阻塞尝试，并在失败时立即释放第一个锁：获取 $A$；尝试 $try\\_lock(B)$；如果尝试失败，则释放 $A$，执行一段有限时间的退避（backoff），然后重试；否则，进入临界区，然后释放两个锁。\n\n请仅以死锁的经典必要条件（通常称为 Coffman 条件）为基础——即互斥、持有并等待、不可抢占和循环等待——来回答以下问题。指出该修改有意破坏了哪个必要条件，并论证与原始嵌套加锁方式相比，此更改在活性（liveness）和性能方面的主要影响。选择所有正确的选项。\n\nA. 该修改通过确保线程在持有 $A$ 时不会等待 $B$ 来破坏“持有并等待”条件；结果是，在 $A$ 和 $B$ 上的死锁被阻止了，但如果没有随机化退避，可能会发生活锁或饥饿。\n\nB. 该修改破坏了“不可抢占”条件，因为当线程获取 $B$ 失败时，$A$ 可能会被强制从该线程中拿走；因此，死锁被阻止，且抢占开销增加。\n\nC. 该修改保持所有四个 Coffman 条件不变；如果两个线程无限循环，死锁仍然可能发生。\n\nD. 该修改需要一个全局锁顺序来避免死锁；否则它会破坏互斥并可能损坏临界区。\n\nE. 尽管阻止了死锁，但由于重试、自旋或频繁唤醒，该修改可能会增加中央处理器（CPU）的使用率。",
            "solution": "问题要求基于死锁的四个必要条件，对一种死锁避免技术进行分析，并探讨其在活性和性能方面的影响。\n\n### 步骤 1：问题验证\n\n问题陈述提供了一个来自操作系统和并发领域的清晰且自包含的场景。\n\n**已知条件：**\n1.  一个系统中有两个互斥锁 `$A$` 和 `$B$`，用于保护一个共享数据结构。\n2.  一个可能导致死锁的原始加锁方案：线程 `$T_1$` 调用 `lock(A)` 后调用 `lock(B)`，而另一个线程 `$T_2$` 调用 `lock(B)` 后调用 `lock(A)`。\n3.  一个对加锁协议的提议修改：\n    a. 获取 `$A$` (`lock(A)`)。\n    b. 非阻塞地尝试获取 `$B$` (`try_lock(B)`)。\n    c. 如果 `try_lock(B)` 成功，则进入临界区，然后释放两个锁。\n    d. 如果 `try_lock(B)` 失败，则释放 `$A$`，执行一段有限时间的退避，并重试整个序列。\n4.  分析必须基于死锁的四个经典必要条件（Coffman 条件）：互斥、持有并等待、不可抢占和循环等待。\n\n**验证：**\n- **科学依据：** 该问题基于计算机科学的基本和标准原理，特别是关于并发控制和死锁的操作系统理论。互斥锁、`lock`、`try_lock`、退避和 Coffman 条件等概念都是公认的。该场景是用于教授死锁避免的经典范例。\n- **定义良好：** 问题陈述清晰。它描述了一个初始算法、一个修改后的算法，并要求在一个特定的理论框架（Coffman 条件）下分析该修改及其在实践中的后果（活性、性能）。该描述足以推导出唯一且有意义的解决方案。\n- **客观性：** 语言技术性强、精确，且没有歧义或主观论断。\n\n该问题是一个标准、定义良好的计算机科学问题，科学上合理且客观，因此是有效的。\n\n### 步骤 2：分析修改后的加锁协议\n\n我们将根据死锁的四个必要条件来分析修改后的协议。要发生死锁，所有四个条件必须同时成立。修改的目标是破坏其中至少一个条件。\n\n1.  **互斥：** 该条件指出，至少有一个资源必须以非共享模式持有。根据定义，互斥锁 `$A$` 和 `$B$` 是排他性锁资源。修改后的方案继续将它们用作互斥锁，确保在任何时候只有一个线程可以持有一个给定的锁。因此，**互斥**条件仍然成立。\n\n2.  **持有并等待：** 该条件指出，一个线程必须持有至少一个资源，并且正在等待获取当前由其他线程持有的额外资源。\n    - 在原始协议中，一个线程可以成功执行 `lock(A)`，然后在 `lock(B)` 上无限期地阻塞（等待）。在这个等待期间，它持有资源 `$A$` 并等待资源 `$B$`。这满足了持有并等待条件。\n    - 在修改后的协议中，一个线程获取 `$A$`。然后它使用 `try_lock(B)` 尝试获取 `$B$`。这个调用是非阻塞的；它会立即返回，指示成功或失败。如果失败，线程的逻辑规定它必须立即释放 `$A$`。在任何时候，线程都不会在持有资源 `$A$` 的同时*等待*资源 `$B$`。它要么快速连续地获取 `$A$` 和 `$B$`，要么在释放 `$A$` 之前仅持有它很短的一段时间，然后什么也不持有。因此，该修改**破坏了“持有并等待”条件**。\n\n3.  **不可抢占：** 该条件指出，资源不能被从线程中强制拿走；它们必须由持有它们的线程自愿释放。在修改后的协议中，当一个线程获取 `$B$` 失败时，它会释放 `$A$`。这个释放是自愿的；它是线程编程逻辑中一个明确的部分。操作系统或其他线程不会强制抢占锁 `$A$`。因此，根据经典定义，**不可抢占**条件仍然成立。\n\n4.  **循环等待：** 该条件指出，必须存在一组等待线程 `{$T_0, T_1, ..., T_n$}`，使得 `$T_0$` 等待由 `$T_1$` 持有的资源，`$T_1$` 等待由 `$T_2$` 持有的资源，...，而 `$T_n$` 等待由 `$T_0$` 持有的资源。通过破坏持有并等待条件，该修改使得循环等待变得不可能。一个未能获取第二个锁的线程不会等待；它会释放它的第一个锁，从而打破任何潜在的依赖链。因此，作为破坏持有并等待条件的结果，**循环等待**条件也被有效地阻止了。\n\n该修改的逻辑直接针对并破坏的主要条件是**持有并等待**。\n\n### 步骤 3：活性和性能影响分析\n\n- **活性：** 死锁是一种活性失败，其中进程被永久阻塞。该修改防止了死锁。然而，它引入了其他活性失败的可能性。\n    - **活锁：** 考虑两个线程 `$T_1$` 和 `$T_2$` 几乎同时尝试该协议。`$T_1$` 获取 `$A$`。`$T_2$` 获取 `$B$`。`$T_1$` 执行 `try_lock(B)` 失败并释放 `$A$`。`$T_2$` 执行 `try_lock(A)` 失败并释放 `$B$`。两者都进行退避。如果它们的退避时间相同且有限，它们可能会无限期地重复这个序列。两个线程都在活动（执行指令），但没有取得任何进展。这就是活锁。通常使用随机化退避策略来降低活锁的概率，但不能完全消除它。\n    - **饥饿：** 在一个多线程系统中，可能某个特定的线程会反复地不走运。它可能因为其他线程总能设法获取到它需要的某个锁而持续无法同时获取两个锁。当其他线程在取得进展时，这一个线程就会“饿死”。\n\n- **性能：**\n    - 原始的阻塞协议（`lock(A)`，`lock(B)`）在锁不可用时会导致线程被操作系统调度器挂起。在挂起期间，线程消耗零中央处理器（CPU）资源。\n    - 修改后的协议涉及一个重试循环。每次尝试都包括 `lock`、`try_lock`，以及（在失败时）`unlock` 和 `backoff`。这个循环消耗 CPU 周期。即使退避使线程休眠，重复的加锁尝试和频繁的上下文切换（唤醒）的开销也可能远高于阻塞方法的单次上下文切换，尤其是在高竞争条件下。这会导致 **CPU 使用率增加**。\n\n### 步骤 4：逐项评估选项\n\n**A. 该修改通过确保线程在持有 $A$ 时不会等待 $B$ 来破坏“持有并等待”条件；结果是，在 $A$ 和 $B$ 上的死锁被阻止了，但如果没有随机化退避，可能会发生活锁或饥饿。**\n- 该陈述正确地指出了**持有并等待**条件被破坏。\n- 它正确地得出结论，即死锁因此被阻止。\n- 它正确地指出了可能出现的活性问题，如**活锁**和**饥饿**。\n**结论：正确。**\n\n**B. 该修改破坏了“不可抢占”条件，因为当线程获取 $B$ 失败时，$A$ 可能会被强制从该线程中拿走；因此，死锁被阻止，且抢占开销增加。**\n- 该陈述错误地声称**不可抢占**条件被破坏。锁 `$A$` 是由线程自己的逻辑自愿释放的，而不是被外部代理强制抢占的。\n**结论：错误。**\n\n**C. 该修改保持所有四个 Coffman 条件不变；如果两个线程无限循环，死锁仍然可能发生。**\n- 该陈述在两点上是错误的。首先，它错误地声称所有四个条件都保持不变，而实际上“持有并等待”条件被破坏了。其次，它将**活锁**（无限循环但没有进展）与**死锁**（被无限期阻塞）混淆了。因为一个条件被破坏，死锁是不可能发生的。\n**结论：错误。**\n\n**D. 该修改需要一个全局锁顺序来避免死锁；否则它会破坏互斥并可能损坏临界区。**\n- 该陈述是错误的。“尝试加锁并释放”策略是强制执行全局锁顺序的一种*替代*方案。全局锁顺序是另一种防止死锁的方法（通过防止循环等待）。\n- 它还错误地声称该方法破坏了**互斥**。互斥锁的使用确保了互斥性得以维持，并且线程只有在获取*两个*锁之后才能进入临界区，从而防止数据损坏。\n**结论：错误。**\n\n**E. 尽管阻止了死锁，但由于重试、自旋或频繁唤醒，该修改可能会增加中央处理器（CPU）的使用率。**\n- 该陈述正确地指出了一个关键的性能影响。重试机制是一种形式的忙等待或导致频繁的线程调度，与阻塞（休眠线程不消耗CPU）相比，这两者都会增加**CPU 使用率**。它也正确地指出死锁被阻止了。\n**结论：正确。**\n\n选项 A 和 E 都对该修改提供了正确的分析，涵盖了问题的不同部分（死锁条件、活性和性能）。",
            "answer": "$$\\boxed{AE}$$"
        },
        {
            "introduction": "“循环等待”是构成死锁的最后一个关键支柱，它描述了一组进程形成环形依赖链的僵局。经典的“哲学家就餐”问题是阐释该条件的绝佳模型。本练习  将引导你分析这个环形依赖场景，并推导出去除循环等待的最优雅、最常用的方法——对资源进行全局排序，并强制所有进程按序申请。",
            "id": "3662794",
            "problem": "一个操作系统（OS）管理一组共 $n$ 个文件锁 $\\{F_0,F_1,\\dots,F_{n-1}\\}$，每个锁都是一个二元互斥锁。系统中有 $n$ 个线程 $\\{T_0,T_1,\\dots,T_{n-1}\\}$，对于每个 $i\\in\\{0,1,\\dots,n-1\\}$，线程 $T_i$ 必须获得恰好 2 个锁才能完成其临界区：$F_i$ 和 $F_{(i+1)\\bmod n}$。基准的加锁策略是阻塞式获取：每个线程尝试获取它的第一个锁，一旦持有，就尝试获取它的第二个锁，必要时会阻塞；锁一旦被授予，就不会被操作系统强制撤销。\n\n使用以下第一性原理基础：\n- 死锁的发生需要同时满足以下四个必要条件：互斥、持有并等待、不可抢占和循环等待。\n- 互斥意味着一个锁在同一时间最多只能被一个线程持有。\n- 持有并等待意味着一个线程在等待获取额外资源的同时，至少持有一个资源。\n- 不可抢占意味着一个资源一旦被获取，就不能被强制夺走；它必须被自愿释放。\n- 循环等待意味着存在一个线程循环链，其中每个线程都在等待下一个线程持有的资源。\n\n考虑这个环中的经典死锁模式：如果每个线程 $T_i$ 首先获取 $F_i$，然后等待 $F_{(i+1)\\bmod n}$，就可能出现一个长度为 $n$ 的循环等待。请确定一个最小的策略变更，该变更能够打破循环等待，同时保留互斥性，并且在其他方面保持资源语义不变。选择最佳选项。\n\nA. 对文件锁实施严格的全局排序：为每个 $F_k$ 从一个全序关系中分配一个唯一的等级 $r(F_k)$，并要求所有线程按照严格递增的等级顺序获取所需的锁。\n\nB. 允许操作系统在锁的持有者等待另一个锁时，在超时后强制撤销其持有的锁，从而实现锁的抢占。\n\nC. 用两阶段尝试加锁策略替换阻塞式获取：一个线程以非阻塞方式尝试获取两个锁；如果未能获取第二个锁，则释放第一个锁并在稍后重试。\n\nD. 用一个守护所有文件的全局锁 $G$ 替换 $n$ 个文件锁，这样每个线程在其整个临界区周围只获取 1 个锁 $G$。\n\n回答正确的选项。",
            "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n- 一个操作系统管理一组共 $n$ 个文件锁 $\\{F_0, F_1, \\dots, F_{n-1}\\}$。\n- 每个锁都是一个二元互斥锁。\n- 有 $n$ 个线程 $\\{T_0, T_1, \\dots, T_{n-1}\\}$。\n- 对于每个 $i \\in \\{0, 1, \\dots, n-1\\}$，线程 $T_i$ 必须获得恰好 2 个锁才能完成其临界区：$F_i$ 和 $F_{(i+1)\\bmod n}$。\n- 基准的加锁策略是阻塞式获取：一个线程获取它的第一个锁，然后获取它的第二个锁，必要时会阻塞。\n- 锁不会被强制撤销（不可抢占）。\n- 第一性原理基础：死锁的发生需要同时满足四个必要条件：\n    1.  **互斥**：一个锁在同一时间最多只能被一个线程持有。\n    2.  **持有并等待**：一个线程在等待获取额外资源的同时，至少持有一个资源。\n    3.  **不可抢占**：一个资源不能被强制夺走。\n    4.  **循环等待**：存在一个线程循环链，其中每个线程都在等待下一个线程持有的资源。\n- 问题要求确定一个最小的策略变更，该变更能够**打破循环等待**，同时保留互斥性，并且在其他方面保持资源语义不变。\n\n#### 步骤 2：使用提取的已知条件进行验证\n问题陈述是操作系统和资源加锁背景下“哲学家就餐问题”的一个经典表述。\n- **科学依据**：该问题牢固地基于计算机科学中的既定概念，特别是关于并发、资源管理和死锁的操作系统理论。死锁的四个必要条件是该领域的基石。\n- **定义明确**：问题定义清晰。它描述了一个系统、一个潜在的问题（死锁），并要求一种特定类型的解决方案（一个打破其中一个必要条件的策略变更）。可以推导出一个独特且有意义的解决方案。\n- **客观性**：语言精确且技术性强，没有含糊不清或主观的陈述。\n\n该问题没有表现出验证标准中列出的任何缺陷。在其领域内，这是一个健全、可形式化和标准的问题。\n\n#### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导出一个解决方案。\n\n### 基于原理的推导\n问题要求一个策略变更，通过打破**循环等待**条件来专门防止死锁。在所描述的系统中，当且仅当所有四个必要条件——互斥、持有并等待、不可抢占和循环等待——同时满足时，才会发生死锁。问题指出，互斥和不可抢占是基准系统的特性。当一个线程成功获取其第一个锁然后阻塞等待其第二个锁时，持有并等待条件就满足了。\n\n目标是循环等待条件。如果存在一个等待线程的循环，这个条件就会出现。在给定的设置中，如果每个线程 $T_i$ 都获取了它的第一个锁 $F_i$，然后等待它的第二个锁 $F_{(i+1)\\bmod n}$，就会发生死锁。这导致了以下循环依赖关系：\n- $T_0$ 持有 $F_0$ 并等待 $F_1$。\n- $F_1$ 被 $T_1$ 持有，而 $T_1$ 在等待 $F_2$。\n- ...\n- $T_{n-2}$ 持有 $F_{n-2}$ 并等待 $F_{n-1}$。\n- $T_{n-1}$ 持有 $F_{n-1}$ 并等待 $F_0$，而 $F_0$ 被 $T_0$ 持有。\n\n这形成了一个循环 $T_0 \\to T_1 \\to \\dots \\to T_{n-1} \\to T_0$，其中 $\\to$ 表示“等待...所持有的资源”。为了打破循环等待，我们必须引入一个策略，使得这样的循环不可能形成。\n\n### 逐项分析\n\n**A. 对文件锁实施严格的全局排序：为每个 $F_k$ 从一个全序关系中分配一个唯一的等级 $r(F_k)$，并要求所有线程按照严格递增的等级顺序获取所需的锁。**\n\n这是防止死锁的一种经典技术。让我们分析它对循环等待的影响。不失一般性地，假设锁 $F_k$ 的等级是其索引，即 $r(F_k) = k$。\n一个线程 $T_i$ 需要锁 $F_i$ 和 $F_{(i+1)\\bmod n}$。\n- 对于 $i \\in \\{0, 1, \\dots, n-2\\}$，所需的锁是 $F_i$ 和 $F_{i+1}$。由于 $r(F_i) = i  i+1 = r(F_{i+1})$，线程 $T_i$ 必须先获取 $F_i$，然后获取 $F_{i+1}$。\n- 对于线程 $T_{n-1}$，所需的锁是 $F_{n-1}$ 和 $F_0$。由于 $r(F_0) = 0  n-1 = r(F_{n-1})$，线程 $T_{n-1}$ 必须先获取 $F_0$，然后获取 $F_{n-1}$。\n\n现在，为了反证，假设存在一个循环等待。这意味着存在一组线程 $\\{P_1, P_2, \\dots, P_k\\}$，使得 $P_1$ 正在等待 $P_2$ 持有的锁，$P_2$ 等待 $P_3$ 持有的锁，...，而 $P_k$ 等待 $P_1$ 持有的锁。\n根据该策略，一个线程 $P_j$ 只能等待一个等级*高于*其当前持有的任何锁的等级的锁。设 $L_j$ 是 $P_j$ 正在等待的锁。$L_j$ 由 $P_{j+1}$ 持有（索引以 $k$ 为模）。因此，对于每个 $j$，$P_{j+1}$ 持有锁 $L_j$。当 $P_{j+1}$ 稍后等待锁 $L_{j+1}$ 时，必须有 $r(L_j)  r(L_{j+1})$。将此逻辑应用于整个循环：\n- $P_1$ 等待 $P_2$ 持有的 $L_1$。\n- $P_2$ 持有 $L_1$ 并等待 $L_2$。根据规则，$r(L_1)  r(L_2)$。\n- $P_3$ 持有 $L_2$ 并等待 $L_3$。根据规则，$r(L_2)  r(L_3)$。\n- ...\n- $P_k$ 持有 $L_{k-1}$ 并等待 $L_k$。根据规则，$r(L_{k-1})  r(L_k)$。\n- $P_1$ 持有 $L_k$ 并等待 $L_1$。根据规则，$r(L_k)  r(L_1)$。\n\n组合这些不等式得到链条 $r(L_1)  r(L_2)  \\dots  r(L_k)  r(L_1)$。这是一个逻辑矛盾。因此，不可能存在循环等待。\n该策略直接且可证明地打破了循环等待条件。这是一个“最小变更”，因为它保留了 $n$ 个锁及其对线程的分配（即“资源语义”），而仅仅增加了一个行为规则。\n结论：**正确**\n\n**B. 允许操作系统在锁的持有者等待另一个锁时，在超时后强制撤销其持有的锁，从而实现锁的抢占。**\n\n这个策略变更针对的是**不可抢占**条件，而不是循环等待条件。打破四个必要条件中的任何一个都足以防止死锁。然而，问题明确要求一个“打破循环等待”的策略。此选项打破的是另一个不同的条件。\n结论：**不正确**\n\n**C. 用两阶段尝试加锁策略替换阻塞式获取：一个线程以非阻塞方式尝试获取两个锁；如果未能获取第二个锁，则释放第一个锁并在稍后重试。**\n\n这个策略变更针对的是**持有并等待**条件。遵循此策略的线程永远不会在等待另一个资源时持有一个资源。它要么在一个原子步骤中获取其所需的所有资源（两个锁），要么一个也不持有。如果一个线程未能获取第二个锁，它会释放第一个锁，此时它没有在“等待”时“持有”。这有效地消除了持有并等待条件。同样，虽然这可以防止死锁，但它并非通过打破循环等待条件来实现的，而这正是问题的要求。\n结论：**不正确**\n\n**D. 用一个守护所有文件的全局锁 $G$ 替换 $n$ 个文件锁，这样每个线程在其整个临界区周围只获取 1 个锁 $G$。**\n\n这个策略变更确实可以防止死锁。由于每个线程只需要一个资源（$G$），持有并等待条件被打破了（一个线程不能在等待另一个资源时持有一个资源）。循环等待条件也被打破了，因为等待的循环至少需要两个不同的资源被争夺。然而，问题要求一个*最小的*策略变更，且保持“资源语义不变”。用一个粗粒度的全局锁替换 $n$ 个细粒度的锁是对资源语义的根本性且非最小的改变。这是一个会急剧降低潜在并发性的激烈措施。选项 A 要小得多，因为它保留了原始的 $n$ 个锁及其用途，只增加了一个获取顺序的规则。因此，这个选项不如选项 A 那样满足问题的约束。\n结论：**不正确**\n\n最终结论：选项 A 是唯一一个按要求直接针对循环等待条件，并且通过保留底层资源结构的最小变更来实现这一点的选项。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}