{
    "hands_on_practices": [
        {
            "introduction": "理解内存分配器不仅是记忆定义，更是掌握其逐步执行的行为。本练习就像一个数字取证谜题，你需要通过观察最终状态来推断其底层规则。通过这种方式，你可以巩固对首次适应（first-fit）、最佳适应（best-fit）和合并策略（coalescing）之间机制差异的理解。",
            "id": "3644730",
            "problem": "一个系统管理主内存，并维护一个按地址升序排列的空闲块（hole）列表。一个单一的长时间运行的工作负载执行一系列的分配和释放操作。您仅被告知以下基本规则和观察结果。\n\n- 在任何时候，主内存都是已分配块和空闲块的不相交并集。当通过释放操作产生相邻的空闲块时，根据分配器的策略，它们可能会也可能不会被合并。在向一个空闲块中进行分配时，如果该空闲块严格大于请求大小，分配器可能会将该空闲块分割成一个已分配块和一个剩余空闲块。\n- 在固定分区分配中，内存被预先划分为一组在运行时大小不变的固定分区；进程占用整个分区，而空闲块就是整个空闲的分区。在可变分区分配中，内存最初是一个连续的空闲区域，由分配器动态地进行分割和合并。首次适应算法（First-fit）选择地址顺序上第一个能满足请求的空闲块；最佳适应算法（Best-fit）在所有能满足请求的空闲块中，选择最小的那个。\n\n假设初始条件和请求序列如下。\n\n- 最初，大小为 $M = 200$ 的整个内存是一个连续的空闲块。\n- 按时间顺序发生一系列请求和事件，其进程标识符和大小如下：\n  1) 分配大小为 $50$ 的 $P_1$，\n  2) 分配大小为 $40$ 的 $P_2$，\n  3) 分配大小为 $30$ 的 $P_3$，\n  4) 分配大小为 $25$ 的 $P_4$，\n  5) 释放 $P_3$，\n  6) 分配大小为 $20$ 的 $P_5$，\n  7) 分配大小为 $10$ 的 $P_7$，\n  8) 分配大小为 $20$ 的 $P_6$，\n  9) 释放 $P_2$，\n  10) 释放 $P_5$，\n  11) 分配大小为 $30$ 的 $P_8$。\n\n在事件 $11$ 之后立即进行的内存转储显示，空闲列表（按地址升序排列）正好由两个空闲块组成，其大小构成了多重集 $\\{30, 35\\}$。\n\n根据上述基本定义以及观察到的初始和最终条件，以下哪种分配器特征与观察结果最一致？\n\nA. 固定分区分配（任何变体）\n\nB. 可变分区分配，采用首次适应算法，并在释放时立即合并相邻的空闲块\n\nC. 可变分区分配，采用最佳适应算法，并在释放时立即合并相邻的空闲块\n\nD. 可变分区分配，采用首次适应算法，且在释放时不进行合并\n\nE. 信息不足以区分首次适应和最佳适应算法，或区分固定分区和可变分区",
            "solution": "### 第1步：提取已知信息\n问题提供了以下信息：\n- **内存模型**：一个单一的主内存空间，是已分配块和空闲块（碎片）的不相交并集。空闲块列表按地址升序维护。\n- **分配/释放规则**：\n    - 在比请求大的空闲块中进行分配可能会分割该空闲块。\n    - 释放一个块可能会也可能不会导致与相邻空闲块的合并。\n- **分配器定义**：\n    - **固定分区**：内存被*预先*划分为固定大小的分区。进程占用整个分区。空闲块是整个分区。\n    - **可变分区**：内存最初是一个大的空闲块，之后被动态地分割和合并。\n    - **首次适应**：选择地址顺序上第一个足够大的空闲块以满足请求。\n    - **最佳适应**：选择足够满足请求的最小的空闲块。\n- **初始条件**：\n    - 总内存大小 $M = 200$。\n    - 整个内存最初是一个空闲块：`(address=0, size=200)`。\n- **事件序列**：\n    1. 分配大小为 $50$ 的 $P_1$。\n    2. 分配大小为 $40$ 的 $P_2$。\n    3. 分配大小为 $30$ 的 $P_3$。\n    4. 分配大小为 $25$ 的 $P_4$。\n    5. 释放 $P_3$。\n    6. 分配大小为 $20$ 的 $P_5$。\n    7. 分配大小为 $10$ 的 $P_7$。\n    8. 分配大小为 $20$ 的 $P_6$。\n    9. 释放 $P_2$。\n    10. 释放 $P_5$。\n    11. 分配大小为 $30$ 的 $P_8$。\n- **最终观察结果**：在事件 11 之后，空闲列表恰好包含两个空闲块，其大小由多重集 $\\{30, 35\\}$ 给出。\n\n### 第2步：使用提取的已知信息进行验证\n- **科学基础**：该问题使用了操作系统领域的标准、明确定义的概​​念，特别是内存管理算法（固定与可变分区、首次适应、最佳适应、合并）。这些概念在计算机科学教育的背景下是内部一致且事实正确的。\n- **良构问题**：问题提供了一个初始状态、一个定义明确的操作序列和一个最终状态。它要求确定给定的哪种分配策略可以产生这个结果。这是一个可解的逆向工程或验证问题。预期会有一个唯一答案，可以通过系统地模拟每种策略的过程来找到。\n- **客观性**：问题使用精确的技术语言陈述，没有主观或模棱两可的术语。问题是自包含的，不包含矛盾信息。分配和释放的总内存量与最终状态一致。净分配内存为 $(50+40+30+25+20+10+20+30) - (30+40+20) = 225 - 90 = 135$。总空闲空间应为 $200 - 135 = 65$。最终观察到的空闲块大小为 $30$ 和 $35$，它们的总和是 $30+35=65$。这个内部一致性检查通过。\n\n### 第3步：结论与行动\n问题陈述是 **有效的**。我将通过为每个提议的分配策略模拟事件序列来推导解决方案。\n\n### 正确答案的推导\n\n我将跟踪整个事件序列中内存空闲列表的状态。空闲列表是一个由元组 `(address, size)` 组成的有序列表。\n\n**初始状态：** 内存为 `[0, 199]`。\n`空闲列表: [(0, 200)]`\n\n**事件 1-4：初始分配**\n因为只有一个空闲块，首次适应和最佳适应算法的行为相同。\n1.  **分配 $P_1(50)$:** $P_1$ 占用 `[0, 49]`。`空闲列表: [(50, 150)]`\n2.  **分配 $P_2(40)$:** $P_2$ 占用 `[50, 89]`。`空闲列表: [(90, 110)]`\n3.  **分配 $P_3(30)$:** $P_3$ 占用 `[90, 119]`。`空闲列表: [(120, 80)]`\n4.  **分配 $P_4(25)$:** $P_4$ 占用 `[120, 144]`。`空闲列表: [(145, 55)]`\n\n**事件 5: 释放 $P_3$**\n-   位于 `[90, 119]` (大小 30) 的 $P_3$ 块被释放。它被已分配的块（$P_2$ 在 `[50, 89]`，$P_4$ 在 `[120, 144]`）包围，因此无法发生合并。\n-   `空闲列表: [(90, 30), (145, 55)]` (按地址排序)\n\n**事件 6: 分配 $P_5(20)$**\n-   请求大小为 20。空闲块为 `(90, 30)` 和 `(145, 55)`。\n-   **首次适应:** 选择第一个足够的空闲块 `(90, 30)`。\n-   **最佳适应:** 选择最小的足够大的空闲块。因为 $30  55$，它也选择 `(90, 30)`。\n-   两种策略都将 $P_5$ 分配到 `[90, 109]`，并分割该空闲块。剩余空闲块为 `(90+20, 30-20) = (110, 10)`。\n-   `空闲列表: [(110, 10), (145, 55)]`\n\n**事件 7: 分配 $P_7(10)$**\n-   请求大小为 10。空闲块为 `(110, 10)` 和 `(145, 55)`。\n-   **首次适应:** 选择 `(110, 10)`。\n-   **最佳适应:** 选择 `(110, 10)`，因为它是最小的足够大的空闲块。\n-   两种策略都将 $P_7$ 分配到 `[110, 119]`。这是一个精确匹配，所以该空闲块被完全使用。\n-   `空闲列表: [(145, 55)]`\n\n**事件 8: 分配 $P_6(20)$**\n-   请求大小为 20。只有一个空闲块 `(145, 55)`。\n-   $P_6$ 被分配到 `[145, 164]`，并分割该空闲块。剩余空闲块为 `(145+20, 55-20) = (165, 35)`。\n-   `空闲列表: [(165, 35)]`\n\n此时，可变分区分配的策略尚未出现分歧。已分配块的内存布局是：\n$P_1[0,49]$, $P_2[50,89]$, $P_5[90,109]$, $P_7[110,119]$, $P_4[120,144]$, $P_6[145,164]$。\n\n**事件 9: 释放 $P_2$**\n-   位于 `[50, 89]` (大小 40) 的 $P_2$ 块被释放。它邻接已分配的块 $P_1$ 和 $P_5$。无法进行合并。\n-   `空闲列表: [(50, 40), (165, 35)]`\n\n**事件 10: 释放 $P_5$**\n-   位于 `[90, 109]` (大小 20) 的 $P_5$ 块被释放。\n-   位于 `[90, 109]` 的新空闲块紧邻现有的位于 `[50, 89]` 的空闲块。\n-   在这里，合并策略变得至关重要。\n\n-   **立即合并的情况 (选项 B, C):** 两个相邻的空闲块 `(50, 40)` 和 `(90, 20)` 被合并成一个更大的空闲块：`(50, 40+20) = (50, 60)`。\n    -   `空闲列表: [(50, 60), (165, 35)]`\n-   **不合并的情况 (选项 D):** 新的空闲块被简单地添加到列表中。\n    -   `空闲列表: [(50, 40), (90, 20), (165, 35)]`\n\n**事件 11: 分配 $P_8(30)$**\n-   我们现在为不同的策略测试最后一步。\n\n### 逐项分析\n\n**A. 固定分区分配（任何变体）**\n问题陈述，在固定分区分配中，内存被*预先*划分为固定大小的分区。然而，初始条件是内存是一个大小为 $200$ 的连续空闲块。这符合可变分区分配的定义，而不是固定分区。此外，目标是最终得到大小为 $30$ 和 $35$ 的空闲块。在固定分区中，空闲块的大小是预先确定的并且不会改变。通过分割动态创建具有这些特定大小的空闲块是可变分区分配的特征。因此，固定分区分配与问题设置不一致。\n**结论：不正确**\n\n**B. 可变分区分配，采用首次适应算法，并在释放时立即合并相邻的空闲块**\n-   从事件10开始，此策略的状态是 `空闲列表: [(50, 60), (165, 35)]`。\n-   事件11：分配 $P_8(30)$。使用首次适应算法，分配器按地址顺序检查列表。\n-   第一个空闲块 `(50, 60)` 是足够的 ($60 \\ge 30$)。它被选中。\n-   $P_8$ 被分配到 `[50, 79]`。该空闲块被分割，在地址 $50+30=80$ 处留下一个大小为 $60-30=30$ 的剩余空闲块。\n-   新的 `空闲列表` 是 `[(80, 30), (165, 35)]`。\n-   最终的空闲列表正好由两个空闲块组成，其大小构成多重集 $\\{30, 35\\}$。这与观察结果完全匹配。\n**结论：正确**\n\n**C. 可变分区分配，采用最佳适应算法，并在释放时立即合并相邻的空闲块**\n-   从事件10开始，此策略的状态是 `空闲列表: [(50, 60), (165, 35)]`。\n-   事件11：分配 $P_8(30)$。使用最佳适应算法，分配器找到足够大的最小空闲块。可用的空闲块大小为 $60$ 和 $35$。\n-   两个空闲块都足够大。最小的足够大的空闲块是大小为 $35$ 的那个。它被选中。\n-   $P_8$ 被分配到地址为 $165$ 的空闲块。它占用空间 `[165, 194]`。剩余空闲块的大小为 $35-30=5$，地址为 $165+30=195$。\n-   新的 `空闲列表` 是 `[(50, 60), (195, 5)]`。\n-   最终的空闲列表有大小为 $\\{60, 5\\}$ 的空闲块。这与观察到的 $\\{30, 35\\}$ 不匹配。\n**结论：不正确**\n\n**D. 可变分区分配，采用首次适应算法，且在释放时不进行合并**\n-   从事件10开始，此策略的状态是 `空闲列表: [(50, 40), (90, 20), (165, 35)]`。\n-   事件11：分配 $P_8(30)$。使用首次适应算法，第一个足够的空闲块是 `(50, 40)`。\n-   $P_8$ 被分配到 `[50, 79]`，在地址 $50+30=80$ 处留下一个大小为 $40-30=10$ 的剩余空闲块。\n-   新的 `空闲列表` 是 `[(80, 10), (90, 20), (165, 35)]`。\n-   最终状态有三个大小为 $\\{10, 20, 35\\}$ 的空闲块，这与观察到的“恰好两个空闲块”且大小为 $\\{30, 35\\}$ 的情况不匹配。\n**结论：不正确**\n\n**E. 信息不足以区分首次适应和最佳适应算法，或区分固定分区和可变分区**\n这是不正确的。如上所示，我们可以区分。选项A（固定分区）与问题设置不一致。选项C和D导致的最终状态与观察结果相矛盾。只有选项B产生的最终状态与观察结果完全一致。因此，信息是充分的。\n**结论：不正确**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "掌握了分配器的底层机制后，我们将其应用于更高层次的设计决策。本练习探讨了一个常见的现实世界场景：为混合了大量小请求和少量大请求的工作负载管理内存。它突出了固定分区和可变分区策略之间的根本权衡，迫使我们在可预测的内部碎片和灾难性的外部碎片风险之间做出选择。",
            "id": "3644668",
            "problem": "一个系统将一个大小为 $M = 128\\,\\text{KiB}$ 的连续内存池专用于一个表现出混合工作负载的网络子系统：频繁的小缓冲区分配和罕见的大会话释放与重新分配。\n\n考虑了两种分配器设计，每种都管理同一个内存池，并且都不允许在运行时进行内存整理（compaction）。\n\n- 固定分区设计 (F)：内存池被划分为固定的、不重叠的分区，这些分区的大小或相对位置永远不会改变。具体来说，有 $16$ 个大小为 $4\\,\\text{KiB}$ 的小分区（槽），用于小缓冲区；以及一个大小为 $64\\,\\text{KiB}$ 的大分区，用于大会话缓冲区。一个请求必须完全放入一个分区内；小请求总是被导向小槽；大请求使用那个唯一的 $64\\,\\text{KiB}$ 分区。\n- 可变分区设计 (V)：整个 $128\\,\\text{KiB}$ 是一个可变分区堆，由一个首次适应（first-fit）分配器管理，该分配器在释放时立即合并（immediate coalescing）并且不进行内存整理。每个分配请求都从一个合适的空闲块中消耗掉与请求大小完全相同的空间（本问题忽略头部/对齐开销），并将任何更大的空闲块分割为一个已分配部分和一个剩余部分。\n\n工作负载假设：\n\n- 稳态下，任何时候都维持 $n = 12$ 个活跃的小缓冲区，每个大小为 $s = 3\\,\\text{KiB}$，其开始和结束时间随时间交错。\n- 最初，存在一个大小为 $L = 64\\,\\text{KiB}$ 的大会话分配。在时间 $t_1$，这个大会话分配被释放（一个罕见事件）。此后，小缓冲区的频繁更替仍在继续。在稍后的某个时间 $t_2 \\gg t_1$，该大会话再次请求 $L = 64\\,\\text{KiB}$。\n\n使用以下核心定义：\n- 内部碎片 (Internal fragmentation) 是为满足一个请求而实际分配的内存与请求大小之差，对所有活跃的分配求和。\n- 外部碎片 (External fragmentation) 是这样一种情况：总空闲内存 $\\sum_j f_j$ 足以满足一个大小为 $R$ 的请求，但最大连续空闲块 $\\max_j f_j$ 小于 $R$（因此请求因缺乏连续性而失败）。\n\n在此场景下，下列哪个陈述是正确的？\n\nA. 在设计 F 中，稳态下（在 $t_1$ 和 $t_2$ 之间），有 $n = 12$ 个大小为 $s = 3\\,\\text{KiB}$ 的活跃小缓冲区，由小缓冲区产生的总内部碎片恰好是 $12\\,\\text{KiB}$，并且如果 $64\\,\\text{KiB}$ 的分区是空闲的，那么在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求将总是成功。\n\nB. 在设计 V 中，使用首次适应和立即合并策略，内部碎片为 $0$，并且只要总空闲内存至少为 $64\\,\\text{KiB}$，在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求就保证成功。\n\nC. 在设计 V 中，即使在 $t_2$ 时总空闲内存严格大于 $64\\,\\text{KiB}$，在稳态下对 $L = 64\\,\\text{KiB}$ 的大请求也可能失败，因为空闲空间可能被长寿命的小分配分割成不连续的碎片，其中最大的连续块小于 $64\\,\\text{KiB}$。\n\nD. 在设计 F 中，由于固定的 $4\\,\\text{KiB}$ 槽大小，每个小缓冲区的内部碎片会随时间无限增长，导致它对于此工作负载渐近地大于设计 V 中的外部碎片。\n\n选择所有适用的选项。",
            "solution": "### 问题验证\n\n**步骤1：提取已知条件**\n\n问题陈述提供了以下信息：\n- 总内存池大小：$M = 128\\,\\text{KiB}$。\n- 两种设计都不允许运行时内存整理。\n\n- **固定分区设计 (F)：**\n    - $16$ 个大小为 $4\\,\\text{KiB}$ 的小分区。\n    - $1$ 个大小为 $64\\,\\text{KiB}$ 的大分区。\n    - 请求必须放入一个分区内。小请求使用小分区；大请求使用大分区。\n\n- **可变分区设计 (V)：**\n    - 一个大小为 $128\\,\\text{KiB}$ 的可变分区堆。\n    - 分配算法：首次适应。\n    - 在 `free` 时，发生立即合并。\n    - 分配开销（头部/对齐）被忽略；一个大小为 $S$ 的请求正好消耗 $S$ 的空间。\n\n- **工作负载：**\n    - 稳态：$n = 12$ 个活跃的小缓冲区。\n    - 每个小缓冲区的大小：$s = 3\\,\\text{KiB}$。\n    - 初始状态：存在一个大小为 $L = 64\\,\\text{KiB}$ 的大会话分配。\n    - 在时间 $t_1$：释放 $L = 64\\,\\text{KiB}$ 的分配。\n    - 在时间 $t_2 \\gg t_1$：一个新的大小为 $L = 64\\,\\text{KiB}$ 的请求到达。\n\n- **定义：**\n    - 内部碎片：$\\sum (\\text{已分配大小} - \\text{请求大小})$，对所有活跃分配求和。\n    - 外部碎片：总空闲内存足以满足一个大小为 $R$ 的请求，但最大连续空闲块小于 $R$ 的情况。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学基础：** 该问题基于操作系统内存管理的基本概念，特别是固定分区和可变分区分配方案，以及相关的内部和外部碎片现象。这些概念是计算机科学课程中的标准内容。\n2.  **定义明确：** 问题是定义明确的。它提供了所有必要的定量数据（内存大小、分区数量、请求大小）和定性描述（首次适应、立即合并、交错工作负载），以便对两种设计进行严谨的分析。选项中提出的问题可以根据所提供的模型得到明确的回答。\n3.  **客观性：** 语言技术性强、精确且客观。\n4.  **一致性：** 参数是一致的。在设计 F 中，各分区大小之和等于总内存大小：$(16 \\times 4\\,\\text{KiB}) + 64\\,\\text{KiB} = 64\\,\\text{KiB} + 64\\,\\text{KiB} = 128\\,\\text{KiB} = M$。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。它科学合理、自成体系、一致且定义明确。可以开始求解过程。\n\n### 解题推导\n\n该问题要求分析两种内存分配设计——固定分区（F）和可变分区（V），在特定工作负载下的表现，并评估比较它们在碎片和分配成功方面的行为的陈述。\n\n#### 设计 F（固定分区）的分析\n\n在设计 F 中，内存被预先分配到静态分区中。大小为 $s = 3\\,\\text{KiB}$ 的小请求从包含 $16$ 个槽（每个大小为 $4\\,\\text{KiB}$）的池中得到满足。大小为 $L = 64\\,\\text{KiB}$ 的大请求从唯一的专用 $64\\,\\text{KiB}$ 分区中得到满足。\n\n-   **内部碎片：** 当一个 $3\\,\\text{KiB}$ 的请求被放入一个 $4\\,\\text{KiB}$ 的分区时，已分配分区的一部分未被使用。这就是内部碎片。\n    对于单个小缓冲区：\n    $$ \\text{内部碎片}_{\\text{小}} = (\\text{分区大小}) - (\\text{请求大小}) = 4\\,\\text{KiB} - 3\\,\\text{KiB} = 1\\,\\text{KiB} $$\n    在稳态下，有 $n = 12$ 个活跃的小缓冲区。由这些缓冲区产生的总内部碎片为：\n    $$ \\text{总内部碎片}_{\\text{小}} = n \\times \\text{内部碎片}_{\\text{小}} = 12 \\times 1\\,\\text{KiB} = 12\\,\\text{KiB} $$\n\n-   **在 $t_2$ 时的分配成功率：**\n    在时间 $t_1$，大的 $64\\,\\text{KiB}$ 会话被释放，使得专用的 $64\\,\\text{KiB}$ 分区变为可用。小缓冲区的频繁更替只发生在 $16$ 个小分区内。任何小缓冲区的分配都永远不会使用大分区。因此，在 $t_1$ 和 $t_2$ 之间，这个 $64\\,\\text{KiB}$ 的分区保持空闲和连续。当新的大小为 $L = 64\\,\\text{KiB}$ 的请求在 $t_2$ 到达时，它将被导向这个分区，该分区是空闲的，分配将成功。\n\n#### 设计 V（可变分区）的分析\n\n在设计 V 中，整个 $128\\,\\text{KiB}$ 内存池被视为一个单一的堆。使用首次适应策略从空闲块中进行分配。\n\n-   **内部碎片：** 问题陈述“每个分配请求都消耗掉与请求大小完全相同的空间”。这是纯可变分区方案的定义特征。分配的块大小与请求的大小相匹配。因此，根据这个定义，任何已分配块*内部*都没有浪费的空间。\n    $$ \\text{内部碎片} = 0 $$\n\n-   **外部碎片与在 $t_2$ 时的分配成功率：**\n    在稳态下（在 $t_1$ 和 $t_2$ 之间），有 $n = 12$ 个大小为 $s = 3\\,\\text{KiB}$ 的活跃小缓冲区。\n    $$ \\text{已分配总内存} = n \\times s = 12 \\times 3\\,\\text{KiB} = 36\\,\\text{KiB} $$\n    系统中的总空闲内存为：\n    $$ \\text{总空闲内存} = M - \\text{已分配总内存} = 128\\,\\text{KiB} - 36\\,\\text{KiB} = 92\\,\\text{KiB} $$\n    在时间 $t_2$，一个大小为 $L = 64\\,\\text{KiB}$ 的请求到达。由于总空闲内存（$92\\,\\text{KiB}$）大于请求大小（$64\\,\\text{KiB}$），所以分配在理论上是可能的。然而，成功与否取决于是否存在一个*单一连续的空闲块*，其大小至少为 $64\\,\\text{KiB}$。\n    小分配和释放的“交错”更替可能导致外部碎片。在 $t_1$，一个大的 $64\\,\\text{KiB}$ 连续块变为空闲。首次适应分配器在随后服务 $3\\,\\text{KiB}$ 请求时，可能会从这个大的空闲块中切分出小块。如果这样一个 $3\\,\\text{KiB}$ 的分配变为长寿命的，它就会像一个“塞子”一样，阻止其两侧的空闲空间被合并，即使相邻的块被释放了。在足够长的时间后（$t_2 \\gg t_1$），这个过程可能会将大的空闲块和堆的其余部分“撕碎”成许多更小的、不连续的空闲块。这是这类分配器的一种典型失败模式，即最大可用连续块的大小可能变得小于一个大的请求大小，即使总空闲内存很充足。因此，在 $t_2$ 时的 $64\\,\\text{KiB}$ 请求*不*保证成功；它可能因外部碎片而失败。\n\n### 逐项分析\n\n**A. 在设计 F 中，稳态下（在 $t_1$ 和 $t_2$ 之间），有 $n = 12$ 个大小为 $s = 3\\,\\text{KiB}$ 的活跃小缓冲区，由小缓冲区产生的总内部碎片恰好是 $12\\,\\text{KiB}$，并且如果 $64\\,\\text{KiB}$ 的分区是空闲的，那么在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求将总是成功。**\n-   陈述的第一部分，关于内部碎片，是正确的，如上文计算所示：$12 \\times (4\\,\\text{KiB} - 3\\,\\text{KiB}) = 12\\,\\text{KiB}$。\n-   第二部分也是正确的。大分区与小缓冲区的频繁更替是隔离的。它在 $t_1$ 被释放，并一直保持空闲直到 $t_2$ 的请求到来，从而保证了 $64\\,\\text{KiB}$ 分配的成功。条件“如果 $64\\,\\text{KiB}$ 分区是空闲的”被问题的时间线所满足。\n-   **结论：正确。**\n\n**B. 在设计 V 中，使用首次适应和立即合并策略，内部碎片为 $0$，并且只要总空闲内存至少为 $64\\,\\text{KiB}$，在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求就保证成功。**\n-   第一部分，“内部碎片为 $0$”，根据问题的可变分区方案定义是正确的。\n-   第二部分，“...只要总空闲内存至少为 $64\\,\\text{KiB}$，就保证成功”，这是不正确的。这个陈述忽略了外部碎片的可能性。总空闲内存是 $92\\,\\text{KiB}$，但不能保证其连续性。如果没有足够大的单一空闲块，请求就会失败。\n-   **结论：不正确。**\n\n**C. 在设计 V 中，即使在 $t_2$ 时总空闲内存严格大于 $64\\,\\text{KiB}$，在稳态下对 $L = 64\\,\\text{KiB}$ 的大请求也可能失败，因为空闲空间可能被长寿命的小分配分割成不连续的碎片，其中最大的连续块小于 $64\\,\\text{KiB}$。**\n-   这个陈述准确地描述了设计 V 环境下的外部碎片现象。正如我们的分析所确立的，在 $t_2$ 时的总空闲内存是 $92\\,\\text{KiB}$（大于 $64\\,\\text{KiB}$）。小分配的“交错”更替确实可能使堆碎片化，以至于最大的连续块小于 $64\\,\\text{KiB}$。所提供的理由是对潜在分配失败的正确解释。\n-   **结论：正确。**\n\n**D. 在设计 F 中，由于固定的 $4\\,\\text{KiB}$ 槽大小，每个小缓冲区的内部碎片会随时间无限增长，导致它对于此工作负载渐近地大于设计 V 中的外部碎片。**\n-   “每个小缓冲区的内部碎片会随时间无限增长”这个前提是错误的。对于任何给定的放入固定分区（$4\\,\\text{KiB}$）的小缓冲区请求（$3\\,\\text{KiB}$），内部碎片是恒定的：$4\\,\\text{KiB} - 3\\,\\text{KiB} = 1\\,\\text{KiB}$。它不会随时间变化。\n-   由于前提是错误的，整个陈述是无效的。\n-   **结论：不正确。**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "在上一个练习中我们已经了解了外部碎片的概念，现在我们将进一步证明它不仅仅是一个理论上的风险，而是可以被量化的。通过分析一个“对抗性”的工作负载，我们可以推导出外部碎片的最坏情况，并理解看似高效的分配策略如何在特定条件下导致严重的内存浪费。这个练习将帮助你从数学上把握外部碎片的危害。",
            "id": "3644643",
            "problem": "考虑一个由操作系统（OS）使用可变分区分配和最佳适配放置策略管理的单一连续内存区域。最佳适配选择大小足以满足传入请求的最小空闲块（空洞）。外部碎片定义为总内存中空闲但无法满足给定大小的单个分配请求的那部分内存所占的比例，因为空闲内存被分割成多个空洞，每个空洞都小于该请求。相比之下，固定分区分配会预先将内存划分为大小相等的分区，不会产生外部碎片，但可能会产生内部碎片。\n\n设总内存大小为 $M = n(a+b)$，其中 $n \\geq 1$ 为某个整数，$a$ 和 $b$ 是正数大小且 $a  b$。系统开始时只有一个大小为 $M$ 的空闲空洞。一个对抗性工作负载发出 $2n$ 个大小在 $a$ 和 $b$ 之间交替的分配请求（顺序为 $a, b, a, b, \\dots$），这些请求恰好完全填满内存，不留任何剩余空间，最终形成一个完全分配的内存，其排列方式为 $n$ 对大小为 $a$ 和 $b$ 的连续已分配块。然后，该工作负载发出 $n$ 个释放请求，精确地释放所有大小为 $a$ 的已分配块，而保持 $n$ 个大小为 $b$ 的已分配块不变。结果，空闲空间由 $n$ 个大小均为 $a$ 的空洞组成，这些空洞被大小为 $b$ 的已分配块隔开。\n\n现在假设工作负载转为以对抗性方式发出请求，其请求大小围绕典型空洞大小变化：它尝试分配大小为 $c$ 的块，其中 $c$ 的选择满足 $a  c \\leq a+b$，因此 $c$ 恰好超过了典型的空闲空洞大小 $a$。在最佳适配策略下，任何大小为 $c$ 的分配请求只有在存在一个大小至少为 $c$ 的空闲空洞时才能成功。\n\n仅使用上述核心定义以及所描述的分配和释放序列，推导出在这种对抗性模式下最佳适配策略的最坏情况外部碎片率，并以 $a$ 和 $b$ 的闭式解析函数表示。你的答案必须是单个解析表达式。无需四舍五入。将最终结果表示为一个无单位的纯分数。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 第 1 步：提取已知条件\n-   内存管理方案：可变分区分配。\n-   放置策略：最佳适配。\n-   外部碎片的定义：总内存中空闲但无法满足给定大小的单个分配请求的那部分内存所占的比例，因为空闲内存被分割成多个空洞，每个空洞都小于该请求。\n-   总内存大小：$M = n(a+b)$，其中 $n \\geq 1$ 为整数。\n-   块大小：$a$ 和 $b$ 是正数大小且 $a  b$。\n-   初始状态：一个大小为 $M$ 的单一空闲空洞。\n-   分配序列 1：$2n$ 个大小交替的请求，顺序为 $a, b, a, b, \\dots$。这会完全分配内存。\n-   释放序列：$n$ 个释放所有大小为 $a$ 的已分配块的请求。\n-   释放后状态：$n$ 个大小为 $b$ 的已分配块仍然存在。\n-   分配序列 2（对抗性）：请求大小为 $c$ 的块，其中 $a  c \\leq a+b$。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：问题使用了计算机科学和操作系统理论中标准的、明确定义的概念，包括可变分区分配、最佳适配策略和外部碎片。所描述的场景是一个典型的例子，用于说明某些分配方案中可能产生高碎片的潜力。它是科学合理的。\n2.  **适定性**：问题要求基于明确定义的事件序列和一组参数（$a$, $b$, $n$）推导一个特定的、可导出的量（最坏情况外部碎片率）。目标是一个闭式表达式，这意味着存在唯一的解析解。\n3.  **客观性**：语言精确且技术性强。像“对抗性工作负载”这样的术语在算法分析中是标准术语，不会引入主观性。\n4.  **不完整或矛盾的设置**：该设置是自洽的。总内存大小 $M = n(a+b)$ 被最初的 $2n$ 个分配请求（$n$ 个大小为 $a$ 和 $n$ 个大小为 $b$，总计 $na + nb = n(a+b)$）精确消耗。随后的内存状态被明确描述。没有矛盾之处。\n5.  **不切实际或不可行**：该场景虽然是为了产生“最坏情况”而设计的，但在物理上或逻辑上并非不可能。它代表了一个有效的内存操作序列。\n6.  **不适定或结构不良**：问题结构良好，可以导出一个有意义的解决方案。术语定义清晰。\n7.  **伪深刻、琐碎或同义反复**：问题需要将定义系统地应用于特定场景，这是一项非平凡的推理任务。\n8.  **超出科学可验证性**：问题纯粹是分析性的，其解决方案可以通过逻辑推导来验证。\n\n### 第 3 步：结论与行动\n问题是有效的。将提供一个合理的解决方案。\n\n### 解题推导\n问题要求在特定对抗性模式下，最佳适配策略的最坏情况外部碎片率。让我们逐步分析内存状态。\n\n1.  系统开始时总内存大小为 $M = n(a+b)$，作为一个单一的空闲块。\n\n2.  一个初始的对抗性工作负载以交替顺序（$a, b, a, b, \\dots$）分配 $n$ 个大小为 $a$ 的块和 $n$ 个大小为 $b$ 的块。由于内存开始时是一个单一的空洞，最佳适配策略对于第一个序列是无关紧要的；这些块被连续放置。这些分配的总大小是 $n \\times a + n \\times b = n(a+b) = M$。在此阶段结束时，整个内存都被分配，物理布局由 $n$ 对相邻的块组成：`[a][b][a][b]...[a][b]`。\n\n3.  接下来，所有 $n$ 个大小为 $a$ 的块被释放。大小为 $b$ 的块保留在原位。这使得内存处于碎片化状态。具体来说，现在有 $n$ 个空闲空洞，每个大小为 $a$。这些空洞被 $n$ 个大小为 $b$ 的已分配块隔开。内存布局为：`[hole(a)][block(b)][hole(a)][block(b)]...[hole(a)][block(b)]`。\n\n4.  我们现在必须计算外部碎片。空闲内存的总量是所有空洞大小的总和。\n    $$ \\text{Total Free Memory} = n \\times a $$\n\n5.  问题定义了一个新的对抗性工作负载，它发出大小为 $c$ 的块的请求，其中大小 $c$ 的选择满足条件 $a  c \\leq a+b$。\n\n6.  根据问题的定义，外部碎片是总内存中空闲但无法满足给定大小请求的部分所占的比例。让我们分析满足大小为 $c$ 的请求的可能性。\n    -   系统有 $n$ 个空闲空洞，每个空洞的大小恰好为 $a$。\n    -   传入请求的大小为 $c$。\n    -   给定条件 $a  c$。\n    -   因此，请求的大小 $c$ 严格大于任何可用空洞的大小 $a$。\n\n7.  最佳适配算法搜索足以满足请求的最小空洞。由于没有一个空洞的大小大于或等于 $c$，所以没有空洞可以满足该请求。因此，分配大小为 $c$ 的块的请求将会失败。\n\n8.  这意味着系统中所有的空闲内存对于这个请求都是不可用的。这个不可用（即外部碎片）内存的总量等于总空闲内存。\n    $$ \\text{Total Fragmented Memory} = \\text{Total Free Memory} = n \\times a $$\n\n9.  外部碎片率，我们记作 $F_{ext}$，是总碎片内存与总内存大小 $M$ 的比率。\n    $$ F_{ext} = \\frac{\\text{Total Fragmented Memory}}{\\text{Total Memory}} $$\n    代入我们推导出的表达式：\n    $$ F_{ext} = \\frac{n \\times a}{M} $$\n    我们知道 $M = n(a+b)$。将其代入方程中：\n    $$ F_{ext} = \\frac{n \\times a}{n(a+b)} $$\n\n10. 整数 $n$ 同时出现在分子和分母中，因此可以消掉。\n    $$ F_{ext} = \\frac{a}{a+b} $$\n这个表达式表示了在指定对抗性模式下的最坏情况外部碎片率。它是一个关于 $a$ 和 $b$ 的闭式解析函数，符合要求。“最坏情况”是通过这个特定的分配和释放序列实现的，该序列最大化了小的、不可用空洞的数量，然后请求一个刚好大到无法放入任何一个空洞中的块。在范围 $(a, a+b]$ 内对 $c$ 的任何选择都会导致相同的碎片率，因为关键特征是 $c>a$。",
            "answer": "$$\n\\boxed{\\frac{a}{a+b}}\n$$"
        }
    ]
}