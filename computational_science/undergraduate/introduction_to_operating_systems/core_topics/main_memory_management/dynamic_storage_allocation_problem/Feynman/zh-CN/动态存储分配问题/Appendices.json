{
    "hands_on_practices": [
        {
            "introduction": "在动态内存分配中，我们请求的内存大小（有效载荷）只是冰山一角。为了有效管理内存，分配器必须在每个内存块中嵌入额外的数据，如头部和尾部，并满足特定的硬件对齐要求。 这个练习将带你深入一个内存块的内部结构，通过精确计算由元数据和对齐填充所引起的内部碎片，让你亲手量化这些“隐藏”的开销。",
            "id": "3637495",
            "problem": "某个操作系统课程中使用的动态内存分配器，其实现的内存块带有显式元数据和严格对齐要求。每个已分配的块包含一个大小为 $h$ 的头部，紧邻在有效载荷之前；以及一个大小为 $f$ 的尾部，紧跟在有效载荷之后。分配器必须确保每个有效载荷的起始地址与对齐量子 $a$ 对齐。分配器在一个初始为空的堆上运行，该堆的基地址与 $a$ 对齐，并且它会连续放置内存块，连续的块之间没有间隙。为了在所有后续分配中保持有效载荷对齐，分配器可以在头部之后立即插入最小非负字节数的填充，并可能在块的末尾添加最小非负字节数的填充，以使总块大小是 $a$ 的倍数。\n\n使用以下参数：头部大小 $h = 12$ 字节，尾部大小 $f = 4$ 字节，对齐量子 $a = 16$ 字节。考虑一个包含5个分配请求的序列，其有效载荷大小为 $\\{s_1, s_2, s_3, s_4, s_5\\} = \\{13, 64, 7, 33, 2\\}$ 字节。\n\n从以下基本定义出发：(i) 一个块的内部碎片是指该块内不属于所请求有效载荷的字节数；(ii) 对齐意味着有效载荷的起始地址与 $0$ 模 $a$ 同余。请确定所有5个块中，不属于任何有效载荷的字节总数，这些字节完全由元数据和所述的对齐填充相互作用产生（即，计算所有头部和尾部字节、为实现对齐而在有效载荷前插入的任何填充，以及为将块大小向上取整为 $a$ 的倍数而在块末尾添加的任何填充）。\n\n将你的最终答案表示为整数个字节。无需四舍五入。最终数值答案的单位应为字节。",
            "solution": "问题陈述已经过验证，被认为是科学合理的、定义明确的且客观的。它为解决操作系统动态内存分配研究中的一个标准问题提供了一套完整且一致的参数和约束。\n\n该问题要求计算一个包含5次内存分配的序列中，非有效载荷字节的总数。这些非有效载荷字节包括块的元数据（头部和尾部）以及为满足对齐约束所需的任何填充。\n\n给定的参数如下：\n- 头部大小：$h = 12$ 字节\n- 尾部大小：$f = 4$ 字节\n- 对齐量子：$a = 16$ 字节\n- 5个请求的有效载荷大小序列：$\\{s_1, s_2, s_3, s_4, s_5\\} = \\{13, 64, 7, 33, 2\\}$ 字节。\n\n让我们分析单个已分配块的结构。一个块由一个头部、可选的有效载荷前填充、有效载荷本身、一个尾部和可选的有效载荷后填充组成。每个块的总大小，包括所有组件，必须是对齐量子 $a$ 的倍数。\n\n分配器从与 $a$ 对齐的堆基地址开始，顺序放置块。设块 $i$ 的起始地址为 $B_i$。\n对于第一个块，$B_1$ 是堆基地址，因此 $B_1 \\equiv 0 \\pmod a$。\n任何块 $i$ 的总大小（我们记作 $S_i$）都要求是 $a$ 的倍数。下一个块，即块 $i+1$，将从地址 $B_{i+1} = B_i + S_i$ 开始。由于 $B_i$ 是 $a$ 的倍数，而 $S_i$ 也是 $a$ 的倍数，所以 $B_{i+1}$ 也将是 $a$ 的倍数。通过归纳法可知，每个块的起始地址 $B_i$ 都与量子 $a$ 对齐。\n\n现在，让我们为给定的有效载荷大小 $s_i$ 确定块的组成部分。\n1.  **头部**：块从地址 $B_i$ 开始，有一个大小为 $h$ 的头部。头部结束于地址 $B_i + h - 1$。\n2.  **有效载荷前填充**：有效载荷必须从地址 $P_i$ 开始，该地址是 $a$ 的倍数。此地址必须大于或等于紧跟在头部之后的地址，即 $B_i + h$。由于 $B_i \\equiv 0 \\pmod a$，我们需要找到大于或等于 $B_i + h$ 的最小 $a$ 的倍数。这等同于找到要添加到 $h$ 的最小非负填充量 $p_{\\text{pre},i}$，使得 $h + p_{\\text{pre},i}$ 是 $a$ 的倍数。此填充对于所有块都是恒定的，因为它仅取决于 $h$ 和 $a$。\n    有效载荷前填充的量由公式 $(a - (h \\pmod a)) \\pmod a$ 给出。\n    代入给定值：\n    $$p_{\\text{pre}} = (16 - (12 \\pmod{16})) \\pmod{16} = (16 - 12) \\pmod{16} = 4 \\text{ bytes}$$\n    所以，对于每个块，在头部和有效载荷之间插入 $4$ 字节的填充。块 $i$ 的有效载荷从地址 $P_i = B_i + h + p_{\\text{pre}} = B_i + 12 + 4 = B_i + 16$ 开始，该地址与 $a$ 对齐。\n\n3.  **有效载荷和尾部**：放置大小为 $s_i$ 的有效载荷，然后是一个大小为 $f$ 的尾部。\n\n4.  **总块大小和有效载荷后填充**：到目前为止，在最终取整之前，块的大小是头部、有效载荷前填充、有效载荷和尾部大小的总和。我们称这个未取整的大小为 $U_i$。\n    $$U_i = h + p_{\\text{pre}} + s_i + f = 12 + 4 + s_i + 4 = 20 + s_i$$\n    块的总大小 $S_i$ 必须是大于或等于 $U_i$ 的最小 $a$ 的倍数。这通过将 $U_i$ 向上取整到最接近的 $a$ 的倍数来计算。\n    $$S_i = a \\cdot \\left\\lceil \\frac{U_i}{a} \\right\\rceil = 16 \\cdot \\left\\lceil \\frac{20 + s_i}{16} \\right\\rceil$$\n    有效载荷后填充为 $p_{\\text{post},i} = S_i - U_i$。\n\n每个块我们关心的量是非有效载荷字节数 $N_i$。这是块的总大小减去有效载荷的大小。\n$$N_i = S_i - s_i$$\n这等同于头部、尾部以及两个填充部分大小的总和：$N_i = h + f + p_{\\text{pre}} + p_{\\text{post},i}$。\n\n我们现在为5个分配请求中的每一个计算 $N_i$。\n\n**块 1：** $s_1 = 13$ 字节\n- 未取整大小：$U_1 = 20 + 13 = 33$ 字节。\n- 总块大小：$S_1 = 16 \\cdot \\lceil \\frac{33}{16} \\rceil = 16 \\cdot 3 = 48$ 字节。\n- 非有效载荷字节数：$N_1 = S_1 - s_1 = 48 - 13 = 35$ 字节。\n\n**块 2：** $s_2 = 64$ 字节\n- 未取整大小：$U_2 = 20 + 64 = 84$ 字节。\n- 总块大小：$S_2 = 16 \\cdot \\lceil \\frac{84}{16} \\rceil = 16 \\cdot 6 = 96$ 字节。\n- 非有效载荷字节数：$N_2 = S_2 - s_2 = 96 - 64 = 32$ 字节。\n\n**块 3：** $s_3 = 7$ 字节\n- 未取整大小：$U_3 = 20 + 7 = 27$ 字节。\n- 总块大小：$S_3 = 16 \\cdot \\lceil \\frac{27}{16} \\rceil = 16 \\cdot 2 = 32$ 字节。\n- 非有效载荷字节数：$N_3 = S_3 - s_3 = 32 - 7 = 25$ 字节。\n\n**块 4：** $s_4 = 33$ 字节\n- 未取整大小：$U_4 = 20 + 33 = 53$ 字节。\n- 总块大小：$S_4 = 16 \\cdot \\lceil \\frac{53}{16} \\rceil = 16 \\cdot 4 = 64$ 字节。\n- 非有效载荷字节数：$N_4 = S_4 - s_4 = 64 - 33 = 31$ 字节。\n\n**块 5：** $s_5 = 2$ 字节\n- 未取整大小：$U_5 = 20 + 2 = 22$ 字节。\n- 总块大小：$S_5 = 16 \\cdot \\lceil \\frac{22}{16} \\rceil = 16 \\cdot 2 = 32$ 字节。\n- 非有效载荷字节数：$N_5 = S_5 - s_5 = 32 - 2 = 30$ 字节。\n\n所有5个块的非有效载荷字节总数是各个非有效载荷量之和：\n$$N_{\\text{total}} = N_1 + N_2 + N_3 + N_4 + N_5$$\n$$N_{\\text{total}} = 35 + 32 + 25 + 31 + 30$$\n$$N_{\\text{total}} = 153 \\text{ bytes}$$",
            "answer": "$$\\boxed{153}$$"
        },
        {
            "introduction": "理解了单个内存块的开销后，我们把视野扩大到整个堆内存的管理。实现一个内存分配器是理解其行为的最佳方式。 在这个实践中，你将构建一个“首次适应”分配器，并观察在一系列分配和释放操作后，内存空间如何逐渐变得零散，最终形成“外部碎片”——即总有足够空闲空间，却因不连续而无法满足新的请求。",
            "id": "3239139",
            "problem": "设计并实现一个模拟的堆内存管理器，该管理器使用首次适应策略来满足分配请求。堆被建模为一个连续的地址数组，并被分割成多个块。每个块都有一个以抽象单位计量的大小和一个表示其是已分配还是空闲的状态。该分配器必须实现在分配时的块分割，以及在释放时合并相邻的空闲块。首次适应策略从堆的起始位置开始搜索，并选择第一个大小至少等于请求大小的空闲块。如果所选的空闲块大于请求的大小，它将被分割成一个大小为所请求大小的已分配块和一个代表剩余容量的空闲块。如果一个块的大小恰好等于请求的大小，它将被直接标记为已分配，而不进行分割。\n\n基本原理：\n- 堆内存是一个连续的地址空间；连续的分配请求需要一个单一且不间断的地址范围。\n- 首次适应是一种广泛使用的堆分配策略：一个大小为 $s$ 的请求从头开始扫描空闲列表，直到找到第一个大小至少为 $s$ 的空闲块，并将分配放置在那里。\n- 外部碎片是指总空闲内存足以满足一个请求，但由于空闲内存分散在多个非连续的块中而无法使用的现象。在本问题中，外部碎片的一个量化度量是最大连续空闲区域（即空闲块）的数量以及这类区域中最大的那个的大小。\n\n您必须：\n- 实现一个具有以下操作的首次适应分配器：\n  - 如果存在合适的空闲块，则分配一个大小为 $s$ 的块。返回一个唯一指向该已分配块的句柄（一个标识符）。如果没有合适的空闲块，则分配失败。\n  - 通过句柄释放一个先前分配的块，并将其与任何相邻的空闲块合并，以恢复最大的连续空闲区域。\n- 所有块都使用精确的整数大小。本问题中没有物理单位。\n- 提供能够在任何时刻计算以下指标的函数：\n  - 空闲块的数量（每个块都是一个最大的连续空闲区域）。\n  - 最大空闲块的大小。\n  - 总空闲内存，计算方式为所有空闲块大小的总和。\n- 实现一个测试，该测试在经过一系列特定的分配和释放操作后，尝试进行一次大小为 $s^\\ast$ 的最终分配，报告在首次适应策略下该分配是否会成功，然后立即撤销该尝试，使堆恢复到之前的状态。\n\n关于最坏情况外部碎片的核心要求：\n- 构建一个请求序列，该序列在首次适应策略下产生数量级为 $O(N)$ 的最坏情况外部碎片。具体来说，对于一个容量至少为 $3N$ 个单位的堆，执行 $2N$ 次大小为 1 的分配，然后释放这 $2N$ 个块中每隔一个的已分配块（例如，按照分配顺序，释放位于位置 $0,2,4,\\ldots,2N-2$ 的块）。这会产生 $N$ 个大小为 1 的空闲块与 $N$ 个大小为 1 的已分配块交错排列，空闲块之间没有邻接关系，因此合并操作无法减少它们的数量。在形成这种模式后，尝试分配一个大小为 $N$ 的单个块，并报告该分配是否会成功。\n\n测试套件：\n- 案例 1：堆大小为 30，$N=10$。执行上述 $O(N)$ 碎片化构造。尝试一次大小为 10 的最终分配。\n- 案例 2：堆大小为 3，$N=1$。执行相同的构造，然后尝试一次大小为 1 的最终分配。\n- 案例 3：堆大小为 12。分配 12 个大小为 1 的块，然后全部释放，最后尝试一次大小为 12 的最终分配。\n- 案例 4：堆大小为 20。顺序分配大小为 $[3,2,5,2,3,2,1,2]$ 的块，然后释放第 2、第 4、第 6 和第 8 个已分配的块（这些块的大小均为 2），最后尝试一次大小为 5 的最终分配。\n\n对于每个测试案例，按以下确切顺序生成结果列表：\n- 空闲块的数量（一个整数）。\n- 最大空闲块的大小（一个整数）。\n- 总空闲内存（一个整数）。\n- 最终尝试的分配是否成功（一个布尔值）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个由方括号括起来的逗号分隔列表。例如，输出应类似于 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$，不含空格。\n\n您的实现必须是自包含和确定性的，无需任何输入，并精确生成一行符合指定格式的输出。",
            "solution": "问题陈述在形式上是有效的。它以计算机科学原理为科学基础，特别是动态内存管理算法。该问题提法明确，为进行确定性模拟提供了所有必要的数据、约束和定义。其语言客观且无歧义。因此，我们可以着手提供解决方案。\n\n设计一个基于首次适应策略的模拟堆内存管理器，需要一种能够高效表示内存被分割成空闲块和已分配块的数据结构，并支持分配（带块分割）和释放（带块合并）的操作。\n\n双向链表是实现此目的的典范数据结构。列表中的每个节点代表一个连续的内存块。使用指向内存顺序中前一个和后一个块的指针，可以实现高效遍历，并且关键的是，可以实现对相邻块的常数时间访问，这对于释放过程中的合并操作至关重要。\n\n在我们的模型中，每个块将是一个具有以下属性的对象：\n- `$s$`: 表示块大小的整数。\n- `$is\\_free$`: 一个布尔标志，如果块可用于分配，则为 `True`，否则为 `False`。\n- `$start\\_addr$`: 块在堆内的起始地址（偏移量），提供唯一的空间参考。\n- `$prev\\_block$`: 对堆内存空间中逻辑上在前一个块的引用。\n- `$next\\_block$`: 对堆内存空间中逻辑上在后一个块的引用。\n\n堆管理器本身初始化时包含一个跨越整个堆容量的单一空闲块。分配情况通过一个字典进行跟踪，该字典将成功分配时返回的唯一整数句柄映射到相应的块对象。\n\n核心操作实现如下：\n\n**1. 分配 (`allocate(s)`)**\n首次适应算法要求从堆的起始位置进行线性扫描。我们从头部开始遍历块的双向链表，寻找第一个满足两个条件的块 `$b$`：`$b.is\\_free` 为 `True`，且其大小 `$b.s$` 大于或等于请求的大小 `$s$`。\n\n- 如果找不到这样的块，说明可用内存过于碎片化或不足，分配请求失败。\n- 如果找到了一个合适的块 `$b$`：\n    - **精确匹配**：如果 `$b.s = s$`，该块仅被标记为已分配（`$b.is\\_free = False$`）。列表无需进行结构性更改。\n    - **分割**：如果 `$b.s > s$`，该块必须被分割。原始块 `$b$` 的大小被调整为 `$s$` 并标记为已分配。一个大小为 `$b.s - s$` 的新空闲块紧随其后在列表中被创建。此操作涉及更新 `$b$` 及其原始后继节点的指针，以插入新的剩余空闲块，从而保持双向链表的完整性。\n\n系统会生成一个唯一的句柄并与已分配的块关联，然后将其返回给调用者。\n\n**2. 释放 (`free(handle)`)**\n释放操作首先使用提供的 `$handle$` 来检索要释放的块。该块的状态被更改为 `$is\\_free = True$`。关键步骤是合并，它通过将相邻的空闲块合并成一个更大的单一空闲块来对抗外部碎片。\n\n在释放一个块 `$B$` 时，我们检查它的邻居——前一个块 `$A$` 和后一个块 `$C$`。\n- 如果 `$C$` 存在且为空闲，则 `$B$` 和 `$C$` 被合并。这通过将 `$C$'s` 的大小加到 `$B's$` 的大小上，并更新 `$B's$` `next_block` 指针以绕过 `$C$` 来实现，从而有效地将 `$C$` 从列表中移除。\n- 随后，如果 `$A$` 存在且为空闲，那么现在可能变得更大的块 `$B$` 将被合并到 `$A$` 中。这通过将 `$B's$` 的大小加到 `$A's$` 的大小上，并更新 `$A's$` `next_block` 指针以绕过 `$B$` 来完成。\n\n这种双向检查确保一个新释放的块会与其所有相邻的空闲邻居合并，从而在该位置恢复可能的最大连续空闲空间。\n\n**3. 指标与测试**\n所需的指标——空闲块数量、最大空闲块大小和总空闲内存——通过直接遍历链表来计算，对 `$is\\_free` 为 `True` 的块进行计数、求最大值和总和的累积。\n\n用于测试大小为 `$s^*$` 的潜在分配的函数是以事务方式实现的。它首先使用标准的 `allocate` 方法尝试分配。如果分配失败，则返回 `False`。如果成功，它会获取一个句柄，返回 `True`，并立即用该句柄调用 `free` 方法。正如我们的设计所确立的，包含合并逻辑的 `free` 操作能正确地逆转由分割或精确匹配分配所引起的状态变化，从而将堆恢复到测试前的精确状态。\n\n提供的测试案例旨在验证分配器行为的特定方面。案例 `$3$` 展示了完美的合并。案例 `$4$` 例证了外部碎片现象，即总空闲内存超过请求大小，但分配仍然失败。案例 `$1$` 和 `$2$` 为首次适应算法构建了一种特定的最坏情况碎片模式，其中大量小的、非连续的空闲块使得分配器尽管有充足的总空闲空间也无法满足一个大的请求。我们的实现正确地模拟了这些现象。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the heap memory manager simulation problem.\n    \"\"\"\n\n    class Block:\n        \"\"\"Represents a block of memory in the heap.\"\"\"\n        def __init__(self, size, start_addr):\n            self.size = size\n            self.is_free = True\n            self.start_addr = start_addr\n            self.prev_block = None\n            self.next_block = None\n\n        def __repr__(self):\n            state = \"F\" if self.is_free else \"A\"\n            return f\"[{state}({self.size})@{self.start_addr}]\"\n\n    class HeapManager:\n        \"\"\"Implements a first-fit heap memory manager.\"\"\"\n        def __init__(self, total_size):\n            self.total_size = total_size\n            self.head = Block(total_size, 0)\n            self.allocations = {}\n            self.next_handle = 1\n\n        def allocate(self, req_size):\n            \"\"\"Allocates a block of memory using first-fit strategy.\"\"\"\n            if req_size == 0:\n                return None\n            \n            current_block = self.head\n            while current_block:\n                if current_block.is_free and current_block.size >= req_size:\n                    # Found a suitable block\n                    if current_block.size > req_size:\n                        # Split the block\n                        new_free_block = Block(\n                            size=current_block.size - req_size,\n                            start_addr=current_block.start_addr + req_size\n                        )\n                        new_free_block.prev_block = current_block\n                        new_free_block.next_block = current_block.next_block\n                        \n                        if current_block.next_block:\n                            current_block.next_block.prev_block = new_free_block\n                        \n                        current_block.size = req_size\n                        current_block.next_block = new_free_block\n\n                    # Mark the block as allocated\n                    current_block.is_free = False\n                    handle = self.next_handle\n                    self.allocations[handle] = current_block\n                    self.next_handle += 1\n                    return handle\n\n                current_block = current_block.next_block\n            \n            return None # Allocation failed\n\n        def free(self, handle):\n            \"\"\"Frees a previously allocated block and coalesces neighbors.\"\"\"\n            if handle not in self.allocations:\n                return\n\n            block_to_free = self.allocations.pop(handle)\n            block_to_free.is_free = True\n\n            # Coalesce with next block\n            if block_to_free.next_block and block_to_free.next_block.is_free:\n                next_b = block_to_free.next_block\n                block_to_free.size += next_b.size\n                block_to_free.next_block = next_b.next_block\n                if next_b.next_block:\n                    next_b.next_block.prev_block = block_to_free\n\n            # Coalesce with previous block\n            if block_to_free.prev_block and block_to_free.prev_block.is_free:\n                prev_b = block_to_free.prev_block\n                prev_b.size += block_to_free.size\n                prev_b.next_block = block_to_free.next_block\n                if block_to_free.next_block:\n                    block_to_free.next_block.prev_block = prev_b\n        \n        def get_metrics(self):\n            \"\"\"Computes the required heap metrics.\"\"\"\n            num_free_blocks = 0\n            max_free_block_size = 0\n            total_free_memory = 0\n            \n            current_block = self.head\n            while current_block:\n                if current_block.is_free:\n                    num_free_blocks += 1\n                    total_free_memory += current_block.size\n                    if current_block.size > max_free_block_size:\n                        max_free_block_size = current_block.size\n                current_block = current_block.next_block\n            \n            return num_free_blocks, max_free_block_size, total_free_memory\n\n        def test_allocate(self, req_size):\n            \"\"\"Tests if an allocation would succeed and reverts the heap state.\"\"\"\n            handle = self.allocate(req_size)\n            if handle is None:\n                return False\n            else:\n                self.free(handle)\n                return True\n\n    all_results = []\n\n    # Case 1\n    heap1 = HeapManager(30)\n    n1 = 10\n    handles1 = [heap1.allocate(1) for _ in range(2 * n1)]\n    for i in range(0, 2 * n1, 2):\n        heap1.free(handles1[i])\n    metrics1 = heap1.get_metrics()\n    success1 = heap1.test_allocate(10)\n    all_results.append([*metrics1, success1])\n\n    # Case 2\n    heap2 = HeapManager(3)\n    n2 = 1\n    handles2 = [heap2.allocate(1) for _ in range(2 * n2)]\n    for i in range(0, 2 * n2, 2):\n        heap2.free(handles2[i])\n    metrics2 = heap2.get_metrics()\n    success2 = heap2.test_allocate(1)\n    all_results.append([*metrics2, success2])\n    \n    # Case 3\n    heap3 = HeapManager(12)\n    handles3 = [heap3.allocate(1) for _ in range(12)]\n    for handle in handles3:\n        heap3.free(handle)\n    metrics3 = heap3.get_metrics()\n    success3 = heap3.test_allocate(12)\n    all_results.append([*metrics3, success3])\n\n    # Case 4\n    heap4 = HeapManager(20)\n    alloc_sizes = [3, 2, 5, 2, 3, 2, 1, 2]\n    handles4 = [heap4.allocate(size) for size in alloc_sizes]\n    handles_to_free_indices = [1, 3, 5, 7] # 2nd, 4th, 6th, 8th (0-indexed)\n    for index in handles_to_free_indices:\n        heap4.free(handles4[index])\n    metrics4 = heap4.get_metrics()\n    success4 = heap4.test_allocate(5)\n    all_results.append([*metrics4, success4])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    print(f\"[[{result_str}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当外部碎片化问题变得严重时，内存整理（compaction）是终极解决方案，但它并非没有代价。 这个练习模拟了内存整理过程，将所有活动内存块移动到一端，从而合并所有碎片化的空闲空间。通过这个练习，你将学会如何量化整理过程的两个关键指标：基于内存带宽的性能成本，以及碎片化程度的显著改善。",
            "id": "3637454",
            "problem": "一个操作系统 (OS) 管理一个总大小为 $64$ MiB 的连续随机存取存储器 (RAM) 区域，其字节地址从基地址 $0$ 开始计算。该内存当前包含以下活动分配，由它们的起始偏移量（以 MiB 为单位，从基地址算起）和大小（以 MiB 为单位）指定：\n分配 $A_{1}$：起始 $4$，大小 $6$；分配 $A_{2}$：起始 $12$，大小 $8$；分配 $A_{3}$：起始 $22$，大小 $2$；分配 $A_{4}$：起始 $28$，大小 $10$；分配 $A_{5}$：起始 $40$，大小 $5$；分配 $A_{6}$：起始 $48$，大小 $4$；分配 $A_{7}$：起始 $56$，大小 $3$。\n\n所有其他内存均为空闲。空闲区间（以 MiB 为单位）为 $[0,4)$, $[10,12)$, $[20,22)$, $[24,28)$, $[38,40)$, $[45,48)$, $[52,56)$ 和 $[59,64)$。\n\n从动态存储分配中外部碎片的基本定义和数据传输带宽的定义出发，设计一种紧凑策略，该策略重新定位所有活动分配以形成一个单一的连续空闲区域，保持分配按其原始起始偏移量非递减的顺序，并确保在重定位过程中没有重叠。在此策略下，确定：\n\n1. 重定位成本 $R$，定义为完成紧凑所需的总时间（以秒为单位），假设重定位带宽是统一的 $B = 64 \\times 2^{20}$ 字节/秒。将 $R$ 以秒表示。\n\n2. 外部碎片的减少量 $\\Delta F$，其中碎片度量 $F$ 定义为总空闲内存中，不属于最大连续空闲块的部分所占的比例，即 $F = 1 - \\frac{\\text{最大空闲块的大小}}{\\text{总空闲内存}}$。计算 $\\Delta F = F_{\\text{before}} - F_{\\text{after}}$ 作为一个纯数（无量纲）。\n\n提供 $R$ 和 $\\Delta F$ 的精确值，不要四舍五入。最终答案必须以包含 $R$ 和 $\\Delta F$ 的行矩阵形式给出。",
            "solution": "问题陈述已经过验证，被认为是自洽的、有科学依据且适定的。所有提供的数据都是一致的，足以推导出唯一的解。内存紧凑、外部碎片和数据传输带宽的概念是操作系统中的标准主题，其在问题中的定义是形式化且明确的。因此，我们可以着手求解。\n\n问题要求两个量：重定位成本 $R$ 和外部碎片的减少量 $\\Delta F$。我们将依次解决这两个问题。\n\n首先，我们验证内存布局。总 RAM 大小为 $S_{RAM} = 64$ MiB。\n活动分配如下：\n$A_{1}$：起始 $4$ MiB，大小 $6$ MiB $\\rightarrow$ 区间 $[4, 10)$\n$A_{2}$：起始 $12$ MiB，大小 $8$ MiB $\\rightarrow$ 区间 $[12, 20)$\n$A_{3}$：起始 $22$ MiB，大小 $2$ MiB $\\rightarrow$ 区间 $[22, 24)$\n$A_{4}$：起始 $28$ MiB，大小 $10$ MiB $\\rightarrow$ 区间 $[28, 38)$\n$A_{5}$：起始 $40$ MiB，大小 $5$ MiB $\\rightarrow$ 区间 $[40, 45)$\n$A_{6}$：起始 $48$ MiB，大小 $4$ MiB $\\rightarrow$ 区间 $[48, 52)$\n$A_{7}$：起始 $56$ MiB，大小 $3$ MiB $\\rightarrow$ 区间 $[56, 59)$\n\n已分配内存的总大小是所有分配大小的总和：\n$$S_{alloc} = 6 + 8 + 2 + 10 + 5 + 4 + 3 = 38 \\text{ MiB}$$\n\n空闲区间如题目所给，为 $[0,4)$, $[10,12)$, $[20,22)$, $[24,28)$, $[38,40)$, $[45,48)$, $[52,56)$ 和 $[59,64)$。\n空闲内存的总大小是这些空闲块大小的总和：\n$$S_{free} = (4-0) + (12-10) + (22-20) + (28-24) + (40-38) + (48-45) + (56-52) + (64-59)$$\n$$S_{free} = 4 + 2 + 2 + 4 + 2 + 3 + 4 + 5 = 26 \\text{ MiB}$$\n\n已分配内存和空闲内存的总和是 $S_{alloc} + S_{free} = 38 + 26 = 64$ MiB，这与总 RAM 大小相符，证实了所提供数据的一致性。\n\n**1. 重定位成本 $R$ 的计算**\n\n紧凑策略是重新定位所有活动分配，使其在内存区域的起始处（从地址 $0$ 开始）形成一个单一的连续块，并保持其相对顺序。重定位成本 $R$ 是移动数据所需的总时间。该时间由移动的数据总量和内存带宽决定。\n\n该策略规定，紧凑后，所有分配将从地址 $0$ 开始连续排列。新的布局将是：\n$A_{1}$ 位于 $[0, 6)$\n$A_{2}$ 位于 $[6, 14)$\n$A_{3}$ 位于 $[14, 16)$\n$A_{4}$ 位于 $[16, 26)$\n$A_{5}$ 位于 $[26, 31)$\n$A_{6}$ 位于 $[31, 35)$\n$A_{7}$ 位于 $[35, 38)$\n\n第一个分配 $A_{1}$ 的原始起始地址是 $4$ MiB，而不是 $0$ MiB。因此，$A_{1}$ 必须被移动到其在地址 $0$ 的新位置。为了保持连续性和相对顺序，所有后续的分配也必须被移动到它们的新位置。因此，需要重定位的数据总量是所有活动分配大小的总和。\n\n需要移动的总数据 = $S_{alloc} = 38$ MiB。\n为了计算时间，我们必须用一致的单位来表示数据大小和带宽。\n$1$ MiB = $2^{20}$ 字节。\n需要移动的总数据 = $38 \\times 2^{20}$ 字节。\n\n给定的重定位带宽是 $B = 64 \\times 2^{20}$ 字节/秒。\n\n重定位成本 $R$ 是移动的总数据量与带宽的比值：\n$$R = \\frac{\\text{需要移动的总数据}}{B} = \\frac{38 \\times 2^{20} \\text{ 字节}}{64 \\times 2^{20} \\text{ 字节/秒}}$$\n$2^{20}$ 项可以消去：\n$$R = \\frac{38}{64} = \\frac{19}{32} \\text{ 秒}$$\n\n**2. 外部碎片减少量 $\\Delta F$ 的计算**\n\n碎片度量定义为 $F = 1 - \\frac{\\text{最大空闲块的大小}}{\\text{总空闲内存}}$。碎片的减少量是 $\\Delta F = F_{\\text{before}} - F_{\\text{after}}$。\n\n首先，我们计算 $F_{\\text{before}}$。\n紧凑前各空闲块的大小分别为 $4$、$2$、$2$、$4$、$2$、$3$、$4$ 和 $5$ MiB。\n最大空闲块的大小是这些值的最大值：\n$$\\text{最大空闲块的大小}_{\\text{before}} = \\max(\\{4, 2, 2, 4, 2, 3, 4, 5\\}) = 5 \\text{ MiB}$$\n总空闲内存为 $S_{free} = 26$ MiB。\n$$F_{\\text{before}} = 1 - \\frac{5 \\text{ MiB}}{26 \\text{ MiB}} = 1 - \\frac{5}{26} = \\frac{21}{26}$$\n\n接下来，我们计算 $F_{\\text{after}}$。\n紧凑后，所有已分配的块在内存的起始位置形成一个大小为 $S_{alloc} = 38$ MiB 的单一连续段。这使得所有空闲空间在内存的末尾合并成一个单一的连续块。\n这个单一空闲块的大小等于总空闲内存，即 $S_{free} = 26$ MiB。\n因此，紧凑后最大空闲块的大小是 $26$ MiB。\n$$F_{\\text{after}} = 1 - \\frac{26 \\text{ MiB}}{26 \\text{ MiB}} = 1 - 1 = 0$$\n\n最后，我们计算碎片的减少量 $\\Delta F$：\n$$\\Delta F = F_{\\text{before}} - F_{\\text{after}} = \\frac{21}{26} - 0 = \\frac{21}{26}$$\n\n所求的两个值是 $R = \\frac{19}{32}$ 和 $\\Delta F = \\frac{21}{26}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{19}{32}  \\frac{21}{26} \\end{pmatrix}}$$"
        }
    ]
}