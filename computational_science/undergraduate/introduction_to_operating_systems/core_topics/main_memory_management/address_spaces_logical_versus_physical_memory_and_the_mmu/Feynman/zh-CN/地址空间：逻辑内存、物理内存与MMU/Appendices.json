{
    "hands_on_practices": [
        {
            "introduction": "虚拟地址空间的大小并非任意设定，它是由页表设计的各项参数（如页大小 $P$、页表项大小和页表层级 $L$）共同决定的。本练习将指导你从第一性原理出发，推导不同架构下的虚拟地址宽度，让你能够亲手计算并量化不同页表设计对虚拟地址空间以及内存管理开销的影响。通过对比两种假设的体系结构，你将更深刻地理解在设计内存管理单元（MMU）时，空间效率（页表开销）和内存利用率（内部碎片）之间的基本权衡。",
            "id": "3620292",
            "problem": "一个计算机系统使用由内存管理单元（MMU）实现的请求分页式虚拟内存。MMU 使用统一的多级页表方案将进程的逻辑（虚拟）地址转换为物理地址。每一级页表都是一个页面大小的、由固定大小的页表条目组成的数组。对于一个给定的架构，设 $L$ 表示页表级数（包括叶级），设 $E$ 表示每个页表页的条目数，设 $P$ 表示页面大小（以字节为单位）。内存引用的虚拟地址被分割为一个页面偏移量和 $L$ 个索引，每级一个索引，用于选择该级中对应的条目。\n\n提出了两种架构：\n\n- 架构 $\\mathsf{A}$：$L_{\\mathsf{A}} = 4$，$P_{\\mathsf{A}} = 4 \\times 2^{10}$ 字节，每个页表条目为 $8$ 字节，其设计选择为 $E_{\\mathsf{A}} = P_{\\mathsf{A}} / 8$。\n\n- 架构 $\\mathsf{B}$：$L_{\\mathsf{B}} = 3$，$P_{\\mathsf{B}} = 16 \\times 2^{10}$ 字节，每个页表条目为 $8$ 字节，其设计选择为 $E_{\\mathsf{B}} = P_{\\mathsf{B}} / 8$。\n\n假设一个页表条目存储了足够的信息来定位下一级页表（或叶级的物理页面），并且除了所描述的多级方案外，没有硬件施加的限制。从分页的核心定义（页面偏移量、页号和多级索引）以及编码 $N$ 个不同值所需的位数是 $\\log_{2}(N)$ 这一事实出发，从第一性原理推导出每种架构的虚拟地址宽度。仅使用这些基本原理，不要假设或引用任何特定于架构的“快捷”公式。\n\n为了用具体数字来支持比较，考虑为一个进程映射一个大小为 $S = 256 \\times 2^{20}$ 字节的连续逻辑内存区域。对于每种架构，确定分配的最末级页表的数量、分配的上层页表的数量，以及总的页表内存开销（以字节为单位）。简要解释观察到的设计权衡（例如，对页表内存开销和内部碎片的影响）。\n\n你的最终答案仅报告架构 $\\mathsf{A}$ 和架构 $\\mathsf{B}$ 之间虚拟地址宽度的差异。将你的最终答案表示为一个整数位数。",
            "solution": "该问题是有效的，因为它在科学上基于虚拟内存管理的原理，定义明确并提供了所有必要的信息，而且陈述客观。我们可以从第一性原理出发进行求解。\n\n一个虚拟地址被划分为两个主要部分：页号和页面偏移量。页面偏移量所需的位数 $w_{\\text{offset}}$ 由页面大小 $P$ 决定。为了唯一地寻址一个大小为 $P$ 字节的页面内的每个字节，我们需要 $w_{\\text{offset}} = \\log_2(P)$ 位。\n\n虚拟地址的其余位构成了页号。在具有 $L$ 级的多级分页方案中，页号被进一步细分为 $L$ 个索引，每个索引用于在特定级别的页表中选择一个条目。问题陈述，每个页表本身就是一个页面大小的数组，包含 $E$ 个页表条目。为了在页表中选择 $E$ 个条目中的一个，需要一个宽度为 $w_{\\text{index}} = \\log_2(E)$ 位的索引。\n\n由于方案是统一的，每个 $L$ 索引都具有相同的宽度 $w_{\\text{index}}$。页号的总宽度 $w_{\\text{pn}}$ 是所有索引宽度的总和，即 $w_{\\text{pn}} = L \\times w_{\\text{index}} = L \\times \\log_2(E)$。\n\n因此，总虚拟地址宽度 $w_{\\text{vaddr}}$ 是页号宽度和页面偏移量宽度的总和：\n$$w_{\\text{vaddr}} = w_{\\text{pn}} + w_{\\text{offset}} = (L \\times \\log_2(E)) + \\log_2(P)$$\n\n给定一个页表是页面大小的，并且每个页表条目（PTE）都有固定的大小。设 PTE 大小为 $S_{\\text{PTE}}$。每个页表的条目数 $E$ 是页面大小 $P$ 除以 PTE 大小 $S_{\\text{PTE}}$。\n$$E = \\frac{P}{S_{\\text{PTE}}}$$\n将此代入我们关于 $w_{\\text{vaddr}}$ 的方程中：\n$$w_{\\text{vaddr}} = L \\times \\log_2\\left(\\frac{P}{S_{\\text{PTE}}}\\right) + \\log_2(P)$$\n这是从第一性原理推导出的通用公式。现在我们将其应用于每个架构。\n\n对于两种架构，页表条目大小均为 $S_{\\text{PTE}} = 8$ 字节，即 $2^3$ 字节。\n\n**架构 $\\mathsf{A}$**\n给定的参数是：\n- 级数，$L_{\\mathsf{A}} = 4$。\n- 页面大小，$P_{\\mathsf{A}} = 4 \\times 2^{10} = 2^2 \\times 2^{10} = 2^{12}$ 字节。\n- 页表条目大小，$S_{\\text{PTE}} = 8 = 2^3$ 字节。\n\n首先，我们计算架构 $\\mathsf{A}$ 中每个页表页的条目数：\n$$E_{\\mathsf{A}} = \\frac{P_{\\mathsf{A}}}{S_{\\text{PTE}}} = \\frac{2^{12}}{2^3} = 2^9$$\n用于此页表索引的位数是：\n$$w_{\\text{index, A}} = \\log_2(E_{\\mathsf{A}}) = \\log_2(2^9) = 9 \\text{ 位}$$\n用于页面偏移量的位数是：\n$$w_{\\text{offset, A}} = \\log_2(P_{\\mathsf{A}}) = \\log_2(2^{12}) = 12 \\text{ 位}$$\n架构 $\\mathsf{A}$ 的总虚拟地址宽度是：\n$$w_{\\text{vaddr, A}} = (L_{\\mathsf{A}} \\times w_{\\text{index, A}}) + w_{\\text{offset, A}} = (4 \\times 9) + 12 = 36 + 12 = 48 \\text{ 位}$$\n\n**架构 $\\mathsf{B}$**\n给定的参数是：\n- 级数，$L_{\\mathsf{B}} = 3$。\n- 页面大小，$P_{\\mathsf{B}} = 16 \\times 2^{10} = 2^4 \\times 2^{10} = 2^{14}$ 字节。\n- 页表条目大小，$S_{\\text{PTE}} = 8 = 2^3$ 字节。\n\n首先，我们计算架构 $\\mathsf{B}$ 中每个页表页的条目数：\n$$E_{\\mathsf{B}} = \\frac{P_{\\mathsf{B}}}{S_{\\text{PTE}}} = \\frac{2^{14}}{2^3} = 2^{11}$$\n用于此页表索引的位数是：\n$$w_{\\text{index, B}} = \\log_2(E_{\\mathsf{B}}) = \\log_2(2^{11}) = 11 \\text{ 位}$$\n用于页面偏移量的位数是：\n$$w_{\\text{offset, B}} = \\log_2(P_{\\mathsf{B}}) = \\log_2(2^{14}) = 14 \\text{ 位}$$\n架构 $\\mathsf{B}$ 的总虚拟地址宽度是：\n$$w_{\\text{vaddr, B}} = (L_{\\mathsf{B}} \\times w_{\\text{index, B}}) + w_{\\text{offset, B}} = (3 \\times 11) + 14 = 33 + 14 = 47 \\text{ 位}$$\n\n**虚拟地址宽度的差异**\n差异为 $w_{\\text{vaddr, A}} - w_{\\text{vaddr, B}} = 48 - 47 = 1$ 位。\n\n**页表开销分析**\n我们现在分析映射一个大小为 $S = 256 \\times 2^{20}$ 字节的连续区域的内存开销。\n$S = 256 \\times 2^{20} = 2^8 \\times 2^{20} = 2^{28}$ 字节。\n\n**对于架构 $\\mathsf{A}$ ($P_{\\mathsf{A}} = 2^{12}$ 字节, $E_{\\mathsf{A}} = 2^9$ 条目/表, $L_{\\mathsf{A}}=4$ 级):**\n映射该区域所需的页面数：\n$$N_{\\text{pages, A}} = \\frac{S}{P_{\\mathsf{A}}} = \\frac{2^{28}}{2^{12}} = 2^{16} = 65536 \\text{ 页面}$$\n这些页面由最末级（叶级）页表中的条目指向。在一个4级方案中，这些是第4级页表。\n最末级（L4）页表的数量：\n$$N_{L4, \\mathsf{A}} = \\left\\lceil \\frac{N_{\\text{pages, A}}}{E_{\\mathsf{A}}} \\right\\rceil = \\left\\lceil \\frac{2^{16}}{2^9} \\right\\rceil = 2^7 = 128 \\text{ 个表}$$\n这 $128$ 个表需要在第3级页表中有 $128$ 个指针。\n第3级（L3）页表的数量：\n$$N_{L3, \\mathsf{A}} = \\left\\lceil \\frac{N_{L4, \\mathsf{A}}}{E_{\\mathsf{A}}} \\right\\rceil = \\left\\lceil \\frac{128}{2^9} \\right\\rceil = \\left\\lceil \\frac{2^7}{2^9} \\right\\rceil = 1 \\text{ 个表}$$\n这个单独的 L3 表需要在第2级页表中有一个指针。\n第2级（L2）页表的数量：\n$$N_{L2, \\mathsf{A}} = \\left\\lceil \\frac{N_{L3, \\mathsf{A}}}{E_{\\mathsf{A}}} \\right\\rceil = \\left\\lceil \\frac{1}{2^9} \\right\\rceil = 1 \\text{ 个表}$$\n这个单独的 L2 表需要在第1级页表中有一个指针。\n第1级（L1）页表（顶层目录）的数量：\n$$N_{L1, \\mathsf{A}} = \\left\\lceil \\frac{N_{L2, \\mathsf{A}}}{E_{\\mathsf{A}}} \\right\\rceil = \\left\\lceil \\frac{1}{2^9} \\right\\rceil = 1 \\text{ 个表}$$\n- 最末级页表数量：$128$。\n- 上层页表（L1, L2, L3）数量：$1 + 1 + 1 = 3$。\n- 分配的总页表数：$128 + 3 = 131$。\n- 总页表内存开销：$131 \\times P_{\\mathsf{A}} = 131 \\times 2^{12} = 131 \\times 4096 = 536576$ 字节。\n\n**对于架构 $\\mathsf{B}$ ($P_{\\mathsf{B}} = 2^{14}$ 字节, $E_{\\mathsf{B}} = 2^{11}$ 条目/表, $L_{\\mathsf{B}}=3$ 级):**\n映射该区域所需的页面数：\n$$N_{\\text{pages, B}} = \\frac{S}{P_{\\mathsf{B}}} = \\frac{2^{28}}{2^{14}} = 2^{14} = 16384 \\text{ 页面}$$\n这些页面由最末级（叶级）页表中的条目指向。在一个3级方案中，这些是第3级页表。\n最末级（L3）页表的数量：\n$$N_{L3, \\mathsf{B}} = \\left\\lceil \\frac{N_{\\text{pages, B}}}{E_{\\mathsf{B}}} \\right\\rceil = \\left\\lceil \\frac{2^{14}}{2^{11}} \\right\\rceil = 2^3 = 8 \\text{ 个表}$$\n这 $8$ 个表需要在第2级页表中有 $8$ 个指针。\n第2级（L2）页表的数量：\n$$N_{L2, \\mathsf{B}} = \\left\\lceil \\frac{N_{L3, \\mathsf{B}}}{E_{\\mathsf{B}}} \\right\\rceil = \\left\\lceil \\frac{8}{2^{11}} \\right\\rceil = 1 \\text{ 个表}$$\n这个单独的 L2 表需要在第1级页表中有一个指针。\n第1级（L1）页表（顶层目录）的数量：\n$$N_{L1, \\mathsf{B}} = \\left\\lceil \\frac{N_{L2, \\mathsf{B}}}{E_{\\mathsf{B}}} \\right\\rceil = \\left\\lceil \\frac{1}{2^{11}} \\right\\rceil = 1 \\text{ 个表}$$\n- 最末级页表数量：$8$。\n- 上层页表（L1, L2）数量：$1 + 1 = 2$。\n- 分配的总页表数：$8 + 2 = 10$。\n- 总页表内存开销：$10 \\times P_{\\mathsf{B}} = 10 \\times 2^{14} = 10 \\times 16384 = 163840$ 字节。\n\n**设计权衡简要说明**\n- **页表内存开销**：与架构 $\\mathsf{A}$（$536576$ 字节）相比，架构 $\\mathsf{B}$ 的页表内存开销（$163840$ 字节）显著更低。这是其更大的页面尺寸（$16 \\text{ KiB}$ 对比 $4 \\text{ KiB}$）和更浅的页表层次结构（$3$ 级对比 $4$ 级）的直接结果。更大的页面意味着覆盖相同内存区域所需的页面更少，这反过来又意味着需要更少的页表条目和更少的最末级页表。\n- **内部碎片**：在内部碎片方面，架构 $\\mathsf{A}$ 更为优越。由于其页面尺寸较小（$4 \\text{ KiB}$），内存分配末尾的平均浪费空间（平均 $2 \\text{ KiB}$）要小于架构 $\\mathsf{B}$ 的 $16 \\text{ KiB}$ 页面（平均 $8 \\text{ KiB}$）。对于具有许多小的、非页面对齐内存段的进程，这可能导致在架构 $\\mathsf{B}$ 中出现大量的内存浪费。\n这种权衡是经典的：较小的页面减少了内部碎片，但增加了页表的大小和对转译后备缓冲区（TLB）的压力；而较大的页面减少了页表开销并提高了 TLB 效率，但代价是增加了内部碎片。\n\n所要求的最终答案仅是虚拟地址宽度的差异。\n$$w_{\\text{vaddr, A}} - w_{\\text{vaddr, B}} = 48 - 47 = 1$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "理解了页表的静态结构后，我们来探讨其动态性能。地址翻译的速度至关重要，这正是TLB（转译后备缓冲器）的核心作用，但其有限的容量也使其成为性能瓶颈。本练习模拟了一种特定的内存访问模式——大步幅遍历，旨在揭示当程序的工作集（所需页面的集合）大小恰好超过TLB容量 $E$ 时，如何引发灾难性的性能下降，即“TLB颠簸”。你将通过分析计算出导致这种最差情况的最小步幅 $s$，从而直观感受应用程序访问模式与底层硬件交互的重要性。",
            "id": "3620213",
            "problem": "一个在带有内存管理单元（MMU）的机器上运行的单线程程序，使用跨步访问模式对一个连续数组进行重复的、环绕式的遍历。该数组是一个大小为 $(E+1)\\,p$ 字节的连续虚拟区域，其中 $E$ 是转译后备缓冲器（TLB）中的条目数，$p$ 是页面大小（以字节为单位）。数组的基地址与页面边界对齐。TLB 是具有 $E$ 个条目的全相联缓存，并使用最近最少使用（LRU）替换策略。数组的每个虚拟页面都映射到一个不同的物理页帧。中央处理器（CPU）生成以下虚拟地址序列\n$$\nv_k \\equiv v_0 + (k\\,s) \\bmod \\left((E+1)\\,p\\right),\n$$\n对于整数 $k \\ge 0$，其中 $s$ 是跨步（以字节为单位），$v_0$ 是数组的基虚拟地址（页面对齐）。数据缓存是单级的、全相联的，其容量足够大，以至于在遍历 $(E+1)$ 个页面的一个完整周期内，绝不会因为容量问题而驱逐任何缓存行，并且其行大小为 $b$ 字节，其中 $b$ 可以整除 $p$。\n\n请仅从虚拟内存页面、作为拥有 $E$ 个条目并采用 LRU 策略的近期虚拟到物理地址转换缓存的 TLB 的基本定义，以及上述访问序列出发，推理导出的虚拟页号序列如何依赖于跨步 $s$，以及这又如何决定了 TLB 的未命中行为。另外，请宏观地讨论缓存行大小 $b$ 如何与页面内的跨步 $s$ 相互作用，即使在给定的假设下，缓存并不约束 TLB 的行为。\n\n将“最大 TLB 颠簸”定义为稳态 TLB 未命中率等于 $1$（即，在预热之后，每次访问都是 TLB 未命中）。确定为此工作负载产生最大 TLB 颠簸的最小正跨步 $s$（以字节为单位）。用字节表示 $s$ 的最终答案。无需四舍五入。",
            "solution": "问题要求找出导致“最大 TLB 颠簸”的最小正跨步 $s$，“最大 TLB 颠簸”被定义为稳态转译后备缓冲器 (TLB) 未命中率为 $1$。我们必须分析跨步内存访问模式与采用最近最少使用 (LRU) 替换策略的全相联 TLB 之间的相互作用。\n\n首先，让我们建立基本原理。虚拟地址 $v$ 由内存管理单元 (MMU) 转换为物理地址。此过程涉及确定与 $v$ 对应的虚拟页号 (VPN)。给定页面大小为 $p$ 字节，所讨论的内存区域的基地址 $v_0$ 与页面对齐，则地址 $v$ 的 VPN 可以计算为 $\\text{VPN}(v) = \\lfloor (v - v_0) / p \\rfloor$。TLB 是一个缓存，用于存储最近的 VPN 到物理页帧的映射，以加速此转换。\n\n给定系统有一个包含 $E$ 个条目的 TLB。它是全相联的，并使用 LRU 替换策略。程序访问一个大小为 $(E+1)p$ 字节的连续虚拟数组，这正好对应于 $E+1$ 个虚拟页面。让我们用 VPN $0, 1, 2, \\dots, E$ 来标记这些页面。\n\n稳态 TLB 未命中率为 $1$ 意味着在初始预热期之后，每次内存访问都会导致 TLB 未命中。对于一个具有 $E$ 个条目和 LRU 策略的 TLB，当内存访问序列强制引用一个其转换刚被驱逐的页面时，就会出现这种情况。如果访问模式在一个至少包含 $E+1$ 个不同页面的“工作集”中循环，就会发生这种情况。由于我们的数组正好跨越 $E+1$ 个页面，如果访问模式在一个重复的循环中系统地触及所有 $E+1$ 个页面，就会发生最大颠簸。\n\n让我们分析生成的虚拟地址序列：\n$$v_k = v_0 + ((k\\,s) \\bmod ((E+1)p))$$\n距离数组基地址的偏移量是 $o_k = (k\\,s) \\bmod ((E+1)p)$。第 $k$ 次访问的 VPN 是：\n$$P_k = \\text{VPN}(v_k) = \\left\\lfloor \\frac{v_k - v_0}{p} \\right\\rfloor = \\left\\lfloor \\frac{(k\\,s) \\bmod ((E+1)p)}{p} \\right\\rfloor$$\n\n为了使未命中率为 $1$，每次访问都必须访问与前一次访问的页面不同的页面（实际上，与最近访问的 $E$ 个唯一页面都不同）。一个必要但不充分的条件是，每次访问时页号都必须改变。也就是说，在稳态下，对于所有的 $k$ 都有 $P_k \\neq P_{k+1}$。\n\n让我们考虑跨步 $s$ 相对于页面大小 $p$ 的影响。\n如果跨步 $s$ 小于页面大小 $p$（即 $s  p$），那么在 $v_k$ 和 $v_{k+1}=v_k+s$ 的两次连续访问（为简单起见，忽略环绕）可能会落在同一页面内。对地址 $v$ 的一次访问，其页内偏移为 $v \\pmod p$，紧接着将是对 $v+s$ 的访问。如果 $(v \\pmod p) + s  p$，两次访问都在同一页面。对于任何页内偏移不在页面最后 $s$ 个字节内的地址 $v$，此条件都将满足。这意味着有 $(p-s)/p$ 的访问比例不会跨越页面边界。因此，如果 $s  p$，将会出现对同一页面的一系列访问，导致 TLB 命中。这违反了未命中率为 $1$ 的条件。因此，最大颠簸的一个必要条件是 $s \\ge p$。\n\n我们正在寻找导致最大颠簸的*最小正*跨步 $s$。基于以上推理，我们应该从 $s=p$ 开始搜索。\n\n让我们设置跨步 $s=p$。VPN 序列变为：\n$$P_k = \\left\\lfloor \\frac{(k\\,p) \\bmod ((E+1)p)}{p} \\right\\rfloor$$\n由于 $k\\,p$ 和 $(E+1)p$ 都是 $p$ 的整数倍，我们可以简化这个表达式。设 $N=E+1$。\n$$(k\\,p) \\bmod (N p) = (k \\bmod N)p$$\n因此，\n$$P_k = \\left\\lfloor \\frac{(k \\bmod (E+1))p}{p} \\right\\rfloor = k \\bmod (E+1)$$\n对于 $k=0, 1, 2, \\dots$，被访问的 VPN 序列是：\n$$0, 1, 2, \\dots, E, 0, 1, 2, \\dots$$\n这是对数组所有 $E+1$ 个页面的顺序扫描，并在末尾环绕。让我们追踪这个拥有 $E$ 个条目的 LRU TLB 的状态。\n1.  访问页面 $0$：未命中。TLB 中有 $\\{0\\}$。\n2.  访问页面 $1$：未命中。TLB 中有 $\\{0, 1\\}$。\n...\nE. 访问页面 $E-1$：未命中。TLB 此时已满：$\\{0, 1, \\dots, E-1\\}$。页面 $0$ 是最近最少使用的。\nE+1. 访问页面 $E$：未命中。页面 $0$ 被驱逐。TLB 包含 $\\{1, 2, \\dots, E\\}$。页面 $1$ 成为 LRU 条目。\nE+2. 访问页面 $0$（来自环绕）：未命中。页面 $0$ 不在 TLB 中。页面 $1$ 被驱逐。TLB 包含 $\\{2, 3, \\dots, E, 0\\}$。页面 $2$ 成为 LRU 条目。\nE+3. 访问页面 $1$：未命中。页面 $1$ 不在 TLB 中。页面 $2$ 被驱逐。TLB 包含 $\\{3, \\dots, E, 0, 1\\}$。\n\n这种模式无限期地持续下去。每次访问都是针对在 $E$ 步之前其转换被驱逐的页面，从而保证了在稳态下每次访问都会发生 TLB 未命中。因此，跨步 $s=p$ 会导致 TLB 未命中率为 $1$。\n\n因为我们已经确定任何小于 $p$ 的跨步 $s$ 都不能产生 $1$ 的未命中率，并且我们已经证明 $s=p$ 确实能产生 $1$ 的未命中率，所以产生最大 TLB 颠簸的最小正跨步是 $s=p$。\n\n最后，问题要求对缓存行大小 $b$ 和跨步 $s$ 之间的相互作用进行宏观讨论。由于缓存足够大以避免容量未命中，我们只考虑强制性未命中。一次内存访问会取回一个大小为 $b$ 字节的缓存行。如果跨步 $s$ 小于 $b$，连续的访问可能会落在同一个缓存行内。例如，对 $v_k$ 的访问会取入一个缓存行；如果下一次对 $v_{k+1}=v_k+s$ 的访问落入同一行，则将是缓存命中。在这种情况下，缓存未命中率大约为 $s/b$。如果 $s \\ge b$，每次访问都会访问不同的缓存行，使得每次访问都成为强制性缓存未命中（未命中率为 $1$）。对于我们的解 $s=p$，并且由于 $b$ 整除 $p$，我们有 $s=p \\ge b$。这意味着每次访问不仅会导致 TLB 未命中，还会导致数据缓存未命中，这对两个内存系统组件来说都是最坏的情况。",
            "answer": "$$\\boxed{p}$$"
        },
        {
            "introduction": "前面的练习揭示了小页面在页表开销和TLB压力方面可能带来的挑战。为了应对这些问题，现代CPU和操作系统引入了“巨页”这一重要优化。本练习设置了一个具体的内存区域重映射任务，要求你计算并对比分别使用标准4 KiB页面和2 MiB巨页所需的页表项更新次数。通过这个实践，你将能直观地量化巨页在减少地址翻译工作量和提升内存操作效率方面的巨大优势。",
            "id": "3620275",
            "problem": "考虑一个 $64$ 位系统，该系统使用请求分页虚拟内存，同时支持大小为 $4$ KiB 的基本页和大小为 $2$ MiB 的巨页。内存管理单元（MMU）通过多级页表将虚拟地址（VA）转换为物理地址（PA）。每个页面映射条目（对于 $4$ KiB 页面是页表条目（PTE），对于 $2$ MiB 页面是设置了页面大小位的页目录条目（PDE））精确映射一个页面，并且是重映射的单位。对于本问题，定义一次“PTE 更新”为写入一个任一类型的页面映射条目。\n\n假设以下关于物理和虚拟内存的事实：\n- 一个 $4$ KiB 的页面是 $2^{12}$ 字节，一个 $2$ MiB 的页面是 $2^{21}$ 字节。一个 kibibyte（KiB）是 $2^{10}$ 字节，一个 mebibyte（MiB）是 $2^{20}$ 字节。\n- 一个 $2$ MiB 的映射要求其 VA 基地址和 PA 基地址分别对齐到 $2$ MiB 边界，且该映射所覆盖的物理帧必须在物理上是连续的。\n- 一个 $4$ KiB 的映射要求其 VA 基地址和 PA 基地址分别对齐到 $4$ KiB 边界，且物理帧必须存在；不需要更大的对齐。\n\n您必须将一个大小为 $513$ MiB 的单个大型连续 VA 区域重映射到一组新的物理帧号（PFN），这些物理帧在整个 $513$ MiB 范围内是物理上连续的。该区域的 VA 基地址相对于最近的 $2$ MiB 边界有 $1$ MiB 的未对齐，目标 PFN 范围的 PA 基地址也相对于一个 $2$ MiB 边界有 $1$ MiB 的未对齐。所有涉及的地址都对齐到 $4$ KiB 边界，并且多级页表已经存在；只需计算执行重映射所需的页面映射条目写入次数，不计算任何指针级条目或页表分配。\n\n计算在两种独立的策略下所需的最少页面映射条目更新次数：\n- 策略 A：在对齐规则允许的情况下尽可能使用 $2$ MiB 页面，对任何无法被 $2$ MiB 页面覆盖的剩余部分使用 $4$ KiB 页面。\n- 策略 B：对整个 $513$ MiB 区域仅使用 $4$ KiB 页面。\n\n按（策略 A, 策略 B）的顺序以一个序对的形式报告您的最终答案。最终答案必须是单个实体且不含单位。",
            "solution": "该问题经评估有效。它在科学上基于操作系统内存管理的原理，问题陈述清晰，数据充分且一致，表述客观。\n\n我们需要计算在两种不同的分页策略下，将一个大小为 $513 \\text{ MiB}$ 的连续虚拟地址（VA）区域重映射到一个同样大小的连续物理地址（PA）区域所需的页面映射条目更新次数。\n\n让我们从问题陈述中定义关键参数：\n-   需要重映射的内存区域总大小：$S_{total} = 513 \\text{ MiB}$。\n-   基本页大小：$S_{base} = 4 \\text{ KiB} = 4 \\times 2^{10} \\text{ 字节} = 2^2 \\times 2^{10} \\text{ 字节} = 2^{12} \\text{ 字节}$。\n-   巨页大小：$S_{huge} = 2 \\text{ MiB} = 2 \\times 2^{20} \\text{ 字节} = 2^{21} \\text{ 字节}$。\n-   该区域的 VA 基地址相对于 $2 \\text{ MiB}$ 边界有 $1 \\text{ MiB}$ 的未对齐。\n-   目标区域的 PA 基地址也相对于 $2 \\text{ MiB}$ 边界有 $1 \\text{ MiB}$ 的未对齐。\n-   一次“更新”定义为写入一个页面映射条目，可以是 $4$ KiB 页面或 $2$ MiB 页面的条目。\n\n首先，我们分析策略 B，因为它更简单。\n\n**策略 B：仅使用 $4$ KiB 页面**\n\n在此策略中，整个 $513 \\text{ MiB}$ 区域仅使用 $4 \\text{ KiB}$ 页面进行映射。所需的页面映射条目更新次数 $N_B$ 是区域总大小除以单个基本页面的大小。这里的未对齐问题无关紧要，因为问题说明所有地址都对齐到 $4 \\text{ KiB}$ 边界，这是使用 $4 \\text{ KiB}$ 页面的唯一要求。\n\n我们可以用字节表示大小来进行计算：\n$S_{total} = 513 \\text{ MiB} = 513 \\times 2^{20} \\text{ 字节}$。\n$S_{base} = 4 \\text{ KiB} = 2^{12} \\text{ 字节}$。\n\n更新次数为：\n$$N_B = \\frac{S_{total}}{S_{base}} = \\frac{513 \\times 2^{20}}{2^{12}} = 513 \\times 2^{20-12} = 513 \\times 2^8$$\n$$N_B = 513 \\times 256$$\n为了计算这个值，我们可以将 $513$ 写成 $512 + 1 = 2^9 + 1$：\n$$N_B = (2^9 + 1) \\times 2^8 = 2^9 \\times 2^8 + 1 \\times 2^8 = 2^{17} + 2^8 = 131072 + 256 = 131328$$\n因此，对于策略 B，需要 $131,328$ 次更新。\n\n**策略 A：尽可能使用 $2$ MiB 页面**\n\n该策略需要仔细分析对齐约束。只有当一个 $2 \\text{ MiB}$ 巨页的 VA 基地址和其对应的 PA 基地址都对齐到 $2 \\text{ MiB}$ 边界时，才能使用它。\n\n设区域的 VA 基地址为 $V_{start}$，PA 基地址为 $P_{start}$。问题陈述它们相对于 $2 \\text{ MiB}$ 边界有 $1 \\text{ MiB}$ 的未对齐。这可以数学上表示为：\n$$V_{start} \\pmod{2 \\text{ MiB}} = 1 \\text{ MiB}$$\n$$P_{start} \\pmod{2 \\text{ MiB}} = 1 \\text{ MiB}$$\n\nVA 区域从 $V_{start}$ 延伸到 $V_{start} + 513 \\text{ MiB} - 1$。\n由于 $V_{start}$ 未对齐到 $2 \\text{ MiB}$ 边界，我们不能在区域的起始处使用 $2 \\text{ MiB}$ 页面。我们必须首先使用 $4$ KiB 页面映射区域的一部分，直到达到一个 $2 \\text{ MiB}$ 对齐的 VA。\n\n第一个大于 $V_{start}$ 的 $2 \\text{ MiB}$ 对齐的 VA 地址是 $V_{align} = V_{start} + (2 \\text{ MiB} - 1 \\text{ MiB}) = V_{start} + 1 \\text{ MiB}$。从 $V_{start}$ 到 $V_{align}-1$ 的 VA 段大小为 $1 \\text{ MiB}$。这个初始段必须使用 $4$ KiB 页面进行映射。\n这个初始 $1 \\text{ MiB}$ 段的更新次数 $N_{A,1}$ 为：\n$$N_{A,1} = \\frac{1 \\text{ MiB}}{4 \\text{ KiB}} = \\frac{2^{20} \\text{ 字节}}{2^{12} \\text{ 字节}} = 2^{20-12} = 2^8 = 256$$\n\n现在，我们考虑区域的剩余部分。总大小为 $513 \\text{ MiB}$，我们已经映射了 $1 \\text{ MiB}$。剩余大小为 $513 \\text{ MiB} - 1 \\text{ MiB} = 512 \\text{ MiB}$。\n这个剩余区域从 VA $V_{align} = V_{start} + 1 \\text{ MiB}$ 开始。我们已经确定这个 VA 是 $2 \\text{ MiB}$ 对齐的。\n\n接下来，我们必须检查相应 PA 的对齐情况。物理内存是连续的，所以对应于 $V_{align}$ 的 PA 是 $P_{align} = P_{start} + 1 \\text{ MiB}$。我们检查它的对齐情况：\n$$P_{align} \\pmod{2 \\text{ MiB}} = (P_{start} + 1 \\text{ MiB}) \\pmod{2 \\text{ MiB}}$$\n由于 $P_{start} \\pmod{2 \\text{ MiB}} = 1 \\text{ MiB}$，我们有：\n$$(1 \\text{ MiB} + 1 \\text{ MiB}) \\pmod{2 \\text{ MiB}} = 2 \\text{ MiB} \\pmod{2 \\text{ MiB}} = 0$$\n剩余区域的 PA 基地址 $P_{align}$ 也是 $2 \\text{ MiB}$ 对齐的。\n\n剩余区域的大小为 $512 \\text{ MiB}$。由于其 VA 和 PA 基地址都是 $2 \\text{ MiB}$ 对齐的，并且物理内存是连续的，我们可以使用 $2 \\text{ MiB}$ 巨页来映射这整个部分。所需的巨页数量 $N_{A,2}$ 为：\n$$N_{A,2} = \\frac{512 \\text{ MiB}}{2 \\text{ MiB}} = 256$$\n\n策略 A 的总更新次数 $N_A$ 是初始未对齐部分和主要对齐部分更新次数的总和：\n$$N_A = N_{A,1} + N_{A,2} = 256 + 256 = 512$$\n\n因此，对于策略 A，需要 $512$ 次更新。\n\n最终答案是策略 A 和策略 B 的结果对。\n- 策略 A：$512$ 次更新。\n- 策略 B：$131,328$ 次更新。\n该序对是 $(512, 131328)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n512  131328\n\\end{pmatrix}\n}\n$$"
        }
    ]
}