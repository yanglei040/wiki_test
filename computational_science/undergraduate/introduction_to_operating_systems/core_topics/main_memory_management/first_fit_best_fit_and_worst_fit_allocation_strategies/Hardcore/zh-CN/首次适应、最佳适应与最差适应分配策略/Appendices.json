{
    "hands_on_practices": [
        {
            "introduction": "首先，我们将通过一个受控的场景来探索首次适应、最佳适应和最差适应策略的核心逻辑。这项练习  要求您追踪每个分配器在处理一个简单的重复请求序列时所做的决策。通过计算搜索成本和找到完全匹配大小的内存块的概率等指标，您将对每种策略在速度和内存利用率之间所做的基本权衡有一个具体的理解。",
            "id": "3644104",
            "problem": "考虑一个操作系统（OS）中的单区域动态内存分配器，它使用线性空闲列表和连续的块。该分配器可以采用三种策略之一运行：首次适应（first-fit）、最佳适应（best-fit）或最差适应（worst-fit）。空闲列表按固定顺序维护，并恰好包含三个空闲块，其大小按顺序分别为 $8$、$6$ 和 $9$ 个单位。一个周期为 $k=3$ 的循环工作负载在每一步发出一个分配请求，大小分别为 $6$、$8$ 和 $7$ 个单位，然后无限重复。在下一次分配请求到来之前，每次分配之后会立即释放与所请求大小相同的块。假设分割一个较大的已分配块会在分割点留下一个剩余的空闲碎片，并且立即释放会触发合并操作，从而在下一次请求之前确定性地将空闲列表恢复到其原始状态和顺序。在整个周期中，分配器不会改变空闲列表的顺序。\n\n基本定义：\n- 首次适应分配器选择空闲列表中第一个大小至少等于请求大小的块。\n- 最佳适应分配器选择空闲列表中大小至少等于请求大小的最小块；假设采用一种朴素的实现，它会扫描整个空闲列表以确定最小的足够大的块。\n- 最差适应分配器选择空闲列表中大小至少等于请求大小的最大块；假设采用一种朴素的实现，它会扫描整个空闲列表以确定最大的足够大的块。\n\n设 $\\Pr[\\text{exact-fit}]$ 表示在一个包含 $k$ 个请求的周期内，分配器返回的块的大小与请求大小完全相等的概率。设 $T$ 表示在所述的朴素实现下，每次分配请求检查的空闲列表块头的期望数量，该值是在一个周期的 $k$ 个请求上平均计算的。\n\n针对此循环工作负载，确定哪种策略可以最大化 $\\Pr[\\text{exact-fit}]$，哪种策略可以最小化 $T$。将三种策略编码为数字：首次适应 $=1$，最佳适应 $=2$，最差适应 $=3$。将你的最终答案以行矩阵 $\\left(s_{\\max} \\ \\ s_{\\min}\\right)$ 的形式报告，其中 $s_{\\max}$ 是最大化 $\\Pr[\\text{exact-fit}]$ 的策略代码，$s_{\\min}$ 是最小化 $T$ 的策略代码。无需四舍五入，也无需报告单位。使用指定的编码将最终答案表示为行矩阵。",
            "solution": "该问题要求在特定的循环工作负载下，分析三种动态内存分配策略——首次适应、最佳适应和最差适应。我们的任务是确定哪种策略能最大化精确匹配分配的概率（表示为 $\\Pr[\\text{exact-fit}]$），以及哪种策略能最小化每次请求检查的空闲列表块头的期望数量（表示为 $T$）。策略编码为：首次适应 $=1$，最佳适应 $=2$，最差适应 $=3$。\n\n空闲列表的初始状态是一个有序的块大小序列：$L = (8, 6, 9)$。此列表包含 $3$ 个块。\n工作负载是一个重复周期为 $k=3$ 的分配请求，大小为 $R = (r_1, r_2, r_3) = (6, 8, 7)$。\n一个关键条件是，每次分配并立即释放所分配的块后，空闲列表都会确定性地恢复到其原始状态和顺序 $L$。这一简化意味着在一个周期中的 $k=3$ 个请求中的每一个都是针对相同的初始空闲列表 $L=(8, 6, 9)$ 进行评估的。\n\n我们将对每个策略在一个包含 $k=3$ 个请求的周期内进行分析。\n\n1. 首次适应策略 ($s=1$)\n该策略选择空闲列表中第一个足以满足请求的可用块。列表按其固定顺序 $(8, 6, 9)$ 进行扫描。\n\n- 请求 $r_1 = 6$：分配器从头开始扫描列表。第一个块的大小为 $8$。由于 $8 \\ge 6$，该块被选中用于分配。搜索停止。这不是一个精确匹配（$8 > 6$）。检查的块数为 $1$。\n- 请求 $r_2 = 8$：列表恢复为 $(8, 6, 9)$。分配器扫描列表。第一个块的大小为 $8$。由于 $8 \\ge 8$，该块被选中。这是一个精确匹配。检查的块数为 $1$。\n- 请求 $r_3 = 7$：列表恢复为 $(8, 6, 9)$。分配器扫描列表。第一个块的大小为 $8$。由于 $8 \\ge 7$，该块被选中。这不是一个精确匹配（$8 > 7$）。检查的块数为 $1$。\n\n对于首次适应策略：\n- 在一个周期内，精确匹配分配的总数为 $1$。\n- 精确匹配的概率为 $\\Pr[\\text{exact-fit}]_{ff} = \\frac{1}{3}$。\n- 在该周期内检查的块头总数为 $1 + 1 + 1 = 3$。\n- 每次请求的期望检查次数为 $T_{ff} = \\frac{3}{3} = 1$。\n\n2. 最佳适应策略 ($s=2$)\n该策略从整个空闲列表中选择足以满足请求的最小块。问题指定了一个朴素的实现，即对每个请求都扫描整个包含 $3$ 个块的列表以找到最小的足够大的块。\n\n- 请求 $r_1 = 6$：分配器扫描整个列表 $(8, 6, 9)$。足够大的块的集合是 $\\{8, 6, 9\\}$。其中最小的是大小为 $6$ 的块。该块被选中。这是一个精确匹配。检查的块数为 $3$。\n- 请求 $r_2 = 8$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块的集合是 $\\{8, 9\\}$。其中最小的是大小为 $8$ 的块。该块被选中。这是一个精确匹配。检查的块数为 $3$。\n- 请求 $r_3 = 7$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块的集合是 $\\{8, 9\\}$。其中最小的是大小为 $8$ 的块。该块被选中。这不是一个精确匹配（$8 > 7$）。检查的块数为 $3$。\n\n对于最佳适应策略：\n- 在一个周期内，精确匹配分配的总数为 $2$。\n- 精确匹配的概率为 $\\Pr[\\text{exact-fit}]_{bf} = \\frac{2}{3}$。\n- 检查的块头总数为 $3 + 3 + 3 = 9$。\n- 每次请求的期望检查次数为 $T_{bf} = \\frac{9}{3} = 3$。\n\n3. 最差适应策略 ($s=3$)\n该策略从整个空闲列表中选择足够大的最大块。这也使用了一个朴素的实现，即对每个请求都扫描整个包含 $3$ 个块的列表。\n\n- 请求 $r_1 = 6$：分配器扫描整个列表 $(8, 6, 9)$。足够大的块的集合是 $\\{8, 6, 9\\}$。其中最大的是大小为 $9$ 的块。该块被选中。这不是一个精确匹配（$9 > 6$）。检查的块数为 $3$。\n- 请求 $r_2 = 8$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块的集合是 $\\{8, 9\\}$。其中最大的是大小为 $9$ 的块。该块被选中。这不是一个精确匹配（$9 > 8$）。检查的块数为 $3$。\n- 请求 $r_3 = 7$：列表恢复。分配器扫描整个列表 $(8, 6, 9)$。足够大的块的集合是 $\\{8, 9\\}$。其中最大的是大小为 $9$ 的块。该块被选中。这不是一个精确匹配（$9 > 7$）。检查的块数为 $3$。\n\n对于最差适应策略：\n- 在一个周期内，精确匹配分配的总数为 $0$。\n- 精确匹配的概率为 $\\Pr[\\text{exact-fit}]_{wf} = \\frac{0}{3} = 0$。\n- 检查的块头总数为 $3 + 3 + 3 = 9$。\n- 每次请求的期望检查次数为 $T_{wf} = \\frac{9}{3} = 3$。\n\n指标摘要：\n- 首次适应 ($s=1$)：$\\Pr[\\text{exact-fit}]_{ff} = \\frac{1}{3}$，$T_{ff} = 1$。\n- 最佳适应 ($s=2$)：$\\Pr[\\text{exact-fit}]_{bf} = \\frac{2}{3}$，$T_{bf} = 3$。\n- 最差适应 ($s=3$)：$\\Pr[\\text{exact-fit}]_{wf} = 0$，$T_{wf} = 3$。\n\n最优策略的确定：\n为了找到最大化 $\\Pr[\\text{exact-fit}]$ 的策略，我们比较计算出的概率：$\\{\\frac{1}{3}, \\frac{2}{3}, 0\\}$。最大值为 $\\frac{2}{3}$，对应于最佳适应策略。因此，最大化此概率的策略代码是 $s_{\\max} = 2$。\n\n为了找到最小化期望检查次数 $T$ 的策略，我们比较平均检查计数：$\\{1, 3, 3\\}$。最小值为 $1$，对应于首次适应策略。因此，最小化此成本的策略代码是 $s_{\\min} = 1$。\n\n问题要求将最终答案以行矩阵 $(s_{\\max} \\ \\ s_{\\min})$ 的形式报告。代入确定的值，我们得到矩阵 $(2 \\ \\ 1)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本机制之后，我们现在来研究分配选择的长期后果。这个思想实验  向您提出挑战，要求您设计一个请求序列，以最大化首次适应和最差适应策略在内存碎片化方面的差异。通过主动尝试“攻破”系统，您将培养出敏锐的直觉，理解每种策略的逻辑如何随着时间的推移塑造空闲内存的格局，从而导致不同程度的碎片。",
            "id": "3644191",
            "problem": "考虑一个可变大小分区的内存分配器，它管理一个按内存地址升序排列的空闲列表。该分配器在分配时使用块分割，但不进行压缩或合并：当从大小为 $f \\ge s$ 的空闲块中满足大小为 $s$ 的请求时，分配器会创建一个大小为 $s$ 的已分配块和一个大小为 $f - s$ 的剩余空闲块（如果 $f = s$，则所选的空闲块消失）。定义首次适应（First-Fit, FF）策略为选择地址顺序上第一个大小至少等于请求大小的空闲块，定义最差适应（Worst-Fit, WF）策略为选择大小至少等于请求大小的最大空闲块。\n\n最初，空闲列表由 $m$ 个大小为 $b$ 的小块和一个大小为 $B$ 的大块组成，其中 $B > b > 0$ 且 $m \\ge n$。你将执行 $n$ 次分配操作，请求大小为 $\\{ s_i \\}_{i=1}^{n}$，并满足对于所有 $i$，有 $0  s_i \\le b$。\n\n令 $C_{\\max}^{\\mathrm{FF}}(t)$ 和 $C_{\\max}^{\\mathrm{WF}}(t)$ 分别表示在首次适应和最差适应策略下，经过 $t$ 次操作后最大连续空闲块的大小。定义经过 $n$ 次操作后的差值为\n$$\n\\Delta C_{\\max} \\equiv C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n).\n$$\n你的任务是：\n- 仅使用首次适应和最差适应策略的核心定义以及所述的分配器语义，确定能使 $\\Delta C_{\\max}$ 最大化的请求序列 $\\{ s_i \\}$ 的模式。\n- 从第一性原理出发，推导 $\\Delta C_{\\max}$ 的最大可达值，并以 $n$、$b$ 和 $B$ 的闭式表达式表示。\n\n提供最终答案为一个精确的解析表达式。不需要四舍五入。",
            "solution": "我们的目标是最大化 $\\Delta C_{\\max} = C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n)$。这需要我们找到一个请求序列 $\\{s_i\\}_{i=1}^n$，该序列能同时使 $C_{\\max}^{\\mathrm{FF}}(n)$ 尽可能大，并使 $C_{\\max}^{\\mathrm{WF}}(n)$ 尽可能小。\n\n**请求序列模式分析**\n\n我们来分析每种分配策略的行为，以确定最优的请求序列。\n\n**最大化 $C_{\\max}^{\\mathrm{FF}}(n)$:**\n初始空闲列表中的最大块大小为 $B$。由于不执行合并，因此永远无法创建比 $B$ 更大的块。因此，$C_{\\max}^{\\mathrm{FF}}(n)$ 的最大可能值为 $B$。为实现此目的，这 $n$ 次分配的序列必须完全不使用大小为 $B$ 的大块。\n\n首次适应（FF）策略按内存地址升序扫描空闲列表。初始列表由 $m$ 个大小为 $b$ 的块和一个大小为 $B$ 的块组成，且小块在前。对于任何满足 $0  s_i \\le b$ 的请求 $s_i$，FF 将首先扫描初始的 $m$ 个块。由于 $m \\ge n$，小块的数量至少与请求数量一样多。每个请求 $s_i$ 都可以由大小为 $b$ 的块来满足。\n\n为了保证永远不会触及大小为 $B$ 的大块，我们必须确保 $n$ 个请求中的每一个都由前 $m$ 个块中的一个来满足。一个能实现这一点的简单序列是，对所有 $i \\in \\{1, \\ldots, n\\}$，选择 $s_i = b$。\n- 对于第一个请求 $s_1 = b$，FF 找到第一个大小为 $b$ 的块，该块恰好满足请求。此块从空闲列表中移除。\n- 对于第二个请求 $s_2 = b$，FF 找到下一个大小为 $b$ 的块并将其移除。\n- 这个过程持续 $n$ 次请求。由于 $m \\ge n$，对于 $n$ 个请求中的每一个，都有一个全新的大小为 $b$ 的块可用。\n- 经过 $n$ 次这样的操作后，前 $n$ 个大小为 $b$ 的块已被消耗。空闲列表现在由 $m-n$ 个大小为 $b$ 的块和那个未被触动的大小为 $B$ 的块组成。\n- 由于 $B > b$，最大空闲块的大小为 $C_{\\max}^{\\mathrm{FF}}(n) = B$。\n\n这个对于所有 $i$ 都有 $s_i = b$ 的序列，实现了 $C_{\\max}^{\\mathrm{FF}}(n)$ 的最大可能值。\n\n**最小化 $C_{\\max}^{\\mathrm{WF}}(n)$:**\n最差适应（WF）策略总是从最大的可用空闲块中分配。为了使最终的最大块大小 $C_{\\max}^{\\mathrm{WF}}(n)$ 尽可能小，我们应该选择请求序列 $\\{s_i\\}$ 来系统地减小最大块的大小。WF 策略会优先消耗大块，所以我们的序列应该利用这一点。为了最大程度地消耗大块，我们应该最大化分配的总量 $\\sum_{i=1}^n s_i$。在 $0  s_i \\le b$ 的约束下，当对于所有 $i=1, \\ldots, n$ 都有 $s_i = b$ 时，总和最大。\n\n让我们用这个序列（即对于 $i=1, \\ldots, n$ 都有 $s_i = b$）来分析WF的行为。\n- 最初，空闲块的大小为 $\\{b, \\ldots, b, B\\}$。由于 $B>b$，最大的块是大小为 $B$ 的那个。\n- 对于每个请求 $s_i=b$，WF 会识别当前空闲列表中的最大块。\n- 只要原始大小为 $B$ 的块的剩余部分大于或等于其他任何块（即大于 $b$），WF 就会选择它进行分配。\n- 经过 $n$ 次大小为 $b$ 的请求后，总共分配了 $nb$ 的内存。这部分内存优先从最大的可用块中划分出来。\n- 在 $n$ 次操作后，大块的剩余大小为 $B-nb$。空闲列表中的其他块大小仍然为 $b$。\n- 因此，最终空闲列表中的块大小为 $\\{b, \\ldots, b, B-nb\\}$（$m$ 个 $b$ 和一个剩余块）。\n- 最终的最大空闲块大小是两个潜在幸存者中较大的一个：原始小块大小 $b$ 和大块的剩余部分 $B-nb$。\n$$C_{\\max}^{\\mathrm{WF}}(n) = \\max(b, B-nb)$$\n\n对于所有 $i$ 都有 $s_i=b$ 的序列成功地最大化了 $C_{\\max}^{\\mathrm{FF}}(n)$ 并最小化了 $C_{\\max}^{\\mathrm{WF}}(n)$，因此它确实是最大化 $\\Delta C_{\\max}$ 的模式。\n\n**最大 $\\Delta C_{\\max}$ 的推导**\n\n现在我们可以使用为最优序列 $s_i=b$ 推导出的结果来计算 $\\Delta C_{\\max}$ 的最大值：\n$$\n\\Delta C_{\\max} = C_{\\max}^{\\mathrm{FF}}(n) - C_{\\max}^{\\mathrm{WF}}(n) = B - \\max(b, B-nb)\n$$\n这个表达式可以通过考虑 $\\max$ 函数的两种情况来简化。\n\n情况 A：$b \\ge B-nb$，等价于 $(n+1)b \\ge B$。\n在这种情况下，$\\max(b, B-nb) = b$。\n差值为 $\\Delta C_{\\max} = B - b$。\n\n情况 B：$b  B-nb$，等价于 $(n+1)b  B$。\n在这种情况下，$\\max(b, B-nb) = B-nb$。\n差值为 $\\Delta C_{\\max} = B - (B-nb) = nb$。\n\n结合这两种情况，$\\Delta C_{\\max}$ 的最大值是 $nb$ 和 $B-b$ 这两个值中较小的一个。这可以用最小值函数紧凑地表示：\n$$\n\\max(\\Delta C_{\\max}) = \\min(nb, B-b)\n$$\n这个表达式代表了最终答案。导致此结果的模式是对于所有 $n$ 次分配都使用大小为 $s_i=b$ 的请求。",
            "answer": "$$\n\\boxed{\\min(nb, B-b)}\n$$"
        },
        {
            "introduction": "最后，我们将通过实现一个完整的内存分配模拟器，将理论付诸实践。这个编程挑战  要求您在三种策略下对内存块的分配和释放进行建模，并融入诸如块合并和最小碎片大小阈值等现实细节。通过运行预定义的工作负载并测量由此产生的内部和外部碎片，您将亲身体验如何凭经验评估和比较这些基本操作系统算法的性能。",
            "id": "3644173",
            "problem": "您需要实现并分析在三种选择策略（首次适应、最佳适应和最差适应）下的连续内存分配，并应用一个关于分割的阈值规则。考虑一个固定大小的单一连续内存，以及一个由唯一进程标识符标识的确定性分配和释放请求序列。重点是在序列结束时，量化外部碎片和内部碎片，并比较这些指标如何随着分割阈值的变化而改变。\n\n需要使用的基本定义：\n- 连续分配维护一个空闲块列表，并分配一个在地址空间中连续的完整内存区域。分配基于一种选择足够大小的空闲块的策略。\n- 首次适应选择第一个足够大的空闲块。\n- 最佳适应选择不小于请求大小的最小空闲块；若大小相同，则通过选择起始地址最低的块来打破平局。\n- 最差适应选择最大的空闲块；若大小相同，则通过选择起始地址最低的块来打破平局。\n- 当为了满足一个大小为 $r$ 的请求而分割一个大小为 $s$ 的空闲块时，设剩余部分为 $t = s - r$。如果 $t  \\epsilon$ (严格小于)，分配器不进行分割。相反，它将整个大小为 $s$ 的块分配给该请求，并为该分配记录 $s - r$ 字节的内部浪费。如果 $t \\ge \\epsilon$，则进行正常分割，形成一个大小为 $r$ 的已分配块和一个大小为 $t$ 的空闲块。\n- 释放时，立即与任何相邻的空闲邻居块进行合并，以保持最大的空闲连续性。\n- 在整个序列结束时，将外部碎片 $E$ 定义为\n$$\nE \\equiv \\begin{cases}\n0,  \\text{当总空闲内存 } F = 0 \\text{ 时},\\\\\n1 - \\dfrac{L}{F},  \\text{当 } F  0 \\text{ 时},\n\\end{cases}\n$$\n其中 $F$ 是所有空闲块大小的总和，$L$ 是最大空闲块的大小。\n- 在整个序列结束时，将内部碎片 $I$ 定义为当前所有已分配块的 $(\\text{allocated\\_size} - \\text{requested\\_size})$ 之和（以字节为单位）。每个已分配块在分配时记录其请求大小和已分配大小；只有在结束时仍处于分配状态的块才对 $I$ 有贡献。\n\n内存模型和参数：\n- 总内存大小为 $M = 100$ 字节，建模为从 $0$ 到 $M-1$ 的地址；初始状态是一个大小为 100 的单一空闲块。\n- 请求是一个包含 10 个操作的序列，操作为分配或释放一个由标识符引用的块。分配大小以字节为单位。序列如下：\n  - 分配 id $1$ 大小 $20$。\n  - 分配 id $2$ 大小 $10$。\n  - 分配 id $3$ 大小 $15$。\n  - 释放 id $2$。\n  - 分配 id $4$ 大小 $9$。\n  - 分配 id $5$ 大小 $8$。\n  - 释放 id $3$。\n  - 分配 id $6$ 大小 $12$。\n  - 释放 id $1$。\n  - 分配 id $7$ 大小 $18$。\n- 使用严格的地址顺序来表示空闲列表和已分配块；块选择中的平局通过选择起始地址最低的块来解决。\n- 假设此序列中的所有分配在上述规则下都能成功。\n\n分割阈值测试套件：\n- 对 $\\epsilon \\in \\{0, 2, 4, 12\\}$ 评估系统，其中 $\\epsilon$ 以字节为单位。\n\n程序要求：\n- 对每个 $\\epsilon$ 值，在首次适应 (FF)、最佳适应 (BF) 和最差适应 (WF) 每种策略下独立模拟该序列。分配器的操作完全如上所述，包括释放时的立即合并和分配时的分割阈值规则。\n- 对于每对 $(\\epsilon, \\text{policy})$，计算最终的外部碎片 $E$ (无量纲) 和最终的内部碎片 $I$ (以字节为单位)。除了字节，不涉及其他物理单位，也不使用角度。\n- 输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表。对于按升序排列的每个 $\\epsilon$ 值 $\\{0, 2, 4, 12\\}$，按以下顺序附加六个浮点数：$E_{\\mathrm{FF}}$, $I_{\\mathrm{FF}}$, $E_{\\mathrm{BF}}$, $I_{\\mathrm{BF}}$, $E_{\\mathrm{WF}}$, $I_{\\mathrm{WF}}$。将每个数字打印为小数点后恰好有六位数字的浮点值。因此，最后一行应在一个方括号列表中包含 $4 \\times 6 = 24$ 个浮点数，格式如 $[\\dots]$。\n\n设计目标和覆盖范围：\n- 测试套件包括作为基线的 $\\epsilon = 0$，一个只影响非常小的尾部碎片的较小阈值 $\\epsilon = 2$，一个抑制更多尾部碎片的中等阈值 $\\epsilon = 4$，以及一个用于强调权衡的较大阈值 $\\epsilon = 12$。\n- 这涵盖了正常路径场景、阈值规则的类边界情况以及策略差异化，确保结果是可量化的浮点数，并按规定汇总到最终的单行列表中。",
            "solution": "我们从连续内存分配策略和碎片的核心定义开始。分配器维护一个按起始地址排序的内存段列表，每个段由 $(\\text{start}, \\text{size}, \\text{is\\_free})$ 描述，对于已分配的块，还记录 $(\\text{id}, \\text{requested\\_size}, \\text{allocated\\_size})$。初始状态是一个大小为 $M=100$ 字节的单一空闲段。\n\n分配选择由一个搜索空闲列表的策略决定：\n- 首次适应返回第一个大小至少为 $r$ 的空闲段。\n- 最佳适应返回大小至少为 $r$ 的空闲段中尺寸最小的那个；平局由最小的起始地址打破。\n- 最差适应返回大小至少为 $r$ 的空闲段中尺寸最大的那个；平局由最小的起始地址打破。\n\n一旦选择了一个大小为 $s$ 的候选空闲块来满足一个 $r$ 字节的请求，我们计算尾部大小 $t = s - r$ 并应用分割阈值规则：\n- 如果 $t  \\epsilon$，则分配会消耗整个大小为 $s$ 的块，并将其分配给该请求。为此块记录的内部浪费为 $s - r$。不会从此块创建新的空闲段。\n- 如果 $t \\ge \\epsilon$，分配器将空闲块分割成一个大小为 $r$ 的已分配块和一个在紧邻地址的大小为 $t$ 的空闲块。本次分配的内部浪费为 $0$，因为分配的大小等于请求的大小。\n\n当释放一个标识符为 $\\text{id}$ 的块时，该段被标记为空闲，并立即与两侧相邻的空闲邻居进行合并，形成一个单一的空闲块。这个不变性确保了在给定的分配决策下，空闲列表始终保持最大程度的合并状态。\n\n在整个序列结束时，我们计算：\n- 总空闲内存 $F$，即所有空闲段大小的总和。\n- 最大空闲块 $L$，即空闲段中的最大大小；如果没有空闲段，则 $L = 0$。\n- 外部碎片 $E$ 为\n$$\nE = \\begin{cases}\n0,  \\text{当 } F = 0 \\text{ 时},\\\\\n1 - \\dfrac{L}{F},  \\text{当 } F > 0 \\text{ 时}。\n\\end{cases}\n$$\n- 内部碎片 $I$，即当前已分配段的 $(\\text{allocated\\_size} - \\text{requested\\_size})$ 之和。请注意，这不是一个随时间累积的指标；它是最终状态下锁定在已分配块内部的浪费。\n\n模拟器的算法大纲：\n1. 将内存表示为一个按起始地址排序的段的动态数组。每个事件都会修改此数组。\n2. 对于在策略 $P$ 下的大小为 $r$ 的分配：\n   - 扫描空闲段以根据策略 $P$ 选择索引。\n   - 如果不存在大小至少为 $r$ 的段，则序列会失败；然而，所提供的序列是一致的，因此在给定约束下所有分配都会成功。\n   - 设所选段的大小为 $s$，起始地址为 $a$。计算 $t = s - r$。如果 $t  \\epsilon$，则分配整个段：将其标记为已分配，并设置 $\\text{requested\\_size} = r$ 和 $\\text{allocated\\_size} = s$。如果 $t \\ge \\epsilon$，则进行分割：将所选段更改为大小为 $r$ 的已分配段，并紧随其后插入一个大小为 $t$、起始地址为 $a + r$ 的新空闲段。\n3. 对于释放标识符为 $\\text{id}$ 的块：\n   - 找到具有该 $\\text{id}$ 的已分配段并将其标记为空闲。\n   - 如果前一个邻居是空闲的，则通过合并大小和调整起始地址来与其合并。然后，如果后一个邻居是空闲的，则与其合并。由于列表保持排序，每个邻居的合并操作耗时为常数时间。\n4. 处理完所有操作后，按规定计算 $F$、$L$、$E$ 和 $I$。\n\n一个案例的示例性推导，用以演示原理：\n考虑在首次适应策略下 $\\epsilon = 4$ 的情况。在 $M=100$ 上的确定性序列是：\n- 分配 id $1$ 大小 $20$：分割 $100 \\to 20 + 80$，因为 $80 \\ge 4$。\n- 分配 id $2$ 大小 $10$：分割 $80 \\to 10 + 70$，因为 $70 \\ge 4$。\n- 分配 id $3$ 大小 $15$：分割 $70 \\to 15 + 55$，因为 $55 \\ge 4$。\n- 释放 id $2$：这个 10 字节的块变为空闲。\n- 分配 id $4$ 大小 $9$：选择第一个大小为 10 的空闲块。尾部大小为 $t = 1$，由于 $1  4$，消耗整个 10 字节的块。在 id 4 上记录内部浪费 $10 - 9 = 1$。\n- 分配 id $5$ 大小 $8$：选择下一个大小为 55 的空闲块；分割成 $8 + 47$，因为 $47 \\ge 4$。\n- 释放 id $3$：这个 15 字节的块变为空闲；其邻居都是已分配块，所以除了自身之外不进行合并。\n- 分配 id $6$ 大小 $12$：选择第一个大小为 15 的空闲块。尾部大小为 $t = 3$，由于 $3  4$，消耗整个 15 字节的块。在 id 6 上记录内部浪费 $15 - 12 = 3$。\n- 释放 id $1$：这个 20 字节的块变为空闲。\n- 分配 id $7$ 大小 $18$：选择第一个大小为 20 的空闲块。尾部大小为 $t = 2$，由于 $2  4$，消耗整个 20 字节的块。在 id 7 上记录内部浪费 $20 - 18 = 2$。\n\n结束时，唯一的空闲内存是那个 47 字节的块；因此 $F = 47, L = 47$，所以 $E = 1 - 47/47 = 0$。内部碎片为 $I = 1 + 3 + 2 = 6$ 字节。这演示了增加 $\\epsilon$ 如何以增加内部浪费为代价来抑制小的外部碎片。\n\n作为比较，在同样 $\\epsilon = 4$ 的最差适应策略下，选择过程会重复挑选最大的块，产生总是至少为 $\\epsilon$ 的大尾部；因此 $I = 0$，最终的空闲集合是两个块，其大小总和为 $F = 53$，最大块为 $L = 27$，得到 $E = 1 - 27/53 \\approx 0.490566$。\n\n通过为每个 $\\epsilon \\in \\{0, 2, 4, 12\\}$ 和每种策略执行定义的序列，模拟器计算出最终的 $E$ 和 $I$ 值。程序必须输出一个包含 24 个浮点数的方括号列表，按每个 $\\epsilon$ 的 $E_{\\mathrm{FF}}, I_{\\mathrm{FF}}, E_{\\mathrm{BF}}, I_{\\mathrm{BF}}, E_{\\mathrm{WF}}, I_{\\mathrm{WF}}$ 顺序排列，每个数字小数点后精确到六位，用逗号分隔，无附加文本。",
            "answer": "[0.490566, 0.000000, 0.490566, 0.000000, 0.490566, 0.000000, 0.490566, 0.000000, 0.000000, 1.000000, 0.490566, 0.000000, 0.000000, 6.000000, 0.000000, 6.000000, 0.490566, 0.000000, 0.000000, 25.000000, 0.000000, 25.000000, 0.000000, 19.000000]"
        }
    ]
}