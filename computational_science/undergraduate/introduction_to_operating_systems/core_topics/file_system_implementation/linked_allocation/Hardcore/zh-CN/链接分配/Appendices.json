{
    "hands_on_practices": [
        {
            "introduction": "理论学习的一个重要环节是量化分析不同数据结构的性能。此练习旨在通过一个具体的文件截断场景，让您亲手计算和比较链式分配与索引分配的性能差异。通过分析这一常见操作的成本，您将深刻理解为何简单的链式分配在处理文件尾部操作时效率低下，并认识到批量处理等优化策略的价值 。",
            "id": "3653085",
            "problem": "考虑一个支持两种文件块分配方法的文件系统：通过文件分配表 (FAT) 的链接分配和通过索引节点 (inode) 的索引分配。在链接分配中，文件的目录项仅存储指向第一个块的指针；每个块存储指向下一个块的指针。在索引分配中，inode 在一个保存在主内存中的单级索引块中存储指向所有数据块的指针。\n\n假设一个文件当前占用了 $N=50{,}000$ 个块。一个应用程序发出 $B=10{,}000$ 次连续的截断操作，每次操作都精确地移除文件的最后一个块。所有元数据结构都驻留在主内存中。以下操作成本适用：\n- 读取单个指针（从 FAT 或索引块）的成本为 $t_{r} = 80$ 纳秒。\n- 写入单个指针（到 FAT 或索引块）的成本为 $t_{w} = 120$ 纳秒。\n- 在空闲空间位图中写入一位的成本为 $t_{f} = 150$ 纳秒。\n- 每次截断调用更新文件元数据（例如，目录项或 inode 中的文件大小）的成本为 $t_{i} = 200$ 纳秒。\n\n在没有尾指针的链接分配下，截断一个当前长度为 $m$ 的文件的最后一个块需要从头开始遍历链表到尾块的前一个块，以将其后继指针更新为空终止符。在索引分配下，截断最后一个块需要清除索引中的最后一个指针，而不需要遍历。\n\n你必须：\n1. 从链接分配和索引分配的核心定义出发，推导出每种方法在每次截断步骤中执行的指针更新次数，并对链接分配在 $B$ 次连续截断中的总次数进行汇总。\n2. 使用给定的成本，计算当使用链接分配和索引分配，以 $B$ 次连续的单块截断操作来移除最后 $B$ 个块时，各自的总时间。\n3. 假设操作系统对链接分配应用了批量优化：它遍历链表一次到达新的尾部（第 $(N-B)$ 个块），执行一次指针写入以在此处终止列表，在位图中写入 $B$ 位，并执行一次元数据更新。推导这种批量方法的总时间。\n4. 最后，报告使用 $B$ 次连续单块截断的链接分配总时间与使用 $B$ 次连续单块截断的索引分配总时间的比率，作为一个无量纲的单一数字。将最终比率四舍五入到四位有效数字。为清晰起见，所有中间时间都以秒为单位表示，但所要求的最终比率是无量纲的。",
            "solution": "首先验证问题以确保其具有科学依据、定义明确且客观。\n\n### 步骤 1: 提取已知条件\n- **文件系统方法**：链接分配（FAT，无尾指针）和索引分配（inode，单级索引）。\n- **初始状态**：文件大小为 $N = 50{,}000$ 个块。\n- **操作**：$B = 10{,}000$ 次连续的单块截断。\n- **内存假设**：所有元数据（FAT、索引块）都在主内存中。\n- **操作成本**：\n    - 指针读取时间：$t_r = 80 \\text{ ns}$\n    - 指针写入时间：$t_w = 120 \\text{ ns}$\n    - 空闲空间位图位写入时间：$t_f = 150 \\text{ ns}$\n    - 每次调用的元数据更新时间（例如文件大小）：$t_i = 200 \\text{ ns}$\n- **链接分配算法（连续）**：对于一个有 $m$ 个块的文件，遍历到第 $m-1$ 个块并更新其指针。\n- **索引分配算法（连续）**：清除索引块中的最后一个指针。\n- **链接分配算法（批量）**：遍历一次到第 $N-B$ 个块，一次指针写入，$B$ 次位图写入，一次元数据更新。\n\n### 步骤 2: 使用提取的已知条件进行验证\n该问题提出了一个来自操作系统领域的程式化但标准的算法分析问题。链接和索引文件分配的概念是基础性的。成本模型虽然简化（例如，忽略缓存效应并假设内存访问时间恒定），但对于比较性能分析是一个有效的基础。所有参数都明确定义，任务也没有歧义。问题是自包含的且逻辑上一致。它不违反科学原理，不是定义不良的，并且是客观呈现的。\n\n### 步骤 3: 结论与行动\n问题是**有效的**。将提供完整的解决方案。\n\n解决方案通过解决问题的四个要求部分来进行。\n\n### 1  2. 连续单块截断的总时间\n\n我们将为两种分配方法推导 $B$ 次连续截断的成本。\n\n**链接分配（连续）**\n\n首先，我们分析单次截断步骤的成本。设第 $k$ 次截断操作发生在文件有 $m_k$ 个块时，其中 $k \\in \\{1, 2, \\dots, B\\}$。初始时，$m_1=N$。第一次截断后，$m_2 = N-1$，以此类推。第 $k$ 次截断前的块数为 $m_k = N - (k-1)$。\n\n要截断最后一个块（第 $m_k$ 个块），系统必须遍历块的链表以找到它的前一个块，即第 $m_k - 1$ 个块。这需要读取块 $1, 2, \\dots, m_k-2$ 中的指针。\n- 第 $k$ 次截断的指针读取次数：$N_{\\text{reads},k} = m_k - 2 = (N - k + 1) - 2 = N - k - 1$。\n- 到达第 $m_k - 1$ 个块后，其指针被覆写为空终止符。这构成一次指针写入。\n- 第 $k$ 次截断的指针写入次数：$N_{\\text{writes},k} = 1$。\n\n第 $k$ 次截断的总成本 $C_{\\text{linked}, k}$ 是指针读取、一次指针写入、一次位图更新和一次元数据更新的成本总和：\n$$C_{\\text{linked},k} = (N - k - 1)t_r + t_w + t_f + t_i$$\n为了求得总时间 $T_{\\text{linked, succ}}$，我们将此成本在所有 $B$ 次截断（从 $k=1$到 $k=B$）上求和：\n$$T_{\\text{linked, succ}} = \\sum_{k=1}^{B} C_{\\text{linked},k} = \\sum_{k=1}^{B} \\left[ (N-k-1)t_r + t_w + t_f + t_i \\right]$$\n$$T_{\\text{linked, succ}} = t_r \\sum_{k=1}^{B} (N-k-1) + B(t_w+t_f+t_i)$$\n求和项是一个等差数列的和：\n$$\\sum_{k=1}^{B} (N-k-1) = (N-2) + (N-3) + \\dots + (N-B-1)$$\n该和可以计算为 $\\frac{\\text{项数}}{2} \\times (\\text{首项} + \\text{末项})$：\n$$\\sum_{k=1}^{B} (N-k-1) = \\frac{B}{2}((N-2) + (N-B-1)) = \\frac{B(2N-B-3)}{2}$$\n所以，总时间为：\n$$T_{\\text{linked, succ}} = \\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)$$\n代入给定值：\n$N = 50000$, $B = 10000$, $t_r = 80 \\times 10^{-9} \\text{ s}$, $t_w = 120 \\times 10^{-9} \\text{ s}$, $t_f = 150 \\times 10^{-9} \\text{ s}$, $t_i = 200 \\times 10^{-9} \\text{ s}$。\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(2 \\cdot 50000 - 10000 - 3)}{2}\\right](80 \\times 10^{-9}) + 10000(120+150+200) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(89997)}{2}\\right](80 \\times 10^{-9}) + 10000(470) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = (449,985,000)(80 \\times 10^{-9}) + 4,700,000 \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = 35.9988 \\text{ s} + 0.0047 \\text{ s} = 36.0035 \\text{ s}$$\n\n**索引分配（连续）**\n\n对于索引分配，inode 指向内存中的一个索引块，该索引块包含一个指向数据块的指针数组。要截断最后一个块，系统只需修改这个索引块。\n- 对于每次截断，指向最后一个块的指针被清除（设置为空）。这是一次指针写入。遍历不需要指针读取。\n- 每次截断的指针读取次数：$N_{\\text{reads}} = 0$。\n- 每次截断的指针写入次数：$N_{\\text{writes}} = 1$。\n\n单次截断的成本 $C_{\\text{indexed}}$ 是恒定的：\n$$C_{\\text{indexed}} = t_w + t_f + t_i$$\n$B$ 次连续截断的总时间 $T_{\\text{indexed, succ}}$ 为：\n$$T_{\\text{indexed, succ}} = B \\times C_{\\text{indexed}} = B(t_w+t_f+t_i)$$\n代入值：\n$$T_{\\text{indexed, succ}} = 10000(120 + 150 + 200) \\times 10^{-9} = 10000(470) \\times 10^{-9} = 4,700,000 \\times 10^{-9} = 0.0047 \\text{ s}$$\n\n### 3. 批量优化的链接分配的总时间\n\n在这种情况下，移除 $B$ 个块的整个操作通过单次遍历完成。\n1.  **遍历**：系统遍历到新的尾块，即第 $N-B$ 个块。这需要读取块 $1, 2, \\dots, N-B-1$ 中的指针。\n    指针读取次数：$N - B - 1$。\n2.  **指针写入**：第 $N-B$ 个块中的指针被更新为空终止符。\n    指针写入次数：$1$。\n3.  **位图更新**：所有 $B$ 个被释放的块都在空闲空间位图中被标记。\n    位图写入次数：$B$。\n4.  **元数据更新**：文件大小在整个批量操作中只更新一次。\n    元数据更新次数：$1$。\n\n总时间 $T_{\\text{linked, batch}}$ 为：\n$$T_{\\text{linked, batch}} = (N-B-1)t_r + t_w + B t_f + t_i$$\n代入值：\n$$T_{\\text{linked, batch}} = (50000 - 10000 - 1)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 10000(150 \\times 10^{-9}) + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (39999)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 1,500,000 \\times 10^{-9} + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (3,199,920 + 120 + 1,500,000 + 200) \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = 4,700,240 \\times 10^{-9} = 0.00470024 \\text{ s}$$\n\n### 4. 连续截断时间的比率\n\n最后，我们计算连续链接分配的总时间与连续索引分配的总时间的比率。\n$$R = \\frac{T_{\\text{linked, succ}}}{T_{\\text{indexed, succ}}} = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)}{B(t_w+t_f+t_i)}$$\n$$R = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r}{B(t_w+t_f+t_i)} + 1 = \\frac{(2N-B-3)t_r}{2(t_w+t_f+t_i)} + 1$$\n使用数值：\n$$R = \\frac{(2 \\cdot 50000 - 10000 - 3)(80)}{2(120+150+200)} + 1$$\n$$R = \\frac{(89997)(80)}{2(470)} + 1$$\n$$R = \\frac{7199760}{940} + 1$$\n$$R \\approx 7659.31914... + 1 = 7660.31914...$$\n四舍五入到四位有效数字，比率为 $7660$。\n或者，使用计算出的时间：\n$$R = \\frac{36.0035 \\text{ s}}{0.0047 \\text{ s}} \\approx 7660.31914...$$\n结果是一致的。最终四舍五入的值是 $7660$。",
            "answer": "$$\\boxed{7660}$$"
        },
        {
            "introduction": "文件系统的稳健性不仅体现在性能上，更关键的是在发生崩溃后保持数据一致性的能力。本练习模拟了一个真实世界中的挑战：一个因意外中断而导致两个文件共享数据块的场景。您需要扮演文件系统一致性检查器的角色，从给定的指针状态中检测出这种“跨链”错误，并评估不同的修复策略，从而培养在不依赖全局索引的情况下进行底层数据结构调试和恢复的思维能力 。",
            "id": "3653075",
            "problem": "一个操作系统对文件使用链接分配。根据链接分配的定义，每个文件表示为一个磁盘块的单向链表：目录为每个文件存储其头块的标识符，每个已分配的块存储一个指向文件中下一个块标识符的指针，或者一个特殊的空值 $0$ 来标记文件结尾。空闲空间被追踪为一个单向链表的空闲列表，其头指针存储在超级块中。系统不维护一个将块映射到后继块的全局文件分配表（FAT），也没有任何持久化的每块所有者或引用计数；磁盘上只存在目录头、空闲列表头以及块内后继指针。\n\n考虑一个小型磁盘，其块标识符为 $1,2,\\dots,12$。目录列出了两个文件，文件 $A$ 和文件 $B$，它们的头块分别是 $2$ 和 $7$。空闲列表的头是 $1$。块内后继指针 $n(b)$ 如下（其中 $n(b)=0$ 表示文件结尾）：\n\n- 文件 $A$：$n(2)=4$, $n(4)=6$, $n(6)=9$, $n(9)=0$。\n- 文件 $B$：$n(7)=8$, $n(8)=6$（然后遵循 $n(6)$ 的指向）。\n- 空闲列表：$n(1)=3$, $n(3)=5$, $n(5)=10$, $n(10)=11$, $n(11)=12$, $n(12)=0$。\n\n在对文件 $B$ 进行写入操作时发生崩溃后，系统恰好处于上述状态。要求您从第一性原理出发，对有向图中的可达性进行推理：将每个磁盘块视为一个顶点，每个块内后继指针视为一条有向边 $b \\to n(b)$，每个目录头视为一个根。一致性检查器必须 (i) 检测两个文件是否通过指针别名共享一个块（即，存在一个可以从两个文件根到达的块），以及 (ii) 仅使用可用的磁盘元数据和任何临时的内存结构来解决不一致性，而不依赖任何预先存在的全局索引。如果一个解决方案不损坏任何剩余的文件数据，则被认为是正确的；如果在没有额外空间的情况下无法完全保留两个文件，该解决方案可以使用空闲块复制数据或截断最多一个文件，但绝不能释放任何仍被引用的块。\n\n在此特定状态下，以下哪些过程既能检测到共享块的不一致性，又能根据所述约束产生一个正确的解决方案？选择所有适用的选项。\n\nA. 从每个文件的头部分别遍历其链，对单个链使用循环检测算法（例如，Floyd 的龟兔赛跑算法）以确保该文件内没有循环；如果没有发现每个文件的循环或悬空指针，则声明系统一致。不跨文件跟踪任何全局已访问信息。\n\nB. 从文件 $A$ 和文件 $B$ 的头部开始进行根导向遍历，维护一个从块标识符到引用计数的内存映射 $c(b)$，初始值为 $0$。每次从任何文件根发现块 $b$ 时，增加 $c(b)$。如果任何 $c(b)1$，则报告存在共享块。为了解决，选择一个文件（例如，文件 $B$），通过从空闲列表中分配新块并将共享块的内容和后继结构复制到新块中来复制共享的后缀；然后将该文件中共享块的前驱重新连接以指向第一个新块。从空闲列表中移除新分配的块。保持另一个文件不变。\n\nC. 通过设置 $n(8)=0$ 来在共享段之前截断文件 $B$，并立即将块 $6$ 和 $9$ 链接到空闲列表的头部来标记它们为空闲，因为文件 $B$ 不再需要它们，以此来修复状态。\n\nD. 仅检查空闲列表是否存在异常（例如循环或与自身重叠）。如果空闲列表是一个与文件头不相交的有效简单链，则声明系统一致，因为在链接分配下，任何问题必然会体现在空闲列表中。\n\nE. 遍历两个文件，同时维护一个内存中的已访问集合 $V$ 和一个“首次拥有者”映射 $o(b)$，该映射记录了首次发现一个块的文件。当发现一个块 $b$ 已经在 $V$ 中，但其 $o(b)$ 是一个不同的文件时，检测到交叉链接。通过在后发现的文件的前驱处截断该文件（例如，对文件 $B$ 设置 $n(8)=0$）来解决，并且不将任何共享块添加到空闲列表中。保持先发现的文件的链完整。",
            "solution": "在尝试给出解决方案之前，将首先验证问题陈述的科学合理性、自洽性和清晰度。\n\n### 步骤1：提取已知条件\n- **文件系统模型**：对文件使用链接分配。\n- **文件结构**：每个文件是一个磁盘块的单向链表。目录为每个文件存储其头块。每个块包含一个指针 $n(b)$，指向下一个块的标识符。指针值为 $0$ 表示文件结尾。\n- **空闲空间管理**：一个单向链表的空闲块列表，其头指针存储在超级块中。\n- **系统约束**：没有全局文件分配表（FAT）。没有持久化的每块所有者或引用计数。唯一的磁盘元数据是目录头、空闲列表头和块内后继指针。\n- **磁盘状态**：\n    - 块标识符：$1, 2, \\dots, 12$。\n    - 文件 A 头：块 $2$。\n    - 文件 B 头：块 $7$。\n    - 空闲列表头：块 $1$。\n- **后继指针, $n(b)$**：\n    - 对于文件 A 的链：$n(2)=4$, $n(4)=6$, $n(6)=9$, $n(9)=0$。\n    - 对于文件 B 的链：$n(7)=8$, $n(8)=6$。\n    - 对于空闲列表：$n(1)=3$, $n(3)=5$, $n(5)=10$, $n(10)=11$, $n(11)=12$, $n(12)=0$。\n- **问题背景**：系统在一次崩溃后处于此状态。\n- **任务**：一致性检查器必须：\n    1. 检测共享块（指针别名）。\n    2. 仅使用磁盘元数据和临时内存结构来解决不一致性。\n- **解决方案约束**：\n    1. 不得损坏剩余的文件数据。\n    2. 如果无法完全保留，可以使用空闲块复制数据或截断最多一个文件。\n    3. 不得释放任何仍被文件引用的块。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题描述了一个简化但连贯的链接分配文件系统模型。这是操作系统入门课程中的一个标准主题。状态使用有向图模型描述，其中块是顶点，指针是边。这是一种形式化且严谨的表示。\n\n- **科学依据**：该问题基于数据结构（链表、图）和操作系统（文件系统管理、崩溃一致性）的原理。特定的不一致性——两个文件链指向同一个块——是此类系统中一个现实的故障模式，尤其是在没有更高级的完整性机制的情况下。\n- **良构性**：磁盘的初始状态（所有相关指针和列表头）已完全指定。一致性检查器的任务（检测和解决）以及对正确解决方案的约束都已明确定义。这允许对所提出的算法进行无歧义的评估。\n- **客观性**：问题以精确的技术术语陈述（例如，“单向链表”、“指针别名”、“根导向遍历”）。没有主观或模棱两可的语言。\n\n该问题不违反任何无效性标准。例如，它不是矛盾的；$n(b)$ 的值定义了一个特定但存在不一致的图结构。对于手头的任务，它没有被不充分地指定。该问题将一个实际的文件系统问题正确地形式化为一个可解的图论问题。\n\n### 步骤3：结论和行动\n问题陈述是**有效的**。将通过分析给定状态和评估每个提议的过程来推导解决方案。\n\n### 系统状态分析\n首先，我们根据给定的条件构建磁盘块的状态。\n- **文件 A 链**：从头块 $2$ 开始，链是 $2 \\to n(2)=4 \\to n(4)=6 \\to n(6)=9 \\to n(9)=0$。分配给文件 A 的块是 $\\{2, 4, 6, 9\\}$。\n- **文件 B 链**：从头块 $7$ 开始，链是 $7 \\to n(7)=8 \\to n(8)=6$。由于 $n(8)=6$，文件 B 的链与文件 A 的链合并。从文件 B 的头部开始的完整路径是 $7 \\to 8 \\to 6 \\to 9 \\to 0$。从文件 B 的头部可达的块是 $\\{7, 8, 6, 9\\}$。\n- **共享块**：块 $6$ 和 $9$ 可以从文件 A 的头部和文件 B 的头部到达。这是一种“共享块”或“交叉链接”的不一致性。\n- **空闲列表链**：从头块 $1$ 开始，链是 $1 \\to 3 \\to 5 \\to 10 \\to 11 \\to 12 \\to 0$。空闲块是 $\\{1, 3, 5, 10, 11, 12\\}$。\n- **块分配总结**：\n    - 仅由文件 A 使用：$\\{2, 4\\}$\n    - 仅由文件 B 使用：$\\{7, 8\\}$\n    - 由文件 A 和文件 B 共享：$\\{6, 9\\}$\n    - 空闲：$\\{1, 3, 5, 10, 11, 12\\}$\n\n任务是评估既能检测到块 $\\{6, 9\\}$ 是共享的，又能根据给定的约束解决此问题的过程。\n\n### 逐项分析\n\n**A. 从每个文件的头部分别遍历其链……使用循环检测算法……不跨文件跟踪任何全局已访问信息。**\n- **检测**：此过程检查单个列表*内部*的病态。文件 A 的链 $2 \\to 4 \\to 6 \\to 9 \\to 0$ 是一条没有循环的简单路径。文件 B 的链 $7 \\to 8 \\to 6 \\to 9 \\to 0$ 也是一条没有循环的简单路径。因为该过程明确指出“不跨文件跟踪任何全局已访问信息”，所以它没有机制来得知块 $6$（以及随后的 $9$）是两个列表的成员。因此，此过程将无法检测到共享块的不一致性。\n- **结论**：**不正确**。\n\n**B. 从文件 A 和文件 B 的头部开始进行根导向遍历，维护一个从块标识符到引用计数的内存映射 $c(b)$……如果任何 $c(b)1$，则报告存在共享块。为了解决，选择一个文件……并通过从空闲列表中分配新块来复制共享的后缀……**\n- **检测**：此过程使用引用计数方法。\n    1. 为所有块 $b$ 初始化一个映射 $c(b) \\to 0$。\n    2. 遍历文件 A ($2 \\to 4 \\to 6 \\to 9$)：这将设置 $c(2)=1$, $c(4)=1$, $c(6)=1$, $c(9)=1$。\n    3. 遍历文件 B ($7 \\to 8 \\to 6 \\to 9$)：这将设置 $c(7)=1$, $c(8)=1$。在访问块 $6$ 时，它会增加 $c(6)$，使其变为 $c(6)=2$。\n    4. 对于块 $6$，$c(b)1$ 的条件得到满足。不一致性被成功检测到。\n- **解决方案**：该过程建议为一个文件复制共享的后缀。共享后缀从块 $6$ 开始。它由块 $\\{6, 9\\}$ 组成。\n    1. 从空闲列表中分配两个新块（例如，块 $1$ 和 $3$）。新的空闲列表头变为 $5$。\n    2. 块 $6$ 的内容被复制到块 $1$。块 $9$ 的内容被复制到块 $3$。\n    3. 为新链设置指针：$n(1)=3$ 和 $n(3)=0$。\n    4. 文件 B 链中的前驱块 $8$ 被更新以指向新链：$n(8)=1$。\n- **结果状态**：\n    - 文件 A：$2 \\to 4 \\to 6 \\to 9 \\to 0$（未改变）。\n    - 文件 B：$7 \\to 8 \\to 1 \\to 3 \\to 0$。\n    - 两个原始文件的数据都被保留了。没有被引用的块被错误地释放。这个解决方案遵守了所有规定的约束。\n- **结论**：**正确**。\n\n**C. 通过设置 $n(8)=0$ 来截断文件 B……并立即将块 $6$ 和 $9$ 链接到空闲列表的头部来标记它们为空闲……**\n- **检测**：这个选项描述的是一个解决方案，而不是一个检测方法。它预设了不一致性是已知的。\n- **解决方案**：该过程是通过设置 $n(8)=0$ 来截断文件 B，然后将块 $6$ 和 $9$ 添加到空闲列表。\n    1. 设置 $n(8)=0$ 后，文件 B 变为 $7 \\to 8 \\to 0$。\n    2. 然后该过程将块 $6$ 和 $9$ 添加到空闲列表。\n    3. 然而，文件 A 的链仍然是 $2 \\to 4 \\to 6 \\to 9 \\to 0$。块 $6$ 和 $9$ 仍在使用中，属于文件 A。\n    4. 将一个仍在使用中的块添加到空闲列表是一个严重错误，因为当该块被重新分配时会导致数据损坏。这违反了“不得释放任何仍被引用的块”的约束。\n- **结论**：**不正确**。\n\n**D. 仅检查空闲列表是否存在异常……如果空闲列表是一个与文件头不相交的有效简单链，则声明系统一致……**\n- **检测**：此过程仅检查空闲列表。在给定状态下，空闲列表是 $1 \\to 3 \\to 5 \\to 10 \\to 11 \\to 12 \\to 0$。这是一个有效的、以空值结尾的、无循环的链。其成员与文件头（$2$ 和 $7$）不相交。根据其逻辑，此过程将声明系统一致。它完全忽略了两个文件分配链之间的交叉链接。其潜在的假设，即所有不一致性都会在空闲列表中体现出来，是错误的。\n- **结论**：**不正确**。\n\n**E. 遍历两个文件，同时维护一个内存中的已访问集合 $V$ 和一个“首次拥有者”映射 $o(b)$……当发现一个块 $b$ 已经在 $V$ 中，但其 $o(b)$ 是一个不同的文件时，检测到交叉链接。通过在后发现的文件的前驱处截断该文件……并且不将任何共享块添加到空闲列表中。**\n- **检测**：此过程使用一个已访问集合和所有权跟踪。\n    1. 初始化 $V=\\{\\}$ 和一个所有者映射 $o$。\n    2. 遍历文件 A ($2 \\to 4 \\to 6 \\to 9$)：对于 $b \\in \\{2, 4, 6, 9\\}$，将 $b$ 添加到 $V$ 并设置 $o(b) = \\text{文件 A}$。\n    3. 遍历文件 B ($7 \\to 8 \\to 6 \\to \\dots$)：\n       - 访问 $7$：不在 $V$ 中。添加到 $V$，设置 $o(7) = \\text{文件 B}$。\n       - 访问 $8$：不在 $V$ 中。添加到 $V$，设置 $o(8) = \\text{文件 B}$。\n       - 访问 $6$：在 $V$ 中。检查所有者：$o(6) = \\text{文件 A}$。这与当前文件（文件 B）不同。检测到交叉链接。\n- **解决方案**：该过程是截断后来发现使用共享块的文件（文件 B）。文件 B 链中共享块 $6$ 的前驱是块 $8$。\n    1. 通过设置 $n(8)=0$ 来截断文件 B。\n    2. 共享块 $\\{6, 9\\}$ 被明确“不添加……到空闲列表”。这是正确的，因为它们仍然是文件 A 的一部分。\n- **结果状态**：\n    - 文件 A：$2 \\to 4 \\to 6 \\to 9 \\to 0$（未改变）。\n    - 文件 B：$7 \\to 8 \\to 0$（已截断）。\n    - 文件 A 的数据被保留，文件 B 被截断，这是一种允许的解决方案策略。没有被引用的块被释放。这个解决方案遵守了所有规定的约束。\n- **结论**：**正确**。",
            "answer": "$$\\boxed{BE}$$"
        },
        {
            "introduction": "链式分配虽然灵活，但其固有缺点是会导致文件在物理磁盘上严重碎片化，影响顺序读取性能。这个实践练习将理论付诸实践，要求您设计并实现一个在线文件整理算法。通过编写代码来模拟块的移动和状态管理，您不仅能加深对链式分配底层机制的理解，还能掌握在资源受限（例如，仅有一个内存缓冲区）的情况下优化数据布局的实用技能 。",
            "id": "3653129",
            "problem": "给定一个简化的磁盘模型和一个使用链接分配存储的单个文件。磁盘被建模为一个从 $0$ 到 $N-1$ 的块索引数组。在链接分配下，一个文件由一系列逻辑上的磁盘块组成，其中每个块存储一个指向下一个块的指针。我们用一个不同的块索引序列 $\\langle s_0, s_1, \\dots, s_{L-1}\\rangle$ 来建模文件的逻辑顺序，其中 $L \\ge 1$ 是文件中的块数。每个 $s_k$ 是 $\\{0,1,\\dots,N-1\\}$ 中的一个磁盘块索引，所有的 $s_k$ 两两不同，并且这些索引当前被此文件占用。其他文件可能会占用额外的磁盘块，这些块由一个集合 $U \\subseteq \\{0,1,\\dots,N-1\\}$ 给出，该集合与 $\\{s_0,\\dots,s_{L-1}\\}$ 不相交。一个磁盘块 $i$ 是空闲的，当且仅当 $i \\notin U$ 且 $i \\notin \\{s_0,\\dots,s_{L-1}\\}$。\n\n目标：设计并实现一个在线紧凑化算法，将文件的块重写到物理顺序上非递减的、近乎连续的区域，同时保持文件的逻辑顺序。该算法必须遵守以下具体规则，这些规则形式化了链接分配和在线操作的约束：\n\n- 磁盘操作模型：\n  - 将一个块读入内存缓冲区需要花费 $1$ 个时间单位。\n  - 将缓冲区中的一个块写入磁盘需要花费 $1$ 个时间单位。\n  - 对文件内指针的更新被假定包含在重写块的写入操作中，不产生额外的 I/O。\n  - 寻道成本被忽略。\n- 空间模型：\n  - 您在任何时候最多可以使用 $1$ 个内存缓冲区块（在线约束）。同时使用的此类缓冲区的峰值数量是需要报告的空间成本。\n- 允许的移动操作：\n  - 要将当前位于物理索引 $s$ 的文件块重定位到一个空闲的目标索引 $t$，您必须将 $s$ 读入缓冲区并将其写入 $t$（时间成本为 $2$）。完成后，$s$ 变为空闲。\n- 放置策略（稳定贪心前向紧凑化，SGFC）：\n  - 维护一个写入光标 $w$，初始化为 $0$。\n  - 按顺序 $s_0, s_1, \\dots, s_{L-1}$ 处理文件的逻辑块。\n  - 对于当前源索引 $s$，选择目标索引 $t$ 为满足 $i \\ge w$ 且 $i$ 当前为空闲或 $i = s$ 的最小 $i$。这确保了如果源块已经处于允许的最早位置，它可以保持原位；否则它将移动到当前最早的空闲索引。\n  - 如果 $t \\ne s$，执行移动操作（读取 $s$，写入 $t$），将 $s$ 标记为空闲，并将 $t$ 标记为被该文件占用。如果 $t = s$，则不执行任何操作。\n  - 设置 $w \\leftarrow t + 1$ 并继续处理下一个逻辑块。\n- 需要计算和报告的度量指标：\n  - 总 I/O 时间 $T$，等于移动块数的 $2$ 倍（每次移动包含一次读取和一次写入）。\n  - 移动的块数 $M$。\n  - 同时使用的峰值额外内存缓冲区块数 $B$。\n  - 最终物理布局 $\\langle t_0,t_1,\\dots,t_{L-1}\\rangle$ 中最长连续序列的长度 $R$，其中当 $t_{k} = t_{k-1} + 1$ 时，连续序列长度增加。\n  - 最终布局本身，即列表 $\\langle t_0,t_1,\\dots,t_{L-1}\\rangle$。\n\n您的任务是严格按照规定实现 SGFC 算法，并计算上述度量指标。\n\n测试套件定义（将这些嵌入您的程序中；不应读取任何输入）：\n\n- 测试用例 1：\n  - $N = 20$\n  - 文件逻辑顺序（当前物理索引）： $\\langle 17, 3, 12, 5, 9, 15 \\rangle$\n  - 其他文件占用 $U = \\{0, 10, 11, 14, 18\\}$\n- 测试用例 2（边界情况：单块文件）：\n  - $N = 8$\n  - 文件逻辑顺序： $\\langle 2 \\rangle$\n  - 其他文件占用 $U = \\{0, 1, 3, 5, 6, 7\\}$\n- 测试用例 3（已经连续，无需移动）：\n  - $N = 12$\n  - 文件逻辑顺序： $\\langle 1, 2, 3, 4 \\rangle$\n  - 其他文件占用 $U = \\{0, 7, 9, 10, 11\\}$\n- 测试用例 4（与后续块占用早期槽位的重叠风险）：\n  - $N = 15$\n  - 文件逻辑顺序： $\\langle 5, 6, 12, 4 \\rangle$\n  - 其他文件占用 $U = \\{0, 1, 9, 14\\}$\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[T, M, B, R, [t_0,t_1,\\dots,t_{L-1}]]$ 形式的列表，不含空格。例如：$[[T_1,M_1,B_1,R_1,[\\dots]],[T_2,M_2,B_2,R_2,[\\dots]],\\dots]$。\n\n输出中的所有数字都是整数。除了上面定义的抽象 I/O 时间单位外，不涉及任何角度或物理单位。",
            "solution": "该问题是定义明确的算法挑战，要求严格实现和分析一个特定的在线文件紧凑化算法（SGFC）。我们将通过为每个测试用例直接模拟该算法来推导结果。模拟的核心是维护一个数组来表示磁盘上每个块的状态（空闲、被其他文件占用、被当前文件占用）。\n\n### 算法执行与度量计算\n\n我们将逐步执行 SGFC 算法并计算每个测试用例的度量指标。\n\n#### 测试用例 1\n- **初始状态**：$N=20$，文件块 $\\langle 17, 3, 12, 5, 9, 15 \\rangle$，$U=\\{0, 10, 11, 14, 18\\}$。空闲块：$\\{1, 2, 4, 6, 7, 8, 13, 16, 19\\}$。\n- **执行步骤**：\n  1. $k=0, s_0=17$。写入光标 $w=0$。第一个空闲位置是 $t_0=1$。移动 $17 \\to 1$。$M=1$。$w=2$。\n  2. $k=1, s_1=3$。$w=2$。第一个空闲位置是 $t_1=2$。移动 $3 \\to 2$。$M=2$。$w=3$。\n  3. $k=2, s_2=12$。$w=3$。块 $3$ 现在空闲，所以第一个空闲位置是 $t_2=3$。移动 $12 \\to 3$。$M=3$。$w=4$。\n  4. $k=3, s_3=5$。$w=4$。第一个空闲位置是 $t_3=4$。移动 $5 \\to 4$。$M=4$。$w=5$。\n  5. $k=4, s_4=9$。$w=5$。块 $5$ 现在空闲，所以第一个空闲位置是 $t_4=5$。移动 $9 \\to 5$。$M=5$。$w=6$。\n  6. $k=5, s_5=15$。$w=6$。第一个空闲位置是 $t_5=6$。移动 $15 \\to 6$。$M=6$。$w=7$。\n- **结果**：\n  - $M=6$ 个移动。\n  - $T = 2 \\times M = 12$。\n  - $B = 1$（因为有移动）。\n  - 最终布局：$\\langle 1, 2, 3, 4, 5, 6 \\rangle$。\n  - 最长连续序列长度 $R=6$。\n- **小计**: `[12,6,1,6,[1,2,3,4,5,6]]`\n\n#### 测试用例 2\n- **初始状态**：$N=8$，文件块 $\\langle 2 \\rangle$，$U=\\{0, 1, 3, 5, 6, 7\\}$。空闲块：$\\{4\\}$。\n- **执行步骤**：\n  1. $k=0, s_0=2$。$w=0$。第一个不被 $U$ 占用的位置是 $2$，它就是源块本身。因此 $t_0=2$。不移动。$M=0$。$w=3$。\n- **结果**：\n  - $M=0$ 个移动。\n  - $T=0$。\n  - $B=0$。\n  - 最终布局：$\\langle 2 \\rangle$。\n  - 最长连续序列长度 $R=1$。\n- **小计**: `[0,0,0,1,[2]]`\n\n#### 测试用例 3\n- **初始状态**：$N=12$，文件块 $\\langle 1, 2, 3, 4 \\rangle$，$U=\\{0, 7, 9, 10, 11\\}$。空闲块：$\\{5, 6, 8\\}$。\n- **执行步骤**：\n  1. $k=0, s_0=1$。$w=0$。位置 $0$ 被 $U$ 占用。第一个可用位置是 $1$，它就是源块本身。$t_0=1$。不移动。$M=0$。$w=2$。\n  2. $k=1, s_1=2$。$w=2$。第一个可用位置是 $2$，即源块本身。$t_1=2$。不移动。$M=0$。$w=3$。\n  3. $k=2, s_2=3$。$w=3$。第一个可用位置是 $3$，即源块本身。$t_2=3$。不移动。$M=0$。$w=4$。\n  4. $k=3, s_3=4$。$w=4$。第一个可用位置是 $4$，即源块本身。$t_3=4$。不移动。$M=0$。$w=5$。\n- **结果**：\n  - $M=0$ 个移动。\n  - $T=0$。\n  - $B=0$。\n  - 最终布局：$\\langle 1, 2, 3, 4 \\rangle$。\n  - 最长连续序列长度 $R=4$。\n- **小计**: `[0,0,0,4,[1,2,3,4]]`\n\n#### 测试用例 4\n- **初始状态**：$N=15$，文件块 $\\langle 5, 6, 12, 4 \\rangle$，$U=\\{0, 1, 9, 14\\}$。空闲块：$\\{2, 3, 7, 8, 10, 11, 13\\}$。\n- **执行步骤**：\n  1. $k=0, s_0=5$。$w=0$。第一个空闲位置是 $t_0=2$。移动 $5 \\to 2$。$M=1$。磁盘状态更新：块 $5$ 变为空闲，块 $2$ 被文件占用。$w=3$。\n  2. $k=1, s_1=6$。$w=3$。第一个空闲位置是 $t_1=3$。移动 $6 \\to 3$。$M=2$。磁盘状态更新：块 $6$ 变为空闲，块 $3$ 被文件占用。$w=4$。\n  3. $k=2, s_2=12$。$w=4$。块 $4$ 当前被该文件的后续部分占用。下一个可用位置是块 $5$（在步骤1中被释放）。所以 $t_2=5$。移动 $12 \\to 5$。$M=3$。磁盘状态更新：块 $12$ 变为空闲，块 $5$ 被文件占用。$w=6$。\n  4. $k=3, s_3=4$。$w=6$。块 $6$ 当前空闲（在步骤2中被释放）。所以 $t_3=6$。移动 $4 \\to 6$。$M=4$。磁盘状态更新：块 $4$ 变为空闲，块 $6$ 被文件占用。$w=7$。\n- **结果**：\n  - $M=4$ 个移动。\n  - $T=2 \\times M=8$。\n  - $B=1$。\n  - 最终布局：$\\langle 2, 3, 5, 6 \\rangle$。\n  - 最长连续序列长度 $R=2$（来自序列 $\\langle 2,3 \\rangle$ 和 $\\langle 5,6 \\rangle$）。\n- **小计**: `[8,4,1,2,[2,3,5,6]]`\n\n### 最终输出\n根据以上分析，所有测试用例的综合结果格式化后如下：\n`[[12,6,1,6,[1,2,3,4,5,6]],[0,0,0,1,[2]],[0,0,0,4,[1,2,3,4]],[8,4,1,2,[2,3,5,6]]]`",
            "answer": "[[12,6,1,6,[1,2,3,4,5,6]],[0,0,0,1,[2]],[0,0,0,4,[1,2,3,4]],[8,4,1,2,[2,3,5,6]]]"
        }
    ]
}