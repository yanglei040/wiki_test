{
    "hands_on_practices": [
        {
            "introduction": "Understanding linked allocation begins with its most fundamental trade-off: the space consumed by pointers versus the data stored. This exercise guides you through a first-principles derivation to quantify this pointer overhead. By establishing a threshold for block size, you will gain a concrete understanding of how design parameters impact storage efficiency .",
            "id": "3653104",
            "problem": "A file system uses linked allocation, where each disk block has a total size of $B$ bytes. In each block, a single pointer of size $p$ bytes is stored to locate the next block in the file, and the remainder of the block is used for file data. Assume that this pointer field is present in every block. The pointer bytes are considered metadata, and the ratio of metadata to useful payload is defined as the pointer overhead fraction. A system design constraint requires that, for each block, the pointer overhead must not exceed a specified fraction $\\theta$ of the useful data stored in that block.\n\nStarting from the definitions that:\n- useful data per block equals total bytes minus metadata bytes, and\n- the pointer overhead fraction is defined as the ratio of metadata bytes to useful data bytes,\n\nderive, from first principles, a closed-form expression for the threshold block size $B_{\\text{threshold}}$ (in terms of $p$ and $\\theta$) at which the pointer overhead equals the allowable fraction $\\theta$. Interpret this threshold as the boundary such that for any block size $B$ smaller than $B_{\\text{threshold}}$, the overhead per block exceeds $\\theta$ times the useful data, and for any $B$ greater than or equal to $B_{\\text{threshold}}$, the overhead per block is at most $\\theta$ times the useful data. Assume $B>p$ and $\\theta>0$.\n\nExpress your final answer as a closed-form analytic expression in bytes, in terms of $p$ and $\\theta$ only. Do not substitute numerical values and do not include units inside the final boxed answer.",
            "solution": "The problem requires the derivation of a closed-form expression for a threshold block size, $B_{\\text{threshold}}$, in a linked-allocation file system. The derivation must start from first principles as defined in the problem statement.\n\nLet the total size of a disk block be $B$ bytes.\nLet the size of the pointer stored in each block be $p$ bytes. This pointer constitutes the metadata.\nLet the maximum allowable pointer overhead fraction be $\\theta$. We are given the assumptions that $B > p$ and $\\theta > 0$.\n\nFirst, we formalize the definitions provided in the problem statement.\n\nLet $M$ be the size of the metadata in a single block. According to the problem, this consists solely of the pointer.\n$$M = p$$\n\nLet $D$ be the amount of useful data stored in a single block. The problem defines this as the total block size minus the metadata bytes.\n$$D = B - M$$\nSubstituting the expression for $M$, we get the useful data as a function of $B$ and $p$:\n$$D(B) = B - p$$\n\nNext, we define the pointer overhead fraction, which we will denote as $O_f$. The problem defines this as the ratio of metadata bytes to useful data bytes.\n$$O_f = \\frac{M}{D}$$\nSubstituting the expressions for $M$ and $D(B)$, we can express the overhead fraction as a function of the block size $B$:\n$$O_f(B) = \\frac{p}{B - p}$$\n\nThe system design imposes a constraint that the pointer overhead must not exceed a fraction $\\theta$ of the useful data. This translates to the inequality $M \\le \\theta D$. Dividing by $D$ (which is positive, since $B > p$ implies $D > 0$), this constraint is equivalent to:\n$$\\frac{M}{D} \\le \\theta$$\nSubstituting our expression for the overhead fraction, the constraint is:\n$$O_f(B) = \\frac{p}{B - p} \\le \\theta$$\n\nThe problem asks for the threshold block size, $B_{\\text{threshold}}$, which is defined as the specific block size at which the pointer overhead fraction *equals* the allowable fraction $\\theta$. This represents the boundary case of the constraint. Therefore, we set $O_f(B_{\\text{threshold}}) = \\theta$.\n$$\\frac{p}{B_{\\text{threshold}} - p} = \\theta$$\n\nWe now solve this equation for $B_{\\text{threshold}}$. Given that $\\theta > 0$ and we require $B_{\\text{threshold}} > p$, we can safely multiply both sides by $(B_{\\text{threshold}} - p)$:\n$$p = \\theta (B_{\\text{threshold}} - p)$$\nDistributing $\\theta$ on the right-hand side gives:\n$$p = \\theta B_{\\text{threshold}} - \\theta p$$\nTo solve for $B_{\\text{threshold}}$, we first isolate the term containing it:\n$$\\theta B_{\\text{threshold}} = p + \\theta p$$\nFactoring out $p$ from the terms on the right-hand side yields:\n$$\\theta B_{\\text{threshold}} = p(1 + \\theta)$$\nFinally, since $\\theta > 0$, we can divide by $\\theta$ to obtain the closed-form expression for the threshold block size:\n$$B_{\\text{threshold}} = \\frac{p(1 + \\theta)}{\\theta}$$\n\nThis expression can also be written as $B_{\\text{threshold}} = p\\left(1 + \\frac{1}{\\theta}\\right)$.\n\nTo confirm the interpretation provided in the problem, we examine the behavior of the overhead fraction function, $O_f(B) = \\frac{p}{B - p}$. The derivative with respect to $B$ is $\\frac{d(O_f)}{dB} = -\\frac{p}{(B - p)^2}$. Since $p > 0$ and $(B-p)^2 > 0$, the derivative is always negative for $B > p$. This means that $O_f(B)$ is a monotonically decreasing function of $B$.\nConsequently:\n- For any block size $B < B_{\\text{threshold}}$, it follows that $O_f(B) > O_f(B_{\\text{threshold}})$, which means $\\frac{p}{B-p} > \\theta$. This matches the condition that the overhead per block exceeds $\\theta$ times the useful data.\n- For any block size $B \\ge B_{\\text{threshold}}$, it follows that $O_f(B) \\le O_f(B_{\\text{threshold}})$, which means $\\frac{p}{B-p} \\le \\theta$. This matches the condition that the overhead per block is at most $\\theta$ times the useful data.\nThe derived expression for $B_{\\text{threshold}}$ is therefore consistent with all conditions and interpretations given in the problem statement.",
            "answer": "$$\\boxed{\\frac{p(1 + \\theta)}{\\theta}}$$"
        },
        {
            "introduction": "Beyond static efficiency, a robust file system must handle unexpected failures. This practice presents a hypothetical crash scenario where two files inadvertently share disk blocks, a classic \"cross-link\" inconsistency. By treating the file system as a directed graph, you will evaluate different algorithmic strategies for detecting and resolving such critical errors, a core task of file system checker utilities .",
            "id": "3653075",
            "problem": "An operating system uses linked allocation for files. By definition of linked allocation, each file is represented as a singly linked list of disk blocks: the directory stores the identifier of the head block for each file, and each allocated block stores a pointer to the identifier of the next block in the file or to a special null value $0$ to mark end-of-file. The free space is tracked as a singly linked free list whose head pointer is stored in a superblock. The system does not maintain a global File Allocation Table (FAT) mapping blocks to successors, nor any persistent per-block owner or reference count; only the directory heads, the free-list head, and the in-block successor pointers exist on disk.\n\nConsider a small disk with block identifiers $1,2,\\dots,12$. The directory lists two files, File $A$ and File $B$, whose head blocks are $2$ and $7$, respectively. The free list head is $1$. The in-block successor pointers $n(b)$ are as follows (with $n(b)=0$ indicating end-of-file):\n\n- File $A$: $n(2)=4$, $n(4)=6$, $n(6)=9$, $n(9)=0$.\n- File $B$: $n(7)=8$, $n(8)=6$ (and then follows whatever $n(6)$ dictates).\n- Free list: $n(1)=3$, $n(3)=5$, $n(5)=10$, $n(10)=11$, $n(11)=12$, $n(12)=0$.\n\nAfter a crash during a write to File $B$, the system is in exactly the state described above. You are asked to reason from first principles about reachability in directed graphs: treat each disk block as a vertex, each in-block successor pointer as a directed edge $b \\to n(b)$, and each directory head as a root. A consistency checker must (i) detect whether two files share a block via pointer aliasing (i.e., there exists a block reachable from both file roots), and (ii) resolve the inconsistency using only the available on-disk metadata and any temporary in-memory structures, without relying on any preexisting global index. A resolution is considered correct if it does not corrupt any remaining file data; if full preservation of both files is impossible without additional space, the resolution may either duplicate data using free blocks or truncate at most one file, but it must not free any still-referenced blocks.\n\nWhich of the following procedures both detect the shared-block inconsistency in this specific state and produce a correct resolution under the stated constraints? Select all that apply.\n\nA. Traverse each file’s chain separately from its head, using a cycle-detection algorithm on the single chain (e.g., Floyd’s tortoise-hare) to ensure there is no cycle within that file; if no per-file cycle or dangling pointer is found, declare the system consistent. Do not track any global visited information across files.\n\nB. Perform a root-directed traversal from both File $A$ and File $B$ heads, maintaining an in-memory map $c(b)$ from block identifiers to reference counts initialized to $0$. Increment $c(b)$ on each discovery of $b$ from any file root. If any $c(b)>1$, report a shared block. To resolve, select one file (e.g., File $B$) and duplicate the shared suffix by allocating new blocks from the free list and copying the contents and successor structure of the shared blocks into the new blocks; then rewire the predecessor in that file to point to the first new block. Remove the newly allocated blocks from the free list. Leave the other file unchanged.\n\nC. Fix the state by setting $n(8)=0$ to truncate File $B$ before the shared segment and immediately marking blocks $6$ and $9$ free by linking them into the head of the free list, because File $B$ no longer needs them.\n\nD. Inspect only the free list for anomalies (such as cycles or overlaps with itself). If the free list is a valid simple chain disjoint from file heads, declare the system consistent, because any problem would necessarily manifest in the free list under linked allocation.\n\nE. Traverse both files while maintaining an in-memory visited set $V$ and a “first owner” map $o(b)$ that records the file from which a block was first discovered. Upon discovering a block $b$ that is already in $V$ but whose $o(b)$ is a different file, detect a cross-link. Resolve by truncating the later-discovered file at its predecessor (e.g., set $n(8)=0$ for File $B$), and do not add any of the shared blocks to the free list. Leave the earlier-discovered file’s chain intact.",
            "solution": "The problem statement will first be validated for scientific soundness, self-consistency, and clarity before a solution is attempted.\n\n### Step 1: Extract Givens\n- **File System Model**: Linked allocation for files.\n- **File Structure**: Each file is a singly linked list of disk blocks. The directory stores the head block for each file. Each block contains a pointer, $n(b)$, to the next block's identifier. A pointer value of $0$ indicates the end of the file.\n- **Free Space Management**: A singly linked list of free blocks, with its head pointer stored in a superblock.\n- **System Constraints**: No global File Allocation Table (FAT). No persistent per-block owner or reference count. The only on-disk metadata are the directory heads, the free-list head, and the in-block successor pointers.\n- **Disk State**:\n    - Block identifiers: $1, 2, \\dots, 12$.\n    - File A head: block $2$.\n    - File B head: block $7$.\n    - Free list head: block $1$.\n- **Successor Pointers, $n(b)$**:\n    - For File A's chain: $n(2)=4$, $n(4)=6$, $n(6)=9$, $n(9)=0$.\n    - For File B's chain: $n(7)=8$, $n(8)=6$.\n    - For the free list: $n(1)=3$, $n(3)=5$, $n(5)=10$, $n(10)=11$, $n(11)=12$, $n(12)=0$.\n- **Problem Context**: The system is in this state after a crash.\n- **Task**: A consistency checker must:\n    1. Detect shared blocks (pointer aliasing).\n    2. Resolve the inconsistency using only on-disk metadata and temporary in-memory structures.\n- **Resolution Constraints**:\n    1. Must not corrupt remaining file data.\n    2. May duplicate data using free blocks or truncate at most one file if full preservation is impossible.\n    3. Must not free any block that is still referenced by a file.\n\n### Step 2: Validate Using Extracted Givens\nThe problem describes a simplified but coherent model of a linked allocation file system. This is a standard topic in introductory operating systems courses. The state is described using a directed graph model, where blocks are vertices and pointers are edges. This is a formal and rigorous representation.\n\n- **Scientifically Grounded**: The problem is grounded in the principles of data structures (linked lists, graphs) and operating systems (file system management, crash consistency). The specific inconsistency—two file chains pointing to the same block—is a realistic failure mode in such systems, especially without more advanced integrity mechanisms.\n- **Well-Posed**: The initial state of the disk (all relevant pointers and list heads) is fully specified. The tasks for the consistency checker (detection and resolution) and the constraints on a correct resolution are clearly defined. This allows for an unambiguous evaluation of the proposed algorithms.\n- **Objective**: The problem is stated in precise, technical terms (e.g., \"singly linked list,\" \"pointer aliasing,\" \"root-directed traversal\"). There is no subjective or ambiguous language.\n\nThe problem does not violate any of the invalidity criteria. For instance, it is not contradictory; the values of $n(b)$ define a specific, albeit inconsistent, graph structure. It is not underspecified for the task at hand. The problem correctly formalizes a practical file system issue into a solvable graph theory problem.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A solution will be derived by analyzing the given state and evaluating each proposed procedure.\n\n### Analysis of the System State\nFirst, we construct the state of the disk blocks based on the givens.\n- **File A chain**: Starting from head block $2$, the chain is $2 \\to n(2)=4 \\to n(4)=6 \\to n(6)=9 \\to n(9)=0$. The blocks allocated to File A are $\\{2, 4, 6, 9\\}$.\n- **File B chain**: Starting from head block $7$, the chain is $7 \\to n(7)=8 \\to n(8)=6$. Since $n(8)=6$, the chain for File B merges with the chain for File A. The full path from File B's head is $7 \\to 8 \\to 6 \\to 9 \\to 0$. The blocks reachable from File B's head are $\\{7, 8, 6, 9\\}$.\n- **Shared Blocks**: Blocks $6$ and $9$ are reachable from both File A's head and File B's head. This is a \"shared-block\" or \"cross-link\" inconsistency.\n- **Free List chain**: Starting from head block $1$, the chain is $1 \\to 3 \\to 5 \\to 10 \\to 11 \\to 12 \\to 0$. The free blocks are $\\{1, 3, 5, 10, 11, 12\\}$.\n- **Summary of Block Allocation**:\n    - Used only by File A: $\\{2, 4\\}$\n    - Used only by File B: $\\{7, 8\\}$\n    - Shared by File A and File B: $\\{6, 9\\}$\n    - Free: $\\{1, 3, 5, 10, 11, 12\\}$\n\nThe task is to evaluate procedures that can both detect that blocks $\\{6, 9\\}$ are shared and then resolve this issue according to the given constraints.\n\n### Option-by-Option Analysis\n\n**A. Traverse each file’s chain separately... using a cycle-detection algorithm... Do not track any global visited information across files.**\n- **Detection**: This procedure checks for pathologies *within* a single list. The chain for File A, $2 \\to 4 \\to 6 \\to 9 \\to 0$, is a simple path with no cycles. The chain for File B, $7 \\to 8 \\to 6 \\to 9 \\to 0$, is also a simple path with no cycles. Because the procedure explicitly states \"Do not track any global visited information across files,\" it has no mechanism to learn that block $6$ (and subsequently $9$) is a member of both lists. Therefore, this procedure will fail to detect the shared-block inconsistency.\n- **Verdict**: **Incorrect**.\n\n**B. Perform a root-directed traversal from both File A and File B heads, maintaining an in-memory map $c(b)$ from block identifiers to reference counts... If any $c(b)>1$, report a shared block. To resolve, select one file... and duplicate the shared suffix by allocating new blocks from the free list...**\n- **Detection**: This procedure uses a reference counting approach.\n    1. Initialize a map $c(b) \\to 0$ for all blocks $b$.\n    2. Traverse File A ($2 \\to 4 \\to 6 \\to 9$): This sets $c(2)=1$, $c(4)=1$, $c(6)=1$, $c(9)=1$.\n    3. Traverse File B ($7 \\to 8 \\to 6 \\to 9$): This sets $c(7)=1$, $c(8)=1$. Upon visiting block $6$, it increments $c(6)$, making $c(6)=2$.\n    4. The condition $c(b)>1$ is met for block $6$. The inconsistency is successfully detected.\n- **Resolution**: The procedure proposes duplicating the shared suffix for one file. The shared suffix starts at block $6$. It consists of blocks $\\{6, 9\\}$.\n    1. Two new blocks are allocated from the free list (e.g., blocks $1$ and $3$). The new free list head becomes $5$.\n    2. The content of block $6$ is copied to block $1$. The content of block $9$ is copied to block $3$.\n    3. The pointers are set for the new chain: $n(1)=3$ and $n(3)=0$.\n    4. The predecessor in File B's chain, block $8$, is updated to point to the new chain: $n(8)=1$.\n- **Resulting State**:\n    - File A: $2 \\to 4 \\to 6 \\to 9 \\to 0$ (unchanged).\n    - File B: $7 \\to 8 \\to 1 \\to 3 \\to 0$.\n    - The data from both original files is preserved. No referenced blocks are incorrectly freed. This resolution adheres to all stated constraints.\n- **Verdict**: **Correct**.\n\n**C. Fix the state by setting $n(8)=0$ to truncate File B... and immediately marking blocks $6$ and $9$ free by linking them into the head of the free list...**\n- **Detection**: This option describes a resolution, not a detection method. It presupposes the inconsistency is known.\n- **Resolution**: The procedure is to truncate File B by setting $n(8)=0$, and then to add blocks $6$ and $9$ to the free list.\n    1. After setting $n(8)=0$, File B becomes $7 \\to 8 \\to 0$.\n    2. The procedure then adds blocks $6$ and $9$ to the free list.\n    3. However, File A's chain is still $2 \\to 4 \\to 6 \\to 9 \\to 0$. Blocks $6$ and $9$ are still in use by File A.\n    4. Adding a block that is still in use to the free list is a severe error, as it leads to data corruption when that block is reallocated. This violates the constraint \"must not free any still-referenced blocks.\"\n- **Verdict**: **Incorrect**.\n\n**D. Inspect only the free list for anomalies... If the free list is a valid simple chain disjoint from file heads, declare the system consistent...**\n- **Detection**: This procedure checks only the free list. In the given state, the free list is $1 \\to 3 \\to 5 \\to 10 \\to 11 \\to 12 \\to 0$. This is a valid, null-terminated, non-cyclic chain. Its members are disjoint from the file heads ($2$ and $7$). According to its logic, this procedure would declare the system consistent. It completely misses the cross-link between the two files' allocation chains. The underlying assumption that all inconsistencies manifest in the free list is false.\n- **Verdict**: **Incorrect**.\n\n**E. Traverse both files while maintaining an in-memory visited set $V$ and a “first owner” map $o(b)$... Upon discovering a block $b$ that is already in $V$ but whose $o(b)$ is a different file, detect a cross-link. Resolve by truncating the later-discovered file at its predecessor... and do not add any of the shared blocks to the free list.**\n- **Detection**: This procedure uses a visited set and ownership tracking.\n    1. Initialize $V=\\{\\}$ and an owner map $o$.\n    2. Traverse File A ($2 \\to 4 \\to 6 \\to 9$):\n       - For $b \\in \\{2, 4, 6, 9\\}$, add $b$ to $V$ and set $o(b) = \\text{File A}$.\n    3. Traverse File B ($7 \\to 8 \\to 6 \\to \\dots$):\n       - Visit $7$: Not in $V$. Add to $V$, set $o(7) = \\text{File B}$.\n       - Visit $8$: Not in $V$. Add to $V$, set $o(8) = \\text{File B}$.\n       - Visit $6$: Is in $V$. Check owner: $o(6) = \\text{File A}$. This is different from the current file, File B. A cross-link is detected.\n- **Resolution**: The procedure is to truncate the file that was discovered to be using the shared block later (File B). The predecessor to the shared block $6$ in File B's chain is block $8$.\n    1. Truncate File B by setting $n(8)=0$.\n    2. The shared blocks $\\{6, 9\\}$ are explicitly \"do not add... to the free list.\" This is correct because they remain part of File A.\n- **Resulting State**:\n    - File A: $2 \\to 4 \\to 6 \\to 9 \\to 0$ (unchanged).\n    - File B: $7 \\to 8 \\to 0$ (truncated).\n    - The data of File A is preserved, and File B is truncated, which is an allowed resolution strategy. No referenced blocks are freed. This resolution adheres to all stated constraints.\n- **Verdict**: **Correct**.",
            "answer": "$$\\boxed{BE}$$"
        },
        {
            "introduction": "The architectural choices in a file system directly dictate its performance for various operations. This problem provides a quantitative comparison of linked allocation and indexed allocation for the common task of file truncation. By modeling the cost of low-level operations, you will uncover a significant performance bottleneck in simple linked allocation and appreciate why alternative structures like inodes are often preferred .",
            "id": "3653085",
            "problem": "Consider a file system that supports two block-allocation methods for files: linked allocation via a File Allocation Table (FAT) and indexed allocation via an index node (inode). In linked allocation, the directory entry of a file stores only the pointer to the first block; each block stores a pointer to the next block. In indexed allocation, the inode stores pointers to all data blocks in a single-level index block, which is kept in main memory.\n\nAssume a file currently occupies $N=50{,}000$ blocks. An application issues $B=10{,}000$ successive truncation operations, each removing exactly the last block of the file. All metadata structures are resident in main memory. The following operation costs apply:\n- Reading a single pointer (from the FAT or an index block) costs $t_{r} = 80$ nanoseconds.\n- Writing a single pointer (to the FAT or an index block) costs $t_{w} = 120$ nanoseconds.\n- Writing one bit in the free-space bitmap costs $t_{f} = 150$ nanoseconds.\n- Updating file metadata (for example, file size in the directory entry or inode) per truncation call costs $t_{i} = 200$ nanoseconds.\n\nUnder linked allocation without a tail pointer, truncating the last block of a file of current length $m$ requires traversing the chain from the head to the predecessor of the tail to update the predecessor’s next pointer to the null terminator. Under indexed allocation, truncating the last block requires clearing the last pointer in the index and does not require traversal.\n\nYou must:\n1. From core definitions of linked and indexed allocation, derive the number of pointer updates performed per truncation step for each method, and aggregate them across $B$ successive truncations for linked allocation.\n2. Using the given costs, compute the total time to remove the last $B$ blocks when performed as $B$ successive single-block truncations using linked allocation and using indexed allocation.\n3. Suppose the operating system applies a batch optimization for linked allocation: it traverses the chain once to the new tail (the $(N-B)$-th block), performs a single pointer write to terminate the list there, writes $B$ bits in the bitmap, and performs a single metadata update. Derive the total time of this batch approach.\n4. Finally, report the ratio of the total time of linked allocation with $B$ successive single-block truncations to the total time of indexed allocation with $B$ successive single-block truncations, as a single dimensionless number. Round your final ratio to four significant figures. Express all intermediate times in seconds for clarity, but the requested final ratio is dimensionless.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **File System Methods**: Linked allocation (FAT, no tail pointer) and Indexed allocation (inode, single-level index).\n- **Initial State**: File size is $N = 50{,}000$ blocks.\n- **Operations**: $B = 10{,}000$ successive single-block truncations.\n- **Memory Assumption**: All metadata (FAT, index block) are in main memory.\n- **Operation Costs**:\n    - Pointer read time: $t_r = 80 \\text{ ns}$\n    - Pointer write time: $t_w = 120 \\text{ ns}$\n    - Free-space bitmap bit write time: $t_f = 150 \\text{ ns}$\n    - Per-call metadata update time (e.g., file size): $t_i = 200 \\text{ ns}$\n- **Algorithm for Linked Allocation (Successive)**: For a file of $m$ blocks, traverse to block $m-1$ and update its pointer.\n- **Algorithm for Indexed Allocation (Successive)**: Clear the last pointer in the index block.\n- **Algorithm for Linked Allocation (Batch)**: Traverse once to block $N-B$, one pointer write, $B$ bitmap writes, one metadata update.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presents a stylized but standard algorithmic analysis question from the field of operating systems. The concepts of linked and indexed file allocation are fundamental. The cost model, though simplified (e.g., ignoring cache effects and assuming constant memory access times), is a valid basis for a comparative performance analysis. All parameters are clearly defined, and the tasks are unambiguous. The problem is self-contained and logically consistent. It does not violate scientific principles, is not ill-posed, and is presented objectively.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\nThe solution proceeds by addressing the four required components of the problem.\n\n### 1 & 2. Total Time for Successive Single-Block Truncations\n\nWe will derive the costs for both allocation methods for $B$ successive truncations.\n\n**Linked Allocation (Successive)**\n\nFirst, we analyze the cost of a single truncation step. Let the $k$-th truncation operation occur when the file has $m_k$ blocks, for $k \\in \\{1, 2, \\dots, B\\}$. Initially, $m_1=N$. After the first truncation, $m_2 = N-1$, and so on. The number of blocks before the $k$-th truncation is $m_k = N - (k-1)$.\n\nTo truncate the last block ($m_k$), the system must traverse the linked list of blocks to find its predecessor, block $m_k - 1$. This requires reading the pointers in blocks $1, 2, \\dots, m_k-2$.\n- Number of pointer reads for the $k$-th truncation: $N_{\\text{reads},k} = m_k - 2 = (N - k + 1) - 2 = N - k - 1$.\n- Upon reaching block $m_k - 1$, its pointer is overwritten to be the null terminator. This constitutes one pointer write.\n- Number of pointer writes for the $k$-th truncation: $N_{\\text{writes},k} = 1$.\n\nThe total cost for the $k$-th truncation, $C_{\\text{linked}, k}$, is the sum of costs for pointer reads, one pointer write, one bitmap update, and one metadata update:\n$$C_{\\text{linked},k} = (N - k - 1)t_r + t_w + t_f + t_i$$\nTo find the total time, $T_{\\text{linked, succ}}$, we sum this cost over all $B$ truncations (from $k=1$ to $k=B$):\n$$T_{\\text{linked, succ}} = \\sum_{k=1}^{B} C_{\\text{linked},k} = \\sum_{k=1}^{B} \\left[ (N-k-1)t_r + t_w + t_f + t_i \\right]$$\n$$T_{\\text{linked, succ}} = t_r \\sum_{k=1}^{B} (N-k-1) + B(t_w+t_f+t_i)$$\nThe summation term is the sum of an arithmetic series:\n$$\\sum_{k=1}^{B} (N-k-1) = (N-2) + (N-3) + \\dots + (N-B-1)$$\nThe sum can be calculated as $\\frac{\\text{number of terms}}{2} \\times (\\text{first term} + \\text{last term})$:\n$$\\sum_{k=1}^{B} (N-k-1) = \\frac{B}{2}((N-2) + (N-B-1)) = \\frac{B(2N-B-3)}{2}$$\nSo, the total time is:\n$$T_{\\text{linked, succ}} = \\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)$$\nSubstituting the given values:\n$N = 50000$, $B = 10000$, $t_r = 80 \\times 10^{-9} \\text{ s}$, $t_w = 120 \\times 10^{-9} \\text{ s}$, $t_f = 150 \\times 10^{-9} \\text{ s}$, $t_i = 200 \\times 10^{-9} \\text{ s}$.\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(2 \\cdot 50000 - 10000 - 3)}{2}\\right](80 \\times 10^{-9}) + 10000(120+150+200) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = \\left[\\frac{10000(89997)}{2}\\right](80 \\times 10^{-9}) + 10000(470) \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = (449,985,000)(80 \\times 10^{-9}) + 4,700,000 \\times 10^{-9}$$\n$$T_{\\text{linked, succ}} = 35.9988 \\text{ s} + 0.0047 \\text{ s} = 36.0035 \\text{ s}$$\n\n**Indexed Allocation (Successive)**\n\nFor indexed allocation, the inode points to an index block in memory containing an array of pointers to the data blocks. To truncate the last block, the system only needs to modify this index block.\n- For each truncation, the pointer to the last block is cleared (set to null). This is one pointer write. No pointer reads are required for traversal.\n- Number of pointer reads per truncation: $N_{\\text{reads}} = 0$.\n- Number of pointer writes per truncation: $N_{\\text{writes}} = 1$.\n\nThe cost for a single truncation, $C_{\\text{indexed}}$, is constant:\n$$C_{\\text{indexed}} = t_w + t_f + t_i$$\nThe total time for $B$ successive truncations, $T_{\\text{indexed, succ}}$, is:\n$$T_{\\text{indexed, succ}} = B \\times C_{\\text{indexed}} = B(t_w+t_f+t_i)$$\nSubstituting values:\n$$T_{\\text{indexed, succ}} = 10000(120 + 150 + 200) \\times 10^{-9} = 10000(470) \\times 10^{-9} = 4,700,000 \\times 10^{-9} = 0.0047 \\text{ s}$$\n\n### 3. Total Time for Batch-Optimized Linked Allocation\n\nIn this scenario, the total operation to remove $B$ blocks is performed with a single pass.\n1.  **Traversal**: The system traverses to the new tail block, which is block $N-B$. This requires reading the pointers in blocks $1, 2, \\dots, N-B-1$.\n    Number of pointer reads: $N - B - 1$.\n2.  **Pointer Write**: The pointer in block $N-B$ is updated to the null terminator.\n    Number of pointer writes: $1$.\n3.  **Bitmap Update**: All $B$ freed blocks are marked in the free-space bitmap.\n    Number of bitmap writes: $B$.\n4.  **Metadata Update**: The file size is updated once for the entire batch operation.\n    Number of metadata updates: $1$.\n\nThe total time, $T_{\\text{linked, batch}}$, is:\n$$T_{\\text{linked, batch}} = (N-B-1)t_r + t_w + B t_f + t_i$$\nSubstituting values:\n$$T_{\\text{linked, batch}} = (50000 - 10000 - 1)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 10000(150 \\times 10^{-9}) + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (39999)(80 \\times 10^{-9}) + 120 \\times 10^{-9} + 1,500,000 \\times 10^{-9} + 200 \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = (3,199,920 + 120 + 1,500,000 + 200) \\times 10^{-9}$$\n$$T_{\\text{linked, batch}} = 4,700,240 \\times 10^{-9} = 0.00470024 \\text{ s}$$\n\n### 4. Ratio of Successive Truncation Times\n\nFinally, we compute the ratio of the total time for successive linked allocation to that of successive indexed allocation.\n$$R = \\frac{T_{\\text{linked, succ}}}{T_{\\text{indexed, succ}}} = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r + B(t_w+t_f+t_i)}{B(t_w+t_f+t_i)}$$\n$$R = \\frac{\\left[\\frac{B(2N-B-3)}{2}\\right]t_r}{B(t_w+t_f+t_i)} + 1 = \\frac{(2N-B-3)t_r}{2(t_w+t_f+t_i)} + 1$$\nUsing the numerical values:\n$$R = \\frac{(2 \\cdot 50000 - 10000 - 3)(80)}{2(120+150+200)} + 1$$\n$$R = \\frac{(89997)(80)}{2(470)} + 1$$\n$$R = \\frac{7199760}{940} + 1$$\n$$R \\approx 7659.31914... + 1 = 7660.31914...$$\nRounding to four significant figures, the ratio is $7660$.\nAlternatively, using the calculated times:\n$$R = \\frac{36.0035 \\text{ s}}{0.0047 \\text{ s}} \\approx 7660.31914...$$\nThe result is consistent. The final rounded value is $7660$.",
            "answer": "$$\\boxed{7660}$$"
        }
    ]
}