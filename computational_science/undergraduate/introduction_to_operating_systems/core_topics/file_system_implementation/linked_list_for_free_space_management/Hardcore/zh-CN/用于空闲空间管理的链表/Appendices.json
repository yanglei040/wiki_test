{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基础。在编写自己的内存分配器之前，通过手动模拟来深入理解不同分配策略的行为至关重要。本练习  提供了一系列内存分配和释放操作，要求您追踪在“首次适配”和“下次适配”策略下内存的最终状态，从而揭示这两种策略在决策上的关键差异。",
            "id": "3653441",
            "problem": "考虑一个管理连续堆的显式空闲链表分配器。空闲链表是一个严格按地址递增顺序维护的单向链表。该分配器在释放内存时会与左右相邻块进行立即合并，并且仅当分配后剩余部分至少为最小块大小阈值 $m$（一个表示头部/脚部和最小有效载荷要求的正常数）时，才会在分配时分割一个空闲块。下面说明的所有块大小都已包含任何分配器元数据；它们是从空闲链表中取出或返回到空闲链表的精确大小。所有大小都是固定字长的倍数，并且请求从不违反内存对齐。该分配器在空闲链表上使用两种搜索策略之一：首次适应（first-fit）或下次适应（next-fit）。首次适应策略总是从头部开始扫描。下次适应策略维护一个漫游指针（rover），从上一次搜索终止的节点继续搜索（需要时会回绕到头部）；在任何分配之前，漫游指针的初始位置在头部；从一个被分割的空闲块成功分配后，漫游指针被设置到剩余块；如果没有剩余块，漫游指针指向被消耗块在空闲链表中的后继者。\n\n假设堆最初由一个大小为 $12n$ 字节的单个空闲块组成，起始地址为 $0$，结束地址为 $12n$。考虑以下操作轨迹，其中每个 $\\mathrm{malloc}$ 请求的块大小都与所述完全一致，每个 $\\mathrm{free}$ 都精确释放由指定操作先前分配的块。这些操作是：\n\n- 操作 $1$：$\\mathrm{malloc}(3n)$ 产生块 $B_1$。\n- 操作 $2$：$\\mathrm{malloc}(4n)$ 产生块 $B_2$。\n- 操作 $3$：$\\mathrm{malloc}(2n)$ 产生块 $B_3$。\n- 操作 $4$：$\\mathrm{free}(B_2)$。\n- 操作 $5$：$\\mathrm{malloc}(3n)$ 产生块 $B_4$。\n- 操作 $6$：$\\mathrm{free}(B_1)$。\n- 操作 $7$：$\\mathrm{free}(B_3)$。\n\n已知在操作 7 之后，观察到的空闲链表（请记住，它是按地址递增顺序排列的）恰好包含两个空闲块：第一个大小为 $3n$，紧随其后（按地址顺序）的是第二个大小为 $6n$ 的块。\n\n在刚才描述的分配器模型下，以下哪个陈述是正确的？您的答案应指明哪种或哪些策略可以通过该操作轨迹产生观察到的空闲链表形态，在给定的下次适应漫游指针语义下这种识别是否唯一，以及为了使观察结果可实现，关于 $n$（相对于 $m$）的充分必要条件是什么。\n\nA. 首次适应和下次适应策略都能在所有满足 $n \\ge m$ 的 $n$ 值下产生观察到的最终空闲链表；因此，从观察结果中无法唯一识别分配策略。\n\nB. 只有首次适应策略能够产生观察到的最终空闲链表，且当且仅当 $n \\ge m$ 时发生；在给定的下次适应漫游指针语义下，这种识别是唯一的，因为下次适应策略无法产生该观察结果。\n\nC. 对于任何 $n$，只有下次适应策略能够产生观察到的最终空闲链表；首次适应策略不能。\n\nD. 对于任何 $n$，两种策略都无法产生观察到的最终空闲链表；无论 $n$ 为何值，该观察结果都与分配器模型相矛盾。",
            "solution": "该问题陈述是计算系统领域一个良构且自洽的练习，具体涉及动态内存分配器的行为。它以已确立的计算机科学原理为科学依据，其术语定义足够精确，可以进行形式化分析。因此，该问题是有效的。\n\n我们用一个元组 `[地址, 大小]` 来表示一个内存块。用括号括起来的此类元组列表，例如 `(...)`，将代表按地址递增顺序维护的空闲链表。\n\n堆的初始状态是位于地址 $0$ 的一个大小为 $12n$ 的单个空闲块。\n初始堆：`[0, 12n]`\n初始空闲链表 (FL)：`( [0, 12n] )`\n\n现在我们将为首次适应（FF）和下次适应（NF）这两种策略分别追踪操作序列。\n\n### 首次适应 (FF) 策略分析\n\nFF 策略总是从空闲链表的头部开始搜索合适的空闲块。\n\n**初始状态：** FL = `( [0, 12n] )`。\n\n**操作 1: `\\mathrm{malloc}(3n)` $\\to B_1$**\nFF 找到块 `[0, 12n]`。剩余部分大小为 $12n - 3n = 9n$。假设发生分割（这要求 $9n \\ge m$），块 $B_1$ 在 `[0, 3n]` 处被分配。\n状态：FL = `( [3n, 9n] )`。$B_1$ 是 `[0, 3n]`。\n\n**操作 2: `\\mathrm{malloc}(4n)` $\\to B_2$**\nFF 找到块 `[3n, 9n]`。剩余部分大小为 $9n - 4n = 5n$。假设发生分割（要求 $5n \\ge m$），块 $B_2$ 在 `[3n, 4n]` 处被分配。\n状态：FL = `( [7n, 5n] )`。$B_2$ 是 `[3n, 4n]`。\n\n**操作 3: `\\mathrm{malloc}(2n)` $\\to B_3$**\nFF 找到块 `[7n, 5n]`。剩余部分大小为 $5n - 2n = 3n$。假设发生分割（要求 $3n \\ge m$），块 $B_3$ 在 `[7n, 2n]` 处被分配。\n状态：FL = `( [9n, 3n] )`。$B_3$ 是 `[7n, 2n]`。\n\n**操作 4: `\\mathrm{free}(B_2)`**\n位于 `[3n, 4n]` 的 $B_2$ 被释放。它的左相邻块（位于 `[0, 3n]` 的 `B_1`）和右相邻块（位于 `[7n, 2n]` 的 `B_3`）都处于已分配状态。因此，不发生合并。新的空闲块按地址顺序插入到空闲链表中。\n状态：FL = `( [3n, 4n], [9n, 3n] )`。\n\n**操作 5: `\\mathrm{malloc}(3n)` $\\to B_4$**\nFF 从 FL 的头部 `[3n, 4n]` 开始。这个块足够大。剩余部分大小为 $4n - 3n = n$。这里的“当且仅当”分割规则至关重要。\n*   **情况 1：$n \\ge m$。** 发生分割。$B_4$ 在 `[3n, 3n]` 处被分配。产生一个新的空闲块，即剩余部分 `[6n, n]`。\n    FL 中的块 `[3n, 4n]` 被 `[6n, n]` 替换。\n    状态：FL = `( [6n, n], [9n, 3n] )`。$B_4$ 是 `[3n, 3n]`。\n*   **情况 2：$n  m$。** 不发生分割。整个块 `[3n, 4n]` 被分配给 $B_4$（产生大小为 $n$ 的内部碎片）。\n    状态：FL = `( [9n, 3n] )`。$B_4$ 是 `[3n, 4n]`。\n\n我们对两种情况继续追踪。\n\n**操作 6: `\\mathrm{free}(B_1)`**\n位于 `[0, 3n]` 的 $B_1$ 被释放。\n*   **情况 1 ($n \\ge m$)：** `[0, 3n]` 的右相邻块是位于 `[3n, 3n]` 的 $B_4$，它已被分配。不发生合并。新的空闲块 `[0, 3n]` 被添加到 FL 的头部。\n    状态：FL = `( [0, 3n], [6n, n], [9n, 3n] )`。\n*   **情况 2 ($n  m$)：** `[0, 3n]` 的右相邻块是位于 `[3n, 4n]` 的 $B_4$，它已被分配。不发生合并。新的空闲块 `[0, 3n]` 被添加到 FL 的头部。\n    状态：FL = `( [0, 3n], [9n, 3n] )`。\n\n**操作 7: `\\mathrm{free}(B_3)`**\n位于 `[7n, 2n]` 的 $B_3$ 被释放。\n*   **情况 1 ($n \\ge m$)：** 我们检查 `[7n, 2n]` 在堆中的相邻块。\n    -   左相邻块：在地址 $7n - n = 6n$ 处，我们有空闲块 `[6n, n]`。发生合并。新块为 `[6n, n+2n] = [6n, 3n]`。\n    -   这个新块的右相邻块（即 $B_3$ 的原始右相邻块）：在地址 $7n+2n = 9n$ 处，我们有空闲块 `[9n, 3n]`。发生合并。最终合并的块是 `[6n, 3n+3n] = [6n, 6n]`。\n    此操作前的 FL 是 `( [0, 3n], [6n, n], [9n, 3n] )`。块 `[6n, n]` 和 `[9n, 3n]` 被单个块 `[6n, 6n]` 替换。\n    **最终 FL (FF, $n \\ge m$)： `( [0, 3n], [6n, 6n] )`**。这与观察到的状态相符：两个大小分别为 $3n$ 和 $6n$ 的块。这条路径仅在所有假设的分割都发生时才会出现，这要求 $9n \\ge m$，$5n \\ge m$，$3n \\ge m$ 和 $n \\ge m$。其充分必要条件是 $n \\ge m$。\n\n*   **情况 2 ($n  m$)：** 我们检查 `[7n, 2n]` 的相邻块。\n    -   左相邻块：在地址 $3n$ 处，我们有位于 `[3n, 4n]` 的 $B_4$，它已被分配。不发生左合并。\n    -   右相邻块：在地址 $9n$ 处，我们有空闲块 `[9n, 3n]`。发生合并。新块为 `[7n, 2n+3n] = [7n, 5n]`。\n    此操作前的 FL 是 `( [0, 3n], [9n, 3n] )`。块 `[9n, 3n]` 被 `[7n, 5n]` 替换。\n    **最终 FL (FF, $n  m$)： `( [0, 3n], [7n, 5n] )`**。这与观察结果不符。\n\n**FF 的结论：** 首次适应策略能够产生观察到的最终空闲链表，当且仅当 $n \\ge m$。\n\n### 下次适应 (NF) 策略分析\n\nNF 策略维护一个 `rover` 指针，并从 `rover` 的位置开始搜索。最初，漫游指针指向空闲链表的头部。\n\n**初始状态：** FL = `( [0, 12n] )`。漫游指针指向 `[0, 12n]`。\n\n**操作 1: `\\mathrm{malloc}(3n)` $\\to B_1$**\nNF 找到 `[0, 12n]`。假设分割（$9n \\ge m$），$B_1$ 是 `[0, 3n]`。剩余部分是 `[3n, 9n]`。\n状态：FL = `( [3n, 9n] )`。漫游指针更新为指向剩余块 `[3n, 9n]`。\n\n**操作 2: `\\mathrm{malloc}(4n)` $\\to B_2$**\nNF 从 `[3n, 9n]` 开始并找到它。假设分割（$5n \\ge m$），$B_2$ 是 `[3n, 4n]`。剩余部分是 `[7n, 5n]`。\n状态：FL = `( [7n, 5n] )`。漫游指针更新为指向剩余块 `[7n, 5n]`。\n\n**操作 3: `\\mathrm{malloc}(2n)` $\\to B_3$**\nNF 从 `[7n, 5n]` 开始并找到它。假设分割（$3n \\ge m$），$B_3$ 是 `[7n, 2n]`。剩余部分是 `[9n, 3n]`。\n状态：FL = `( [9n, 3n] )`。漫游指针更新为指向剩余块 `[9n, 3n]`。\n\n**操作 4: `\\mathrm{free}(B_2)`**\n位于 `[3n, 4n]` 的 $B_2$ 被释放。不发生合并。`free` 操作不影响漫游指针。\n状态：FL = `( [3n, 4n], [9n, 3n] )`。漫游指针保持在 `[9n, 3n]`。\n\n**操作 5: `\\mathrm{malloc}(3n)` $\\to B_4$**\nNF 从漫游指针 `[9n, 3n]` 开始搜索。这个块完美匹配大小为 $3n$ 的请求。剩余部分为 $0$，小于 $m$（一个正常数），所以不发生分割。该块被完全消耗。\n$B_4$ 在 `[9n, 3n]` 处被分配。原先的空闲块 `[9n, 3n]` 从 FL 中移除。\n漫游指针更新规则规定，对于一个被完全消耗的块，漫游指针移动到它在空闲链表中的后继者。空闲链表是 `( [3n, 4n], [9n, 3n] )`。尾部 `[9n, 3n]` 的后继者通过回绕被认为是头部 `[3n, 4n]`。\n状态：FL = `( [3n, 4n] )`。漫游指针指向 `[3n, 4n]`。$B_4$ 是 `[9n, 3n]`。\n\n这个选择是确定性的。NF 必须选择 `[9n, 3n]`，因为这是它遇到的第一个合适的块。它不会回绕去寻找 `[3n, 4n]`。这从根本上将其行为与 FF 在这一步区分开来。\n\n**操作 6: `\\mathrm{free}(B_1)`**\n位于 `[0, 3n]` 的 $B_1$ 被释放。它的右相邻块是 `[3n, 4n]`，这是一个空闲块。发生合并。形成一个新的空闲块 `[0, 7n]`。漫游指针之前指向 `[3n, 4n]`，它现在是这个更大块的一部分。可以合理地假设漫游指针现在指向 `[0, 7n]`。\n状态：FL = `( [0, 7n] )`。\n\n**操作 7: `\\mathrm{free}(B_3)`**\n位于 `[7n, 2n]` 的 $B_3$ 被释放。它的左相邻块是空闲块 `[0, 7n]`。发生合并。形成一个新的空闲块 `[0, 9n]`。$B_3$ 的右相邻块是位于 `[9n, 3n]` 的 $B_4$，它已被分配。\n**最终 FL (NF)：`( [0, 9n] )`**。\n\n这个最终状态包含一个大小为 $9n$ 的单个空闲块。这与观察到的状态不符。这个结果是稳健的，即使关于 $m$ 的不同假设会阻止早期步骤中的分割，结果也不会改变，因为漫游指针的位置仍然会引导它为 `B_4` 选择最后一个空闲块。\n\n**NF 的结论：** 下次适应策略不能产生观察到的最终空闲链表。\n\n### 选项评估\n\n*   **A. 首次适应和下次适应策略都能在所有满足 $n \\ge m$ 的 $n$ 值下产生观察到的最终空闲链表；因此，从观察结果中无法唯一识别分配策略。**\n    这是**不正确的**。我们的分析表明，下次适应策略无法产生观察到的状态。\n\n*   **B. 只有首次适应策略能够产生观察到的最终空闲链表，且当且仅当 $n \\ge m$ 时发生；在给定的下次适应漫游指针语义下，这种识别是唯一的，因为下次适应策略无法产生该观察结果。**\n    这是**正确的**。我们的分析得出结论，FF 产生该状态当且仅当 $n \\ge m$，而 NF 在任何情况下都无法产生该状态。因此，观察到这个最终状态唯一地将策略识别为首次适应，并对 $n$ 相对于 $m$ 设定了一个条件。\n\n*   **C. 对于任何 $n$，只有下次适应策略能够产生观察到的最终空闲链表；首次适应策略不能。**\n    这是**不正确的**。这与我们的发现相反。\n\n*   **D. 对于任何 $n$，两种策略都无法产生观察到的最终空闲链表；无论 $n$ 为何值，该观察结果都与分配器模型相矛盾。**\n    这是**不正确的**。在 $n \\ge m$ 的条件下，首次适应策略可以产生观察到的状态。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "理解了分配策略后，下一步是亲手实现一个功能性的内存分配器。这个实践练习  指导您构建一个基于显式空闲链表的分配器，并实现两种变体：一种带有边界标记以支持合并，另一种则禁用此功能。通过对比两种变体在相同操作序列下的外部碎片，您将亲眼见证并量化“合并”技术在抑制内存碎片化方面的巨大威力。",
            "id": "3653403",
            "problem": "您需要实现一个确定性的模拟器，该模拟器模拟一个使用空闲块链表来管理空闲空间的连续内存分配器。该分配器必须支持两种变体，这两种变体除了释放时的合并策略不同外，其他方面完全相同：\n- 变体 C（带边界标签）：一个被释放的块通过合并共享边界的区间，与任何紧邻的空闲块进行合并。\n- 变体 B（移除脚部）：一个被释放的块被插入到空闲列表中，不进行任何合并，即使它与其他空闲块相邻。\n\n使用以下核心定义作为基本基础：\n- 一个连续内存区域被建模为从 $0$ 到 $M-1$ 的整数地址，其中 $M \\in \\mathbb{N}$ 是可寻址单元的总数。\n- 空闲空间通过一个由非重叠区间 $[b,\\ell]$ 组成的有序单向链表来维护，这些区间表示从基地址 $b \\in \\mathbb{N}$ 开始、长度为 $\\ell \\in \\mathbb{N}$ 的块，意味着空闲单元是 $\\{b, b+1, \\dots, b+\\ell-1\\}$。两个连续的块 $[b_1,\\ell_1]$ 和 $[b_2,\\ell_2]$ 相邻，当且仅当 $b_1+\\ell_1=b_2$。\n- 一个大小为 $s \\in \\mathbb{N}$ 的分配请求使用首次适应算法：选择第一个满足 $\\ell \\ge s$ 的空闲区间 $[b,\\ell]$，将区间 $[b,s]$ 分配为有效载荷，并更新空闲列表，如果 $\\ell=s$，则移除 $[b,\\ell]$；如果 $\\ells$，则将其替换为 $[b+s,\\ell-s]$。\n- 对先前返回的分配 $[b,\\ell]$ 进行释放操作时，会将 $[b,\\ell]$ 按排序顺序插回空闲列表。在变体 C 中，通过重复合并相邻块来进行合并，以使没有两个空闲区间是相邻的。在变体 B 中，完全不进行合并。\n- 外部碎片度量定义为\n$$\nF_{\\text{ext}} \\;=\\;\n\\begin{cases}\n0,   \\text{如果 } T_{\\text{free}}=0, \\\\\n1 - \\dfrac{L_{\\max}}{T_{\\text{free}}},  \\text{如果 } T_{\\text{free}} > 0,\n\\end{cases}\n$$\n其中 $T_{\\text{free}}$ 是总空闲空间（所有空闲区间长度之和），而 $L_{\\max}$ 是最大空闲区间的大小。\n\n分配标识符按如下方式分配。每次成功的分配都会按成功顺序被赋予下一个正整数标识符 $1,2,3,\\dots$，并且该标识符与当时返回的确切区间 $[b,\\ell]$ 绑定。失败的分配（没有足够大的空闲块）不消耗标识符。释放操作指定一个标识符 $k \\in \\mathbb{N}$；如果 $k$ 当前已被分配，则相应的块会根据当前活动的变体返回到空闲列表。如果 $k$ 当前未被分配，则该释放请求被忽略。\n\n实现一个程序，对下面的每个测试用例运行变体 B 和变体 C，并在每个用例中，计算执行完整个操作序列后的差值\n$$\n\\Delta \\;=\\; F_{\\text{ext}}^{\\text{(B)}} - F_{\\text{ext}}^{\\text{(C)}}\n$$\n将每个 $\\Delta$ 报告为精确到小数点后四位的十进制数。\n\n输入：无输入。所有参数都是固定的并嵌入在程序中。\n\n操作表示法：每个操作要么是分配 $A\\;s$（分配大小为 $s$），要么是释放 $F\\;k$（释放标识符为 $k$）。\n\n测试套件（每个都从一个包含单个空闲块 $[0,M]$ 的全新初始状态独立执行）：\n- 测试用例 1：\n  - $M=64$\n  - 操作： $A\\;10,\\;A\\;12,\\;A\\;8,\\;F\\;2,\\;A\\;6,\\;F\\;3,\\;F\\;1,\\;A\\;5,\\;F\\;4$\n- 测试用例 2：\n  - $M=32$\n  - 操作： $A\\;8,\\;A\\;8,\\;F\\;1,\\;A\\;4,\\;F\\;2$\n- 测试用e例 3：\n  - $M=50$\n  - 操作： $A\\;5,\\;A\\;5,\\;A\\;5,\\;A\\;5,\\;A\\;5,\\;F\\;2,\\;F\\;4,\\;A\\;3,\\;A\\;2,\\;F\\;3,\\;F\\;5,\\;F\\;1$\n\n最终输出格式：您的程序应生成单行输出，其中包含三个结果，以逗号分隔的列表形式并用方括号括起来，顺序与测试用例一致：\n$$\n[\\Delta_1,\\Delta_2,\\Delta_3]\n$$\n每个 $\\Delta_i$ 必须打印为四舍五入到小数点后四位的十进制数。\n\n科学真实性和推导要求：\n- 基于上述关于首次适应分配、区间合并和外部碎片度量 $F_{\\text{ext}}$ 的核心定义来设计。\n- 确保您的实现维护一个空闲区间的有序链表表示，根据两种变体的定义对其进行更新，并在每个测试用例结束时严格根据 $T_{\\text{free}}$ 和 $L_{\\max}$ 计算 $F_{\\text{ext}}$。\n- 不要使用任何随机化；所有结果必须是确定性的和可复现的。\n\n您的程序必须是自包含的，并且不得读取任何输入。唯一的输出必须是上面指定的确切格式的单行。所有量纲均为无量纲。按规定将每个结果表示为四舍五入到小数点后四位的数值。",
            "solution": "为了解决这个问题，我们需要为每个测试用例模拟内存分配器的两种变体（B-不合并 和 C-合并），并计算它们最终外部碎片度量的差异。我们将手动追踪每个测试用例。\n\n符号约定：\n- `Alloc`：已分配块的集合，格式为 `{ID: [基址, 长度]}`。\n- `Free`：空闲块的有序列表，格式为 `([基址, 长度], ...)`。\n\n### 测试用例 1：M=64\n\n**初始状态:** `Alloc: {}`, `Free: ([0, 64])`, `NextID: 1`\n\n**操作序列追踪 (变体 B - 不合并)**\n1.  `A 10` -> `ID 1:[0,10]`. `Free: ([10, 54])`.\n2.  `A 12` -> `ID 2:[10,12]`. `Free: ([22, 42])`.\n3.  `A 8` -> `ID 3:[22,8]`. `Free: ([30, 34])`. `Alloc: {1:[0,10], 2:[10,12], 3:[22,8]}`.\n4.  `F 2` (释放 `[10,12]`). `Free: ([10,12], [30,34])`.\n5.  `A 6` -> `ID 4:[10,6]`. 剩余 `[16,6]`. `Free: ([16,6], [30,34])`. `Alloc: {..., 4:[10,6]}`.\n6.  `F 3` (释放 `[22,8]`). `Free: ([16,6], [22,8], [30,34])`.\n7.  `F 1` (释放 `[0,10]`). `Free: ([0,10], [16,6], [22,8], [30,34])`.\n8.  `A 5` -> `ID 5:[0,5]`. 剩余 `[5,5]`. `Free: ([5,5], [16,6], [22,8], [30,34])`. `Alloc: {..., 5:[0,5]}`.\n9.  `F 4` (释放 `[10,6]`). `Free: ([5,5], [10,6], [16,6], [22,8], [30,34])`.\n\n**最终状态 (B):**\n-   $T_{\\text{free}} = 5+6+6+8+34 = 59$\n-   $L_{\\max} = 34$\n-   $F_{\\text{ext}}^{\\text{(B)}} = 1 - \\frac{34}{59} = \\frac{25}{59} \\approx 0.423728$\n\n**操作序列追踪 (变体 C - 合并)**\n1.  `A 10` -> `ID 1:[0,10]`. `Free: ([10, 54])`.\n2.  `A 12` -> `ID 2:[10,12]`. `Free: ([22, 42])`.\n3.  `A 8` -> `ID 3:[22,8]`. `Free: ([30, 34])`.\n4.  `F 2` (释放 `[10,12]`). 无相邻空闲块. `Free: ([10,12], [30,34])`.\n5.  `A 6` -> `ID 4:[10,6]`. 剩余 `[16,6]`. `Free: ([16,6], [30,34])`.\n6.  `F 3` (释放 `[22,8]`). 与 `[16,6]` 和 `[30,34]` 都相邻. 合并为 `[16, 6+8+34] = [16, 48]`. `Free: ([16,48])`.\n7.  `F 1` (释放 `[0,10]`). 无相邻空闲块. `Free: ([0,10], [16,48])`.\n8.  `A 5` -> `ID 5:[0,5]`. 剩余 `[5,5]`. `Free: ([5,5], [16,48])`.\n9.  `F 4` (释放 `[10,6]`). 与 `[5,5]` 和 `[16,48]` 都相邻. 合并为 `[5, 5+6+48] = [5,59]`. `Free: ([5,59])`.\n\n**最终状态 (C):**\n-   $T_{\\text{free}} = 59$\n-   $L_{\\max} = 59$\n-   $F_{\\text{ext}}^{\\text{(C)}} = 1 - \\frac{59}{59} = 0$\n\n**$\\Delta_1 = 0.423728 - 0 = 0.423728 \\approx 0.4237$**\n\n### 测试用例 2：M=32\n\n**初始状态:** `Alloc: {}`, `Free: ([0, 32])`, `NextID: 1`\n\n**操作序列追踪 (变体 B - 不合并)**\n1.  `A 8` -> `ID 1:[0,8]`. `Free: ([8,24])`.\n2.  `A 8` -> `ID 2:[8,8]`. `Free: ([16,16])`.\n3.  `F 1` (释放 `[0,8]`). `Free: ([0,8], [16,16])`.\n4.  `A 4` -> `ID 3:[0,4]`. 剩余 `[4,4]`. `Free: ([4,4], [16,16])`.\n5.  `F 2` (释放 `[8,8]`). `Free: ([4,4], [8,8], [16,16])`.\n\n**最终状态 (B):**\n-   $T_{\\text{free}} = 4+8+16 = 28$\n-   $L_{\\max} = 16$\n-   $F_{\\text{ext}}^{\\text{(B)}} = 1 - \\frac{16}{28} = \\frac{12}{28} = \\frac{3}{7} \\approx 0.428571$\n\n**操作序列追踪 (变体 C - 合并)**\n1.  `A 8` -> `ID 1:[0,8]`. `Free: ([8,24])`.\n2.  `A 8` -> `ID 2:[8,8]`. `Free: ([16,16])`.\n3.  `F 1` (释放 `[0,8]`). `Free: ([0,8], [16,16])`.\n4.  `A 4` -> `ID 3:[0,4]`. 剩余 `[4,4]`. `Free: ([4,4], [16,16])`.\n5.  `F 2` (释放 `[8,8]`). 与 `[4,4]` 相邻. 合并为 `[4, 4+8] = [4,12]`. `Free: ([4,12], [16,16])`.\n\n**最终状态 (C):**\n-   $T_{\\text{free}} = 12+16 = 28$\n-   $L_{\\max} = 16$\n-   $F_{\\text{ext}}^{\\text{(C)}} = 1 - \\frac{16}{28} = \\frac{3}{7} \\approx 0.428571$\n\n**$\\Delta_2 = 0.428571 - 0.428571 = 0 \\approx 0.0000$**\n\n### 测试用例 3：M=50\n\n**初始状态:** `Alloc: {}`, `Free: ([0, 50])`, `NextID: 1`\n\n**操作序列追踪 (变体 B - 不合并)**\n1-5. `A 5` x 5 -> `ID 1-5` 分配 `[0,5], [5,5], [10,5], [15,5], [20,5]`. `Free: ([25,25])`.\n6.  `F 2` (释放 `[5,5]`). `Free: ([5,5], [25,25])`.\n7.  `F 4` (释放 `[15,5]`). `Free: ([5,5], [15,5], [25,25])`.\n8.  `A 3` -> `ID 6:[5,3]`. 剩余 `[8,2]`. `Free: ([8,2], [15,5], [25,25])`.\n9.  `A 2` -> `ID 7:[8,2]`. `Free: ([15,5], [25,25])`.\n10. `F 3` (释放 `[10,5]`). `Free: ([10,5], [15,5], [25,25])`.\n11. `F 5` (释放 `[20,5]`). `Free: ([10,5], [15,5], [20,5], [25,25])`.\n12. `F 1` (释放 `[0,5]`). `Free: ([0,5], [10,5], [15,5], [20,5], [25,25])`.\n最终 `Alloc: {6:[5,3], 7:[8,2]}`.\n\n**最终状态 (B):**\n-   $T_{\\text{free}} = 50 - (3+2) = 45$. (核对: $5+5+5+5+25 = 45$).\n-   $L_{\\max} = 25$.\n-   $F_{\\text{ext}}^{\\text{(B)}} = 1 - \\frac{25}{45} = \\frac{20}{45} = \\frac{4}{9} \\approx 0.444444$\n\n**操作序列追踪 (变体 C - 合并)**\n1-7. 同上. `Alloc: {1,3,5}`. `Free: ([5,5], [15,5], [25,25])`.\n8.  `A 3` -> `ID 6:[5,3]`. 剩余 `[8,2]`. `Free: ([8,2], [15,5], [25,25])`.\n9.  `A 2` -> `ID 7:[8,2]`. `Free: ([15,5], [25,25])`.\n10. `F 3` (释放 `[10,5]`). 与 `[15,5]` 相邻. 合并为 `[10,10]`. `Free: ([10,10], [25,25])`.\n11. `F 5` (释放 `[20,5]`). 与 `[25,25]` 相邻. 合并为 `[20,30]`. `Free: ([10,10], [20,30])`.\n12. `F 1` (释放 `[0,5]`). 无相邻空闲块. `Free: ([0,5], [10,10], [20,30])`.\n\n**最终状态 (C):**\n-   $T_{\\text{free}} = 50 - (3+2) = 45$. (核对: $5+10+30 = 45$).\n-   $L_{\\max} = 30$.\n-   $F_{\\text{ext}}^{\\text{(C)}} = 1 - \\frac{30}{45} = \\frac{15}{45} = \\frac{1}{3} \\approx 0.333333$\n\n**$\\Delta_3 = \\frac{4}{9} - \\frac{1}{3} = \\frac{4-3}{9} = \\frac{1}{9} \\approx 0.111111 \\approx 0.1111$**\n\n最终结果：$[\\Delta_1, \\Delta_2, \\Delta_3] = [0.4237, 0.0000, 0.1111]$",
            "answer": "[0.4237,0.0000,0.1111]"
        },
        {
            "introduction": "一个健壮的系统不仅要能正确运行，还要能诊断和修复错误。本项高级练习  将挑战您处理一个已损坏的堆转储，其中的空闲链表可能包含循环、野指针或未链接的“孤岛”。您的任务是编写一个诊断程序来识别这些不一致性，并实现一个修复算法，通过重新扫描和合并来重建一个一致且高效的空闲链表，从而加深对分配器核心不变量的理解。",
            "id": "3653468",
            "problem": "给定一个由空闲块单向链表管理的堆的形式化视图。每个块由三个字段表示：以单位计的大小、一个布尔分配标志以及一个给出列表中下一个空闲块索引的 next 指针。堆在概念上是一个由整数索引的块数组。空闲链表应包含所有且仅包含空闲块，是无环的，并遵守不变量：空闲链表中表示的块是内存中不相交的段，并且在物理顺序上相邻时可以合并。\n\n此问题的基本基础是以下定义和不变量集：单向链表是一个有向图，其中每个节点的出度最多为一；一个格式良好的空闲链表是一个从头节点开始的简单路径，它恰好覆盖所有空闲内存块一次，并通过对相邻空闲块进行合并来最小化外部碎片。任何一致的分配器都维护以下不变量：空闲块的大小总和等于分配器所记录的空闲内存总量；空闲链表是无环的，并且能到达每个空闲块，可能需要合并连续的空闲块之后。根据图论，节点出度最多为一的有限有向图可以分解为不相交的简单路径和环；正确性要求确保空闲链表是一条覆盖所有空闲内存一次且不包含环的单一路径。\n\n您的任务是：从堆转储中重建空闲链表，识别不可达的空闲块（称为孤岛），提出一个修复算法，通过将相邻的空闲块合并成连续段并按严格递增的索引顺序重新链接空闲链表来恢复所有不变量，然后从第一性原理论证其正确性。\n\n使用数组表示测试用例的堆转储：大小为 $size[i]$，分配标志为 $alloc[i]$（其中 $alloc[i]=1$ 表示已分配，$alloc[i]=0$ 表示空闲），next 指针为 $next[i]$（存储在块头中的下一个空闲块的索引，-1 表示列表结束）。空闲链表的头索引由 $head$ 给出。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 从 $head$ 开始，通过跟随 $next[i]$ 遍历存储的空闲链表，并计算可达的空闲块。如果到达有效索引范围之外的节点、标记为已分配的节点或检测到环（通过重访节点），则停止遍历。记录 $R$，即到达的唯一空闲块的数量。\n- 将那些 $alloc[i]=0$ 但不在可达集合中的块识别为孤岛。记录 $I$，即此类块的数量。\n- 通过按升序索引扫描堆来修复空闲链表，将任何连续的空闲块合并成单个空闲连续段。创建一个新的概念性空闲链表，其中每个连续段是一个节点，按严格递增的索引顺序链接。记录 $A$，即合并后的空闲连续段数量。\n- 验证一个不变量 $C$ 等于 $1$，当且仅当以下所有条件都满足：修复后的空闲链表是无环的，修复后的空闲链表覆盖了所有空闲内存（连续段节点的大小总和等于所有空闲块的大小总和），并且概念上的 next 指针按索引严格递增（这意味着无环性）。否则记录 $C=0$。\n\n使用上述基本定义设计您的算法，不要使用任何快捷公式。\n\n测试套件：\n- 案例 $1$：$n=6$，$size=[10,5,8,7,6,4]$，$alloc=[0,1,0,1,0,1]$，$head=0$，空闲块的 $next$ 指针：$next[0]=2$，$next[2]=4$，$next[4]=-1$；非空闲块的 $next$ 值可以是任意或未使用的。\n- 案例 $2$：$n=5$，$size=[8,4,3,5,7]$，$alloc=[0,1,0,0,1]$，$head=0$，$next[0]=3$，$next[3]=-1$，索引为 $2$ 的块是空闲但未被链接，即一个孤岛。\n- 案例 $3$：$n=3$，$size=[9,6,2]$，$alloc=[0,0,1]$，$head=0$，$next[0]=1$，$next[1]=0$，在空闲块之间形成了一个空闲链表环。\n- 案例 $4$：$n=7$，$size=[4,5,3,2,6,1,7]$，$alloc=[0,1,0,1,0,0,1]$，$head=2$，$next[2]=99$（一个越界指针），其他空闲块的 $next$ 为 $-1$。\n\n您的程序应生成单行输出，按顺序包含每个测试用例的四元组 $[R,I,A,C]$，其中 $R$、$I$ 和 $A$ 为整数，$C$ 为 $0$ 或 $1$，聚合成一个单一的、逗号分隔的列表的列表。例如，最终输出格式必须像 $[[r_1,i_1,a_1,c_1],[r_2,i_2,a_2,c_2],\\ldots]$，不含多余的空格或文本。",
            "solution": "下面对每个测试用例进行逐步分析，以计算所需的四元组 $[R, I, A, C]$。\n\n### 步骤1：计算可达空闲块 (R)\n我们从`head`开始遍历链表，使用一个`visited`集合来检测环并记录可达的空闲块。\n\n### 步骤2：识别孤岛 (I)\n我们扫描所有块，计算那些`alloc`为0但不在`visited`集合中的块的数量。\n\n### 步骤3：修复并计数连续段 (A)\n我们扫描所有块并合并所有物理上相邻的空闲块，然后计算得到的连续空闲段的数量。\n\n### 步骤4：验证不变量 (C)\n根据定义，修复算法通过按索引顺序扫描和链接来重建链表，这天然保证了链表是无环的、覆盖所有空闲内存并且指针按索引严格递增。因此，如果算法正确实现，$C$ 将始终为1。\n\n---\n\n### 案例 1: 完美链表\n- **堆**: $n=6, size=[10,5,8,7,6,4], alloc=[0,1,0,1,0,1], head=0, next[0]=2, next[2]=4, next[4]=-1$\n- **(R)**: 从 `head=0` 开始。\n  - 访问 `0` (`alloc[0]==0`)。`visited={0}`。下一个是 `2`。\n  - 访问 `2` (`alloc[2]==0`)。`visited={0,2}`。下一个是 `4`。\n  - 访问 `4` (`alloc[4]==0`)。`visited={0,2,4}`。下一个是 `-1` (结束)。\n  - 可达空闲块：`{0, 2, 4}`。$R=3$。\n- **(I)**: 扫描所有块。空闲块为索引`0, 2, 4`。所有空闲块都可达。$I=0$。\n- **(A)**: 修复。\n  - `i=0`: 空闲。段1开始。\n  - `i=1`: 已分配。段1结束：`{index:0, size:10}`。\n  - `i=2`: 空闲。段2开始。\n  - `i=3`: 已分配。段2结束：`{index:2, size:8}`。\n  - `i=4`: 空闲。段3开始。\n  - `i=5`: 已分配。段3结束：`{index:4, size:6}`。\n  - 修复后有3个连续段。$A=3$。\n- **(C)**: 修复后的链表是健康的。$C=1$。\n- **结果**: `[3, 0, 3, 1]`\n\n---\n\n### 案例 2: 孤岛\n- **堆**: $n=5, size=[8,4,3,5,7], alloc=[0,1,0,0,1], head=0, next[0]=3, next[3]=-1$\n- **(R)**: 从 `head=0` 开始。\n  - 访问 `0` (`alloc[0]==0`)。`visited={0}`。下一个是 `3`。\n  - 访问 `3` (`alloc[3]==0`)。`visited={0,3}`。下一个是 `-1` (结束)。\n  - 可达空闲块：`{0, 3}`。$R=2$。\n- **(I)**: 扫描所有块。空闲块为`0, 2, 3`。块`2`是空闲的但未被访问。\n  - 孤岛：`{2}`。$I=1$。\n- **(A)**: 修复。\n  - `i=0`: 空闲。段1开始。\n  - `i=1`: 已分配。段1结束：`{index:0, size:8}`。\n  - `i=2`: 空闲。段2开始。\n  - `i=3`: 空闲。合并到段2。\n  - `i=4`: 已分配。段2结束：`{index:2, size:3+5=8}`。\n  - 修复后有2个连续段。$A=2$。\n- **(C)**: $C=1$。\n- **结果**: `[2, 1, 2, 1]`\n\n---\n\n### 案例 3: 环\n- **堆**: $n=3, size=[9,6,2], alloc=[0,0,1], head=0, next[0]=1, next[1]=0$\n- **(R)**: 从 `head=0` 开始。\n  - 访问 `0` (`alloc[0]==0`)。`visited={0}`。下一个是 `1`。\n  - 访问 `1` (`alloc[1]==0`)。`visited={0,1}`。下一个是 `0`。\n  - 尝试访问`0`，但`0`已在`visited`中。检测到环，停止。\n  - 可达空闲块：`{0, 1}`。$R=2$。\n- **(I)**: 扫描所有块。空闲块为`0, 1`。所有空闲块都可达。$I=0$。\n- **(A)**: 修复。\n  - `i=0`: 空闲。段1开始。\n  - `i=1`: 空闲。合并到段1。\n  - `i=2`: 已分配。段1结束：`{index:0, size:9+6=15}`。\n  - 修复后有1个连续段。$A=1$。\n- **(C)**: $C=1$。\n- **结果**: `[2, 0, 1, 1]`\n\n---\n\n### 案例 4: 野指针\n- **堆**: $n=7, size=[4,5,3,2,6,1,7], alloc=[0,1,0,1,0,0,1], head=2, next[2]=99$\n- **(R)**: 从 `head=2` 开始。\n  - 访问 `2` (`alloc[2]==0`)。`visited={2}`。下一个是 `99`。\n  - 尝试访问`99`，但索引越界($n=7$)。停止。\n  - 可达空闲块：`{2}`。$R=1$。\n- **(I)**: 扫描所有块。空闲块为`0, 2, 4, 5`。块`0, 4, 5`是空闲的但未被访问。\n  - 孤岛：`{0, 4, 5}`。$I=3$。\n- **(A)**: 修复。\n  - `i=0`: 空闲。段1：`{index:0, size:4}`。\n  - `i=1`: 已分配。\n  - `i=2`: 空闲。段2：`{index:2, size:3}`。\n  - `i=3`: 已分配。\n  - `i=4`: 空闲。段3开始。\n  - `i=5`: 空闲。合并到段3。\n  - `i=6`: 已分配。段3结束：`{index:4, size:6+1=7}`。\n  - 修复后有3个连续段。$A=3$。\n- **(C)**: $C=1$。\n- **结果**: `[1, 3, 3, 1]`",
            "answer": "[[3,0,3,1],[2,1,2,1],[2,0,1,1],[1,3,3,1]]"
        }
    ]
}