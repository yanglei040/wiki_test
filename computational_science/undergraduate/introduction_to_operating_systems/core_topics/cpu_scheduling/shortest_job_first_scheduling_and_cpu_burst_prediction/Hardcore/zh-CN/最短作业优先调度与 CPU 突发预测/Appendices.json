{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的调度场景之前，首先理解理想条件下SJF算法的核心行为至关重要。这个练习将引导你分析一个简化的模型，其中所有任务同时到达且中央处理器（CPU）突发时间被完美预测。通过推导最长等待时间的解析表达式，你将揭示SJF算法的基本性质，并为后续更复杂的实践打下坚实的理论基础 。",
            "id": "3682864",
            "problem": "考虑 $n$ 个独立作业 $J_1, J_2, \\dots, J_n$，它们在时间 $0$ 同时到达，且每个作业都只包含一个中央处理器 (CPU) 执行期。设真实的 CPU 执行期长度为 $b_1, b_2, \\dots, b_n$，且 $b_1  b_2  \\dots  b_n$。系统使用一个非抢占式的最短作业优先 (SJF) 调度程序，且调度程序的 CPU 执行期预测是完美的，即对每个作业 $J_i$ 的预测执行期等于其真实执行期 $b_i$。假设没有上下文切换开销，也没有输入/输出阻塞；一旦一个作业开始其 CPU 执行期，它就会一直运行直到完成。\n\n仅从等待时间和非抢占式 SJF 选择规则的核心定义出发，推导在此场景下所有作业 $J_1, \\dots, J_n$ 中任一作业所经历的最大等待时间的闭式解析表达式。作业 $J_i$ 的等待时间 $W_i$ 定义为从其到达时刻到其首次在 CPU 上开始执行的瞬间所经过的时间。请用符号形式，以 $b_1, \\dots, b_n$ 表示您的最终答案，在适当之处使用 Sigma 求和表示法，并且表达式中不要包含单位。",
            "solution": "在尝试求解之前，将首先对问题的科学合理性、自洽性和清晰度进行验证。\n\n### 步骤 1：提取已知条件\n问题陈述提供了以下信息：\n- 一组 $n$ 个独立作业，$J_1, J_2, \\dots, J_n$。\n- 所有作业在时间 $0$ 同时到达。\n- 每个作业包含一个单独的 CPU 执行期。\n- 真实的 CPU 执行期长度为 $b_1, b_2, \\dots, b_n$。\n- 执行期长度是严格排序的：$b_1  b_2  \\dots  b_n$。\n- 调度算法为非抢占式最短作业优先 (SJF)。\n- 调度程序的预测是完美的，意味着作业 $J_i$ 的预测执行期为其真实执行期 $b_i$。\n- 没有上下文切换开销。\n- 没有输入/输出阻塞。\n- 作业 $J_i$ 的等待时间 $W_i$ 定义为从其到达直到开始执行所经过的时间。\n- 目标是推导所有作业中最大等待时间的闭式解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据**：该问题是操作系统领域中 CPU 调度算法研究的一个经典理论练习。最短作业优先调度、等待时间以及 CPU 执行期都是基础且完善的概念。简化的假设（同时到达、无开销）是用于隔离和分析该算法核心行为的标准做法。\n- **适定性**：该问题定义清晰。严格的不等式 $b_1  b_2  \\dots  b_n$ 消除了作业选择中的任何模糊性，因为执行期长度没有相同的情况。非抢占式特性和完美预测确保了确定且唯一的执行序列。因此，存在一个唯一的、稳定的、有意义的解。\n- **客观性**：该问题使用计算机科学标准的精确、无歧义的术语进行陈述。所有参数和定义都是客观的。\n\n该问题没有表现出验证标准中列出的任何缺陷（例如，科学上不合理、不完整、模糊不清）。这是一个结构良好、根植于既定计算机科学理论的问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将推导解答。\n\n### 解答推导过程\n目标是找到最大等待时间 $\\max\\{W_1, W_2, \\dots, W_n\\}$。我们首先分析在非抢占式最短作业优先 (SJF) 调度策略下作业的执行顺序。\n\n1.  **执行顺序**：\n    - 在时间 $t=0$ 时，所有 $n$ 个作业（$J_1, \\dots, J_n$）都在就绪队列中。\n    - SJF 调度程序选择具有最短预测 CPU 执行期的作业。由于预测是完美的，它会选择具有最小真实执行期长度 $b_i$ 的作业。\n    - 根据给定的条件 $b_1  b_2  \\dots  b_n$，具有绝对最短执行期长度的作业是 $J_1$。\n    - 因此，在时间 $t=0$ 时，作业 $J_1$ 被选择执行。\n    - 因为调度是非抢占式的，$J_1$ 会一直运行直到完成。它在时间 $0$ 开始，并在时间 $b_1$ 完成。\n    - 在时间 $t=b_1$ 时，作业 $J_1$ 完成。剩余的作业是 $J_2, J_3, \\dots, J_n$。\n    - 调度程序再次应用 SJF 规则。在剩余的作业中，$J_2$ 具有最短的执行期长度 $b_2$。\n    - 因此，接下来选择作业 $J_2$。它在时间 $b_1$ 开始并运行至完成，在时间 $b_1 + b_2$ 结束。\n    - 这个过程按顺序继续。在作业 $J_1, \\dots, J_{k-1}$ 完成后，调度程序将选择作业 $J_k$，因为它在剩余作业中具有最短的执行期长度。\n    - 由此产生的执行顺序确定为 $J_1, J_2, J_3, \\dots, J_n$。\n\n2.  **任意作业 $J_k$ 的等待时间**：\n    - 作业 $J_k$ 的等待时间，记为 $W_k$，是从其到达直到其开始执行所经过的时间。\n    - 所有作业都在时间 $0$ 到达。因此，等待时间等于作业的开始时间。\n    - 作业 $J_1$ 在时间 $0$ 开始。其等待时间为 $W_1 = 0$。\n    - 作业 $J_2$ 在 $J_1$ 完成后开始。其开始时间为 $b_1$。其等待时间为 $W_2 = b_1$。\n    - 作业 $J_3$ 在 $J_1$ 和 $J_2$ 完成后开始。其开始时间为 $b_1 + b_2$。其等待时间为 $W_3 = b_1 + b_2$。\n    - 推广开来，作业 $J_k$ 在作业 $J_1, J_2, \\dots, J_{k-1}$ 全部完成后开始。$J_k$ 的开始时间是这些先前作业的执行期之和。\n    - 作业 $J_k$ 的等待时间由以下公式给出：\n    $$W_k = \\sum_{i=1}^{k-1} b_i$$\n    此公式对 $k \\ge 2$ 成立。对于 $k=1$，该求和是针对一个空集，其值按惯例定义为 $0$，因此 $W_1 = 0$。\n\n3.  **最大等待时间**：\n    - 我们需要找到等待时间集合 $\\{W_1, W_2, \\dots, W_n\\}$ 中的最大值。\n    - 等待时间构成一个序列：\n        - $W_1 = 0$\n        - $W_2 = b_1$\n        - $W_3 = b_1 + b_2$\n        - ...\n        - $W_n = b_1 + b_2 + \\dots + b_{n-1}$\n    - CPU 执行期长度 $b_i$ 代表一个时间段，必须为正数，所以对于所有 $i \\in \\{1, \\dots, n\\}$，$b_i > 0$。\n    - 考虑连续等待时间之间的差值，对于 $k \\ge 2$：\n    $$W_k - W_{k-1} = \\left(\\sum_{i=1}^{k-1} b_i\\right) - \\left(\\sum_{i=1}^{k-2} b_i\\right) = b_{k-1}$$\n    - 由于 $b_{k-1} > 0$，因此对于所有 $k \\ge 2$，$W_k > W_{k-1}$。\n    - 这证明了等待时间序列是严格递增的：$W_1  W_2  \\dots  W_n$。\n    - 一个严格递增序列的最大值是其最后一个元素。\n    - 因此，最大等待时间是 $W_n$。\n\n4.  **最终表达式**：\n    - 最大等待时间是 $W_n$，它是在 $J_n$ 之前执行的所有作业的执行期长度之和。这些作业是 $J_1, \\dots, J_{n-1}$。\n    - 最大等待时间的最终闭式表达式为：\n    $$\\max_{k \\in \\{1,\\dots,n\\}} W_k = W_n = \\sum_{i=1}^{n-1} b_i$$",
            "answer": "$$\\boxed{\\sum_{i=1}^{n-1} b_i}$$"
        },
        {
            "introduction": "掌握了调度算法的实现后，我们可以将分析从单个任务的度量提升到整个系统的宏观性能。本练习旨在将你的调度模拟与排队论中的一个基本定律——利特尔法则（Little's Law）联系起来。通过仿真测量系统中的平均任务数（$\\overline{L}$）、平均到达率（$\\lambda$）和平均周转时间（$\\overline{W}$），并验证它们是否满足 $\\overline{L} = \\lambda \\overline{W}$ 的关系，你将巩固对调度决策与系统整体性能之间联系的理解 。",
            "id": "3682783",
            "problem": "考虑一个单处理器系统，该系统使用最短作业优先 (SJF) 调度算法来调度中央处理器 (CPU) 的执行脉冲串，其中作业长度是先验未知的，并通过指数加权移动平均 (EWMA) 进行预测。每个进程生成一系列 CPU 脉冲串，这些脉冲串与在 CPU 之外发生的输入/输出交错进行；每个脉冲串在指定时间到达，并需要指定的服务时间。假设在一个有限的时间窗口内观察一个稳定的、工作 conserving 的系统，该窗口从最早的脉冲串到达时开始，到最后一个脉冲串完成时结束。就绪队列中保存着已到达但当前未执行的脉冲串。\n\n从以下基本原则出发：\n- 流量守恒：在一个有限的观测窗口内，总到達数等于总离开数，且时间平均到达率等于时间平均离开率。\n- 时间平均定义：系统中的时间平均数量是系统中的数量对时间的积分除以观测窗口的长度，队列中的时间平均数量也类似（不包括正在服务的作业）。\n\n基于这些原则，推导在系统中的时间平均数量、到达率以及每个作业在系统中平均花费的时间之间必须成立的关系。同时，使用服务开始前的平均等待时间，为就绪队列单独推导类似的关系。不要假设任何特殊的分布，如指数分布；仅假设在有限窗口内的稳定性、工作 conserving 特性以及良定义的时间平均值。\n\n实现一个仿真程序，该程序：\n- 基于预测的 CPU 脉冲串长度，使用非抢占式 SJF 调度脉冲串。\n- 使用 EWMA 预测每个进程的下一个 CPU 脉冲串。如果 $\\tau_n$ 表示对给定进程的第 $n$ 个脉冲串的预测，而 $t_n$ 表示该第 $n$ 个脉冲串的实际长度，那么下一个预测是 $$\\tau_{n+1} = \\alpha\\, t_n + (1 - \\alpha)\\, \\tau_n,$$ 其中 $0 \\le \\alpha \\le 1$ 是一个平滑因子，$\\tau_0$ 是对该进程的初始预测值。当一个进程尚未完成任何脉冲串时，其预测脉冲串长度为 $\\tau_0$。当 CPU 空闲时，调度程序从就绪队列中选择其进程当前 $\\tau$ 值最小的脉冲串；冲突通过最早到达时间解决，其次通过一个由实现定义的确定性规则解决。\n- 对于每个具有到达时间 $a_i$ 和服务时间 $s_i$ 的脉冲串 $i$，测量其服务开始时间 $b_i$、完成时间 $c_i = b_i + s_i$、在系统中的时间 $w_i^{\\text{sys}} = c_i - a_i$ 以及在队列中的等待时间 $w_i^{\\text{q}} = b_i - a_i$。\n- 在观测窗口 $[A_{\\min}, C_{\\max}]$（其中 $A_{\\min} = \\min_i a_i$ 且 $C_{\\max} = \\max_i c_i$）上计算以下指标：\n  - 系统中的时间平均数量 $\\overline{L} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt,$ 其中 $L(t)$ 是在时间 $t$ 时正在等待或执行的脉冲串数量。\n  - 队列中的时间平均数量 $\\overline{L_q} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt,$ 其中 $L_q(t)$ 仅计算在时间 $t$ 时在就绪队列中等待的脉冲串（不包括正在执行的脉冲串）。\n  - 平均到达率 $\\lambda = \\frac{N}{C_{\\max} - A_{\\min}},$ 其中 $N$ 是脉冲串的总数。\n  - 在系统中的平均时间 $\\overline{W} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}},$ 以及在队列中的平均等待时间 $\\overline{W_q} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}}.$\n- 通过计算绝对误差来验证一致性 $\\varepsilon_{\\text{sys}} = \\left| \\overline{L} - \\lambda\\, \\overline{W} \\right| \\quad \\text{和} \\quad \\varepsilon_{\\text{q}} = \\left| \\overline{L_q} - \\lambda\\, \\overline{W_q} \\right|.$\n\n所有时间都必须以秒 ($\\text{s}$) 为单位处理。到达率 $\\lambda$ 的单位是秒的倒数 ($\\text{s}^{-1}$)。时间平均数量 $\\overline{L}$ 和 $\\overline{L_q}$ 是无量纲的。\n\n测试套件：\n- 测试用例 1（正常路径，中等负载）：\n  - 进程：$3$ 个进程，标识符分别为 $0$、$1$、$2$。\n  - 平滑因子：$\\alpha = 0.5$。\n  - 每个进程的初始预测值：$\\tau_0 = 5.0\\,\\text{s}$。\n  - 脉冲串（到达时间 $a_i$ 单位为秒，服务时间 $s_i$ 单位为秒，进程标识符）：\n    - 进程 $0$：$[ (a=0.0, s=5.0), (a=12.0, s=4.0), (a=23.0, s=6.0) ]$。\n    - 进程 $1$：$[ (a=1.0, s=3.0), (a=7.0, s=2.0), (a=15.0, s=8.0) ]$。\n    - 进程 $2$：$[ (a=2.0, s=6.0), (a=9.0, s=7.0), (a=25.0, s=3.0) ]$。\n- 测试用例 2（重度重叠，高 $\\alpha$ 值）：\n  - 进程：$3$ 个进程，标识符分别为 $0$、$1$、$2$。\n  - 平滑因子：$\\alpha = 0.9$。\n  - 每个进程的初始预测值：$\\tau_0 = 6.0\\,\\text{s}$。\n  - 脉冲串：\n    - 进程 $0$：$[ (a=0.0, s=9.0), (a=10.0, s=9.0), (a=20.0, s=9.0) ]$。\n    - 进程 $1$：$[ (a=0.1, s=2.0), (a=2.5, s=2.0), (a=4.9, s=2.0), (a=7.4, s=2.0), (a=9.8, s=2.0), (a=12.2, s=2.0) ]$。\n    - 进程 $2$：$[ (a=0.2, s=4.0), (a=4.3, s=4.5), (a=8.4, s=5.0), (a=12.5, s=5.2) ]$。\n- 测试用例 3（边界 $\\alpha=0$，退化预测）：\n  - 进程：$3$ 个进程，标识符分别为 $0$、$1$、$2$。\n  - 平滑因子：$\\alpha = 0.0$。\n  - 每个进程的初始预测值：$\\tau_0 = 4.0\\,\\text{s}$。\n  - 脉冲串：\n    - 进程 $0$：$[ (a=0.0, s=1.0), (a=2.0, s=9.0) ]$。\n    - 进程 $1$：$[ (a=0.5, s=5.0) ]$。\n    - 进程 $2$：$[ (a=1.0, s=4.0), (a=3.0, s=3.0) ]$。\n\n最终输出格式：\n您的程序应生成单行输出，该输出将所有测试用例的一致性误差聚合为一个用方括号括起来的逗号分隔列表。这六个值按测试用例排序，分别是\n$[ \\varepsilon_{\\text{sys}}^{(1)}, \\varepsilon_{\\text{q}}^{(1)}, \\varepsilon_{\\text{sys}}^{(2)}, \\varepsilon_{\\text{q}}^{(2)}, \\varepsilon_{\\text{sys}}^{(3)}, \\varepsilon_{\\text{q}}^{(3)} ]$,\n四舍五入到六位小数。例如，如果在数值精度范围内实现完美的一致性，输出可能为 $[0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000]$。",
            "solution": "该问题需要两个不同的部分：首先，理论推导时间平均系统内数量、到达率和平均在系统时间（以及它们特定于队列的类似物）之间的关系；其次，进行离散事件模拟，以在特定调度策略下通过计算验证这些关系。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **系统模型**：单处理器、工作 conserving、稳定的系统，在有限时间窗口 $[A_{\\min}, C_{\\max}]$ 内进行观察。\n*   **调度**：基于预测的脉冲串长度的非抢占式最短作业优先 (SJF)。\n*   **预测**：指数加权移动平均 (EWMA)：$\\tau_{n+1} = \\alpha\\, t_n + (1 - \\alpha)\\, \\tau_n$，其中 $0 \\le \\alpha \\le 1$。$\\tau_0$ 是初始预测值。\n*   **冲突解决**：对于 SJF，首先是最小的 $\\tau$，然后是最早到达时间，最后是由实现定义的确定性规则。\n*   **指标定义**：\n    *   观测窗口：$[A_{\\min}, C_{\\max}]$，其中 $A_{\\min} = \\min_i a_i$ 且 $C_{\\max} = \\max_i c_i$。\n    *   脉冲串 $i$ 在系统中的时间：$w_i^{\\text{sys}} = c_i - a_i$。\n    *   脉冲串 $i$ 在队列中的等待时间：$w_i^{\\text{q}} = b_i - a_i$。\n    *   系统中的时间平均数量：$\\overline{L} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt$。\n    *   队列中的时间平均数量：$\\overline{L_q} = \\frac{1}{C_{\\max} - A_{\\min}} \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt$。\n    *   平均到达率：$\\lambda = \\frac{N}{C_{\\max} - A_{\\min}}$，其中 $N$ 为总脉冲串数。\n    *   在系统中的平均时间：$\\overline{W} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}}$。\n    *   在队列中的平均等待时间：$\\overline{W_q} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}}$。\n*   **验证目标**：计算绝对误差 $\\varepsilon_{\\text{sys}} = \\left| \\overline{L} - \\lambda\\, \\overline{W} \\right|$ 和 $\\varepsilon_{\\text{q}} = \\left| \\overline{L_q} - \\lambda\\, \\overline{W_q} \\right|$。\n*   **测试用例**：提供了三个完整的测试用例，包括进程定义、脉冲串到达/服务时间、$\\alpha$ 和 $\\tau_0$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在科学上基于排队论和操作系统原理。要推导的核心关系 $\\overline{L} = \\lambda \\overline{W}$ 是利特尔法则的一种形式，这是排队论中的一个基本定理。该问题是适定的，为获得唯一的模拟结果提供了所有必要的参数和确定性规则。定义是精确和客观的。没有矛盾、科学缺陷或歧义。\n\n**步骤 3：结论与行动**\n\n该问题是有效的。将提供完整的解决方案。\n\n### 基本关系推导（利特尔法则）\n\n推导依赖于一种图形解释，通常称为“面积论证”，应用于有限观测窗口 $T = C_{\\max} - A_{\\min}$。\n\n设 $L(t)$ 为在时间 $t$ 系统中的脉冲串数量（等待中或服务中）。系统中的时间平均数量 $\\overline{L}$ 定义为：\n$$ \\overline{L} = \\frac{1}{T} \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt $$\n积分 $\\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt$ 代表 $L(t)$ 对 $t$ 的曲线下的总面积。这个面积可以概念化为在观测窗口内系统中累积的总“脉冲串-秒”。\n\n或者，我们可以通过对每个单独脉冲串的贡献求和来计算这个总累积量。对于每个脉冲串 $i$（从 $1$ 到 $N$），它在时间 $a_i$ 到达并在时间 $c_i$ 完成。它在系统中花费的总时间是 $w_i^{\\text{sys}} = c_i - a_i$。所有 $N$ 个脉冲串的这些个体逗留时间的总和，给出了系统中累积的相同的总脉冲串-秒。\n$$ \\sum_{i=1}^{N} w_i^{\\text{sys}} = \\int_{A_{\\min}}^{C_{\\max}} L(t)\\, dt $$\n这个等式成立，因为两边代表的是同一个量：系统中所有脉冲串的总时间积分存在量。\n\n现在，我们将其代入 $\\overline{L}$ 的定义中：\n$$ \\overline{L} = \\frac{1}{T} \\sum_{i=1}^{N} w_i^{\\text{sys}} $$\n我们可以通过乘以和除以 $N$（脉冲串的总数）来重写此表达式：\n$$ \\overline{L} = \\left( \\frac{N}{T} \\right) \\left( \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}} \\right) $$\n通过代入问题中对平均到达率 $\\lambda = \\frac{N}{T} = \\frac{N}{C_{\\max} - A_{\\min}}$ 和在系统中的平均时间 $\\overline{W} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{sys}}$ 的定义，我们得到期望的关系：\n$$ \\overline{L} = \\lambda \\overline{W} $$\n这个结果被称为利特尔法则，它非常通用，不依赖于到达或服务时间分布，也不依赖于调度策略，只要系统是稳定且工作 conserving 的。\n\n对于就绪队列的类似关系遵循完全相同的逻辑。设 $L_q(t)$ 为在时间 $t$ 就绪队列中的脉冲串数量（等待服务）。队列中的时间平均数量是：\n$$ \\overline{L_q} = \\frac{1}{T} \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt $$\n该积分代表在队列中等待所花费的总脉冲串-秒。这也等于所有个体等待时间 $w_i^{\\text{q}} = b_i - a_i$ 的总和，其中 $b_i$ 是脉冲串 $i$ 开始服务的时间。\n$$ \\sum_{i=1}^{N} w_i^{\\text{q}} = \\int_{A_{\\min}}^{C_{\\max}} L_q(t)\\, dt $$\n将其代入 $\\overline{L_q}$ 的定义并重新整理：\n$$ \\overline{L_q} = \\frac{1}{T} \\sum_{i=1}^{N} w_i^{\\text{q}} = \\left( \\frac{N}{T} \\right) \\left( \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}} \\right) $$\n使用 $\\lambda$ 和在队列中的平均等待时间 $\\overline{W_q} = \\frac{1}{N} \\sum_{i=1}^{N} w_i^{\\text{q}}$ 的定义，我们得到：\n$$ \\overline{L_q} = \\lambda \\overline{W_q} $$\n仿真将通过计算验证这些恒等式在浮点精度范围内成立。\n\n### 仿真设计与实现\n\n为了验证这些关系，我们构建一个离散事件仿真。仿真时钟非均匀地推进，从一个事件跳到下一个事件。系统状态仅在这些事件时间点发生变化。\n\n**核心组件：**\n1.  **事件**：主要的事件类型是 `ARRIVAL`（一个脉冲串进入就绪队列）和 `COMPLETION`（一个脉冲串完成执行并离开系统）。一个事件由其时间和相关的脉冲串来表征。\n2.  **事件队列**：一个优先队列，持有所有未来事件，按其预定时间排序。对于此问题的规模，动态排序的数组是足够的。\n3.  **全局时钟**：一个变量 `current_time`，跟踪仿真的进度。它总是更新为事件队列中下一个事件的时间。\n4.  **就绪队列**：此队列保存已到达但尚未执行的脉冲串。\n5.  **CPU 状态**：指示 CPU 是 `IDLE`（空闲）还是 `BUSY`（繁忙）。如果是 `BUSY`，它会跟踪当前正在服务的脉冲串。\n6.  **进程状态**：对于每个进程，我们必须维护其当前的 EWMA 预测值 $\\tau$。\n\n**仿真逻辑：**\n仿真通过按时间顺序处理事件来进行。\n1.  **初始化**：\n    *   创建所有指定的脉冲串。为每个脉冲串创建 `ARRIVAL` 事件并放入事件队列。\n    *   事件队列按时间排序。\n    *   仿真 `current_time` 初始化为第一个事件的时间，即 $A_{\\min}$。\n    *   所有进程的 EWMA 预测值 ($\\tau$) 初始化为 $\\tau_0$。\n    *   度量累加器（用于 $L(t)$ 和 $L_q(t)$ 下的总面积，以及 $w_i^{\\text{sys}}$ 和 $w_i^{\\text{q}}$ 的总和）设置为 $0$。\n\n2.  **主循环**：循环继续直到事件队列为空。在每次迭代中：\n    *   从事件队列中移除下一个事件。\n    *   计算新 `current_time`（来自事件）和 `last_event_time` 之间的时间差 $\\Delta t$。\n    *   更新面积累加器：`area_L += num_in_system * Δt`，`area_Lq += num_in_queue * Δt`。值 `num_in_system` 和 `num_in_queue` 是在区间 $(\\text{last\\_event\\_time}, \\text{current\\_time}]$ 内保持不变的。\n    *   更新 `current_time` 和 `last_event_time`。\n    *   处理事件：\n        *   如果为 `ARRIVAL`：将脉冲串添加到就绪队列。\n        *   如果为 `COMPLETION`：将脉冲串标记为已完成。计算其 $w_i^{\\text{sys}}$ 和 $w_i^{\\text{q}}$ 并加到累积总和中。更新其进程的 EWMA 预测值 $\\tau$。将 CPU 设置为 `IDLE`。\n    *   处理事件后，如果 CPU 为 `IDLE` 且就绪队列非空，则调用调度程序。\n\n3.  **调度程序**：\n    *   调度程序在就绪队列中搜索具有最小预测服务时间 $\\tau$ 的脉冲串。\n    *   冲突通过选择具有最早到达时间的脉冲串来解决。\n    *   任何进一步的冲突都通过确定性规则来解决（例如，按最低进程 ID，然后按脉冲串索引）。\n    *   从就绪队列中移除选定的脉冲串，并开始其服务。将其开始时间 $b_i$ 记录为 `current_time`。\n    *   为该脉冲串在 `current_time + s_i` 创建一个新的 `COMPLETION` 事件，并将其插入事件队列，然后重新排序。将 CPU 设置为 `BUSY`。\n\n4.  **最终化**：\n    *   当仿真结束时（事件队列为空），最终时间为 $C_{\\max}$。总观测周期为 $T = C_{\\max} - A_{\\min}$。\n    *   从累积的总数中计算最终的平均指标（$\\overline{L}$、$\\overline{L_q}$、$\\lambda$、$\\overline{W}$、$\\overline{W_q}$）。\n    *   一致性误差 $\\varepsilon_{\\text{sys}}$ 和 $\\varepsilon_{\\text{q}}$ 被计算为利特尔法则所规定的绝对差值。",
            "answer": "[0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000]"
        }
    ]
}