{
    "hands_on_practices": [
        {
            "introduction": "“先到先服务”（FCFS）和“最短作业优先”（SJF）是两种基础的非抢占式调度算法。虽然FCFS实现简单，但SJF在最小化平均等待时间方面具有理论上的最优性。本练习 () 旨在通过一个具体的工作负载，让你亲手计算并比较这两种策略下的“减速率”这一性能指标，从而直观地感受SJF的性能优势及其对短作业的友好性。",
            "id": "3630106",
            "problem": "一个单处理器中央处理单元 (CPU) 执行一个由六个任意到达的独立作业组成的混合工作负载。调度和上下文切换的开销可忽略不计（假设为零）。就绪队列通过先来先服务 (FCFS) 或非抢占式最短作业优先 (SJF) 进行管理。对于 FCFS，同时到达的作业之间的平局通过增加作业索引来打破。对于 SJF，当 CPU 变为空闲时，调度器会选择可用作业中服务时间最短的那个；平局首先按最早到达时间打破，然后按增加的作业索引打破。如果就绪队列为空，CPU 将保持空闲直到下一个作业到达。所有时间都以毫秒为单位。对于每个作业 $J_i$，设到达时间为 $a_i$，服务时间（CPU 执行期）为 $s_i$，开始时间为 $b_i$，完成时间为 $f_i$，周转时间为 $c_i = f_i - a_i$，减速率为 $S_i = \\frac{c_i}{s_i}$。\n\n工作负载如下：\n- 作业 $J_1$：$a_1 = 0$, $s_1 = 8$。\n- 作业 $J_2$：$a_2 = 0$, $s_2 = 3$。\n- 作业 $J_3$：$a_3 = 0$, $s_3 = 1$。\n- 作业 $J_4$：$a_4 = 2$, $s_4 = 9$。\n- 作业 $J_5$：$a_5 = 3$, $s_5 = 2$。\n- 作业 $J_6$：$a_6 = 6$, $s_6 = 5$。\n\n仅使用上述定义和调度规则，确定 FCFS 下的算术平均减速率（表示为 $\\overline{S}_{\\mathrm{FCFS}}$）和 SJF 下的算术平均减速率（表示为 $\\overline{S}_{\\mathrm{SJF}}$）。然后计算比率\n$$R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}.$$\n仅报告 $R$ 的纯数值，四舍五入到四位有效数字。",
            "solution": "问题陈述经审阅后被认定为有效。这是一个来自操作系统领域，特别是 CPU 调度方向的适定问题。它为六个作业提供了一套完整的数据，定义了两种调度算法（先来先服务和非抢占式最短作业优先）并附有明确的平局打破规则，同时指定了所有必要的性能指标。不存在科学上的不一致、矛盾或模糊之处。因此，我们可以着手进行解答。\n\n该问题要求计算两种不同调度策略下的算术平均减速率及其比率。给出的定义如下：\n- 到达时间：$a_i$\n- 服务时间：$s_i$\n- 完成时间：$f_i$\n- 周转时间：$c_i = f_i - a_i$\n- 减速率：$S_i = \\frac{c_i}{s_i}$\n- 平均减速率：$\\overline{S} = \\frac{1}{N} \\sum_{i=1}^{N} S_i$，其中 $N=6$。\n\n工作负载包含 6 个作业，从 $J_1$ 到 $J_6$：\n- $J_1: a_1=0, s_1=8$\n- $J_2: a_2=0, s_2=3$\n- $J_3: a_3=0, s_3=1$\n- $J_4: a_4=2, s_4=9$\n- $J_5: a_5=3, s_5=2$\n- $J_6: a_6=6, s_6=5$\n\n**第一部分：先来先服务 (FCFS) 调度下的分析**\n\n在 FCFS 策略下，作业按其到达顺序进行处理。对于同时到达的作业，通过增加作业索引来打破平局。\n- 在时间 $t=0$ 时，作业 $J_1$、$J_2$ 和 $J_3$ 到达。就绪队列按作业索引排序为 ($J_1, J_2, J_3$)。\n- CPU 在 $t=0$ 时开始处理 $J_1$。它运行 $s_1 = 8$ 个时间单位。\n- $J_1$ 的完成时间为 $f_1 = 0 + 8 = 8$。\n- 在 $t=8$ 时，CPU 变为空闲。此时所有其他作业均已到达，就绪队列包含它们。FCFS 顺序（基于原始到达时间和作业索引）为 ($J_2, J_3, J_4, J_5, J_6$)。\n- CPU 在 $t=8$ 时开始处理 $J_2$。它运行 $s_2 = 3$ 个时间单位。\n- $J_2$ 的完成时间为 $f_2 = 8 + 3 = 11$。\n- CPU 在 $t=11$ 时开始处理 $J_3$。它运行 $s_3 = 1$ 个时间单位。\n- $J_3$ 的完成时间为 $f_3 = 11 + 1 = 12$。\n- CPU 在 $t=12$ 时开始处理 $J_4$。它运行 $s_4 = 9$ 个时间单位。\n- $J_4$ 的完成时间为 $f_4 = 12 + 9 = 21$。\n- CPU 在 $t=21$ 时开始处理 $J_5$。它运行 $s_5 = 2$ 个时间单位。\n- $J_5$ 的完成时间为 $f_5 = 21 + 2 = 23$。\n- CPU 在 $t=23$ 时开始处理 $J_6$。它运行 $s_6 = 5$ 个时间单位。\n- $J_6$ 的完成时间为 $f_6 = 23 + 5 = 28$。\n\n现在，我们为每个作业计算周转时间 $c_i$ 和减速率 $S_i$。\n- $J_1$: $c_1 = f_1 - a_1 = 8 - 0 = 8$。$S_1 = c_1/s_1 = 8/8 = 1$。\n- $J_2$: $c_2 = f_2 - a_2 = 11 - 0 = 11$。$S_2 = c_2/s_2 = 11/3$。\n- $J_3$: $c_3 = f_3 - a_3 = 12 - 0 = 12$。$S_3 = c_3/s_3 = 12/1 = 12$。\n- $J_4$: $c_4 = f_4 - a_4 = 21 - 2 = 19$。$S_4 = c_4/s_4 = 19/9$。\n- $J_5$: $c_5 = f_5 - a_5 = 23 - 3 = 20$。$S_5 = c_5/s_5 = 20/2 = 10$。\n- $J_6$: $c_6 = f_6 - a_6 = 28 - 6 = 22$。$S_6 = c_6/s_6 = 22/5$。\n\nFCFS 的算术平均减速率为：\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(1 + \\frac{11}{3} + 12 + \\frac{19}{9} + 10 + \\frac{22}{5}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(23 + \\frac{11}{3} + \\frac{19}{9} + \\frac{22}{5}\\right) $$\n为了对分数求和，我们找到公分母 $45$：\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{23 \\cdot 45}{45} + \\frac{11 \\cdot 15}{45} + \\frac{19 \\cdot 5}{45} + \\frac{22 \\cdot 9}{45}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{1035 + 165 + 95 + 198}{45}\\right) = \\frac{1}{6} \\left(\\frac{1493}{45}\\right) = \\frac{1493}{270} $$\n\n**第二部分：非抢占式最短作业优先 (SJF) 调度下的分析**\n\n在非抢占式 SJF 策略下，当 CPU 变为空闲时，它会选择可用作业中服务时间最短的那个。平局首先按最早到达时间打破，然后按增加的作业索引打破。\n\n- 在 $t=0$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$、$J_2(s_2=3, a_2=0)$ 和 $J_3(s_3=1, a_3=0)$。根据最短服务时间，选择 $J_3$。\n- $J_3$ 在 $t=0$ 时开始，运行 $s_3=1$。完成时间 $f_3 = 1$。\n- 在 $t=1$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$ 和 $J_2(s_2=3, a_2=0)$。最短的是 $J_2$。\n- $J_2$ 在 $t=1$ 时开始，运行 $s_2=3$。完成时间 $f_2 = 1+3=4$。在其执行期间，$J_4(a_4=2, s_4=9)$ 和 $J_5(a_5=3, s_5=2)$ 到达。\n- 在 $t=4$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$、$J_4(s_4=9, a_4=2)$ 和 $J_5(s_5=2, a_5=3)$。最短的是 $J_5$。\n- $J_5$ 在 $t=4$ 时开始，运行 $s_5=2$。完成时间 $f_5 = 4+2=6$。在其执行期间，$J_6(a_6=6, s_6=5)$ 在其完成的时刻到达。\n- 在 $t=6$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$、$J_4(s_4=9, a_4=2)$ 和 $J_6(s_6=5, a_6=6)$。最短的是 $J_6$。\n- $J_6$ 在 $t=6$ 时开始，运行 $s_6=5$。完成时间 $f_6 = 6+5=11$。\n- 在 $t=11$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$ 和 $J_4(s_4=9, a_4=2)$。最短的是 $J_1$。\n- $J_1$ 在 $t=11$ 时开始，运行 $s_1=8$。完成时间 $f_1 = 11+8=19$。\n- 在 $t=19$ 时，CPU 空闲。剩下的唯一作业是 $J_4$。\n- $J_4$ 在 $t=19$ 时开始，运行 $s_4=9$。完成时间 $f_4 = 19+9=28$。\n\n现在，我们计算 SJF 策略下每个作业的周转时间 $c_i$ 和减速率 $S_i$。\n- $J_1$: $c_1 = f_1 - a_1 = 19 - 0 = 19$。$S_1 = c_1/s_1 = 19/8$。\n- $J_2$: $c_2 = f_2 - a_2 = 4 - 0 = 4$。$S_2 = c_2/s_2 = 4/3$。\n- $J_3$: $c_3 = f_3 - a_3 = 1 - 0 = 1$。$S_3 = c_3/s_3 = 1/1 = 1$。\n- $J_4$: $c_4 = f_4 - a_4 = 28 - 2 = 26$。$S_4 = c_4/s_4 = 26/9$。\n- $J_5$: $c_5 = f_5 - a_5 = 6 - 3 = 3$。$S_5 = c_5/s_5 = 3/2$。\n- $J_6$: $c_6 = f_6 - a_6 = 11 - 6 = 5$。$S_6 = c_6/s_6 = 5/5 = 1$。\n\nSJF 的算术平均减速率为：\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(\\frac{19}{8} + \\frac{4}{3} + 1 + \\frac{26}{9} + \\frac{3}{2} + 1\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(2 + \\frac{19}{8} + \\frac{4}{3} + \\frac{26}{9} + \\frac{3}{2}\\right) $$\n为了对分数求和，我们找到公分母 $72$：\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{2 \\cdot 72}{72} + \\frac{19 \\cdot 9}{72} + \\frac{4 \\cdot 24}{72} + \\frac{26 \\cdot 8}{72} + \\frac{3 \\cdot 36}{72}\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{144 + 171 + 96 + 208 + 108}{72}\\right) = \\frac{1}{6} \\left(\\frac{727}{72}\\right) = \\frac{727}{432} $$\n\n**第三部分：比率 R 的计算**\n\n最后一步是计算比率 $R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}$。\n$$ R = \\frac{1493/270}{727/432} = \\frac{1493}{270} \\times \\frac{432}{727} $$\n我们可以简化分数 $\\frac{432}{270}$：\n$$ \\frac{432}{270} = \\frac{432 \\div 54}{270 \\div 54} = \\frac{8}{5} $$\n所以比率变为：\n$$ R = \\frac{1493}{727} \\times \\frac{8}{5} = \\frac{11944}{3635} $$\n现在，我们计算数值并四舍五入到四位有效数字：\n$$ R \\approx 3.285832187... $$\n四舍五入到四位有效数字得到 $3.286$。",
            "answer": "$$\\boxed{3.286}$$"
        },
        {
            "introduction": "与非抢占式调度不同，抢占式调度（如“时间片轮转”RR）通过允许更高优先级的进程中断当前运行的进程来提高系统的响应性。然而，这种灵活性并非没有代价——每次抢占都会引入上下文切换的开销。本练习 () 建立了一个理想化模型，用于分析时间片大小 $q$ 与上下文切换开销 $d$ 之间的关系，并量化其对系统总吞吐量的影响，帮助你理解抢占式系统中的一个核心设计权衡。",
            "id": "3630101",
            "problem": "考虑一个单核中央处理器 (CPU) 在轮询 (RR) 调度下执行一个由大量相同的、纯CPU密集型作业组成的作业流。每个作业需要总共 $C$ 个单位的CPU服务才能完成，其中 $C \\gg q$，$q$ 是RR调度的时间片（quantum）。在每次抢占和分派时，调度程序会产生平均为 $d$ 个单位CPU时间的上下文切换开销，在此期间不执行任何有用的作业计算。假设总是至少有2个就绪作业，因此在每个时间片到期时都会发生上下文切换，CPU从不空闲，并且从长期平均来看，作业开始和完成时的边界效应可以忽略不计。\n\n令 $X(q,d)$ 表示长期吞吐量，定义为单位时间内完成作业数的极限；令 $X_{\\text{ideal}}$ 表示在同一CPU上没有上下文切换开销和抢占开销时的理想吞吐量。将乘法吞吐量下降因子定义为 $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$。\n\n仅从吞吐量的定义以及在RR调度和分派下对有效工作与开销的时间核算出发，推导出 $D(q,d)$，然后在 $q=d$ 的情况下计算其值。当 $q=d$ 时，将 $D(q,d)$ 的最终答案表示为一个单一的精确值。无需四舍五入，最终答案中不应包含单位。将最终值表示为一个简化的精确分数。",
            "solution": "首先验证问题陈述的科学合理性、自洽性和清晰度。\n\n**步骤1：提取已知条件**\n- 调度算法：轮询 (RR)。\n- CPU：单核。\n- 作业特性：相同的、纯CPU密集型。\n- 每个作业所需的总CPU服务时间：$C$。\n- 时间片 (quantum)：$q$。\n- 服务时间与时间片的关系：$C \\gg q$。\n- 每次抢占的上下文切换开销：$d$。\n- 系统状态：总是至少有2个就绪作业，确保CPU从不空闲，且在每个时间片结束时都发生上下文切换。\n- 简化假设：从长期平均来看，作业开始和完成时的边界效应可以忽略不计。\n- 长期吞吐量的定义：$X(q,d)$ 是单位时间内完成作业数的极限。\n- 理想吞吐量的定义：$X_{\\text{ideal}}$ 是在同一CPU上当 $d=0$ （无上下文切换开销）时的吞吐量。\n- 吞吐量下降因子的定义：$D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$。\n- 任务：推导 $D(q,d)$ 并在 $q=d$ 的情况下计算其值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于操作系统CPU调度的基本原理。它提出了一个用于分析轮询算法性能的标准的简化模型。所使用的术语（$C$，$q$，$d$，吞吐量）在计算机科学中都有明确的定义。所提供的假设（例如，$C \\gg q$，总有就绪作业）对于为稳态行为创建一个易于处理的分析模型是必要的，它消除了瞬态和空闲时间带来的复杂性。该问题提法明确、客观且自洽，没有内部矛盾或信息缺失。这是一个有效的可供分析的问题。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整的解决方案。\n\n**解答推导**\n\n目标是求出吞吐量下降因子 $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$。我们首先推导理想吞吐量 $X_{\\text{ideal}}$ 和实际吞吐量 $X(q,d)$ 的表达式。吞吐量定义为单位时间内完成的作业数量。\n\n**1. 理想吞吐量 ($X_{\\text{ideal}}$)**\n\n在理想情况下，没有上下文切换的开销，因此 $d=0$。CPU将其100%的时间用于为作业执行有用的计算。每个作业需要总共 $C$ 个单位的CPU服务时间。因此，完成一个作业所需的时间就是 $C$。\n\n理想吞吐量 $X_{\\text{ideal}}$ 是完成一个作业所需时间的倒数：\n$$X_{\\text{ideal}} = \\frac{1 \\text{ 作业}}{C \\text{ 时间单位}} = \\frac{1}{C}$$\n\n**2. 实际吞吐量 ($X(q,d)$)**\n\n在带有上下文切换开销的轮询调度下，CPU的时间被划分为有效工作和开销。问题陈述说明了在每个时间片之后都会发生一次上下文切换。\n\n一个操作周期包括：\n- 一个有效计算的时间片，持续时间为 $q$。\n- 一次上下文切换，持续时间为 $d$。\n\n这样一个周期的总持续时间是 $T_{\\text{cycle}} = q + d$。\n\n在这个总时间为 $q+d$ 的周期内，只有持续时间为 $q$ 的部分被用于执行有效工作。CPU用于有效计算的时间占总时间的比例即为其效率 $\\eta$：\n$$\\eta = \\frac{\\text{有效时间}}{\\text{总时间}} = \\frac{q}{q+d}$$\n\n要完成单个作业，必须提供总共 $C$ 个单位的有效CPU服务。由于CPU仅在时间中有 $\\eta$ 的比例可用于有效工作，因此提供 $C$ 个单位服务所需的总（时钟）时间为：\n$$T_{\\text{job}} = \\frac{C}{\\eta} = \\frac{C}{\\frac{q}{q+d}} = C \\frac{q+d}{q}$$\n\n实际的长期吞吐量 $X(q,d)$ 是每个作业所需总时间的倒数：\n$$X(q,d) = \\frac{1}{T_{\\text{job}}} = \\frac{1}{C \\frac{q+d}{q}} = \\frac{q}{C(q+d)}$$\n\n**3. 吞吐量下降因子 ($D(q,d)$)**\n\n现在我们可以根据其定义计算下降因子：\n$$D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$$\n代入 $X(q,d)$ 和 $X_{\\text{ideal}}$ 的表达式：\n$$D(q,d) = \\frac{\\frac{q}{C(q+d)}}{\\frac{1}{C}}$$\n$$D(q,d) = \\frac{q}{C(q+d)} \\cdot \\frac{C}{1} = \\frac{q}{q+d}$$\n这个结果是直观的：吞吐量下降的因子等于CPU用于执行有效工作的时间所占的比例。\n\n**4. $q=d$ 时的求值**\n\n问题要求计算当时间片 $q$ 等于上下文切换开销 $d$ 时 $D(q,d)$ 的值。我们将 $d=q$ 代入 $D(q,d)$ 的表达式中：\n$$D(q,q) = \\frac{q}{q+q} = \\frac{q}{2q}$$\n由于 $q$ 是一个时间片，它必须是一个正的持续时间（$q > 0$）。因此我们可以约掉分子和分母中的 $q$：\n$$D(q,q) = \\frac{1}{2}$$\n\n因此，当上下文切换开销等于时间片持续时间时，CPU将其一半的时间用于有效工作，一半用于开销，导致吞吐量恰好是理想吞吐量的一半。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "基于优先级的调度策略功能强大，但面临着一个经典问题：低优先级任务可能永远得不到执行，即“饥饿”现象。“老化”是一种常用的解决方案，通过动态提升等待中任务的优先级来确保公平。本练习 () 将让你扮演系统设计者的角色，通过计算来寻找一个最佳的“老化速率” $\\alpha$。你需要在两个相互制约的目标之间取得平衡：既要有效防止任务饥饿，又要避免优先级过快趋同而失去调度意义，这体现了操作系统设计中的现实挑战。",
            "id": "3630147",
            "problem": "一个单处理器操作系统对中央处理器（CPU）采用基于优先级的抢占式调度。每个就绪（非运行）任务都有一个动态优先级，该优先级从其基础优先级开始，并通过老化在每个调度器时钟周期（tick）增加一个固定的增量。具体来说，在每个调度器时钟周期，就绪队列中的每个任务的动态优先级都会增加 $\\alpha$（单位：优先级点数/时钟周期），上限为最大优先级 $P_{\\max}$。调度器总是分派具有最高动态优先级的就绪任务；优先级相同时按先进先出（FIFO）原则处理。假设抢占和分派决策只在时钟周期边界发生。老化仅适用于等待中的任务；正在执行的运行中任务不会老化。\n\n为防止在最坏负载情况下的饥饿现象，系统设计者规定，任何基础优先级为 $p_{L}$ 的任务必须在最多 $W_{\\max}$ 个时钟周期内获得CPU时间，即使基础优先级为 $p_{H}$ 的任务流持续到达。在此要求下，只需确保低优先级任务的动态优先级在等待 $W_{\\max}$ 个时钟周期内能达到至少 $p_{H}$ 即可。\n\n为保持调度器稳定性，设计者还规定，优先级不能过快地趋同。具体而言，他们要求一个从低基础优先级 $p_{\\min}$ 开始的任务，其等待时间不能少于 $T_{\\text{flat}}$ 个时钟周期就达到最大优先级 $P_{\\max}$。此约束避免了优先级过快地同质化，从而导致调度器失去任务之间有意义的区分度。\n\n给定以下参数：\n- 最大优先级 $P_{\\max} = 100$，\n- 高基础优先级 $p_{H} = 80$，\n- 用于饥饿约束的低基础优先级 $p_{L} = 25$，\n- 饥饿界限 $W_{\\max} = 550$ 个时钟周期，\n- 用于趋同约束的低基础优先级 $p_{\\min} = 10$，\n- 最小趋同时间 $T_{\\text{flat}} = 450$ 个时钟周期，\n\n请根据优先级老化和调度的基本原理，推导老化速率 $\\alpha$ 的允许范围，该范围需同时满足防止饥饿和避免优先级过快趋同的要求。将最终答案表示为代表 $\\alpha$ 下界和上界的两个数字（单位：优先级点数/时钟周期）。无需四舍五入；请提供精确值。最终答案必须是一个计算结果。",
            "solution": "问题要求基于两个不同的约束条件推导优先级老化速率 $\\alpha$ 的允许范围：一个是为了防止任务饥饿，另一个是为了防止优先级体系的快速趋同。我们将分别分析每个约束条件，以确定 $\\alpha$ 的下界和上界。\n\n基本原理是，一个基础优先级为 $p_{base}$ 的就绪任务，其动态优先级 $p_{dyn}(t)$ 会随着它在就绪队列中等待的时间 $t$ 线性增加。老化速率 $\\alpha$ 是比例常数。这个关系可以表示为：\n$$p_{dyn}(t) = p_{base} + \\alpha t$$\n这个增长的上限是最大优先级 $P_{\\max}$。在我们的分析中，我们首先考虑无上限的线性增长，以找出达到特定优先级阈值所需的时间，然后确保该逻辑与上限设置一致。\n\n第一个约束旨在防止饥饿。它规定，任何基础优先级为 $p_L$ 的任务必须在最大等待时间 $W_{\\max}$ 个时钟周期内获得CPU时间。问题指出，满足此要求的一个充分条件是，确保该任务的动态优先级在 $W_{\\max}$ 的时间窗口内至少达到高基础优先级水平 $p_H$。这能确保低优先级任务最终将具有比任何新到达的高优先级任务更高的优先级，从而被调度。\n\n让我们将这个条件形式化。低优先级任务等待时间 $t$ 后的动态优先级是 $p_L + \\alpha t$。为了保证它能在 $W_{\\max}$ 个时钟周期内被调度，其在时间 $t = W_{\\max}$ 时的优先级必须至少为 $p_H$。这给了我们以下不等式：\n$$p_L + \\alpha W_{\\max} \\ge p_H$$\n对于防止饥饿的最小可接受 $\\alpha$ 值，此不等式必须成立。我们可以解这个不等式求出 $\\alpha$：\n$$\\alpha W_{\\max} \\ge p_H - p_L$$\n$$\\alpha \\ge \\frac{p_H - p_L}{W_{\\max}}$$\n这个不等式确定了老化速率的下界 $\\alpha_{min}$。代入给定的参数值：\n- 用于比较的高基础优先级, $p_H = 80$。\n- 用于饥饿约束的低基础优先级, $p_L = 25$。\n- 最大允许等待时间, $W_{\\max} = 550$ 个时钟周期。\n\n我们计算 $\\alpha$ 的最小值：\n$$\\alpha_{min} = \\frac{80 - 25}{550} = \\frac{55}{550} = \\frac{1}{10}$$\n因此，为防止饥饿，老化速率 $\\alpha$ 必须至少为 $\\frac{1}{10}$ 优先级点数/时钟周期。\n\n第二个约束旨在通过防止优先级过快趋同来保持优先级系统中有意义的区分度。它要求一个从极低基础优先级 $p_{min}$ 开始的任务，不能在少于 $T_{flat}$ 个时钟周期内达到系统的最大优先级 $P_{max}$。\n\n设 $T_{climb}$ 为基础优先级为 $p_{min}$ 的任务达到 $P_{max}$ 所需的时间。我们可以通过将其动态优先级设为等于 $P_{max}$ 来求得这个时间：\n$$p_{min} + \\alpha T_{climb} = P_{max}$$\n解出 $T_{climb}$：\n$$T_{climb} = \\frac{P_{max} - p_{min}}{\\alpha}$$\n约束规定，这个时间必须大于或等于 $T_{flat}$：\n$$T_{climb} \\ge T_{flat}$$\n代入我们关于 $T_{climb}$ 的表达式：\n$$\\frac{P_{max} - p_{min}}{\\alpha} \\ge T_{flat}$$\n这个不等式将确定 $\\alpha$ 的上界。由于 $\\alpha$ 是一个增长率，它本质上是正数（$\\alpha > 0$）。我们可以安全地重排不等式来解出 $\\alpha$：\n$$P_{max} - p_{min} \\ge \\alpha T_{flat}$$\n$$\\alpha \\le \\frac{P_{max} - p_{min}}{T_{flat}}$$\n这个不等式确定了老化速率的上界 $\\alpha_{max}$。代入给定的参数值：\n- 最大优先级, $P_{max} = 100$。\n- 用于趋同约束的低基础优先级, $p_{min} = 10$。\n- 最小优先级趋同时间, $T_{flat} = 450$ 个时钟周期。\n\n我们计算 $\\alpha$ 的最大值：\n$$\\alpha_{max} = \\frac{100 - 10}{450} = \\frac{90}{450} = \\frac{9}{45} = \\frac{1}{5}$$\n因此，为避免优先级快速趋同，老化速率 $\\alpha$ 不得超过 $\\frac{1}{5}$ 优先级点数/时钟周期。\n\n结合这两个约束，我们得到 $\\alpha$ 的允许范围：\n$$\\alpha_{min} \\le \\alpha \\le \\alpha_{max}$$\n$$\\frac{1}{10} \\le \\alpha \\le \\frac{1}{5}$$\n$\\alpha$ 的下界是 $\\frac{1}{10}$，上界是 $\\frac{1}{5}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{10} & \\frac{1}{5} \\end{pmatrix}}$$"
        }
    ]
}