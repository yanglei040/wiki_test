{
    "hands_on_practices": [
        {
            "introduction": "在我们深入探讨时间量子选择的复杂权衡之前，首先必须理解其对系统基本容量的影响。这个练习将引导你推导出一个核心关系式，它揭示了在一个有固定CPU预算的周期内，系统能够支持的最大任务数量是如何由时间量子 $q$ 和每次上下文切换的开销 $c$ 共同决定的。通过这个实践，你将学会如何从第一性原理出发，量化调度策略对系统吞吐量潜力的基本限制 。",
            "id": "3678475",
            "problem": "一个系统使用节流机制来为中央处理器（CPU）强制执行每周期执行预算。该机制以持续时间为 $T$ 的固定长度周期运行，在每个周期内，用户任务消耗的总CPU时间加上调度器开销不得超过预算 $B$，其中 $0  B \\leq T$。调度器是轮询（RR）调度器，它为每个就绪任务分配一个固定的时间量子 $q$。每个长度为 $q$ 的调度时间片都伴随着一个固定的开销成本 $c$（包括上下文切换和记账），并且这个成本 $c$ 也从同一个预算 $B$ 中扣除。\n\n假设有 $n$ 个相同的CPU密集型任务始终处于就绪状态，公平性被定义为在每个周期内为每个任务恰好分配一个长度为 $q$ 的时间片。RR调度器在周期内循环地为任务提供服务，使得 $n$ 个任务中的每一个在每个周期内都能获得一次时间片，并且每次调度时间片都会产生 $c$ 的开销。\n\n从基本原理出发——即固定时间量子的轮询调度定义、包括开销在内的总CPU使用量不得超过 $B$ 的预算规则，以及每个时间片伴有恒定开销的假设——推导出一个在不违反预算的情况下每周期可调度的最大整数任务数 $n$ 的闭式表达式。请用 $B$、$q$ 和 $c$ 表示您的最终答案为一个解析表达式。无需进行数值舍入。",
            "solution": "问题要求在给定CPU预算 $B$、时间量子 $q$ 和每次时间片的开销 $c$ 的情况下，推导出一个周期内可调度的最大整数任务数 $n$ 的闭式表达式。\n\n推导过程从问题描述中提供的基本约束出发。\n\n1.  **每周期的总CPU消耗**：一个周期内消耗的总CPU时间是执行用户任务所用时间与调度器开销所用时间之和。\n\n2.  **用户任务的CPU时间**：根据问题对公平性的定义，每个周期内 $n$ 个任务中的每一个都恰好获得一个持续时间为 $q$ 的时间片。因此，在一个周期内分配给用户任务的总CPU时间是任务数量乘以每个任务的时间量子持续时间。\n    $$\n    T_{\\text{tasks}} = n \\cdot q\n    $$\n\n3.  **调度器开销的CPU时间**：每次调度时间片，都会产生一个固定的开销成本 $c$。由于有 $n$ 个任务，每个任务被调度一次，因此每个周期总共有 $n$ 次调度事件。总开销成本是调度事件的数量乘以每次事件的成本。\n    $$\n    T_{\\text{overhead}} = n \\cdot c\n    $$\n\n4.  **预算约束**：问题指出，用户任务消耗的总CPU时间加上调度器开销不得超过预算 $B$。这施加了以下不等式：\n    $$\n    T_{\\text{tasks}} + T_{\\text{overhead}} \\leq B\n    $$\n    代入 $T_{\\text{tasks}}$ 和 $T_{\\text{overhead}}$ 的表达式，我们得到：\n    $$\n    n \\cdot q + n \\cdot c \\leq B\n    $$\n\n5.  **求解 n**：我们可以从不等式的左侧提取公因数 $n$：\n    $$\n    n(q + c) \\leq B\n    $$\n    项 $(q+c)$ 代表了调度单个任务一个时间片对预算的总成本。因为 $q$ 是一个时间量子，所以它必须是正的（$q  0$），而 $c$ 是一个开销成本，所以它必须是非负的（$c \\geq 0$）。因此，和 $(q+c)$ 是严格为正的。我们可以用 $(q+c)$ 来除这个不等式，而不用改变不等号的方向：\n    $$\n    n \\leq \\frac{B}{q+c}\n    $$\n    这个不等式定义了任务数量 $n$ 的上界。\n\n6.  **整数约束**：问题要求的是*最大整数任务数*。由于 $n$ 必须是一个整数，其最大值是小于或等于表达式 $\\frac{B}{q+c}$ 的最大整数。根据定义，这就是该表达式的下取整。下取整函数，表示为 $\\lfloor x \\rfloor$，给出小于或等于 $x$ 的最大整数。\n\n因此，最大整数任务数 $n$ 由下式给出：\n$$\nn = \\left\\lfloor \\frac{B}{q+c} \\right\\rfloor\n$$\n这是在不违反预算的情况下，每周期可调度的最大任务数的最终闭式表达式，用 $B$、$q$ 和 $c$ 表示。周期持续时间 $T$ 是一个上下文参数，用于确认预算 $B$ 是总时间的有效部分（$B \\leq T$），但它不参与基于预算约束对 $n$ 的计算。",
            "answer": "$$\n\\boxed{\\left\\lfloor \\frac{B}{q+c} \\right\\rfloor}\n$$"
        },
        {
            "introduction": "理论容量告诉我们能运行多少任务，但实际性能则取决于运行这些任务的效率。上下文切换并非没有代价，这个练习通过一个假设场景，让你量化比较两种不同上下文切换开销（$c_{\\text{hot}}$ 和 $c_{\\text{cold}}$）对系统性能的影响。通过手动模拟轮转调度过程，你将计算出有效的CPU利用率和平均周转时间，从而深刻理解即使是微小的切换开销差异，也会在宏观上对系统效率产生显著影响 。",
            "id": "3630387",
            "problem": "一个单核中央处理器 (CPU) 运行一个批处理工作负载，包含 $3$ 个计算密集型进程 $\\{P_{1},P_{2},P_{3}\\}$。这些进程都在时间 $t=0$ 到达，并且不执行输入/输出或阻塞操作。操作系统使用轮询 (Round-Robin, RR) 调度算法，固定时间量为 $q=2\\,\\text{ms}$。在每个时间片之前会立即执行一次上下文切换以调度下一个进程，此调度开销是完全串行的（与有效执行没有重叠）。上下文切换的成本取决于缓存状态，具体如下：如果下一个进程的工作集仍然驻留在缓存中，则切换成本为 $c_{\\text{hot}}$，否则为 $c_{\\text{cold}}$。\n\n定义进程的 CPU 突发需求为 $b_{1}=7\\,\\text{ms}$，$b_{2}=3\\,\\text{ms}$ 和 $b_{3}=5\\,\\text{ms}$。每次调度时，执行中的进程运行时间为 $\\min\\{q,\\text{剩余突发时间}\\}$。\n\n考虑两种在调度时引发不同缓存状态的抢占模式：\n\n- 模式 $\\mathcal{H}$ (热保留 RR)：在 $t=0$ 时的第一次调度产生 $c_{\\text{cold}}$ 的成本，之后的所有调度都产生 $c_{\\text{hot}}$ 的成本。\n- 模式 $\\mathcal{C}$ (冷主导 RR)：每次调度，包括第一次，都产生 $c_{\\text{cold}}$ 的成本。\n\n使用 $c_{\\text{hot}}=0.1\\,\\text{ms}$ 和 $c_{\\text{cold}}=0.6\\,\\text{ms}$。\n\n对于本实验，定义有效 CPU 利用率 $U$ 为所有进程完成前的总墙钟时间中，用于执行进程 CPU 突发（即，不包括调度开销所花费的时间）的部分所占的比例。定义进程 $i$ 的周转时间为 $C_{i}-A_{i}$，其中 $A_{i}$ 是到达时间，$C_{i}$ 是完成时间；由于所有进程的到达时间都是 $t=0$，所以平均周转时间为 $\\overline{T}=\\frac{1}{3}\\sum_{i=1}^{3}C_{i}$。\n\n计算模式 $\\mathcal{H}$ 下的 $U_{\\mathcal{H}}$ 和 $\\overline{T}_{\\mathcal{H}}$，以及模式 $\\mathcal{C}$ 下的 $U_{\\mathcal{C}}$ 和 $\\overline{T}_{\\mathcal{C}}$。然后构建综合改进因子\n$$\nM \\;=\\; \\frac{U_{\\mathcal{H}}}{U_{\\mathcal{C}}}\\,\\cdot\\,\\frac{\\overline{T}_{\\mathcal{C}}}{\\overline{T}_{\\mathcal{H}}}\\,,\n$$\n这是一个无量纲的量。将 $M$ 的最终值四舍五入到四位有效数字，并将其报告为一个无单位的纯数字。",
            "solution": "问题陈述经验证具有科学依据、提法明确、客观且完整。它描述了操作系统理论中的一个标准 CPU 调度场景，并提供了所有必要的参数。通过模拟所述的调度模型，可以推导出一个唯一的解。\n\n求解过程需要对两种指定的上下文切换成本模式 $\\mathcal{C}$ 和 $\\mathcal{H}$ 下的轮询 (Round-Robin, RR) 调度算法进行逐步模拟。对于每种模式，我们将确定每个进程 $P_i$ 的完成时间 $C_i$、总墙钟时间、有效 CPU 利用率 $U$ 和平均周转时间 $\\overline{T}$。\n\n给定的参数如下：\n- 进程数量：$3$个，即 $\\{P_{1}, P_{2}, P_{3}\\}$。\n- 到达时间：$A_{1}=A_{2}=A_{3}=0\\,\\text{ms}$。\n- CPU 突发需求：$b_{1}=7\\,\\text{ms}$，$b_{2}=3\\,\\text{ms}$ 和 $b_{3}=5\\,\\text{ms}$。\n- 调度算法：轮询 (RR)，时间量 $q=2\\,\\text{ms}$。\n- 上下文切换成本：$c_{\\text{hot}}=0.1\\,\\text{ms}$ 和 $c_{\\text{cold}}=0.6\\,\\text{ms}$。\n- 假定在 $t=0$ 时就绪队列的调度顺序为：$P_1 \\to P_2 \\to P_3$。\n\n所需的总时间片数量（也即上下文切换次数）是每个进程轮转次数的总和：\n$N_{\\text{slices}} = \\lceil \\frac{b_1}{q} \\rceil + \\lceil \\frac{b_2}{q} \\rceil + \\lceil \\frac{b_3}{q} \\rceil = \\lceil \\frac{7}{2} \\rceil + \\lceil \\frac{3}{2} \\rceil + \\lceil \\frac{5}{2} \\rceil = 4 + 2 + 3 = 9$。\n总共将有 $9$ 次上下文切换。\n\n首先，我们分析模式 $\\mathcal{C}$ (冷主导 RR)，其中每次上下文切换都产生 $c_{\\text{cold}}=0.6\\,\\text{ms}$ 的成本。\n\n令 $t$ 为当前时间（单位为 $\\text{ms}$），初始化为 $t=0$。令 $b_{i,r}$ 为进程 $P_i$ 的剩余突发时间。\n初始时，$b_{1,r}=7$，$b_{2,r}=3$，$b_{3,r}=5$。\n1. 调度 $P_1$：开销成本为 $c_{\\text{cold}}=0.6$。现在时间为 $t=0.6$。$P_1$ 运行 $q=2$。时间变为 $t=0.6+2=2.6$。$P_1$ 的剩余突发时间为 $b_{1,r}=7-2=5$。\n2. 调度 $P_2$：开销为 $c_{\\text{cold}}=0.6$。$t=2.6+0.6=3.2$。$P_2$ 运行 $q=2$。$t=3.2+2=5.2$。$b_{2,r}=3-2=1$。\n3. 调度 $P_3$：开销为 $c_{\\text{cold}}=0.6$。$t=5.2+0.6=5.8$。$P_3$ 运行 $q=2$。$t=5.8+2=7.8$。$b_{3,r}=5-2=3$。\n4. 调度 $P_1$：开销为 $c_{\\text{cold}}=0.6$。$t=7.8+0.6=8.4$。$P_1$ 运行 $q=2$。$t=8.4+2=10.4$。$b_{1,r}=5-2=3$。\n5. 调度 $P_2$：开销为 $c_{\\text{cold}}=0.6$。$t=10.4+0.6=11.0$。$P_2$ 运行其剩余的 $1\\,\\text{ms}$。$t=11.0+1=12.0$。$b_{2,r}=0$。进程 $P_2$ 完成，其完成时间为 $C_{2, \\mathcal{C}}=12.0\\,\\text{ms}$。\n6. 调度 $P_3$：开销为 $c_{\\text{cold}}=0.6$。$t=12.0+0.6=12.6$。$P_3$ 运行 $q=2$。$t=12.6+2=14.6$。$b_{3,r}=3-2=1$。\n7. 调度 $P_1$：开销为 $c_{\\text{cold}}=0.6$。$t=14.6+0.6=15.2$。$P_1$ 运行 $q=2$。$t=15.2+2=17.2$。$b_{1,r}=3-2=1$。\n8. 调度 $P_3$：开销为 $c_{\\text{cold}}=0.6$。$t=17.2+0.6=17.8$。$P_3$ 运行其剩余的 $1\\,\\text{ms}$。$t=17.8+1=18.8$。$b_{3,r}=0$。进程 $P_3$ 完成，$C_{3, \\mathcal{C}}=18.8\\,\\text{ms}$。\n9. 调度 $P_1$：开销为 $c_{\\text{cold}}=0.6$。$t=18.8+0.6=19.4$。$P_1$ 运行其剩余的 $1\\,\\text{ms}$。$t=19.4+1=20.4$。$b_{1,r}=0$。进程 $P_1$ 完成，$C_{1, \\mathcal{C}}=20.4\\,\\text{ms}$。\n\n模式 $\\mathcal{C}$ 的总时间为 $T_{\\text{total}, \\mathcal{C}}=20.4\\,\\text{ms}$。\n总 CPU 突发执行时间为 $B_{\\text{total}} = 7+3+5=15\\,\\text{ms}$。\n模式 $\\mathcal{C}$ 的有效 CPU 利用率为 $U_{\\mathcal{C}} = \\frac{B_{\\text{total}}}{T_{\\text{total}, \\mathcal{C}}} = \\frac{15}{20.4}$。\n完成时间为 $C_{1, \\mathcal{C}}=20.4$，$C_{2, \\mathcal{C}}=12.0$，$C_{3, \\mathcal{C}}=18.8$。由于所有进程都在 $A_i=0$ 时到达，它们的周转时间等于其完成时间。\n模式 $\\mathcal{C}$ 的平均周转时间为 $\\overline{T}_{\\mathcal{C}} = \\frac{1}{3}(20.4 + 12.0 + 18.8) = \\frac{51.2}{3}\\,\\text{ms}$。\n\n接下来，我们分析模式 $\\mathcal{H}$ (热保留 RR)，其中第一次切换的成本为 $c_{\\text{cold}}=0.6\\,\\text{ms}$，而后续的 8 次切换成本为 $c_{\\text{hot}}=0.1\\,\\text{ms}$。\n\n1. 调度 $P_1$：开销为 $c_{\\text{cold}}=0.6$。$t=0.6$。$P_1$ 运行 $q=2$。$t=2.6$。$b_{1,r}=5$。\n2. 调度 $P_2$：开销为 $c_{\\text{hot}}=0.1$。$t=2.6+0.1=2.7$。$P_2$ 运行 $q=2$。$t=4.7$。$b_{2,r}=1$。\n3. 调度 $P_3$：开销为 $c_{\\text{hot}}=0.1$。$t=4.7+0.1=4.8$。$P_3$ 运行 $q=2。t=6.8$。$b_{3,r}=3$。\n4. 调度 $P_1$：开销为 $c_{\\text{hot}}=0.1$。$t=6.8+0.1=6.9$。$P_1$ 运行 $q=2$。$t=8.9$。$b_{1,r}=3$。\n5. 调度 $P_2$：开销为 $c_{\\text{hot}}=0.1$。$t=8.9+0.1=9.0$。$P_2$ 运行 $1\\,\\text{ms}$。$t=10.0$。$b_{2,r}=0$。$P_2$ 完成，$C_{2, \\mathcal{H}}=10.0\\,\\text{ms}$。\n6. 调度 $P_3$：开销为 $c_{\\text{hot}}=0.1$。$t=10.0+0.1=10.1$。$P_3$ 运行 $q=2$。$t=12.1$。$b_{3,r}=1$。\n7. 调度 $P_1$：开销为 $c_{\\text{hot}}=0.1$。$t=12.1+0.1=12.2$。$P_1$ 运行 $q=2$。$t=14.2$。$b_{1,r}=1$。\n8. 调度 $P_3$：开销为 $c_{\\text hot}=0.1$。$t=14.2+0.1=14.3$。$P_3$ 运行 $1\\,\\text{ms}$。$t=15.3$。$b_{3,r}=0$。$P_3$ 完成，$C_{3, \\mathcal{H}}=15.3\\,\\text{ms}$。\n9. 调度 $P_1$：开销为 $c_{\\text{hot}}=0.1$。$t=15.3+0.1=15.4$。$P_1$ 运行 $1\\,\\text{ms}$。$t=16.4$。$b_1,r=0$。$P_1$ 完成，$C_{1, \\mathcal{H}}=16.4\\,\\text{ms}$。\n\n模式 $\\mathcal{H}$ 的总时间为 $T_{\\text{total}, \\mathcal{H}}=16.4\\,\\text{ms}$。\n总开销为 $c_{\\text{cold}} + (9-1)c_{\\text{hot}} = 0.6 + 8 \\times 0.1 = 1.4\\,\\text{ms}$。\n总时间核算：$B_{\\text{total}} + \\text{开销} = 15 + 1.4 = 16.4\\,\\text{ms}$，与计算结果一致。\n模式 $\\mathcal{H}$ 的有效 CPU 利用率为 $U_{\\mathcal{H}} = \\frac{B_{\\text{total}}}{T_{\\text{total}, \\mathcal{H}}} = \\frac{15}{16.4}$。\n完成时间为 $C_{1, \\mathcal{H}}=16.4$，$C_{2, \\mathcal{H}}=10.0$，$C_{3, \\mathcal{H}}=15.3$。\n模式 $\\mathcal{H}$ 的平均周转时间为 $\\overline{T}_{\\mathcal{H}} = \\frac{1}{3}(16.4 + 10.0 + 15.3) = \\frac{41.7}{3}\\,\\text{ms}$。\n\n最后，我们计算综合改进因子 $M$：\n$$\nM = \\frac{U_{\\mathcal{H}}}{U_{\\mathcal{C}}}\\,\\cdot\\,\\frac{\\overline{T}_{\\mathcal{C}}}{\\overline{T}_{\\mathcal{H}}}\n$$\n代入推导出的值：\n$$\nM = \\frac{15/16.4}{15/20.4} \\cdot \\frac{51.2/3}{41.7/3} = \\frac{20.4}{16.4} \\cdot \\frac{51.2}{41.7}\n$$\n$$\nM = \\frac{20.4 \\times 51.2}{16.4 \\times 41.7} = \\frac{1044.48}{683.88} \\approx 1.5272633\n$$\n将结果四舍五入到四位有效数字，我们得到 $1.527$。",
            "answer": "$$\\boxed{1.527}$$"
        },
        {
            "introduction": "轮转调度通常被认为是“公平的”，因为它为每个进程提供了相等的时间片。然而，当系统中同时存在计算密集型和交互式任务时，这种表面的公平性会受到挑战吗？本练习将引导你使用Jain公平指数这一标准度量，来分析混合工作负载下CPU份额的实际分配情况，并揭示时间量子 $q$ 的选择如何影响调度结果的公平性 。这个推导将帮助你理解，真正的公平性不仅仅是机会均等，更关乎结果的均衡。",
            "id": "3678396",
            "problem": "考虑一个使用轮询调度算法的单处理器系统，其时间量子为 $q$，上下文切换开销可忽略不计。在时间 $t=0$ 时，有 $N$ 个始终处于就绪状态的计算密集型任务和 $M$ 个交互式任务。交互式任务在消耗一小段中央处理器（CPU）时间后会自愿阻塞以进行输入/输出（I/O）。每个交互式任务一旦被调度，会运行一个固定的时长 $s$（其中 $0sq$），然后睡眠足够长的时间，以至于在感兴趣的时间区间内不会再次出现。调度器以循环顺序访问每个就绪任务最多一次，允许每个任务运行，直到它执行了 $q$ 个时间单位或主动放弃CPU，以先发生者为准。\n\n定义在所考虑的时间区间内，任务 $i$ 的有效CPU份额 $x_i$ 为其际CPU运行时间与该区间内所有任务累积的总CPU运行时间之比：\n$$\nx_i \\;=\\; \\frac{\\text{running time of task } i}{\\sum\\limits_{j=1}^{N+M} \\text{running time of task } j}.\n$$\n使用此定义，推导所得CPU份额向量 $x = (x_1,\\dots,x_{N+M})$ 的公平性指数 $J(q)$ 作为时间量子 $q$ 的函数，其中公平性指数由著名的 Jain公平性指数定义\n$$\nJ(x)\\;=\\;\\frac{\\left(\\sum\\limits_{i=1}^{N+M} x_i\\right)^{2}}{(N+M)\\left(\\sum\\limits_{i=1}^{N+M} x_i^{2}\\right)}.\n$$\n假设 $N\\geq 1$，$M\\geq 1$，$q0$ 且 $0sq$。请将您的最终答案表示为关于 $N$、$M$、$q$ 和 $s$ 的单个闭式解析表达式。不需要进行数值计算，也无需四舍五入。",
            "solution": "在尝试求解之前，首先对问题进行严格验证，以确保其科学上合理、良定且客观。\n\n**步骤 1：提取已知条件**\n- 系统：采用轮询调度的单处理器系统。\n- 时间量子：$q$。\n- 上下文切换开销：可忽略。\n- 计算密集型任务数量：$N$，其中 $N \\geq 1$。\n- 交互式任务数量：$M$，其中 $M \\geq 1$。\n- 计算密集型任务的行为：始终处于就绪状态。\n- 交互式任务的行为：运行一个固定的时长 $s$（其中 $0  s  q$），然后阻塞且不再出现。\n- 调度器逻辑：以循环顺序访问每个任务；运行直到时间量子 $q$ 用尽或任务主动放弃CPU。\n- CPU份额 $x_i$ 的定义：$x_i = \\frac{\\text{running time of task } i}{\\sum_{j=1}^{N+M} \\text{running time of task } j}$。\n- Jain公平性指数 $J(x)$ 的定义：$J(x) = \\frac{(\\sum_{i=1}^{N+M} x_i)^{2}}{(N+M)(\\sum_{i=1}^{N+M} x_i^{2})}$。\n- 任务：推导公平性指数 $J(q)$ 作为 $N$、$M$、$q$ 和 $s$ 的函数。\n\n**步骤 2：使用已知条件进行验证**\n该问题具有科学依据，利用了操作系统领域的标准概念，如轮询调度、时间量子、计算密集型与I/O密集型进程，以及一个公认的性能指标（Jain公平性指数）。所提出的模型虽然是一种简化（例如，忽略上下文切换、确定性的任务行为），但对于理论分析而言，它是一个常见且有效的抽象。该问题是良定的；所有参数和约束都已明确定义，从而可以得出一个可确定的、唯一的解。语言客观，没有歧义。“感兴趣的时间区间”这一短语由问题的上下文隐含地、充分地定义了：由于指定了 $M$ 个交互式任务只运行一次，因此评估所有 $N+M$ 个任务之间公平性的唯一合乎逻辑的区间，就是每个任务都有机会执行的那个单一的、初始的调度轮次。在这一轮之后，活动任务的集合发生变化，从而改变了系统的动态。因此，该问题是自洽的、一致的且可解的。\n\n**步骤 3：结论与行动**\n问题有效。现在开始推导解答。\n\n问题的核心是计算每个任务的CPU份额 $x_i$，然后将这些份额代入 Jain公平性指数的公式。我们在一个单一、完整的调度轮次中分析该系统，在此轮次中，每个初始的 $N+M$ 个任务都被服务一次。\n\n首先，我们确定在此区间内每种类型的任务所消耗的CPU时间。\n有 $N$ 个计算密集型任务。由于它们始终处于就绪状态，每个任务都将被调度并运行其完整的时间量子 $q$。这 $N$ 个任务中任何一个的运行时间都是 $q$。\n有 $M$ 个交互式任务。每个任务被指定在阻塞前运行一个时长 $s$。由于问题陈述 $0  s  q$，每个交互式任务将运行时间 $s$ 后，在其时间量子用尽之前主动放弃CPU。这 $M$ 个任务中任何一个的运行时间都是 $s$。\n\n在此区间内，所有任务累积的总CPU时间 $T_{\\text{total}}$ 是所有 $N$ 个计算密集型任务和 $M$ 个交互式任务的时间之和：\n$$ T_{\\text{total}} = (N \\times q) + (M \\times s) = Nq + Ms $$\n接下来，我们使用其定义 $x_i = (\\text{running time of task } i) / T_{\\text{total}}$ 来计算每个任务的CPU份额。\n对于 $N$ 个计算密集型任务中的每一个，其份额（我们可表示为 $x_{\\text{c}}$）是相同的：\n$$ x_{\\text{c}} = \\frac{q}{Nq + Ms} $$\n对于 $M$ 个交互式任务中的每一个，其份额（我们可表示为 $x_{\\text{int}}$）在其组内也是相同的：\n$$ x_{\\text{int}} = \\frac{s}{Nq + Ms} $$\n现在，我们应用 Jain公平性指数的公式 $J(q)$：\n$$ J(q) = \\frac{\\left(\\sum\\limits_{i=1}^{N+M} x_i\\right)^{2}}{(N+M)\\left(\\sum\\limits_{i=1}^{N+M} x_i^{2}\\right)} $$\n我们计算两个求和项。首先，分子中份额的和：\n$$ \\sum_{i=1}^{N+M} x_i = N \\cdot x_{\\text{c}} + M \\cdot x_{\\text{int}} = N \\left( \\frac{q}{Nq + Ms} \\right) + M \\left( \\frac{s}{Nq + Ms} \\right) = \\frac{Nq + Ms}{Nq + Ms} = 1 $$\n这证实了所有份额之和为 $1$ 的属性。因此，$J(q)$ 的分子是 $(1)^{2} = 1$。$J(q)$ 的公式简化为：\n$$ J(q) = \\frac{1}{(N+M)\\left(\\sum\\limits_{i=1}^{N+M} x_i^{2}\\right)} $$\n接下来，我们计算分母中份额平方的和：\n$$ \\sum_{i=1}^{N+M} x_i^{2} = N \\cdot x_{\\text{c}}^{2} + M \\cdot x_{\\text{int}}^{2} = N \\left( \\frac{q}{Nq + Ms} \\right)^{2} + M \\left( \\frac{s}{Nq + Ms} \\right)^{2} $$\n$$ \\sum_{i=1}^{N+M} x_i^{2} = \\frac{Nq^{2}}{(Nq + Ms)^{2}} + \\frac{Ms^{2}}{(Nq + Ms)^{2}} = \\frac{Nq^{2} + Ms^{2}}{(Nq + Ms)^{2}} $$\n最后，我们将此表达式代回 $J(q)$ 的简化公式中：\n$$ J(q) = \\frac{1}{(N+M) \\left( \\frac{Nq^{2} + Ms^{2}}{(Nq + Ms)^{2}} \\right)} $$\n将分母中的分数求倒数，得到公平性指数的最终闭式表达式：\n$$ J(q) = \\frac{(Nq + Ms)^{2}}{(N+M)(Nq^{2} + Ms^{2})} $$\n该表达式给出了作为给定参数 $N$、$M$、$q$ 和 $s$ 的函数的公平性指数。",
            "answer": "$$\n\\boxed{\\frac{(Nq + Ms)^{2}}{(N+M)(Nq^{2} + Ms^{2})}}\n$$"
        }
    ]
}