{
    "hands_on_practices": [
        {
            "introduction": "本练习提供了一个基础训练，旨在理解多级队列调度系统如何在预算约束下分配 CPU 时间。通过推导每个队列的服务份额，你将巩固对工作守恒和分层资源分配等核心原则在稳态场景下的理解。",
            "id": "3660877",
            "problem": "一个操作系统部署了多级队列调度 (MLQS)，其中有$3$个就绪队列，分别表示为 $Q_0$（最高优先级）、$Q_1$ 和 $Q_2$（最低优先级）。调度程序对前两个队列强制执行长期预算约束：队列 $Q_0$ 的预算为 $B_0$，队列 $Q_1$ 的预算为 $B_1$，其中 $0  B_0  1$, $0  B_1  1$, 且 $B_0 + B_1 \\le 1$。假设在重负载下的稳态（每个队列始终有可运行的线程）满足以下基本属性：\n\n- 调度程序是工作保持的 (work-conserving)：当有可运行的工作时，中央处理器 (CPU) 绝不会被有意闲置。\n- 预算约束是严格上限：一个饱和的队列其长期运行的CPU时间份额不能超过其预算。\n- 通过分级赠予确保无饥饿：任何未被较高优先级队列使用的容量将立即对较低优先级队列可用。\n\n设 $S_i$ 表示队列 $Q_i$ 获得的稳态服务份额（长期运行的CPU时间份额）。仅使用上述属性和定义，推导 $S_0$、$S_1$ 和 $S_2$ 关于 $B_0$ 和 $B_1$ 的表达式。将您的最终答案表示为一个包含 $S_0$、$S_1$ 和 $S_2$ 的单行矩阵，使用最简闭式形式。无需四舍五入，服务份额是无量纲的。",
            "solution": "该问题是有效的，因为它科学地基于操作系统调度的原理，定义良好，具有自洽和一致的定义与约束，并以客观、可形式化的语言表述。\n\n设 $S_i$ 表示队列 $Q_i$ 的稳态服务份额，其中 $i \\in \\{0, 1, 2\\}$。总可用CPU时间可以表示为1的分数。“工作保持”属性指出，如果有工作要做，CPU绝不会闲置。“重负载”假设保证了每个队列始终有可运行的线程。结合起来，这两个属性意味着所有队列的服务份额之和必须等于总可用CPU时间。\n$$S_0 + S_1 + S_2 = 1$$\n此方程表示CPU资源的完全分配。\n\n我们继续确定每个队列的服务份额，从最高优先级的 $Q_0$ 开始。队列 $Q_0$ 具有最高优先级并且是饱和的（总是有工作）。因此，调度程序将总是在其预算的限制下选择一个来自 $Q_0$ 的线程来运行。问题指出，预算 $B_0$ 是长期运行CPU时间份额的“严格上限”。由于 $Q_0$ 是饱和的，它将完全利用其分配的预算。因此，$Q_0$ 的稳态服务份额恰好是其预算。\n$$S_0 = B_0$$\n\n接下来，我们分析队列 $Q_1$。它的优先级低于 $Q_0$ 但高于 $Q_2$。除 $Q_0$ 之外的队列可用的CPU时间是总时间减去 $Q_0$ 消耗的时间，即 $1 - S_0 = 1 - B_0$。“分级赠予”属性确保了这部分剩余容量可用于较低优先级的队列。由于 $Q_1$ 的优先级高于 $Q_2$，它对这部分容量有优先使用权。队列 $Q_1$ 也是饱和的，并将尝试消耗尽可能多的可用时间。然而，其消耗受其自身预算 $B_1$ 的限制。因此，服务份额 $S_1$ 是可用容量与其预算之间的最小值：\n$$S_1 = \\min(1 - B_0, B_1)$$\n问题提供了约束条件 $B_0 + B_1 \\le 1$。这个不等式可以重排为 $B_1 \\le 1 - B_0$。这表明 $Q_1$ 的预算不大于 $Q_0$ 被服务后剩余的CPU容量。因此，$Q_1$ 的限制因素是其自身的预算，而不是可用容量。\n$$S_1 = B_1$$\n\n最后，我们确定最低优先级队列 $Q_2$ 的服务份额。由于调度程序是工作保持的，且 $Q_2$ 始终是可运行的，它将获得所有未被较高优先级队列 $Q_0$ 和 $Q_1$ 消耗的CPU时间。我们使用最初的资源分配方程：\n$$S_0 + S_1 + S_2 = 1$$\n代入推导出的 $S_0$ 和 $S_1$ 的表达式：\n$$B_0 + B_1 + S_2 = 1$$\n解出 $S_2$ 得到剩余的CPU时间份额：\n$$S_2 = 1 - B_0 - B_1$$\n给定的条件 $B_0 + B_1 \\le 1$ 确保了 $S_2 \\ge 0$，这意味着最低优先级的队列不会发生CPU时间饥饿，这与问题陈述的属性是一致的。\n\n因此，稳态服务份额为 $S_0 = B_0$，$S_1 = B_1$ 和 $S_2 = 1 - B_0 - B_1$。这些需要表示为一个单行矩阵。",
            "answer": "$$\\boxed{\\begin{pmatrix} B_0  B_1  1 - B_0 - B_1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "本练习从长时平均性能转向短期性能分析，挑战你分析低优先级任务的响应能力。你将通过对一个高优先级周期性任务的行为进行建模，来确定后台任务的首次响应最坏等待时间，这对于需要平衡交互式和批处理工作负载的系统来说是一个关键指标。",
            "id": "3660837",
            "problem": "一个单处理器操作系统使用一个严格抢占式多级队列调度器，该调度器包含三个队列：$Q_0$（最高优先级）、$Q_1$（中等优先级）和 $Q_2$（最低优先级）。中央处理器（CPU）总是从非空的最高优先级队列中运行一个就绪任务，并抢占任何来自较低优先级队列的任务。上下文切换和分派延迟可忽略不计。\n\n队列 $Q_0$ 承载一个周期性工作负载，其周期为 $P$，占空比为 $d$，其中 $0  d  1$。这意味着，在每个长度为 $P$ 的时间间隔内，$Q_0$ 队列中的任务总共需要 $dP$ 的 CPU 时间。在 $Q_0$ 队列有就绪任务时，它会连续运行。队列 $Q_1$ 始终为空。在时间 $t_0$ 时，一个批处理任务 $\\tau$ 到达 $Q_2$ 队列，此时 $Q_2$ 队列中没有其他任务。\n\n在给定这些条件下，推导任务 $\\tau$ 的首次响应时间（从到达时间 $t_0$ 到其首次执行的持续时间）的紧凑最坏情况上界。您的答案应该以 $P$ 和 $d$ 的封闭形式给出。",
            "solution": "我们从基本定义开始：\n\n- 在严格抢占式优先级调度下，队列优先级为 $Q_0 \\succ Q_1 \\succ Q_2$，CPU 对 $Q_2$ 可用，当且仅当 $Q_0$ 和 $Q_1$ 都为空闲状态。根据假设，$Q_1$ 为空，因此 CPU 对 $Q_2$ 的可用性等价于 $Q_0$ 为空闲状态。\n\n- 一个周期为 $P$、占空比为 $d$ 的周期性工作负载，在每个周期内执行一个长度为 $dP$ 的连续繁忙区间（在各个周期之间具有固定相位），在时间轴上产生一个重复模式：对于每个整数 $n$，存在一个繁忙区间\n  $$ I_n = [nP + \\phi,\\; nP + \\phi + dP) $$\n  其中 $\\phi \\in [0,P)$ 是某个固定相位，在此期间 $Q_0$ 执行并抢占 $Q_2$。在连续的繁忙区间 $I_n$ 和 $I_{n+1}$ 之间，$Q_0$ 空闲的时间恰好为 $(1-d)P$ 单位。\n\n令 $t_0$ 表示 $Q_2$ 任务 $\\tau$ 的到达时间。将 $\\tau$ 首次能够执行所需的最早时间 $\\Delta(t_0) \\ge 0$ 定义为最小非负偏移量，使得 $t_0 + \\Delta(t_0)$ 不落在任何 $Q_0$ 的繁忙区间内：\n$$ \\Delta(t_0) \\equiv \\inf \\{ \\Delta \\ge 0 \\mid t_0 + \\Delta \\notin \\bigcup_{n \\in \\mathbb{Z}} I_n \\}. $$\n因为 $Q_1$ 为空，并且在 $\\tau$ 到达时 $Q_2$ 中没有其他积压任务，所以当 $Q_0$ 变为空闲时，$\\tau$ 将立即被分派。因此，$\\tau$ 的首次响应时间等于 $\\Delta(t_0)$。\n\n我们现在对 $\\Delta(t_0)$ 进行统一上界约束，考虑所有到达相位 $t_0$ 相对于 $\\{I_n\\}_{n \\in \\mathbb{Z}}$ 的周期性结构。\n\n从周期性开关模型中推导出的关键结构性事实：\n\n- 每个繁忙区间 $I_n$ 的长度为 $|I_n| = dP$。\n- 连续的繁忙区间之间由一个长度为 $(1-d)P$ 的空闲间隙分隔：\n  $$ \\text{gap}(I_n, I_{n+1}) = (n+1)P + \\phi - \\big(nP + \\phi + dP\\big) = P - dP = (1-d)P. $$\n- 因此，没有两个繁忙区间是相邻的；每个繁忙区间之后都跟着一个固定长度为 $(1-d)P$ 的空闲区间。\n\n考虑到达时间 $t_0$ 的两种情况：\n\n1. $t_0 \\notin \\bigcup_{n} I_n$（在空闲区间内到达）。那么 $\\Delta(t_0) = 0$，因为 CPU 立即对 $Q_2$ 可用。\n\n2. $t_0 \\in I_k$（对于某个 $k$，在繁忙区间内到达）。由于 $I_k$ 是一个长度为 $dP$ 的连续区间，距离 $I_k$ 结束的剩余时间为\n   $$ r(t_0) = \\big(kP + \\phi + dP\\big) - t_0 \\in (0, dP]. $$\n   CPU 首次对 $Q_2$ 可用的时刻恰好是 $I_k$ 结束之时，因为随后的时间段是一个长度为 $(1-d)P$ 的空闲区间。因此，\n   $$ \\Delta(t_0) = r(t_0) \\le dP. $$\n\n综合这两种情况，我们得到统一上界\n$$ \\Delta(t_0) \\le dP. $$\n\n紧凑性：这个界是紧凑的，因为存在一个到达相位可以使等式成立。选择 $t_0 = nP + \\phi$，其中 $n$ 为任意整数，即到达时间恰好与繁忙区间 $I_n$ 的开始时间重合。那么 $r(t_0) = dP$，所以 $\\Delta(t_0) = dP$。\n\n因此，$\\tau$ 的首次响应时间的紧凑最坏情况上界是\n$$ dP. $$\n\n当 $P$ 的单位是秒且 $d$ 是无量纲的时，这个界以时间单位（例如，秒）表示。最终表达式按要求以 $P$ 和 $d$ 的封闭形式给出。",
            "answer": "$$\\boxed{dP}$$"
        },
        {
            "introduction": "本练习将探讨一个与直觉相反的“调度异常”现象，即优化单个作业反而可能降低整体系统性能。通过计算两种不同场景下的总完成时间（makespan），你将了解到上下文切换和缓存预热等开销如何导致意想不到的结果，以及为什么在性能调优中全局系统视角至关重要。",
            "id": "3660936",
            "problem": "一个操作系统实现了具有严格优先级的多级队列（MLQ）调度，其中前台队列 $Q_1$（交互式）在任何 $Q_1$ 作业到达时总是抢占后台队列 $Q_2$（批处理）。$Q_1$ 队列使用轮询（RR）调度，$Q_2$ 队列使用先到先服务（FCFS）调度。一次上下文切换消耗 $c = 0.2\\,\\mathrm{ms}$ 的 CPU 时间，并且每次抢占 $Q_2$ 作业都会在 $Q_2$ 作业恢复有效执行之前产生额外的缓存和转译后备缓冲器（TLB）预热开销 $\\delta = 0.8\\,\\mathrm{ms}$。假设中央处理器（CPU）在有任何作业就绪时从不空闲，并且每当一个 $Q_1$ 的 CPU 计算突发（burst）到达时，它会立即抢占正在运行的任何 $Q_2$ 作业。\n\n考虑以下工作负载，所有作业均在时间 $t=0$ 时到达：\n- 一个 $Q_1$ 作业，记为 $I$，以及两个 $Q_2$ 作业，记为 $B_1$ 和 $B_2$。\n- $B_1$ 的总 CPU 需求为 $120\\,\\mathrm{ms}$，$B_2$ 的总 CPU 需求为 $80\\,\\mathrm{ms}$，因此 $Q_2$ 共有 $200\\,\\mathrm{ms}$ 的 CPU 工作量。\n- 情况 $\\mathrm{Old}$（$I$ “加速”前）：作业 $I$ 需要 $30\\,\\mathrm{ms}$ 的 CPU，其结构为 $3$ 个各 $10\\,\\mathrm{ms}$ 的计算突发，连续的计算突发之间有 $50\\,\\mathrm{ms}$ 的输入/输出（I/O）阻塞时间。\n- 情况 $\\mathrm{New}$（$I$ “加速”后）：作业 $I$ 经过优化，现在需要 $20\\,\\mathrm{ms}$ 的 CPU，其结构为 $20$ 个各 $1\\,\\mathrm{ms}$ 的计算突发，连续的计算突发之间有 $5\\,\\mathrm{ms}$ 的 I/O 阻塞时间。\n\n仅使用严格优先级 MLQ、FCFS、抢占、上下文切换开销和完工时间（定义为所有作业完成时的墙上时钟时间）的核心定义，回答以下问题：\n\n1. 在给定假设下，计算情况 $\\mathrm{Old}$ 和情况 $\\mathrm{New}$ 的工作负载完工时间。明确计算 $Q_2$ 面临的每次抢占开销（每次当 $Q_1$ 的一个计算突发到达而 $Q_2$ 正在运行时，都包含 $c$ 和 $\\delta$）。\n2. 尽管在情况 $\\mathrm{New}$ 中 $I$ 消耗的 CPU 比情况 $\\mathrm{Old}$ 中少，工作负载的完工时间却可能增加。哪个选项最能解释这种调度异常的根本原因？\n\n选项：\n- A. 在严格优先级的 MLQ 中，更频繁的 $Q_1$ 到达会导致对 $Q_2$ 的额外抢占。每次抢占都会增加 $c+\\delta$ 的开销并破坏 $Q_2$ 的局部性，因此如果累积的开销增量超过了 $I$ 的 CPU 需求减少量，完工时间就会增加。\n\n- B. $Q_1$ 和 $Q_2$ 之间的优先级反转导致 $Q_1$ 在 $Q_2$ 之后阻塞；加速 $Q_1$ 会加剧这种反转，从而延迟所有作业。\n\n- C. 该异常是由于 $Q_2$ 中的轮询调度使用过小的时间片，这会使 $Q_2$ 的计算突发碎片化；加速 $Q_1$ 仅仅是揭示了这个潜在问题。\n\n- D. 即使上下文切换和抢占成本为零（即 $c=\\delta=0$），这种异常仍然会发生；因此，根本原因内在于抢占的时机而非开销。",
            "solution": "用户希望我扮演一位严谨的 STEM 教授，解决并分析一个关于操作系统调度的问题。我将首先验证问题陈述的有效性，然后进行详细的解答和选项分析。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n- **调度器类型：** 具有严格优先级的多级队列（MLQ）。\n- **队列：**\n    - $Q_1$：前台（交互式），较高优先级。\n    - $Q_2$：后台（批处理），较低优先级。\n- **优先级规则：** 来自 $Q_1$ 的作业总是抢占来自 $Q_2$ 的作业。$Q_1$ 作业的到达会立即抢占任何正在运行的 $Q_2$ 作业。\n- **队列算法：**\n    - $Q_1$：轮询（RR）。\n    - $Q_2$：先到先服务（FCFS）。\n- **工作负载（均在 $t=0$ 时到达）：**\n    - 一个 $Q_1$ 作业：$I$。\n    - 两个 $Q_2$ 作业：$B_1$ 和 $B_2$。\n- **作业 CPU 需求：**\n    - $B_1$：$120\\,\\mathrm{ms}$。\n    - $B_2$：$80\\,\\mathrm{ms}$。\n- **情况 $\\mathrm{Old}$（作业 $I$）：**\n    - 总 CPU：$30\\,\\mathrm{ms}$。\n    - 结构：$3$ 个各 $10\\,\\mathrm{ms}$ 的计算突发。\n    - I/O 时间：计算突发之间 $50\\,\\mathrm{ms}$。\n- **情况 $\\mathrm{New}$（作业 $I$）：**\n    - 总 CPU：$20\\,\\mathrm{ms}$。\n    - 结构：$20$ 个各 $1\\,\\mathrm{ms}$ 的计算突发。\n    - I/O 时间：计算突发之间 $5\\,\\mathrm{ms}$。\n- **开销：**\n    - 上下文切换成本：$c = 0.2\\,\\mathrm{ms}$。\n    - $Q_2$ 抢占开销（缓存/TLB 预热）：$\\delta = 0.8\\,\\mathrm{ms}$，在 $Q_2$ 作业恢复前产生。\n- **CPU 假设：** 有任何作业就绪时，CPU 从不空闲。\n- **问题指令：** 计算两种情况下的完工时间，明确将每次抢占的开销计为 $c$ 和 $\\delta$。\n- **度量指标：** 完工时间是所有作业完成时的墙上时钟时间。\n\n**第二步：使用提取的已知条件进行验证**\n\n对问题陈述进行严格审查：\n- **科学依据充分：** 该问题基于操作系统中标准且完善的概念，包括多级队列调度、抢占、上下文切换和缓存效应（局部性）。该场景是用于说明调度器性能的经典示例。它在科学上是合理的。\n- **定义明确：** 问题提供了所有必要的参数：调度算法、优先级规则、作业特征（到达时间、CPU 计算突发、I/O 时间）和开销成本。目标（计算完工时间并解释异常现象）定义清晰。这些条件允许对系统执行进行唯一的、确定性的模拟。\n- **客观：** 问题使用精确、无歧义的技术术语陈述。没有主观或基于意见的内容。\n\n问题包含了一个关于如何计算开销的具体说明：“明确计算 $Q_2$ 面临的每次抢占开销（每次当 $Q_1$ 的一个计算突发到达而 $Q_2$ 正在运行时，都包含 $c$ 和 $\\delta$）”。这指导求解者在每次抢占事件中使用 $c+\\delta$ 的总开销，解决了在对完整的抢占周期中涉及的两次独立上下文切换和预热开销进行建模时可能出现的任何歧义。这是问题本身提供的一个简化模型。\n\n**第三步：结论与行动**\n\n该问题是**有效**的。这是一个来自操作系统领域、定义明确且有科学依据的问题，需要仔细的计算和概念推理。我将着手进行解答。\n\n### 求解推导\n\n分析需要计算两种场景下的完工时间。由于 CPU 从不空闲，完工时间是所有 CPU 忙碌时间的总和。这包括所有作业的有效 CPU 时间和用于开销的无效时间。\n\n完工时间 = (所有作业的总 CPU 需求) + (总开销)\n\n后台作业的总 CPU 需求是恒定的：$120\\,\\mathrm{ms} + 80\\,\\mathrm{ms} = 200\\,\\mathrm{ms}$。\n每次抢占的开销由上下文切换成本和预热开销之和给出：$c + \\delta = 0.2\\,\\mathrm{ms} + 0.8\\,\\mathrm{ms} = 1.0\\,\\mathrm{ms}$。\n当作业 $I$ 的一个计算突发到达（即完成其 I/O 并变为就绪状态）而一个 $Q_2$ 作业（$B_1$ 或 $B_2$）正在运行时，就会发生抢占。\n\n**1. 完工时间计算**\n\n**情况 $\\mathrm{Old}$**\n- 作业 $I$ 的 CPU 需求：$3 \\times 10\\,\\mathrm{ms} = 30\\,\\mathrm{ms}$。\n- 作业 $I$ 的结构：$3$ 个 CPU 计算突发。第一个计算突发在 $t=0$ 时开始，此时 CPU 空闲，因此它不抢占任何作业。随后的 $3-1 = 2$ 个计算突发将在它们各自的 I/O 周期后到达。\n- 让我们确认当这些后续计算突发到达时，是否有一个 $Q_2$ 作业正在运行。\n    - $t \\in [0, 10]\\,\\mathrm{ms}$：$I$ 运行其第一个 $10\\,\\mathrm{ms}$ 的计算突发。\n    - $t \\in [10, 60]\\,\\mathrm{ms}$：$I$ 处于 $50\\,\\mathrm{ms}$ 的 I/O 状态。在此期间，$B_1$（来自 FCFS 的 $Q_2$ 队列）运行。\n    - 在 $t=60\\,\\mathrm{ms}$ 时，$I$ 再次变为就绪。由于 $B_1$ 正在运行，发生一次抢占。\n    - 这种模式会继续。在 $I$ 的每个 CPU 计算突发（除了最后一个）之后，它会执行 I/O，允许一个 $Q_2$ 作业运行，然后在 $I$ 再次就绪时被抢占。\n- 抢占次数：有 $2$ 次抢占，一次是为作业 $I$ 的第二个计算突发，一次是为第三个计算突发。\n- 总开销：$2 \\times (c + \\delta) = 2 \\times 1.0\\,\\mathrm{ms} = 2.0\\,\\mathrm{ms}$。\n- 总 CPU 工作量：（$I$ 的 CPU 时间）+（$B_1, B_2$ 的 CPU 时间）= $30\\,\\mathrm{ms} + 200\\,\\mathrm{ms} = 230\\,\\mathrm{ms}$。\n- 完工时间 ($\\mathrm{Old}$): 总 CPU 工作量 + 总开销 = $230\\,\\mathrm{ms} + 2.0\\,\\mathrm{ms} = 232\\,\\mathrm{ms}$。\n\n**情况 $\\mathrm{New}$**\n- 作业 $I$ 的 CPU 需求：$20 \\times 1\\,\\mathrm{ms} = 20\\,\\mathrm{ms}$。\n- 作业 $I$ 的结构：$20$ 个 CPU 计算突发。第一个计算突发不抢占。随后的 $20-1=19$ 个计算突发都将各自导致一次抢占。\n- $I$ 的一个周期（CPU + I/O）的时间为 $1\\,\\mathrm{ms} + 5\\,\\mathrm{ms} = 6\\,\\mathrm{ms}$。在 $5\\,\\mathrm{ms}$ 的 I/O 阻塞期间，一个 $Q_2$ 作业将运行。在 I/O 结束时，$I$ 将变为就绪并抢占正在运行的 $Q_2$ 作业。这对于初始计算突发后的所有 $19$ 个计算突发都会发生。\n- 抢占次数：$19$ 次。\n- 总开销：$19 \\times (c + \\delta) = 19 \\times 1.0\\,\\mathrm{ms} = 19\\,\\mathrm{ms}$。\n- 总 CPU 工作量：（$I$ 的 CPU 时间）+（$B_1, B_2$ 的 CPU 时间）= $20\\,\\mathrm{ms} + 200\\,\\mathrm{ms} = 220\\,\\mathrm{ms}$。\n- 完工时间 ($\\mathrm{New}$): 总 CPU 工作量 + 总开销 = $220\\,\\mathrm{ms} + 19\\,\\mathrm{ms} = 239\\,\\mathrm{ms}$。\n\n**计算总结：**\n- 情况 $\\mathrm{Old}$ 的完工时间：$232\\,\\mathrm{ms}$。\n- 情况 $\\mathrm{New}$ 的完工时间：$239\\,\\mathrm{ms}$。\n\n尽管作业 $I$ 使用的总 CPU 时间更少（减少了 $30-20=10\\,\\mathrm{ms}$），完工时间却从 $232\\,\\mathrm{ms}$ 增加到了 $239\\,\\mathrm{ms}$。这是因为总开销的增加量（$19-2=17\\,\\mathrm{ms}$）大于 CPU 时间的减少量。\n\n**2. 异常分析（选项评估）**\n\n- **A. 在严格优先级的 MLQ 中，更频繁的 $Q_1$ 到达会导致对 $Q_2$ 的额外抢占。每次抢占都会增加 $c+\\delta$ 的开销并破坏 $Q_2$ 的局部性，因此如果累积的开销增量超过了 $I$ 的 CPU 需求减少量，完工时间就会增加。**\n    - 这个选项准确地描述了我们刚刚量化的机制。作业 $I$ 的结构重组导致了更频繁地从 I/O 返回（$20$ 个计算突发而非 $3$ 个），这导致了更多的抢占（$19$ 次而非 $2$ 次）。每次抢占都增加了 $c+\\delta$ 的开销。术语 $\\delta$ 明确用于缓存/TLB 预热，这是局部性损失的一种度量。我们的计算表明，累积的开销增量（$17\\,\\mathrm{ms}$）超过了 $I$ 的 CPU 需求减少量（$10\\,\\mathrm{ms}$），导致了更长的完工时间。这个陈述正确地指出了根本原因。\n    - **结论：正确。**\n\n- **B. $Q_1$ 和 $Q_2$ 之间的优先级反转导致 $Q_1$ 在 $Q_2$ 之后阻塞；加速 $Q_1$ 会加剧这种反转，从而延迟所有作业。**\n    - 优先级反转发生在当一个高优先级任务被迫等待一个低优先级任务释放资源时。该问题描述的是一个严格优先级的抢占式调度器，其中高优先级作业 $I$ *从不*等待 $B_1$ 或 $B_2$。它会立即抢占它们。该系统中没有发生优先级反转。\n    - **结论：错误。**\n\n- **C. 该异常是由于 $Q_2$ 中的轮询调度使用过小的时间片，这会使 $Q_2$ 的计算突发碎片化；加速 $Q_1$ 仅仅是揭示了这个潜在问题。**\n    - 问题陈述明确指出 $Q_2$ 队列使用先到先服务（FCFS），而不是轮询。这个陈述基于一个错误的前提。\n    - **结论：错误。**\n\n- **D. 即使上下文切换和抢占成本为零（即 $c=\\delta=0$），这种异常仍然会发生；因此，根本原因内在于抢占的时机而非开销。**\n    - 这是一个可检验的反事实假设。让我们假设 $c=0$ 且 $\\delta=0$。\n    - 完工时间（$\\mathrm{Old}$，零开销）= 总 CPU 工作量 = $30\\,\\mathrm{ms} + 200\\,\\mathrm{ms} = 230\\,\\mathrm{ms}$。\n    - 完工时间（$\\mathrm{New}$，零开销）= 总 CPU 工作量 = $20\\,\\mathrm{ms} + 200\\,\\mathrm{ms} = 220\\,\\mathrm{ms}$。\n    - 如果开销为零，完工时间将会减少，而异常（完工时间增加）就不会发生。因此，开销成本是导致异常的根本原因，而不是孤立的抢占时机。\n    - **结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}