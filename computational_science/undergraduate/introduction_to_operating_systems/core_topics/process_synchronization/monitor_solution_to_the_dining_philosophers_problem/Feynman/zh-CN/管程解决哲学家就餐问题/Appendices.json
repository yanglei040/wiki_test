{
    "hands_on_practices": [
        {
            "introduction": "让我们从管程的核心——信号机制——开始。一个设计良好的管程不仅要保证正确性，还应追求效率，避免不必要的开销。本练习  将挑战你分析一个包含过多信号的“冗余”实现，并将其精简至最核心的信号集合，这将迫使你深入理解在Mesa语义下，信号在何时何处才是真正必要的，从而锻炼你编写简洁高效同步代码的能力。",
            "id": "3659274",
            "problem": "一个基于管程的哲学家就餐问题的解决方案在 Mesa 风格的条件变量语义下实现，其中 `signal` 操作会唤醒一个等待的线程并将其置于管程的入口队列中，而 `wait` 操作会释放管程并挂起线程直到收到信号。哲学家的数量为 $N \\ge 5$，索引为 $0, 1, \\dots, N-1$。令 $\\mathrm{left}(i) = (i-1) \\bmod N$ 且 $\\mathrm{right}(i) = (i+1) \\bmod N$。每个哲学家 $i$ 维持一个状态 $s[i] \\in \\{\\mathrm{THINKING}, \\mathrm{HUNGRY}, \\mathrm{EATING}\\}$ 并拥有一个私有条件变量 $c[i]$。此外还有一个全局条件变量 $g$。所有对共享状态的访问都发生在管程内部，这保证了互斥。\n\n定义哲学家 $j$ 的启用谓词为\n$$\nP(j) \\equiv \\big(s[j] = \\mathrm{HUNGRY}\\big) \\land \\big(s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}\\big) \\land \\big(s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}\\big).\n$$\n\n考虑以下带有标记信号点 $S_1, S_2, \\dots, S_7$ 的冗长管程代码。过程 $\\mathrm{test}(i)$ 检查启用谓词，如果为真，则将哲学家的状态转换为进食。\n\n- $\\mathrm{test}(i)$:\n  - 如果 $P(i)$ 成立，则\n    - 设置 $s[i] := \\mathrm{EATING}$。\n    - $S_1$: signal $c[i]$。\n    - $S_2$: signal $c[\\mathrm{left}(i)]$。\n    - $S_3$: signal $c[\\mathrm{right}(i)]$。\n\n- $\\mathrm{pickup}(i)$:\n  - 设置 $s[i] := \\mathrm{HUNGRY}$。\n  - 调用 $\\mathrm{test}(i)$。\n  - 当 $s[i] \\ne \\mathrm{EATING}$ 时，在 $c[i]$ 上等待。\n  - $S_4$: signal $g$。\n\n- $\\mathrm{putdown}(i)$:\n  - 设置 $s[i] := \\mathrm{THINKING}$。\n  - $S_5$: signal $c[\\mathrm{left}(i)]$。\n  - $S_6$: signal $c[\\mathrm{right}(i)]$。\n  - 调用 $\\mathrm{test}(\\mathrm{left}(i))$；然后调用 $\\mathrm{test}(\\mathrm{right}(i))$。\n  - $S_7$: broadcast $g$。\n\n假设如下：\n- 使用 Mesa 风格的条件变量，每个等待的线程在一个 `while` 循环中重新检查其条件。\n- 管程为所有上述操作提供互斥。\n- 调度器是弱公平的：一个持续被启用且无限次就绪的线程最终会运行。\n- 除非一个线程的启用谓词由于管程内部发生的状态变化而刚刚变为真，否则不应向该线程发送信号，以避免虚假唤醒。目标是在遵守此规则的同时，移除冗余的信号操作，并保持安全性（没有两个相邻的哲学家同时进食）和活性（如果一个哲学家 $p$ 保持饥饿且其邻居最终停止进食，那么 $p$ 最终会进食）。\n\n哪个选项留下了必须保留在代码中的最小信号操作集合，以保持所述的安全性和活性属性，同时遵守“仅当特定哲学家的启用谓词刚刚变为真时才发送信号”的规则，并将所有其他信号/广播作为冗余移除？\n\nA. 仅保留 $\\mathrm{test}(i)$ 内的 $S_1$；移除 $S_2, S_3, S_4, S_5, S_6, S_7$。\n\nB. 保留 $S_1$ 并同时保留 $S_5$ 和 $S_6$；移除 $S_2, S_3, S_4, S_7$。\n\nC. 移除 $S_1, S_2, S_3, S_4, S_5, S_6$；仅保留 $S_7$（在 $\\mathrm{putdown}(i)$ 中对全局变量进行广播）。\n\nD. 移除 $S_1, S_4, S_7$；保留 $S_2, S_3, S_5, S_6$（在 $\\mathrm{test}$ 和 $\\mathrm{putdown}$ 中都只对邻居发信号）。",
            "solution": "问题的核心在于信号发送规则：仅当哲学家 $j$ 的谓词 $P(j)$ 刚刚变为真时，才向其发送信号。我们来分析一下 $P(j)$ 何时可以从假变为真。\n谓词是 $P(j) \\equiv \\big(s[j] = \\mathrm{HUNGRY}\\big) \\land \\big(s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}\\big) \\land \\big(s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}\\big)$。\n为了使 $P(j)$ 变为真，所有三个子句都必须为真。管程内部的状态变化必须导致最后一个为假的子句变为真。\n- 当哲学家 $j$ 调用 $\\mathrm{pickup}(j)$ 时，项 $s[j] = \\mathrm{HUNGRY}$ 变为真。\n- 当哲学家 $\\mathrm{left}(j)$ 结束进食并调用 $\\mathrm{putdown}(\\mathrm{left}(j))$，将其状态从 $\\mathrm{EATING}$ 更改为 $\\mathrm{THINKING}$ 时，项 $s[\\mathrm{left}(j)] \\ne \\mathrm{EATING}$ 变为真。\n- 当哲学家 $\\mathrm{right}(j)$ 调用 $\\mathrm{putdown}(\\mathrm{right}(j))$ 时，项 $s[\\mathrm{right}(j)] \\ne \\mathrm{EATING}$ 变为真。\n\n因此，唯一能使一个等待中的饥饿哲学家的谓词变为真的事件是其邻居结束进食。这发生在该邻居的 `putdown` 过程中。正确的逻辑是，结束进食的哲学家检查其行为是否使其任一邻居能够进食。所提供的代码通过让 `putdown(i)` 调用 `test(left(i))` 和 `test(right(i))` 来实现这一点。\n\n现在，我们根据这一原则以及对正确性（安全性和活性）的需求来分析每个信号。\n\n- **对 `test(i)` 信号的分析**：\n  - $S_1: \\mathrm{signal}~c[i]$：如果发现 $P(i)$ 为真并且状态已设置为 $s[i] := \\mathrm{EATING}$，则会发出此信号。哲学家 $i$ 在 `pickup(i)` 过程中，以 `while s[i] \\ne \\mathrm{EATING}` 为条件在 $c[i]$ 上等待。在另一个线程执行 `test(i)` 并设置 `s[i] := \\mathrm{EATING}` 后，必须唤醒哲学家 $i$ 以重新评估其循环条件，发现条件为假，然后继续进食。如果没有这个信号，一个被批准进食的哲学家将永远等待。因此，$S_1$ 对**活性至关重要**。这个信号没有违反规则，因为它是对 $P(i)$ 已变为真并已验证这一事实采取行动的直接结果。\n  - $S_2: \\mathrm{signal}~c[\\mathrm{left}(i)]$ 和 $S_3: \\mathrm{signal}~c[\\mathrm{right}(i)]$: 这些信号在 `test(i)` 成功后发送，意味着 $s[i]$ 刚刚被设置为 $\\mathrm{EATING}$。这个状态变化导致谓词 $P(\\mathrm{left}(i))$ 和 $P(\\mathrm{right}(i))$ 变为*假*（因为它们的一个邻居现在正在进食）。向一个其启用条件刚刚变为假的线程发送信号直接违反了信号发送规则，并且没有任何用处。因此，在指定的规则下，$S_2$ 和 $S_3$ 是**冗余且不正确的**。\n\n- **对 `pickup(i)` 信号的分析**：\n  - $S_4: \\mathrm{signal}~g$: 这个信号在哲学家 $i$ 成功通过 `wait` 循环并被视为正在进食后发送。状态变化是 `s[i]` 变为 $\\mathrm{EATING}$。如刚才所讨论的，这使得邻居的谓词变为假。它不会使任何其他先验未知的哲学家的谓词变为真。信号是在全局条件变量 $g$ 上，但尚不清楚谁会在上面等待或为什么等待。鉴于有特定的 `c[i]` 变量，这个信号似乎没有目的。它肯定不符合信号发送规则。因此，$S_4$ 是**冗余的**。\n\n- **对 `putdown(i)` 信号的分析**：\n  - $S_5: \\mathrm{signal}~c[\\mathrm{left}(i)]$ 和 $S_6: \\mathrm{signal}~c[\\mathrm{right}(i)]$: 这些信号在调用 `test(left(i))` 和 `test(right(i))` *之前*发送。当 `putdown(i)` 向 `c[left(i)]` 发送信号时，哲学家 `left(i)`（如果饥饿且在等待）将被唤醒。由于 Mesa 语义，它重新进入管程并重新评估其等待条件：`s[left(i)] \\ne \\mathrm{EATING}`。这个条件仍然为假（其状态是 `HUNGRY`），因为会将其状态更改为 `EATING` 的 `test(left(i))` 调用尚未发生。所以，哲学家又回去睡觉了。这是一个虚假唤醒。正确且高效的程序是首先调用 `test(left(i))`，它将状态设置为 `EATING` 然后*再*发送信号（通过 $S_1$）。由于 `test` 调用与 $S_1$ 结合提供了正确的信号机制，因此 $S_5$ 和 $S_6$ 是**冗余且低效的**。\n  - $S_7: \\mathrm{broadcast}~g$: 这会唤醒所有在全局条件变量 $g$ 上等待的线程。然而，`pickup` 过程指定了哲学家在他们的私有条件变量 `c[i]` 上等待。在 `g` 上的广播不会唤醒他们。即使我们假设线程在 `g` 上等待，广播的效率也远低于 `test` 调用提供的定向信号。它会导致“惊群效应”，即所有等待的哲学家都被唤醒并竞争管程，结果大多数哲学家发现它们的条件仍然为假。鉴于存在私有条件变量，$S_7$ 是**冗余且无效的**。\n\n**推导结论**：\n唯一既对活性必要又符合解决方案逻辑的信号是 $S_1$。当一个哲学家 `i` 放下叉子时，它会对它的邻居调用 `test`。如果一个邻居 `j` 现在可以进食，`test(j)` 会设置 `s[j] := \\mathrm{EATING}` 并使用 `S_1`（即 `signal c[j]`）来唤醒哲学家 `j`。这是该管程解决方案公认的正确且最小的结构。\n\n### 逐项分析\n\n- **A. 仅保留 $\\mathrm{test}(i)$ 内的 $S_1$；移除 $S_2, S_3, S_4, S_5, S_6, S_7$。**\n  - 该选项反映了我们的推导结论。仅保留 $S_1$ 创建了由 Tanenbaum 为哲学家就餐问题提出的标准、正确且高效的解决方案。安全性由管程互斥内的谓词检查来保证。活性得到保证（根据问题的定义），因为一个结束进食的哲学家会测试其邻居，如果一个邻居可以进食，它就会被发信号。这是一个最小集合，因为移除 $S_1$ 会破坏活性。\n  - **结论：正确。**\n\n- **B. 保留 $S_1$ 并同时保留 $S_5$ 和 $S_6$；移除 $S_2, S_3, S_4, S_7$。**\n  - 该选项保留了必要的信号 $S_1$，但同时也包括了冗余的信号 $S_5$ 和 $S_6$。如分析所述，$S_5$ 和 $S_6$ 在状态被 `test` 调用改变之前发送，导致虚假唤醒。由于目标是*最小*集合，而 $S_5$ 和 $S_6$ 是冗余的，因此该选项不正确。\n  - **结论：不正确。**\n\n- **C. 移除 $S_1, S_2, S_3, S_4, S_5, S_6$；仅保留 $S_7$（在 $\\mathrm{putdown}(i)$ 中对全局变量进行广播）。**\n  - 该选项移除了必要的信号 $S_1$。没有 $S_1$，一个其状态被 `test` 调用设置为 `EATING` 的哲学家将永远不会从其在 `c[i]` 上的等待中被唤醒。此外，广播 $S_7$ 是在全局变量 $g$ 上，而哲学家们在他们的私有变量 $c[i]$ 上等待。系统将无法工作并会死锁。\n  - **结论：不正确。**\n\n- **D. 移除 $S_1, S_4, S_7$；保留 $S_2, S_3, S_5, S_6$（在 $\\mathrm{test}$ 和 $\\mathrm{putdown}$ 中都只对邻居发信号）。**\n  - 该选项移除了对活性至关重要的信号 $S_1$。它保留了违反信号发送规则的信号（$S_2, S_3$）和冗余且导致虚假唤醒的信号（$S_5, S_6$）。这个信号集合是完全错误的。\n  - **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了理论逻辑之后，我们如何能确信一个并发程序的实现是正确的呢？本练习  介绍了一种强大的技术：确定性模拟。通过在一个单线程模拟器中对多线程环境的非确定性行为进行建模，我们能够可复现地测试各种复杂的执行路径。你将亲手构建一个模拟器，故意引入一个常见的同步错误，并设计系统不变量（断言）来自动捕捉这个bug，从而在并发程序的验证与调试方面获得宝贵的实践经验。",
            "id": "3659295",
            "problem": "要求您设计并分析一个基于管程（monitor）的哲学家就餐问题解决方案的小型确定性模拟器，其明确目标是使用断言来检测一类特定的同步错误。目标概念是这样一种管程解决方案：它使用单个互斥管程和一组针对每个哲学家的条件变量数组，以确保正确且无死锁的同步。您将从第一性原理（管程语义和不变量）出发进行推理，并对这些语义进行离散事件、单线程的模拟编码，从而使行为完全确定，并可在独立程序中进行测试。\n\n您必须使用的基本依据包括以下来自经典操作系统的经过充分测试的定义和事实：\n- 管程为其方法强制执行互斥；任何时候最多只有一个线程在管程内部执行。\n- 条件变量支持 wait 和 signal 两个操作，用于根据共享状态的谓词来挂起和恢复线程。\n- 对于有 $N$ 个哲学家的哲学家就餐问题，一个安全性不变量是：任何两个相邻的哲学家不能同时进餐。\n- 标准的基于管程的解决方案维护一个状态数组 $\\text{state}[i] \\in \\{\\text{THINKING}, \\text{HUNGRY}, \\text{EATING}\\}$ 和为每个哲学家 $i$ 设置的条件变量 $\\text{self}[i]$。存在两个管程方法：$\\text{pickup}(i)$ 请求叉子，$\\text{putdown}(i)$ 释放叉子。一个辅助函数 $\\text{test}(i)$ 检查哲学家 $i$ 在给定其邻居状态的情况下是否可以进餐。\n\n您的模拟器不应创建线程。相反，它必须在一个确定性的方法调用调度下，通过离散步骤来模拟管程操作和条件变量的效果。请使用以下精确模型：\n- 哲学家索引为 $i \\in \\{0,1,\\dots,N-1\\}$。令 $\\ell(i) = (i-1) \\bmod N$ 且 $r(i) = (i+1) \\bmod N$。\n- 管程状态由数组 $\\text{state}[i] \\in \\{0,1,2\\}$（编码 THINKING ($0$)、HUNGRY ($1$) 和 EATING ($2$)）和 $\\text{waiting}[i] \\in \\{\\text{false}, \\text{true}\\}$（指示哲学家 $i$ 是否在模拟的等待中被挂起）组成。\n- 模拟的方法定义如下：\n  - $\\text{pickup}(i)$:\n    1. 设置 $\\text{state}[i] \\leftarrow 1$。\n    2. 调用 $\\text{test}(i)$。\n    3. 如果 $\\text{state}[i] \\neq 2$，则设置 $\\text{waiting}[i] \\leftarrow \\text{true}$；否则立即返回。\n  - $\\text{putdown}(i)$:\n    1. 要求 $\\text{state}[i] = 2$；然后设置 $\\text{state}[i] \\leftarrow 0$。\n    2. 调用 $\\text{test}(\\ell(i))$，然后调用 $\\text{test}(r(i))$。\n  - $\\text{test}(i)$:\n    1. 如果 $\\text{state}[i] = 1$ 且 $\\text{state}[\\ell(i)] \\neq 2$ 且 $\\text{state}[r(i)] \\neq 2$，则设置 $\\text{state}[i] \\leftarrow 2$ 并向某个条件变量索引 $k$ 发出一个模拟信号。\n    2. 否则，不执行任何操作。\n- 模拟的信号传递通过清除一个等待标志来建模：当向索引 $k$ 发出信号时，如果 $\\text{waiting}[k]$ 为 $\\text{true}$，则设置 $\\text{waiting}[k] \\leftarrow \\text{false}$，否则不执行任何操作。\n\n引入一个错误参数 $b \\in \\{0,1\\}$，它控制当哲学家 $i$ 进餐的前提条件满足时，在 $\\text{test}(i)$ 中如何选择索引 $k$：\n- 如果 $b=0$（无错误），则 $k \\leftarrow i$（向正确的、针对该哲学家的条件变量发信号）。\n- 如果 $b=1$（注入错误），则 $k \\leftarrow r(i)$（向错误的条件变量发信号：向右邻居的条件变量发信号，而不是哲学家 $i$ 自己的）。\n\n在每次模拟的管程方法返回后，您必须设计并检查以下断言：\n- 安全性不变量：对所有 $i$，$\\lnot(\\text{state}[i]=2 \\wedge \\text{state}[r(i)]=2)$。\n- 唤醒-安全性不变量：对所有 $i$，$\\lnot(\\text{state}[i]=2 \\wedge \\text{waiting}[i]=\\text{true})$。\n\n其背后的直觉是，第一个不变量编码了哲学家就餐问题的核心安全性，而第二个不变量编码了正确的条件发信语义：任何哲学家都不能在仍被标记为等待的同时处于 EATING 状态。\n\n您的程序必须：\n- 精确地实现上述模拟器。\n- 运行一个固定的调度测试套件。一个调度是指在指定的哲学家索引上，形如 $\\text{pickup}(i)$ 或 $\\text{putdown}(i)$ 的管程方法调用的有限序列。每个调度都从所有哲学家都处于 THINKING 且不等待的初始状态开始执行。\n- 对于每个调度，返回一个布尔结果，指示在该调度的整个执行过程中是否所有断言都成立。\n\n测试套件：\n- 情况 A (理想路径，无错误): $N=5$, $b=0$, 调度 $\\big[\\text{pickup}(0), \\text{pickup}(1), \\text{pickup}(4), \\text{putdown}(0), \\text{putdown}(4), \\text{putdown}(1)\\big]$。\n- 情况 B (错误在启用邻居时触发): $N=5$, $b=1$, 调度 $\\big[\\text{pickup}(0), \\text{pickup}(1), \\text{pickup}(4), \\text{putdown}(0), \\text{putdown}(4), \\text{putdown}(1)\\big]$。\n- 情况 C ($N=2$ 的边界情况，错误触发): $N=2$, $b=1$, 调度 $\\big[\\text{pickup}(0), \\text{pickup}(1), \\text{putdown}(0)\\big]$。\n- 情况 D (错误存在但未被触发): $N=5$, $b=1$, 调度 $\\big[\\text{pickup}(0), \\text{putdown}(0)\\big]$。\n\n答案规范：\n- 对于每种情况，如果所有断言在整个调度期间都成立，程序必须输出 $1$，否则输出 $0$。\n- 最终输出格式必须是单行，包含一个用方括号括起来的逗号分隔的结果列表，例如 $\\big[1,0,1\\big]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[1,0,0,1]”）。此问题不涉及物理单位、角度或百分比；所有输出都是编码为整数的布尔值。",
            "solution": "该问题要求设计并实现一个用于哲学家就餐问题基于管程解决方案的确定性单线程模拟器。该模拟器的目的是使用断言来验证正确性属性，特别是检测与条件变量信号发送不正确相关的错误。\n\n### 基于原理的设计和模拟模型\n\n问题的核心在于将管程和条件变量的抽象语义转化为一个具体的、确定性的算法。在真实的多线程环境中，调度器的行为会引入不确定性。通过创建一个单线程的离散事件模拟，我们可以确定性地分析特定操作序列的逻辑后果。\n\n**1. 状态表示**\n\n系统的状态（通常在管程内部管理）由两个数组表示，每个数组的大小均为 $N$（对应 $N$ 个哲学家）：\n-   `state[i]`：一个整数数组，存储哲学家 $i$ 的状态。我们使用以下映射：$0$ 表示 THINKING，$1$ 表示 HUNGRY，$2$ 表示 EATING。\n-   `waiting[i]`：一个布尔数组（表示为整数 $0$ 或 $1$），指示哲学家 $i$ 是否在某个条件变量上被挂起。`waiting[i] = 1` 意味着哲学家 $i$ 在管程内被阻塞，等待某个条件变为真。\n\n哲学家的索引是循环的，因此哲学家 $i$ 的左邻居和右邻居分别由 $\\ell(i) = (i - 1 + N) \\pmod{N}$ 和 $r(i) = (i + 1) \\pmod{N}$ 给出。\n\n**2. 管程操作的模拟**\n\n管程的同步方法 (`pickup`, `putdown`) 和内部辅助例程 (`test`) 被建模为操作此共享状态的函数。由于模拟是单线程的，互斥是隐式的；在任何给定时间只有一个函数在操作状态。\n\n-   **`test(i)`**：这是检查一个饥饿的哲学家是否可以开始进餐的核心逻辑。条件是哲学家 $i$ 必须是 HUNGRY (`state[i] = 1`)，并且它的两个邻居都不能是 EATING (`state[\\ell(i)] \\neq 2` 且 `state[r(i)] \\neq 2`)。如果满足此条件，`state[i]` 被设置为 EATING ($2$)。该函数还封装了信号发送机制。\n-   **条件变量信号发送 (`signal`)**：对条件变量的 `signal` 操作通过针对一个特定的等待中的哲学家进行模拟。当 `test(i)` 确定哲学家 $i$ 可以进餐时，它应该向哲学家 $i$ 正在等待的条件变量发送信号。在我们的模型中，这是 `self[i]`。向哲学家 $k$ 发送一个 `signal` 被建模为：如果 `waiting[k]` 为真，则将其设置为假。这代表了被阻塞哲学家的“唤醒”。\n-   **`pickup(i)`**：这模拟了哲学家 $i$ 试图获取叉子的过程。它首先将其状态设置为 HUNGRY (`state[i] = 1`)，然后调用 `test(i)` 查看是否可以立即进餐。如果 `test(i)` 并未使其进入 EATING 状态，该哲学家必须阻塞。这通过设置 `waiting[i] = 1` 来建模。\n-   **`putdown(i)`**：这模拟了哲学家 $i$ 释放其叉子的过程。它将其状态设置回 THINKING (`state[i] = 0`)。这个动作可能会使其饥饿的邻居能够进餐。因此，它调用 `test(\\ell(i))` 和 `test(r(i))` 来检查任一邻居现在是否可以继续。\n\n**3. 错误注入**\n\n为了测试系统的稳健性和我们断言的有效性，通过一个参数 $b \\in \\{0, 1\\}$ 引入了一个特定的错误。该错误针对 `test(i)` 函数内的信号发送逻辑。\n-   如果 $b=0$（正确行为），当哲学家 $i$ 可以进餐时，信号被发送给哲学家 $i$（即 `signal(i)`）。如果哲学家 $i$ 正在等待，这会正确地唤醒它。\n-   如果 $b=1$（错误行为），信号被发送给右邻居，即哲学家 $r(i)$（即 `signal(r(i))`）。这模拟了并发编程中常见的差一错误或指针错误。\n\n**4. 基于断言的验证**\n\n在每次模拟操作（`pickup` 或 `putdown`）之后，我们检查两个不变量以确保系统状态保持正确。在任何时候，任一断言的失败都会使该调度的执行无效。\n\n1.  **安全性不变量**：$\\forall i \\in \\{0, \\dots, N-1\\}, \\lnot(\\text{state}[i] = 2 \\wedge \\text{state}[r(i)] = 2)$。这是哲学家就餐问题的基本安全属性：任何两个相邻的哲学家不能同时进餐。\n2.  **唤醒-安全性不变量**：$\\forall i \\in \\{0, \\dots, N-1\\}, \\lnot(\\text{state}[i] = 2 \\wedge \\text{waiting}[i] = \\text{true})$。这是一个新颖的不变量，旨在测试条件变量机制本身的正确性。它断言一个哲学家不能在处于 EATING 状态的同时也被标记为正在等待。从逻辑上讲，一个正在进餐的哲学家已经成功获取了必要的资源，不应该被阻塞。违反此不变量表明，一个哲学家状态被更改为 EATING，但相应的 `signal` 操作未能清除其 `waiting` 标志，这正是我们旨在检测的错误。\n\n**5. 测试用例分析**\n\n让我们追踪情况 B：$N=5$, $b=1$, 调度 `[pickup(0), pickup(1), pickup(4), putdown(0), ...]`。\n-   最初，所有状态都为 $0$ (THINKING)，`waiting` 标志都为假。\n-   `pickup(0)`：`test(0)` 成功。`state[0]` 变为 $2$ (EATING)。由于 $b=1$，信号被发送给哲学家 $r(0)=1$，但 `waiting[1]` 为假，因此这是一个空操作。所有断言都成立。\n-   `pickup(1)`：`test(1)` 失败，因为邻居 $0$ 正在进餐。`state[1]` 为 $1$ (HUNGRY)，`waiting[1]` 被设为真。所有断言都成立。\n-   `pickup(4)`：`test(4)` 失败，因为邻居 $0$ 正在进餐。`state[4]` 为 $1$ (HUNGRY)，`waiting[4]` 被设为真。所有断言都成立。\n-   `putdown(0)`：`state[0]` 变为 $0$ (THINKING)。这会调用 `test(l(0)=4)` 和 `test(r(0)=1)`。\n    -   `test(4)`：现在成功。`state[4]` 变为 $2$ (EATING)。错误的信号被发送给 $r(4)=0$。`waiting[0]` 为假，因此这是一个空操作。关键的是，信号*没有*发给哲学家 $4$，所以 `waiting[4]` 保持为真。\n    -   `test(1)`：也成功。`state[1]` 变为 $2$ (EATING)。错误的信号被发送给 $r(1)=2$。`waiting[2]` 为假，这是一个空操作。`waiting[1]` 保持为真。\n-   在 `putdown(0)` 返回后，检查断言。现在的状态是 `state=[0,2,0,0,2]` 和 `waiting=[0,1,0,0,1]`。\n    -   检查唤醒-安全性不变量 $\\lnot(\\text{state}[i]=2 \\wedge \\text{waiting}[i]=\\text{true})$。\n    -   对于 $i=1$：`state[1]=2` 且 `waiting[1]=1`。条件为真，因此不变量被违反。\n    -   对于 $i=4$：`state[4]=2` 且 `waiting[4]=1`。条件为真，因此不变量被违反。\n情况 B 的模拟正确地返回 $0$（失败）。这证明了所选断言在检测特定同步错误方面的有效性。",
            "answer": "$$\\boxed{[1,0,0,1]}$$"
        },
        {
            "introduction": "一个正确的解决方案是基础，而一个高性能的方案则是更高的追求。本练习  将我们的关注点从正确性转向性能分析。通过运用系统建模的基本原理，你将推导出一个描述整个哲学家就餐系统吞吐量的数学表达式。这项实践将向你展示同步约束（例如同时就餐的最大人数）如何转变为性能瓶颈，并帮助你学习量化系统的服务能力，从而将抽象的管程解决方案与具体的性能指标联系起来。",
            "id": "3659316",
            "problem": "考虑一个经典的哲学家就餐问题系统，其中有 $N$ 位哲学家围成一圈，他们之间有 $N$ 把叉子，每对相邻的哲学家之间有一把。每位哲学家确定性地在思考（时长 $\\tau$）和进餐（时长 $\\sigma$）两种状态之间交替，并无限重复此循环。一个监视器（monitor）通过条件变量实现互斥和协调，以确保：\n\n- 没有两个相邻的哲学家同时进餐，即如果哲学家 $i$ 在进餐，则哲学家 $i-1$ 和 $i+1$（索引对 $N$ 取模）不在进餐。\n- 最多有 $M$ 位哲学家同时进餐，其中 $M \\le \\lfloor N/2 \\rfloor$。\n- 请求进餐的哲学家会在监视器中阻塞，直到其两边的叉子都可用且未达到全局并发进餐者上限；进餐完成后，监视器会释放叉子并通知等待的哲学家，以确保系统前进并避免饥饿。\n\n假设监视器操作和信号通知的开销可忽略不计，监视器中采用公平的调度策略以确保被阻塞的哲学家最终会被唤醒，并且系统能达到一个稳定状态。令 $\\Lambda(N,M,\\tau,\\sigma)$ 表示系统的长期吞吐量，单位为“餐/秒”（即进餐阶段完成的时间平均速率）。\n\n从互斥和“服务时间守恒”的第一性原理出发，推导出一个 $\\Lambda(N,M,\\tau,\\sigma)$ 的闭式解析表达式。该表达式应为一个单一的表达式，并能隐含地描述上限 $M$ 何时成为瓶颈及其对吞吐量的影响。最终答案以“餐/秒”为单位表示，不要对结果进行四舍五入。你的推导必须从监视器强制执行的基于不变量的约束以及以下事实开始：每个完成的进餐阶段恰好消耗 $\\sigma$ 单位的服务时间，而在没有阻塞的情况下，每个哲学家的周期时长为 $\\tau+\\sigma$。请提供 $\\Lambda(N,M,\\tau,\\sigma)$ 的最终表达式。",
            "solution": "该问题要求推导哲学家就餐问题系统的长期吞吐量 $\\Lambda(N,M,\\tau,\\sigma)$ 的闭式解析表达式。推导将从第一性原理出发，从两个角度考虑系统：需求服务的哲学家和提供服务的资源。实际吞吐量将是这两个角度决定的速率中的较小值，这是一个经典的瓶颈分析。\n\n设 $N$ 为哲学家数量，$\\tau$ 为思考时间，$\\sigma$ 为进餐时间。系统受到约束，即没有两个相邻的哲学家同时进餐，并且在任何时刻最多有 $M$ 位哲学家进餐，其中 $M \\le \\lfloor N/2 \\rfloor$。我们假设系统达到一个稳定的、对称的稳态，其中所有哲学家表现出相同的平均行为。\n\n首先，我们从单个哲学家的角度分析系统。在一个完整的周期中，一个哲学家花费 $\\tau$ 的时间思考，花费 $W_{wait}$ 的时间等待资源（叉子和进餐位），以及花费 $\\sigma$ 的时间进餐。因此，单个哲学家的总平均周期时间为 $T_{cycle} = \\tau + \\sigma + W_{wait}$。单个哲学家的吞吐量，即他们完成进餐的速率，是 $1 / T_{cycle}$。由于有 $N$ 位行为相同的哲学家，系统的总吞吐量 $\\Lambda$ 是单个哲学家吞吐量的 $N$ 倍：\n$$\n\\Lambda = \\frac{N}{\\tau + \\sigma + W_{wait}}\n$$\n这个方程将系统吞吐量与平均等待时间联系起来，而平均等待时间目前是未知的。\n\n其次，我们从资源的角度分析系统，这里的资源是“进餐位”。设 $E$ 为稳态下同时进餐的哲学家的平均数量。这 $E$ 位哲学家中的每一位都在 $\\sigma$ 秒内完成进餐。根据利用率法则（Utilization Law，利特尔法则（Little's Law）的直接推论），一个系统的吞吐量等于繁忙服务器的平均数量除以平均服务时间。在这里，“服务器”是正在进餐的哲学家，“服务时间”是 $\\sigma$。因此，总吞吐量 $\\Lambda$ 由下式给出：\n$$\n\\Lambda = \\frac{E}{\\sigma}\n$$\n这为 $\\Lambda$ 提供了第二个表达式，将其与平均并发进餐者数量 $E$ 联系起来。\n\n为了找到实际吞吐量，我们必须确定系统的瓶颈。吞吐量要么受限于哲学家请求进餐的速率，要么受限于系统服务这些请求的速率。\n\n如果资源无限，可能的最大吞吐量（我们称之为需求驱动吞吐量 $\\Lambda_{demand}$）发生在没有竞争因而没有等待时间（$W_{wait} = 0$）的情况下。在这种情况下，每个哲学家的周期时间就是 $\\tau + \\sigma$。吞吐量将是：\n$$\n\\Lambda_{demand} = \\frac{N}{\\tau + \\sigma}\n$$\n\n资源可以维持的最大可能吞吐量（我们称之为供给驱动吞吐量 $\\Lambda_{supply}$）由并发进餐的约束决定。问题陈述了两个约束：没有两个相邻的哲学家同时进餐，以及最多有 $M$ 位哲学家同时进餐。第一个约束意味着最多有 $\\lfloor N/2 \\rfloor$ 个并发进餐者。第二个约束是一个明确的上限 $M$。由于问题规定 $M \\le \\lfloor N/2 \\rfloor$，所以更严格的约束总是全局上限 $M$。因此，进餐哲学家的平均数量 $E$ 不能超过 $M$。当系统以其最大容量运行时，它达到饱和状态，这意味着 $E$ 达到其最大可能值 $E_{max} = M$。那么，供给方能支持的最大吞吐量是：\n$$\n\\Lambda_{supply} = \\frac{E_{max}}{\\sigma} = \\frac{M}{\\sigma}\n$$\n\n系统的实际稳态吞吐量 $\\Lambda$ 不能超过需求速率或供给速率。因此，吞吐量是这两个值的最小值：\n$$\n\\Lambda(N,M,\\tau,\\sigma) = \\min(\\Lambda_{demand}, \\Lambda_{supply})\n$$\n代入 $\\Lambda_{demand}$ 和 $\\Lambda_{supply}$ 的表达式，我们得到最终的闭式表达式：\n$$\n\\Lambda(N,M,\\tau,\\sigma) = \\min\\left(\\frac{N}{\\tau + \\sigma}, \\frac{M}{\\sigma}\\right)\n$$\n这个单一表达式隐含地描述了系统的两种运行机制。\n1. 如果 $\\frac{N}{\\tau + \\sigma} \\le \\frac{M}{\\sigma}$，则系统受需求限制（或哲学家限制）。吞吐量为 $\\Lambda = \\frac{N}{\\tau + \\sigma}$，资源上限 $M$ 不是约束瓶颈。这个不等式等价于 $\\frac{N\\sigma}{\\tau + \\sigma} \\le M$，这意味着哲学家们需求的平均进餐者数量在系统容量之内。在这种情况下，$W_{wait} = 0$。\n\n2. 如果 $\\frac{N}{\\tau + \\sigma} > \\frac{M}{\\sigma}$，则系统受供给限制（或资源限制）。吞吐量的上限为 $\\Lambda = \\frac{M}{\\sigma}$。在这种机制下，存在竞争，哲学家会经历非零的平均等待时间，$W_{wait} > 0$。上限 $M$ 是约束瓶颈。\n表达式 $\\min\\left(\\frac{N}{\\tau + \\sigma}, \\frac{M}{\\sigma}\\right)$ 巧妙地涵盖了这两种情况。",
            "answer": "$$\\boxed{\\min\\left(\\frac{N}{\\tau + \\sigma}, \\frac{M}{\\sigma}\\right)}$$"
        }
    ]
}