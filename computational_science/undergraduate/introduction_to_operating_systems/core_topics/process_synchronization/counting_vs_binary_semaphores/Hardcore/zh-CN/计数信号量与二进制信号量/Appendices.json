{
    "hands_on_practices": [
        {
            "introduction": "选择信号量不仅关乎逻辑正确性，也深刻影响系统性能。本练习将引导你通过一个基于排队论的假设场景，来量化分析在管理一个拥有多个资源的资源池时，使用二进制信号量与计数信号量对系统利用率的不同影响。通过这个练习，你将深入理解为何二进制信号量会成为多资源系统的性能瓶颈，并掌握衡量系统负载与稳定性的关键概念。",
            "id": "3629427",
            "problem": "考虑一个有 $n$ 个相同、独立资源的系统，每个资源保护对代码临界区的一个入口。作业以速率 $\\lambda$ 的泊松过程到达系统，每个作业需要独占访问一个资源，其服务时间服从速率为 $\\mu$ 的指数分布（因此平均服务时间为 $1/\\mu$）。系统使用信号量来控制并发访问：\n- 一个具有 $n$ 个初始许可的计数信号量允许多达 $n$ 个作业并发执行。\n- 一个二元信号量即使存在 $n$ 个资源，也最多只允许一个作业执行；假设它用于保护整个资源池，从而强制实现单并发。\n\n当没有可用许可时到达的作业将在一个无限的先到先服务（FCFS）队列中等待，直到有许可变为可用。没有抢占。将资源池的稳态利用率 $U$ 定义为被占用的 $n$ 个资源的长期平均比例，即长期平均被占用的许可数除以 $n$。\n\n从核心定义以及关于生灭过程和泊松/指数服务系统的成熟理论出发，推导：\n1. 在计数信号量下，系统的稳态利用率 $U_{\\mathrm{count}}(\\lambda,\\mu,n)$，假设系统是稳定的，即 $\\lambda  n\\mu$。\n2. 在二元信号量下，系统的稳态利用率 $U_{\\mathrm{binary}}(\\lambda,\\mu,n)$，假设系统是稳定的，即 $\\lambda  \\mu$。\n3. 在二元信号量下可达到的最大稳态利用率与在计数信号量下可达到的最大稳态利用率之比 $R$，两者均在其各自的稳定性范围内取值。\n\n将你的最终答案表示为一个单行矩阵，按顺序包含 $\\left(U_{\\mathrm{count}},\\,U_{\\mathrm{binary}},\\,R\\right)$。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是基于排队论的一个合理、适定的问题。我们将逐步推导所需的量。\n\n该问题要求计算在两种不同信号量控制方案下与资源利用率相关的三个量。让我们分别分析每种情况，然后计算所需的比率。整个过程中的关键概念是稳态利用率 $U$ 的定义，即被占用资源的长期平均数量（我们表示为 $L_s$）除以资源总数 $n$。\n$$U = \\frac{L_s}{n}$$\n排队论的一个基本结果，利特尔法则（Little's Law），应用于系统的服务部分，指出服务中的平均作业数 $L_s$ 等于进入服务的作业的有效到达率 $\\lambda_{\\text{eff}}$ 乘以作业在服务中花费的平均时间 $W_s$。\n$$L_s = \\lambda_{\\text{eff}} W_s$$\n在一个具有无限队列的稳定系统中，没有作业丢失，因此服务设施的有效到达率等于系统的总到达率，即 $\\lambda_{\\text{eff}} = \\lambda$。问题陈述服务时间服从速率为 $\\mu$ 的指数分布，因此平均服务时间为 $W_s = 1/\\mu$。\n将这些代入 $L_s$ 的公式，我们得到平均被占用的资源数：\n$$L_s = \\lambda \\cdot \\frac{1}{\\mu} = \\frac{\\lambda}{\\mu}$$\n这个关于 $L_s$ 的结果是通用的，并且只要系统稳定，对任何数量的服务器都成立。两种信号量方案之间的差异将通过它们的稳定性条件以及我们如何将 $L_s$ 与总资源池 $n$ 关联起来体现出来。\n\n1.  **计数信号量下的稳态利用率, $U_{\\mathrm{count}}$**\n\n具有 $n$ 个初始许可的计数信号量的系统是一个经典的 M/M/n 排队模型。在这里，到达是速率为 $\\lambda$ 的泊松过程，有 $n$ 个并行的相同服务器，每个服务器的指数服务速率为 $\\mu$。只要 $n$ 个资源中至少有一个是空闲的，作业就可以得到服务。\n\n被占用的资源（服务器）的平均数量是 $L_s = \\frac{\\lambda}{\\mu}$。资源池的利用率 $U_{\\mathrm{count}}$ 是这个平均数量除以资源总数 $n$。\n$$U_{\\mathrm{count}}(\\lambda, \\mu, n) = \\frac{L_s}{n} = \\frac{\\lambda / \\mu}{n} = \\frac{\\lambda}{n\\mu}$$\n如题目所给，M/M/n 队列的稳定性条件是 $\\lambda  n\\mu$。这可以重写为 $\\frac{\\lambda}{n\\mu}  1$。这证实了我们推导出的利用率（也称为流量强度 $\\rho$）必须小于 $1$ 才能使系统稳定。\n\n2.  **二元信号量下的稳态利用率, $U_{\\mathrm{binary}}$**\n\n二元信号量最多只允许一个作业并发执行，即使有 $n$ 个物理资源可用。这个约束有效地将系统转变为一个 M/M/1 队列，其中只有一个“逻辑”服务器（即单个信号量许可）。\n\n必须计算被占用的物理资源的平均数量 $L_s$。在这个 M/M/1 系统中，在任何给定时间，要么没有资源被占用（系统空闲），要么恰好有一个资源被占用（一个作业正在执行）。一个资源被占用的概率等于 M/M/1 模型中单个逻辑服务器的利用率。M/M/1 服务器的利用率由 $\\rho_1 = \\frac{\\lambda}{\\mu}$ 给出。\n因此，平均被占用的资源数为：\n$$L_s = (1 \\times \\text{Prob(system busy)}) + (0 \\times \\text{Prob(system idle)}) = 1 \\cdot \\rho_1 + 0 \\cdot (1-\\rho_1) = \\rho_1 = \\frac{\\lambda}{\\mu}$$\n这个结果与前面通过利特尔法则得到的结果相同。可用资源的总数仍然是 $n$。因此，资源池的利用率 $U_{\\mathrm{binary}}$ 是平均繁忙资源数除以 $n$：\n$$U_{\\mathrm{binary}}(\\lambda, \\mu, n) = \\frac{L_s}{n} = \\frac{\\lambda / \\mu}{n} = \\frac{\\lambda}{n\\mu}$$\n如题目所给，这个 M/M/1 系统的稳定性条件是 $\\lambda  \\mu$。这可以使用单服务器利用率重写为 $\\rho_1 = \\frac{\\lambda}{\\mu}  1$。\n\n值得注意的是，$U_{\\mathrm{count}}$ 和 $U_{\\mathrm{binary}}$ 的表达式是相同的。系统性能的差异来自于它们不同的稳定性边界。\n\n3.  **最大可达利用率之比, $R$**\n\n我们需要求出比率 $R = \\frac{\\max(U_{\\mathrm{binary}})}{\\max(U_{\\mathrm{count}})}$。每个系统的最大可达利用率是通过在其各自的稳定性范围内取利用率函数的上确界来找到的。\n\n对于计数信号量（$M/M/n$ 系统）：\n利用率为 $U_{\\mathrm{count}} = \\frac{\\lambda}{n\\mu}$，稳定性条件为 $\\lambda  n\\mu$。\n最大可达利用率是当到达率接近其上界时的极限：\n$$\\max(U_{\\mathrm{count}}) = \\sup_{\\lambda  n\\mu} \\left( \\frac{\\lambda}{n\\mu} \\right) = \\lim_{\\lambda \\to (n\\mu)^{-}} \\frac{\\lambda}{n\\mu} = \\frac{n\\mu}{n\\mu} = 1$$\n这意味着当负载接近系统的总容量时，资源在极限情况下可以被完全利用。\n\n对于二元信号量（有效的 $M/M/1$ 系统）：\n利用率为 $U_{\\mathrm{binary}} = \\frac{\\lambda}{n\\mu}$，稳定性条件为 $\\lambda  \\mu$。\n最大可达利用率是当到达率接近其（更严格的）上界时的极限：\n$$\\max(U_{\\mathrm{binary}}) = \\sup_{\\lambda  \\mu} \\left( \\frac{\\lambda}{n\\mu} \\right) = \\lim_{\\lambda \\to \\mu^{-}} \\frac{\\lambda}{n\\mu} = \\frac{\\mu}{n\\mu} = \\frac{1}{n}$$\n这意味着因为一次只能使用一个资源，所以整个 $n$ 个资源池的最大利用率被限制在 $\\frac{1}{n}$，这种情况发生在那个唯一可用的资源被加载到其全部容量时。\n\n最后，我们计算比率 $R$：\n$$R = \\frac{\\max(U_{\\mathrm{binary}})}{\\max(U_{\\mathrm{count}})} = \\frac{1/n}{1} = \\frac{1}{n}$$\n\n因此，所求的三个量是 $U_{\\mathrm{count}} = \\frac{\\lambda}{n\\mu}$，$U_{\\mathrm{binary}} = \\frac{\\lambda}{n\\mu}$，和 $R = \\frac{1}{n}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\lambda}{n\\mu}  \\frac{\\lambda}{n\\mu}  \\frac{1}{n} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在性能分析之后，我们转向并发编程的核心——逻辑正确性，特别是如何避免死锁。本练习设计了一个思想实验，探讨了当一个线程尝试重复获取同一个信号量时会发生什么。通过对比二进制信号量和计数信号量在该场景下的不同表现，你将直观地看到为什么对非递归的二进制信号量的二次等待会立即导致死锁，以及计数信号量虽然更灵活，但在特定调度下同样存在死锁的风险。",
            "id": "3629421",
            "problem": "考虑一个操作系统（OS），其标准信号量实现满足以下核心定义：一个信号量维持一个整数状态 $s$；一个 $wait$ 操作是原子的，当 $s > 0$ 时它将 $s$ 减一，当 $s = 0$ 时它将阻塞调用者；一个 $signal$ 操作将 $s$ 加一，并可能唤醒一个被阻塞的调用者。二进制信号量将 $s$ 限制在 $s \\in \\{0, 1\\}$，而计数信号量允许 $s \\in \\mathbb{N}$（非负整数集）。这些操作不跟踪所有权且是非递归的，这意味着一个线程在尝试多次获取时，不能依赖其身份来绕过 $wait$ 阻塞。\n\n设计并分析以下两个实验，使用 $n$ 个线程，标记为 $T_1, T_2, \\dots, T_n$，其中每个线程执行序列 $wait$；$wait$；$signal$；$signal$，且在两个 $wait$ 操作之间没有穿插的 $signal$ 操作：\n\n- 实验 $1$：一个二进制信号量 $B$，初始状态为 $s_B = 1$。每个线程 $T_i$ 执行 $wait(B)$；$wait(B)$；(一些工作)；$signal(B)$；$signal(B)$。\n- 实验 $2$：一个计数信号量 $C$，初始状态为 $s_C = n$。每个线程 $T_i$ 执行 $wait(C)$；$wait(C)$；(一些工作)；$signal(C)$；$signal(C)$。\n\n假设调度器可以任意交错操作，但保证 $wait$ 和 $signal$ 的原子性。仅使用关于 $wait$/$signal$ 语义的第一性原理以及死锁的必要条件（互斥、持有并等待、无抢占和循环等待），确定哪些关于死锁风险及其预防的陈述是正确的。\n\n选择所有适用的选项：\n\nA. 在实验 $1$ 中，必然会发生死锁：第一个执行其第二个 $wait(B)$ 的线程在持有一个单元时被阻塞，没有线程能到达 $signal(B)$。\n\nB. 在实验 $2$ 中，死锁不会发生，因为初始时 $s_C = n$ 为每个线程提供了一个单元，每个线程最终都将在没有任何 $signal(C)$ 先发生的情况下获得其第二个单元。\n\nC. 在实验 $2$ 中，如果 $n$ 个线程中的每一个都恰好获得一个单元，然后在第二次 $wait(C)$ 时阻塞，就可能发生死锁；要排除在这种每个线程需要 $2$ 个单元的模式下发生死锁的可能性，初始计数必须至少为 $n + 1$。\n\nD. 为了避免实验 $2$ 中的死锁，计数信号量必须初始化为 $2n$ 个单元；任何更小的初始计数都会使死锁不可避免。",
            "solution": "首先验证问题陈述，以确保其科学上合理、问题提出得当且客观。\n\n### 步骤 1：提取已知条件\n- **信号量定义**：一个整数状态 $s$；一个原子的 `wait` 操作，如果 $s > 0$ 则递减 $s$，如果 $s = 0$ 则阻塞调用者；一个原子的 `signal` 操作，递增 $s$。\n- **信号量类型**：二进制信号量限制 $s \\in \\{0, 1\\}$。计数信号量允许 $s \\in \\mathbb{N}$（非负整数）。\n- **信号量属性**：操作是非递归的，意味着持有信号量单元的线程在信号量计数为 $0$ 时，无法执行后续的 `wait` 操作而不被阻塞。\n- **系统设置**：$n$ 个线程，标记为 $T_1, T_2, \\dots, T_n$。\n- **线程行为**：每个线程 $T_i$ 执行序列 `wait`；`wait`；`(一些工作)`；`signal`；`signal`。\n- **实验 1**：一个二进制信号量 $B$，初始状态为 $s_B = 1$。每个线程执行 `wait(B)`；`wait(B)`；`...`；`signal(B)`；`signal(B)`。\n- **实验 2**：一个计数信号量 $C$，初始状态为 $s_C = n$。每个线程执行 `wait(C)`；`wait(C)`；`...`；`signal(C)`；`signal(C)`。\n- **调度器**：调度器可以任意交错线程操作，但保证 `wait` 和 `signal` 的原子性。\n- **任务**：基于第一性原理，确定哪些关于死锁的陈述是正确的。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题基于计算机科学和操作系统理论中的标准、明确定义的概​​念，即计数和二进制信号量、线程和死锁。为信号量操作提供的定义是标准的。所描述的场景是抽象的，但代表了并发编程中有效且可分析的情况。问题是自包含的，提供了所有必要的初始条件和行为规则。语言精确且客观。不存在科学或逻辑上的矛盾，问题提出得当，可以对死锁条件进行确定性分析。\n\n### 步骤 3：结论和行动\n问题陈述是**有效的**。可以进行全面分析。\n\n### 推导与分析\n\n**实验 1 分析：二进制信号量**\n\n在这个实验中，我们使用一个初始状态为 $s_B = 1$ 的二进制信号量 $B$。有 $n$ 个线程，每个线程都试图连续执行两次 `wait(B)`。\n\n考虑任意一个首先被调度的线程，比如 $T_1$。\n1.  $T_1$ 执行其第一个 `wait(B)`。由于 $s_B = 1 > 0$，操作成功。信号量的状态递减，因此 $s_B$ 变为 $0$。$T_1$ 现在名义上持有着信号量。\n2.  接下来，$T_1$ 试图执行其第二个 `wait(B)`。此时，$s_B = 0$。根据 `wait` 操作的定义，$T_1$ 将被阻塞，因为它必须等待 $s_B$ 变为正数。\n3.  问题陈述指出信号量是非递归的。这意味着即使 $T_1$ 是导致 $s_B$ 变为 $0$ 的线程，它也无法绕过其第二个 `wait(B)` 上的阻塞条件。\n4.  一旦 $T_1$ 被阻塞，它就无法继续执行其 `signal(B)` 调用。$T_1$ 解除阻塞的唯一方法是让另一个线程执行 `signal(B)`。\n5.  考虑任何其他线程 $T_j$（其中 $j \\ne 1$）。如果调度器运行 $T_j$，它将尝试其第一个 `wait(B)`。然而，由于 $s_B$ 已经是 $0$（因为 $T_1$ 的第一个 `wait`），$T_j$ 也将被阻塞。\n6.  这适用于所有 $n$ 个线程。一个线程（$T_1$）在其第二个 `wait(B)` 上被阻塞，所有其他线程将在其第一个 `wait(B)` 上被阻塞。没有任何线程能够到达 `signal(B)` 指令。\n\n这种情况满足了死锁的四个必要条件：\n- **互斥**：二进制信号量确保一次只有一个线程可以持有资源。\n- **持有并等待**：线程 $T_1$ 成功获取了信号量（完成了第一个 `wait`），并在等待再次获取信号量时（在第二个 `wait` 上）被阻塞。\n- **无抢占**：信号量不能被从 $T_1$ 强行夺走；它必须通过 `signal` 操作被释放。\n- **循环等待**：这是一个循环等待的平凡案例，即一个进程正在等待一个它自己持有的资源。$T_1$ 等待一个 `signal(B)`，而这个信号只有在 $T_1$ 自己完成其任务后才能发出，但它无法完成任务，因为它正在等待。\n\n死锁不仅是可能的，而且是只要任何单个线程按顺序执行其两个 `wait(B)` 操作就必然发生的结果。\n\n**实验 2 分析：计数信号量**\n\n在这个实验中，我们使用一个初始状态为 $s_C = n$ 的计数信号量 $C$。有 $n$ 个线程，每个线程都试图执行两次 `wait(C)`。每个线程需要从信号量中获取 $2$ 个单元才能完成工作，然后释放它们。可用单元的总数是 $n$。\n\n让我们分析一个最大化资源竞争的“最坏情况”调度场景：\n1.  调度器交错执行这 $n$ 个线程，使得每个线程都恰好执行一次 `wait(C)` 操作。\n2.  线程 $T_1$ 执行 `wait(C)`。$s_C$ 变为 $n-1$。\n3.  线程 $T_2$ 执行 `wait(C)`。$s_C$ 变为 $n-2$。\n4.  ...\n5.  这个过程一直持续到线程 $T_n$ 执行 `wait(C)`。此时，$s_C$ 变为 $n-n = 0$。\n6.  现在，每个线程都已成功从信号量中获取了一个单元，并准备请求其第二个单元。信号量的计数为 $s_C = 0$。\n7.  让任何一个线程，比如 $T_1$，尝试其第二个 `wait(C)`。由于 $s_C = 0$，$T_1$ 将被阻塞。\n8.  任何其他被调度的线程也会遭遇同样的命运。所有 $n$ 个线程都将尝试其第二个 `wait(C)` 并被阻塞。\n9.  所有 $n$ 个线程现在都处于阻塞状态，每个都在等待 $s_C$ 变为正数。然而，所有线程都在其 `signal(C)` 调用之前被阻塞。没有线程可以继续执行以发出信号，所以 $s_C$ 将永远保持为 $0$。\n\n这是一个典型的死锁。每个线程持有一个资源，并等待另一个资源，但可用资源池已空。所有四个死锁条件都已满足。因此，在实验 2 中，死锁是可能发生的。\n\n为了防止这种死锁，我们可以应用死锁避免的原则。系统有 $n$ 个进程（线程），每个进程最多需要 $k=2$ 个资源（信号量单元）。设 $m$ 为初始资源数（$s_C$）。如果 $m > n(k-1)$，就可以保证避免死锁。\n在我们的例子中，$k=2$，所以条件是 $m > n(2-1)$，简化为 $m > n$。保证避免死锁的最小整数单元数是 $m = n+1$。如果 $s_C$ 初始化为 $n+1$，在最坏的情况下，即 $n$ 个线程每个都拿走一个单元，信号量计数将为 $(n+1) - n = 1$。这会留下一个可用单元，允许一个线程获取其第二个单元，完成其工作，并释放其两个单元，从而打破潜在的死锁。\n\n### 逐项分析\n\n**A. 在实验 1 中，必然会发生死锁：第一个执行其第二个 $wait(B)$ 的线程在持有一个单元时被阻塞，没有线程能到达 $signal(B)$。**\n根据对实验 1 的分析，二进制信号量的非递归性质意味着一个线程试图两次获取它将导致自死锁。第一个 `wait(B)` 将 $s_B$ 设置为 $0$，同一线程的第二个 `wait(B)` 将其阻塞。没有其他线程可以获取该信号量以发出信号。因此，死锁保证会发生。\n\n**结论：正确。**\n\n**B. 在实验 2 中，死锁不会发生，因为 $s_C = n$ 初始为每个线程提供一个单元，每个线程最终都将在没有任何 $signal(C)$ 先发生的情况下获得其第二个单元。**\n根据对实验 2 的分析，如果调度器交错执行线程，使得每个线程都获取信号量的一个单元，则可能发生死锁。在这种情况下，信号量计数变为 $0$，所有线程在尝试获取第二个单元时都会阻塞。对于这种特定的、有效的交错执行方式，“每个线程最终都会获得其第二个单元”的说法是错误的。\n\n**结论：错误。**\n\n**C. 在实验 2 中，如果 $n$ 个线程中的每一个都恰好获得一个单元，然后在第二次 $wait(C)$ 时阻塞，就可能发生死锁；要排除在这种每个线程需要 $2$ 个单元的模式下发生死锁的可能性，初始计数必须至少为 $n + 1$。**\n这个陈述有两部分。第一部分正确地指出了导致实验 2 中死锁的具体事件序列，这与我们的分析相符。第二部分提供了一个防止这种死锁的条件。根据死锁避免原则推导，为了保证在每个线程都拿走 $1$ 个单元（最坏情况）后至少有一个线程可以继续执行，初始单元数必须至少为 $n+1$。这确保了在 $n$ 个单元被拿走后，还剩下 $1$ 个单元，允许一个线程获取其第二个单元并最终释放其资源。该陈述的两个部分都是正确的。\n\n**结论：正确。**\n\n**D. 为了避免实验 2 中的死锁，计数信号量必须初始化为 $2n$ 个单元；任何更小的初始计数都会使死锁不可避免。**\n将信号量初始化为 $s_C=2n$ 是避免死锁的充分条件，因为它提供了足够的单元，让每个线程都能在不阻塞的情况下获取其所需的两个单元。然而，它不是一个必要条件。正如在选项 C 的分析中所确立的，初始计数为 $n+1$ 也足以防止死锁。对于任何 $n>1$，$n+1  2n$。因此，“任何更小的初始计数都会使死锁不可避免”的说法是错误的。例如，如果 $n=5$，计数为 $6$（小于 $2n=10$）就足以避免死锁。\n\n**结论：错误。**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "真实的系统必须能够应对各种异常情况。本练习将挑战你思考一个更高级但非常实际的问题：当一个等待信号量的操作因超时而失败时，应该如何正确处理？这个问题将引导你深入思考资源管理中的“不变量”原则，理解为什么错误的补偿操作（如在超时后调用 `post`）会导致信号量计数的“膨胀”或“泄露”，这些都是并发系统中隐蔽而严重的bug。",
            "id": "3629405",
            "problem": "在一门操作系统（OS）课程中，考虑一个容量为 $C$ 的计数信号量 $S$，它用于控制对一个相同许可证池的访问。计数信号量维护一个非负整数 $count$，表示当前可用的许可证数量。操作 $\\text{wait}(S)$ 原子地检查 $count > 0$ 是否成立；如果成立，它将 $count$ 减 1 并返回成功，否则它将阻塞。操作 $\\text{post}(S)$ 原子地将 $count$ 加 1，并可能唤醒一个等待中的线程。定时等待 $\\text{wait}(S, t)$ 是一个变体，它最多阻塞 $t$ 秒，然后要么返回成功（意味着在某个时刻获取了一个许可证且 $count$ 已被递减），要么返回超时（意味着没有获取许可证且 $count$ 未被递减）。根据定义，容量 $C$ 是恒定的，并且线程持有的许可证数量加上可用的许可证数量绝不能超过 $C$。\n\n现在考虑一个容量为 $C = 2$ 的计数信号量 $S$ 的以下场景。在时间 $0$，两个线程 $X$ 和 $Y$ 调用 $\\text{wait}(S)$ 并都成功，因此 $count = 0$ 且持有者数量为 $2$。第三个线程 $Z$ 调用 $\\text{wait}(S, t)$（其中 $t > 0$）并阻塞。在时间间隔 $[0, t)$ 内没有线程调用 $\\text{post}(S)$，所以在时间 $t$，$Z$ 的调用返回超时，并且 $Z$ 没有获取到许可证。在超时后，$Z$ 立即执行一个取消处理程序。你必须决定 $Z$ 是否应该调用 $\\text{post}(S)$ 来“补偿”其被中止的尝试，并且你必须推断不匹配的 $\\text{wait}$/$\\text{post}$ 调用的后果。然后将其与二元信号量（容量 $C = 1$）进行对比。\n\n仅使用上述核心定义和“可用许可证数量加上持有许可证数量受 $C$ 限制”这一不变量，评估以下论断。选择所有正确的选项。\n\nA. 在一个容量为 $C$ 的计数信号量中，如果一个线程从 $\\text{wait}(S, t)$ 超时而没有获取许可证，那么调用 $\\text{post}(S)$ 进行补偿是错误的，因为它在没有相应获取操作的情况下增加了 $count$，这违反了资源记账原则并造成许可证虚增。\n\nB. 在计数信号量中，如果一个线程在 $\\text{wait}(S, t)$ 成功返回后（因此它持有一个许可证）但在调用 $\\text{post}(S)$ 之前被取消，它必须在其取消处理程序中恰好调用一次 $\\text{post}(S)$，以避免无限期地持有该许可证。\n\nC. 对于二元信号量（容量 $C = 1$），任何超时后的无条件 $\\text{post}(S)$ 调用是无害的，因为信号量计数不能超过 $1$，所以额外的 $\\text{post}(S)$ 调用不会使并发性超出预期的限制。\n\nD. 在实现带超时的计数信号量上的 $\\text{wait}(S, t)$ 时，正确的补偿逻辑是跟踪是否已获取许可证（例如，使用一个仅在成功时设置的布尔标志），并且当且仅当该标志为真时才调用 $\\text{post}(S)$；否则，不应发出 $\\text{post}(S)$ 调用，从而保持“可用许可证加上持有许可证的数量绝不超过 $C$”这一不变量。",
            "solution": "必须首先确定问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- **信号量类型**: 容量为 $C$ 的计数信号量 $S$。\n- **状态变量**: 一个非负整数 `count` ($N_{avail}$)，表示当前可用的许可证数量。\n- **$\\text{wait}(S)$ 操作**: 原子地检查 $count > 0$ 是否成立。如果成立，它将 $count$ 减 1 并返回成功。否则，它将阻塞。\n- **$\\text{post}(S)$ 操作**: 原子地将 $count$ 加 1。它可能唤醒一个等待中的线程。\n- **$\\text{wait}(S, t)$ 操作**: 一个定时等待，最多阻塞 $t$ 秒。如果获取了许可证（意味着 $count$ 被递减），则返回成功；如果未获取许可证（意味着 $count$ 未被递减），则返回超时。\n- **不变量**: 线程持有的许可证数量（$N_{held}$）加上可用的许可证数量（$N_{avail}$）不得超过容量 $C$。这可以写成 $N_{held} + N_{avail} \\le C$。\n- **场景**:\n    - 容量 $C=2$。\n    - 在时间 $t=0$，线程 $X$ 和 $Y$ 调用 $\\text{wait}(S)$ 并成功。状态变为 $N_{held}=2$, $N_{avail}=0$。\n    - 第三个线程 $Z$ 调用 $\\text{wait}(S, t)$（其中 $t > 0$）并阻塞。\n    - 在时间间隔 $[0, t)$ 内没有线程调用 $\\text{post}(S)$。\n    - 在时间 $t$，$Z$ 的调用返回超时。$Z$ 没有获取到许可证。\n    - 紧接着，$Z$ 执行一个取消处理程序。\n- **任务**: 评估关于 $Z$ 是否应调用 $\\text{post}(S)$ 的论断，以及不匹配的 $\\text{wait}/\\text{post}$ 调用的普遍后果。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**: 该问题基于计数信号量和二元信号量的标准和基本概念，这些是操作系统和并发编程的基石。$\\text{wait}$（P操作）和 $\\text{post}$（V操作）、定时等待和取消处理程序的定义都是标准的。\n- **良构性**: 定义精确，场景描述清晰且按时间顺序。所述的不变量 $N_{held} + N_{avail} \\le C$ 是信号量的一个关键安全属性。问题要求基于这些形式化定义评估具体论断，这是一个可解的问题。\n- **客观性**: 问题以形式化、客观的语言陈述，没有歧义或主观性。\n\n问题陈述没有说明中列出的缺陷。它在科学上是合理的、良构的且客观的。它提出了一个标准的、非平凡的同步问题。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。将推导解决方案。\n\n### 基于原则的推导\n计数信号量的核心原则是许可证的守恒定律。信号量初始化时 $N_{avail} = C$ 且 $N_{held} = 0$。一个正确的程序必须维持不变量 $N_{held} + N_{avail} = C$。问题陈述提供了一个稍弱但仍然关键的安全不变量：$N_{held} + N_{avail} \\le C$。违反此不变量表明使用信号量的程序逻辑存在缺陷。\n\n一次成功的 `wait` 操作代表一个许可证从“可用”池转换到“持有”状态。这意味着 $N_{avail}$ 减少 1，$N_{held}$ 增加 1，它们的总和保持不变。\n一次 `post` 操作应该用于将一个持有的许可证返回到可用池。这意味着 $N_{avail}$ 增加 1，$N_{held}$ 减少 1，它们的总和也保持不变。\n\n一个不持有许可证的线程调用 `post` 是一个错误。它会在没有相应减少 $N_{held}$ 的情况下增加 $N_{avail}$。这会增加总和 $N_{held} + N_{avail}$，导致 $N_{held} + N_{avail} > C$。这种现象，有时被称为许可证创建或膨胀，会破坏信号量的状态，允许多于 $C$ 个线程并发访问资源。\n\n我们现在将基于此原则评估每个论断。\n\n### 逐项分析\n\n**A. 在一个容量为 $C$ 的计数信号量中，如果一个线程从 $\\text{wait}(S, t)$ 超时而没有获取许可证，那么调用 $\\text{post}(S)$ 进行补偿是错误的，因为它在没有相应获取操作的情况下增加了 $count$，这违反了资源记账原则并造成许可证虚增。**\n\n- **分析**: 问题陈述指出，从 $\\text{wait}(S, t)$ 超时意味着“没有获取许可证且 $count$ 未被递减”。因此，所讨论的线程不持有许可证。如果该线程调用 $\\text{post}(S)$，它将增加 $count$ ($N_{avail}$) 而没有许可证可释放（即没有相应地减少 $N_{held}$）。此行为人为地创建了一个新的许可证。\n让我们分析对不变量的影响。设在虚假的 $\\text{post}(S)$ 调用之前的状态为 $N_{held}$ 和 $N_{avail}$。我们有 $N_{held} + N_{avail} \\le C$。调用 $\\text{post}(S)$ 后，新状态为 $N'_{held} = N_{held}$ 和 $N'_{avail} = N_{avail} + 1$。总和变为 $N'_{held} + N'_{avail} = N_{held} + N_{avail} + 1$。如果信号量已完全被使用（即 $N_{held} + N_{avail} = C$），总和将变为 $C+1$，直接违反不变量 $N_{held} + N_{avail} \\le C$。这破坏了信号量的资源记账。“leaked permits”（泄露的许可证）这个术语稍有不精确；“spuriously created permits”（虚假创建的许可证）或“permit inflation”（许可证膨胀）更准确，但意图是明确的。这个调用绝对是错误的。\n- **结论**: **正确**。\n\n**B. 在计数信号量中，如果一个线程在 $\\text{wait}(S, t)$ 成功返回后（因此它持有一个许可证）但在调用 $\\text{post}(S)$ 之前被取消，它必须在其取消处理程序中恰好调用一次 $\\text{post}(S)$，以避免无限期地持有该许可证。**\n\n- **分析**: 如果 $\\text{wait}(S, t)$ 返回成功，则该线程已获取一个许可证。这意味着 $N_{avail}$ 被递减，$N_{held}$ 被递增。该线程现在对此许可证负责。如果线程在执行其正常的 `post(S)` 调用之前被取消，该许可证将保留在“持有”状态，与一个现已终止的线程相关联。该许可证实际上对系统而言是丢失了，这是一种资源泄漏，会永久性地减少可用资源的数量。为防止这种情况，一个行为良好的取消处理程序必须清理已获取的资源。在这种情况下，这意味着恰好调用一次 $\\text{post}(S)$ 将持有的许可证返还给信号量，从而恢复不变量并防止资源泄漏。\n- **结论**: **正确**。\n\n**C. 对于二元信号量（容量 $C = 1$），任何超时后的无条件 $\\text{post}(S)$ 调用是无害的，因为信号量计数不能超过 $1$，所以额外的 $\\text{post}(S)$ 调用不会使并发性超出预期的限制。**\n\n- **分析**: 二元信号量是计数信号量在 $C=1$ 时的特例，通常用于互斥。假设信号量已被锁定，意味着资源正在使用中。状态为 $N_{held}=1$ 和 $N_{avail}=0$。一个调用 `wait` 的线程将会阻塞。如果它超时，它并未获取许可证。如果它随后无条件地调用 $\\text{post}(S)$，$N_{avail}$ 将增加到 $1$。状态变为 $N_{held}=1, N_{avail}=1$。总和为 $2$，违反了不变量 $N_{held} + N_{avail} \\le 1$。信号量现在指示资源可用 ($N_{avail}=1$)，即使它仍被持有 ($N_{held}=1$)。第三个线程现在可以调用 `wait(S)`，成功并进入临界区。这导致两个线程同时位于临界区内，完全破坏了互斥的保证。该行为“无害”的前提是灾难性地错误的。声称“信号量计数不能超过 $1$”也无法由所提供的 `post(S)` 定义（该定义仅增加 `count`）来保证。即使某个实现将 `count` 的上限设为 $1$，这个虚假的 `post` 也会错误地将 `count` 设置为 $1$（而它本应是 $0$），导致同样的失败。\n- **结论**: **不正确**。\n\n**D. 在实现带超时的计数信号量上的 $\\text{wait}(S, t)$ 时，正确的补偿逻辑是跟踪是否已获取许可证（例如，使用一个仅在成功时设置的布尔标志），并且当且仅当该标志为真时才调用 $\\text{post}(S)$；否则，不应发出 $\\text{post}(S)$ 调用，从而保持“可用许可证加上持有许可证的数量绝不超过 $C$”这一不变量。**\n\n- **分析**: 该论断描述了一个通用且健壮的模式，用于处理可能失败的资源获取过程中的取消操作。“当且仅当获取了许可证时才调用 `post(S)`”这一逻辑正确地处理了在 A 和 B 中讨论的两种情况。\n    1.  如果 `wait` 操作超时或失败，则没有获取许可证。标志将为假。该逻辑规定不调用 `post(S)`。这与 A 的分析结论相符，并防止了许可证膨胀。\n    2.  如果 `wait` 操作成功，则获取了许可证。标志将为真。该逻辑规定在取消时调用 `post(S)`。这与 B 的分析结论相符，并防止了许可证泄漏。\n这种“获取-执行-释放”模式，在编程语言中通常通过 `try...finally` 块或 RAII 结构实现，是确保资源安全的标准、正确的方法。它保证了每一次成功的获取都有相应的释放，从而维护了信号量的不变量。\n- **结论**: **正确**。",
            "answer": "$$\\boxed{ABD}$$"
        }
    ]
}