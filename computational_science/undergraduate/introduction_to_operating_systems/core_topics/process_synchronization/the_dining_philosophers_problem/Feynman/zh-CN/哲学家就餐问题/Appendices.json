{
    "hands_on_practices": [
        {
            "introduction": "这项实践的核心是将理论付诸实践，实现一个经典的死锁避免策略。通过使用互斥锁和资源分级策略编写解决方案，你将在预防死锁方面获得直接的动手经验。这项练习将巩固你对 Coffman 条件的理解，特别是如何在实际的并发程序中打破“循环等待”条件 。",
            "id": "3661790",
            "problem": "要求您设计、实现并验证一个使用互斥锁的哲学家就餐问题的并发模拟，并采用基于资源分层的死锁避免策略。从以下基本出发点开始：Coffman 死锁条件指出，一个系统仅当以下所有四个条件同时成立时才会发生死锁：互斥、占有并等待、不可抢占和循环等待。在经典的哲学家就餐问题中，叉子被建模为互斥资源，因此互斥、占有并等待和不可抢占这三个条件通常在设计上是成立的。因此，防止循环等待足以确保系统无死锁。一种经过充分检验的防止循环等待的方法是为资源强加一个严格全序，并要求线程只能按照此顺序的升序获取资源。\n\n设计一个程序，创建 $n$ 个环形排列的哲学家线程，索引从 $0$ 到 $n-1$。哲学家 $i$ 需要叉子 $i$ 和叉子 $(i+1) \\bmod n$ 才能进食。将每个叉子建模为一个互斥锁。通过根据叉子的索引为其强加一个严格全序来实现资源分层，并要求每个哲学家先获取索引较低的叉子，再获取索引较高的叉子。在边界情况下，当两个叉子重合时（这在 $n=1$ 时发生，因为 $(0+1) \\bmod 1 = 0$），哲学家在进食前必须且仅需获取一次该单个叉子。\n\n每个哲学家必须执行恰好 $k$ 个进食周期。在一个进食周期中，哲学家必须：\n- 遵守资源分层规则获取所需叉子，\n- 执行一个代表进食的恒定时间临界区，\n- 释放所有持有的叉子。\n\n在所有哲学家线程终止后，验证每个哲学家是否都恰好完成了 $k$ 个进食周期。程序必须为每个测试用例生成一个布尔值：如果每个哲学家都恰好进食了 $k$ 次且程序成功终止，则输出 $1$，否则输出 $0$。\n\n测试套件：\n为以下参数集 $(n, k)$ 运行模拟，以覆盖典型情况、边界条件和一个更大的压力测试用例：\n- $(n, k) = (5, 100)$,\n- $(n, k) = (1, 100)$,\n- $(n, k) = (2, 100)$,\n- $(n, k) = (13, 50)$,\n- $(n, k) = (7, 0)$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,\\dots,result_m]$）。对于上述测试套件，请打印 $[b_1,b_2,b_3,b_4,b_5]$，其中每个 $b_i$ 是先前定义的 $1$ 或 $0$。输出不需要单位，因为这些值是表示为整数的无量纲布尔值。",
            "solution": "当前问题要求设计并实现一个哲学家就餐问题的并发模拟。解决方案必须按照规定，采用资源分层策略来防止死锁。系统由 `$n$` 个哲学家和 `$n$` 个叉子组成，分别建模为线程和互斥锁。每个哲学家必须完成 `$k$` 个思考、获取叉子、进食和释放叉子的循环。\n\n### 基于原则的设计\n\n该解决方案基于并发编程和死锁理论的原则。Coffman 条件规定，只有当互斥、占有并等待、不可抢占和循环等待这四个条件全部存在时，才会发生死锁。我们的设计内在地包含了前三个条件：\n1.  **互斥**：每个叉子是一个互斥锁（`mtx_t`），根据定义，它在同一时间只能被一个线程持有。\n2.  **占有并等待**：一个哲学家获取一个叉子后，在等待获取第二个叉子时会一直持有第一个叉子。\n3.  **不可抢占**：不能强制哲学家释放叉子；他们在进食后自愿释放。\n\n因此，为防止死锁，我们必须消除第四个条件：**循环等待**。\n\n### 通过资源分层避免死锁\n\n指定的死锁避免策略是资源分层。这是一种标准技术，它对所有资源强加一个全局全序。然后要求线程按照与此顺序一致的序列获取资源。\n\n1.  **资源建模**：将 `$n$` 个叉子从 `$0$` 到 `$n-1$` 进行索引。此索引作为我们全序的基础。索引较低的叉子必须在索引较高的叉子之前被获取。\n\n2.  **获取逻辑**：\n    -   每个哲学家 `$i$`（对于 `$i \\in \\{0, 1, ..., n-1\\}$`）位于叉子 `$i$` 和叉子 `$(i+1) \\bmod n$` 之间。\n    -   设哲学家 `$i$` 所需的两个叉子为 `$f_a = i$` 和 `$f_b = (i+1) \\bmod n$`。\n    -   获取协议如下：\n        -   识别索引较低的叉子，`first_fork = min(f_a, f_b)`。\n        -   识别索引较高的叉子，`second_fork = max(f_a, f_b)`。\n        -   哲学家必须首先锁定与 `first_fork` 对应的互斥锁。\n        -   只有这样，哲学家才可以尝试锁定 `second_fork` 的互斥锁。\n\n3.  **打破循环**：该协议打破了循环等待条件。一个经典的死锁场景是每个哲学家都拿起他们左边的叉子，然后等待右边的叉子，从而形成一个循环依赖链。通过资源分层，这个链在需要叉子 `$n-1$` 和 `$0$` 的哲学家 `$n-1$` 处被打破。协议强制哲学家 `$n-1$` 先获取叉子 `$0$`，而不是先获取叉子 `$n-1$` 再等待叉子 `$0$`。由于哲学家 `$0$` 也是先获取叉子 `$0$` 作为他的第一个叉子，这两位哲学家将竞争叉子 `$0$`，从而使他们的执行串行化，防止了死锁循环。\n\n### 实现细节\n\n实现是一个使用 `threads.h` 库的 C 程序。\n\n1.  **主循环**：`main` 函数遍历指定的 `$(n, k)` 参数测试套件。对于每个测试用例，它都会协调整个模拟过程。\n\n2.  **模拟设置**：对于每个使用参数 `$n$` 和 `$k$` 的模拟运行：\n    -   分配并初始化一个包含 `$n$` 个互斥锁（`mtx_t`）的数组来代表叉子。\n    -   分配一个包含 `$n$` 个计数器（`int`）的数组来追踪每个哲学家进食的次数。\n    -   创建 `$n$` 个哲学家线程（`thrd_t`）。每个线程都被传递其唯一ID（`$0$`到`$n-1$`）、哲学家总数 `$n$`、目标进食周期数 `$k$`、一个指向其个人进食计数器的指针，以及一个指向叉子互斥锁数组的指针。\n\n3.  **哲学家线程逻辑 (`philosopher_routine`)**：\n    -   核心逻辑位于此线程函数中。它执行一个循环 `$k$` 次。\n    -   在每次迭代中，它实现叉子获取、进食和释放的循环。\n    -   计算叉子索引，并应用 `min`/`max` 逻辑来确定获取顺序。\n    -   一个特殊的检查 `if (first_fork_idx != second_fork_idx)` 至关重要。它正确处理了 `$n=1$` 的边界情况，此时所需的两个叉子是同一个（叉子 `$0$`）。这可以防止尝试锁定一个已经持有的非递归互斥锁而导致的未定义行为。\n    -   成功获取必要的叉子后，“进食”阶段是一个概念上的临界区。然后线程以与获取相反的顺序释放叉子。\n    -   一旦 `$k$` 次循环完成，线程通过将其进食计数器设置为 `$k$` 来记录其完成状态。\n\n4.  **验证**：创建所有线程后，主线程使用 `thrd_join` 等待它们全部完成。一旦所有哲学家都完成了，主线程会验证结果。它遍历进食计数器。如果每个计数器都等于 `$k$`，则该测试用例的模拟成功，结果为 `$1$`。否则，结果为 `$0$`。\n\n5.  **清理**：销毁所有互斥锁，并释放所有动态分配的内存，以防止资源泄漏。\n\n最终程序会整理每个测试用例的布尔结果，并以指定的格式 `[b_1,b_2,...,b_m]` 打印出来。该解决方案是鲁棒的，并为所有给定的测试用例（包括 `$n=1$` 和 `$k=0$` 等边界条件）正确地实现了规定的死锁避免机制。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n```"
        },
        {
            "introduction": "在学习了如何预防死锁之后，这项实践将重点转向如何检测死锁。你将把系统建模为等待图 (Wait-For Graph)，并实现一个高效的在线算法来检测图中的环，因为环的存在直接标志着死锁的发生。这项练习不仅加深了你对死锁条件的理论理解，还将并发问题与基础的图论及不相交集联合 (Disjoint Set Union, DSU) 等数据结构联系起来 。",
            "id": "3687542",
            "problem": "考虑经典的哲学家就餐问题，有 $N$ 位哲学家（编号为 $0,1,\\dots,N-1$）围坐在一张圆桌旁，并有 $N$ 把叉子。其中，叉子 $i$ 由哲学家 $i$ 和 $(i+1) \\bmod N$ 共享。每把叉子都是一个单实例资源。将资源获取建模为一个在线事件序列：当哲学家 $u$ 尝试获取邻座哲学家 $v$ 持有的叉子且必须等待时，在等待图（Wait-For Graph, WFG）中创建一条有向边 $u \\to v$。WFG 是一个有向图，其顶点是哲学家，边代表哲学家之间的等待依赖关系。在单实例资源设置中，WFG 中存在环是环中顶点集发生死锁的充分必要条件。\n\n您的任务如下：\n- 从死锁和等待图（WFG）的核心定义出发，形式化地推导一个用于 WFG 的在线环检测算法，该算法每次叉子获取事件的均摊时间复杂度为 $\\mathcal{O}(1)$。您必须证明其均摊复杂度的合理性，并说明在哲学家就餐问题的何种结构特性下该算法是正确的。\n- 将此算法实现为一个完整、可运行的程序，处理下述固定的事件序列测试套件。对于每个测试用例，程序必须识别出 WFG 中首次出现有向环的最早的获取事件索引（从 1 开始计数）。如果在处理完一个测试用例中的所有事件后没有出现环，则该测试用例的结果必须为 $-1$。\n\n每个测试用例的在线事件模型如下：一个事件是一个有序对 $(u,v)$，表示哲学家 $u$ 尝试获取邻座 $v$ 当前持有的叉子并因此进入等待状态。处理事件 $(u,v)$ 时，如果哲学家 $u$ 尚无出边（一个哲学家在任何时候最多只能等待一把叉子），则向 WFG 添加有向边 $u \\to v$。添加边之后，立即判断 WFG 中是否存在任何有向环。\n\n测试套件包含五个测试用例，涵盖了一般行为和边界情况：\n- 测试用例 1：$N=5$，事件 $\\big[(0,1),(1,2),(2,3),(3,4),(4,0)\\big]$。这模拟了当每个哲学家持有一把叉子并等待下一把时经典的死锁形成过程。应在第 5 个事件时形成环。\n- 测试用例 2：$N=2$，事件 $\\big[(0,1),(1,0)\\big]$。在第 2 个事件时形成环。\n- 测试用例 3：$N=5$，事件 $\\big[(0,1),(2,3),(4,0)\\big]$。不会形成环；答案应为 $-1$。\n- 测试用例 4：$N=3$，事件 $\\big[(0,1),(1,2),(2,0)\\big]$。在第 3 个事件时形成环。\n- 测试用例 5：$N=4$，事件 $\\big[\\,\\big]$（空序列）。不会形成环；答案应为 $-1$。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含五个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序与上文列出的一致。例如，对于第一个、第二个和第四个测试用例分别在第 5、第 2 和第 3 个事件时检测到环，而第三个和第五个测试用例没有环的情况，一个有效的输出行应为 $\\big[5,2,-1,3,-1\\big]$。\n\n不涉及物理单位或角度单位；结果为整数。对于每个测试用例，您的实现的内存使用量必须为 $\\mathcal{O}(N)$，并且在您推导中证明的假设下，每个事件的处理时间必须是均摊 $\\mathcal{O}(1)$。",
            "solution": "该问题要求针对哲学家就餐问题生成的等待图（WFG），推导并实现一个在线环检测算法。该算法每个事件的均摊时间复杂度必须为 $\\mathcal{O}(1)$，内存复杂度为 $\\mathcal{O}(N)$。\n\n首先，我们分析问题描述中定义的 WFG 的结构特性。该图的顶点是 $N$ 位哲学家。当哲学家 $u$ 开始等待哲学家 $v$ 持有的叉子时，会创建一条有向边 $u \\to v$。一个关键的约束是：“一个哲学家在任何时候最多只能等待一把叉子”。这转化为一个基本的图论性质：任何顶点 $u$ 的出度（表示为 $\\text{deg}^+(u)$）最多为 1。\n$$ \\forall u \\in V, \\quad \\text{deg}^+(u) \\le 1 $$\n具有此性质的有向图被称为函数图。函数图的每个连通分量由一组有向树组成，这些树的根指向一个单独的有向环；或者是一个单独的有向路径，可以看作是一棵树，其根在分量内没有出边。\n\n问题指定了一个在线过程，其中只有在哲学家 $u$ 之前没有等待时，才会添加边 $u \\to v$。这意味着在添加边 $u \\to v$ 之前，$u$ 的出度必须为 0，即 $\\text{deg}^+(u) = 0$。在我们基于路径的结构视图中，出度为 0 的顶点是路径的“尾部”。\n\n添加边 $u \\to v$ 会形成一个环，当且仅当在添加该边*之前*图中已存在一条从 $v$ 到 $u$ 的有向路径。设这样一条路径为 $v \\to w_1 \\to \\dots \\to w_k \\to u$。添加边 $u \\to v$ 会将此路径闭合为环 $u \\to v \\to w_1 \\to \\dots \\to w_k \\to u$。因此，环检测任务等价于回答可达性查询：“$u$ 是否可以从 $v$ 到达？”。\n\n回答此查询的一个朴素方法是从 $v$ 开始执行图遍历（如深度优先搜索或广度优先搜索）。由于任何顶点的出度最多为 1，从 $v$ 出发的路径是唯一的。我们可以简单地跟随其后继指针：$v, \\text{successor}[v], \\text{successor}[\\text{successor}[v]], \\dots$，直到找到 $u$ 或到达路径的末端（一个没有后继的顶点）。在最坏情况下，此遍历可能访问多达 $N-1$ 个其他顶点，导致每个事件的时间复杂度为 $\\mathcal{O}(N)$，这不满足要求。\n\n为实现均摊 $\\mathcal{O}(1)$ 复杂度，我们需要一种更高效的方式来管理路径信息。这可以通过使用类似于不相交集联合（Disjoint Set Union, DSU）或并查集（Union-Find）的数据结构来实现。WFG 中的每条不同路径都可以被视为一个顶点“集合”。其关键思想是为每个集合关联一个唯一的代表元。路径代表元的一个规范选择是其尾部（出度为 0 的顶点）。\n\n让我们将这种基于 DSU 的方法形式化。\n1.  **数据结构**：我们使用一个数组 `path_tail[N]`，其中 `path_tail[i]` 存储包含哲学家 $i$ 的路径的代表元（即尾部）。初始时，每个哲学家都位于各自的长度为零的路径中，因此我们为所有 $i \\in \\{0, \\dots, N-1\\}$ 初始化 `path_tail[i] = i`。我们还使用一个 `successor[N]` 数组来表示 WFG 的边，并将其初始化为一个哨兵值（例如 $-1$）。\n\n2.  **`find_tail(i)` 操作**：此函数查找包含哲学家 `i` 的路径的尾部。它类似于 DSU 中的 `find` 操作。为了达到期望的均摊复杂度，我们使用路径压缩。当我们为哲学家 `i` 找到尾部时，我们更新 `path_tail[i]` 使其直接指向该尾部。\n    ```\n    function find_tail(i):\n        if path_tail[i] == i:\n            return i\n        // Path compression:\n        path_tail[i] = find_tail(path_tail[i])\n        return path_tail[i]\n    ```\n\n3.  **`union(u, v)` 操作**：这类似于 `union` 操作。当我们添加一条边 $u \\to v$ 时，我们实际上是将以 $u$ 结尾的路径与包含 $v$ 的路径合并。新形成路径的尾部是包含 $v$ 的原始路径的尾部。令 $t_u = \\text{find\\_tail}(u)$ 且 $t_v = \\text{find\\_tail}(v)$。联合操作将 $t_u$ 所在集合的代表元设置为 $t_v$。也就是说，`path_tail[t_u] = t_v`。\n\n4.  **针对事件 $(u, v)$ 的在线算法**：\n    *   一个事件 $(u, v)$ 意味着哲学家 $u$ 开始等待 $v$ 持有的资源。根据问题描述，$u$ 之前没有在等待，因此 $\\text{deg}^+(u)=0$。这意味着 $u$ 是其当前路径的尾部。因此，在事件发生前，`find_tail(u)` 必然返回 $u$。\n    *   **环检测**：如果 $v$ 所在的路径已经终止于 $u$，则会形成一个环。这当且仅当包含 $v$ 的路径的尾部是 $u$ 时成立。因此，我们计算 $t_v = \\text{find\\_tail}(v)$ 并检查是否有 $t_v == u$。如果它们相等，添加边 $u \\to v$ 将会形成一个环。\n    *   **更新（若无环）**：如果 $t_v \\neq u$，则没有环形成。我们更新数据结构以反映新边：a. 设置 `successor[u] = v`。b. 执行联合操作：以 $u$ 结尾的路径现在连接到 $v$ 的路径。$u$ 所在路径的新尾部是 $v$ 所在路径的尾部。由于 $u$ 是其自身的代表元（`find_tail(u) == u`），这个联合操作简化为 `path_tail[u] = find_tail(v)`。\n\n**均摊复杂度证明**：`find_tail` 操作使用了路径压缩。对包含 $N$ 个元素的集合执行 $M$ 次 `find_tail` 和 `union` 操作的总时间为 $\\mathcal{O}(M \\cdot \\alpha(N))$，其中 $\\alpha(N)$ 是增长极其缓慢的反阿克曼函数。对于任何实际的 $N$ 值，$\\alpha(N)$ 都是一个小常数（小于 5）。因此，每个事件的均摊时间复杂度（涉及一次 `find_tail` 和一次 `union`（指针更新））实际上是 $\\mathcal{O}(1)$。所需的内存用于 `successor` 和 `path_tail` 数组，两者的大小均为 $N$，因此总内存复杂度为 $\\mathcal{O}(N)$。\n\n**在结构特性下的正确性**：该算法的正确性取决于问题陈述中的两个特性：1. 对于任何哲学家 $w$，$\\text{deg}^+(w) \\le 1$，这确保了 WFG 是一个函数图（路径和环的集合）。2. 只有当 $\\text{deg}^+(u)=0$ 时才添加边 $u \\to v$，这意味着 $u$ 是一个尾节点。这两个特性保证了我们的环检测条件（`find_tail(v) == u`）是充分且必要的。如果该条件成立，则存在一条路径 $v \\to \\dots \\to u$，添加 $u \\to v$ 会完成一个环。如果该条件不成立，则 $u$ 和 $v$ 位于不相交的路径上，连接它们会创建一条更长的单一路径，而不是一个环。\n\n实现将遵循这种基于 DSU 的逻辑来处理给定的测试套件。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n```"
        },
        {
            "introduction": "实现一个正确的解决方案仅仅是第一步，评估其性能也同样重要。这项实践要求你像一名系统研究员一样思考，设计一个严谨的实验来比较不同哲学家就餐算法的优劣。你将学习如何定义和测量吞吐量 $\\lambda$、平均等待时间 $W$ 和公平性 $J$ 等关键指标，并理解严谨的实验方法论的重要性，包括处理预热期和进行统计重复实验的必要性 。",
            "id": "3687546",
            "problem": "考虑一个实现餐饮哲学家问题的系统，有 $N$ 位哲学家围坐在一张桌子旁，每位哲学家左右各有一把叉子。哲学家在思考和进食两种状态之间交替。当一位哲学家感到饥饿时，他会请求相邻的两把叉子，并且只有在获得两把叉子后才能开始进食。思考时间和进食时间在所有哲学家和周期中是独立同分布的，服从均值分别为 $\\tau_{\\text{think}}$ 和 $\\tau_{\\text{eat}}$ 秒的指数分布。您必须在 $N$ 增长（取值集合为 $\\{5, 10, 20, 40\\}$）的情况下比较三种算法：\n\n- 算法 $\\mathrm{S}$（对称朴素算法）：每位哲学家先获取左边的叉子，然后获取右边的叉子。该算法容易发生死锁。\n- 算法 $\\mathrm{R}$（资源层级算法）：对叉子施加一个全序关系；每位哲学家总是先获取编号较小的叉子，再获取编号较大的叉子。该算法通过消除循环等待来防止死锁。\n- 算法 $\\mathrm{W}$（服务员算法）：一个中心化的服务员仅当一位哲学家相邻的两把叉子都可用时才授予其进食许可，否则该请求将等待。该算法能防止死锁，且不会在叉子可用性之外不必要地限制并发性。\n\n您将使用性能计数器，在稳态下的长时间运行中定义和估计三个指标：\n\n- 系统吞吐量 $\\lambda$：单位时间内（所有哲学家）完成的进食周期的长期速率。\n- 平均等待时间 $W$：从哲学家在饥饿状态开始时首次请求叉子到开始进食的期望时间。\n- Jain 公平性指数 $J$：基于每个哲学家的吞吐量 $x_i$ 计算，定义为 $J = \\dfrac{\\left(\\sum_{i=1}^{N} x_i\\right)^2}{N \\sum_{i=1}^{N} x_i^2}$。\n\n假设遵循并发和性能分析中的以下基本原则：必须对叉子强制互斥；活性（进展）和有界等待是期望的属性；当系统是遍历的时，稳态平均值是良定义的；无偏估计需要移除瞬态效应并为每位哲学家采集足够样本；对于算法 $\\mathrm{S}$，死锁是中止进展的终结条件。\n\n随着 $N$ 的增长，为了比较算法 $\\mathrm{S}$、$\\mathrm{R}$ 和 $\\mathrm{W}$，以下哪个选项是能够产生无偏估计和有效的跨 $N$ 比较的最科学合理的实验计划和正确的指标计算方法？\n\nA. 对每个 $N$ 和算法，进行一次固定时长 $T$ 的单次模拟，不设预热期，将获取叉子的总次数记录为吞吐量 $\\lambda = \\dfrac{\\text{获取次数}}{T}$，将 $W$ 计算为获取第一把叉子和获取第二把叉子之间的平均时间，并使用 $x_i = W_i$ 基于每位哲学家的平均等待时间计算公平性 $J$。如果算法 $\\mathrm{S}$ 发生死锁，则设置 $\\lambda = 0$， $W = +\\infty$，以及 $J = 0$。\n\nB. 对每个 $N$ 和算法，运行直到每位哲学家都完成了固定数量 $M$ 的进食周期，然后停止。计算 $\\lambda = \\dfrac{N M}{T_{\\text{stop}}}$，其中 $T_{\\text{stop}}$ 是经过的时间，将 $W$ 定义为思考结束和进食开始之间的平均时间，并基于每位哲学家完成的周期数 $x_i = M$ 计算 $J$ 为 $J = \\dfrac{\\sum_{i=1}^{N} x_i^2}{\\left(\\sum_{i=1}^{N} x_i\\right)^2}$。如果算法 $\\mathrm{S}$ 在所有哲学家达到 $M$ 之前发生死锁，则立即用新的随机种子重新开始运行，并丢弃发生死锁的运行。\n\nC. 对每个 $N$ 和算法，执行一次长时间运行且不进行重复实验，使用一个与 $N$ 无关的简短预热期 $T_w$，将 $\\lambda$ 计算为单位时间内成功抓取第一把叉子的总和，将 $W$ 计算为发出请求和获取第一把叉子之间的时间，并从每位哲学家抓取第一把叉子的速率 $x_i$ 计算公平性 $J$。如果算法 $\\mathrm{S}$ 发生死锁，则忽略它并继续测量其他哲学家。\n\nD. 对每个 $N$ 和算法，使用不同的随机种子执行 $R$ 次独立的重复实验。在每次重复实验中，应用一个与 $N$ 成比例的预热期 $T_w$（例如，对于固定的常数 $c$，有 $T_w = c \\cdot N \\cdot \\max\\{\\tau_{\\text{think}}, \\tau_{\\text{eat}}\\}$）以减少瞬态效应，然后在同样与 $N$ 成比例的测量窗口 $T_m$ 内进行测量，以保持每位哲学家的期望样本数大致恒定（例如，对于固定的 $c'$，有 $T_m = c' \\cdot N \\cdot \\tau_{\\text{eat}}$）。计算 $\\lambda = \\dfrac{C}{T_m}$，其中 $C$ 是测量期间完成的进食周期总数，计算每位哲学家的吞吐量 $x_i = \\dfrac{C_i}{T_m}$，计算 $J = \\dfrac{\\left(\\sum_{i=1}^{N} x_i\\right)^2}{N \\sum_{i=1}^{N} x_i^2}$，并将 $W$ 计算为从哲学家发出叉子请求的瞬间到进食开始的瞬间的平均时间。检测算法 $\\mathrm{S}$ 中的死锁；如果在测量窗口内发生死锁，则记录死锁发生率并令 $\\lambda \\to 0$，并将该次重复实验从 $W$ 和 $J$ 的计算中排除（因为没有进食发生时它们是未定义的），同时仍将死锁发生率作为一个独立的活性指标。汇总 $R$ 次重复实验的估计值，为每个 $N$ 和算法提供置信区间，并比较随 $N$ 增长的趋势。",
            "solution": "任务是确定用于比较餐饮哲学家问题三种不同算法的最科学合理的实验计划。比较涉及在哲学家数量（$N$）增加时，测量系统吞吐量（$\\lambda$）、平均等待时间（$W$）和公平性（$J$）。一个健全的随机模拟实验计划必须解决几个关键方面：消除初始化偏差、通过重复实验确保统计有效性、正确定义和测量指标、处理像死锁这样的特定故障模式，以及确保在不同系统规模下进行公平比较。\n\n### 问题陈述验证\n\n首先，对问题陈述本身进行验证。\n\n**步骤1：提取给定信息**\n- 系统：餐饮哲学家问题，有 $N$ 位哲学家，其中 $N \\in \\{5, 10, 20, 40\\}$。\n- 过程：哲学家在思考和进食之间交替。\n- 资源：$N$ 把叉子，每位哲学家需要两把相邻的叉子才能进食。\n- 随机性：思考和进食时间是独立同分布（i.i.d.）的指数随机变量，均值分别为 $\\tau_{\\text{think}}$ 和 $\\tau_{\\text{eat}}$。\n- 算法：\n    - S（对称朴素算法）：先左叉后右叉；易于死锁。\n    - R（资源层级算法）：叉子有序；先获取编号较小的叉子；无死锁。\n    - W（服务员算法）：中心化服务员原子性地授予对两把叉子的访问权；无死锁。\n- 指标：\n    - 吞吐量 $\\lambda$：单位时间内完成的进食周期的长期速率。\n    - 平均等待时间 $W$：从首次请求叉子到开始进食的期望时间。\n    - Jain 公平性指数 $J$：$J = \\dfrac{\\left(\\sum_{i=1}^{N} x_i\\right)^2}{N \\sum_{i=1}^{N} x_i^2}$，基于每位哲学家的吞吐量 $x_i$。\n- 基本原则：互斥，期望活性和有界等待，假设遍历性以进行稳态分析，要求通过移除瞬态效应和足够采样来获得无偏估计，并将死锁视为算法S的终结状态。\n- 问题：确定最科学合理的实验计划和指标计算方法。\n\n**步骤2：使用提取的给定信息进行验证**\n问题陈述是科学合理的。\n- **科学基础**：餐饮哲学家问题是并发编程和操作系统中的一个经典问题。所提出的算法（朴素、资源层级、服务员/监视器）是标准示例。性能指标（$\\lambda, W, J$）是性能评估中的标准指标。使用指数分布进行随机模拟是排队论和系统建模中一种行之有效的方法论。\n- **良构问题**：问题要求从一组选项中评估并选择最佳方法。这是一个清晰、定义明确的任务。目标——获得无偏估计并实现有效的跨$N$比较——是明确的。\n- **客观性**：语言精确且技术性强，没有主观或含糊的术语。\n\n**步骤3：结论与行动**\n问题陈述有效。我将继续分析所提供的选项。\n\n### 逐项分析\n\n对每个选项的评估基于随机系统性能评估的既定原则。\n\n**A. 对每个 $N$ 和算法，进行一次固定时长 $T$ 的单次模拟，不设预热期，将获取叉子的总次数记录为吞吐量 $\\lambda = \\dfrac{\\text{获取次数}}{T}$，将 $W$ 计算为获取第一把叉子和获取第二把叉子之间的平均时间，并使用 $x_i = W_i$ 基于每位哲学家的平均等待时间计算公平性 $J$。如果算法 $\\mathrm{S}$ 发生死锁，则设置 $\\lambda = 0$， $W = +\\infty$，以及 $J = 0$。**\n\n- **预热**：没有预热期（\"no warm-up\"）是一个致命缺陷。模拟的初始状态（例如，所有哲学家都在思考）不能代表稳态行为。从一开始就进行的测量会带有偏差。\n- **重复实验**：使用“单次模拟”仅从一个随机过程中提供一个样本点。这无法估计统计不确定性（如置信区间），也无法确定观察到的差异是显著的还是偶然的。\n- **吞吐量 $\\lambda$**：该指标被错误地定义为基于“获取叉子的次数”。问题将 $\\lambda$ 定义为“完成的进食周期”。这两者不等价；一个哲学家可以获取一把叉子但未能完成一个周期。\n- **等待时间 $W$**：提议的 $W$ 测量方法，“获取第一把叉子和获取第二把叉子之间的时间”，是错误的。问题将 $W$ 定义为从*初始请求*到*开始进食*的总时间。该选项忽略了等待第一把叉子的时间。\n- **公平性 $J$**：提议基于“每位哲学家的平均等待时间”来计算 $J$，这与问题的定义相矛盾，问题明确指出应基于“每位哲学家的吞吐量 $x_i$”来计算。\n\n**结论**：**不正确**。此选项在实验方法和指标定义上充满了根本性错误。\n\n**B. 对每个 $N$ 和算法，运行直到每位哲学家都完成了固定数量 $M$ 的进食周期，然后停止。计算 $\\lambda = \\dfrac{N M}{T_{\\text{stop}}}$，其中 $T_{\\text{stop}}$ 是经过的时间，将 $W$ 定义为思考结束和进食开始之间的平均时间，并基于每位哲学家完成的周期数 $x_i = M$ 计算 $J$ 为 $J = \\dfrac{\\sum_{i=1}^{N} x_i^2}{\\left(\\sum_{i=1}^{N} x_i\\right)^2}$。如果算法 $\\mathrm{S}$ 在所有哲学家达到 $M$ 之前发生死锁，则立即用新的随机种子重新开始运行，并丢弃发生死锁的运行。**\n\n- **死锁处理**：“丢弃……死锁的运行”这一指令引入了严重的幸存者偏差。死锁是算法 S 的一个关键特性。通过丢弃发生死锁的运行，评估将仅限于那些未发生死锁（因此不具代表性）的样本路径，导致对算法 S 的性能和活性做出严重不准确且过于乐观的评估。\n- **公平性 $J$**：$J$ 的公式是颠倒的。正确的 Jain 指数公式已在问题陈述中给出。此外，将输入定义为 $x_i = M$ 是毫无意义的。如果每位哲学家都完成了 $M$ 个周期，那么每个 $x_i$ 都将相同，无论实际花费的时间如何，$J$ 都会误导性地计算为 1（完美公平）。在这种情况下，公平性应基于速率（吞吐量）计算，而不是总数。\n- **预热/重复实验**：该计划缺乏明确的预热阶段和针对所有条件的系统性重复实验策略（它只提到在死锁时重新运行）。\n\n**结论**：**不正确**。对死锁的错误处理是一个致命缺陷，而且公平性指数的计算在数学上和概念上都是错误的。\n\n**C. 对每个 $N$ 和算法，执行一次长时间运行且不进行重复实验，使用一个与 $N$ 无关的简短预热期 $T_w$，将 $\\lambda$ 计算为单位时间内成功抓取第一把叉子的总和，将 $W$ 计算为发出请求和获取第一把叉子之间的时间，并从每位哲学家抓取第一把叉子的速率 $x_i$ 计算公平性 $J$。如果算法 $\\mathrm{S}$ 发生死锁，则忽略它并继续测量其他哲学家。**\n\n- **重复实验**：“一次长时间运行且不进行重复实验”是统计学上的糟糕实践，如选项 A 所述。\n- **预热可扩展性**：一个“与 $N$ 无关”的预热时间 $T_w$ 是一个糟糕的设计选择。系统达到稳态所需的时间（混合时间）通常随系统规模 $N$ 的增加而增加。一个对 $N=5$ 足够的 $T_w$ 很可能对 $N=40$ 是不足的。\n- **指标定义**：$\\lambda$、$W$ 以及 $J$ 的基础的定义都是不正确的。它们基于“抓取第一把叉子”而不是完成的进食周期。这未能衡量所定义的实际进展或总等待时间。\n- **死锁处理**：“忽略它并继续测量其他哲学家”这一指令揭示了对死锁的误解。在指定的系统中，涉及一个哲学家环路的死锁将阻止他们的邻居永远无法获得两把叉子，可能导致整个系统停止。不可能“忽略”一个死锁；它对相关哲学家来说是一个吸收态，并对其他哲学家产生连锁效应。\n\n**结论**：**不正确**。此选项在系统动态、性能指标和正确的实验扩展方面表现出多种概念性误解。\n\n**D. 对每个 $N$ 和算法，使用不同的随机种子执行 $R$ 次独立的重复实验。在每次重复实验中，应用一个与 $N$ 成比例的预热期 $T_w$（例如，对于固定的常数 $c$，有 $T_w = c \\cdot N \\cdot \\max\\{\\tau_{\\text{think}}, \\tau_{\\text{eat}}\\}$）以减少瞬态效应，然后在同样与 $N$ 成比例的测量窗口 $T_m$ 内进行测量，以保持每位哲学家的期望样本数大致恒定（例如，对于固定的 $c'$，有 $T_m = c' \\cdot N \\cdot \\tau_{\\text{eat}}$）。计算 $\\lambda = \\dfrac{C}{T_m}$，其中 $C$ 是测量期间完成的进食周期总数，计算每位哲学家的吞吐量 $x_i = \\dfrac{C_i}{T_m}$，计算 $J = \\dfrac{\\left(\\sum_{i=1}^{N} x_i\\right)^2}{N \\sum_{i=1}^{N} x_i^2}$，并将 $W$ 计算为从哲学家发出叉子请求的瞬间到进食开始的瞬间的平均时间。检测算法 $\\mathrm{S}$ 中的死锁；如果在测量窗口内发生死锁，则记录死锁发生率并令 $\\lambda \\to 0$，并将该次重复实验从 $W$ 和 $J$ 的计算中排除（因为没有进食发生时它们是未定义的），同时仍将死锁发生率作为一个独立的活性指标。汇总 $R$ 次重复实验的估计值，为每个 $N$ 和算法提供置信区间，并比较随 $N$ 增长的趋势。**\n\n- **重复实验与预热**：该计划正确地要求进行独立重复实验以确保统计有效性，并设置预热期以消除初始化偏差。\n- **可扩展性**：至关重要的是，它指明了预热期（$T_w$）和测量期（$T_m$）都应与 $N$ 成比例。这对于在不同系统规模之间进行公平比较至关重要，确保系统已达到稳态，并且在每种配置中为每个实体收集了相当数量的样本。\n- **指标定义**：吞吐量（$\\lambda$）、每位哲学家的吞吐量（$x_i$）、Jain 公平性指数（$J$）和平均等待时间（$W$）的计算都是精确的，并且完全符合问题陈述中提供的定义。\n- **死锁处理**：对死锁的处理堪称典范。它被视为一个重要的、可测量的结果（“记录死锁发生率”）。对于该特定运行的后果（$\\lambda \\to 0$，从 $W$ 和 $J$ 的统计中排除）在逻辑上是合理的，因为这些指标变得无定义。这种方法为算法 S 的行为提供了完整而真实的描述，将其活性属性（死锁）与其在非死锁情况下的性能属性分开。\n- **分析**：最后一步汇总结果并计算置信区间，代表了一种完整而严谨的科学方法。\n\n**结论**：**正确**。此选项描述了一个全面、方法严谨且科学合理的实验计划，遵循了所有基于模拟的性能分析的最佳实践。",
            "answer": "$$\\boxed{D}$$"
        }
    ]
}