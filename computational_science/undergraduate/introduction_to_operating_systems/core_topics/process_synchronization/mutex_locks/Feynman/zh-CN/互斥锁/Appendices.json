{
    "hands_on_practices": [
        {
            "introduction": "本练习将理论付诸实践，让你解决并发领域最著名的问题之一——哲学家就餐问题。这不仅仅是一个学术谜题，更是一个宝贵的实践机会，旨在训练你如何通过实现“资源层级”这一核心的死锁避免策略来防止死锁。通过这个练习 ，你将深入理解多个线程如何竞争多个共享资源，以及如何通过强制施加一个全局顺序来避免整个系统陷入僵局。",
            "id": "3661790",
            "problem": "要求你设计、实现并验证一个使用互斥锁的哲学家就餐问题的并发模拟，该模拟采用基于资源层级的死锁避免策略。从以下基本原理出发：Coffman 死锁条件指出，一个系统只有在以下所有四个条件同时成立时才会发生死锁：互斥、持有并等待、不可抢占和循环等待。在经典的哲学家就餐问题中，叉子被建模为互斥资源，因此互斥、持有并等待以及不可抢占这三个条件通常在设计上就已成立。所以，防止循环等待就足以确保无死锁。一个经过充分检验的防止循环等待的方法是，对资源施加一个严格的全序关系，并要求线程只能按照此顺序的升序获取资源。\n\n设计一个程序，创建 $n$ 个环形排列的哲学家线程，索引从 $0$ 到 $n-1$，其中哲学家 $i$ 需要叉子 $i$ 和叉子 $(i+1) \\pmod n$ 才能进食。将每把叉子建模为一个互斥锁。通过根据叉子的索引对其施加严格全序来实现资源层级，并要求每个哲学家必须先获取索引较小的叉子，然后再获取索引较大的叉子。在两把叉子重合的边界情况下（当 $n=1$ 时会发生，因为 $(0+1) \\pmod 1 = 0$），哲学家在进食前必须且仅需获取一次该叉子。\n\n每个哲学家必须执行恰好 $k$ 个进食周期。在一个进食周期中，哲学家必须：\n- 遵守资源层级获取所需的叉子，\n- 执行一个恒定时间的临界区来代表进食，\n- 释放所有持有的叉子。\n\n在所有哲学家线程终止后，验证每个哲学家是否都完成了恰好 $k$ 个进食周期。程序必须为每个测试用例生成一个布尔值：如果每个哲学家都恰好进食了 $k$ 次且程序终止，则输出 $1$，否则输出 $0$。\n\n测试套件：\n为以下参数集 $(n, k)$ 运行模拟，以覆盖典型情况、边界条件和一个较大的压力测试用例：\n- $(n, k) = (5, 100)$,\n- $(n, k) = (1, 100)$,\n- $(n, k) = (2, 100)$,\n- $(n, k) = (13, 50)$,\n- $(n, k) = (7, 0)$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots,result_m]$）。对于上述测试套件，请打印 $[b_1,b_2,b_3,b_4,b_5]$，其中每个 $b_i$ 为 $1$ 或 $0$，如前所定义。输出不需要单位，因为这些值是表示为整数的无量纲布尔值。",
            "solution": "当前问题要求设计并实现一个哲学家就餐问题的并发模拟。解决方案必须按照规定，采用资源层级策略来防止死锁。该系统由 $n$ 位哲学家和 $n$ 把叉子组成，它们分别被建模为线程和互斥锁。每位哲学家必须完成 $k$ 个周期的思考、获取叉子、进食和释放叉子。\n\n### 基于原则的设计\n\n该解决方案基于并发编程和死锁理论的原则。Coffman 条件规定，只有当互斥、持有并等待、不可抢占和循环等待这四个条件都存在时，死锁才可能发生。我们的设计天生就包含了前三个条件：\n1.  **互斥**：每把叉子是一个互斥锁（`mtx_t`），根据定义，它在同一时间只能被一个线程持有。\n2.  **持有并等待**：一位哲学家获取一把叉子，然后在等待获取第二把叉子时持有它。\n3.  **不可抢占**：哲学家不能被强制释放叉子；他们在进食后自愿释放。\n\n因此，为了防止死锁，我们必须消除第四个条件：**循环等待**。\n\n### 通过资源层级避免死锁\n\n指定的死锁避免策略是资源层级。这是一种标准技术，它对所有资源施加一个全局全序。然后要求线程按照与此顺序一致的序列获取资源。\n\n1.  **资源建模**：$n$ 把叉子的索引为 $0$ 到 $n-1$。这个索引作为我们全序的基础。索引较小的叉子必须在索引较大的叉子之前被获取。\n\n2.  **获取逻辑**：\n    -   每位哲学家 $i$（对于 $i \\in \\{0, 1, ..., n-1\\}$）位于叉子 $i$ 和叉子 $(i+1) \\pmod n$ 之间。\n    -   设哲学家 $i$ 需要的两把叉子为 $f_a = i$ 和 $f_b = (i+1) \\pmod n$。\n    -   获取协议如下：\n        -   确定索引较小的叉子，`first_fork = min(f_a, f_b)`。\n        -   确定索引较大的叉子，`second_fork = max(f_a, f_b)`。\n        -   哲学家必须首先锁定与 `first_fork` 对应的互斥锁。\n        -   只有在那之后，哲学家才可以尝试锁定 `second_fork` 的互斥锁。\n\n3.  **打破循环**：此协议打破了循环等待条件。一个经典的死锁场景是，每位哲学家都拿起他们左边的叉子，然后等待右边的叉子，形成一个循环依赖链。通过资源层级，这个链条在哲学家 $n-1$ 处被打破，他需要叉子 $n-1$ 和 $0$。协议强制哲学家 $n-1$ 先获取叉子 $0$，而不是获取叉子 $n-1$ 后等待叉子 $0$。由于哲学家 $0$ 也将叉子 $0$ 作为他首先要获取的叉子，这两位哲学家将竞争叉子 $0$，从而串行化他们的执行，防止死锁循环。\n\n### 实现细节\n\n实现是一个使用 `threads.h` 库的 C 程序。\n\n1.  **主循环**：`main` 函数遍历指定的 $(n, k)$ 参数测试套件。对于每个测试用例，它都会组织整个模拟过程。\n\n2.  **模拟设置**：对于每个使用参数 $n$ 和 $k$ 的模拟运行：\n    -   分配并初始化一个包含 $n$ 个互斥锁（`mtx_t`）的数组来代表叉子。\n    -   分配一个包含 $n$ 个计数器（`int`）的数组，以跟踪每位哲学家进食的次数。\n    -   创建 $n$ 个哲学家线程（`thrd_t`）。每个线程都被传递其唯一的 ID（$0$ 到 $n-1$)、哲学家总数 $n$、目标进食周期数 $k$、一个指向其个人进食计数器的指针，以及一个指向叉子互斥锁数组的指针。\n\n3.  **哲学家线程逻辑 (`philosopher_routine`)**：\n    -   核心逻辑位于此线程函数中。它执行一个循环 $k$ 次。\n    -   在每次迭代中，它都实现获取叉子、进食和释放叉子的周期。\n    -   计算叉子索引，并应用 `min`/`max` 逻辑来确定获取顺序。\n    -   一个特殊的检查 `if (first_fork_idx != second_fork_idx)` 至关重要。它正确处理了 $n=1$ 的边界情况，此时所需的两把叉子是相同的（叉子 $0$）。这可以防止尝试锁定一个已经被持有的非递归互斥锁而导致的未定义行为。\n    -   成功获取必要的叉子后，“进食”阶段是一个概念上的临界区。然后线程按获取的相反顺序释放叉子。\n    -   一旦 $k$ 个周期的循环完成，线程通过将其进食计数器设置为 $k$ 来记录其完成情况。\n\n4.  **验证**：创建所有线程后，主线程使用 `thrd_join` 等待所有线程完成。一旦所有哲学家都完成，主线程会验证结果。它遍历进食计数器。如果每个计数器都等于 $k$，则该测试用例的模拟成功，结果为 $1$，否则为 $0$。\n\n5.  **清理**：销毁所有互斥锁，并释放所有动态分配的内存，以防止资源泄漏。\n\n最终程序整理每个测试用例的布尔结果，并以指定的格式 `[b_1,b_2,...,b_m]` 打印它们。该解决方案是稳健的，并为所有给定的测试用例正确实现了规定的死锁避免机制，包括 $n=1$ 和 $k=0$ 等边界条件。",
            "answer": "```c\n// [EDITOR'S NOTE: The C code for this solution was missing from the source and cannot be reconstructed.]\n#include\n```"
        },
        {
            "introduction": "预防错误固然重要，但诊断和修复线上问题是工程师必备的一项关键技能。这个练习模拟了一个真实世界的调试场景：一个多线程服务突然“挂起”，你需要像侦探一样从蛛丝马迹中找出原因。通过分析给定的线程堆栈和锁状态信息 ，你将学会如何在脑海中构建“等待关系图”，从而系统性地定位并诊断出最棘手的并发错误——死锁。",
            "id": "3661769",
            "problem": "一个运行在遵循可移植操作系统接口 (POSIX) 的操作系统 (OS) 上的多线程服务使用互斥锁 (mutex locks) 来保护跨模块的共享状态。三个互斥锁，分别标记为 $M_x$、$M_y$ 和 $M_z$，使用默认属性创建。四个线程，分别标记为 $T_1$、$T_2$、$T_3$ 和 $T_4$，执行工作函数，这些函数有时会获取多个互斥锁。在挂钟时间 17:23:54 时，该服务似乎挂起了。你触发了一次诊断捕获，该捕获停止了所有线程，并记录了它们的堆栈跟踪以及每个互斥锁的经过插桩的所有者/等待者快照。捕获结果如下：\n\n- 线程 $T_1$ 堆栈（显示顶层帧）： \n  - $pthread\\_mutex\\_lock(M_y)$ 阻塞\n  - 下层：持有 $M_x$ 后调用 $process\\_B$\n  - 插桩显示 $T_1$ 当前持有 $M_x$ 并尝试锁定 $M_y$\n\n- 线程 $T_2$ 堆栈（显示顶层帧）：\n  - $pthread\\_mutex\\_lock(M_x)$ 阻塞\n  - 下层：持有 $M_y$ 后调用 $process\\_A$\n  - 插桩显示 $T_2$ 当前持有 $M_y$ 并尝试锁定 $M_x$\n\n- 线程 $T_3$ 堆栈（显示顶层帧）：\n  - $pthread\\_mutex\\_lock(M_z)$ 阻塞\n  - 下层：未持有其他互斥锁时调用 $aux\\_work$\n  - 插桩显示 $T_3$ 正在尝试锁定 $M_z$\n\n- 线程 $T_4$ 堆栈（显示顶层帧）：\n  - $do\\_maintenance$ 正在运行\n  - 插桩显示 $T_4$ 当前持有 $M_z$ 且未尝试锁定任何其他互斥锁\n\n- 互斥锁所有者/等待者快照（来自同一时刻的插桩）：\n  - $M_x$：所有者 $T_1$；等待者 $\\{T_2\\}$\n  - $M_y$：所有者 $T_2$；等待者 $\\{T_1\\}$\n  - $M_z$：所有者 $T_4$；等待者 $\\{T_3\\}$\n\n假设使用标准的互斥锁语义：对一个有竞争的互斥锁调用 $pthread\\_mutex\\_lock$ 会使调用线程进入阻塞状态，且互斥锁不能被抢占或从其所有者处被强制剥夺。死锁需要四个 Coffman 条件：互斥、持有并等待、不可抢占和循环等待。\n\n仅使用这些基本定义和捕获的数据，你希望既能诊断挂起问题，又能选择一个最稳健、侵入性最小的变更来防止其复现。哪个选项正确描述了一种基于原则的调试方法，该方法利用堆栈跟踪来识别谁持有哪个互斥锁以及谁在等待哪个互斥锁，然后提出了一个能够破坏所有代码路径中死锁的底层必要条件的修复方案？\n\nA. 通过将每个阻塞的 $pthread\\_mutex\\_lock$ 帧映射到其目标互斥锁，并与插桩数据中的所有者进行交叉引用，来构建一个等待图：检测到边 $T_1 \\rightarrow M_y \\rightarrow T_2$ 和 $T_2 \\rightarrow M_x \\rightarrow T_1$ 形成了一个环路，而 $T_3 \\rightarrow M_z \\rightarrow T_4$ 不在环路中。结论是 $T_1$ 和 $T_2$ 在 $M_x$ 和 $M_y$ 上发生了死锁，原因是不同路径中锁的获取顺序相反。通过在所有模块中强制执行严格的全局锁顺序 $M_x \\rightarrow M_y \\rightarrow M_z$，并在全系统范围内打破循环等待，该顺序通过断言进行验证。\n\nB. 结论是 $T_3$ 和 $T_4$ 在 $M_z$ 上发生了死锁，因为 $T_3$ 被阻塞而 $T_4$ 持有 $M_z$。通过为所有 $pthread\\_mutex\\_lock$ 调用添加超时来解决问题，这样阻塞的线程最终会中止其锁尝试并继续执行。\n\nC. 诊断为饥饿而非死锁：$T_1$ 被阻塞是因为 $T_2$ 具有更高的优先级并持续运行。通过将 $T_1$ 的调度器优先级提高到 $T_2$ 之上，以确保它能更快地获取 $M_y$ 来修复。\n\nD. 通过在 $process\\_B$ 中围绕 $M_y$ 插入“先解锁后加锁”的逻辑来避免环路：在尝试获取 $M_y$ 时临时释放 $M_x$，之后再重新获取 $M_x$。这种局部更改足以在没有全局策略的情况下防止死锁。",
            "solution": "从基本定义开始。互斥锁确保了互斥性：在任何时候，最多只有一个线程可以拥有一个互斥锁。根据 POSIX 语义，对一个已锁定的互斥锁调用 $pthread\\_mutex\\_lock$ 会阻塞调用者，直到该互斥锁可用。Coffman 条件指出，当四个条件同时成立时会发生死锁：互斥、持有并等待（每个进程在等待其他资源时至少持有一个资源）、不可抢占（资源不能被强制剥夺）和循环等待（资源分配图中存在一个环路，使得每个进程都在等待下一个进程持有的资源）。\n\n从第一性原理出发，诊断死锁涉及构建一个等待/资源分配图。节点可以是线程 ($T_i$) 和互斥锁 ($M_j$)。一条有向边 $T_i \\rightarrow M_j$ 表示线程 $T_i$ 当前正阻塞等待获取互斥锁 $M_j$。一条有向边 $M_j \\rightarrow T_i$ 表示互斥锁 $M_j$ 当前由线程 $T_i$ 持有。一个在线程和互斥锁之间交替的环路表示循环等待，满足第四个 Coffman 条件。如果互斥、持有并等待以及不可抢占条件也成立（对于标准互斥锁来说，这些条件确实成立），那么系统就处于死锁状态。\n\n使用捕获的堆栈跟踪和插桩数据：\n\n- 对于 $T_1$：顶层帧显示 $pthread\\_mutex\\_lock(M_y)$ 阻塞，且插桩数据显示 $T_1$ 持有 $M_x$。因此，添加边 $T_1 \\rightarrow M_y$ 和 $M_x \\rightarrow T_1$。\n\n- 对于 $T_2$：顶层帧显示 $pthread\\_mutex\\_lock(M_x)$ 阻塞，且插桩数据显示 $T_2$ 持有 $M_y$。因此，添加边 $T_2 \\rightarrow M_x$ 和 $M_y \\rightarrow T_2$。\n\n- 对于 $T_3$：顶层帧显示 $pthread\\_mutex\\_lock(M_z)$ 阻塞。插桩数据未显示 $T_3$ 持有任何其他互斥锁，因此添加边 $T_3 \\rightarrow M_z$。\n\n- 对于 $T_4$：插桩数据显示 $T_4$ 持有 $M_z$ 且未尝试锁定任何其他锁，因此添加边 $M_z \\rightarrow T_4$。\n\n现在分析该图：\n\n- 涉及 $T_1$、$T_2$、$M_x$ 和 $M_y$ 的子图包含 $T_1 \\rightarrow M_y \\rightarrow T_2 \\rightarrow M_x \\rightarrow T_1$。这是一个环路。互斥条件成立，因为 $M_x$ 和 $M_y$ 是互斥锁。持有并等待条件成立，因为 $T_1$ 在等待 $M_y$ 时持有 $M_x$，而 $T_2$ 在等待 $M_x$ 时持有 $M_y$。对于标准互斥锁，不可抢占条件成立。因此，所有四个 Coffman 条件都已满足，$T_1$ 和 $T_2$ 陷入死锁。\n\n- 涉及 $T_3$、$T_4$ 和 $M_z$ 的子图包含 $T_3 \\rightarrow M_z \\rightarrow T_4$。没有从 $T_4$ 指向另一个互斥锁的边。因此，这里没有环路，这也不是死锁。这只是一个简单的竞争情况，即 $T_3$ 等待 $T_4$ 释放 $M_z$。\n\n为了防止复现，应寻求一种侵入性最小的变更，以全局性地打破其中一个 Coffman 条件。对于需要多个锁的代码库中的互斥锁死锁问题，最标准和最稳健的方法是强制执行严格的全局锁顺序。如果所有代码路径都按照 $M_x$，然后 $M_y$，然后 $M_z$（或任何一致的全序）的顺序获取锁，那么循环等待就不可能出现：因为代表“等待”的边总是从一个低阶锁指向一个高阶锁，从而形成一个无环偏序，所以不可能存在环路。这打破了循环等待条件，而无需改变互斥语义或要求抢占。可以使用断言来验证函数在调试版本的运行时没有违反该顺序。\n\n评估每个选项：\n\nA. 该选项提出了基于原则的诊断方法：从堆stack跟踪和所有者数据构建等待图。它正确地识别了环路 $T_1 \\rightarrow M_y \\rightarrow T_2 \\rightarrow M_x \\rightarrow T_1$，并正确地将 $T_3$ 和 $T_4$ 排除在死锁之外。然后，它提议在所有模块中强制执行全局锁顺序 $M_x \\rightarrow M_y \\rightarrow M_z$，这从设计上就打破了循环等待条件。这与基本定义一致，并且是侵入性最小的：它仅需要代码更改来重新排序锁的获取和添加检查，而无需改变互斥锁的抽象。结论：正确。\n\nB. 该选项错误地诊断了 $T_3$ 和 $T_4$ 之间存在死锁。图上没有显示环路；$T_3$ 等待由 $T_4$ 持有的 $M_z$，但 $T_4$ 并没有在等待。因此，这不是死锁。此外，为 $pthread\\_mutex\\_lock$ 添加超时不是一个标准的 POSIX 功能，并且即使通过非阻塞尝试和重试来实现，也可能引入活锁或破坏临界区的原子性保证。它没有解决 $T_1$ 和 $T_2$ 之间实际存在的环路。结论：不正确。\n\nC. 该选项声称是由于调度器优先级导致的饥饿。捕获的数据明确显示是阻塞在互斥锁获取上，而不是抢占问题。当 $T_1$ 等待 $T_2$ 持有的 $M_y$ 而 $T_2$ 等待 $T_1$ 持有的 $M_x$ 时，优先级的改变无法解决这个环路。调度器的改变无法打破互斥依赖关系。结论：不正确。\n\nD. 该选项建议在尝试获取 $M_y$ 之前局部地解锁 $M_x$，然后重新获取 $M_x$。虽然表面上这可能避免了一个循环等待的实例，但它引入了一个窗口期，在此期间由 $M_x$ 保护的临界区不受保护，可能导致竞争和不变量违规。此外，如果没有一个一致的全局策略，其他路径仍然可能以相反的顺序获取锁并导致死锁。这不是一个稳健的、系统级的修复方案，并且可能会降低正确性。结论：不正确。\n\n因此，最佳选择是选项 A，它正确地使用堆栈跟踪来构建等待图，识别出死锁，并提出了一个恰当的全局锁顺序来打破循环等待条件。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "健壮的并发代码不仅要能预防死锁，还必须能优雅地处理各种异常情况。本练习探讨了一个常见但极其危险的陷阱：当线程中发生意外错误（如异常抛出）时，可能导致它“忘记”释放已经持有的锁，从而使其他依赖该锁的线程永久等待。这个问题  促使你跳出“正常执行路径”的思维定势，学习并运用诸如“资源获取即初始化”（RAII）等现代编程范式，以确保资源在任何情况下都能被正确释放。",
            "id": "3661749",
            "problem": "一个服务器程序维护一个共享有界队列，该队列由一个互斥锁 $M$ 在 $N$ 个工作线程 $\\{T_1,\\dots,T_N\\}$ 之间进行保护。每个工作线程执行一个临界区，该临界区执行以下概念性步骤：获取 $M$，操作队列，然后释放 $M$。操作阶段会调用一个辅助函数 $f$，该函数可能会在到达显式释放语句之前抛出一个异常事件 $E$。在最近的一份错误报告中，当 $E$ 发生后，其他试图获取 $M$ 的工作线程会无限期阻塞。要求您根据操作系统的并发基础原理确定根本原因，并选择能够稳健地消除此错误同时保持正确互斥性的模式。\n\n假设以下基本事实成立：\n- 互斥锁强制实现互斥：在任何时候最多有 $1$ 个线程持有 $M$，从而使临界区的状态转换对其他线程来说是原子的。\n- 进展要求持有 $M$ 的线程最终会释放 $M$；否则，其他线程可能永远阻塞，违反了活性（liveness）要求。\n- 异常通过展开调用栈来改变控制流，跳过当前作用域中的后续语句，除非有语言机制保证在作用域退出时执行清理代码。\n\n以下哪项更改能同时满足以下两个要求：（i）保证 $M$ 在所有控制流路径（包括异常和提前返回）上都被释放，以及（ii）保持互斥性，且不存在临界区完成前 $M$ 就被释放的时间窗口？选择所有适用的选项。\n\nA. 在成功获取 $M$ 后立即创建一个作用域防护对象，该对象的析构函数在作用域退出时确定性地调用 $M$ 的释放操作，并消除所有手动释放。这就是“资源获取即初始化”（Resource Acquisition Is Initialization, RAII）模式。\n\nB. 用一个 try-catch 结构包围临界区，该结构捕获由 $f$ 抛出的特定异常类型，并仅在 catch 处理程序内部调用 $M$ 的释放操作，而常规返回路径则继续使用现有的手动释放。\n\nC. 将 $M$ 替换为递归（可重入）互斥锁，允许同一线程多次获取该锁，并假设可重入性可以防止由异常引起的死锁。\n\nD. 引入一个与 $M$ 配对的条件变量，并让线程在异常处理程序内部对该条件变量发信号，以通知其他线程它们应该在不阻塞于 $M$ 的情况下继续执行。\n\nE. 使用一种保证在作用域退出时执行终结操作的语言特性（例如，finally 块或 defer 语句），将 $M$ 的释放操作放在该终结结构中，确保无论控制如何离开作用域（包括异常和提前返回），释放操作都会运行。",
            "solution": "问题的核心在于，当持有锁的线程中发生异常时，常规的控制流被中断，导致锁的释放操作被跳过，从而使锁被永久持有（泄露）。这会导致其他所有需要该锁的线程无限期阻塞。一个健壮的解决方案必须保证无论控制流如何退出临界区（正常返回、提前返回或异常抛出），锁都一定会被释放。\n\n- **选项 A (RAII)** 和 **选项 E (finally/defer)** 都是专门为此类问题设计的编程模式。\n  - **A (资源获取即初始化 - RAII):** 这是C++等语言中的惯用方法。一个“作用域防护”对象在构造时获取锁，在析构时释放锁。由于当作用域因任何原因退出时，栈上对象的析构函数都会被确定性地调用，因此锁的释放得到了保证。\n  - **E (finally/defer):** 像Java的 `finally` 块或Go的 `defer` 语句，它们提供了语言级别的保证，即无论函数如何返回，指定的清理代码（释放锁）都将被执行。\n  这两个选项都满足了在所有路径上释放锁且不破坏互斥性的要求。\n\n- **选项 B (try-catch)** 是一个脆弱且不完整的解决方案。它只能捕获特定类型的异常。如果函数中有多个返回点或抛出其他类型的异常，锁仍然可能被泄露。它需要手动在多个地方重复释放逻辑，容易出错。\n\n- **选项 C (递归互斥锁)** 与问题无关。递归锁解决的是同一线程重复获取自己已持有锁的问题，而不是锁被持有后未被释放的问题。\n\n- **选项 D (条件变量)** 是错误的工具。条件变量用于线程间的状态通知，不能解决锁泄露的问题，反而会使逻辑复杂化并引入新的错误。\n\n因此，选项 A 和 E 是唯一能够提供所需保证的健壮解决方案。",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}