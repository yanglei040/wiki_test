{
    "hands_on_practices": [
        {
            "introduction": "Writing correct concurrent code requires mastering the nuances of synchronization primitives. This first exercise focuses on a common pitfall when using Mesa-style condition variables: the \"spurious wake-up.\" You will explore why simply checking a condition once before waiting is unsafe and why a `while` loop is the only robust pattern to guarantee correctness .",
            "id": "3687757",
            "problem": "You are designing the synchronization for the classical readers-writers problem in an Operating System (OS), with writer preference and Condition Variables (CV). The shared state includes a mutex $m$, CVs $canRead$ and $canWrite$, an integer $activeReaders$, an integer $waitingWriters$, and a boolean $writerActive$. The semantics are as follows: (i) $wait(cv, m)$ atomically releases $m$ and blocks the calling thread; when the wait returns, $m$ has been re-acquired, (ii) $signal(cv)$ or $broadcast(cv)$ may wake one or more waiters, but spurious wake-ups are permitted (a waiting thread may wake without any $signal$ or $broadcast$), and (iii) Mesa-style CV semantics apply: a signaled thread only runs after the signaling thread releases $m$, so the condition may have changed before the waiter runs.\n\nThe required safety property is that at most one writer is active and no reader can read while a writer is active. Formally, when $writerActive = \\text{true}$, then $activeReaders = 0$. The writer-preference policy requires that new readers do not enter if any writer is active or waiting. Formally, a reader may proceed into the critical section only if $\\lnot writerActive \\land waitingWriters = 0$.\n\nConsider two shapes of reader-entry code, written informally using the shared state variables above. Both execute under $m$ held and increment $activeReaders$ just before returning to the caller.\n\n- Single-check version: if the admission predicate is false, execute $wait(canRead, m)$ once, then proceed to increment $activeReaders$.\n- Loop version: while the admission predicate is false, execute $wait(canRead, m)$, then when the loop exits, proceed to increment $activeReaders$.\n\nYour task is to reason from the definitions above to choose the correct statements about how to guard reader entry in the presence of spurious wake-ups and writer preference.\n\nWhich of the following options are correct?\n\nA. The loop guard that preserves safety and writer preference is: while $\\big(writerActive \\lor waitingWriters > 0\\big)$, call $wait(canRead, m)$. Only when the loop exits should $activeReaders \\leftarrow activeReaders + 1$.\n\nB. The loop guard can be weakened to: while $\\big(writerActive \\land waitingWriters > 0\\big)$, call $wait(canRead, m)$, because if only one of the two is true, no violation can occur.\n\nC. The single-check version with a single if-test is safe if it checks $\\big(writerActive \\lor waitingWriters > 0\\big)$ once before a single $wait(canRead, m)$, because $wait$ re-acquires $m$ before returning and thus the condition cannot change unexpectedly.\n\nD. There exists a schedule showing that the single-check version fails under spurious wake-ups: at time $t_1$, a writer sets $writerActive \\leftarrow \\text{true}$ and holds $m$; at time $t_2$, a reader $R$ executes the single if-test, finds $\\big(writerActive \\lor waitingWriters > 0\\big)$ true, and calls $wait(canRead, m)$; at time $t_3$, a spurious wake-up occurs, $R$ returns from $wait$ with $m$ held while $writerActive$ is still $\\text{true}$; at time $t_4$, because there is no re-check, $R$ increments $activeReaders$ and proceeds concurrently with the writer, violating safety.\n\nE. Using $signal(canRead)$ instead of $broadcast(canRead)$ when a writer releases the resource eliminates the need for a loop in the reader code, because at most one reader will wake and the state will be stable when it runs.\n\nSelect all that apply.",
            "solution": "The user wants a critical analysis of synchronization strategies for the readers-writers problem with writer preference, using Mesa-style condition variables. I will first validate the problem statement and then, finding it valid, proceed to a detailed analysis of each option.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n-   **Problem Domain**: Classical readers-writers problem in an Operating System.\n-   **Synchronization Policy**: Writer preference.\n-   **Primitives**: Mutex $m$ and Condition Variables (CVs) $canRead$ and $canWrite$.\n-   **Shared State**: Integer $activeReaders$, integer $waitingWriters$, boolean $writerActive$.\n-   **CV Semantics**:\n    -   (i) $wait(cv, m)$ atomically releases $m$, blocks, and re-acquires $m$ upon return.\n    -   (ii) Spurious wake-ups are permitted.\n    -   (iii) Mesa-style semantics apply: a signaled thread resumes execution only after the signaling thread releases the mutex $m$.\n-   **Safety Property**: If $writerActive = \\text{true}$, then $activeReaders = 0$.\n-   **Writer-Preference Policy**: A reader may enter its critical section only if $\\lnot writerActive \\land waitingWriters = 0$.\n-   **Code Constructs to Compare**:\n    1.  **Single-check**: An `if` statement tests the admission predicate once before a potential $wait$.\n    2.  **Loop**: A `while` loop repeatedly tests the admission predicate before proceeding.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is **valid**.\n-   It is **Scientifically Grounded** and **Objective**: The problem is a canonical computer science problem concerning concurrency control. The terminology (Mesa semantics, spurious wake-ups, mutex, condition variable) and the formal properties are standard and precisely defined within the field of operating systems.\n-   It is **Well-Posed**: The problem provides a complete set of rules (primitive semantics, safety properties, policies) and asks for an evaluation of specific implementation choices against these rules. This allows for a unique and logical analysis.\n-   There are no contradictions, ambiguities, or factual errors in the setup.\n\n### **Derivation and Solution**\n\nThe core of the problem lies in the interaction between the reader's admission condition and the semantics of Mesa-style condition variables.\n\n**Fundamental Principle of Mesa-style CVs:**\nThe problem states that (ii) spurious wake-ups are possible, and (iii) due to Mesa-style semantics, the condition that prompted a `signal` may no longer be true when the waiting thread finally re-acquires the mutex and runs. Both of these facts imply a crucial design principle: **upon waking from a $wait$ call, a thread cannot assume the desired condition is met.** It must re-evaluate the condition.\n\nThe standard and correct pattern to wait for a condition $P$ to become true using Mesa-style CVs is to place the $wait$ call inside a `while` loop:\n\n`lock(m);`\n`while (!P)`\n`    wait(cv, m);`\n`// ... proceed, P is guaranteed to be true here`\n`unlock(m);`\n\nAny implementation that uses a single `if` check before the $wait$ is inherently flawed, as it fails to re-check the condition after waking up.\n\n**Applying the Principle to the Problem:**\nThe writer-preference policy dictates that a reader can proceed only when the condition $P \\equiv (\\lnot writerActive \\land waitingWriters = 0)$ is true. The condition to wait, therefore, is $\\lnot P$. Using De Morgan's laws:\n$$ \\lnot(\\lnot writerActive \\land waitingWriters = 0) \\equiv (\\lnot(\\lnot writerActive) \\lor \\lnot(waitingWriters = 0)) $$\n$$ \\equiv (writerActive \\lor waitingWriters \\neq 0) $$\nAssuming $waitingWriters$ cannot be negative, this is equivalent to $(writerActive \\lor waitingWriters > 0)$.\n\nTherefore, the correct reader entry code must lock the mutex $m$, loop while $(writerActive \\lor waitingWriters > 0)$, and only after the loop terminates (when the condition to proceed is met) increment $activeReaders$.\n\n### **Option-by-Option Analysis**\n\n**A. The loop guard that preserves safety and writer preference is: while $\\big(writerActive \\lor waitingWriters > 0\\big)$, call $wait(canRead, m)$. Only when the loop exits should $activeReaders \\leftarrow activeReaders + 1$.**\n\n-   **Analysis**: This option describes the exact implementation derived from first principles. The `while` loop correctly handles both spurious wake-ups and the condition changes inherent in Mesa-style semantics by re-checking the predicate. The predicate itself, $writerActive \\lor waitingWriters > 0$, is the correct condition for a reader to wait, as it is the negation of the admission predicate $\\lnot writerActive \\land waitingWriters = 0$. Incrementing $activeReaders$ after the loop ensures a reader is only counted once it has been granted access, preserving the integrity of the shared state.\n-   **Verdict**: Correct.\n\n**B. The loop guard can be weakened to: while $\\big(writerActive \\land waitingWriters > 0\\big)$, call $wait(canRead, m)$, because if only one of the two is true, no violation can occur.**\n\n-   **Analysis**: This proposes an incorrect waiting condition. The loop would terminate if $\\lnot(writerActive \\land waitingWriters > 0)$ is true, which is equivalent to $\\lnot writerActive \\lor waitingWriters = 0$. This is not the required admission condition.\n    -   Case 1: If $writerActive$ is true and $waitingWriters = 0$, the loop condition is false. The reader would exit the loop and increment $activeReaders$, resulting in a state where $writerActive = \\text{true}$ and $activeReaders > 0$. This is a direct violation of the specified safety property.\n    -   Case 2: If $writerActive$ is false and $waitingWriters > 0$, the loop condition is false. The reader would exit the loop and proceed, violating the writer-preference policy which requires readers to wait for waiting writers.\n-   **Verdict**: Incorrect.\n\n**C. The single-check version with a single if-test is safe if it checks $\\big(writerActive \\lor waitingWriters > 0\\big)$ once before a single $wait(canRead, m)$, because $wait$ re-acquires $m$ before returning and thus the condition cannot change unexpectedly.**\n\n-   **Analysis**: This option defends the single-check version. Its reasoning is fundamentally flawed. While $wait(canRead, m)$ does re-acquire $m$, the period between the thread being signaled (or spuriously woken up) and it re-acquiring the lock is an interval where other threads can run. Another thread could have acquired $m$, changed the state (e.g., a new writer arrived and set $waitingWriters > 0$), and released $m$. Furthermore, a spurious wake-up provides no information about the state at all. A `while` loop is required to handle these cases; an `if` statement is insufficient and unsafe. The claim that \"the condition cannot change unexpectedly\" is false.\n-   **Verdict**: Incorrect.\n\n**D. There exists a schedule showing that the single-check version fails under spurious wake-ups: at time $t_1$, a writer sets $writerActive \\leftarrow \\text{true}$ and holds $m$; at time $t_2$, a reader $R$ executes the single if-test, finds $\\big(writerActive \\lor waitingWriters > 0\\big)$ true, and calls $wait(canRead, m)$; at time $t_3$, a spurious wake-up occurs, $R$ returns from $wait$ with $m$ held while $writerActive$ is still $\\text{true}$; at time $t_4$, because there is no re-check, $R$ increments $activeReaders$ and proceeds concurrently with the writer, violating safety.**\n\n-   **Analysis**: This option provides a concrete failure scenario for the single-check version. While the wording \"at time $t_1$, a writer... holds $m$\" and \"at time $t_2$, a reader $R$ executes\" is slightly imprecise (two threads cannot hold the same mutex simultaneously), the logical sequence of states it describes is valid and demonstrates a critical flaw. A more precise timeline would be: A writer acquires $m$, sets $writerActive \\leftarrow \\text{true}$, and releases $m$ to do work. Reader $R$ then acquires $m$, sees $writerActive$ is true, and calls $wait(canRead, m)$, releasing $m$. Then, a spurious wake-up occurs. $R$ re-acquires $m$. At this point, the writer is still active ($writerActive = \\text{true}$). The single-check code does not re-test the condition, so $R$ incorrectly proceeds to increment $activeReaders$ and enters the critical section. This leads to a state where $writerActive = \\text{true}$ and $activeReaders > 0$, a clear violation of the safety property. The scenario described is a classic example of why a `while` loop is necessary.\n-   **Verdict**: Correct.\n\n**E. Using $signal(canRead)$ instead of $broadcast(canRead)$ when a writer releases the resource eliminates the need for a loop in the reader code, because at most one reader will wake and the state will be stable when it runs.**\n\n-   **Analysis**: This option is incorrect for two primary reasons. First, the claim that \"the state will be stable when it runs\" is false under Mesa-style semantics. As established, another thread can change the state between the `signal` and the waiter's resumption. Second, it completely ignores the possibility of spurious wake-ups, which are independent of whether `signal` or `broadcast` is used. A spurious wake-up would still cause the single-check code to fail. Therefore, switching to $signal(canRead)$ does not remove the need for the `while` loop.\n-   **Verdict**: Incorrect.",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "Beyond getting the waiting logic right, robust systems must also handle unexpected failures gracefully. This practice explores the concept of exception safety in the context of the readers-writers problem . You will diagnose a critical liveness failure—writer starvation—caused by a reader that fails to release its \"lock\" due to an error, and discover how language constructs like `try-finally` are essential for maintaining system invariants.",
            "id": "3687699",
            "problem": "A system implements a readers-writers protocol using a single mutual exclusion lock $mutex$ and two condition variables $canRead$ and $canWrite$. The shared state includes an integer counter $rw\\_count$ and a Boolean $writerActive$. The intended invariant is that $rw\\_count$ equals the number of currently active reader threads, and writers may proceed only when $rw\\_count = 0$ and $writerActive = \\text{false}$. The intended entry/exit behavior is as follows: reader entry acquires $mutex$, waits while $writerActive = \\text{true}$, increments $rw\\_count$, and releases $mutex$; reader exit acquires $mutex$, decrements $rw\\_count$, signals $canWrite$ if $rw\\_count = 0$, and releases $mutex$. A writer entry acquires $mutex$, waits while $(rw\\_count > 0) \\lor (writerActive = \\text{true})$, sets $writerActive = \\text{true}$, and releases $mutex$; writer exit acquires $mutex$, sets $writerActive = \\text{false}$, broadcasts $canRead$ and signals $canWrite$, then releases $mutex$.\n\nConsider the following scenario with $3$ readers and $2$ writers. Reader $R\\_1$ performs entry (acquires $mutex$, observes $writerActive = \\text{false}$, increments $rw\\_count$ to $1$, releases $mutex$) and begins reading. Readers $R\\_2$ and $R\\_3$ subsequently enter and increment $rw\\_count$ to $3$. Writer $W\\_1$ attempts to enter and waits because $rw\\_count > 0$. During its read, $R\\_2$ encounters an input/output error that triggers an exception, causing $R\\_2$ to return immediately without executing the reader exit routine. As a result, $rw\\_count$ remains at $3$ even after $R\\_2$ has stopped reading, and $W\\_1$ continues to wait. Over time, more writers arrive and get stuck, waiting for $rw\\_count$ to become $0$. No thread manipulates $writerActive$ in this period.\n\nUsing only the fundamental definitions of mutual exclusion, condition variables, and the stated invariant $rw\\_count = \\text{number of active readers}$, analyze why writers get stuck and identify the most robust correction that preserves safety (no concurrent reading during writing) and liveness (writers eventually proceed when readers finish), even in the presence of exceptions in the reader code.\n\nWhich option both correctly diagnoses the fault and proposes a correct fix pattern?\n\nA. The problem is that $rw\\_count$ increments and decrements are not atomic; the fix is to make $rw\\_count$ atomic so exceptions cannot interfere with updates.\n\nB. The problem is that the exceptional path skips the reader exit, violating the invariant $rw\\_count = \\text{number of active readers}$; the fix is to wrap the read section in a try-finally: after incrementing $rw\\_count$ under $mutex$ and releasing $mutex$, execute the read in the try block, and in the finally block reacquire $mutex$, decrement $rw\\_count$, and if $rw\\_count = 0$ signal $canWrite$, then release $mutex$.\n\nC. The problem is that writers wait on the wrong condition variable; the fix is for writers to wait on $canRead$ so that readers can wake writers when they finish.\n\nD. The problem is the ordering of the reader increment relative to checking $writerActive$; the fix is to move the increment of $rw\\_count$ to after the read completes, so exceptions cannot leave $rw\\_count$ elevated.\n\nE. The problem is lack of timeouts in writer waits; the fix is to add a timeout so that writers proceed after a bounded delay regardless of $rw\\_count$.",
            "solution": "The user wants me to act as a STEM professor and solve a computer science problem related to the readers-writers problem.\n\nMy plan is as follows:\n1.  **Validate the problem statement**. I will extract all givens verbatim and check for scientific soundness, well-posedness, and other criteria.\n2.  **If valid, derive the solution from first principles**. I will analyze the cause of the failure mode described and determine the correct architectural pattern to prevent it while preserving correctness (safety and liveness).\n3.  **Evaluate each option**. I will systematically analyze options A, B, C, D, and E against the derived solution and the principles of concurrent programming.\n4.  **Format the output**. I will adhere strictly to all formatting rules, especially the mandatory use of LaTeX for all mathematical and symbolic entities.\n\n### Step 1: Extract Givens\n\n*   **Synchronization Primitives**: A single mutual exclusion lock `$mutex$`, and two condition variables `$canRead$` and `$canWrite$`.\n*   **Shared State**: An integer counter `$rw\\_count$` and a Boolean `$writerActive$`.\n*   **Intended Invariant**: `$rw\\_count$` equals the number of currently active reader threads.\n*   **Writer Precondition**: Writers may proceed only when `$rw\\_count = 0$` and `$writerActive = \\text{false}$`.\n*   **Reader Entry Protocol**: Acquire `$mutex$`, wait while `$writerActive = \\text{true}$`, increment `$rw\\_count$`, and release `$mutex$`.\n*   **Reader Exit Protocol**: Acquire `$mutex$`, decrement `$rw\\_count$`, signal `$canWrite$` if `$rw\\_count = 0$`, and release `$mutex$`.\n*   **Writer Entry Protocol**: Acquire `$mutex$`, wait while `$(rw\\_count > 0) \\lor (writerActive = \\text{true})$`, set `$writerActive = \\text{true}$`, and release `$mutex$`.\n*   **Writer Exit Protocol**: Acquire `$mutex$`, set `$writerActive = \\text{false}$`, broadcast `$canRead$` and signal `$canWrite$`, then release `$mutex$`.\n*   **Scenario**:\n    *   A system with `$3$` readers (`$R_1$`, `$R_2$`, `$R_3$`) and `$2$` writers.\n    *   `$R_1$`, `$R_2$`, and `$R_3$` successfully execute the reader entry protocol. `$rw\\_count$` becomes `$3$`.\n    *   A writer `$W_1$` attempts entry and blocks, waiting for `$rw\\_count` to become `$0$`.\n    *   Reader `$R_2$` encounters an I/O error, which triggers an exception, causing it to terminate its task immediately.\n    *   Critically, `$R_2$` **does not execute the reader exit routine**.\n    *   As a consequence, `$rw\\_count$` remains elevated. Even after `$R_1$` and `$R_3$` exit, `$rw\\_count$` will be `$1$`, not `$0$`.\n    *   Writers, including `$W_1$`, continue to wait indefinitely.\n\n### Step 2: Validate Using Extracted Givens\n\n*   **Scientific Grounding**: The problem is situated within the domain of concurrent programming and operating systems, dealing with the classic readers-writers problem. The primitives used (`mutex`, condition variables) and the failure mode (exception-safety) are standard, well-understood concepts in computer science. The problem is scientifically and technically sound.\n*   **Well-Posed**: The problem describes a specific implementation, a specific failure scenario, and asks for a diagnosis and a robust fix. The objectives for the fix (preserving safety and liveness) are clearly stated. A definite conceptual solution can be derived.\n*   **Objectivity**: The description is factual and devoid of subjective or ambiguous language. The behavior of the system is described deterministically based on the rules of the protocol.\n*   **Flaw Checklist**: The problem does not violate any of the specified flaw conditions. It is not unsound, incomplete, unrealistic, or ill-posed. The scenario of an exception short-circuiting cleanup logic is a common and serious bug in real-world systems, making this a relevant and non-trivial problem.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. I will proceed with the solution.\n\n### Derivation of Solution\n\nThe core of the readers-writers problem is to maintain invariants that guarantee safety and liveness. The safety invariant for this \"reader-preference\" or \"shared-read-lock\" pattern is twofold:\n$1$. Multiple readers are allowed concurrently: `(number of writers) = 0`.\n$2$. A single writer is allowed exclusively: `(number of writers) = 1` $\\implies$ `(number of readers) = 0`.\n\nThe provided implementation uses state variables `$rw\\_count$` and `$writerActive$` to enforce these invariants. The logic relies on the intended invariant: `$rw\\_count$` accurately reflects the number of threads currently performing a read operation.\n\n**Analysis of the Fault**:\nThe problem states that reader `$R_2$`, upon encountering an exception, \"return[s] immediately without executing the reader exit routine.\"\n\nThe reader entry routine performs the following state change: `$rw\\_count \\leftarrow rw\\_count + 1$.\nThe reader exit routine is responsible for the corresponding state change: `$rw\\_count \\leftarrow rw\\_count - 1$.\n\nWhen `$R_2$` terminates without executing the exit routine, the increment to `$rw\\_count$` is never undone. The variable `$rw\\_count$` now permanently over-reports the number of active readers. The system state becomes inconsistent with physical reality; the invariant `$rw\\_count = \\text{number of active readers}$` is violated.\n\nThe writer entry protocol includes the condition `wait while ($rw\\_count > 0$)`. Because `$rw\\_count$` will never return to `$0$` (it is permanently offset by `$1$`), the condition for a writer to proceed will never be met. This leads to starvation of all writer threads.\n\n**Principle of a Robust Correction**:\nThe fundamental issue is a failure to guarantee resource cleanup or state restoration in the presence of exceptional control flow. The \"resource\" here is the claim on the read lock, represented by the incremented `$rw\\_count$`. The principle to apply is that any action that acquires a resource or modifies a shared state must be paired with a corresponding release/restore action that is guaranteed to execute, regardless of whether the intervening code completes normally or terminates due to an exception.\n\nIn most modern programming languages that support exceptions, this guarantee is provided by a `try...finally` block (or `try...catch...finally`). The code that might throw an exception is placed in the `try` block, and the cleanup code is placed in the `finally` block. The semantics of `finally` guarantee its execution upon exiting the `try` block for any reason. Another pattern achieving the same goal is Scope-Bound Resource Management (SBRM), also known as Resource Acquisition Is Initialization (RAII) in C++.\n\nThe correct structure for a robust reader implementation is:\n$1$. Reader Entry:\n   - Acquire `$mutex$`.\n   - Wait for permission to read (e.g., `while ($writerActive$) { canRead.wait(mutex); }`).\n   - Increment `$rw\\_count$`.\n   - Release `$mutex$`.\n$2$. **Protected Read Operation**:\n   - `try`\n      - Perform the read operation (this is where the I/O error and exception can occur).\n   - `finally`\n      - Execute the Reader Exit protocol:\n         - Acquire `$mutex$`.\n         - Decrement `$rw\\_count$`.\n         - If `$rw\\_count = 0$`, signal `$canWrite$`.\n         - Release `$mutex$`.\n\nThis structure ensures that for every successful increment of `$rw\\_count$`, a decrement is guaranteed to occur, thus preserving the integrity of the shared state and the correctness of the protocol.\n\n### Option-by-Option Analysis\n\n**A. The problem is that `$rw\\_count$` increments and decrements are not atomic; the fix is to make `$rw\\_count$` atomic so exceptions cannot interfere with updates.**\n- **Analysis**: The problem states that updates to `$rw\\_count$` are performed while holding the `$mutex$`. This already guarantees that the increment and decrement operations are atomic with respect to other threads. The failure is not that the increment operation itself is interrupted, but that the entire *exit routine* (which contains the decrement) is skipped due to the exception. Making `$rw\\_count$` a hardware-supported atomic type (like `std::atomic` in C++) does not solve this problem, as the line of code that performs the atomic decrement would still be skipped.\n- **Verdict**: **Incorrect**.\n\n**B. The problem is that the exceptional path skips the reader exit, violating the invariant `$rw\\_count = \\text{number of active readers}$`; the fix is to wrap the read section in a try-finally: after incrementing `$rw\\_count$` under `$mutex$` and releasing `$mutex$`, execute the read in the try block, and in the finally block reacquire `$mutex$`, decrement `$rw\\_count$`, and if `$rw\\_count = 0$` signal `$canWrite$`, then release `$mutex$`.**\n- **Analysis**: This option provides a perfect diagnosis: the exceptional path skips the cleanup code, leading to a broken invariant. The proposed solution is to use a `try-finally` block to bracket the fallible read operation. The code placed in the `finally` block is the complete reader exit protocol. This architectural pattern is the canonical and robust solution for ensuring resource deallocation and state consistency in the face of exceptions. This matches the solution derived from first principles.\n- **Verdict**: **Correct**.\n\n**C. The problem is that writers wait on the wrong condition variable; the fix is for writers to wait on `$canRead$` so that readers can wake writers when they finish.**\n- **Analysis**: In the described protocol, readers departing signal `$canWrite$`, and writers wait on `$canWrite$`. This is a logical and correct pairing. The variable `$canRead$` is used by an exiting writer to signal waiting readers. Having writers wait on `$canRead$` would be semantically incorrect. Furthermore, the problem is not that the writer isn't being woken up; the problem is that the condition it is waiting for (`$rw\\_count = 0$`) can never become true due to state corruption. Changing the condition variable does not address the root cause.\n- **Verdict**: **Incorrect**.\n\n**D. The problem is the ordering of the reader increment relative to checking `$writerActive$`; the fix is to move the increment of `$rw\\_count$` to after the read completes, so exceptions cannot leave `$rw\\_count$` elevated.**\n- **Analysis**: This fix attempts to solve the state corruption problem but introduces a severe safety violation. If `$rw\\_count$` is only incremented *after* the read is complete, then during the entire read operation, `$rw\\_count$` does not account for this active reader. If another thread, a writer, attempts to enter, it may see `$rw\\_count = 0$` (if no other readers are active), and it will proceed to write. This results in a writer operating concurrently with a reader, which violates the fundamental safety requirement of the readers-writers problem.\n- **Verdict**: **Incorrect**.\n\n**E. The problem is lack of timeouts in writer waits; the fix is to add a timeout so that writers proceed after a bounded delay regardless of `$rw\\_count$`.**\n- **Analysis**: This \"fix\" suggests that a writer, after waiting for some period, should ignore the wait condition (`$rw\\_count > 0$`) and proceed. This would cause the writer to start writing while readers are still active, resulting in a race condition and a catastrophic safety violation. While timeouts can be used to detect and handle liveness failures (like deadlock or starvation), they do not grant a thread permission to violate a safety invariant. A proper use of a timeout would be to log an error, retry, or escalate, not to blindly proceed. This option papers over the liveness problem by destroying the safety of the protocol.\n- **Verdict**: **Incorrect**.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Having examined low-level bugs and robust implementation patterns, we now scale up to the system level. In this final practice, you will act as a system designer and implement a complete, discrete-time simulator for a readers-writers scheduler with a specific writer-preference policy . This exercise will challenge you to translate a formal set of rules into a working program and analyze key performance metrics like makespan and concurrency.",
            "id": "2422634",
            "problem": "You are given a shared-memory parallel system with a single logical shared object accessed by two types of operations: readers and writers. Each operation is a request characterized by an arrival time and a service duration, both measured in discrete unitless time steps. An operation, once started, occupies the shared object over a half-open interval from its start time to its start time plus its duration, that is, over the interval $\\left[ s_i, s_i + d_i \\right)$ where $s_i$ is the start time and $d_i$ is the duration.\n\nThe system must satisfy the following semantics and constraints.\n\n1) Safety constraints. Let $R(t)$ denote the number of active readers at time $t$ and let $W(t) \\in \\{0,1\\}$ denote the number of active writers at time $t$. The system must ensure that for every time $t$, if $W(t) = 1$ then $R(t) = 0$, and additionally there is never more than one writer active simultaneously. Multiple readers may be active concurrently when no writer is active.\n\n2) Fairness constraint for writers (writer starvation freedom). Once a writer has arrived and is waiting to start, no new reader may start until there are no waiting writers. Formally, if at time $t$ there exists a writer $j$ with arrival time $a_j \\le t$ whose start time $s_j$ satisfies $s_j > t$, then no reader may start at time $t$.\n\n3) Deterministic scheduling semantics. Time progresses over a discrete set of decision times. At each decision time $t$, the following ordering within the instant $t$ is assumed: first, all operations that have end time exactly $t$ complete and release the resource; second, all operations whose arrival time equals $t$ are considered to have arrived and joined the waiting set; third, new starts are determined according to the following rule:\n   a) If there is at least one waiting writer and there are no active readers and no active writer, then the unique earliest-arrived waiting writer must start at time $t$.\n   b) Otherwise, if there are no waiting writers and no active writer, then all waiting readers must start at time $t$.\n   c) Otherwise, no new operation starts at time $t$.\nIn case multiple requests share the same arrival time, their relative order is the order given in the input for that test case. An operation’s start time must be no earlier than its arrival time.\n\nYour task is to implement a program that, given a finite list of requests for each test case, constructs start times for all requests that obey the semantics above and then computes the following three quantities for each test case:\n- A boolean indicating whether the produced schedule satisfies both the safety constraints and the writer fairness constraint defined above.\n- The maximum number of concurrent readers, that is, $\\max_{t} R(t)$ over the schedule.\n- The makespan, defined as the difference between the latest completion time $\\max_i \\left( s_i + d_i \\right)$ and the earliest arrival time $\\min_i a_i$.\n\nTest suite. Use the following $5$ test cases. Each test case is a list of requests. Each request is a triple $(\\text{type}, a, d)$ where $\\text{type} \\in \\{\\text{R}, \\text{W}\\}$, $a$ is the arrival time, and $d$ is the duration. For equal arrival times within a test case, the order in which the requests are listed below is the required tie-breaking order.\n\n- Test case $1$:\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 3),\\, (\\text{W},\\, 2,\\, 4),\\, (\\text{R},\\, 6,\\, 2),\\, (\\text{W},\\, 6,\\, 1)]$.\n\n- Test case $2$:\n  $[(\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 0,\\, 2),\\, (\\text{R},\\, 1,\\, 1)]$.\n\n- Test case $3$:\n  $[(\\text{W},\\, 0,\\, 2),\\, (\\text{W},\\, 1,\\, 2),\\, (\\text{W},\\, 3,\\, 1)]$.\n\n- Test case $4$:\n  $[(\\text{R},\\, 0,\\, 5),\\, (\\text{R},\\, 1,\\, 5),\\, (\\text{W},\\, 2,\\, 2),\\, (\\text{R},\\, 2,\\, 1),\\, (\\text{R},\\, 3,\\, 1)]$.\n\n- Test case $5$:\n  $[(\\text{R},\\, 0,\\, 1),\\, (\\text{W},\\, 0,\\, 1)]$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a three-element list $[\\text{valid}, \\text{max\\_readers}, \\text{makespan}]$ in that order, with no spaces. For example, a valid output shape is\n$[[\\text{True},2,7],[\\text{False},1,3],[\\text{True},3,5],[\\text{True},2,4],[\\text{True},1,1]]$\nbut with the actual values determined by your implementation for the specified test suite.",
            "solution": "The problem requires the simulation of a deterministic scheduling policy for a readers-writers problem on a shared resource. The solution involves two main stages: first, simulating the system over discrete time steps to generate a schedule, and second, analyzing this schedule to compute the required metrics.\n\n**1. Simulation of the Scheduling Policy**\n\nThe core of the task is to implement a discrete-time simulator that strictly adheres to the given scheduling semantics. The state of the system at any time `t` can be described by the set of active operations and the set of waiting operations.\n\nLet's formalize the state variables:\n- A list of unprocessed requests, sorted by their arrival times `a_i` and, for ties, by their order in the input. Each request `i` is a tuple of (type, `a_i`, `d_i`). We will augment this with a unique ID and a field for the start time `s_i`.\n- A queue of waiting readers, `waiting_readers`.\n- A queue of waiting writers, `waiting_writers`, maintained in first-in-first-out (FIFO) order based on arrival.\n- A list of active readers, `active_readers`.\n- A variable for the single active writer, `active_writer`.\n\nThe simulation proceeds by incrementing a time variable `t` starting from $t=0$. The simulation terminates when all requests have arrived, started, and completed.\n\nAt each time step `t`, the following sequence of actions must be performed, as specified in the problem statement:\n\n**Step 1: Process Completions**\nAny active operation `i` whose completion time `s_i + d_i` is equal to `t` finishes its execution.\n- If an active writer `j` has `s_j + d_j = t`, the resource is released by setting `active_writer` to null.\n- Any active readers `k` with `s_k + d_k = t` are removed from the `active_readers` list.\n\n**Step 2: Process Arrivals**\nAll requests `i` with an arrival time `a_i = t` are moved from the unprocessed list to the appropriate waiting queue (`waiting_readers` or `waiting_writers`). The tie-breaking rule (input order for requests with the same arrival time) must be respected when adding to the queues.\n\n**Step 3: Make Scheduling Decisions**\nNew operations are started based on the current state of active and waiting queues, following a strict set of rules:\n- **Rule (a):** If `waiting_writers` is not empty AND `active_readers` is empty AND `active_writer` is null, the earliest-arrived writer from `waiting_writers` is dequeued and started. Its start time `s_i` is set to `t`, and it becomes the `active_writer`.\n- **Rule (b):** Otherwise, if `waiting_writers` is empty AND `active_writer` is null, all readers in `waiting_readers` are started. For each of these readers, its start time `s_i` is set to `t`, and it is moved to the `active_readers` list. The `waiting_readers` queue is then cleared.\n- **Rule (c):** In all other cases (e.g., the resource is held by a writer, or held by readers while a writer is waiting), no new operation can start at time `t`.\n\nThis `t++` simulation loop continues until all requests are completed.\n\n**2. Analysis of the Generated Schedule**\n\nOnce the simulation is complete, all requests will have an assigned start time `s_i`. We then analyze this complete schedule to compute three quantities for each test case.\n\n**A. Schedule Validity**\nThe problem requires a boolean indicating if the generated schedule satisfies the safety and writer-fairness constraints. The provided scheduling rules are designed to produce a valid schedule by construction. Therefore, this check serves as a verification of the simulator's implementation.\n- **Safety Check:** A schedule is safe if at no time `t` a writer is active concurrently with any other operation (reader or writer), and there is never more than one active writer. This can be verified by iterating through time and checking the sets of active operations.\n- **Fairness Check:** The writer-starvation-freedom rule states that no new reader may start at time `t` if a writer is waiting. This is checked by examining each reader's start time `s_k`. At `t = s_k`, we verify that there was no writer `j` for which `a_j \\le s_k` and `s_j > s_k`.\n\nIf both checks pass, the schedule is valid. Given the deterministic rules, this should always be `True` for a correct implementation.\n\n**B. Maximum Concurrent Readers**\nThis is the maximum value of `R(t)` over the entire duration of the schedule, where `R(t)` is the number of active readers at time `t`. This can be computed by analyzing the schedule. An efficient method is to create a list of `START_READER` and `END_READER` events at times `s_i` and `s_i+d_i` respectively. By sorting these events and sweeping through time, we can track the current number of active readers and find its maximum.\n\n**C. Makespan**\nThe makespan is defined as the total time elapsed from the first arrival to the last completion. It is calculated as:\n$$\n\\text{Makespan} = \\left( \\max_{i} (s_i + d_i) \\right) - \\left( \\min_{i} a_i \\right)\n$$\nThe minimum arrival time `min(a_i)` is found from the input data. The maximum completion time `max(s_i + d_i)` is determined from the generated schedule.\n\nBy following this procedure for each test case, we can systematically derive the required results. The use of a simple time-stepping simulation ensures a direct and faithful implementation of the problem's formal specification.\n\n```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the readers-writers scheduling problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [('R', 0, 5), ('R', 1, 3), ('W', 2, 4), ('R', 6, 2), ('W', 6, 1)],\n        # Test case 2\n        [('R', 0, 2), ('R', 0, 2), ('R', 1, 1)],\n        # Test case 3\n        [('W', 0, 2), ('W', 1, 2), ('W', 3, 1)],\n        # Test case 4\n        [('R', 0, 5), ('R', 1, 5), ('W', 2, 2), ('R', 2, 1), ('R', 3, 1)],\n        # Test case 5\n        [('R', 0, 1), ('W', 0, 1)],\n    ]\n\n    all_results = []\n    for case_idx, case_data in enumerate(test_cases):\n        # 1. Initialize requests with unique IDs and start times\n        requests = []\n        for i, (req_type, arrival, duration) in enumerate(case_data):\n            requests.append({\n                'id': i,\n                'type': req_type,\n                'a': arrival,\n                'd': duration,\n                's': -1,  # Start time, -1 indicates not started\n            })\n\n        # 2. Simulation\n        time = 0\n        num_completed = 0\n        total_requests = len(requests)\n        \n        arrived_but_not_waiting_requests = sorted(requests, key=lambda r: (r['a'], r['id']))\n        arrived_idx = 0\n\n        waiting_readers = deque()\n        waiting_writers = deque()\n        active_readers = []\n        active_writer = None\n\n        while num_completed  total_requests:\n            # Step 1: Process completions at the beginning of time t\n            completed_this_step = []\n            if active_writer and (active_writer['s'] + active_writer['d'] == time):\n                completed_this_step.append(active_writer)\n                active_writer = None\n\n            remaining_active_readers = []\n            for r in active_readers:\n                if r['s'] + r['d'] == time:\n                    completed_this_step.append(r)\n                else:\n                    remaining_active_readers.append(r)\n            active_readers = remaining_active_readers\n            \n            num_completed += len(completed_this_step)\n\n            # Step 2: Process arrivals at time t\n            while arrived_idx  total_requests and arrived_but_not_waiting_requests[arrived_idx]['a'] == time:\n                req = arrived_but_not_waiting_requests[arrived_idx]\n                if req['type'] == 'R':\n                    waiting_readers.append(req)\n                else: # 'W'\n                    waiting_writers.append(req)\n                arrived_idx += 1\n\n            # Step 3: Make scheduling decisions\n            # Rule a: Start a writer if possible\n            if waiting_writers and not active_readers and not active_writer:\n                writer_to_start = waiting_writers.popleft()\n                writer_to_start['s'] = time\n                active_writer = writer_to_start\n            # Rule b: Otherwise, start readers if possible\n            elif not waiting_writers and not active_writer:\n                while waiting_readers:\n                    reader_to_start = waiting_readers.popleft()\n                    reader_to_start['s'] = time\n                    active_readers.append(reader_to_start)\n            # Rule c: Otherwise, wait\n            \n            time += 1\n        \n        # 3. Analysis of the schedule\n        schedule = requests\n        is_valid = True\n        \n        # Safety and Max Readers calculation\n        max_time = 0\n        if schedule:\n            max_time = max(r['s'] + r['d'] for r in schedule)\n\n        max_readers_count = 0\n        for t in range(max_time):\n            current_readers = [r for r in schedule if r['type'] == 'R' and r['s'] = t  r['s'] + r['d']]\n            current_writers = [r for r in schedule if r['type'] == 'W' and r['s'] = t  r['s'] + r['d']]\n            \n            num_r = len(current_readers)\n            num_w = len(current_writers)\n            \n            max_readers_count = max(max_readers_count, num_r)\n\n            if num_w > 1 or (num_w > 0 and num_r > 0):\n                is_valid = False\n                break\n        \n        # Fairness check\n        if is_valid:\n            for reader in schedule:\n                if reader['type'] == 'R':\n                    start_time = reader['s']\n                    for writer in schedule:\n                        if writer['type'] == 'W':\n                            # Writer was waiting if it arrived at or before reader start, and started after\n                            if writer['a'] = start_time and writer['s'] > start_time:\n                                is_valid = False\n                                break\n                    if not is_valid:\n                        break\n        \n        # Makespan calculation\n        min_arrival_time = min(r['a'] for r in schedule) if schedule else 0\n        max_completion_time = max(r['s'] + r['d'] for r in schedule) if schedule else 0\n        makespan = max_completion_time - min_arrival_time\n\n        all_results.append([is_valid, max_readers_count, makespan])\n\n    # Final formatting\n    result_str = \",\".join([f\"[{v},{r},{m}]\" for v, r, m in all_results])\n    return f\"[{result_str}]\"\n\n\n# The problem asks for the program's output, so we print it.\n# print(solve())\n```",
            "answer": "[[True,2,12],[True,3,2],[True,0,5],[True,2,9],[True,1,2]]"
        }
    ]
}