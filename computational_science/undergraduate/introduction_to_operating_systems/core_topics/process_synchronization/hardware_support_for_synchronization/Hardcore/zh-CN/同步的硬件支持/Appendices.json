{
    "hands_on_practices": [
        {
            "introduction": "将高级内存模型（如 C11 的获取/释放语义）与底层硬件指令联系起来，是编写正确且可移植的并发代码的关键。本练习提供了一个具体的场景——屏障同步算法——来探索 x86 和 ARM 等不同架构如何实现这些内存排序保证。通过分析所需显式内存屏障指令的数量，您将更深刻地理解不同硬件内存模型中固有的性能权衡 。",
            "id": "3647015",
            "problem": "您正在为一个遵循 2011 年 C 编程语言标准 (C11) 内存模型的系统设计一个基于共享原子计数器的可移植屏障。$n$ 个工作线程中的每一个都通过原子性地增加一个共享计数器来参与屏障，最后一个到达的线程通过发布一个新的代（generation）值来释放其他线程。其意图是仅使用 acquire 和 release 语义。您必须将这些语义映射到一个目标硬件架构上，并计算所需的显式 fence 指令数量以及其他关键操作的计数。\n\n基本原理：\n- C11 内存模型定义了 happens-before 关系和 acquire/release 同步。一个 release 操作与一个读取该 release 结果的 acquire 操作“同步于”（synchronizes-with），如果 $A$ 同步于 $B$，则 $A$ happens-before $B$。一次 acquire 加载可阻止后续内存操作被重排序到其之前。一次 release 存储可阻止之前的内存操作被重排序到其之后。一次 acquire-release 读-改-写 (RMW) 操作结合了这两种属性。\n- 硬件内存模型提供了实现这些抽象保证的可执行原语：\n  - 全局存储顺序 (TSO) 硬件，例如广泛部署的 x$86$ TSO，保证加载和存储不会被重排序，除非后续的加载由于存储缓冲区的存在，可能在全局顺序上先于之前的存储被观察到；然而，锁定的 RMW 是全局有序的，并且相对于其他核心，同时起到 acquire 和 release 的作用。\n  - 弱序硬件，例如 Advanced RISC Machines 第 7 版 (ARMv$7$)，允许大量的重排序，并且需要显式屏障才能用普通的加载和存储实现 C11 排序；独占加载/存储原语本身在没有屏障的情况下，不强制施加 acquire 或 release 语义。\n  - Advanced RISC Machines 第 8 版 (ARMv$8$) 提供了加载、存储和独占加载/存储的 acquire 和 release 变体，它们直接实现 C11 的 acquire/release 语义，无需额外的屏障。\n\n屏障算法模型：\n- 共享原子变量：一个初始化为 $0$ 的计数器 $C$，和一个初始化为 $0$ 的代标志 $G$。\n- 每个带有局部代值 $g$ 的线程执行：\n  $$\n  r \\leftarrow \\operatorname{fetch\\_add}(C, 1,\\ \\text{acquire-release})\n  $$\n  如果 $r + 1 = n$，则它是最后一个线程：\n  - 使用 release 存储重置计数器并发布下一代：\n    $$\n    \\operatorname{store}(C, 0,\\ \\text{release}),\\quad \\operatorname{store}(G, g+1,\\ \\text{release})\n    $$\n  否则，它将自旋等待，直到使用 acquire 加载观察到新的代：\n    $$\n    \\text{repeat}\\ \\ell \\leftarrow \\operatorname{load}(G,\\ \\text{acquire})\\ \\text{until}\\ \\ell = g+1\n    $$\n\n到硬件的映射约束：\n- 架构代码 $a$ 选择映射：\n  - $a = 0$: x$86$ TSO。将 acquire 加载映射为普通加载，将 release 存储映射为普通存储，将 acquire-release RMW 映射为锁定的 RMW；acquire/release 语义不需要显式 fence。\n  - $a = 1$: ARMv$7$。没有原生的 acquire/release 变体。使用显式屏障：\n    - Acquire 加载：一个普通加载后跟一个数据内存屏障，记为 $\\mathrm{DMB}$。\n    - Release 存储：一个普通存储前跟一个 $\\mathrm{DMB}$。\n    - 使用独占加载/存储实现的 Acquire-release RMW 必须用两个 $\\mathrm{DMB}$ 包围，以获得双向排序保证。\n  - $a = 2$: ARMv$8$。对加载、存储和 acquire-release RMW 使用原生的 acquire/release 指令；acquire/release 语义不需要显式 $\\mathrm{DMB}$。\n\n计数模型与所需输出：\n- 为 $n \\ge 1$ 的单个屏障阶段定义以下计数：\n  - 执行的原子 RMW 操作总数，记为 $R(n)$。\n  - 成功观察到已发布代（generation）的 acquire 加载总数，记为 $L(n)$。\n  - 对代标志的 release 存储总数，记为 $S(n)$。\n  - 在所选映射下所需的显式 fence 指令总数，记为 $B(a, n)$，其中一个 fence 是一个 `mfence` 或等效的全架构内存屏障指令（如 `DMB`）；在原生 acquire/release 指令就足够的架构上，$B(a,n)$ 计为 $0$。\n\n计数假设：\n- $n$ 个线程中的每一个都恰好执行一次 acquire-release RMW 增量操作。\n- 恰好一个线程（最后到达的）执行 release 存储来重置 $C$ 和推进 $G$。\n- 恰好 $n - 1$ 个线程通过 acquire 加载观察到新的代；每个等待线程只计算成功的见证加载，不计算短暂的自旋。\n- 在 ARMv$7$ 上：\n  - 每个 acquire-release RMW 恰好贡献 $2$ 个显式屏障。\n  - 单个 release 存储恰好贡献 $1$ 个显式屏障。\n  - 每个成功的 acquire 加载恰好贡献 $1$ 个显式屏障。\n\n任务：\n- 使用上述基础和假设，推导出 $R(n)$、$L(n)$、$S(n)$ 和 $B(a, n)$ 的表达式。\n- 实现一个完整、可运行的程序，为下面的测试套件中的每个测试用例计算元组 $[B(a,n), R(n), L(n), S(n)]$，并将所有结果打印为单行。\n\n测试套件：\n- 使用以下 $(a, n)$ 对：\n  - $(0, 4)$\n  - $(1, 4)$\n  - $(2, 4)$\n  - $(1, 1)$\n  - $(0, 64)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的结果列表，每个结果都是一个按 $[B, R, L, S]$ 顺序排列的四个整数的列表，所有内容都包含在一对单独的方括号中。例如，格式为\n  $$\n  [[B_1,R_1,L_1,S_1],[B_2,R_2,L_2,S_2],\\dots]\n  $$\n- 输出中不得有空格。唯一可接受的类型是整数和整数列表。",
            "solution": "**问题验证**\n\n首先对问题陈述进行严格的验证过程。\n\n**步骤 1：提取的已知条件**\n- **系统**：具有 acquire/release 语义的 C11 内存模型。\n- **算法**：一个用于 $n$ 个线程的屏障，使用共享原子变量：计数器 $C$（初始为 $0$）和代标志 $G$（初始为 $0$）。\n- **线程逻辑（局部代 $g$）**：\n  $$\n  r \\leftarrow \\operatorname{fetch\\_add}(C, 1,\\ \\text{acquire-release})\n  $$\n  如果 $r + 1 = n$ (最后一个线程):\n  $$\n  \\operatorname{store}(C, 0,\\ \\text{release}),\\quad \\operatorname{store}(G, g+1,\\ \\text{release})\n  $$\n  否则 (等待线程):\n  $$\n  \\text{repeat}\\ \\ell \\leftarrow \\operatorname{load}(G,\\ \\text{acquire})\\ \\text{until}\\ \\ell = g+1\n  $$\n- **硬件映射（架构代码 $a$）**：\n  - $a = 0$ (x$86$ TSO)：映射到普通加载/存储和锁定的 RMW。无显式 fence。\n  - $a = 1$ (ARMv$7$)：需要显式的数据内存屏障（$\\mathrm{DMB}$）。\n    - Acquire 加载：普通加载后跟 $1$ 个 $\\mathrm{DMB}$。\n    - Release 存储：普通存储前有 $1$ 个 $\\mathrm{DMB}$。\n    - Acquire-release RMW：由 $2$ 个 $\\mathrm{DMB}$ 包围。\n  - $a = 2$ (ARMv$8$)：使用原生的 acquire/release 指令。无显式 fence。\n- **对于 $n \\ge 1$ 需要计数的量**：\n  - $R(n)$：原子 RMW 操作总数。\n  - $L(n)$：成功的 acquire 加载总数。\n  - $S(n)$：对 $G$ 的 release 存储总数。\n  - $B(a, n)$：显式 fence 指令总数。\n- **计数假设**：\n  - $n$ 个线程中的每一个都执行一次 RMW。\n  - 一个最后到达的线程执行 release 存储。\n  - $n - 1$ 个线程各自执行一次成功的 acquire 加载。\n  - 对于 $a = 1$ (ARMv$7$)：\n    - 每次 RMW 消耗 $2$ 个屏障。\n    - “单个 release 存储恰好贡献 $1$ 个显式屏障。”\n    - 每次成功的 acquire 加载消耗 $1$ 个屏障。\n\n**步骤 2：已知条件的验证**\n该问题在科学上基于计算机体系结构和并发编程的既定原则，特别是 C11 内存模型及其在不同硬件架构（TSO vs. 弱序）上的实现。该屏障算法是一个标准结构。问题是适定的，提供了推导唯一解所需的所有必要定义、约束和计数规则。语言是客观和正式的。\n\nARMv$7$ 的计数假设中存在一个微小的歧义：算法显示了两次 release 存储（$\\operatorname{store}(C, 0, \\text{release})$ 和 $\\operatorname{store}(G, g+1, \\text{release})$），而假设指出“单个 release 存储恰好贡献 $1$ 个显式屏障”。这可以通过解释为在两次存储操作之前发出单个 `DMB` 指令来解决，从而满足两者的 release 语义。这是一种常见且高效的实现模式，并使问题陈述内部一致。因此，该问题不被认为是矛盾的或不适定的。它没有违反任何无效性标准。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将根据提供的模型推导出解决方案。\n\n**表达式推导**\n\n为 $n \\ge 1$ 的 $n$ 线程系统推导量 $R(n)$、$L(n)$、$S(n)$ 和 $B(a, n)$。\n\n**1. 原子 RMW 操作总数，$R(n)$**\n根据算法和计数假设，参与的 $n$ 个线程中的每一个都对计数器 $C$ 执行恰好一次 $\\operatorname{fetch\\_add}$ 操作。此操作是一个原子读-改-写（RMW）。\n因此，RMW 操作的总数为：\n$$\nR(n) = n\n$$\n\n**2. 成功的 acquire 加载总数，$L(n)$**\n算法规定，任何不是最后一个到达的线程都必须等待代标志 $G$ 发生变化。对于一个有 $n$ 个线程的系统，有 $n-1$ 个这样的等待线程。计数模型规定，我们只计算这些等待线程中每一个的最终成功 acquire 加载。如果 $n=1$，单个线程就是最后一个线程，没有线程等待；等待线程的数量是 $1 - 1 = 0$，这是正确的。\n因此，成功的 acquire 加载总数为：\n$$\nL(n) = n - 1\n$$\n\n**3. 对代标志的 release 存储总数，$S(n)$**\n只有最后一个到达屏障的线程会更新共享状态。这包括重置计数器 $C$ 并通过存储到 $G$ 来发布新的代。量 $S(n)$ 特指对代标志 $G$ 的 release 存储次数。最后一个线程恰好执行一次这样的存储：$\\operatorname{store}(G, g+1, \\text{release})$。这对任何 $n \\ge 1$ 都成立。\n因此，对 $G$ 的 release 存储总数是恒定的：\n$$\nS(n) = 1\n$$\n\n**4. 显式 fence 指令总数，$B(a, n)$**\n显式 fence 指令的数量取决于架构代码 $a$。\n\n**情况 $a=0$ (x$86$ TSO) 和 $a=2$ (ARMv$8$)**:\n对于 x$86$ TSO 和 ARMv$8$，映射规则规定 C11 acquire/release 语义分别使用锁定指令或原生 acquire/release 指令变体来实现。在这两种情况下，都不需要像 `mfence` 或 `DMB` 这样的显式、独立的 fence 指令。\n$$\nB(0, n) = 0\n$$\n$$\nB(2, n) = 0\n$$\n\n**情况 $a=1$ (ARMv$7$)**:\n对于 ARMv$7$，需要显式的 `DMB` 屏障。我们根据计数假设对来自三种操作类型的屏障进行求和。\n- **来自 RMW 的屏障**：共有 $R(n) = n$ 次 RMW 操作。每次 `acquire-release` RMW 需要 $2$ 个 `DMB` 屏障。总贡献为 $2 \\times R(n) = 2n$。\n- **来自 Release 存储的屏障**：最后一个线程执行两次 release 存储。如验证期间所确定的，假设“单个 release 存储恰好贡献 $1$ 个显式屏障”被解释为最后一个线程的整个 release-store 阶段消耗一个屏障（即，一个 `DMB` 为随后的两个存储提供 fence）。这贡献了 $1$ 个屏障。\n- **来自 Acquire 加载的屏障**：共有 $L(n) = n-1$ 次成功的 acquire 加载。每次 `acquire` 加载需要 $1$ 个 `DMB` 屏障。这贡献了 $1 \\times L(n) = n-1$ 个屏障。\n\n对 $a=1$ 的这些贡献求和：\n$$\nB(1, n) = (\\text{来自 RMW 的屏障}) + (\\text{来自存储的屏障}) + (\\text{来自加载的屏障})\n$$\n$$\nB(1, n) = (2n) + (1) + (n-1)\n$$\n$$\nB(1, n) = 3n\n$$\n此公式对所有 $n \\ge 1$ 成立。对于边界情况 $n=1$，成功 acquire 加载的次数为 $L(1)=0$，因此它们的屏障贡献为 $0$。公式正确地给出 $B(1,1) = 3 \\times 1 = 3$，这与直接计算相符：单个 RMW 的 $2$ 个屏障加上 release 存储阶段的 $1$ 个屏障。\n\n**公式摘要**:\n- $R(n) = n$\n- $L(n) = n - 1$\n- $S(n) = 1$\n- $B(a, n) = \\begin{cases} 0  \\text{如果 } a = 0 \\text{ 或 } a=2 \\\\ 3n  \\text{如果 } a = 1 \\end{cases}$\n\n这些公式用于计算给定测试套件的结果。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        },
        {
            "introduction": "原子指令，如 Fetch-and-Add ($FAA$)，是构建高性能并发数据结构的强大基石，但它们在固定宽度的寄存器上操作，带来了诸如溢出之类的挑战。本实践将指导您设计一个稳健的、硬件辅助的引用计数方案，通过将计数值提升到 64 位累加器来处理 32 位原子操作的局限性。您将学习如何分析环绕风险并实现一个两级计数器设计，这是一种在不牺牲准确性的前提下管理高频事件的常用模式 。",
            "id": "3647064",
            "problem": "要求您设计并论证一种硬件辅助的引用计数方案，该方案在快速路径上仅使用 Fetch-and-Add (FAA) 作为其唯一的更新原语。假设一台机器在 $32$ 位寄存器上提供单指令原子 Fetch-and-Add (FAA) 操作，该操作在 $\\mathbb{Z}_{2^{32}}$ 中执行模加运算，并原子地返回加法前的值。引用计数必须相对于获取/释放的数量保持单调，并且不得静默溢出。您必须推导出一个算法，通过将一个有界的 $32$ 位计数器与一个 $64$ 位累加器相结合，来维护一个逻辑上无界的计数值，并且您必须在一个程序中实现并测试该算法。\n\n基本原理和定义：\n- 原子操作：如果共享内存上的一个操作的效果是不可分割的，即整个操作发生在一个单一的线性化时间点上，则该操作是原子的。对寄存器 $R$ 进行增量为 $\\Delta$ 的 Fetch-and-Add (FAA) 操作会执行 $R \\gets (R + \\Delta) \\bmod 2^{w}$ 并返回旧值，其中 $w$ 是寄存器位宽。\n- 可线性化性：如果存在一个与实时顺序和串行规约一致的全序，那么并发操作的历史记录是可线性化的。\n- 模算术：对于位宽 $w$，寄存器上的加法运算以 $2^{w}$ 为模进行。\n- 我们的目标位宽是 $w = 32$，因此回绕发生在 $2^{32}$；可表示的最大无符号值为 $2^{32} - 1$。\n\n目标：\n- 设计一个引用计数数据结构，包含两个整数存储位置：一个快速路径的 $32$ 位计数器 $D$，仅通过 $32$ 位 FAA 更新；以及一个 $64$ 位累加器 $A$，在推理模型中通过 $64$ 位 FAA 或常规加法更新。逻辑引用计数值为 $R = A + D$，作为一个 $64$ 位整数。\n- 引入一个提升规则，以在 $D$ 接近 $2^{32}$ 时避免溢出。具体来说，定义一个裕量 $S \\in \\mathbb{N}$，满足 $1 \\leq S \\ll 2^{32}$，以及一个高水位阈值 $H = 2^{32} - S$。该算法必须确保对 $D$ 的每一次 FAA 操作仅在安全时执行，即当结果 $D$ 严格小于 $2^{32}$ 时，并且必须在 $D$ 变得很大时将 $D$ 压缩进 $A$。\n\n设计约束：\n- 假设 $D$ 在概念上是 $32$ 位的，$A$ 是 $64$ 位的。假设每次更新是一个整数 $\\Delta \\geq 0$；实践中可能存在释放（递减），但在提供的测试套件中不作要求。该算法必须确保：\n  1. 安全性：在对 $D$ 执行增量为 $\\Delta$ 的 FAA 操作之前，检查回绕风险谓词 $D + \\Delta \\geq 2^{32}$。如果为真，首先执行提升操作：$A \\gets A + D, D \\gets 0$，然后执行 $D \\gets D + \\Delta$。\n  2. 高水位压缩：在执行 $D \\gets D + \\Delta$ 之后，如果 $D \\geq H$，则执行压缩操作：$A \\gets A + D, D \\gets 0$。\n- 通过这些规则，不变量 $0 \\leq D  2^{32}$ 得以保持，并且逻辑计数值 $R = A + D$ 等于从初始状态开始所有应用的 $\\Delta$ 值的数学总和。\n\n您的任务：\n1. 根据原子 FAA 和模算术的定义，推导为什么回绕风险谓词 $D + \\Delta \\geq 2^{32}$ 足以检测即将发生的溢出，以及为什么在对 $D$ 进行 FAA 之前执行 $A \\gets A + D, D \\gets 0$ 可以防止增量丢失。解释使用 $H = 2^{32} - S$ 的高水位压缩如何保持 $D$ 处于低值以最小化未来的风险。\n2. 实现一个程序，对于一个小型测试套件，为每个测试用例计算三个量：\n   - 朴素 $32$ 位结果 $N$，计算方式为 $N = (D_0 + \\sum_i \\Delta_i) \\bmod 2^{32}$。\n   - 精确 $64$ 位和 $E$，计算方式为 $E = D_0 + \\sum_i \\Delta_i$（因为对于所有提供的测试，$A_0 = 0$）。\n   - 通过带有提升和高水位压缩的算法产生的提升后 $64$ 位和 $P$，即处理完所有 $\\Delta_i$ 后的最终 $A + D$。\n   同时计算一个布尔回绕风险标志 $F$，如果在任何步骤中 $D$ 会发生溢出（即，在任何步骤中 $D + \\Delta \\geq 2^{32}$），则为 $1$，否则为 $0$。\n3. 使用裕量 $S = 1024$ 和 $H = 2^{32} - S$。位宽为 $w = 32$，因此回绕边界是 $2^{32}$。所有数字必须被视为纯整数。不涉及角度或物理单位。\n4. 测试套件：\n   - 用例 $1$：$A_0 = 0$，$D_0 = 0$，更新 $\\Delta = [100, 50, 10]$。\n   - 用例 $2$：$A_0 = 0$，$D_0 = H - 500$，更新 $\\Delta = [600, 400]$。\n   - 用例 $3$：$A_0 = 0$，$D_0 = 0$，更新 $\\Delta = [H + 500, H + 500, H + 500]$。\n   - 用例 $4$：$A_0 = 0$，$D_0 = 2^{32} - 1 - 10$，更新 $\\Delta = [20, 7]$。\n5. 输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[N_1,E_1,P_1,F_1,N_2,E_2,P_2,F_2,N_3,E_3,P_3,F_3,N_4,E_4,P_4,F_4]$，其中下标按上面列出的顺序索引各个用例。所有值必须是整数；布尔值 $F_i$ 必须是 $0$ 或 $1$。\n\n程序必须是自包含的，不得读取输入，并且必须严格遵守另行指定的运行时环境约束。",
            "solution": "用户提供的问题是有效且定义明确的。它涉及计算机科学的基本概念，特别是使用原子硬件原语管理共享资源的算法设计，这是操作系统和并发编程中的一个核心主题。该问题在科学上以整数算术和原子指令的行为为基础。所有必需的参数和定义都已提供，并且没有内部矛盾。\n\n### 第 1 部分：推导与解释\n\n这个问题的核心是使用有界的硬件组件创建一个逻辑上无界的计数器。我们给定一个 $32$ 位寄存器 $D$ 和一个 $64$ 位寄存器 $A$。逻辑计数值定义为 $R = A + D$。$D$ 的主要更新机制是一个 $32$ 位的原子 Fetch-and-Add (FAA) 指令。\n\n**1. 回绕风险谓词的充分性**\n\n在 $32$ 位寄存器 $D$ 上的 FAA 操作执行模 $2^{32}$ 的加法。设寄存器的当前值为 $D_{old}$，增量为 $\\Delta$。FAA 指令计算新值为 $D_{new} = (D_{old} + \\Delta) \\pmod{2^{32}}$。\n\n当数学和 $D_{old} + \\Delta$ 超过寄存器可表示的最大值 $2^{32}-1$ 时，就会发生静默溢出或回绕。换句话说，当且仅当整数和大于或等于模数 $2^{32}$ 时，才会发生溢出。\n\n问题将回绕风险谓词指定为条件 $D + \\Delta \\geq 2^{32}$。这正是无符号 $32$ 位整数加法中发生溢出的精确数学条件。\n- 如果 $D + \\Delta  2^{32}$，模加法的结果就是数学和，$(D + \\Delta) \\pmod{2^{32}} = D + \\Delta$。没有信息丢失。\n- 如果 $D + \\Delta \\geq 2^{32}$，模加法的结果为 $(D + \\Delta) - k \\cdot 2^{32}$，其中整数 $k \\ge 1$。对于一个 $32$ 位寄存器上的单次加法，且两个操作数也都是可表示为 $32$ 位无符号整数，这个和将小于 $2 \\cdot 2^{32}$，所以 $k=1$。结果是 $(D+\\Delta) - 2^{32}$。这意味着从和中“丢失”了 $2^{32}$ 的值。\n\n因此，检查谓词 $D + \\Delta \\geq 2^{32}$ 对于检测即将发生的溢出是必要且充分的，如果直接执行 FAA，这种溢出将破坏逻辑计数值。检查本身必须使用更宽的算术（例如 $64$ 位）来执行，以避免在检查过程中发生溢出。\n\n**2. 通过 FAA 前的提升操作防止丢失**\n\n该算法的安全规则规定，如果回绕风险谓词 $D + \\Delta \\geq 2^{32}$ 为真，我们必须在应用增量 $\\Delta$ 之前首先执行一次提升操作。提升操作包括两个步骤：$A \\gets A + D$ 和 $D \\gets 0$。让我们分析这对总逻辑计数值 $R$ 的影响。\n\n设操作前的状态为 $(A, D)$。逻辑计数值为 $R_{pre} = A + D$。我们检测到 $D + \\Delta \\geq 2^{32}$。\n根据规则，我们首先进行提升：\n1.  将 $D$ 的值转移到累加器：$A' \\gets A + D$。\n2.  重置快速路径计数器：$D' \\gets 0$。\n在这个中间点，逻辑计数值为 $R_{interm} = A' + D' = (A + D) + 0 = A + D$。逻辑值被保留了下来。我们实际上已将 $D$ 的值“存入”了安全的、更宽的累加器 $A$ 中。\n\n接下来，我们应用增量：$D'' \\gets D' + \\Delta = 0 + \\Delta = \\Delta$。问题指定对 $D$ 的更新是通过 FAA 进行的。由于 $\\Delta$ 是一个增量，在 $D=0$ 上执行 FAA$(D, \\Delta)$ 会使 $D$ 变为 $\\Delta$（假设 $\\Delta  2^{32}$，这对于测试用例是成立的）。最终状态为 $(A', D'')$，即 $(A+D, \\Delta)$。最终的逻辑计数值为 $R_{post} = A' + D'' = (A + D) + \\Delta$。\n\n这与期望的结果相匹配：新的逻辑计数值应该是原始逻辑计数值加上增量，即 $R_{pre} + \\Delta = (A+D) + \\Delta$。通过首先将 $D$ 的值移动到 $A$，我们防止了后续对 $D$ 的 FAA 操作中的回绕破坏总和。\n\n**3. 高水位压缩的作用**\n\n回绕风险检查是一种*反应式*机制；它仅在溢出即将来临时触发。这条路径在计算上更昂贵，因为它除了对 $D$ 的操作外，还涉及更新累加器 $A$，这可能需要一个单独的原子操作或锁。\n\n高水位压缩是一种*主动式*优化。它引入了一个阈值 $H = 2^{32} - S$，其中 $S$ 是一个裕量值。在对 $D$ 应用任何增量后，算法会检查是否 $D \\geq H$。如果是，即使没有即时溢出风险， $D$ 的值也会被压缩到 $A$ 中（$A \\gets A + D, D \\gets 0$）。\n\n这样做的目的是保持 $D$ 的值较低。通过在 $D$ 变大时定期将其重置为 $0$，触发更昂贵的反应式回绕风险路径的概率会显著降低。压缩后，$D=0$。下一个增量 $\\Delta$ 只有在 $\\Delta \\geq 2^{32}$ 时才会触发回绕风险检查。对于任何 $\\Delta  2^{32}$，加法不会溢出。通过选择一个合理的裕量 $S$，我们确保除非收到一个非常大的单次增量 $\\Delta$（即 $\\Delta > S$），否则在 $D$ 增长到足以超过高水位线 $H$ 之前，可以应用多个较小的增量通过快速路径（仅对 $D$ 进行 FAA）。这分摊了更新累加器 $A$ 的成本，并将最频繁的操作保持在最快的路径上。",
            "answer": "```c\n#include"
        },
        {
            "introduction": "比较并交换 ($CAS$) 指令是许多无锁算法的基石，但其使用充满了微妙的陷阱，其中最著名的是 A-B-A 问题。在本练习中，您将构建一个无锁的空闲链表，并确定性地编排 A-B-A 问题的发生，从而亲身体验内存重用如何破坏一个看似正确的算法。随后，您将使用险象指针（hazard pointers）实现一个标准解决方案，为确保高级无锁数据结构的安全性和正确性提供一堂实践课 。",
            "id": "3647095",
            "problem": "您将设计并实现一个完整、可运行的程序，该程序使用基于比较并交换（CAS）构建的无锁空闲链表来演示硬件支持的同步，在立即回收的条件下通过一个$3$节点周期暴露A-B-A（ABA）问题，然后使用险象指针防止该问题，并最终估算在险象指针扫描下每个节点的回收开销。其根本基础必须是原子性和硬件比较并交换的定义与语义，以及无锁栈的逻辑和险象指针的原理。\n\n从以下基本事实和定义开始：\n- 原子性（Atomicity）：如果一个操作相对于其他操作表现为瞬时发生，确保状态变化不可分割，则该操作是原子的。\n- 比较并交换（Compare-And-Swap, CAS）：比较并交换（CAS）读取一个内存位置，将其与一个期望值进行比较，如果相等，则原子性地写入一个新值。形式上，对于内存位置 $M$、期望值 $E$ 和新值 $N$，$CAS(M,E,N)$ 在 $M$ 等于 $E$ 的情况下设置 $M \\leftarrow N$ 并返回成功，否则保持 $M$ 不变并返回失败。\n- Treiber 栈：一个典型的无锁栈对头指针使用 $CAS$，尝试执行 $$head \\leftarrow new,$$ 条件是 $head$ 的当前观测值未改变，从而形成一个乐观重试的循环。\n- A-B-A 问题（ABA）：A-B-A（ABA）问题发生于以下情况：一个线程读取指针值 $A$，其他并发操作将结构更改为 $B$ 又改回 $A$，然后原始线程后续的 $CAS$ 操作因匹配到 $A$ 而成功，尽管中间的更改已使其“未改变”的假设失效。\n- 险象指针（Hazard pointers, HP）：险象指针（HP）是每个线程发布的指针保护，可防止其他线程当前正在读取的节点的内存被回收（和重用），从而消除由已释放节点的内存重用引起的 $ABA$ 变体。\n\n您的程序必须：\n1. 使用对头指针的 $CAS$ 操作实现一个无锁空闲链表（Treiber 栈），以推入（push）和弹出（pop）节点。\n2. 在不使用险象指针并立即回收内存的情况下，使用标记为 $A$、$B$ 和 $C$ 的恰好 $3$ 个节点，构建一个确定性的 $ABA$ 演示。线程 $\\#1$ 将读取 $A$ 并准备一个 $CAS$ 操作以将 $A$ 替换为 $B$；线程 $\\#2$ 将弹出 $A$，立即将其回收至空闲链表，弹出 $B$，分配一个（由于立即回收）重用 $A$ 地址的新节点，并将其推入。然后，线程 $\\#1$ 执行准备好的 $CAS$，该操作匹配到重新出现的指针值 $A$，但写入了一个过期的 next 指针，从而通过丢弃被重用的节点来演示 $ABA$ 损坏。此序列必须通过逻辑屏障进行确定性地编排。\n3. 使用险象指针修复由内存重用引发的 $ABA$ 问题：线程 $\\#1$ 在尝试其 $CAS$ 操作前发布一个指向 $A$ 的险象指针；线程 $\\#2$ 的回收逻辑会扫描险象指针集合，并推迟回收（即，当 $A$ 受保护时，不将其返回到空闲链表）。这保证了在线程 $\\#1$ 的 $CAS$ 操作期间，$A$ 不会被重用并以相同地址重新出现，从而防止了内存重用变体的 $ABA$ 问题。\n4. 估算在险象指针下的每个节点的回收开销，定义为每个退役节点执行的险象槽检查次数。如果有 $H$ 个险象槽和 $R$ 个被扫描的退役节点，则总检查次数为 $H \\cdot R$，每个节点的平均开销为 $$\\frac{H \\cdot R}{R} = H.$$\n\n设计约束和要求：\n- 将空闲链表表示为一个单向链式栈，带有一个全局原子头指针。节点必须具有整数标识符以便清晰。\n- 使用原子标志精心编排线程执行，以使序列是确定性的：线程 $\\#1$ 读取头节点（$A$）并准备 $CAS$，然后线程 $\\#2$ 执行引发 $ABA$ 的序列，之后线程 $\\#1$ 执行其 $CAS$。\n- 为展示险象指针的修复效果，线程 $\\#1$ 在 $CAS$ 之前发布其险象指针（每个线程一个槽），线程 $\\#2$ 的回收逻辑在将节点返回空闲链表之前扫描所有险象槽。如果有任何槽引用了某个节点，则必须推迟回收，且该节点在关键窗口期内不得返回到空闲链表。\n- $ABA$ 检测必须表示为每个测试用例的布尔结果：如果观察到 $ABA$，则为 $1$，否则为 $0$。\n- 险象指针开销计算必须是一个浮点数，等于每个退役节点的平均险象检查次数。\n\n测试套件和预期输出：\n按顺序执行以下测试用例：\n- 测试用例 $1$ (happy path $ABA$)：$2$ 个线程，禁用险象指针。预期会演示 $ABA$。输出为一个布尔值。\n- 测试用例 $2$ (修复)：$2$ 个线程，启用险象指针。预期会防止内存重用 $ABA$。输出为一个布尔值。\n- 测试用例 $3$ (边界)：$1$ 个线程，禁用险象指针。无并发；$ABA$ 不应发生。输出为一个布尔值。\n- 测试用例 $4$ (开销)：使用 $H=4$ 个险象槽和 $R=50$ 个退役节点进行险象指针扫描。输出为一个浮点数，等于每个节点的开销，以十进制表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result1,result2,result3,result4]$）。对于上述测试套件，请打印三个布尔结果（以 $0$ 或 $1$ 表示），后跟浮点数开销（以十进制表示）。",
            "solution": "该问题要求设计并实现一个C程序，以演示无锁栈中的A-B-A问题、其使用险象指针的缓解方法，并估算相关的开销。该解决方案必须是确定性的，并基于原子操作和并发数据结构的基本原理。\n\n问题的核心围绕一个无锁栈，通常称为Treiber栈，它在不使用传统锁的情况下管理一个节点列表。其操作 `push` 和 `pop` 建立在原子硬件指令——比较并交换（$CAS$）之上。例如，一个 `pop` 操作包含三个步骤：\n$1$. 读取栈的当前头节点：$old\\_head \\leftarrow head$。\n$2$. 确定新的头节点：$new\\_head \\leftarrow old\\_head \\rightarrow next$。\n$3$. 当且仅当头指针自读取后未发生变化时，原子性地更新它：$CAS(head, old\\_head, new\\_head)$。\n如果 $CAS$ 失败，意味着另一个线程修改了栈，操作必须从步骤 $1$ 开始重试。\n\nA-B-A问题源于此逻辑中的一个微妙缺陷。$CAS$ 指令检查头指针的值是否未变，但它无法检测该地址指向的底层节点是否已被释放并为新目的重新分配。序列如下：一个线程读取指针值 $A$。同时，其他线程弹出 $A$，弹出另一个节点 $B$，然后回收并为新节点重新分配先前由 $A$ 使用的内存，该新节点随后被推回栈上。头指针再次持有地址 $A$。原始线程未察觉到这段中间历史，执行其 $CAS$ 操作，此时操作成功，导致数据结构损坏，通常是更新丢失。\n\n我们的实现将确定性地编排此场景及其在四个测试用例中的解决方案。\n\n**数据结构和初始化**\n\n我们定义一个 `Node` 结构体，包含一个整数标识符 `id` 和一个 `next` 指针。\n$$\n\\text{struct Node} \\{ \\text{struct Node* next; int id;} \\};\n$$\n一个包含 $3$ 个节点的全局池，我们将称之为 $A$、$B$ 和 $C$，被静态分配，以确保它们的内存地址在整个演示过程中保持不变。它们的标识符分别初始化为 $1$、$2$ 和 $3$。主要的数据结构是一个无锁栈，由一个原子头指针 `_Atomic(Node*) stack_head` 表示。第二个类似的栈 `freelist_head` 用于管理回收的节点。对于确定性测试，主栈初始化为 $A \\rightarrow B \\rightarrow C$ 的状态，其中 $A$ 是头节点。\n\n**测试用例 1：演示A-B-A问题**\n\n此测试使用 $2$ 个线程 $T_1$ 和 $T_2$，并禁用险象指针。执行过程通过原子布尔标志精心排序，以强制产生A-B-A竞争条件。\n\n$1$. **线程 $T_1$ (受害者)**:\n   - 读取栈头，观察到指针 $A$。设其为 $old\\_head$。\n   - 确定下一个节点是 $B$。设其为 $new\\_head$。\n   - $T_1$ 现在准备执行 $CAS(stack\\_head, A, B)$ 来完成其弹出操作。\n   - 它向 $T_2$ 发出信号，让其开始操作，然后等待。\n\n$2$. **线程 $T_2$ (对抗者)**:\n   - 收到 $T_1$ 的信号后，$T_2$ 迅速改变栈。\n   - 它弹出 $A$。栈变为 $B \\rightarrow C$。\n   - 它弹出 $B$。栈变为 $C$。\n   - 它通过将节点 $A$ 推入 `freelist` 来“回收”它。由于禁用了险象指针，这是立即的。\n   - 它需要一个新节点推入主栈。它通过从 `freelist` 中弹出来“分配”一个，这会返回同一个节点 $A$。\n   - 它将这个重新分配的节点 $A$ 推入主栈。栈状态变为 $A \\rightarrow C$。节点 $B$ 现在被孤立了。\n   - 它向 $T_1$ 发出信号，表示其操作已完成。\n\n$3$. **解决**:\n   - $T_1$ 恢复并执行其准备好的 $CAS(stack\\_head, A, B)$。\n   - 因为 $T_2$ 已将重新分配的 $A$ 推回栈上，当前的 `stack_head` 指针等于 $T_1$ 的 `old_head`。$CAS$ 成功。\n   - `stack_head` 被更新为指向 $B$。最终的栈是 $B \\rightarrow C$。$T_2$ 推入的节点 $A$ 现在丢失了。\n   - 在这些底层状态被显著修改的情况下，$CAS$ 操作的成功正是A-B-A问题的体现。此测试的布尔结果是 $1$ (true)。\n\n**测试用例 2：用险象指针缓解A-B-A问题**\n\n此测试重复该场景，使用 $2$ 个线程但启用险象指针。险象指针是每个线程公开可见的指针，指示该线程当前正在访问的节点。内存回收逻辑必须扫描所有险象指针，并推迟释放任何被其“保护”的节点。\n\n$1$. **线程 $T_1$**:\n   - 读取栈头，观察到指针 $A$。\n   - **关键地，它发布此指针：$HP[0] \\leftarrow A$。**\n   - 它像之前一样继续，准备其 $CAS$ 并向 $T_2$ 发信号。\n\n$2$. **线程 $T_2$**:\n   - 它像之前一样弹出 $A$ 和 $B$。\n   - 它尝试回收 $A$。其回收逻辑现在扫描险象指针数组。它发现 $HP[0] == A$。\n   - 因为 $A$ 是险象节点，$T_2$ **不能**将其返回到 `freelist`。回收被推迟。\n   - 然后，$T_2$ 尝试从 `freelist` 分配一个节点。由于 $A$ 没有被返回，它不能被重新分配。假设 `freelist` 在其他方面是空的，分配失败（或者如果有一个可用节点，则返回不同的节点）。在我们的特定设置中，`freelist` 是空的，所以分配返回 `NULL`。\n   - $T_2$ 的推入操作没有发生。主栈保持在状态 $C$。\n   - 它向 $T_1$ 发信号。\n\n$3$. **解决**:\n   - $T_1$ 恢复并执行其准备好的 $CAS(stack\\_head, A, B)$。\n   - 当前的 `stack_head` 指向 $C$，这与 $T_1$ 的 `old_head` 值 $A$ 不匹配。$CAS$ **失败**，这是正确的行为。\n   - 然后，$T_1$ 会在新状态上重试其弹出操作。A-B-A问题得以避免。布尔结果是 $0$ (false)。\n   - 最后，$T_1$ 清除其险象指针：$HP[0] \\leftarrow NULL$。\n\n**测试用例 3：边界条件（单线程）**\n\n此测试使用 $1$ 个线程运行，并禁用险象指针。该线程执行 $T_1$ 的 `pop` 逻辑。由于没有并发线程 $T_2$ 来操纵栈，从初始读取 `head` 到最终 $CAS$ 之间的状态保证不变。$CAS$ 成功。然而，这是一个正确的、有效的操作，而不是A-B-A的实例。我们的检测逻辑要求 $CAS$ 成功且 $T_2$ 完成了操纵，因此能正确识别这一点。结果是 $0$ (false)。\n\n**测试用例 4：回收开销估算**\n\n问题将回收开销定义为每个退役节点执行的险象槽检查次数。当一个线程决定扫描其退役节点列表（假设大小为 $R$）时，它必须将 $R$ 个节点中的每一个与每个活动的险象指针槽（假设大小为 $H$）进行核对。\n\n- $R$ 个退役节点的总检查次数 = $H \\times R$。\n- 每个退役节点的平均开销 = $\\frac{H \\times R}{R} = H$。\n\n因此，开销就是系统中险象指针槽的总数，通常等于线程数。对于给定的参数 $H=4$ 个险象槽和 $R=50$ 个退役节点，计算很简单：平均开销是 $4.0$。问题的这一部分测试应用给定形式定义的能力。程序直接计算此值。\n\n这四个测试的综合结果提供了一个关于关键并发问题及其标准解决方案的全面、实际的演示，所有这些都在一个自包含、可验证的程序中进行编排。",
            "answer": "```c\n#include"
        }
    ]
}