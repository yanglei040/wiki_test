{
    "hands_on_practices": [
        {
            "introduction": "原子指令（如 Fetch-and-Add）是构建高性能并发系统的基石，但其本身受限于硬件字长，例如 32 位计数器会面临溢出问题。当我们需要一个逻辑上无界的计数器时，该如何设计？本练习将指导你实现一种实用的高扩展性引用计数方案，该方案巧妙地结合了快速路径上的 32 位原子计数器和一条安全路径上的 64 位累加器，以避免数据丢失，这是实现工业级监控和统计系统中常见的核心技术。",
            "id": "3647064",
            "problem": "要求您设计并论证一种硬件辅助的引用计数方案，该方案在快速路径上仅使用“取值并加”（Fetch-and-Add, FAA）作为其唯一的更新原语。假设一台机器在 $32$ 位寄存器上提供单指令原子“取值并加”（FAA）操作，该操作在 $\\mathbb{Z}_{2^{32}}$ 中执行模加法，并原子性地返回加法前的值。引用计数必须相对于获取/释放的数量保持单调，并且不得静默溢出。您必须推导出一个算法，通过将一个有界的 $32$ 位计数器与一个 $64$ 位累加器相结合，来维护一个逻辑上无界的计数值。同时，您必须在一个程序中实现并测试该算法。\n\n基本原理和定义：\n- 原子操作：对共享内存的操作，如果其效果是不可分割的，即整个操作发生在时间上的一个线性化点，则该操作是原子的。“取值并加”（FAA）在寄存器 $R$ 上以增量 $\\Delta$ 执行操作 $R \\gets (R + \\Delta) \\bmod 2^{w}$ 并返回旧值，其中 $w$ 是寄存器宽度（以比特为单位）。\n- 线性一致性：如果存在一个与实时顺序和顺序规约一致的全序，那么并发操作的历史记录是线性一致的。\n- 模运算：对于宽度 $w$，寄存器上的加法以 $2^{w}$ 为模执行。\n- 我们的目标宽度为 $w = 32$，因此在 $2^{32}$ 处发生回绕；可表示的最大无符号值为 $2^{32} - 1$。\n\n目标：\n- 设计一个引用计数数据结构，包含两个整数存储位置：一个快速路径的 $32$ 位计数器 $D$，仅通过 $32$ 位 FAA 更新；以及一个 $64$ 位累加器 $A$，在推理模型中通过 $64$ 位 FAA 或常规加法更新。逻辑引用计数为 $64$ 位整数 $R = A + D$。\n- 引入一个提升规则以避免当 $D$ 接近 $2^{32}$ 时发生溢出。具体来说，定义一个松弛量 $S \\in \\mathbb{N}$，满足 $1 \\leq S \\ll 2^{32}$，以及一个高水位阈值 $H = 2^{32} - S$。算法必须确保每次对 $D$ 的 FAA 操作仅在安全时执行，即当产生的 $D$ 值严格小于 $2^{32}$ 时，并且当 $D$ 变得很大时，必须将 $D$ 压缩到 $A$ 中。\n\n设计约束：\n- 设 $D$ 在概念上是 $32$ 位的，而 $A$ 是 $64$ 位的。设每次更新为一个整数 $\\Delta \\geq 0$；实践中可能存在释放（递减）操作，但在提供的测试套件中不作要求。算法必须确保：\n  1. 安全性：在对 $D$ 执行增量为 $\\Delta$ 的 FAA 操作之前，检查回绕风险谓词 $D + \\Delta \\geq 2^{32}$。如果为真，首先执行提升操作：$A \\gets A + D, D \\gets 0$，然后执行 $D \\gets D + \\Delta$。\n  2. 高水位压缩：在执行 $D \\gets D + \\Delta$ 后，如果 $D \\geq H$，则执行压缩操作：$A \\gets A + D, D \\gets 0$。\n- 通过这些规则，不变量 $0 \\leq D  2^{32}$ 得以保持，并且逻辑计数值 $R = A + D$ 等于从初始状态开始所有应用的 $\\Delta$ 值的数学和。\n\n您的任务：\n1. 根据原子 FAA 和模运算的定义，推导为什么回绕风险谓词 $D + \\Delta \\geq 2^{32}$ 足以检测即将发生的溢出，以及为什么在对 $D$ 执行 FAA 之前执行 $A \\gets A + D, D \\gets 0$ 可以防止增量丢失。解释高水位压缩（使用 $H = 2^{32} - S$）如何保持 $D$ 处于低值以最小化未来的风险。\n2. 实现一个程序，该程序针对一个小型测试套件，为每个测试用例计算三个量：\n   - 朴素的 $32$ 位结果 $N$，计算方式为 $N = (D_0 + \\sum_i \\Delta_i) \\bmod 2^{32}$。\n   - 精确的 $64$ 位和 $E$，计算方式为 $E = D_0 + \\sum_i \\Delta_i$（因为在所有提供的测试中 $A_0 = 0$）。\n   - 通过带有提升和高水位压缩的算法产生的 $64$ 位和 $P$，即处理完所有 $\\Delta_i$ 后的最终 $A + D$。\n   同时计算一个布尔回绕风险标志 $F$，如果在任何步骤中 $D$ 会发生溢出（即在任何步骤中 $D + \\Delta \\geq 2^{32}$），则 $F$ 为 $1$，否则为 $0$。\n3. 使用松弛量 $S = 1024$ 和 $H = 2^{32} - S$。宽度为 $w = 32$，因此回绕边界为 $2^{32}$。所有数字必须被视为纯整数。不涉及角度或物理单位。\n4. 测试套件：\n   - 用例 1：$A_0 = 0$, $D_0 = 0$, 更新 $\\Delta = [100, 50, 10]$。\n   - 用例 2：$A_0 = 0$, $D_0 = H - 500$, 更新 $\\Delta = [600, 400]$。\n   - 用例 3：$A_0 = 0$, $D_0 = 0$, 更新 $\\Delta = [H + 500, H + 500, H + 500]$。\n   - 用例 4：$A_0 = 0$, $D_0 = 2^{32} - 1 - 10$, 更新 $\\Delta = [20, 7]$。\n5. 输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[N_1,E_1,P_1,F_1,N_2,E_2,P_2,F_2,N_3,E_3,P_3,F_3,N_4,E_4,P_4,F_4]$，其中下标按上面列出的顺序索引测试用例。所有值必须是整数；布尔值 $F_i$ 必须是 $0$ 或 $1$。\n\n程序必须是自包含的，不得读取输入，并严格遵守其他地方指定的运行时环境约束。",
            "solution": "用户提出的问题是有效且定义明确的。它涉及计算机科学的基本概念，特别是使用原子硬件原语管理共享资源的算法设计，这是操作系统和并发编程中的一个核心主题。该问题在科学上基于整数算术和原子指令的行为。所有必需的参数和定义都已提供，并且没有内部矛盾。\n\n### 第1部分：推导与解释\n\n这个问题的核心是使用有界的硬件组件创建一个逻辑上无界的计数器。我们给定一个 $32$ 位寄存器 $D$ 和一个 $64$ 位寄存器 $A$。逻辑计数值定义为 $R = A + D$。对 $D$ 的主要更新机制是一个 $32$ 位的原子“取值并加”（FAA）指令。\n\n**1. 回绕风险谓词的充分性**\n\n在 $32$ 位寄存器 $D$ 上的 FAA 操作执行模 $2^{32}$ 的加法。设寄存器的当前值为 $D_{old}$，增量为 $\\Delta$。FAA 指令计算新值为 $D_{new} = (D_{old} + \\Delta) \\pmod{2^{32}}$。\n\n当数学和 $D_{old} + \\Delta$ 超过寄存器可表示的最大值 $2^{32}-1$ 时，就会发生静默溢出或回绕。换句话说，当且仅当整数和大于或等于模数 $2^{32}$ 时，溢出才会发生。\n\n问题将回绕风险谓词指定为条件 $D + \\Delta \\geq 2^{32}$。这正是无符号 $32$ 位整数加法中发生溢出的精确数学条件。\n- 如果 $D + \\Delta  2^{32}$，模加法的结果就是数学和，即 $(D + \\Delta) \\pmod{2^{32}} = D + \\Delta$。没有信息丢失。\n- 如果 $D + \\Delta \\geq 2^{32}$，模加法的结果是 $(D + \\Delta) - k \\cdot 2^{32}$，其中整数 $k \\ge 1$。对于在 $32$ 位寄存器上进行的单次加法，其中两个操作数也都可以表示为 $32$ 位无符号整数，这个和将小于 $2 \\cdot 2^{32}$，所以 $k=1$。结果是 $(D+\\Delta) - 2^{32}$。这意味着从和中“丢失”了 $2^{32}$ 的值。\n\n因此，检查谓词 $D + \\Delta \\geq 2^{32}$ 是检测即将发生的溢出的必要且充分的条件，如果直接执行 FAA，这种溢出将破坏逻辑计数值。检查本身必须使用更大宽度的算术（如 $64$ 位）来执行，以避免在检查过程中发生溢出。\n\n**2. 通过 FAA 前的提升操作防止丢失**\n\n算法的安全性规则规定，如果回绕风险谓词 $D + \\Delta \\geq 2^{32}$ 为真，我们必须在应用增量 $\\Delta$ 之前首先执行一个提升操作。提升操作包括两个步骤：$A \\gets A + D$ 和 $D \\gets 0$。让我们分析这对总逻辑计数值 $R$ 的影响。\n\n设操作前的状态为 $(A, D)$。逻辑计数值为 $R_{pre} = A + D$。\n我们检测到 $D + \\Delta \\geq 2^{32}$。\n根据规则，我们首先进行提升：\n1.  将 $D$ 的值转移到累加器中：$A' \\gets A + D$。\n2.  重置快速路径计数器：$D' \\gets 0$。\n在这个中间点，逻辑计数值为 $R_{interm} = A' + D' = (A + D) + 0 = A + D$。逻辑值被保留了下来。我们实际上已将 $D$ 的值“存入”了安全的、更宽的累加器 $A$ 中。\n\n接下来，我们应用增量：$D'' \\gets D' + \\Delta = 0 + \\Delta = \\Delta$。问题指定对 $D$ 的更新是通过 FAA。由于 $\\Delta$ 是一个增量，对 $D=0$ 执行 FAA$(D, \\Delta)$ 会使 $D$ 变为 $\\Delta$（假设 $\\Delta  2^{32}$，这对测试用例成立）。\n最终状态为 $(A', D'')$，即 $(A+D, \\Delta)$。\n最终逻辑计数值为 $R_{post} = A' + D'' = (A + D) + \\Delta$。\n\n这与期望的结果相匹配：新的逻辑计数值应该是原始逻辑计数值加上增量，即 $R_{pre} + \\Delta = (A+D) + \\Delta$。通过首先将 $D$ 的值移入 $A$，我们防止了后续对 $D$ 的 FAA 操作中的回绕破坏总和。\n\n**3. 高水位压缩的作用**\n\n回绕风险检查是一种*反应式*机制；它仅在溢出即将发生时触发。这条路径在计算上更昂贵，因为它除了对 $D$ 的操作外，还涉及更新累加器 $A$，这可能需要一个独立的原子操作或锁。\n\n高水位压缩是一种*主动式*优化。它引入了一个阈值 $H = 2^{32} - S$，其中 $S$ 是一个松弛值。在对 $D$ 应用任何增量后，算法会检查是否 $D \\geq H$。如果是，即使没有迫在眉睫的溢出，也会将 $D$ 的值压缩到 $A$ 中（$A \\gets A + D, D \\gets 0$）。\n\n这样做的目的是保持 $D$ 的值较低。通过在 $D$ 变得很大时周期性地将其重置为 $0$，触发更昂贵的反应式回绕风险路径的概率会显著降低。压缩后，$D=0$。下一个增量 $\\Delta$ 只有在 $\\Delta \\geq 2^{32}$ 时才会触发回绕风险检查。对于任何 $\\Delta  2^{32}$，加法不会溢出。通过选择一个合理的松弛量 $S$，我们确保除非收到一个非常大的单次增量 $\\Delta$（即 $\\Delta > S$），否则可以在 $D$ 增长到足以超过高水位标记 $H$ 之前，通过快速路径（仅对 $D$ 进行 FAA）应用多个较小的增量。这摊销了更新累加器 $A$ 的成本，并将最频繁的操作保持在最快的路径上。",
            "answer": "```c\n#include"
        },
        {
            "introduction": "无锁编程（Lock-free programming）通过原子指令（如 Compare-and-Swap, CAS）避免了传统锁带来的开销，但它也引入了更为隐蔽和棘手的难题，其中最著名的就是 ABA 问题。本练习将引导你亲手构建一个导致 ABA 问题的场景，观察一个无锁栈如何在并发修改下被破坏，然后再利用“危险指针”（Hazard Pointers）这一经典技术来修复它。通过这个过程，你将深刻理解无锁数据结构设计的复杂性以及内存回收机制在并发编程中的关键作用。",
            "id": "3647095",
            "problem": "您将设计并实现一个完整、可运行的程序，该程序使用基于比较并交换 (CAS) 构建的无锁空闲链表来演示硬件支持的同步，通过在立即回收策略下的一个 $3$ 节点循环暴露 A-B-A 问题 (ABA)，然后使用危险指针防止该问题，并最终估算在使用危险指针扫描时每个节点的回收开销。程序必须基于原子性和硬件比较并交换的定义与语义，以及无锁栈的逻辑和危险指针的原理。\n\n从以下基本事实和定义开始：\n- 原子性 (Atomicity)：若一个操作相对于其他操作而言表现为瞬时发生，确保了状态变化的不可分割性，则该操作是原子的。\n- 比较并交换 (Compare-And-Swap, CAS)：CAS 读取一个内存位置，将其与一个期望值进行比较，如果相等，则原子性地写入一个新值。形式上，对于内存位置 $M$、期望值 $E$ 和新值 $N$，$CAS(M,E,N)$ 在 $M$ 的值曾是 $E$ 的情况下，设置 $M \\leftarrow N$ 并返回成功，否则保持 $M$ 不变并返回失败。\n- Treiber 栈：一个典型的无锁栈对头指针使用 $CAS$，尝试执行 $$head \\leftarrow new,$$ 其条件是 $head$ 的当前观测值未变，从而形成一个乐观重试循环。\n- A-B-A 问题 (ABA)：当一个线程读取了指针值 $A$ 后，其他并发操作将结构更改为 $B$ 又改回 $A$，此时原始线程后续的 $CAS$ 操作因为匹配到 $A$ 而成功，尽管期间的更改已使其“$A$ 未改变”的假设失效，这时就发生了 A-B-A 问题 (ABA)。\n- 危险指针 (Hazard pointers, HP)：危险指针是每个线程发布的指针保护机制，用于防止其他线程正在读取的节点被回收（和重用），从而消除由已释放节点的内存重用所引起的 $ABA$ 变体问题。\n\n您的程序必须：\n1. 使用 $CAS$ 对头指针进行操作，实现一个用于推入（push）和弹出（pop）节点的无锁空闲链表（Treiber 栈）。\n2. 在没有危险指针的情况下，使用恰好 $3$ 个标记为 $A$、$B$ 和 $C$ 的节点，并采用立即回收策略，构建一个确定性的 $ABA$ 演示。线程 $\\#1$ 将读取 $A$ 并准备一个 $CAS$ 操作以将 $A$ 替换为 $B$；线程 $\\#2$ 将弹出 $A$，立即将其回收至空闲链表，再弹出 $B$，然后分配一个（由于立即回收）重用 $A$ 地址的新节点，并将其推入栈中。之后，线程 $\\#1$ 执行其准备好的 $CAS$ 操作，该操作匹配到了重新出现的指针值 $A$，但写入了一个过期的 next 指针，从而因丢弃了重用的节点而展示了 $ABA$ 导致的损坏。此序列必须通过逻辑屏障进行确定性地编排。\n3. 使用危险指针修复由内存重用引起的 $ABA$ 问题：线程 $\\#1$ 在尝试其 $CAS$ 操作前发布一个指向 $A$ 的危险指针；线程 $\\#2$ 的回收逻辑会扫描所有危险指针集合，并推迟回收（即，当 $A$ 受保护时，不将其返回到空闲链表）。这保证了在线程 $\\#1$ 的 $CAS$ 操作期间，$A$ 不会被重用并以相同的地址重新出现，从而防止了内存重用类型的 $ABA$ 问题。\n4. 估算在使用危险指针时每个节点的回收开销，其定义为每个退役节点所执行的危险指针槽位检查次数。如果有 $H$ 个危险指针槽位和 $R$ 个被扫描的退役节点，总检查次数为 $H \\cdot R$，则每个节点的平均开销为 $$\\frac{H \\cdot R}{R} = H.$$\n\n设计约束和要求：\n- 将空闲链表表示为带有全局原子头指针的单向链式栈。为清晰起见，节点必须有整数标识符。\n- 使用原子标志仔细编排线程执行，以确保序列的确定性：线程 $\\#1$ 读取头节点 ($A$) 并准备 $CAS$，然后线程 $\\#2$ 执行引发 $ABA$ 的序列，之后线程 $\\#1$ 执行其 $CAS$。\n- 为展示危险指针的修复效果，线程 $\\#1$ 在 $CAS$ 之前发布其危险指针（每个线程一个槽位），而线程 $\\#2$ 的回收逻辑在将节点返回空闲链表之前会扫描所有危险指针槽位。如果有任何槽位引用了某个节点，则必须推迟对该节点的回收，并且在关键窗口期内不得将其返回到空闲链表。\n- 每个测试用例的 $ABA$ 检测必须表示为一个布尔结果：如果观察到 $ABA$，则为 $1$，否则为 $0$。\n- 危险指针开销的计算结果必须是一个浮点数，等于每个退役节点的平均危险指针检查次数。\n\n测试套件和预期输出：\n提供以下按顺序执行的测试用例：\n- 测试用例 $1$（$ABA$ 典型路径）：$2$ 个线程，禁用危险指针。预期将演示 $ABA$。输出为布尔值。\n- 测试用例 $2$（修复）：$2$ 个线程，启用危险指针。预期将防止内存重用导致的 $ABA$。输出为布尔值。\n- 测试用例 $3$（边界情况）：$1$ 个线程，禁用危险指针。无并发；$ABA$ 不应发生。输出为布尔值。\n- 测试用例 $4$（开销）：使用 $H=4$ 个危险指针槽位和 $R=50$ 个退役节点进行危险指针扫描。输出为浮点数，等于每个节点的开销，以十进制小数表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3,result4]$）。对于上述测试套件，请打印三个布尔结果（以 $0$ 或 $1$ 表示），后跟浮点数表示的开销（以十进制小数表示）。",
            "solution": "该问题要求设计并实现一个 C 语言程序，用以演示无锁栈中的 A-B-A 问题、如何使用危险指针缓解该问题，并估算相关开销。解决方案必须是确定性的，并基于原子操作和并发数据结构的基本原理。\n\n问题的核心围绕一个无锁栈（常称为 Treiber 栈），它无需使用传统锁即可管理一个节点列表。其 `push` 和 `pop` 操作构建于原子硬件指令——比较并交换 ($CAS$) 之上。例如，一个 `pop` 操作涉及三个步骤：\n$1$. 读取栈的当前头节点：$old\\_head \\leftarrow head$。\n$2$. 确定新的头节点：$new\\_head \\leftarrow old\\_head \\rightarrow next$。\n$3$. 当且仅当头指针自读取后未发生改变时，原子性地更新它：$CAS(head, old\\_head, new\\_head)$。\n如果 $CAS$ 失败，意味着另一个线程修改了栈，操作必须从第 1 步开始重试。\n\nA-B-A 问题源于此逻辑中的一个微妙缺陷。$CAS$ 指令检查头指针的值是否未变，但无法检测到该地址指向的底层节点是否已被释放并为新目的重新分配。其发生序列如下：一个线程读取指针值 $A$。同时，其他线程弹出 $A$，再弹出另一个节点 $B$，然后回收并重新分配先前由 $A$ 使用的内存给一个新节点，该新节点随后被推回栈上。此时头指针再次持有地址 $A$。原始线程对这一中间过程一无所知，执行其 $CAS$ 操作，该操作现在会成功，从而导致数据结构损坏，通常表现为更新丢失。\n\n我们的实现将在四个测试用例中确定性地编排此场景及其解决方案。\n\n**数据结构与初始化**\n\n我们定义一个 `Node` 结构体，包含一个整数标识符 `id` 和一个 `next` 指针。\n$$\n\\text{struct Node} \\{ \\text{struct Node* next; int id;} \\};\n$$\n我们静态分配一个包含 $3$ 个节点的全局节点池，分别称为 $A$、$B$ 和 $C$，以确保它们的内存地址在整个演示过程中保持不变。它们的标识符分别初始化为 $1$、$2$ 和 $3$。主要的数据结构是一个无锁栈，由一个原子头指针 `_Atomic(Node*) stack_head` 表示。第二个类似的栈 `freelist_head` 用于管理已回收的节点。对于确定性测试，主栈初始化为状态 $A \\rightarrow B \\rightarrow C$，其中 $A$ 是头节点。\n\n**测试用例 1：演示 A-B-A 问题**\n\n此测试使用 $2$ 个线程 $T_1$ 和 $T_2$，并禁用危险指针。执行过程通过原子布尔标志精心编排，以强制触发 A-B-A 竞争条件。\n\n$1$. **线程 $T_1$（受害者）**：\n   - 读取栈顶，观察到指针 $A$。记作 $old\\_head$。\n   - 确定下一个节点是 $B$。记作 $new\\_head$。\n   - $T_1$ 现在准备执行 $CAS(stack\\_head, A, B)$ 来完成其弹出操作。\n   - 它向 $T_2$ 发出信号，让其开始操作，然后等待。\n\n$2$. **线程 $T_2$（对手）**：\n   - 收到 $T_1$ 的信号后，$T_2$ 迅速改变栈。\n   - 它弹出 $A$。栈变为 $B \\rightarrow C$。\n   - 它弹出 $B$。栈变为 $C$。\n   - 它通过将节点 $A$ 推入 `freelist` 来“回收”它。由于危险指针被禁用，此操作是立即的。\n   - 它需要一个新节点推入主栈。它通过从 `freelist` 中弹出一个节点来“分配”，这会返回同一个节点 $A$。\n   - 它将这个重新分配的节点 $A$ 推入主栈。栈状态变为 $A \\rightarrow C$。节点 $B$ 现在被孤立了。\n   - 它向 $T_1$ 发出信号，表示其操作已完成。\n\n$3$. **解决**：\n   - $T_1$ 恢复执行，并执行其准备好的 $CAS(stack\\_head, A, B)$。\n   - 因为 $T_2$ 已将重新分配的 $A$ 推回栈上，当前的 `stack_head` 指针等于 $T_1$ 的 `old_head`。$CAS$ 成功。\n   - `stack_head` 被更新为指向 $B$。最终的栈是 $B \\rightarrow C$。$T_2$ 推入的节点 $A$ 现在丢失了。\n   - 在底层状态被显著修改的情况下，$CAS$ 操作的成功正是 A-B-A 问题的体现。此测试的布尔结果是 $1$ (true)。\n\n**测试用例 2：使用危险指针缓解 A-B-A**\n\n此测试重复该场景，使用 $2$ 个线程但启用危险指针。危险指针是每个线程公开可见的指针，用于指示该线程当前正在访问的节点。内存回收逻辑必须扫描所有危险指针，并推迟释放任何被其“保护”的节点。\n\n$1$. **线程 $T_1$**：\n   - 读取栈顶，观察到指针 $A$。\n   - **关键步骤，它发布此指针：$HP[0] \\leftarrow A$。**\n   - 它像之前一样继续，准备其 $CAS$ 操作并向 $T_2$ 发出信号。\n\n$2$. **线程 $T_2$**：\n   - 它像之前一样弹出 $A$ 和 $B$。\n   - 它尝试回收 $A$。其回收逻辑现在会扫描危险指针数组。它发现 $HP[0] == A$。\n   - 因为 $A$ 是危险的，$T_2$ **不能**将其返回到 `freelist`。回收被推迟。\n   - $T_2$ 接着尝试从 `freelist` 分配一个节点。由于 $A$ 未被返回，它不能被重新分配。假设 `freelist` 此外为空，分配将失败（或者如果 `freelist` 中有其他可用节点，则返回该节点）。在我们的特定设置中，`freelist` 是空的，因此分配返回 `NULL`。\n   - $T_2$ 的推入操作没有发生。主栈保持在状态 $C$。\n   - 它向 $T_1$ 发出信号。\n\n$3$. **解决**：\n   - $T_1$ 恢复执行并执行 $CAS(stack\\_head, A, C)$。（注意：当前头节点是 $C$，而不是前一个场景中的 $B$）。\n   - 当前的 `stack_head` 指向 $C$，与 $T_1$ 的 `old_head` 值 $A$ 不匹配。$CAS$ **失败**，这是正确的行为。\n   - $T_1$ 随后会在新的状态上重试其弹出操作。A-B-A 问题被避免了。布尔结果是 $0$ (false)。\n   - 最后，$T_1$ 清除其危险指针：$HP[0] \\leftarrow NULL$。\n\n**测试用例 3：边界条件（单线程）**\n\n此测试使用 $1$ 个线程运行，并禁用危险指针。该线程执行 $T_1$ 的 `pop` 逻辑。由于没有并发的线程 $T_2$ 来操纵栈，从初始读取 $head$ 到最终 $CAS$ 之间的状态保证不变。$CAS$ 会成功。然而，这是一个正确的、有效的操作，而不是 A-B-A 的实例。我们的检测逻辑要求 $CAS$ 成功且 $T_2$ 完成了操纵，因此能正确识别这种情况。结果为 $0$ (false)。\n\n**测试用例 4：回收开销估算**\n\n问题将回收开销定义为每个退役节点执行的危险指针槽位检查次数。当一个线程决定扫描其退役节点列表（假设大小为 $R$）时，它必须将这 $R$ 个节点中的每一个与每个活动的危险指针槽位（假设大小为 $H$）进行核对。\n\n- $R$ 个退役节点的总检查次数 = $H \\times R$。\n- 每个退役节点的平均开销 = $\\frac{H \\times R}{R} = H$。\n\n因此，开销就是系统中危险指针槽位的总数，该数量通常等于线程数。对于给定的参数 $H=4$ 个危险指针槽位和 $R=50$ 个退役节点，计算非常简单：平均开销是 $4.0$。问题的这一部分测试应用给定形式化定义的能力。程序会直接计算这个值。\n\n这四个测试的综合结果，在一个独立、可验证的程序中，全面而实践性地演示了一个关键的并发问题及其标准解决方案。",
            "answer": "```c\n#include"
        }
    ]
}