{
    "hands_on_practices": [
        {
            "introduction": "理论上理解信号量和互斥锁的工作原理是一回事，但在实践中发现并修复由细微操作顺序错误引起的并发漏洞则是另一回事。这项练习将挑战你像操作系统调度器一样思考，通过手动构建一个交错执行的序列来暴露一个有缺陷的消费者实现中的关键竞争条件。通过这个过程，你将深刻理解为什么标准的生产者-消费者解决方案必须严格遵守特定的操作顺序，从而巩固对并发控制核心原则的认识。",
            "id": "3687132",
            "problem": "考虑一个使用计数信号量和二元互斥锁实现的经典有界缓冲区生产者-消费者问题。假设有两个生产者 $P_1$ 和 $P_2$ 以及一个消费者 $C$。缓冲区的容量为 $B$，共享整数 $count$ 跟踪已占用槽位的数量。系统使用计数信号量 $empty$ 和 $full$，其初始值分别为 $empty = B - count$ 和 $full = count$，以及一个保护缓冲区和 $count$ 的二元互斥锁 $m$。原语的语义如下：$\\text{wait}(s)$ 原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞；$\\text{signal}(s)$ 原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。关键的正确性不变量是 $0 \\le count \\le B$ 必须始终成立，并且对缓冲区和 $count$ 的修改仅在持有 $m$ 时发生。\n\n假设生产者的预期序列如下：\n- $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后向缓冲区 $\\text{put}$，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n\n然而，消费者的实现不正确，它会过早地发出 $\\text{signal}(empty)$：\n- $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n从科学上一致的初始状态 $B = 2$、$count = 2$、$empty = 0$、$full = 2$ 开始，并且 $P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上，构建一个交错执行序列，说明 $C$ 过早的 $\\text{signal}(empty)$ 如何导致违反不变量 $count \\le B$。然后，确定一个修正后的消费者序列，该序列通过遵守互斥和容量语义，确保在所有交错执行下不变量 $0 \\le count \\le B$ 都能被保持。\n\n以下哪个选项既\n- 提供了一个具体的交错执行序列（在上述错误消费者的前提下）使得 $count$ 超过 $B$，又\n- 提出了一个修正后的消费者操作顺序，以防止在任何交错执行下发生此类违规？\n\nA. 演示违规的交错执行，然后是修正后的消费者：\n- 交错执行：\n  - $C$：$\\text{wait}(full)$，然后 $\\text{signal}(empty)$。\n  - $P_1$：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$ 使得当 $B=2$ 时 $count = 3$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n- 修正后的消费者序列：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(empty)$。\n\nB. 没有违规的交错执行，然后是错误的消费者修复：\n- 交错执行：\n  - $C$：$\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{signal}(empty)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n  - $P_1$：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$。\n- 提议的消费者修复（仍然过早）：\n  - $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\nC. 演示违规的交错执行，然后是错误的消费者修复：\n- 交错执行：\n  - $C$：$\\text{wait}(full)$，然后 $\\text{signal}(empty)$。\n  - $P_1$：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$。\n  - $C$：在 $P_1$ 持有 $m$ 时 $\\text{wait}(m)$ 阻塞。\n  - $P_1$：$\\text{put}$，然后 $count := count + 1$ 使得当 $B=2$ 时 $count = 3$，然后 $\\text{signal}(m)$。\n- 提议的消费者修复（将 $\\text{take}$ 移到互斥区之外）：\n  - $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(empty)$，然后 $\\text{signal}(m)$。\n\nD. 使用过早的 $\\text{signal}(full)$ 演示违规的交错执行，然后是错误的消费者修复：\n- 交错执行：\n  - $C$：$\\text{wait}(full)$，然后 $\\text{signal}(full)$，然后 $\\text{wait}(m)$。\n  - $P_1$：$\\text{wait}(full)$ 成功，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$ 使得当 $B=2$ 时 $count = 3$。\n- 提议的消费者修复（顺序错误且缺少 $\\text{signal}(empty)$）：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n选择唯一最佳选项。",
            "solution": "在继续之前，对问题陈述进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 进程：两个生产者 $P_1$ 和 $P_2$，一个消费者 $C$。\n- 缓冲区容量：$B$。\n- 共享状态：一个整数 $count$，跟踪已占用槽位的数量。\n- 同步原语：\n    - 计数信号量 $empty$，初始化为 $B - count$。\n    - 计数信号量 $full$，初始化为 $count$。\n    - 二元互斥锁 $m$。\n- 原语语义：\n    - $\\text{wait}(s)$：原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞。\n    - $\\text{signal}(s)$：原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。\n- 正确性不变量：$0 \\le count \\le B$ 必须始终成立。\n- 生产者逻辑：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后向缓冲区 $\\text{put}$，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n- 错误的消费者逻辑：$\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n- 特定初始状态：$B = 2$，$count = 2$，$empty = 0$，$full = 2$。$P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上。假定互斥锁 $m$ 可用（值为 $1$）。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于并发编程和操作系统的原理。它描述了一个经典的同步问题（有界缓冲区），使用了标准的原语（信号量、互斥锁）。术语是精确和客观的。提供的初始状态（$B=2, count=2, empty=0, full=2$）与定义（$empty=B-count=2-2=0$; $full=count=2$）一致。该问题提取得当，要求提供一个特定的执行轨迹来展示一个缺陷和一个修正后的代码序列。对于软件环境而言，该设置并非不完整、矛盾或不切实际。它代表了一种常见的编程错误类型。\n\n**步骤 3：结论与行动**\n问题陈述有效。将推导解决方案。\n\n### 解决方案的推导\n\n问题的核心在于错误的消费者 $C$ 和一个生产者（例如 $P_1$）之间的交互。需要被违反的不变量是 $count \\le B$。我们需要展示一个交错执行如何能导致 $count  2$。\n\n**1. 缺陷分析**\n\n标准的生产者-消费者解决方案使用 $empty$ 和 $full$ 信号量来强制执行缓冲区容量约束。生产者在生产前必须等待一个空槽位（通过调用 $\\text{wait}(empty)$），而消费者在消费前必须等待一个满槽位（通过调用 $\\text{wait}(full)$）。\n\n- **生产者**逻辑是正确的：它等待一个空槽位（$\\text{wait}(empty)$），获取一个锁（$\\text{wait}(m)$）来更新共享状态，添加一个项目并增加 $count$，释放锁（$\\text{signal}(m)$），最后发出一个槽位现在已满的信号（$\\text{signal}(full)$）。\n- **消费者**逻辑是错误的。操作 $\\text{wait}(full)$ 和 $\\text{signal}(empty)$ 在概念上应该包裹消费一个项目的过程。然而，给出的序列是 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$ 等。消费者在它实际获得锁 $m$ 并从缓冲区中移除项目*之前*就发出了一个槽位为空的信号。这产生了一个竞争条件。消费者宣告了一个尚不存在的资源（一个空槽位）。\n\n**2. 构建一个违规的交错执行**\n\n让我们从初始状态开始跟踪一次执行：$B=2$，$count=2$，$empty=0$，$full=2$，$m=1$。$P_1$ 和 $P_2$ 都阻塞在 $\\text{wait}(empty)$ 上。\n\n1.  $C$ 开始执行。生产者被阻塞，所以它们不能运行。\n2.  $C$ 执行 $\\text{wait}(full)$。$full$ 的值为 $2$，所以调用成功，$full$ 减为 $1$。\n3.  $C$ 执行其错误指令：$\\text{signal}(empty)$。$empty$ 的值原为 $0$。此调用将 $empty$ 增为 $1$。由于 $P_1$（或 $P_2$）被阻塞在该信号量上，操作系统会解除对 $P_1$ 的阻塞。$P_1$ 现在处于就绪状态，已经完成了它的 $\\text{wait}(empty)$ 调用。\n4.  此时，发生上下文切换，调度器选择运行 $P_1$。消费者 $C$ 在它能够执行 $\\text{wait}(m)$ 之前被抢占。\n5.  $P_1$ 执行其下一条指令 $\\text{wait}(m)$。互斥锁 $m$ 可用（值为 $1$），所以 $P_1$ 获取了它，$m$ 的值变为 $0$。$P_1$ 现在处于其临界区内。\n6.  在其临界区内，$P_1$ 执行一个 $\\text{put}$ 操作。原本已满的缓冲区现在溢出。\n7.  $P_1$ 执行 $count := count + 1$。$count$ 的值原为 $2$。现在它被增加到 $3$。\n8.  此时，不变量 $count \\le B$ 被违反，因为 $count = 3$ 而 $B = 2$。违规已经发生。$P_1$ 剩余的执行序列（$\\text{signal}(m)$，$\\text{signal}(full)$）以及最终 $C$ 的执行（它将阻塞在 $\\text{wait}(m)$ 上直到 $P_1$ 释放它）不会改变这个事实。\n\n这个交错执行成功地演示了违规。\n\n**3. 提出一个修正后的消费者序列**\n\n要修复这个错误，消费者必须在完成移除一个项目并相应更新共享变量 $count$ *之后*，才能发出一个槽位为空的信号。对共享状态（缓冲区和 $count$）的修改必须受到互斥锁 $m$ 的保护。因此，$\\text{signal}(empty)$ 调用必须移到临界区之后。\n\n消费者正确的、标准的序列是：\n1.  $\\text{wait}(full)$: 等待直到缓冲区中至少有一个项目。\n2.  $\\text{wait}(m)$: 获取锁以访问共享状态。\n3.  $\\text{take}$: 从缓冲区中移除一个项目。\n4.  $count := count - 1$: 将项目计数减一。\n5.  $\\text{signal}(m)$: 释放锁。\n6.  $\\text{signal}(empty)$: 向生产者发出一个槽位已被释放的信号。\n\n这个顺序确保了信号量 $empty$ 正确地代表了可用槽位的数量，从而防止了导致违规的竞争条件。\n\n### 逐项分析\n\n**A. 演示违规的交错执行，然后是修正后的消费者：**\n- **交错执行：**所描述的交错执行（$C$ 运行 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$；然后 $P_1$ 被唤醒，获取 $m$，并将 $count$ 增加到 $3$）与上面推导出的违规轨迹完全匹配。这部分是正确的。\n- **修正后的消费者序列：**提议的序列是 $\\text{wait}(full)$、$\\text{wait}(m)$、$\\text{take}$、$count := count - 1$、$\\text{signal}(m)$、$\\text{signal}(empty)$。如上所述，这是标准的正确实现。这部分是正确的。\n- **结论：** **正确**。\n\n**B. 没有违规的交错执行，然后是错误的消费者修复：**\n- **交错执行：**这描述了一个 $C$ 在上下文切换前获取互斥锁的交错执行。如分析所示，这个特定的交错执行不会产生违规。任务是展示一个*确实*会产生违规的交错执行。这部分未能完成任务。\n- **提议的消费者修复：**提议的“修复”与原始的错误序列完全相同。这部分是不正确的。\n- **结论：** **不正确**。\n\n**C. 演示违规的交错执行，然后是错误的消费者修复：**\n- **交错执行：**该交错执行的描述比选项 A 中更详细一些（明确显示了 $C$ 阻塞在 $m$ 上），但在概念上是同样正确的违规演示。这部分是正确的。\n- **提议的消费者修复：**提议的序列是 $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，... 这是有严重缺陷的。$\\text{take}$ 操作修改了共享缓冲区，但被放置在由互斥锁 $m$ 保护的临界区之外。这引入了另一种竞争条件。这部分是不正确的。\n- **结论：** **不正确**。\n\n**D. 使用过早的 $\\text{signal}(full)$ 演示违规的交错执行，然后是错误的消费者修复：**\n- **交错执行：**该交错执行描述了一个不同的错误，即过早的 $\\text{signal}(full)$。问题明确指出错误是过早的 $\\text{signal}(empty)$。此外，它错误地声称生产者等待 `full`，而实际上它们等待的是 `empty`。这部分与问题陈述不一致。\n- **提议的消费者修复：**提议的修复缺少 $\\text{take}$ 操作和 $\\text{signal}(empty)$ 调用，这将最终导致系统死锁，因为生产者将永远不会被通知。这部分是不正确的。\n- **结论：** **不正确**。\n\n基于以上分析，选项 A 是唯一一个既通过有效的交错执行正确演示了违规，又为消费者的逻辑提供了标准、正确的修复方案的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在确保了逻辑正确性之后，下一个挑战是根据性能要求来设计系统。这项练习将有界缓冲问题置于一个具有严格截止期限的实时系统场景中。通过从第一性原理出发，推导出处理突发数据所需的最小缓冲区容量，你将学会如何将抽象的数据结构与吞吐量、延迟等具体的系统性能指标联系起来，这对于设计满足服务质量（QoS）要求的健壮系统至关重要。",
            "id": "3687090",
            "problem": "一个单生产者、单消费者的有界缓冲区系统必须保证每个被接纳的项目在不晚于一个固定的单位项目截止时间前完成服务。缓冲区仅存放等待中的项目；消费者从缓冲区取出一个项目开始服务，并在服务期间持有该项目。假设存在以下基础模型。\n\n- 在时间 $t = 0$ 时，一个最坏情况下的包含 $X$ 个项目的突发同时到达。这些项目是相同的，并以先到先服务的顺序入队。\n- 消费者以每秒 $\\mu$ 个项目的恒定速率处理项目，因此每个项目的确定性服务时间为 $1/\\mu$ 秒。不存在上下文切换或出队开销。\n- 每个项目必须在到达后的 $D$ 秒内完成服务。系统在项目到达时采用准入控制：对于给定的当前队列状态无法满足其截止时间的项目，将不被接纳进入缓冲区并立即被拒绝，以免在注定迟到的项目上浪费缓冲区空间。\n- 如果至少有一个项目被接纳，消费者在 $t = 0^{+}$ 时立即开始处理。在 $t = 0$ 的突发之后没有新的项目到达。\n\n从该模型的第一性原理出发，推导出一个闭式表达式，用于计算所需的最小缓冲区容量 $B$（以缓冲区槽位为单位），以确保在所述的最坏情况突发下，没有被接纳的项目因缓冲区溢出而丢失，并且每个被接纳的项目都在其截止时间前完成。\n\n请用一个包含 $X$、$\\mu$ 和 $D$ 的单一解析表达式来表示你的最终答案。不需要进行数值近似或四舍五入。",
            "solution": "问题要求在特定条件下，单生产者、单消费者系统所需的最小缓冲区容量 $B$。推导过程从第一性原理出发，通过分析以先到先服务（FCFS）方式处理的项目的事件时序来进行。\n\n我们将包含 $X$ 个项目的突发到达时间记为 $t_{arrival} = 0$。根据问题陈述，每个被接纳的项目必须在到达后的 $D$ 秒内完成服务。因此，对于任何被接纳的项目，其完成时间 $t_{completion}$ 必须满足条件 $t_{completion} \\le D$。\n\n消费者以每秒 $\\mu$ 个项目的恒定速率处理项目。这意味着单个项目的服务时间是确定性的，等于 $s = 1/\\mu$ 秒。系统采用FCFS排队规则。我们来分析处理序列中第 $k$ 个项目的完成时间，其中 $k$ 是一个正整数（$k=1, 2, 3, \\dots$）。\n\n第一个项目（$k = 1$）在 $t = 0$ 时入队，由于消费者立即可用，其服务在 $t=0^{+}$ 开始。其服务在时间 $t_{completion,1} = 1/\\mu$ 完成。\n第二个项目（$k = 2$）必须等待第一个项目完成。它在时间 $1/\\mu$ 进入服务，并在时间 $t_{completion,2} = 1/\\mu + 1/\\mu = 2/\\mu$ 完成服务。\n将此模式推广，第 $k$ 个被处理的项目将在以下时间完成其服务：\n$$t_{completion,k} = k \\times \\frac{1}{\\mu} = \\frac{k}{\\mu}$$\n\n系统采用准入控制策略：一个项目只有在能够满足其截止时间的情况下才被接纳。对于处理序列中的第 $k$ 个项目，这意味着其完成时间不能超过截止时间 $D$。\n$$\\frac{k}{\\mu} \\le D$$\n这个不等式可以重新整理，以求出 $k$ 的最大可能值：\n$$k \\le \\mu D$$\n\n由于 $k$ 必须表示整数个项目，因此在满足所有截止时间的情况下可以处理的最大项目数，我们称之为 $A_{max\\_servable}$，是小于或等于 $\\mu D$ 的最大整数。这可以用向下取整函数表示：\n$$A_{max\\_servable} = \\lfloor \\mu D \\rfloor$$\n\n在时间 $t=0$ 时，一个包含 $X$ 个项目的突发到达。系统接纳的项目数不能超过可用项目数。因此，实际被接纳的项目数，我们记为 $A$，是可用项目数 $X$ 和系统可服务处理的最大项目数 $A_{max\\_servable}$ 中的较小者。\n$$A = \\min(X, A_{max\\_servable}) = \\min(X, \\lfloor \\mu D \\rfloor)$$\n\n我们现在需要确定所需的缓冲区容量 $B$。问题陈述中说明，缓冲区仅存放*等待中*的项目。当前正在服务的项目由消费者持有，不在缓冲区中。在时间 $t=0$，$A$ 个项目被接纳。在时间 $t=0^{+}$，如果 $A  0$，第一个项目立即出队并进入服务。剩下的 $A-1$ 个项目必须驻留在缓冲区中。这个时刻代表了缓冲区的峰值占用率，因为从这一点开始，没有新项目到达，缓冲区中的项目数量只会随着消费者逐个处理而减少。\n\n因此，最小缓冲区容量 $B$ 必须足够大以容纳这些等待中的项目。\n$$B = A - 1$$\n\n这对 $A \\ge 1$ 成立。如果 $A=0$ 或 $A=1$，等待中的项目数量为 $0$。负的缓冲区容量在物理上没有意义。缓冲区容量必须是一个非负整数。因此，所需的容量是等待中的项目数，并以 $0$ 为下限。\n$$B = \\max(0, A - 1)$$\n\n将 $A$ 的表达式代入此方程，得到所需最小缓冲区容量的最终闭式表达式：\n$$B = \\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)$$\n\n该表达式正确地涵盖了所有情况。例如，如果服务时间 $1/\\mu$ 超过了截止时间 $D$，则 $\\mu D  1$，这意味着 $\\lfloor \\mu D \\rfloor = 0$。这导致 $A=0$ 且 $B=\\max(0, 0-1) = 0$，这是正确的，因为没有项目可以被接纳。如果只有一个项目被接纳（$A=1$），它直接进入消费者，缓冲区需求为 $B = \\max(0, 1-1) = 0$，这也是正确的。对于任何超过一个被接纳的项目（$A > 1$），一个在服务中， $A-1$ 个在缓冲区中，与公式相符。",
            "answer": "$$\\boxed{\\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)}$$"
        },
        {
            "introduction": "手动寻找导致错误的线程交错序列既困难又容易出错。本练习介绍了一种更强大的自动化技术：模型检测。你将亲手实现一个简单的验证器，它能穷举探索有界缓冲区实现的状态空间，从而系统地找出常见的“差一错误”（off-by-one error）。这项实践不仅加深了你对循环缓冲区索引和容量管理的理解，还让你体验了如何将抽象的系统不变量（invariants）转化为可执行的、能自动发现程序错误的具体代码。",
            "id": "3687126",
            "problem": "设计并实现一个完整、可运行的程序，该程序系统性地模型检验一个有界缓冲循环区的实现，以检查循环索引和容量守卫中的差一错误。有界缓冲区（也称生产者-消费者队列）的容量为 $B$，并有两个索引：生产者索引 $p$ 和消费者索引 $c$。占用量（当前缓冲区中的项目数）为 $n$。生产出的项目使用严格递增的标识符 $0, 1, 2, \\ldots$ 进行标记，正确的消费必须保持顺序，无重复、无丢失。\n\n从以下基本原则出发：\n- 对索引进行的模运算遵循 $x' = (x + 1) \\bmod m$ 规则，用于当一个模为 $m$ 的索引前进一位时的回环处理。\n- 有界缓冲区的安全性属性要求在任何时候都满足 $\\;0 \\le n \\le B\\;$，并且两个索引都满足 $\\;0 \\le p  B\\;$ 和 $\\;0 \\le c  B\\;$。\n- 总生产量与总消费量之间的守恒关系为 $\\;n = N_p - N_c\\;$，其中 $N_p$ 是已生产项目的计数，$N_c$ 是已消费项目的计数。\n- 消费的正确性要求在索引 $c$ 处读取的值等于下一个预期的标识符 $\\;N_c\\;$。\n\n您必须将循环缓冲区实现为两个标记迁移系统模型，并通过有限状态探索来验证它们：\n- 修复前（有缺陷的）模型，旨在展示差一错误：\n  1. 当 $\\;n \\le B\\;$ 时，允许生产。\n  2. 生产者将当前项目 $\\;N_p\\;$ 写入位置 $\\;p\\;$，然后用 $p' = (p + 1) \\bmod B$ 更新 $p$，用 $n' = n + 1$ 更新 $n$，并将 $N_p$ 增加 1。\n  3. 当 $\\;n  0\\;$ 时，允许消费。\n  4. 消费者检查索引 $c$ 处的缓冲区值是否等于 $\\;N_c\\;$，消费该项目，然后用 $c' = (c + 1) \\bmod (B + 1)$ 更新 $c$，用 $n' = n - 1$ 更新 $n$，并将 $N_c$ 增加 1。\n- 修复后（已修正的）模型：\n  1. 当 $\\;n  B\\;$ 时，允许生产。\n  2. 生产者将当前项目 $\\;N_p\\;$ 写入位置 $\\;p\\;$，然后用 $p' = (p + 1) \\bmod B$ 更新 $p$，用 $n' = n + 1$ 更新 $n$，并将 $N_p$ 增加 1。\n  3. 当 $\\;n  0\\;$ 时，允许消费。\n  4. 消费者检查索引 $c$ 处的缓冲区值是否等于 $\\;N_c\\;$，消费该项目，然后用 $c' = (c + 1) \\bmod B$ 更新 $c$，用 $n' = n - 1$ 更新 $n$，并将 $N_c$ 增加 1。\n\n模型检验要求：\n- 从 $\\;p = 0\\;$, $\\;c = 0\\;$, $\\;n = 0\\;$, $\\;N_p = 0\\;$, 和 $\\;N_c = 0\\;$ 的初始状态开始，使用深度优先搜索（DFS）对所有长度最多为 $S$ 步的执行轨迹进行穷尽探索。在每一步，如果生产和消费都可进行，则分支探索两个迁移。如果只有一个可进行，则执行该迁移。如果两者都不可进行或达到步数限制，则终止该分支。\n- 在每个达到的状态，检查不变量 $\\;0 \\le p  B\\;$, $\\;0 \\le c  B\\;$, $\\;0 \\le n \\le B\\;$ 和 $\\;n = N_p - N_c\\;$。\n- 在每次消费迁移时，在更新索引和计数器之前，额外检查读取的值是否等于 $\\;N_c\\;$。\n\n只要在任何探索的轨迹上出现任何不变量失败或读取值检查失败，即发生违规（这代表一个反例）。当且仅当在深度为 $S$ 的所有探索轨迹中都没有发生违规时，模型才算通过。\n\n测试套件：\n- 案例 1：$B = 3$, $S = 6$。\n- 案例 2：$B = 1$, $S = 4$。\n- 案例 3：$B = 2$, $S = 5$。\n- 案例 4：$B = 4$, $S = 7$。\n\n对每个案例，运行修复前模型和修复后模型。要求的最终输出格式为单行，包含两个列表：第一个列表包含修复前模型的结果，第二个列表包含修复后模型的结果。每个条目是一个布尔值，如果模型通过（在深度 $S$ 内的所有轨迹中未发现违规），则编码为 $1$，如果模型失败（在至少一个轨迹中发现违规），则编码为 $0$。您的程序应生成单行输出，包含用方括号括起来的逗号分隔列表结果，具体格式如下：\n$$\\text{[[}b_1,b_2,b_3,b_4\\text{],[}f_1,f_2,f_3,f_4\\text{]]}$$\n其中 $b_i$ 和 $f_i$ 分别是案例 $i$ 中修复前模型和修复后模型的布尔结果。",
            "solution": "该问题要求设计并实现一个模型检验器，用于根据一组安全性和正确性属性，验证有界缓冲区算法的两种实现。此任务属于计算机科学中的形式化方法领域，特别是有限状态系统的算法验证。\n\n解决方案的架构是使用深度优先搜索（DFS）算法进行系统性的、穷尽的状态空间探索。有界缓冲区系统被建模为一个标记迁移系统，其中状态由系统变量定义，迁移代表生产者或消费者的行为。\n\n### 状态表示\n系统的状态 $\\Sigma$ 是一个元组，包括生产者索引 $p$、消费者索引 $c$、当前占用量 $n$、已生产项目总数 $N_p$、已消费项目总数 $N_c$ 以及缓冲区数组本身的内容。\n$$ \\Sigma = (p, c, n, N_p, N_c, \\text{buffer}) $$\n缓冲区是一个大小为 $B$ 的数组。初始时，系统处于状态 $\\Sigma_0 = (0, 0, 0, 0, 0, \\text{empty\\_buffer})$，此时缓冲区被视为空。\n\n### 迁移系统\n系统的行为由任意给定状态下的两种可能迁移定义：生产迁移（$T_p$）和消费迁移（$T_c$）。每个迁移由一个守卫（迁移要被启用必须为真的条件）和一个动作（更新状态的规则）定义。\n\n#### 1. 修复前（有缺陷的）模型\n- **生产迁移 ($T_p$)**:\n  - 守卫：$n \\le B$。这个守卫是有缺陷的，因为它允许在缓冲区已满时（即当 $n=B$ 时）进行生产。\n  - 动作：将一个标识符为 $N_p$ 的项目写入 $\\text{buffer}[p]$。状态更新如下：\n    $$ p' = (p + 1) \\bmod B $$\n    $$ n' = n + 1 $$\n    $$ N_p' = N_p + 1 $$\n- **消费迁移 ($T_c$)**:\n  - 守卫：$n  0$。这个守卫是正确的。\n  - 动作：消费位于 $\\text{buffer}[c]$ 的项目。状态更新如下：\n    $$ c' = (c + 1) \\bmod (B + 1) $$\n    $$ n' = n - 1 $$\n    $$ N_c' = N_c + 1 $$\n    消费者索引 $c$ 的模数 $B+1$ 是一个缺陷。由于有效的缓冲区索引是 $0, 1, \\ldots, B-1$，此规则最终将导致 $c$ 取值为 $B$，从而尝试越界访问。\n\n#### 2. 修复后（已修正的）模型\n- **生产迁移 ($T_p$)**:\n  - 守卫：$n  B$。这是正确的守卫，防止在缓冲区已满时进行生产。\n  - 动作：与修复前模型相同。\n    $$ p' = (p + 1) \\bmod B $$\n    $$ n' = n + 1 $$\n    $$ N_p' = N_p + 1 $$\n- **消费迁移 ($T_c$)**:\n  - 守卫：$n  0$。\n  - 动作：使用正确的模数更新消费者索引，状态更新如下：\n    $$ c' = (c + 1) \\bmod B $$\n    $$ n' = n - 1 $$\n    $$ N_c' = N_c + 1 $$\n\n### 通过深度优先搜索进行验证\n模型检验过程实现为一个递归函数 `model_check_dfs`，该函数从初始状态 $\\Sigma_0$ 开始，对状态空间图执行 DFS。搜索受最大探索深度 $S$ 的限制。\n\n每个递归步骤的算法如下：\n1.  **不变量检查**：在给定深度进入新状态时，函数首先验证一组安全性不变量：\n    - 索引边界：$0 \\le p  B$ 和 $0 \\le c  B$。\n    - 占用量边界：$0 \\le n \\le B$。\n    - 守恒定律：$n = N_p - N_c$。\n    如果任何不变量被违反，则模型失败。函数返回失败状态，从而对当前搜索路径进行剪枝。\n\n2.  **深度检查**：如果当前搜索深度达到限制 $S$，该路径的探索成功终止，函数返回成功状态。\n\n3.  **迁移探索**：函数根据模型的守卫确定从当前状态可以启用哪些迁移（$T_p$ 和/或 $T_c$）。\n    - 如果可以进行生产，则根据生产者动作计算一个新状态，并以增加的深度对这个新状态递归调用 `model_check_dfs` 函数。\n    - 如果可以进行消费，算法首先执行一个关键的数据正确性检查：验证 `buffer[c]` 处的项目确实是下一个预期的项目，即 `buffer[c] == N_c`。如果此检查失败，则表示数据损坏或丢失，模型失败。如果检查通过，则根据消费者动作计算一个新状态，并进行递归调用。\n\n4.  **结果传播**：如果任何递归调用返回失败状态，该状态会立即沿调用栈向上传播。一旦找到第一个反例（即导致违反不变量或正确性属性的状态的轨迹），整个模型就被视为失败。如果在深度 $S$ 内探索了所有可能的执行轨迹而未发现任何违规，则认为模型已通过检查。\n\n这种系统化的方法保证了如果存在一个可由 $S$ 个或更少操作序列触发的缺陷，模型检验器将会找到它。修复前模型中的缺陷——特别是缓冲区溢出（$n  B$）和消费者索引越界（$c \\ge B$）的可能性——很容易被不变量检查检测到。修复后模型采用了正确的守卫和更新规则，遵守所有指定的属性，因此通过了验证。",
            "answer": "[[0,0,0,0],[1,1,1,1]]"
        }
    ]
}