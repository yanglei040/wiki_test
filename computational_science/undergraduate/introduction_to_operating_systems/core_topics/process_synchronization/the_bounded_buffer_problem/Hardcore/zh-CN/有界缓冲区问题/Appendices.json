{
    "hands_on_practices": [
        {
            "introduction": "在设计任何缓冲系统时，首要问题之一是：“缓冲区需要多大？” 这个问题的答案并非凭空猜测，而是基于系统必须满足的性能要求。本练习将指导你从第一性原理出发，通过一个假设的场景来推导缓冲区大小，场景中数据以突发方式到达，且每个数据项都有严格的处理时限。通过这个计算 ，你将掌握如何将外部约束（如突发负载和延迟要求）量化为内部设计参数（如缓冲区容量），这是连接理论与现实系统设计的关键一步。",
            "id": "3687090",
            "problem": "一个单生产者、单消费者的有界缓冲区系统必须保证每个被接纳的项目最迟在一个固定的单位项目截止时间内完成服务。缓冲区只存放等待中的项目；消费者从缓冲区取出一个项目开始服务，并在服务期间持有该项目。假设遵循以下基础模型。\n\n- 在时间 $t = 0$ 时，最坏情况下的 $X$ 个项目突发同时到达。这些项目是相同的，并按先到先服务的顺序入队。\n- 消费者以每秒 $\\mu$ 个项目的恒定速率处理项目，因此每个项目的确定性服务时间为 $1/\\mu$ 秒。不存在上下文切换或出队开销。\n- 每个项目必须在到达后的 $D$ 秒内完成服务。系统在项目到达时采用准入控制：对于给定当前队列状态而无法满足其截止时间的项目，将不被接纳进入缓冲区并立即被拒绝，以免在注定迟到的项目上浪费缓冲区空间。\n- 如果至少有一个项目被接納，消费者在 $t = 0^{+}$ 时立即开始处理。在 $t = 0$ 的突发之后没有新的项目到达。\n\n从该模型的第一性原理出发，推导出一个闭式表达式，用于计算所需的最小缓冲区容量 $B$（以缓冲区槽位为单位），以确保在所述的最坏情况突发下，没有被接納的项目因缓冲区溢出而丢失，并且每个被接納的项目都在其截止时间内完成。\n\n请用一个包含 $X$、$\\mu$ 和 $D$ 的单一解析表达式来表示你的最终答案。不需要数值近似或四舍五入。",
            "solution": "问题要求在特定条件下，单生产者、单消费者系统所需的最小缓冲区容量 $B$。推导过程从第一性原理出发，通过分析按先到先服务（FCFS）方式处理的项目的事件时间来进行。\n\n让我们将 $X$ 个项目突发到达的时间表示为 $t_{arrival} = 0$。根据问题描述，每个被接纳的项目必须在其到达后的 $D$ 秒截止時間内完成服务。因此，对于任何被接纳的项目，其完成时间 $t_{completion}$ 必须满足条件 $t_{completion} \\le D$。\n\n消费者以每秒 $\\mu$ 个项目的恒定速率处理项目。这意味着单个项目的服务时间是确定性的，等于 $s = 1/\\mu$ 秒。系统采用 FCFS 排队规则。让我们分析处理序列中第 $k$ 个项目的完成时间，其中 $k$ 是一个正整数（$k=1, 2, 3, \\dots$）。\n\n第一个项目（$k = 1$）在 $t = 0$ 时入队，并且由于消费者立即可用，其服务在 $t=0^{+}$ 时开始。其服务在时间 $t_{completion,1} = 1/\\mu$ 完成。\n第二个项目（$k = 2$）必须等待第一个项目完成。它在时间 $1/\\mu$ 进入服务，并在时间 $t_{completion,2} = 1/\\mu + 1/\\mu = 2/\\mu$ 完成服务。\n推广此模式，第 $k$ 个待处理的项目将在以下时间完成其服务：\n$$t_{completion,k} = k \\times \\frac{1}{\\mu} = \\frac{k}{\\mu}$$\n\n系统采用准入控制策略：一个项目只有在能够满足其截止时间的情况下才会被接纳。对于处理序列中的第 $k$ 个项目，这意味着其完成时间不能超过截止时间 $D$。\n$$\\frac{k}{\\mu} \\le D$$\n这个不等式可以重新排列以找到 $k$ 的最大可能值：\n$$k \\le \\mu D$$\n\n由于 $k$ 必須代表整数个项目，因此在满足所有截止时间的前提下可以处理的最大项目数（我们称之为 $A_{max\\_servable}$）是小于或等于 $\\mu D$ 的最大整数。这由向下取整函数表示：\n$$A_{max\\_servable} = \\lfloor \\mu D \\rfloor$$\n\n在时间 $t=0$ 时，有 $X$ 个项目的突发到达。系统不能接纳超过可用项目数量的项目。因此，实际被接纳的项目数（我们表示为 $A$）是可用项目数 $X$ 和系统可服务处理的最大项目数 $A_{max\\_servable}$ 之间的最小值。\n$$A = \\min(X, A_{max\\_servable}) = \\min(X, \\lfloor \\mu D \\rfloor)$$\n\n我们现在需要确定所需的缓冲区容量 $B$。问题陈述缓冲区只存放*等待中*的项目。当前正在服务的项目由消费者持有，不在缓冲区中。在时间 $t=0$ 时，有 $A$ 个项目被接纳。在时间 $t=0^{+}$ 时，如果 $A  0$，第一个项目会立即出队并进入服务。剩下的 $A-1$ 个项目必须驻留在缓冲区中。这一刻代表了缓冲区的峰值占用率，因为从此时起，没有新项目到达，缓冲区中的项目数量只会随着消费者逐一处理而减少。\n\n因此，最小缓冲区容量 $B$ 必须足够大以容纳这些等待中的项目。\n$$B = A - 1$$\n\n这在 $A \\ge 1$ 时有效。如果 $A=0$ 或 $A=1$，等待中的项目数量为 $0$。负的缓冲区容量没有物理意义。缓冲区容量必须是一个非负整数。因此，所需的容量是等待中的项目数，并以 $0$ 为下限。\n$$B = \\max(0, A - 1)$$\n\n将 $A$ 的表达式代入此方程，得到所需最小缓冲区容量的最终闭式表达式：\n$$B = \\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)$$\n\n这个表达式正确地涵盖了所有情况。例如，如果服务时间 $1/\\mu$ 超过截止时间 $D$，则 $\\mu D  1$，这意味着 $\\lfloor \\mu D \\rfloor = 0$。这导致 $A=0$ 和 $B=\\max(0, 0-1) = 0$，这是正确的，因为没有项目可以被接纳。如果只有一个项目被接纳（$A=1$），它直接进入消费者，缓冲区需求为 $B = \\max(0, 1-1) = 0$，这也是正确的。对于任何被接纳的大于1的项目（$A > 1$），一个在服务中，$A-1$ 个在缓冲区中，与公式相符。",
            "answer": "$$\\boxed{\\max(0, \\min(X, \\lfloor \\mu D \\rfloor) - 1)}$$"
        },
        {
            "introduction": "确定了缓冲区大小后，下一个挑战是正确地管理并发访问，以防止生产者和消费者线程相互干扰。即使逻辑看似正确，微小的实现错误也可能导致灾难性的后果，例如缓冲区溢出。这个练习  展示了一个经典的例子：由于消费者代码中一个不合时宜的信号量操作，导致系统不变量被破坏。通过追踪线程的交错执行，你将学会如何“扮演”操作系统调度器，以发现并理解这类难以捉摸的并发错误。",
            "id": "3687132",
            "problem": "考虑一个使用计数信号量和二元互斥锁实现的经典有界缓冲区生产者-消费者问题。设有两个生产者 $P_1$ 和 $P_2$ 以及一个消费者 $C$。缓冲区的容量为 $B$，共享整数 $count$ 跟踪已占用槽位的数量。系统使用计数信号量 $empty$ 和 $full$，初始值分别为 $empty = B - count$ 和 $full = count$，以及一个保护缓冲区和 $count$ 的二元互斥锁 $m$。原语的语义如下：$\\text{wait}(s)$ 原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞；$\\text{signal}(s)$ 原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。关键的正确性不变量是 $0 \\le count \\le B$ 必须始终成立，并且对缓冲区和 $count$ 的修改仅在持有 $m$ 时发生。\n\n假设预期的生产者序列如下：\n- $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后向缓冲区 $\\text{put}$，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n\n然而，消费者的实现不正确，它会过早地发出 $\\text{signal}(empty)$：\n- $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n从科学上一致的初始状态 $B = 2$，$count = 2$，$empty = 0$，$full = 2$ 开始，并且 $P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上，构造一个交错执行序列，展示 $C$ 过早执行 $\\text{signal}(empty)$ 如何导致违反不变量 $count \\le B$。然后，确定一个修正后的消费者序列，该序列通过遵守互斥和容量语义，确保不变量 $0 \\le count \\le B$ 在所有交错执行下都得以保持。\n\n下面的哪个选项既\n- 提供了一个具体的交错执行序列（在给定上述错误消费者的情况下）使得 $count$ 超过 $B$，\n- 又提出了一个修正后的消费者操作顺序以防止任何交错执行下出现此类违规？\n\nA. 演示违规的交错执行，然后是修正后的消费者：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后执行 $\\text{signal}(empty)$。\n  - $P_1$：执行 $\\text{wait}(empty)$，然后执行 $\\text{wait}(m)$，然后执行 $\\text{put}$，然后 $count := count + 1$ 使得 $count = 3$ 而 $B = 2$，然后执行 $\\text{signal}(m)$，然后执行 $\\text{signal}(full)$。\n- 修正后的消费者序列：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(empty)$。\n\nB. 没有违规的交错执行，然后是错误的消费者修复方案：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后执行 $\\text{wait}(m)$，然后执行 $\\text{signal}(empty)$，然后执行 $\\text{take}$，然后 $count := count - 1$，然后执行 $\\text{signal}(m)$。\n  - $P_1$：执行 $\\text{wait}(empty)$，然后执行 $\\text{wait}(m)$，然后执行 $\\text{put}$，然后 $count := count + 1$。\n- 提议的消费者修复方案（仍然过早）：\n  - $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\nC. 演示违規的交错执行，然后是错误的消费者修复方案：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后执行 $\\text{signal}(empty)$。\n  - $P_1$：执行 $\\text{wait}(empty)$，然后执行 $\\text{wait}(m)$。\n  - $C$：$\\text{wait}(m)$ 阻塞，因为 $P_1$ 持有 $m$。\n  - $P_1$：执行 $\\text{put}$，然后 $count := count + 1$ 使得 $count = 3$ 而 $B = 2$，然后执行 $\\text{signal}(m)$。\n- 提议的消费者修复方案（将 $\\text{take}$ 移到互斥区之外）：\n  - $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(empty)$，然后 $\\text{signal}(m)$。\n\nD. 使用过早的 $\\text{signal}(full)$ 演示违规的交错执行，然后是错误的消费者修复方案：\n- 交错执行：\n  - $C$：执行 $\\text{wait}(full)$，然后执行 $\\text{signal}(full)$，然后执行 $\\text{wait}(m)$。\n  - $P_1$：$\\text{wait}(full)$ 成功，然后执行 $\\text{wait}(m)$，然后执行 $\\text{put}$，然后 $count := count + 1$ 使得 $count = 3$ 而 $B = 2$。\n- 提议的消费者修复方案（顺序错误且缺少 $\\text{signal}(empty)$）：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n选择唯一的最佳选项。",
            "solution": "在继续之前，对问题陈述进行验证。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n- 进程：两个生产者 $P_1$ 和 $P_2$，以及一个消费者 $C$。\n- 缓冲区容量：$B$。\n- 共享状态：一个整数 $count$，跟踪已占用槽位的数量。\n- 同步原语：\n    - 计数信号量 $empty$，初始化为 $B - count$。\n    - 计数信号量 $full$，初始化为 $count$。\n    - 二元互斥锁 $m$。\n- 原语语义：\n    - $\\text{wait}(s)$：原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞。\n    - $\\text{signal}(s)$：原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。\n- 正确性不变量：$0 \\le count \\le B$ 必须始终成立。\n- 生产者逻辑：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后向缓冲区 $\\text{put}$，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n- 错误的消费者逻辑：$\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n- 特定初始状态：$B = 2$，$count = 2$，$empty = 0$，$full = 2$。$P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上。假定互斥锁 $m$ 可用（值为 $1$）。\n\n**步骤 2：使用提取的给定条件进行验证**\n该问题在科学上基于并发编程和操作系统的原理。它描述了一个使用标准原语（信号量、互斥锁）的经典同步问题（有界缓冲区）。术语是精确和客观的。提供的初始状态 ($B=2, count=2, empty=0, full=2$) 与定义 ($empty=B-count=2-2=0$; $full=count=2$) 一致。问题提得很好，要求提供一个特定的执行轨迹来展示缺陷，并提供一个修正后的代码序列。对于软件上下文来说，这个设置不是不完整的、矛盾的或不切实际的。它代表了一种常见的编程错误类型。\n\n**步骤 3：结论与行动**\n问题陈述有效。将推导出解决方案。\n\n### 解决方案的推导\n\n问题的核心在于错误的消费者 $C$ 和某个生产者（比如 $P_1$）之间的交互。需要被违反的不变量是 $count \\le B$。我们需要展示一个交错执行如何能导致 $count > 2$。\n\n**1. 缺陷分析**\n\n标准的生产者-消费者解决方案使用 $empty$ 和 $full$ 信号量来强制执行缓冲区容量约束。生产者在生产前必须等待一个空槽位（通过调用 $\\text{wait}(empty)$），而消费者在消费前必须等待一个满槽位（通过调用 $\\text{wait}(full)$）。\n\n- **生产者**逻辑是正确的：它等待一个空槽位 ($\\text{wait}(empty)$)，获取一个锁 ($\\text{wait}(m)$) 来更新共享状态，添加一个物品并增加 $count$，释放锁 ($\\text{signal}(m)$)，最后通知一个槽位现在已满 ($\\text{signal}(full)$)。\n- **消费者**逻辑是错误的。操作 $\\text{wait}(full)$ 和 $\\text{signal}(empty)$ 在概念上应该包围着对一个物品的消费过程。然而，给定的序列是 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$ 等等。消费者在它实际获取锁 $m$ 并从缓冲区中移除物品*之前*就通知一个槽位是空的。这造成了竞争条件。消费者宣告了一个尚不存在的资源（一个空槽位）。\n\n**2. 构造一个违反不变量的交错执行**\n\n让我们从初始状态开始跟踪一个执行过程：$B=2$，$count=2$，$empty=0$，$full=2$，$m=1$。$P_1$ 和 $P_2$ 阻塞在 $\\text{wait}(empty)$ 上。\n\n1.  $C$ 开始执行。生产者被阻塞，所以它们不能运行。\n2.  $C$ 执行 $\\text{wait}(full)$。$full$ 的值为 $2$，所以调用成功，$full$ 被减为 $1$。\n3.  $C$ 执行其错误指令：$\\text{signal}(empty)$。$empty$ 的值原为 $0$。此调用将 $empty$ 增至 $1$。由于 $P_1$（或 $P_2$）阻塞在该信号量上，操作系统会解除 $P_1$ 的阻塞。$P_1$ 现在处于就绪状态，已完成了它的 $\\text{wait}(empty)$ 调用。\n4.  此时，发生上下文切换，调度器选择运行 $P_1$。消费者 $C$ 在执行 $\\text{wait}(m)$ 之前被抢占。\n5.  $P_1$ 执行它的下一条指令 $\\text{wait}(m)$。互斥锁 $m$ 可用（值为 $1$），所以 $P_1$ 获取它，$m$ 的值变为 $0$。$P_1$ 现在处于其临界区内。\n6.  在其临界区内，$P_1$ 执行一个 $\\text{put}$ 操作。原本已满的缓冲区现在溢出了。\n7.  $P_1$ 执行 $count := count + 1$。$count$ 的值原为 $2$。现在它被增至 $3$。\n8.  此刻，不变量 $count \\le B$ 被违反，因为 $count = 3$ 而 $B = 2$。违规已经发生。$P_1$ 的剩余执行序列（$\\text{signal}(m)$，$\\text{signal}(full)$）以及最终 $C$ 的执行（它将在 $\\text{wait}(m)$ 上阻塞直到 $P_1$ 释放它）都不会改变这个事实。\n\n这个交错执行成功地演示了违规情况。\n\n**3. 提出修正后的消费者序列**\n\n要修复这个 bug，消费者必须在完成移除物品和相应更新共享变量 $count$ *之后*，才能通知一个槽位变为空。对共享状态（缓冲区和 $count$）的修改必须由互斥锁 $m$ 保护。因此，$\\text{signal}(empty)$ 调用必须移到临界区之后。\n\n消费者的正确、标准序列是：\n1.  $\\text{wait}(full)$：等待直到缓冲区中至少有一个物品。\n2.  $\\text{wait}(m)$：获取锁以访问共享状态。\n3.  $\\text{take}$：从缓冲区中取出一个物品。\n4.  $count := count - 1$：将物品计数减一。\n5.  $\\text{signal}(m)$：释放锁。\n6.  $\\text{signal}(empty)$：向生产者通知一个槽位已被释放。\n\n这个顺序确保了信号量 $empty$ 正确地表示可用槽位的数量，从而防止了导致违规的竞争条件。\n\n### 逐个选项分析\n\n**A. 演示违规的交錯執行，然後是修正後的消費者：**\n- **交错执行：** 所描述的交错执行（$C$ 运行 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$；然后 $P_1$ 被唤醒，获取 $m$，并将 $count$ 增加到 $3$）与上面推导出的违规轨迹完全匹配。这部分是正确的。\n- **修正后的消费者序列：** 提议的序列是 $\\text{wait}(full)$，$\\text{wait}(m)$，$\\text{take}$，$count := count - 1$，$\\text{signal}(m)$，$\\text{signal}(empty)$。这是如上推导的标准正确实现。这部分是正确的。\n- **结论：** **正确**。\n\n**B. 没有违规的交错执行，然后是错误的消费者修复方案：**\n- **交错执行：** 这里描述了一个 $C$ 在上下文切换前获取互斥锁的交错执行。如分析所示，这个特定的交错执行不会产生违规。任务是展示一个*确实*会产生违规的交错执行。这部分未能完成任务。\n- **提议的消费者修复方案：** 提议的“修复”方案与原始的错误序列完全相同。这部分是不正确的。\n- **结论：** **不正确**。\n\n**C. 演示违规的交错执行，然后是错误的消费者修复方案：**\n- **交错执行：** 这个交错执行的描述比选项 A 中更详细一些（明确显示 $C$ 在 $m$ 上阻塞），但它在概念上是同样正确的违规演示。这部分是正确的。\n- **提议的消费者修复方案：** 提议的序列是 $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，...这是严重错误的。$\\text{take}$ 操作修改了共享缓冲区，但却被放置在由互斥锁 $m$ 保护的临界区之外。这引入了另一种竞争条件。这部分是不正确的。\n- **结论：** **不正确**。\n\n**D. 使用过早的 $\\text{signal}(full)$ 演示违规的交錯執行，然后是错误的消费者修复方案：**\n- **交错执行：** 这个交错执行描述了一个不同的错误，即过早的 $\\text{signal}(full)$。问题明确指出错误是过早的 $\\text{signal}(empty)$。此外，它错误地声称生产者等待 `full`，而实际上它们等待 `empty`。这部分与问题陈述不一致。\n- **提议的消费者修复方案：** 提议的修复方案缺少 $\\text{take}$ 操作和 $\\text{signal}(empty)$ 调用，这最终会导致系统死锁，因为生产者永远不会被通知。这部分是不正确的。\n- **结论：** **不正确**。\n\n基于分析，选项 A 是唯一一个既通过有效的交错执行正确演示了违规情况，又为消费者的逻辑提供了标准、正确的修复方案的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "除了高层次的同步逻辑外，我们还必须确保底层数据结构的实现是无懈可击的。对于有界缓冲区而言，这通常意味着要正确处理环形数组的索引，稍有不慎就会导致“差一错误”(off-by-one error)。本练习  不仅让你直面这些常见的索引计算陷阱，还引入了一种强大的自动化验证技术——模型检验。你将编写一个程序，系统性地探索所有可能的执行路径，以形式化的方法来证明修复后代码的正确性。",
            "id": "3687126",
            "problem": "设计并实现一个完整、可运行的程序，对一个有界缓冲区环形实现进行系统性的模型检验，以检查循环索引和容量护卫条件中的差一错误。有界缓冲区，也称为生产者-消费者队列，其容量为 $B$，并有两个索引：生产者索引 $p$ 和消费者索引 $c$。占用量（缓冲区中当前项目的数量）为 $n$。生产的项目使用严格递增的标识符 $0, 1, 2, \\ldots$ 进行标记，正确的消费必须保持顺序，无重复、无丢失。\n\n从以下基本依据开始：\n- 索引上的模运算遵循 $x' = (x + 1) \\bmod m$，用于当模为 $m$ 的索引加一时进行环绕。\n- 有界缓冲区的安全性属性要求在任何时候都满足 $\\;0 \\le n \\le B\\;$，并且两个索引都满足 $\\;0 \\le p  B\\;$ 和 $\\;0 \\le c  B\\;$。\n- 总生产量和总消耗量之间的守恒关系为 $\\;n = N_p - N_c\\;$，其中 $N_p$ 是已生产项目的计数，$N_c$ 是已消费项目的计数。\n- 消费的正确性要求在索引 $c$ 处读取的值等于下一个预期的标识符 $\\;N_c\\;$。\n\n你必须将环形缓冲区的两种模型实现为标记迁移系统，并通过有限状态探索来验证它们：\n- 修复前（有bug）的模型，旨在展示差一错误：\n  1. 当 $\\;n \\le B\\;$ 时，生产被启用。\n  2. 生产者将当前项目 $\\;N_p\\;$ 写入槽位 $\\;p\\;$，然后将 $p$ 更新为 $p' = (p + 1) \\bmod B$，将 $n$ 更新为 $n' = n + 1$，并将 $N_p$ 增加 1。\n  3. 当 $\\;n  0\\;$ 时，消费被启用。\n  4. 消费者检查索引 $c$ 处的缓冲区值是否等于 $\\;N_c\\;$，消费该项，然后将 $c$ 更新为 $c' = (c + 1) \\bmod (B + 1)$，将 $n$ 更新为 $n' = n - 1$，并将 $N_c$ 增加 1。\n- 修复后（已修正）的模型：\n  1. 当 $\\;n  B\\;$ 时，生产被启用。\n  2. 生产者将当前项目 $\\;N_p\\;$ 写入槽位 $\\;p\\;$，然后将 $p$ 更新为 $p' = (p + 1) \\bmod B$，将 $n$ 更新为 $n' = n + 1$，并将 $N_p$ 增加 1。\n  3. 当 $\\;n  0\\;$ 时，消费被启用。\n  4. 消费者检查索引 $c$ 处的缓冲区值是否等于 $\\;N_c\\;$，消费该项，然后将 $c$ 更新为 $c' = (c + 1) \\bmod B$，将 $n$ 更新为 $n' = n - 1$，并将 $N_c$ 增加 1。\n\n模型检验要求：\n- 从初始状态 $\\;p = 0\\;$、$\\;c = 0\\;$、$\\;n = 0\\;$、$\\;N_p = 0\\;$ 和 $\\;N_c = 0\\;$ 开始，使用深度优先搜索（DFS）对长度最多为 $S$ 步的所有执行轨迹进行穷尽式探索。在每一步，如果生产和消费都被启用，则分支以探索两种迁移。如果只有一个被启用，则执行该迁移。如果两者都未启用或达到步数限制，则终止该分支。\n- 在每个达到的状态，检查不变量 $\\;0 \\le p  B\\;$、$\\;0 \\le c  B\\;$、$\\;0 \\le n \\le B\\;$ 和 $\\;n = N_p - N_c\\;$。\n- 在每次消费迁移时，额外检查读取的值在更新索引和计数器之前是否等于 $\\;N_c\\;$。\n\n一旦任何不变量失效或在任何探索的轨迹上读取值检查失败，即发生违规（这代表一个反例）。当且仅当在深度为 $S$ 的所有探索轨迹中没有发生违规时，模型通过。\n\n测试套件：\n- 情况 1：$B = 3$, $S = 6$。\n- 情况 2：$B = 1$, $S = 4$。\n- 情况 3：$B = 2$, $S = 5$。\n- 情况 4：$B = 4$, $S = 7$。\n\n对于每种情况，运行修复前模型和修复后模型。要求的最终输出格式为单行，包含两个列表：第一个列表包含修复前模型的结果，第二个列表包含修复后模型的结果。每个条目是一个布尔值，如果模型通过（在深度为 $S$ 的所有轨迹中未发现违规）则编码为 $1$，如果失败（在至少一条轨迹中发现违规）则为 $0$。你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，具体如下：\n$$\\text{[[}b_1,b_2,b_3,b_4\\text{],[}f_1,f_2,f_3,f_4\\text{]]}$$\n其中 $b_i$ 和 $f_i$ 分别是修复前模型和修复后模型在情况 $i$ 下的布尔值结果。",
            "solution": "该问题要求设计并实现一个模型检验器，以一组安全性和正确性属性为标准，来验证一个有界缓冲区算法的两种实现。此任务属于计算机科学中的形式化方法领域，特别是有限状态系统的算法验证。\n\n该解决方案的架构是使用深度优先搜索（DFS）算法进行系统性的、穷尽的状态空间探索。有界缓冲区系统被建模为一个标记迁移系统，其中状态由系统的变量定义，迁移代表生产者或消费者的动作。\n\n### 状态表示\n系统的一个状态 $\\Sigma$ 是一个元组，包含生产者索引 $p$、消费者索引 $c$、当前占用量 $n$、总生产项目数 $N_p$、总消费项目数 $N_c$ 以及缓冲区数组本身的内容。\n$$ \\Sigma = (p, c, n, N_p, N_c, \\text{buffer}) $$\n缓冲区是一个大小为 $B$ 的数组。最初，系统处于状态 $\\Sigma_0 = (0, 0, 0, 0, 0, \\text{empty\\_buffer})$，此时缓冲区被视为空。\n\n### 迁移系统\n系统的行为由任意给定状态下的两种可能迁移定义：生产迁移（$T_p$）和消费迁移（$T_c$）。每个迁移由一个护卫条件（迁移要被启用必须为真的条件）和一个动作（更新状态的规则）定义。\n\n#### 1. 修复前（有bug）的模型\n- **生产迁移（$T_p$）**:\n  - 护卫条件：$n \\le B$。这个护卫条件是有缺陷的，因为它允许在缓冲区已满时（即 $n=B$ 时）进行生产。\n  - 动作：将一个标识符为 $N_p$ 的项目写入 $\\text{buffer}[p]$。状态更新如下：\n    $$ p' = (p + 1) \\bmod B $$\n    $$ n' = n + 1 $$\n    $$ N_p' = N_p + 1 $$\n- **消费迁移（$T_c$）**:\n  - 护卫条件：$n  0$。这个护卫条件是正确的。\n  - 动作：消费位于 $\\text{buffer}[c]$ 的项目。状态更新如下：\n    $$ c' = (c + 1) \\bmod (B + 1) $$\n    $$ n' = n - 1 $$\n    $$ N_c' = N_c + 1 $$\n    消费者索引 $c$ 的模为 $B+1$ 是一个缺陷。由于有效的缓冲区索引是 $0, 1, \\ldots, B-1$，这条规则最终将导致 $c$ 取值为 $B$，从而尝试越界访问。\n\n#### 2. 修复后（已修正）的模型\n- **生产迁移（$T_p$）**:\n  - 护卫条件：$n  B$。这是正确的护卫条件，可防止在缓冲区已满时进行生产。\n  - 动作：与修复前模型相同。\n    $$ p' = (p + 1) \\bmod B $$\n    $$ n' = n + 1 $$\n    $$ N_p' = N_p + 1 $$\n- **消费迁移（$T_c$）**:\n  - 护卫条件：$n  0$。\n  - 动作：使用正确的消费者索引模数更新状态：\n    $$ c' = (c + 1) \\bmod B $$\n    $$ n' = n - 1 $$\n    $$ N_c' = N_c + 1 $$\n\n### 通过深度优先搜索进行验证\n模型检验过程实现为一个递归函数 `model_check_dfs`，它从初始状态 $\\Sigma_0$ 开始，对状态空间图执行深度优先搜索。搜索受最大探索深度 $S$ 的限制。\n\n每个递归步骤的算法如下：\n1.  **不变量检查**：在进入给定深度的一个新状态时，函数首先验证一组安全性不变量：\n    - 索引边界：$0 \\le p  B$ 和 $0 \\le c  B$。\n    - 占用量边界：$0 \\le n \\le B$。\n    - 守恒定律：$n = N_p - N_c$。\n    如果任何不变量被违反，则模型检验失败。函数返回一个失败状态，剪除当前的搜索路径。\n\n2.  **深度检查**：如果当前搜索深度达到限制 $S$，该路径的探索成功终止，函数返回一个成功状态。\n\n3.  **迁移探索**：函数根据模型的护卫条件确定从当前状态可以启用哪些迁移（$T_p$ 和/或 $T_c$）。\n    - 如果可以进行生产，则根据生产者动作计算一个新状态，并以递增的深度对此新状态递归调用 `model_check_dfs` 函数。\n    - 如果可以进行消费，算法首先执行一个关键的数据正确性检查：验证 `buffer[c]` 处的项目确实是下一个预期的项目，即 `buffer[c] == N_c`。如果此检查失败，则表示数据损坏或丢失，模型检验失败。如果检查通过，则根据消费者动作计算一个新状态，并进行递归调用。\n\n4.  **结果传播**：如果任何递归调用返回失败状态，该状态将立即沿着调用栈向上传播。一旦找到第一个反例（一条导致状态违反不变量或正确性属性的轨迹），整个模型就被认为失败。如果在深度 $S$ 内探索了所有可能的执行轨迹而未发现任何违规，则模型被认为通过了检查。\n\n这种系统性方法保证，如果存在一个可由 $S$ 个或更少操作序列触发的缺陷，模型检验器将会找到它。修复前模型中的缺陷——特别是缓冲区溢出（$n  B$）和越界的消费者索引（$c \\ge B$）的可能性——很容易被不变量检查检测到。修复后的模型采用正确的护卫条件和更新规则，遵循所有指定的属性，因此通过验证。",
            "answer": "$$\\boxed{[[0,0,0,0],[1,1,1,1]]}$$"
        }
    ]
}