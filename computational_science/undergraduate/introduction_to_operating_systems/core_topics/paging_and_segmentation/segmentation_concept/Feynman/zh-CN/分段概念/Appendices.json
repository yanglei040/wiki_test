{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你完成内存分段机制中最核心的操作：逻辑地址到物理地址的转换。通过亲手计算，你将理解基址（base）和界限（limit）寄存器如何协同工作，不仅将程序的逻辑视图映射到物理内存，更重要的是，如何通过严格的边界检查来保护内存区域免受非法访问。这个基础练习是掌握分段概念不可或缺的第一步，它清晰地揭示了硬件层面的内存保护原理。",
            "id": "3680307",
            "problem": "一个单处理器系统使用分段式内存管理。根据该模型的定义，每个逻辑地址是一个数对 $\\left(i, o\\right)$，其中 $i$ 是段索引，$o$ 是段 $i$ 内的一个非负字节偏移量。每个段 $i$ 都有一个基址（起始物理地址）$b_i$ 和一个界限 $l_i$。系统对每次内存引用进行边界检查，验证 $0 \\le o  l_i$ 是否成立。如果边界检查通过，内存管理单元（MMU）将段基址和偏移量进行整数求和，从而形成物理地址。如果边界检查失败，MMU 会引发一个段错误。假设所有地址和界限都是精确的字节计数，没有舍入或对齐的副作用。\n\n考虑一个段 $i$，其基址为 $b_i = 0x200000$，界限为 $l_i = 0x3000$。有两条指令使用偏移量 $o_1 = 0x2FFF$ 和 $o_2 = 0x3000$ 来引用该段。\n\n仅使用上述定义，确定哪个偏移量能通过边界检查，哪个会导致错误。解释为什么其中一个是差一错误的情况。然后，通过执行所需的加法，计算有效偏移量的物理地址 $p$。用十六进制表示最终的物理地址，并加上前缀 $0x$。不需要舍入。",
            "solution": "我们将根据所提供的定义来验证问题，如果问题有效，则进行求解。\n\n首先，从问题陈述中提取已知条件：\n- 逻辑地址是一个数对 $(i, o)$，其中 $i$ 是段索引，$o$ 是非负字节偏移量。\n- 每个段 $i$ 有一个基址 $b_i$ 和一个界限 $l_i$。\n- 边界检查由不等式 $0 \\le o  l_i$ 定义。\n- 如果边界检查通过，物理地址 $p$ 计算为 $p = b_i + o$。\n- 如果边界检查失败，会发生段错误。\n- 对于特定的段 $i$，基址为 $b_i = 0x200000$。\n- 对于同一个段，界限为 $l_i = 0x3000$。\n- 需要检查两个偏移量：$o_1 = 0x2FFF$ 和 $o_2 = 0x3000$。\n\n该问题具有科学依据，因为它描述了操作系统和计算机体系结构中使用的标准内存分段模型。问题提法严谨，提供了所有必要的数据（$b_i$、$l_i$、$o_1$、$o_2$）和清晰明确的验证规则（$0 \\le o  l_i$）。没有矛盾或缺失的定义。因此，该问题被认为是有效的，并将提供解决方案。\n\n问题的核心在于边界检查条件的严格不等式，$o  l_i$。界限 $l_i$ 代表段的大小。对于一个大小为 $l_i$ 的段，有效的字节偏移量范围是从 $0$ 到 $l_i - 1$（包含两者）。这总共有 $l_i$ 个不同的地址。\n\n我们现在将根据边界检查条件 $0 \\le o  l_i$ 来测试每个偏移量，其中 $l_i = 0x3000$。\n\n情况1：偏移量 $o_1 = 0x2FFF$。\n边界检查变为 $0 \\le 0x2FFF  0x3000$。\n在十六进制运算中，$0x2FFF$ 精确地比 $0x3000$ 小一。因此，不等式 $0x2FFF  0x3000$ 是成立的。由于偏移量也是非负的，条件 $0 \\le 0x2FFF  0x3000$ 完全满足。\n结论：偏移量 $o_1$ 通过边界检查。\n\n情况2：偏移量 $o_2 = 0x3000$。\n边界检查变为 $0 \\le 0x3000  0x3000$。\n不等式 $0x3000  0x3000$ 是不成立的，因为一个数不能严格小于它本身。\n结论：偏移量 $o_2$ 未通过边界检查，将导致段错误。\n\n偏移量 $o_2 = 0x3000$ 展示了差一错误的情况。该段的有效偏移量范围是从 $0$ 到 $l_i - 1$。当 $l_i = 0x3000$ 时，最高有效偏移量是 $0x3000 - 1 = 0x2FFF$。尝试访问偏移量 $o_2 = 0x3000$ 是试图访问该段最后一个有效字节紧邻的下一个字节。这是一个经典的差一错误，内存管理单元的严格边界检查正是为了捕捉此类错误而设计的。\n\n最后，我们为有效的偏移量 $o_1 = 0x2FFF$ 计算物理地址 $p$。物理地址是基址和偏移量的和：\n$p = b_i + o_1$\n代入给定值：\n$p = 0x200000 + 0x2FFF$\n执行十六进制加法：\n$$\n\\begin{array}{@{}c@{\\,}c}\n  0x200000 \\\\\n+  0x002FFF \\\\\n\\hline\n  0x202FFF\n\\end{array}\n$$\n因此，有效内存引用的物理地址是 $p = 0x202FFF$。",
            "answer": "$$\n\\boxed{0x202FFF}\n$$"
        },
        {
            "introduction": "在掌握了基本的地址转换规则后，我们必须深入探讨其在真实系统中的实现细节。看似简单的边界检查 $o \\lt l$ 在面对有限位数的计算机算术时，可能隐藏着严重的安全漏洞，例如整数溢出。本练习通过一个精心设计的边界情况，揭示了朴素实现为何会失败，并引导你思考如何编写健壮的、能够抵御此类攻击的内核代码。理解这一点对于任何有志于系统编程的开发者来说都至关重要。",
            "id": "3680289",
            "problem": "一个使用分段机制的操作系统（OS）将每个逻辑地址表示为一个序偶 $\\langle s, o \\rangle$，其中 $s$ 是段标识符，$o$ 是偏移量。中央处理器（CPU）仅在偏移量满足 $0 \\le o  l(s)$ 的情况下，才将 $\\langle s, o \\rangle$ 映射到物理地址 $p = b(s) + o$，其中 $b(s)$ 是基址，$l(s)$ 是段限长。考虑一个字长为 $w$ 位的机器。在此类机器上，$w$ 位无符号整数的加法和减法是按模 $2^w$ 执行的，无符号比较将位模式解释为范围在 $[0, 2^w - 1]$ 内的整数。\n\n一个用户进程请求内核从一个段中偏移量为 $o$ 的位置开始复制 $n$ 个字节，内核必须判断所请求的 $n$ 字节范围是否完全位于该段的边界内。假设一个 $w = 32$ 位的架构。考虑以下边界情况：\n- 段限长 $l = 2^{32} - 4$。\n- 请求的起始偏移量 $o = 2^{32} - 8$。\n- 请求的长度 $n = 16$ 字节。\n\n假设 $b(s)$ 是任意但固定的，并且内核必须仅使用硬件提供的 $w$ 位整数类型的算术和比较运算来实现其决策。哪种方法能够做出正确的决策，在一般情况下（包括这个边界情况）防止回绕访问，即通过确保检查 $o  l$ 使用无符号算术，并避免由模加法引起的漏洞？\n\nA. 将边界检查作为两个无符号比较来执行：首先验证 $o  l$，然后验证 $n \\le l - o$。如果任一比较失败，则拒绝请求。\n\nB. 对 $w$ 位整数执行单个无符号检查 $o + n \\le l$。如果为真则接受，否则拒绝。\n\nC. 将 $o$、$l$ 和 $n$ 视为有符号 $32$ 位整数，并使用有符号比较检查 $o  l$ 和 $o + n \\le l$。如果任一比较失败，则拒绝请求。\n\nD. 使用 $32$ 位模加法计算物理地址 $p = b(s) + o$ 和 $q = p + n - 1$，然后通过无符号比较检查 $q \\le b(s) + l - 1$。如果为真则接受，否则拒绝。",
            "solution": "该用户问题要求一个正确且鲁棒的内核级算法，用以检查内存访问请求是否在内存段的边界内。该请求是在一个由限长 $l$ 定义的段内，从偏移量 $o$ 开始访问 $n$ 个字节。有效偏移量在范围 $[0, l-1]$ 内。因此，所请求的字节范围（从偏移量 $o$ 到 $o + n - 1$）必须完全包含在有效范围内。这可以用标准整数算术中的两个条件来表示：\n1. 起始偏移量必须有效：$o \\ge 0$。由于偏移量是无符号的，这个条件总是成立的。\n2. 结束偏移量必须有效：$o + n - 1  l$。\n\n条件2等价于 $o + n \\le l$。因为我们假设任何有意义的复制操作都有 $n>0$，所以条件 $o + n \\le l$ 也隐含了 $o  l$。因此，在纯数学中，单个检查 $o + n \\le l$ 就足够了。\n\n问题的核心在于使用 $w$ 位无符号整数算术来实现这个检查，其中加法是按模 $2^w$ 执行的。$o + n$ 的直接硬件实现会计算 $(o + n) \\pmod{2^w}$。如果 $o+n \\ge 2^w$，就会发生整数溢出，结果会“回绕”到一个较小的值。这可能导致本应失败的检查通过，从而产生安全漏洞。\n\n让我们使用提供的 $w = 32$ 的边界情况：\n- 段限长 $l = 2^{32} - 4$。\n- 请求的起始偏移量 $o = 2^{32} - 8$。\n- 请求的长度 $n = 16$ 字节。\n\n请求访问的偏移量范围是从 $o = 2^{32} - 8$ 到 $o+n-1 = (2^{32} - 8) + 16 - 1 = 2^{32} + 7$。\n有效的偏移量范围是 $[0, l-1]$，即 $[0, 2^{32} - 5]$。\n请求的范围明显超出了有效的段限长。因此，该请求必须被拒绝。\n\n现在，我们评估每一种提议的方法。\n\n**A. 将边界检查作为两个无符号比较来执行：首先验证 $o  l$，然后验证 $n \\le l - o$。如果任一比较失败，则拒绝请求。**\n\n这种方法分解了检查。让我们用给定的边界情况值，在 $32$ 位无符号算术下分析它。\n1.  **第一次检查：$o  l$**\n    这将 $2^{32} - 8$ 与 $2^{32} - 4$ 进行比较。作为无符号比较，这是成立的。检查通过。\n2.  **第二次检查：$n \\le l - o$**\n    首先执行减法 $l - o$。由于第一次检查已确定 $o  l$，无符号减法 $(l - o)$ 不会在模运算意义下发生下溢。硬件将计算出正确的数学差值。\n    $l - o = (2^{32} - 4) - (2^{32} - 8) = 4$。\n    然后比较的是 $n \\le 4$，即 $16 \\le 4$。这是不成立的。\n    由于第二次比较失败，内核拒绝该请求。\n\n对于这个边界情况，这是正确的结果。\n总的来说，这个方法是正确的。第一次检查 $o  l$ 确保了起始点在段内，并且关键地，确保了减法 $l-o$ 能得出从偏移量 $o$ 开始的段的真实剩余大小。第二次检查 $n \\le l-o$ 随后正确地验证了所请求的长度 $n$ 是否能容纳在这个剩余空间内。这等价于检查 $o+n \\le l$，但不会受到 $o+n$ 溢出的影响。\n\n对A的裁定：**正确**。\n\n**B. 对 $w$ 位整数执行单个无符号检查 $o + n \\le l$。如果为真则接受，否则拒绝。**\n\n这种方法直接实现了数学上的检查，但它容易受到溢出的影响。\n1.  **使用 $32$ 位无符号算术计算 $o + n$：**\n    $o + n = (2^{32} - 8) + 16 = 2^{32} + 8$。\n    硬件按模 $2^{32}$ 计算这个值：$(2^{32} + 8) \\pmod{2^{32}} = 8$。\n2.  **执行比较：**\n    检查变为 $8 \\le l$，即 $8 \\le 2^{32} - 4$。这是成立的。\n    内核会接受该请求。这是不正确的结果，因为它将导致越界访问（回绕写入到偏移量 $[0, 7]$）。这是一个经典的整数溢出漏洞。\n\n对B的裁定：**不正确**。\n\n**C. 将 $o$、$l$ 和 $n$ 视为有符号 $32$ 位整数，并使用有符号比较检查 $o  l$ 和 $o + n \\le l$。如果任一比较失败，则拒绝请求。**\n\n这种方法将位模式的解释从无符号更改为有符号。一个 $32$ 位有符号整数（采用二进制补码）的范围是从 $-2^{31}$ 到 $2^{31}-1$。\n- $l = 2^{32} - 4$ 的位模式是 `0xFFFFFFFC`。作为有符号整数，这是 $-4$。\n- $o = 2^{32} - 8$ 的位模式是 `0xFFFFFFF8`。作为有符号整数，这是 $-8$。\n- $n = 16$ 的位模式是 `0x00000010`。作为有符号整数，这是 $16$。\n\n1.  **第一次检查：使用有符号比较检查 $o  l$。**\n    $-8  -4$ 是否成立？是的，成立。检查通过。\n2.  **第二次检查：使用有符号比较检查 $o + n \\le l$。**\n    $o+n$ 计算为 $-8 + 16 = 8$。\n    检查是 $8 \\le -4$ 是否成立？不成立。\n    内核拒绝该请求。对于这个特定的边界情况，结果是正确的。\n\n然而，这种方法并非普遍正确。偏移量和长度本质上是无符号量。将它们视为有符号数在最高有效位为 1 的有效情况下会失败。例如，考虑一个段限长为 $l = 2^{31}$ 的段。一个 $o=0$ 且 $n=1$ 的请求显然是有效的。\n- $l = 2^{31}$ 的位模式是 `0x80000000`。作为有符号整数，这被解释为 $-2^{31}$。\n- $o=0$ 和 $n=1$ 被解释为 $0$ 和 $1$。\n第一次检查 $o  l$ 变为 $0  -2^{31}$，这是不成立的。该请求将被错误地拒绝。\n\n对C的裁定：**不正确**。\n\n**D. 使用 $32$ 位模加法计算物理地址 $p = b(s) + o$ 和 $q = p + n - 1$，然后通过无符号比较检查 $q \\le b(s) + l - 1$。如果为真则接受，否则拒绝。**\n\n这种方法将检查移到物理地址空间中。其逻辑依赖于这样一个想法：在不等式两边加上基址 $b(s)$，然后执行模运算会得到正确的结果。这是错误的。不等式 $x \\le y$ 不一定能保持为 $(b+x)\\pmod{2^w} \\le (b+y)\\pmod{2^w}$。结果取决于 $b$ 的值。\n\n让我们用题目中的无效请求作为反例来证明这一点：$l = 2^{32} - 4$, $o = 2^{32} - 8$, $n = 16$。\n- 设段基址为 $b(s) = 4$。\n- $p = b(s) + o = 4 + (2^{32} - 8) = 2^{32} - 4$。硬件计算出 $p = (2^{32} - 4) \\pmod{2^{32}} = 2^{32}-4$。\n- $q = p + n - 1 = (2^{32} - 4) + 16 - 1 = 2^{32} + 11$。硬件计算出 $q = (2^{32} + 11) \\pmod{2^{32}} = 11$。\n- 物理地址上限是 $b(s) + l - 1 = 4 + (2^{32} - 4) - 1 = 2^{32} - 1$。硬件将其计算为 $(2^{32} - 1) \\pmod{2^{32}} = 2^{32}-1$。\n- 检查是 $q \\le b(s) + l - 1$。这变为 $11 \\le 2^{32}-1$。这是成立的。\n内核会接受该请求，这是不正确的结果。该方法失败了，因为它的正确性取决于任意的 $b(s)$ 值。\n\n对D的裁定：**不正确**。\n\n总而言之，只有方法A提供了一个在指定的硬件算术约束下，能够免疫整数溢出漏洞的、普遍正确且鲁棒的解决方案。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "前面的练习聚焦于单次内存访问的微观视角，而本练习将带你进入宏观层面，模拟分段内存管理的动态过程。你将亲手实现一个采用首次适应（first-fit）策略的内存分配器，处理段的创建和销毁，并在此过程中直面分段机制的主要缺点——外部碎片。通过量化分析外部碎片，你将深刻体会到为何它会降低内存利用率，并最终理解操作系统不断发展更复杂内存管理方案（如分页）的根本动因。",
            "id": "3680267",
            "problem": "您将实现一个在单一连续、线性寻址的内存空间中，使用首次适应策略的分段式内存分配模拟，并计算在一系列段的到达和离开过程中一个有原则的外部碎片度量。其目的是将操作系统（OS）中的分段概念与可测量的现象（如外部碎片）联系起来。\n\n推导的基本依据包括以下经过充分检验并被广泛接受的概念和定义：\n- 进程段是一个连续的内存块。在分段中，每个段在地址空间中占据一个连续的区域。\n- 首次适应分配策略按地址升序扫描空闲内存块，并选择第一个大小至少等于请求大小的块。\n- 当且仅当两个相邻的空闲块共享一个边界时，空闲块必须在释放时进行合并，以确保对连续内存的一致建模。\n- 外部碎片是指总空闲内存足以满足请求，但没有单个空闲块足够大的情况。一个合理的外部碎片瞬时度量是量化未被包含在最大空闲块中的那部分空闲内存的比例。\n\n形式上，考虑一个大小为 $M$ 个可寻址单元的内存，建模为区间 $[0,M)$，其中空闲块和已分配块表示为不相交的子区间。设系统通过两种类型的事件，在由 $t \\in \\{1,2,\\ldots,T\\}$ 索引的离散步骤中演化：\n- 到达：$\\mathrm{arrive}(s_i, a_i)$ 表示段 $s_i$ 请求一个大小为 $a_i$ 单元的连续分配。\n- 离开：$\\mathrm{depart}(s_i)$ 表示段 $s_i$ 被释放。\n\n您必须实现：\n1. 对每个 $\\mathrm{arrive}(s_i, a_i)$ 实现首次适应连续分配：\n   - 按起始地址递增的顺序扫描空闲块，并选择第一个大小至少为 $a_i$ 的块。\n   - 将 $s_i$ 放置在该块的起始位置，并相应地缩小或移除该空闲块。\n   - 如果没有合适的块，则分配失败，该步骤下状态保持不变。\n2. 对每个 $\\mathrm{depart}(s_i)$ 实现释放操作：\n   - 将 $s_i$ 占用的区间标记为空闲，按起始地址顺序将其插入到空闲列表中，并与相邻的空闲块合并，以维持最大化的连续空闲区间。\n3. 在每个事件后计算外部碎片度量：\n   - 令 $F_t$ 为步骤 $t$ 后的瞬时外部碎片，定义为\n     $$ F_t = \\begin{cases} \\frac{\\sum_{k} f_k(t) - \\max_k f_k(t)}{\\sum_k f_k(t)},  \\text{if } \\sum_k f_k(t) > 0 \\\\ 0,  \\text{if } \\sum_k f_k(t) = 0 \\end{cases} $$\n     其中 $f_k(t)$ 是步骤 $t$ 后第 $k$ 个空闲块的大小，$\\max_k f_k(t)$ 是步骤 $t$ 后最大空闲块的大小。\n   - 计算整个追踪序列中的平均外部碎片 $\\overline{F}=\\dfrac{1}{T}\\sum_{t=1}^{T}F_t$ 和最大外部碎片 $\\max_t F_t$。\n   - 统计整个追踪序列中分配失败的次数 $\\phi$。\n\n您的程序必须设置并运行以下测试用例的追踪序列。对于每个测试用例，都指定了内存大小 $M$ 和事件序列。在每个追踪序列中，所有离开事件都指向有效的、当前已分配的段，并且所有段标识符在追踪序列内是唯一的。\n\n测试用例 $\\#1$ (包含混合分配和释放的通用情况):\n- 内存大小 $M=\\;64$。\n- 长度为 $T=\\;9$ 的事件序列：\n  1. $\\mathrm{arrive}(s_1, 10)$\n  2. $\\mathrm{arrive}(s_2, 20)$\n  3. $\\mathrm{arrive}(s_3, 5)$\n  4. $\\mathrm{depart}(s_2)$\n  5. $\\mathrm{arrive}(s_4, 12)$\n  6. $\\mathrm{arrive}(s_5, 15)$\n  7. $\\mathrm{depart}(s_1)$\n  8. $\\mathrm{depart}(s_3)$\n  9. $\\mathrm{arrive}(s_6, 16)$\n\n测试用例 $\\#2$ (精确匹配边界行为和合并):\n- 内存大小 $M=\\;32$。\n- 长度为 $T=\\;6$ 的事件序列：\n  1. $\\mathrm{arrive}(s_1, 12)$\n  2. $\\mathrm{arrive}(s_2, 8)$\n  3. $\\mathrm{depart}(s_1)$\n  4. $\\mathrm{arrive}(s_3, 12)$\n  5. $\\mathrm{depart}(s_2)$\n  6. $\\mathrm{arrive}(s_4, 20)$\n\n测试用例 $\\#3$ (演示总空闲内存足够但最大块不足的外部碎片):\n- 内存大小 $M=\\;50$。\n- 长度为 $T=\\;11$ 的事件序列：\n  1. $\\mathrm{arrive}(s_1, 10)$\n  2. $\\mathrm{arrive}(s_2, 9)$\n  3. $\\mathrm{arrive}(s_3, 8)$\n  4. $\\mathrm{arrive}(s_4, 7)$\n  5. $\\mathrm{depart}(s_2)$\n  6. $\\mathrm{depart}(s_3)$\n  7. $\\mathrm{arrive}(s_5, 12)$\n  8. $\\mathrm{arrive}(s_6, 20)$\n  9. $\\mathrm{depart}(s_5)$\n  10. $\\mathrm{arrive}(s_7, 16)$\n  11. $\\mathrm{arrive}(s_8, 16)$\n\n测试用例 $\\#4$ (两端合并压力测试和碎片导致的失败):\n- 内存大小 $M=\\;100$。\n- 长度为 $T=\\;11$ 的事件序列：\n  1. $\\mathrm{arrive}(s_1, 30)$\n  2. $\\mathrm{arrive}(s_2, 30)$\n  3. $\\mathrm{arrive}(s_3, 30)$\n  4. $\\mathrm{depart}(s_2)$\n  5. $\\mathrm{arrive}(s_4, 20)$\n  6. $\\mathrm{depart}(s_1)$\n  7. $\\mathrm{depart}(s_3)$\n  8. $\\mathrm{arrive}(s_5, 35)$\n  9. $\\mathrm{depart}(s_4)$\n  10. $\\mathrm{arrive}(s_6, 45)$\n  11. $\\mathrm{arrive}(s_7, 15)$\n\n对于每个测试用例，您的程序必须产生以下输出：\n- 平均外部碎片 $\\overline{F}$，为一个实数，精确到小数点后六位。\n- 最大外部碎片 $\\max_t F_t$，为一个实数，精确到小数点后六位。\n- 分配失败的次数 $\\phi$，为一个整数。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个由列表组成的列表，用方括号括起来，每个内部列表对应一个测试用例（按 $\\#1$到$\\#4$的顺序）。每个内部列表必须是 $[\\overline{F},\\max_t F_t,\\phi]$ 的形式。例如，输出必须看起来像：\n  [[0.123456,0.234567,2],[...],[...],[...]]\n- 所有实数必须精确打印到小数点后六位。不应打印任何其他文本。",
            "solution": "模拟分段式内存分配并测量外部碎片的问题是一个有效且定义明确的计算任务，它基于操作系统的基本原理。该问题为内存模型、分配/释放策略、碎片的量化度量提供了一个精确的定义，并附有一套全面的测试用例。它在科学上是合理的、客观的，并且包含足够的信息以得出一个唯一的、可验证的解决方案。\n\n解决方案涉及设计一个离散时间模拟，该模拟对一系列事件中的内存状态进行建模。大小为 $M$ 的内存被表示为一系列连续的块。选择双向链表作为管理这些块的数据结构，因为它能提供高效的插入、删除和遍历操作，这些对于块分割和合并操作至关重要。链表中的每个节点代表一个内存块，并存储其起始地址、大小、分配状态（空闲或占用），以及（如果已分配）段标识符。该列表按块起始地址的升序维护。\n\n让一个块由一个具有以下属性的结构表示：`start`、`size`、`is_free`、`segment_id` 以及指针 `prev` 和 `next`。每个测试用例的内存初始状态是一个单一的空闲块，其 `start` $= 0$，`size` $= M$。\n\n为了高效处理 $\\mathrm{depart}(s_i)$ 形式的释放操作，使用了一个直接访问段表。该表是一个按段ID索引的数组，其中每个条目存储一个指向双向链表中相应块的指针。这避免了为释放一个段而搜索整个内存。\n\n模拟过程是通过按指定顺序处理总共 $T$ 个步骤中的每个事件来进行的。\n\n**1. 分配 `arrive(s_i, a_i)`:**\n首次适应策略要求从头（最低地址）开始扫描内存块列表。遇到的第一个被标记为空闲（`is_free` 为 true）且大小大于或等于请求大小 $a_i$ 的块被选中。\n- 如果找到了这样的块（设其大小为 $S$）：\n    - 如果 $S = a_i$（精确匹配），则该块的状态更改为已分配。其 `is_free` 标志设置为 false，`segment_id` 设置为 $s_i$。\n    - 如果 $S > a_i$，则该块被分割。原始块的大小减小到 $a_i$，并标记为已分配给段 $s_i$。为大小为 $S - a_i$ 的剩余部分创建一个新的空闲块，起始地址为 `original_start` $+ a_i$。这个新块被插入到链表中紧跟在刚分配的块之后。\n    - 在这两种情况下，段表都会更新，以将 $s_i$ 映射到新分配块的地址。\n- 如果在扫描完整个列表后没有找到合适的块，则分配失败。分配失败的计数 $\\phi$ 增加，并且此步骤的内存状态保持不变。\n\n**2. 释放 `depart(s_i)`:**\n- 使用段表立即定位段 $s_i$ 占用的块。\n- 通过将其 `is_free` 标志设置为 true 并重置其 `segment_id`，将此块标记为空闲。\n- 然后执行合并操作。检查新释放块的邻居：\n    - 如果列表中的下一个块（更高地址）也是空闲的，则将其合并。当前块的大小增加下一个块的大小，并将下一个块的节点从列表中移除。\n    - 如果列表中的前一个块（更低地址）也是空闲的，则将当前块合并到其中。前一个块的大小增加当前块的大小，并将当前块的节点移除。\n    这个过程确保空闲块总是被最大程度地合并。一个新释放的块如果其前驱和后继都为空闲，可能会触发与两者的合并，从而形成一个更大的单一空闲块。\n\n**3. 碎片度量计算:**\n在步骤 $t$（对于 $t \\in \\{1, 2, \\ldots, T\\}$）的每个事件之后，计算瞬时外部碎片 $F_t$。这需要对内存块列表进行一次完整扫描以：\n- 通过对所有空闲块的大小求和，计算总空闲内存 $\\sum_k f_k(t)$。\n- 找到最大空闲块的大小 $\\max_k f_k(t)$。\n- 然后使用给定的公式计算碎片 $F_t$：\n  $$F_t=\\begin{cases}\n  \\dfrac{\\sum_{k} f_k(t)-\\max_k f_k(t)}{\\sum_k f_k(t)},  \\text{if } \\sum_k f_k(t)  0 \\\\\n  0,  \\text{if } \\sum_k f_k(t) = 0\n  \\end{cases}$$\n$F_t$ 的值被添加到一个运行总和中，并且如果 $F_t$ 更大，则更新迄今为止见到的最大碎片 $\\max_t F_t$。\n\n在处理完一个追踪序列中的所有 $T$ 个事件后，计算平均外部碎片为 $\\overline{F} = \\frac{1}{T}\\sum_{t=1}^{T}F_t$。该测试用例的最终结果是计算出的 $\\overline{F}$、$\\max_t F_t$ 和总失败次数 $\\phi$。对问题陈述中提供的每个测试用例重复这整个过程。",
            "answer": "```\n[[0.310418, 0.621622, 1], [0.083333, 0.500000, 0], [0.315849, 0.571429, 2], [0.212646, 0.500000, 0]]\n```"
        }
    ]
}