{
    "hands_on_practices": [
        {
            "introduction": "To truly master memory protection, one must first understand the fundamental mechanics of how the hardware enforces boundaries. This first practice challenges you to apply the core definitions of paging to a common scenario: a program writing sequentially past the end of an allocated page. By calculating the exact virtual address that triggers the first page fault, you will solidify your understanding of how the Memory Management Unit (MMU) uses page boundaries to police memory access on a byte-by-byte basis .",
            "id": "3657608",
            "problem": "Consider a process running on a system that implements paged virtual memory with fixed-size pages. Each page has size $P$ bytes, and virtual addresses are integers in units of bytes. The Central Processing Unit (CPU) consults the Memory Management Unit (MMU) to translate each virtual address to a physical address; the MMU uses the page table hierarchy and raises a page fault if the translation indicates that the referenced page is not present or if the requested access violates the protection bits of the page.\n\nAssume a contiguous layout in the virtual address space as follows:\n- One mapped page with write permission spans addresses $[B, B+P)$.\n- Immediately following it, there is an unmapped gap of $g$ consecutive pages spanning addresses $[B+P, B+P+gP)$, where $g$ is a positive integer.\n- Immediately following the gap, there is another mapped page (possibly with different protection) spanning $[B+P+gP, B+P+(g+1)P)$.\n\nA thread performs a forward, byte-granular write of a contiguous buffer of length $L$ bytes starting at virtual address $S$, where $B \\leq S < B+P$, and $L > B+P - S$ so the write crosses into the next page. The write touches addresses in the increasing sequence $S, S+1, S+2, \\dots, S+L-1$.\n\nUsing only the definitions of paging, page boundaries, and protection checks, derive the first virtual address at which the MMU will raise a fault during this write, knowing that the first page after $[B, B+P)$ is the first page of the unmapped gap. Express your final answer as a single closed-form analytic expression in terms of $S$ and $P$ only, in bytes. No rounding is required.\n\nAdditionally, provide a brief qualitative discussion explaining whether the protection bits of the mapped page immediately after the gap influence the hardware’s classification of the fault caused by the first access into the gap (for example, whether it is considered a “not-present” fault versus a “protection” fault). Your discussion should rely solely on first principles of MMU address translation and page protection semantics.",
            "solution": "The problem asks for the first virtual address that will cause a fault during a sequential write operation, and for a qualitative discussion about the nature of that fault. We will address these two parts in order.\n\nFirst, we must determine the virtual address of the first fault.\nThe system uses paged virtual memory with a fixed page size of $P$ bytes. A virtual address $V$ is located on a specific page. The starting address of the page containing $V$ can be calculated as $P \\times \\lfloor V/P \\rfloor$, where $\\lfloor \\cdot \\rfloor$ denotes the floor function. The page containing $V$ spans the address range $[P \\times \\lfloor V/P \\rfloor, P \\times \\lfloor V/P \\rfloor + P)$.\n\nThe problem states that a write operation starts at a virtual address $S$ which is located within a mapped page that spans the range $[B, B+P)$. This implies that $B$ is the starting address of a page. From the general formula, the starting address of the page containing $S$ is $P \\times \\lfloor S/P \\rfloor$. Therefore, we can establish the identity:\n$$B = P \\times \\left\\lfloor \\frac{S}{P} \\right\\rfloor$$\nThis page has write permission, so any write accesses to addresses within this page will succeed without generating a fault. The write operation accesses bytes at addresses $S, S+1, S+2, \\dots$ in sequence. All write accesses to addresses $V$ such that $S \\le V < B+P$ are therefore valid.\n\nThe problem specifies that the length of the write buffer, $L$, is greater than the remaining space in the initial page, i.e., $L > (B+P) - S$. This condition guarantees that the write operation will attempt to access addresses beyond the end of the first page. The last valid address in the first page is $B+P-1$. The sequential write will access this address and then attempt to access the next byte at address $(B+P-1)+1 = B+P$.\n\nThe problem states that the address range $[B+P, B+P+gP)$ is an \"unmapped gap\". This means there is no valid virtual-to-physical address mapping for any address $V$ in this range. When the Memory Management Unit (MMU) attempts to translate the virtual address $B+P$, it will find that the corresponding page table entry (PTE) is invalid (e.g., the 'present' bit is $0$). This failed translation attempt immediately causes the hardware to raise a page fault.\n\nSince the write accesses addresses in increasing order starting from a valid region, the very first address that falls into the unmapped gap will be the first address to cause a fault. This address is precisely $B+P$.\n\nTo express the final answer in terms of only $S$ and $P$, as required, we substitute the expression for $B$ we derived earlier:\n$$V_{\\text{fault}} = B+P = \\left( P \\times \\left\\lfloor \\frac{S}{P} \\right\\rfloor \\right) + P$$\nThis expression can be simplified by factoring out $P$:\n$$V_{\\text{fault}} = P \\times \\left( \\left\\lfloor \\frac{S}{P} \\right\\rfloor + 1 \\right)$$\nThis is the closed-form analytic expression for the first virtual address at which the MMU will raise a fault.\n\nSecond, we provide the qualitative discussion regarding the fault type.\nThe question is whether the protection bits of the mapped page immediately after the unmapped gap influence the hardware's classification of the fault that occurs at address $V_{\\text{fault}} = B+P$.\n\nThe address translation mechanism performed by the MMU is deterministic and localized. To translate a virtual address $V$, the MMU determines its virtual page number (VPN), $VPN(V) = \\lfloor V/P \\rfloor$, and uses this to index into the page table structure to find the corresponding PTE. The fault occurs at address $B+P$, which is the first address in the unmapped gap. The MMU's action is determined entirely by the contents of the PTE for the page containing this address.\n\nThe problem states this page is \"unmapped\". In the context of MMU hardware, this means the PTE for this page will be marked as invalid (e.g., a 'present' or 'valid' bit is set to $0$). The MMU's logic prioritizes this check. If the page is not marked as present, the MMU cannot proceed to check protection bits (read/write/execute) because there is no valid physical frame to protect. The MMU immediately signals a fault to the CPU, and the hardware typically reports the cause as a \"not-present\" or \"invalid page\" fault.\n\nThe properties of the page after the gap, which starts at address $B+P+gP$, are described by a completely different PTE. The MMU hardware does not look ahead at other PTEs when translating a specific address. The translation process for address $B+P$ is independent of the mapping or protection status of the page starting at $B+P+gP$. Therefore, the protection bits of the mapped page following the gap have absolutely no influence on the classification of the fault caused by the first access into the gap. The fault is unequivocally classified based on the invalid mapping of the accessed page itself.",
            "answer": "$$\\boxed{P \\times \\left( \\left\\lfloor \\frac{S}{P} \\right\\rfloor + 1 \\right)}$$"
        },
        {
            "introduction": "Operating systems don't just use memory protection to isolate processes; they also leverage it to build more reliable software. This exercise explores the concept of 'guard pages,' a crucial technique for preventing stack overflows by intentionally placing non-writable pages adjacent to a thread's stack. By determining the maximum recursion depth before a fault occurs, you will see how a hardware mechanism can be used to turn a silent and dangerous data corruption bug into an immediate and detectable program crash .",
            "id": "3657704",
            "problem": "An operating system uses demand paging with per-page access permissions enforced by the memory management unit (MMU). Each virtual memory page has a size of $P$ bytes. The stack for a particular thread is placed in a region where virtual pages alternate between data pages with read and write permissions ($\\text{rw}$, non-executable) and guard pages with execute-only permission ($\\text{--x}$), in the repeating pattern $\\text{rw}, \\text{--x}, \\text{rw}, \\text{--x}, \\dots$. The stack grows toward lower addresses. The thread begins execution with the stack pointer aligned to the top of an $\\text{rw}$ page and with $0$ bytes currently used in that page. Each recursive function call consumes a fixed-size activation record of $F$ bytes that is laid out contiguously on the stack. The hardware raises a protection fault immediately upon any read or write that targets a page whose corresponding permission bit (read or write) is not set.\n\nStarting from the definitions of page size, page permissions, and the MMU’s access checks, derive a closed-form expression for the maximum number of completed recursive calls $d$ that can be performed before the first protection fault occurs in this configuration. Your derivation should proceed from first principles, explicitly identifying the resource that limits stack growth and how the MMU enforces that limit, without invoking any pre-derived shortcut formulas. Express your final answer in terms of $P$ and $F$ using standard mathematical operators and, if needed, an appropriate integer-rounding operator. No rounding by significant figures is required. Also, in a few sentences within your reasoning, explain how the presence of the execute-only guard pages prevents silent memory corruption compared to a design where all pages are $\\text{rw}$.",
            "solution": "The problem asks for the maximum number of completed recursive calls, $d$, before a protection fault occurs. The solution requires analyzing the memory layout, the stack growth mechanism, and the conditions under which the Memory Management Unit (MMU) generates a fault.\n\n**Derivation from First Principles**\n\nThe operating system has configured the virtual address space for the thread's stack such that usable memory pages are separated by protected guard pages. The pattern is $\\text{rw}, \\text{--x}, \\text{rw}, \\text{--x}, \\dots$. Each page, whether an $\\text{rw}$ data page or a $\\text{--x}$ guard page, has a size of $P$ bytes.\n\nThe stack grows toward lower memory addresses. The problem states that the stack pointer begins at the top of an $\\text{rw}$ page. Let us denote the starting address of this page (its highest address) as $A_{start}$. Since the stack grows downwards, it will consume memory at addresses $A_{start}-1$, $A_{start}-2$, and so on.\n\nThis initial $\\text{rw}$ page provides a contiguous block of $P$ bytes of memory where read and write operations are permitted. The addresses in this page range from $A_{start}-P$ (inclusive, lowest address) to $A_{start}-1$ (inclusive, highest address used by the stack). The page immediately below this one in the address space is a guard page with $\\text{--x}$ permissions. Any attempt to read from or write to this guard page will trigger a protection fault, as the necessary $\\text{r}$ or $\\text{w}$ permission bits are not set for that page.\n\nEach recursive function call consumes a fixed-size activation record of $F$ bytes. When a function is called, its activation record is pushed onto the stack. For $d$ completed recursive calls, the total memory consumed on the stack is the sum of the sizes of the $d$ activation records. Since each is of size $F$, the total memory footprint is $d \\times F$ bytes.\n\nThe thread can execute without faults as long as all memory writes required for pushing these activation records occur within pages that have write permission. From the starting configuration, the thread has access to one full $\\text{rw}$ page, providing exactly $P$ bytes of usable stack space before a guard page is encountered.\n\nTherefore, the total memory consumed by the completed calls, $d \\times F$, must be less than or equal to the available $\\text{rw}$ space, which is $P$. This gives us the inequality:\n$$d \\times F \\le P$$\n\nWe are looking for the maximum number of *completed* calls, which corresponds to the maximum integer value of $d$ that satisfies this condition. Assuming $F > 0$ (an activation record must have a non-zero size), we can divide by $F$:\n$$d \\le \\frac{P}{F}$$\n\nSince $d$ must be an integer representing the number of calls, the maximum value it can take is the largest integer that is less than or equal to $\\frac{P}{F}$. This is, by definition, the floor of the expression $\\frac{P}{F}$.\n$$d_{max} = \\left\\lfloor \\frac{P}{F} \\right\\rfloor$$\n\nLet's verify this. After $d_{max}$ calls, the total stack usage is $d_{max} \\times F = \\lfloor \\frac{P}{F} \\rfloor \\times F$. By the definition of the floor function, $\\lfloor x \\rfloor \\le x$, so $\\lfloor \\frac{P}{F} \\rfloor \\le \\frac{P}{F}$, which implies $\\lfloor \\frac{P}{F} \\rfloor \\times F \\le P$. Thus, all memory access for the first $d_{max}$ calls falls within the initial $\\text{rw}$ page.\n\nNow, consider the $(d_{max} + 1)$-th call. This call would attempt to push another activation record of size $F$. The total memory required would be $(d_{max} + 1) \\times F$. Since $\\lfloor x \\rfloor > x - 1$, we have $\\lfloor \\frac{P}{F} \\rfloor > \\frac{P}{F} - 1$, which means $\\lfloor \\frac{P}{F} \\rfloor + 1 > \\frac{P}{F}$. Multiplying by $F$ gives $(\\lfloor \\frac{P}{F} \\rfloor + 1) \\times F > P$. This shows that the memory required for the $(d_{max} + 1)$-th call exceeds the $P$ bytes available in the initial $\\text{rw}$ page. The write operation will cross the page boundary and target an address within the adjacent $\\text{--x}$ guard page, causing an immediate protection fault. Therefore, the $(d_{max} + 1)$-th call cannot complete.\n\n**Role of Guard Pages**\n\nThe presence of the execute-only ($\\text{--x}$) guard pages is a critical security and reliability feature. In a system where all pages were $\\text{rw}$, a stack overflow (consuming more stack space than allocated) would cause the stack to grow into an adjacent memory region, such as the heap or another thread's stack. This would silently corrupt data in that region, leading to unpredictable program behavior, difficult-to-diagnose crashes, and potential security vulnerabilities like buffer overflow exploits. By placing a non-writable guard page next to the stack's allocated region, any attempt to grow the stack beyond its limit results in an immediate, deterministic hardware protection fault. This fault is caught by the operating system, which typically terminates the offending process, turning a silent data corruption bug into an easily identifiable crash at the exact point of the error.",
            "answer": "$$\\boxed{\\left\\lfloor \\frac{P}{F} \\right\\rfloor}$$"
        },
        {
            "introduction": "Real-world programs often perform operations that span multiple memory pages, which can lead to complex failure modes when protection boundaries are crossed. This problem investigates what happens when a memory copy operation starts on a writable page but attempts to continue onto a read-only page, resulting in a partial, incomplete write. This practice will push you to think beyond simple hardware faults and consider software-level strategies, like using system calls to manage permissions, to ensure that operations are 'all-or-nothing' or atomic .",
            "id": "3657635",
            "problem": "A user-space program on a $64$-bit Operating System (OS) runs on hardware that enforces virtual memory protection via a Memory Management Unit (MMU). Pages are contiguous regions of virtual memory of size $4096$ bytes, and each page has an associated access-rights vector (e.g., read-only, read-write). The MMU causes a protection fault when an instruction attempts to access a page in a manner not permitted by that page’s rights; the OS delivers a Signal Segmentation Violation (SIGSEGV) to the process upon such a fault. Consider the following situation:\n\n- A destination array begins at virtual address $V$ such that $V \\bmod 4096 = 4080$.\n- The first page containing the start of the destination has read-write permission, and the immediately following page is read-only.\n- A source buffer is fully readable and at least $64$ bytes long.\n- The program calls a standard C library function that copies bytes from the source to the destination in increasing-address order (assume it issues ordinary store instructions that write to the destination and does not use prefetches or non-fault-suppressing speculative stores that would write beyond the page boundary before reaching it).\n\nStarting from the core definitions above (page size and offset arithmetic, MMU enforcement of per-page rights, and process signal delivery on protection violation), reason about the failure mode when attempting to copy $64$ bytes from the source into the destination. Then, evaluate how one might design an all-or-nothing copy (either the full $64$ bytes are written or none are) using page protection changes. Choose all statements that are correct under these assumptions.\n\nA. With page size $4096$ and destination page offset $4080$, copying $64$ bytes writes exactly $16$ bytes into the first page before the first attempted write to the second page triggers a protection fault, causing Signal Segmentation Violation (SIGSEGV). After the fault, the destination contains the first $16$ bytes from the source; no bytes in the second page were modified.\n\nB. The copy completes without fault because the implementation can upgrade page permissions on demand; the MMU allows writing into a read-only page when the write follows a prior successful write to a neighboring page.\n\nC. Marking only the first page temporarily read-only via a protection change before the copy guarantees an all-or-nothing outcome without any signal handling or rollback, because the MMU will prevent any partial writes and the program can simply reattempt the copy afterward to complete it.\n\nD. To ensure all-or-nothing semantics before performing the copy, compute the set of pages covering the destination range and attempt to change their protection to include write access via a protection-change system call (e.g., making both pages read-write). If the protection change for any page fails, abort the copy so no bytes are written; if all succeed, perform the $64$-byte copy and then restore the original protection configuration. This approach yields atomicity at page granularity.\n\nE. Using language-level exceptions (e.g., a try-catch block) around the copy ensures an all-or-nothing outcome because exceptions are raised before any writes occur, preventing partial copies across page boundaries.\n\nSelect all correct options.",
            "solution": "### Derivation and Option Evaluation\n\nFirst, let's analyze the initial failure mode as described in the problem.\n\nThe page size is $4096$ bytes. Addresses within a page are identified by offsets from $0$ to $4095$.\nThe destination array starts at a virtual address $V$ such that its offset within the page is $4080$.\nLet's call the page containing address $V$ as \"Page 1\" and the subsequent page as \"Page 2\".\nPage 1 has read-write permissions.\nPage 2 has read-only permissions.\n\nThe number of bytes available for writing in Page 1, starting from address $V$, is calculated as:\n$$ \\text{Bytes remaining in Page 1} = \\text{Page Size} - \\text{Start Offset} = 4096 - 4080 = 16 \\text{ bytes} $$\nThese $16$ bytes correspond to the address range $[V, V+15]$.\n\nThe program attempts to copy $64$ bytes. The copy operation proceeds in increasing-address order.\n1.  The first $16$ bytes are copied to the address range $[V, V+15]$. All these addresses fall within Page 1, which is writable. These $16$ store operations will succeed.\n2.  The $17$-th byte is to be written to address $V+16$.\n    - The virtual address $V$ can be written as $V = k \\cdot 4096 + 4080$ for some integer $k$.\n    - The virtual address $V+16$ is then $k \\cdot 4096 + 4080 + 16 = k \\cdot 4096 + 4096 = (k+1) \\cdot 4096$.\n    - An address of the form $(k+1) \\cdot 4096$ is the first byte (offset $0$) of the next page, which is Page 2.\n3.  The problem states that Page 2 is read-only.\n4.  When the CPU, executing the copy function, attempts to perform a store instruction to address $V+16$, the MMU will detect a write attempt to a read-only page.\n5.  The MMU will trap to the OS kernel, signaling a protection fault.\n6.  The OS fault handler will identify the cause and deliver a SIGSEGV signal to the user-space process.\n7.  Crucially, the first $16$ writes have already completed and modified the memory in Page 1. The fault occurs on the $17$-th write, which is prevented from happening. All subsequent writes ($18$ through $64$) are also prevented because the process is either terminated or control is transferred to a signal handler, interrupting the normal execution flow of the copy function.\n\nThis initial analysis confirms that the copy operation fails, resulting in a partial write of $16$ bytes.\n\nNow, we evaluate each option based on this understanding and the principles of memory management.\n\n---\n\n**A. With page size $4096$ and destination page offset $4080$, copying $64$ bytes writes exactly $16$ bytes into the first page before the first attempted write to the second page triggers a protection fault, causing Signal Segmentation Violation (SIGSEGV). After the fault, the destination contains the first $16$ bytes from the source; no bytes in the second page were modified.**\n\nThis statement perfectly matches our derived analysis. The calculation of $16$ bytes being successfully written to the first page is correct ($4096 - 4080 = 16$). The identification of the fault occurring on the first write to the second, read-only page is correct. The consequence, a SIGSEGV signal and a partially modified destination, is also correct.\n\nVerdict: **Correct**\n\n---\n\n**B. The copy completes without fault because the implementation can upgrade page permissions on demand; the MMU allows writing into a read-only page when the write follows a prior successful write to a neighboring page.**\n\nThis statement describes a behavior that does not exist in standard hardware MMUs. The MMU is a strict enforcer of permissions set by the operating system in the page tables. It does not dynamically change permissions based on access patterns like \"a write following a prior successful write\". A write to a page marked as read-only will always fault, regardless of what happened in an adjacent page. Any change to page permissions must be done explicitly by the OS via privileged instructions, typically in response to a system call from a process.\n\nVerdict: **Incorrect**\n\n---\n\n**C. Marking only the first page temporarily read-only via a protection change before the copy guarantees an all-or-nothing outcome without any signal handling or rollback, because the MMU will prevent any partial writes and the program can simply reattempt the copy afterward to complete it.**\n\nThis option proposes a strategy for an all-or-nothing copy. Let's analyze it. If the program changes the permission of the first page (Page 1) to read-only *before* starting the copy, the very first write attempt (to address $V$) will target a now read-only page. This will cause an immediate protection fault and a SIGSEGV. At this point, zero bytes have been written, so the \"no partial write\" condition is met. However, the statement claims this works \"without any signal handling\". A protection fault results in a SIGSEGV. If the process has no custom signal handler for SIGSEGV, the default action is to terminate the process. Therefore, the program cannot \"simply reattempt the copy afterward\". To recover from the fault and implement the rest of the strategy (restoring permissions and re-attempting), a custom signal handler is mandatory. The claim that this works without signal handling is fundamentally false.\n\nVerdict: **Incorrect**\n\n---\n\n**D. To ensure all-or-nothing semantics before performing the copy, compute the set of pages covering the destination range and attempt to change their protection to include write access via a protection-change system call (e.g., making both pages read-write). If the protection change for any page fails, abort the copy so no bytes are written; if all succeed, perform the $64$-byte copy and then restore the original protection configuration. This approach yields atomicity at page granularity.**\n\nThis describes a \"pre-flight check\" strategy.\n1.  **Identify Pages:** The copy spans from address $V$ (offset $4080$ in Page 1) to $V+63$. The range is $[V, V+15]$ in Page 1 and $[V+16, V+63]$ in Page 2. So, two pages are involved.\n2.  **Pre-check Permissions:** The program uses a system call (like `mprotect` on POSIX systems) to request write permissions for both pages. This system call is an atomic operation from the user process's perspective.\n3.  **Handle Failure:** If the OS denies the request for either page, the system call will fail and return an error. The program can check this return value and abort the operation. Since no bytes have been copied yet, this satisfies the \"nothing\" part of \"all-or-nothing\".\n4.  **Handle Success:** If the system call succeeds, the program is guaranteed that both pages are now writable. It can then proceed with the $64$-byte copy, which will complete without a protection fault. Afterwards, it can restore the original permissions. This handles the \"all\" part.\nThis is a standard, robust, and correct software pattern for ensuring that a multi-page write can complete without faulting midway. The description of the process is accurate. The final claim that this yields \"atomicity at page granularity\" is also correct, as the check is performed on a per-page basis.\n\nVerdict: **Correct**\n\n---\n\n**E. Using language-level exceptions (e.g., a try-catch block) around the copy ensures an all-or-nothing outcome because exceptions are raised before any writes occur, preventing partial copies across page boundaries.**\n\nThis statement confuses two distinct concepts: hardware-generated signals and language-level exceptions. In C/C++, a `try-catch` block cannot catch a hardware-generated signal like SIGSEGV. Even in languages where this might be possible through complex runtime machinery, the fundamental claim that the \"exception\" is raised \"before any writes occur\" is false. As established in the initial analysis, the SIGSEGV is triggered by the $17$-th attempted write, *after* the first $16$ writes have already successfully modified memory. A partial copy has already occurred before the fault is even generated. Therefore, this mechanism cannot prevent partial writes and cannot ensure an all-or-nothing outcome.\n\nVerdict: **Incorrect**",
            "answer": "$$\\boxed{AD}$$"
        }
    ]
}