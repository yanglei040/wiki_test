{
    "hands_on_practices": [
        {
            "introduction": "Modern systems often attach storage remotely using protocols like iSCSI, which can be managed by the host CPU or by specialized hardware. This exercise guides you through modeling and quantifying the performance trade-offs between a software-based iSCSI initiator and a hardware-offload Network Interface Controller (NIC). By analyzing factors like CPU cycle costs and session setup latency from first principles, you will gain practical skills in evaluating system performance and making informed hardware decisions .",
            "id": "3634733",
            "problem": "A storage team is evaluating two ways to attach remote disks using Internet Small Computer Systems Interface (iSCSI): a software initiator using the host Central Processing Unit (CPU) and an iSCSI offload Network Interface Controller (NIC) that implements protocol processing in hardware. They want a principled estimate of the end-to-end benefit of the offload approach across multiple sessions by combining two effects grounded in first principles: CPU-seconds saved during sustained data transfer and wall-clock attach time saved during session login. Assume the following widely used bases:\n- The total CPU time consumed by a task is the total cycles executed divided by the CPU frequency, that is, $t_{\\text{cpu}} = \\frac{\\text{cycles}}{f}$.\n- Per-byte and per-packet processing costs in a network stack are modeled as constant cycle costs $a$ (cycles per byte) and $p$ (cycles per packet), respectively, and total cycles are additive across bytes and packets.\n- The number of packets needed to carry a given number of payload bytes is the ceiling of payload bytes divided by effective payload per packet.\n- One mebibyte equals $2^{20}$ bytes, that is, $1 \\text{ MiB} = 2^{20} \\text{ bytes}$.\n- An authentication workload of $L$ bytes that is hashed on the CPU consumes a constant number of cycles per byte.\n\nConsider the following concrete scenario. A host with CPU frequency $f$ runs $N$ iSCSI sessions that are attached sequentially and then concurrently sustain reads for a window of $T$ seconds at a per-session application payload throughput $s$. Each session uses a Maximum Transmission Unit (MTU) whose effective TCP payload per packet is $\\text{pld}$ bytes. The software initiator incurs per-byte cost $a_{\\text{sw}}$ and per-packet cost $p_{\\text{sw}}$, while the offload NIC incurs $a_{\\text{off}}$ and $p_{\\text{off}}$. During login (attach), both implementations perform a fixed control handshake of $k$ round trips over a round-trip time $\\text{RTT}$, and both must authenticate $L$ bytes with a hash; the software initiator requires $h_{\\text{sw}}$ cycles per byte for this hash, while the offload NIC reduces the CPU hashing cost to a fraction $\\rho$ of the software cost but introduces a fixed firmware setup delay $g$ per session at login. Assume $k \\in \\mathbb{N}$ and that the control handshake latency component cancels when comparing attach times, because it is identical in both cases.\n\nUse the parameter values:\n- $f = 3.2 \\times 10^{9} \\text{ cycles/s}$, $N = 8$, $T = 10 \\text{ s}$, $s = 50 \\text{ MiB/s}$.\n- $\\text{pld} = 1460 \\text{ bytes}$.\n- $a_{\\text{sw}} = 3 \\text{ cycles/byte}$, $p_{\\text{sw}} = 6000 \\text{ cycles/packet}$.\n- $a_{\\text{off}} = 0.3 \\text{ cycles/byte}$, $p_{\\text{off}} = 600 \\text{ cycles/packet}$.\n- $k = 6$, $\\text{RTT} = 1.5 \\times 10^{-3} \\text{ s}$, $L = 64 \\text{ KiB}$ with $1 \\text{ KiB} = 1024 \\text{ bytes}$, $h_{\\text{sw}} = 20 \\text{ cycles/byte}$, $\\rho = 0.05$, $g = 2.0 \\times 10^{-4} \\text{ s}$.\n\nDefine the combined time advantage $M$ of the offload NIC over the software initiator across all $N$ sessions as the sum of:\n- The total CPU-seconds saved during the $T$-second sustained read window, computed from the difference in data-path cycle costs between software and offload, and\n- The total wall-clock attach (login) time saved across the $N$ sequential session attachments, computed from the difference between software and offload client-side attach times per session.\n\nCompute $M$ and express your final answer in seconds. Round your answer to four significant figures.",
            "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, and objective. It presents a standard performance modeling scenario in computer systems using established first-principle models for CPU cost in network processing. All necessary parameters and definitions are provided, and there are no contradictions or ambiguities. Therefore, a complete solution can be constructed.\n\nThe problem requires the computation of the combined time advantage, $M$, of an iSCSI offload NIC over a software initiator. This advantage is defined as the sum of two components:\n1.  The total CPU-seconds saved during a sustained data transfer period, which we will denote as $\\Delta t_{\\text{cpu,transfer}}$.\n2.  The total wall-clock attach time saved across all sessions, which we will denote as $\\Delta t_{\\text{attach,total}}$.\n\nThus, the total advantage is $M = \\Delta t_{\\text{cpu,transfer}} + \\Delta t_{\\text{attach,total}}$. We will calculate each component separately.\n\nFirst, we calculate the total CPU-seconds saved during the sustained data transfer, $\\Delta t_{\\text{cpu,transfer}}$.\nThe total amount of application payload data transferred, $B_{\\text{total}}$, across all $N$ sessions for a duration $T$ at a per-session throughput $s$ is:\n$$B_{\\text{total}} = N \\times s \\times T$$\nThe throughput $s$ is given in mebibytes per second ($\\text{MiB/s}$), which must be converted to bytes per second. Using the given conversion $1 \\text{ MiB} = 2^{20} \\text{ bytes}$:\n$$B_{\\text{total}} = N \\times (s \\times 2^{20}) \\times T$$\n\nThe total number of packets, $P_{\\text{total}}$, required to transport these bytes is determined by the payload per packet, $\\text{pld}$. According to the problem, this is the ceiling of the total bytes divided by the payload size:\n$$P_{\\text{total}} = \\left\\lceil \\frac{B_{\\text{total}}}{\\text{pld}} \\right\\rceil$$\n\nThe total CPU cycles consumed for data transfer are the sum of per-byte and per-packet costs. For the software initiator, the total cycles are:\n$$C_{\\text{sw,transfer}} = a_{\\text{sw}} B_{\\text{total}} + p_{\\text{sw}} P_{\\text{total}}$$\nFor the offload NIC, the CPU incurs a lower cost:\n$$C_{\\text{off,transfer}} = a_{\\text{off}} B_{\\text{total}} + p_{\\text{off}} P_{\\text{total}}$$\n\nThe number of CPU cycles saved by using the offload NIC is the difference:\n$$\\Delta C_{\\text{transfer}} = C_{\\text{sw,transfer}} - C_{\\text{off,transfer}} = (a_{\\text{sw}} - a_{\\text{off}}) B_{\\text{total}} + (p_{\\text{sw}} - p_{\\text{off}}) P_{\\text{total}}$$\n\nThe CPU time saved, $\\Delta t_{\\text{cpu,transfer}}$, is the number of cycles saved divided by the CPU frequency, $f$:\n$$\\Delta t_{\\text{cpu,transfer}} = \\frac{\\Delta C_{\\text{transfer}}}{f} = \\frac{(a_{\\text{sw}} - a_{\\text{off}}) B_{\\text{total}} + (p_{\\text{sw}} - p_{\\text{off}}) P_{\\text{total}}}{f}$$\n\nNext, we calculate the total wall-clock attach time saved, $\\Delta t_{\\text{attach,total}}$.\nThe sessions are attached sequentially, so the total time saved is $N$ times the saving for a single session. Let $\\Delta t_{\\text{attach,session}}$ be the wall-clock time saved for one session's login.\n$$\\Delta t_{\\text{attach,total}} = N \\times \\Delta t_{\\text{attach,session}}$$\n\nThe attach time for a single session consists of a network handshake component and a CPU-bound authentication component. The problem states that the handshake latency ($k \\times \\text{RTT}$) is identical for both methods and cancels out in the comparison. We therefore only need to consider the difference in the time spent on authentication and any other specified delays.\n\nThe wall-clock time for the software initiator's authentication, $t_{\\text{auth,sw}}$, is the CPU time required to hash $L$ bytes. The size $L$ is given in kibibytes ($\\text{KiB}$) and must be converted to bytes using $1 \\text{ KiB} = 1024 \\text{ bytes}$. Let $L_{\\text{bytes}} = L \\times 1024$.\n$$t_{\\text{auth,sw}} = \\frac{C_{\\text{auth,sw}}}{f} = \\frac{L_{\\text{bytes}} \\times h_{\\text{sw}}}{f}$$\n\nFor the offload NIC, the CPU cost for the hash is reduced by a factor $\\rho$. The wall-clock time for authentication on the CPU is:\n$$t_{\\text{auth,off}} = \\frac{\\rho \\times (L_{\\text{bytes}} \\times h_{\\text{sw}})}{f}$$\nHowever, the offload NIC introduces an additional fixed firmware setup delay, $g$.\n\nThe total wall-clock attach time for each implementation is:\n$$t_{\\text{attach,sw}} = t_{\\text{handshake}} + t_{\\text{auth,sw}}$$\n$$t_{\\text{attach,off}} = t_{\\text{handshake}} + t_{\\text{auth,off}} + g$$\n\nThe saving per session is the difference:\n$$\\Delta t_{\\text{attach,session}} = t_{\\text{attach,sw}} - t_{\\text{attach,off}} = (t_{\\text{handshake}} + t_{\\text{auth,sw}}) - (t_{\\text{handshake}} + t_{\\text{auth,off}} + g)$$\n$$\\Delta t_{\\text{attach,session}} = t_{\\text{auth,sw}} - t_{\\text{auth,off}} - g = \\frac{L_{\\text{bytes}} h_{\\text{sw}}}{f} - \\frac{\\rho L_{\\text{bytes}} h_{\\text{sw}}}{f} - g = \\frac{(1 - \\rho) L_{\\text{bytes}} h_{\\text{sw}}}{f} - g$$\n\nThe total wall-clock time saved across all $N$ sessions is:\n$$\\Delta t_{\\text{attach,total}} = N \\left(\\frac{(1 - \\rho) (L \\times 1024) h_{\\text{sw}}}{f} - g\\right)$$\n\nNow, we substitute the given numerical values into these expressions.\nGiven values: $f = 3.2 \\times 10^9 \\text{ s}^{-1}$, $N = 8$, $T = 10 \\text{ s}$, $s = 50 \\text{ MiB/s}$, $\\text{pld} = 1460 \\text{ bytes}$, $a_{\\text{sw}} = 3$, $p_{\\text{sw}} = 6000$, $a_{\\text{off}} = 0.3$, $p_{\\text{off}} = 600$, $L = 64 \\text{ KiB}$, $h_{\\text{sw}} = 20$, $\\rho = 0.05$, $g = 2.0 \\times 10^{-4} \\text{ s}$.\n\nCalculation of $\\Delta t_{\\text{cpu,transfer}}$:\n$B_{\\text{total}} = 8 \\times (50 \\times 2^{20} \\text{ bytes/s}) \\times 10 \\text{ s} = 4000 \\times 2^{20} \\text{ bytes} = 4194304000 \\text{ bytes}$.\n$P_{\\text{total}} = \\lceil \\frac{4194304000}{1460} \\rceil = \\lceil 2872810.95... \\rceil = 2872811 \\text{ packets}$.\n$\\Delta a = a_{\\text{sw}} - a_{\\text{off}} = 3 - 0.3 = 2.7$ cycles/byte.\n$\\Delta p = p_{\\text{sw}} - p_{\\text{off}} = 6000 - 600 = 5400$ cycles/packet.\n$\\Delta C_{\\text{transfer}} = (2.7 \\times 4194304000) + (5400 \\times 2872811) = 11324620800 + 15513179400 = 26837800200 \\text{ cycles}$.\n$\\Delta t_{\\text{cpu,transfer}} = \\frac{26837800200}{3.2 \\times 10^9} \\approx 8.38681 \\text{ s}$.\n\nCalculation of $\\Delta t_{\\text{attach,total}}$:\n$L_{\\text{bytes}} = 64 \\text{ KiB} = 64 \\times 1024 \\text{ bytes} = 65536 \\text{ bytes}$.\n$1 - \\rho = 1 - 0.05 = 0.95$.\n$\\Delta t_{\\text{attach,session}} = \\frac{0.95 \\times 65536 \\times 20}{3.2 \\times 10^9} - 2.0 \\times 10^{-4} = \\frac{1245184}{3.2 \\times 10^9} - 0.0002 = 0.00038912 - 0.0002 = 0.00018912 \\text{ s}$.\n$\\Delta t_{\\text{attach,total}} = 8 \\times 0.00018912 \\text{ s} = 0.00151296 \\text{ s}$.\n\nFinally, we compute the total advantage $M$:\n$M = \\Delta t_{\\text{cpu,transfer}} + \\Delta t_{\\text{attach,total}} = 8.3868125 \\text{ s} + 0.00151296 \\text{ s} = 8.3883255225 \\text{ s}$.\n\nThe problem requires the answer to be rounded to four significant figures.\n$M \\approx 8.388 \\text{ s}$.",
            "answer": "$$\n\\boxed{8.388}\n$$"
        },
        {
            "introduction": "A system's reliability depends not just on its average speed, but on its ability to handle infrequent, high-latency I/O events. This practice introduces a probabilistic model to analyze the \"tail latency\" of different disk attachment methods, including NVMe, SATA, and iSCSI. By calculating high-percentile latencies and deriving appropriate I/O timeout values, you will learn how to build robust systems that can distinguish between temporary delays and genuine device failures .",
            "id": "3634744",
            "problem": "An operating system must choose safe timeout settings for block I/O across different disk attachment methods while controlling false timeouts. Consider a single-block read latency model for three attachment methods: Non-Volatile Memory Express (NVMe), Serial Advanced Technology Attachment (SATA) solid-state drive, and Internet Small Computer Systems Interface (iSCSI) over Ethernet. For each attachment, model the per-request latency random variable as $X = c + Z$, where $c$ is a nonnegative constant representing the base latency and $Z$ is a random variable that captures occasional tail delays due to queuing or retries. Assume $Z$ takes value $0$ with probability $1 - p$ and is equal to $Y$ with probability $p$, where $Y$ is independent of $c$ and has the exponential distribution with rate $\\lambda$. The cumulative distribution function of the exponential distribution is $F_{Y}(y) = 1 - \\exp(-\\lambda y)$ for $y \\ge 0$. This mixture model captures the empirical observation of a mass at $c$ with an exponential tail.\n\nFor each attachment method, use the following parameters, all in milliseconds:\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$.\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$.\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$.\n\nUsing the fundamental definitions above and reasoning from the model, do the following:\n1. Derive the expression for the $0.99$-quantile (the $99$th percentile) latency $L_{99}$ of $X$ and compute $L_{99}$ for each attachment method.\n2. Recommend an operating system timeout $t_{o}$ per attachment by choosing the smallest $t_{o}$ such that $\\mathbb{P}(X > t_{o}) \\le \\theta$ with target tail exceedance $\\theta = 10^{-4}$. Compute $t_{o}$ for each attachment method.\n\nRound all numerical answers to four significant figures. Express all answers in milliseconds. Provide your final answer as a single row containing six values in the order: $L_{99}^{\\mathrm{NVMe}}$, $L_{99}^{\\mathrm{SATA}}$, $L_{99}^{\\mathrm{iSCSI}}$, $t_{o}^{\\mathrm{NVMe}}$, $t_{o}^{\\mathrm{SATA}}$, $t_{o}^{\\mathrm{iSCSI}}$.",
            "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically grounded, and objective problem in applied probability and analysis of computer systems performance. All necessary parameters and definitions are provided, and there are no internal contradictions.\n\nThe latency for a single-block read is modeled by the random variable $X = c + Z$. Here, $c$ is a constant base latency, and $Z$ is a random variable representing additional delays. The variable $Z$ follows a mixture distribution: it is $0$ with probability $1-p$ and follows an exponential distribution with rate $\\lambda$ with probability $p$. Let this exponential random variable be $Y$. The cumulative distribution function (CDF) of $Y$ is given as $F_Y(y) = 1 - \\exp(-\\lambda y)$ for $y \\ge 0$.\n\nFirst, we derive the CDF of the total latency $X$, denoted by $F_X(x) = \\mathbb{P}(X \\le x)$.\n$$F_X(x) = \\mathbb{P}(c + Z \\le x) = \\mathbb{P}(Z \\le x-c)$$\nLet $z' = x-c$. The support of $Z$ is $[0, \\infty)$, since $Y$ has support $[0, \\infty)$ and $Z$ can also be $0$. Therefore, if $x < c$, then $x-c < 0$, and $\\mathbb{P}(Z \\le x-c) = 0$. So, $F_X(x) = 0$ for $x < c$.\n\nFor $x \\ge c$, we have $x-c \\ge 0$. We can use the law of total probability to find the CDF of $Z$.\n$$\\mathbb{P}(Z \\le z') = \\mathbb{P}(Z \\le z' | Z=0)\\mathbb{P}(Z=0) + \\mathbb{P}(Z \\le z' | Z=Y)\\mathbb{P}(Z=Y)$$\nSince $z' \\ge 0$, the condition $0 \\le z'$ is always true.\n$$\\mathbb{P}(Z \\le z') = 1 \\cdot (1-p) + \\mathbb{P}(Y \\le z') \\cdot p$$\nSubstituting the CDF of the exponential distribution, $F_Y(z') = 1 - \\exp(-\\lambda z')$:\n$$\\mathbb{P}(Z \\le z') = (1-p) + p(1 - \\exp(-\\lambda z')) = 1 - p + p - p\\exp(-\\lambda z') = 1 - p\\exp(-\\lambda z')$$\nSubstituting $z' = x-c$ back, we get the CDF of $X$ for $x \\ge c$:\n$$F_X(x) = 1 - p\\exp(-\\lambda(x-c))$$\nThis CDF has a discontinuity at $x=c$. The probability of a request finishing at exactly the base latency $c$ is $\\mathbb{P}(X=c) = \\mathbb{P}(Z=0) = 1-p$. The CDF value at this point is $F_X(c) = \\mathbb{P}(X \\le c) = \\mathbb{P}(X=c) = 1-p$, which is consistent with our derived formula: $F_X(c) = 1 - p\\exp(0) = 1-p$.\n\n1. Derive the expression for the $0.99$-quantile ($99^{th}$ percentile) latency $L_{99}$.\nThe $q$-quantile $x_q$ is the value such that $F_X(x_q) = q$. We need to find $L_{99}$ such that $F_X(L_{99}) = 0.99$.\nFirst, we check if the quantile lies at the point mass at $c$ or in the exponential tail. The value of the CDF at the point mass is $1-p$.\nFor NVMe: $1 - p_{\\mathrm{NVMe}} = 1 - 0.02 = 0.98$.\nFor SATA: $1 - p_{\\mathrm{SATA}} = 1 - 0.03 = 0.97$.\nFor iSCSI: $1 - p_{\\mathrm{iSCSI}} = 1 - 0.05 = 0.95$.\nIn all three cases, the target probability $0.99$ is greater than $1-p$. This means $L_{99}$ must be greater than $c$ and lie within the continuous exponential tail of the distribution. We solve for $L_{99}$:\n$$F_X(L_{99}) = 1 - p\\exp(-\\lambda(L_{99}-c)) = 0.99$$\n$$p\\exp(-\\lambda(L_{99}-c)) = 1 - 0.99 = 0.01$$\n$$\\exp(-\\lambda(L_{99}-c)) = \\frac{0.01}{p}$$\nTaking the natural logarithm of both sides:\n$$-\\lambda(L_{99}-c) = \\ln\\left(\\frac{0.01}{p}\\right) = -\\ln\\left(\\frac{p}{0.01}\\right)$$\n$$L_{99}-c = \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{0.01}\\right)$$\n$$L_{99} = c + \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{10^{-2}}\\right)$$\n\nWe now compute $L_{99}$ for each attachment method.\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$.\n$L_{99}^{\\mathrm{NVMe}} = 0.12 + 0.35 \\cdot \\ln\\left(\\frac{0.02}{0.01}\\right) = 0.12 + 0.35 \\ln(2) \\approx 0.12 + 0.35(0.693147) \\approx 0.362601$ ms.\nTo four significant figures, $L_{99}^{\\mathrm{NVMe}} = 0.3626$ ms.\n\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$.\n$L_{99}^{\\mathrm{SATA}} = 0.45 + 3.0 \\cdot \\ln\\left(\\frac{0.03}{0.01}\\right) = 0.45 + 3.0 \\ln(3) \\approx 0.45 + 3.0(1.098612) \\approx 3.745836$ ms.\nTo four significant figures, $L_{99}^{\\mathrm{SATA}} = 3.746$ ms.\n\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$.\n$L_{99}^{\\mathrm{iSCSI}} = 1.30 + 10.0 \\cdot \\ln\\left(\\frac{0.05}{0.01}\\right) = 1.30 + 10.0 \\ln(5) \\approx 1.30 + 10.0(1.609438) \\approx 17.39438$ ms.\nTo four significant figures, $L_{99}^{\\mathrm{iSCSI}} = 17.39$ ms.\n\n2. Recommend an operating system timeout $t_{o}$.\nWe need to find the smallest $t_o$ such that the probability of exceeding this timeout is at most $\\theta = 10^{-4}$.\n$$\\mathbb{P}(X > t_o) \\le \\theta$$\nThis is equivalent to $1 - \\mathbb{P}(X \\le t_o) \\le \\theta$, or $F_X(t_o) \\ge 1 - \\theta$.\nTo find the smallest such $t_o$, we set the CDF to this minimum required value:\n$$F_X(t_o) = 1 - \\theta = 1 - 10^{-4} = 0.9999$$\nThe logic is identical to the quantile calculation in Part 1. For all three attachment methods, $1-p < 0.9999$, so the timeout $t_o$ will be greater than the base latency $c$.\n$$1 - p\\exp(-\\lambda(t_o-c)) = 1 - \\theta$$\n$$p\\exp(-\\lambda(t_o-c)) = \\theta$$\n$$\\exp(-\\lambda(t_o-c)) = \\frac{\\theta}{p}$$\n$$-\\lambda(t_o-c) = \\ln\\left(\\frac{\\theta}{p}\\right) = -\\ln\\left(\\frac{p}{\\theta}\\right)$$\n$$t_o - c = \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{\\theta}\\right)$$\n$$t_o = c + \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{\\theta}\\right)$$\n\nWe now compute $t_o$ for each attachment method with $\\theta = 10^{-4}$.\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$.\n$t_{o}^{\\mathrm{NVMe}} = 0.12 + 0.35 \\cdot \\ln\\left(\\frac{0.02}{10^{-4}}\\right) = 0.12 + 0.35 \\ln(200) \\approx 0.12 + 0.35(5.298317) \\approx 1.97441$ ms.\nTo four significant figures, $t_{o}^{\\mathrm{NVMe}} = 1.974$ ms.\n\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$.\n$t_{o}^{\\mathrm{SATA}} = 0.45 + 3.0 \\cdot \\ln\\left(\\frac{0.03}{10^{-4}}\\right) = 0.45 + 3.0 \\ln(300) \\approx 0.45 + 3.0(5.703782) \\approx 17.5613$ ms.\nTo four significant figures, $t_{o}^{\\mathrm{SATA}} = 17.56$ ms.\n\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$.\n$t_{o}^{\\mathrm{iSCSI}} = 1.30 + 10.0 \\cdot \\ln\\left(\\frac{0.05}{10^{-4}}\\right) = 1.30 + 10.0 \\ln(500) \\approx 1.30 + 10.0(6.214608) \\approx 63.4461$ ms.\nTo four significant figures, $t_{o}^{\\mathrm{iSCSI}} = 63.45$ ms.\n\nThe six required values are $L_{99}^{\\mathrm{NVMe}}$, $L_{99}^{\\mathrm{SATA}}$, $L_{99}^{\\mathrm{iSCSI}}$, $t_{o}^{\\mathrm{NVMe}}$, $t_{o}^{\\mathrm{SATA}}$, and $t_{o}^{\\mathrm{iSCSI}}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.3626 & 3.746 & 17.39 & 1.974 & 17.56 & 63.45 \\end{pmatrix}}$$"
        },
        {
            "introduction": "During startup, an operating system must correctly identify the boot volume among potentially many attached storage devices, a process complicated by administrative practices like disk cloning. This exercise explores the probabilistic risk of booting from an incorrect device when unique identifiers are duplicated. By analyzing this failure mode and quantifying the effectiveness of a cryptographic safeguard, you will see how layered, independent identifiers can dramatically improve system integrity and prevent critical errors .",
            "id": "3634761",
            "problem": "A server supports multiple disk attachment methods, including Serial Advanced Technology Attachment (SATA), Non-Volatile Memory Express (NVMe), and Internet Small Computer Systems Interface (iSCSI). During early boot, the operating systemâ€™s device enumerator scans attachments in an event-driven manner across buses, and the overall arrival order of candidate block devices can be modeled as a uniformly random permutation, reflecting asynchronous discovery latencies and independent bus probing. The boot configuration identifies the root volume by a filesystem Universally Unique Identifier (UUID), defined as a standardized Universally Unique Identifier (UUID) string stored in the filesystem superblock. Due to block-level cloning, exactly $k$ attachments share the same filesystem UUID; one is the intended root, while the remaining $k-1$ are wrong clones. All other attachments have non-matching filesystem UUIDs. There are no device-path pinning hints or persistent ordering guarantees across buses.\n\nAssume there are $n_{S}$ SATA disks, $n_{N}$ NVMe namespaces, and $n_{I}$ iSCSI Logical Unit Numbers (LUNs); these totals determine the pool the enumerator scans but do not otherwise bias which of the $k$ matching attachments appears first. The system currently chooses the first attachment whose filesystem UUID equals the configured target.\n\nYou then deploy a safeguard: introduce $G$ independent Globally Unique Identifier (GUID) namespaces, where each attachment is assigned a fresh random $128$-bit Globally Unique Identifier (GUID) in each namespace at provisioning. Clones retain the same filesystem UUID as the intended root but do not share any of the newly assigned GUIDs. The boot acceptance rule becomes a conjunction: a device is accepted only if its filesystem UUID and all $G$ namespace GUIDs match the configured values. Treat the random $128$-bit GUIDs as independent and uniformly distributed across attachments and across namespaces.\n\nStarting from first principles of randomized enumeration and independence of cryptographic identifiers:\n- Derive an expression for the probability $p_{misboot}$ of booting from a wrong attachment under the original rule (matching on filesystem UUID only), in terms of $k$.\n- Derive a closed-form expression for $p_{misboot}$ under the safeguard, as a function of $k$ and $G$.\n- Evaluate the safeguarded $p_{misboot}$ numerically for $k=3$ and $G=2$, rounding your answer to four significant figures. Express the final probability as a decimal in scientific notation. No unit is required.\n\nFor concreteness, you may take $n_{S}=4$, $n_{N}=3$, and $n_{I}=5$, and you should justify why these counts do or do not affect $p_{misboot}$ under the assumptions stated. The final numeric answer must be the safeguarded $p_{misboot}$ for $k=3$ and $G=2$, rounded to four significant figures.",
            "solution": "The problem requires the derivation of misboot probabilities under two different boot rules and a final numerical evaluation.\n\nFirst, we address the role of the device counts $n_{S}$, $n_{N}$, and $n_{I}$. The total number of devices is $N = n_{S} + n_{N} + n_{I}$. The problem states that the operating system scans devices in a \"uniformly random permutation\" and chooses the *first* one that meets the boot criteria. The boot criteria involve matching a specific filesystem UUID. There are $k$ devices with this target UUID and $N-k$ devices without it. The boot process will never terminate on one of the $N-k$ devices, so they are irrelevant to the final choice. The decision is made exclusively among the $k$ candidate devices. Since the overall permutation of $N$ devices is uniformly random, the relative ordering of the $k$ candidate devices is also a uniformly random permutation of size $k$. This means each of the $k$ devices with the matching UUID has an equal probability of appearing first in the sequence of candidates. Consequently, the specific values of $n_{S}$, $n_{N}$, and $n_{I}$ (which sum to $N$) do not influence the probability of misboot, as this probability depends only on the relative ordering within the group of $k$ candidates.\n\nDerivation of $p_{misboot}$ under the original rule:\nUnder the original rule, the system boots from the first device it finds with the correct filesystem UUID. We have a set of $k$ such devices, comprising $1$ correct root device and $k-1$ incorrect clones. As established, each of these $k$ devices has an equal chance of being the first one encountered from this set.\nA misboot occurs if the first device encountered is one of the $k-1$ clones. The probability of this event is the number of unfavorable outcomes divided by the total number of possible outcomes.\nThere are $k-1$ unfavorable outcomes (selecting a clone) and $k$ total possible outcomes (selecting any of the devices with the matching UUID).\nTherefore, the probability of a misboot, $p_{misboot}$, is:\n$$p_{misboot} = \\frac{k-1}{k}$$\n\nDerivation of $p_{misboot}$ under the safeguard rule:\nUnder the safeguard, a device must match the filesystem UUID and all $G$ provisioned GUIDs. The $k-1$ clones share the filesystem UUID but are assigned fresh, random $128$-bit GUIDs in each of the $G$ namespaces.\nThe probability that a single, randomly generated $128$-bit GUID happens to match a specific target GUID is $p_{g} = \\frac{1}{2^{128}}$, assuming a uniform distribution.\nSince the $G$ GUIDs are independent, the probability that a single clone has a full set of matching GUIDs by pure chance (a \"GUID collision\") is:\n$$p_{coll} = (p_{g})^{G} = \\left(\\frac{1}{2^{128}}\\right)^G = 2^{-128G}$$\nA misboot can only occur if at least one clone has a GUID collision *and* is scanned before the true root volume.\n\nLet $M$ be the number of clones (out of $k-1$) that have a GUID collision. This is a random variable that follows a binomial distribution, $M \\sim \\text{Binomial}(k-1, p_{coll})$. The set of devices that can pass all checks (are \"bootable\") includes the true root volume (which always passes) and the $M$ colliding clones. The total number of bootable devices is $1+M$. The system will boot from the first of these $1+M$ bootable devices that it encounters. A misboot occurs if this device is one of the $M$ clones. Given $M=m$ colliding clones, there are $1+m$ bootable devices. By symmetry, the probability that the first one of these to be scanned is a clone is $\\frac{m}{1+m}$.\n\nTo find the total probability of a misboot, we compute the expected value of this conditional probability over all possible values of $M$:\n$$p_{misboot} = E\\left[\\frac{M}{1+M}\\right] = \\sum_{m=0}^{k-1} P(M=m) \\frac{m}{1+m}$$\nThis can be calculated as $p_{misboot} = 1 - E\\left[\\frac{1}{1+M}\\right]$. We can find a closed form for the expectation:\n$$ E\\left[\\frac{1}{1+M}\\right] = \\sum_{m=0}^{k-1} \\frac{1}{m+1} \\binom{k-1}{m} p_{coll}^m (1-p_{coll})^{k-1-m} $$\nUsing the identity $\\frac{1}{m+1}\\binom{n}{m} = \\frac{1}{n+1}\\binom{n+1}{m+1}$ with $n=k-1$:\n$$ E\\left[\\frac{1}{1+M}\\right] = \\sum_{m=0}^{k-1} \\frac{1}{k}\\binom{k}{m+1}p_{coll}^m (1-p_{coll})^{k-1-m} $$\nLet $j=m+1$.\n$$ E\\left[\\frac{1}{1+M}\\right] = \\frac{1}{k} \\sum_{j=1}^{k} \\binom{k}{j} p_{coll}^{j-1} (1-p_{coll})^{k-j} = \\frac{1}{k \\cdot p_{coll}} \\sum_{j=1}^{k} \\binom{k}{j} p_{coll}^{j} (1-p_{coll})^{k-j} $$\nThe sum is the binomial probability $P(X \\ge 1)$ where $X \\sim \\text{Binomial}(k, p_{coll})$, which equals $1 - P(X=0) = 1 - (1-p_{coll})^k$.\n$$ E\\left[\\frac{1}{1+M}\\right] = \\frac{1 - (1-p_{coll})^k}{k \\cdot p_{coll}} $$\nTherefore, the exact closed-form expression for the misboot probability is:\n$$p_{misboot} = 1 - \\frac{1 - (1-p_{coll})^k}{k \\cdot p_{coll}}$$\nwhere $p_{coll} = 2^{-128G}$.\n\nNumerical evaluation for $k=3$ and $G=2$:\nFor these values, the collision probability is $p_{coll} = 2^{-128 \\times 2} = 2^{-256}$.\nWe substitute $k=3$ into our derived expression:\n$$p_{misboot} = 1 - \\frac{1 - (1-p_{coll})^3}{3 p_{coll}}$$\nUsing the binomial expansion $(1-x)^3 = 1 - 3x + 3x^2 - x^3$:\n$$p_{misboot} = 1 - \\frac{1 - (1 - 3p_{coll} + 3p_{coll}^2 - p_{coll}^3)}{3 p_{coll}} = 1 - \\frac{3p_{coll} - 3p_{coll}^2 + p_{coll}^3}{3 p_{coll}}$$\n$$p_{misboot} = 1 - \\left(1 - p_{coll} + \\frac{1}{3}p_{coll}^2\\right) = p_{coll} - \\frac{1}{3}p_{coll}^2$$\nSince $p_{coll} = 2^{-256}$ is an extremely small number, the term $\\frac{1}{3}p_{coll}^2$ is negligible compared to $p_{coll}$. Thus, we can approximate $p_{misboot} \\approx p_{coll} = 2^{-256}$.\nWe convert this to scientific notation:\n$$ \\log_{10}(p_{misboot}) \\approx \\log_{10}(2^{-256}) = -256 \\log_{10}(2) \\approx -256 \\times 0.30103 \\approx -77.06368 $$\n$$ p_{misboot} \\approx 10^{-77.06368} = 10^{0.93632} \\times 10^{-78} \\approx 8.6358 \\times 10^{-78} $$\nRounding to four significant figures, the probability is $8.636 \\times 10^{-78}$.",
            "answer": "$$\\boxed{8.636 \\times 10^{-78}}$$"
        }
    ]
}