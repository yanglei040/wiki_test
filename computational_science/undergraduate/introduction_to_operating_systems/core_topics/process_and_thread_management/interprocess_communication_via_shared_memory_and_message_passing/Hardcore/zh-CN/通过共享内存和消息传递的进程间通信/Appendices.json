{
    "hands_on_practices": [
        {
            "introduction": "缓存行是内存一致性的基本单位。当不同线程访问位于同一缓存行内的不同变量时，即使逻辑上没有冲突，硬件层面也会因为缓存一致性协议而产生不必要的通信开销，这种现象被称为“伪共享”（false sharing）。本练习将通过一个量化模型，指导你推导出为避免伪共享而必须在共享变量之间设置的最小安全距离，从而加深对底层硬件行为的理解。",
            "id": "3650171",
            "problem": "一个系统团队正在评估两种用于两个协作进程之间进行进程间通信的设计：通过操作系统原语进行消息传递，以及使用共享内存进行原地更新。为了减少消息传递中常见的系统调用开销，他们考虑对两个频繁更新的计数器使用共享内存。硬件是一个共享内存多处理器，具有写-失效缓存一致性，并且缓存行大小固定为 $L$ 字节。系统会创建一个共享内存段，并将其映射到由操作系统选择的虚拟基地址上；该映射的基地址模 $L$ 的值不能被用户空间控制，可以是 $\\{0,1,\\dots,L-1\\}$ 中的任意一个余数。每个计数器存储在一个大小为 $s$ 字节的标量对象中（其中 $1 \\leq s \\leq L$），并且这两个计数器被放置在距离共享内存段起始位置 $o_1$ 和 $o_2$ 的字节偏移处，其中 $o_2 \\geq o_1$ 且两个计数器的地址不重叠。\n\n请使用以下基本定义作为您推理的基础：\n\n- 缓存行是一致性的单位；如果两个内存位置位于同一缓存行中，不同处理器对这些位置的写入可能会导致伪共享，即使这些位置是不同的，也会表现为一致性流量。\n- 地址 $x$ 位于缓存行索引 $\\left\\lfloor x / L \\right\\rfloor$ 中。一个连续的内存区域 $[x, x + s - 1]$ 占据所有其索引在集合 $\\left\\{\\left\\lfloor \\frac{y}{L} \\right\\rfloor : y \\in [x, x + s - 1]\\right\\}$ 中的缓存行。\n\n设 $B$ 表示映射的（未知）虚拟基地址，两个计数器的地址范围定义为 $[B + o_1, B + o_1 + s - 1]$ 和 $[B + o_2, B + o_2 + s - 1]$。目标是选择一个间距 $d = o_2 - o_1$，以最小化缓存行争用（消除伪共享），而不管 $B \\bmod L$ 的值如何。\n\n请基于上述定义，且不假设 $B$ 有任何特殊对齐方式，推导出一个关于 $L$ 和 $s$ 的最小字节间距 $d$ 的闭式表达式，使得对于 $B \\bmod L$ 的每一种可能的余数，两个计数器都不会占用任何共同的缓存行。请以字节为单位提供您最终的 $d$ 的表达式。不需要进行数值计算或四舍五入；请用 $L$ 和 $s$ 的符号表示最终结果。",
            "solution": "问题要求推导共享内存中两个数据对象（计数器）之间的最小字节间距 $d$，以保证它们不占用任何共同的缓存行，而不管内存映射的基地址对齐方式如何。此条件必须能防止伪共享。\n\n设缓存行大小为 $L$ 字节。两个计数器的大小均为 $s$ 字节，其中 $1 \\le s \\le L$。共享内存段被映射到一个虚拟基地址 $B$。计数器被放置在该基地址的偏移量 $o_1$ 和 $o_2$ 处。间距为 $d = o_2 - o_1$。不失一般性，我们假设 $o_2 \\ge o_1$。\n\n第一个计数器占据连续的内存地址范围 $[B+o_1, B+o_1+s-1]$。我们将其起始地址表示为 $A_1 = B+o_1$。地址范围是 $[A_1, A_1+s-1]$。\n第二个计数器占据地址范围 $[B+o_2, B+o_2+s-1]$。其起始地址为 $A_2 = B+o_2 = B+o_1+d = A_1+d$。地址范围是 $[A_2, A_2+s-1]$。\n\n根据问题陈述，地址 $x$ 位于索引为 $\\lfloor x/L \\rfloor$ 的缓存行中。如果两个内存位置映射到相同的缓存行索引，就会引起争用。为了完全消除两个计数器之间的争用，第一个计数器占用的缓存行索引集合必须与第二个计数器的缓存行索引集合不相交。\n\n第一个计数器的缓存行索引集合 $C_1$ 由其范围内所有地址 $y_1$ 的索引给出：$C_1 = \\{\\lfloor y_1/L \\rfloor : y_1 \\in [A_1, A_1+s-1]\\}$。由于函数 $\\lfloor \\cdot \\rfloor$ 是非递减的，这个索引集合是一个连续的范围。最小索引是 $\\lfloor A_1/L \\rfloor$，最大索引是 $\\lfloor (A_1+s-1)/L \\rfloor$。\n\n同样，第二个计数器的缓存行索引集合 $C_2$ 是 $C_2 = \\{\\lfloor y_2/L \\rfloor : y_2 \\in [A_2, A_2+s-1]\\}$。最小索引是 $\\lfloor A_2/L \\rfloor$，最大索引是 $\\lfloor (A_2+s-1)/L \\rfloor$。\n\n由于 $o_2 \\ge o_1$，我们有 $A_2 \\ge A_1$。为确保缓存行索引集合 $C_1$ 和 $C_2$ 不相交，$C_1$ 中的最大索引必须严格小于 $C_2$ 中的最小索引。这给出了充要条件：\n$$\n\\max(C_1)  \\min(C_2)\n$$\n$$\n\\lfloor \\frac{A_1+s-1}{L} \\rfloor  \\lfloor \\frac{A_2}{L} \\rfloor\n$$\n代入 $A_2 = A_1+d$，条件变为：\n$$\n\\lfloor \\frac{A_1+s-1}{L} \\rfloor  \\lfloor \\frac{A_1+d}{L} \\rfloor\n$$\n这个不等式必须对任何可能的基地址 $B$ 都成立。问题指出基地址模 $L$（我们表示为 $B \\pmod L$）可以是 $\\{0, 1, \\dots, L-1\\}$ 中的任意一个余数。第一个计数器的起始地址是 $A_1 = B+o_1$。偏移量 $o_1$ 是一个固定的选定值，而 $B$ 是可变的。$A_1$ 相对于缓存行边界的对齐由 $A_1 \\pmod L = (B+o_1) \\pmod L$ 给出。由于 $B \\pmod L$ 可以取从 $0$ 到 $L-1$ 的任何值，通过适当选择 $B$，$(B+o_1) \\pmod L$ 也可以取这些值。因此，我们必须确保不等式对 $A_1$ 的任何可能对齐方式都成立。\n\n设 $A_1 = kL+r$，其中 $k$ 是一个整数，表示基缓存行索引，$r \\in \\{0, 1, \\dots, L-1\\}$ 是该行内的字节偏移量。将此代入不等式：\n$$\n\\lfloor \\frac{kL+r+s-1}{L} \\rfloor  \\lfloor \\frac{kL+r+d}{L} \\rfloor\n$$\n使用整数 $n$ 的属性 $\\lfloor z+n \\rfloor = \\lfloor z \\rfloor + n$：\n$$\nk + \\lfloor \\frac{r+s-1}{L} \\rfloor  k + \\lfloor \\frac{r+d}{L} \\rfloor\n$$\n$$\n\\lfloor \\frac{r+s-1}{L} \\rfloor  \\lfloor \\frac{r+d}{L} \\rfloor\n$$\n这等价于要求：\n$$\n\\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\le \\lfloor \\frac{r+d}{L} \\rfloor\n$$\n这个条件必须对所有可能的余数 $r \\in \\{0, 1, \\dots, L-1\\}$ 都成立。为了找到满足所有 $r$ 的最小 $d$，我们必须分析 $r$ 的最坏情况。我们来解出 $d$：\n$$\n\\frac{r+d}{L} \\ge \\lfloor \\frac{r+d}{L} \\rfloor \\ge \\lfloor \\frac{r+s-1}{L} \\rfloor + 1\n$$\n这意味着 $r+d \\ge L \\left( \\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\right)$, 所以：\n$$\nd \\ge L \\left( \\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\right) - r\n$$\n为了找到适用于所有 $r$ 的最小 $d$，我们必须找到右侧表达式在所有可能的 $r$ 上的最大值：\n$$\nd_{min} = \\max_{r \\in \\{0, \\dots, L-1\\}} \\left( L \\left( \\lfloor \\frac{r+s-1}{L} \\rfloor + 1 \\right) - r \\right)\n$$\n我们根据 $\\lfloor (r+s-1)/L \\rfloor$ 的值，分两部分来分析这个表达式。\n给定 $1 \\le s \\le L$ 和 $0 \\le r \\le L-1$，项 $r+s-1$ 的范围可以从 $s-1$ 到 $2L-2$。因此，$\\lfloor (r+s-1)/L \\rfloor$ 的值可以是 $0$ 或 $1$。\n\n情况1：$r+s-1  L$，这意味着 $r  L-s+1$。\n在这种情况下，$\\lfloor (r+s-1)/L \\rfloor = 0$。表达式变为 $L(0+1) - r = L-r$。为了在范围 $[0, L-s]$ 内最大化这个值，我们选择最小的 $r$，即 $r=0$。最大值为 $L-0=L$。\n\n情况2：$r+s-1 \\ge L$，这意味着 $r \\ge L-s+1$。\n在这种情况下，$\\lfloor (r+s-1)/L \\rfloor = 1$。表达式变为 $L(1+1) - r = 2L-r$。为了在范围 $[L-s+1, L-1]$ 内最大化这个值，我们选择最小的 $r$，即 $r=L-s+1$。最大值为 $2L - (L-s+1) = L+s-1$。\n\n所需的总的最小间距 $d$ 是这两种情况要求的最大值：\n$$\nd_{min} = \\max(L, L+s-1)\n$$\n由于 $s \\ge 1$，我们有 $s-1 \\ge 0$，这意味着 $L+s-1 \\ge L$。因此，这两个值的最大值是 $L+s-1$。\n\n所需的最小字节间距为 $d = L+s-1$。这保证了对于共享内存段的任何可能对齐方式，两个计数器都将驻留在完全独立的缓存行中，从而消除伪共享。计数器不重叠的条件 $d \\ge s$ 也得到满足，因为 $L \\ge 1$ 意味着 $L+s-1 \\ge s$。",
            "answer": "$$ \\boxed{L+s-1} $$"
        },
        {
            "introduction": "在现代多处理器系统中，为了追求极致性能，处理器和编译器可能会对内存操作进行重排序，导致其他核心观察到的操作顺序与程序代码的顺序不一致。这种“弱内存模型”为编写正确的并发程序带来了巨大挑战。本练习将剖析一个经典的“单生产者-单消费者”（SPSC）无锁队列中的数据竞争问题，并演示如何运用“释放-获取”（release-acquire）语义来确保数据在进程间的正确、可靠传递。",
            "id": "3650142",
            "problem": "一位软件工程师实现了一个单生产者单消费者（SPSC）环形缓冲区，用于通过共享内存进行进程间通信。该环形缓冲区的容量为 $N$，有一个槽数组 $buf[\\,0 \\dots N-1\\,]$，以及两个索引：$head$（仅由生产者写入）和 $tail$（仅由消费者写入）。通信在缓存一致性多处理器的两个核心上运行。该系统遵守按位置的缓存一致性，但允许编译器和中央处理器（CPU）对不同地址的操作进行重排序，除非受到内存排序原语的约束。\n\n基本操作如下。生产者通过以下步骤入队一个项目：\n- 等待直到缓冲区不满。\n- 通过普通存储将负载写入 $buf[\\,head \\bmod N\\,]$。\n- 通过存储 $head := head + 1$（模 $N$）来发布可用性。\n\n消费者通过以下步骤出队一个项目：\n- 加载 $h := head$。\n- 如果 $h \\ne tail$，则通过普通加载读取 $buf[\\,tail \\bmod N\\,]$，然后存储 $tail := tail + 1$（模 $N$）。\n\n假设初始时 $head = tail = 0$ 且 $N = 2$，并假设 $buf[\\,0\\,]$ 包含一个来自先前时期的旧值 $u$。该实现对 $head$ 和 $tail$ 使用了原子操作，但采用的是松散排序（无内存屏障），并对 $buf[\\cdot]$ 使用普通的非原子加载和存储。生产者的代码按程序顺序执行，但除了程序顺序之外，对 $buf[\\cdot]$ 的存储和随后对 $head$ 的存储之间没有明确的排序约束；同样，消费者加载 $head$ 然后加载 $buf[\\cdot]$ 也没有明确的排序约束。\n\n使用以下基本原则：\n- 在共享内存系统中，缓存一致性对每个内存位置强制实施单一的总顺序，但不对不同位置之间强制实施单一的总顺序。因此，对不同位置的写入操作对其他核心可见的顺序可能与程序顺序不同，除非受到约束。\n- 具有释放语义的存储操作确保其在程序顺序中的所有先前写入操作在释放存储本身变得可见之前，对其他线程可见；具有获取语义的加载操作确保其在程序顺序中的所有后续读取操作所观察到的值不早于获取加载所读到的值。对同一位置的释放操作和匹配的获取加载操作建立了一个先行发生（happens-before）关系，该关系保证了（跨线程的）所有先前的写入操作都在所有后续的读取操作之前发生。\n\n问题：着眼于回绕（由于 $N=2$）和内存排序的相互作用，哪个选项最能指明此 SPSC 环形缓冲区中一个真实的读取陈旧数据风险，并提出一个充分的修正方法，以在所有只保证按位置一致性的架构上防止该风险？\n\nA. 因为只有一个生产者和一个消费者，并且缓存一致性保留了单线程内的程序顺序，所以即使使用松散原子操作，消费者也不会读到陈旧数据；因此不需要额外的内存排序。\n\nB. 如果没有生产者对 $head$ 的释放存储和消费者对 $head$ 的获取加载，消费者有可能在生产者对 $buf[\\,0\\,]$ 的写入变得可见之前，就观察到 $head$ 已经增加（表示回绕后 $buf[\\,0\\,]$ 中有一个项目），从而导致消费者读到陈旧的旧值 $u$。将生产者的 $head$ 更新操作设为释放存储，并将消费者的 $head$ 读取操作设为获取加载，会引入一个先行发生（happens-before）边，从而防止这种陈旧读取。\n\nC. 风险完全来自回绕时的模运算；使用 $i := head \\bmod N$ 且 $N=2$ 会导致地址别名。解决方法是保持所有操作为松散排序，但将索引计算更改为 $i := head \\bmod (N-1)$，这样回绕就永远不会指向同一个槽。\n\nD. 使用2的幂次容量并通过 $i := head \\, \\ \\, (N-1)$ 进行掩码操作，可以将索引与缓存行对齐，从而消除陈旧读取，因此只要 $head$ 和 $tail$ 是原子的，就不需要特定的内存排序。\n\nE. 不使用 $head$ 进行排序，而是将消费者的 $tail$ 加载设为获取操作，并将生产者的 $tail$ 存储设为释放操作就足够了，因为 $tail$ 和 $head$ 是仅有的共享索引，并且至少有一个会被排序。\n\n选择所有适用的选项。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n\n- 实现了一个单生产者单消费者（SPSC）环形缓冲区，用于通过共享内存进行进程间通信。\n- 环形缓冲区的容量为 $N$。\n- 有一个槽数组 $buf[\\,0 \\dots N-1\\,]$。\n- 有两个索引：$head$（仅由生产者写入）和 $tail$（仅由消费者写入）。\n- 系统是一个具有两个核心的缓存一致性多处理器。\n- 系统遵守按位置的缓存一致性，但允许编译器和中央处理器（CPU）对不同地址的操作进行重排序，除非受到内存排序原语的约束。\n- 生产者入队操作：\n    1. 等待直到缓冲区不满。\n    2. 通过普通存储将负载写入 $buf[\\,head \\bmod N\\,]$。\n    3. 通过存储 $head := head + 1$（模 $N$）来发布可用性。\n- 消费者出队操作：\n    1. 加载 $h := head$。\n    2. 如果 $h \\ne tail$，则通过普通加载读取 $buf[\\,tail \\bmod N\\,]$，然后存储 $tail := tail + 1$（模 $N$）。\n- 初始条件：$head = tail = 0$ 且 $N = 2$。\n- $buf[\\,0\\,]$ 包含一个来自先前时期的旧值 $u$。\n- $head$ 和 $tail$ 使用松散排序（无内存屏障）的原子操作。\n- $buf[\\cdot]$ 使用普通的非原子加载和存储。\n- 生产者的对 $buf[\\cdot]$ 的存储和对 $head$ 的存储之间，除了程序顺序外，没有明确的排序约束。\n- 消费者的对 $head$ 的加载和对 $buf[\\cdot]$ 的加载之间没有明确的排序约束。\n- 基本原则（公理）：\n    1. 缓存一致性对每个内存位置强制实施单一的总顺序，但不对不同位置之间强制实施。对不同位置的写入对其他核心可见的顺序可能与程序顺序不同。\n    2. 具有释放语义的存储确保其在程序顺序中的所有先前写入在释放存储本身变得可见之前，对其他线程可见。\n    3. 具有获取语义的加载确保其在程序顺序中的所有后续读取所观察到的值不早于获取加载所读到的值。\n    4. 对同一位置的释放-获取对建立了一个先行发生（happens-before）关系。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了并发编程中的一个经典场景，特别是在弱序内存模型的硬件上设计无锁队列。\n\n- **科学上成立**：该问题坚实地基于计算机体系结构和操作系统的既定原则，包括缓存一致性、内存一致性模型（特别是弱序与强序）、原子操作以及释放-获取语义。这些是现代系统编程中标准且关键的概念。\n- **问题定义明确**：问题被清晰地定义。它提出了一个特定的算法、一个特定的硬件内存模型，并要求识别一种著名的数据竞争类型（陈旧读取）及其标准的正确解决方案。基于所提供的公理，存在一个唯一的、有意义的解决方案。\n- **客观性**：语言技术性强、精确且无主观性。“基本原则”部分提供了明确的推理规则，使问题变得客观和自洽。\n\n该问题没有表现出指令中列出的任何缺陷。对生产者和消费者操作的描述、初始状态、内存模型特性以及内存排序原语的定义都是一致和足够完整的，足以进行严谨的分析。略显模糊的措辞“$head := head + 1$ (modulo $N$)”在上下文中被理解为索引变量本身在概念上是无界的（以区分满和空状态），而其值通过模运算用于访问有限的缓冲区数组。这是标准做法，并不会使关于内存排序的核心逻辑失效。\n\n### 步骤 3：结论与行动\n\n问题陈述是 **有效的**。继续进行解决方案推导和选项分析。\n\n## 解决方案推导\n\n这个问题的核心是，一个核心（生产者）执行的内存操作以何种顺序对另一个核心（消费者）可见。问题指出，系统“允许编译器和...CPU对不同地址的操作进行重排序”。生产者对两个不同的地址执行两个关键的写入操作：\n1. 数据写入：`store(buf[idx], data)`\n2. 索引写入（发布）：`store(head, new_head)`\n\n在生产者的程序中，这两个操作是按此顺序排列的。然而，由于它们是针对不同的内存位置（$buf[idx]$ 和 $head$），并且没有明确的内存排序约束（内存屏障），弱序架构允许第二个存储操作——对 $head$ 的更新——在第一个存储操作——对缓冲槽的写入——可见之前，就对消费者的核心可见。\n\n让我们追踪给定的具体场景：$N=2$，$head=0$，$tail=0$，并且 $buf[\\,0\\,]$ 包含一个陈旧值 $u$。\n\n1.  **核心1上的生产者**：打算将一个新值（比如 $v$）入队到缓冲区。\n    - 缓冲区未满，因为 $head - tail = 0  2$。\n    - 它计算索引：$head \\bmod N = 0 \\bmod 2 = 0$。\n    - 按程序顺序，它执行：\n        a. `store(buf[0], v)`\n        b. `store(head, 1)`（使用松散原子操作）\n2.  **核心2上的消费者**：并发地检查新项目。\n    - 它加载 $head$ 的值：`h = load(head)`（使用松散原子操作）。\n3.  **竞争条件**：由于内存重排序，对 $head$ 的更改（从 $0$ 变为 $1$）可能会在写入 $buf[\\,0\\,]$ 的新数据 $v$ 之前，通过内存系统传播并对核心2可见。\n    - 消费者看到 $h=1$。\n    - 它将此值与其本地的 $tail=0$ 进行比较。由于 $h \\ne tail$，它断定有一个项目可供读取。\n    - 它计算读取索引：$tail \\bmod N = 0 \\bmod 2 = 0$。\n    - 它继续从 $buf[\\,0\\,]$ 读取：`data = load(buf[0])`。\n    - 因为生产者对 $buf[\\,0\\,]$ 写入 $v$ 的操作尚未对核心2可见，消费者的加载操作将获取其缓存中当前可见的值，即陈旧值 $u$。这是一个“陈旧读取”缺陷。\n\n回绕时问题是相同的。在生产和消费两个项目后，我们可能有 $head=tail=2$。然后生产者写入 $buf[\\,2 \\bmod 2\\,]$（即 $buf[\\,0\\,]$），并更新 $head$ 为 $3$。同样的重排序可能导致消费者看到 $head=3$，但读到的却是 $buf[\\,0\\,]$ 的旧内容，而不是新内容。\n\n**修正方法**：为防止这种情况，我们必须强制实施一种排序。必须保证生产者对缓冲槽的写入在消费者从该槽读取之前对消费者可见。同步是通过 $head$ 索引实现的。\n\n- 生产者必须确保其所有的先前写入（特别是对 $buf[\\cdot]$ 的写入）在它对 $head$ 的写入变得可见之前完成并可见。这正是**具有释放语义的存储**的定义。该操作应为 `store_release(head, new_head)`。\n\n- 消费者在看到 $head$ 的新值后，必须确保它能看到所有保证在生产者的释放存储之前发生的内存写入。这正是**具有获取语义的加载**的定义。该操作应为 `h = load_acquire(head)`。\n\n在 $head$ 变量上的这种 `release-acquire` 配对建立了一个“先行发生”（happens-before）关系。生产者对 $buf[\\,0\\,]$ 的写入 *先行发生于* 它对 $head$ 的释放存储。消费者的对 $head$ 的获取加载 *先行发生于* 它随后对 $buf[\\,0\\,]$ 的加载。在 $head$ 上的同步确保了当消费者尝试读取缓冲区时，生产者对缓冲区的写入已对消费者的核心可见。\n\n## 逐项分析\n\n**A. 因为只有一个生产者和一个消费者，并且缓存一致性保留了单线程内的程序顺序，所以即使使用松散原子操作，消费者也不会读到陈旧数据；因此不需要额外的内存排序。**\n\n- **分析**：这是错误的。虽然SPSC通过确保索引仅由一个线程写入来简化了逻辑，但这并不能消除内存排序的要求。缓存一致性保证了对*单个*位置写入的总顺序，而不是跨不同位置的。 “单线程内的程序顺序”是对执行线程本身的保证，而不是保证其写入操作对其他线程可见的顺序。核心问题是，对 $buf[\\cdot]$ 和 $head$ 这两个不同内存位置的写入存在被重排序的可能性。\n- **结论**：不正确。\n\n**B. 如果没有生产者对 $head$ 的释放存储和消费者对 $head$ 的获取加载，消费者有可能在生产者对 $buf[\\,0\\,]$ 的写入变得可见之前，就观察到 $head$ 已经增加（表示回绕后 $buf[\\,0\\,]$ 中有一个项目），从而导致消费者读到陈旧的旧值 $u$。将生产者的 $head$ 更新操作设为释放存储，并将消费者的 $head$ 读取操作设为获取加载，会引入一个先行发生（happens-before）边，从而防止这种陈旧读取。**\n\n- **分析**：这个陈述正确地指出了竞争条件——`head` 的更新在数据写入之前变得可见——并基于提供的公理给出了正确的解决方案。生产者对 $head$ 的释放存储以正确的顺序发布了数据和新索引。消费者对 $head$ 的获取加载确保了它在继续执行前能观察到生产者的先前写入。这建立了必要的 `先行发生` 关系。描述中读到陈旧值 $u$ 是这种竞争的直接后果。\n- **结论**：正确。\n\n**C. 风险完全来自回绕时的模运算；使用 $i := head \\bmod N$ 且 $N=2$ 会导致地址别名。解决方法是保持所有操作为松散排序，但将索引计算更改为 $i := head \\bmod (N-1)$，这样回绕就永远不会指向同一个槽。**\n\n- **分析**：这错误地诊断了问题。地址“别名”正是环形缓冲区的全部意义所在——重用一组固定的槽。问题不在于索引算术，而在于内存可见性顺序。此外，所提出的修复方案是无稽之谈。对于 $N=2$，将索引计算为 $head \\bmod (N-1)$ 会变成 $head \\bmod 1$，结果永远是 $0$。这意味着只有 $buf[\\,0\\,]$ 会被使用，实际上把缓冲区变成了一个单槽缓冲区，并没有解决内存排序问题。\n- **结论**：不正确。\n\n**D. 使用2的幂次容量并通过 $i := head \\, \\ \\, (N-1)$ 进行掩码操作，可以将索引与缓存行对齐，从而消除陈旧读取，因此只要 $head$ 和 $tail$ 是原子的，就不需要特定的内存排序。**\n\n- **分析**：使用2的幂次容量和位掩码是模运算的性能优化。将数据与缓存行对齐有助于防止“伪共享”并提高性能。然而，这两种技术都不能强制内存排序。CPU 仍然可以自由地重排序对 $head$ 和缓冲槽这两个不同内存位置的写入的可见性。问题在于硬件级别的指令重排序，而不是缓存对齐或算术效率。\n- **结论**：不正确。\n\n**E. 不使用 $head$ 进行排序，而是将消费者的 $tail$ 加载设为获取操作，并将生产者的 $tail$ 存储设为释放操作就足够了，因为 $tail$ 和 $head$ 是仅有的共享索引，并且至少有一个会被排序。**\n\n- **分析**：这个提议在错误的变量上以错误的方向进行同步排序。消费者是 $tail$ 的唯一写入者，所以对 $tail$ 的 `store_release` 操作会存在于消费者的代码中。生产者只读取 $tail$（以检查缓冲区是否已满）。因此，在 $tail$ 上的 `release-acquire` 对将同步从消费者到生产者的内存操作。这对于确保生产者拥有关于可用空间的最新视图是有用的，但它完全没有解决主要的数据流问题，即确保消费者能看到生产者的数据。数据从生产者流向消费者，因此同步必须在一个由生产者写入、消费者读取的变量上进行排序，这个变量就是 $head$。\n- **结论**：不正确。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在设计共享内存并发系统时，锁的粒度是一个关键的权衡点。使用单一的全局锁虽然简单，但容易成为性能瓶颈；而将数据分区并使用多个细粒度锁可以减少竞争，但会引入额外的管理开销。本练习构建了一个数学模型来量化这种权衡，帮助你通过分析竞争等待时间与锁管理开销之间的关系，找到最优的分区数量，从而在实际工程中做出更明智的设计决策。",
            "id": "3650193",
            "problem": "一个多核程序使用共享内存区域来协调 $n$ 个线程的工作。为避免单个全局锁引起的高竞争，该区域可以被划分为 $s$ 个大小相等的部分，每个部分由其自己的锁来保护。每个操作都会均匀随机地映射到恰好一个部分（例如，通过将键哈希到部分索引），获取该部分的锁，执行一个恒定时间的临界更新，然后释放锁。假设在稳定工作负载下，以下经验测量和理论推导的事实成立：\n\n- 当使用单个锁时（即 $s=1$），每次操作纯粹因等待锁而产生的预期额外时间（不包括恒定时间的临界工作和其他无关成本）为 $\\gamma$ （时间单位）。这个 $\\gamma$ 捕捉了当前工作负载下到达率、服务时间和调度器行为的综合影响。\n- 当共享区域被划分为 $s$ 个独立的、等概率的部分，并且操作到部分的映射是均匀且独立的时，每次操作由竞争引起的等待时间与 $s$ 成反比，因为竞争被均匀地分配到 $s$ 个独立的锁上。\n- 更多的锁会因更大的锁数组和缓存效应而产生每次操作的锁管理开销。此开销随部分数量线性增长，测得的边际成本为每个部分每次操作 $h$（时间单位）。因此，将 $s$ 增加 1 会使每次操作的预期锁管理开销增加 $h$。\n\n仅根据上述事实和独立预期成本的标准可加性，将每次操作用于同步（等待时间加上锁管理开销）的预期时间建模为 $s$、$\\gamma$ 和 $h$ 的函数。将 $s$ 视为一个正实数变量，并忽略任何不依赖于 $s$ 的常数项。推导出使该预期同步时间最小化的 $s$ 值。\n\n以 $\\gamma$ 和 $h$ 的单个封闭形式解析表达式给出你的最终答案。无需四舍五入。$s$ 是无量纲的；不要在最终表达式中包含单位。",
            "solution": "问题要求我们将每次操作的预期同步时间建模为分区数量 $s$ 的函数，然后找出使该时间最小化的 $s$ 值。令 $T(s)$ 表示每次操作的总预期同步时间。问题指出，该时间由两个部分组成：一个是由竞争引起的等待时间，我们将其表示为 $W(s)$；另一个是锁管理开销，表示为 $O(s)$。\n\n总同步时间是这两个部分之和：\n$$T(s) = W(s) + O(s)$$\n\n首先，我们必须确定 $W(s)$ 的函数形式。问题指出，“每次操作由竞争引起的等待时间与 $s$ 成反比”。这种关系可以用数学方式表示为 $W(s) = \\frac{k}{s}$，其中 $k$ 是一个比例常数。我们还得知条件“当使用单个锁时（即 $s=1$），每次操作纯粹因等待锁而产生的预期额外时间……为 $\\gamma$”。这使我们能够确定常数 $k$。在我们的 $W(s)$ 模型中设置 $s=1$，得到 $W(1) = \\frac{k}{1} = k$。由于给定 $W(1) = \\gamma$，因此 $k = \\gamma$。因此，由竞争引起的等待时间由以下公式给出：\n$$W(s) = \\frac{\\gamma}{s}$$\n\n接下来，我们确定 $O(s)$ 的函数形式。问题指出，“每次操作的锁管理开销……随部分数量线性增长，测得的边际成本为每个部分每次操作 $h$……”。边际成本为 $h$ 的线性增长意味着依赖于 $s$ 的开销部分由函数 $O(s) = h \\cdot s$ 给出。“忽略任何不依赖于 $s$ 的常数项”的指令验证了这个模型，因为我们只关心随 $s$ 变化的项，以找到 $s$ 的最优值。因此，我们有：\n$$O(s) = h \\cdot s$$\n\n结合这两个部分，我们得到总预期同步时间作为 $s$ 的函数：\n$$T(s) = \\frac{\\gamma}{s} + h \\cdot s$$\n\n为了找到使 $T(s)$ 最小化的 $s$ 值，我们可以使用微积分，按规定将 $s$ 视为一个正实数变量。我们计算 $T(s)$ 关于 $s$ 的一阶导数，并将其设为零以找到临界点。\n\n$T(s)$ 的导数是：\n$$\\frac{dT}{ds} = \\frac{d}{ds} \\left( \\frac{\\gamma}{s} + h \\cdot s \\right) = \\frac{d}{ds}(\\gamma s^{-1}) + \\frac{d}{ds}(hs)$$\n$$\\frac{dT}{ds} = -\\gamma s^{-2} + h = -\\frac{\\gamma}{s^2} + h$$\n\n将导数设为零，得到最小值的条件：\n$$-\\frac{\\gamma}{s^2} + h = 0$$\n$$h = \\frac{\\gamma}{s^2}$$\n\n现在我们可以解出 $s$。由于 $s$ 必须是正数（它代表部分的数量），我们可以按如下方式重新排列方程：\n$$s^2 = \\frac{\\gamma}{h}$$\n取正平方根得到 $s$ 的最优值：\n$$s = \\sqrt{\\frac{\\gamma}{h}}$$\n参数 $\\gamma$ 和 $h$ 是时间成本，因此它们是正实数。它们的比率是一个正的无量纲量，所以其平方根是一个定义明确的正实数。\n\n为了验证这个临界点对应于一个最小值，我们检查 $T(s)$ 的二阶导数：\n$$\\frac{d^2T}{ds^2} = \\frac{d}{ds} \\left( -\\frac{\\gamma}{s^2} + h \\right) = \\frac{d}{ds}(-\\gamma s^{-2})$$\n$$\\frac{d^2T}{ds^2} = -(-2)\\gamma s^{-3} = \\frac{2\\gamma}{s^3}$$\n\n鉴于 $\\gamma > 0$（一个等待时间）并且我们考虑的是 $s > 0$（部分的数量），二阶导数 $\\frac{d^2T}{ds^2}$ 在所有感兴趣的定义域内的 $s$ 值上都严格为正。正的二阶导数表明函数 $T(s)$ 对于 $s > 0$ 是严格凸的，这证实了我们找到的 $s$ 值对应于一个唯一的全局最小值。",
            "answer": "$$\\boxed{\\sqrt{\\frac{\\gamma}{h}}}$$"
        }
    ]
}