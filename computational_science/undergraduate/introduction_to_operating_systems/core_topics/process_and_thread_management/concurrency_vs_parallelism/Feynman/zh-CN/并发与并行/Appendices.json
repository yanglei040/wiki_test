{
    "hands_on_practices": [
        {
            "introduction": "即使我们拥有几乎无限的计算核心，也并非所有程序都能实现无限的加速。这个实践将引导你使用阿姆达尔定律（Amdahl's Law），一个量化并行计算潜力的基本法则。通过分析一个包含串行关键部分的场景，你将亲手计算并理解，即使存在大量并发线程，一个看似很小的串行部分也会如何成为性能瓶颈，严重限制并行化带来的实际收益 。",
            "id": "3626997",
            "problem": "一个服务器应用程序在操作系统（OS）调度程序下运行在一个多核中央处理器（CPU）上。该应用程序产生 $N$ 个工作线程来处理客户端请求。每个请求包括两个阶段：一个不访问任何共享状态的本地计算阶段，以及一个更新由互斥锁保护的共享日志的临界区。由于锁一次只允许一个线程执行临界区，因此即使存在许多可运行的线程，临界区本质上也是串行的。假设操作系统调度程序在 $N$ 个线程之间产生大量交错，因此并发性（交错）很高，但临界区主导了请求时间。\n\n假设在单核上测得的每个请求的时间如下：本地计算阶段耗时 $c = 3$ 毫秒，临界区耗时 $s = 7$ 毫秒。假设本地计算阶段在 $M$ 个相同核心上具有理想的并行扩展性，除了临界区本身的串行化之外没有其他同步开销，并且临界区不会因核心增多而受益。\n\n从加速比 $S(M)$ 是 $T(1)/T(M)$ 的比率，单核执行时间的可并行化部分 $p$ 是可以在多个核心上并发运行的工作部分，而串行部分 $1 - p$ 不会随着核心增多而加速这些基本定义出发，推导出 $S(M)$ 关于 $p$ 和 $M$ 的表达式。然后，根据 $c$ 和 $s$ 计算此工作负载的可并行化部分 $p$，并评估当 $M \\in \\{1, 2, 8\\}$ 时的加速比。将您的最终答案表示为一个行矩阵，其中包含对应于 $M = 1$、$M = 2$ 和 $M = 8$ 的三个加速比。在您的最终数值中不要包含任何单位。",
            "solution": "该问题要求推导被称为阿姆达尔定律的加速比公式，并将其应用于多核处理器上的特定工作负载。\n\n首先，我们进行问题验证。\n\n**步骤1：提取已知条件**\n- 应用程序产生 $N$ 个工作线程。\n- 每个请求有一个本地计算阶段和一个临界区阶段。\n- 临界区由互斥锁保护，使其本质上是串行的。\n- 单核上每个请求的本地计算时间：$c = 3$ 毫秒。\n- 单核上每个请求的临界区时间：$s = 7$ 毫秒。\n- 假设本地计算阶段在 $M$ 个核心上具有理想的并行扩展性。\n- 临界区不会因核心增多而受益。\n- 除了串行化之外没有同步开销。\n- 加速比定义：$S(M) = T(1)/T(M)$，其中 $T(M)$ 是在 $M$ 个核心上的执行时间。\n- 单核执行时间的可并行化部分：$p$。\n- 单核执行时间的串行部分：$1-p$。\n- 任务：推导 $S(M)$ 关于 $p$ 和 $M$ 的表达式。\n- 任务：根据 $c$ 和 $s$ 计算 $p$。\n- 任务：评估当 $M \\in \\{1, 2, 8\\}$ 时的 $S(M)$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是阿姆达尔定律的经典应用，阿姆达尔定律是并行计算中的一个基本原则，用于预测使用多个处理器时的理论加速比。所有概念（临界区、可并行化部分、加速比）在计算机科学和操作系统中都是标准概念。\n- **问题定义明确**：问题提供了所有必要的定义和数据（$c$, $s$），以推导公式并计算所需值。目标陈述清晰。存在唯一解。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观或含糊不清的术语。\n\n该问题是有效的，因为它是科学合理的、定义明确的并且是客观的。我们可以继续进行求解。\n\n**加速比 $S(M)$ 的推导**\n\n设 $T(1)$ 为任务在单个处理器核心上的总执行时间。这个总时间可以分为一个无法并行的串行部分和一个可并行的部分。\n\n串行部分被给定为 $1-p$。因此，在串行部分上花费的时间是 $(1-p)T(1)$。这个时间与核心数量 $M$ 无关，是恒定的。\n\n可并行化部分被给定为 $p$。在单核上，可并行化部分花费的时间是 $pT(1)$。在理想的并行扩展下，这项工作可以分布在 $M$ 个核心上，将这部分的时间减少到 $\\frac{pT(1)}{M}$。\n\n在 $M$ 个核心上的总执行时间 $T(M)$ 是串行部分时间和并行化部分时间之和：\n$$T(M) = (1-p)T(1) + \\frac{pT(1)}{M}$$\n我们可以提出公因子 $T(1)$：\n$$T(M) = T(1) \\left( (1-p) + \\frac{p}{M} \\right)$$\n加速比 $S(M)$ 定义为单核执行时间与多核执行时间之比：\n$$S(M) = \\frac{T(1)}{T(M)}$$\n代入 $T(M)$ 的表达式：\n$$S(M) = \\frac{T(1)}{T(1) \\left( (1-p) + \\frac{p}{M} \\right)}$$\n$$S(M) = \\frac{1}{(1-p) + \\frac{p}{M}}$$\n这就是关于可并行化部分 $p$ 和处理器数量 $M$ 的通用加速比表达式，即著名的阿姆达尔定律。\n\n**可并行化部分 $p$ 的计算**\n\n对于给定的工作负载，单核上单个请求的总执行时间 $T(1)$ 是本地计算时间 $c$ 和临界区时间 $s$ 的和。\n$$T(1) = c + s$$\n本地计算是可以并行运行的工作部分。因此，其持续时间 $c$ 对应于单核执行时间的可并行化部分。临界区本质上是串行的，因此其持续时间 $s$ 对应于串行部分。\n\n可并行化部分 $p$ 是可并行化时间与总时间之比：\n$$p = \\frac{c}{c+s}$$\n代入给定值 $c=3$ 和 $s=7$：\n$$p = \\frac{3}{3+7} = \\frac{3}{10} = 0.3$$\n串行部分为 $1-p = 1 - 0.3 = 0.7$。这对应于 $\\frac{s}{c+s} = \\frac{7}{10} = 0.7$，是一致的。\n\n**对 $M \\in \\{1, 2, 8\\}$ 评估加速比**\n\n现在我们使用推导出的加速比公式，其中 $p=0.3$：\n$$S(M) = \\frac{1}{(1-0.3) + \\frac{0.3}{M}} = \\frac{1}{0.7 + \\frac{0.3}{M}}$$\n\n情况 1：$M=1$\n$$S(1) = \\frac{1}{0.7 + \\frac{0.3}{1}} = \\frac{1}{0.7 + 0.3} = \\frac{1}{1} = 1$$\n这是预期的基准加速比。\n\n情况 2：$M=2$\n$$S(2) = \\frac{1}{0.7 + \\frac{0.3}{2}} = \\frac{1}{0.7 + 0.15} = \\frac{1}{0.85}$$\n为了将其表示为精确分数：\n$$S(2) = \\frac{1}{\\frac{85}{100}} = \\frac{100}{85} = \\frac{20}{17}$$\n\n情况 3：$M=8$\n$$S(8) = \\frac{1}{0.7 + \\frac{0.3}{8}}$$\n为了将其表示为精确分数，我们将分母转换为共同的基数：\n$$0.7 = \\frac{7}{10} = \\frac{56}{80}$$\n$$\\frac{0.3}{8} = \\frac{\\frac{3}{10}}{8} = \\frac{3}{80}$$\n所以，分母是：\n$$\\frac{56}{80} + \\frac{3}{80} = \\frac{59}{80}$$\n因此，加速比是：\n$$S(8) = \\frac{1}{\\frac{59}{80}} = \\frac{80}{59}$$\n\n计算出的三个加速比值是 $S(1)=1$，$S(2)=\\frac{20}{17}$，和 $S(8)=\\frac{80}{59}$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 & \\frac{20}{17} & \\frac{80}{59} \\end{pmatrix}}$$"
        },
        {
            "introduction": "从理论限制转向一个非常实际的系统设计问题：如何为一个混合了计算和阻塞I/O任务的服务器设置最佳的线程池大小？线程数并非简单地等于CPU核心数。这个练习将引导你推导出一个线程池大小的设置规则，它需要同时满足两个目标：既要保证有足够的并发线程来处理等待I/O的任务以满足延迟要求，又要有效利用所有CPU核心的并行处理能力 。",
            "id": "3627021",
            "problem": "一台服务器使用一个固定大小的线程池来处理独立的客户端请求。每个请求在中央处理器（CPU）上的计算阶段和阻塞式输入/输出（I/O）等待之间交替进行。设 $C$ 为每个请求的平均 CPU 计算时间，$W$ 为每个请求的平均阻塞时间，其中 $C, W > 0$，并将每个线程建模为在计算（在核心上忙碌）和等待（因 I/O 而阻塞）之间循环。该机器有 $M$ 个相同的 CPU 核心可用于执行准备好计算的线程。请求以平均速率 $\\lambda$ （请求/秒）到达。系统操作员的目标是稳态平均响应时间不超过 $R^\\star$ 秒。线程池的大小为 $k$ 个线程。\n\n从第一性原理出发，提出了一个选择 $k$ 的规则，该规则同时满足：\n- 覆盖 I/O 延迟的并发性要求（以便有足够的请求在处理中，从而实现目标平均响应时间），以及\n- 由 $M$ 个核心施加的并行性限制（以便计算吞吐量不会受限，核心也不会因阻塞而空闲）。\n\n选择唯一的最佳选项。\n\nA. 选择 $k = \\lceil M \\rceil$。\n\nB. 选择 $k = \\left\\lceil M \\cdot \\left(1 + \\frac{W}{C}\\right) \\right\\rceil$。\n\nC. 选择 $k = \\left\\lceil \\max\\!\\left( M \\cdot \\left(1 + \\frac{W}{C}\\right),\\, \\lambda \\cdot R^\\star \\right) \\right\\rceil$。\n\nD. 选择 $k = \\left\\lceil \\lambda \\cdot (C + W) \\right\\rceil$。\n\nE. 选择 $k = \\left\\lceil \\frac{M}{1 + \\frac{W}{C}} \\right\\rceil$。",
            "solution": "用户希望我解决一个关于线程池大小设置的问题。\n\n### 步骤 1：验证问题陈述\n\n我将首先根据指示验证问题陈述。\n\n#### 提取已知条件\n- 一台服务器使用一个大小为 $k$ 的固定大小线程池。\n- 服务器处理独立的客户端请求。\n- 每个请求在计算阶段（CPU）和阻塞式输入/输出（I/O）等待之间交替进行。\n- $C$：每个请求的平均 CPU 计算时间，其中 $C > 0$。\n- $W$：每个请求的平均阻塞式 I/O 等待时间，其中 $W > 0$。\n- 系统有 $M$ 个相同的 CPU 核心。\n- $\\lambda$：请求的平均到达率（请求/秒）。\n- $R^\\star$：目标稳态平均响应时间（秒）。\n\n#### 使用提取的已知条件进行验证\n问题要求一个选择线程池大小 $k$ 的规则，以满足两个要求：\n1.  一个覆盖 I/O 延迟并满足响应时间目标的并发性要求。\n2.  一个有效利用 $M$ 个 CPU 核心的并行性限制。\n\n该问题陈述具有科学依据、提法恰当且客观。它描述了计算机系统性能建模中一个经典且基础的问题。参数（$C$、$W$、$M$、$\\lambda$、$R^\\star$）是排队论和系统分析中使用的标准指标。该模型使用 CPU 和 I/O 时间的平均值，是进行一阶分析时常用且有效的简化方法。问题不模棱两可、不自相矛盾，也不是基于错误的前提。它要求从第一性原理推导出一个规模设置的启发式方法，这是一项标准的工程任务。\n\n#### 结论\n问题陈述是**有效的**。我将继续进行推导和求解。\n\n### 步骤 2：从第一性原理推导\n\n问题要求一个确定线程池大小 $k$ 的规则，该规则要同时解决两个不同的约束：一个与硬件利用率（并行性）有关，另一个与服务水平目标（并发性）有关。\n\n**1. 并行性限制：使 CPU 核心饱和**\n\n第一个目标是选择 $k$ 以便让 $M$ 个 CPU 核心保持忙碌，而不是因为线程阻塞于 I/O 而空闲。\n- 让我们考虑单个线程。在其处理一个请求的一个完整周期中，它花费 $C$ 个时间单位处于可运行状态（计算或准备计算），花费 $W$ 个时间单位处于阻塞状态（等待 I/O）。\n- 一个周期的总时间是 $C+W$。\n- 线程处于可运行状态（即需要 CPU 核心）的时间比例是 $f_{cpu} = \\frac{C}{C+W}$。\n- 线程被 I/O 阻塞的时间比例是 $f_{io} = \\frac{W}{C+W}$。\n\n对于一个大小为 $k$ 的线程池，在任何给定时间处于可运行状态的平均线程数是 $k \\cdot f_{cpu} = k \\cdot \\frac{C}{C+W}$。\n为了完全饱和所有 $M$ 个核心，我们需要可运行线程的数量至少等于核心数 $M$。理想的目标点是可运行线程数恰好为 $M$。\n$$\nk \\cdot \\frac{C}{C+W} = M\n$$\n求解 $k$ 得到保持 CPU 饱和所需的线程数：\n$$\nk_{cpu} = M \\cdot \\frac{C+W}{C} = M \\cdot \\left(1 + \\frac{W}{C}\\right)\n$$\n这个公式，通常被称为基于利用率的规模设置规则，提供了为确保平均恰好有 $M$ 个线程准备好运行所需的线程数，从而使 $M$ 个核心得到充分利用。如果线程数少于此值，那么只要有超过 $k-M$ 个线程被阻塞，核心就会空闲。这个公式体现了并行性限制。\n\n**2. 并发性要求：满足响应时间目标**\n\n第二个目标是拥有足够的线程来处理传入的工作负载，并实现 $R^\\star$ 或更低的平均响应时间。\n- 这可以使用利特尔法则（Little's Law）进行分析，这是排队论中的一个基本定理，它指出：一个稳定系统中客户的长期平均数量 $L$，等于长期平均有效到达率 $\\lambda$ 乘以客户在系统中花费的平均时间 $R$。\n$$\nL = \\lambda \\cdot R\n$$\n- 在我们的情境中，“客户”就是客户端请求。“系统”就是服务器。请求在系统中花费的时间是其响应时间。\n- 系统必须支持 $\\lambda$ 的到达率，并旨在达到 $R^\\star$ 的平均响应时间。\n- 应用利特尔法则，为满足此目标，系统中并发请求的平均数量为：\n$$\nL^\\star = \\lambda \\cdot R^\\star\n$$\n- 每个“在处理中”（由服务器处理）的请求都需要线程池中的一个线程。因此，为了支持平均 $L^\\star$ 个并发请求，线程池必须至少有那么多线程。\n$$\nk_{latency} \\ge \\lambda \\cdot R^\\star\n$$\n这个公式体现了由服务水平目标驱动的并发性要求。\n\n**3. 结合两项要求**\n\n问题要求一个*同时*满足两个要求的单一规则。线程池必须足够大，以满足两个约束中更严格的一个。\n- 它必须足够大以保持 CPU 忙碌：$k \\ge M \\cdot \\left(1 + \\frac{W}{C}\\right)$。\n- 它必须足够大以支持延迟目标所需的并发性：$k \\ge \\lambda \\cdot R^\\star$。\n\n为了同时满足这两个条件，$k$ 必须大于或等于这两个要求值的最大值：\n$$\nk \\ge \\max\\left( M \\cdot \\left(1 + \\frac{W}{C}\\right),\\, \\lambda \\cdot R^\\star \\right)\n$$\n由于线程池大小 $k$ 必须是一个整数，满足此条件的最小整数值是该表达式的向上取整。\n$$\nk = \\left\\lceil \\max\\left( M \\cdot \\left(1 + \\frac{W}{C}\\right),\\, \\lambda \\cdot R^\\star \\right) \\right\\rceil\n$$\n这个复合规则确保系统被配置为既能处理硬件级的并行性目标，也能处理应用级的并发性目标。\n\n### 步骤 3：逐项分析选项\n\n现在，我将根据推导出的原理解释每个选项。\n\n**A. 选择 $k = \\lceil M \\rceil$。**\n由于 $M$（核心数）是一个整数，这可以简化为 $k=M$。该规则将线程数设置为等于可用核心数。这仅对纯 CPU 密集型（即 $W=0$）的工作负载是合适的策略。对于给定的问题，其中请求有阻塞式 I/O 等待（$W > 0$），如果所有 $M$ 个线程同时阻塞在 I/O 上，CPU 核心将变为空闲。这未能满足保持核心忙碌的要求。因此，此选项不充分。\n**结论：不正确。**\n\n**B. 选择 $k = \\left\\lceil M \\cdot \\left(1 + \\frac{W}{C}\\right) \\right\\rceil$。**\n此公式与我们为保持 $M$ 个核心饱和而推导出的 $k_{cpu}$ 完全对应。它正确地解决了并行性限制。但是，它完全忽略了关于到达率 $\\lambda$ 和目标响应时间 $R^\\star$ 的第二个要求。如果满足服务目标所需的并发水平 $\\lambda \\cdot R^\\star$ 显著大于 $M \\cdot (1 + W/C)$，此规则将导致线程池过小，使得请求在分配到线程前被拒绝或排队等待过长时间，从而无法满足响应时间目标。由于它只满足了两个要求中的一个，因此它是不完整的。\n**结论：不正确。**\n\n**C. 选择 $k = \\left\\lceil \\max\\!\\left( M \\cdot \\left(1 + \\frac{W}{C}\\right),\\, \\lambda \\cdot R^\\star \\right) \\right\\rceil$。**\n这个公式包含了我们从第一性原理推导出的两个下界。项 $M \\cdot (1 + W/C)$ 确保线程池足够大以保持硬件被充分利用。项 $\\lambda \\cdot R^\\star$ 确保线程池足够大以支持满足性能目标所需的并发请求数。通过取这两个项的最大值，该规则保证了所选的池大小 $k$ 足以同时满足以硬件为中心的要求和以服务水平为中心的要求。这个规则稳健地同时体现了问题的两个方面。\n**结论：正确。**\n\n**D. 选择 $k = \\left\\lceil \\lambda \\cdot (C + W) \\right\\rceil$。**\n项 $C+W$ 表示一个请求的总理想服务时间，不包括任何排队延迟。表达式 $\\lambda \\cdot (C+W)$ 是应用利特尔法则来计算当响应时间恰好等于服务时间时系统中的请求数。这是系统提交负载的定义。虽然这个值与所需的并发性有关，但它完全忽略了核心数 $M$，未能解决并行性限制。此外，它假设目标响应时间 $R^\\star$ 等于理想服务时间 $C+W$，这通常是不成立的，因为 $R^\\star$ 通常必须考虑排队延迟。\n**结论：不正确。**\n\n**E. 选择 $k = \\left\\lceil \\frac{M}{1 + \\frac{W}{C}} \\right\\rceil$。**\n这个公式可以重写为 $k = \\lceil M \\cdot \\frac{C}{C+W} \\rceil$。由于 $C, W > 0$，分数 $\\frac{C}{C+W}$ 总是小于 1。因此，此规则会建议一个大小为 $k \\le M$ 的线程池。如果线程数少于核心数，就不可能完全利用所有 $M$ 个核心。这直接与使 CPU 饱和的目标相矛盾，并且在概念上与处理 I/O 密集型任务的正确逻辑相反。\n**结论：不正确。**",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "让我们来做一个诊断挑战。在软件开发中，我们常常遇到一个令人困惑的现象：增加了线程和CPU核心，性能却毫无提升。这个思想实验将帮助你运用前面学到的概念，诊断出这种无效并行背后的根本原因——由于共享资源（如一个全局锁）的争用，导致执行被串行化，从而抵消了并行处理的优势 。",
            "id": "3627024",
            "problem": "一个软件团队在一台具有2个相同中央处理器（CPU）核心的双核机器上，在单个应用程序中运行两个独立的数据处理任务，任务 $T_1$ 和任务 $T_2$。每个任务处理 $K$ 条记录，并使用一个包含 $N$ 个工作线程的线程池。处理每条记录按顺序包括两个步骤：首先，一个计算步骤，该步骤是完全可并行的，需要 $C$ 毫秒的纯CPU工作；其次，一个日志记录步骤，该步骤会调用一个共享的第三方库例程，该例程由单个进程范围的互斥锁（mutex）$M$ 保护，并且在持有锁 $M$ 的情况下需要 $L$ 毫秒的纯CPU工作。两个任务都链接到同一个库，因此在记录日志时会竞争同一个锁 $M$。假设 $C$ 远小于 $L$ (即, $C \\ll L$)，并且操作系统（OS）调度器在其他方面是公平且高效的。\n\n在实验中，当 $N$ 从 1 增加到更大的值（例如，$N=8$）时，在双核系统上同时完成两个任务的总挂钟时间与 $N=1$ 时大致相同。团队得出结论，并行性存在但无效。\n\n哪个选项能从第一性原理最好地解释这一观察结果，并预测将单个共享锁 $M$ 替换为两个不相交的锁（一个由任务 $T_1$ 专用，一个由任务 $T_2$ 专用）会产生什么效果？\n\nA. 线程实际上不是并行的：当存在互斥锁时，操作系统不能同时运行来自不同任务的线程。用两个锁替换共享锁没有帮助，因为互斥锁天生会阻止跨核心的并行。\n\nB. 存在并行性：来自不同线程的计算步骤可以在2个核心上同时执行，但单个共享锁 $M$ 使得每个日志记录步骤成为跨两个任务所有线程的单一串行资源。由于 $C \\ll L$，串行化的日志记录占主导地位，因此在2个核心上的加速效果消失了。为每个任务提供自己的锁可以消除跨任务的竞争，允许两个日志记录流并发进行，从而在双核上为较大的 $L$ 恢复近2倍的加速。\n\nC. 缺乏加速的主要原因是随 $N$ 增长的上下文切换开销。将所有线程固定到单个核心将减少上下文切换，并在双核上恢复近2倍的加速。\n\nD. 计算步骤使内存带宽饱和；互斥锁无法解释这种扩展性问题。用每个任务的锁替换共享锁不会改变性能，但升级到4个核心将保证近4倍的加速，即使单个共享锁仍然存在。",
            "solution": "### 步骤1：提取已知条件\n- 一台具有2个相同中央处理器（CPU）核心的双核机器。\n- 两个独立的数据处理任务，任务 $T_1$ 和任务 $T_2$。\n- 每个任务处理 $K$ 条记录。\n- 每个任务使用一个包含 $N$ 个工作线程的线程池。总线程数为 $2N$。\n- 处理单条记录涉及两个顺序步骤：\n    1.  一个持续时间为 $C$ 毫秒的计算步骤，该步骤是完全可并行的纯CPU工作。\n    2.  一个持续时间为 $L$ 毫秒的日志记录步骤，该步骤是纯CPU工作，并且需要获取单个进程范围的互斥锁（mutex）$M$。\n- 任务 $T_1$ 和任务 $T_2$ 都竞争同一个锁 $M$。\n- 给出了一个基本条件：$C \\ll L$。\n- 提供了一个实验观察结果：当 $N$ 从1增加到更大的值（例如，$N=8$）时，同时完成两个任务的总挂钟时间大致保持不变。\n- 问题要求解释这一观察结果，并预测将单个锁 $M$ 替换为每个任务一个的两个不相交的锁的效果。\n\n### 步骤2：使用提取的已知条件进行验证\n根据预定义的标准评估问题陈述。\n\n- **科学依据**：该问题很好地基于操作系统的基本原理，特别是并发、并行和像互斥锁这样的同步原语。所描述的场景是并行计算的核心概念 Amdahl 定律的经典例证。不存在科学或事实上的不健全之处。\n- **适定性**：问题定义清晰。系统（硬件、软件任务、工作负载）、约束（共享锁、计算与日志记录的相对成本）和观察结果都已明确。问题要求一个具体的解释和预测，可以从前提中推导出一个合乎逻辑的、唯一的解决方案。\n- **客观性**：语言精确客观，使用了标准的计算机科学术语。没有主观或含糊的陈述。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学或事实不健全**：无。该场景是一个标准的性能瓶颈问题。\n2.  **无法形式化或不相关**：无。该问题可以直接形式化，并且与其所述主题相关。\n3.  **不完整或矛盾的设置**：无。提供的信息是充分且一致的。条件 $C \\ll L$ 是分析的关键。\n4.  **不切实际或不可行**：无。这是一个在软件工程中非常现实的场景，其中共享的、缓慢的日志记录设施成为主要的性能瓶颈。\n5.  **不适定或结构不良**：无。存在一个独特概念上的解决方案。\n6.  **故作高深、琐碎或同义反复**：无。该问题需要正确应用第一性原理（Amdahl 定律）来诊断一个不明显的性能问题。\n7.  **超出科学可验证性**：无。这些原理是公认的，并且该场景是可测试的。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。继续进行解答。\n\n### 基于原理的推导\n\n分析基于 Amdahl 定律，该定律为在固定工作负载下，当系统资源得到改善时，任务执行延迟的理论加速比建模。\n\n让我们分析总工作量及其组成部分。\n-   需要处理的总记录数：$2K$（$T_1$ 和 $T_2$ 各 $K$ 条）。\n-   对于每条记录，有一个持续时间为 $C$ 的计算部分和一个持续时间为 $L$ 的日志记录部分。\n-   用于计算的总CPU工作量：$2K \\times C$。这项工作是“完全可并行的”。\n-   用于日志记录的总CPU工作量：$2K \\times L$。这项工作被单个进程范围的互斥锁 $M$ 串行化。在任何给定时刻，整个应用程序中只有一个线程可以执行日志记录步骤。\n\n**初始场景分析（单个共享锁 $M$）**\n\n完成任务的总时间受限于无法并行的那部分工作。\n工作负载的串行部分由所有的日志记录步骤组成。由于单个锁 $M$ 的存在，它们必须一个接一个地执行，所以这部分所需的最短时间是所有日志记录持续时间的总和：\n$$T_{serial} = 2K \\times L$$\n工作负载的并行部分由所有的计算步骤组成。总工作量是 $2K \\times C$。使用2个核心，这项工作理想情况下可以在以下时间内完成：\n$$T_{parallel} = \\frac{2K \\times C}{2} = K \\times C$$\n总挂钟时间 $T_{total}$ 取决于这两种类型的工作如何重叠。串行的日志记录工作构成了一个硬瓶颈。当一个核心忙于一个日志记录步骤（持续时间为 $L$）时，另一个核心可以执行计算步骤。由于给定 $C \\ll L$，一个日志记录步骤比一个计算步骤花费的时间长得多。在一个核心上执行一个持续时间为 $L$ 的日志记录步骤的时间内，另一个核心可以完成 $L/C$ 个计算步骤。考虑到大量的线程（$N > 1$），很有可能总会有一个线程准备好在空闲核心上进行计算步骤。然而，整体进度受到 $2K$ 个日志记录操作的串行执行的限制。\n总执行时间将由串行部分主导。总时间可以近似为串行瓶颈的时间加上任何无法隐藏在串行工作背后的并行工作的时间。\n一个简单而稳健的模型是将总时间近似看作所有串行步骤的总和：\n$$T_{total} \\approx T_{serial} = 2KL$$\n并行计算工作（总共 $2KC$）与串行日志记录工作（总共 $2KL$）相比很小，因为 $C \\ll L$。大部分计算工作可以在一个核心上执行，而另一个核心被日志记录步骤占用。因此，总时间绝大部分由串行日志记录队列主导。\n\n这个模型解释了观察结果：将线程数 $N$ 从1增加到8并不会减少总时间。当 $N \\ge 1$ 时，我们总共已经至少有2个线程（每个任务一个）。只要活动线程数至少与核心数一样多（即 $2N \\ge 2$），增加更多线程只会增加等待单个锁 $M$ 的线程数量。它不会减少串行瓶颈的长度，该瓶颈仍然是 $2KL$。执行时间大致保持不变，受此瓶颈限制。\n\n**提议变更的分析（两个不相交的锁）**\n\n该变更涉及将单个锁 $M$ 替换为两个锁：$M_1$ 专用于任务 $T_1$，$M_2$ 专用于任务 $T_2$。\n-   任务 $T_1$ 的 $N$ 个线程现在只竞争锁 $M_1$。$T_1$ 的 $K$ 个日志记录步骤彼此之间是串行化的。\n-   任务 $T_2$ 的 $N$ 个线程现在只竞争锁 $M_2$。$T_2$ 的 $K$ 个日志记录步骤彼此之间是串行化的。\n\n关键在于，一个来自 $T_1$ 的线程持有 $M_1$ 并不会阻止一个来自 $T_2$ 的线程持有 $M_2$。由于机器有2个核心，一个核心可以执行 $T_1$ 的日志记录步骤，而另一个核心可以并行地执行 $T_2$ 的日志记录步骤。\n这两个任务现在实际上是独立的，可以在两个核心上并行运行。总挂钟时间将是两个任务中较长者所花费的时间。由于它们是相同的，我们只需要分析一个。\n对于在其“自己的”核心上运行的任务 $T_1$，总工作量是 $K$ 条记录，每条记录耗时 $C+L$。日志记录部分是串行的，总共耗时 $KL$。计算部分是可并行的，但由于它们都在一个有效的执行流上运行（受其自己的锁的瓶颈限制），任务 $T_1$ 的总时间将大约是其所有工作的总和：\n$$T'_{T_1} \\approx K \\times C + K \\times L = K(C+L)$$\n任务 $T_2$ 也类似：\n$$T'_{T_2} \\approx K(C+L)$$\n由于两个任务在2个核心上并行运行，新的总挂钟时间 $T'_{total}$ 是：\n$$T'_{total} = \\max(T'_{T_1}, T'_{T_2}) \\approx K(C+L)$$\n给定条件 $C \\ll L$，我们可以将其近似为：\n$$T'_{total} \\approx KL$$\n让我们计算加速比：\n$$Speedup = \\frac{T_{total}}{T'_{total}} \\approx \\frac{2KL}{KL} = 2$$\n因此，预计将单个共享锁替换为两个按任务分配的锁将在双核系统上提供大约2倍的加速。\n\n### 逐项分析\n\n-   **A. 线程实际上不是并行的：当存在互斥锁时，操作系统不能同时运行来自不同任务的线程。用两个锁替换共享锁没有帮助，因为互斥锁天生会阻止跨核心的并行。**\n    这个陈述包含多个谬误。首先，计算步骤*是*并行的。其次，即使其中一个线程持有互斥锁，操作系统也绝对可以在不同的核心上运行线程；互斥锁只阻止多个线程进入*同一个*临界区。第三，为不同的数据流使用不同的锁是*增加*并行度的标准技术。\n    **结论：不正确。**\n\n-   **B. 存在并行性：来自不同线程的计算步骤可以在2个核心上同时执行，但单个共享锁 $M$ 使得每个日志记录步骤成为跨两个任务所有线程的单一串行资源。由于 $C \\ll L$，串行化的日志记录占主导地位，因此在2个核心上的加速效果消失了。为每个任务提供自己的锁可以消除跨任务的竞争，允许两个日志记录流并发进行，从而在双核上为较大的 $L$ 恢复近2倍的加速。**\n    这个陈述正确地指出了计算步骤中存在并行性。它正确地诊断了问题：在持续时间长的日志记录步骤（$L$）上的单个锁 $M$ 创建了一个串行瓶颈，根据 Amdahl 定律，这个瓶颈主导了总执行时间，从而抵消了多核的好处。它正确地预测了两个不相交的锁将使两个任务互相解脱，允许它们的日志记录流在两个核心上并行运行，这将导致接近2倍的加速。这与我们的推导完全吻合。\n    **结论：正确。**\n\n-   **C. 缺乏加速的主要原因是随 $N$ 增长的上下文切换开销。将所有线程固定到单个核心将减少上下文切换，并在双核上恢复近2倍的加速。**\n    虽然上下文切换开销是真实存在的，但这里的瓶颈主要原因是由锁引起的串行化，这一点由条件 $C \\ll L$ 确定。将所有线程固定到单个核心的建议是适得其反的；它将完全消除任何并行性的可能性，并会显著减慢执行速度，使得在双核机器上不可能实现2倍的加速。\n    **结论：不正确。**\n\n-   **D. 计算步骤使内存带宽饱和；互斥锁无法解释这种扩展性问题。用每个任务的锁替换共享锁不会改变性能，但升级到4个核心将保证近4倍的加速，即使单个共享锁仍然存在。**\n    这个选项对内存带宽提出了一个没有依据的说法。一个保护长临界区的互斥锁是导致扩展性差的典型原因。预测替换锁没有帮助是错误的，正如我们的分析所示。预测在保留单个串行锁的情况下升级到4个核心将产生4倍加速是根本错误的。如果进程被一个串行部分瓶颈，增加更多核心会产生递减的回报，在这种极端情况下，几乎不会提供任何加速。\n    **结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}