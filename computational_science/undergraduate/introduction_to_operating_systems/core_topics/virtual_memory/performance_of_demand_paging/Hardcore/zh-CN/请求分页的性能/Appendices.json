{
    "hands_on_practices": [
        {
            "introduction": "在理论上学习了有效内存访问时间（EAT）的计算方法后，将其应用于实际硬件性能分析是至关重要的一步。本练习将引导你量化分析使用固态硬盘（SSD）与传统机械硬盘（HDD）作为后备存储时，系统性能的差异。通过这个实践，你不仅能计算出平均性能的提升，还能从根本上理解为什么SSD能够提供更稳定、更可预测的性能，即更低的访问时间方差和尾延迟。",
            "id": "3668900",
            "problem": "一个进程在工作站上使用请求分页和单级页表，该工作站的主存访问时间为 $t_{m} = 0.1 \\,\\mu \\text{s}$。每次内存引用时，发生缺页的概率为 $p = 2 \\times 10^{-4}$。当发生缺页时，操作系统陷入内核，更新页表，调度读取缺失的页，并恢复进程。处理此过程的输入/输出之外的处理器开销为 $t_{\\text{os}} = 25 \\,\\mu \\text{s}$。\n\n后备存储是固态硬盘（SSD）或机械硬盘（HDD）。对于每次缺页，存储服务时间包括固定的控制器延迟和页的顺序传输时间。将存储延迟建模为随机变量 $L$，其均值为 $\\mathbb{E}[L]$，方差为 $\\operatorname{Var}(L)$；页面传输时间由 $t_{x} = S / B$ 给出，其中 $S$ 是页面大小，$B$ 是持续读取带宽。页面大小为 $S = 4096 \\text{ 字节}$。假设对于 SSD，$\\mathbb{E}[L_{\\text{SSD}}] = 100 \\,\\mu \\text{s}$ 且 $\\operatorname{Var}(L_{\\text{SSD}}) = (20 \\,\\mu \\text{s})^{2}$，持续带宽为 $B_{\\text{SSD}} = 500 \\times 10^{6} \\text{ 字节/秒}$。假设对于 HDD，$\\mathbb{E}[L_{\\text{HDD}}] = 6000 \\,\\mu \\text{s}$ 且 $\\operatorname{Var}(L_{\\text{HDD}}) = (3000 \\,\\mu \\text{s})^{2}$，持续带宽为 $B_{\\text{HDD}} = 150 \\times 10^{6} \\text{ 字节/秒}$。\n\n仅使用伯努利混合结果（无缺页与缺页）的期望值定义和上述参数，推导在 SSD 和 HDD 下的有效访问时间（EAT）的表达式。然后计算差值 $\\Delta EAT = EAT_{\\text{HDD}} - EAT_{\\text{SSD}}$，作为一个实数。最后，从方差和尾部概率的第一性原理出发，定性地论证为什么相对于 HDD，SSD 后备存储既降低了访问时间的方差，也降低了缺页的尾延迟。\n\n以 $\\mu \\text{s}$ 为单位表示 $\\Delta EAT$ 的最终数值，并将答案四舍五入到四位有效数字。",
            "solution": "本问题要求推导有效访问时间（EAT）的表达式，计算使用机械硬盘（HDD）和固态硬盘（SSD）作为后备存储时 EAT 的差值，并对 SSD 在访问时间方差和尾延迟方面的性能优势进行定性论证。\n\n首先，我们建立有效访问时间的模型。一次内存引用会产生两种结果之一：如果页面在主存中，则访问成功（事件概率为 $1-p$）；如果不在，则发生缺页（事件概率为 $p$）。EAT 是访问时间在此伯努利分布结果下的期望值。\n\n设 $T_{hit}$ 为页面在内存中时的内存访问时间，设 $T_{fault}$ 为处理一次缺页的时间。问题指明主存访问时间为 $t_m$。在没有关于快表（TLB）或多级页表的更多信息的情况下，我们将无缺页访问时间 $T_{hit}$ 定义为 $t_m$。那么 EAT 由下式给出：\n$$EAT = (1-p) \\cdot T_{hit} + p \\cdot \\mathbb{E}[T_{fault}]$$\n这里，$\\mathbb{E}[T_{fault}]$ 是期望缺页服务时间。\n\n如上所述，缺页服务时间 $T_{fault}$ 包括几个部分：操作系统开销（$t_{os}$）、存储设备延迟（$L$）和页面传输时间（$t_x$）。\n$$T_{fault} = t_{os} + L + t_x$$\n延迟 $L$ 是一个随机变量，而对于给定的设备，$t_{os}$ 和 $t_x$ 是常数。通过应用期望的线性性质，可以找到期望缺页服务时间：\n$$\\mathbb{E}[T_{fault}] = \\mathbb{E}[t_{os} + L + t_x] = t_{os} + \\mathbb{E}[L] + t_x$$\n\n页面传输时间 $t_x$ 由页面大小 $S$ 和设备的持续读取带宽 $B$ 决定，其中 $t_x = S/B$。我们分别计算 SSD 和 HDD 的这个时间。\n\n对于 SSD：\n$S = 4096 \\text{ 字节}$\n$B_{\\text{SSD}} = 500 \\times 10^{6} \\text{ 字节/秒}$\n$$t_{x, \\text{SSD}} = \\frac{S}{B_{\\text{SSD}}} = \\frac{4096}{500 \\times 10^{6}} \\text{ s} = 8.192 \\times 10^{-6} \\text{ s} = 8.192 \\,\\mu\\text{s}$$\n\n对于 HDD：\n$S = 4096 \\text{ 字节}$\n$B_{\\text{HDD}} = 150 \\times 10^{6} \\text{ 字节/秒}$\n$$t_{x, \\text{HDD}} = \\frac{S}{B_{\\text{HDD}}} = \\frac{4096}{150 \\times 10^{6}} \\text{ s} \\approx 27.3067 \\times 10^{-6} \\text{ s} = 27.3067 \\,\\mu\\text{s}$$\n\n现在，我们可以使用给定的参数为每种设备写出期望缺页服务时间的完整表达式：$t_{os} = 25 \\,\\mu\\text{s}$，$\\mathbb{E}[L_{\\text{SSD}}] = 100 \\,\\mu\\text{s}$，和 $\\mathbb{E}[L_{\\text{HDD}}] = 6000 \\,\\mu\\text{s}$。\n\nSSD 的期望缺页时间：\n$$\\mathbb{E}[T_{\\text{fault, SSD}}] = t_{os} + \\mathbb{E}[L_{\\text{SSD}}] + t_{x, \\text{SSD}} = 25 \\,\\mu\\text{s} + 100 \\,\\mu\\text{s} + 8.192 \\,\\mu\\text{s} = 133.192 \\,\\mu\\text{s}$$\n\nHDD 的期望缺页时间：\n$$\\mathbb{E}[T_{\\text{fault, HDD}}] = t_{os} + \\mathbb{E}[L_{\\text{HDD}}] + t_{x, \\text{HDD}} \\approx 25 \\,\\mu\\text{s} + 6000 \\,\\mu\\text{s} + 27.3067 \\,\\mu\\text{s} = 6052.3067 \\,\\mu\\text{s}$$\n\n每种配置的有效访问时间是：\n$$EAT_{\\text{SSD}} = (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, SSD}}]$$\n$$EAT_{\\text{HDD}} = (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, HDD}}]$$\n\n我们需要计算差值 $\\Delta EAT = EAT_{\\text{HDD}} - EAT_{\\text{SSD}}$。\n$$\\Delta EAT = \\left( (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, HDD}}] \\right) - \\left( (1-p)t_m + p \\cdot \\mathbb{E}[T_{\\text{fault, SSD}}] \\right)$$\n项 $(1-p)t_m$ 被消去，表达式简化为：\n$$\\Delta EAT = p \\left( \\mathbb{E}[T_{\\text{fault, HDD}}] - \\mathbb{E}[T_{\\text{fault, SSD}}] \\right)$$\n代入计算出的值：\n$$\\Delta EAT = (2 \\times 10^{-4}) \\left( 6052.3067 \\,\\mu\\text{s} - 133.192 \\,\\mu\\text{s} \\right)$$\n$$\\Delta EAT = (2 \\times 10^{-4}) \\left( 5919.1147 \\,\\mu\\text{s} \\right)$$\n$$\\Delta EAT \\approx 1.1838229 \\,\\mu\\text{s}$$\n四舍五入到四位有效数字得到 $1.184 \\,\\mu\\text{s}$。\n\n最后，我们提供一个定性论证，说明为什么相对于 HDD，SSD 既降低了访问时间的方差，也降低了缺页的尾延迟。\n\n1.  **访问时间的方差**：缺页服务时间 $T_{fault} = t_{os} + L + t_x$ 中的随机部分是存储延迟 $L$，因为 $t_{os}$ 和 $t_x$ 都是确定性常数。因此，缺页服务时间的方差等于延迟的方差：$\\operatorname{Var}(T_{fault}) = \\operatorname{Var}(t_{os} + L + t_x) = \\operatorname{Var}(L)$。问题给出了这些方差：\n    $$\\operatorname{Var}(L_{\\text{SSD}}) = (20 \\,\\mu\\text{s})^2 = 400 \\,(\\mu\\text{s})^2$$\n    $$\\operatorname{Var}(L_{\\text{HDD}}) = (3000 \\,\\mu\\text{s})^2 = 9 \\times 10^6 \\,(\\mu\\text{s})^2$$\n    标准差为 $\\sigma_{\\text{SSD}} = 20 \\,\\mu\\text{s}$ 和 $\\sigma_{\\text{HDD}} = 3000 \\,\\mu\\text{s}$。HDD 延迟的方差（和标准差）比 SSD 大几个数量级。这是它们物理性质的直接结果。HDD 延迟主要由机械操作决定：移动读/写磁头到正确磁道的寻道时间和等待所需扇区旋转到磁头下的旋转延迟。这些时间高度可变，取决于磁头和磁盘的初始和最终位置。相比之下，SSD 延迟是纯电子的，涉及寻址和访问闪存单元，这是一个远比前者确定和一致的过程。这种操作上的根本差异就是为什么 $\\operatorname{Var}(L_{\\text{HDD}}) \\gg \\operatorname{Var}(L_{\\text{SSD}})$，因此使用 SSD 时缺页服务时间的方差要小得多。\n\n2.  **尾延迟**：尾延迟指的是观测到非常长的服务时间的概率，通常用服务时间分布的高百分位数（例如，第 99 或 99.9 百分位数）来表征。一个方差较大的随机变量将具有更宽的概率分布，意味着其值更分散地分布在均值周围。一个具有较大方差和/或较大均值的分布通常会有“更重”或“更长”的尾部，这表明观测到远离均值的结果的概率不可忽略。HDD 的延迟分布既有大得多的均值（$\\mathbb{E}[L_{\\text{HDD}}] = 6000 \\,\\mu\\text{s}$ vs. $\\mathbb{E}[L_{\\text{SSD}}] = 100 \\,\\mu\\text{s}$），也有大得多的方差。因此，经历一次比平均值长得多的缺页服务时间（即尾延迟事件）的概率对于 HDD 来说要高得多。对于 SSD，低均值和极小的方差意味着其延迟分布是紧密集中的，使得极长的延迟变得非常不可能。因此，SSD 不仅提供了更快的平均性能，还提供了更可预测的性能，最坏情况下延迟峰值的发生率要低得多。",
            "answer": "$$\\boxed{1.184}$$"
        },
        {
            "introduction": "在了解了单次缺页中断的成本后，下一个关键问题是如何通过有效的算法来降低缺页的发生频率。本练习将带你深入研究几种经典的页面替换算法——先进先出（FIFO）、最近最少使用（LRU）和时钟（Clock）算法——在面对具有阶段性局部特征的真实访问序列时的表现。通过模拟和分析，你将学会评估不同算法的优劣，并揭示像FIFO这类算法可能出现的“Belady异常”这一违反直觉的现象，从而深刻理解算法设计中的微妙之处。",
            "id": "3668817",
            "problem": "一个虚拟内存系统使用请求分页，其全相联主存有 $M$ 个页帧，并且有一个单一进程，其引用流表现出明显的局部性阶段。考虑以下引用轨迹 $\\mathcal{S}$，它由两个阶段 $\\mathcal{A}$ 和 $\\mathcal{B}$ 各连接两次构成：\n$$\n\\mathcal{A} = [\\,1,\\,2,\\,1,\\,2,\\,1,\\,2,\\,3,\\,1,\\,2,\\,1,\\,2,\\,3\\,], \\quad\n\\mathcal{B} = [\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,],\n$$\n使得\n$$\n\\mathcal{S} = \\mathcal{A} \\,\\Vert\\, \\mathcal{B} \\,\\Vert\\, \\mathcal{A} \\,\\Vert\\, \\mathcal{B},\n$$\n其中 $\\Vert$ 表示连接。$\\mathcal{S}$ 的总长度为 48 次引用。需要比较的页面替换算法有先进先出 (FIFO)、最近最少使用 (LRU) 和二次机会 (Clock) 算法。假设为单级统一内存访问，转换后备缓冲区效应可忽略不计，并且在处理 $\\mathcal{S}$ 的第一个引用之前，所有页帧最初为空，所有引用位均被清除。\n\n你将使用重用（栈）距离的概念来分析请求分页的性能。对于在时间 $t$ 对一个页面的引用，将其重用距离 $K$ 定义为在其前一次引用与时间 $t$ 之间严格引用的不同页面的数量；对于一个页面的首次引用（没有前一次引用），令 $K = \\infty$。令 $D(k)$ 表示在整个轨迹 $\\mathcal{S}$ 上测得的 $K$ 的经验分布，即对于每个 $k \\in \\{1,2,3,\\dots\\}$ 和 $k=\\infty$，$D(k)$ 是 $\\mathcal{S}$ 中重用距离等于 $k$ 的引用所占的比例。\n\n任务：\n- 仅使用请求分页、重用距离的核心定义以及 LRU 的定性栈属性（即在相同轨迹上，使用 $M$ 个帧的 LRU 内存中的页面集合总是使用 $M-1$ 个帧的页面集合的超集），计算给定 $\\mathcal{S}$ 的经验分布 $D(k)$。\n- 从第一性原理出发，推导如何从 $D(k)$ 和帧数 $M$ 计算 LRU 的期望缺页次数，并在 $\\mathcal{S}$ 上对 $M=3$ 的情况进行评估。\n- 通过从算法定义直接推理，确定当 $M=3$ 时，在 $\\mathcal{S}$ 上 FIFO 和二次机会 (Clock) 算法产生的总缺页次数，并与你从 $D(k)$ 推导出的 LRU 结果进行定性比较。\n- 专注于单一阶段 $\\mathcal{B}$（即 12 次引用的子序列），在冷启动（$\\mathcal{B}$ 开始时帧为空）的情况下，通过比较在该子序列上 $M=3$ 与 $M=4$ 时 FIFO 的总缺页次数，讨论 FIFO 出现 Belady 异常的风险，并从缺乏栈属性的角度解释观察到的任何异常的根本原因。\n\n最终答案只需提供在整个 48 次引用的轨迹 $\\mathcal{S}$ 上，当 $M=3$ 时 LRU 的期望总缺页次数，以单个无单位整数的形式给出。不要在最终答案框中包含中间结果。",
            "solution": "我们从核心定义开始。当被引用的页面不在 $M$ 个页帧的集合中时，就会发生缺页。一次引用的重用距离 $K$ 是指在其前一次出现与当前时间之间严格引用的不同页面的数量；对于页面的首次引用，$K=\\infty$。对于最近最少使用 (LRU) 算法，一次引用是命中，当且仅当自上次引用该页面以来所使用的不同页面的数量严格小于帧数 $M$，因为 LRU 会在内存中保留最近使用过的 $M$ 个不同页面。因此，在使用 $M$ 个帧的 LRU 算法下，一次引用发生缺页当且仅当 $K \\ge M$ (包括 $K=\\infty$）。对于长度为 $N$ 的轨迹，当 $D(k)$ 是经验重用距离分布时，这得出 LRU 的缺页次数等于\n$$\nN \\cdot \\Big( D(\\infty) \\;+\\; \\sum_{k=M}^{\\infty} D(k) \\Big),\n$$\n\n步骤 1：计算 $\\mathcal{S}$ 的经验分布 $D(k)$。\n\n我们扫描 $\\mathcal{S}$ 一遍，对于每次引用，计算 $K$ 值，即自上一次引用同一页面以来遇到的不同页面的数量，如果没有前一次引用则 $K=\\infty$。对全部 48 次引用进行统计，得到以下计数：\n- $5$ 次引用的 $K=\\infty$，\n- $12$ 次引用的 $K=1$，\n- $16$ 次引用的 $K=2$，\n- $4$ 次引用的 $K=3$，\n- $11$ 次引用的 $K=4$，\n以及对于所有其他有限 $k$ 值为 $0$。\n这些计数总和为 48，符合要求。因此，\n$$\nD(\\infty) \\;=\\; \\frac{5}{48},\\quad D(1)\\;=\\;\\frac{12}{48},\\quad D(2)\\;=\\;\\frac{16}{48},\\quad D(3)\\;=\\;\\frac{4}{48},\\quad D(4)\\;=\\;\\frac{11}{48},\n$$\n其中对于所有 $k \\ge 5$，$D(k)=0$。\n\n步骤 2：推导并评估 $M=3$ 时 LRU 的期望缺页次数。\n\n根据 LRU 的栈属性和重用距离的定义，在使用 $M=3$ 的 LRU 算法下，如果 $K \\in \\{\\infty\\} \\cup \\{3,4,5,\\dots\\}$，则引用会发生缺页。使用上面得到的经验分布 $D(k)$ 和 $N=48$，\n$$\n\\text{Faults}_{\\text{LRU},\\,M=3}\n\\;=\\;\n48 \\cdot \\Big( D(\\infty) + \\sum_{k=3}^{\\infty} D(k) \\Big)\n\\;=\\;\n48 \\cdot \\Big( \\frac{5}{48} + \\frac{4}{48} + \\frac{11}{48} \\Big)\n\\;=\\;\n48 \\cdot \\frac{20}{48}\n\\;=\\;\n20.\n$$\n等价地，直接计数：$5$ 次首次接触引用加上 $4$ 次 $K=3$ 的引用再加上 $11$ 次 $K=4$ 的引用，总共产生 $20$ 次 LRU 缺页。\n\n步骤 3：通过直接的算法推理，比较 $M=3$ 时的 FIFO 和二次机会 (Clock) 算法。\n\n我们现在根据 FIFO 和 Clock 的定义来模拟它们。对于先进先出 (FIFO)，维护一个按到达顺序排列的已加载帧队列；当内存已满且发生未命中时，驱逐最旧的帧（队列头部）。对于二次机会 (Clock)，维护一个带引用位的帧循环列表；命中时，将该页的引用位置为 $1$；未命中时，向前移动指针，将遇到的任何为 $1$ 的引用位清零并继续，直到找到一个引用位为 $0$ 的帧；驱逐该帧，将新页面安装在此处并将引用位置为 $1$，然后将指针前移一个位置。\n\n在 $48$ 次引用的轨迹 $\\mathcal{S}$ 上，当 $M=3$ 时（帧初始为空，对于 Clock 算法，所有引用位初始为 $0$，指针在第一个帧），进行逐步模拟，得到以下总缺页次数：\n- $\\text{Faults}_{\\text{FIFO},\\,M=3} = 18$,\n- $\\text{Faults}_{\\text{Clock},\\,M=3} = 18$,\n这两个值都可能低于、等于或高于 LRU 的计数值，具体取决于轨迹；在这里，经验上的 LRU 计数值为 $20$。这说明，虽然 LRU 具有栈属性，并且在典型的具有良好局部性的轨迹上，对于给定的 $M$，它倾向于在栈算法中最小化缺页次数，但 FIFO 和 Clock 不是栈算法；特别地，在给定的有限轨迹上，FIFO 有时可能会比 LRU 产生更少或更多的缺页。\n\n步骤 4：讨论在阶段 $\\mathcal{B}$ 上 FIFO 的 Belady 异常风险。\n\nBelady 异常指的是，在使用 FIFO 算法时，增加页帧数量可能会导致缺页次数增加的可能性。考虑单一阶段 $\\mathcal{B} = [\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,]$，在冷启动（$\\mathcal{B}$ 开始时帧为空）的情况下。直接的 FIFO 模拟显示：\n- 当 $M=3$ 时，在 $\\mathcal{B}$ 上的总 FIFO 缺页次数为 $9$ 次。\n- 当 $M=4$ 时，在 $\\mathcal{B}$ 上的总 FIFO 缺页次数为 $10$ 次。\n因此，将帧数从 $3$ 增加到 $4$ 导致 FIFO 缺页次数从 $9$ 次增加到 $10$ 次，这是 Belady 异常的一个实例。根本原因在于 FIFO 缺乏栈属性：在给定时间，使用 $M=4$ 的内存中页面集合不一定是使用 $M=3$ 的集合在同一引用串上的超集，因此额外的容量可能会扰乱驱逐顺序，从而导致额外的未命中。\n\n结论和要求的数值结果。\n\n根据测得的 $D(k)$ 和 LRU 的栈属性，在 $\\mathcal{S}$ 上当 $M=3$ 时，LRU 的期望总缺页次数等于 $20$。",
            "answer": "$$\\boxed{20}$$"
        },
        {
            "introduction": "除了选择合适的页面替换算法，我们还可以通过优化缺页处理流程本身来提升系统性能，预取（Prefetching）就是一种常见的策略。这个练习构建了一个经典的系统设计权衡场景：在发生缺页时，花费额外的I/O时间预取多个页面，以期望降低未来的缺页率。你的任务是建立模型并计算出使这项优化策略“收支平衡”的临界缺页率，这个过程将锻炼你使用性能模型来指导具体系统决策的能力。",
            "id": "3633506",
            "problem": "一个虚拟内存系统对一个程序使用请求分页，在没有任何预取的情况下，该程序每次内存引用的缺页概率为 $p$。处理器在命中时的内存引用服务时间为 $t_m$。在请求分页下发生缺页时，操作系统执行故障处理，其软件开销为 $H$，然后执行一次输入/输出（I/O）操作以调入故障页面：存储设备的平均寻道加旋转延迟为 $L$，持续传输速率为 $R$，页面大小为 $S$。假设I/O在一次连续的操作中完成，因此在请求分页下每次故障的服务时间为 $H + L + \\frac{S}{R}$。\n\n现在考虑一种预取策略：每当发生缺页时，系统在同一次I/O操作中还预取 $m$ 个额外的页面，这不会产生超过 $L$ 的额外延迟，但每次缺页会产生额外的传输时间 $\\frac{mS}{R}$。该策略将稳态缺页概率（每次引用）降低至一个未知的 $p'$，但不会改变 $t_m$ 或 $H$。\n\n仅使用平均内存访问时间（EMAT）的定义，其中每次引用的时间是命中和缺页情况的期望值，确定盈亏平衡的 $p'$，使得预取相对于请求分页对EMAT既无益也无害。然后，使用以下参数对此盈亏平衡点 $p'$ 进行数值计算，并将最终答案表示为小数，四舍五入到四位有效数字：\n\n- 基准缺页概率: $p = 3.0 \\times 10^{-5}$。\n- 内存命中时间: $t_m = 8.0 \\times 10^{-8}$ 秒。\n- 每次缺页的操作系统软件开销: $H = 4.0 \\times 10^{-4}$ 秒。\n- 设备平均延迟: $L = 5.6 \\times 10^{-3}$ 秒。\n- 持续传输速率: $R = 250$ mebibytes/秒 (MiB/s)。\n- 页面大小: $S = 8$ kibibytes (KiB)。\n- 预取深度: $m = 12$ 个额外页面/每次缺页。\n\n使用 $1$ MiB $= 2^{20}$ 字节和 $1$ KiB $= 2^{10}$ 字节。不要使用百分号；将概率以纯小数形式报告。",
            "solution": "我们从平均内存访问时间（命中和缺页的期望值）的定义开始。设每次引用的缺页概率为 $p$，命中概率为 $1 - p$。如果命中时间为 $t_m$，缺页服务时间为 $T_{\\text{fault}}$，那么平均内存访问时间（EMAT）为\n$$\n\\text{EMAT} = (1 - p)\\, t_m + p\\, T_{\\text{fault}}.\n$$\n在请求分页下，缺页服务时间是操作系统开销 $H$、设备平均延迟 $L$ 和传输一个页面的时间 $\\frac{S}{R}$ 的总和：\n$$\nT_{\\text{on}} = H + L + \\frac{S}{R}.\n$$\n在预取策略下，我们在同一次I/O操作中获取故障页面以及额外的 $m$ 个页面。没有超过 $L$ 的额外延迟，但有额外的传输时间 $\\frac{mS}{R}$。因此，带预取的缺页服务时间是\n$$\nT_{\\text{pre}} = H + L + \\frac{(m+1)S}{R} = \\left(H + L + \\frac{S}{R}\\right) + \\frac{mS}{R} = T_{\\text{on}} + k,\n$$\n其中，我们将因预取而产生的每次缺页的额外I/O成本定义为\n$$\nk = \\frac{mS}{R}.\n$$\n设预取策略下新的每次引用缺页概率为 $p'$。两种策略的EMAT分别为\n$$\n\\text{EMAT}_{\\text{on}} = (1 - p)\\, t_m + p\\, T_{\\text{on}}, \\qquad \\text{EMAT}_{\\text{pre}} = (1 - p')\\, t_m + p'\\, T_{\\text{pre}}.\n$$\n盈亏平衡条件要求两者相等：\n$$\n(1 - p)\\, t_m + p\\, T_{\\text{on}} = (1 - p')\\, t_m + p'\\, T_{\\text{pre}}.\n$$\n重新整理以求解 $p'$：\n\n$$\nt_m - p t_m + p T_{\\text{on}} = t_m - p' t_m + p' T_{\\text{pre}}\n$$\n\n\n$$\n- p t_m + p T_{\\text{on}} = - p' t_m + p' T_{\\text{pre}}\n$$\n\n\n$$\np' (T_{\\text{pre}} - t_m) = p (T_{\\text{on}} - t_m)\n$$\n\n\n$$\np' = p \\, \\frac{T_{\\text{on}} - t_m}{T_{\\text{pre}} - t_m} = p \\, \\frac{T_{\\text{on}} - t_m}{(T_{\\text{on}} + k) - t_m}.\n$$\n\n这个表达式表明了为精确抵消预取所引入的额外I/O成本 $k$，缺页概率需要降低的幅度。\n\n我们现在进行数值计算。首先计算每页传输时间 $\\frac{S}{R}$，然后计算 $k$、$T_{\\text{on}}$ 和 $T_{\\text{pre}}$。\n\n- 转换单位。已知 $R = 250$ MiB/s 且 $S = 8$ KiB，\n  - $1$ MiB $= 2^{20}$ 字节 且 $1$ KiB $= 2^{10}$ 字节。\n  - $R = 250 \\times 2^{20} = 250 \\times 1{,}048{,}576 = 262{,}144{,}000$ 字节/秒。\n  - $S = 8 \\times 2^{10} = 8192$ 字节。\n因此，\n$$\n\\frac{S}{R} = \\frac{8192}{262{,}144{,}000} = \\frac{1}{32{,}000} = 3.125 \\times 10^{-5} \\text{ s}.\n$$\n\n- 预取 $m = 12$ 个额外页面的额外传输时间为\n$$\nk = \\frac{mS}{R} = 12 \\times 3.125 \\times 10^{-5} = 3.75 \\times 10^{-4} \\text{ s}.\n$$\n\n- 请求分页的缺页服务时间为\n$$\nT_{\\text{on}} = H + L + \\frac{S}{R} = (4.0 \\times 10^{-4}) + (5.6 \\times 10^{-3}) + (3.125 \\times 10^{-5}) = 6.03125 \\times 10^{-3} \\text{ s}.\n$$\n\n- 预取的缺页服务时间为\n$$\nT_{\\text{pre}} = T_{\\text{on}} + k = (6.03125 \\times 10^{-3}) + (3.75 \\times 10^{-4}) = 6.40625 \\times 10^{-3} \\text{ s}.\n$$\n\n- 命中时间为 $t_m = 8.0 \\times 10^{-8}$ 秒，所以\n$$\nT_{\\text{on}} - t_m = 6.03125 \\times 10^{-3} - 8.0 \\times 10^{-8} = 6.03117 \\times 10^{-3} \\text{ s},\n$$\n$$\nT_{\\text{pre}} - t_m = 6.40625 \\times 10^{-3} - 8.0 \\times 10^{-8} = 6.40617 \\times 10^{-3} \\text{ s}.\n$$\n\n因此，\n$$\np'_{\\text{break}} = p \\, \\frac{T_{\\text{on}} - t_m}{T_{\\text{pre}} - t_m} = \\left(3.0 \\times 10^{-5}\\right) \\times \\frac{6.03117 \\times 10^{-3}}{6.40617 \\times 10^{-3}}.\n$$\n计算比率：\n$$\n\\frac{6.03117}{6.40617} \\approx 0.941461,\n$$\n因此\n$$\np'_{\\text{break}} \\approx \\left(3.0 \\times 10^{-5}\\right) \\times 0.941461 = 2.824383 \\times 10^{-5}.\n$$\n按要求四舍五入到四位有效数字：\n$$\np'_{\\text{break}} = 2.824 \\times 10^{-5}.\n$$\n这是在给定的设备带宽、延迟和预取深度下，使预取与请求分页达到盈亏平衡所需的预取后最低缺页概率（以小数形式表示）。",
            "answer": "$$\\boxed{2.824 \\times 10^{-5}}$$"
        }
    ]
}