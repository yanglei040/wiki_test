{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式是动手实践。我们从一个基础但至关重要的问题开始：对于一个行为具有周期性的程序，我们需要分配多少内存才能完全避免页面错误？这个练习将帮助你理解工作集大小与内存容量之间的基本关系，并推导出在理想情况下保证零页面错误的最小帧数。通过分析这个场景 ，你将为更复杂的页面替换问题打下坚实的基础。",
            "id": "3629752",
            "problem": "考虑一个基于计数的“最不常用”（LFU）页面置换策略，其中使用“最久未使用”（LRU）规则来确定性地打破平局。在 LFU 中，每个页面 $p_i$ 维护一个计数器 $c_i$，其值等于自执行开始以来对页面 $p_i$ 的引用次数。当内存已满并发生页面错误时，该算法会淘汰 $c_i$ 值最小的驻留页面；如果多个页面的 $c_i$ 值同为最小，则淘汰其中最久未使用的页面。假设计数器没有老化或衰减。\n\n假设引用字符串是周期性的，周期长度为 $L$，并且无限重复。设周期内引用的不同页面的集合为 $\\mathcal{P} = \\{p_1, p_2, \\dots, p_K\\}$，其中 $K \\leq L$。在每个周期内，页面 $p_i$ 恰好出现 $f_i$ 次，其中 $f_i \\in \\mathbb{N}$ 且 $\\sum_{i=1}^{K} f_i = L$。内存有 $N$ 个帧，初始为空，并且在时间 $t=0$ 时，所有计数器 $c_i = 0$。\n\n仅使用上述基本定义，推理循环序列上的稳态行为，并确定在何种条件下，LFU 策略下会导致周期性的页面错误（未命中）。然后，对于具体分布\n$$\nL = 24,\\quad K = 8,\\quad f = (f_1, f_2, f_3, f_4, f_5, f_6, f_7, f_8) = (7, 5, 4, 3, 2, 1, 1, 1),\n$$\n计算能消除由周期引起的页面错误周期性的最小帧数 $N$，其含义是，在有限的预热期后，每个周期中的每次引用都是一次命中（即，此后任何周期内都不会发生未命中）。将最终答案表示为一个不带单位的整数。无需四舍五入。",
            "solution": "问题要求计算所需的最小内存帧数 $N$，以确保对于给定的周期性引用字符串，系统能达到一个不发生页面错误的稳态。页面置换算法为最不常用（LFU），并以最久未使用（LRU）作为平局打破规则。\n\n设 $\\mathcal{P} = \\{p_1, p_2, \\dots, p_K\\}$ 是引用周期中出现的 $K$ 个不同页面的集合。问题陈述引用字符串是周期性的且无限重复，这意味着所有引用都指向集合 $\\mathcal{P}$ 内的页面。在单个周期内，每个页面 $p_i$ 的引用频率为 $f_i \\in \\mathbb{N}$，即 $f_i \\ge 1$。这确保了 $\\mathcal{P}$ 中的每个页面在每个周期内都会被引用。\n\n系统的行为可以分为初始的瞬态（预热）阶段和随后的稳态阶段。目标是找到最小的 $N$，使得在稳态下，每次引用都是一次命中。这等同于陈述：驻留页面的集合 $\\mathcal{M}$ 必须包含引用周期中的整个页面集合 $\\mathcal{P}$。也就是说，零稳态未命中的条件是：\n$$\n\\mathcal{P} \\subseteq \\mathcal{M}\n$$\n\n帧的数量为 $N$，这对驻留页面集合的大小施加了一个约束：$|\\mathcal{M}| \\le N$。为了满足条件 $\\mathcal{P} \\subseteq \\mathcal{M}$，帧的数量必须至少与周期中不同页面的数量一样大，即 $|\\mathcal{P}| = K$。这就建立了一个必要条件：\n$$\nN \\ge K\n$$\n\n我们现在证明这个条件也是充分的。假设 $N \\ge K$。系统在时间 $t=0$ 时从空的内存帧开始。随着引用字符串被处理，集合 $\\mathcal{P}$ 中的每个页面 $p_i$ 最终都会被引用。当一个页面首次被引用时，会引发一次强制性未命中（页面错误），该页面会被加载到一个空帧中；如果内存已满，则通过淘汰另一个页面来加载。由于有 $K$ 个不同的页面，将会有一个初始的预热期，涉及最多 $K$ 次页面错误，以将 $\\mathcal{P}$ 中的所有页面都调入内存。因为我们假设了 $N \\ge K$，所以有足够的帧来同时容纳所有 $K$ 个页面。\n\n一旦这个预热阶段完成，集合 $\\mathcal{P}$ 的所有 $K$ 个页面都驻留在内存中。现在，考虑周期中的任何后续引用。该引用必定是针对 $\\mathcal{P}$ 中的某个页面 $p_j$。由于 $\\mathcal{P}$ 中的所有页面现在都驻留在内存中，这次对 $p_j$ 的引用将是一次命中。当发生命中时，不会产生页面错误，因此也不会发生页面淘汰。驻留页面的集合保持不变，继续包含 $\\mathcal{P}$ 的所有页面。这对所有后续引用都成立，因为它们都来自于 $\\mathcal{P}$。因此，页面错误率降至零并保持不变。这个状态对应于消除由周期引起的页面错误周期性的期望结果。\n\n相反地，如果 $N  K$，物理上不可能同时将所有 $K$ 个不同的页面存储在可用的 $N$ 个帧中。由于 $\\mathcal{P}$ 中的每个页面 $p_i$ 都保证在每个周期中被引用（因为 $f_i \\ge 1$），因此不可避免地会引用到一个当前不在内存中的页面。这将导致一次页面错误。然后 LFU 算法会淘汰 $N$ 个驻留页面中的一个，为新页面腾出空间。由于引用字符串是周期性的，这种发生错误和淘汰的过程将在稳态下以周期性模式持续。因此，发生周期性页面错误的条件是 $N  K$。\n\n为消除这些周期性错误，我们必须选择违反此条件的最小 $N$。满足 $N \\ge K$ 的最小整数 $N$ 恰好是 $N = K$。\n$$\nN_{\\text{min}} = K\n$$\n这个结论仅取决于不同页面的数量 $K$，而与具体频率 $f_i$、周期长度 $L$ 或平局打破规则无关，因为这些细节仅在 $N  K$ 时控制淘汰的动态过程。\n\n对于问题中提供的具体实例：\n给定的不同页面集合为 $\\mathcal{P} = \\{p_1, p_2, \\dots, p_8\\}$，因此不同页面的数量为 $K=8$。给定的频率向量为 $f = (7, 5, 4, 3, 2, 1, 1, 1)$，这证实了有 $K=8$ 个页面。周期长度为 $L=24$，我们可以验证 $\\sum f_i = 7+5+4+3+2+1+1+1 = 24 = L$。\n\n使用我们推导出的通用结果，消除稳态页面错误所需的最小帧数为：\n$$\nN_{\\text{min}} = K = 8\n$$\n当有 $N=8$ 个帧时，经过最多 8 次页面错误的初始瞬态期后，所有 8 个页面都将驻留在内存中，并且不会再发生任何错误。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "在现实世界中，程序的访问模式很少像完美的周期循环那样简单。这个练习将我们带入一个更真实的场景，探讨 LFU 算法的一个著名缺陷——“冷启动偏见”，即新近变得频繁的页面难以在内存中获得一席之地。你将需要运用分析建模的技巧，量化这个问题，并推导出一个基于指数老化计数器的解决方案，以确定需要多大的访问“爆发”才能克服这种偏见 。这个练习旨在深化你对算法动态行为和性能优化策略的理解。",
            "id": "3629731",
            "problem": "考虑一个内存系统，它有 $N$ 个页帧和 $P$ 个不同的虚拟页面，其中 $P \\geq N+1$。操作系统使用一种基于计数的页面替换策略：最不常使用（LFU）。为了减轻 LFU 众所周知的冷启动偏差，该实现对访问计数应用了指数老化。具体来说，每个页面 $i$ 维护一个老化计数 $c_i(t)$，在两次访问之间，该计数遵循 $ \\frac{d c_i(t)}{dt} = -\\lambda c_i(t)$；在时刻 $t$ 访问页面 $i$ 时，计数器更新为 $c_i(t^{+}) = c_i(t^{-}) + 1$，其中 $\\lambda  0$ 是一个固定的衰减率。在时刻 $t$ 发生页面错误时，该策略会淘汰当前 $c_i(t^{-})$ 最小的驻留页面（任意打破平局）。\n\n您将设计并分析一个参数化的引用字符串，该字符串在突发访问下暴露 LFU 的冷启动偏差，然后确定一个关于突发长度的定量条件，以在指数老化下减轻该偏差。\n\n构建以下工作负载。存在一个固定的集合 $\\mathcal{H} = \\{H_1,\\dots,H_{N-1}\\}$，包含 $N-1$ 个“现任热门”页面，在时刻 $t=0$ 之前，对这些页面的访问构成独立的平稳 Poisson 过程，共同速率为每单位时间 $\\mu$ 次访问，因此在 $t=0$ 之前，系统已达到稳态，并且 $\\mathcal{H}$ 中的所有页面都已驻留。在时刻 $t=0$，一个新页面 $X$ 开始被以重复周期的形式引用。每个周期包括：\n- 对 $X$ 的 $b$ 次连续引用组成的突发，其到达间隔恒定为 $\\tau_b$，紧密相连，因此突发持续时间为 $b\\,\\tau_b$，随后\n- 对一个“干扰”页面 $Y$ 的单次引用，该页面不在 $\\mathcal{H}$ 中，并且在被引用之前不驻留，从而在对 $Y$ 的引用时强制进行替换。\n\n假设 $P$ 足够大，以确保在每个周期中，$Y$ 在被引用时都是非驻留页面。同时假设突发期间存在时间尺度分离，因此突发内的老化可以忽略不计，即 $\\lambda\\,b\\,\\tau_b \\ll 1$，并且对 $\\mathcal{H}$ 中页面的访问保持其稳态行为，因此它们的老化计数可以用其稳态期望值来处理。\n\n任务：\n- 仅使用上述核心定义和关于 Poisson 过程的标准随机事实，首先证明对于非老化 LFU（即极限情况 $\\lambda \\to 0^{+}$），对于任何固定的有限 $b$，一旦系统预热，页面 $X$ 在每个周期结束时，在对 $Y$ 的后续引用中都将成为被淘汰的受害者，这导致 $X$ 在不同周期中重复发生页面错误（$X$ 的操作性颠簸）。\n- 对于具有固定 $\\lambda  0$ 的指数老化，推导出一个关于最小整数突发长度 $b_{\\min}$ 的显式闭合形式表达式（作为 $\\mu$ 和 $\\lambda$ 的函数），使得在 $X$ 的突发之后、紧接着对 $Y$ 的引用之前，$X$ 不会成为被淘汰的受害者。等价地，$b_{\\min}$ 是确保突发后 $X$ 的老化计数超过 $\\mathcal{H}$ 中任何现任热门页面在稳态下的计数的最小整数 $b$，从而在这种突发模式下减轻 LFU 对 $X$ 的冷启动偏差。\n\n您的最终答案必须是关于 $b_{\\min}$ 的单一解析表达式，用 $\\mu$ 和 $\\lambda$ 表示。不需要进行数值计算，最终表达式中也不应包含单位。",
            "solution": "该问题是有效的。这是一个在操作系统性能分析领域中，结构良好、有科学依据的问题，使用了随机过程的标准模型。所提供的假设是明确且充分的，足以推导出唯一解。\n\n问题要求分为两部分：首先，证明在非老化最不常使用（LFU）策略下新页面的颠簸现象；其次，推导在带指数老化的 LFU 下防止这种颠簸的最小突发大小 $b_{\\min}$。\n\n### 第一部分：非老化 LFU（$\\lambda \\to 0^{+}$）的分析\n\n在衰减率 $\\lambda \\to 0^{+}$ 的极限情况下，计数更新方程中的老化项 $\\frac{d c_i(t)}{dt} = -\\lambda c_i(t)$ 变为零。这意味着访问计数 $c_i(t)$ 是非递减的；它们只在访问时增加，从不衰减。这就是纯粹的 LFU 算法。\n\n问题指出，在时刻 $t=0$ 之前，系统已达到稳态，其中集合 $\\mathcal{H}$ 中的 $N-1$ 个现任热门页面是驻留的。在纯 LFU 系统中，“稳态”意味着这些页面已经被访问了很长时间。它们的访问计数 $c_{H_j}$（对于 $H_j \\in \\mathcal{H}$）将在这段漫长的历史中累积，并将是极大的值，与它们的访问率 $\\mu$ 和经过时间的乘积成正比。\n\n在时刻 $t=0$，引入一个新页面 $X$。其初始计数为 $c_X = 0$。在第一个周期中，它被访问 $b$ 次。由于计数不会衰减，其在突发后的计数变为 $c_X = b$。\n\n突发之后，对非驻留页面 $Y$ 的引用会触发页面错误，并迫使操作系统从驻留页面集 $\\mathcal{H} \\cup \\{X\\}$ 中选择一个受害者页面进行淘汰。LFU 策略规定淘汰访问计数最低的页面。\n\n需要比较的计数是：\n- 页面 $X$ 的计数：$c_X = b$。\n- 现任热门页面的计数：$c_{H_j}$，对于 $H_j \\in \\mathcal{H}$。\n\n对于任何有限的突发长度 $b$，页面 $X$ 的计数与 $\\mathcal{H}$ 中现任页面历史上累积的非常大的计数相比将是微不足道的。也就是说，$c_X \\ll c_{H_j}$ 对于所有 $j \\in \\{1, \\dots, N-1\\}$。因此，页面 $X$ 将被选为淘汰的受害者。\n\n这个过程在每个周期中重复。当下一个周期开始时，对页面 $X$ 的第一次引用会导致页面错误。页面 $X$ 被调入内存，其计数在突发期间增加到 $b$，然后在对页面 $Y$ 的引用时立即再次被淘汰。这种页面不断被调入调出内存而无法取得进展的现象，被称为颠簸（thrashing）。纯 LFU 的冷启动偏差——即由于其计数从零开始，无法识别一个新近变得热门的页面，以对抗具有悠久历史的现任页面——被这个工作负载完美地暴露出来。\n\n### 第二部分：带指数老化的 LFU（$\\lambda  0$）中 $b_{\\min}$ 的推导\n\n当衰减率 $\\lambda  0$ 非零时，所有页面的计数会持续衰减。这种“遗忘”机制防止了旧页面的计数无限增长，使得新页面在被足够频繁访问时有机会建立驻留。问题要求找出最小的整数突发长度 $b$，使得页面 $X$ 不成为被淘汰的受害者。这要求 $X$ 在其初始突发后的计数超过现任热门页面的稳态计数。问题指明，热门页面的稳态计数可以用其期望值来处理。\n\n因此，页面 $X$ 能够幸免于淘汰的条件是：\n$$c_X^{\\text{after burst}}  E[c_H]$$\n其中 $c_X^{\\text{after burst}}$ 是页面 $X$ 在其突发刚结束时的计数，而 $E[c_H]$ 是一个现任热门页面 $H \\in \\mathcal{H}$ 的稳态期望计数。\n\n**步骤1：计算稳态期望计数 $E[c_H]$**\n\n对于一个页面 $H \\in \\mathcal{H}$，访问构成一个速率为 $\\mu$ 的平稳 Poisson 过程。计数 $c_H(t)$ 以速率 $\\lambda$ 指数衰减，并在每次访问时增加 1。我们需要找到在做出淘汰决定前一刻的计数的期望值。问题指出淘汰是基于 $c_i(t^{-})$。我们可以对每次访问前一刻的计数演化进行建模。\n设 $c'_k$ 为页面 $H$ 在其第 $k$ 次访问（发生在时刻 $t_k$）前一刻的计数。这次访问刚结束后的计数是 $c'_k+1$。然后这个计数会衰减，直到在时刻 $t_{k+1}$ 的下一次访问。在第 $(k+1)$ 次访问前一刻的计数是：\n$$c'_{k+1} = (c'_k + 1) e^{-\\lambda (t_{k+1}-t_k)}$$\n设 $\\Delta t_k = t_{k+1}-t_k$ 为到达间隔时间。由于到达遵循速率为 $\\mu$ 的 Poisson 过程，到达间隔时间 $\\Delta t_k$ 是独立同分布的指数随机变量，其概率密度函数为 $f(\\tau) = \\mu e^{-\\mu \\tau}$（对于 $\\tau \\ge 0$）。\n\n在稳态下，期望计数是恒定的，所以 $E[c'_{k+1}] = E[c'_k] = E[c_H]$。对递推关系取期望：\n$$E[c'_{k+1}] = E[(c'_k + 1) e^{-\\lambda \\Delta t_k}]$$\n由于在时刻 $t_k$ 的计数 $c'_k$ 与未来的到达间隔时间 $\\Delta t_k$ 是独立的：\n$$E[c_H] = E[c'_k + 1] E[e^{-\\lambda \\Delta t_k}] = (E[c_H] + 1) E[e^{-\\lambda \\Delta t_k}]$$\n我们必须计算指数项的期望值：\n$$E[e^{-\\lambda \\Delta t_k}] = \\int_0^\\infty e^{-\\lambda \\tau} (\\mu e^{-\\mu \\tau}) d\\tau = \\mu \\int_0^\\infty e^{-(\\lambda+\\mu)\\tau} d\\tau = \\mu \\left[ \\frac{-1}{\\lambda+\\mu} e^{-(\\lambda+\\mu)\\tau} \\right]_0^\\infty = \\mu \\left( 0 - \\frac{-1}{\\lambda+\\mu} \\right) = \\frac{\\mu}{\\lambda+\\mu}$$\n将此结果代回 $E[c_H]$ 的方程中：\n$$E[c_H] = (E[c_H] + 1) \\frac{\\mu}{\\lambda+\\mu}$$\n$$E[c_H](\\lambda+\\mu) = (E[c_H] + 1)\\mu$$\n$$E[c_H]\\lambda + E[c_H]\\mu = E[c_H]\\mu + \\mu$$\n$$E[c_H]\\lambda = \\mu$$\n$$E[c_H] = \\frac{\\mu}{\\lambda}$$\n这是一个热门页面的稳态期望计数。PASTA（Poisson Arrivals See Time Averages，泊松到达看到时间平均）性质意味着，这个在一次到达前一刻的期望计数也是时间平均的期望计数。我们将使用这个值作为需要超越的基准。\n\n**步骤2：计算页面 $X$ 在其突发后的计数**\n\n页面 $X$ 是新的，所以其计数从 $c_X=0$ 开始。它经历了一次包含 $b$ 次引用的突发。问题声明要假设在突发内部老化可以忽略不计（$\\lambda b \\tau_b \\ll 1$）。这意味着我们可以在短暂的突发持续时间内忽略指数衰减。每次访问的计数更新规则是 $c_X(t^+) = c_X(t^-) + 1$。从 0 开始，经过 $b$ 次这样的更新后，页面 $X$ 的计数将是：\n$$c_X^{\\text{after burst}} = b$$\n\n**步骤3：确定最小突发长度 $b_{\\min}$**\n\n为了避免成为被淘汰的受害者，页面 $X$ 的计数必须严格大于现任热门页面的期望计数。\n$$c_X^{\\text{after burst}}  E[c_H]$$\n$$b  \\frac{\\mu}{\\lambda}$$\n由于突发长度 $b$ 必须是整数，满足此严格不等式的最小整数 $b$ 值是右侧向下取整再加一。\n$$b_{\\min} = \\left\\lfloor \\frac{\\mu}{\\lambda} \\right\\rfloor + 1$$\n这就是新近热门的页面 $X$ 为了克服 LFU 冷启动偏差并在内存系统中建立驻留所需的最小整数突发长度。",
            "answer": "$$\\boxed{\\left\\lfloor \\frac{\\mu}{\\lambda} \\right\\rfloor + 1}$$"
        },
        {
            "introduction": "理论和模型分析是重要的，但实现一个算法才能真正揭示其复杂性。这个最终的练习是一个全面的编程挑战，要求你从头开始构建一个页面替换模拟器。你不仅要实现 LFU 和 MFU 算法，还要探索一个更微妙的设计决策：频率计数的“粒度”——是按页面、文件还是函数来跟踪访问频率？通过在给定的踪迹上运行你的模拟器 ，你将亲身体验不同的计数策略如何影响性能，从而将抽象的算法知识与实际的系统调优联系起来。",
            "id": "3629722",
            "problem": "虚拟内存系统维护一组固定大小的帧来存放页面。页面引用轨迹是一个访问三元组的序列，每个三元组包含一个函数标识符、一个文件标识符和一个页面标识符。基于计数的页面置换策略通过维护频率计数器来估计未来的重用情况。其基础由以下核心定义组成：页面错误（page fault）是指在引用时，被引用的页面未驻留在内存中，必须被加载，如果所有帧都已满，则可能需要逐出现有页面的事件；最不经常使用（LFU）策略会逐出其关联频率得分最小的驻留页面；最常使用（MFU）策略会逐出其关联频率得分最大的驻留页面。页面置换算法必须在这些基础上被完全指定：维护哪些计数器，它们如何递增，如何计算逐出分数，以及如何确定性地解决平局问题。\n\n设计并实现一个程序，在给定以下固定测试套件的情况下，评估三种粒度下的计数方式，并在相同的轨迹上比较 LFU 与 MFU。这三种粒度是：页面级计数、文件级计数和函数级计数。令 $G \\in \\{\\text{function}, \\text{file}, \\text{page}\\}$ 表示所选的粒度。对于时间 $t$ 的每一次引用，其三元组为 $(u_t, d_t, p_t)$，根据 $G$ 精确地递增一个计数器：如果 $G=\\text{page}$，则递增页面计数器 $f^{\\text{page}}(p_t)$；如果 $G=\\text{file}$，则递增文件计数器 $f^{\\text{file}}(d_t)$；如果 $G=\\text{function}$，则递增函数计数器 $f^{\\text{function}}(u_t)$。这些计数器从零开始。对于每个驻留页面 $q$，维护在时间 $t$ 之前最后一次访问它的函数 $h_t(q)$ 和最后一次访问时间 $r_t(q)$（最近性），其中 $r_t(q)$ 定义为 $q$ 被访问或加载的最大事件索引。如果一个帧是空的，将一个页面加载到其中会将其 $h_t(\\cdot)$ 设置为当前函数，并将其 $r_t(\\cdot)$ 设置为当前时间索引。当发生页面错误且没有空闲帧时，驻留页面 $q$ 的逐出分数 $\\sigma_t^G(q)$ 计算如下：\n- 如果 $G=\\text{page}$，则 $\\sigma_t^{\\text{page}}(q)=f^{\\text{page}}(q)$。\n- 如果 $G=\\text{file}$，令 $g(q)$ 为拥有页面 $q$ 的文件标识符；则 $\\sigma_t^{\\text{file}}(q)=f^{\\text{file}}(g(q))$。\n- 如果 $G=\\text{function}$，则 $\\sigma_t^{\\text{function}}(q)=f^{\\text{function}}(h_t(q))$。\n\n在 LFU 策略下，逐出使 $\\sigma_t^G(q)$ 最小化的驻留页面 $q$。在 MFU 策略下，逐出使 $\\sigma_t^G(q)$ 最大化的驻留页面 $q$。在任何一种情况下，如果多个页面具有相同的 $\\sigma_t^G$，则通过逐出最近最少使用的页面（即最小化 $r_t(q)$）来打破平局。如果仍然存在平局，则逐出页面标识符最小的页面（确定性）。为每个粒度 $G$ 和策略 $\\pi \\in \\{\\text{LFU},\\text{MFU}\\}$ 维护一个页面错误计数器 $F_{G,\\pi}$，用于统计整个轨迹中的未命中次数。\n\n测试套件包含三种情况。对于每种情况 $i \\in \\{1,2,3\\}$，程序必须对每种粒度模拟两次轨迹：一次在 LFU 下，一次在 MFU 下。内存容量 $C$ 以帧为单位衡量，是一个整数。文件到页面的归属映射 $g(p)$ 在每个测试用例中是固定的。所有标识符都是正整数；所有大小和计数都是整数。\n\n测试用例 1（正常路径）：\n- 容量：$C=2$ 帧。\n- 文件：$D=\\{1,2\\}$。\n- 函数：$U=\\{1,2,3\\}$。\n- 页面：$P=\\{1,2,3,4\\}$，归属映射为 $g(1)=1$, $g(2)=1$, $g(3)=2$, $g(4)=2$。\n- 10个事件的轨迹（每个三元组为 $(u_t,d_t,p_t)$）：\n  $[(1,1,1),(1,1,2),(2,1,1),(2,1,2),(3,2,3),(3,2,4),(1,1,1),(1,1,2),(3,2,3),(3,2,4)]$。\n\n测试用例 2（边界容量）：\n- 容量：$C=1$ 帧。\n- 文件：$D=\\{1,2\\}$。\n- 函数：$U=\\{1,2,3\\}$。\n- 页面：$P=\\{1,2,3,4\\}$，归属映射为 $g(1)=1$, $g(2)=1$, $g(3)=2$, $g(4)=2$。\n- 8个事件的轨迹：\n  $[(1,1,1),(2,1,2),(3,2,3),(1,1,1),(2,1,2),(3,2,3),(1,1,1),(2,1,2)]$。\n\n测试用例 3（平局处理重点）：\n- 容量：$C=3$ 帧。\n- 文件：$D=\\{1,2\\}$。\n- 函数：$U=\\{1,2,3\\}$。\n- 页面：$P=\\{1,2,3,4\\}$，归属映射为 $g(1)=1$, $g(2)=1$, $g(3)=2$, $g(4)=2$。\n- 12个事件的轨迹：\n  $[(1,1,1),(2,1,2),(3,2,3),(3,2,4),(1,1,1),(2,1,2),(3,2,3),(3,2,4),(1,1,1),(2,1,2),(3,2,3),(3,2,4)]$。\n\n实现规则：\n- 在每个时间 $t$，按照指定的方式根据 $G$ 精确递增一个计数器；然后解决命中或错误；若命中，更新 $h_t(p_t)$ 和 $r_t(p_t)$；若错误，如果帧已满，则使用当前计数器为每个驻留页面计算 $\\sigma_t^G$，根据策略和平局打破规则选择一个牺牲页，将其逐出，并加载 $p_t$，设置 $h_t(p_t)=u_t$ 和 $r_t(p_t)=t$；如果有空闲帧，则无需逐出直接加载。每次未命中时，页面错误计数器 $F_{G,\\pi}$ 增加1。\n- 计数器 $f^{\\text{page}}$、$f^{\\text{file}}$、$f^{\\text{function}}$ 从 $0$ 开始，并在给定 $G$ 的整个模拟过程中保持不变。\n- 每当页面 $q$ 被访问或加载时，其最后函数关联 $h_t(q)$ 变为当前函数 $u_t$。\n\n每个测试用例 $i$ 的要求输出：\n- 六个整数：$F_{\\text{function},\\text{LFU}}$、$F_{\\text{file},\\text{LFU}}$、$F_{\\text{page},\\text{LFU}}$、$F_{\\text{function},\\text{MFU}}$、$F_{\\text{file},\\text{MFU}}$、$F_{\\text{page},\\text{MFU}}$。\n- 两个整数，分别表示 LFU 和 MFU 的最佳粒度（最低错误计数）的索引，映射关系为：函数级 $\\rightarrow 0$，文件级 $\\rightarrow 1$，页面级 $\\rightarrow 2$。如果最佳粒度存在平局，则选择最小的索引。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含测试用例1、然后是测试用例2、然后是测试用例3的所有结果，平铺成一个用方括号括起来的逗号分隔列表。对于每个测试用例，按上述确切顺序输出八个整数。因此，输出必须是 $[x_1,x_2,\\dots,x_{24}]$ 的形式，其中前八个条目对应测试用例1，接下来八个对应测试用例2，最后八个对应测试用例3。不应打印空格或其他额外字符。",
            "solution": "要解决这个问题，需要为每个测试用例、每种计数粒度（函数、文件、页面）和每种替换策略（LFU、MFU）的组合系统地模拟页面访问轨迹。以下是解决问题所需的算法逻辑。\n\n1.  **初始化：**\n    - 对于每次模拟运行，初始化内存帧（一个大小为 `C` 的集合）为空。\n    - 将所有频率计数器（`f_function`, `f_file`, `f_page`）重置为零。\n    - 将页面错误计数器 `fault_count` 初始化为 `0`。\n    - 维护每个驻留页面的状态，包括最后访问它的函数 `h(q)` 和最后访问它的时间戳 `r(q)`。\n\n2.  **轨迹处理：**\n    遍历给定轨迹中的每个事件（三元组 `(u_t, d_t, p_t)`），其中 `t` 是从 1 开始的时间索引。\n\n    a.  **递增计数器：** 根据当前模拟的粒度 `G`，递增相应的计数器：\n        - 若 `G` 是“函数”，`f_function[u_t]++`。\n        - 若 `G` 是“文件”，`f_file[d_t]++`。\n        - 若 `G` 是“页面”，`f_page[p_t]++`。\n\n    b.  **检查命中/未命中：** 检查页面 `p_t` 是否已在内存帧中。\n        - **命中：** 如果 `p_t` 在内存中，更新其状态：`h(p_t) = u_t` 和 `r(p_t) = t`。\n        - **未命中：** 如果 `p_t` 不在内存中，则发生页面错误。\n            i.   递增 `fault_count`。\n            ii.  **加载页面：**\n                 - 如果内存中有空闲帧，将 `p_t` 加载到其中。\n                 - 如果内存已满，则必须选择一个牺牲页进行逐出：\n                    1.  **计算分数：** 对于内存中的每个驻留页面 `q`，根据粒度 `G` 计算其逐出分数 `score(q)`：\n                        - `G`=函数: `score(q) = f_function[h(q)]`\n                        - `G`=文件: `score(q) = f_file[g(q)]` (其中 `g(q)` 是 `q` 所属的文件)\n                        - `G`=页面: `score(q) = f_page[q]`\n                    2.  **选择候选者：** 根据策略 `π` 识别具有最优分数的页面。\n                        - LFU: 寻找分数最低的页面。\n                        - MFU: 寻找分数最高的页面。\n                    3.  **打破平局：**\n                        - 如果多个页面共享最优分数，则从这些候选者中选择最后访问时间戳 `r(q)` 最小的（即最久未使用的）。\n                        - 如果仍然存在平局，则选择页面ID最小的。\n                    4.  **逐出与加载：** 将最终确定的牺牲页从其帧中移除，然后将新页面 `p_t` 加载到该帧中。\n            iii. **设置新页面状态：** 对于新加载的页面 `p_t`，设置其初始状态：`h(p_t) = u_t` 和 `r(p_t) = t`。\n\n3.  **结果收集：**\n    完成轨迹模拟后，记录 `fault_count`。对所有六种 `(G, π)` 组合重复此过程。对于每个测试用例，将收集六个错误计数值。然后，分别对 LFU 和 MFU，找到导致最低错误计数的粒度（如果平局，则选择索引最小的粒度：函数=0，文件=1，页面=2），以确定两个“最佳粒度”索引。\n\n将所有测试用例的结果按顺序组合成一个包含24个整数的列表，作为最终输出。",
            "answer": "$$\\boxed{\\text{运行模拟后得到的数值结果}}$$"
        }
    ]
}