{
    "hands_on_practices": [
        {
            "introduction": "在分析复杂场景之前，我们必须首先巩固对附加参考位（ARB）算法核心机制的理解。这个练习将引导你从第一性原理出发，证明该算法的$k$位寄存器实际上编码了最近$k$个时间间隔的引用历史。通过这个推导，你将对算法的“记忆”以及它如何量化“近期性”有一个精确的数学认识，为后续更复杂的分析奠定基础。",
            "id": "3619905",
            "problem": "考虑一个操作系统，它为页面置换实现了附加参考位（ARB）算法，该算法近似于最近最少使用（LRU）算法。对于每个页面 $i$，ARB 算法维护一个 $k$ 位的寄存器 $R_i$，并每隔 $\\Delta t$ 秒使用一次周期性定时器中断。寄存器 $R_i$ 初始化为全 $0$ 位。在时间索引 $t \\in \\{1, 2, \\dots, n\\}$ 的每次中断期间，该算法执行以下操作：它将 $R_i$ 右移一位，丢弃最低有效位，然后将每个时间间隔的参考位 $r_i(t) \\in \\{0, 1\\}$ 写入 $R_i$ 的最高有效位位置。在第 $n$ 次更新后，算法将 $R_i$ 解释为一个无符号二进制整数，记为 $V_i$，用于对页面进行置换排序。\n\n仅从 ARB 算法的这些操作性定义（初始化、移位、插入 $r_i(t)$ 和无符号解释）出发，并假设 $n \\geq k$，执行以下操作：\n\n- 证明在第 $n$ 次更新后，$R_i$ 的内容精确地编码了二进制参考历史 $\\{r_i(1), r_i(2), \\dots, r_i(n)\\}$ 的最后 $k$ 位，且这些位按时间顺序排列，其中 $r_i(n)$ 占据 $R_i$ 的最高有效位。\n\n- 使用该解释，准确地描述两个不同的长度为 $n$ 的二进制参考历史在第 $n$ 次更新后产生相同无符号值 $V_i$ 的确切条件。\n\n- 以 $n$ 和 $k$ 的函数闭合形式，计算映射到第 $n$ 次更新后固定值 $V_i$ 的不同长度为 $n$ 的二进制参考历史的数量。\n\n将您的最终答案表示为关于 $n$ 和 $k$ 的单个闭合形式解析表达式。无需四舍五入，也无需单位。",
            "solution": "该问题已经过验证，被认为是合理的。它在科学上基于操作系统算法的原理，问题表述清晰，对附加参考位（ARB）算法有明确和形式化的定义，并且语言客观。所提供的信息是自洽的，足以进行严格的推导。我们可以开始求解。\n\n问题要求对 ARB 算法下 $k$ 位寄存器 $R_i$ 的状态进行三项相关分析。我们将系统地解决每个部分。设寄存器 $R_i$ 在第 $t$ 次更新后的状态为一个位向量 $R_i^{(t)} = (b_{k-1}^{(t)}, b_{k-2}^{(t)}, \\dots, b_0^{(t)})$，其中 $b_{k-1}^{(t)}$ 是最高有效位（MSB），$b_0^{(t)}$ 是最低有效位（LSB）。寄存器初始化为全 $0$，即 $R_i^{(0)} = (0, 0, \\dots, 0)$。在每个时间步 $t \\in \\{1, 2, \\dots, n\\}$，更新操作包括一次右移，然后将参考位 $r_i(t)$ 插入 MSB 位置。这个操作可以用以下递推关系描述：\n$b_{k-1}^{(t)} = r_i(t)$\n$b_{j}^{(t)} = b_{j+1}^{(t-1)}$ for $j \\in \\{0, 1, \\dots, k-2\\}$.\n\n首先，我们证明第 $n$ 次更新后 $R_i$ 的内容。让我们追踪寄存器位的状态。\n在 $t=1$ 时：寄存器右移，仍为 $(0, \\dots, 0)$，然后插入 $r_i(1)$。所以，$R_i^{(1)} = (r_i(1), 0, \\dots, 0)$。\n在 $t=2$ 时：$R_i^{(1)}$ 右移得到 $(0, r_i(1), 0, \\dots, 0)$。然后插入 $r_i(2)$。所以，$R_i^{(2)} = (r_i(2), r_i(1), 0, \\dots, 0)$。\n通过归纳法，我们可以确定 $t$ 次更新后寄存器中位 $b_j^{(t)}$ 的一般形式。让我们展开在 $t=n$ 时状态的递推关系。\nMSB，$b_{k-1}^{(n)}$，在第 $n$ 步被设置为 $r_i(n)$。\n$b_{k-1}^{(n)} = r_i(n)$。\n下一位，$b_{k-2}^{(n)}$，从前一个状态的 MSB，$b_{k-1}^{(n-1)}$，接收其值。\n$b_{k-2}^{(n)} = b_{k-1}^{(n-1)} = r_i(n-1)$。\n类似地，位 $b_{k-3}^{(n)}$ 从 $b_{k-2}^{(n-1)}$ 接收其值，而 $b_{k-2}^{(n-1)}$ 又来自 $b_{k-1}^{(n-2)}$。\n$b_{k-3}^{(n)} = b_{k-2}^{(n-1)} = b_{k-1}^{(n-2)} = r_i(n-2)$。\n推广这个模式，经过 $n$ 次更新后，位置 $j$ 上的位（其中 LSB 是位置 $0$）$b_j^{(n)}$，是 $k-1-j$ 步前处于 MSB 位置的值。也就是说，是在时间 $n-(k-1-j) = n-k+1+j$ 插入的值。\n让我们用另一种索引约定来验证这一点。对于 $m \\in \\{0, 1, \\dots, k-1\\}$，位 $b_{k-1-m}^{(n)}$ 对应于在时间 $n$ 之前的 $m$ 步插入的参考位，即 $r_i(n-m)$。\n对于 $m=0$，$b_{k-1}^{(n)} = r_i(n)$。\n对于 $m=1$，$b_{k-2}^{(n)} = r_i(n-1)$。\n...\n对于 $m=k-1$，$b_{0}^{(n)} = r_i(n-(k-1)) = r_i(n-k+1)$。\n这是成立的，因为题目假设 $n \\geq k$，这确保了时间索引 $n-k+1$ 至少为 $1$。初始的 $0$ 位已完全被移出寄存器。\n因此，第 $n$ 次更新后寄存器的状态是：\n$$R_i^{(n)} = (r_i(n), r_i(n-1), \\dots, r_i(n-k+1))$$\n这表示参考历史 $\\{r_i(1), \\dots, r_i(n)\\}$ 的最后 $k$ 位。最新的位 $r_i(n)$ 占据最高有效位，并且这些位从 MSB 到 LSB 是按时间倒序排列的。题目的措辞“按时间顺序排列，其中 $r_i(n)$ 占据最高有效位”是定义布局的一个具体指令，我们的推导证实了这一点。\n\n其次，我们描述两个不同的二进制参考历史产生相同值 $V_i$ 的情况。一个历史是一个序列 $H = \\{r_i(1), r_i(2), \\dots, r_i(n)\\}$。值 $V_i$ 是最终寄存器状态 $R_i^{(n)}$ 的无符号二进制整数解释。\n$$V_i = \\sum_{j=0}^{k-1} b_j^{(n)} 2^j$$\n代入我们关于位 $b_j^{(n)}$ 的结果：\n$$V_i = b_{k-1}^{(n)}2^{k-1} + b_{k-2}^{(n)}2^{k-2} + \\dots + b_0^{(n)}2^0$$\n$$V_i = r_i(n)2^{k-1} + r_i(n-1)2^{k-2} + \\dots + r_i(n-k+1)2^0$$\n这个表达式表明，值 $V_i$ 仅取决于参考历史的最后 $k$ 位，即 $\\{r_i(n-k+1), r_i(n-k+2), \\dots, r_i(n)\\}$。来自前 $n-k$ 个参考位 $\\{r_i(1), \\dots, r_i(n-k)\\}$ 的任何信息都丢失了。\n因此，两个不同的历史 $H$ 和 $H'$ 产生相同的值 $V_i$，当且仅当它们的最后 $k$ 个参考位是相同的。也就是说，对于 $H = \\{r_i(1), \\dots, r_i(n)\\}$ 和 $H' = \\{r'_i(1), \\dots, r'_i(n)\\}$，条件 $V_i = V'_i$ 等价于：\n$$r_i(t) = r'_i(t) \\quad \\text{for all } t \\in \\{n-k+1, n-k+2, \\dots, n\\}$$\n由于规定历史是不同的 ($H \\neq H'$)，它们必须在至少一个前 $n-k$ 个参考位上有所不同。\n\n第三，我们计算映射到固定值 $V_i$ 的长度为 $n$ 的不同二进制参考历史的数量。一个固定的整数值 $V_i$（其中 $0 \\leq V_i  2^k$）有一个唯一的 $k$ 位二进制表示。这个唯一的位模式确定了寄存器 $R_i^{(n)}$ 所需的状态。\n根据我们的第一个结果，固定 $R_i^{(n)}$ 的状态等价于固定最后 $k$ 个参考位的值，即 $\\{r_i(n), r_i(n-1), \\dots, r_i(n-k+1)\\}$。\n一个历史是一个 $n$ 位的序列 $\\{r_i(1), r_i(2), \\dots, r_i(n)\\}$。为了映射到所选的 $V_i$，最后的 $k$ 位是确定的。然而，历史的前 $n-k$ 位 $\\{r_i(1), r_i(2), \\dots, r_i(n-k)\\}$ 不影响 $V_i$ 的最终值。这 $n-k$ 位中的每一位都可以独立地选择为 $0$ 或 $1$。\n$r_i(1)$ 的选择数量是 $2$。\n$r_i(2)$ 的选择数量是 $2$。\n...\n$r_i(n-k)$ 的选择数量是 $2$。\n不同历史的总数是这些独立位各自选择数量的乘积。因此，映射到固定值 $V_i$ 的长度为 $n$ 的参考历史的数量是：\n$$ \\underbrace{2 \\times 2 \\times \\dots \\times 2}_{n-k \\text{ times}} = 2^{n-k} $$\n这个结果与所选的 $V_i$ 的具体值无关。假设 $n \\geq k$ 确保了指数 $n-k$ 是一个非负整数。",
            "answer": "$$\\boxed{2^{n-k}}$$"
        },
        {
            "introduction": "理论是基础，但算法的价值最终体现在实践中。现在我们将理论应用于一个现代操作系统中常见且棘手的场景：大页（huge page）管理。这项动手编程练习要求你模拟当一个大页被拆分（降级）为其组成的基页时，ARB算法如何由于信息丢失而对内存使用情况做出错误判断。你将亲手量化这种“粗粒度”历史记录在“细粒度”访问模式下所造成的信息扭曲。",
            "id": "3619828",
            "problem": "你的任务是在一个真实的虚拟内存场景下严格评估 Additional Reference Bits (ARB) 算法，该场景涉及一个大内存页（巨页）被降级为多个基页。ARB 算法为每个页面维护一个 $k$ 位的年龄寄存器 $V_i$，该寄存器编码了引用的新近度（recency）和频率（frequency）。在每个以 $t \\in \\{1,2,\\dots,n\\}$ 为索引的离散时间间隔结束时，该实现会将每个 $V_i$ 右移一位，并将最近的引用位 $r_i(t) \\in \\{0,1\\}$ 作为最高有效位插入。这种设计在操作系统中被广泛使用，以利用硬件支持的引用位来近似实现页面替换策略。\n\n使用的基本前提和假设：\n- 虚拟内存由页面组成。一个巨页将 $M$ 个基页聚合为一个连续区域。\n- Additional Reference Bits (ARB) 算法通过为每个被跟踪的页面使用一个 $k$ 位的老化寄存器来近似其最近的使用历史。\n- 巨页降级操作将一个被跟踪的巨页替换为 $M$ 个单独跟踪的基页。一种常见的种子策略是将每个被降级的基页的寄存器初始化为该巨页当前的寄存器值。\n- 我们考虑一个巨页以及仅发生在该巨页内的引用。在每个时间间隔 $t$ 内，恰好有一次小内存访问，被访问的子页索引由一个确定性的、均匀的过程决定，除非另有说明。\n\n你的任务是模拟和量化当访问频繁但分散在整个巨页上时，ARB 算法在降级时刻如何未能捕获子页局部性。具体来说，你必须计算在降级时，因继承巨页的老化寄存器而被错误分类为“热”页的子页数量，并与一个从一开始就单独跟踪每个基页的基准情况进行比较。\n\n定义和度量：\n- 令 $n$ 为模拟的总时间间隔数。\n- 令 $M$ 为构成巨页的基页数量。\n- 令 $k$ 为 ARB 寄存器中的位数。\n- 令 $V_H$ 表示当作为一个单独页面跟踪时，巨页在时间 $n$ 的 ARB 寄存器值。\n- 令 $V_i^{\\text{base}}$ 表示当每个基页从一开始就单独跟踪时，基页 $i \\in \\{0,1,\\dots,M-1\\}$ 在时间 $n$ 的基准 ARB 寄存器。\n- 令 $V_i^{\\text{demote}}$ 表示降级后即刻的基页 $i$ 的 ARB 寄存器，其中种子策略为所有 $i$ 分配 $V_i^{\\text{demote}} := V_H$。\n- 定义“热”页阈值为 $\\theta := 2^{k-1}$。\n- 定义在时间 $n$ 的“热”页集合为 $H_{\\text{base}} := \\{i \\mid V_i^{\\text{base}} \\ge \\theta\\}$ 和 $H_{\\text{demote}} := \\{i \\mid V_i^{\\text{demote}} \\ge \\theta\\}$。\n- 你必须报告的错分情况是伪热页的数量，由 $\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right|$ 给出，是一个整数。\n\n引用生成：\n- 为了可重复性，使用一个确定性线性同余生成器，其递归式为 $x_{t+1} := (a x_t + c) \\bmod 2^{32}$，其中 $a := 1664525$，$c := 1013904223$，从指定的无符号种子 $x_0$ 开始。\n- 对于均匀分布，选择在时间 $t$ 被引用的子页索引为 $i_t := x_t \\bmod M$。\n- 对于集中访问，引入一个大小为 $s$ 的“热”集和概率 $p \\in (0,1)$：以概率 $p$ 均匀引用热集内的一个子页；以概率 $1-p$ 均匀引用其余 $M-s$ 个子页中的一个。使用该生成器进行伯努利决策和索引选择。\n\n程序要求：\n- 为巨页和基准的每子页跟踪实现 $n$ 个时间间隔的 ARB 更新。对于巨页，如果在时间间隔 $t$ 内巨页中的任何子页被引用，则该时间间隔的引用位为 $r_H(t) := 1$，在此设置中该值始终为 $1$。\n- 在时间 $n$（降级时刻），为所有 $i$ 设定 $V_i^{\\text{demote}} := V_H$，使用阈值 $\\theta$ 计算 $H_{\\text{base}}$ 和 $H_{\\text{demote}}$，并输出 $\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right|$。\n- 不要假设任何特定的硬件页面大小；将 $M$ 纯粹视为一个数量。\n- 角度、物理单位和百分比均不适用；所有输出都是无单位的整数。\n\n测试套件：\n运行以下四个测试用例并汇总它们的结果：\n1. 一般分布情况：$M = 128$，$k = 8$，$n = 256$，在子页上均匀分布，种子 $x_0 = 1$。\n2. 边界降级情况：$M = 1$，$k = 8$，$n = 256$，均匀分布，种子 $x_0 = 1$。\n3. 集中子页局部性：$M = 64$，$k = 8$，$n = 256$，热集大小 $s = 2$，概率 $p = 0.9$，种子 $x_0 = 42$。\n4. ARB 中的量化边缘：$M = 64$，$k = 3$，$n = 64$，均匀分布，种子 $x_0 = 7$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_j$ 是根据上述定义计算的测试用例 $j$ 的伪热页计数。",
            "solution": "该问题要求对 Additional Reference Bits (ARB) 页面老化算法进行分析，特别是关于当一个巨页被降级为其组成的基页时发生的信息损失。我们需要计算在降级后即刻被错误分类为“热”页的基页数量，并与一个从一开始就单独跟踪每个页面引用历史的基准情况进行比较。\n\nARB 算法的核心是页面 $i$ 的 $k$ 位老化寄存器 $V_i$ 的更新规则。在每个时间间隔 $t \\in \\{1, 2, \\dots, n\\}$ 结束时，寄存器会根据该时间间隔的引用位 $r_i(t) \\in \\{0, 1\\}$ 进行更新：\n$$\nV_i(t) = (V_i(t-1) \\gg 1) \\lor (r_i(t) \\ll (k-1))\n$$\n其中 $\\gg$ 表示按位右移，$\\ll$ 表示按位左移，$\\lor$ 表示按位或操作。我们假设寄存器初始化为 0，即 $V_i(0)=0$。\n\n问题要求我们在一个特定的时间点 $t=n$ 比较两种场景，该时间点代表了巨页的降级。\n\n场景 1：巨页跟踪\n为整个巨页（由 $M$ 个基页组成）维护一个单一的 ARB 寄存器 $V_H$。问题陈述中指出，每个时间间隔恰好访问一个子页。因此，整个巨页在每个时间间隔都被引用，这意味着它的引用位总是 $1$。因此，对于所有 $t \\in \\{1, 2, \\dots, n\\}$，都有 $r_H(t) = 1$。\n$V_H$ 的更新规则是：\n$$\nV_H(t) = (V_H(t-1) \\gg 1) \\lor (1 \\ll (k-1))\n$$\n从 $V_H(0) = 0$ 开始，经过 $n$ 步后，$V_H(n)$ 的值是 2 的幂次之和：\n$$\nV_H(n) = \\sum_{j=0}^{\\min(n, k)-1} 2^{k-1-j}\n$$\n这是一个可以计算出闭式解的等比级数。对于 $n \\ge k$，寄存器将被 1 填满，因此 $V_H(n) = 2^k - 1$。对于 $n  k$，其值为 $V_H(n) = (2^k - 1) - (2^{k-n} - 1) = 2^k-2^{k-n}$。在所有测试用例中，$n \\ge k$，所以 $V_H(n) = 2^k - 1$。\n\n降级时，每个基页都继承这个寄存器值：对于所有 $i \\in \\{0, 1, \\dots, M-1\\}$，$V_i^{\\text{demote}} = V_H(n)$。\n\n场景 2：基准单独跟踪\n在此场景中，从一开始就为 $M$ 个基页中的每一个维护一个单独的 ARB 寄存器 $V_i^{\\text{base}}$。对于每个时间间隔 $t$，会访问一个子页 $i_t$。其引用位为 $r_{i_t}(t)=1$，而对于所有其他页面 $j \\neq i_t$，引用位为 $r_j(t)=0$。寄存器会相应地更新：\n$$\nV_{i_t}^{\\text{base}}(t) = (V_{i_t}^{\\text{base}}(t-1) \\gg 1) \\lor (1 \\ll (k-1))\n$$\n$$\nV_j^{\\text{base}}(t) = (V_j^{\\text{base}}(t-1) \\gg 1) \\lor (0 \\ll (k-1)) = (V_j^{\\text{base}}(t-1) \\gg 1) \\quad \\text{for } j \\neq i_t\n$$\n这个过程必须模拟 $n$ 步，以找到最终值 $V_i^{\\text{base}}(n)$。被访问页面的序列 $i_1, i_2, \\dots, i_n$ 由指定的线性同余生成器 (LCG) 决定。\n\n错分分析\n如果一个页面 $i$ 的寄存器值大于或等于阈值 $\\theta = 2^{k-1}$，则它被定义为“热”页。在降级模型下，“热”页的集合是 $H_{\\text{demote}} = \\{i \\mid V_i^{\\text{demote}} \\ge \\theta\\}$，对于基准模型则是 $H_{\\text{base}} = \\{i \\mid V_i^{\\text{base}} \\ge \\theta\\}$。我们需要找到伪热页的数量，即集合差的基数 $\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right|$。\n\n让我们来分析一个页面成为“热”页的条件。一个 $k$ 位的数大于或等于 $2^{k-1}$ 当且仅当其最高有效位 (MSB) 为 $1$。让我们检查 $V_i(t)$ 的 MSB：\n$(V_i(t-1) \\gg 1)$ 的 MSB 总是 $0$。\n$(r_i(t) \\ll (k-1))$ 的 MSB 恰好是 $r_i(t)$。\n按位或操作意味着 $V_i(t)$ 的 MSB 是 $0 \\lor r_i(t) = r_i(t)$。\n因此，$V_i(t) \\ge \\theta$ 当且仅当 $r_i(t) = 1$。\n\n这提供了一个关键的洞见。在时间 $n$，基准模型中的页面 $i$ 是“热”页，当且仅当它在最后一个时间间隔 $t=n$ 被引用。由于在时间 $n$ 恰好只有一个页面 $i_n$ 被引用，所以基准“热”集是 $H_{\\text{base}} = \\{i_n\\}$。它只包含一个元素。\n\n对于降级模型，$V_i^{\\text{demote}} = V_H(n)$。正如我们已经确定的，对于所有测试用例，$V_H(n) = 2^k - 1$。阈值是 $\\theta = 2^{k-1}$。由于对于任何 $k \\ge 1$ 都有 $2^k - 1 \\ge 2^{k-1}$，所有被降级的页面都被分类为“热”页。因此，$H_{\\text{demote}} = \\{0, 1, \\dots, M-1\\}$。\n\n因此，伪热页的数量为：\n$$\n\\left|H_{\\text{demote}} \\setminus H_{\\text{base}}\\right| = \\left| \\{0, 1, \\dots, M-1\\} \\setminus \\{i_n\\} \\right|\n$$\n对于 $M > 1$，这个计数是 $M - 1$。对于 $M=1$ 的边界情况，巨页就是基页，因此 $H_{\\text{demote}}=H_{\\text{base}}=\\{0\\}$，计数为 $1-1=0$。\n\n尽管我们已经分析地推导出了结果，但问题指示我们执行模拟。因此，C 代码将实现对基准寄存器在 $n$ 个时间步长内的完整模拟，然后计算满足条件的页面数量，这可作为我们分析性洞见的程序性验证。\n\n每个测试用例的模拟将按如下方式进行：\n1. 将一个包含 $M$ 个基准寄存器 `V_base[i]` 的数组初始化为 $0$。\n2. 用种子 $x_0$ 初始化 LCG 状态 `x`。\n3. 对 $t$ 从 $1$ 到 $n$ 进行循环：\n   a. 更新 LCG 状态：$x \\leftarrow (a \\cdot x + c) \\pmod{2^{32}}$。\n   b. 根据 $x$ 和访问模式（均匀或集中）确定被访问的页面索引 $i_t$。\n   c. 根据 ARB 规则更新所有 $M$ 个基准寄存器，使用 $r_{i_t}(t)=1$ 和对于 $j \\neq i_t$ 的 $r_j(t)=0$。\n4. $n$ 步之后，计算阈值 $\\theta = 2^{k-1}$。\n5. 由于在所有情况下 $V_H(n) \\ge \\theta$，每个被降级的页面都是“热”页。错分页面的数量是那些不是“热”页的基准页面的数量。\n6. 统计 $V_i^{\\text{base}}(n)  \\theta$ 的索引 $i$ 的数量。这个计数是该测试用例的最终结果。\n这个过程忠实地实现了所述场景，并将得出分析预测的结果。",
            "answer": "[127, 0, 63, 63]"
        },
        {
            "introduction": "一个算法在真实世界中的性能，还取决于其对底层硬件不完美性的“容忍度”。最后的这个练习将探讨ARB算法在面对随机硬件噪声时的稳健性。通过概率分析，你将推导出一个从未被实际访问的“冷”页面，其年龄值$V_i$会因为这些虚假的引用信号而期望“膨胀”多少。这能让你深刻理解算法在非理想条件下的行为偏差。",
            "id": "3619934",
            "problem": "一个虚拟内存系统实现了附加引用位（ARB）页面置换算法。对于每个页面 $i$，ARB 维护一个 $k$ 位寄存器，其无符号整数解释表示为 $V_i$。在每个采样周期结束时，该算法对每个页面执行以下更新：将 $k$ 位寄存器右移 $1$ 位，丢弃最低有效位，将当前的硬件引用位 $R_i$ 插入最高有效位，然后清除 $R_i$。因此，越近期的引用对 $V_i$ 的贡献权重越高的位。\n\n考虑一个真正的冷页面，意味着它从未被任何进程实际引用过。然而，假设硬件引用位 $R_i$ 会因随机噪声而被虚假地设置：在每个采样周期中，$R_i$ 以概率 $\\epsilon$ 被设置为 1，否则保持为 0，且每个周期之间相互独立。假设该页面的 ARB 寄存器初始化为 0。\n\n仅使用 ARB 更新机制的核心定义和初等概率（期望的线性性和独立性），推导经过 $M$ 次 ARB 更新后 $V_i$ 的期望值的闭式表达式，该表达式是关于 $\\epsilon$、$k$ 和 $M$ 的函数。然后，取 $M \\to \\infty$ 的极限，以获得这样一个冷页面的 $V_i$ 的稳态期望虚增值。请用一个关于 $\\epsilon$ 和 $k$ 的单一闭式解析表达式来表示你的最终答案。不要对答案进行四舍五入。",
            "solution": "问题要求在一个附加引用位（ARB）页面置换系统中，一个会受到虚假位设置影响的 $k$ 位寄存器 $V_i$ 的稳态期望值。推导过程将首先建立寄存器经过 $M$ 次更新后其值的形式化表示，然后计算其期望值，最后取 $M \\to \\infty$ 的极限。\n\n设 $V_i(t)$ 为页面 $i$ 的 $k$ 位寄存器在 $t$ 次更新后的无符号整数值。初始状态给定为 $V_i(0)=0$。该寄存器由 $k$ 个位组成，我们将其表示为 $b_{k-1}(t), b_{k-2}(t), \\ldots, b_0(t)$，其中 $b_{k-1}$ 是最高有效位（MSB），$b_0$ 是最低有效位（LSB）。在时间 $t$ 时寄存器的值由标准的二进制到整数转换给出：\n$$V_i(t) = \\sum_{j=0}^{k-1} b_j(t) 2^j$$\n在每个采样周期 $t \\in \\{1, 2, \\ldots, M\\}$ 结束时执行的 ARB 更新机制由两个操作定义：\n$1$. 寄存器向右移动一位。这意味着位置 $j$ 的位从前一状态下位置 $j+1$ 的位获取其新值：对于所有 $j \\in \\{0, 1, \\ldots, k-2\\}$，$b_j(t) = b_{j+1}(t-1)$。\n$2$. MSB 用当前周期的硬件引用位 $R_i(t)$ 的值进行更新：$b_{k-1}(t) = R_i(t)$。\n\n对于所讨论的冷页面，引用位 $R_i(t)$ 被建模为独立的伯努利随机变量，对于每个周期 $t$，$P(R_i(t)=1) = \\epsilon$ 且 $P(R_i(t)=0) = 1-\\epsilon$。因此，每个引用位的期望值为 $E[R_i(t)] = 1 \\cdot P(R_i(t)=1) + 0 \\cdot P(R_i(t)=0) = \\epsilon$。\n\n为了找出 $M$ 次更新后的值 $V_i(M)$，我们必须确定每个位 $b_j(M)$ 的值。我们可以通过重复应用更新规则来追溯每个位的来源：\n$$b_j(M) = b_{j+1}(M-1) = b_{j+2}(M-2) = \\ldots = b_{j+s}(M-s)$$\n我们可以将位置 $j$ 的位追溯回 $s = k-1-j$ 步时间，此时它的祖先是位置 $k-1$ 处的 MSB：\n$$b_j(M) = b_{k-1}(M - (k-1-j)) = R_i(M - k + 1 + j)$$\n这个关系成立的条件是引用位的时间索引为正，即 $M - k + 1 + j \\ge 1$，可简化为 $M+j \\ge k$。\n\n如果 $M+j  k$，则追溯在 $M$ 次更新内不会到达一个 MSB。相反，我们将该位的起源追溯到 $t=0$ 时的初始状态：\n$$b_j(M) = b_{j+1}(M-1) = \\ldots = b_{j+M}(M-M) = b_{j+M}(0)$$\n由于条件是 $M+j  k$，索引 $j+M$ 是一个有效的位位置（即 $j+M  k$）。初始条件 $V_i(0)=0$ 意味着所有初始位都为零，因此 $b_{j+M}(0) = 0$。因此，对于 $M+j  k$，我们有 $b_j(M) = 0$。\n\n结合这两种情况，$M$ 次更新后位 $j$ 的状态是：\n$$b_j(M) = \\begin{cases} R_i(M - k + 1 + j)  \\text{if } M+j \\ge k \\\\ 0  \\text{if } M+j  k \\end{cases}$$\n条件 $M+j \\ge k$ 等价于 $j \\ge k-M$。我们现在可以写出 $V_i(M)$ 的表达式：\n$$V_i(M) = \\sum_{j=0}^{k-1} b_j(M) 2^j = \\sum_{j=\\max(0, k-M)}^{k-1} R_i(M - k + 1 + j) 2^j$$\n问题要求的是 $V_i(M)$ 的期望值。利用期望的线性性，我们有：\n$$E[V_i(M)] = E\\left[ \\sum_{j=\\max(0, k-M)}^{k-1} R_i(M - k + 1 + j) 2^j \\right] = \\sum_{j=\\max(0, k-M)}^{k-1} E[R_i(M - k + 1 + j)] 2^j$$\n对于所有 $t$ 代入 $E[R_i(t)] = \\epsilon$：\n$$E[V_i(M)] = \\sum_{j=\\max(0, k-M)}^{k-1} \\epsilon \\cdot 2^j = \\epsilon \\sum_{j=\\max(0, k-M)}^{k-1} 2^j$$\n这个和是一个等比级数。设下界为 $a = \\max(0, k-M)$，上界为 $b = k-1$。等比级数 $\\sum_{j=a}^{b} r^j$ 的和由 $\\frac{r^a - r^{b+1}}{1-r}$ 给出。对于 $r=2$，这简化为 $2^{b+1} - 2^a$。\n代入我们的 $a$ 和 $b$ 的界限：\n$$\\sum_{j=\\max(0, k-M)}^{k-1} 2^j = 2^{(k-1)+1} - 2^{\\max(0, k-M)} = 2^k - 2^{\\max(0, k-M)}$$\n因此，$M$ 次更新后期望值的闭式表达式是：\n$$E[V_i(M)] = \\epsilon \\left(2^k - 2^{\\max(0, k-M)}\\right)$$\n最后一步是通过取 $M \\to \\infty$ 的极限来找到稳态期望值：\n$$E[V_i]_{\\text{steady-state}} = \\lim_{M \\to \\infty} E[V_i(M)] = \\lim_{M \\to \\infty} \\left[ \\epsilon \\left(2^k - 2^{\\max(0, k-M)}\\right) \\right]$$\n当 $M \\to \\infty$ 时，项 $k-M \\to -\\infty$。因此，对于任何 $M \\ge k$，$\\max(0, k-M)$ 变为 $0$。\n因此，项 $2^{\\max(0, k-M)}$ 的极限是：\n$$\\lim_{M \\to \\infty} 2^{\\max(0, k-M)} = 2^0 = 1$$\n将此结果代入期望值的极限中：\n$$E[V_i]_{\\text{steady-state}} = \\epsilon (2^k - 1)$$\n这个值表示一个冷页面的 ARB 计数器的稳态期望虚增值，这完全是由引用位中的随机噪声引起的。",
            "answer": "$$\\boxed{\\epsilon (2^k - 1)}$$"
        }
    ]
}