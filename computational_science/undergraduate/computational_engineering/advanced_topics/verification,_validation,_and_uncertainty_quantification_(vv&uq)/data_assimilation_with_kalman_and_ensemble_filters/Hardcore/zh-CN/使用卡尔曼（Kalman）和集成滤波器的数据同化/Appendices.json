{
    "hands_on_practices": [
        {
            "introduction": "要掌握数据同化，一个理想的起点是将其应用于一个清晰且具体的物理问题。本练习将指导您使用卡尔曼滤波器来估计GPS卫星时钟相对于主时钟的偏差和漂移。通过将一个物理系统（一个有时钟误差的卫星）转化为线性状态空间模型，您将亲手实践卡尔曼滤波器的核心预测-更新循环。完成此任务将为您掌握跟踪动态系统的基本工具——卡尔曼滤波器的核心机制——打下坚实的基础。",
            "id": "2382578",
            "problem": "考虑一个全球定位系统（GPS）卫星，其时钟相对于主时钟在离散时间 $t_k$（单位：秒）由一个未知的时钟偏差 $b_k$（单位：秒）和一个未知的时钟漂移 $d_k$（单位：秒/秒）建模。隐藏状态为 $x_k = \\begin{bmatrix} b_k \\\\ d_k \\end{bmatrix}$。卫星时钟遵循一个线性状态演化模型\n$$\n\\begin{aligned}\nb_{k+1} = b_k + d_k \\,\\Delta t_k + w_{b,k},\\\\\nd_{k+1} = d_k + w_{d,k},\n\\end{aligned}\n$$\n其中 $\\Delta t_k = t_{k+1} - t_k$，过程噪声 $w_{b,k}$ 和 $w_{d,k}$ 是相互独立的零均值高斯噪声，其方差分别为 $\\operatorname{Var}(w_{b,k}) = q_b \\,\\Delta t_k$ 和 $\\operatorname{Var}(w_{d,k}) = q_d \\,\\Delta t_k$。在时间 $t_k$ 的伪距残差测量值 $z_k$（单位：米）与时钟偏差的关系如下\n$$\nz_k = c\\, b_k + v_k,\n$$\n其中 $c = 299792458$（单位：米/秒）是光速，$v_k$ 是零均值高斯噪声，其方差为 $\\operatorname{Var}(v_k) = r^2$（单位：米平方）。初始状态是高斯分布，其均值为 $m_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$，协方差为 $P_0 = \\operatorname{diag}\\!\\big((10^{-6})^2, (10^{-10})^2\\big)$。\n\n任务：对于下方的每个测试用例，给定时间戳 $t_k$、测量值 $z_k$ 以及参数 $r$、$q_b$ 和 $q_d$，计算最终时刻状态的后验均值（即，在给定截至最后一个测量值的所有测量值的条件下，对 $\\begin{bmatrix} b_T \\\\ d_T \\end{bmatrix}$ 的最小均方误差估计）。将最终估计值 $b_T$（单位：秒）和 $d_T$（单位：秒/秒）表示为浮点数，输出中不含单位符号。\n\n测试套件：\n- 用例 A:\n  - 时间（秒）：$[0, 1, 2, 3, 4, 5]$。\n  - 测量值（米）：$[34.775095, 36.924783647, 37.874472334, 36.624161021, 38.073849708, 37.823538395]$。\n  - 测量噪声标准差（米）：$r = 2.0$。\n  - 过程噪声强度：$q_b = 1.0 \\times 10^{-20}$，$q_d = 1.0 \\times 10^{-22}$。\n\n- 用例 B:\n  - 时间（秒）：$[0, 1, 2, 3, 4, 5]$。\n  - 测量值（米）：$[24.18339664, 23.88339664, 24.38339664, 23.68339664, 23.98339664, 24.08339664]$。\n  - 测量噪声标准差（米）：$r = 1.0$。\n  - 过程噪声强度：$q_b = 1.0 \\times 10^{-22}$，$q_d = 1.0 \\times 10^{-24}$。\n\n- 用例 C:\n  - 时间（秒）：$[0, 2, 3.5, 7.0, 7.5, 10.0]$。\n  - 测量值（米）：$[11.9896229, 17.4296644084, 13.3846955397, 15.7797681794, 14.7647785565, 12.689830442]$。\n  - 测量噪声标准差（米）：$r = 5.0$。\n  - 过程噪声强度：$q_b = 5.0 \\times 10^{-20}$，$q_d = 1.0 \\times 10^{-20}$。\n\n- 用例 D:\n  - 时间（秒）：$[0, 0.5, 1.0, 1.5, 2.0]$。\n  - 测量值（米）：$[0.05, 0.729481145, 1.50896229, 2.218443435, 2.99792458]$。\n  - 测量噪声标准差（米）：$r = 0.1$。\n  - 过程噪声强度：$q_b = 1.0 \\times 10^{-22}$，$q_d = 1.0 \\times 10^{-18}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个用例的结果，形式为配对列表，顺序与上述用例列表相同。每对是估计的最终偏差和漂移，即 $[b_T, d_T]$。因此，总输出必须是方括号中的四个配对的单个列表，例如文本结构 \"[[...,...],[...,...],[...,...],[...,...]]\"，不添加空格或打印额外文本。输出中的所有数值如上所述，分别代表秒和秒/秒。",
            "solution": "该问题要求在给定一系列测量值的情况下，计算一个线性动态系统的状态向量的后验均值。这是一个经典的状态估计问题，其最小均方误差意义下的最优解由卡尔曼滤波器提供。该系统是线性的，并且所有噪声过程都被指定为高斯噪声，这些是卡尔曼滤波器的理想条件。\n\n系统在时间 $t_k$ 的状态由向量 $x_k = \\begin{bmatrix} b_k \\\\ d_k \\end{bmatrix}$ 给出，其中 $b_k$ 是时钟偏差（单位：秒），$d_k$ 是时钟漂移（单位：秒/秒）。\n\n状态演化由一个离散时间线性模型控制：\n$$x_{k+1} = F_k x_k + w_k$$\n其中 $F_k$ 是状态转移矩阵，$w_k$ 是过程噪声。根据问题陈述，我们有：\n$$\n\\begin{aligned}\nb_{k+1} = b_k + d_k \\,\\Delta t_k + w_{b,k} \\\\\nd_{k+1} = d_k + w_{d,k}\n\\end{aligned}\n$$\n这使我们能够确定时间间隔 $\\Delta t_k = t_{k+1} - t_k$ 的状态转移矩阵为：\n$$F_k = \\begin{bmatrix} 1 & \\Delta t_k \\\\ 0 & 1 \\end{bmatrix}$$\n过程噪声向量为 $w_k = \\begin{bmatrix} w_{b,k} \\\\ w_{d,k} \\end{bmatrix}$。噪声 $w_{b,k}$ 和 $w_{d,k}$ 是独立的零均值高斯变量。因此，过程噪声协方差矩阵 $Q_k$ 是对角矩阵：\n$$Q_k = \\operatorname{Cov}(w_k) = \\begin{bmatrix} \\operatorname{Var}(w_{b,k}) & 0 \\\\ 0 & \\operatorname{Var}(w_{d,k}) \\end{bmatrix} = \\begin{bmatrix} q_b \\Delta t_k & 0 \\\\ 0 & q_d \\Delta t_k \\end{bmatrix}$$\n\n测量模型将状态 $x_k$ 与测量值 $z_k$ 相关联：\n$$z_k = H x_k + v_k$$\n其中 $H$ 是测量矩阵，$v_k$ 是测量噪声。给定的关系是 $z_k = c\\, b_k + v_k$。这可以用一个恒定的测量矩阵写成矩阵形式：\n$$H = \\begin{bmatrix} c & 0 \\end{bmatrix}$$\n其中光速 $c = 299792458 \\, \\text{m/s}$。测量噪声 $v_k$ 是一个零均值高斯噪声，其方差为 $\\operatorname{Var}(v_k) = r^2$。因此，测量噪声协方差 $R$ 是一个标量：\n$$R = r^2$$\n\n卡尔曼滤波器算法包括一个两步递归过程：预测和更新。设 $m_{k|k-1}$ 和 $P_{k|k-1}$ 表示在给定截至时间 $t_{k-1}$ 的测量值的情况下，状态 $x_k$ 的先验均值和协方差。设 $m_{k|k}$ 和 $P_{k|k}$ 表示在给定截至时间 $t_k$ 的测量值的情况下，状态的后验均值和协方差。\n\n该过程从时间 $t_0$ 的初始状态分布开始，该分布作为考虑任何测量之前的先验给出。\n初始条件（在时间 $t_0$ 测量 $z_0$ 之前）：\n$$m_{0|-1} = m_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$$\n$$P_{0|-1} = P_0 = \\begin{bmatrix} (10^{-6})^2 & 0 \\\\ 0 & (10^{-10})^2 \\end{bmatrix} = \\begin{bmatrix} 10^{-12} & 0 \\\\ 0 & 10^{-20} \\end{bmatrix}$$\n\n然后，滤波器对从 $k=0, \\dots, N$ 的每个测量值进行迭代，其中 $N$ 是最终时间 $t_N$ 处的最终测量值的索引。\n\n对于每个时间步 $k$：\n首先，如果 $k>0$，执行预测步骤，将估计从时间 $t_{k-1}$ 传播到 $t_k$。\n1.  **预测步骤**（从 $t_{k-1}$ 到 $t_k$）：\n    -   时间 $t_k$ 的预测（先验）均值：$m_{k|k-1} = F_{k-1} m_{k-1|k-1}$\n    -   时间 $t_k$ 的预测（先验）协方差：$P_{k|k-1} = F_{k-1} P_{k-1|k-1} F_{k-1}^T + Q_{k-1}$\n    此处，$F_{k-1}$ 和 $Q_{k-1}$ 使用 $\\Delta t_{k-1} = t_k - t_{k-1}$ 定义。对于 $k=0$，此步骤被跳过，我们使用 $m_{0|-1}$ 和 $P_{0|-1}$ 作为先验。\n\n其次，更新步骤结合时间 $t_k$ 的测量值 $z_k$，将先验估计提炼为后验估计。\n2.  **更新步骤**（在时间 $t_k$）：\n    -   新息（测量残差）：$\\nu_k = z_k - H m_{k|k-1}$\n    -   新息协方差：$S_k = H P_{k|k-1} H^T + R$\n    -   卡尔曼增益：$K_k = P_{k|k-1} H^T S_k^{-1}$\n    -   更新后（后验）均值：$m_{k|k} = m_{k|k-1} + K_k \\nu_k$\n    -   更新后（后验）协方差：$P_{k|k} = (I - K_k H) P_{k|k-1}$，其中 $I$ 是单位矩阵。\n\n该算法从 $k=0$ 的给定先验开始，执行一次更新，然后预测到 $k=1$，在 $k=1$ 进行更新，依此类推，直到处理完时间 $t_N$ 的最终测量值。每个测试用例的最终输出是最终时刻的后验状态均值 $m_{N|N}$，其中包含估计的偏差 $b_N$ 和漂移 $d_N$。这代表了在给定所有测量值（包括最后一个）的情况下，的最小均方误差估计。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the GPS clock state estimation problem for multiple test cases using a Kalman filter.\n    \"\"\"\n    \n    # Define physical and initial state constants\n    C = 299792458.0  # Speed of light in m/s\n    M0 = np.array([[0.0], [0.0]])  # Initial state mean [b_0, d_0]^T\n    P0 = np.array([[1e-12, 0.0], [0.0, 1e-20]])  # Initial state covariance\n\n    test_cases = [\n        {\n            \"times\": [0, 1, 2, 3, 4, 5],\n            \"measurements\": [34.775095, 36.924783647, 37.874472334, 36.624161021, 38.073849708, 37.823538395],\n            \"r\": 2.0, \"qb\": 1.0e-20, \"qd\": 1.0e-22\n        },\n        {\n            \"times\": [0, 1, 2, 3, 4, 5],\n            \"measurements\": [24.18339664, 23.88339664, 24.38339664, 23.68339664, 23.98339664, 24.08339664],\n            \"r\": 1.0, \"qb\": 1.0e-22, \"qd\": 1.0e-24\n        },\n        {\n            \"times\": [0, 2, 3.5, 7.0, 7.5, 10.0],\n            \"measurements\": [11.9896229, 17.4296644084, 13.3846955397, 15.7797681794, 14.7647785565, 12.689830442],\n            \"r\": 5.0, \"qb\": 5.0e-20, \"qd\": 1.0e-20\n        },\n        {\n            \"times\": [0, 0.5, 1.0, 1.5, 2.0],\n            \"measurements\": [0.05, 0.729481145, 1.50896229, 2.218443435, 2.99792458],\n            \"r\": 0.1, \"qb\": 1.0e-22, \"qd\": 1.0e-18\n        }\n    ]\n\n    def run_kalman_filter(times, measurements, r, qb, qd):\n        \"\"\"\n        Implements the Kalman filter for the given time-varying linear system.\n\n        Args:\n            times (list): List of time stamps t_k.\n            measurements (list): List of measurements z_k.\n            r (float): Measurement noise standard deviation.\n            qb (float): Process noise intensity for bias.\n            qd (float): Process noise intensity for drift.\n\n        Returns:\n            list: The final estimated state [b_T, d_T].\n        \"\"\"\n        # Initialize state mean and covariance\n        m = M0.copy()\n        P = P0.copy()\n\n        # Define constant matrices\n        H = np.array([[C, 0.0]])  # Measurement matrix (1x2)\n        R_val = r**2  # Measurement noise variance (scalar)\n        I = np.identity(2)  # Identity matrix\n\n        # Iterate through each measurement\n        for k in range(len(times)):\n            # --- Prediction step (from t_{k-1} to t_k) ---\n            if k > 0:\n                dt = times[k] - times[k-1]\n                \n                # State transition matrix F\n                F = np.array([[1.0, dt], [0.0, 1.0]])\n                \n                # Process noise covariance matrix Q\n                Q = np.array([[qb * dt, 0.0], [0.0, qd * dt]])\n                \n                # Predict state and covariance\n                m = F @ m\n                P = F @ P @ F.T + Q\n            \n            # --- Update step (at t_k) ---\n            z_k = measurements[k]\n            \n            # Innovation (measurement residual)\n            nu = z_k - (H @ m)[0, 0]  # nu is a scalar\n            \n            # Innovation covariance\n            S = (H @ P @ H.T)[0, 0] + R_val  # S is a scalar\n            \n            # Kalman gain (K = P H' / S)\n            K = (P @ H.T) / S  # K is a 2x1 vector\n            \n            # Update state mean\n            m = m + K * nu\n            \n            # Update state covariance using Joseph form for numerical stability\n            P = (I - K @ H) @ P @ (I - K @ H).T + (K * R_val) @ K.T\n\n        return m.flatten().tolist()\n\n    results = []\n    for case in test_cases:\n        final_state = run_kalman_filter(\n            case[\"times\"], case[\"measurements\"], case[\"r\"], case[\"qb\"], case[\"qd\"]\n        )\n        results.append(final_state)\n    \n    # Format the output string as per requirements: [[b,d],[b,d],...]\n    output_str = f\"[{','.join([f'[{b},{d}]' for b, d in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将视角从随时间跟踪系统状态，转向一个不同但相关的挑战：估计系统未知的物理属性。 本练习以一个简化的油藏模型为例，展示了支撑卡尔曼滤波器的贝叶斯更新框架在解决反演问题（也称为参数估计或历史拟合）中的威力。您将通过将模拟输出与历史生产数据进行匹配，来估计油藏的静态渗透率场。完成此练习将揭示数据同化不仅是用于状态跟踪，更是一个融合模型与数据的通用框架，并将滤波器与更广泛的贝叶斯推断和计算反演问题领域联系起来。",
            "id": "2382583",
            "problem": "给定一个一维理想化石油储层，它被表示为 $N$ 个平行的等截面积流动管道。在离散时间 $t \\in \\{1,\\dots,T\\}$，两个边界的压力分别为 $p_{\\mathrm{in}}(t)$ 和 $p_{\\mathrm{out}}(t)$，管道内为稳态、单相、不可压缩流。横截面积为 $A$，长度为 $L$，流体动力粘度为 $\\mu$。每个管道 $i \\in \\{1,\\dots,N\\}$ 具有一个未知的绝对渗透率 $k_i$，并假设其不随时间变化。在时间 $t$ 的总体积流量 $q_t$ 等于\n$$\nq_t \\;=\\; \\frac{A}{\\mu}\\,\\frac{p_{\\mathrm{in}}(t)-p_{\\mathrm{out}}(t)}{L}\\,\\frac{1}{N}\\sum_{i=1}^{N} k_i,\n$$\n且在时间 $t$ 的测量流量为\n$$\ny_t \\;=\\; q_t + \\varepsilon_t,\n$$\n其中 $\\varepsilon_t$ 是一个独立的、均值为零、方差为 $r^2$ 的高斯噪声。\n\n渗透率向量 $k = [k_1,\\dots,k_N]^\\top$ 的先验分布是高斯分布，其均值向量 $m_0 \\in \\mathbb{R}^N$ 的所有分量均等于一个标量 $m_0$，其协方差矩阵 $C_0 \\in \\mathbb{R}^{N \\times N}$ 由平方指数核给出\n$$\n(C_0)_{ij} \\;=\\; \\sigma^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2\\,\\ell^2}\\right),\n$$\n其中 $d_{ij}$ 是管道 $i$ 和 $j$ 的中心沿储层长度的距离，其计算公式为 $d_{ij} \\;=\\; \\left|\\left(i-\\tfrac{1}{2}\\right)\\Delta x - \\left(j-\\tfrac{1}{2}\\right)\\Delta x \\right|$，且 $\\Delta x \\;=\\; \\frac{L}{N}$。\n\n令 $H \\in \\mathbb{R}^{T\\times N}$ 表示从渗透率到无噪声测量的线性映射，其对应于时间 $t$ 的行等于\n$$\nh_t^\\top \\;=\\; \\frac{A}{\\mu}\\,\\frac{p_{\\mathrm{in}}(t)-p_{\\mathrm{out}}(t)}{L}\\,\\frac{1}{N}\\,\\mathbf{1}^\\top,\n$$\n其中 $\\mathbf{1}$ 是 $\\mathbb{R}^{N}$ 中的全1向量。将测量值 $y_t$ 堆叠成 $y \\in \\mathbb{R}^T$ 并定义 $R = r^2 I_T$。\n\n对于下方的每个测试用例，按顺序执行以下操作：\n- 使用相同的固定伪随机种子 $0$ 来抽取真实渗透率 $k_{\\mathrm{true}} \\sim \\mathcal{N}(m_0, C_0)$ 和独立的测量噪声 $\\varepsilon_t \\sim \\mathcal{N}(0,r^2)$（对于 $t=1,\\dots,T$）。\n- 构建 $y = H k_{\\mathrm{true}} + \\varepsilon$，其中 $\\varepsilon = [\\varepsilon_1,\\dots,\\varepsilon_T]^\\top$。\n- 在指定的线性高斯模型下，计算 $k$ 的贝叶斯后验均值 $\\hat{k}$。\n- 计算 $\\hat{k}$ 与 $k_{\\mathrm{true}}$ 之间的均方根误差 (RMSE)，其定义为\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\hat{k}_i - (k_{\\mathrm{true}})_i\\right)^2}.\n$$\n\n所有量和输出都必须使用国际单位制表示：长度单位为米 ($\\mathrm{m}$)，面积单位为平方米 ($\\mathrm{m}^2$)，动力粘度单位为帕斯卡·秒 ($\\mathrm{Pa\\cdot s}$)，压力单位为帕斯卡 ($\\mathrm{Pa}$)，体积流量单位为立方米/秒 ($\\mathrm{m}^3/\\mathrm{s}$)，渗透率单位为平方米 ($\\mathrm{m}^2$)。报告每个测试用例的最终RMSE，单位为 $\\mathrm{m}^2$。\n\n测试套件（对三个不同的用例，请严格使用这些参数）：\n- 用例 A（通用情况）：\n  - $N = 20$, $L = 10^3\\,\\mathrm{m}$, $A = 10^4\\,\\mathrm{m}^2$, $\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$,\n  - $T = 5$，压降 $\\Delta p_t = p_{\\mathrm{in}}(t)-p_{\\mathrm{out}}(t)$ 为 $[\\;10^6,\\;8\\times 10^5,\\;9\\times 10^5,\\;1.1\\times 10^6,\\;1.2\\times 10^6\\;]\\,\\mathrm{Pa}$，\n  - 先验均值标量 $m_0 = 2.0\\times 10^{-13}\\,\\mathrm{m}^2$，先验核参数 $\\sigma = 3.0\\times 10^{-14}\\,\\mathrm{m}^2$ 和 $\\ell = 200\\,\\mathrm{m}$，\n  - 测量噪声标准差 $r = 1.0\\times 10^{-4}\\,\\mathrm{m}^3/\\mathrm{s}$。\n- 用例 B（降维和不同方案）：\n  - $N = 10$, $L = 10^3\\,\\mathrm{m}$, $A = 10^4\\,\\mathrm{m}^2$, $\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$,\n  - $T = 3$，压降 $\\Delta p_t = [\\;10^6,\\;1.5\\times 10^6,\\;5\\times 10^5\\;]\\,\\mathrm{Pa}$，\n  - 先验均值标量 $m_0 = 2.0\\times 10^{-13}\\,\\mathrm{m}^2$，先验核参数 $\\sigma = 2.0\\times 10^{-14}\\,\\mathrm{m}^2$ 和 $\\ell = 400\\,\\mathrm{m}$，\n  - 测量噪声标准差 $r = 5.0\\times 10^{-5}\\,\\mathrm{m}^3/\\mathrm{s}$。\n- 用例 C（更高维度和更大可变性）：\n  - $N = 30$, $L = 10^3\\,\\mathrm{m}$, $A = 10^4\\,\\mathrm{m}^2$, $\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$,\n  - $T = 6$，压降 $\\Delta p_t = [\\;6\\times 10^5,\\;8\\times 10^5,\\;10^6,\\;1.2\\times 10^6,\\;1.4\\times 10^6,\\;1.6\\times 10^6\\;]\\,\\mathrm{Pa}$，\n  - 先验均值标量 $m_0 = 2.0\\times 10^{-13}\\,\\mathrm{m}^2$，先验核参数 $\\sigma = 4.0\\times 10^{-14}\\,\\mathrm{m}^2$ 和 $\\ell = 150\\,\\mathrm{m}$，\n  - 测量噪声标准差 $r = 2.0\\times 10^{-4}\\,\\mathrm{m}^3/\\mathrm{s}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含对应于用例 A、B 和 C 的三个 RMSE 值（单位为 $\\mathrm{m}^2$），形式为用方括号括起来的逗号分隔列表（例如，$[\\mathrm{rmseA},\\mathrm{rmseB},\\mathrm{rmseC}]$）。不应打印任何额外文本。",
            "solution": "所提出的问题是贝叶斯反演理论中的一个标准练习，应用于多孔介质中流体流动的简化模型。其结构是一个线性高斯系统，对此存在闭式解析解。我将首先验证问题陈述，然后提供求解方法的严谨推导。\n\n**问题验证**\n\n**步骤 1：提取的已知条件**\n- 时间 $t$ 的总体积流量模型：$q_t = \\frac{A}{\\mu}\\,\\frac{p_{\\mathrm{in}}(t)-p_{\\mathrm{out}}(t)}{L}\\,\\frac{1}{N}\\sum_{i=1}^{N} k_i$。\n- 测量模型：$y_t = q_t + \\varepsilon_t$，噪声为 $\\varepsilon_t \\sim \\mathcal{N}(0, r^2)$。\n- 状态向量（未知渗透率）：$k = [k_1, \\dots, k_N]^\\top$。\n- $k$ 的先验分布：$k \\sim \\mathcal{N}(m_0, C_0)$。\n- 先验均值向量 $m_0$：所有分量均等于一个标量 $m_0$。\n- 先验协方差矩阵 $C_0$：$(C_0)_{ij} = \\sigma^2 \\exp(-\\frac{d_{ij}^2}{2\\ell^2})$。\n- 距离度量：$d_{ij} = |\\left(i-\\frac{1}{2}\\right)\\Delta x - \\left(j-\\frac{1}{2}\\right)\\Delta x |$，其中 $\\Delta x = L/N$。\n- 线性观测算子 $H \\in \\mathbb{R}^{T\\times N}$：第 $t$ 行为 $h_t^\\top = \\frac{A}{\\mu}\\,\\frac{p_{\\mathrm{in}}(t)-p_{\\mathrm{out}}(t)}{L}\\,\\frac{1}{N}\\,\\mathbf{1}^\\top$。\n- 堆叠模型：$y = H k + \\varepsilon$，其中测量向量为 $y \\in \\mathbb{R}^T$，噪声向量为 $\\varepsilon \\sim \\mathcal{N}(0, R)$，且 $R=r^2 I_T$。\n- 目标：对于三个测试用例（A、B、C），将伪随机种子设为 $0$，生成 $k_{\\mathrm{true}} \\sim \\mathcal{N}(m_0, C_0)$ 和 $\\varepsilon \\sim \\mathcal{N}(0,R)$，构建合成测量值 $y$，计算贝叶斯后验均值 $\\hat{k}$，并报告均方根误差 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(\\hat{k}_i - (k_{\\mathrm{true}})_i)^2}$。\n- 每个用例的所有参数和单位均在国际单位制中指定。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于达西定律在线性化形式下的单相不可压缩流，这是多孔介质流体动力学的基石。在地球物理和工程反演问题中，对空间相关的渗透率场使用高斯先验和对测量值使用高斯噪声是标准做法。该模型是一个有效但简化的物理表示。\n- **适定性：** 该问题要求在线性高斯模型中计算后验均值。该解的存在性和唯一性在数学上是有保证的。计算过程被明确无误地指定。\n- **客观性：** 该问题使用精确的数学定义和数值进行阐述。它不含主观或模糊的语言。\n\n**步骤 3：结论与行动**\n该问题具有科学合理性、适定性和客观性。它不包含任何不一致之处、缺失信息或逻辑缺陷。此问题被判定为 **有效**。将提供解答。\n\n**求解推导**\n\n问题是从一组带噪声的测量值 $y \\in \\mathbb{R}^T$ 中推断渗透率向量 $k \\in \\mathbb{R}^N$。它们之间的关系由一个线性高斯统计模型所支配。\n\n关于状态 $k$ 的先验信念被编码在一个高斯概率分布中：\n$$\np(k) = \\mathcal{N}(k | m_0, C_0) \\propto \\exp\\left(-\\frac{1}{2}(k - m_0)^\\top C_0^{-1}(k - m_0)\\right)\n$$\n其中 $m_0 \\in \\mathbb{R}^N$ 是先验均值向量，$C_0 \\in \\mathbb{R}^{N\\times N}$ 是先验协方差矩阵。\n\n测量过程由线性模型 $y = Hk + \\varepsilon$ 描述，其中 $H \\in \\mathbb{R}^{T\\times N}$ 是观测算子，$\\varepsilon \\in \\mathbb{R}^T$ 是服从分布 $\\varepsilon \\sim \\mathcal{N}(0, R)$ 的高斯噪声向量。这定义了似然函数，即在给定特定 $k$ 的条件下观测到 $y$ 的概率：\n$$\np(y | k) = \\mathcal{N}(y | Hk, R) \\propto \\exp\\left(-\\frac{1}{2}(y - Hk)^\\top R^{-1}(y - Hk)\\right)\n$$\n\n根据贝叶斯定理，$k$ 在给定测量值 $y$ 时的后验概率分布与似然和先验的乘积成正比：\n$$\np(k | y) \\propto p(y | k) p(k)\n$$\n由于先验和似然都是高斯分布，后验分布也是高斯分布，这一性质称为共轭性。后验分布写作 $p(k|y) = \\mathcal{N}(k | \\hat{k}, \\hat{C})$，其中 $\\hat{k}$ 是后验均值，$\\hat{C}$ 是后验协方差。\n\n后验均值 $\\hat{k}$ 代表了均方意义下对 $k$ 的最佳估计，也是我们必须计算的量。其标准公式通过在后验分布表达式的指数项上配方法推导得出：\n$$\n\\hat{k} = (C_0^{-1} + H^\\top R^{-1} H)^{-1} (C_0^{-1} m_0 + H^\\top R^{-1} y)\n$$\n这种形式需要对 $N \\times N$ 矩阵 $(C_0^{-1} + H^\\top R^{-1} H)$ 求逆。在许多实际问题中，包括本题指定的用例，状态变量的数量 $N$ 可能远大于测量值的数量 $T$。在这种情况下，对一个 $N \\times N$ 矩阵求逆计算成本高昂且可能不稳定。\n\n使用 Woodbury 矩阵恒等式可以推导出计算效率更高的 $\\hat{k}$ 公式。这得到了“卡尔曼更新”形式：\n$$\n\\hat{k} = m_0 + C_0 H^\\top (H C_0 H^\\top + R)^{-1} (y - H m_0)\n$$\n该表达式在数学上与第一个等价，但需要对大小为 $T \\times T$ 的矩阵 $S = H C_0 H^\\top + R$ 求逆。由于所有测试用例中都有 $T \\ll N$（例如，用例 A 中 $T=5, N=20$），从计算的角度来看，第二种形式要优越得多。矩阵 $S$ 被称为测量的先验预测协方差。\n\n每个测试用例的算法如下：\n1. 通过用标量值 $m_0$ 填充来构建先验均值向量 $m_0 \\in \\mathbb{R}^N$。\n2. 使用提供的平方指数核函数构建先验协方差矩阵 $C_0 \\in \\mathbb{R}^{N\\times N}$。这首先需要计算 $N \\times N$ 的距离矩阵 $d_{ij}$。\n3. 将随机数生成器种子设置为 $0$。这确保了可复现性。\n4. 通过从多元正态分布 $\\mathcal{N}(m_0, C_0)$ 中抽取一个样本来生成真实渗透率向量 $k_{\\mathrm{true}}$。\n5. 构建观测算子矩阵 $H \\in \\mathbb{R}^{T\\times N}$。每一行 $t$ 是一个由压降 $\\Delta p_t$ 和其他物理参数决定的常数向量。\n6. 构建测量误差协方差矩阵 $R = r^2 I_T \\in \\mathbb{R}^{T\\times T}$。\n7. 通过从 $\\mathcal{N}(0, r^2)$ 中抽取 $T$ 个独立样本来生成测量噪声向量 $\\varepsilon \\in \\mathbb{R}^T$。\n8. 合成观测向量 $y$ 为 $y = H k_{\\mathrm{true}} + \\varepsilon$。\n9. 使用第二个更高效的公式计算后验均值 $\\hat{k}$。为了稳定性，通过求解线性方程组来数值地执行求逆操作 $(H C_0 H^\\top + R)^{-1}$。\n10. 使用公式 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (\\hat{k}_i - (k_{\\mathrm{true}})_i)^2}$ 计算后验估计 $\\hat{k}$ 与生成的真实值 $k_{\\mathrm{true}}$ 之间的最终均方根误差 (RMSE)。\n\n按照指示，对三个测试用例中的每一个都重复此过程，并且每次都将随机种子重置为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Ensure numpy version 1.23.5 is used for reproducibility of random numbers.\n# The code is written for Python 3.12.\n# Scipy is not required as numpy.linalg is sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian inverse problem for three test cases and prints the RMSEs.\n    \"\"\"\n\n    test_cases = [\n        # Case A: general case\n        {\n            \"N\": 20, \"L\": 1000.0, \"A\": 10000.0, \"mu\": 1e-3,\n            \"T\": 5, \"delta_p\": np.array([1e6, 8e5, 9e5, 1.1e6, 1.2e6]),\n            \"m0_scalar\": 2.0e-13, \"sigma\": 3.0e-14, \"ell\": 200.0,\n            \"r\": 1.0e-4\n        },\n        # Case B: reduced dimension and distinct schedule\n        {\n            \"N\": 10, \"L\": 1000.0, \"A\": 10000.0, \"mu\": 1e-3,\n            \"T\": 3, \"delta_p\": np.array([1e6, 1.5e6, 5e5]),\n            \"m0_scalar\": 2.0e-13, \"sigma\": 2.0e-14, \"ell\": 400.0,\n            \"r\": 5.0e-5\n        },\n        # Case C: higher dimension and larger variability\n        {\n            \"N\": 30, \"L\": 1000.0, \"A\": 10000.0, \"mu\": 1e-3,\n            \"T\": 6, \"delta_p\": np.array([6e5, 8e5, 1.0e6, 1.2e6, 1.4e6, 1.6e6]),\n            \"m0_scalar\": 2.0e-13, \"sigma\": 4.0e-14, \"ell\": 150.0,\n            \"r\": 2.0e-4\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        rmse = solve_case(case_params)\n        results.append(f\"{rmse:.6e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(params):\n    \"\"\"\n    Computes the RMSE for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N, L, A, mu = params[\"N\"], params[\"L\"], params[\"A\"], params[\"mu\"]\n    T, delta_p = params[\"T\"], params[\"delta_p\"]\n    m0_scalar, sigma, ell, r = params[\"m0_scalar\"], params[\"sigma\"], params[\"ell\"], params[\"r\"]\n\n    # Per problem statement, reset seed to 0 for each case.\n    np.random.seed(0)\n\n    # 1. Construct prior model (mean vector and covariance matrix)\n    m0_vec = np.full(N, m0_scalar)\n    \n    delta_x = L / N\n    # Coordinates of the center of each conduit\n    conduit_centers = (np.arange(N) + 0.5) * delta_x\n    # Distance matrix d_ij = |(i-1/2)dx - (j-1/2)dx|\n    dist_matrix = np.abs(conduit_centers[:, np.newaxis] - conduit_centers[np.newaxis, :])\n    \n    # Prior covariance matrix C0 using squared-exponential kernel\n    C0 = sigma**2 * np.exp(-dist_matrix**2 / (2 * ell**2))\n    \n    # 2. Draw ground-truth permeability from prior distribution\n    k_true = np.random.multivariate_normal(m0_vec, C0)\n\n    # 3. Construct observation operator H\n    # Each row t of H is h_t^T = (A * delta_p_t / (mu * L * N)) * 1^T\n    h_factors = (A / (mu * L * N)) * delta_p\n    H = np.ones((T, N)) * h_factors[:, np.newaxis]\n\n    # 4. Construct measurement model and generate synthetic data\n    # Measurement error covariance matrix R\n    R = np.eye(T) * (r**2)\n    \n    # Generate measurement noise\n    epsilon = np.random.normal(0, r, size=T)\n    \n    # Generate synthetic measurement vector y\n    y = H @ k_true + epsilon\n\n    # 5. Compute the Bayesian posterior mean estimate k_hat\n    # We use the formula: hat_k = m0 + C0 H^T (H C0 H^T + R)^-1 (y - H m0)\n    # This avoids inverting the large N x N matrix C0.\n    \n    # Innovation term\n    innovation = y - H @ m0_vec\n    \n    # Prior predictive covariance of measurements, S\n    S = H @ C0 @ H.T + R\n    \n    # Solve the linear system S * x = innovation for x = S^-1 * innovation\n    # This is more numerically stable than computing the inverse of S directly.\n    S_inv_innovation = np.linalg.solve(S, innovation)\n    \n    # Compute the posterior mean\n    k_hat = m0_vec + C0 @ H.T @ S_inv_innovation\n\n    # 6. Compute the Root-Mean-Square Error (RMSE)\n    rmse = np.sqrt(np.mean((k_hat - k_true)**2))\n    \n    return rmse\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}