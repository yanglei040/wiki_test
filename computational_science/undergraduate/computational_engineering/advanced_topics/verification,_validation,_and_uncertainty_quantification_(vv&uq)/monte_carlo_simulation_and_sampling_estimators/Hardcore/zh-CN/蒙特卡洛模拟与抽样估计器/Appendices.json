{
    "hands_on_practices": [
        {
            "introduction": "蒙特卡洛方法的一个最直观的应用是“投针法”或“命中-脱靶”法，它通过在一个已知体积的区域内进行随机抽样，来估算一个未知体积的几何形状。这个练习将带领你通过一个经典案例——估算高维球体与其外切超立方体的体积之比——来亲手实践这一思想。通过这个练习，你不仅能掌握蒙特卡洛积分的基本原理，还能亲眼见证并理解一个在高维空间中令人费解却又至关重要的现象：“维度灾难”。",
            "id": "2415275",
            "problem": "你需要研究一个 $d$ 维超球体的体积与一个 $d$ 维超立方体体积之比随维度 $d$ 变化的规律。令 $C_d = [-1,1]^d \\subset \\mathbb{R}^d$ 表示以原点为中心、边长为 $2$ 的超立方体，令 $S_d = \\{x \\in \\mathbb{R}^d : \\lVert x \\rVert_2 \\le 1\\}$ 表示 $d$ 维欧几里得空间中的单位超球面。定义比率 $R(d)$ 如下：\n$$\nR(d) = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)}.\n$$\n对于给定的正整数 $N$ 和整数种子 $s$，令 $X_1,\\dots,X_N$ 为由种子 $s$ 初始化的伪随机数生成器所决定的、在 $C_d$ 上均匀分布的独立同分布随机向量。定义估计量\n$$\n\\widehat{R}_N(d,s) \\equiv \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2 \\le 1\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。对于下面的每个测试用例，计算单个实数 $\\widehat{R}_N(d,s)$。\n\n所有答案必须是无量纲实数。将每个结果四舍五入到恰好 $6$ 位小数。\n\n测试集（每一项为 $(d,N,s)$）：\n- $(1, 20000, 7)$\n- $(2, 100000, 11)$\n- $(8, 300000, 2025)$\n- $(12, 500000, 123)$\n- $(20, 500000, 99991)$\n\n最终输出格式：您的程序应生成一行输出，其中包含按测试集顺序排列的结果，形式为方括号括起来的逗号分隔列表。例如，通用格式为 [$x_1,x_2,x_3,x_4,x_5$]，其中每个 $x_i$ 是按上述规定四舍五入到恰好 $6$ 位小数的实数。",
            "solution": "该问题要求计算一个 $d$ 维超球体与一个 $d$ 维超立方体体积之比的蒙特卡洛估计量。我将首先验证问题陈述，然后基于计算科学的基本原理提供一个完整的解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n\n问题提供了以下定义和参数：\n- 超立方体：$C_d = [-1,1]^d \\subset \\mathbb{R}^d$。这是一个以原点为中心、边长为 $2$ 的超立方体。\n- 超球面：$S_d = \\{x \\in \\mathbb{R}^d : \\lVert x \\rVert_2 \\le 1\\}$。这是一个以原点为中心、完全内接于超立方体 $C_d$ 的单位超球面。\n- 体积之比：$R(d) = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)}$。\n- 随机向量：$X_1,\\dots,X_N$ 是独立同分布 (i.i.d.) 的随机向量，在 $C_d$ 上均匀分布。它们的生成由一个以整数种子 $s$ 初始化的伪随机数生成器决定。\n- 估计量：$\\widehat{R}_N(d,s) \\equiv \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2 \\le 1\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n- 测试用例（以 $(d, N, s)$ 元组的形式）：\n    - $(1, 20000, 7)$\n    - $(2, 100000, 11)$\n    - $(8, 300000, 2025)$\n    - $(12, 500000, 123)$\n    - $(20, 500000, 99991)$\n- 输出规格：每个数值结果必须四舍五入到恰好 $6$ 位小数。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n我现在将根据既定标准评估问题的有效性。\n- **科学性**：该问题是蒙特卡洛积分的一个经典应用，这是计算物理、工程和应用数学中一个基础且广泛使用的技术。超球面、超立方体和蒙特卡洛估计量的定义都是标准的且数学上正确的。该问题基于概率论和统计估计的原理。它完全是合理的。\n- **适定性**：该问题是适定的。对于每个测试用例，所有必需的参数（$d$、$N$、$s$）都已提供。使用带种子的伪随机数生成器确保了随机向量序列 $X_i$ 是确定性的，从而得到一个唯一且可计算的估计量 $\\widehat{R}_N(d,s)$ 值。\n- **客观性**：该问题使用精确、无歧义的数学语言陈述。它不含任何主观或推测性内容。\n\n基于此分析，该问题没有表现出验证清单中列出的任何缺陷。它是科学合理的、适定的、客观的，并与指定的蒙特卡洛方法主题直接相关。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。我将继续构建并给出解决方案。\n\n### 解决方案\n\n目标是为几个测试用例计算估计量 $\\widehat{R}_N(d,s)$。该估计量近似于比率 $R(d) = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)}$。该方法基于蒙特卡洛积分的原理。\n\n令 $X$ 为在超立方体 $C_d$ 中均匀分布的随机向量。该向量位于内接超球面 $S_d$ 内的概率由它们体积的比率给出：\n$$\nP(X \\in S_d) = \\frac{\\int_{C_d} \\mathbf{1}\\{x \\in S_d\\} dx}{\\int_{C_d} 1 dx} = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)} = R(d)\n$$\n其中 $\\mathbf{1}\\{x \\in S_d\\}$ 是指示函数，如果 $x \\in S_d$ 则为 $1$，否则为 $0$。\n\n该问题为此概率定义了一个估计量。我们生成 $N$ 个独立的随机向量 $X_1, X_2, \\dots, X_N$，每个向量都在 $C_d$ 中均匀分布。对于每个向量 $X_i$，我们定义一个伯努利随机变量 $Z_i = \\mathbf{1}\\{X_i \\in S_d\\}$。条件 $X_i \\in S_d$ 等价于 $\\lVert X_i \\rVert_2 \\le 1$。每个 $Z_i$ 的期望恰好是概率 $R(d)$：\n$$\nE[Z_i] = 1 \\cdot P(Z_i=1) + 0 \\cdot P(Z_i=0) = P(X_i \\in S_d) = R(d)\n$$\n估计量 $\\widehat{R}_N(d,s)$ 是这 $N$ 次伯努利试验的样本均值：\n$$\n\\widehat{R}_N(d,s) = \\frac{1}{N} \\sum_{i=1}^N Z_i = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2 \\le 1\\}\n$$\n根据大数定律，当 $N$ 趋于无穷大时，该样本均值收敛于真实期望：\n$$\n\\lim_{N \\to \\infty} \\widehat{R}_N(d,s) = R(d)\n$$\n这为该方法提供了理论依据。用于计算给定参数集 $(d, N, s)$ 的 $\\widehat{R}_N(d,s)$ 的规定算法如下：\n\n1.  **初始化**：使用指定的整数种子 $s$ 初始化一个伪随机数生成器。这确保了结果的可复现性。\n\n2.  **样本生成**：生成一组 $N$ 个随机向量 $\\{X_1, \\dots, X_N\\}$，其中每个 $X_i = (x_{i1}, x_{i2}, \\dots, x_{id})$ 是 $\\mathbb{R}^d$ 中的一个点。为确保向量在超立方体 $C_d = [-1, 1]^d$ 中均匀分布，每个分量 $x_{ij}$ 都必须从均匀分布 $U[-1, 1]$ 中抽取。这在计算上通过生成一个 $N \\times d$ 的浮点数矩阵来实现，其中每个元素都是来自 $U[-1, 1]$ 的独立样本。\n\n3.  **条件检查**：对于每个向量 $X_i$，判断它是否位于单位超球面 $S_d$ 内部。这通过检查其欧几里得范数是否小于或等于 $1$ 来完成。为了计算效率，最好检查范数的平方：\n    $$\n    \\lVert X_i \\rVert_2 \\le 1 \\iff \\lVert X_i \\rVert_2^2 \\le 1^2 \\iff \\sum_{j=1}^d x_{ij}^2 \\le 1\n    $$\n    这避免了计算开销大的平方根运算。\n\n4.  **估计**：计算满足上一步条件的向量数量，我们称之为 $M$。这个计数等价于指示函数的总和：$M = \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2^2 \\le 1\\}$。然后蒙特卡洛估计值计算为比率：\n    $$\n    \\widehat{R}_N(d,s) = \\frac{M}{N}\n    $$\n5.  **完成**：对每个测试用例 $(d, N, s)$ 重复此过程，并将所得估计值按要求四舍五入到 $6$ 位小数。“维度灾难”现象将会变得明显，即在高维度 $d$ 下，超球体的体积相对于超立方体变得极小，估计值 $\\widehat{R}_N(d,s)$ 会迅速趋近于零。对于 $d=20$，统计上很可能 $M=0$，从而得到估计值 $0$。\n\n至此，理论框架和算法设计完成。实现将基于此逻辑进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Monte Carlo estimate of the ratio of a d-dimensional hypersphere's\n    volume to that of its enclosing hypercube for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (d, N, s), where:\n    # d: dimension of the space\n    # N: number of samples\n    # s: seed for the pseudo-random number generator\n    test_cases = [\n        (1, 20000, 7),\n        (2, 100000, 11),\n        (8, 300000, 2025),\n        (12, 500000, 123),\n        (20, 500000, 99991)\n    ]\n\n    results = []\n    for d, N, s in test_cases:\n        # Initialize the pseudo-random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(s)\n\n        # Generate N random vectors in d-dimensional space.\n        # Each component of each vector is drawn from the uniform distribution on [-1, 1].\n        # This creates an N x d matrix of points uniformly sampled from the hypercube C_d.\n        # The size parameter is (number of rows, number of columns), i.e., (N, d).\n        samples = rng.uniform(-1, 1, size=(N, d))\n\n        # For each sample vector, calculate its squared Euclidean norm.\n        # This is more computationally efficient than calculating the norm itself,\n        # as it avoids the square root operation.\n        # The condition ||x||_2 = 1 is equivalent to ||x||_2^2 = 1.\n        # The sum is performed along axis=1 to sum the squared components for each vector (row).\n        squared_norms = np.sum(samples**2, axis=1)\n\n        # Count the number of samples whose squared norm is less than or equal to 1.\n        # These are the points that lie within the unit hypersphere S_d.\n        count_inside = np.sum(squared_norms = 1)\n\n        # The estimator is the ratio of points inside the hypersphere to the total number of points.\n        # This ratio approximates the volume ratio R(d).\n        estimate = count_inside / N\n\n        # Per the problem specification, the final result must be rounded to 6 decimal places.\n        # We format the number as a string to ensure exactly 6 decimal places are shown.\n        results.append(f\"{estimate:.6f}\")\n\n    # Final print statement in the exact required format: a comma-separated list in brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然基础的蒙特卡洛积分功能强大，但当被积函数包含奇点或急剧变化的峰值时，其效率会显著下降，导致估计结果的方差过高。为了解决这一问题，我们引入一种关键的方差缩减技术——重要性抽样。这个练习旨在通过处理一个带有端点奇点的积分，让你动手实现这一高级方法，学习如何根据被积函数的特性选择一个合适的“提议分布”，从而在不引入偏差的前提下，极大地提升估计的精度和稳定性。",
            "id": "2415223",
            "problem": "构建一个蒙特卡洛重要性抽样估计量，以评估以下形式的积分：$$I=\\int_{0}^{1} x^{-a}(1-x)^{-b}\\,g(x)\\,dx,$$ 其中 $0 \\lt a \\lt 1$，$0 \\le b \\lt 1$，$g(x)$ 是 $[0,1]$ 上的有界连续函数。从蒙特卡洛积分和重要性抽样的核心定义出发：如果 $p(x)$ 是在 $(0,1)$ 上严格为正的任意概率密度函数，则 $$I=\\int_{0}^{1} \\frac{x^{-a}(1-x)^{-b}\\,g(x)}{p(x)}\\,p(x)\\,dx=\\mathbb{E}_{p}\\!\\left[\\frac{x^{-a}(1-x)^{-b}\\,g(X)}{p(X)}\\right],$$ 其中 $X \\sim p$。您的任务是：\n- 从第一性原理出发，推导确保估计量对于给定具有端点奇点的被积函数类是无偏的且具有有限方差的关于 $p(x)$ 的条件。\n- 以有原则的方式选择一个密度函数 $p(x)$，使其能捕捉 $x^{-a}(1-x)^{-b}$ 的端点行为，并根据被积函数的结构和 Beta 函数 $B(\\alpha,\\beta)=\\int_{0}^{1} x^{\\alpha-1}(1-x)^{\\beta-1}\\,dx$（其中 $\\alpha \\gt 0$ 且 $\\beta \\gt 0$）的定义来证明您选择的合理性。\n- 将您的选择转化为一个具体的、可在算法上实现的抽样方案，该方案能为 $I$ 生成一个无偏估计量，并且在端点处没有数值不稳定性。\n\n实现一个完整、可运行的程序，该程序：\n- 为保证可复现性，使用单一共享伪随机种子 $s=20231105$。\n- 对于下方的每个测试用例，从您选择的 $p(x)$ 中抽取大小为 $N$ 的独立样本，并返回 $I$ 的单个蒙特卡洛估计值 $\\widehat{I}$。\n- 所有三角函数均使用弧度制。\n- 按测试用例的顺序，生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件（每个用例指定 $(a,b,g,N)$）：\n- 用例 1：$a=\\tfrac{1}{2}$, $b=0$, $g(x)=\\exp(x)$, $N=200000$。\n- 用例 2：$a=0.9$, $b=0$, $g(x)=\\cos(x)$, $N=600000$。\n- 用例 3：$a=0.49$, $b=0.49$, $g(x)=\\sin(3x)$, $N=400000$。\n- 用例 4：$a=0.99$, $b=0$, $g(x)=1$, $N=100000$。\n- 用例 5：$a=0.1$, $b=0.9$, $g(x)=\\exp(2x)$, $N=500000$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是用例 $i$ 的蒙特卡洛估计值。不涉及物理单位，输出为实数。三角函数必须使用弧度制。不要读取任何输入；程序必须按原样运行，且仅使用指定的种子和指定的样本大小。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 待求积分的形式为 $I=\\int_{0}^{1} x^{-a}(1-x)^{-b}\\,g(x)\\,dx$。\n- 参数 $a$ 和 $b$ 受限于 $0 \\lt a \\lt 1$ 和 $0 \\le b \\lt 1$。\n- 函数 $g(x)$ 被指定为区间 $[0,1]$ 上的有界连续函数。\n- 蒙特卡洛重要性抽样估计量根据其第一性原理定义为：$I=\\mathbb{E}_{p}\\!\\left[\\frac{x^{-a}(1-x)^{-b}\\,g(X)}{p(X)}\\right]$，其中概率密度函数 $p(x)$ 的支撑集在 $(0,1)$ 上，且 $X \\sim p$。\n- Beta 函数定义为 $B(\\alpha,\\beta)=\\int_{0}^{1} x^{\\alpha-1}(1-x)^{\\beta-1}\\,dx$，其中 $\\alpha  0$ 且 $\\beta  0$。\n- 实现要求使用伪随机种子 $s=20231105$，每个用例使用大小为 $N$ 的独立样本，并且三角函数使用弧度制。\n- 测试套件如下：\n  - 用例 1：$(a,b,g,N) = (\\tfrac{1}{2}, 0, \\exp(x), 200000)$。\n  - 用例 2：$(a,b,g,N) = (0.9, 0, \\cos(x), 600000)$。\n  - 用例 3：$(a,b,g,N) = (0.49, 0.49, \\sin(3x), 400000)$。\n  - 用例 4：$(a,b,g,N) = (0.99, 0, 1, 100000)$。\n  - 用例 5：$(a,b,g,N) = (0.1, 0.9, \\exp(2x), 500000)$。\n\n**步骤 2：验证已知条件**\n该问题是科学合理的、适定的和客观的。这是一个关于蒙特卡洛方法的计算科学标准问题。约束条件 $0 \\lt a \\lt 1$ 和 $0 \\le b \\lt 1$ 确保了被积函数在 $x=0$ 和 $x=1$ 处的奇点是可积的，从而保证积分 $I$ 是有限且良定义的。构建解决方案所需的所有必要数据和定义均已提供。该问题没有矛盾、歧义，也不依赖于非科学前提。\n\n**步骤 3：结论与行动**\n问题有效。将提供解决方案。\n\n将被积函数记为 $f(x) = x^{-a}(1-x)^{-b}\\,g(x)$。积分为 $I = \\int_{0}^{1} f(x) dx$。基于从 $p(x)$ 中抽取的 $N$ 个独立同分布样本 $X_i \\sim p(x)$，对 $I$ 的蒙特卡洛重要性抽样估计量由下式给出：\n$$ \\widehat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)} $$\n\n**无偏性和有限方差条件的推导**\n\n首先，我们讨论估计量无偏的条件。估计量的期望为：\n$$ \\mathbb{E}_p[\\widehat{I}_N] = \\mathbb{E}_p\\left[\\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}\\right] = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{E}_p\\left[\\frac{f(X_i)}{p(X_i)}\\right] = \\mathbb{E}_p\\left[\\frac{f(X)}{p(X)}\\right] $$\n根据连续随机变量期望的定义，此式为：\n$$ \\mathbb{E}_p\\left[\\frac{f(X)}{p(X)}\\right] = \\int_{\\text{supp}(p)} \\frac{f(x)}{p(x)} p(x) dx = \\int_{\\text{supp}(p)} f(x) dx $$\n为了使估计量无偏，即 $\\mathbb{E}_p[\\widehat{I}_N] = I = \\int_{0}^{1} f(x) dx$，我们必须有 $\\int_{\\text{supp}(p)} f(x) dx = \\int_{0}^{1} f(x) dx$。如果 $p(x)$ 的支撑集包含 $f(x)$ 非零的区域，则此条件得到保证。形式上，条件是对于任何 $x \\in (0,1)$，如果 $f(x) \\neq 0$，那么 $p(x)  0$。我们将要求对所有 $x \\in (0,1)$ 都有 $p(x)  0$。\n\n其次，我们讨论估计量具有有限方差的条件。估计量的方差为：\n$$ \\text{Var}_p(\\widehat{I}_N) = \\frac{1}{N} \\text{Var}_p\\left(\\frac{f(X)}{p(X)}\\right) $$\n当且仅当随机变量 $\\frac{f(X)}{p(X)}$ 的二阶矩是有限时，方差才是有限的。这要求：\n$$ \\mathbb{E}_p\\left[\\left(\\frac{f(X)}{p(X)}\\right)^2\\right] = \\int_{0}^{1} \\frac{f(x)^2}{p(x)} dx  \\infty $$\n代入 $f(x) = x^{-a}(1-x)^{-b}\\,g(x)$，条件变为：\n$$ \\int_{0}^{1} \\frac{\\left(x^{-a}(1-x)^{-b}\\,g(x)\\right)^2}{p(x)} dx = \\int_{0}^{1} \\frac{x^{-2a}(1-x)^{-2b}\\,g(x)^2}{p(x)} dx  \\infty $$\n由于 $g(x)$ 在 $[0,1]$ 上有界，存在一个常数 $M$ 使得 $g(x)^2 \\le M^2$。因此，有限方差的一个充分条件是：\n$$ \\int_{0}^{1} \\frac{x^{-2a}(1-x)^{-2b}}{p(x)} dx  \\infty $$\n这个条件决定了提议密度 $p(x)$ 在端点附近的行为。为确保收敛，$p(x)$ 在 $x=0$ 附近的奇性必须至少与 $x^{-2a}$ 相同，在 $x=1$ 附近的奇性必须至少与 $(1-x)^{-2b}$ 相同。\n\n**提议密度 $p(x)$ 的选择**\n\n重要性抽样的原理建议选择一个能模仿被积函数 $|f(x)|$ 行为的提议密度 $p(x)$。我们被积函数的奇异部分是 $w(x) = x^{-a}(1-x)^{-b}$。这种函数形式与 Beta 分布的核成比例。\n具有参数 $\\alpha  0$ 和 $\\beta  0$ 的 Beta 分布随机变量的概率密度函数为：\n$$ p(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{B(\\alpha, \\beta)} $$\n为了匹配 $w(x)$ 的形式，我们选择指数使得 $\\alpha-1 = -a$ 和 $\\beta-1 = -b$。这给出了参数选择：\n$$ \\alpha = 1-a \\quad \\text{和} \\quad \\beta = 1-b $$\n给定的约束条件 $0 \\lt a \\lt 1$ 和 $0 \\le b \\lt 1$ 确保了 $\\alpha = 1-a  0$ 和 $\\beta = 1-b  0$。因此，具有这些参数的 Beta 分布是良定义的。我们选择的提议密度是：\n$$ p(x) = \\frac{x^{-a}(1-x)^{-b}}{B(1-a, 1-b)} $$\n这个选择满足无偏性条件，因为对 $x \\in (0,1)$ 有 $p(x)  0$。\n让我们用这个 $p(x)$ 来验证有限方差条件。二阶矩的积分变为：\n$$ \\int_0^1 \\frac{x^{-2a}(1-x)^{-2b} g(x)^2}{\\frac{x^{-a}(1-x)^{-b}}{B(1-a, 1-b)}} dx = B(1-a, 1-b) \\int_0^1 x^{-a}(1-x)^{-b}g(x)^2 dx $$\n由于 $g(x)^2$ 是一个有界函数，并且积分 $\\int_0^1 x^{-a}(1-x)^{-b} dx = B(1-a, 1-b)$ 收敛，所以整个表达式是有限的。因此，这种 $p(x)$ 的选择保证了估计量具有有限方差。\n\n**算法实现**\n\n使用我们选择的 $p(x)$，估计量中的比率 $\\frac{f(x)}{p(x)}$ 大大简化为：\n$$ \\frac{f(x)}{p(x)} = \\frac{x^{-a}(1-x)^{-b}g(x)}{\\frac{x^{-a}(1-x)^{-b}}{B(1-a, 1-b)}} = g(x) B(1-a, 1-b) $$\n于是，蒙特卡洛估计量为：\n$$ \\widehat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} \\left[ g(X_i) B(1-a, 1-b) \\right] = B(1-a, 1-b) \\left( \\frac{1}{N} \\sum_{i=1}^{N} g(X_i) \\right) $$\n其中 $X_i$ 是从 Beta 分布 $\\text{Beta}(1-a, 1-b)$ 中抽取的样本。\n\n这个公式是数值稳定的，因为它完全从求和中移除了奇异项。算法如下：\n1.  对每个测试用例 $(a, b, g, N)$，确定提议分布的参数：$\\alpha = 1-a$ 和 $\\beta = 1-b$。\n2.  使用数值库函数预先计算常数 $C = B(\\alpha, \\beta)$。\n3.  从分布 $\\text{Beta}(\\alpha, \\beta)$ 中生成 $N$ 个随机样本 $X_1, X_2, \\dots, X_N$。\n4.  对每个样本 $X_i$ 计算 $g(X_i)$。\n5.  计算这些值的样本均值：$\\bar{g} = \\frac{1}{N} \\sum_{i=1}^{N} g(X_i)$。\n6.  积分的估计值为 $\\widehat{I} = C \\times \\bar{g}$。\n\n对每个指定的测试用例都实现此过程。\n- **用例 1**：$a=\\tfrac{1}{2}, b=0 \\implies \\alpha=0.5, \\beta=1$。\n- **用例 2**：$a=0.9, b=0 \\implies \\alpha=0.1, \\beta=1$。\n- **用例 3**：$a=0.49, b=0.49 \\implies \\alpha=0.51, \\beta=0.51$。\n- **用例 4**：$a=0.99, b=0 \\implies \\alpha=0.01, \\beta=1$。对于此用例，$g(x)=1$，因此估计量简化为 $\\widehat{I} = B(0.01, 1) \\times \\frac{1}{N}\\sum_i 1 = B(0.01, 1)$，这正是积分的精确值。\n- **用例 5**：$a=0.1, b=0.9 \\implies \\alpha=0.9, \\beta=0.1$。\n实现将使用指定的随机种子以保证可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import beta as beta_function\n\ndef solve():\n    \"\"\"\n    Constructs and applies a Monte Carlo importance sampling estimator for integrals\n    with endpoint singularities, as specified in the problem statement.\n    \"\"\"\n\n    # Initialize a random number generator with the specified seed for reproducibility.\n    seed = 20231105\n    rng = np.random.default_rng(seed)\n\n    # Define the g(x) functions for each test case. Angles are in radians.\n    g1 = lambda x: np.exp(x)\n    g2 = lambda x: np.cos(x)\n    g3 = lambda x: np.sin(3 * x)\n    # For g(x)=1, return an array of ones to ensure correct vectorized computation.\n    g4 = lambda x: np.ones_like(x)\n    g5 = lambda x: np.exp(2 * x)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, b, g(x) function, sample size N)\n    test_cases = [\n        (0.5, 0.0, g1, 200000),\n        (0.9, 0.0, g2, 600000),\n        (0.49, 0.49, g3, 400000),\n        (0.99, 0.0, g4, 100000),\n        (0.1, 0.9, g5, 500000),\n    ]\n\n    results = []\n    for a, b, g, N in test_cases:\n        # Step 1: Define parameters for the Beta proposal distribution.\n        # Naming beta_p to avoid shadowing the imported beta_function.\n        alpha_p = 1.0 - a\n        beta_p = 1.0 - b\n\n        # Step 2: Pre-calculate the constant C = B(alpha, beta).\n        beta_constant = beta_function(alpha_p, beta_p)\n\n        # Step 3: Generate N random samples from the Beta(alpha, beta) distribution.\n        samples = rng.beta(alpha_p, beta_p, size=N)\n\n        # Step 4: Evaluate g(x) on the generated samples.\n        g_values = g(samples)\n\n        # Step 5: Compute the sample mean of g(x) values.\n        mean_g = np.mean(g_values)\n\n        # Step 6: The final estimate is B(alpha, beta) * mean(g(x)).\n        estimate = beta_constant * mean_g\n        \n        results.append(estimate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蒙特卡洛方法的应用远不止于数值积分，它更是模拟复杂物理系统和随机过程的强大工具。逾渗理论是统计物理学中的一个经典领域，其中蒙特卡洛模拟是研究系统相变行为不可或缺的手段。这个练习将引导你模拟一个格点上的逾渗过程，以估算其临界阈值。此任务不仅要求你运用蒙特卡洛方法的核心思想——通过大量独立实验求平均，还考验你设计高效算法（如并查集）以使复杂模拟在计算上可行的能力。",
            "id": "2415272",
            "problem": "您需要实现一个蒙特卡洛模拟程序，用以估算方形晶格上的位点渗流阈值。考虑一个具有自由边界的 $n \\times n$ 位点的方形网格，其中每个位点要么是开放的，要么是闭合的。如果存在一条由相邻的开放位点组成的路径，连接顶部边缘和底部边缘，则称该构型发生渗流。其中，相邻关系由 $4$-邻域连通性（上、下、左、右）定义。在每次模拟试验中，从所有位点都闭合的状态开始，以无放回的均匀随机顺序逐个开放位点，直到首次发生渗流。设 $N = n^2$。对于给定的某次试验，设 $K$ 为首次发生渗流瞬间的开放位点数；将该次试验的渗流阈值观测值定义为分数 $K/N$。对指定次数的试验独立重复此过程，并通过所有试验中观测到的分数的算术平均值来估算渗流阈值。\n\n您的推理和算法设计必须仅基于以下基本要素：晶格上位点渗流的定义、各次试验中独立同分布随机变量的定义、作为抽样估计量的算术平均值的定义，以及概率论中的大数强定律和中心极限定理。\n\n实现要求：\n- 使用一种算法数据结构，该结构能在每次开放位点后，高效地测试当前开放位点集合中是否存在从顶部边缘到底部边缘的路径，而无需每次都扫描整个网格。您必须在解决方案中证明您选择的合理性。\n- 每次试验必须使用一个独立的、$N$ 个位点的均匀随机排列来确定开放顺序。\n- 对于每个测试用例，仅报告蒙特卡洛估计值（所有试验记录的阈值的算术平均值），以小数点后保留 $4$ 位的十进制数形式报告。\n\n测试套件：\n您的程序必须运行以下四个参数集，并按指定顺序生成估计值：\n- Case A（正常路径，目标情况）：$n = 50$，试验次数 $= 200$，随机种子 $= 12345$。\n- Case B（边界情况，最小晶格）：$n = 1$，试验次数 $= 200$，随机种子 $= 2$。\n- Case C（中等晶格，更多试验）：$n = 10$，试验次数 $= 300$，随机种子 $= 777$。\n- Case D（与 Case A 同样大小，更多试验）：$n = 50$，试验次数 $= 300$，随机种子 $= 98765$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，结果顺序为 [Case A, Case B, Case C, Case D]。每个条目必须四舍五入到小数点后恰好 $4$ 位。例如，一个有效的输出行格式为“[0.5920,1.0000,0.5850,0.5925]”。不得打印任何其他文本。\n\n本任务中没有物理单位、角度或百分比。所有数值必须表示为纯数字。",
            "solution": "该问题要求估算带有自由边界的 $n \\times n$ 方形晶格上的位点渗流阈值，记为 $p_c$。这一目标将通过蒙特卡洛模拟实现。其方法论基于概率论和计算算法设计的基本原理。\n\n首先，我们对问题进行形式化描述。该系统是一个包含 $N = n^2$ 个位点的方形晶格。在单次模拟试验中，我们从所有位点均被指定为“闭合”状态开始。然后我们逐个开放位点，开放的顺序由从 $N$ 个位点中无放回抽取的均匀随机排列决定。设 $K$ 为首次出现一条由开放、相邻位点组成的连续路径连接晶格顶部边界与底部边界时的开放位点数。相邻关系由冯·诺依曼邻域（von Neumann neighborhood），即 $4$-连通性定义。单次试验 $i$ 的结果是临界分数 $p_i = K_i / N$。通过进行 $M$ 次独立同分布（i.i.d.）的试验，我们生成一组观测值 $\\{p_1, p_2, \\ldots, p_M\\}$。\n\n估算真实渗流阈值的理论基础在于大数定律。渗流阈值 $p_c$ 是无限晶格（$n \\to \\infty$）的一个性质。对于一个大小为 $n$ 的有限晶格，我们估算的是临界分数的期望值 $E[K/N]$。我们的蒙特卡洛估计量 $\\hat{p}_c$ 是各次试验结果的算术平均值：\n$$ \\hat{p}_c = \\frac{1}{M} \\sum_{i=1}^{M} p_i $$\n根据大数强定律，当试验次数 $M$ 趋于无穷大时，该样本均值几乎必然收敛于给定晶格尺寸下的真实期望值：\n$$ \\lim_{M \\to \\infty} \\hat{p}_c = E\\left[\\frac{K}{N}\\right] $$\n中心极限定理进一步告诉我们，对于足够大的 $M$，估计量 $\\hat{p}_c$ 的分布近似为正态分布，这使得量化统计不确定性成为可能，尽管当前任务不作此要求。\n\n算法设计的关键部分是高效地检测渗流事件。一种朴素的方法是，在每开放一个位点后，从所有顶行位点开始执行图遍历（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)），这种方法在计算上是不可行的。在包含 $N$ 个位点的网格上，单次 BFS/DFS 需要 $O(N)$ 的时间。由于我们可能需要开放多达 $O(N)$ 个位点，单次试验的总时间将为 $O(N^2)$，这对于指定的 $n = 50$ ($N = 2500$) 的晶格尺寸是不可行的。\n\n一个更优越的算法，也是我们将采用的算法，是利用并查集（Disjoint-Set Union, DSU 或 Union-Find）数据结构。该数据结构擅长维护不相交集合的集合，并高效地跟踪连通性。晶格上的每个位点都映射到并查集中的一个元素。初始时， $N$ 个位点中的每一个都存在于其自身的单元素集合中。当一个位点被开放时，我们遍历其四个邻居。如果一个邻居已经开放，我们就对包含当前位点及其邻居的集合执行 `union` 操作。通过按大小合并和路径压缩等优化，`union` 和 `find` 操作的均摊时间复杂度接近常数，记为 $O(\\alpha(N))$，其中 $\\alpha(N)$ 是增长极其缓慢的反阿克曼函数。\n\n为了专门测试从顶部到底部的渗流，我们对并查集数据结构进行了增强。对于并查集中的每个集合（由其根元素表示），我们维护两个布尔标记：`is_top_connected` 和 `is_bottom_connected`。\n- 当位于行 $r$ 和列 $c$ 的一个新位点被开放时，它最初形成自己的集合。如果 $r = 0$，其集合的 `is_top_connected` 标记被设为 `true`。如果 $r = n-1$，其 `is_bottom_connected` 标记被设为 `true`。对于 $n=1$ 的特殊情况，两个标记都被设为 `true`。\n- 当两个集合通过 `union` 操作合并时，新合并的集合继承了连通性属性。如果原始集合中任何一个连接到顶部，则新集合也连接到顶部。同样的逻辑适用于底部连通性。\n在某个集合同时拥有 `is_top_connected = true` 和 `is_bottom_connected = true` 属性的精确时刻，即检测到渗流。这可能在开放单个位点时发生（对于 $n=1$ 的情况），或者在一次 `union` 操作后立即发生。\n\n模拟的整体算法如下：\n1. 对于每个由晶格尺寸 $n$、试验次数 $M$ 和随机种子指定的测试用例，初始化一个列表来存储试验结果。\n2. 使用给定的种子初始化一个伪随机数生成器，以确保可复现性。\n3. 开始主循环，迭代 $M$ 次。每次迭代为一次试验。\n4. 在一次试验内部：\n    a. 初始化一个包含 $N = n^2$ 个元素的并查集数据结构，并为每个集合增强两个布尔标记。\n    b. 跟踪哪些位点是开放的，例如，使用一个布尔数组。\n    c. 生成从 $0$ 到 $N-1$ 的位点索引的随机排列。此序列决定了位点被开放的顺序。\n    d. 遍历排列后的位点索引。对于每个被开放的位点 `s`：\n        i. 将开放位点的计数 $K$ 加一。将位点 `s` 标记为开放。\n        ii. 为仅包含 `s` 的新集合初始化渗流标记。检查这个新的单位点簇是否渗流（仅在 $n=1$ 时可能）。\n        iii. 识别 `s` 的四个邻居。对于每个已经开放的邻居 `t`，执行 `union(s, t)`。\n        iv. 每次 `union` 操作后，通过检查其根的标记来判断新形成的簇是否渗流。\n        v. 如果检测到渗流，计算分数 $p_i = K/N$，存储该值，并终止当前试验，继续下一次试验。\n5. 所有 $M$ 次试验完成后，计算存储的分数 $\\{p_i\\}$ 的算术平均值。\n6. 将结果格式化为所需精度，并将其添加到最终答案列表中。\n\n这种基于并查集的方法每次试验的时间复杂度约为 $O(N \\cdot \\alpha(N))$，使得所有测试用例的模拟在计算上都是高效和可行的。$n=1$ 的情况是一个平凡的边界情况，只要唯一的那个位点被开放，渗流就会发生，因此 $K=1, N=1$，阈值始终为 $1.0$。该算法能正确处理此场景。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass UnionFind:\n    \"\"\"\n    A Disjoint-Set Union (DSU) data structure with path compression\n    and union by size, augmented for percolation checking.\n    \"\"\"\n    \n    def __init__(self, n_grid):\n        \"\"\"\n        Initializes the DSU for an n_grid x n_grid lattice.\n        \n        Args:\n            n_grid (int): The side length of the square grid.\n        \"\"\"\n        self.n = n_grid\n        self.N = n_grid * n_grid\n        self.parent = np.arange(self.N)\n        self.sz = np.ones(self.N, dtype=int)\n        \n        # Flags to track if a set is connected to the top or bottom edge.\n        # These properties are stored at the root of each set.\n        self.is_top_connected = np.zeros(self.N, dtype=bool)\n        self.is_bottom_connected = np.zeros(self.N, dtype=bool)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing element i with path compression.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j, using union by size.\n        Updates connectivity flags and returns True if percolation occurs.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        \n        if root_i == root_j:\n            # Already in the same set, no change.\n            return False\n\n        # Union by size heuristic\n        if self.sz[root_i]  self.sz[root_j]:\n            root_i, root_j = root_j, root_i\n        \n        self.parent[root_j] = root_i\n        self.sz[root_i] += self.sz[root_j]\n        \n        # Merge connectivity flags\n        new_top_connected = self.is_top_connected[root_i] or self.is_top_connected[root_j]\n        new_bottom_connected = self.is_bottom_connected[root_i] or self.is_bottom_connected[root_j]\n        \n        self.is_top_connected[root_i] = new_top_connected\n        self.is_bottom_connected[root_i] = new_bottom_connected\n        \n        # Check for percolation\n        return new_top_connected and new_bottom_connected\n\ndef run_single_trial(n, rng):\n    \"\"\"\n    Runs a single percolation simulation trial on an n x n grid.\n    \n    Args:\n        n (int): The side length of the square grid.\n        rng (numpy.random.Generator): The random number generator.\n\n    Returns:\n        float: The percolation threshold (K/N) for this trial.\n    \"\"\"\n    N = n * n\n    if n == 0:\n        return 0.0\n\n    uf = UnionFind(n)\n    is_open = np.zeros(N, dtype=bool)\n    \n    site_order = rng.permutation(N)\n    \n    for num_opened, site_idx in enumerate(site_order, 1):\n        is_open[site_idx] = True\n        \n        row, col = divmod(site_idx, n)\n        \n        # Initialize flags for the newly opened site's set\n        root = uf.find(site_idx)\n        if row == 0:\n            uf.is_top_connected[root] = True\n        if row == n - 1:\n            uf.is_bottom_connected[root] = True\n            \n        # Check if the single-site cluster percolates (only for n=1)\n        if uf.is_top_connected[root] and uf.is_bottom_connected[root]:\n            return num_opened / N\n            \n        # Check and union with open neighbors\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            neighbor_row, neighbor_col = row + dr, col + dc\n            \n            if 0 = neighbor_row  n and 0 = neighbor_col  n:\n                neighbor_idx = neighbor_row * n + neighbor_col\n                if is_open[neighbor_idx]:\n                    if uf.union(site_idx, neighbor_idx):\n                        return num_opened / N\n    \n    # This part should not be reached in a valid percolation setup\n    # where the grid can become fully connected.\n    return 1.0\n\ndef run_simulation(n, num_trials, seed):\n    \"\"\"\n    Runs the full Monte Carlo simulation for a given parameter set.\n    \n    Args:\n        n (int): The side length of the square grid.\n        num_trials (int): The number of independent trials to run.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated percolation threshold.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    thresholds = []\n    \n    for _ in range(num_trials):\n        threshold = run_single_trial(n, rng)\n        thresholds.append(threshold)\n        \n    return np.mean(thresholds)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, num_trials, random_seed)\n        (50, 200, 12345),   # Case A\n        (1, 200, 2),        # Case B\n        (10, 300, 777),     # Case C\n        (50, 300, 98765),   # Case D\n    ]\n\n    results = []\n    for n, num_trials, seed in test_cases:\n        mean_threshold = run_simulation(n, num_trials, seed)\n        results.append(f\"{mean_threshold:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}