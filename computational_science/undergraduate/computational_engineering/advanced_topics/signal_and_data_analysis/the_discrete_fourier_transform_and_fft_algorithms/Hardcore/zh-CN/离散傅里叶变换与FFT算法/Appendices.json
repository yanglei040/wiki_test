{
    "hands_on_practices": [
        {
            "introduction": "快速傅里叶变换 (FFT) 是现代数字信号处理的基石。虽然许多计算库都提供了高效的FFT实现，但从零开始构建它能让你对该算法的“分而治之”策略有更深刻的理解。本练习将指导你亲手实现经典的Cooley-Tukey FFT算法，并通过验证卷积定理和帕塞瓦尔恒等式等基本性质来巩固你的认识。",
            "id": "2387187",
            "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 为非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n其逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换例程的情况下，计算长度为 $N = 2^m$ 的序列的 DFT 和 IDFT。您的程序还必须仅使用这些定义，通过明确的测试用例来验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，它们的长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，该定理满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- 帕塞瓦尔恒等式（使用上述归一化）：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 时的 DFT 和 IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT 用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度必须解释为弧度。\n\n使用以下测试套件，并按下述顺序生成输出：\n\n- 测试 1 (DFT 与直接 DFT 的正确性比较，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2 (逆变换恢复)：使用与测试 1 相同的 $N$ 和 $x$，通过将您的 IDFT 应用于您快速实现得到的 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3 (通过频域进行循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$，以及 $b = [0,1,0,0,0,0,0,0]$。直接根据其定义计算长度为 $N$ 的循环卷积 $c$。另外，通过对 $a$ 和 $b$ 进行 DFT、逐点相乘并应用 IDFT 来计算 $\\hat{c}$。以浮点数形式输出标量 $\\max_n |c_n - \\hat{c}_n|$。\n- 测试 4 (帕塞瓦尔恒等式)：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，其中 $n = 0,1,\\dots,15$。通过您的快速实现计算 $X$。以浮点数形式输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$。\n- 测试 5 (边缘情况 $N=1$)：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$ 然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6 (最小非平凡尺寸 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下，精确的 DFT 是 $[0,2]$。以浮点数形式输出标量 $\\max_k |X_k - [0,2]_k|$。\n\n最终输出格式：您的程序应生成一行输出，其中包含按顺序排列的六个结果，形式为逗号分隔的列表，并用方括号括起，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔值条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实数值条目必须以标准十进制或科学记数法打印。不应打印其他任何文本。",
            "solution": "所提出的问题是计算物理领域，特别是信号处理领域中一个适定且科学严谨的练习。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整的、客观的，并且其解决方案是可验证的。我们将开始解决此问题。\n\n问题的核心是为给定长度为 $N$ 的离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算 DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n直接实现此公式涉及两个嵌套循环，一个用于从 $0$ 到 $N-1$ 的每个索引 $k$，另一个用于从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为 $\\mathcal{O}(N^2)$，对于大的 $N$ 来说效率低下。为了验证目的，我们将实现这样一种直接方法。\n\n问题规定 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 为非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。长度为 $N$ 的 DFT 被递归地分解为两个长度为 $(N/2)$ 的 DFT。\n\n设序列 $x_n$ 被分为其偶数索引元素，形成一个序列 $x'_m = x_{2m}$，以及其奇数索引元素，形成一个序列 $x''_m = x_{2m+1}$，每个序列的长度均为 $N/2$。DFT 的求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”。对于索引的前半部分，$0 \\le k  N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$（$0 \\le k  N/2$），我们利用性质 $X'_{k+N/2} = X'_k$，$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得出：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。递归在基例 $N=1$ 处终止，其中序列 $\\{x_0\\}$ 的 DFT 就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n没有必要进行单独的实现。我们可以将 IDFT 与正向 DFT 联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n右侧是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，然后对结果取复共轭，再乘以 $1/N$ 来求得 $x_n$。即，$x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这使我们能够使用我们高效的 FFT 实现来计算逆变换 (IFFT)。\n\n该问题还要求验证两个基本定理。\n\n首先，循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是各个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素相乘。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来测试这一点。\n\n其次，帕塞瓦尔恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将针对一个特定的测试信号来验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT、一个递归的 $\\mathcal{O}(N \\log N)$ FFT、一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和 $\\varepsilon = 10^{-9}$ 的数值容差来执行指定的 6 个测试用例。结果将被收集并以要求的格式打印出来。",
            "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N == 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了如何高效计算离散傅里叶变换 (DFT) 后，下一步关键在于如何解读其输出。本练习要求你从第一性原理出发，推导一个纯复指数信号的DFT表达式。通过这个理论实践，你将能深刻理解当信号频率未精确落在DFT频率“栅格”上时发生的频谱泄漏现象，这是在实际应用中进行精确频率分析的基础。",
            "id": "2443861",
            "problem": "考虑一个长度为$N$的离散时间复指数信号，定义为 $x[n] = \\exp(j \\omega_0 n)$（当 $0 \\leq n \\leq N-1$ 时），且在其他情况下 $x[n] = 0$。其中 $\\omega_0$ 是以弧度/样本为单位的实角频率。令 $X[k]$ 表示 $x[n]$ 的 $N$ 点离散傅里叶变换 (DFT)，定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-j \\frac{2\\pi}{N} k n\\right), \\quad 0 \\leq k \\leq N-1.\n$$\n从第一性原理出发，且不使用任何预先制定的变换对，推导一个对所有实数 $\\omega_0$ 都有效的 $X[k]$ 的闭式表达式。然后，在以下几种情况下，分析其幅值 $|X[k]|$ 的定性行为：\n- 情况 (i)：对于某个整数 $m$，有 $\\omega_0 = \\frac{2\\pi}{N} m$。\n- 情况 (ii)：对于某个整数 $m$ 和一个满足 $0  |\\varepsilon|  \\frac{\\pi}{N}$ 的微小非零偏差 $\\varepsilon$，有 $\\omega_0 = \\frac{2\\pi}{N} m + \\varepsilon$。\n- 情况 (iii)：$\\omega_0$ 与 $\\frac{2\\pi}{N}$ 的任何整数倍都不是模 $2\\pi$ 同余。\n\n你最终报告的答案必须是 $X[k]$ 关于 $N$、$\\omega_0$ 和 $k$ 的单一闭式解析表达式。不需要数值近似。所有角度均以弧度表示。最终答案必须是单一的解析表达式；不要在最终答案中包含任何额外的评论或单位。",
            "solution": "该问题陈述具有科学依据、问题明确、客观且自洽。它提出了离散信号处理中的一个基本任务：推导复指数信号的离散傅里叶变换 (DFT)。所有必要的定义和参数都已提供，不存在矛盾或模糊之处。该问题适合进行分析。\n\n我们从信号 $x[n]$ 的 $N$ 点 DFT 定义开始：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi}{N} k n\\right)\n$$\n给定信号为 $x[n] = \\exp(j \\omega_0 n)$（当 $0 \\leq n \\leq N-1$ 时）。将其代入 DFT 公式可得：\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp(j \\omega_0 n) \\exp\\left(-j \\frac{2\\pi}{N} k n\\right)\n$$\n合并指数项，我们得到：\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\left(\\omega_0 - \\frac{2\\pi k}{N}\\right) n\\right)\n$$\n这是一个形式为 $\\sum_{n=0}^{N-1} r^n$ 的有限几何级数，其中公比为 $r = \\exp(j (\\omega_0 - \\frac{2\\pi k}{N}))$。\n\n有限几何级数的和由 $\\frac{1 - r^N}{1 - r}$ 给出，这在 $r \\neq 1$ 时有效。我们还必须考虑 $r = 1$ 的特殊情况。\n\n情况 A：$r \\neq 1$。\n如果 $r$ 定义中的指数不是 $2\\pi$ 的整数倍，则此条件成立。也就是说，对于任何整数 $p$，有 $\\omega_0 - \\frac{2\\pi k}{N} \\neq 2\\pi p$。在这种情况下，我们应用公式：\n$$\nX[k] = \\frac{1 - \\left(\\exp\\left(j \\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\right)^N}{1 - \\exp\\left(j \\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)} = \\frac{1 - \\exp\\left(j N\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}{1 - \\exp\\left(j \\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}\n$$\n为了获得一个更具洞察力的形式，我们从分子和分母中提出对应于半角的项：\n$$\nX[k] = \\frac{\\exp\\left(j \\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\left[\\exp\\left(-j \\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right) - \\exp\\left(j \\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\right]}{\\exp\\left(j \\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\left[\\exp\\left(-j \\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right) - \\exp\\left(j \\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\right]}\n$$\n使用恒等式 $\\sin(\\theta) = \\frac{\\exp(j\\theta) - \\exp(-j\\theta)}{2j}$，我们可以将其写为：\n$$\nX[k] = \\frac{\\exp\\left(j \\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right) \\left[-2j \\sin\\left(\\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\right]}{\\exp\\left(j \\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right) \\left[-2j \\sin\\left(\\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)\\right]}\n$$\n相位项合并，其他因子化简，得到：\n$$\nX[k] = \\exp\\left(j \\left(\\frac{N-1}{2}\\right)\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right) \\frac{\\sin\\left(\\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}{\\sin\\left(\\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}\n$$\n这个表达式是狄利克雷核（Dirichlet kernel）的一种形式，经过了缩放和相移。\n\n情况 B：$r = 1$。\n如果对于某个整数 $p$，有 $\\omega_0 - \\frac{2\\pi k}{N} = 2\\pi p$，则此条件成立。在这种情况下，求和中的每一项都是 $\\exp(j 2\\pi p n) = 1$。和变为：\n$$\nX[k] = \\sum_{n=0}^{N-1} 1 = N\n$$\n我们可以证明，在情况 A 中推导出的表达式收敛于此值。令 $\\alpha = \\frac{1}{2}(\\omega_0 - \\frac{2\\pi k}{N})$。条件 $r=1$ 对应于 $\\alpha = \\pi p$。我们使用 L'Hôpital 法则计算当 $\\alpha \\to \\pi p$ 时表达式幅值部分的极限：\n$$\n\\lim_{\\alpha \\to \\pi p} \\frac{\\sin(N\\alpha)}{\\sin(\\alpha)} = \\lim_{\\alpha \\to \\pi p} \\frac{N \\cos(N\\alpha)}{\\cos(\\alpha)} = \\frac{N \\cos(N\\pi p)}{\\cos(\\pi p)} = \\frac{N (-1)^{Np}}{(-1)^p} = N(-1)^{p(N-1)}\n$$\n情况 A 中的相位项是 $\\exp(j (N-1)\\alpha)$。当 $\\alpha \\to \\pi p$ 时，它变为 $\\exp(j (N-1)\\pi p) = ((-1)^{p})^{N-1} = (-1)^{p(N-1)}$。\n将相位和幅值的极限相乘，得到 $N(-1)^{p(N-1)} (-1)^{p(N-1)} = N$。\n由于情况 A 的表达式有一个明确的极限，且该极限等于情况 B 的结果，因此它对所有实数 $\\omega_0$ 均有效，其中在可去奇点处的值由这些极限定义。\n\n现在，我们分析幅值 $|X[k]|$ 的定性行为。相位项的模为 1，所以：\n$$\n|X[k]| = \\left|\\frac{\\sin\\left(\\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}{\\sin\\left(\\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}\\right|\n$$\n\n情况 (i)：对于某个整数 $m$，有 $\\omega_0 = \\frac{2\\pi}{N} m$。\n信号频率恰好与一个 DFT 频率仓重合。不失一般性，我们假设 $0 \\leq m \\leq N-1$。正弦函数的参数变为，对于分子是 $\\frac{N}{2}(\\frac{2\\pi m}{N} - \\frac{2\\pi k}{N}) = \\pi(m-k)$，对于分母是 $\\frac{1}{2}(\\frac{2\\pi m}{N} - \\frac{2\\pi k}{N}) = \\frac{\\pi}{N}(m-k)$。\n如果 $k=m$，分母为 $\\sin(0)=0$。这对应于我们情况 B 中 $p=0$ 的分析。因此，$X[m] = N$ 且 $|X[m]| = N$。\n如果 $k \\neq m$，分母 $\\sin(\\frac{\\pi}{N}(m-k))$ 非零，因为 $0  |m-k|  N$。同时，分子 $\\sin(\\pi(m-k))$ 为零，因为 $m-k$ 是一个非零整数。因此，对于所有 $k \\neq m$，$X[k]=0$ 且 $|X[k]|=0$。所有能量都集中在单个频率仓 $k=m$ 中。\n\n情况 (ii)：对于某个整数 $m$ 和小的非零 $\\varepsilon$，有 $\\omega_0 = \\frac{2\\pi}{N} m + \\varepsilon$。\n参数变为 $\\omega_0 - \\frac{2\\pi k}{N} = \\frac{2\\pi}{N}(m-k) + \\varepsilon$。\n对于 $k=m$，参数为 $\\varepsilon$。当 $\\varepsilon$ 很小时，$|X[m]| = |\\frac{\\sin(N\\varepsilon/2)}{\\sin(\\varepsilon/2)}| \\approx |\\frac{N\\varepsilon/2}{\\varepsilon/2}| = N$。\n对于 $k \\neq m$，参数不为零。$|X[k]|$ 的值将不为零，这表明能量“泄漏”到了相邻的频率仓中。这解释了频谱泄漏现象。\n\n情况 (iii)：$\\omega_0$ 与 $\\frac{2\\pi}{N}$ 的任何整数倍都不是模 $2\\pi$ 同余。\n这意味着对于所有 $k \\in \\{0, \\dots, N-1\\}$，$\\omega_0 - \\frac{2\\pi k}{N}$ 都不是 $2\\pi$ 的整数倍。因此，几何级数的公比总是不等于 1。这种情况与情况 (ii) 本质上相同，但没有一个频率仓会特别接近峰值。频谱将在所有仓中呈现一个非零值，峰值将位于最接近 $\\frac{N\\omega_0}{2\\pi}$ 的 $k$ 值附近。",
            "answer": "$$\n\\boxed{\\exp\\left(j \\left(\\frac{N-1}{2}\\right)\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right) \\frac{\\sin\\left(\\frac{N}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}{\\sin\\left(\\frac{1}{2}\\left(\\omega_0 - \\frac{2\\pi k}{N}\\right)\\right)}}\n$$"
        },
        {
            "introduction": "傅里叶级数是表示周期信号的强大工具，但它在信号的突变或不连续点附近表现如何？著名的吉布斯现象描述了在这种情况下出现的特征性“过冲”。本练习将通过编程实践，利用傅里叶逆变换重构一个方波信号，让你能够直观地观察并量化这一在信号和图像处理中具有重要意义的效应。",
            "id": "2443812",
            "problem": "考虑一个离散时间、实值的周期性方波，其一个周期由长度为 $N$ 的序列 $s[n]$ 表示，其中 $n \\in \\{0,1,\\dots,N-1\\}$ 且 $N$ 为偶数。该序列定义如下\n$$\ns[n] =\n\\begin{cases}\n+1,  0 \\le n  N/2, \\\\\n-1,  N/2 \\le n  N.\n\\end{cases}\n$$\n令 $X[k]$ 表示 $s[n]$ 的离散傅里叶变换 (DFT)，其定义为 $k \\in \\{0,1,\\dots,N-1\\}$：\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] \\, e^{-i 2\\pi nk/N},\n$$\n逆离散傅里叶变换 (IDFT) 由下式给出\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi nk/N}.\n$$\n所有角度均以弧度为单位。对于整数带宽参数 $K$（满足 $0 \\le K \\le \\left\\lfloor \\frac{N}{2} \\right\\rfloor - 1$），定义索引集\n$$\n\\mathcal{S}_K = \\{0\\} \\cup \\{1,2,\\dots,K\\} \\cup \\{N-K, N-K+1, \\dots, N-1\\},\n$$\n以及频谱截断重构\n$$\nx_K[n] = \\frac{1}{N} \\sum_{k \\in \\mathcal{S}_K} X[k] \\, e^{i 2\\pi nk/N}.\n$$\n令 $M_K = \\max_{0 \\le n \\le N-1} x_K[n]$ 且 $m_K = \\min_{0 \\le n \\le N-1} x_K[n]$。设高平台为 $A_{\\text{high}} = +1$，低平台为 $A_{\\text{low}} = -1$，跳变幅度为 $J = A_{\\text{high}} - A_{\\text{low}} = 2$，定义归一化吉布斯偏差为\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - A_{\\text{high}})}{J}, \\; \\frac{\\max(0, A_{\\text{low}} - m_K)}{J} \\right).\n$$\n量 $G_K$ 捕捉了重构序列 $x_K[n]$ 中高于 $A_{\\text{high}}$ 的归一化过冲和低于 $A_{\\text{low}}$ 的归一化下冲的最大值。对于足够大但又不太接近奈奎斯特极限的 $K$，对于此方波跳变，$G_K$ 应接近著名的吉布斯常数，约等于 $0.08949$。\n\n您的任务是编写一个完整的程序，对下面指定的每个测试用例，构建 $s[n]$、计算 $X[k]$、从截断的频谱中形成 $x_K[n]$、评估 $G_K$，并输出结果。\n\n测试套件（每个测试用例是一个 $(N,K)$ 对）：\n- 用例 1：$(4096, 0)$。\n- 用例 2：$(4096, 1)$。\n- 用例 3：$(4096, 3)$。\n- 用例 4：$(4096, 7)$。\n- 用例 5：$(4096, 15)$。\n- 用例 6：$(4096, 63)$。\n- 用例 7：$(4096, 255)$。\n- 用例 8：$(64, 31)$。\n\n对于每个用例，计算 $G_K$ 为一个浮点数，并四舍五入到 $6$ 位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的八个四舍五入值的列表，用方括号括起来，顺序与上述测试用例相同。例如，一个有效的输出格式是 [$0.123456$,$0.234567$,$0.345678$,$0.456789$,$0.567890$,$0.678901$,$0.789012$,$0.890123$]。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于傅里叶分析的原理，在数学上是适定的，并且是客观明确的。该问题是自包含的，提供了所有必要的定义、常数和参数，以获得唯一且可验证的解。因此，我们将着手进行推导和计算。\n\n目标是计算周期性方波的截断傅里叶级数重构的归一化吉布斯偏差 $G_K$。该过程涉及几个不同的步骤，将对每个提供的测试用例 $(N, K)$ 执行这些步骤。\n\n步骤 1：信号生成\n首先，我们为给定的长度 $N$（指定为偶数）构建离散时间信号 $s[n]$。该信号代表方波的一个周期。其定义为：\n$$\ns[n] =\n\\begin{cases}\n+1,  0 \\le n  N/2, \\\\\n-1,  N/2 \\le n  N.\n\\end{cases}\n$$\n该序列是实值的，长度为 $N$ 个样本，索引从 $n=0$ 到 $n=N-1$。\n\n步骤 2：离散傅里叶变换 (DFT)\n接下来，我们计算信号 $s[n]$ 的 DFT，以获得其频域表示 $X[k]$。DFT 定义为：\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] \\, e^{-i 2\\pi nk/N}\n$$\n对于 $k \\in \\{0, 1, \\dots, N-1\\}$。为提高计算效率，此变换将使用快速傅里叶变换 (FFT) 算法实现，这是合适的，因为测试套件中的 $N$ 值都是 2 的幂。\n\n步骤 3：频谱截断\n根据整数带宽参数 $K$ 创建频谱的截断版本。通过保留集合 $\\mathcal{S}_K$ 内索引 $k$ 对应的 $X[k]$ 系数，并将所有其他系数设置为零，形成一个新的频谱序列，我们可以将其表示为 $X_K[k]$。索引集 $\\mathcal{S}_K$ 定义为：\n$$\n\\mathcal{S}_K = \\{0\\} \\cup \\{1,2,\\dots,K\\} \\cup \\{N-K, N-K+1, \\dots, N-1\\}\n$$\n该集合包括直流分量 ($k=0$)、前 $K$ 个正频率分量 ($k=1, \\dots, K$) 以及相应的 $K$ 个负频率分量 ($k=N-K, \\dots, N-1$)，这些对于确保重构信号是实值是必要的。因此，$X_K[k]$ 定义为：\n$$\nX_K[k] =\n\\begin{cases}\nX[k],  k \\in \\mathcal{S}_K,\\\\\n0,  k \\notin \\mathcal{S}_K.\n\\end{cases}\n$$\n\n步骤 4：信号重构\n通过计算截断频谱 $X_K[k]$ 的逆离散傅里叶变换 (IDFT) 来合成截断信号 $x_K[n]$。IDFT 公式为：\n$$\nx_K[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X_K[k] \\, e^{i 2\\pi nk/N}\n$$\n与正变换类似，为了效率，将使用逆快速傅里叶变换 (IFFT) 算法。由于原始信号 $s[n]$ 是实数，并且截断频谱 $X_K[k]$ 是以共轭对称方式构建的（即，$X_K[k] = \\overline{X_K[N-k]}$），因此得到的信号 $x_K[n]$ 将是实值的，尽管由于浮点误差可能会出现微小的虚部，应将其舍弃。\n\n步骤 5：吉布斯偏差计算\n最后，我们通过计算归一化吉布斯偏差 $G_K$ 来量化吉布斯现象。这需要找到重构信号 $x_K[n]$ 在一个周期内的最大值和最小值：\n$$\nM_K = \\max_{0 \\le n \\le N-1} x_K[n]\n$$\n$$\nm_K = \\min_{0 \\le n \\le N-1} x_K[n]\n$$\n问题提供了高平台水平 $A_{\\text{high}} = +1$、低平台水平 $A_{\\text{low}} = -1$ 和跳变幅度 $J = A_{\\text{high}} - A_{\\text{low}} = 2$。归一化吉布斯偏差 $G_K$ 是归一化过冲和下冲中的最大值：\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - A_{\\text{high}})}{J}, \\; \\frac{\\max(0, A_{\\text{low}} - m_K)}{J} \\right)\n$$\n代入给定值，得到：\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - 1)}{2}, \\; \\frac{\\max(0, -1 - m_K)}{2} \\right)\n$$\n对测试套件中指定的每个 $(N, K)$ 对执行此计算，并将得到的 $G_K$ 值按要求四舍五入到 6 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized Gibbs deviation G_K for a truncated Fourier series\n    reconstruction of a square wave for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as (N, K) pairs.\n    test_cases = [\n        (4096, 0),\n        (4096, 1),\n        (4096, 3),\n        (4096, 7),\n        (4096, 15),\n        (4096, 63),\n        (4096, 255),\n        (64, 31),\n    ]\n\n    # Constants for Gibbs deviation calculation.\n    A_high = 1.0\n    A_low = -1.0\n    J = A_high - A_low  # Jump magnitude\n\n    results = []\n    for N, K in test_cases:\n        # Step 1: Construct the discrete-time square wave signal s[n].\n        # N is guaranteed to be even.\n        s_n = np.ones(N)\n        s_n[N // 2:] = -1.0\n\n        # Step 2: Compute the Discrete Fourier Transform (DFT) of s[n] using FFT.\n        X_k = np.fft.fft(s_n)\n\n        # Step 3: Truncate the spectrum based on the bandwidth parameter K.\n        # Create a new spectrum X_K_k initialized to zeros.\n        X_K_k = np.zeros_like(X_k, dtype=complex)\n\n        # The index set S_K is {0} U {1,...,K} U {N-K,...,N-1}.\n        # Copy the DC component (k=0).\n        if K >= 0:\n            X_K_k[0] = X_k[0]\n        \n        if K > 0:\n            # Copy positive frequency components (k=1,...,K).\n            X_K_k[1:K + 1] = X_k[1:K + 1]\n            # Copy negative frequency components (k=N-K,...,N-1).\n            X_K_k[N - K:] = X_k[N - K:]\n\n        # Step 4: Compute the truncated reconstruction x_K[n] using IFFT.\n        # np.fft.ifft includes the 1/N scaling factor.\n        # The result should be real due to conjugate symmetry, so we take the real part.\n        x_K_n = np.fft.ifft(X_K_k).real\n\n        # Step 5: Find the maximum and minimum values of the reconstructed signal.\n        M_K = np.max(x_K_n)\n        m_K = np.min(x_K_n)\n\n        # Step 6: Calculate the normalized Gibbs deviation G_K.\n        # It is the maximum of the normalized overshoot and undershoot.\n        overshoot_norm = max(0, M_K - A_high) / J\n        undershoot_norm = max(0, A_low - m_K) / J\n        G_K = max(overshoot_norm, undershoot_norm)\n        \n        # Round the result to 6 decimal places and append to the list.\n        results.append(round(G_K, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}