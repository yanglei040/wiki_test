{
    "hands_on_practices": [
        {
            "introduction": "在无网格粒子法中，尤其是在弱可压光滑粒子流体动力学（SPH）中，压力通常通过状态方程直接从密度计算得出，而非求解压力泊松方程。本练习将引导你通过一个静水压问题，亲手推导并比较基于状态方程的压力模型与经典不可压缩流体压力模型之间的差异。通过这个实践，你将深刻理解弱可压近似的本质，并量化其与理想不可压缩模型的偏差。",
            "id": "2413331",
            "problem": "给定一个一维、垂直、静态的水柱，该水柱被建模为一组等间距的粒子（一种无网格离散化方法），其自由表面高度为 $z = H$，底部高度为 $z = 0$。重力向下作用，其大小为 $g$。参考流体密度为 $\\rho_0$，自由表面的静水压力为 $p_0$（大气压力），您可以将其视为零表压，即 $p_0 = 0$。您将比较两种在粒子位置处近似计算压力场的模型：\n\n1. 状态方程（EOS）方法，该方法是弱可压光滑粒子流体动力学（SPH）的代表。使用水的泰特状态方程：\n$$\np(\\rho) - p_0 = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\right],\n$$\n其中 $c_0$ 是人工声速，$\\gamma$ 是泰特指数。在重力作用下的静力平衡状态下，动量平衡方程简化为\n$$\n\\frac{dp}{dz} = -\\rho g,\n$$\n并且 EOS 将 $p$ 和 $\\rho$ 关联起来。施加自由表面边界条件 $p(H) = p_0$。\n\n2. 基于投影法的不可压求解器模型，其中密度是恒定的 $\\rho = \\rho_0$，静力平衡简化为\n$$\n\\frac{dp}{dz} = -\\rho_0 g,\n$$\n其自由表面边界条件为 $p(H) = p_0$。\n\n任务：\n- 从第一性原理推导所需的解析表达式，以在给定参数 $(\\rho_0, g, c_0, \\gamma, H)$ 的情况下，评估任意深度 $z \\in [0,H]$ 处的 EOS 可压缩静水压力 $p_{\\mathrm{eos}}(z)$ 和不可压缩静水压力 $p_{\\mathrm{inc}}(z)$。\n- 使用包含 $N$ 个沿水柱等间距分布的粒子的离散化方法，在每个粒子位置 $z_i$（其中 $i = 0, 1, \\dots, N-1$）处计算 $p_{\\mathrm{eos}}$ 和 $p_{\\mathrm{inc}}$。粒子位置必须为 $z_i = i \\Delta z$，其中 $\\Delta z = H/(N-1)$。\n- 计算所有粒子上两个压力场之间的最大逐点绝对偏差：\n$$\n\\Delta p_{\\max} = \\max_{0 \\le i  N} \\left| p_{\\mathrm{eos}}(z_i) - p_{\\mathrm{inc}}(z_i) \\right|.\n$$\n\n物理单位：\n- 所有输入均采用国际单位制。您的程序必须以帕斯卡（Pa）为单位报告 $\\Delta p_{\\max}$。将每个结果表示为四舍五入到小数点后三位的小数。\n\n测试套件：\n您的程序必须评估以下四个测试用例，并按如下规定，在单行中输出四个结果。\n\n- 用例 A（正常路径）：$\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 1.0$ m, $c_0 = 50.0$ m/s, $\\gamma = 7.0$, $N = 101$。\n- 用例 B（浅水柱边界情况）：$\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 0.1$ m, $c_0 = 50.0$ m/s, $\\gamma = 7.0$, $N = 11$。\n- 用例 C（软 EOS 边缘情况）：$\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 2.0$ m, $c_0 = 10.0$ m/s, $\\gamma = 7.0$, $N = 201$。\n- 用例 D（硬 EOS 近乎不可压缩）：$\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 2.0$ m, $c_0 = 1000.0$ m/s, $\\gamma = 7.0$, $N = 51$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个用例的结果，顺序为 A、B、C、D，格式为方括号括起来的逗号分隔列表，例如：\n\"[x_A,x_B,x_C,x_D]\"\n- 每个 $x_\\cdot$ 是以帕斯卡为单位的 $\\Delta p_{\\max}$ 的值，四舍五入到小数点后三位。\n- 程序必须是自包含的，不得读取任何输入，也不得执行任何文件或网络 I/O 操作。",
            "solution": "该问题要求推导和比较两种用于计算高度为 $H$ 的一维水柱中静水压力的模型。第一个模型是针对不可压缩流体的，第二个模型是针对由泰特状态方程（EOS）描述的弱可压缩流体的。最终目标是在一组离散化的粒子位置上，找出这两种模型之间的最大绝对压力偏差。\n\n首先，我们推导不可压缩模型中压力场 $p_{\\mathrm{inc}}(z)$ 的解析表达式。静力平衡的控制方程是动量平衡方程，它简化为：\n$$\n\\frac{dp}{dz} = -\\rho g\n$$\n在不可压缩模型中，密度被假定为常数，即 $\\rho = \\rho_0$。该方程变为：\n$$\n\\frac{dp_{\\mathrm{inc}}}{dz} = -\\rho_0 g\n$$\n这是一个简单的常微分方程。我们对垂直坐标 $z$ 进行积分：\n$$\n\\int dp_{\\mathrm{inc}} = \\int -\\rho_0 g \\, dz \\implies p_{\\mathrm{inc}}(z) = -\\rho_0 g z + C\n$$\n其中 $C$ 是积分常数。我们通过应用自由表面 $z=H$ 处的边界条件来确定 $C$，在该处压力给定为 $p_0=0$。\n$$\np_{\\mathrm{inc}}(H) = -\\rho_0 g H + C = 0 \\implies C = \\rho_0 g H\n$$\n将该常数代回压力表达式，得到不可压缩静水压力的最终形式：\n$$\np_{\\mathrm{inc}}(z) = \\rho_0 g H - \\rho_0 g z = \\rho_0 g (H-z)\n$$\n这是压力和深度之间我们所熟知的线性关系，其中 $H-z$ 是自由表面以下的深度。\n\n接下来，我们推导弱可压缩模型的压力场 $p_{\\mathrm{eos}}(z)$。我们有一个包含两个耦合方程的方程组：静力平衡方程（其中密度 $\\rho$ 现在是压力的函数）和泰特状态方程。\n1. 静力平衡：$\\frac{dp}{dz} = -\\rho(p) g$\n2. 泰特状态方程（$p_0 = 0$）：$p(\\rho) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\right]$\n\n为求解此方程组，我们首先从 EOS 中将密度 $\\rho$ 表示为压力 $p$ 的函数：\n$$\n\\frac{p \\gamma}{\\rho_0 c_0^2} = \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\implies \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} = 1 + \\frac{p \\gamma}{\\rho_0 c_0^2}\n$$\n$$\n\\rho(p) = \\rho_0 \\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{1/\\gamma}\n$$\n将此表达式代入静力平衡方程，得到一个关于 $p(z)$ 的一阶可分离常微分方程：\n$$\n\\frac{dp}{dz} = -g \\rho_0 \\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{1/\\gamma}\n$$\n我们分离变量 $p$ 和 $z$：\n$$\n\\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{-1/\\gamma} dp = -g \\rho_0 dz\n$$\n我们对两边进行积分。左边的积分从表面压力 $p(H)=0$ 到任意高度 $z$ 处的压力 $p(z)$。右边的积分则相应地从 $H$ 到 $z$。\n$$\n\\int_{0}^{p(z)} \\left( 1 + \\frac{\\gamma P}{\\rho_0 c_0^2} \\right)^{-1/\\gamma} dP = \\int_{H}^{z} -g \\rho_0 dZ\n$$\n右侧积分结果为：\n$$\n\\int_{H}^{z} -g \\rho_0 dZ = -g \\rho_0 [Z]_{H}^{z} = -g \\rho_0(z - H) = g \\rho_0 (H-z)\n$$\n对于左侧的积分，令 $u = 1 + \\frac{\\gamma P}{\\rho_0 c_0^2}$，这意味着 $dP = \\frac{\\rho_0 c_0^2}{\\gamma} du$。$u$ 的积分上下限分别为 $1$（对应 $P=0$）和 $1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}$（对应 $P=p(z)$）。积分变为：\n$$\n\\int_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}} u^{-1/\\gamma} \\left(\\frac{\\rho_0 c_0^2}{\\gamma}\\right) du = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\frac{u^{1 - 1/\\gamma}}{1 - 1/\\gamma} \\right]_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}}\n$$\n$$\n= \\frac{\\rho_0 c_0^2}{\\gamma} \\frac{\\gamma}{\\gamma-1} \\left[ u^{(\\gamma-1)/\\gamma} \\right]_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}} = \\frac{\\rho_0 c_0^2}{\\gamma-1} \\left[ \\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} - 1 \\right]\n$$\n令两边的结果相等，得到：\n$$\n\\frac{\\rho_0 c_0^2}{\\gamma-1} \\left[ \\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} - 1 \\right] = g \\rho_0 (H-z)\n$$\n现在，我们求解 $p_{\\mathrm{eos}}(z)$：\n$$\n\\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} = 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2}\n$$\n$$\n1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2} = \\left( 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2} \\right)^{\\gamma/(\\gamma-1)}\n$$\n$$\np_{\\mathrm{eos}}(z) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\n这就是弱可压缩静水压力的解析表达式。\n\n任务是找到 $\\Delta p_{\\max} = \\max_{0 \\le i  N} \\left| p_{\\mathrm{eos}}(z_i) - p_{\\mathrm{inc}}(z_i) \\right|$。一种暴力方法是在所有 $N$ 个粒子位置上计算这个值。然而，我们可以分析偏差函数 $\\Delta p(z) = p_{\\mathrm{eos}}(z) - p_{\\mathrm{inc}}(z)$ 的行为。让我们将表面以下的深度定义为一个新变量 $X = H-z$。对于 $z \\in [0, H]$，有 $X \\in [0, H]$。压力表达式变为：\n$$\np_{\\mathrm{inc}}(X) = \\rho_0 g X\n$$\n$$\np_{\\mathrm{eos}}(X) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\n在 $X=0$（表面）处，两种压力都为 $0$，因此偏差为 $0$。让我们研究一下偏差对 $X$ 的导数。\n$$\n\\frac{dp_{\\mathrm{inc}}}{dX} = \\rho_0 g\n$$\n$$\n\\frac{dp_{\\mathrm{eos}}}{dX} = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\frac{\\gamma}{\\gamma-1} \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{\\frac{\\gamma}{\\gamma-1}-1} \\cdot \\frac{g(\\gamma-1)}{c_0^2} \\right] = \\rho_0 g \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{1/(\\gamma-1)}\n$$\n考虑到对于表面以下的任何点，$g$、$\\gamma-1$（因为 $\\gamma=7.0$）和 $X$ 均为正值，所以括号中的项大于 $1$。由于指数 $1/(\\gamma-1)$ 也为正，我们有：\n$$\n\\frac{dp_{\\mathrm{eos}}}{dX} > \\rho_0 g = \\frac{dp_{\\mathrm{inc}}}{dX} \\quad \\text{for } X > 0\n$$\n由于 $p_{\\mathrm{eos}}(0) = p_{\\mathrm{inc}}(0) = 0$，并且对于 $X>0$，$p_{\\mathrm{eos}}(X)$ 的斜率始终大于 $p_{\\mathrm{inc}}(X)$ 的斜率，因此函数 $p_{\\mathrm{eos}}(X)$ 始终大于 $p_{\\mathrm{inc}}(X)$，它们的差值 $\\Delta p(X) = p_{\\mathrm{eos}}(X) - p_{\\mathrm{inc}}(X)$ 是深度 $X$ 的单调递增函数。\n因此，最大偏差必定出现在最大深度处，即 $X=H$，对应于水柱底部 $z=0$ 的位置。对于找到最大值而言，离散化是无关紧要的，因为该值保证出现在粒子集合所包含的空间域的端点之一，具体来说是 $z_0=0$。\n计算简化为：\n$$\n\\Delta p_{\\max} = |p_{\\mathrm{eos}}(0) - p_{\\mathrm{inc}}(0)|\n$$\n其中\n$$\np_{\\mathrm{inc}}(0) = \\rho_0 g H\n$$\n$$\np_{\\mathrm{eos}}(0) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)H}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\n这一见解显著简化了数值实现，因为每个测试用例只需要评估一个点。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum absolute pressure deviation between an incompressible\n    and a weakly compressible hydrostatic model for a set of test cases.\n    \"\"\"\n    \n    # Test cases: (rho_0, g, H, c_0, gamma, N)\n    test_cases = [\n        # Case A: Happy path\n        (1000.0, 9.81, 1.0, 50.0, 7.0, 101),\n        # Case B: Shallow column\n        (1000.0, 9.81, 0.1, 50.0, 7.0, 11),\n        # Case C: Soft EOS\n        (1000.0, 9.81, 2.0, 10.0, 7.0, 201),\n        # Case D: Stiff EOS (near-incompressible)\n        (1000.0, 9.81, 2.0, 1000.0, 7.0, 51),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        rho_0, g, H, c_0, gamma, N = case\n        \n        # As derived in the solution, the maximum pressure deviation occurs at the\n        # maximum depth, z=0. We only need to calculate the pressures at this point.\n        z = 0.0\n        \n        # 1. Incompressible pressure at z=0\n        p_inc_at_0 = rho_0 * g * (H - z)\n        \n        # 2. EOS-based pressure at z=0\n        # The term H-z is the depth below the free surface.\n        depth = H - z\n        \n        # The term inside the power function\n        base_term = 1.0 + (g * (gamma - 1.0) * depth) / (c_0**2)\n        \n        # The exponent\n        exponent = gamma / (gamma - 1.0)\n        \n        # Full expression for p_eos at z=0\n        p_eos_at_0 = (rho_0 * c_0**2 / gamma) * (base_term**exponent - 1.0)\n        \n        # 3. Maximum absolute deviation\n        delta_p_max = abs(p_eos_at_0 - p_inc_at_0)\n        \n        # Round to three decimal places and append to results list\n        results.append(f\"{delta_p_max:.3f}\")\n\n    # Format the final output string as per requirements\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何数值方法在求解物理方程时都会引入误差，对于波动问题，这些误差通常表现为色散（不同频率的波以错误的速度传播）和耗散（波的振幅被人为地减弱）。本练习将教你使用傅里叶分析这一强大工具，来量化一个基于粒子的平流格式所产生的数值误差。通过分析该方法如何处理单个傅里叶模式，你将学会计算数值相速度和等效扩散系数，从而对算法的精度进行严格的评估。",
            "id": "2413385",
            "problem": "考虑一个定义在周期性域上的一维线性平流方程，\n$$\\partial_t u(x,t)+c\\,\\partial_x u(x,t)=0,$$\n该方程设定在区间 $[0,L)$ 上，具有周期性边界条件和恒定的平流速度 $c$。假设 $N$ 个拉格朗日粒子初始位于位置 $x_i=i\\,h$（其中 $i\\in\\{0,1,\\dots,N-1\\}\\,(h=L/N)$），每个粒子携带初始条件\n$$u_0(x)=\\cos(k\\,x),\\quad k=\\frac{2\\pi n}{L},$$\n在其位置上的标量值 $u_i^0=u_0(x_i)$，其中 $n$ 是给定的整数模态指数。在一个时间步长 $\\Delta t$ 内，粒子位置通过精确的拉格朗日映射进行更新\n$$x_i'=(x_i+c\\,\\Delta t)\\bmod L,$$\n而它们携带的值保持不变，$u_i'=u_i^0$。为了在这一步之后，在原始粒子位置 $\\{x_j\\}_{j=0}^{N-1}$ 上重新估计场，定义核函数平滑重构\n$$u^{\\mathrm{rec}}(x_j)=\\frac{\\sum_{i=0}^{N-1} u_i'\\,W\\!\\big(d(x_j-x_i')\\big)}{\\sum_{i=0}^{N-1} W\\!\\big(d(x_j-x_i')\\big)},$$\n其中 $W(r)=\\exp\\!\\big(-[r/(\\beta h)]^2\\big)$ 是一个高斯核函数，$\\beta0$ 是无量纲平滑参数，$d(r)$ 是 $r$ 模 $L$ 的等价类在 $(-L/2,L/2]$ 区间内的唯一代表，即\n$$d(r)=r-mL\\quad\\text{with}\\quad m=\\operatorname{round}\\!\\left(\\frac{r}{L}\\right),\\quad d(r)\\in(-L/2,L/2].$$\n对于一个在网格上采样的场 $v(x_j)$，定义其在波数 $k$ 处的离散傅里叶系数为\n$$\\hat{v}(k)=\\frac{1}{N}\\sum_{j=0}^{N-1} v(x_j)\\,e^{-i k x_j}.$$\n设 $\\hat{U}_0=\\hat{u}_0(k)$ 为初始场的系数，$\\hat{U}_1=\\widehat{u^{\\mathrm{rec}}}(k)$ 为一个时间步长后重构场的系数。定义复数比率\n$$R=\\frac{\\hat{U}_1}{\\hat{U}_0}.$$\n使用 $R$，定义数值相速度\n$$c_{\\mathrm{num}}=-\\frac{\\arg(R)}{k\\,\\Delta t},$$\n以及与模态振幅衰减相关的等效扩散系数\n$$D_{\\mathrm{eq}}=-\\frac{1}{k^2\\,\\Delta t}\\,\\ln|R|.$$\n色散误差为 $c_{\\mathrm{num}}-c$。所有量均为无量纲，所有角度均以弧度为单位。对于以下测试套件，请为每种情况计算上述定义的色散误差和等效扩散系数，重构时使用相同的 $W(r)$ 和 $d(r)$。请按指定顺序汇总结果，并生成单行输出，其中包含所有数字，形式为用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 情况A（良好解析，小位移）：$L=1$，$N=200$，$c=1$，$\\beta=0.6$，$n=3$，$\\Delta t=0.2\\,h$。\n- 情况B（近奈奎斯特模态，中等位移）：$L=1$，$N=128$，$c=1$，$\\beta=0.6$，$n=60$，$\\Delta t=0.5\\,h$。\n- 情况C（网格移位位移）：$L=1$，$N=150$，$c=1$，$\\beta=0.6$，$n=10$，$\\Delta t=1.0\\,h$。\n\n您的程序应生成单行输出，其中包含按以下顺序排列的结果，格式为方括号括起来的逗号分隔列表：\n[(c_{\\mathrm{num}}-c)_{\\mathrm{A}}, D_{\\mathrm{eq,A}}, (c_{\\mathrm{num}}-c)_{\\mathrm{B}}, D_{\\mathrm{eq,B}}, (c_{\\mathrm{num}}-c)_{\\mathrm{C}}, D_{\\mathrm{eq,C}}].",
            "solution": "该问题要求计算一种应用于一维线性平流方程的基于拉格朗日粒子的方法的数值误差度量——具体来说是色散误差和等效扩散。对此类数值格式的恰当科学分析，并不涉及蛮力的、按部就班的模拟。相反，它要求对该格式在傅里叶模态上的行为进行更基础的分析，因为控制方程和数值算子的线性特性允许进行分解和叠加。\n\n完整的数值方法包括两个阶段：拉格朗日粒子的精确平流，然后是通过基于核函数的方法将场重构到原始网格上。这个两阶段过程可以看作一个单一的线性算子 $\\mathcal{L}$，它将初始的网格采样场 $u^0 = \\{u_j^0\\}_{j=0}^{N-1}$ 映射到一个时间步长后的重构场 $u^1 = \\{u_j^{\\mathrm{rec}}\\}_{j=0}^{N-1}$。即 $u^1 = \\mathcal{L}(u^0)$。\n\n问题的初始条件为 $u_0(x) = \\cos(kx)$，其中 $k = \\frac{2\\pi n}{L}$。在离散网格 $x_j=j h$ 上，初始条件为 $u_j^0 = \\cos(k x_j)$。使用欧拉恒等式，我们可以将其写为 $u_j^0 = \\frac{1}{2}(e^{i k x_j} + e^{-i k x_j})$。分析的本质在于确定算子 $\\mathcal{L}$ 对单个复傅里叶模态 $v_j = e^{i k x_j}$ 的作用。由于网格的空间均匀性和重构核函数的平移不变性，算子 $\\mathcal{L}$ 是一个相对于空间位置的线性时不变 (LTI) 系统。因此，它对傅里叶模态的作用只是简单地乘以一个复常数，这个常数被称为放大因子或特征值 $R(k)$。\n$$ \\mathcal{L}(\\{e^{i k x_j}\\}) = R(k) \\cdot \\{e^{i k x_j}\\} $$\n问题定义了比率 $R = \\hat{U}_1/\\hat{U}_0$，其中 $\\hat{U}_0$ 和 $\\hat{U}_1$ 分别是初始场和重构场在波数 $k$ 处的离散傅里叶系数。对于初始条件 $u_0(x)=\\cos(kx)$，其离散傅里叶变换 $\\hat{u}_0(k)$ 仅在波数 $\\pm k$ 处非零。可以证明，对于 $n \\in \\{1, \\dots, N/2 - 1\\}$，有 $\\hat{U}_0 = \\hat{u}_0(k) = 1/2$。重构场的傅里叶系数将为 $\\hat{U}_1 = \\hat{u}^{\\mathrm{rec}}(k) = \\frac{1}{2}R(k)$，从而得到比率 $R = R(k)$。因此，我们的任务简化为求解放大因子 $R(k)$。\n\n让我们来推导 $R(k)$ 的表达式。第 $i$ 个粒子携带的值为 $u_i' = u_i^0$。对于一个输入模态 $e^{ikx}$，该值为 $u_i' = e^{ikx_i}$。粒子的新位置是 $x_i' = (x_i + c\\Delta t) \\bmod L$。我们定义 $\\Delta x = c\\Delta t$。\n在网格点 $x_j$ 处的重构场由下式给出\n$$ u^{\\mathrm{rec}}(x_j) = \\frac{\\sum_{i=0}^{N-1} u_i'\\,W(d(x_j-x_i'))}{\\sum_{i=0}^{N-1} W(d(x_j-x_i'))} $$\n分母是相同位移核函数的和。由于平流后的粒子位置集合 $\\{x_i'\\}$ 只是一个平移了 $\\Delta x$ 的均匀网格，这个和与重构点 $x_j$ 无关。我们用 $B$ 表示这个常数分母。\n$$ B = \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) $$\n对于输入 $u_i' = e^{ikx_i}$，分子为\n$$ \\text{Numerator} = \\sum_{i=0}^{N-1} e^{ikx_i} W(d(x_j - (x_i+\\Delta x))) $$\n将 $x_i$ 表示为 $x_i = x_j - (j-i)h$ 并令 $m=j-i \\pmod N$，我们得到：\n$$ \\text{Numerator} = \\sum_{m=0}^{N-1} e^{ik(x_j - mh)} W(d(mh-\\Delta x)) = e^{ikx_j} \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) e^{-ikmh} $$\n令 $G = \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) e^{-ikmh}$。\n重构场为 $u^{\\mathrm{rec}}(x_j) = \\frac{G}{B} e^{ikx_j}$。因此放大因子为 $R(k) = G/B$。\n$$ R = R(k) = \\frac{\\sum_{m=0}^{N-1} W(d(mh-c\\Delta t)) e^{-ikmh}}{\\sum_{m=0}^{N-1} W(d(mh-c\\Delta t))} $$\n这个表达式是精确的，并且允许对 $R$进行直接而高效的计算。\n\n数值相速度 $c_{\\mathrm{num}}$ 和等效扩散 $D_{\\mathrm{eq}}$ 是通过将数值放大因子 $R$ 与解析的平流-扩散方程的放大因子 $e^{(-ikc_{\\mathrm{num}} - k^2 D_{\\mathrm{eq}})\\Delta t}$ 相关联来定义的。将其与 $R = |R|e^{i\\arg(R)}$ 等同，可得：\n$$ c_{\\mathrm{num}} = -\\frac{\\arg(R)}{k\\,\\Delta t} \\quad \\text{and} \\quad D_{\\mathrm{eq}} = -\\frac{\\ln|R|}{k^2\\,\\Delta t} $$\n于是色散误差为 $c_{\\mathrm{num}}-c$。\n\n通过为每个测试案例实现这些公式来获得解答。\n对每种情况，我们确定参数 $L, N, c, \\beta, n, \\Delta t$。根据这些参数，我们计算 $h=L/N$，$k=2\\pi n/L$ 和 $\\Delta x=c\\Delta t$。然后，我们对索引 $m \\in \\{0, 1, ..., N-1\\}$ 计算分子 $G$ 和分母 $B$ 的和。比率 $R=G/B$ 提供了计算色散误差和等效扩散所需的所有信息。所有测试案例的计算都基于这个稳健的分析框架进行。",
            "answer": "```python\n# The final implementation adheres to the specified execution environment.\n# language: Python\n# version: 3.12\n# libraries: numpy==1.23.5, scipy==1.11.4\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating dispersion error and equivalent diffusion\n    for a particle-based advection scheme based on an analytical formula\n    for the amplification factor.\n    \"\"\"\n\n    # Test suite as defined in the problem statement.\n    # Each tuple contains: (L, N, c, beta, n, dt_h), where dt_h is Delta t in units of h.\n    test_cases = [\n        # Case A (well-resolved, small displacement)\n        (1.0, 200, 1.0, 0.6, 3, 0.2),\n        # Case B (near-Nyquist mode, moderate displacement)\n        (1.0, 128, 1.0, 0.6, 60, 0.5),\n        # Case C (grid-shift displacement)\n        (1.0, 150, 1.0, 0.6, 10, 1.0),\n    ]\n\n    results = []\n    \n    # Per the problem, round(r/L) is used for the periodic distance function.\n    # numpy.round rounds to the nearest even integer for halves, a standard\n    # and deterministic choice.\n    def periodic_distance(r, L):\n        \"\"\"\n        Calculates the periodic distance representative in (-L/2, L/2].\n        The problem defines this via d(r) = r - m*L where m = round(r/L).\n        \"\"\"\n        return r - L * np.round(r / L)\n\n    def kernel_W(r, beta, h):\n        \"\"\"\n        Gaussian kernel function W(r) = exp(-[r/(beta*h)]^2).\n        \"\"\"\n        arg = r / (beta * h)\n        return np.exp(-arg**2)\n\n    for case in test_cases:\n        L, N, c, beta, n, dt_h = case\n        \n        # Calculate derived parameters for the case.\n        h = L / N\n        dt = dt_h * h\n        k = 2.0 * np.pi * n / L\n        delta_x = c * dt\n        \n        # Array of indices for the summation, m = 0, 1, ..., N-1.\n        m_vals = np.arange(N)\n        \n        # Calculate the arguments for the periodic distance function.\n        r_vals = m_vals * h - delta_x\n        \n        # Apply the periodic distance function to all arguments.\n        d_vals = periodic_distance(r_vals, L)\n        \n        # Evaluate the kernel function for all periodic distances.\n        W_vals = kernel_W(d_vals, beta, h)\n        \n        # The denominator B is the sum of kernel values.\n        B = np.sum(W_vals)\n        \n        # The numerator G is the discrete Fourier-like sum.\n        exp_vals = np.exp(-1j * k * m_vals * h)\n        G = np.sum(W_vals * exp_vals)\n        \n        # R is the complex amplification factor.\n        # Guard against division by zero, though unlikely with a Gaussian kernel.\n        if B == 0:\n            R = 0.0 + 0.0j\n        else:\n            R = G / B\n        \n        # Calculate numerical phase speed and equivalent diffusion.\n        # These definitions are singular if k=0 or dt=0, but test cases avoid this.\n        if k == 0 or dt == 0:\n            c_num = c\n            D_eq = 0.0\n        else:\n            c_num = -np.angle(R) / (k * dt)\n            \n            # Use a tolerance to avoid taking the log of zero.\n            abs_R = np.abs(R)\n            if abs_R > 1e-16:\n                D_eq = -np.log(abs_R) / (k**2 * dt)\n            else:\n                D_eq = np.inf\n        \n        # The dispersion error is the difference between numerical and exact phase speeds.\n        dispersion_error = c_num - c\n        \n        results.append(dispersion_error)\n        results.append(D_eq)\n\n    # Print the final results in the specified single-line format.\n    # Using scientific notation for consistent formatting and precision.\n    print(f\"[{','.join(f'{val:.10e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "由于每个粒子可能与大量其他粒子发生相互作用，粒子法的计算成本可能非常高昂。邻居列表是一种关键的优化技术，它将相互作用的计算限制在邻近的粒子之间。本练习将带你深入探索SPH模拟中的一个核心权衡：计算效率与模拟精度。你将通过改变邻居列表的更新频率，亲手量化计算成本的节省以及由此引入的模拟误差，从而直观地理解算法优化中的现实挑战。",
            "id": "2413353",
            "problem": "考虑一个一维系综，包含 $M$ 个相同的拉格朗日粒子，它们分布在长度为 $L$ 的周期性区域上，每个粒子都带有相等的质量 $m$。设初始位置均匀分布为 $x_i^0 = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = L/M$，对于 $i=0,1,\\dots,M-1$。粒子轨迹由以下随时间变化的映射给出：\n$$\nx_i(t) = \\left[x_i^0 + A \\sin\\!\\left(\\tfrac{2\\pi}{L} x_i^0\\right)\\sin(\\omega t)\\right] \\bmod L,\n$$\n因此所有量都是无量纲的。两两之间的距离在 $[0,L)$ 上使用最小镜像约定：\n$$\nd(x,y) = \\min\\!\\left(|x-y|,\\, L - |x-y|\\right).\n$$\n将粒子 $i$ 在时间 $t$ 的平滑粒子流体动力学（SPH）密度估计定义为：\n$$\n\\rho_i(t) = \\sum_{j=0}^{M-1} m \\, W\\!\\left(d\\!\\left(x_i(t),x_j(t)\\right), h\\right),\n$$\n其中，平滑长度为 $h$ 的一维三次样条核函数 $W$ 为：\n$$\nW(r,h) = \\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1, \\\\\n\\dfrac{1}{h}\\left(\\dfrac{1}{6}(2 - q)^3\\right),  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n\\quad \\text{其中 } q = \\dfrac{r}{h}.\n$$\n考虑离散时间 $t_s = s\\,\\Delta t$，对于 $s=0,1,\\dots,S-1$。在时间步 $s$ 的邻居列表是对于每个粒子 $i$，满足 $d\\!\\left(x_i(t_s),x_j(t_s)\\right)  2h$ 的索引 $j$ 的集合。假设邻居列表仅每 $N$ 步重新计算一次：在满足 $s \\equiv 0 \\pmod N$ 的时间步 $s$，构建邻居列表；在其他时间步，重复使用最近构建的邻居列表来评估 $\\rho_i(t_s)$，而粒子位置 $x_i(t_s)$ 继续按照给定的轨迹演化。在计算 $\\rho_i(t_s)$ 时，必须始终包含自身贡献项（$j=i$）。\n\n将给定步长 $N$ 的精度度量定义为相对于参考情况 $N=1$ 的所有粒子和所有时间的均方根（RMS）密度误差：\n$$\nE_N = \\left(\\frac{1}{MS}\\sum_{s=0}^{S-1}\\sum_{i=0}^{M-1}\\left[\\rho_i^{(N)}(t_s)-\\rho_i^{(1)}(t_s)\\right]^2\\right)^{1/2}.\n$$\n将中央处理器（CPU）时间的代理定义为在整个模拟过程中，对于步长 $N$，成对绝对距离评估的总次数 $C_N$，其中：\n- 在每个邻居列表重建步骤中，所有无序对 $\\{i,j\\}$（其中 $i \\ne j$）被检查一次（每次重建计为 $\\tfrac{M(M-1)}{2}$ 次绝对距离计算）。\n- 在每个时间步，使用当前邻居列表评估密度总和时，每次在求和中使用的邻居对（不包括自身贡献）计为一次绝对距离计算。\n\n所有量都是无量纲的。使用以下固定参数：\n- $L = 1$, $M = 64$, $\\Delta x = L/M$, $m = 1/M$,\n- $h = 0.98\\,\\Delta x$,\n- $A = 0.25\\,\\Delta x$,\n- $\\omega = 2\\pi$,\n- $\\Delta t = 0.01$, $S = 200$.\n\n测试组（要评估的邻居列表步长值 $N$）：\n- 情况 1：$N = 1$,\n- 情况 2：$N = 2$,\n- 情况 3：$N = 5$,\n- 情况 4：$N = 200$.\n\n对于每种情况，计算数对 $[E_N, C_N]$，其中 $E_N$ 是一个四舍五入到六位小数的浮点数，$C_N$ 是一个整数。你的程序应该生成单行输出，其中包含结果，格式为这些数对的逗号分隔列表，并用方括号括起来，顺序与测试组一致。例如：\n\"[[E_1,C_1],[E_2,C_2],[E_3,C_3],[E_4,C_4]]\"",
            "solution": "该问题是有效的。它提出了一个在平滑粒子流体动力学（SPH）领域中定义明确的计算实验，SPH是一种用于计算工程和物理学的无网格方法。该问题具有科学依据，数学上一致，并且所有参数和过程都得到了明确的规定。其目标是分析在使用一种常见的优化技术——不频繁更新邻居列表时，计算成本与精度之间的权衡。\n\n解决方案是通过执行所述的直接数值模拟获得的。问题的核心是为一个具有给定轨迹的一维粒子系统实现SPH形式体系。算法的主要步骤如下：\n\n1.  **系统初始化**：所有物理和数值参数都按规定定义：区域长度 $L$、粒子数 $M$、粒子质量 $m$、平滑长度 $h$、轨迹振幅 $A$ 和频率 $\\omega$，以及时间步长参数 $\\Delta t$ 和 $S$。$M$ 个粒子的初始位置 $x_i^0$ 被设定为在周期性区域 $[0, L)$ 上均匀分布。\n\n2.  **核心函数的实现**：需要三个关键函数：\n    *   **粒子轨迹 $x_i(t)$**：一个根据指定映射计算任意粒子 $i$ 在任意给定时间 $t$ 的位置的函数：\n        $$x_i(t) = \\left[x_i^0 + A \\sin\\!\\left(\\tfrac{2\\pi}{L} x_i^0\\right)\\sin(\\omega t)\\right] \\bmod L$$\n    *   **周期性距离 $d(x,y)$**：一个使用最小镜像约定计算周期性区域上两点之间成对距离的函数：\n        $$d(x,y) = \\min\\!\\left(|x-y|,\\, L - |x-y|\\right)$$\n    *   **SPH 核函数 $W(r,h)$**：一个实现一维三次样条核的函数。其值取决于归一化距离 $q = r/h$：\n        $$W(r,h) = \\begin{cases} \\frac{1}{h}(\\frac{2}{3} - q^2 + \\frac{1}{2}q^3)  0 \\le q  1 \\\\ \\frac{1}{h}(\\frac{1}{6}(2-q)^3)  1 \\le q  2 \\\\ 0  q \\ge 2 \\end{cases}$$\n\n3.  **不同步长 $N$ 的模拟**：算法的主要部分是一个循环，遍历邻居列表更新步长 $N \\in \\{1, 2, 5, 200\\}$ 的指定测试用例。对每个 $N$，执行一个包含 $S$ 个时间步的完整模拟。\n\n4.  **时间步进循环**：对于给定的 $N$，模拟在离散时间步 $t_s = s\\Delta t$ 上进行，其中 $s=0, 1, \\dots, S-1$。在每个时间步 $s$：\n    *   所有粒子的位置 $x_i(t_s)$ 被更新。\n    *   通过检查 `if s % N == 0` 来确定是否应重建邻居列表。\n    *   **邻居列表重建**：如果需要重建，则检查所有唯一的无序粒子对 $\\{i,j\\}$。计算每对粒子间的距离 $d(x_i(t_s), x_j(t_s))$。如果此距离小于核函数支持域截断半径 $2h$，则将这些粒子添加到彼此的邻居列表中。对于此 N 体检查，计算成本代理 $C_N$ 增加 $\\frac{M(M-1)}{2}$。\n    *   **密度计算**：使用当前的邻居列表（如果未发生重建，则可能来自前一个步骤），计算每个粒子的密度 $\\rho_i^{(N)}(t_s)$。公式为：\n        $$\\rho_i^{(N)}(t_s) = m W(0, h) + \\sum_{j \\in \\text{neighbors}(i)} m W(d(x_i(t_s), x_j(t_s)), h)$$\n        始终包含自身贡献项 $m W(0,h)$。注意，即使邻居列表本身是“过时的”，也必须在当前时间 $t_s$ 重新评估距离 $d(x_i(t_s), x_j(t_s))$。\n    *   **成本累积**：成本 $C_N$ 会进一步增加，增加的量为密度求和所需的成对距离计算次数。根据问题陈述，这是该时间步使用的所有邻居列表中的条目总数，代表了在求和中评估的有序对 $(i,j)$ 的数量。\n\n5.  **误差计算**：\n    *   $N=1$ 的模拟作为高保真度参考。其密度历史 $\\rho_i^{(1)}(t_s)$ 被存储。根据定义，其误差为 $E_1=0$。\n    *   对于每个后续的 $N  1$ 的模拟，将得到的密度历史 $\\rho_i^{(N)}(t_s)$ 与参考进行比较。使用提供的公式计算均方根误差 $E_N$：\n        $$E_N = \\left(\\frac{1}{MS}\\sum_{s=0}^{S-1}\\sum_{i=0}^{M-1}\\left[\\rho_i^{(N)}(t_s)-\\rho_i^{(1)}(t_s)\\right]^2\\right)^{1/2}$$\n\n6.  **最终输出**：对于每个 $N$，存储计算出的数对 $[E_N, C_N]$，其中 $E_N$ 四舍五入到六位小数。将这些数对的最终集合格式化为指定的字符串格式。\n\n整个过程使用 Python 实现，并利用 `NumPy` 库对粒子数组进行高效的矢量化操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH neighbor list accuracy vs. cost problem.\n    \"\"\"\n    # Define fixed parameters\n    L = 1.0\n    M = 64\n    dx = L / M\n    m = 1.0 / M\n    h = 0.98 * dx\n    A = 0.25 * dx\n    omega = 2.0 * np.pi\n    dt = 0.01\n    S = 200\n\n    # Test cases for neighbor-list stride N\n    test_cases = [1, 2, 5, 200]\n\n    # --- Helper Functions ---\n    def min_image_dist(p1, p2, domain_length):\n        \"\"\"\n        Calculates the minimum image distance in a periodic domain.\n        Can handle p1 being a scalar and p2 being a numpy array.\n        \"\"\"\n        delta = np.abs(p1 - p2)\n        return np.minimum(delta, domain_length - delta)\n\n    def kernel_W(r, h_val):\n        \"\"\"\n        Computes the 1D cubic spline kernel value.\n        Handles both scalar and numpy array inputs for r.\n        \"\"\"\n        was_scalar = np.isscalar(r)\n        r = np.atleast_1d(r)\n        \n        q = r / h_val\n        \n        # Branch for 0 = q  1\n        term1 = (1/h_val) * (2/3 - q**2 + 0.5 * q**3)\n        # Branch for 1 = q  2\n        term2 = (1/h_val) * (1/6) * (2 - q)**3\n        \n        w = np.where(q  1, term1, np.where(q  2, term2, 0.0))\n        \n        return w.item() if was_scalar else w\n\n    # --- Simulation Logic ---\n\n    # Initial particle positions\n    x0 = (np.arange(M) + 0.5) * dx\n\n    final_results = []\n    rho_ref_history = None\n    \n    # Pre-calculate self-contribution term for density\n    self_contrib_rho = m * kernel_W(0.0, h)\n\n    for N in test_cases:\n        cost_N = 0\n        rho_N_history = np.zeros((S, M))\n        neighbor_lists = [[] for _ in range(M)]\n\n        for s in range(S):\n            t = s * dt\n            \n            # Calculate current particle positions\n            positions = (x0 + A * np.sin(2 * np.pi / L * x0) * np.sin(omega * t)) % L\n\n            # Rebuild neighbor list if s is a multiple of N\n            if s % N == 0:\n                cost_N += M * (M - 1) // 2\n                neighbor_lists = [[] for _ in range(M)]\n                for i in range(M):\n                    for j in range(i + 1, M):\n                        dist = min_image_dist(positions[i], positions[j], L)\n                        if dist  2 * h:\n                            neighbor_lists[i].append(j)\n                            neighbor_lists[j].append(i)\n\n            # Calculate SPH density for each particle\n            current_densities = np.full(M, self_contrib_rho)\n            density_eval_cost = 0\n            for i in range(M):\n                if not neighbor_lists[i]:\n                    continue\n                \n                # Vectorized calculation for all neighbors of particle i\n                neighbor_indices = np.array(neighbor_lists[i])\n                neighbor_pos = positions[neighbor_indices]\n                \n                distances = min_image_dist(positions[i], neighbor_pos, L)\n                kernel_values = kernel_W(distances, h)\n                \n                current_densities[i] += m * np.sum(kernel_values)\n                density_eval_cost += len(neighbor_indices)\n\n            cost_N += density_eval_cost\n            rho_N_history[s, :] = current_densities\n\n        # Post-simulation processing for this N\n        if N == 1:\n            rho_ref_history = rho_N_history\n            E_N = 0.0\n        else:\n            # Calculate RMS error relative to N=1 case\n            diff_sq = (rho_N_history - rho_ref_history)**2\n            mean_sq_err = np.mean(diff_sq)\n            E_N = np.sqrt(mean_sq_err)\n\n        final_results.append([round(E_N, 6), int(cost_N)])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'[{e},{c}]' for e, c in final_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}