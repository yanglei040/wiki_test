{
    "hands_on_practices": [
        {
            "introduction": "切割单元法 (cut-cell method) 以其处理复杂几何的灵活性而著称，但这种灵活性也带来了挑战。通过对一个简化的平流问题进行理论分析 ，你将亲自推导一个基本的一阶迎风格式在切割单元处的截断误差。这个练习将揭示简单切割单元格式的一个基本缺陷——不一致性 (inconsistency)，并让你深刻理解为何在实际应用中需要更复杂的数值方法来保证计算的准确性。",
            "id": "2401460",
            "problem": "考虑守恒形式的一维线性平流偏微分方程 (PDE)，$u_{t} + (au)_{x} = 0$，其中平流速度 $a  0$ 为常数。设空间网格主要由尺寸为 $h$ 的均匀网格单元构成，但在一个长度为 $h$ 的常规网格单元的右侧，存在一个长度为 $\\alpha h$（其中 $\\alpha \\in (0,1)$）的单个切割网格单元。将常规网格单元和切割网格单元之间的共享界面（面）记为 $x_{f}$。设 $\\bar{u}_{L}(t)$ 为紧邻 $x_{f}$ 左侧的常规网格单元（长度为 $h$）上 $u(x,t)$ 的精确单元平均值，设 $\\bar{u}_{C}(t)$ 为 $x_{f}$ 右侧的切割网格单元（长度为 $\\alpha h$）上的精确单元平均值。考虑标准的一阶迎风有限体积半离散化（采用 Godunov 通量和等于单元平均值的分段常数重构）：\n$$\n\\frac{d \\bar{u}_{C}}{d t} = -\\frac{a}{\\alpha h}\\left(\\bar{u}_{C} - \\bar{u}_{L}\\right),\n$$\n该方法在界面 $x_{f}$ 处使用数值通量 $F_{f} = a \\bar{u}_{L}$，在切割网格单元的右界面处使用 $F_{C+1/2} = a \\bar{u}_{C}$。\n\n将切割网格单元处的局部空间截断误差定义为将精确解代入离散算子，再减去精确的有限体积平衡方程后得到的残差，即\n$$\n\\tau_{C} = \\left[-\\frac{a}{\\alpha h}\\left(u(x_{f}+\\alpha h,t) - u(x_{f},t)\\right)\\right] - \\left[-\\frac{a}{\\alpha h}\\left(\\bar{u}_{C}(t) - \\bar{u}_{L}(t)\\right)\\right].\n$$\n请从第一性原理出发，利用泰勒级数和单元平均值的定义，推导当 $h \\to 0$ 时 $\\tau_{C}$ 的主阶项，并用 $a$、$\\alpha$ 以及在界面位置 $x_{f}$ 处求值的 $u$ 的空间导数来表示。将最终答案表示为关于主阶截断误差项的单个闭式解析表达式（省略大$\\mathcal{O}$符号），仅用 $a$、$\\alpha$ 和 $u_{x}(x_{f},t)$ 表示。不需要进行数值近似。答案必须是无单位的单一解析表达式。",
            "solution": "本题要求推导一阶迎风有限体积格式在含切割网格单元的网格上求解一维线性平流方程 $u_t + a u_x = 0$ 时，局部空间截断误差 $\\tau_C$ 的主阶项。\n\n首先，我们建立必要的定义和关系。切割网格单元 $[x_f, x_f + \\alpha h]$ 上的单元平均值 $\\bar{u}_C(t)$ 的精确时间演化可通过在该单元上对 PDE $u_t = -a u_x$ 进行积分得到：\n$$\n\\int_{x_f}^{x_f + \\alpha h} u_t(x,t) \\,dx = -a \\int_{x_f}^{x_f + \\alpha h} u_x(x,t) \\,dx\n$$\n使用定义 $\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f + \\alpha h} u(x,t) \\,dx$ 和微积分基本定理，我们得到：\n$$\n\\frac{d}{dt} (\\alpha h \\bar{u}_C(t)) = -a \\left[ u(x_f + \\alpha h, t) - u(x_f, t) \\right]\n$$\n这给出了 $\\bar{u}_C(t)$ 演化方程的精确空间算子部分：\n$$\n\\left(\\frac{d\\bar{u}_C}{dt}\\right)_{\\text{exact}} = -\\frac{a}{\\alpha h} \\left[ u(x_f + \\alpha h, t) - u(x_f, t) \\right]\n$$\n题目给出了数值格式所用的半离散化：\n$$\n\\left(\\frac{d\\bar{u}_C}{dt}\\right)_{\\text{numerical}} = -\\frac{a}{\\alpha h} \\left( \\bar{u}_C(t) - \\bar{u}_L(t) \\right)\n$$\n局部空间截断误差 $\\tau_C$ 在题目中被定义为精确空间算子与数值空间算子之差，两者均使用精确解 $u(x,t)$ 进行求值。注意，题目的定义是 $\\tau_C = (\\text{精确}) - (\\text{数值})$，这与某些惯例的定义符号相反。我们严格遵循题目的定义：\n$$\n\\tau_C = \\left[-\\frac{a}{\\alpha h}\\left(u(x_{f}+\\alpha h,t) - u(x_{f},t)\\right)\\right] - \\left[-\\frac{a}{\\alpha h}\\left(\\bar{u}_{C}(t) - \\bar{u}_{L}(t)\\right)\\right]\n$$\n这可以简化为：\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ \\left( \\bar{u}_C(t) - \\bar{u}_L(t) \\right) - \\left( u(x_f + \\alpha h, t) - u(x_f, t) \\right) \\right]\n$$\n为了求出当 $h \\to 0$ 时 $\\tau_C$ 的主阶项，我们对解 $u(x,t)$ 在界面位置 $x=x_f$ 附近进行泰勒级数展开，并保持时间 $t$ 不变。设 $u_f = u(x_f, t)$，$u_{x,f} = u_x(x_f, t)$ 等等。展开式为：\n$$\nu(x,t) = u_f + (x-x_f) u_{x,f} + \\frac{(x-x_f)^2}{2} u_{xx,f} + \\mathcal{O}((x-x_f)^3)\n$$\n现在我们展开 $\\tau_C$ 表达式中的各项。首先，我们展开精确的单元平均值 $\\bar{u}_L(t)$ 和 $\\bar{u}_C(t)$。\n左侧常规网格单元 $[x_f-h, x_f]$ 上的单元平均值为：\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\int_{x_f-h}^{x_f} u(x,t) \\,dx = \\frac{1}{h} \\int_{x_f-h}^{x_f} \\left( u_f + (x-x_f) u_{x,f} + \\frac{(x-x_f)^2}{2} u_{xx,f} + \\dots \\right) dx\n$$\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\left[ (x-x_f) u_f + \\frac{(x-x_f)^2}{2} u_{x,f} + \\frac{(x-x_f)^3}{6} u_{xx,f} + \\dots \\right]_{x_f-h}^{x_f}\n$$\n$$\n\\bar{u}_L(t) = \\frac{1}{h} \\left[ (0 - (-h))u_f + \\left(0 - \\frac{(-h)^2}{2}\\right)u_{x,f} + \\dots \\right] = u_f - \\frac{h}{2} u_{x,f} + \\mathcal{O}(h^2)\n$$\n切割网格单元 $[x_f, x_f+\\alpha h]$ 上的单元平均值为：\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f+\\alpha h} u(x,t) \\,dx = \\frac{1}{\\alpha h} \\int_{x_f}^{x_f+\\alpha h} \\left( u_f + (x-x_f) u_{x,f} + \\dots \\right) dx\n$$\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\left[ (x-x_f) u_f + \\frac{(x-x_f)^2}{2} u_{x,f} + \\dots \\right]_{x_f}^{x_f+\\alpha h}\n$$\n$$\n\\bar{u}_C(t) = \\frac{1}{\\alpha h} \\left[ (\\alpha h) u_f + \\frac{(\\alpha h)^2}{2} u_{x,f} + \\dots \\right] = u_f + \\frac{\\alpha h}{2} u_{x,f} + \\mathcal{O}(h^2)\n$$\n单元平均值之差为：\n$$\n\\bar{u}_C(t) - \\bar{u}_L(t) = \\left( u_f + \\frac{\\alpha h}{2} u_{x,f} \\right) - \\left( u_f - \\frac{h}{2} u_{x,f} \\right) + \\mathcal{O}(h^2) = \\frac{h}{2}(1+\\alpha) u_{x,f} + \\mathcal{O}(h^2)\n$$\n接下来，我们展开包含精确解点值的项：\n$$\nu(x_f+\\alpha h, t) - u(x_f, t) = \\left( u_f + (\\alpha h) u_{x,f} + \\mathcal{O}(h^2) \\right) - u_f = \\alpha h \\, u_{x,f} + \\mathcal{O}(h^2)\n$$\n现在，将这些展开式代入 $\\tau_C$ 的公式：\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ \\left( \\frac{h}{2}(1+\\alpha) u_{x,f} + \\mathcal{O}(h^2) \\right) - \\left( \\alpha h \\, u_{x,f} + \\mathcal{O}(h^2) \\right) \\right]\n$$\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ h u_{x,f} \\left( \\frac{1+\\alpha}{2} - \\alpha \\right) + \\mathcal{O}(h^2) \\right]\n$$\n简化 $h u_{x,f}$ 项的系数：\n$$\n\\frac{1+\\alpha}{2} - \\alpha = \\frac{1+\\alpha-2\\alpha}{2} = \\frac{1-\\alpha}{2}\n$$\n因此，$\\tau_C$ 的表达式变为：\n$$\n\\tau_C = \\frac{a}{\\alpha h} \\left[ h \\frac{1-\\alpha}{2} u_{x,f} + \\mathcal{O}(h^2) \\right] = a \\frac{1-\\alpha}{2\\alpha} u_{x,f} + \\mathcal{O}(h)\n$$\n当 $h \\to 0$ 时，截断误差的主阶项是不随 $h$ 消失的项。由于 $\\alpha \\in (0,1)$，$\\alpha \\neq 1$，该主阶项通常非零。它是 $\\mathcal{O}(h^0)$ 阶的，即相对于 $h$ 是一个常数。\n这表明该格式在切割网格单元处是不相容的（零阶精度），这是标准一阶 Godunov 方法简单地应用于非均匀网格时的一个已知缺陷。\n\n因此，主阶项为：\n$$\na \\frac{1-\\alpha}{2\\alpha} u_{x}(x_{f},t)\n$$",
            "answer": "$$\n\\boxed{a \\frac{1-\\alpha}{2\\alpha} u_{x}(x_{f},t)}\n$$"
        },
        {
            "introduction": "除了精度问题，稳定性是切割单元法面临的另一个严峻挑战，尤其是对于显式时间推进格式。极小的切割单元会导致整个计算域的时间步长受到极其严格的限制，从而严重影响计算效率。这个练习  让你亲手设计并实现一种局部时间步进 (local time-stepping) 方案，通过为不同大小的单元分配不同的时间步长，来克服“小单元问题”带来的稳定性瓶颈。这项实践将向你展示如何巧妙地平衡稳定性和计算成本，是现代计算流体动力学软件中的一项关键优化技术。",
            "id": "2401456",
            "problem": "考虑一维线性平流方程 $\\partial_t q + a\\,\\partial_x q = 0$，其定义在一个周期性区间上，并使用标称单元宽度为 $h$ 的均匀笛卡尔网格进行离散。一个浸入边界切割了部分单元，因此对于单元 $j$，只有其标称体积的一部分，即比例为 $\\alpha_j \\in (0,1]$ 的部分，包含流体。在一维空间中，被切割单元的有效流体长度为 $h_j = \\alpha_j h$。假设对每个单元应用守恒显式有限体积更新，并令 $\\nu \\in (0,1]$ 表示一个指定的 Courant 数。对于未切割的单元，其基础时间步长由均匀单元稳定性限制定义为 $\\Delta t_{\\text{base}} = \\nu h / |a|$。通过为每个单元分配一个整数子循环因子 $r_j \\in \\{1,2,4,8,\\dots\\}$（2的幂），引入了局部时间步进，因此单元的时间步长为 $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$。稳定性要求每个单元都满足 Courant–Friedrichs–Lewy 不等式 $|a|\\,\\Delta t_j / h_j \\le \\nu$。设 $T_{\\text{end}}$ 为最终时间，使得 $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ 是一个整数，这样每个未切割的单元都精确执行 $N_{\\text{base}}$ 个基础步长。\n\n您的任务是为下面列出的每个测试用例，确定一组子循环因子 $r_j$ 的选择，该选择需满足稳定性不等式和2的幂约束，最小化在 $[0,T_{\\text{end}}]$ 上的单元更新总数，并量化局部时间步进相对于统一小步长方案的效率。在这里，一个单元更新指将该单元推进其局部时间步长一次。对于统一小步长方案，所有单元都以 $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$ 推进，其中 $R_{\\max} = \\max_j r_j$。\n\n对于每个测试用例，计算并报告：\n- 子循环因子列表 $[r_1,\\dots,r_M]$（整数）。\n- 局部方案执行的更新总数 $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$（整数）。\n- 统一小步长方案执行的更新总数 $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$（整数）。\n- 效率增益 $G = N_{\\text{uniform}}/N_{\\text{local}}$，四舍五入到六位小数（浮点数）。\n- 一个布尔值，指示在您选择的 $r_j$ 下，稳定性不等式 $|a|\\,\\Delta t_j / h_j \\le \\nu$ 对所有单元是否成立（布尔值）。\n\n使用以下测试套件。所有长度单位必须是米（$\\mathrm{m}$），速度单位是米/秒（$\\mathrm{m/s}$），时间单位是秒（$\\mathrm{s}$）。\n- 测试用例 A（正常路径）：$h = 1.0\\,\\mathrm{m}$，$a = 1.0\\,\\mathrm{m/s}$，$\\nu = 0.5$，$T_{\\text{end}} = 1.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$。\n- 测试用例 B（全为未切割）：$h = 0.5\\,\\mathrm{m}$，$a = 2.0\\,\\mathrm{m/s}$，$\\nu = 0.5$，$T_{\\text{end}} = 1.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,1.0,\\,1.0\\,]$。\n- 测试用例 C（极端切割）：$h = 1.0\\,\\mathrm{m}$，$a = 2.0\\,\\mathrm{m/s}$，$\\nu = 0.4$，$T_{\\text{end}} = 1.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,0.2,\\,0.03\\,]$。\n- 测试用例 D（边界相等）：$h = 2.0\\,\\mathrm{m}$，$a = 1.0\\,\\mathrm{m/s}$，$\\nu = 1.0$，$T_{\\text{end}} = 4.0\\,\\mathrm{s}$，$\\boldsymbol{\\alpha} = [\\,1.0,\\,0.5,\\,0.25,\\,0.125\\,]$。\n\n您的程序必须生成单行输出，其中包含按相同顺序排列的测试用例结果，并汇总到一个外部列表中。每个测试用例的结果本身必须是一个列表，其结构为 [r_list, N_local, N_uniform, G, stable_flag]。该单行必须是包含在方括号中的逗号分隔列表，例如：“[[...],[...],[...],[...]]”。",
            "solution": "所述问题将首先经过严格的验证过程。\n\n**步骤1：提取的已知条件**\n\n基本物理模型是一维线性平流方程：$\\partial_t q + a\\,\\partial_x q = 0$。\n问题在具有单元宽度 $h$ 的均匀笛卡尔网格上离散化。\n浸入边界导致了切割单元，其中单元 $j$ 的流体体积分数为 $\\alpha_j \\in (0,1]$，有效长度为 $h_j = \\alpha_j h$。\n使用守恒显式有限体积更新。\n指定的 Courant 数为 $\\nu \\in (0,1]$。\n未切割单元（其中 $\\alpha_j=1$）的时间步长为 $\\Delta t_{\\text{base}} = \\nu h / |a|$。\n采用局部时间步进，每个单元 $j$ 具有一个子循环因子 $r_j$ 和一个局部时间步长 $\\Delta t_j = \\Delta t_{\\text{base}}/r_j$。\n子循环因子被限制为2的幂：$r_j \\in \\{1, 2, 4, \\dots\\}$。\n每个单元的 Courant–Friedrichs–Lewy (CFL) 稳定性条件为 $|a|\\,\\Delta t_j / h_j \\le \\nu$。\n模拟运行至最终时间 $T_{\\text{end}}$。量 $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}}$ 被指定为整数。\n目标是选择子循环因子集合 $\\{r_j\\}$ 以最小化单元更新的总数，$N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$。\n定义了一个参考的统一小步长方案，其时间步长为 $\\Delta t_{\\text{uniform}} = \\Delta t_{\\text{base}} / R_{\\max}$，其中 $R_{\\max} = \\max_j r_j$。此方案的更新总数为 $N_{\\text{uniform}} = N_{\\text{base}}\\,M\\,R_{\\max}$。\n效率增益定义为 $G = N_{\\text{uniform}}/N_{\\text{local}}$。\n每个测试用例所需的输出是：因子列表 $[r_1,\\dots,r_M]$，总更新数 $N_{\\text{local}}$ 和 $N_{\\text{uniform}}$，增益 $G$，以及一个布尔稳定性标志。\n测试用例为 $h$、$a$、$\\nu$、$T_{\\text{end}}$ 和向量 $\\boldsymbol{\\alpha}$ 提供了具体值。\n\n**步骤2：问题陈述的验证**\n\n该问题具有科学依据，它基于标准的平流方程和成熟的有限体积法，并结合局部时间步进以处理浸入边界情境中的小单元问题。CFL 条件是显式数值方法的基本原理。该问题是适定的，提出了一个具有明确目标函数（最小化 $N_{\\text{local}}$）和对变量 ($r_j$) 有明确约束的约束优化问题。语言客观且数学上精确。设置是自洽的，没有矛盾。所提供的数据在量纲上是一致的，并且在物理上是合理的。该问题不违反任何指定的无效标准。\n\n**步骤3：结论与行动**\n\n该问题被认为是有效的。将制定一个解决方案。\n\n**最优子循环因子的推导**\n\n目标是最小化在模拟时间 $[0, T_{\\text{end}}]$ 内的单元更新总数，由下列表达式给出：\n$$\nN_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j\n$$\n由于对于任何给定的测试用例，$N_{\\text{base}}$ 是一个正常数，因此最小化 $N_{\\text{local}}$ 等价于最小化子循环因子的总和 $\\sum_{j=1}^M r_j$。由于每个 $r_j$ 的选择与其他 $r_j$ 无关，因此通过为每个单元 $j$ 选择最小的有效 $r_j$ 来最小化总和。\n\n每个 $r_j$ 的约束条件是：\n1. $r_j$ 必须是2的幂，即对于某个非负整数 $k$，$r_j = 2^k$。\n2. $r_j$ 必须满足局部 CFL 稳定性不等式：$|a|\\,\\Delta t_j / h_j \\le \\nu$。\n\n我们通过代入 $\\Delta t_j$ 和 $h_j$ 的定义来分析稳定性不等式：\n$$\n\\frac{|a|}{h_j} \\Delta t_j = \\frac{|a|}{\\alpha_j h} \\left( \\frac{\\Delta t_{\\text{base}}}{r_j} \\right) \\le \\nu\n$$\n现在，代入 $\\Delta t_{\\text{base}} = \\nu h / |a|$ 的定义：\n$$\n\\frac{|a|}{\\alpha_j h} \\left( \\frac{1}{r_j} \\frac{\\nu h}{|a|} \\right) \\le \\nu\n$$\n假设 $a \\ne 0$ 和 $h, \\nu  0$，我们可以简化表达式：\n$$\n\\frac{1}{\\alpha_j r_j} \\le 1\n$$\n由于 $\\alpha_j  0$ 并且 $r_j$ 必须为正，这等价于：\n$$\nr_j \\ge \\frac{1}{\\alpha_j}\n$$\n将此与2的幂约束相结合，单元 $j$ 的最优子循环因子 $r_j$ 是大于或等于 $1/\\alpha_j$ 的最小2的整数次幂。\n\n这可以形式化地表示。设最小要求值为 $s_j = 1/\\alpha_j$。我们寻找满足 $2^k \\ge s_j$ 的最小非负整数 $k$。取以2为底的对数，我们发现 $k \\ge \\log_2(s_j)$。由于 $k$ 必须是整数，因此最小的 $k$ 是 $\\lceil \\log_2(s_j) \\rceil$。因此，单元 $j$ 的最优子循环因子是：\n$$\nr_j = 2^{\\lceil \\log_2(1/\\alpha_j) \\rceil}\n$$\n对于未切割的单元，$\\alpha_j=1$，这给出 $1/\\alpha_j=1$。由于 $\\log_2(1)=0$，我们有 $\\lceil 0 \\rceil = 0$ 和 $r_j = 2^0 = 1$，这是正确的。这对应于一个单元采用基础时间步长 $\\Delta t_{\\text{base}}$。对于被切割的单元，$\\alpha_j  1$，这要求 $r_j > 1$。\n\n**性能指标计算与稳定性检查**\n\n一旦为给定的测试用例确定了最优因子列表 $\\boldsymbol{r} = [r_1, \\dots, r_M]$，剩余的量按如下方式计算：\n1. 最大子循环因子为 $R_{\\max} = \\max_j r_j$。\n2. 基础步数为 $N_{\\text{base}} = T_{\\text{end}} / \\Delta t_{\\text{base}} = T_{\\text{end}} / (\\nu h / |a|)$。\n3. 局部时间步进方案的更新总数为 $N_{\\text{local}} = N_{\\text{base}} \\sum_{j=1}^M r_j$。\n4. 统一小步长方案的更新总数为 $N_{\\text{uniform}} = N_{\\text{base}} M R_{\\max}$。\n5. 效率增益为 $G = N_{\\text{uniform}} / N_{\\text{local}}$。\n6. 布尔稳定性标志通过检查所有单元 $j=1,\\dots,M$ 的 CFL 条件 $|a|\\,\\Delta t_j / h_j \\le \\nu$ 来确定。根据我们的构造，$r_j \\ge 1/\\alpha_j$，这等价于 CFL 条件得到满足。因此，此标志将始终为真。\n\n该算法应用于每个测试用例以生成所需的结果。最终实现将执行这些计算并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the local time stepping optimization problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A: h, a, nu, T_end, alpha_list\n        (1.0, 1.0, 0.5, 1.0, [1.0, 0.5, 0.25, 0.125]),\n        # Test Case B\n        (0.5, 2.0, 0.5, 1.0, [1.0, 1.0, 1.0]),\n        # Test Case C\n        (1.0, 2.0, 0.4, 1.0, [1.0, 0.2, 0.03]),\n        # Test Case D\n        (2.0, 1.0, 1.0, 4.0, [1.0, 0.5, 0.25, 0.125]),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        h, a, nu, T_end, alpha_list = case\n        \n        # Determine the optimal subcycling factor r_j for each cell\n        r_list = []\n        for alpha_j in alpha_list:\n            # The stability condition r_j >= 1/alpha_j must be satisfied.\n            # We want the smallest power of two that meets this condition.\n            min_r_val = 1.0 / alpha_j\n            \n            # Efficiently find the smallest power of two >= min_r_val\n            # Can be found with logarithms: r = 2**ceil(log2(min_r_val))\n            # or with a simple loop.\n            r_j = 1\n            while r_j  min_r_val:\n                r_j *= 2\n            r_list.append(int(r_j))\n            \n        # Calculate performance metrics\n        M = len(alpha_list)\n        abs_a = abs(a)\n        \n        # Base time step and number of base steps\n        delta_t_base = nu * h / abs_a\n        N_base = int(round(T_end / delta_t_base))\n\n        # Total updates for local and uniform schemes\n        sum_r = sum(r_list)\n        N_local = N_base * sum_r\n        \n        R_max = max(r_list) if r_list else 1\n        N_uniform = N_base * M * R_max\n        \n        # Efficiency gain\n        G = N_uniform / N_local if N_local > 0 else 0.0\n        G_rounded = round(G, 6)\n        \n        # Verify stability for the chosen r_j\n        stable_flag = True\n        for r_j, alpha_j in zip(r_list, alpha_list):\n            h_j = alpha_j * h\n            delta_t_j = delta_t_base / r_j\n            cfl_val = abs_a * delta_t_j / h_j\n            # Use a small tolerance for floating point comparison\n            if cfl_val > nu + 1e-9:\n                stable_flag = False\n                break\n                \n        # Aggregate results for this case\n        case_result = [r_list, int(N_local), int(N_uniform), G_rounded, stable_flag]\n        all_results.append(case_result)\n\n    # Convert each element of the result lists to a string for join\n    def format_results(results):\n        formatted_list = []\n        for item in results:\n            if isinstance(item, list):\n                formatted_list.append(f\"[{','.join(map(str, item))}]\")\n            elif isinstance(item, float):\n                # Ensure float has required decimal places in string representation\n                formatted_list.append(f\"{item:.6f}\")\n            else:\n                 formatted_list.append(str(item))\n        return f\"[{','.join(formatted_list)}]\"\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(map(format_results, all_results))}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了精度和稳定性的核心挑战后，我们便可以将这些方法应用于一个实际的工程问题：计算浸入物体所受的力。这个任务要求我们将边界的抽象概念转化为具体的数值计算过程。这项实践  对比了两种主流思想：一种是将力分布在边界附近区域的弥散界面浸入边界法 (diffuse-interface IB method)，另一种是精确重构边界的锐利界面切割单元法 (sharp-interface CC method)。通过亲手实现这两种方法并将其计算结果与精确解进行比较，你将对它们各自的优缺点和实现细节获得深入的实践性理解。",
            "id": "2401412",
            "problem": "给定一个封闭光滑曲线 $\\Gamma \\subset \\mathbb{R}^2$，定义为以 $(c_x,c_y)$ 为中心、半径为 $R$ 的圆，即有符号距离函数 $\\phi(x,y)=\\sqrt{(x-c_x)^2+(y-c_y)^2}-R$ 的零水平集。定义平面上的矢量值力密度为 $\\mathbf{f}(x,y)=\\begin{bmatrix}\\cos(3\\theta(x,y))+\\tfrac{1}{2}\\\\ \\sin(2\\theta(x,y))\\end{bmatrix}$，其中 $\\theta(x,y)=\\mathrm{atan2}(y-c_y,x-c_x)$ 是围绕中心的极角，以弧度表示。总力由曲线积分 $\\mathbf{F}=\\int_{\\Gamma}\\mathbf{f}\\,ds$ 定义。\n\n您的任务是，在一个覆盖正方形域 $\\Omega=[-L,L]^2$ 的均匀笛卡尔网格上，使用两种不同的方法计算并比较 $\\mathbf{F}$ 的近似值：\n\n- 一种基于正则化狄拉克-德尔塔函数的弥散界面浸入边界近似。设正则化德尔塔函数为\n$$\n\\delta_\\varepsilon(\\phi)=\n\\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi\\phi}{\\varepsilon}\\right)\\right),  |\\phi|\\le \\varepsilon,\\\\\n0,  |\\phi|\\varepsilon,\n\\end{cases}\n$$\n并对于有符号距离 $\\phi$ 设 $|\\nabla \\phi|=1$。在一个间距为 $h=\\dfrac{2L}{N-1}$ 的 $N\\times N$ 网格上，通过单元面积为 $h^2$ 的黎曼和来近似\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)\\approx \\iint_{\\Omega}\\mathbf{f}(x,y)\\,\\delta_\\varepsilon(\\phi(x,y))\\,|\\nabla\\phi(x,y)|\\,dx\\,dy\n$$\n\n- 一种锐利界面切割单元近似，它将 $\\Gamma=\\{\\phi=0\\}$ 替换为一条折线，该折线由每个其顶点跨越零水平集的网格单元上对 $\\phi$ 进行线性插值得到。对于每个得到的长度为 $|s|$、中点为 $\\mathbf{m}_s$ 的线段 $s$，通过以下方式近似曲线积分\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h)\\approx \\sum_{s}\\mathbf{f}(\\mathbf{m}_s)\\,|s|.\n$$\n\n所有角度量均使用弧度。对于此人工构造测试，精确的总力为\n$$\n\\mathbf{F}_{\\mathrm{true}}=\\int_{0}^{2\\pi}\\begin{bmatrix}\\cos(3\\theta)+\\tfrac{1}{2}\\\\ \\sin(2\\theta)\\end{bmatrix}R\\,d\\theta=\\begin{bmatrix}\\pi R\\\\ 0\\end{bmatrix}.\n$$\n\n实现一个程序，对以下参数集（其中 $\\varepsilon=k_\\varepsilon\\,h$）评估欧几里得范数误差\n$$\ne_{\\mathrm{IB}}=\\left\\|\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon,h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2,\\qquad\ne_{\\mathrm{CC}}=\\left\\|\\mathbf{F}_{\\mathrm{CC}}(h)-\\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\n\n- 测试 1：$L=1.2$, $R=0.9$, $N=33$, $(c_x,c_y)=(0.0,0.0)$, $k_\\varepsilon=1.5$.\n- 测试 2：$L=1.2$, $R=0.9$, $N=33$, $(c_x,c_y)=(0.2,-0.15)$, $k_\\varepsilon=0.5$.\n- 测试 3：$L=1.2$, $R=0.9$, $N=65$, $(c_x,c_y)=(0.2,-0.15)$, $k_\\varepsilon=1.5$.\n- 测试 4：$L=1.2$, $R=0.9$, $N=129$, $(c_x,c_y)=(0.37,0.22)$, $k_\\varepsilon=1.5$.\n\n您的程序必须生成单行输出，其中包含一个逗号分隔的8个浮点数结果列表，并用方括号括起来，顺序为 $[e_{\\mathrm{IB}}^{(1)},e_{\\mathrm{CC}}^{(1)},e_{\\mathrm{IB}}^{(2)},e_{\\mathrm{CC}}^{(2)},e_{\\mathrm{IB}}^{(3)},e_{\\mathrm{CC}}^{(3)},e_{\\mathrm{IB}}^{(4)},e_{\\mathrm{CC}}^{(4)}]$，其中上标表示测试编号。每个值必须四舍五入到6位小数。不应打印任何其他文本。由于在此设置中所有量都是无量纲的，因此不需要物理单位。",
            "solution": "该问题要求计算矢量值力密度 $\\mathbf{f}(x,y)$ 在一个圆 $\\Gamma$ 上的曲线积分。这需要在一个均匀笛卡尔网格上使用两种不同的数值方法进行近似：弥散界面浸入边界 (IB) 方法和锐利界面切割单元 (CC) 方法。这些方法的准确性将通过将其结果与精确的解析解进行比较来评估。\n\n首先，定义每个测试用例所需的参数：域半宽 $L$、圆半径 $R$、中心坐标 $(c_x, c_y)$、网格尺寸 $N \\times N$ 以及狄拉克-德尔塔函数宽度参数 $k_\\varepsilon$。根据这些参数，可以导出网格间距 $h = \\frac{2L}{N-1}$ 和德尔塔函数支持半径 $\\varepsilon = k_\\varepsilon h$。计算网格由点 $(x_i, y_j)$ 组成，其中 $x_i = -L + i \\cdot h$ 且 $y_j = -L + j \\cdot h$，对于 $i, j \\in \\{0, 1, \\dots, N-1\\}$。\n\n精确总力 $\\mathbf{F}_{\\mathrm{true}}$ 由力密度沿以极角 $\\theta$ 参数化的曲线的积分给出：\n$$\n\\mathbf{F}_{\\mathrm{true}} = \\int_{0}^{2\\pi} \\mathbf{f}(\\theta) R \\, d\\theta = \\int_{0}^{2\\pi} \\begin{bmatrix} \\cos(3\\theta) + \\frac{1}{2} \\\\ \\sin(2\\theta) \\end{bmatrix} R \\, d\\theta = \\begin{bmatrix} \\pi R \\\\ 0 \\end{bmatrix}\n$$\n这可作为与数值近似值进行比较的基准。\n\n第一种数值方法是**浸入边界 (Immersed Boundary, IB) 方法**。该方法将集中在曲线 $\\Gamma$ 上的奇异力表示为一个分布在曲线小邻域内的正则化力场。这是通过使用正则化狄拉克-德尔塔函数 $\\delta_\\varepsilon(\\phi)$ 实现的，其中 $\\phi$ 是到曲线 $\\Gamma$ 的有符号距离函数。然后，通过在整个计算域 $\\Omega$ 上积分该正则化力场来近似总力：\n$$\n\\mathbf{F}_{\\mathrm{IB}}(\\varepsilon, h) = \\iint_{\\Omega} \\mathbf{f}(x,y) \\, \\delta_\\varepsilon(\\phi(x,y)) \\, |\\nabla\\phi(x,y)| \\, dx \\, dy\n$$\n鉴于对于有符号距离函数 $|\\nabla \\phi| = 1$，这简化了积分。我们将此积分离散化为网格单元上的黎曼和。对于每个网格点 $(x_i, y_j)$，我们评估力密度 $\\mathbf{f}(x_i, y_j)$、有符号距离 $\\phi(x_i, y_j)$ 和德尔塔函数 $\\delta_\\varepsilon(\\phi(x_i, y_j))$。总力则是这些贡献乘以单元面积 $h^2$ 的总和：\n$$\n\\mathbf{F}_{\\mathrm{IB}} \\approx \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{f}(x_i, y_j) \\, \\delta_\\varepsilon(\\phi(x_i, y_j)) \\, h^2\n$$\n实现过程包括在 $N \\times N$ 网格上计算这些量并执行求和。\n\n第二种数值方法是**切割单元 (Cut-Cell, CC) 方法**。该方法通过在其相交的每个网格单元内显式重构曲线 $\\Gamma$，从而提供几何的精确表示。过程如下：\n1. 遍历域中的每个网格单元。一个单元由四个相邻的网格点定义。\n2. 对于每个单元，确定它是否被曲线 $\\Gamma$“切割”。这可以通过检查有符号距离函数 $\\phi$ 在单元顶点之间是否变号来检测。如果所有顶点的 $\\phi$ 值符号相同，则该单元完全位于曲线内部或外部，对曲线积分没有贡献。\n3. 如果一个单元被切割，则需要找到 $\\Gamma$ 与单元边的交点。这是通过沿每条边对 $\\phi$ 进行线性插值来完成的。对于连接顶点 $\\mathbf{p}_1$ 和 $\\mathbf{p}_2$ 且有符号距离值为 $\\phi_1$ 和 $\\phi_2$ 的边，$\\phi=0$ 处的交点 $\\mathbf{p}_{\\text{int}}$ 由下式给出：\n$$\n\\mathbf{p}_{\\text{int}} = \\frac{\\phi_2 \\mathbf{p}_1 - \\phi_1 \\mathbf{p}_2}{\\phi_2 - \\phi_1}\n$$\n4. 对于像圆这样的光滑曲线和足够精细的网格，每个被切割的单元将恰好有两个交点。这两个点定义了一个线段 $s$，该线段近似了该单元内 $\\Gamma$ 的部分。\n5. 然后，通过对所有这些线段的贡献求和来近似曲线积分：\n$$\n\\mathbf{F}_{\\mathrm{CC}}(h) \\approx \\sum_{s} \\mathbf{f}(\\mathbf{m}_s) \\, |s|\n$$\n其中 $|s|$ 是线段 $s$ 的长度，$\\mathbf{m}_s$ 是它的中点。\n\n对于每个测试用例，都计算 $\\mathbf{F}_{\\mathrm{IB}}$ 和 $\\mathbf{F}_{\\mathrm{CC}}$。然后，误差计算为数值近似值与精确力 $\\mathbf{F}_{\\mathrm{true}}$ 之差的欧几里得范数：\n$$\ne_{\\mathrm{IB}} = \\left\\|\\mathbf{F}_{\\mathrm{IB}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2, \\qquad e_{\\mathrm{CC}} = \\left\\|\\mathbf{F}_{\\mathrm{CC}} - \\mathbf{F}_{\\mathrm{true}}\\right\\|_2\n$$\n为所有指定的测试用例收集这些误差值，并作为最终输出呈现。值得注意的是，在测试4中，圆稍微超出了计算域 $\\Omega$。两种数值方法都严格在 $\\Omega$ 内运行，因此它们将近似截断曲线 $\\Gamma \\cap \\Omega$ 上的积分。比较仍然是与 $\\mathbf{F}_{\\mathrm{true}}$（即在完整圆 $\\Gamma$ 上的积分）进行的。这为该特定测试用例计算的误差度量引入了域截断误差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares immersed-boundary and cut-cell approximations of a line integral.\n    \"\"\"\n    test_cases = [\n        # (L, R, N, (cx, cy), k_eps)\n        (1.2, 0.9, 33, (0.0, 0.0), 1.5),\n        (1.2, 0.9, 33, (0.2, -0.15), 0.5),\n        (1.2, 0.9, 65, (0.2, -0.15), 1.5),\n        (1.2, 0.9, 129, (0.37, 0.22), 1.5),\n    ]\n\n    results = []\n    for L, R, N, (cx, cy), k_eps in test_cases:\n        h = (2 * L) / (N - 1)\n        eps = k_eps * h\n        \n        # Grid setup\n        x_coords = np.linspace(-L, L, N)\n        y_coords = np.linspace(-L, L, N)\n        xx, yy = np.meshgrid(x_coords, y_coords)\n\n        # Signed distance function\n        phi = np.sqrt((xx - cx)**2 + (yy - cy)**2) - R\n        \n        # Exact force\n        F_true = np.array([np.pi * R, 0.0])\n\n        # --- Immersed Boundary (IB) Calculation ---\n        F_ib = np.zeros(2)\n        \n        # Active region for delta function\n        active_mask = np.abs(phi) = eps\n\n        phi_active = phi[active_mask]\n        xx_active = xx[active_mask]\n        yy_active = yy[active_mask]\n\n        delta_eps = (1.0 / (2.0 * eps)) * (1.0 + np.cos(np.pi * phi_active / eps))\n        \n        theta_active = np.arctan2(yy_active - cy, xx_active - cx)\n        \n        fx_active = np.cos(3 * theta_active) + 0.5\n        fy_active = np.sin(2 * theta_active)\n\n        F_ib[0] = np.sum(fx_active * delta_eps) * h**2\n        F_ib[1] = np.sum(fy_active * delta_eps) * h**2\n        \n        e_ib = np.linalg.norm(F_ib - F_true)\n        \n        # --- Cut-Cell (CC) Calculation ---\n        F_cc = np.zeros(2)\n        \n        phi_grid = phi\n\n        for j in range(N - 1):\n            for i in range(N - 1):\n                # Vertices (BL, BR, TR, TL) and their phi values\n                points = [\n                    np.array([x_coords[i], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j]]),\n                    np.array([x_coords[i+1], y_coords[j+1]]),\n                    np.array([x_coords[i], y_coords[j+1]])\n                ]\n                phis = [\n                    phi_grid[j, i], \n                    phi_grid[j, i+1], \n                    phi_grid[j+1, i+1], \n                    phi_grid[j+1, i]\n                ]\n\n                # If all phi values have the same sign, cell is not cut\n                if not (np.all(np.array(phis) > 0) or np.all(np.array(phis)  0)):\n                    intersections = []\n                    for k in range(4):\n                        p1, p2 = points[k], points[(k + 1) % 4]\n                        phi1, phi2 = phis[k], phis[(k + 1) % 4]\n\n                        if phi1 * phi2  0:\n                            # Linear interpolation to find the zero-crossing at phi=0\n                            p_int = (p1 * phi2 - p2 * phi1) / (phi2 - phi1)\n                            intersections.append(p_int)\n                    \n                    if len(intersections) == 2:\n                        p_a, p_b = intersections\n                        \n                        # Segment length\n                        length_s = np.linalg.norm(p_a - p_b)\n                        \n                        # Midpoint\n                        m_s = (p_a + p_b) / 2.0\n                        \n                        # Force at midpoint\n                        theta_m = np.arctan2(m_s[1] - cy, m_s[0] - cx)\n                        f_m = np.array([\n                            np.cos(3 * theta_m) + 0.5,\n                            np.sin(2 * theta_m)\n                        ])\n                        \n                        F_cc += f_m * length_s\n\n        e_cc = np.linalg.norm(F_cc - F_true)\n        \n        results.extend([e_ib, e_cc])\n\n    # Format output\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}