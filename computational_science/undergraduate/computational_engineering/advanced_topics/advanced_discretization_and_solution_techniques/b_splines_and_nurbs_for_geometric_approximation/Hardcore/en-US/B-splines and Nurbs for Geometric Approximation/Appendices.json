{
    "hands_on_practices": [
        {
            "introduction": "In computational engineering, different geometric modeling systems often use their own preferred curve representations. This exercise explores the fundamental relationship between two of the most important types: B-splines and Bézier curves. By deriving the transformation matrix that converts a uniform B-spline segment into its equivalent Bézier form, you will gain a deep understanding of how these representations are connected through a common polynomial basis. This hands-on derivation  moves beyond rote application of formulas, strengthening your foundational knowledge of spline mathematics.",
            "id": "2372217",
            "problem": "A cubic B-spline curve with an open uniform knot vector and unit spacing is used to approximate a smooth profile in a computational engineering pipeline. Consider an interior knot span $\\left[u_k, u_{k+1}\\right]$ with $u_{k+1} - u_k = 1$. Let the curve segment on this span be written in two equivalent forms:\n- As a degree-$3$ B-spline segment using the $4$ control points $\\mathbf{P}_{k-3}, \\mathbf{P}_{k-2}, \\mathbf{P}_{k-1}, \\mathbf{P}_{k}$ and the nonzero basis functions $N_{k-3,3}(u), \\dots, N_{k,3}(u)$.\n- As a cubic Bézier curve using the $4$ Bézier control points $\\mathbf{Q}_0, \\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{Q}_3$ and the Bernstein polynomials of degree $3$.\n\nStarting only from the fundamental definitions of B-spline basis functions via the Cox–de Boor recursion and the Bernstein polynomials, proceed as follows:\n- Reparameterize the span to $s \\in [0,1]$ using $s = u - u_k$.\n- Derive the polynomial form on $[0,1]$ of the $4$ nonzero cubic uniform B-spline basis functions for this span.\n- Express both the B-spline and the Bézier representations in the monomial power basis $\\left[s^3, s^2, s, 1\\right]$ to obtain their respective $4 \\times 4$ basis matrices.\n- From first principles, derive the $4 \\times 4$ linear transformation matrix $\\mathbf{T}$ such that\n$$\n\\begin{pmatrix}\n\\mathbf{Q}_0 \\\\ \\mathbf{Q}_1 \\\\ \\mathbf{Q}_2 \\\\ \\mathbf{Q}_3\n\\end{pmatrix}\n=\n\\mathbf{T}\n\\begin{pmatrix}\n\\mathbf{P}_{k-3} \\\\ \\mathbf{P}_{k-2} \\\\ \\mathbf{P}_{k-1} \\\\ \\mathbf{P}_k\n\\end{pmatrix}.\n$$\n\nGive your final answer as a single explicit $4 \\times 4$ matrix with rational entries. Do not use any pre-tabulated conversion formulas or results beyond the fundamental definitions. The final answer must be a single closed-form expression. No rounding is required.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of computational geometry, specifically the theory of B-splines and Bézier curves. The problem is well-posed, objective, and contains all necessary information for a unique solution to be derived from first principles. We shall proceed with the derivation.\n\nThe objective is to find the linear transformation matrix $\\mathbf{T}$ that maps a set of four uniform cubic B-spline control points $\\{\\mathbf{P}_{k-3}, \\mathbf{P}_{k-2}, \\mathbf{P}_{k-1}, \\mathbf{P}_{k}\\}$ to the set of four equivalent cubic Bézier control points $\\{\\mathbf{Q}_0, \\mathbf{Q}_1, \\mathbf{Q}_2, \\mathbf{Q}_3\\}$. The curve segment is defined over a knot span $[u_k, u_{k+1}]$, which is reparameterized by $s = u - u_k$ to the interval $[0,1]$.\n\nA curve segment $\\mathbf{C}(s)$ for $s \\in [0,1]$ can be expressed in two forms:\n$1$. As a B-spline segment: $\\mathbf{C}(s) = \\sum_{i=0}^{3} \\mathbf{P}_{k-3+i} b_i(s)$, where $b_i(s) = N_{k-3+i, 3}(u)$ are the B-spline basis functions evaluated on the span.\n$2$. As a Bézier segment: $\\mathbf{C}(s) = \\sum_{j=0}^{3} \\mathbf{Q}_j B_{j,3}(s)$, where $B_{j,3}(s)$ are the Bernstein basis polynomials.\n\nBoth representations can be written in a matrix form using the monomial basis $[s^3, s^2, s, 1]$. Let $S(s) = \\begin{pmatrix} s^3  s^2  s  1 \\end{pmatrix}$.\nThen,\n$$ \\mathbf{C}(s) = S(s) M_{B-spline} \\begin{pmatrix} \\mathbf{P}_{k-3} \\\\ \\mathbf{P}_{k-2} \\\\ \\mathbf{P}_{k-1} \\\\ \\mathbf{P}_k \\end{pmatrix} = S(s) M_{Bezier} \\begin{pmatrix} \\mathbf{Q}_0 \\\\ \\mathbf{Q}_1 \\\\ \\mathbf{Q}_2 \\\\ \\mathbf{Q}_3 \\end{pmatrix} $$\nSince the monomial basis is linearly independent, the coefficients of $S(s)$ must be equal:\n$$ M_{B-spline} \\begin{pmatrix} \\mathbf{P}_{k-3} \\\\ \\mathbf{P}_{k-2} \\\\ \\mathbf{P}_{k-1} \\\\ \\mathbf{P}_k \\end{pmatrix} = M_{Bezier} \\begin{pmatrix} \\mathbf{Q}_0 \\\\ \\mathbf{Q}_1 \\\\ \\mathbf{Q}_2 \\\\ \\mathbf{Q}_3 \\end{pmatrix} $$\nFrom this, we can solve for the Bézier control points:\n$$ \\begin{pmatrix} \\mathbf{Q}_0 \\\\ \\mathbf{Q}_1 \\\\ \\mathbf{Q}_2 \\\\ \\mathbf{Q}_3 \\end{pmatrix} = (M_{Bezier})^{-1} M_{B-spline} \\begin{pmatrix} \\mathbf{P}_{k-3} \\\\ \\mathbf{P}_{k-2} \\\\ \\mathbf{P}_{k-1} \\\\ \\mathbf{P}_k \\end{pmatrix} $$\nThe desired transformation matrix is therefore $\\mathbf{T} = (M_{Bezier})^{-1} M_{B-spline}$. We will now derive the matrices $M_{B-spline}$ and $M_{Bezier}$ from their fundamental definitions.\n\nStep 1: Derivation of the Uniform Cubic B-spline Basis Functions\nWe use the Cox-de Boor recursion formula for B-spline basis functions of degree $p$:\n$$ N_{i,p}(u) = \\frac{u-u_i}{u_{i+p}-u_i}N_{i,p-1}(u) + \\frac{u_{i+p+1}-u}{u_{i+p+1}-u_{i+1}}N_{i+1,p-1}(u) $$\nwith $N_{i,0}(u) = 1$ if $u_i \\le u  u_{i+1}$ and $0$ otherwise.\nFor a uniform knot vector with unit spacing, we may set $u_i = i$ without loss of generality. The recursion simplifies to:\n$$ N_{i,p}(u) = \\frac{u-i}{p}N_{i,p-1}(u) + \\frac{i+p+1-u}{p}N_{i+1,p-1}(u) $$\nWe are interested in the interval $[u_k, u_{k+1}] = [k, k+1]$, parameterized by $s = u-k \\in [0,1]$, so $u=s+k$.\nThe four non-zero cubic ($p=3$) basis functions on this interval are $N_{k-3,3}(u), N_{k-2,3}(u), N_{k-1,3}(u), N_{k,3}(u)$. Let's denote their reparameterized forms as $b_0(s), b_1(s), b_2(s), b_3(s)$. We build them up from degree $0$.\n\nOn $u \\in [k, k+1)$, the only non-zero basis function of degree $0$ is $N_{k,0}(u)=1$. For degree $1$, the functions with support overlapping this interval are $N_{k-1,1}(u) = k+1-u = 1-s$ and $N_{k,1}(u) = u-k = s$.\n\nFor degree $2$ ($p=2$):\n$N_{k-2,2}(u) = \\frac{u-(k-2)}{2}N_{k-2,1}(u) + \\frac{k+1-u}{2}N_{k-1,1}(u) = 0 + \\frac{1-s}{2}(1-s) = \\frac{1}{2}(1-s)^2$.\n$N_{k-1,2}(u) = \\frac{u-(k-1)}{2}N_{k-1,1}(u) + \\frac{k+2-u}{2}N_{k,1}(u) = \\frac{s+1}{2}(1-s) + \\frac{2-s}{2}(s) = \\frac{1}{2}(-2s^2+2s+1)$.\n$N_{k,2}(u) = \\frac{u-k}{2}N_{k,1}(u) + \\frac{k+3-u}{2}N_{k+1,1}(u) = \\frac{s}{2}(s) + 0 = \\frac{1}{2}s^2$.\n\nFor degree $3$ ($p=3$):\n$b_0(s) = N_{k-3,3}(u) = \\frac{k+1-u}{3}N_{k-2,2}(u) = \\frac{1-s}{3} \\frac{(1-s)^2}{2} = \\frac{1}{6}(1-s)^3 = \\frac{1}{6}(-s^3+3s^2-3s+1)$.\n$b_1(s) = N_{k-2,3}(u) = \\frac{u-(k-2)}{3}N_{k-2,2}(u) + \\frac{k+2-u}{3}N_{k-1,2}(u) = \\frac{s+2}{3}\\frac{(1-s)^2}{2} + \\frac{2-s}{3}\\frac{-2s^2+2s+1}{2} = \\frac{1}{6}(3s^3-6s^2+4)$.\n$b_2(s) = N_{k-1,3}(u) = \\frac{u-(k-1)}{3}N_{k-1,2}(u) + \\frac{k+3-u}{3}N_{k,2}(u) = \\frac{s+1}{3}\\frac{-2s^2+2s+1}{2} + \\frac{3-s}{3}\\frac{s^2}{2} = \\frac{1}{6}(-3s^3+3s^2+3s+1)$.\n$b_3(s) = N_{k,3}(u) = \\frac{u-k}{3}N_{k,2}(u) = \\frac{s}{3}\\frac{s^2}{2} = \\frac{1}{6}s^3$.\n\nThe B-spline basis matrix $M_{B-spline}$ is formed by the coefficients of these polynomials in the basis $[s^3, s^2, s, 1]$. The $j$-th column corresponds to $b_{j-1}(s)$.\n$$ M_{B-spline} = \\frac{1}{6} \\begin{pmatrix} -1  3  -3  1 \\\\ 3  -6  3  0 \\\\ -3  0  3  0 \\\\ 1  4  1  0 \\end{pmatrix} $$\n\nStep 2: Derivation of the Bézier Basis Matrix\nThe cubic Bernstein basis polynomials are defined as $B_{i,3}(s) = \\binom{3}{i} s^i (1-s)^{3-i}$ for $i=0,1,2,3$.\n$B_{0,3}(s) = (1-s)^3 = -s^3 + 3s^2 - 3s + 1$.\n$B_{1,3}(s) = 3s(1-s)^2 = 3s^3 - 6s^2 + 3s$.\n$B_{2,3}(s) = 3s^2(1-s) = -3s^3 + 3s^2$.\n$B_{3,3}(s) = s^3$.\n\nThe Bézier basis matrix $M_{Bezier}$ is formed by the coefficients of these polynomials.\n$$ M_{Bezier} = \\begin{pmatrix} -1  3  -3  1 \\\\ 3  -6  3  0 \\\\ -3  3  0  0 \\\\ 1  0  0  0 \\end{pmatrix} $$\n\nStep 3: Derivation of the Inverse Bézier Basis Matrix\nTo find $\\mathbf{T}$, we need $(M_{Bezier})^{-1}$. We can derive this by relating the Bézier control points to the coefficients of the monomial power basis. For a curve $\\mathbf{C}(s) = \\mathbf{c}_3 s^3 + \\mathbf{c}_2 s^2 + \\mathbf{c}_1 s + \\mathbf{c}_0$, the Bézier points are given by its endpoint derivatives.\n$\\mathbf{Q}_0 = \\mathbf{C}(0) = \\mathbf{c}_0$.\n$\\mathbf{Q}_1 = \\mathbf{C}(0) + \\frac{1}{3}\\mathbf{C}'(0) = \\mathbf{c}_0 + \\frac{1}{3}\\mathbf{c}_1$.\n$\\mathbf{Q}_3 = \\mathbf{C}(1) = \\mathbf{c}_3 + \\mathbf{c}_2 + \\mathbf{c}_1 + \\mathbf{c}_0$.\n$\\mathbf{Q}_2 = \\mathbf{C}(1) - \\frac{1}{3}\\mathbf{C}'(1) = (\\mathbf{c}_3+\\mathbf{c}_2+\\mathbf{c}_1+\\mathbf{c}_0) - \\frac{1}{3}(3\\mathbf{c}_3+2\\mathbf{c}_2+\\mathbf{c}_1) = \\mathbf{c}_0 + \\frac{2}{3}\\mathbf{c}_1 + \\frac{1}{3}\\mathbf{c}_2$.\n\nIn matrix form, this relation is:\n$$ \\begin{pmatrix} \\mathbf{Q}_0 \\\\ \\mathbf{Q}_1 \\\\ \\mathbf{Q}_2 \\\\ \\mathbf{Q}_3 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  1/3  1 \\\\ 0  1/3  2/3  1 \\\\ 1  1  1  1 \\end{pmatrix} \\begin{pmatrix} \\mathbf{c}_3 \\\\ \\mathbf{c}_2 \\\\ \\mathbf{c}_1 \\\\ \\mathbf{c}_0 \\end{pmatrix} $$\nThe vector $(\\mathbf{c}_3, \\mathbf{c}_2, \\mathbf{c}_1, \\mathbf{c}_0)^T$ is the result of $M_{B-spline} \\mathbf{P}_{vec}$. Therefore, the matrix above is $(M_{Bezier})^{-1}$.\n$$ (M_{Bezier})^{-1} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  \\frac{1}{3}  1 \\\\ 0  \\frac{1}{3}  \\frac{2}{3}  1 \\\\ 1  1  1  1 \\end{pmatrix} $$\n\nStep 4: Calculation of the Transformation Matrix T\nFinally, we compute the product $\\mathbf{T} = (M_{Bezier})^{-1} M_{B-spline}$.\n$$ \\mathbf{T} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  \\frac{1}{3}  1 \\\\ 0  \\frac{1}{3}  \\frac{2}{3}  1 \\\\ 1  1  1  1 \\end{pmatrix} \\frac{1}{6} \\begin{pmatrix} -1  3  -3  1 \\\\ 3  -6  3  0 \\\\ -3  0  3  0 \\\\ 1  4  1  0 \\end{pmatrix} $$\n$$ \\mathbf{T} = \\frac{1}{6} \\begin{pmatrix}\n(1)  (4)  (1)  (0) \\\\\n\\frac{1}{3}(-3)+1(1)  \\frac{1}{3}(0)+1(4)  \\frac{1}{3}(3)+1(1)  \\frac{1}{3}(0)+1(0) \\\\\n\\frac{1}{3}(3)+\\frac{2}{3}(-3)+1(1)  \\frac{1}{3}(-6)+\\frac{2}{3}(0)+1(4)  \\frac{1}{3}(3)+\\frac{2}{3}(3)+1(1)  \\frac{1}{3}(0)+\\frac{2}{3}(0)+1(0) \\\\\n(-1)+3-3+1  3-6+0+4  -3+3+3+1  1+0+0+0\n\\end{pmatrix} $$\n$$ \\mathbf{T} = \\frac{1}{6} \\begin{pmatrix}\n1  4  1  0 \\\\\n-1+1  4  1+1  0 \\\\\n1-2+1  -2+4  1+2+1  0 \\\\\n0  1  4  1\n\\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix}\n1  4  1  0 \\\\\n0  4  2  0 \\\\\n0  2  4  0 \\\\\n0  1  4  1\n\\end{pmatrix} $$\nThe problem requests the final answer as a single explicit matrix with rational entries. We incorporate the scalar multiple into the matrix elements.\n$$ \\mathbf{T} = \\begin{pmatrix}\n\\frac{1}{6}  \\frac{4}{6}  \\frac{1}{6}  0 \\\\\n0  \\frac{4}{6}  \\frac{2}{6}  0 \\\\\n0  \\frac{2}{6}  \\frac{4}{6}  0 \\\\\n0  \\frac{1}{6}  \\frac{4}{6}  \\frac{1}{6}\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{1}{6}  \\frac{2}{3}  \\frac{1}{6}  0 \\\\\n0  \\frac{2}{3}  \\frac{1}{3}  0 \\\\\n0  \\frac{1}{3}  \\frac{2}{3}  0 \\\\\n0  \\frac{1}{6}  \\frac{2}{3}  \\frac{1}{6}\n\\end{pmatrix} $$\nThis is the required transformation matrix.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6}  \\frac{2}{3}  \\frac{1}{6}  0 \\\\\n0  \\frac{2}{3}  \\frac{1}{3}  0 \\\\\n0  \\frac{1}{3}  \\frac{2}{3}  0 \\\\\n0  \\frac{1}{6}  \\frac{2}{3}  \\frac{1}{6}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "One of the most practical tasks in geometric design is creating a smooth, predictable curve that passes through a specific set of data points. This exercise  guides you through the complete process of B-spline interpolation, a cornerstone of computer-aided design. You will learn to construct the entire system from the ground up, including generating parameter values via chord-length parameterization and building a suitable knot vector, before solving for the control points that force the curve to meet the required constraints. This practice bridges the gap between abstract theory and tangible design, showing how to manipulate the B-spline control structure to achieve a precise geometric goal.",
            "id": "2372182",
            "problem": "Design a program that, for each given test case, constructs a nonrational B-spline curve of degree $p$ that interpolates a specified sequence of points in Euclidean space by enforcing exact interpolation at a set of parameter values. Let the sequence of data points be $\\{\\mathbf{Q}_i\\}_{i=0}^{n}$ with $\\mathbf{Q}_i \\in \\mathbb{R}^d$, where $d \\in \\{2,3\\}$. Define the B-spline basis functions $\\{N_{j,p}(u)\\}_{j=0}^{n}$ over a clamped open knot vector $\\mathbf{U} = \\{U_0,\\dots,U_{n+p+1}\\}$, and define the B-spline curve $ \\mathbf{C}(u) = \\sum_{j=0}^{n} N_{j,p}(u)\\,\\mathbf{P}_j$, where $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ are the unknown control points in $\\mathbb{R}^d$. The interpolation requirement is $\\mathbf{C}(t_i) = \\mathbf{Q}_i$ for $i = 0,\\dots,n$, where $\\{t_i\\}_{i=0}^{n}$ are strictly increasing parameter values in $[0,1]$ obtained by chord-length parameterization defined by $t_0 = 0$, $t_i = \\left(\\sum_{k=1}^{i} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2\\right) / \\left(\\sum_{k=1}^{n} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2\\right)$ for $i=1,\\dots,n$, and hence $t_n = 1$. The clamped open knot vector must have multiplicity $p+1$ at the ends: $U_0 = \\cdots = U_p = 0$ and $U_{n+1} = \\cdots = U_{n+p+1} = 1$, with internal knots set by the averaging method for $j=1,\\dots,n-p$:\n$$\nU_{j+p} = \\frac{1}{p}\\sum_{i=j}^{j+p-1} t_i.\n$$\nFor each test case, compute control points $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ that satisfy the interpolation constraints, evaluate the curve at the same parameter values $\\{t_i\\}$, and return the maximum interpolation residual measured by the Euclidean norm, i.e., $\\max_{0\\le i\\le n} \\|\\mathbf{C}(t_i)-\\mathbf{Q}_i\\|_2$, as a real number. No physical units are involved.\n\nTest Suite:\n- Case A (happy path, two-dimensional cubic): $p=3$, $\\mathbf{Q}_0=\\left(0,0\\right)$, $\\mathbf{Q}_1=\\left(1,2\\right)$, $\\mathbf{Q}_2=\\left(3,3\\right)$, $\\mathbf{Q}_3=\\left(4,2\\right)$, $\\mathbf{Q}_4=\\left(5,0\\right)$.\n- Case B (boundary degree, two-dimensional linear with multiple interior knots): $p=1$, $\\mathbf{Q}_0=\\left(0,0\\right)$, $\\mathbf{Q}_1=\\left(1,2\\right)$, $\\mathbf{Q}_2=\\left(2,2\\right)$, $\\mathbf{Q}_3=\\left(3,0\\right)$.\n- Case C (three-dimensional quadratic, nonuniform spacing): $p=2$, $\\mathbf{Q}_0=\\left(0,0,0\\right)$, $\\mathbf{Q}_1=\\left(1,0.5,0.1\\right)$, $\\mathbf{Q}_2=\\left(2,0.0,0.2\\right)$, $\\mathbf{Q}_3=\\left(3,-0.5,0.0\\right)$, $\\mathbf{Q}_4=\\left(4,0.0,-0.1\\right)$.\n\nYour program must, for each case in the order A, B, C, construct the parameter values $\\{t_i\\}$, construct the clamped open knot vector $\\mathbf{U}$ as specified, set up the interpolation equations implied by $\\mathbf{C}(t_i)=\\mathbf{Q}_i$ for $i=0,\\dots,n$, compute control points $\\{\\mathbf{P}_j\\}$, and output a single real number equal to $\\max_{i}\\|\\mathbf{C}(t_i)-\\mathbf{Q}_i\\|_2$ for that case.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\text{resultA}, \\text{resultB}, \\text{resultC} \\right]$), where each entry is the maximum interpolation residual for the corresponding test case expressed as a real number.",
            "solution": "The user has provided a problem that requires the design of a program for B-spline curve interpolation. The problem is well-defined, scientifically sound, and falls within the domain of computational engineering. It has been validated as a valid problem.\n\nThe core of the problem is to find a set of control points $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ for a B-spline curve of degree $p$, such that the curve passes through a given sequence of data points $\\{\\mathbf{Q}_i\\}_{i=0}^{n}$. The interpolation conditions are given by $\\mathbf{C}(t_i) = \\mathbf{Q}_i$ for a specific set of parameter values $\\{t_i\\}_{i=0}^{n}$.\n\nThe B-spline curve is defined as a linear combination of B-spline basis functions $N_{j,p}(u)$ and the unknown control points $\\mathbf{P}_j$:\n$$\n\\mathbf{C}(u) = \\sum_{j=0}^{n} N_{j,p}(u)\\,\\mathbf{P}_j\n$$\nSubstituting the interpolation conditions into this definition yields a system of $n+1$ linear equations for the $n+1$ unknown control points:\n$$\n\\mathbf{Q}_i = \\sum_{j=0}^{n} N_{j,p}(t_i)\\,\\mathbf{P}_j \\quad \\text{for } i = 0, \\dots, n\n$$\nThis system can be expressed in matrix form as $N \\mathbf{P} = \\mathbf{Q}$, where $N$ is an $(n+1) \\times (n+1)$ matrix with entries $N_{ij} = N_{j,p}(t_i)$, $\\mathbf{P}$ is the matrix of control points (with rows being $\\mathbf{P}_j^T$), and $\\mathbf{Q}$ is the matrix of data points (with rows being $\\mathbf{Q}_i^T$). Note that this system is solved independently for each coordinate of the points.\n\nThe solution proceeds via the following well-defined steps:\n\n1.  **Parameterization**: The parameter values $\\{t_i\\}_{i=0}^{n}$ are determined using the chord-length method. This method assigns parameter values proportionally to the cumulative Euclidean distance between consecutive data points. The total chord length is $L = \\sum_{k=1}^{n} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2$. The parameters are then:\n    $$\n    t_0 = 0, \\quad t_i = \\frac{1}{L} \\sum_{k=1}^{i} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2 \\quad \\text{for } i=1,\\dots,n\n    $$\n\n2.  **Knot Vector Generation**: A clamped open knot vector $\\mathbf{U}$ of size $n+p+2$ is constructed. The clamping ensures that the curve starts at $\\mathbf{P}_0$ and ends at $\\mathbf{P}_n$. The knots are defined as:\n    - End knots: $U_0 = \\dots = U_p = 0$ and $U_{n+1} = \\dots = U_{n+p+1} = 1$.\n    - Internal knots: The problem specifies an averaging method, where internal knots are computed based on the parameter values $\\{t_i\\}$:\n    $$\n    U_{j+p} = \\frac{1}{p}\\sum_{i=j}^{j+p-1} t_i \\quad \\text{for } j=1, \\dots, n-p\n    $$\n    This method of knot placement is designed to satisfy the Schoenberg-Whitney conditions, ensuring that the resulting interpolation matrix $N$ is non-singular and well-conditioned.\n\n3.  **Basis Function Evaluation**: The B-spline basis functions $N_{j,p}(u)$ are evaluated using the Cox-de Boor recursion formula. For $p  0$:\n    $$\n    N_{j,p}(u) = \\frac{u - U_j}{U_{j+p} - U_j} N_{j,p-1}(u) + \\frac{U_{j+p+1} - u}{U_{j+p+1} - U_{j+1}} N_{j+1,p-1}(u)\n    $$\n    The base case for the recursion is:\n    $$\n    N_{j,0}(u) = \\begin{cases} 1  \\text{if } U_j \\le u  U_{j+1} \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    A convention is used where any term with a zero denominator is treated as zero. For the very last knot interval, $[U_n, U_{n+1}]$, the interval is considered closed at the right end to handle $u=1$. Computationally, this process is implemented efficiently without recursion, by calculating values for increasing degrees.\n\n4.  **System Solution**: The interpolation matrix $N$ is populated by evaluating the basis functions at each parameter value $t_i$. The linear system $N \\mathbf{P} = \\mathbf{Q}$ is then solved for the control point matrix $\\mathbf{P}$ using a standard numerical linear algebra solver, such as `numpy.linalg.solve`, which is robust against potential numerical instabilities.\n\n5.  **Residual Calculation**: After computing the control points $\\{\\mathbf{P}_j\\}$, the B-spline curve $\\mathbf{C}(u)$ is fully defined. To verify the interpolation, the curve is evaluated at the original parameter values, $\\mathbf{C}(t_i)$. Due to floating-point arithmetic limitations, the computed $\\mathbf{C}(t_i)$ might not be exactly equal to $\\mathbf{Q}_i$. The interpolation residual for each point is calculated as the Euclidean norm of the difference, $\\|\\mathbf{C}(t_i) - \\mathbf{Q}_i\\|_2$. The final result for each test case is the maximum of these residuals over all $i=0, \\dots, n$. This value serves as a measure of the accuracy of the numerical implementation. For a correct implementation, this residual should be on the order of machine precision.",
            "answer": "```python\nimport numpy as np\n\ndef find_span(n, p, u, U):\n    \"\"\"\n    Determine the knot span index for a given parameter u.\n    This implementation is based on Algorithm A2.1 from \"The NURBS Book\".\n    \n    Args:\n        n (int): Number of control points minus 1.\n        p (int): Degree of the B-spline.\n        u (float): Parameter value.\n        U (np.ndarray): Knot vector.\n    \n    Returns:\n        int: The index of the knot span that contains u.\n    \"\"\"\n    if u = U[n + 1]:  # Special case for u at the end of the domain\n        return n\n    \n    # Binary search for the span\n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    \n    while u  U[mid] or u = U[mid + 1]:\n        if u  U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef basis_funs(i, u, p, U):\n    \"\"\"\n    Compute the non-zero B-spline basis functions.\n    This implementation is based on Algorithm A2.2 from \"The NURBS Book\".\n\n    Args:\n        i (int): Knot span index.\n        u (float): Parameter value.\n        p (int): Degree of the B-spline.\n        U (np.ndarray): Knot vector.\n\n    Returns:\n        np.ndarray: An array of p+1 non-zero basis function values.\n    \"\"\"\n    N = np.zeros(p + 1, dtype=np.float64)\n    N[0] = 1.0\n    left = np.zeros(p + 1, dtype=np.float64)\n    right = np.zeros(p + 1, dtype=np.float64)\n\n    for j in range(1, p + 1):\n        left[j] = u - U[i + 1 - j]\n        right[j] = U[i + j] - u\n        saved = 0.0\n        for r in range(j):\n            # The denominator can be zero if knots are repeated. The formula\n            # requires this term to be zero, which is handled implicitly\n            # if the numerator is also zero, but we add a check for robustness.\n            den = right[r + 1] + left[j - r]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = N[r] / den\n            N[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        N[j] = saved\n    return N\n\ndef solve_interpolation(p, Q_points):\n    \"\"\"\n    Computes the maximum interpolation residual for a single test case.\n\n    Args:\n        p (int): Degree of the B-spline.\n        Q_points (list of tuples): Sequence of data points to interpolate.\n\n    Returns:\n        float: The maximum interpolation residual.\n    \"\"\"\n    Q = np.array(Q_points, dtype=np.float64)\n    n = Q.shape[0] - 1\n    \n    # Step 1: Chord-length parameterization\n    t = np.zeros(n + 1, dtype=np.float64)\n    chord_lengths = np.linalg.norm(np.diff(Q, axis=0), axis=1)\n    total_length = np.sum(chord_lengths)\n    \n    if total_length  1e-12: # Handle degenerate case where all points coincide.\n        return 0.0\n\n    cumulative_lengths = np.cumsum(chord_lengths)\n    t[1:] = cumulative_lengths / total_length\n    \n    # Step 2: Knot vector construction\n    num_knots = n + p + 2\n    U = np.zeros(num_knots, dtype=np.float64)\n    U[0:p+1] = 0.0\n    U[n+1:] = 1.0\n    \n    if p  0 and n  p:\n        for j in range(1, n - p + 1):\n            U[p + j] = (1.0 / p) * np.sum(t[j : j + p])\n    elif p == 1 and n  1: # The general formula covers this, but for clarity:\n        for j in range(1, n):\n            U[1 + j] = t[j]\n\n    # Step 3: Set up interpolation matrix N\n    N_matrix = np.zeros((n + 1, n + 1), dtype=np.float64)\n    for i in range(n + 1):\n        u_param = t[i]\n        span = find_span(n, p, u_param, U)\n        basis_values = basis_funs(span, u_param, p, U)\n        start_idx = span - p\n        N_matrix[i, start_idx : start_idx + p + 1] = basis_values\n\n    # Step 4: Solve for control points P\n    try:\n        P = np.linalg.solve(N_matrix, Q)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # Step 5: Evaluate the curve and compute the maximum residual\n    Q_reconstructed = N_matrix @ P\n    residuals = np.linalg.norm(Q_reconstructed - Q, axis=1)\n    max_residual = np.max(residuals)\n    \n    return max_residual\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: 2D cubic B-spline\n        (3, [ (0.0, 0.0), (1.0, 2.0), (3.0, 3.0), (4.0, 2.0), (5.0, 0.0) ]),\n        # Case B: 2D linear B-spline\n        (1, [ (0.0, 0.0), (1.0, 2.0), (2.0, 2.0), (3.0, 0.0) ]),\n        # Case C: 3D quadratic B-spline\n        (2, [ (0.0, 0.0, 0.0), (1.0, 0.5, 0.1), (2.0, 0.0, 0.2), (3.0, -0.5, 0.0), (4.0, 0.0, -0.1) ])\n    ]\n\n    results = []\n    for p, Q_points in test_cases:\n        result = solve_interpolation(p, Q_points)\n        # Format to scientific notation for consistent output of small numbers.\n        results.append(f\"{result:.17e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Progressing from curves to surfaces and from B-splines to their powerful generalization, NURBS, is essential for modeling complex three-dimensional objects. This advanced practice  delves into the differential geometry of NURBS surfaces, a critical skill for engineering analysis, rendering, and simulation. You will implement an algorithm to compute the tangent plane at any point on a surface by first finding the partial derivatives $\\mathbf{S}_u$ and $\\mathbf{S}_v$ and then their cross product. This involves a careful application of the quotient rule to the rational NURBS definition, providing a robust method for analyzing the local geometry of sophisticated models.",
            "id": "2372227",
            "problem": "Design and implement a complete, runnable program that computes the coefficients of the tangent plane to a Non-Uniform Rational B-Spline (NURBS) tensor-product surface at specified parameter values. The solution must be derived from first principles of B-splines and rational surfaces and must not rely on external data or interactivity.\n\nYou must base your derivation and implementation on the following fundamental definitions and facts:\n- The B-spline basis functions of degree $p$ are defined recursively by the Cox–de Boor recursion:\n  - For $p=0$, $N_{i,0}(u) = 1$ if $u \\in [U_i, U_{i+1})$ and $0$ otherwise.\n  - For $p \\ge 1$,\n  $$\n  N_{i,p}(u) = \\frac{u-U_i}{U_{i+p}-U_i} N_{i,p-1}(u) + \\frac{U_{i+p+1}-u}{U_{i+p+1}-U_{i+1}} N_{i+1,p-1}(u),\n  $$\n  with the convention that terms with zero denominators contribute zero.\n- A tensor-product NURBS surface of degrees $p$ and $q$ is defined by control points $\\mathbf{P}_{i,j} \\in \\mathbb{R}^3$, associated nonnegative weights $w_{i,j}$, and knot vectors $U$ and $V$:\n  $$\n  \\mathbf{S}(u,v) = \\frac{\\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) \\, M_{j,q}(v) \\, w_{i,j} \\, \\mathbf{P}_{i,j}}{\\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) \\, M_{j,q}(v) \\, w_{i,j}},\n  $$\n  where $M_{j,q}(v)$ are the B-spline basis functions in $v$ with knot vector $V$.\n- The tangent plane at $(u_0,v_0)$ is the plane passing through the surface point $\\mathbf{S}(u_0,v_0)$ with normal vector $\\mathbf{n}(u_0,v_0) = \\mathbf{S}_u(u_0,v_0) \\times \\mathbf{S}_v(u_0,v_0)$, provided $\\|\\mathbf{n}\\| \\ne 0$. The plane coefficients $(a,b,c,d)$ satisfy $a x + b y + c z + d = 0$, with $(a,b,c) = \\mathbf{\\hat n}$ a unit normal and $d = -\\mathbf{\\hat n}\\cdot \\mathbf{S}(u_0,v_0)$.\n\nYou must implement the algorithm to evaluate $\\mathbf{S}(u,v)$ and its first partial derivatives $\\mathbf{S}_u(u,v)$ and $\\mathbf{S}_v(u,v)$ by combining:\n- Derivatives of the non-rational B-spline basis functions (via a principled recursion for basis function derivatives).\n- The quotient rule for rational functions to obtain derivatives of $\\mathbf{S}(u,v)$ from the derivatives of the weighted numerator and weight denominator.\n\nSurface specification to be used in your program:\n- Degrees: $p=q=2$.\n- Knot vectors (open uniform):\n  $$\n  U = [\\,0,\\,0,\\,0,\\,\\tfrac{1}{2},\\,1,\\,1,\\,1\\,], \\quad V = [\\,0,\\,0,\\,0,\\,\\tfrac{1}{2},\\,1,\\,1,\\,1\\,].\n  $$\n- Control net $\\mathbf{P}_{i,j}$ for $i \\in \\{0,1,2,3\\}$ and $j \\in \\{0,1,2,3\\}$ defined procedurally by\n  $$\n  \\mathbf{P}_{i,j} = \\big(i,\\; j,\\; 0.2\\,(i-1.5)^2 + 0.1\\,(j-1.5)^2\\big).\n  $$\n- Weights $w_{i,j}$ defined piecewise by\n  $$\n  w_{i,j} = \\begin{cases}\n  2,  \\text{if } i \\in \\{1,2\\} \\text{ and } j \\in \\{1,2\\},\\\\\n  1,  \\text{otherwise}.\n  \\end{cases}\n  $$\n\nAlgorithmic requirements:\n- Implement robust evaluation of B-spline basis functions and their first derivatives using a span-finding routine and a stable basis derivative algorithm.\n- Evaluate $\\mathbf{S}(u,v)$, $\\mathbf{S}_u(u,v)$, and $\\mathbf{S}_v(u,v)$ by assembling weighted sums over the nonzero basis supports and applying the quotient rule to convert from non-rational to rational derivatives.\n- Compute the unit normal $\\mathbf{\\hat n} = \\frac{\\mathbf{S}_u \\times \\mathbf{S}_v}{\\|\\mathbf{S}_u \\times \\mathbf{S}_v\\|}$ and enforce a deterministic orientation rule to avoid sign ambiguity: if the third component of $\\mathbf{\\hat n}$ is negative, flip the sign of $\\mathbf{\\hat n}$; if it is zero, require the second component to be nonnegative, and if also zero, require the first component to be nonnegative.\n- Compute plane coefficients $(a,b,c,d)$ with $(a,b,c)=\\mathbf{\\hat n}$ and $d=-\\mathbf{\\hat n}\\cdot \\mathbf{S}(u_0,v_0)$.\n- If $\\|\\mathbf{S}_u \\times \\mathbf{S}_v\\|$ is below a small tolerance (e.g., effectively zero), the plane is undefined; in that case, return four Not-a-Number values.\n\nNumerical output requirements:\n- Use the following test suite of parameter pairs $(u,v)$:\n  - Case $1$: $(u,v)=(0.3,\\,0.6)$,\n  - Case $2$: $(u,v)=(0.5,\\,0.5)$,\n  - Case $3$: $(u,v)=(0,\\,0)$,\n  - Case $4$: $(u,v)=(1,\\,1)$.\n- For each case, output the tangent plane coefficients $(a,b,c,d)$ as four floating-point numbers rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[a,b,c,d]$ for the corresponding case, with no spaces. For example:\n  $$\n  [ [a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4] ]\n  $$\n  but printed without spaces and with each number rounded to six decimal places, e.g.,\n  $[[0.123456,0.234567,0.945678,-1.234567],[\\dots],\\dots]$.\n\nAngle units are not applicable. There are no physical units. All numerical values must follow the rounding requirement described above. The final program must be self-contained, require no input, and adhere to the specified output format.",
            "solution": "The problem requires the computation of tangent plane coefficients for a Non-Uniform Rational B-Spline (NURBS) surface at specified parameter values. This is a standard problem in computational geometry and computer-aided design. The solution will be derived from first principles as stipulated.\n\nA tensor-product NURBS surface $\\mathbf{S}(u,v)$ is a rational function defined as:\n$$\n\\mathbf{S}(u,v) = \\frac{\\mathbf{A}(u,v)}{w(u,v)}\n$$\nwhere $\\mathbf{A}(u,v)$ is the weighted sum of control points, and $w(u,v)$ is the sum of weights.\n$$\n\\mathbf{A}(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) M_{j,q}(v) w_{i,j} \\mathbf{P}_{i,j}\n$$\n$$\nw(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) M_{j,q}(v) w_{i,j}\n$$\nHere, $N_{i,p}(u)$ and $M_{j,q}(v)$ are the B-spline basis functions of degrees $p$ and $q$ over knot vectors $U$ and $V$, respectively. The control points are $\\mathbf{P}_{i,j}$ and weights are $w_{i,j}$.\n\nThe tangent plane at a point $\\mathbf{S}(u_0, v_0)$ is defined by the point itself and a normal vector $\\mathbf{n}$. The normal vector is given by the cross product of the partial derivatives of the surface with respect to its parameters, $\\mathbf{S}_u$ and $\\mathbf{S}_v$.\n$$\n\\mathbf{n}(u,v) = \\mathbf{S}_u(u,v) \\times \\mathbf{S}_v(u,v)\n$$\nThe partial derivatives are found using the quotient rule for vector-valued functions:\n$$\n\\mathbf{S}_u = \\frac{\\partial}{\\partial u} \\left( \\frac{\\mathbf{A}}{w} \\right) = \\frac{\\frac{\\partial \\mathbf{A}}{\\partial u} w - \\mathbf{A} \\frac{\\partial w}{\\partial u}}{w^2} = \\frac{\\mathbf{A}_u w - \\mathbf{A} w_u}{w^2}\n$$\n$$\n\\mathbf{S}_v = \\frac{\\partial}{\\partial v} \\left( \\frac{\\mathbf{A}}{w} \\right) = \\frac{\\frac{\\partial \\mathbf{A}}{\\partial v} w - \\mathbf{A} \\frac{\\partial w}{\\partial v}}{w^2} = \\frac{\\mathbf{A}_v w - \\mathbf{A} w_v}{w^2}\n$$\nThe terms $\\mathbf{A}_u, w_u, \\mathbf{A}_v, w_v$ are the partial derivatives of the non-rational numerator and denominator components:\n$$\n\\mathbf{A}_u(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N'_{i,p}(u) M_{j,q}(v) w_{i,j} \\mathbf{P}_{i,j}\n$$\n$$\nw_u(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N'_{i,p}(u) M_{j,q}(v) w_{i,j}\n$$\nAnalogous expressions exist for $\\mathbf{A}_v$ and $w_v$ involving the derivative of the basis functions $M'_{j,q}(v)$.\n\nThe derivatives of the B-spline basis functions $N_{i,p}(u)$ are given by the standard formula, which can itself be derived from the Cox-de Boor recursion:\n$$\nN'_{i,p}(u) = \\frac{p}{U_{i+p}-U_i} N_{i,p-1}(u) - \\frac{p}{U_{i+p+1}-U_{i+1}} N_{i+1,p-1}(u)\n$$\nAgain, terms with zero denominators are taken to be zero. This formula shows that derivatives of degree-$p$ basis functions can be computed from values of degree-$(p-1)$ basis functions.\n\nThe algorithmic procedure is as follows:\n1.  **Find Span**: For a given parameter value $u$, find the knot interval $[U_k, U_{k+1})$ in which it lies. The index $k$ is the span. This localizes the computation, as only $p+1$ basis functions are non-zero over this interval.\n2.  **Evaluate Basis Functions and Derivatives**:\n    -   Implement a function to compute the values of all non-zero basis functions $N_{k-p,p}(u), \\dots, N_{k,p}(u)$ of degree $p$ using the Cox-de Boor recursion.\n    -   Implement a function to compute the first derivatives of these basis functions. This function will first call the basis function evaluation routine for degree $p-1$, and then apply the derivative formula stated above.\n3.  **Evaluate Surface Point and Derivatives**: For a given pair $(u,v)$:\n    -   Find the spans for $u$ and $v$ in their respective knot vectors $U$ and $V$.\n    -   Evaluate the basis functions and their first derivatives for both $u$ and $v$ in their relevant spans. This yields arrays of values $\\{N_i(u)\\}, \\{N'_i(u)\\}, \\{M_j(v)\\}, \\{M'_j(v)\\}$.\n    -   Compute the six necessary sums ($\\mathbf{A}, w, \\mathbf{A}_u, w_u, \\mathbf{A}_v, w_v$) by iterating over the local support of the basis functions (i.e., a $(p+1) \\times (q+1)$ block of control points).\n    -   Assemble $\\mathbf{S}(u,v)$, $\\mathbf{S}_u(u,v)$, and $\\mathbf{S}_v(u,v)$ using the quotient rule formulas.\n4.  **Compute Plane Coefficients**:\n    -   Calculate the normal vector $\\mathbf{n} = \\mathbf{S}_u \\times \\mathbf{S}_v$.\n    -   Check if its magnitude $\\|\\mathbf{n}\\|$ is close to zero. If so, the plane is ill-defined.\n    -   Normalize the vector to get the unit normal $\\mathbf{\\hat n} = \\mathbf{n} / \\|\\mathbf{n}\\|$.\n    -   Apply the specified orientation rule to ensure a unique normal vector direction. If $\\hat{n}_z  0$, flip the vector sign. If $\\hat{n}_z = 0$, ensure $\\hat{n}_y \\ge 0$. If both are zero, ensure $\\hat{n}_x \\ge 0$.\n    -   The plane coefficients are $(a,b,c,d)$, where $(a,b,c) = \\mathbf{\\hat n}$ and $d = -\\mathbf{\\hat n} \\cdot \\mathbf{S}(u,v)$.\n\nThe provided surface is of degree $p=q=2$ with $4 \\times 4$ control points $\\mathbf{P}_{i,j}$ and weights $w_{i,j}$ over open uniform knot vectors $U=V = [0, 0, 0, \\frac{1}{2}, 1, 1, 1]$. The parameter domain is $[0,1] \\times [0,1]$. Special care is taken at the boundaries of the domain ($u,v \\in \\{0,1\\}$) and at the internal knot $u=v=0.5$, though the general algorithm is robust to these cases provided correct implementation of the basis function and derivative formulas, especially the `0/0=0` convention.\n\nThe implementation will follow this principled structure, building from basis function evaluation up to the final plane equation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define the NURBS surface, compute tangent planes for test cases,\n    and print the results in the specified format.\n    \"\"\"\n\n    # --- Surface Specification ---\n    p = 2  # Degree in u\n    q = 2  # Degree in v\n    U = np.array([0., 0., 0., 0.5, 1., 1., 1.])  # Knot vector in u\n    V = np.array([0., 0., 0., 0.5, 1., 1., 1.])  # Knot vector in v\n\n    n = len(U) - p - 2  # Number of control points in u is n+1 = 4\n    m = len(V) - q - 2  # Number of control points in v is m+1 = 4\n\n    # Procedurally generate control points P_ij\n    P = np.zeros((n + 1, m + 1, 3))\n    for i in range(n + 1):\n        for j in range(m + 1):\n            x = float(i)\n            y = float(j)\n            z = 0.2 * (i - 1.5)**2 + 0.1 * (j - 1.5)**2\n            P[i, j] = [x, y, z]\n\n    # Procedurally generate weights w_ij\n    W = np.ones((n + 1, m + 1))\n    W[1:3, 1:3] = 2.0\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.3, 0.6),\n        (0.5, 0.5),\n        (0.0, 0.0),\n        (1.0, 1.0),\n    ]\n\n    results = []\n    for u_eval, v_eval in test_cases:\n        coeffs = compute_plane_coeffs(u_eval, v_eval, p, q, U, V, P, W)\n        results.append(coeffs)\n\n    # --- Format and Print Output ---\n    result_str_parts = []\n    for res in results:\n        if np.isnan(res[0]):\n            part = '[nan,nan,nan,nan]'\n        else:\n            part = '[' + ','.join([f\"{x:.6f}\" for x in res]) + ']'\n        result_str_parts.append(part)\n    \n    print(f\"[{','.join(result_str_parts)}]\")\n\ndef find_span(u, p, U):\n    \"\"\"\n    Find the knot span index i such that U_i = u  U_{i+1}.\n    n is the number of control points minus 1.\n    \"\"\"\n    n = len(U) - p - 2\n    if u == U[n + 1]:\n        return n\n    \n    # Binary search for the span\n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    while u  U[mid] or u = U[mid + 1]:\n        if u  U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef basis_funs(span, u, p, U):\n    \"\"\"\n    Compute the non-zero B-spline basis functions for a given span.\n    Uses the Cox-de Boor recursion.\n    Returns: A (p+1) element array with N_{span-p,p}(u), ..., N_{span,p}(u)\n    \"\"\"\n    N = np.zeros(p + 1)\n    left = np.zeros(p + 1)\n    right = np.zeros(p + 1)\n    N[0] = 1.0\n\n    for j in range(1, p + 1):\n        left[j] = u - U[span + 1 - j]\n        right[j] = U[span + j] - u\n        saved = 0.0\n        for r in range(j):\n            den = right[r + 1] + left[j - r]\n            temp = 0.0\n            if den != 0.0:\n                temp = N[r] / den\n            N[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        N[j] = saved\n    return N\n\ndef ders_basis_funs(span, u, p, U):\n    \"\"\"\n    Compute derivatives of B-spline basis functions.\n    Returns: A (p+1) element array with the first derivatives.\n    \"\"\"\n    if p == 0:\n        return np.zeros(1)\n        \n    N_prev = basis_funs(span, u, p - 1, U)\n    ders = np.zeros(p + 1)\n    \n    for j in range(p + 1):\n        i = span - p + j\n        term1 = 0.0\n        den1 = U[i + p] - U[i]\n        if den1 != 0.0 and j  0:\n            term1 = N_prev[j - 1] / den1\n\n        term2 = 0.0\n        den2 = U[i + p + 1] - U[i + 1]\n        if den2 != 0.0 and j  p:\n            term2 = N_prev[j] / den2\n        \n        ders[j] = p * (term1 - term2)\n        \n    return ders\n\ndef surface_pt_and_ders(u, v, p, q, U, V, P, W):\n    \"\"\"\n    Computes the surface point S(u,v) and its first partial derivatives S_u, S_v.\n    \"\"\"\n    n = len(U) - p - 2\n    m = len(V) - q - 2\n\n    u_span = find_span(u, p, U)\n    v_span = find_span(v, q, V)\n    \n    Nu = basis_funs(u_span, u, p, U)\n    Nv = basis_funs(v_span, v, q, V)\n    \n    dNu = ders_basis_funs(u_span, u, p, U)\n    dNv = ders_basis_funs(v_span, v, q, V)\n\n    S_num = np.zeros(3)\n    S_den = 0.0\n    Su_num = np.zeros(3)\n    Su_den = 0.0\n    Sv_num = np.zeros(3)\n    Sv_den = 0.0\n\n    for i in range(p + 1):\n        for j in range(q + 1):\n            ii = u_span - p + i\n            jj = v_span - q + j\n            \n            w_ij = W[ii, jj]\n            P_ij = P[ii, jj]\n            \n            temp = Nu[i] * Nv[j] * w_ij\n            S_num += temp * P_ij\n            S_den += temp\n            \n            temp_u = dNu[i] * Nv[j] * w_ij\n            Su_num += temp_u * P_ij\n            Su_den += temp_u\n            \n            temp_v = Nu[i] * dNv[j] * w_ij\n            Sv_num += temp_v * P_ij\n            Sv_den += temp_v\n\n    if S_den == 0.0:\n        return np.full(3, np.nan), np.full(3, np.nan), np.full(3, np.nan)\n\n    S = S_num / S_den\n    Su = (Su_num * S_den - S_num * Su_den) / (S_den**2)\n    Sv = (Sv_num * S_den - S_num * Sv_den) / (S_den**2)\n\n    return S, Su, Sv\n\ndef compute_plane_coeffs(u, v, p, q, U, V, P, W):\n    \"\"\"\n    Computes the tangent plane coefficients (a, b, c, d) for the NURBS surface.\n    \"\"\"\n    S, Su, Sv = surface_pt_and_ders(u, v, p, q, U, V, P, W)\n    if np.any(np.isnan(S)):\n        return [np.nan, np.nan, np.nan, np.nan]\n\n    normal = np.cross(Su, Sv)\n    norm_mag = np.linalg.norm(normal)\n    \n    tolerance = 1e-12\n    if norm_mag  tolerance:\n        return [np.nan, np.nan, np.nan, np.nan]\n\n    n_hat = normal / norm_mag\n\n    # Deterministic orientation rule\n    if n_hat[2]  0.0:\n        n_hat = -n_hat\n    elif abs(n_hat[2])  tolerance:\n        if n_hat[1]  0.0:\n            n_hat = -n_hat\n        elif abs(n_hat[1])  tolerance:\n            if n_hat[0]  0.0:\n                n_hat = -n_hat\n    \n    a, b, c = n_hat\n    d = -np.dot(n_hat, S)\n\n    return [a, b, c, d]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}