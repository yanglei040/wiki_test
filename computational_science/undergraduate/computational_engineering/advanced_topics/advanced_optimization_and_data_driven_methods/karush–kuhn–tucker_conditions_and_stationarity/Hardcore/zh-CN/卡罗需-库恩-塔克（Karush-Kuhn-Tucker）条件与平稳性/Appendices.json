{
    "hands_on_practices": [
        {
            "introduction": "掌握 Karush-Kuhn-Tucker (KKT) 条件的第一步是在一个简单的场景中理解其各个组成部分如何协同工作。这个练习旨在通过一个单变量的二次优化问题，清晰地展示平庸性、原始可行性、对偶可行性和互补松弛性这四个核心条件。通过解决这个问题，你将为处理更复杂的约束优化问题打下坚实的基础。",
            "id": "2167418",
            "problem": "在一个简化的机器学习场景中，与模型参数 $x$ 相关的成本由二次函数 $f(x) = \\frac{1}{2}x^2$ 描述。为防止欠拟合并确保模型具有最低程度的复杂度，一位领域专家施加了一个约束，即参数 $x$ 必须至少为 2。这导致了一个约束优化问题。\n\n此问题的拉格朗日函数定义为 $L(x, \\lambda) = f(x) + \\lambda g(x)$，其中 $g(x) \\le 0$ 代表不等式约束，且 $\\lambda \\ge 0$ 是拉格朗日乘子。\n\n你的任务是找到拉格朗日函数的鞍点 $(x^*, \\lambda^*)$。该点对应于在满足约束条件下最小化成本函数的最优参数值 $x^*$，以及相关的最优拉格朗日乘子 $\\lambda^*$。\n\n将鞍点以有序对 $(x^*, \\lambda^*)$ 的形式报告。",
            "solution": "给定凸二次目标函数 $f(x) = \\frac{1}{2}x^{2}$ 和不等式约束 $x \\geq 2$。为了将其表示为标准形式 $g(x) \\leq 0$，定义 $g(x) = 2 - x$，因此约束为 $g(x) \\leq 0$。拉格朗日函数为\n$$\nL(x, \\lambda) = \\frac{1}{2}x^{2} + \\lambda(2 - x),\n$$\n对偶可行性要求 $\\lambda \\geq 0$。\n\n对于带有仿射约束的凸问题，Karush–Kuhn–Tucker (KKT) 条件是确定最优性和刻画鞍点的充要条件。KKT 条件如下：\n- 原始可行性：$g(x^{*}) \\leq 0$，即 $x^{*} \\geq 2$。\n- 对偶可行性：$\\lambda^{*} \\geq 0$。\n- 平稳性：$\\frac{\\partial L}{\\partial x}(x^{*}, \\lambda^{*}) = 0$。\n- 互补松弛性：$\\lambda^{*} g(x^{*}) = 0$。\n\n计算平稳性条件：\n$$\n\\frac{\\partial L}{\\partial x} = x - \\lambda \\quad \\Rightarrow \\quad x^{*} - \\lambda^{*} = 0 \\quad \\Rightarrow \\quad x^{*} = \\lambda^{*}.\n$$\n应用互补松弛性：\n$$\n\\lambda^{*}(2 - x^{*}) = 0.\n$$\n分情况讨论：\n- 如果 $\\lambda^{*} = 0$，则由平稳性条件可知 $x^{*} = 0$，这违反了原始可行性 $x^{*} \\geq 2$；因此排除此种情况。\n- 因此必有 $2 - x^{*} = 0 \\Rightarrow x^{*} = 2$。再由平稳性条件可知 $\\lambda^{*} = x^{*} = 2$，这满足 $\\lambda^{*} \\geq 0$ 和 $x^{*} \\geq 2$。\n\n因此，唯一的 KKT 点是 $(x^{*}, \\lambda^{*}) = (2, 2)$。因为该问题是带有仿射约束的凸问题，所以这个 KKT 点就是拉格朗日函数的鞍点。等价地，验证鞍点性质：$L(x, 2)$ 在 $x = 2$ 处取得最小值，且对于所有 $\\lambda \\geq 0$ 都有 $L(2, \\lambda) = 2$，其对偶最大值点为 $\\lambda^{*} = 2$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2  2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基础知识后，我们可以将 KKT 条件应用到更具挑战性的多维问题中。这个练习要求你找到一个点在第一象限内（一个由多个不等式约束定义的凸集）的最近点，这是一个具有直观几何意义的优化问题。它将训练你如何系统地、分量化地运用互补松弛性条件来判断在最优解处哪些约束是“激活”的，这是求解许多工程和机器学习问题的关键技巧。",
            "id": "2407313",
            "problem": "设 $p \\in \\mathbb{R}^{3}$ 为点 $p = (-1,-2,3)$。考虑在第一卦限中寻找点 $x \\in \\mathbb{R}^{3}$，使其在欧几里得意义下最接近点 $p$。将此问题表述为约束优化问题\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\; \\frac{1}{2}\\|x - p\\|_{2}^{2} \\quad \\text{subject to} \\quad x_{i} \\ge 0 \\text{ for } i=1,2,3.\n$$\n确定 Karush–Kuhn–Tucker (KKT) 点 $(x^{\\star},\\lambda^{\\star})$，其中 $\\lambda^{\\star} \\in \\mathbb{R}^{3}$ 是与不等式约束相关的拉格朗日乘子。以单一行向量 $(x_{1}^{\\star},x_{2}^{\\star},x_{3}^{\\star},\\lambda_{1}^{\\star},\\lambda_{2}^{\\star},\\lambda_{3}^{\\star})$ 的形式给出您的最终答案。无需四舍五入。",
            "solution": "我们需要在第一卦限约束下，最小化从 $x$ 到 $p$ 的欧氏距离的平方。该优化问题为\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\; f(x) = \\frac{1}{2}\\|x - p\\|_{2}^{2} \\quad \\text{subject to} \\quad x_{i} \\ge 0 \\text{ for } i=1,2,3,\n$$\n其中 $p = (-1,-2,3)$。我们通过定义将不等式约束表示为标准形式 $g_{i}(x) \\le 0$\n$$\ng_{i}(x) = -x_{i} \\le 0, \\quad i=1,2,3.\n$$\n拉格朗日函数 $L:\\mathbb{R}^{3} \\times \\mathbb{R}^{3} \\to \\mathbb{R}$ 为\n$$\nL(x,\\lambda) = \\frac{1}{2}\\|x - p\\|_{2}^{2} + \\sum_{i=1}^{3} \\lambda_{i} g_{i}(x) = \\frac{1}{2}\\|x - p\\|_{2}^{2} - \\lambda^{\\top} x,\n$$\n其中 $\\lambda \\in \\mathbb{R}^{3}$ 是拉格朗日乘子。Karush–Kuhn–Tucker (KKT) 条件包括：\n1. 驻点条件 (Stationarity):\n$$\n\\nabla_{x} L(x,\\lambda) = x - p - \\lambda = 0 \\;\\; \\Longrightarrow \\;\\; \\lambda = x - p.\n$$\n2. 原始可行性 (Primal feasibility):\n$$\nx_{i} \\ge 0, \\quad i=1,2,3.\n$$\n3. 对偶可行性 (Dual feasibility):\n$$\n\\lambda_{i} \\ge 0, \\quad i=1,2,3.\n$$\n4. 互补松弛性 (Complementary slackness):\n$$\n\\lambda_{i} \\, x_{i} = 0, \\quad i=1,2,3.\n$$\n将 $p = (-1,-2,3)$ 代入驻点关系式 $\\lambda = x - p$，分量形式为\n$$\n\\lambda_{1} = x_{1} + 1, \\quad \\lambda_{2} = x_{2} + 2, \\quad \\lambda_{3} = x_{3} - 3.\n$$\n现在我们对每个坐标强制执行互补松弛性和可行性。\n\n对于 $i=1$：\n- 如果 $x_{1} > 0$，则 $\\lambda_{1} = 0$，这意味着 $x_{1} + 1 = 0 \\Rightarrow x_{1} = -1$，与 $x_{1} > 0$ 矛盾。\n- 因此，$x_{1} = 0$，于是 $\\lambda_{1} = 0 + 1 = 1 \\ge 0$。\n\n对于 $i=2$：\n- 如果 $x_{2} > 0$，则 $\\lambda_{2} = 0$，这意味着 $x_{2} + 2 = 0 \\Rightarrow x_{2} = -2$，与 $x_{2} > 0$ 矛盾。\n- 因此，$x_{2} = 0$，于是 $\\lambda_{2} = 0 + 2 = 2 \\ge 0$。\n\n对于 $i=3$：\n- 如果 $x_{3} > 0$，则 $\\lambda_{3} = 0$，这意味着 $x_{3} - 3 = 0 \\Rightarrow x_{3} = 3$，与 $x_{3} > 0$ 一致。\n- 这个选择满足互补松弛性，因为 $\\lambda_{3} x_{3} = 0 \\cdot 3 = 0$，并且满足对偶可行性，因为 $\\lambda_{3} = 0 \\ge 0$。\n\n综合各分量，唯一的 KKT 点是\n$$\nx^{\\star} = (0,0,3), \\quad \\lambda^{\\star} = (1,2,0).\n$$\n因为目标函数是严格凸的，且可行集是凸集，所以这些 KKT 条件是全局最优的充分条件，这证实了 $(x^{\\star},\\lambda^{\\star})$ 是该问题的 KKT 点。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  0  3  1  2  0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "将理论知识转化为实际应用是工程学教育的核心。这个练习将引导你从数学理论走向计算实践，通过编写一个函数来程序化地验证给定解是否满足 KKT 条件。这项任务不仅能巩固你对 KKT 各个条件的精确理解，还能让你体会到在处理数值计算时引入容差的重要性，这是在实际优化算法开发中的一个基本环节。",
            "id": "2407334",
            "problem": "给定一个具体的非线性优化问题，要求您实现一个程序化验证器，用于检验 Karush–Kuhn–Tucker (KKT) 最优性条件。考虑以下计算工程形式的最小化问题：最小化目标函数 $f(x) = (x_1 - 1)^2 + (x_2 - 2)^2$，约束条件为不等式约束 $g_1(x) = x_1 + x_2 - 2 \\le 0$、$g_2(x) = -x_1 \\le 0$、$g_3(x) = -x_2 \\le 0$ 和等式约束 $h_1(x) = x_1 - x_2 = 0$，其中 $x \\in \\mathbb{R}^2$。令 $\\lambda \\in \\mathbb{R}^3$ 表示不等式约束的拉格朗日乘子向量，$\\mu \\in \\mathbb{R}$ 表示等式约束的乘子。KKT 验证必须包括四个典型部分：原始可行性、对偶可行性、互补松弛性和平稳性。对平稳性残差使用欧几里得向量范数，并在规定的容差 $\\epsilon > 0$ 内执行所有检查。\n\n您的任务是编写一个完整的程序，实现一个名为 check_kkt(x, lam, mu, eps) 的函数。该函数返回一个布尔值，指示给定的三元组 $(x, \\lambda, \\mu)$ 是否在容差 $\\epsilon$ 内满足指定问题的 KKT 条件。该函数必须执行以下检查：\n- 原始可行性：所有不等式约束满足 $g_i(x) \\le \\epsilon$，所有等式约束满足 $|h_j(x)| \\le \\epsilon$。\n- 对偶可行性：所有不等式约束的乘子满足 $\\lambda_i \\ge -\\epsilon$。\n- 互补松弛性：所有乘积满足 $|\\lambda_i \\, g_i(x)| \\le \\epsilon$。\n- 平稳性：拉格朗日函数梯度的欧几里得范数满足 $\\|\\nabla f(x) + \\sum_{i=1}^{3} \\lambda_i \\nabla g_i(x) + \\mu \\nabla h_1(x)\\|_2 \\le \\epsilon$。\n\n此问题的梯度为：\n- $\\nabla f(x) = \\big(2(x_1 - 1), \\, 2(x_2 - 2)\\big)$，\n- $\\nabla g_1(x) = (1, \\, 1)$, $\\nabla g_2(x) = (-1, \\, 0)$, $\\nabla g_3(x) = (0, \\, -1)$，\n- $\\nabla h_1(x) = (1, \\, -1)$。\n\n您的程序必须对以下输入测试套件评估 `check_kkt` 函数，并汇总布尔结果。对于每个测试用例，$x$ 是一个长度为 2 的实数数组，$\\lambda$ 是一个长度为 3 的实数数组，$\\mu$ 是一个实数标量，$\\epsilon$ 是一个正实数标量：\n- 测试用例 1 (典型 KKT 点): $x = [1, 1]$, $\\lambda = [1, 0, 0]$, $\\mu = -1$, $\\epsilon = 10^{-8}$。预期：True。\n- 测试用例 2 (平稳性条件不满足): $x = [1, 1]$, $\\lambda = [0.5, 0, 0]$, $\\mu = -0.5$, $\\epsilon = 10^{-8}$。预期：False。\n- 测试用例 3 (原始不可行): $x = [1.2, 1.2]$, $\\lambda = [1, 0, 0]$, $\\mu = -1$, $\\epsilon = 10^{-8}$。预期：False。\n- 测试用例 4 (在容差内的近似 KKT 点): $x = [1, 1 + 10^{-7}]$, $\\lambda = [1, -10^{-7}, 0]$, $\\mu = -1 - 10^{-7}$, $\\epsilon = 10^{-6}$。预期：True。\n- 测试用例 5 (互补松弛性条件不满足): $x = [1, 1]$, $\\lambda = [1, 0.1, 0]$, $\\mu = -1$, $\\epsilon = 10^{-8}$。预期：False。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[True,False,True,False,True]”）。不得打印任何其他文本。不涉及物理单位。不涉及角度。不涉及百分比。唯一可接受的输出类型是按规定汇总的布尔值。",
            "solution": "所提供的问题经过了严格的验证，被认为是有效的。这是一个来自计算工程领域的适定、有科学依据的问题，具体涉及非线性优化问题的 Karush-Kuhn-Tucker (KKT) 最优性条件的验证。所有函数、变量和条件都已明确定义，任务是实现一个数值验证器。\n\n该问题是在一组不等式和等式约束下最小化目标函数 $f(x)$。这是一个标准的非线性规划 (NLP) 问题，其形式如下：\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  f(x) \\\\\n\\text{subject to} \\quad  g_i(x) \\le 0, \\quad i = 1, \\dots, m \\\\\n h_j(x) = 0, \\quad j = 1, \\dots, p\n\\end{aligned}\n$$\n对于所提供的具体案例：\n-   目标函数：$f(x) = (x_1 - 1)^2 + (x_2 - 2)^2$ 其中 $x = (x_1, x_2) \\in \\mathbb{R}^2$。\n-   不等式约束 ($m=3$)：\n    -   $g_1(x) = x_1 + x_2 - 2 \\le 0$\n    -   $g_2(x) = -x_1 \\le 0$\n    -   $g_3(x) = -x_2 \\le 0$\n-   等式约束 ($p=1$)：\n    -   $h_1(x) = x_1 - x_2 = 0$\n\nKarush-Kuhn-Tucker 条件是 NLP 中的一个解为最优解的一阶必要条件，前提是满足某些正则性条件。为了陈述这些条件，我们首先引入与该问题相关的拉格朗日函数 $L(x, \\lambda, \\mu)$：\n$$\nL(x, \\lambda, \\mu) = f(x) + \\sum_{i=1}^{m} \\lambda_i g_i(x) + \\sum_{j=1}^{p} \\mu_j h_j(x)\n$$\n其中 $\\lambda = (\\lambda_1, \\dots, \\lambda_m)$ 是不等式约束的拉格朗日乘子（也称为对偶变量），$\\mu = (\\mu_1, \\dots, \\mu_p)$ 是等式约束的乘子。\n\n对于给定的问题，拉格朗日函数为：\n$$\nL(x, \\lambda, \\mu) = (x_1 - 1)^2 + (x_2 - 2)^2 + \\lambda_1(x_1 + x_2 - 2) + \\lambda_2(-x_1) + \\lambda_3(-x_2) + \\mu_1(x_1 - x_2)\n$$\n由于只有一个等式约束，我们将其乘子表示为 $\\mu$。一个点 $(x^*, \\lambda^*, \\mu^*)$ 成为最优候选点的 KKT 条件是：\n\n1.  **原始可行性**：点 $x^*$ 必须满足所有原始约束。\n    -   $g_i(x^*) \\le 0$ for $i \\in \\{1, 2, 3\\}$\n    -   $h_1(x^*) = 0$\n2.  **对偶可行性**：不等式约束的拉格朗日乘子必须为非负数。\n    -   $\\lambda_i^* \\ge 0$ for $i \\in \\{1, 2, 3\\}$\n3.  **互补松弛性**：对于每个不等式约束，要么该约束是激活的（即等式成立），要么其对应的乘子为零。\n    -   $\\lambda_i^* g_i(x^*) = 0$ for $i \\in \\{1, 2, 3\\}$\n4.  **平稳性**：拉格朗日函数相对于原始变量 $x$ 的梯度在点 $(x^*, \\lambda^*, \\mu^*)$ 处必须为零。\n    -   $\\nabla_x L(x^*, \\lambda^*, \\mu^*) = 0$\n\n对于数值验证，这些精确条件必须使用一个小的正容差 $\\epsilon$ 进行放宽。程序化检查的结构如下：\n\n-   **原始可行性检查**：\n    -   $g_i(x) \\le \\epsilon$ for $i \\in \\{1, 2, 3\\}$\n    -   $|h_1(x)| \\le \\epsilon$\n-   **对偶可行性检查**：\n    -   $\\lambda_i \\ge -\\epsilon$ for $i \\in \\{1, 2, 3\\}$。这允许出现数值上为零的微小负值。\n-   **互补松弛性检查**：\n    -   $|\\lambda_i g_i(x)| \\le \\epsilon$ for $i \\in \\{1, 2, 3\\}$。\n-   **平稳性检查**：\n    拉格朗日函数关于 $x$ 的梯度是：\n    $$\n    \\nabla_x L(x, \\lambda, \\mu) = \\nabla f(x) + \\sum_{i=1}^{3} \\lambda_i \\nabla g_i(x) + \\mu \\nabla h_1(x)\n    $$\n    代入给定的梯度：\n    -   $\\nabla f(x) = (2(x_1 - 1), 2(x_2 - 2))$\n    -   $\\nabla g_1(x) = (1, 1)$, $\\nabla g_2(x) = (-1, 0)$, $\\nabla g_3(x) = (0, -1)$\n    -   $\\nabla h_1(x) = (1, -1)$\n    拉格朗日梯度的分量是：\n    $$\n    \\frac{\\partial L}{\\partial x_1} = 2(x_1 - 1) + \\lambda_1(1) + \\lambda_2(-1) + \\lambda_3(0) + \\mu(1) = 2(x_1 - 1) + \\lambda_1 - \\lambda_2 + \\mu\n    $$\n    $$\n    \\frac{\\partial L}{\\partial x_2} = 2(x_2 - 2) + \\lambda_1(1) + \\lambda_2(0) + \\lambda_3(-1) + \\mu(-1) = 2(x_2 - 2) + \\lambda_1 - \\lambda_3 - \\mu\n    $$\n    那么平稳性条件就是这个梯度向量的欧几里得范数（称为平稳性残差）必须接近于零：\n    $$\n    \\|\\nabla_x L(x, \\lambda, \\mu)\\|_2 \\le \\epsilon\n    $$\n\n实现的函数 `check_kkt` 将系统地执行这四项检查。如果任何一项检查失败，函数立即返回 `False`。如果所有检查都通过，则返回 `True`。\n\n让我们用第一个测试用例来演示：$x = [1, 1]$, $\\lambda = [1, 0, 0]$, $\\mu = -1$，以及 $\\epsilon = 10^{-8}$。\n-   变量：$x_1 = 1$, $x_2 = 1$, $\\lambda_1 = 1$, $\\lambda_2 = 0$, $\\lambda_3 = 0$, $\\mu = -1$。\n\n-   **原始可行性**：\n    -   $g_1(x) = 1 + 1 - 2 = 0$。$0 \\le 10^{-8}$ 为真。\n    -   $g_2(x) = -1$。$-1 \\le 10^{-8}$ 为真。\n    -   $g_3(x) = -1$。$-1 \\le 10^{-8}$ 为真。\n    -   $h_1(x) = 1 - 1 = 0$。$|0| \\le 10^{-8}$ 为真。\n    条件满足。\n\n-   **对偶可行性**：\n    -   $\\lambda_1 = 1 \\ge -10^{-8}$ 为真。\n    -   $\\lambda_2 = 0 \\ge -10^{-8}$ 为真。\n    -   $\\lambda_3 = 0 \\ge -10^{-8}$ 为真。\n    条件满足。\n\n-   **互补松弛性**：\n    -   $|\\lambda_1 g_1(x)| = |1 \\cdot 0| = 0$。$0 \\le 10^{-8}$ 为真。\n    -   $|\\lambda_2 g_2(x)| = |0 \\cdot (-1)| = 0$。$0 \\le 10^{-8}$ 为真。\n    -   $|\\lambda_3 g_3(x)| = |0 \\cdot (-1)| = 0$。$0 \\le 10^{-8}$ 为真。\n    条件满足。\n\n-   **平稳性**：\n    -   $\\frac{\\partial L}{\\partial x_1} = 2(1 - 1) + 1 - 0 + (-1) = 0$。\n    -   $\\frac{\\partial L}{\\partial x_2} = 2(1 - 2) + 1 - 0 - (-1) = -2 + 1 + 1 = 0$。\n    -   梯度向量为 $(0, 0)$。\n    -   $\\|\\nabla_x L\\|_2 = \\sqrt{0^2 + 0^2} = 0$。$0 \\le 10^{-8}$ 为真。\n    条件满足。\n\n由于所有四个条件都在容差 $\\epsilon$ 内得到满足，点 $(x, \\lambda, \\mu)$ 是一个有效的 KKT 点，函数正确返回 `True`。其他测试用例也以类似方式进行评估，程序将汇总布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_kkt(x, lam, mu, eps):\n    \"\"\"\n    Verifies the KKT conditions for a given point (x, lam, mu).\n\n    Args:\n        x (np.ndarray): Primal variables, a 2-element array [x1, x2].\n        lam (np.ndarray): Lagrange multipliers for inequality constraints, a 3-element array [lam1, lam2, lam3].\n        mu (float): Lagrange multiplier for the equality constraint.\n        eps (float): Tolerance for all numerical checks.\n\n    Returns:\n        bool: True if the KKT conditions are satisfied, False otherwise.\n    \"\"\"\n    x1, x2 = x[0], x[1]\n    lam1, lam2, lam3 = lam[0], lam[1], lam[2]\n\n    # --- 1. Primal Feasibility ---\n    # g1(x) = x1 + x2 - 2 = 0\n    g1 = x1 + x2 - 2\n    if g1 > eps:\n        return False\n\n    # g2(x) = -x1 = 0\n    g2 = -x1\n    if g2 > eps:\n        return False\n\n    # g3(x) = -x2 = 0\n    g3 = -x2\n    if g3 > eps:\n        return False\n\n    # h1(x) = x1 - x2 = 0\n    h1 = x1 - x2\n    if abs(h1) > eps:\n        return False\n        \n    # --- 2. Dual Feasibility ---\n    # lam_i >= 0 for all i\n    if np.any(lam  -eps):\n        return False\n\n    # --- 3. Complementary Slackness ---\n    # lam1 * g1(x) = 0\n    if abs(lam1 * g1) > eps:\n        return False\n\n    # lam2 * g2(x) = 0\n    if abs(lam2 * g2) > eps:\n        return False\n\n    # lam3 * g3(x) = 0\n    if abs(lam3 * g3) > eps:\n        return False\n\n    # --- 4. Stationarity ---\n    # Gradient of the Lagrangian with respect to x must be zero.\n    # grad_L_x1 = 2*(x1 - 1) + lam1 - lam2 + mu\n    # grad_L_x2 = 2*(x2 - 2) + lam1 - lam3 - mu\n    grad_L_x1 = 2 * (x1 - 1) + lam1 - lam2 + mu\n    grad_L_x2 = 2 * (x2 - 2) + lam1 - lam3 - mu\n    \n    grad_L = np.array([grad_L_x1, grad_L_x2])\n    \n    # Check the Euclidean norm of the gradient\n    stationarity_residual = np.linalg.norm(grad_L)\n    \n    if stationarity_residual > eps:\n        return False\n        \n    # If all conditions pass\n    return True\n\ndef solve():\n    \"\"\"\n    Executes the KKT verification for a predefined suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (canonical KKT point)\n        {'x': np.array([1.0, 1.0]), 'lam': np.array([1.0, 0.0, 0.0]), 'mu': -1.0, 'eps': 1e-8},\n        # Test case 2 (stationarity violated)\n        {'x': np.array([1.0, 1.0]), 'lam': np.array([0.5, 0.0, 0.0]), 'mu': -0.5, 'eps': 1e-8},\n        # Test case 3 (primal infeasible)\n        {'x': np.array([1.2, 1.2]), 'lam': np.array([1.0, 0.0, 0.0]), 'mu': -1.0, 'eps': 1e-8},\n        # Test case 4 (near-KKT within tolerance)\n        {'x': np.array([1.0, 1.0 + 1e-7]), 'lam': np.array([1.0, -1e-7, 0.0]), 'mu': -1.0 - 1e-7, 'eps': 1e-6},\n        # Test case 5 (complementary slackness violated)\n        {'x': np.array([1.0, 1.0]), 'lam': np.array([1.0, 0.1, 0.0]), 'mu': -1.0, 'eps': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_kkt(case['x'], case['lam'], case['mu'], case['eps'])\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}