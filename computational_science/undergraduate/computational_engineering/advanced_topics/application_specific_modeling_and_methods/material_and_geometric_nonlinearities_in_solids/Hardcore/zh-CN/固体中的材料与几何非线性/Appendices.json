{
    "hands_on_practices": [
        {
            "introduction": "材料非线性的理论概念需要通过计算实践来真正掌握。本练习聚焦于塑性，一种常见的路径依赖材料行为。你将亲手实现“返回映射”算法，这是一种用于更新弹塑性材料应力状态的基本数值方法，也是现代仿真软件的基石之一。通过这个练习，你将深入理解材料状态如何随加载历史演化。",
            "id": "2411414",
            "problem": "实现一维隐式后向欧拉应力更新，用于带各向同性硬化（径向返回映射）的率无关 von Mises 塑性模型，适用于小应变单轴加载。从固体力学基本定律开始。该实现必须使用后向欧拉时间离散化，为单个应变增量更新应力和内部变量。您的程序必须是自包含的，并为每个提供的测试用例计算更新后的应力、塑性应变、累积塑性应变以及一致算法切线模量。\n\n假设和定义：\n- 小应变运动学。总应变表示为 $\\,\\varepsilon\\,$，塑性应变表示为 $\\,\\varepsilon^{p}\\,$，累积塑性应变表示为 $\\,\\alpha\\,$。\n- 一维线性弹性本构关系，杨氏模量为 $\\,E\\,$：$\\,\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)\\,$，其中 $\\,\\sigma\\,$ 是 Cauchy 应力。\n- 各向同性硬化，具有常数硬化模量 $\\,H \\ge 0\\,$ 和初始屈服应力 $\\,\\sigma_{y0} > 0\\,$。当前屈服应力为 $\\,\\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\,\\alpha\\,$。\n- 专用于一维的 von Mises 屈服函数：$\\,f(\\sigma,\\alpha)=|\\sigma|-\\sigma_{y}(\\alpha)\\,$，其容许性条件为 $\\,f \\le 0\\,$。\n- 关联流动与一致性。一维塑性流动方向是 $\\,\\sigma\\,$ 的符号。\n\n离散化目标：\n- 给定材料参数 $\\,E\\,$（单位为 $\\mathrm{Pa}$）、$\\,H\\,$（单位为 $\\mathrm{Pa}$）和 $\\,\\sigma_{y0}\\,$（单位为 $\\mathrm{Pa}$），以及第 $\\,n\\,$ 步的状态，包括 $\\,\\varepsilon^{p}_{n}\\,$ 和 $\\,\\alpha_{n}\\,$（均为无量纲），以及在第 $\\,n+1\\,$ 步给定的总应变 $\\,\\varepsilon_{n+1}\\,$（无量纲），使用隐式后向欧拉返回映射格式计算更新后的值 $\\,\\sigma_{n+1}\\,$（单位为 $\\mathrm{Pa}$）、$\\,\\varepsilon^{p}_{n+1}\\,$（无量纲）、$\\,\\alpha_{n+1}\\,$（无量纲）以及一致算法切线模量 $\\,E_{\\mathrm{tan},\\,n+1}\\,$（单位为 $\\mathrm{Pa}$）。\n\n数值要求：\n- 您的算法必须实现一个弹性试探状态，并且如果试探状态违反容许性，则需向屈服面进行径向返回。使用数值上稳健的方法处理屈服条件，以决定弹性与塑性响应。\n- 不出现角度；无需角度单位。\n- 所有应力必须以 $\\mathrm{Pa}$ 表示，应变为无量纲。\n\n测试套件：\n对于每个测试，输入元组为 $\\,\\left(E,\\,H,\\,\\sigma_{y0},\\,\\varepsilon_{n+1},\\,\\varepsilon^{p}_{n},\\,\\alpha_{n}\\right)\\,$。您的程序必须计算输出 $\\,\\left[\\sigma_{n+1},\\,\\varepsilon^{p}_{n+1},\\,\\alpha_{n+1},\\,E_{\\mathrm{tan},\\,n+1}\\right]\\,$。\n\n提供以下六个测试用例的结果：\n1. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n2. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.25\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n3. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n4. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=3.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n5. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=-5.0\\times 10^{-4},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n6. $\\,\\left( E=100\\times 10^{9}\\,\\mathrm{Pa},\\; H=0,\\; \\sigma_{y0}=100\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为列表的列表：\n  $\\,\\bigl[\\,[\\sigma_{1},\\,\\varepsilon^{p}_{1},\\,\\alpha_{1},\\,E_{\\mathrm{tan},1}],\\;[\\sigma_{2},\\,\\varepsilon^{p}_{2},\\,\\alpha_{2},\\,E_{\\mathrm{tan},2}],\\;\\dotsc,\\;[\\sigma_{6},\\,\\varepsilon^{p}_{6},\\,\\alpha_{6},\\,E_{\\mathrm{tan},6}]\\,\\bigr]\\,$\n- 每个 $\\,\\sigma_{i}\\,$ 和 $\\,E_{\\mathrm{tan},i}\\,$ 必须以 $\\mathrm{Pa}$ 为单位，$\\,\\varepsilon^{p}_{i}\\,$ 和 $\\,\\alpha_{i}\\,$ 必须是无量纲的。输出中不应包含任何文本或单位；必须只打印数值列表。",
            "solution": "所述问题是有效的。这是一个来自计算固体力学领域的适定的、有科学依据的问题，并提供了所有必要的信息。我们将进行推导和求解。\n\n该问题要求实现一个隐式、一维、率无关的带各向同性硬化的弹塑性模型。任务的核心是使用后向欧拉方法（一种通常称为径向返回映射算法的技术）为单个时间增量执行应力更新过程。\n\n**$1$. 基本本构方程**\n\n我们首先以连续的、率形式陈述一维模型的控制方程。\n\n- **应变分解**：总应变 $\\varepsilon$ 被加法分解为弹性部分 $\\varepsilon^{e}$ 和塑性部分 $\\varepsilon^{p}$：\n$$ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $$\n其率形式为：\n$$ \\dot{\\varepsilon} = \\dot{\\varepsilon}^{e} + \\dot{\\varepsilon}^{p} $$\n\n- **弹性定律**：应力 $\\sigma$ 通过线性弹性（Hooke）定律与弹性应变相关，杨氏模量为 $E$：\n$$ \\sigma = E \\varepsilon^{e} = E (\\varepsilon - \\varepsilon^{p}) $$\n其率形式为：\n$$ \\dot{\\sigma} = E \\dot{\\varepsilon}^{e} = E (\\dot{\\varepsilon} - \\dot{\\varepsilon}^{p}) $$\n\n- **屈服函数**：弹性域的边界由专用于一维的 von Mises 屈服函数 $f$ 定义。它依赖于应力 $\\sigma$ 和一个内部变量，即累积塑性应变 $\\alpha$：\n$$ f(\\sigma, \\alpha) = |\\sigma| - \\sigma_{y}(\\alpha) \\le 0 $$\n其中 $\\sigma_{y}(\\alpha)$ 是当前屈服应力。\n\n- **各向同性硬化定律**：当前屈服应力 $\\sigma_{y}(\\alpha)$ 根据线性各向同性硬化法则随累积塑性应变 $\\alpha$ 演化：\n$$ \\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\alpha $$\n此处，$\\sigma_{y0}$ 是初始屈服应力，而 $H$ 是常数硬化模量。\n\n- **流动法则和硬化演化**：塑性流动是关联的，意味着塑性应变率 $\\dot{\\varepsilon}^{p}$ 垂直于屈服面。内部变量的演化由塑性乘子率 $\\dot{\\gamma}$ 控制：\n$$ \\dot{\\varepsilon}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sgn}(\\sigma) $$\n$$ \\dot{\\alpha} = \\dot{\\gamma} \\sqrt{\\left(\\frac{\\partial f}{\\partial \\sigma}\\right)^2} = \\dot{\\gamma} |\\mathrm{sgn}(\\sigma)| = \\dot{\\gamma} $$\n\n- **Karush-Kuhn-Tucker (KKT) 加载/卸载条件**：这些条件控制塑性流动：\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\n如果发生塑性加载（$\\dot{\\gamma} > 0$），状态必须保持在屈服面上（$f=0$），这意味着一致性条件 $\\dot{f}=0$。\n\n**$2$. 隐式后向欧拉离散化**\n\n我们使用隐式后向欧拉格式对率方程在一个从 $t_{n}$ 到 $t_{n+1}$ 的时间增量上进行积分。这意味着所有率项都在步末 $t_{n+1}$ 进行评估。给定第 $n$ 步的状态 $(\\varepsilon^{p}_{n}, \\alpha_{n})$ 和第 $n+1$ 步的总应变 $\\varepsilon_{n+1}$，我们必须找到 $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$。\n\n离散化的演化方程为：\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\varepsilon^{p} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\gamma $$\n其中 $\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} \\, dt$ 是有限塑性乘子增量，它必须是非负的，即 $\\Delta\\gamma \\ge 0$。\n\n步末的应力为：\n$$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) $$\n\n离散形式的 KKT 条件变为：\n$$ \\Delta\\gamma \\ge 0, \\quad f_{n+1} = |\\sigma_{n+1}| - \\sigma_{y}(\\alpha_{n+1}) \\le 0, \\quad \\Delta\\gamma f_{n+1} = 0 $$\n\n**$3$. 返回映射算法**\n\n该算法提供了一种稳健的方法来求解离散化系统。它包括一个弹性预测，如果预测违反屈服条件，则进行塑性修正。\n\n**步骤 $3.1$：弹性预测**\n\n首先，我们假设该步是纯弹性的，这意味着 $\\Delta\\gamma = 0$。这给出了一个“试探”状态。\n塑性应变和累积塑性应变不变：\n$$ \\varepsilon^{p, \\mathrm{trial}}_{n+1} = \\varepsilon^{p}_{n} $$\n$$ \\alpha^{\\mathrm{trial}}_{n+1} = \\alpha_{n} $$\n试探应力由 Hooke 定律计算得出：\n$$ \\sigma^{\\mathrm{trial}}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) $$\n\n**步骤 $3.2$：屈服检查**\n\n我们通过评估屈服函数来检查这个试探状态是否是容许的。用于此检查的屈服应力基于增量开始时的状态：\n$$ \\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n} $$\n试探屈服函数值为：\n$$ f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} $$\n- 如果 $f^{\\mathrm{trial}}_{n+1} \\le 0$，则弹性假设是正确的。材料响应是弹性的。最终状态即为试探状态：\n  $$ \\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}, \\quad \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}, \\quad \\alpha_{n+1} = \\alpha_{n} $$\n- 如果 $f^{\\mathrm{trial}}_{n+1} > 0$，则弹性假设被违反。发生塑性变形，需要进行塑性修正。\n\n**步骤 $3.3$：塑性修正**\n\n对于塑性步，我们必须找到 $\\Delta\\gamma > 0$，使得最终状态 $(\\sigma_{n+1}, \\alpha_{n+1})$ 位于更新后的屈服面上，即 $f_{n+1} = 0$。\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0 $$\n代入离散化的演化方程：\n$$ |\\sigma_{n+1}| = \\sigma_{y0} + H(\\alpha_{n} + \\Delta\\gamma) = (\\sigma_{y0} + H\\alpha_{n}) + H\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\n现在，用试探应力和 $\\Delta\\gamma$ 表示 $\\sigma_{n+1}$：\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) = E(\\varepsilon_{n+1} - (\\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}))) $$\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) = \\sigma^{\\mathrm{trial}}_{n+1} - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\n该算法的一个关键方面是，在返回过程中应力符号不会改变，因此 $\\mathrm{sgn}(\\sigma_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$。取绝对值：\n$$ |\\sigma_{n+1}| = |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma $$\n该方程描述了应力大小从试探值“返回”到屈服面的过程。将 $|\\sigma_{n+1}|$ 的两个表达式相等：\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\n求解塑性乘子增量 $\\Delta\\gamma$：\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} = (E+H)\\Delta\\gamma $$\n$$ \\Delta\\gamma = \\frac{|\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}}{E+H} = \\frac{f^{\\mathrm{trial}}_{n+1}}{E+H} $$\n由于我们处于塑性情况，$f^{\\mathrm{trial}}_{n+1} > 0$。因为 $E > 0$ 且 $H \\ge 0$，我们正确地得到 $\\Delta\\gamma > 0$。\n\n一旦 $\\Delta\\gamma$ 已知，我们更新状态变量：\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma $$\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) $$\n更新后的应力 $\\sigma_{n+1}$ 可以通过从试探应力返回或使用最终屈服条件来计算。使用后者通常更稳健：\n$$ \\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times \\sigma_{y}(\\alpha_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times (\\sigma_{y,n} + H\\Delta\\gamma) $$\n\n**$4$. 一致算法切线模量**\n\n一致算法切线模量 $E_{\\mathrm{tan},n+1}$ 定义为最终应力相对于最终总应变的导数，即 $E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}}$。它对于隐式有限元方法至关重要。\n\n- **弹性情况**：如果该步是弹性的，$\\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$。\n$$ E_{\\mathrm{tan},n+1} = \\frac{d}{d\\varepsilon_{n+1}} [E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})] = E $$\n\n- **塑性情况**：如果该步是塑性的，我们对最终应力表达式进行微分。一个便于微分的形式是：\n$$ \\sigma_{n+1} = \\frac{\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})E\\sigma_{y,n} + HE(\\varepsilon_{n+1} - \\varepsilon^{p}_n)}{E+H} $$\n对 $\\varepsilon_{n+1}$ 求导（并将 $\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$ 视为对于 $\\varepsilon_{n+1}$ 的无穷小变化是常数）：\n$$ E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = \\frac{d}{d\\varepsilon_{n+1}} \\left[ \\frac{\\mathrm{const} + HE\\varepsilon_{n+1}}{E+H} \\right] = \\frac{HE}{E+H} $$\n对于理想塑性（$H=0$），这正确地给出 $E_{\\mathrm{tan},n+1} = 0$。\n\n**$5$. 实现算法摘要**\n\n对于每个输入元组 $(E, H, \\sigma_{y0}, \\varepsilon_{n+1}, \\varepsilon^{p}_{n}, \\alpha_{n})$：\n1.  计算试探应力：$\\sigma^{\\mathrm{trial}}_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$。\n2.  根据前一状态计算屈服应力：$\\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n}$。\n3.  评估试探屈服函数：$f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}$。\n4.  **如果 $f^{\\mathrm{trial}}_{n+1} \\le 0$（弹性步）：**\n    - $\\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}$\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}$\n    - $\\alpha_{n+1} = \\alpha_{n}$\n    - $E_{\\mathrm{tan},n+1} = E$\n5.  **否则（塑性步）：**\n    - $\\Delta\\gamma = f^{\\mathrm{trial}}_{n+1} / (E+H)$。\n    - $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma$。\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\cdot \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$。\n    - $\\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\cdot (\\sigma_{y,n} + H\\Delta\\gamma)$。\n    - $E_{\\mathrm{tan},n+1} = (E \\cdot H) / (E+H)$。\n6.  返回计算值 $[\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1}, E_{\\mathrm{tan},n+1}]$。\n\n此算法现已准备好实施。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n):\n    \"\"\"\n    Computes the updated stress, plastic strain, accumulated plastic strain,\n    and consistent tangent modulus for a 1D J2 plasticity model with\n    isotropic hardening using an implicit backward Euler return-mapping algorithm.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        H (float): Hardening modulus in Pa.\n        sig_y0 (float): Initial yield stress in Pa.\n        eps_n1 (float): Total strain at step n+1 (dimensionless).\n        eps_p_n (float): Plastic strain at step n (dimensionless).\n        alpha_n (float): Accumulated plastic strain at step n (dimensionless).\n\n    Returns:\n        list: A list containing [sig_n1, eps_p_n1, alpha_n1, E_tan_n1].\n    \"\"\"\n    # Step 1: Elastic predictor (trial state)\n    sig_trial_n1 = E * (eps_n1 - eps_p_n)\n\n    # Step 2: Yield check\n    # Yield stress from the previous converged step n\n    sig_y_n = sig_y0 + H * alpha_n\n    \n    # Evaluate yield function at the trial state\n    f_trial_n1 = np.abs(sig_trial_n1) - sig_y_n\n\n    # Step 3: Determine if the step is elastic or plastic\n    if f_trial_n1 = 0:\n        # Elastic step\n        sig_n1 = sig_trial_n1\n        eps_p_n1 = eps_p_n\n        alpha_n1 = alpha_n\n        E_tan_n1 = E\n    else:\n        # Plastic step (plastic corrector)\n        \n        # Calculate the plastic multiplier increment\n        # E > 0 and H >= 0, so E + H > 0.\n        delta_gamma = f_trial_n1 / (E + H)\n\n        # Update internal variables\n        alpha_n1 = alpha_n + delta_gamma\n        \n        # The sign of trial stress determines the direction of plastic flow.\n        # If sig_trial_n1 were 0, f_trial_n1 would be = 0, so we would be\n        # in the elastic branch. Thus, sig_trial_n1 is non-zero here.\n        sign_sig_trial = np.sign(sig_trial_n1)\n        \n        eps_p_n1 = eps_p_n + delta_gamma * sign_sig_trial\n\n        # Update stress by returning to the updated yield surface.\n        # This form is numerically stable and directly enforces the yield condition.\n        sig_n1 = sign_sig_trial * (sig_y_n + H * delta_gamma)\n\n        # Calculate the consistent algorithmic tangent modulus for the plastic case\n        E_tan_n1 = (E * H) / (E + H)\n\n    return [sig_n1, eps_p_n1, alpha_n1, E_tan_n1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E, H, sigma_y0, epsilon_n+1, epsilon_p_n, alpha_n)\n    test_cases = [\n        (210e9, 2e9, 400e6, 1.0e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 1.25e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 2.0e-3, 0.0, 0.0),\n        (210e9, 2e9, 400e6, 3.0e-3, 1.0e-3, 1.0e-3),\n        (210e9, 2e9, 400e6, -5.0e-4, 1.0e-3, 1.0e-3),\n        (100e9, 0.0, 100e6, 2.0e-3, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        E, H, sig_y0, eps_n1, eps_p_n, alpha_n = case\n        \n        # Calculate the updated state\n        result = update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n)\n        results.append(result)\n\n    # Format the output string to be exactly as specified: [[r1,r2,...],[...],...]\n    # without extra spaces.\n    inner_lists = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_lists)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "除了材料响应，结构的几何构型本身也可以是非线性的来源。本练习探讨几何刚度的概念，即结构中存在的应力会改变其抵抗变形的能力。你将为一个桁架单元实现几何刚度矩阵，从而具体理解轴向力如何影响结构的稳定性和大位移响应。这一原理是分析屈曲等稳定性问题的核心。",
            "id": "2411426",
            "problem": "实现一个完整且可运行的程序，用于计算一个经历大转动和小轴向应变的二维（$2$D）两节点直桁架单元的几何刚度矩阵 $K_{\\sigma}$，并在一组给定构型上进行验证。\n\n几何刚度矩阵 $K_{\\sigma}$ 定义为：对于每个节点具有两个平移自由度（DOF）的直杆，根据虚功原理得到的一致切线刚度中的初应力贡献部分。设单元连接当前位置为 $\\mathbf{x}_1 = (x_1,y_1)$ 的节点 $1$ 和当前位置为 $\\mathbf{x}_2 = (x_2,y_2)$ 的节点 $2$，当前长度为 $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$，当前单位切向量为 $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$。设初始（参考）位置为 $\\mathbf{X}_1 = (X_1,Y_1)$ 和 $\\mathbf{X}_2 = (X_2,Y_2)$，初始长度为 $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$。材料为线性弹性，杨氏模量为 $E$，横截面积为常数 $A$。假设轴向应变很小，但允许弦的任意大刚体转动。轴力 $N$ 根据轴向伸长计算，即 $N = (EA/L_0)\\,(l - L_0)$，并用于计算几何刚度。所有力必须以牛顿表示，所有长度必须以米表示。\n\n您的程序必须：\n- 对于每个测试用例，根据给定的 $E$、$A$、$L_0$ 和当前构型计算轴力 $N$（单位：牛顿）。\n- 构建对应于自由度顺序 $(x_1,y_1,x_2,y_2)$ 的 $4\\times 4$ 全局坐标系下的几何刚度矩阵 $K_{\\sigma}$（单位：牛顿/米）。\n- 为进行验证，计算弗罗贝尼乌斯范数 $\\|K_{\\sigma}\\|_F$，并将其与标量 $2|N|/l$（单位：牛顿/米）进行比较。报告每个测试用例的标量差 $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$（单位：牛顿/米）。\n\n下文指定的角度单位为弧度。所有输出值必须以牛顿/米为单位，并四舍五入到 $9$ 位小数。\n\n测试套件（每个用例相互独立）：\n- 用例 A（刚性转动，零伸长）：\n  - $E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$，$A = 3.0\\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$，因此 $L_0 = 1.0\\,\\mathrm{m}$。\n  - 当前构型：绕节点 $1$ 纯转动角度 $\\theta = \\pi/3$，即 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$。\n- 用例 B（纯轴向拉伸，无转动）：\n  - $E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$，$A = 1.2\\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$，因此 $L_0 = 2.0\\,\\mathrm{m}$。\n  - 当前构型：$\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$。\n- 用例 C（带压缩的大转动）：\n  - $E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$，$A = 2.5\\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$，因此 $L_0 = 1.5\\,\\mathrm{m}$。\n  - 当前构型：转动 $\\theta = 1.74532925199433$ 并径向缩短 $\\delta = -0.01\\,\\mathrm{m}$，即 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 A、B、C 的顺序排列结果，例如 $[\\Delta_A,\\Delta_B,\\Delta_C]$，其中每个 $\\Delta$ 是一个以牛顿/米为单位、四舍五入到 $9$ 位小数的浮点数。",
            "solution": "用户提交了一个待评估和求解的问题。首要的强制步骤是对问题陈述进行严格验证。\n\n### 步骤 1：提取已知信息\n\n问题陈述提供了以下信息：\n- **单元定义**：一个二维（$2$D）两节点直桁架单元。\n- **自由度 (DOF)**：每个节点两个平移自由度。全局自由度向量排序为 $(x_1, y_1, x_2, y_2)$。\n- **运动学假设**：大刚体转动和小轴向应变。\n- **节点位置**：\n    - 参考（初始）位置：$\\mathbf{X}_1 = (X_1, Y_1)$，$\\mathbf{X}_2 = (X_2, Y_2)$\n    - 当前位置：$\\mathbf{x}_1 = (x_1, y_1)$，$\\mathbf{x}_2 = (x_2, y_2)$\n- **单元长度**：\n    - 初始长度：$L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$\n    - 当前长度：$l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$\n- **单元切向量**：当前单位切向量 $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$。\n- **材料属性**：线性弹性，杨氏模量为 $E$，横截面积为常数 $A$。\n- **本构关系**：轴力 $N = (EA/L_0)\\,(l - L_0)$。\n- **目标量**：全局坐标系下的几何刚度矩阵 $\\mathbf{K}_{\\sigma}$，定义为一致切线刚度中的初应力贡献。它是一个 $4 \\times 4$ 矩阵。\n- **验证任务**：对于每个测试用例，计算标量差 $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$，其中 $\\|K_{\\sigma}\\|_F$ 是几何刚度矩阵的弗罗贝尼乌斯范数。\n- **单位**：力以牛顿（N）为单位，长度以米（m）为单位，压强以帕斯卡（Pa）为单位。输出 $\\Delta$ 的单位为 N/m。\n- **输出精度**：所有输出值必须四舍五入到 $9$ 位小数。\n\n- **测试用例 A**：\n  - $E = 2.10 \\times 10^{11}\\,\\mathrm{Pa}$，$A = 3.0 \\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$（$L_0 = 1.0\\,\\mathrm{m}$）。\n  - 当前构型：绕节点 $1$ 转动 $\\theta = \\pi/3$，因此 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$。\n\n- **测试用例 B**：\n  - $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$，$A = 1.2 \\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$（$L_0 = 2.0\\,\\mathrm{m}$）。\n  - 当前构型：$\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$。\n\n- **测试用例 C**：\n  - $E = 2.00 \\times 10^{11}\\,\\mathrm{Pa}$，$A = 2.5 \\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$（$L_0 = 1.5\\,\\mathrm{m}$）。\n  - 当前构型：转动 $\\theta = 1.74532925199433\\,\\mathrm{rad}$ 并径向缩短 $\\delta = -0.01\\,\\mathrm{m}$，因此 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n根据所需标准对问题进行评估：\n- **科学性**：该问题植根于结构的有限元分析，特别是在几何非线性的背景下。几何刚度矩阵（$\\mathbf{K}_\\sigma$）的概念是计算固体力学中的一个标准和基本组成部分，用于捕捉现有应力对刚度的影响（例如，应力刚化或软化效应）。所提供的轴力公式 $N = (EA/L_0)(l - L_0)$ 是胡克定律在杆总伸长上的直接应用，这与协同转动（co-rotational）列式法或小应变假设下的总拉格朗日列式法相一致。该问题是该领域的标准练习。\n- **适定性**：该问题是适定的。对于每个测试用例，都提供了所有必要的数据（$E, A$，初始和当前坐标）。所有待计算量（$L_0, l, N, \\mathbf{K}_\\sigma, \\|K_{\\sigma}\\|_F, \\Delta$）的定义都是明确的。这些指令对每个用例都会导出一个唯一的、确定性的结果。\n- **客观性**：语言完全是客观的，采用了精确的数学和工程术语。没有主观或基于观点的陈述。输入和期望的输出都是可量化的。\n\n该问题没有表现出任何列举的无效性缺陷。它在科学上是合理的，与指定主题直接相关，是完整的，物理上是可信的，并且结构良好。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。现将提供一个完整的、有理有据的解答。\n\n### 求解推导\n\n分析经历大位移但小应变的结构需要考虑几何非线性。总切线刚度矩阵 $\\mathbf{K}_T$ 是材料刚度矩阵 $\\mathbf{K}_m$（取决于材料属性和几何形状）与几何刚度矩阵 $\\mathbf{K}_\\sigma$（取决于当前应力状态）之和。\n$$\n\\mathbf{K}_T = \\mathbf{K}_m + \\mathbf{K}_\\sigma\n$$\n本问题仅关注 $\\mathbf{K}_\\sigma$ 的计算。该矩阵源于内力向量相对于几何变化的变分。对于一个承受轴力 $N$（拉力为正，压力为负）的二维桁架单元，其在全局坐标系下的几何刚度矩阵由一个公认的公式给出：\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l}\n\\begin{bmatrix}\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}   -(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}) \\\\\n-(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t})  \\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}\n\\end{bmatrix}\n$$\n在此表达式中，$l$ 是单元的当前长度，$N$ 是轴力，$\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵，$\\mathbf{t}$ 是当前构型下沿单元轴线的单位向量，定义为 $\\mathbf{t} = (t_x, t_y)^T = \\frac{1}{l}(\\mathbf{x}_2 - \\mathbf{x}_1)$。符号 $\\otimes$ 表示张量积。\n\n$2 \\times 2$ 子矩阵 $\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}$ 可以展开。由于 $\\mathbf{t}$ 是单位向量，所以 $t_x^2 + t_y^2 = 1$。\n$$\n\\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\begin{bmatrix} t_x  t_y \\end{bmatrix} = \\begin{bmatrix} t_x^2  t_x t_y \\\\ t_x t_y  t_y^2 \\end{bmatrix}\n$$\n因此，\n$$\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} t_x^2  t_x t_y \\\\ t_x t_y  t_y^2 \\end{bmatrix} = \\begin{bmatrix} 1 - t_x^2  -t_x t_y \\\\ -t_x t_y  1 - t_y^2 \\end{bmatrix} = \\begin{bmatrix} t_y^2  -t_x t_y \\\\ -t_x t_y  t_x^2 \\end{bmatrix}\n$$\n我们将此子矩阵表示为 $\\mathbf{M}$。那么，对应于全局自由度 $(x_1, y_1, x_2, y_2)$ 的完整 $4 \\times 4$ 几何刚度矩阵为：\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix} = \\frac{N}{l}\n\\begin{bmatrix}\nt_y^2   -t_x t_y   -t_y^2   t_x t_y \\\\\n-t_x t_y   t_x^2   t_x t_y   -t_x^2 \\\\\n-t_y^2   t_x t_y   t_y^2   -t_x t_y \\\\\nt_x t_y   -t_x^2   -t_x t_y   t_x^2\n\\end{bmatrix}\n$$\n问题要求计算该矩阵的弗罗贝尼乌斯范数 $\\|\\mathbf{K}_{\\sigma}\\|_F$。弗罗贝尼乌斯范数的平方是其所有元素平方的总和。\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\text{tr}(\\mathbf{K}_{\\sigma}^T \\mathbf{K}_{\\sigma}) = \\sum_{i,j} (K_{\\sigma,ij})^2\n$$\n观察 $\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix}$ 的结构，其弗罗贝尼乌斯范数的平方为：\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\left(\\frac{N}{l}\\right)^2 \\left( \\|\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|\\mathbf{M}\\|_F^2 \\right) = 4 \\left(\\frac{N}{l}\\right)^2 \\|\\mathbf{M}\\|_F^2\n$$\n我们来计算子矩阵 $\\mathbf{M}$ 的弗罗贝尼乌斯范数的平方：\n$$\n\\|\\mathbf{M}\\|_F^2 = (t_y^2)^2 + (-t_x t_y)^2 + (-t_x t_y)^2 + (t_x^2)^2 = t_y^4 + t_x^2 t_y^2 + t_x^2 t_y^2 + t_x^4\n$$\n$$\n\\|\\mathbf{M}\\|_F^2 = t_y^2(t_y^2 + t_x^2) + t_x^2(t_y^2 + t_x^2) = (t_y^2 + t_x^2)(t_x^2 + t_y^2) = (1)(1) = 1\n$$\n这是因为 $\\mathbf{t}$ 是一个单位向量，所以 $t_x^2+t_y^2=1$。\n将此结果代回，我们发现：\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = 4 \\left(\\frac{N}{l}\\right)^2 (1) = 4 \\frac{N^2}{l^2}\n$$\n取平方根得到弗罗贝尼乌斯范数：\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F = \\sqrt{4 \\frac{N^2}{l^2}} = 2 \\frac{|N|}{l}\n$$\n问题要求计算 $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$。根据此解析推导，对于任何有效输入，$\\Delta$ 的值都必须恒为零。此计算可作为该恒等式的数值验证，任何非零结果都将归因于浮点表示和算术误差。\n\n### 计算算法\n\n对每个测试用例，执行以下步骤：\n1. 定义输入参数：$E, A$，初始节点坐标 $\\mathbf{X}_1, \\mathbf{X}_2$ 和当前节点坐标 $\\mathbf{x}_1, \\mathbf{x}_2$。\n2. 计算初始长度 $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$。\n3. 计算当前长度 $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$。如果 $l=0$，则单元已坍缩，后续步骤无定义。测试用例避免了这种奇异情况。\n4. 计算轴力 $N = \\frac{EA}{L_0}(l - L_0)$。\n5. 计算当前单位切向量的分量，$t_x = (x_2 - x_1)/l$ 和 $t_y = (y_2 - y_1)/l$。\n6. 使用推导的公式构建 $4 \\times 4$ 矩阵 $\\mathbf{K}_{\\sigma}$。\n7. 使用数值库函数计算弗罗贝尼乌斯范数 $\\|\\mathbf{K}_{\\sigma}\\|_F$。\n8. 计算验证标量 $V = 2|N|/l$。\n9. 计算差值 $\\Delta = \\|\\mathbf{K}_{\\sigma}\\|_F - V$。\n10. 存储得到的 $\\Delta$ 值，该值预期在数值上接近于零。\n\n该算法将应用于三个给定的测试用例。最终输出将是按规定格式四舍五入的 $\\Delta$ 值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta(E, A, X1, X2, x1, x2):\n    \"\"\"\n    Computes the geometric stiffness matrix K_sigma and the verification difference Delta.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        A (float): Cross-sectional area in m^2.\n        X1 (np.ndarray): Initial coordinates of node 1 (2-element array) in m.\n        X2 (np.ndarray): Initial coordinates of node 2 (2-element array) in m.\n        x1 (np.ndarray): Current coordinates of node 1 (2-element array) in m.\n        x2 (np.ndarray): Current coordinates of node 2 (2-element array) in m.\n\n    Returns:\n        float: The scalar difference Delta = ||K_sigma||_F - 2*|N|/l in N/m.\n    \"\"\"\n    # Calculate initial length\n    if not isinstance(X1, np.ndarray): X1 = np.array(X1, dtype=float)\n    if not isinstance(X2, np.ndarray): X2 = np.array(X2, dtype=float)\n    L0 = np.linalg.norm(X2 - X1)\n\n    # Calculate current length\n    if not isinstance(x1, np.ndarray): x1 = np.array(x1, dtype=float)\n    if not isinstance(x2, np.ndarray): x2 = np.array(x2, dtype=float)\n    dx = x2 - x1\n    l = np.linalg.norm(dx)\n\n    # Handle the case of zero current length to avoid division by zero\n    if l == 0.0:\n        # If length is zero, N is based on L0, K_sigma would be singular.\n        # As per problem context, this case is not expected.\n        # But for robustness, we can define N and state K_sigma is undefined.\n        # Here we assume it implies zero stiffness contribution.\n        return 0.0\n\n    # Calculate axial force N\n    N = (E * A / L0) * (l - L0)\n\n    # Calculate current unit tangent vector t\n    t = dx / l\n    tx, ty = t[0], t[1]\n\n    # Construct the geometric stiffness matrix K_sigma\n    # Submatrix M = [[ty^2, -tx*ty], [-tx*ty, tx^2]]\n    M = np.array([\n        [ty**2, -tx * ty],\n        [-tx * ty, tx**2]\n    ])\n    \n    # K_sigma = (N / l) * [[M, -M], [-M, M]]\n    K_sigma = (N / l) * np.block([\n        [M, -M],\n        [-M, M]\n    ])\n    \n    # Compute the Frobenius norm of K_sigma\n    norm_K_sigma = np.linalg.norm(K_sigma, 'fro')\n    \n    # Compute the verification scalar 2*|N|/l\n    verification_scalar = 2.0 * abs(N) / l\n    \n    # Compute the difference Delta\n    delta = norm_K_sigma - verification_scalar\n    \n    return delta\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the required format.\n    \"\"\"\n    # Case A: Rigid rotation, zero extension\n    theta_A = np.pi / 3.0\n    L0_A = 1.0\n    case_A = {\n        \"E\": 2.10e11, \"A\": 3.0e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (L0_A * np.cos(theta_A), L0_A * np.sin(theta_A))\n    }\n\n    # Case B: Pure axial tension, no rotation\n    case_B = {\n        \"E\": 7.0e10, \"A\": 1.2e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (2.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (2.02, 0.0)\n    }\n\n    # Case C: Large rotation with compression\n    L0_C = 1.5\n    delta_len_C = -0.01\n    l_C = L0_C + delta_len_C\n    theta_C = 1.74532925199433  # 100 degrees\n    case_C = {\n        \"E\": 2.00e11, \"A\": 2.5e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.5, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (l_C * np.cos(theta_C), l_C * np.sin(theta_C))\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        delta_val = compute_delta(\n            case[\"E\"], case[\"A\"],\n            case[\"X1\"], case[\"X2\"],\n            case[\"x1\"], case[\"x2\"]\n        )\n        results.append(delta_val)\n\n    # Format the final output string as required\n    formatted_results = [f\"{res:.9f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "真实的工程挑战往往同时涉及材料和几何非线性。最后的这个练习将这些概念融为一体，利用连续介质损伤力学模拟大变形下的材料退化。通过在一个大应变框架内实现损伤演化规律，你将构建一个更全面的模型，用以捕捉材料软化和失效萌生等复杂现象。",
            "id": "2411469",
            "problem": "考虑一个初始长度为 $L_0$、参考横截面积恒为 $A_0$ 的细长聚合物棒，在位移控制下单轴受拉。假设棒身变形均匀，变形梯度可简化为标量拉伸率 $\\lambda$。使用一维超弹性损伤模型，其中几何非线性通过精确运动学捕捉，材料非线性通过各向同性连续介质损伤捕捉。\n\n本问题的基本依据如下：\n- 运动学：拉伸率为 $\\lambda = 1 + u/L_0$，其中 $u$ 是施加的端部位移，单位为米 (m)。Green-Lagrange应变为 $E = \\frac{1}{2}(\\lambda^2 - 1)$。\n- 热力学与本构结构：设单位参考体积的亥姆霍兹自由能为 $\\psi(E, D) = (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,E^2$，其中 $E_{\\mathrm{Y}}$ 是杨氏模量，单位为帕斯卡 (Pa)，$D \\in [0,1)$ 是一个降低刚度的标量损伤变量。\n- 应力度量：第二Piola-Kirchhoff应力为 $S = \\partial \\psi / \\partial E$，第一Piola-Kirchhoff（名义）应力为 $P = \\lambda\\,S$。轴向力为 $N = A_0\\,P$，单位为牛顿 (N)。\n- 损伤驱动变量与历史：仅在受拉时产生损伤，损伤由Green-Lagrange应变的非负部分驱动，$r(E) = \\max(E, 0)$。历史变量 $\\kappa$ 是加载历史中的最大值，更新方式为 $\\kappa_{n+1} = \\max(\\kappa_n, r(E_{n+1}))$，初始值为 $\\kappa_0 = 0$。\n- 损伤演化：使用一个带阈值的光滑、热力学上可接受的软化定律，由下式给出\n$$\nD(\\kappa) = 1 - \\exp\\!\\Bigg(-\\left(\\frac{\\langle \\kappa - \\kappa_{\\mathrm{th}} \\rangle_+}{\\kappa_f}\\right)^m\\Bigg),\n$$\n其中 $\\kappa_{\\mathrm{th}}  0$ 是损伤起始的Green-Lagrange应变阈值，$\\kappa_f  0$ 是软化尺度，$m  0$ 是形状参数，且 $\\langle x \\rangle_+ = \\max(x, 0)$。该定律确保当 $\\kappa \\le \\kappa_{\\mathrm{th}}$ 时 $D = 0$，当 $\\kappa \\to \\infty$ 时 $D \\to 1$。\n\n任务：\n1. 从上述定义出发，推导 $S(E, D)$、$P(\\lambda, E, D)$ 和 $N(\\lambda, E, D)$ 关于输入参数和状态变量的显式表达式。不要假定任何线性化运动学，且不要跳过推导步骤。\n2. 设计一个算法，对于给定的位移序列 $\\{u_1, u_2, \\ldots, u_K\\}$，在每一步根据上述定义更新历史变量 $\\kappa$ 和损伤 $D$，并计算最后一步的最终轴向力 $N$ 和最终损伤 $D$。假设为准静态加载，不考虑惯性，并使用任务1中推导的精确表达式。\n3. 在一个程序中实现该算法，以评估以下测试套件。所有输入均采用一致的国际单位制（SI）：$u$ 的单位为米 (m)，$L_0$ 的单位为米 (m)，$A_0$ 的单位为平方米 (m$^2$)，$E_{\\mathrm{Y}}$ 的单位为帕斯卡 (Pa)。报告的轴向力单位为牛顿 (N)。本问题不涉及角度。将每个数值输出表示为四舍五入到六位小数的十进制数。\n\n测试套件：\n- 情况A（无损伤，小应变）：$E_{\\mathrm{Y}} = 2.0 \\times 10^9$ Pa，$A_0 = 1.0 \\times 10^{-4}$ m$^2$，$L_0 = 0.1$ m，$\\kappa_{\\mathrm{th}} = 0.02$，$\\kappa_f = 0.1$，$m = 2.0$，位移步长 $\\{u_k\\} = \\{0.0001, 0.0002, 0.0003, 0.0005\\}$ m。\n- 情况B（单调加载进入软化阶段）：$E_{\\mathrm{Y}} = 2.0 \\times 10^9$ Pa，$A_0 = 1.0 \\times 10^{-4}$ m$^2$，$L_0 = 0.1$ m，$\\kappa_{\\mathrm{th}} = 0.02$，$\\kappa_f = 0.1$，$m = 2.0$，位移步长 $\\{u_k\\} = \\{0.002, 0.004, 0.006, 0.01\\}$ m。\n- 情况C（加载-卸载，损伤保留）：$E_{\\mathrm{Y}} = 1.0 \\times 10^9$ Pa，$A_0 = 1.0 \\times 10^{-4}$ m$^2$，$L_0 = 0.1$ m，$\\kappa_{\\mathrm{th}} = 0.01$，$k_f = 0.05$，$m = 1.5$，位移步长 $\\{u_k\\} = \\{0.004, 0.002\\}$ m。\n- 情况D（恰好在损伤阈值处）：$E_{\\mathrm{Y}} = 2.0 \\times 10^9$ Pa，$A_0 = 1.0 \\times 10^{-4}$ m$^2$，$L_0 = 0.1$ m，$\\kappa_{\\mathrm{th}} = 0.02$，$\\kappa_f = 0.1$，$m = 2.0$，单个位移步长 $u_1 = L_0 \\left(\\sqrt{1 + 2 \\kappa_{\\mathrm{th}}} - 1\\right)$ m，这使得Green-Lagrange应变等于阈值。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每种情况，返回一个包含两个元素的列表，即最终轴向力（牛顿）和最终损伤 $[N_{\\mathrm{final}}, D_{\\mathrm{final}}]$，两者都四舍五入到六位小数。因此，总体输出必须是按A、B、C、D顺序排列的包含四个列表的列表，例如 $[[\\dots,\\dots],[\\dots,\\dots],[\\dots,\\dots],[\\dots,\\dots]]$。",
            "solution": "该问题已经过验证，被认为是科学上可靠、适定且自洽的。这是计算固体力学中的一个标准问题。我们开始进行求解。\n\n解答按要求分为三个部分：表达式推导、计算算法设计，以及针对指定测试套件的实现。\n\n**任务1：本构表达式的推导**\n\n问题提供了一维超弹性损伤模型的运动学、热力学和应力度量的基本定义。我们从单位参考体积的亥姆霍兹自由能 $\\psi$ 出发，推导应力和力的显式表达式。所有推导均使用完全非线性的运动学关系。\n\n亥姆霍兹自由能由下式给出：\n$$\n\\psi(E, D) = (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,E^2\n$$\n其中 $E$ 是Green-Lagrange应变，$D$ 是标量损伤变量，$E_{\\mathrm{Y}}$ 是杨氏模量。\n\n1.  **第二Piola-Kirchhoff应力 ($S$)**\n    第二Piola-Kirchhoff应力 $S$ 与Green-Lagrange应变 $E$ 功共轭。它是通过将自由能 $\\psi$ 对 $E$ 求偏导数得到的，同时保持内部状态变量 $D$ 恒定：\n    $$\n    S = \\frac{\\partial \\psi}{\\partial E}\n    $$\n    代入 $\\psi$ 的表达式：\n    $$\n    S = \\frac{\\partial}{\\partial E} \\left[ (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,E^2 \\right]\n    $$\n    在对 $E$ 求导时，项 $(1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}$ 被视为常数：\n    $$\n    S = (1 - D)\\,\\frac{1}{2}\\,E_{\\mathrm{Y}}\\,(2E)\n    $$\n    简化后得到第二Piola-Kirchhoff应力的最终表达式：\n    $$\n    S(E, D) = (1 - D)\\,E_{\\mathrm{Y}}\\,E\n    $$\n    此方程表示一个割线刚度关系，其中有效模量被损伤因子 $(1 - D)$ 所折减。\n\n2.  **第一Piola-Kirchhoff应力 ($P$)**\n    第一Piola-Kirchhoff应力，也称为名义应力，$P$，通过变形梯度与第二Piola-Kirchhoff应力 $S$ 相关。在这种一维情况下，变形梯度即为拉伸率 $\\lambda$。关系式为：\n    $$\n    P = \\lambda\\,S\n    $$\n    代入推导出的 $S(E, D)$ 表达式：\n    $$\n    P(\\lambda, E, D) = \\lambda\\,(1 - D)\\,E_{\\mathrm{Y}}\\,E\n    $$\n    该应力度量是单位*参考*面积上的力。\n\n3.  **轴向力 ($N$)**\n    棒中的总轴向力 $N$ 是第一Piola-Kirchhoff应力 $P$ 乘以恒定的参考横截面积 $A_0$：\n    $$\n    N = A_0\\,P\n    $$\n    代入推导出的 $P(\\lambda, E, D)$ 表达式：\n    $$\n    N(\\lambda, E, D) = A_0\\,\\lambda\\,(1 - D)\\,E_{\\mathrm{Y}}\\,E\n    $$\n    这是轴向力的最终表达式。为计算给定排量 $u$ 下的该值，必须首先计算运动学变量 $\\lambda = 1 + u/L_0$ 和 $E = \\frac{1}{2}(\\lambda^2 - 1)$，并确定损伤变量 $D$ 的当前值。\n\n**任务2：算法设计**\n\n问题要求设计一个算法来模拟杆在给定的总端部位移序列 $\\{u^{(1)}, u^{(2)}, \\ldots, u^{(K)}\\}$ 下的响应。由于连续介质损伤的特性（由所经历的最大应变决定），材料行为具有历史依赖性。因此，该算法必须按位移序列进行，在每一步更新状态变量。\n\n在任意步骤 $k$ 的系统状态由历史变量 $\\kappa$ 和由此产生的损伤 $D$ 定义。\n\n**算法步骤：**\n\n1.  **初始化：**\n    - 输入材料参数：杨氏模量 $E_{\\mathrm{Y}}$、损伤阈值 $\\kappa_{\\mathrm{th}}$、软化尺度 $\\kappa_f$ 和形状参数 $m$。\n    - 输入几何参数：初始长度 $L_0$ 和参考面积 $A_0$。\n    - 输入要施加的总位移序列：$\\{u^{(1)}, u^{(2)}, \\ldots, u^{(K)}\\}$。\n    - 初始化状态变量：\n        - 历史变量（经历过的最大应变）：$\\kappa = 0$。\n        - 损伤变量：$D = 0$。\n        - 当前轴向力：$N = 0$。\n\n2.  **迭代状态更新：**\n    对于序列 $\\{u^{(1)}, u^{(2)}, \\ldots, u^{(K)}\\}$ 中的每个指定位移 $u_{current}$：\n    a.  **计算运动学变量：**\n        i.  计算拉伸率：$\\lambda = 1 + u_{current} / L_0$。\n        ii. 计算Green-Lagrange应变：$E = \\frac{1}{2}(\\lambda^2 - 1)$。\n\n    b.  **更新损伤状态：**\n        i.  确定损伤驱动变量，即应变的非负部分：$r = \\max(E, 0)$。\n        ii. 通过取其先前值与当前驱动量 $r$ 的最大值来更新历史变量 $\\kappa$：$\\kappa \\leftarrow \\max(\\kappa, r)$。\n        iii. 使用更新后的历史变量 $\\kappa$ 和给定的演化定律计算当前损伤 $D$：\n            $$\n            D = 1 - \\exp\\!\\Bigg(-\\left(\\frac{\\max(\\kappa - \\kappa_{\\mathrm{th}}, 0)}{\\kappa_f}\\right)^m\\Bigg)\n            $$\n            此更新确保了损伤是不可逆的；在卸载时它只能增长或保持不变。\n\n    c.  **计算力：**\n        i.  使用 $E$、$D$ 和 $\\lambda$ 的当前值，通过任务1中推导的表达式计算轴向力 $N$：\n            $$\n            N = A_0\\,\\lambda\\,(1 - D)\\,E_{\\mathrm{Y}}\\,E\n            $$\n\n3.  **最终结果：**\n    - 遍历所有指定的位移后，最终的轴向力 $N$ 和损伤 $D$ 值对应于最后一个位移 $u^{(K)}$ 时的状态。\n    - 报告这些最终值，$N_{\\mathrm{final}}$ 和 $D_{\\mathrm{final}}$。\n\n该算法正确地模拟了指定的准静态、等温和历史依赖性响应。在每个步骤中使用总位移值而非增量，这一点由测试情况C的“加载-卸载”描述所证实，因为使用单调增量是无法实现这种情况的。\n\n**任务3：测试套件的实现**\n\n任务2中的算法在一个Python程序中实现。该程序遍历四个指定的测试用例，为每个用例计算最终的轴向力 $N$ 和损伤 $D$，并按要求格式化输出。计算严格遵守推导出的非线性方程。",
            "answer": "```python\nimport numpy as np\n\ndef compute_final_state(params, u_sequence):\n    \"\"\"\n    Computes the final axial force and damage for a given sequence of displacements.\n\n    Args:\n        params (dict): A dictionary containing material and geometric parameters.\n        u_sequence (list): A list of prescribed total end displacements.\n\n    Returns:\n        tuple: A tuple containing the final axial force (N) and final damage (D).\n    \"\"\"\n    # Unpack parameters\n    E_Y = params['E_Y']\n    A_0 = params['A_0']\n    L_0 = params['L_0']\n    kappa_th = params['kappa_th']\n    kappa_f = params['kappa_f']\n    m = params['m']\n\n    # Initialize state variables\n    kappa = 0.0\n    damage = 0.0\n    force = 0.0\n    \n    if not u_sequence:\n        return 0.0, 0.0\n\n    for u_current in u_sequence:\n        # Step 1: Compute kinematics\n        stretch = 1.0 + u_current / L_0\n        green_lagrange_strain = 0.5 * (stretch**2 - 1.0)\n\n        # Step 2: Update damage state\n        # a. Damage driving variable\n        strain_driver = max(green_lagrange_strain, 0.0)\n        \n        # b. Update history variable\n        kappa = max(kappa, strain_driver)\n        \n        # c. Compute new damage value\n        if kappa > kappa_th:\n            arg = (kappa - kappa_th) / kappa_f\n            damage = 1.0 - np.exp(-(arg**m))\n        else:\n            damage = 0.0\n            \n        # Step 3: Compute stresses and force\n        # Second Piola-Kirchhoff stress\n        S = (1.0 - damage) * E_Y * green_lagrange_strain\n        # First Piola-Kirchhoff stress\n        P = stretch * S\n        # Axial force\n        force = A_0 * P\n\n    return force, damage\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the hyperelastic-damage model.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"params\": {'E_Y': 2.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.02, 'kappa_f': 0.1, 'm': 2.0},\n            \"u_sequence\": [0.0001, 0.0002, 0.0003, 0.0005]\n        },\n        {\n            \"name\": \"Case B\",\n            \"params\": {'E_Y': 2.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.02, 'kappa_f': 0.1, 'm': 2.0},\n            \"u_sequence\": [0.002, 0.004, 0.006, 0.01]\n        },\n        {\n            \"name\": \"Case C\",\n            \"params\": {'E_Y': 1.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.01, 'kappa_f': 0.05, 'm': 1.5},\n            \"u_sequence\": [0.004, 0.002]\n        },\n        {\n            \"name\": \"Case D\",\n            \"params\": {'E_Y': 2.0e9, 'A_0': 1.0e-4, 'L_0': 0.1, 'kappa_th': 0.02, 'kappa_f': 0.1, 'm': 2.0},\n            \"u_sequence\": [] # To be calculated\n        }\n    ]\n\n    # Calculate specific displacement for Case D\n    L0_D = test_cases[3]['params']['L_0']\n    kappa_th_D = test_cases[3]['params']['kappa_th']\n    u1_D = L0_D * (np.sqrt(1.0 + 2.0 * kappa_th_D) - 1.0)\n    test_cases[3]['u_sequence'] = [u1_D]\n\n    # Run all test cases and collect results\n    all_results = []\n    for case in test_cases:\n        N_final, D_final = compute_final_state(case['params'], case['u_sequence'])\n        all_results.append([N_final, D_final])\n\n    # Format the output string as specified\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in all_results]\n    output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(output_string)\n\nsolve()\n```"
        }
    ]
}