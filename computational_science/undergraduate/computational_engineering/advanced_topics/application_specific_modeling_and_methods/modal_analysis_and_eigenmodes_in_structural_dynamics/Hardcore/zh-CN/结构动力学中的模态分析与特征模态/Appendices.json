{
    "hands_on_practices": [
        {
            "introduction": "理论分析和数值模拟是结构动力学研究的两大支柱。本练习旨在通过一个经典的振动弦模型，连接这两个领域。通过从第一性原理推导连续弦的精确解，并与您自己构建的有限元模型的结果进行比较，您将亲身体验离散化如何影响模态分析的准确性，并理解网格密度在捕捉结构真实行为中的关键作用。",
            "id": "2414089",
            "problem": "考虑一根长度为 $L$、在恒定张力 $T$ 下、具有均匀线质量密度 $\\mu$ 的理想拉紧弦。其横向位移 $u(x,t)$ 满足一维波动方程和两端固定边界条件，即 $u(0,t)=0$ 和 $u(L,t)=0$。将系统视为连续体以获得精确的特征频率和特征模态，并使用均匀、分段线性的有限元模型对其进行近似，以获得离散的特征频率和特征模态。\n\n您的程序必须针对每个指定的测试用例，从第一性原理出发完成以下任务：\n- 对于连续弦，推导精确的第 $n$ 阶角特征频率 $\\omega_n^{\\mathrm{exact}}$ 和相应的归一化精确模态形状 $\\phi_n^{\\mathrm{exact}}(x)$，其中归一化是相对于均匀网格上节点采样向量的欧几里得范数。\n- 对于在 $[0,L]$ 上使用 $N_e$ 个均匀线性单元的有限元离散化，通过在每个单元上对弱形式进行积分来组装精确的全局刚度矩阵和质量矩阵，在 $x=0$ 和 $x=L$ 处施加固定边界条件，并求解得到的广义特征值问题，以获得第 $n$ 阶离散角特征频率 $\\omega_n^{\\mathrm{fem}}$ 和相应的归一化离散模态形状向量 $\\phi_n^{\\mathrm{fem}}$（通过完整节点向量的欧几里得范数进行归一化，包括零值的边界节点）。\n- 通过首先对齐 $\\phi_n^{\\mathrm{fem}}$ 的符号以最大化其与采样精确模态向量的点积，然后计算最大绝对节点误差，将离散模态形状与在相同网格节点上采样的精确模态形状进行比较。\n- 为每个测试用例计算两个指标：相对角频率误差 $|\\omega_n^{\\mathrm{fem}}-\\omega_n^{\\mathrm{exact}}|/\\omega_n^{\\mathrm{exact}}$（无量纲）和最大绝对节点模态形状误差 $\\max_i|\\phi_{n,i}^{\\mathrm{fem}}-\\phi_{n,i}^{\\mathrm{exact}}|$（无量纲），其中 $i$ 遍历所有网格节点，包括边界节点。\n\n所有测试用例均使用以下物理参数：长度 $L=1\\,\\mathrm{m}$，张力 $T=100\\,\\mathrm{N}$，线密度 $\\mu=0.01\\,\\mathrm{kg/m}$。角度量必须以弧度/秒为单位。所有误差均以无量纲实数报告。\n\n测试套件（每个测试用例是均匀单元数和模态索引的一对 $(N_e,n)$）：\n- 案例 1：$(N_e,n)=(2,1)$。\n- 案例 2：$(N_e,n)=(4,1)$。\n- 案例 3：$(N_e,n)=(8,2)$。\n- 案例 4：$(N_e,n)=(16,3)$。\n- 案例 5：$(N_e,n)=(8,7)$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含两个实数的列表 $[\\text{frequency\\_relative\\_error},\\text{mode\\_shape\\_max\\_nodal\\_error}]$。对于上述五个案例，最终输出格式必须是：\n$[[e_{1,f},e_{1,s}],[e_{2,f},e_{2,s}],[e_{3,f},e_{3,s}],[e_{4,f},e_{4,s}],[e_{5,f},e_{5,s}]]$\n其中 $e_{k,f}$ 是案例 $k$ 的相对角频率误差，$e_{k,s}$ 是最大绝对节点模态形状误差。",
            "solution": "所提出的问题是计算结构动力学中一个明确定义的练习，特别是解析解与通过有限元法 (FEM) 获得的数值近似解的比较。它具有科学依据，数学上一致，并且所有必要的参数都已提供。因此，该问题是有效的，我将进行完整的推导和求解。\n\n分析分为三个部分：首先，推导连续系统的精确特征解；其次，建立和求解离散有限元模型；第三，定义用于比较的误差度量。\n\n**1. 连续系统：精确解析解**\n\n理想拉紧弦的横向位移 $u(x,t)$ 由一维波动方程控制：\n$$\n\\mu \\frac{\\partial^2 u}{\\partial t^2} - T \\frac{\\partial^2 u}{\\partial x^2} = 0, \\quad x \\in [0, L]\n$$\n其中 $\\mu$ 是线质量密度，$T$ 是张力，$L$ 是弦的长度，$x$ 是空间坐标，$t$ 是时间。边界条件为两端固定，即 $u(0,t) = 0$ 和 $u(L,t) = 0$。\n\n为了找到固有频率和模态形状（特征解），我们使用分离变量法寻找驻波解。我们假设解的形式为 $u(x,t) = \\phi(x)q(t)$。将其代入波动方程并重新排列可得：\n$$\n\\frac{1}{q(t)} \\frac{d^2 q}{dt^2} = \\frac{T}{\\mu} \\frac{1}{\\phi(x)} \\frac{d^2 \\phi}{dx^2}\n$$\n由于左侧仅依赖于 $t$，右侧仅依赖于 $x$，因此两者都必须等于一个常数，我们将其表示为 $-\\omega^2$。这产生两个常微分方程：\n$$\n\\frac{d^2 q}{dt^2} + \\omega^2 q = 0\n$$\n$$\n\\frac{d^2 \\phi}{dx^2} + k^2 \\phi = 0, \\quad \\text{其中 } k^2 = \\frac{\\mu \\omega^2}{T}\n$$\n模态形状 $\\phi(x)$ 的空间方程具有通解：\n$$\n\\phi(x) = A \\sin(kx) + B \\cos(kx)\n$$\n应用边界条件：\n1.  $\\phi(0) = 0 \\implies A \\sin(0) + B \\cos(0) = 0 \\implies B = 0$。\n2.  $\\phi(L) = 0 \\implies A \\sin(kL) = 0$。对于非平凡解（$A \\neq 0$），必须有 $\\sin(kL) = 0$。\n\n当 $kL = n\\pi$（对于任何整数 $n=1, 2, 3, \\dots$）时，此条件得到满足。这量化了容许的波数 $k_n$：\n$$\nk_n = \\frac{n\\pi}{L}\n$$\n将其代回 $\\omega^2$ 的关系式中，我们找到了离散的角特征频率集合 $\\omega_n^{\\mathrm{exact}}$：\n$$\n(\\omega_n^{\\mathrm{exact}})^2 = \\frac{T}{\\mu} k_n^2 = \\frac{T}{\\mu} \\left(\\frac{n\\pi}{L}\\right)^2 \\implies \\omega_n^{\\mathrm{exact}} = \\frac{n\\pi}{L} \\sqrt{\\frac{T}{\\mu}}\n$$\n相应的模态形状（特征模态）由下式给出：\n$$\n\\phi_n^{\\mathrm{exact}}(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n为简单起见，振幅已设为 $1$，因为它将通过归一化来处理。为了与具有 $N_e$ 个单元（因此有 $N_e+1$ 个节点）的网格上的有限元解进行比较，我们在节点坐标 $x_i = i \\cdot (L/N_e)$（其中 $i=0, 1, \\dots, N_e$）处对该连续函数进行采样。得到的采样向量必须通过其欧几里得范数进行归一化，从而得到向量 $\\boldsymbol{\\phi}_n^{\\mathrm{exact}}$。\n\n**2. 离散系统：有限元法**\n\n我们从空间控制方程 $-T u'' = \\omega^2 \\mu u$ 的弱形式开始。对于一个满足相同齐次边界条件（即 $v(0)=v(L)=0$）的检验函数 $v(x)$，弱形式为：\n$$\n\\int_0^L v(-T u'') dx = \\int_0^L v(\\omega^2 \\mu u) dx\n$$\n对左侧进行分部积分可得：\n$$\n\\int_0^L T u' v' dx - [T u' v]_0^L = \\omega^2 \\int_0^L \\mu u v dx\n$$\n边界项 $[T u' v]_0^L$ 因 $v(0)=v(L)=0$ 而消失。弱形式变为：\n$$\n\\int_0^L T u' v' dx = \\omega^2 \\int_0^L \\mu u v dx\n$$\n我们将域 $[0,L]$ 离散为 $N_e$ 个线性单元，每个单元长度为 $h = L/N_e$。在每个单元内，位移由线性形函数 $N_1(\\xi), N_2(\\xi)$ 近似，其中 $\\xi \\in [0,h]$ 是局部坐标：$u^e(\\xi) = N_1(\\xi) d_1 + N_2(\\xi) d_2$。形函数为 $N_1(\\xi) = 1-\\xi/h$ 和 $N_2(\\xi)=\\xi/h$。\n\n单元刚度矩阵 $k^e$ 和质量矩阵 $m^e$ 是通过将近似式代入弱形式，并在一个单元上积分得到的：\n$$\nk_{ij}^e = \\int_0^h T N_i' N_j' d\\xi = \\frac{T}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n$$\nm_{ij}^e = \\int_0^h \\mu N_i N_j d\\xi = \\frac{\\mu h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n这是一致质量矩阵的公式，是精确特征分析所必需的。通过对所有 $N_e$ 个单元的贡献求和，组装成大小为 $(N_e+1) \\times (N_e+1)$ 的全局矩阵 $K$ 和 $M$。这导致了全局广义特征值问题：\n$$\nK\\boldsymbol{\\phi} = \\omega^2 M\\boldsymbol{\\phi}\n$$\n固定的边界条件 $u(0)=0$ 和 $u(L)=0$ 意味着第一个和最后一个节点位移为零。我们通过从 $K$ 和 $M$ 中移除第一行和最后一行以及第一列和最后一列来强制执行此条件，从而为内部节点创建大小为 $(N_e-1) \\times (N_e-1)$ 的缩减系统 $K_{red}\\boldsymbol{\\phi}_{red} = \\omega^2 M_{red}\\boldsymbol{\\phi}_{red}$。\n\n求解这个缩减的特征值问题，得到 $N_e-1$ 对特征值 $(\\omega_n^{\\mathrm{fem}})^2$ 和特征向量 $\\boldsymbol{\\phi}_{n,red}^{\\mathrm{fem}}$。通过在边界处用零填充缩减的特征向量，重构出完整的模态形状向量 $\\boldsymbol{\\phi}_n^{\\mathrm{fem}}$。然后，这个完整的向量通过其欧几里得范数进行归一化。\n\n**3. 误差计算**\n\n对于每个测试用例 $(N_e, n)$，我们计算两个指定的度量：\n- **相对频率误差**：第 $n$ 个有限元特征频率与第 $n$ 个精确特征频率之间的相对误差。\n$$\ne_f = \\frac{|\\omega_n^{\\mathrm{fem}} - \\omega_n^{\\mathrm{exact}}|}{\\omega_n^{\\mathrm{exact}}}\n$$\n- **最大节点模态形状误差**：首先，我们必须对齐数值计算出的特征向量的符号。一个特征向量 $\\boldsymbol{\\phi}$ 和它的负值 $-\\boldsymbol{\\phi}$ 在数学上是等价的。我们通过将 $\\boldsymbol{\\phi}_n^{\\mathrm{fem}}$ 乘以 $\\text{sign}(\\boldsymbol{\\phi}_n^{\\mathrm{fem}} \\cdot \\boldsymbol{\\phi}_n^{\\mathrm{exact}})$ 来确保一致的比较，其中 $\\boldsymbol{\\phi}_n^{\\mathrm{exact}}$ 是采样得到的精确模态形状值的向量。对齐后，误差是归一化有限元模态向量和归一化精确模态向量分量之间差的绝对值的最大值。\n$$\ne_s = \\max_i |\\phi_{n,i}^{\\mathrm{fem}} - \\phi_{n,i}^{\\mathrm{exact}}|\n$$\n这个过程为有限元模型在频率和模态形状预测方面的准确性提供了严格的量化。高阶模态和较粗的网格预计会产生更大的误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves for the eigenfrequencies and eigenmodes of a taut string using both an\n    analytical continuous model and a discrete finite element model, and computes\n    the error between them for specified test cases.\n    \"\"\"\n    # Physical parameters\n    L = 1.0  # m\n    T = 100.0  # N\n    MU = 0.01  # kg/m\n\n    # Test suite: (Number of elements Ne, Mode index n)\n    test_cases = [\n        (2, 1),\n        (4, 1),\n        (8, 2),\n        (16, 3),\n        (8, 7),\n    ]\n\n    all_results = []\n\n    for Ne, n_mode in test_cases:\n        # --- 1. Exact Analytical Solution ---\n        # Exact angular eigenfrequency\n        omega_exact = (n_mode * np.pi / L) * np.sqrt(T / MU)\n\n        # Nodal coordinates for a mesh with Ne elements\n        num_nodes = Ne + 1\n        nodes = np.linspace(0, L, num_nodes)\n\n        # Sample the exact mode shape at the nodes\n        phi_exact_sampled = np.sin(n_mode * np.pi * nodes / L)\n        \n        # Normalize the sampled exact mode shape vector by its Euclidean norm\n        norm_exact = np.linalg.norm(phi_exact_sampled)\n        # Avoid division by zero if the mode shape is accidentally all zeros\n        phi_exact_normalized = phi_exact_sampled / norm_exact if norm_exact > 0 else phi_exact_sampled\n\n        # --- 2. Finite Element Method (FEM) Solution ---\n        h = L / Ne  # Element length\n\n        # Element stiffness matrix k^e\n        k_e = (T / h) * np.array([[1, -1], [-1, 1]])\n\n        # Element consistent mass matrix m^e\n        m_e = (MU * h / 6.0) * np.array([[2, 1], [1, 2]])\n\n        # Assemble global matrices K and M\n        K_global = np.zeros((num_nodes, num_nodes))\n        M_global = np.zeros((num_nodes, num_nodes))\n\n        for i in range(Ne):\n            # Assembly indices for the two nodes of element i\n            idx = np.array([i, i + 1])\n            K_global[np.ix_(idx, idx)] += k_e\n            M_global[np.ix_(idx, idx)] += m_e\n\n        # Apply fixed-fixed boundary conditions by reducing the system\n        # (remove first and last rows/columns, corresponding to nodes 0 and Ne)\n        internal_dofs = slice(1, Ne)\n        K_red = K_global[internal_dofs, internal_dofs]\n        M_red = M_global[internal_dofs, internal_dofs]\n\n        # Solve the generalized eigenvalue problem: K_red * v = lambda * M_red * v\n        # eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # The number of internal DoFs is Ne - 1.\n        # This will fail if n_mode > Ne - 1, as the model cannot capture that mode.\n        if n_mode > Ne - 1:\n            # This case is physically not representable by the mesh,\n            # though the problem setup avoids this.\n            all_results.append([np.inf, np.inf])\n            continue\n            \n        eigenvalues, eigenvectors = eigh(K_red, M_red)\n\n        # The n-th eigenvalue (_lambda) corresponds to omega^2\n        # Use (n_mode - 1) for 0-based indexing\n        _lambda = eigenvalues[n_mode - 1]\n        omega_fem = np.sqrt(_lambda)\n\n        # Get the corresponding eigenvector for the reduced system\n        phi_fem_red = eigenvectors[:, n_mode - 1]\n\n        # Reconstruct the full mode shape vector including boundary nodes\n        phi_fem_full = np.zeros(num_nodes)\n        phi_fem_full[internal_dofs] = phi_fem_red\n        \n        # Normalize the full FEM mode shape vector by its Euclidean norm\n        norm_fem = np.linalg.norm(phi_fem_full)\n        phi_fem_normalized = phi_fem_full / norm_fem if norm_fem > 0 else phi_fem_full\n\n        # --- 3. Comparison and Error Calculation ---\n\n        # Align sign of FEM eigenvector to match the exact one\n        if np.dot(phi_fem_normalized, phi_exact_normalized)  0:\n            phi_fem_normalized *= -1.0\n\n        # Relative angular frequency error\n        freq_rel_error = np.abs(omega_fem - omega_exact) / omega_exact\n\n        # Maximum absolute nodal mode shape error\n        mode_shape_max_error = np.max(np.abs(phi_fem_normalized - phi_exact_normalized))\n\n        all_results.append([freq_rel_error, mode_shape_max_error])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{e[0]},{e[1]}]\" for e in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的离散化概念之后，我们将深入探讨有限元分析的一个核心实际问题：收敛性。本练习使用更复杂的欧拉-伯努利梁单元，引导您设计一个计算实验，以量化验证一个重要的工程直觉：高阶模态对网格的精细程度远比低阶模态更敏感。理解这一原理对于确保任何有限元模拟结果的可靠性和有效性都至关重要。",
            "id": "2414111",
            "problem": "你的任务是设计并实现一个完整的计算实验，以证明和量化对于通过有限元法 (FEM) 离散化的一维均匀欧拉-伯努利梁，高阶模态的精度比低阶模态的精度对网格细化更敏感。\n\n从适用于结构动力学的第一性原理出发，使用以下基本基础：\n- 连续介质的牛顿第二定律，表示为横向运动的惯性力与内力之间的平衡。\n- 适用于细长梁的欧拉-伯努利运动学假设。\n- 与上述原理一致的标准弱（变分）形式。\n\n你必须：\n1) 为长度为 $L$、两端为简支边界条件的均匀棱柱形欧拉-伯努利梁，建立无阻尼、无强迫的自由振动边值问题。使用横向位移场 $w(x,t)$，其控制方程为 $$\\rho A \\,\\frac{\\partial^{2} w}{\\partial t^{2}} + E I \\,\\frac{\\partial^{4} w}{\\partial x^{4}} = 0,$$ 其中 $E$ 是杨氏模量，$\\rho$ 是质量密度，$A$ 是横截面积，$I$ 是截面二次矩。简支边界条件为：$w(0,t)=0$，$w(L,t)=0$；且支座处的弯矩为零（这是弱形式中的自然边界条件）。\n2) 使用容许测试函数推导弱形式，并根据需要进行分部积分，然后使用 $C^{1}$ 连续的三次 Hermite 形函数对空间坐标进行离散化，以获得一致的单元级质量和刚度贡献。对于具有 $N$ 个等长度单元的网格，组装全局质量矩阵 $M$ 和刚度矩阵 $K$。通过消除相应的位移自由度并保持转动自由度自由，施加 $w(0,t)=0$ 和 $w(L,t)=0$ 作为本质边界条件。\n3) 认识到半离散自由振动问题可简化为广义特征值问题 $$K \\,\\phi = \\omega^{2} M \\,\\phi,$$ 其中 $\\omega$ 是自振圆频率（单位为弧度/秒），$\\phi$ 是振动模态形状。\n4) 对于简支均匀梁，其精确的自振圆频率具有如下闭合形式解 $$\\omega_{n}^{\\text{exact}} = \\frac{(n \\pi)^{2}}{L^{2}} \\sqrt{\\frac{E I}{\\rho A}}, \\quad n=1,2,3,\\dots$$ 将此作为量化 FEM 精度的参考基准。所有频率均以弧度/秒表示。\n5) 对于每个包含 $N$ 个单元的网格，通过求解广义特征值问题计算前三个自振圆频率的离散近似值，并提取 $n=1$ 和 $n=3$ 这两种模态。对于每种模态 $n$ 和每个 $N$，定义相对误差 $$\\varepsilon_{n}(N) = \\frac{\\left|\\omega_{n}^{\\text{FEM}}(N) - \\omega_{n}^{\\text{exact}}\\right|}{\\omega_{n}^{\\text{exact}}}.$$ 相对误差是无量纲的。\n6) 针对模态 $n=1$ 和 $n=3$，通过三种互补的方式量化“对网格细化的敏感性”：\n   - 敏感性比率 $r$ 定义为在所有测试网格上，比率 $\\varepsilon_{3}(N) / \\varepsilon_{1}(N)$ 的中位数。\n   - 估算的收敛阶 $p_{n}$ 通过对 $\\log_{10}\\varepsilon_{n}(N)$ 与 $\\log_{10} h$ 进行最小二乘拟合得到，其中 $h=L/N$ 是单元尺寸。将 $p_{1}$ 和 $p_{3}$ 报告为等于拟合斜率大小的正数。\n   - 细化阈值 $N_{n}^{\\star}$ 定义为测试集中使得 $\\varepsilon_{n}(N)  \\tau$ (容差 $\\tau = 5 \\times 10^{-3}$) 的最小 $N$。如果测试集中没有 $N$ 满足该容差，则设置 $N_{n}^{\\star}=-1$ 以表示“在测试网格内未达到”。\n7) 使用以下包含三组独立梁参数的测试套件来检验你的实现。所有量均采用国际单位制 (SI)：\n   - 测试案例 1：$E = 210 \\times 10^{9}\\,\\mathrm{Pa}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$b = 0.05\\,\\mathrm{m}$，$h = 0.20\\,\\mathrm{m}$，因此 $A = b h$ 且 $I = \\dfrac{b h^{3}}{12}$，$L = 2.0\\,\\mathrm{m}$。\n   - 测试案例 2：$E = 70 \\times 10^{9}\\,\\mathrm{Pa}$，$\\rho = 2700\\,\\mathrm{kg/m^{3}}$，$b = 0.03\\,\\mathrm{m}$，$h = 0.06\\,\\mathrm{m}$，因此 $A = b h$ 且 $I = \\dfrac{b h^{3}}{12}$，$L = 3.0\\,\\mathrm{m}$。\n   - 测试案例 3：$E = 200 \\times 10^{9}\\,\\mathrm{Pa}$，$\\rho = 7850\\,\\mathrm{kg/m^{3}}$，$b = 0.02\\,\\mathrm{m}$，$h = 0.05\\,\\mathrm{m}$，因此 $A = b h$ 且 $I = \\dfrac{b h^{3}}{12}$，$L = 10.0\\,\\mathrm{m}$。\n8) 对于每个测试案例，针对网格尺寸 $N \\in \\{4,\\,8,\\,16,\\,32,\\,64,\\,128\\}$ 运行 FEM。计算如上定义的量 $r$, $p_{1}$, $p_{3}$, $N_{1}^{\\star}$ 和 $N_{3}^{\\star}$。报告 $r$（四舍五入到三位小数），$p_{1}$ 和 $p_{3}$（四舍五入到两位小数），以及 $N_{1}^{\\star}$ 和 $N_{3}^{\\star}$（为整数，如果未达到则为-1）。尽管频率单位是弧度/秒，但仅报告指定的无量纲误差派生量。\n9) 最终输出格式：你的程序应生成单行输出，其中包含一个由三个内部列表组成的列表，每个测试案例对应一个内部列表，每个内部列表的形式为 $[r, p_{1}, p_{3}, N_{1}^{\\star}, N_{3}^{\\star}]$。例如，一个语法上有效的输出行形式为 $[[r_{1},p_{1,1},p_{3,1},N_{1,1}^{\\star},N_{3,1}^{\\star}],[r_{2},p_{1,2},p_{3,2},N_{1,2}^{\\star},N_{3,2}^{\\star}],[r_{3},p_{1,3},p_{3,3},N_{1,3}^{\\star},N_{3,3}^{\\star}]]$, 其中所有数字都替换为使用指定舍入规则计算出的值。角度（如果有）必须以弧度为单位；此处没有要报告的角度。不得使用百分比；所有误差都应表示为小数。\n\n你的程序必须是完全自包含的，不得读取任何输入，也不得访问网络或文件。它必须直接实现上述推导和计算，并以指定的确切格式生成最终输出。",
            "solution": "对问题陈述进行了严格审查，并确认其有效。该问题基于结构力学原理，提法恰当，目标明确，并为进行所要求的计算实验提供了所有必要信息。任务是在有限元法 (FEM) 分析中，证明和量化梁的高阶振动模态对网格细化的更高敏感性。\n\n我们从描述均匀欧拉-伯努利梁无阻尼自由振动的控制偏微分方程开始，该方程模拟了横向位移 $w(x,t)$：\n$$ \\rho A \\frac{\\partial^2 w}{\\partial t^2} + EI \\frac{\\partial^4 w}{\\partial x^4} = 0 $$\n此处，$\\rho$ 是材料密度，$A$ 是横截面积，$E$ 是杨氏模量，$I$ 是截面的二次矩。我们假设谐波运动，设解的形式为 $w(x,t) = \\phi(x) e^{i\\omega t}$，其中 $\\phi(x)$ 是模态形状，$\\omega$ 是自振圆频率。将此代入控制方程，得到不含时间的常微分方程：\n$$ EI \\frac{d^4\\phi}{dx^4} - \\omega^2 \\rho A \\phi = 0 $$\n为推导弱形式，我们乘以一个容许测试函数 $v(x)$，并在梁的长度 $L$ 上积分：\n$$ \\int_0^L v \\left( EI \\phi'''' - \\omega^2 \\rho A \\phi \\right) dx = 0 $$\n我们对包含四阶导数的项应用两次分部积分。第一次积分得到：\n$$ \\int_0^L EI \\phi'''' v \\, dx = \\left[ EI \\phi''' v \\right]_0^L - \\int_0^L EI \\phi''' v' \\, dx $$\n边界项 $\\left[ EI \\phi''' v \\right]_0^L$ 涉及剪力 $V = (EI\\phi'')'$。对剩余积分进行第二次分部积分得到：\n$$ - \\int_0^L EI \\phi''' v' \\, dx = - \\left[ EI \\phi'' v' \\right]_0^L + \\int_0^L EI \\phi'' v'' \\, dx $$\n第二个边界项 $- \\left[ EI \\phi'' v' \\right]_0^L$ 涉及弯矩 $M = EI\\phi''$。结合这些结果，弱形式为：\n$$ \\int_0^L EI \\phi'' v'' \\, dx - \\omega^2 \\int_0^L \\rho A \\phi v \\, dx + \\left[V v\\right]_0^L - \\left[M v'\\right]_0^L = 0 $$\n对于简支梁，本质边界条件是 $\\phi(0) = \\phi(L) = 0$。测试函数 $v(x)$ 也必须满足这些条件，因此 $v(0) = v(L) = 0$。这使得剪力边界项为零。支座处的弯矩为零，$M(0) = M(L) = 0$，这些是自然边界条件。由于 $v'$ 在边界处不被约束为零，这意味着项 $\\left[M v'\\right]_0^L$ 因为 $M$ 为零而消失。最终的弱形式是：\n$$ \\int_0^L EI \\phi'' v'' \\, dx = \\omega^2 \\int_0^L \\rho A \\phi v \\, dx $$\n此方程必须对所有容许测试函数 $v(x)$ 成立。\n\n对于有限元离散化，我们将梁划分为 $N$ 个等长度的单元，单元长度为 $l_e = L/N$。在每个单元内，位移场 $\\phi(x)$ 使用 $C^1$ 连续的三次 Hermite 形函数进行插值。每个节点有两个自由度 (DOF)：一个横向位移和一个转角。对于具有节点1和2的单元，局部（本地）位移向量为 $\\mathbf{d}^e = [w_1, \\theta_1, w_2, \\theta_2]^T$。位移场近似为 $\\phi(x) \\approx \\mathbf{N}(x) \\mathbf{d}^e$，其中 $\\mathbf{N}(x)$ 是 Hermite 形函数的向量。使用此近似对弱形式进行离散化，得到单元级矩阵方程 $\\mathbf{K}^e \\mathbf{d}^e = \\omega^2 \\mathbf{M}^e \\mathbf{d}^e$，其中 $\\mathbf{K}^e$ 和 $\\mathbf{M}^e$ 分别是单元刚度矩阵和一致质量矩阵。它们的标准形式为：\n$$ \\mathbf{K}^e = \\frac{EI}{l_e^3} \\begin{pmatrix} 12  6l_e  -12  6l_e \\\\ 6l_e  4l_e^2  -6l_e  2l_e^2 \\\\ -12  -6l_e  12  -6l_e \\\\ 6l_e  2l_e^2  -6l_e  4l_e^2 \\end{pmatrix} $$\n$$ \\mathbf{M}^e = \\frac{\\rho A l_e}{420} \\begin{pmatrix} 156  22l_e  54  -13l_e \\\\ 22l_e  4l_e^2  13l_e  -3l_e^2 \\\\ 54  13l_e  156  -22l_e \\\\ -13l_e  -3l_e^2  -22l_e  4l_e^2 \\end{pmatrix} $$\n全局刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$ 是通过对所有单元的贡献求和来组装的。具有 $N$ 个单元的网格有 $N+1$ 个节点和总共 $2(N+1)$ 个自由度。通过消除对应于第一个和最后一个节点的位移自由度的行和列，来施加简支边界条件 $w(0)=0$ 和 $w(L)=0$。这些端点的转动自由度保持自由。\n\n此过程导出一个简化的广义特征值问题 $\\mathbf{K}_{red} \\mathbf{\\phi}_{red} = \\omega^2 \\mathbf{M}_{red} \\mathbf{\\phi}_{red}$，通过数值求解该问题可以找到近似的自振频率 $\\omega_n^{\\text{FEM}}$。通过将这些频率与简支梁的精确解析解进行比较来评估其准确性：\n$$ \\omega_{n}^{\\text{exact}} = \\frac{(n \\pi)^{2}}{L^{2}} \\sqrt{\\frac{E I}{\\rho A}}, \\quad n=1,2,3,\\dots $$\n对于第 $n$ 阶模态和包含 $N$ 个单元的网格，相对误差为 $\\varepsilon_{n}(N) = |\\omega_{n}^{\\text{FEM}}(N) - \\omega_{n}^{\\text{exact}}|/\\omega_{n}^{\\text{exact}}$。\n\n对网格细化的敏感性通过以下三个指标对模态 $n=1$ 和 $n=3$ 进行量化：\n1.  敏感性比率，$r = \\text{median}(\\varepsilon_{3}(N) / \\varepsilon_{1}(N))$，衡量在一系列网格密度下，第三模态的误差相对于第一模态误差的大多少。$r \\gg 1$ 的值表示更高的敏感性。\n2.  收敛阶 $p_n$ 是通过对 $\\log_{10}\\varepsilon_{n}$ 与 $\\log_{10}h$ 进行线性最小二乘拟合来估算的，其中 $h=L/N$ 是单元尺寸。对于该问题，使用 Hermite 单元的有限元理论预测收敛阶为 $p=4$。\n3.  细化阈值 $N_{n}^{\\star}$ 是测试集中为使相对误差低于容差 $\\tau = 5 \\times 10^{-3}$ 所需的最小单元数 $N$。这为达到指定精度所需的计算成本提供了一个实际的度量。\n\n该计算实验包括为给定的测试案例和网格尺寸实现整个程序，计算指定的指标，并报告格式化的结果。这将从数值上证实一个原理：具有更复杂空间变化（更短波长）的高阶模态需要更精细的网格才能获得准确的解析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the computational experiment for Euler-Bernoulli beam modal analysis.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: E (Pa), rho (kg/m^3), b (m), h_section (m), L (m)\n        (210e9, 7800, 0.05, 0.20, 2.0),\n        # Case 2\n        (70e9, 2700, 0.03, 0.06, 3.0),\n        # Case 3\n        (200e9, 7850, 0.02, 0.05, 10.0),\n    ]\n\n    mesh_sizes = [4, 8, 16, 32, 64, 128]\n    tau = 5e-3\n    all_results = []\n\n    for case in test_cases:\n        E, rho, b, h_section, L = case\n        A = b * h_section\n        I = b * h_section**3 / 12\n\n        # --- Calculate exact frequencies ---\n        const = (np.pi**2 / L**2) * np.sqrt((E * I) / (rho * A))\n        omega_1_exact = (1**2) * const\n        omega_3_exact = (3**2) * const\n        \n        errors_n1 = []\n        errors_n3 = []\n\n        for N in mesh_sizes:\n            # --- Element matrices ---\n            le = L / N\n            k_factor = (E * I) / le**3\n            Ke = k_factor * np.array([\n                [12, 6*le, -12, 6*le],\n                [6*le, 4*le**2, -6*le, 2*le**2],\n                [-12, -6*le, 12, -6*le],\n                [6*le, 2*le**2, -6*le, 4*le**2]\n            ])\n            \n            m_factor = (rho * A * le) / 420\n            Me = m_factor * np.array([\n                [156, 22*le, 54, -13*le],\n                [22*le, 4*le**2, 13*le, -3*le**2],\n                [54, 13*le, 156, -22*le],\n                [-13*le, -3*le**2, -22*le, 4*le**2]\n            ])\n\n            # --- Assembly ---\n            num_dofs = 2 * (N + 1)\n            K_global = np.zeros((num_dofs, num_dofs))\n            M_global = np.zeros((num_dofs, num_dofs))\n\n            for i in range(N):\n                dof_indices = np.array([2*i, 2*i+1, 2*i+2, 2*i+3])\n                K_global[np.ix_(dof_indices, dof_indices)] += Ke\n                M_global[np.ix_(dof_indices, dof_indices)] += Me\n\n            # --- Apply Boundary Conditions ---\n            # Simply supported: w(0)=0, w(L)=0\n            # DOFs to remove are displacement at node 0 and node N\n            # DOF index for w_0 is 0. DOF for w_N is 2*N.\n            dofs_to_remove = [0, 2 * N]\n            K_red = np.delete(np.delete(K_global, dofs_to_remove, axis=0), dofs_to_remove, axis=1)\n            M_red = np.delete(np.delete(M_global, dofs_to_remove, axis=0), dofs_to_remove, axis=1)\n            \n            # --- Solve Eigenvalue Problem ---\n            # eigh returns eigenvalues in ascending order.\n            # Eigenvalues lambda are omega^2.\n            eigenvalues, _ = eigh(K_red, M_red)\n            \n            omega_1_fem = np.sqrt(eigenvalues[0])\n            omega_3_fem = np.sqrt(eigenvalues[2]) # 3rd mode is at index 2\n\n            # --- Calculate Relative Errors ---\n            error1 = np.abs(omega_1_fem - omega_1_exact) / omega_1_exact\n            error3 = np.abs(omega_3_fem - omega_3_exact) / omega_3_exact\n            errors_n1.append(error1)\n            errors_n3.append(error3)\n\n        # --- Quantify Sensitivity Metrics ---\n        errors_n1 = np.array(errors_n1)\n        errors_n3 = np.array(errors_n3)\n\n        # Sensitivity ratio r\n        ratios = errors_n3 / errors_n1\n        r = np.median(ratios)\n\n        # Convergence order p\n        h_values = L / np.array(mesh_sizes)\n        log_h = np.log10(h_values)\n        log_eps1 = np.log10(errors_n1)\n        log_eps3 = np.log10(errors_n3)\n        \n        # Fit returns [slope, intercept]; slope is the convergence order p\n        p1 = np.polyfit(log_h, log_eps1, 1)[0]\n        p3 = np.polyfit(log_h, log_eps3, 1)[0]\n        \n        # Refinement threshold N*\n        N1_star_indices = np.where(errors_n1  tau)[0]\n        N1_star = mesh_sizes[N1_star_indices[0]] if len(N1_star_indices) > 0 else -1\n        \n        N3_star_indices = np.where(errors_n3  tau)[0]\n        N3_star = mesh_sizes[N3_star_indices[0]] if len(N3_star_indices) > 0 else -1\n        \n        # --- Store and round results for the case ---\n        case_results = [\n            round(r, 3), \n            round(p1, 2), \n            round(p3, 2), \n            int(N1_star), \n            int(N3_star)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format (list of lists with no spaces).\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的工程结构往往具有可调参数，其动态特性也随之变化。本练习将引导您探索一个高级但普遍存在的现象——“模态趋近”(mode veering)，即当系统参数缓慢变化时，两个相邻的模态会迅速交换其振动特性。您将学习如何通过参数化研究追踪模态频率的变化，并使用模态置信准则（MAC）这一强大工具来量化和识别这种模态间的相互作用。",
            "id": "2414070",
            "problem": "考虑一个无阻尼、线性、时不变的多自由度结构系统，其质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 为对称正定矩阵，单位为千克；其刚度矩阵 $K(p) \\in \\mathbb{R}^{n \\times n}$ 为对称正定矩阵，单位为牛顿/米，依赖于一个标量调谐参数 $p$，单位为牛顿/米。对于每个固定的 $p$ 值，自由振动问题由以下广义特征值问题控制：\n$$\nK(p)\\,\\phi = \\lambda\\,M\\,\\phi,\n$$\n其中 $\\lambda \\ge 0$，相应的固有圆频率（单位为弧度/秒）由 $\\omega = \\sqrt{\\lambda}$ 给出。相关的振型是特征向量 $\\phi \\ne 0$，其定义可相差一个非零标量。关于质量矩阵 $M$，两个振型 $\\phi$ 和 $\\psi$ 之间的模态置信准则 (Modal Assurance Criterion, MAC) 定义为：\n$$\n\\mathrm{MAC}_M(\\phi,\\psi) = \\frac{\\left|\\phi^\\top M \\psi\\right|^2}{\\left(\\phi^\\top M \\phi\\right)\\left(\\psi^\\top M \\psi\\right)} \\in [0,1].\n$$\n振型转向 (Mode veering) 是指在参数 $p$ 缓慢变化下，两个相邻的振型在没有实际特征频率交叉的情况下交换其特性的一种现象，通常在两个子系统之间存在弱耦合时观察到。\n\n您的任务是编写一个完整的、可运行的程序，对于下面指定的每个测试用例，评估给定有限参数值集合中两个最小的固有圆频率，检测它们之间差值最小时的参数，并使用模态置信准则量化最小参数值下的第一振型与最大参数值下的第一或第二振型哪个关联性更强。\n\n对于每个测试用例 $i$，请使用所提供的确切参数集执行以下操作：\n1) 对于每个列出的 $p$ 值，求解广义特征值问题，计算两个最小的固有圆频率（单位为弧度/秒），并计算它们的绝对差值（频率间隙，单位为弧度/秒）。确定该间隙最小时的参数值 $p^\\star$（单位为牛顿/米）。如果出现平局，选择达到最小间隙的 $p$ 中最小的那个。\n2) 令 $p_{\\min}$ 为所列出的最小 $p$ 值，$p_{\\max}$ 为所列出的最大 $p$ 值。令 $\\phi_1(p_{\\min})$ 表示在 $p_{\\min}$ 处的第一振型（与最小固有圆频率相关），$\\phi_1(p_{\\max})$ 和 $\\phi_2(p_{\\max})$ 分别表示在 $p_{\\max}$ 处的第一和第二振型。计算 $\\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_1(p_{\\max})\\right)$ 和 $\\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_2(p_{\\max})\\right)$。定义一个整数交换指示符，若满足\n$$\n\\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_2(p_{\\max})\\right) > \\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_1(p_{\\max})\\right),\n$$\n则该指示符等于 $1$，否则等于 $0$。\n\n单位和报告：\n- 报告 $p^\\star$，单位为牛顿/米，四舍五入至 $6$ 位小数。\n- 报告最小频率间隙，单位为弧度/秒，四舍五入至 $6$ 位小数。\n- 报告交换指示符，为整数 $0$ 或 $1$。\n- 不涉及角度；无需角度单位。\n- 不涉及百分比。\n\n测试套件（三个用例）：\n- 用例 $1$（双自由度）：$M = \\mathrm{diag}(1,1)$ 千克，且\n$$\nK(p) = \\begin{bmatrix} p + 0.3  -0.3 \\\\ -0.3  2.0 + 0.3 \\end{bmatrix} \\ \\text{牛顿/米},\n$$\n参数集为\n$$\np \\in \\{\\, 0.5,\\, 0.8,\\, 1.1,\\, 1.4,\\, 1.7,\\, 2.0,\\, 2.3,\\, 2.6,\\, 2.9 \\,\\} \\ \\text{牛顿/米}.\n$$\n- 用例 $2$（双自由度，解耦边界情况）：$M = \\mathrm{diag}(1,1)$ 千克，且\n$$\nK(p) = \\begin{bmatrix} p  0.0 \\\\ 0.0  2.0 \\end{bmatrix} \\ \\text{牛顿/米},\n$$\n参数集同上\n$$\np \\in \\{\\, 0.5,\\, 0.8,\\, 1.1,\\, 1.4,\\, 1.7,\\, 2.0,\\, 2.3,\\, 2.6,\\, 2.9 \\,\\} \\ \\text{牛顿/米}.\n$$\n- 用例 $3$（三自由度，含一个刚性第三振型）：$M = \\mathrm{diag}(1,1,1)$ 千克，且\n$$\nK(p) = \\begin{bmatrix}\np + 0.2  -0.2  0.0 \\\\\n-0.2  2.5 + 0.2  0.0 \\\\\n0.0  0.0  40.0\n\\end{bmatrix} \\ \\text{牛顿/米},\n$$\n参数集为\n$$\np \\in \\{\\, 1.5,\\, 1.8,\\, 2.1,\\, 2.4,\\, 2.7,\\, 3.0 \\,\\} \\ \\text{牛顿/米}.\n$$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含按用例 $1$、$2$ 和 $3$ 的顺序排列的三个列表，并以逗号分隔。每个内部列表必须为 $[p^\\star,\\ \\text{gap}_{\\min},\\ \\text{exchange}]$ 的形式，其中 $p^\\star$ 和 $\\text{gap}_{\\min}$ 是四舍五入到 $6$ 位小数的浮点数，$\\text{exchange}$ 是整数 $0$ 或 $1$。\n- 例如，输出必须具有以下形式：\n$$\n[\\,[p^\\star_1,\\ \\text{gap}_{\\min,1},\\ \\text{exchange}_1],\\ [p^\\star_2,\\ \\text{gap}_{\\min,2},\\ \\text{exchange}_2],\\ [p^\\star_3,\\ \\text{gap}_{\\min,3},\\ \\text{exchange}_3]\\,],\n$$\n打印在单行上，无任何附加文本。",
            "solution": "所陈述的问题是有效的。它在科学上基于线性结构动力学原理，特别是多自由度系统自由振动的分析。质量矩阵 $M$、刚度矩阵 $K(p)$、广义特征值问题、固有频率 $\\omega$、振型 $\\phi$ 以及模态置信准则 (MAC) 的定义都是标准且正确的。所提供的矩阵是对称的，并且已经验证，对于给定的参数 $p$ 范围，它们也是正定的，这确保了一个具有实数、正频率的适定物理问题。该任务是一个清晰且客观的计算练习，可以为其确定唯一的解。我们将继续进行求解。\n\n问题的核心是求解一个结构系统的广义特征值问题：\n$$\nK(p)\\,\\phi = \\lambda\\,M\\,\\phi\n$$\n这里，$K(p)$ 是依赖于参数 $p$ 的刚度矩阵，$M$ 是质量矩阵，$\\lambda$ 是特征值（固有圆频率的平方），$\\phi$ 是特征向量（振型）。我们的任务是分析当 $p$ 在给定的离散集合上变化时，两个最低固有频率 $\\omega_1(p) = \\sqrt{\\lambda_1(p)}$ 和 $\\omega_2(p) = \\sqrt{\\lambda_2(p)}$ 的行为。\n\n将通过以下系统性步骤为每个测试用例实施解决方案：\n\n1.  **迭代特征求解**：对于指定集合 $\\{p_j\\}$ 中的每个参数值 $p$，我们构造特定的刚度矩阵 $K(p_j)$。然后，我们使用可靠的数值算法求解广义特征值问题 $K(p_j)\\phi = \\lambda M \\phi$。这将得到一组按升序排列的特征值 $\\lambda_i(p_j)$ 及其对应的 M-正交归一的特征向量 $\\phi_i(p_j)$。我们关心的是前两个特征对：$(\\lambda_1, \\phi_1)$ 和 $(\\lambda_2, \\phi_2)$。\n\n2.  **频率间隙计算**：根据特征值，我们计算两个最小的固有圆频率，$\\omega_1(p_j) = \\sqrt{\\lambda_1(p_j)}$ 和 $\\omega_2(p_j) = \\sqrt{\\lambda_2(p_j)}$。频率间隙即为绝对差值，$\\Delta\\omega(p_j) = \\omega_2(p_j) - \\omega_1(p_j)$。我们收集所有 $p_j$ 的这些间隙。\n\n3.  **最小间隙的确定**：我们搜索计算出的间隙以找到最小值。出现此最小值的参数值 $p$ 被指定为 $p^\\star$。如果多个 $p_j$ 值产生相同的最小间隙，则按照问题的决胜规则，选择最小的那个 $p_j$。最小间隙本身表示为 $\\text{gap}_{\\min}$。\n\n4.  **振型相关性分析**：此步骤量化了振型转向现象。我们确定最小参数值下的第一振型 $\\phi_1(p_{\\min})$，以及最大参数值下的前两个振型 $\\phi_1(p_{\\max})$ 和 $\\phi_2(p_{\\max})$。然后，我们采用模态置信准则，其定义为：\n    $$\n    \\mathrm{MAC}_M(\\phi_a,\\psi_b) = \\frac{\\left|\\phi_a^\\top M \\psi_b\\right|^2}{\\left(\\phi_a^\\top M \\phi_a\\right)\\left(\\psi_b^\\top M \\psi_b\\right)}\n    $$\n    该准则为任意两个振型 $\\phi_a$ 和 $\\psi_b$ 提供一个介于 $0$（不相关）和 $1$（完全相关）之间的标量值。请注意，由于数值求解器返回的特征向量已经归一化，使得 $\\phi^\\top M \\phi = 1$，因此 $\\mathrm{MAC}$ 表达式中的分母为1，这简化了计算。然而，为保证数值稳健性，我们计算完整的表达式。\n\n5.  **交换指示符**：我们计算两个 $\\mathrm{MAC}$ 值：第一个比较初始第一振型与最终第一振型，$C_{11} = \\mathrm{MAC}_M(\\phi_1(p_{\\min}), \\phi_1(p_{\\max}))$；第二个比较初始第一振型与最终第二振型，$C_{12} = \\mathrm{MAC}_M(\\phi_1(p_{\\min}), \\phi_2(p_{\\max}))$。如果初始振型与最终第二振型更为相似，则发生了振型交换。因此，交换指示符定义为一个整数，如果 $C_{12} > C_{11}$ 则为 $1$，否则为 $0$。\n\n这个完整的算法将应用于所提供的三个测试用例。每个用例的结果，包括 $p^\\star$、$\\text{gap}_{\\min}$ 和交换指示符，将按要求进行格式化和呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the modal analysis problem for the given test cases.\n    \"\"\"\n\n    def mac_m(phi_a, phi_b, M):\n        \"\"\"\n        Calculates the Mass-based Modal Assurance Criterion (MAC).\n        \n        Args:\n            phi_a (np.ndarray): First mode shape vector.\n            phi_b (np.ndarray): Second mode shape vector.\n            M (np.ndarray): Mass matrix.\n        \n        Returns:\n            float: The MAC value.\n        \"\"\"\n        numerator = np.abs(phi_a.T @ M @ phi_b)**2\n        denominator = (phi_a.T @ M @ phi_a) * (phi_b.T @ M @ phi_b)\n        \n        # Avoid division by zero in case of null vectors, though not expected here.\n        if denominator  1e-12:\n            return 0.0\n        return numerator / denominator\n\n    def process_case(M, K_func, p_values):\n        \"\"\"\n        Processes a single test case to find p_star, min_gap, and exchange_indicator.\n        \"\"\"\n        modal_data = []\n        p_values_sorted = sorted(p_values)\n\n        for p in p_values_sorted:\n            K = K_func(p)\n            \n            # Solve the generalized eigenvalue problem: K*phi = lambda*M*phi\n            # scipy.linalg.eigh returns eigenvalues in ascending order.\n            eigenvalues, eigenvectors = eigh(K, M)\n            \n            # We need the two smallest natural frequencies and their modes.\n            omega_1 = np.sqrt(eigenvalues[0])\n            omega_2 = np.sqrt(eigenvalues[1])\n            gap = omega_2 - omega_1\n            \n            phi_1 = eigenvectors[:, 0]\n            phi_2 = eigenvectors[:, 1]\n            \n            modal_data.append({'p': p, 'gap': gap, 'phi1': phi_1, 'phi2': phi_2})\n            \n        # 1) Find p_star for minimum gap, with tie-breaking for smallest p.\n        min_gap_data = min(modal_data, key=lambda x: (x['gap'], x['p']))\n        p_star = min_gap_data['p']\n        min_gap = min_gap_data['gap']\n        \n        # 2) Get modes at p_min and p_max for MAC calculation.\n        # Since p_values are sorted, modal_data is also implicitly sorted by 'p'.\n        phi1_at_p_min = modal_data[0]['phi1']\n        \n        p_max_data = modal_data[-1]\n        phi1_at_p_max = p_max_data['phi1']\n        phi2_at_p_max = p_max_data['phi2']\n        \n        # Compute MAC values to check for mode exchange.\n        mac_11 = mac_m(phi1_at_p_min, phi1_at_p_max, M)\n        mac_12 = mac_m(phi1_at_p_min, phi2_at_p_max, M)\n        \n        exchange_indicator = 1 if mac_12 > mac_11 else 0\n        \n        return [p_star, min_gap, exchange_indicator]\n\n    # Define the test cases from the problem statement.\n    # --- Case 1 ---\n    M1 = np.diag([1.0, 1.0])\n    def K1_func(p):\n        return np.array([\n            [p + 0.3, -0.3],\n            [-0.3, 2.0 + 0.3]\n        ])\n    p1_values = [0.5, 0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9]\n    \n    # --- Case 2 ---\n    M2 = np.diag([1.0, 1.0])\n    def K2_func(p):\n        return np.array([\n            [p, 0.0],\n            [0.0, 2.0]\n        ])\n    p2_values = p1_values\n    \n    # --- Case 3 ---\n    M3 = np.diag([1.0, 1.0, 1.0])\n    def K3_func(p):\n        return np.array([\n            [p + 0.2, -0.2, 0.0],\n            [-0.2, 2.5 + 0.2, 0.0],\n            [0.0, 0.0, 40.0]\n        ])\n    p3_values = [1.5, 1.8, 2.1, 2.4, 2.7, 3.0]\n    \n    test_cases = [\n        (M1, K1_func, p1_values),\n        (M2, K2_func, p2_values),\n        (M3, K3_func, p3_values)\n    ]\n\n    all_results = []\n    for M, K_func, p_values in test_cases:\n        result = process_case(M, K_func, p_values)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for res in all_results:\n        p_star, min_gap, exchange = res\n        result_strings.append(f'[{p_star:.6f},{min_gap:.6f},{exchange}]')\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}