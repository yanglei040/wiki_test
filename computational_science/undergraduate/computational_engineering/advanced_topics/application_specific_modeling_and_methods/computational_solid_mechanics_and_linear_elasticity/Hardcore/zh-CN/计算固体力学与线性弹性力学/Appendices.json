{
    "hands_on_practices": [
        {
            "introduction": "在我们信任一个复杂的模拟之前，我们必须首先确保其最基本的构建块——有限元——已正确实现。薄片测试 (patch test) 是一个基本的基准测试，它验证了单元精确再现简单、恒定应变状态的能力，这是保证收敛的必要条件。本练习将指导您为四节点四边形单元（许多计算力学程序的核心）实现这一关键测试。",
            "id": "2378079",
            "problem": "要求您实现一个完整的、可运行的程序，在线性弹性、小应变、平面应力分析的背景下，检查一个自定义的四节点等参四边形有限元是否通过常应变片检验。该程序必须是自包含的，并针对指定的测试套件产生单行输出。其目的是验证该单元能在数值容差范围内再现仿射位移场并产生常应变。\n\n从适用于计算固体力学的第一性原理开始：\n- 在没有体力的情况下，静力学中的线性动量平衡方程为 $\\,\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}\\,$，作用于域 $\\,\\Omega\\,$，其中 $\\,\\boldsymbol{\\sigma}\\,$ 是柯西应力张量。小应变运动学给出无穷小应变张量 $\\,\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}})\\,$，其中 $\\,\\mathbf{u}(\\mathbf{x})\\,$ 是位移场。\n- 对于平面应力线弹性问题，各点的本构关系为 $\\,\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}\\,$，其中 $\\,\\mathbf{D}\\,$ 是由杨氏模量 $\\,E\\,$ 和泊松比 $\\,\\nu\\,$ 定义的对称材料矩阵。\n- 弱形式的伽辽金有限元离散化导出了线性系统 $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$，其中 $\\,\\mathbf{K} = \\sum_{e} \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}\\,\\mathrm{d}A\\,$，$\\,\\mathbf{d}\\,$ 是节点位移向量，$\\,\\mathbf{f}\\,$ 是外力向量，$\\,A_e\\,$ 是单元面积，$\\,\\mathbf{B}\\,$ 将节点位移映射到工程应变 $\\,\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx},\\,\\varepsilon_{yy},\\,\\gamma_{xy}]^{\\mathsf{T}}\\,$，其中 $\\,\\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x\\,$。映射和积分将使用双单位正方形上的等参双线性形函数和标准的二乘二高斯求积法进行。\n\n您的程序必须：\n- 在自然坐标 $\\,(\\xi,\\eta)\\,$ 中使用双线性插值实现一个四节点四边形等参单元，并使用 $\\,2 \\times 2\\,$ 高斯求积，求积点位于 $\\,\\xi,\\eta \\in \\{\\pm 1/\\sqrt{3}\\}\\,$ 且权重为单位权重。必须为每个求积点计算从 $\\,(\\xi,\\eta)\\,$ 到物理坐标 $\\, (x,y)\\,$ 的雅可比映射，以评估 $\\,\\mathbf{B}\\,$ 和 $\\,\\det \\mathbf{J}\\,$。\n- 为每个测试案例的网格组装全局刚度矩阵 $\\,\\mathbf{K}\\,$，并通过在网格的外边界上指定位移来施加狄利克雷边界条件。不存在体力，也不施加诺伊曼牵引力。程序应通过识别仅属于一个单元的边，从网格连接关系中以算法方式确定外边界节点。\n- 在计算域的边界上施加一个仿射位移场\n  $$u(x,y) = \\gamma + \\alpha\\,x + \\beta\\,y,\\quad v(x,y) = \\zeta + \\delta\\,x + \\varepsilon\\,y,$$\n  其中 $\\,u\\,$ 和 $\\,v\\,$ 分别是位移的 $x$ 和 $y$ 分量。该场会引起一个常应变\n  $$\\varepsilon_{xx} = \\alpha,\\quad \\varepsilon_{yy} = \\varepsilon,\\quad \\gamma_{xy} = \\beta + \\delta.$$\n  使用常数 $\\,\\alpha = 1.0\\times 10^{-3},\\,\\beta = -2.0\\times 10^{-4},\\,\\delta = 3.0\\times 10^{-4},\\,\\varepsilon = 5.0\\times 10^{-4},\\,\\gamma = 2.5\\times 10^{-3},\\,\\zeta = -1.1\\times 10^{-3}\\,$。坐标单位为米，位移必须以米为单位进行计算。\n- 求解线性系统以获得自由度，并计算：\n  1. 最大节点位移绝对误差\n     $$e_u = \\max_{i}\\, \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert,$$\n     其中 $\\,d_i^{\\text{exact}}\\,$ 是由仿射场得到的精确节点位移。\n  2. 计算得到的高斯点工程应变与目标常应变之间的最大绝对偏差\n     $$e_{\\varepsilon} = \\max_{e,\\,g,\\,k} \\left\\lvert \\varepsilon_{k}^{(e,g)} - \\varepsilon_{k}^{\\text{target}} \\right\\rvert,$$\n     其中 $\\,k \\in \\{xx,yy,xy\\}\\,$，$\\,e\\,$ 是单元索引，$\\,g\\,$ 是高斯点索引。\n- 所有测试案例的材料参数：杨氏模量 $\\,E = 210 \\times 10^{9}\\,$ 帕斯卡和泊松比 $\\,\\nu = 0.30\\,$（平面应力）。虽然指定了物理单位，但要求的输出是无量纲的布尔值。\n\n如果一个测试案例同时满足 $\\,e_u \\le 10^{-10}\\,$ 和 $\\,e_{\\varepsilon} \\le 10^{-10}\\,$，则称其通过常应变片检验。\n\n测试套件（三个网格；所有坐标单位为米；单元连接关系使用从零开始的逆时针顺序节点索引）：\n- 案例 1（单个扭曲四边形）：\n  - 节点：\n    - $0$: $(0.0,\\,0.0)$\n    - $1$: $(1.2,\\,0.1)$\n    - $2$: $(1.0,\\,1.1)$\n    - $3$: $(0.1,\\,0.9)$\n  - 单元：\n    - $[0,\\,1,\\,2,\\,3]$\n- 案例 2（单位正方形的 $2 \\times 2$ 网格）：\n  - 节点：\n    - $0$: $(0.0,\\,0.0)$, $1$: $(0.5,\\,0.0)$, $2$: $(1.0,\\,0.0)$\n    - $3$: $(0.0,\\,0.5)$, $4$: $(0.5,\\,0.5)$, $5$: $(1.0,\\,0.5)$\n    - $6$: $(0.0,\\,1.0)$, $7$: $(0.5,\\,1.0)$, $8$: $(1.0,\\,1.0)$\n  - 单元：\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$, $[3,\\,4,\\,7,\\,6]$, $[4,\\,5,\\,8,\\,7]$\n- 案例 3（一个平行四边形被一条内部分割成两个四边形）：\n  - 角点：$\\mathrm{A}=(0.0,\\,0.0)$, $\\mathrm{B}=(2.0,\\,0.3)$, $\\mathrm{C}=(2.2,\\,1.2)$, $\\mathrm{D}=(0.2,\\,0.9)$。\n  - $\\mathrm{AB}$ 和 $\\mathrm{DC}$ 边中点上的附加点：$\\mathrm{M}_{\\mathrm{AB}}=(1.0,\\,0.15)$, $\\mathrm{M}_{\\mathrm{DC}}=(1.2,\\,1.05)$。\n  - 节点：\n    - $0$: $\\mathrm{A}$, $1$: $\\mathrm{M}_{\\mathrm{AB}}$, $2$: $\\mathrm{B}$, $3$: $\\mathrm{D}$, $4$: $\\mathrm{M}_{\\mathrm{DC}}$, $5$: $\\mathrm{C}$\n  - 单元：\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$\n\n您的程序必须为每个测试案例计算通过或失败的布尔值，并产生一行包含三个结果的输出，结果为逗号分隔的列表，并用方括号括起来，例如 $[\\,\\text{True},\\text{False},\\text{True}\\,]$。不允许有其他输出或文本。这些布尔值分别反映三个案例是否都满足 $\\,e_u \\le 10^{-10}\\,$ 和 $\\,e_{\\varepsilon} \\le 10^{-10}\\,$。\n\n角度单位不适用。如果打印物理量，单位将是国际单位制（SI）；然而，要求的输出是无单位的布尔值。确保数值计算在量纲上保持一致，几何形状使用米，材料刚度使用帕斯卡。程序必须是确定性的，并且不应需要任何用户输入。",
            "solution": "所提出的问题要求实现一个被称为常应变片检验（constant-strain patch test）的验证过程，用于一个四节点等参四边形有限元。该检验是计算力学中的一个基本基准测试，旨在确保有限元列式能够精确地再现常应变状态，这是收敛的必要条件。此分析是在二维、小应变、线弹性、平面应力理论的框架下进行的。我将首先概述理论基础，然后详细说明实现所需的算法步骤。\n\n问题陈述在科学上是合理的，并且是适定的（well-posed）。它提供了所有必要的数据，包括三个不同网格的几何描述、材料属性、一个指定的仿射位移场，以及用于通过检验的精确标准。这是验证有限元代码中的一个标准问题。\n\n**1. 理论公式**\n\n用于固体力学的有限元法（FEM）的基础在于平衡方程弱形式的离散化。对于一个没有体力的静态问题，虚功原理指出，对于任何运动学上容许的虚位移场 $\\,\\delta\\mathbf{u}\\,$，内虚功必须等于外虚功。在没有体力且域边界上没有表面力的情况下，这简化为：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, \\mathrm{d}V = 0\n$$\n其中 $\\,\\boldsymbol{\\sigma}\\,$ 是柯西应力张量，$\\,\\delta\\boldsymbol{\\varepsilon}\\,$ 是对应于 $\\,\\delta\\mathbf{u}\\,$ 的虚应变张量。\n\n**1.1. 等参单元公式**\n\n我们采用一个四节点四边形单元。单元内的几何形状和位移场使用同一组形函数从节点值插值得到，因此称为“等参”。该单元在一个具有自然坐标 $\\,(\\xi, \\eta)\\,$ 的双单位正方形父域中定义，其中 $\\,\\xi, \\eta \\in [-1, 1]\\,$。\n\n四个节点 $\\,(i=1, 2, 3, 4)\\,$ 的双线性形函数 $\\,N_i(\\xi, \\eta)\\,$ 为：\n$$\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad\\quad N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad\\quad N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n单元内任意点的物理坐标 $\\,(x, y)\\,$ 通过自然坐标映射得到：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad\\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n其中 $\\,(x_i, y_i)\\,$ 是单元节点的坐标。\n\n类似地，单元内的位移场 $\\,(u, v)\\,$ 从节点位移 $\\,(u_i, v_i)\\,$ 插值得到：\n$$\nu(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i \\quad\\quad v(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) v_i\n$$\n\n**1.2. 应变-位移关系**\n\n工程应变 $\\,\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}\\,$ 由位移场的空间导数定义：\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\n$$\n为了计算这些导数，我们需要使用链式法则，将关于物理坐标 $\\,(x, y)\\,$ 的导数与关于自然坐标 $\\,(\\xi, \\eta)\\,$ 的导数联系起来。这种关系通过雅可比矩阵 $\\,\\mathbf{J}\\,$ 表示：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} = \n\\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix}\n$$\n$\\,\\mathbf{J}\\,$ 的分量通过对几何映射进行微分求得，例如 $\\,\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i\\,$。对 $\\,\\mathbf{J}\\,$ 求逆可得：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix}\n$$\n现在，应变可以通过应变-位移矩阵 $\\,\\mathbf{B}\\,$ 表示为节点位移 $\\,\\mathbf{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^{\\mathsf{T}}\\,$ 的函数：\n$$\n\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\n$$\n矩阵 $\\,\\mathbf{B}\\,$ 是一个 $\\,3 \\times 8\\,$ 的矩阵，由四个 $\\,3 \\times 2\\,$ 的块组成，$\\,\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\\,$，其中每个块 $\\,\\mathbf{B}_i\\,$ 由下式给出：\n$$\n\\mathbf{B}_i = \n\\begin{bmatrix}\n\\frac{\\partial N_i}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial N_i}{\\partial y} \\\\\n\\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x}\n\\end{bmatrix}\n$$\n形函数的空间导数，例如 $\\,\\frac{\\partial N_i}{\\partial x}\\,$，使用雅可比矩阵的逆计算：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\n\n**1.3. 单元刚度矩阵与系统组装**\n\n单元刚度矩阵 $\\,\\mathbf{K}^e\\,$ 关联了一个单元的节点力与节点位移。它通过将离散公式代入弱形式积分得到：\n$$\n\\mathbf{K}^e = \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}A\n$$\n其中 $\\,A_e\\,$ 是单元面积，$\\,\\mathbf{D}\\,$ 是平面应力的材料本构矩阵：\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \n\\begin{bmatrix} \n1 & \\nu & 0 \\\\ \n\\nu & 1 & 0 \\\\ \n0 & 0 & \\frac{1-\\nu}{2} \n\\end{bmatrix}\n$$\n其中 $\\,E\\,$ 是杨氏模量，$\\,\\nu\\,$ 是泊松比。\n该积分使用高斯求积进行数值计算。变换到父域：\n$$\n\\mathbf{K}^e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}(\\xi, \\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\n使用 $\\,2 \\times 2\\,$ 高斯求积，求积点位于 $\\,(\\xi_g, \\eta_g) \\in \\{\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}\\}\\,$ 且权重为单位权重 $\\,(w_g = 1)\\,$：\n$$\n\\mathbf{K}^e \\approx \\sum_{g=1}^{4} \\mathbf{B}(\\xi_g, \\eta_g)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi_g, \\eta_g) \\det(\\mathbf{J}(\\xi_g, \\eta_g)) w_g\n$$\n整个网格的全局刚度矩阵 $\\,\\mathbf{K}\\,$ 通过将每个单元刚度矩阵 $\\,\\mathbf{K}^e\\,$ 的贡献组装到相应的全局自由度中形成。这得到了线性系统 $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$。\n\n**2. 片检验程序**\n\n片检验（Patch test）验证单元是否能精确表示常应变状态。这是通过在一片单元的边界上施加一个与常应变场对应的位移场来实现的。然后计算内部节点的有限元解，并与精确的解析解进行比较。\n\n**2.1. 边界条件与系统求解**\n\n在网格的边界节点上施加一个仿射位移场：\n$$\nu(x,y) = \\gamma + \\alpha x + \\beta y \\quad\\quad v(x,y) = \\zeta + \\delta x + \\varepsilon y\n$$\n该位移场对应一个常工程应变状态：\n$$\n\\varepsilon_{xx}^{\\text{target}} = \\alpha, \\quad \\varepsilon_{yy}^{\\text{target}} = \\varepsilon, \\quad \\gamma_{xy}^{\\text{target}} = \\beta + \\delta\n$$\n程序必须首先以算法方式识别边界节点。这通过遍历所有单元并计算每条边的出现次数来完成。只属于一个单元的边是边界边，其组成节点是边界节点。\n\n全局系统 $\\,\\mathbf{K}\\mathbf{d} = \\mathbf{f}\\,$ 被划分为自由自由度（free DOFs）和指定自由度（prescribed DOFs），分别用下标 $\\,f\\,$ 和 $\\,p\\,$ 表示：\n$$\n\\begin{bmatrix} \\mathbf{K}_{ff} & \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf} & \\mathbf{K}_{pp} \\end{bmatrix}\n\\begin{Bmatrix} \\mathbf{d}_f \\\\ \\mathbf{d}_p \\end{Bmatrix} =\n\\begin{Bmatrix} \\mathbf{f}_f \\\\ \\mathbf{f}_p \\end{Bmatrix}\n$$\n边界节点的位移 $\\,\\mathbf{d}_p\\,$ 从指定的仿射场中得知。由于没有外部节点力，自由自由度对应的力向量 $\\,\\mathbf{f}_f\\,$ 为零。需求解的未知内部节点位移 $\\,\\mathbf{d}_f\\,$ 的系统是：\n$$\n\\mathbf{K}_{ff} \\mathbf{d}_f = - \\mathbf{K}_{fp} \\mathbf{d}_p\n$$\n这个较小的线性系统被求解以获得 $\\,\\mathbf{d}_f\\,$。\n\n**2.2. 误差评估**\n\n一旦计算出位移 $\\,\\mathbf{d}_f\\,$，就组装出完整的位移向量 $\\,\\mathbf{d}\\,$。然后计算两个误差度量：\n1.  **位移误差 $\\,e_u\\,$**：在所有节点上，计算得到的节点位移与仿射场得到的精确解析位移之间的最大绝对差。\n    $$\n    e_u = \\max_{i} \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert\n    $$\n    一个正确的公式应该能精确地再现仿射位移场，因此 $\\,e_u\\,$ 应该在机器精度级别。\n2.  **应变误差 $\\,e_{\\varepsilon}\\,$**：在每个单元的每个高斯点上，计算得到的应变与目标常应变之间的最大绝对差。\n    $$\n    e_{\\varepsilon} = \\max_{e,g,k} \\left\\lvert \\varepsilon_k^{(e,g)} - \\varepsilon_k^{\\text{target}} \\right\\rvert\n    $$\n    这里，$\\,\\varepsilon_k^{(e,g)}\\,$ 是单元 $\\,e\\,$ 的高斯点 $\\,g\\,$ 处的第 $\\,k\\,$ 个应变分量（xx, yy 或 xy），使用 $\\,\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\\,$ 计算。这个误差也应该接近于零。\n\n如果 $\\,e_u\\,$ 和 $\\,e_{\\varepsilon}\\,$ 都低于指定的容差 $\\,10^{-10}\\,$，则测试案例通过。这确认了单元满足片检验的能力。接下来的实现将遵循这一严谨的程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: single distorted quadrilateral\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.2, 0.1], [1.0, 1.1], [0.1, 0.9]\n            ]),\n            \"elements\": np.array([[0, 1, 2, 3]])\n        },\n        # Case 2: 2x2 mesh of the unit square\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n                [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n                [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4],\n                [3, 4, 7, 6], [4, 5, 8, 7]\n            ])\n        },\n        # Case 3: parallelogram split into two quads\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.0, 0.15], [2.0, 0.3],\n                [0.2, 0.9], [1.2, 1.05], [2.2, 1.2]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4]\n            ])\n        }\n    ]\n\n    # Material parameters\n    E = 210.0e9  # Pascals\n    nu = 0.30\n\n    # Affine displacement field parameters\n    affine_coeffs = {\n        'alpha': 1.0e-3, 'beta': -2.0e-4, 'gamma': 2.5e-3,\n        'delta': 3.0e-4, 'epsilon': 5.0e-4, 'zeta': -1.1e-3\n    }\n    \n    # Pass/fail tolerance\n    tolerance = 1.0e-10\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        elements = case[\"elements\"]\n        passed = run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance)\n        results.append(passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance):\n    \"\"\"\n    Performs the patch test for a single mesh configuration.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    num_dofs = 2 * num_nodes\n    \n    # 1. Material matrix for plane stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    # 2. Gaussian quadrature points and weights (2x2)\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    # 3. Assemble global stiffness matrix K\n    K_global = np.zeros((num_dofs, num_dofs))\n    element_gauss_data = [] # To store B matrices and detJ for strain calculations\n\n    for el_nodes_indices in elements:\n        el_nodes_coords = nodes[el_nodes_indices]\n        K_element = np.zeros((8, 8))\n        gauss_data_for_element = []\n\n        for i, (xi, eta) in enumerate(gauss_points):\n            # Shape function derivatives w.r.t. natural coordinates\n            dN_dxi_eta = 0.25 * np.array([\n                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n            ])\n            \n            # Jacobian matrix\n            J = dN_dxi_eta @ el_nodes_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Shape function derivatives w.r.t. physical coordinates\n            dN_dxy = invJ @ dN_dxi_eta\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, 8))\n            for j in range(4):\n                B[0, 2*j] = dN_dxy[0, j]\n                B[1, 2*j+1] = dN_dxy[1, j]\n                B[2, 2*j] = dN_dxy[1, j]\n                B[2, 2*j+1] = dN_dxy[0, j]\n            \n            K_element += B.T @ D @ B * detJ * gauss_weights[i]\n            gauss_data_for_element.append({'B': B, 'detJ': detJ})\n        \n        element_gauss_data.append(gauss_data_for_element)\n\n        # Assemble into global K\n        dof_indices = np.array([[2*i, 2*i+1] for i in el_nodes_indices]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_element\n        \n    # 4. Apply boundary conditions\n    boundary_nodes = find_boundary_nodes(elements)\n    prescribed_dofs = []\n    for node_idx in boundary_nodes:\n        prescribed_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, prescribed_dofs)\n\n    # 5. Calculate exact displacements and solve system\n    d_exact = calculate_exact_displacements(nodes, affine_coeffs)\n    d_p = d_exact[prescribed_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n\n    # Handle case where there are no free DOFs (e.g., single element mesh)\n    if free_dofs.size > 0:\n        F_eff = -K_fp @ d_p\n        d_f = np.linalg.solve(K_ff, F_eff)\n    else:\n        d_f = np.array([])\n    \n    d_solution = np.zeros(num_dofs)\n    d_solution[prescribed_dofs] = d_p\n    if free_dofs.size > 0:\n        d_solution[free_dofs] = d_f\n\n    # 6. Calculate errors\n    # Displacement error\n    e_u = np.max(np.abs(d_solution - d_exact))\n    \n    # Strain error\n    alpha, beta, delta, epsilon = [affine_coeffs[k] for k in ['alpha', 'beta', 'delta', 'epsilon']]\n    strain_target = np.array([alpha, epsilon, beta + delta])\n    \n    e_strain = 0.0\n    for i, el_nodes_indices in enumerate(elements):\n        el_dof_indices = np.array([[2*j, 2*j+1] for j in el_nodes_indices]).flatten()\n        d_element = d_solution[el_dof_indices]\n        \n        for gauss_data in element_gauss_data[i]:\n            B = gauss_data['B']\n            strain_computed = B @ d_element\n            e_strain = max(e_strain, np.max(np.abs(strain_computed - strain_target)))\n\n    return e_u = tolerance and e_strain = tolerance\n\ndef find_boundary_nodes(elements):\n    \"\"\"\n    Identifies boundary nodes from an element connectivity list.\n    \"\"\"\n    edge_counts = collections.defaultdict(int)\n    for el in elements:\n        for i in range(4):\n            n1 = el[i]\n            n2 = el[(i + 1) % 4]\n            edge = tuple(sorted((n1, n2)))\n            edge_counts[edge] += 1\n            \n    boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n    boundary_nodes = set()\n    for edge in boundary_edges:\n        boundary_nodes.update(edge)\n        \n    return boundary_nodes\n\ndef calculate_exact_displacements(nodes, coeffs):\n    \"\"\"\n    Calculates exact nodal displacements from the affine field.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    d_exact = np.zeros(2 * num_nodes)\n    alpha, beta, gamma = coeffs['alpha'], coeffs['beta'], coeffs['gamma']\n    delta, epsilon, zeta = coeffs['delta'], coeffs['epsilon'], coeffs['zeta']\n    \n    for i in range(num_nodes):\n        x, y = nodes[i, 0], nodes[i, 1]\n        d_exact[2*i] = gamma + alpha * x + beta * y  # u\n        d_exact[2*i+1] = zeta + delta * x + epsilon * y # v\n        \n    return d_exact\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个正确的单元是不够的；我们还必须验证我们的整个数值方法在离散化加密时能否收敛到真实的物理解。本练习涉及解决弹性力学中的一个经典问题——受压厚壁圆筒（Lamé 问题）——我们拥有该问题的精确解析解。通过将您的有限差分法数值结果与不同网格密度下的精确解进行比较，您将进行一次收敛性研究，并学习如何量化计算模型的准确性。",
            "id": "2378059",
            "problem": "您需要设计并实现一个完整的、可运行的程序，该程序为一个具有闭式解析解的线性弹性边界值问题进行网格收敛性研究。使用受压的轴对称厚壁圆筒（也称为 Lame 问题）作为验证问题。此任务必须基于计算固体力学和线性弹性的第一性原理进行开发，并且程序必须将数值解与解析解进行比较，以量化网格细化时的收敛性。\n\n物理设置为一个各向同性、均匀、线性弹性的厚壁圆筒，其内半径为 $a$，外半径为 $b$，轴向厚度为单位长度，且无体力。该圆筒在 $r=a$ 处承受均匀内压 $p_i$，在 $r=b$ 处承受均匀外压 $p_o$。考虑轴对称、平面应变情况。未知量是径向位移 $u(r)$，其中 $r$ 是径向坐标。\n\n从以下基本原理出发：\n- 圆柱坐标系中轴对称且无体力情况下的线性动量平衡（平衡方程）：$d\\sigma_r/dr + (\\sigma_r - \\sigma_\\theta)/r = 0$。\n- 轴对称条件下的运动学定义：$\\varepsilon_r = du/dr$ 和 $\\varepsilon_\\theta = u/r$。\n- 平面应变下各向同性材料的线性弹性（胡克定律）本构模型，其中 Lamé 常数为 $\\lambda$ 和 $\\mu$：$\\sigma_r = \\lambda (\\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z) + 2 \\mu \\varepsilon_r$ 和 $\\sigma_\\theta = \\lambda (\\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z) + 2 \\mu \\varepsilon_\\theta$，在平面应变中 $\\varepsilon_z = 0$。常数为 $\\mu = E/[2(1+\\nu)]$ 和 $\\lambda = E \\nu / [(1+\\nu)(1-2\\nu)]$，其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 自然（力）边界条件：$\\sigma_r(a) = -p_i$ 和 $\\sigma_r(b) = -p_o$。\n\n需要执行的任务：\n1. 从上述原理推导出在 $r \\in [a,b]$ 上关于 $u(r)$ 的强形式控制常微分方程，以及用 $u$ 和 $du/dr$ 表示的相关边界条件。\n2. 推导应力场 $\\sigma_r(r)$ 和 $\\sigma_\\theta(r)$ 关于 $a$、$b$、$p_i$ 和 $p_o$ 的解析解。\n3. 使用具有 $N$ 个区间和网格间距 $h = (b-a)/N$ 的均匀径向网格，构建强形式的有限差分离散化。对内部使用标准的二阶中心差分格式，在边界处使用二阶单边有限差分近似 $du/dr$ 来施加力边界条件。组装并求解得到的线性系统，以获得节点 $r_i = a + i h$ 处的节点位移 $\\{u_i\\}_{i=0}^N$。\n4. 根据离散解，使用 $\\sigma_r = (\\lambda + 2\\mu)\\,u' + \\lambda\\,u/r$ 和 $\\sigma_\\theta = \\lambda\\,u' + (\\lambda + 2\\mu)\\,u/r$ 计算节点的数值应力，其中 $u'$ 通过一致的二阶有限差分（内部为中心差分，边界为单边差分）进行近似。\n5. 计算所有节点上径向应力的相对均方根（RMS）误差：\n$$\n\\mathrm{err} = \\frac{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r,i}^{\\mathrm{num}} - \\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}.\n$$\n误差是无量纲的。\n\n您的程序必须运行以下测试套件，并将每个案例的误差以单行、方括号括起来的逗号分隔列表形式输出：\n- 案例 1 (正常路径): $a = 0.5\\,\\mathrm{m}$，$b = 1.0\\,\\mathrm{m}$，$p_i = 1.0\\times 10^{6}\\,\\mathrm{Pa}$，$p_o = 0.0\\,\\mathrm{Pa}$，$E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$，$\\nu = 0.30$，$N = 10$。\n- 案例 2 (网格细化): 与案例 1 相同，但 $N = 20$。\n- 案例 3 (网格更细化): 与案例 1 相同，但 $N = 40$。\n- 案例 4 (边缘网格尺寸): 与案例 1 相同，但 $N = 2$。\n- 案例 5 (不同几何形状和载荷): $a = 0.3\\,\\mathrm{m}$，$b = 1.0\\,\\mathrm{m}$，$p_i = 2.0\\times 10^{6}\\,\\mathrm{Pa}$，$p_o = 0.5\\times 10^{6}\\,\\mathrm{Pa}$，$E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$，$\\nu = 0.25$，$N = 40$。\n- 案例 6 (均匀压力一致性): $a = 0.7\\,\\mathrm{m}$，$b = 1.0\\,\\mathrm{m}$，$p_i = 1.0\\times 10^{5}\\,\\mathrm{Pa}$，$p_o = 1.0\\times 10^{5}\\,\\mathrm{Pa}$，$E = 1.0\\times 10^{11}\\,\\mathrm{Pa}$，$\\nu = 0.33$，$N = 20$。\n\n物理单位：\n- 半径 $a$ 和 $b$ 的单位必须是 $\\mathrm{m}$。\n- 压力 $p_i$ 和 $p_o$ 的单位必须是 $\\mathrm{Pa}$。\n- 杨氏模量 $E$ 的单位必须是 $\\mathrm{Pa}$。\n- 泊松比 $\\nu$ 是无量纲的。\n- 位移 $u$ 的单位是 $\\mathrm{m}$。\n- 报告的误差是无量纲的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $\\left[\\mathrm{err}_1,\\mathrm{err}_2,\\dots\\right]$，其中每个条目是与上述案例顺序对应的浮点数误差。",
            "solution": "所提出的问题是线性弹性力学中一个标准的边界值问题，特别是受压厚壁圆筒的 Lamé 问题。我们将首先验证问题陈述，然后进行所需的推导和数值实现计划，因为该问题是适定的且在科学上是合理的。\n\n**1. 控制方程（强形式）的推导**\n\n分析从所提供的连续介质力学的基本原理开始。\n在没有体力的情况下，轴对称圆柱坐标系中的线性动量平衡由下式给出：\n$$ \\frac{d\\sigma_r}{dr} + \\frac{\\sigma_r - \\sigma_\\theta}{r} = 0 \\quad (1) $$\n连接应变与位移的运动学关系为：\n$$ \\varepsilon_r = \\frac{du}{dr}, \\quad \\varepsilon_\\theta = \\frac{u}{r} \\quad (2) $$\n材料是各向同性的线弹性体，状态为平面应变（$\\varepsilon_z = 0$）。本构关系（Hooke 定律）为：\n$$ \\sigma_r = \\lambda (\\varepsilon_r + \\varepsilon_\\theta) + 2 \\mu \\varepsilon_r \\quad (3a) $$\n$$ \\sigma_\\theta = \\lambda (\\varepsilon_r + \\varepsilon_\\theta) + 2 \\mu \\varepsilon_\\theta \\quad (3b) $$\n其中 $\\lambda$ 和 $\\mu$ 是 Lamé 的第一和第二参数。\n\n首先，我们将(2)式代入(3)式，用径向位移 $u(r)$ 表示应力：\n$$ \\sigma_r = \\lambda \\left(\\frac{du}{dr} + \\frac{u}{r}\\right) + 2 \\mu \\frac{du}{dr} = (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\quad (4a) $$\n$$ \\sigma_\\theta = \\lambda \\left(\\frac{du}{dr} + \\frac{u}{r}\\right) + 2 \\mu \\frac{u}{r} = \\lambda \\frac{du}{dr} + (\\lambda + 2\\mu) \\frac{u}{r} \\quad (4b) $$\n接下来，我们将这些应力表达式代入平衡方程(1)。我们需要 $\\sigma_r$ 的导数：\n$$ \\frac{d\\sigma_r}{dr} = \\frac{d}{dr} \\left( (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\right) = (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\lambda \\left( \\frac{1}{r}\\frac{du}{dr} - \\frac{u}{r^2} \\right) $$\n以及应力差：\n$$ \\sigma_r - \\sigma_\\theta = \\left( (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\right) - \\left( \\lambda \\frac{du}{dr} + (\\lambda + 2\\mu) \\frac{u}{r} \\right) = 2\\mu \\left( \\frac{du}{dr} - \\frac{u}{r} \\right) $$\n将这些代入平衡方程(1)中：\n$$ \\left( (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\frac{\\lambda}{r}\\frac{du}{dr} - \\frac{\\lambda u}{r^2} \\right) + \\frac{1}{r} \\left( 2\\mu \\left( \\frac{du}{dr} - \\frac{u}{r} \\right) \\right) = 0 $$\n合并各项：\n$$ (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\frac{(\\lambda + 2\\mu)}{r}\\frac{du}{dr} - \\frac{(\\lambda + 2\\mu)}{r^2}u = 0 $$\n由于对于任何物理材料 $\\lambda + 2\\mu \\neq 0$，我们可以除以该项，得到关于 $u(r)$ 的控制常微分方程的强形式：\n$$ \\frac{d^2u}{dr^2} + \\frac{1}{r}\\frac{du}{dr} - \\frac{u}{r^2} = 0 \\quad (5) $$\n该方程在域 $r \\in [a, b]$ 上有效。边界条件以力的形式给出，即 $\\sigma_r(a) = -p_i$ 和 $\\sigma_r(b) = -p_o$。使用方程(4a)，我们用 $u(r)$ 及其导数表示这些条件：\n$$ (\\lambda + 2\\mu) \\frac{du}{dr}\\bigg|_{r=a} + \\frac{\\lambda}{a} u(a) = -p_i \\quad (6a) $$\n$$ (\\lambda + 2\\mu) \\frac{du}{dr}\\bigg|_{r=b} + \\frac{\\lambda}{b} u(b) = -p_o \\quad (6b) $$\n\n**2. 解析解的推导**\n\n方程(5)是一个 Cauchy-Euler 方程。其通解形式为 $u(r) = C_1 r + C_2/r$。为了确定积分常数，可以使用边界条件(6a)和(6b)。然而，直接求解应力场的常数更为直接。与此位移形式一致的应力场必须具有以下形式：\n$$ \\sigma_r(r) = A - \\frac{B}{r^2} \\quad (7a) $$\n$$ \\sigma_\\theta(r) = A + \\frac{B}{r^2} \\quad (7b) $$\n这种形式恒满足平衡方程(1)。常数 $A$ 和 $B$ 由应力边界条件确定：\n$$ \\sigma_r(a) = A - \\frac{B}{a^2} = -p_i $$\n$$ \\sigma_r(b) = A - \\frac{B}{b^2} = -p_o $$\n这是一个关于 $A$ 和 $B$ 的线性系统。两方程相减得到：\n$$ B \\left( \\frac{1}{b^2} - \\frac{1}{a^2} \\right) = -p_i + p_o \\implies B \\left( \\frac{a^2 - b^2}{a^2 b^2} \\right) = p_o - p_i $$\n$$ B = \\frac{(p_i - p_o) a^2 b^2}{b^2 - a^2} $$\n将 $B$ 代回第一个方程以求得 $A$：\n$$ A = -p_i + \\frac{B}{a^2} = -p_i + \\frac{(p_i - p_o) b^2}{b^2 - a^2} = \\frac{-p_i (b^2 - a^2) + p_i b^2 - p_o b^2}{b^2 - a^2} = \\frac{p_i a^2 - p_o b^2}{b^2 - a^2} $$\n因此，径向应力的精确解析解为：\n$$ \\sigma_{r}(r)^{\\mathrm{exact}} = \\frac{p_i a^2 - p_o b^2}{b^2 - a^2} - \\frac{(p_i - p_o) a^2 b^2}{b^2 - a^2} \\frac{1}{r^2} \\quad (8) $$\n\n**3. 有限差分法（FDM）离散化**\n\n我们在域 $[a, b]$ 上定义一个具有 $N$ 个区间的均匀网格，使得网格间距为 $h = (b-a)/N$。节点位于 $r_i = a + i h$，其中 $i = 0, 1, \\dots, N$。我们求解这些 $N+1$ 个节点上的近似解 $u_i \\approx u(r_i)$。\n\n对于内部节点（$i = 1, \\dots, N-1$），我们使用二阶中心差分公式对控制常微分方程(5)进行离散化：\n$$ u'(r_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u''(r_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} $$\n将这些代入(5)式得到：\n$$ \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\frac{1}{r_i}\\frac{u_{i+1} - u_{i-1}}{2h} - \\frac{u_i}{r_i^2} = 0 $$\n乘以 $h^2$ 并按未知数 $u_j$ 合并项：\n$$ \\left(1 - \\frac{h}{2r_i}\\right) u_{i-1} + \\left(-2 - \\frac{h^2}{r_i^2}\\right) u_i + \\left(1 + \\frac{h}{2r_i}\\right) u_{i+1} = 0 \\quad (9) $$\n这提供了 $N-1$ 个线性代数方程。\n\n对于边界节点 $i=0$ 和 $i=N$，我们对边界条件(6a)和(6b)进行离散化。这需要对导数 $du/dr$ 使用二阶单边有限差分近似：\n$$ u'(r_0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}, \\quad u'(r_N) \\approx \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} $$\n将这些代入(6a)和(6b)中：\n在 $r=a$ 处 ($i=0$):\n$$ (\\lambda + 2\\mu) \\left( \\frac{-3u_0 + 4u_1 - u_2}{2h} \\right) + \\frac{\\lambda}{r_0} u_0 = -p_i \\quad (10a) $$\n在 $r=b$ 处 ($i=N$):\n$$ (\\lambda + 2\\mu) \\left( \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} \\right) + \\frac{\\lambda}{r_N} u_N = -p_o \\quad (10b) $$\n方程(9)、(10a)和(10b)构成了一个包含 $N+1$ 个未知数 $\\{u_i\\}_{i=0}^N$ 的 $N+1$ 个线性方程组。该系统写作 $\\mathbf{A} \\mathbf{u} = \\mathbf{f}$，需要进行组装和数值求解。矩阵 $\\mathbf{A}$ 是五对角的。\n\n**4. 数值应力计算与误差度量**\n\n在求解节点位移 $\\mathbf{u}$ 后，使用方程(4a)计算每个节点 $i$ 处径向应力的数值近似值 $\\sigma_{r,i}^{\\mathrm{num}}$。导数 $u'(r_i)$ 使用一致的二阶格式进行近似：内部节点使用中心差分，边界节点使用单边差分，与用于边界条件的格式相同。\n$$ \\sigma_{r,i}^{\\mathrm{num}} = (\\lambda + 2\\mu) u'_{i} + \\lambda \\frac{u_i}{r_i} $$\n其中 $u'_i$ 是导数的相应有限差分近似。\n\n然后通过将数值应力向量与在节点上计算的精确应力向量进行比较，来计算相对均方根（RMS）误差：\n$$ \\mathrm{err} = \\frac{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r,i}^{\\mathrm{num}} - \\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}} $$\n这量化了数值模拟的准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Lamé problem convergence study.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 10},\n        # Case 2 (refined mesh)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 20},\n        # Case 3 (more refined mesh)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 40},\n        # Case 4 (edge mesh size)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 2},\n        # Case 5 (different geometry and loads)\n        {'a': 0.3, 'b': 1.0, 'p_i': 2.0e6, 'p_o': 0.5e6, 'E': 7.0e10, 'nu': 0.25, 'N': 40},\n        # Case 6 (uniform pressure consistency)\n        {'a': 0.7, 'b': 1.0, 'p_i': 1.0e5, 'p_o': 1.0e5, 'E': 1.0e11, 'nu': 0.33, 'N': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(**case)\n        results.append(f\"{error:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_error_for_case(a, b, p_i, p_o, E, nu, N):\n    \"\"\"\n    Solves the Lamé problem for one case and computes the relative RMS error.\n\n    Args:\n        a (float): Inner radius [m].\n        b (float): Outer radius [m].\n        p_i (float): Internal pressure [Pa].\n        p_o (float): External pressure [Pa].\n        E (float): Young's modulus [Pa].\n        nu (float): Poisson's ratio.\n        N (int): Number of intervals in the mesh.\n\n    Returns:\n        float: The relative RMS error for the radial stress.\n    \"\"\"\n    # 1. Calculate constants and set up mesh\n    # Use 'lmbda' for lambda to avoid keyword conflict\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n    h = (b - a) / N\n    r = np.array([a + i * h for i in range(N + 1)])\n\n    # 2. Assemble the linear system A * u = f for N+1 unknowns u_0, ..., u_N\n    num_unknowns = N + 1\n    A = np.zeros((num_unknowns, num_unknowns))\n    f = np.zeros(num_unknowns)\n\n    # Equation for node i=0 (from boundary condition at r=a)\n    # This equation involves u_0, u_1, u_2\n    A[0, 0] = -3 * (lmbda + 2 * mu) / (2 * h) + lmbda / r[0]\n    A[0, 1] = 2 * (lmbda + 2 * mu) / h  # Simplified from 4 * (...) / (2*h)\n    A[0, 2] = -1 * (lmbda + 2 * mu) / (2 * h)\n    f[0] = -p_i\n\n    # Equations for interior nodes i=1 to N-1 (from governing ODE)\n    for i in range(1, N):\n        A[i, i - 1] = 1 - h / (2 * r[i])\n        A[i, i] = -2 - h**2 / r[i]**2\n        A[i, i + 1] = 1 + h / (2 * r[i])\n\n    # Equation for node i=N (from boundary condition at r=b)\n    # This equation involves u_{N-2}, u_{N-1}, u_N\n    A[N, N - 2] = (lmbda + 2 * mu) / (2 * h)\n    A[N, N - 1] = -2 * (lmbda + 2 * mu) / h # Simplified from -4 * (...) / (2*h)\n    A[N, N] = 3 * (lmbda + 2 * mu) / (2 * h) + lmbda / r[N]\n    f[N] = -p_o\n    \n    # 3. Solve for displacement vector u\n    u = np.linalg.solve(A, f)\n\n    # 4. Compute numerical stresses from the displacement solution\n    du_dr_num = np.zeros(num_unknowns)\n    # Derivative at i=0 (second-order forward difference)\n    du_dr_num[0] = (-3 * u[0] + 4 * u[1] - u[2]) / (2 * h)\n    # Derivatives for i=1 to N-1 (second-order central difference)\n    for i in range(1, N):\n        du_dr_num[i] = (u[i + 1] - u[i - 1]) / (2 * h)\n    # Derivative at i=N (second-order backward difference)\n    du_dr_num[N] = (3 * u[N] - 4 * u[N - 1] + u[N - 2]) / (2 * h)\n\n    sigma_r_num = (lmbda + 2 * mu) * du_dr_num + lmbda * u / r\n\n    # 5. Compute analytical stresses at nodes\n    const_A = (p_i * a**2 - p_o * b**2) / (b**2 - a**2)\n    const_B = (p_i - p_o) * a**2 * b**2 / (b**2 - a**2)\n    sigma_r_exact = const_A - const_B / r**2\n\n    # 6. Compute the relative RMS error\n    numerator = np.sqrt(np.sum((sigma_r_num - sigma_r_exact)**2))\n    denominator = np.sqrt(np.sum(sigma_r_exact**2))\n    \n    if abs(denominator)  1e-15:\n        if abs(numerator)  1e-15:\n            return 0.0  # Exact solution found for a zero-norm case if it happens\n        else:\n            return np.inf  # Numerical solution non-zero, but analytical is zero\n    \n    error = numerator / denominator\n    return error\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "有限元分析通常会输出大量数据，通常以组件内许多点的应力张量形式出现。为了理解这些数据并评估设计的安全性，工程师必须提取关键量。本练习侧重于一项基本的后处理任务：从给定的柯西应力张量 (Cauchy stress tensor) 计算主应力及其方向，它们代表了最大法向应力以及其作用的平面。",
            "id": "2378068",
            "problem": "给定一个三维（$3$D）实体部件在静态加载下，其选定点上的一组对称 Cauchy 应力张量。每个应力状态由一个实对称 $3\\times 3$ 矩阵 $\\boldsymbol{\\sigma}$ 表示，其元素单位为帕斯卡（Pa）。对于每个应力张量，确定第一主应力方向，定义为与最大主应力相关联的单位向量 $\\boldsymbol{v}_{1}\\in\\mathbb{R}^{3}$。第一主应力方向是指这样的方向 $\\boldsymbol{v}_{1}$：在一个单位法向量为 $\\boldsymbol{n}=\\boldsymbol{v}_{1}$ 的平面上，其面力向量与 $\\boldsymbol{n}$ 共线，并且相应的标量面力（主应力）在所有此类方向中是最大的。\n\n为确保方向的唯一性，请采用以下约定：\n- 将方向归一化，使其欧几里得范数为1。\n- 为确定其符号，设 $\\tau=10^{-12}$。在分量 $(v_{x},v_{y},v_{z})$ 中找到第一个绝对值超过 $\\tau$ 的分量；如果该分量为负，则将整个向量乘以 $-1$。如果没有分量的绝对值超过 $\\tau$（对于非零单位向量，这种情况不会发生），则报告 $\\left[1,0,0\\right]$。\n\n将每个方向报告为其笛卡尔分量的列表 $\\left[v_{x},v_{y},v_{z}\\right]$，每个分量四舍五入到六位小数。这些分量是无量纲的。\n\n测试套件（每个张量以帕斯卡（Pa）为单位给出；条目为精确值）：\n- 情况 1：\n  $\\boldsymbol{\\sigma}_{1}=\\begin{bmatrix}\n  1.20\\times 10^{8}  3.0\\times 10^{7}  0.0\\\\\n  3.0\\times 10^{7}  8.0\\times 10^{7}  1.0\\times 10^{7}\\\\\n  0.0  1.0\\times 10^{7}  6.0\\times 10^{7}\n  \\end{bmatrix}$\n- 情况 2：\n  $\\boldsymbol{\\sigma}_{2}=\\begin{bmatrix}\n  5.0\\times 10^{7}  0.0  0.0\\\\\n  0.0  2.0\\times 10^{8}  0.0\\\\\n  0.0  0.0  1.0\\times 10^{8}\n  \\end{bmatrix}$\n- 情况 3：\n  $\\boldsymbol{\\sigma}_{3}=\\begin{bmatrix}\n  0.0  5.0\\times 10^{7}  0.0\\\\\n  5.0\\times 10^{7}  0.0  0.0\\\\\n  0.0  0.0  -1.0\\times 10^{7}\n  \\end{bmatrix}$\n- 情况 4：\n  $\\boldsymbol{\\sigma}_{4}=\\begin{bmatrix}\n  1.01\\times 10^{8}  1.0\\times 10^{6}  2.0\\times 10^{6}\\\\\n  1.0\\times 10^{6}  1.00\\times 10^{8}  1.5\\times 10^{6}\\\\\n  2.0\\times 10^{6}  1.5\\times 10^{6}  1.02\\times 10^{8}\n  \\end{bmatrix}$\n- 情况 5：\n  $\\boldsymbol{\\sigma}_{5}=\\begin{bmatrix}\n  -1.00\\times 10^{8}  0.0  0.0\\\\\n  0.0  -5.0\\times 10^{7}  0.0\\\\\n  0.0  0.0  -7.5\\times 10^{7}\n  \\end{bmatrix}$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表中的每个条目本身是对应测试用例的方括号三元组，不含空格。例如，一个有效的格式是 $\\left[[0.577350,0.577350,0.577350],[\\dots]\\right]$。",
            "solution": "对所述问题进行验证。\n\n**步骤 1：提取已知条件**\n- 问题背景为 $3$D 固体力学。\n- 输入为一组对称的 $3 \\times 3$ Cauchy 应力张量 $\\boldsymbol{\\sigma}$，其元素为实数，单位为帕斯卡（Pa）。\n- 任务是为每个张量找到第一主应力方向 $\\boldsymbol{v}_{1} \\in \\mathbb{R}^{3}$。\n- 第一主应力方向定义为与最大主应力相关联的单位特征向量。\n- 规定了唯一性约定：\n    1. 向量 $\\boldsymbol{v}_{1}$ 必须被归一化为单位欧几里得范数。\n    2. 给出了一个符号确定规则：设容差 $\\tau = 10^{-12}$，找到向量 $(v_{x}, v_{y}, v_{z})$ 中第一个绝对值超过 $\\tau$ 的分量。如果此分量为负，则整个向量必须乘以 $-1$。\n- 每个方向的输出是其笛卡尔分量的列表 $[v_{x}, v_{y}, v_{z}]$，每个分量四舍五入到六位小数。\n- 提供了五个特定的应力张量 $\\boldsymbol{\\sigma}_{1}$ 到 $\\boldsymbol{\\sigma}_{5}$ 作为测试用例。\n\n**步骤 2：已知条件的验证**\n根据验证标准对问题进行评估：\n- **科学依据：** 该问题是线性弹性和连续介质力学中的一个基本练习。Cauchy 应力张量、其对称性、主应力及主方向是核心且成熟的概念。该问题在科学上是合理的。\n- **适定性：** 对于任何实对称矩阵，如应力张量 $\\boldsymbol{\\sigma}$，都存在实数特征值（主应力）和一组相应的正交特征向量（主方向）。该问题要求找出与最大特征值相关的方向。由于所有提供的测试用例都产生不同的特征值，因此主方向在符号上是唯一的。所提供的符号确定约定解决了这种模糊性，使得问题是适定的。\n- **客观性：** 该问题使用精确的数学语言和定量数据进行表述。确定最终向量的程序是算法性的且无歧义的。不需要主观解释。\n- **完整性与一致性：** 提供了所有必要信息，包括应力张量和明确的唯一性规则。整个设定是自洽且无矛盾的。应力的单位（Pa）和量级对于工程材料是物理上合理的。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它有科学依据、适定、客观且自洽。将提供一个解决方案。\n\n任务是为给定的 Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 找到第一主方向。这等同于找到矩阵 $\\boldsymbol{\\sigma}$ 的最大特征值对应的特征向量。主应力 $\\sigma_{p}$ 与其对应的主方向 $\\boldsymbol{v}$ 之间的关系由以下特征值问题定义：\n$$\n\\boldsymbol{\\sigma}\\boldsymbol{v} = \\sigma_{p}\\boldsymbol{v}\n$$\n此处，$\\sigma_{p}$ 是一个特征值，$\\boldsymbol{v}$ 是 $\\boldsymbol{\\sigma}$ 对应的特征向量。根据角动量守恒原理，Cauchy 应力张量是一个对称矩阵（$\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{T}$），因此实对称矩阵的谱定理保证了它有三个实数特征值（主应力 $\\sigma_{1}, \\sigma_{2}, \\sigma_{3}$）和一组三个相互正交的特征向量（主方向 $\\boldsymbol{v}_{1}, \\boldsymbol{v}_{2}, \\boldsymbol{v}_{3}$）。\n\n第一主应力定义为代数值最大的特征值，通常表示为 $\\sigma_{1}$，其中 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\sigma_{3}$。对应的第一主方向是其关联的特征向量 $\\boldsymbol{v}_{1}$。\n\n为每个给定的应力张量求解此问题的计算步骤如下：\n首先，我们求解特征值问题。这是数值线性代数中的一个标准任务。我们将使用一个稳健的特征求解器，例如 Python 的 `NumPy` 库中提供的 `numpy.linalg.eigh` 函数。该函数针对对称（或厄米）矩阵进行了优化，并具有一个便利的特性，即返回按升序排列的特征值。因此，最大特征值 $\\sigma_{1}$ 将是返回的特征值数组中的最后一个元素。相应的特征向量 $\\boldsymbol{v}_{1}$ 将是返回的特征向量矩阵的最后一列。\n\n其次，我们必须遵守问题的唯一性约定。`numpy.linalg.eigh` 函数返回的特征向量已经被归一化为单位欧几里得范数，满足了约定的第一部分。第二部分是符号确定规则。一个特征向量 $\\boldsymbol{v}$ 与 $-\\boldsymbol{v}$ 等价，因为它们都定义了相同的方向（特征空间）。为确保单一表示，我们应用指定的程序。设计算出的单位特征向量为 $\\boldsymbol{v} = [v_{x}, v_{y}, v_{z}]^{T}$，容差为 $\\tau = 10^{-12}$。\n1. 检查第一个分量 $v_{x}$。如果 $|v_{x}|  \\tau$，其符号决定整个向量的符号。如果 $v_{x}  0$，我们将最终向量设置为 $-\\boldsymbol{v}$。否则，我们按原样使用 $\\boldsymbol{v}$。\n2. 如果 $|v_{x}| \\le \\tau$，我们继续检查第二个分量 $v_{y}$。如果 $|v_{y}|  \\tau$，其符号决定方向。如果 $v_{y}  0$，我们使用 $-\\boldsymbol{v}$。否则，我们使用 $\\boldsymbol{v}$。\n3. 如果 $|v_{x}| \\le \\tau$ 和 $|v_{y}| \\le \\tau$ 都成立，我们检查第三个分量 $v_{z}$。由于向量是单位范数，所以 $|v_{z}|$ 必须大于 $\\tau$。如果 $v_{z}  0$，我们使用 $-\\boldsymbol{v}$。否则，我们使用 $\\boldsymbol{v}$。\n此程序确保报告的向量是唯一的。\n\n最后，根据要求，将得到的唯一方向向量的分量四舍五入到六位小数。将此完整过程系统地应用于五个给定的应力张量 $\\boldsymbol{\\sigma}_{1}$ 到 $\\boldsymbol{\\sigma}_{5}$。然后将结果汇总成指定的最终输出格式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the first principal stress direction for a set of Cauchy stress tensors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each stress tensor is given in units of Pascal (Pa).\n    test_cases = [\n        # Case 1\n        np.array([\n            [1.20e8, 3.0e7, 0.0],\n            [3.0e7, 8.0e7, 1.0e7],\n            [0.0, 1.0e7, 6.0e7]\n        ]),\n        # Case 2\n        np.array([\n            [5.0e7, 0.0, 0.0],\n            [0.0, 2.0e8, 0.0],\n            [0.0, 0.0, 1.0e8]\n        ]),\n        # Case 3\n        np.array([\n            [0.0, 5.0e7, 0.0],\n            [5.0e7, 0.0, 0.0],\n            [0.0, 0.0, -1.0e7]\n        ]),\n        # Case 4\n        np.array([\n            [1.01e8, 1.0e6, 2.0e6],\n            [1.0e6, 1.00e8, 1.5e6],\n            [2.0e6, 1.5e6, 1.02e8]\n        ]),\n        # Case 5\n        np.array([\n            [-1.00e8, 0.0, 0.0],\n            [0.0, -5.0e7, 0.0],\n            [0.0, 0.0, -7.5e7]\n        ])\n    ]\n\n    results = []\n    tau = 1e-12\n\n    for sigma in test_cases:\n        # For a symmetric matrix sigma, np.linalg.eigh returns eigenvalues in\n        # ascending order and the corresponding normalized eigenvectors as columns\n        # of the returned matrix.\n        eigenvalues, eigenvectors = np.linalg.eigh(sigma)\n\n        # The first principal stress is the maximum eigenvalue.\n        # Its direction is the corresponding eigenvector. Due to the ascending sort,\n        # this is the last column of the eigenvectors matrix.\n        v1 = eigenvectors[:, -1]\n\n        # Apply the uniqueness convention to fix the sign of the direction vector.\n        # The eigenvector is already of unit norm.\n        # Find the first component with an absolute value greater than tau.\n        # If this component is negative, flip the sign of the entire vector.\n        for i in range(3):\n            if abs(v1[i]) > tau:\n                if v1[i]  0:\n                    v1 = -v1\n                break\n        \n        # Format the components by rounding to six decimal places,\n        # ensuring trailing zeros are present.\n        v1_formatted = [f\"{comp:.6f}\" for comp in v1]\n\n        # Assemble the formatted vector into a string representation of a list.\n        result_str = f\"[{','.join(v1_formatted)}]\"\n        results.append(result_str)\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n  solve()\n```"
        }
    ]
}