{
    "hands_on_practices": [
        {
            "introduction": "特征值和特征向量是理解线性系统动态演化的核心工具。这个练习提供了一个具体实例，展示如何运用特征分解来求解一个常微分方程组，将一个耦合的矩阵问题转化为几个独立的标量问题，从而清晰地揭示系统的基本行为模式。",
            "id": "2387684",
            "problem": "在一个计算工程中出现的降阶$2$状态线性模型（例如，一个粗糙的双节点热网络）中，状态向量 $u(t) \\in \\mathbb{R}^{2}$ 根据线性时不变常微分方程（ODE）$\\dot{u}(t) = A u(t)$ 演化，初始条件为 $u(0) = u_{0}$。考虑\n$$\nA = \\begin{pmatrix} 4  -2 \\\\ 1  1 \\end{pmatrix}, \\qquad u_{0} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}.\n$$\n仅从适用于此背景的基本定义和事实出发——具体来说，是矩阵指数的幂级数定义和矩阵的特征分解概念——通过对矩阵 $A$ 进行对角化，推导出 $u(t)$ 的显式表达式。然后，报告第一个分量 $u_{1}(t)$ 作为 $t$ 的函数的闭式解析表达式。将你的最终答案以 $t$ 的单个解析表达式形式给出。无需进行数值计算或四舍五入。",
            "solution": "首先对问题进行验证。\n\n步骤1：提取已知条件。\n系统由状态向量 $u(t) \\in \\mathbb{R}^{2}$ 的线性时不变常微分方程 $\\dot{u}(t) = A u(t)$ 控制。\n系统矩阵为 $A = \\begin{pmatrix} 4  -2 \\\\ 1  1 \\end{pmatrix}$。\n初始条件为 $u(0) = u_{0} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n解 $u(t)$ 的推导必须通过对 $A$ 进行对角化，并且必须基于矩阵指数的幂级数定义和特征分解的概念。\n要求的输出是解向量的第一个分量 $u_{1}(t)$ 的闭式解析表达式。\n\n步骤2：验证。\n该问题是一个标准的线性一阶常微分方程组的初值问题。此类模型在计算工程和其他 STEM 领域是基础。给定的矩阵 $A$ 是一个常数 $2 \\times 2$ 矩阵，初始条件 $u_0$ 是一个常数向量。\n该问题：\n- **科学上成立**：它基于线性代数和微分方程的既定原理。\n- **适定的**：它是一个标准的常系数矩阵初值问题，保证在所有时间 $t$ 上存在唯一解。矩阵 $A$ 的特征值是不同的，这意味着 $A$ 是可对角化的，并且所要求的方法是适用的。\n- **客观的**：问题以精确的数学术语表述，没有歧义或主观论断。\n- **完整的**：提供了所有必要的数据（$A$，$u_0$）和约束条件。\n- **可行的**：计算是直接的，不涉及任何不切实际的物理或数学条件。\n\n结论：该问题是有效的。\n\n解法如下。该问题是一个形式为 $\\dot{u}(t) = A u(t)$ 且 $u(0) = u_0$ 的线性初值问题。形式解由 $u(t) = \\exp(At) u_0$ 给出。问题要求根据矩阵指数的幂级数定义 $\\exp(M) = \\sum_{k=0}^{\\infty} \\frac{M^k}{k!}$ 来证明这一点。\n令 $u(t) = \\exp(At) u_0 = \\left(\\sum_{k=0}^{\\infty} \\frac{(At)^k}{k!}\\right) u_0$。\n对 $t$ 逐项求导：\n$$\n\\frac{d}{dt} u(t) = \\frac{d}{dt} \\left( \\sum_{k=0}^{\\infty} \\frac{A^k t^k}{k!} \\right) u_0 = \\left( \\sum_{k=1}^{\\infty} \\frac{A^k k t^{k-1}}{k!} \\right) u_0 = \\left( \\sum_{k=1}^{\\infty} \\frac{A^k t^{k-1}}{(k-1)!} \\right) u_0\n$$\n从求和式中提出一个 $A$：\n$$\n\\frac{d}{dt} u(t) = A \\left( \\sum_{k=1}^{\\infty} \\frac{A^{k-1} t^{k-1}}{(k-1)!} \\right) u_0\n$$\n通过用 $j = k-1$ 重新索引，求和变为 $\\sum_{j=0}^{\\infty} \\frac{(At)^j}{j!} = \\exp(At)$。\n因此，$\\frac{d}{dt} u(t) = A \\left( \\exp(At) u_0 \\right) = A u(t)$，这满足了微分方程。\n在 $t=0$ 时，$u(0) = \\exp(A \\cdot 0) u_0 = I u_0 = u_0$，这满足了初始条件。\n\n为了计算 $\\exp(At)$，我们对矩阵 $A$ 进行对角化。$A$ 的特征分解为 $A = PDP^{-1}$，其中 $D$ 是特征值构成的对角矩阵，$P$ 是其列为相应特征向量的矩阵。\n首先，我们通过求解特征方程 $\\det(A - \\lambda I) = 0$ 来找到特征值。\n$$\n\\det \\begin{pmatrix} 4-\\lambda  -2 \\\\ 1  1-\\lambda \\end{pmatrix} = (4-\\lambda)(1-\\lambda) - (-2)(1) = 4 - 5\\lambda + \\lambda^2 + 2 = \\lambda^2 - 5\\lambda + 6 = 0\n$$\n对二次方程进行因式分解得到 $(\\lambda - 2)(\\lambda - 3) = 0$。特征值为 $\\lambda_1 = 2$ 和 $\\lambda_2 = 3$。\n\n接下来，我们通过求解每个特征值的 $(A - \\lambda I)v = 0$ 来找到相应的特征向量。\n对于 $\\lambda_1 = 2$：\n$$\n(A - 2I)v_1 = \\begin{pmatrix} 4-2  -2 \\\\ 1  1-2 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 2  -2 \\\\ 1  -1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得到方程 $x-y=0$。一个合适的特征向量是 $v_1 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n对于 $\\lambda_2 = 3$：\n$$\n(A - 3I)v_2 = \\begin{pmatrix} 4-3  -2 \\\\ 1  1-3 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 1  -2 \\\\ 1  -2 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得到方程 $x-2y=0$。一个合适的特征向量是 $v_2 = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。\n\n特征向量矩阵 $P$ 和特征值对角矩阵 $D$ 为：\n$$\nP = \\begin{pmatrix} v_1  v_2 \\end{pmatrix} = \\begin{pmatrix} 1  2 \\\\ 1  1 \\end{pmatrix}, \\qquad D = \\begin{pmatrix} \\lambda_1  0 \\\\ 0  \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} 2  0 \\\\ 0  3 \\end{pmatrix}\n$$\n我们需要 $P$ 的逆矩阵：\n$$\nP^{-1} = \\frac{1}{\\det(P)} \\begin{pmatrix} 1  -2 \\\\ -1  1 \\end{pmatrix} = \\frac{1}{1 \\cdot 1 - 2 \\cdot 1} \\begin{pmatrix} 1  -2 \\\\ -1  1 \\end{pmatrix} = \\frac{1}{-1} \\begin{pmatrix} 1  -2 \\\\ -1  1 \\end{pmatrix} = \\begin{pmatrix} -1  2 \\\\ 1  -1 \\end{pmatrix}\n$$\n对角化的用处在于 $\\exp(At) = P \\exp(Dt) P^{-1}$。这源于幂级数：\n$\\exp(At) = \\sum_{k=0}^{\\infty} \\frac{(PDP^{-1}t)^k}{k!} = \\sum_{k=0}^{\\infty} \\frac{P(Dt)^k P^{-1}}{k!} = P\\left(\\sum_{k=0}^{\\infty} \\frac{(Dt)^k}{k!}\\right)P^{-1} = P\\exp(Dt)P^{-1}$。\n对角矩阵的指数是其元素指数构成的对角矩阵：\n$$\n\\exp(Dt) = \\exp\\left(\\begin{pmatrix} 2t  0 \\\\ 0  3t \\end{pmatrix}\\right) = \\begin{pmatrix} \\exp(2t)  0 \\\\ 0  \\exp(3t) \\end{pmatrix}\n$$\n现在，我们计算 $\\exp(At)$：\n$$\n\\exp(At) = P \\exp(Dt) P^{-1} = \\begin{pmatrix} 1  2 \\\\ 1  1 \\end{pmatrix} \\begin{pmatrix} \\exp(2t)  0 \\\\ 0  \\exp(3t) \\end{pmatrix} \\begin{pmatrix} -1  2 \\\\ 1  -1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} \\exp(2t)  2\\exp(3t) \\\\ \\exp(2t)  \\exp(3t) \\end{pmatrix} \\begin{pmatrix} -1  2 \\\\ 1  -1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} -\\exp(2t) + 2\\exp(3t)  2\\exp(2t) - 2\\exp(3t) \\\\ -\\exp(2t) + \\exp(3t)  2\\exp(2t) - \\exp(3t) \\end{pmatrix}\n$$\n最后，我们计算解 $u(t) = \\exp(At) u_0$：\n$$\nu(t) = \\begin{pmatrix} -\\exp(2t) + 2\\exp(3t)  2\\exp(2t) - 2\\exp(3t) \\\\ -\\exp(2t) + \\exp(3t)  2\\exp(2t) - \\exp(3t) \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\n$$\nu(t) = \\begin{pmatrix} u_1(t) \\\\ u_2(t) \\end{pmatrix} = \\begin{pmatrix} -\\exp(2t) + 2\\exp(3t) \\\\ -\\exp(2t) + \\exp(3t) \\end{pmatrix} = \\begin{pmatrix} 2\\exp(3t) - \\exp(2t) \\\\ \\exp(3t) - \\exp(2t) \\end{pmatrix}\n$$\n问题要求第一个分量 $u_1(t)$。\n$$\nu_1(t) = 2\\exp(3t) - \\exp(2t)\n$$\n这就是状态向量的第一个分量作为时间 $t$ 的函数的闭式解析表达式。",
            "answer": "$$\\boxed{2\\exp(3t) - \\exp(2t)}$$"
        },
        {
            "introduction": "然而，并非所有矩阵都可以被对角化。当一个矩阵的线性无关特征向量数量不足时，我们称之为“亏损矩阵”(defective matrix)，这时就需要更普适的工具。这个练习将引导我们处理这种特殊但重要的情况，通过计算一个 $2 \\times 2$ 矩阵的若尔当标准型 (Jordan normal form)，深入理解其内在结构，这对于分析更广泛线性系统的稳定性至关重要。",
            "id": "2387707",
            "problem": "在计算工程中，离散化双状态线性系统的稳定性可以通过其状态转移矩阵的特征结构来研究。考虑由下式给出的实矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$\n$$\nA \\;=\\; \\begin{pmatrix}\n5  -3 \\\\\n12  -7\n\\end{pmatrix}.\n$$\n$\\mathbb{R}$ 上的若尔当标准型是指一种实数标准型，它由若干个若尔当块组成，并约定每个若尔当块的超对角线元素均为1。仅使用特征值、特征向量和广义特征向量的定义，确定在 $\\mathbb{R}$ 上相似变换下，$A$ 的若尔当标准型中单个超对角线元素的值。将最终答案表示为一个实数。无需四舍五入。",
            "solution": "在尝试解答之前，需对问题进行有效性验证。\n\n首先，从问题陈述中提取已知条件：\n- 矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$ 定义为 $A = \\begin{pmatrix} 5  -3 \\\\ 12  -7 \\end{pmatrix}$。\n- 目标是确定在 $\\mathbb{R}$ 上 $A$ 的若尔当标准型中单个超对角线元素的值。\n- 若尔当块的约定是其超对角线元素为1。\n- 推导过程必须“仅使用特征值、特征向量和广义特征向量的定义”。\n\n对问题进行有效性评估。该问题涉及成熟的线性代数理论，特别是若尔当标准型，因此具有科学依据。该问题是良定的，因为方阵的若尔当标准型在若尔当块的排列上是唯一的，且超对角线元素的值是矩阵的确定性属性。其语言客观精确。问题是自洽的，没有违反任何基本原理。因此，该问题被认定为有效，并将提供解答。\n\n矩阵的若尔当标准型由其特征值以及对应的特征空间和广义特征空间的结构确定。第一步是通过求解特征方程 $\\det(A - \\lambda I) = 0$ 来计算矩阵 $A$ 的特征值，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\n特征多项式为：\n$$ \\det(A - \\lambda I) = \\det\\begin{pmatrix} 5-\\lambda  -3 \\\\ 12  -7-\\lambda \\end{pmatrix} $$\n$$ = (5-\\lambda)(-7-\\lambda) - (-3)(12) $$\n$$ = -35 - 5\\lambda + 7\\lambda + \\lambda^2 + 36 $$\n$$ = \\lambda^2 + 2\\lambda + 1 $$\n$$ = (\\lambda + 1)^2 $$\n令特征多项式等于零，$(\\lambda + 1)^2 = 0$，得到一个代数重数为 $m_a = 2$ 的单一特征值 $\\lambda = -1$。\n\n接下来，我们确定该特征值的几何重数 $m_g$。几何重数是与 $\\lambda$ 相关联的特征空间的维数，也就是矩阵 $(A - \\lambda I)$ 的零空间的维数。\n对于 $\\lambda = -1$，我们有：\n$$ A - \\lambda I = A - (-1)I = A + I = \\begin{pmatrix} 5+1  -3 \\\\ 12  -7+1 \\end{pmatrix} = \\begin{pmatrix} 6  -3 \\\\ 12  -6 \\end{pmatrix} $$\n为了找到零空间，我们求解方程组 $(A+I)v = 0$，其中向量 $v = \\begin{pmatrix} x \\\\ y \\end{pmatrix}$：\n$$ \\begin{pmatrix} 6  -3 \\\\ 12  -6 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n该线性方程组等价于单个方程 $6x - 3y = 0$，化简为 $y = 2x$。该特征空间由单个向量张成，例如 $v_1 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$。\n这个零空间的维数是1。因此，几何重数 $m_g = 1$。\n\n由于几何重数 $m_g = 1$ 小于代数重数 $m_a = 2$，矩阵 $A$ 不可对角化。$A$ 的若尔当标准型必须包含至少一个非对角的若尔当块。考虑到 $A$ 是一个 $2 \\times 2$ 矩阵，且只有一个代数重数为2的特征值，其若尔当标准型必须由一个单独的 $2 \\times 2$ 若尔当块组成。\n\n根据问题陈述中给出的定义和约定，一个对应于特征值 $\\lambda$ 的 $k \\times k$ 大小的若尔当块是一个形如下式的上三角矩阵：\n$$ J_k(\\lambda) = \\begin{pmatrix}\n\\lambda  1  0  \\dots  0 \\\\\n0  \\lambda  1  \\dots  0 \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  \\vdots \\\\\n0  0  \\dots  \\lambda  1 \\\\\n0  0  \\dots  0  \\lambda\n\\end{pmatrix} $$\n超对角线上的元素均为 $1$。\n\n对于矩阵 $A$，其若尔当标准型是一个对应于特征值 $\\lambda = -1$ 的单独的 $2 \\times 2$ 块。该块为：\n$$ J = J_2(-1) = \\begin{pmatrix} -1  1 \\\\ 0  -1 \\end{pmatrix} $$\n这种结构是该矩阵对于一个代数重数为2的特征值只有一个线性无关的特征向量的直接结果。若尔当分解的基由一个特征向量 $v_1$ 和一个满足 $(A-\\lambda I)v_2 = v_1$ 的广义特征向量 $v_2$ 构成。这样一个长度为2的链的存在证实了若尔当块的结构。\n\n若尔当标准型 $J$ 有一个超对角线元素。观察矩阵 $J$，该元素位于第1行第2列。该元素的值是 $1$。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "除了分析静态系统，计算工程师经常需要研究当系统参数变化时，其性质如何演变。这个实践将理论知识与编程技能相结合，通过编写程序来可视化特征值在复平面上的“轨迹”。这项练习不仅能加深对特征值与矩阵参数之间关系的理解，还为探索系统稳定性、分岔和灵敏度分析等高级主题提供了直观的计算方法。",
            "id": "2387717",
            "problem": "给定一个由仿射映射 $M(t) = (1 - t)A + tB$ 定义的 $2 \\times 2$ 方阵的参数族，其中 $t \\in [0, 1]$，$A$ 和 $B$ 是实 $2 \\times 2$ 矩阵。对于每个这样的族，将 $M(t)$ 的两个特征值视为 $t$ 的函数。特征值轨迹定义为在区间 $[0, 1]$ 上，随 $t$ 连续选取 $M(t)$ 的一个特征值而在复平面上描绘出的连续曲线。存在两条这样的轨迹。\n\n您的任务是编写一个程序，对每个给定的测试用例，近似计算复平面中两条特征值轨迹各自的弧长。使用 $S$ 个等间距参数样本 $t_k = \\frac{k}{S - 1}$，其中 $k = 0, 1, \\ldots, S - 1$。对于一条连续轨迹 $\\lambda_j(t)$，通过离散和来近似其弧长：\n$$\nL_j \\approx \\sum_{k=1}^{S-1} \\left| \\lambda_j(t_k) - \\lambda_j(t_{k-1}) \\right|,\n$$\n其中 $\\left| \\cdot \\right|$ 表示复模，即复平面中的欧几里得范数。对每个测试用例，按非递减顺序报告两个弧长。所有量均无单位。\n\n测试套件：\n- 用例 $1$（具有复数到实数过渡的一般行为）：$A = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$，$B = \\begin{bmatrix} 2  0 \\\\ 0  3 \\end{bmatrix}$，$S = 501$。\n- 用例 $2$（常数重特征值，在端点处为亏损矩阵）：$A = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix}$，$B = \\begin{bmatrix} 1  -1 \\\\ 0  1 \\end{bmatrix}$，$S = 101$。\n- 用例 $3$（全程为纯虚共轭特征值）：$A = \\begin{bmatrix} 0  -2 \\\\ 1  0 \\end{bmatrix}$，$B = \\begin{bmatrix} 0  -3 \\\\ 1  0 \\end{bmatrix}$，$S = 301$。\n- 用例 $4$（具有特征值交叉的实对称对角插值）：$A = \\begin{bmatrix} -1  0 \\\\ 0  1 \\end{bmatrix}$，$B = \\begin{bmatrix} 1  0 \\\\ 0  -1 \\end{bmatrix}$，$S = 201$。\n\n对于每个用例，计算 $[L_1, L_2]$ 作为按非递减顺序排序的两个轨迹弧长，并将每个数字四舍五入到恰好 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个用例的结果，这些结果汇总到单个列表的列表中，不含空格，格式如下：\n$$\n\\text{[[}\\ell_{1,1},\\ell_{1,2}\\text{],[}\\ell_{2,1},\\ell_{2,2}\\text{],[}\\ell_{3,1},\\ell_{3,2}\\text{],[}\\ell_{4,1},\\ell_{4,2}\\text{]]},\n$$\n其中 $\\ell_{i,j}$ 是用例 $i$、轨迹 $j$ 的四舍五入后的弧长。例如，打印的行应类似于 $[[x_{11},x_{12}],[x_{21},x_{22}],[x_{31},x_{32}],[x_{41},x_{42}]]$，其中每个 $x_{ij}$ 显示小数点后恰好 $6$ 位数字。",
            "solution": "所给出的问题陈述经过了严格验证，被认定为有效。它在线性代数方面有科学依据，在数学上是适定的，并且没有歧义或矛盾。所有必要的数据均已提供。因此，我们可以着手求解。\n\n问题要求计算参数化矩阵族 $M(t) = (1 - t)A + tB$（其中 $t \\in [0, 1]$）的两条特征值轨迹的弧长。一条特征值轨迹 $\\lambda(t)$ 是复平面中的一条连续路径。其弧长 $L$ 由积分 $L = \\int_0^1 \\left| \\frac{d\\lambda}{dt} \\right| dt$ 给出。\n\n题目要求我们使用 $S$ 个等间距点 $t_k = \\frac{k}{S - 1}$（其中 $k = 0, 1, \\dots, S-1$）上的离散和来近似该积分。因此，第 $j$ 条轨迹的弧长 $L_j$ 可通过连接轨迹上连续点的弦长之和来近似：\n$$\nL_j \\approx \\sum_{k=1}^{S-1} \\left| \\lambda_j(t_k) - \\lambda_j(t_{k-1}) \\right|\n$$\n其中 $\\lambda_j(t_k)$ 是参数值 $t_k$ 处的第 $j$ 个特征值，而 $|\\cdot|$ 表示复模。\n\n对于每个测试用例，总体算法流程如下：\n\n首先，我们生成参数值序列 $t_0, t_1, \\dots, t_{S-1}$。\n\n其次，对于每个 $t_k$，我们构造矩阵 $M(t_k) = (1 - t_k)A + t_k B$ 并计算其两个特征值。对于一个通用的 $2 \\times 2$ 矩阵 $M = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$，其特征值是特征多项式 $\\lambda^2 - \\text{tr}(M)\\lambda + \\det(M) = 0$ 的根。这些根由二次求根公式给出：\n$$\n\\lambda = \\frac{\\text{tr}(M) \\pm \\sqrt{\\text{tr}(M)^2 - 4\\det(M)}}{2}\n$$\n这些计算将使用一个稳健的数值库，具体来说是 `numpy.linalg.eigvals` 来执行。\n\n第三，也是最关键的一步，我们必须确定两条连续的轨迹 $\\lambda_1(t)$ 和 $\\lambda_2(t)$。数值特征值求解器通常按特定顺序（例如，按实部大小）返回特征值，这并不能保证该序列对应于单条连续轨迹，特别是当特征值交叉或合并时（在所谓的奇异点处）。为了解决这个问题，我们必须在步与步之间“跟踪”特征值。\n我们从 $M(t_0) = A$ 的两个特征值开始，将它们指定为 $\\lambda_1(t_0)$ 和 $\\lambda_2(t_0)$。对于每个后续步骤 $k$，我们计算 $M(t_k)$ 的新特征值，称之为 $e_a$ 和 $e_b$。我们必须决定是 $\\lambda_1(t_k) = e_a$ 且 $\\lambda_2(t_k) = e_b$，还是应该交换这个分配。我们通过选择使上一步到这一步的总“跳跃”距离最小化的配对来做出此决定。我们比较两种可能的总距离：\n$$\nD_1 = |\\lambda_1(t_{k-1}) - e_a| + |\\lambda_2(t_{k-1}) - e_b|\n$$\n$$\nD_2 = |\\lambda_1(t_{k-1}) - e_b| + |\\lambda_2(t_{k-1}) - e_a|\n$$\n如果 $D_1 \\le D_2$，我们分配 $\\lambda_1(t_k) = e_a$ 和 $\\lambda_2(t_k) = e_b$。否则，我们分配 $\\lambda_1(t_k) = e_b$ 和 $\\lambda_2(t_k) = e_a$。对于本问题中使用的小参数步长 $\\Delta t = \\frac{1}{S-1}$，这种贪心最近邻跟踪方案是有效的。\n\n第四，在构造出两个有序的特征值序列 $\\{\\lambda_1(t_k)\\}_{k=0}^{S-1}$ 和 $\\{\\lambda_2(t_k)\\}_{k=0}^{S-1}$ 后，我们使用给定的求和公式计算它们各自的弧长 $L_1$ 和 $L_2$。`numpy.diff` 函数非常适合计算差分序列 $\\lambda_j(t_k) - \\lambda_j(t_{k-1})$，之后我们对每个差分取绝对值（模）并求和。\n\n最后，对于每个测试用例，计算出的弧长 $L_1$ 和 $L_2$ 按非递减顺序排序，四舍五入到 $6$ 位小数，并按要求格式化。此过程被系统地应用于所有四个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eigenvalue trajectory arclength problem for the given test suite.\n    \"\"\"\n\n    test_cases_data = [\n        {\n            \"A\": np.array([[0, -1], [1, 0]], dtype=float),\n            \"B\": np.array([[2, 0], [0, 3]], dtype=float),\n            \"S\": 501,\n        },\n        {\n            \"A\": np.array([[1, 1], [0, 1]], dtype=float),\n            \"B\": np.array([[1, -1], [0, 1]], dtype=float),\n            \"S\": 101,\n        },\n        {\n            \"A\": np.array([[0, -2], [1, 0]], dtype=float),\n            \"B\": np.array([[0, -3], [1, 0]], dtype=float),\n            \"S\": 301,\n        },\n        {\n            \"A\": np.array([[-1, 0], [0, 1]], dtype=float),\n            \"B\": np.array([[1, 0], [0, -1]], dtype=float),\n            \"S\": 201,\n        },\n    ]\n\n    all_case_results = []\n\n    for case_data in test_cases_data:\n        A = case_data[\"A\"]\n        B = case_data[\"B\"]\n        S = case_data[\"S\"]\n\n        # Generate parameter space\n        t_space = np.linspace(0, 1, S)\n\n        # Step 1: Compute eigenvalues at each parameter step t_k\n        eigenvalue_history = []\n        for t in t_space:\n            M = (1.0 - t) * A + t * B\n            eigs = np.linalg.eigvals(M)\n            eigenvalue_history.append(eigs)\n\n        # Step 2: Track eigenvalues to form continuous trajectories\n        # Initialize the two trajectories with the eigenvalues at t=0\n        traj1 = [eigenvalue_history[0][0]]\n        traj2 = [eigenvalue_history[0][1]]\n\n        for k in range(1, S):\n            prev_e1 = traj1[-1]\n            prev_e2 = traj2[-1]\n            \n            # Current eigenvalues (unordered)\n            curr_e_a, curr_e_b = eigenvalue_history[k]\n\n            # Calculate cost of two possible pairings to maintain continuity\n            dist_1 = abs(prev_e1 - curr_e_a) + abs(prev_e2 - curr_e_b)\n            dist_2 = abs(prev_e1 - curr_e_b) + abs(prev_e2 - curr_e_a)\n\n            # Choose the pairing with the minimum \"jump\" distance\n            if dist_1 = dist_2:\n                traj1.append(curr_e_a)\n                traj2.append(curr_e_b)\n            else:\n                traj1.append(curr_e_b)\n                traj2.append(curr_e_a)\n        \n        # Step 3: Compute arclength for each trajectory\n        traj1_np = np.array(traj1)\n        traj2_np = np.array(traj2)\n        \n        arclength1 = np.sum(np.abs(np.diff(traj1_np)))\n        arclength2 = np.sum(np.abs(np.diff(traj2_np)))\n\n        # Step 4: Sort arclengths in nondecreasing order\n        sorted_lengths = sorted([arclength1, arclength2])\n        all_case_results.append(sorted_lengths)\n\n    # Format the final output string according to the specification\n    formatted_results = []\n    for res_pair in all_case_results:\n        # Format each number to 6 decimal places and create a string representation of the list\n        str_pair = [f\"{length:.6f}\" for length in res_pair]\n        formatted_results.append(f\"[{','.join(str_pair)}]\")\n    \n    # Aggregate all case results into a single string\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}