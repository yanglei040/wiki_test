{
    "hands_on_practices": [
        {
            "introduction": "The bisection method is the workhorse of bracketing techniques, valued for its simplicity and guaranteed convergence. This first practice applies the method to a concrete problem from optical engineering: finding the specific wavelength at which two materials have identical refractive indices, a key task in designing achromatic lenses and other optical systems . By implementing the bisection algorithm to solve this, you will build a solid foundation in numerical root-finding and see how these methods are used to solve practical design challenges.",
            "id": "2375454",
            "problem": "A continuous scalar function of one variable is defined as the difference between two refractive index dispersion laws, each given by a three-term Cauchy model. For a material with coefficients $A$, $B$, and $C$, and a vacuum wavelength $\\lambda$ in micrometers, the refractive index is modeled by\n$$\nn(\\lambda) \\;=\\; A \\;+\\; \\frac{B}{\\lambda^{2}} \\;+\\; \\frac{C}{\\lambda^{4}} \\quad \\text{for} \\quad \\lambda \\gt 0.\n$$\nFor each test case below, define $f(\\lambda) \\;=\\; n_{1}(\\lambda) \\;-\\; n_{2}(\\lambda)$ using the specified pairs of materials and coefficients. For each provided closed interval $[\\lambda_{L}, \\lambda_{R}]$ and absolute tolerance $\\tau$, determine a value $\\lambda^{\\ast} \\in [\\lambda_{L}, \\lambda_{R}]$ such that $f(\\lambda^{\\ast}) = 0$ to within absolute error at most $\\tau$ in the wavelength variable, under the assumption that $f$ is continuous on $[\\lambda_{L}, \\lambda_{R}]$ and that a solution exists in each case.\n\nUse the Cauchy model with the following physically plausible coefficient sets (all wavelengths in micrometers):\n- Material $M_{A}$: $A = 1.42$, $B = 0.01$, $C = 0.0004$.\n- Material $M_{B}$: $A = 1.46$, $B = 0.002$, $C = 0.00005$.\n- Material $M_{C}$: $A = 1.38$, $B = 0.03$, $C = 0.001$.\n- Material $M_{D}$: $A = 1.45$, $B = 0.005$, $C = 0.00015$.\n\nTest suite:\n1. $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$ on $[\\lambda_{L}, \\lambda_{R}] = [0.45, 0.50]$, with $\\tau = 1.0 \\times 10^{-12}$.\n2. $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$ on $[\\lambda_{L}, \\lambda_{R}] = [0.486, 0.49]$, with $\\tau = 1.0 \\times 10^{-12}$.\n3. $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$ on $[\\lambda_{L}, \\lambda_{R}] = [0.60, 0.65]$, with $\\tau = 1.0 \\times 10^{-12}$.\n4. $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$ on $[\\lambda_{L}, \\lambda_{R}] = [0.40, 1.00]$, with $\\tau = 1.0 \\times 10^{-12}$.\n\nExpress each wavelength in micrometers, rounded to $12$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_{1},x_{2},x_{3},x_{4}]$), where each $x_{k}$ is the computed $\\lambda^{\\ast}$ for test case $k$.",
            "solution": "The problem requires finding a root $\\lambda^{\\ast}$ for the function $f(\\lambda) = n_{1}(\\lambda) - n_{2}(\\lambda) = 0$ within a specified interval $[\\lambda_{L}, \\lambda_{R}]$ and absolute error tolerance $\\tau$. The refractive index $n(\\lambda)$ for each material is given by the three-term Cauchy model:\n$$\nn(\\lambda) \\;=\\; A \\;+\\; \\frac{B}{\\lambda^{2}} \\;+\\; \\frac{C}{\\lambda^{4}}\n$$\nwhere $\\lambda$ is the vacuum wavelength in micrometers. The function to be solved is therefore:\n$$\nf(\\lambda) \\;=\\; (A_{1} - A_{2}) \\;+\\; (B_{1} - B_{2})\\lambda^{-2} \\;+\\; (C_{1} - C_{2})\\lambda^{-4} \\;=\\; 0\n$$\nThis is a standard root-finding problem for a continuous function on a closed interval. The problem statement guarantees that a solution exists in each given interval and that the function is continuous. Given these conditions, and noting that the problem is set in the context of computational methods, the Bisection Method is a suitable and robust algorithm for this task. Its convergence is guaranteed if the function values at the interval endpoints have opposite signs.\n\nLet us define the coefficients for the two functions to be analyzed:\nFor test cases $1$ and $2$, $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$. The coefficients are:\n- $A_A = 1.42$, $B_A = 0.01$, $C_A = 0.0004$.\n- $A_B = 1.46$, $B_B = 0.002$, $C_B = 0.00005$.\nThe resulting function is:\n$$\nf_{A-B}(\\lambda) \\;=\\; (1.42 - 1.46) + (0.01 - 0.002)\\lambda^{-2} + (0.0004 - 0.00005)\\lambda^{-4}\n$$\n$$\nf_{A-B}(\\lambda) \\;=\\; -0.04 \\;+\\; 0.008\\lambda^{-2} \\;+\\; 0.00035\\lambda^{-4}\n$$\nFor test cases $3$ and $4$, $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$. The coefficients are:\n- $A_C = 1.38$, $B_C = 0.03$, $C_C = 0.001$.\n- $A_D = 1.45$, $B_D = 0.005$, $C_D = 0.00015$.\nThe resulting function is:\n$$\nf_{C-D}(\\lambda) \\;=\\; (1.38 - 1.45) + (0.03 - 0.005)\\lambda^{-2} + (0.001 - 0.00015)\\lambda^{-4}\n$$\n$$\nf_{C-D}(\\lambda) \\;=\\; -0.07 \\;+\\; 0.025\\lambda^{-2} \\;+\\; 0.00085\\lambda^{-4}\n$$\n\nThe Bisection Method algorithm proceeds as follows:\n$1$. Start with an interval $[a, b]$, where $a = \\lambda_L$ and $b = \\lambda_R$. Verify that $f(a)$ and $f(b)$ have opposite signs, i.e., $f(a)f(b) < 0$. This condition, a consequence of the Intermediate Value Theorem, guarantees at least one root lies in $(a, b)$. All test cases provided fulfill this requirement.\n$2$. Compute the midpoint of the interval: $c = a + (b-a)/2$.\n$3$. Evaluate the function at the midpoint, $f(c)$.\n$4$. The true root $\\lambda^{\\ast}$ is guaranteed to be in the interval $[a, b]$. The midpoint $c$ is an approximation of $\\lambda^{\\ast}$ with an absolute error no greater than half the interval width: $|\\lambda^{\\ast} - c| \\le (b-a)/2$. The termination condition is to stop when this error bound is less than or equal to the specified tolerance $\\tau$. Therefore, the iterative process continues as long as $(b-a)/2 > \\tau$.\n$5$. If the process has not terminated, the interval is updated. If $f(a)f(c) < 0$, the root is in the left half of the interval, so the new interval becomes $[a, c]$. Otherwise, the root must be in the right half, and the new interval becomes $[c, b]$.\n$6$. Repeat from step $2$ with the new, smaller interval.\n\nUpon termination, the midpoint of the final interval is taken as the solution $\\lambda^{\\ast}$. This procedure will be implemented and applied to each of the four test cases with their respective functions, intervals $[\\lambda_{L}, \\lambda_{R}]$, and the specified tolerance $\\tau = 1.0 \\times 10^{-12}$. The final results will be expressed in micrometers, rounded to $12$ decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the root of f(lambda) = n1(lambda) - n2(lambda) = 0\n    using the bisection method for the given test cases.\n    \"\"\"\n    \n    # Material coefficients as per the problem statement.\n    # A (dimensionless), B (um^2), C (um^4)\n    materials = {\n        'M_A': (1.42, 0.01, 0.0004),\n        'M_B': (1.46, 0.002, 0.00005),\n        'M_C': (1.38, 0.03, 0.001),\n        'M_D': (1.45, 0.005, 0.00015),\n    }\n\n    # Define the test cases.\n    # Each case: (Material 1 name, Material 2 name, lambda_L, lambda_R, tolerance)\n    test_cases = [\n        ('M_A', 'M_B', 0.45, 0.50, 1.0e-12),\n        ('M_A', 'M_B', 0.486, 0.49, 1.0e-12),\n        ('M_C', 'M_D', 0.60, 0.65, 1.0e-12),\n        ('M_C', 'M_D', 0.40, 1.00, 1.0e-12),\n    ]\n\n    def bisection(func, a, b, tol):\n        \"\"\"\n        Implementation of the bisection method for root finding.\n\n        Args:\n            func: The function for which to find a root.\n            a: The left endpoint of the interval.\n            b: The right endpoint of the interval.\n            tol: The desired absolute error tolerance for the root.\n\n        Returns:\n            The estimated root of the function.\n        \"\"\"\n        fa = func(a)\n        fb = func(b)\n\n        if fa * fb >= 0:\n            # This should not happen for the given problem as a solution is assumed to exist.\n            raise ValueError(\"Bisection method requires function to have opposite signs at interval endpoints.\")\n\n        # The loop condition ensures the final midpoint has an error = tol.\n        # c = (a+b)/2, error is |c - root| = (b-a)/2. We need (b-a)/2 = tol.\n        while (b - a) / 2.0 > tol:\n            c = a + (b - a) / 2.0  # Use this form to avoid potential floating point overflow\n            fc = func(c)\n            \n            if fc == 0.0:\n                # Found the exact root\n                return c\n            \n            if fa * fc  0:\n                b = c\n                fb = fc # Not strictly necessary, but can be a micro-optimization\n            else:\n                a = c\n                fa = fc # Same as above\n\n        # Return the midpoint of the final interval\n        return a + (b - a) / 2.0\n\n    results = []\n    for case in test_cases:\n        mat1_name, mat2_name, lambda_L, lambda_R, tolerance = case\n        \n        A1, B1, C1 = materials[mat1_name]\n        A2, B2, C2 = materials[mat2_name]\n        \n        # Define the function f(lambda) = n1(lambda) - n2(lambda)\n        # f(x) = (A1-A2) + (B1-B2)/x^2 + (C1-C2)/x^4\n        def f(lam):\n            lam_sq = lam * lam\n            lam_q = lam_sq * lam_sq\n            return (A1 - A2) + (B1 - B2) / lam_sq + (C1 - C2) / lam_q\n\n        # Find the root using the bisection method\n        root = bisection(f, lambda_L, lambda_R, tolerance)\n        \n        # Format the result to 12 decimal places and append\n        results.append(f\"{root:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the bisection method is reliable, its convergence can be slow. The false position method, or regula falsi, offers a potentially faster alternative by using a more 'intelligent' guess based on a secant line approximation. This exercise is designed to let you directly compare the number of iterations required by both bisection and false position to find the root of $f(x) = \\arctan(x)$, revealing the performance trade-offs that are critical to understand in computational problem-solving .",
            "id": "2375433",
            "problem": "You are given the real-valued function $f(x) = \\arctan(x)$, where the inverse tangent is taken in radians. Consider closed intervals $\\left[a,b\\right]$ satisfying $a  b$ together with two positive tolerances $\\tau_x  0$ and $\\tau_f  0$, and a maximum iteration budget $N_{\\max} \\in \\mathbb{N}$. For each test case below, determine two integers: the number of iterations required by the bisection method and the number of iterations required by the false position (regula falsi) method to satisfy the termination criteria defined below.\n\nMethod definitions and termination criteria are as follows (they apply to both methods, with only the interior point formula differing):\n- Function and bracket prerequisites:\n  - The method acts on $f(x) = \\arctan(x)$, in radians.\n  - The initial bracket $\\left[a,b\\right]$ must satisfy either $f(a)\\cdot f(b)  0$ or $f(a) = 0$ or $f(b) = 0$.\n  - Use real arithmetic.\n- Initial zero detection without iteration:\n  - If $\\lvert f(a) \\rvert \\le \\tau_f$, return $0$ iterations.\n  - Else if $\\lvert f(b) \\rvert \\le \\tau_f$, return $0$ iterations.\n- Iterative step counting and updates:\n  - Initialize the iteration counter $n := 0$.\n  - Repeat until termination or $n = N_{\\max}$:\n    - Compute one new interior candidate $x_k$ and evaluate $f(x_k)$:\n      - Bisection interior point: $x_k = \\dfrac{a+b}{2}$.\n      - False position interior point: $x_k = a - f(a)\\dfrac{b-a}{f(b)-f(a)}$.\n    - Increase the counter: $n := n + 1$.\n    - If $\\lvert f(x_k) \\rvert \\le \\tau_f$, terminate and return $n$.\n    - Otherwise, update the bracket by replacing the endpoint that has the same sign as $f(x_k)$:\n      - If $f(a)\\cdot f(x_k)  0$, set $b := x_k$; else set $a := x_k$.\n    - After the update, if the new bracket length $\\lvert b-a \\rvert \\le \\tau_x$, terminate and return $n$.\n  - If $n$ reaches $N_{\\max}$ without meeting a termination criterion, return $n$.\n- Angle unit: all angles are in radians.\n\nTest suite. For each parameter tuple $(a,b,\\tau_x,\\tau_f,N_{\\max})$ below, compute and report the ordered pair $\\left[N_{\\text{bis}}, N_{\\text{fp}}\\right]$:\n1. $a=-1000$, $b=1001$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$.\n2. $a=-1$, $b=1$, $\\tau_x = 10^{-8}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$.\n3. $a=0$, $b=1$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$.\n4. $a=-1$, $b=0$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of the four ordered pairs in the exact order above, enclosed in square brackets. For example, the format must be like\n\"[[n11,n12],[n21,n22],[n31,n32],[n41,n42]]\"\nwhere $n_{i1}$ is the bisection iteration count and $n_{i2}$ is the false position iteration count for test case $i$. The final outputs must be integers. No additional text should be printed.",
            "solution": "We must quantify the iteration counts needed for the bisection and false position methods applied to the function $f(x) = \\arctan(x)$ in radians. Both methods rely on the intermediate value property and sign changes to isolate a root in a bracketing interval $\\left[a,b\\right]$. The function $f(x) = \\arctan(x)$ is continuous for all real $x$, strictly increasing, and has a unique real root at $x=0$, with $f(0)=0$. For any valid bracket $\\left[a,b\\right]$ satisfying $f(a)\\cdot f(b)  0$ or either endpoint being a root, both methods are applicable.\n\nIteration counting and termination are governed by the problem’s precisely stated rules. We now connect fundamental properties to algorithmic implications:\n\n1. Well-posedness and initial detection:\n   - Because $f$ is continuous and strictly increasing, any $\\left[a,b\\right]$ with $a0b$ must bracket the root at $x=0$ with $f(a)  0  f(b)$, unless an endpoint is already the root, that is, $f(0)=0$ when $a=0$ or $b=0$.\n   - By the rule, if initially $\\lvert f(a) \\rvert \\le \\tau_f$ or $\\lvert f(b) \\rvert \\le \\tau_f$, the iteration count is $0$.\n\n2. Bisection method fundamentals:\n   - Each iteration halves the bracket length. If $L_0 = b-a$ and $L_k$ denotes the length after $k$ updates, then $L_k = \\dfrac{L_0}{2^k}$.\n   - Under the problem’s counting convention, the width criterion is checked after updating the bracket, so achieving $\\lvert b-a \\rvert \\le \\tau_x$ requires\n     $$ k \\ge \\left\\lceil \\log_2 \\left(\\dfrac{L_0}{\\tau_x}\\right) \\right\\rceil. $$\n   - The function-value criterion is checked immediately after computing the interior point $x_k$ (the midpoint), before updating the bracket. Because the root is at $x=0$ and $0\\in [a,b]$ at all times, the midpoint $m_k$ satisfies $\\lvert m_k \\rvert \\le \\dfrac{L_{k-1}}{2}$. Moreover, for $\\lvert x \\rvert \\le 1$, we have $0 \\le \\lvert \\arctan(x) \\rvert \\le \\lvert x \\rvert$. Therefore, $\\lvert f(m_k) \\rvert \\le \\dfrac{L_{k-1}}{2}$. This shows that the function-value criterion will be satisfied once $L_{k-1} \\le 2\\tau_f$. Hence, depending on the tolerances and initial length $L_0$, termination may occur via the function-value check (before update) or via the width check (after update), with the iteration count exactly as specified by the rule sequence.\n\n3. False position (regula falsi) fundamentals:\n   - Each iteration computes the secant-interpolated root\n     $$ x_k = a - f(a)\\dfrac{b-a}{f(b)-f(a)}, $$\n     evaluates $f(x_k)$, and then replaces the endpoint having the same sign as $f(x_k)$.\n   - Because $f$ is continuous and strictly increasing, the root remains bracketed after each update. The bracketing interval $\\left[a,b\\right]$ shrinks monotonically in length (although not necessarily by a factor of $\\tfrac{1}{2}$ at every step), and the sequence $\\lvert f(x_k) \\rvert$ decreases to $0$.\n   - The termination criteria from the problem statement apply exactly as written: the function-value criterion is checked right after evaluating $f(x_k)$; if not met, the interval is updated, and then the width criterion is checked.\n\n4. Application to the test suite:\n   - Test case $1$: $a=-1000$, $b=1001$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$. Bisection needs approximately\n     $$ \\left\\lceil \\log_2\\left(\\dfrac{2001}{10^{-12}}\\right) \\right\\rceil = \\left\\lceil \\log_2\\left(2.001\\times 10^{15}\\right) \\right\\rceil = 51 $$\n     iterations if termination occurs via the width criterion. The function-value criterion can trigger when the midpoint is sufficiently close to $0$; under the given counting rule (function check before update, width check after update), the exact iteration is determined programmatically. For false position, due to near symmetry of $f(a)$ and $f(b)$ in magnitude, the first secant iterate is extremely close to $0$, so very few iterations are expected before the function-value criterion is met.\n   - Test case $2$: $a=-1$, $b=1$, $\\tau_x = 10^{-8}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$. Bisection requires\n     $$ \\left\\lceil \\log_2\\left(\\dfrac{2}{10^{-8}}\\right) \\right\\rceil = \\left\\lceil \\log_2\\left(2\\times 10^8\\right) \\right\\rceil = 28 $$\n     iterations to meet the width criterion. For false position, because $f(x)$ is odd and the bracket is symmetric, the first secant point is exactly $x=0$, so the method terminates after computing one candidate.\n   - Test cases $3$ and $4$ place the root at an endpoint: $[0,1]$ and $[-1,0]$. By the initial zero detection rule, both methods return $0$ iterations.\n\n5. Numerical computation and final aggregation:\n   - Implement the two methods strictly per the iteration counting and termination order given.\n   - For each test case, compute the ordered pair $\\left[N_{\\text{bis}}, N_{\\text{fp}}\\right]$ and collect all four pairs into a single list printed on one line, as required.\n\nThis principle-based design, combined with careful termination ordering, yields unambiguous, reproducible iteration counts that can be validated by any correct implementation using real arithmetic in radians.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nfrom typing import Callable, Tuple, List\n\ndef f(x: float) -> float:\n    # arctan in radians\n    return math.atan(x)\n\ndef bisection_iterations(\n    f: Callable[[float], float],\n    a: float,\n    b: float,\n    tau_x: float,\n    tau_f: float,\n    nmax: int\n) -> int:\n    fa = f(a)\n    if abs(fa) = tau_f:\n        return 0\n    fb = f(b)\n    if abs(fb) = tau_f:\n        return 0\n    # Require a sign change if neither endpoint is within function tolerance\n    if fa * fb > 0:\n        # Not a valid bracket; in this problem's test suite, this should not happen.\n        # To keep the function total, return nmax if invalid.\n        return nmax\n\n    n = 0\n    left, right = a, b\n    f_left, f_right = fa, fb\n\n    while n  nmax:\n        x = 0.5 * (left + right)\n        fx = f(x)\n        n += 1\n\n        # Function-value termination check immediately after evaluation\n        if abs(fx) = tau_f:\n            return n\n\n        # Update the bracket by sign\n        if f_left * fx  0:\n            right = x\n            f_right = fx\n        else:\n            left = x\n            f_left = fx\n\n        # Width termination check after the bracket update\n        if abs(right - left) = tau_x:\n            return n\n\n    return n  # Reached nmax\n\ndef false_position_iterations(\n    f: Callable[[float], float],\n    a: float,\n    b: float,\n    tau_x: float,\n    tau_f: float,\n    nmax: int\n) -> int:\n    fa = f(a)\n    if abs(fa) = tau_f:\n        return 0\n    fb = f(b)\n    if abs(fb) = tau_f:\n        return 0\n    if fa * fb > 0:\n        return nmax  # invalid bracket; not expected in test suite\n\n    n = 0\n    left, right = a, b\n    f_left, f_right = fa, fb\n\n    while n  nmax:\n        denom = (f_right - f_left)\n        # Guard against pathological zero denominator; fallback to mid-point if happens.\n        if denom == 0.0:\n            x = 0.5 * (left + right)\n        else:\n            x = left - f_left * (right - left) / denom\n\n        fx = f(x)\n        n += 1\n\n        # Function-value termination check immediately after evaluation\n        if abs(fx) = tau_f:\n            return n\n\n        # Update the bracket: replace the endpoint with same sign as f(x)\n        if f_left * fx  0:\n            right = x\n            f_right = fx\n        else:\n            left = x\n            f_left = fx\n\n        # Width termination check after the bracket update\n        if abs(right - left) = tau_x:\n            return n\n\n    return n  # Reached nmax\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, b, tau_x, tau_f, N_max)\n    test_cases = [\n        (-1000.0, 1001.0, 1e-12, 1e-12, 1_000_000),\n        (-1.0, 1.0, 1e-8, 1e-12, 1_000_000),\n        (0.0, 1.0, 1e-12, 1e-12, 1_000_000),\n        (-1.0, 0.0, 1e-12, 1e-12, 1_000_000),\n    ]\n\n    results: List[List[int]] = []\n    for a, b, tau_x, tau_f, nmax in test_cases:\n        n_bis = bisection_iterations(f, a, b, tau_x, tau_f, nmax)\n        n_fp = false_position_iterations(f, a, b, tau_x, tau_f, nmax)\n        results.append([int(n_bis), int(n_fp)])\n\n    # Final print statement in the exact required format.\n    # Ensure a single-line output with the nested list format.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The previous exercise may have revealed a significant weakness of the false position method: its tendency to stagnate when the function is strongly curved. This final practice moves from analysis to synthesis by asking you to build a more robust, \"defensive\" algorithm that combines the speed of false position with the reliability of bisection . Implementing this hybrid method, which detects stagnation and triggers a bisection step, mirrors a crucial aspect of computational engineering: improving upon standard algorithms to create tools that are both fast and failsafe.",
            "id": "2375457",
            "problem": "Design and implement a program that, for each specified test case, computes an approximation of a real root $x^\\star$ of a continuous scalar function $f:\\mathbb{R}\\to\\mathbb{R}$ in a closed interval $[a,b]$ satisfying the bracketing condition $f(a)\\cdot f(b)\\le 0$. The program must maintain the bracketing property at all times. At each iteration, the trial point $c$ must be chosen as follows: use the unique point on the straight line passing through $(a,f(a))$ and $(b,f(b))$ where this line intersects the $x$-axis, namely\n$$\nc_{\\text{rf}}=\\frac{a\\,f(b)-b\\,f(a)}{f(b)-f(a)},\n$$\nexcept when either $f(a)=f(b)$ or exactly the same endpoint has remained unchanged for at least $2$ consecutive iterations, in which case the next trial point must be the midpoint\n$$\nc_{\\text{bis}}=\\frac{a+b}{2}.\n$$\nAfter computing $c$ and $f(c)$, update the interval to $[a,c]$ or $[c,b]$ so that the updated interval continues to satisfy $f(a)\\cdot f(b)\\le 0$. If $|f(c)|\\le \\varepsilon_f$, or if $|b-a|\\le \\varepsilon_x$, terminate and return the current $c$ as the approximation. If $|f(a)|\\le \\varepsilon_f$ or $|f(b)|\\le \\varepsilon_f$ at any time, return the corresponding endpoint immediately. The iteration count must not exceed a given maximum $N_{\\max}$.\n\nFor all test cases below, use absolute function tolerance $\\varepsilon_f=10^{-12}$, absolute interval-width tolerance $\\varepsilon_x=10^{-12}$, and maximum iterations $N_{\\max}=100$. All real numbers in the output must be rounded to $10$ decimal places.\n\nTest suite to be solved by a single run of the program:\n- Case $1$: $f(x)=x^3 - x - 2$, with $a=1$ and $b=2$.\n- Case $2$: $f(x)=e^{-x} - x$, with $a=0$ and $b=1$.\n- Case $3$: $f(x)=x^3 + 10^{-6}x - 1$, with $a=0$ and $b=1$.\n- Case $4$: $f(x)=x$, with $a=0$ and $b=3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the approximated root for Case $i$, rounded to $10$ decimal places as specified.",
            "solution": "The user has specified the design and implementation of a root-finding algorithm. The problem statement will first be validated for correctness and completeness.\n\n**Step 1: Extract Givens**\n\nThe givens are extracted verbatim from the problem statement:\n- **Function**: A continuous scalar function $f:\\mathbb{R}\\to\\mathbb{R}$.\n- **Interval**: A closed interval $[a,b]$ such that the bracketing condition $f(a)\\cdot f(b)\\le 0$ is satisfied.\n- **Primary Trial Point (Regula Falsi)**: $$c_{\\text{rf}}=\\frac{a\\,f(b)-b\\,f(a)}{f(b)-f(a)}$$\n- **Secondary Trial Point (Bisection)**: $$c_{\\text{bis}}=\\frac{a+b}{2}$$\n- **Conditions for Bisection**: Bisection is to be used if either $f(a)=f(b)$ or if \"exactly the same endpoint has remained unchanged for at least $2$ consecutive iterations\".\n- **Interval Update Rule**: After computing a trial point $c$ and the function value $f(c)$, the new interval becomes either $[a,c]$ or $[c,b]$, whichever maintains the bracketing property.\n- **Termination Criteria and Return Values**:\n    1. If $|f(c)|\\le \\varepsilon_f$, terminate and return $c$.\n    2. If $|b-a|\\le \\varepsilon_x$, terminate and return $c$.\n    3. If at any time $|f(a)|\\le \\varepsilon_f$ or $|f(b)|\\le \\varepsilon_f$, terminate and return $a$ or $b$ respectively.\n    4. The maximum number of iterations is $N_{\\max}$.\n- **Parameters**:\n    - Absolute function tolerance: $\\varepsilon_f=10^{-12}$.\n    - Absolute interval-width tolerance: $\\varepsilon_x=10^{-12}$.\n    - Maximum iterations: $N_{\\max}=100$.\n- **Test Cases**:\n    - Case $1$: $f(x)=x^3 - x - 2$ on $[1, 2]$.\n    - Case $2$: $f(x)=e^{-x} - x$ on $[0, 1]$.\n    - Case $3$: $f(x)=x^3 + 10^{-6}x - 1$ on $[0, 1]$.\n    - Case $4$: $f(x)=x$ on $[0, 3]$.\n- **Output Format**: Results for all test cases as a comma-separated list in square brackets, with each result rounded to $10$ decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem describes a hybrid numerical method combining the Regula Falsi (False Position) method and the Bisection method. This is a standard and well-documented technique in numerical analysis, a core discipline within computational engineering and applied mathematics. The modification to address the stagnation of the Regula Falsi method is a known improvement strategy (related to the Illinois algorithm). The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It provides specific functions, initial intervals that satisfy the required bracketing condition, explicit algorithmic steps, and unambiguous termination criteria. For an appropriately chosen function and interval, the algorithm is guaranteed to converge to a root.\n- **Objective**: The problem is stated in precise, objective mathematical language, free of any subjective or non-formalizable content.\n\nAll criteria for a valid problem are met. There are no violations of scientific principles, no contradictions, and no ambiguities that would prevent a rigorous implementation.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. A solution will be constructed.\n\n**Principle-Based Solution**\n\nThe objective is to find a real root $x^\\star$ of a continuous function $f(x)$ within an interval $[a, b]$, where $f(a)$ and $f(b)$ have opposite signs or one is zero, i.e., $f(a)f(b) \\le 0$. The Intermediate Value Theorem guarantees that at least one root exists in this interval. The specified method is a bracketing algorithm, meaning it systematically shrinks the interval $[a, b]$ while ensuring the root remains within it.\n\nThe core of the algorithm is an iterative process. At each step $k$, we have an interval $[a_k, b_k]$ containing a root. We must choose a new point $c_k \\in (a_k, b_k)$ to test.\n\nThe primary method for choosing $c_k$ is the Regula Falsi method. This involves constructing a straight line (a secant) through the points $(a_k, f(a_k))$ and $(b_k, f(b_k))$. The next approximation $c_k$ is the point where this line intersects the $x$-axis. The formula for this point is derived from the two-point form of a line equation and is given as:\n$$\nc_{\\text{rf}} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}\n$$\nThis method often converges faster than the Bisection method. However, it has a significant drawback: if the function is strongly curved, one of the endpoints of the interval may become \"stuck\" (remain unchanged for many iterations), leading to very slow convergence. The interval width $|b_k - a_k|$ may not approach zero.\n\nTo combat this stagnation, the problem specifies a hybrid strategy. The Regula Falsi method is the default, but if stagnation is detected, a different trial point is used. Stagnation is defined as the case where \"exactly the same endpoint has remained unchanged for at least $2$ consecutive iterations\". In this situation, or if $f(a_k) = f(b_k)$ (which makes the denominator of $c_{\\text{rf}}$ zero), the algorithm must switch to the Bisection method for one step. The bisection trial point is simply the midpoint of the interval:\n$$\nc_{\\text{bis}} = \\frac{a_k + b_k}{2}\n$$\nThe bisection step forces the search to move away from the stagnant endpoint, typically breaking the pattern of slow convergence. After a bisection step is taken, the stagnation counter is reset, and the algorithm reverts to using Regula Falsi.\n\nAfter calculating the trial point $c_k$ (either $c_{\\text{rf}}$ or $c_{\\text{bis}}$) and its function value $f(c_k)$, the interval for the next iteration, $[a_{k+1}, b_{k+1}]$, is determined. To maintain the bracketing property, we check the sign of $f(c_k)$:\n- If $f(a_k) f(c_k)  0$, the root is in $[a_k, c_k]$, so we set $a_{k+1} = a_k$ and $b_{k+1} = c_k$. In this case, endpoint $a_k$ remains unchanged.\n- If $f(b_k) f(c_k)  0$ (which is equivalent to $f(a_k) f(c_k)  0$ since $f(a_k) f(b_k)  0$), the root is in $[c_k, b_k]$, so we set $a_{k+1} = c_k$ and $b_{k+1} = b_k$. In this case, endpoint $b_k$ remains unchanged.\n- If $f(c_k) = 0$, the root has been found exactly.\n\nThis process is repeated until one of the specified termination criteria is met:\n1. The function value at the trial point is sufficiently close to zero: $|f(c_k)| \\le \\varepsilon_f$.\n2. The width of the bracketing interval is sufficiently small: $|b_k - a_k| \\le \\varepsilon_x$.\n3. The iteration limit $N_{\\max}$ is reached.\n\nThe problem also specifies that at the beginning of each iteration, the function values at the endpoints, $f(a_k)$ and $f(b_k)$, should be checked against $\\varepsilon_f$. If either is small enough, that endpoint is taken as the root.\n\nThe implementation will maintain a counter for consecutive iterations where the same endpoint is retained. If this counter reaches $2$, a bisection step is forced for the current iteration, and the counter is reset.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases and print the results.\n    \"\"\"\n\n    def find_root(f, a, b, eps_f, eps_x, n_max):\n        \"\"\"\n        Computes a root of f in [a, b] using a hybrid of Regula Falsi and Bisection.\n\n        Args:\n            f (callable): The function for which to find a root.\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            eps_f (float): Absolute function value tolerance.\n            eps_x (float): Absolute interval width tolerance.\n            n_max (int): Maximum number of iterations.\n\n        Returns:\n            float: The approximated root.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        # Initial checks on endpoints as per problem statement\n        if abs(fa) = eps_f:\n            return a\n        if abs(fb) = eps_f:\n            return b\n\n        # The problem statement guarantees the bracketing condition f(a)*f(b) = 0\n        \n        stagnant_counter = 0\n        # This flag tracks which endpoint ('a' or 'b') was unchanged in the last update.\n        # True if 'a' was unchanged, False if 'b' was unchanged, None otherwise.\n        last_unchanged_endpoint_is_a = None\n        \n        c = a # Initialize c to a valid float\n\n        for _ in range(n_max):\n            \n            # Determine if a bisection step is required\n            use_bisection = (stagnant_counter >= 2) or (fa == fb)\n            \n            # Calculate trial point c\n            if use_bisection:\n                c = (a + b) / 2.0\n            else:\n                c = (a * fb - b * fa) / (fb - fa)\n\n            fc = f(c)\n\n            # Termination checks, in the order specified by the problem.\n            # The problem states to return the *current* c if interval width is small.\n            if abs(b - a) = eps_x:\n                return c\n            \n            if abs(fc) = eps_f:\n                return c\n\n            # Update the interval and stagnation state\n            is_bisect_step = use_bisection\n\n            if fa * fc  0:  # Root is in [a, c], so b is updated\n                b = c\n                fb = fc\n                # Endpoint 'a' has remained unchanged\n                if last_unchanged_endpoint_is_a is True:\n                    stagnant_counter += 1\n                else:\n                    last_unchanged_endpoint_is_a = True\n                    stagnant_counter = 1\n            elif fb * fc  0:  # Root is in [c, b], so a is updated\n                a = c\n                fa = fc\n                # Endpoint 'b' has remained unchanged\n                if last_unchanged_endpoint_is_a is False:\n                    stagnant_counter += 1\n                else:\n                    last_unchanged_endpoint_is_a = False\n                    stagnant_counter = 1\n            else:  # This case implies fc is 0.0, which is handled by the termination condition above\n                return c\n\n            # After a bisection step, reset the stagnation counter\n            if is_bisect_step:\n                stagnant_counter = 0\n                last_unchanged_endpoint_is_a = None\n\n        # Return the last computed c if max iterations is reached\n        return c\n\n    # Define common parameters for all test cases\n    eps_f = 1e-12\n    eps_x = 1e-12\n    n_max = 100\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (lambda x: x**3 - x - 2, 1.0, 2.0),\n        (lambda x: np.exp(-x) - x, 0.0, 1.0),\n        (lambda x: x**3 + 1e-6 * x - 1, 0.0, 1.0),\n        (lambda x: x, 0.0, 3.0),\n    ]\n\n    results = []\n    for f, a, b in test_cases:\n        root = find_root(f, a, b, eps_f, eps_x, n_max)\n        # Format the result to 10 decimal places as a string\n        results.append(f\"{root:.10f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}