{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。在工程和科学领域，许多问题最终都归结为求解方程的根。本节的第一个练习将带你进入光学工程的世界，任务是找到两种不同材料折射率完全相同的特定光波长。这个问题将引导你实现可靠的二分法 ()，这是一个基本但功能强大的工具，用于解决这类实际的、基于物理的根求解问题。",
            "id": "2375454",
            "problem": "定义一个单变量连续标量函数，其值为两个折射率色散定律之差，每个定律均由一个三项Cauchy模型给出。对于一种系数为 $A$、$B$ 和 $C$ 的材料，以及以微米为单位的真空波长 $\\lambda$，其折射率由以下模型描述：\n$$\nn(\\lambda) \\;=\\; A \\;+\\; \\frac{B}{\\lambda^{2}} \\;+\\; \\frac{C}{\\lambda^{4}} \\quad \\text{for} \\quad \\lambda \\gt 0.\n$$\n对于下方的每个测试用例，使用指定的材料和系数对定义 $f(\\lambda) \\;=\\; n_{1}(\\lambda) \\;-\\; n_{2}(\\lambda)$。对于每个给定的闭区间 $[\\lambda_{L}, \\lambda_{R}]$ 和绝对容差 $\\tau$，在假设函数 $f$ 在 $[\\lambda_{L}, \\lambda_{R}]$ 上连续且每种情况下都存在解的前提下，确定一个值 $\\lambda^{\\ast} \\in [\\lambda_{L}, \\lambda_{R}]$，使得 $f(\\lambda^{\\ast}) = 0$，且波长变量的绝对误差最多为 $\\tau$。\n\n使用Cauchy模型和以下物理上合理的系数组（所有波长单位均为微米）：\n- 材料 $M_{A}$：$A = 1.42$，$B = 0.01$，$C = 0.0004$。\n- 材料 $M_{B}$：$A = 1.46$，$B = 0.002$，$C = 0.00005$。\n- 材料 $M_{C}$：$A = 1.38$，$B = 0.03$，$C = 0.001$。\n- 材料 $M_{D}$：$A = 1.45$，$B = 0.005$，$C = 0.00015$。\n\n测试套件：\n1. $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$ 在 $[\\lambda_{L}, \\lambda_{R}] = [0.45, 0.50]$ 上，$\\tau = 1.0 \\times 10^{-12}$。\n2. $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$ 在 $[\\lambda_{L}, \\lambda_{R}] = [0.486, 0.49]$ 上，$\\tau = 1.0 \\times 10^{-12}$。\n3. $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$ 在 $[\\lambda_{L}, \\lambda_{R}] = [0.60, 0.65]$ 上，$\\tau = 1.0 \\times 10^{-12}$。\n4. $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$ 在 $[\\lambda_{L}, \\lambda_{R}] = [0.40, 1.00]$ 上，$\\tau = 1.0 \\times 10^{-12}$。\n\n每个波长均以微米表示，并四舍五入到$12$位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[x_{1},x_{2},x_{3},x_{4}]$），其中每个 $x_{k}$ 是测试用例 $k$ 计算出的 $\\lambda^{\\ast}$。",
            "solution": "该问题要求在指定的区间 $[\\lambda_{L}, \\lambda_{R}]$ 和绝对误差容差 $\\tau$ 内，为函数 $f(\\lambda) = n_{1}(\\lambda) - n_{2}(\\lambda) = 0$ 找到一个根 $\\lambda^{\\ast}$。每种材料的折射率 $n(\\lambda)$ 由三项Cauchy模型给出：\n$$\nn(\\lambda) \\;=\\; A \\;+\\; \\frac{B}{\\lambda^{2}} \\;+\\; \\frac{C}{\\lambda^{4}}\n$$\n其中 $\\lambda$ 是以微米为单位的真空波长。因此，待求解的函数为：\n$$\nf(\\lambda) \\;=\\; (A_{1} - A_{2}) \\;+\\; (B_{1} - B_{2})\\lambda^{-2} \\;+\\; (C_{1} - C_{2})\\lambda^{-4} \\;=\\; 0\n$$\n这是一个在闭区间上求解连续函数根的标准问题。问题陈述保证了在每个给定区间内存在解，并且函数是连续的。在这些条件下，并注意到该问题是在计算方法的背景下提出的，二分法是完成此任务的合适且稳健的算法。如果函数在区间端点的值异号，则其收敛性得到保证。\n\n让我们为待分析的两个函数定义系数：\n对于测试用例 $1$ 和 $2$，$f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$。其系数为：\n- $A_A = 1.42$, $B_A = 0.01$, $C_A = 0.0004$。\n- $A_B = 1.46$, $B_B = 0.002$, $C_B = 0.00005$。\n得到的函数是：\n$$\nf_{A-B}(\\lambda) \\;=\\; (1.42 - 1.46) + (0.01 - 0.002)\\lambda^{-2} + (0.0004 - 0.00005)\\lambda^{-4}\n$$\n$$\nf_{A-B}(\\lambda) \\;=\\; -0.04 \\;+\\; 0.008\\lambda^{-2} \\;+\\; 0.00035\\lambda^{-4}\n$$\n对于测试用例 $3$ 和 $4$，$f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$。其系数为：\n- $A_C = 1.38$, $B_C = 0.03$, $C_C = 0.001$。\n- $A_D = 1.45$, $B_D = 0.005$, $C_D = 0.00015$。\n得到的函数是：\n$$\nf_{C-D}(\\lambda) \\;=\\; (1.38 - 1.45) + (0.03 - 0.005)\\lambda^{-2} + (0.001 - 0.00015)\\lambda^{-4}\n$$\n$$\nf_{C-D}(\\lambda) \\;=\\; -0.07 \\;+\\; 0.025\\lambda^{-2} \\;+\\; 0.00085\\lambda^{-4}\n$$\n\n二分法算法流程如下：\n$1$. 从区间 $[a, b]$ 开始，其中 $a = \\lambda_L$，$b = \\lambda_R$。验证 $f(a)$ 和 $f(b)$ 异号，即 $f(a)f(b)  0$。该条件是介值定理的一个推论，保证了在 $(a, b)$ 内至少存在一个根。所有提供的测试用例都满足此要求。\n$2$. 计算区间的中点：$c = a + (b-a)/2$。\n$3$. 计算中点处的函数值 $f(c)$。\n$4$. 真实根 $\\lambda^{\\ast}$ 保证在区间 $[a, b]$ 内。中点 $c$ 是 $\\lambda^{\\ast}$ 的一个近似值，其绝对误差不大于区间宽度的一半：$|\\lambda^{\\ast} - c| \\le (b-a)/2$。终止条件是当此误差界小于或等于指定的容差 $\\tau$ 时停止。因此，只要 $(b-a)/2 > \\tau$，迭代过程就继续进行。\n$5$. 如果过程尚未终止，则更新区间。如果 $f(a)f(c)  0$，则根位于区间的左半部分，因此新区间变为 $[a, c]$。否则，根必在右半部分，新区间变为 $[c, b]$。\n$6$. 使用新的、更小的区间从步骤2开始重复。\n\n终止时，最终区间的中点被视为解 $\\lambda^{\\ast}$。此过程将被实现并应用于四个测试用例中的每一个，使用它们各自的函数、区间 $[\\lambda_{L}, \\lambda_{R}]$ 和指定的容差 $\\tau = 1.0 \\times 10^{-12}$。最终结果将以微米表示，并四舍五入到$12$位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the root of f(lambda) = n1(lambda) - n2(lambda) = 0\n    using the bisection method for the given test cases.\n    \"\"\"\n    \n    # Material coefficients as per the problem statement.\n    # A (dimensionless), B (um^2), C (um^4)\n    materials = {\n        'M_A': (1.42, 0.01, 0.0004),\n        'M_B': (1.46, 0.002, 0.00005),\n        'M_C': (1.38, 0.03, 0.001),\n        'M_D': (1.45, 0.005, 0.00015),\n    }\n\n    # Define the test cases.\n    # Each case: (Material 1 name, Material 2 name, lambda_L, lambda_R, tolerance)\n    test_cases = [\n        ('M_A', 'M_B', 0.45, 0.50, 1.0e-12),\n        ('M_A', 'M_B', 0.486, 0.49, 1.0e-12),\n        ('M_C', 'M_D', 0.60, 0.65, 1.0e-12),\n        ('M_C', 'M_D', 0.40, 1.00, 1.0e-12),\n    ]\n\n    def bisection(func, a, b, tol):\n        \"\"\"\n        Implementation of the bisection method for root finding.\n\n        Args:\n            func: The function for which to find a root.\n            a: The left endpoint of the interval.\n            b: The right endpoint of the interval.\n            tol: The desired absolute error tolerance for the root.\n\n        Returns:\n            The estimated root of the function.\n        \"\"\"\n        fa = func(a)\n        fb = func(b)\n\n        if fa * fb >= 0:\n            # This should not happen for the given problem as a solution is assumed to exist.\n            raise ValueError(\"Bisection method requires function to have opposite signs at interval endpoints.\")\n\n        # The loop condition ensures the final midpoint has an error = tol.\n        # c = (a+b)/2, error is |c - root| = (b-a)/2. We need (b-a)/2 = tol.\n        while (b - a) / 2.0 > tol:\n            c = a + (b - a) / 2.0  # Use this form to avoid potential floating point overflow\n            fc = func(c)\n            \n            if fc == 0.0:\n                # Found the exact root\n                return c\n            \n            if fa * fc  0:\n                b = c\n                fb = fc # Not strictly necessary, but can be a micro-optimization\n            else:\n                a = c\n                fa = fc # Same as above\n\n        # Return the midpoint of the final interval\n        return a + (b - a) / 2.0\n\n    results = []\n    for case in test_cases:\n        mat1_name, mat2_name, lambda_L, lambda_R, tolerance = case\n        \n        A1, B1, C1 = materials[mat1_name]\n        A2, B2, C2 = materials[mat2_name]\n        \n        # Define the function f(lambda) = n1(lambda) - n2(lambda)\n        # f(x) = (A1-A2) + (B1-B2)/x^2 + (C1-C2)/x^4\n        def f(lam):\n            lam_sq = lam * lam\n            lam_q = lam_sq * lam_sq\n            return (A1 - A2) + (B1 - B2) / lam_sq + (C1 - C2) / lam_q\n\n        # Find the root using the bisection method\n        root = bisection(f, lambda_L, lambda_R, tolerance)\n        \n        # Format the result to 12 decimal places and append\n        results.append(f\"{root:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "虽然二分法很可靠，但它的收敛速度有时可能不尽人意。相比之下，试位法（或称线性插值法）通过利用函数值本身来构造割线，通常能更快地逼近根。然而，速度的提升并非没有代价。这个练习 () 将让你直接比较这两种方法的性能，揭示标准试位法在某些函数上可能出现的“停滞”现象，从而强调了深刻理解算法行为的重要性，而不仅仅是记住公式。",
            "id": "2375433",
            "problem": "给定一个实值函数 $f(x) = \\arctan(x)$，其中反正切值的单位为弧度。考虑满足 $a  b$ 的闭区间 $\\left[a,b\\right]$，以及两个正公差 $\\tau_x  0$ 和 $\\tau_f  0$，还有一个最大迭代预算 $N_{\\max} \\in \\mathbb{N}$。对于下方的每个测试用例，请确定两个整数：二分法所需的迭代次数和试位法 (regula falsi) 所需的迭代次数，以满足下面定义的终止准则。\n\n方法定义和终止准则如下（它们适用于两种方法，仅内点公式不同）：\n- 函数和区间先决条件：\n  - 该方法作用于函数 $f(x) = \\arctan(x)$，单位为弧度。\n  - 初始区间 $\\left[a,b\\right]$ 必须满足 $f(a)\\cdot f(b)  0$ 或 $f(a) = 0$ 或 $f(b) = 0$。\n  - 使用实数算术。\n- 无需迭代的初始零点检测：\n  - 如果 $\\lvert f(a) \\rvert \\le \\tau_f$，返回 $0$ 次迭代。\n  - 否则，如果 $\\lvert f(b) \\rvert \\le \\tau_f$，返回 $0$ 次迭代。\n- 迭代步数计数与更新：\n  - 初始化迭代计数器 $n := 0$。\n  - 重复执行直到满足终止条件或 $n = N_{\\max}$：\n    - 计算一个新的内部候选点 $x_k$ 并评估 $f(x_k)$：\n      - 二分法内点：$x_k = \\dfrac{a+b}{2}$。\n      - 试位法内点：$x_k = a - f(a)\\dfrac{b-a}{f(b)-f(a)}$。\n    - 增加计数器：$n := n + 1$。\n    - 如果 $\\lvert f(x_k) \\rvert \\le \\tau_f$，则终止并返回 $n$。\n    - 否则，通过替换与 $f(x_k)$ 符号相同的端点来更新区间：\n      - 如果 $f(a)\\cdot f(x_k)  0$，则设 $b := x_k$；否则设 $a := x_k$。\n    - 更新后，如果新区间长度 $\\lvert b-a \\rvert \\le \\tau_x$，则终止并返回 $n$。\n  - 如果在未满足终止准则的情况下 $n$ 达到 $N_{\\max}$，则返回 $n$。\n- 角度单位：所有角度均以弧度为单位。\n\n测试套件。对于下方的每个参数元组 $(a,b,\\tau_x,\\tau_f,N_{\\max})$，计算并报告有序对 $\\left[N_{\\text{bis}}, N_{\\text{fp}}\\right]$：\n1. $a=-1000$, $b=1001$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$。\n2. $a=-1$, $b=1$, $\\tau_x = 10^{-8}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$。\n3. $a=0$, $b=1$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$。\n4. $a=-1$, $b=0$, $\\tau_x = 10^{-12}$, $\\tau_f = 10^{-12}$, $N_{\\max}=10^{6}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内含按上述顺序排列的四个有序对，并用方括号括起来。例如，格式必须类似于\n\"[[n11,n12],[n21,n22],[n31,n32],[n41,n42]]\"\n其中 $n_{i1}$ 是测试用例 $i$ 的二分法迭代次数，$n_{i2}$ 是试位法的迭代次数。最终输出必须是整数。不应打印任何额外文本。",
            "solution": "我们必须量化将二分法和试位法应用于以弧度为单位的函数 $f(x) = \\arctan(x)$ 时所需的迭代次数。这两种方法都依赖于介值性质和符号变化来在括弧区间 $\\left[a,b\\right]$ 中隔离一个根。函数 $f(x) = \\arctan(x)$ 对所有实数 $x$ 都是连续的、严格递增的，并且在 $x=0$ 处有唯一的实根，其中 $f(0)=0$。对于任何满足 $f(a)\\cdot f(b)  0$ 或任一端点是根的有效区间 $\\left[a,b\\right]$，这两种方法都适用。\n\n迭代计数和终止遵循问题中精确陈述的规则。现在我们将基本性质与算法含义联系起来：\n\n1. 适定性和初始检测：\n   - 因为 $f$ 是连续且严格递增的，所以任何满足 $a  0  b$ 的区间都会有 $f(a)  0  f(b)$，因此 $f(a)f(b)  0$。\n   - 案例3和4的区间分别包含 $a=0$ 和 $b=0$。由于 $f(0)=0$，初始检测 $\\lvert f(a) \\rvert \\le \\tau_f$ 或 $\\lvert f(b) \\rvert \\le \\tau_f$ 将立即满足。因此，对于案例3和4，两种方法都将报告0次迭代。\n\n2. 二分法：\n   - 二分法通过将区间大小减半来收敛。其性能仅取决于初始区间宽度 $\\lvert b-a \\rvert$ 和容差 $\\tau_x$ 或 $\\tau_f$。对于 $\\arctan(x)$，当 $x$ 接近0时，$\\arctan(x) \\approx x$。因此，$\\tau_x$ 和 $\\tau_f$ 的终止条件将大致同时满足。\n   - 案例1的区间非常宽，而案例2的区间很窄。因此，案例1的二分法将需要比案例2更多的迭代。\n\n3. 试位法 (Regula Falsi) 和函数曲率：\n   - 试位法利用连接 $(a,f(a))$ 和 $(b,f(b))$ 的割线。$\\arctan(x)$ 函数对于 $x > 0$ 是凹的（$f''(x)  0$），对于 $x  0$ 是凸的（$f''(x) > 0$）。\n   - 案例1：区间 $[-1000, 1001]$ 是非对称的。割线将系统性地高估根（即，割线与x轴的交点将大于0），因为函数在负区间的“陡峭度”比正区间略大。每次迭代都会用一个新的正值替换 $b$，而 $a=-1000$ 将会“停滞”。这将导致非常缓慢的收敛，特别是当 $\\tau_x$ 是主要的终止准则时。\n   - 案例2：区间 $[-1, 1]$ 是对称的。由于 $\\arctan(x)$ 是一个奇函数（$\\arctan(-x) = -\\arctan(x)$），连接 $(-1, f(-1))$ 和 $(1, f(1))$ 的割线将精确地穿过原点 $(0,0)$。因此，试位法将在第一次迭代中找到根 $x=0$，并因 $\\lvert f(0) \\rvert \\le \\tau_f$ 而终止，报告1次迭代。\n\n基于这些分析的预期结果：\n- 案例1：$N_{\\text{bis}}$ 会是一个合理的值（约50-60次），而 $N_{\\text{fp}}$ 会非常大，因为停滞问题。\n- 案例2：$N_{\\text{bis}}$ 会是一个中等值（约25-30次），而 $N_{\\text{fp}}$ 会是1。\n- 案例3：$N_{\\text{bis}} = 0, N_{\\text{fp}} = 0$。\n- 案例4：$N_{\\text{bis}} = 0, N_{\\text{fp}} = 0$。\n\n这些预期可以通过实现问题中描述的精确算法来验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nfrom typing import Callable, Tuple, List\n\ndef f(x: float) -> float:\n    # arctan in radians\n    return math.atan(x)\n\ndef bisection_iterations(\n    f: Callable[[float], float],\n    a: float,\n    b: float,\n    tau_x: float,\n    tau_f: float,\n    nmax: int\n) -> int:\n    fa = f(a)\n    if abs(fa) = tau_f:\n        return 0\n    fb = f(b)\n    if abs(fb) = tau_f:\n        return 0\n    # Require a sign change if neither endpoint is within function tolerance\n    if fa * fb > 0:\n        # Not a valid bracket; in this problem's test suite, this should not happen.\n        # To keep the function total, return nmax if invalid.\n        return nmax\n\n    n = 0\n    left, right = a, b\n    f_left, f_right = fa, fb\n\n    while n  nmax:\n        x = 0.5 * (left + right)\n        fx = f(x)\n        n += 1\n\n        # Function-value termination check immediately after evaluation\n        if abs(fx) = tau_f:\n            return n\n\n        # Update the bracket by sign\n        if f_left * fx  0:\n            right = x\n            f_right = fx\n        else:\n            left = x\n            f_left = fx\n\n        # Width termination check after the bracket update\n        if abs(right - left) = tau_x:\n            return n\n\n    return n  # Reached nmax\n\ndef false_position_iterations(\n    f: Callable[[float], float],\n    a: float,\n    b: float,\n    tau_x: float,\n    tau_f: float,\n    nmax: int\n) -> int:\n    fa = f(a)\n    if abs(fa) = tau_f:\n        return 0\n    fb = f(b)\n    if abs(fb) = tau_f:\n        return 0\n    if fa * fb > 0:\n        return nmax  # invalid bracket; not expected in test suite\n\n    n = 0\n    left, right = a, b\n    f_left, f_right = fa, fb\n\n    while n  nmax:\n        denom = (f_right - f_left)\n        # Guard against pathological zero denominator; fallback to mid-point if happens.\n        if denom == 0.0:\n            x = 0.5 * (left + right)\n        else:\n            x = left - f_left * (right - left) / denom\n\n        fx = f(x)\n        n += 1\n\n        # Function-value termination check immediately after evaluation\n        if abs(fx) = tau_f:\n            return n\n\n        # Update the bracket: replace the endpoint with same sign as f(x)\n        if f_left * fx  0:\n            right = x\n            f_right = fx\n        else:\n            left = x\n            f_left = fx\n\n        # Width termination check after the bracket update\n        if abs(right - left) = tau_x:\n            return n\n\n    return n  # Reached nmax\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, b, tau_x, tau_f, N_max)\n    test_cases = [\n        (-1000.0, 1001.0, 1e-12, 1e-12, 1_000_000),\n        (-1.0, 1.0, 1e-8, 1e-12, 1_000_000),\n        (0.0, 1.0, 1e-12, 1e-12, 1_000_000),\n        (-1.0, 0.0, 1e-12, 1e-12, 1_000_000),\n    ]\n\n    results: List[List[int]] = []\n    for a, b, tau_x, tau_f, nmax in test_cases:\n        n_bis = bisection_iterations(f, a, b, tau_x, tau_f, nmax)\n        n_fp = false_position_iterations(f, a, b, tau_x, tau_f, nmax)\n        results.append([int(n_bis), int(n_fp)])\n\n    # Final print statement in the exact required format.\n    # Ensure a single-line output with the nested list format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习中，我们发现了标准试位法的潜在缺陷。那么，我们能否设计一个更“智能”的算法，既能享受试位法的快速收敛，又能避免其停滞的风险？这个练习 () 正是为此而设。你将构建一个混合方法，它以试位法为基础，但能智能地检测停滞并自动切换到二分法步骤。完成这个练习标志着你从算法的使用者向健壮数值工具的设计者迈出了关键一步。",
            "id": "2375457",
            "problem": "设计并实现一个程序，该程序为每个指定的测试用例，计算一个连续标量函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 在满足括号条件 $f(a)\\cdot f(b)\\le 0$ 的闭区间 $[a,b]$ 上的一个实根 $x^\\star$ 的近似值。程序必须始终保持括号性质。在每次迭代中，必须按如下方式选择试探点 $c$：使用通过点 $(a,f(a))$ 和 $(b,f(b))$ 的直线与 $x$ 轴相交的唯一点，即\n$$\nc_{\\text{rf}}=\\frac{a\\,f(b)-b\\,f(a)}{f(b)-f(a)},\n$$\n除非 $f(a)=f(b)$ 或完全相同的端点连续至少2次迭代保持不变，在这种情况下，下一个试探点必须是中点\n$$\nc_{\\text{bis}}=\\frac{a+b}{2}。\n$$\n计算出 $c$ 和 $f(c)$ 后，将区间更新为 $[a,c]$ 或 $[c,b]$，以使更新后的区间继续满足 $f(a)\\cdot f(b)\\le 0$。如果 $|f(c)|\\le \\varepsilon_f$ 或 $|b-a|\\le \\varepsilon_x$，则终止并将当前的 $c$ 作为近似值返回。如果在任何时候 $|f(a)|\\le \\varepsilon_f$ 或 $|f(b)|\\le \\varepsilon_f$，则立即返回相应的端点。迭代次数不得超过给定的最大值 $N_{\\max}$。\n\n对于下面的所有测试用例，使用绝对函数容差 $\\varepsilon_f=10^{-12}$，绝对区间宽度容差 $\\varepsilon_x=10^{-12}$，以及最大迭代次数 $N_{\\max}=100$。输出中的所有实数必须四舍五入到小数点后10位。\n\n由单次程序运行解决的测试套件：\n- 案例1：$f(x)=x^3 - x - 2$，其中 $a=1$，$b=2$。\n- 案例2：$f(x)=e^{-x} - x$，其中 $a=0$，$b=1$。\n- 案例3：$f(x)=x^3 + 10^{-6}x - 1$，其中 $a=0$，$b=1$。\n- 案例4：$f(x)=x$，其中 $a=0$，$b=3$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是案例 $i$ 的近似根，按规定四舍五入到小数点后10位。",
            "solution": "用户指定了寻根算法的设计与实现。首先将验证问题陈述的正确性和完整性。\n\n**步骤1：提取给定条件**\n\n给定条件逐字从问题陈述中提取：\n- **函数**：一个连续标量函数 $f:\\mathbb{R}\\to\\mathbb{R}$。\n- **区间**：一个闭区间 $[a,b]$，满足括号条件 $f(a)\\cdot f(b)\\le 0$。\n- **主试探点（试位法）**：$$c_{\\text{rf}}=\\frac{a\\,f(b)-b\\,f(a)}{f(b)-f(a)}$$\n- **次试探点（二分法）**：$$c_{\\text{bis}}=\\frac{a+b}{2}$$\n- **二分法的条件**：如果 $f(a)=f(b)$ 或者“完全相同的端点连续至少2次迭代保持不变”，则使用二分法。\n- **区间更新规则**：计算试探点 $c$ 和函数值 $f(c)$ 后，新区间变为 $[a,c]$ 或 $[c,b]$，以保持括号性质的那个为准。\n- **终止标准和返回值**：\n    1. 如果 $|f(c)|\\le \\varepsilon_f$，终止并返回 $c$。\n    2. 如果 $|b-a|\\le \\varepsilon_x$，终止并返回 $c$。\n    3. 如果在任何时候 $|f(a)|\\le \\varepsilon_f$ 或 $|f(b)|\\le \\varepsilon_f$，则终止并分别返回 $a$ 或 $b$。\n    4. 最大迭代次数为 $N_{\\max}$。\n- **参数**：\n    - 绝对函数容差：$\\varepsilon_f=10^{-12}$。\n    - 绝对区间宽度容差：$\\varepsilon_x=10^{-12}$。\n    - 最大迭代次数：$N_{\\max}=100$。\n- **测试用例**：\n    - 案例1：$f(x)=x^3 - x - 2$ 在 $[1, 2]$ 上。\n    - 案例2：$f(x)=e^{-x} - x$ 在 $[0, 1]$ 上。\n    - 案例3：$f(x)=x^3 + 10^{-6}x - 1$ 在 $[0, 1]$ 上。\n    - 案例4：$f(x)=x$ 在 $[0, 3]$ 上。\n- **输出格式**：所有测试用例的结果以方括号内的逗号分隔列表形式呈现，每个结果四舍五入到小数点后10位。\n\n**步骤2：使用提取的给定条件进行验证**\n\n根据验证标准对问题进行评估。\n- **有科学依据**：该问题描述了一种结合了试位法（Regula Falsi 或 False Position method）和二分法的混合数值方法。这是数值分析中的一种标准且有据可查的技术，而数值分析是计算工程和应用数学中的核心学科。为解决试位法停滞问题而做的修改是一种已知的改进策略（与 Illinois 算法相关）。该问题是科学合理的。\n- **适定的**：该问题是适定的。它提供了具体的函数、满足所需括号条件的初始区间、明确的算法步骤和无歧义的终止标准。对于恰当选择的函数和区间，该算法保证收敛到一个根。\n- **客观的**：该问题以精确、客观的数学语言陈述，不含任何主观或非形式化内容。\n\n满足有效问题的所有标准。没有违反科学原理，没有矛盾，也没有会妨碍严格实现的歧义。\n\n**步骤3：结论与行动**\n\n问题被判定为 **有效**。将构建一个解决方案。\n\n**基于原理的解决方案**\n\n目标是寻找连续函数 $f(x)$ 在区间 $[a, b]$ 内的一个实根 $x^\\star$，其中 $f(a)$ 和 $f(b)$ 异号或其中一个为零，即 $f(a)f(b) \\le 0$。根据介值定理，该区间内保证至少存在一个根。指定的方法是一种区间算法，意味着它系统地缩小区间 $[a, b]$，同时确保根始终位于其中。\n\n该算法的核心是一个迭代过程。在每一步 $k$，我们有一个包含根的区间 $[a_k, b_k]$。我们必须选择一个新的点 $c_k \\in (a_k, b_k)$ 进行测试。\n\n选择 $c_k$ 的主要方法是试位法。这涉及构造一条穿过点 $(a_k, f(a_k))$ 和 $(b_k, f(b_k))$ 的直线（割线）。下一个近似值 $c_k$ 是这条直线与 $x$ 轴相交的点。该点的公式由直线方程的两点式导出，如下所示：\n$$\nc_{\\text{rf}} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}\n$$\n这种方法通常比二分法收敛得更快。然而，它有一个显著的缺点：如果函数弯曲程度很大，区间的一个端点可能会“卡住”（在多次迭代中保持不变），导致收敛非常缓慢。区间宽度 $|b_k - a_k|$ 可能不会趋近于零。\n\n为了解决这种停滞问题，题目指定了一种混合策略。默认使用试位法，但如果检测到停滞，则使用不同的试探点。停滞被定义为“完全相同的端点连续至少2次迭代保持不变”的情况。在这种情况下，或者如果 $f(a_k) = f(b_k)$（这会使 $c_{\\text{rf}}$ 的分母为零），算法必须切换到二分法执行一步。二分法的试探点就是区间的中点：\n$$\nc_{\\text{bis}} = \\frac{a_k + b_k}{2}\n$$\n二分步骤迫使搜索移离停滞的端点，通常会打破缓慢收敛的模式。执行一次二分步骤后，停滞计数器被重置，算法恢复使用试位法。\n\n在计算出试探点 $c_k$（无论是 $c_{\\text{rf}}$ 还是 $c_{\\text{bis}}$）及其函数值 $f(c_k)$ 后，确定下一次迭代的区间 $[a_{k+1}, b_{k+1}]$。为了保持括号性质，我们检查 $f(c_k)$ 的符号：\n- 如果 $f(a_k) f(c_k)  0$，根在 $[a_k, c_k]$ 内，所以我们设置 $a_{k+1} = a_k$ 和 $b_{k+1} = c_k$。在这种情况下，端点 $a_k$ 保持不变。\n- 如果 $f(b_k) f(c_k)  0$（由于 $f(a_k) f(b_k)  0$，这等价于 $f(a_k) f(c_k) > 0$），根在 $[c_k, b_k]$ 内，所以我们设置 $a_{k+1} = c_k$ 和 $b_{k+1} = b_k$。在这种情况下，端点 $b_k$ 保持不变。\n- 如果 $f(c_k) = 0$，则根已被精确找到。\n\n重复此过程，直到满足指定的终止标准之一：\n1. 试探点处的函数值足够接近于零：$|f(c_k)| \\le \\varepsilon_f$。\n2. 括号区间的宽度足够小：$|b_k - a_k| \\le \\varepsilon_x$。\n3. 达到迭代次数上限 $N_{\\max}$。\n\n问题还规定，在每次迭代开始时，应检查端点处的函数值 $f(a_k)$ 和 $f(b_k)$ 是否满足 $\\varepsilon_f$ 的要求。如果其中任何一个足够小，则该端点被视为根。\n\n实现将维护一个计数器，用于记录同一端点被保留的连续迭代次数。如果此计数器达到2，则在当前迭代中强制执行一次二分步骤，并重置计数器。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases and print the results.\n    \"\"\"\n\n    def find_root(f, a, b, eps_f, eps_x, n_max):\n        \"\"\"\n        Computes a root of f in [a, b] using a hybrid of Regula Falsi and Bisection.\n\n        Args:\n            f (callable): The function for which to find a root.\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            eps_f (float): Absolute function value tolerance.\n            eps_x (float): Absolute interval width tolerance.\n            n_max (int): Maximum number of iterations.\n\n        Returns:\n            float: The approximated root.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        # Initial checks on endpoints as per problem statement\n        if abs(fa) = eps_f:\n            return a\n        if abs(fb) = eps_f:\n            return b\n\n        # The problem statement guarantees the bracketing condition f(a)*f(b) = 0\n        \n        stagnant_counter = 0\n        # This flag tracks which endpoint ('a' or 'b') was unchanged in the last update.\n        # True if 'a' was unchanged, False if 'b' was unchanged, None otherwise.\n        last_unchanged_endpoint_is_a = None\n        \n        c = a # Initialize c to a valid float\n\n        for _ in range(n_max):\n            \n            # Determine if a bisection step is required\n            use_bisection = (stagnant_counter >= 2) or (fa == fb)\n            \n            # Calculate trial point c\n            if use_bisection:\n                c = (a + b) / 2.0\n            else:\n                c = (a * fb - b * fa) / (fb - fa)\n\n            fc = f(c)\n\n            # Termination check on interval width must use the *current* interval [a,b]\n            # before it's updated. The problem is slightly ambiguous, but this is a\n            # common interpretation. Another is to check after update. Let's check after update\n            # as it is more robust and aligns with problem 2's explicit structure.\n            \n            if abs(fc) = eps_f:\n                return c\n\n            # Update the interval and stagnation state\n            is_bisect_step = use_bisection\n            \n            # Store old interval to check for stagnation\n            old_a, old_b = a, b\n\n            if fa * fc  0:  # Root is in [a, c], so b is updated\n                b = c\n                fb = fc\n            elif fb * fc  0:  # Root is in [c, b], so a is updated\n                a = c\n                fa = fc\n            else:  # This case implies fc is 0.0, which is handled by the termination condition above\n                return c\n\n            # Check for stagnation\n            if a == old_a: # b was updated, so a is the stagnant one\n                if last_unchanged_endpoint_is_a is True:\n                    stagnant_counter += 1\n                else:\n                    last_unchanged_endpoint_is_a = True\n                    stagnant_counter = 1\n            elif b == old_b: # a was updated, so b is the stagnant one\n                if last_unchanged_endpoint_is_a is False:\n                    stagnant_counter += 1\n                else:\n                    last_unchanged_endpoint_is_a = False\n                    stagnant_counter = 1\n\n            # After a bisection step, reset the stagnation counter\n            if is_bisect_step:\n                stagnant_counter = 0\n                last_unchanged_endpoint_is_a = None\n            \n            # Final termination check on width of the *new* interval\n            if abs(b - a) = eps_x:\n                return c\n\n        # Return the last computed c if max iterations is reached\n        return c\n\n    # Define common parameters for all test cases\n    eps_f = 1e-12\n    eps_x = 1e-12\n    n_max = 100\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (lambda x: x**3 - x - 2, 1.0, 2.0),\n        (lambda x: np.exp(-x) - x, 0.0, 1.0),\n        (lambda x: x**3 + 1e-6 * x - 1, 0.0, 1.0),\n        (lambda x: x, 0.0, 3.0),\n    ]\n\n    results = []\n    for f_func, a, b in test_cases:\n        root = find_root(f_func, a, b, eps_f, eps_x, n_max)\n        # Format the result to 10 decimal places as a string\n        results.append(f\"{root:.10f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}