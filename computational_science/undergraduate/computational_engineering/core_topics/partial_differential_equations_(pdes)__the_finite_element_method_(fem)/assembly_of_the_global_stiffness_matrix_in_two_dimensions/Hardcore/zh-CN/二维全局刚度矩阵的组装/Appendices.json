{
    "hands_on_practices": [
        {
            "introduction": "掌握全局刚度矩阵组装的第一步是精通其核心机制：直接刚度叠加法。这个练习模拟了一个在有限元编程中非常常见的场景——代码调试。通过要求你手动计算并验证全局矩阵中的一个特定元素，本练习旨在巩固你对局部自由度如何映射到全局自由度，以及单元矩阵如何对全局系统做出贡献的理解。",
            "id": "2371849",
            "problem": "考虑一个单位正方形上的标量扩散问题，该问题使用线性三角形单元通过有限元法（FEM）进行离散化。网格在坐标 $(0,0)$、$(1,0)$、$(1,1)$ 和 $(0,1)$ 处有节点，分别标记为全局节点 $1$、$2$、$3$ 和 $4$。单元由连接关系 $e_{1}=(1,2,3)$ 和 $e_{2}=(1,3,4)$ 定义。局部刚度矩阵（对于单位无量纲传导率和线性形函数）已知为\n$$\nK^{(1)}=\\begin{pmatrix}\n0.5  -0.5  0 \\\\\n-0.5  1  -0.5 \\\\\n0  -0.5  0.5\n\\end{pmatrix},\n\\quad\nK^{(2)}=\\begin{pmatrix}\n0.5  0  -0.5 \\\\\n0  0.5  -0.5 \\\\\n-0.5  -0.5  1\n\\end{pmatrix},\n$$\n其中 $K^{(1)}$ 根据对应于全局节点 $(1,2,3)$ 的局部节点排序，而 $K^{(2)}$ 根据对应于全局节点 $(1,3,4)$ 的局部节点排序。一个实现产生了以下组装后的全局刚度矩阵 $\\tilde{K}$：\n$$\n\\tilde{K}=\\begin{pmatrix}\n1.0  -0.5  -0.5  0 \\\\\n-0.5  1.0  -0.5  0 \\\\\n-0.5  -0.5  1.5  -0.5 \\\\\n0  0  -0.5  0.5\n\\end{pmatrix}.\n$$\n假设 $K^{(1)}$ 和 $K^{(2)}$ 是正确的，唯一的问题是组装过程中的一个错误，请确定使用给定的单元连接关系和局部刚度矩阵进行正确组装后，应得到的全局刚度矩阵元素 $K_{1,4}$ 的正确值。以无单位的精确数字形式提供答案。",
            "solution": "所述问题在科学上是合理的、适定的，并包含了获得唯一解所需的所有信息。提供的局部刚度矩阵 $K^{(1)}$ 和 $K^{(2)}$ 已被验证对于在指定几何形状上具有单位无量纲传导率的线性三角形单元是正确的。任务是确定全局刚度矩阵 $K$ 中元素 $K_{1,4}$ 的正确值。\n\n在有限元法中，全局刚度矩阵的组装基于直接刚度求和原理。全局矩阵 $K$ 初始化为一个大小为 $N \\times N$ 的零矩阵，其中 $N$ 是全局节点的总数。在此问题中，$N=4$。然后，将每个单元的局部刚度矩阵的贡献加到全局矩阵中。全局矩阵的一个元素 $K_{I,J}$ 是所有单元矩阵 $K^{(e)}$ 贡献的总和：\n$$\nK_{I,J} = \\sum_{e} K^{(e)}_{I,J}\n$$\n其中 $K^{(e)}_{I,J}$ 是单元 $e$ 对全局矩阵第 $I$ 行和第 $J$ 列元素的贡献。一个贡献 $K^{(e)}_{I,J}$ 仅当全局节点 $I$ 和 $J$ 都属于单元 $e$ 时才非零。\n\n我们需要找到特定元素 $K_{1,4}$ 的值。我们必须检查每个单元的连接关系，以确定哪些单元对该元素有贡献。\n单元由以下连接关系定义：\n1. 单元 $e_1$：连接全局节点 $(1, 2, 3)$。\n2. 单元 $e_2$：连接全局节点 $(1, 3, 4)$。\n\n一个单元仅当它同时包含全局节点 $1$ 和全局节点 $4$ 时，才对 $K_{1,4}$ 有贡献。\n- 单元 $e_1$ 包含节点 $1$ 但不包含节点 $4$。因此，它对 $K_{1,4}$ 元素的贡献为零。\n- 单元 $e_2$ 同时包含节点 $1$ 和节点 $4$。因此，它是唯一对 $K_{1,4}$ 元素有贡献的单元。\n\n因此，$K_{1,4}$ 的值完全由单元 $e_2$ 的贡献决定。我们必须确定局部刚度矩阵 $K^{(2)}$ 中的哪个元素对应于全局元素 $K_{1,4}$。\n\n问题陈述，对于单元 $e_2$，局部节点根据全局节点 $(1, 3, 4)$ 排序。这定义了从局部节点索引（我们称之为 $i, j, k$）到全局节点索引（$I, J, K$）的映射：\n- 局部节点 $1$ $\\rightarrow$ 全局节点 $1$\n- 局部节点 $2$ $\\rightarrow$ 全局节点 $3$\n- 局部节点 $3$ $\\rightarrow$ 全局节点 $4$\n\n单元 $e_2$ 的局部刚度矩阵给出如下：\n$$\nK^{(2)} = \\begin{pmatrix} k^{(2)}_{11}  k^{(2)}_{12}  k^{(2)}_{13} \\\\ k^{(2)}_{21}  k^{(2)}_{22}  k^{(2)}_{23} \\\\ k^{(2)}_{31}  k^{(2)}_{32}  k^{(2)}_{33} \\end{pmatrix} = \\begin{pmatrix} 0.5  0  -0.5 \\\\ 0  0.5  -0.5 \\\\ -0.5  -0.5  1 \\end{pmatrix}\n$$\n来自单元 $e_2$ 对全局元素 $K_{I,J}$ 的贡献是局部元素 $k^{(2)}_{ij}$，其中局部节点 $i$ 映射到全局节点 $I$，局部节点 $j$ 映射到全局节点 $J$。\n\n我们寻求对 $K_{1,4}$ 的贡献。\n- 全局行索引为 $I=1$，对应于局部节点 $i=1$。\n- 全局列索引为 $J=4$，对应于局部节点 $j=3$。\n因此，对 $K_{1,4}$ 的贡献是局部矩阵元素 $k^{(2)}_{1,3}$。\n\n从给定的矩阵 $K^{(2)}$ 中，第一行第三列的元素是：\n$$\nk^{(2)}_{1,3} = -0.5\n$$\n由于单元 $e_2$ 是唯一对 $K_{1,4}$ 有贡献的单元，因此在组装后的全局刚度矩阵中，该元素的正确值为：\n$$\nK_{1,4} = k^{(2)}_{1,3} = -0.5\n$$\n提供的错误矩阵 $\\tilde{K}$ 与正确值的计算无关。正确的组装过程明确地导致这个结果。",
            "answer": "$$\n\\boxed{-0.5}\n$$"
        },
        {
            "introduction": "仅仅正确地执行组装步骤并不能保证得到一个理想的全局刚度矩阵。此练习将引导我们从“如何组装”深入到“为何如此”的层面，探讨在计算单元刚度矩阵时一个至关重要的步骤——数值积分——所带来的影响。通过分析“减缩积分”的优缺点，你将理解它如何影响全局系统的稳定性和准确性，并接触到“沙漏现象”（hourglassing）这一关键的计算力学概念。",
            "id": "2371822",
            "problem": "考虑一个有界域 $\\Omega \\subset \\mathbb{R}^{2}$ 上的平面线性弹性问题，该问题具有小应变和均匀、对称正定的本构矩阵 $D \\in \\mathbb{R}^{3 \\times 3}$。该域使用由四节点双线性四边形单元组成的协调网格进行离散化。对于每个域为 $\\Omega^{e}$ 的单元 $e$，其单元刚度矩阵定义为\n$$\nk^{e} \\;=\\; \\int_{\\Omega^{e}} B(\\mathbf{x})^{\\mathsf{T}}\\, D \\, B(\\mathbf{x}) \\,\\mathrm{d}\\Omega,\n$$\n其中 $B(\\mathbf{x})$ 是从单元形函数导出的应变-位移矩阵。全局刚度矩阵 $K$ 是通过在标准有限元流程中组装所有单元的 $k^{e}$ 形成的。\n\n在计算 $k^{e}$ 中的积分时，考虑两种数值积分方案：\n- 完全高斯积分，使用从父单元映射的 $2\\times 2$ 个高斯点。\n- 减缩高斯积分，使用位于父单元中心的 $1\\times 1$ 个高斯点。\n\n选择所有关于对 $k^{e}$ 使用减缩积分对组装后的全局矩阵 $K$ 的影响以及术语“沙漏”在此背景下的含义的正确陈述。\n\nA. 对每个 $k^{e}$ 使用减缩积分可以减轻与锁定现象相关的伪刚度，使得 $K$ 在能量意义上刚度更小，但它可能会引入伪零能模式；因此，除非引入额外的稳定化或约束，否则 $K$ 可能会发生秩亏。\n\nB. 沙漏现象指的是在所选积分点上应变为零的变形模式；在减缩积分下，这些模式贡献的单元能量为零，并会组装成满足离散平衡方程的全局零能模式，可能导致解的非唯一性。\n\nC. 减缩积分会增加 $K$ 的带宽并改变其稀疏模式，因为更少的积分点会在 $K$ 中产生更少的非零项。\n\nD. 对于线性弹性问题中的双线性四边形单元，完全 $2\\times 2$ 高斯积分可消除沙漏现象；组装后的 $K$ 是对称的，并且在施加本质边界条件以消除刚体模态后是正定的。\n\nE. 如果 $D$ 是对称正定的，减缩积分会保持每个 $k^{e}$ 和 $K$ 的对称性，但由于零能模式的存在，它可能使 $K$ 仅为半正定。\n\nF. 沙漏现象指的是由 $D$ 的病态性引起的应力场伪振荡，与数值积分的选择无关。",
            "solution": "这是一个计算力学的练习。问题陈述是有效的。它在科学上是合理的、适定的、客观的，并为评估这些陈述提供了所有必要的信息。它涉及有限元方法（FEM）中标准、成熟的概念。\n\n我们正在分析一个使用4节点双线性四边形单元离散化的平面线性弹性问题。一个单元 $e$ 的单元刚度矩阵由下式给出\n$$\nk^{e} \\;=\\; \\int_{\\Omega^{e}} B(\\mathbf{x})^{\\mathsf{T}}\\, D \\, B(\\mathbf{x}) \\,\\mathrm{d}\\Omega\n$$\n其中 $B$ 是 $3 \\times 8$ 的应变-位移矩阵，$D$ 是 $3 \\times 3$ 的对称正定本构矩阵。全局刚度矩阵 $K$ 由单元矩阵 $k^{e}$ 组装而成。我们必须评估使用减缩的 $1\\times 1$ 高斯积分方案与完全的 $2\\times 2$ 方案所带来的后果。\n\n一个双线性四边形单元具有形函数 $N_i(\\xi, \\eta)$，对于 $i \\in \\{1, 2, 3, 4\\}$，这些函数在父单元上是关于 $\\xi$ 和 $\\eta$ 的线性函数。应变-位移矩阵 $B$ 的分量由这些形函数的空间导数构成。由于等参映射， $B(\\mathbf{x})$ 的项是坐标的有理函数。被积函数 $B(\\mathbf{x})^{\\mathsf{T}} D B(\\mathbf{x})$ 通常是一个复杂的函数。对于矩形单元，需要一个 $2 \\times 2$ 的高斯积分法则来精确积分刚度矩阵，而对于一般的扭曲四边形，这被认为是“完全”积分，因为它足以捕捉主导的多项式项并确保 $k^e$ 的正确秩。一个 $1 \\times 1$ 的法则（仅在单元中心计算被积函数）是“减缩”积分。它会对单元刚度能进行积分不足。\n\n现在，我们来分析每个陈述。\n\n**陈述 A: 对每个 $k^{e}$ 使用减缩积分可以减轻与锁定现象相关的伪刚度，使得 $K$ 在能量意义上刚度更小，但它可能会引入伪零能模式；因此，除非引入额外的稳定化或约束，否则 $K$ 可能会发生秩亏。**\n这个陈述是完全正确的。\n1.  **减轻锁定**：众所周知，双线性单元在弯曲主导的情况下会表现出“锁定”（例如，剪切锁定）。它们无法在不产生寄生剪切应变的情况下表示纯弯曲，这使得单元产生伪刚性。减缩积分在单元中心点计算剪切应变分量，而在这个点上这些分量最为准确（或对于某些弯曲模式为零），从而减轻了这种伪刚度。\n2.  **刚度更小的系统**：通过对刚度矩阵进行积分不足，我们实际上低估了单元的应变能。对于任何位移向量 $d^e$，其能量为 $(d^e)^{\\mathsf{T}} k^e_{reduced} d^e \\le (d^e)^{\\mathsf{T}} k^e_{full} d^e$。这一性质延伸到组装后的全局矩阵 $K$，使其在能量意义上刚度更小。\n3.  **伪零能模式**：积分不足的代价是，某些非刚体运动的变形模式可能在单个积分点上产生零应变。单元对这些被称为“沙漏模式”或伪零能模式的模式不提供任何抗力。\n4.  **秩亏**：这些零能模式对应于 $k^e$（以及随后的 $K$）的零空间中的额外向量。这意味着 $K$ 的秩低于应有的值。即使在施加边界条件以消除刚体运动后，这些伪模式仍然可能存在，导致系统奇异。需要沙漏控制或稳定化技术来增加人工刚度以控制这些模式。\n因此，该陈述是 **正确的**。\n\n**陈述 B: 沙漏现象指的是在所选积分点上应变为零的变形模式；在减缩积分下，这些模式贡献的单元能量为零，并会组装成满足离散平衡方程的全局零能模式，可能导致解的非唯一性。**\n该陈述给出了一个精确的定义，并正确地指出了沙漏现象的后果。\n1.  **定义**：沙漏模式是一种节点位移模式 $d^e_{hg}$，其对应的应变场 $\\epsilon(\\mathbf{x}) = B(\\mathbf{x}) d^e_{hg}$ 通常不为零，但在减缩积分点的特定位置处变为零。对于Q4单元上的 $1 \\times 1$ 方案，$\\epsilon(\\mathbf{x}_{center}) = 0$。\n2.  **零单元能量**：由于被积函数 $B^{\\mathsf{T}} D B$ 仅在应变为零的地方进行评估，因此该模式的数值计算出的单元应变能为零：$U^e = \\frac{1}{2} (d^e_{hg})^{\\mathsf{T}} k^e_{reduced} d^e_{hg} = 0$。\n3.  **全局效应和非唯一性**：这些局部单元级别的模式可以组合成一个全局变形模式 $d_{global}$，使得 $K d_{global} = 0$。如果在施加边界条件后仍然存在这样的模式，那么系统 $K u = f$ 的解就不是唯一的，因为任何解 $u$ 都可以通过加上 $d_{global}$ 的任意倍数而被污染。\n因此，该陈述是 **正确的**。\n\n**陈述 C: 减缩积分会增加 $K$ 的带宽并改变其稀疏模式，因为更少的积分点会在 $K$ 中产生更少的非零项。**\n这个陈述是根本错误的。全局刚度矩阵 $K$ 的稀疏模式和带宽完全由网格拓扑决定——即哪些节点由同一个单元连接。一个项 $K_{ij}$ 是非零的，当且仅当节点 $i$ 和 $j$ 属于同一个单元。数值积分法则影响 $k^e$ 中非零项的*值*，从而影响 $K$ 中非零项的*值*，但不会影响它们的*位置*。断言“更少的积分点会产生更少的非零项”是错误的；通常情况下，无论使用何种积分法则，$k^e$ 的所有项都是非零的。\n因此，该陈述是 **不正确的**。\n\n**陈述 D: 对于线性弹性问题中的双线性四边形单元，完全 $2\\times 2$ 高斯积分可消除沙漏现象；组装后的 $K$ 是对称的，并且在施加本质边界条件以消除刚体模态后是正定的。**\n这个陈述准确地描述了使用完全积分的系统属性。\n1.  **消除沙漏现象**：沙漏现象是*减缩*积分的产物。完全 $2 \\times 2$ 积分足以确保单元刚度矩阵 $k^e$ 的零能模式仅为三个刚体模态（在二维中为两个平移和一个旋转）。\n2.  **对称性**：由于 $D$ 是对称的，被积函数 $B^{\\mathsf{T}} D B$ 也是对称的。积分和组装过程保持了这种对称性，所以 $K$ 是对称的。\n3.  **正定性**：使用完全积分时，单元矩阵 $k^e$ 是半正定的，其零空间正确地只对应于刚体运动。一旦对全局系统施加本质边界条件以阻止这些刚体运动，约束后的全局刚度矩阵就变为正定。这保证了唯一、稳定解的存在。\n因此，该陈述是 **正确的**。\n\n**陈述 E: 如果 $D$ 是对称正定的，减缩积分会保持每个 $k^{e}$ 和 $K$ 的对称性，但由于零能模式的存在，它可能使 $K$ 仅为半正定。**\n这个陈述是正确的。\n1.  **对称性保持**：$k^e$ 的对称性源于被积函数 $B^{\\mathsf{T}} D B$ 的对称性，只要 $D$ 是对称的，这一点就能得到保证。积分法则（一个加权和）的选择不影响这种对称性。对称单元矩阵的组装会得到一个对称的全局矩阵 $K$。\n2.  **半正定性**：减缩积分引入的伪零能（沙漏）模式意味着存在非零的节点位移向量 $d^e$（非刚体模态），使得 $(d^e)^{\\mathsf{T}} k^e d^e = 0$。这使得 $k^e$ 成为半正定矩阵，其零空间的维数大于刚体模态的数量。在组装时，这些额外的零能模式可能会在 $K$ 中持续存在，即使在施加边界条件后也使其成为半正定。这意味着矩阵是奇异的，并且在没有稳定化的情况下问题缺乏唯一解。\n因此，该陈述是 **正确的**。\n\n**陈述 F: 沙漏现象指的是由 $D$ 的病态性引起的应力场伪振荡，与数值积分的选择无关。**\n这个陈述是不正确的。它混淆了沙漏现象的原因和性质。\n1.  **原因**：沙漏现象根本上是由使用减缩数值积分引起的，这种积分方法无法检测某些变形模式的应变能。它不是由本构矩阵 $D$ 的病态性引起的。$D$ 的病态性，例如在近不可压缩材料中（泊松比 $\\nu \\to 0.5$），会导致一种被称为体积锁定的不同数值病态问题。\n2.  **与积分的关系**：这一现象与数值积分的选择密不可分。它不会在完全积分时发生。“与数值积分的选择无关”的说法是错误的。虽然沙漏模式确实会导致位移场和应力场出现伪振荡，但其根本原因被错误地指认了。\n因此，该陈述是 **不正确的**。\n\n总而言之，陈述 A、B、D 和 E 是对线性弹性中双线性四边形单元在不同积分方案下行为的正确描述。",
            "answer": "$$\\boxed{ABDE}$$"
        },
        {
            "introduction": "本章的最终挑战是将理论知识转化为实际的编程能力。这个综合性练习要求你从第一性原理出发，构建一个完整的二维线弹性有限元求解器，用于分析复合材料结构。你需要将矩阵组装过程与材料本构、边界条件施加和最终系统求解融为一体，这是对你所学知识的终极检验。",
            "id": "2371824",
            "problem": "您需要编写一个完整的程序，该程序从虚功原理和小应变线性各向同性本构律出发，使用有限元法（FEM）为二维线性弹性复合材料组装全局刚度矩阵。使用平面应力运动学。目标是为一个简单网格计算位移响应，其中相邻单元具有不同的杨氏模量，这些模量可能相差几个数量级。所有距离必须以米表示，力以牛顿表示，应力以帕斯卡表示。不需要角度。所有输出必须以米表示。\n\n您必须使用的基本原理包括：(i) 线性弹性的虚功原理，(ii) 二维小应变张量定义，以及 (iii) 线性、各向同性平面应力本构关系。根据这些原理，您必须推导出单元刚度并组装全局刚度矩阵，然后应用边界条件和荷载来求解位移。\n\n域和网格：\n- 考虑一个尺寸为 $L_x = 2$ 米和 $L_y = 1$ 米的矩形域，厚度恒为 $t = 1$ 米（平面应力沿厚度方向的假设，但保留厚度用于荷载等效）。\n- 使用以下节点集及其坐标 $(x_i,y_i)$（单位为米）：\n  - 节点索引 $0$：$(0,0)$，\n  - 节点索引 $1$：$(1,0)$，\n  - 节点索引 $2$：$(2,0)$，\n  - 节点索引 $3$：$(0,1)$，\n  - 节点索引 $4$：$(1,1)$，\n  - 节点索引 $5$：$(2,1)$。\n- 使用四个线性三角形单元，其节点连接关系如下（每个三元组列出了三角形节点的索引）：\n  - 单元 $0$：$(0,1,4)$，\n  - 单元 $1$：$(0,4,3)$，\n  - 单元 $2$：$(1,2,5)$，\n  - 单元 $3$：$(1,5,4)$。\n\n复合材料指定：\n- 每个形心 $x$ 坐标严格小于 $1$ 米的三角形使用材料 $E_1$；否则使用材料 $E_2$。\n- 所有单元的泊松比均一，等于 $\\nu = 0.3$。\n\n荷载和边界条件：\n- 在 $x = L_x$ 的边界上，即节点索引 $2$ 和 $5$ 之间的边上，施加均匀面力 $\\mathbf{t} = (t_x,t_y)$，其中 $t_x = 10^6$ 帕斯卡， $t_y = 0$。将此视为物理面力（单位面积上的力），并使用标准的一致荷载法，通过沿边积分并乘以厚度 $t$ 将其转换为等效节点线荷载。\n- 对所有 $x = 0$ 米的节点（节点索引 $0$ 和 $3$）的位移分量施加齐次狄利克雷边界条件：在这些节点处设置 $u_x = 0$ 和 $u_y = 0$。\n\n控制方程和离散化框架：\n- 从二维线性弹性的虚功原理和小应变定义出发，得到定义刚度算子的双线性形式和用于诺伊曼边界条件的线性泛函。使用每个单元内应变恒定的线性三角形单元。对于每个单元，根据单元的杨氏模量和 $\\nu$，从本构律计算标准应变-位移矩阵 $B$ 和平面应力弹性矩阵 $D$。\n- 通过将单元贡献按单元连接关系映射相加，组装全局刚度矩阵 $K$。\n- 通过将在 $x = L_x$ 边界边上施加的面力产生的一致节点力相加，组装全局力向量 $f$。\n\n求解和要求输出：\n- 通过消除指定的自由度来施加狄利克雷边界条件，并求解得到的线性系统以获得未知的位移自由度。\n- 对于下面列出的每个测试用例，计算节点索引 $5$（右上角点，位于 $(2,1)$ 米处）的位移大小，即 $\\|\\mathbf{u}_5\\|_2 = \\sqrt{u_x^2 + u_y^2}$，单位为米。\n\n测试套件：\n- 用例 $1$（极端对比度）：$E_1 = 10^{12}$ 帕斯卡， $E_2 = 10^{6}$ 帕斯卡。\n- 用例 $2$（中等对比度）：$E_1 = 10^{9}$ 帕斯卡， $E_2 = 10^{6}$ 帕斯卡。\n- 用例 $3$（均匀参考）：$E_1 = 10^{9}$ 帕斯卡， $E_2 = 10^{9}$ 帕斯卡。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，按上述顺序以逗号分隔列表的形式用方括号括起来，单位为米。对每个浮点数使用具有 $6$ 位有效数字的科学记数法。例如，一个有效的输出格式是 $[1.234560\\text{e-}03,4.321000\\text{e+}00,5.000000\\text{e-}02]$。",
            "solution": "该问题是基于线性弹性和有限元法的既定理论，是计算工程学的核心课题。该问题是适定的，域、网格、材料属性、荷载和边界条件都已完全指定，狄利克雷边界条件足以防止刚体运动，从而确保唯一解的存在。\n\n推导和求解过程按要求从基本原理出发。\n\n线性弹性固体的平衡方程的弱形式由虚功原理给出。忽略体力，它表明对于任何运动学容许的虚位移场 $\\delta\\mathbf{u}$：\n$$\n\\int_V \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV = \\int_{S_t} \\mathbf{t} \\cdot \\delta\\mathbf{u} \\, dS\n$$\n该问题在平面应力条件下进行分析。在每个单元 $e$ 内，位移场使用节点位移 $\\mathbf{d}_e$ 和形函数矩阵 $\\mathbf{N}(x,y)$ 来近似：$\\mathbf{u}(x,y) \\approx \\mathbf{N}(x,y) \\mathbf{d}_e$。应变-位移关系为 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$，其中 $\\mathbf{B}$ 对于线性三角形单元是恒定的。对于平面应力下的线性、各向同性弹性材料，应力-应变关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$。\n\n将离散化的量代入虚功原理，最终得到全局线性方程组 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 由下式给出：\n$$\n\\mathbf{K}_e = t A_e \\mathbf{B}^T \\mathbf{D} \\mathbf{B}\n$$\n因为 $\\mathbf{B}$、$\\mathbf{D}$ 和厚度 $t$ 在线性三角形单元内是常数。\n\n由于边长为 $L$ 的边上的面力 $\\mathbf{t}$ 产生的单元一致力向量 $\\mathbf{f}_e$ 为：\n$$\n\\mathbf{f}_e = t \\int_L \\mathbf{N}^T \\mathbf{t} \\, dL\n$$\n对于连接两个节点的线性单元边，积分的结果是将边上的总力 $F = t \\cdot L \\cdot \\text{traction}$ 均等地分配给两个节点。在这个问题中，面力 $t_x = 10^6$ 帕斯卡施加在节点 $2$ 和 $5$ 之间的边上。该边的长度为 $L_{2-5} = 1$ 米。总力为 $F_x = t_x \\cdot L_{2-5} \\cdot t = 10^6$ 牛顿。因此，一致节点力为 $f_{2x} = 5 \\times 10^5$ 牛顿和 $f_{5x} = 5 \\times 10^5$ 牛顿。\n\n全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$ 是通过遍历所有单元，计算它们各自的 $\\mathbf{K}_e$，并根据节点连接关系将它们组装到全局系统中来构建的。单元的材料属性由其形心位置确定。\n- 单元 $0$ 和 $1$ 的形心 $x$ 坐标小于 $1$ 米，使用材料 $E_1$。\n- 单元 $2$ 和 $3$ 的形心 $x$ 坐标大于或等于 $1$ 米，使用材料 $E_2$。\n\n在节点 $0$ 和 $3$ 处指定的齐次狄利克雷边界条件（$u_x=u_y=0$）通过从全局刚度矩阵和力向量中划掉相应的行和列来施加。求解得到的简化系统可得到未知的节点位移。最后，为每个测试用例计算节点 $5$ 处的位移大小。\n\n以下是实现此过程的完整 Python 代码。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear elasticity problem using the Finite Element Method.\n    \"\"\"\n    \n    # Define problem parameters\n    nodes = np.array([\n        [0.0, 0.0], [1.0, 0.0], [2.0, 0.0],\n        [0.0, 1.0], [1.0, 1.0], [2.0, 1.0]\n    ])\n    \n    elements = np.array([\n        [0, 1, 4], [0, 4, 3],\n        [1, 2, 5], [1, 5, 4]\n    ])\n    \n    nu = 0.3  # Poisson's ratio\n    thickness = 1.0  # meters\n    traction_x = 1e6  # Pascals\n    \n    # Define test cases\n    test_cases = [\n        (1e12, 1e6), # Case 1\n        (1e9, 1e6),  # Case 2\n        (1e9, 1e9)   # Case 3\n    ]\n    \n    results = []\n\n    for E1, E2 in test_cases:\n        \n        n_nodes = nodes.shape[0]\n        n_dofs = 2 * n_nodes\n        \n        K = np.zeros((n_dofs, n_dofs))\n        f = np.zeros(n_dofs)\n        \n        # Assemble global stiffness matrix K\n        for elem_nodes in elements:\n            # Determine material properties for the element\n            coords = nodes[elem_nodes]\n            centroid_x = np.mean(coords[:, 0])\n            \n            E = E1 if centroid_x  1.0 else E2\n            \n            # Constitutive matrix D for plane stress\n            D_factor = E / (1.0 - nu**2)\n            D = D_factor * np.array([\n                [1.0, nu, 0.0],\n                [nu, 1.0, 0.0],\n                [0.0, 0.0, (1.0 - nu) / 2.0]\n            ])\n            \n            # Strain-displacement matrix B for linear triangle\n            (x1, y1), (x2, y2), (x3, y3) = coords[0], coords[1], coords[2]\n            \n            # Area of the element (assuming counter-clockwise node ordering)\n            area = 0.5 * ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1))\n\n            B = (1.0 / (2.0 * area)) * np.array([\n                [y2 - y3, 0,       y3 - y1, 0,       y1 - y2, 0      ],\n                [0,       x3 - x2, 0,       x1 - x3, 0,       x2 - x1],\n                [x3 - x2, y2 - y3, x1 - x3, y3 - y1, x2 - x1, y1 - y2]\n            ])\n            \n            # Element stiffness matrix\n            Ke = thickness * area * (B.T @ D @ B)\n            \n            # Assemble Ke into K\n            dof_indices = []\n            for node_idx in elem_nodes:\n                dof_indices.extend([2 * node_idx, 2 * node_idx + 1])\n            \n            K[np.ix_(dof_indices, dof_indices)] += Ke\n\n        # Assemble global force vector f\n        edge_len_2_5 = np.linalg.norm(nodes[5] - nodes[2])\n        total_force = traction_x * edge_len_2_5 * thickness\n        \n        f[2 * 2] += total_force / 2.0\n        f[2 * 5] += total_force / 2.0\n        \n        # Apply boundary conditions\n        prescribed_dofs = [0, 1, 6, 7] # DOFs for nodes 0 and 3\n        all_dofs = np.arange(n_dofs)\n        free_dofs = np.setdiff1d(all_dofs, prescribed_dofs)\n        \n        # Solve for unknown displacements\n        K_reduced = K[np.ix_(free_dofs, free_dofs)]\n        f_reduced = f[free_dofs]\n        \n        u_reduced = np.linalg.solve(K_reduced, f_reduced)\n        \n        # Reconstruct full displacement vector\n        u = np.zeros(n_dofs)\n        u[free_dofs] = u_reduced\n        \n        # Calculate displacement magnitude at node 5\n        u5x, u5y = u[10], u[11]\n        disp_magnitude = np.sqrt(u5x**2 + u5y**2)\n        \n        results.append(disp_magnitude)\n\n    # Format output according to specification\n    # The following line is for generating the final answer string\n    # formatted_results = [f\"{res:.6e}\" for res in results]\n    # print(f\"[{','.join(formatted_results)}]\")\n    \n    return results\n\n# To generate the answer, one would run the code, e.g., by uncommenting the print statement.\n# The following is a placeholder for the user to run the code.\nif __name__ == '__main__':\n    final_results = solve()\n    formatted_results = [f\"{res:.6e}\" for res in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n```",
            "answer": "$$\n\\boxed{[1.000219\\text{e+}00, 1.001000\\text{e+}00, 1.999402\\text{e-}03]}\n$$"
        }
    ]
}