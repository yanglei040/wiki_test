{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。这个练习将指导你从头开始实现托马斯算法，这是理解其工作原理的最佳方式。为了高效地处理三对角矩阵，我们将采用一种不存储大量零元素的紧凑存储方案，这在科学计算中是标准做法，能够显著节省内存资源。通过完成此练习，你将掌握该算法的核心逻辑和高效编程实现。",
            "id": "2446352",
            "problem": "您的任务是求解系数矩阵为三对角矩阵的线性系统。一个实三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的定义是，其非零元素仅存在于主对角线和两条相邻的对角线上。您必须采用并使用一种紧凑存储布局，该布局由三个一维数组组成：\n- 一个次对角线数组 $l \\in \\mathbb{R}^{n-1}$，\n- 一个主对角线数组 $d \\in \\mathbb{R}^{n}$，\n- 一个超对角线数组 $u \\in \\mathbb{R}^{n-1}$。\n\n该紧凑存储必须遵循以下索引约定来编码 $A$：\n- 对于 $i \\in \\{0,1,\\dots,n-2\\}$，$l[i]$ 存储矩阵元素 $A_{i+1,i}$，\n- 对于 $i \\in \\{0,1,\\dots,n-1\\}$，$d[i]$ 存储矩阵元素 $A_{i,i}$，\n- 对于 $i \\in \\{0,1,\\dots,n-2\\}$，$u[i]$ 存储矩阵元素 $A_{i,i+1}$。\n\n您的程序必须：\n- 为每个指定的测试用例构建紧凑存储 $(l,d,u)$，\n- 通过将三对角矩阵 $A$（由 $(l,d,u)$ 编码）与一个预设的精确解向量 $x^{\\star} \\in \\mathbb{R}^{n}$ 相乘，构建右端向量 $b \\in \\mathbb{R}^{n}$，\n- 对于每个测试用例，仅使用紧凑存储数组 $(l,d,u)$ 和向量 $b$ 计算并返回精确解 $x^{\\star}$ 的数值近似解 $\\hat{x}$，不得将 $A$ 物化为密集矩阵，也不得使用任何库中的外部三对角求解器，\n- 对于每个测试用例，计算最大绝对误差 $e = \\max_{0 \\le i \\le n-1} | \\hat{x}_i - x^{\\star}_i |$。\n\n测试套件：\n- 情况 1（正常情况，对称严格对角占优）：\n  - 维度：$n = 5$。\n  - 表示 $A$ 的紧凑存储为 $l[i] = -1$（对于 $i \\in \\{0,1,2,3\\}$），$d[i] = 2$（对于 $i \\in \\{0,1,2,3,4\\}$），以及 $u[i] = -1$（对于 $i \\in \\{0,1,2,3\\}$）。\n  - 精确解：$x^{\\star} = [1, 2, 3, 4, 5]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n- 情况 2（边界情况 $n=1$）：\n  - 维度：$n = 1$。\n  - 表示 $A$ 的紧凑存储为 $d[0] = 3$（没有次对角线或超对角线元素）。\n  - 精确解：$x^{\\star} = [7]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n- 情况 3（次对角线上有零，严格对角占优）：\n  - 维度：$n = 6$。\n  - 表示 $A$ 的紧凑存储为 $d[i] = 4$（对于 $i \\in \\{0,1,2,3,4,5\\}$），$u = [1, 0, 1, 0, 1]^{\\mathsf{T}}$，以及 $l = [0, 1, 0, 1, 0]^{\\mathsf{T}}$。\n  - 精确解：$x^{\\star} = [1, -1, 2, -2, 3, -3]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n- 情况 4（非对称，严格对角占优）：\n  - 维度：$n = 5$。\n  - 表示 $A$ 的紧凑存储为 $d = [5, 5, 5, 5, 5]^{\\mathsf{T}}$，$u = [2, -1, 0.5, -2.5]^{\\mathsf{T}}$，以及 $l = [-1, 0.5, -0.5, 1.5]^{\\mathsf{T}}$。\n  - 精确解：$x^{\\star} = [1, 2, -1, 0.5, -2]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n\n您的程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是相应测试用例的最大绝对误差 $e$。例如，输出格式必须严格遵循 $[e_1,e_2,e_3,e_4]$ 的形式，不含空格。所有值都是无单位的实数。本问题中不出现角度或百分比。",
            "solution": "提交分析的问题陈述被认为是有效的。这是一个数值线性代数领域中的适定问题，具体涉及求解由三对角矩阵定义的线性方程组。该问题具有科学依据，是客观的，并提供了推导唯一且有意义解所需的所有必要信息。所指定的算法，通常称为 Thomas 算法或三对角矩阵算法 (Tridiagonal Matrix Algorithm, TDMA)，是解决此类问题的标准且高效的直接法。\n\n任务是求解线性方程组 $A\\hat{x} = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，$\\hat{x} \\in \\mathbb{R}^{n}$ 是待求解向量，而 $b \\in \\mathbb{R}^{n}$ 是右端向量。矩阵 $A$ 以紧凑存储格式提供，使用三个一维数组：次对角线 $l \\in \\mathbb{R}^{n-1}$、主对角线 $d \\in \\mathbb{R}^{n}$ 和超对角线 $u \\in \\mathbb{R}^{n-1}$。使用指定的索引约定，该方程组可以明确写为：\n$$A_{i,j} = \\begin{cases} d_i  \\text{若 } j=i \\\\ u_i  \\text{若 } j=i+1 \\\\ l_{j}  \\text{若 } j=i-1, \\text{ 即对于 } A_{i,i-1}\\text{，该元素为 } l_{i-1} \\\\ 0  \\text{其他情况} \\end{cases}$$\n方程组为：\n$$d_0 \\hat{x}_0 + u_0 \\hat{x}_1 = b_0 \\quad (i=0)$$\n$$l_{i-1} \\hat{x}_{i-1} + d_i \\hat{x}_i + u_i \\hat{x}_{i+1} = b_i \\quad (\\text{对于 } i=1, 2, \\ldots, n-2)$$\n$$l_{n-2} \\hat{x}_{n-2} + d_{n-1} \\hat{x}_{n-1} = b_{n-1} \\quad (i=n-1)$$\n\nThomas 算法是高斯消元法的一种体现，它利用了矩阵 $A$ 的稀疏三对角结构。它包括两个阶段：向前消元过程和向后代入过程。\n\n**1. 向前消元**\n此阶段的目标是将系统转换为上双对角形式。我们逐行系统地消去次对角线元素。这是通过修改主对角线和超对角线系数以及右端向量来实现的。\n\n对于第一行（$i=0$），我们除以对角元素 $d_0$，假设 $d_0 \\neq 0$：\n$$\\hat{x}_0 + \\frac{u_0}{d_0} \\hat{x}_1 = \\frac{b_0}{d_0}$$\n我们为修改后的系统定义新系数：$u'_0 = \\frac{u_0}{d_0}$ 和 $b'_0 = \\frac{b_0}{d_0}$。方程变为 $\\hat{x}_0 + u'_0 \\hat{x}_1 = b'_0$。\n\n接下来，对于第二行（$i=1$），方程为 $l_0 \\hat{x}_0 + d_1 \\hat{x}_1 + u_1 \\hat{x}_2 = b_1$。我们从修改后的第一个方程中代入 $\\hat{x}_0$ 的表达式，即 $\\hat{x}_0 = b'_0 - u'_0 \\hat{x}_1$：\n$$l_0 (b'_0 - u'_0 \\hat{x}_1) + d_1 \\hat{x}_1 + u_1 \\hat{x}_2 = b_1$$\n对涉及 $\\hat{x}_1$ 和 $\\hat{x}_2$ 的项进行分组：\n$$(d_1 - l_0 u'_0) \\hat{x}_1 + u_1 \\hat{x}_2 = b_1 - l_0 b'_0$$\n除以 $\\hat{x}_1$ 的新系数，我们得到：\n$$\\hat{x}_1 + \\frac{u_1}{d_1 - l_0 u'_0} \\hat{x}_2 = \\frac{b_1 - l_0 b'_0}{d_1 - l_0 u'_0}$$\n这就给出了新系数 $u'_1$ 和 $b'_1$ 的递推关系。\n\n对于一个通用行 $i$（从 $i=1$ 到 $n-1$）进行推广，我们从方程 $l_{i-1} \\hat{x}_{i-1} + d_i \\hat{x}_i + u_i \\hat{x}_{i+1} = b_i$ 开始。从前一步（$i-1$）中，我们有关系式 $\\hat{x}_{i-1} = b'_{i-1} - u'_{i-1} \\hat{x}_i$。将其代入当前方程得到：\n$$l_{i-1} (b'_{i-1} - u'_{i-1} \\hat{x}_i) + d_i \\hat{x}_i + u_i \\hat{x}_{i+1} = b_i$$\n化简后得到：\n$$(d_i - l_{i-1} u'_{i-1}) \\hat{x}_i + u_i \\hat{x}_{i+1} = b_i - l_{i-1} b'_{i-1}$$\n令分母为 $m_i = d_i - l_{i-1} u'_{i-1}$。为了使算法在不进行主元选择的情况下保持稳定，我们需要对于所有 $i$ 都有 $m_i \\neq 0$。对于测试套件中提供的严格对角占优矩阵，此条件是保证成立的。\n\n修改后系数（我们用撇号表示）的递推关系是：\n- 对于 $i=0$：\n$$u'_0 = \\frac{u_0}{d_0}$$\n$$b'_0 = \\frac{b_0}{d_0}$$\n- 对于 $i=1, 2, \\ldots, n-2$：\n$$u'_i = \\frac{u_i}{d_i - l_{i-1} u'_{i-1}}$$\n$$b'_i = \\frac{b_i - l_{i-1} b'_{i-1}}{d_i - l_{i-1} u'_{i-1}}$$\n- 对于最后一行，$i=n-1$：\n$$b'_{n-1} = \\frac{b_{n-1} - l_{n-2} b'_{n-2}}{d_{n-1} - l_{n-2} u'_{n-2}}$$\n注意，由于没有 $u_{n-1}$ 项，因此不需要 $u'_{n-1}$。\n\n**2. 向后代入**\n经过向前消元过程后，原始系统 $A\\hat{x}=b$ 被转换为一个等价的上双对角系统：\n$$\\hat{x}_i + u'_i \\hat{x}_{i+1} = b'_i \\quad (\\text{对于 } i=0, 1, \\ldots, n-2)$$\n$$\\hat{x}_{n-1} = b'_{n-1}$$\n该系统通过从最后一个方程开始并向后代入来求解。\n解通过以下递推关系找到：\n$$\\hat{x}_{n-1} = b'_{n-1}$$\n$$\\hat{x}_i = b'_i - u'_i \\hat{x}_{i+1} \\quad (\\text{对于 } i = n-2, n-3, \\ldots, 0)$$\n\n每个测试用例的总体流程如下：\n首先，通过计算矩阵向量积 $b = A x^{\\star}$ 来构建右端向量 $b$，这里使用提供的紧凑存储数组 $(l,d,u)$ 和精确解向量 $x^{\\star}$，而不物化完整的矩阵 $A$。\n其次，对系统 $A\\hat{x}=b$ 应用所述的 Thomas 算法，以获得数值解 $\\hat{x}$。\n最后，计算最大绝对误差 $e = \\max_{0 \\le i \\le n-1} | \\hat{x}_i - x^{\\star}_i |$。由于计算是使用浮点算术执行的，此误差可作为衡量实现方案数值精度的指标。对于给定的具有稳定矩阵的测试用例，该误差预计将非常接近于零，处于机器精度（machine epsilon）的量级。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It constructs tridiagonal systems, solves them using a custom \n    Thomas algorithm implementation, and computes the maximum absolute error.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Happy path, symmetric strictly diagonally dominant\n        {\n            \"n\": 5,\n            \"l\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"d\": np.array([2.0, 2.0, 2.0, 2.0, 2.0]),\n            \"u\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"x_star\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n        },\n        # Case 2: Boundary case n=1\n        {\n            \"n\": 1,\n            \"l\": np.array([]),\n            \"d\": np.array([3.0]),\n            \"u\": np.array([]),\n            \"x_star\": np.array([7.0]),\n        },\n        # Case 3: Zeros on off-diagonals, strictly diagonally dominant\n        {\n            \"n\": 6,\n            \"l\": np.array([0.0, 1.0, 0.0, 1.0, 0.0]),\n            \"d\": np.array([4.0] * 6),\n            \"u\": np.array([1.0, 0.0, 1.0, 0.0, 1.0]),\n            \"x_star\": np.array([1.0, -1.0, 2.0, -2.0, 3.0, -3.0]),\n        },\n        # Case 4: Nonsymmetric, strictly diagonally dominant\n        {\n            \"n\": 5,\n            \"l\": np.array([-1.0, 0.5, -0.5, 1.5]),\n            \"d\": np.array([5.0] * 5),\n            \"u\": np.array([2.0, -1.0, 0.5, -2.5]),\n            \"x_star\": np.array([1.0, 2.0, -1.0, 0.5, -2.0]),\n        },\n    ]\n\n    def construct_b(n, l, d, u, x_star):\n        \"\"\"\n        Constructs the right-hand side vector b = A * x_star using packed storage.\n        \"\"\"\n        if n == 0:\n            return np.array([])\n        \n        b = np.zeros(n, dtype=float)\n        \n        if n == 1:\n            b[0] = d[0] * x_star[0]\n            return b\n\n        # First row\n        b[0] = d[0] * x_star[0] + u[0] * x_star[1]\n        \n        # Middle rows\n        for i in range(1, n - 1):\n            b[i] = l[i-1] * x_star[i-1] + d[i] * x_star[i] + u[i] * x_star[i+1]\n            \n        # Last row\n        b[n-1] = l[n-2] * x_star[n-2] + d[n-1] * x_star[n-1]\n        \n        return b\n\n    def thomas_solver(n, l, d, u, b):\n        \"\"\"\n        Solves a tridiagonal system Ax=b using the Thomas algorithm (TDMA).\n        \n        Args:\n            n (int): The dimension of the system.\n            l (np.ndarray): The subdiagonal (n-1 elements).\n            d (np.ndarray): The main diagonal (n elements).\n            u (np.ndarray): The superdiagonal (n-1 elements).\n            b (np.ndarray): The right-hand side vector (n elements).\n        \n        Returns:\n            np.ndarray: The solution vector x_hat.\n        \"\"\"\n        # Handle the trivial case n=1\n        if n == 1:\n            return np.array([b[0] / d[0]])\n            \n        # Allocate space for modified coefficients\n        u_prime = np.zeros(n - 1, dtype=float)\n        b_prime = np.zeros(n, dtype=float)\n        \n        # Forward elimination sweep\n        # i = 0\n        u_prime[0] = u[0] / d[0]\n        b_prime[0] = b[0] / d[0]\n        \n        # i = 1 to n-2\n        for i in range(1, n - 1):\n            denominator = d[i] - l[i-1] * u_prime[i-1]\n            u_prime[i] = u[i] / denominator\n            b_prime[i] = (b[i] - l[i-1] * b_prime[i-1]) / denominator\n        \n        # i = n-1 (last element of b_prime)\n        denominator_last = d[n-1] - l[n-2] * u_prime[n-2]\n        b_prime[n-1] = (b[n-1] - l[n-2] * b_prime[n-2]) / denominator_last\n\n        # Backward substitution sweep\n        x_hat = np.zeros(n, dtype=float)\n        x_hat[n-1] = b_prime[n-1]\n        for i in range(n - 2, -1, -1):\n            x_hat[i] = b_prime[i] - u_prime[i] * x_hat[i+1]\n            \n        return x_hat\n\n    results = []\n    for case in test_cases:\n        n, l, d, u, x_star = case[\"n\"], case[\"l\"], case[\"d\"], case[\"u\"], case[\"x_star\"]\n        \n        # Construct the right-hand side vector b = A * x_star\n        b = construct_b(n, l, d, u, x_star)\n        \n        # Solve the system A * x_hat = b to find the numerical solution\n        x_hat = thomas_solver(n, l, d, u, b)\n        \n        # Compute the maximum absolute error\n        error = np.max(np.abs(x_hat - x_star))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个稳健的数值算法不仅要快，还要能处理各种边界情况。本练习在基础实现之上，引入了对奇异或近奇异矩阵的判断，这是数值计算中的一个关键概念。通过检查计算过程中主元（pivots）的大小，你可以使你的托马斯算法实现更加可靠，从而避免因除以一个接近零的数而导致的计算失败或精度损失。",
            "id": "2446297",
            "problem": "给定一个形如 $A \\mathbf{x} = \\mathbf{d}$ 的实三对角线性方程组族，其中 $A \\in \\mathbb{R}^{n \\times n}$ 的主对角线元素为 $\\{b_i\\}_{i=1}^{n}$，次对角线元素为 $\\{a_i\\}_{i=2}^{n}$，超对角线元素为 $\\{c_i\\}_{i=1}^{n-1}$，即\n$$\nA =\n\\begin{pmatrix}\nb_1  c_1  0  \\cdots  0 \\\\\na_2  b_2  c_2  \\ddots  \\vdots \\\\\n0  a_3  b_3  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  c_{n-1} \\\\\n0  \\cdots  0  a_n  b_n\n\\end{pmatrix}, \\quad\n\\mathbf{x} =\n\\begin{pmatrix}\nx_1 \\\\ x_2 \\\\ \\vdots \\\\ x_{n-1} \\\\ x_n\n\\end{pmatrix}, \\quad\n\\mathbf{d} =\n\\begin{pmatrix}\nd_1 \\\\ d_2 \\\\ \\vdots \\\\ d_{n-1} \\\\ d_n\n\\end{pmatrix}.\n$$\n对于每个方程组，还会给出一个非负容差 $\\tau \\in \\mathbb{R}$，您必须应用以下规则：通过下式定义序列 $\\{p_i\\}$、$\\{c'_i\\}$ 和 $\\{d'_i\\}$：\n$$\np_1 = b_1,\n$$\n对于 $i = 1$ 设置\n$$\nc'_1 = \\begin{cases}\n\\frac{c_1}{p_1},  \\text{if } n \\ge 2, \\\\\n\\text{undefined},  \\text{if } n = 1,\n\\end{cases}\n\\quad\nd'_1 = \\frac{d_1}{p_1}.\n$$\n对于 $i = 2, 3, \\ldots, n$，设置\n$$\np_i = b_i - a_i \\, c'_{i-1}.\n$$\n在任何索引 $i \\in \\{1,2,\\ldots,n\\}$ 处，如果 $|p_i| \\le \\tau$，则认为计算因奇异或近奇异而失败，并且您必须为该方程组声明失败。如果对于所有 $i$ 都有 $|p_i|  \\tau$，则对于 $i = 2, 3, \\ldots, n-1$ 定义\n$$\nc'_i = \\frac{c_i}{p_i},\n$$\n并且对于 $i = 2, 3, \\ldots, n$ 定义\n$$\nd'_i = \\frac{d_i - a_i d'_{i-1}}{p_i}.\n$$\n如果没有声明失败，则唯一解 $\\mathbf{x}$ 由以下回代关系定义\n$$\nx_n = d'_n, \\quad\nx_i = d'_i - c'_i x_{i+1} \\quad \\text{for } i = n-1, n-2, \\ldots, 1.\n$$\n\n实现一个程序，对于下面的每个测试用例，该程序遵循上述规则，并在计算成功时输出解向量 $\\mathbf{x}$（作为实数列表），或者在因为存在索引 $i$ 使得 $|p_i| \\le \\tau$ 而声明失败时输出布尔值 $False$。\n\n测试套件。每个测试用例由元组 $(\\{a_i\\}_{i=2}^{n}, \\{b_i\\}_{i=1}^{n}, \\{c_i\\}_{i=1}^{n-1}, \\{d_i\\}_{i=1}^{n}, \\tau)$ 指定，为便于实现，以零基数组形式写成列表\n$$\na = [a_2, a_3, \\ldots, a_n], \\quad b = [b_1, b_2, \\ldots, b_n], \\quad c = [c_1, c_2, \\ldots, c_{n-1}], \\quad d = [d_1, d_2, \\ldots, d_n],\n$$\n其中 $\\tau$ 单独给出。\n\n请为以下六个测试用例提供结果：\n- 用例 $1$ (常规，严格对角占优): $a = [ -1, -1, -1, -1 ]$, $b = [ 2, 2, 2, 2, 2 ]$, $c = [ -1, -1, -1, -1 ]$, $d = [ 1, 1, 1, 1, 1 ]$, $\\tau = 10^{-12}$。\n- 用例 $2$ (边界情况 $n = 1$，因首个主元过小而失败): $a = [\\,]$ (空列表), $b = [ 10^{-12} ]$, $c = [\\,]$, $d = [ 1 ]$, $\\tau = 10^{-10}$。\n- 用例 $3$ (计算中途出现精确的零主元): $a = [ 1, 1 ]$, $b = [ 1, 1, 1 ]$, $c = [ 1, 1 ]$, $d = [ 1, 2, 3 ]$, $\\tau = 10^{-12}$。\n- 用例 $4$ (对角矩阵): $a = [ 0, 0, 0 ]$, $b = [ 3, 4, 5, 6 ]$, $c = [ 0, 0, 0 ]$, $d = [ 3, 8, 10, 12 ]$, $\\tau = 10^{-12}$。\n- 用例 $5$ (近奇异但在严格容差下可接受): $a = [ 1 ]$, $b = [ 1, 1 + 10^{-9} ]$, $c = [ 1 ]$, $d = [ 1, 1 ]$, $\\tau = 10^{-12}$。\n- 用例 $6$ (与用例 $5$ 相同，但在较宽松的容差下失败): $a = [ 1 ]$, $b = [ 1, 1 + 10^{-9} ]$, $c = [ 1 ]$, $d = [ 1, 1 ]$, $\\tau = 10^{-8}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，如果规则声明失败，则输出解向量（作为实数列表）或布尔值 $False$。打印的行中不得有任何空格。例如，一个汇总三个假设性用例结果的输出可能如下所示\n$$\n[\\,[0.5,1.0],False,[1.0]\\,].\n$$\n您的程序必须且只能输出这样一行，其中按顺序包含六个测试用例的结果，格式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，不得包含任何额外文本。",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n\nThe problem provides a procedure to solve a real tridiagonal linear system $A \\mathbf{x} = \\mathbf{d}$ of size $n \\times n$.\nThe matrix $A$ has:\n- Main diagonal entries: $\\{b_i\\}_{i=1}^{n}$\n- Subdiagonal entries: $\\{a_i\\}_{i=2}^{n}$\n- Superdiagonal entries: $\\{c_i\\}_{i=1}^{n-1}$\n\nThe algorithm is defined via sequences $\\{p_i\\}$, $\\{c'_i\\}$, and $\\{d'_i\\}$ and a nonnegative tolerance $\\tau$.\n\nForward Elimination:\n1.  Initialize with $i=1$:\n    $p_1 = b_1$.\n    A failure is declared if $|p_1| \\le \\tau$.\n    If successful, compute $c'_1 = c_1/p_1$ (for $n \\ge 2$) and $d'_1 = d_1/p_1$.\n\n2.  Iterate for $i = 2, 3, \\ldots, n$:\n    $p_i = b_i - a_i c'_{i-1}$.\n    A failure is declared if $|p_i| \\le \\tau$.\n    If successful, compute $c'_i = c_i/p_i$ (for $i  n$) and $d'_i = (d_i - a_i d'_{i-1})/p_i$.\n\nBack Substitution:\nIf no failure occurs, the solution $\\mathbf{x}$ is found by:\n$x_n = d'_n$.\n$x_i = d'_i - c'_i x_{i+1}$ for $i = n-1, n-2, \\ldots, 1$.\n\nOutput:\n- The boolean value `False` upon failure.\n- The solution vector $\\mathbf{x}$ upon success.\n\nTest Cases: Six specific instances of $(\\{a_i\\}, \\{b_i\\}, \\{c_i\\}, \\{d_i\\}, \\tau)$ are provided for implementation, using zero-based list formats for the vectors.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded:** The described algorithm is the Thomas algorithm, a well-established and computationally efficient method in numerical linear algebra for solving tridiagonal systems. It is a specialized form of Gaussian elimination. The use of a tolerance $\\tau$ to check the magnitude of pivots is a standard technique to ensure numerical stability. The problem is scientifically sound.\n-   **Well-Posed:** The algorithm is deterministic and provides a unique outcome (either a solution vector or a failure state) for any valid set of inputs. The conditions for its application and termination are clearly defined.\n-   **Objective:** The problem is stated using precise mathematical language and notation. All data and procedures are objective and formalizable.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, well-posed, complete, and verifiable.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be provided.\n\n**Principle-Based Solution**\n\nThe algorithm presented in the problem statement is a direct application of LU decomposition tailored for a tridiagonal matrix structure. This method, known as the Thomas algorithm, achieves high efficiency by avoiding operations on the zero elements of the matrix. The core principle is to factor the tridiagonal matrix $A$ into the product of a lower bidiagonal matrix $L$ and a unit upper bidiagonal matrix $U$, a form known as Crout's factorization, $A = LU$.\n\nLet the matrices $L$ and $U$ be defined as:\n$$\nL =\n\\begin{pmatrix}\np_1  0  0  \\cdots  0 \\\\\na_2  p_2  0  \\ddots  \\vdots \\\\\n0  a_3  p_3  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\cdots  0  a_n  p_n\n\\end{pmatrix}, \\quad\nU =\n\\begin{pmatrix}\n1  c'_1  0  \\cdots  0 \\\\\n0  1  c'_2  \\ddots  \\vdots \\\\\n0  0  1  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  c'_{n-1} \\\\\n0  \\cdots  0  0  1\n\\end{pmatrix}\n$$\nBy equating the entries of $A$ with the product $LU$, we derive the recurrence relations for the unknown elements $p_i$ and $c'_i$.\nThe main diagonal of $A$ gives $b_i = (LU)_{ii}$:\n-   For $i=1$: $b_1 = p_1$.\n-   For $i=2, \\ldots, n$: $b_i = a_i c'_{i-1} + p_i$, which rearranges to $p_i = b_i - a_i c'_{i-1}$.\n\nThe superdiagonal of $A$ gives $c_i = (LU)_{i,i+1}$:\n-   For $i=1, \\ldots, n-1$: $c_i = p_i c'_i$, which gives $c'_i = c_i / p_i$.\n\nThese relations are precisely the forward-elimination steps of the prescribed algorithm for computing $\\{p_i\\}$ and $\\{c'_i\\}$. The elements $\\{p_i\\}$ are the pivots of the Gaussian elimination process. The condition $|p_i| \\le \\tau$ for a small tolerance $\\tau \\ge 0$ is a critical check for numerical stability. If a pivot $p_i$ is zero, the matrix $A$ is singular, and the algorithm fails. If $|p_i|$ is very small, the matrix is ill-conditioned (near-singular), and dividing by $p_i$ would introduce large floating-point errors, destabilizing the solution. The tolerance $\\tau$ provides a practical threshold to declare failure in such cases.\n\nOnce the factorization $A=LU$ is found, the original system $A\\mathbf{x} = \\mathbf{d}$ becomes $LU\\mathbf{x} = \\mathbf{d}$. This is solved in two stages:\n1.  **Forward Substitution:** Let $\\mathbf{y} = U\\mathbf{x}$. Solve the lower triangular system $L\\mathbf{y} = \\mathbf{d}$. This yields:\n    -   $p_1 y_1 = d_1 \\implies y_1 = d_1/p_1$.\n    -   $a_i y_{i-1} + p_i y_i = d_i \\implies y_i = (d_i - a_i y_{i-1})/p_i$ for $i=2, \\ldots, n$.\n    By observing the structure of this recurrence, we see that the vector $\\mathbf{y}$ is identical to the sequence $\\mathbf{d}' = \\{d'_i\\}_{i=1}^n$ defined in the problem. The forward elimination phase thus computes the LU factorization and solves $L\\mathbf{y} = \\mathbf{d}$ simultaneously.\n\n2.  **Backward Substitution:** Solve the unit upper triangular system $U\\mathbf{x} = \\mathbf{y}$ (which is now $U\\mathbf{x} = \\mathbf{d}'$). This yields:\n    -   $x_n = y_n = d'_n$.\n    -   $x_i + c'_i x_{i+1} = y_i = d'_i \\implies x_i = d'_i - c'_i x_{i+1}$ for $i=n-1, \\ldots, 1$.\n    This is identical to the back-substitution phase defined in the problem statement.\n\nIn summary, the provided algorithm is a numerically robust implementation of the Thomas algorithm, grounded in the principles of LU factorization for tridiagonal systems. The logic is sound, and its implementation will yield the correct solution or a failure state as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve_tridiagonal(a_vec, b_vec, c_vec, d_vec, tau):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n\n    Args:\n        a_vec (list): The subdiagonal entries [a_2, ..., a_n].\n        b_vec (list): The main diagonal entries [b_1, ..., b_n].\n        c_vec (list): The superdiagonal entries [c_1, ..., c_{n-1}].\n        d_vec (list): The right-hand side vector [d_1, ..., d_n].\n        tau (float): The non-negative tolerance for pivot checking.\n\n    Returns:\n        list or bool: The solution vector x as a list of floats, or False if\n                      the computation fails due to a small pivot.\n    \"\"\"\n    n = len(b_vec)\n    if n == 0:\n        return []\n\n    # Handle the n=1 case separately as per the algorithm's structure\n    if n == 1:\n        p1 = b_vec[0]\n        if abs(p1) = tau:\n            return False\n        return [d_vec[0] / p1]\n\n    # Allocate memory for modified coefficients\n    c_prime = [0.0] * (n - 1)\n    d_prime = [0.0] * n\n\n    # --- Forward Elimination Phase ---\n\n    # Step for i = 1 (Python index 0)\n    p1 = b_vec[0]\n    if abs(p1) = tau:\n        return False\n    \n    c_prime[0] = c_vec[0] / p1\n    d_prime[0] = d_vec[0] / p1\n\n    # Loop for i = 2 to n (Python index 1 to n-1)\n    for i in range(1, n):\n        # Current mathematical index is i+1, Python index is i\n        # a_{i+1} in math corresponds to a_vec[i-1]\n        \n        pi = b_vec[i] - a_vec[i-1] * c_prime[i-1]\n        if abs(pi) = tau:\n            return False\n\n        if i  n - 1:\n            # c_{i+1} in math corresponds to c_vec[i]\n            c_prime[i] = c_vec[i] / pi\n        \n        # d_{i+1} in math corresponds to d_vec[i]\n        d_prime[i] = (d_vec[i] - a_vec[i-1] * d_prime[i-1]) / pi\n\n    # --- Backward Substitution Phase ---\n    x = [0.0] * n\n    x[n - 1] = d_prime[n - 1]\n    \n    # Loop for i = n-1 down to 1 (Python index n-2 down to 0)\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\n\ndef solve():\n    \"\"\"\n    Runs the provided test suite and prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case 1: regular, strictly diagonally dominant\n        {'a': [-1., -1., -1., -1.], 'b': [2., 2., 2., 2., 2.], 'c': [-1., -1., -1., -1.], 'd': [1., 1., 1., 1., 1.], 'tau': 1e-12},\n        # Case 2: boundary size n=1, failure due to tiny first pivot\n        {'a': [], 'b': [1e-12], 'c': [], 'd': [1.], 'tau': 1e-10},\n        # Case 3: mid-computation exact zero pivot\n        {'a': [1., 1.], 'b': [1., 1., 1.], 'c': [1., 1.], 'd': [1., 2., 3.], 'tau': 1e-12},\n        # Case 4: diagonal matrix\n        {'a': [0., 0., 0.], 'b': [3., 4., 5., 6.], 'c': [0., 0., 0.], 'd': [3., 8., 10., 12.], 'tau': 1e-12},\n        # Case 5: near-singular but acceptable under strict tolerance\n        {'a': [1.], 'b': [1., 1. + 1e-9], 'c': [1.], 'd': [1., 1.], 'tau': 1e-12},\n        # Case 6: same as Case 5 but failure under looser tolerance\n        {'a': [1.], 'b': [1., 1. + 1e-9], 'c': [1.], 'd': [1., 1.], 'tau': 1e-8},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_tridiagonal(case['a'], case['b'], case['c'], case['d'], case['tau'])\n        all_results.append(result)\n\n    # Format the results into a single string with no spaces, as required.\n    string_results = []\n    for res in all_results:\n        if res is False:\n            string_results.append(\"False\")\n        else: # It is a list of numbers\n            list_as_string = \"[\" + \",\".join(map(str, res)) + \"]\"\n            string_results.append(list_as_string)\n            \n    final_output = \"[\" + \",\".join(string_results) + \"]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "托马斯算法的用途超出了仅仅求解线性方程组 $A\\mathbf{x} = \\mathbf{d}$。本练习展示了一个巧妙的应用：在不计算整个逆矩阵 $A^{-1}$ 的情况下，高效地求出其特定的一列。这不仅能加深你对矩阵逆定义的理解（即 $A A^{-1} = I$），也突显了线性方程求解器作为解决更广泛矩阵问题的基础工具的强大功能。",
            "id": "2446301",
            "problem": "考虑一个非奇异三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其下对角线元素为 $a \\in \\mathbb{R}^{n-1}$，主对角线元素为 $b \\in \\mathbb{R}^{n}$，上对角线元素为 $c \\in \\mathbb{R}^{n-1}$。您的任务是设计一个方法，用于计算逆矩阵 $A^{-1}$ 的某一列，即对于给定的列索引 $j$，计算 $A^{-1}_{:,j}$，而无需计算整个逆矩阵。Thomas 算法是高斯消元法 (Gaussian elimination) 针对三对角系统的一种特殊形式，其运行时间为线性时间。\n\n从逆矩阵的基本定义出发，第 $j$ 列 $A^{-1}_{:,j}$ 是满足 $A x = e_j$ 的唯一向量 $x \\in \\mathbb{R}^{n}$，其中 $e_j$ 是第 $j$ 个标准基向量。您的任务是实现一个程序，在给定 $(a,b,c)$ 和一个从零开始的列索引 $j \\in \\{0,1,\\dots,n-1\\}$ 的情况下，构造 $e_j$ 并使用基于 Thomas 算法的前向消元和回代法求解三对角线性系统 $A x = e_j$。这样得到的 $x$ 即为 $A^{-1}_{:,j}$。您不得构造完整的逆矩阵 $A^{-1}$。\n\n您的程序必须：\n- 实现一个求解 $A x = d$ 的求解器，其中 $A$ 是三对角矩阵，其下对角线为 $a$，主对角线为 $b$，上对角线为 $c$，右端项为 $d$。求解器需使用 Thomas 算法的数值稳定版本，通过要求所有主元非零来避免除零错误。\n- 对于每个指定的测试用例，设置 $d = e_j$ 以获得所需的列 $A^{-1}_{:,j}$。\n- 将所得向量的每个分量四舍五入到 $6$ 位小数，并以小数点后恰好 $6$ 位的精度打印。\n\n使用以下测试套件，每个用例指定为 $(a,b,c,j)$，其中 $j$ 为从零开始的索引：\n- 测试用例 1 (通用，对角占优):\n  - $n=5$\n  - $a = [-1,-1,-1,-1]$\n  - $b = [4,4,4,4,4]$\n  - $c = [-1,-1,-1,-1]$\n  - $j = 2$\n- 测试用例 2 (对称正定，边界列):\n  - $n=6$\n  - $a = [-1,-1,-1,-1,-1]$\n  - $b = [2,2,2,2,2,2]$\n  - $c = [-1,-1,-1,-1,-1]$\n  - $j = 0$\n- 测试用例 3 (可变系数，最后一列):\n  - $n=6$\n  - $a = [0.5,-0.3,0.7,-0.2,1.1]$\n  - $b = [3.0,2.5,2.8,3.2,2.9,3.1]$\n  - $c = [-0.4,0.6,-0.5,0.9,-0.7]$\n  - $j = 5$\n- 测试用例 4 (最小维度):\n  - $n=1$\n  - $a = []$\n  - $b = [5.0]$\n  - $c = []$\n  - $j = 0$\n\n最终输出格式要求：\n- 您的程序必须生成单行输出，其中按顺序包含所有测试用例的结果，聚合为一个列表的列表，不含空格，并且每个浮点数都以小数点后恰好 $6$ 位的精度打印。例如，格式必须类似于 $[\\,[x\\_1,x\\_2,\\dots],[y\\_1,y\\_2,\\dots],\\dots\\,]$，不含空格，如 $[[0.125000,0.000000],[\\dots],\\dots]$。\n\n不涉及物理单位。不使用角度。所有数值答案均为实数。每个测试用例的答案必须是一个浮点数列表，每个浮点数四舍五入到 $6$ 位小数，最终程序输出必须是符合指定格式的单行字符串。",
            "solution": "提供的问题陈述已经过严格审查，并被认定为有效。它在科学上是合理的，在数学上是适定的，并包含获得唯一解所需的所有必要信息。该问题要求计算矩阵逆的特定列，这是计算科学与工程中的一项标准任务。我们将采用严谨的方法进行求解。\n\n定义非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的逆的基本关系是 $A A^{-1} = I_n$，其中 $I_n$ 是 $n \\times n$ 的单位矩阵。令 $x^{(j)}$ 表示 $A^{-1}$ 的第 $j$ 列， $e_j$ 表示 $I_n$ 的第 $j$ 列（即在索引 $j$ 处为 1，其余位置为零的标准基向量）。矩阵-向量积 $A x^{(j)}$ 得到乘积 $A A^{-1}$ 的第 $j$ 列。因此，计算逆矩阵的第 $j$ 列等价于求解以下线性方程组：\n$$\nA x^{(j)} = e_j\n$$\n问题指明矩阵 $A$ 是三对角的。此类系统可使用 Thomas 算法（也称为三对角矩阵算法，即 TDMA）高效求解。该算法是高斯消元法 (Gaussian elimination) 的一种简化形式，计算复杂度为 $O(n)$。\n\n该算法分两个阶段进行：一个前向消元过程和一个回代过程。设三对角矩阵 $A$ 由其下对角线 $a \\in \\mathbb{R}^{n-1}$、主对角线 $b \\in \\mathbb{R}^{n}$ 和上对角线 $c \\in \\mathbb{R}^{n-1}$ 表示。方程组 $Ax=d$ 可写为：\n$$\n\\begin{cases}\nb_0 x_0 + c_0 x_1 = d_0  \\text{for } i=0 \\\\\na_{i-1} x_{i-1} + b_i x_i + c_i x_{i+1} = d_i  \\text{for } i=1, \\dots, n-2 \\\\\na_{n-2} x_{n-2} + b_{n-1} x_{n-1} = d_{n-1}  \\text{for } i=n-1\n\\end{cases}\n$$\n其中所有索引都是从零开始的。\n\n**1. 前向消元**\n\n此阶段的目标是消去下对角线元素，将系统转化为上双对角形式。我们通过修改矩阵的系数和右端项向量 $d$ 来实现这一点。对于每一行 $i$，我们用 $x_{i+1}$ 来表示 $x_i$。\n\n从第一个方程（$i=0$）开始，我们除以 $b_0$（由于 $A$ 是非奇异的，所以 $b_0$ 非零）：\n$$\nx_0 + \\frac{c_0}{b_0} x_1 = \\frac{d_0}{b_0}\n$$\n我们定义新的系数 $c'_0 = \\frac{c_0}{b_0}$ 和 $d'_0 = \\frac{d_0}{b_0}$。\n\n对于后续的行 $i = 1, \\dots, n-1$，我们将前一行修改后的方程中 $x_{i-1}$ 的表达式 $x_{i-1} = d'_{i-1} - c'_{i-1}x_i$ 代入当前行的方程 $a_{i-1}x_{i-1} + b_ix_i + c_ix_{i+1} = d_i$（其中约定 $c_{n-1}=0$）：\n$$\na_{i-1}(d'_{i-1} - c'_{i-1}x_i) + b_i x_i + c_i x_{i+1} = d_i\n$$\n整理关于 $x_i$ 的项得到：\n$$\n(b_i - a_{i-1}c'_{i-1})x_i + c_i x_{i+1} = d_i - a_{i-1}d'_{i-1}\n$$\n项 $m_i = b_i - a_{i-1}c'_{i-1}$ 作为第 $i$ 行的主元。对于问题中指定的矩阵（对角占优或对称正定），这些主元保证非零。除以主元，我们得到第 $i$ 行修改后的方程：\n$$\nx_i + \\frac{c_i}{m_i} x_{i+1} = \\frac{d_i - a_{i-1}d'_{i-1}}{m_i}\n$$\n这就给出了修改后系数 $c'_i$ 和 $d'_i$ 的递推关系：\n$$\nc'_i = \\frac{c_i}{b_i - a_{i-1}c'_{i-1}} \\quad \\text{for } i=1, \\dots, n-2\n$$\n$$\nd'_i = \\frac{d_i - a_{i-1}d'_{i-1}}{b_i - a_{i-1}c'_{i-1}} \\quad \\text{for } i=1, \\dots, n-1\n$$\n经过此前向过程，原始系统 $Ax=d$ 被转化为一个等价的上三角系统 $A'x=d'$，其中 $A'_{ii}=1$, $A'_{i,i+1}=c'_i$，所有其他元素均为零。\n\n**2. 回代**\n\n当系统处于上双对角形式时，我们可以从最后一个方程开始，通过回代求解 $x$。\n最后一个方程就是 $x_{n-1} = d'_{n-1}$。\n对于其余的未知数，我们使用关系 $x_i + c'_i x_{i+1} = d'_i$：\n$$\nx_i = d'_i - c'_i x_{i+1} \\quad \\text{for } i = n-2, \\dots, 0\n$$\n这个过程得到解向量 $x = x^{(j)}$。\n\n对于每个测试用例，我们为指定的列索引 $j$ 构造向量 $d=e_j$，应用所述的 Thomas 算法，并报告结果向量 $x^{(j)}$，其分量四舍五入到 $6$ 位小数。$n=1$ 的特殊情况简化为平凡方程 $b_0 x_0 = d_0$，解为 $x_0 = d_0 / b_0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {\n            \"a\": [-1, -1, -1, -1],\n            \"b\": [4, 4, 4, 4, 4],\n            \"c\": [-1, -1, -1, -1],\n            \"j\": 2\n        },\n        # Test case 2\n        {\n            \"a\": [-1, -1, -1, -1, -1],\n            \"b\": [2, 2, 2, 2, 2, 2],\n            \"c\": [-1, -1, -1, -1, -1],\n            \"j\": 0\n        },\n        # Test case 3\n        {\n            \"a\": [0.5, -0.3, 0.7, -0.2, 1.1],\n            \"b\": [3.0, 2.5, 2.8, 3.2, 2.9, 3.1],\n            \"c\": [-0.4, 0.6, -0.5, 0.9, -0.7],\n            \"j\": 5\n        },\n        # Test case 4\n        {\n            \"a\": [],\n            \"b\": [5.0],\n            \"c\": [],\n            \"j\": 0\n        }\n    ]\n\n    def thomas_solver(a, b, c, d):\n        \"\"\"\n        Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n        \n        Args:\n            a (list or np.ndarray): Subdiagonal elements (length n-1).\n            b (list or np.ndarray): Diagonal elements (length n).\n            c (list or np.ndarray): Superdiagonal elements (length n-1).\n            d (list or np.ndarray): Right-hand side vector (length n).\n            \n        Returns:\n            np.ndarray: The solution vector x.\n        \"\"\"\n        n = len(b)\n        \n        if n == 0:\n            return np.array([])\n        if n == 1:\n            if b[0] == 0:\n                raise ValueError(\"Division by zero in n=1 case.\")\n            return np.array([d[0] / b[0]])\n\n        # Create copies to avoid modifying input lists\n        ac = np.array(a, dtype=float)\n        bc = np.array(b, dtype=float)\n        cc = np.array(c, dtype=float)\n        dc = np.array(d, dtype=float)\n\n        c_prime = np.zeros(n - 1)\n        d_prime = np.zeros(n)\n\n        # Forward elimination phase\n        if bc[0] == 0:\n            raise ValueError(\"Pivot is zero. Thomas algorithm requires non-zero pivots.\")\n        c_prime[0] = cc[0] / bc[0]\n        d_prime[0] = dc[0] / bc[0]\n\n        for i in range(1, n):\n            denom = bc[i] - ac[i-1] * c_prime[i-1]\n            if denom == 0:\n                raise ValueError(\"Pivot is zero. Thomas algorithm requires non-zero pivots.\")\n            \n            if i  n - 1:\n                c_prime[i] = cc[i] / denom\n            \n            d_prime[i] = (dc[i] - ac[i-1] * d_prime[i-1]) / denom\n\n        # Backward substitution phase\n        x = np.zeros(n)\n        x[n-1] = d_prime[n-1]\n        for i in range(n - 2, -1, -1):\n            x[i] = d_prime[i] - c_prime[i] * x[i+1]\n            \n        return x\n\n    all_results = []\n    for case in test_cases:\n        a, b, c, j = case[\"a\"], case[\"b\"], case[\"c\"], case[\"j\"]\n        n = len(b)\n        \n        # Construct the j-th standard basis vector e_j\n        d = np.zeros(n)\n        d[j] = 1.0\n        \n        # Solve Ax = e_j to get the j-th column of A^-1\n        x = thomas_solver(a, b, c, d)\n        \n        # The problem requires rounding to 6 decimal places.\n        # The string formatting `{:.6f}` handles this rounding.\n        all_results.append(x)\n\n    # Format the final output string as specified\n    result_strings = []\n    for res in all_results:\n        # Format each number to have exactly 6 decimal places.\n        formatted_numbers = [f\"{val:.6f}\" for val in res]\n        result_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}