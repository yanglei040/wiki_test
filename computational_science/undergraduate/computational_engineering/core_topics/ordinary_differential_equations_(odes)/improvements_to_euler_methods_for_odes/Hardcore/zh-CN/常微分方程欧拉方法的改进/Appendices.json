{
    "hands_on_practices": [
        {
            "introduction": "显式欧拉方法虽然简单，但在模拟弹簧等物理系统时，为了保持稳定，往往需要极小的时间步长。本练习将介绍一种重要的改进方法：半隐式欧拉法 。你会发现，只需对算法进行微小调整，即将对数值稳定性影响最大的项（阻尼项）进行隐式处理，就能显著提高方法的稳定性，从而允许使用更大的时间步长进行模拟。",
            "id": "2402453",
            "problem": "给定一个由以下常微分方程 (ODE) 控制的一维质量-弹簧-阻尼模型：$$m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0,$$ 其中 $m$ 是质量，单位为千克，$c$ 是粘性阻尼系数，单位为千克/秒，$k$ 是弹簧刚度，单位为牛顿/米。引入速度变量 $v(t) = \\dot{x}(t)$。考虑该系统在大小为 $h$ 秒的均匀时间步长上的以下一阶时间离散化：\n$$v_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}}, \\quad x_{n+1} = x_n + h \\, v_{n+1},$$\n初始条件为 $x_0$ 和 $v_0$。量 $x_n$ 和 $v_n$ 分别近似于离散时间 $t_n = n h$ 时的位置和速度。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 实现上述离散时间更新，以将 $x_n$ 和 $v_n$ 传播指定的步数 $N$。\n- 对于下面指定的每个测试用例，计算：\n  1. 最终位置 $x_N$（米）。\n  2. 最终速度 $v_N$（米/秒）。\n  3. 最终机械能 $$E_N = \\tfrac{1}{2} m v_N^2 + \\tfrac{1}{2} k x_N^2$$（焦耳）。\n  4. 一个有界性指标，定义如下：令 $$M = \\max_{0 \\le n \\le N} \\max\\{|x_n|, |v_n|\\}。$$ 如果 $M \\le B$ 则结果定义为 $1$，否则为 $0$，其中 $B = 10^6$。\n- 所有值 $x_N$、$v_N$ 和 $E_N$ 都必须以国际单位制 (SI) 表示。不要打印单位；数值将被解释为国际单位制单位。\n\n使用以下测试套件，其中每个用例是一个元组 $(m, c, k, h, N, x_0, v_0)$：\n- 用例 1：$(1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0)$\n- 用例 2：$(1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0)$\n- 用例 3：$(1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个用例，按顺序附加四个值 $[x_N, v_N, E_N, \\text{bounded}]$，其中有界性指标用整数 $1$ 表示真，$0$ 表示假。因此，最终输出必须包含与上述三个用例相对应的 12 个逗号分隔的条目，顺序与用例给出的顺序相同，例如：\n\"[x1,v1,E1,b1,x2,v2,E2,b2,x3,v3,E3,b3]\"。",
            "solution": "在尝试任何解决方案之前，首先对问题陈述进行严格验证，以确保其科学和逻辑的完整性。\n\n### 第 1 步：提取已知条件\n\n问题陈述中逐字提供了以下信息：\n- **控制常微分方程：** $m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0$，其中 $m$ 是质量 (kg)，$c$ 是阻尼系数 (kg/s)，$k$ 是弹簧刚度 (N/m)。\n- **状态变量：** $v(t) = \\dot{x}(t)$。\n- **离散化方案：**\n  - 时间步长：$h$ (s)。\n  - $t_n = n h$ 时的近似值：$x_n, v_n$。\n  - 更新方程：\n    $$v_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}}, \\quad x_{n+1} = x_n + h \\, v_{n+1}$$\n- **初始条件：** $x_0, v_0$。\n- **任务：** 对于给定的步数 $N$，计算：\n  1. 最终位置 $x_N$ (米)。\n  2. 最终速度 $v_N$ (米/秒)。\n  3. 最终机械能 $E_N = \\tfrac{1}{2} m v_N^2 + \\tfrac{1}{2} k x_N^2$ (焦耳)。\n  4. 有界性指标：令 $M = \\max_{0 \\le n \\le N} \\max\\{|x_n|, |v_n|\\}$。如果 $M \\le B$，该指标为 $1$，否则为 $0$，其中 $B = 10^6$。\n- **测试用例：** 每个用例是一个元组 $(m, c, k, h, N, x_0, v_0)$。\n  - 用例 1：$(1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0)$\n  - 用例 2：$(1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0)$\n  - 用例 3：$(1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0)$\n\n### 第 2 步：使用提取的已知条件进行验证\n\n- **科学依据：** 该控制方程是质量-弹簧-阻尼系统的基本线性模型，是经典力学的基石。机械能的定义是正确的。该数值方案是求解常微分方程的合法方法。该问题在科学上是合理的。\n- **适定性：** 该常微分方程的初值问题是适定的。所提供的离散化方案在其更新规则中是显式的，意味着 $x_{n+1}$ 和 $v_{n+1}$ 由 $x_n$ 和 $v_n$ 唯一确定。对于所有有效的物理参数（$m0, c\\ge0, h0$），分母 $1 + h \\, \\frac{c}{m}$ 均不为零。该问题是适定的。\n- **客观性：** 该问题使用精确、客观的数学和物理术语进行表述。任务是定量的且无歧义的。该问题是客观的。\n- **完整性和一致性：** 每个测试用例都提供了所有必要的常数、初始条件和参数（$m, c, k, h, N, x_0, v_0, B$）。该问题是自包含且一致的。单位指定为国际单位制 (SI)，这是一致的。\n\n### 第 3 步：结论与行动\n\n问题陈述在科学上是合理的、适定的和完整的。它被判定为**有效**。将开发一个解决方案。\n\n### 解决方案\n\n该解决方案需要实现一个数值时间步进算法来近似质量-弹簧-阻尼系统的动力学。\n\n**1. 数学公式**\n\n通过引入速度变量 $v(t) = \\dot{x}(t)$，二阶常微分方程 (ODE)\n$$m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0$$\n被转换为一个一阶常微分方程组。该系统变为：\n$$\n\\begin{cases}\n\\dot{x}(t) = v(t) \\\\\n\\dot{v}(t) = -\\frac{k}{m} x(t) - \\frac{c}{m} v(t)\n\\end{cases}\n$$\n\n**2. 离散化方案分析**\n\n提供的更新规则是：\n$$\nv_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}} \\tag{1}\n$$\n$$\nx_{n+1} = x_n + h \\, v_{n+1} \\tag{2}\n$$\n其中 $h$ 是时间步长，$(x_n, v_n)$ 是在时间 $t_n = n h$ 时 $(x(t_n), v(t_n))$ 的近似值。\n\n该方案可以被识别为一种半隐式方法。通过将方程重新排列成有限差分的形式，我们可以看到其结构：\n$$\n\\frac{x_{n+1} - x_n}{h} = v_{n+1} \\quad \\text{（位置的隐式/后向欧拉步）}\n$$\n$$\n\\frac{v_{n+1} - v_n}{h} = -\\frac{k}{m} x_n - \\frac{c}{m} v_{n+1} \\quad \\text{（速度的混合步）}\n$$\n速度更新使用旧位置 $x_n$（对弹簧力的显式或前向处理）和新速度 $v_{n+1}$（对阻尼力的隐式或后向处理）。这种结构通常比完全显式的方法（如标准前向欧拉法）提供更好的稳定性，特别是对于刚性或振荡系统。\n\n**3. 无阻尼情况的稳定性考虑**\n\n数值方法的一个关键方面是稳定性。考虑用例 3，其中没有阻尼 ($c=0$)。参数 $c_m = c/m$ 变为 $0$。更新方程简化为：\n$$\nv_{n+1} = v_n - h \\frac{k}{m} x_n\n$$\n$$\nx_{n+1} = x_n + h v_{n+1}\n$$\n这是著名的辛欧拉方法。对于简谐振子，其稳定性取决于时间步长的大小。稳定性判据是 $|h \\omega_0| \\le 2$，其中 $\\omega_0 = \\sqrt{k/m}$ 是固有角频率。\n\n对于用例 3，我们有 $m=1.0$，$k=1.0$ 和 $h=2.2$。固有频率是 $\\omega_0 = \\sqrt{1.0/1.0} = 1.0 \\, \\text{rad/s}$。我们检查稳定性条件：\n$$\n|h \\omega_0| = |2.2 \\times 1.0| = 2.2\n$$\n由于 $2.2  2.0$，稳定性条件被违反。对于此参数选择，数值方案是不稳定的。因此，我们必须预测用例 3 的数值解将无界增长，并且有界性指标应正确地为 $0$。这是测试用例的一个特点，而不是问题本身的缺陷。\n\n**4. 算法流程**\n\n程序将为每个测试用例 $(m, c, k, h, N, x_0, v_0)$ 执行以下步骤：\n1.  初始化状态变量 $x = x_0$ 和 $v = v_0$。\n2.  初始化有界性跟踪变量，$M_{max} = \\max(|x_0|, |v_0|)$。\n3.  预先计算常数系数 $\\frac{k}{m}$ 和 $\\frac{c}{m}$ 以避免循环内的冗余计算。分母项 $1 + h \\frac{c}{m}$ 也将被预先计算。\n4.  执行一个从 $n=0$ 到 $N-1$ 的循环：\n    a. 使用方程 $(1)$ 计算 $v_{n+1}$。\n    b. 使用方程 $(2)$ 计算 $x_{n+1}$。\n    c. 更新状态：$(x_n, v_n) \\leftarrow (x_{n+1}, v_{n+1})$。\n    d. 更新跟踪器：$M_{max} = \\max(M_{max}, |x_{n+1}|, |v_{n+1}|)$。\n5.  循环完成后，最终状态为 $(x_N, v_N)$。\n6.  计算最终能量 $E_N = \\frac{1}{2} m v_N^2 + \\frac{1}{2} k x_N^2$。\n7.  确定有界性指标：如果 $M_{max} \\le 10^6$ 则为 $1$，否则为 $0$。\n8.  收集四个结果：$x_N, v_N, E_N,$ 和有界性指标。\n\n此流程将系统地应用于所有提供的测试用例，以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring-damper problem for a given set of test cases\n    using the specified semi-implicit numerical scheme.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, c, k, h, N, x0, v0)\n    test_cases = [\n        (1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0),\n        (1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0),\n        (1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0),\n    ]\n\n    # Bounding constant B\n    BOUND = 10**6\n\n    results = []\n    \n    for case in test_cases:\n        m, c, k, h, N, x0, v0 = case\n\n        # Initialize state variables\n        x = float(x0)\n        v = float(v0)\n\n        # Initialize tracker for boundedness check\n        max_abs_val = max(abs(x), abs(v))\n\n        # Pre-compute coefficients for efficiency\n        k_over_m = k / m\n        c_over_m = c / m\n        denominator = 1.0 + h * c_over_m\n\n        # Time-stepping loop\n        for _ in range(int(N)):\n            # Apply the update equations\n            v_new = (v - h * k_over_m * x) / denominator\n            x_new = x + h * v_new\n\n            # Update the state\n            x, v = x_new, v_new\n            \n            # Update the maximum absolute value observed\n            max_abs_val = max(max_abs_val, abs(x), abs(v))\n\n        # Final state\n        x_N = x\n        v_N = v\n\n        # Calculate final mechanical energy\n        E_N = 0.5 * m * v_N**2 + 0.5 * k * x_N**2\n\n        # Determine boundedness indicator\n        is_bounded = 1 if max_abs_val = BOUND else 0\n\n        # Append results for this case\n        results.extend([x_N, v_N, E_N, is_bounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了稳定性，提高计算精度是改进数值方法的另一个核心目标。本练习将引导你实现一种巧妙的“延迟修正”技术 。其核心思想是，首先使用标准欧拉法快速获得一个初步解，然后利用这个初步解来估计并补偿原始方法中的主要误差项，从而在第二轮计算中获得更精确的结果。通过这个练习，你将亲手将一阶的欧拉方法提升为二阶精度方法，并学会如何通过数值实验来验证其收敛阶。",
            "id": "2402452",
            "problem": "您需要形式化并实现一种用于常微分方程初值问题的前向欧拉法的延迟修正改进方法。考虑在均匀网格 $t_n=t_0+n h$（其中 $n=0,1,\\dots,N$，$h=(T-t_0)/N$）上形式为 $y'(t)=f(t,y(t))$ 的问题，其初始条件为 $y(t_0)=y_0$。通过 $y_{n+1}^{E}=y_n^{E}+h\\,f(t_n,y_n^{E})$ 定义一个初步的前向欧拉近似 $y_n^{E}$，其中 $y_0^{E}=y_0$。使用这个完整的欧拉计算过程，通过差商定义主误差项 $y''(t_n)$ 的一个近似\n$$\n\\widehat{y''}(t_n) \\coloneqq \\frac{ f(t_{n+1},\\,y_{n+1}^{E}) - f(t_n,\\,y_n^{E}) }{h}.\n$$\n然后，通过一个包含此估计值的单步法重新求解一个修正后的问题，使得修正后的数值解 $y_n^{C}$ 定义为\n$$\ny_{n+1}^{C} \\coloneqq y_n^{C} + h\\,f(t_n,y_n^{C}) + \\frac{h^2}{2}\\,\\widehat{y''}(t_n), \\quad y_0^{C}=y_0.\n$$\n对于下述每个测试用例，计算前向欧拉解和修正解在最终时间 $T$ 的绝对误差，并计算定义为前向欧拉误差除以修正误差的误差比。\n\n此外，对于指定的观测阶测试，通过两个步长 $h_1$ 和 $h_2=h_1/2$ 使用以下公式计算修正方法的观测全局阶 $p$\n$$\np \\coloneqq \\frac{\\log\\!\\big(e(h_1)/e(h_2)\\big)}{\\log(2)},\n$$\n其中 $e(h)$ 是使用步长 $h$ 的修正方法在最终时间 $T$ 得到的绝对误差。\n\n所有答案必须表示为无量纲实数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个数字必须以保留六位有效数字的十进制科学记数法打印，例如 $[1.234560\\mathrm{e}{-03},2.500000\\mathrm{e}{+00}]$。\n\n测试套件和要求的输出：\n\n- 测试用例 1（标准情况，线性自治）：$y'(t)=\\lambda y(t)$，其中 $\\lambda=-3$，$t_0=0$，$T=1$，$y_0=1$，$h=0.1$。在 $T$ 处的精确值为 $y(T)=\\exp(\\lambda T)$。输出三个数字：前向欧拉绝对误差、修正后的绝对误差以及它们的比率。\n\n- 测试用例 2（边界/边缘情况：单步）：$y'(t)=\\lambda y(t)$，其中 $\\lambda=-1$，$t_0=0$，$T=1$，$y_0=1$，$h=1$。在 $T$ 处的精确值为 $y(T)=\\exp(\\lambda T)$。输出与测试用例 1 相同的三个数字。\n\n- 测试用例 3（非线性自治）：$y'(t)=-y(t)^3$，$t_0=0$，$T=1$，$y_0=1$，$h=0.1$。在 $T$ 处的精确值为 $y(T)=1/\\sqrt{1+2T}$。输出与测试用例 1 相同的三个数字。\n\n- 测试用例 4（时变线性）：$y'(t)=t - y(t)$，$t_0=0$，$T=1$，$y_0=0$，$h=0.1$。在 $T$ 处的精确值为 $y(T)=T-1+\\exp(-T)$。输出与测试用例 1 相同的三个数字。\n\n- 测试用例 5（线性自治系统的观测阶）：对于 $y'(t)=\\lambda y(t)$，其中 $\\lambda=-3$，$t_0=0$，$T=1$，$y_0=1$，计算修正方法在 $T$ 处对于 $h_1=0.2$ 和 $h_2=0.1$ 的绝对误差，然后通过上述公式计算 $p$。输出一个数字：观测阶 $p$。\n\n- 测试用例 6（非线性自治系统的观测阶）：对于 $y'(t)=-y(t)^3$，$t_0=0$，$T=1$，$y_0=1$，计算修正方法在 $T$ 处对于 $h_1=0.2$ 和 $h_2=0.1$ 的绝对误差，然后通过上述公式计算 $p$。输出一个数字：观测阶 $p$。\n\n最终输出格式：您的程序必须以 $[r_1,r_2,\\dots,r_{14}]$ 的形式打印单行，其中的条目按顺序为测试用例 1 的三个数字、测试用例 2 的三个数字、测试用例 3 的三个数字、测试用例 4 的三个数字，随后是测试用例 5 的单个数字和测试用例 6 的单个数字，每个数字都按照上述规定以保留六位有效数字的十进制科学记数法呈现。",
            "solution": "所给问题是有效的，它形式化了一种用于求解具有初始条件 $y(t_0)=y_0$ 的 $y'(t)=f(t,y(t))$ 形式初值问题的、改进前向欧拉法的延迟修正技术。该方法在科学上是合理的、适定的，并且所有术语和步骤都得到了明确的定义。它构成了常微分方程数值分析领域的一个标准问题。我们开始进行求解。\n\n该方法的基本原理是修正前向欧拉法局部截断误差中的主项。精确解 $y(t)$ 在 $t_n$ 附近的泰勒级数展开为\n$$\ny(t_{n+1}) = y(t_n) + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + O(h^3),\n$$\n其中 $h$ 是步长，$y'(t) = f(t, y(t))$。前向欧拉法 $y_{n+1} = y_n + h f(t_n, y_n)$ 通过仅保留到 $h$ 的一阶项来近似此展开。因此，局部截断误差为 $y(t_{n+1}) - (y(t_n) + h f(t_n, y(t_n))) = \\frac{h^2}{2} y''(t_n) + O(h^3)$，这导致了 $O(h)$ 阶的全局误差。\n\n为了提高精度，可以尝试估计并包含二阶项 $\\frac{h^2}{2} y''(t_n)$。这定义了一种理想化的二阶方法。挑战在于 $y''(t_n)$ 通常是未知的。所提出的延迟修正方案通过一个两阶段过程来解决这个问题。\n\n首先，使用标准的前向欧拉法在整个区间 $[t_0, T]$ 上计算一个初步的、完整的解轨迹，记为 $y_n^E$：\n$$\ny_{n+1}^E = y_n^E + h f(t_n, y_n^E), \\quad y_0^E = y_0.\n$$\n尽管这个解只有一阶精度，全局误差为 $O(h)$，但它提供了在所有网格点 $t_n$ 上解的近似值。\n\n其次，使用这个初步解来估计真解的二阶导数 $y''(t_n)$。二阶导数的定义是 $y''(t) = \\frac{d}{dt} y'(t) = \\frac{d}{dt} f(t, y(t))$。在时间 $t_n$ 对该导数的一阶有限差分近似为 $\\frac{f(t_{n+1}, y(t_{n+1})) - f(t_n, y(t_n))}{h}$。该方法通过将初步欧拉计算得到的值 $y_n^E$ 和 $y_{n+1}^E$ 代替真解的值 $y(t_n)$ 和 $y(t_{n+1})$ 来近似这个表达式：\n$$\n\\widehat{y''}(t_n) \\coloneqq \\frac{f(t_{n+1}, y_{n+1}^E) - f(t_n, y_n^E)}{h}.\n$$\n对所有必要的步（即 $n=0, 1, \\dots, N-1$）执行此计算。由于 $y_n^E = y(t_n) + O(h)$，可以证明这个近似是一阶精确的，即 $\\widehat{y''}(t_n) = y''(t_n) + O(h)$。\n\n最后，计算一个新的、修正后的解 $y_n^C$。修改积分方案以包含估计的误差项。这产生了一个新的单步法，其中修正项是预先计算的，并充当一个强迫函数：\n$$\ny_{n+1}^C = y_n^C + h f(t_n, y_n^C) + \\frac{h^2}{2} \\widehat{y''}(t_n), \\quad y_0^C = y_0.\n$$\n这个修正方法的局部截断误差是 $O(h^3)$，因为来自泰勒展开的 $O(h^2)$ 项被修正项近似抵消了：$\\frac{h^2}{2} y''(t_n) - \\frac{h^2}{2} \\widehat{y''}(t_n) = \\frac{h^2}{2} (y''(t_n) - (y''(t_n) + O(h))) = O(h^3)$。一个局部截断误差为 $O(h^{p+1})$ 阶的方法通常具有 $O(h^p)$ 阶的全局误差。因此，我们期望这个修正方法是二阶精确的，全局误差为 $O(h^2)$。这个假设在指定的观测阶计算中得到了检验。\n\n该算法被实现为一个通用的求解器函数，它接受微分方程 $f$、初始和最终时间 $t_0$ 和 $T$、初始值 $y_0$ 以及步长 $h$。该函数首先执行欧拉计算，然后计算 $\\widehat{y''}(t_n)$ 值的数组，最后执行修正后的积分。然后将此求解器应用于问题陈述中定义的六个测试用例中的每一个。计算并收集所要求的量——欧拉法和修正法的绝对误差、它们的比率以及收敛的观测阶——用于最终输出。步数 $N$ 取为 $(T-t_0)/h$，对于所有测试用例，此比率都是整数，以满足均匀网格的要求。提供的精确解用于计算在最终时间 $T$ 的误差。收敛的观测阶 $p$ 使用公式 $p = \\log(e(h_1)/e(h_2)) / \\log(2)$ 计算，该公式直接源于误差 $e(h)$ 的行为类似于 $e(h) \\approx C h^p$（对于某个常数 $C$）的假设。",
            "answer": "```python\nimport numpy as np\n\ndef deferred_correction_solver(f, t0, T, y0, h):\n    \"\"\"\n    Solves an ODE y'(t) = f(t, y) using Forward Euler and a deferred correction method.\n\n    Args:\n        f (callable): The function f(t, y).\n        t0 (float): Initial time.\n        T (float): Final time.\n        y0 (float): Initial value y(t0).\n        h (float): Step size.\n\n    Returns:\n        tuple: A tuple containing:\n            - y_euler_final (float): The final value from the Forward Euler method.\n            - y_corrected_final (float): The final value from the corrected method.\n    \"\"\"\n    if not np.isclose((T - t0) / h, round((T - t0) / h)):\n        raise ValueError(\"T-t0 must be an integer multiple of h\")\n    N = int(round((T - t0) / h))\n    t_grid = np.linspace(t0, T, N + 1)\n\n    # Stage 1: Compute preliminary solution using Forward Euler\n    yE = np.zeros(N + 1)\n    yE[0] = y0\n    for n in range(N):\n        yE[n + 1] = yE[n] + h * f(t_grid[n], yE[n])\n\n    # Stage 1.5: Compute the approximation of the second derivative\n    ypp_hat = np.zeros(N)\n    for n in range(N):\n        ypp_hat[n] = (f(t_grid[n + 1], yE[n + 1]) - f(t_grid[n], yE[n])) / h\n\n    # Stage 2: Compute the corrected solution\n    yC = np.zeros(N + 1)\n    yC[0] = y0\n    for n in range(N):\n        yC[n + 1] = yC[n] + h * f(t_grid[n], yC[n]) + (h**2 / 2) * ypp_hat[n]\n\n    return yE[N], yC[N]\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the formatted results.\n    \"\"\"\n    results = []\n\n    # Test Case 1: y'(t) = -3y(t), h=0.1\n    f1 = lambda t, y: -3 * y\n    t0_1, T_1, y0_1, h_1 = 0, 1, 1, 0.1\n    y_exact_1 = np.exp(-3 * T_1)\n    yE_1, yC_1 = deferred_correction_solver(f1, t0_1, T_1, y0_1, h_1)\n    err_E1 = np.abs(yE_1 - y_exact_1)\n    err_C1 = np.abs(yC_1 - y_exact_1)\n    ratio1 = err_E1 / err_C1\n    results.extend([err_E1, err_C1, ratio1])\n\n    # Test Case 2: y'(t) = -y(t), h=1.0\n    f2 = lambda t, y: -1 * y\n    t0_2, T_2, y0_2, h_2 = 0, 1, 1, 1.0\n    y_exact_2 = np.exp(-1 * T_2)\n    yE_2, yC_2 = deferred_correction_solver(f2, t0_2, T_2, y0_2, h_2)\n    err_E2 = np.abs(yE_2 - y_exact_2)\n    err_C2 = np.abs(yC_2 - y_exact_2)\n    ratio2 = err_E2 / err_C2\n    results.extend([err_E2, err_C2, ratio2])\n\n    # Test Case 3: y'(t) = -y(t)^3, h=0.1\n    f3 = lambda t, y: -y**3\n    t0_3, T_3, y0_3, h_3 = 0, 1, 1, 0.1\n    y_exact_3 = 1 / np.sqrt(1 + 2 * T_3)\n    yE_3, yC_3 = deferred_correction_solver(f3, t0_3, T_3, y0_3, h_3)\n    err_E3 = np.abs(yE_3 - y_exact_3)\n    err_C3 = np.abs(yC_3 - y_exact_3)\n    ratio3 = err_E3 / err_C3\n    results.extend([err_E3, err_C3, ratio3])\n\n    # Test Case 4: y'(t) = t - y(t), h=0.1\n    f4 = lambda t, y: t - y\n    t0_4, T_4, y0_4, h_4 = 0, 1, 0, 0.1\n    y_exact_4 = T_4 - 1 + np.exp(-T_4)\n    yE_4, yC_4 = deferred_correction_solver(f4, t0_4, T_4, y0_4, h_4)\n    err_E4 = np.abs(yE_4 - y_exact_4)\n    err_C4 = np.abs(yC_4 - y_exact_4)\n    ratio4 = err_E4 / err_C4\n    results.extend([err_E4, err_C4, ratio4])\n\n    # Test Case 5: Observed order for Test Case 1\n    h5_1, h5_2 = 0.2, 0.1\n    _, yC_h1_5 = deferred_correction_solver(f1, t0_1, T_1, y0_1, h5_1)\n    err_h1_5 = np.abs(yC_h1_5 - y_exact_1)\n    err_h2_5 = err_C1 # Re-use calculation from Test Case 1\n    p5 = np.log(err_h1_5 / err_h2_5) / np.log(2)\n    results.append(p5)\n\n    # Test Case 6: Observed order for Test Case 3\n    h6_1, h6_2 = 0.2, 0.1\n    _, yC_h1_6 = deferred_correction_solver(f3, t0_3, T_3, y0_3, h6_1)\n    y_exact_6 = y_exact_3\n    err_h1_6 = np.abs(yC_h1_6 - y_exact_6)\n    err_h2_6 = err_C3 # Re-use calculation from Test Case 3\n    p6 = np.log(err_h1_6 / err_h2_6) / np.log(2)\n    results.append(p6)\n\n    # Format output as specified\n    formatted_results = [f\"{x:.6e}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "休恩（Heun）方法是另一种常见的二阶方法，通常被视为对欧拉法的直接升级。本练习将超越简单的算法实现，深入分析其在模拟振荡系统（如谐振子）时的长期行为特性 。你将通过编程，将该方法在模拟过程中的实际数值表现与基于稳定性理论的预测进行对比，从而揭示数值格式在能量保持等方面的细微特性，这对于物理和工程领域的长期动态模拟至关重要。",
            "id": "2402465",
            "problem": "考虑线性二阶常微分方程 $y'' = -k\\,y$，其中 $k  0$。将其重写为关于状态向量 $z(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$ 的一阶系统，其中 $x(t) = y(t)$ 且 $v(t) = y'(t)$。该系统具有 $z'(t) = A z(t)$ 的形式，其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个常数矩阵。使用初始条件 $x(0) = 1$ 和 $v(0) = 0$。令 $\\omega = \\sqrt{k}$，并定义振幅泛函 $A(t) = \\sqrt{x(t)^2 + \\left(\\dfrac{v(t)}{\\omega}\\right)^2}$。在这些条件下，精确的连续时间动力学系统会保持 $A(t)$ 在所有 $t \\ge 0$ 时不变。在本任务中，您的程序必须使用具有固定步长 $h$ 的Heun方法（显式梯形法则）在时间区间 $[0,T]$ 上推进该一阶系统，其中 $N = T/h$ 是一个整数。对于给定的 $(k,h,T)$，将在纯虚数特征值 $i \\omega$ 处计算的Heun方法的每步复数放大因子定义为 $R(i \\omega h) = 1 + i \\omega h + \\tfrac{1}{2}(i \\omega h)^2$，并令 $g(h,\\omega) = |R(i \\omega h)|$。令 $G(N,h,\\omega) = \\left(g(h,\\omega)\\right)^N$ 为 $N$ 步后预测的振幅乘法因子。对于每个测试用例，计算数值测量的振幅乘法因子与理论预测 $G(N,h,\\omega)$ 之间的绝对差值。数值测量的振幅乘法因子必须通过使用Heun方法离散化的轨迹计算为 $A(T)/A(0)$。您的程序必须评估以下参数三元组 $(k,h,T)$ 的测试套件：\n- $(k,h,T) = (1.0, 0.1, 10.0)$，\n- $(k,h,T) = (4.0, 0.05, 5.0)$，\n- $(k,h,T) = (1.0, 0.5, 50.0)$，\n- $(k,h,T) = (1.0, 0.001, 1.0)$。\n所有量都是无量纲的，不需要物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$）形式的结果，其中每个 $r_j$ 是对应测试用例的上述定义的绝对差值，以科学记数法表示，并精确到 $12$ 位有效数字。",
            "solution": "问题陈述是有效的。这是一个在计算工程领域中，特别是关于常微分方程数值分析的适定问题。所有参数和条件都已提供，目标在科学上是合理且可验证的。我们开始进行解答。\n\n该问题围绕一个简谐振子的线性二阶常微分方程（ODE）展开，该方程由 $y'' = -k\\,y$ 给出，其中 $k  0$ 为正常数。为了进行数值求解，我们首先将其转换为一个一阶ODE系统。令状态向量为 $z(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$，其中 $x(t) = y(t)$ 表示位置，$v(t) = y'(t)$ 表示速度。其导数为 $x'(t) = v(t)$ 和 $v'(t) = y''(t) = -k\\,x(t)$。这得到矩阵形式 $z'(t) = A z(t)$，其中：\n$$\nz'(t) = \\begin{pmatrix} x'(t) \\\\ v'(t) \\end{pmatrix} = \\begin{pmatrix} 0   1 \\\\ -k   0 \\end{pmatrix} \\begin{pmatrix} x(t) \\\\ v(t) \\end{pmatrix} \\implies A = \\begin{pmatrix} 0   1 \\\\ -k   0 \\end{pmatrix}\n$$\n初始条件指定为 $x(0) = 1$ 和 $v(0) = 0$，这对应于初始状态向量 $z(0) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n数值积分将使用Heun方法（也称为显式梯形法则或二阶Runge-Kutta方法）以固定步长 $h$ 来执行。对于一个通用的一阶系统 $z' = f(t,z)$，从时间 $t_n$ 的状态 $z_n$ 更新到时间 $t_{n+1} = t_n + h$ 的状态 $z_{n+1}$ 是一个两阶段过程：\n1.  预测步： $z_{n+1}^* = z_n + h f(t_n, z_n)$\n2.  校正步： $z_{n+1} = z_n + \\frac{h}{2} \\left[ f(t_n, z_n) + f(t_{n+1}, z_{n+1}^*) \\right]$\n\n对于我们的线性系统，$f(t,z) = A z$。将此代入Heun方法的公式中，可得：\n$z_{n+1} = z_n + \\frac{h}{2} \\left[ A z_n + A(z_n + h A z_n) \\right] = z_n + \\frac{h}{2} \\left[ 2 A z_n + h A^2 z_n \\right]$\n这可以简化为一个线性更新规则 $z_{n+1} = M_H z_n$，其中 $M_H$ 是放大矩阵：\n$$\nM_H = I + hA + \\frac{h^2}{2} A^2\n$$\n矩阵 $A^2$ 是 $\\begin{pmatrix} 0   1 \\\\ -k   0 \\end{pmatrix} \\begin{pmatrix} 0   1 \\\\ -k   0 \\end{pmatrix} = \\begin{pmatrix} -k   0 \\\\ 0   -k \\end{pmatrix} = -kI$。\n将 $A$ 和 $A^2$ 代入 $M_H$ 的表达式中：\n$$\nM_H = \\begin{pmatrix} 1   0 \\\\ 0   1 \\end{pmatrix} + h \\begin{pmatrix} 0   1 \\\\ -k   0 \\end{pmatrix} + \\frac{h^2}{2} \\begin{pmatrix} -k   0 \\\\ 0   -k \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{kh^2}{2}   h \\\\ -kh   1 - \\frac{kh^2}{2} \\end{pmatrix}\n$$\n因此，数值模拟涉及将此矩阵迭代应用于初始状态向量 $z_0$ 共 $N=T/h$ 次：$z_N = (M_H)^N z_0$。\n\n理论上预测的振幅乘法因子 $G(N,h,\\omega)$ 是基于稳定性分析的。数值解的行为与矩阵 $A$ 的特征值相关，其特征值为 $\\lambda_{\\pm} = \\pm i\\sqrt{k} = \\pm i\\omega$。当应用于测试方程 $u'=\\lambda u$ 时，Heun方法的稳定性函数为 $R(z) = 1+z+\\frac{1}{2}z^2$，其中 $z=h\\lambda$。放大矩阵 $M_H$ 的特征值由 $R(h\\lambda_{\\pm})$ 给出。因子 $g(h,\\omega)$ 定义为在其中一个特征值 $i\\omega$ 处计算的该稳定性函数的模：\n$$\ng(h,\\omega) = |R(i\\omega h)| = \\left| 1 + i\\omega h + \\frac{1}{2}(i\\omega h)^2 \\right| = \\left| \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) + i(\\omega h) \\right|\n$$\n模的计算如下：\n$$\ng(h,\\omega) = \\sqrt{\\left(1 - \\frac{\\omega^2 h^2}{2}\\right)^2 + (\\omega h)^2} = \\sqrt{1 - \\omega^2 h^2 + \\frac{\\omega^4 h^4}{4} + \\omega^2 h^2} = \\sqrt{1 + \\frac{\\omega^4 h^4}{4}}\n$$\n由于 $\\omega^2 = k$，这变为 $g(h,\\omega) = \\sqrt{1 + \\frac{k^2 h^4}{4}}$。$N$ 步后的理论总放大因子预测为 $G(N,h,\\omega) = (g(h,\\omega))^N$。\n\n数值测量的振幅乘法因子为 $A(T)/A(0)$。振幅泛函为 $A(t) = \\sqrt{x(t)^2 + (v(t)/\\omega)^2}$。\n在初始条件 $x(0) = 1$ 和 $v(0) = 0$下，初始振幅为 $A(0) = \\sqrt{1^2 + (0/\\omega)^2} = 1$。\n最终振幅为 $A(T) = \\sqrt{x_N^2 + (v_N/\\omega)^2}$，其中 $z_N = \\begin{bmatrix} x_N \\\\ v_N \\end{bmatrix}$ 是 $N$ 步后的状态。\n因此，测量的因子就是 $A(T)$。\n\n$A(T)$ 和 $G(N,h,\\omega)$ 之间预计会存在差异。理论预测 $G$ 假设增长完全由 $M_H$ 的特征值的模决定。这个假设成立的条件是 $M_H$ 是一个正规矩阵（$M_H^T M_H = M_H M_H^T$）并且使用的范数是标准的欧几里得2-范数。对于 $k=1$，矩阵 $M_H$ 确实是正规的，并且振幅泛函 $A(t)$ 对应于 $z(t)$ 的欧几里得范数。在这种特殊情况下，测量的振幅增长必须与理论预测完全匹配，任何差异都将归因于浮点表示误差。然而，对于 $k \\neq 1$，$M_H$ 不是正规矩阵。在非正规矩阵的作用下，特定的类能量范数 $A(t)$ 的演化通常不遵循谱半径。递推关系为 $A_{n+1}^2 = (g(h, \\omega))^2 A_n^2 + \\frac{(k-1)h^2}{k} v_n^2$。对于 $k1$ 时的附加正项（或对于 $k1$ 时的负项）导致了简单的特征值分析无法捕捉到的漂移。该问题要求计算这一精确的差异。\n\n解决方案需要实现一个循环，使用推导出的 $x_{n+1}$ 和 $v_{n+1}$ 的更新方程，对状态 $(x_n, v_n)$ 进行 $N$ 步迭代。然后，使用最终状态 $(x_N, v_N)$ 来计算测量因子 $A(T)$。将此与理论因子 $G(N,h,\\omega) = (1 + k^2 h^4 / 4)^{N/2}$ 进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by simulating an ODE with Heun's method and comparing\n    the numerical amplitude growth with the theoretical prediction from stability analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, h, T)\n        (1.0, 0.1, 10.0),\n        (4.0, 0.05, 5.0),\n        (1.0, 0.5, 50.0),\n        (1.0, 0.001, 1.0)\n    ]\n\n    results = []\n    for k, h, T in test_cases:\n        # Number of steps. The problem statement guarantees this is an integer.\n        N = int(round(T / h))\n\n        # Initial conditions\n        x = 1.0\n        v = 0.0\n\n        # Pre-calculate coefficients for Heun's method update matrix\n        # z_{n+1} = M_H * z_n\n        # M_H = [[c1, c2], [c3, c1]]\n        # c1 = 1 - k*h^2/2\n        # c2 = h\n        # c3 = -k*h\n        c1 = 1.0 - k * h**2 / 2.0\n        c2 = h\n        c3 = -k * h\n\n        # Run the simulation for N steps\n        for _ in range(N):\n            x_new = c1 * x + c2 * v\n            v_new = c3 * x + c1 * v\n            x, v = x_new, v_new\n        \n        # The final state is (x, v) at time T.\n\n        # Calculate the numerically measured amplitude multiplication factor.\n        # A(t) = sqrt(x(t)^2 + (v(t)/omega)^2), omega^2 = k\n        # A(0) = sqrt(1^2 + (0/omega)^2) = 1\n        # Measured factor = A(T) / A(0) = A(T)\n        measured_factor = np.sqrt(x**2 + v**2 / k)\n\n        # Calculate the theoretical predicted amplitude multiplication factor.\n        # g = |R(i*omega*h)| = sqrt(1 + (k^2 * h^4) / 4)\n        # G = g^N = (1 + (k^2 * h^4) / 4)^(N/2)\n        g_sq = 1.0 + k**2 * h**4 / 4.0\n        theoretical_factor = np.power(g_sq, N / 2.0)\n\n        # Compute the absolute difference\n        abs_diff = np.abs(measured_factor - theoretical_factor)\n        results.append(abs_diff)\n\n    # Format the results for the final print statement.\n    # The output must be in scientific notation with exactly 12 significant digits.\n    # The format specifier \"{:.11e}\" achieves this.\n    formatted_results = [f\"{r:.11e}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}