{
    "hands_on_practices": [
        {
            "introduction": "在深入学习计算方法之前，通过解析求解一个边值问题来巩固我们的理解是至关重要的。这个练习将指导你为一个简单的线性常微分方程找到精确解，该解将作为评估后续数值方法准确性的重要基准 。",
            "id": "513889",
            "problem": "考虑二阶线性常微分方程的边值问题：\n\n$$ y'' + 9y = x $$\n\n定义在区间 $[0, \\pi]$ 上，边界条件为 $y(0) = 0$ 和 $y'(\\pi) = 0$。求该解在 $x = \\pi/2$ 处的值，记为 $y(\\pi/2)$。",
            "solution": "1. 求解齐次方程 $y''+9y=0$：\n   特征方程为 $r^2+9=0$，解得 $r=\\pm3i$，所以\n   $$y_h = A\\cos(3x)+B\\sin(3x)。$$\n\n2. 寻求一个形如 $y_p=Cx+D$ 的特解。那么\n   $y_p''=0$, $9y_p=9(Cx+D)$,\n   所以\n   $$y_p''+9y_p=9Cx+9D\\stackrel{!}{=}x\\;\\Longrightarrow\\;9C=1,\\;9D=0$$\n   $$\\Longrightarrow\\;C=\\frac{1}{9},\\;D=0,\\quad y_p=\\frac{x}{9}。$$\n\n3. 通解为：\n   $$y(x)=A\\cos(3x)+B\\sin(3x)+\\frac{x}{9}。$$\n\n4. 应用条件 $y(0)=0$：\n   $y(0)=A\\cdot1+B\\cdot0+0=0\\;\\Longrightarrow\\;A=0$,\n   $$y(x)=B\\sin(3x)+\\frac{x}{9}。$$\n\n5. 计算导数并应用条件 $y'(\\pi)=0$：\n   $y'(x)=3B\\cos(3x)+\\frac{1}{9}$,\n   $y'(\\pi)=3B\\cos(3\\pi)+\\frac{1}{9}=3B(-1)+\\frac{1}{9}=0\\;\\Longrightarrow\\;B=\\frac{1}{27}$。\n\n6. 因此\n   $$y(x)=\\frac{1}{27}\\sin(3x)+\\frac{x}{9},\\quad \n     y\\Bigl(\\frac\\pi2\\Bigr)=\\frac{1}{27}\\sin\\!\\Bigl(\\frac{3\\pi}{2}\\Bigr)+\\frac{\\pi}{18} \n     =-\\frac{1}{27}+\\frac{\\pi}{18}=\\frac{\\pi}{18}-\\frac{1}{27}。$$",
            "answer": "$$\\boxed{\\frac{\\pi}{18} - \\frac{1}{27}}$$"
        },
        {
            "introduction": "有限差分法是一种强大的工具，它将微分方程转化为计算机可以求解的代数方程组。在本练习中，你将亲手实践如何离散化一个边值问题，并特别关注如何处理诺伊曼（Neumann）边界条件——这在涉及边界通量或梯度的工程与物理问题中十分常见 。",
            "id": "2173556",
            "problem": "考虑由常微分方程\n$$y'' - y = -x$$\n定义的两点边值问题，其定义域为区间 $0 \\le x \\le 1$。边界条件为 $y'(0) = 1$ 和 $y(1) = 2$。\n\n我们希望使用有限差分法求此问题的近似数值解。将区间 $[0, 1]$ 划分为 $n=3$ 个等宽的子区间，宽度为 $h$。令 $y_i$ 表示解 $y(x_i)$ 在网格点 $x_i = i h$ (其中 $i=0, 1, 2, 3$) 处的数值近似值。\n\n为离散化该微分方程，对二阶导数使用二阶中心差分近似，即 $y''(x_i) \\approx \\frac{y_{i+1} - 2y_i + y_{i-1}}{h^2}$。对于 $x=0$ 处的导数边界条件，使用一阶向前差分近似，即 $y'(x_0) \\approx \\frac{y_1 - y_0}{h}$。此过程将生成一个关于未知值 $y_0, y_1, y_2$ 的线性方程组。\n\n计算 $y(0)$ 的数值近似值。将您的答案表示为最简分数形式。",
            "solution": "我们将区间划分为 $n=3$ 个相等的子区间，因此 $h=(1-0)/3=1/3$。网格点为 $x_{i}=ih$ (其中 $i=0,1,2,3$)，右边界值给出 $y_{3}=2$。\n\n对 $x=0$ 处的导数边界条件使用一阶向前差分，\n$$\n\\frac{y_{1}-y_{0}}{h}=1 \\quad \\Rightarrow \\quad y_{1}=y_{0}+h.\n$$\n对内部节点使用二阶中心差分，对于 $i=1$ 和 $i=2$ 我们有\n$$\n\\frac{y_{i+1}-2y_{i}+y_{i-1}}{h^{2}}-y_{i}=-x_{i}.\n$$\n对于 $i=1$，由于 $x_{1}=h$，\n$$\n\\frac{y_{2}-2y_{1}+y_{0}}{h^{2}}-y_{1}=-h,\n$$\n两边同乘以 $h^{2}$ 后变为\n$$\ny_{2}-2y_{1}+y_{0}-h^{2}y_{1}=-h^{3}.\n$$\n代入 $y_{1}=y_{0}+h$ 得\n$$\ny_{2}+(-1-h^{2})y_{0}-(2+h^{2})h=-h^{3},\n$$\n因此\n$$\ny_{2}=(1+h^{2})y_{0}+(2+h^{2})h-h^{3}.\n$$\n对于 $i=2$，有 $x_{2}=2h$ 和 $y_{3}=2$，\n$$\n\\frac{y_{3}-2y_{2}+y_{1}}{h^{2}}-y_{2}=-2h,\n$$\n或者，两边同乘以 $h^{2}$，\n$$\ny_{3}-2y_{2}+y_{1}-h^{2}y_{2}=-2h^{3}.\n$$\n代入 $y_{3}=2$，$y_{1}=y_{0}+h$ 以及 $y_{2}$ 的表达式，得\n$$\n2+y_{0}+h-(2+h^{2})\\left[(1+h^{2})y_{0}+(2+h^{2})h-h^{3}\\right]=-2h^{3}.\n$$\n令 $A=2+h^{2}$，则上式为\n$$\n2+y_{0}+h-A(1+h^{2})y_{0}-A^{2}h+Ah^{3}=-2h^{3}.\n$$\n整理得，\n$$\n\\left[1-A(1+h^{2})\\right]y_{0}=-2h^{3}-2-h-Ah^{3}+A^{2}h.\n$$\n由于 $A(1+h^{2})=2+3h^{2}+h^{4}$，系数化简为 $-(1+3h^{2}+h^{4})$，而右边化简为 $-2+3h$。因此，\n$$\n-(1+3h^{2}+h^{4})\\,y_{0}=-2+3h \\quad \\Rightarrow \\quad y_{0}=\\frac{2-3h}{1+3h^{2}+h^{4}}.\n$$\n当 $h=1/3$ 时，我们计算\n$2-3h=2-1=1$, $1+3h^{2}+h^{4}=1+\\frac{1}{3}+\\frac{1}{81}=\\frac{109}{81}$.\n于是\n$$\ny_{0}=\\frac{1}{109/81}=\\frac{81}{109}.\n$$\n因此，$y(0)$ 的有限差分近似值为 $\\frac{81}{109}$。",
            "answer": "$$\\boxed{\\frac{81}{109}}$$"
        },
        {
            "introduction": "当面对非线性方程时，线性问题中的叠加原理不再适用，求解过程也变得更具挑战性。本练习将介绍打靶法，这是一种将边值问题巧妙地转化为初值问题求解的直观方法，你将通过它探索非线性特性如何导致解可能存在多个、一个甚至不存在的复杂情况 。",
            "id": "2375115",
            "problem": "考虑在无量纲设定下，常微分方程两点边值问题的打靶法。设 $x \\in [a,b]$ 为自变量，$y(x)$ 为因变量。对于一个二阶常微分方程，引入打靶参数 $s$ 作为 $x=a$ 处缺失的初始条件，并定义一个标量求根函数 $F(s)$，其零点（或零点集）对应于满足 $x=b$ 处边界条件的情况。具体来说，当左边界是狄利克雷（Dirichlet）类型时，取 $y(a) = \\alpha$ 和 $y^{\\prime}(a) = s$，并设 $F(s) = y(b;s) - \\beta$。当右边界是诺伊曼（Neumann）类型时，取 $y^{\\prime}(b) = \\gamma$ 并设 $F(s) = y^{\\prime}(b;s) - \\gamma$。根据非线性的性质，映射 $s \\mapsto F(s)$ 可能有多个根、没有根或有连续统的根。\n\n您的任务是实现一个程序，对三个精心选择的非线性边值问题，通过对初值问题进行数值积分和标量求根的区间划定，来刻画相应打靶函数 $F(s)$ 的根结构。任何三角表达式中使用的角度都必须以弧度为单位进行解释。\n\n从一个基本出发点开始，即右端项光滑的初值问题有唯一的局部解，并且在保守情况下，乘以 $y^{\\prime}$ 会得到一个第一运动积分。仅使用打靶法的定义以及初值问题的基本存在性和唯一性作为您的唯一起点。除非能从此基础推导，否则不要假设任何显式解。\n\n定义三个测试案例如下。\n\n- 案例 A（具有狄利克雷-狄利克雷边界条件的非线性保守振子；预期有多个根）：考虑\n  $$ y^{\\prime\\prime}(x) + y(x)^3 = 0, \\quad x \\in [0,1], $$\n  边界条件为\n  $$ y(0) = 0, \\quad y(1) = 0. $$\n  定义打靶参数为 $s = y^{\\prime}(0)$，求根函数为 $F(s) = y(1;s) - 0$。通过对多个 $s$ 值进行初值问题的数值积分来检测 $F(s)$ 的符号变化，然后将每个根所在的区间精确化以求得根。对于一个对称搜索区间 $[-S_{\\max}, S_{\\max}]$ 和网格间距 $\\Delta s$，报告在该区间内检测到的不同根的总数，包括对称的非零根以及（如果存在）$s = 0$ 处的根。使用测试参数 $S_{\\max} = 12$ 和 $\\Delta s = 0.05$。\n\n- 案例 B（具有诺伊曼-诺伊曼边界条件的非线性方程；预期无根）：考虑\n  $$ y^{\\prime\\prime}(x) = 1 + \\big(y^{\\prime}(x)\\big)^2, \\quad x \\in [0,1], $$\n  边界条件为\n  $$ y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0. $$\n  使用 $s = y(0)$ 作为打靶参数，并定义 $F(s) = y^{\\prime}(1;s) - 0$。通过在两个不同的打靶值 $s_1 = -1$ 和 $s_2 = 1$ 处评估 $F(s)$，来数值验证不存在根，证明 $F(s)$ 在这两点上严格非零且符号相同。返回一个布尔值，当且仅当此测试未检测到根时为真。\n\n- 案例 C（具有诺伊曼-诺伊曼边界条件的非线性方程；预期有连续统的根）：考虑\n  $$ y^{\\prime\\prime}(x) = y(x)\\,y^{\\prime}(x), \\quad x \\in [0,1], $$\n  边界条件为\n  $$ y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0. $$\n  使用 $s = y(0)$ 作为打靶参数，并定义 $F(s) = y^{\\prime}(1;s) - 0$。通过在两个不同的打靶值 $s_1 = -0.3$ 和 $s_2 = 0.8$ 处评估 $F(s)$，并检查两个评估结果是否都在一个严格的数值容差内为零，来数值验证存在连续统的根。返回一个布尔值，当且仅当两个值在数值上都为零时为真，这证实了存在多个不同的 $s$ 使得边界条件得到满足。\n\n实现要求和数值规格：\n\n- 对每个案例，将常微分方程表述为一阶系统：\n  $$ y^{\\prime} = v, \\quad v^{\\prime} = f(x, y, v). $$\n- 使用对 $[0,1]$ 上的初值问题的数值积分来评估 $F(s)$。如果在分析中使用三角函数，请以弧度解释角度。\n- 在积分器中使用相对容差 $10^{-10}$ 和绝对容差 $10^{-12}$。\n- 对于案例 A，在 $[0, S_{\\max}]$ 上以间距 $\\Delta s$ 对 $F(s)$ 进行粗略扫描，以找到 $F(s)$ 的符号变化，并用一个稳健的区间求根器精化每个区间。将计数镜像到 $[-S_{\\max}, 0)$，并包括可能在 $s=0$ 处检测到的根。\n- 对于案例 B 和 C，在指定的 $s$ 值处进行评估，并使用 $10^{-8}$ 的容差来判断是否为零。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出格式必须为 `[M, NR, CR],`\n\n最终程序必须是完整的，无需用户输入即可运行，仅使用 Python 标准库和指定的科学计算库。本问题中的所有数值和参数都是无量纲的；任何计算或报告中都不涉及物理单位。",
            "solution": "该问题要求使用打靶法对三个不同的非线性两点边值问题的解结构进行数值表征。对问题陈述的严格验证证实了其有效性：它在科学上基于常微分方程理论，是适定的、客观的，并为数值实现提供了一套完整且一致的参数。我们将着手解决此问题。\n\n打靶法将一个边值问题（BVP）转化为一个初值问题（IVP）。我们引入一个参数 $s$，代表在一个边界（例如 $x=a$）处缺失的初始条件。然后，我们将得到的 IVP 数值积分到另一个边界 $x=b$。定义一个函数 $F(s)$，当且仅当在 $x=b$ 处的边界条件得到满足时，该函数等于零。$F(s)$ 的根对应于原始 BVP 的解。\n\n对于一个形如 $y'' = g(x, y, y')$ 的一般二阶常微分方程，我们通过令 $y_0 = y$ 和 $y_1 = y'$ 将其重构为一个一阶系统。该系统为：\n$$\n\\begin{cases}\ny_0^{\\prime} = y_1 \\\\\ny_1^{\\prime} = g(x, y_0, y_1)\n\\end{cases}\n$$\n然后使用数值积分器求解此系统。对于本问题，我们使用指定的相对容差 $10^{-10}$ 和绝对容差 $10^{-12}$ 的高精度容差。\n\n### 案例 A：非线性保守振子\n边值问题为：\n$$ y^{\\prime\\prime}(x) + y(x)^3 = 0, \\quad x \\in [0,1], \\quad y(0) = 0, \\quad y(1) = 0 $$\n一阶系统为：\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ -y_0^3 \\end{pmatrix} $$\n在 $x=0$ 处的边界条件是狄利克雷类型，$y(0)=0$。我们引入打靶参数 $s = y^{\\prime}(0)$。因此，IVP 的初始条件为 $\\mathbf{y}(0) = [y_0(0), y_1(0)]^T = [0, s]^T$。打靶函数 $F(s)$ 由右边界条件 $y(1)=0$ 定义：\n$$ F(s) = y_0(1; s) - 0 = y_0(1; s) $$\n问题要求在区间 $s \\in [-12, 12]$ 内 $F(s)$ 的根的总数。\n\n该常微分方程是保守的，这表明解是振荡的，从而预期有多个根。此外，该方程在变换 $y \\to -y$ 下是不变的。如果 $y(x;s)$ 是打靶参数为 $s$ 的解，那么 $-y(x;s)$ 也是一个解。$-y(x;s)$ 的初始斜率为 $-y'(0;s) = -s$。因此，$F(-s) = y_0(1;-s) = -y_0(1;s) = -F(s)$。这种奇对称性意味着如果 $s_0 \\neq 0$ 是一个根，那么 $-s_0$ 也是一个根。同时，$F(0)=0$，对应于平凡解 $y(x)=0$，所以 $s=0$ 总是一个根。\n\n我们的步骤如下：\n1.  确定 $s=0$ 是一个根。\n2.  在区间 $(0, S_{\\max}]$ 中搜索根，其中 $S_{\\max} = 12$。我们用步长 $\\Delta s = 0.05$ 对此区间进行离散化。\n3.  对于离散化中每个出现符号变化的段 $[s_i, s_{i+1}]$，即 $F(s_i)F(s_{i+1})  0$，我们使用稳健的数值求根器确认该区间内存在一个唯一的根。\n4.  计算当 $s>0$ 时找到的根的数量。\n5.  由于对称性，根的总数是 $M = 1 + 2 \\times (\\text{正根的数量})$。\n\n### 案例 B：无解\n边值问题为：\n$$ y^{\\prime\\prime}(x) = 1 + \\big(y^{\\prime}(x)\\big)^2, \\quad x \\in [0,1], \\quad y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0 $$\n一阶系统为：\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ 1 + y_1^2 \\end{pmatrix} $$\n在 $x=0$ 处的边界条件是诺伊曼类型。因此，打靶参数被选为函数值本身，$s = y(0)$。初始条件为 $\\mathbf{y}(0) = [s, 0]^T$。打靶函数源于右边界条件 $y^{\\prime}(1)=0$：\n$$ F(s) = y_1(1; s) - 0 = y_1(1; s) $$\n$y_1 = y'$ 的方程与 $y_0$ 解耦：$y_1' = 1 + y_1^2$。这是一个可分离变量方程：$dy_1 / (1 + y_1^2) = dx$。使用初始条件 $y_1(0) = 0$ 从 $x=0$ 积分到一个一般的 $x$ 得到 $\\arctan(y_1(x)) = x$，或 $y_1(x) = \\tan(x)$。关键是，$y_1(x)$ 的这个解与 $y_0(0) = s$ 无关。因此，打靶函数是一个常数：\n$$ F(s) = y_1(1) = \\tan(1) \\approx 1.5574 $$\n由于 $F(s)$ 是一个非零常数，它没有根。我们通过在两个不同的点 $s_1 = -1$ 和 $s_2 = 1$ 处评估 $F(s)$，并确认两个值都是正且非零来数值验证这一点。如果此测试未检测到根，则布尔结果 `NR` 为真。\n\n### 案例 C：连续统解\n边值问题为：\n$$ y^{\\prime\\prime}(x) = y(x)\\,y^{\\prime}(x), \\quad x \\in [0,1], \\quad y^{\\prime}(0) = 0, \\quad y^{\\prime}(1) = 0 $$\n一阶系统为：\n$$ \\mathbf{y}^{\\prime} = \\begin{pmatrix} y_0^{\\prime} \\\\ y_1^{\\prime} \\end{pmatrix} = \\begin{pmatrix} y_1 \\\\ y_0 y_1 \\end{pmatrix} $$\n与案例 B 一样，我们使用打靶参数 $s = y(0)$，得到初始条件 $\\mathbf{y}(0) = [s, 0]^T$。打靶函数是 $F(s) = y_1(1; s)$。\n对系统进行解析考察揭示了一个特殊性质。初始条件 $y_1(0)=0$ 将系统置于 $y_1$ 分量的平衡状态，因为 $y_1'(0) = y_0(0) y_1(0) = s \\cdot 0 = 0$。根据初值问题解的唯一性，如果初始状态是一个平衡点，它将一直保持在该状态。因此，对于所有 $x \\in [0,1]$，$y_1(x) = 0$。这意味着 $y_0(x)$ 是常数，所以 $y_0(x) = y_0(0) = s$。\n对于任何常数 $s$，函数 $y(x) = s$ 及其导数 $y'(x) = 0$ 是常微分方程 $y'' = y y'$ 的一个有效解，因为它简化为 $0 = s \\cdot 0$。\n此解满足两个边界条件 $y'(0)=0$ 和 $y'(1)=0$。因此，对于所有 $s$ 值，$F(s) = y_1(1; s) = 0$。存在一个解的连续统。我们通过在两个不同的点 $s_1 = -0.3$ 和 $s_2 = 0.8$ 处评估 $F(s)$，并检查两个值是否都在 $10^{-8}$ 的容差内为零来数值验证这一点。如果此测试通过，则布尔结果 `CR` 为真。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves three boundary value problems using the shooting method to characterize\n    the root structure of the corresponding shooting function F(s).\n    \"\"\"\n\n    # --- Case A: Nonlinear conservative oscillator ---\n    def solve_case_a():\n        s_max = 12.0\n        delta_s = 0.05\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_a(t, y):\n            # y'' + y^3 = 0  =  y0' = y1, y1' = -y0^3\n            y0, y1 = y\n            return [y1, -y0**3]\n\n        memo = {}\n        def F_a(s):\n            s_val = float(s)\n            if s_val in memo:\n                return memo[s_val]\n            \n            # Trivial case s=0\n            if abs(s_val)  1e-15:\n                return 0.0\n\n            # Initial condition: y(0)=0, y'(0)=s\n            y0 = [0.0, s_val]\n            sol = solve_ivp(ode_a, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y(1;s)\n            result = sol.y[0, -1]\n            memo[s_val] = result\n            return result\n\n        # The trivial solution y(x)=0 corresponding to s=0 is a root.\n        root_count = 1  \n        \n        # Scan for roots for s  0\n        positive_roots = 0\n        s_grid = np.arange(delta_s, s_max + delta_s, delta_s)\n        \n        f_prev = F_a(0)\n        s_prev = 0\n        \n        for s_curr in s_grid:\n            f_curr = F_a(s_curr)\n            if np.sign(f_curr) != np.sign(f_prev) and f_prev != 0:\n                # Bracket found, refine with brentq to confirm root\n                try:\n                    brentq(F_a, s_prev, s_curr)\n                    positive_roots += 1\n                except ValueError:\n                    # Should not happen if sign change is correct\n                    pass\n            s_prev = s_curr\n            f_prev = f_curr\n\n        # Total roots = 1 (for s=0) + 2 * (positive roots) due to symmetry\n        M = 1 + 2 * positive_roots\n        return M\n\n    # --- Case B: Nonlinear equation with no roots ---\n    def solve_case_b():\n        s1 = -1.0\n        s2 = 1.0\n        zero_tol = 1e-8\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_b(t, y):\n            # y'' = 1 + (y')^2  =  y0' = y1, y1' = 1 + y1^2\n            y0, y1 = y\n            return [y1, 1 + y1**2]\n\n        def F_b(s):\n            # Initial condition: y(0)=s, y'(0)=0\n            y0 = [s, 0.0]\n            sol = solve_ivp(ode_b, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y'(1;s)\n            return sol.y[1, -1]\n\n        f_s1 = F_b(s1)\n        f_s2 = F_b(s2)\n        \n        # Analytically, F(s) = tan(1) for all s.\n        # Check if both are non-zero and have the same sign.\n        no_root_detected = (\n            abs(f_s1) > zero_tol and\n            abs(f_s2) > zero_tol and\n            np.sign(f_s1) == np.sign(f_s2)\n        )\n        return no_root_detected\n\n    # --- Case C: Nonlinear equation with a continuum of roots ---\n    def solve_case_c():\n        s1 = -0.3\n        s2 = 0.8\n        zero_tol = 1e-8\n        rtol = 1e-10\n        atol = 1e-12\n\n        def ode_c(t, y):\n            # y'' = y * y'  =  y0' = y1, y1' = y0 * y1\n            y0, y1 = y\n            return [y1, y0 * y1]\n\n        def F_c(s):\n            # Initial condition: y(0)=s, y'(0)=0\n            y0 = [s, 0.0]\n            sol = solve_ivp(ode_c, [0, 1], y0, rtol=rtol, atol=atol)\n            # F(s) = y'(1;s)\n            return sol.y[1, -1]\n\n        f_s1 = F_c(s1)\n        f_s2 = F_c(s2)\n\n        # Analytically, F(s) = 0 for all s.\n        # Check if both evaluations are numerically zero.\n        continuum_detected = (\n            abs(f_s1)  zero_tol and\n            abs(f_s2)  zero_tol\n        )\n        return continuum_detected\n\n    # Calculate results for all cases\n    result_a = solve_case_a()\n    result_b = solve_case_b()\n    result_c = solve_case_c()\n\n    # Print in the specified format [M, NR, CR]\n    print(f\"[{result_a},{result_b},{result_c}]\")\n\nsolve()\n```"
        }
    ]
}