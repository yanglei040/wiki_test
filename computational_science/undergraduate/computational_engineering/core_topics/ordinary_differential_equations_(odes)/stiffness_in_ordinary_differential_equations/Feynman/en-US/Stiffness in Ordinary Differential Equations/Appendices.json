{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the challenge of stiffness, there's no substitute for seeing a reliable numerical method struggle. This practice  demonstrates how a standard explicit adaptive solver, designed for efficiency, can be forced into taking incredibly small steps when faced with a stiff system. You will investigate how the method's performance degrades, not because of accuracy demands, but due to a fundamental stability limit imposed by disparate timescales in the problem.",
            "id": "2439135",
            "problem": "Construct a program that analyzes step-size behavior of an explicit adaptive integrator on initial value problems exhibiting stiffness. For each given initial value problem, integrate the system and record the minimal accepted time step during the integration. Use an explicit Runge–Kutta–Fehlberg method of order five with an embedded order four estimator (Runge–Kutta–Fehlberg (RKF45)) with standard absolute and relative error control. For all problems, require absolute tolerance $\\mathrm{atol} = 10^{-9}$ and relative tolerance $\\mathrm{rtol} = 10^{-6}$. Define an accepted step as one for which the embedded local error estimate satisfies a standard weighted root-mean-square criterion less than or equal to $1$. Define “extreme step-size reduction” as the occurrence of a minimal accepted time step strictly less than $10^{-4}$ over the specified integration interval.\n\nYou must evaluate the following test suite of initial value problems:\n\n- Test A (nonstiff scalar): $$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- Test B (stiff scalar, forced linear): $$y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- Test C (stiff linear two-component system): $$\\begin{aligned} y_1'(t) = -15\\,y_1(t), \\\\ y_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\nFor each test, compute the minimal accepted step size $h_{\\min}$ encountered over the integration and determine a boolean value according to whether $h_{\\min}  10^{-4}$ holds. The required final output is a single line containing a comma-separated list of these three boolean results in order $\\text{[A,B,C]}$, enclosed in square brackets. For example, an output of the form $\\text{[False,True,True]}$ indicates that extreme step-size reduction occurred for Test B and Test C but not for Test A.\n\nThere are no physical units in this problem. Angles do not appear. Percentages are not used. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, exactly in the order $\\text{[A,B,C]}$ as described above.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to construct a unique, verifiable solution. The problem lies within the domain of computational engineering and numerical analysis, specifically addressing the concept of stiffness in ordinary differential equations (ODEs).\n\nStiffness in an initial value problem arises when the solution contains components that vary on vastly different time scales. This poses a significant challenge for explicit numerical integration methods. While the rapidly decaying components (transients) may become negligible very quickly, their presence in the system's Jacobian matrix continues to impose a severe restriction on the integrator's step size to maintain numerical stability. The step size is constrained by the fastest time scale, even when accuracy considerations for the smooth, slow-varying part of the solution would permit a much larger step. This leads to computationally inefficient integrations, as the solver is forced to take an excessive number of very small steps.\n\nThe task is to demonstrate this phenomenon by analyzing the step-size behavior of an explicit adaptive integrator on three distinct ODE problems. The chosen integrator is a Runge-Kutta-Fehlberg method of order five with an embedded order-four error estimator, commonly known as RKF45. A modern, high-quality implementation of this class of method is the Dormand-Prince 5(4) pair, which is available in the `scipy` library as `scipy.integrate.solve_ivp` with `method='RK45'`. This will be the tool used for the numerical integration.\n\nThe integration process uses adaptive step-size control based on a local error estimate. At each step, an error is estimated by comparing the fifth-order solution with the embedded fourth-order one. This error, $E$, is measured using a weighted root-mean-square norm, and the step is accepted only if $E \\le 1$. The weights are functions of the specified absolute tolerance, $\\mathrm{atol} = 10^{-9}$, and relative tolerance, $\\mathrm{rtol} = 10^{-6}$. Specifically, for a solution vector $y$, the error is scaled by $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$. After an accepted step of size $h$, the next step size is chosen to keep the estimated error near the target of $1$. If the error is too large, the step is rejected and retried with a smaller $h$.\n\nWe will analyze three initial value problems and record the minimum accepted step size, $h_{\\min}$, for each. The condition for \"extreme step-size reduction\" is defined as $h_{\\min}  10^{-4}$.\n\nTest A: Nonstiff scalar problem\nThe ODE is $y'(t) = -y(t)$ with $y(0)=1$ on $t \\in [0, 10]$.\nThe system's Jacobian is simply the scalar $J = [-1]$. The only eigenvalue is $\\lambda = -1$, corresponding to a time constant of $\\tau = 1/|\\lambda| = 1$. The solution is $y(t) = e^{-t}$. There is only one time scale, and it is not particularly fast. The step size selected by the adaptive integrator will be governed primarily by the accuracy requirements defined by $\\mathrm{atol}$ and $\\mathrm{rtol}$. We do not expect stability to force the step size to be pathologically small. Therefore, it is predicted that $h_{\\min}$ will not fall below the threshold of $10^{-4}$.\n\nTest B: Stiff scalar problem\nThe ODE is $y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}$ with $y(0)=0$ on $t \\in [0, 0.1]$.\nThe Jacobian is $J = [-10000]$. The eigenvalue is $\\lambda = -10000$, corresponding to an extremely fast time constant of $\\tau = 1/|\\lambda| = 10^{-4}\\,$s. The stability region of an explicit Runge-Kutta method requires that the product of the step size $h$ and the eigenvalue $\\lambda$ lies within a bounded region in the complex plane. For real negative eigenvalues, this imposes a constraint of the form $h \\lesssim C/|\\lambda|$ for some constant $C$ of order $1$, which for this problem is $h \\lesssim C \\times 10^{-4}$. Even after the initial transient associated with this eigenvalue has decayed (which happens very quickly, within a few multiples of $10^{-4}$), this stability constraint remains in effect for the explicit integrator. Consequently, the step size will be severely limited throughout the entire integration interval. It is strongly predicted that $h_{\\min}$ will be less than $10^{-4}$.\n\nTest C: Stiff linear system\nThe system is given by:\n$$\n\\begin{aligned}\ny_1'(t) = -15\\,y_1(t) \\\\\ny_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{with} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{on} \\quad t \\in [0, 0.2].\n$$\nThe Jacobian matrix of this system is:\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15  0 \\\\ 10000  -10000 \\end{bmatrix}\n$$\nSince this matrix is lower triangular, its eigenvalues are its diagonal entries: $\\lambda_1 = -15$ and $\\lambda_2 = -10000$. These correspond to two very different time scales: a slow one $\\tau_1 = 1/15 \\approx 0.067$ and a very fast one $\\tau_2 = 1/10000 = 10^{-4}$. The ratio of the magnitudes of the eigenvalues, the stiffness ratio, is $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$, which is large and confirms the system is stiff. As with Test B, the stability of the explicit integrator is governed by the eigenvalue with the largest magnitude, $\\lambda_2 = -10000$. The step size $h$ will be constrained by the stability limit associated with this eigenvalue, forcing $h$ to remain on the order of $10^{-4}$ or smaller. Thus, it is predicted that $h_{\\min}  10^{-4}$.\n\nThe program will implement this analysis by calling `scipy.integrate.solve_ivp` for each case. The returned solution object contains an array `sol.t` of the time points at which the solution was computed. The sequence of accepted step sizes is then calculated as the successive differences in this array, `np.diff(sol.t)`. The minimum of these values is $h_{\\min}$, which is then compared against the $10^{-4}$ threshold to produce the required boolean output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t)  2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) exists, there are no steps.\n            # We can treat this as no extreme reduction, or handle as an error.\n            # For this problem's context, it indicates no steps were taken or needed,\n            # so no small steps were taken.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min  step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    # Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is not what the example output shows. The problem asks for a list\n    # of boolean values, which is commonly represented textually as true/false\n    # or True/False. We will stick to the standard Python representation.\n    # The example [False,True,True] uses capitalized boolean literals.\n    # Let's format it exactly as specified.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having witnessed the practical failure of an explicit method, we now turn to the underlying theory to understand why. This exercise  guides you through a stability analysis of a classic stiff system. By comparing the behavior of an explicit Runge-Kutta method with the implicit Backward Euler method, you will discover how their fundamentally different stability properties determine their suitability for handling equations with widely separated timescales.",
            "id": "2439060",
            "problem": "A linear time-invariant system representative of a coupled dissipative process is given by the ordinary differential equation $\\,\\mathbf{u}'(t)=\\mathbf{A}\\,\\mathbf{u}(t)\\,$ with\n$$\n\\mathbf{A}=\\begin{bmatrix}\n-1  0\\\\\n0  -900\n\\end{bmatrix},\\quad \\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}, \\quad t\\in[0,2].\n$$\nAn engineer proposes to integrate this system with a constant step size $\\,h=0.004\\,$ using either the classical fourth-order Runge–Kutta (RK4) method or the Backward Euler (BE) method. By reasoning from the definitions of linear stability for one-step methods applied to the scalar test equation $\\,y'(t)=\\lambda y(t)\\,$ and the spectral mapping of $\\,\\mathbf{A}\\,$, select all statements that are correct.\n\nA. With step size $\\,h=0.004\\,$, classical fourth-order Runge–Kutta (RK4) produces a linearly stable update for both eigenmodes of $\\,\\mathbf{A}\\,$ over $\\,t\\in[0,2]\\,$.\n\nB. With step size $\\,h=0.004\\,$, classical fourth-order Runge–Kutta (RK4) is linearly unstable for the fast eigenmode of $\\,\\mathbf{A}\\,$, so the numerical solution can grow even though the true solution decays.\n\nC. Backward Euler (BE) is linearly stable for this system for any step size $\\,h0\\,$.\n\nD. The system is stiff in the standard computational engineering sense: the explicit step size restriction is dictated by the fast mode and not by the accuracy needed to resolve the slow mode.\n\nE. Because both eigenvalues are in the open left half-plane, any consistent explicit Runge–Kutta method is unconditionally stable on this problem for any $\\,h0\\,$.",
            "solution": "The problem statement is first subjected to validation.\n\n### Step 1: Extract Givens\n- The governing ordinary differential equation (ODE) is a linear time-invariant system: $\\mathbf{u}'(t)=\\mathbf{A}\\,\\mathbf{u}(t)$.\n- The system matrix is $\\mathbf{A}=\\begin{bmatrix} -1  0\\\\ 0  -900 \\end{bmatrix}$.\n- The initial condition is $\\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}$.\n- The time domain is $t\\in[0,2]$.\n- A constant step size is proposed: $h=0.004$.\n- Two numerical integration methods are considered: the classical fourth-order Runge–Kutta (RK4) method and the Backward Euler (BE) method.\n- The analysis must be based on linear stability theory for the scalar test equation $y'(t)=\\lambda y(t)$ and the spectrum of the matrix $\\mathbf{A}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presented is a standard, well-defined initial value problem from the field of numerical analysis for ordinary differential equations.\n- **Scientifically Grounded:** The problem uses fundamental concepts of linear algebra, differential equations, and numerical stability (RK4, Backward Euler, stiffness), which are all established principles in computational science and engineering. It is a textbook example used to illustrate the concept of stiffness.\n- **Well-Posed:** The problem provides a complete specification for a linear ODE system with an initial condition, which possesses a unique, stable analytical solution. The question posed is specific and has a definite answer based on standard stability theory.\n- **Objective:** The problem statement is formulated with precise mathematical and technical language, free of ambiguity, subjectivity, or non-scientific claims.\n- **Completeness and Consistency:** All necessary information (matrix $\\mathbf{A}$, initial condition $\\mathbf{u}(0)$, time interval $t \\in [0,2]$, step size $h$, methods) is provided. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A rigorous solution and evaluation of the options may proceed.\n\n### Derivation\nThe stability of a numerical method for the system $\\mathbf{u}' = \\mathbf{A}\\mathbf{u}$ is determined by its behavior on the scalar test problems $y' = \\lambda y$, where $\\lambda$ are the eigenvalues of $\\mathbf{A}$. The matrix $\\mathbf{A}$ is diagonal, so its eigenvalues are the diagonal entries: $\\lambda_1 = -1$ and $\\lambda_2 = -900$. The exact solution to the system is $\\mathbf{u}(t) = \\begin{bmatrix}e^{\\lambda_1 t} \\\\ e^{\\lambda_2 t}\\end{bmatrix} = \\begin{bmatrix}e^{-t} \\\\ e^{-900t}\\end{bmatrix}$, given the initial condition $\\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}$. Both components of the solution decay as $t$ increases.\n\nA one-step numerical method is linearly stable if the numerical solution does not grow for a problem whose true solution decays. For the test equation $y' = \\lambda y$, the numerical update is $y_{n+1} = R(z) y_n$, where $z = h\\lambda$ and $R(z)$ is the stability function of the method. The condition for linear stability is $|R(z)| \\le 1$.\n\nThe proposed step size is $h = 0.004$. We must evaluate $z = h\\lambda$ for both eigenvalues:\n- For the \"slow\" mode associated with $\\lambda_1 = -1$: $z_1 = h \\lambda_1 = 0.004 \\times (-1) = -0.004$.\n- For the \"fast\" mode associated with $\\lambda_2 = -900$: $z_2 = h \\lambda_2 = 0.004 \\times (-900) = -3.6$.\n\nNow we analyze the methods.\n\n1.  **Classical Fourth-Order Runge–Kutta (RK4):**\n    The stability function for RK4 is the truncated Taylor series of the exponential function, $R_{\\text{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}$. The region of absolute stability, $\\{z \\in \\mathbb{C} : |R_{\\text{RK4}}(z)| \\le 1\\}$, for real negative $z$, corresponds to the interval approximately $[-2.785, 0]$.\n    - For the slow mode: $z_1 = -0.004$. This value is within the interval $[-2.785, 0]$. Thus, the method is stable for this mode.\n    - For the fast mode: $z_2 = -3.6$. This value is outside the interval $[-2.785, 0]$, as $-3.6  -2.785$. The method is unstable for this mode.\n\n2.  **Backward Euler (BE):**\n    The stability function is $R_{\\text{BE}}(z) = (1-z)^{-1}$. The region of absolute stability is $\\{z \\in \\mathbb{C} : |R_{\\text{BE}}(z)| \\le 1\\}$, which is equivalent to $\\{z \\in \\mathbb{C} : |1-z| \\ge 1\\}$. This region includes the entire open left half-plane, $\\operatorname{Re}(z)  0$. A method with this property is called A-stable.\n    - For both eigenvalues $\\lambda_1 = -1$ and $\\lambda_2 = -900$, and for any step size $h > 0$, the values $z_1 = h\\lambda_1$ and $z_2 = h\\lambda_2$ are real and negative. They always lie in the left half-plane. Therefore, Backward Euler is stable for both modes for any $h > 0$.\n\n### Option-by-Option Analysis\n\n**A. With step size $\\,h=0.004\\,$, classical fourth-order Runge–Kutta (RK4) produces a linearly stable update for both eigenmodes of $\\,\\mathbf{A}\\,$ over $\\,t\\in[0,2]\\,$.**\nAs derived above, for the fast eigenmode with $\\lambda_2 = -900$, the stability parameter is $z_2 = -3.6$. This lies outside the stability interval $[-2.785, 0]$ for the RK4 method. The update for the fast mode is therefore unstable. The statement claims stability for *both* eigenmodes, which is false.\n**Verdict: Incorrect.**\n\n**B. With step size $\\,h=0.004\\,$, classical fourth-order Runge–Kutta (RK4) is linearly unstable for the fast eigenmode of $\\,\\mathbf{A}\\,$, so the numerical solution can grow even though the true solution decays.**\nAs shown, RK4 is indeed linearly unstable for the fast mode because $z_2 = -3.6$ is outside the stability region. When a method is linearly unstable, the magnitude of the numerical solution component corresponding to that mode is amplified at each step, i.e., $|R_{\\text{RK4}}(-3.6)| > 1$. This leads to exponential growth of the error in the numerical solution, which will eventually dominate the computation, even though the true solution component $e^{-900t}$ decays rapidly to zero. This statement is a correct description of the consequences of violating a stability condition.\n**Verdict: Correct.**\n\n**C. Backward Euler (BE) is linearly stable for this system for any step size $\\,h0\\,$.**\nThe Backward Euler method is A-stable. Its region of absolute stability contains the entire left half-plane of complex numbers, $\\{z \\in \\mathbb{C} : \\operatorname{Re}(z) \\le 0\\}$. The eigenvalues of the system matrix $\\mathbf{A}$ are $\\lambda_1 = -1$ and $\\lambda_2 = -900$, both of which are in the open left half-plane. For any $h > 0$, the products $h\\lambda_1$ and $h\\lambda_2$ will also lie in the open left half-plane. Thus, they will always be inside the stability region of the Backward Euler method. The method is unconditionally stable for this problem.\n**Verdict: Correct.**\n\n**D. The system is stiff in the standard computational engineering sense: the explicit step size restriction is dictated by the fast mode and not by the accuracy needed to resolve the slow mode.**\nStiffness arises when there is a large disparity in time scales. Here, the time scales are $\\tau_1 = 1/|\\lambda_1| = 1$ s and $\\tau_2 = 1/|\\lambda_2| = 1/900 \\approx 0.0011$ s. The ratio $\\tau_1/\\tau_2 = 900 \\gg 1$. After a very short transient period (a few multiples of $\\tau_2$), the fast component $e^{-900t}$ becomes negligible, and the solution behaves like $e^{-t}$. To accurately resolve this slow behavior, a relatively large step size (e.g., $h=0.1$) would suffice. However, for an explicit method like RK4 to remain stable, the step size must satisfy $h \\le 2.785/|\\lambda_2| = 2.785/900 \\approx 0.0031$. This step size is dictated by the stability of the fast, transient mode, not the accuracy requirements of the slow, persistent mode. This is the very definition of a stiff system.\n**Verdict: Correct.**\n\n**E. Because both eigenvalues are in the open left half-plane, any consistent explicit Runge–Kutta method is unconditionally stable on this problem for any $\\,h0\\,$.**\nThis statement is fundamentally false. No explicit Runge-Kutta method can be A-stable. The stability function $R(z)$ for an explicit method is a polynomial in $z$. As $|z| \\to \\infty$, any polynomial is unbounded, so $|R(z)|$ cannot be less than or equal to $1$ for all $z$ in the left half-plane. The stability regions of explicit methods are always bounded. Consequently, for any such method and any $\\lambda  0$, there always exists a sufficiently large step size $h$ such that $h\\lambda$ falls outside the stability region. Thus, all explicit methods have a conditional stability limit on $h$ for stiff problems.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{BCD}$$"
        },
        {
            "introduction": "With a solid theoretical understanding of stability, the next logical step is to build and test a solver designed for stiff systems. In this practice , you will implement the first-order Backward Differentiation Formula (BDF1), a simple yet powerful implicit method. Through a series of carefully designed tests on the canonical stiff equation, you will empirically verify the crucial properties of A-stability and L-stability that allow this method to efficiently solve problems that are intractable for explicit solvers.",
            "id": "2439069",
            "problem": "Implement a one-step Backward Differentiation Formula method of order one for the scalar linear initial value problem defined by the canonical stiff test equation. Consider the ordinary differential equation given by $y^{\\prime}(t)=\\lambda y(t)$ with initial condition $y(0)=y_0$. Let the time grid be uniform with step size $hgt;0$, so that $t_n = n h$ for integer $n \\ge 0$, and let $N$ denote the number of steps taken so that the final time is $t_N = N h$. For each test case listed below, use the same initial value $y_0=1$ and apply the implementation to approximate the numerical solution at $t_N$. Then, evaluate the specified property for each case using the stated quantitative criterion.\n\nRequired properties to evaluate:\n- A-stability check: For a case labeled as A-stability, return a boolean that is true if the numerical solution magnitude at $t_N$ does not exceed the initial magnitude, that is, if $\\lvert y_N \\rvert \\le \\lvert y_0 \\rvert$, and false otherwise.\n- L-stability check: For a case labeled as L-stability, return a boolean that is true if a single step produces stiff decay relative to the initial value, specifically if $\\lvert y_1 \\rvert / \\lvert y_0 \\rvert \\le \\tau_L$ with tolerance $\\tau_L=10^{-6}$, and false otherwise.\n- Zero-eigenvalue boundary check: For a case labeled as zero-boundary, return a boolean that is true if the numerical solution after $N$ steps equals the initial condition within a strict tolerance $\\tau_0=10^{-12}$, that is, if $\\lvert y_N - y_0 \\rvert \\le \\tau_0$, and false otherwise.\n\nTest suite:\n- Case 1 (A-stability): $\\lambda=-2.5$, $h=4.0$, $N=5$.\n- Case 2 (A-stability, extremely stiff but large step): $\\lambda=-10^3$, $h=10^2$, $N=2$.\n- Case 3 (L-stability): $\\lambda=-10^9$, $h=10^{-2}$, $N=1$, tolerance $\\tau_L=10^{-6}$.\n- Case 4 (Zero-eigenvalue boundary): $\\lambda=0$, $h=10$, $N=3$, tolerance $\\tau_0=10^{-12}$.\n- Case 5 (Non-A-stable configuration with positive $\\lambda$): $\\lambda=0.5$, $h=3.0$, $N=5$.\n- Case 6 (A-stability near a representative boundary on the negative real axis): $\\lambda=-10^{-12}$, $h=10^{12}$, $N=4$.\n\nAll computations are to be carried out in pure numbers without physical units. Angles are not involved. Percentages must not be used.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,\\dots,result_6]$), where each entry is a boolean in the order of the test suite listed above.",
            "solution": "The problem statement is critically examined and found to be valid. It is a well-posed, scientifically grounded problem in the field of computational engineering, specifically concerning the numerical stability of methods for solving stiff ordinary differential equations. All parameters and criteria are defined with sufficient precision.\n\nThe task is to implement the one-step Backward Differentiation Formula (BDF1), also known as the Backward Euler method, for the canonical stiff test equation $y'(t) = \\lambda y(t)$ with initial condition $y(0)=y_0$. We must then evaluate certain stability properties for a given set of test cases.\n\nFirst, we derive the numerical scheme. The BDF1 method approximates the derivative $y'(t)$ at time $t_{n+1}$ using a first-order backward difference:\n$$\ny'(t_{n+1}) \\approx \\frac{y_{n+1} - y_n}{h}\n$$\nwhere $y_n$ is the numerical approximation to $y(t_n)$, and $h = t_{n+1} - t_n$ is the constant time step. For the given ordinary differential equation (ODE), $y'(t_{n+1}) = \\lambda y(t_{n+1})$. The BDF1 discretization is therefore implicit:\n$$\n\\frac{y_{n+1} - y_n}{h} = \\lambda y_{n+1}\n$$\nTo obtain a recurrence relation, we must solve for $y_{n+1}$ in terms of $y_n$:\n$$\ny_{n+1} - y_n = h \\lambda y_{n+1}\n$$\n$$\ny_{n+1} (1 - h \\lambda) = y_n\n$$\n$$\ny_{n+1} = \\frac{1}{1 - h \\lambda} y_n\n$$\nThis recurrence relation defines the numerical solution at each time step. The term $R(z) = \\frac{1}{1 - z}$ where $z = h\\lambda$ is the stability function of the method. By repeated application of this formula, the numerical solution at step $N$ can be expressed in a closed form:\n$$\ny_N = \\left( \\frac{1}{1 - h \\lambda} \\right)^N y_0\n$$\nThis single formula is sufficient to evaluate all test cases. The initial condition is given as $y_0=1$.\n\nThe problem requires checking A-stability and L-stability. A numerical method is A-stable if its region of absolute stability contains the entire left half of the complex plane, i.e., $\\{z \\in \\mathbb{C} \\mid \\operatorname{Re}(z) \\le 0 \\}$. This means that for any stable ODE (where $\\operatorname{Re}(\\lambda) \\le 0$), the numerical solution does not grow, regardless of the step size $h$. For the BDF1 method, the stability function is $R(z) = (1 - z)^{-1}$. If we let $z = x + iy$ with $x \\le 0$, the squared magnitude is:\n$$\n|R(z)|^2 = \\left| \\frac{1}{1 - (x+iy)} \\right|^2 = \\frac{1}{(1-x)^2 + y^2}\n$$\nSince $x \\le 0$, it follows that $1-x \\ge 1$, and thus $(1-x)^2 \\ge 1$. Consequently, $|R(z)|^2 \\le 1$, which confirms that $|R(z)| \\le 1$ for all $\\operatorname{Re}(z) \\le 0$. The BDF1 method is A-stable. The A-stability check, $|y_N| \\le |y_0|$, should therefore be true for all cases where $\\lambda \\le 0$.\n\nL-stability is a stronger condition requiring that, in addition to being A-stable, the stability function vanishes at infinity in the left-half plane: $\\lim_{\\operatorname{Re}(z) \\to -\\infty} |R(z)| = 0$. For BDF1, as $\\operatorname{Re}(z) \\to -\\infty$, $|1-z| \\to \\infty$, so $|R(z)| \\to 0$. The method is indeed L-stable. This property is crucial for stiff problems, where it ensures that components corresponding to very large negative eigenvalues are damped out rapidly.\n\nWe now evaluate each test case using the derived formula $y_N = (1 - h \\lambda)^{-N} y_0$ and the given criteria with $y_0 = 1$.\n\nCase 1 (A-stability): $\\lambda=-2.5$, $h=4.0$, $N=5$.\nThe product $z = h\\lambda = (4.0)(-2.5) = -10.0$.\n$y_5 = (\\frac{1}{1 - (-10.0)})^5 (1) = (\\frac{1}{11})^5$.\nThe criterion is $|y_5| \\le |y_0|$, which is $|\\frac{1}{11^5}| \\le 1$. This is true.\n\nCase 2 (A-stability): $\\lambda=-10^3$, $h=10^2$, $N=2$.\nThe product $z = h\\lambda = (10^2)(-10^3) = -10^5$.\n$y_2 = (\\frac{1}{1 - (-10^5)})^2 (1) = (\\frac{1}{100001})^2$.\nThe criterion is $|y_2| \\le |y_0|$, which is $|\\frac{1}{100001^2}| \\le 1$. This is true.\n\nCase 3 (L-stability): $\\lambda=-10^9$, $h=10^{-2}$, $N=1$, $\\tau_L=10^{-6}$.\nThe product $z = h\\lambda = (10^{-2})(-10^9) = -10^7$.\n$y_1 = (\\frac{1}{1 - (-10^7)})^1 (1) = \\frac{1}{10000001}$.\nThe criterion is $|y_1| / |y_0| \\le \\tau_L$, which is $|\\frac{1}{10000001}| \\le 10^{-6}$. This is equivalent to $\\frac{1}{10000001} \\le \\frac{1}{1000000}$, which is true.\n\nCase 4 (Zero-eigenvalue boundary): $\\lambda=0$, $h=10$, $N=3$, $\\tau_0=10^{-12}$.\nThe product $z = h\\lambda = (10)(0) = 0$.\n$y_3 = (\\frac{1}{1 - 0})^3 (1) = 1$.\nThe criterion is $|y_3 - y_0| \\le \\tau_0$, which is $|1 - 1| \\le 10^{-12}$, or $0 \\le 10^{-12}$. This is true.\n\nCase 5 (Non-A-stable configuration): $\\lambda=0.5$, $h=3.0$, $N=5$.\nThe ODE itself is unstable as $\\lambda > 0$. The A-stability-style check $|y_N| \\le |y_0|$ is expected to fail.\nThe product $z = h\\lambda = (3.0)(0.5) = 1.5$.\n$y_5 = (\\frac{1}{1 - 1.5})^5 (1) = (\\frac{1}{-0.5})^5 = (-2)^5 = -32$.\nThe criterion is $|y_5| \\le |y_0|$, which is $|-32| \\le 1$, or $32 \\le 1$. This is false.\n\nCase 6 (A-stability): $\\lambda=-10^{-12}$, $h=10^{12}$, $N=4$.\nThe product $z = h\\lambda = (10^{12})(-10^{-12}) = -1$.\n$y_4 = (\\frac{1}{1 - (-1)})^4 (1) = (\\frac{1}{2})^4 = \\frac{1}{16}$.\nThe criterion is $|y_4| \\le |y_0|$, which is $|\\frac{1}{16}| \\le 1$. This is true.\n\nThe sequence of results is: True, True, True, True, False, True.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the BDF1 method for the canonical stiff test equation\n    y'(t) = lambda * y(t) across a suite of predefined test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'lambda_val': -2.5, 'h': 4.0, 'N': 5, 'check': 'A-stability', 'tol': None},\n        {'id': 2, 'lambda_val': -1.0e3, 'h': 1.0e2, 'N': 2, 'check': 'A-stability', 'tol': None},\n        {'id': 3, 'lambda_val': -1.0e9, 'h': 1.0e-2, 'N': 1, 'check': 'L-stability', 'tol': 1.0e-6},\n        {'id': 4, 'lambda_val': 0.0, 'h': 10.0, 'N': 3, 'check': 'zero-boundary', 'tol': 1.0e-12},\n        {'id': 5, 'lambda_val': 0.5, 'h': 3.0, 'N': 5, 'check': 'A-stability', 'tol': None},\n        {'id': 6, 'lambda_val': -1.0e-12, 'h': 1.0e12, 'N': 4, 'check': 'A-stability', 'tol': None},\n    ]\n\n    results = []\n    y0 = 1.0\n\n    for case in test_cases:\n        lambda_val = case['lambda_val']\n        h = case['h']\n        N = case['N']\n        check_type = case['check']\n        tol = case['tol']\n\n        # The closed-form solution for y_N is y_0 * (1 / (1 - h*lambda))^N\n        # Let z = h*lambda, the stability function is R(z) = 1 / (1 - z)\n        # y_N = y_0 * R(z)^N\n        # Using standard Python floats (double precision) is sufficient for these values.\n        z = h * lambda_val\n        R = 1.0 / (1.0 - z)\n\n        result_bool = False\n        if check_type == 'A-stability':\n            # Check if |y_N| = |y_0|\n            y_N = (R**N) * y0\n            result_bool = np.abs(y_N) = np.abs(y0)\n        elif check_type == 'L-stability':\n            # Check if |y_1| / |y_0| = tau_L\n            # For this case N is always 1\n            y_1 = R * y0\n            # Since y0=1.0, this simplifies to checking |y_1| = tol\n            result_bool = np.abs(y_1) / np.abs(y0) = tol\n        elif check_type == 'zero-boundary':\n            # Check if |y_N - y_0| = tau_0\n            y_N = (R**N) * y0\n            result_bool = np.abs(y_N - y0) = tol\n        \n        results.append(result_bool)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a boolean in Python is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}