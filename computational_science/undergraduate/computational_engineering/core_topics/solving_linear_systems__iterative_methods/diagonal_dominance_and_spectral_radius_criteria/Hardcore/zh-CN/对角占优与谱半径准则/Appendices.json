{
    "hands_on_practices": [
        {
            "introduction": "我们知道，严格对角占优是保证雅可比（Jacobi）迭代收敛的一个充分条件，但这是否意味着非对角占优矩阵的迭代过程就一定会发散呢？这个练习通过一个巧妙的构造性问题，挑战了这一常见误解。通过探究一个非对角占优的 $2 \\times 2$ 矩阵在保证收敛的前提下，其雅可比迭代矩阵的谱半径可以达到的最小值，您将深化对收敛条件的本质理解。",
            "id": "2384207",
            "problem": "考虑一个实 $2 \\times 2$ 矩阵 $A$，其元素为 $a_{11}=a$, $a_{12}=b$, $a_{21}=c$, $a_{22}=d$，其中 $a \\neq 0$ 且 $d \\neq 0$，并假设 $A$ 是非奇异的。如果对每一行 $i$，都有 $|a_{ii}| \\geq \\sum_{j \\neq i} |a_{ij}|$ 成立，则称矩阵 $A$ 是对角占优的。如果一个矩阵不是对角占优的，则称其为非对角占优的。用于求解 $A x = f$ 的雅可比迭代由矩阵分裂 $A = D + L + U$ 定义，其中 $D = \\mathrm{diag}(a,d)$ 是 $A$ 的对角部分，$L$ 和 $U$ 分别是 $A$ 的严格下三角和严格上三角部分。雅可比迭代矩阵定义为 $B_{J} = -D^{-1}(L+U)$。矩阵 $M$ 的谱半径，记为 $\\rho(M)$，是 $M$ 的特征值的最大模。\n\n在所有满足 $a \\neq 0$、$d \\neq 0$、非对角占优且雅可比方法收敛（即 $\\rho(B_{J})  1$）的实 $2 \\times 2$ 非奇异矩阵 $A$ 中，确定 $\\rho(B_{J})$ 的最小可能值。请以精确数形式给出你的答案，不要四舍五入。",
            "solution": "所述问题定义明确且具有科学依据。我们将着手解决它。\n\n设实 $2 \\times 2$ 矩阵表示为 $A$：\n$$\nA = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}\n$$\n问题指明 $A$ 是非奇异的，且 $a \\neq 0$ 和 $d \\neq 0$。\n\n雅可比迭代法将矩阵 $A$ 分裂为其对角部分 $D$、严格下三角部分 $L$ 和严格上三角部分 $U$：$A = D + L + U$。雅可比迭代矩阵 $B_J$ 定义为 $B_J = -D^{-1}(L+U)$。计算如下：\n$$\nB_J = - \\begin{pmatrix} \\frac{1}{a}  0 \\\\ 0  \\frac{1}{d} \\end{pmatrix} \\begin{pmatrix} 0  b \\\\ c  0 \\end{pmatrix} = \\begin{pmatrix} 0  -b/a \\\\ -c/d  0 \\end{pmatrix}\n$$\n$B_J$ 的特征值 $\\lambda$ 可通过特征方程 $\\det(B_J - \\lambda I) = 0$ 求得：\n$$\n\\det \\begin{pmatrix} -\\lambda  -b/a \\\\ -c/d  -\\lambda \\end{pmatrix} = (-\\lambda)(-\\lambda) - (-b/a)(-c/d) = \\lambda^2 - \\frac{bc}{ad} = 0\n$$\n这得到 $\\lambda^2 = \\frac{bc}{ad}$，所以特征值为 $\\lambda_{1,2} = \\pm \\sqrt{\\frac{bc}{ad}}$。谱半径 $\\rho(B_J)$ 是特征值模的最大值：\n$$\n\\rho(B_J) = \\max \\left\\{ \\left| \\sqrt{\\frac{bc}{ad}} \\right|, \\left| -\\sqrt{\\frac{bc}{ad}} \\right| \\right\\} = \\left| \\sqrt{\\frac{bc}{ad}} \\right| = \\sqrt{\\left| \\frac{bc}{ad} \\right|}\n$$\n问题要求我们在满足一组条件的情况下，求出 $\\rho(B_J)$ 的最小可能值。让我们列出这些条件：\n1.  $a \\neq 0$ 且 $d \\neq 0$。\n2.  $A$ 是非奇异的：$\\det(A) = ad - bc \\neq 0$。\n3.  雅可比方法收敛：$\\rho(B_J)  1$，这意味着 $\\sqrt{|bc/ad|}  1$，或 $|bc|  |ad|$。\n4.  $A$ 是非对角占优的。如果对所有行 $i$ 都有 $|a_{ii}| \\geq \\sum_{j \\neq i} |a_{ij}|$，则矩阵是对角占优的。对于我们的 $2 \\times 2$ 矩阵，这意味着 $|a| \\geq |b|$ 且 $|d| \\geq |c|$。如果一个矩阵不是对角占优的，则称其为非对角占优，这意味着上述条件中至少有一个不满足。因此，非对角占优的条件是：\n    $$\n    (|a|  |b|) \\quad \\text{或} \\quad (|d|  |c|)\n    $$\n\n我们的目标是在所有满足这四个条件的矩阵 $A$ 的集合上找到 $\\inf\\{\\rho(B_J)\\}$。\n\n谱半径作为绝对值的最大值，总是非负的：$\\rho(B_J) \\ge 0$。因此，$\\rho(B_J)$ 的最小可能值必须大于或等于 $0$。\n\n问题归结为，对于一个满足所有给定约束条件的矩阵 $A$，$\\rho(B_J) = 0$ 这个值是否可以达到。\n从谱半径的表达式可知，$\\rho(B_J) = \\sqrt{|bc/ad|} = 0$ 当且仅当 $bc = 0$（因为 $a$ 和 $d$ 非零）。这意味着 $b=0$ 或 $c=0$。让我们检查这样的矩阵是否能满足所有必需的条件。\n\n情况1：设 $c=0$，$b$ 为任意实数。\n矩阵为 $A = \\begin{pmatrix} a  b \\\\ 0  d \\end{pmatrix}$。\n我们验证这些条件：\n1.  $a \\neq 0$, $d \\neq 0$。这是可以选择的。\n2.  非奇异性：$\\det(A) = ad - b(0) = ad$。因为 $a \\neq 0$ 且 $d \\neq 0$，所以 $\\det(A) \\neq 0$。该条件满足。\n3.  收敛性：当 $c=0$ 时，$\\rho(B_J) = \\sqrt{|b(0)/(ad)|} = 0$。由于 $0  1$，此条件满足。\n4.  非对角占优：条件是 $(|a|  |b|)$ 或 $(|d|  |0|)$。第二部分 $|d|  0$ 对于实数 $d \\neq 0$ 是不可能的。因此，我们必须满足第一部分：$|a|  |b|$。\n\n我们必须证明存在实数 $a, b, d$ 使得 $a \\neq 0$, $d \\neq 0$, 且 $|a|  |b|$。这很容易实现。例如，令 $a=1, b=2, c=0, d=1$。\n矩阵为 $A = \\begin{pmatrix} 1  2 \\\\ 0  1 \\end{pmatrix}$。我们来验证这个例子。\n- $a=1 \\neq 0$，$d=1 \\neq 0$。\n- $\\det(A) = (1)(1) - (2)(0) = 1 \\neq 0$。\n- $\\rho(B_J) = \\sqrt{|(2)(0)/((1)(1))|} = 0  1$。\n- 非对角占优，因为对于第一行，有 $|a_{11}| = |1| = 1$ 和 $|a_{12}| = |2| = 2$。由于 $1  2$，条件 $|a||b|$ 得到满足。\n\n这个矩阵满足了问题中规定的所有标准，并且对于这个矩阵，谱半径为 $0$。\n\n由于我们已经确定对于任何有效矩阵，都有 $\\rho(B_J) \\ge 0$，并且我们构造了一个有效的矩阵使其 $\\rho(B_J) = 0$，因此 $\\rho(B_J)$ 的最小可能值为 $0$。类似地，对于 $b=0$ 且 $|d||c|$ 的情况，论证同样成立。\n该下确界是一个可以达到的最小值。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "在收敛性分析中，我们常常使用迭代矩阵的范数（如无穷范数 $\\|B_J\\|_{\\infty}$）来为谱半径 $\\rho(B_J)$ 提供一个易于计算的上界。然而，这个上界的紧密程度在不同情况下差异巨大。这个数值实验将指导您构建几类特殊的矩阵，通过编码实践来亲手检验并量化谱半径与其无穷范数上界之间的差距，从而深刻体会理论界限在实践中的适用性与局限性。",
            "id": "2384241",
            "problem": "考虑使用雅可比方法求解线性系统。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个非奇异矩阵，其对角部分为 $D$，严格下三角部分为 $L$，严格上三角部分为 $U$，使得 $A = D - L - U$。雅可比迭代的形式为 $x^{(k+1)} = D^{-1}(b + (L + U)x^{(k)})$，其迭代矩阵为 $B_J = D^{-1}(L + U)$。对于给定的矩阵 $B$，谱半径 $\\rho(B)$ 定义为其特征值的最大模。导出矩阵范数的一个核心事实是，对于任何导出范数，都有 $\\rho(B) \\le \\lVert B \\rVert$，特别是 $\\rho(B_J) \\le \\lVert B_J \\rVert_\\infty$，其中 $\\lVert \\cdot \\rVert_\\infty$ 是导出无穷范数（最大绝对行和）。\n\n设计一个数值实验，以比较对于不同的矩阵 $A$，基于无穷范数的 $\\rho(B_J)$ 上界的紧致性。所有计算必须纯粹在 $\\mathbb{R}$ 中进行（不涉及物理单位）。从雅可比迭代矩阵和导出无穷范数的基本定义开始。对于每个测试用例，您必须：\n- 仅使用给定参数构造指定的矩阵 $A$。\n- 通过 $i \\ne j$ 时 $B_J(i,j) = -a_{ij}/a_{ii}$ 以及 $B_J(i,i) = 0$ 直接从 $A$ 构建 $B_J$。\n- 计算上界 $\\lVert B_J \\rVert_\\infty$（$B_J$ 的最大绝对行和）。\n- 计算谱半径 $\\rho(B_J)$（$B_J$ 特征值的最大模）。\n- 报告非负差距 $\\lVert B_J \\rVert_\\infty - \\rho(B_J)$（浮点数形式），它量化了上界的松紧程度（零表示紧致）。\n- 同时报告一个布尔值，指示该上界是否数值上是紧致的，这里定义为 $\\lVert B_J \\rVert_\\infty - \\rho(B_J) \\le 10^{-10}$。\n\n您必须实现以下矩阵 $A$ 的测试套件（每个矩阵完全由以下参数确定），这些矩阵被选择用来探究紧致性的不同行为：\n\n- 情况1（通过常数非对角结构实现精确或近似紧致）：$A \\in \\mathbb{R}^{n \\times n}$，其中对所有 $i$ 有 $a_{ii} = 1$，对所有 $i \\ne j$ 有 $a_{ij} = -s/(n-1)$。参数：$n = 5$，$s = 0.9$。\n- 情况2（对于小型三对角托普利茨矩阵是松的）：$A = d I - c T$，其中 $T$ 是一个三对角矩阵，其第一副对角线和第一超对角线上的元素为 $1$，其余元素为 $0$。参数：$n = 3$，$d = 1.0$，$c = 0.45$。\n- 情况3（通过幂零的 $B_J$ 导致极度松）：$A = I - U$，其中 $U$ 在第一超对角线上的值为常数 $t$，其余位置为零（因此 $U$ 是严格上三角矩阵）。参数：$n = 6$，$t = 0.9$。\n- 情况4（对于大型三对角托普利茨矩阵是近似紧致的）：$A = d I - c T$，其中 $T$ 的定义与情况2相同。参数：$n = 50$，$d = 1.0$，$c = 0.45$。\n\n您的程序必须：\n- 完全按照描述从其参数构建每个 $A$，不使用任何随机性。\n- 对每种情况，计算：\n  1) 上界 $\\lVert B_J \\rVert_\\infty$，\n  2) 谱半径 $\\rho(B_J)$，\n  3) 差距 $\\lVert B_J \\rVert_\\infty - \\rho(B_J)$，\n  4) 上述定义的布尔紧致性指示符。\n- 在打印前将所有浮点输出四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是一个包含上述指定顺序的四个条目的列表。例如，一个包含两个有效用例的输出应如下所示：$[[b_1,\\;r_1,\\;g_1,\\;t_1],[b_2,\\;r_2,\\;g_2,\\;t_2]]$，其中 $b_k$，$r_k$ 和 $g_k$ 是浮点数（四舍五入到六位小数），$t_k$ 是布尔值。",
            "solution": "所述问题是有效的。它基于数值线性代数的既定原理，特别是雅可比迭代法的收敛性分析。所有定义，包括雅可比迭代矩阵 $B_J$、谱半径 $\\rho(B)$ 和导出无穷范数 $\\lVert \\cdot \\rVert_\\infty$，都是标准的。该问题是自包含的，为每个测试用例提供了所有必要的参数，并提出了一个明确定义的计算任务。不存在科学上的不一致、模糊或矛盾之处。\n\n目标是进行一项数值实验，以评估界 $\\rho(B_J) \\le \\lVert B_J \\rVert_\\infty$ 的紧致性。对于每个指定的矩阵 $A$，我们必须计算迭代矩阵 $B_J$、其谱半径 $\\rho(B_J)$、无穷范数 $\\lVert B_J \\rVert_\\infty$、差距 $\\lVert B_J \\rVert_\\infty - \\rho(B_J)$ 以及数值紧致性的布尔指示符。\n\n让我们为每个测试用例进行正式的、分步的推导和实现规划。\n\n雅可比迭代矩阵 $B_J$ 定义为 $B_J = D^{-1}(L+U)$，其中 $A = D-L-U$。这里，$D$ 是 $A$ 的对角部分，$-L$ 是严格下三角部分，$-U$ 是严格上三角部分。一个等价且计算上更方便的 $B_J$ 公式是 $B_J = I - D^{-1}A$。$B_J$ 的分量由 $(B_J)_{ii} = 0$（对所有 $i$）和 $(B_J)_{ij} = -a_{ij}/a_{ii}$（对 $i \\ne j$）给出。这要求对所有 $i$ 都有 $a_{ii} \\ne 0$，这个条件在所有指定的测试用例中都成立。\n\n需要计算的量是：\n1. 无穷范数，$\\lVert B_J \\rVert_\\infty = \\max_{1 \\le i \\le n} \\sum_{j=1}^{n} |(B_J)_{ij}|$。\n2. 谱半径，$\\rho(B_J) = \\max \\{|\\lambda| : \\lambda \\text{ 是 } B_J \\text{ 的特征值}\\}$。\n3. 差距，$g = \\lVert B_J \\rVert_\\infty - \\rho(B_J)$。\n4. 紧致性布尔值，$t = (g \\le 10^{-10})$。\n\n我们现在将分析每种情况，构造所需的矩阵并计算期望的值。\n\n**情况1：常数非对角结构**\n- 参数：$n=5$，$s=0.9$。\n- 矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$ 定义为 $a_{ii} = 1$ 以及 $a_{ij} = -s/(n-1) = -0.9/4 = -0.225$（当 $i \\ne j$ 时）。\n- 雅可比矩阵 $B_J$ 的元素为 $(B_J)_{ij} = -a_{ij}/a_{ii} = -(-0.225)/1 = 0.225$（当 $i \\ne j$ 时），以及 $(B_J)_{ii} = 0$。\n- 无穷范数是最大绝对行和。对于任意行 $i$，$\\sum_{j=1}^{n} |(B_J)_{ij}| = (n-1) \\times 0.225 = 4 \\times 0.225 = 0.9$。因此，$\\lVert B_J \\rVert_\\infty = 0.9$。\n- 矩阵 $B_J$ 可以写成 $k(J-I)$，其中 $k=0.225$，$J$ 是全一矩阵，$I$ 是单位矩阵。$J$ 的特征值为 $\\{n, 0, \\dots, 0\\}$。$J-I$ 的特征值为 $\\{n-1, -1, \\dots, -1\\}$。对于 $n=5$，它们是 $\\{4, -1, -1, -1, -1\\}$。\n- $B_J$ 的特征值是这些值的 $k$ 倍：$\\{0.225 \\times 4, 0.225 \\times (-1), \\dots\\} = \\{0.9, -0.225, -0.225, -0.225, -0.225\\}$。\n- 谱半径为 $\\rho(B_J) = \\max(|0.9|, |-0.225|) = 0.9$。\n- 差距为 $\\lVert B_J \\rVert_\\infty - \\rho(B_J) = 0.9 - 0.9 = 0$。该界是精确紧致的。\n\n**情况2：小型三对角托普利茨矩阵**\n- 参数：$n=3$，$d=1.0$，$c=0.45$。\n- 矩阵 $A = dI - cT$，其中 $T$ 的第一副对角线和第一超对角线上为 $1$。\n$$A = \\begin{pmatrix} 1.0  -0.45  0 \\\\ -0.45  1.0  -0.45 \\\\ 0  -0.45  1.0 \\end{pmatrix}$$\n- 由于 $a_{ii} = d = 1.0$，雅可比矩阵为 $B_J = cT$。\n$$B_J = \\begin{pmatrix} 0  0.45  0 \\\\ 0.45  0  0.45 \\\\ 0  0.45  0 \\end{pmatrix}$$\n- 绝对行和为 $\\{0.45, 0.9, 0.45\\}$。最大值为 $\\lVert B_J \\rVert_\\infty = 0.9$。\n- 这样一个 $n \\times n$ 的三对角矩阵 $T$ 的特征值为 $\\lambda_k = 2\\cos(\\frac{k\\pi}{n+1})$，对于 $k=1, \\dots, n$。\n- 对于 $n=3$，$T$ 的特征值为 $2\\cos(\\pi/4) = \\sqrt{2}$，$2\\cos(2\\pi/4) = 0$ 和 $2\\cos(3\\pi/4) = -\\sqrt{2}$。\n- $B_J = cT$ 的特征值为 $\\{0.45\\sqrt{2}, 0, -0.45\\sqrt{2}\\}$。\n- 谱半径为 $\\rho(B_J) = |0.45\\sqrt{2}| \\approx 0.636396$。\n- 差距为 $0.9 - 0.636396... \\approx 0.263604$。该界不是紧致的。\n\n**情况3：幂零雅可比矩阵**\n- 参数：$n=6$，$t=0.9$。\n- 矩阵 $A = I - U$，其中 $U$ 是一个在第一超对角线上为 $t=0.9$、其余位置为零的矩阵。\n$$A = \\begin{pmatrix} 1  -0.9  0  0  0  0 \\\\ 0  1  -0.9  0  0  0 \\\\ 0  0  1  -0.9  0  0 \\\\ 0  0  0  1  -0.9  0 \\\\ 0  0  0  0  1  -0.9 \\\\ 0  0  0  0  0  1 \\end{pmatrix}$$\n- 对角线元素为 $a_{ii}=1$。雅可比矩阵为 $B_J = I - D^{-1}A = I - I^{-1}(I - U) = U$。\n- 因此，$B_J$ 的第一超对角线上为 $0.9$，其余位置为零。\n- 绝对行和为 $\\{0.9, 0.9, 0.9, 0.9, 0.9, 0\\}$。最大值为 $\\lVert B_J \\rVert_\\infty = 0.9$。\n- $B_J$ 是一个严格上三角矩阵。它的特征值是其对角线元素，均为 $0$。\n- 谱半径为 $\\rho(B_J) = 0$。\n- 差距为 $0.9 - 0 = 0.9$。该界极度松。\n\n**情况4：大型三对角托普利茨矩阵**\n- 参数：$n=50$，$d=1.0$，$c=0.45$。\n- 设置与情况2相同，但 $n=50$。$A = dI - cT$ 且 $B_J = cT$。\n- 绝对行和为 $\\{c, 2c, \\dots, 2c, c\\}$。当 $c=0.45$ 时，和为 $\\{0.45, 0.9, \\dots, 0.9, 0.45\\}$。最大值为 $\\lVert B_J \\rVert_\\infty = 2c = 0.9$。\n- $B_J$ 的特征值为 $\\lambda_k = 2c\\cos(\\frac{k\\pi}{n+1})$，对于 $k=1, \\dots, n$。\n- 我们有 $n=50$，所以特征值为 $0.9\\cos(\\frac{k\\pi}{51})$，对于 $k=1, \\dots, 50$。\n- 谱半径为 $\\rho(B_J) = \\max_{k} |0.9\\cos(\\frac{k\\pi}{51})| = 0.9\\cos(\\frac{\\pi}{51})$。\n- 当 $n$ 变大时，$\\frac{\\pi}{n+1} \\to 0$ 且 $\\cos(\\frac{\\pi}{n+1}) \\to 1$。因此，$\\rho(B_J)$ 接近 $\\lVert B_J \\rVert_\\infty$。\n- $\\rho(B_J) = 0.9 \\times \\cos(\\pi/51) \\approx 0.9 \\times 0.998108 \\approx 0.898297$。\n- 差距为 $0.9 - 0.898297... \\approx 0.001703$。该界是近似紧致的，但不满足 $g \\le 10^{-10}$ 的严格标准。\n\n实现将对每种情况遵循这些步骤，使用数值库来构造矩阵和计算特征值。最终结果将按规定格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to compare the tightness of the\n    infinity-norm-based upper bound on the spectral radius of the Jacobi\n    iteration matrix for several test cases.\n    \"\"\"\n\n    test_cases_params = [\n        # Case 1: n=5, s=0.9\n        {'type': 'constant_off_diagonal', 'n': 5, 's': 0.9},\n        # Case 2: n=3, d=1.0, c=0.45\n        {'type': 'tridiagonal', 'n': 3, 'd': 1.0, 'c': 0.45},\n        # Case 3: n=6, t=0.9\n        {'type': 'nilpotent_b_j', 'n': 6, 't': 0.9},\n        # Case 4: n=50, d=1.0, c=0.45\n        {'type': 'tridiagonal', 'n': 50, 'd': 1.0, 'c': 0.45},\n    ]\n\n    all_results = []\n\n    for params in test_cases_params:\n        # Construct matrix A based on the case type and parameters\n        n = params['n']\n        if params['type'] == 'constant_off_diagonal':\n            s = params['s']\n            A = np.full((n, n), -s / (n - 1))\n            np.fill_diagonal(A, 1.0)\n        elif params['type'] == 'tridiagonal':\n            d = params['d']\n            c = params['c']\n            T = np.diag(np.ones(n - 1), k=1) + np.diag(np.ones(n - 1), k=-1)\n            A = d * np.eye(n) - c * T\n        elif params['type'] == 'nilpotent_b_j':\n            t = params['t']\n            U = np.diag(np.full(n - 1, t), k=1)\n            A = np.eye(n) - U\n        else:\n            raise ValueError(\"Unknown test case type\")\n\n        # Construct the Jacobi iteration matrix B_J\n        # B_J = I - D^{-1}A\n        diag_A = np.diag(A)\n        if np.any(diag_A == 0):\n            # This case should not be reached with the given problems.\n            raise ValueError(\"Matrix A has zero on the diagonal, D is not invertible.\")\n        \n        D_inv = np.diag(1.0 / diag_A)\n        B_J = np.eye(n) - D_inv @ A\n\n        # 1. Compute the infinity norm of B_J (the bound)\n        bound = np.linalg.norm(B_J, ord=np.inf)\n\n        # 2. Compute the spectral radius of B_J\n        eigenvalues = np.linalg.eigvals(B_J)\n        spectral_radius = np.max(np.abs(eigenvalues))\n\n        # 3. Compute the gap\n        gap = bound - spectral_radius\n\n        # 4. Determine if the bound is numerically tight\n        is_tight = gap = 1e-10\n\n        all_results.append([bound, spectral_radius, gap, is_tight])\n\n    # Format the final output string as specified\n    formatted_cases = []\n    for res in all_results:\n        b, r, g, t = res\n        # Format floats to 6 decimal places and boolean to string\n        case_str = f\"[{b:.6f},{r:.6f},{g:.6f},{str(t)}]\"\n        formatted_cases.append(case_str)\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "既然我们知道对角占优有利于迭代法的收敛，一个自然的想法是：对于一个不满足此条件的线性系统，我们能否通过重新排列方程的顺序来改善其性质？这个高级练习将引导您实现一个“动态”高斯-赛德尔（Gauss-Seidel）求解器，它在每次迭代前通过行重排来最大化对角元素，并与基准求解器进行性能对比。通过这个实践，您不仅能掌握一种提高迭代法鲁棒性的实用技巧，还能深入理解矩阵重排、谱半径和收敛速度之间的内在联系。",
            "id": "2384203",
            "problem": "给定形式为 $A x = b$ 的方形线性系统，其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $b \\in \\mathbb{R}^{n}$。考虑严格对角占优性质以及定常迭代收敛的谱半径判据。如果对于每个行索引 $i \\in \\{1,\\dots,n\\}$，矩阵 $A$ 满足以下条件，则称其为严格对角占优 (strictly diagonally dominant, SDD)：\n$$\n|a_{i i}| \\gt \\sum_{j \\ne i} |a_{i j}|.\n$$\n设 Gauss–Seidel 方法通过分裂 $A = D - L - U$ 来定义，其中 $D$ 是 $A$ 的对角部分，$L$ 是 $-A$ 的严格下三角部分，$U$ 是 $-A$ 的严格上三角部分。其迭代矩阵为\n$$\nT_{\\mathrm{GS}} = (D - L)^{-1} U,\n$$\n谱半径判据要求\n$$\n\\rho(T_{\\mathrm{GS}}) \\lt 1\n$$\n以确保收敛，其中 $\\rho(\\cdot)$ 表示谱半径。对于一个行置换矩阵 $P \\in \\mathbb{R}^{n \\times n}$，置换后的系统为 $P A x = P b$。\n\n您的任务是为 $A x = b$ 实现两个求解器：\n\n- 一个基准 Gauss–Seidel 求解器，使用 $A$ 的自然行序。\n\n- 一个动态行重排的 Gauss–Seidel 求解器，在每次扫描（sweep） $k \\in \\{0,1,2,\\dots\\}$ 开始时，选择一个行置换 $P_k$，以最大化置换后对角线元素的绝对值之和，即\n$$\nP_k \\in \\arg \\max_{P \\in \\mathcal{P}} \\sum_{i=1}^{n} \\left| (P A)_{i i} \\right|,\n$$\n其中 $\\mathcal{P}$ 是所有 $n \\times n$ 置换矩阵的集合。然后对 $P_k A x = P_k b$ 执行扫描。\n\n对于每个测试用例，请在您的程序中完成以下所有操作：\n\n1. 使用零向量 $x^{(0)} = 0$ 进行初始化。使用欧几里得范数计算残差。当 $\\lVert A x^{(k)} - b \\rVert_2 \\le \\tau$（容差 $\\tau = 10^{-8}$）或扫描次数达到 $N_{\\max} = 1000$ 时终止。将收敛性报告为布尔值，并附上所用的扫描次数。如果在基准求解器中，由于活动方程组中的对角元素为零而导致任何除以零的运算，则声明基准求解器不收敛，并将扫描次数报告为 $-1$。\n\n2. 使用以下公式计算基准系统（未置换）的 $T_{\\mathrm{GS}}$ 的谱半径 $\\rho_{\\text{base}}$：\n$$\nT_{\\mathrm{GS}} = (D - L)^{-1} U.\n$$\n如果 $(D - L)$ 是奇异的或需要进行任何除以零的运算，则设 $\\rho_{\\text{base}} = -1.0$。\n\n3. 计算一个最佳置换 $P^\\star$，该置换最大化 $\\sum_{i=1}^{n} |(P A)_{i i}|$（与动态方法中使用的优化相同）。使用 $P^\\star A$ 计算\n$$\n\\rho_{\\text{best}} = \\rho\\!\\left( (D^\\star - L^\\star)^{-1} U^\\star \\right),\n$$\n其中 $D^\\star$、$L^\\star$ 和 $U^\\star$ 的定义类似于从 $A$ 定义 $D$、$L$ 和 $U$。如果 $(D^\\star - L^\\star)$ 是奇异的，则设 $\\rho_{\\text{best}} = -1.0$。\n\n4. 计算最佳置换前后的最小对角占优比：\n$$\n\\delta_{\\min}(A) = \\min_{1 \\le i \\le n} \\frac{|a_{i i}|}{\\sum_{j \\ne i} |a_{i j}|}, \\quad\n\\delta_{\\min}(P^\\star A) = \\min_{1 \\le i \\le n} \\frac{|(P^\\star A)_{i i}|}{\\sum_{j \\ne i} |(P^\\star A)_{i j}|}.\n$$\n使用约定：如果分母为 $0$ 且分子非零，则比率为 $+\\infty$；如果分子为 $0$ 且分母为正，则比率为 $0$。如果分子和分母均为 $0$，则将比率视为 $+\\infty$。\n\n为以下系统 $(A, b)$ 的测试套件提供结果：\n\n- 测试用例 1 ($n=3$)：\n$$\nA_1 = \\begin{bmatrix}\n4  -1  0 \\\\\n-1  4  -1 \\\\\n0  -1  3\n\\end{bmatrix}, \\quad\nb_1 = \\begin{bmatrix}\n15 \\\\ 10 \\\\ 10\n\\end{bmatrix}.\n$$\n\n- 测试用例 2 ($n=3$)：\n$$\nA_2 = \\begin{bmatrix}\n0  2  1 \\\\\n3  0  1 \\\\\n1  1  4\n\\end{bmatrix}, \\quad\nb_2 = \\begin{bmatrix}\n3 \\\\ 4 \\\\ 5\n\\end{bmatrix}.\n$$\n\n- 测试用例 3 ($n=3$)：\n$$\nA_3 = \\begin{bmatrix}\n2  -1  1 \\\\\n-1  2  -1 \\\\\n1  -1  2\n\\end{bmatrix}, \\quad\nb_3 = \\begin{bmatrix}\n1 \\\\ 0 \\\\ 1\n\\end{bmatrix}.\n$$\n\n- 测试用例 4 ($n=4$)：\n$$\nA_4 = \\begin{bmatrix}\n1  3  0  0 \\\\\n2  0  2  0 \\\\\n0  2  0  3 \\\\\n0  0  4  0\n\\end{bmatrix}, \\quad\nb_4 = \\begin{bmatrix}\n1 \\\\ 2 \\\\ 3 \\\\ 4\n\\end{bmatrix}.\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，每个测试用例的结果本身是一个包含以下八个条目的列表，顺序如下：\n$[$ $\\text{iters\\_base}$, $\\text{iters\\_dyn}$, $\\text{conv\\_base}$, $\\text{conv\\_dyn}$, $\\rho_{\\text{base}}$, $\\rho_{\\text{best}}$, $\\delta_{\\min}(A)$, $\\delta_{\\min}(P^\\star A)$ $]$.\n\n此处 $\\text{iters\\_base}$ 和 $\\text{iters\\_dyn}$ 是整数（如果在 $N_{\\max}$ 内未收敛，则使用 $-1$），$\\text{conv\\_base}$ 和 $\\text{conv\\_dyn}$ 是布尔值，其余量是浮点数。您的程序应严格按照以下格式打印一行：\n$$\n\\big[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} \\big],\n$$\n即，一个单独的 Python 风格的列表字面量，其中包含按上述测试用例相同顺序排列的、以逗号分隔的内部列表。",
            "solution": "所提出的问题是计算工程领域，特别是数值线性代数领域中一个定义明确且具有科学依据的练习。它要求实现和比较用于求解线性方程组 $A x = b$ 的 Gauss-Seidel 迭代法的两种变体。该问题是有效的，因为它基于已建立的数学原理，提供了所有必要的数据和约束，并要求一个客观、可验证的结果。\n\n核心任务围绕定常迭代法展开。对于线性系统 $A x = b$，我们将矩阵 $A$ 分解为 $A = M - N$，其中 $M$ 是一个易于求逆的矩阵。然后迭代定义为 $M x^{(k+1)} = N x^{(k)} + b$。为了收敛，迭代矩阵 $T = M^{-1} N$ 的谱半径必须小于 1，即 $\\rho(T)  1$。\n\nGauss-Seidel 方法是该框架的一个具体实例。矩阵 $A$ 被分裂为其对角部分 $D$、严格下三角部分 $-L$ 和严格上三角部分 $-U$，使得 $A = D - L - U$。该方法通过选择 $M = D - L$ 和 $N = U$ 来定义。因此，迭代过程为：\n$$\n(D - L) x^{(k+1)} = U x^{(k)} + b.\n$$\n迭代矩阵是 $T_{\\mathrm{GS}} = (D - L)^{-1} U$。Gauss-Seidel 方法收敛的一个充分但不必要条件是矩阵 $A$ 是严格对角占优 (SDD) 的。如果对于每一行 $i$，对角元素的绝对值大于该行所有其他元素的绝对值之和，则矩阵 $A$ 是 SDD 的：\n$$\n|a_{ii}|  \\sum_{j \\neq i} |a_{ij}|.\n$$\n此条件确保 $\\rho(T_{\\mathrm{GS}})  1$。\n\n问题要求实现两个求解器和几项分析：\n\n1.  **基准 Gauss-Seidel 求解器**：该求解器将方法直接应用于给定的系统 $A x = b$。在一次扫描中，每个分量 $x_i$ 的更新如下：\n    $$\n    x_i^{(k+1)} = \\frac{1}{a_{ii}} \\left( b_i - \\sum_{j  i} a_{ij}x_j^{(k+1)} - \\sum_{j > i} a_{ij}x_j^{(k)} \\right).\n    $$\n    此方法要求所有对角元素 $a_{ii}$ 非零。如果任何 $a_{ii}=0$，则该方法失败。\n\n2.  **动态行重排 Gauss-Seidel 求解器**：该变体试图通过在每次迭代开始时重新排列方程（行）来增强收敛性。其目标是找到一个置换矩阵 $P_k$，使得置换后的矩阵 $P_k A$ 的对角线元素绝对值之和最大化。这是一个经典的**分配问题**，可以通过匈牙利算法或类似的线性规划方法高效解决。在找到最佳置换 $P_k$ 后，对置换后的系统 $P_k A x = P_k b$ 执行一次标准的 Gauss-Seidel 扫描。这个过程在每次迭代中重复。\n\n3.  **谱半径计算**：对于基准系统和最优一次性置换后的系统，需要计算各自的 Gauss-Seidel 迭代矩阵 $T_{\\mathrm{GS}} = (D - L)^{-1} U$ 的谱半径。这通常通过数值方法计算 $(D-L)^{-1}U$ 的特征值并取其最大模来实现。\n\n4.  **对角占优比**：为了量化矩阵的对角占优程度，问题要求计算最小对角占优比 $\\delta_{\\min}$。$\\delta_{\\min}(A) > 1$ 是矩阵 $A$ 严格对角占优的另一种表述。比较原始矩阵和最优置换后矩阵的该比值，可以直观地看到行重排对改善对角占优性的效果。\n\n该问题的实现将涉及数值迭代、矩阵操作、求解分配问题以及特征值计算，从而全面地检验对迭代法理论和实践的理解。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    TOL = 1e-8\n    N_MAX = 1000\n\n    def find_best_permutation(A):\n        \"\"\"Finds the row permutation that maximizes the sum of absolute diagonal entries.\"\"\"\n        n = A.shape[0]\n        # Cost matrix where C[i, j] is the cost of assigning original row j to new row i.\n        # We want to maximize sum(|A_p(i),i|), which is equivalent to minimizing sum(-|A_p(i),i|).\n        # The cost of placing original row j at the new row position i (contributing to new diagonal A'_{ii})\n        # is -|A_{j, i}|.\n        cost_matrix = -np.abs(A.T)\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        # col_ind[i] is the original row index that should be moved to new row i.\n        return col_ind\n\n    def calculate_spectral_radius(A):\n        \"\"\"Computes the spectral radius of the Gauss-Seidel iteration matrix for A.\"\"\"\n        n = A.shape[0]\n        # Check for singularity of D-L, which occurs if any diagonal element is zero.\n        if np.any(np.diag(A) == 0):\n            return -1.0\n        \n        D = np.diag(np.diag(A))\n        L = -np.tril(A, -1)\n        U = -np.triu(A, 1)\n        \n        try:\n            # Solve (D-L)T = U for T = T_GS using forward substitution\n            T_gs = solve_triangular(D - L, U, lower=True)\n            eigenvalues = np.linalg.eigvals(T_gs)\n            return np.max(np.abs(eigenvalues))\n        except np.linalg.LinAlgError:\n            # This case can happen if D-L is numerically singular\n            return -1.0\n\n    def calculate_delta_min(A):\n        \"\"\"Computes the minimum diagonal dominance ratio for A.\"\"\"\n        n = A.shape[0]\n        ratios = []\n        for i in range(n):\n            diag_val = np.abs(A[i, i])\n            off_diag_sum = np.sum(np.abs(A[i, :])) - diag_val\n            if off_diag_sum == 0:\n                if diag_val == 0:\n                    ratios.append(np.inf) # convention from problem\n                else:\n                    ratios.append(np.inf)\n            else:\n                ratios.append(diag_val / off_diag_sum)\n        return np.min(ratios)\n\n    def baseline_gs_solver(A, b):\n        \"\"\"Baseline Gauss-Seidel solver.\"\"\"\n        n = A.shape[0]\n        x = np.zeros(n)\n        \n        if np.any(np.diag(A) == 0):\n            return -1, False\n\n        for k in range(N_MAX):\n            x_old = x.copy()\n            for i in range(n):\n                sigma = np.dot(A[i, :i], x[:i]) + np.dot(A[i, i+1:], x_old[i+1:])\n                x[i] = (b[i] - sigma) / A[i, i]\n            \n            if np.linalg.norm(A @ x - b) = TOL:\n                return k + 1, True\n        \n        return -1, False\n\n    def dynamic_gs_solver(A, b):\n        \"\"\"Dynamic row-reordered Gauss-Seidel solver.\"\"\"\n        n = A.shape[0]\n        x = np.zeros(n)\n\n        # The optimal permutation is constant since A is constant.\n        # However, the problem states to select it \"at the start of each sweep\".\n        for k in range(N_MAX):\n            perm = find_best_permutation(A)\n            A_k = A[perm, :]\n            b_k = b[perm]\n\n            if np.any(np.diag(A_k) == 0):\n                return -1, False\n            \n            x_old = x.copy()\n            for i in range(n):\n                sigma = np.dot(A_k[i, :i], x[:i]) + np.dot(A_k[i, i+1:], x_old[i+1:])\n                x[i] = (b_k[i] - sigma) / A_k[i, i]\n            \n            if np.linalg.norm(A @ x - b) = TOL:\n                return k + 1, True\n                \n        return -1, False\n\n    def process_case(A, b):\n        \"\"\"Process a single test case (A, b).\"\"\"\n        # Solvers\n        iters_base, conv_base = baseline_gs_solver(A, b)\n        iters_dyn, conv_dyn = dynamic_gs_solver(A, b)\n        \n        # Spectral radius for baseline system\n        rho_base = calculate_spectral_radius(A)\n        \n        # Best permutation and related metrics\n        p_star = find_best_permutation(A)\n        A_best = A[p_star, :]\n        rho_best = calculate_spectral_radius(A_best)\n        \n        # Diagonal dominance ratios\n        delta_min_A = calculate_delta_min(A)\n        delta_min_A_best = calculate_delta_min(A_best)\n        \n        return [\n            iters_base, iters_dyn,\n            conv_base, conv_dyn,\n            rho_base, rho_best,\n            delta_min_A, delta_min_A_best\n        ]\n\n    test_cases = [\n        (np.array([[4., -1., 0.], [-1., 4., -1.], [0., -1., 3.]]), \n         np.array([15., 10., 10.])),\n        (np.array([[0., 2., 1.], [3., 0., 1.], [1., 1., 4.]]), \n         np.array([3., 4., 5.])),\n        (np.array([[2., -1., 1.], [-1., 2., -1.], [1., -1., 2.]]), \n         np.array([1., 0., 1.])),\n        (np.array([[1., 3., 0., 0.], [2., 0., 2., 0.], [0., 2., 0., 3.], [0., 0., 4., 0.]]), \n         np.array([1., 2., 3., 4.]))\n    ]\n\n    results = [process_case(A, b) for A, b in test_cases]\n    \n    # Format the final output string as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}