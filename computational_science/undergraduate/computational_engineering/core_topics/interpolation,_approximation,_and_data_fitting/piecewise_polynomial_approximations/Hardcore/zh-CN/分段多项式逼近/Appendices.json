{
    "hands_on_practices": [
        {
            "introduction": "B样条是许多高级建模技术（如非均匀有理B样条(NURBS)）的基本构件。本练习将通过指导您使用核心的Cox–de Boor递归公式，从零开始手动构建一个二次B样条基函数，从而揭开其神秘面纱。这种动手计算将加强您对节点向量如何直接决定样条形状的理解。",
            "id": "2424168",
            "problem": "在计算工程中，基样条（B样条）提供了具有紧支集和可控连续性的稳健分段多项式逼近。考虑开放、非均匀节点向量 $t = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}$ 和二次次数 $p = 2$。从零次B样条基函数的基本定义和 Cox–de Boor 递推公式出发，手动推导与此节点向量相关的二次B样条基函数 $N_{3,2}(x)$ 的显式分段多项式表达式。使用标准约定，即如果递推式中的分母为零，则相应项为零，并将特征区间取为 $[a,b)$ 形式的半开区间。将最终结果表示为关于 $x$ 的单个分段定义的解析表达式。不需要数值舍入，也不涉及单位。最终答案必须仅为闭式表达式。",
            "solution": "在尝试任何解答之前，所提出的问题都经过了严格的验证。\n\n### 步骤 1：提取已知条件\n-   **领域**：计算工程\n-   **主题**：分段多项式逼近，B样条\n-   **节点向量**：$t = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}$\n-   **次数**：$p = 2$（二次）\n-   **目标基函数**：$N_{3,2}(x)$\n-   **方法**：Cox–de Boor 递推，从零次基函数开始。\n-   **约定 1**：若递推公式中分母为零，则相应项为零。\n-   **约定 2**：特征区间为半开区间 $[a,b)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是B样条理论中的一个标准、基础练习，B样条是数值分析和计算机辅助几何设计中的核心主题。所有概念，包括节点向量、次数和 Cox-de Boor 递推，都是公认的。该问题在科学上是合理的。\n2.  **适定性**：该问题描述精确。节点向量、多项式次数和目标基函数都已明确给出。处理零分母和区间形式的约定消除了计算中的任何潜在歧义。存在一个唯一、稳定且有意义的分段多项式解，并且可以推导得出。\n3.  **客观性**：语言清晰、精确且完全客观。它陈述了一个数学任务，不包含主观或推测性内容。\n\n### 步骤 3：结论与行动\n该问题被确定为**有效**。它自洽、有科学依据且适定。将推导解答。\n\n### 推导\nB样条基函数 $N_{i,p}(x)$ 的推导遵循 Cox-de Boor 递推公式。我们从零次基函数 $N_{i,0}(x)$ 的定义开始：\n$$\nN_{i,0}(x) =\n\\begin{cases}\n1  \\text{if } t_i \\le x  t_{i+1} \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n对于次数 $p > 0$，高次基函数被递归定义为：\n$$\nN_{i,p}(x) = \\frac{x - t_i}{t_{i+p} - t_i} N_{i, p-1}(x) + \\frac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}} N_{i+1, p-1}(x)\n$$\n给定的约定指出，任何分母为零的项都取为零。\n\n问题指定的节点向量 $t = \\{t_0, t_1, \\dots, t_8\\}$ 为：\n$$\nt = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}\n$$\n次数为 $p=2$。我们需要求出基函数 $N_{3,2}(x)$ 的表达式。\n\n首先，我们确定 $N_{3,2}(x)$ 的支集。B样条基函数 $N_{i,p}(x)$ 的支集是区间 $[t_i, t_{i+p+1})$。对于 $N_{3,2}(x)$，这对应于区间 $[t_3, t_{3+2+1}) = [t_3, t_6)$。根据节点向量，$t_3=1$ 且 $t_6=4$。因此，$N_{3,2}(x)$ 仅在 $x \\in [1, 4)$ 时非零。\n\n我们应用递推公式来求解 $N_{3,2}(x)$：\n$$\nN_{3,2}(x) = \\frac{x - t_3}{t_{3+2} - t_3} N_{3,1}(x) + \\frac{t_{3+2+1} - x}{t_{3+2+1} - t_{3+1}} N_{4,1}(x) = \\frac{x - t_3}{t_5 - t_3} N_{3,1}(x) + \\frac{t_6 - x}{t_6 - t_4} N_{4,1}(x)\n$$\n代入节点值 $t_3=1, t_4=3, t_5=3$ 和 $t_6=4$：\n$$\nN_{3,2}(x) = \\frac{x - 1}{3 - 1} N_{3,1}(x) + \\frac{4 - x}{4 - 3} N_{4,1}(x) = \\frac{x - 1}{2} N_{3,1}(x) + (4 - x) N_{4,1}(x)\n$$\n接下来，我们必须求出线性基函数 $N_{3,1}(x)$ 和 $N_{4,1}(x)$ 的表达式。\n\n对于 $N_{3,1}(x)$，递推式为：\n$$\nN_{3,1}(x) = \\frac{x - t_3}{t_{3+1} - t_3} N_{3,0}(x) + \\frac{t_{3+1+1} - x}{t_{3+1+1} - t_{3+1}} N_{4,0}(x) = \\frac{x - t_3}{t_4 - t_3} N_{3,0}(x) + \\frac{t_5 - x}{t_5 - t_4} N_{4,0}(x)\n$$\n代入节点值 $t_3=1, t_4=3, t_5=3$：\n$$\nN_{3,1}(x) = \\frac{x - 1}{3 - 1} N_{3,0}(x) + \\frac{3 - x}{3 - 3} N_{4,0}(x)\n$$\n分母 $t_5 - t_4$ 为零，所以第二项为零。\n$$\nN_{3,1}(x) = \\frac{x - 1}{2} N_{3,0}(x)\n$$\n$N_{3,0}(x)$ 的支集是 $[t_3, t_4) = [1, 3)$，在此区间上其值为 $1$。因此，$N_{3,1}(x)$ 为：\n$$\nN_{3,1}(x) = \\begin{cases} \\frac{x-1}{2}  \\text{if } 1 \\le x  3 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n对于 $N_{4,1}(x)$，递推式为：\n$$\nN_{4,1}(x) = \\frac{x - t_4}{t_{4+1} - t_4} N_{4,0}(x) + \\frac{t_{4+1+1} - x}{t_{4+1+1} - t_{4+1}} N_{5,0}(x) = \\frac{x - t_4}{t_5 - t_4} N_{4,0}(x) + \\frac{t_6 - x}{t_6 - t_5} N_{5,0}(x)\n$$\n代入节点值 $t_4=3, t_5=3, t_6=4$：\n$$\nN_{4,1}(x) = \\frac{x - 3}{3 - 3} N_{4,0}(x) + \\frac{4 - x}{4 - 3} N_{5,0}(x)\n$$\n分母 $t_5 - t_4$ 为零，所以第一项为零。\n$$\nN_{4,1}(x) = \\frac{4 - x}{1} N_{5,0}(x) = (4 - x) N_{5,0}(x)\n$$\n$N_{5,0}(x)$ 的支集是 $[t_5, t_6) = [3, 4)$，在此区间上其值为 $1$。因此，$N_{4,1}(x)$ 为：\n$$\nN_{4,1}(x) = \\begin{cases} 4 - x  \\text{if } 3 \\le x  4 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n现在，我们将 $N_{3,1}(x)$ 和 $N_{4,1}(x)$ 的这些分段表达式代入 $N_{3,2}(x)$ 的方程中。我们考虑其支集 $[1, 4)$ 上的各个区间。\n\n情况 1：$x \\in [1, 3)$\n在此区间内，$N_{3,1}(x) = \\frac{x-1}{2}$ 且 $N_{4,1}(x) = 0$。\n$$\nN_{3,2}(x) = \\frac{x - 1}{2} \\left( \\frac{x-1}{2} \\right) + (4 - x)(0) = \\frac{(x-1)^2}{4}\n$$\n\n情况 2：$x \\in [3, 4)$\n在此区间内，$N_{3,1}(x) = 0$ 且 $N_{4,1}(x) = 4-x$。\n$$\nN_{3,2}(x) = \\frac{x-1}{2}(0) + (4 - x)(4 - x) = (4-x)^2\n$$\n\n综合这些结果，我们得到 $N_{3,2}(x)$ 的完整分段定义表达式：\n$$\nN_{3,2}(x) =\n\\begin{cases}\n\\frac{(x-1)^2}{4}  \\text{if } 1 \\leq x  3 \\\\\n(4-x)^2  \\text{if } 3 \\leq x  4 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n该函数的支集为 $[1,4)$。在节点 $x=3$ 处，其重复度为 $k=2$，连续性为 $C^{p-k} = C^{2-2} = C^0$。我们验证如下：\n$\\lim_{x \\to 3^-} N_{3,2}(x) = \\frac{(3-1)^2}{4} = 1$。\n$N_{3,2}(3) = (4-3)^2 = 1$。\n该函数是连续的，符合要求。",
            "answer": "$$\n\\boxed{\nN_{3,2}(x) = \n\\begin{cases}\n\\frac{(x-1)^{2}}{4}  \\text{if } 1 \\le x  3 \\\\\n(4-x)^{2}  \\text{if } 3 \\le x  4 \\\\\n0  \\text{otherwise}\n\\end{cases}\n}\n$$"
        },
        {
            "introduction": "从抽象的基函数转向具体的应用，分段多项式在计算机辅助设计（CAD）中对于表示复杂曲线至关重要。本实践涉及一项常见任务：使用分段三次Hermite曲线来近似一个完美的圆。通过编写代码分析其径向误差，您将对计算效率和几何精度之间的权衡获得宝贵的实践洞察。",
            "id": "2424157",
            "problem": "给定平面上一个以原点为中心、半径为 $R  0$ 的完美圆，考虑其参数表示 $\\mathbf{C}(\\theta) = \\big(R\\cos\\theta,\\; R\\sin\\theta\\big)$，其中 $\\theta \\in [0, 2\\pi]$ 且 $\\theta$ 以弧度为单位。设 $N \\in \\mathbb{N}$ 为等角分段的数量，定义均匀划分 $\\theta_k = k h$，其中 $k = 0,1,\\dots,N$ 且 $h = \\dfrac{2\\pi}{N}$。对于每个子区间 $[\\theta_k,\\theta_{k+1}]$，考虑映射 $t \\mapsto \\theta_k + h t$，其中 $t \\in [0,1]$。定义分段三次多项式逼近 $\\mathbf{S}_{N,R}$ 如下：在每个分段 $k$ 上，令 $\\mathbf{P}_k:[0,1]\\to\\mathbb{R}^2$ 为唯一的向量值三次多项式（关于 $t$），其满足\n$$\n\\mathbf{P}_k(0) = \\mathbf{C}(\\theta_k),\\quad\n\\mathbf{P}_k(1) = \\mathbf{C}(\\theta_{k+1}),\\quad\n\\mathbf{P}_k'(0) = h\\,\\mathbf{C}'(\\theta_k),\\quad\n\\mathbf{P}_k'(1) = h\\,\\mathbf{C}'(\\theta_{k+1}),\n$$\n其中 $\\mathbf{C}'(\\theta) = \\dfrac{d\\mathbf{C}}{d\\theta}(\\theta) = \\big(-R\\sin\\theta,\\; R\\cos\\theta\\big)$。这定义了一条连续、分段三次、$C^1$ 的参数曲线 $\\mathbf{S}_{N,R}$，该曲线逼近了圆。\n\n定义在分段 $k$ 上参数 $t$ 处的径向误差为\n$$\ne_k(t) = \\left\\|\\mathbf{P}_k(t)\\right\\| - R,\n$$\n以及完整分段多项式逼近的最大绝对径向误差为\n$$\nE(N,R) = \\max_{0 \\le k \\le N-1}\\;\\max_{t \\in [0,1]} \\left|e_k(t)\\right|.\n$$\n\n任务：对于下面测试套件中列出的每个指定的 $(N,R)$ 对，计算 $E(N,R)$ 并报告结果。所有角度必须以弧度处理。除了 $R$ 所隐含的单位长度外，没有其他物理单位，所要求的输出是无量纲的。每个报告值必须是四舍五入到 $12$ 位小数的浮点数。\n\n测试套件（每一项为 $(N,R)$）：\n- $(1,\\,1)$\n- $(2,\\,1)$\n- $(3,\\,1)$\n- $(4,\\,1)$\n- $(8,\\,1)$\n- $(16,\\,1)$\n- $(12,\\,2)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试套件中的顺序相同，例如 $\\big[\\text{result}_1,\\text{result}_2,\\dots\\big]$。每个值在打印前必须四舍五入到 $12$ 位小数。",
            "solution": "所提出的问题已经过严格验证，在科学上是合理的、适定的和客观的。它构成了计算几何和数值逼近理论中的一个标准练习。我们继续进行求解。\n\n目标是计算半径为 $R$ 的圆的分段三次 Hermite 逼近 $\\mathbf{S}_{N,R}$ 的最大绝对径向误差 $E(N,R)$。该逼近是在 $N$ 个均匀的角度分段上构建的。\n\n首先，我们利用问题的旋转对称性。圆在旋转下是不变的，并且该逼近是使用步长为 $h = 2\\pi/N$ 的均匀划分 $\\theta_k = k h$ 来构建的。从 $\\theta_k$ 开始的分段的 Hermite 插值条件，是从 $\\theta_0=0$ 到 $\\theta_1=h$ 的第一分段条件的旋转版本。因此，分段 $k$ 上的参数曲线 $\\mathbf{P}_k(t)$ 是第一分段上曲线 $\\mathbf{P}_0(t)$ 的简单旋转：$\\mathbf{P}_k(t) = \\mathcal{R}(\\theta_k)\\mathbf{P}_0(t)$，其中 $\\mathcal{R}(\\theta_k)$ 是角度 $\\theta_k$ 的旋转矩阵。由于向量范数在旋转下是不变的，即 $\\|\\mathbf{P}_k(t)\\| = \\|\\mathcal{R}(\\theta_k)\\mathbf{P}_0(t)\\| = \\|\\mathbf{P}_0(t)\\|$，因此径向误差 $e_k(t) = \\|\\mathbf{P}_k(t)\\| - R$ 与分段索引 $k$ 无关。\n这极大地简化了问题，因为我们只需要分析第一分段上的误差：\n$$\nE(N,R) = \\max_{t \\in [0,1]} |e_0(t)| = \\max_{t \\in [0,1]} \\left| \\big\\|\\mathbf{P}_0(t)\\big\\| - R \\right|.\n$$\n\n在 $t \\in [0,1]$ 上的唯一三次多项式 $\\mathbf{P}_0(t)$ 由四个向量值 Hermite 条件确定：\n\\begin{align*}\n\\mathbf{p}_0 = \\mathbf{P}_0(0) = \\mathbf{C}(0) = (R, 0) \\\\\n\\mathbf{p}_1 = \\mathbf{P}_0(1) = \\mathbf{C}(h) = (R\\cos h, R\\sin h) \\\\\n\\mathbf{v}_0 = \\mathbf{P}_0'(0) = h\\mathbf{C}'(0) = (0, Rh) \\\\\n\\mathbf{v}_1 = \\mathbf{P}_0'(1) = h\\mathbf{C}'(h) = (-Rh\\sin h, Rh\\cos h)\n\\end{align*}\n将 $\\mathbf{P}_0(t)$ 写为 $\\mathbf{a}t^3 + \\mathbf{b}t^2 + \\mathbf{c}t + \\mathbf{d}$，通过求解 Hermite 条件所施加的方程组可以找到向量系数：\n$$\n\\mathbf{a} = 2\\mathbf{p}_0 - 2\\mathbf{p}_1 + \\mathbf{v}_0 + \\mathbf{v}_1 \\\\\n\\mathbf{b} = -3\\mathbf{p}_0 + 3\\mathbf{p}_1 - 2\\mathbf{v}_0 - \\mathbf{v}_1 \\\\\n\\mathbf{c} = \\mathbf{v}_0 \\\\\n\\mathbf{d} = \\mathbf{p}_0\n$$\n为了找到 $|e_0(t)|$ 的最大值，我们必须找到 $e_0(t)$ 在区间 $[0,1]$ 上的临界点。误差在端点处为零，即 $e_0(0)=e_0(1)=0$，因为多项式在这些点上插值了圆。在内部区间 $(0,1)$ 中的任何极值点都必须位于导数为零的点。$e_0(t) = \\sqrt{\\|\\mathbf{P}_0(t)\\|^2} - R$ 的极值点对应于范数平方函数 $f(t) = \\|\\mathbf{P}_0(t)\\|^2$ 的极值点。\n临界点是 $f'(t)=0$ 的解。使用点积的求导法则：\n$$\nf'(t) = \\frac{d}{dt}\\left( \\mathbf{P}_0(t) \\cdot \\mathbf{P}_0(t) \\right) = 2 \\mathbf{P}_0(t) \\cdot \\mathbf{P}_0'(t).\n$$\n由于 $\\mathbf{P}_0(t)$ 是一个三次多项式，其导数 $\\mathbf{P}_0'(t)$ 是一个二次多项式，它们的点积 $\\mathbf{P}_0(t) \\cdot \\mathbf{P}_0'(t)$ 是一个关于 $t$ 的五次多项式。因此，误差函数的临界点是这个五次多项式的根。\n\n一般五次多项式的根不存在解析解。必须采用数值方法。计算策略如下：\n1. 对于每对 $(N,R)$，计算 $h = 2\\pi/N$。\n2. 确定向量 $\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{v}_0, \\mathbf{v}_1$。\n3. 计算三次多项式 $\\mathbf{P}_0(t)$ 的系数 $\\mathbf{a}, \\mathbf{b}, \\mathbf{c}, \\mathbf{d}$。\n4. 构建五次多项式 $g(t) = \\mathbf{P}_0(t) \\cdot \\mathbf{P}_0'(t)$。\n5. 数值求解 $g(t)$ 的所有根。\n6. 最大误差位置的候选点是 $g(t)$ 在 $(0,1)$ 内的实数根集合，以及边界点 $t=0$ 和 $t=1$。\n7. 在每个候选点上评估绝对径向误差 $|e_0(t)|$。这些值中的最大值即为所求的最大误差 $E(N,R)$。\n\n最后，我们观察到 Hermite 数据点 $\\mathbf{p}_0, \\mathbf{p}_1$ 和切向量 $\\mathbf{v}_0, \\mathbf{v}_1$ 都与半径 $R$ 成线性比例。这意味着多项式 $\\mathbf{P}_0(t)$、其范数 $\\|\\mathbf{P}_0(t)\\|$ 和误差 $e_0(t)$ 也与 $R$ 成线性比例。因此，$E(N,R) = R \\cdot E(N,1)$。此性质可用于对结果进行有用的检验。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial import Polynomial\n\ndef solve():\n    \"\"\"\n    Solves the piecewise cubic approximation problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1),\n        (2, 1),\n        (3, 1),\n        (4, 1),\n        (8, 1),\n        (16, 1),\n        (12, 2)\n    ]\n\n    results = []\n    for N, R in test_cases:\n        result = compute_max_radial_error(N, R)\n        results.append(round(result, 12))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_radial_error(N, R):\n    \"\"\"\n    Computes the maximum absolute radial error E(N,R) for a given N and R.\n\n    The method involves the following steps:\n    1. Define the Hermite interpolation conditions for the first segment of the circle approximation.\n    2. Construct the vector-valued cubic polynomial P_0(t) for this segment.\n    3. The radial error extremum occurs where the velocity vector P_0'(t) is orthogonal \n       to the position vector P_0(t), i.e., P_0(t) . P_0'(t) = 0.\n    4. This dot product is a quintic polynomial in t. Its roots are found numerically.\n    5. The maximum error is found by checking the error at these roots (if in [0,1])\n       and at the endpoints t=0 and t=1.\n    \"\"\"\n    # Angular width of one segment\n    h = 2.0 * np.pi / N\n\n    # Endpoint positions (p0, p1) and scaled tangent vectors (v0, v1)\n    p0 = np.array([R, 0.0], dtype=np.float64)\n    p1 = np.array([R * np.cos(h), R * np.sin(h)], dtype=np.float64)\n    v0 = np.array([0.0, R * h], dtype=np.float64)\n    v1 = np.array([-R * h * np.sin(h), R * h * np.cos(h)], dtype=np.float64)\n\n    # Coefficients a, b, c, d for the cubic P_0(t) = at^3 + bt^2 + ct + d\n    a = 2.0 * p0 - 2.0 * p1 + v0 + v1\n    b = -3.0 * p0 + 3.0 * p1 - 2.0 * v0 - v1\n    c = v0\n    d = p0\n\n    # Represent the components of P_0(t) as polynomial objects\n    Px = Polynomial([d[0], c[0], b[0], a[0]])\n    Py = Polynomial([d[1], c[1], b[1], a[1]])\n\n    # Get the derivatives P_x'(t) and P_y'(t)\n    Px_prime = Px.deriv()\n    Py_prime = Py.deriv()\n\n    # The dot product P_0(t) . P_0'(t) is a quintic polynomial.\n    quintic_poly = Px * Px_prime + Py * Py_prime\n\n    # Find the roots of the quintic polynomial\n    roots = quintic_poly.roots()\n\n    # Candidate values of t for the maximum error are the real roots in [0,1] and boundaries.\n    candidates = {0.0, 1.0}\n    for root in roots:\n        # Check if the root is real (imaginary part is close to zero)\n        if np.isclose(root.imag, 0):\n            real_root = root.real\n            # Add to candidates if it's in the open interval (0,1)\n            if 0  real_root and real_root  1:\n                candidates.add(real_root)\n\n    max_abs_error = 0.0\n    for t in candidates:\n        # Evaluate polynomial P_0 at t\n        pos_vec = np.array([Px(t), Py(t)])\n        \n        # Calculate the absolute radial error | ||P_0(t)|| - R |\n        radial_error = np.linalg.norm(pos_vec) - R\n        abs_error = abs(radial_error)\n        \n        # Update maximum error\n        if abs_error  max_abs_error:\n            max_abs_error = abs_error\n            \n    return max_abs_error\n\nsolve()\n```"
        },
        {
            "introduction": "现在我们将注意力从几何建模转向数据分析，这是另一个主要的应用领域。在工程实践中，我们常常从模拟或实验中获得离散数据，并需要找到其背后函数穿过零点的精确位置。本练习要求您编写一个程序，以寻找由保形分段三次插值函数所表示的函数的根，这是一种在不引入人为振荡的情况下分析真实世界数据的稳健技术。",
            "id": "2424134",
            "problem": "给定一些数据集，每个数据集包含严格递增的横坐标 $x_0  x_1  \\dots  x_{n-1}$ 和对应的纵坐标 $y_0, y_1, \\dots, y_{n-1}$。标量函数 $f(x)$ 并非直接给出，而是通过对数据集使用分段三次Hermite插值法构建的唯一保形分段三次插值函数。你的任务是编写一个程序，为测试套件中的每个数据集，找出函数 $f(x)=0$ 在闭区间 $\\left[x_0, x_{n-1}\\right]$ 内的所有实数根。\n\n基本原理和建模假设：\n- 在每个子区间 $\\left[x_k,x_{k+1}\\right]$ 上，插值函数由一个三次Hermite多项式定义，该多项式满足在子区间端点处的函数值和斜率匹配条件。令 $h_k = x_{k+1}-x_k$ 且 $t=(x-x_k)/h_k\\in[0,1]$。在 $\\left[x_k,x_{k+1}\\right]$ 上，插值函数 $p_k(x)$ 定义为\n$$\np_k(x) = y_k h_{00}(t) + h_k m_k h_{10}(t) + y_{k+1} h_{01}(t) + h_k m_{k+1} h_{11}(t),\n$$\n其中三次Hermite基多项式为\n$$\nh_{00}(t) = 2t^3 - 3t^2 + 1,\\quad\nh_{10}(t) = t^3 - 2t^2 + t,\\quad\nh_{01}(t) = -2t^3 + 3t^2,\\quad\nh_{11}(t) = t^3 - t^2.\n$$\n- 斜率 $m_k$ 是通过将保单调性规则（Fritsch–Carlson方法）应用于割线斜率 $\\delta_k = \\dfrac{y_{k+1}-y_k}{x_{k+1}-x_k}$ 来选择的，以确保如果 $y_k$ 相对于 $x$ 是单调的，那么插值函数不会引入伪振荡或过冲。具体而言，如果 $\\delta_{k-1}$ 和 $\\delta_k$ 符号相反或其中之一为零，则 $m_k=0$；否则，$m_k$ 是 $\\delta_{k-1}$ 和 $\\delta_k$ 的加权调和平均值，以保持局部形状。端点斜率 $m_0$ 和 $m_{n-1}$ 以一致的方式选择，以避免过冲。\n- 根是满足 $f(x^\\star)=0$ 的任意 $x^\\star \\in [x_0,x_{n-1}]$。根可能严格出现在子区间内部（作为三次方程 $p_k(x)=0$ 的解），或者恰好出现在 $y_k=0$ 的节点 $x_k$ 处。\n\n算法要求：\n- 对每个数据集，按前述方法构建分段三次Hermite插值函数 $f(x)$。然后，对每个子区间，求解三次方程 $p_k(x)=0$，找出位于 $[x_k, x_{k+1}]$ 内的实数根。同时，将任何满足 $y_k=0$ 的节点 $x_k$ 也视为根。由于数值舍入误差，舍弃任何在 $\\left[x_0,x_{n-1}\\right]$ 之外的根。移除间距小于一个小的容差的重复根。\n- 将所有根按升序排序。将每个根四舍五入到6位小数。\n\n角度单位：当数据集中出现三角函数时，角度单位应解释为弧度。\n\n输出格式：\n- 你的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个数据集对应一个内层列表，其中包含按升序排列并四舍五入的根。使用逗号分隔的表示法，并用方括号括起来，不含任何空白字符。例如：\"[[r11,r12],[r21],[...]]\"。对根使用标准十进制浮点表示法，小数点后恰好保留6位数字。空列表应表示为\"[]\"。\n\n测试套件：\n为进行稳健的评估，请在以下四个数据集上运行你的程序。对于每个数据集，$x$ 都是严格递增的。\n\n- 测试用例1（一个内部根，不在节点上）：\n  - $x = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]$\n  - $y = [\\sin(0.5), \\sin(1.0), \\sin(1.5), \\sin(2.0), \\sin(2.5), \\sin(3.0), \\sin(3.5)]$ 其中角度单位为弧度。\n\n- 测试用例2（在定义域内无根）：\n  - $x = [-2.0, -1.0, 0.0, 1.0, 2.0]$\n  - $y = [(-2.0)^2 + 1.0, (-1.0)^2 + 1.0, 0.0^2 + 1.0, 1.0^2 + 1.0, 2.0^2 + 1.0]$。\n\n- 测试用例3（多个根恰好在节点上）：\n  - $x = [0, \\tfrac{\\pi}{4}, \\tfrac{\\pi}{2}, \\tfrac{3\\pi}{4}, \\pi, \\tfrac{5\\pi}{4}, \\tfrac{3\\pi}{2}, \\tfrac{7\\pi}{4}, 2\\pi]$\n  - $y = [\\sin(0), \\sin(\\tfrac{\\pi}{4}), \\sin(\\tfrac{\\pi}{2}), \\sin(\\tfrac{3\\pi}{4}), \\sin(\\pi), \\sin(\\tfrac{5\\pi}{4}), \\sin(\\tfrac{3\\pi}{2}), \\sin(\\tfrac{7\\pi}{4}), \\sin(2\\pi)]$ 其中角度单位为弧度。\n\n- 测试用例4（根在右边界上）：\n  - $x = [0.0, 0.5, 1.0, 1.5, 2.0]$\n  - $y = [0.0-2.0, 0.5-2.0, 1.0-2.0, 1.5-2.0, 2.0-2.0]$。\n\n数值和验证细节：\n- 使用一个小的绝对容差（例如 $10^{-12}$）来判断一个值是否为零（用于检测节点处的根）以及对来自相邻子区间的根进行去重。\n- 只需报告闭区间内的实数根。\n- 将每个根四舍五入到恰好6位小数，并确保内层列表在四舍五入后是严格升序的。\n\n你的程序必须实现上述所有要求，并生成一行包含四个测试用例汇总结果的输出，其格式需符合规定，且输出行中不含任何额外的打印或空白字符。",
            "solution": "所述问题是有效的。它提出了一个在计算工程领域，特别是在数值分析和逼近论领域中定义明确的任务。该问题在科学上基于分段多项式插值理论，是客观的，并提供了构建唯一、可验证解所需的所有信息。问题中没有矛盾、歧义，也不依赖于任何非科学的前提。\n\n目标是找到在闭区间 $[x_0, x_{n-1}]$ 上定义的函数 $f(x)$ 的所有实数根，其中 $f(x)$ 是根据给定数据集 $(x_k, y_k)$（$k=0, 1, \\dots, n-1$）构建的保形分段三次Hermite插值函数。\n\n分段三次Hermite插值是一种通过连接三次多项式（每个子区间 $[x_k, x_{k+1}]$ 一个）来构造的样条。为使插值函数光滑，函数值和一阶导数必须在节点 $x_k$ 处一致。设 $p_k(x)$ 是区间 $[x_k, x_{k+1}]$ 上的三次多项式。它由四条信息定义：函数值 $y_k = f(x_k)$ 和 $y_{k+1} = f(x_{k+1})$，以及导数值 $m_k = f'(x_k)$ 和 $m_{k+1} = f'(x_{k+1})$。\n\n在 $[x_k, x_{k+1}]$ 上的插值函数 $p_k(x)$ 可以用Hermite基多项式表示。令 $h_k = x_{k+1} - x_k$ 并定义一个归一化变量 $t = (x - x_k) / h_k$，这样当 $x$ 从 $x_k$ 变化到 $x_{k+1}$ 时，$t \\in [0, 1]$。该插值函数由下式给出：\n$$\np_k(x(t)) = y_k h_{00}(t) + y_{k+1} h_{01}(t) + h_k m_k h_{10}(t) + h_k m_{k+1} h_{11}(t)\n$$\n其中Hermite基函数为：\n$$\n\\begin{aligned}\nh_{00}(t) = 2t^3 - 3t^2 + 1 \\\\\nh_{01}(t) = -2t^3 + 3t^2 \\\\\nh_{10}(t) = t^3 - 2t^2 + t \\\\\nh_{11}(t) = t^3 - t^2\n\\end{aligned}\n$$\n这些基函数具有 $h_{00}(0)=1$, $h_{01}(1)=1$, $h'_{10}(0)=1$, $h'_{11}(1)=1$ 的性质，而在 $0$ 和 $1$ 处的其他值和导数值均为零，这确保了插值条件得到满足。\n\n关键部分是导数值 $m_k$ 的选择。标准三次样条强制二阶导数连续，但这可能会引入原始数据中不存在的伪振荡。问题指定了一种“保形”或“保单调性”的方法，即Fritsch–Carlson方法。该方法根据数据的局部几何形状（由割线斜率 $\\delta_k = (y_{k+1} - y_k) / (x_{k+1} - x_k)$ 定义）来确定斜率 $m_k$。\n对于一个内部节点 $x_k$（$k=1, \\dots, n-2$），其原理如下： 1. 如果相邻的割线斜率符号不同，即 $\\delta_{k-1} \\delta_k \\le 0$，则数据在 $x_k$ 周围不是单调的。为防止过冲，这个非单调点处的导数设为零：$m_k = 0$。 2. 如果割线斜率符号相同，即 $\\delta_{k-1} \\delta_k  0$，则数据是局部单调的。选择导数 $m_k$ 以保持这种单调性。标准库中实现的常见选择是 $\\delta_{k-1}$ 和 $\\delta_k$ 的加权调和平均值，以确保 $|m_k|$ 被适当地界定。\n端点斜率 $m_0$ 和 $m_{n-1}$ 使用与这些原则一致的单边格式来确定，以避免边界附近的过冲。\n\n一旦所有 $k$ 的斜率 $m_k$ 都被确定，分段多项式 $f(x)$ 就完全定义了。任务简化为在 $[x_0, x_{n-1}]$ 上寻找 $f(x)=0$ 的根。这涉及两种不同的情况： 1. 节点处的根：如果对应的纵坐标 $y_k=0$，则在节点 $x_k$ 处存在一个根。 2. 子区间内的根：如果三次多项式 $p_k(x)$ 在开区间 $(x_k, x_{k+1})$ 内有一个零点，则该区间内存在一个根。\n\n为了找到区间内的根，我们必须求解 $p_k(x)=0$。通过代入Hermite基函数并按 $t$ 的幂次合并同类项，该方程变为一个标准的三次方程 $at^3 + bt^2 + ct + d = 0$，其系数为：\n$$\n\\begin{aligned}\na = 2(y_k - y_{k+1}) + h_k(m_k + m_{k+1}) \\\\\nb = 3(y_{k+1} - y_k) - h_k(2m_k + m_{k+1}) \\\\\nc = h_k m_k \\\\\nd = y_k\n\\end{aligned}\n$$\n这个三次方程可以求解其实数根 $t^\\star$。任何位于 $[0, 1]$ 范围内的根 $t^\\star$ 都对应于插值函数的一个有效根 $x^\\star = x_k + t^\\star h_k$。\n\n计算策略按以下步骤进行：\n1.  对每个数据集，使用 `scipy.interpolate.PchipInterpolator` 类。这个类提供了Fritsch-Carlson方法的一个稳健且数值稳定的实现，用于构建保形分段三次插值函数。\n2.  为确保完备性，求根过程被分解为两部分： a. 通过检查输入的纵坐标值 $y_k$ 是否在小的容差 $\\epsilon = 10^{-12}$ 内接近于零，来识别节点处的根。 b. 使用插值器对象的 `.roots()` 方法来寻找开区间 $(x_k, x_{k+1})$ 内的根。该方法能高效且准确地找到分段多项式在其定义域内的所有实数根，但它不会报告在全局边界 $x_0$ 和 $x_{n-1}$ 处的根。\n3.  将来自这两个来源的根收集到一个集合中。\n4.  这个集合按升序排序。如果一个节点处的根被两种方法同时找到，就可能出现重复值。通过遍历排序后的列表，只保留那些间距大于容差 $\\epsilon$ 的根，从而移除重复值。\n5.  最后，将唯一的、已排序的根四舍五入到6位小数，并按要求格式化。这种方法保证了在闭区间 $[x_0, x_{n-1}]$ 内的所有实数根都能被找到并正确报告。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the real roots of shape-preserving piecewise cubic Hermite interpolants\n    for a suite of test cases.\n    \"\"\"\n    # Tolerance for floating-point comparisons (zero-checking and de-duplication).\n    TOL = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: one interior root, not at a knot\n        {\n            \"x\": np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]),\n            \"y\": np.sin(np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]))\n        },\n        # Test case 2: no roots in the domain\n        {\n            \"x\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"y\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0])**2 + 1.0\n        },\n        # Test case 3: multiple roots exactly at knots\n        {\n            \"x\": np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]),\n            \"y\": np.sin(np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]))\n        },\n        # Test case 4: root at the right boundary\n        {\n            \"x\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]),\n            \"y\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]) - 2.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        x_data, y_data = case[\"x\"], case[\"y\"]\n\n        # 1. Construct the shape-preserving piecewise cubic Hermite interpolant.\n        #    PchipInterpolator implements the Fritsch–Carlson method.\n        interpolator = PchipInterpolator(x_data, y_data)\n\n        # 2. Find roots. This requires a two-pronged approach.\n        \n        # 2a. Find roots within open subintervals using the PPoly.roots() method.\n        # This method correctly finds roots within (x_k, x_{k+1}) for all k,\n        # but does not report roots at the global boundaries x_0 and x_{n-1}.\n        interior_roots = interpolator.roots(extrapolate=False)\n\n        # 2b. Find roots that occur exactly at the knots.\n        knot_roots = x_data[np.abs(y_data)  TOL]\n        \n        # 3. Combine, sort, and de-duplicate the roots.\n        if interior_roots.size == 0 and knot_roots.size == 0:\n            unique_sorted_roots = []\n        else:\n            all_found_roots = np.concatenate((interior_roots, knot_roots))\n            # Sort all roots to prepare for de-duplication.\n            all_found_roots.sort()\n\n            # De-duplicate roots that are closer than the tolerance.\n            if len(all_found_roots)  0:\n                unique_sorted_roots = [all_found_roots[0]]\n                for root in all_found_roots[1:]:\n                    if root - unique_sorted_roots[-1]  TOL:\n                        unique_sorted_roots.append(root)\n            else:\n                unique_sorted_roots = []\n\n        # 4. Format the output: round to 6 decimal places.\n        # The f-string format ensures exactly 6 digits are printed, even for whole numbers.\n        formatted_roots = [f\"{root:.6f}\" for root in unique_sorted_roots]\n        all_results.append(f\"[{','.join(formatted_roots)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}