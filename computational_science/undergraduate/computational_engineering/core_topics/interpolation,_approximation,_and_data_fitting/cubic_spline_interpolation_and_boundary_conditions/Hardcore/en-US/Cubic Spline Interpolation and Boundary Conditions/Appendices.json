{
    "hands_on_practices": [
        {
            "introduction": "While many computational libraries offer pre-built spline functions, a true mastery of the method comes from building one from the ground up. This first exercise guides you through the implementation of a natural cubic spline, focusing on the construction and solution of the underlying tridiagonal system for the second derivatives. This practice illuminates the spline's inner workings and reinforces the core connection between the mathematical continuity conditions and the resulting linear algebra .",
            "id": "2384309",
            "problem": "You are given one-dimensional data sampled at strictly increasing nodes. For a set of nodes $x_0 < x_1 < \\dots < x_n$ with corresponding values $y_0, y_1, \\dots, y_n$, consider the unique natural cubic spline $S(x)$ defined by the following properties: on each interval $[x_i, x_{i+1}]$ the function $S(x)$ is a cubic polynomial; the function $S(x)$ satisfies the interpolation conditions $S(x_i) = y_i$ for all $i$ with $0 \\le i \\le n$; the first derivative $S'(x)$ is continuous on $[x_0, x_n]$; the second derivative $S''(x)$ is continuous on $[x_0, x_n]$; and the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$ hold. Your task is to write a complete program that, for each test case below, constructs the unique natural cubic spline $S(x)$ for the provided data set and evaluates $S(x)$ at a specified query point $x_q$.\n\nAll inputs in the test suite are explicitly given below. Each test case is independent. In each case, use the provided arrays $x$ and $y$ as the exact data to construct $S(x)$, and then compute the scalar value $S(x_q)$. No external data sources are permitted or needed. All computations are purely numerical and dimensionless; no physical units apply.\n\nTest Suite (each item is a triple $(x, y, x_q)$ to be processed independently, in the given order):\n- Test case $1$: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 1.3$.\n- Test case $2$: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 0.0$.\n- Test case $3$: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 3.0$.\n- Test case $4$: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 2.2$.\n- Test case $5$: $x = [-1.0, 2.0]$, $y = [-1.0, 4.0]$, $x_q = 0.5$.\n\nYour program must compute $S(x_q)$ for each of the above $5$ cases, in order, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each number in the output list must be a floating-point value rounded to exactly $8$ decimal places. For example, the required output format is $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is $S(x_q)$ rounded to $8$ decimal places for test case $i$.",
            "solution": "The goal is to construct the unique natural cubic spline $S(x)$ from the given data $(x_i, y_i)$ with $0 \\le i \\le n$, where $x_0 < x_1 < \\dots < x_n$. By definition, $S(x)$ is piecewise cubic on each interval $[x_i, x_{i+1}]$, interpolates the data $S(x_i) = y_i$, and has continuous first and second derivatives on $[x_0, x_n]$, with the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$.\n\nA standard construction proceeds by introducing the unknown vector of second derivatives at the knots, denoted by $M_i = S''(x_i)$ for $0 \\le i \\le n$. The step sizes are $h_i = x_{i+1} - x_i$ for $0 \\le i \\le n-1$. For interior indices $i$ with $1 \\le i \\le n-1$, continuity of $S'(x)$ and $S''(x)$ across the knots leads to a linear system for the interior second derivatives $M_1, M_2, \\dots, M_{n-1}$:\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\nwith the natural boundary conditions $M_0 = 0$ and $M_n = 0$. For $n = 1$ (i.e., two nodes), there are no interior unknowns and the natural cubic spline reduces exactly to linear interpolation between the two points, which is consistent with $M_0 = 0$ and $M_1 = 0$.\n\nThe coefficient matrix of the system for $(M_1, \\dots, M_{n-1})$ is tridiagonal, with the following entries for $1 \\le i \\le n-1$:\n- Main diagonal: $b_i = 2(h_{i-1} + h_i)$.\n- Subdiagonal: $a_i = h_{i-1}$ for $i \\ge 2$.\n- Superdiagonal: $c_i = h_i$ for $i \\le n-2$.\nThe right-hand side is $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$.\n\nThis linear system is strictly diagonally dominant for strictly increasing $x_i$ with $h_i > 0$, ensuring a unique solution. An efficient and exact method to solve a tridiagonal linear system in $\\mathcal{O}(n)$ time consists of a forward elimination phase that eliminates subdiagonal entries followed by a backward substitution phase to recover the unknowns. Specifically, let the system be expressed in compact notation as\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{for } i = 1, 2, \\dots, n-1,\n$$\nwith the conventions that $a_1 = 0$ and $c_{n-1} = 0$. The forward elimination step constructs modified diagonals and right-hand side:\nfor $i = 2, 3, \\dots, n-1$,\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\nThe backward substitution then computes\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{for } i = n-2, n-3, \\dots, 1.\n$$\nFinally, set $M_0 = 0$ and $M_n = 0$ to obtain the full vector $(M_0, M_1, \\dots, M_n)$.\n\nWith the second derivatives known, the spline on interval $[x_i, x_{i+1}]$ can be evaluated for any $x \\in [x_i, x_{i+1}]$ using the Hermite-like representation\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\nwhere $h_i = x_{i+1} - x_i$, $A = \\frac{x_{i+1} - x}{h_i}$, and $B = \\frac{x - x_i}{h_i}$. This representation satisfies $S(x_i) = y_i$, $S(x_{i+1}) = y_{i+1}$, and the continuity conditions by construction. If $n = 1$, then $M_i = 0$ for all indices and the formula reduces to the linear interpolation $S(x) = A y_0 + B y_1$.\n\nTo evaluate $S(x_q)$, determine the interval $[x_i, x_{i+1}]$ such that $x_q \\in [x_i, x_{i+1}]$. If $x_q = x_n$, select the final interval $[x_{n-1}, x_n]$. Compute $A$, $B$, and then $S(x_q)$ via the above formula. Repeating this for each test case produces the required scalar outputs. Each result is finally rounded to exactly $8$ decimal places and emitted in a single bracketed, comma-separated list in the specified order.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n < 1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        hi_prev = h[i] if i >= 0 else None\n        hi = h[i+1] if (i + 1) < n else None\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq <= x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] <= xq <= x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            if x[mid] <= xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        raise ZeroDivisionError(\"Zero interval width encountered.\")\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "With a foundational spline implementation understood, we now address a crucial aspect of modeling: selecting appropriate boundary conditions. This choice is not merely a mathematical formality; it should reflect the physical or geometric nature of the system being modeled. This practice demonstrates this principle by comparing the performance of a generic 'natural' spline with a context-aware 'periodic' spline for interpolating a known periodic function, highlighting how the right choice can dramatically improve model accuracy .",
            "id": "2382247",
            "problem": "Consider the function $f(x) = \\sin(x)$ defined on the closed interval $[0, 2\\pi]$, where all angles are in radians. Let $x_0 = 0$ and $x_{N-1} = 2\\pi$. For a given integer $N \\geq 4$, define a set of $N$ sample points $\\{x_i\\}_{i=0}^{N-1}$ that are uniformly spaced on $[0, 2\\pi]$, and corresponding data values $y_i = f(x_i)$ for all $i$. Construct two cubic spline interpolants $S_{\\mathrm{nat}}(x)$ and $S_{\\mathrm{per}}(x)$ that interpolate the data $\\{(x_i, y_i)\\}$, where:\n- $S_{\\mathrm{nat}}(x)$ is the natural cubic spline, which satisfies the boundary conditions $S_{\\mathrm{nat}}''(x_0) = 0$ and $S_{\\mathrm{nat}}''(x_{N-1}) = 0$.\n- $S_{\\mathrm{per}}(x)$ is the periodic cubic spline, which satisfies $S_{\\mathrm{per}}^{(k)}(x_0) = S_{\\mathrm{per}}^{(k)}(x_{N-1})$ for $k \\in \\{0, 1, 2\\}$.\n\nDefine the true derivative at the boundaries as $f'(x_0) = \\cos(0)$ and $f'(x_{N-1}) = \\cos(2\\pi)$. For each spline type $\\tau \\in \\{\\mathrm{nat}, \\mathrm{per}\\}$, define the boundary derivative error\n$$\nE_{\\tau}(N) = \\max\\left( \\left| S_{\\tau}'(x_0) - f'(x_0) \\right|, \\left| S_{\\tau}'(x_{N-1}) - f'(x_{N-1}) \\right| \\right).\n$$\nFor each $N$ in the test suite, compute the ratio\n$$\nR(N) = \\frac{E_{\\mathrm{nat}}(N)}{E_{\\mathrm{per}}(N)}.\n$$\n\nYour program must:\n- Use the function $f(x) = \\sin(x)$ on $[0, 2\\pi]$ with angles in radians.\n- For each specified $N$, form the uniform grid including both endpoints, construct $S_{\\mathrm{nat}}(x)$ and $S_{\\mathrm{per}}(x)$ as defined above, evaluate $E_{\\mathrm{nat}}(N)$ and $E_{\\mathrm{per}}(N)$, and report $R(N)$.\n\nTest suite:\n- $N \\in \\{5, 9, 17, 64\\}$.\n\nThe required final output format is a single line containing the list of the four values $[R(5), R(9), R(17), R(64)]$ as a comma-separated list enclosed in square brackets, with each floating-point value rounded to exactly $8$ decimal places (for example, $[1.23456789,2.34567891,3.45678912,4.56789123]$). No other text should be printed.",
            "solution": "The task is to compare the accuracy of natural and periodic cubic splines in approximating the boundary derivatives of the function $f(x) = \\sin(x)$ on the interval $[0, 2\\pi]$. A cubic spline interpolant, $S(x)$, is a piecewise function, where each piece $S_i(x)$ on an interval $[x_i, x_{i+1}]$ is a cubic polynomial of the form:\n$$S_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$$\nThe coefficients are determined by enforcing several conditions:\n1.  Interpolation: $S(x_i) = y_i$ for all $i=0, \\dots, N-1$.\n2.  Continuity: The spline $S(x)$, its first derivative $S'(x)$, and its second derivative $S''(x)$ are continuous over the entire interval $[x_0, x_{N-1}]$.\n\nThese conditions yield a system of linear equations. It is standard to solve for the second derivatives at the knots, $M_i = S''(x_i)$. For a uniform grid with spacing $h = (x_{N-1}-x_0)/(N-1)$, the equations for the interior knots ($i=1, \\dots, N-2$) are given by:\n$$M_{i-1} + 4M_i + M_{i+1} = \\frac{6}{h^2}(y_{i-1} - 2y_i + y_{i+1})$$\nTo obtain a unique solution for all $M_i$, two additional boundary conditions are required. The choice of these conditions defines the type of the spline.\n\n1.  **Natural Cubic Spline ($S_{\\mathrm{nat}}(x)$)**:\n    The boundary conditions are $S_{\\mathrm{nat}}''(x_0) = 0$ and $S_{\\mathrm{nat}}''(x_{N-1}) = 0$. This implies $M_0 = 0$ and $M_{N-1} = 0$. These constraints close the system of equations, resulting in a strictly diagonally dominant tridiagonal system for the unknown interior second derivatives $M_1, \\dots, M_{N-2}$, which guarantees a unique solution.\n    A critical observation for this specific problem is that the function being interpolated, $f(x) = \\sin(x)$, has true second derivatives at the boundaries of $f''(0) = -\\sin(0) = 0$ and $f''(2\\pi) = -\\sin(2\\pi) = 0$. Therefore, the natural spline's boundary conditions coincidentally match the true second derivatives of the function. This situation is analogous to a 'clamped' spline where the true second derivatives are provided, which is known to lead to a higher order of accuracy than a general natural spline.\n\n2.  **Periodic Cubic Spline ($S_{\\mathrm{per}}(x)$)**:\n    The boundary conditions are periodic: $S_{\\mathrm{per}}^{(k)}(x_0) = S_{\\mathrm{per}}^{(k)}(x_{N-1})$ for $k=0, 1, 2$. The function $f(x) = \\sin(x)$ and its derivatives are periodic on $[0, 2\\pi]$, so these conditions are consistent with the underlying function's properties. These conditions result in a cyclic tridiagonal system of equations for $M_0, \\dots, M_{N-1}$, which is also non-singular and has a unique solution. This type of spline is theoretically the most appropriate for interpolating periodic functions.\n\nThe first derivative of the spline at the endpoints is required to compute the error. These can be calculated from the values of $y_i$ and $M_i$. At the left boundary $x_0$:\n$$S'(x_0) = \\frac{y_1 - y_0}{h} - \\frac{h}{6}(2M_0 + M_1)$$\nAt the right boundary $x_{N-1}$:\n$$S'(x_{N-1}) = \\frac{y_{N-1} - y_{N-2}}{h} + \\frac{h}{6}(M_{N-2} + 2M_{N-1})$$\nThe true derivative of $f(x) = \\sin(x)$ is $f'(x) = \\cos(x)$. At the boundaries, the true values are $f'(0) = \\cos(0) = 1$ and $f'(2\\pi) = \\cos(2\\pi) = 1$.\nThe error for each spline type $\\tau \\in \\{\\mathrm{nat}, \\mathrm{per}\\}$ is defined as the maximum absolute difference between the spline's derivative and the true derivative at the two boundaries:\n$$E_{\\tau}(N) = \\max\\left( \\left| S_{\\tau}'(0) - 1 \\right|, \\left| S_{\\tau}'(2\\pi) - 1 \\right| \\right)$$\nFinally, the ratio $R(N) = E_{\\mathrm{nat}}(N) / E_{\\mathrm{per}}(N)$ is computed for each $N$ in the test suite.\n\nThe algorithm proceeds as follows:\nFor each given value of $N$:\n1.  Generate $N$ uniformly spaced points $\\{x_i\\}$ on $[0, 2\\pi]$ and the corresponding data values $y_i = \\sin(x_i)$.\n2.  Construct the natural cubic spline $S_{\\mathrm{nat}}(x)$ using the `scipy.interpolate.CubicSpline` library function with `bc_type='natural'`.\n3.  Construct the periodic cubic spline $S_{\\mathrm{per}}(x)$ using the same function with `bc_type='periodic'`.\n4.  Evaluate the first derivatives $S_{\\mathrm{nat}}'(0)$, $S_{\\mathrm{nat}}'(2\\pi)$, $S_{\\mathrm{per}}'(0)$, and $S_{\\mathrm{per}}'(2\\pi)$.\n5.  Calculate the errors $E_{\\mathrm{nat}}(N)$ and $E_{\\mathrm{per}}(N)$.\n6.  Compute the ratio $R(N)$.\n\nThis procedure is repeated for each $N$ in the set $\\{5, 9, 17, 64\\}$. The resulting ratios are collected and formatted as specified. The \"lucky\" choice of natural boundary conditions is expected to make $S_{\\mathrm{nat}}(x)$ surprisingly accurate, leading to an interesting comparison with the theoretically superior periodic spline.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the cubic spline boundary derivative error problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [5, 9, 17, 64]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Define the grid and data points for f(x) = sin(x) on [0, 2*pi].\n        # The grid is uniform and includes both endpoints.\n        x_points = np.linspace(0.0, 2.0 * np.pi, N)\n        y_points = np.sin(x_points)\n\n        # Step 2: Define the true derivative at the boundaries.\n        # f'(x) = cos(x), so f'(0) = 1 and f'(2*pi) = 1.\n        f_prime_true = 1.0\n\n        # Step 3: Construct the natural cubic spline and calculate its boundary derivative error.\n        # 'natural' sets the second derivative at the endpoints to zero.\n        # S_nat''(x_0) = 0, S_nat''(x_{N-1}) = 0.\n        s_nat = CubicSpline(x_points, y_points, bc_type='natural')\n        \n        # Evaluate the first derivative (nu=1) at the boundaries.\n        s_nat_prime_x0 = s_nat(x_points[0], nu=1)\n        s_nat_prime_x_end = s_nat(x_points[-1], nu=1)\n        \n        # Calculate the error E_nat(N).\n        error_nat = max(abs(s_nat_prime_x0 - f_prime_true), abs(s_nat_prime_x_end - f_prime_true))\n\n        # Step 4: Construct the periodic cubic spline and calculate its boundary derivative error.\n        # 'periodic' enforces S^(k)(x_0) = S^(k)(x_{N-1}) for k=0,1,2.\n        # This is valid because y_points[0] is numerically equal to y_points[-1].\n        s_per = CubicSpline(x_points, y_points, bc_type='periodic')\n\n        # Evaluate the first derivative (nu=1) at the boundaries.\n        s_per_prime_x0 = s_per(x_points[0], nu=1)\n        s_per_prime_x_end = s_per(x_points[-1], nu=1)\n        \n        # Calculate the error E_per(N).\n        error_per = max(abs(s_per_prime_x0 - f_prime_true), abs(s_per_prime_x_end - f_prime_true))\n\n        # Step 5: Compute the ratio R(N).\n        # We check for division by zero, although it is not expected for this problem.\n        if error_per == 0.0:\n            # If the periodic spline is perfectly accurate, the ratio is either 0 (if natural is also perfect)\n            # or infinite (if natural has error). In a computational context, we would report a very large number\n            # or handle as a special case. Given the problem, it's safe to assume error_per > 0.\n            ratio = np.inf if error_nat > 0 else 0.0\n        else:\n            ratio = error_nat / error_per\n        \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    # Each float is formatted to 8 decimal places.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A common temptation in engineering is to use an interpolation model to predict values outside the range of the original data—a practice known as extrapolation. While sometimes necessary, it is fraught with risk, as the model's behavior is unconstrained by data. This final practice explores the stability of spline extrapolation, investigating how different boundary conditions—natural, clamped, and not-a-knot—govern the reliability of predictions and teaching you how to quantify this behavior .",
            "id": "2382282",
            "problem": "You are tasked with implementing a complete, runnable program that constructs and evaluates cubic spline interpolants with different endpoint boundary conditions, and then quantifies how these conditions influence extrapolation beyond the data range. Your program must be deterministic and produce the exact output format described below.\n\nConsider data generated from the function $f(x) = \\sin(x)$ over the closed interval $[0,\\pi]$, with angles measured in radians. Let $n = 8$ sample points be uniformly spaced on $[0,\\pi]$, i.e., $x_i = 0 + (i-1)\\,\\Delta x$ with $\\Delta x = \\pi/(n-1)$ for $i = 1,2,\\dots,n$, and let $y_i = f(x_i)$ for $i = 1,2,\\dots,n$. You will construct a cubic spline interpolant $s(x)$ to the data $\\{(x_i,y_i)\\}_{i=1}^n$ under each of the following boundary conditions at the endpoints $x_1$ and $x_n$:\n\n- Natural boundary conditions: $s''(x_1) = 0$ and $s''(x_n) = 0$.\n- Clamped boundary conditions: $s'(x_1) = f'(x_1)$ and $s'(x_n) = f'(x_n)$, where $f'(x) = \\cos(x)$.\n- Not-a-knot boundary conditions: the third derivative is continuous at the first interior knot $x_2$ and the last interior knot $x_{n-1}$, which forces the first two and last two polynomial pieces to merge into single cubics.\n\nA cubic spline $s(x)$ is a piecewise cubic polynomial with global $C^2$-smoothness (i.e., $s(x)$, $s'(x)$, and $s''(x)$ are continuous for all $x$), satisfying the interpolation conditions $s(x_i) = y_i$ for all $i$. The boundary conditions above complete the specification so that a unique interpolant exists. Extrapolation of $s(x)$ beyond $[x_1,x_n]$ is defined by extending the cubic polynomial of the nearest boundary interval.\n\nYour program must compute the following quantitative diagnostics:\n\n- Define two extrapolation targets: $x_L = -0.5$ (to the left of $x_1$) and $x_R = \\pi + 0.5$ (to the right of $x_n$), with angles in radians.\n- For each boundary condition, compute the absolute extrapolation error at $x_L$ and at $x_R$, defined as $E_{\\text{left}} = |s(x_L) - f(x_L)|$ and $E_{\\text{right}} = |s(x_R) - f(x_R)|$.\n- To assess extrapolation stability controlled by the boundary conditions, define the following one-sided endpoint sensitivity metrics based on a small perturbation $\\varepsilon = 10^{-6}$:\n  - Right-end sensitivity at $x_R$: construct a perturbed dataset with only the rightmost data value changed to $y_n^{\\text{pert}} = y_n + \\varepsilon$, leaving all other $y_i$ unchanged and keeping the same boundary condition. Let $s^{\\text{pert}}(x)$ be the corresponding spline. Define $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$.\n  - Left-end sensitivity at $x_L$: construct a perturbed dataset with only the leftmost data value changed to $y_1^{\\text{pert}} = y_1 + \\varepsilon$, leaving all other $y_i$ unchanged and keeping the same boundary condition. Define $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$.\nThese sensitivities quantify how a unit change at the nearest endpoint data value influences an extrapolated prediction just beyond that endpoint, under each boundary condition.\n\nTest suite and required outputs:\n- Use exactly the three boundary conditions described above in the fixed order: natural, clamped, not-a-knot.\n- Use exactly $n = 8$, the function $f(x) = \\sin(x)$, $x_L = -0.5$, $x_R = \\pi + 0.5$, and $\\varepsilon = 10^{-6}$, with angles in radians.\n- Your program must compute and aggregate the following four lists of floating-point results in the exact order shown:\n  1. $[E_{\\text{right}}^{\\text{natural}}, E_{\\text{right}}^{\\text{clamped}}, E_{\\text{right}}^{\\text{not-a-knot}}]$,\n  2. $[E_{\\text{left}}^{\\text{natural}}, E_{\\text{left}}^{\\text{clamped}}, E_{\\text{left}}^{\\text{not-a-knot}}]$,\n  3. $[S_{\\text{right}}^{\\text{natural}}, S_{\\text{right}}^{\\text{clamped}}, S_{\\text{right}}^{\\text{not-a-knot}}]$,\n  4. $[S_{\\text{left}}^{\\text{natural}}, S_{\\text{left}}^{\\text{clamped}}, S_{\\text{left}}^{\\text{not-a-knot}}]$.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated top-level Python-style list of four lists, in the order specified above (for example, a line like $[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]$). The numerical values must be floating-point numbers.\n\nScientific and algorithmic bases that you must rely on in your reasoning and implementation:\n- Definition of cubic splines as piecewise cubic functions with $C^2$ continuity, satisfying interpolation conditions.\n- Boundary condition roles in closing the linear system for spline coefficients.\n- Extrapolation for cubic splines as the natural continuation of the boundary interval’s cubic.\n- Sensitivity as a finite-difference approximation of a directional derivative with respect to data perturbations.\n\nAngles must be in radians, and all requested numerical answers must be returned as floating-point values in the exact output format described.",
            "solution": "A cubic spline $s(x)$ interpolating a set of $n$ data points $\\{(x_i, y_i)\\}_{i=1}^n$ is a piecewise function. On each subinterval $[x_i, x_{i+1}]$ for $i=1, \\dots, n-1$, $s(x)$ is a cubic polynomial, which we denote as $s_i(x)$.\n$$s_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$$\nThere are $4(n-1)$ coefficients $\\{a_i, b_i, c_i, d_i\\}_{i=1}^{n-1}$ to determine. The following conditions are imposed:\n1. Interpolation: $s_i(x_i) = y_i$ for $i=1, \\dots, n-1$ and $s_{n-1}(x_n) = y_n$. This provides $n$ conditions. From the first part, we find $a_i = y_i$.\n2. Continuity: At the $n-2$ interior knots $x_2, \\dots, x_{n-1}$, the function value, first derivative, and second derivative must be continuous.\n   - $s_{i-1}(x_i) = s_i(x_i) (= y_i)$\n   - $s'_{i-1}(x_i) = s'_i(x_i)$\n   - $s''_{i-1}(x_i) = s''_i(x_i)$\nThese continuity constraints provide $3(n-2)$ conditions. In total, we have $n + 3(n-2) = 4n-6$ conditions for $4(n-1) = 4n-4$ unknowns. We are short two conditions. These are provided by the boundary conditions at the endpoints $x_1$ and $x_n$.\n\nThe specified boundary conditions are:\n- **Natural**: The second derivatives at the endpoints are zero: $s''(x_1)=0$ and $s''(x_n)=0$. This implies that the spline approaches the endpoints with no curvature, mimicking a line. It is often used when no information about the endpoint derivatives is available.\n- **Clamped**: The first derivatives at the endpoints are specified. Here, they are matched to the true derivatives of the underlying function $f(x)$: $s'(x_1) = f'(x_1)$ and $s'(x_n) = f'(x_n)$. For $f(x)=\\sin(x)$, we have $f'(x)=\\cos(x)$, so $s'(0) = \\cos(0) = 1$ and $s'(\\pi) = \\cos(\\pi) = -1$.\n- **Not-a-knot**: This condition forces the first and second cubic pieces to be the same polynomial, and likewise for the last two pieces. This is achieved by enforcing continuity of the third derivative at the first interior knot $x_2$ and the last interior knot $x_{n-1}$. That is, $s'''(x_2^-) = s'''(x_2^+)$ and $s'''(x_{n-1}^-) = s'''(x_{n-1}^+)$.\n\nThe problem requires extrapolation, which means evaluating the spline $s(x)$ at points outside the interval $[x_1, x_n]$. This is performed by extending the cubic polynomial defined on the nearest boundary interval. For $x < x_1$, we use $s_1(x)$, and for $x > x_n$, we use $s_{n-1}(x)$.\n\nThe sensitivity metrics, $S_{\\text{left}}$ and $S_{\\text{right}}$, are finite-difference approximations to the partial derivatives of the extrapolated values with respect to the endpoint data values:\n$$ S_{\\text{left}} \\approx \\frac{\\partial s(x_L)}{\\partial y_1}, \\quad S_{\\text{right}} \\approx \\frac{\\partial s(x_R)}{\\partial y_n} $$\nThese metrics quantify the stability of extrapolation. A large sensitivity value indicates that a small change or error in an endpoint measurement can lead to a large, amplified error in the extrapolated prediction.\n\nThe solution proceeds as follows:\n1.  Set up the constants $n=8$, $\\varepsilon=10^{-6}$, and the evaluation points $x_L=-0.5$ and $x_R=\\pi+0.5$.\n2.  Generate the data points $\\{x_i, y_i\\}_{i=1}^n$ from $f(x)=\\sin(x)$ on $[0, \\pi]$ using $x_i = (i-1)\\pi/(n-1)$.\n3.  Iterate through the three boundary conditions: natural, clamped, and not-a-knot.\n4.  For each condition:\n    a. Construct the baseline cubic spline $s(x)$ using the original data $\\{x_i, y_i\\}$. For the clamped case, the derivatives $s'(0)=1$ and $s'(\\pi)=-1$ are supplied. Extrapolation is enabled.\n    b. Evaluate $s(x_L)$ and $s(x_R)$. Calculate the extrapolation errors $E_{\\text{left}} = |s(x_L) - \\sin(x_L)|$ and $E_{\\text{right}} = |s(x_R) - \\sin(x_R)|$.\n    c. To find $S_{\\text{right}}$, create a perturbed dataset where $y_n$ is replaced by $y_n + \\varepsilon$. Construct the perturbed spline $s^{\\text{pert}}(x)$ using the same boundary condition type. Calculate $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$.\n    d. To find $S_{\\text{left}}$, create a perturbed dataset where $y_1$ is replaced by $y_1 + \\varepsilon$. Construct the perturbed spline $s^{\\text{pert}}(x)$. Calculate $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$.\n5.  Collect the results for $E_{\\text{right}}$, $E_{\\text{left}}$, $S_{\\text{right}}$, and $S_{\\text{left}}$ into four separate lists, maintaining the order of the boundary conditions.\n6.  Format the four lists into a single list of lists for the final output. The implementation will utilize the `scipy.interpolate.CubicSpline` class, which provides a robust and efficient way to perform these constructions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Constructs cubic splines with different boundary conditions,\n    evaluates extrapolation error and endpoint sensitivity.\n    \"\"\"\n\n    # Step 1: Define constants and problem parameters as per the statement.\n    n = 8\n    epsilon = 1e-6\n    x_left_target = -0.5\n    x_right_target = np.pi + 0.5\n    \n    # Define the true function and its derivative.\n    true_func = np.sin\n    true_func_deriv = np.cos\n    \n    # Step 2: Generate the sample data points.\n    # The problem statement uses 1-based indexing i=1,...,n.\n    # We use 0-based indexing for arrays.\n    # x_i = (i-1)*pi/(n-1) for i=1..n becomes x_j = j*pi/(n-1) for j=0..n-1.\n    x_nodes = np.linspace(0, np.pi, n)\n    y_nodes = true_func(x_nodes)\n\n    # Define the boundary conditions and their order for processing.\n    boundary_conditions = ['natural', 'clamped', 'not-a-knot']\n    \n    # Lists to store the computed diagnostics.\n    errors_right = []\n    errors_left = []\n    sensitivities_right = []\n    sensitivities_left = []\n    \n    # Step 3: Loop through each boundary condition type.\n    for bc_type in boundary_conditions:\n        \n        # --- Baseline Spline Calculation ---\n        # Special handling for 'clamped' condition which requires derivative values.\n        if bc_type == 'clamped':\n            # Derivatives at endpoints x_1=0 and x_n=pi.\n            # f'(x) = cos(x), so f'(0)=1, f'(pi)=-1.\n            deriv_at_endpoints = (true_func_deriv(x_nodes[0]), true_func_deriv(x_nodes[-1]))\n            # The bc_type argument for clamped specifies derivative order and value.\n            # (order, value) for left, (order, value) for right.\n            spline = CubicSpline(x_nodes, y_nodes, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            # For 'natural' and 'not-a-knot', the string name is sufficient.\n            spline = CubicSpline(x_nodes, y_nodes, bc_type=bc_type, extrapolate=True)\n\n        # Evaluate extrapolation errors.\n        s_left = spline(x_left_target)\n        s_right = spline(x_right_target)\n        \n        f_left = true_func(x_left_target)\n        f_right = true_func(x_right_target)\n        \n        error_left = np.abs(s_left - f_left)\n        error_right = np.abs(s_right - f_right)\n        \n        errors_left.append(error_left)\n        errors_right.append(error_right)\n        \n        # --- Sensitivity Analysis: Right End ---\n        y_perturbed_right = y_nodes.copy()\n        y_perturbed_right[-1] += epsilon\n        \n        if bc_type == 'clamped':\n            # Per the problem, we keep the original boundary conditions.\n            spline_pert_right = CubicSpline(x_nodes, y_perturbed_right, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            spline_pert_right = CubicSpline(x_nodes, y_perturbed_right, bc_type=bc_type, extrapolate=True)\n        \n        s_pert_right = spline_pert_right(x_right_target)\n        sensitivity_right = np.abs(s_pert_right - s_right) / epsilon\n        sensitivities_right.append(sensitivity_right)\n        \n        # --- Sensitivity Analysis: Left End ---\n        y_perturbed_left = y_nodes.copy()\n        y_perturbed_left[0] += epsilon\n\n        if bc_type == 'clamped':\n            # Keeping the same boundary condition.\n            spline_pert_left = CubicSpline(x_nodes, y_perturbed_left, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            spline_pert_left = CubicSpline(x_nodes, y_perturbed_left, bc_type=bc_type, extrapolate=True)\n            \n        s_pert_left = spline_pert_left(x_left_target)\n        sensitivity_left = np.abs(s_pert_left - s_left) / epsilon\n        sensitivities_left.append(sensitivity_left)\n        \n    # Step 4: Assemble final results in the required list-of-lists format.\n    final_results = [\n        errors_right,\n        errors_left,\n        sensitivities_right,\n        sensitivities_left\n    ]\n    \n    # Final print statement must match the required format exactly.\n    # Convert list of lists to the string representation.\n    # Example: [[a,b,c],[d,e,f],[g,h,i],[j,k,l]]\n    result_str = f\"[{','.join(map(str, final_results))}]\"\n    # The default string representation of a list in Python is `[item1, item2, ...]`.\n    # We remove outer quotes and replace spaces for a compact representation.\n    result_str = str(final_results).replace(\" \", \"\")\n\n    print(result_str)\n```"
        }
    ]
}