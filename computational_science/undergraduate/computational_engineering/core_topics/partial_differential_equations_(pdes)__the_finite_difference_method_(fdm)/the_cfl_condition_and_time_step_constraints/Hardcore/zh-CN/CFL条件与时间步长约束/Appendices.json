{
    "hands_on_practices": [
        {
            "introduction": "在掌握如何确保稳定性之前，了解数值格式为何会轻易失效是极具启发性的。第一个练习  将引导你分析一个看似直观的前向时间、中心空间（FTCS）差分格式。通过基本的稳定性分析，你将亲自揭示为何这个看似合理的方法对于平流方程是无条件不稳定的，从而深刻理解精心设计数值格式的必要性。",
            "id": "2442990",
            "problem": "在周期性域 $x \\in [0,L]$ 上，给定一个波速为常数 $a$ 的一维线性平流方程：\n$$\nu_{t} + a\\,u_{x} = 0,\n$$\n网格为均匀网格 $x_{j} = j\\,\\Delta x$（$j$ 为整数），时间层为 $t^{n} = n\\,\\Delta t$（$n$ 为整数）。考虑显式向前时间、中心空间格式\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right).\n$$\n令库朗数 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$，并考虑一个无量纲波数为 $\\theta \\in [0,\\pi]$ 的离散傅里叶模态。将此格式在该模态上的单步放大因子定义为 $G(C,\\theta)$，即 $u_{j}^{n+1} = G(C,\\theta)\\,u_{j}^{n}$，并令\n$$\nS(C) = \\max_{\\theta \\in [0,\\pi]} \\left|G(C,\\theta)\\right|.\n$$\n求 $S(C)$ 的闭式解。请以关于 $C$ 的单个解析表达式的形式给出最终答案。无需四舍五入，且答案是无量纲的。",
            "solution": "该问题要求确定应用于一维线性平流方程的显式向前时间、中心空间 (FTCS) 数值格式的最大单步放大因子 $S(C)$。此过程从 von Neumann 稳定性分析开始。\n\n给定的数值格式为：\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right)\n$$\n库朗数定义为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$。将其代入格式中可得：\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\frac{C}{2}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right)\n$$\n对于 von Neumann 分析，我们考虑解的单个傅里叶模态。设在网格点 $j$ 和时间层 $n$ 的数值解表示为：\n$$\nu_{j}^{n} = \\hat{u}^{n}(k) e^{i k x_{j}}\n$$\n其中 $k$ 是波数，$x_{j} = j\\,\\Delta x$ 是空间坐标，$i = \\sqrt{-1}$。放大因子（为简单起见，我们将其记为 $G$）关联了连续时间步长上模态的振幅：\n$$\n\\hat{u}^{n+1}(k) = G \\, \\hat{u}^{n}(k)\n$$\n这意味着 $u_{j}^{n+1} = G \\, u_{j}^{n}$。我们也可以将相邻项写为：\n$$\nu_{j+1}^{n} = \\hat{u}^{n}(k) e^{i k (j+1)\\Delta x} = \\hat{u}^{n}(k) e^{i k j\\Delta x} e^{i k \\Delta x} = u_{j}^{n} e^{i k \\Delta x}\n$$\n$$\nu_{j-1}^{n} = \\hat{u}^{n}(k) e^{i k (j-1)\\Delta x} = \\hat{u}^{n}(k) e^{i k j\\Delta x} e^{-i k \\Delta x} = u_{j}^{n} e^{-i k \\Delta x}\n$$\n将这些表达式代入数值格式可得：\n$$\nG \\, u_{j}^{n} = u_{j}^{n} - \\frac{C}{2}\\left(u_{j}^{n} e^{i k \\Delta x} - u_{j}^{n} e^{-i k \\Delta x}\\right)\n$$\n对于非平凡解 ($u_{j}^{n} \\neq 0$)，我们可以将整个方程除以 $u_{j}^{n}$ 来求解放大因子 $G$：\n$$\nG = 1 - \\frac{C}{2}\\left(e^{i k \\Delta x} - e^{-i k \\Delta x}\\right)\n$$\n使用欧拉恒等式 $e^{i\\phi} - e^{-i\\phi} = 2i\\sin(\\phi)$，我们可以简化括号中的表达式：\n$$\ne^{i k \\Delta x} - e^{-i k \\Delta x} = 2i\\sin(k \\Delta x)\n$$\n这导出了放大因子的以下表达式：\n$$\nG = 1 - \\frac{C}{2} \\left(2i\\sin(k \\Delta x)\\right) = 1 - iC\\sin(k \\Delta x)\n$$\n问题指定使用无量纲波数 $\\theta = k \\Delta x$，其中 $\\theta \\in [0, \\pi]$。作为 $C$ 和 $\\theta$ 的函数的放大因子是：\n$$\nG(C, \\theta) = 1 - iC\\sin(\\theta)\n$$\n这是一个复数，其实部为 $1$，虚部为 $-C\\sin(\\theta)$。放大因子的模 $|G(C, \\theta)|$ 计算如下：\n$$\n|G(C, \\theta)| = \\sqrt{(\\text{Re}(G))^2 + (\\text{Im}(G))^2} = \\sqrt{(1)^2 + (-C\\sin(\\theta))^2} = \\sqrt{1 + C^2\\sin^2(\\theta)}\n$$\n问题要求解 $S(C) = \\max_{\\theta \\in [0,\\pi]} |G(C,\\theta)|$。为求此最大值，我们需要在区间 $[0, \\pi]$ 上对关于 $\\theta$ 的表达式 $\\sqrt{1 + C^2\\sin^2(\\theta)}$ 进行最大化。由于平方根函数对于非负自变量是单调递增的，最大化 $|G(C,\\theta)|$ 等价于最大化其平方 $|G(C,\\theta)|^2 = 1 + C^2\\sin^2(\\theta)$。\n\n表达式 $1 + C^2\\sin^2(\\theta)$ 仅通过 $\\sin^2(\\theta)$ 项依赖于 $\\theta$。我们需要找到当 $\\theta \\in [0, \\pi]$ 时 $\\sin^2(\\theta)$ 的最大值。函数 $\\sin(\\theta)$ 在此区间内的 $\\theta = \\frac{\\pi}{2}$ 处取得其最大值 $1$。因此，$\\sin^2(\\theta)$ 的最大值也为 $1$，同样在 $\\theta = \\frac{\\pi}{2}$ 处取得。\n\n因此，$|G(C,\\theta)|^2$ 的最大值是：\n$$\n\\max_{\\theta \\in [0,\\pi]} \\left(1 + C^2\\sin^2(\\theta)\\right) = 1 + C^2 (\\max_{\\theta \\in [0,\\pi]} \\sin^2(\\theta)) = 1 + C^2(1) = 1 + C^2\n$$\n量 $S(C)$ 是这个最大值的平方根：\n$$\nS(C) = \\sqrt{1 + C^2}\n$$\n此结果表明，对于任何非零库朗数 $C$，放大因子的模对于某些波数（具体而言，对于任何满足 $\\sin(\\theta) \\neq 0$ 的 $\\theta$）都大于 $1$，这表明 FTCS 格式对于线性平流方程是无条件不稳定的。然而，问题只要求 $S(C)$ 的闭式表达式。",
            "answer": "$$\\boxed{\\sqrt{1+C^2}}$$"
        },
        {
            "introduction": "虽然CFL条件保证了像一阶迎风格式这类方法的稳定性，但它并不保证计算的精度。这个动手编程练习  将让你探索一个关键且不那么直观的概念：一个极小的时间步长，虽然完全满足稳定性要求，却可能因累积的数值耗散而导致糟糕的精度。通过比较不同库朗数下的模拟结果，你将对稳定性与精度之间的权衡有一个实践性的理解。",
            "id": "2443006",
            "problem": "考虑周期域上的一维线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其平流速度为常数 $a > 0$，空间周期为 $L$。设空间网格为均匀网格，有 $N$ 个点，网格间距为 $\\Delta x = L/N$，网格点为 $x_i = i\\,\\Delta x$，$i \\in \\{0,1,\\dots,N-1\\}$。定义 Courant 数为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$，其中 $\\Delta t$ 是时间步长。考虑 $a>0$ 的显式一阶迎风格式更新，\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; C\\left(u_i^n - u_{i-1}^n\\right),\n$$\n采用周期性索引，使得 $u_{-1}^n = u_{N-1}^n$。设时间 $t$ 的精确解为 $u(x,t) = u_0\\!\\left((x - a t) \\bmod L\\right)$，其中 $u_0(x)$ 是初始条件。\n\n您必须编写一个完整的、可运行的程序，对于固定的无量纲配置，\n- $L = 1$，\n- $a = 1$，\n- $N = 128$，\n- 最终目标时间 $T = 0.02$，\n对下面列出的每个测试用例执行以下操作：\n1. 使用测试用例的 $C$ 值，设置 $\\Delta x = L/N$ 和 $\\Delta t = C\\,\\Delta x / a$。\n2. 令 $n_{\\text{steps}} = \\text{round}\\!\\left(T/\\Delta t\\right)$ 为整数时间步数。从指定的初始条件 $u_0(x)$ 开始，将给定格式精确推进 $n_{\\text{steps}}$ 步，以获得时间 $t' = n_{\\text{steps}} \\Delta t$ 时的数值解。\n3. 计算时间 $t'$ 时的精确解 $u_{\\text{exact}}(x_i,t') = u_0\\!\\left((x_i - a t') \\bmod L\\right)$。\n4. 计算离散、归一化的 $\\ell^2$ 误差\n$$\nE = \\frac{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}.\n$$\n所有变量均为无量纲；无需物理单位。\n\n测试套件（每一项都是由一个初始条件和一个 Courant 数定义的独立测试用例）：\n- 平滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，$C = 0.9$。\n- 平滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，$C = 0.5$。\n- 平滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，$C = 0.1$。\n- 平滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，$C = 10^{-4}$。\n- 不连续初始条件\n$$\nu_0(x) =\n\\begin{cases}\n1,  0.25 \\le x  0.75, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n$C = 0.9$。\n- 同上的不连续初始条件，$C = 0.5$。\n- 同上的不连续初始条件，$C = 0.1$。\n- 同上的不连续初始条件，$C = 10^{-4}$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n$$\n\\big[ E_{\\text{smooth},\\,0.9},\\; E_{\\text{smooth},\\,0.5},\\; E_{\\text{smooth},\\,0.1},\\; E_{\\text{smooth},\\,10^{-4}},\\; E_{\\text{box},\\,0.9},\\; E_{\\text{box},\\,0.5},\\; E_{\\text{box},\\,0.1},\\; E_{\\text{box},\\,10^{-4}} \\big].\n$$\n每个条目必须是浮点数。该测试套件旨在揭示，尽管对于所有 $C \\in (0,1]$ 都稳定，但过小的 $C$ 值（例如 $C = 10^{-4}$）会降低精度，因为即使在固定网格上，格式引起的累积扩散在整个积分时间内也很大。",
            "solution": "我们分析用于一维线性平流方程的一阶迎风法。平流方程为\n$$\nu_t + a u_x = 0,\n$$\n$a  0$。在均匀网格 $x_i = i\\,\\Delta x$ 上，显式迎风格式更新为\n$$\nu_i^{n+1} = u_i^n - C\\left(u_i^n - u_{i-1}^n\\right),\n$$\n其中 Courant 数为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$，并使用周期性索引，使得 $u_{-1}^n = u_{N-1}^n$。在 Courant–Friedrichs–Lewy (CFL) 条件下，该格式对于所有 $C \\in (0,1]$ 都是单调且稳定的。\n\n理解其精度影响的一个基本方法是通过修正方程。在时间和空间上进行泰勒展开并匹配各项。迎风法的主阶修正方程为\n$$\nu_t + a u_x = \\nu_{\\text{num}}\\,u_{xx} + \\mathcal{O}(\\Delta x^2, \\Delta t^2),\n$$\n其中，格式引起的数值扩散系数为\n$$\n\\nu_{\\text{num}} = \\frac{a\\,\\Delta x}{2}\\,(1 - C).\n$$\n这表明离散化表现为带有附加扩散项的平流：在固定的 $\\Delta x$ 和 $a$ 条件下，$C$ 越小，$\\nu_{\\text{num}}$ 越大，当 $C \\to 0$ 时，$\\nu_{\\text{num}} \\approx \\frac{a\\,\\Delta x}{2}$。相反，当 $C \\to 1$ 时，$\\nu_{\\text{num}} \\to 0$，这解释了一个众所周知的事实，即一阶迎风格式在 $C=1$ 附近扩散性最小。在固定的物理时长内，累积扩散随 $\\nu_{\\text{num}}$ 增长，因此在固定网格上，随着 $C$ 的减小而增加，导致尽管稳定但精度较差。\n\n我们也可以在傅里叶域中分析该格式。对于离散傅里叶模 $e^{\\mathrm{i}\\theta i}$（其中 $\\theta \\in [-\\pi,\\pi]$），迎风格式的放大因子为\n$$\nG(\\theta) = (1 - C) + C\\,e^{-\\mathrm{i}\\theta}.\n$$\n其模长为\n$$\n|G(\\theta)| = \\sqrt{(1 - C + C\\cos\\theta)^2 + (C\\sin\\theta)^2} \\le 1,\n$$\n仅当 $\\theta = 0$ 或 $C = 1$ 时等号成立。对于 $C \\in (0,1)$ 和 $\\theta \\ne 0$，我们有 $|G(\\theta)|  1$，这会衰减模态并模拟扩散。经过 $n$ 个时间步长，该模态乘以 $G(\\theta)^n$，在连续统中对应于一个近似于 $\\exp\\left(-\\nu_{\\text{num}} k^2 t\\right)$ 的有效扩散衰减，其中 $k = \\theta/\\Delta x$ 且 $t = n\\Delta t$。\n\n为了计算效率和相对于周期网格上离散格式的精确性，我们避免显式地迭代 $n$ 步。取而代之的是，我们计算初始数据的离散傅里叶变换，将每个傅里叶系数乘以 $G(\\theta)^n$，然后应用逆变换以获得 $n$ 步后的数值解：\n$$\n\\widehat{u}^{\\,n}_m = \\left(G(\\theta_m)\\right)^n \\widehat{u}^{\\,0}_m, \\quad \\theta_m = \\frac{2\\pi m}{N},\n$$\n其中 $m$ 索引了快速傅里叶变换标准排序下的离散傅里叶模。此过程提供了线性格式在周期性网格上经过 $n$ 步后的精确结果，避免了多次时间循环迭代带来的舍入误差累积。\n\n对于每个测试用例，我们按以下步骤进行：\n1. 设置 $L = 1$、$a = 1$、$N = 128$、$\\Delta x = L/N$ 和目标 Courant 数 $C$。\n2. 设置 $\\Delta t = C\\,\\Delta x / a$。计算 $n_{\\text{steps}} = \\operatorname{round}(T/\\Delta t)$ 和 $t' = n_{\\text{steps}}\\Delta t$。\n3. 按规定定义初始条件 $u_0(x)$。对于平滑情况，$u_0(x) = \\sin(2\\pi x)$。对于不连续（方波）情况，\n$$\nu_0(x) = \\begin{cases}\n1,  0.25 \\le x  0.75, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n4. 计算在 $t'$ 时的精确解：$u_{\\text{exact}}(x_i, t') = u_0\\!\\left((x_i - a t') \\bmod L\\right)$。\n5. 通过应用如上所述的放大因子为 $G(\\theta_m)$ 的格式谱形式，计算 $n_{\\text{steps}}$ 步后的数值解。\n6. 计算归一化的离散 $\\ell^2$ 误差\n$$\nE = \\frac{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}.\n$$\n\n因为在 $\\Delta x$ 固定的情况下，$\\nu_{\\text{num}}$ 随 $C$ 的减小而增大，我们预计当 $C$ 接近 1 时误差最小，并且当 $C$ 减小到 $0.5$，然后到 $0.1$，特别是到 $10^{-4}$ 时，误差会增加。这对于平滑和不连续的初始数据都成立，其中不连续的情况表现出更强的可见模糊效应，这是由于其高频模态含量较高，而当 $C$ 非常小时，这些模态被 $|G(\\theta)|^n$ 更严重地衰减。程序实现了这一逻辑，并以所要求的单行列表格式报告了八个指定测试用例的误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef initial_condition(x, kind):\n    if kind == \"smooth\":\n        return np.sin(2.0 * np.pi * x)\n    elif kind == \"box\":\n        # Indicator: 1 on [0.25, 0.75), 0 elsewhere\n        return ((x >= 0.25)  (x  0.75)).astype(float)\n    else:\n        raise ValueError(\"Unknown initial condition kind.\")\n\ndef exact_solution(x, t, a, L, kind):\n    # Periodic shift by a*t\n    x_shift = (x - a * t) % L\n    return initial_condition(x_shift, kind)\n\ndef upwind_after_n_steps_fft(u0, C, nsteps):\n    \"\"\"\n    Compute the result of nsteps of explicit upwind for a>0 on a periodic grid\n    by applying the scheme's amplification factor in Fourier space.\n    \"\"\"\n    N = u0.size\n    # Discrete Fourier mode angles theta_m = 2*pi*m/N in FFT ordering.\n    m = np.fft.fftfreq(N, d=1.0 / N)  # integer mode indices in FFT order\n    theta = 2.0 * np.pi * m / N\n    G = (1.0 - C) + C * np.exp(-1j * theta)\n    # Raise symbol to power nsteps; this is exact for the linear scheme.\n    G_n = G ** int(nsteps)\n    U0 = np.fft.fft(u0)\n    Un = np.fft.ifft(G_n * U0).real\n    return Un\n\ndef normalized_l2_error(u_num, u_ex):\n    diff = u_num - u_ex\n    num = np.sqrt(np.mean(diff * diff))\n    den = np.sqrt(np.mean(u_ex * u_ex))\n    # To avoid division by zero in degenerate cases\n    if den == 0.0:\n        return float(num)\n    return float(num / den)\n\ndef solve():\n    # Fixed configuration (nondimensional)\n    L = 1.0\n    a = 1.0\n    N = 128\n    T = 0.02\n    dx = L / N\n    x = np.linspace(0.0, L, N, endpoint=False)\n\n    # Test suite: list of (initial_condition_kind, Courant number)\n    test_cases = [\n        (\"smooth\", 0.9),\n        (\"smooth\", 0.5),\n        (\"smooth\", 0.1),\n        (\"smooth\", 1e-4),\n        (\"box\", 0.9),\n        (\"box\", 0.5),\n        (\"box\", 0.1),\n        (\"box\", 1e-4),\n    ]\n\n    results = []\n    for kind, C in test_cases:\n        dt = C * dx / a\n        # Integer number of steps; use round to get the nearest integer\n        nsteps = int(np.round(T / dt)) if dt > 0 else 0\n        # Actual time reached\n        t_prime = nsteps * dt\n\n        # Initial condition and exact solution at t_prime\n        u0 = initial_condition(x, kind)\n        u_exact = exact_solution(x, t_prime, a, L, kind)\n\n        # Numerical solution after nsteps using FFT representation\n        u_num = upwind_after_n_steps_fft(u0, C, nsteps)\n\n        # Normalized L2 error\n        E = normalized_l2_error(u_num, u_exact)\n        results.append(E)\n\n    # Final print statement in the exact required format.\n    print(\"[\" + \",\".join(f\"{val:.12g}\" for val in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在真实的模拟场景中，诸如波速之类的物理条件是会变化的，这使得固定时间步长变得低效甚至不安全。最后的这个练习  将挑战你应用所学知识，构建一个自适应时间步长控制器。你需要将核心的CFL原理转化为一个动态算法，该算法能够自动调整时间步长以维持一个目标库朗数，并集成专业工程软件中常见的实用约束条件。",
            "id": "2443027",
            "problem": "为一个一维显式格式实现一个自适应时间步长控制器。该格式用于推进一个双曲守恒律，其中信息以速度 $V(t) \\ge 0$ 沿特征线传播。数值网格间距是均匀的 $\\,\\Delta x\\,$，显式时间积分器在时间 $\\,t_n\\,$ 处以步长 $\\,\\Delta t_n\\,$ 向前推进。Courant–Friedrichs–Lewy (CFL) 条件要求数值依赖域必须包含物理依赖域，这对比值为 $\\,\\sigma_n = V(t_n)\\,\\Delta t_n / \\Delta x\\,$ 的无量纲 Courant 数 $\\,\\sigma_n\\,$ 施加了限制。在本问题中，您将从第一性原理出发，推导如何维持一个目标 Courant 数 $\\,\\sigma_\\star \\in (0,1)\\,$，并实现一个施加了额外实际约束的自适应控制器。\n\n您必须设计一个控制器，在每个被接受的时间 $\\,t_n\\,$ 处：\n- 根据 CFL 思想，使用瞬时特征速度 $\\,V(t_n)\\,$ 计算一个候选步长 $\\,\\Delta t^{\\text{cand}}_{n+1}\\,$，目标是使 $\\,\\sigma_{n+1}\\,$ 接近一个固定的目标值 $\\,\\sigma_\\star\\,$。\n- 强制施加步长下界和上界 $\\,\\Delta t_{\\min} \\le \\Delta t_{n+1} \\le \\Delta t_{\\max}\\,$，其中 $\\,\\Delta t_{\\min}  0\\,$ 且 $\\,\\Delta t_{\\max} \\ge \\Delta t_{\\min}\\,$，单位为秒。\n- 强制施加一个步长变化限制器 $\\,\\varrho \\ge 1\\,$，使得连续步长满足 $\\,\\Delta t_{n+1} \\le \\varrho\\,\\Delta t_n\\,$ 和 $\\,\\Delta t_{n+1} \\ge \\Delta t_n/\\varrho\\,$，从而防止突变。\n- 应用终端上限，以使时间不会超过预设的最终时间 $\\,t_{\\text{end}}\\,$；也就是说，如果 $\\,t_n + \\Delta t_{n+1}  t_{\\text{end}}\\,$，则用 $\\,t_{\\text{end}} - t_n\\,$ 替换 $\\,\\Delta t_{n+1}\\,$。终端上限可能会违反下界和变化限制器，但其值不得为负。\n- 将 $\\,V(t_n) = 0\\,$ 的情况视为不施加 CFL 限制，因此目标是在满足上下界、变化限制器和终端上限的前提下，采用允许的最大步长。\n\n从 Courant 数的定义和双曲问题的依赖域概念开始。除了它是一个带有标准 CFL 型限制的显式格式外，不要假设任何特定的有限差分模板。在不预先引用目标公式的情况下，推导与这些原则一致的控制器公式。清楚地证明您所实现的 $\\,\\Delta t^{\\text{cand}}_{n+1}\\,$ 为何具有您所选择的形式。\n\n为了验证，实现一个程序，通过根据控制器重复选择 $\\,\\Delta t_n\\,$ 并记录每个被接受的步长（包括终端步长）处的实际 Courant 数 $\\,\\sigma_n = V(t_n)\\,\\Delta t_n/\\Delta x\\,$，来将时间从 $\\,t_0\\,$ 积分到 $\\,t_{\\text{end}}\\,$。对于每个测试用例，报告以下列表：\n- 接受的步数（整数） $\\,N\\,$。\n- 实现的最大 Courant 数 $\\,\\max_n \\sigma_n\\,$ (无量纲)。\n- 实现的最小 Courant 数 $\\,\\min_n \\sigma_n\\,$ (无量纲)。\n- 实现的 Courant 数的算术平均值 $\\,\\frac{1}{N}\\sum_{n=1}^{N} \\sigma_n\\,$ (无量纲)。\n- 最后一个接受的步长大小 $\\,\\Delta t_N\\,$ (单位：秒)。\n\n所有物理量必须使用国际单位制。特别地，$\\,\\Delta x\\,$ 以米表示，$\\,V(t)\\,$ 以米/秒表示，$\\,\\Delta t\\,$ 以秒表示，$\\,t\\,$ 以秒表示。当出现三角函数时，其参数必须以弧度为单位。\n\n测试套件。使用以下三种情况，每种情况都有一个速度函数 $\\,V(t)\\,$、一个目标 $\\,\\sigma_\\star\\,$、界限 $\\,\\Delta t_{\\min}\\,$ 和 $\\,\\Delta t_{\\max}\\,$、一个步长变化限制器 $\\,\\varrho\\,$、一个空间步长 $\\,\\Delta x\\,$ 和一个时间区间 $[t_0, t_{\\text{end}}]$：\n- 情况 A (理想情况，恒定速度)：\n  - $\\,\\Delta x = 0.5\\,\\text{m}\\,$, $\\,\\sigma_\\star = 0.8\\,$, $\\,\\Delta t_{\\min} = 0.01\\,\\text{s}\\,$, $\\,\\Delta t_{\\max} = 1.0\\,\\text{s}\\,$, $\\,\\varrho = 1.5\\,$, $\\,t_0 = 0.0\\,\\text{s}\\,$, $\\,t_{\\text{end}} = 5.0\\,\\text{s}\\,$,\n  - 对所有 $\\,t\\,$，$\\,V(t) = 1.25\\,\\text{m}/\\text{s}\\,$。\n- 情况 B (速度随时间有界变化，角度单位为弧度)：\n  - $\\,\\Delta x = 0.2\\,\\text{m}\\,$, $\\,\\sigma_\\star = 0.9\\,$, $\\,\\Delta t_{\\min} = 0.001\\,\\text{s}\\,$, $\\,\\Delta t_{\\max} = 0.08\\,\\text{s}\\,$, $\\,\\varrho = 1.1\\,$, $\\,t_0 = 0.0\\,\\text{s}\\,$, $\\,t_{\\text{end}} = 1.0\\,\\text{s}\\,$,\n  - $\\,V(t) = 0.5 + 0.45 \\sin(2\\pi t)\\,$，单位为米/秒，其中 $\\,2\\pi t\\,$ 以弧度为单位。\n- 情况 C (速度在某个子区间内消失)：\n  - $\\,\\Delta x = 1.0\\,\\text{m}\\,$, $\\,\\sigma_\\star = 0.7\\,$, $\\,\\Delta t_{\\min} = 0.05\\,\\text{s}\\,$, $\\,\\Delta t_{\\max} = 0.5\\,\\text{s}\\,$, $\\,\\varrho = 1.2\\,$, $\\,t_0 = 0.0\\,\\text{s}\\,$, $\\,t_{\\text{end}} = 2.0\\,\\text{s}\\,$,\n  - $\\,V(t) = \\max\\{0,\\, 1.0 - 0.8\\,t\\}\\,$，单位为米/秒。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个情况产生一个列表 $[N,\\max\\sigma,\\min\\sigma,\\overline{\\sigma},\\Delta t_N]$。例如，输出格式必须为 $[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,]$ 的形式，不含额外文本。所有 $\\,\\Delta t\\,$ 值必须以秒为单位，所有 Courant 数均为无量纲。报告的每个量必须是布尔值、整数、浮点数或这些基本类型的列表。",
            "solution": "所述问题在科学上是合理的、适定的，并包含了推导和实现自适应时间步长控制器所需的所有必要信息。因此，该问题被认为是有效的。我们着手进行求解。\n\nCourant–Friedrichs–Lewy (CFL) 条件是用于求解双曲偏微分方程的显式数值格式的一个基本稳定性判据。它源于这样一个原理：数值算法必须能够获取确定未来某一时刻状态所需的所有物理信息。对于一维双曲系统，信息以有限速度沿特征线传播，我们将其表示为 $V(t) \\ge 0$。点 $(x_j, t_{n+1})$ 的物理依赖域是在前一时刻 $t_n$ 上能够影响它的点的集合。对于以速度 $V$ 传播的波，假设 $V$ 在小的时间间隔 $\\Delta t_n = t_{n+1} - t_n$ 内是恒定的，那么在时间 $t_n$ 上的这个域是区间 $[x_j - V(t_n) \\Delta t_n, x_j + V(t_n) \\Delta t_n]$。一个显式数值格式使用来自时间 $t_n$ 处有限数量的相邻网格点（例如 $\\{x_{j-k}, \\ldots, x_{j+k}\\}$）的信息来计算 $(x_j, t_{n+1})$ 处的解。数值依赖域是跨越这些点的区间 $[x_{j-k}, x_{j+k}]$。CFL 条件要求物理依赖域被包含在数值依赖域之内。对于一个标准的最近邻模板 ($k=1$)，这意味着 $V(t_n) \\Delta t_n \\le \\Delta x$。这可以用无量纲 Courant 数 $\\sigma_n$ 来表示：\n$$ \\sigma_n = \\frac{V(t_n) \\Delta t_n}{\\Delta x} \\le 1 $$\n为了保证稳定性，$\\sigma_n$ 不能超过某个限制，通常是 $1$。为了提高效率，希望使用允许的最大时间步长，这意味着 $\\sigma_n$ 应该接近这个限制。自适应时间步长控制器旨在将 $\\sigma_n$ 维持在一个目标值 $\\sigma_\\star \\in (0, 1)$ 附近，其中 $\\sigma_\\star  1$ 提供了一个安全裕度。\n\n我们的任务是设计一个在当前时间 $t_n$ 选择时间步长 $\\Delta t_{n+1}$ 的控制器。我们的目标是使后续的 Courant 数 $\\sigma_{n+1} = V(t_{n+1}) \\Delta t_{n+1} / \\Delta x$ 大约等于 $\\sigma_\\star$。由于我们在时间 $t_n$ 不知道 $V(t_{n+1})$，我们使用可用的信息 $V(t_n)$ 作为区间 $[t_n, t_{n+1}]$ 上特征速度的最佳估计。因此，我们的目标是：\n$$ \\sigma_\\star \\approx \\frac{V(t_n) \\Delta t_{n+1}}{\\Delta x} $$\n求解 $\\Delta t_{n+1}$，我们得到完全基于 CFL 条件的候选时间步长：\n$$ \\Delta t^{\\text{cand}}_{n+1} = \\sigma_\\star \\frac{\\Delta x}{V(t_n)} $$\n该公式在 $V(t_n)  0$ 时有效。如果 $V(t_n) = 0$，则特征线在 $x$-$t$ 平面中是垂直的，没有空间上的传播。CFL 条件对 $\\Delta t$ 不施加上限。在这种情况下，问题陈述我们应力求采用允许的最大步长，这将由其他约束条件决定。一种实际的实现方法是，当 $V(t_n) = 0$ 时，将候选步长设置为允许的最大步长 $\\Delta t_{\\max}$。\n\n此候选步长随后必须受到一系列实际约束，以确保积分过程的鲁棒性和平滑性：\n\n1.  **步长变化限制器**：为防止时间步长发生突兀的、可能破坏稳定性的变化，我们强制要求连续步长的比率受限于一个因子 $\\varrho \\ge 1$。对于 $n \\ge 1$，$ \\Delta t_n$ 是前一步的步长，下一步的步长 $\\Delta t_{n+1}$ 必须满足：\n    $$ \\frac{\\Delta t_n}{\\varrho} \\le \\Delta t_{n+1} \\le \\varrho \\Delta t_n $$\n    此限制器不适用于第一个时间步长 $\\Delta t_1$，因为没有前一步长 $\\Delta t_0$。\n\n2.  **绝对步长界限**：无论其他因素如何，时间步长也必须位于一个固定的范围内：\n    $$ \\Delta t_{\\min} \\le \\Delta t_{n+1} \\le \\Delta t_{\\max} $$\n    其中 $\\Delta t_{\\min}  0$ 确保时间向前推进。\n\n3.  **终端上限**：为确保模拟在最终时间 $t_{\\text{end}}$ 精确停止，最后一步必须进行调整以防过冲。如果一个本来可接受的步长 $\\Delta t'_{n+1}$ 会导致 $t_n + \\Delta t'_{n+1}  t_{\\text{end}}$，那么必须将其替换为 $\\Delta t_{n+1} = t_{\\text{end}} - t_n$。这最后的调整具有最高优先级，并可能导致步长小于 $\\Delta t_{\\min}$ 或违反步长变化限制器。\n\n结合这些约束，我们形成一个完整的算法，用于在时间 $t_n$ 处选择 $\\Delta t_{n+1}$，给定前一步长 $\\Delta t_n$（对于 $n \\ge 1$）：\n\n首先，我们确定候选步长 $\\Delta t_{\\text{cand}}$：\n$$ \\Delta t_{\\text{cand}} = \\begin{cases} \\sigma_\\star \\frac{\\Delta x}{V(t_n)},  \\text{若 } V(t_n)  0 \\\\ \\Delta t_{\\max},  \\text{若 } V(t_n) = 0 \\end{cases} $$\n接下来，在应用终端上限之前，我们定义步长的下界和上界。设 $\\Delta t_{\\text{lower}}$ 和 $\\Delta t_{\\text{upper}}$ 为这些界限。初始时，它们由绝对限制设定：$\\Delta t_{\\text{lower}} = \\Delta t_{\\min}$ 和 $\\Delta t_{\\text{upper}} = \\Delta t_{\\max}$。如果不是第一步 ($n \\ge 1$)，步长变化限制器会进一步约束这些界限：\n$$ \\Delta t_{\\text{lower}} \\leftarrow \\max(\\Delta t_{\\text{lower}}, \\Delta t_n / \\varrho) $$\n$$ \\Delta t_{\\text{upper}} \\leftarrow \\min(\\Delta t_{\\text{upper}}, \\varrho \\Delta t_n) $$\n然后，通过将候选步长限制在这些界限内，找到初步步长 $\\Delta t'_{n+1}$：\n$$ \\Delta t'_{n+1} = \\max(\\Delta t_{\\text{lower}}, \\min(\\Delta t_{\\text{upper}}, \\Delta t_{\\text{cand}})) $$\n最后，应用终端上限来确定最终的步长 $\\Delta t_{n+1}$：\n$$ \\Delta t_{n+1} = \\min(\\Delta t'_{n+1}, t_{\\text{end}} - t_n) $$\n这个多阶段过程定义了一个鲁棒且确定性的时间步长控制器。\n\n模拟过程迭代进行。从 $t_0$ 开始，我们计算 $\\Delta t_1$（不使用步长变化限制器）。在每一步 $n=1, 2, \\dots, N$，我们在时间 $t_{n-1}$ 处计算 $\\Delta t_n$。我们记录实际的 Courant 数 $\\sigma_n = V(t_{n-1}) \\Delta t_n / \\Delta x$。然后，我们将时间推进到 $t_n = t_{n-1} + \\Delta t_n$，并存储 $\\Delta t_n$ 以用于下一步的变化限制器计算。此过程持续进行，直到 $t_n \\ge t_{\\text{end}}$。最终的统计数据——步数 $N$、$\\{\\sigma_n\\}$ 的最大值、最小值和平均值，以及最终步长 $\\Delta t_N$——则根据记录的历史数据计算得出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    # Define velocity functions for each case\n    def V_A(t: float) -> float:\n        \"\"\"Velocity for Case A: constant speed.\"\"\"\n        return 1.25\n\n    def V_B(t: float) -> float:\n        \"\"\"Velocity for Case B: time-varying speed.\"\"\"\n        return 0.5 + 0.45 * np.sin(2 * np.pi * t)\n\n    def V_C(t: float) -> float:\n        \"\"\"Velocity for Case C: speed with a zero interval.\"\"\"\n        return max(0.0, 1.0 - 0.8 * t)\n\n    def run_simulation(dx, sigma_star, dt_min, dt_max, rho, t_0, t_end, V_func):\n        \"\"\"\n        Performs the time integration with the adaptive step controller.\n\n        Args:\n            dx (float): Grid spacing.\n            sigma_star (float): Target Courant number.\n            dt_min (float): Minimum allowed time step.\n            dt_max (float): Maximum allowed time step.\n            rho (float): Step change limiter factor.\n            t_0 (float): Start time.\n            t_end (float): End time.\n            V_func (callable): Function V(t) for characteristic speed.\n\n        Returns:\n            list: A list containing [N, max_sigma, min_sigma, mean_sigma, last_dt].\n        \"\"\"\n        t = t_0\n        dt_prev = None\n        sigmas = []\n        num_steps = 0\n        last_dt = 0.0\n\n        # Use a small tolerance for floating-point comparisons to avoid issues near t_end\n        epsilon = 1e-12\n\n        while t  t_end - epsilon:\n            # 1. Compute candidate step from CFL condition\n            v_at_t = V_func(t)\n            if v_at_t > 0:\n                dt_cand = sigma_star * dx / v_at_t\n            else:  # v_at_t == 0, no CFL restriction, aim for largest step\n                dt_cand = dt_max\n\n            # 2. Determine constraint bounds from absolute limits and rate limiter\n            dt_upper_bound = dt_max\n            dt_lower_bound = dt_min\n            if dt_prev is not None:\n                dt_upper_bound = min(dt_upper_bound, rho * dt_prev)\n                dt_lower_bound = max(dt_lower_bound, dt_prev / rho)\n\n            # 3. Apply constraints by clamping the candidate step\n            dt_next = max(dt_lower_bound, min(dt_upper_bound, dt_cand))\n\n            # 4. Apply terminal cap: ensure the step does not overshoot t_end\n            dt_next = min(dt_next, t_end - t)\n\n            # Safeguard against non-positive steps after terminal cap\n            if dt_next = 0:\n                break\n\n            # 5. Record realized Courant number for the current step\n            realized_sigma = v_at_t * dt_next / dx\n            sigmas.append(realized_sigma)\n\n            # 6. Advance time and update state for the next iteration\n            t += dt_next\n            dt_prev = dt_next\n            last_dt = dt_next\n            num_steps += 1\n        \n        if not sigmas:  # Handle case of no steps being taken\n            return [0, 0.0, 0.0, 0.0, 0.0]\n\n        # Calculate final statistics\n        N = num_steps\n        max_sigma = max(sigmas)\n        min_sigma = min(sigmas)\n        mean_sigma = sum(sigmas) / N\n\n        return [N, max_sigma, min_sigma, mean_sigma, last_dt]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'dx': 0.5, 'sigma_star': 0.8, 'dt_min': 0.01, 'dt_max': 1.0, 'rho': 1.5, 't_0': 0.0, 't_end': 5.0, 'V_func': V_A},\n        # Case B\n        {'dx': 0.2, 'sigma_star': 0.9, 'dt_min': 0.001, 'dt_max': 0.08, 'rho': 1.1, 't_0': 0.0, 't_end': 1.0, 'V_func': V_B},\n        # Case C\n        {'dx': 1.0, 'sigma_star': 0.7, 'dt_min': 0.05, 'dt_max': 0.5, 'rho': 1.2, 't_0': 0.0, 't_end': 2.0, 'V_func': V_C}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_simulation(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}