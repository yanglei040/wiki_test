{
    "hands_on_practices": [
        {
            "introduction": "在计算工程中，数值方法的保真度至关重要，即其准确传递初始信息随时间演化的能力。本练习将通过一个包含多种空间尺度波动的初始条件，来检验一个数值格式的性能。通过求解线性平流方程，你将学习如何量化数值耗散和色散误差，这对于确保模拟结果能够准确反映物理现实至关重要 。",
            "id": "2403418",
            "problem": "考虑一个在周期性域上具有周期性边界条件的一维线性平流初值问题：寻找一个标量场 $u(x,t)$，它满足方程 $u_t + c\\,u_x = 0$（其中 $x \\in [0,2\\pi]$ 且 $t \\ge 0$），具有周期性边界条件 $u(0,t)=u(2\\pi,t)$（对于所有 $t \\ge 0$），以及一个包含大尺度分离的初值条件：$u(x,0) = A_1 \\cos(k_1 x) + A_2 \\cos(k_2 x)$。在这里，$x$ 的单位是弧度，$c$ 是一个恒定的平流速度，$A_1, A_2, k_1, k_2$ 是常数。目标是评估一个数值格式在同时输运长波（$k_1$）和短波（$k_2$）分量时的保真度。所有角度均使用弧度。\n\n您的任务如下，从第一性原理出发：\n1) 从偏微分方程 $u_t + c\\,u_x = 0$ 和周期性边界条件出发，推导给定初始条件下任意时间 $t \\ge 0$ 的精确解。将解表示为一种能清楚表明两种模式在输运过程中振幅不变的形式。\n2) 针对此初值问题，通过对固定网格点上的 $u(x,t)$ 进行时间上的泰勒展开，利用控制方程将时间导数替换为空间导数，并用中心有限差分逼近空间导数，推导一个二阶精度、显式、守恒的有限差分方法。以必须遵守以保持稳定性的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = \\dfrac{c\\,\\Delta t}{\\Delta x}$ 来陈述稳定性条件。\n3) 在一个包含 $N$ 个点 $x_j = j \\,\\Delta x$（其中 $j=0,1,\\dots,N-1$，$\\Delta x = \\dfrac{2\\pi}{N}$）的均匀网格上实现您推导的数值方法，并通过对 $N$ 取模来卷绕索引以实现周期性边界条件。使用由预设的 CFL 数 $\\nu$ 定义的时间步长 $\\Delta t = \\nu \\,\\dfrac{\\Delta x}{|c|}$。从 $t=0$ 推进到最终时间 $T$；如果 $T$ 不是 $\\Delta t$ 的整数倍，则使用一个缩短的最后一步，以确保解恰好在 $t=T$ 时刻报告。\n4) 对于给定的数值解 $u^{\\text{num}}(x_j,T)$ 和解析解 $u^{\\text{ex}}(x_j,T)$，计算由下式定义的相对离散 $L^2$ 误差：\n$$\nE_{L^2} = \\dfrac{\\left( \\sum_{j=0}^{N-1} \\left(u^{\\text{num}}(x_j,T) - u^{\\text{ex}}(x_j,T)\\right)^2 \\,\\Delta x \\right)^{1/2}}{\\left( \\sum_{j=0}^{N-1} \\left(u^{\\text{ex}}(x_j,T)\\right)^2 \\,\\Delta x \\right)^{1/2}}.\n$$\n5) 为了量化多尺度保真度，通过对 $\\cos(k_2 x)$ 和 $\\sin(k_2 x)$ 进行正交投影，从您的数值解中计算高波数模式 $k_2$ 的输运后振幅。具体来说，通过以下方式定义余弦和正弦系数的离散近似：\n$$\nC_{k} = \\dfrac{1}{\\pi} \\sum_{j=0}^{N-1} u^{\\text{num}}(x_j,T) \\cos(k x_j) \\,\\Delta x, \\quad S_{k} = \\dfrac{1}{\\pi} \\sum_{j=0}^{N-1} u^{\\text{num}}(x_j,T) \\sin(k x_j) \\,\\Delta x,\n$$\n并将在波数 $k$ 处的输运后振幅大小定义为 $\\widehat{A}_k = \\sqrt{C_k^2+S_k^2}$。将 $k_2$ 处的相对振幅误差报告为\n$$\nE_{\\text{amp}} = \\dfrac{|\\widehat{A}_{k_2} - A_2|}{A_2}。\n$$\n由于精确解在平流作用下保持了每个傅里叶模式的振幅，因此 $\\widehat{A}_{k_2}$ 与 $A_2$ 的任何偏差都反映了数值频散、耗散和/或混叠效应。\n\n实现一个完整的程序，该程序：\n- 使用上述方法和计算。\n- 应用以下参数值测试套件，每个测试定义一次独立的运行：\n  - 测试 1：$N=1024$, $c=1$, $\\nu=0.5$, $T=2.0$, $A_1=1$, $k_1=1$, $A_2=0.01$, $k_2=100$。\n  - 测试 2：$N=256$, $c=1$, $\\nu=0.99$, $T=5.0$, $A_1=1$, $k_1=1$, $A_2=0.01$, $k_2=100$。\n  - 测试 3：$N=128$, $c=1$, $\\nu=0.5$, $T=2.0$, $A_1=1$, $k_1=1$, $A_2=0.01$, $k_2=100$。\n  - 测试 4：$N=512$, $c=1$, $\\nu=0.7$, $T=2.0$, $A_1=1$, $k_1=1$, $A_2=0.0001$, $k_2=200$。\n  - 测试 5：$N=256$, $c=-1$, $\\nu=0.8$, $T=3.0$, $A_1=1$, $k_1=1$, $A_2=0.01$, $k_2=80$。\n\n对于每个测试，计算并收集两个浮点数：时间 $T$ 时的相对 $L^2$ 误差 $E_{L^2}$，以及时间 $T$ 时高波数模式 $k_2$ 的相对振幅误差 $E_{\\text{amp}}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个长度为 5 的列表。第 $i$ 个条目是测试 $i$ 的双元素列表 $[E_{L^2}, E_{\\text{amp}}]$，顺序如上所述。该行应严格格式化为 Python 风格的数值列表的列表，例如，$\\left[\\left[e_{11},e_{12}\\right],\\left[e_{21},e_{22}\\right],\\dots\\right]$。不应打印任何额外文本。\n- 所有计算都是无量纲的；将数字报告为无单位的浮点值。",
            "solution": "对问题陈述进行验证。\n\n### 第 1 步：提取给定条件\n\n-   **控制方程**：一维线性平流方程，$u_t + c\\,u_x = 0$。\n-   **域**：$x \\in [0,2\\pi]$ 且 $t \\ge 0$。\n-   **边界条件**：周期性，$u(0,t)=u(2\\pi,t)$ 对于所有 $t \\ge 0$。\n-   **初始条件**：$u(x,0) = A_1 \\cos(k_1 x) + A_2 \\cos(k_2 x)$。\n-   **常数**：平流速度 $c$，振幅 $A_1, A_2$，波数 $k_1, k_2$。波数为整数。\n-   **数值网格**：具有 $N$ 个点的均匀网格，$x_j = j \\,\\Delta x$ 对于 $j=0,1,\\dots,N-1$，其中 $\\Delta x = \\dfrac{2\\pi}{N}$。\n-   **时间步长**：$\\Delta t = \\nu \\,\\dfrac{\\Delta x}{|c|}$，其中 $\\nu$ 是预设的 Courant–Friedrichs–Lewy (CFL) 数。\n-   **最终时间**：$T$。\n-   **误差度量 1（相对 $L^2$ 误差）**：\n    $$\n    E_{L^2} = \\dfrac{\\left( \\sum_{j=0}^{N-1} \\left(u^{\\text{num}}(x_j,T) - u^{\\text{ex}}(x_j,T)\\right)^2 \\,\\Delta x \\right)^{1/2}}{\\left( \\sum_{j=0}^{N-1} \\left(u^{\\text{ex}}(x_j,T)\\right)^2 \\,\\Delta x \\right)^{1/2}}\n    $$\n-   **误差度量 2（相对振幅误差）**：\n    -   余弦系数：$C_{k} = \\dfrac{1}{\\pi} \\sum_{j=0}^{N-1} u^{\\text{num}}(x_j,T) \\cos(k x_j) \\,\\Delta x$。\n    -   正弦系数：$S_{k} = \\dfrac{1}{\\pi} \\sum_{j=0}^{N-1} u^{\\text{num}}(x_j,T) \\sin(k x_j) \\,\\Delta x$。\n    -   输运后振幅：$\\widehat{A}_k = \\sqrt{C_k^2+S_k^2}$。\n    -   相对误差：$E_{\\text{amp}} = \\dfrac{|\\widehat{A}_{k_2} - A_2|}{A_2}$。\n-   **测试套件**：提供了五组参数 $(N, c, \\nu, T, A_1, k_1, A_2, k_2)$。\n\n### 第 2 步：使用提取的给定条件进行验证\n\n-   **科学基础**：本问题涉及线性平流方程的数值解，这是物理学和工程学中的一个基本模型。指定的初始条件、边界条件和分析方法（有限差分、误差范数、傅里叶分析）都是标准的且被严格定义。问题不含伪科学。\n-   **适定的**：在周期域上具有光滑初始条件的一维线性平流方程构成了一个适定的初值问题。存在唯一的稳定解。\n-   **客观的**：问题以精确的数学语言表述。所有参数和度量均被客观定义。\n-   **完整且一致的**：提供了推导和实现解决方案所需的所有信息。五个测试案例的参数都已完全指定。波数 $k_1$ 和 $k_2$ 的整数性质与周期域 $[0, 2\\pi]$ 一致。\n-   **可行的**：参数值处于一个计算上可行且适合测试数值格式属性的范围内。\n-   **结构良好**：任务以逻辑顺序安排：首先，推导精确解以供参考；其次，推导数值方法；第三，实现它；最后，执行指定的误差分析。\n\n### 第 3 步：结论与行动\n\n该问题具有科学合理性、适定性和完整性。这是一个有效的计算工程问题。将提供一个解决方案。\n\n### 精确解的推导\n\n控制偏微分方程 (PDE) 是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\n该方程表明，沿着由 $\\frac{dx}{dt} = c$ 定义的特征线，$u(x(t), t)$ 的全导数为零。对特征线的这个关系进行积分，得到 $x - ct = x_0$，其中 $x_0$ 是一个常数。因此，解 $u$ 必须沿着这些特征线保持不变，这意味着解具有行波的一般形式：\n$$\nu(x,t) = f(x-ct)\n$$\n函数 $f$ 由 $t=0$ 时的初始条件确定：\n$$\nu(x,0) = f(x) = A_1 \\cos(k_1 x) + A_2 \\cos(k_2 x)\n$$\n将这种形式的 $f$ 代入通解，得到对于所有 $t \\ge 0$ 的精确解：\n$$\nu^{\\text{ex}}(x,t) = A_1 \\cos(k_1 (x-ct)) + A_2 \\cos(k_2 (x-ct))\n$$\n该表达式表明，两个初始余弦模式以速度 $c$ 被输运（平流），而它们各自的振幅 $A_1$ 和 $A_2$ 没有任何变化。解还必须满足周期性边界条件 $u(0,t) = u(2\\pi,t)$。为此，波数 $k_1$ 和 $k_2$ 必须是整数，这在问题的测试案例中已指定。\n\n### 数值方法的推导\n\n我们按照指定的过程推导一个二阶精度的有限差分格式。我们从 $u(x, t+\\Delta t)$ 在固定空间网格点 $x_j$ 处的时间泰勒级数展开开始：\n$$\nu(x_j, t+\\Delta t) = u(x_j, t) + \\Delta t \\, u_t(x_j, t) + \\frac{(\\Delta t)^2}{2} \\, u_{tt}(x_j, t) + O((\\Delta t)^3)\n$$\n令 $u_j^n$ 表示 $u(x_j, n\\Delta t)$ 的数值近似。离散更新写为：\n$$\nu_j^{n+1} = u_j^n + \\Delta t (u_t)_j^n + \\frac{(\\Delta t)^2}{2} (u_{tt})_j^n + O((\\Delta t)^3)\n$$\n利用控制方程 $u_t = -c u_x$ 将时间导数替换为空间导数：\n$$\nu_t = -c u_x\n$$\n$$\nu_{tt} = \\frac{\\partial}{\\partial t}(-c u_x) = -c \\frac{\\partial}{\\partial x}(u_t) = -c \\frac{\\partial}{\\partial x}(-c u_x) = c^2 u_{xx}\n$$\n将这些代入泰勒展开式得到：\n$$\nu_j^{n+1} = u_j^n - c \\Delta t (u_x)_j^n + \\frac{c^2 (\\Delta t)^2}{2} (u_{xx})_j^n + O((\\Delta t)^3)\n$$\n现在我们用二阶精度的中心有限差分来近似空间导数：\n$$\n(u_x)_j^n \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x}\n$$\n$$\n(u_{xx})_j^n \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n将这些近似代入时间展开的方程，得到显式格式：\n$$\nu_j^{n+1} = u_j^n - c \\Delta t \\left(\\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x}\\right) + \\frac{c^2 (\\Delta t)^2}{2} \\left(\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\\right)\n$$\n定义格式的 CFL 数 $\\nu_{\\text{sch}} = \\frac{c \\Delta t}{\\Delta x}$。方程可以重写为：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\nu_{\\text{sch}}}{2} (u_{j+1}^n - u_{j-1}^n) + \\frac{\\nu_{\\text{sch}}^2}{2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n这是 Lax-Wendroff 格式。按空间索引分组各项：\n$$\nu_j^{n+1} = \\left(\\frac{\\nu_{\\text{sch}}^2}{2} + \\frac{\\nu_{\\text{sch}}}{2}\\right) u_{j-1}^n + \\left(1 - \\nu_{\\text{sch}}^2\\right) u_j^n + \\left(\\frac{\\nu_{\\text{sch}}^2}{2} - \\frac{\\nu_{\\text{sch}}}{2}\\right) u_{j+1}^n\n$$\n此格式在空间和时间上都是守恒且二阶精度的。为了稳定性，冯·诺依曼分析表明 CFL 数必须满足：\n$$\n|\\nu_{\\text{sch}}| = \\frac{|c| \\Delta t}{\\Delta x} \\le 1\n$$\n在实现中，预设的 CFL 数为 $\\nu$，由此 $\\Delta t = \\nu \\frac{\\Delta x}{|c|}$。在格式公式中实际使用的 CFL 数是 $\\nu_{\\text{sch}} = \\frac{c \\Delta t}{\\Delta x} = \\frac{c}{\\Delta x} \\left(\\nu \\frac{\\Delta x}{|c|}\\right) = \\nu \\frac{c}{|c|} = \\nu \\cdot \\text{sign}(c)$。这必须用于系数的计算。\n\n### 实现与分析算法\n\n1.  **初始化**：对于每个测试案例，定义参数 $N, c, \\nu, T, A_1, k_1, A_2, k_2$。\n2.  **网格与初始条件**：构建空间网格 $x_j = j \\frac{2\\pi}{N}$ 对于 $j=0, \\dots, N-1$。对所有 $j$ 计算初始条件 $u^0_j = A_1 \\cos(k_1 x_j) + A_2 \\cos(k_2 x_j)$。\n3.  **时间步进**：\n    -   计算时间步长 $\\Delta t = \\nu \\frac{\\Delta x}{|c|}$。\n    -   确定完整步数 $n_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$，以及最后的畸零时间步长 $\\Delta t_{\\text{last}} = T - n_{\\text{steps}} \\Delta t$。\n    -   基于 $\\nu_{\\text{sch}} = \\nu \\cdot \\text{sign}(c)$ 计算完整步长的格式系数。\n    -   迭代 $n_{\\text{steps}}$ 次，在每一步中使用向量化的 Lax-Wendroff 公式更新解向量 $u$。周期性边界条件可通过使用 `numpy.roll` 高效处理数组元素的移位来实现。\n    -   如果 $\\Delta t_{\\text{last}} > 0$，则使用重新计算的 $\\nu_{\\text{sch,last}} = \\frac{c \\Delta t_{\\text{last}}}{\\Delta x}$ 及其相应的系数执行最后一次更新。\n4.  **误差计算**：\n    -   在最终时间 $T$，数值解为 $u^{\\text{num}}(x_j, T)$。\n    -   在网格上计算精确解：$u^{\\text{ex}}(x_j,T) = A_1 \\cos(k_1(x_j-cT)) + A_2 \\cos(k_2(x_j-cT))$。\n    -   使用向量范数的比值计算相对 $L^2$ 误差 $E_{L^2} = \\frac{\\|u^{\\text{num}} - u^{\\text{ex}}\\|_2}{\\|u^{\\text{ex}}\\|_2}$。\n    -   根据给定公式，通过将数值解与余弦和正弦基函数求和，计算离散傅里叶系数 $C_{k_2}$ 和 $S_{k_2}$。\n    -   由此计算输运后振幅 $\\widehat{A}_{k_2} = \\sqrt{C_{k_2}^2+S_{k_2}^2}$。\n    -   最后，计算相对振幅误差 $E_{\\text{amp}} = \\frac{|\\widehat{A}_{k_2} - A_2|}{A_2}$。\n5.  **输出**：为每个测试案例收集数据对 $[E_{L^2}, E_{\\text{amp}}]$，并将最终输出格式化为单行的 Python 风格的列表的列表。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, c, nu_cfl, T, A1, k1, A2, k2):\n    \"\"\"\n    Runs a single simulation of the 1D linear advection equation.\n    \n    Args:\n        N (int): Number of grid points.\n        c (float): Advection speed.\n        nu_cfl (float): Prescribed CFL number for time step calculation.\n        T (float): Final time.\n        A1, k1 (float, int): Amplitude and wavenumber for the long wave.\n        A2, k2 (float, int): Amplitude and wavenumber for the short wave.\n    \n    Returns:\n        list: A two-element list [E_L2, E_amp].\n    \"\"\"\n    # 1. Grid and Initial Condition\n    delta_x = 2.0 * np.pi / N\n    x = np.arange(N) * delta_x\n    u = A1 * np.cos(k1 * x) + A2 * np.cos(k2 * x)\n\n    # 2. Time Stepping\n    # Handle the case c=0 to avoid division by zero, although not in test cases.\n    if abs(c)  1e-12:\n        num_steps = 0\n        last_dt = 0.0\n        delta_t = np.inf\n    else:\n        delta_t = nu_cfl * delta_x / abs(c)\n        if delta_t > 0:\n            num_steps = int(T / delta_t)\n            last_dt = T - num_steps * delta_t\n        else: # T=0 case\n            num_steps = 0\n            last_dt = 0.0\n\n    # Lax-Wendroff coefficients for full time steps\n    if num_steps > 0:\n        nu_scheme = nu_cfl * np.sign(c)\n        c_p = nu_scheme * (nu_scheme - 1.0) / 2.0  # Coefficient for u_{j+1}\n        c_z = 1.0 - nu_scheme**2                   # Coefficient for u_j\n        c_m = nu_scheme * (nu_scheme + 1.0) / 2.0  # Coefficient for u_{j-1}\n\n    # Time integration loop for full steps\n    for _ in range(num_steps):\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u = c_p * u_jp1 + c_z * u + c_m * u_jm1\n\n    # Final, possibly shortened, time step\n    if last_dt > 1e-12:  # Tolerance to avoid near-zero steps\n        nu_last = c * last_dt / delta_x\n        c_p_last = nu_last * (nu_last - 1.0) / 2.0\n        c_z_last = 1.0 - nu_last**2\n        c_m_last = nu_last * (nu_last + 1.0) / 2.0\n        \n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u = c_p_last * u_jp1 + c_z_last * u + c_m_last * u_jm1\n\n    u_num = u\n\n    # 3. Error Calculation\n    # Exact solution at time T\n    u_ex = A1 * np.cos(k1 * (x - c * T)) + A2 * np.cos(k2 * (x - c * T))\n\n    # Relative L2 error\n    norm_diff = np.linalg.norm(u_num - u_ex)\n    norm_ex = np.linalg.norm(u_ex)\n    E_L2 = norm_diff / norm_ex if norm_ex > 0 else 0.0\n\n    # Relative amplitude error for k2\n    C_k2 = (1.0 / np.pi) * np.sum(u_num * np.cos(k2 * x) * delta_x)\n    S_k2 = (1.0 / np.pi) * np.sum(u_num * np.sin(k2 * x) * delta_x)\n    \n    A_k2_hat = np.sqrt(C_k2**2 + S_k2**2)\n    \n    E_amp = abs(A_k2_hat - A2) / A2 if A2 > 0 else 0.0\n\n    return [E_L2, E_amp]\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, c, nu, T, A1, k1, A2, k2)\n        (1024, 1.0, 0.5, 2.0, 1.0, 1, 0.01, 100),\n        (256, 1.0, 0.99, 5.0, 1.0, 1, 0.01, 100),\n        (128, 1.0, 0.5, 2.0, 1.0, 1, 0.01, 100),\n        (512, 1.0, 0.7, 2.0, 1.0, 1, 0.0001, 200),\n        (256, -1.0, 0.8, 3.0, 1.0, 1, 0.01, 80),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Format output string to be a Python-style list of lists with no extra spaces\n    results_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "边界条件不仅是静态约束，更可以是驱动系统演化的主动力。本练习通过一个时变边界条件来激励一个一维波动系统，旨在探索共振现象。你将从第一性原理出发推导系统的固有频率，并观察当驱动频率与某一固有频率匹配时，系统响应如何随时间急剧增长，这揭示了结构动力学和信号处理中的一个核心概念 。",
            "id": "2403378",
            "problem": "考虑一个有限区间上的一维波动方程，以无量纲形式给出以避免物理单位。设场为 $u(x,t)$，其中空间坐标 $x \\in [0,L]$，时间 $t \\ge 0$。其控制偏微分方程 (PDE) 为\n$$\nu_{tt}(x,t) = c^2\\,u_{xx}(x,t),\n$$\n服从以下狄利克雷 (Dirichlet) 边界条件\n$$\nu(0,t) = g(t), \\quad u(L,t) = 0,\n$$\n及初始条件\n$$\nu(x,0) = 0, \\quad u_t(x,0) = 0.\n$$\n边界驱动是一个时变信号\n$$\ng(t) = A \\sin(\\omega t),\n$$\n其中所有角度均以弧度为单位。\n\n从相关齐次边界值问题（$g(t) \\equiv 0$）的分离变量法出发，并利用特征函数的正交性，推导该区域的固有模态振型和相应的固有角频率。利用此推导来定义一个与选定区域固有模态相调谐的参数化 $\\omega$ 选择，不得使用任何简便公式。\n\n您的计算任务是设计并实现一个二阶精确、显式的时域有限差分积分器，用于求解带有非齐次狄利克雷边界输入 $g(t)$ 的偏微分方程，并在每个时间步强制施加边界值。使用包含 $N_x$ 个子区间的均匀网格，网格间距为 $\\Delta x = L/N_x$，并根据波动方程的 Courant–Friedrichs–Lewy (CFL) 稳定性条件选择显式时间步长 $\\Delta t$。定义 Courant 数 $r = c\\,\\Delta t/\\Delta x$。内部点的显式中心差分更新在空间和时间上均应为二阶精度。使用给定的初始条件，并与所选的更新方案一致地初始化该格式。\n\n为给定的模拟定义以下标量性能指标：在模拟时间区间内，空间中点 $x=L/2$ 处所达到的最大绝对位移，\n$$\nM = \\max_{0 \\le n \\le N_t} \\left| u\\!\\left(\\tfrac{L}{2}, n\\,\\Delta t \\right) \\right|,\n$$\n其中 $N_t$ 是总时间步数。\n\n根据从第一性原理推导出的固有频率，通过选择下式来设置驱动频率以激励选定的模态\n$$\n\\omega = \\omega_m\\,(1+\\delta),\n$$\n其中 $m$ 是您选择的正整数模态指数，$\\omega_m$ 是您推导出的第 $m$ 个固有角频率，$\\delta$ 是一个无量纲的失谐参数。对每次模拟，运行所选 $\\omega$ 的指定驱动周期数 $P$；即，模拟到最终时间 $T = P \\cdot 2\\pi/\\omega$。所有量均为无量纲。\n\n实现该计算，并报告下列每个测试用例的 $M$ 值。在所有情况下，使用相同的空间分辨率以使比较有意义。每个元组为 $(L, c, N_x, r, m, \\delta, A, P)$:\n- 用例 A (共振，基模): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,1,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n- 用例 B (轻微失谐): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,1,\\; \\delta=\\,0.05,\\; A=\\,1,\\; P=\\,30\\,)$。\n- 用例 C (共振，在节点处测量的偶数模态): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,2,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n- 用例 D (共振，更高阶的奇数模态): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,3,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n- 用例 E (CFL 稳定性边界): $(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,1,\\; m=\\,1,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n\n您的程序必须：\n- 根据您推导的分离变量分析计算第 $m$ 个固有频率 $\\omega_m$，然后设置 $\\omega = \\omega_m\\,(1+\\delta)$。\n- 使用 Courant 数 $r \\le 1$ 的显式二阶格式，并在每个时间步强制施加 $u(0,t)=g(t)$ 和 $u(L,t)=0$。\n- 对于每个用例，模拟直到 $T = P \\cdot 2\\pi/\\omega$，并记录如上定义的 $M$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用例 A 到 E 的结果，按顺序排列，形式为方括号括起来的逗号分隔列表，每个数字四舍五入到六位小数，例如 [r_a,r_b,r_c,r_d,r_e]。",
            "solution": "所述问题是有效的。这是一个来自计算工程领域的适定初边值问题，它基于波动力学和数值分析的基本原理。该问题没有矛盾、歧义或科学谬误。我们将着手提供一个完整的解决方案。\n\n解决方案需要两个主要部分：首先，对系统固有频率进行理论推导；其次，设计并实现一个基于有限差分法的数值求解器。\n\n固有频率的第一性原理推导\n\n为了找到固有频率，我们必须分析相关的齐次问题。这对应于给定边界条件为零的偏微分方程 (PDE)。\n该 PDE 是一维波动方程：\n$$u_{tt}(x,t) = c^2 u_{xx}(x,t), \\quad x \\in [0, L], \\quad t \\ge 0$$\n相关的齐次狄利克雷 (Dirichlet) 边界条件是：\n$$u(0,t) = 0, \\quad u(L,t) = 0$$\n我们采用分离变量法，假设解的形式为 $u(x,t) = X(x)T(t)$。将其代入 PDE 可得：\n$$X(x)T''(t) = c^2 X''(x)T(t)$$\n重新整理各项以分离空间和时间变量，我们得到：\n$$\\frac{T''(t)}{c^2 T(t)} = \\frac{X''(x)}{X(x)}$$\n由于左侧仅依赖于时间 $t$，右侧仅依赖于空间 $x$，因此两者必须等于一个常数。我们将此分离常数记为 $-\\lambda$。选择负号是为了确保得到满足边界条件的振荡解（即非平凡解）。\n$$ \\frac{X''(x)}{X(x)} = -\\lambda \\quad \\text{and} \\quad \\frac{T''(t)}{c^2 T(t)} = -\\lambda $$\n这会产生两个常微分方程 (ODE)：\n1.  空间 ODE: $X''(x) + \\lambda X(x) = 0$\n2.  时间 ODE: $T''(t) + \\lambda c^2 T(t) = 0$\n\n我们首先求解空间 ODE，它构成了一个 Sturm-Liouville 边界值问题。$u(x,t)$ 的边界条件转化为 $X(x)$ 的条件：\n$$X(0) = 0, \\quad X(L) = 0$$\n空间 ODE 的通解是 $X(x) = C_1 \\cos(\\sqrt{\\lambda}x) + C_2 \\sin(\\sqrt{\\lambda}x)$。\n应用第一个边界条件 $X(0) = 0$：\n$$C_1 \\cos(0) + C_2 \\sin(0) = C_1 \\cdot 1 + C_2 \\cdot 0 = C_1 = 0$$\n这将解简化为 $X(x) = C_2 \\sin(\\sqrt{\\lambda}x)$。\n应用第二个边界条件 $X(L) = 0$：\n$$C_2 \\sin(\\sqrt{\\lambda}L) = 0$$\n为了得到非平凡解，我们要求 $C_2 \\neq 0$，这意味着 $\\sin(\\sqrt{\\lambda}L)$ 必须为零。当正弦函数的参数是 $\\pi$ 的整数倍时，此条件得到满足：\n$$\\sqrt{\\lambda}L = m\\pi, \\quad \\text{for } m = 1, 2, 3, \\dots$$\n排除 $m=0$ 的情况，因为它会导致 $\\lambda=0$ 和平凡解 $X(x)=0$。负整数的 $m$ 不会产生新的独立解。\n求解特征值 $\\lambda$，我们得到一组离散值：\n$$\\lambda_m = \\left(\\frac{m\\pi}{L}\\right)^2, \\quad m=1, 2, 3, \\dots$$\n相应的特征函数，或称固有模态振型，是：\n$$X_m(x) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$$\n现在我们回到时间 ODE，代入特征值 $\\lambda_m$：\n$$T_m''(t) + \\lambda_m c^2 T_m(t) = 0$$\n这是简谐振荡器的方程。固有角频率 $\\omega_m$ 是 $T_m(t)$ 系数的平方根：\n$$\\omega_m^2 = \\lambda_m c^2 = \\left(\\frac{m\\pi}{L}\\right)^2 c^2$$\n取正平方根可得固有角频率：\n$$\\omega_m = \\frac{m\\pi c}{L}, \\quad m=1, 2, 3, \\dots$$\n推导到此完成。该公式将用于在数值模拟中设置驱动频率 $\\omega = \\omega_m(1+\\delta)$。\n\n时域有限差分 (FDTD) 格式\n\n我们用均匀网格对区域进行离散化。空间坐标为 $x_i = i\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N_x\\}$，$\\Delta x = L/N_x$。时间坐标为 $t_n = n\\Delta t$，其中 $n \\in \\{0, 1, \\dots, N_t\\}$。我们将场的数值近似表示为 $u_i^n \\approx u(x_i, t_n)$。\n\nPDE $u_{tt} = c^2 u_{xx}$ 在空间和时间上都使用二阶中心差分进行近似：\n$$\\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} = c^2 \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}$$\n求解下一时间步的场 $u_i^{n+1}$，得到内部网格点（$i=1, \\dots, N_x-1$）的显式更新规则：\n$$u_i^{n+1} = 2u_i^n - u_i^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n)$$\n定义 Courant 数 $r = c\\Delta t/\\Delta x$，格式简化为：\n$$u_i^{n+1} = 2(1 - r^2)u_i^n + r^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}$$\n当 $r \\le 1$ 时，该格式是稳定的，这就是 Courant-Friedrichs-Lewy (CFL) 条件。\n\n初始条件为 $u(x,0) = 0$ 和 $u_t(x,0)=0$。\n根据 $u(x,0)=0$，我们为所有 $i \\in \\{0, \\dots, N_x\\}$ 设置 $u_i^0 = 0$。\n时间导数 $u_t(x,0)=0$ 用于求解第一个时间步的解 $u_i^1$。我们对 $t=0$ 处的导数使用二阶中心差分：\n$$\\frac{u_i^1 - u_i^{-1}}{2\\Delta t} = u_t(x_i, 0) = 0 \\implies u_i^{-1} = u_i^1$$\n此处 $u_i^{-1}$ 是一个虚构的时间“鬼点”。我们将其代入 $n=0$ 时的更新规则中：\n$$u_i^1 = 2(1 - r^2)u_i^0 + r^2(u_{i+1}^0 + u_{i-1}^0) - u_i^{-1}$$\n代入 $u_i^0=0$ 和 $u_i^{-1}=u_i^1$：\n$$u_i^1 = 2(1 - r^2)(0) + r^2(0+0) - u_i^1 \\implies 2u_i^1 = 0 \\implies u_i^1 = 0$$\n这对内部点成立。对于边界点，其值由边界条件决定。\n在任意时间步 $n$，边界条件被直接施加：\n$$u_0^n = g(t_n) = A \\sin(\\omega t_n)$$\n$$u_{N_x}^n = 0$$\n因此，对于初始化：\n- 时间 $n=0$：对所有 $i$，有 $u_i^0 = 0$。注意 $u_0^0=g(0)=A\\sin(0)=0$，这与条件一致。\n- 时间 $n=1$：对内部点 $i=1, \\dots, N_x-1$，有 $u_i^1 = 0$。边界为 $u_0^1 = g(\\Delta t)$ 和 $u_{N_x}^1 = 0$。\n\n模拟从这些初始状态开始，通过迭代应用更新规则进行。在每个时间步记录中点 $x=L/2$（对应索引 $i=N_x/2$）处的最大绝对位移，以找到总的最大值 $M$。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(L, c, Nx, r, m, delta, A, P):\n    \"\"\"\n    Solves the 1D wave equation using a finite-difference time-domain (FDTD) scheme.\n\n    Args:\n        L (float): Length of the domain.\n        c (float): Wave speed.\n        Nx (int): Number of spatial subintervals.\n        r (float): Courant number.\n        m (int): Mode index for driving frequency.\n        delta (float): Detuning parameter.\n        A (float): Amplitude of the boundary driving signal.\n        P (int): Number of drive periods to simulate.\n\n    Returns:\n        float: The maximum absolute displacement at the spatial midpoint.\n    \"\"\"\n    # 1. Setup grid and parameters\n    delta_x = L / Nx\n    \n    # 2. Calculate frequencies based on the derived formula\n    # Natural angular frequency for the m-th mode\n    omega_m = m * np.pi * c / L\n    # Driving angular frequency\n    omega = omega_m * (1.0 + delta)\n\n    # 3. Setup time stepping\n    delta_t = r * delta_x / c\n    # Final simulation time\n    if omega == 0:\n        # Avoid division by zero if frequency is zero (not in test cases but for robustness)\n        T_final = 0\n    else:\n        T_final = P * 2.0 * np.pi / omega\n    \n    # Total number of time steps (the loop will go up to Nt)\n    Nt = int(np.ceil(T_final / delta_t))\n\n    # Index of the spatial midpoint for performance metric\n    mid_point_idx = Nx // 2\n\n    # Courant number squared, used in the update rule\n    r_sq = r**2\n\n    # 4. Initialize field arrays\n    # u_prev stores the field at time step n-1\n    # u_curr stores the field at time step n\n    \n    # Per the derivation for ICs u(x,0)=0, u_t(x,0)=0:\n    # State at n=0 (t=0): u_prev array represents this.\n    # u(x,0)=0 implies u_i^0=0 for all i. The BC g(0)=A*sin(0)=0 is consistent.\n    u_prev = np.zeros(Nx + 1)\n    \n    # State at n=1 (t=delta_t): u_curr array represents this.\n    # u_i^1=0 for interior points. BCs are enforced.\n    u_curr = np.zeros(Nx + 1)\n    t = delta_t\n    u_curr[0] = A * np.sin(omega * t)\n    # u_curr[Nx] = 0 is already set by np.zeros.\n\n    # 5. Track max displacement at midpoint\n    # Initialize with the value at t=delta_t, since t=0 is zero everywhere.\n    max_disp = np.abs(u_curr[mid_point_idx])\n\n    # 6. Time-stepping loop\n    # This loop computes states for n=2, 3, ..., Nt.\n    # The loop iterates n from 1 to Nt-1 to compute u_next for time steps n+1.\n    for n in range(1, Nt):\n        # We have u_prev (n-1) and u_curr (n), compute u_next (n+1)\n        u_next = np.zeros(Nx + 1)\n\n        # Update interior points using a vectorized numpy operation for efficiency\n        # This applies the FDTD stencil: u_i^{n+1} = 2(1-r^2)u_i^n + r^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}\n        u_next[1:Nx] = 2.0 * (1.0 - r_sq) * u_curr[1:Nx] \\\n                      + r_sq * (u_curr[2:Nx+1] + u_curr[0:Nx-1]) \\\n                      - u_prev[1:Nx]\n\n        # Enforce boundary conditions at the next time step t = (n+1)*delta_t\n        t = (n + 1) * delta_t\n        u_next[0] = A * np.sin(omega * t)\n        u_next[Nx] = 0.0\n\n        # Update the performance metric\n        max_disp = max(max_disp, np.abs(u_next[mid_point_idx]))\n        \n        # Advance the state arrays for the next iteration\n        u_prev, u_curr = u_curr, u_next\n\n    return max_disp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (L, c, Nx, r, m, delta, A, P)\n        (1.0, 1.0, 200, 0.9, 1, 0.0,    1.0, 30),  # Case A\n        (1.0, 1.0, 200, 0.9, 1, 0.05,   1.0, 30),  # Case B\n        (1.0, 1.0, 200, 0.9, 2, 0.0,    1.0, 30),  # Case C\n        (1.0, 1.0, 200, 0.9, 3, 0.0,    1.0, 30),  # Case D\n        (1.0, 1.0, 200, 1.0, 1, 0.0,    1.0, 30),  # Case E\n    ]\n\n    results = []\n    for case_params in test_cases:\n        max_displacement = run_simulation(*case_params)\n        results.append(f\"{max_displacement:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当初始条件与边界条件在时空域的“角落”不兼容时，会给数值求解带来独特的挑战。本练习研究一个在原点 $(x,t)=(0,0)$ 处存在不连续性的热传导问题，这是一个在工程启动或相变问题中常见的情景。通过将你的数值解与一个已知的半无限域解析解进行比较，你将深入理解数值方法在处理奇点时的行为，并学会如何评估解在这些关键区域的准确性 。",
            "id": "2403435",
            "problem": "考虑一个定义在有限区间上的一维热传导方程，该区间用于近似一个半无限域，\n$$\n\\frac{\\partial u}{\\partial t}(x,t)=a\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\\quad x\\in(0,L),\\ t\\in(0,T],\n$$\n其初始条件为\n$$\nu(x,0)=0,\\quad x\\in(0,L],\n$$\n以及狄利克雷边界条件\n$$\nu(0,t)=1,\\quad t\\in(0,T],\\qquad u(L,t)=0,\\quad t\\in[0,T].\n$$\n在角点 $(x,t)=(0,0)$ 处存在不相容性，因为当 $x0$ 时 $u(x,0)=0$，而当 $t0$ 时 $u(0,t)=1$。对于较小的时间且远离 $x=L$ 的区域，该问题的解与半无限域的相似解表现一致\n$$\nu_{\\text{ref}}(x,t)=\\operatorname{erfc}\\!\\left(\\frac{x}{2\\sqrt{a\\,t}}\\right),\n$$\n其中互补误差函数 (erfc) 的定义为\n$$\n\\operatorname{erfc}(z)=\\frac{2}{\\sqrt{\\pi}}\\int_{z}^{\\infty} e^{-s^2}\\,ds.\n$$\n\n任务：对于下面列出的每个测试用例，数值近似初边值问题的解，直到指定时间 $t^\\ast$，并报告在指定网格位置 $x_i=i\\,\\Delta x$ 处的绝对误差。其中，均匀网格包含 $N$ 个子区间，因此 $\\Delta x=L/N$。需要报告的用例绝对误差为\n$$\nE=\\big|u_{\\text{num}}(x_i,t^\\ast)-u_{\\text{ref}}(x_i,t^\\ast)\\big|.\n$$\n你可以使用任何数学上一致的方法来近似求解，但必须满足给定的初始条件和边界条件。\n\n测试套件：\n- 用例 A (一般情况): $a=1.0$, $L=1.0$, $N=200$, $\\Delta t=10^{-5}$, $t^\\ast=10^{-3}$, $i=1$。\n- 用例 B (较粗的时间分辨率以强调角点附近的平滑效应): $a=1.0$, $L=1.0$, $N=100$, $\\Delta t=2\\times 10^{-4}$, $t^\\ast=2\\times 10^{-2}$, $i=2$。\n- 用例 C (不同的扩散系数和较短的定义域，在 $t^\\ast$ 时右边界影响可忽略不计): $a=0.2$, $L=0.5$, $N=100$, $\\Delta t=5\\times 10^{-5}$, $t^\\ast=5\\times 10^{-3}$, $i=1$。\n\n所有量均为无量纲。不涉及角度。不需要百分比。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，结果顺序与上述用例一致。每个浮点数需采用科学记数法格式化，小数点后保留 $8$ 位数字，例如：\n$$\n[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C}],\n$$\n其中每个条目的格式为 $\\text{d.dddddddd}\\text{e}\\pm\\text{dd}$，使用小写字母 $e$。",
            "solution": "所给问题是一个标准的一维热传导方程初边值问题。尽管在角点 $(x,t)=(0,0)$ 处存在指定的不连续性（这是一个已知的数值挑战），但该问题是适定的且在科学上是合理的。我们将对其进行数值求解。\n\n控制偏微分方程 (PDE) 为热传导方程：\n$$\n\\frac{\\partial u}{\\partial t} = a \\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于定义在域 $x \\in (0,L)$ 和 $t \\in (0,T]$ 上的函数 $u(x,t)$。\n\n为了数值求解该方程，我们必须在空间和时间上对其进行离散化。我们引入一个均匀空间网格，其节点为 $x_j = j \\Delta x$，$j = 0, 1, \\dots, N$，网格间距为 $\\Delta x = L/N$。时间域被离散为大小为 $\\Delta t$ 的步长，时间点为 $t_k = k \\Delta t$。我们将 $u(x_j, t_k)$ 的数值近似值记为 $u_j^k$。\n\n二阶空间导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t_k} \\approx \\frac{u_{j+1}^k - 2u_j^k + u_{j-1}^k}{(\\Delta x)^2}\n$$\n\n对于时间导数，显式前向欧拉格式是条件稳定的，需要满足 Courant-Friedrichs-Lewy (CFL) 条件 $r = a \\Delta t / (\\Delta x)^2 \\le 1/2$。对于用例 B，我们计算出 $r = 1.0 \\times (2 \\times 10^{-4}) / (1.0/100)^2 = 2.0$，这违反了该条件，使得显式方法不稳定。为了确保所有测试用例的无条件稳定性，我们选择隐式后向时间中心空间 (BTCS) 方法。\n\nBTCS 格式将有限差分应用于未来的时间步 $k+1$：\n$$\n\\frac{u_j^{k+1} - u_j^k}{\\Delta t} = a \\frac{u_{j+1}^{k+1} - 2u_j^{k+1} + u_{j-1}^{k+1}}{(\\Delta x)^2}\n$$\n此方程对内部网格点 $j = 1, 2, \\dots, N-1$ 有效。整理各项，将时间步 $k+1$ 的未知数值组合在左侧，我们得到一个线性方程组：\n$$\n-r u_{j-1}^{k+1} + (1+2r) u_j^{k+1} - r u_{j+1}^{k+1} = u_j^k\n$$\n其中 $r = a \\Delta t / (\\Delta x)^2$ 是扩散数。\n\n这个包含 $N-1$ 个方程、用于求解 $N-1$ 个未知内部节点值 $\\{u_j^{k+1}\\}_{j=1}^{N-1}$ 的方程组必须与边界条件结合。\n狄利克雷边界条件为 $u(0,t)=1$ 和 $u(L,t)=0$。在我们的离散框架中，这意味着对于任何时间步 $k+1  0$，都有 $u_0^{k+1} = 1$ 和 $u_N^{k+1} = 0$。\n\n将边界值代入第一个 ($j=1$) 和最后一个 ($j=N-1$) 内部节点的方程中，我们得到：\n对于 $j=1$：\n$$\n-r u_0^{k+1} + (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k \\implies (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k + r(1)\n$$\n对于 $j=N-1$：\n$$\n-r u_{N-2}^{k+1} + (1+2r) u_{N-1}^{k+1} - r u_N^{k+1} = u_{N-1}^k \\implies -r u_{N-2}^{k+1} + (1+2r) u_{N-1}^{k+1} = u_{N-1}^k + r(0)\n$$\n由此产生的方程组 $A \\mathbf{u}_{\\text{int}}^{k+1} = \\mathbf{d}^k$ 的系数矩阵 $A$ 是一个大小为 $(N-1) \\times (N-1)$ 的三对角矩阵，该方程组在每个时间步求解。矩阵 $A$ 的下对角线元素为 $-r$，主对角线元素为 $1+2r$，上对角线元素为 $-r$。右端向量 $\\mathbf{d}^k$ 由前一时间步的内部解 $\\mathbf{u}_{\\text{int}}^k = (u_1^k, \\dots, u_{N-1}^k)^T$ 构造，并根据边界条件进行修正：$d_1 = u_1^k + r$ 以及对于 $j=2, \\dots, N-1$ 有 $d_j = u_j^k$。\n\n算法流程如下：\n1. 初始化 $t=0$ 时的解。根据初始条件 $u(x,0)=0$，我们设定对所有 $j=0, 1, \\dots, N$，有 $u_j^0 = 0$。\n2. 对从 $t=0$ 到 $t=t^\\ast$ 的每个时间步：\n   a. 构造三对角矩阵 $A$ 和右端向量 $\\mathbf{d}^k$。\n   b. 求解线性系统 $A \\mathbf{u}_{\\text{int}}^{k+1} = \\mathbf{d}^k$ 以得到下一个时间步的内部节点值 $\\mathbf{u}_{\\text{int}}^{k+1}$。使用高效的三对角系统求解算法，如 Thomas 算法（在 `scipy.linalg.solve_banded` 中实现）。\n   c. 更新解向量。\n3. 最后一个时间步结束后，数值解 $u_{\\text{num}}(x_i, t^\\ast)$ 由值 $u_i^K$ 给出，其中 $K = t^\\ast / \\Delta t$。\n4. 将此数值解与半无限域的参考解 $u_{\\text{ref}}(x_i, t^\\ast) = \\operatorname{erfc}(x_i / (2\\sqrt{a t^\\ast}))$ 进行比较。计算绝对误差 $E = |u_i^K - u_{\\text{ref}}(x_i, t^\\ast)|$。\n\n将此流程应用于每个测试用例，以确定所需的绝对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erfc\n\ndef solve_case(params):\n    \"\"\"\n    Numerically solves the 1D heat equation for a given set of parameters\n    using the Backward Time, Centered Space (BTCS) implicit method.\n\n    Args:\n        params (tuple): A tuple containing the problem parameters:\n                        (a, L, N, dt, t_star, i).\n                        a: thermal diffusivity\n                        L: length of the domain\n                        N: number of subintervals\n                        dt: time step size\n                        t_star: final time\n                        i: grid index for error calculation\n\n    Returns:\n        float: The absolute error between the numerical solution and the\n               reference semi-infinite solution at the specified point.\n    \"\"\"\n    a, L, N, dt, t_star, i = params\n\n    # Discretization parameters\n    dx = L / N\n    r = a * dt / (dx**2)\n    num_steps = int(round(t_star / dt))\n\n    # Initial condition: u(x, 0) = 0 for x in [0, L]\n    # The solution vector u has N+1 points, for j = 0, ..., N.\n    u = np.zeros(N + 1)\n\n    # Set up the tridiagonal matrix for the BTCS aystem.\n    # The system is for the N-1 interior points (j = 1, ..., N-1).\n    # The banded matrix format for scipy.linalg.solve_banded is used.\n    # It has 3 rows: upper diagonal, main diagonal, lower diagonal.\n    A_banded = np.zeros((3, N - 1))\n    A_banded[0, 1:] = -r        # Upper diagonal (shifted one to the left)\n    A_banded[1, :] = 1 + 2 * r  # Main diagonal\n    A_banded[2, :-1] = -r       # Lower diagonal (shifted one to the right)\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Construct the right-hand side (RHS) vector from the solution\n        # at the current time step (u).\n        # We solve for the N-1 interior points.\n        rhs = u[1:N].copy()\n\n        # Modify RHS to incorporate Dirichlet boundary conditions.\n        # For the first interior point (j=1): u(0,t)=1.\n        # The term -r*u_0^{k+1} is moved to the RHS, becoming +r*u_0^{k+1} = +r*1.\n        rhs[0] += r\n        \n        # For the last interior point (j=N-1): u(L,t)=0.\n        # The term -r*u_N^{k+1} is moved to the RHS, becoming +r*u_N^{k+1} = +r*0.\n        # So, no change is needed for rhs[-1].\n\n        # Solve the tridiagonal system A * u_next_interior = rhs\n        u_interior_next = solve_banded((1, 1), A_banded, rhs)\n\n        # Update the interior points of the solution vector for the next time step.\n        u[1:N] = u_interior_next\n\n    # After the loop, u contains the numerical solution at time t_star.\n    x_i = i * dx\n    u_num = u[i]\n\n    # Calculate the reference semi-infinite domain solution.\n    u_ref = erfc(x_i / (2 * np.sqrt(a * t_star)))\n\n    # Calculate the absolute error.\n    error = np.abs(u_num - u_ref)\n    \n    return error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: a=1.0, L=1.0, N=200, dt=10^-5, t*=10^-3, i=1\n        (1.0, 1.0, 200, 1e-5, 1e-3, 1),\n        # Case B: a=1.0, L=1.0, N=100, dt=2x10^-4, t*=2x10^-2, i=2\n        (1.0, 1.0, 100, 2e-4, 2e-2, 2),\n        # Case C: a=0.2, L=0.5, N=100, dt=5x10^-5, t*=5x10^-3, i=1\n        (0.2, 0.5, 100, 5e-5, 5e-3, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(case)\n        # Format the result to scientific notation with 8 decimal places.\n        results.append(f\"{error:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}