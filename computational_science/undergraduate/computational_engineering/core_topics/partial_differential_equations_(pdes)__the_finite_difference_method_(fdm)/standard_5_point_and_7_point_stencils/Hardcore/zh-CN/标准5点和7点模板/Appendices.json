{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最终目的是付诸实践。这项练习 () 将指导你从头开始，使用五点中心差分格式构建一个完整的二维泊松方程数值求解器。通过这个过程，你不仅将掌握偏微分方程离散化的核心技术，还将学会如何利用 SciPy 库中的稀疏矩阵高效地处理大型线性系统，这是计算科学与工程中的一项基本功。",
            "id": "2438628",
            "problem": "您的任务是构建一个完整且高效的数值求解器，用于在矩形网格上使用标准的五点差分格式求解二维泊松方程。该问题将在纯粹的数学和算法背景下进行设定和求解，不依赖任何物理单位。求解器必须使用科学计算Python库 (SciPy) 的稀疏矩阵功能，以确保在组装和求解过程中的效率。\n\n起点 (基本基础)：\n- 二维泊松方程由 $-\\Delta u = f$ 给出，定义在矩形域 $\\Omega = [a_x,b_x] \\times [a_y,b_y]$ 上，其中 $\\Delta$ 表示拉普拉斯算子 $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n- 狄利克雷边界条件在边界 $\\partial \\Omega$ 上规定 $u = g$。\n- 离散近似必须基于均匀张量积网格上的二阶中心有限差分，该网格在 $x$ 方向有 $N_x$ 个内部点，在 $y$ 方向有 $N_y$ 个内部点。网格间距为 $h_x = \\frac{b_x - a_x}{N_x + 1}$ 和 $h_y = \\frac{b_y - a_y}{N_y + 1}$。\n- 五点差分格式是通过在每个坐标方向上组合一维二阶中心差分得到的。\n\n您的任务：\n- 从泰勒展开推导出一个一致的拉普拉斯算子离散近似，从而得到一个用于求解 $u$ 的内部网格值的对称正定线性系统。\n- 设计一种高效的线性系统稀疏组装方法，利用 SciPy 的稀疏矩阵运算和网格引出的张量积 (克罗内克积) 结构，在构建矩阵时避免对所有网格点进行显式循环。\n- 通过边界贡献项将狄利克雷边界条件并入右侧项。\n- 使用合适的稀疏求解器求解得到的稀疏线性系统。\n- 通过计算数值解与已知的构造精确解在内部网格上的离散 $L^2$ 误差范数来评估精度，其定义为\n$$\n\\|e\\|_{L^2(\\Omega_h)} \\equiv \\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}} - u(x_i,y_j)\\right)^2 h_x h_y \\right)^{1/2},\n$$\n其中 $(x_i,y_j)$ 是内部网格节点，$u_{ij}^{\\text{num}}$ 是在这些节点上计算出的解，而 $u(x,y)$ 是构造的精确解。\n\n测试套件：\n实现您的求解器并在以下三个构造解案例上进行评估。在每个案例中，$f$ 和 $g$ 必须根据精确解 $u$ 构建，以使连续解已知。所有函数都是无量纲的，没有物理单位。\n\n- 案例 1 (理想情况，单位正方形上的零狄利克雷边界)：\n  - 域：$[a_x,b_x] \\times [a_y,b_y] = [0,1] \\times [0,1]$。\n  - 网格：$N_x = 32$，$N_y = 32$。\n  - 精确解：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 右侧项：$f(x,y)$ 与 $-\\Delta u = f$ 一致。\n  - 边界条件：$g(x,y) = u(x,y)$ 在 $\\partial \\Omega$ 上 (对于此精确解，在整个边界上其值为 $0$)。\n\n- 案例 2 (非零狄利克雷边界，多项式精确解)：\n  - 域：$[a_x,b_x] \\times [a_y,b_y] = [0,1] \\times [0,1]$。\n  - 网格：$N_x = 10$，$N_y = 10$。\n  - 精确解：$u(x,y) = x^2 + y^2$。\n  - 右侧项：$f(x,y)$ 与 $-\\Delta u = f$ 一致。\n  - 边界条件：$g(x,y) = u(x,y)$ 在 $\\partial \\Omega$ 上。\n\n- 案例 3 (矩形域上的各向异性间距)：\n  - 域：$[a_x,b_x] \\times [a_y,b_y] = [0,2] \\times [0,1]$。\n  - 网格：$N_x = 15$，$N_y = 9$。\n  - 精确解：$u(x,y) = \\sin\\left(\\frac{\\pi}{2} x\\right)\\sin(\\pi y)$。\n  - 右侧项：$f(x,y)$ 与 $-\\Delta u = f$ 一致。\n  - 边界条件：$g(x,y) = u(x,y)$ 在 $\\partial \\Omega$ 上 (对于此精确解，在整个边界上其值为 $0$)。\n\n输出规范：\n- 对于每个案例，按上述规定计算内部网格上的离散 $L^2$ 误差范数。\n- 您的程序应生成一行输出，其中包含三个结果，以逗号分隔并用方括号括起来的列表，每个浮点值四舍五入到八位小数。例如：$[0.00123456,0.00000000,0.01234567]$。\n- 不应产生任何其他输出。\n\n实现约束：\n- 最终程序必须是一个完整、可运行的 Python 脚本，使用科学计算 Python (SciPy) 的稀疏矩阵工具进行组装和求解，并使用数值 Python (NumPy) 库进行数组操作。\n- 组装过程应利用离散算子的张量积结构以提高效率。",
            "solution": "所提出的问题是数值分析中一个标准的、适定的练习。它要求实现一个用于二维泊松方程的有限差分求解器。该问题具有科学依据，内部一致，并包含了继续进行所需的所有信息。因此，我们将提供一个完整的解决方案。\n\n过程是有条不紊的。首先，我们从连续偏微分方程推导出离散代数系统。其次，我们形式化系统矩阵的结构并确定其性质。第三，我们为其组装和求解构建一个高效的算法。最后，我们通过构造解来验证实现。\n\n**1. 泊松方程的离散化**\n\n控制方程是矩形域 $\\Omega = [a_x, b_x] \\times [a_y, b_y]$ 上的泊松方程：\n$$\n-\\Delta u = -\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = f(x,y)\n$$\n其狄利克雷边界条件为 $u(x,y) = g(x,y)$，适用于 $(x,y) \\in \\partial\\Omega$。\n\n我们引入一个均匀网格，在 $x$ 方向有 $N_x$ 个内部点，在 $y$ 方向有 $N_y$ 个内部点。网格坐标为 $x_i = a_x + i \\cdot h_x$ (其中 $i=0, 1, \\dots, N_x+1$) 和 $y_j = a_y + j \\cdot h_y$ (其中 $j=0, 1, \\dots, N_y+1$)。网格间距为 $h_x = \\frac{b_x - a_x}{N_x + 1}$ 和 $h_y = \\frac{b_y - a_y}{N_y + 1}$。未知值为内部网格点处的函数值 $u_{ij} \\equiv u(x_i, y_j)$，其中 $i \\in \\{1, \\dots, N_x\\}$ 且 $j \\in \\{1, \\dots, N_y\\}$。\n\n为了近似二阶导数，我们使用二阶中心有限差分。推导依赖于泰勒级数展开。对于一个足够光滑的函数 $u(x,y)$，我们有：\n$$\nu(x_i \\pm h_x, y_j) = u(x_i, y_j) \\pm h_x \\frac{\\partial u}{\\partial x}\\bigg|_{ij} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} \\pm \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{ij} + O(h_x^4)\n$$\n将 $u(x_i + h_x, y_j)$ 和 $u(x_i - h_x, y_j)$ 的展开式相加，可以消去奇数阶导数项：\n$$\nu(x_i + h_x, y_j) + u(x_i - h_x, y_j) = 2 u(x_i, y_j) + h_x^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} + O(h_x^4)\n$$\n解出二阶导数，得到中心差分近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} = \\frac{u(x_{i-1}, y_j) - 2u(x_i, y_j) + u(x_{i+1}, y_j)}{h_x^2} + O(h_x^2)\n$$\n$\\frac{\\partial^2 u}{\\partial y^2}$ 也有类似的表达式。将这些代入内部点 $(x_i, y_j)$ 处的泊松方程，得到离散方程：\n$$\n-\\left( \\frac{u_{i-1,j} - 2u_{ij} + u_{i+1,j}}{h_x^2} + \\frac{u_{i,j-1} - 2u_{ij} + u_{i,j+1}}{h_y^2} \\right) = f_{ij}\n$$\n其中 $f_{ij} = f(x_i, y_j)$。整理各项，我们得到五点差分格式公式：\n$$\n\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{ij} - \\frac{1}{h_x^2}u_{i-1,j} - \\frac{1}{h_x^2}u_{i+1,j} - \\frac{1}{h_y^2}u_{i,j-1} - \\frac{1}{h_y^2}u_{i,j+1} = f_{ij}\n$$\n这个包含 $N_x \\times N_y$ 个线性代数方程的系统必须被求解，以得到未知数 $u_{ij}$。\n\n**2. 线性系统组装与克罗内克积结构**\n\n要解这个系统，我们必须将其表示为矩阵形式 $A\\mathbf{u} = \\mathbf{b}$。这需要将二维未知数网格 $\\{u_{ij}\\}$ 映射到一个大小为 $N_x N_y$ 的一维向量 $\\mathbf{u}$。我们采用列主序（字典序）排序，其中未知数 $u_{ij}$ 的索引 $k$ 由 $k = (i-1) + (j-1)N_x$ 给出，适用于 $i \\in \\{1,\\dots,N_x\\}$ 和 $j \\in \\{1,\\dots,N_y\\}$。\n\n离散负拉普拉斯算子可以表示为两个算子之和，每个空间维度一个：$L_h = L_x + L_y$。通过所选的向量化方式，这种变量分离在系统矩阵 $A$ 中引入了张量积（也称为克罗内克积）结构。\n\n设 $A_x$ 是表示一维负二阶导数算子 $-\\frac{d^2}{dx^2}$ 在具有 $N_x$ 个点的网格上的矩阵。它是一个 $N_x \\times N_x$ 的三对角矩阵：\n$$\nA_x = \\frac{1}{h_x^2} \\begin{pmatrix} 2  -1   \\\\ -1  2  -1  \\\\  \\ddots  \\ddots  \\ddots \\\\   -1  2  -1 \\\\    -1  2 \\end{pmatrix}\n$$\n类似地，设 $A_y$ 是对应于 $y$ 方向的 $N_y \\times N_y$ 矩阵。设 $I_x$ 和 $I_y$ 分别是大小为 $N_x \\times N_x$ 和 $N_y \\times N_y$ 的单位矩阵。表示二维离散负拉普拉斯算子的矩阵 $A$ 由两个克罗内克积之和给出：\n$$\nA = (I_y \\otimes A_x) + (A_y \\otimes I_x)\n$$\n其中 $\\otimes$ 表示克罗内克积。这种构造产生一个 $(N_x N_y) \\times (N_x N_y)$ 的块三对角矩阵。这种结构是使用稀疏矩阵库进行高效组装的基础。矩阵 $A$ 是对称的，并且对于这个问题是正定的，这保证了唯一解的存在。\n\n**3. 并入边界条件**\n\n当一个内部点 $(x_i, y_j)$ 与边界 $\\partial\\Omega$ 相邻时，其在差分格式中的一个或多个邻居（例如，$u_{i-1,j}$）的值是已知的，由狄利克雷条件 $g(x,y)$ 规定。这些已知值必须移到线性系统的右侧。例如，对于一个与左边界 $x=a_x$ 相邻的点 $(x_1, y_j)$，项 $-\\frac{1}{h_x^2} u_{0,j}$ 变为 $-\\frac{1}{h_x^2} g(x_0, y_j)$，这是一个已知量。该项被加到右侧项 $f_{1j}$ 上。\n\n右侧向量 $\\mathbf{b}$ 的第 $k$ 个元素（对应于点 $(x_i, y_j)$）的一般形式为：\n$$\nb_k = f_{ij} + C_{bc}\n$$\n其中 $C_{bc}$ 表示来自任何相邻边界点的贡献之和。对于点 $(x_i, y_j)$：\n- 如果 $i=1$：$C_{bc}$ 包括 $\\frac{1}{h_x^2} g(a_x, y_j)$。\n- 如果 $i=N_x$：$C_{bc}$ 包括 $\\frac{1}{h_x^2} g(b_x, y_j)$。\n- 如果 $j=1$：$C_{bc}$ 包括 $\\frac{1}{h_y^2} g(x_i, a_y)$。\n- 如果 $j=N_y$：$C_{bc}$ 包括 $\\frac{1}{h_y^2} g(x_i, b_y)$。\n\n**4. 数值实现与误差评估**\n\n算法如下：\n1. 对于给定的测试案例，确定域 $[a_x,b_x] \\times [a_y,b_y]$、网格维度 $N_x, N_y$ 以及精确解 $u(x,y)$ 的解析函数。\n2. 解析计算源项 $f(x,y) = -\\Delta u(x,y)$ 和边界函数 $g(x,y) = u(x,y)|_{\\partial\\Omega}$。\n3. 使用 `scipy.sparse.diags` 构建稀疏的 $N_x \\times N_x$ 矩阵 $A_x$ 和 $N_y \\times N_y$ 矩阵 $A_y$。\n4. 使用 `scipy.sparse.kron` 构建完整的稀疏系统矩阵 $A$，其大小为 $(N_x N_y) \\times (N_x N_y)$。\n5. 通过在所有内部网格点上评估 $f$ 并如上所述添加边界贡献来构建右侧向量 $\\mathbf{b}$。\n6. 使用稀疏直接求解器（如 `scipy.sparse.linalg.spsolve`）求解稀疏线性系统 $A\\mathbf{u} = \\mathbf{b}$，以获得未知数向量 $\\mathbf{u}$。\n7. 将解向量 $\\mathbf{u}$ 重塑为 $N_x \\times N_y$ 的网格 `U_num`。\n8. 在内部网格上评估精确解 $u(x,y)$ 以获得 `U_exact`。\n9. 计算离散 $L^2$ 误差范数：\n    $$\n    \\|e\\|_{L^2(\\Omega_h)} = \\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} (u_{ij}^{\\text{num}} - u(x_i,y_j))^2 h_x h_y \\right)^{1/2}\n    $$\n\n**测试案例详情：**\n\n对于每个案例，我们首先推导源函数 $f(x,y)$：\n- **案例 1：** $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  $f = -\\Delta u = -(-\\pi^2\\sin(\\pi x)\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\sin(\\pi y)) = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。\n- **案例 2：** $u(x,y) = x^2 + y^2$。\n  $f = -\\Delta u = -(2 + 2) = -4$。\n- **案例 3：** $u(x,y) = \\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$。\n  $f = -\\Delta u = -(-(\\frac{\\pi}{2})^2\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y) - \\pi^2\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)) = \\frac{5\\pi^2}{4}\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$。\n\n实现将现在遵循这些步骤来计算每个案例的误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_poisson_2d(domain, grid_size, u_exact_func, f_func, g_func):\n    \"\"\"\n    Solves the 2D Poisson equation -Delta u = f on a rectangular domain\n    with Dirichlet boundary conditions u = g using a 5-point finite difference\n    stencil and sparse matrix representation.\n\n    Args:\n        domain (tuple): (ax, bx, ay, by) defining the domain [ax, bx] x [ay, by].\n        grid_size (tuple): (Nx, Ny) of interior grid points.\n        u_exact_func (callable): The exact solution u(x, y).\n        f_func (callable): The source term f(x, y).\n        g_func (callable): The Dirichlet boundary condition function g(x, y).\n\n    Returns:\n        float: The discrete L2-error norm of the solution.\n    \"\"\"\n    ax, bx, ay, by = domain\n    Nx, Ny = grid_size\n    N = Nx * Ny\n\n    hx = (bx - ax) / (Nx + 1)\n    hy = (by - ay) / (Ny + 1)\n\n    # Create grid for interior points\n    x_int = np.linspace(ax + hx, bx - hx, Nx)\n    y_int = np.linspace(ay + hy, by - hy, Ny)\n    X_int, Y_int = np.meshgrid(x_int, y_int, indexing='ij')\n\n    # Construct 1D Laplacian matrices\n    diagonals_x = [-1, 2, -1]\n    Ax = sparse.diags(diagonals_x, [-1, 0, 1], shape=(Nx, Nx), format='csr') / (hx**2)\n\n    diagonals_y = [-1, 2, -1]\n    Ay = sparse.diags(diagonals_y, [-1, 0, 1], shape=(Ny, Ny), format='csr') / (hy**2)\n\n    # Create identity matrices\n    Ix = sparse.identity(Nx, format='csr')\n    Iy = sparse.identity(Ny, format='csr')\n\n    # Construct 2D Laplacian matrix using Kronecker product (column-major ordering)\n    A = sparse.kron(Iy, Ax) + sparse.kron(Ay, Ix)\n    A = A.tocsr()\n\n    # Construct the right-hand side (RHS) vector b\n    # 1. Source term f\n    b = f_func(X_int, Y_int).flatten('F') # Use Fortran order for column-major\n\n    # 2. Boundary conditions\n    # We add contributions to b for interior points adjacent to the boundary.\n    \n    # Left and Right boundaries (x=ax, x=bx)\n    y_bnd = np.linspace(ay + hy, by - hy, Ny)\n    g_left = g_func(ax, y_bnd)\n    g_right = g_func(bx, y_bnd)\n    for j in range(Ny):\n        # A point (i=0, j) is adjacent to the left boundary\n        k = 0 + j * Nx\n        b[k] += g_left[j] / hx**2\n        # A point (i=Nx-1, j) is adjacent to the right boundary\n        k = (Nx - 1) + j * Nx\n        b[k] += g_right[j] / hx**2\n        \n    # Bottom and Top boundaries (y=ay, y=by)\n    x_bnd = np.linspace(ax + hx, bx - hx, Nx)\n    g_bottom = g_func(x_bnd, ay)\n    g_top = g_func(x_bnd, by)\n    for i in range(Nx):\n        # A point (i, j=0) is adjacent to the bottom boundary\n        k = i + 0 * Nx\n        b[k] += g_bottom[i] / hy**2\n        # A point (i, j=Ny-1) is adjacent to the top boundary\n        k = i + (Ny - 1) * Nx\n        b[k] += g_top[i] / hy**2\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n\n    # Reshape solution vector to 2D grid\n    U_num = u_vec.reshape((Nx, Ny), order='F') # Fortran order for column-major\n\n    # Evaluate exact solution on the interior grid\n    U_exact = u_exact_func(X_int, Y_int)\n\n    # Compute discrete L2 error norm\n    error = np.sqrt(np.sum((U_num - U_exact)**2) * hx * hy)\n\n    return error\n\ndef solve():\n    \"\"\"Defines and runs the test suite.\"\"\"\n    \n    pi = np.pi\n    \n    test_cases = [\n        # Case 1: Happy path, zero Dirichlet BC\n        {\n            \"domain\": (0.0, 1.0, 0.0, 1.0),\n            \"grid_size\": (32, 32),\n            \"u_exact\": lambda x, y: np.sin(pi * x) * np.sin(pi * y),\n            \"f\": lambda x, y: 2 * pi**2 * np.sin(pi * x) * np.sin(pi * y),\n        },\n        # Case 2: Nonzero Dirichlet BC, polynomial solution\n        {\n            \"domain\": (0.0, 1.0, 0.0, 1.0),\n            \"grid_size\": (10, 10),\n            \"u_exact\": lambda x, y: x**2 + y**2,\n            \"f\": lambda x, y: -4.0 * np.ones_like(x),\n        },\n        # Case 3: Anisotropic spacings\n        {\n            \"domain\": (0.0, 2.0, 0.0, 1.0),\n            \"grid_size\": (15, 9),\n            \"u_exact\": lambda x, y: np.sin(pi/2 * x) * np.sin(pi * y),\n            \"f\": lambda x, y: (pi**2 / 4 + pi**2) * np.sin(pi/2 * x) * np.sin(pi * y),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # For all cases, the boundary condition g is simply the exact solution evaluated on the boundary.\n        g_func = case[\"u_exact\"]\n        \n        error = solve_poisson_2d(\n            domain=case[\"domain\"],\n            grid_size=case[\"grid_size\"],\n            u_exact_func=case[\"u_exact\"],\n            f_func=case[\"f\"],\n            g_func=g_func\n        )\n        results.append(error)\n\n    # Format the final output string as required.\n    formatted_results = ','.join([f\"{r:.8f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "离散化不仅是近似，它还会在我们的模型中引入新的、非物理的行为。这项练习 () 将通过分析亥姆霍兹方程来探讨一个关键概念：数值色散。你将推导五点格式下的数值色散关系，并理解离散网格如何影响不同波长（或波数）的波的传播速度，这是评估任何用于波传播问题的数值方法稳定性和准确性的核心步骤。",
            "id": "2438676",
            "problem": "考虑定义在一个无限均匀笛卡尔网格上的二维亥姆霍兹方程 $\\nabla^{2}\\phi + k^{2}\\phi = 0$，其在两个空间方向上的间距均为 $h$。令 $\\phi_{m,n}$ 表示节点 $(m h, n h)$ 处的网格函数，其中 $m,n \\in \\mathbb{Z}$。拉普拉斯算子 $\\nabla^{2}\\phi$ 通过标准的中心五点差分格式进行离散化：\n$$\n\\left.\\nabla^{2}\\phi\\right|_{m,n} \\approx \\frac{\\phi_{m+1,n} + \\phi_{m-1,n} + \\phi_{m,n+1} + \\phi_{m,n-1} - 4\\,\\phi_{m,n}}{h^{2}}.\n$$\n将数值色散函数 $D(\\xi,\\eta;h,k)$ 定义为离散波数 $(\\xi,\\eta)$、网格间距 $h$ 和亥姆霍兹参数 $k$ 的标量函数，使得形如 $\\phi_{m,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big)$ 的离散平面波满足离散化的亥姆霍兹方程当且仅当 $D(\\xi,\\eta;h,k) = 0$。请推导并以闭合形式给出 $D(\\xi,\\eta;h,k)$。\n\n你的最终答案必须是 $D(\\xi,\\eta;h,k)$ 的单个闭合形式解析表达式（不要将其表示为等于零的方程）。不需要四舍五入，也不涉及单位。",
            "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件。\n- 控制偏微分方程是二维亥姆霍兹方程：$\\nabla^{2}\\phi + k^{2}\\phi = 0$。\n- 域是一个无限均匀的笛卡尔网格，在两个空间方向上的网格间距均为 $h$。\n- 节点 $(m h, n h)$ 处的网格函数表示为 $\\phi_{m,n}$，其中 $m,n \\in \\mathbb{Z}$。\n- 拉普拉斯算子 $\\nabla^{2}\\phi$ 使用标准的五点差分格式进行离散化：\n$$\n\\left.\\nabla^{2}\\phi\\right|_{m,n} \\approx \\frac{\\phi_{m+1,n} + \\phi_{m-1,n} + \\phi_{m,n+1} + \\phi_{m,n-1} - 4\\,\\phi_{m,n}}{h^{2}}.\n$$\n- 提出了一个离散平面波解：$\\phi_{m,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big)$，其中 $\\xi$ 和 $\\eta$ 是离散波数。\n- 数值色散函数 $D(\\xi,\\eta;h,k)$ 被定义为使得离散平面波成为有效解时必须等于零的函数。\n\n步骤2：使用提取的已知条件进行验证。\n- **科学依据：** 这个问题是偏微分方程数值分析中的一个基本练习，特别是有限差分法。亥姆霍兹方程、五点差分格式和数值色散的概念都是计算科学与工程中标准且成熟的课题。该问题在科学上是合理的。\n- **适定性：** 该问题提供了推导所求函数所需的所有组成部分——方程、离散化方案和试探解形式。目标明确，并且预期会有一个唯一的解。\n- **客观性：** 问题以客观的数学语言表述，没有主观或含糊不清的术语。\n\n步骤3：结论与行动。\n该问题被认为是有效的，因为它具有科学依据、适定、客观且完整。我将继续推导解答。\n\n亥姆霍兹方程的离散形式是通过将拉普拉斯算子的五点差分格式近似代入连续方程得到的：\n$$\n\\frac{\\phi_{m+1,n} + \\phi_{m-1,n} + \\phi_{m,n+1} + \\phi_{m,n-1} - 4\\,\\phi_{m,n}}{h^{2}} + k^{2}\\phi_{m,n} = 0\n$$\n为了找到数值色散关系，我们将离散平面波拟设 $\\phi_{m,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big)$ 代入这个离散方程中。涉及相邻网格点的项可以用 $\\phi_{m,n}$ 来表示：\n- $\\phi_{m+1,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi (m+1) + \\eta n)\\big) = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big) \\exp(\\mathrm{i}\\xi) = \\phi_{m,n} \\exp(\\mathrm{i}\\xi)$\n- $\\phi_{m-1,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi (m-1) + \\eta n)\\big) = \\phi_{m,n} \\exp(-\\mathrm{i}\\xi)$\n- $\\phi_{m,n+1} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta (n+1))\\big) = \\phi_{m,n} \\exp(\\mathrm{i}\\eta)$\n- $\\phi_{m,n-1} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta (n-1))\\big) = \\phi_{m,n} \\exp(-\\mathrm{i}\\eta)$\n\n将这些表达式代入离散方程，得到：\n$$\n\\frac{\\phi_{m,n}\\exp(\\mathrm{i}\\xi) + \\phi_{m,n}\\exp(-\\mathrm{i}\\xi) + \\phi_{m,n}\\exp(\\mathrm{i}\\eta) + \\phi_{m,n}\\exp(-\\mathrm{i}\\eta) - 4\\,\\phi_{m,n}}{h^{2}} + k^{2}\\phi_{m,n} = 0\n$$\n对于一个非平凡解（即 $A \\neq 0$，所以 $\\phi_{m,n}$ 不恒为零），我们可以将整个方程除以 $\\phi_{m,n}$：\n$$\n\\frac{\\exp(\\mathrm{i}\\xi) + \\exp(-\\mathrm{i}\\xi) + \\exp(\\mathrm{i}\\eta) + \\exp(-\\mathrm{i}\\eta) - 4}{h^{2}} + k^{2} = 0\n$$\n使用欧拉恒等式 $\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta) = 2\\cos(\\theta)$，我们可以简化该表达式：\n$$\n\\frac{2\\cos(\\xi) + 2\\cos(\\eta) - 4}{h^{2}} + k^{2} = 0\n$$\n根据定义，数值色散函数 $D(\\xi,\\eta;h,k)$ 是该方程的左侧。\n$$\nD(\\xi,\\eta;h,k) = \\frac{2\\cos(\\xi) + 2\\cos(\\eta) - 4}{h^{2}} + k^{2}\n$$\n这个表达式可以进一步简化。我们从分子中提出因子 $2$：\n$$\nD(\\xi,\\eta;h,k) = \\frac{2(\\cos(\\xi) - 1) + 2(\\cos(\\eta) - 1)}{h^{2}} + k^{2}\n$$\n使用三角半角恒等式 $1 - \\cos(\\theta) = 2\\sin^{2}(\\theta/2)$，或等价地 $\\cos(\\theta) - 1 = -2\\sin^{2}(\\theta/2)$，我们替换余弦项：\n$$\nD(\\xi,\\eta;h,k) = \\frac{2\\left(-2\\sin^{2}\\left(\\frac{\\xi}{2}\\right)\\right) + 2\\left(-2\\sin^{2}\\left(\\frac{\\eta}{2}\\right)\\right)}{h^{2}} + k^{2}\n$$\n$$\nD(\\xi,\\eta;h,k) = \\frac{-4\\sin^{2}\\left(\\frac{\\xi}{2}\\right) - 4\\sin^{2}\\left(\\frac{\\eta}{2}\\right)}{h^{2}} + k^{2}\n$$\n提出公因子，得到数值色散函数的最终闭合形式表达式：\n$$\nD(\\xi,\\eta;h,k) = k^{2} - \\frac{4}{h^{2}}\\left(\\sin^{2}\\left(\\frac{\\xi}{2}\\right) + \\sin^{2}\\left(\\frac{\\eta}{2}\\right)\\right)\n$$\n这就是所求的函数。",
            "answer": "$$\n\\boxed{k^{2} - \\frac{4}{h^{2}} \\left( \\sin^{2}\\left(\\frac{\\xi}{2}\\right) + \\sin^{2}\\left(\\frac{\\eta}{2}\\right) \\right)}\n$$"
        },
        {
            "introduction": "一个好的数值方法不仅要准确，我们还必须了解其局限性。这项动手实践 () 旨在通过一个巧妙的“人造解”实验，揭示标准五点格式的一个固有弱点：网格各向异性。你将通过编程比较求解器在处理与网格轴对齐和对角线对齐的特征时的误差，从而直观地理解为什么该格式在解析某些方向的特征时表现不佳，这是进行严谨科学计算时必须具备的批判性思维。",
            "id": "2393578",
            "problem": "考虑单位平方域上的二维泊松方程，其具有强但平滑的特征，主方向与网格轴对齐或呈对角线方向。数学模型是标量场 $u(x,y)$ 在 $[0,1]\\times[0,1]$ 上的边值问题，\n$$- \\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in (0,1)\\times(0,1),$$\n边界 $\\partial([0,1]\\times[0,1])$ 上具有狄利克雷边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$。拉普拉斯算子 $\\nabla^2$ 定义为 $\\nabla^2 u = \\partial^2 u / \\partial x^2 + \\partial^2 u / \\partial y^2$。您必须在均匀网格上使用标准的五点中心差分有限差分法来近似算子 $\\nabla^2$，并求解得到的线性系统以获得内部网格点上的 $u(x,y)$。\n\n使用人造解方法定义两个精确解 $u_{\\text{exact}}(x,y)$，其锐度由宽度参数 $\\sigma > 0$ 控制，方向为：\n- 与直线 $x=y$ 对齐的对角线脊：\n  $$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right).$$\n- 沿 $x$ 轴方向，以 $x=0.5$ 为中心的轴对齐脊：\n  $$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right).$$\n\n对于每个人造解，通过将连续拉普拉斯算子 $\\nabla^2$ 应用于 $u_{\\text{exact}}$ 并设置 $f(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y)$，来计算其连续的右端项 $f(x,y)$。对于对角线脊，请注意 $u_{\\mathrm{diag}}(x,y;\\sigma)$ 仅依赖于 $s=x-y$；对于函数 $g(s)$，使用恒等式 $\\partial^2 g/\\partial x^2 = g''(s)$ 和 $\\partial^2 g/\\partial y^2 = g''(s)$，这共同意味着 $\\nabla^2 g(s) = 2 g''(s)$。对于轴对齐脊，请注意 $u_{\\mathrm{axis}}(x,y;\\sigma)$ 仅依赖于 $x$，因此 $\\nabla^2 u_{\\mathrm{axis}} = \\partial^2 u_{\\mathrm{axis}}/\\partial x^2$。这些运算都是连续导数；不要使用离散近似来构造 $f(x,y)$。\n\n使用一个包含 $N\\times N$ 个点的均匀笛卡尔网格对域进行离散化，网格间距为 $h = 1/(N-1)$，其中 $N$ 是一个奇数，以使直线 $y=0.5$ 成为网格的一行。在内部点 $(i,j)$ 上为拉普拉斯算子组装标准的五点模板，通过将边界设置为精确的人造解来强制执行狄利克雷边界条件。仅使用标准的五点模板为内部未知数构建并求解线性系统；不要使用任何高阶或九点模板。\n\n在同一网格上使用相同的 $\\sigma$ 计算对角线和轴对齐人造解的数值解后，通过插入精确的边界值来重建完整的网格。然后，评估以下两个逐行的最大绝对误差：\n- 对角线误差 $E_{\\mathrm{diag}}$：沿离散对角网格线 $x=y$（即索引为 $i=j$ 的节点）的数值解与精确解之间的最大绝对差，并按该线上精确解的最大振幅进行归一化。对于 $u_{\\mathrm{diag}}$，沿 $x=y$ 线的精确值在该线上的所有点均为 $1$。\n- 轴线误差 $E_{\\mathrm{axis}}$：沿水平线 $y=0.5$（即索引为 $j=(N-1)/2$ 的节点）的数值解与精确解之间的最大绝对差，并按该线上精确解的最大振幅进行归一化。对于 $u_{\\mathrm{axis}}$，沿 $y=0.5$ 线的精确峰值出现在 $x=0.5$ 处，其值为 $1$。\n\n定义失效比\n$$R(N,\\sigma) = \\frac{E_{\\mathrm{diag}}}{E_{\\mathrm{axis}}}.$$\n$R(N,\\sigma) > 1$ 的值表示五点模板对于对角线对齐的尖锐特征表现出比轴对齐特征更大的误差，这表明了网格对齐的各向异性，以及在相当分辨率下无法解析对角线锐度的问题。\n\n您的程序必须：\n- 实现五点中心差分法，以求解 $u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$ 的泊松问题，使用相同的网格和 $\\sigma$。\n- 为每个测试案例计算 $E_{\\mathrm{diag}}$、$E_{\\mathrm{axis}}$ 和 $R(N,\\sigma)$。\n- 按照下文指定，将所有比率作为单个列表在一行上输出。\n\n不涉及物理单位。不使用角度。所有浮点输出均以普通十进制表示法表示。\n\n用于评估覆盖范围的测试套件：\n- 案例 1（欠解析的对角线特征）：$N=33$，$\\sigma=0.02$。\n- 案例 2（改进的分辨率）：$N=65$，$\\sigma=0.02$。\n- 案例 3（粗网格上的较宽特征）：$N=33$，$\\sigma=0.04$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含与上述案例对应的三个比率 $R(N,\\sigma)$，格式为方括号内以逗号分隔的列表，每个值四舍五入到 6 位小数（例如，$[r_1,r_2,r_3]$）。",
            "solution": "所提出的问题是一个有效且适定的数值分析练习。它涉及使用五点有限差分法求解二维泊松方程，并使用人造解方法来分析模板的各向异性误差特性。所有必需的信息都已提供，物理和数学基础是合理的，目标是清晰且可验证的。\n\n问题是在单位平方域 $\\Omega = [0,1]\\times[0,1]$ 上求解泊松方程：\n$$ - \\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in (0,1)\\times(0,1) $$\n狄利克雷边界条件为 $u(x,y) = u_{\\text{exact}}(x,y)$，其中 $(x,y) \\in \\partial\\Omega$。算子 $\\nabla^2$ 是拉普拉斯算子，$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n\n采用人造解方法。我们定义两个精确解，$u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$，并通过应用连续算子 $f = -\\nabla^2 u_{\\text{exact}}$ 推导出相应的强迫函数 $f(x,y)$。\n\n对于对角线脊，$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp(-\\frac{(x-y)^2}{2\\sigma^2})$。令 $g(s) = \\exp(-s^2/(2\\sigma^2))$ 且 $s=x-y$。其导数为 $g'(s) = -\\frac{s}{\\sigma^2}g(s)$ 和 $g''(s) = (\\frac{s^2}{\\sigma^4} - \\frac{1}{\\sigma^2})g(s)$。使用恒等式 $\\nabla^2 g(x-y) = 2g''(x-y)$，强迫函数为：\n$$ f_{\\mathrm{diag}}(x,y;\\sigma) = -2 g''(x-y) = -2 \\left(\\frac{(x-y)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) = 2\\left(\\frac{1}{\\sigma^2} - \\frac{(x-y)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) $$\n\n对于轴对齐脊，$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp(-\\frac{(x-0.5)^2}{2\\sigma^2})$。此函数仅依赖于 $x$。令 $h(x) = \\exp(-(x-0.5)^2/(2\\sigma^2))$。拉普拉斯算子为 $\\nabla^2 h(x) = \\frac{d^2h}{dx^2}$。二阶导数为 $\\frac{d^2h}{dx^2} = (\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2})h(x)$。强迫函数为：\n$$ f_{\\mathrm{axis}}(x,y;\\sigma) = -\\frac{d^2u_{\\mathrm{axis}}}{dx^2} = -\\left(\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) = \\left(\\frac{1}{\\sigma^2} - \\frac{(x-0.5)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) $$\n\n域使用一个包含 $N \\times N$ 个点的均匀笛卡尔网格进行离散化，其中 $N$ 是一个奇数。网格间距为 $h = 1/(N-1)$。设网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。设 $U_{i,j}$ 是 $u(x_i, y_j)$ 的数值近似。\n\n对于内部网格点 $(x_i, y_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$），负拉普拉斯算子的标准 $5$ 点中心差分近似为：\n$$ -\\nabla^2 u(x_i, y_j) \\approx \\frac{-U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} + 4U_{i,j}}{h^2} $$\n将其设为等于强迫项 $f(x_i, y_j) = f_{i,j}$，得到离散方程：\n$$ 4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} = h^2 f_{i,j} $$\n必须求解这个线性方程组，以得到 $(N-2) \\times (N-2)$ 个未知的内部值 $U_{i,j}$。边界上的值（$i=0, i=N-1, j=0$ 或 $j=N-1$）由狄利克雷条件 $U_{i,j} = u_{\\text{exact}}(x_i, y_j)$ 给出，是已知的。这些已知的边界值被移到与边界相邻的内部点的方程的右侧。\n\n这导致了一个形式为 $A\\mathbf{u} = \\mathbf{b}$ 的线性系统，其中 $\\mathbf{u}$ 是 $(N-2)^2$ 个未知内部网格值的向量，$A$ 是一个大小为 $(N-2)^2 \\times (N-2)^2$ 的稀疏、对称正定、块三对角矩阵，$\\mathbf{b}$ 是包含强迫项 $f$ 和边界条件的右端向量。矩阵 $A$ 的主对角线上为 $4$，对应于 $5$ 点模板中四个邻居的条目为 $-1$。这个稀疏系统被数值求解。\n\n在求解内部值之后，通过将内部解嵌入已知的精确边界值中来重建完整的数值解网格。\n\n然后沿特定线评估误差。对角线误差 $E_{\\mathrm{diag}}$ 是为 $u_{\\mathrm{diag}}$ 情况计算的：\n$$ E_{\\mathrm{diag}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,i} - u_{\\mathrm{diag}}(x_i, x_i)|}{\\max_{i} u_{\\mathrm{diag}}(x_i, x_i)} = \\max_{i} |U_{i,i} - 1| $$\n轴线误差 $E_{\\mathrm{axis}}$ 是为 $u_{\\mathrm{axis}}$ 情况沿直线 $y=0.5$ 计算的，这对应于网格索引 $j_{\\text{mid}} = (N-1)/2$：\n$$ E_{\\mathrm{axis}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})|}{\\max_{i} u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})} = \\max_{i} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})| $$\n在这两种情况下，沿各自线的精确解的归一化最大振幅均为 $1$。\n\n最后，计算失效比 $R(N,\\sigma) = E_{\\mathrm{diag}} / E_{\\mathrm{axis}}$ 以量化模板的各向异性误差。所提供的程序为每个指定的测试案例实现了这整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef u_diag_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    return np.exp(-s_sq / (2 * sigma_sq))\n\ndef f_diag_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-s_sq / (2 * sigma_sq))\n    return 2 * (1 / sigma_sq - s_sq / sigma_4) * exp_term\n\ndef u_axis_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    return np.exp(-z_sq / (2 * sigma_sq))\n\ndef f_axis_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-z_sq / (2 * sigma_sq))\n    return (1 / sigma_sq - z_sq / sigma_4) * exp_term\n\ndef solve_poisson(N, sigma, u_exact_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation using a 5-point finite difference stencil.\n    This implementation uses column-major ordering for unknowns.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    u_exact_grid = u_exact_func(X, Y, sigma)\n    f_grid = f_func(X, Y, sigma)\n    \n    M = N - 2\n    num_unknowns = M * M\n\n    # Construct the sparse matrix A for column-major ordering\n    main_diag_T = np.ones(M) * 4\n    off_diag_T = np.ones(M - 1) * -1\n    T = sparse.diags([off_diag_T, main_diag_T, off_diag_T], [-1, 0, 1], shape=(M, M), format='csr')\n    I_M = sparse.identity(M, format='csr')\n    A = sparse.kron(I_M, T) + sparse.diags([np.ones(M*(M-1))*-1, np.ones(M*(M-1))*-1], [-M, M], format='csr')\n    A = A.tocsc()\n    \n    # Construct the right-hand side vector b for column-major ordering\n    b = (h**2 * f_grid[1:-1, 1:-1]).flatten('F')\n    \n    # Boundary contributions for column-major vector b\n    # Left/Right boundaries (x=0, x=1)\n    g_left = u_exact_grid[0, 1:-1]\n    g_right = u_exact_grid[-1, 1:-1]\n    for j in range(M): # Iterate through rows of interior grid\n        # Points adjacent to left boundary (i=0)\n        k_left = 0 + j * M\n        b[k_left] += g_left[j]\n        # Points adjacent to right boundary (i=N-1)\n        k_right = (M - 1) + j * M\n        b[k_right] += g_right[j]\n\n    # Bottom/Top boundaries (y=0, y=1)\n    g_bottom = u_exact_grid[1:-1, 0]\n    g_top = u_exact_grid[1:-1, -1]\n    for i in range(M): # Iterate through columns of interior grid\n        # Points adjacent to bottom boundary (j=0)\n        k_bottom = i + 0 * M\n        b[k_bottom] += g_bottom[i]\n        # Points adjacent to top boundary (j=N-1)\n        k_top = i + (M - 1) * M\n        b[k_top] += g_top[i]\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n    \n    # Reshape solution vector to grid and insert into full solution grid\n    U_interior = u_vec.reshape((M, M), order='F')\n    U_numerical = np.copy(u_exact_grid)\n    U_numerical[1:-1, 1:-1] = U_interior\n    \n    return U_numerical, u_exact_grid\n\ndef solve():\n    test_cases = [\n        (33, 0.02),\n        (65, 0.02),\n        (33, 0.04),\n    ]\n\n    results = []\n    for N, sigma in test_cases:\n        # Diagonal case\n        U_diag_numerical, u_exact_diag_grid = solve_poisson(N, sigma, u_diag_func, f_diag_func)\n        diag_numerical = np.diag(U_diag_numerical)\n        diag_exact = np.diag(u_exact_diag_grid)\n        E_diag = np.max(np.abs(diag_numerical - diag_exact))\n\n        # Axis-aligned case\n        U_axis_numerical, u_exact_axis_grid = solve_poisson(N, sigma, u_axis_func, f_axis_func)\n        j_mid = (N - 1) // 2\n        axis_numerical_row = U_axis_numerical[:, j_mid]\n        axis_exact_row = u_exact_axis_grid[:, j_mid]\n        E_axis = np.max(np.abs(axis_numerical_row - axis_exact_row))\n        \n        # Failure ratio\n        R = E_diag / E_axis if E_axis != 0 else float('inf')\n        results.append(R)\n\n    # Format results for printing\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}