{
    "hands_on_practices": [
        {
            "introduction": "尽管许多教科书中的示例都使用均匀网格，但现实世界的问题通常需要非均匀网格来有效解析复杂特征。这个实践将指导你使用泰勒级数展开，在非均匀网格上从第一性原理推导有限差分近似。这项练习旨在构建一项核心技能，它对于理解和开发更高级的数值方法至关重要。",
            "id": "2392901",
            "problem": "考虑一个光滑标量场 $u(x)$，例如，它代表一维线性波动方程中的位移场，其中空间算子涉及二阶空间导数 $u_{xx}$。设 $x_{i-1}  x_i  x_{i+1}$ 是非均匀一维网格上的三个连续点。你的任务是推导一个逼近二阶导数 $u_{xx}(x_i)$ 的三点有限差分格式。请确定该格式的系数、局部截断误差的主项，并找出使该格式达到二阶精度的条件。",
            "solution": "问题陈述经过审阅，被认定是有效的。它在科学上基于数值分析的原理，提法恰当，数据充分且一致，并以客观的数学语言表达。它没有违反任何无效标准。因此，我们可以进行推导。\n\n我们的目标是确定形如 $L[u](x_i) = a\\,u(x_{i-1})+b\\,u(x_{i})+c\\,u(x_{i+1})$ 的有限差分近似的系数 $a$、$b$ 和 $c$，该近似用于逼近二阶导数 $u_{xx}(x_i) \\equiv u''(x_i)$。假设函数 $u(x)$ 至少是四次连续可微的。我们对 $u(x_{i+1})$ 和 $u(x_{i-1})$ 在点 $x_i$ 周围使用泰勒级数展开。令 $h_i = x_{i+1} - x_i$ 和 $h_{i-1} = x_i - x_{i-1}$。为简化推导，我们将 $u(x_k)$ 记为 $u_k$，并将 $u$ 在 $x_i$ 处的导数记为 $u'_i, u''_i, u'''_i, u^{(4)}_i$。\n\n泰勒级数展开式为：\n$$u(x_{i+1}) = u_{i+1} = u_i + h_i u'_i + \\frac{h_i^2}{2} u''_i + \\frac{h_i^3}{6} u'''_i + \\frac{h_i^4}{24} u^{(4)}_i + \\mathcal{O}(h_i^5)$$\n$$u(x_{i-1}) = u_{i-1} = u_i - h_{i-1} u'_i + \\frac{h_{i-1}^2}{2} u''_i - \\frac{h_{i-1}^3}{6} u'''_i + \\frac{h_{i-1}^4}{24} u^{(4)}_i + \\mathcal{O}(h_{i-1}^5)$$\n\n我们构造线性组合并代入这些展开式：\n$$a u_{i-1} + b u_i + c u_{i+1} = a\\left(u_i - h_{i-1} u'_i + \\frac{h_{i-1}^2}{2} u''_i - \\dots\\right) + b u_i + c\\left(u_i + h_i u'_i + \\frac{h_i^2}{2} u''_i + \\dots\\right)$$\n\n按 $u$ 在 $x_i$ 处的导数对各项进行分组：\n$$a u_{i-1} + b u_i + c u_{i+1} = (a+b+c)u_i + (c h_i - a h_{i-1})u'_i + \\left(\\frac{c h_i^2}{2} + \\frac{a h_{i-1}^2}{2}\\right)u''_i + \\left(\\frac{c h_i^3}{6} - \\frac{a h_{i-1}^3}{6}\\right)u'''_i + \\left(\\frac{c h_i^4}{24} + \\frac{a h_{i-1}^4}{24}\\right)u^{(4)}_i + \\dots$$\n\n为确保此表达式逼近 $u''_i$，我们匹配各导数的系数：\n1. $u_i$ 的系数：$a+b+c=0$\n2. $u'_i$ 的系数：$c h_i - a h_{i-1} = 0$\n3. $u''_i$ 的系数：$\\frac{c h_i^2}{2} + \\frac{a h_{i-1}^2}{2} = 1$\n\n从方程 $(2)$，我们得到 $a = c \\frac{h_i}{h_{i-1}}$。将此代入方程 $(3)$：\n$$\\frac{c h_i^2}{2} + \\frac{(c h_i/h_{i-1}) h_{i-1}^2}{2} = 1$$\n$$\\frac{c}{2} (h_i^2 + h_i h_{i-1}) = 1$$\n$$\\frac{c h_i}{2} (h_i + h_{i-1}) = 1$$\n由此得出系数 $c$：\n$$c = \\frac{2}{h_i(h_i + h_{i-1})}$$\n现在我们使用方程 $(2)$ 的关系式求出 $a$：\n$$a = c \\frac{h_i}{h_{i-1}} = \\frac{2}{h_i(h_i + h_{i-1})} \\frac{h_i}{h_{i-1}} = \\frac{2}{h_{i-1}(h_i + h_{i-1})}$$\n最后，我们从方程 $(1)$ 求出 $b$：\n$$b = -a - c = -\\left(\\frac{2}{h_{i-1}(h_i + h_{i-1})} + \\frac{2}{h_i(h_i + h_{i-1})}\\right)$$\n$$b = -\\frac{2}{h_i + h_{i-1}}\\left(\\frac{1}{h_{i-1}} + \\frac{1}{h_i}\\right) = -\\frac{2}{h_i + h_{i-1}}\\left(\\frac{h_i + h_{i-1}}{h_i h_{i-1}}\\right) = -\\frac{2}{h_i h_{i-1}}$$\n\n因此，$u_{xx}(x_i)$ 的有限差分近似为：\n$$L[u](x_i) = \\frac{2}{h_{i-1}(h_i + h_{i-1})} u_{i-1} - \\frac{2}{h_i h_{i-1}} u_i + \\frac{2}{h_i(h_i + h_{i-1})} u_{i+1}$$\n该表达式可以重排成一个更直观的形式：\n$$L[u](x_i) = \\frac{2}{h_i + h_{i-1}} \\left[ \\frac{u_{i+1} - u_i}{h_i} - \\frac{u_i - u_{i-1}}{h_{i-1}} \\right]$$\n这显示了该算子是一阶差商的差，并由平均间距 $\\frac{1}{2}(h_i+h_{i-1})$ 进行归一化。\n\n局部截断误差 $\\tau_i$ 定义为 $L[u](x_i) = u''(x_i) + \\tau_i$。$\\tau_i$ 的主项由泰勒展开中未被抵消的高阶项给出。\n$$\\tau_i = \\left(\\frac{c h_i^3}{6} - \\frac{a h_{i-1}^3}{6}\\right)u'''_i + \\left(\\frac{c h_i^4}{24} + \\frac{a h_{i-1}^4}{24}\\right)u^{(4)}_i + \\mathcal{O}(h^3)$$\n其中 $h = \\max\\{h_i, h_{i-1}\\}$。我们来计算这些系数。\n$u'''_i$ 的系数是：\n$$\\frac{1}{6}(c h_i^3 - a h_{i-1}^3) = \\frac{1}{6}\\left(\\frac{2 h_i^3}{h_i(h_i + h_{i-1})} - \\frac{2 h_{i-1}^3}{h_{i-1}(h_i + h_{i-1})}\\right) = \\frac{1}{3(h_i + h_{i-1})}(h_i^2 - h_{i-1}^2) = \\frac{1}{3}(h_i - h_{i-1})$$\n$u^{(4)}_i$ 的系数是：\n$$\\frac{1}{24}(c h_i^4 + a h_{i-1}^4) = \\frac{1}{24}\\left(\\frac{2 h_i^4}{h_i(h_i + h_{i-1})} + \\frac{2 h_{i-1}^4}{h_{i-1}(h_i + h_{i-1})}\\right) = \\frac{1}{12(h_i + h_{i-1})}(h_i^3 + h_{i-1}^3)$$\n使用恒等式 $h_i^3 + h_{i-1}^3 = (h_i+h_{i-1})(h_i^2 - h_i h_{i-1} + h_{i-1}^2)$，上式可简化为：\n$$\\frac{1}{12}(h_i^2 - h_i h_{i-1} + h_{i-1}^2)$$\n因此，局部截断误差的主项为：\n$$\\tau_i = \\frac{h_i - h_{i-1}}{3} u'''(x_i) + \\frac{h_i^2 - h_i h_{i-1} + h_{i-1}^2}{12} u^{(4)}(x_i) + \\mathcal{O}(h^3)$$\n相容性的阶数由 $\\tau_i$ 中 $h$ 的最低次幂决定。第一项是 $\\mathcal{O}(h_i - h_{i-1})$，第二项是 $\\mathcal{O}(h^2)$。对于一般的非均匀网格，$h_i - h_{i-1} = \\mathcal{O}(h)$，所以该格式是一阶相容的。\n要使该格式达到二阶相容，截断误差必须为 $\\mathcal{O}(h^2)$。这要求 $u'''(x_i)$ 项的系数为 $\\mathcal{O}(h^2)$ 阶。因此，条件是 $h_i - h_{i-1} = \\mathcal{O}(h^2)$。这正是问题陈述中提供的光滑网格假设。在此条件下，截断误差的主部为 $\\mathcal{O}(h^2)$，该近似是二阶精确的。",
            "answer": "$$\\boxed{\\frac{2}{h_i+h_{i-1}} \\left( \\frac{u(x_{i+1})-u(x_i)}{h_i} - \\frac{u(x_i)-u(x_{i-1})}{h_{i-1}} \\right)}$$"
        },
        {
            "introduction": "对于时间相关的偏微分方程，稳定性是数值方法的基石。本练习超越了标准的正向时间演化分析，探讨了波动方程格式在时间反向传播时的稳定性。这个思想实验不仅加深了对冯·诺依曼稳定性分析的理解，还揭示了数值格式本身的基本属性，例如时间可逆性。",
            "id": "2392915",
            "problem": "考虑均匀空间网格上的一维波动方程，\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,t) \\;=\\; c^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\n其波速 $c>0$ 为常数。设空间网格为 $x_j = j\\,\\Delta x$（$j$ 为整数），时间层级为 $t^n = n\\,\\Delta t$（$n$ 为整数）。考虑在时间和空间上均为二阶精度的标准显式中心有限差分格式，\n$$\nu_j^{n+1} \\;=\\; 2\\,u_j^{n} \\;-\\; u_j^{n-1} \\;+\\; \\left(\\frac{c\\,\\Delta t}{\\Delta x}\\right)^{2}\\,\\bigl(u_{j+1}^{n} - 2\\,u_j^{n} + u_{j-1}^{n}\\bigr),\n$$\n对所有整数 $j$ 和 $n$ 成立。假设我们打算从一个最终时间 $t=T$ 开始，随时间向后演化离散解，使用这个相同的递推关系，根据 $u^{n}$ 和 $u^{n+1}$ 的可用值来计算 $u^{n-1}$。假设在最后两个时间层级 $t=T$ 和 $t=T-\\Delta t$ 上有一致的离散数据，从而唯一地定义了时间反向步进。\n\n对时间反向演化的线性稳定性定义如下：对于形式为 $e^{\\mathrm{i}\\,j\\,\\theta}$（其中 $\\theta \\in [0,\\pi]$）的每个空间傅里叶模式，作用于连续两个时间层级对的相应单步时间反向推进算子的谱半径不超过 $1$。换句话说，对于所有 $\\theta \\in [0,\\pi]$，将 $\\bigl(u^{n+1},u^{n}\\bigr)$ 映射到 $\\bigl(u^{n},u^{n-1}\\bigr)$ 的线性映射的每个特征值的模最多为 $1$。\n\n您的任务是编写一个程序，对于下面测试套件中的每个参数三元组 $(c,\\Delta x,\\Delta t)$，判断该格式在上述定义的时间反向演化意义下是否是线性稳定的。对于每种情况，如果稳定则输出布尔值 $True$，否则输出 $False$。\n\n使用以下参数值的测试套件（每行是一个独立的测试用例）：\n- $(c,\\Delta x,\\Delta t) = (\\,1,\\;1,\\;0.5\\,)$\n- $(c,\\Delta x,\\Delta t) = (\\,2,\\;0.5,\\;0.25\\,)$\n- $(c,\\Delta x,\\Delta t) = (\\,1,\\;0.01,\\;0.012\\,)$\n- $(c,\\Delta x,\\Delta t) = (\\,0,\\;1,\\;0.1\\,)$\n- $(c,\\Delta x,\\Delta t) = (\\,3,\\;0.2,\\;0.07\\,)$\n- $(c,\\Delta x,\\Delta t) = (\\,1,\\;0.01,\\;0.0099\\,)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上述测试套件的顺序相同。例如，所需的格式是\n“[result1,result2,result3,result4,result5,result6]”。",
            "solution": "所述问题是有效的。它在科学上基于偏微分方程数值分析的既定理论，特别是有限差分格式的 von Neumann 稳定性分析。该问题是适定的，为时间反向演化提供了精确的稳定性定义和所有必要的参数。它是客观的，没有歧义。因此，我们可以进行形式化的求解。\n\n任务是确定一维波动方程的标准有限差分格式在用于时间反向演化时的线性稳定性。该格式由下式给出\n$$u_j^{n+1} \\;=\\; 2\\,u_j^{n} \\;-\\; u_j^{n-1} \\;+\\; \\left(\\frac{c\\,\\Delta t}{\\Delta x}\\right)^{2}\\,\\bigl(u_{j+1}^{n} - 2\\,u_j^{n} + u_{j-1}^{n}\\bigr).$$\n令 Courant 数记为 $\\sigma = \\frac{c\\,\\Delta t}{\\Delta x}$。为了分析时间反向演化，我们必须重新整理该格式以求解 $u_j^{n-1}$：\n$$u_j^{n-1} \\;=\\; 2u_j^n - u_j^{n+1} + \\sigma^2 \\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right).$$\n这个递推关系的稳定性使用 von Neumann 方法进行分析。我们考虑单个空间傅里叶模式作为试探解：\n$$u_j^n = \\hat{u}^n(\\theta) e^{\\mathrm{i}j\\theta},$$\n其中 $\\mathrm{i} = \\sqrt{-1}$，$j$ 是空间索引，$n$ 是时间索引，$\\theta = k_x \\Delta x$ 是波数为 $k_x$ 的空间模式的无量纲波数。将此代入反向递推关系，得到振幅 $\\hat{u}^n(\\theta)$ 的递推关系：\n$$\\hat{u}^{n-1} e^{\\mathrm{i}j\\theta} = 2\\hat{u}^n e^{\\mathrm{i}j\\theta} - \\hat{u}^{n+1} e^{\\mathrm{i}j\\theta} + \\sigma^2 \\hat{u}^n \\left(e^{\\mathrm{i}(j+1)\\theta} - 2e^{\\mathrm{i}j\\theta} + e^{\\mathrm{i}(j-1)\\theta}\\right).$$\n除以公因子 $e^{\\mathrm{i}j\\theta}$，我们得到：\n$$\\hat{u}^{n-1} = 2\\hat{u}^n - \\hat{u}^{n+1} + \\sigma^2 \\hat{u}^n \\left(e^{\\mathrm{i}\\theta} - 2 + e^{-\\mathrm{i}\\theta}\\right).$$\n使用恒等式 $e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta} = 2\\cos\\theta$，括号中的项变为 $2\\cos\\theta - 2 = -2(1-\\cos\\theta)$。进一步使用半角恒等式 $1-\\cos\\theta = 2\\sin^2(\\theta/2)$，我们简化振幅的递推关系：\n$$\\hat{u}^{n-1} = 2\\hat{u}^n - \\hat{u}^{n+1} + \\sigma^2 \\hat{u}^n \\left(-4\\sin^2(\\frac{\\theta}{2})\\right) \\\\\n\\hat{u}^{n-1} = \\left(2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2})\\right) \\hat{u}^n - \\hat{u}^{n+1}.$$\n问题通过连续两个时间层级上的一对值来定义状态。对于反向演化，第 $n+1$ 步的状态是向量 $\\mathbf{v}^{n+1} = \\begin{pmatrix} \\hat{u}^{n+1} \\\\ \\hat{u}^{n} \\end{pmatrix}$。该格式将此状态映射到前一个时间步的状态 $\\mathbf{v}^{n} = \\begin{pmatrix} \\hat{u}^{n} \\\\ \\hat{u}^{n-1} \\end{pmatrix}$。这个映射 $\\mathbf{v}^{n} = G(\\theta) \\mathbf{v}^{n+1}$ 由时间反向推进矩阵 $G(\\theta)$ 描述。我们如下构造该矩阵：\n$\\mathbf{v}^n$ 的第一个分量是 $\\hat{u}^n = 0 \\cdot \\hat{u}^{n+1} + 1 \\cdot \\hat{u}^n$。\n第二个分量由我们导出的递推关系给出：$\\hat{u}^{n-1} = (-1) \\cdot \\hat{u}^{n+1} + \\left(2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2})\\right) \\hat{u}^n$。\n因此，推进矩阵为：\n$$G(\\theta) = \\begin{pmatrix} 0  1 \\\\ -1  2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2}) \\end{pmatrix}.$$\n线性稳定性要求该矩阵的谱半径 $\\rho(G) = \\max_i |\\lambda_i|$ 对所有 $\\theta \\in [0, \\pi]$ 不超过 $1$。$G(\\theta)$ 的特征值 $\\lambda$ 可通过特征方程 $\\det(G(\\theta) - \\lambda I) = 0$ 求得：\n$$\\det \\begin{pmatrix} -\\lambda  1 \\\\ -1  2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2}) - \\lambda \\end{pmatrix} = 0 \\\\\n(-\\lambda)\\left(2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2}) - \\lambda\\right) - (1)(-1) = 0 \\\\\n\\lambda^2 - \\left(2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2})\\right)\\lambda + 1 = 0.$$\n这是一个形如 $\\lambda^2 - P\\lambda + 1 = 0$ 的二次方程，其中 $P = 2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2})$。根的乘积为 $1$。\n特征值的性质取决于判别式 $\\Delta = P^2 - 4$。\n如果 $\\Delta  0$，特征值是一对共轭复数。设 $\\lambda_1 = z$ 和 $\\lambda_2 = \\bar{z}$。它们的乘积为 $\\lambda_1\\lambda_2 = z\\bar{z} = |z|^2 = 1$。因此，如果特征值是复数，它们的模恰好为 $1$。这对应于稳定情况。复数特征值的条件是 $P^2  4$，即 $|P|  2$。\n$$-2  2 - 4\\sigma^2\\sin^2(\\frac{\\theta}{2})  2 \\\\\n-4  -4\\sigma^2\\sin^2(\\frac{\\theta}{2})  0 \\\\\n0  4\\sigma^2\\sin^2(\\frac{\\theta}{2})  4 \\\\\n0  \\sigma^2\\sin^2(\\frac{\\theta}{2})  1.$$\n如果 $\\Delta \\ge 0$，特征值是实数。由于它们的乘积为 $1$，如果它们的模不相等，则必有一个模大于 $1$，另一个模小于 $1$。对于稳定性（所有特征值满足 $|\\lambda| \\le 1$），这是不允许的。只有当两个特征值的模都等于 $1$ 时，即 $\\lambda = \\pm 1$ 时，才可能稳定。这只发生在复数根区域的边界上，即 $\\Delta = 0$ 时，对应于 $|P|=2$。这得到 $\\sigma^2\\sin^2(\\frac{\\theta}{2}) = 0$ 或 $\\sigma^2\\sin^2(\\frac{\\theta}{2}) = 1$。\n\n综合这些情况，对于给定的 $\\theta$，该格式是稳定的当且仅当 $|P| \\le 2$，这等价于条件 $0 \\le \\sigma^2\\sin^2(\\frac{\\theta}{2}) \\le 1$。\n为了使格式对所有可能的模式都稳定，此条件必须对所有 $\\theta \\in [0, \\pi]$ 成立。因此，我们必须在表达式 $\\sigma^2\\sin^2(\\frac{\\theta}{2})$ 取最大值处强制满足该条件。函数 $\\sin^2(\\frac{\\theta}{2})$ 在 $\\theta=\\pi$ 时达到其最大值 $1$。\n因此，稳定性的充要条件是：\n$$\\sigma^2 \\cdot \\max_{\\theta \\in [0, \\pi]} \\left(\\sin^2(\\frac{\\theta}{2})\\right) \\le 1 \\\\\n\\sigma^2 \\cdot 1 \\le 1 \\implies \\sigma^2 \\le 1.$$\n由于参数 $c$、$\\Delta t$ 和 $\\Delta x$ 是非负的，Courant 数 $\\sigma = \\frac{c\\,\\Delta t}{\\Delta x}$ 也是非负的。稳定性条件简化为：\n$$\\frac{c\\,\\Delta t}{\\Delta x} \\le 1.$$\n这就是著名的 Courant-Friedrichs-Lewy (CFL) 条件。值得注意的是，对于这个时间可逆的格式，反向演化的稳定性条件与正向演化的稳定性条件相同。我们现在将此准则应用于给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining backward-in-time stability for a finite\n    difference scheme of the 1D wave equation.\n    \"\"\"\n\n    # The test suite provides parameter triplets (c, Delta_x, Delta_t).\n    # Each line corresponds to one independent test case.\n    test_cases = [\n        (1.0, 1.0, 0.5),\n        (2.0, 0.5, 0.25),\n        (1.0, 0.01, 0.012),\n        (0.0, 1.0, 0.1),\n        (3.0, 0.2, 0.07),\n        (1.0, 0.01, 0.0099),\n    ]\n\n    results = []\n    for case in test_cases:\n        c, delta_x, delta_t = case\n\n        # The stability of the scheme, both for forward and backward time evolution,\n        # is determined by the Courant-Friedrichs-Lewy (CFL) condition.\n        # The Courant number, sigma, must be less than or equal to 1.\n        # sigma = (c * delta_t) / delta_x\n        #\n        # A case with delta_x = 0 would be physically and numerically meaningless,\n        # but we add a check to prevent division by zero for robustness, though\n        # not required by the problem's test cases.\n        if delta_x == 0:\n            # If c * delta_t is non-zero, this would be infinitely unstable.\n            # If c * delta_t is zero, the case is ambiguous but we treat it as unstable.\n            is_stable = False\n        else:\n            courant_number = (c * delta_t) / delta_x\n            is_stable = (courant_number = 1.0)\n        \n        results.append(is_stable)\n\n    # The final output must be a single line containing a comma-separated\n    # list of boolean results enclosed in square brackets.\n    # The str() function for booleans in Python produces \"True\" or \"False\",\n    # which matches the required output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理问题天然地适用于曲线坐标系，但这常常会引入奇点，给直接进行数值离散化带来挑战。本练习将处理球对称波动方程，其中包含一个常见的原点奇点。你将学习一种强大的技巧——变量替换——将方程转换为一个可以用标准有限差分法轻松求解的更简单形式，这是计算工程中的一个关键策略。",
            "id": "2392876",
            "problem": "考虑一维球对称波动方程\n$$\nu_{tt}(r,t) = c^2\\left(u_{rr}(r,t) + \\frac{2}{r}u_r(r,t)\\right), \\quad r \\in [0,R], \\ t \\ge 0,\n$$\n其正则性要求为解在原点处是有限的。所有量均为无量纲。初始位移和初始速度由下式指定\n$$\nu(r,0) = \\frac{1}{r} f(r), \\quad u_t(r,0) = 0,\n$$\n其中\n$$\nf(r) = r \\exp\\!\\left(-\\frac{(r - r_c)^2}{2\\sigma^2}\\right),\n$$\n且在原点处的值必须解释为极限\n$$\nu(0,0) = \\lim_{r \\to 0^+} \\frac{f(r)}{r}.\n$$\n在外边界上，施加齐次狄利克雷条件\n$$\nu(R,t) = 0 \\quad \\text{for all } t \\ge 0.\n$$\n你必须为原点处的奇异项设计一个数值稳定且一致的处理方法，在空间和时间的均匀网格上实现一个时域有限差分求解器，并将解演化到指定的最终时刻。为进行误差评估，需将数值解与如下构造的精确解进行比较。将 $f$ 在实数轴上的奇延拓定义为\n$$\n\\tilde{f}(x) = \\begin{cases}\nf(x),  x \\ge 0, \\\\\n-f(-x),  x  0,\n\\end{cases}\n$$\n并设\n$$\nv(r,t) = \\frac{1}{2}\\left[\\tilde{f}(r - c t) + \\tilde{f}(r + c t)\\right], \\quad r \\ge 0, \\ t \\ge 0.\n$$\n则精确位移为\n$$\nu_{\\text{exact}}(r,t) = \\begin{cases}\n\\displaystyle \\frac{v(r,t)}{r},  r > 0, \\\\[8pt]\n\\displaystyle \\left.\\frac{\\partial v}{\\partial r}\\right|_{r=0,t},  r = 0,\n\\end{cases}\n$$\n其中原点处的导数由下式给出\n$$\nu_{\\text{exact}}(0,t) = f'(c t), \\quad f'(r) = \\exp\\!\\left(-\\frac{(r - r_c)^2}{2\\sigma^2}\\right) - \\frac{r(r - r_c)}{\\sigma^2} \\exp\\!\\left(-\\frac{(r - r_c)^2}{2\\sigma^2}\\right).\n$$\n使用以下参数值的测试套件；所有量均为无量纲：\n\n- 所有测试的通用参数：$c = 1.0$， $R = 2.0$， $r_c = 0.6$， $\\sigma = 0.08$。\n- 测试 1 (内部稳定性，亚库朗情况)：$[0,R]$ 上的空间子区间数 $N = 400$；空间步长 $\\Delta r = R/N$；时间步长 $\\Delta t = 0.9 \\, \\Delta r / c$；时间步数 $M = 50$；最终时刻 $T = M \\Delta t$。\n- 测试 2 (边界库朗情况)：$N = 400$；$\\Delta r = R/N$；$\\Delta t = 1.0 \\, \\Delta r / c$；$M = 50$；$T = M \\Delta t$。\n- 测试 3 (用于稳定性检测的超库朗压力测试)：$N = 300$；$\\Delta r = R/N$；$\\Delta t = 1.05 \\, \\Delta r / c$；$M = 200$；$T = M \\Delta t$。\n\n你的程序必须：\n\n- 实现一个有限差分求解器，该求解器在网格点 $r_i = i \\Delta r$（$i = 0,1,\\dots,N$）处生成数值近似解 $u_{\\text{num}}(r_i, T)$。\n- 对于测试 1 和测试 2，计算均方根误差\n$$\nE = \\left(\\frac{1}{N+1} \\sum_{i=0}^N \\left[u_{\\text{num}}(r_i,T) - u_{\\text{exact}}(r_i,T)\\right]^2 \\right)^{1/2}.\n$$\n- 对于测试 3，返回一个布尔值，指示数值解在所有网格点和所有时间步（直到并包括最终时刻 $T$）的绝对值是否保持在 $10^6$ 以内且为有限值；如果保持有界且有限，则返回 $\\text{True}$，否则返回 $\\text{False}$。\n- 此外，对于测试 1，报告最终时刻在原点处的绝对误差，\n$$\nE_0 = \\left|u_{\\text{num}}(0,T) - u_{\\text{exact}}(0,T)\\right|.\n$$\n\n最终输出格式：你的程序应生成一行输出，其中包含一个列表，列表内有四个条目，顺序为 $[E_{\\text{Test 1}}, E_{\\text{Test 2}}, \\text{Stable}_{\\text{Test 3}}, E_{0,\\text{Test 1}}]$，打印为用逗号分隔并用方括号括起来的列表（例如，$[0.00123,0.00111,True,0.00045]$）。除第三个条目为布尔值外，所有输出均为无量纲实数。此问题不涉及角度。不使用或推断其他单位。",
            "solution": "该问题陈述提出了一个针对一维球对称波动方程的定义明确的初边值问题。它在科学上是合理的、自洽的且客观的。所有用于验证的参数、条件和要求都已明确指定。所提供的基于 d'Alembert 公式的“精确”解适用于指定的模拟时间，因为在计算误差的测试案例中，来自外边界 $r=R$ 的反射没有时间影响解域。因此，该问题是有效的，我将着手解决它。\n\n控制性偏微分方程 (PDE) 是\n$$\nu_{tt} = c^2\\left(u_{rr} + \\frac{2}{r}u_r\\right)\n$$\n其中 $u=u(r,t)$，下标表示偏微分。项 $\\frac{2}{r}u_r$ 在原点 $r=0$ 处存在一个奇点，这在数值格式中需要特殊处理。\n\n处理这种奇点的一个稳健且标准的方法是引入变量替换。令 $v(r,t) = r u(r,t)$。我们可以用 $v$ 来表示 $u$ 的偏导数：\n$$\nu = \\frac{v}{r} \\implies u_r = \\frac{v_r r - v}{r^2}, \\quad u_{rr} = \\frac{(v_{rr} r) r^2 - (v_r r - v) 2r}{r^4} = \\frac{v_{rr}}{r} - \\frac{2v_r}{r^2} + \\frac{2v}{r^3}\n$$\n将这些代入原始 PDE 中得到：\n$$\n\\left(\\frac{v}{r}\\right)_{tt} = c^2\\left(\\left(\\frac{v_{rr}}{r} - \\frac{2v_r}{r^2} + \\frac{2v}{r^3}\\right) + \\frac{2}{r}\\left(\\frac{v_r r - v}{r^2}\\right)\\right)\n$$\n$$\n\\frac{v_{tt}}{r} = c^2\\left(\\frac{v_{rr}}{r} - \\frac{2v_r}{r^2} + \\frac{2v}{r^3} + \\frac{2v_r}{r^2} - \\frac{2v}{r^3}\\right)\n$$\n$$\n\\frac{v_{tt}}{r} = c^2 \\frac{v_{rr}}{r}\n$$\n对于 $r>0$，这简化为 $v(r,t)$ 的典型一维波动方程：\n$$\nv_{tt} = c^2 v_{rr}\n$$\n这个变换有效地移除了奇点。我们现在可以求解 $v(r,t)$，然后恢复 $u(r,t)$。\n\n接下来，我们必须将 $u$ 的初始条件和边界条件转换为 $v$ 的条件：\n1.  **初始位移：** $v(r,0) = r u(r,0) = r \\left(\\frac{1}{r} f(r)\\right) = f(r)$。\n2.  **初始速度：** $v_t(r,0) = r u_t(r,0) = r \\cdot 0 = 0$。\n3.  **$r=R$ 处的边界条件：** $v(R,t) = R u(R,t) = R \\cdot 0 = 0$。\n4.  **$r=0$ 处的边界条件：** $u(r,t)$ 在原点处有限的要求意味着 $v(0,t) = \\lim_{r \\to 0} r u(r,t) = 0$。\n\n我们现在得到了一个关于 $v(r,t)$ 在区域 $[0,R]$ 上的标准一维波动方程问题，其边界条件为齐次狄利克雷条件 $v(0,t)=v(R,t)=0$。我们可以使用时域有限差分 (FDTD) 方法，在空间步长为 $\\Delta r = R/N$、时间步长为 $\\Delta t$ 的均匀网格上求解。令 $v_i^n \\approx v(i\\Delta r, n\\Delta t)$。对导数 $v_{tt}$ 和 $v_{rr}$ 使用二阶中心差分，我们得到显式蛙跳格式：\n$$\n\\frac{v_i^{n+1} - 2v_i^n + v_i^{n-1}}{(\\Delta t)^2} = c^2 \\frac{v_{i+1}^n - 2v_i^n + v_{i-1}^n}{(\\Delta r)^2}\n$$\n解出 $v_i^{n+1}$，得到内部点（$i=1, \\dots, N-1$）的更新规则：\n$$\nv_i^{n+1} = 2v_i^n - v_i^{n-1} + \\lambda^2 (v_{i+1}^n - 2v_i^n + v_{i-1}^n)\n$$\n其中 $\\lambda = c \\Delta t / \\Delta r$ 是 Courant-Friedrichs-Lewy (CFL) 数。该格式在 $\\lambda \\le 1$ 时稳定。\n\n为了开始模拟，我们需要两个初始时间层 $n=0$ 和 $n=1$ 的值。我们有 $v_i^0 = f(r_i)$。对于第一个时间步，我们对初始速度条件 $v_t(r,0)=0$ 使用中心差分：\n$$\n\\frac{v_i^1 - v_i^{-1}}{2\\Delta t} = 0 \\implies v_i^{-1} = v_i^1\n$$\n将此代入 $n=0$ 的主更新规则中：\n$$\nv_i^1 = 2v_i^0 - v_i^{-1} + \\lambda^2(v_{i+1}^0 - 2v_i^0 + v_{i-1}^0) = 2v_i^0 - v_i^1 + \\lambda^2(v_{i+1}^0 - 2v_i^0 + v_{i-1}^0)\n$$\n$$\nv_i^1 = v_i^0 + \\frac{\\lambda^2}{2} (v_{i+1}^0 - 2v_i^0 + v_{i-1}^0)\n$$\n这提供了 $v_i^1$ 的值，使得时间步进可以继续。边界条件 $v_0^n=0$ 和 $v_N^n=0$ 在所有时间步都强制执行。\n\n在将 $v_i^n$ 演化到最终时间 $T=M\\Delta t$ 后，我们必须重构解 $u_i^M$。\n-   对于内部点 $r_i > 0$（即 $i=1, \\dots, N$），重构是直接的：$u_i^M = v_i^M / r_i = v_i^M / (i\\Delta r)$。\n-   在原点 $r_0=0$ 处，我们有 $u(0,t) = \\lim_{r\\to 0} u(r,t) = \\lim_{r\\to 0} \\frac{v(r,t)}{r}$。由于 $v(0,t)=0$，这是 $v$ 关于 $r$ 在 $r=0$ 处的偏导数的定义。\n    $$\n    u(0,t) = \\left. \\frac{\\partial v}{\\partial r} \\right|_{r=0, t}\n    $$\n    我们可以用中心差分来近似这个导数。根据 d'Alembert 解的结构，$v$ 必须是关于原点的奇函数。这意味着 $v(-\\Delta r, t) = -v(\\Delta r, t)$，所以 $v_{-1}^n = -v_1^n$。\n    $$\n    u_0^M = \\frac{v_1^M - v_{-1}^M}{2\\Delta r} = \\frac{v_1^M - (-v_1^M)}{2\\Delta r} = \\frac{2v_1^M}{2\\Delta r} = \\frac{v_1^M}{\\Delta r}\n    $$\n这样就完成了数值方法。实现将遵循这种变换变量的方法。对于测试 3，CFL 数 $\\lambda=1.05>1$，违反了稳定性条件；我们预计数值解会呈指数增长，这将通过检查其幅度是否超过一个大阈值（$10^6$）来检测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D spherically symmetric wave equation using an FDTD scheme\n    and evaluates results for three test cases.\n    \"\"\"\n\n    # Common parameters for all tests\n    c_param = 1.0\n    R_param = 2.0\n    rc_param = 0.6\n    sigma_param = 0.08\n    \n    # Test cases defined in the problem statement\n    test_cases = [\n        {'N': 400, 'cfl': 0.9, 'M': 50, 'id': 'Test 1'},\n        {'N': 400, 'cfl': 1.0, 'M': 50, 'id': 'Test 2'},\n        {'N': 300, 'cfl': 1.05, 'M': 200, 'id': 'Test 3'},\n    ]\n\n    # Helper functions for the exact solution\n    def f(r, rc, sigma):\n        \"\"\"Initial condition function f(r).\"\"\"\n        return r * np.exp(-(r - rc)**2 / (2 * sigma**2))\n\n    def f_tilde(x, rc, sigma):\n        \"\"\"Odd extension of f(r).\"\"\"\n        x = np.asarray(x)\n        # Use np.where to handle piecewise definition\n        positive_x = x[x = 0]\n        negative_x = x[x  0]\n        \n        # Explicitly define for positive and negative parts\n        f_pos = f(positive_x, rc, sigma)\n        f_neg = -f(-negative_x, rc, sigma)\n        \n        # Combine results\n        result = np.zeros_like(x, dtype=float)\n        result[x = 0] = f_pos\n        result[x  0] = f_neg\n        return result\n\n    def f_prime(r, rc, sigma):\n        \"\"\"Derivative of f(r).\"\"\"\n        factor = np.exp(-(r - rc)**2 / (2 * sigma**2))\n        return factor - r * (r - rc) / sigma**2 * factor\n\n    def get_u_exact(r_grid, t, c, rc, sigma):\n        \"\"\"Computes the exact solution u(r,t).\"\"\"\n        u_ex = np.zeros_like(r_grid, dtype=float)\n        \n        r_plus_ct = r_grid + c * t\n        r_minus_ct = r_grid - c * t\n        \n        v_exact_t = 0.5 * (f_tilde(r_minus_ct, rc, sigma) + f_tilde(r_plus_ct, rc, sigma))\n        \n        # For r  0\n        mask_r_pos = r_grid > 0\n        u_ex[mask_r_pos] = v_exact_t[mask_r_pos] / r_grid[mask_r_pos]\n        \n        # For r = 0\n        if r_grid[0] == 0:\n            u_ex[0] = f_prime(c * t, rc, sigma)\n        \n        return u_ex\n\n    def run_simulation(N, cfl, M, c, R, rc, sigma, check_stability=False):\n        \"\"\"\n        Runs the FDTD simulation for the transformed variable v = r*u.\n        \"\"\"\n        dr = R / N\n        dt = cfl * dr / c\n        r_grid = np.linspace(0, R, N + 1)\n        lambda_sq = (c * dt / dr)**2\n\n        # Arrays for v at n-1, n, n+1 time steps\n        v_prev = np.zeros(N + 1)\n        v_curr = f(r_grid, rc, sigma)\n\n        # Enforce boundary conditions on initial state v(r,0)\n        v_curr[0] = 0.0\n        v_curr[N] = 0.0\n        \n        # This is not needed as v_curr is a new array, but for safety\n        v_prev[:] = v_curr\n\n        # First time step using v_t(r,0)=0\n        v_next = np.zeros(N + 1)\n        for i in range(1, N):\n            v_next[i] = v_curr[i] + 0.5 * lambda_sq * (v_curr[i+1] - 2 * v_curr[i] + v_curr[i-1])\n        \n        v_prev[:] = v_curr\n        v_curr[:] = v_next\n\n        # Main FDTD loop\n        for _ in range(1, M):\n            v_temp = v_curr.copy()\n            for i in range(1, N):\n                v_next[i] = 2.0 * v_curr[i] - v_prev[i] + lambda_sq * (v_curr[i+1] - 2.0 * v_curr[i] + v_curr[i-1])\n            \n            v_prev[:] = v_temp\n            v_curr[:] = v_next\n\n            if check_stability:\n                u_check = np.zeros(N + 1)\n                if dr > 0:\n                    u_check[1:] = v_curr[1:] / r_grid[1:]\n                    u_check[0] = v_curr[1] / dr\n                if np.any(np.abs(u_check) > 1e6) or np.any(np.isnan(u_check)):\n                    return False  # Unstable\n        \n        if check_stability:\n            return True # Stable\n\n        # Reconstruct u from v at final time\n        u_num = np.zeros(N + 1)\n        if dr > 0:\n            u_num[1:] = v_curr[1:] / r_grid[1:]\n            u_num[0] = v_curr[1] / dr\n        return u_num\n\n    results = {}\n    for case in test_cases:\n        N, cfl, M, case_id = case['N'], case['cfl'], case['M'], case['id']\n\n        if case_id == 'Test 3':\n            is_stable = run_simulation(N, cfl, M, c_param, R_param, rc_param, sigma_param, check_stability=True)\n            results['stable_test3'] = is_stable\n        else:\n            T_final = M * cfl * (R_param / N) / c_param\n            u_numerical = run_simulation(N, cfl, M, c_param, R_param, rc_param, sigma_param)\n            \n            r_points = np.linspace(0, R_param, N + 1)\n            u_analytical = get_u_exact(r_points, T_final, c_param, rc_param, sigma_param)\n\n            rms_error = np.sqrt(np.mean((u_numerical - u_analytical)**2))\n\n            if case_id == 'Test 1':\n                results['E_test1'] = rms_error\n                origin_error = np.abs(u_numerical[0] - u_analytical[0])\n                results['E0_test1'] = origin_error\n            elif case_id == 'Test 2':\n                results['E_test2'] = rms_error\n\n    # Assemble the final list in the required order\n    final_output = [\n        results['E_test1'],\n        results['E_test2'],\n        results['stable_test3'],\n        results['E0_test1']\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```"
        }
    ]
}