{
    "hands_on_practices": [
        {
            "introduction": "在我们应用有限差分公式之前，理解它们的来源至关重要。这项实践将指导你使用泰勒级数展开，从第一性原理推导出一个二维混合偏导数的差分格式。掌握这项基本功，能让你在面对标准教科书中未包含的微分算子时，有能力自行构建合适的数值逼近格式 ()。",
            "id": "2418865",
            "problem": "考虑一个函数 $f(x,y)$，它在一个点 $(x_i,y_j)$ 的邻域内是三阶连续可微的。该函数在间距为 $h_x0$ 和 $h_y0$ 的均匀笛卡尔网格上进行采样，其中 $x_{i\\pm 1}=x_i\\pm h_x$ 且 $y_{j\\pm 1}=y_j\\pm h_y$。将网格采样点记为 $f_{i,j}=f(x_i,y_j)$，$f_{i\\pm 1,j\\pm 1}=f(x_{i\\pm 1},y_{j\\pm 1})$。\n\n使用在 $(x_i,y_j)$ 处获得相容近似所需的最少网格点数，构造一个在该均匀网格上近似混合偏导数 $\\frac{\\partial^2 f}{\\partial x \\partial y}(x_i,y_j)$ 的有限差分模板。将您的最终结果表示为仅含 $f_{i\\pm 1,j\\pm 1}$、$h_x$ 和 $h_y$ 的单个封闭形式解析表达式。最终结果中不要包含任何中间步骤。",
            "solution": "我们寻求在间距为 $h_x$ 和 $h_y$ 的均匀笛卡尔网格上，使用尽可能少的网格点来得到混合偏导数 $\\frac{\\partial^2 f}{\\partial x \\partial y}(x_i,y_j)$ 的一个相容有限差分近似。在均匀网格上，对于 $(x_i,y_j)$ 处的相容性和局部性的一个最小且自然的要求是，模板应以 $(x_i,y_j)$ 为中心，并使用对称点，以便在形成线性组合时抵消低阶项。在二维空间中，不包含 $(x_i,y_j)$ 且满足分离混合导数所需奇偶性的最小对称点集，由四个对角相邻点组成：$(x_{i+1},y_{j+1})$、$(x_{i+1},y_{j-1})$、$(x_{i-1},y_{j+1})$ 和 $(x_{i-1},y_{j-1})$。\n\n为从第一性原理推导系数，我们在 $(x_i,y_j)$ 点将函数 $f$ 在这四个对角位置展开为三阶二元泰勒级数。令 $f$ 的下标表示在 $(x_i,y_j)$ 处求得的偏导数，例如 $f_x=\\frac{\\partial f}{\\partial x}(x_i,y_j)$，$f_{xy}=\\frac{\\partial^2 f}{\\partial x \\partial y}(x_i,y_j)$，更高阶导数以此类推。那么\n\n$$\n\\begin{aligned}\nf_{i+1,j+1}=f+ h_x f_x + h_y f_y + \\tfrac{1}{2} h_x^2 f_{xx} + \\tfrac{1}{2} h_y^2 f_{yy} + h_x h_y f_{xy} + \\tfrac{1}{6} h_x^3 f_{xxx} + \\tfrac{1}{6} h_y^3 f_{yyy} \\\\\n\\quad + \\tfrac{1}{2} h_x^2 h_y f_{xxy} + \\tfrac{1}{2} h_x h_y^2 f_{xyy} + \\mathcal{O}(h_x^4, h_y^4, h_x^3 h_y, h_x h_y^3),\\\\\nf_{i+1,j-1}=f+ h_x f_x - h_y f_y + \\tfrac{1}{2} h_x^2 f_{xx} + \\tfrac{1}{2} h_y^2 f_{yy} - h_x h_y f_{xy} + \\tfrac{1}{6} h_x^3 f_{xxx} - \\tfrac{1}{6} h_y^3 f_{yyy} \\\\\n\\quad + \\tfrac{1}{2} h_x^2 h_y f_{xxy} - \\tfrac{1}{2} h_x h_y^2 f_{xyy} + \\mathcal{O}(h_x^4, h_y^4, h_x^3 h_y, h_x h_y^3),\\\\\nf_{i-1,j+1}=f- h_x f_x + h_y f_y + \\tfrac{1}{2} h_x^2 f_{xx} + \\tfrac{1}{2} h_y^2 f_{yy} - h_x h_y f_{xy} - \\tfrac{1}{6} h_x^3 f_{xxx} + \\tfrac{1}{6} h_y^3 f_{yyy} \\\\\n\\quad - \\tfrac{1}{2} h_x^2 h_y f_{xxy} + \\tfrac{1}{2} h_x h_y^2 f_{xyy} + \\mathcal{O}(h_x^4, h_y^4, h_x^3 h_y, h_x h_y^3),\\\\\nf_{i-1,j-1}=f- h_x f_x - h_y f_y + \\tfrac{1}{2} h_x^2 f_{xx} + \\tfrac{1}{2} h_y^2 f_{yy} + h_x h_y f_{xy} - \\tfrac{1}{6} h_x^3 f_{xxx} - \\tfrac{1}{6} h_y^3 f_{yyy} \\\\\n\\quad - \\tfrac{1}{2} h_x^2 h_y f_{xxy} - \\tfrac{1}{2} h_x h_y^2 f_{xyy} + \\mathcal{O}(h_x^4, h_y^4, h_x^3 h_y, h_x h_y^3).\n\\end{aligned}\n$$\n\n考虑线性组合\n\n$$\nS \\equiv f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}.\n$$\n\n将上述展开式逐项相加减，常数项 $f$ 被抵消，所有涉及一阶导数（$f_x$, $f_y$）的项以及纯二阶导数（$f_{xx}$, $f_{yy}$）的项也都被抵消。混合二阶导数项 $f_{xy}$ 则相长相加：\n\n$$\nS = 4 h_x h_y f_{xy} + \\mathcal{O}(h_x^3 h_y, h_x h_y^3).\n$$\n\n两边除以 $4 h_x h_y$ 得到近似式\n\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y}(x_i,y_j) = \\frac{f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}}{4 h_x h_y} + \\mathcal{O}\\!\\left(h_x^2 + h_y^2\\right).\n$$\n\n该模板恰好使用四个函数值，这是在均匀网格上对 $(x_i,y_j)$ 处的混合导数进行对称、中心、相容近似所需的最小网格点数。因此，所求的有限差分模板即为上述的对角四点公式，其封闭形式解析表达式为\n\n$$\n\\frac{f_{i+1,j+1} - f_{i+1,j-1} - f_{i-1,j+1} + f_{i-1,j-1}}{4 h_x h_y}.\n$$",
            "answer": "$$\\boxed{\\frac{f_{i+1,j+1}-f_{i+1,j-1}-f_{i-1,j+1}+f_{i-1,j-1}}{4\\,h_{x}\\,h_{y}}}$$"
        },
        {
            "introduction": "有限差分法不仅是局部的计算模板，我们还可以将其看作作用于整个网格函数上的线性算子，并表示为矩阵。这项实践要求你构建周期性边界条件下的一阶导数矩阵，并分析其本征值 ()。通过分析算子的谱特性，我们可以深入理解其数值行为，这对于研究数值格式的稳定性和精度至关重要。",
            "id": "2418819",
            "problem": "考虑一个长度为 $L$ 的一维域上的均匀周期网格，其上有 $N$ 个网格点，位置为 $x_j = jh$，$j \\in \\{0,1,\\ldots,N-1\\}$，间距为 $h = L/N$。定义作用于网格函数 $\\mathbf{u} = (u_0,\\ldots,u_{N-1})^\\top$ 的离散一阶导数算子 $D$，其形式为反对称的最近邻线性组合：\n$$(D\\mathbf{u})_j = \\frac{u_{j+1} - u_{j-1}}{2h},$$\n其中下标按模 $N$ 解释以强制周期性，即 $u_{-1} \\equiv u_{N-1}$ 且 $u_{N} \\equiv u_{0}$。这样就定义了一个具有周期性边界条件的 $N \\times N$ 实矩阵 $D$。\n\n任务：对于下面列出的每个测试用例 $(N,L)$，构造如上定义的矩阵 $D$，计算其所有特征值，并返回这些特征值的虚部。\n\n测试集（每对为 $(N,L)$，其中 $L$ 无量纲）：\n- 案例 1：$(N,L) = (2, 1)$。\n- 案例 2：$(N,L) = (3, 2\\pi)$。\n- 案例 3：$(N,L) = (5, 1)$。\n- 案例 4：$(N,L) = (8, 2)$。\n\n答案规格：\n- 对于每个测试用例，输出一个列表，其中包含 $D$ 的所有 $N$ 个特征值的虚部，并按非递减顺序排序。\n- 将每个值四舍五入到 $12$ 位小数。\n- 将所有测试用例的结果汇总到一个列表的列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔的列表的列表（例如：\"[[a_1,a_2,\\ldots,a_N],[b_1,b_2,\\ldots,b_N],\\ldots]\"），其中每个内部列表对应于上面列出的相同顺序的测试用例。",
            "solution": "该问题要求计算均匀周期网格上离散一阶导数算子的特征值。该问题陈述的有效性得到了证实，因为它在数值分析方面有科学依据，是适定且客观的。\n\n算子 $D$ 近似于一阶导数 $\\frac{d}{dx}$，由二阶中心差分公式定义：\n$$ (D\\mathbf{u})_j = \\frac{u_{j+1} - u_{j-1}}{2h} $$\n这里，$\\mathbf{u} = (u_0, u_1, \\ldots, u_{N-1})^\\top$ 是一个向量，表示一个函数在 $N$ 个网格点 $x_j = jh$（其中 $j \\in \\{0, 1, \\ldots, N-1\\}$）上的取值。网格间距为 $h=L/N$，其中 $L$ 是域的长度。下标是周期性的，即 $u_{N} \\equiv u_0$ 和 $u_{-1} \\equiv u_{N-1}$。\n\n这个线性算子可以由一个 $N \\times N$ 矩阵 $D$ 表示。该矩阵的元素 $D_{jk}$ 由表达式 $(D\\mathbf{u})_j$ 中 $u_k$ 的系数确定。根据公式，第 $j$ 行中唯一的非零元素是：\n$$ D_{j, (j+1) \\pmod N} = \\frac{1}{2h} $$\n$$ D_{j, (j-1) \\pmod N} = -\\frac{1}{2h} $$\n得到的矩阵 $D$ 是一个实的、稀疏的、循环矩阵。它也是反对称的，即 $D^\\top = -D$。实反对称矩阵的一个基本性质是其特征值为纯虚数。这与周期域上连续算子 $\\frac{d}{dx}$ 的特征值为 $i k$（其中 $k$ 为波数）这一事实相符。\n\n任务是为几对 $(N, L)$ 找到该矩阵 $D$ 的特征值。对于给定的 $N$ 和 $L$，构造矩阵 $D$。然后，使用标准的数值算法计算其 $N$ 个特征值 $\\lambda_k$。根据理论，这些特征值将是纯虚数，因此其实部为零（或由于浮点误差，在数值上是一个非常小的数）。问题要求我们提取这些特征值的虚部。\n\n特征值的解析解是已知的，可作为理论验证：\n$$ \\lambda_k = i \\frac{N}{L} \\sin\\left(\\frac{2\\pi k}{N}\\right) \\quad \\text{for } k \\in \\{0, 1, \\ldots, N-1\\} $$\n因此，虚部为 $\\text{Im}(\\lambda_k) = \\frac{N}{L} \\sin\\left(\\frac{2\\pi k}{N}\\right)$。这个公式证实了特征值是纯虚数，并为数值程序的验证提供了期望值。对于 $N=2$ 的特殊情况，在模 $2$ 运算下，模板点 $j+1$ 和 $j-1$ 变得相同，导致分子 $u_{j+1} - u_{j-1}$ 为零。因此，对于 $N=2$，$D$ 矩阵是零矩阵，其特征值均为 $0$。解析公式正确地预测了这一点，因为对于整数 $k$，$\\sin(\\pi k) = 0$。\n\n每个测试用例 $(N, L)$ 的计算过程如下：\n$1$. 计算网格间距 $h = L/N$。\n$2$. 构造 $N \\times N$ 矩阵 $D$。对于 $N2$，这是一个带状矩阵，其非零元素位于第一超对角线和次对角线上，以及由于周期性而产生的角点元素。对于 $N \\le 2$，它是零矩阵。\n$3$. 使用数值库函数（例如 `numpy.linalg.eigvals`）计算 $D$ 的特征值。\n$4$. 提取每个特征值的虚部。\n$5$. 按非递减顺序对虚部列表进行排序。\n$6$. 将排序后列表中的每个值四舍五入到 $12$ 位小数。\n\n该过程被系统地应用于每个测试用例，并将结果列表汇总成一个列表的列表作为输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    Constructs the differentiation matrix, computes its eigenvalues,\n    and formats the imaginary parts as required.\n    \"\"\"\n\n    def construct_differentiation_matrix(N, L):\n        \"\"\"\n        Constructs the N x N differentiation matrix D for a domain of length L.\n\n        Args:\n            N (int): The number of grid points.\n            L (float): The length of the periodic domain.\n\n        Returns:\n            numpy.ndarray: The N x N matrix D.\n        \"\"\"\n        if N = 2:\n            # For N=2, j+1 and j-1 are the same point modulo 2, so D is the zero matrix.\n            # This also handles trivial cases N=0, 1.\n            return np.zeros((N, N))\n\n        h = L / N\n        c = 1.0 / (2.0 * h)\n        \n        # Diagonal for u_{j+1} term\n        diag_p1 = c * np.ones(N - 1)\n        # Diagonal for u_{j-1} term\n        diag_m1 = -c * np.ones(N - 1)\n        \n        D = np.diag(diag_p1, k=1) + np.diag(diag_m1, k=-1)\n        \n        # Add corner elements for periodic boundary conditions\n        D[0, N - 1] = -c  # u_{-1} term for j=0 is u_{N-1}\n        D[N - 1, 0] = c   # u_{N} term for j=N-1 is u_{0}\n        \n        return D\n\n    def solve_case(params):\n        \"\"\"\n        Computes the imaginary parts of the eigenvalues for a single test case.\n\n        Args:\n            params (tuple): A tuple (N, L) defining the test case.\n\n        Returns:\n            list: A sorted list of the imaginary parts of the eigenvalues,\n                  rounded to 12 decimal places.\n        \"\"\"\n        N, L = params\n        D_matrix = construct_differentiation_matrix(N, L)\n        \n        # Compute eigenvalues\n        eigenvalues = np.linalg.eigvals(D_matrix)\n        \n        # Extract imaginary parts. Due to the matrix being real and skew-symmetric,\n        # eigenvalues are purely imaginary. Numerical computation might yield\n        # negligible real parts, which are discarded.\n        imag_parts = np.imag(eigenvalues)\n        \n        # Sort in nondecreasing order\n        sorted_imag_parts = np.sort(imag_parts)\n        \n        # Round to 12 decimal places\n        rounded_parts = np.round(sorted_imag_parts, 12)\n        \n        return rounded_parts.tolist()\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 1.0),\n        (3, 2 * np.pi),\n        (5, 1.0),\n        (8, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    def format_list_no_spaces(lst):\n        \"\"\"Formats a list into a string like '[item1,item2]' without spaces.\"\"\"\n        return '[' + ','.join(map(str, lst)) + ']'\n\n    # Final print statement in the exact required format.\n    # The output format must be a list of lists with no spaces, e.g., [[1,2],[3,4]].\n    # The default str(list) adds spaces, so we build the string manually.\n    results_as_strings = [format_list_no_spaces(res) for res in results]\n    final_output_string = '[' + ','.join(results_as_strings) + ']'\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将这些概念应用于计算物理和工程中的一个实际问题：计算三维向量场的散度。这项实践综合了之前所学的知识，要求你为区域内部和边界点实施不同的差分格式 ()。这不仅能巩固你对差分格式的理解，还能让你体会到在真实多维问题中正确处理边界条件的必要性。",
            "id": "2418896",
            "problem": "给定一个三维均匀笛卡尔网格，其节点索引为 $\\{i,j,k\\}$，其中 $i \\in \\{0,1,\\dots,N_x-1\\}$，$j \\in \\{0,1,\\dots,N_y-1\\}$，$k \\in \\{0,1,\\dots,N_z-1\\}$。节点 $(i,j,k)$ 的物理坐标由 $x_i = x_{\\min} + i\\,\\Delta x$、$y_j = y_{\\min} + j\\,\\Delta y$、$z_k = z_{\\min} + k\\,\\Delta z$ 定义，其均匀间距为 $\\Delta x = \\dfrac{x_{\\max}-x_{\\min}}{N_x-1}$、$\\Delta y = \\dfrac{y_{\\max}-y_{\\min}}{N_y-1}$ 和 $\\Delta z = \\dfrac{z_{\\max}-z_{\\min}}{N_z-1}$。在每个网格节点上，通过解析表达式给定一个分量为 $\\mathbf{F} = (P,Q,R)$ 的矢量场 $\\mathbf{F}(x,y,z)$。如果出现三角函数，其参数必须解释为以弧度为单位的角度。\n\n节点 $(i,j,k)$ 处的离散散度定义为分别应用于分量 $P,Q,R$ 的三个离散一阶偏导数之和。在节点 $(i,j,k)$ 处，$x$ 方向上的离散一阶偏导数定义如下：\n- 对于 $x$ 方向的内部节点，即 $1 \\le i \\le N_x - 2$：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} \\approx \\frac{P_{i+1,j,k} - P_{i-1,j,k}}{2\\,\\Delta x}.$$\n- 对于 $x$ 方向的左边界，即 $i = 0$：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{0,j,k} \\approx \\frac{-3\\,P_{0,j,k} + 4\\,P_{1,j,k} - P_{2,j,k}}{2\\,\\Delta x}.$$\n- 对于 $x$ 方向的右边界，即 $i = N_x - 1$：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{N_x-1,j,k} \\approx \\frac{3\\,P_{N_x-1,j,k} - 4\\,P_{N_x-2,j,k} + P_{N_x-3,j,k}}{2\\,\\Delta x}.$$\n\n必须对 $y$ 方向上的 $Q$（使用 $\\Delta y$）和 $z$ 方向上的 $R$（使用 $\\Delta z$）使用类似的公式。节点 $(i,j,k)$ 处的离散散度是这三个近似值的和：\n$$\\left.\\nabla \\cdot \\mathbf{F}\\right|_{i,j,k} \\approx \\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} + \\left.\\frac{\\partial Q}{\\partial y}\\right|_{i,j,k} + \\left.\\frac{\\partial R}{\\partial z}\\right|_{i,j,k}.$$\n\n使用上述定义计算以下每个测试用例的离散散度。对于每个用例，构建网格，在所有节点上计算场分量，计算离散散度场，并提取指定节点处的值。您的程序必须将四个结果作为一个列表输出，每个值四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n- 用例 1：\n  - 域：$x \\in [-1,1]$，$y \\in [-1,1]$，$z \\in [-1,1]$。\n  - 网格尺寸：$N_x = 3$，$N_y = 4$，$N_z = 3$。\n  - 场：$P(x,y,z) = 2\\,x$，$Q(x,y,z) = -3\\,y$，$R(x,y,z) = 4\\,z$。\n  - 报告的节点索引：$(i,j,k) = (0,0,0)$。\n- 用例 2：\n  - 域：$x \\in [0,1]$，$y \\in [0,1]$，$z \\in [0,1]$。\n  - 网格尺寸：$N_x = 5$，$N_y = 5$，$N_z = 5$。\n  - 场：$P(x,y,z) = x^2$，$Q(x,y,z) = y^2$，$R(x,y,z) = z^2$。\n  - 报告的节点索引：$(i,j,k) = (2,2,3)$。\n- 用例 3：\n  - 域：$x \\in [0,\\pi]$，$y \\in \\left[0,\\frac{\\pi}{2}\\right]$，$z \\in [0,1]$。\n  - 网格尺寸：$N_x = 8$，$N_y = 7$，$N_z = 6$。\n  - 场：$P(x,y,z) = \\sin(x)$，$Q(x,y,z) = \\cos(y)$，$R(x,y,z) = e^{z}$。\n  - 报告的节点索引：$(i,j,k) = (4,3,2)$。\n- 用例 4：\n  - 域：$x \\in \\left[-\\frac{1}{2},\\frac{1}{2}\\right]$，$y \\in [0,1]$，$z \\in [-1,1]$。\n  - 网格尺寸：$N_x = 4$，$N_y = 3$，$N_z = 5$。\n  - 场：$P(x,y,z) = e^{x}$，$Q(x,y,z) = y^3$，$R(x,y,z) = z$。\n  - 报告的节点索引：$(i,j,k) = (3,0,4)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4]$）。\n- 每个 $r_m$ 必须是小数点后恰好保留 $6$ 位的十进制数。\n- 不应打印任何额外文本。",
            "solution": "所提出的问题要求在三维均匀笛卡尔网格上计算矢量场 $\\mathbf{F}(x,y,z) = (P, Q, R)$ 的离散散度。该问题定义明确、科学上合理且完整。所有必要组成部分，包括网格结构、矢量场的解析表达式以及用于近似偏导数的特定有限差分公式，均已提供。该问题是计算工程和应用数学中的一个标准练习，特别是在微分算子数值离散化领域。因此，该问题是有效的，并允许直接、明确的求解。\n\n问题的核心是计算散度，其定义为 $\\nabla \\cdot \\mathbf{F} = \\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}$。我们需要在网格上的指定节点 $(i,j,k)$ 处，用一个离散等价物来近似这个连续算子。任何节点 $(i,j,k)$ 的物理坐标由以下公式给出：\n$$x_i = x_{\\min} + i\\,\\Delta x, \\quad \\text{for } i \\in \\{0, 1, \\dots, N_x-1\\}$$\n$$y_j = y_{\\min} + j\\,\\Delta y, \\quad \\text{for } j \\in \\{0, 1, \\dots, N_y-1\\}$$\n$$z_k = z_{\\min} + k\\,\\Delta z, \\quad \\text{for } k \\in \\{0, 1, \\dots, N_z-1\\}$$\n其中网格间距是均匀的：\n$$\\Delta x = \\frac{x_{\\max}-x_{\\min}}{N_x-1}, \\quad \\Delta y = \\frac{y_{\\max}-y_{\\min}}{N_y-1}, \\quad \\Delta z = \\frac{z_{\\max}-z_{\\min}}{N_z-1}$$\n\n分量 $P$ 关于 $x$ 的离散偏导数由二阶精度的有限差分公式给出，具体公式取决于节点索引 $i$ 的位置：\n对于内部节点，$1 \\le i \\le N_x-2$，使用中心差分公式：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} \\approx \\frac{P(x_{i+1}, y_j, z_k) - P(x_{i-1}, y_j, z_k)}{2\\,\\Delta x}$$\n对于左边界节点，$i=0$，使用前向差分公式：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{0,j,k} \\approx \\frac{-3\\,P(x_0, y_j, z_k) + 4\\,P(x_1, y_j, z_k) - P(x_2, y_j, z_k)}{2\\,\\Delta x}$$\n对于右边界节点，$i = N_x-1$，使用后向差分公式：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{N_x-1,j,k} \\approx \\frac{3\\,P(x_{N_x-1}, y_j, z_k) - 4\\,P(x_{N_x-2}, y_j, z_k) + P(x_{N_x-3}, y_j, z_k)}{2\\,\\Delta x}$$\n\n对于 $Q$ 关于 $y$ 的偏导数（使用索引 $j$、间距 $\\Delta y$ 和网格尺寸 $N_y$）以及 $R$ 关于 $z$ 的偏导数（使用索引 $k$、间距 $\\Delta z$ 和网格尺寸 $N_z$），应用相同的模板结构。节点 $(i,j,k)$ 处的离散散度是这三个数值近似值的和：\n$$\\left.\\nabla \\cdot \\mathbf{F}\\right|_{i,j,k} \\approx \\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} + \\left.\\frac{\\partial Q}{\\partial y}\\right|_{i,j,k} + \\left.\\frac{\\partial R}{\\partial z}\\right|_{i,j,k}$$\n\n求解过程是为提供的四个测试用例中的每一个系统地实现此计算。对于每个用例，我们首先建立网格参数（$x_{\\min}$、$x_{\\max}$、$N_x$ 等）。然后，我们确定网格间距（$\\Delta x$、$\\Delta y$、$\\Delta z$）和每个轴的物理坐标集。对于指定的节点索引 $(i,j,k)$，我们确定其在每个维度上的位置是在边界上还是在内部。基于此，我们选择合适的有限差分公式。然后，我们在必要的相邻网格点上计算场分量 $P$、$Q$ 和 $R$，计算每个偏导数近似值，并将结果相加得到最终的离散散度。对所有四个测试用例重复此过程以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discrete divergence of a vector field on a 3D Cartesian grid\n    for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            \"domain\": {'x': (-1, 1), 'y': (-1, 1), 'z': (-1, 1)},\n            \"grid_sizes\": {'Nx': 3, 'Ny': 4, 'Nz': 3},\n            \"field\": {\n                'P': lambda x, y, z: 2 * x,\n                'Q': lambda x, y, z: -3 * y,\n                'R': lambda x, y, z: 4 * z\n            },\n            \"node_index\": (0, 0, 0)\n        },\n        # Case 2\n        {\n            \"domain\": {'x': (0, 1), 'y': (0, 1), 'z': (0, 1)},\n            \"grid_sizes\": {'Nx': 5, 'Ny': 5, 'Nz': 5},\n            \"field\": {\n                'P': lambda x, y, z: x**2,\n                'Q': lambda x, y, z: y**2,\n                'R': lambda x, y, z: z**2\n            },\n            \"node_index\": (2, 2, 3)\n        },\n        # Case 3\n        {\n            \"domain\": {'x': (0, np.pi), 'y': (0, np.pi / 2), 'z': (0, 1)},\n            \"grid_sizes\": {'Nx': 8, 'Ny': 7, 'Nz': 6},\n            \"field\": {\n                'P': lambda x, y, z: np.sin(x),\n                'Q': lambda x, y, z: np.cos(y),\n                'R': lambda x, y, z: np.exp(z)\n            },\n            \"node_index\": (4, 3, 2)\n        },\n        # Case 4\n        {\n            \"domain\": {'x': (-0.5, 0.5), 'y': (0, 1), 'z': (-1, 1)},\n            \"grid_sizes\": {'Nx': 4, 'Ny': 3, 'Nz': 5},\n            \"field\": {\n                'P': lambda x, y, z: np.exp(x),\n                'Q': lambda x, y, z: y**3,\n                'R': lambda x, y, z: z\n            },\n            \"node_index\": (3, 0, 4)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        x_min, x_max = case[\"domain\"]['x']\n        y_min, y_max = case[\"domain\"]['y']\n        z_min, z_max = case[\"domain\"]['z']\n        \n        Nx = case[\"grid_sizes\"]['Nx']\n        Ny = case[\"grid_sizes\"]['Ny']\n        Nz = case[\"grid_sizes\"]['Nz']\n\n        P = case[\"field\"]['P']\n        Q = case[\"field\"]['Q']\n        R = case[\"field\"]['R']\n        \n        i, j, k = case[\"node_index\"]\n\n        # Calculate grid spacings\n        # Handle division by zero for single-point dimensions (N=1)\n        delta_x = (x_max - x_min) / (Nx - 1) if Nx > 1 else 0\n        delta_y = (y_max - y_min) / (Ny - 1) if Ny > 1 else 0\n        delta_z = (z_max - z_min) / (Nz - 1) if Nz > 1 else 0\n\n        # Generate coordinate arrays\n        x_coords = np.linspace(x_min, x_max, Nx)\n        y_coords = np.linspace(y_min, y_max, Ny)\n        z_coords = np.linspace(z_min, z_max, Nz)\n        \n        x_target, y_target, z_target = x_coords[i], y_coords[j], z_coords[k]\n\n        # --- Calculate dP/dx ---\n        if Nx  3:\n            # Not enough points for the specified stencils. Problem implies N>=3.\n            # However, for robustness, we can assume derivative is 0 if not computable.\n            dP_dx = 0.0\n        elif i == 0: # Forward difference at left boundary\n            p0 = P(x_coords[0], y_target, z_target)\n            p1 = P(x_coords[1], y_target, z_target)\n            p2 = P(x_coords[2], y_target, z_target)\n            dP_dx = (-3 * p0 + 4 * p1 - p2) / (2 * delta_x)\n        elif i == Nx - 1: # Backward difference at right boundary\n            p0 = P(x_coords[Nx-1], y_target, z_target)\n            p1 = P(x_coords[Nx-2], y_target, z_target)\n            p2 = P(x_coords[Nx-3], y_target, z_target)\n            dP_dx = (3 * p0 - 4 * p1 + p2) / (2 * delta_x)\n        else: # Central difference for interior\n            p_minus = P(x_coords[i-1], y_target, z_target)\n            p_plus = P(x_coords[i+1], y_target, z_target)\n            dP_dx = (p_plus - p_minus) / (2 * delta_x)\n\n        # --- Calculate dQ/dy ---\n        if Ny  3:\n            dQ_dy = 0.0\n        elif j == 0: # Forward difference at 'left' boundary\n            q0 = Q(x_target, y_coords[0], z_target)\n            q1 = Q(x_target, y_coords[1], z_target)\n            q2 = Q(x_target, y_coords[2], z_target)\n            dQ_dy = (-3 * q0 + 4 * q1 - q2) / (2 * delta_y)\n        elif j == Ny - 1: # Backward difference at 'right' boundary\n            q0 = Q(x_target, y_coords[Ny-1], z_target)\n            q1 = Q(x_target, y_coords[Ny-2], z_target)\n            q2 = Q(x_target, y_coords[Ny-3], z_target)\n            dQ_dy = (3 * q0 - 4 * q1 + q2) / (2 * delta_y)\n        else: # Central difference for interior\n            q_minus = Q(x_target, y_coords[j-1], z_target)\n            q_plus = Q(x_target, y_coords[j+1], z_target)\n            dQ_dy = (q_plus - q_minus) / (2 * delta_y)\n\n        # --- Calculate dR/dz ---\n        if Nz  3:\n            dR_dz = 0.0\n        elif k == 0: # Forward difference at 'left' boundary\n            r0 = R(x_target, y_target, z_coords[0])\n            r1 = R(x_target, y_target, z_coords[1])\n            r2 = R(x_target, y_target, z_coords[2])\n            dR_dz = (-3 * r0 + 4 * r1 - r2) / (2 * delta_z)\n        elif k == Nz - 1: # Backward difference at 'right' boundary\n            r0 = R(x_target, y_target, z_coords[Nz-1])\n            r1 = R(x_target, y_target, z_coords[Nz-2])\n            r2 = R(x_target, y_target, z_coords[Nz-3])\n            dR_dz = (3 * r0 - 4 * r1 + r2) / (2 * delta_z)\n        else: # Central difference for interior\n            r_minus = R(x_target, y_target, z_coords[k-1])\n            r_plus = R(x_target, y_target, z_coords[k+1])\n            dR_dz = (r_plus - r_minus) / (2 * delta_z)\n            \n        divergence = dP_dx + dQ_dy + dR_dz\n        results.append(divergence)\n\n    # Format the final output string\n    # The requirement is to round to 6 decimal places.\n    # The f-string format specifier f'{x:.6f}' does this.\n    output_str = \"[\" + \",\".join(f\"{res:.6f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}