{
    "hands_on_practices": [
        {
            "introduction": "在数值分析领域，解决同一个问题通常存在多种方法。本练习将指导你如何使用相对误差作为关键指标，来具体、定量地比较两种不同迭代算法的性能 。通过这种方式，你将学会如何判断哪种算法在初始阶段收敛得更快，从而做出更明智的算法选择。",
            "id": "2152054",
            "problem": "在计算科学领域，不同的数值算法通常根据其收敛速度和准确性进行比较。考虑两种迭代算法，算法 A 和算法 B，它们被设计用来近似计算 $\\sqrt{3}$ 的值。\n\n算法 A 使用由以下递推关系定义的序列：\n$$x_{n+1} = \\frac{1}{2} \\left( x_n + \\frac{3}{x_n} \\right)$$\n\n算法 B 使用一个更复杂的序列，定义如下：\n$$y_{n+1} = \\frac{y_n(y_n^2 + 9)}{3y_n^2 + 3}$$\n\n两种算法都从相同的初始猜测值 $x_0 = y_0 = 1$ 开始。每种算法的第一次迭代，$x_1$ 和 $y_1$，为 $\\sqrt{3}$ 提供了一个新的近似值。\n\n令 $E_{R,A}$ 表示近似值 $x_1$ 相对于真值 $\\sqrt{3}$ 的相对误差。相对误差定义为近似值与真值之差的绝对值，除以真值的绝对值。类似地，令 $E_{R,B}$ 为近似值 $y_1$ 的相对误差。\n\n计算比率 $\\frac{E_{R,A}}{E_{R,B}}$ 的精确值。您的答案应该是一个封闭形式的解析表达式。",
            "solution": "我们已知两个迭代算法，初始值为 $x_{0}=y_{0}=1$，递推关系为\n$$\nx_{n+1}=\\frac{1}{2}\\left(x_{n}+\\frac{3}{x_{n}}\\right),\\qquad\ny_{n+1}=\\frac{y_{n}(y_{n}^{2}+9)}{3y_{n}^{2}+3}.\n$$\n计算第一次迭代的值：\n$$\nx_{1}=\\frac{1}{2}\\left(1+\\frac{3}{1}\\right)=\\frac{1}{2}\\cdot 4=2,\\qquad\ny_{1}=\\frac{1\\cdot(1^{2}+9)}{3\\cdot 1^{2}+3}=\\frac{10}{6}=\\frac{5}{3}.\n$$\n相对误差为，其中真值为 $t=\\sqrt{3}$，\n$$\nE_{R,A}=\\frac{|x_{1}-t|}{|t|}=\\frac{|2-\\sqrt{3}|}{\\sqrt{3}}=\\frac{2-\\sqrt{3}}{\\sqrt{3}},\n$$\n因为 $2 > \\sqrt{3}$，以及\n$$\nE_{R,B}=\\frac{|y_{1}-t|}{|t|}=\\frac{\\left|\\frac{5}{3}-\\sqrt{3}\\right|}{\\sqrt{3}}=\\frac{\\sqrt{3}-\\frac{5}{3}}{\\sqrt{3}},\n$$\n因为 $5/3  \\sqrt{3}$。因此，通过消去公分母 $\\sqrt{3}$，该比率简化为：\n$$\n\\frac{E_{R,A}}{E_{R,B}}=\\frac{2-\\sqrt{3}}{\\sqrt{3}-\\frac{5}{3}}.\n$$\n分子和分母同乘以 $2+\\sqrt{3}$，利用 $(2-\\sqrt{3})(2+\\sqrt{3})=4-3=1$：\n$$\n\\frac{E_{R,A}}{E_{R,B}}=\\frac{1}{\\left(\\sqrt{3}-\\frac{5}{3}\\right)(2+\\sqrt{3})}.\n$$\n使用 $\\left(\\sqrt{3}\\right)^{2}=3$ 展开分母：\n$$\n\\left(\\sqrt{3}-\\frac{5}{3}\\right)(2+\\sqrt{3})=2\\sqrt{3}+3-\\frac{10}{3}-\\frac{5}{3}\\sqrt{3}\n=\\left(3-\\frac{10}{3}\\right)+\\left(2-\\frac{5}{3}\\right)\\sqrt{3}\n=\\frac{-1}{3}+\\frac{1}{3}\\sqrt{3}=\\frac{1}{3}\\left(\\sqrt{3}-1\\right).\n$$\n因此\n$$\n\\frac{E_{R,A}}{E_{R,B}}=\\frac{1}{\\frac{1}{3}\\left(\\sqrt{3}-1\\right)}=\\frac{3}{\\sqrt{3}-1}\n=\\frac{3\\left(\\sqrt{3}+1\\right)}{(\\sqrt{3}-1)(\\sqrt{3}+1)}=\\frac{3\\left(\\sqrt{3}+1\\right)}{2}\n=\\frac{3}{2}\\left(\\sqrt{3}+1\\right).\n$$",
            "answer": "$$\\boxed{\\frac{3}{2}\\left(\\sqrt{3}+1\\right)}$$"
        },
        {
            "introduction": "在理论上完全等价的数学公式，在计算机上进行有限精度运算时其表现可能大相径庭。本练习将引导你探究一个“灾难性抵消”的经典案例，即两个几乎相等的数相减导致有效数字严重损失，从而产生巨大的相对误差 。通过这个实践，你不仅需要识别问题所在，还需通过代数变换找到一个数值稳定的计算形式，这是计算工程中一项至关重要的技能。",
            "id": "2370387",
            "problem": "设一个实值函数对以弧度为单位的实数输入定义为表达式 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$（当 $x \\neq 0$ 时），并由极限值定义 $f(0) = \\dfrac{1}{2}$。在有限精度算术中，当 $x$ 接近 $0$ 时，直接使用表达式 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$ 计算 $f(x)$ 会在分子中引发灾难性抵消，并导致整个结果产生巨大的相对误差。你的任务是量化此效应，并与一个在代数上等价但在 $x = 0$ 附近数值稳定的公式进行比较。\n\n要求：\n1) 将一个近似值 $a$ 相对于参考值 $t \\neq 0$ 的相对误差定义为 $\\left|\\dfrac{a - t}{t}\\right|$。\n\n2) 对于集合 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-8},\\; 10^{-1},\\; 1 \\,\\}$ 中的每个测试值（单位均为弧度），计算：\n- 当 $x \\neq 0$ 时，通过将 $x$ 代入 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$ 得到的朴素计算值 $a_{\\mathrm{naive}}(x)$。对于 $x = 0$，该直接表达式无定义；在这种情况下，为本问题之目的，根据定义将朴素方法的相对误差视为 $+\\infty$。\n- 一个数值稳定的计算值 $a_{\\mathrm{stable}}(x)$，它基于一个在 $x \\neq 0$ 时与 $f(x)$ 完全相等并在 $x=0$ 处允许值为 $\\dfrac{1}{2}$ 的连续扩展的代数重构。\n- 一个用于 $f(x)$ 的高精度参考值 $t(x)$，由绝对收敛级数\n$$\nt(x) \\;=\\; \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2m+2)!},\n$$\n定义，并理解为该级数在 $x=0$ 处的值为 $t(0) = \\dfrac{1}{2}$。\n\n3) 对于每个 $x \\in S$，计算两个相对误差\n$$\nE_{\\mathrm{naive}}(x) = \\left|\\dfrac{a_{\\mathrm{naive}}(x) - t(x)}{t(x)}\\right|, \\qquad\nE_{\\mathrm{stable}}(x) = \\left|\\dfrac{a_{\\mathrm{stable}}(x) - t(x)}{t(x)}\\right|.\n$$\n对于 $x = 0$，根据此任务的定义，设置 $E_{\\mathrm{naive}}(0) = +\\infty$。所有量均为无量纲量，所有角度均以弧度为单位。\n\n测试套件与最终输出规范：\n- 严格按照顺序使用测试输入 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-8},\\; 10^{-1},\\; 1 \\,\\}$。\n- 你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个条目对应一个测试输入 $x \\in S$，并且其本身就是与 $S$ 中顺序相同的双元素列表 $[E_{\\mathrm{naive}}(x), E_{\\mathrm{stable}}(x)]$。例如，整体结构必须为\n$[[E_{\\mathrm{naive}}(0),E_{\\mathrm{stable}}(0)],[E_{\\mathrm{naive}}(10^{-16}),E_{\\mathrm{stable}}(10^{-16})],\\ldots,[E_{\\mathrm{naive}}(1),E_{\\mathrm{stable}}(1)]]$ 的形式。\n所有报告的值必须是实数浮点数；$E_{\\mathrm{naive}}(0)$ 的值允许为 $+\\infty$。",
            "solution": "所述问题是有效的。这是一个适定、有科学依据且无歧义的计算工程问题，专门处理有限精度算术中的灾难性抵消现象。所有定义和参数都已提供，且无矛盾之处。因此，我们将着手提供一个完整的解决方案。\n\n任务是分析当 $x$ 趋近于零时，计算函数 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$ 的数值误差。该函数在 $x=0$ 处的真值由极限给出：$f(0) = \\lim_{x \\to 0} \\dfrac{1 - \\cos(x)}{x^{2}} = \\dfrac{1}{2}$。\n\n首先，我们讨论计算 $f(x)$ 所需的三种方法。\n\n**1. 高精度参考值, $t(x)$**\n\n参考值 $t(x)$ 由无穷级数定义：\n$$\nt(x) = \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2m+2)!}\n$$\n这是 $f(x)$ 的麦克劳林级数。其正确性可以通过从 $\\cos(x)$ 的级数开始验证：\n$$\n\\cos(x) = \\sum_{k=0}^{\\infty} (-1)^{k} \\dfrac{x^{2k}}{(2k)!} = 1 - \\dfrac{x^2}{2!} + \\dfrac{x^4}{4!} - \\dfrac{x^6}{6!} + \\dots\n$$\n由此，我们推导出分子 $1 - \\cos(x)$ 的级数：\n$$\n1 - \\cos(x) = 1 - \\left(1 - \\dfrac{x^2}{2!} + \\dfrac{x^4}{4!} - \\dots\\right) = \\dfrac{x^2}{2!} - \\dfrac{x^4}{4!} + \\dfrac{x^6}{6!} - \\dots = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\dfrac{x^{2k}}{(2k)!}\n$$\n除以 $x^2$ 得到 $f(x)$ 的级数：\n$$\nf(x) = \\dfrac{1 - \\cos(x)}{x^2} = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\dfrac{x^{2k-2}}{(2k)!}\n$$\n通过替换下标 $m = k-1$，我们得到给定的 $t(x)$ 表达式：\n$$\nt(x) = \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2(m+1))!} = \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2m+2)!}\n$$\n为计算目的，这个绝对收敛级数将被截断。求和将迭代进行，不断添加项，直到新项的量级小到在标准双精度浮点算术中无法改变累加和为止。这确保了参考值达到机器所允许的最高精度。各项的计算将以递归方式进行以保持数值稳定性：如果 $c_m$ 是第 $m$ 项，则 $c_m = c_{m-1} \\cdot \\left( \\dfrac{-x^2}{(2m+1)(2m+2)} \\right)$。\n\n**2. 朴素计算, $a_{\\mathrm{naive}}(x)$**\n\n朴素计算使用直接表达式 $a_{\\mathrm{naive}}(x) = \\dfrac{1 - \\cos(x)}{x^2}$。当 $x$ 接近 $0$ 时，$\\cos(x)$ 非常接近 $1$。在有限精度算术中，减法 $1 - \\cos(x)$ 将会损失大量的相对精度。这是一个灾难性抵消的经典案例。例如，如果 $x$ 足够小（例如，$x  10^{-8}$），在双精度下计算的 $\\cos(x)$ 可能与 $1$ 无法区分，导致分子计算结果恰好为 $0$，从而得出严重不正确的结果和巨大的相对误差。对于 $x=0$，该表达式无定义，且规定相对误差 $E_{\\mathrm{naive}}(0)$ 为 $+\\infty$。\n\n**3. 数值稳定计算, $a_{\\mathrm{stable}}(x)$**\n\n为避免灾难性抵消，我们必须对表达式进行代数重构。我们使用半角三角恒等式 $1 - \\cos(x) = 2 \\sin^2(x/2)$。将其代入 $f(x)$ 的表达式，得到：\n$$\nf(x) = \\dfrac{2 \\sin^2(x/2)}{x^2}\n$$\n这种形式可以重写以突显其在 $x=0$ 附近的良好性质：\n$$\nf(x) = 2 \\left( \\dfrac{\\sin(x/2)}{x} \\right)^2 = \\dfrac{2}{4} \\left( \\dfrac{\\sin(x/2)}{x/2} \\right)^2 = \\dfrac{1}{2} \\left( \\dfrac{\\sin(x/2)}{x/2} \\right)^2\n$$\n这就是我们的稳定公式 $a_{\\mathrm{stable}}(x)$。当 $x \\to 0$ 时，其参数 $u=x/2$ 也趋近于 $0$。子表达式 $\\sin(u)/u$ 在计算上是稳定的，并能精确地趋近其极限值 $1$。因此，不会发生两个相近数的减法，从而实现了数值稳定性。对于 $x=0$，此公式被连续扩展至其极限值 $a_{\\mathrm{stable}}(0) = 1/2$。\n\n**计算过程与误差计算**\n\n对于集合 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-8},\\; 10^{-1},\\; 1 \\,\\}$ 中的每个测试值 $x$，我们将执行以下步骤：\n1.  使用收敛级数法计算参考值 $t(x)$。对于 $x=0$，$t(0)=1/2$。\n2.  使用各自的公式计算 $a_{\\mathrm{naive}}(x)$ 和 $a_{\\mathrm{stable}}(x)$。对于 $x=0$，$a_{\\mathrm{stable}}(0)=1/2$，而 $a_{\\mathrm{naive}}(0)$ 无定义。\n3.  按定义计算相对误差：\n    $$\n    E_{\\mathrm{naive}}(x) = \\left|\\dfrac{a_{\\mathrm{naive}}(x) - t(x)}{t(x)}\\right| \\quad \\text{和} \\quad E_{\\mathrm{stable}}(x) = \\left|\\dfrac{a_{\\mathrm{stable}}(x) - t(x)}{t(x)}\\right|\n    $$\n    根据定义，对于 $x=0$，我们将设置 $E_{\\mathrm{naive}}(0) = +\\infty$ 并计算 $E_{\\mathrm{stable}}(0) = \\left|\\dfrac{1/2 - 1/2}{1/2}\\right| = 0$。\n\n最终输出将是一个列表，其中包含测试集 $S$ 中每个 $x$ 对应的 $[E_{\\mathrm{naive}}(x), E_{\\mathrm{stable}}(x)]$ 对，并按指定顺序排列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef high_accuracy_f(x: float) - float:\n    \"\"\"\n    Computes the reference value t(x) using its Maclaurin series expansion,\n    t(x) = sum_{m=0 to inf} (-1)^m * x^(2m) / (2m+2)!.\n    The sum is computed until the terms become negligible in double precision.\n    \"\"\"\n    if x == 0.0:\n        return 0.5\n\n    # Start with the m=0 term: (-1)^0 * x^0 / 2! = 1/2\n    term = 0.5\n    current_sum = term\n    x_sq = x * x\n\n    # Iterate for m = 1, 2, 3, ...\n    # The ratio term_m / term_{m-1} is -x^2 / ((2m+1)*(2m+2))\n    for m in range(1, 100): # 100 is a safe upper limit for convergence\n        term *= -x_sq / ((2 * m + 1) * (2 * m + 2))\n        \n        # Check if the term is too small to affect the sum in float64 precision.\n        if current_sum + term == current_sum:\n            break\n        \n        current_sum += term\n        \n    return current_sum\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating naive and stable relative errors for a set of test inputs.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.0, 1e-16, 1e-12, 1e-8, 1e-1, 1.0]\n\n    results = []\n    for x in test_cases:\n        # Special handling for x = 0 as per the problem definition.\n        if x == 0.0:\n            e_naive = np.inf\n            # a_stable(0) = 1/2, t(0) = 1/2, so the error is zero.\n            e_stable = 0.0\n            results.append([e_naive, e_stable])\n            continue\n\n        # 1. Compute the high-accuracy reference value t(x).\n        t_x = high_accuracy_f(x)\n\n        # 2. Compute the naive evaluation a_naive(x).\n        # This is subject to catastrophic cancellation for small x.\n        a_naive = (1.0 - np.cos(x)) / (x * x)\n\n        # 3. Compute the numerically stable evaluation a_stable(x).\n        # Using the formulation: 0.5 * (sin(x/2) / (x/2))^2\n        u = x / 2.0\n        # The ratio sin(u)/u is evaluated accurately by numpy for small u.\n        a_stable = 0.5 * (np.sin(u) / u)**2\n\n        # 4. Compute the relative errors.\n        # The reference t(x) will not be zero for the given test cases.\n        e_naive = np.abs((a_naive - t_x) / t_x)\n        e_stable = np.abs((a_stable - t_x) / t_x)\n        \n        results.append([e_naive, e_stable])\n\n    # Final print statement in the exact required format.\n    # The format is [[val1_0,val2_0],[val1_1,val2_1],...] with no spaces.\n    formatted_results = ','.join([f'[{e_n},{e_s}]' for e_n, e_s in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "当一个数值算法报告成功时，通常意味着函数值（即“残差”）已非常接近于零。但这是否必然保证我们得到的近似解也同样接近真实解呢？本练习通过一个精心设计的“病态”问题  揭示了一个深刻的道理：一个极小的残差背后，可能隐藏着一个相对较大的解误差。这个实践将教会你在评估计算结果时，必须审慎区分残差大小和解的真实精度。",
            "id": "2370347",
            "problem": "在一个标量非线性方程 $f(x) = (x - 1)^{10} = 0$ 的求根计算中，真根为 $x^{\\dagger} = 1$。一个迭代求解器返回一个估计值 $x^{*}$，其测量残差大小为 $\\lvert f(x^{*}) \\rvert = 10^{-12}$。仅使用残差和绝对误差的定义，确定绝对误差的大小 $\\lvert x^{*} - x^{\\dagger} \\rvert$。将您的答案四舍五入到四位有效数字。将答案表示为纯数字（无单位）。",
            "solution": "对问题陈述进行验证。\n\n从问题陈述中提取的已知条件如下：\n1.  标量非线性方程为 $f(x) = (x - 1)^{10} = 0$。\n2.  真根为 $x^{\\dagger} = 1$。\n3.  从求解器得到的估计根记为 $x^{*}$。\n4.  测量残差的大小为 $\\lvert f(x^{*}) \\rvert = 10^{-12}$。\n5.  目标是求绝对误差的大小 $\\lvert x^{*} - x^{\\dagger} \\rvert$。\n6.  最终数值答案必须四舍五入到四位有效数字。\n\n经检验，该问题是有效的。其科学依据在于数值分析的原理，特别是求根算法中的误差分析。该问题是适定的，因为提供了计算唯一解所需的所有信息。所用术语精确且客观。所选函数 $f(x) = (x - 1)^{10}$ 是一个经典例子，用于说明高重根的病态概念，即一个非常小的残差并不保证一个小的误差。\n\n求解过程如下。\n\n绝对误差 $e_{abs}$ 的定义是近似值 $x^{*}$ 与真值 $x^{\\dagger}$ 之差的大小。\n$$e_{abs} = \\lvert x^{*} - x^{\\dagger} \\rvert$$\n已知真根为 $x^{\\dagger} = 1$，绝对误差为：\n$$e_{abs} = \\lvert x^{*} - 1 \\rvert$$\n\n残差是在近似根处计算的函数值 $f(x^{*})$。问题给出了该残差的大小：\n$$\\lvert f(x^{*}) \\rvert = 10^{-12}$$\n函数由 $f(x) = (x - 1)^{10}$ 给出。将 $x^{*}$ 代入函数得到：\n$$f(x^{*}) = (x^{*} - 1)^{10}$$\n因此，残差大小为：\n$$\\lvert (x^{*} - 1)^{10} \\rvert = 10^{-12}$$\n使用绝对值的性质 $\\lvert a^{n} \\rvert = \\lvert a \\rvert^{n}$（对于偶数整数指数 $n=10$），我们可以将表达式重写为：\n$$\\lvert x^{*} - 1 \\rvert^{10} = 10^{-12}$$\n我们认识到项 $\\lvert x^{*} - 1 \\rvert$ 正是绝对误差 $e_{abs}$。将此代入方程得到：\n$$(e_{abs})^{10} = 10^{-12}$$\n为了求解 $e_{abs}$，我们对等式两边取正10次根：\n$$e_{abs} = \\left( 10^{-12} \\right)^{\\frac{1}{10}}$$\n使用指数法则 $(a^{b})^{c} = a^{bc}$，我们简化表达式：\n$$e_{abs} = 10^{-12 \\times \\frac{1}{10}} = 10^{-\\frac{12}{10}} = 10^{-1.2}$$\n问题要求一个四舍五入到四位有效数字的数值答案。我们计算 $10^{-1.2}$ 的值：\n$$e_{abs} \\approx 0.0630957344...$$\n为了将其四舍五入到四位有效数字，我们确定前四位有效数字，它们是 $6$、$3$、$0$ 和 $9$。$9$ 后面的数字是 $5$，这要求对最后一位有效数字进行进位。因此，$0.06309$ 向上取整变为 $0.06310$。末尾的零是有效数字，必须包含以表示精度。\n\n因此，绝对误差的大小约为 $0.06310$。这个结果表明，对于高重根，一个非常小的残差（量级为 $10^{-12}$）可能对应一个相对较大的误差（量级为 $10^{-2}$），这是一个病态问题的标志。",
            "answer": "$$\\boxed{0.06310}$$"
        }
    ]
}