{
    "hands_on_practices": [
        {
            "introduction": "牛顿法以其二次收敛速度而闻名，但这依赖于根是单根的假设。本练习将探讨当此假设被违反时（例如对于一个重根）会发生什么。通过从第一性原理推导误差传播，您将更深入地理解收敛速度，并揭示决定算法性能的理论基础。",
            "id": "2378389",
            "problem": "在计算工程中，牛顿-拉夫逊法被广泛用于求解非线性方程。考虑将牛顿-拉夫逊迭代\n$$\nx_{k+1} \\;=\\; x_k \\;-\\; \\frac{p(x_k)}{p'(x_k)}\n$$\n应用于多项式\n$$\np(x) \\;=\\; (x-1)^{4}\\,(x+2),\n$$\n目标是找到位于 $x=1$ 的根。令 $e_k = x_k - 1$ 表示第 $k$ 次迭代的误差，并假设初始猜测值 $x_0$ 的选择足够接近 $x=1$，以至于序列 $\\{x_k\\}$ 收敛于 $1$。仅使用牛顿-拉夫逊迭代的定义、重根的定义以及关于光滑函数的一阶基本推理，确定由下式定义的渐近线性误差缩减因子 $r$：\n$$\nr \\;=\\; \\lim_{k\\to\\infty} \\frac{|e_{k+1}|}{|e_k|}.\n$$\n请以精确的有理数形式给出你的答案。不要计算任何具体的迭代值。",
            "solution": "对问题陈述进行验证。\n\n按原文摘录已知条件如下：\n1.  牛顿-拉夫逊迭代：$x_{k+1} = x_k - \\frac{p(x_k)}{p'(x_k)}$。\n2.  多项式函数：$p(x) = (x-1)^{4}\\,(x+2)$。\n3.  目标根：$x=1$。\n4.  误差定义：$e_k = x_k - 1$。\n5.  收敛性假设：从初始猜测值 $x_0$ 生成的序列 $\\{x_k\\}$ 收敛于 $1$。\n6.  目标：确定渐近线性误差缩减因子 $r = \\lim_{k\\to\\infty} \\frac{|e_{k+1}|}{|e_k|}$。\n7.  约束：推导过程必须仅使用牛顿-拉夫逊法的定义、重根的定义和一阶基本推理。\n8.  答案格式：精确的有理数。\n\n该问题具有科学依据，因为它涉及数值分析中标准的、公认的概念。问题提法得当，提供了确定唯一且有意义解所需的所有信息。语言客观而精确。问题有效。我们开始求解。\n\n该问题要求计算牛顿-拉夫逊法应用于具有重根的多项式时的渐近误差缩减因子。我们关心的根是 $x=1$。设第 $k$ 次迭代的误差定义为 $e_k = x_k - 1$。根据此定义，我们有 $x_k = 1 + e_k$。下一次迭代的误差 $e_{k+1}$ 由 $e_{k+1} = x_{k+1} - 1$ 给出。\n\n我们将牛顿-拉夫逊公式代入 $e_{k+1}$ 的表达式中：\n$$\ne_{k+1} = \\left(x_k - \\frac{p(x_k)}{p'(x_k)}\\right) - 1\n$$\n使用关系式 $x_k - 1 = e_k$，我们可以将其改写为：\n$$\ne_{k+1} = e_k - \\frac{p(x_k)}{p'(x_k)}\n$$\n为了分析当 $k \\to \\infty$ 时的渐近行为，我们必须考察当 $x_k \\to 1$（这意味着 $e_k \\to 0$）时此关系式的行为。我们通过代入 $x_k = 1 + e_k$，用误差 $e_k$ 来表示函数 $p(x_k)$ 及其导数 $p'(x_k)$。\n\n首先，我们计算多项式 $p(x) = (x-1)^{4}(x+2)$ 的导数。使用乘法法则求导，我们得到：\n$$\np'(x) = \\frac{d}{dx}\\left[(x-1)^{4}(x+2)\\right] = 4(x-1)^{3}(x+2) + (x-1)^{4}(1)\n$$\n提出公因式 $(x-1)^{3}$：\n$$\np'(x) = (x-1)^{3} \\left[ 4(x+2) + (x-1) \\right] = (x-1)^{3} (4x+8+x-1) = (x-1)^{3} (5x+7)\n$$\n现在，我们在 $x_k = 1 + e_k$ 处计算 $p(x_k)$ 和 $p'(x_k)$ 的值：\n$$\np(x_k) = p(1+e_k) = ((1+e_k)-1)^{4}((1+e_k)+2) = (e_k)^{4}(e_k+3)\n$$\n$$\np'(x_k) = p'(1+e_k) = ((1+e_k)-1)^{3}(5(1+e_k)+7) = (e_k)^{3}(5e_k+5+7) = (e_k)^{3}(5e_k+12)\n$$\n问题陈述指出了位于 $x=1$ 的根具有重数，这从因子 $(x-1)^4$ 中可以明显看出。对于 $p(x) = (x-1)^m g(x)$ 且 $g(1) \\neq 0$ 的情况，根的重数为 $m$。在这里，$m=4$ 且 $g(x) = x+2$，其中 $g(1)=3 \\neq 0$。\n\n现在，将这些表达式代回 $e_{k+1}$ 的方程中：\n$$\ne_{k+1} = e_k - \\frac{(e_k)^{4}(e_k+3)}{(e_k)^{3}(5e_k+12)}\n$$\n对于 $e_k \\neq 0$，我们可以化简这个分数：\n$$\ne_{k+1} = e_k - e_k \\frac{e_k+3}{5e_k+12}\n$$\n提出 $e_k$ 以分析误差缩减情况：\n$$\ne_{k+1} = e_k \\left( 1 - \\frac{e_k+3}{5e_k+12} \\right)\n$$\n为了合并括号内的项，我们通分：\n$$\ne_{k+1} = e_k \\left( \\frac{(5e_k+12) - (e_k+3)}{5e_k+12} \\right) = e_k \\left( \\frac{5e_k+12-e_k-3}{5e_k+12} \\right) = e_k \\left( \\frac{4e_k+9}{5e_k+12} \\right)\n$$\n渐近线性误差缩减因子 $r$ 定义为连续误差之比的极限：\n$$\nr = \\lim_{k\\to\\infty} \\frac{|e_{k+1}|}{|e_k|}\n$$\n使用我们推导出的 $e_{k+1}$ 的表达式：\n$$\n\\frac{e_{k+1}}{e_k} = \\frac{4e_k+9}{5e_k+12}\n$$\n序列 $\\{x_k\\}$ 收敛于 $1$ 的假设意味着 $\\lim_{k\\to\\infty} e_k = 0$。我们现在可以计算这个极限：\n$$\nr = \\lim_{k\\to\\infty} \\left| \\frac{e_{k+1}}{e_k} \\right| = \\lim_{e_k\\to 0} \\left| \\frac{4e_k+9}{5e_k+12} \\right| = \\left| \\frac{4(0)+9}{5(0)+12} \\right| = \\left| \\frac{9}{12} \\right| = \\frac{3}{4}\n$$\n这个结果与牛顿法处理重数为 $m$ 的根的一般理论是一致的，该理论预测线性收敛率为 $r = \\frac{m-1}{m}$。对于 $m=4$，这给出 $r = \\frac{4-1}{4} = \\frac{3}{4}$。我们从第一性原理出发的推导证实了该值。渐近误差缩减因子是一个精确的有理数。",
            "answer": "$$\n\\boxed{\\frac{3}{4}}\n$$"
        },
        {
            "introduction": "在求解大型线性系统时，我们常常使用迭代法，但一个关键问题是所选方法对特定系统是否收敛。本练习应用盖尔圆定理 (Gershgorin circle theorem) 这一强大的线性代数工具来分析雅可比 (Jacobi) 迭代法的稳定性，该稳定性由迭代矩阵的谱半径决定。通过这个练习，您将把抽象的矩阵理论与算法行为的实际预测联系起来，学会如何在实施前评估迭代方法的适用性。",
            "id": "2378407",
            "problem": "考虑线性系统 $A \\mathbf{x} = \\mathbf{b}$，其中\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1  -2  1 \\\\\n-3  1  -1 \\\\\n2  -1  1\n\\end{pmatrix}.\n$$\n假设对此系统应用雅可比迭代法，其迭代矩阵由 $A$ 的对角部分 $D$ 和严格非对角部分 $L+U$ 通过标准分裂 $A = D + L + U$ 定义，雅可比迭代矩阵为 $B_{J} = -D^{-1}(L+U)$。使用盖尔什戈林圆盘定理，确定从 $B_{J}$ 的盖尔什戈林行圆盘的并集中得到的谱半径 $\\rho(B_{J})$ 的最小一致上界 $R$。给出 $R$ 的精确值作为最终答案。不要四舍五入。在你的推理中，仅根据需要使用第一性原理和定义，并且完全基于这个基于盖尔什戈林定理的界限来预测雅可比方法的行为。最终报告的值必须是一个不带单位的实数。",
            "solution": "该问题要求使用盖尔什戈林圆盘定理确定雅可比迭代矩阵谱半径的一个上界。然后用这个界限来评估雅可比方法对给定线性系统的收敛性。\n\n线性系统为 $A \\mathbf{x} = \\mathbf{b}$，其中矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n1  -2  1 \\\\\n-3  1  -1 \\\\\n2  -1  1\n\\end{pmatrix}\n$$\n雅可比方法基于将矩阵 $A$ 分裂为其对角部分 $D$、严格下三角部分 $L$ 和严格上三角部分 $U$。\n$$\nA = D + L + U\n$$\n根据给定的矩阵 $A$，我们确定这些组成部分：\n$$\nD = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}, \\quad\nL = \\begin{pmatrix}\n0  0  0 \\\\\n-3  0  0 \\\\\n2  -1  0\n\\end{pmatrix}, \\quad\nU = \\begin{pmatrix}\n0  -2  1 \\\\\n0  0  -1 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n雅可比迭代矩阵 $B_{J}$ 定义为 $B_{J} = -D^{-1}(L+U)$。\n首先，我们计算对角矩阵 $D$ 的逆。由于在这种特殊情况下 $D$ 是单位矩阵 $I$，它的逆也是单位矩阵：\n$$\nD^{-1} = I^{-1} = I = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n接下来，我们计算和 $L+U$：\n$$\nL+U = \\begin{pmatrix}\n0  -2  1 \\\\\n-3  0  -1 \\\\\n2  -1  0\n\\end{pmatrix}\n$$\n现在，我们可以求出雅可比迭代矩阵 $B_{J}$：\n$$\nB_{J} = -D^{-1}(L+U) = -I(L+U) = -(L+U) = \\begin{pmatrix}\n0  2  -1 \\\\\n3  0  1 \\\\\n-2  1  0\n\\end{pmatrix}\n$$\n盖尔什戈林圆盘定理指出，对于任何方阵 $M \\in \\mathbb{C}^{n \\times n}$，其所有特征值都位于盖尔什戈林圆盘的并集 $\\bigcup_{i=1}^{n} C_i$ 中，其中每个圆盘 $C_i$（基于 $M$ 的行）以对角线元素 $M_{ii}$ 为中心，其半径 $r_i$ 等于第 $i$ 行中非对角线元素绝对值之和：\n$$\nC_i = \\{z \\in \\mathbb{C} : |z - M_{ii}| \\le r_i\\}, \\quad \\text{其中 } r_i = \\sum_{j \\neq i} |M_{ij}|\n$$\n我们将此定理应用于雅可比矩阵 $B_{J}$。 $B_{J}$ 的对角线元素均为零，即 $(B_{J})_{ii} = 0$ 对 $i \\in \\{1, 2, 3\\}$ 成立。因此，所有的盖尔什戈林圆盘都以复平面的原点为中心。我们计算每一行的半径：\n\n对于第一行（$i=1$）：\n中心是 $c_1 = (B_{J})_{11} = 0$。\n半径是 $r_1 = |(B_{J})_{12}| + |(B_{J})_{13}| = |2| + |-1| = 2 + 1 = 3$。\n圆盘是 $C_1 = \\{z \\in \\mathbb{C} : |z| \\le 3\\}$。\n\n对于第二行（$i=2$）：\n中心是 $c_2 = (B_{J})_{22} = 0$。\n半径是 $r_2 = |(B_{J})_{21}| + |(B_{J})_{23}| = |3| + |1| = 3 + 1 = 4$。\n圆盘是 $C_2 = \\{z \\in \\mathbb{C} : |z| \\le 4\\}$。\n\n对于第三行（$i=3$）：\n中心是 $c_3 = (B_{J})_{33} = 0$。\n半径是 $r_3 = |(B_{J})_{31}| + |(B_{J})_{32}| = |-2| + |1| = 2 + 1 = 3$。\n圆盘是 $C_3 = \\{z \\in \\mathbb{C} : |z| \\le 3\\}$。\n\n包含 $B_{J}$ 所有特征值的集合，即其谱 $\\sigma(B_{J})$，是这三个圆盘并集的子集：$\\sigma(B_{J}) \\subseteq C_1 \\cup C_2 \\cup C_3$。\n这些圆盘的并集是 $\\{z \\in \\mathbb{C} : |z| \\le 3\\} \\cup \\{z \\in \\mathbb{C} : |z| \\le 4\\} \\cup \\{z \\in \\mathbb{C} : |z| \\le 3\\}$。\n由于 $C_1$ 和 $C_3$ 是 $C_2$ 的子集，所以并集就是 $C_2$：\n$$\n\\bigcup_{i=1}^{3} C_i = C_2 = \\{z \\in \\mathbb{C} : |z| \\le 4\\}\n$$\n谱半径 $\\rho(B_{J})$ 定义为 $B_{J}$ 特征值绝对值的最大值，即 $\\rho(B_{J}) = \\max_{\\lambda \\in \\sigma(B_{J})} |\\lambda|$。\n由于每个特征值 $\\lambda$ 都必须位于盖尔什戈林圆盘的并集内，其绝对值必须小于或等于该并集的最大半径。\n因此，谱半径的一个上界由最大圆盘的半径给出：\n$$\n\\rho(B_{J}) \\le \\max(r_1, r_2, r_3) = \\max(3, 4, 3) = 4\n$$\n从盖尔什戈林行圆盘的并集中得到的谱半径 $\\rho(B_{J})$ 的最小一致上界 $R$ 就是这个最大半径。\n$$\nR = 4\n$$\n关于雅可比方法的行为，一个迭代格式收敛的充要条件是其迭代矩阵的谱半径严格小于1。在我们的例子中，收敛条件是 $\\rho(B_{J}) < 1$。我们得到的界是 $R = 4$，这意味着 $\\rho(B_{J}) \\le 4$。由于这个界不小于1，盖尔什戈林圆盘定理没有提供足够的证据来保证雅可比方法对该系统收敛。仅基于这个结果，不能断定该方法会收敛；它有可能会发散。\n最终答案是 $R$ 的值。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在对物理或生物系统进行长期模拟时，数值误差的累积可能会破坏解的定性特征。经典的洛特卡-沃尔泰拉 (Lotka-Volterra) 捕食者-被捕食者模型就是一个拥有守恒量的系统范例。本编程练习将对比标准的显式欧拉法和一种结构保持的辛欧拉法，您将研究积分器的选择如何影响系统不变量的长期守恒性。这项实践清晰地展示了“几何积分”思想的重要性：一个优秀的数值格式应尊重问题的内在数学或物理结构，这对于实现长期稳定性和准确性至关重要。",
            "id": "2378425",
            "problem": "您将研究时间积分方法的选择如何影响经典的捕食者-被捕食者 Lotka–Volterra 系统的长期轨道稳定性、精度和收敛性。考虑以下耦合常微分方程 (ODE)\n$$\n\\frac{dx}{dt} = a x - b x y,\\quad \\frac{dy}{dt} = -c y + d x y,\n$$\n其参数和初始条件均为严格正值。在本作业中，固定参数为 $a = 1$、$b = 1$、$c = 1$、$d = 1$，初始条件为 $x(0) = 1.5$、$y(0) = 1$。您的任务是实现两个一阶时间步进器，量化它们在短期和长期范围内的精度和稳定性，并按照下文指定的方式将数值诊断结果汇总到单行输出中。所有角度都是无量纲的，不涉及物理单位。\n\n基本基础：使用常微分方程的基本定义、显式欧拉法、哈密顿系统上的辛方法概念，以及数值精度（全局误差）、稳定性（不变量和正性的定性保持）和收敛性（时间步长细化下的观测阶数）的标准概念。使用关于 Lotka-Volterra 系统（其中 $a, b, c, d > 0$）的以下经过充分检验的事实：对于所有满足 $x(t) > 0$ 和 $y(t) > 0$ 的 $t$，函数\n$$\nI(x,y) = d\\,x - c \\ln x + b\\,y - a \\ln y\n$$\n沿精确轨迹保持不变。\n\n实现以下组件：\n\n1) 时间步进器：\n- 显式欧拉法（一种非保结构格式）：给定时间步长 $h > 0$，通过对右侧矢量场应用显式欧拉更新来推进 $x$ 和 $y$。\n- 辛欧拉法（一种用于哈密顿流的保结构格式）：引入典则变量变换 $u = \\ln x$，$v = \\ln y$，该系统可写成一个典则哈密顿系统，其哈密顿量为\n$$\nH(u,v) = d\\,e^{u} - c\\,u + b\\,e^{v} - a\\,v,\n$$\n典则方程为 $u' = -\\partial H/\\partial v$，$v' = \\partial H/\\partial u$。在典则变量 $(u,v)$ 中应用一阶辛欧拉格式，然后在每一步通过 $x = e^{u}$，$y = e^{v}$ 映射回 $(x,y)$。\n\n2) 用于量化精度、稳定性和收敛性的诊断指标：\n- 不变量漂移：对于给定的最终时间 $T > 0$，将不变量的绝对漂移定义为\n$$\n\\Delta I = \\left| I\\!\\left(x(T), y(T)\\right) - I\\!\\left(x(0), y(0)\\right) \\right|.\n$$\n如果在任何步骤中，数值 $(x,y)$ 离开了正象限（即，如果 $x \\le 0$ 或 $y \\le 0$），则不变量未定义；在这种情况下，将漂移报告为浮点数“非数值”(NaN)，并如下文所述单独标记违反了正性。\n- 正性标志：对于一条轨迹，返回一个布尔值，指示在达到最终时间前的每个离散步骤 $n$ 中是否都有 $x_n > 0$ 和 $y_n > 0$。\n- 最终时间的经验收敛阶：对于固定的 $T > 0$ 和两个步长 $h$ 和 $h/2$，分别用每个步长计算在时间 $T$ 的数值解。使用由鲁棒的 ODE 求解器计算的高精度参考解来近似时间 $T$ 时的精确状态。将误差 $E(h)$ 和 $E(h/2)$ 定义为时间 $T$ 时数值状态与参考状态之差的欧几里得范数。然后通过\n$$\np = \\log_2\\!\\left(\\frac{E(h)}{E(h/2)}\\right)\n$$\n来估计观测阶数。使用具有严格容差的高精度参考解，以使参考解误差相对于方法误差可以忽略不计。\n\n3) 测试套件和要求输出：\n固定 $a = 1$、$b = 1$、$c = 1$、$d = 1$，$x(0) = 1.5$、$y(0) = 1$。实现以下五个测试用例，每个用例都会产生一个待汇总的结果：\n\n- 测试 $1$（长期漂移和正性，非保结构）：在 $[0,T]$（其中 $T = 50$）上使用步长 $h = 0.05$ 的显式欧拉法。输出一个双元素列表 $[\\Delta I, \\text{pos}]$，其中 $\\Delta I$ 是上面定义的绝对不变量漂移（一个浮点数），$\\text{pos}$ 是正性标志（一个布尔值）。\n- 测试 $2$（长期漂移和正性，保结构）：在 $[0,T]$（其中 $T = 50$）上使用步长 $h = 0.05$ 的辛欧拉法。如上输出一个双元素列表 $[\\Delta I, \\text{pos}]$。\n- 测试 $3$（显式欧拉法的经验阶数）：使用步长 $h = 0.1$ 和 $h/2 = 0.05$ 计算在 $T = 10$ 时的观测阶数。使用高精度参考解进行比较。输出标量 $p$（一个浮点数）。\n- 测试 $4$（辛欧拉法的经验阶数）：使用步长 $h = 0.1$ 和 $h/2 = 0.05$ 计算在 $T = 10$ 时的观测阶数。使用高精度参考解进行比较。输出标量 $p$（一个浮点数）。\n- 测试 $5$（粗步长下的边缘情况稳定性）：在 $[0,T]$（其中 $T = 200$）上使用步长 $h = 0.5$ 的显式欧拉法。输出正性标志（一个布尔值）。\n\n实现细节和约束：\n- 所有模拟必须使用固定的参数 $a = 1$、$b = 1$、$c = 1$、$d = 1$ 和初始条件 $x(0) = 1.5$、$y(0) = 1$。\n- 对于高精度参考解，请使用具有严格容差的自适应 ODE 积分器（例如，相对容差 $10^{-12}$ 和绝对容差 $10^{-14}$）。\n- 对于所有测试，使用均匀的时间步长，该步长能精确整除最终时间，以使步数 $N = T/h$ 为整数。\n- 您的程序必须按所述实现两种时间步进器，并计算所要求的输出。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n\\big[ [\\Delta I_{\\text{EE}}, \\text{pos}_{\\text{EE}}], [\\Delta I_{\\text{SE}}, \\text{pos}_{\\text{SE}}], p_{\\text{EE}}, p_{\\text{SE}}, \\text{pos}_{\\text{EE,coarse}} \\big].\n$$\n例如，一个语法正确的输出看起来会像 $[[0.123,True],[0.004,True],0.98,1.01,False]$（此处显示的值仅为示例；您的程序必须计算实际值）。输出不包含单位和角度；布尔值按标准编程语言中的方式书写。",
            "solution": "该问题要求对 Lotka-Volterra 捕食者-被捕食者模型的两种数值积分格式——显式欧拉法和辛欧拉法——进行比较分析。分析将侧重于稳定性、精度和收敛性等基本数值概念。问题陈述已经过验证，被认为是科学上合理的、适定的和完整的。它构成了计算科学中一个标准且具有指导意义的练习。我们现在开始进行求解。\n\n该系统由以下耦合常微分方程 (ODE) 描述：\n$$\n\\frac{dx}{dt} = a x - b x y\n$$\n$$\n\\frac{dy}{dt} = -c y + d x y\n$$\n其中 $x(t)$ 和 $y(t)$ 分别代表被捕食者和捕食者的种群数量。参数固定为 $a = 1$、$b = 1$、$c = 1$ 和 $d = 1$。初始条件为 $x(0) = 1.5$ 和 $y(0) = 1.0$。\n\n该系统的一个关键特征是存在一个守恒量，或称首次积分，由以下函数给出：\n$$\nI(x,y) = d\\,x - c \\ln x + b\\,y - a \\ln y\n$$\n对于 ODE 的精确解，$\\frac{dI}{dt} = 0$，这意味着解轨迹 $(x(t), y(t))$ 被限制在 $I(x,y)$ 的等值线上。在相平面中，这些等值线围绕非平凡不动点 $(x_c, y_c) = (c/d, a/b)$ 形成闭合轨道。对于给定参数，该不动点位于 $(1, 1)$。$I(x,y)$ 的守恒是该系统的一个关键结构特性。一个理想的数值方法至少应能在长时间积分中近似地保持这个守恒性质。\n\n我们将实现并分析两种一阶数值格式。\n\n1.  **显式欧拉法**：\n这是一种标准的、非保结构的数值方法。给定时间 $t_n$ 的状态 $(x_n, y_n)$，时间 $t_{n+1} = t_n + h$ 的状态通过沿矢量场切线的线性外插来近似：\n$$\nx_{n+1} = x_n + h (a x_n - b x_n y_n)\n$$\n$$\ny_{n+1} = y_n + h (-c y_n + d x_n y_n)\n$$\n该方法实现简单，但众所周知，对于振荡系统，它要么是耗散的，要么是反耗散的。对于哈密顿系统，它不守恒能量或任何相关的不变量，数值轨迹通常会螺旋式地偏离真实的闭合轨道。此外，如果时间步长 $h$ 过大，显式更新可能导致不符合物理意义的负种群数量。\n\n2.  **辛欧拉法**：\n这是一种保结构积分器，具体来说是为哈密顿系统设计的几何积分器。Lotka-Volterra 系统可以转化为一个典则哈密顿系统。令 $u = \\ln x$ 和 $v = \\ln y$。在这些典则坐标下的动力学由哈密顿量控制：\n$$\nH(u,v) = d\\,e^{u} - c\\,u + b\\,e^{v} - a\\,v\n$$\n运动方程为 $\\dot{u} = -\\partial H / \\partial v = a - b e^v$ 和 $\\dot{v} = \\partial H / \\partial u = d e^u - c$。可以通过分离共轭变量的更新来构造一阶辛欧拉格式。我们将使用以下变体：\n$$\nv_{n+1} = v_n + h (d e^{u_n} - c)\n$$\n$$\nu_{n+1} = u_n + h (a - b e^{v_{n+1}})\n$$\n在 $(u,v)$ 坐标中每走一步后，我们转换回原始变量：$x_{n+1} = e^{u_{n+1}}$ 和 $y_{n+1} = e^{v_{n+1}}$。通过构造，只要 $u$ 和 $v$ 是实数（它们确实会是），该方法就能确保 $x$ 和 $y$ 保持正值。辛积分器并不精确守恒哈密顿量 $H$；相反，它们精确守 অবজার一个附近的“影子”哈密顿量。这一特性导致数值能量误差在零附近振荡，从而带来出色的长期稳定性和有界的不变量漂移，这与像显式欧拉法这样的非辛方法中观察到的长期漂移形成鲜明对比。\n\n对这些方法的评估基于三个诊断指标：\n\n-   **不变量漂移 ($\\Delta I$)**：衡量长期稳定性。它被定义为绝对差 $|I(x(T), y(T)) - I(x(0), y(0))|$。对于一个完美的积分器，$\\Delta I$ 将为零。我们预计辛欧拉法在长时间范围内的 $\\Delta I$ 将显著小于显式欧拉法。\n\n-   **正性**：种群模型的一个基本物理要求是种群数量保持非负。我们监测在所有步骤中是否有 $x_n > 0$ 和 $y_n > 0$。未能保持正性表明数值格式发生了灾难性失效。\n\n-   **经验收敛阶 ($p$)**：衡量精度。对于一个误差为 $E(h) \\propto h^p$ 的方法，我们可以通过比较使用两种不同步长 $h$ 和 $h/2$ 的模拟所产生的误差来估计阶数 $p$。公式为 $p = \\log_2(E(h)/E(h/2))$。对于正在测试的一阶方法，我们期望观察到 $p \\approx 1$。\n\n指定的五个测试旨在突显这两种方法之间的差异：\n-   测试 $1$ 和 $2$ 比较显式欧拉法和辛欧拉法的长期漂移和稳定性。\n-   测试 $3$ 和 $4$ 数值验证了两种格式的一阶收敛性。\n-   测试 $5$ 展示了显式欧拉法在粗时间步长下的不稳定性，在这种情况下，显式更新可能会过冲并违反正性。\n\n以下代码实现了这些测试并计算了所需的数值结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem by comparing Explicit and Symplectic Euler methods.\n    \"\"\"\n    # Fixed parameters and initial conditions\n    a, b, c, d = 1.0, 1.0, 1.0, 1.0\n    x0, y0 = 1.5, 1.0\n    state0 = np.array([x0, y0])\n\n    # === Helper Functions ===\n\n    def lotka_volterra_rhs(t, state, a, b, c, d):\n        \"\"\"Right-hand side of the Lotka-Volterra ODEs.\"\"\"\n        x, y = state\n        dxdt = a * x - b * x * y\n        dydt = -c * y + d * x * y\n        return np.array([dxdt, dydt])\n\n    def invariant(state, a, b, c, d):\n        \"\"\"Computes the conserved quantity I(x, y).\"\"\"\n        x, y = state\n        if x <= 0 or y <= 0:\n            return float('nan')\n        return d * x - c * np.log(x) + b * y - a * np.log(y)\n\n    def explicit_euler_step(state, h, a, b, c, d):\n        \"\"\"Performs one step of the Explicit Euler method.\"\"\"\n        x, y = state\n        x_new = x + h * (a * x - b * x * y)\n        y_new = y + h * (-c * y + d * x * y)\n        return np.array([x_new, y_new])\n\n    def symplectic_euler_step(state, h, a, b, c, d):\n        \"\"\"Performs one step of the Symplectic Euler method.\"\"\"\n        x, y = state\n        u, v = np.log(x), np.log(y)\n        v_new = v + h * (d * np.exp(u) - c)\n        u_new = u + h * (a - b * np.exp(v_new))\n        return np.array([np.exp(u_new), np.exp(v_new)])\n\n    def time_integrator(stepper_fn, state0, h, T, params):\n        \"\"\"\n        Integrates the ODEs using a given stepper function.\n        Returns the final state and a positivity flag.\n        \"\"\"\n        state = np.copy(state0)\n        positivity = True\n        num_steps = int(round(T / h))\n        \n        for _ in range(num_steps):\n            state = stepper_fn(state, h, *params)\n            if state[0] <= 0 or state[1] <= 0:\n                positivity = False\n                break\n        return state, positivity\n\n    # Initial invariant value\n    I0 = invariant(state0, a, b, c, d)\n    \n    results = []\n\n    # === Test 1: Explicit Euler, long-horizon drift and positivity ===\n    h1 = 0.05\n    T1 = 50.0\n    final_state_ee, pos_ee = time_integrator(explicit_euler_step, state0, h1, T1, (a, b, c, d))\n    if pos_ee:\n        I_final_ee = invariant(final_state_ee, a, b, c, d)\n        delta_I_ee = abs(I_final_ee - I0)\n    else:\n        delta_I_ee = float('nan')\n    results.append([delta_I_ee, pos_ee])\n\n    # === Test 2: Symplectic Euler, long-horizon drift and positivity ===\n    h2 = 0.05\n    T2 = 50.0\n    final_state_se, pos_se = time_integrator(symplectic_euler_step, state0, h2, T2, (a, b, c, d))\n    if pos_se:\n        I_final_se = invariant(final_state_se, a, b, c, d)\n        delta_I_se = abs(I_final_se - I0)\n    else:\n        delta_I_se = float('nan')\n    results.append([delta_I_se, pos_se])\n\n    # === Setup for Convergence Tests ===\n    T_conv = 10.0\n    h_conv = 0.1\n    \n    # High-accuracy reference solution\n    ref_sol = solve_ivp(\n        lotka_volterra_rhs, [0, T_conv], state0,\n        args=(a, b, c, d),\n        method='DOP853',\n        rtol=1e-12,\n        atol=1e-14\n    )\n    ref_state_T = ref_sol.y[:, -1]\n\n    # === Test 3: Empirical order for Explicit Euler ===\n    state_h_ee, _ = time_integrator(explicit_euler_step, state0, h_conv, T_conv, (a, b, c, d))\n    state_h2_ee, _ = time_integrator(explicit_euler_step, state0, h_conv / 2, T_conv, (a, b, c, d))\n    \n    error_h_ee = np.linalg.norm(state_h_ee - ref_state_T)\n    error_h2_ee = np.linalg.norm(state_h2_ee - ref_state_T)\n    \n    p_ee = np.log2(error_h_ee / error_h2_ee) if error_h2_ee > 0 else float('nan')\n    results.append(p_ee)\n\n    # === Test 4: Empirical order for Symplectic Euler ===\n    state_h_se, _ = time_integrator(symplectic_euler_step, state0, h_conv, T_conv, (a, b, c, d))\n    state_h2_se, _ = time_integrator(symplectic_euler_step, state0, h_conv / 2, T_conv, (a, b, c, d))\n\n    error_h_se = np.linalg.norm(state_h_se - ref_state_T)\n    error_h2_se = np.linalg.norm(state_h2_se - ref_state_T)\n\n    p_se = np.log2(error_h_se / error_h2_se) if error_h2_se > 0 else float('nan')\n    results.append(p_se)\n\n    # === Test 5: Explicit Euler, edge-case stability ===\n    h5 = 0.5\n    T5 = 200.0\n    _, pos_ee_coarse = time_integrator(explicit_euler_step, state0, h5, T5, (a, b, c, d))\n    results.append(pos_ee_coarse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}