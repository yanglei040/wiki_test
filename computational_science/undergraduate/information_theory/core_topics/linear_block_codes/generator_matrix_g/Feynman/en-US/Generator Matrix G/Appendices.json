{
    "hands_on_practices": [
        {
            "introduction": "The most fundamental task of a generator matrix $G$ is to encode a message vector $u$ into a corresponding codeword $c$. This exercise provides direct practice with this core operation, $c = uG$, within the framework of binary arithmetic (modulo 2). Mastering this calculation is the first essential step toward understanding how linear block codes protect information. ",
            "id": "1626330",
            "problem": "Consider a binary linear code used in a digital communication system. This system encodes message vectors of length $k=4$ into codeword vectors of length $n=7$. All arithmetic is performed in the finite field $\\mathbb{F}_2$, which means all additions and multiplications are carried out modulo 2 (e.g., $1+1=0$ and $1 \\times 1 = 1$).\n\nThe generator matrix $G$ for this specific code is given as:\n$$\nG = \\begin{pmatrix}\n1  0  0  0  1  1  0 \\\\\n0  1  0  0  0  1  1 \\\\\n0  0  1  0  1  1  1 \\\\\n0  0  0  1  1  0  1\n\\end{pmatrix}\n$$\n\nA message vector $u = [1, 0, 1, 1]$ is ready to be transmitted. To protect it from errors during transmission, it must first be encoded into its corresponding codeword vector $c$. Determine this codeword $c$. Your final answer should be presented as a single row matrix containing the binary digits of the codeword.",
            "solution": "We work over the field $\\mathbb{F}_{2}$, so all additions and multiplications are modulo $2$. For a binary linear code with generator matrix $G \\in \\mathbb{F}_{2}^{k \\times n}$ and a message row vector $u \\in \\mathbb{F}_{2}^{1 \\times k}$, the corresponding codeword row vector is\n$$\nc = uG \\in \\mathbb{F}_{2}^{1 \\times n}.\n$$\nLet the rows of $G$ be $r_{1}, r_{2}, r_{3}, r_{4} \\in \\mathbb{F}_{2}^{1 \\times 7}$. Then\n$$\nc = u_{1}r_{1} + u_{2}r_{2} + u_{3}r_{3} + u_{4}r_{4} \\quad \\text{(all operations in } \\mathbb{F}_{2}\\text{)}.\n$$\nGiven $u = [1, 0, 1, 1]$, we have\n$$\nc = r_{1} + r_{3} + r_{4}.\n$$\nFrom\n$$\nr_{1} = \\begin{pmatrix} 1  0  0  0  1  1  0 \\end{pmatrix},\\quad\nr_{3} = \\begin{pmatrix} 0  0  1  0  1  1  1 \\end{pmatrix},\\quad\nr_{4} = \\begin{pmatrix} 0  0  0  1  1  0  1 \\end{pmatrix},\n$$\nfirst compute\n$$\nr_{1} + r_{3} = \\begin{pmatrix}\n1+0  0+0  0+1  0+0  1+1  1+1  0+1\n\\end{pmatrix}\n= \\begin{pmatrix}\n1  0  1  0  0  0  1\n\\end{pmatrix},\n$$\nthen add $r_{4}$:\n$$\n(r_{1} + r_{3}) + r_{4} = \\begin{pmatrix}\n1+0  0+0  1+0  0+1  0+1  0+0  1+1\n\\end{pmatrix}\n= \\begin{pmatrix}\n1  0  1  1  1  0  0\n\\end{pmatrix}.\n$$\nTherefore, the codeword is\n$$\nc = \\begin{pmatrix} 1  0  1  1  1  0  0 \\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}1  0  1  1  1  0  0\\end{pmatrix}}$$"
        },
        {
            "introduction": "While different generator matrices can define the same code, a \"systematic\" form $G_{sys} = [I_k | P]$ is often preferred for its practical advantages, as the original message appears explicitly in the first $k$ bits of the codeword. This practice focuses on the essential skill of converting a given generator matrix into its equivalent systematic form using row operations. This process not only yields a more convenient matrix but also reinforces the key idea that a linear code is defined by the row space, which remains unchanged by these operations. ",
            "id": "1637124",
            "problem": "In digital communication, linear block codes are used to encode messages by adding redundant bits, which allows for error detection and correction at the receiver. A linear $(n, k)$ code takes a $k$-bit message vector and produces an $n$-bit codeword. The generator matrix $G$ for such a code is a $k \\times n$ matrix.\n\nAny generator matrix can be converted into an equivalent systematic form, $G_{sys} = [I_k | P]$, where $I_k$ is the $k \\times k$ identity matrix and $P$ is a $k \\times (n-k)$ matrix known as the parity-check part. In this form, the first $k$ bits of the codeword are identical to the original message bits. All arithmetic operations are performed over the binary field GF(2), where addition corresponds to the XOR operation ($1+1=0$).\n\nConsider a specific $(4, 2)$ linear block code described by the following non-systematic generator matrix:\n$$\nG = \\begin{pmatrix} 0  1  1  0 \\\\ 1  1  0  1 \\end{pmatrix}\n$$\nDetermine the parity matrix $P$ for the equivalent systematic generator matrix of this code. Present your answer as a matrix.",
            "solution": "The goal is to transform the given generator matrix $G$ into its systematic form $G_{sys} = [I_k | P]$, where $k=2$ for this $(4,2)$ code. This means we want to obtain the $2 \\times 2$ identity matrix $I_2 = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$ in the first two columns of $G$ using elementary row operations over GF(2).\n\nThe given non-systematic generator matrix is:\n$$\nG = \\begin{pmatrix} 0  1  1  0 \\\\ 1  1  0  1 \\end{pmatrix}\n$$\nLet's denote the rows as $R_1$ and $R_2$.\n\nOur target form for the first two columns is $\\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$.\n\nStep 1: Obtain a '1' in the top-left position (element at row 1, column 1).\nThe current element at (1,1) is 0. The element at (2,1) is 1. We can swap Row 1 ($R_1$) and Row 2 ($R_2$) to move the '1' to the desired position.\n$$\nR_1 \\leftrightarrow R_2\n$$\nThis operation yields a new matrix, let's call it $G'$:\n$$\nG' = \\begin{pmatrix} 1  1  0  1 \\\\ 0  1  1  0 \\end{pmatrix}\n$$\nThe first column is now correct. Now we need to transform the second column to $\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$.\n\nStep 2: Obtain a '0' in the position (1,2).\nThe element at (1,2) is currently 1. To make it 0, we can add the second row ($R_2'$) to the first row ($R_1'$) using modulo-2 arithmetic. Let the new first row be $R_1''$.\n$$\nR_1'' \\leftarrow R_1' + R_2'\n$$\nThe calculation for the new first row is:\n$R_1'' = (1+0, 1+1, 0+1, 1+0) = (1, 0, 1, 1)$\nThe second row remains unchanged: $R_2'' = R_2' = (0, 1, 1, 0)$.\n\nArranging these rows gives the systematic generator matrix $G_{sys}$:\n$$\nG_{sys} = \\begin{pmatrix} 1  0  1  1 \\\\ 0  1  1  0 \\end{pmatrix}\n$$\nThis matrix is now in the form $[I_2 | P]$. The first two columns form the identity matrix $I_2$, and the last two columns form the parity matrix $P$.\n\nBy comparing our result with the standard form, we can identify the matrix $P$:\n$$\nP = \\begin{pmatrix} 1  1 \\\\ 1  0 \\end{pmatrix}\n$$\nThis is the $2 \\times (4-2) = 2 \\times 2$ parity matrix for the systematic code.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1 \\\\\n1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Linearity is the defining characteristic of the codes we are studying, and it has powerful consequences. This problem challenges you to move beyond simple calculations and reason about the properties of an entire code based on the properties of its generator matrix. By investigating how the Hamming weight of the generator's rows influences the weight of every possible codeword, you will gain a deeper appreciation for the elegant structure that linearity imposes on the code space. ",
            "id": "1626317",
            "problem": "In the study of error-correcting codes, a linear block code is a fundamental concept. Such a code over the binary field, GF(2) = {0, 1}, can be defined by a $k \\times n$ generator matrix $G$. A message vector $u$, which is a $1 \\times k$ binary vector (a row of $k$ bits), is encoded into a codeword $c$, a $1 \\times n$ binary vector, via the matrix multiplication $c = uG$ (where all arithmetic is performed modulo 2).\n\nThe Hamming weight of a binary vector, denoted as $w(v)$, is the number of non-zero elements (i.e., the number of 1s) in the vector. For example, the Hamming weight of the vector $v = (1, 0, 1, 1, 0)$ is $w(v) = 3$.\n\nConsider a specific $k \\times n$ generator matrix $G$ for a linear block code. Upon inspection, it is found that every row vector of this matrix $G$ has an even Hamming weight. Based on this single property, what can be definitively concluded about the codewords generated by this matrix?\n\nSelect the most accurate statement from the choices below.\n\nA. All codewords generated by $G$ have an even Hamming weight.\n\nB. All non-zero codewords generated by $G$ have an odd Hamming weight.\n\nC. The number of even-weight codewords is equal to the number of odd-weight codewords.\n\nD. The minimum distance of the code must be exactly 2.\n\nE. The property of the row weights does not provide any information about the weights of the other codewords.",
            "solution": "The problem asks what can be concluded about the Hamming weights of codewords generated by a matrix $G$ where every row has an even Hamming weight. Let's analyze the structure of a codeword and the properties of Hamming weight.\n\nLet the generator matrix be a $k \\times n$ matrix $G$. We can represent its rows as $g_1, g_2, \\ldots, g_k$. Each $g_i$ is a vector of length $n$.\n$$\nG = \\begin{pmatrix}\ng_1 \\\\\ng_2 \\\\\n\\vdots \\\\\ng_k\n\\end{pmatrix}\n$$\nThe problem states that the Hamming weight of each row is even. This can be written as $w(g_i) \\equiv 0 \\pmod{2}$ for all $i \\in \\{1, 2, \\ldots, k\\}$.\n\nA message vector is a binary vector $u = (u_1, u_2, \\ldots, u_k)$, where each $u_i \\in \\{0, 1\\}$.\nA codeword $c$ is generated by the multiplication $c = uG$. This matrix multiplication can be expressed as a linear combination of the rows of $G$:\n$$\nc = u_1 g_1 + u_2 g_2 + \\cdots + u_k g_k = \\sum_{i=1}^{k} u_i g_i\n$$\nAll additions are performed in GF(2), which means they are equivalent to the bitwise XOR operation.\n\nWe need to determine the Hamming weight of an arbitrary codeword $c$, which is $w(c) = w(\\sum_{i=1}^{k} u_i g_i)$.\n\nA key property of Hamming weight over GF(2) is that the parity of the weight of a sum of vectors is the sum of the parities of their individual weights. In other words, for any two binary vectors $a$ and $b$, the following congruence holds:\n$w(a+b) \\equiv w(a) + w(b) \\pmod{2}$.\nThis property extends to a sum of multiple vectors. Thus, we can analyze the weight of the codeword $c$ modulo 2:\n$$\nw(c) = w\\left(\\sum_{i=1}^{k} u_i g_i\\right) \\equiv \\sum_{i=1}^{k} w(u_i g_i) \\pmod{2}\n$$\nNow, let's examine the term $w(u_i g_i)$. Since $u_i$ is either 0 or 1:\n- If $u_i = 0$, then $u_i g_i$ is the zero vector, and its weight is $w(0 \\cdot g_i) = w(\\mathbf{0}) = 0$.\n- If $u_i = 1$, then $u_i g_i$ is the vector $g_i$ itself, and its weight is $w(1 \\cdot g_i) = w(g_i)$.\nIn both cases, we can write $w(u_i g_i) = u_i \\cdot w(g_i)$.\n\nSubstituting this back into our congruence for the weight of $c$:\n$$\nw(c) \\equiv \\sum_{i=1}^{k} u_i \\cdot w(g_i) \\pmod{2}\n$$\nWe are given that the weight of every row $g_i$ is even, which means $w(g_i) \\equiv 0 \\pmod{2}$ for all $i$. Let's substitute this crucial piece of information:\n$$\nw(c) \\equiv \\sum_{i=1}^{k} u_i \\cdot (0) \\pmod{2}\n$$\nThis simplifies to:\n$$\nw(c) \\equiv \\sum_{i=1}^{k} 0 \\pmod{2}\n$$\n$$\nw(c) \\equiv 0 \\pmod{2}\n$$\nThis result shows that the Hamming weight of any codeword $c$ generated by this matrix $G$ must be an even number. This is true for any choice of the message vector $u$. This includes the zero codeword, which is generated by the zero message vector $u=\\mathbf{0}$, resulting in $c=\\mathbf{0}$ with $w(c)=0$, which is even.\n\nTherefore, the statement \"All codewords generated by $G$ have an even Hamming weight\" is correct. This corresponds to option A.\n\nLet's briefly analyze the other options:\n- B. \"All non-zero codewords generated by $G$ have an odd Hamming weight.\" This is directly contradicted by our derivation.\n- C. \"The number of even-weight codewords is equal to the number of odd-weight codewords.\" This is a property of linear codes that do not have the special property given. In our case, all $2^k$ codewords have even weight, and there are 0 odd-weight codewords.\n- D. \"The minimum distance of the code must be exactly 2.\" The minimum distance $d_{min}$ of a linear code is the minimum Hamming weight of any non-zero codeword. Our derivation shows all non-zero codewords have even weight, so $d_{min}$ must be an even integer greater than 0. However, it does not have to be *exactly* 2. It could be 4, 6, or any other even integer. For example, the code generated by the single row $g_1 = (1,1,1,1)$ has $w(g_1)=4$. The non-zero codeword is just $(1,1,1,1)$, and the minimum distance is 4. Thus, this statement is not necessarily true.\n- E. \"The property of the row weights does not provide any information about the weights of the other codewords.\" This is false, as we were able to draw a very specific conclusion.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}