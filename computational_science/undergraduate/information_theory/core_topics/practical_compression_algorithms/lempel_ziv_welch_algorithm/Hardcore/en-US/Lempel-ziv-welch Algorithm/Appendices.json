{
    "hands_on_practices": [
        {
            "introduction": "To truly understand the Lempel-Ziv-Welch algorithm, there is no substitute for tracing its operation by hand. This first exercise  guides you through the fundamental encoding process on a simple string. By starting with a minimal dictionary, you can focus entirely on the core logic of how LZW identifies patterns and builds its dictionary dynamically.",
            "id": "1636836",
            "problem": "The Lempel-Ziv-Welch (LZW) algorithm is a universal lossless data compression algorithm. Its operation relies on building a dictionary of strings encountered during the compression process. The compression proceeds as follows:\n\n1.  Initialize the dictionary with a set of predefined strings and their corresponding codes.\n2.  Start with an empty 'current string' `S`.\n3.  Read the next character `C` from the input stream.\n4.  Consider the new string `S + C` (the current string appended with the new character).\n5.  If `S + C` is already in the dictionary, update the current string: `S = S + C`.\n6.  If `S + C` is not in the dictionary:\n    a) Add `S + C` to the dictionary with the next available integer code.\n    b) Output the code for the current string `S`.\n    c) Reset the current string to be just the character `C`, i.e., `S = C`.\n7.  Repeat from step 3 until the end of the input stream is reached.\n8.  After the loop terminates, output the code for the final 'current string' `S`.\n\nConsider an LZW compressor with an initial dictionary containing only two entries: `A` is assigned code `0`, and `B` is assigned code `1`. The codes for new dictionary entries start from `2` and are assigned sequentially.\n\nDetermine the sequence of output codes generated by this LZW compressor for the input string `BBAABABB`. Present your answer as a sequence of integers.",
            "solution": "Initialize the dictionary with $D(\\text{A})=0$ and $D(\\text{B})=1$. Let the next available code be $n=2$. Start with the current string $S$ empty.\n\nRead the first character $C=\\text{B}$. Since $S$ is empty, the concatenation $S+C=\\text{B}$ is in the dictionary, so update $S=\\text{B}$.\n\nRead the second character $C=\\text{B}$. Now $S+C=\\text{BB}$ is not in the dictionary. Add it: $D(\\text{BB})=2$ and update $n \\rightarrow 3$. Output the code for the current string $S$, which is $D(\\text{B})=1$. Reset $S=C=\\text{B}$.\n\nRead the third character $C=\\text{A}$. Now $S+C=\\text{BA}$ is not in the dictionary. Add it: $D(\\text{BA})=3$ and update $n \\rightarrow 4$. Output $D(\\text{B})=1$. Reset $S=C=\\text{A}$.\n\nRead the fourth character $C=\\text{A}$. Now $S+C=\\text{AA}$ is not in the dictionary. Add it: $D(\\text{AA})=4$ and update $n \\rightarrow 5$. Output $D(\\text{A})=0$. Reset $S=C=\\text{A}$.\n\nRead the fifth character $C=\\text{B}$. Now $S+C=\\text{AB}$ is not in the dictionary. Add it: $D(\\text{AB})=5$ and update $n \\rightarrow 6$. Output $D(\\text{A})=0$. Reset $S=C=\\text{B}$.\n\nRead the sixth character $C=\\text{A}$. Now $S+C=\\text{BA}$ is in the dictionary (with code $3$), so update $S=\\text{BA}$.\n\nRead the seventh character $C=\\text{B}$. Now $S+C=\\text{BAB}$ is not in the dictionary. Add it: $D(\\text{BAB})=6$ and update $n \\rightarrow 7$. Output $D(\\text{BA})=3$. Reset $S=C=\\text{B}$.\n\nRead the eighth character $C=\\text{B}$. Now $S+C=\\text{BB}$ is in the dictionary (with code $2$), so update $S=\\text{BB}$.\n\nEnd of input: output the code for the final current string $S$, which is $D(\\text{BB})=2$.\n\nCollecting the outputs in order gives the sequence $1, 1, 0, 0, 3, 2$.",
            "answer": "$$\\boxed{\\begin{pmatrix}1 & 1 & 0 & 0 & 3 & 2\\end{pmatrix}}$$"
        },
        {
            "introduction": "The elegance of LZW lies in its symmetric design, where the decompressor can perfectly reconstruct the dictionary built by the compressor. This practice  challenges you to act as the decompressor, translating a sequence of codes back into the original message. This exercise reinforces the rule for dictionary building from the decoder's perspective and shows how compression is reversed.",
            "id": "1636869",
            "problem": "A simplified data compression system uses the Lempel-Ziv-Welch (LZW) algorithm to encode text messages. The algorithm works by building a dictionary of strings encountered during compression. For the purpose of this problem, assume the following specific details about the LZW implementation:\n\n1.  The initial dictionary is pre-populated with entries for all 8-bit ASCII characters. This means the integer codes from 0 to 255 are mapped to their corresponding single-character strings.\n2.  The first available code for newly generated dictionary entries is 256.\n3.  The LZW encoder reads the longest string `S` from the input that is currently in the dictionary. It outputs the code for `S`. It then takes `S` plus the next character `C` from the input, `S+C`, and adds this new string to the dictionary with the next available numeric code.\n\nA compressed message fragment is received as a sequence of integer codes. The sequence is `[65, 66, 67, 256, 258]`. Reconstruct the original text message fragment from this sequence.",
            "solution": "We are asked to decode an LZW-compressed sequence of codes: `[65, 66, 67, 256, 258]`. We will use the standard LZW decoding algorithm, which mirrors the encoding process.\n\n**Initial State:**\n*   The dictionary contains entries for all ASCII characters from 0 to 255. For example, code `65` maps to the string 'A', `66` to 'B', and `67` to 'C'.\n*   The next available code to be added to the dictionary is `256`.\n*   The output string is initially empty.\n\nThe decoding algorithm proceeds as follows: read a code from the input, look up its corresponding string in the dictionary, and output that string. Then, create a new dictionary entry by concatenating the previously output string with the first character of the currently output string.\n\nLet's trace the decoding of the sequence `[65, 66, 67, 256, 258]`.\n\n**Step 1: Decode code `65`**\n*   Input code: `65`.\n*   From the initial dictionary, code `65` corresponds to the string 'A'.\n*   Output string: 'A'.\n*   The first code has been processed. We set `previous_string = 'A'`.\n*   Current decoded message: \"A\".\n\n**Step 2: Decode code `66`**\n*   Input code: `66`.\n*   From the initial dictionary, code `66` corresponds to the string 'B'. Let's call this `current_string`.\n*   Output string: 'B'.\n*   A new dictionary entry must be created. The new entry is `previous_string + first_character(current_string)`.\n*   `previous_string` is 'A'. `current_string` is 'B'. `first_character(current_string)` is 'B'.\n*   New string to add: 'A' + 'B' = \"AB\".\n*   This new string \"AB\" is added to the dictionary with the next available code, which is `256`. So, dictionary now contains `(256, \"AB\")`.\n*   Update `previous_string = current_string = 'B'`.\n*   Current decoded message: \"AB\".\n\n**Step 3: Decode code `67`**\n*   Input code: `67`.\n*   From the initial dictionary, code `67` corresponds to the string 'C'. Let's call this `current_string`.\n*   Output string: 'C'.\n*   Create a new dictionary entry: `previous_string + first_character(current_string)`.\n*   `previous_string` is 'B'. `current_string` is 'C'. `first_character(current_string)` is 'C'.\n*   New string to add: 'B' + 'C' = \"BC\".\n*   This new string \"BC\" is added to the dictionary with the next available code, which is `257`. So, dictionary now contains `(257, \"BC\")`.\n*   Update `previous_string = current_string = 'C'`.\n*   Current decoded message: \"ABC\".\n\n**Step 4: Decode code `256`**\n*   Input code: `256`.\n*   We look up code `256` in our dictionary. From Step 2, we know this corresponds to the string \"AB\". Let's call this `current_string`.\n*   Output string: \"AB\".\n*   Create a new dictionary entry: `previous_string + first_character(current_string)`.\n*   `previous_string` is 'C'. `current_string` is \"AB\". `first_character(current_string)` is 'A'.\n*   New string to add: 'C' + 'A' = \"CA\".\n*   This new string \"CA\" is added to the dictionary with the next available code, which is `258`. So, dictionary now contains `(258, \"CA\")`.\n*   Update `previous_string = current_string = \"AB\"`.\n*   Current decoded message: \"ABCAB\".\n\n**Step 5: Decode code `258`**\n*   Input code: `258`.\n*   We look up code `258` in our dictionary. From Step 4, we know this corresponds to the string \"CA\". Let's call this `current_string`.\n*   Output string: \"CA\".\n*   Create a new dictionary entry: `previous_string + first_character(current_string)`.\n*   `previous_string` is \"AB\". `current_string` is \"CA\". `first_character(current_string)` is 'C'.\n*   New string to add: \"AB\" + 'C' = \"ABC\".\n*   This new string \"ABC\" is added to the dictionary with the next available code, which is `259`. So, dictionary now contains `(259, \"ABC\")`.\n*   Update `previous_string = current_string = \"CA\"`.\n*   Current decoded message: \"ABCABCA\".\n\nThe input sequence is now fully processed. The concatenated output gives the original message.\n\nFinal Decoded String: 'A' + 'B' + 'C' + \"AB\" + \"CA\" = \"ABCABCA\".",
            "answer": "$$\\boxed{ABCABCA}$$"
        },
        {
            "introduction": "A robust understanding of any algorithm includes knowing how it handles edge cases. This problem  presents a special but important scenario in LZW decompression where a code is used by the encoder immediately after its creation. Mastering this situation is key to implementing a fully functional LZW decompressor and reveals the clever foresight in the algorithm's design.",
            "id": "1636872",
            "problem": "A Lempel-Ziv-Welch (LZW) decompressor is designed to reconstruct an original text string from a sequence of integer codes. The algorithm's dictionary is initialized to contain 256 entries (codes 0-255) for all single-character strings corresponding to the 8-bit ASCII character set. The first code available for new multi-character strings is 256.\n\nThe decompression algorithm proceeds by reading one code at a time from the compressed input stream. For each code read, it performs the following two actions in order:\n1.  Retrieves the string corresponding to the code from the dictionary and writes it to the output stream.\n2.  Adds a new entry to the dictionary. This new entry's string value is the concatenation of the string from the *previous* code and the *first character* of the string from the *current* code. The first code in the stream has no previous code, so the dictionary is not updated after it is processed.\n\nYou are tasked with manually decompressing the following sequence of codes: `[66, 79, 256, 258]`.\nThe codes 66 and 79 correspond to the ASCII characters 'B' and 'O', respectively.\n\nDetermine the exact original uncompressed string.",
            "solution": "Initialize the LZW dictionary $D$ with single-character strings for codes $0$ through $255$. The next available code is $c=256$. Let $\\operatorname{first}(X)$ denote the first character of string $X$. The decompression reads each code, outputs its corresponding string, and then adds a new entry $D[c]=P \\, \\Vert \\, \\operatorname{first}(S)$, where $P$ is the string from the previous code and $S$ is the string from the current code. For the special case when a code is not yet in $D$, the LZW rule is $S=P \\, \\Vert \\, \\operatorname{first}(P)$.\n\nProcess the codes $[66,79,256,258]$ as follows.\n\n1) Read $66$:\n- Current string $S=D[66]=\"B\"$. Output \"B\".\n- No previous code exists, so do not add to the dictionary.\n- Set $P=\"B\"$. $c$ remains $256$.\n\n2) Read $79$:\n- $S=D[79]=\"O\"$. Output \"O\".\n- Add $D[256]=P \\, \\Vert \\, \\operatorname{first}(S)=\"B\" \\, \\Vert \\, \"O\"=\"BO\"$. Increment $c$ to $257$.\n- Set $P=\"O\"$.\n\n3) Read $256$:\n- $S=D[256]=\"BO\"$. Output \"BO\".\n- Add $D[257]=P \\, \\Vert \\, \\operatorname{first}(S)=\"O\" \\, \\Vert \\, \"B\"=\"OB\"$. Increment $c$ to $258$.\n- Set $P=\"BO\"$.\n\n4) Read $258$:\n- Code $258$ is not yet in $D$ (since $c=258$), so use the LZW special case: $S=P \\, \\Vert \\, \\operatorname{first}(P)=\"BO\" \\, \\Vert \\, \"B\"=\"BOB\"$. Output \"BOB\".\n- Add $D[258]=P \\, \\Vert \\, \\operatorname{first}(S)=\"BO\" \\, \\Vert \\, \"B\"=\"BOB\"$. Increment $c$ to $259$.\n- Set $P=\"BOB\"$.\n\nConcatenating all outputs in order gives the original string: \"B\" followed by \"O\" followed by \"BO\" followed by \"BOB\", which is \"BOBOBOB\".",
            "answer": "$$\\boxed{BOBOBOB}$$"
        }
    ]
}