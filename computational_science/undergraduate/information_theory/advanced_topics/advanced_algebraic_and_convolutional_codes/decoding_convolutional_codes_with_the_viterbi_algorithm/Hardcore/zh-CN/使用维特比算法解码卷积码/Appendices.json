{
    "hands_on_practices": [
        {
            "introduction": "维特比算法的核心思想是在网格图中寻找与接收序列“最接近”的路径。为了量化这种“接近度”，我们需要一个衡量标准来评估每一步（即每个分支）的差异。这个练习将带你计算维特比算法中最基本也最关键的组成部分——分支度量，它通常通过汉明距离来定义，为解码过程中的路径选择提供依据。",
            "id": "1616748",
            "problem": "一个数字通信系统使用一个码率为 $R=1/2$、约束长度为 $K=3$ 的卷积编码器。在时间步 $i$ 时，编码器的状态由其两个存储寄存器的内容定义，即 $S_i = (m_{i-1}, m_{i-2})$，其中 $m_{i-k}$ 是 $k$ 个时间步之前的输入比特。\n\n在时间步 $i$ 时的两个输出比特，记为比特对 $c_i = (c_{i,1}, c_{i,2})$，是根据当前输入比特 $m_i$ 和状态 $(m_{i-1}, m_{i-2})$，按照以下生成规则产生的，其中 $\\oplus$ 表示模2加：\n$c_{i,1} = m_i \\oplus m_{i-1} \\oplus m_{i-2}$\n$c_{i,2} = m_i \\oplus m_{i-2}$\n\n经过噪声信道传输后，接收机接收到编码序列的受损版本。在维特比译码算法中，接收机为每个可能的状态转移计算一个分支度量，以找到最可能发送的序列。对于给定的转移，分支度量定义为接收到的比特对与编码器在该相同转移下本应产生的理想比特对之间的汉明距离。\n\n假设在时间步 $i$ 时，编码器处于状态 $S_i = (1, 0)$，且下一个输入比特为 $m_i = 1$。在接收机端，观测到该时间步对应的接收比特对为 $r_i = (1, 0)$。\n\n计算此特定转移的分支度量的数值。",
            "solution": "编码器码率为 $R=1/2$，约束长度为 $K=3$，因此在时间 $i$ 的状态为 $S_{i}=(m_{i-1},m_{i-2})$。生成规则为\n$$\nc_{i,1}=m_{i}\\oplus m_{i-1}\\oplus m_{i-2}, \\qquad c_{i,2}=m_{i}\\oplus m_{i-2}.\n$$\n给定 $S_{i}=(1,0)$ 和 $m_{i}=1$，计算理想的编码器输出：\n$$\nc_{i,1}=1\\oplus 1\\oplus 0=(1\\oplus 1)\\oplus 0=0\\oplus 0=0, \\qquad c_{i,2}=1\\oplus 0=1,\n$$\n所以 $c_{i}=(0,1)$。接收到的比特对为 $r_{i}=(1,0)$。\n\n维特比分支度量是 $c_{i}$ 和 $r_{i}$ 之间的汉明距离，即不同位置的数量。等价地，对于二进制符号，\n$$\nd_{H}(c_{i},r_{i})=(c_{i,1}\\oplus r_{i,1})+(c_{i,2}\\oplus r_{i,2})=(0\\oplus 1)+(1\\oplus 0)=1+1=2.\n$$\n因此，此转移的分支度量为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "掌握了如何计算单个分支度量后，我们就可以将这些基本计算单元组合起来，执行完整的维特比解码过程。这个练习将引导你处理一个简短的接收序列，逐步完成维特比算法的每一步：累积路径度量、在每个状态下选择“幸存路径”，并最终通过回溯来恢复原始信息序列。通过这个完整的演练，你将亲身体验维特比算法的强大功能。",
            "id": "1664334",
            "problem": "在一个数字通信系统中，一个简单的码率为1/2的卷积编码器被用来在传输前为消息添加冗余。该编码器有一个单比特的内存，用于定义其状态。状态空间由两个状态组成：状态`S0`，表示前一个输入比特是`0`；状态`S1`，表示前一个输入比特是`1`。\n\n在每个时间步，一个输入比特`m`进入编码器，发生一次状态转移，并生成一个两比特的输出`c`。转移逻辑如下：\n- 如果编码器处于状态`S0`（前一个输入是`0`）：\n    - 输入比特`m=0`使编码器转移回状态`S0`，并产生输出`c=00`。\n    - 输入比特`m=1`使编码器转移到状态`S1`，并产生输出`c=11`。\n- 如果编码器处于状态`S1`（前一个输入是`1`）：\n    - 输入比特`m=0`使编码器转移到状态`S0`，并产生输出`c=10`。\n    - 输入比特`m=1`使编码器转移回状态`S1`，并产生输出`c=01`。\n\n一个未知的3比特信息序列由该编码器处理。在编码之前，一个称为冲刷比特的单比特'0'被附加到这个3比特序列的末尾。编码器在处理这个附加后的4比特序列的第一个比特之前被初始化到状态`S0`。所得到的8比特编码序列通过一个噪声信道传输。\n\n接收到的2比特对序列是`[10, 01, 01, 10]`。假设错误是独立的，且对任何比特发生的概率相同，那么最可能的发送序列是与接收序列具有最小总汉明距离的序列。使用维特比算法来确定原始的3比特信息序列。\n\n以下哪个是最可能的原始3比特信息序列？\n\nA. `011`\n\nB. `101`\n\nC. `111`\n\nD. `001`\n\nE. `110`",
            "solution": "目标是通过应用维特比算法解码接收序列`r = [10, 01, 01, 10]`来找出原始的3比特信息序列。维特比算法在卷积码的网格图中找到一条与接收序列具有最小汉明距离的路径。\n\n编码器有两个状态`S0`和`S1`，并被初始化在`S0`。输入是一个4比特序列（3个消息比特 + 1个冲刷比特）。算法针对4个时间步逐步进行。使用的度量是累积汉明距离，我们称之为路径度量（PM）。分支度量是某次转移的输出与该时间步接收到的比特对之间的汉明距离。\n\n设$PM_t(S)$为状态`S`在时间`t`的路径度量。\n**初始步骤 (t=0):**\n编码器从状态`S0`开始。\n$PM_0(S0) = 0$\n$PM_0(S1) = \\infty$ （或一个非常大的数，因为它是一个不可能的起始状态）\n\n**时间步 1 (t=1):**\n接收比特: `r_1 = 10`。\n在`t=0`时，从`S0`出现两条路径。\n- 到`S0`的路径：输入`m=0`，输出`c=00`。分支度量 = 汉明距离 $d(00, 10) = 1$。\n  $PM_1(S0) = PM_0(S0) + d(00, 10) = 0 + 1 = 1$。到`S0`的幸存路径对应于输入`0`。\n- 到`S1`的路径：输入`m=1`，输出`c=11`。分支度量 = $d(11, 10) = 1$。\n  $PM_1(S1) = PM_0(S0) + d(11, 10) = 0 + 1 = 1$。到`S1`的幸存路径对应于输入`1`。\n\n**时间步 2 (t=2):**\n接收比特: `r_2 = 01`。\n- 到`S0`的路径：\n  - 从`S0`（输入`m=0`，输出`c=00`）：总PM = $PM_1(S0) + d(00, 01) = 1 + 1 = 2$。\n  - 从`S1`（输入`m=0`，输出`c=10`）：总PM = $PM_1(S1) + d(10, 01) = 1 + 2 = 3$。\n  `S0`的最小PM是2。幸存路径来自`S0`。\n  $PM_2(S0) = 2$。此路径的输入序列是`00`。\n- 到`S1`的路径：\n  - 从`S0`（输入`m=1`，输出`c=11`）：总PM = $PM_1(S0) + d(11, 01) = 1 + 1 = 2$。\n  - 从`S1`（输入`m=1`，输出`c=01`）：总PM = $PM_1(S1) + d(01, 01) = 1 + 0 = 1$。\n  `S1`的最小PM是1。幸存路径来自`S1`。\n  $PM_2(S1) = 1$。此路径的输入序列是`11`。\n\n**时间步 3 (t=3):**\n接收比特: `r_3 = 01`。\n- 到`S0`的路径：\n  - 从`S0`（输入`m=0`，输出`c=00`）：总PM = $PM_2(S0) + d(00, 01) = 2 + 1 = 3$。\n  - 从`S1`（输入`m=0`，输出`c=10`）：总PM = $PM_2(S1) + d(10, 01) = 1 + 2 = 3$。\n  出现平局。一个常见的惯例是选择来自上方状态（`S0`）的路径。\n  $PM_3(S0) = 3$。幸存路径对应的输入序列是`000`。\n- 到`S1`的路径：\n  - 从`S0`（输入`m=1`，输出`c=11`）：总PM = $PM_2(S0) + d(11, 01) = 2 + 1 = 3$。\n  - 从`S1`（输入`m=1`，输出`c=01`）：总PM = $PM_2(S1) + d(01, 01) = 1 + 0 = 1$。\n  `S1`的最小PM是1。幸存路径来自`S1`。\n  $PM_3(S1) = 1$。幸存路径对应的输入序列是`111`。\n\n**时间步 4 (t=4):**\n接收比特: `r_4 = 10`。输入是冲刷比特`m=0`。我们只考虑输入为`0`的转移。编码器必须结束在状态`S0`。\n- 从`t=3`的`S0`到`t=4`的`S0`的路径（输入`m=0`，输出`c=00`）：\n  最终PM = $PM_3(S0) + d(00, 10) = 3 + 1 = 4$。\n- 从`t=3`的`S1`到`t=4`的`S0`的路径（输入`m=0`，输出`c=10`）：\n  最终PM = $PM_3(S1) + d(10, 10) = 1 + 0 = 1$。\n\n**回溯：**\n比较所有结束于`S0`的路径的最终路径度量，最小值是1。这条路径是最可能的路径。我们对其进行回溯以找到输入序列。\n- 在`t=4`时，获胜路径来自`t=3`时的`S1`。输入是`0`。\n- 在`t=3`时，进入`S1`的幸存路径来自`t=2`时的`S1`。输入是`1`。\n- 在`t=2`时，进入`S1`的幸存路径来自`t=1`时的`S1`。输入是`1`。\n- 在`t=1`时，进入`S1`的幸存路径来自`t=0`时的`S0`。输入是`1`。\n\n按时间顺序读取输入，解码后的4比特序列是`1110`。最后一个比特是冲刷比特，所以原始的3比特信息序列是`111`。\n\n这与选项C相符。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "维特比算法为何能有效纠正错误？其性能在很大程度上取决于编码设计，即确保错误路径与正确路径之间具有显著的差异。本练习通过分析“错误事件”——解码器偏离正确路径后又重新汇合的 detour——来探讨这个问题。通过计算不同错误路径的汉明权重，你将理解编码结构如何影响这些错误路径与正确路径的“距离”，而这正是决定解码器纠错能力的关键。",
            "id": "1616756",
            "problem": "一个数字通信系统采用速率为 $R=1/2$ 的卷积码进行前向纠错。该编码器的记忆深度为 $M=2$。编码器在时间步 $k$ 的状态由前两个信息比特给出，即 $S_k = (u_{k-1}, u_{k-2})$。编码器被初始化为全零状态，即 $S_1 = (u_0, u_{-1}) = (0, 0)$。在时间 $k$ 的两个输出比特，记为比特对 $(v_k^{(1)}, v_k^{(2)})$，由当前输入比特 $u_k$ 和当前状态 $S_k$ 根据以下生成方程生成，其中所有加法均为模2加法：\n$$v_k^{(1)} = u_k + u_{k-1} + u_{k-2}$$\n$$v_k^{(2)} = u_k + u_{k-2}$$\n\n假设发射机发送一个完全由零组成的消息（全零信息序列）。因此，发送的正确编码序列也是一个全零序列。在接收端，Viterbi译码器可能会错误地选择一条穿过码格图的路径，该路径从全零路径分岔出去，随后又重新汇合。这样的一次绕行被称为一个错误事件。一个错误事件与正确的全零路径被混淆的可能性，与沿着这条错误路径生成的编码序列的汉明权重（即其输出中'1'的总数）有关。\n\n考虑两个特定的错误事件，路径 A 和路径 B，它们都在时间 $k=1$ 时从全零路径分岔出去。\n- **路径 A** 是当输入信息序列为 $u_A = (1, 0, 0, 0, \\dots)$（即在时间 $k=1$ 时有一个'1'）时，编码器所经过的轨迹。\n- **路径 B** 是当输入信息序列为 $u_B = (1, 1, 0, 0, \\dots)$（即在时间 $k=1$ 和 $k=2$ 时有'1'）时，编码器所经过的轨迹。\n\n两条路径最终都将返回到全零状态。令 $d_A$ 为路径 A 从分岔点开始直到与全零路径重新汇合为止所生成的完整编码输出序列的汉明权重。同样地，令 $d_B$ 为路径 B 的汉明权重。\n\n计算比率 $d_B / d_A$。",
            "solution": "编码器的记忆深度为 $M=2$，状态为 $S_{k}=(u_{k-1},u_{k-2})$。当发送的信息为全零时，全零编码序列是正确的路径。错误事件是由一个非零输入子序列产生的，该子序列使编码器离开全零状态，随后又返回到全零状态；该事件的汉明权重等于沿着该子序列的编码器输出中'1'的总数。因为全零路径的输出全为零，所以错误路径的汉明权重等于在该事件期间它与正确路径之间的汉明距离。\n\n生成方程（模2）为\n$$\nv_{k}^{(1)}=u_{k}+u_{k-1}+u_{k-2},\\qquad v_{k}^{(2)}=u_{k}+u_{k-2}.\n$$\n当状态返回到 $(0,0)$ 时，即当两个连续的输入比特为零时，路径与全零路径重新汇合。根据状态定义 $S_{k}=(u_{k-1},u_{k-2})$，所要包含的输出，是指从 $k=1$ 分岔开始，到状态首次再次变为 $(0,0)$ 的前一时间步为止的这段时间内，每个时间步 $k$ 所产生的输出（等价地，包含直至使状态返回零状态的转移在内的所有输出）。\n\n路径 A 的输入为 $u_{1}=1$，$u_{2}=0$，$u_{3}=0$，以及对于 $k\\geq 4$ 有 $u_{k}=0$。状态演变为 $S_{1}=(0,0)$, $S_{2}=(1,0)$, $S_{3}=(0,1)$, $S_{4}=(0,0)$，因此该事件跨越了 $k=1,2,3$。输出为：\n$$\nk=1\\text{时： }(v_{1}^{(1)},v_{1}^{(2)})=(1+0+0,\\ 1+0)=(1,1),\n$$\n$$\nk=2\\text{时： }(v_{2}^{(1)},v_{2}^{(2)})=(0+1+0,\\ 0+0)=(1,0),\n$$\n$$\nk=3\\text{时： }(v_{3}^{(1)},v_{3}^{(2)})=(0+0+1,\\ 0+1)=(1,1).\n$$\n每个时间步的汉明权重分别为 $2$、$1$ 和 $2$，因此\n$$\nd_{A}=2+1+2=5.\n$$\n\n路径 B 的输入为 $u_{1}=1$，$u_{2}=1$，$u_{3}=0$，$u_{4}=0$，以及对于 $k\\geq 5$ 有 $u_{k}=0$。状态演变为 $S_{1}=(0,0)$, $S_{2}=(1,0)$, $S_{3}=(1,1)$, $S_{4}=(0,1)$, $S_{5}=(0,0)$，因此该事件跨越了 $k=1,2,3,4$。输出为：\n$$\nk=1\\text{时： }(v_{1}^{(1)},v_{1}^{(2)})=(1+0+0,\\ 1+0)=(1,1),\n$$\n$$\nk=2\\text{时： }(v_{2}^{(1)},v_{2}^{(2)})=(1+1+0,\\ 1+0)=(0,1),\n$$\n$$\nk=3\\text{时： }(v_{3}^{(1)},v_{3}^{(2)})=(0+1+1,\\ 0+1)=(0,1),\n$$\n$$\nk=4\\text{时： }(v_{4}^{(1)},v_{4}^{(2)})=(0+0+1,\\ 0+1)=(1,1).\n$$\n每个时间步的汉明权重分别为 $2$、$1$、$1$ 和 $2$，因此\n$$\nd_{B}=2+1+1+2=6.\n$$\n\n因此，所求的比率为\n$$\n\\frac{d_{B}}{d_{A}}=\\frac{6}{5}.\n$$",
            "answer": "$$\\boxed{\\frac{6}{5}}$$"
        }
    ]
}