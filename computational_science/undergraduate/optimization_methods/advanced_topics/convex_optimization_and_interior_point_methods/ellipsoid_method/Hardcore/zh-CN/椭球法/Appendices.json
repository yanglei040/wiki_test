{
    "hands_on_practices": [
        {
            "introduction": "理解迭代算法的最佳方式之一是亲手执行几步。本练习  将指导你为一个简单的线性规划问题手动执行两轮完整的椭球法迭代。通过这个过程，你将揭开中心点和形态矩阵更新公式的神秘面纱，并加深对体积缩减保证这一核心特性的理解。",
            "id": "3125375",
            "problem": "考虑 $\\mathbb{R}^{3}$ 中的以下线性规划 (LP) 的可行性实例：\n求解 $x \\in \\mathbb{R}^{3}$，使得\n- $x_{1} \\ge 0$, $x_{2} \\ge 0$, $x_{3} \\ge 0$,\n- $x_{1} + x_{2} + x_{3} \\le 1$.\n\n设初始椭球为\n$$\n\\mathcal{E}_{0} = \\{\\, x \\in \\mathbb{R}^{3} : (x - c_{0})^{\\mathsf{T}} P_{0}^{-1} (x - c_{0}) \\le 1 \\,\\},\n$$\n其中心为 $c_{0} = (1, 1, 1)^{\\mathsf{T}}$，形态矩阵为 $P_{0} = 4 I_{3}$，其中 $I_{3}$ 是 $3 \\times 3$ 的单位矩阵。你将运行两次经典的中心切割椭球法迭代，在每次迭代中使用被违背的不等式作为分离超平面。在每次迭代中，当在当前中心 $c$ 处发现一个被违背的不等式 $a^{\\mathsf{T}} x \\le b$ 时，使用中心切割 $a^{\\mathsf{T}} x \\le a^{\\mathsf{T}} c$ 来更新椭球。\n\n任务：\n1. 在迭代 1 中，在 $c_{0}$ 处识别一个被违背的约束，形成相应的中心切割，并计算下一个椭球 $\\mathcal{E}_{1}$ 的更新后的中心 $c_{1}$ 和形态矩阵 $P_{1}$。请明确展示你的中间计算过程。\n2. 在迭代 2 中，重复相同的过程：使用 $c_{1}$ 和 $P_{1}$，在 $c_{1}$ 处识别一个被违背的约束，形成中心切割，并计算 $\\mathcal{E}_{2}$ 的更新后的中心 $c_{2}$ 和形态矩阵 $P_{2}$。\n3. 在每次迭代后，仅使用中心切割的定义和集合包含推理来证明真实可行域仍然包含在更新后的椭球中。\n4. 最后，计算比值 $\\det(P_{2}) / \\det(P_{0})$ 的精确值。以单个精确表达式的形式提供你的最终答案。不要四舍五入。",
            "solution": "该问题是有效的，因为它是优化理论中椭球法的一个明确定义的应用，其设定自洽且一致。初始椭球保证包含可行域，这是该方法的必要前提条件。\n\n问题设定在维度 $n=3$ 的空间中。可行域 $S$ 由以下线性不等式定义：\n$$S = \\{ x \\in \\mathbb{R}^{3} \\mid x_1 \\ge 0, x_2 \\ge 0, x_3 \\ge 0, x_1+x_2+x_3 \\le 1 \\}$$\n这些可以写成矩阵形式 $a_i^{\\mathsf{T}}x \\le b_i$：\n1. $-x_1 \\le 0$\n2. $-x_2 \\le 0$\n3. $-x_3 \\le 0$\n4. $x_1+x_2+x_3 \\le 1$\n\n初始椭球为 $\\mathcal{E}_0 = \\{ x \\in \\mathbb{R}^{3} : (x - c_0)^{\\mathsf{T}} P_0^{-1} (x - c_0) \\le 1 \\}$，其中心为 $c_0 = (1, 1, 1)^{\\mathsf{T}}$，形态矩阵为 $P_0 = 4I_3 = \\begin{pmatrix} 4  0  0 \\\\ 0  4  0 \\\\ 0  0  4 \\end{pmatrix}$。\n\n对于维度 $n=3$ 的中心切割椭球法的更新公式如下：\n下一个中心 $c_{k+1}$ 由下式给出：\n$$c_{k+1} = c_k - \\frac{1}{n+1} \\frac{P_k g_k}{\\sqrt{g_k^{\\mathsf{T}} P_k g_k}} = c_k - \\frac{1}{4} \\frac{P_k g_k}{\\sqrt{g_k^{\\mathsf{T}} P_k g_k}}$$\n下一个形态矩阵 $P_{k+1}$ 由下式给出：\n$$P_{k+1} = \\frac{n^2}{n^2-1} \\left( P_k - \\frac{2}{n+1} \\frac{(P_k g_k)(P_k g_k)^{\\mathsf{T}}}{g_k^{\\mathsf{T}} P_k g_k} \\right) = \\frac{9}{8} \\left( P_k - \\frac{1}{2} \\frac{(P_k g_k)(P_k g_k)^{\\mathsf{T}}}{g_k^{\\mathsf{T}} P_k g_k} \\right)$$\n其中 $g_k$ 是被违背约束 $a^{\\mathsf{T}}x \\le b$ 的法向量，因此 $g_k=a$。\n\n**任务1：迭代 1**\n\n首先，我们检查中心 $c_0 = (1, 1, 1)^{\\mathsf{T}}$ 违背了哪个约束。\n1. $-x_1 \\le 0 \\implies -1 \\le 0$. (满足)\n2. $-x_2 \\le 0 \\implies -1 \\le 0$. (满足)\n3. $-x_3 \\le 0 \\implies -1 \\le 0$. (满足)\n4. $x_1+x_2+x_3 \\le 1 \\implies 1+1+1 = 3 \\le 1$. (违背)\n\n被违背的约束是 $x_1+x_2+x_3 \\le 1$。法向量为 $g_0 = (1, 1, 1)^{\\mathsf{T}}$。\n现在我们计算更新所需的各项。\n$$P_0 g_0 = (4I_3) g_0 = 4g_0 = \\begin{pmatrix} 4 \\\\ 4 \\\\ 4 \\end{pmatrix}$$\n$$g_0^{\\mathsf{T}} P_0 g_0 = g_0^{\\mathsf{T}} (4g_0) = 4 (g_0^{\\mathsf{T}} g_0) = 4(1^2+1^2+1^2) = 12$$\n$$\\sqrt{g_0^{\\mathsf{T}} P_0 g_0} = \\sqrt{12} = 2\\sqrt{3}$$\n\n现在，我们计算更新后的中心 $c_1$：\n$$c_1 = c_0 - \\frac{1}{4} \\frac{P_0 g_0}{\\sqrt{g_0^{\\mathsf{T}} P_0 g_0}} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{1}{4} \\frac{\\begin{pmatrix} 4 \\\\ 4 \\\\ 4 \\end{pmatrix}}{2\\sqrt{3}} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{1}{2\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\left(1 - \\frac{\\sqrt{3}}{6}\\right) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$\n所以，$c_1 = \\left( \\frac{6-\\sqrt{3}}{6}, \\frac{6-\\sqrt{3}}{6}, \\frac{6-\\sqrt{3}}{6} \\right)^{\\mathsf{T}}$。\n\n接下来，我们计算更新后的形态矩阵 $P_1$：\n$$(P_0 g_0)(P_0 g_0)^{\\mathsf{T}} = \\begin{pmatrix} 4 \\\\ 4 \\\\ 4 \\end{pmatrix} \\begin{pmatrix} 4  4  4 \\end{pmatrix} = 16 \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}$$\n$$P_1 = \\frac{9}{8} \\left( 4I_3 - \\frac{1}{2} \\frac{16 \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}}{12} \\right) = \\frac{9}{8} \\left( 4I_3 - \\frac{2}{3} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} \\right)$$\n$$P_1 = \\frac{9}{8} \\begin{pmatrix} 4-\\frac{2}{3}  -\\frac{2}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  4-\\frac{2}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  -\\frac{2}{3}  4-\\frac{2}{3} \\end{pmatrix} = \\frac{9}{8} \\begin{pmatrix} \\frac{10}{3}  -\\frac{2}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  \\frac{10}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  -\\frac{2}{3}  \\frac{10}{3} \\end{pmatrix} = \\frac{9}{8} \\frac{2}{3} \\begin{pmatrix} 5  -1  -1 \\\\ -1  5  -1 \\\\ -1  -1  5 \\end{pmatrix}$$\n$$P_1 = \\frac{3}{4} \\begin{pmatrix} 5  -1  -1 \\\\ -1  5  -1 \\\\ -1  -1  5 \\end{pmatrix}$$\n\n**任务2：迭代 2**\n\n我们检查 $c_1 = (\\alpha, \\alpha, \\alpha)^{\\mathsf{T}}$ 违背了哪个约束，其中 $\\alpha = 1 - \\frac{\\sqrt{3}}{6}$。\n因为 $\\sqrt{3}  6$，所以我们有 $\\alpha > 0$。前三个约束 $-x_i \\le 0$ 被满足，因为 $-\\alpha  0$。\n对于第四个约束：\n$$x_1+x_2+x_3 = 3\\alpha = 3\\left(1 - \\frac{\\sqrt{3}}{6}\\right) = 3 - \\frac{\\sqrt{3}}{2}$$\n我们检查是否 $3 - \\frac{\\sqrt{3}}{2} \\le 1$。这等价于 $2 \\le \\frac{\\sqrt{3}}{2}$，或 $4 \\le \\sqrt{3}$，这是错误的，因为 $16 \\le 3$ 是错误的。因此，约束 $x_1+x_2+x_3 \\le 1$ 被违背。\n法向量为 $g_1 = (1, 1, 1)^{\\mathsf{T}}$。\n我们计算更新所需的各项：\n$$P_1 g_1 = \\frac{3}{4} \\begin{pmatrix} 5  -1  -1 \\\\ -1  5  -1 \\\\ -1  -1  5 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{3}{4} \\begin{pmatrix} 3 \\\\ 3 \\\\ 3 \\end{pmatrix} = \\frac{9}{4} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$\n$$g_1^{\\mathsf{T}} P_1 g_1 = g_1^{\\mathsf{T}} (P_1 g_1) = \\begin{pmatrix} 1  1  1 \\end{pmatrix} \\frac{9}{4} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{9}{4}(1+1+1) = \\frac{27}{4}$$\n$$\\sqrt{g_1^{\\mathsf{T}} P_1 g_1} = \\sqrt{\\frac{27}{4}} = \\frac{3\\sqrt{3}}{2}$$\n\n现在，我们计算更新后的中心 $c_2$：\n$$c_2 = c_1 - \\frac{1}{4} \\frac{P_1 g_1}{\\sqrt{g_1^{\\mathsf{T}} P_1 g_1}} = \\left(1 - \\frac{\\sqrt{3}}{6}\\right)\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{1}{4} \\frac{\\frac{9}{4}\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}}{\\frac{3\\sqrt{3}}{2}}$$\n$$ \\frac{\\frac{9}{4}}{\\frac{3\\sqrt{3}}{2}} = \\frac{9}{4} \\cdot \\frac{2}{3\\sqrt{3}} = \\frac{3}{2\\sqrt{3}} = \\frac{\\sqrt{3}}{2} $$\n$$c_2 = \\left(1 - \\frac{\\sqrt{3}}{6}\\right)\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{1}{4} \\left(\\frac{\\sqrt{3}}{2}\\right) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\left(1 - \\frac{\\sqrt{3}}{6} - \\frac{\\sqrt{3}}{8}\\right) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$\n$$c_2 = \\left(1 - \\left(\\frac{4\\sqrt{3}+3\\sqrt{3}}{24}\\right)\\right) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\left(1 - \\frac{7\\sqrt{3}}{24}\\right) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}$$\n\n最后，我们计算更新后的形态矩阵 $P_2$：\n$$(P_1 g_1)(P_1 g_1)^{\\mathsf{T}} = \\left(\\frac{9}{4}\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}\\right) \\left(\\frac{9}{4}\\begin{pmatrix} 1  1  1 \\end{pmatrix}\\right) = \\frac{81}{16} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}$$\n$$P_2 = \\frac{9}{8} \\left( P_1 - \\frac{1}{2} \\frac{\\frac{81}{16} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}}{\\frac{27}{4}} \\right) = \\frac{9}{8} \\left( P_1 - \\frac{1}{2} \\left(\\frac{3}{4}\\right) \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} \\right)$$\n$$P_2 = \\frac{9}{8} \\left( \\frac{3}{4} \\begin{pmatrix} 5  -1  -1 \\\\ -1  5  -1 \\\\ -1  -1  5 \\end{pmatrix} - \\frac{3}{8} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} \\right)$$\n$$P_2 = \\frac{9}{8} \\frac{3}{8} \\left( 2 \\begin{pmatrix} 5  -1  -1 \\\\ -1  5  -1 \\\\ -1  -1  5 \\end{pmatrix} - \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} \\right) = \\frac{27}{64} \\begin{pmatrix} 9  -3  -3 \\\\ -3  9  -3 \\\\ -3  -3  9 \\end{pmatrix}$$\n$$P_2 = \\frac{81}{64} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}$$\n\n**任务3：可行域包含性的证明**\n\n设 $S$ 为可行域，$\\mathcal{E}_k$ 为第 $k$ 次迭代时的椭球。根据假设，有 $S \\subseteq \\mathcal{E}_0$。椭球法对于所有 $k \\ge 0$ 都保持不变量 $S \\subseteq \\mathcal{E}_k$。\n在第 $k$ 次迭代时，我们有一个中心 $c_k$ 和一个椭球 $\\mathcal{E}_k$，使得 $S \\subseteq \\mathcal{E}_k$。如果 $c_k \\notin S$，则会找到一个被违背的约束 $a^{\\mathsf{T}}x \\le b$，这意味着 $a^{\\mathsf{T}}c_k  b$。\n对于可行域 $S$ 中的任意点 $x$，它必须满足这个约束，因此有 $a^{\\mathsf{T}}x \\le b$。\n综合这些，我们得到对于所有 $x \\in S$ 都有 $a^{\\mathsf{T}}x \\le b  a^{\\mathsf{T}}c_k$。这意味着整个可行域 $S$ 位于半空间 $\\{x \\in \\mathbb{R}^n : a^{\\mathsf{T}}x \\le a^{\\mathsf{T}}c_k \\}$ 中。\n下一个椭球 $\\mathcal{E}_{k+1}$ 被构造为包含半椭球 $\\mathcal{E}_k' = \\mathcal{E}_k \\cap \\{x \\in \\mathbb{R}^n : a^{\\mathsf{T}}x \\le a^{\\mathsf{T}}c_k \\}$。\n因为 $S \\subseteq \\mathcal{E}_k$ 并且 $S$ 也位于切割半空间中，所以我们有 $S \\subseteq \\mathcal{E}_k'$。\n根据该方法的构造，有 $\\mathcal{E}_k' \\subseteq \\mathcal{E}_{k+1}$。\n因此，根据集合包含的传递性，有 $S \\subseteq \\mathcal{E}_{k+1}$。\n这个逻辑对两次迭代（$k=0$ 和 $k=1$）都成立，从而确保可行域保持在更新后的椭球 $\\mathcal{E}_1$ 和 $\\mathcal{E}_2$ 之内。\n\n**任务4：行列式之比**\n\n对于 $n$ 维空间中的中心切割，连续形态矩阵的行列式之比由以下公式给出：\n$$\\frac{\\det(P_{k+1})}{\\det(P_k)} = \\left(\\frac{n}{n+1}\\right)^2 \\left(\\frac{n^2}{n^2-1}\\right)^{n-1}$$\n对于 $n=3$，该比值为：\n$$\\frac{\\det(P_{k+1})}{\\det(P_k)} = \\left(\\frac{3}{4}\\right)^2 \\left(\\frac{3^2}{3^2-1}\\right)^{3-1} = \\frac{9}{16} \\left(\\frac{9}{8}\\right)^2 = \\frac{9}{16} \\frac{81}{64} = \\frac{729}{1024}$$\n由于两个步骤都使用中心切割，因此每次迭代的这个比值是恒定的。我们需要求出比值 $\\frac{\\det(P_2)}{\\det(P_0)}$。\n$$\\frac{\\det(P_2)}{\\det(P_0)} = \\frac{\\det(P_2)}{\\det(P_1)} \\cdot \\frac{\\det(P_1)}{\\det(P_0)}$$\n由于两次迭代的比值都是 $\\frac{729}{1024}$，我们有：\n$$\\frac{\\det(P_2)}{\\det(P_0)} = \\left( \\frac{729}{1024} \\right)^2 = \\frac{729^2}{1024^2} = \\frac{531441}{1048576}$$\n这也可以用素数分解来表示：$729 = 3^6$ 和 $1024 = 2^{10}$。\n$$\\frac{\\det(P_2)}{\\det(P_0)} = \\left( \\frac{3^6}{2^{10}} \\right)^2 = \\frac{3^{12}}{2^{20}}$$\n我们也可以从我们计算出的矩阵直接验证这一点。\n$\\det(P_0) = \\det(4I_3) = 4^3=64$。\n$\\det(P_2) = \\det\\left(\\frac{81}{64} \\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}\\right) = \\left(\\frac{81}{64}\\right)^3 \\det\\begin{pmatrix} 3  -1  -1 \\\\ -1  3  -1 \\\\ -1  -1  3 \\end{pmatrix}$。\n该矩阵的行列式为 $3(9-1) - (-1)(-3-1) + (-1)(1+3) = 24 - 4 - 4 = 16$。\n$\\det(P_2) = \\left(\\frac{81}{64}\\right)^3 \\cdot 16 = \\frac{(3^4)^3}{(2^6)^3} \\cdot 2^4 = \\frac{3^{12}}{2^{18}} \\cdot 2^4 = \\frac{3^{12}}{2^{14}}$。\n该比值为 $\\frac{\\det(P_2)}{\\det(P_0)} = \\frac{3^{12}/2^{14}}{64} = \\frac{3^{12}/2^{14}}{2^6} = \\frac{3^{12}}{2^{20}}$。\n精确表达式为 $\\frac{531441}{1048576}$。",
            "answer": "$$\\boxed{\\frac{531441}{1048576}}$$"
        },
        {
            "introduction": "椭球法的威力远不止于求解线性问题，它可以应用于任何存在“分离预言机”的凸可行性问题。本练习  探讨了如何为一个由二次不等式定义的凸集找到一个分离超平面。这个实践突出了分离预言机的关键作用，并将椭球法与更广泛的凸分析原理（如利用梯度构造支撑超平面）联系起来。",
            "id": "3125337",
            "problem": "考虑在 $\\mathbb{R}^{2}$ 中将椭球法应用于一个可行性问题，其中可行域是由二次约束 $x^{\\top} Q x \\leq 1$ 定义的凸集。设对称正定矩阵为\n$$\nQ = \\begin{pmatrix}\n2  1 \\\\\n1  3\n\\end{pmatrix},\n$$\n并假设当前查询点为 $c = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$，该点被发现违反了约束。\n\n从凸可微函数的基本定义和凸性的一阶特征（通过梯度和次梯度不等式得到的支撑超平面）出发，推导在 $c$ 点处对可行集的一个有效分离半空间。具体来说：\n- 将 $f(x) = x^{\\top} Q x - 1$ 视为定义约束边界的凸函数。\n- 使用基本原理得到形式为 $g^{\\top} x \\leq \\beta$ 的切割，该切割将可行域与点 $c$ 分开，其中 $g$ 是从在 $c$ 点的梯度导出的切割法向量。\n- 对于给定的 $Q$ 和 $c$，计算 $g$ 和 $\\beta$ 的具体值。\n\n将切割法向量的分量和标量界 $\\beta$ 一起以单个行向量 $\\begin{pmatrix} g_{1}  g_{2}  \\beta \\end{pmatrix}$ 的形式报告。无需四舍五入。",
            "solution": "我们从约束 $x^{\\top} Q x \\leq 1$ 开始，并定义函数\n$$\nf(x) = x^{\\top} Q x - 1.\n$$\n因为 $Q$ 是对称正定矩阵，所以二次型 $x^{\\top} Q x$ 是严格凸的。因此，$f(x)$ 是一个凸可微函数，其梯度处处存在。凸可微函数的基本一阶特征表明，对于任意 $x, y \\in \\mathbb{R}^{n}$，\n$$\nf(y) \\geq f(x) + \\nabla f(x)^{\\top} (y - x).\n$$\n对于任意可行点 $y$（即，任何满足 $f(y) \\leq 0$ 的 $y$），代入 $x = c$ 得到\n$$\n0 \\geq f(y) \\geq f(c) + \\nabla f(c)^{\\top} (y - c).\n$$\n整理可得分离不等式\n$$\n\\nabla f(c)^{\\top} y \\leq \\nabla f(c)^{\\top} c - f(c).\n$$\n因此，可行集的一个有效分离半空间是\n$$\ng^{\\top} x \\leq \\beta \\quad \\text{其中} \\quad g = \\nabla f(c), \\quad \\beta = g^{\\top} c - f(c).\n$$\n\n我们现在计算 $\\nabla f(x)$。由于 $f(x) = x^{\\top} Q x - 1$ 且 $Q$ 是对称的，\n$$\n\\nabla f(x) = (Q + Q^{\\top}) x = 2 Q x.\n$$\n在 $c = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 处求值，\n$$\nQ c = \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n= \\begin{pmatrix} 2 \\cdot 1 + 1 \\cdot 1 \\\\ 1 \\cdot 1 + 3 \\cdot 1 \\end{pmatrix}\n= \\begin{pmatrix} 3 \\\\ 4 \\end{pmatrix}.\n$$\n因此，\n$$\ng = \\nabla f(c) = 2 Q c = 2 \\begin{pmatrix} 3 \\\\ 4 \\end{pmatrix} = \\begin{pmatrix} 6 \\\\ 8 \\end{pmatrix}.\n$$\n\n接下来，计算 $f(c)$：\n$$\nf(c) = c^{\\top} Q c - 1 = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - 1.\n$$\n首先，计算 $Q c = \\begin{pmatrix} 3 \\\\ 4 \\end{pmatrix}$，然后\n$$\nc^{\\top} Q c = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 4 \\end{pmatrix} = 1 \\cdot 3 + 1 \\cdot 4 = 7,\n$$\n所以\n$$\nf(c) = 7 - 1 = 6.\n$$\n\n最后，计算 $\\beta$：\n$$\n\\beta = g^{\\top} c - f(c) = \\begin{pmatrix} 6  8 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - 6 = (6 \\cdot 1 + 8 \\cdot 1) - 6 = 14 - 6 = 8.\n$$\n\n因此，分离半空间是\n$$\n\\begin{pmatrix} 6  8 \\end{pmatrix}^{\\top} x \\leq 8,\n$$\n所要求的切割参数行向量是\n$$\n\\begin{pmatrix} 6  8  8 \\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 6  8  8 \\end{pmatrix}}$$"
        },
        {
            "introduction": "从计算角度看，在每一步迭代中都重新求逆形态矩阵 $P_k$ 的成本是极其高昂的。本练习  聚焦于解决这一问题的关键技术：用于高效更新逆矩阵的 Sherman-Morrison 公式。通过在数值上实现并验证该公式，你将掌握使椭球法在计算上变得可行的核心技巧。",
            "id": "3125367",
            "problem": "考虑对称正定（Symmetric Positive-Definite, SPD）椭球形状矩阵在椭球法中的作用。在更新过程中，经常需要计算该矩阵的逆，并且自然会出现秩一变化。您需要实现一个关于秩一逆更新的数值测试，并通过与直接求逆进行比较来验证其正确性。请使用以下基本原理：矩阵逆的定义，即对于可逆矩阵 $P$，存在一个矩阵 $P^{-1}$ 满足 $P P^{-1} = I$；以及矩阵乘积的逆的法则，即对于可逆矩阵 $A$ 和 $B$，$ (A B)^{-1} = B^{-1} A^{-1}$。不假设任何其他恒等式。\n\n任务：给定一个基矩阵 $P$、一个向量 $u$ 和一个标量 $\\alpha$，定义秩一更新后的矩阵 $P_{\\text{new}} = P + \\alpha \\, u u^{\\top}$。实现一个函数，该函数在给定 $P^{-1}$、$u$ 和 $\\alpha$ 的情况下，通过使用从第一性原理推导出的秩一逆更新来计算 $P_{\\text{new}}^{-1}$，而不是重新计算完整的逆。通过将您更新后的逆与通过对 $P_{\\text{new}}$求逆得到的直接逆进行比较，来数值验证其正确性。\n\n对于下方的每个测试用例：\n- 计算 $P_{\\text{new}} = P + \\alpha \\, u u^{\\top}$。\n- 通过直接对 $P$ 求逆来计算 $P^{-1}$。\n- 使用您的秩一更新从 $P^{-1}$ 获得一个近似值 $\\widehat{P_{\\text{new}}^{-1}}$，而不直接对 $P_{\\text{new}}$ 求逆。\n- 通过对 $P_{\\text{new}}$ 求逆来计算直接逆 $P_{\\text{new}}^{-1}$。\n- 设偏差为最大逐元素绝对差 $$\\Delta = \\max_{i,j} \\left| \\left(\\widehat{P_{\\text{new}}^{-1}} - P_{\\text{new}}^{-1}\\right)_{i j} \\right|.$$\n- 如果 $\\Delta \\le \\text{tol}$，则产生布尔结果 `True`，否则为 `False`，其中 $\\text{tol}$ 是为每个用例指定的容差。\n\n测试套件：\n- 用例 1（一般 SPD，中等程度更新）：\n  - $P = \\begin{bmatrix}\n  3.045  -0.105  0.165 \\\\\n  -0.105  2.245  -0.385 \\\\\n  0.165  -0.385  1.605\n  \\end{bmatrix}$,\n  - $u = \\begin{bmatrix} 0.5 \\\\ -0.2 \\\\ 0.3 \\end{bmatrix}$,\n  - $\\alpha = 0.7$,\n  - $\\text{tol} = 10^{-12}$.\n- 用例 2（一般 SPD，极小更新）：\n  - $P = \\begin{bmatrix}\n  2.108  -0.072  0.144  -0.126 \\\\\n  -0.072  2.548  -0.096  0.084 \\\\\n  0.144  -0.096  3.192  -0.168 \\\\\n  -0.126  0.084  -0.168  1.647\n  \\end{bmatrix}$,\n  - $u = \\begin{bmatrix} 0.2 \\\\ 0.1 \\\\ -0.5 \\\\ 0.3 \\end{bmatrix}$,\n  - $\\alpha = 10^{-9}$,\n  - $\\text{tol} = 10^{-12}$.\n- 用例 3（分母接近奇异的边缘情况，但仍可逆）：\n  - $P = \\begin{bmatrix}\n  1.018  0.012  -0.024  0.030  -0.006 \\\\\n  0.012  1.208  -0.016  0.020  -0.004 \\\\\n  -0.024  -0.016  1.432  -0.040  0.008 \\\\\n  0.030  0.020  -0.040  1.650  -0.010 \\\\\n  -0.006  -0.004  0.008  -0.010  1.802\n  \\end{bmatrix}$,\n  - $u = \\begin{bmatrix} 0.9 \\\\ -0.1 \\\\ 0.05 \\\\ 0.2 \\\\ -0.3 \\end{bmatrix}$,\n  - 首先计算 $P^{-1}$，然后设置 $\\alpha = -\\dfrac{1}{u^{\\top} P^{-1} u} + \\varepsilon$，其中 $\\varepsilon = 10^{-6}$，来定义 $\\alpha$。\n  - $\\text{tol} = 10^{-8}$.\n- 用例 4（一般 SPD，安全量级的负更新）：\n  - $P = \\begin{bmatrix}\n  5.016  0.020  -0.024 \\\\\n  0.020  4.025  -0.030 \\\\\n  -0.024  -0.030  3.036\n  \\end{bmatrix}$,\n  - $u = \\begin{bmatrix} 1.0 \\\\ -0.8 \\\\ 0.3 \\end{bmatrix}$,\n  - $\\alpha = -0.2$,\n  - $\\text{tol} = 10^{-12}$.\n\n实现和输出要求：\n- 您的程序必须是一个完整的、可运行的程序，它能完全按照规定构建上述测试用例，执行计算，并进行数值正确性验证。\n- 对于每个测试用例，计算上述的布尔结果。\n- 您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，如果四个布尔结果都为真，则输出必须是 `[True,True,True,True]`。",
            "solution": "此任务旨在验证 Sherman-Morrison 公式的矩阵秩一更新的有效性。该公式对于椭球法等算法的效率至关重要，在这些算法中，定义椭球形状的矩阵在每次迭代中都会被更新。\n\n## 秩一逆更新公式的推导\n\n问题要求从第一性原理推导秩一更新矩阵 $P_{\\text{new}} = P + \\alpha \\, u u^{\\top}$ 的逆，给定可逆矩阵 $P$、其逆 $P^{-1}$、向量 $u$ 和标量 $\\alpha$。允许使用的第一性原理是矩阵逆的定义 $A A^{-1} = I$（其中 $I$ 是单位矩阵），以及乘积的逆的法则 $(AB)^{-1} = B^{-1}A^{-1}$。\n\n我们将通过验证所提出的逆满足定义 $P_{\\text{new}} P_{\\text{new}}^{-1} = I$ 来确定 Sherman-Morrison 公式的正确性。该公式表述为：\n$$ P_{\\text{new}}^{-1} = (P + \\alpha u u^{\\top})^{-1} = P^{-1} - \\frac{\\alpha P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} $$\n此公式有效的前提是分母非零，即 $1 + \\alpha u^{\\top} P^{-1} u \\neq 0$。\n\n为了验证这一点，我们计算 $P_{\\text{new}}$ 与其建议的逆的乘积：\n$$ (P + \\alpha u u^{\\top}) \\left( P^{-1} - \\frac{\\alpha P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} \\right) $$\n\n使用分配律逐项展开此乘积，得到：\n$$ = P \\left( P^{-1} - \\frac{\\alpha P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} \\right) + \\alpha u u^{\\top} \\left( P^{-1} - \\frac{\\alpha P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} \\right) $$\n$$ = (P P^{-1}) - \\frac{\\alpha (P P^{-1}) u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} + (\\alpha u u^{\\top} P^{-1}) - \\frac{\\alpha^2 u u^{\\top} P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} $$\n\n使用恒等式 $P P^{-1} = I$，表达式简化为：\n$$ = I - \\frac{\\alpha I u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} + \\alpha u u^{\\top} P^{-1} - \\frac{\\alpha^2 u u^{\\top} P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} $$\n项 $I u$ 简化为 $u$：\n$$ = I - \\frac{\\alpha u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} + \\alpha u u^{\\top} P^{-1} - \\frac{\\alpha^2 u u^{\\top} P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} $$\n\n我们认识到 $u^{\\top} P^{-1} u$ 是一个标量值。我们用 $\\beta = u^{\\top} P^{-1} u$ 来表示这个标量。项 $u u^{\\top} P^{-1} u u^{\\top} P^{-1}$ 可以利用矩阵乘法的结合律重新排列为 $u (u^{\\top} P^{-1} u) u^{\\top} P^{-1} = u (\\beta) u^{\\top} P^{-1} = \\beta (u u^{\\top} P^{-1})$。将 $\\beta$ 代入主表达式中，得到：\n$$ = I - \\frac{\\alpha u u^{\\top} P^{-1}}{1 + \\alpha \\beta} + \\alpha u u^{\\top} P^{-1} - \\frac{\\alpha^2 \\beta u u^{\\top} P^{-1}}{1 + \\alpha \\beta} $$\n\n我们可以提出公共矩阵项 $u u^{\\top} P^{-1}$：\n$$ = I + \\left( \\alpha - \\frac{\\alpha}{1 + \\alpha \\beta} - \\frac{\\alpha^2 \\beta}{1 + \\alpha \\beta} \\right) u u^{\\top} P^{-1} $$\n\n现在，我们通过通分来简化括号中的标量系数：\n$$ \\alpha - \\frac{\\alpha + \\alpha^2 \\beta}{1 + \\alpha \\beta} = \\alpha - \\frac{\\alpha (1 + \\alpha \\beta)}{1 + \\alpha \\beta} $$\n假设 $1 + \\alpha \\beta \\neq 0$，则分数简化为 $\\alpha$，整个标量系数变为：\n$$ \\alpha - \\alpha = 0 $$\n\n将此结果代回乘积的表达式中：\n$$ = I + (0) u u^{\\top} P^{-1} = I $$\n\n我们已经证明了 $(P + \\alpha u u^{\\top}) \\left( P^{-1} - \\frac{\\alpha P^{-1} u u^{\\top} P^{-1}}{1 + \\alpha u^{\\top} P^{-1} u} \\right) = I$。此验证证明了 Sherman-Morrison 公式的正确性，且推导过程遵循了指定的第一性原理。\n\n## 算法实现与验证\n\n数值测试根据问题规范实现。对每个测试用例执行以下步骤：\n1. 定义基矩阵 $P$、向量 $u$ 和标量 $\\alpha$。对于用例 3，$\\alpha$ 通过编程计算为 $\\alpha = -\\frac{1}{u^{\\top} P^{-1} u} + \\varepsilon$，其中 $\\varepsilon = 10^{-6}$，从而为更新公式的分母创造一个接近奇异的条件，以测试其数值稳定性。\n2. 通过直接求逆（`numpy.linalg.inv`）计算初始逆 $P^{-1}$。\n3. 构建秩一更新矩阵 $P_{\\text{new}} = P + \\alpha u u^{\\top}$。\n4. 使用上面推导的 Sherman-Morrison 公式计算更新矩阵的逆 $\\widehat{P_{\\text{new}}^{-1}}$。分子可以高效地计算为向量的外积，即 $\\alpha (P^{-1}u)(u^{\\top}P^{-1})$。由于 $P$ 是对称的，所以 $P^{-1}$ 也是对称的，因此这等价于 $\\alpha \\, (P^{-1}u)(P^{-1}u)^{\\top}$。\n5. 通过对 $P_{\\text{new}}$ 求逆来计算直接逆 $P_{\\text{new}}^{-1}$。这作为比较的基准真相。\n6. 计算偏差 $\\Delta = \\max_{i,j} \\left| \\left(\\widehat{P_{\\text{new}}^{-1}} - P_{\\text{new}}^{-1}\\right)_{i j} \\right|$。\n7. 确定布尔值 $\\Delta \\le \\text{tol}$ 并存储。\n\n在各种测试用例中（包括标准更新、微小扰动、近奇异条件和负更新）的成功验证，展示了 Sherman-Morrison 公式的数值鲁棒性和正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rank_one_inverse_update(P_inv, u, alpha):\n    \"\"\"\n    Computes the inverse of (P + alpha * u * u.T) using the Sherman-Morrison formula.\n\n    Args:\n        P_inv (np.ndarray): The inverse of the original matrix P.\n        u (np.ndarray): The update vector.\n        alpha (float): The update scalar.\n\n    Returns:\n        np.ndarray: The inverse of the updated matrix.\n    \"\"\"\n    # Ensure u is a column vector for matrix operations\n    u_col = u.reshape(-1, 1)\n\n    # Compute the vector P_inv @ u, which is used in both numerator and denominator\n    P_inv_u = P_inv @ u_col\n\n    # Denominator of the update term: 1 + alpha * u.T @ P_inv @ u\n    # Note: u.T @ P_inv @ u is a scalar\n    denominator = 1.0 + alpha * (u_col.T @ P_inv_u)[0, 0]\n\n    # Handle the case where the denominator is close to zero, which means\n    # the updated matrix is singular or near-singular.\n    if np.abs(denominator)  1e-20:\n        raise ValueError(\"Denominator in Sherman-Morrison formula is near zero.\")\n\n    # Numerator of the update term: alpha * (P_inv @ u) @ (u.T @ P_inv)\n    # This is an outer product. Since P is symmetric, P_inv is also symmetric,\n    # so (u.T @ P_inv) is the transpose of (P_inv @ u).\n    # The term is alpha * (P_inv @ u) @ (P_inv @ u).T\n    numerator_matrix = alpha * (P_inv_u @ P_inv_u.T)\n\n    # Apply the Sherman-Morrison formula\n    P_new_inv = P_inv - numerator_matrix / denominator\n\n    return P_new_inv\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the rank-one inverse update.\n    \"\"\"\n    # Case 1 (general SPD, moderate update)\n    P1 = np.array([\n        [3.045, -0.105, 0.165],\n        [-0.105, 2.245, -0.385],\n        [0.165, -0.385, 1.605]\n    ])\n    u1 = np.array([0.5, -0.2, 0.3])\n    alpha1 = 0.7\n    tol1 = 1e-12\n\n    # Case 2 (general SPD, very small update)\n    P2 = np.array([\n        [2.108, -0.072, 0.144, -0.126],\n        [-0.072, 2.548, -0.096, 0.084],\n        [0.144, -0.096, 3.192, -0.168],\n        [-0.126, 0.084, -0.168, 1.647]\n    ])\n    u2 = np.array([0.2, 0.1, -0.5, 0.3])\n    alpha2 = 1e-9\n    tol2 = 1e-12\n\n    # Case 3 (near-singular denominator edge)\n    P3 = np.array([\n        [1.018, 0.012, -0.024, 0.030, -0.006],\n        [0.012, 1.208, -0.016, 0.020, -0.004],\n        [-0.024, -0.016, 1.432, -0.040, 0.008],\n        [0.030, 0.020, -0.040, 1.650, -0.010],\n        [-0.006, -0.004, 0.008, -0.010, 1.802]\n    ])\n    u3 = np.array([0.9, -0.1, 0.05, 0.2, -0.3])\n    P3_inv = np.linalg.inv(P3)\n    u3_T_P3_inv_u3 = u3.T @ P3_inv @ u3\n    epsilon3 = 1e-6\n    alpha3 = -1.0 / u3_T_P3_inv_u3 + epsilon3\n    tol3 = 1e-8\n\n    # Case 4 (general SPD, negative update)\n    P4 = np.array([\n        [5.016, 0.020, -0.024],\n        [0.020, 4.025, -0.030],\n        [-0.024, -0.030, 3.036]\n    ])\n    u4 = np.array([1.0, -0.8, 0.3])\n    alpha4 = -0.2\n    tol4 = 1e-12\n    \n    test_cases = [\n        (P1, u1, alpha1, tol1),\n        (P2, u2, alpha2, tol2),\n        (P3, u3, alpha3, tol3),\n        (P4, u4, alpha4, tol4),\n    ]\n\n    results = []\n    for P, u, alpha, tol in test_cases:\n        # Step 1: Compute P_new = P + alpha * u * u.T\n        P_new = P + alpha * np.outer(u, u)\n\n        # Step 2: Compute P_inv by directly inverting P\n        P_inv = np.linalg.inv(P)\n\n        # Step 3: Use rank-one update to obtain P_new_inv_hat\n        P_new_inv_hat = rank_one_inverse_update(P_inv, u, alpha)\n\n        # Step 4: Compute direct inverse of P_new for verification\n        P_new_inv_direct = np.linalg.inv(P_new)\n\n        # Step 5: Compute the discrepancy\n        discrepancy = np.max(np.abs(P_new_inv_hat - P_new_inv_direct))\n        \n        # Step 6: Check against tolerance and record result\n        results.append(discrepancy = tol)\n\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\nsolve()\n```"
        }
    ]
}