{
    "hands_on_practices": [
        {
            "introduction": "本实践模拟了一个真实场景：工程师需要通过观察内存模块的行为来确定其核心时序参数。通过测量行命中和行未命中时的延迟，我们可以推导出诸如 $CL$ 和 $t_{RCD}$ 等基本值。这项练习可以加深我们对这些抽象参数如何体现为具体性能特征的理解。",
            "id": "3684083",
            "problem": "一项实验室性能分析工作旨在通过观察读取事务的第一个数据节拍延迟，来校准双倍数据速率同步动态随机存取存储器（DDR SDRAM）通道的命令时序参数。在此设置中，对已打开行（行命中）的读取仅需发出一个 READ 命令，而对已关闭行（行未命中）的读取则需要在发出 READ 命令之前，先发出一个 ACTIVATE 命令来打开该行。假设时序环境如下：只有一个未完成的读取请求，命令总线每个时钟周期可以接受一个命令，没有附加延迟，且总线在其他时间处于空闲状态，因此没有总线转换或存储体冲突。命令和数据都注册到同一个同步时钟；所有延迟均以时钟周期为单位进行测量。\n\n第一个数据节拍延迟定义为从内存控制器为服务该读取而发出所需的最早命令（对于行未命中是 ACTIVATE，对于行命中是 READ）的时钟周期，到第一个数据节拍出现在数据总线上的时钟周期数。\n\n以下量值是同步动态随机存取存储器（SDRAM）的标准时序参数：\n- 列地址选通延迟（$CL$），从 READ 命令到第一个数据节拍的延迟。\n- 行至列延迟（$t_{RCD}$），从 ACTIVATE 命令到可以对该行发出 READ 命令的最小延迟。\n- 突发长度（$BL$），一次突发读取返回的数据节拍数；第一个数据节拍延迟只关心到第一个节拍的时间，而不关心突发传输的完成。\n\n在突发长度 $BL=8$ 的校准运行中，您观察到以下第一个数据节拍延迟：\n- 行未命中时的第一个数据节拍延迟 $T = 14$ 个时钟周期。\n- 行命中时的第一个数据节拍延迟 $H = 10$ 个时钟周期。\n\n仅使用上述定义，求解 $CL$ 和 $t_{RCD}$ 的值（以时钟周期为单位）。然后，通过考虑在 $BL=4$ 下的第二次运行来验证第一个数据节拍延迟与 $BL$ 的无关性：预测在 $BL=4$ 时的行命中和行未命中的第一个数据节拍延迟（以时钟周期为单位），并根据定义解释它们是否与 $BL=8$ 的情况有所不同。请用时钟周期表示 $CL$ 和 $t_{RCD}$ 的最终值。无需四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于计算机内存架构的原理，问题提出得当，数据充分且一致，并以客观、正式的语言表述。我们可以进行正式的求解。\n\n该问题要求基于观察到的行命中和行未命中时的第一个数据节拍延迟，来确定两个基本的同步动态随机存取存储器（SDRAM）时序参数：列地址选通延迟（$CL$）和行至列延迟（$t_{RCD}$）。\n\n让我们首先根据所提供的定义，将观察到的延迟与时序参数之间的关系形式化。所有延迟都以时钟周期为单位测量。\n\n1.  **行命中延迟（$H$）**：对一个已打开行的读取被称为行命中。该过程涉及发出单个 READ 命令。行命中的第一个数据节拍延迟 $H$ 定义为从发出 READ 命令到第一个数据节拍出现在数据总线上的时钟周期数。根据定义，此延迟即为列地址选通延迟 $CL$。\n    $$H = CL$$\n    鉴于观察到的行命中延迟为 $H = 10$ 个时钟周期，我们可以直接确定 $CL$：\n    $$CL = 10$$\n\n2.  **行未命中延迟（$T$）**：对一个已关闭行的读取是行未命中。这需要两个顺序命令：一个 ACTIVATE 命令以打开行，随后一个 READ 命令以选择该行内的列。\n    -   行未命中的第一个数据节拍延迟 $T$ 是从发出第一个必要命令（ACTIVATE）的周期开始测量的。我们将 ACTIVATE 发出的周期记为周期 $0$。\n    -   行至列延迟 $t_{RCD}$ 是从 ACTIVATE 命令到可以对同一行发出 READ 命令的最小延迟。因此，READ 命令不能在周期 $t_{RCD}$ 之前发出。问题陈述命令总线每个周期可以接受一个命令，并且在其他时间是空闲的。由于总线约束，READ 命令最早可以在周期 $1$ 发出；由于时序约束，它必须在周期 $t_{RCD}$ 或之后发出。因此，READ 命令在周期 $\\max(1, t_{RCD})$ 发出。由于物理 DRAM 时序总是满足 $t_{RCD} > 1$，所以 READ 命令在周期 $t_{RCD}$ 发出。\n    -   一旦 READ 命令在周期 $t_{RCD}$ 发出，还需要额外的 $CL$ 个周期，第一个数据节拍才会出现。\n    -   因此，数据在周期 $t_{RCD} + CL$ 出现。\n    -   总延迟 $T$（从周期 $0$ 开始测量）是这两个延迟的总和。\n    $$T = t_{RCD} + CL$$\n    鉴于观察到的行未命中延迟为 $T = 14$ 个时钟周期，并且我们已经求得 $CL = 10$，我们可以解出 $t_{RCD}$：\n    $$14 = t_{RCD} + 10$$\n    $$t_{RCD} = 14 - 10$$\n    $$t_{RCD} = 4$$\n    因此，时序参数为 $CL = 10$ 个时钟周期和 $t_{RCD} = 4$ 个时钟周期。\n\n3.  **与突发长度（$BL$）的无关性**：问题要求预测突发长度为 $BL=4$ 时的延迟，并解释与 $BL=8$ 的情况相比是否有任何变化。\n    -   参数 $CL$ 被定义为到*第一个数据节拍*的延迟。\n    -   参数 $t_{RCD}$ 是 ACTIVATE 和 READ 命令之间的延迟，它完全发生在数据传输之前。\n    -   对于行命中和行未命中，第一个数据节拍延迟根据定义只关心到*第一个*数据节拍到达的时间。我们推导出的表达式 $H = CL$ 和 $T = t_{RCD} + CL$ 只依赖于这两个参数。\n    -   突发长度（$BL$）决定了在支付了初始访问延迟*之后*连续传输的数据节拍数。例如，对于 $BL=8$ 的突发长度，会返回八个连续的数据节拍，通常从第一个节拍到达的周期开始，并持续几个后续周期（取决于数据总线宽度和时钟方案，例如，对于具有 8 节拍突发的 DDR，需要 4 个时钟周期）。将 $BL$ 更改为 4 意味着只返回四个节拍。\n    -   由于 $H$ 和 $T$ 的定义完全基于*第一个*数据节拍的到达，所以它们从根本上独立于突发中的总节拍数。\n    -   因此，将突发长度从 $BL=8$ 更改为 $BL=4$ 对第一个数据节拍延迟没有影响。在 $BL=4$ 时预测的延迟将与在 $BL=8$ 时观察到的延迟相同：\n        -   在 $BL=4$ 时预测的行命中延迟（$H'$）：$H' = CL = 10$ 个时钟周期。\n        -   在 $BL=4$ 时预测的行未命中延迟（$T'$）：$T' = t_{RCD} + CL = 4 + 10 = 14$ 个时钟周期。\n\n所请求参数的最终值为 $CL = 10$ 个时钟周期和 $t_{RCD} = 4$ 个时钟周期。",
            "answer": "$$\\boxed{\\begin{pmatrix} 10  4 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在我们理解了单个时序参数的基础上，这项练习将挑战我们扮演内存控制器的角色。给定一个命令序列和一套完整的时序规则，我们的任务是找出所有违规之处并正确地调度命令，这正是真实内存控制器调度器的核心功能。这个谜题般的问题能让我们深入理解内存操作之间错综复杂的依赖关系。",
            "id": "3684049",
            "problem": "一个内存控制器针对一个同步动态随机存取存储器 (SDRAM) 设备，并发出了一系列针对每个存储体的命令。该控制器必须遵守由标准的命令间最小间隔定义的每个存储体的时序约束。对于单个存储体，需要强制执行的主要约束如下：\n\n- 行至列延迟 (tRCD)：在对同一存储体发出 ACTIVATE (ACT) 命令和随后的 READ 命令之间，必须经过至少 $t_{RCD}$ 个时钟周期。\n- 行有效时间 (tRAS)：在对同一存储体发出 ACTIVATE (ACT) 命令和随后的 PRECHARGE (PRE) 命令之间，必须经过至少 $t_{RAS}$ 个时钟周期。\n- 行预充电时间 (tRP)：在对同一存储体发出 PRECHARGE (PRE) 命令和随后的 ACTIVATE (ACT) 命令之间，必须经过至少 $t_{RP}$ 个时钟周期。\n- 行周期时间 (tRC)：在对同一存储体发出的连续 ACTIVATE (ACT) 命令之间，必须经过至少 $t_{RC}$ 个时钟周期。\n- 读至预充电 (tRTP)：在对同一存储体发出 READ 命令和随后的 PRECHARGE (PRE) 命令之间，必须经过至少 $t_{RTP}$ 个时钟周期。\n\n其他相关参数包括列地址选通 (CAS) 延迟 (CL) 和突发长度 (BL)。你可以假设读至预充电约束 $t_{RTP}$ 包含了与读取流水线相关的必要限制，并且一旦 $t_{RTP}$ 和 $t_{RAS}$ 都得到满足，就允许进行显式预充电。可以根据需要插入空操作 (NOP) 周期，但必须保留原始的命令顺序。\n\n考虑单个存储体 $B0$，其具有以下时序参数，均以时钟周期表示：$t_{RCD}=3$，$t_{RAS}=6$，$t_{RP}=3$，$t_{RC}=9$，$t_{RTP}=2$，$CL=3$，$BL=4$。控制器在指定的时钟周期（周期索引从 $0$ 开始）发出以下命令序列：\n\n- 周期 $0$：ACT $B0$\n- 周期 $2$：READ $B0$\n- 周期 $5$：PRE $B0$\n- 周期 $7$：ACT $B0$\n- 周期 $9$：READ $B0$\n- 周期 $12$：PRE $B0$\n\n哪个选项正确地指出了上述时序安排中所有被违反的时序约束，并提供了最早的修正后的周期数（不重新排序，仅插入最少的必要空闲周期），以使该序列相对于所有陈述的约束都合法？\n\nA. 违规项：周期 $2$ 处的 $t_{RCD}$，周期 $5$ 处的 $t_{RAS}$，周期 $7$ 处的 $t_{RP}$。最早的修正：将周期 $2$ 的 READ 移至周期 $3$，将周期 $5$ 的 PRE 移至周期 $6$，将周期 $7$ 的 ACT 移至周期 $8$；保持周期 $9$ 的 READ 和周期 $12$ 的 PRE 不变。\n\nB. 违规项：周期 $2$ 和 $9$ 处的 $t_{RCD}$，周期 $5$ 和 $12$ 处的 $t_{RAS}$，周期 $7$ 处的 $t_{RP}$ 和 $t_{RC}$。最早的修正：将周期 $2$ 的 READ 移至周期 $3$，将周期 $5$ 的 PRE 移至周期 $6$，将周期 $7$ 的 ACT 移至周期 $9$，将周期 $9$ 的 READ 移至周期 $12$，并将周期 $12$ 的 PRE 移至周期 $15$。\n\nC. 违规项：仅周期 $5$ 和 $12$ 处的 $t_{RTP}$。最早的修正：将周期 $5$ 的 PRE 移至周期 $6$，将周期 $12$ 的 PRE 移至周期 $11$；所有其他命令保持不变。\n\nD. 违规项：仅周期 $7$ 处的 $t_{RC}$。最早的修正：将周期 $7$ 的 ACT 移至周期 $9$；保持所有其他命令的时间不变。\n\nE. 违规项：周期 $2$ 和 $9$ 处的 $t_{RCD}$，周期 $5$ 和 $12$ 处的 $t_{RAS}$，周期 $7$ 处的 $t_{RP}$ 和 $t_{RC}$。使用数据突发完成作为门控条件的修正：将周期 $2$ 的 READ 移至周期 $3$，将周期 $5$ 的 PRE 移至周期 $10$，将周期 $7$ 的 ACT 移至周期 $13$，将周期 $9$ 的 READ 移至周期 $16$，并将周期 $12$ 的 PRE 移至周期 $22$。",
            "solution": "从核心的 SDRAM 每存储体时序定义开始：\n\n- 在对一个给定的存储体发出 ACTIVATE 后，必须经过至少 $t_{RCD}$ 个时钟周期才能对该存储体发出 READ。\n- 在对一个给定的存储体发出 ACTIVATE 后，必须经过至少 $t_{RAS}$ 个时钟周期才能对该存储体发出 PRECHARGE。\n- 在对一个给定的存储体发出 PRECHARGE 后，必须经过至少 $t_{RP}$ 个时钟周期才能对该存储体发出下一个 ACTIVATE。\n- 对同一存储体的两个 ACTIVATE 命令之间，必须经过至少 $t_{RC}$ 个时钟周期。\n- 在对一个给定的存储体发出 READ 后，必须经过至少 $t_{RTP}$ 个时钟周期才能对该存储体发出 PRECHARGE。\n\n所有参数都是针对每个存储体的，并以时钟周期为单位：$t_{RCD}=3$，$t_{RAS}=6$，$t_{RP}=3$，$t_{RC}=9$，$t_{RTP}=2$，为完整起见，还提供了 $CL=3$ 和 $BL=4$。我们被允许插入空闲周期 (NOP)，但不能重新排序命令。\n\n逐步评估给定的时序安排：\n\n- 周期 $0$：ACT $B0$。这在周期 $0$ 打开一个行。\n\n- 周期 $2$：READ $B0$。检查 $t_{RCD}$：周期 $0$ 的 ACT 要求 READ 不早于周期 $0 + t_{RCD} = 0 + 3 = 3$。在周期 $2$ 发出违反了 $t_{RCD}$。因此，最早的合法 READ 是在周期 $3$。\n\n- 周期 $5$：PRE $B0$。适用两个检查：\n  1) ACT 和 PRE 之间的 $t_{RAS}$：PRE 不得早于周期 $0 + t_{RAS} = 0 + 6 = 6$。在周期 $5$ 发出违反了 $t_{RAS}$。\n  2) READ 和 PRE 之间的 $t_{RTP}$：如果 READ (按要求) 移至周期 $3$，则 PRE 不得早于周期 $3 + t_{RTP} = 3 + 2 = 5$。结合两者，PRE 必须同时满足这两个约束，所以最早的合法 PRE 是在 $\\max(6,5) = 6$。因此，由于 $t_{RAS}$ 的原因，在周期 $5$ 发出是非法的。\n\n- 周期 $7$：ACT $B0$。对下一个 ACT 适用两个检查：\n  1) 来自前一个 PRE 的 $t_{RP}$：在 PRE 修正到周期 $6$ 的情况下，下一个 ACT 不得早于周期 $6 + t_{RP} = 6 + 3 = 9$。在周期 $7$ 发出违反了 $t_{RP}$。\n  2) 来自前一个 ACT 的 $t_{RC}$：下一个 ACT 不得早于周期 $0 + t_{RC} = 0 + 9 = 9$。在周期 $7$ 发出也违反了 $t_{RC}$。因此，最早的合法 ACT 是在周期 $9$。\n\n- 周期 $9$：READ $B0$。在 ACT 修正到周期 $9$ 的情况下，检查 $t_{RCD}$：READ 不得早于周期 $9 + t_{RCD} = 9 + 3 = 12$。在周期 $9$ 发出违反了 $t_{RCD}$。最早的合法 READ 是在周期 $12$。\n\n- 周期 $12$：PRE $B0$。适用两个检查：\n  1) 来自周期 $9$ 的第二个 ACT 的 $t_{RAS}$：PRE 不得早于周期 $9 + t_{RAS} = 9 + 6 = 15$。\n  2) 来自周期 $12$ 的第二个 READ 的 $t_{RTP}$：PRE 不得早于周期 $12 + t_{RTP} = 12 + 2 = 14$。\nPRE 必须同时满足两者，因此最早的合法 PRE 是在 $\\max(15,14) = 15$。在周期 $12$ 发出违反了 $t_{RAS}$。\n\n原始时序安排中的违规项总结：\n- 周期 $2$ 的 READ 和周期 $9$ 的 READ 违反了 $t_{RCD}$。\n- 周期 $5$ 的 PRE 和周期 $12$ 的 PRE 违反了 $t_{RAS}$。\n- 周期 $7$ 的 ACT 违反了 $t_{RP}$ 和 $t_{RC}$。\n\n保留顺序并仅插入必要空闲周期的最早修正时序安排：\n- ACT 在周期 $0$（不变）。\n- READ 在周期 $3$（满足 $t_{RCD}$ 的最早时间）。\n- PRE 在周期 $6$（同时满足 $t_{RAS}$ 和 $t_{RTP}$ 的最早时间）。\n- ACT 在周期 $9$（同时满足 $t_{RP}$ 和 $t_{RC}$ 的最早时间）。\n- READ 在周期 $12$（满足 $t_{RCD}$ 的最早时间）。\n- PRE 在周期 $15$（同时满足 $t_{RAS}$ 和 $t_{RTP}$ 的最早时间）。\n\n注意，$CL=3$ 和 $BL=4$ 意味着第一次读取的数据从周期 $3+3=6$ 开始返回，持续 $4$ 个周期（周期 $6$ 到 $9$），这与只要满足 $t_{RTP}$ 和 $t_{RAS}$ 就允许在周期 $6$ 进行 PRE 是一致的；问题陈述规定，一旦 $t_{RTP}$ 和 $t_{RAS}$ 都被满足，就允许进行显式预充电。\n\n逐个选项分析：\n\n- 选项 A：只列出了周期 $2$ 的 $t_{RCD}$、周期 $5$ 的 $t_{RAS}$ 和周期 $7$ 的 $t_{RP}$ 违规，遗漏了周期 $7$ 的 $t_{RC}$ 违规、周期 $9$ 的第二次 $t_{RCD}$ 违规以及周期 $12$ 的 $t_{RAS}$ 违规。其提议的周期 $8$ 的 ACT 也违反了 $t_{RC}$ 和 $t_{RP}$，并且将 READ 留在周期 $9$ 会相对于修正后的 ACT 违反 $t_{RCD}$。不正确。\n\n- 选项 B：指出了所有违规项（周期 $2$ 和 $9$ 的 $t_{RCD}$，周期 $5$ 和 $12$ 的 $t_{RAS}$，以及周期 $7$ 的 $t_{RP}$ 和 $t_{RC}$），并给出了最早的修正周期：READ 在 $3$，PRE 在 $6$，ACT 在 $9$，READ 在 $12$，PRE 在 $15$。正确。\n\n- 选项 C：声称对于 PRE 命令只有 $t_{RTP}$ 违规。这是不正确的，因为原始周期 $5$ 的 PRE 已经满足了来自原始周期 $2$ 的 READ 的 $t_{RTP}$（差值 $3 \\ge 2$），并且原始周期 $12$ 的 PRE 满足了来自周期 $9$ 的 READ 的 $t_{RTP}$（差值 $3 \\ge 2$）。此外，它忽略了 $t_{RCD}$、$t_{RAS}$、$t_{RP}$ 和 $t_{RC}$ 的违规。不正确。\n\n- 选项 D：声称仅在周期 $7$ 存在 $t_{RC}$ 违规，并提议将 ACT 移至周期 $9$，同时保持其他命令不变。这忽略了周期 $2$ 的初始 $t_{RCD}$ 违规、周期 $5$ 的 $t_{RAS}$ 违规，并且仍然会使周期 $9$ 的 READ 相对于周期 $9$ 的 ACT 违反 $t_{RCD}$，并使周期 $12$ 的 PRE 违反 $t_{RAS}$。不正确。\n\n- 选项 E：正确列出了所有违规项，但提出了一个非最小化的修正时序安排，因为它额外等待数据突发完成作为 PRE 的门控条件（例如，将 PRE 移至周期 $10$）。问题要求的是最早的修正周期数；因此，即使其约束是保守的，这个选项也是不可接受的。不正确。\n\n因此，正确的选项是既能识别所有违规项，又能提供最早的合法修正的选项，即选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在掌握了命令级时序之后，我们现在将分析尺度扩展到系统级别。本实践专注于计算最大可持续数据吞吐率，即带宽。我们将学习如何识别作为性能瓶颈的具体时序约束——无论是数据总线速度还是命令发出速率，这是性能调优的一项关键技能。",
            "id": "3684048",
            "problem": "一个单通道双倍数据速率同步动态随机存取存储器 (DDR SDRAM) 子系统，其内存时钟频率为 $f_{\\text{clk}} = 800\\,\\text{MHz}$，数据总线宽度为 $64\\,\\text{bits}$。该设备使用固定的突发长度 $BL = 8$。命令/地址总线在每个内存时钟周期最多可以发出一条命令。在一个长的、稳态的流式传输区间内，内存控制器只发出读 (READ) 命令，并且目标是每个都已有一行打开的存储体，因此在此区间内不会发出激活 (ACT) 或预充电 (PRE) 命令。在发出 READ 命令之前适用的所有时序约束，即行到列延迟 $t_{RCD} = 11$ 个周期和行预充电时间 $t_{RP} = 11$ 个周期，都已在流式传输区间开始前被满足。列到列命令间隔为 $t_{CCD} = 6$ 个周期，列地址选通 (CAS) 延迟为 $CL = 11$ 个周期。没有刷新或写操作发生，并且有足够多的独立存储体，可以在仅受所述约束限制的情况下保持数据总线繁忙。\n\n从双倍数据速率信号传输（每个内存时钟周期两次数据传输）和同步动态随机存取存储器 (SDRAM) 中突发传输的基本定义出发，并仅使用上述给定的约束条件，确定在此流式传输区间内的最大可持续数据吞吐率。以千兆字节/秒 (GB/s) 为单位表示您的最终答案，其中 $1\\,\\text{GB} = 10^9\\,\\text{bytes}$，并将您的答案四舍五入到四位有效数字。此外，请在 $t_{RCD}$、$t_{RP}$、$t_{CCD}$、$CL$ 和每周期一命令的命令总线速率这些约束中，确定在给定配置下，哪一个单一约束从根本上限制了此吞吐率（请在您的推理中说明）。",
            "solution": "该问题要求计算在特定稳态条件下，一个双倍数据速率同步动态随机存取存储器 (DDR SDRAM) 子系统的最大可持续数据吞吐率，并识别出主要的性能限制约束。\n\n经过验证，该问题被认为具有科学依据、良定、客观且自洽。所有提供的参数都是内存子系统分析中的标准参数，并且落在实际范围内。所描述的场景——对已打开行的稳定读取操作流——是评估峰值内存带宽的经典案例。因此，可以推导出一个严谨的解决方案。\n\n数据吞吐率 $R$ 的基本定义是单位时间 $T$ 内传输的数据量 $D$：\n$$R = \\frac{D}{T}$$\n\n我们首先确定单次内存操作中传输的数据量。指定的操作是 `READ` 命令，它会启动一次突发传输。数据总线宽度为 $W = 64\\,\\text{bits}$，相当于 $8\\,\\text{bytes}$。突发长度为 $BL = 8$。长度为 $BL$ 的突发对应于 $BL$ 次连续的数据传输，每次传输一个等于总线宽度的数据单元。因此，每次突发传输的总数据量为：\n$$D_{\\text{burst}} = W \\times BL = (64\\,\\text{bits}) \\times 8 = 512\\,\\text{bits}$$\n使用 $8\\,\\text{bits} = 1\\,\\text{byte}$ 这一恒等式，将其转换为字节：\n$$D_{\\text{burst}} = \\frac{512\\,\\text{bits}}{8\\,\\text{bits/byte}} = 64\\,\\text{bytes}$$\n\n接下来，我们必须确定连续 `READ` 命令启动之间的最小时间间隔 $T_{\\text{period}}$。对于这种特定的访问模式，该周期由系统中最严格的时序约束决定。我们分析潜在的限制因素。\n\n1.  **数据总线占用**：DDR SDRAM 的内存时钟频率为 $f_{\\text{clk}} = 800\\,\\text{MHz}$。“双倍数据速率”这一名称表示每个内存时钟周期发生两次数据传输。长度为 $BL = 8$ 的突发涉及 8 次传输。因此，单次突发传输数据所占用的数据总线时间 $T_{\\text{bus\\_busy}}$ 为：\n    $$T_{\\text{bus\\_busy}} = \\frac{BL}{2} \\text{ cycles} = \\frac{8}{2} \\text{ cycles} = 4 \\text{ cycles}$$\n    为了实现数据总线的最大利用率，需要每 $4$ 个时钟周期启动一次新的突发。这为 `READ` 命令之间的时间间隔建立了一个潜在的下限。\n\n2.  **命令发出约束**：问题提供了几个与命令相关的时序参数。\n    *   命令/地址总线每个时钟周期可以发出一条命令。这是命令总线的物理限制，允许每 $1$ 个周期发出一条新命令。\n    *   列到列命令间隔为 $t_{CCD} = 6$ 个周期。此约束指定了两个列访问命令（如 `READ`）之间必须经过的最小时间。这意味着新 `READ` 命令最多每 $6$ 个时钟周期才能发出一次。\n    *   CAS 延迟 $CL = 11$ 个周期，是从发出 `READ` 命令到总线上出现第一份数据之间的延迟。在流水线的、稳态的读操作流中，延迟会影响填充流水线的初始延迟，但不会限制后续命令发出的速率。因此，$CL$ 不限制可持续吞吐率。\n    *   时序参数 $t_{RCD}$ 和 $t_{RP}$ 与行激活和预充电有关。问题陈述，流式传输区间只涉及对已打开行的 `READ` 命令，并明确指出不发出 `ACT` 和 `PRE` 命令，且它们之前的约束已满足。因此，$t_{RCD}$ 和 $t_{RP}$ 与此稳态吞吐率计算无关。\n\n比较命令发出速率的约束，1个周期的总线物理限制比 $t_{CCD} = 6$ 个周期的要求限制性要小。因此，由于命令总线的限制，`READ` 命令之间的有效最小时间是 $6$ 个周期。\n\n为了找到连续突发开始之间的实际时间周期 $T_{\\text{period}}$，我们必须取数据总线完成其传输所需的时间和命令总线发出下一个命令所需的时间中的最大值。\n$$T_{\\text{period\\_in\\_cycles}} = \\max\\left(\\frac{BL}{2}, t_{CCD}\\right)$$\n代入给定值：\n$$T_{\\text{period\\_in\\_cycles}} = \\max(4, 6) = 6 \\text{ cycles}$$\n\n这个结果表明，系统受限于命令时序，而非数据总线。由于 $t_{CCD}$ 约束，新的 `READ` 命令只能每 $6$ 个时钟周期发出一次，尽管数据总线在仅 $4$ 个周期后就已空闲。这意味着在每次突发传输之间，数据总线将空闲 $6 - 4 = 2$ 个周期。因此，在此配置中从根本上限制吞吐率的单一约束是列到列命令间隔 $t_{CCD}$。\n\n现在我们可以计算最大可持续吞吐率。该周期的时间长度为：\n$$T_{\\text{period}} = T_{\\text{period\\_in\\_cycles}} \\times T_{\\text{clk}} = \\frac{T_{\\text{period\\_in\\_cycles}}}{f_{\\text{clk}}} = \\frac{6}{800 \\times 10^6\\,\\text{s}}$$\n吞吐率 $R$ 是每次突发的数据量除以该周期：\n$$R = \\frac{D_{\\text{burst}}}{T_{\\text{period}}} = \\frac{64\\,\\text{bytes}}{6 / (800 \\times 10^6\\,\\text{s}^{-1})} = \\frac{64 \\times 800 \\times 10^6}{6} \\,\\text{B/s}$$\n$$R = \\frac{51200 \\times 10^6}{6} \\,\\text{B/s} = \\frac{51.2 \\times 10^9}{6} \\,\\text{B/s}$$\n问题要求以千兆字节/秒 ($\\text{GB/s}$) 为单位给出答案，其中 $1\\,\\text{GB} = 10^9\\,\\text{bytes}$。\n$$R = \\frac{51.2}{6} \\,\\text{GB/s} \\approx 8.5333... \\,\\text{GB/s}$$\n将结果四舍五入到四位有效数字，得到：\n$$R \\approx 8.533 \\,\\text{GB/s}$$",
            "answer": "$$\\boxed{8.533}$$"
        }
    ]
}