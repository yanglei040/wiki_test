{
    "hands_on_practices": [
        {
            "introduction": "缓存虽然速度快，但其性能可能会因为“冲突未命中”而急剧下降，即常用数据项竞争同一缓存位置。本练习将让你亲身体验，一个看似无害的内存布局如何为直接映射缓存制造出最坏情况。通过分析这个病态案例，你将对数据布局如何影响缓存性能有更深的直觉，并学会一种基本的缓解冲突的技术。",
            "id": "3684789",
            "problem": "一个字节可寻址系统使用直接映射缓存，其总容量为 $C$ 字节，块大小为 $B$ 字节，其中 $C$ 是 $B$ 的整数倍。令缓存行数量为 $L = \\frac{C}{B}$。两个数组 $A$ 和 $D$ 各占用 $C$ 字节，在主存中的布局如下：$A$ 的基地址为 $A_{\\mathrm{base}} = 0$，$D$ 的基地址为 $D_{\\mathrm{base}} = C$。每个数组每个元素存储一个字节，因此 $A$ 的第 $i$ 个元素的地址为 $A_{\\mathrm{base}} + i$，$D$ 的第 $i$ 个元素的地址为 $D_{\\mathrm{base}} + i$。考虑一种交替访问模式，对于所有 $i \\in \\{0, 1, \\dots, C-1\\}$，系统在读取 $A[i]$ 之后紧接着读取 $D[i]$。假设缓存初始为空。\n\n请仅使用直接映射索引的基本定义——即字节地址 $x$ 的缓存行索引由 $\\left\\lfloor \\frac{x}{B} \\right\\rfloor \\bmod L$ 给出——以及强制性未命中的概念，首先推理在给定布局下，上述交替访问模式所导致的缓存未命中总数。接下来，提出一种重新映射方案，通过仅将 $D$ 的基地址更改为 $D_{\\mathrm{base}}' = C + B$（即在 $A$ 和 $D$ 之间填充 $B$ 字节）来消除病态冲突，并在此同样的交替访问模式下重新分析未命中总数。\n\n由于这次重新映射，总未命中数的倍数缩减因子是多少？请用一个只含 $B$ 的闭式表达式表示。请将最终答案表示为单个符号表达式。无需四舍五入。",
            "solution": "让我们用 $C$ 字节表示缓存容量，用 $B$ 字节表示块大小，用 $L = \\frac{C}{B}$ 表示缓存行数。该系统是字节可寻址的，并且缓存是直接映射的。对于给定的字节地址 $x$，其缓存行索引由公式 $I(x) = \\left\\lfloor \\frac{x}{B} \\right\\rfloor \\pmod L$ 给出。\n\n首先，我们将分析初始内存布局下的缓存未命中总数，然后分析重新映射后布局下的情况。\n\n**情况 1：初始内存布局**\n\n在初始配置中，数组 $A$ 的基地址为 $A_{\\mathrm{base}} = 0$，数组 $D$ 的基地址为 $D_{\\mathrm{base}} = C$。每个数组的大小为 $C$ 字节。访问模式是从 $A$ 和 $D$ 中交替读取相应元素：对于所有 $i \\in \\{0, 1, \\dots, C-1\\}$，系统读取 $A[i]$ 后紧接着读取 $D[i]$。\n\n$A$ 的第 $i$ 个元素（记为 $A[i]$）的地址是 $x_A(i) = A_{\\mathrm{base}} + i = i$。\n此次访问的缓存行索引是：\n$$I_A(i) = \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\pmod L$$\n\n$D$ 的第 $i$ 个元素（记为 $D[i]$）的地址是 $x_D(i) = D_{\\mathrm{base}} + i = C + i$。\n由于 $C=LB$，此次访问的缓存行索引是：\n$$I_D(i) = \\left\\lfloor \\frac{C+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor \\frac{LB+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor L + \\frac{i}{B} \\right\\rfloor \\pmod L$$\n利用向下取整函数的性质 $\\lfloor n+y \\rfloor = n + \\lfloor y \\rfloor$（其中 $n$ 为整数）：\n$$I_D(i) = \\left( L + \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\right) \\pmod L$$\n由于 $L \\pmod L = 0$，上式可简化为：\n$$I_D(i) = \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\pmod L$$\n\n我们观察到，对于所有的 $i$，$I_A(i) = I_D(i)$。这意味着对于任何给定的 $i$，对 $A[i]$ 的访问和对 $D[i]$ 的访问都会映射到完全相同的缓存行。\n\n现在，考虑交替访问序列（读取 $A[i]$，读取 $D[i]$）。让我们追踪一个缓存行的状态。假设访问 $A[i]$ 发生。如果包含 $A[i]$ 的块不在缓存中，它将被取回，导致一次未命中。紧接着，访问 $D[i]$ 发生。由于 $D[i]$ 映射到相同的缓存行，并且它属于不同的内存块，因此必须取回它的块。这个操作会驱逐刚刚加载的用于 $A[i]$ 的块。这是一种冲突未命中。\n对于下一次迭代 $i+1$，访问 $A[i+1]$ 发生。如果 $A[i+1]$与 $A[i]$ 位于同一个块中，那么它的块已经不在缓存中了，因为它被对 $D[i]$ 的访问所驱逐。因此，这次对 $A[i+1]$ 的访问也是一次未命中。\n这种“乒乓”效应在整个循环中持续发生。对 $A$ 中某个元素的访问会加载一个块，该块立即被对 $D$ 中相应元素的访问所驱逐，然后又被下一次对 $A$ 的访问所驱逐，依此类推。\n\n因此，该序列中的每一次内存访问都会导致缓存未命中。循环从 $i=0$ 到 $C-1$ 运行，对于每个 $i$，都有两次访问（$A[i]$ 和 $D[i]$）。\n总访问次数为 $2 \\times C$。\n因此，在这种初始配置中，未命中总数 $M_1$ 为：\n$$M_1 = 2C$$\n\n**情况 2：重新映射后的内存布局**\n\n在重新映射的配置中，$A$ 的基地址保持为 $A_{\\mathrm{base}} = 0$，但 $D$ 的基地址更改为 $D_{\\mathrm{base}}' = C + B$。\n\n对 $A[i]$ 访问的缓存行索引保持不变：\n$$I_A(i) = \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\pmod L$$\n\n$D$ 的第 $i$ 个元素 $D[i]$ 的地址现在是 $x_D'(i) = D_{\\mathrm{base}}' + i = C + B + i$。\n此次访问的缓存行索引是：\n$$I_D'(i) = \\left\\lfloor \\frac{C+B+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor \\frac{LB+B+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor L + 1 + \\frac{i}{B} \\right\\rfloor \\pmod L$$\n$$I_D'(i) = \\left( L + 1 + \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\right) \\pmod L = \\left( 1 + \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\right) \\pmod L$$\n\n我们现在有 $I_D'(i) = (I_A(i) + 1) \\pmod L$。对相应元素 $A[i]$ 和 $D[i]$ 的访问现在映射到不同（相邻，在 $L-1$ 处环绕）的缓存行。这种重新映射消除了在第一种情况中观察到的病态冲突。\n\n让我们用这个新布局来分析未命中模式。我们可以按内存块对访问进行分组。循环变量 $i$ 的范围是从 $0$ 到 $C-1$。数组内的块索引可以定义为 $k = \\lfloor i/B \\rfloor$，其范围从 $k=0$ 到 $k = \\lfloor (C-1)/B \\rfloor = L-1$。\n\n对于每个块索引 $k \\in \\{0, 1, \\dots, L-1\\}$，循环遍历从 $kB$ 到 $(k+1)B-1$ 的 $i$。\n- 此范围内所有对 $A[i]$ 的访问都落在 $A$ 的第 $k$ 个块中。该块映射到缓存行 $I_A = k \\pmod L = k$。\n- 此范围内所有对 $D[i]$ 的访问都落在 $D$ 的第 $k$ 个块中（从数组结构而非内存的角度看）。该块映射到缓存行 $I_D' = (k+1) \\pmod L$。\n\n考虑给定块索引 $k$ 的访问：\n- 对 $A$ 的第 $k$ 个块的第一次访问（例如，在 $i=kB$ 时对 $A[kB]$ 的访问）将导致一次未命中，因为该块之前从未被访问过（或已被驱逐）。这可能是一次强制性未命中（如果缓存行为空或包含一个我们不再需要的块）或一次冲突未命中。这次未命中将 $A$ 的第 $k$ 个块带入缓存行 $k$。\n- 对 $A$ 的这个块的后续 $B-1$ 次访问（即 $A[kB+1], \\dots, A[(k+1)B-1]$）都将是命中，因为该块现在在缓存中。\n- 同样，对 $D$ 的第 $k$ 个块的第一次访问（例如，在 $i=kB$ 时对 $D[kB]$ 的访问）将导致一次未命中，将其带入缓存行 $(k+1) \\pmod L$。\n- 对 $D$ 的这个块的后续 $B-1$ 次访问都将是命中。\n\n对于从 $0$ 到 $L-1$ 的每个块索引 $k$，对于 $A$ 的相应块有一次未命中，对于 $D$ 的相应块也有一次未命中。这为 $L$ 次块迭代中的每一次带来了 2 次未命中。\n在重新映射配置中，未命中总数 $M_2$ 为：\n$$M_2 = 2 \\times L$$\n由于 $L=C/B$，我们可以将其写为 $M_2 = \\frac{2C}{B}$。\n\n**倍数缩减因子**\n\n问题要求计算总未命中数的倍数缩减因子。这是原始未命中数与新未命中数的比率。\n$$\\text{缩减因子} = \\frac{M_1}{M_2}$$\n代入 $M_1$ 和 $M_2$ 的表达式：\n$$\\text{缩减因子} = \\frac{2C}{2L} = \\frac{2C}{2C/B} = B$$\n倍数缩减因子是 $B$。此表达式按要求仅取决于 $B$。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "存储层次结构优化的最高境界是设计与缓存协同工作的算法，即所谓的“缓存感知编程”。本练习让你扮演性能工程师的角色，去优化经典的矩阵乘法算法。你的任务是确定最佳的“分块”大小，使得核心工作集能够完全装入L1缓存，从而最大化数据复用并显著减少内存访问延迟。",
            "id": "3684821",
            "problem": "一个矩阵乘法内核使用分块算法为大型方阵计算 $\\mathbf{C} \\leftarrow \\mathbf{C} + \\mathbf{A}\\mathbf{B}$。在分块版本中，内核重复地将来自 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的两个大小为 $b \\times b$ 的块相乘，并将结果累加到 $\\mathbf{C}$ 的一个 $b \\times b$ 的块中，同时将这三个块都保留在1级（L1）数据缓存中以最大化数据重用。假设如下：\n\n- L1数据缓存的容量为 $C = 192 \\,\\text{KiB}$。\n- 每个元素是一个大小为 $s = 8 \\,\\text{bytes}$ 的双精度浮点数。\n- 缓存使用写回（write-back）和写分配（write-allocate）策略，对于此计算，标签和元数据开销相对于 $C$ 可以忽略不计。\n- 您可以假设一个理想的全相联容量模型，使得三个 $b \\times b$ 的块要同时驻留，它们共同占用的空间不得超过可用容量 $C$。\n\n从存储层次结构的核心定义（容量以字节为单位，数据足迹计算为元素数量乘以元素大小）出发，确定最大的理论块大小 $b$，使得三个 $b \\times b$ 块的总足迹不超过 $C$。将最终的 $b$ 表示为一个实数，并将您的答案四舍五入到四位有效数字。最终数字中不要包含任何单位。",
            "solution": "这个问题的核心原则是，必须同时驻留在缓存中的数据的总内存足迹不能超过缓存的容量。问题指出，三个块——一个来自矩阵 $\\mathbf{A}$，一个来自 $\\mathbf{B}$，一个来自 $\\mathbf{C}$——必须驻留在L1数据缓存中。\n\n设 $b$ 为方形块（或瓦片）的维度。\n每个块有 $b \\times b = b^2$ 个元素。\n每个元素是一个双精度浮点数，大小为 $s = 8 \\,\\text{bytes}$。\n\n一个 $b \\times b$ 块的内存足迹，记为 $F_{tile}$，是元素数量乘以每个元素的大小：\n$$F_{tile} = b^2 \\cdot s$$\n\n分块算法要求同时在缓存中保留三个这样的块。因此，算法内循环所需的总内存足迹 $F_{total}$ 为：\n$$F_{total} = 3 \\cdot F_{tile} = 3 \\cdot b^2 \\cdot s$$\n\n这个总足迹不能超过L1数据缓存的容量 $C$。这给了我们主导不等式：\n$$3 \\cdot b^2 \\cdot s \\le C$$\n\n为了找到最大的理论块大小 $b$，我们求解足迹恰好等于容量的情况：\n$$3 \\cdot b^2 \\cdot s = C$$\n\n现在我们可以求解 $b$：\n$$b^2 = \\frac{C}{3s}$$\n$$b = \\sqrt{\\frac{C}{3s}}$$\n\n给定的值为 $C = 192 \\,\\text{KiB}$ 和 $s = 8 \\,\\text{bytes}$。\n首先，我们必须将缓存容量 $C$ 以字节为单位表示，以与元素大小 $s$ 保持一致。在计算机科学中，一千字节（KiB）定义为 $2^{10}$ 字节。\n$$C = 192 \\,\\text{KiB} = 192 \\times 2^{10} \\,\\text{bytes} = 192 \\times 1024 \\,\\text{bytes} = 196608 \\,\\text{bytes}$$\n\n现在，我们将 $C$ 和 $s$ 的数值代入 $b$ 的方程中：\n$$b = \\sqrt{\\frac{196608}{3 \\times 8}}$$\n$$b = \\sqrt{\\frac{196608}{24}}$$\n$$b = \\sqrt{8192}$$\n\n为了简化根式，我们可以将 $8192$ 表示为 $2$ 的幂。$8192 = 2^{13}$。\n$$b = \\sqrt{2^{13}} = \\sqrt{2^{12} \\times 2^1} = \\sqrt{(2^6)^2 \\times 2} = 2^6 \\sqrt{2} = 64\\sqrt{2}$$\n\n问题要求一个四舍五入到四位有效数字的实数。我们计算其数值：\n$$b = 64\\sqrt{2} \\approx 64 \\times 1.41421356... \\approx 90.509667...$$\n\n将此值四舍五入到四位有效数字得到：\n$$b \\approx 90.51$$\n这表示块大小的最大理论维度。虽然在实践中 $b$ 必须是整数（例如，$\\lfloor 90.51 \\rfloor = 90$），但问题明确要求用实数表示。",
            "answer": "$$\n\\boxed{90.51}\n$$"
        }
    ]
}