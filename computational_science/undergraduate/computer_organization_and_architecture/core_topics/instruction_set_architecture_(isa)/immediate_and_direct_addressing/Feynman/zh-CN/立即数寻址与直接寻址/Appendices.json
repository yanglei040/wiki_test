{
    "hands_on_practices": [
        {
            "introduction": "立即寻址虽然高效，但其表示能力受到指令中立即数字段宽度的严格限制。本练习将引导您探索一个核心问题：在一个指令集有限的假设性计算机上，哪些常数可以通过一个或多个立即数指令序列生成，而哪些常数因为超出表示范围而必须通过直接寻址从内存中加载。通过这个思想实验，您将深化对符号扩展、零扩展以及指令集设计背后权衡的理解。",
            "id": "3648996",
            "problem": "一个假设的精简指令集计算机的简化加载与算术子集使用两种操作数指定机制：立即数寻址和直接寻址。该机器拥有位宽为 $w=32$ 位的通用寄存器，采用二进制补码整数运算，并包含以下指令，这些指令接受一个嵌入在指令字中、位宽为 $k=8$ 位的立即数字段。\n\n定义和语义：\n- 立即数寻址：操作数是编码在指令中的常量。指令 $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}_8$ 将 $k=8$ 位字段 $\\mathrm{imm}_8$ 进行二进制补码符号扩展至 $w=32$ 位后的值写入寄存器 $r_d$。指令 $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}_8$ 计算 $r_d$ 与 $k=8$ 位字段 $\\mathrm{imm}_8$ 零扩展至 $w=32$ 位后的值的按位或，其结果只影响 $r_d$ 的低8位，高位保持不变。没有其他带立即数的指令可用。\n- 直接寻址：操作数位于内存中，其绝对地址编码在指令中。指令 $\\mathrm{LDRI}\\;r_d,\\; \\mathrm{addr}_{16}$ 将存储在绝对内存地址 $\\mathrm{addr}_{16}$ 处的 $w=32$ 位字加载到 $r_d$ 中。假设内存中有一个只读常量池，因此任何 $w=32$ 位的常量都可以放在那里，并在需要时通过直接寻址获取。\n\n你需要确定，对于具体的目标常量集合\n$$S=\\{-200,\\,-129,\\,-128,\\,-1,\\,0,\\,42,\\,100,\\,127,\\,128,\\,200,\\,255,\\,256,\\,300\\},$$\n哪些常量必须通过直接寻址加载（即，不能通过单条立即数寻址指令放入寄存器，也不能通过不访问内存的、给定带立即数指令的任何有限序列来生成）。除了对 $S$ 进行分类外，你的答案还必须正确陈述使用给定的 $k=8$ 立即数字段，哪些值是可合成的，哪些是不可合成的一般模式，并列出在可能的情况下避免直接寻址的合理变通方法。\n\n哪个选项是正确的？\n\nA. 唯一能被单个立即数直接表示的常量是 $c\\in[-128,127]$ 的那些值；除此之外，一个两条指令的变通方法通过先执行 $\\mathrm{MOVI}\\;r_d,\\,0$ 再执行 $\\mathrm{ORI}\\;r_d,\\,c$ 来精确覆盖 $c\\in[128,255]$ 的情况，因为从零开始的零扩展和按位或可以产生任何在[0, 255]范围内的非负数 $c$。所有其他的 $c$ 都需要直接寻址。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,256,\\,300\\}$ 必须通过直接寻址加载。\n\nB. 任何 $c\\in[0,65535]$ 的 $32$ 位常量都可以通过使用零扩展的两条指令序列在不访问内存的情况下构建，因此 $\\{128,\\,200,\\,255\\}$ 都不需要直接寻址，但 $c\\in\\{-200,\\,-129,\\,-128,\\,-1\\}$ 必须从内存中获取，因为负常量不能通过位运算从零构建。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,-128,\\,-1\\}$ 需要直接寻址；所有其他常量则不需要。\n\nC. 因为重复使用 $\\mathrm{ORI}$ 可以逐步将高位字节设置为任何期望的模式，所以集合 $S$ 中的每个常量都可以在不访问内存的情况下合成；如果允许足够多的立即数 $\\mathrm{ORI}$ 操作，就不需要直接寻址。\n\nD. 由于立即数只有 $k=8$ 位宽，任何绝对值超过 $255$ 的常量都必须从内存加载，但任何绝对值至多为 $255$ 的常量（包括所有 $|c|\\le 255$ 的负数）都由于符号扩展而可以在一条指令中直接表示。因此，在集合 $S$ 中，恰好 $\\{256,\\,300\\}$ 需要直接寻址；所有其他常量则不需要。",
            "solution": "### 步骤 1：提取已知条件\n问题陈述为一台假设的精简指令集计算机提供了以下定义和约束：\n-   寄存器位宽：$w=32$ 位。\n-   整数表示：二进制补码。\n-   立即数字段位宽：$k=8$ 位。\n-   指令 $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}_8$：将 $k=8$ 位立即数字段 $\\mathrm{imm}_8$ 进行 $w=32$ 位二进制补码符号扩展后的值写入寄存器 $r_d$。\n-   指令 $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}_8$：计算寄存器 $r_d$ 中的值与 $k=8$ 位立即数字段 $\\mathrm{imm}_8$ 进行 $w=32$ 位零扩展后的值的按位或。结果写回 $r_d$。问题陈述阐明这只影响 $r_d$ 的低8位，这是与一个零扩展的8位值进行或运算的直接结果。\n-   不存在其他带立即数的指令。\n-   指令 $\\mathrm{LDRI}\\;r_d,\\; \\mathrm{addr}_{16}$：从内存地址加载一个 $w=32$ 位的字到 $r_d$ 中。\n-   只读内存中有一个常量池，可用于通过 $\\mathrm{LDRI}$ 加载任何 $32$ 位常量。\n-   目标常量集合是 $S=\\{-200,\\,-129,\\,-128,\\,-1,\\,0,\\,42,\\,100,\\,127,\\,128,\\,200,\\,255,\\,256,\\,300\\}$。\n-   任务是识别出集合 $S$ 中的哪些常量不能仅通过 $\\mathrm{MOVI}$ 和 $\\mathrm{ORI}$ 指令的有限序列在寄存器中生成，从而需要从内存加载（直接寻址）。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述在计算机组成和体系结构的原理上具有科学依据。指令集、寻址模式（立即数、直接）、数据表示（二进制补码）和位运算（符号扩展、零扩展、按位或）等概念都是标准的。这些指令虽然经过简化，但定义明确，对于一个假设的机器来说是合理的。语义陈述精确。对于 $\\mathrm{ORI}$ 指令，“只影响低8位”这一术语是对与一个零扩展的8位值进行按位或运算效果的直接且正确的描述，因此是冗余的但并不矛盾。该问题是自包含的、客观的、且定义良好的，允许一个唯一的、可推导的解。未发现任何缺陷。\n\n### 步骤 3：结论与行动\n问题有效。现在推导解决方案。\n\n### 解的推导\n\n让我们确定所有仅使用 $\\mathrm{MOVI}$ 和 $\\mathrm{ORI}$ 指令可以合成的 $32$ 位整数常量的集合。如果一个常量可以是一系列这些指令执行后寄存器中的最终值，那么它就是可合成的。\n\n1.  **$\\mathrm{MOVI}$ 指令分析：**\n    指令 $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}_8$ 接受一个8位二进制补码立即数，并将其符号扩展到32位。\n    一个8位二进制补码整数的范围是从 $-2^{8-1}$ 到 $2^{8-1}-1$，即 $[-128, 127]$。\n    -   如果 $\\mathrm{imm}_8 \\in [0, 127]$，其符号位（第8位）为0。符号扩展会将 $r_d$ 的高24位填充为0。$r_d$ 中的值将等于 $\\mathrm{imm}_8$。\n    -   如果 $\\mathrm{imm}_8 \\in [-128, -1]$，其符号位为1。符号扩展会将 $r_d$ 的高24位填充为1。$r_d$ 中的值是相应的32位负数。\n    因此，一条单独的 $\\mathrm{MOVI}$ 指令可以生成任何整数常量 $c$，使得 $c \\in [-128, 127]$。\n\n2.  **$\\mathrm{ORI}$ 指令分析：**\n    指令 $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}_8$ 计算 $r_d \\leftarrow r_d \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}_8)$。字段 $\\mathrm{imm}_8$ 被零扩展意味着它被视为一个8位无符号值，可以表示从0到255的任何整数。$\\mathrm{ZEXT}_{32}(\\mathrm{imm}_8)$ 的结果是一个32位值，其中高24位全为0，低8位对应于 $\\mathrm{imm}_8$。\n\n3.  **指令序列分析：**\n    任何合成序列都必须以一条 $\\mathrm{MOVI}$ 指令开始以加载一个初始值，然后可以跟随任意数量的 $\\mathrm{ORI}$ 指令。由于按位或运算的结合律和幂等性，任何 $\\mathrm{ORI}$ 指令序列都等效于一条单独的 $\\mathrm{ORI}$ 指令，其立即数是所有原始立即数位的并集。\n    设一个可合成的常量为 $C$。它必须具有以下形式：\n    $$C = \\mathrm{SEXT}_{32}(\\mathrm{imm}_A) \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}_B)$$\n    其中 $\\mathrm{imm}_A$ 是一个8位二进制补码值（来自 $\\mathrm{MOVI}$），$\\mathrm{imm}_B$ 是一个有效的8位无符号值（来自一个或多个 $\\mathrm{ORI}$ 指令，$0 \\le \\mathrm{imm}_B \\le 255$）。\n\n    我们分析两种情况，基于 $\\mathrm{imm}_A$ 的符号。\n\n    **情况 1：合成非负常量。**\n    要合成一个非负常量，高位不能全为1。这要求初始的 $\\mathrm{MOVI}$ 使用一个非负立即数，即 $\\mathrm{imm}_A \\in [0, 127]$。\n    -   对于 $\\mathrm{imm}_A \\ge 0$，$\\mathrm{SEXT}_{32}(\\mathrm{imm}_A)$ 与 $\\mathrm{ZEXT}_{32}(\\mathrm{imm}_A)$ 相同。寄存器中的值 $S_A$ 在范围 $[0, 127]$ 内。其高24位为0。\n    -   随后的 $\\mathrm{ORI}$ 操作计算 $S_A \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}_B)$。值 $\\mathrm{ZEXT}_{32}(\\mathrm{imm}_B)$ 的高24位也为0。\n    -   因此，结果的高24位将为0。这意味着结果常量 $C$ 必须是非负的并且小于 $2^8=256$。实际上，小于 $2^8 + 2^8 - 1$... 等等，$\\mathrm{ORI}$ 只作用于低8位。高24位是0。那么结果数字被限制在范围 $[0, 2^8-1]$ 内吗？不完全是。该值为 $S_A \\lor V_B$，其中 $S_A \\in [0, 127]$ 且 $V_B \\in [0, 255]$。结果在 $[0, 255]$ 范围内。\n    -   我们能构成任何在 $[0, 255]$ 范围内的整数 $c$ 吗？\n        -   对于 $c \\in [0, 127]$，我们可以使用单条指令：$\\mathrm{MOVI}\\;r_d,\\; c$。\n        -   对于 $c \\in [128, 255]$，我们可以使用一个两条指令的序列：\n            1.  $\\mathrm{MOVI}\\;r_d,\\;0$。这将 $r_d$ 设置为0。\n            2.  $\\mathrm{ORI}\\;r_d,\\;c$。这将计算 $r_d \\leftarrow 0 \\lor c$，结果为 $c$。这是可能的，因为 $c$ 对于 $\\mathrm{ORI}$ 来说是一个有效的8位无符号立即数。\n    -   因此，整个整数范围 $[0, 255]$ 是可合成的。\n\n    **情况 2：合成负常量。**\n    要合成一个负常量，高位必须全为1。这要求初始的 $\\mathrm{MOVI}$ 使用一个负立即数，即 $\\mathrm{imm}_A \\in [-128, -1]$。\n    -   $\\mathrm{SEXT}_{32}(\\mathrm{imm}_A)$ 会得到一个值 $S_A$，其高24位全为1。设 $\\mathrm{imm}_A$ 的8位模式为 $P_A$。$S_A$ 是 $\\text{0xFFFFFF}P_A$。由于 $\\mathrm{imm}_A$ 是负数， $P_A$ 的最高有效位是1。所以 $P_A \\in [\\text{0x80}, \\text{0xFF}]$。\n    -   随后的 $\\mathrm{ORI}$ 操作计算 $S_A \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}_B)$。设 $\\mathrm{imm}_B$ 的8位模式为 $P_B$。计算出的值为 $C = (\\text{0xFFFFFF}P_A) \\lor (\\text{0x000000}P_B) = \\text{0xFFFFFF}(P_A \\lor P_B)$。\n    -   由于 $P_A$ 的最高有效位是1，所以结果字节 $P_A \\lor P_B$ 的最高有效位也必须是1。\n    -   这意味着任何可合成的负常量的低字节的最高有效位必须被设置。这样的字节在范围 $[\\text{0x80}, \\text{0xFF}]$ 内。\n    -   一个形如 $\\text{0xFFFFFF}Z$ 的32位数字，其中 $Z \\in [\\text{0x80}, \\text{0xFF}]$，表示一个在 $[-128, -1]$ 范围内的整数。\n    -   因此，任何可合成的负数都必须在 $[-128, -1]$ 的范围内。这个整个范围可以仅由单条 $\\mathrm{MOVI}$ 指令生成。$\\mathrm{ORI}$ 指令并没有扩展可合成负数的范围。\n\n4.  **关于可合成常量的结论：**\n    所有可由给定指令合成的整数集合是情况1和情况2范围的并集：\n    $$ \\{\\text{可合成整数}\\} = [-128, -1] \\cup [0, 255] $$\n    这个并集构成了所有满足 $-128 \\le c \\le 255$ 的整数的连续集合。\n    任何在此范围 $[-128, 255]$ 之外的整数常量都无法合成，必须使用 $\\mathrm{LDRI}$ 指令从内存中加载。\n\n5.  **对集合 $S$ 中常量的分类：**\n    我们现在根据可合成范围 $[-128, 255]$ 来测试集合 $S$ 中的每个常量。\n    -   $-200$：不在 $[-128, 255]$ 内。必须加载。\n    -   $-129$：不在 $[-128, 255]$ 内。必须加载。\n    -   $-128$：在 $[-128, 255]$ 内。可合成。\n    -   $-1$：在 $[-128, 255]$ 内。可合成。\n    -   $0$：在 $[-128, 255]$ 内。可合成。\n    -   $42$：在 $[-128, 255]$ 内。可合成。\n    -   $100$：在 $[-128, 255]$ 内。可合成。\n    -   $127$：在 $[-128, 255]$ 内。可合成。\n    -   $128$：在 $[-128, 255]$ 内。可合成。\n    -   $200$：在 $[-128, 255]$ 内。可合成。\n    -   $255$：在 $[-128, 255]$ 内。可合成。\n    -   $256$：不在 $[-128, 255]$ 内。必须加载。\n    -   $300$：不在 $[-128, 255]$ 内。必须加载。\n\n    来自集合 $S$ 中必须通过直接寻址加载的常量集合是 $\\{-200, -129, 256, 300\\}$。\n\n### 逐项分析\n\n**A. 唯一能被单个立即数直接表示的常量是 $c\\in[-128,127]$ 的那些值；除此之外，一个两条指令的变通方法通过先执行 $\\mathrm{MOVI}\\;r_d,\\,0$ 再执行 $\\mathrm{ORI}\\;r_d,\\,c$ 来精确覆盖 $c\\in[128,255]$ 的情况，因为从零开始的零扩展和按位或可以产生任何在[0, 255]范围内的非负数 $c$。所有其他的 $c$ 都需要直接寻址。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,256,\\,300\\}$ 必须通过直接寻址加载。**\n\n-   **分析：** 该推理确定了在 $[-128, 127]$ 范围内的常量可以用一条指令生成，在 $[128, 255]$ 范围内的常量可以用两条指令生成。这些集合的并集是整数范围 $[-128, 255]$。“所有其他的 c 都需要直接寻址”的说法正确地指出这是可合成整数的完整集合。将此规则应用于集合 $S$ 得出的列表是 $\\{-200, -129, 256, 300\\}$，与我们的推导相符。短语“其低8位等于c”是表达“对于 $c \\in [0,255]$”的一种稍欠精确的方式，但上下文使其含义清晰。整个陈述是一致且正确的。\n-   **结论：** **正确**。\n\n**B. 任何 $c\\in[0,65535]$ 的 $32$-bit 常量都可以通过使用零扩展的两条指令序列在不访问内存的情况下构建，因此 $\\{128,\\,200,\\,255\\}$ 都不需要直接寻址，但 $c\\in\\{-200,\\,-129,\\,-128,\\,-1\\}$ 必须从内存中获取，因为负常量不能通过位运算从零构建。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,-128,\\,-1\\}$ 需要直接寻址；所有其他常量则不需要。**\n\n-   **分析：** 声称任何在 $[0, 65535]$ 范围内的常量都可以构建是错误的。$\\mathrm{ORI}$ 指令只影响最低的8位，因此不可能设置位范围 $[15:8]$ 来生成像 $256$ ($0x100$) 这样的数字。声称 $\\{-128, -1\\}$ 必须从内存中获取也是错误的，因为它们可以通过 $\\mathrm{MOVI}$ 直接创建。最终需要加载的常量列表不正确。\n-   **结论：** **不正确**。\n\n**C. 因为重复使用 $\\mathrm{ORI}$ 可以逐步将高位字节设置为任何期望的模式，所以集合 $S$ 中的每个常量都可以在不访问内存的情况下合成；如果允许足够多的立即数 $\\mathrm{ORI}$ 操作，就不需要直接寻址。**\n\n-   **分析：** 这个陈述基于一个错误的前提。$\\mathrm{ORI}$ 指令被定义为使用一个零扩展的8位立即数。这意味着与寄存器进行或运算的值的形式是 $\\text{0x000000XX}$。这样的操作永远不能设置高位字节（位31到8）中的任何位。因此，不可能“逐步将高位字节设置为任何期望的模式”。因此，并非所有常量都可以被合成。\n-   **结论：** **不正确**。\n\n**D. 由于立即数只有 $k=8$ 位宽，任何绝对值超过 $255$ 的常量都必须从内存加载，但任何绝对值至多为 $255$ 的常量（包括所有 $|c|\\le 255$ 的负数）都由于符号扩展而可以在一条指令中直接表示。因此，在集合 $S$ 中，恰好 $\\{256,\\,300\\}$ 需要直接寻址；所有其他常量则不需要。**\n\n-   **分析：** 声称“任何绝对值至多为 $255$ 的常量...都可以在一条指令中直接表示”是错误的。“在一条指令中直接表示”指的是 $\\mathrm{MOVI}$ 指令，它只能产生 $[-128, 127]$ 范围内的常量。像 $200$（绝对值为 $200 \\le 255$）这样的常量需要两条指令。更重要的是，声称任何绝对值至多为 $255$ 的常量都是可合成的，这是错误的。例如，$c = -200$ 的绝对值为 $|c|=200 \\le 255$，但正如我们推导的，它是不可合成的。最终需要加载的常量列表 $\\{256, 300\\}$ 是不完整的，因为它忽略了 $-200$ 和 $-129$。\n-   **结论：** **不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "理论概念最终要服务于实践，在立即寻址和直接寻址之间的选择会对程序性能和代码大小产生实际影响。本练习提供了一个计算数组和的常见编程场景，要求您精确计算两种实现方式的性能差异：一种使用立即数作为循环步长，另一种则从内存中加载步长。通过这种量化分析，您可以直观地把握指令集设计和编译器优化中的核心权衡。",
            "id": "3648974",
            "problem": "考虑一个简化的加载-存储指令集架构，其字长为 $32$ 位，地址为 $32$ 位。处理器顺序执行指令，无重叠；每条指令在下一条指令开始前完成。所有数据加载均在一级（L1）数据缓存中命中。以下基本定义适用：\n- 立即数寻址模式：指令在指令字中编码一个常量操作数；使用立即数操作数不执行数据内存读取。\n- 直接寻址模式：指令在指令字中编码一个绝对数据内存地址；使用直接内存操作数会从编码的地址执行一次数据内存读取。\n- 带比例变址的寄存器间接寻址：加载指令通过将基址寄存器和一个比例变址（此处，按元素大小缩放）相加来计算有效地址。\n\n假设此简化架构有以下经过充分测试的事实：\n- 整数寄存器到寄存器的加法需要 $1$ 个周期，占用 $4$ 字节的代码。\n- 带立即数操作数的整数加法（例如，按常数递增）需要 $1$ 个周期，占用 $4$ 字节的代码。\n- 将立即数移动到寄存器（例如，将寄存器初始化为常数）需要 $1$ 个周期，占用 $4$ 字节的代码。\n- 使用带比例变址的寄存器间接寻址从内存加载（例如，加载数组元素）需要 $3$ 个周期，占用 $4$ 字节的代码。\n- 使用直接寻址（绝对地址编码在指令中）从内存加载需要 $3$ 个周期，占用 $8$ 字节的代码（用于存放 $32$ 位地址）。\n- 带有两个寄存器之间集成比较的条件分支需要 $1$ 个周期，占用 $4$ 字节的代码。在下面的程序中，该分支在每次循环迭代中执行一次，且分支预测是完美的（没有额外开销）。\n\n给定一个程序，用于对位于寄存器 $r_{\\mathrm{base}}$ 中基址处的 $N$ 个连续 $32$ 位整数数组求和。两个变体仅在处理循环步长的方式上有所不同：\n\n变体 I（立即数步长）：循环索引 $r_{i}$ 在每次迭代中通过立即数常量 $1$ 进行递增。\n- 循环前初始化：\n  - 使用立即数移动指令设置 $r_{i} \\leftarrow 0$。\n  - 使用立即数移动指令设置 $r_{\\mathrm{sum}} \\leftarrow 0$。\n  - 使用立即数移动指令设置 $r_{N} \\leftarrow N$。\n- 每次迭代的循环体：\n  - 使用带比例变址的寄存器间接寻址将元素加载到 $r_{t}$ 中：$[r_{\\mathrm{base}} + r_{i} \\times 4]$。\n  - 加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$。\n  - 通过立即数递增索引：$r_{i} \\leftarrow r_{i} + 1$。\n  - 条件分支：如果 $r_{i}  r_{N}$ 则继续。\n\n变体 II（直接寻址步长）：循环索引 $r_{i}$ 在每次迭代中通过一个步长值进行递增，该步长值通过直接寻址从持有常量 $1$ 的固定绝对地址 $\\alpha$ 获取。\n- 循环前初始化：与变体 I 相同。\n- 每次迭代的循环体：\n  - 使用带比例变址的寄存器间接寻址将元素加载到 $r_{t}$ 中：$[r_{\\mathrm{base}} + r_{i} \\times 4]$。\n  - 使用直接寻址从绝对地址 $\\alpha$ 将步长加载到 $r_{\\mathrm{step}}$ 中。\n  - 加法 $r_{i} \\leftarrow r_{i} + r_{\\mathrm{step}}$。\n  - 加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$。\n  - 条件分支：如果 $r_{i}  r_{N}$ 则继续。\n\n仅使用上述定义以及给定的时序和代码大小事实，推导出总周期数 $C_{\\mathrm{I}}(N)$ 和 $C_{\\mathrm{II}}(N)$，以及静态代码体积 $\\mathrm{size}_{\\mathrm{I}}$ 和 $\\mathrm{size}_{\\mathrm{II}}$，并将它们表示为 $N$ 的函数。然后计算：\n- 变体 I 相对于变体 II 的加速比，定义为 $S(N) = \\dfrac{C_{\\mathrm{II}}(N)}{C_{\\mathrm{I}}(N)}$。\n- 静态代码体积比，定义为 $R = \\dfrac{\\mathrm{size}_{\\mathrm{I}}}{\\mathrm{size}_{\\mathrm{II}}}$。\n\n将你的最终答案表示为一个包含 $S(N)$ 和 $R$ 的行矩阵。不需要四舍五入，你应该给出精确的封闭形式表达式。最终答案中不应包含单位。",
            "solution": "推导过程依赖于寻址模式的核心定义以及给定的经过充分测试的时序和代码大小事实。立即数操作数不引起数据内存读取，而直接寻址则在指令中嵌入一个绝对地址，这仍然会执行一次数据内存读取。在这个简化模型中，加载操作需要 $3$ 个周期，根据寻址模式的不同占用 $4$ 或 $8$ 个字节。算术和分支指令需要 $1$ 个周期，占用 $4$ 个字节。\n\n我们通过枚举执行的指令并加总它们的周期和大小来进行计算。\n\n对于变体 I（立即数步长）：\n\n循环前初始化包括三条立即数移动指令：\n- 设置 $r_{i} \\leftarrow 0$：$1$ 个周期，$4$ 字节。\n- 设置 $r_{\\mathrm{sum}} \\leftarrow 0$：$1$ 个周期，$4$ 字节。\n- 设置 $r_{N} \\leftarrow N$：$1$ 个周期，$4$ 字节。\n\n因此，循环前的周期数为\n$$\nC_{\\mathrm{I,init}} = 1 + 1 + 1 = 3,\n$$\n循环前的代码大小为\n$$\n\\mathrm{size}_{\\mathrm{I,init}} = 4 + 4 + 4 = 12.\n$$\n\n每次循环迭代执行以下操作：\n- 通过带比例变址的寄存器间接寻址加载元素：$3$ 个周期，$4$ 字节。\n- 加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$：$1$ 个周期，$4$ 字节。\n- 立即数加法递增 $r_{i} \\leftarrow r_{i} + 1$：$1$ 个周期，$4$ 字节。\n- 条件分支：$1$ 个周期，$4$ 字节。\n\n因此，每次迭代的周期数为\n$$\nC_{\\mathrm{I,iter}} = 3 + 1 + 1 + 1 = 6,\n$$\n循环体的（静态）代码体积为\n$$\n\\mathrm{size}_{\\mathrm{I,loop}} = 4 + 4 + 4 + 4 = 16.\n$$\n\n因为有 $N$ 次迭代，并且分支在每次迭代中执行一次，所以变体 I 的总周期数和静态代码大小为\n$$\nC_{\\mathrm{I}}(N) = C_{\\mathrm{I,init}} + N \\cdot C_{\\mathrm{I,iter}} = 3 + 6N,\n$$\n$$\n\\mathrm{size}_{\\mathrm{I}} = \\mathrm{size}_{\\mathrm{I,init}} + \\mathrm{size}_{\\mathrm{I,loop}} = 12 + 16 = 28.\n$$\n\n对于变体 II（直接寻址步长）：\n\n循环前初始化与变体 I 相同，得出\n$$\nC_{\\mathrm{II,init}} = 3, \\quad \\mathrm{size}_{\\mathrm{II,init}} = 12.\n$$\n\n每次循环迭代执行以下操作：\n- 通过带比例变址的寄存器间接寻址加载元素：$3$ 个周期，$4$ 字节。\n- 通过直接寻址从绝对地址 $\\alpha$ 加载步长：$3$ 个周期，$8$ 字节。\n- 加法 $r_{i} \\leftarrow r_{i} + r_{\\mathrm{step}}$：$1$ 个周期，$4$ 字节。\n- 加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$：$1$ 个周期，$4$ 字节。\n- 条件分支：$1$ 个周期，$4$ 字节。\n\n因此，每次迭代的周期数为\n$$\nC_{\\mathrm{II,iter}} = 3 + 3 + 1 + 1 + 1 = 9,\n$$\n循环体的（静态）代码体积为\n$$\n\\mathrm{size}_{\\mathrm{II,loop}} = 4 + 8 + 4 + 4 + 4 = 24.\n$$\n\n因此，变体 II 的总周期数和静态代码大小为\n$$\nC_{\\mathrm{II}}(N) = C_{\\mathrm{II,init}} + N \\cdot C_{\\mathrm{II,iter}} = 3 + 9N,\n$$\n$$\n\\mathrm{size}_{\\mathrm{II}} = \\mathrm{size}_{\\mathrm{II,init}} + \\mathrm{size}_{\\mathrm{II,loop}} = 12 + 24 = 36.\n$$\n\n现在计算所要求的比较值。\n\n变体 I 相对于变体 II 的加速比定义为\n$$\nS(N) = \\frac{C_{\\mathrm{II}}(N)}{C_{\\mathrm{I}}(N)} = \\frac{3 + 9N}{3 + 6N} = \\frac{3(1 + 3N)}{3(1 + 2N)} = \\frac{1 + 3N}{1 + 2N}.\n$$\n\n静态代码体积比为\n$$\nR = \\frac{\\mathrm{size}_{\\mathrm{I}}}{\\mathrm{size}_{\\mathrm{II}}} = \\frac{28}{36} = \\frac{7}{9}.\n$$\n\n这些是关于 $N$ （对于 $S(N)$）和常量（对于 $R$）的精确封闭形式表达式。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1+3N}{1+2N}  \\frac{7}{9}\\end{pmatrix}}$$"
        },
        {
            "introduction": "当程序需要的常数远大于指令中的立即数字段时，架构师和编译器开发者面临着一个有趣的挑战。本练习将指导您设计一种巧妙的算法，通过一系列的移位和加法指令来“合成”一个大的64位常数。您将计算这种方法的延迟，并将其与看似更简单的直接内存加载进行比较，从而揭示由现代存储层次结构引起的复杂性能考量。",
            "id": "3649029",
            "problem": "中央处理器 (CPU) 实现两种相关的寻址机制：立即寻址和直接寻址。立即寻址将常量直接编码在指令的立即数字段中，而直接寻址则编码一个内存地址，常量从该地址中获取。考虑在一个具有以下指令集和时序模型的 CPU 上的通用寄存器中生成一个特定的 $64$ 位常量 $K$ 的任务：\n\n- 该指令集提供三种相关操作，每种操作在 $1$ 个周期内完成，其产生的结果只能在下一个周期被后续的相关指令使用：\n    - $ \\mathrm{LOAD\\_IMM12}(r, u) $ 将无符号 $12$ 位立即数 $u \\in [0, 2^{12}-1]$ 写入寄存器 $r$。\n    - $ \\mathrm{SLL12}(r) $ 将寄存器 $r$ 逻辑左移 $12$ 位。\n    - $ \\mathrm{ADD\\_IMM12}(r, u) $ 将无符号 $12$ 位立即数 $u \\in [0, 2^{12}-1]$ 加到寄存器 $r$。\n  假设真实的数据依赖性强制这些操作严格串行化；构建 $K$ 的序列中没有重叠。\n\n- 直接寻址使用 $ \\mathrm{LD\\_DIRECT}(r, A) $，该指令将绝对地址 $A$ 处的 $64$ 位字加载到寄存器 $r$ 中。其延迟，从指令发出到数据在 $r$ 中可用（包括地址生成和写回），取决于缓存/内存级别的命中情况：\n    - 一级 (L1) 缓存命中延迟 $=4$ 个周期，概率为 $P_{\\mathrm{L1}}=0.93$。\n    - 二级 (L2) 缓存命中延迟 $=12$ 个周期，概率为 $P_{\\mathrm{L2}}=0.05$。\n    - 三级 (L3) 缓存命中延迟 $=36$ 个周期，概率为 $P_{\\mathrm{L3}}=0.015$。\n    - 主内存延迟 $=200$ 个周期，概率为 $P_{\\mathrm{Mem}}=0.005$。\n  这些概率满足 $P_{\\mathrm{L1}}+P_{\\mathrm{L2}}+P_{\\mathrm{L3}}+P_{\\mathrm{Mem}}=1$。\n\nCPU 的运行频率为 $f = 3.0 \\times 10^{9} \\, \\mathrm{Hz}$。\n\n给定常量 $K = \\text{0xABCDEF123456789}$。\n\n- 仅使用 $ \\mathrm{LOAD\\_IMM12} $、$ \\mathrm{SLL12} $ 和 $ \\mathrm{ADD\\_IMM12} $，从基本原理出发，设计一种通过将 $12$ 位立即数与左移 $12$ 位的操作相结合，在寄存器中合成 $K$ 的方法。您的设计必须解释如何分解 $K$ 以及如何对操作进行排序，并对在所述约束下指令数最小化给出明确的论证。\n- 确定在此 CPU 上使用立即寻址生成 $K$ 所需的最小周期数。\n- 计算在此 CPU 上使用直接寻址生成 $K$ 的期望周期数。\n- 最后，计算立即寻址合成和直接寻址加载之间的延迟差（以纳秒为单位），定义为\n$$\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}},$$\n其中 $T_{\\mathrm{imm}}$ 和 $T_{\\mathrm{direct}}$ 分别是以纳秒为单位的延迟。将最终的 $\\Delta T$ 四舍五入到四位有效数字，并以纳秒表示。",
            "solution": "问题陈述经评估有效。它在科学上基于计算机组成和体系结构的原理，描述了一个合理的、简化的 CPU 指令集、寻址模式和存储层次结构模型。该问题是适定的，提供了所有必要的数据和约束来推导出所需性能指标的唯一解。定义和数值在内部是一致且客观的。\n\n任务是分析两种将常量加载到寄存器中的方法，并比较它们的延迟。\n\n首先，我们解决使用立即寻址合成常量 $K$ 的问题。问题指定了一个 $64$ 位常量 $K = \\text{0xABCDEF123456789}$。这是一个15位十六进制数，对应 $15 \\times 4 = 60$ 位。当加载到 $64$ 位寄存器中时，高4位将为零。\n\n可用的指令 $\\mathrm{LOAD\\_IMM12}$、$\\mathrm{ADD\\_IMM12}$ 和 $\\mathrm{SLL12}$ 对 $12$ 位立即数进行操作并移位 $12$ 位。这表明可以将 $60$ 位的常量自然地分解为 $12$ 位的块。一个 $12$ 位的块对应 $3$ 个十六进制数字。我们将 $K$ 分解为五个 $12$ 位的块，从最高有效位 ($k_4$) 到最低有效位 ($k_0$)：\n$K = \\text{0xABC DEF 123 456 789}$\n这些块是：\n- $k_4 = \\text{0xABC}$\n- $k_3 = \\text{0xDEF}$\n- $k_2 = \\text{0x123}$\n- $k_1 = \\text{0x456}$\n- $k_0 = \\text{0x789}$\n\n$K$ 的值可以表示为以 $2^{12}$ 为底的多项式：\n$$K = k_4 \\cdot (2^{12})^4 + k_3 \\cdot (2^{12})^3 + k_2 \\cdot (2^{12})^2 + k_1 \\cdot (2^{12})^1 + k_0 \\cdot (2^{12})^0$$\n这个结构可以使用霍纳（Horner）方法高效地合成：\n$$K = ((((k_4 \\cdot 2^{12} + k_3) \\cdot 2^{12} + k_2) \\cdot 2^{12} + k_1) \\cdot 2^{12} + k_0)$$\n这对应于寄存器 $r$ 中的以下操作序列：\n1. 用最高有效块 $k_4$ 初始化 $r$。\n2. 将 $r$ 左移 $12$ 位（乘以 $2^{12}$）。\n3. 加上下一个块 $k_3$。\n4. 对余下的块 $k_2$、$k_1$ 和 $k_0$ 重复步骤 2 和 3。\n\n在寄存器（比如 $r0$）中生成 $K$ 的具体指令序列是：\n1. $\\mathrm{LOAD\\_IMM12}(r0, \\text{0xABC})$\n2. $\\mathrm{SLL12}(r0)$\n3. $\\mathrm{ADD\\_IMM12}(r0, \\text{0xDEF})$\n4. $\\mathrm{SLL12}(r0)$\n5. $\\mathrm{ADD\\_IMM12}(r0, \\text{0x123})$\n6. $\\mathrm{SLL12}(r0)$\n7. $\\mathrm{ADD\\_IMM12}(r0, \\text{0x456})$\n8. $\\mathrm{SLL12}(r0)$\n9. $\\mathrm{ADD\\_IMM12}(r0, \\text{0x789})$\n\n该序列由 $1$ 条 $\\mathrm{LOAD\\_IMM12}$ 指令、$4$ 条 $\\mathrm{SLL12}$ 指令和 $4$ 条 $\\mathrm{ADD\\_IMM12}$ 指令组成，总共 $9$ 条指令。这个序列是最小的。要构造这个 $60$ 位常量，我们必须指定其五个非零的 $12$ 位块。这至少需要 $5$ 条提供立即数值的指令（$\\mathrm{LOAD\\_IMM12}$ 或 $\\mathrm{ADD\\_IMM12}$）。为了将这五个块放置在它们正确的位位置（每个位置相隔 $12$ 位），我们需要 $4$ 次 $12$ 位的相对移位。因此，最少需要 $5 + 4 = 9$ 条指令。所提出的序列达到了这个下限。\n\n接下来，我们确定这种立即寻址方法的周期数，$C_{\\mathrm{imm}}$。问题陈述指出，每条指令需要 $1$ 个周期，并且序列中每条连续指令之间都存在真实的数据依赖性。这强制了严格的串行化。因此，总周期数就是指令链中的总指令数。\n$$C_{\\mathrm{imm}} = 9 \\text{ cycles}$$\n\n现在，我们计算直接寻址方法的期望周期数，$E[C_{\\mathrm{direct}}]$。该方法使用单条指令 $\\mathrm{LD\\_DIRECT}$，其延迟取决于存储层次结构。期望延迟是所有可能延迟按其概率加权的总和：\n$$E[C_{\\mathrm{direct}}] = C_{\\mathrm{L1}}P_{\\mathrm{L1}} + C_{\\mathrm{L2}}P_{\\mathrm{L2}} + C_{\\mathrm{L3}}P_{\\mathrm{L3}} + C_{\\mathrm{Mem}}P_{\\mathrm{Mem}}$$\n代入给定值：\n$$E[C_{\\mathrm{direct}}] = (4 \\cdot 0.93) + (12 \\cdot 0.05) + (36 \\cdot 0.015) + (200 \\cdot 0.005)$$\n$$E[C_{\\mathrm{direct}}] = 3.72 + 0.60 + 0.54 + 1.00 = 5.86 \\text{ cycles}$$\n\n最后，我们计算延迟差 $\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}}$（以纳秒为单位）。首先，我们从 CPU 频率 $f = 3.0 \\times 10^9 \\, \\mathrm{Hz}$ 计算其时钟周期 $T_{\\mathrm{cycle}}$：\n$$T_{\\mathrm{cycle}} = \\frac{1}{f} = \\frac{1}{3.0 \\times 10^{9} \\, \\mathrm{Hz}} = \\frac{1}{3} \\times 10^{-9} \\, \\mathrm{s} = \\frac{1}{3} \\, \\mathrm{ns}$$\n每种方法的总延迟是其周期数乘以时钟周期。对于直接寻址方法，我们使用期望周期数。\n$$T_{\\mathrm{imm}} = C_{\\mathrm{imm}} \\cdot T_{\\mathrm{cycle}} = 9 \\cdot \\frac{1}{3} \\, \\mathrm{ns} = 3 \\, \\mathrm{ns}$$\n$$T_{\\mathrm{direct}} = E[C_{\\mathrm{direct}}] \\cdot T_{\\mathrm{cycle}} = 5.86 \\cdot \\frac{1}{3} \\, \\mathrm{ns} \\approx 1.9533... \\, \\mathrm{ns}$$\n延迟差为：\n$$\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}} = 3 \\, \\mathrm{ns} - \\frac{5.86}{3} \\, \\mathrm{ns} = \\frac{9 - 5.86}{3} \\, \\mathrm{ns} = \\frac{3.14}{3} \\, \\mathrm{ns}$$\n$$\\Delta T \\approx 1.04666... \\, \\mathrm{ns}$$\n按要求四舍五入到四位有效数字，我们得到：\n$$\\Delta T \\approx 1.047 \\, \\mathrm{ns}$$",
            "answer": "$$\\boxed{1.047}$$"
        }
    ]
}