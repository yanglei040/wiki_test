{
    "hands_on_practices": [
        {
            "introduction": "并非所有的指令集架构都同样完备。本练习将探讨如何在只提供基本逻辑运算的机器上，构建一项至关重要的操作——算术右移，这对于有符号整数的除法至关重要。通过这项实践，你将深化对二进制补码表示法以及位操作机制的理解。",
            "id": "3620381",
            "problem": "一台 $w$ 位二进制补码计算机缺少算术右移指令，但支持逻辑右移、按位与、按位或以及二进制补码取反，所有这些操作都在模 $2^{w}$ 下进行，结果被截断为 $w$ 位。考虑通过对值 $x$ 使用以下表达式，仅用这些操作来模拟算术右移 $k$ 个位置：\n$$\nY(x,k,w) \\;=\\; \\left(x \\gg_{\\mathrm{logic}} k\\right) \\;\\lor\\; \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\; \\ll\\; (w-k)\\right),\n$$\n其中 $x$ 是一个以二进制补码解释的 $w$ 位字，$\\gg_{\\mathrm{logic}}$ 表示逻辑右移（零填充），$\\ll$ 表示左移（零填充），$\\land$ 表示按位与，$\\lor$ 表示按位或，一元 $-$ 表示模 $2^{w}$ 的二进制补码取反。\n\n仅使用二进制补码表示、逻辑和算术移位以及按位操作的基本定义，完成以下任务：\n- 从第一性原理出发，推导并证明\n$$\nM(x,k,w) \\;=\\; \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)\n$$\n这一项是一个 $w$ 位掩码，当 $x$ 的符号位为 $0$ 时它等于 $0$，当 $x$ 的符号位为 $1$ 时它等于一个在最高有效 $k$ 个比特位上为 $k$ 个 $1$ 的掩码。\n- 得出结论，$Y(x,k,w)$ 对于任何 $w$ 位二进制补码输入 $x$ 和整数 $k$（其中 $0 \\le k  w$），其结果等于对 $x$ 进行算术右移 $k$ 个位置的结果。\n\n然后，对于一个具体实例，其中 $w = 16$， $x$ 等于 $-10000$ 的二进制补码编码，且 $k = 5$，计算 $Y(x,k,w)$ 生成的有符号十进制值。将您的最终结果表示为一个有符号的十进制整数。",
            "solution": "首先验证问题，以确保其科学基础扎实、提法明确且客观。\n\n### 第 1 步：提取已知信息\n- 一台 $w$ 位二进制补码计算机。\n- 支持的操作：逻辑右移（$\\gg_{\\mathrm{logic}}$）、按位与（$\\land$）、按位或（$\\lor$）、二进制补码取反（一元 $-$）以及左移（$\\ll$）。所有操作均在模 $2^w$ 下进行，结果截断为 $w$ 位。\n- 模拟算术右移的表达式：$Y(x,k,w) = \\left(x \\gg_{\\mathrm{logic}} k\\right) \\lor M(x,k,w)$。\n- 掩码项的定义：$M(x,k,w) = \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)$。\n- $x$ 是一个 $w$ 位的二进制补码字。\n- $k$ 是一个整数，满足 $0 \\le k  w$。\n- 任务1：证明 $M(x,k,w)$ 根据 $x$ 的符号位创建一个特定的掩码。\n- 任务2：得出结论，$Y(x,k,w)$ 等价于 $x$ 的算术右移 $k$ 位。\n- 任务3：当 $w = 16$，$x$ 为 $-10000$ 的二进制补码，且 $k = 5$ 时，计算 $Y(x,k,w)$ 的有符号十进制值。\n\n### 第 2 步：使用提取的已知信息进行验证\n- **科学基础扎实：** 该问题基于计算机组成和体系结构中的基本、标准概念，特别是整数表示（二进制补码）和位级操作（移位、按位逻辑）。使用逻辑移位和其他基本指令来模拟算术移位是该领域一个经典且实际的问题。\n- **提法明确：** 问题提供了所有必要的定义和约束。函数 $Y(x,k,w)$ 和 $M(x,k,w)$ 都有明确的定义。任务具体，能够导出一个唯一、可验证的解。\n- **客观：** 问题以精确、形式化的语言陈述，没有歧义或主观性陈述。\n\n### 第 3 步：结论与行动\n问题是有效的。这是一个关于计算机算术的严谨练习。将提供完整的解决方案。\n\n### 解题推导\n\n我们首先陈述证明所需的基本定义。\n一个由位串 $x_{w-1}x_{w-2}...x_0$ 表示的 $w$ 位整数 $x$，其二进制补码的值为 $V(x) = -x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$。位 $x_{w-1}$ 是符号位；对于非负数，$x_{w-1}=0$，对于负数，$x_{w-1}=1$。\n\n**算术右移** $k$ 个位置，表示为 $x \\gg_{\\mathrm{arith}} k$，将所有位向右移动 $k$ 个位置。最高有效的 $k$ 个位（MSBs）用原始符号位 $x_{w-1}$ 的副本填充。此操作等效于整数除以 $2^k$，并向负无穷大取整：$\\lfloor V(x) / 2^k \\rfloor$。\n\n**逻辑右移** $k$ 个位置，表示为 $x \\gg_{\\mathrm{logic}} k$，也将所有位向右移动 $k$ 个位置，但最高有效的 $k$ 个位总是用 $0$ 填充。\n\n目标是证明 $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor M(x,k,w)$ 正确地模拟了 $x \\gg_{\\mathrm{arith}} k$。项 $x \\gg_{\\mathrm{logic}} k$ 执行移位操作，在最高有效位引入零。掩码 $M(x,k,w)$ 的作用是修正这些最高有效位，当且仅当原始数字 $x$ 为负时，将它们更改为 $1$。\n\n**第 1 部分：分析掩码项 $M(x,k,w)$**\n\n掩码定义为 $M(x,k,w) = \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)$。我们从内到外分析这个表达式。\n\n1.  **分离符号位：** 项 $\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right)$ 将 $w$ 位字 $x$ 向右逻辑移位 $w-1$ 个位置，并用零填充。这将原始符号位 $x_{w-1}$ 移动到最低有效位（LSB）位置（位 $0$）。所有其他 $w-1$ 位都变为 $0$。得到的 $w$ 位字是 $00...0x_{w-1}$。\n\n2.  **转换为整数 $0$ 或 $1$：** 执行按位与操作 `... $\\land$ 1`。值 $1$ 作为一个 $w$ 位字是 $00...01$。操作 $(00...0x_{w-1}) \\land (00...01)$ 的结果是，如果 $x_{w-1}=1$，则为字 $00...01$，如果 $x_{w-1}=0$，则为字 $00...00$。我们可以将此结果的整数值表示为 $S$，其中 $S=x_{w-1}$。\n\n3.  **二进制补码取反：** 表达式现在变为 $-S$。\n    - **情况 A：$x$ 为非负数。** 符号位 $x_{w-1}=0$，所以 $S=0$。$0$ 的二进制补码是 $0$。得到的 $w$ 位字是全零序列：$00...0$。\n    - **情况 B：$x$ 为负数。** 符号位 $x_{w-1}=1$，所以 $S=1$。$1$（表示为 $00...01$）的二进制补码是通过按位取反（$11...10$）再加 $1$ 得到的，即 $11...11$。这是 $-1$ 的 $w$ 位表示。\n\n4.  **最后的左移：** 上一步的结果向左移动 $(w-k)$ 个位置：`... $\\ll (w-k)$`。\n    - **情况 A（来自上述）：** 如果字是全零，将其向左移动任何位数，结果仍然是全零的字。因此，如果 $x$ 是非负数，$M(x,k,w)$ 是全零字。\n    - **情况 B（来自上述）：** 如果字是全一（$11...11$），将其向左移动 $(w-k)$ 个位置，会导致最右边的 $(w-k)$ 位被零填充。最高有效的 $k$ 位由最初在位置 $w-1, w-2, ..., k$ 的位填充。由于源字的所有位都是 $1$，这些最高有效的 $k$ 位都将变为 $1$。得到的掩码是一个其最高有效 $k$ 位等于 $1$ 而其余 $w-k$ 位等于 $0$ 的字。\n\n这样就完成了推导。$M(x,k,w)$ 是一个 $w$ 位字，如果 $x$ 的符号位为 $0$，它就是 $0$；如果 $x$ 的符号位为 $1$，它就是一个在最高有效位位置有 $k$ 个 $1$ 的掩码。\n\n**第 2 部分：证明等价于算术右移**\n\n现在我们分析 $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor M(x,k,w)$。\n\n- **情况 1：$x$ 为非负数。** 符号位 $x_{w-1}=0$。\n    - 算术右移 $x \\gg_{\\mathrm{arith}} k$ 会用 $0$ 填充最高有效的 $k$ 位。\n    - 逻辑右移 $x \\gg_{\\mathrm{logic}} k$ 也会用 $0$ 填充最高有效的 $k$ 位。\n    - 如上所示，对于非负数 $x$，掩码 $M(x,k,w)$ 是全零字。\n    - 因此，$Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor (\\text{全零字}) = (x \\gg_{\\mathrm{logic}} k)$。\n    - 在这种情况下，$Y(x,k,w)$ 与 $x \\gg_{\\mathrm{arith}} k$ 相同。\n\n- **情况 2：$x$ 为负数。** 符号位 $x_{w-1}=1$。\n    - 算术右移 $x \\gg_{\\mathrm{arith}} k$ 会将 $x$ 的位向右移动 $k$ 位，并用 $1$ 填充最高有效的 $k$ 位。\n    - 项 $x \\gg_{\\mathrm{logic}} k$ 将位向右移动，但用 $0$ 填充最高有效的 $k$ 位。\n    - 如上所示，对于负数 $x$，掩码 $M(x,k,w)$ 的最高有效 $k$ 位被置为 $1$，而其最低有效 $w-k$ 位被置为 $0$。\n    - 让我们执行按位或操作：\n        - 对于最高有效的 $k$ 个位位置：来自 $(x \\gg_{\\mathrm{logic}} k)$ 的位是 $0$。来自 $M(x,k,w)$ 的位是 $1$。或运算的结果是 $1$。\n        - 对于最低有效的 $w-k$ 个位位置：来自 $(x \\gg_{\\mathrm{logic}} k)$ 的位包含 $x$ 的移位后内容。来自 $M(x,k,w)$ 的位是 $0$。或运算的结果保留了来自 $(x \\gg_{\\mathrm{logic}} k)$ 的位。\n    - 最终结果的最高有效 $k$ 位被置为 $1$，而其最低有效 $w-k$ 位被正确地设置为 $x$ 移位后的位。这正是负数算术右移的定义。\n    - 在这种情况下，$Y(x,k,w)$ 也与 $x \\gg_{\\mathrm{arith}} k$ 相同。\n\n由于该等式对于非负数和负数都成立，我们得出结论，$Y(x,k,w)$ 对于任何 $w$ 位输入 $x$ 和 $0 \\le k  w$ 都是对 $x$ 进行算术右移 $k$ 个位置的有效模拟。\n\n**第 3 部分：具体计算**\n\n给定 $w=16, k=5$，输入值为 $-10000$。我们需要计算 $Y(x,k,w)$ 的有符号十进制值。\n根据我们的证明，我们知道这等价于一次算术右移。\n$$ Y(x,k,w) = \\lfloor \\frac{-10000}{2^k} \\rfloor $$\n当 $k=5$ 时，我们有 $2^5 = 32$。\n$$ \\text{值} = \\lfloor \\frac{-10000}{32} \\rfloor $$\n进行除法运算：\n$$ \\frac{-10000}{32} = -312.5 $$\n该值的向下取整是：\n$$ \\lfloor -312.5 \\rfloor = -313 $$\n生成的有符号十进制值为 $-313$。\n\n为了验证，我们来找出 $x=-10000$ 的 $16$ 位表示。\n$10000$ 的二进制是 $8192 + 1024 + 512 + 256 + 16 = 2^{13} + 2^{10} + 2^9 + 2^8 + 2^4$。\n在 $16$ 位中，这是 `0010 0111 0001 0000`。\n要得到 $-10000$，我们取其二进制补码：按位取反再加 $1$。\n取反：`1101 1000 1110 1111`\n加 $1$： `1101 1000 1111 0000` (这就是 $x$)。\n将其算术右移 $k=5$ 个位置。原始的 $x$ (`1101 1000 1111 0000`) 右移5位并进行符号扩展后，得到的结果是 `1111 1110 1100 0111`。要验证这个值，我们取其二进制补码来找到其绝对值：\n取反：`0000 0001 0011 1000`\n加 1： `0000 0001 0011 1001`\n这个二进制数表示的十进制值是 $2^8 + 2^5 + 2^4 + 2^3 + 2^0 = 256 + 32 + 16 + 8 + 1 = 313$。\n因此，该值为 $-313$。\n位级验证证实了整数除法的结果。",
            "answer": "$$\\boxed{-313}$$"
        },
        {
            "introduction": "一个常见的编程任务——计算两个整数的平均值——隐藏着一个微妙的陷阱：算术溢出。本练习挑战你超越 $(a+b)/2$ 这种简单的实现方式，利用位逻辑推导出一个健壮且不会溢出的方法。这个过程将展示底层思维如何帮助我们编写出更安全、更正确的代码。",
            "id": "3620404",
            "problem": "要求您在机器指令层面，仅使用算术和逻辑指令，对两个有符号整数平均值的向下取整进行推理和实现。底层的机器模型是一个宽度为 $w = 32$ 位的定宽二进制补码算术单元，其语义如下：\n\n- 二进制补码表示法使用第 $31$ 位作为符号位，表示范围在 $[-2^{31}, 2^{31}-1]$ 内的整数。\n- 加法、减法和所有位运算都对位模式执行模 $2^{32}$ 运算。也就是说，两个 $32$ 位值相加会丢弃超出第 $31$ 位的进位。\n- 有符号值的右移是算术右移（即符号位扩展），无符号值的右移是逻辑右移（即零填充）。\n- 按位逻辑运算符独立作用于每个比特位。\n\n作为起点的基本事实假设：\n\n- 二进制加法可以分解为不带进位的和位与进位位：对于所有表示整数的位模式，$a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$，其中 $\\oplus$ 是按位异或，$\\land$ 是按位与。此恒等式在整数环中成立；它描述了进位在加法中如何传播。\n- 对一个二进制补码值进行 $1$ 位的算术右移等价于除以 $2$ 的向下取整：对于任何可用 $32$ 位二进制补码表示的 $x$，$\\operatorname{ashr}(x, 1)$ 等于 $\\left\\lfloor x / 2 \\right\\rfloor$。\n\n您的任务：\n\n1) 定义一个函数，该函数尝试通过先相加再右移一位来计算两个有符号 $32$ 位整数 $a$ 和 $b$ 的平均值的向下取整，即通过在 $32$ 位二进制补码算术中计算 $(a + b)$，然后应用 $1$ 位的算术右移来计算 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$。分析并展示由于 $(a+b)$ 中的环绕溢出（wrap-around overflow）导致此方法失败的情况。\n\n2) 从恒等式 $a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$ 和算术右移作为除以 $2$ 向下取整的语义出发，推导一个仅由运算符 $\\land$、$\\oplus$、整数加法和 $1$ 位算术右移构成的表达式，该表达式可以为 $[-2^{31}, 2^{31}-1]$ 中的所有 $a, b$ 计算 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$，并且当中间结果被限制在 $32$ 位时不会发生溢出。证明为什么在所述模型下该表达式不会溢出。\n\n3) 在上述 $w = 32$ 位二进制补码模型下，实现以下三个函数，且不调用 C 编程语言中任何未定义的行为：\n- 一个“朴素”的向下取整平均值函数 $\\mathrm{avg\\_naive}(a, b)$，它返回先对 $a$ 和 $b$ 执行 $32$ 位模加法，然后应用 $1$ 位算术右移的结果。\n- 一个“修正”的向下取整平均值函数 $\\mathrm{avg\\_correct}(a, b)$，它仅使用 $32$ 位值上的 $\\land$、$\\oplus$、整数加法和 $1$ 位算术右移来计算 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$，且不会溢出，如第 $2$ 部分所推导。\n- 一个“参考”的向下取整平均值函数 $\\mathrm{avg\\_ref}(a, b)$，它使用一个更宽的整数类型来计算真实的数学值 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$，该类型可被证明对于 $[-2^{31}, 2^{31}-1]$ 范围内的输入不会溢出。\n\n为保证正确性和可移植性的重要实现要求：\n- 您必须显式地模拟 $32$ 位二进制补码算术。特别地，不要依赖 C 语言的有符号数溢出或右移负有符号整数的实现定义行为。使用掩码来限制到 $32$ 位，并使用显式符号扩展来实现算术右移。\n- 将所有中间的 $32$ 位值视为模 $2^{32}$ 的位模式，并且仅在每个返回有符号结果的函数的最后一步才将其转换为有符号整数。\n\n测试套件：\n您的程序必须计算以下六个测试用例，每个用例是一对有符号 $32$ 位整数 $(a, b)$：\n- 情况 $1$：$(a, b) = (5, 2)$。\n- 情况 $2$：$(a, b) = (2{,}147{,}483{,}647, 2{,}147{,}483{,}647)$。\n- 情况 $3$：$(a, b) = (-2{,}147{,}483{,}648, -2{,}147{,}483{,}648)$。\n- 情况 $4$：$(a, b) = (2{,}147{,}483{,}647, -2{,}147{,}483{,}648)$。\n- 情况 $5$：$(a, b) = (2{,}147{,}483{,}647, 2{,}147{,}483{,}646)$。\n- 情况 $6$：$(a, b) = (-7, -2)$。\n\n对于每个用例，计算：\n- $N = \\mathrm{avg\\_naive}(a, b)$，\n- $C = \\mathrm{avg\\_correct}(a, b)$，\n- $R = \\mathrm{avg\\_ref}(a, b)$，\n- $n\\_ok$，如果 $N = R$ 则等于 $1$，否则等于 $0$，\n- $c\\_ok$，如果 $C = R$ 则等于 $1$，否则等于 $0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个含六个子列表的列表，每个子列表对应一个测试用例，顺序与上文相同。每个子列表必须是五元组 $[N,C,R,n\\_ok,c\\_ok]$，所有条目均为十进制整数且无空格。整个输出的格式应严格为一个由这些子列表组成的、用方括号括起来的、逗号分隔的列表，例如 $[[\\cdots],[\\cdots],\\ldots]$。",
            "solution": "此问题经评估有效。它在科学上基于二进制补码算术的原理，问题提出得很好，有明确的目标和约束，并且以精确、客观的语言表述。它自成体系且内部一致。因此，我们可以着手解决。\n\n该问题要求在一个受限的二进制补码机器模型内，分析并实现计算两个有符号 $32$ 位整数平均值的向下取整 $\\lfloor (a + b) / 2 \\rfloor$ 的方法。该模型宽度为 $w=32$ 位，加法使用模运算，并定义算术右移 $\\operatorname{ashr}(x, 1)$ 等价于 $\\lfloor x / 2 \\rfloor$。\n\n### 1. 朴素方法的分析\n\n朴素方法通过先使用机器原生的 $32$ 位加法计算和 $a+b$，然后执行 $1$ 位的算术右移来计算 $\\lfloor (a + b) / 2 \\rfloor$。设 $a$ 和 $b$ 的机器加法表示为 $a +_{32} b$。因此，计算过程为 $\\operatorname{ashr}(a +_{32} b, 1)$。\n\n这种方法的根本缺陷是在初始加法过程中会发生溢出。数学上的和 $a+b$ 可能会超出 $32$ 位有符号整数的表示范围，即 $[-2^{31}, 2^{31}-1]$。在二进制补码算术中，这种溢出会导致结果“环绕”，产生一个与真实和模 $2^{32}$ 同余但大小不同、符号也可能不同的值。\n\n我们用两个例子来证明这种失败：\n\n**情况1：正溢出**\n设 $a = 2^{31}-1$ 且 $b = 2^{31}-1$。\n真实的数学和是 $S = (2^{31}-1) + (2^{31}-1) = 2^{32}-2$。\n正确的平均值是 $\\lfloor S/2 \\rfloor = \\lfloor (2^{32}-2)/2 \\rfloor = 2^{31}-1$。\n在 $32$ 位机器模型中，和 $a +_{32} b$ 的计算如下：\n$(2^{31}-1) + (2^{31}-1) \\equiv (2^{32}-2) \\pmod{2^{32}} \\equiv -2$。\n$2^{31}-1$ 的位模式是 `0x7FFFFFFF`。`0x7FFFFFFF + 0x7FFFFFFF` 的和结果为 `0xFFFFFFFE`，这是 $-2$ 的二进制补码表示。\n然后，朴素方法计算 $\\operatorname{ashr}(-2, 1) = \\lfloor -2/2 \\rfloor = -1$。\n这个结果 $-1$ 与正确值 $2^{31}-1$ 相差甚远。\n\n**情况2：负溢出**\n设 $a = -2^{31}$ 且 $b = -2^{31}$。\n真实的数学和是 $S = (-2^{31}) + (-2^{31}) = -2^{32}$。\n正确的平均值是 $\\lfloor S/2 \\rfloor = \\lfloor -2^{32}/2 \\rfloor = -2^{31}$。\n在 $32$ 位机器模型中，和 $a +_{32} b$ 的计算如下：\n$(-2^{31}) + (-2^{31}) \\equiv (-2^{32}) \\pmod{2^{32}} \\equiv 0$。\n$-2^{31}$ 的位模式是 `0x80000000`。`0x80000000 + 0x80000000` 的和结果为 `0x100000000`。由于在 $32$ 位算术中会丢弃第 $31$ 位的进位，结果是 `0x00000000`，表示 $0$。\n然后，朴素方法计算 $\\operatorname{ashr}(0, 1) = \\lfloor 0/2 \\rfloor = 0$。\n这个结果 $0$ 是不正确的；真实的平均值是 $-2^{31}$。\n\n这些情况表明，由于加法运算中的中间溢出，朴素方法是不可靠的。\n\n### 2. 推导正确的无溢出表达式\n\n为了推导一个稳健的表达式，我们从给定的、将整数加法与位运算联系起来的基本事实出发：\n$$a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$$\n其中 $\\oplus$ 是按位异或，$\\land$ 是按位与。此恒等式对任意大小的整数都成立。\n\n我们的目标是计算 $\\lfloor (a+b)/2 \\rfloor$。我们将该恒等式代入此表达式：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{(a \\oplus b) + 2 \\cdot (a \\land b)}{2} \\right\\rfloor $$\n我们可以在向下取整函数内部分配除法：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} + \\frac{2 \\cdot (a \\land b)}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} + (a \\land b) \\right\\rfloor $$\n由于 $(a \\land b)$ 的结果是一个整数值，我们可以使用属性 $\\lfloor z+k \\rfloor = \\lfloor z \\rfloor + k$，其中 $z$ 为任意实数，$k$ 为整数：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} \\right\\rfloor + (a \\land b) $$\n问题陈述中提到，对于任何 $32$ 位二进制补码整数 $x$，操作 $\\operatorname{ashr}(x, 1)$ 等价于 $\\lfloor x/2 \\rfloor$。将此应用于项 $\\lfloor (a \\oplus b)/2 \\rfloor$，我们得到最终表达式：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\operatorname{ashr}(a \\oplus b, 1) + (a \\land b) $$\n该表达式完全由允许的运算符组成。\n\n**无溢出理由：**\n现在我们必须证明，使用 $32$ 位模运算计算此表达式不会在最终的加法步骤中导致溢出。设 $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ 和 $T_2 = a \\land b$。我们分析和 $T_1 + T_2$ 中操作数 $T_1$ 和 $T_2$ 的符号。二进制补码加法中的溢出只可能在两个同号数相加且结果符号相反时发生。\n\n- **情况A：$a$ 和 $b$ 符号相同。**\n  $a$ 和 $b$ 的符号位相同（$a_{31} = b_{31}$）。\n  - $(a \\oplus b)$ 的符号位是 $a_{31} \\oplus b_{31} = 0$。因此，$(a \\oplus b)$ 是一个非负整数。它的算术右移 $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ 也是非负的。\n  - $(a \\land b)$ 的符号位是 $a_{31} \\land b_{31} = a_{31}$。因此，$T_2 = a \\land b$ 与 $a$ 和 $b$ 的符号相同。\n  - 如果 $a, b \\ge 0$，那么 $T_1 \\ge 0$ 且 $T_2 \\ge 0$。真实的平均值也必须是非负的，并且可以在 $32$ 位内表示。和 $T_1 + T_2$ 不会溢出。例如，如果 $a=b=2^{31}-1$，那么 $T_1=\\operatorname{ashr}(0,1)=0$ 且 $T_2=2^{31}-1$。和是 $2^{31}-1$，这是正确的并且不会溢出。\n  - 如果 $a, b  0$，那么 $T_1 \\ge 0$ 且 $T_2  0$。我们在将一个非负数与一个负数相加。这个和保证位于两个操作数之间，因此绝不会溢出。\n\n- **情况B：$a$ 和 $b$ 符号不同。**\n  $a$ 和 $b$ 的符号位不同（$a_{31} \\neq b_{31}$）。\n  - $(a \\oplus b)$ 的符号位是 $a_{31} \\oplus b_{31} = 1$。因此，$(a \\oplus b)$ 是一个负整数。它的算术右移 $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ 也是负的。\n  - $(a \\land b)$ 的符号位是 $a_{31} \\land b_{31} = 0$。因此，$T_2 = a \\land b$ 是一个非负整数。\n  - 我们再次将一个负数（$T_1$）与一个非负数（$T_2$）相加。与情况A一样，此操作不会溢出。\n\n在所有可能的情况下，最终加法的操作数不会同时具有相同的符号（除非其中一个为零），而这是溢出的必要条件。因此，表达式 $\\operatorname{ashr}(a \\oplus b, 1) + (a \\land b)$ 可以使用 $32$ 位模运算进行计算，而没有任何中间溢出的风险。\n\n### 3. 实现计划\n\n问题要求在 C 语言中实现三个函数，严格遵守对 $32$ 位二进制补码模型的模拟，并避免 C 语言对有符号整数的未定义或实现定义行为。我们将假设 `int` 是 $32$ 位类型，`long long` 是 $64$ 位类型，这是 C23 环境中的标准配置。\n\n- **`avg_ref(a, b)`**：此参考函数会将输入 $a$ 和 $b$ 强制转换为更宽的类型 `long long`，该类型保证能容纳它们的和而不会溢出。然后，对 `long long` 类型的和使用算术右移运算符 `>>` 计算平均值的向下取整。在 C23 标准下，右移有符号整数保证是算术移位，产生 $\\lfloor (a+b)/2 \\rfloor$。\n\n- **`ashr_s32_by_1(x)`**：为了遵循显式模拟的要求，将创建一个辅助函数来执行 $1$ 位的算术右移。它会将有符号输入转换为 `unsigned int` 以执行逻辑右移（这是明确定义的），然后如果原始数字为负，则手动恢复符号位。\n\n- **`avg_naive(a, b)`**：此函数将模拟有缺陷的方法。它将使用 `unsigned int` 来执行 $a$ 和 $b$ 的模加法。得到的位模式将被重新解释为有符号的 `int`，并传递给我们的 `ashr_s32_by_1` 辅助函数。\n\n- **`avg_correct(a, b)`**：此函数将实现推导出的无溢出公式。它将使用 `unsigned int` 类型来执行按位 `` 和 `^` 运算以及最终的 `+` 运算，从而确保所有算术都是模运算。`^` 运算的中间结果将被强制转换为有符号的 `int`，这仅仅是为了调用 `ashr_s32_by_1` 函数，因为 `ashr` 操作是定义在有符号值上的。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include\n```"
        },
        {
            "introduction": "对于现代处理器流水线来说，条件分支的开销可能十分昂贵。本练习将介绍一种强大的优化技术：将控制流转换为数据流，这是高性能计算的一块基石。你将学习如何运用位运算来生成一个“掩码”，从而在不使用 `if` 语句的情况下在两个值之间进行选择。",
            "id": "3620402",
            "problem": "要求您设计并实现一个无分支机制，仅当输入整数为零时为其分配一个默认值，且该机制完全依赖于算术和逻辑指令。此任务的基础是带符号整数的二进制补码表示法以及位运算和移位操作的标准定义。您必须从第一性原理出发，推导出一个字宽的掩码，当输入为零时，该掩码全为1，否则全为0。使用该掩码在原始输入和提供的默认值之间进行选择，不得使用任何条件分支。\n\n假设以下基本事实：\n- 在二进制补码中，对于一个带符号整数 $x$，其相反数 $-x$ 是通过在字长模运算下加上加法逆元来定义的。位运算是逐位执行的，无符号右移是逻辑移位（补零）。\n- 对于任何宽度为 $w$ 位的整数，最高有效位（MSB）的索引为 $w - 1$。\n- 位或、位非和位与运算在位向量上遵循其标准代数性质。\n- 对于任何非零的二进制补码整数 $x$， $x$ 或 $-x$ 中至少有一个的最高有效位为1。对于 $x=0$， $x$ 和 $-x$ 的所有位都为0。\n\n您的程序必须：\n1. 通过计算确定实现中 `unsigned long long` 类型的位宽 $w$（不要假设固定宽度）。\n2. 从第一性原理出发，仅使用位或、取反（二进制补码）和移位运算，推导出一个掩码函数 $m(x)$，使得当 $x = 0$ 时，$m(x)$ 的值等于字宽全为1，否则等于字宽全为0。\n3. 使用 $m(x)$ 实现一个无分支选择函数，当 $x = 0$ 时返回默认值 $d$，否则返回 $x$。选择过程必须纯粹用算术和逻辑指令表示。不得使用条件语句、用于分支的库调用以及任何未定义行为。\n4. 同样，仅使用基于相同推理基础的位/算术指令，计算一个零指示符 $z(x)$，当 $x = 0$ 时其值为1，否则为0。\n\n测试套件：\n根据计算出的 $w$，使用带符号的 $x$ 和带符号的默认值 $d$ 作为 $w$ 位值。构建以下六个测试用例：\n- 用例1：$x = 13$, $d = 99$。\n- 用例2：$x = 0$, $d = -42$。\n- 用例3：$x = -7$, $d = 123$。\n- 用例4：$x = -\\left(1 \\ll (w - 1)\\right)$, $d = 555$。\n- 用例5：$x = \\left(1 \\ll (w - 1)\\right) - 1$, $d = 777$。\n- 用例6：$x = 0$, $d = 0$。\n\n输出规格：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。对于每个测试用例，输出零指示符 $z(x)$，后跟无分支选择的结果。因此，如果有6个测试用例，最终输出行必须包含12个整数，格式如下\n$[z(x_1),\\text{sel}(x_1,d_1),z(x_2),\\text{sel}(x_2,d_2),\\ldots,z(x_6),\\text{sel}(x_6,d_6)]$。\n所有输出均为无单位整数，您必须确保不打印任何其他文本。",
            "solution": "该问题被评估为有效，因为它科学地基于二进制补码算术和位运算的原理，问题陈述清晰，目标和约束明确，并且没有任何事实不准确、含糊不清或矛盾之处。\n\n解决方案分四个阶段进行：计算系统的位宽、推导用于零测试的无分支掩码、使用该掩码实现无分支选择机制，以及推导零指示符。所有步骤都严格按照规定，仅依赖于算术和逻辑指令。\n\n### 步骤1：确定位宽 $w$\n\n位操作算法，特别是涉及最高有效位（MSB）的算法，依赖于字长，记为 $w$。问题要求通过计算来确定 `unsigned long long` 类型的位宽 $w$。虽然在C语言中最直接的方法是使用编译时表达式 `$sizeof(\\text{unsigned long long}) * 8$`，但也可以通过编程计算实现：将一个所有位都设置为1的变量不断右移，直到它变为0，并计算移位次数。设 `v = ~0ULL`。使 `v` 变为0所需的移位次数即为 $w$。在实现中，我们使用一个循环：`while(v > 0) \\{ v >>= 1; w++; \\}`。这个计算出的 $w$ 值将用于所有后续的位移计算。对于典型的64位架构，$w$ 将是64。\n\n### 步骤2：零测试掩码 $m(x)$ 的推导\n\n问题的核心是创建一个掩码 $m(x)$，如果输入整数 $x$ 为0，该掩码的值为一个全为1的字（即二进制补码中的-1，或 `~0`），否则为一个全为0的字。推导基于所提供的原理：对于任何非零带符号整数 $x$， $x$ 或其相反数 $-x$ 中至少有一个的最高有效位（MSB）为1。对于 $x=0$， $x$ 和 $-x$ 都是0，所以它们的MSB都是0。\n\n将一个带符号的 $w$ 位整数 $y$ 进行 $w-1$ 位的算术右移，记为 $y \\gg (w-1)$，会将符号位传播到整个字。如果 $y$ 是负数（MSB为1），此操作的结果是全1（-1）；如果 $y$ 是非负数（MSB为0），结果是全0（0）。\n\n让我们利用这个性质构造一个中间值 $I(x)$：\n$$ I(x) = (x \\gg (w-1)) \\lor (-x \\gg (w-1)) $$\n其中 $\\lor$ 表示位或运算。我们对 $x$ 的所有可能值分析这个表达式：\n- **情况1：$x > 0$**。值 $x$ 是非负数，所以 $x \\gg (w-1)$ 结果为0。值 $-x$ 是负数，所以 $-x \\gg (w-1)$ 结果为-1。最终结果是 $I(x) = 0 \\lor (-1) = -1$（全1）。\n- **情况2：$x  0$**。值 $x$ 是负数，所以 $x \\gg (w-1)$ 结果为-1。与-1进行位或运算的结果总是-1，无论 $-x \\gg (w-1)$ 的值是多少。因此，$I(x) = -1$（全1）。即使对于 $x = T_{\\text{min}}$（此时 $-x = x$），此结论也成立。\n- **情况3：$x = 0$**。$x$ 和 $-x$ 都是0。由于它们都是非负数，$x \\gg (w-1)$ 是0，$-x \\gg (w-1)$ 也是0。结果是 $I(x) = 0 \\lor 0 = 0$。\n\n总而言之，如果 $x \\neq 0$，$I(x)$ 为-1（全1）；如果 $x=0$，$I(x)$ 为0。这正是所需掩码 $m(x)$ 的逻辑反。为了得到 $m(x)$，我们对 $I(x)$ 应用位非（$\\neg$）运算：\n$$ m(x) = \\neg I(x) = \\neg \\left( (x \\gg (w-1)) \\lor (-x \\gg (w-1)) \\right) $$\n$m(x)$ 的这个表达式在 $x=0$ 时值为-1（全1），在 $x \\neq 0$ 时值为0，仅使用取反、位或和移位操作就满足了要求。\n\n### 步骤3：零指示符 $z(x)$ 的推导\n\n问题要求一个零指示符函数 $z(x)$，当 $x=0$ 时返回整数1，否则返回0。这可以直接从掩码 $m(x)$ 推导出来。\n- 如果 $x=0$，$m(x)$ 是一个全为1的字（`...1111`）。其最高有效位为1。\n- 如果 $x \\neq 0$，$m(x)$ 是一个全为0的字（`...0000`）。其最高有效位为0。\n\n因此，$z(x)$ 就是 $m(x)$ 的最高有效位。要提取最高有效位，我们可以对 $m(x)$ 执行 $w-1$ 位的逻辑右移。必须使用逻辑移位来确保空出的位被0填充。在C语言中，可以通过先将值强制转换为其无符号等价类型来保证这一点。\n$$ z(x) = ((\\text{unsigned long long})m(x)) \\gg (w-1) $$\n该表达式在 $x=0$ 时产生1，在 $x \\neq 0$ 时产生0。\n\n### 步骤4：无分支选择函数 $\\text{sel}(x,d)$ 的实现\n\n最后的任务是实现一个无分支选择函数 $\\text{sel}(x,d)$，当 $x=0$ 时返回默认值 $d$，否则返回原始值 $x$。这可以通过使用掩码 $m(x)$ 和位运算来实现。无分支选择的标准公式是：\n$$ \\text{result} = (A \\land \\text{MASK}) \\lor (B \\land (\\neg \\text{MASK})) $$\n当MASK全为1时，选择值 $A$；当MASK全为0时，选择值 $B$。\n\n在我们的情况中，我们希望在 $x=0$ 时选择 $d$。这对应于我们的掩码 $m(x)$ 全为1的情况。我们希望在 $x \\neq 0$ 时选择 $x$，这对应于 $m(x)$ 全为0的情况。将我们的变量映射到公式中（$A=d$, $B=x$, $\\text{MASK}=m(x)$），我们得到：\n$$ \\text{sel}(x, d) = (d \\land m(x)) \\lor (x \\land (\\neg m(x))) $$\n让我们验证一下这个表达式：\n- 如果 $x=0$：$m(x)=-1$（全1），且 $\\neg m(x)=0$。表达式变为 $(d \\land (-1)) \\lor (x \\land 0)$，简化为 $d \\lor 0 = d$。\n- 如果 $x \\neq 0$：$m(x)=0$，且 $\\neg m(x)=-1$。表达式变为 $(d \\land 0) \\lor (x \\land (-1))$，简化为 $0 \\lor x = x$。\n\n该逻辑是正确的，并且仅使用位与（$\\land$）、位或（$\\lor$）和位非（$\\neg$）运算就实现了所需的选择功能，完全避免了条件分支。",
            "answer": "```c\n// This program is designed to be self-contained and adheres to the C23 standard.\n// It uses only the specified headers and implements branchless logic as required.\n#include\n```"
        }
    ]
}