{
    "hands_on_practices": [
        {
            "introduction": "在系统设计中，选择使用编程I/O（PIO）还是直接内存访问（DMA）是一项基本决策。PIO实现简单，但每次数据传输都需要CPU的持续介入；而DMA的设置更为复杂，但它能将CPU从繁重的数据搬运工作中解放出来。本练习将指导你进行定量分析，计算出两种方式效率相当的“盈亏平衡点”，从而帮助你理解对于多大的数据块，设置DMA所带来的开销才是值得的。",
            "id": "3648466",
            "problem": "处理器通过程序化输入/输出 (PIO) 或直接内存访问 (DMA) 两种方式与高级技术附件 (ATA) 磁盘通信。在程序化输入/输出 (PIO) 模式下，中央处理器 (CPU) 主动传输每个数据字，每个字会产生 $c_{pio}$ 个 CPU 周期的开销。在直接内存访问 (DMA) 模式下，DMA 控制器在 CPU 完成一次性设置后自主移动数据，这会产生一个固定的 $c_{setup}$ 个 CPU 周期的设置开销，在传输过程中没有额外的按字计算的 CPU 周期开销。假设 CPU 时钟周期为 $T_{clk}$，并且移动数据块的设备到内存的总线传输时间对于 PIO 和 DMA 来说是相同的，仅取决于以字为单位的块大小 $S$，而与方法无关；因此，在比较总传输时间时，这个总线传输时间可以被视为一个公共项。\n\n仅使用时间和周期计数的第一性原理，即 CPU 已用时间是周期数和 CPU 时钟周期的乘积，推导出最小的整数块大小 $S^{*}$（以字为单位），使得使用 DMA 的总传输时间严格小于使用 PIO 的总传输时间。请用包含 $c_{setup}$ 和 $c_{pio}$ 的闭式解析表达式来表示你的最终答案。无需进行四舍五入。以字为单位，给出你的 $S^{*}$ 答案。",
            "solution": "该问题要求推导出最小的整数块大小，记为 $S^{*}$，使得使用直接内存访问 (DMA) 的数据传输严格快于使用程序化输入/输出 (PIO)。比较的标准是总传输时间。\n\n设 $S$ 是以字为单位的块大小。已知条件如下：\n- $c_{pio}$: PIO 模式下每个字的 CPU 开销，以周期为单位。\n- $c_{setup}$: DMA 模式下固定的 CPU 设置开销，以周期为单位。\n- $T_{clk}$: CPU 时钟周期。\n\n问题指出“CPU 已用时间是周期数和 CPU 时钟周期的乘积”。我们可以利用这个原理来为 PIO 和 DMA 的 CPU 相关时间成本建模。问题还明确指出，两种方法的总线传输时间是相同的，因此在比较总时间时它会相互抵消。\n\n我们来定义 PIO 传输的总时间 $T_{total, PIO}$ 和 DMA 传输的总时间 $T_{total, DMA}$。这些时间包括 CPU 时间开销和总线数据传输时间。设 $T_{bus}(S)$ 是在总线上传输大小为 $S$ 的块所需的时间。\n\n对于大小为 $S$ 字的块的 PIO 传输，CPU 参与传输每个字。所消耗的 CPU 总周期数是块大小与每字周期开销的乘积。\n$$ N_{cycles, PIO} = S \\cdot c_{pio} $$\nPIO 对应的 CPU 时间 $T_{CPU, PIO}$ 为：\n$$ T_{CPU, PIO} = N_{cycles, PIO} \\cdot T_{clk} = (S \\cdot c_{pio}) \\cdot T_{clk} $$\n因此，PIO 传输的总时间为：\n$$ T_{total, PIO} = T_{CPU, PIO} + T_{bus}(S) = (S \\cdot c_{pio}) \\cdot T_{clk} + T_{bus}(S) $$\n\n对于大小为 $S$ 字的块的 DMA 传输，CPU 只执行初始设置。此后，DMA 控制器管理传输，CPU 可以自由执行其他任务。所消耗的 CPU 周期数是一个固定的设置成本，与块大小无关。\n$$ N_{cycles, DMA} = c_{setup} $$\nDMA 对应的 CPU 时间 $T_{CPU, DMA}$ 为：\n$$ T_{CPU, DMA} = N_{cycles, DMA} \\cdot T_{clk} = c_{setup} \\cdot T_{clk} $$\nDMA 传输的总时间为：\n$$ T_{total, DMA} = T_{CPU, DMA} + T_{bus}(S) = c_{setup} \\cdot T_{clk} + T_{bus}(S) $$\n\n我们正在寻找 DMA 传输严格快于 PIO 传输的条件。这可以转化为以下不等式：\n$$ T_{total, DMA}  T_{total, PIO} $$\n代入总时间的表达式：\n$$ c_{setup} \\cdot T_{clk} + T_{bus}(S)  (S \\cdot c_{pio}) \\cdot T_{clk} + T_{bus}(S) $$\n总线传输时间 $T_{bus}(S)$ 是不等式两边的公共项，可以消去。\n$$ c_{setup} \\cdot T_{clk}  (S \\cdot c_{pio}) \\cdot T_{clk} $$\n由于 CPU 时钟周期 $T_{clk}$ 是一个物理时间长度，它必须是一个正值 ($T_{clk}  0$)。我们可以将不等式两边同时除以 $T_{clk}$ 而不改变其方向。\n$$ c_{setup}  S \\cdot c_{pio} $$\n为了求解 $S$，我们必须考虑 $c_{pio}$ 的值。$c_{pio}$ 项表示每个字的 CPU 周期开销。为了使问题具有物理意义，并且存在一个 DMA 变得更有优势的交叉点，这个开销必须是正的 ($c_{pio}  0$)。如果 $c_{pio}$ 为零或负，PIO 将总是至少与 DMA 一样快（假设设置成本 $c_{setup}$ 为非负）。假设 $c_{pio}  0$，我们可以用它来除以两边以分离出 $S$：\n$$ \\frac{c_{setup}}{c_{pio}}  S $$\n或者，将 $S$ 写在左边：\n$$ S  \\frac{c_{setup}}{c_{pio}} $$\n问题要求满足此条件的最小整数块大小 $S^{*}$。设 $R = \\frac{c_{setup}}{c_{pio}}$。条件是 $S  R$。满足此条件的整数集合是 $\\{ k \\in \\mathbb{Z} \\mid k  R \\}$。该集合中的最小整数是紧跟在 $R$ 值之后的整数。这可以用向下取整函数（floor function）来正式表达，该函数给出小于或等于其参数的最大整数。大于 $R$ 的最小整数是 $\\lfloor R \\rfloor + 1$。\n例如，如果 $R = 15.3$，条件是 $S  15.3$。最小整数 $S$ 是 $16$，即 $\\lfloor 15.3 \\rfloor + 1 = 15 + 1$。如果 $R$ 是一个整数，比如说 $R = 15$，条件是 $S  15$。最小整数 $S$ 同样是 $16$，即 $\\lfloor 15 \\rfloor + 1 = 15 + 1$。\n因此，最小整数块大小 $S^{*}$ 由下式给出：\n$$ S^{*} = \\left\\lfloor \\frac{c_{setup}}{c_{pio}} \\right\\rfloor + 1 $$\n这个表达式提供了以字为单位的块大小的盈亏平衡点。对于任何块大小 $S \\ge S^{*}$，DMA 方法将具有更低或相等的 CPU 时间成本。由于问题要求严格小于的时间，因此 $S^{*}$ 是该条件成立的第一个整数值。",
            "answer": "$$\n\\boxed{\\left\\lfloor \\frac{c_{setup}}{c_{pio}} \\right\\rfloor + 1}\n$$"
        },
        {
            "introduction": "除了数据传输本身，I/O面临的另一个关键挑战是CPU如何得知设备需要服务。这可以通过连续的轮询（polling）或使用硬件中断（interrupt）来实现。本练习对这两种策略的CPU成本进行建模，让你能够计算出关键的事件到达率，在该速率下，中断驱动方式的效率开始优于忙等待轮询所带来的持续开销。",
            "id": "3648479",
            "problem": "单个设备生成一个事件流，该事件流可建模为速率为每秒 $\\lambda$ 个事件的泊松过程。一个时钟频率为每秒 $f$ 个周期的中央处理器 (CPU) 必须使用以下两种输入/输出 (I/O) 策略之一来处理每个事件：\n\n- 忙等待轮询：当系统配置为轮询时，CPU 在其他情况下是空闲的，并执行一个紧凑循环，重复读取设备状态寄存器。每次轮询迭代消耗 $c_p$ 个周期。当检测到事件时，将执行处理程序代码；假设无论采用何种 I/O 策略，处理程序代码都是相同的，因此任何单位事件的服务周期都是共同的，为了比较开销，无需单独建模。因为当 CPU 被分配用于轮询时，轮询循环会持续运行，所以在稳态下，除了被处理程序执行所取代外，它会消耗可用的指令发射能力；因此，归因于轮询循环和处理程序调用的总周期消耗不能超过每秒 $f$ 个周期。\n\n- 中断驱动 I/O：当系统配置为中断时，每个事件的到达都会触发一个中断，处理该事件会产生 $c_i$ 个周期的开销，包括上下文保存和处理程序执行。\n\n将 I/O 的 CPU 利用率定义为 I/O 机制（包括处理程序执行）每秒消耗的 CPU 周期期望值除以 $f$。仅使用基本速率论证和上述定义，确定事件到达速率 $\\lambda^{\\star}$，在该速率下，中断驱动策略与轮询策略的 CPU 利用率相同。将最终答案表示为关于 $f$ 和 $c_i$ 的闭式解析表达式。以每秒事件数为单位表示最终速率。无需进行数值代入，也无需进行舍入。",
            "solution": "问题要求确定事件到达速率 $\\lambda^{\\star}$，在该速率下，中断驱动 I/O 策略的 CPU 利用率与忙等待轮询策略的 CPU 利用率相等。我们首先根据所提供的定义，为每种情况下的 CPU 利用率建立正式模型。\n\nI/O 的 CPU 利用率 $U_{I/O}$ 定义为 I/O 机制每秒消耗的 CPU 周期期望值除以每秒可用的总周期数，即 CPU 时钟频率 $f$。\n$$\nU_{I/O} = \\frac{\\text{E}[\\text{每秒用于 I/O 的周期数}]}{f}\n$$\n\n首先我们来分析中断驱动 I/O 策略。事件以泊松过程的形式到达，平均速率为每秒 $\\lambda$ 个事件。每个事件触发一个中断，处理该中断需要消耗 $c_i$ 个 CPU 周期。因此，中断机制每秒消耗的 CPU 周期期望值是平均事件速率与单位事件周期成本的乘积。\n$$\n\\text{E}[\\text{每秒用于中断的周期数}] = \\lambda \\cdot c_i\n$$\n中断驱动策略的 CPU 利用率 $U_{int}$ 则由下式给出：\n$$\nU_{int} = \\frac{\\lambda c_i}{f}\n$$\n\n接下来，我们分析忙等待轮询策略。问题陈述中指出，在使用此策略时，“CPU 在其他情况下是空闲的，并执行一个紧凑循环，重复读取设备状态寄存器”，并且“当 CPU 分配给轮询任务时，轮询循环会持续运行”。这意味着 CPU 永久地专用于 I/O 任务。它要么在执行轮询循环，要么在检测到事件时执行事件处理程序。问题规定了“I/O 的 CPU 利用率是 I/O 机制（包括处理程序执行）每秒消耗的 CPU 周期的期望值”。由于 CPU 始终忙于轮询或处理，因此该 I/O 机制每秒消耗的总周期数等于 CPU 每秒可执行的总周期数，即其频率 $f$。\n$$\n\\text{E}[\\text{每秒用于轮询的周期数}] = f\n$$\n因此，忙等待轮询策略的 CPU 利用率 $U_{poll}$ 为：\n$$\nU_{poll} = \\frac{f}{f} = 1\n$$\n这表明，如上所述的忙等待轮询策略，其本质是消耗分配给它的 CPU 容量的 $100\\%$。参数 $c_p$（单次轮询迭代的成本）对于计算此总利用率而言是无关信息，因为这种忙等待实现的定义性特征是其连续、全时运行。\n\n为了找到临界事件速率 $\\lambda^{\\star}$，我们将两种策略的利用率设为相等：$U_{int} = U_{poll}$。\n$$\n\\frac{\\lambda^{\\star} c_i}{f} = 1\n$$\n对该方程求解 $\\lambda^{\\star}$，得到所需的表达式：\n$$\n\\lambda^{\\star} = \\frac{f}{c_i}\n$$\n这个结果具有物理意义。它代表了中断驱动系统在达到饱和（即其自身的 CPU 利用率达到 $100\\%$）之前所能处理的最大事件速率。在此特定速率下，其利用率等于忙等待轮询系统恒定的 $100\\%$ 利用率。对于任何速率 $\\lambda  \\lambda^{\\star}$，中断驱动方法在 CPU 周期消耗方面更有效率。表达式的单位是 $\\frac{\\text{周期/秒}}{\\text{周期/事件}}$，正确地得出了 事件/秒。",
            "answer": "$$\\boxed{\\frac{f}{c_i}}$$"
        },
        {
            "introduction": "为大批量数据传输选择了DMA之后，下一步是调整其参数以获得最佳性能。DMA控制器以“突发”（burst）的方式移动数据，突发大小直接影响系统吞吐率和响应能力。在本练习中，你将学习如何确定最优的突发大小，以在满足一个关键系统约束（即CPU可被阻塞的最长时间）的前提下，最大化数据传输速度。",
            "id": "3648441",
            "problem": "一个片上系统采用直接内存访问 (DMA) 技术，通过共享系统总线将数据从主内存移动到设备。DMA 控制器发出重复的突发传输，每次突发传输按顺序包括三个阶段：持续时间为 $\\ell$ 的总线仲裁阶段，持续时间为 $o$ 的固定控制器开销阶段，以及持续时间为移动的总字节数 $b$ 除以总线传输速率 $\\rho$ 的数据移动阶段。中央处理器 (CPU) 只有在 DMA 未占用总线时才能访问总线；因此，在 DMA 占用总线期间（即开销和数据移动阶段），CPU 会发生停顿。总线仲裁阶段不会导致 CPU 停顿。\n\n假设系统在稳态下运行，DMA 突发传输连续进行。使用以下数值：\n- 仲裁延迟 $\\ell = 1$ 微秒，\n- 每次突发传输的开销 $o = 2$ 微秒，\n- 总线传输速率 $\\rho = 1600$ 字节/微秒，\n- 每次突发传输允许的最大 CPU 停顿时间 $L_{\\text{stall}} = 20$ 微秒，\n- 总线节拍粒度 $s = 64$ 字节（每次突发传输的大小必须是 $s$ 的整数倍）。\n\n从上面阐述的吞吐量和停顿约束的定义出发，确定能够最大化稳态 DMA 吞吐量的突发传输大小 $b$（以字节为单位），同时满足每次突发传输的最大 CPU 停顿时间小于或等于 $L_{\\text{stall}}$ 的要求。您的答案必须是一个单一的数字，并且必须以字节表示。不需要按有效数字进行四舍五入；请严格遵守总线粒度 $s$。",
            "solution": "目标是找到在给定约束条件下，能够最大化稳态 DMA 吞吐量的突发传输大小 $b$（以字节为单位）。\n\n首先，我们定义稳态 DMA 吞吐量，用 $\\Theta$ 表示。吞吐量是单位时间内传输的有效数据量。在连续突发传输的稳态下，一个周期的总时间是单次突发传输的持续时间 $T_{burst}$。\n\n单次突发传输的持续时间是其三个阶段的总和：\n1.  仲裁时间：$T_{arb} = \\ell$\n2.  开销时间：$T_{ovh} = o$\n3.  数据移动时间：$T_{data} = \\frac{b}{\\rho}$\n\n单次突发传输的总时间为：\n$$ T_{burst} = T_{arb} + T_{ovh} + T_{data} = \\ell + o + \\frac{b}{\\rho} $$\n\n单次突发传输的数据量为 $b$。因此，稳态吞吐量 $\\Theta(b)$ 作为突发传输大小 $b$ 的函数是：\n$$ \\Theta(b) = \\frac{\\text{Data Transferred}}{\\text{Total Time}} = \\frac{b}{T_{burst}} = \\frac{b}{\\ell + o + \\frac{b}{\\rho}} $$\n\n为了理解吞吐量如何依赖于突发传输大小 $b$，我们分析函数 $\\Theta(b)$。我们可以将其重写为：\n$$ \\Theta(b) = \\frac{b \\rho}{(\\ell + o)\\rho + b} $$\n为了确定该函数是否有最大值或是否单调，我们计算它关于 $b$ 的导数：\n$$ \\frac{d\\Theta}{db} = \\frac{(\\rho)((\\ell + o)\\rho + b) - (b\\rho)(1)}{((\\ell + o)\\rho + b)^2} = \\frac{(\\ell + o)\\rho^2 + b\\rho - b\\rho}{((\\ell + o)\\rho + b)^2} = \\frac{(\\ell + o)\\rho^2}{((\\ell + o)\\rho + b)^2} $$\n鉴于 $\\ell  0$，$o  0$ 且 $\\rho  0$，分子 $(\\ell + o)\\rho^2$ 严格为正。分母是一个平方项，因此对于任何有效的 $b$ 也为正。因此，对于所有 $b  0$，都有 $\\frac{d\\Theta}{db}  0$。这证明了吞吐量 $\\Theta(b)$ 是关于突发传输大小 $b$ 的单调递增函数。\n\n为了最大化吞吐量 $\\Theta(b)$，我们必须选择满足问题所有约束的 $b$ 的最大可能值。\n\n接下来，我们将 $b$ 的约束形式化。\n\n**约束 1：最大 CPU 停顿**\n当 DMA 控制器占用总线时，CPU 会发生停顿，这发生在开销和数据移动阶段。每次突发传输的总停顿时间 $T_{stall}$ 为：\n$$ T_{stall} = T_{ovh} + T_{data} = o + \\frac{b}{\\rho} $$\n问题规定，此停顿时间不得超过允许的最大停顿时间 $L_{\\text{stall}}$：\n$$ o + \\frac{b}{\\rho} \\le L_{\\text{stall}} $$\n求解 $b$，我们得到突发传输大小的上限：\n$$ \\frac{b}{\\rho} \\le L_{\\text{stall}} - o $$\n$$ b \\le \\rho (L_{\\text{stall}} - o) $$\n\n**约束 2：总线粒度**\n突发传输大小 $b$ 必须是总线节拍粒度 $s$ 的整数倍。\n$$ b = k \\cdot s, \\quad \\text{其中 } k \\text{ 是一个正整数 } (k \\in \\{1, 2, 3, \\dots\\}) $$\n\n为了找到最优突发传输大小 $b_{opt}$，我们必须找到满足这两个约束的 $b$ 的最大值。该值将是小于或等于从停顿约束导出的最大值的 $s$ 的最大整数倍。\n设 $b_{max\\_limit} = \\rho(L_{\\text{stall}} - o)$。我们需要找到最大的 $b$，使得 $b = k \\cdot s$ 且 $b \\le b_{max\\_limit}$。这等价于找到最大的整数 $k$，使得 $k \\cdot s \\le b_{max\\_limit}$，即 $k_{max} = \\left\\lfloor \\frac{b_{max\\_limit}}{s} \\right\\rfloor$。\n那么，最优突发传输大小为：\n$$ b_{opt} = s \\cdot k_{max} = s \\cdot \\left\\lfloor \\frac{\\rho(L_{\\text{stall}} - o)}{s} \\right\\rfloor $$\n\n现在，我们代入给定的数值：\n- $\\rho = 1600$ 字节/$\\mu$s\n- $L_{\\text{stall}} = 20$ $\\mu$s\n- $o = 2$ $\\mu$s\n- $s = 64$ 字节\n\n首先，计算 $b$ 的最大限制：\n$$ b_{max\\_limit} = 1600 \\frac{\\text{bytes}}{\\mu s} \\times (20 \\mu s - 2 \\mu s) = 1600 \\frac{\\text{bytes}}{\\mu s} \\times 18 \\mu s = 28800 \\text{ bytes} $$\n\n所以，我们必须有 $b \\le 28800$ 字节。\n\n接下来，我们应用粒度约束。我们需要找到小于或等于 $28800$ 字节的 $s = 64$ 字节的最大倍数。\n$$ k_{max} = \\left\\lfloor \\frac{28800}{64} \\right\\rfloor $$\n我们来执行除法：\n$$ \\frac{28800}{64} = \\frac{14400}{32} = \\frac{7200}{16} = \\frac{3600}{8} = \\frac{1800}{4} = 450 $$\n由于结果是整数，所以 $\\left\\lfloor 450 \\right\\rfloor = 450$。\n所以，$k_{max} = 450$。\n\n最优突发传输大小 $b_{opt}$ 是：\n$$ b_{opt} = s \\cdot k_{max} = 64 \\text{ bytes} \\times 450 = 28800 \\text{ bytes} $$\n\n此突发传输大小在遵守 CPU 停顿限制和总线粒度要求的同时，最大化了 DMA 吞吐量。",
            "answer": "$$\\boxed{28800}$$"
        }
    ]
}