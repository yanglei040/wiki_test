{
    "hands_on_practices": [
        {
            "introduction": "Understanding the theory behind stack frames is one thing; building one is another. This first exercise challenges you to act like a compiler and meticulously construct the memory layout of a function's activation record based on the rules of a real-world Application Binary Interface (ABI). By calculating byte offsets and accounting for data alignment, you will gain a concrete understanding of how local variables, arguments, and function call mechanics are physically organized in memory . This practice is fundamental to low-level programming, debugging, and reverse engineering.",
            "id": "3680344",
            "problem": "A function in the System V Application Binary Interface (SysV ABI) for the Advanced Micro Devices 64-bit architecture (AMD64) receives its first six integer arguments in registers and any additional integer arguments on the stack. The stack grows toward lower addresses. The caller performs a call that pushes the return address, and the callee executes a standard prologue that pushes the Base Pointer ($\\mathrm{RBP}$), sets $\\mathrm{RBP}$ to the Stack Pointer ($\\mathrm{RSP}$), and then subtracts a contiguous block for local storage. In this environment, the alignment invariant is that immediately before any call, $\\mathrm{RSP}$ must be aligned to a $16$-byte boundary. The function described here is non-variadic, uses a frame pointer, calls another function (so it cannot rely on the red zone), and pushes no callee-saved registers other than $\\mathrm{RBP}$.\n\nYou are given that the function has exactly $7$ integer arguments and three local variables with sizes and alignment requirements:\n- Local $L_{1}$ has size $8$ bytes and requires $8$-byte alignment.\n- Local $L_{2}$ has size $16$ bytes and requires $16$-byte alignment.\n- Local $L_{3}$ has size $24$ bytes and requires $8$-byte alignment.\n\nAssume the locals are allocated in source order $L_{1}$, then $L_{2}$, then $L_{3}$, laid out contiguously from higher to lower addresses, inserting only the minimal padding necessary to satisfy each local’s stated alignment relative to $\\mathrm{RBP}$. Define the “base address” of each local as the lowest addressed byte of the local’s storage, and define all byte offsets relative to $\\mathrm{RBP}$.\n\nStarting from the fundamental facts above (stack grows down, the call instruction pushes the return address, the prologue pushes and sets $\\mathrm{RBP}$, SysV ABI register/stack argument rules, and the $16$-byte alignment requirement for $\\mathrm{RSP}$ at call sites), reconstruct the exact stack frame layout by:\n1. Determining the base offsets (relative to $\\mathrm{RBP}$) for $L_{1}$, $L_{2}$, and $L_{3}$, satisfying their alignment requirements and non-overlap.\n2. Determining the offset (relative to $\\mathrm{RBP}$) of the seventh integer argument.\n3. Determining the minimal number of additional padding bytes that must be added to the local area (beyond what is required for the locals themselves) so that immediately before any call from this function, $\\mathrm{RSP}$ is aligned to a $16$-byte boundary.\n\nExpress your final answer as a row matrix in the order $\\left(L_{1}, L_{2}, L_{3}, \\text{arg}_{7}, \\text{padding}\\right)$, where each entry is the required offset or padding in bytes. No rounding is required.",
            "solution": "The solution is derived by reconstructing the stack frame layout based on the rules of the System V AMD64 ABI. All offsets are relative to the base pointer, `RBP`, after the function prologue has executed.\n\n**2.1. Determine the Alignment of RBP**\nFirst, we establish the alignment of the base pointer `RBP`.\n1.  The ABI specifies that immediately before a `call` instruction, the stack pointer `RSP` must be aligned to a $16$-byte boundary. Let the caller's `RSP` before calling our function be $S_{caller}$, where $S_{caller} \\pmod{16} = 0$.\n2.  The `call` instruction pushes the $8$-byte return address onto the stack. Thus, upon entry to our function, the `RSP` is at address $S_{caller} - 8$. The value of `RSP` at entry is therefore $16k - 8$ for some integer $k$, which means $RSP \\pmod{16} = 8$. This is consistent with the ABI requirement that `(RSP + 8)` is a multiple of $16$ at function entry.\n3.  The first instruction of the callee's prologue is `push RBP`. This pushes the $8$-byte value of the old `RBP` and decrements `RSP` by $8$. The `RSP` is now at $(S_{caller} - 8) - 8 = S_{caller} - 16$. This address is a multiple of $16$.\n4.  The next instruction is `mov RBP, RSP`. This sets the new frame's base pointer `RBP` to the current value of `RSP`.\nTherefore, the value of `RBP` for the duration of our function is aligned to a $16$-byte boundary. This is a critical fact for determining the offsets of local variables.\n\n**2.2. Determine the Offset of the Seventh Argument (`arg_7`)**\nArguments are located at positive offsets from `RBP`.\n-   `[RBP + 0]`: This location stores the saved `RBP` from the caller's frame (pushed by our prologue).\n-   `[RBP + 8]`: This location stores the return address (pushed by the `call` instruction).\n-   The first six integer arguments are passed in registers. The seventh argument, `arg_7`, is the first to be passed on the stack. The caller places it on the stack before the `call`. It resides immediately above the return address.\n-   Therefore, the seventh argument is located at `[RBP + 16]`.\nThe offset of `arg_7` relative to `RBP` is $+16$ bytes.\n\n**2.3. Determine the Offsets of Local Variables ($L_1, L_2, L_3$)**\nLocal variables are stored at negative offsets from `RBP`. They are laid out from higher addresses (closer to `RBP`) to lower addresses. The problem specifies minimal padding to satisfy alignment constraints. We determined that `RBP` is $16$-byte aligned. An object at offset `off` from `RBP` has address `RBP + off`. For this address to have an alignment of `A`, we need `(RBP + off) \\pmod A = 0$. Since `RBP` is a multiple of any of the required alignments ($8$ or $16$), this simplifies to `off \\pmod A = 0$.\n\n-   **Layout of $L_{1}$ (size $8$, align $8$):**\n    $L_1$ is the first local variable, so it is placed closest to `RBP`. We need to find the base offset $off_1 < 0$ for an $8$-byte object that is $8$-byte aligned. To be as close to `RBP` as possible, we place its base at `RBP-8`. The offset is $off_1 = -8$. This satisfies the alignment, since $-8 \\pmod 8 = 0$.\n    -   $L_{1}$ occupies the memory range `[RBP - 8, RBP - 1]`.\n    -   The base offset for $L_1$ is $-8$.\n\n-   **Layout of $L_{2}$ (size $16$, align $16$):**\n    $L_2$ must be placed contiguously below $L_1$. The highest address used by $L_1$ is `RBP - 1`, so the next available address is `RBP - 9`. $L_2$ is a $16$-byte object, so its memory block is `[base, base + 15]`. The top of this block, `base + 15`, must be at an address less than or equal to `RBP - 9`.\n    In terms of offsets, let the base offset be $off_2$. The block is `[RBP + off_2, RBP + off_2 + 15]`.\n    We must have $off_2 + 15 \\le -9$, which implies $off_2 \\le -24$.\n    Additionally, the base offset must be $16$-byte aligned: $off_2 \\pmod{16} = 0$.\n    We need the largest integer offset (closest to $0$) that is a multiple of $16$ and is less than or equal to $-24$. This value is $-32$.\n    -   $L_{2}$ occupies the memory range `[RBP - 32, RBP - 17]`.\n    -   The base offset for $L_2$ is $-32$.\n    -   Note: This creates an $8$-byte padding area between `RBP - 16` and `RBP - 9`.\n\n-   **Layout of $L_{3}$ (size $24$, align $8$):**\n    $L_3$ is placed below $L_2$. The highest address used by $L_2$ is `RBP - 17`, so the next available address is `RBP - 18`. Let the base offset of $L_3$ be $off_3$. The block is `[RBP + off_3, RBP + off_3 + 23]`.\n    We must have $off_3 + 23 \\le -18$, which implies $off_3 \\le -41$.\n    Wait, the previous address available was `RBP-33`, not `-18`. $L_2$ range is `[RBP-32, RBP-17]`. Next available is `RBP-33`.\n    My apologies, a methodical error. Let's restart the layout of $L_3$.\n    $L_2$ occupies `[RBP - 32, RBP - 17]`. The next available address is `RBP - 33`.\n    The block for $L_3$ is `[RBP + off_3, RBP + off_3 + 23]`.\n    We must have $off_3 + 23 \\le -33$, which implies $off_3 \\le -56$.\n    The base offset must be $8$-byte aligned: $off_3 \\pmod 8 = 0$.\n    We need the largest integer offset that is a multiple of $8$ and is less than or equal to $-56$. This value is $-56$.\n    -   $L_{3}$ occupies the memory range `[RBP - 56, RBP - 33]`.\n    -   The base offset for $L_3$ is $-56$.\n    -   There is no padding between $L_2$ and $L_3$.\n\nThe total contiguous block of memory required for all local variables and their internal padding extends from `RBP - 1` down to `RBP - 56`, a total size of $56$ bytes.\n\n**2.4. Determine Additional Padding for Call Alignment**\nThe function calls another function, so it is non-leaf. The `RSP` must be $16$-byte aligned immediately before it issues a `call` instruction.\nThe local storage area occupies $56$ bytes. The prologue must allocate at least this much space via `sub RSP, N`.\nLet the total allocation be $N$ bytes, where $N = 56 + P$, and $P$ is the additional padding. After the prologue, `RSP = RBP - N`.\nA standard and robust compilation strategy is to align the stack pointer immediately after the prologue. This provides a correctly aligned stack for the function body to operate on, simplifying subsequent preparations for calls. To achieve this, the total local area allocation, `N`, must be a multiple of $16$, since `RBP` is $16$-byte aligned.\n-   Required size for locals: $56$ bytes.\n-   We need to find the smallest multiple of $16$, let's call it $N$, such that $N \\ge 56$.\n-   Multiples of $16$: $16, 32, 48, 64, ...$\n-   The smallest multiple of $16$ that is greater than or equal to $56$ is $64$.\n-   So, the total allocation size is $N=64$ bytes.\n-   The additional padding required is $P = N - 56 = 64 - 56 = 8$ bytes.\n\nWith this padding, the prologue instruction would be `sub RSP, 64`. The `RSP` would then be `RBP - 64`, which is $16$-byte aligned. When this function subsequently calls another function, `RSP` is already aligned (assuming the sub-call takes no stack arguments). If the sub-call requires stack arguments, the compiler performs further stack adjustments from this aligned base to prepare the arguments while maintaining the alignment invariant. The $8$ bytes of padding in the static frame is the minimal amount required to establish this aligned base.\n\n**Summary of Results:**\n-   Offset of $L_{1}$: $-8$ bytes.\n-   Offset of $L_{2}$: $-32$ bytes.\n-   Offset of $L_{3}$: $-56$ bytes.\n-   Offset of `arg_7`: $+16$ bytes.\n-   Additional padding: $8$ bytes.\n\nThe final answer is the row matrix of these values in the specified order.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-8 & -32 & -56 & 16 & 8\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "After mastering the rules for building a correct stack frame, the next step is to diagnose what happens when those rules are broken. This practice presents a classic and subtle bug: a mismatch in the calling convention between a function caller and the callee. Your task is to analyze the consequences of this mismatch, predict the resulting stack imbalance, and evaluate a method for detecting such errors at runtime . This exercise highlights that an ABI is a strict contract, and violating it leads to predictable, yet often elusive, bugs like stack corruption.",
            "id": "3680364",
            "problem": "An engineer is diagnosing a subtle stack imbalance in a system using a downward-growing stack on a $32$-bit Instruction Set Architecture (ISA). The system adheres to the typical Application Binary Interface (ABI) facts: a function call pushes a $4$-byte return address onto the stack, the called function may save the Frame Pointer (FP) by pushing it, and the callee sets up its activation record (locals and saved registers) but must restore them before return. Under the C Declaration (cdecl) calling convention, the caller deallocates the argument area after the call by adjusting the Stack Pointer (SP). Under the Standard Call (stdcall) calling convention, the callee deallocates the argument area before returning (for example via an epilogue that adds the total argument size to SP, or a return instruction that adds that size).\n\nA particular call site expects Standard Call (stdcall) and therefore performs no caller-side argument cleanup after the call. However, the target function was actually compiled using C Declaration (cdecl), so it does not deallocate its argument area. The function being called has $3$ arguments, each occupying $4$ bytes, and contains a standard prologue that saves the Frame Pointer (FP) and allocates locals, and a matching epilogue that restores them. The call site performs the following sequence each time it calls the function:\n- Record the current Stack Pointer (SP) in a temporary variable $sp_{\\text{pre}}$.\n- Push $3$ arguments of $4$ bytes each (total argument area $S = 12$ bytes).\n- Execute the call, which pushes a $4$-byte return address.\n- Upon return, perform no caller-side adjustment of SP.\n- Immediately record the Stack Pointer (SP) in $sp_{\\text{post}}$.\n\nAssume there are no intervening stack allocations or deallocations between consecutive calls at the call site other than what is described, and that the callee’s prologue and epilogue are perfectly balanced with respect to its own activation record (that is, aside from the argument area policy, the callee’s net effect on SP equals its entry state). Let $k$ denote the number of consecutive calls executed in a loop under this mismatch.\n\nSelect all statements that are correct:\n\nA. Under the described mismatch, the per-call drift of SP at the call site satisfies $sp_{\\text{post}} - sp_{\\text{pre}} = -S = -12$, and after $k$ consecutive calls the cumulative drift relative to the initial SP is $-12k$ bytes.\n\nB. Under the described mismatch, the per-call drift of SP at the call site satisfies $sp_{\\text{post}} - sp_{\\text{pre}} = +S = +12$, because both caller and callee attempt to deallocate the argument area.\n\nC. A robust runtime check for detecting a calling convention mismatch at the call site is: record SP immediately before pushing the arguments as $sp_{\\text{pre}}$, then after the function returns and before any caller cleanup record SP again as $sp_{\\text{post}}$; compute $\\Delta = sp_{\\text{post}} - sp_{\\text{pre}}$. If the call site expects Standard Call (stdcall), assert $\\Delta = 0$; if it expects C Declaration (cdecl), assert $\\Delta = -S$. Any violation indicates a mismatch.\n\nD. A more reliable runtime check is to compare the Frame Pointer (FP) before and after the call, because FP remains unchanged across calls under both conventions; therefore any change in FP indicates a calling convention mismatch.\n\nE. Because a call pushes a $4$-byte return address and a return pops it, the net change in SP across a well-matched call-return pair, ignoring argument cleanup, is $-4$ bytes; therefore comparing SP before the call and after the return will always differ by $-4$ bytes even when the calling conventions agree.",
            "solution": "### Principle-Based Derivation\nLet us trace the value of the Stack Pointer (SP) through one complete call cycle as described. The stack grows downwards, so pushing data decreases the SP value, and popping data increases it.\n\nLet $SP_{0}$ be the value of the stack pointer at the beginning of the sequence.\n\n1.  **Record $sp_{\\text{pre}}$**: According to the sequence, $sp_{\\text{pre}}$ is recorded first.\n    $$sp_{\\text{pre}} = SP_{0}$$\n2.  **Push arguments**: The caller pushes $3$ arguments, each $4$ bytes. The total size is $S = 12$ bytes.\n    $$SP \\text{ becomes } SP_{0} - 12$$\n3.  **Execute `call`**: The `call` instruction pushes the $4$-byte return address onto the stack.\n    $$SP \\text{ becomes } (SP_{0} - 12) - 4 = SP_{0} - 16$$\n    This is the value of the SP upon entry into the callee function.\n4.  **Callee Execution (`cdecl`)**:\n    - The callee executes its prologue (e.g., saving FP, allocating locals), body, and epilogue. The problem states that the prologue and epilogue are perfectly balanced for the callee's own frame (locals and saved registers). This means these operations have a net-zero effect on the SP from the callee's entry to the point just before its `ret` instruction.\n    - The callee is `cdecl`, so it **does not** deallocate the arguments passed to it.\n    - The `ret` instruction is executed. It pops the $4$-byte return address from the stack and jumps to it. This increases the SP by $4$ bytes.\n    - The SP value upon return to the caller is therefore $(SP_0 - 16) + 4 = SP_0 - 12$.\n5.  **Caller-side, post-return**:\n    - The caller was expecting a `stdcall` function, so it assumes the callee has cleaned up the arguments. Consequently, the caller performs **no** stack adjustment for the arguments.\n6.  **Record $sp_{\\text{post}}$**: The SP is immediately measured.\n    $$sp_{\\text{post}} = SP_{0} - 12$$\n7.  **Calculate Per-Call Drift**: The change in the stack pointer at the call site for one call is:\n    $$\\Delta SP = sp_{\\text{post}} - sp_{\\text{pre}} = (SP_{0} - 12) - SP_{0} = -12 \\text{ bytes}$$\n    Since $S = 12$ bytes, the drift is $\\Delta SP = -S$.\n8.  **Calculate Cumulative Drift**: Because there are no other intervening stack operations, this drift is cumulative. After $k$ consecutive calls, the total change in the stack pointer relative to its value before the first call will be:\n    $$\\text{Cumulative Drift} = k \\times \\Delta SP = -12k \\text{ bytes}$$\n\n### Option-by-Option Analysis\n\n**A. Under the described mismatch, the per-call drift of SP at the call site satisfies $sp_{\\text{post}} - sp_{\\text{pre}} = -S = -12$, and after $k$ consecutive calls the cumulative drift relative to the initial SP is $-12k$ bytes.**\nOur derivation shows that $sp_{\\text{post}} - sp_{\\text{pre}} = -12$ bytes. Since $S=12$ bytes, this is equal to $-S$. The cumulative drift after $k$ calls is correctly stated as $-12k$ bytes. This statement accurately describes the consequences of the specified mismatch, where neither the caller nor the callee deallocates the argument area, causing the stack to grow with each call.\n**Verdict: Correct.**\n\n**B. Under the described mismatch, the per-call drift of SP at the call site satisfies $sp_{\\text{post}} - sp_{\\text{pre}} = +S = +12$, because both caller and callee attempt to deallocate the argument area.**\nThis statement describes a different mismatch: a `cdecl` caller (which cleans the stack) calling a `stdcall` callee (which also cleans the stack). In that scenario, a \"double cleanup\" would occur, leading to a drift of $+S$. However, the problem specifies a `stdcall`-expecting caller (no cleanup) and a `cdecl` callee (no cleanup). In our case, neither party deallocates the arguments. Therefore, the premise and the conclusion of this option are both false for the given problem.\n**Verdict: Incorrect.**\n\n**C. A robust runtime check for detecting a calling convention mismatch at the call site is: record SP immediately before pushing the arguments as $sp_{\\text{pre}}$, then after the function returns and before any caller cleanup record SP again as $sp_{\\text{post}}$; compute $\\Delta = sp_{\\text{post}} - sp_{\\text{pre}}$. If the call site expects Standard Call (stdcall), assert $\\Delta = 0$; if it expects C Declaration (cdecl), assert $\\Delta = -S$. Any violation indicates a mismatch.**\nLet's analyze the proposed check for correctly matched conventions. The measurement points are the same as those in the main problem description.\n- **Well-matched `stdcall`**: The caller pushes arguments ($SP \\to SP - S$), calls, and the callee returns. A `stdcall` callee deallocates the $S$ bytes of arguments before returning (e.g., using a `ret S` instruction). The net effect on SP, from before pushing arguments to after the function returns, is $0$. So, for a `stdcall` site, we expect $\\Delta = sp_{\\text{post}} - sp_{\\text{pre}} = 0$. The assertion `assert \\Delta = 0` is correct.\n- **Well-matched `cdecl`**: The caller pushes arguments ($SP \\to SP - S$), calls, and the callee returns. A `cdecl` callee does not deallocate arguments. The SP value after the function returns but *before* the caller's cleanup is $sp_{\\text{post}} = sp_{\\text{pre}} - S$. Therefore, $\\Delta = -S$. The assertion `assert \\Delta = -S` is correct. (The caller would then perform an `add SP, S` to restore balance, but the check happens before this).\nSince the assertions correctly describe the expected behavior for both standard conventions, any result other than the expected one (e.g., getting $\\Delta = -S$ at a site expecting `stdcall`) correctly indicates a mismatch. This is a valid and robust checking mechanism.\n**Verdict: Correct.**\n\n**D. A more reliable runtime check is to compare the Frame Pointer (FP) before and after the call, because FP remains unchanged across calls under both conventions; therefore any change in FP indicates a calling convention mismatch.**\nA standard function prologue involves saving the caller's frame pointer (`push ebp` on x86) and the epilogue involves restoring it (`pop ebp`). This behavior is part of the Application Binary Interface (ABI) and is generally independent of the argument cleanup strategy (`cdecl` vs. `stdcall`). The problem states the callee has a \"standard prologue that saves the Frame Pointer... and a matching epilogue that restores them.\" Therefore, the callee, despite being `cdecl`, will correctly restore the caller's FP. Comparing the FP before and after the call would show no change, and this check would consequently **fail** to detect the stack imbalance caused by the argument cleanup mismatch. The SP-based check in option C is superior for this type of error.\n**Verdict: Incorrect.**\n\n**E. Because a call pushes a $4$-byte return address and a return pops it, the net change in SP across a well-matched call-return pair, ignoring argument cleanup, is $-4$ bytes; therefore comparing SP before the call and after the return will always differ by $-4$ bytes even when the calling conventions agree.**\nThis statement is fundamentally flawed. The `call` instruction decrements SP by $4$ bytes to push the return address. The corresponding `ret` instruction increments SP by $4$ bytes when it pops that same address into the program counter. The net effect of this matched pair of operations on the stack pointer is $4 - 4 = 0$. The change is not $-4$ bytes. The SP is transiently lower by $4$ bytes (or more) during the function execution, but it is restored by the `ret` instruction.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "Compilers work hard to make our programs efficient, and one key optimization involves minimizing the memory footprint of each function call. This final practice moves beyond the fixed layout of a stack frame to explore how its size can be optimized. By analyzing the \"live ranges\" of temporary variables, you will determine the minimum number of stack slots required by reusing the same memory for different variables that are not needed at the same time . This provides a hands-on look at the principles of liveness analysis and interference graphs, core concepts in compiler optimization.",
            "id": "3680337",
            "problem": "A function $g$ runs on a machine with a conventional stack-based calling convention. An activation record (stack frame) for a call to $g$ must contain the following fixed fields: the return address (one machine word), the saved frame pointer (one machine word), and two callee-saved registers that the callee chooses to use and therefore must preserve (two machine words). Assume each stack slot holds exactly one machine word, the stack grows in the direction consistent with the machine’s convention, and no additional padding or alignment constraints are required beyond these words. Beyond the fixed fields, $g$ has several stack-resident objects (spilled temporaries and locals) whose presence in the activation record is required only while their values are live. A single stack slot may be reused by multiple such objects provided their live ranges do not overlap in time.\n\nConsider a straight-line region of $g$ labeled by program points $p \\in \\{0,1,\\ldots,16\\}$, with live ranges for the stack-resident objects given as half-open intervals $[l,r)$, meaning the object becomes live immediately after point $l$ and remains live up to but not including point $r$. The objects and their live ranges are:\n- $A: [2,7)$\n- $B: [1,4)$\n- $C: [5,10)$\n- $D: [3,5)$\n- $E: [8,12)$\n- $F: [11,15)$\n- $L: [6,11)$\n- $T: [9,13)$\n\nAssume the return address and saved frame pointer are present throughout the call to $g$, and the two callee-saved registers used by $g$ are saved in the prologue and restored in the epilogue, so they occupy their slots for the entire duration of the function.\n\nUsing fundamental definitions of activation records, liveness, and interference (two objects interfere if their live ranges overlap, and therefore cannot occupy the same slot at the same time), reason from first principles to determine the minimal number of reusable spill/local slots and the minimal total activation record size (in machine words). Then select the option that correctly gives the minimal total size and provides a valid reuse mapping of objects to a minimal number of slots that achieves this size.\n\nOptions:\n\nA. Total activation record size is $8$ words. A valid reuse mapping with $4$ spill/local slots is: $s_1: B \\rightarrow C \\rightarrow F$, $s_2: A \\rightarrow E$, $s_3: D \\rightarrow L$, $s_4: T$.\n\nB. Total activation record size is $9$ words because the peak overlap among objects is $5$ at $[9,10)$. One possible mapping is $s_1: B$, $s_2: A$, $s_3: D \\rightarrow L$, $s_4: C$, $s_5: E \\rightarrow T \\rightarrow F$.\n\nC. Total activation record size is $6$ words; the mapping $s_1: B \\rightarrow C \\rightarrow F$, $s_2: A \\rightarrow E$, $s_3: D \\rightarrow L$, $s_4: T$ suffices for the spill/local portion.\n\nD. Total activation record size is $12$ words because reuse is impossible when calls are present; every object $A,B,C,D,E,F,L,T$ must have a dedicated slot, in addition to the four fixed words.\n\nE. Total activation record size is $8$ words; a mapping with $4$ spill/local slots is $s_1: A \\rightarrow C \\rightarrow E$, $s_2: B \\rightarrow F$, $s_3: D \\rightarrow L$, $s_4: T$.",
            "solution": "The problem asks for the minimal total size of the activation record for function $g$. This size is the sum of two components: the size of the fixed fields and the minimal size of the area for stack-resident local objects and spills.\n\n**1. Size of the Fixed Fields**\n\nThe problem states the activation record contains:\n- $1$ machine word for the return address.\n- $1$ machine word for the saved frame pointer.\n- $2$ machine words for two callee-saved registers.\n\nThese fields are present for the entire duration of the function. Therefore, the fixed part of the activation record has a size of:\n$$ S_{fixed} = 1 + 1 + 2 = 4 \\text{ machine words} $$\n\n**2. Minimal Size of the Spill/Local Area**\n\nThe spill/local area holds objects $A, B, C, D, E, F, L, T$. A stack slot can be reused for different objects provided their live ranges do not overlap. The minimum number of slots required is determined by the maximum number of objects that are simultaneously live at any point in time. This is equivalent to finding the maximum number of overlapping intervals among the given live ranges.\n\nThe live ranges are:\n- $A: [2,7)$\n- $B: [1,4)$\n- $C: [5,10)$\n- $D: [3,5)$\n- $E: [8,12)$\n- $F: [11,15)$\n- $L: [6,11)$\n- $T: [9,13)$\n\nLet's determine the number of live objects, denoted $N$, over the time interval defined by the program points. The number of live objects changes only at the start or end points of the intervals.\n\n- Interval $[1,2)$: Live objects are $\\{B\\}$. $N=1$.\n- Interval $[2,3)$: Live objects are $\\{B, A\\}$. $N=2$.\n- Interval $[3,4)$: Live objects are $\\{B, A, D\\}$. $N=3$.\n- Interval $[4,5)$: Live objects are $\\{A, D\\}$ (B's liveness ends at 4). $N=2$.\n- Interval $[5,6)$: Live objects are $\\{A, C\\}$ (D's liveness ends at 5, C's starts at 5). $N=2$.\n- Interval $[6,7)$: Live objects are $\\{A, C, L\\}$. $N=3$.\n- Interval $[7,8)$: Live objects are $\\{C, L\\}$ (A's liveness ends at 7). $N=2$.\n- Interval $[8,9)$: Live objects are $\\{C, L, E\\}$. $N=3$.\n- Interval $[9,10)$: Live objects are $\\{C, L, E, T\\}$. $N=4$.\n- Interval $[10,11)$: Live objects are $\\{L, E, T\\}$ (C's liveness ends at 10). $N=3$.\n- Interval $[11,12)$: Live objects are $\\{E, T, F\\}$ (L's liveness ends at 11, F's starts at 11). $N=3$.\n- Interval $[12,13)$: Live objects are $\\{T, F\\}$ (E's liveness ends at 12). $N=2$.\n- Interval $[13,15)$: Live objects are $\\{F\\}$ (T's liveness ends at 13). $N=1$.\n- Interval $[15, \\ldots)$: No objects are live. $N=0$.\n\nThe maximum number of simultaneously live objects is $4$, which occurs during the program point interval $[9,10)$, where the set of live objects is $\\{C, L, E, T\\}$. This means that at least $4$ distinct stack slots are required for the spill/local objects. This minimum is achievable because for interval graphs, the chromatic number equals the clique number.\n\nThus, the minimal size of the spill/local area is:\n$$ S_{local} = 4 \\text{ machine words} $$\n\n**3. Minimal Total Activation Record Size**\n\nThe minimal total size of the activation record is the sum of the fixed and minimal local sizes.\n$$ S_{total} = S_{fixed} + S_{local} = 4 + 4 = 8 \\text{ machine words} $$\n\n### Option-by-Option Analysis\n\nNow, we evaluate each option based on our derived results.\n\n**A. Total activation record size is $8$ words. A valid reuse mapping with $4$ spill/local slots is: $s_1: B \\rightarrow C \\rightarrow F$, $s_2: A \\rightarrow E$, $s_3: D \\rightarrow L$, $s_4: T$.**\n\n- **Total Size:** The stated size of $8$ words matches our calculation. Correct.\n- **Spill/Local Slots:** The mapping uses $4$ slots ($s_1, s_2, s_3, s_4$), which matches our calculated minimum. Correct.\n- **Mapping Validity:** We must check that objects mapped to the same slot do not have overlapping live ranges. Two intervals $[l_1, r_1)$ and $[l_2, r_2)$ do not overlap if $r_1 \\le l_2$ or $r_2 \\le l_1$.\n    - $s_1: B[1,4), C[5,10), F[11,15)$.\n        - $B$ and $C$: $4 < 5$. No overlap.\n        - $C$ and $F$: $10 < 11$. No overlap.\n        - This mapping is valid.\n    - $s_2: A[2,7), E[8,12)$.\n        - $A$ and $E$: $7 < 8$. No overlap.\n        - This mapping is valid.\n    - $s_3: D[3,5), L[6,11)$.\n        - $D$ and $L$: $5 < 6$. No overlap.\n        - This mapping is valid.\n    - $s_4: T[9,13)$.\n        - Only one object. This is valid.\nThe entire mapping is valid. The option provides the correct minimal size and a valid minimal slot mapping.\n- **Verdict:** Correct.\n\n**B. Total activation record size is $9$ words because the peak overlap among objects is $5$ at $[9,10)$. One possible mapping is $s_1: B$, $s_2: A$, $s_3: D \\rightarrow L$, $s_4: C$, $s_5: E \\rightarrow T \\rightarrow F$.**\n\n- **Total Size and Justification:** The stated size of $9$ words is incorrect. The justification that the peak overlap is $5$ is also incorrect; our analysis showed the peak overlap is $4$.\n- **Verdict:** Incorrect.\n\n**C. Total activation record size is $6$ words; the mapping $s_1: B \\rightarrow C \\rightarrow F$, $s_2: A \\rightarrow E$, $s_3: D \\rightarrow L$, $s_4: T$ suffices for the spill/local portion.**\n\n- **Total Size:** The stated size of $6$ words is incorrect. The fixed part alone is $4$ words, and the spill/local part requires another $4$ words, for a total of $8$.\n- **Mapping:** The mapping itself is valid (as shown in the analysis of option A), but the total size is wrong.\n- **Verdict:** Incorrect.\n\n**D. Total activation record size is $12$ words because reuse is impossible when calls are present; every object $A,B,C,D,E,F,L,T$ must have a dedicated slot, in addition to the four fixed words.**\n\n- **Total Size:** A size of $12$ words would correspond to $4$ fixed words plus $8$ dedicated slots for the $8$ objects. This would be the size if no reuse were possible.\n- **Justification:** The justification \"reuse is impossible\" directly contradicts the premise of the problem, which explicitly allows for reuse. The problem describes a straight-line block of code with no mention of function calls that would complicate liveness analysis.\n- **Verdict:** Incorrect.\n\n**E. Total activation record size is $8$ words; a mapping with $4$ spill/local slots is $s_1: A \\rightarrow C \\rightarrow E$, $s_2: B \\rightarrow F$, $s_3: D \\rightarrow L$, $s_4: T$.**\n\n- **Total Size:** The stated size of $8$ words is correct.\n- **Spill/Local Slots:** The mapping correctly uses $4$ slots.\n- **Mapping Validity:** We check the assignments.\n    - $s_1: A[2,7), C[5,10), E[8,12)$.\n        - $A$ and $C$: The live range of $A$ is $[2,7)$ and for $C$ is $[5,10)$. These intervals overlap in the range $[5,7)$. Therefore, objects $A$ and $C$ cannot be assigned to the same slot.\n    - Since this assignment is invalid, the entire mapping is invalid.\n- **Verdict:** Incorrect.\n\nBased on the analysis, only option A is fully correct. It states the correct minimal total size and provides a valid mapping of objects to the minimal number of required slots.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}