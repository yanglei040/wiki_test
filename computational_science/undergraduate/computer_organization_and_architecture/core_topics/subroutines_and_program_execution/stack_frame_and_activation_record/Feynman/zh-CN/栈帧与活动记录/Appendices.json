{
    "hands_on_practices": [
        {
            "introduction": "深入理解应用程序二进制接口 (ABI) 对系统编程至关重要。本练习将让你亲身实践，应用 System V AMD64 ABI 的规则来精确计算一个栈帧的内存布局。通过处理局部变量、栈传递的参数以及满足对齐要求的填充字节，你将掌握构建和解析栈帧的基础技能，这对于调试、性能优化乃至逆向工程都非常有价值。",
            "id": "3680344",
            "problem": "在用于 AMD 64位架构 (AMD64) 的 System V 应用程序二进制接口 (SysV ABI) 中，一个函数通过寄存器接收其前六个整数参数，任何额外的整数参数则通过栈接收。栈向低地址方向增长。调用者执行一个 `call` 指令，该指令会推入返回地址；被调用者执行一个标准的函数序言，该序言会推入基址指针 ($\\mathrm{RBP}$)，将 $\\mathrm{RBP}$ 设置为栈指针 ($\\mathrm{RSP}$)，然后减去一个连续的块用于局部存储。在此环境中，对齐不变量要求在任何 `call` 指令之前，$\\mathrm{RSP}$ 必须对齐到 $16$ 字节边界。这里描述的函数是非可变参数的，使用帧指针，调用另一个函数（因此不能依赖红色区域），并且除了 $\\mathrm{RBP}$ 之外不推入任何被调用者保存的寄存器。\n\n给定该函数恰好有 $7$ 个整数参数和三个局部变量，它们的大小和对齐要求如下：\n- 局部变量 $L_{1}$ 大小为 $8$ 字节，要求 $8$ 字节对齐。\n- 局部变量 $L_{2}$ 大小为 $16$ 字节，要求 $16$ 字节对齐。\n- 局部变量 $L_{3}$ 大小为 $24$ 字节，要求 $8$ 字节对齐。\n\n假设局部变量按源代码顺序 $L_{1}$、$L_{2}$、$L_{3}$ 分配，从高地址到低地址连续布局，仅插入满足每个局部变量相对于 $\\mathrm{RBP}$ 的对齐要求所需的最小填充。将每个局部变量的“基地址”定义为其存储空间的最低地址字节，并将所有字节偏移量定义为相对于 $\\mathrm{RBP}$ 的值。\n\n从上述基本事实（栈向下增长、`call` 指令推入返回地址、函数序言推入并设置 $\\mathrm{RBP}$、SysV ABI 寄存器/栈参数规则，以及在调用点 $\\mathrm{RSP}$ 的 $16$ 字节对齐要求）出发，通过以下步骤重建确切的栈帧布局：\n1. 确定 $L_{1}$、$L_{2}$ 和 $L_{3}$ 的基地址偏移量（相对于 $\\mathrm{RBP}$），满足它们的对齐要求且不重叠。\n2. 确定第七个整数参数的偏移量（相对于 $\\mathrm{RBP}$）。\n3. 确定必须添加到局部区域的额外填充字节的最小数量（超出局部变量本身所需），以确保在此函数的任何 `call` 指令之前，$\\mathrm{RSP}$ 都能对齐到 $16$ 字节边界。\n\n将你的最终答案表示为一个行矩阵，顺序为 $\\left(L_{1}, L_{2}, L_{3}, \\text{arg}_{7}, \\text{padding}\\right)$，其中每个条目是所需的偏移量或填充量（以字节为单位）。无需四舍五入。",
            "solution": "用户希望确定一个在 System V AMD64 ABI 下编译的函数的栈帧布局。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n- **架构/ABI：** 适用于 AMD64 的 System V 应用程序二进制接口 (SysV ABI)。\n- **参数传递：** 前六个整数参数在寄存器中；额外的整数参数在栈上。\n- **栈增长：** 朝向更低的内存地址。\n- **`call` 指令：** 推入8字节的返回地址。\n- **函数序言：** 标准序言：`push RBP`、`mov RBP, RSP`、`sub RSP, N`。\n- **栈对齐：** 在任何 `call` 指令之前，`RSP` 必须对齐到 $16$ 字节边界。\n- **函数属性：** 非可变参数，使用帧指针 (`RBP`)，调用其他函数（非叶函数），不使用红色区域，除了 `RBP` 外不推入任何被调用者保存的寄存器。\n- **函数签名：** 恰好有 $7$ 个整数参数。\n- **局部变量：**\n    - $L_{1}$：大小 $8$ 字节，对齐 $8$ 字节。\n    - $L_{2}$：大小 $16$ 字节，对齐 $16$ 字节。\n    - $L_{3}$：大小 $24$ 字节，对齐 $8$ 字节。\n- **局部变量布局：** 按源代码顺序（$L_{1}$、$L_{2}$、$L_{3}$）从高地址到低地址连续分配，使用最小填充以满足相对于 `RBP` 的对齐要求。\n- **定义：** “基地址”是局部变量存储的最低地址字节。偏移量是相对于 `RBP` 的。\n\n**1.2. 使用提取的已知条件进行验证**\n根据验证标准评估问题陈述。\n- **科学性：** 该问题基于真实世界中明确定义的 System V AMD64 ABI。所有陈述的行为（栈增长、`call` 指令、函数序言、寄存器/栈参数传递、对齐规则）都是对该标准的事实正确描述。这是计算机组成和编译器设计中的一个典型问题。 **(有效)**\n- **良构性：** 问题提供了一套完整的约束条件（参数数量、局部变量属性、ABI规则），并要求具体的、可量化的结果（偏移量和填充）。这些约束足以确定唯一的解决方案。 **(有效)**\n- **客观性：** 问题以精确的技术语言陈述，没有歧义、主观性或观点。 **(有效)**\n- **完整性和一致性：** 已知条件是自洽的，并且足以求解。没有矛盾。 **(有效)**\n- **现实性：** 该场景是理解编译器如何生成代码和管理栈的标准练习，这是计算机科学中的一个基础课题。 **(有效)**\n\n**1.3. 结论与行动**\n此问题有效。将提供详细的解决方案。\n\n### 步骤2：详细解答\n\n该解答通过根据 System V AMD64 ABI 的规则重建栈帧布局得出。在函数序言执行后，所有偏移量都是相对于基址指针 `RBP` 的。\n\n**2.1. 确定 RBP 的对齐**\n首先，我们确定基址指针 `RBP` 的对齐方式。\n1.  ABI 规定，在 `call` 指令之前，栈指针 `RSP` 必须对齐到 $16$ 字节边界。设调用我们函数之前，调用者的 `RSP` 为 $S_{caller}$，其中 $S_{caller} \\pmod{16} = 0$。\n2.  `call` 指令将 $8$ 字节的返回地址推入栈中。因此，进入我们的函数时，`RSP` 的地址是 $S_{caller} - 8$。因此，入口处的 `RSP` 值为 $16k - 8$（对于某个整数 $k$），这意味着 $RSP \\pmod{16} = 8$。这与 ABI 要求在函数入口处 `(RSP + 8)` 是 $16$ 的倍数是一致的。\n3.  被调用者序言的第一条指令是 `push RBP`。这将旧 `RBP` 的 $8$ 字节值推入栈中，并使 `RSP` 减少 $8$。`RSP` 现在位于 $(S_{caller} - 8) - 8 = S_{caller} - 16$。这个地址是 $16$ 的倍数。\n4.  下一条指令是 `mov RBP, RSP`。这将新帧的基址指针 `RBP` 设置为 `RSP` 的当前值。\n因此，在我们函数的执行期间，`RBP` 的值对齐到 $16$ 字节边界。这是确定局部变量偏移量的关键事实。\n\n**2.2. 确定第七个参数 (`arg_7`) 的偏移量**\n参数位于相对于 `RBP` 的正偏移量处。\n-   `[RBP + 0]`：此位置存储了来自调用者帧的已保存的 `RBP`（由我们的函数序言推入）。\n-   `[RBP + 8]`：此位置存储了返回地址（由 `call` 指令推入）。\n-   前六个整数参数通过寄存器传递。第七个参数 `arg_7` 是第一个通过栈传递的参数。调用者在 `call` 指令之前将其放置在栈上。它位于返回地址的正上方。\n-   因此，第七个参数位于 `[RBP + 16]`。\n`arg_7` 相对于 `RBP` 的偏移量是 $+16$ 字节。\n\n**2.3. 确定局部变量 ($L_1, L_2, L_3$) 的偏移量**\n局部变量存储在相对于 `RBP` 的负偏移量处。它们从高地址（更靠近 `RBP`）向低地址布局。问题指定了为满足对齐约束而使用的最小填充。我们已经确定 `RBP` 是 $16$ 字节对齐的。一个距离 `RBP` 偏移量为 `off` 的对象的地址是 `RBP + off`。为了使该地址具有 `A` 的对齐方式，我们需要 `(RBP + off) \\pmod A = 0`。由于 `RBP` 是任何所需对齐（$8$ 或 $16$）的倍数，这可以简化为 `off \\pmod A = 0`。\n\n-   **$L_{1}$ 的布局（大小 $8$，对齐 $8$）：**\n    $L_1$ 是第一个局部变量，因此它被放置在最靠近 `RBP` 的位置。我们需要为一个 $8$ 字节对象找到一个基地址偏移量 $off_1  0$，该对象是 $8$ 字节对齐的。为了尽可能靠近 `RBP`，我们将其基地址放在 `RBP-8`。偏移量为 $off_1 = -8$。这满足对齐要求，因为 $-8 \\pmod 8 = 0$。\n    -   $L_{1}$ 占据内存范围 `[RBP - 8, RBP - 1]`。\n    -   $L_1$ 的基地址偏移量为 $-8$。\n\n-   **$L_{2}$ 的布局（大小 $16$，对齐 $16$）：**\n    $L_2$ 必须连续地放置在 $L_1$ 的下方。$L_1$ 使用的最低地址是 `RBP - 8`，因此下一个可用地址是 `RBP - 9`。$L_2$ 是一个 $16$ 字节的对象，所以它的内存块是 `[base, base + 15]`。这个块的顶部 `base + 15` 必须在一个小于或等于 `RBP - 9` 的地址。\n    用偏移量来说，设基地址偏移量为 $off_2$。内存块是 `[RBP + off_2, RBP + off_2 + 15]`。\n    我们必须有 $off_2 + 15 \\le -9$，这意味着 $off_2 \\le -24$。\n    此外，基地址偏移量必须是 $16$ 字节对齐的：$off_2 \\pmod{16} = 0$。\n    我们需要找到小于或等于 $-24$ 的、最接近 $0$ 的 $16$ 的倍数。这个值是 $-32$。\n    -   $L_{2}$ 占据内存范围 `[RBP - 32, RBP - 17]`。\n    -   $L_2$ 的基地址偏移量为 $-32$。\n    -   注意：这在 `RBP - 16` 和 `RBP - 9` 之间产生了一个 $8$ 字节的填充区域。\n\n-   **$L_{3}$ 的布局（大小 $24$，对齐 $8$）：**\n    $L_3$ 放置在 $L_2$ 的下方。$L_2$ 占据内存范围 `[RBP - 32, RBP - 17]`，因此下一个可用的最高地址是 `RBP - 33`。设 $L_3$ 的基地址偏移量为 $off_3$。其内存块为 `[RBP + off_3, RBP + off_3 + 23]`。\n    我们必须有 $off_3 + 23 \\le -33$，这意味着 $off_3 \\le -56$。\n    此外，基地址偏移量必须是 $8$ 字节对齐的：$off_3 \\pmod 8 = 0$。\n    我们需要找到小于或等于 $-56$ 的、最接近 $0$ 的 $8$ 的倍数。这个值是 $-56$。\n    -   $L_{3}$ 占据内存范围 `[RBP - 56, RBP - 33]`。\n    -   $L_3$ 的基地址偏移量为 $-56$。\n    -   $L_2$ 和 $L_3$ 之间没有填充。\n\n所有局部变量及其内部填充所需的总连续内存块从 `RBP - 1` 一直延伸到 `RBP - 56`，总大小为 $56$ 字节。\n\n**2.4. 确定用于调用对齐的额外填充**\n该函数调用另一个函数，因此它是非叶函数。在它发出 `call` 指令之前，`RSP` 必须是 $16$ 字节对齐的。\n局部存储区域占用 $56$ 字节。函数序言必须通过 `sub RSP, N` 分配至少这么大的空间。\n设总分配大小为 $N$ 字节，其中 $N = 56 + P$，$P$ 是额外的填充。序言之后，`RSP = RBP - N`。\n一个标准且稳健的编译策略是在函数序言之后立即对齐栈指针。这为函数体提供了一个正确对齐的栈以进行操作，简化了后续为调用所做的准备。为实现这一点，总的局部区域分配大小 `N` 必须是 $16$ 的倍数，因为 `RBP` 是 $16$ 字节对齐的。\n-   局部变量所需大小：$56$ 字节。\n-   我们需要找到 $16$ 的最小倍数（称之为 $N$），使得 $N \\ge 56$。\n-   $16$ 的倍数：$16, 32, 48, 64, ...$\n-   大于或等于 $56$ 的最小的 $16$ 的倍数是 $64$。\n-   所以，总分配大小为 $N=64$ 字节。\n-   所需的额外填充是 $P = N - 56 = 64 - 56 = 8$ 字节。\n\n有了这个填充，函数序言指令将是 `sub RSP, 64`。然后 `RSP` 将是 `RBP - 64`，这是 $16$ 字节对齐的。当这个函数随后调用另一个函数时，`RSP` 已经是（在子调用不接受栈参数的情况下）对齐的。如果子调用需要栈参数，编译器会从这个对齐的基准开始进行进一步的栈调整来准备参数，同时保持对齐不变量。静态帧中的 $8$ 字节填充是建立这个对齐基准所需的最小量。\n\n**结果总结：**\n-   $L_{1}$ 的偏移量：$-8$ 字节。\n-   $L_{2}$ 的偏移量：$-32$ 字节。\n-   $L_{3}$ 的偏移量：$-56$ 字节。\n-   `arg_7` 的偏移量：$+16$ 字节。\n-   额外填充：$8$ 字节。\n\n最终答案是按指定顺序排列的这些值的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-8  -32  -56  16  8\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在正确构建栈帧的基础上，本练习将探讨当调用者和被调用者之间的“契约”被破坏时会发生什么。通过分析 `cdecl` 和 `stdcall` 调用约定之间的不匹配，你将学习如何追踪栈指针 ($SP$) 的行为来诊断栈不平衡问题。这种不匹配是导致程序出现微妙且灾难性错误的常见原因，理解其原理有助于编写更健壮的系统软件。",
            "id": "3680364",
            "problem": "一位工程师正在诊断一个系统中微妙的堆栈不平衡问题，该系统在一个 $32$ 位指令集架构（ISA）上使用向下增长的堆栈。该系统遵循典型的应用程序二进制接口（ABI）约定：函数调用会将一个 $4$ 字节的返回地址推入堆栈，被调用函数（callee）可能会通过推入帧指针（FP）来保存它，被调用函数会设置其激活记录（局部变量和保存的寄存器），但必须在返回前恢复它们。在 C 声明（cdecl）调用约定下，调用者（caller）在调用结束后通过调整堆栈指针（SP）来释放参数区域。在标准调用（stdcall）调用约定下，被调用者在返回前释放参数区域（例如，通过一个将总参数大小加到 $SP$ 上的函数尾声，或者一个能增加该大小的返回指令）。\n\n一个特定的调用点期望使用标准调用（stdcall），因此在调用后不执行调用者侧的参数清理。然而，目标函数实际上是使用 C 声明（cdecl）编译的，因此它不会释放其参数区域。被调用的函数有 $3$ 个参数，每个参数占用 $4$ 字节，并包含一个标准的函数前序（prologue）来保存帧指针（FP）和分配局部变量，以及一个匹配的函数尾声（epilogue）来恢复它们。调用点每次调用该函数时执行以下序列：\n- 将当前的堆栈指针（SP）记录在一个临时变量 $sp_{\\text{pre}}$ 中。\n- 推入 $3$ 个各占 $4$ 字节的参数（总参数区域 $S = 12$ 字节）。\n- 执行调用，这会推入一个 $4$ 字节的返回地址。\n- 返回后，不执行调用者侧对 $SP$ 的调整。\n- 立即将堆栈指针（SP）记录在 $sp_{\\text{post}}$ 中。\n\n假设在调用点的连续调用之间，除了所描述的操作外，没有其他堆栈分配或释放操作，并且被调用函数的函数前序和尾声相对于其自身的激活记录是完全平衡的（也就是说，除了参数区域策略外，被调用函数对 $SP$ 的净影响等于其进入时的状态）。令 $k$ 表示在这种不匹配情况下循环执行的连续调用次数。\n\n选择所有正确的陈述：\n\nA. 在所描述的不匹配情况下，调用点处 $SP$ 的每次调用漂移满足 $sp_{\\text{post}} - sp_{\\text{pre}} = -S = -12$，并且在 $k$ 次连续调用后，相对于初始 $SP$ 的累积漂移为 $-12k$ 字节。\n\nB. 在所描述的不匹配情况下，调用点处 $SP$ 的每次调用漂移满足 $sp_{\\text{post}} - sp_{\\text{pre}} = +S = +12$，因为调用者和被调用者都试图释放参数区域。\n\nC. 一种用于在调用点检测调用约定不匹配的稳健运行时检查是：在推入参数之前立即将 $SP$ 记录为 $sp_{\\text{pre}}$，然后在函数返回后、任何调用者清理之前再次将 $SP$ 记录为 $sp_{\\text{post}}$；计算 $\\Delta = sp_{\\text{post}} - sp_{\\text{pre}}$。如果调用点期望标准调用（stdcall），则断言 $\\Delta = 0$；如果期望 C 声明（cdecl），则断言 $\\Delta = -S$。任何违反都表明存在不匹配。\n\nD. 一种更可靠的运行时检查是在调用前后比较帧指针（FP），因为在两种约定下，FP 在调用前后都保持不变；因此 FP 的任何变化都表明存在调用约定不匹配。\n\nE. 因为一次调用会推入一个 $4$ 字节的返回地址，而一次返回会弹出它，所以在一次匹配良好的调用-返回对中，忽略参数清理，$SP$ 的净变化是 $-4$ 字节；因此，即使调用约定一致，比较调用前和返回后的 $SP$ 也将总是相差 $-4$ 字节。",
            "solution": "用户希望我分析一个在 $32$ 位系统上使用向下增长堆栈的特定调用约定不匹配问题。我将首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **架构**：向下增长的堆栈，$32$ 位指令集架构（ISA）。\n- **返回地址**：函数调用推入一个 $4$ 字节的返回地址。\n- **帧指针 (FP)**：被调用函数可能会通过推入帧指针来保存它。它必须在返回前恢复它。\n- **`cdecl` 约定**：调用者在调用后释放参数区域。\n- **`stdcall` 约定**：被调用者在返回前释放参数区域。\n- **场景不匹配**：\n    - 调用点（调用者）期望 `stdcall`。\n    - 目标函数（被调用者）使用 `cdecl` 编译。\n- **函数签名**：\n    - 参数数量：$3$。\n    - 每个参数的大小：$4$ 字节。\n    - 总参数区域大小：$S = 3 \\times 4 = 12$ 字节。\n- **被调用者行为**：被调用者有一个标准的函数前序（保存 FP，分配局部变量）和一个匹配的函数尾声，它们相对于其自身的激活记录是完全平衡的。\n- **调用者行为（测量序列）**：\n    1. 将堆栈指针（SP）记录为 $sp_{\\text{pre}}$。\n    2. 推入 $3$ 个参数（共 $12$ 字节）。\n    3. 执行 `call` 指令。\n    4. 返回后，调用者不执行参数清理（与 `stdcall` 的期望一致）。\n    5. 立即将堆栈指针（SP）记录为 $sp_{\\text{post}}$。\n- **变量**：$k$ 是连续调用的次数。\n- **假设**：在调用之间没有其他堆栈操作发生。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于计算机组成和体系结构的基本原理。堆栈帧、调用约定（`cdecl`、`stdcall`）、堆栈指针和帧指针都是标准的、定义明确的概念。所描述的行为对于像 x86 这样的架构是典型的。\n- **良构性**：该问题是良构的。初始条件、操作序列和不匹配的假设都已明确指定，从而可以对堆栈指针的状态进行确定性分析。\n- **客观性**：该问题以精确、客观和技术性的语言陈述。它没有歧义和主观性。\n- **缺陷检查清单**：该问题没有违反任何无效性标准。它是科学合理的、可形式化的、完整的和现实的。调用约定不匹配是一类真实的软件错误。\n\n### 步骤 3：结论和行动\n问题陈述是**有效的**。我将继续推导解决方案并评估各个选项。\n\n### 基于原理的推导\n让我们按照描述跟踪堆栈指针（SP）在一个完整调用周期中的值。堆栈向下增长，所以推入数据会减少 SP 值，而弹出数据会增加它。\n\n设 $SP_{0}$ 是序列开始时堆栈指针的值。\n\n1.  **记录 $sp_{\\text{pre}}$**：根据序列，$sp_{\\text{pre}}$ 首先被记录。\n    $$sp_{\\text{pre}} = SP_{0}$$\n2.  **推入参数**：调用者推入 $3$ 个参数，每个 $4$ 字节。总大小为 $S = 12$ 字节。\n    $$SP \\text{ 变为 } SP_{0} - 12$$\n3.  **执行 `call`**：`call` 指令将 $4$ 字节的返回地址推入堆栈。\n    $$SP \\text{ 变为 } (SP_{0} - 12) - 4 = SP_{0} - 16$$\n    这是进入被调用函数时的 SP 值。\n4.  **被调用者执行 (`cdecl`)**：\n    - 被调用者执行其函数前序（例如，保存 FP，分配局部变量）、函数体和函数尾声。问题陈述指出，函数前序和尾声对于被调用者自己的帧（局部变量和保存的寄存器）是完全平衡的。这意味着从被调用者进入到其 `ret` 指令之前，这些操作对 SP 的净影响为零。\n    - 被调用者是 `cdecl`，所以它**不**会释放传递给它的参数。\n    - 执行 `ret` 指令。它从堆栈中弹出 $4$ 字节的返回地址并跳转到该地址。这会使 SP 增加 $4$ 字节。\n    - 因此，返回到调用者时的 SP 值为 $(SP_0 - 16) + 4 = SP_0 - 12$。\n5.  **调用者侧，返回后**：\n    - 调用者期望的是一个 `stdcall` 函数，所以它假设被调用者已经清理了参数。因此，调用者**不**对参数进行堆栈调整。\n6.  **记录 $sp_{\\text{post}}$**：立即测量 SP。\n    $$sp_{\\text{post}} = SP_{0} - 12$$\n7.  **计算每次调用的漂移**：在调用点，一次调用的堆栈指针变化为：\n    $$\\Delta SP = sp_{\\text{post}} - sp_{\\text{pre}} = (SP_{0} - 12) - SP_{0} = -12 \\text{ 字节}$$\n    由于 $S = 12$ 字节，漂移为 $\\Delta SP = -S$。\n8.  **计算累积漂移**：因为没有其他中间的堆栈操作，这种漂移是累积的。在 $k$ 次连续调用后，相对于第一次调用前的值，堆栈指针的总变化将是：\n    $$\\text{累积漂移} = k \\times \\Delta SP = -12k \\text{ 字节}$$\n\n### 逐项分析选项\n\n**A. 在所描述的不匹配情况下，调用点处 $SP$ 的每次调用漂移满足 $sp_{\\text{post}} - sp_{\\text{pre}} = -S = -12$，并且在 $k$ 次连续调用后，相对于初始 $SP$ 的累积漂移为 $-12k$ 字节。**\n我们的推导表明 $sp_{\\text{post}} - sp_{\\text{pre}} = -12$ 字节。由于 $S=12$ 字节，这等于 $-S$。$k$ 次调用后的累积漂移被正确地表述为 $-12k$ 字节。这个陈述准确地描述了指定不匹配的后果，即调用者和被调用者都没有释放参数区域，导致堆栈在每次调用时增长。\n**结论：正确。**\n\n**B. 在所描述的不匹配情况下，调用点处 $SP$ 的每次调用漂移满足 $sp_{\\text{post}} - sp_{\\text{pre}} = +S = +12$，因为调用者和被调用者都试图释放参数区域。**\n这个陈述描述了另一种不匹配：一个 `cdecl` 调用者（会清理堆栈）调用一个 `stdcall` 被调用者（也会清理堆栈）。在这种情况下，会发生“双重清理”，导致 $+S$ 的漂移。然而，问题指定的是一个期望 `stdcall` 的调用者（不清理）和一个 `cdecl` 的被调用者（不清理）。在我们的情况下，双方都没有释放参数。因此，对于给定的问题，这个选项的前提和结论都是错误的。\n**结论：不正确。**\n\n**C. 一种用于在调用点检测调用约定不匹配的稳健运行时检查是：在推入参数之前立即将 $SP$ 记录为 $sp_{\\text{pre}}$，然后在函数返回后、任何调用者清理之前再次将 $SP$ 记录为 $sp_{\\text{post}}$；计算 $\\Delta = sp_{\\text{post}} - sp_{\\text{pre}}$。如果调用点期望标准调用（stdcall），则断言 $\\Delta = 0$；如果期望 C 声明（cdecl），则断言 $\\Delta = -S$。任何违反都表明存在不匹配。**\n让我们分析所提出的用于检查正确匹配的约定的方法。测量点与主问题描述中的相同。\n- **匹配良好的 `stdcall`**：调用者推入参数（$SP \\to SP - S$），调用，然后被调用者返回。一个 `stdcall` 被调用者在返回前会释放 $S$ 字节的参数（例如，使用 `ret S` 指令）。从推入参数前到函数返回后，对 SP 的净影响是 $0$。所以，对于一个 `stdcall` 调用点，我们期望 $\\Delta = sp_{\\text{post}} - sp_{\\text{pre}} = 0$。断言 `assert \\Delta = 0` 是正确的。\n- **匹配良好的 `cdecl`**：调用者推入参数（$SP \\to SP - S$），调用，然后被调用者返回。一个 `cdecl` 被调用者不释放参数。函数返回后但在调用者清理*之前*的 SP 值为 $sp_{\\text{post}} = sp_{\\text{pre}} - S$。因此，$\\Delta = -S$。断言 `assert \\Delta = -S` 是正确的。（调用者随后会执行 `add SP, S` 来恢复平衡，但检查在此之前发生）。\n由于这些断言正确地描述了两种标准约定的预期行为，任何与预期不符的结果（例如，在期望 `stdcall` 的调用点得到 $\\Delta = -S$）都正确地指示了不匹配。这是一个有效且稳健的检查机制。\n**结论：正确。**\n\n**D. 一种更可靠的运行时检查是在调用前后比较帧指针（FP），因为在两种约定下，FP 在调用前后都保持不变；因此 FP 的任何变化都表明存在调用约定不匹配。**\n标准的函数前序包括保存调用者的帧指针（在 x86 上是 `push ebp`），而函数尾声则包括恢复它（`pop ebp`）。这种行为是应用程序二进制接口（ABI）的一部分，通常与参数清理策略（`cdecl` vs `stdcall`）无关。问题陈述中说，被调用者有一个“标准的函数前序来保存帧指针……以及一个匹配的函数尾声来恢复它们。”因此，被调用者尽管是 `cdecl`，仍会正确恢复调用者的 FP。在调用前后比较 FP 将显示没有变化，因此这个检查将**无法**检测到由参数清理不匹配引起的堆栈不平衡。选项 C 中基于 SP 的检查对于这类错误是更优的。\n**结论：不正确。**\n\n**E. 因为一次调用会推入一个 $4$ 字节的返回地址，而一次返回会弹出它，所以在一次匹配良好的调用-返回对中，忽略参数清理，$SP$ 的净变化是 $-4$ 字节；因此，即使调用约定一致，比较调用前和返回后的 $SP$ 也将总是相差 $-4$ 字节。**\n这个陈述有根本性的错误。`call` 指令将 SP 减去 $4$ 字节以推入返回地址。相应的 `ret` 指令在弹出该地址到程序计数器时将 SP 增加 $4$ 字节。这对匹配操作对堆栈指针的净效应是 $4 - 4 = 0$。变化不是 $-4$ 字节。在函数执行期间，SP 会暂时性地减少 $4$ 字节（或更多），但会被 `ret` 指令恢复。\n**结论：不正确。**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "本节的最终练习将深入探讨一种最危险的未定义行为：通过类型签名不匹配的函数指针进行调用。你将追踪 ABI 如何根据不同的数据类型（如整数与浮点数）来规定参数传递，并分析这种不匹配如何导致被调用函数接收到无意义的数据。这个练习凸显了 ABI 严格的、机械化的本质，以及在底层编程中违反类型系统所带来的风险。",
            "id": "3680339",
            "problem": "考虑一个为 $\\text{x86\\_64}$ 架构上的 System V 应用程序二进制接口 (ABI) 编译的程序。以下事实（经过充分测试的 ABI 规则）成立：\n- 前六个整数或指针参数按顺序通过寄存器传递：$rdi$、$rsi$、$rdx$、$rcx$、$r8$、$r9$。\n- 前八个浮点参数通过 $xmm0$ 到 $xmm7$ 传递。\n- 整数或指针返回值在 $rax$ 中传递；浮点返回值在 $xmm0$ 中传递。\n- 栈指针 $rsp$ 在 `call` 指令执行时必须是 $16$ 字节对齐的。\n- 被调用者保存的寄存器包括 $rbx$、$rbp$、$r12$、$r13$、$r14$ 和 $r15$；调用者保存的寄存器包括 $rax$、$rcx$、$rdx$、$rsi$、$rdi$、$r8$–$r11$ 和 $xmm0$–$xmm15$。\n\n一个调用者持有一个静态类型为 $long (*)(long, long, long)$ 的函数指针 $p$，并以 $p(a,b,c)$ 的形式调用它，其中 $a=10$，$b=20$，$c=30$。实际的目标函数（被错误地赋给了 $p$）的原型是 $double h(double x, int y, long z)$，并返回 $x + (double)y + (double)z$。假设在没有消毒器（sanitizer）的情况下进行常规优化，没有可变参数，并且编译器遵守上述应用程序二进制接口（ABI）规则。同时假设调用者使用标准的序言（prologue）和调用序列，以确保 $rsp$ 对齐规则得到满足。因此，由于原型不匹配，该程序表现出未定义行为。\n\n以下哪个描述正确地刻画了进入 $h$ 函数时预期与实际的活动记录状态（寄存器和栈），以及由此对计算和调用者观察到的返回值产生的影响？\n\nA. 进入 $h$ 时，$x$ 从 $xmm0$ 读取（调用者未设置该寄存器，因此其包含一个不确定的值），$y$ 从 $edi$ 读取（即持有 $a$ 的 $rdi$ 的低 $32$ 位），$z$ 从 $rsi$ 读取（其持有 $b$）。调用者的第三个参数 $c$ 位于 $rdx$ 中，但被忽略，因为 $h$ 不会消耗第三个整数寄存器参数。被调用者使用一个不确定的 $x$ 计算出一个 $double$ 值，在 $xmm0$ 中返回该 $double$ 值，而调用者从 $rax$ 读取一个 $long$ 结果，但 $rax$ 并不持有返回的 $double$ 值。因此，调用者观察到的 $long$ 值是未指定的。\n\nB. 过程调用标准强制规定，当发生原型不匹配时，调用者必须通过将 $a$ 转换为 $(double)a$ 来将任何对应的浮点参数放入 $xmm0$ 中，因此在入口处 $x$ 将等于 $(double)a$，计算将确定性地进行。\n\nC. 无论寄存器传递如何，内存中的活动记录在被调用者的栈帧中的固定偏移量处包含 $a$、$b$、$c$，并且被调用者从栈中读取它们。因此，$x$、$y$ 和 $z$ 按顺序从栈中获取，计算是确定性的。\n\nD. 不匹配的原型迫使编译器生成一个可变参数风格的调用序列，将所有参数移动到栈上并清除 $xmm$ 寄存器。这消除了未定义行为，因为被调用者随后会根据需要从内存中加载所有三个参数。\n\nE. 即使原型不匹配，栈对齐和影子空间（shadow space）也能保证在函数返回时，$xmm0$ 的低 $64$ 位会镜像到 $rax$ 中，因此调用者会将返回的 $double$ 值的位表示读入 $r$ 中。\n\nF. 在这种情况下，根据 ABI 的要求，栈指针 $rsp$ 在调用点保持 $16$ 字节对齐，因此对齐错误不是未定义行为的来源；未定义行为的产生是因为被调用者从 $xmm0$ 读取 $x$ 并在 $xmm0$ 中返回值，而调用者既没有为参数初始化 $xmm0$，也没有为返回值读取 $xmm0$。\n\n选择所有正确的选项。",
            "solution": "### 问题验证\n\n根据提供的规则对问题陈述进行评估。\n\n**步骤 1：提取已知信息**\n\n*   **平台**：$\\text{x86\\_64}$ 架构上的 System V 应用程序二进制接口 (ABI)。\n*   **ABI 规则 (整数/指针参数)**：前六个参数按顺序通过寄存器传递：$rdi, rsi, rdx, rcx, r8, r9$。\n*   **ABI 规则 (浮点参数)**：前八个参数通过寄存器 $xmm0$ 到 $xmm7$ 传递。\n*   **ABI 规则 (返回值)**：整数/指针值在 $rax$ 中返回。浮点值在 $xmm0$ 中返回。\n*   **ABI 规则 (栈)**：栈指针 $rsp$ 在 `call` 指令执行点必须是 $16$ 字节对齐的。\n*   **ABI 规则 (寄存器易失性)**：\n    *   被调用者保存：$rbx, rbp, r12, r13, r14, r15$。\n    *   调用者保存：$rax, rcx, rdx, rsi, rdi, r8-r11, xmm0-xmm15$。\n*   **调用者行为**：\n    *   持有一个静态类型为 `long (*)(long, long, long)` 的函数指针 $p$。\n    *   以 $a=10, b=20, c=30$ 执行调用 $p(a, b, c)$。\n    *   假设遵循 ABI 对齐规则。\n*   **被调用者 (实际函数) 行为**：\n    *   函数是 `h`，其原型为 `double h(double x, int y, long z)`。\n    *   函数返回表达式 $x + (double)y + (double)z$ 的值。\n*   **假设**：常规优化，无消毒器，无可变参数，编译器遵守 ABI。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n*   **科学依据**：该问题基于真实世界中详细记录的 System V AMD64 ABI。所有陈述的规则都是该标准的正确表示。该场景——通过类型不匹配的指针进行函数调用——是一个经典且现实的编程错误，会导致未定义行为。\n*   **定义明确**：问题定义清晰。调用者的行为由其静态类型信息决定，被调用者的行为由其实际原型决定。ABI 规则提供了一个确定性的框架来追踪这种不匹配的机制性后果。对状态转移进行唯一分析是可能的。\n*   **客观性**：问题使用了来自计算机体系结构和系统编程的精确、标准的术语（例如，“活动记录”、“寄存器”、“ABI”、“栈指针”）。它没有主观或模棱两可的语言。\n*   **完整性和一致性**：问题为分析该场景提供了足够的信息。没有内部矛盾。程序表现出“未定义行为”的说法在技术上是正确的，但问题要求基于 ABI 追踪具体的、机制性的后果，这是一个标准的教学练习。\n\n**步骤 3：结论和行动**\n\n问题陈述是**有效的**。这是一个合理且定义明确的问题，旨在测试对标准调用约定的详细知识。\n\n### 解题推导\n\n分析过程是根据 ABI 分别考虑调用者和被调用者的行为，然后协调不匹配的状态。\n\n**1. 调用者的行为 (调用 `p`)**\n\n调用者的编译器看到一个通过类型为 `long (*)(long, long, long)` 的指针进行的调用。根据 System V ABI，它将按如下方式准备参数：\n*   从调用者的角度来看，该函数是非浮点函数。\n*   第一个参数 `a = 10`（`long` 类型）被放入寄存器 $rdi$。\n*   第二个参数 `b = 20`（`long` 类型）被放入寄存器 $rsi$。\n*   第三个参数 `c = 30`（`long` 类型）被放入寄存器 $rdx$。\n*   调用者不使用任何 $xmm$ 寄存器来传递参数，因为它所知道的函数原型不包含浮点类型。寄存器 $xmm0$ 是调用者保存的，这意味着不保证其内容在函数调用后保持不变，并且调用者没有义务在调用前将其设置为任何特定值。因此，从被调用者的角度来看，它的值是不确定的。\n*   调用者执行一条 `call` 指令。根据问题陈述，此时栈指针 $rsp$ 是 $16$ 字节对齐的。\n*   函数返回后，调用者期望在 $rax$ 寄存器中得到 `long` 类型的返回值。\n\n**2. 被调用者的行为 (进入 `h` 时)**\n\n实际执行的函数是 `h`，其原型为 `double h(double x, int y, long z)`。根据 ABI，它期望按如下方式接收其参数：\n*   第一个参数是 `x`（`double` 类型）。根据 ABI 的分类，这是一个浮点类型，因此期望它在寄存器 $xmm0$ 中。\n*   第二个参数是 `y`（`int` 类型）。这是一个整数类型。下一个可用的整数类寄存器是 $rdi$。函数将读取 $rdi$ 的低 $32$ 位（即 $edi$ 寄存器）来获取此值。\n*   第三个参数是 `z`（`long` 类型）。这是一个整数类型。下一个可用的整数类寄存器是 $rsi$。函数将读取完整的 $64$ 位 $rsi$ 寄存器来获取此值。\n\n**3. 状态协调与计算**\n\n通过结合调用者的行为和被调用者的期望，我们确定 `h` 内部的实际初始状态：\n*   参数 $x$：`h` 从 $xmm0$ 读取。调用者没有在此处放置值。因此 $x$ 的值是不确定的（垃圾值）。\n*   参数 $y$：`h` 从 $edi$ 读取。调用者将 $a=10$ 放入了 $rdi$。所以，$y$ 接收到值 $10$。\n*   参数 $z$：`h` 从 $rsi$ 读取。调用者将 $b=20$ 放入了 $rsi$。所以，$z$ 接收到值 $20$。\n*   调用者的第三个参数 $c=30$ 在 $rdx$ 中，从未被 `h` 为其参数读取。\n\n然后函数 `h` 计算其返回值：$x + (double)y + (double)z$。\n这变成：$(\\text{不确定的值}) + (double)10 + (double)20 = (\\text{不确定的值}) + 30.0$。\n结果是一个不确定的 `double` 值。\n\n**4. 返回值处理**\n\n*   `h` 返回一个 `double`。根据 ABI，它将这个不确定的结果放入寄存器 $xmm0$。\n*   调用者期望一个 `long` 类型的返回值，因此从寄存器 $rax$ 读取。\n*   ABI 没有规定函数返回时 $xmm0$ 和 $rax$ 之间有任何联系。$rax$ 是一个调用者保存的寄存器，`h` 没有义务在其中放置任何特定的值，特别是当它返回一个 `double` 时。因此，返回到调用者时 $rax$ 中的值是未指定的。它可能是调用前的任何值，也可能在 `h` 执行期间因不相关的临时计算而被覆盖。\n\n**结论**：调用者从 $rax$ 接收到一个未指定的 `long` 值，这个值与 `h` 计算并在 $xmm0$ 中返回的 `double` 值完全无关。\n\n### 逐项分析选项\n\n**A. 进入 `h` 时，$x$ 从 $xmm0$ 读取（调用者未设置该寄存器，因此其包含一个不确定的值），$y$ 从 $edi$ 读取（即持有 $a$ 的 $rdi$ 的低 $32$ 位），$z$ 从 $rsi$ 读取（其持有 $b$）。调用者的第三个参数 $c$ 位于 $rdx$ 中，但被忽略，因为 $h$ 不会消耗第三个整数寄存器参数。被调用者使用一个不确定的 $x$ 计算出一个 $double$ 值，在 $xmm0$ 中返回该 $double$ 值，而调用者从 $rax$ 读取一个 $long$ 结果，但 $rax$ 并不持有返回的 $double$ 值。因此，调用者观察到的 $long$ 值是未指定的。**\n\n此选项对事件进行了完整而准确的逐步描述。它正确地指出了调用者和被调用者为每个参数使用的寄存器，对计算的后果（使用不确定的值），用于返回值的不同寄存器，以及对调用者的最终结果。\n*结论：**正确***。\n\n**B. 过程调用标准强制规定，当发生原型不匹配时，调用者必须通过将 $a$ 转换为 $(double)a$ 来将任何对应的浮点参数放入 $xmm0$ 中，因此在入口处 $x$ 将等于 $(double)a$，计算将确定性地进行。**\n\n这是不正确的。C 语言的编译模型基于静态类型。调用者的编译器根据它所知道的类型 `long (*)(long, long, long)` 生成代码，并且没有关于实际目标原型的任何信息。ABI 没有这种针对类型不匹配的“修复”机制；它们只会导致未定义行为。\n*结论：**错误***。\n\n**C. 无论寄存器传递如何，内存中的活动记录在被调用者的栈帧中的固定偏移量处包含 $a$、$b$、$c$，并且被调用者从栈中读取它们。因此，$x$、$y$ 和 $z$ 按顺序从栈中获取，计算是确定性的。**\n\n这是不正确的。System V x86_64 ABI 强烈倾向于在寄存器中传递参数以提高性能。只有在可用寄存器用尽时，参数才会在栈上传递。在这种情况下，调用者和被调用者都期望参数在寄存器中。\n*结论：**错误***。\n\n**D. 不匹配的原型迫使编译器生成一个可变参数风格的调用序列，将所有参数移动到栈上并清除 $xmm$ 寄存器。这消除了未定义行为，因为被调用者随后会根据需要从内存中加载所有三个参数。**\n\n这是不正确的。函数指针的静态类型不包含省略号（`...`），因此编译器不会生成可变参数调用序列。这种不匹配在编译时不会被检测到。\n*结论：**错误***。\n\n**E. 即使原型不匹配，栈对齐和影子空间（shadow space）也能保证在函数返回时，$xmm0$ 的低 $64$ 位会镜像到 $rax$ 中，因此调用者会将返回的 $double$ 值的位表示读入 $r$ 中。**\n\n这是不正确的。System V ABI 中没有这样的规则。“影子空间”是 Windows x64 ABI 的一个特性，而不是 System V 的。更重要的是，浮点返回寄存器（$xmm0$）和整数返回寄存器（$rax$）之间没有自动镜像。它们是独立的，用于不同的返回类型。\n*结论：**错误***。\n\n**F. 在这种情况下，根据 ABI 的要求，栈指针 $rsp$ 在调用点保持 $16$ 字节对齐，因此对齐错误不是未定义行为的来源；未定义行为的产生是因为被调用者从 $xmm0$ 读取 $x$ 并在 $xmm0$ 中返回值，而调用者既没有为参数初始化 $xmm0$，也没有为返回值读取 $xmm0$。**\n\n这个陈述对问题给出了一个高层次的、正确的诊断。它根据问题的前提正确地指出栈对齐不是问题所在。它正确地指出了两个根本性的失败点：（1）传递第一个参数时寄存器使用的不匹配（`调用者没有初始化 xmm0` 但 `被调用者从 xmm0 读取 x`），以及（2）返回值寄存器使用的不匹配（`被调用者在 xmm0 中返回` 但调用者从 $rax$ 读取）。这是对情况的有效和准确的描述。\n*结论：**正确***。",
            "answer": "$$\\boxed{AF}$$"
        }
    ]
}