## 应用与跨学科联系

在前面的章节中，我们已经探讨了参数传递的核心原则与机制，包括[调用约定](@entry_id:753766)（ABIs）、寄存器使用规范以及[栈帧](@entry_id:635120)布局。这些规则虽然看似是底层和技术性的，但它们构成了现代计算中软件模块之间所有交互的基础。从操作系统内核到高级语言编译器，再到安全关键型系统，对[参数传递机制](@entry_id:753160)的深刻理解对于设计、优化和保护软件至关重要。

本章的目标是展示这些核心原则如何在多样的、真实的、跨学科的背景下被应用、扩展和整合。我们将通过一系列应用场景，揭示参数传递不仅是关于“如何”移动数据，更是关于“为什么”要以特定的方式移动数据——这背后驱动因素通常涉及性能、安全、[互操作性](@entry_id:750761)和架构特性。我们不会重复讲授核心概念，而是将它们作为分析工具，来探索更广阔的计算领域。

### [操作系统](@entry_id:752937)与硬件的接口

操作系统内核是软件与硬件交互的最前沿。参数传递规则在管理这种交互中扮演着核心角色，尤其是在处理特权级转换、异步事件（如中断）和系统调用时。这些场景下的ABI必须精确无误，以确保系统的稳定性和安全性。

#### 用户空间与内核空间的ABI差异

在单个[操作系统](@entry_id:752937)和架构上，通常存在多种[调用约定](@entry_id:753766)，一个典型的例子就是用户空间应用程序所遵循的ABI与内核接口（系统调用）所遵循的ABI之间的差异。例如，在Linux下的x86-64架构中，标准的System V ABI规定，函数的前六个整型或指针参数通过寄存器 $rdi$、$rsi$、$rdx$、$rcx$、$r8$ 和 $r9$ 传递。然而，当用户空间代码发起一个系统调用时，Linux内核期望的ABI有所不同：系统调用号放入 $rax$ 寄存器，而前六个参数则[分布](@entry_id:182848)在 $rdi$、$rsi$、$rdx$、$r10$、$r8$ 和 $r9$ 中。

这种差异意味着，从用户空间到内核的转换并非无缝。当一个C库函数（如 `write()`）封装一个[系统调用](@entry_id:755772)时，它必须充当一个“桥梁”，将遵循用户空间ABI的参数重新[排列](@entry_id:136432)，以满足内核ABI的要求。在这个例子中，第四个参数的位置发生了变化：在用户空间ABI中它位于 $rcx$，而在内核ABI中它应位于 $r10$。因此，在执行 `syscall` 指令之前，必须执行一个 `mov` 指令，将第四个参数的值从 $rcx$ 复制到 $r10$。值得注意的是，`syscall` 指令本身会修改 $rcx$ 和 $r11$ 寄存器，因此在转换过程中无需保留 $rcx$ 的原始值。这个看似微小的调整，是确保用户程序能够与内核正确通信的关键一步，它体现了不同软件层之间接口的精确性和有意设计。

#### 中断与[异常处理](@entry_id:749149)

当处理器响应中断或异常时，它会从正常执行流切换到一个特殊的处理程序。这个过程也深度依赖于精心设计的[参数传递机制](@entry_id:753160)，通常是硬件和软件约定的结合。

在嵌入式系统，如基于ARMv7-M架构的微控制器中，硬件在异常发生时会自动将一部分处理器状态（如寄存器 $r_0$–$r_3$、$r_{12}$、连接寄存器LR、[程序计数器](@entry_id:753801)PC和程序[状态寄存器](@entry_id:755408)xPSR）压入栈中。这创建了一个“异常栈帧”。如果[中断服务程序](@entry_id:750778)（ISR）是用C语言编写的，那么就需要一个汇编包装器（wrapper）来衔接硬件行为和C语言的ARM架构[过程调用](@entry_id:753765)标准（AAPCS）。例如，假设一个错误码在中断发生前被置于 $r_0$ 中，并且硬件已将其保存在异常[栈帧](@entry_id:635120)的底部。ISR包装器需要读取这个值，并将其作为参数传递给C处理函数。根据AAPCS，第一个参数应通过 $r_0$ 寄存器传递。因此，包装器必须从[栈帧](@entry_id:635120)中加载该值到 $r_0$ 中。

更重要的是，AAPCS要求在调用任何公共函数时，[栈指针](@entry_id:755333)必须是8字节对齐的。在调用C处理函数之前，ISR包装器必须保存包含异常返回信息的LR寄存器。如果只将一个32位的LR压栈，[栈指针](@entry_id:755333)会移动4字节，破坏8字节对齐。因此，一个健壮的实现会同时压入两个寄存器（例如，LR和一个被使用的[被调用者保存寄存器](@entry_id:747091)如 $r_4$），以维持8字节对齐。这个例子展示了在硬件自动保存部分状态的环境下，软件层面仍需仔细遵循ABI规则，特别是栈对齐，以确保与高级语言的正确交互。

在[x86架构](@entry_id:756791)上，情况类似但细节不同。当一个需要传递错误码的异常（如页错误）发生时，CPU硬件会将错误码压入栈中，位于返回地址和其他状态信息之上。内核中的汇编包装器在调用C语言处理函数前，需要将这个由硬件提供的错误码作为第一个参数传递。根据cdecl[调用约定](@entry_id:753766)，参数从右到左压栈。因此，包装器需要先压入指向保存所有寄存器状态的trap_frame结构的指针，然后再压入错误码。对于那些硬件不提供错误码的异常，包装器必须自己压入一个占位的0值，以维持统一的函数接口。这再次说明，软件包装器如何通过遵循ABI，将硬件层面多样化的行为抽象成一个统一、可预测的软件接口。

### 高级语言与编译器实现

参数传递的规则不仅是硬件和[操作系统](@entry_id:752937)的专利，它们也深刻影响着高级编程语言的实现方式和编译器的优化策略。程序员日常使用的语言特性，其底层实现往往与ABI紧密相连。

#### [面向对象编程](@entry_id:752863)中的`this`指针

在C++等面向对象语言中，调用一个非静态成员函数（如 `object->method(arg)`）时，编译器会隐式地将对象的地址作为一个额外的、隐藏的第一个参数传递给该函数。这个参数就是 `this` 指针。这个过程完全遵循目标平台的ABI。例如，在x86-64上，若使用System V ABI，`this` 指针会被放入 $rdi$ 寄存器；若使用Microsoft x64 ABI，则会被放入 $rcx$ 寄存器。

当涉及多重继承时，情况变得更加复杂和有趣。如果一个类 `D` 同时继承自 `A` 和 `B`，在 `D` 的[对象布局](@entry_id:752866)中，`A` 子对象可能位于偏移量0处，而 `B` 子对象可能位于某个非零偏移量（例如+16字节）处。如果通过一个指向 `B` 子对象的指针来调用一个被 `D` 重写的虚函数 `g()`，那么传递给 `g()` 的 `this` 指针最初将指向 `B` 子对象（即 `D` 对象的+16字节处）。然而，`D::g()` 的实现是被编译为期望 `this` 指针指向 `D` 对象本身的起始位置（偏移量0）。

为了解决这个不匹配，编译器会生成一个小的代码片段，称为“thunk”。[虚函数表](@entry_id:756585)（vtable）中相应的条目不会直接指向 `D::g()` 的实现，而是指向这个thunk。这个thunk的唯一工作就是调整 `this` 指针——在这个例子中，它会将传入的 `this` 指针减去16——然后无条件地跳转到 `D::g()` 的主函数体。这个过程对程序员是完全透明的，但它完美地展示了[参数传递机制](@entry_id:753160)如何与复杂的语言特性（如多重继承和虚函数）协同工作，以确保语义的正确性。

#### 编译器的[性能优化](@entry_id:753341)

参数传递本身是有开销的，包括寄存器移动、栈操作以及函数调用和返回的指令开销。因此，编译器会采用各种优化手段来最小化这些开销。

**[函数内联](@entry_id:749642)（Inlining）** 是一种常见的优化。编译器将函数调用替换为函数体本身的代码，从而完全消除了调用/返回开销和参数传递开销。然而，这并非没有代价。当函数体被内联到调用者中时，其局部变量（临时量）必须与调用者的局部变量共享可用的物理寄存器。如果两者的寄存器需求之和超过了可用寄存器的数量，就会导致“[寄存器压力](@entry_id:754204)”增加，迫使编译器将一些变量“[溢出](@entry_id:172355)”（spill）到内存中，即在需要时从内存加载，在修改后存回内存。这会引入额外的内存访问开销。因此，内联的净效益是一个权衡：节省的调用开销是否大于可能引入的溢出开销。一个简单的性能模型可以量化这个过程：例如，一次[函数调用](@entry_id:753765)节省了固定的调用开销（如12周期）和参数传递开销（如5个参数，每个2周期，共10周期），但如果内联导致了3个[寄存器溢出](@entry_id:754206)，每个[溢出](@entry_id:172355)需要一次加载（3周期）和一次存储（3周期），则会引入18周期的额外开销。在这种情况下，总收益是 $12+10-18=4$ 周期，内联仍然是有效的。编译器在做决策时会使用类似的启发式模型。

**参数聚合（Argument Aggregation）** 是另一种针对多参数函数的优化。当一个函数有大量参数时，根据ABI，许多参数可能需要通过栈传递，这涉及到多次内存写操作。如果编译器（尤其是在[链接时优化](@entry_id:751337)LTO阶段，拥有全局视野时）发现一个函数的所有调用点都在其控制之下，且该函数地址未被取走，它可以进行一个激进的转换。编译器可以创建一个内部版本的函数，该函数只接受一个参数：一个指向包含所有原始参数的聚合结构体（aggregate）的指针。然后，它会重写所有的调用点，让调用者在自己的栈上构建这个聚合结构体，然后只传递一个指针。这种转换将多次栈参数传递简化为一次寄存器参数传递。这种优化对于减少调用点的代码大小和潜在的内存访问非常有效，但它必须小心处理语义正确性。例如，为了保持“[按值传递](@entry_id:753240)”的语义，必须确保被调用者不会修改聚合体内容，或者如果多个调用共享同一个聚合体，那么在每次调用前都需要确保其内容是最新的，没有因别名（aliasing）而变脏。

### [互操作性](@entry_id:750761)与跨领域通信

在由不同语言、平台和系统组成的异构世界中，ABI是确保它们能够相互通信的“通用语”。理解参数传递的规则对于构建跨语言和跨平台的接口至关重要。

#### 跨平台[调用约定](@entry_id:753766)桥接

不同的[操作系统](@entry_id:752937)平台，即使在相同的硬件架构上，也可能采用不同的ABI。一个典型的例子是x86-64架构上的System V ABI（用于Linux/macOS）和Microsoft x64 ABI（用于Windows）。当需要编写跨平台代码或在两个平台之间进行接口调用时，就必须处理这些ABI差异。

例如，考虑一个函数签名为 `f(int64, double, int64, double)`。
- 在 **System V ABI**下，参数按类型分类。两个 `int64` 参数会进入前两个可用的[通用寄存器](@entry_id:749779)（$rdi$, $rsi$），而两个 `double` 参数会进入前两个可用的浮点寄存器（$xmm0$, $xmm1$）。
- 在 **Windows x64 ABI**下，参数按位置分配。前四个参数无论类型如何，都会按顺序映射到寄存器 $rcx$, $rdx$, $r8$, $r9$。如果参数是[浮点](@entry_id:749453)类型，它还会被“镜像”到对应的XMM寄存器（$xmm0$至$xmm3$）。因此，`int64` 参数1进入 $rcx$，`double` 参数2进入 $xmm1$ (并且其位置由 $rdx$ 占据)，`int64` 参数3进入 $r8$，`double` 参数4进入 $xmm3$ (位置由 $r9$ 占据)。

为了让一个遵循System V ABI的调用者能够调用一个遵循Windows ABI的被调用者，必须创建一个“thunk”或“bridge”层。这个thunk需要进行一系列的 `mov` 指令来重新[排列](@entry_id:136432)寄存器中的参数。此外，Windows ABI还要求调用者在栈上为被调用者预留32字节的“home space”或“shadow space”。这个thunk还必须在调用前调整[栈指针](@entry_id:755333)，以分配这个空间并保持16字节的栈对齐。这个过程清晰地表明，二[进制](@entry_id:634389)级别的[互操作性](@entry_id:750761)需要对不同ABI的参数传递规则有精确的了解。

#### 托管语言与本地代码的交互

当高级托管语言（如Python, Java, C#）需要调用本地代码（如C/C++库）时，就会出现所谓的[外部函数接口](@entry_id:749515)（Foreign Function Interface, FFI）。这里的挑战在于弥合托管运行时的抽象世界与本地代码的原始[内存模型](@entry_id:751871)之间的“语义鸿沟”。

以Python（CPython）调用C扩展为例。一个Python对象在C层面表示为一个 `PyObject*` 指针。在ABI层面，这只是一个普通的指针（一个内存地址），它会被[按值传递](@entry_id:753240)到寄存器中（例如，在System V ABI下放入 $rdi$）。然而，CPython的[内存管理](@entry_id:636637)是基于引用计数的。ABI本身完全不知道引用计数的概念。如果C代码打算长期持有这个对象的引用（例如，将其存储在一个全局变量中），它就必须显式地增加该对象的引用计数（通过调用 `Py_INCREF`）。否则，当原始的Python引用超出作用域时，对象的引用计数可能降为零，导致对象被销毁，而C代码中持有的将是一个悬空指针。

为了管理这种复杂性，Python C-API文档中定义了一套软件层面的约定：参数可以是“借用引用”（borrowed reference）或“新引用”（new reference）。“借用引用”意味着调用者仍然拥有该对象，被调用者不能永久持有它，除非它自己通过 `Py_INCREF` 创建一个“新引用”。当一个C函数创建一个新对象并返回时，它返回一个“新引用”，将所有权转交给调用者，调用者最终有责任减少其引用计数。这些软件约定是建立在原始ABI之上的必要抽象，用以安全地管理跨语言边界的对象生命周期。

对于使用[垃圾回收](@entry_id:637325)（GC）的语言（如Java或.NET），情况类似但有其特殊性。这些语言的GC是“移动式”的，意味着为了减少[内存碎片](@entry_id:635227)，GC可能会在内存中移动对象。如果将一个指向托管对象的指针直接传递给本地代码，GC的下一次运行可能会使这个指针失效。为了解决这个问题，[JIT编译](@entry_id:750967)器在生成调用本地代码的stub时，必须“钉住”（pin）这个对象。钉住操作会通知GC，在本地调用返回之前，暂时不要移动这个对象。这确保了传递给本地代码的直接内存指针在整个调用期间保持有效。这个过程对值类型（如 `int` 或 `double`）来说通常不是必需的，它们的值可以直接复制并传递，但对于需要被本地代码解引用的对象引用来说，这是至关重要的。

### 架构多样性与专业化

[调用约定](@entry_id:753766)并非一成不变，它们会随着[处理器架构](@entry_id:753770)的演进而发展，以支持新的计算[范式](@entry_id:161181)或提供更高的性能。

#### SPARC寄存器窗口

SPARC架构提供了一种独特的、基于硬件的[参数传递机制](@entry_id:753160)，称为“寄存器窗口”（register windows）。与传统的x86或ARM架构中固定的、由软件管理的调用者保存/[被调用者保存寄存器](@entry_id:747091)不同，SPARC提供了一个大的[物理寄存器文件](@entry_id:753427)，被组织成一组重叠的“窗口”。每个函数在调用时会获得一个新的窗口。窗口的精妙之处在于重叠：调用者窗口中的“out”寄存器（`%o0`–`%o7`）在物理上与被调用者窗口中的“in”寄存器（`%i0`–`%i7`）是相同的。

因此，参数传递变得极其高效：调用者只需将参数放入自己的`%o`寄存器中，然后执行 `call` 指令。被调用者执行 `save` 指令后，这些参数就自动出现在自己的`%i`寄存器中，无需任何 `mov` 指令。当硬件窗口耗尽时（即[函数调用](@entry_id:753765)深度超过了硬件窗口的数量），会触发一个“窗口溢出”陷阱，由[操作系统](@entry_id:752937)介入，将最旧的窗口内容保存到内存中的栈上，从而释放一个硬件窗口。相反，当函数返回导致窗口需要恢复时，如果所需窗口不在寄存器文件中，会触发“窗口欠载”陷阱，由[操作系统](@entry_id:752937)从内存中加载回来。这种机制将函数调用的大部分开销从软件转移到了硬件和（在极端情况下）[操作系统](@entry_id:752937)。

#### ARM可伸缩矢量扩展 (SVE)

现代计算的一个趋势是[向量化](@entry_id:193244)，即单条指令处理多个数据元素。ARM的可伸缩矢量扩展（SVE）是这一领域的前沿技术。SVE的一个核心特性是“[向量长度](@entry_id:156432)无关”（vector-length agnostic）编程，即同一份二[进制](@entry_id:634389)代码可以在具有不同[向量长度](@entry_id:156432)（例如128位、256位或512位）的硬件上运行，而无需重新编译。

这就给ABI设计带来了独特的挑战：如何传递一个“大小未知”的向量？如果[按值传递](@entry_id:753240)，编译器不知道要在栈上分配多少空间；如果按[引用传递](@entry_id:753238)，也面临同样的问题。SVE的解决方案是，在ABI中定义了新的参数类型，如 `svfloat32_t`（可伸缩的单精度浮点向量），并规定它们必须在专用的可伸缩向量寄存器（`z0`–`z31`）和谓词寄存器（`p0`–`p15`）中传递。例如，一个接受两个 `svfloat32_t` 和一个 `svbool_t`（可伸缩谓词）的函数，会分别在 $z0$, $z1$ 和 $p0$ 中接收它的参数。返回值则在 $z0$ 中。由于硬件指令本身就是向量长度无关的，这种纯寄存器传递方案使得整个调用过程也与具体的向量长度[解耦](@entry_id:637294)，从而实现了真正的二[进制](@entry_id:634389)兼容性。

### 安全系统中的参数传递

在安全关键型系统中，参数传递的方式不仅影响性能和正确性，更直接关系到系统的安全性。错误的约定可能导致[信息泄露](@entry_id:155485)或[权限提升](@entry_id:753756)。

#### 硬件强制的信任边界：[Intel SGX](@entry_id:750706)

Intel软件保护扩展（SGX）提供了一种在CPU内部创建硬件隔离的“安全区”（enclave）的能力，即使在[操作系统](@entry_id:752937)被攻破的情况下也能保护代码和数据的机密性和完整性。当不可信的“主机”应用调用安全区内的函数（一个ECALL）时，参数传递必须跨越这个硬件强制的信任边界。

将一个指针从不可信世界传递到可信世界是极其危险的。为了应对这种风险，SGX的接口定义语言（EDL）和其生成的“桥接代码”（trusted bridge）实现了严格的参数“编组”（marshaling）规则。对于标记为 `[in]` 的指针参数，桥接代码不会直接传递原始指针。相反，它会在安全区内部开辟一块新的内存，对外部指针进行严格的[边界检查](@entry_id:746954)（确保它不指向安全区内部且不会导致地址[溢出](@entry_id:172355)），然后将外部内存的内容“深拷贝”到安全区内部。安全区内的函数实际操作的是这个内部的安全副本。这种机制有效地防止了“[检查时-使用时](@entry_id:756030)”（Time-of-Check-Time-of-Use, [TOCTOU](@entry_id:756027)）攻击，即攻击者在指针被验证后、使用前修改其指向的内容。对于 `[out]` 指针，过程相反：安全区函数写入内部缓冲区，调用返回后桥接代码再将其内容拷贝到外部。虽然这引入了数据拷贝的开销，但它是确保安全所必需的。EDL也提供了 `[user_check]` 选项，它会直接传递原始指针以追求极致性能，但也将全部验证和防止[TOCTOU](@entry_id:756027)攻击的责任推给了安全区开发者。

#### 基于能力的[操作系统安全](@entry_id:753017)模型

在传统的Unix-like[操作系统](@entry_id:752937)中，一个文件描述符（file descriptor）只是一个整数。它的权限来自于上下文——即它在哪个进程的文件描述符表中的哪个位置。整数本身不携带任何权限信息。

一种更现代、更安全的[操作系统](@entry_id:752937)设计[范式](@entry_id:161181)是基于“能力”（capability）的。在这种模型中，一个指向内核对象（如一个打开的文件）的句柄不再是一个简单的整数，而是一个由内核创建和验证的、不可伪造的“能力”令牌。这个令牌本身就封装了对该对象的操作权限（如读、写）。参数传递因此从“传递一个索引”演变成了“委托一份权限”。

这种设计的深刻之处在于它如何处理能力的复制。如果复制一个能力会创建一个拥有相同权限的别名（alias-copy），这就类似于Unix的 `dup` [系统调用](@entry_id:755772)。但能力系统可以提供更精细的控制，例如“衰减复制”（attenuating-copy），即新创建的能力副本的权限是原始能力权限的一个严格[子集](@entry_id:261956)。这使得遵循“[最小权限原则](@entry_id:753740)”变得非常容易：一个拥有读写权限的进程可以创建一个只读的副本传递给一个它不完全信任的[子模](@entry_id:148922)块。这种设计将安全策略直接融入了参数传递和对象引用的核心机制中。

#### 防止秘密[信息泄露](@entry_id:155485)

在处理高度敏感数据（如加密密钥）的固件或引导程序（boot ROM）中，一个核心安全目标是确保这些秘密永远不会被写入内存。如果一个秘密 `K` 被加载到一个寄存器中，那么从它被加载到它被销毁的整个生命周期内，必须杜绝所有可能导致该寄存器内容被写入内存的路径。

这要求设计一个极其严格的、非标准的[调用约定](@entry_id:753766)。首先，必须禁用所有依赖于栈的[被调用者保存寄存器](@entry_id:747091)约定，所有寄存器都应视为调用者保存。其次，必须通过[静态分析](@entry_id:755368)或特殊的编译器模式来完全禁止[寄存器溢出](@entry_id:754206)。更微妙的是，必须处理异步中断。许多架构在响应中断时，会自动将部分或全部寄存器压入栈中。如果秘密 `K` 恰好位于其中一个寄存器中，一个随机到来的中断就会导致它被泄露到内存。因此，在处理秘密期间，必须全局禁用中断，或者使用具有“影子寄存器组”的硬件，当中断发生时切换寄存器组而不是压栈。这种为安全而定制的参数传递和执行模型，展示了对整个系统（编译器、OS、硬件）行为的通盘考虑是何等重要。

### 调试与工具链支持

参数传递的复杂性，尤其是经过[编译器优化](@entry_id:747548)后，给程序调试带来了巨大挑战。现代工具链通过丰富的调试信息来应对这一挑战。

在编译过程中，一个参数的“位置”是动态变化的。在函数入口，它可能位于ABI指定的寄存器中（如 $rdi$）。几条指令之后，为了释放该寄存器，编译器可能将其移动到栈上的一个槽位。再往后，如果编译器通过[常量传播](@entry_id:747745)分析出该参数的值是一个常量（例如13），它可能会直接在代码中使用这个[立即数](@entry_id:750532)，而该参数在任何寄存器或内存中都不再有“家”。最后，当该参数的生命周期结束时，它就完全“消失”了。

为了让调试器在程序的任何断点处都能准确地告诉开发者参数的值，编译器会生成DWARF（Debugging With Attributed Record Formats）调试信息。对于每个变量，编译器会生成一个“位置列表”（location list）。这是一个表格，将[程序计数器](@entry_id:753801)（PC）的范围映射到描述该变量位置的DWARF表达式。例如，一个位置列表可能这样描述一个参数 `p`：
- 在PC范围 `[0x400710, 0x400720)`，`p` 位于寄存器 $rdi$。
- 在PC范围 `[0x400720, 0x400730)`，`p` 位于栈地址 $rsp-16$ 处。
- 在PC范围 `[0x400730, 0x400760)`，`p` 的值就是常量13（使用特殊的 `DW_OP_stack_value` 表达式）。
- 在PC范围 `[0x400760, ...)`，没有条目，表示 `p` 已被优化掉，值不可用。

当调试器停在某个P[C值](@entry_id:272975)时，它会查询这个位置列表，找到对应的条目，并解释其表达式，从而找到或重构出参数的值。这使得开发者能够以一种符合源代码逻辑的方式进行调试，而无需手动追踪优化后代码中数据的[复杂流动](@entry_id:747569)。

### 结论

通过本章的探讨，我们看到参数传递远不止是将数据从一个函数传递到另一个函数的简单机制。它是一个深刻的、跨领域的概念，是计算机科学中许多核心领域的交汇点。[调用约定](@entry_id:753766)是硬件架构、[操作系统](@entry_id:752937)、编译器和高级语言之间签订的社会契约，它确保了软件世界的模块化和[互操作性](@entry_id:750761)。对这些约定的理解，以及对其背后设计哲学的洞察，对于任何希望在系统层面构建高效、健壮和安全软件的工程师和科学家来说，都是一项不可或缺的关键技能。