{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你深入指令集设计的核心，通过比较标准与压缩指令格式，让你亲身体验指令集架构（ISA）的选择如何影响代码密度。通过手动编码一小段代码 ，你将学会验证不同编码方式如何保持执行等效性。这项实践对于理解现代处理器在性能、代码大小和硬件复杂性之间的权衡至关重要。",
            "id": "3655278",
            "problem": "一个精简指令集计算机五代 (RISC-V) 32位整数基础 (RV32I) 程序需要进行编码，一种是仅使用基准的 RV32I $32$ 位指令，另一种是使用 RISC-V 压缩 (RVC) 扩展，该扩展为特定情况引入了 $16$ 位编码。代码从地址 $0x1000$ 开始，并按地址递增顺序执行。\n\n给定以下指令语义和编码事实的子集作为基本依据：\n\n- 基准 RV32I：\n  - 所有基准指令占用 $32$ 位，即每个指令 $4$ 字节。\n  - 程序计数器 (PC) 在每次取指后按指令宽度增加。\n  - 以下指令的语义是标准的：\n    - $\\mathrm{ADDI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s + i$。\n    - $\\mathrm{ADD}\\ r_d, r_s1, r_s2$: $r_d \\leftarrow r_{s1} + r_{s2}$。\n    - $\\mathrm{ANDI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s \\ \\ \\ i$。\n    - $\\mathrm{ORI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s \\,|\\, i$。\n    - $\\mathrm{LW}\\ r_d, u(r_s)$: $r_d \\leftarrow \\mathrm{MEM}[r_s + u]$，其中 $u$ 是一个字节偏移量。\n    - $\\mathrm{SW}\\ r_s2, u(r_s1)$: $\\mathrm{MEM}[r_{s1} + u] \\leftarrow r_{s2}$。\n    - $\\mathrm{BEQ}\\ r_s1, r_s2, \\mathrm{label}$: 若 $r_{s1} = r_{s2}$，则使用 PC 相对位移 $\\delta$ 跳转到 $\\mathrm{label}$，计算方式为 $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$；$\\delta$ 必须是架构范围内可编码的、有符号的、$2$字节的倍数。\n- 本问题中使用的 RISC-V 压缩 (RVC) $16$ 位形式（所有未提及的形式均不可用）：\n  - $\\mathrm{C.ADDI}\\ r_d, i$: 当 $r_d \\neq x0$ 且 $i \\in \\{-32, -31, \\ldots, -1, 1, \\ldots, 31\\}$ 时可用；语义与 $\\mathrm{ADDI}\\ r_d, r_d, i$ 相同；宽度 $16$ 位。\n  - $\\mathrm{C.ANDI}\\ r_d, i$: 当 $r_d \\in \\{x8, x9, \\ldots, x15\\}$ 且 $i \\in \\{-32, -31, \\ldots, 31\\}$ 时可用；语义与 $\\mathrm{ANDI}\\ r_d, r_d, i$ 相同；宽度 $16$ 位。\n  - $\\mathrm{C.LW}\\ r_d, u(r_s)$: 当 $r_d, r_s \\in \\{x8, x9, \\ldots, x15\\}$ 且 $u$ 是一个无符号字节偏移量，是 $4$ 的倍数且位于 $\\{0, 4, 8, \\ldots, 252\\}$ 集合中时可用；语义与 $\\mathrm{LW}$ 相同；宽度 $16$ 位。\n  - $\\mathrm{C.SW}\\ r_s2, u(r_s1)$: 当 $r_{s2}, r_{s1} \\in \\{x8, x9, \\ldots, x15\\}$ 且 $u$ 是一个无符号字节偏移量，是 $4$ 的倍数且位于 $\\{0, 4, 8, \\ldots, 252\\}$ 集合中时可用；语义与 $\\mathrm{SW}$ 相同；宽度 $16$ 位。\n  - $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$: 当 $r_s \\in \\{x8, x9, \\ldots, x15\\}$ 时可用；若 $r_s = x0$，则使用位移 $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$ 跳转，该位移必须是 $\\{-256, -254, \\ldots, -2, 0, 2, \\ldots, 254\\}$ 集合内的一个有符号的、$2$ 字节的倍数；宽度 $16$ 位。\n  - 此子集中没有 $\\mathrm{C.ORI}$；$\\mathrm{ORI}$ 保持为 $32$ 位。\n- 所有内存访问都是自然对齐且合法的；寄存器 $x0$ 硬连线到零；寄存器名称 $x0, x1, \\ldots, x31$ 指的是标准的 RISC-V 整数寄存器。\n- 这里所要求的执行等效性概念是指，用压缩形式（如果可用）替换基准指令，会保留寄存器和内存的架构状态转换，并保留控制流目标。\n\n考虑以下 RV32I 汇编代码片段，其标签和基地址如下所示：\n- 基地址：$\\mathrm{addr}(\\mathrm{start}) = 0x1000$。\n- 代码：\n  1) $\\mathrm{ADDI}\\ x8, x8, 12$\n  2) $\\mathrm{LW}\\ x9, 16(x8)$\n  3) $\\mathrm{ADD}\\ x5, x6, x7$\n  4) $\\mathrm{SW}\\ x9, 20(x8)$\n  5) $\\mathrm{ORI}\\ x10, x10, 512$\n  6) $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$\n  7) $\\mathrm{ADDI}\\ x3, x3, 100$\n  8) $\\mathrm{L1}: \\mathrm{ANDI}\\ x12, x12, 31$\n\n任务：\n1) 对每条指令，判断上述定义的 RVC $16$ 位形式是否适用，如果适用请指明其名称；否则，该指令保持为 $32$ 位。\n2) 在仅使用 RV32I（所有指令为 $32$ 位）的假设下，计算每条指令的地址以及第 $6$ 行的 $\\mathrm{BEQ}$ 指令所使用的分支位移 $\\delta_{\\mathrm{RV32I}}$。\n3) 根据任务 $1$ 的结果，在所有适用的地方使用 RVC，计算混合宽度编码下每条指令的地址以及第 $6$ 行的 $\\mathrm{C.BEQZ}$ 指令（如果可压缩）所使用的分支位移 $\\delta_{\\mathrm{RVC}}$。\n4) 计算两种编码的总代码大小（以字节为单位）和代码大小压缩比\n   $$R \\equiv \\frac{\\text{压缩后的总字节数}}{\\text{基准总字节数}}。$$\n   将 $R$ 表示为最简分数。无需四舍五入。\n5) 简要证明，在所述约束条件下，对此代码片段进行的压缩替换保留了执行等效性。\n\n你的最终答案必须仅为 $R$ 的单个值，表示为一个无单位的最简分数，不得包含其他任何内容。",
            "solution": "问题陈述已经过验证，被认为是合理的。这是一个在计算机体系结构领域，特别是关于 RISC-V 指令集的，定义明确的问题。所提供的规则，尽管是完整规范的一个子集，并包含了分支位移计算的特定定义，但其本身是自洽和一致的。\n\n解决方案将通过处理问题陈述中概述的五个任务来展开。\n\n**任务 1：RVC 适用性分析**\n\n我们分析所提供代码片段中的每条指令，以根据给定规则确定其是否可以被 $16$ 位的 RVC 等效指令替换。\n\n1.  $\\mathrm{ADDI}\\ x8, x8, 12$: 这条指令符合 $\\mathrm{ADDI}\\ r_d, r_d, i$ 的形式。目标寄存器是 $r_d = x8$，不等于 $x0$。立即数是 $i = 12$，在 $\\mathrm{C.ADDI}$ 允许的范围 $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$ 内。因此，该指令可压缩为 $\\mathrm{C.ADDI}\\ x8, 12$。其宽度为 $16$ 位（$2$ 字节）。\n\n2.  $\\mathrm{LW}\\ x9, 16(x8)$: 寄存器是 $r_d = x9$ 和 $r_s = x8$。两者都在 $\\mathrm{C.LW}$ 所要求的集合 $\\{x8, x9, \\ldots, x15\\}$ 内。偏移量是 $u = 16$。这是一个无符号的 $4$ 的倍数，且在允许的范围 $\\{0, 4, \\ldots, 252\\}$ 内。因此，该指令可压缩为 $\\mathrm{C.LW}\\ x9, 16(x8)$。其宽度为 $16$ 位（$2$ 字节）。\n\n3.  $\\mathrm{ADD}\\ x5, x6, x7$: 这是一个三操作数寄存器-寄存器指令。问题没有为这种形式提供 $16$ 位的 RVC 等效指令。因此，它保持为 $32$ 位（$4$ 字节）的基准指令。\n\n4.  $\\mathrm{SW}\\ x9, 20(x8)$: 寄存器是 $r_{s2} = x9$ 和 $r_{s1} = x8$。两者都在 $\\mathrm{C.SW}$ 所要求的集合 $\\{x8, x9, \\ldots, x15\\}$ 内。偏移量是 $u = 20$。这是一个无符号的 $4$ 的倍数，且在允许的范围 $\\{0, 4, \\ldots, 252\\}$ 内。因此，该指令可压缩为 $\\mathrm{C.SW}\\ x9, 20(x8)$。其宽度为 $16$ 位（$2$ 字节）。\n\n5.  $\\mathrm{ORI}\\ x10, x10, 512$: 问题陈述明确指出“此子集中没有 $\\mathrm{C.ORI}$”。此外，立即数 $i=512$ 远超 RVC 指令典型的小立即数范围。该指令保持为 $32$ 位（$4$ 字节）的基准指令。\n\n6.  $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$: 这条指令在寄存器 $x10$ 等于寄存器 $x0$（硬连线到零）时跳转。这等同于在 $x10$ 为零时跳转。RVC 形式 $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$ 在 $r_s \\in \\{x8, \\ldots, x15\\}$ 时可用。这里，$r_s = x10$，满足该条件。压缩的有效性还取决于分支位移，我们稍后会分析，但指令形式是可压缩的。假设位移有效，其宽度为 $16$ 位（$2$ 字节）。\n\n7.  $\\mathrm{ADDI}\\ x3, x3, 100$: 这条指令符合可能压缩为 $\\mathrm{C.ADDI}$ 的形式。然而，立即数是 $i = 100$。这个值不在允许的范围 $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$ 内。因此，该指令不可压缩，保持为 $32$ 位（$4$ 字节）的基准指令。\n\n8.  $\\mathrm{ANDI}\\ x12, x12, 31$: 这条指令的 $r_d = x12$，在 $\\mathrm{C.ANDI}$ 所要求的集合 $\\{x8, \\ldots, x15\\}$ 内。立即数是 $i = 31$，在允许的范围 $\\{-32, \\ldots, 31\\}$ 内。因此，该指令可压缩为 $\\mathrm{C.ANDI}\\ x12, 31$。其宽度为 $16$ 位（$2$ 字节）。\n\n**任务 2：仅使用基准 RV32I 指令的分析**\n\n假设所有 $8$ 条指令均为 $32$ 位（$4$ 字节）宽，我们可以从基地址 $0x1000$ 开始确定每条指令的地址。\n\n- 指令 1 ($\\mathrm{ADDI}$): 地址 $ = 0x1000$\n- 指令 2 ($\\mathrm{LW}$): 地址 $ = 0x1000 + 4 = 0x1004$\n- 指令 3 ($\\mathrm{ADD}$): 地址 $ = 0x1004 + 4 = 0x1008$\n- 指令 4 ($\\mathrm{SW}$): 地址 $ = 0x1008 + 4 = 0x100C$\n- 指令 5 ($\\mathrm{ORI}$): 地址 $ = 0x100C + 4 = 0x1010$\n- 指令 6 ($\\mathrm{BEQ}$): 地址 $ = 0x1010 + 4 = 0x1014$\n- 指令 7 ($\\mathrm{ADDI}$): 地址 $ = 0x1014 + 4 = 0x1018$\n- 指令 8 ($\\mathrm{L1}: \\mathrm{ANDI}$): 地址 $ = 0x1018 + 4 = 0x101C$\n\n代码的总大小为 $8 \\times 4 = 32$ 字节。\n\n位于地址 $\\mathrm{PC} = 0x1014$ 的 $\\mathrm{BEQ}$ 指令的分支位移是使用提供的公式 $\\delta_{\\mathrm{RV32I}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$ 计算的。目标标签 $\\mathrm{L1}$ 位于地址 $0x101C$。\n$$ \\delta_{\\mathrm{RV32I}} = 0x101C - (0x1014 + 4) = 0x101C - 0x1018 = 4 $$\n位移为 $4$ 字节，这是一个有符号的 $2$ 字节的倍数，并且完全在 B 型指令的标准架构范围内。\n\n**任务 3：使用 RVC 替换后的分析**\n\n使用任务 1 中的可压缩性结果，我们确定新的指令地址。\n压缩后的大小：$2$, $2$, $4$, $2$, $4$, $2$, $4$, $2$ 字节。\n\n- 指令 1 ($\\mathrm{C.ADDI}$): 地址 $ = 0x1000$，大小 $ = 2$\n- 指令 2 ($\\mathrm{C.LW}$): 地址 $ = 0x1000 + 2 = 0x1002$，大小 $ = 2$\n- 指令 3 ($\\mathrm{ADD}$): 地址 $ = 0x1002 + 2 = 0x1004$，大小 $ = 4$\n- 指令 4 ($\\mathrm{C.SW}$): 地址 $ = 0x1004 + 4 = 0x1008$，大小 $ = 2$\n- 指令 5 ($\\mathrm{ORI}$): 地址 $ = 0x1008 + 2 = 0x100A$，大小 $ = 4$\n- 指令 6 ($\\mathrm{C.BEQZ}$): 地址 $ = 0x100A + 4 = 0x100E$，大小 $ = 2$\n- 指令 7 ($\\mathrm{ADDI}$): 地址 $ = 0x100E + 2 = 0x1010$，大小 $ = 4$\n- 指令 8 ($\\mathrm{L1}: \\mathrm{C.ANDI}$): 地址 $ = 0x1010 + 4 = 0x1014$，大小 $ = 2$\n\n压缩后代码的总大小为 $2+2+4+2+4+2+4+2 = 22$ 字节。\n\n位于地址 $\\mathrm{PC} = 0x100E$ 的 $\\mathrm{C.BEQZ}$ 指令的分支位移是使用提供的公式 $\\delta_{\\mathrm{RVC}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$ 计算的。目标标签 $\\mathrm{L1}$ 现在位于地址 $0x1014$。\n$$ \\delta_{\\mathrm{RVC}} = 0x1014 - (0x100E + 2) = 0x1014 - 0x1010 = 4 $$\n位移为 $4$ 字节。该值是有符号的 $2$ 的倍数，并且位于为 $\\mathrm{C.BEQZ}$ 指定的集合 $\\{-256, \\dots, 254\\}$ 内。因此，该分支指令的压缩是有效的。\n\n**任务 4：代码大小和压缩比**\n\n- 基准代码总大小（仅 RV32I）：$32$ 字节。\n- 压缩后代码总大小（使用 RVC）：$22$ 字节。\n\n代码大小压缩比 $R$ 定义为：\n$$ R = \\frac{\\text{压缩后的总字节数}}{\\text{基准总字节数}} = \\frac{22}{32} $$\n通过将分子和分母除以它们的最大公约数 $2$ 来化简此分数：\n$$ R = \\frac{11}{16} $$\n\n**任务 5：执行等效性的证明**\n\n对于此特定代码片段，用 RVC 形式替换基准指令保留了执行等效性。\n1.  **状态保持**：对于每条可压缩指令（$\\mathrm{ADDI}$、$\\mathrm{LW}$、$\\mathrm{SW}$、$\\mathrm{ANDI}$），只要满足对操作数（寄存器编号、立即数值）的特定约束，其 RVC 语义就被定义为与其 RV32I 对应指令的语义相同。例如，$\\mathrm{C.ADDI}\\ r_d, i$ 在语义上与 $\\mathrm{ADDI}\\ r_d, r_d, i$ 完全相同。由于我们的分析确认所有约束都已满足，因此每条压缩指令对寄存器和/或内存执行的操作与原始的 $32$ 位指令完全相同。\n2.  **控制流保持**：条件分支指令 $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$ 被替换为 $\\mathrm{C.BEQZ}\\ x10, \\mathrm{L1}$。两者都当且仅当寄存器 $x10$ 的内容为零时发生跳转。分支目标是标签 $\\mathrm{L1}$。尽管 $\\mathrm{L1}$ 的绝对地址在两种编码之间发生了变化（从 $0x101C$ 变为 $0x1014$），但分支指令使用 PC 相对寻址。我们计算了位移（$\\delta_{\\mathrm{RV32I}} = 4$ 和 $\\delta_{\\mathrm{RVC}} = 4$）并确认它们在各自的内存布局中正确地编码了从分支指令到目标指令的跳转。由于分支条件和逻辑目标相同，因此控制流得以保持。\n\n因此，两种程序编码的架构状态变化序列是相同的。",
            "answer": "$$\\boxed{\\frac{11}{16}}$$"
        },
        {
            "introduction": "在理解了单个指令之后，本练习将探索如何将它们组织成更复杂的控制结构，例如跳转表。你将实现一个“地址无关”跳转表的逻辑 ，这是一种编写位置无关代码的关键技术，使得代码可以加载到内存的任何位置而无需修改。这项练习将磨练你处理内存地址、对齐和边界检查的技能，这些都是编写健壮的底层程序所必需的。",
            "id": "3655275",
            "problem": "要求您使用一种通用编程语言，对机器语言和汇编语言中的无重定位跳转表背后的核心思想进行形式化并加以实现。其根本基础是程序计数器 (PC) 的定义，在一个典型的指令集架构 (ISA) 中，PC 是一个字节寻址的寄存器，指向当前待执行的指令。在一个表驱动的控制转移机制中，一个由大小相等的连续代码条目组成的块可以作为跳转目标，通过索引进行选择。\n\n从基本定义出发：\n- 程序计数器 $PC$ 是一个字节地址。\n- 一个代码区域由一个基地址 $B$、每个条目的固定步长 $S$（以字节为单位）以及一个逻辑容量 $n$（条目数）来表征。\n- 索引必须在重定位下保持不变：如果区域和 $PC$ 都被一个位移 $\\delta$ 移动，计算出的索引必须保持不变。\n- 要求对齐和边界正确性：只有与声明的步长对齐且在逻辑容量范围内的条目才是有效的目标。\n- 允许稀疏性：某些逻辑索引可以刻意没有分配处理程序。\n\n您的任务是从这些定义中推导出一个规范化过程，该过程将 $PC$ 映射到表的逻辑索引 $i$，并包含所有必要的边界和对齐检查，以及对稀疏索引的优雅处理。然后，您必须将此过程实现为一个完整、可运行的程序，该程序在给定一小组参数集测试套件的情况下，计算出所选的处理程序标识符或一个明确定义的错误代码。\n\n实现模型和正确性要求：\n- 将地址视为字节地址。使用非负整数作为处理程序标识符。使用负数处理程序标识符表示稀疏（缺失）的条目。\n- 每个测试用例的结果必须是一个整数：\n  - 当规范化索引有效且条目存在时，返回一个等于处理程序标识符的非负整数。\n  - 如果 $PC$ 超出由 $B$、$S$ 和 $n$ 指定的区域范围，则返回 $-1$。\n  - 如果 $PC$ 在边界内但未与步长 $S$ 对齐，则返回 $-2$。\n  - 如果规范化索引有效但条目是稀疏的（缺失），则返回 $-3$。\n- 规范化必须是无重定位的：对于任何位移 $\\delta$，如果 $B \\mapsto B + \\delta$ 且 $PC \\mapsto PC + \\delta$，则计算出的索引 $i$ 必须完全相同。\n\n测试套件：\n请为以下测试用例提供结果，每个用例由 $(B, S, n, PC, \\text{handlers}[0..n-1])$ 指定，其中地址为十六进制字面量，步长和容量为十进制。处理程序为十进制，任何负数处理程序表示一个缺失的条目。\n\n- 用例 A (正常路径): $(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 2 \\cdot 8, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- 用例 B (下边界越界): $(B = 0x1000, S = 8, n = 5, PC = 0x0, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- 用例 C (边界内未对齐): $(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 3 \\cdot 8 + 4, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- 用例 D (稀疏缺失条目): $(B = 0x2000, S = 4, n = 6, PC = 0x2000 + 3 \\cdot 4, \\text{handlers} = [0, -1, 2, -1, 4, 5])$.\n- 用例 E (重定位不变性): $(B = 0x1000 + 0x300, S = 8, n = 5, PC = (0x1000 + 2 \\cdot 8) + 0x300, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- 用例 F (上边界包含): $(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 3 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$.\n- 用例 G (结束边界不包含): $(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 4 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$.\n- 用例 H (大步长): $(B = 0x80000000, S = 512, n = 3, PC = 0x80000000 + 512, \\text{handlers} = [7, 8, 9])$.\n- 用例 I (基地址条目): $(B = 0x5000, S = 32, n = 2, PC = 0x5000, \\text{handlers} = [42, 43])$.\n\n您的程序应产生一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_A,\\text{result}_B,\\dots]$）。不应打印任何其他文本。",
            "solution": "该问题定义明确，科学上基于计算机体系结构的原理，并为推导和实现一个过程提供了完整的规范集。它不包含任何矛盾或歧义。因此，该问题被认为是有效的。\n\n任务是形式化并实现一个过程，该过程将程序计数器地址 $PC$ 映射到一个无重定位跳转表的逻辑索引 $i$。该表由一个基地址 $B$、每个条目的固定大小步长 $S$ 以及总容量为 $n$ 个条目来定义。该过程必须执行所有必要的边界和对齐检查，并处理稀疏条目。\n\n规范化过程的推导从给定的要求逐步进行。\n\n1.  **重定位不变性**：基本约束是索引机制必须是位置无关的。这意味着，如果整个代码段（包括跳转表和当前程序计数器）被某个位移 $\\delta$ 重定位，计算出的索引必须保持不变。设原始基地址为 $B$，程序计数器为 $PC$。重定位后，新地址为 $B' = B + \\delta$ 和 $PC' = PC + \\delta$。为了使索引保持不变，其计算必须仅依赖于 $PC$ 和 $B$ 之间的相对偏移量，即 $\\Delta = PC - B$。这是因为新的偏移量 $\\Delta' = PC' - B' = (PC + \\delta) - (B + \\delta) = PC - B = \\Delta$。因此，所有后续的检查和计算都必须基于这个相对偏移量 $\\Delta$。为便于计算，地址被视为非负无符号整数。\n\n2.  **边界检查**：跳转表由 $n$ 个条目组成，每个条目大小为 $S$ 字节。该表所占用的内存区域从地址 $B$ 开始，到地址 $B + n \\cdot S$ 之前结束。因此，表中任何目标的有效地址范围是 $[B, B + n \\cdot S)$。当且仅当满足条件 $B \\le PC  B + n \\cdot S$ 时，给定的程序计数器 $PC$ 才在该区域的边界内。这是要执行的第一个检查。如果 $PC$ 在此范围之外，则认为其越界。问题规定，在这种情况下，过程必须返回错误代码 $-1$。\n\n3.  **对齐检查**：一个有效的跳转目标必须对应于某个表条目的起始位置。这些入口点的地址是 $B$, $B+S$, $B+2S$, ..., $B+(n-1)S$。这意味着 $PC$ 相对于基地址 $B$ 的偏移量，即 $\\Delta = PC - B$，必须是步长 $S$ 的整数倍。此属性称为对齐。可以通过检查 $\\Delta$ 除以 $S$ 的余数是否为零来验证，即 $(PC - B) \\pmod S = 0$。此检查应对任何在边界内的 $PC$ 执行。如果一个在边界内的 $PC$ 未与步长 $S$ 对齐，则过程必须返回错误代码 $-2$。\n\n4.  **索引计算**：如果一个 $PC$ 通过了边界和对齐检查，它就指向一个有效的条目。该条目的逻辑索引 $i$ 对应于从基地址开始的偏移量中包含多少个大小为 $S$ 的步长。这通过整除来计算：\n    $$i = \\frac{PC - B}{S}$$\n    鉴于边界检查 ($0 \\le PC - B  n \\cdot S$)，计算出的索引 $i$ 保证在大小为 $n$ 的数组的有效范围内，即 $0 \\le i  n$。\n\n5.  **稀疏处理**：问题允许“稀疏”表，其中某些逻辑索引可能没有对应的处理程序。在提供的 `handlers` 数组中，这些稀疏条目由负值表示。在计算出有效索引 $i$ 后，过程必须从 `handlers`[$i$] 中检索处理程序标识符。如果此值为负（即 $\\text{handlers}[i]  0$），则表示这是一个稀疏条目。在这种情况下，过程必须返回错误代码 $-3$。\n\n6.  **成功查找**：如果检索到的处理程序标识符是非负的（即 $\\text{handlers}[i] \\ge 0$），则查找成功。过程的最终结果就是这个非负的处理程序标识符。\n\n总之，对于给定的一组参数 $(B, S, n, PC, \\text{handlers})$，完整的算法如下：\n1.  检查 $PC  B$ 或 $PC \\ge B + n \\cdot S$ 是否成立。如果为真，返回 $-1$。\n2.  计算偏移量 $\\Delta = PC - B$。\n3.  检查 $\\Delta \\pmod S \\neq 0$ 是否成立。如果为真，返回 $-2$。\n4.  计算索引 $i = \\Delta / S$。\n5.  检索处理程序标识符 $h = \\text{handlers}[i]$。\n6.  检查 $h  0$ 是否成立。如果为真，返回 $-3$。\n7.  否则，返回 $h$。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include"
        },
        {
            "introduction": "最后的这项练习将你的视角从指令集提升到应用程序二进制接口（ABI）——这是软件组件之间交互的关键契约。你将为一个对齐敏感的内存分配器建模，并根据 System V AMD64 ABI 分析栈的行为 ，包括函数调用和“红区”的使用规则。这项任务让你从实践中深刻理解，高级语言特性是如何通过严谨的底层约定来支持，从而确保程序的稳定性和互操作性。",
            "id": "3655246",
            "problem": "要求您以数学和算法的方式，形式化并实现一个对齐敏感的内存分配包装器（wrapper）的行为，该包装器将用汇编语言编写，并遵循 System V Advanced Microcontroller Device eXtended (AMD64) Application Binary Interface (ABI)。该包装器必须确保返回的指针满足2的幂次方对齐，并且必须根据 ABI 规定来考虑函数序言（prologue）的调整和红色区域（red-zone）的使用。您的任务是从第一性原理出发，推导出必要的算术和逻辑条件，并实现一个完整的、可运行的程序，该程序能针对一组固定的测试套件产生指定的输出。\n\n使用的基本和核心定义：\n- 整数同余和模运算：对于整数 $x$、$m$，表达式 $x \\equiv r \\pmod{m}$ 表示 $m$ 整除 $(x - r)$。\n- 2的幂次方对齐：一个地址 $A'$ 是 $2^k$ 对齐的，当且仅当 $A' \\equiv 0 \\pmod{2^k}$。\n- 用于掩码的二进制补码属性：对于 $m = 2^k$，位掩码 $m - 1$ 的低 $k$ 位为1，而 $\\lnot(m - 1)$（按位取反）会清除机器字中的那 $k$ 个位。\n- System V AMD64 ABI 事实：\n  1. 栈向低地址方向增长，栈指针 $s$ 在函数入口处必须是 $16$ 字节对齐的（即，在被调用者（callee）入口处有 $s \\equiv 0 \\pmod{16}$）。\n  2. `call` 指令会压入一个 $8$ 字节的返回地址，因此在 `call` 之前，调用者（caller）必须有 $s \\equiv 8 \\pmod{16}$，以确保被调用者的入口栈指针是 $16$ 字节对齐的。\n  3. 红色区域（red-zone）是当前栈指针下方一个 $128$ 字节的区域，可被不调整 $s$ 且不执行调用的叶函数（leaf function）使用。如果函数执行任何调用或通过压栈（push）或减法改变 $s$，则这种用法是不安全的。\n\n您的程序必须为每个测试用例计算：\n1. 最小调整后的对齐地址 $A'$，满足 $A' \\ge A$ 且 $A' \\equiv 0 \\pmod{2^k}$。\n2. 调整量 $\\Delta = A' - A$。\n3. 一个布尔值 $b_1$，指示在给定函数序言调整的情况下，栈指针是否根据 ABI 为 `call` 指令做好了正确准备；形式上，从函数入口处的 $s_0 \\equiv 0 \\pmod{16}$ 开始，应用一次可选的基指针压栈（如果压栈则减去 $8$ 字节），然后为帧分配减去 $F$ 字节，并测试在预期的 `call` 之前是否有 $s \\equiv 8 \\pmod{16}$。\n4. 一个布尔值 $b_2$，指示在红色区域中使用 $R$ 字节的临时空间是否安全；形式上，$b_2$ 为真当且仅当函数是叶函数（$C = 0$），不压入基指针，不减去任何帧大小（即不改变 $s$），且 $R \\le 128$。\n\n要求的输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且其本身也是一个按 $[A', \\Delta, b_1, b_2]$ 顺序排列的四个结果的逗号分隔列表。例如：$[[\\dots],[\\dots],\\dots]$。所有量均使用整数；布尔值使用 $0$ 和 $1$。\n\n测试套件：\n对于每个测试用例，参数为 $(A, k, p, F, C, R)$，其中：\n- $A$ 是底层分配器返回的原始地址，被视为无符号整数。\n- $k$ 是对齐要求 $2^k$ 中的幂。\n- $p$ 是一个布尔值，指示函数序言是否压入基指针（即从栈指针中减去 $8$ 字节）。\n- $F$ 是在序言中从栈指针减去的帧大小（以字节为单位）。\n- $C$ 是函数体执行的 `call` 指令数量。\n- $R$ 是预期的红色区域临时使用空间（以字节为单位）。\n\n使用以下测试用例：\n- 用例 1：$(A = 4099, k = 5, p = 1, F = 16, C = 1, R = 0)$。\n- 用例 2：$(A = 1024, k = 6, p = 0, F = 0, C = 0, R = 64)$。\n- 用例 3：$(A = 123456789, k = 12, p = 1, F = 24, C = 1, R = 0)$。\n- 用例 4：$(A = 555, k = 4, p = 0, F = 0, C = 0, R = 256)$。\n- 用例 5：$(A = 259, k = 3, p = 1, F = 0, C = 0, R = 128)$。\n\n科学真实性约束：\n- 将所有地址视为机器字内的无符号整数；假设 $k$ 满足 $1 \\le k \\le 63$ 以避免 $2^k$ 溢出。\n- 仅通过模 $16$ 的同余类来建模栈指针算术；不执行实际的栈操作。\n\n您的程序必须是自包含的，不得读取任何输入，并且必须计算并以指定的格式在单行上精确打印所有测试用例的结果。",
            "solution": "此问题被评估为有效。它在科学上基于计算机体系结构（特别是 System V AMD64 ABI）和数学（整数同余和位运算）的原理。该问题定义明确，提供了一套清晰、自包含的定义、约束和测试数据，从而导出一个唯一且有意义的解。其语言是客观且正式的。\n\n解决方案要求为每个测试用例 $(A, k, p, F, C, R)$ 计算四个量：对齐地址 $A'$、调整量 $\\Delta$、调用就绪布尔值 $b_1$ 和红色区域安全布尔值 $b_2$。\n\n1.  **对齐地址（$A'$）和调整量（$\\Delta$）的计算**\n\n    目标是找到最小的调整后地址 $A'$，使其大于或等于原始地址 $A$ 且对齐到 $m = 2^k$ 的边界。用数学术语来说，我们寻求满足同余式 $A' \\equiv 0 \\pmod{2^k}$ 的最小 $A' \\ge A$。\n\n    设 $m = 2^k$。任何整数地址 $A$ 都可以使用除法算法表示为相对于 $m$ 的倍数的形式：$A = qm + r$，其中 $q$ 是商，$r = A \\pmod m$ 是余数，且 $0 \\le r  m$。\n\n    如果 $A$ 已经对齐，其余数 $r$ 为 $0$。在这种情况下，最小对齐地址就是 $A$ 本身，所以 $A' = A$，所需的调整量 $\\Delta = A' - A = 0$。\n\n    如果 $A$ 未对齐，$r > 0$。大于 $A$ 的下一个 $m$ 的倍数是 $(q+1)m$。因此，对齐地址是 $A' = (q+1)m$。我们可以用 $A$ 和 $r$ 来表示它：\n    $$A' = (qm + r) + (m - r) = A + (m - r)$$\n    所需的调整量是我们增加的量：\n    $$\\Delta = A' - A = m - r = m - (A \\pmod m)$$\n    我们可以用一个单一的表达式来统一这两种情况（$r=0$ 和 $r>0$）的调整量：\n    $$\\Delta = (m - (A \\pmod m)) \\pmod m$$\n    那么对齐地址就是简单的 $A' = A + \\Delta$。\n\n    在底层编程中，这个操作通常使用位运算更高效地实现。如果一个地址的最低 $k$ 位为零，则它与 $m=2^k$ 对齐。值 $m-1$ 是一个位掩码，其最低的 $k$ 位恰好被设置为 $1$。\n    对齐地址 $A'$ 可以通过将掩码（$m-1$）与 $A$ 相加，然后清除低 $k$ 位来计算。清除低 $k$ 位等效于与反转的掩码 $\\lnot(m-1)$ 进行按位与（AND）操作。\n    $$A' = (A + (2^k - 1)) \\land \\lnot(2^k - 1)$$\n    其中 $\\land$ 是按位与运算符，$\\lnot$ 是按位非运算符。这个公式正确地将 $A$ 向上取整到下一个对齐边界。\n\n2.  **调用就绪布尔值（$b_1$）的计算**\n\n    System V AMD64 ABI 有严格的栈对齐要求。在进入函数时，栈指针 $s$ 必须是 $16$ 字节对齐的。即，$s_{entry} \\equiv 0 \\pmod{16}$。`call` 指令将一个 $8$ 字节的返回地址压入栈中。为确保被调用者接收到一个 $16$ 字节对齐的栈指针，调用者的栈指针在执行 `call` 指令前必须满足 $s_{pre-call} \\equiv 8 \\pmod{16}$。\n\n    我们通过函数序言来建模栈指针模 $16$ 的同余类状态。\n    - 函数入口处的初始状态：$s_0 \\equiv 0 \\pmod{16}$。\n    - 序言可能会将基指针（`rbp`）压入栈中，这将使栈指针减少 $8$ 字节。这种情况在 $p=1$ 时发生。新的栈指针同余式为 $s_1 \\equiv (s_0 - 8p) \\pmod{16}$。由于 $s_0 \\equiv 0 \\pmod{16}$，这可以简化为 $s_1 \\equiv -8p \\pmod{16}$。\n    - 然后，序言通过从栈指针中减去帧大小 $F$ 来为局部变量分配空间。在函数体执行前，最终的栈指针值为 $s_{final} \\equiv (s_1 - F) \\pmod{16}$。\n    - 代入 $s_1$，我们得到 $s_{final} \\equiv (-8p - F) \\pmod{16}$。\n\n    布尔值 $b_1$ 为真当且仅当最终的栈指针的对齐状态适合后续的 `call` 指令。条件是：\n    $$s_{final} \\equiv 8 \\pmod{16}$$\n    因此，如果 $(-8p - F) \\equiv 8 \\pmod{16}$，$b_1$ 为 $1$，否则为 $0$。\n\n3.  **红色区域安全布尔值（$b_2$）的计算**\n\n    红色区域是当前栈指针下方一个 $128$ 字节的区域，函数可以使用它进行临时存储，而无需显式地减少栈指针。然而，只有在特定条件下使用它才是安全的，因为信号或中断处理程序可能会覆盖这个区域。\n\n    ABI 规定，当且仅当函数是*叶函数*且不修改栈指针时，红色区域才是安全的。叶函数是指不调用其他任何函数的函数。\n    $b_2$ 为真（$1$）的条件是以下各项的逻辑与：\n    - 函数必须是叶函数。这由参数 $C$（调用次数）给出。条件是 $C=0$。\n    - 函数不得在其序言中修改栈指针。这意味着它不能压入基指针（$p=0$）并且不能分配栈帧（$F=0$）。\n    - 使用的临时空间量 $R$ 不得超过红色区域的大小，即 $128$ 字节。条件是 $R \\le 128$。\n\n    综合这些，$b_2$ 为 $1$ 当且仅当 $(C=0) \\land (p=0) \\land (F=0) \\land (R \\le 128)$。如果这些条件中有任何一个为假，$b_2$ 就为 $0$。",
            "answer": "```c\n// The complete and compilable C program.\n#include"
        }
    ]
}