{
    "hands_on_practices": [
        {
            "introduction": "Let's begin at the lowest level: instruction encoding. Understanding how assembly mnemonics translate into binary machine code is the foundation of machine language. This exercise  will guide you through hand-encoding a program snippet using both standard and compressed instruction formats, revealing the trade-offs in code size and complexity.",
            "id": "3655278",
            "problem": "A Reduced Instruction Set Computer Five (RISC-V) 32-bit Integer base (RV32I) program is to be encoded both with only the baseline RV32I $32$-bit instructions and with the RISC-V Compressed (RVC) extension, which introduces $16$-bit encodings for certain cases. The code starts at address $0x1000$ and executes in increasing address order.\n\nYou are given the following subset of instruction semantics and encoding facts to serve as the fundamental base:\n\n- Baseline RV32I:\n  - All baseline instructions occupy $32$ bits, i.e., $4$ bytes each.\n  - Program Counter (PC) advances by the instruction width after each fetch.\n  - The semantics of the following instructions are standard:\n    - $\\mathrm{ADDI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s + i$.\n    - $\\mathrm{ADD}\\ r_d, r_s1, r_s2$: $r_d \\leftarrow r_{s1} + r_{s2}$.\n    - $\\mathrm{ANDI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s \\,\\\\, i$.\n    - $\\mathrm{ORI}\\ r_d, r_s, i$: $r_d \\leftarrow r_s \\,|\\, i$.\n    - $\\mathrm{LW}\\ r_d, u(r_s)$: $r_d \\leftarrow \\mathrm{MEM}[r_s + u]$, where $u$ is a byte offset.\n    - $\\mathrm{SW}\\ r_s2, u(r_s1)$: $\\mathrm{MEM}[r_{s1} + u] \\leftarrow r_{s2}$.\n    - $\\mathrm{BEQ}\\ r_s1, r_s2, \\mathrm{label}$: If $r_{s1} = r_{s2}$ then branch to $\\mathrm{label}$ using a PC-relative displacement $\\delta$ computed as $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$; $\\delta$ must be a signed multiple of $2$ bytes within the architectural range to be encodable.\n- RISC-V Compressed (RVC) $16$-bit forms used in this problem (all not mentioned forms are unavailable):\n  - $\\mathrm{C.ADDI}\\ r_d, i$: Available when $r_d \\neq x0$ and $i \\in \\{-32, -31, \\ldots, -1, 1, \\ldots, 31\\}$; semantics identical to $\\mathrm{ADDI}\\ r_d, r_d, i$; width $16$ bits.\n  - $\\mathrm{C.ANDI}\\ r_d, i$: Available when $r_d \\in \\{x8, x9, \\ldots, x15\\}$ and $i \\in \\{-32, -31, \\ldots, 31\\}$; semantics identical to $\\mathrm{ANDI}\\ r_d, r_d, i$; width $16$ bits.\n  - $\\mathrm{C.LW}\\ r_d, u(r_s)$: Available when $r_d, r_s \\in \\{x8, x9, \\ldots, x15\\}$ and $u$ is an unsigned byte offset that is a multiple of $4$ and lies in $\\{0, 4, 8, \\ldots, 252\\}$; semantics identical to $\\mathrm{LW}$; width $16$ bits.\n  - $\\mathrm{C.SW}\\ r_s2, u(r_s1)$: Available when $r_s2, r_s1 \\in \\{x8, x9, \\ldots, x15\\}$ and $u$ is an unsigned byte offset that is a multiple of $4$ and lies in $\\{0, 4, 8, \\ldots, 252\\}$; semantics identical to $\\mathrm{SW}$; width $16$ bits.\n  - $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$: Available when $r_s \\in \\{x8, x9, \\ldots, x15\\}$; branches if $r_s = x0$ using a displacement $\\delta = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$ that must be a signed multiple of $2$ bytes within the set $\\{-256, -254, \\ldots, -2, 0, 2, \\ldots, 254\\}$; width $16$ bits.\n  - There is no $\\mathrm{C.ORI}$ in this subset; $\\mathrm{ORI}$ remains $32$-bit.\n- All memory accesses are naturally aligned and legal; the register $x0$ is hardwired to zero; the register names $x0, x1, \\ldots, x31$ refer to the standard RISC-V integer registers.\n- The notion of execution equivalence required here is that replacing a baseline instruction by its compressed form (when available) preserves the architectural state transitions for registers and memory, and preserves control flow targets.\n\nConsider the following RV32I assembly snippet, with label and base address as indicated:\n- Base address: $\\mathrm{addr}(\\mathrm{start}) = 0x1000$.\n- Code:\n  1) $\\mathrm{ADDI}\\ x8, x8, 12$\n  2) $\\mathrm{LW}\\ x9, 16(x8)$\n  3) $\\mathrm{ADD}\\ x5, x6, x7$\n  4) $\\mathrm{SW}\\ x9, 20(x8)$\n  5) $\\mathrm{ORI}\\ x10, x10, 512$\n  6) $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$\n  7) $\\mathrm{ADDI}\\ x3, x3, 100$\n  8) $\\mathrm{L1}: \\mathrm{ANDI}\\ x12, x12, 31$\n\nTasks:\n1) For each instruction, decide whether an RVC $16$-bit form as defined above applies and name it if applicable; otherwise, it remains $32$-bit.\n2) Using the RV32I-only assumption (all instructions $32$-bit), compute the address of each instruction and the branch displacement $\\delta_{\\mathrm{RV32I}}$ used by the $\\mathrm{BEQ}$ at line $6$.\n3) Using RVC wherever applicable from Task $1$, compute the address of each instruction under the mixed-width encoding and the branch displacement $\\delta_{\\mathrm{RVC}}$ used by the $\\mathrm{C.BEQZ}$ at line $6$ (if compressible).\n4) Compute the total code size in bytes for both encodings and the code-size compression ratio\n   $$R \\equiv \\frac{\\text{total compressed bytes}}{\\text{total baseline bytes}}.$$\n   Express $R$ as a reduced fraction. No rounding is required.\n5) Briefly justify that, under the stated constraints, the compressed substitutions preserve execution equivalence for this snippet.\n\nYour final answer must be the single value of $R$ only, presented as a reduced fraction with no units, and nothing else.",
            "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem in computer architecture, specifically concerning the RISC-V instruction set. The provided rules, though a subset of the full specification and containing specific definitions for branch displacement calculation, are self-contained and consistent.\n\nThe solution proceeds by addressing each of the five tasks outlined in the problem statement.\n\n**Task 1: RVC Applicability Analysis**\n\nWe analyze each instruction in the provided snippet to determine if it can be replaced by a $16$-bit RVC equivalent according to the given rules.\n\n1.  $\\mathrm{ADDI}\\ x8, x8, 12$: This instruction matches the form $\\mathrm{ADDI}\\ r_d, r_d, i$. The destination register is $r_d = x8$, which is not $x0$. The immediate is $i = 12$, which is within the allowed range $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$ for $\\mathrm{C.ADDI}$. Thus, this instruction is compressible into $\\mathrm{C.ADDI}\\ x8, 12$. Its width is $16$ bits ($2$ bytes).\n\n2.  $\\mathrm{LW}\\ x9, 16(x8)$: The registers are $r_d = x9$ and $r_s = x8$. Both are in the required set $\\{x8, x9, \\ldots, x15\\}$ for $\\mathrm{C.LW}$. The offset is $u = 16$. This is an unsigned multiple of $4$ and falls within the allowed range $\\{0, 4, \\ldots, 252\\}$. Thus, this instruction is compressible into $\\mathrm{C.LW}\\ x9, 16(x8)$. Its width is $16$ bits ($2$ bytes).\n\n3.  $\\mathrm{ADD}\\ x5, x6, x7$: This is a three-operand register-register instruction. The problem provides no $16$-bit RVC equivalent for this form. Therefore, it remains a $32$-bit ($4$ byte) baseline instruction.\n\n4.  $\\mathrm{SW}\\ x9, 20(x8)$: The registers are $r_{s2} = x9$ and $r_{s1} = x8$. Both are in the required set $\\{x8, x9, \\ldots, x15\\}$ for $\\mathrm{C.SW}$. The offset is $u = 20$. This is an unsigned multiple of $4$ and falls within the allowed range $\\{0, 4, \\ldots, 252\\}$. Thus, this instruction is compressible into $\\mathrm{C.SW}\\ x9, 20(x8)$. Its width is $16$ bits ($2$ bytes).\n\n5.  $\\mathrm{ORI}\\ x10, x10, 512$: The problem statement explicitly notes that \"There is no $\\mathrm{C.ORI}$ in this subset\". Furthermore, the immediate value $i=512$ is far outside the typical small immediate range for RVC instructions. This instruction remains a $32$-bit ($4$ byte) baseline instruction.\n\n6.  $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$: This instruction branches if register $x10$ is equal to register $x0$ (which is hardwired to zero). This is equivalent to branching if $x10$ is zero. The RVC form $\\mathrm{C.BEQZ}\\ r_s, \\mathrm{label}$ is available if $r_s \\in \\{x8, \\ldots, x15\\}$. Here, $r_s = x10$, which satisfies the condition. The validity of the compression also depends on the branch displacement, which we will analyze later, but the instruction form is compressible. Assuming the displacement is valid, its width is $16$ bits ($2$ bytes).\n\n7.  $\\mathrm{ADDI}\\ x3, x3, 100$: This matches the form for potential compression to $\\mathrm{C.ADDI}$. However, the immediate is $i = 100$. This value is not in the allowed range $\\{-32, \\ldots, -1, 1, \\ldots, 31\\}$. Thus, this instruction is not compressible and remains a $32$-bit ($4$ byte) baseline instruction.\n\n8.  $\\mathrm{ANDI}\\ x12, x12, 31$: This instruction has $r_d = x12$, which is in the required set $\\{x8, \\ldots, x15\\}$ for $\\mathrm{C.ANDI}$. The immediate is $i = 31$, which is in the allowed range $\\{-32, \\ldots, 31\\}$. Thus, this instruction is compressible into $\\mathrm{C.ANDI}\\ x12, 31$. Its width is $16$ bits ($2$ bytes).\n\n**Task 2: Analysis with Baseline RV32I Instructions Only**\n\nAssuming all $8$ instructions are $32$-bit ($4$ bytes) wide, we can determine the address of each instruction starting from the base address $0x1000$.\n\n- Instruction 1 ($\\mathrm{ADDI}$): Address $ = 0x1000$\n- Instruction 2 ($\\mathrm{LW}$): Address $ = 0x1000 + 4 = 0x1004$\n- Instruction 3 ($\\mathrm{ADD}$): Address $ = 0x1004 + 4 = 0x1008$\n- Instruction 4 ($\\mathrm{SW}$): Address $ = 0x1008 + 4 = 0x100C$\n- Instruction 5 ($\\mathrm{ORI}$): Address $ = 0x100C + 4 = 0x1010$\n- Instruction 6 ($\\mathrm{BEQ}$): Address $ = 0x1010 + 4 = 0x1014$\n- Instruction 7 ($\\mathrm{ADDI}$): Address $ = 0x1014 + 4 = 0x1018$\n- Instruction 8 ($\\mathrm{L1}: \\mathrm{ANDI}$): Address $ = 0x1018 + 4 = 0x101C$\n\nThe total size of the code is $8 \\times 4 = 32$ bytes.\n\nThe branch displacement for the $\\mathrm{BEQ}$ instruction at address $\\mathrm{PC} = 0x1014$ is calculated using the provided formula $\\delta_{\\mathrm{RV32I}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 4)$. The target label $\\mathrm{L1}$ is at address $0x101C$.\n$$ \\delta_{\\mathrm{RV32I}} = 0x101C - (0x1014 + 4) = 0x101C - 0x1018 = 4 $$\nThe displacement is $4$ bytes, which is a signed multiple of $2$ bytes and is well within the standard architectural range for a B-type instruction.\n\n**Task 3: Analysis with RVC substitutions**\n\nUsing the compressibility results from Task 1, we determine the new instruction addresses.\nCompressed sizes: $2$, $2$, $4$, $2$, $4$, $2$, $4$, $2$ bytes.\n\n- Instruction 1 ($\\mathrm{C.ADDI}$): Address $ = 0x1000$, Size $ = 2$\n- Instruction 2 ($\\mathrm{C.LW}$): Address $ = 0x1000 + 2 = 0x1002$, Size $ = 2$\n- Instruction 3 ($\\mathrm{ADD}$): Address $ = 0x1002 + 2 = 0x1004$, Size $ = 4$\n- Instruction 4 ($\\mathrm{C.SW}$): Address $ = 0x1004 + 4 = 0x1008$, Size $ = 2$\n- Instruction 5 ($\\mathrm{ORI}$): Address $ = 0x1008 + 2 = 0x100A$, Size $ = 4$\n- Instruction 6 ($\\mathrm{C.BEQZ}$): Address $ = 0x100A + 4 = 0x100E$, Size $ = 2$\n- Instruction 7 ($\\mathrm{ADDI}$): Address $ = 0x100E + 2 = 0x1010$, Size $ = 4$\n- Instruction 8 ($\\mathrm{L1}: \\mathrm{C.ANDI}$): Address $ = 0x1010 + 4 = 0x1014$, Size $ = 2$\n\nThe total size of the compressed code is $2+2+4+2+4+2+4+2 = 22$ bytes.\n\nThe branch displacement for the $\\mathrm{C.BEQZ}$ instruction at address $\\mathrm{PC} = 0x100E$ is calculated using the provided formula $\\delta_{\\mathrm{RVC}} = \\mathrm{addr}(\\mathrm{label}) - (\\mathrm{PC} + 2)$. The target label $\\mathrm{L1}$ is now at address $0x1014$.\n$$ \\delta_{\\mathrm{RVC}} = 0x1014 - (0x100E + 2) = 0x1014 - 0x1010 = 4 $$\nThe displacement is $4$ bytes. This value is a signed multiple of $2$ and lies in the set $\\{-256, \\dots, 254\\}$ specified for $\\mathrm{C.BEQZ}$. Therefore, the compression of the branch instruction is valid.\n\n**Task 4: Code Size and Compression Ratio**\n\n- Total baseline code size (RV32I-only): $32$ bytes.\n- Total compressed code size (with RVC): $22$ bytes.\n\nThe code-size compression ratio $R$ is defined as:\n$$ R = \\frac{\\text{total compressed bytes}}{\\text{total baseline bytes}} = \\frac{22}{32} $$\nReducing this fraction by dividing the numerator and denominator by their greatest common divisor, which is $2$:\n$$ R = \\frac{11}{16} $$\n\n**Task 5: Justification of Execution Equivalence**\n\nThe substitution of baseline instructions with their RVC forms preserves execution equivalence for this specific snippet.\n1.  **State Preservation**: For every compressible instruction ($\\mathrm{ADDI}$, $\\mathrm{LW}$, $\\mathrm{SW}$, $\\mathrm{ANDI}$), the RVC semantics are defined to be identical to their RV32I counterparts, given that the specific constraints on operands (register numbers, immediate values) are met. For example, $\\mathrm{C.ADDI}\\ r_d, i$ is semantically identical to $\\mathrm{ADDI}\\ r_d, r_d, i$. Since our analysis confirmed all constraints were met, each compressed instruction performs the exact same operation on the registers and/or memory as the original $32$-bit instruction.\n2.  **Control Flow Preservation**: The conditional branch $\\mathrm{BEQ}\\ x10, x0, \\mathrm{L1}$ is replaced by $\\mathrm{C.BEQZ}\\ x10, \\mathrm{L1}$. Both branch if and only if the content of register $x10$ is zero. The branch target is the label $\\mathrm{L1}$. Although the absolute address of $\\mathrm{L1}$ changes between the two encodings (from $0x101C$ to $0x1014$), the branch instructions use PC-relative addressing. We calculated the displacements ($\\delta_{\\mathrm{RV32I}} = 4$ and $\\delta_{\\mathrm{RVC}} = 4$) and confirmed they correctly encode the jump from the branch instruction to the target instruction in their respective memory layouts. Since the branching condition and the logical target are the same, the control flow is preserved.\n\nTherefore, the sequence of architectural state changes is identical for both program encodings.",
            "answer": "$$\\boxed{\\frac{11}{16}}$$"
        },
        {
            "introduction": "With a grasp of individual instructions, we can now build more complex control structures. This practice  challenges you to implement the logic for a relocation-free jump table, a common mechanism used by compilers for efficient `switch-case` statements. You will learn how to normalize the program counter into a table index while ensuring memory safety through bounds and alignment checks.",
            "id": "3655275",
            "problem": "You are asked to formalize and implement, in a general-purpose programming language, the core idea behind a relocation-free jump table as found in machine language and assembly. The fundamental base is the definition of the Program Counter (PC), which in a typical Instruction Set Architecture (ISA) is a byte-addressed register that points to the current instruction to be executed. In a table-driven control transfer mechanism, a block of contiguous code entries of equal size may serve as jump targets selected by an index.\n\nStarting from the fundamental definitions:\n- The Program Counter $PC$ is a byte address.\n- A code region is characterized by a base address $B$, a fixed stride $S$ in bytes per entry, and a logical capacity $n$ entries.\n- Indexing must be invariant under relocation: if both the region and $PC$ are shifted by a displacement $\\delta$, the computed index must be unchanged.\n- Alignment and bounds correctness are required: only entries aligned to the declared stride and within the logical capacity are valid targets.\n- Sparsity is permitted: some logical indices may deliberately have no assigned handler.\n\nYour task is to derive from these definitions the normalization procedure that maps $PC$ to a logical index $i$ for the table, with all necessary checks for bounds and alignment, and with graceful handling of sparse indices. You must then implement this procedure in a complete, runnable program that, given a small test suite of parameter sets, computes the selected handler identifier or a well-defined error code.\n\nImplementation model and correctness requirements:\n- Treat addresses as byte addresses. Use non-negative integers for handler identifiers. Use negative handler identifiers to denote sparse (missing) entries.\n- The result for each test case must be one integer:\n  - Return a non-negative integer equal to the handler identifier when the normalized index is valid and the entry is present.\n  - Return $-1$ if the $PC$ is out of bounds for the region specified by $B$, $S$, and $n$.\n  - Return $-2$ if the $PC$ is within bounds but not aligned to the stride $S$.\n  - Return $-3$ if the normalized index is valid but the entry is sparse (missing).\n- The normalization must be relocation-free: for any displacement $\\delta$, if $B \\mapsto B + \\delta$ and $PC \\mapsto PC + \\delta$, the computed index $i$ must be identical.\n\nTest suite:\nProvide results for the following test cases, each specified by $(B, S, n, PC, \\text{handlers}[0..n-1])$ with addresses in hexadecimal literals and strides and capacities in decimal. Handlers are in decimal, and any negative handler denotes a missing entry.\n\n- Case A (happy path): $(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 2 \\cdot 8, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case B (out-of-bounds below): $(B = 0x1000, S = 8, n = 5, PC = 0x0, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case C (misaligned within bounds): $(B = 0x1000, S = 8, n = 5, PC = 0x1000 + 3 \\cdot 8 + 4, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case D (sparse missing entry): $(B = 0x2000, S = 4, n = 6, PC = 0x2000 + 3 \\cdot 4, \\text{handlers} = [0, -1, 2, -1, 4, 5])$.\n- Case E (relocation invariance): $(B = 0x1000 + 0x300, S = 8, n = 5, PC = (0x1000 + 2 \\cdot 8) + 0x300, \\text{handlers} = [10, 11, 12, 13, 14])$.\n- Case F (upper boundary inclusive): $(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 3 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$.\n- Case G (end boundary exclusive): $(B = 0x3000, S = 16, n = 4, PC = 0x3000 + 4 \\cdot 16, \\text{handlers} = [100, 101, 102, 103])$.\n- Case H (large stride): $(B = 0x80000000, S = 512, n = 3, PC = 0x80000000 + 512, \\text{handlers} = [7, 8, 9])$.\n- Case I (base entry): $(B = 0x5000, S = 32, n = 2, PC = 0x5000, \\text{handlers} = [42, 43])$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_A,\\text{result}_B,\\dots]$). No other text should be printed.",
            "solution": "The problem is well-defined, scientifically grounded in the principles of computer architecture, and provides a complete set of specifications for deriving and implementing a procedure. It contains no contradictions or ambiguities. Therefore, the problem is deemed valid.\n\nThe task is to formalize and implement a procedure that maps a program counter address, $PC$, to a logical index, $i$, for a relocation-free jump table. The table is defined by a base address $B$, a fixed-size stride $S$ per entry, and a total capacity of $n$ entries. The procedure must perform all necessary checks for bounds and alignment, and handle sparse entries.\n\nThe derivation of the normalization procedure proceeds step-by-step from the given requirements.\n\n1.  **Relocation Invariance**: The fundamental constraint is that the indexing mechanism must be position-independent. This means that if the entire code segment, including the jump table and the current program counter, is relocated by some displacement $\\delta$, the computed index must remain unchanged. Let the original base address be $B$ and the program counter be $PC$. After relocation, the new addresses are $B' = B + \\delta$ and $PC' = PC + \\delta$. For the index to be invariant, its calculation must depend only on the relative offset between $PC$ and $B$, which is $\\Delta = PC - B$. This is because the new offset $\\Delta' = PC' - B' = (PC + \\delta) - (B + \\delta) = PC - B = \\Delta$. Thus, all subsequent checks and calculations must be based on this relative offset, $\\Delta$. For computational purposes, addresses are treated as non-negative unsigned integers.\n\n2.  **Bounds Checking**: The jump table consists of $n$ entries, each of size $S$ bytes. The memory region occupied by the table starts at address $B$ and ends immediately before address $B + n \\cdot S$. Therefore, the valid range of addresses for any target within the table is $[B, B + n \\cdot S)$. A given program counter $PC$ is within the bounds of this region if and only if the condition $B \\le PC  B + n \\cdot S$ is satisfied. This is the first check to be performed. If $PC$ is outside this range, it is considered out of bounds. The problem specifies that in this case, the procedure must return the error code $-1$.\n\n3.  **Alignment Checking**: A valid jump target must correspond to the beginning of one of the table entries. The addresses of these entry points are $B$, $B+S$, $B+2S$, ..., $B+(n-1)S$. This implies that the relative offset of $PC$ from the base $B$, which is $\\Delta = PC - B$, must be an integer multiple of the stride $S$. This property is known as alignment. It can be verified by checking if the remainder of the division of $\\Delta$ by $S$ is zero. That is, $(PC - B) \\pmod S = 0$. This check should be performed for any $PC$ that is within bounds. If an in-bounds $PC$ is not aligned to the stride $S$, the procedure must return the error code $-2$.\n\n4.  **Index Calculation**: If a $PC$ passes both the bounds and alignment checks, it points to a valid entry. The logical index $i$ of this entry corresponds to how many strides of size $S$ are contained in the offset from the base address. This is calculated using integer division:\n    $$i = \\frac{PC - B}{S}$$\n    Given the bounds check ($0 \\le PC - B  n \\cdot S$), the calculated index $i$ is guaranteed to be within the valid range for an array of size $n$, i.e., $0 \\le i  n$.\n\n5.  **Sparsity Handling**: The problem permits \"sparse\" tables, where certain logical indices may not have a corresponding handler. These sparse entries are denoted by negative values in the provided `handlers` array. After a valid index $i$ is calculated, the procedure must retrieve the handler identifier from `handlers`[$i$]. If this value is negative (i.e., $\\text{handlers}[i]  0$), it signifies a sparse entry. In this case, the procedure must return the error code $-3$.\n\n6.  **Successful Lookup**: If the retrieved handler identifier is non-negative (i.e., $\\text{handlers}[i] \\ge 0$), the lookup is successful. The procedure's final result is this non-negative handler identifier.\n\nIn summary, the complete algorithm for a given set of parameters $(B, S, n, PC, \\text{handlers})$ is as follows:\n1.  Check if $PC  B$ or $PC \\ge B + n \\cdot S$. If true, return $-1$.\n2.  Calculate the offset $\\Delta = PC - B$.\n3.  Check if $\\Delta \\pmod S \\neq 0$. If true, return $-2$.\n4.  Calculate the index $i = \\Delta / S$.\n5.  Retrieve the handler identifier $h = \\text{handlers}[i]$.\n6.  Check if $h  0$. If true, return $-3$.\n7.  Otherwise, return $h$.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    unsigned long long B;\n    int S;\n    int n;\n    unsigned long long PC;\n    const int* handlers;\n} TestCase;\n\n/**\n * @brief Computes the handler identifier for a given Program Counter (PC)\n *        based on a jump table's properties.\n *\n * @param tc The TestCase struct containing B, S, n, PC, and handlers.\n * @return An integer representing the handler ID or an error code:\n *         - Non-negative: The handler identifier.\n *         - -1: PC is out of bounds.\n *         - -2: PC is misaligned.\n *         - -3: The entry is sparse (missing).\n */\nint get_handler_id(TestCase tc) {\n    // 1. Bounds Checking\n    // The valid memory region is [B, B + n * S).\n    // An unsigned long long is used for the region end to prevent overflow\n    // with large addresses or strides.\n    unsigned long long region_end = tc.B + (unsigned long long)tc.n * tc.S;\n    if (tc.PC  tc.B || tc.PC = region_end) {\n        return -1; // Out of bounds\n    }\n\n    // 2. Alignment Checking\n    // The offset from the base must be a multiple of the stride.\n    unsigned long long offset = tc.PC - tc.B;\n    if (offset % tc.S != 0) {\n        return -2; // Misaligned\n    }\n\n    // 3. Index Calculation\n    int index = offset / tc.S;\n\n    // 4. Sparsity Handling\n    int handler_id = tc.handlers[index];\n    if (handler_id  0) {\n        return -3; // Sparse entry\n    }\n\n    // 5. Successful Lookup\n    return handler_id;\n}\n\nint main(void) {\n    // Define the handler arrays for the test cases.\n    const int handlers_A_B_C_E[] = {10, 11, 12, 13, 14};\n    const int handlers_D[] = {0, -1, 2, -1, 4, 5};\n    const int handlers_F_G[] = {100, 101, 102, 103};\n    const int handlers_H[] = {7, 8, 9};\n    const int handlers_I[] = {42, 43};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // Case A (happy path)\n        {0x1000, 8, 5, 0x1000 + 2 * 8, handlers_A_B_C_E},\n        // Case B (out-of-bounds below)\n        {0x1000, 8, 5, 0x0, handlers_A_B_C_E},\n        // Case C (misaligned within bounds)\n        {0x1000, 8, 5, 0x1000 + 3 * 8 + 4, handlers_A_B_C_E},\n        // Case D (sparse missing entry)\n        {0x2000, 4, 6, 0x2000 + 3 * 4, handlers_D},\n        // Case E (relocation invariance)\n        {0x1000 + 0x300, 8, 5, (0x1000 + 2 * 8) + 0x300, handlers_A_B_C_E},\n        // Case F (upper boundary inclusive)\n        {0x3000, 16, 4, 0x3000 + 3 * 16, handlers_F_G},\n        // Case G (end boundary exclusive)\n        {0x3000, 16, 4, 0x3000 + 4 * 16, handlers_F_G},\n        // Case H (large stride) - use ULL suffix for 64-bit constant\n        {0x80000000ULL, 512, 3, 0x80000000ULL + 512, handlers_H},\n        // Case I (base entry)\n        {0x5000, 32, 2, 0x5000, handlers_I},\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        results[i] = get_handler_id(test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        printf(\"%d\", results[i]);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Beyond our own code, assembly programs must correctly interface with the broader system, following rules defined by the Application Binary Interface (ABI). This final exercise  simulates writing an alignment-sensitive memory allocator wrapper, a task that requires mastering concepts like power-of-two alignment, stack pointer management, and the proper use of ABI features like the \"red-zone.\"",
            "id": "3655246",
            "problem": "You are asked to formalize and implement, in a mathematical and algorithmic way, the behavior of an alignment-sensitive memory allocation wrapper that would be written in assembly language on the System V AMD64 Application Binary Interface (ABI). The wrapper must ensure that the returned pointer satisfies a power-of-two alignment and must account for prologue adjustments and the use of the red-zone according to the ABI. Your task is to derive the necessary arithmetic and logical conditions from first principles and implement a complete, runnable program that produces the specified outputs for a fixed test suite.\n\nFundamental base and core definitions to use:\n- Integer congruence and modulo arithmetic: for integers $x$, $m$, the statement $x \\equiv r \\pmod{m}$ denotes that $m$ divides $(x - r)$.\n- Power-of-two alignment: an address $A'$ is aligned to $2^k$ if and only if $A' \\equiv 0 \\pmod{2^k}$.\n- Two’s complement properties for masking: for $m = 2^k$, the bitmask $m - 1$ has $k$ low bits set, and $\\lnot(m - 1)$ (bitwise complement) clears those $k$ bits in a machine word.\n- System V AMD64 ABI facts: \n  1. Stack grows toward lower addresses, and the stack pointer $s$ must be $16$-byte aligned at function entry (that is, $s \\equiv 0 \\pmod{16}$ in the callee upon entry). \n  2. A call instruction pushes an $8$-byte return address, so immediately before a call, the caller must have $s \\equiv 8 \\pmod{16}$ to ensure that the callee’s entry stack pointer aligns to $16$ bytes.\n  3. The red-zone is a $128$-byte region below the current stack pointer that can be used by a leaf function that does not adjust $s$ and does not perform calls. This usage is unsafe if the function performs any call or changes $s$ via a push or subtraction.\n\nYour program must, for each test case, compute:\n1. The minimally adjusted aligned address $A'$ such that $A' \\ge A$ and $A' \\equiv 0 \\pmod{2^k}$.\n2. The adjustment amount $\\Delta = A' - A$.\n3. A boolean $b_1$ indicating whether, given the function’s prologue adjustments, the stack pointer is correctly prepared for a call instruction according to the ABI; formally, starting with $s_0 \\equiv 0 \\pmod{16}$ at function entry, apply an optional push of the base pointer (subtract $8$ bytes if pushed) and then subtract $F$ bytes for the frame allocation, and test whether $s \\equiv 8 \\pmod{16}$ immediately before a prospective call.\n4. A boolean $b_2$ indicating whether using $R$ bytes of scratch space in the red-zone is safe; formally, $b_2$ is true if and only if the function is a leaf ($C = 0$), does not push the base pointer, does not subtract any frame size (no change to $s$), and $R \\le 128$.\n\nRequired output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and itself is a comma-separated list of the four results in the order $[A', \\Delta, b_1, b_2]$. For example: $[[\\dots],[\\dots],\\dots]$. Use integers for all quantities; use $0$ and $1$ for booleans.\n\nTest suite:\nFor each test case, the parameters are $(A, k, p, F, C, R)$ where:\n- $A$ is the raw address returned by the underlying allocator, treated as an unsigned integer.\n- $k$ is the power for the alignment requirement $2^k$.\n- $p$ is a boolean indicating whether the function prologue pushes the base pointer (that is, subtracts $8$ bytes from the stack pointer).\n- $F$ is the frame size in bytes subtracted from the stack pointer in the prologue.\n- $C$ is the number of call instructions executed by the function body.\n- $R$ is the intended red-zone scratch usage in bytes.\n\nUse the following test cases:\n- Case $1$: $(A = 4099, k = 5, p = 1, F = 16, C = 1, R = 0)$.\n- Case $2$: $(A = 1024, k = 6, p = 0, F = 0, C = 0, R = 64)$.\n- Case $3$: $(A = 123456789, k = 12, p = 1, F = 24, C = 1, R = 0)$.\n- Case $4$: $(A = 555, k = 4, p = 0, F = 0, C = 0, R = 256)$.\n- Case $5$: $(A = 259, k = 3, p = 1, F = 0, C = 0, R = 128)$.\n\nConstraints for scientific realism:\n- Treat all addresses as unsigned integers within a machine word; assume `$k$` satisfies $1 \\le k \\le 63$ to avoid overflow in $2^k$.\n- Model stack pointer arithmetic only via congruence classes modulo $16$; no actual stack manipulation is performed.\n\nYour program must be self-contained, must not read any input, and must compute and print the results for all test cases exactly in the specified format on a single line.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of computer architecture (specifically the System V AMD64 ABI) and mathematics (integer congruence and bitwise arithmetic). The problem is well-posed, providing a clear, self-contained set of definitions, constraints, and test data, leading to a unique and meaningful solution. The language is objective and formal.\n\nThe solution requires the calculation of four quantities for each test case $(A, k, p, F, C, R)$: the aligned address $A'$, the adjustment $\\Delta$, a call-readiness boolean $b_1$, and a red-zone safety boolean $b_2$.\n\n1.  **Calculation of Aligned Address ($A'$) and Adjustment ($\\Delta$)**\n\n    The goal is to find the minimally adjusted address $A'$ such that it is greater than or equal to the raw address $A$ and is aligned to a boundary of $m = 2^k$. In mathematical terms, we seek the smallest $A' \\ge A$ satisfying the congruence $A' \\equiv 0 \\pmod{2^k}$.\n\n    Let $m = 2^k$. Any integer address $A$ can be expressed relative to a multiple of $m$ using the division algorithm: $A = qm + r$, where $q$ is the quotient and $r = A \\pmod m$ is the remainder, with $0 \\le r  m$.\n\n    If $A$ is already aligned, its remainder $r$ is $0$. In this case, the minimal aligned address is $A$ itself, so $A' = A$ and the required adjustment is $\\Delta = A' - A = 0$.\n\n    If $A$ is not aligned, $r  0$. The next address greater than $A$ that is a multiple of $m$ is $(q+1)m$. Therefore, the aligned address is $A' = (q+1)m$. We can write this in terms of $A$ and $r$:\n    $$A' = (qm + r) + (m - r) = A + (m - r)$$\n    The adjustment required is the amount we added:\n    $$\\Delta = A' - A = m - r = m - (A \\pmod m)$$\n    We can unify these two cases ($r=0$ and $r0$) with a single expression for the adjustment:\n    $$\\Delta = (m - (A \\pmod m)) \\pmod m$$\n    The aligned address is then simply $A' = A + \\Delta$.\n\n    In low-level programming, this operation is often implemented more efficiently using bitwise operations. An address is aligned to $m=2^k$ if its lowest $k$ bits are zero. The value $m-1$ is a bitmask with exactly the lowest $k$ bits set to $1$.\n    The aligned address $A'$ can be computed by adding the mask ($m-1$) to $A$ and then clearing the lower $k$ bits. Clearing the lower $k$ bits is equivalent to a bitwise AND with the inverted mask, $\\lnot(m-1)$.\n    $$A' = (A + (2^k - 1)) \\land \\lnot(2^k - 1)$$\n    where $\\land$ is the bitwise AND operator and $\\lnot$ is the bitwise NOT operator. This formula correctly rounds $A$ up to the next alignment boundary.\n\n2.  **Calculation of Call-Readiness Boolean ($b_1$)**\n\n    The System V AMD64 ABI has strict stack alignment requirements. On entry to a function, the stack pointer, $s$, must be $16$-byte aligned. That is, $s_{entry} \\equiv 0 \\pmod{16}$. A `call` instruction pushes an $8$-byte return address onto the stack. To ensure the callee receives a $16$-byte aligned stack pointer, the caller's stack pointer must satisfy $s_{pre-call} \\equiv 8 \\pmod{16}$ immediately before the `call` instruction is executed.\n\n    We model the state of the stack pointer's congruence class modulo $16$ through the function prologue.\n    - Initial state at function entry: $s_0 \\equiv 0 \\pmod{16}$.\n    - The prologue may push the base pointer (`rbp`) onto the stack, which decrements the stack pointer by $8$ bytes. This happens if $p=1$. The new stack pointer congruence is $s_1 \\equiv (s_0 - 8p) \\pmod{16}$. Since $s_0 \\equiv 0 \\pmod{16}$, this simplifies to $s_1 \\equiv -8p \\pmod{16}$.\n    - The prologue then allocates space for local variables by subtracting the frame size $F$ from the stack pointer. The final stack pointer value before the function body executes is $s_{final} \\equiv (s_1 - F) \\pmod{16}$.\n    - Substituting for $s_1$, we get $s_{final} \\equiv (-8p - F) \\pmod{16}$.\n\n    The boolean $b_1$ is true if and only if this final stack pointer alignment is suitable for a subsequent call instruction. The condition is:\n    $$s_{final} \\equiv 8 \\pmod{16}$$\n    Therefore, $b_1$ is $1$ if $(-8p - F) \\equiv 8 \\pmod{16}$, and $0$ otherwise.\n\n3.  **Calculation of Red-Zone Safety Boolean ($b_2$)**\n\n    The red-zone is a $128$-byte area on the stack below the current stack pointer that a function can use for temporary storage without explicitly decrementing the stack pointer. However, its use is only safe under specific conditions, as signal or interrupt handlers could otherwise overwrite this area.\n\n    The ABI specifies that the red-zone is safe to use if and only if the function is a *leaf function* and does not modify the stack pointer. A leaf function is one that does not make any calls to other functions.\n    The conditions for $b_2$ to be true ($1$) are a conjunction of the following:\n    - The function must be a leaf function. This is given by the parameter $C$, the number of calls. The condition is $C=0$.\n    - The function must not modify the stack pointer in its prologue. This means it must not push the base pointer ($p=0$) and must not allocate a stack frame ($F=0$).\n    - The amount of scratch space used, $R$, must not exceed the size of the red-zone, which is $128$ bytes. The condition is $R \\le 128$.\n\n    Combining these, $b_2$ is $1$ if and only if $(C=0) \\land (p=0) \\land (F=0) \\land (R \\le 128)$. If any of these conditions are false, $b_2$ is $0$.",
            "answer": "```c\n// The complete and compilable C program.\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    unsigned long long A; // Raw address\n    int k;                // Alignment power\n    int p;                // Prologue pushes base pointer\n    int F;                // Frame size\n    int C;                // Number of calls\n    int R;                // Red-zone usage\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        { 4099ULL, 5, 1, 16, 1, 0 },\n        { 1024ULL, 6, 0, 0, 0, 64 },\n        { 123456789ULL, 12, 1, 24, 1, 0 },\n        { 555ULL, 4, 0, 0, 0, 256 },\n        { 259ULL, 3, 1, 0, 0, 128 }\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // 1. Calculate the aligned address A' and adjustment Delta.\n        // The alignment value is 2^k. Using 1ULL ensures the left shift\n        // works correctly for k up to 63 on a 64-bit system.\n        unsigned long long alignment = 1ULL  tc.k;\n        \n        // This is a standard bit-twiddling hack to round up to the next\n        // multiple of a power of two.\n        unsigned long long aligned_A = (tc.A + alignment - 1)  ~(alignment - 1);\n        \n        unsigned long long delta = aligned_A - tc.A;\n\n        // 2. Calculate the call-readiness boolean b1.\n        // The stack must be 16-byte aligned at function entry (s_entry % 16 == 0).\n        // A 'call' requires the stack to be 8-byte aligned pre-call.\n        // s_final = s_entry - 8*p - F\n        // We check if (0 - 8*p - F) % 16 == 8.\n        // The `+ 16` handles potential negative results from the C % operator.\n        int s_final_mod_16 = ((-8 * tc.p - tc.F) % 16 + 16) % 16;\n        int b1 = (s_final_mod_16 == 8);\n\n        // 3. Calculate the red-zone safety boolean b2.\n        // Safe if: leaf function (C=0), no stack change (p=0, F=0), and R = 128.\n        int b2 = (tc.C == 0  tc.p == 0  tc.F == 0  tc.R = 128);\n\n        // Print the results for the current test case.\n        printf(\"[%llu,%llu,%d,%d]\", aligned_A, delta, b1, b2);\n\n        // Add a comma if this is not the last test case.\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}