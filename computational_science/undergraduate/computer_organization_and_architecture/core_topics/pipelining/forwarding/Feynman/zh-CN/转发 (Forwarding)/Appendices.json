{
    "hands_on_practices": [
        {
            "introduction": "要理解转发机制的价值，最直观的方法莫过于比较有无转发的流水线性能。本练习将引导你为一段给定的代码，在两种不同的硬件设定下（有转发和无转发）手动推演其执行调度。通过计算指令在执行阶段的最早开始时间，你将亲眼见证并量化转发技术如何通过解决数据依赖来避免停顿，从而显著提升流水线效率。",
            "id": "3643888",
            "problem": "一个采用按序发射的五阶段流水线处理器按顺序执行 $\\mathrm{IF}$、$\\mathrm{ID}$、$\\mathrm{EX}$、$\\mathrm{MEM}$ 和 $\\mathrm{WB}$ 阶段，每个周期执行一个阶段。寄存器文件写操作发生在 $\\mathrm{WB}$ 周期的前半部分，寄存器文件读操作发生在 $\\mathrm{ID}$ 周期的后半部分。只有一个 $\\mathrm{EX}$ 单元，因此在任何给定周期内最多只能有一条指令占用 $\\mathrm{EX}$ 阶段。考虑以下程序片段，其中 $\\mathrm{add}$ 和 $\\mathrm{sub}$ 是在 $\\mathrm{EX}$ 阶段产生结果的整数算术运算，而 $\\mathrm{lw}$ 是在 $\\mathrm{EX}$ 阶段计算有效地址、在 $\\mathrm{MEM}$ 阶段读取内存并在 $\\mathrm{WB}$ 阶段写回加载值的加载指令：\n$I_1$: $\\mathrm{add}\\ r_1,\\ r_2,\\ r_3$ \n$I_2$: $\\mathrm{sub}\\ r_4,\\ r_1,\\ r_5$\n$I_3$: $\\mathrm{lw}\\ r_6,\\ 0(r_1)$\n$I_4$: $\\mathrm{add}\\ r_7,\\ r_6,\\ r_8$\n$I_5$: $\\mathrm{add}\\ r_1,\\ r_7,\\ r_9$\n$I_6$: $\\mathrm{add}\\ r_{10},\\ r_1,\\ r_{11}$\n$I_7$: $\\mathrm{lw}\\ r_{12},\\ 8(r_{10})$\n$I_8$: $\\mathrm{add}\\ r_{13},\\ r_{12},\\ r_{14}$\n假设有两种机器变体：\n- 变体 $\\mathcal{F}$ 具有完全转发（旁路）功能，可将结果从 $\\mathrm{EX}/\\mathrm{MEM}$ 和 $\\mathrm{MEM}/\\mathrm{WB}$ 流水线寄存器转发到 $\\mathrm{ID}/\\mathrm{EX}$ 阶段的输入。\n- 变体 $\\mathcal{N}$ 没有转发功能；消费者指令只能通过读取寄存器文件来获取生成的值。\n\n将指令间的交互建模为一个有向无环图，其顶点是指令 $\\{I_1,\\dots,I_8\\}$，其边是真数据相关（$\\mathrm{RAW}$），边的流水线距离约束仅由阶段时序和是否可用转发决定。在此模型下，通过一个“尽快”拓扑调度来定义指令 $I_i$ 可以开始 $\\mathrm{EX}$ 阶段的最早周期，记为 $E_i$，该调度强制执行以下规则：\n- 程序顺序的按序发射（每条指令 $I_i$ 开始 $\\mathrm{EX}$ 的时间不得早于 $I_{i-1}$ 开始 $\\mathrm{EX}$ 之后的一个周期），\n- 基线流水线流程（在没有冒险的情况下，$I_i$ 将在周期 $i+2$ 开始 $\\mathrm{EX}$），\n- 流水线所隐含的数据相关边约束（从给定的阶段语义中推导出这些约束；除阶段时序外，不假设任何公式）。\n\n分别计算变体 $\\mathcal{F}$ 和 $\\mathcal{N}$ 的序列 $\\{E_i^{\\mathcal{F}}\\}_{i=1}^{8}$ 和 $\\{E_i^{\\mathcal{N}}\\}_{i=1}^{8}$，然后计算标量差 $\\Delta \\equiv E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$。将 $\\Delta$ 的值以单个实数形式提供。无需四舍五入。",
            "solution": "该问题要求分析一个五阶段流水线处理器在两种不同配置（有转发和无转发）下执行给定指令序列的性能。我们的目标是确定每条指令 $I_i$ 能开始其执行（EX）阶段的最早周期 $E_i$，然后计算两种情况下最后一条指令 $I_8$ 的 $E_8$ 值之差。\n\n首先，我们识别指令序列中的所有写真（RAW）数据依赖关系：\n- $I_1 \\to I_2$ (对 $r_1$)\n- $I_1 \\to I_3$ (对 $r_1$)\n- $I_3 \\to I_4$ (对 $r_6$)\n- $I_4 \\to I_5$ (对 $r_7$)\n- $I_5 \\to I_6$ (对 $r_1$)\n- $I_6 \\to I_7$ (对 $r_{10}$)\n- $I_7 \\to I_8$ (对 $r_{12}$)\n\n指令 $I_i$ 的EX阶段开始时间 $E_i$ 由以下递推关系决定：$E_i = \\max(E_{i-1} + 1, \\text{数据依赖约束})$，且 $E_1 = 3$。\n\n**变体 $\\mathcal{F}$ (有转发):**\n在有转发的流水线中，ALU指令（如 `add`, `sub`）的结果在EX阶段结束时可用，可以立即转发给下一条指令的EX阶段。加载指令（`lw`）的结果在MEM阶段结束时可用。这意味着：\n- ALU-ALU/ALU-use 依赖不会导致停顿。\n- 加载-使用（load-use）依赖（如 $I_3 \\to I_4$ 和 $I_7 \\to I_8$）会导致1个周期的停顿。对于从 $I_k$ 到 $I_i$ 的加载-使用依赖，$E_i \\ge E_k + 2$。\n\n- $E_1 = 3$\n- $E_2$: 依赖于 $I_1$ (add)。无停顿。$E_2 = \\max(E_1+1) = 4$。\n- $E_3$: 依赖于 $I_1$ (add)。无停顿。$E_3 = \\max(E_2+1) = 5$。\n- $E_4$: 依赖于 $I_3$ (lw)。加载-使用冒险。$E_4 = \\max(E_3+1, E_3+2) = \\max(6, 7) = 7$。\n- $E_5$: 依赖于 $I_4$ (add)。无停顿。$E_5 = \\max(E_4+1) = 8$。\n- $E_6$: 依赖于 $I_5$ (add)。无停顿。$E_6 = \\max(E_5+1) = 9$。\n- $E_7$: 依赖于 $I_6$ (add)。无停顿。$E_7 = \\max(E_6+1) = 10$。\n- $E_8$: 依赖于 $I_7$ (lw)。加载-使用冒险。$E_8 = \\max(E_7+1, E_7+2) = \\max(11, 12) = 12$。\n所以，$E_8^{\\mathcal{F}} = 12$。\n\n**变体 $\\mathcal{N}$ (无转发):**\n在没有转发的流水线中，消费者指令必须等待生产者指令完成写回（WB）阶段后，才能在其译码（ID）阶段读取寄存器堆。\n- 生产者 $I_k$ 的WB阶段在周期 $E_k+2$ 完成。\n- 消费者 $I_i$ 的ID阶段必须在周期 $T \\ge E_k+2$ 进行。\n- 消费者 $I_i$ 的EX阶段则可以在周期 $T+1 \\ge E_k+3$ 开始。\n因此，对于从 $I_k$ 到 $I_i$ 的数据依赖，我们有约束 $E_i \\ge E_k+3$。\n\n- $E_1 = 3$\n- $E_2$: 依赖于 $I_1$。$E_2 = \\max(E_1+1, E_1+3) = \\max(4, 6) = 6$。\n- $E_3$: 依赖于 $I_1$。$E_3 = \\max(E_2+1, E_1+3) = \\max(7, 6) = 7$。\n- $E_4$: 依赖于 $I_3$。$E_4 = \\max(E_3+1, E_3+3) = \\max(8, 10) = 10$。\n- $E_5$: 依赖于 $I_4$。$E_5 = \\max(E_4+1, E_4+3) = \\max(11, 13) = 13$。\n- $E_6$: 依赖于 $I_5$。$E_6 = \\max(E_5+1, E_5+3) = \\max(14, 16) = 16$。\n- $E_7$: 依赖于 $I_6$。$E_7 = \\max(E_6+1, E_6+3) = \\max(17, 19) = 19$。\n- $E_8$: 依赖于 $I_7$。$E_8 = \\max(E_7+1, E_7+3) = \\max(20, 22) = 22$。\n所以，$E_8^{\\mathcal{N}} = 22$。\n\n**计算差值 $\\Delta$:**\n$$ \\Delta = E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}} = 22 - 12 = 10 $$",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "在见识了转发带来的性能优势后，我们现在深入其实现细节。转发功能虽然强大，但并非万能；它无法解决所有的读后写（RAW）数据险情。本练习要求你为经典的“加载-使用”险情设计组合逻辑谓词，这种险情是转发无法凭一己之力解决的。通过这个过程，你将理解转发和流水线停顿机制之间相辅相成的关系，这对于构建一个正确且高效的处理器至关重要。",
            "id": "3643923",
            "problem": "一个标量、按序的五级流水线实现了以下阶段：指令提取 ($\\mathrm{IF}$)、指令译码和寄存器读取 ($\\mathrm{ID}$)、执行 ($\\mathrm{EX}$)、访存 ($\\mathrm{MEM}$) 和写回 ($\\mathrm{WB}$)。寄存器文件在 $\\mathrm{ID}$ 阶段被读取，在 $\\mathrm{WB}$ 阶段被写入。该机器将位于 $\\mathrm{EX}/\\mathrm{MEM}$ 和 $\\mathrm{MEM}/\\mathrm{WB}$ 边界的流水线寄存器中的结果转发到为 $\\mathrm{EX}$ 阶段提供输入的操作数多路选择器。$\\mathrm{MEM}$ 阶段的访存是一个单周期的理想缓存访问，因此加载指令在 $\\mathrm{MEM}$ 阶段结束时产生其数据。不存在结构冒险。指令集架构提供寄存器-寄存器算术指令、加载指令、存储指令和条件分支指令。分支在 $\\mathrm{EX}$ 阶段被解析并且被完美预测，因此没有控制停顿。\n\n你需要提出一个仅在加载-使用冒险时停顿的最小化冒险检测器，论证为什么转发加上这个检测器能确保此流水线中所有写后读数据冒险的正确性，然后在一个指定的合成工作负载上量化每指令周期数 (CPI)。\n\n假设和术语：\n- 流水线寄存器表示为 $R_{\\mathrm{IF/ID}}$、 $R_{\\mathrm{ID/EX}}$、 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$。\n- 对于位于流水线寄存器 $R$ 中的任何指令 $I$，字段 $R.\\mathrm{rs}$ 和 $R.\\mathrm{rt}$ 表示在 $\\mathrm{ID}$ 阶段读取的第一个和第二个源寄存器的标识符（如果适用），而 $R.\\mathrm{dest}$ 表示在 $\\mathrm{WB}$ 阶段写入的目标寄存器的标识符（如果适用）。控制位 $R.\\mathrm{MemRead}$ 当且仅当 $I$ 是加载指令时被置位。\n- 索引为 $0$ 的寄存器硬连线到零且永远不会被写入；在你的逻辑中应处理与寄存器 $0$ 的比较，以避免伪相关性导致停顿。\n- 当在周期 $t$ 请求停顿时，程序计数器和 $R_{\\mathrm{IF/ID}}$ 被保持，并且在周期 $t+1$ 向 $R_{\\mathrm{ID/EX}}$ 注入一个气泡 (一个 $\\mathrm{NOP}$)。\n\n任务：\n1) 根据前面的定义和五级流水线的语义，推导出一个作用于 $R_{\\mathrm{IF/ID}}$ 和 $R_{\\mathrm{ID/EX}}$ 字段的最小组合谓词 $H$。当且仅当必须插入一个单周期的停顿以避免在下一个周期的 $\\mathrm{EX}$ 阶段发生写后读时序冲突时，该谓词 $H$ 为真。请使用命名​​字段上的等于、逻辑与、逻辑或和逻辑非来符号化地表示 $H$。\n\n2) 仅使用上述流水线时序假设以及从 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$ 到 $\\mathrm{EX}$ 操作数输入存在转发的事实，论证在 $H$ 作为唯一的停顿来源的情况下，所有写后读数据冒险都得到了正确处理。你的论证应考虑生产者指令是算术指令（在 $\\mathrm{EX}$ 阶段结束时产生结果）和加载指令（在 $\\mathrm{MEM}$ 阶段结束时产生结果）的情况，并应解释为什么除了 $H$ 发出的信号外，不需要其他停顿。\n\n3) 考虑一个长的合成指令流，其静态指令混合为：算术指令比例 $f_{\\mathrm{A}} = 0.44$，加载指令比例 $f_{\\mathrm{L}} = 0.28$，存储指令比例 $f_{\\mathrm{S}} = 0.18$，分支指令比例 $f_{\\mathrm{B}} = 0.10$。假设以下数据相关性的独立性模型：在位置 $i$ 的指令是写入一个非零寄存器的加载指令的条件下，位置 $i+1$ 的指令以概率 $p = 0.35$ 读取同一个目标寄存器作为其源之一，并且这与其他一切都独立。如果发生这种情况，就构成了你在 $H$ 中定义的加载-使用情况；否则就不是。没有其他停顿的来源。\n\n基于第1部分和第2部分的最小停顿策略，计算此流水线在此工作负载上的期望稳态 $\\mathrm{CPI}$。将你的答案四舍五入到四位有效数字。只给出一个没有单位的数值。",
            "solution": "该问题提出了一个经典的五级流水线处理器模型，要求推导冒险检测逻辑、论证其正确性，并以每指令周期数 ($\\mathrm{CPI}$) 的形式进行性能计算。该问题定义明确、内部一致，并基于计算机体系结构的基本原理。将按要求分三部分进行解答。\n\n### 1. 冒险检测谓词 $H$ 的推导\n\n当一条后续指令需要某条指令的结果，但该结果尚不可用，且转发硬件无法提供该数据时，就会发生需要停顿的数据冒险。我们必须确定发生这种情况的特定时序。\n\n流水线具有从 $\\mathrm{EX}$ 和 $\\mathrm{MEM}$ 阶段的输出寄存器（即 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$）到 $\\mathrm{EX}$ 阶段输入的转发功能。\n- 算术指令在 $\\mathrm{EX}$ 阶段计算其结果。该结果在 $\\mathrm{EX}$ 阶段结束时位于 $R_{\\mathrm{EX/MEM}}$ 中，可以及时转发给进入其 $\\mathrm{EX}$ 阶段的下一条指令。\n- 加载指令在 $\\mathrm{MEM}$ 阶段从内存中获取数据。该数据仅在 $\\mathrm{MEM}$ 阶段结束时才在 $R_{\\mathrm{MEM/WB}}$ 中可用。\n\n让我们考虑一条加载指令 $I_1$ 紧跟着一条使用所加载数据的指令 $I_2$。\n- 在周期 $t$，假设 $I_1$ 处于 $\\mathrm{EX}$ 阶段，$I_2$ 处于 $\\mathrm{ID}$ 阶段。$\\mathrm{ID}$ 阶段的硬件必须决定是停顿还是继续。\n- 如果流水线不停顿，则在周期 $t+1$，$I_1$ 进入 $\\mathrm{MEM}$ 阶段，$I_2$ 进入 $\\mathrm{EX}$ 阶段。\n- $I_2$ 在其 $\\mathrm{EX}$ 阶段的开始（即周期 $t+1$ 的开始）需要其源操作数。\n- 然而，$I_1$ 要到其 $\\mathrm{MEM}$ 阶段的结束（即周期 $t+1$ 的结束）才能从内存中获得数据。\n- 因此，数据在 $I_2$ 的 $\\mathrm{EX}$ 阶段开始时不可用。来自 $R_{\\mathrm{EX/MEM}}$ 和 $R_{\\mathrm{MEM/WB}}$ 的转发路径也无济于事，因为所需的数据尚未锁存到这两个寄存器中的任何一个。这就是一个加载-使用型写后读 (RAW) 冒险。\n\n为解决此问题，需要一个单周期的停顿。当在周期 $t$ 检测到冒险时，一个气泡被注入到周期 $t+1$ 的 $\\mathrm{EX}$ 阶段，而指令 $I_2$ 则被保持在 $\\mathrm{ID}$ 阶段。\n- 周期 $t$：$I_1$ 在 $\\mathrm{EX}$ 阶段，$I_2$ 在 $\\mathrm{ID}$ 阶段。检测到冒险。\n- 周期 $t+1$：$I_1$ 进入 $\\mathrm{MEM}$ 阶段。$I_2$ 保持在 $\\mathrm{ID}$ 阶段。一个 $\\mathrm{NOP}$ (气泡) 进入 $\\mathrm{EX}$ 阶段。\n- 周期 $t+2$：$I_1$ 进入 $\\mathrm{WB}$ 阶段。$I_2$ 进入 $\\mathrm{EX}$ 阶段。在此周期开始时，加载的结果位于流水线寄存器 $R_{\\mathrm{MEM/WB}}$ 中。来自 $R_{\\mathrm{MEM/WB}}$ 的转发路径现在可以正确地为 $I_2$ 向 $\\mathrm{EX}$ 阶段提供操作数。\n\n冒险检测逻辑必须识别出这种确切的场景。该逻辑位于 $\\mathrm{ID}$ 阶段，并对代表 $\\mathrm{EX}$ 阶段指令 ($R_{\\mathrm{ID/EX}}$) 和 $\\mathrm{ID}$ 阶段指令 ($R_{\\mathrm{IF/ID}}$) 的流水线寄存器内容进行操作。用于停顿的谓词 $H$ 为真，当且仅当满足以下所有条件：\n1. $\\mathrm{EX}$ 阶段的指令是加载指令。如果其 `MemRead` 控制信号被置位，则此条件为真：$R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}$。\n2. 加载指令的目标寄存器是 $\\mathrm{ID}$ 阶段指令的源寄存器之一。如果 $(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt})$，则此条件为真。\n3. 该相关性不涉及硬连线到零的寄存器，该寄存器可以被读取但永远不会被写入。这意味着加载指令的目标寄存器不能是寄存器 $0$：$R_{\\mathrm{ID/EX}}.\\mathrm{dest} \\neq 0$，可以表示为 $\\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0)$。\n\n结合这些条件，最小组合谓词 $H$ 是：\n$$H = (R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}) \\land \\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0) \\land ((R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt}))$$\n\n### 2. 正确性论证\n\n我们必须证明，指定的转发路径和停顿逻辑 $H$ 的组合正确地解决了所有可能的写后读 (RAW) 数据冒险。我们可以根据生产者指令的类型和其与消费者指令之间的距离来对冒险进行分类。\n\n**情况 A：生产者是算术指令。**\n结果在 $\\mathrm{EX}$ 阶段结束时于 $R_{\\mathrm{EX/MEM}}$ 寄存器中可用。\n- **消费者是下一条指令 ($i+1$)：**当消费者指令处于其 $\\mathrm{EX}$ 阶段时，生产者处于其 $\\mathrm{MEM}$ 阶段。生产者的结果位于 $R_{\\mathrm{EX/MEM}}$ 中，可以转发给消费者的 $\\mathrm{EX}$ 阶段输入。不需要停顿。\n- **消费者是指令 $i+2$：**当消费者处于其 $\\mathrm{EX}$ 阶段时，生产者处于其 $\\mathrm{WB}$ 阶段。生产者的结果位于 $R_{\\mathrm{MEM/WB}}$ 中，可以转发给消费者的 $\\mathrm{EX}$ 阶段输入。不需要停顿。\n- **消费者是指令 $i+3$ 或更晚的指令：**生产者已过其 $\\mathrm{WB}$ 阶段。结果已被写入寄存器文件。消费者在其 $\\mathrm{ID}$ 阶段从寄存器文件读取正确的值（由于读前写寄存器文件语义，其中 $\\mathrm{WB}$ 的写半周期在 $\\mathrm{ID}$ 的读半周期之前）。不需要停顿。\n情况 A 的结论：所有来自算术指令的 RAW 冒险都由转发逻辑解决，无需停顿。\n\n**情况 B：生产者是加载指令。**\n结果在 $\\mathrm{MEM}$ 阶段结束时于 $R_{\\mathrm{MEM/WB}}$ 寄存器中可用。\n- **消费者是下一条指令 ($i+1$)：** 这是第1部分中详述的加载-使用冒险。消费者在其 $\\mathrm{EX}$ 阶段开始时需要结果，但生产者仅在其 $\\mathrm{MEM}$ 阶段结束时才提供结果。无法及时进行转发。谓词 $H$ 专门设计用于检测这种情况（加载指令在 $\\mathrm{EX}$ 阶段，相关的消费者指令在 $\\mathrm{ID}$ 阶段）并正确触发一个单周期的停顿。停顿之后，该相关性等效于 `i+2 处的加载-使用` 情况，这种情况由转发处理。\n- **消费者是指令 $i+2$：**当消费者处于其 $\\mathrm{EX}$ 阶段时，生产者处于其 $\\mathrm{WB}$ 阶段。加载的数据位于 $R_{\\mathrm{MEM/WB}}$ 中，可以转发给消费者的 $\\mathrm{EX}$ 阶段输入。谓词 $H$ 不会触发，因为 $\\mathrm{EX}$ 阶段的指令（指令 $i+1$）不是生产者加载指令。不停顿是正确的。\n- **消费者是指令 $i+3$ 或更晚的指令：**结果已被写入寄存器文件，并由消费者直接读取。不需要停顿。\n情况 B 的结论：唯一一个涉及加载指令且未被转发解决的 RAW 冒险是紧随其后的加载-使用情况。这个特定情况由 $H$ 检测并通过一个单周期停顿来解决。所有其他情况都由转发或正常的寄存器文件操作处理。\n\n由于所有源于算术指令和加载指令的可能的 RAW 冒险都通过转发硬件或最小停顿逻辑 $H$ 得到了正确处理，因此该流水线的数据冒险处理是正确的。\n\n### 3. CPI 计算\n\n每指令周期数 ($\\mathrm{CPI}$) 是总时钟周期数除以总指令数。在没有冒险的理想流水线中，$\\mathrm{CPI}$ 为 $1$。停顿会增加 $\\mathrm{CPI}$。$\\mathrm{CPI}$ 的公式是：\n$$ \\mathrm{CPI} = \\mathrm{CPI}_{\\text{ideal}} + \\frac{\\text{Total Stall Cycles}}{\\text{Total Instructions}} $$\n鉴于 $\\mathrm{CPI}_{\\text{ideal}} = 1$，我们可以写出：\n$$ \\mathrm{CPI} = 1 + (\\text{stall frequency}) \\times (\\text{stall penalty}) $$\n根据以上分析，停顿仅在发生加载-使用冒险时出现。问题规定了单周期的停顿，因此每次发生的停顿惩罚是 $1$ 个周期。\n\n我们需要计算停顿频率，即任何给定的指令序列触发停顿的概率。如果一条指令是加载指令，并且紧随其后的指令使用了它的结果，就会触发停顿。\n- 加载指令所占的比例为 $f_{\\mathrm{L}} = 0.28$。\n- 紧跟在加载指令之后的指令对其有相关性的概率为 $p = 0.35$。这种相关性正是冒险逻辑 $H$ 所检测的。\n\n指令流中每条指令的停顿事件频率是指令为加载指令的概率与下一条指令导致加载-使用冒险的条件概率的乘积。\n$$ \\text{Stall Frequency} = f_{\\mathrm{L}} \\times p $$\n每条指令的停顿周期数是这个频率乘以 $1$ 个周期的惩罚。\n$$ \\frac{\\text{Total Stall Cycles}}{\\text{Total Instructions}} = f_{\\mathrm{L}} \\times p \\times 1 = f_{\\mathrm{L}} \\times p $$\n将此代入 $\\mathrm{CPI}$ 公式：\n$$ \\mathrm{CPI} = 1 + f_{\\mathrm{L}} \\times p $$\n使用给定的值 $f_{\\mathrm{L}} = 0.28$ 和 $p = 0.35$：\n$$ \\mathrm{CPI} = 1 + (0.28 \\times 0.35) $$\n$$ \\mathrm{CPI} = 1 + 0.098 $$\n$$ \\mathrm{CPI} = 1.098 $$\n题目要求将答案四舍五入到四位有效数字。数值 $1.098$ 恰好有四位有效数字。",
            "answer": "$$\n\\boxed{1.098}\n$$"
        },
        {
            "introduction": "真实的程序性能是数据流和控制流共同作用的结果。本练习将转发的概念融入一个更完整的性能分析场景中。你将分析一个紧凑的循环，其中数据险情可以被转发完美解决，从而让你能够分离并量化控制险情（即分支预测失败的代价）对性能的最终影响。这有助于你建立一个全面的$CPI$（每指令周期数）分析模型，理解不同类型的流水线险情如何共同决定处理器的最终效率。",
            "id": "3643933",
            "problem": "考虑一个经典的 $5$ 级整数流水线，其阶段包括指令提取 (IF)、指令解码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。该流水线是单发射的，拥有完美的指令和数据缓存（无缓存未命中），并实现了到执行阶段的完全数据前馈（旁路）。前馈将来自 EX/MEM 和 MEM/WB 流水线寄存器的结果提供给相关指令的 EX 阶段输入，以及分支指令的 EX 阶段比较器。加载指令在 MEM 阶段产生其结果；但是，下面的代码不包含加载指令。假设没有结构性冒险。\n\n条件分支在 EX 阶段被解析。当分支被采用时，前端由于控制冒险处理而损失 $\\beta$ 个气泡周期；当分支不被采用时，不会产生气泡周期。假设在长期运行中，分支被采用的迭代比例为 $p$，其中 $0 \\leq p \\leq 1$。\n\n分析以下紧凑循环，该循环更新寄存器 $R2$ 并在紧随其后的指令中立即使用 $R2$：\n\nLOOP:\n    ADD R2, R2, R3\n    SUB R4, R2, R5\n    ADD R1, R1, R11\n    BNE R1, R12, LOOP\n\n假设循环末尾的分支会一直循环，直到满足一个依赖于 $R1$ 的终止条件，因此在动态执行中有 $p$ 的比例分支被采用，否则不被采用。\n\n从流水线阶段和冒险处理的基本定义出发，追踪一次稳态循环迭代中数据相关的前馈决策，并确定是否需要任何停顿周期。然后，推导该循环的稳态每指令周期数 (CPI) 的一个闭式符号表达式，该表达式是关于分支采用比例 $p$ 和分支采用惩罚 $\\beta$ 的函数。将您的最终答案表示为单个解析表达式。CPI 是无量纲的；不需要单位。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取已知条件\n- 流水线：$5$ 级（指令提取 (IF)、指令解码 (ID)、执行 (EX)、内存访问 (MEM)、写回 (WB)）。\n- 微架构：单发射，从 EX/MEM 和 MEM/WB 寄存器到 EX 阶段输入和 EX 阶段比较器的完全数据前馈。\n- 缓存：完美的指令和数据缓存（无缓存未命中）。\n- 冒险：无结构性冒险。代码中不存在加载指令。\n- 控制流：条件分支 (`BNE`) 在 EX 阶段被解析。\n- 分支惩罚：一个被采用的分支会招致 $\\beta$ 个气泡周期的惩罚。一个不被采用的分支招致 $0$ 个气泡周期。\n- 分支行为：分支以 $p$ 的长期比例（概率）被采用，其中 $0 \\leq p \\leq 1$。\n- 代码序列（循环）：\n  1. `ADD R2, R2, R3`\n  2. `SUB R4, R2, R5`\n  3. `ADD R1, R1, R11`\n  4. `BNE R1, R12, LOOP`\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，描述了计算机体系结构教育和分析中常用的标准 RISC 流水线模型。数据前馈、控制冒险和每指令周期数 (CPI) 的概念都定义明确。该问题定义明确，提供了所有必要的参数（$\\beta$、$p$）和一个清晰的代码段，以推导 CPI 的唯一符号表达式。语言客观而精确。所给条件内部一致，不违反任何计算机组织的基本原则。指定的旁路路径足以处理代码中存在的数据相关性，这将在解法中得到证明。该问题并非微不足道，因为它需要仔细分析数据冒险和控制冒险。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将推导完整解法。\n\n### 解法推导\n目标是为所提供循环的稳态每指令周期数 (CPI) 推导一个闭式符号表达式。这需要分析数据冒险和控制冒险。\n\n设循环中的四条指令表示如下：\n- $I_1$：`ADD R2, R2, R3`\n- $I_2$：`SUB R4, R2, R5`\n- $I_3$：`ADD R1, R1, R11`\n- $I_4$：`BNE R1, R12, LOOP`\n\n**1. 数据冒险分析**\n\n我们识别代码中的写后读 (RAW) 数据相关：\n- **对 $R2$ 的相关性**：$I_1$ 写入寄存器 $R2$，而 $I_2$ 从 $R2$ 读取。\n- **对 $R1$ 的相关性**：$I_3$ 写入寄存器 $R1$，而 $I_4$ 从 $R1$ 读取以进行分支比较。\n\n让我们追踪流水线执行以确定这些相关是否会导致停顿。如果消费者指令需要生产者指令的结果时该结果尚不可用，则需要停顿。\n\n*对 $I_1 \\rightarrow I_2$ 相关性的分析：*\n指令 $I_1$ (ADD) 在其 EX 阶段计算结果。此结果在 $I_1$ 处于其 EX 阶段的时钟周期结束时可用于前馈。指令 $I_2$ (SUB) 在其 EX 阶段开始时需要 $R2$ 的值作为 ALU 的输入。\n考虑没有任何停顿的单次迭代的流水线时序图：\n- 周期 $k$：$I_1$ 处于 EX 阶段。\n- 周期 $k+1$：$I_1$ 处于 MEM 阶段，$I_2$ 处于 EX 阶段。\n\n在周期 $k+1$，$I_1$ 的结果存在于 EX/MEM 流水线寄存器中。问题陈述指出，流水线具有“从 EX/MEM……流水线寄存器到 EX 阶段输入的完全数据前馈”。因此，$I_1$ 的结果可以直接前馈到 $I_2$ 在周期 $k+1$ 的 ALU 输入。解决此相关性不需要停顿。\n\n*对 $I_3 \\rightarrow I_4$ 相关性的分析：*\n指令 $I_3$ (ADD) 在其 EX 阶段计算 $R1$ 的结果。指令 $I_4$ (BNE) 在其 EX 阶段需要 $R1$ 的这个值来执行比较。\n考虑这些指令的流水线时序：\n- 周期 $m$：$I_3$ 处于 EX 阶段。\n- 周期 $m+1$：$I_3$ 处于 MEM 阶段，$I_4$ 处于 EX 阶段。\n\n与第一种情况类似，在周期 $m+1$，来自 $I_3$ 的 $R1$ 的新值在 EX/MEM 流水线寄存器中可用。问题指定前馈可用于“分支指令的 EX 阶段比较器”。因此，$R1$ 的新值可以前馈到 $I_4$ 在 EX 阶段的比较器逻辑。此相关性同样不需要停顿。\n\n数据冒险结论：由于指定的完全前馈硬件，循环体内部的数据相关性不会导致停顿周期。\n\n**2. 控制冒险和 CPI 计算**\n\nCPI 定义为总周期数除以总指令数。对于稳态循环，我们可以将其计算为每次循环迭代的平均周期数除以每次迭代的指令数。\n\n每次迭代的指令数 $N_{instr}$ 为 $4$。\n\n在没有任何冒险的情况下，单发射流水线的理想 CPI 为 $1$。在这种情况下，一次循环迭代在稳态下将在 $4$ 个周期内完成。然而，`BNE` 指令 ($I_4$) 引入了潜在的控制冒险。\n\n分支结果在 $I_4$ 的 EX 阶段确定。我们必须考虑两种情况：\n\n*情况 A：分支不被采用*\n这种情况以 $(1-p)$ 的概率发生。流水线假定预测分支不被采用（一种常见的静态预测方案），因此它继续顺序提取指令。当 $I_4$ 在其 EX 阶段被解析并发现不被采用时，已经提取的指令是正确的。问题陈述中指出，在这种情况下，会产生 $0$ 个气泡周期。\n这次迭代的周期数就是指令数：$C_{not\\_taken} = 4$。\n\n*情况 B：分支被采用*\n这种情况以 $p$ 的概率发生。当 $I_4$ 处于其 EX 阶段时，流水线发现分支被采用。此时，已经从错误路径（顺序地）提取了下一次迭代的指令。这些指令必须从流水线中冲刷掉，并且必须在分支目标 (`LOOP`) 处重新开始提取。问题指定这会花费 $\\beta$ 个气泡周期。\n这次迭代的周期数是指令数加上惩罚：$C_{taken} = 4 + \\beta$。\n\n*每次迭代的平均周期数*\n每次循环迭代的平均周期数 $\\bar{C}_{iter}$ 是每种情况下周期的加权平均值：\n$$ \\bar{C}_{iter} = C_{not\\_taken} \\cdot (1-p) + C_{taken} \\cdot p $$\n$$ \\bar{C}_{iter} = 4 \\cdot (1-p) + (4 + \\beta) \\cdot p $$\n$$ \\bar{C}_{iter} = 4 - 4p + 4p + \\beta p $$\n$$ \\bar{C}_{iter} = 4 + \\beta p $$\n\n*最终 CPI 计算*\n稳态 CPI 是每次迭代的平均周期数除以每次迭代的指令数：\n$$ \\text{CPI} = \\frac{\\bar{C}_{iter}}{N_{instr}} $$\n$$ \\text{CPI} = \\frac{4 + \\beta p}{4} $$\n$$ \\text{CPI} = 1 + \\frac{\\beta p}{4} $$\n\n这个表达式表示稳态 CPI 作为分支采用比例 $p$ 和分支采用惩罚 $\\beta$ 的函数。基础 CPI 是 $1$，附加项 $\\frac{\\beta p}{4}$ 表示由于控制冒险导致的性能损失，该损失在循环中的所有指令上平均分摊。",
            "answer": "$$\\boxed{1 + \\frac{\\beta p}{4}}$$"
        }
    ]
}