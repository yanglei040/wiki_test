{
    "hands_on_practices": [
        {
            "introduction": "To truly appreciate the power of forwarding, it is essential to see its direct impact on program execution time. This exercise challenges you to trace a short program on two different pipelines—one with full forwarding and one entirely without it—to quantify the exact cycle savings. By meticulously calculating the earliest possible start time for each instruction in a dependency chain, you will build a concrete, cycle-by-cycle understanding of how forwarding eliminates stalls and dramatically accelerates computation .",
            "id": "3643888",
            "problem": "A five-stage pipelined processor with in-order issue executes stages $\\mathrm{IF}$, $\\mathrm{ID}$, $\\mathrm{EX}$, $\\mathrm{MEM}$, and $\\mathrm{WB}$ in that order, one stage per cycle. Register file writes occur in the first half of the $\\mathrm{WB}$ cycle and register file reads occur in the second half of the $\\mathrm{ID}$ cycle. There is a single $\\mathrm{EX}$ unit, so at most one instruction can occupy $\\mathrm{EX}$ in any given cycle. Consider the following program fragment, where $\\mathrm{add}$ and $\\mathrm{sub}$ are integer arithmetic operations that produce results in $\\mathrm{EX}$, and $\\mathrm{lw}$ is a load that computes an effective address in $\\mathrm{EX}$, reads memory in $\\mathrm{MEM}$, and writes the loaded value in $\\mathrm{WB}$:\n$I_1$: $\\mathrm{add}\\ r_1,\\ r_2,\\ r_3$ \n$I_2$: $\\mathrm{sub}\\ r_4,\\ r_1,\\ r_5$\n$I_3$: $\\mathrm{lw}\\ r_6,\\ 0(r_1)$\n$I_4$: $\\mathrm{add}\\ r_7,\\ r_6,\\ r_8$\n$I_5$: $\\mathrm{add}\\ r_1,\\ r_7,\\ r_9$\n$I_6$: $\\mathrm{add}\\ r_{10},\\ r_1,\\ r_{11}$\n$I_7$: $\\mathrm{lw}\\ r_{12},\\ 8(r_{10})$\n$I_8$: $\\mathrm{add}\\ r_{13},\\ r_{12},\\ r_{14}$\nAssume two machine variants:\n- Variant $\\mathcal{F}$ has full forwarding (bypassing) from $\\mathrm{EX}/\\mathrm{MEM}$ and $\\mathrm{MEM}/\\mathrm{WB}$ pipeline registers to the $\\mathrm{ID}/\\mathrm{EX}$ stage inputs.\n- Variant $\\mathcal{N}$ has no forwarding; consumers can only obtain produced values by reading the register file.\n\nModel instruction interactions as a directed acyclic graph whose vertices are the instructions $\\{I_1,\\dots,I_8\\}$ and whose edges are true data dependences ($\\mathrm{RAW}$) with pipeline-distance constraints determined only by stage timing and whether forwarding is available. Under this model, define the earliest possible cycle an instruction $I_i$ can start $\\mathrm{EX}$, denoted $E_i$, by an as-soon-as-possible topological schedule that enforces:\n- program-order in-order issue (each $I_i$ must start $\\mathrm{EX}$ no earlier than one cycle after $I_{i-1}$ starts $\\mathrm{EX}$),\n- baseline pipeline flow (absent hazards, $I_i$ would start $\\mathrm{EX}$ in cycle $i+2$),\n- the data-dependence edge constraints implied by the pipeline (derive these constraints from the given stage semantics; do not assume any formula beyond stage timing).\n\nCompute the sequences $\\{E_i^{\\mathcal{F}}\\}_{i=1}^{8}$ and $\\{E_i^{\\mathcal{N}}\\}_{i=1}^{8}$ for variants $\\mathcal{F}$ and $\\mathcal{N}$, respectively, and then compute the scalar difference $\\Delta \\equiv E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$. Provide the value of $\\Delta$ as a single real number. No rounding is required.",
            "solution": "The problem requires the analysis of a five-stage pipelined processor executing a given sequence of instructions under two different configurations: one with full forwarding ($\\mathcal{F}$) and one with no forwarding ($\\mathcal{N}$). The goal is to determine the cycle at which the final instruction, $I_8$, starts its execution ($\\mathrm{EX}$) stage in each variant, and then to compute the difference.\n\nThe earliest cycle an instruction $I_i$ can begin its $\\mathrm{EX}$ stage, denoted $E_i$, is determined by an as-soon-as-possible (ASAP) schedule. This schedule must satisfy constraints imposed by the in-order issue nature of the pipeline and any true data dependences (Read-After-Write, or $\\mathrm{RAW}$).\n\nThe scheduling for $I_i$ is governed by the following recurrence relation for $i > 1$:\n$$E_i = \\max(E_{i-1} + 1, \\{\\text{data dependence constraints for } I_i\\})$$\nThe term $E_{i-1} + 1$ enforces the structural hazard constraint due to the single $\\mathrm{EX}$ unit and in-order issue. The data dependence constraints arise from $\\mathrm{RAW}$ hazards, where $I_i$ needs a result produced by a preceding instruction $I_k$ (where $k<i$). The base case is determined by the baseline pipeline flow: instruction $I_1$ is fetched at cycle $1$, decoded at cycle $2$, and starts execution at cycle $3$. Thus, $E_1 = 3$.\n\nFirst, we identify the $\\mathrm{RAW}$ data dependences in the given program fragment:\n- $I_1: \\mathrm{add}\\ r_1, r_2, r_3$\n- $I_2: \\mathrm{sub}\\ r_4, r_1, r_5$ depends on $I_1$ for register $r_1$. ($I_1 \\rightarrow I_2$)\n- $I_3: \\mathrm{lw}\\ r_6, 0(r_1)$ depends on $I_1$ for register $r_1$. ($I_1 \\rightarrow I_3$)\n- $I_4: \\mathrm{add}\\ r_7, r_6, r_8$ depends on $I_3$ for register $r_6$. ($I_3 \\rightarrow I_4$)\n- $I_5: \\mathrm{add}\\ r_1, r_7, r_9$ depends on $I_4$ for register $r_7$. ($I_4 \\rightarrow I_5$)\n- $I_6: \\mathrm{add}\\ r_{10}, r_1, r_{11}$ depends on $I_5$ for register $r_1$. ($I_5 \\rightarrow I_6$)\n- $I_7: \\mathrm{lw}\\ r_{12}, 8(r_{10})$ depends on $I_6$ for register $r_{10}$. ($I_6 \\rightarrow I_7$)\n- $I_8: \\mathrm{add}\\ r_{13}, r_{12}, r_{14}$ depends on $I_7$ for register $r_{12}$. ($I_7 \\rightarrow I_8$)\n\nNext, we derive the specific data dependence constraints for each variant. Let a producer instruction $I_k$ start its $\\mathrm{EX}$ stage at cycle $E_k$. A consumer instruction $I_i$ needs the result for its $\\mathrm{EX}$ stage, which starts at cycle $E_i$.\n\n**Variant $\\mathcal{N}$ (No Forwarding):**\nIn this variant, a result must be written to the register file before a subsequent instruction can read it.\n- An arithmetic instruction (`add`, `sub`) computes its result in the $\\mathrm{EX}$ stage (cycle $E_k$) and writes it back in the $\\mathrm{WB}$ stage (cycle $E_k+2$).\n- A load instruction (`lw`) computes its address in $\\mathrm{EX}$ (cycle $E_k$), reads memory in $\\mathrm{MEM}$ (cycle $E_k+1$), and writes the value back in the $\\mathrm{WB}$ stage (cycle $E_k+2$).\nFor both instruction types, the result is written to the register file during the first half of cycle $E_k+2$. The consumer instruction $I_i$ reads its source operands during the second half of its $\\mathrm{ID}$ stage, which occurs in cycle $E_i-1$. To ensure the correct value is read, the read must not occur in a cycle before the write. Therefore, the ID stage of $I_i$ must not be earlier than the WB stage of $I_k$:\n$$E_i - 1 \\ge E_k + 2 \\implies E_i \\ge E_k + 3$$\nThis constraint applies to all $\\mathrm{RAW}$ dependences in variant $\\mathcal{N}$.\n\n**Variant $\\mathcal{F}$ (Full Forwarding):**\nIn this variant, results can be bypassed from the end of the $\\mathrm{EX}$ or $\\mathrm{MEM}$ stages to the beginning of the $\\mathrm{EX}$ stage for a subsequent instruction.\n- **ALU-to-ALU Dependence:** If the producer $I_k$ is an arithmetic instruction, its result is available at the end of its $\\mathrm{EX}$ stage, i.e., at the end of cycle $E_k$. This value can be forwarded from the $\\mathrm{EX}/\\mathrm{MEM}$ pipeline register to the $\\mathrm{EX}$ stage input for $I_i$ in the next cycle. Thus, $I_i$ can begin execution in cycle $E_k+1$. The constraint is:\n$$E_i \\ge E_k + 1$$\n- **Load-to-Use Dependence:** If the producer $I_k$ is a `lw` instruction, its result is available from memory at the end of its $\\mathrm{MEM}$ stage, i.e., at the end of cycle $E_k+1$. This value can be forwarded from the $\\mathrm{MEM}/\\mathrm{WB}$ pipeline register to the $\\mathrm{EX}$ stage input for $I_i$ in the next cycle. Thus, $I_i$ can begin execution in cycle $E_k+2$. The constraint is:\n$$E_i \\ge E_k + 2$$\n\nNow we can compute the sequences $\\{E_i^{\\mathcal{F}}\\}_{i=1}^{8}$ and $\\{E_i^{\\mathcal{N}}\\}_{i=1}^{8}$.\n\n**Calculation for Variant $\\mathcal{F}$ (Full Forwarding):**\nThe recurrence is $E_i^\\mathcal{F} = \\max(E_{i-1}^\\mathcal{F} + 1, \\text{data dep terms})$.\n- $E_1^\\mathcal{F} = 3$.\n- $I_1 \\rightarrow I_2$ (`add` producer): $E_2^\\mathcal{F} = \\max(E_1^\\mathcal{F}+1, E_1^\\mathcal{F}+1) = \\max(3+1, 3+1) = 4$.\n- $I_1 \\rightarrow I_3$ (`add` producer): $E_3^\\mathcal{F} = \\max(E_2^\\mathcal{F}+1, E_1^\\mathcal{F}+1) = \\max(4+1, 3+1) = 5$.\n- $I_3 \\rightarrow I_4$ (`lw` producer): $E_4^\\mathcal{F} = \\max(E_3^\\mathcal{F}+1, E_3^\\mathcal{F}+2) = \\max(5+1, 5+2) = 7$.\n- $I_4 \\rightarrow I_5$ (`add` producer): $E_5^\\mathcal{F} = \\max(E_4^\\mathcal{F}+1, E_4^\\mathcal{F}+1) = \\max(7+1, 7+1) = 8$.\n- $I_5 \\rightarrow I_6$ (`add` producer): $E_6^\\mathcal{F} = \\max(E_5^\\mathcal{F}+1, E_5^\\mathcal{F}+1) = \\max(8+1, 8+1) = 9$.\n- $I_6 \\rightarrow I_7$ (`add` producer): $E_7^\\mathcal{F} = \\max(E_6^\\mathcal{F}+1, E_6^\\mathcal{F}+1) = \\max(9+1, 9+1) = 10$.\n- $I_7 \\rightarrow I_8$ (`lw` producer): $E_8^\\mathcal{F} = \\max(E_7^\\mathcal{F}+1, E_7^\\mathcal{F}+2) = \\max(10+1, 10+2) = 12$.\nThe sequence is $\\{E_i^\\mathcal{F}\\} = \\{3, 4, 5, 7, 8, 9, 10, 12\\}$. So, $E_8^\\mathcal{F}=12$.\n\n**Calculation for Variant $\\mathcal{N}$ (No Forwarding):**\nThe recurrence is $E_i^\\mathcal{N} = \\max(E_{i-1}^\\mathcal{N} + 1, \\text{data dep terms})$.\n- $E_1^\\mathcal{N} = 3$.\n- $I_1 \\rightarrow I_2$: $E_2^\\mathcal{N} = \\max(E_1^\\mathcal{N}+1, E_1^\\mathcal{N}+3) = \\max(3+1, 3+3) = 6$.\n- $I_1 \\rightarrow I_3$: $E_3^\\mathcal{N} = \\max(E_2^\\mathcal{N}+1, E_1^\\mathcal{N}+3) = \\max(6+1, 3+3) = 7$.\n- $I_3 \\rightarrow I_4$: $E_4^\\mathcal{N} = \\max(E_3^\\mathcal{N}+1, E_3^\\mathcal{N}+3) = \\max(7+1, 7+3) = 10$.\n- $I_4 \\rightarrow I_5$: $E_5^\\mathcal{N} = \\max(E_4^\\mathcal{N}+1, E_4^\\mathcal{N}+3) = \\max(10+1, 10+3) = 13$.\n- $I_5 \\rightarrow I_6$: $E_6^\\mathcal{N} = \\max(E_5^\\mathcal{N}+1, E_5^\\mathcal{N}+3) = \\max(13+1, 13+3) = 16$.\n- $I_6 \\rightarrow I_7$: $E_7^\\mathcal{N} = \\max(E_6^\\mathcal{N}+1, E_6^\\mathcal{N}+3) = \\max(16+1, 16+3) = 19$.\n- $I_7 \\rightarrow I_8$: $E_8^\\mathcal{N} = \\max(E_7^\\mathcal{N}+1, E_7^\\mathcal{N}+3) = \\max(19+1, 19+3) = 22$.\nThe sequence is $\\{E_i^\\mathcal{N}\\} = \\{3, 6, 7, 10, 13, 16, 19, 22\\}$. So, $E_8^\\mathcal{N}=22$.\n\n**Final Calculation:**\nThe problem asks for the scalar difference $\\Delta \\equiv E_8^{\\mathcal{N}} - E_8^{\\mathcal{F}}$.\nUsing the values computed above:\n$$ \\Delta = 22 - 12 = 10 $$\nThe difference in the start cycle of the $\\mathrm{EX}$ stage for instruction $I_8$ between the two variants is $10$.",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "While forwarding is a powerful technique, it is not a silver bullet; it cannot resolve every data dependency issue on its own. This practice moves beyond the \"what\" of forwarding to the \"how,\" asking you to step into the role of a processor designer and derive the precise logical predicate for a hazard detector . By focusing on the classic \"load-use\" hazard, where forwarding is insufficient, you will learn how stall logic and forwarding hardware work in concert to guarantee program correctness.",
            "id": "3643923",
            "problem": "A scalar, in-order, five-stage pipeline implements the following stages: instruction fetch ($\\mathrm{IF}$), instruction decode and register read ($\\mathrm{ID}$), execute ($\\mathrm{EX}$), memory access ($\\mathrm{MEM}$), and write-back ($\\mathrm{WB}$). The register file is read in $\\mathrm{ID}$ and written in $\\mathrm{WB}$. The machine forwards results from the pipeline registers at the boundaries $\\mathrm{EX}/\\mathrm{MEM}$ and $\\mathrm{MEM}/\\mathrm{WB}$ to the operand multiplexers feeding $\\mathrm{EX}$. The memory access in $\\mathrm{MEM}$ is a single-cycle ideal cache access, so a load produces its data at the end of $\\mathrm{MEM}$. There are no structural hazards. The instruction set architecture provides register-register arithmetic instructions, loads, stores, and conditional branches. Branches are resolved in $\\mathrm{EX}$ and are perfectly predicted, so there are no control stalls.\n\nYou will propose a minimal hazard detector that only stalls on load-use hazards, argue why forwarding plus this detector ensures correctness for all read-after-write data hazards in this pipeline, and then quantify the clock cycles per instruction (CPI) on a specified synthetic workload.\n\nAssumptions and nomenclature:\n- The pipeline registers are denoted $R_{\\mathrm{IF/ID}}$, $R_{\\mathrm{ID/EX}}$, $R_{\\mathrm{EX/MEM}}$, and $R_{\\mathrm{MEM/WB}}$.\n- For any instruction $I$ residing in a pipeline register $R$, the fields $R.\\mathrm{rs}$ and $R.\\mathrm{rt}$ denote the identifier of the first and second source registers read in $\\mathrm{ID}$ (when applicable), and $R.\\mathrm{dest}$ denotes the destination register written in $\\mathrm{WB}$ (when applicable). The control bit $R.\\mathrm{MemRead}$ is asserted if and only if $I$ is a load.\n- The register with index $0$ is hardwired to zero and is never written; comparisons to register $0$ should be handled in your logic so that false dependencies do not cause stalls.\n- When a stall is requested in cycle $t$, the program counter and $R_{\\mathrm{IF/ID}}$ are held, and a bubble (a $\\mathrm{NOP}$) is injected into $R_{\\mathrm{ID/EX}}$ for cycle $t+1$.\n\nTasks:\n1) From the preceding definitions and the semantics of the five-stage pipeline, derive a minimal combinational predicate $H$ over fields of $R_{\\mathrm{IF/ID}}$ and $R_{\\mathrm{ID/EX}}$ that is true if and only if a one-cycle stall must be inserted to avoid a read-after-write timing violation in $\\mathrm{EX}$ of the next cycle. Express $H$ symbolically in terms of equality, logical conjunction, disjunction, and negation over the named fields.\n\n2) Using only the pipeline timing assumptions stated above and the existence of forwarding from $R_{\\mathrm{EX/MEM}}$ and $R_{\\mathrm{MEM/WB}}$ to the $\\mathrm{EX}$ operand inputs, argue that with $H$ as the only source of stalls, all read-after-write data hazards are correctly handled. Your argument should consider producer instructions that are arithmetic (producing results at the end of $\\mathrm{EX}$) and loads (producing results at the end of $\\mathrm{MEM}$), and should explain why no other stalls are needed beyond those signaled by $H$.\n\n3) Consider a long synthetic instruction stream in which the static instruction mix is: arithmetic instructions fraction $f_{\\mathrm{A}} = 0.44$, loads fraction $f_{\\mathrm{L}} = 0.28$, stores fraction $f_{\\mathrm{S}} = 0.18$, and branches fraction $f_{\\mathrm{B}} = 0.10$. Assume the following independence model for data dependences: conditioned on an instruction at position $i$ being a load that writes a nonzero register, the instruction at position $i+1$ reads that same destination register as one of its sources with probability $p = 0.35$, independently of everything else. If it does, that constitutes a load-use case as defined in your $H$; otherwise, it does not. There are no other sources of stalls.\n\nBased on the minimal stall policy in parts $1$ and $2$, compute the expected steady-state $\\mathrm{CPI}$ of this pipeline on this workload. Round your answer to four significant figures. State only a single numerical value with no units.",
            "solution": "The problem presents a classic five-stage pipelined processor model and asks for the derivation of hazard detection logic, an argument for its correctness, and a performance calculation in terms of Clock Cycles Per Instruction ($\\mathrm{CPI}$). The problem is well-defined, internally consistent, and grounded in the fundamental principles of computer architecture. It will be addressed in three parts as requested.\n\n### 1. Derivation of the Hazard Detection Predicate $H$\n\nA data hazard requiring a stall occurs when the result of an instruction is not available when a subsequent instruction needs it, and the data cannot be supplied by the forwarding hardware. We must identify the specific timing case where this occurs.\n\nThe pipeline has forwarding from the output registers of the $\\mathrm{EX}$ and $\\mathrm{MEM}$ stages, namely $R_{\\mathrm{EX/MEM}}$ and $R_{\\mathrm{MEM/WB}}$, to the inputs of the $\\mathrm{EX}$ stage.\n- An arithmetic instruction computes its result in the $\\mathrm{EX}$ stage. This result is available in $R_{\\mathrm{EX/MEM}}$ at the end of the $\\mathrm{EX}$ stage, in time to be forwarded to the next instruction entering its $\\mathrm{EX}$ stage.\n- A load instruction fetches data from memory in the $\\mathrm{MEM}$ stage. This data is available in $R_{\\mathrm{MEM/WB}}$ only at the end of the $\\mathrm{MEM}$ stage.\n\nLet's consider a load instruction, $I_1$, followed immediately by an instruction, $I_2$, that uses the loaded data.\n- At cycle $t$, let $I_1$ be in the $\\mathrm{EX}$ stage and $I_2$ be in the $\\mathrm{ID}$ stage. The hardware in the $\\mathrm{ID}$ stage must decide whether to stall or proceed.\n- If the pipeline does not stall, then in cycle $t+1$, $I_1$ moves to the $\\mathrm{MEM}$ stage and $I_2$ moves to the $\\mathrm{EX}$ stage.\n- $I_2$ requires its source operands at the beginning of its $\\mathrm{EX}$ stage (i.e., at the start of cycle $t+1$).\n- However, $I_1$ will only have its data available from memory at the end of its $\\mathrm{MEM}$ stage (i.e., at the end of cycle $t+1$).\n- The data is thus not available for $I_2$ at the start of its $\\mathrm{EX}$ stage. The forwarding paths from $R_{\\mathrm{EX/MEM}}$ and $R_{\\mathrm{MEM/WB}}$ are of no help, as the required data has not yet been latched into either of these registers. This is a load-use RAW (Read-After-Write) hazard.\n\nTo resolve this, a one-cycle stall is necessary. When the hazard is detected in cycle $t$, a bubble is injected into the $\\mathrm{EX}$ stage for cycle $t+1$, and instruction $I_2$ is held in the $\\mathrm{ID}$ stage.\n- Cycle $t$: $I_1$ is in $\\mathrm{EX}$, $I_2$ is in $\\mathrm{ID}$. Hazard is detected.\n- Cycle $t+1$: $I_1$ moves to $\\mathrm{MEM}$. $I_2$ remains in $\\mathrm{ID}$. A $\\mathrm{NOP}$ (bubble) enters $\\mathrm{EX}$.\n- Cycle $t+2$: $I_1$ moves to $\\mathrm{WB}$. $I_2$ moves to $\\mathrm{EX}$. At the start of this cycle, the result of the load is in the pipeline register $R_{\\mathrm{MEM/WB}}$. The forwarding path from $R_{\\mathrm{MEM/WB}}$ can now correctly supply the operand to the $\\mathrm{EX}$ stage for $I_2$.\n\nThe hazard detection logic must identify this precise scenario. The logic resides in the $\\mathrm{ID}$ stage and operates on the contents of the pipeline registers that represent the instruction in $\\mathrm{EX}$ ($R_{\\mathrm{ID/EX}}$) and the instruction in $\\mathrm{ID}$ ($R_{\\mathrm{IF/ID}}$). The predicate $H$ for stalling is true if and only if all of the following conditions are met:\n1. The instruction in the $\\mathrm{EX}$ stage is a load. This is true if its `MemRead` control signal is asserted: $R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}$.\n2. The destination register of the load instruction is one of the source registers for the instruction in the $\\mathrm{ID}$ stage. This is true if $(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt})$.\n3. The dependency is not on the hardwired zero register, which can be read but never written. This means the destination register of the load cannot be register $0$: $R_{\\mathrm{ID/EX}}.\\mathrm{dest} \\neq 0$, which can be expressed as $\\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0)$.\n\nCombining these conditions, the minimal combinational predicate $H$ is:\n$$H = (R_{\\mathrm{ID/EX}}.\\mathrm{MemRead}) \\land \\neg(R_{\\mathrm{ID/EX}}.\\mathrm{dest} = 0) \\land ((R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rs}) \\lor (R_{\\mathrm{ID/EX}}.\\mathrm{dest} = R_{\\mathrm{IF/ID}}.\\mathrm{rt}))$$\n\n### 2. Argument for Correctness\n\nWe must demonstrate that the combination of the specified forwarding paths and the stall logic $H$ correctly resolves all possible RAW data hazards. We can classify hazards by the type of producer instruction and the distance to the consumer instruction.\n\n**Case A: The producer is an arithmetic instruction.**\nThe result is available at the end of the $\\mathrm{EX}$ stage in the $R_{\\mathrm{EX/MEM}}$ register.\n- **Consumer is the next instruction ($i+1$):** When the consumer instruction is in its $\\mathrm{EX}$ stage, the producer is in its $\\mathrm{MEM}$ stage. The producer's result is in $R_{\\mathrm{EX/MEM}}$ and can be forwarded to the consumer's $\\mathrm{EX}$ stage input. No stall is needed.\n- **Consumer is instruction $i+2$:** When the consumer is in its $\\mathrm{EX}$ stage, the producer is in its $\\mathrm{WB}$ stage. The producer's result is in $R_{\\mathrm{MEM/WB}}$ and can be forwarded to the consumer's $\\mathrm{EX}$ stage input. No stall is needed.\n- **Consumer is instruction $i+3$ or later:** The producer is past its $\\mathrm{WB}$ stage. The result has been written to the register file. The consumer reads the correct value from the register file during its $\\mathrm{ID}$ stage (due to write-before-read register file semantics, where the write half-cycle of $\\mathrm{WB}$ precedes the read half-cycle of $\\mathrm{ID}$). No stall is needed.\nConclusion for Case A: All RAW hazards from arithmetic instructions are resolved by the forwarding logic without stalls.\n\n**Case B: The producer is a load instruction.**\nThe result is available at the end of the $\\mathrm{MEM}$ stage in the $R_{\\mathrm{MEM/WB}}$ register.\n- **Consumer is the next instruction ($i+1$):** This is the load-use hazard detailed in Part 1. The result is needed by the consumer at the beginning of its $\\mathrm{EX}$ stage, but the producer only furnishes it at the end of its $\\mathrm{MEM}$ stage. Forwarding is not possible in time. The predicate $H$ is specifically designed to detect this case (load in $\\mathrm{EX}$, dependent consumer in $\\mathrm{ID}$) and correctly triggers a one-cycle stall. After the stall, the dependency is equivalent to the `load-use at i+2` case, which is handled by forwarding.\n- **Consumer is instruction $i+2$:** When the consumer is in its $\\mathrm{EX}$ stage, the producer is in its $\\mathrm{WB}$ stage. The loaded data is in $R_{\\mathrm{MEM/WB}}$ and can be forwarded to the consumer's $\\mathrm{EX}$ stage input. The predicate $H$ does not fire, as the instruction in the $\\mathrm{EX}$ stage (instruction $i+1$) is not the producer load instruction. The lack of a stall is correct.\n- **Consumer is instruction $i+3$ or later:** The result has been written to the register file and is read directly by the consumer. No stall is needed.\nConclusion for Case B: The only RAW hazard involving a load that is not resolved by forwarding is the immediate load-use case. This specific case is detected by $H$ and resolved by a one-cycle stall. All other cases are handled by forwarding or normal register file operation.\n\nSince all possible RAW hazards originating from both arithmetic and load instructions are handled correctly by either the forwarding hardware or the minimal stall logic $H$, the pipeline's data hazard handling is correct.\n\n### 3. CPI Calculation\n\nThe Clock Cycles Per Instruction ($\\mathrm{CPI}$) is the total number of clock cycles divided by the total number of instructions. In an ideal pipeline with no hazards, the $\\mathrm{CPI}$ is $1$. Stalls increase the $\\mathrm{CPI}$. The formula for $\\mathrm{CPI}$ is:\n$$ \\mathrm{CPI} = \\mathrm{CPI}_{\\text{ideal}} + \\frac{\\text{Total Stall Cycles}}{\\text{Total Instructions}} $$\nGiven $\\mathrm{CPI}_{\\text{ideal}} = 1$, we can write:\n$$ \\mathrm{CPI} = 1 + (\\text{stall frequency}) \\times (\\text{stall penalty}) $$\nFrom the analysis above, stalls only occur for a load-use hazard. The problem specifies a one-cycle stall, so the stall penalty is $1$ cycle per occurrence.\n\nWe need to calculate the stall frequency, which is the probability that any given instruction sequence triggers a stall. A stall is triggered if an instruction is a load AND the immediately following instruction uses its result.\n- The fraction of instructions that are loads is given as $f_{\\mathrm{L}} = 0.28$.\n- The probability that the instruction immediately following a load has a dependency on it is given as $p = 0.35$. This dependence is what is detected by the hazard logic $H$.\n\nThe frequency of stall events per instruction in the stream is the product of the probability of an instruction being a load and the conditional probability of the next instruction causing a load-use hazard.\n$$ \\text{Stall Frequency} = f_{\\mathrm{L}} \\times p $$\nThe number of stall cycles per instruction is this frequency multiplied by the penalty of $1$ cycle.\n$$ \\frac{\\text{Total Stall Cycles}}{\\text{Total Instructions}} = f_{\\mathrm{L}} \\times p \\times 1 = f_{\\mathrm{L}} \\times p $$\nSubstituting this into the $\\mathrm{CPI}$ formula:\n$$ \\mathrm{CPI} = 1 + f_{\\mathrm{L}} \\times p $$\nUsing the provided values $f_{\\mathrm{L}} = 0.28$ and $p = 0.35$:\n$$ \\mathrm{CPI} = 1 + (0.28 \\times 0.35) $$\n$$ \\mathrm{CPI} = 1 + 0.098 $$\n$$ \\mathrm{CPI} = 1.098 $$\nThe problem asks for the answer to be rounded to four significant figures. The value $1.098$ has exactly four significant figures.",
            "answer": "$$\n\\boxed{1.098}\n$$"
        },
        {
            "introduction": "Ultimately, the goal of architectural enhancements like forwarding is to improve overall performance, a metric often captured by Cycles Per Instruction (CPI). This final practice situates forwarding within the broader context of pipeline performance by including the effects of control hazards from branches . By analyzing a common loop structure, you will derive a symbolic expression for CPI, learning how the successful resolution of data hazards by forwarding interacts with other performance bottlenecks to determine the processor's true throughput.",
            "id": "3643933",
            "problem": "Consider a classic $5$-stage integer pipeline with stages Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The pipeline is single-issue, has perfect instruction and data caches (no cache misses), and implements full data forwarding (bypassing) to the Execute stage. Forwarding supplies results from the EX/MEM and MEM/WB pipeline registers into the EX stage inputs of dependent instructions and into the EX stage comparator for branches. Loads produce their result in the MEM stage; however, the code below contains no loads. Assume no structural hazards.\n\nA conditional branch is resolved in the EX stage. When the branch is taken, the front-end loses $\\beta$ bubble cycles due to control hazard handling; when the branch is not taken, no bubble cycles are incurred. Assume that the long-run fraction of iterations in which the branch is taken is $p$, where $0 \\leq p \\leq 1$.\n\nAnalyze the following tight loop, which updates register $R2$ and uses $R2$ immediately in the subsequent instruction:\n\nLOOP:\n    ADD R2, R2, R3\n    SUB R4, R2, R5\n    ADD R1, R1, R11\n    BNE R1, R12, LOOP\n\nAssume the branch at the end loops until a termination condition that depends on $R1$, so the branch is taken for a fraction $p$ of dynamic executions and not taken otherwise.\n\nStarting from the fundamental definitions of pipeline stages and hazard handling, trace the forwarding decisions for the data dependences in one steady-state loop iteration and determine whether any stall cycles are required. Then, derive a closed-form symbolic expression for the steady-state Cycles Per Instruction (CPI) of this loop as a function of the taken-branch fraction $p$ and the taken-branch penalty $\\beta$. Express your final answer as a single analytic expression. The CPI is dimensionless; no units are required.",
            "solution": "The problem statement is critically evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- Pipeline: $5$-stage (Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory Access (MEM), Write Back (WB)).\n- Microarchitecture: single-issue, full data forwarding from EX/MEM and MEM/WB registers to the EX stage inputs and EX stage comparator.\n- Caches: perfect instruction and data caches (no cache misses).\n- Hazards: No structural hazards. Loads are not present in the code.\n- Control Flow: A conditional branch (`BNE`) is resolved in the EX stage.\n- Branch Penalty: A taken branch incurs a penalty of $\\beta$ bubble cycles. A not-taken branch incurs $0$ bubble cycles.\n- Branch Behavior: The branch is taken with a long-run fraction (probability) of $p$, where $0 \\leq p \\leq 1$.\n- Code Sequence (Loop):\n  1. `ADD R2, R2, R3`\n  2. `SUB R4, R2, R5`\n  3. `ADD R1, R1, R11`\n  4. `BNE R1, R12, LOOP`\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, describing a standard RISC pipeline model commonly used in computer architecture education and analysis. The concepts of data forwarding, control hazards, and Cycles Per Instruction (CPI) are well-defined. The problem is well-posed, providing all necessary parameters ($\\beta$, $p$) and a clear code segment to derive a unique symbolic expression for CPI. The language is objective and precise. The givens are internally consistent and do not violate any fundamental principles of computer organization. The specified forwarding paths are sufficient to handle the data dependencies present in the code, which will be demonstrated in the solution. The problem is not trivial, as it requires careful analysis of both data and control hazards.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full solution will be derived.\n\n### Solution Derivation\nThe objective is to derive a closed-form symbolic expression for the steady-state Cycles Per Instruction (CPI) of the provided loop. This requires analyzing both data and control hazards.\n\nLet the four instructions in the loop be denoted as follows:\n- $I_1$: `ADD R2, R2, R3`\n- $I_2$: `SUB R4, R2, R5`\n- $I_3$: `ADD R1, R1, R11`\n- $I_4$: `BNE R1, R12, LOOP`\n\n**1. Data Hazard Analysis**\n\nWe identify the Read-After-Write (RAW) data dependencies in the code:\n- **Dependency on $R2$**: $I_1$ writes to register $R2$, and $I_2$ reads from $R2$.\n- **Dependency on $R1$**: $I_3$ writes to register $R1$, and $I_4$ reads from $R1$ for the branch comparison.\n\nLet's trace the pipeline execution to determine if these dependencies cause stalls. A stall is required if the result of a producer instruction is not available when the consumer instruction needs it.\n\n*Analysis of the $I_1 \\rightarrow I_2$ dependency:*\nInstruction $I_1$ (ADD) computes its result in the EX stage. This result is available for forwarding at the end of the clock cycle where $I_1$ is in its EX stage. Instruction $I_2$ (SUB) requires the value of $R2$ as an input to the ALU at the beginning of its EX stage.\nConsider the pipeline timing diagram for a single iteration without any stalls:\n- Cycle $k$: $I_1$ is in EX stage.\n- Cycle $k+1$: $I_1$ is in MEM stage, $I_2$ is in EX stage.\n\nAt cycle $k+1$, the result of $I_1$ is present in the EX/MEM pipeline register. The problem states that the pipeline has \"full data forwarding... from the EX/MEM... pipeline registers into the EX stage inputs\". Therefore, the result of $I_1$ can be forwarded directly to the ALU input for $I_2$ in cycle $k+1$. No stall is necessary to resolve this dependency.\n\n*Analysis of the $I_3 \\rightarrow I_4$ dependency:*\nInstruction $I_3$ (ADD) computes its result for $R1$ in its EX stage. Instruction $I_4$ (BNE) needs this value of $R1$ in its EX stage to perform the comparison.\nConsider the pipeline timing for these instructions:\n- Cycle $m$: $I_3$ is in EX stage.\n- Cycle $m+1$: $I_3$ is in MEM stage, $I_4$ is in EX stage.\n\nSimilar to the first case, at cycle $m+1$, the new value of $R1$ from $I_3$ is available in the EX/MEM pipeline register. The problem specifies that forwarding is available \"into the EX stage comparator for branches\". Thus, the new value of $R1$ can be forwarded to the comparator logic in the EX stage for $I_4$. No stall is necessary for this dependency either.\n\nConclusion on data hazards: Due to the specified full forwarding hardware, no stall cycles are incurred because of data dependencies within the loop body.\n\n**2. Control Hazard and CPI Calculation**\n\nThe CPI is defined as the total number of cycles divided by the total number of instructions. For a steady-state loop, we can calculate this as the average number of cycles per loop iteration divided by the number of instructions per iteration.\n\nThe number of instructions per iteration, $N_{instr}$, is $4$.\n\nIn the absence of any hazards, a single-issue pipeline has an ideal CPI of $1$. In such a scenario, one loop iteration would complete in $4$ cycles in the steady state. However, the `BNE` instruction ($I_4$) introduces a potential control hazard.\n\nThe branch outcome is determined in the EX stage of $I_4$. We must consider two cases:\n\n*Case A: Branch is not taken*\nThis occurs with a probability of $(1-p)$. The pipeline is assumed to predict that the branch is not taken (a common static prediction scheme), so it continues fetching instructions sequentially. When $I_4$ is resolved in its EX stage and found to be not taken, the instructions already fetched are the correct ones. The problem states that in this case, $0$ bubble cycles are incurred.\nThe number of cycles for this iteration is simply the number of instructions: $C_{not\\_taken} = 4$.\n\n*Case B: Branch is taken*\nThis occurs with a probability of $p$. When $I_4$ is in its EX stage, the pipeline discovers that the branch is taken. At this point, the instructions for the next iteration have been fetched from the wrong path (sequentially). These instructions must be flushed from the pipeline, and fetching must restart at the branch target (`LOOP`). The problem specifies this costs $\\beta$ bubble cycles.\nThe number of cycles for this iteration is the number of instructions plus the penalty: $C_{taken} = 4 + \\beta$.\n\n*Average Cycles per Iteration*\nThe average number of cycles per loop iteration, $\\bar{C}_{iter}$, is the weighted average of the cycles in each case:\n$$ \\bar{C}_{iter} = C_{not\\_taken} \\cdot (1-p) + C_{taken} \\cdot p $$\n$$ \\bar{C}_{iter} = 4 \\cdot (1-p) + (4 + \\beta) \\cdot p $$\n$$ \\bar{C}_{iter} = 4 - 4p + 4p + \\beta p $$\n$$ \\bar{C}_{iter} = 4 + \\beta p $$\n\n*Final CPI Calculation*\nThe steady-state CPI is the average cycles per iteration divided by the number of instructions per iteration:\n$$ \\text{CPI} = \\frac{\\bar{C}_{iter}}{N_{instr}} $$\n$$ \\text{CPI} = \\frac{4 + \\beta p}{4} $$\n$$ \\text{CPI} = 1 + \\frac{\\beta p}{4} $$\n\nThis expression represents the steady-state CPI as a function of the taken-branch fraction $p$ and the taken-branch penalty $\\beta$. The base CPI is $1$, and the additional term $\\frac{\\beta p}{4}$ represents the performance penalty due to control hazards, averaged over all instructions in the loop.",
            "answer": "$$\\boxed{1 + \\frac{\\beta p}{4}}$$"
        }
    ]
}