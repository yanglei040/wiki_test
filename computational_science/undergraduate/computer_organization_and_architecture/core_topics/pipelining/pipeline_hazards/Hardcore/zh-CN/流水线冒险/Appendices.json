{
    "hands_on_practices": [
        {
            "introduction": "在探讨了数据冒险之后，我们现在来探索控制冒险，它会破坏指令的顺序执行流程。本问题聚焦于一个特定的、微妙的控制冒险场景，即深度递归函数调用期间返回地址栈（RAS）的行为。通过分析这个场景，你将看到软件构造如何对硬件预测机制产生压力，以及编译器优化如何巧妙地解决由此产生的性能问题 。",
            "id": "3664987",
            "problem": "考虑一个单发射、顺序流水线，其包含以下$6$个阶段：指令提取（IF，阶段$1$）、指令译码（ID，阶段$2$）、寄存器读取（RR，阶段$3$）、执行（EX，阶段$4$）、访存（MEM，阶段$5$）和写回（WB，阶段$6$）。包括函数返回在内的控制转移，在返回指令到达执行（EX）阶段时被解析。在那一刻，如果预测的下一条程序计数器不正确，则所有位于更早阶段的更晚指令都将被冲刷。\n\n一个动态预测器使用一个容量为$C$个条目的返回地址栈（RAS）。RAS在函数调用时存储返回地址，并在返回时提供这些地址。假设：\n- 每个阶段恰好占用$1$个周期。\n- 预测错误的返回会导致在返回指令被解析时，冲刷所有更早的流水线阶段。\n- 在主计算之后，该递归是自尾递归，因此每次调用都会对自身执行一次尾调用，直到满足基本情况为止。\n- 除了返回之外的所有非返回控制转移都被完美预测。\n\n编译器未对一个特定的递归函数执行尾调用优化，该函数达到最大递归深度$D = 50$帧（包括基本情况）。微架构提供了一个容量为$C = 16$的RAS。当递归回溯时，超出RAS容量的返回会因为之前的溢出而弹出不正确的地址，从而导致预测错误。\n\n仅从流水线冒险（由未解析的分支目标引起的控制冒险）、流水线阶段时序以及返回地址栈（RAS）在溢出情况下的行为这些核心定义出发，推导在基线（无尾调用优化）情况下，由返回预测错误导致的总停顿惩罚（以周期为单位）。然后，提出一种尾调用优化方案，将递归尾调用转换为等效循环，从而消除递归链中每次调用的返回。在此优化下，假设循环结束时只有一个最终返回，并且RAS永不溢出。\n\n计算与基线递归场景相比，通过尾调用优化消除的净停顿周期数。将您的最终答案表示为精确的整数周期数。无需四舍五入，最终答案框内也无需报告物理单位。",
            "solution": "我们从流水线冒险和预测器行为的基本概念开始：\n\n- 当下一个程序计数器未能及早确定时，会产生控制冒险，导致流水线可能沿着错误的路径提取指令。如果预测错误，则在更早阶段中沿着错误路径提取的指令必须被冲刷，从而产生停顿周期。\n- 在一个阶段编号为$1$到$6$的$6$阶段流水线中，如果一个控制转移在阶段$k$被解析，那么在解析的时刻，有$k-1$个更早的阶段（阶段$1$到$k-1$）可能持有错误路径上的指令。在一个每个阶段占用一周期、简单的顺序流水线中，冲刷这些指令并重定向指令提取会产生$k-1$个周期的惩罚。\n- 返回地址栈（RAS）在调用时压入返回地址，并在匹配的返回时弹出它。如果递归深度$D$超过RAS容量$C$，那么超过容量$C$的压入操作会覆盖或替换掉较早的条目，从而使得最早的$D-C$个返回将弹出不正确的地址。每次这样的不正确弹出都构成一次预测错误的返回。\n\n我们将这些原则应用于给定的流水线和递归：\n\n1. 返回在执行（EX）阶段被解析，在给定的流水线中这是第$k = 4$阶段（IF是$1$，ID是$2$，RR是$3$，EX是$4$）。因此，一个预测错误的返回会产生如下的停顿惩罚：\n   $$ p = k - 1 = 4 - 1 = 3 \\text{ cycles}. $$\n\n2. 递归深度达到$D = 50$，而RAS的容量为$C = 16$。在溢出情况下，回溯期间因地址不正确而被弹出的返回次数为：\n   $$ N_{\\text{mispred}} = D - C = 50 - 16 = 34. $$\n\n3. 每次预测错误的返回都会产生$p = 3$个周期的惩罚。因此，在基线（无尾调用优化）场景下，由返回预测错误导致的总停顿惩罚为：\n   $$ S_{\\text{baseline}} = N_{\\text{mispred}} \\cdot p = 34 \\cdot 3 = 102. $$\n\n现在我们考虑尾调用优化：\n\n- 尾调用优化重写了自尾调用，使得函数不再为尾调用压入新的栈帧；而是将其变为一个循环，迭代直至达到基本情况。这消除了递归链中每次调用的返回，从而消除了会导致RAS溢出和预测错误的一系列返回。\n- 在优化后，循环结束后只有一个最终的返回。由于只有一个返回且RAS容量为$C = 16$，不会发生溢出，因此RAS的弹出是正确的。根据假设，非返回的控制转移被完美预测，并且我们认为最终的返回被RAS正确处理。因此，优化后因返回预测错误产生的停顿惩罚为：\n  $$ S_{\\text{optimized}} = 0. $$\n\n通过尾调用优化，相对于基线消除的净停顿周期数为：\n$$ \\Delta S = S_{\\text{baseline}} - S_{\\text{optimized}} = 102 - 0 = 102. $$\n\n因此，节省的精确整数周期数为$102$。",
            "answer": "$$\\boxed{102}$$"
        },
        {
            "introduction": "现实世界中的处理器远比简单的教科书模型复杂。最后一个练习将深入探讨数据冒险检测的精妙之处，揭示依赖关系并非总是发生在整个寄存器层面。你将首先识别一个由子寄存器操作引起的“假冒险”，然后量化实现一个更精确的、字节级别的依赖性检查器以消除此类低效率所需的硬件复杂度 。",
            "id": "3665019",
            "problem": "一台具有 $64$ 位通用寄存器的标量机支持子字操作，这些操作可在寄存器内读取或写入大小为 $1$、$2$、$4$ 或 $8$ 字节的连续、自然对齐的字段。其流水线目前对写后读（RAW）使用一种简单的依赖检查规则：一条读取寄存器 $r$ 的年轻指令，被认为与任何写入寄存器 $r$ 的正在执行的年老指令存在 RAW 依赖，无论实际读取或写入的是哪个子字字段。\n\nA 部分（概念设置）：构建一个双指令序列，在意图层面（命名所访问的子字字段）进行表达，该序列在此简单规则下会触发 RAW 假阳性，但由于写入和读取的子字不相交而没有真正的数据依赖。你可以假设有一个通用的算术指令，它只读取源寄存器的高 $32$ 位；以及一个字节写入指令，它只写入目标寄存器的最低 $8$ 位。\n\nB 部分（推导与计算）：为了消除此类假阳性同时不错过真正的冒险，你重新设计了冒险检测单元，以跟踪每个字节的掩码。对于每条将要写入某个目标寄存器 $d_{j}$ 的正在执行的年老指令 $j$，你存储：\n- 一个寄存器标识符，以及\n- 一个 $8$ 位写入掩码 $W_{j}$，其中位 $k \\in \\{0,\\dots,7\\}$ 表示是否将写入 $d_{j}$ 的字节 $k$。\n\n对于新译码指令的每个源操作数 $i$，你获取：\n- 一个寄存器标识符 $r_{i}$，以及\n- 一个 $8$ 位读取掩码 $R_{i}$，其中位 $k$ 表示是否将读取 $r_{i}$ 的字节 $k$。\n\n源操作数 $i$ 和年老指令 $j$ 之间存在真正的 RAW，当且仅当 $r_{i} = d_{j}$ 并且访问字节的交集非空，也就是说，当且仅当按位交集 $W_{j} \\wedge R_{i}$ 至少有一个 $1$ 位。\n\n你需要量化基于掩码的最小依赖跟踪复杂度，以译码阶段每周期评估一条新译码指令的 RAW 冒险所需的位级操作数来表示，并遵循以下约束：\n- 与 RAW 检查相关的正在执行的年老写入指令最多有 $f$ 条。\n- 新指令最多有 $r$ 个源操作数。\n- 冒险单元必须为所有对 $(i,j)$ 计算所有的成对掩码重叠 $W_{j} \\wedge R_{i}$，且不使用时间复用（即，所有需要的按位与操作都在该周期内执行）。\n- 你只需计算用于形成这些成对重叠向量的 1 位与操作的数量（忽略用于测试非空性的寄存器标识符相等性比较和任何或-归约的成本）。\n\n从基本原理出发，推导所需 1 位与操作最小数量的闭式表达式，该表达式是 $r$、$f$ 以及每个寄存器的字节数 $b$ 的函数。然后，用 $r = 3$、$f = 24$ 和 $b = 8$ 计算该表达式的值。将最终答案表示为一个数字。不需要单位，也不需要四舍五入。",
            "solution": "首先根据指定标准对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 机器：标量机，具有 $64$ 位通用寄存器。\n- 操作：对大小为 $1$、$2$、$4$ 或 $8$ 字节的连续、自然对齐字段进行子字操作。\n- 简单的 RAW 规则：一条读取寄存器 $r$ 的年轻指令依赖于任何写入寄存器 $r$ 的年老指令，不考虑子字字段。\n- A 部分已知条件：一条算术指令读取源寄存器的高 $32$ 位；一条字节写入指令写入目标寄存器的最低 $8$ 位。\n- B 部分已知条件（重新设计的单元）：\n    - $W_j$：一条正在执行的年老指令 $j$ 的 $8$ 位写入掩码。\n    - $R_i$：一条新指令的源操作数 $i$ 的 $8$ 位读取掩码。\n    - 真正的 RAW 条件：寄存器标识符匹配 并且 按位交集 $W_j \\wedge R_i$ 非零。\n- B 部分计算约束：\n    - $f$：正在执行的年老写入指令的最大数量。\n    - $r$：新指令的最大源操作数数量。\n    - $b$：每个寄存器的字节数（对于 $64$ 位寄存器和 $8$ 位掩码，隐含为 $8$）。\n    - 所有成对掩码重叠 $W_j \\wedge R_i$ 都在一个周期内计算。\n    - 计数仅限于这些重叠所需的 1 位与操作的数量。\n- B 部分评估参数：$r = 3$，$f = 24$，$b = 8$。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题被评估为有效。\n- **科学基础：** 该问题根植于计算机体系结构的基本概念，特别是流水线冒险（写后读）和用于解决这些问题的微体系结构技术（使用位掩码进行依赖检查）。这些是该领域的标准课题。\n- **提法得当：** 问题清晰地分为概念部分（A）和定量部分（B）。A 部分提供了足够的细节来构建所需的示例。B 部分提供了一组明确的变量、约束和一个要计算的特定量，从而得出一个唯一的解。\n- **客观性：** 语言正式、精确，没有主观或含糊的术语。\n- 问题不违反任何其他验证标准（事实可靠性、可形式化性、完整性、现实性等）。参数和概念与现代处理器设计一致。\n\n**结论与行动**\n问题有效。将提供完整解答。\n\n**A 部分：概念性的 RAW 假阳性冒险**\n\n当硬件检测到一个在数据层面实际不存在的依赖关系，从而导致不必要的流水线停顿时，就会发生写后读（RAW）假阳性冒险。当涉及子字操作时，在整个寄存器级别检查依赖关系的简单规则容易出现此类错误。\n\n让我们考虑一个由两条指令组成的序列，一条年老指令 $I_1$ 和一条年轻指令 $I_2$，它们都操作同一个 $64$ 位寄存器，我们称之为 $R_A$。一个 $64$ 位寄存器由 $8$ 个字节组成，我们可以从字节 $0$（最低有效字节）到字节 $7$（最高有效字节）对其进行索引。\n\n1.  **年老指令 $I_1$**：这是问题中指定的字节写入指令。它向寄存器 $R_A$ 写入一个值，但只修改最低的字节。\n    - **操作**：写入寄存器 $R_A$ 的字节 $0$（位 $7$ 到 $0$）。\n    - **写入的字节**：$\\{0\\}$\n\n2.  **年轻指令 $I_2$**：这是问题中指定的算术指令。它使用寄存器 $R_A$ 作为源操作数，但只需要存储在高 $32$ 位中的值。\n    - **操作**：读取高 $32$ 位，这对应于寄存器 $R_A$ 的高 $4$ 个字节。\n    - **读取的字节**：$\\{4, 5, 6, 7\\}$\n\n**依赖性分析：**\n\n- **简单规则应用**：冒险检测单元看到 $I_1$ 写入寄存器 $R_A$，而后续的指令 $I_2$ 从寄存器 $R_A$ 读取。根据其规则，它标记了一个 RAW 依赖。这迫使流水线停顿 $I_2$，直到 $I_1$ 完成其写回阶段，以确保 $I_2$ 读取到 $R_A$ 的“正确”值。\n\n- **真实依赖分析**：只有当 $I_1$ 的执行影响 $I_2$ 的结果时，才存在真正的数据依赖。如果 $I_2$ 读取了 $I_1$ 修改过的寄存器部分，就会发生这种情况。在本例中，$I_1$ 写入的字节集是 $\\{0\\}$，$I_2$ 读取的字节集是 $\\{4, 5, 6, 7\\}$。这两个集合的交集为空：$\\{0\\} \\cap \\{4, 5, 6, 7\\} = \\emptyset$。因此，$I_2$ 读取的值完全独立于 $I_1$ 执行的写入操作。简单检查器标记的 RAW 冒险是一个**假阳性**。这次停顿是不必要的，导致了性能损失。\n\n**B 部分：硬件复杂度的推导与计算**\n\n重新设计的冒险检测单元旨在通过使用位掩码在字节级别跟踪依赖关系来消除这些假阳性。我们需要推导出一个闭式表达式，表示为执行这种更精确的检查，每周期所需的 1 位与操作总数。\n\n设 $N$ 为 1 位与操作的总数。\n问题提供了以下参数：\n- $r$：新译码指令的最大源操作数数量。\n- $f$：正在执行的、写入寄存器的年老指令的最大数量。\n- $b$：每个寄存器的字节数。这对应于读写掩码的长度。\n\n对于一个给定的源操作数 $i$ 和一条年老的写入指令 $j$，真正的 RAW 冒险逻辑是：\n$(r_i = d_j) \\wedge (\\text{non-zero}(W_j \\wedge R_i))$\n其中 $r_i$ 和 $d_j$ 是寄存器标识符，$W_j$ 和 $R_i$ 分别是 $b$ 位的写入和读取掩码。\n\n我们被要求只计算用于形成成对重叠向量 $W_j \\wedge R_i$ 的 1 位与操作的数量。\n\n1.  **每对的操作**：对于由一个源操作数 $i$ 和一个年老写入者 $j$ 组成的单对，我们需要计算它们掩码的按位与，$W_j \\wedge R_i$。由于每个掩码都是一个 $b$ 位向量，计算它们的按位与需要执行 $b$ 个独立的 1 位与操作。\n\n2.  **对的数量**：必须对新指令的每个源操作数与每个年老的写入指令进行检查。\n    - 源操作数数量 = $r$。\n    - 年老写入者数量 = $f$。\n    - 硬件必须在一个周期内并行评估所有可能的配对。此类对 $(i, j)$ 的总数是源操作数数量与年老写入者数量的乘积，即 $r \\times f$。\n\n3.  **总操作数**：1 位与操作的总数 $N$ 是对的数量乘以每对的 1 位与操作数。\n    $$ N = (\\text{对的数量}) \\times (\\text{每对的操作数}) $$\n    代入上述步骤中的表达式：\n    $$ N = (r \\times f) \\times b $$\n    因此，闭式表达式为：\n    $$ N = rfb $$\n\n**针对特定参数的评估**：\n我们被要求用给定的值来评估这个表达式：\n- $r = 3$\n- $f = 24$\n- $b = 8$（因为寄存器是 $64$ 位的，意味着 $64/8 = 8$ 字节）\n\n将这些值代入我们推导出的表达式中：\n$$ N = (3) \\times (24) \\times (8) $$\n首先，我们计算 $r$ 和 $f$ 的乘积：\n$$ 3 \\times 24 = 72 $$\n然后，将此结果乘以 $b$：\n$$ N = 72 \\times 8 $$\n$$ N = 576 $$\n因此，在一个周期内为一条新指令并行计算所有必要的重叠掩码，至少需要 $576$ 个单独的 1 位与门。",
            "answer": "$$\\boxed{576}$$"
        }
    ]
}