{
    "hands_on_practices": [
        {
            "introduction": "The core idea of a branch delay slot is to turn a potential pipeline stall into an opportunity for useful work. This first exercise makes that concept concrete by having you practice the most common method of filling a delay slot: moving a safe instruction from before the branch. By then deriving a formula for speedup, you will develop a quantitative model for how much this optimization is worth, depending on how often branches occur and how successfully they can be filled .",
            "id": "3629849",
            "problem": "Consider a classic five-stage, single-issue Reduced Instruction Set Computer (RISC) pipeline with one architecturally visible branch delay slot per control-transfer instruction, as in Microprocessor without Interlocked Pipeline Stages (MIPS). The branch delay slot semantics are: the instruction immediately following a branch always executes, regardless of whether the branch is taken. If a compiler or hand-scheduler cannot find a useful, safe instruction to place in the delay slot, a No Operation (NOP) occupies that slot. Assume the following baseline facts as the fundamental base for reasoning:\n- The execution time of a program can be modeled as the number of executed instructions times the average cycles per instruction, and for an ideal single-issue pipeline with no stalls other than branch-delay effects, the cycles per instruction is $1$.\n- Speedup is defined as $S = T_{\\text{baseline}} / T_{\\text{improved}}$, where $T$ denotes the total execution time (or, equivalently, total cycles on a fixed-frequency machine).\n- Let $I_u$ denote the dynamic count of useful instructions in the original program semantics (excluding any NOPs introduced to fill delay slots).\n- Let $f_b$ denote the dynamic fraction of branch instructions among the $I_u$ useful instructions, so the dynamic number of branch instructions is $N_b = f_b \\, I_u$.\n\nBuild a minimal example (in pseudocode or MIPS-like style) in which a branch has a delay slot that can be filled by moving a safe instruction (one that preserves correctness with respect to data dependences and exception behavior) from before or after the branch. Illustrate which instruction you choose to place in the delay slot and justify why it is safe.\n\nNow model the effect of instruction scheduling that fills a fraction $r$ of the delay slots with useful instructions, where $r \\in [0,1]$ is the fill rate over the dynamic execution. Assume that:\n- Each unfilled delay slot executes a single NOP, costing exactly $1$ cycle.\n- Filling a delay slot with a useful instruction does not increase the total number of cycles relative to executing that instruction at its original position; it is purely a reordering that preserves the total count of useful instructions $I_u$.\n- There are no additional stalls or hazards beyond what is described, and the machine remains single-issue with one instruction retired per cycle.\n\nDerive, from the above definitions, a closed-form symbolic expression for the speedup $S$ as a function of the fill rate $r$ and the branch fraction $f_b$. Your final answer must be a single analytic expression in terms of $r$ and $f_b$. No numerical approximation or rounding is required. Express your final answer as a single closed-form expression.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of computer architecture, specifically RISC pipeline design and instruction scheduling. The problem is well-posed, providing a clear set of definitions and constraints ($I_u$, $f_b$, $r$, CPI=$1$, speedup definition) that permit the derivation of a unique, meaningful symbolic expression. The language is objective and free of ambiguity. The problem is formalizable and directly relevant to the topic of control flow instructions.\n\nThe problem consists of two parts: first, to provide a minimal example of filling a branch delay slot, and second, to derive a formula for the speedup gained from this optimization.\n\nFirst, we will construct a minimal example. Consider the following sequence of MIPS-like instructions:\n\nOriginal code sequence:\n1. `ADD R3, R1, R2`  // An instruction that determines the branch condition.\n2. `SUB R4, R5, R6`  // An independent instruction.\n3. `BEQ R3, R0, Target` // Branch if `R3` equals `R0`.\n4. `...`             // Instruction at the fall-through path.\n\nIn a MIPS-like pipeline with a branch delay slot, the instruction immediately following the branch is always executed. To ensure correctness without scheduling, a `NOP` (No Operation) instruction would be placed after the branch:\n\nCode with NOP in delay slot:\n`ADD R3, R1, R2`\n`SUB R4, R5, R6`\n`BEQ R3, R0, Target`\n`NOP`                // The NOP in the delay slot is always executed.\n\nInstruction scheduling can improve performance by replacing the `NOP` with a useful instruction. There are three primary sources for such an instruction:\n1.  From before the branch: An independent instruction from before the branch can be moved into the delay slot.\n2.  From the branch target: An instruction from the target address can be moved, but it must be safe to execute even if the branch is not taken.\n3.  From the fall-through path: An instruction from the sequential path can be moved, but it must be safe to execute even if the branch is taken.\n\nThe safest and most common optimization is moving an instruction from before the branch. In our example, the `SUB R4, R5, R6` instruction does not affect the branch condition (which depends on `R3`) and its destination register (`R4`) is not used by the branch instruction. Therefore, it can be safely moved into the delay slot. The `ADD R3, R1, R2` instruction cannot be moved because it produces the value that the `BEQ` instruction consumes.\n\nScheduled code with filled delay slot:\n`ADD R3, R1, R2`\n`BEQ R3, R0, Target`\n`SUB R4, R5, R6`  // Moved into the delay slot.\n\nThis scheduled code is correct because the `SUB` instruction was guaranteed to execute in the original sequence, and its execution in the delay slot does not alter the program logic or the outcome of the branch. The total number of useful instructions remains the same, but one `NOP` cycle has been eliminated.\n\nNext, we derive the general expression for speedup, $S$, as a function of the branch fraction, $f_b$, and the delay slot fill rate, $r$.\n\nThe speedup is defined as $S = T_{\\text{baseline}} / T_{\\text{improved}}$. Since the problem states that the average cycles per instruction (CPI) is $1$ for all executed instructions (including `NOP`s) and the clock frequency is fixed, the execution time $T$ is directly proportional to the total number of instructions executed.\nLet $I_{total}$ be the total number of instructions dynamically executed.\nThen $T \\propto I_{total}$.\n\nLet $I_u$ be the dynamic count of useful instructions in the program. This count is constant.\nLet $f_b$ be the fraction of branch instructions among the useful instructions.\nThe number of branch instructions is $N_b = f_b I_u$.\nEach branch instruction creates one delay slot.\n\nWe must define a baseline for comparison. A natural and logical baseline is the scenario where no optimization is performed, meaning every branch delay slot is filled with a `NOP`. This corresponds to a fill rate of $r=0$.\n\nIn the baseline scenario ($T_{\\text{baseline}}$):\nThe number of `NOP` instructions is equal to the number of branch instructions, since no slots are filled with useful instructions.\n$N_{NOP, baseline} = N_b = f_b I_u$.\nThe total number of executed instructions is the sum of useful instructions and `NOP`s.\n$I_{total, baseline} = I_u + N_{NOP, baseline} = I_u + f_b I_u = I_u(1 + f_b)$.\nThe execution time (or cycles) is $T_{\\text{baseline}} = I_{total, baseline} \\cdot 1 = I_u(1 + f_b)$.\n\nNow, consider the improved scenario ($T_{\\text{improved}}$) where a fraction $r$ of the delay slots are filled with useful instructions.\nThe total number of branch instructions remains $N_b = f_b I_u$.\nThe number of delay slots filled with useful instructions is $r \\cdot N_b = r f_b I_u$.\nThe number of delay slots that remain unfilled and are thus occupied by `NOP`s is $(1-r) \\cdot N_b = (1-r) f_b I_u$.\nThe total number of executed instructions is the sum of the constant number of useful instructions, $I_u$, and the number of `NOP`s. The useful instructions moved into delay slots do not add to the instruction count, as they are simply reordered.\n$I_{total, improved} = I_u + N_{NOP, improved} = I_u + (1-r)f_b I_u = I_u(1 + (1-r)f_b)$.\nThe execution time (or cycles) is $T_{\\text{improved}} = I_{total, improved} \\cdot 1 = I_u(1 + (1-r)f_b)$.\n\nFinally, we calculate the speedup $S$:\n$$S = \\frac{T_{\\text{baseline}}}{T_{\\text{improved}}} = \\frac{I_u(1 + f_b)}{I_u(1 + (1-r)f_b)}$$\nThe $I_u$ terms cancel, yielding the final expression for speedup as a function of $f_b$ and $r$:\n$$S(f_b, r) = \\frac{1 + f_b}{1 + (1-r)f_b}$$\nThis can also be written as:\n$$S(f_b, r) = \\frac{1 + f_b}{1 + f_b - r f_b}$$\nThis expression correctly captures the performance improvement. If $r=0$ (no slots filled), $S=1$, indicating no speedup relative to the baseline. If $r=1$ (all slots filled), $S = 1+f_b$, representing the maximum possible speedup where all branch penalties are eliminated.",
            "answer": "$$\n\\boxed{\\frac{1 + f_b}{1 + (1-r)f_b}}\n$$"
        },
        {
            "introduction": "While moving an instruction from before a branch is straightforward, compilers can often be more aggressive. This practice explores a powerful optimization where the delay slot is filled with an instruction from the branch's *fall-through* path. The critical challenge is ensuring correctness, as the moved instruction will now execute even when the branch is taken, a form of speculative execution that requires careful analysis of program behavior .",
            "id": "3623700",
            "problem": "A Reduced Instruction Set Computer (RISC) processor with a classic five-stage pipeline—Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Writeback (WB)—implements one branch delay slot. Under this Instruction Set Architecture (ISA), the instruction immediately following a branch always executes to completion regardless of whether the branch is taken or not; that is, the instruction at $\\mathrm{PC}+4$ is committed in program order prior to control transfer. Branch resolution occurs in the EX stage, and exceptions are precise: architectural state reflects the sequence of committed instructions exactly as in the sequential specification. Arithmetic instructions in this ISA do not raise exceptions, while memory stores and loads can raise exceptions and have externally visible side effects.\n\nConsider the following assembly snippet that uses branch folding (fall-through), where the fall-through block begins after the branch. The labels `L1` and `L2` mark the targets of the taken branch and the point of reconvergence, respectively; registers $r_z$ denotes the architectural zero register, and $r_i$ denotes a general-purpose register $i$:\n- `beq r_1, r_z, L1`    ; branch to `L1` if $r_1 = 0$ (currently has a delay `nop`)\n- `nop`                           ; delay slot currently unfilled\n- `mul r_3, r_3, r_4`           ; first instruction of fall-through block (no exceptions)\n- `sw r_3, 0(r_5)`              ; store result to memory (may raise exception or side effect)\n- `j L2`               ; jump to reconvergence\n- `L1: mov r_3, r_6`            ; taken-path: overwrite $r_3$ before any use\n- `L2: add r_9, r_3, r_7`       ; reconverged use of $r_3$\n\nA compiler optimization pass proposes filling the delay slot by moving the first instruction of the fall-through block (`mul r_3, r_3, r_4`) into the delay slot, yielding:\n- `beq r_1, r_z, L1`\n- `mul r_3, r_3, r_4`           ; now in delay slot\n- `sw r_3, 0(r_5)`\n- `j L2`\n- `L1: mov r_3, r_6`\n- `L2: add r_9, r_3, r_7`\n\nAssume the following:\n- The multiply `mul` has no exceptions or externally visible side effects.\n- The store `sw` has externally visible side effects and may raise exceptions.\n- The zero register $r_z$ always reads as $0$.\n- The value of $r_3$ on the taken path at `L1` is fully overwritten by `mov r_3, r_6` before any use, and the first use of $r_3$ after both paths reconverge is `add r_9, r_3, r_7` at `L2`.\n\nWhich statement best characterizes whether the proposed transformation preserves the observable behavior of the program according to the ISA’s branch delay slot semantics?\n\nA. The transformation is correct because the delay-slot `mul` executes on both outcomes, but on the taken path $r_3$ is overwritten before any use, and `mul` is side-effect-free and non-trapping.\n\nB. The transformation is incorrect because the delay-slot instruction executes only when the branch is not taken, so placing the fall-through `mul` there would skip it on the not-taken path.\n\nC. The transformation is correct only if the hardware branch predictor prefers “not taken,” since prediction determines whether the delay-slot instruction runs.\n\nD. The transformation is incorrect because moving any instruction into a delay slot changes pipeline hazards and therefore violates data dependences regardless of side effects.\n\nE. The transformation is correct if and only if the moved instruction uses registers disjoint from those in the branch condition (here $r_1$ and $r_z$), irrespective of its side effects or exception behavior.",
            "solution": "The problem statement has been validated and found to be a well-defined problem in computer architecture. It is scientifically grounded, well-posed, and objective.\n\nThe core of the problem is to determine the correctness of a compiler optimization known as delay slot filling. The transformation moves an instruction from the fall-through path of a conditional branch into the branch's delay slot. To be correct, this transformation must preserve the observable behavior of the program for all possible execution paths (branch taken and branch not taken). The observable behavior is determined by the final state of registers and memory, and any externally visible side effects or exceptions.\n\nThe ISA specifies that the instruction in the delay slot (the instruction at $\\mathrm{PC}+4$) \"always executes to completion regardless of whether the branch is taken or not\". Let's analyze the program behavior before and after the transformation.\n\n**Original Program Behavior**\n\n1.  **Branch Not Taken (if $r_1 \\neq r_z$):**\n    The processor executes the instructions sequentially.\n    - `beq r_1, r_z, L1`: Condition is false.\n    - `nop`: Executes in the delay slot. Has no effect.\n    - `mul r_3, r_3, r_4`: Updates register $r_3$.\n    - `sw r_3, 0(r_5)`: Stores the new value of $r_3$ to memory.\n    - `j L2`: Jumps to `L2`.\n    - `add r_9, r_3, r_7`: Uses the value of $r_3$ computed by the `mul` instruction.\n    The sequence of operations affecting the program state is: `mul`, then `sw`, then `add`.\n\n2.  **Branch Taken (if $r_1 = r_z$):**\n    The branch to `L1` is taken, but the delay slot instruction executes first.\n    - `beq r_1, r_z, L1`: Condition is true.\n    - `nop`: Executes in the delay slot. Has no effect.\n    - After the `nop`, control transfers to `L1`. The `mul` and `sw` instructions are skipped.\n    - `mov r_3, r_6`: Overwrites register $r_3$.\n    - `add r_9, r_3, r_7`: Uses the value of $r_3$ from the `mov` instruction.\n    The sequence of operations affecting the program state is: `mov`, then `add`.\n\n**Transformed Program Behavior**\n\nThe `mul r_3, r_3, r_4` instruction is moved into the delay slot.\n\n1.  **Branch Not Taken (if $r_1 \\neq r_z$):**\n    The processor executes the instructions sequentially. The delay slot `mul` is part of this sequence.\n    - `beq r_1, r_z, L1`: Condition is false.\n    - `mul r_3, r_3, r_4`: Executes in the delay slot. Updates register $r_3$.\n    - `sw r_3, 0(r_5)`: Stores the new value of $r_3$ to memory.\n    - `j L2`: Jumps to `L2`.\n    - `add r_9, r_3, r_7`: Uses the value of $r_3$ computed by the `mul` instruction.\n    This behavior is identical to the original program's not-taken path.\n\n2.  **Branch Taken (if $r_1 = r_z$):**\n    The branch to `L1` is taken, and the delay slot instruction (`mul`) executes.\n    - `beq r_1, r_z, L1`: Condition is true.\n    - `mul r_3, r_3, r_4`: Executes in the delay slot, updating $r_3$.\n    - After the `mul`, control transfers to `L1`.\n    - `mov r_3, r_6`: Overwrites register $r_3$. The value computed by `mul` is discarded.\n    - `add r_9, r_3, r_7`: Uses the value of $r_3$ from the `mov` instruction.\n    The crucial observation is that although `mul` is executed, its effect on $r_3$ is nullified by the subsequent `mov` before $r_3$ is ever used. The problem statement guarantees this (\"value of $r_3$ on the taken path... is fully overwritten... before any use\"). Additionally, the problem states that `mul` has no exceptions or side effects. Therefore, its execution on this path has no observable impact on the final program state. The final register values are identical to the original program's taken path.\n\n**Conclusion on Transformation**\nSince the observable program behavior is identical for both the taken and not-taken paths, the transformation is correct. This type of optimization is valid under three conditions, all of which are met here:\n1. The moved instruction is executed on the fall-through path in the original program.\n2. The moved instruction has no side effects or exceptions that would alter the program state on the taken path.\n3. Any modification to the register state by the moved instruction on the taken path is undone or irrelevant before the next use of that register.\n\n**Option-by-Option Analysis**\n\nA. The transformation is correct because the delay-slot `mul` executes on both outcomes, but on the taken path $r_3$ is overwritten before any use, and `mul` is side-effect-free and non-trapping.\nThis statement accurately summarises our derivation. It correctly identifies the three key requirements for this optimization to be valid: the delay slot instruction executes on both paths, its architectural effect on the taken path is nullified by a subsequent instruction, and it does not introduce any other incorrect observable behavior (side effects or exceptions).\n**Verdict: Correct**\n\nB. The transformation is incorrect because the delay-slot instruction executes only when the branch is not taken, so placing the fall-through `mul` there would skip it on the not-taken path.\nThis is factually wrong. It misinterprets the fundamental semantics of the specified branch delay slot. The problem explicitly states a delay slot of this type \"always executes to completion regardless of whether the branch is taken or not\".\n**Verdict: Incorrect**\n\nC. The transformation is correct only if the hardware branch predictor prefers “not taken,” since prediction determines whether the delay-slot instruction runs.\nThis is incorrect. Branch prediction is a microarchitectural technique to improve performance by guessing the branch outcome. The architectural correctness of a program, however, depends on the ISA's-defined semantics, not the predictor's behavior. The ISA mandates that the delay slot instruction executes; the processor must ensure this is the final committed behavior, even if it has to flush a wrong-path speculation.\n**Verdict: Incorrect**\n\nD. The transformation is incorrect because moving any instruction into a delay slot changes pipeline hazards and therefore violates data dependences regardless of side effects.\nThis is an overly strong and incorrect generalization. The entire purpose of compiler optimizations like delay slot filling is to manage and resolve pipeline hazards and dependencies in a way that improves performance while preserving program semantics. It does not inherently violate them. In this case, the data dependencies are correctly preserved.\n**Verdict: Incorrect**\n\nE. The transformation is correct if and only if the moved instruction uses registers disjoint from those in the branch condition (here $r_1$ and $r_z$), irrespective of its side effects or exception behavior.\nThis statement is flawed. While the register disjointness is a good practice, it's not the core of the issue here. More importantly, the claim that the transformation is correct \"irrespective of its side effects or exception behavior\" is fundamentally wrong. If the `mul` instruction could cause an exception or had a side effect (like writing to memory), executing it on the taken path would introduce an observable behavior that was not present in the original program, thus making the transformation incorrect. The absence of side effects and exceptions is a critical condition for this optimization.\n**Verdict: Incorrect**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Filling a delay slot solves a control hazard, but the moved instruction does not exist in a vacuum; it must still obey all the rules of a pipelined datapath. This final exercise examines the crucial interaction between the branch delay mechanism and data hazards. You will trace instructions through a pipeline to see how a Read-After-Write (RAW) dependency is handled when it involves an instruction in a delay slot, highlighting the role of data forwarding in achieving true performance gains .",
            "id": "3632106",
            "problem": "A processor implements a classic 5-stage pipeline with the following stages: Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). Each stage takes exactly $1$ cycle. The register file writes occur in the first half of the WB cycle, and reads occur in the second half of the ID cycle. The design includes a single delayed branch slot: the instruction immediately following a branch always executes, regardless of whether the branch is taken. The data path may include full forwarding (bypassing) that can feed ALU operands in $\\text{EX}$ from the previous instructions’ $\\text{EX/MEM}$ or $\\text{MEM/WB}$ pipeline registers.\n\nConsider the sequence of instructions:\n- $I_1$: `ADD R1, R2, R3`\n- $I_2$: `BR label`\n- $I_3$: `SUB R4, R1, R5` placed in the delayed branch slot (i.e., $I_3$ is the instruction immediately following $I_2$).\n\nUsing the fundamental definitions of data hazards:\n- Read After Write (RAW): an instruction $I_j$ reads a location that a prior instruction $I_i$ writes, and $I_j$ reads before $I_i$ completes its write.\n- Write After Read (WAR): an instruction $I_j$ writes a location that a prior instruction $I_i$ reads, and $I_j$ writes before $I_i$ completes its read.\n- Write After Write (WAW): an instruction $I_j$ writes a location that a prior instruction $I_i$ writes, and $I_j$ writes before $I_i$ completes its write,\n\ndetermine which of the following statements are correct under the pipeline, timing, and delayed branch assumptions above.\n\nA. There is a RAW dependence from $I_1$ to $I_3$, but with full forwarding into $\\text{EX}$, $I_3$ can consume the value of $R_1$ without any stall, even though $I_2$ is a branch between them.\n\nB. If forwarding is unavailable, a single-cycle stall is required to ensure $I_3$ reads $R_1$ after $I_1$ writes it back; alternatively, scheduling an independent instruction into the delayed branch slot avoids the stall.\n\nC. Because a branch lies between $I_1$ and $I_3$, the dependence is transformed into a WAR hazard, which can be ignored for in-order pipelines.\n\nD. Reordering $I_3$ to execute before $I_1$ within the delayed slot preserves program semantics because $R_1$ is only a source operand in $I_3$.\n\nE. With the register file write-first/read-second timing alone (no forwarding), $I_3$ reads the correct $R_1$ value without any stall.",
            "solution": "The user wants me to solve the problem.\n\n***\n\n### Step 1: Extract Givens\n\n-   **Pipeline Architecture**: Classic $5$-stage pipeline: Instruction Fetch (IF), Instruction Decode and Register Read (ID), Execute (EX), Memory Access (MEM), and Write Back (WB).\n-   **Stage Timing**: Each stage takes $1$ cycle.\n-   **Register File Timing**: Writes occur in the first half of the WB cycle. Reads occur in the second half of the ID cycle.\n-   **Branching**: Single delayed branch slot. The instruction immediately following a branch is always executed.\n-   **Forwarding**: The datapath may include full forwarding from the $\\text{EX/MEM}$ or $\\text{MEM/WB}$ pipeline registers to the ALU operands in the $\\text{EX}$ stage.\n-   **Instruction Sequence**:\n    -   $I_1$: `ADD R1, R2, R3` (Destination $R_1$, sources $R_2, R_3$)\n    -   $I_2$: `BR label` (Branch instruction)\n    -   $I_3$: `SUB R4, R1, R5` (Destination $R_4$, sources $R_1, R_5$)\n-   **Execution Context**: $I_3$ is located in the delayed branch slot of $I_2$.\n-   **Hazard Definitions**: Standard definitions for Read After Write (RAW), Write After Read (WAR), and Write After Write (WAW) are provided.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is firmly based on fundamental principles of computer organization and architecture. The $5$-stage RISC pipeline, data hazards, forwarding (bypassing), and delayed branches are all standard, well-established concepts.\n-   **Well-Posed**: The problem is clearly defined. It provides a specific pipeline structure, timing rules, and an instruction sequence. The task is to analyze the interactions within this system, which allows for a unique and stable solution.\n-   **Objective**: The language is precise and unambiguous. Standard acronyms and terminology from the field of computer architecture are used correctly.\n\nThe problem statement is self-contained, internally consistent, and scientifically sound. It does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A full solution will be derived.\n\n***\n\n### Derivation\n\n#### 1. Data Dependency Analysis\n\nFirst, let's identify the data dependencies between the given instructions.\n-   $I_1$: `ADD R1, R2, R3` writes to register $R_1$.\n-   $I_3$: `SUB R4, R1, R5` reads from register $R_1$.\n\nSince $I_3$ executes after $I_1$ and reads a register ($R_1$) that $I_1$ writes to, there is a true data dependence, also known as a Read-After-Write (RAW) dependence, from $I_1$ to $I_3$. The correct execution of the program requires that $I_3$ uses the new value of $R_1$ produced by $I_1$. In a pipelined processor, this dependence can lead to a RAW hazard if the pipeline timing causes $I_3$ to read $R_1$ before $I_1$ has written its result.\n\n#### 2. Pipeline Execution Analysis\n\nThe instructions are executed in the sequence $I_1, I_2, I_3$ because $I_3$ is in the delayed branch slot of $I_2$. Let's map their execution on the $5$-stage pipeline.\n\n| Cycle | $1$  | $2$  | $3$  | $4$   | $5$   | $6$   | $7$   |\n| :---: | :--: | :--: | :--: | :---: | :---: | :---: | :---: |\n| $I_1$ | IF   | ID   | EX   | MEM   | WB    |       |       |\n| $I_2$ |      | IF   | ID   | EX    | MEM   | WB    |       |\n| $I_3$ |      |      | IF   | ID    | EX    | MEM   | WB    |\n\n-   $I_1$ calculates the value for $R_1$ in its $\\text{EX}$ stage (cycle $3$) and writes this value back to the register file in its $\\text{WB}$ stage (cycle $5$).\n-   $I_3$ needs the value of $R_1$ for its computation in the $\\text{EX}$ stage (cycle $5$). To get this value, it performs a register read in its $\\text{ID}$ stage (cycle $4$).\n\n#### 3. Analysis of Scenarios\n\nWe will analyze two hardware configurations as prompted by the options: one with full forwarding and one without.\n\n**Scenario 1: With Full Forwarding**\n\nThe problem states that full forwarding can supply an ALU operand in the $\\text{EX}$ stage from the $\\text{EX/MEM}$ or $\\text{MEM/WB}$ pipeline registers.\n-   At the beginning of cycle $5$, instruction $I_3$ enters its $\\text{EX}$ stage and requires the value of $R_1$.\n-   At the same time (during cycle $5$), instruction $I_1$ is in its $\\text{WB}$ stage. The result of $I_1$'s computation (from its $\\text{EX}$ stage in cycle $3$) was passed to the $\\text{EX/MEM}$ register for cycle $4$, and is now in the $\\text{MEM/WB}$ register for cycle $5$.\n-   The forwarding logic can detect this situation: the source operand $R_1$ for $I_3$ in $\\text{EX}$ matches the destination register of $I_1$ in $\\text{WB}$.\n-   Therefore, the value from the $\\text{MEM/WB}$ pipeline register can be forwarded directly to the input of the ALU for $I_3$.\n-   This resolves the RAW hazard without requiring any stall cycles.\n\n**Scenario 2: Without Forwarding**\n\nIf no forwarding logic exists, the value must be retrieved from the register file.\n-   $I_3$ reads its source operands from the register file in the second half of its $\\text{ID}$ stage, which is cycle $4$.\n-   $I_1$ writes its result to the register file in the first half of its $\\text{WB}$ stage, which is cycle $5$.\n-   Since the read by $I_3$ (cycle $4$) happens before the write by $I_1$ (cycle $5$), $I_3$ would read the old, stale value of $R_1$. This is a RAW hazard that must be resolved.\n-   The hazard can be resolved by stalling the pipeline. Hazard detection logic in the $\\text{ID}$ stage will detect that $I_3$ needs a result from $I_1$, which is two stages ahead. The pipeline must be stalled.\n-   Let's trace the stall:\n    | Cycle | $1$    | $2$    | $3$    | $4$ (Hazard) | $5$ (Stall)                             | $6$           | $7$   |\n    | :---: | :--: | :--: | :--: | :----------: | :-------------------------------------- | :------------ | :---: |\n    | $I_1$   | IF   | ID   | EX   | MEM          | WB (writes $R_1$ in 1st half)             |               |       |\n    | $I_2$   |      | IF   | ID   | EX           | MEM                                     | WB            |       |\n    | $I_3$   |      |      | IF   | ID           | ID (stalled; reads $R_1$ in 2nd half) | EX            | MEM   |\n    | bubble|      |      |      |              | EX                                      | MEM           | WB    |\n-   In cycle $4$, the hazard is detected in $I_3$'s $\\text{ID}$ stage.\n-   The control logic stalls $I_3$ in the $\\text{ID}$ stage for one cycle (cycle $5$) and inserts a bubble (a NOP) into the $\\text{EX}$ stage.\n-   In the first half of cycle $5$, $I_1$ performs its write-back to $R_1$.\n-   In the second half of cycle $5$, $I_3$, which is still in its $\\text{ID}$ stage, performs its register read. It now successfully reads the new value of $R_1$.\n-   In cycle $6$, $I_3$ can proceed to its $\\text{EX}$ stage with the correct data.\n-   Thus, a single stall cycle is necessary and sufficient to resolve the hazard, thanks to the split-cycle register file access (write in the first half, read in the second half of a cycle).\n\n### Option-by-Option Analysis\n\n**A. There is a RAW dependence from $I_1$ to $I_3$, but with full forwarding into $\\text{EX}$, $I_3$ can consume the value of $R_1$ without any stall, even though $I_2$ is a branch between them.**\n- The existence of a RAW dependence from $I_1$ to $I_3$ on register $R_1$ is established.\n- As shown in \"Scenario 1\", full forwarding from the $\\text{MEM/WB}$ pipeline register to the $\\text{EX}$ stage ALU input allows $I_3$ to receive the correct value of $R_1$ without any stalls.\n- The fact that $I_2$ is a branch is irrelevant to the data hazard between $I_1$ and $I_3$, because the delayed slot ensures $I_3$ is fetched and follows $I_2$ in the pipeline sequence.\n- **Verdict:** **Correct**.\n\n**B. If forwarding is unavailable, a single-cycle stall is required to ensure $I_3$ reads $R_1$ after $I_1$ writes it back; alternatively, scheduling an independent instruction into the delayed branch slot avoids the stall.**\n- The first part of the statement claims a single-cycle stall is required without forwarding. Our analysis in \"Scenario 2\" confirms that one stall cycle is both necessary and sufficient.\n- The second part suggests an alternative: scheduling an independent instruction. If the instruction in the delayed branch slot ($I_3$) did not have a data dependency on the preceding instructions (specifically, if it did not read $R_1$), there would be no RAW hazard and therefore no need for a stall. This is a standard compiler optimization technique.\n- **Verdict:** **Correct**.\n\n**C. Because a branch lies between $I_1$ and $I_3$, the dependence is transformed into a WAR hazard, which can be ignored for in-order pipelines.**\n- The dependence is determined by the pattern of reads and writes to a shared register. $I_1$ writes $R_1$ and a later instruction $I_3$ reads $R_1$. This is, by definition, a RAW (Read-After-Write) dependence.\n- The type of an intervening instruction ($I_2$ being a branch) does not change the nature of the data dependence. The statement that the dependence is \"transformed into a WAR hazard\" is fundamentally incorrect.\n- **Verdict:** **Incorrect**.\n\n**D. Reordering $I_3$ to execute before $I_1$ within the delayed slot preserves program semantics because $R_1$ is only a source operand in $I_3$.**\n- The phrase \"reordering $I_3$ to execute before $I_1$ within the delayed slot\" is logically inconsistent. The delayed slot is a specific position in the instruction stream *after* the branch instruction $I_2$, which in turn is after $I_1$.\n- If we interpret this as swapping $I_1$ and $I_3$ in the original code, the program logic would be broken. Original logic: $R_1 \\leftarrow \\text{value}; \\dots ; R_4 \\leftarrow R_1 - R_5$. Swapped logic: $R_4 \\leftarrow R_1 - R_5; \\dots ; R_1 \\leftarrow \\text{value}$. The `SUB` instruction would use the old value of $R_1$, not the one computed by the `ADD` instruction, thus changing the program's result. Program semantics are not preserved.\n- **Verdict:** **Incorrect**.\n\n**E. With the register file write-first/read-second timing alone (no forwarding), $I_3$ reads the correct $R_1$ value without any stall.**\n- As shown in the pipeline diagram and \"Scenario 2\" analysis, without a stall, $I_3$ performs its read in cycle $4$ and $I_1$ performs its write in cycle $5$. The read occurs a full cycle before the write.\n- The \"write-first/read-second\" timing only helps if the WB stage of the producing instruction overlaps with the ID stage of the consuming instruction in the same cycle. This requires a stall for the $I_i$ vs. $I_{i+2}$ dependency pattern seen here.\n- Therefore, without forwarding, a stall is mandatory.\n- **Verdict:** **Incorrect**.",
            "answer": "$$\\boxed{AB}$$"
        }
    ]
}