{
    "hands_on_practices": [
        {
            "introduction": "A core motivation for pipelining is to increase instruction throughput by raising the clock frequency. Pipeline registers are the key enabler for this, but they also introduce their own timing overheads. This exercise  challenges you to quantify the fundamental trade-off in pipeline design: by partitioning a slow pipeline stage, you can increase the clock speed, but at the cost of a deeper pipeline that can worsen penalties for control hazards like taken branches.",
            "id": "3665312",
            "problem": "A five-stage synchronous pipeline implements Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). Each pipeline stage is separated by a bank of edge-triggered registers. The pipeline registers have a clock-to-output delay $t_{\\text{cq}}$, a setup time $t_{\\text{setup}}$, and an effective clock skew $t_{\\text{skew}}$, all of which contribute to the minimum feasible clock period. The Execute stage is currently the longest logic stage, and branch decisions are resolved at the end of the Execute stage. The machine uses a predict-not-taken policy and flushes on a taken branch; there are no delay slots and no early branch resolution.\n\nMeasured stage logic delays are:\n- IF: $0.68\\,\\text{ns}$,\n- ID: $0.90\\,\\text{ns}$,\n- EX: $2.40\\,\\text{ns}$,\n- MEM: $1.35\\,\\text{ns}$,\n- WB: $0.52\\,\\text{ns}$.\n\nPipeline register overheads are:\n- $t_{\\text{cq}} = 0.07\\,\\text{ns}$,\n- $t_{\\text{setup}} = 0.09\\,\\text{ns}$,\n- $t_{\\text{skew}} = 0.02\\,\\text{ns}$.\n\nSuppose the Execute stage is partitioned by inserting one additional pipeline register, creating two substages EXa and EXb. Assume a feasible retiming leads to EXa having logic delay $1.35\\,\\text{ns}$ and EXb having logic delay $0.95\\,\\text{ns}$, and that the branch decision continues to be produced at the end of EX (or EXb, in the partitioned design).\n\nUsing only first principles of synchronous timing and pipeline control hazards, compute:\n1. The theoretical clock period improvement factor $\\rho$, defined as the ratio $T_{\\text{old}} / T_{\\text{new}}$, where $T_{\\text{old}}$ is the original minimum clock period and $T_{\\text{new}}$ is the minimum clock period after the Execute stage partitioning.\n2. The increase in taken-branch penalty, in cycles, caused by moving branch resolution from the end of EX to the end of EXb.\n\nRound the improvement factor $\\rho$ to four significant figures. Report your final answer as two dimensionless numbers in the order $\\rho$ and the penalty increase, with no units.",
            "solution": "The problem asks for the computation of two performance metrics related to a pipelined processor: the clock period improvement factor after pipeline balancing and the increase in the taken-branch penalty resulting from the deeper pipeline. The solution requires applying first principles of synchronous pipeline timing and control hazard management.\n\nThe minimum clock period, $T_{clk}$, of a synchronous pipeline is constrained by the delay of its longest stage. This delay comprises the combinational logic delay of the stage ($t_{\\text{logic}}$) and the overhead associated with the pipeline registers ($t_{\\text{overhead}}$). The overhead is the sum of the clock-to-output delay ($t_{\\text{cq}}$), the setup time ($t_{\\text{setup}}$), and the clock skew ($t_{\\text{skew}}$). The minimum clock period must satisfy the inequality:\n$$T_{clk} \\ge t_{\\text{logic,max}} + t_{\\text{cq}} + t_{\\text{setup}} + t_{\\text{skew}}$$\nwhere $t_{\\text{logic,max}}$ is the maximum logic delay across all pipeline stages.\n\nFirst, we calculate the total pipeline register overhead, $t_{\\text{overhead}}$, which is constant for all stages.\nGiven values are $t_{\\text{cq}} = 0.07\\,\\text{ns}$, $t_{\\text{setup}} = 0.09\\,\\text{ns}$, and $t_{\\text{skew}} = 0.02\\,\\text{ns}$.\n$$t_{\\text{overhead}} = t_{\\text{cq}} + t_{\\text{setup}} + t_{\\text{skew}} = 0.07\\,\\text{ns} + 0.09\\,\\text{ns} + 0.02\\,\\text{ns} = 0.18\\,\\text{ns}$$\n\n**Part 1: Clock Period Improvement Factor**\n\nWe first determine the minimum clock period for the original five-stage pipeline, $T_{\\text{old}}$. The logic delays for the stages IF, ID, EX, MEM, and WB are given as $0.68\\,\\text{ns}$, $0.90\\,\\text{ns}$, $2.40\\,\\text{ns}$, $1.35\\,\\text{ns}$, and $0.52\\,\\text{ns}$, respectively. The maximum of these is the delay of the Execute (EX) stage.\n$$t_{\\text{logic,old,max}} = \\max(\\{0.68, 0.90, 2.40, 1.35, 0.52\\})\\,\\text{ns} = 2.40\\,\\text{ns}$$\nThe minimum clock period for the original pipeline is therefore:\n$$T_{\\text{old}} = t_{\\text{logic,old,max}} + t_{\\text{overhead}} = 2.40\\,\\text{ns} + 0.18\\,\\text{ns} = 2.58\\,\\text{ns}$$\n\nNext, we determine the minimum clock period for the new six-stage pipeline, $T_{\\text{new}}$. The Execute stage is partitioned into two substages, EXa and EXb, with logic delays $1.35\\,\\text{ns}$ and $0.95\\,\\text{ns}$, respectively. The new set of stage logic delays is for IF, ID, EXa, EXb, MEM, and WB.\nThe delays are $0.68\\,\\text{ns}$, $0.90\\,\\text{ns}$, $1.35\\,\\text{ns}$, $0.95\\,\\text{ns}$, $1.35\\,\\text{ns}$, and $0.52\\,\\text{ns}$. The maximum of these is:\n$$t_{\\text{logic,new,max}} = \\max(\\{0.68, 0.90, 1.35, 0.95, 1.35, 0.52\\})\\,\\text{ns} = 1.35\\,\\text{ns}$$\nThis maximum delay occurs in both the EXa and MEM stages. The minimum clock period for the new pipeline is:\n$$T_{\\text{new}} = t_{\\text{logic,new,max}} + t_{\\text{overhead}} = 1.35\\,\\text{ns} + 0.18\\,\\text{ns} = 1.53\\,\\text{ns}$$\n\nThe clock period improvement factor, $\\rho$, is the ratio $T_{\\text{old}} / T_{\\text{new}}$.\n$$\\rho = \\frac{T_{\\text{old}}}{T_{\\text{new}}} = \\frac{2.58\\,\\text{ns}}{1.53\\,\\text{ns}} \\approx 1.6862745...$$\nRounding to four significant figures as required, we get:\n$$\\rho \\approx 1.686$$\n\n**Part 2: Increase in Taken-Branch Penalty**\n\nThe taken-branch penalty in a pipeline with a predict-not-taken policy is the number of clock cycles lost when a branch is mispredicted (i.e., it is taken). This penalty is equal to the number of instructions on the incorrect execution path that have entered the pipeline before the branch outcome is known and can be acted upon.\n\nLet the pipeline stages be numbered starting from $1$ for the fetch stage. If a branch instruction's outcome and target address are resolved at the end of stage $k$, then by the time the branch instruction has completed stage $k$, $k-1$ subsequent instructions (on the predicted, wrong path) have already been fetched and entered the pipeline. These $k-1$ instructions must be flushed, resulting in a penalty of $k-1$ cycles.\n\nFor the original five-stage pipeline (IF, ID, EX, MEM, WB), the stages are numbered $1, 2, 3, 4, 5$. Branch resolution occurs at the end of the EX stage, which is stage $k_{\\text{old}} = 3$. The penalty is:\n$$P_{\\text{old}} = k_{\\text{old}} - 1 = 3 - 1 = 2 \\text{ cycles}$$\n\nFor the modified six-stage pipeline (IF, ID, EXa, EXb, MEM, WB), the stages are numbered $1, 2, 3, 4, 5, 6$. Branch resolution occurs at the end of the EXb stage, which is stage $k_{\\text{new}} = 4$. The penalty is:\n$$P_{\\text{new}} = k_{\\text{new}} - 1 = 4 - 1 = 3 \\text{ cycles}$$\n\nThe increase in the taken-branch penalty is the difference between the new penalty and the old penalty.\n$$\\Delta P = P_{\\text{new}} - P_{\\text{old}} = 3 - 2 = 1 \\text{ cycle}$$\n\nThe two requested values are the improvement factor $\\rho$ and the penalty increase $\\Delta P$.\n$\\rho = 1.686$\n$\\Delta P = 1$\nThese are reported as a pair of dimensionless numbers.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.686 & 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While pipeline registers improve performance from a timing perspective, they have a tangible physical cost. Each bit stored in a register is a collection of transistors that consume power, and in modern processors with billions of transistors, this power consumption is a first-order design constraint. This practice problem  delves into the physical reality of pipeline registers by asking you to calculate the dynamic power consumption, guided by the principle that power is proportional to switching activity, capacitance, and the square of the voltage ($P \\approx \\alpha C V^2 f$).",
            "id": "3665286",
            "problem": "A five-stage synchronous pipeline has four interstage pipeline registers. Each interstage register contains a datapath and control fields implemented in Complementary Metal-Oxide Semiconductor (CMOS) flip-flops. Assume the following baseline and widened designs and workload properties are scientifically realistic and self-consistent:\n\n- Baseline design:\n  - Datapath width: $32$ bits.\n  - Control field width: $18$ bits.\n  - Effective switched capacitance per datapath bit due to data-dependent transitions: $2.0\\,\\mathrm{fF}$.\n  - Effective switched capacitance per control bit due to data-dependent transitions: $1.5\\,\\mathrm{fF}$.\n  - Effective switched capacitance per flip-flop clock input (per bit): $10\\,\\mathrm{fF}$.\n\n- Widened design:\n  - Datapath width: $64$ bits ($32$ lower bits identical in topology to the baseline, plus $32$ upper bits whose longer interconnect increases each upper bit’s effective switched capacitance due to data-dependent transitions to $2.6\\,\\mathrm{fF}$).\n  - Control field width: unchanged ($18$ bits).\n  - Effective switched capacitance per flip-flop clock input (per bit): unchanged ($10\\,\\mathrm{fF}$).\n\n- Workload and microarchitectural activity:\n  - Clock frequency: $1.2\\,\\mathrm{GHz}$.\n  - Supply voltage: $0.9\\,\\mathrm{V}$.\n  - Fraction of cycles that are active (no stall, clock ungated): $0.85$.\n  - In active cycles, each datapath bit in the lower $32$ bits toggles with probability $0.25$ per cycle.\n  - In active cycles, each control bit toggles with probability $0.10$ per cycle.\n  - In active cycles for the widened design, the upper $32$ datapath bits carry sign-extended $32$-bit values with probability $0.70$ and true $64$-bit values with probability $0.30$. When sign-extended, the upper bits equal the sign bit; the sign bit toggles with probability $0.10$ per active cycle. When true $64$-bit values are present, each upper bit toggles with probability $0.25$ per active cycle.\n\nAssume ideal clock gating that completely stops the flip-flop clock switching during stalled cycles and that short-circuit and leakage components are negligible compared to dynamic switching. Starting from the fundamental capacitor energy relation and basic definitions of switching activity, derive an expression for the total dynamic power of all four interstage pipeline registers in each design and compute the ratio of widened-design total dynamic power to baseline-design total dynamic power.\n\nRound your final ratio to four significant figures. The ratio is dimensionless; do not attach any units to your final answer.",
            "solution": "The problem requires the calculation of the ratio of total dynamic power consumption of four interstage pipeline registers in a widened processor design to that of a baseline design.\n\n### Step 1: Extract Givens\n\n**Shared Parameters:**\n- Number of interstage registers: $N_{reg} = 4$.\n- Clock frequency: $f_{clk} = 1.2\\,\\mathrm{GHz} = 1.2 \\times 10^9\\,\\mathrm{Hz}$.\n- Supply voltage: $V_{dd} = 0.9\\,\\mathrm{V}$.\n- Fraction of active cycles: $\\gamma_{active} = 0.85$.\n- Control field width: $W_{ctrl} = 18$ bits.\n- Effective switched capacitance per control bit (data-dependent): $C_{ctrl} = 1.5\\,\\mathrm{fF}$.\n- Activity factor for control bits in active cycles: $\\alpha_{ctrl} = 0.10$.\n- Effective switched capacitance per flip-flop clock input: $C_{clk} = 10\\,\\mathrm{fF}$.\n\n**Baseline Design:**\n- Datapath width: $W_{data, base} = 32$ bits.\n- Effective switched capacitance per datapath bit (data-dependent): $C_{data} = 2.0\\,\\mathrm{fF}$.\n- Activity factor for datapath bits in active cycles: $\\alpha_{data} = 0.25$.\n\n**Widened Design:**\n- Datapath width: $W_{data, wide} = 64$ bits.\n  - Lower $32$ bits: $W_{data, lo} = 32$. Properties identical to baseline datapath bits.\n  - Upper $32$ bits: $W_{data, hi} = 32$.\n- Effective switched capacitance per upper datapath bit (data-dependent): $C_{data, hi} = 2.6\\,\\mathrm{fF}$.\n- Workload characteristics for upper $32$ bits:\n  - Probability of sign-extended value: $p_{sign\\_ext} = 0.70$.\n  - Probability of true $64$-bit value: $p_{true64} = 0.30$.\n  - Toggling probability of the sign bit: $\\alpha_{sign} = 0.10$.\n  - Toggling probability of an upper bit for true $64$-bit values: $\\alpha_{hi, true64} = 0.25$.\n\n### Step 2: Derivation of the Solution\n\nThe dynamic power consumption of a single CMOS gate is given by $P_{dyn} = \\alpha C V_{dd}^2 f_{clk}$, where $\\alpha$ is the activity factor (the probability that the gate's output toggles in a clock cycle), $C$ is the load capacitance, $V_{dd}$ is the supply voltage, and $f_{clk}$ is the clock frequency.\n\nThe total dynamic power for all four registers is the sum of power consumed by data-dependent switching and clock switching, scaled by the number of registers and the fraction of active cycles. The problem states that clock gating is ideal, meaning power is only consumed during active cycles.\n\nThe total power consumption, $P_{total}$, can be expressed as:\n$$P_{total} = N_{reg} \\times \\gamma_{active} \\times (P_{data\\_sw} + P_{ctrl\\_sw} + P_{clk\\_sw})$$\nwhere the power components are calculated per register during an active cycle.\n\nThe power components for a single register are:\n- Data-dependent switching power for datapath bits: $P_{data\\_sw}$\n- Data-dependent switching power for control bits: $P_{ctrl\\_sw}$\n- Clock switching power for all flip-flops: $P_{clk\\_sw}$\n\nThe clock input of a flip-flop switches on every active clock cycle. Therefore, the activity factor for the clock input, $\\alpha_{clk}$, is $1$.\n\nThe problem asks for the ratio of the total dynamic power of the widened design ($P_{total, wide}$) to that of the baseline design ($P_{total, base}$).\n$$ \\text{Ratio} = \\frac{P_{total, wide}}{P_{total, base}} = \\frac{N_{reg} \\times \\gamma_{active} \\times (P_{data\\_sw, wide} + P_{ctrl\\_sw, wide} + P_{clk\\_sw, wide})}{N_{reg} \\times \\gamma_{active} \\times (P_{data\\_sw, base} + P_{ctrl\\_sw, base} + P_{clk\\_sw, base})} $$\nThe common terms $N_{reg}$ and $\\gamma_{active}$ cancel out. The power for each component is proportional to $V_{dd}^2 f_{clk}$, which also cancels. The ratio thus simplifies to the ratio of the total effective switched capacitance per register in an active cycle ($C_{eff}$) for each design.\n$$ \\text{Ratio} = \\frac{C_{eff, wide}}{C_{eff, base}} $$\n\nLet's compute the effective switched capacitance for each design.\n\n**Baseline Design ($C_{eff, base}$):**\nThe total effective switched capacitance is the sum of contributions from datapath switching, control switching, and clock switching.\n$$ C_{eff, base} = (W_{data, base} \\alpha_{data} C_{data}) + (W_{ctrl} \\alpha_{ctrl} C_{ctrl}) + ((W_{data, base} + W_{ctrl}) \\alpha_{clk} C_{clk}) $$\nSubstituting the given values:\n- Datapath switching: $32 \\times 0.25 \\times 2.0\\,\\mathrm{fF} = 16.0\\,\\mathrm{fF}$.\n- Control switching: $18 \\times 0.10 \\times 1.5\\,\\mathrm{fF} = 2.7\\,\\mathrm{fF}$.\n- Clock switching (for $32+18 = 50$ bits, with $\\alpha_{clk}=1$): $50 \\times 1 \\times 10\\,\\mathrm{fF} = 500.0\\,\\mathrm{fF}$.\n$$ C_{eff, base} = 16.0\\,\\mathrm{fF} + 2.7\\,\\mathrm{fF} + 500.0\\,\\mathrm{fF} = 518.7\\,\\mathrm{fF} $$\n\n**Widened Design ($C_{eff, wide}$):**\nFirst, we determine the effective activity factor for the upper $32$ datapath bits, $\\alpha_{data, hi}$. This is a weighted average based on the workload.\nWhen sign-extended ($70\\%$ of the time), all upper $32$ bits take the value of the sign bit. Thus, they all toggle if and only if the sign bit toggles. The activity factor for each upper bit in this case is $\\alpha_{sign} = 0.10$.\nWhen carrying true $64$-bit values ($30\\%$ of the time), each upper bit toggles with probability $\\alpha_{hi, true64} = 0.25$.\n$$ \\alpha_{data, hi} = p_{sign\\_ext} \\times \\alpha_{sign} + p_{true64} \\times \\alpha_{hi, true64} $$\n$$ \\alpha_{data, hi} = (0.70 \\times 0.10) + (0.30 \\times 0.25) = 0.07 + 0.075 = 0.145 $$\n\nNow, we compute the total effective switched capacitance for the widened design.\n$$ C_{eff, wide} = (\\text{Data}_{lo}) + (\\text{Data}_{hi}) + (\\text{Control}) + (\\text{Clock}) $$\n- Datapath switching (lower $32$ bits): $W_{data, lo} \\alpha_{data} C_{data} = 32 \\times 0.25 \\times 2.0\\,\\mathrm{fF} = 16.0\\,\\mathrm{fF}$.\n- Datapath switching (upper $32$ bits): $W_{data, hi} \\alpha_{data, hi} C_{data, hi} = 32 \\times 0.145 \\times 2.6\\,\\mathrm{fF} = 12.064\\,\\mathrm{fF}$.\n- Control switching (unchanged): $W_{ctrl} \\alpha_{ctrl} C_{ctrl} = 18 \\times 0.10 \\times 1.5\\,\\mathrm{fF} = 2.7\\,\\mathrm{fF}$.\n- Clock switching (for $64+18=82$ bits, with $\\alpha_{clk}=1$): $82 \\times 1 \\times 10\\,\\mathrm{fF} = 820.0\\,\\mathrm{fF}$.\n\n$$ C_{eff, wide} = 16.0\\,\\mathrm{fF} + 12.064\\,\\mathrm{fF} + 2.7\\,\\mathrm{fF} + 820.0\\,\\mathrm{fF} = 850.764\\,\\mathrm{fF} $$\n\n**Final Ratio Calculation:**\nThe ratio of the total dynamic power is the ratio of these effective capacitances.\n$$ \\text{Ratio} = \\frac{C_{eff, wide}}{C_{eff, base}} = \\frac{850.764\\,\\mathrm{fF}}{518.7\\,\\mathrm{fF}} \\approx 1.639992288 $$\nRounding the result to four significant figures gives $1.640$.",
            "answer": "$$\n\\boxed{1.640}\n$$"
        },
        {
            "introduction": "Pipeline registers are not merely passive latches for data; they are active components in the processor's control mechanism. To handle hazards, the control unit must precisely manipulate these registers on a cycle-by-cycle basis to stall parts of the pipeline while allowing others to proceed. This exercise  focuses on the classic load-use data hazard, requiring you to identify the exact control actions—freezing upstream registers and injecting a \"bubble\"—needed to ensure correct execution, thereby deepening your understanding of dynamic pipeline control.",
            "id": "3665309",
            "problem": "A single-issue, in-order, scalar processor implements a classic $5$-stage pipeline: Instruction Fetch (IF), Instruction Decode/Register Fetch (ID), Execute (EX), Memory Access (MEM), and Write Back (WB). The processor uses pipeline registers $IF/ID$, $ID/EX$, $EX/MEM$, and $MEM/WB$, each updated on the rising clock edge, and a Program Counter (PC) that points to the next instruction to fetch. Arithmetic Logic Unit (ALU) operand forwarding is fully implemented from $EX/MEM$ and $MEM/WB$ back to EX inputs, but load data from memory becomes available only at the end of MEM. A No Operation (NOP) is encoded by setting all control signals that would cause state updates to zero.\n\nConsider the following instruction sequence:\n- $I_1$: $LW \\; x2, \\; 0(x1)$\n- $I_2$: $ADD \\; x3, \\; x2, \\; x4$\n- $I_3$: $SUB \\; x5, \\; x6, \\; x7$\n\nAssume $I_1$ enters EX in cycle $t$, $I_2$ is in ID in cycle $t$, and the hazard detection unit in ID determines that $I_2$ has a true data dependence on the value loaded by $I_1$. The goal is to resolve this load-use hazard with exactly a $1$-cycle stall (no more, no less), ensuring that:\n- No incorrect architectural state is committed.\n- The minimum number of pipeline stages are frozen.\n- A single bubble is introduced such that $I_2$ reaches EX only when the loaded value can be provided to the ALU via forwarding.\n\nWhich option precisely specifies how the stall control must act on each pipeline register at cycle $t$ and what must be written into the affected pipeline register(s) to achieve the above behavior?\n\nA. Assert a stall so that $PC$ and $IF/ID$ do not update at the next clock edge (freeze upstream); write control zeros into $ID/EX$ at the next clock edge (insert a NOP bubble into EX); allow $EX/MEM$ and $MEM/WB$ to update normally. After exactly $1$ cycle, deassert the stall so that $I_2$ advances to EX when $I_1$ is in MEM and its loaded data can be forwarded.\n\nB. Assert a stall that freezes $PC$, $IF/ID$, $ID/EX$, $EX/MEM$, and $MEM/WB$ simultaneously for exactly $1$ cycle (global freeze); do not insert any NOP anywhere. Resume normal operation on the next cycle.\n\nC. Do not freeze $PC$ or $IF/ID$; instead, freeze only $ID/EX$ for $1$ cycle and insert the bubble by zeroing control fields in $EX/MEM$ at the next clock edge. Allow $MEM/WB$ to update normally.\n\nD. Freeze only $PC$ for $1$ cycle so that the same instruction is refetched; let $IF/ID$ update with whatever the instruction memory returns; keep $ID/EX$ updating with $I_2$ and do not explicitly insert a NOP into any pipeline register.\n\nE. Freeze $PC$, $IF/ID$, and $ID/EX$ for $1$ cycle; do not write a NOP into any pipeline register; allow $EX/MEM$ and $MEM/WB$ to update normally so that only downstream instructions progress during the stall.",
            "solution": "The problem statement describes a canonical load-use hazard in a standard $5$-stage RISC-style pipeline.\nLet's analyze the timing of the data dependency:\n1.  Instruction $I_1$ ($LW$) is in its EX stage during cycle $t$. It calculates the memory address.\n2.  In cycle $t+1$, $I_1$ will be in its MEM stage, where it reads data from memory.\n3.  The problem states that \"load data from memory becomes available only at the end of MEM\". This means at the rising clock edge that ends cycle $t+1$, the loaded data is latched into the $MEM/WB$ pipeline register.\n4.  Therefore, the loaded data is available for forwarding from the $MEM/WB$ register to the EX stage beginning at a cycle where $I_1$ is in the WB stage. This would be cycle $t+2$.\n5.  Instruction $I_2$ ($ADD$) needs the value of register $x2$. To use the forwarded value, $I_2$ must be in its EX stage no earlier than cycle $t+2$.\n6.  Without a stall, $I_2$ would enter the EX stage in cycle $t+1$. This is too early, as the data is not yet available.\n7.  To delay $I_2$ by one cycle, it must be held in the ID stage during cycle $t+1$, and a \"bubble\" (a NOP) must be inserted into the EX stage for cycle $t+1$. $I_2$ can then proceed to the EX stage in cycle $t+2$, where it can receive the forwarded data from $I_1$ (which is now in its WB stage, with its result in the $MEM/WB$ register).\n\nThe goal is to resolve a load-use hazard with a $1$-cycle stall. This is achieved by manipulating the pipeline control at the clock edge ending cycle $t$.\n\n-   **Pipeline State at Cycle $t$:**\n    -   IF: Fetching $I_3$.\n    -   ID: Decoding $I_2$, hazard detected.\n    -   EX: Executing $I_1$.\n    -   MEM: $I_0$ (instruction before $I_1$).\n    -   WB: $I_{-1}$ (instruction before $I_0$).\n\n-   **Desired Pipeline State at Cycle $t+1$ (after the stall and bubble insertion):**\n    -   IF: Re-fetching $I_3$.\n    -   ID: Re-decoding $I_2$.\n    -   EX: Bubble (NOP).\n    -   MEM: $I_1$.\n    -   WB: $I_0$.\n\nTo transition from the state at cycle $t$ to the desired state at cycle $t+1$, the control logic must perform a specific set of actions at the rising clock edge at the end of cycle $t$:\n\n1.  **Downstream Pipeline (post-hazard):** Instructions $I_1$ and $I_0$, which are already past the ID stage, must continue to flow down the pipeline. This is crucial for efficiency and meets the \"minimum number of pipeline stages are frozen\" constraint.\n    -   The state of $I_1$ in the EX stage is latched into the $EX/MEM$ register.\n    -   The state of $I_0$ in the MEM stage is latched into the $MEM/WB$ register.\n    -   Therefore, $EX/MEM$ and $MEM/WB$ must update normally.\n\n2.  **Stalled Instruction and Upstream Pipeline:** The hazardous instruction $I_2$ and any instruction behind it must be paused.\n    -   To keep $I_2$ in the ID stage for cycle $t+1$, the $IF/ID$ register, which contains $I_2$ during cycle $t$, must not be overwritten by $I_3$ (which was fetched during cycle $t$). This requires **freezing the $IF/ID$ register** by disabling its write signal.\n    -   Because the $IF/ID$ register is not accepting new data, the instruction $I_3$ fetched in cycle $t$ must be re-fetched in cycle $t+1$. This requires the Program Counter (PC) to hold its current value (the address of $I_3$). Thus, the **PC must also be frozen** by disabling its update.\n\n3.  **Bubble Insertion:** To prevent $I_2$ from incorrectly entering the EX stage, and to ensure the pipeline slot is correctly occupied, a \"bubble\" must be inserted.\n    -   A bubble is an effective NOP. The hazard control logic must override the normal inputs to the $ID/EX$ register. Instead of latching the state for $I_2$, it must force the register to latch control signals corresponding to a NOP. The problem defines a NOP as having control signals set to zero. Therefore, the control logic must **write control zeros into the $ID/EX$ register**.\n\nIn summary, the correct control action for a $1$-cycle stall is: freeze PC and $IF/ID$, inject a NOP bubble into $ID/EX$, and allow $EX/MEM$ and $MEM/WB$ to update normally.\n\n### Option-by-Option Analysis\n\n**A. Assert a stall so that $PC$ and $IF/ID$ do not update at the next clock edge (freeze upstream); write control zeros into $ID/EX$ at the next clock edge (insert a NOP bubble into EX); allow $EX/MEM$ and $MEM/WB$ to update normally. After exactly $1$ cycle, deassert the stall so that $I_2$ advances to EX when $I_1$ is in MEM and its loaded data can be forwarded.**\n\nThis option describes the three necessary actions precisely:\n1.  \"$PC$ and $IF/ID$ do not update\": Correctly freezes the upstream pipeline.\n2.  \"write control zeros into $ID/EX$\": Correctly inserts the bubble into the EX stage.\n3.  \"allow $EX/MEM$ and $MEM/WB$ to update normally\": Correctly allows the downstream pipeline to drain.\nThe explanatory clause at the end is slightly imprecise; $I_2$ advances to EX when $I_1$ is in WB, which is the cycle *after* $I_1$ is in MEM. However, the description of the control mechanism itself is perfectly accurate and is the standard implementation. The data becomes *available* at the end of the MEM stage, enabling forwarding in the next cycle.\n\nVerdict: **Correct**.\n\n**B. Assert a stall that freezes $PC$, $IF/ID$, $ID/EX$, $EX/MEM$, and $MEM/WB$ simultaneously for exactly $1$ cycle (global freeze); do not insert any NOP anywhere. Resume normal operation on the next cycle.**\n\nThis option describes a global freeze of the entire pipeline. Freezing $EX/MEM$ and $MEM/WB$ is unnecessary and inefficient, violating the \"minimum stages frozen\" constraint. Freezing $ID/EX$ would cause instruction $I_1$ to be re-executed in cycle $t+1$, which is incorrect. This mechanism is flawed.\n\nVerdict: **Incorrect**.\n\n**C. Do not freeze $PC$ or $IF/ID$; instead, freeze only $ID/EX$ for $1$ cycle and insert the bubble by zeroing control fields in $EX/MEM$ at the next clock edge. Allow $MEM/WB$ to update normally.**\n\nThis option has multiple errors. Not freezing $PC$ and $IF/ID$ would cause instruction $I_2$ to be overwritten and lost. Freezing $ID/EX$ is incorrect, as it would cause re-execution of $I_1$. Inserting the bubble into $EX/MEM$ places it in the wrong stage at the wrong time; the bubble must be in the EX stage in cycle $t+1$, which requires injection into the $ID/EX$ register.\n\nVerdict: **Incorrect**.\n\n**D. Freeze only $PC$ for $1$ cycle so that the same instruction is refetched; let $IF/ID$ update with whatever the instruction memory returns; keep $ID/EX$ updating with $I_2$ and do not explicitly insert a NOP into any pipeline register.**\n\nThis is catastrophically wrong. Allowing $ID/EX$ to update with $I_2$ is precisely what the hazard detection must prevent. This would cause $I_2$ to execute with a stale value for $x2$, committing an incorrect architectural state.\n\nVerdict: **Incorrect**.\n\n**E. Freeze $PC$, $IF/ID$, and $ID/EX$ for $1$ cycle; do not write a NOP into any pipeline register; allow $EX/MEM$ and $MEM/WB$ to update normally so that only downstream instructions progress during the stall.**\n\nThis option correctly identifies that $PC$ and $IF/ID$ must be frozen and that downstream stages should progress. However, it incorrectly states that $ID/EX$ should be frozen. Freezing $ID/EX$ would cause $I_1$ to be re-executed. The correct action is to overwrite $ID/EX$ with a NOP bubble, not to freeze its prior contents.\n\nVerdict: **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}