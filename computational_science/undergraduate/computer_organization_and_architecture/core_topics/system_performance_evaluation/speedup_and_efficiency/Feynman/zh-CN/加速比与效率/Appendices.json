{
    "hands_on_practices": [
        {
            "introduction": "性能优化很少是“免费的午餐”；它常常涉及复杂的权衡。本练习将运用计算机体系结构中基础的 $CPI$ (每指令周期数) 公式，来探讨一种常见的编译器优化技术——循环展开。通过这个实践，你将学习如何量化循环展开在减少动态指令数的同时，如何可能对指令缓存产生负面影响，并最终决定加速比的大小。",
            "id": "3679725",
            "problem": "一个程序在单发射、顺序执行的处理器核心上以固定的时钟频率执行一个包含 $N$ 次迭代的热点循环。每次原始循环迭代执行 $L$ 次加载 (load)、$A$ 次算术逻辑单元 (ALU) 操作和 $B$ 次分支 (branch)。每种指令类型的每指令周期数 (CPI) 假定为常数，分别由 $\\mathrm{CPI}_{\\mathrm{load}}$、$\\mathrm{CPI}_{\\mathrm{ALU}}$ 和 $\\mathrm{CPI}_{\\mathrm{branch}}$ 给出。指令缓存 (I-cache) 会引入额外的每指令停顿周期，其模型为 $r \\cdot p$，其中 $r$ 是 I-cache 的未命中率（单位：每次指令的未命中次数），$p$ 是未命中惩罚（单位：每次未命中的周期数）。假设数据侧行为及所有其他微架构特性在不同版本之间保持不变。使用以下基本定义：\n$$\n\\mathrm{CPI}_{\\text{total}} \\;=\\; \\sum_{i \\in \\{\\text{load}, \\text{ALU}, \\text{branch}\\}} f_i \\cdot \\mathrm{CPI}_i \\;+\\; r \\cdot p,\n$$\n其中 $f_i$ 是指令类型 $i$ 在执行的指令组合中的动态占比，且在固定频率下，执行时间与 $\\text{IC} \\cdot \\mathrm{CPI}_{\\text{total}}$ 成正比，其中 $\\text{IC}$ 是动态指令数。加速比 $S$ 定义为 $S \\;=\\; T_{\\text{original}} / T_{\\text{unrolled}}$。\n\n考虑以下具体场景：\n- 每次迭代的原始循环体：$L = 3$，$A = 4$，$B = 1$（因此每次迭代有 $8$ 条指令）。\n- 各指令类型的 CPI：$\\mathrm{CPI}_{\\mathrm{load}} = 1.2$，$\\mathrm{CPI}_{\\mathrm{ALU}} = 1.0$，$\\mathrm{CPI}_{\\mathrm{branch}} = 3.0$。\n- 原始的 I-cache 未命中率和惩罚：$r_{\\text{orig}} = 0.01$，$p = 10$。\n- 编译器以因子 $U = 4$ 进行循环展开，复制循环体并将动态分支数减少为原来的 $1/U$，而对应于每次原始迭代的 $L$ 和 $A$ 保持不变。假设 $N$ 可被 $U$ 整除，并忽略任何余数处理。\n- 由于代码体积增加，展开后版本的 I-cache 未命中率上升至 $r_{\\text{unroll}} = 0.03$；$p$ 保持不变。\n\n在这些假设下，仅使用上述定义，哪个选项最接近展开后版本相对于原始版本所实现的加速比 $S$ 的值？\n\nA. $S \\approx 1.08$\nB. $S \\approx 0.95$\nC. $S \\approx 1.00$\nD. $S \\approx 1.15$",
            "solution": "推导必须从基本定义出发。首先，在固定时钟频率下，执行时间 $T$ 与 $\\text{IC} \\cdot \\mathrm{CPI}_{\\text{total}}$ 成正比。因此，加速比 $S$ 可以写成：\n$$\nS \\;=\\; \\frac{T_{\\text{original}}}{T_{\\text{unrolled}}} \\;=\\; \\frac{\\text{IC}_{\\text{orig}} \\cdot \\mathrm{CPI}_{\\text{orig}}}{\\text{IC}_{\\text{unroll}} \\cdot \\mathrm{CPI}_{\\text{unroll}}}.\n$$\n我们需要计算每个版本的动态指令组合分数 $f_i$ 和总 CPI，然后计算 $\\text{IC} \\cdot \\mathrm{CPI}$ 的比率。\n\n原始版本：\n- 每次迭代的指令数：加载 $= L = 3$，ALU $= A = 4$，分支 $= B = 1$，总计 $= 3 + 4 + 1 = 8$ 条指令。\n- 指令占比：$f_{\\text{load,orig}} = 3/8 = 0.375$，$f_{\\text{ALU,orig}} = 4/8 = 0.5$，$f_{\\text{branch,orig}} = 1/8 = 0.125$。\n- 每条指令的 I-cache 停顿：$r_{\\text{orig}} \\cdot p = 0.01 \\cdot 10 = 0.1$。\n- 总 CPI：\n$$\n\\mathrm{CPI}_{\\text{orig}} \\;=\\; 0.375 \\cdot 1.2 \\;+\\; 0.5 \\cdot 1.0 \\;+\\; 0.125 \\cdot 3.0 \\;+\\; 0.1 \\;=\\; 0.45 \\;+\\; 0.5 \\;+\\; 0.375 \\;+\\; 0.1 \\;=\\; 1.425.\n$$\n- 每次原始迭代的动态指令数是 $8$。经过 $N$ 次迭代，$\\text{IC}_{\\text{orig}} = 8N$。\n\n展开后版本 ($U = 4$)：\n- 对应于每次原始迭代，加载和 ALU 操作的总数保持不变：加载 $= 3$，ALU $= 4$。\n- 对应于每次原始迭代，分支数减少为原来的 $1/U$：分支 $= 1/4 = 0.25$。\n- 展开后，对应于每次原始迭代的总指令数：$3 + 4 + 0.25 = 7.25$，因此 $\\text{IC}_{\\text{unroll}} = 7.25N$。\n- 指令占比：$f_{\\text{load,unroll}} = 3/7.25 \\approx 0.413793$，$f_{\\text{ALU,unroll}} = 4/7.25 \\approx 0.551724$，$f_{\\text{branch,unroll}} = 0.25/7.25 \\approx 0.0344828$。\n- 每条指令的 I-cache 停顿：$r_{\\text{unroll}} \\cdot p = 0.03 \\cdot 10 = 0.3$。\n- 总 CPI：\n$$\n\\mathrm{CPI}_{\\text{unroll}} \\;=\\; 0.413793 \\cdot 1.2 \\;+\\; 0.551724 \\cdot 1.0 \\;+\\; 0.0344828 \\cdot 3.0 \\;+\\; 0.3.\n$$\n计算各项：\n$$\n0.413793 \\cdot 1.2 \\approx 0.4965516,\\quad 0.551724 \\cdot 1.0 = 0.551724,\\quad 0.0344828 \\cdot 3.0 \\approx 0.1034484.\n$$\n求和：\n$$\n\\mathrm{CPI}_{\\text{unroll}} \\;\\approx\\; 0.4965516 \\;+\\; 0.551724 \\;+\\; 0.1034484 \\;+\\; 0.3 \\;=\\; 1.451724.\n$$\n\n现在计算加速比：\n$$\nS \\;=\\; \\frac{\\text{IC}_{\\text{orig}} \\cdot \\mathrm{CPI}_{\\text{orig}}}{\\text{IC}_{\\text{unroll}} \\cdot \\mathrm{CPI}_{\\text{unroll}}} \\;=\\; \\frac{8N \\cdot 1.425}{7.25N \\cdot 1.451724} \\;=\\; \\frac{8 \\cdot 1.425}{7.25 \\cdot 1.451724}.\n$$\n计算分子：$8 \\cdot 1.425 = 11.4$。\n计算分母：$7.25 \\cdot 1.451724 \\approx 10.525$。\n因此，\n$$\nS \\;\\approx\\; \\frac{11.4}{10.525} \\;\\approx\\; 1.083.\n$$\n在所有选项中，这最接近 $1.08$。\n\n从基本原理进行概念性讨论：循环展开减少了动态分支指令，这降低了动态指令数，并将指令组合的重心转向加载和 ALU 操作。这减少了分支对 $\\mathrm{CPI}_{\\text{total}}$ 和 $\\text{IC}$ 的贡献，但是更大的代码体积会增加 I-cache 的未命中率，从而增加了停顿项 $r \\cdot p$ 并可能导致 $\\mathrm{CPI}_{\\text{total}}$ 增加。在这个模型中，循环展开能提升速度（即 $S > 1$）的精确条件是乘积 $\\text{IC}_{\\text{unroll}} \\cdot \\mathrm{CPI}_{\\text{unroll}}$ 小于 $\\text{IC}_{\\text{orig}} \\cdot \\mathrm{CPI}_{\\text{orig}}$。在本例中，这个条件是成立的，因为尽管 $\\mathrm{CPI}$ 略有增加（从 $1.425$ 增加到 $1.451724$），但动态指令数的减少幅度更大（从 $8N$ 减少到 $7.25N$），从而导致总周期数净减少。\n\n逐个选项分析：\n- A. $S \\approx 1.08$。根据计算，$S \\approx 1.083$，所以这是正确的。\n- B. $S \\approx 0.95$。这个选项声称性能下降（$S  1$），这与计算出的 $S \\approx 1.083$ 相矛盾。不正确。\n- C. $S \\approx 1.00$。这个选项声称没有变化，但计算出的加速比大于 1。不正确。\n- D. $S \\approx 1.15$。这个选项高估了收益；我们计算出的值要低得多。不正确。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "系统的性能瓶颈常常在于内存带宽，而不仅仅是处理器速度。本练习将深入探讨交错式内存的架构，并揭示特定的步长访问模式如何导致存储体（bank）冲突，从而严重降低数据吞吐率。通过这个实践，你将学会从数学上定位冲突的根源，并应用一种简单的软件技巧——数据填充（padding）——来恢复理想的并行访存性能。",
            "id": "3679711",
            "problem": "一个系统实现了交叉主存储器，该存储器具有 $N_b$ 个相同的单端口存储体。连续的逻辑字通过将第 $k$ 个请求字的存储体索引映射为 $b_k = (k \\cdot s) \\bmod N_b$ 来条带化地分布在各个存储体上，其中 $s$ 是以字为单位的步长。内存控制器每个周期每个存储体最多只能发出一个请求。假设请求序列是大的、稳态的（即，$k$ 的范围跨越许多连续整数，因此启动时的瞬态效应可以忽略不计）。目标是理解由步长引起的存储体冲突如何影响加速比和效率，并确定消除冲突所需的填充。\n\n仅使用以下基本原理：\n- 加速比和效率的定义：$S = \\frac{T_{\\text{serial}}}{T_{\\text{parallel}}}$ 和 $E = \\frac{S}{P}$，其中 $P$ 为并行资源数。\n- 映射 $b_k = (k \\cdot s) \\bmod N_b$ 对 $k$ 是周期的，其周期是 $N_b$ 的一个因子。\n- 每个存储体每个周期最多只能服务一个请求。\n\n执行以下操作：\n1. 通过对 $b_k$ 的周期性结构进行推理，确定在稳态下步长访问所访问的不同存储体的数量，并推导出冲突因子 $c$。$c$ 定义为在任意 $N_b$ 个连续请求的窗口内，每个存储体的平均请求数。请用 $N_b$ 和 $s$ 表示 $c$，不要使用任何快捷公式。\n2. 使用加速比和效率的定义，推导吞吐量下降因子（实际吞吐量与无冲突理想吞吐量之比），并用冲突因子 $c$ 和 $N_b$ 表示。解释为什么该因子直接描述了相对于理想交叉存取，加速比的损失情况。\n3. 对于 $N_b = 16$ 和 $s = 12$，计算冲突因子 $c$、吞吐量下降因子（表示为简化分数）以及最小正填充 $p$ 的数值。该填充 $p$ 使得新步长 $s' = s + p$ 与 $N_b$ 互质（即，$s'$ 与 $N_b$ 没有大于1的公约数），从而实现最大加速比。无需四舍五入。\n\n按以下顺序报告第 3 部分的最终数值结果：冲突因子 $c$，吞吐量下降因子，最小填充 $p$。",
            "solution": "### 第 1 部分：冲突因子 $c$ 的推导\n\n从第 $k$ 个字请求到存储体索引 $b_k$ 的映射由线性同余关系 $b_k = (k \\cdot s) \\bmod N_b$ 给出。在稳态下访问的存储体索引集合是当 $k$ 取遍所有整数时该表达式生成的所有值的集合。这是步长 $s$ 对模 $N_b$ 的所有倍数的集合。\n\n根据初等数论，对于 $k \\in \\{0, 1, 2, \\dots\\}$，由 $(k \\cdot a) \\bmod n$ 生成的不同值的集合是 $\\{0 \\cdot g, 1 \\cdot g, 2 \\cdot g, \\dots, (\\frac{n}{g}-1) \\cdot g\\}$，其中 $g = \\gcd(a, n)$。\n将此理论应用于我们的问题，令 $a=s$ 和 $n=N_b$，则访问的不同存储体索引的集合是 $\\{0, g, 2g, \\dots, (\\frac{N_b}{g}-1)g\\}$，其中 $g = \\gcd(s, N_b)$。\n因此，访问的不同存储体的数量 $N_{distinct}$ 是该集合中元素的数量，即：\n$$ N_{distinct} = \\frac{N_b}{\\gcd(s, N_b)} $$\n问题将冲突因子 $c$ 定义为在任意 $N_b$ 个连续请求的窗口内，每个存储体的平均请求数。此定义被解释为在该窗口内映射到任何单个*活动*存储体的请求数。\n\n考虑一个包含 $N_b$ 个连续请求的窗口，例如，对于 $k = 0, 1, \\dots, N_b-1$。总共发出了 $N_b$ 个请求。这 $N_b$ 个请求分布在 $N_{distinct}$ 个活动存储体上。由于映射的周期性，在代表稳态行为的足够大的窗口内，这 $N_{distinct}$ 个存储体中的每一个都被访问了相等的次数。一个大小为 $N_b$ 的窗口恰好包含 $\\gcd(s, N_b)$ 个完整的访问模式周期，其中周期长度为 $N_b / \\gcd(s, N_b)$。\n\n因此，总共 $N_b$ 个请求均匀地分布在 $N_{distinct}$ 个活动存储体上。每个活动存储体的请求数为：\n$$ c = \\frac{\\text{Total Requests}}{\\text{Number of Active Banks}} = \\frac{N_b}{N_{distinct}} = \\frac{N_b}{N_b / \\gcd(s, N_b)} $$\n简化此表达式可得到冲突因子 $c$：\n$$ c = \\gcd(s, N_b) $$\n该因子表示冲突的程度；$c=1$ 表示没有冲突（所有存储体在任何一个被重复访问之前都被访问过），而更高的值表示请求集中在更少的存储体上，导致更频繁的冲突。\n\n### 第 2 部分：吞吐量下降因子的推导\n\n加速比 $S$ 定义为串行执行时间与并行执行时间之比，$S = T_{\\text{serial}}/T_{\\text{parallel}}$。在一个具有 $P$ 个资源的理想并行系统中，理想加速比为 $P$。对于我们的交叉存储系统，并行资源的数量是存储体的数量，因此 $P = N_b$。理想加速比为 $S_{ideal} = N_b$，这发生在所有存储体可以无冲突地并行使用时。\n\n吞吐量是单位时间内服务的请求数，与加速比成正比。理想吞吐量 $\\Theta_{ideal}$ 对应于理想加速比 $S_{ideal}$。实际吞吐量 $\\Theta_{actual}$ 对应于实际加速比 $S_{actual}$。因此，吞吐量下降因子是实际吞吐量与理想吞吐量之比，也等于实际加速比与理想加速比之比：\n$$ \\text{Degradation Factor} = \\frac{\\Theta_{actual}}{\\Theta_{ideal}} = \\frac{S_{actual}}{S_{ideal}} $$\n并行系统的加速比根本上受限于可有效利用的资源数量。在理想情况下（例如，当 $s$ 与 $N_b$ 互质时），所有 $N_b$ 个存储体都被利用，因此有效并行度为 $N_b$。\n在存在潜在冲突的一般情况下，只有 $N_{distinct} = N_b / \\gcd(s, N_b)$ 个存储体被访问。其余的 $N_b - N_{distinct}$ 个存储体保持空闲。因此，可实现的最大加速比受限于活动存储体的数量。假设这些活动存储体可以被高效利用，则实际加速比为 $S_{actual} = N_{distinct}$。\n\n代入理想加速比和实际加速比的表达式：\n$$ S_{ideal} = N_b $$\n$$ S_{actual} = N_{distinct} = \\frac{N_b}{\\gcd(s, N_b)} = \\frac{N_b}{c} $$\n那么吞吐量下降因子为：\n$$ \\text{Degradation Factor} = \\frac{S_{actual}}{S_{ideal}} = \\frac{N_b / c}{N_b} = \\frac{1}{c} $$\n该因子直接描述了加速比的损失，因为它代表了理想并行能力中实际实现的部分。因子 $1/c$ 意味着系统的性能就好像它只有其总存储体数量的 $1/c$。\n\n### 第 3 部分：数值计算\n\n给定 $N_b = 16$ 和步长 $s = 12$。\n\n**冲突因子 $c$**：\n使用第 1 部分推导的公式：\n$$ c = \\gcd(s, N_b) = \\gcd(12, 16) $$\n为了求最大公约数，我们可以使用每个数的质因数分解：\n$12 = 2^2 \\cdot 3$\n$16 = 2^4$\n最大公约数是 $2^2 = 4$。\n$$ c = 4 $$\n\n**吞吐量下降因子**：\n使用第 2 部分的公式，下降因子为 $1/c$：\n$$ \\text{Degradation Factor} = \\frac{1}{c} = \\frac{1}{4} $$\n\n**最小正填充 $p$**：\n我们需要找到最小的正整数 $p$，使得新步长 $s' = s + p$ 与 $N_b$ 互质。这意味着 $\\gcd(s', N_b) = 1$。\n代入给定值：\n$$ s' = 12 + p $$\n$$ N_b = 16 $$\n我们需要 $\\gcd(12+p, 16) = 1$。\n要使 $\\gcd(12+p, 16)$ 为 $1$，$12+p$ 这个数不能与 $16$ 共享任何质因数。$16=2^4$ 的唯一质因数是 $2$。因此，$12+p$ 必须是一个奇数。\n因为 $12$ 是一个偶数，要使 $12+p$ 为奇数，$p$ 必须是一个奇数。\n问题要求的是*最小正*填充 $p$。$p$ 的正奇数序列从 $1, 3, 5, \\dots$ 开始。因此，$p$ 的最小正值为 $1$。\n我们来验证一下 $p=1$ 的情况：\n$$ s' = 12 + 1 = 13 $$\n$$ \\gcd(13, 16) = 1 $$\n这是正确的，因为 $13$ 是一个质数，并且不是 $16$ 的因子。因此，最小正填充为 $p=1$。\n\n第 3 部分的最终数值结果是：冲突因子 $c=4$，吞吐量下降因子 $1/4$，以及最小填充 $p=1$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 4  \\frac{1}{4}  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "在现代多核处理器中，缓存一致性对于保证程序的正确性和高性能至关重要。本练习将比较两种基本的缓存写策略——写穿（write-through）和写回（write-back），并建模分析它们在共享总线上的流量影响。通过分析一个包含明显“读密集”和“写密集”阶段的工作负载，你将深刻理解为何缓存策略的选择对于设计高效的并行系统是如此关键。",
            "id": "3679713",
            "problem": "考虑一个具有 $N=8$ 个相同核心的共享内存多处理器。每个核心都有一个私有的 Level-1 (L1) 数据缓存。我们考虑两种可选的缓存写入策略：写通 (write-through, WT) 和写回 (write-back, WB)。缓存一致性协议是 Modified-Shared-Invalid (MSI)。缓存行大小为 $L = 64$ 字节，机器字长为 $w = 8$ 字节。互连是一个单独的监听总线，其峰值数据带宽为 $R = 25$ GB/s。总线服务时间主要由数据和一致性流量决定；计算、排队和其他延迟可以忽略不计。一次一致性失效广播（包括总线上承载的目录或监听元数据）在总线上消耗 $b_{\\mathrm{inv}} = 16$ 字节。读未命中会获取整个缓存行，在总线上产生 $L$ 字节的开销。在写通策略下，每次写操作都会将写入的字传输到内存，每次写操作产生 $w$ 字节的开销。在写回策略下，脏行仅在被驱逐时写回一次，每个脏行产生 $L$ 字节的开销。假设两种策略在写未命中时都采用写分配 (write-allocate)。\n\n一个并行工作负载按顺序执行两个阶段：\n\n- 阶段 $\\mathcal{R}$ (以读为主)：每个核心对一个共享数组执行 $2.0 \\times 10^{6}$ 次字读取，顺序扫描，因此每个核心接触到 $n_{\\mathrm{R}} = \\frac{2.0 \\times 10^{6}}{8} = 250{,}000$ 个不同的缓存行。为方便建模，假设对于每个核心，其 $n_{\\mathrm{R}}$ 个缓存行中的每一个都恰好从内存中读取一次（每个缓存行每个核心一次读未命中），并且与数据移动相比，共享读取引起的一致性开销可以忽略不计。\n\n- 阶段 $\\mathcal{W}$ (以写为主)：每个核心向从同一数组中抽取的 $n_{\\mathrm{W}} = 125{,}000$ 个缓存行进行写入。对于每个这样的缓存行，一个核心在该行内执行 $n_{\\mathrm{per\\_line}} = 16$ 次不同的字写入。假设在阶段 $\\mathcal{W}$ 开始时，每个核心要写入的缓存行都不在该核心的缓存中，并且在第一次写入前必须获取一次。并且，平均而言，每个这样的缓存行都恰好有另一个共享者，因此为第一次写入获取独占权限会为每个缓存行产生一次失效广播。在写回策略下，假设每个核心写入的缓存行都会变脏，并在阶段结束时被驱逐一次（每个这样的缓存行一次写回）。不发生缓存到缓存的传输；所有未命中都由主内存服务。\n\n每个阶段的总执行时间被视为总线传输时间，等于在总线上传输的总字节数除以 $R$。设工作负载的总执行时间为两个阶段时间之和。使用上述流量模型，计算在整个工作负载中，写回相对于写通的总体加速比，定义为写通策略下的总执行时间与写回策略下的总执行时间之比。将您的最终答案四舍五入到四位有效数字。答案是无量纲的。",
            "solution": "目标是计算写回 (WB) 策略相对于写通 (WT) 策略的加速比 $S$。加速比定义为总执行时间之比：\n$$S = \\frac{T_{WT}}{T_{WB}}$$\n问题指出，任何阶段的执行时间仅由其产生的总线流量决定。总执行时间 $T$ 是总线上传输的总字节数 $B$ 除以总线带宽 $R$。\n$$T = \\frac{B}{R}$$\n因此，加速比可以表示为每种策略产生的总总线流量之比：\n$$S = \\frac{B_{WT} / R}{B_{WB} / R} = \\frac{B_{WT}}{B_{WB}}$$\n总流量是阶段 $\\mathcal{R}$ 和阶段 $\\mathcal{W}$ 的流量之和：$B = B_{\\mathcal{R}} + B_{\\mathcal{W}}$。我们现在将为每种策略计算总总线流量。\n\n**1. 阶段 $\\mathcal{R}$ 的总线流量**\n\n在阶段 $\\mathcal{R}$ 中，$N$ 个核心中的每一个在访问其 $n_{\\mathrm{R}}$ 个不同缓存行时，都会为每个缓存行产生一次读未命中。一次读未命中会从内存中获取一个大小为 $L$ 的完整缓存行。读取行为及其产生的流量与写入策略无关。因此，阶段 $\\mathcal{R}$ 的流量对于 WT 和 WB 两种策略是相同的。\n$$B_{\\mathcal{R}, WT} = B_{\\mathcal{R}, WB} = N \\times n_{\\mathrm{R}} \\times L$$\n代入给定值：\n$N = 8$\n$n_{\\mathrm{R}} = 250{,}000 = 2.5 \\times 10^5$\n$L = 64$ 字节\n$$B_{\\mathcal{R}} = 8 \\times (2.5 \\times 10^5) \\times 64 = 20 \\times 10^5 \\times 64 = 1280 \\times 10^5 = 1.28 \\times 10^8 \\text{ 字节}$$\n\n**2. 阶段 $\\mathcal{W}$ 的总线流量**\n\n在阶段 $\\mathcal{W}$ 中，我们分析 $N$ 个核心中每个核心访问其 $n_{\\mathrm{W}}$ 个缓存行时产生的流量组成部分。对于每个缓存行，以下事件会产生总线流量：\n-   **写未命中 (Write Miss)：** 缓存行最初并不在缓存中，因此对它的第一次写入会导致写未命中。在写分配策略下，这会触发一个“为获取所有权而读”(read for ownership, RFO) 请求，该请求从内存中获取整个缓存行。这会产生 $L$ 字节的流量。\n-   **失效 (Invalidation)：** 为了获得写入的独占所有权，核心必须使其他缓存副本失效。问题指出存在一个其他共享者，因此每个缓存行会发送一次失效广播，产生 $b_{\\mathrm{inv}}$ 字节的流量。\n-   **写数据传输 (Write Data Transfer)：** 将写入数据传输到内存的方法取决于具体策略。\n\n**2a. 使用写通 (WT) 策略的阶段 $\\mathcal{W}$ 流量**\n\n在 WT 策略下，每次写操作都会传播到主内存。每个核心对其 $n_{\\mathrm{W}}$ 个缓存行中的每一个执行 $n_{\\mathrm{per\\_line}}$ 次字写入。每次字写入会在总线上产生 $w$ 字节的流量。\n使用 WT 策略的阶段 $\\mathcal{W}$ 的总流量是所有核心的 RFO、失效以及所有单个写操作产生的流量之和。\n$$B_{\\mathcal{W}, WT} = N \\times n_{\\mathrm{W}} \\times (L + b_{\\mathrm{inv}} + n_{\\mathrm{per\\_line}} \\times w)$$\n代入给定值：\n$N = 8$\n$n_{\\mathrm{W}} = 125{,}000 = 1.25 \\times 10^5$\n$L = 64$ 字节\n$b_{\\mathrm{inv}} = 16$ 字节\n$n_{\\mathrm{per\\_line}} = 16$\n$w = 8$ 字节\n$$B_{\\mathcal{W}, WT} = 8 \\times (1.25 \\times 10^5) \\times (64 + 16 + 16 \\times 8)$$\n$$B_{\\mathcal{W}, WT} = 10^6 \\times (80 + 128) = 10^6 \\times 208 = 2.08 \\times 10^8 \\text{ 字节}$$\n\n**2b. 使用写回 (WB) 策略的阶段 $\\mathcal{W}$ 流量**\n\n在 WB 策略下，写入只在本地缓存中进行。总线流量仅在修改过的（“脏”）缓存行被驱逐并写回内存时发生。问题指出，每个核心写入的 $n_{\\mathrm{W}}$ 个缓存行都会变脏并被驱逐一次，产生一次对整个缓存行的写回。\n使用 WB 策略的阶段 $\\mathcal{W}$ 的总流量是所有核心的 RFO、失效以及最终写回操作产生的流量之和。\n$$B_{\\mathcal{W}, WB} = N \\times n_{\\mathrm{W}} \\times (L + b_{\\mathrm{inv}} + L) = N \\times n_{\\mathrm{W}} \\times (2L + b_{\\mathrm{inv}})$$\n代入数值：\n$$B_{\\mathcal{W}, WB} = 8 \\times (1.25 \\times 10^5) \\times (2 \\times 64 + 16)$$\n$$B_{\\mathcal{W}, WB} = 10^6 \\times (128 + 16) = 10^6 \\times 144 = 1.44 \\times 10^8 \\text{ 字节}$$\n\n**3. 总流量与加速比计算**\n\n现在我们可以通过将两个阶段的流量相加来计算每种策略的总流量。\n\nWT 的总流量：\n$$B_{WT} = B_{\\mathcal{R}} + B_{\\mathcal{W}, WT} = 1.28 \\times 10^8 + 2.08 \\times 10^8 = 3.36 \\times 10^8 \\text{ 字节}$$\n\nWB 的总流量：\n$$B_{WB} = B_{\\mathcal{R}} + B_{\\mathcal{W}, WB} = 1.28 \\times 10^8 + 1.44 \\times 10^8 = 2.72 \\times 10^8 \\text{ 字节}$$\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{B_{WT}}{B_{WB}} = \\frac{3.36 \\times 10^8}{2.72 \\times 10^8} = \\frac{3.36}{2.72}$$\n为了简化分数：\n$$S = \\frac{336}{272} = \\frac{168}{136} = \\frac{84}{68} = \\frac{21}{17}$$\n执行除法并四舍五入到四位有效数字：\n$$S = \\frac{21}{17} \\approx 1.235294...$$\n$$S \\approx 1.235$$\n写回相对于写通的总体加速比约为 $1.235$。",
            "answer": "$$\\boxed{1.235}$$"
        }
    ]
}