{
    "hands_on_practices": [
        {
            "introduction": "理解多周期数据通路性能的第一步是量化其执行效率。本练习将指导你分析一个具体指令序列的总执行时间，并计算平均每条指令周期数（$CPI$），这是评估处理器性能的基本技能。通过这个实践，你将深入理解不同指令类型如何影响整体执行效率。",
            "id": "3660301",
            "problem": "考虑一个经典的MIPS-like指令集架构的多周期实现。该数据通路使用固定长度的时钟，每个控制状态恰好占用一个时钟周期。控制状态如下：取指 $S_{\\mathrm{IF}}$、指令译码和寄存器取数 $S_{\\mathrm{ID}}$、执行 $S_{\\mathrm{EX}}$、内存访问（读） $S_{\\mathrm{MEM,R}}$、内存访问（写） $S_{\\mathrm{MEM,W}}$ 和寄存器写回 $S_{\\mathrm{WB}}$。每条指令在前一条指令完成后才开始执行，指令之间没有重叠。程序计数器（PC）在 $S_{\\mathrm{IF}}$ 状态更新，对于分支指令则在 $S_{\\mathrm{EX}}$ 状态更新。\n\n对于此微基准测试，将以下指令模式重复 $N$ 次：$add$、$lw$、$beq$、$sw$，其中 $N = 250$。具体的指令是：\n$add\\ r_{1}, r_{2}, r_{3}$,\n$lw\\ r_{4}, 0(r_{5})$,\n$beq\\ r_{1}, r_{4}, \\text{Label}$,\n$sw\\ r_{4}, 0(r_{6})$.\n\n假设如下：\n- 分支指令 $beq$ 始终不发生跳转（比较结果为假），因此控制流顺序通过该模式，标签（Label）从未使用。\n- 对于 $lw$ 和 $sw$ 指令，有效地址的计算在 $S_{\\mathrm{EX}}$ 状态下通过将基址寄存器和符号扩展的立即数相加来完成。\n- 每条指令的控制状态序列由各指令的语义和上述数据通路确定，具体如下：\n  - $add$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{WB}}$,\n  - $lw$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,R}} \\rightarrow S_{\\mathrm{WB}}$,\n  - $beq$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}}$,\n  - $sw$: $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,W}}$.\n- 所有内存引用都是对齐的，不会引起异常。\n\n任务：\n1. 根据多周期执行的基本原理和指定的状态序列，推导出执行整个包含 $N=250$ 次重复的 4 条指令模式的微基准测试所需的总时钟周期数。\n2. 统计在整个运行过程中每个控制状态被访问的次数，并据此确定哪些状态在周期份额方面主导了执行过程。\n3. 以单个数字报告该基准测试的平均每指令周期数（CPI）。无需四舍五入，最终答案中不应包含单位。将CPI表示为实数。",
            "solution": "该问题陈述清晰，其科学基础根植于计算机体系结构的原理，并提供了一套完整且一致的数据和假设。因此，该问题是有效的，并且可以直接进行解析求解。\n\n分析过程通过解决指定的三个任务来进行：计算总时钟周期数，确定每个控制状态的访问频率，以及计算平均每指令周期数（CPI）。\n\n**1. 基准测试的总时钟周期数**\n\n该微基准测试包含将一个特定的 4 条指令模式重复 $N$ 次，其中 $N=250$。该模式为：$add$、$lw$、$beq$、$sw$。总时钟周期数 $C_{total}$ 等于重复次数乘以执行一次该模式所需的周期数 $C_{pattern}$。\n\n首先，我们根据给定的控制状态序列确定每条单独指令的时钟周期数。在多周期数据通路中，每个状态对应一个时钟周期。\n- $add$ 指令遵循序列 $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{WB}}$。状态数为 4，因此一条 $add$ 指令的周期数 $C_{add}$ 为 4。\n- $lw$ 指令遵循序列 $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,R}} \\rightarrow S_{\\mathrm{WB}}$。状态数为 5，因此一条 $lw$ 指令的周期数 $C_{lw}$ 为 5。\n- $beq$ 指令由于不发生跳转，遵循序列 $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}}$。比较和不跳转的决定在执行状态完成。状态数为 3，因此一条不跳转的 $beq$ 指令的周期数 $C_{beq}$ 为 3。\n- $sw$ 指令遵循序列 $S_{\\mathrm{IF}} \\rightarrow S_{\\mathrm{ID}} \\rightarrow S_{\\mathrm{EX}} \\rightarrow S_{\\mathrm{MEM,W}}$。状态数为 4，因此一条 $sw$ 指令的周期数 $C_{sw}$ 为 4。\n\n重复一次这个 4 条指令模式的总周期数 $C_{pattern}$ 是模式中每条指令周期数的总和：\n$$C_{pattern} = C_{add} + C_{lw} + C_{beq} + C_{sw} = 4 + 5 + 3 + 4 = 16$$\n该基准测试将此模式执行 $N = 250$ 次。因此，整个基准测试的总时钟周期数为：\n$$C_{total} = N \\times C_{pattern} = 250 \\times 16 = 4000$$\n\n**2. 控制状态访问次数统计**\n\n为了找出每个状态被访问的次数，我们首先确定执行的指令总数 $I_{total}$。该模式有 4 条指令，并重复 $N=250$ 次。\n$$I_{total} = N \\times 4 = 250 \\times 4 = 1000$$\n每种类型的指令被执行的次数是 $N=250$。\n- $add$ 指令的数量, $I_{add} = 250$。\n- $lw$ 指令的数量, $I_{lw} = 250$。\n- $beq$ 指令的数量, $I_{beq} = 250$。\n- $sw$ 指令的数量, $I_{sw} = 250$。\n\n现在，我们通过对所有已执行指令中每个状态的出现次数求和，来统计每个状态的总访问次数。\n- **$S_{\\mathrm{IF}}$ (取指):** 每条指令都必须被取指。所以，每条指令都会访问此状态一次。\n  $$N(S_{\\mathrm{IF}}) = I_{total} = 1000$$\n- **$S_{\\mathrm{ID}}$ (指令译码/寄存器取数):** 每条指令都会被译码。这个状态也是每条指令都会访问一次。\n  $$N(S_{\\mathrm{ID}}) = I_{total} = 1000$$\n- **$S_{\\mathrm{EX}}$ (执行):** 模式中的所有四种指令类型都执行一个执行步骤（$add$ 的ALU运算，$lw$/$sw$ 的地址计算，$beq$ 的比较）。\n  $$N(S_{\\mathrm{EX}}) = I_{total} = 1000$$\n- **$S_{\\mathrm{MEM,R}}$ (内存读):** 只有 $lw$ 指令执行内存读取操作。\n  $$N(S_{\\mathrm{MEM,R}}) = I_{lw} = 250$$\n- **$S_{\\mathrm{MEM,W}}$ (内存写):** 只有 $sw$ 指令执行内存写入操作。\n  $$N(S_{\\mathrm{MEM,W}}) = I_{sw} = 250$$\n- **$S_{\\mathrm{WB}}$ (写回):** 只有将结果写回寄存器堆的指令才使用此状态。在此模式中，这些指令是 $add$ 和 $lw$。\n  $$N(S_{\\mathrm{WB}}) = I_{add} + I_{lw} = 250 + 250 = 500$$\n\n主导执行的状态是那些访问次数最多的状态。状态 $S_{\\mathrm{IF}}$、$S_{\\mathrm{ID}}$ 和 $S_{\\mathrm{EX}}$ 各被访问 1000 次，而 $S_{\\mathrm{WB}}$ 被访问 500 次，$S_{\\mathrm{MEM,R}}$ 和 $S_{\\mathrm{MEM,W}}$ 各被访问 250 次。因此，取指、译码和执行状态主导了执行时间，每个状态占总周期的 $1000/4000 = 25\\%$。\n\n作为一致性检查，所有状态访问的总和必须等于总时钟周期数：\n$$N(S_{\\mathrm{IF}}) + N(S_{\\mathrm{ID}}) + N(S_{\\mathrm{EX}}) + N(S_{\\mathrm{MEM,R}}) + N(S_{\\mathrm{MEM,W}}) + N(S_{\\mathrm{WB}})$$\n$$= 1000 + 1000 + 1000 + 250 + 250 + 500 = 4000$$\n这与先前计算的 $C_{total}$ 相匹配。\n\n**3. 平均每指令周期数 (CPI)**\n\n平均每指令周期数 (CPI) 是一个性能指标，定义为总时钟周期数除以执行的指令总数。\n$$CPI = \\frac{C_{total}}{I_{total}}$$\n使用上面推导出的值：\n$$C_{total} = 4000$$\n$$I_{total} = 1000$$\n该基准测试的 CPI 为：\n$$CPI = \\frac{4000}{1000} = 4.0$$\n这个值表示在这个特定的基准测试组合中，执行一条指令平均所需的时钟周期数。",
            "answer": "$$\\boxed{4.0}$$"
        },
        {
            "introduction": "在学会分析性能之后，下一步自然是探索如何优化性能。本练习探讨了一个常见的硬件增强方案：为寄存器文件增加一个读端口，以允许在单个周期内读取两个操作数。你将计算这项改动对特定指令组合的 $CPI$ 带来的具体提升，从而体会硬件资源与处理器性能之间的直接联系。",
            "id": "3660297",
            "problem": "一台精简指令集计算机的多周期实现使用以下规范状态：取指 ($IF$)、指令译码和寄存器读取 ($ID$)、执行 ($EX$)、内存访问 ($MEM$) 和写回 ($WB$)。该机器的寄存器堆 (RF) 只有一个读端口，因此需要两个源操作数的指令必须使用两个独立的 $ID$ 周期来获取这两个源操作数。每个状态恰好消耗一个时钟周期，且不存在冒险、结构冲突或停顿。下文描述的任何修改都不会改变时钟周期。算术逻辑单元 (ALU) 完全在 $EX$ 状态内执行其操作，数据内存访问完全在 $MEM$ 状态内进行。程序计数器 (PC) 在 $IF$ 期间更新，对于已采纳的分支，则在 $EX$ 期间更新。\n\n在此基准下，各类指令的执行方式如下：\n- R型整数算术或逻辑指令读取两个源寄存器并写入一个目的寄存器。它们使用两个 $ID$ 周期来获取两个源操作数（每个周期一个），然后是 $EX$ 和 $WB$。\n- 加载 ($L$) 指令读取一个基址寄存器和一个立即数偏移量，在 $EX$ 中计算有效地址，在 $MEM$ 中读取数据，并在 $WB$ 中写入结果。\n- 存储 ($S$) 指令读取一个基址寄存器和一个要存储的源寄存器，在 $EX$ 中计算有效地址，并在 $MEM$ 中执行写操作；它们不使用 $WB$。\n- 相等则分支 ($B$) 指令读取两个源寄存器进行比较，在 $EX$ 中执行比较和目标地址计算，且不使用 $MEM$ 或 $WB$。\n\n现在，您为寄存器堆 RF 增加了一个读端口，这样就可以在单个 $ID$ 周期内同时读取两个源操作数。请为R型、S型和B型指令构建新的最小状态序列，以消除额外的 $ID$ 周期，同时在上述假设下保持功能正确性。假设加载指令继续只需要一次RF读取，并且在其他方面保持不变。\n\n考虑一个R型重负载，其指令混合概率为 $p_{R} = 0.75$、$p_{L} = 0.10$、$p_{S} = 0.10$ 和 $p_{B} = 0.05$，其中 $p_{R} + p_{L} + p_{S} + p_{B} = 1$。使用这些精确值，计算平均每指令周期数 (CPI) 的变化量，定义为 $\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{baseline}} - \\mathrm{CPI}_{\\text{modified}}$。请提供 $\\Delta \\mathrm{CPI}$ 的单个数值作为您的最终答案。无需四舍五入。",
            "solution": "问题陈述是计算机体系结构中的一个有效练习。它在科学上基于多周期数据通路设计原理，问题定义明确，有唯一且稳定的解，并以客观、正式的语言表述。它没有验证标准中列出的任何缺陷。因此，我们可以进行正式求解。\n\n该问题要求两项交付内容：首先，在硬件修改后，确定三类指令的新的最小状态序列；其次，计算平均每指令周期数 (CPI) 的变化量。该变化量定义为 $\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{baseline}} - \\mathrm{CPI}_{\\text{modified}}$。\n\n我们首先确定在基准架构中每类指令所需的时钟周期数。每个状态（$IF, ID, EX, MEM, WB$）对应一个时钟周期。\n\n**1. 基准架构分析**\n\n基准机器的寄存器堆 (RF) 为单端口，因此读取两个源寄存器的指令需要两个独立的 $ID$ 周期。\n\n- **R型指令：** 这些指令读取两个源寄存器，执行一次ALU操作，并写入一个目的寄存器。状态序列为取指 ($IF$)、两个指令译码/寄存器读取周期 ($ID$)、执行 ($EX$) 和写回 ($WB$)。\n  序列：$IF \\rightarrow ID \\rightarrow ID \\rightarrow EX \\rightarrow WB$。\n  周期数：$C_{R, \\text{baseline}} = 5$。\n\n- **加载 ($L$) 指令：** 这些指令读取一个基址寄存器，计算地址，访问内存，并写入一个寄存器。读取一个寄存器需要一个 $ID$ 周期。\n  序列：$IF \\rightarrow ID \\rightarrow EX \\rightarrow MEM \\rightarrow WB$。\n  周期数：$C_{L, \\text{baseline}} = 5$。\n\n- **存储 ($S$) 指令：** 这些指令读取一个基址寄存器和一个源寄存器（共两个），计算地址，并写入内存。它们需要两个 $ID$ 周期，且不使用 $WB$ 状态。\n  序列：$IF \\rightarrow ID \\rightarrow ID \\rightarrow EX \\rightarrow MEM$。\n  周期数：$C_{S, \\text{baseline}} = 5$。\n\n- **分支 ($B$) 指令：** 这些指令读取两个寄存器进行比较并计算目标地址。它们需要两个 $ID$ 周期，且不使用 $MEM$ 或 $WB$ 状态。\n  序列：$IF \\rightarrow ID \\rightarrow ID \\rightarrow EX$。\n  周期数：$C_{B, \\text{baseline}} = 4$。\n\n平均CPI是每条指令的周期数与其出现概率的乘积之和。给定的概率为 $p_{R} = 0.75$、$p_{L} = 0.10$、$p_{S} = 0.10$ 和 $p_{B} = 0.05$。\n\n基准CPI计算如下：\n$$ \\mathrm{CPI}_{\\text{baseline}} = p_{R} C_{R, \\text{baseline}} + p_{L} C_{L, \\text{baseline}} + p_{S} C_{S, \\text{baseline}} + p_{B} C_{B, \\text{baseline}} $$\n$$ \\mathrm{CPI}_{\\text{baseline}} = (0.75)(5) + (0.10)(5) + (0.10)(5) + (0.05)(4) $$\n$$ \\mathrm{CPI}_{\\text{baseline}} = 3.75 + 0.50 + 0.50 + 0.20 = 4.95 $$\n\n**2. 修改后架构分析**\n\n修改为寄存器堆 RF 增加了一个读端口，允许在单个 $ID$ 周期内读取两个寄存器。这影响了需要读取两个寄存器的指令（R型、S型和B型）。\n\n新的最小状态序列如下：\n\n- **R型指令：** 由于在一个 $ID$ 周期内读取两个寄存器，序列被缩短。\n  新序列：$IF \\rightarrow ID \\rightarrow EX \\rightarrow WB$。\n  新周期数：$C_{R, \\text{modified}} = 4$。\n\n- **加载 ($L$) 指令：** 不变，如问题所述。\n  序列：$IF \\rightarrow ID \\rightarrow EX \\rightarrow MEM \\rightarrow WB$。\n  周期数：$C_{L, \\text{modified}} = 5$。\n\n- **存储 ($S$) 指令：** 两次寄存器读取现在在一个 $ID$ 周期内完成。\n  新序列：$IF \\rightarrow ID \\rightarrow EX \\rightarrow MEM$。\n  新周期数：$C_{S, \\text{modified}} = 4$。\n\n- **分支 ($B$) 指令：** 用于比较的两次寄存器读取在一个 $ID$ 周期内完成。\n  新序列：$IF \\rightarrow ID \\rightarrow EX$。\n  新周期数：$C_{B, \\text{modified}} = 3$。\n\n修改后的CPI使用新的周期数计算如下：\n$$ \\mathrm{CPI}_{\\text{modified}} = p_{R} C_{R, \\text{modified}} + p_{L} C_{L, \\text{modified}} + p_{S} C_{S, \\text{modified}} + p_{B} C_{B, \\text{modified}} $$\n$$ \\mathrm{CPI}_{\\text{modified}} = (0.75)(4) + (0.10)(5) + (0.10)(4) + (0.05)(3) $$\n$$ \\mathrm{CPI}_{\\text{modified}} = 3.00 + 0.50 + 0.40 + 0.15 = 4.05 $$\n\n**3. $\\Delta \\mathrm{CPI}$ 的计算**\n\n平均CPI的变化量是基准CPI值与修改后CPI值之差。\n$$ \\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{baseline}} - \\mathrm{CPI}_{\\text{modified}} $$\n$$ \\Delta \\mathrm{CPI} = 4.95 - 4.05 = 0.90 $$\n\n或者，我们可以直接计算变化量。该修改为先前需要两个 $ID$ 周期的每类指令（R型、S型和B型）节省了恰好一个周期。每类指令的周期变化量为：\n- $\\Delta C_{R} = C_{R, \\text{baseline}} - C_{R, \\text{modified}} = 5 - 4 = 1$\n- $\\Delta C_{L} = C_{L, \\text{baseline}} - C_{L, \\text{modified}} = 5 - 5 = 0$\n- $\\Delta C_{S} = C_{S, \\text{baseline}} - C_{S, \\text{modified}} = 5 - 4 = 1$\n- $\\Delta C_{B} = C_{B, \\text{baseline}} - C_{B, \\text{modified}} = 4 - 3 = 1$\n\nCPI的总变化量是这些周期变化量的加权和：\n$$ \\Delta \\mathrm{CPI} = p_{R} \\Delta C_{R} + p_{L} \\Delta C_{L} + p_{S} \\Delta C_{S} + p_{B} \\Delta C_{B} $$\n$$ \\Delta \\mathrm{CPI} = (0.75)(1) + (0.10)(0) + (0.10)(1) + (0.05)(1) $$\n$$ \\Delta \\mathrm{CPI} = 0.75 + 0 + 0.10 + 0.05 = 0.90 $$\nCPI的变化量恰好是那些被加速的指令类别的概率之和，因为每种被加速的指令都减少了一个周期。\n\n$\\Delta \\mathrm{CPI}$ 的最终数值为 $0.90$。",
            "answer": "$$\\boxed{0.9}$$"
        },
        {
            "introduction": "一个高效的数据通路固然重要，但保证其正确性是设计的前提。本练习将你置于一个典型的调试场景中，你需要通过分析一系列执行快照来诊断一个隐藏的控制信号故障。这个过程将锻炼你像工程师一样思考，从行为反推错误根源的宝贵能力。",
            "id": "3660319",
            "problem": "一个多周期数据通路被用于执行加载和存储指令，它将每条指令分解为一系列微状态，每个微状态都包含寄存器传输和受控的资源使用。该设计包括以下架构寄存器和组件：程序计数器 (PC)、指令寄存器 (IR)、内存地址寄存器 (MAR)、内存数据寄存器 (MDR)、带有输出 $A$ 和 $B$ 的寄存器文件、带有输出锁存器 $ALUOut$ 的算术逻辑单元 (ALU)，以及一条内部系统总线 (SB)，每个周期由三态驱动器将一个源门控到该总线上。当 $MARWrite$ 置为有效时，内存地址寄存器 (MAR) 从系统总线 (SB) 锁存数据。在加载/存储路径中，有效地址计算的预期行为是：ALU 计算 $A + \\text{SignExt}(\\text{imm})$，将结果锁存到 $ALUOut$ 中，然后由 $ALUOut$ 驱动系统总线 (SB)，并在 $MARWrite$ 置为有效时，由 $MAR$ 锁存这个地址。在指令获取状态中，系统总线 (SB) 由 $PC$ 驱动，$MAR$ 也以类似的方式锁存指令地址。\n\n与此片段相关的控制线包括 $GatePC$、$GateALUOut$、$GateB$（每个都使一个源能够驱动系统总线（SB））、$MARWrite$（将 $SB$ 锁存到 $MAR$ 中）、$ALUSrcA$（选择ALU输入是 $A$ 还是 $PC$）、$ALUSrcB$（在 $B$、常数 $4$、符号扩展的立即数或移位的立即数之间进行选择）以及 $ALUOp$（选择ALU操作）。对于一个字加载指令，教科书式的微操作是：译码和寄存器读取（$A \\leftarrow \\text{Reg}[rs]$, $B \\leftarrow \\text{Reg}[rt]$），有效地址计算（$ALUOut \\leftarrow A + \\text{SignExt}(\\text{imm})$，然后通过系统总线（SB）$MAR \\leftarrow ALUOut$），内存读取（$MDR \\leftarrow M[MAR]$），以及写回（$\\text{Reg}[rt] \\leftarrow MDR$）。对于一个字存储指令，有效地址计算和内存写入是类似的，但写入的数据是 $B$。\n\n考虑以下带有每个状态快照的监测执行，其执行序列为：$\\mathrm{lw}\\ r2, 8(r1)$ 紧跟着 $\\mathrm{sw}\\ r3, 12(r1)$。初始条件为 $PC = \\mathrm{0x00400000}$，$\\text{Reg}[r1] = \\mathrm{0x1000}$，$\\text{Reg}[r2] = \\mathrm{0x5555AAAA}$，$\\text{Reg}[r3] = \\mathrm{0xDEADBEEF}$。内存内容包括 $M[\\mathrm{0x1008}] = \\mathrm{0xABCD1234}$，$M[\\mathrm{0x100C}] = \\mathrm{0x13579BDF}$，$M[\\mathrm{0x5555AAAA}] = \\mathrm{0xCAFEBABE}$，以及 $M[\\mathrm{0xDEADBEEF}] = \\mathrm{0x2468ACE0}$。\n\n观察到的 $\\mathrm{lw}\\ r2, 8(r1)$ 的快照：\n- 译码结束时：$A = \\mathrm{0x1000}$，$B = \\mathrm{0x5555AAAA}$，$IR$ 立即数 $= \\mathrm{0x0008}$。\n- 有效地址状态结束时：$ALUOut = \\mathrm{0x1008}$，$MAR = \\mathrm{0x5555AAAA}$。\n- 内存读取结束时：$MDR = \\mathrm{0xCAFEBABE}$。\n- 写回结束时：$\\text{Reg}[r2] = \\mathrm{0xCAFEBABE}$。\n\n观察到的 $\\mathrm{sw}\\ r3, 12(r1)$ 的快照：\n- 译码结束时：$A = \\mathrm{0x1000}$，$B = \\mathrm{0xDEADBEEF}$，$IR$ 立即数 $= \\mathrm{0x000C}$。\n- 有效地址状态结束时：$ALUOut = \\mathrm{0x100C}$，$MAR = \\mathrm{0xDEADBEEF}$。\n- 内存写入结束时：$M[\\mathrm{0xDEADBEEF}] = \\mathrm{0xDEADBEEF}$，而 $M[\\mathrm{0x100C}]$ 保持为 $\\mathrm{0x13579BDF}$。\n\n根据多周期数据通路的基本原理操作，基本依据如下：\n- 加载/存储的有效地址由 ALU 计算为 $A + \\text{SignExt}(\\text{imm})$，并应被锁存到 $ALUOut$ 中。\n- 内存地址寄存器 (MAR) 必须在 $ALUOut$ 被门控到系统总线 (SB) 上且 $MARWrite$ 被置为有效时，通过采样系统总线 (SB) 来锁存这个由 ALU 产生的有效地址。\n- $B$ 寄存器保存着从寄存器文件读取的第二个操作数，在有效地址状态下，它不是 MAR 的地址来源。\n\n根据提供的每个状态的快照，选择唯一最可能的、能解释该行为的错误控制，这个错误可以通过一个在有效地址状态下比较 $ALUOut$、$MAR$ 和系统总线 (SB) 驱动器选择的调试计划来隔离：\n\nA. 在有效地址状态下，$GateB$ 被错误地置为有效，而 $GateALUOut$ 被取消有效，因此当 $MARWrite$ 置为有效时，$MAR$ 锁存了 $B$ 的值。\n\nB. $ALUSrcB$ 被错误配置为选择常数 $4$，导致 $ALUOut$ 成为 $A + 4$，这接着误导了 $MAR$；快照显示 $MAR$ 的值不同是因为 $ALUOut$ 是错误的。\n\nC. 在指令获取期间，$IRWrite$ 被错误地置为有效，损坏了 $IR$，导致译码阶段读取了错误的寄存器；这间接导致了 $MAR$ 获取了 $B$ 的值。\n\nD. 在有效地址状态期间，$PCWrite$ 被错误地置为有效，使 $PC$ 前进并损坏了到 $MAR$ 的地址路径，导致 $MAR$ 反映了 $B$ 的值而不是 ALU 的结果。",
            "solution": "用户提供了一个关于有故障的多周期数据通路的问题，并要求根据执行快照进行诊断。我的任务是首先验证问题陈述，如果有效，则推导出解决方案并评估给定的选项。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n\n-   **架构**：多周期数据通路，包含寄存器 PC、IR、MAR、MDR；寄存器文件输出 A 和 B；带输出锁存器 ALUOut 的 ALU；一条内部系统总线 (SB)。\n-   **数据传输**：源通过三态驱动器门控到 SB 上。当 $MARWrite$ 置为有效时，MAR 从 SB 锁存数据。\n-   **控制线**：$GatePC$、$GateALUOut$、$GateB$（使源能够驱动 SB）、$MARWrite$（将 SB 锁存到 MAR 中）、$ALUSrcA$、$ALUSrcB$、$ALUOp$。\n-   **预期的 `lw`/`sw` 有效地址状态**：\n    1.  ALU 计算地址：$A + \\text{SignExt}(\\text{imm})$。\n    2.  结果被锁存到 ALUOut：$ALUOut \\leftarrow A + \\text{SignExt}(\\text{imm})$。\n    3.  ALUOut 驱动系统总线：$GateALUOut$ 置为有效。\n    4.  MAR 从总线锁存地址：$MARWrite$ 置为有效，因此 $MAR \\leftarrow ALUOut$。\n-   **预期的 `lw` 微操作**：\n    1.  译码/读取：$A \\leftarrow \\text{Reg}[rs]$, $B \\leftarrow \\text{Reg}[rt]$。\n    2.  地址计算：$ALUOut \\leftarrow A + \\text{SignExt}(\\text{imm})$，然后 $MAR \\leftarrow ALUOut$。\n    3.  内存读取：$MDR \\leftarrow M[MAR]$。\n    4.  写回：$\\text{Reg}[rt] \\leftarrow MDR$。\n-   **初始状态**：\n    -   $PC = \\mathrm{0x00400000}$\n    -   $\\text{Reg}[r1] = \\mathrm{0x1000}$\n    -   $\\text{Reg}[r2] = \\mathrm{0x5555AAAA}$\n    -   $\\text{Reg}[r3] = \\mathrm{0xDEADBEEF}$\n-   **初始内存**：\n    -   $M[\\mathrm{0x1008}] = \\mathrm{0xABCD1234}$\n    -   $M[\\mathrm{0x100C}] = \\mathrm{0x13579BDF}$\n    -   $M[\\mathrm{0x5555AAAA}] = \\mathrm{0xCAFEBABE}$\n    -   $M[\\mathrm{0xDEADBEEF}] = \\mathrm{0x2468ACE0}$\n-   **观察到的 `lw r2, 8(r1)` 的快照**：\n    -   译码结束时：$A = \\mathrm{0x1000}$，$B = \\mathrm{0x5555AAAA}$，$IR$ 立即数 $= \\mathrm{0x0008}$。\n    -   有效地址状态结束时：$ALUOut = \\mathrm{0x1008}$，$MAR = \\mathrm{0x5555AAAA}$。\n    -   内存读取结束时：$MDR = \\mathrm{0xCAFEBABE}$。\n    -   写回结束时：$\\text{Reg}[r2] = \\mathrm{0xCAFEBABE}$。\n-   **观察到的 `sw r3, 12(r1)` 的快照**：\n    -   译码结束时：$A = \\mathrm{0x1000}$，$B = \\mathrm{0xDEADBEEF}$，$IR$ 立即数 $= \\mathrm{0x000C}$。\n    -   有效地址状态结束时：$ALUOut = \\mathrm{0x100C}$，$MAR = \\mathrm{0xDEADBEEF}$。\n    -   内存写入结束时：$M[\\mathrm{0xDEADBEEF}] = \\mathrm{0xDEADBEEF}$。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n问题描述了计算机体系结构中的一个经典调试场景。数据通路模型、微操作和控制信号都是多周期实现的标准配置。我将检查其内部一致性。\n\n-   **`lw r2, 8(r1)` 的分析**：\n    -   指令字段：$rs=r1$, $rt=r2$, 立即数$=8$。\n    -   译码：$A = \\text{Reg}[r1] = \\mathrm{0x1000}$，$B = \\text{Reg}[r2] = \\mathrm{0x5555AAAA}$。与快照匹配。此阶段正确。\n    -   有效地址：预期的 ALU 计算：$ALUOut \\leftarrow A + \\text{SignExt}(imm) = \\mathrm{0x1000} + \\mathrm{0x8} = \\mathrm{0x1008}$。快照显示 $ALUOut = \\mathrm{0x1008}$。ALU 计算正确。预期的 MAR 加载：$MAR \\leftarrow ALUOut$。我们期望 $MAR=\\mathrm{0x1008}$。快照显示 $MAR = \\mathrm{0x5555AAAA}$。这是一个差异。加载到 $MAR$ 的值是来自寄存器 $B$ 的值。\n    -   内存读取：$MDR \\leftarrow M[MAR]$。在 $MAR$ 错误的情况下，操作是 $MDR \\leftarrow M[\\mathrm{0x5555AAAA}]$。根据已知信息，$M[\\mathrm{0x5555AAAA}] = \\mathrm{0xCAFEBABE}$。快照 $MDR = \\mathrm{0xCAFEBABE}$ 与错误的 $MAR$ 一致。\n    -   写回：$\\text{Reg}[r2] \\leftarrow MDR$。操作是 $\\text{Reg}[r2] \\leftarrow \\mathrm{0xCAFEBABE}$。快照证实了这一点。\n\n-   **`sw r3, 12(r1)` 的分析**：\n    -   指令字段：$rs=r1$, $rt=r3$, 立即数$=12$。\n    -   译码：$A = \\text{Reg}[r1] = \\mathrm{0x1000}$，$B = \\text{Reg}[r3] = \\mathrm{0xDEADBEEF}$。与快照匹配。\n    -   有效地址：预期的 ALU 计算：$ALUOut \\leftarrow A + \\text{SignExt}(imm) = \\mathrm{0x1000} + \\mathrm{0xC} = \\mathrm{0x100C}$。快照显示 $ALUOut = \\mathrm{0x100C}$。ALU 计算仍然正确。预期的 MAR 加载：$MAR \\leftarrow ALUOut$。我们期望 $MAR=\\mathrm{0x100C}$。快照显示 $MAR = \\mathrm{0xDEADBEEF}$。差异是一致的：$MAR$ 被加载了寄存器 $B$ 的值。\n    -   内存写入：$M[MAR] \\leftarrow B$。在 $MAR$ 错误的情况下，操作是 $M[\\mathrm{0xDEADBEEF}] \\leftarrow B$。由于 $B = \\mathrm{0xDEADBEEF}$，机器将 $\\mathrm{0xDEADBEEF}$ 写入地址 $\\mathrm{0xDEADBEEF}$。快照证实了这一点。\n\n问题陈述在科学上是合理的、阐述清晰且客观的。所提供的数据和观察到的快照内部一致，并指向一个特定的、可重复的故障。\n\n**步骤 3：结论和行动**\n\n问题陈述是 **有效的**。我将继续进行解答。\n\n### 正确答案的推导\n\n问题的核心在于加载和存储指令在有效地址状态期间观察到的差异。\n\n1.  **识别故障**：\n    -   在两次观察到的指令执行中，ALU 都正确地计算了有效内存地址（$A + \\text{SignExt}(\\text{imm})$）并将此值锁存到 $ALUOut$ 寄存器中。这一点由快照证实：对于 `lw`，$ALUOut=\\mathrm{0x1008}$；对于 `sw`，$ALUOut=\\mathrm{0x100C}$。\n    -   预期序列中的下一步是通过系统总线 (SB) 将此地址从 $ALUOut$ 传输到内存地址寄存器 ($MAR$) 。预期的操作是 $MAR \\leftarrow ALUOut$。\n    -   然而，在这两种情况下，锁存到 $MAR$ 中的值都不是来自 $ALUOut$。相反，$MAR$ 接收的是来自寄存器输出 $B$ 的值。\n        -   对于 `lw`：$MAR$ 变为 $\\mathrm{0x5555AAAA}$，这是 $B$ 的值（$\\text{Reg}[r2]$）。\n        -   对于 `sw`：$MAR$ 变为 $\\mathrm{0xDEADBEEF}$，这是 $B$ 的值（$\\text{Reg}[r3]$）。\n    -   这意味着在写入 $MAR$ 的微状态中，系统总线 (SB) 是由寄存器 $B$ 的输出驱动的，而不是由 $ALUOut$ 锁存器的输出驱动的。\n\n2.  **将故障与控制信号关联**：\n    -   数据到 $MAR$ 的传输由 $MARWrite$ 信号控制。由于 $MAR$ 被更新了（尽管值是错误的），我们可以推断 $MARWrite$ 被正确地置为有效。\n    -   系统总线 (SB) 的数据来源由一组“门控”控制信号决定，例如 $GateALUOut$ 和 $GateB$。由于总线是用三态驱动器实现的，任何时候只有一个源可以驱动总线。\n    -   在此状态下，预期的控制序列是置位 $GateALUOut$ 以将 $ALUOut$ 的内容放到总线上。\n    -   观察到的行为，即来自 $B$ 的值出现在总线上，唯一的解释是控制逻辑错误地置位了 $GateB$，并因此取消了 $GateALUOut$ 的置位。\n\n3.  **诊断结论**：\n    -   故障是有效地址状态下的一个控制逻辑错误。具体来说，在加载 MAR 的周期中，控制信号 $GateB$ 被置为有效，而不是正确的信号 $GateALUOut$。\n\n### 选项评估\n\n-   **A. 在有效地址状态下，$GateB$ 被错误地置为有效，而 $GateALUOut$ 被取消有效，因此当 $MARWrite$ 置为有效时，$MAR$ 锁存了 $B$ 的值。**\n    -   该陈述精确地描述了从证据中诊断出的故障。如果 $GateB$ 被置为有效，总线将由寄存器 $B$ 中的值驱动。当 $MARWrite$ 置为有效时，$MAR$ 将锁存这个不正确的值。这完美地解释了为什么对于 `lw`，$MAR$ 变为 $\\mathrm{0x5555AAAA}$，对于 `sw`，$MAR$ 变为 $\\mathrm{0xDEADBEEF}$。\n    -   **结论：正确**\n\n-   **B. $ALUSrcB$ 被错误配置为选择常数 $4$，导致 $ALUOut$ 成为 $A + 4$，这接着误导了 $MAR$；快照显示 $MAR$ 的值不同是因为 $ALUOut$ 是错误的。**\n    -   这个选项声称 $ALUOut$ 中的值不正确。提供的快照明确地反驳了这一点。对于 `lw`，$ALUOut$ 是 $\\mathrm{0x1008}$（即 $\\mathrm{0x1000} + 8$，而不是 $\\mathrm{0x1000} + 4$）。对于 `sw`，$ALUOut$ 是 $\\mathrm{0x100C}$（即 $\\mathrm{0x1000} + 12$）。ALU 正在正常工作。\n    -   **结论：不正确**\n\n-   **C. 在指令获取期间，$IRWrite$ 被错误地置为有效，损坏了 $IR$，导致译码阶段读取了错误的寄存器；这间接导致了 $MAR$ 获取了 $B$ 的值。**\n    -   这个选项声称指令在译码前就被损坏了。然而，两条指令的“译码结束时”快照都显示，正确的寄存器文件输出（$A$ 和 $B$）和正确的立即数值都是可用的。这意味着 $IR$ 中的指令是正确的，并且译码阶段操作正确。\n    -   **结论：不正确**\n\n-   **D. 在有效地址状态期间，$PCWrite$ 被错误地置为有效，使 $PC$ 前进并损坏了到 $MAR$ 的地址路径，导致 $MAR$ 反映了 $B$ 的值而不是 ALU 的结果。**\n    -   这个选项提出了一个不相关的故障。置位 $PCWrite$ 会影响程序计数器，而在此状态下，程序计数器不是从 ALU 或寄存器 B 到 MAR 的数据通路的一部分。它没有提供一种机制，可以让 B 的值被选择来驱动系统总线并被 MAR 锁存。症状（$MAR \\leftarrow B$）要求总线门控逻辑存在故障，而这个选项没有解决这个问题。\n    -   **结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}