{
    "hands_on_practices": [
        {
            "introduction": "Understanding a barrel shifter begins with its fundamental operation. This first exercise challenges you to trace the path of a data word through a simple logical right shifter built from multiplexers. By manually determining the output for a given input and shift amount, you will build a concrete mental model of how control signals select and route data to perform the shift operation. ",
            "id": "1908624",
            "problem": "A 4-bit logical right barrel shifter is a combinational logic circuit that shifts a 4-bit input word to the right by a specified number of bit positions. The number of positions to shift is determined by a 2-bit control input.\n\nThe shifter takes a 4-bit data input word, $A = A_3A_2A_1A_0$, where $A_3$ is the most significant bit (MSB). It also takes a 2-bit control word, $S = S_1S_0$. The unsigned binary integer value of $S$ dictates the shift amount, which can be 0, 1, 2, or 3 positions. The circuit produces a 4-bit output word, $Y = Y_3Y_2Y_1Y_0$.\n\nThis particular shifter performs a \"logical\" right shift, meaning that as bits are shifted to the right, zeros are filled in from the MSB side. Any bits shifted out from the least significant bit (LSB) side are discarded.\n\nThe circuit is implemented using four 4-to-1 multiplexers (MUX), one for each output bit $Y_i$. A 4-to-1 MUX has four data inputs, denoted $I_0, I_1, I_2, I_3$, and two select lines. The output of the MUX is equal to the data input $I_k$, where $k$ is the unsigned integer value represented by the two select lines. In this barrel shifter design, the control bits $S_1$ and $S_0$ are connected to the select lines of all four multiplexers.\n\nGiven an input data word $A = 1011_2$ and a control word $S = 10_2$, determine the resulting 4-bit output word $Y$. Express your answer as a 4-digit binary string (e.g., 1010).",
            "solution": "A logical right shift by $k$ positions maps each output bit $Y_i$ from an input bit $A_{i+k}$ if the source index is within the word boundary, or from 0 otherwise. The mapping is:\n$$\nY_{i}=\\begin{cases}\nA_{i+k},  \\text{if } i+k \\le 3 \\\\\n0,  \\text{if } i+k > 3\n\\end{cases}\n$$\nThe control word is $S=10_{2}$, so the shift amount is $k=2$. The input is $A=A_{3}A_{2}A_{1}A_{0}=1011$, hence $A_{3}=1$, $A_{2}=0$, $A_{1}=1$, $A_{0}=1$.\n\nWe evaluate each output bit:\n- For $i=3$: $3+2 > 3$, so $Y_{3}=0$.\n- For $i=2$: $2+2 > 3$, so $Y_{2}=0$.\n- For $i=1$: $1+2=3 \\le 3$, so $Y_{1}=A_{3}=1$.\n- For $i=0$: $0+2=2 \\le 3$, so $Y_{0}=A_{2}=0$.\n\nThus the output word is $Y=Y_3Y_2Y_1Y_0 = 0010$.\n\nEquivalently, from the multiplexer perspective: with the select lines $S_1S_0=10_2$, each MUX selects its $I_2$ input. For the MUX generating output $Y_i$, its $I_2$ input is wired to receive $A_{i+2}$ if $i+2 \\le 3$, and wired to logic 0 otherwise. This yields the same result: $Y=0010$.",
            "answer": "$$\\boxed{0010}$$"
        },
        {
            "introduction": "A powerful barrel shifter is not just a one-trick pony; it's a versatile tool in the processor's datapath. This practice explores the clever design principles that allow a single shifter core, built for one type of operation, to support others. You will analyze the mathematical relationships between different shift types and the structural limitations of the hardware, a key skill in efficient resource utilization in processor design. ",
            "id": "3621848",
            "problem": "An $n$-bit barrel shifter is built as a logarithmic-stage multiplexer network that can perform rotate-right by any amount $k$ with $0 \\leq k  n$. A rotate-right by $k$ maps each output bit position $i$ to the input bit at position $(i + k) \\bmod n$, whereas a rotate-left by $k$ maps each output bit position $i$ to the input bit at position $(i - k) \\bmod n$. The control field presented to the barrel shifter is an encoded shift amount of $\\lceil \\log_2 n \\rceil$ bits. You wish to support rotate-left using the existing rotate-right hardware by transforming the requested amount $k$ into $k' = (n - k) \\bmod n$, and also to determine whether arithmetic right shifts can be realized by reusing the same network. Arithmetic Shift Right (ASR) is defined as a right shift that fills vacated most significant bit positions with the original sign bit (the most significant bit of the input), while Logical Shift Right (LSR) fills vacated positions with zeros. Consider the following statements about control encoding and hardware reuse.\n\nWhich statements are correct?\n\nA. For all $n$ and all $k$ with $0 \\leq k  n$, rotate-left by $k$ is equivalent to rotate-right by $k' = (n - k) \\bmod n$, because the index mapping $i \\mapsto (i - k) \\bmod n$ equals $i \\mapsto (i + k') \\bmod n$.\n\nB. To support both rotate-left and rotate-right using the same rotate-right hardware, the control field must be widened from $\\lceil \\log_2 n \\rceil$ bits to $\\lceil \\log_2 n \\rceil + 1$ bits to encode direction; there is no alternative that avoids adding any control bits.\n\nC. A rotate-only barrel shifter that is a pure permutation network cannot realize Arithmetic Shift Right (ASR) by simply reinterpreting rotation control, because ASR requires inserting copies of the sign bit into multiple vacated positions, which is not a permutation of the input bits.\n\nD. If the network is augmented with an additional selectable source that replicates the sign bit onto $n$ lines and a mode control that chooses between wrap-around (for rotate), zero-fill (for logical shifts), and sign-fill (for ASR), the same multiplexer stage structure can implement rotate-right, rotate-left, Logical Shift Right (LSR), and Arithmetic Shift Right (ASR) without changing the number of stages.\n\nE. In twoâ€™s complement arithmetic, Arithmetic Shift Left by $1$ differs from Logical Shift Left by $1$ because it must insert the previous sign bit into the least significant bit; therefore, it requires sign-aware hardware distinct from logical left shift.",
            "solution": "### Analysis of the Statements\n\n**Statement A: Correct.**\nA rotate-left by $k$ is equivalent to a rotate-right by $n-k$ on an $n$-bit word. The index mapping for rotate-left sends an input bit from position $(i - k) \\pmod n$ to output position $i$. The mapping for rotate-right by $k' = (n - k) \\pmod n$ sends an input bit from position $(i + k') \\pmod n = (i + (n-k)) \\pmod n = (i - k) \\pmod n$ to output position $i$. The mappings are identical.\n\n**Statement B: Incorrect.**\nThis statement claims that adding a direction bit is the *only* way. This is false. The number of control patterns from $\\lceil \\log_2 n \\rceil$ bits is $2^{\\lceil \\log_2 n \\rceil}$, which is greater than $n$ unless $n$ is a power of two. If $n$ is not a power of two, there are unused control codes. These unused codes could be assigned to represent specific left-rotation amounts, providing an alternative to adding a new control bit.\n\n**Statement C: Correct.**\nA rotation is a permutation, meaning every input bit maps to exactly one output bit. An Arithmetic Shift Right (ASR) by $k > 0$ is not a permutation. The sign bit (MSB) is copied to $k$ vacated bit positions, a one-to-many mapping. At the same time, the $k$ least significant bits are discarded and do not map to any output. A pure permutation network, like a rotate-only shifter, cannot implement this non-permutation behavior by simply reinterpreting control signals.\n\n**Statement D: Correct.**\nThis describes a standard architecture for a universal shifter, often called a \"funnel shifter\". The core logarithmic MUX network, which performs the actual shifting, can be preceded by logic that prepares a wider input word. This pre-shifter logic selects the \"fill bits\" based on a mode control: wrap-around bits for rotation, zeros for logical shifts, or copies of the sign bit for arithmetic shifts. This design reuses the main shifter stages and adds functionality without altering the number of stages.\n\n**Statement E: Incorrect.**\nIn standard two's complement arithmetic, Arithmetic Shift Left (ASL) and Logical Shift Left (LSL) are identical operations. Both shift bits to the left and fill the vacated least significant bit(s) with zeros. This operation is equivalent to multiplication by two. An LSL by 1 on a value $X$ produces $2X$, which must be an even number, meaning its LSB must be 0. Inserting the sign bit (which could be 1) would violate this mathematical property. Therefore, ASL and LSL do not require distinct hardware.\n\nThe correct statements are A, C, and D.",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "In modern high-frequency CPUs, speed is paramount, and the delay of a combinational circuit like a barrel shifter can become a bottleneck. This final problem moves from logical design to physical performance, asking you to apply the crucial technique of pipelining. You will calculate the minimum number of pipeline stages needed to meet a demanding clock target, connecting the shifter's layered structure to fundamental timing constraints in synchronous systems. ",
            "id": "3621820",
            "problem": "A $64$-bit logical barrel shifter is implemented using the standard layered architecture: the input word passes through $L$ identical layers of $2:1$ multiplexers, where each layer conditionally shifts by $2^{\\ell}$ positions for $\\ell \\in \\{0,1,2,3,4,5\\}$, and $L = \\log_{2}(64)$. Assume the worst-case combinational propagation delay of a single shifter layer (one multiplexer layer) is $t_s$ seconds, identical for all layers, and ignore wire skew and register overhead (that is, treat edge-triggered registers as ideal with negligible setup and clock-to-$Q$ times). The target clock frequency is $1\\,\\text{GHz}$.\n\nYou may pipeline the shifter by inserting $p-1$ banks of edge-triggered registers between the $L$ layers, thereby partitioning the $L$ layers into $p$ pipeline stages. Each pipeline stage contains an integer number of complete layers. The clock period is $T_{\\text{clk}} = 1/1\\,\\text{GHz}$. Assume $0  t_s \\leq T_{\\text{clk}}$ so that at least one complete layer can meet the clock period.\n\nStarting only from the following foundational facts:\n- The total worst-case combinational delay along any path equals the sum of the layer delays encountered on that path.\n- In a synchronous pipeline, the maximum clock frequency is limited by the worst-case combinational delay contained within any single pipeline stage, which must not exceed the clock period.\n\n1. Derive, in closed form, the minimal integer number of pipeline stages $p$ required to meet the $1\\,\\text{GHz}$ clock target as a function of $t_s$ only. Your expression must be valid for all $t_s$ satisfying $0  t_s \\leq T_{\\text{clk}}$, and it must account for the integrality of layers per stage.\n2. Briefly outline a systematic rule for placing the $p-1$ register banks across the $L$ layers to satisfy the timing constraint while minimizing the maximum number of layers per stage.\n\nExpress your final answer to part 1 as a single simplified analytic expression in terms of $t_s$ only. Treat $t_s$ in seconds. No numerical rounding is required.",
            "solution": "First, we establish the key parameters of the system.\n- Total layers in the shifter: $L = \\log_{2}(64) = 6$.\n- Target clock frequency: $f_{\\text{clk}} = 1\\,\\text{GHz}$.\n- Target clock period: $T_{\\text{clk}} = \\frac{1}{f_{\\text{clk}}} = \\frac{1}{1 \\times 10^9\\,\\text{Hz}} = 10^{-9}\\,\\text{s}$.\n- Delay per layer: $t_s$.\n\nThe core timing constraint for a pipelined system is that the combinational delay within any single stage must not exceed the clock period. Let $k$ be the number of shifter layers in a given pipeline stage. The delay of this stage is $k \\times t_s$. The constraint is:\n$$k \\times t_s \\leq T_{\\text{clk}}$$\nSince each stage must contain an integer number of layers, the maximum number of layers that can be grouped into a single stage, $k_{\\text{max}}$, is the greatest integer that satisfies this inequality:\n$$k_{\\text{max}} = \\left\\lfloor \\frac{T_{\\text{clk}}}{t_s} \\right\\rfloor = \\left\\lfloor \\frac{10^{-9}}{t_s} \\right\\rfloor$$\nThe condition $0  t_s \\leq T_{\\text{clk}}$ ensures that $k_{\\text{max}} \\geq 1$.\n\nTo find the minimum number of pipeline stages, $p$, we must partition the total of $L=6$ layers into the fewest possible groups, where no group has more than $k_{\\text{max}}$ layers. This is a classic division problem. The total number of layers must be covered:\n$$p \\times k_{\\text{max}} \\geq L$$\nSolving for the minimum integer $p$ gives:\n$$p = \\left\\lceil \\frac{L}{k_{\\text{max}}} \\right\\rceil$$\n\n1.  **Closed-form expression for $p$:**\n    Substituting the expressions for $L$ and $k_{\\text{max}}$, we get the minimal number of pipeline stages as a function of $t_s$:\n    $$p(t_s) = \\left\\lceil \\frac{6}{\\left\\lfloor \\frac{10^{-9}}{t_s} \\right\\rfloor} \\right\\rceil$$\n    This expression holds for the entire specified range $0  t_s \\leq 10^{-9}\\,\\text{s}$.\n\n2.  **Rule for placing register banks:**\n    To satisfy the timing constraint while minimizing the maximum number of layers per stage, the $L=6$ layers should be distributed as evenly as possible among the $p$ stages. A systematic rule is:\n    a. Calculate the base number of layers per stage: $q = \\lfloor L/p \\rfloor$.\n    b. Calculate the number of stages that will get an extra layer: $r = L \\pmod p$.\n    c. Allocate $q+1$ layers to $r$ of the stages, and $q$ layers to the remaining $p-r$ stages.\n    \n    The $p-1$ register banks are placed after each consecutive group of layers. This ensures the most balanced pipeline, where the maximum logic depth in any stage is $\\lceil L/p \\rceil$, which is guaranteed to be less than or equal to $k_{\\text{max}}$.",
            "answer": "$$\n\\boxed{\n\\left\\lceil \\frac{6}{\\left\\lfloor \\frac{10^{-9}}{t_s} \\right\\rfloor} \\right\\rceil\n}\n$$"
        }
    ]
}