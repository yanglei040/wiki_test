{
    "hands_on_practices": [
        {
            "introduction": "布斯算法通过处理连续的1和0来减少部分积的数量，从而加速乘法运算。本练习旨在通过探索该算法的最佳和最差情况下的输入位模式，帮助您深入理解其核心工作原理。通过分析不同位模式如何影响部分积的数量，您将能更清晰地认识到布斯算法的效率来源及其局限性。",
            "id": "3652101",
            "problem": "考虑使用有符号4基布斯重编码，将一个固定宽度$n$位二进制补码乘数$Q$与一个$n$位二进制补码被乘数$M$相乘。设$Q$的位为$q_{n-1}\\dots q_{1}q_{0}$，其中$q_{k}\\in\\{0,1\\}$，并定义一个辅助位$q_{-1}=0$。在4基布斯重编码中，乘数$Q$被重写为一系列带符号的4基数位$d_{i}\\in\\{-2,-1,0,+1,+2\\}$的和，其位权为$4^{i}$。这些数位由重叠的三位数组$\\left(q_{2i+1},q_{2i},q_{2i-1}\\right)$（其中$i=0,1,\\dots$）形成。因此，部分积为$d_{i}\\cdot M\\cdot 4^{i}$，非零部分积的数量等于$d_{i}\\neq 0$的索引$i$的个数。布斯重编码的目的是通过对$Q$中连续的相同位进行编码，来减少非零部分积的数量。\n\n关于$Q$的位模式以及在有符号4基布斯重编码下产生的非零部分积数量，以下哪些陈述是正确的？\n\nA. 对于$Q=00\\cdots 0$（所有位都为$0$），非零部分积的数量为$0$。对于$Q=11\\cdots 1$（所有位都为$1$，在二进制补码中表示$-1$），非零部分积的数量恰好为$1$，与$n$无关。\n\nB. 在所有$n$位模式中，诸如$Q=10\\,10\\,\\cdots$或$Q=01\\,01\\,\\cdots$的交替位模式会使非零部分积的数量最大化，且其数量等于$\\lceil n/2\\rceil$。\n\nC. 一个单独的连续的1序列，$Q=00\\cdots 0111\\cdots 100\\cdots 0$，会使非零部分积的数量最大化，因为每个三位数组必须重编码为$+2$或$-2$。\n\nD. 对于$n$位的$Q$，在有符号4基布斯重编码下，非零部分积的最大可能数量为$n$，这在$Q$为交替模式$10\\,10\\,\\cdots$时实现。\n\n选择所有正确的选项，并从二进制补码的基本位级解释以及有符号4基布斯重编码的第一性原理（将位分组为重叠的三位数组并消除连续序列）出发，对你的选择进行论证。",
            "solution": "问题陈述描述了用于将两个$n$位二进制补码数（一个乘数$Q$和一个被乘数$M$）相乘的有符号4基布斯重编码算法。该算法的核心是将乘数$Q$重编码为一系列有符号数位$d_i \\in \\{-2, -1, 0, +1, +2\\}$。部分积的数量由这些数位的数量决定，即$k = \\lceil n/2 \\rceil$。*非零*部分积的数量是不等于$0$的数位$d_i$的个数。\n\n数位$d_i$是通过检查乘数$Q$中重叠的位三元组生成的。设$Q$由位$q_{n-1} \\dots q_1 q_0$表示。我们定义一个辅助位$q_{-1}=0$。对于二进制补码数，任何超出最高有效位的位，即对于$k \\ge n$的$q_k$，都被假定为符号扩展，即对于$k \\ge n$，有$q_k = q_{n-1}$。\n\n数位$d_i$对应的三位数组是$(q_{2i+1}, q_{2i}, q_{2i-1})$。数位$d_i$的值计算为$d_i = q_{2i-1} + q_{2i} - 2q_{2i+1}$。这提供了一个查找表：\n- $(0,0,0) \\implies d_i = 0+0-2(0) = 0$\n- $(0,0,1) \\implies d_i = 1+0-2(0) = +1$\n- $(0,1,0) \\implies d_i = 0+1-2(0) = +1$\n- $(0,1,1) \\implies d_i = 1+1-2(0) = +2$\n- $(1,0,0) \\implies d_i = 0+0-2(1) = -2$\n- $(1,0,1) \\implies d_i = 1+0-2(1) = -1$\n- $(1,1,0) \\implies d_i = 0+1-2(1) = -1$\n- $(1,1,1) \\implies d_i = 1+1-2(1) = 0$\n\n当且仅当对应的三位数组不是$(0,0,0)$或$(1,1,1)$时，才会产生非零部分积。\n\n让我们来评估每个陈述。\n\n**A. 对于$Q=00\\cdots 0$（所有位都为$0$），非零部分积的数量为$0$。对于$Q=11\\cdots 1$（所有位都为$1$，在二进制补码中表示$-1$），非零部分积的数量恰好为$1$，与$n$无关。**\n\n- **情况1：$Q = 00\\cdots0$**\n如果$Q$的所有位都是$0$，那么对于 $0 \\le i  n$ 有$q_i=0$。再加上$q_{-1}=0$，每个可能的三位数组$(q_{2i+1}, q_{2i}, q_{2i-1})$都将是$(0,0,0)$。根据查找表，这个三位数组重编码为$d_i=0$。因此，所有的数位$d_i$都是$0$，非零部分积的数量为$0$。这个陈述的这一部分是正确的。\n\n- **情况2：$Q = 11\\cdots1$**\n这种位模式在任何字长$n \\ge 1$的二进制补码表示中都代表数字$-1$。这里，对于 $0 \\le i  n$，有$q_i=1$。我们还有$q_{-1}=0$。\n让我们分析数位$d_i$：\n- 对于$i=0$：三位数组是$(q_1, q_0, q_{-1})$。由于$q_1=1$，$q_0=1$，$q_{-1}=0$，所以三位数组是$(1,1,0)$。这重编码为$d_0 = 0+1-2(1) = -1$。这是一个非零数位。\n- 对于$i  0$且 $2i+1  n$：三位数组是$(q_{2i+1}, q_{2i}, q_{2i-1})$。由于$2i-1 \\ge 1$，三位数组中的所有三个位都来自$Q$并且都等于$1$。三位数组是$(1,1,1)$。这重编码为$d_i = 1+1-2(1) = 0$。\n- 对于最后一个数位：这涉及到符号扩展位。总的数位数量是$\\lceil n/2 \\rceil$。设$k = \\lceil n/2 \\rceil - 1$是最后一个数位的索引。对应的三位数组是$(q_{2k+1}, q_{2k}, q_{2k-1})$。位$q_{2k}$和$q_{2k-1}$是原始数的一部分（或对于奇数$n$是最后一位）并且等于$1$。位$q_{2k+1}$是$q_{n-1}$的符号扩展。因为$q_{n-1}=1$，所以我们有$q_{2k+1}=1$。因此，最后的三位数组也是$(1,1,1)$，它重编码为$d_k=0$。\n因此，只有$d_0$是非零的。非零部分积的数量恰好为$1$。这对任何$n \\ge 1$都成立。$Q$的值被正确地计算为$d_0 \\cdot 4^0 = -1 \\cdot 1 = -1$。\n整个陈述是正确的。\n\nA的结论：**正确**。\n\n**B. 在所有$n$位模式中，诸如$Q=10\\,10\\,\\cdots$或$Q=01\\,01\\,\\cdots$的交替位模式会使非零部分积的数量最大化，且其数量等于$\\lceil n/2\\rceil$。**\n\n重编码后的数位（也就是部分积）的总数是$\\lceil n/2 \\rceil$。为了最大化*非零*部分积的数量，我们需要为每个可能的$i$值生成一个非零数位$d_i$。这意味着我们必须避免形成三位数组$(0,0,0)$和$(1,1,1)$。这些三位数组是由连续的相同位形成的。交替的位模式是连续相同位的对立面。让我们来分析它们。\n\n- **情况1：$Q$具有模式$0101\\cdots$（即$q_{2j}=1, q_{2j+1}=0$）。**\n- 对于$i=0$：三位数组是$(q_1, q_0, q_{-1}) = (0, 1, 0)$。这重编码为$d_0 = 0+1-2(0) = +1$。\n- 对于$i0$：三位数组是$(q_{2i+1}, q_{2i}, q_{2i-1})$。$q_{2i+1}=0$（奇数索引），$q_{2i}=1$（偶数索引），$q_{2i-1}=0$（奇数索引）。三位数组是$(0,1,0)$，重编码为$d_i=+1$。只要这些位在$Q$的范围内，这就成立。\n- 对于最后一个数位（如果$n$是奇数，$n=2k+1$）：$Q$以$q_{n-1}=q_{2k}=1$结尾。我们需要三位数组$(q_{2k+1}, q_{2k}, q_{2k-1})$。模式是$q_{2j}=1$，$q_{2j+1}=0$。等等，问题陈述说$Q=0101...$。这意味着$q_0=1, q_1=0, q_2=1, ...$。所以$q_{2j}=1$且$q_{2j+1}=0$。\n  - $i=0$: $(q_1, q_0, q_{-1}) = (0,1,0) \\implies d_0=+1$。\n  - $i0$: $(q_{2i+1}, q_{2i}, q_{2i-1}) = (0,1,0) \\implies d_i=+1$。只要 $2i+1  n$，这就成立。\n  - 符号扩展：如果$n$是偶数（$n=2k$），$q_{n-1}=q_{2k-1}=0$。最后一个三位数组的索引$i=k-1$涉及的位直到$q_{2k-1}=q_{n-1}$，所以不需要符号扩展。所有的数位都是$+1$。\n  - 如果$n$是奇数（$n=2k+1$），$q_{n-1}=q_{2k}=1$。最后一个三位数组的索引是$i=k$。我们使用$(q_{2k+1}, q_{2k}, q_{2k-1})$。$q_{2k}=1, q_{2k-1}=0$。符号位是$q_{2k}=1$，所以它的扩展是$q_{2k+1}=1$。三位数组是$(1,1,0)$，这得到$d_k=-1$。仍然是非零的。\n在所有情况下，对于模式$0101\\cdots$，每个重编码的数位$d_i$都是非零的。\n\n- **情况2：$Q$具有模式$1010\\cdots$（即$q_{2j}=0, q_{2j+1}=1$）。**\n- 对于$i=0$：三位数组是$(q_1, q_0, q_{-1}) = (1, 0, 0)$。这重编码为$d_0 = 0+0-2(1)=-2$。\n- 对于$i0$：三位数组是$(q_{2i+1}, q_{2i}, q_{2i-1}) = (1, 0, 1)$。这重编码为$d_i = 1+0-2(1)=-1$。\n- 符号扩展：如果$n$是奇数（$n=2k+1$），$q_{n-1}=q_{2k}=0$。最后一个三位数组是$(q_{2k+1}, q_{2k}, q_{2k-1})=(0,0,1)$，得到$d_k=+1$。\n在所有情况下，对于模式$1010\\cdots$，每个重编码的数位$d_i$都是非零的。\n\n由于交替的位模式确保没有一个三位数组是$(0,0,0)$或$(1,1,1)$，所以$\\lceil n/2 \\rceil$个中的每一个数位都是非零的。这是最大可能的数量。\n\nB的结论：**正确**。\n\n**C. 一个单独的连续的1序列，$Q=00\\cdots 0111\\cdots 100\\cdots 0$，会使非零部分积的数量最大化，因为每个三位数组必须重编码为$+2$或$-2$。**\n\n这个陈述与布斯算法的根本目的相悖，该算法旨在高效处理长的连续相同位。\n让我们考虑一个带有一段连续$1$的数，例如$Q=...0011...1100...$。\n- 在全为$0$的区域，所有的三位数组都是$(0,0,0)$，得到$d_i=0$。\n- 在连续$1$序列的内部，所有的三位数组都是$(1,1,1)$，得到$d_i=0$。\n- 非零数位只可能在连续$1$序列的边界处产生。\n- 在连续序列的开始处（一个$0 \\to 1$的转换）：一个三位数组会横跨这个边界。例如，在$...0011...$中，我们可能形成三位数组$(0,1,1)$，重编码为$d_i=+2$，或者$(0,0,1)$，重编码为$d_i=+1$。\n- 在连续序列的结束处（一个$1 \\to 0$的转换）：一个三位数组会横跨这个边界。例如，在$...1100...$中，我们可能形成三位数组$(1,0,0)$，重编码为$d_j=-2$，或者$(1,1,0)$，重编码为$d_j=-1$。\n一段连续的$1$序列最多会产生两个非零数位，一个在序列开始附近，一个在序列结束附近。对于大的$n$，$2$远小于由交替模式达到的最大值$\\lceil n/2 \\rceil$。因此，这种模式并不会使非零部分积的数量最大化；反而使其最小化。\n此外，给出的理由“因为每个三位数组必须重编码为$+2$或$-2$”是错误的。如上所示，数位$+1$和$-1$可以轻易地在边界处生成。例如，如果$Q=...0001110...$，我们在连续序列的开始处形成一个三位数组$(q_{2i+1}, q_{2i}, q_{2i-1})=(0,0,1)$，这将产生$d_i=+1$。该陈述在两个方面都是不正确的。\n\nC的结论：**不正确**。\n\n**D. 对于$n$位的$Q$，在有符号4基布斯重编码下，非零部分积的最大可能数量为$n$，这在$Q$为交替模式$10\\,10\\,\\cdots$时实现。**\n\n4基方案将位以对的形式分组（带有一位重叠）。对于一个$n$位的乘数，这会产生$\\lceil n/2 \\rceil$个组或数位。部分积的总数（无论是零还是非零）是$\\lceil n/2 \\rceil$。因此，*非零*部分积的最大可能数量不能超过这个值。\n该陈述声称最大值为$n$。对于任何$n > 2$，$n > \\lceil n/2 \\rceil$。例如，如果$n=8$，非零部分积的最大数量是$8/2 = 4$，而不是$8$。该陈述从根本上将重编码数位的数量与乘数中的位数混淆了。虽然$1010\\cdots$模式确实能使非零积的数量最大化，但该最大值是$\\lceil n/2 \\rceil$，而不是$n$。\n\nD的结论：**不正确**。\n\n最终结论：陈述A和B是正确的。",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "算法的改进最终要体现在硬件的简化上，布斯算法对部分积的优化也不例外。本练习将引导您亲手量化这种硬件节省：您需要为一个标准阵列乘法器和一个采用布斯编码的乘法器计算其华莱士树（Wallace tree）中所需的3:2压缩器的确切数量。通过这个过程，您将直观地看到算法优化如何直接转化为硬件资源的减少。",
            "id": "3652024",
            "problem": "考虑在位级实现的无符号整数乘法。一个 $3:2$ 压缩器（功能上等同于一个全加器）接收三个相同权重 $2^{i}$ 的单位输入，并产生两个单位输出：一个权重为 $2^{i}$ 的和位和一个权重为 $2^{i+1}$ 的进位。一个位堆由其列高轮廓 $\\{H_{i}\\}$ 描述，其中 $H_{i}$ 是在进行任何压缩之前，第 $i$ 列（权重为 $2^{i}$）中最初存在的单位信号数量。华莱士式列压缩的目标是仅使用 $3:2$ 压缩器将每一列减少到最多两个位，其中进位会传播到更高权重的列。\n\n从位加法和 $3:2$ 压缩的核心定义出发，推导一个公式，该公式对于一个通用的列高轮廓 $\\{H_{i}\\}$，给出将每一列减少到最多两个位所需的最少 $3:2$ 压缩器数量（在每一列中，以及总共）。您的推导必须考虑到由较低权重列的压缩产生并进入较高权重列的进位。\n\n然后将您的公式应用于以下两个用于 8 位乘以 8 位乘法的科学上真实的列高轮廓：\n\n- 阵列乘法器（教科书式部分积）：对于 $i = 0,1,\\dots,14$, \n$$\nH_{i}^{\\text{array}} = \n\\begin{cases}\ni+1,  0 \\leq i \\leq 7, \\\\\n15 - i,  8 \\leq i \\leq 14,\n\\end{cases}\n$$\n具体为\n$$\n\\{H_{i}^{\\text{array}}\\}_{i=0}^{14} = \\{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1\\}.\n$$\n\n- 基4布斯重编码（不存在符号校正位，四个部分积行分别移位 $0,2,4,6$）：对于 $i = 0,1,\\dots,14$，轮廓为\n$$\n\\{H_{i}^{\\text{Booth}}\\}_{i=0}^{14} = \\{1,1,2,2,3,3,4,4,3,3,2,2,1,1,0\\}.\n$$\n\n计算每个轮廓所需的最少 $3:2$ 压缩器数量，并报告其差值（阵列乘法器减去布斯重编码）作为一个实数值。无需四舍五入。将您的最终答案表示为一个不带单位的纯数字。",
            "solution": "问题要求推导一个公式，用于计算归约位堆所需的 $3:2$ 压缩器数量，然后将此公式应用于两个具体示例。\n\n### 第一部分：通用公式的推导\n\n一个 $3:2$ 压缩器，也称为全加器，是并行乘法器中的一个基本组件。它接收三个相同算术权重（比如 $2^i$）的单位输入，并产生两个单位输出：一个权重为 $2^i$ 的和位和一个权重为 $2^{i+1}$ 的进位。这个操作可以表示为：第 $i$ 列的 $3$ 个位 $\\rightarrow$ 第 $i$ 列的 $1$ 个位和第 $i+1$ 列的 $1$ 个位。\n\n我们来分析一个初始高度为 $h$ 位的单列 $i$ 的归约过程。目标是使用 $3:2$ 压缩器将此高度减少到最多为 $2$。每个压缩器将当前列的位数减少 $3-1 = 2$。这个归约过程可能需要多个阶段。\n\n设 $h_0 = h$ 为该列的初始高度。\n在第一阶段的归约中，我们可以应用 $k_1 = \\lfloor h_0/3 \\rfloor$ 个压缩器。这些压缩器消耗了该列中的 $3k_1$ 个位。\n输出是：\n1. $k_1$ 个和位，保留在当前列 $i$ 中。\n2. $k_1$ 个进位，传递到下一个更高权重的列 $i+1$。\n\n在第 $i$ 列中未被任何压缩器处理的位数是 $h_0 \\pmod 3$。\n因此，经过一个压缩阶段后，第 $i$ 列的新高度是产生的和位数与未处理位数之和：\n$$h_1 = k_1 + (h_0 \\pmod 3) = \\lfloor \\frac{h_0}{3} \\rfloor + (h_0 \\pmod 3)$$\n如果 $h_1  2$，这组新的 $h_1$ 个位必须被进一步压缩。这个过程会重复进行。设 $h_j$ 为第 $j$ 阶段的列高。归约过程如下：\n$$h_{j+1} = \\lfloor \\frac{h_j}{3} \\rfloor + (h_j \\pmod 3)$$\n这个过程持续进行，直到达到某个阶段 $m$，使得 $h_m \\le 2$。\n\n此列中使用的压缩器总数是每个阶段使用的压缩器之和：$N_{\\text{comp}}(h) = \\sum_{j=0}^{m-1} k_{j+1} = \\sum_{j=0}^{m-1} \\lfloor h_j/3 \\rfloor$。\n同样，产生并传递到下一列的进位总数是 $C_{\\text{out}}(h) = \\sum_{j=0}^{m-1} k_{j+1}$。\n因此，对于一个初始高度为 $h$ 的单列，所需的压缩器数量 $N_{\\text{comp}}(h)$ 等于它产生的进位数量 $C_{\\text{out}}(h)$。\n\n我们定义一个函数 $f(h)$ 来表示这个数量，即 $N_{\\text{comp}}(h) = C_{\\text{out}}(h)$。\n基于分阶段归约，我们可以为 $f(h)$ 写出一个递归公式：\n- 如果 $h \\le 2$，则不需要压缩器，因此 $f(h) = 0$。\n- 如果 $h  2$，我们在第一阶段使用 $\\lfloor h/3 \\rfloor$ 个压缩器，问题就简化为压缩一个高度为 $h' = \\lfloor h/3 \\rfloor + (h \\pmod 3)$ 的列。所以，$f(h) = \\lfloor h/3 \\rfloor + f(\\lfloor h/3 \\rfloor + (h \\pmod 3))$。\n\n这个递归公式使我们能够计算任何给定列高的压缩器数量。\n\n现在，考虑一个通用的位堆轮廓 $\\{H_i\\}$。由于进位的传播，各列的压缩不是独立的。这个过程必须从最低有效列（$i=0$）开始顺序向上进行。\n\n设 $N_i$ 为第 $i$ 列使用的压缩器数量，设 $C_i$ 为第 $i$ 列产生并传递到第 $i+1$ 列的进位数量。如前所述，$N_i = C_i$。\n设 $H_i$ 为问题陈述中给出的第 $i$ 列的初始高度。\n设 $H'_i$ 为第 $i$ 列在压缩前的总高度，这包括来自前一列的进位。\n我们从 $C_{-1} = 0$ 开始。\n\n对于每一列 $i=0, 1, 2, \\dots$：\n1. 需要压缩的总高度是 $H'_i = H_i + C_{i-1}$。\n2. 此列所需的压缩器数量是 $N_i = f(H'_i)$。\n3. 传递到下一列的进位数量是 $C_i = N_i$。\n\n这导出了以下关于每列 $i$ 中压缩器数量 $N_i$ 的递推关系：\n$$N_i = f(H_i + N_{i-1}), \\quad \\text{其中 } N_{-1}=0$$\n其中 $f(h)$ 是前面定义的递归函数。整个位堆的 $3:2$ 压缩器总数是所有列的总和：\n$$N_{\\text{total}} = \\sum_i N_i$$\n这就构成了通用的公式和步骤。\n\n### 第二部分：应用于特定轮廓\n\n首先，我们预先计算相关高度 $h$ 的 $f(h)$ 值。\n$f(0)=0, f(1)=0, f(2)=0$\n$f(3) = \\lfloor 3/3 \\rfloor + f(1) = 1+0=1$\n$f(4) = \\lfloor 4/3 \\rfloor + f(2) = 1+0=1$\n$f(5) = \\lfloor 5/3 \\rfloor + f(3) = 1+1=2$\n$f(6) = \\lfloor 6/3 \\rfloor + f(2) = 2+0=2$\n$f(7) = \\lfloor 7/3 \\rfloor + f(3) = 2+1=3$\n$f(8) = \\lfloor 8/3 \\rfloor + f(4) = 2+1=3$\n$f(9) = \\lfloor 9/3 \\rfloor + f(3) = 3+1=4$\n$f(10) = \\lfloor 10/3 \\rfloor + f(4) = 3+1=4$\n$f(11) = \\lfloor 11/3 \\rfloor + f(5) = 3+2=5$\n$f(12) = \\lfloor 12/3 \\rfloor + f(4) = 4+1=5$\n$f(13) = \\lfloor 13/3 \\rfloor + f(5) = 4+2=6$\n\n**轮廓1：阵列乘法器**\n初始轮廓是 $\\{H_{i}^{\\text{array}}\\}_{i=0}^{14} = \\{1,2,3,4,5,6,7,8,7,6,5,4,3,2,1\\}$。\n我们计算 $N_i^{\\text{array}} = C_i^{\\text{array}} = f(H_i^{\\text{array}} + C_{i-1}^{\\text{array}})$，其中 $C_{-1}^{\\text{array}} = 0$。\n\n$i=0: H'_0 = 1+0=1 \\implies N_0^{\\text{array}} = f(1)=0$。$C_0=0$。\n$i=1: H'_1 = 2+0=2 \\implies N_1^{\\text{array}} = f(2)=0$。$C_1=0$。\n$i=2: H'_2 = 3+0=3 \\implies N_2^{\\text{array}} = f(3)=1$。$C_2=1$。\n$i=3: H'_3 = 4+1=5 \\implies N_3^{\\text{array}} = f(5)=2$。$C_3=2$。\n$i=4: H'_4 = 5+2=7 \\implies N_4^{\\text{array}} = f(7)=3$。$C_4=3$。\n$i=5: H'_5 = 6+3=9 \\implies N_5^{\\text{array}} = f(9)=4$。$C_5=4$。\n$i=6: H'_6 = 7+4=11 \\implies N_6^{\\text{array}} = f(11)=5$。$C_6=5$。\n$i=7: H'_7 = 8+5=13 \\implies N_7^{\\text{array}} = f(13)=6$。$C_7=6$。\n$i=8: H'_8 = 7+6=13 \\implies N_8^{\\text{array}} = f(13)=6$。$C_8=6$。\n$i=9: H'_9 = 6+6=12 \\implies N_9^{\\text{array}} = f(12)=5$。$C_9=5$。\n$i=10: H'_{10} = 5+5=10 \\implies N_{10}^{\\text{array}} = f(10)=4$。$C_{10}=4$。\n$i=11: H'_{11} = 4+4=8 \\implies N_{11}^{\\text{array}} = f(8)=3$。$C_{11}=3$。\n$i=12: H'_{12} = 3+3=6 \\implies N_{12}^{\\text{array}} = f(6)=2$。$C_{12}=2$。\n$i=13: H'_{13} = 2+2=4 \\implies N_{13}^{\\text{array}} = f(4)=1$。$C_{13}=1$。\n$i=14: H'_{14} = 1+1=2 \\implies N_{14}^{\\text{array}} = f(2)=0$。$C_{14}=0$。\n\n阵列乘法器的压缩器总数：\n$$N_{\\text{total}}^{\\text{array}} = 0+0+1+2+3+4+5+6+6+5+4+3+2+1+0 = 42$$\n\n**轮廓2：基4布斯重编码**\n初始轮廓是 $\\{H_{i}^{\\text{Booth}}\\}_{i=0}^{14} = \\{1,1,2,2,3,3,4,4,3,3,2,2,1,1,0\\}$。\n我们计算 $N_i^{\\text{Booth}} = C_i^{\\text{Booth}} = f(H_i^{\\text{Booth}} + C_{i-1}^{\\text{Booth}})$，其中 $C_{-1}^{\\text{Booth}} = 0$。\n\n$i=0: H'_0 = 1+0=1 \\implies N_0^{\\text{Booth}} = f(1)=0$。$C_0=0$。\n$i=1: H'_1 = 1+0=1 \\implies N_1^{\\text{Booth}} = f(1)=0$。$C_1=0$。\n$i=2: H'_2 = 2+0=2 \\implies N_2^{\\text{Booth}} = f(2)=0$。$C_2=0$。\n$i=3: H'_3 = 2+0=2 \\implies N_3^{\\text{Booth}} = f(2)=0$。$C_3=0$。\n$i=4: H'_4 = 3+0=3 \\implies N_4^{\\text{Booth}} = f(3)=1$。$C_4=1$。\n$i=5: H'_5 = 3+1=4 \\implies N_5^{\\text{Booth}} = f(4)=1$。$C_5=1$。\n$i=6: H'_6 = 4+1=5 \\implies N_6^{\\text{Booth}} = f(5)=2$。$C_6=2$。\n$i=7: H'_7 = 4+2=6 \\implies N_7^{\\text{Booth}} = f(6)=2$。$C_7=2$。\n$i=8: H'_8 = 3+2=5 \\implies N_8^{\\text{Booth}} = f(5)=2$。$C_8=2$。\n$i=9: H'_9 = 3+2=5 \\implies N_9^{\\text{Booth}} = f(5)=2$。$C_9=2$。\n$i=10: H'_{10} = 2+2=4 \\implies N_{10}^{\\text{Booth}} = f(4)=1$。$C_{10}=1$。\n$i=11: H'_{11} = 2+1=3 \\implies N_{11}^{\\text{Booth}} = f(3)=1$。$C_{11}=1$。\n$i=12: H'_{12} = 1+1=2 \\implies N_{12}^{\\text{Booth}} = f(2)=0$。$C_{12}=0$。\n$i=13: H'_{13} = 1+0=1 \\implies N_{13}^{\\text{Booth}} = f(1)=0$。$C_{13}=0$。\n$i=14: H'_{14} = 0+0=0 \\implies N_{14}^{\\text{Booth}} = f(0)=0$。$C_{14}=0$。\n\n布斯重编码乘法器的压缩器总数：\n$$N_{\\text{total}}^{\\text{Booth}} = 0+0+0+0+1+1+2+2+2+2+1+1+0+0+0 = 12$$\n\n### 第三部分：最终计算\n\n问题要求计算压缩器数量的差值，即：\n$$N_{\\text{total}}^{\\text{array}} - N_{\\text{total}}^{\\text{Booth}} = 42 - 12 = 30$$\n对于这个 8 位乘以 8 位的例子，布斯重编码乘法器比阵列乘法器少用 $30$ 个 $3:2$ 压缩器。这说明了布斯算法的一个主要优点：它减少了部分积的数量，从而得到一个更小、更快的归约树。",
            "answer": "$$\\boxed{30}$$"
        },
        {
            "introduction": "深刻理解一个算法也意味着能够识别其表现异常出色的特殊情况。本练习聚焦于一个典型场景：当乘数为$-2$的幂时，布斯算法巧妙地将复杂的乘法简化为一次移位和一次取反操作。通过推导这个简化过程并量化其与传统阵列乘法器相比的延迟优势，您将体会到算法在特定应用中的强大威力。",
            "id": "3652051",
            "problem": "一个$N$位二进制补码有符号整数乘法器通过形成部分积并将它们相加来计算被乘数$a$与乘数$b$的乘积。在基-$2$ Booth重编码中，乘数中连续的$1$比特串被有符号数字替换，以减少非零部分积的数量，这些部分积是被乘数的移位版本，并可能需要减法来处理负数位。考虑一个特殊情况，其中被乘数为 $a=-2^{k}$（$0 \\leq k \\leq N-2$），乘数$b$为任意一个$N$位二进制补码整数。\n\n仅从二进制补码表示法和基-$2$ Booth重编码过程的定义出发，完成以下任务：\n\n1. 逐步推导$a=-2^{k}$的Booth有符号数字序列，并证明乘积$p=a \\cdot b$可简化为单个负的移位部分积。明确指出其符号和移位量（用$k$表示），并将$p$表示为$b$和$k$的函数。\n\n2. 为了量化延迟，采用一个单位延迟逻辑深度模型，其中每个理想化的逻辑级贡献相同的延迟。对于一个典型的规则$N \\times N$阵列乘法器（无先行进位或进位保留压缩；进位沿阵列对角线传播），请从关于进位和求和的第一性原理出发，论证从部分积生成到最终进位输出的关键路径逻辑深度可以建模为$2N+1$级。对于专为$a=-2^{k}$情况定制的专用数据通路，它绕过了部分积累加，而是通过先将$b$左移$k$位然后进行二进制补码求反来计算$p$，假设使用以下组件：\n- 一个由$\\lceil \\log_{2}(N) \\rceil$级级联的$2:1$多路选择器构成的$N$位桶形移位器（BS），贡献$\\lceil \\log_{2}(N) \\rceil$级逻辑深度。\n- 用于求反过程中反码步骤的按位取反，贡献$1$级逻辑深度。\n- 一个用作增量器在二进制补码求反中加$1$的并行前缀加法器（PPA），其逻辑深度为$\\lceil \\log_{2}(N) \\rceil$。\n\n使用这些假设，写出阵列乘法器和为$a=-2^{k}$情况定制的专用数据通路的总关键路径逻辑深度，两者都表示为$N$的函数。\n\n3. 将改进因子$\\mathcal{I}(N)$定义为阵列乘法器的关键路径深度与专用数据通路的关键路径深度的比率：\n$$\n\\mathcal{I}(N) \\equiv \\frac{\\text{阵列深度}}{\\text{专用深度}}.\n$$\n精确计算$\\mathcal{I}(32)$。将你的最终答案报告为单个实数。无需四舍五入，且最终答案中不使用单位。",
            "solution": "这个问题分为三个部分。我们将从二进制补码算术和数字逻辑设计的基本原理出发，依次解决每个部分。\n\n### 第1部分：Booth重编码与乘积简化\n\n问题的第1部分要求推导被乘数$a = -2^k$的基-2 Booth重编码，并证明乘积$p = a \\cdot b$可以简化为单个移位部分积。\n\n**第1步：$a = -2^k$的二进制补码表示**\n\n一个$N$位二进制补码整数由一个位向量$(a_{N-1}, a_{N-2}, \\dots, a_0)$表示。其值由$-a_{N-1}2^{N-1} + \\sum_{i=0}^{N-2} a_i 2^i$给出。我们需要找到对应于值$-2^k$的位向量，其中$0 \\leq k \\leq N-2$。\n\n$a = -2^k$（对于$k  N-1$）的$N$位二进制补码表示是从比特位置$N-1$到$k$的一串1，以及对于所有小于$k$的比特位置都是0。即，其位表示为 $a_i=0$ 对于 $i  k$，$a_i=1$ 对于 $i \\geq k$。\n\n我们可以通过计算其值来验证该表示：\n$$ V = -1 \\cdot 2^{N-1} + \\sum_{i=k}^{N-2} 1 \\cdot 2^i $$\n该求和是一个几何级数：\n$$ \\sum_{i=k}^{N-2} 2^i = 2^k + 2^{k+1} + \\dots + 2^{N-2} = 2^k(1+2+\\dots+2^{N-2-k}) = 2^k \\left( \\frac{2^{N-1-k}-1}{2-1} \\right) = 2^k(2^{N-1-k}-1) = 2^{N-1} - 2^k $$\n将此代回值的表达式中：\n$$ V = -2^{N-1} + (2^{N-1} - 2^k) = -2^k $$\n这证实了表示的正确性。\n\n**第2步：基-2 Booth重编码**\n\n基-2 Booth重编码算法从二进制补码数$a = (a_{N-1}, \\dots, a_0)$生成一个有符号数字序列$y = (y_{N-1}, \\dots, y_0)$。数字的计算方式为$y_i = a_{i-1} - a_i$，其中$a_{-1}$被隐式定义为$0$。$a$的值则表示为$\\sum_{i=0}^{N-1} y_i 2^i$。\n\n让我们将此应用于$a=-2^k$的比特串：\n- 对于 $i  k$：我们有$a_i = 0$和$a_{i-1}=0$（因为 $i-1  k$）。因此，$y_i = a_{i-1} - a_i = 0 - 0 = 0$。\n- 对于$i = k$：我们有$a_k = 1$和$a_{k-1}=0$。因此，$y_k = a_{k-1} - a_k = 0 - 1 = -1$。\n- 对于$i > k$：我们有$a_i = 1$和$a_{i-1}=1$（因为$i-1 \\geq k$）。因此，$y_i = a_{i-1} - a_i = 1 - 1 = 0$。\n\n得到的Booth有符号数字序列全由零组成，除了单个数字$y_k = -1$。\n\n**第3步：乘积计算**\n\n乘积$p = a \\cdot b$是通过对移位的部分积求和来计算的，其中第$i$个部分积是$y_i \\cdot b \\cdot 2^i$。由于我们选择对被乘数$a$进行编码，因此部分积是乘数$b$的移位版本。\n$$ p = \\left( \\sum_{i=0}^{N-1} y_i 2^i \\right) \\cdot b = \\sum_{i=0}^{N-1} (y_i \\cdot b \\cdot 2^i) $$\n由于唯一的非零Booth数字是$y_k = -1$，该求和简化为单个项：\n$$ p = y_k \\cdot b \\cdot 2^k = (-1) \\cdot b \\cdot 2^k = -(b \\cdot 2^k) $$\n这个结果表明乘积$p=a \\cdot b$确实是单个部分积。该部分积是通过将乘数$b$左移$k$位然后进行算术求反而形成的。\n- 符号为负。\n- 移位量为$k$。\n- $p$的表达式为$p = -(b \\cdot 2^k)$。\n\n### 第2部分：延迟（逻辑深度）分析\n\n这部分要求对两种乘法器实现的关键路径逻辑深度进行建模。\n\n**典型阵列乘法器**\n\n问题为规则的$N \\times N$阵列乘法器的关键路径逻辑深度提供了一个模型，即$2N+1$级。我们可以按如下方式论证这个简化的单位延迟模型：\n1.  **部分积生成**：$N^2$个位积$a_i b_j$由$N^2$个并行操作的与门形成。这一步构成一个逻辑级。深度：$1$。\n2.  **加法器阵列（对角线路径）**：在一个行波式阵列中，关键路径首先沿对角线穿过$N-1$个全加器。每个加法器贡献一个逻辑级，用于产生和位。深度：$N-1$。\n3.  **最终加法器（水平路径）**：在阵列的最后一行，进位信号必须水平传播通过一个$N$位的行波进位加法器。这贡献了$N$个逻辑级。深度：$N$。\n4.  **最终输出逻辑**：最终的输出缓冲或逻辑可能增加一个逻辑级。深度：$1$。\n\n将这些贡献相加，总的关键路径逻辑深度为：\n$$ D_{\\text{array}}(N) = 1 + (N-1) + N + 1 = 2N+1 $$\n这证明了给定模型的合理性。\n\n**为$a = -2^k$定制的专用数据通路**\n\n根据第1部分，乘积为$p = -(b \\cdot 2^k)$。这个操作可以通过一个由移位器和求反逻辑组成的专用数据通路来实现。问题指定了每个组件的逻辑深度。这些操作是顺序执行的，所以我们将它们的深度相加。\n\n1.  **移位**：乘数$b$被左移$k$个位置。这由一个$N$位桶形移位器（BS）执行，其指定深度为$\\lceil \\log_2(N) \\rceil$。\n2.  **求反**：对移位后的结果使用二进制补码求反。这是一个两步过程：\n    a.  **反码**：对移位结果进行按位取反。这贡献了$1$个逻辑级。\n    b.  **增1**：对取反后的结果加$1$。这由一个用作增量器的并行前缀加法器（PPA）执行，其指定深度为$\\lceil \\log_2(N) \\rceil$。\n\n专用数据通路的总关键路径逻辑深度是这些顺序阶段的和：\n$$ D_{\\text{specialized}}(N) = D_{\\text{BS}} + D_{\\text{invert}} + D_{\\text{PPA}} = \\lceil \\log_2(N) \\rceil + 1 + \\lceil \\log_2(N) \\rceil = 2 \\lceil \\log_2(N) \\rceil + 1 $$\n所以，这两个逻辑深度函数是：\n- $D_{\\text{array}}(N) = 2N+1$\n- $D_{\\text{specialized}}(N) = 2 \\lceil \\log_2(N) \\rceil + 1$\n\n### 第3部分：改进因子计算\n\n改进因子$\\mathcal{I}(N)$定义为两个深度的比率：\n$$ \\mathcal{I}(N) = \\frac{D_{\\text{array}}(N)}{D_{\\text{specialized}}(N)} = \\frac{2N+1}{2 \\lceil \\log_2(N) \\rceil + 1} $$\n我们被要求计算当$N=32$时该值。\n\n首先，我们计算当$N=32$时每种架构的逻辑深度。\n对于阵列乘法器：\n$$ D_{\\text{array}}(32) = 2(32) + 1 = 64 + 1 = 65 $$\n对于专用数据通路，我们需要$\\lceil \\log_2(32) \\rceil$。由于$32 = 2^5$，$\\log_2(32) = 5$，这是一个整数。因此，$\\lceil \\log_2(32) \\rceil = 5$。\n$$ D_{\\text{specialized}}(32) = 2 \\lceil \\log_2(32) \\rceil + 1 = 2(5) + 1 = 10 + 1 = 11 $$\n现在，我们可以计算改进因子$\\mathcal{I}(32)$：\n$$ \\mathcal{I}(32) = \\frac{D_{\\text{array}}(32)}{D_{\\text{specialized}}(32)} = \\frac{65}{11} $$\n问题要求一个精确的实数。分数$\\frac{65}{11}$就是其精确表示。",
            "answer": "$$\\boxed{\\frac{65}{11}}$$"
        }
    ]
}