{
    "hands_on_practices": [
        {
            "introduction": "The power of a carry-lookahead adder lies in its ability to compute carries in parallel, breaking the linear dependency found in simpler adders. This first practice guides you through the derivation of the core \"group generate\" logic directly from the fundamental carry recurrence . By confronting a practical hardware limit—the maximum number of inputs a gate can have—you will discover why CLAs must be designed hierarchically, a key principle for building fast adders of any size.",
            "id": "3626898",
            "problem": "A Carry-Lookahead Adder (CLA) constructs group carry signals to accelerate addition by exploiting single-bit generate and propagate signals. Let the single-bit generate and propagate signals be denoted by $G_i$ and $P_i$, respectively, and let the carry recursion be given by the fundamental relation $C_{i+1} = G_i \\lor \\left(P_i \\land C_i\\right)$. Define the group generate signal $G_{0,k}$ to be the signal that, independent of the incoming carry $C_0$, indicates that the bit positions $0$ through $k$ collectively generate a carry into position $k+1$.\n\nStarting strictly from the carry recursion $C_{i+1} = G_i \\lor \\left(P_i \\land C_i\\right)$ and the definition of $G_{0,k}$ as the $C_0$-independent contribution to $C_{k+1}$ from bits $0$ through $k$, derive the explicit sum-of-products form for $G_{0,k}$ in terms of $\\{G_t,P_t\\}$ for $t \\in \\{0,1,\\dots,k\\}$. Assume an implementation in Complementary Metal–Oxide–Semiconductor (CMOS) technology, with standard cells that include an OR gate whose maximum static fan-in is $4$. Further assume that all product terms required for $G_{0,k}$ are computed in parallel by separate AND networks, and that the only constraint considered for combining these product terms is the $4$-input limit on OR gates.\n\nUnder these assumptions:\n- Determine the largest integer $k$ such that $G_{0,k}$ can be implemented using a single OR stage with no OR decomposition, i.e., with one OR gate receiving all required product terms directly.\n- For general $k$, propose a decomposition that minimizes the number of additional OR levels by organizing the OR gates into a balanced $4$-ary tree, and derive the minimal number of OR levels needed to combine all product terms.\n\nExpress your final answer as a pair $\\left(k_{\\max}, L_{\\min}(k)\\right)$, where $k_{\\max}$ is the largest $k$ implementable in one OR stage, and $L_{\\min}(k)$ is the minimal number of OR levels in the balanced $4$-ary OR tree needed to realize $G_{0,k}$. No rounding is required. Provide your answer as a single analytical expression.",
            "solution": "The fundamental carry recursion for an $n$-bit adder is given by:\n$$C_{i+1} = G_i \\lor (P_i \\land C_i)$$\nwhere $G_i$ is the generate signal for bit $i$, $P_i$ is the propagate signal for bit $i$, and $C_i$ is the carry-in to bit $i$.\n\nThe first step is to derive the explicit sum-of-products form for the group generate signal $G_{0,k}$. The problem defines $G_{0,k}$ as the component of the carry-out signal from bit $k$, $C_{k+1}$, that is independent of the initial carry-in $C_0$. To find this, we must express $C_{k+1}$ in terms of $C_0$ by repeatedly substituting the carry recursion relation.\n\nFor $i=0$: $C_1 = G_0 \\lor (P_0 \\land C_0)$\nFor $i=1$: $C_2 = G_1 \\lor (P_1 \\land C_1) = G_1 \\lor (P_1 \\land (G_0 \\lor (P_0 \\land C_0))) = G_1 \\lor (P_1 \\land G_0) \\lor (P_1 \\land P_0 \\land C_0)$\nFor $i=2$: $C_3 = G_2 \\lor (P_2 \\land C_2) = G_2 \\lor (P_2 \\land G_1) \\lor (P_2 \\land P_1 \\land G_0) \\lor (P_2 \\land P_1 \\land P_0 \\land C_0)$\n\nObserving the pattern, the general expression for $C_{k+1}$ is:\n$$C_{k+1} = \\left( G_k \\lor (P_k \\land G_{k-1}) \\lor \\dots \\lor (P_k \\land \\dots \\land P_1 \\land G_0) \\right) \\lor \\left( (P_k \\land \\dots \\land P_0) \\land C_0 \\right)$$\nThe group generate signal $G_{0,k}$ is the contribution to $C_{k+1}$ that is independent of $C_0$, which is the first major disjunct:\n$$G_{0,k} = G_k \\lor (P_k \\land G_{k-1}) \\lor (P_k \\land P_{k-1} \\land G_{k-2}) \\lor \\dots \\lor (P_k \\land P_{k-1} \\land \\dots \\land P_1 \\land G_0)$$\nThe number of product terms in this sum-of-products expression is $k+1$.\n\n1.  **Determine the largest integer $k$ ($k_{\\max}$) for which $G_{0,k}$ is implementable in a single OR stage.**\nA single OR stage with a maximum fan-in of $4$ can accept at most $4$ inputs. The number of inputs to the OR gate is the number of product terms, $k+1$.\nTo use a single OR gate, we require:\n$$k+1 \\leq 4 \\implies k \\leq 3$$\nThe largest integer $k$ satisfying this is $3$. Therefore, $k_{\\max} = 3$.\n\n2.  **For a general $k$, derive the minimal number of OR levels $L_{\\min}(k)$.**\nFor a general $k$, we need to combine $N = k+1$ product terms using a balanced $4$-ary tree of OR gates. A tree of logic gates with $L$ levels and a uniform fan-in of $F$ can combine at most $F^L$ inputs.\nHere, the fan-in is $F=4$ and the number of inputs is $N=k+1$. We need to find the smallest integer $L$ that satisfies the inequality:\n$$4^L \\geq k+1$$\nTaking the logarithm base $4$ of both sides:\n$$L \\geq \\log_4(k+1)$$\nSince the number of levels $L$ must be an integer, we must take the ceiling of the right-hand side:\n$$L_{\\min}(k) = \\lceil \\log_4(k+1) \\rceil$$\nThis formula gives the depth of the balanced $4$-ary OR tree.\n\nThe final answer is the pair $(k_{\\max}, L_{\\min}(k))$.\n$k_{\\max} = 3$\n$L_{\\min}(k) = \\lceil \\log_4(k+1) \\rceil$\n\nThe final answer is the pair $(3, \\lceil \\log_4(k+1) \\rceil)$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 3 & \\lceil \\log_4(k+1) \\rceil \\end{pmatrix}}$$"
        },
        {
            "introduction": "A single Boolean function can often be implemented with surprisingly different circuit structures, each with its own performance trade-offs. This exercise explores an elegant alternative model for carry propagation, viewing the carry chain not as a series of AND/OR operations, but as a cascade of multiplexers . By deriving this model and performing a comparative timing analysis against a traditional sum-of-products implementation, you will gain concrete insight into how architectural choices at the gate level directly influence the overall speed of an arithmetic circuit.",
            "id": "3626965",
            "problem": "A four-bit carry-lookahead adder is constructed to add two unsigned binary operands with bit positions $i \\in \\{0,1,2,3\\}$. For each bit position $i$, the bit-level propagate and generate signals are defined by $p_i = a_i \\oplus b_i$ and $g_i = a_i b_i$, respectively, where $\\oplus$ is exclusive-or and adjacency denotes logical and. Let $C_0$ denote the carry-in to bit position $0$, and let $C_4$ denote the carry-out of the most significant bit position.\n\nYou are asked to model the computation of $C_4$ using a tree of $2:1$ multiplexers, where for each bit position $i$, the multiplexer uses $p_i$ as its select input and uses the pair $(g_i, C_i)$ as its data inputs, in the order $\\text{data0} = g_i$ and $\\text{data1} = C_i$. Starting only from the definitions of $p_i$ and $g_i$, and from the meaning of carry generation and carry propagation, derive the nested multiplexer expression for $C_4$ and justify its correctness by logical equivalence.\n\nThen, analyze timing under the following technology assumptions, where all gates are idealized with a single propagation delay independent of input slews and output loads, and interconnect delays are negligible:\n- Each $2:1$ multiplexer has propagation delay $t_{\\text{MUX}} = 0.09 \\text{ ns}$.\n- Each two-input and gate has propagation delay $t_{\\land} = 0.03 \\text{ ns}$.\n- Each two-input or gate has propagation delay $t_{\\lor} = 0.04 \\text{ ns}$.\n\nFor the multiplexer-tree realization, assume $C_4$ is formed by cascading four $2:1$ multiplexers, one per bit position. For a comparison logic-gate realization of $C_4$, consider the canonical sum-of-products form built from the signals $p_3, p_2, p_1, p_0, g_3, g_2, g_1, g_0$, and $C_0$. Implement each product term as a right-associative chain of two-input and gates, and combine the five product terms using a balanced tree of two-input or gates. Under these assumptions:\n- Determine the worst-case path delay $D_{\\text{MUX}}$ from $\\{p_i, g_i, C_0\\}$ to $C_4$ through the multiplexer tree.\n- Determine the worst-case path delay $D_{\\text{LOGIC}}$ from $\\{p_i, g_i, C_0\\}$ to $C_4$ through the logic-gate realization.\n\nFinally, compute the ratio $R = D_{\\text{MUX}} / D_{\\text{LOGIC}}$. Express your final ratio as an exact number with no units. No rounding is required.",
            "solution": "First, we derive the multiplexer expression for $C_4$. The carry-out of a single bit-slice $i$, $C_{i+1}$, can be expressed by the standard carry recurrence relation:\n$$C_{i+1} = g_i \\lor (p_i \\land C_i)$$\nThe problem specifies a $2:1$ multiplexer with select input $S=p_i$, data input $D_0=g_i$, and data input $D_1=C_i$. The output of this multiplexer is:\n$$Y_i = (\\overline{S} \\land D_0) \\lor (S \\land D_1) = (\\overline{p_i} \\land g_i) \\lor (p_i \\land C_i)$$\nTo justify that this multiplexer computes the next carry, i.e., $Y_i = C_{i+1}$, we must show that $(\\overline{p_i} \\land g_i) \\lor (p_i \\land C_i)$ is logically equivalent to $g_i \\lor (p_i \\land C_i)$. This equivalence holds if and only if $g_i \\land p_i = 0$. Using the definitions of $p_i$ and $g_i$:\n$$g_i \\land p_i = (a_i b_i) \\land (a_i \\oplus b_i) = (a_i b_i) \\land (a_i \\overline{b_i} \\lor \\overline{a_i} b_i)$$\n$$= (a_i b_i \\land a_i \\overline{b_i}) \\lor (a_i b_i \\land \\overline{a_i} b_i) = (a_i \\land b_i \\land \\overline{b_i}) \\lor (a_i \\land \\overline{a_i} \\land b_i) = 0 \\lor 0 = 0$$\nSince $g_i \\land p_i = 0$, the standard carry recurrence $g_i \\lor (p_i \\land C_i)$ can be rewritten as $(\\overline{p_i} \\land g_i) \\lor (p_i \\land g_i) \\lor (p_i \\land C_i) = (\\overline{p_i} \\land g_i) \\lor (p_i \\land (g_i \\lor C_i))$. This is not quite it. The simpler way is to use the property that if $A \\land B = 0$, then $A \\lor B = (\\bar{A} \\land B) \\lor A$. Let $A = p_i \\land C_i$ and $B=g_i$. Wait. Let's start from $g_i \\lor (p_i \\land C_i) = (g_i \\land 1) \\lor (p_i \\land C_i) = (g_i \\land (p_i \\lor \\overline{p_i})) \\lor (p_i \\land C_i) = (g_i \\land p_i) \\lor (g_i \\land \\overline{p_i}) \\lor (p_i \\land C_i)$. Since $g_i \\land p_i = 0$, this simplifies to $(g_i \\land \\overline{p_i}) \\lor (p_i \\land C_i)$, which is the multiplexer function.\nThus, $C_{i+1} = \\text{MUX}(p_i, g_i, C_i)$. Unrolling this for a 4-bit adder gives the nested expression:\n$$C_4 = \\text{MUX}(p_3, g_3, \\text{MUX}(p_2, g_2, \\text{MUX}(p_1, g_1, \\text{MUX}(p_0, g_0, C_0))))$$\n\n**Timing analysis of the multiplexer tree ($D_{\\text{MUX}}$):**\nThe nested structure forms a serial chain of four multiplexers. The worst-case delay is the path from $C_0$ to $C_4$, which traverses all four multiplexers.\n$$D_{\\text{MUX}} = 4 \\times t_{\\text{MUX}} = 4 \\times 0.09 \\text{ ns} = 0.36 \\text{ ns}$$\n\n**Timing analysis of the logic-gate realization ($D_{\\text{LOGIC}}$):**\nThe sum-of-products (SoP) expression for $C_4$ is:\n$$C_4 = g_3 \\lor p_3 g_2 \\lor p_3 p_2 g_1 \\lor p_3 p_2 p_1 g_0 \\lor p_3 p_2 p_1 p_0 C_0$$\nThis has 5 product terms.\n1.  **AND stage delay**: The longest product term is $p_3 p_2 p_1 p_0 C_0$, which has 5 inputs. Implemented as a chain of two-input AND gates, this requires $5-1=4$ gates in series. The delay is:\n    $D_{\\text{AND}} = 4 \\times t_{\\land} = 4 \\times 0.03 \\text{ ns} = 0.12 \\text{ ns}$\n2.  **OR stage delay**: The 5 product terms are combined using a balanced tree of two-input OR gates. The depth of this tree is $\\lceil \\log_2 5 \\rceil = 3$. The delay is:\n    $D_{\\text{OR}} = 3 \\times t_{\\lor} = 3 \\times 0.04 \\text{ ns} = 0.12 \\text{ ns}$\n\nThe total worst-case delay $D_{\\text{LOGIC}}$ is the sum of the AND and OR stage delays:\n$$D_{\\text{LOGIC}} = D_{\\text{AND}} + D_{\\text{OR}} = 0.12 \\text{ ns} + 0.12 \\text{ ns} = 0.24 \\text{ ns}$$\n\n**Final ratio calculation:**\n$$R = \\frac{D_{\\text{MUX}}}{D_{\\text{LOGIC}}} = \\frac{0.36 \\text{ ns}}{0.24 \\text{ ns}} = \\frac{36}{24} = \\frac{3}{2} = 1.5$$",
            "answer": "$$\\boxed{1.5}$$"
        },
        {
            "introduction": "A circuit that is correct on paper can sometimes fail in practice due to the finite speed of logic gates. This practice explores the critical, real-world problem of timing hazards—transient glitches that can corrupt computation—within a single bit-slice of a CLA . You will identify a specific input transition that exposes a hazard in the standard carry logic and analyze how a logically redundant, but dynamically robust, circuit structure can eliminate the problem, highlighting the importance of designing for timing integrity.",
            "id": "3626955",
            "problem": "A designer is validating a single-bit slice of a Carry-Lookahead Adder (CLA) where per-bit generate and propagate are defined by the widely used facts of combinational addition: for bit index $i$, the generate signal is $G_i = A_i B_i$ and the propagate signal is $P_i = A_i \\oplus B_i$ (Exclusive-OR (XOR)). The incoming carry is $C_i$, and the carry-out is given by the canonical recurrence $C_{i+1} = G_i \\lor \\left(P_i \\land C_i\\right)$, which follows directly from the definition that a bit either generates a carry when $A_i = 1$ and $B_i = 1$ or propagates an incoming carry when exactly one of $A_i, B_i$ is $1$. To stress-test robustness against logic hazards, the designer intentionally inserts an extra propagation delay $\\Delta t_P$ in the $P_i$ path, while $G_i$ and $C_i$ have negligible additional delay relative to each other. The environment may toggle $A_i$, $B_i$, and $C_i$ in various ways with realistic skew.\n\nUsing the foundational base of Boolean algebra and the definitions above, the designer wishes to (i) propose a concrete input-transition test that is most likely to reveal wrong pulses (glitches) on $C_{i+1}$ arising from the intentional delay in $P_i$, and (ii) select a redundancy-based modification to the carry computation that eliminates such glitches without changing the steady-state function. Which option correctly predicts the wrong $C_{i+1}$ pulse under the delayed $P_i$ and proposes a logically sound redundancy to eliminate it?\n\nA. Stimulus: Hold $C_i = 1$, and simultaneously swap $A_i$ and $B_i$ from $(A_i, B_i) = (0, 1)$ to $(A_i, B_i) = (1, 0)$ (so the ideal $P_i$ remains $1$ and $G_i$ remains $0$ before and after). Prediction: A negative-going glitch appears on $C_{i+1}$ because $P_i$ momentarily drops to $0$ under skew in $A_i$ and $B_i$ combined with the extra $\\Delta t_P$, making $P_i C_i$ briefly $0$ while $G_i = 0$. Fix: Replace the $P_i C_i$ term by a redundant decomposition $A_i C_i \\lor B_i C_i$, yielding $C_{i+1} = G_i \\lor A_i C_i \\lor B_i C_i$, so that during the swap at least one of $A_i C_i$ or $B_i C_i$ remains $1$ and no glitch occurs.\n\nB. Stimulus: Toggle $C_i$ while $A_i = 1$ and $B_i = 1$. Prediction: A glitch appears on $C_{i+1}$ because $P_i$ is delayed. Fix: Compute $P_i$ only as $A_i \\lor B_i$ (logical OR) and use $C_{i+1} = G_i \\lor \\left(P_i \\land C_i\\right)$.\n\nC. Stimulus: Hold $(A_i, B_i) = (1, 0)$ and toggle $C_i$ from $0$ to $1$. Prediction: A positive-going glitch appears on $C_{i+1}$ due to delayed $P_i$. Fix: Duplicate the XOR gate for $P_i$ into two parallel $P_i$ paths and OR their outputs to suppress hazards.\n\nD. Stimulus: Hold $C_i = 1$ and toggle $A_i$ from $0$ to $1$ with $B_i = 0$. Prediction: A negative-going glitch appears on $C_{i+1}$ because $P_i$ is delayed. Fix: Replace XOR with Exclusive-NOR (XNOR) for $P_i$ so that $P_i$ is $1$ when $A_i = B_i$, which stabilizes the carry.",
            "solution": "The correct option is A. Here is a detailed analysis:\n\nThe carry-out function is $C_{i+1} = G_i \\lor (P_i \\land C_i)$, with $G_i = A_i B_i$ and $P_i = A_i \\oplus B_i$. We are looking for a static-1 hazard, where the output is supposed to remain at logic 1 but momentarily glitches to 0 due to path delays.\n\n**1. Analysis of the Stimulus and Prediction in Option A:**\n*   **Stimulus:** Hold $C_i = 1$ and swap $(A_i, B_i)$ from $(0, 1)$ to $(1, 0)$.\n*   **Initial State $(A_i, B_i, C_i) = (0, 1, 1)$:**\n    *   $G_i = 0 \\land 1 = 0$.\n    *   $P_i = 0 \\oplus 1 = 1$.\n    *   $C_{i+1} = 0 \\lor (1 \\land 1) = 1$.\n*   **Final State $(A_i, B_i, C_i) = (1, 0, 1)$:**\n    *   $G_i = 1 \\land 0 = 0$.\n    *   $P_i = 1 \\oplus 0 = 1$.\n    *   $C_{i+1} = 0 \\lor (1 \\land 1) = 1$.\nThe output $C_{i+1}$ is 1 before and after the transition. This is a valid test case for a static-1 hazard.\n\n*   **Glitch Mechanism:** The $P_i = A_i \\oplus B_i$ signal is generated by an XOR gate. When both its inputs, $A_i$ and $B_i$, change simultaneously (with some physical skew), the gate's output can glitch. For example, if $A_i$ changes from $0 \\to 1$ slightly before $B_i$ changes from $1 \\to 0$, the inputs to the XOR gate will momentarily be $(1, 1)$. The output of the XOR gate becomes $1 \\oplus 1 = 0$. Similarly, if $B_i$ changes first, the inputs are momentarily $(0,0)$, and the output is $0 \\oplus 0 = 0$. In either case, the $P_i$ signal glitches from $1 \\to 0 \\to 1$.\n*   **Output Glitch:** The output is $C_{i+1} = G_i \\lor (P_i \\land C_i)$. During the entire transition, $G_i$ remains 0 and $C_i$ remains 1. Therefore, $C_{i+1}$ simplifies to $P_i$. As $P_i$ glitches to 0, so does $C_{i+1}$. This creates the predicted negative-going glitch. The extra delay $\\Delta t_P$ in the propagate path influences the timing of this glitch at the final output.\n\n**2. Analysis of the Fix in Option A:**\n*   **Proposed Fix:** Replace the logic with $C_{i+1} = G_i \\lor A_i C_i \\lor B_i C_i$.\n*   **Logical Equivalence:** The standard full adder carry-out function is $C_{out} = A_i B_i \\lor A_i C_i \\lor B_i C_i$. This is logically equivalent to the original $A_i B_i \\lor (A_i \\oplus B_i)C_i$, so the steady-state behavior is unchanged.\n*   **Hazard Elimination:** This new expression eliminates the XOR gate for the propagate term, which was the source of the glitch. Let's analyze the new circuit with the same stimulus ($C_i=1$ and swapping $A_i, B_i$). The logic becomes $C_{i+1} = A_i B_i \\lor A_i \\lor B_i = A_i \\lor B_i$.\n    *   Initial state $(A_i, B_i) = (0, 1)$: $C_{i+1} = 0 \\lor 1 = 1$.\n    *   Final state $(A_i, B_i) = (1, 0)$: $C_{i+1} = 1 \\lor 0 = 1$.\n    During the transition, the output is held high by either the $A_i$ or the $B_i$ path. Because these paths are separate and OR'd together, as one goes low, the other goes high. This structure is inherently more robust to the specific input swap and prevents the glitch. This is a classic technique of adding redundant logic to eliminate hazards.\n\n**3. Analysis of Other Options:**\n*   **Option B:** When $A_i=1, B_i=1$, then $G_i=1$, which forces $C_{i+1}=1$ regardless of $C_i$ or $P_i$. Toggling $C_i$ has no effect. Incorrect.\n*   **Option C:** When $(A_i, B_i)=(1,0)$, then $G_i=0, P_i=1$. $C_{i+1} = C_i$. The output simply follows the input $C_i$; no glitch is expected. Incorrect.\n*   **Option D:** The transition from $(0,0,1)$ to $(1,0,1)$ causes the output to change from 0 to 1. This is a normal functional transition, not a static hazard scenario. Incorrect.\n\nThus, option A provides the correct stimulus, prediction, and solution for the described hazard problem.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}