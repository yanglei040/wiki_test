{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a tangible link between a familiar mathematical concept, the factorial, and the concrete limitations of hardware data types. By calculating the largest factorial that can fit into a 32-bit signed integer, you will gain a firsthand appreciation for how quickly computations can exceed standard representational bounds. This practice reinforces the importance of understanding data type ranges when implementing algorithms. ",
            "id": "3651585",
            "problem": "A software routine in a systems programming course is implemented to compute the factorial $n!$ using a $32$-bit signed integer type under two's complement representation. In two's complement, a signed $w$-bit integer ranges from $-2^{w-1}$ to $2^{w-1}-1$. The routine accumulates the product sequentially as $1 \\cdot 2 \\cdot 3 \\cdots n$, stored in a single $32$-bit signed integer variable, and the hardware raises an overflow condition if the magnitude of the true mathematical result exceeds the representable range.\n\nStarting from the formal definition of factorial $n!$ for $n \\in \\mathbb{N}$ and the representable range of $32$-bit signed two's complement integers, reason from first principles to determine the largest integer $n$ such that computing $n!$ in this type does not overflow. Your derivation must justify why any larger $n$ necessarily causes overflow, without relying on unproven shortcut formulas.\n\nAdditionally, explain, grounded in fundamental properties of monotonic functions and transformations that preserve order, how one could design a mathematically principled pre-check to detect imminent overflow before performing the multiplication for large $n$, and briefly note when switching to arbitrary-precision (big integer) arithmetic becomes necessary in this context. Do not provide code; focus on the reasoning and mathematical justification.\n\nReport only the maximal $n$ as your final answer. No rounding is required, and no units are involved.",
            "solution": "The problem requires determining the largest integer $n$ for which its factorial, $n!$, can be stored in a $32$-bit signed integer variable using two's complement representation without causing an overflow.\n\nFirst, we establish the range of representable values. The problem states that for a $w$-bit signed integer in two's complement, the range is $[ -2^{w-1}, 2^{w-1}-1 ]$. For this problem, the width $w$ is $32$. Therefore, the range of a $32$-bit signed integer is $[ -2^{32-1}, 2^{32-1}-1 ]$, which simplifies to $[ -2^{31}, 2^{31}-1 ]$.\n\nThe maximum positive integer that can be represented, let's call it $V_{max}$, is $2^{31}-1$. To find its numerical value, we can compute $2^{31}$:\n$$ 2^{31} = 2 \\cdot 2^{30} = 2 \\cdot (2^{10})^{3} = 2 \\cdot (1024)^{3} = 2 \\cdot 1,073,741,824 = 2,147,483,648 $$\nThus, the maximum value is $V_{max} = 2,147,483,648 - 1 = 2,147,483,647$.\n\nThe factorial function, $n!$, is defined for a non-negative integer $n$ as the product of all positive integers up to $n$:\n$$ n! = \\prod_{k=1}^{n} k $$\nFor any $n \\ge 0$, the value of $n!$ is non-negative. Therefore, to avoid overflow, the computed value of $n!$ must not exceed $V_{max}$. The condition is $n! \\le 2^{31}-1$.\n\nWe will now compute the values of $n!$ for increasing $n$, starting from $n=1$, and compare them to $V_{max}$.\n$1! = 1$\n$2! = 2$\n$3! = 6$\n$4! = 24$\n$5! = 120$\n$6! = 720$\n$7! = 5,040$\n$8! = 40,320$\n$9! = 362,880$\n$10! = 3,628,800$\n$11! = 10! \\cdot 11 = 3,628,800 \\cdot 11 = 39,916,800$\n$12! = 11! \\cdot 12 = 39,916,800 \\cdot 12 = 479,001,600$\n\nWe check if $12!$ is within the representable range:\n$479,001,600 \\le 2,147,483,647$. This inequality is true. Therefore, $12!$ can be correctly computed and stored.\n\nNext, we compute the value for $n=13$:\n$13! = 12! \\cdot 13 = 479,001,600 \\cdot 13 = 6,227,020,800$\n\nWe check if $13!$ is within the representable range:\n$6,227,020,800 \\le 2,147,483,647$. This inequality is false. Thus, computing $13!$ results in a value that is too large to be stored, causing an overflow.\n\nTo justify that $n=12$ is the maximal such integer, we must demonstrate that for any integer $m > 12$, $m!$ also causes an overflow. This relies on the monotonic property of the factorial function. The function $f(n) = n!$ is strictly monotonically increasing for $n \\ge 1$. This can be shown by considering the ratio of successive terms: for $n \\ge 1$, $(n+1)! = (n+1) \\cdot n!$. Since $n+1 > 1$, it follows that $(n+1)! > n!$.\nBecause the factorial function is strictly increasing, and we have established that $13! > V_{max}$, it must be that for any integer $m > 13$, $m! = m \\cdot (m-1) \\cdots 14 \\cdot 13! > 13!$. Since $13!$ already exceeds $V_{max}$, any factorial $m!$ for $m \\ge 13$ will also exceed $V_{max}$.\nTherefore, the largest integer $n$ for which $n!$ can be computed without overflow in a $32$-bit signed integer is $12$.\n\nRegarding the design of a pre-check to detect imminent overflow, let's consider the iterative computation of $n!$. At step $k$ (for $k$ from $2$ to $n$), we compute a new product by multiplying the previous product, $(k-1)!$, by $k$. Let $P_{k-1} = (k-1)!$. Before computing $P_k = P_{k-1} \\cdot k$, we must check if this operation will overflow. An overflow will occur if $P_{k-1} \\cdot k > V_{max}$.\nPerforming the multiplication to check this condition is self-defeating, as the multiplication itself is the operation we want to avoid if it overflows. Instead, we can rearrange the inequality. The function $g(x) = x/k$ for a positive integer $k$ is a strictly increasing function, meaning it is an order-preserving transformation. Applying this transformation to the inequality does not change its direction. Therefore, for $k>0$, the condition $P_{k-1} \\cdot k > V_{max}$ is mathematically equivalent to $P_{k-1} > V_{max}/k$.\nThis check is computationally safe. At the beginning of step $k$, the value $P_{k-1}$ is known to be valid and stored correctly. The check involves a division (which for integers can be performed as integer division) and a comparison, both of which are safe operations. If the check $P_{k-1} > V_{max}/k$ is true, an overflow is imminent, and the multiplication should not be performed.\n\nFinally, arbitrary-precision (big integer) arithmetic becomes necessary when the problem domain requires exact integer calculations for numbers whose magnitudes exceed the limits of fixed-size hardware integer types. The factorial function $n!$ grows superexponentially. As shown, $13!$ overflows a $32$-bit integer. Similarly, one can show that $21!$ overflows a $64$-bit signed integer (whose maximum value is $2^{63}-1 \\approx 9.22 \\times 10^{18}$). For applications in fields like cryptography, number theory, or symbolic computation that require exact factorials of larger numbers (e.g., $100!$), fixed-precision arithmetic is fundamentally inadequate. Such applications must use software libraries that represent numbers using dynamic data structures (like arrays of digits) and provide algorithms to perform arithmetic operations on them, with the number's size being limited only by available memory rather than a fixed bit-width.",
            "answer": "$$ \\boxed{12} $$"
        },
        {
            "introduction": "Moving from the concept of overflow to its detection, this practice focuses on the processor's status flags. You will implement a testbench to observe the behavior of the Carry Flag (CF) and Overflow Flag (OF) during subtraction across critical boundary conditions. This hands-on coding exercise demystifies how hardware distinguishes between unsigned wraparound and signed overflow, which are fundamental to low-level debugging and system programming. ",
            "id": "3651567",
            "problem": "You are to implement a complete, runnable program that constructs a subtraction testbench for binary two’s complement arithmetic with a fixed word width $w$. The testbench scans the minuend $a$ over a contiguous set of signed values with step $1$ (in signed order), while keeping $b$ fixed, and records where the Carry Flag (CF) and the Overflow Flag (OF) each change state as $a$ increments by $1$.\n\nFundamental base and required semantics:\n- In two’s complement with fixed width $w$, arithmetic is performed modulo $2^w$. The subtraction $a - b$ is defined as two’s complement addition of $a$ and the two’s complement of $b$, followed by reduction modulo $2^w$.\n- The Carry Flag (CF) for subtraction is defined as the borrow out of the most significant bit of the $w$-bit subtraction under an unsigned interpretation.\n- The Overflow Flag (OF) for subtraction is defined by signed two’s complement semantics: it indicates whether the $w$-bit result, interpreted as a signed two’s complement integer in $[-2^{w-1}, 2^{w-1} - 1]$, fails to represent the true mathematical difference of the signed operands.\n\nYour program must:\n1. For each test case, interpret $a$ and $b$ as $w$-bit two’s complement integers, i.e., use modulo $2^w$ representations on input and output values where appropriate, and perform all arithmetic modulo $2^w$.\n2. For each test case, scan $a$ from $a_{\\mathrm{low}}$ to $a_{\\mathrm{high}}$ inclusive, in signed order with step $1$, and compute both CF and OF for the operation $a - b$ at each $a$.\n3. Define a transition point for a flag $F \\in \\{\\mathrm{CF}, \\mathrm{OF}\\}$ as the signed value $k$ such that the value of $F$ at $a = k$ differs from its value at the immediately previous signed value $a = k - 1$ (both within the scan interval).\n4. Record, for each test case, two lists of signed integers: the list of all CF transition points and the list of all OF transition points, each expressed as the corresponding signed $a$ values where the transitions occur.\n\nConstraints and modeling requirements:\n- All calculations must be carried out using exactly $w$-bit two’s complement semantics, independent of the machine’s native integer width. You must explicitly reduce intermediate and final values modulo $2^w$ by masking to $2^w - 1$.\n- Do not assume any architecture-specific quirks beyond these standard definitions of CF and OF for subtraction in two’s complement arithmetic.\n\nTest suite to implement:\n- Case $1$: $w = 8$, $b = 1$, $a \\in [-4, 4]$.\n- Case $2$: $w = 8$, $b = 0$, $a \\in [-4, 4]$.\n- Case $3$: $w = 8$, $b = -128$, $a \\in [-4, 4]$.\n- Case $4$: $w = 8$, $b = -1$, $a \\in [-4, 4]$.\n- Case $5$: $w = 8$, $b = -1$, $a \\in [124, 127]$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For each test case, output a two-element list: the first element is the list of CF transition points (signed $a$ values), and the second element is the list of OF transition points (signed $a$ values).\n- Aggregate the per-test-case two-element lists into a single outer list, in the order the cases are listed above.\n- The final output must contain no spaces and must use only decimal integers for the $a$ values. For example, an output with two test cases might look like $[[[0,1],[]],[[2],[3]]]$.\n\nNo physical units, angle units, or percentages are required for this problem. The answers are integers only. The program must be self-contained and must not read any input.",
            "solution": "The problem requires the implementation of a testbench to identify transition points for the Carry Flag (CF) and Overflow Flag (OF) during a series of two's complement subtractions. The minuend, $a$, is scanned over a specified range while the subtrahend, $b$, remains fixed. The arithmetic is performed with a fixed word width, $w$.\n\nA rigorous solution necessitates a precise formalization of the underlying arithmetic principles and flag definitions.\n\n**1. Two's Complement Arithmetic**\n\nIn a $w$-bit two's complement system, an integer $x$ in the signed range $[-2^{w-1}, 2^{w-1} - 1]$ is represented by a $w$-bit unsigned integer, which we denote as its bit pattern $X$. The mapping is defined as $X = x \\pmod{2^w}$. All arithmetic operations are performed modulo $2^w$. For this problem, we are given $w=8$, so the signed range is $[-128, 127]$ and arithmetic is performed modulo $2^8 = 256$.\n\nThe subtraction $s = a - b$ is computed by adding the two's complement of $b$ to $a$. The two's complement of $b$ is $(\\neg B) + 1$, where $B$ is the bit pattern of $b$ and $\\neg$ denotes bitwise NOT. Thus, the bit pattern of the result, $S$, is calculated as:\n$$S = (A + (\\neg B + 1)) \\pmod{2^w}$$\nThis is equivalent to performing unsigned subtraction on the bit patterns:\n$$S = (A - B) \\pmod{2^w}$$\nIn our implementation, we can use standard integer types and apply a bitmask of $2^w - 1$ to ensure all results are properly truncated to $w$ bits. For $w=8$, this mask is $0xFF$.\n\n**2. Carry Flag (CF) Definition for Subtraction**\n\nThe problem defines the Carry Flag (CF) as the borrow out of the most significant bit (MSB) position during an unsigned subtraction. A borrow is required for the subtraction $A - B$ if and only if $A$ is less than $B$ when both are treated as unsigned integers.\nTherefore, the logic for the Carry Flag is:\n$$\\text{CF} = \\begin{cases} 1  \\text{if } A  B \\\\ 0  \\text{if } A \\ge B \\end{cases}$$\nwhere $A$ and $B$ are the $w$-bit unsigned representations of the signed integers $a$ and $b$, respectively.\n\n**3. Overflow Flag (OF) Definition for Subtraction**\n\nThe Overflow Flag (OF) indicates that the result of a signed operation cannot be represented within the $w$-bit two's complement range. For subtraction, $s = a - b$, an overflow can only occur if the operands $a$ and $b$ have different signs.\n- If $a$ is positive and $b$ is negative, their difference $a-b$ is a large positive number. Overflow occurs if this true result exceeds $2^{w-1}-1$.\n- If $a$ is negative and $b$ is positive, their difference $a-b$ is a large negative number. Overflow occurs if this true result is less than $-2^{w-1}$.\n\nLet $s(x)$ be the sign bit (MSB) of the $w$-bit representation of an integer $x$. The sign bit is $0$ for non-negative numbers and $1$ for negative numbers. Let $s_{computed}$ be the sign of the $w$-bit result of the subtraction. An overflow occurs if and only if the signs of the operands are different, and the sign of the result is different from the sign of the minuend $a$.\n$$\\text{OF} = 1 \\iff (s(a) \\neq s(b)) \\land (s(s_{computed}) \\neq s(a))$$\nThis can be efficiently implemented using bitwise operations. Let $A$, $B$, and $S$ be the $w$-bit patterns for $a$, $b$, and the computed result $s$. The sign bit is the $(w-1)$-th bit.\n$$\\text{OF} = \\left(\\frac{A \\oplus B}{2^{w-1}}\\right) \\land \\left(\\frac{A \\oplus S}{2^{w-1}}\\right)$$\nwhere $\\oplus$ is the bitwise XOR operator and the divisions are integer divisions (equivalent to right-shifts). This expression evaluates to $1$ if and only if the MSBs of $(A, B)$ differ and the MSBs of $(A, S)$ differ.\n\n**4. Algorithm for Detecting Transitions**\n\nA transition point for a flag is a value $k$ in the scan range where the flag's state changes from its state at $k-1$. The problem specifies that both $k$ and $k-1$ must lie within the scan interval $[a_{\\mathrm{low}}, a_{\\mathrm{high}}]$. This implies that the first possible transition point is $k = a_{\\mathrm{low}} + 1$.\n\nThe algorithm for a given test case ($w, b, a_{\\mathrm{low}}, a_{\\mathrm{high}}$) is as follows:\n1. Initialize empty lists for CF and OF transition points.\n2. Determine the bit pattern for the subtrahend, $B$, from the signed integer $b$.\n3. Compute the initial state of the flags. Calculate $\\text{CF}_{\\text{prev}}$ and $\\text{OF}_{\\text{prev}}$ for the operation $(a_{\\mathrm{low}} - b)$.\n4. Iterate with a signed integer $a$ from $a_{\\mathrm{low}} + 1$ to $a_{\\mathrm{high}}$, inclusive. This loop variable $a$ represents the potential transition point $k$.\n5. Inside the loop, for each value of $a$:\n    a. Determine the bit pattern for the minuend, $A$.\n    b. Calculate the current flags, $\\text{CF}_{\\text{curr}}$ and $\\text{OF}_{\\text{curr}}$, for the operation $(a - b)$.\n    c. If $\\text{CF}_{\\text{curr}} \\neq \\text{CF}_{\\text{prev}}$, record $a$ as a CF transition point.\n    d. If $\\text{OF}_{\\text{curr}} \\neq \\text{OF}_{\\text{prev}}$, record $a$ as an OF transition point.\n    e. Update the previous flag states: $\\text{CF}_{\\text{prev}} = \\text{CF}_{\\text{curr}}$ and $\\text{OF}_{\\text{prev}} = \\text{OF}_{\\text{curr}}$.\n6. After the loop completes, the collected lists contain all transition points for the given test case.\n7. Repeat for all test cases and format the output as specified.\n\nThis procedure correctly identifies every point where a flag's value differs from its value at the immediately preceding integer within the scan range, satisfying all problem requirements.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n// The problem statement explicitly forbids complex.h, threads.h, and stdatomic.h\n// for this particular problem's solution, as they are not needed.\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int w;\n    int b;\n    int a_low;\n    int a_high;\n} TestCase;\n\n// Helper function to print a list of integers in the required format.\nvoid print_int_list(int* arr, int count) {\n    printf(\"[\");\n    for (int i = 0; i  count; ++i) {\n        printf(\"%d\", arr[i]);\n        if (i  count - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {8, 1, -4, 4},\n        {8, 0, -4, 4},\n        {8, -128, -4, 4},\n        {8, -1, -4, 4},\n        {8, -1, 124, 127}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n\n    printf(\"[\"); // Start of the outer list\n\n    for (int i = 0; i  num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int w = tc.w;\n        int a_low = tc.a_low;\n        int a_high = tc.a_high;\n\n        // Use a fixed-size buffer; scan ranges are small.\n        int cf_transitions[20];\n        int of_transitions[20];\n        int cf_count = 0;\n        int of_count = 0;\n\n        // Create the w-bit mask and MSB mask.\n        unsigned int mask = (1u  w) - 1;\n        unsigned int msb_mask = 1u  (w - 1);\n\n        // Get the w-bit unsigned representation of the subtrahend b.\n        unsigned int B = (unsigned int)tc.b  mask;\n\n        // If the scan range is empty or has only one element, no transitions can occur.\n        if (a_low = a_high) {\n            // Print empty results for this case and continue.\n            if (i  0) printf(\",\");\n            printf(\"[[],[]]\");\n            continue;\n        }\n\n        // --- Calculate initial state at a = a_low ---\n        unsigned int A_prev = (unsigned int)a_low  mask;\n        unsigned int S_prev = (A_prev - B)  mask;\n        \n        int cf_prev = (A_prev  B);\n        int of_prev = (((A_prev ^ B)  (A_prev ^ S_prev))  msb_mask) != 0;\n\n        // --- Scan from a_low + 1 to a_high to find transitions ---\n        for (int a_curr_signed = a_low + 1; a_curr_signed = a_high; ++a_curr_signed) {\n            unsigned int A_curr = (unsigned int)a_curr_signed  mask;\n            unsigned int S_curr = (A_curr - B)  mask;\n\n            int cf_curr = (A_curr  B);\n            int of_curr = (((A_curr ^ B)  (A_curr ^ S_curr))  msb_mask) != 0;\n\n            if (cf_curr != cf_prev) {\n                if (cf_count  20) {\n                    cf_transitions[cf_count++] = a_curr_signed;\n                }\n            }\n            if (of_curr != of_prev) {\n                if (of_count  20) {\n                    of_transitions[of_count++] = a_curr_signed;\n                }\n            }\n            \n            // Update previous state for the next iteration\n            cf_prev = cf_curr;\n            of_prev = of_curr;\n        }\n\n        // Print the results for the current test case.\n        if (i  0) {\n            printf(\",\");\n        }\n        printf(\"[\");\n        print_int_list(cf_transitions, cf_count);\n        printf(\",\");\n        print_int_list(of_transitions, of_count);\n        printf(\"]\");\n    }\n\n    printf(\"]\\n\"); // End of the outer list\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Building on our understanding of overflow, this final exercise shifts our focus from detection to prevention, a key aspect of robust system design. You will determine the number of \"guard bits\" required to guarantee that an accumulator does not overflow when summing a series of values, resulting in the important design rule $g(k) = \\lceil \\log_2(k) \\rceil$. This problem illustrates a fundamental principle used in digital signal processing and other applications where computational integrity is paramount. ",
            "id": "3651590",
            "problem": "A fixed-point accumulator in a digital signal path is implemented as an unsigned, fixed-width register that can hold exactly $n$ bits. Each input sample is an $n$-bit unsigned integer. The accumulator starts at $0$ and performs repeated additions of identical inputs into itself, one per clock cycle, using standard modulo-$2^{n}$ arithmetic with an overflow flag that is asserted if and only if the true mathematical sum at any cycle is outside the representable range $\\{0,1,\\dots,2^{n}-1\\}$.\n\nYou are asked to reason from first principles about worst-case overflow when summing multiple $n$-bit quantities and the number of additional “guard” bits needed to provably prevent overflow during the accumulation of $k$ samples.\n\nTasks to guide your reasoning:\n\n1) Using only the definition of the $n$-bit unsigned range and the definition of overflow above, determine the smallest positive integer $k_{\\min}(n)$ with the following “must-overflow” property: for every fixed nonzero $n$-bit unsigned value $x$ and starting from $0$, the process of summing $k_{\\min}(n)$ identical copies of $x$ into an $n$-bit accumulator must overflow at or before the $k_{\\min}(n)$-th addition.\n\n2) Now suppose the accumulator width can be extended by $g$ guard bits, so that the accumulator holds $n+g$ bits while each input sample remains $n$ bits. Determine, in closed form and justified from first principles, the smallest integer function $g(k)$ of $k$ such that, for any sequence of $k$ $n$-bit unsigned inputs (not necessarily identical), the accumulation from $0$ into an $(n+g)$-bit accumulator cannot overflow.\n\nProvide your final answer as the single closed-form expression for $g(k)$ in simplest terms. No rounding is required and no units are involved.",
            "solution": "The problem statement is analyzed and found to be valid. It is scientifically grounded in the principles of digital computer arithmetic, well-posed with clear objectives, and uses precise, unambiguous language. It is a standard problem in computer architecture and digital signal processing. Therefore, a full solution is provided.\n\nThe problem asks for two quantities related to overflow in a fixed-point accumulator. First, we will analyze the scenario of summing identical inputs to find a guaranteed overflow point. Second, we will determine the number of guard bits required to prevent overflow when summing a number of arbitrary inputs.\n\n**Part 1: Minimum Number of Additions to Guarantee Overflow**\n\nAn $n$-bit unsigned integer register can represent values in the set $\\{0, 1, 2, \\dots, 2^n-1\\}$. The accumulator is of this type. An overflow is defined to occur if and only if the true mathematical sum is greater than or equal to $2^n$.\n\nWe are summing $k$ identical copies of a fixed nonzero $n$-bit unsigned value $x$. The value of $x$ is in the range $\\{1, 2, \\dots, 2^n-1\\}$. After $j$ additions of $x$ to an accumulator starting at $0$, the true sum is $S_j = j \\cdot x$. An overflow occurs at or before the $k_{\\min}(n)$-th addition if there exists an integer $j$ with $1 \\le j \\le k_{\\min}(n)$ such that $S_j \\ge 2^n$.\n\nThe problem asks for the smallest integer $k_{\\min}(n)$ that guarantees this property for *every* possible choice of nonzero $x$. To find such a \"worst-case\" bound, we must consider the input $x$ that is least likely to cause an overflow. The sum $S_j = j \\cdot x$ grows most slowly when $x$ is minimized. The smallest nonzero $n$-bit unsigned integer is $x=1$. If we can find a $k_{\\min}(n)$ that guarantees overflow for $x=1$, it will also guarantee overflow for any $x > 1$, since $j \\cdot x \\ge j \\cdot 1$.\n\nLet's analyze the case $x=1$. The true sum after $j$ additions is $S_j=j$. The first time an overflow occurs is when the sum reaches $2^n$. This happens precisely at the $j=2^n$-th addition. For any $j  2^n$, the sum is $j$, which is less than $2^n$ and fits within the $n$-bit accumulator. Thus, for $x=1$, exactly $2^n$ additions are required to cause the first overflow.\n\nIf we were to choose $k = 2^n - 1$, and the input happened to be $x=1$, then after $2^n-1$ additions, the sum would be $2^n-1$. This value is the largest representable value in an $n$-bit register, so no overflow would have occurred yet. Therefore, to *guarantee* an overflow for any nonzero $x$, we must have $k_{\\min}(n) \\ge 2^n$.\n\nLet's test if $k_{\\min}(n) = 2^n$ is sufficient. We need to show that for any $x \\in \\{1, 2, \\dots, 2^n-1\\}$, an overflow must occur at or before the $2^n$-th step. This means we must show there is a $j \\in \\{1, 2, \\dots, 2^n\\}$ such that $j \\cdot x \\ge 2^n$.\nAssume, for the sake of contradiction, that for some nonzero $x$, no overflow occurs for any $j \\le 2^n$. This would imply that $j \\cdot x  2^n$ for all $j \\in \\{1, 2, \\dots, 2^n\\}$. This must hold for $j=2^n$ as well, which gives the inequality $2^n \\cdot x  2^n$. Since $x$ is a positive integer, this implies $x  1$. This contradicts the given condition that $x$ is a nonzero unsigned integer (i.e., $x \\ge 1$). Therefore, our assumption was false, and an overflow must occur for some $j \\le 2^n$.\n\nThe smallest integer with this property is thus $k_{\\min}(n)=2^n$.\n\n**Part 2: Number of Guard Bits to Prevent Overflow**\n\nWe are now summing $k$ potentially different $n$-bit unsigned inputs, $x_1, x_2, \\dots, x_k$. The accumulator is widened to $n+g$ bits, where $g$ is the number of \"guard\" bits. An $(n+g)$-bit unsigned register can represent integers in the range $\\{0, 1, \\dots, 2^{n+g}-1\\}$.\n\nTo prevent overflow, the true sum $S_k = \\sum_{i=1}^k x_i$ must never exceed the maximum representable value of the accumulator. That is, for any possible sequence of $k$ inputs, we must have:\n$$ S_k \\le 2^{n+g} - 1 $$\nTo guarantee this, we must design for the worst-case (maximum possible) sum, $S_{max}$. The sum is maximized when every input $x_i$ takes its maximum possible value. The maximum value for an $n$-bit unsigned integer is $2^n-1$.\n$$ S_{max} = \\sum_{i=1}^k (2^n - 1) = k(2^n - 1) $$\nSo, the condition to prevent overflow becomes a search for the smallest integer $g$ that satisfies:\n$$ k(2^n - 1) \\le 2^{n+g} - 1 $$\nThis inequality can be simplified by considering a slightly looser but still sufficient condition. The sum $S_k$ must be strictly less than the first non-representable integer, which is $2^{n+g}$. This gives:\n$$ S_{max}  2^{n+g} $$\nSubstituting the expression for $S_{max}$:\n$$ k(2^n - 1)  2^{n+g} $$\nTo isolate $g$, we can divide by $2^n$:\n$$ k(1 - 2^{-n})  2^g $$\nThe problem asks for a function $g(k)$ that is independent of $n$. The inequality above must hold for any $n \\ge 1$. The term on the left, $k(1 - 2^{-n})$, is an increasing function of $n$. As $n$ becomes very large, the term $2^{-n}$ approaches $0$, and the left-hand side approaches $k$.\n$$ \\lim_{n\\to\\infty} k(1 - 2^{-n}) = k $$\nFor any finite $n \\ge 1$, we have $1 - 2^{-n}  1$, which implies $k(1 - 2^{-n})  k$. To satisfy the inequality for all possible values of $n$, we must choose $g$ such that the inequality holds even as the left side approaches its supremum, $k$. A choice of $g$ that satisfies $k \\le 2^g$ ensures a solution because:\n$$ k(1 - 2^{-n})  k \\le 2^g $$\nSo we must find the smallest integer $g$ that satisfies $k \\le 2^g$. Taking the base-$2$ logarithm of both sides (since $k \\ge 1$, $\\log_2 k$ is well-defined and non-negative):\n$$ \\log_2(k) \\le g $$\nSince $g$ must be an integer, the smallest integer $g$ satisfying this condition is the ceiling of $\\log_2(k)$.\n$$ g(k) = \\lceil \\log_2(k) \\rceil $$\nTo confirm this is the smallest sufficient integer, consider choosing a smaller number of guard bits, $g' = g-1 = \\lceil \\log_2(k) \\rceil - 1$. From the definition of the ceiling function, we know that $g-1  \\log_2(k)$, which implies $2^{g-1}  k$, or $2^{g'}  k$. Overflow will occur with $g'$ guard bits if, for some $n$, $S_{max} \\ge 2^{n+g'}$. This leads to the condition:\n$$ k(1 - 2^{-n}) \\ge 2^{g'} $$\nSince we know $k > 2^{g'}$, we can write $k = 2^{g'} + \\delta$ for some $\\delta > 0$. The condition is $(2^{g'} + \\delta)(1-2^{-n}) \\ge 2^{g'}$. As $n \\to \\infty$, the left side approaches $2^{g'} + \\delta$, which is strictly greater than the right side, $2^{g'}$. By continuity, there must exist a sufficiently large but finite $n$ for which the inequality holds. Therefore, $g' = g-1$ bits are not sufficient to guarantee no overflow for all $n$.\nThe minimum number of guard bits is therefore $g(k) = \\lceil \\log_2(k) \\rceil$. For $k=1$, $g(1)=0$. For $k=2$, $g(2)=1$. For $k \\in \\{3,4\\}$, $g(k)=2$. For $k \\in \\{5,6,7,8\\}$, $g(k)=3$, and so on. This corresponds to the number of bits required to represent the growth of the sum.\n\nThe final answer required is the single closed-form expression for $g(k)$.",
            "answer": "$$ \\boxed{\\lceil \\log_2(k) \\rceil} $$"
        }
    ]
}