{
    "hands_on_practices": [
        {
            "introduction": "存储程序概念的一个直接体现是，程序必须首先作为数据加载到内存中才能执行。这个练习将这个抽象概念与系统启动的物理现实联系起来。通过计算一个简化系统的启动时间，你将亲身体验指令映像的加载如何依赖于内存总线带宽和传输协议，从而将系统性能与数据传输效率直接挂钩。",
            "id": "3682329",
            "problem": "“存储程序系统”实现了这样一种思想：指令是驻留在内存中的数据，中央处理器（CPU）从内存中获取它们并执行。考虑这样一个系统的最小引导加载程序，它在CPU开始从RAM中获取指令之前，通过同步总线将指令镜像从非易失性存储器（NVM）复制到随机存取存储器（RAM）中。总线宽度为 $W=128$ 位，CPU时钟频率为 $f=800 \\times 10^{6}$ 周期/秒，加载程序发出连续的突发读取，每次突发包含 $B=16$ 个总线字。每次突发读取会产生 $L=12$ 个周期的固定建立延迟，之后每个周期到达一个总线字，直到突发完成。指令镜像大小为 $N=64\\,\\text{MiB}$，其中 $1\\,\\text{MiB}=2^{20}\\,\\text{字节}$。假设加载程序发出最小数量的突发来覆盖 $N$ 字节；如果最后一次突发是部分的，它仍然会被发出并产生相同的建立延迟。\n\n仅从核心定义出发（例如，每个总线字的字节数由 $W$ 决定，每秒的周期数由 $f$ 决定，时间等于周期数除以 $f$），推导出总启动时间作为 $N$、$W$、$B$、$L$ 和 $f$ 的函数，然后根据给定参数进行数值计算。将最终启动时间以秒为单位表示，并将答案四舍五入到四位有效数字。在你的推导过程中，清楚地说明存储程序概念如何使启动时间依赖于内存带宽和传输粒度，而无需使用任何预先提供的快捷公式。",
            "solution": "该问题是有效的，因为它在科学上基于计算机体系结构的原理，问题陈述清晰，信息充分且一致，并且是客观的。所描述的场景是一个标准的引导加载过程，所提供的参数是现实的。\n\n解决方案首先建立存储程序概念与加载指令镜像这一物理任务之间的联系。存储程序概念是现代计算机体系结构的基石，它指出指令和数据一样，都存储在内存中。对于中央处理器（CPU）来说，要执行一个程序，该程序的指令必须首先驻留在CPU可以从中获取它们的内存类型中，通常是随机存取存储器（RAM）。问题描述了引导过程，其中一个初始指令镜像从非易失性存储器（NVM）源复制到RAM。这个传输是执行的强制性先决条件，其持续时间——即启动时间——因此是一个关键的性能指标。这个时间直接取决于内存子系统的物理特性，例如数据路径宽度和传输协议，我们现在将从第一性原理对其进行建模。\n\n首先，我们必须确定要传输的总数据量，以比特为基本单位表示。指令镜像大小给定为 $N = 64\\,\\text{MiB}$。使用提供的定义 $1\\,\\text{MiB} = 2^{20}\\,\\text{字节}$ 和字节的核心定义为 $8$ 比特，我们计算出总镜像大小（以比特为单位），$N_{bits}$：\n$$N_{bits} = N \\times (2^{20}\\ \\text{bytes/MiB}) \\times (8\\ \\text{bits/byte}) = 64 \\times 2^{20} \\times 8\\ \\text{bits}$$\n\n数据通过宽度为 $W = 128$ 比特的同步总线传输。总线上的每次传输移动一个 $W$ 比特的“总线字”。复制整个镜像必须传输的总线字数 $T_{words}$ 是总大小（以比特为单位）除以总线宽度（以比特为单位）：\n$$T_{words} = \\frac{N_{bits}}{W} = \\frac{N \\times 2^{20} \\times 8}{W}$$\n代入给定值 $N=64$ 和 $W=128$：\n$$T_{words} = \\frac{64 \\times 2^{20} \\times 8}{128} = \\frac{512 \\times 2^{20}}{128} = 4 \\times 2^{20} = 4 \\times 1048576 = 4194304\\ \\text{words}$$\n\n加载程序发出连续的突发读取，每次突发包含 $B = 16$ 个总线字。为了计算所需的总突发次数 $N_{bursts}$，我们将总字数 $T_{words}$ 除以每次突发的字数 $B$。由于问题规定即使最后一次突发是部分的，它也被作为一次完整的操作发出（产生相同的建立延迟），因此我们必须对这个除法取向上取整：\n$$N_{bursts} = \\left\\lceil \\frac{T_{words}}{B} \\right\\rceil$$\n代入计算出的 $T_{words}$ 值和给定的 $B=16$ 值：\n$$N_{bursts} = \\left\\lceil \\frac{4194304}{16} \\right\\rceil = \\lceil 262144 \\rceil = 262144\\ \\text{bursts}$$\n在这个具体案例中，总字数是突发大小的整数倍，因此没有部分突发。然而，通用公式必须包含向上取整函数。\n\n接下来，我们计算以时钟周期为单位的总时间。总时间是两个部分之和：数据传输所花费的时间和所有突发的累积建立延迟所花费的时间。\n每次突发，无论是完整的还是部分的，都会产生 $L = 12$ 个周期的建立延迟。总共有 $N_{bursts}$ 次突发，因此花在建立上的总时间是：\n$$C_{latency} = N_{bursts} \\times L$$\n在一次突发的初始延迟之后，每个周期到达一个总线字。因此，传输实际数据所花费的总时间等于要传输的总字数 $T_{words}$。\n$$C_{transfer} = T_{words}$$\n以时钟周期为单位的总时间 $C_{total}$ 是这两个部分之和：\n$$C_{total} = C_{latency} + C_{transfer} = (N_{bursts} \\times L) + T_{words}$$\n\n代入我们计算出的数值：$N_{bursts} = 262144$, $L=12$, 和 $T_{words} = 4194304$：\n$$C_{total} = (262144 \\times 12) + 4194304 = 3145728 + 4194304 = 7340032\\ \\text{cycles}$$\n\n为了计算以秒为单位的总启动时间 $T_{boot}$，我们将总周期数 $C_{total}$ 除以CPU时钟频率 $f = 800 \\times 10^{6}$ 周期/秒。\n$$T_{boot} = \\frac{C_{total}}{f}$$\n代入数值：\n$$T_{boot} = \\frac{7340032}{800 \\times 10^{6}} = \\frac{7340032}{8 \\times 10^{8}} = 0.00917504\\ \\text{seconds}$$\n\n问题要求答案四舍五入到四位有效数字。\n$$T_{boot} \\approx 0.009175\\ \\text{seconds}$$\n这可以写成科学记数法形式 $9.175 \\times 10^{-3}$ 秒。\n\n最后，我们将总启动时间表示为给定参数 $N$、$W$、$B$、$L$ 和 $f$ 的函数。\n$$T_{boot}(N, W, B, L, f) = \\frac{C_{total}}{f} = \\frac{1}{f} \\left( L \\cdot N_{bursts} + T_{words} \\right)$$\n代入 $N_{bursts}$ 和 $T_{words}$ 的表达式：\n$$T_{words} = \\frac{8 \\cdot N \\cdot 2^{20}}{W}$$\n$$N_{bursts} = \\left\\lceil \\frac{T_{words}}{B} \\right\\rceil = \\left\\lceil \\frac{8 \\cdot N \\cdot 2^{20}}{W \\cdot B} \\right\\rceil$$\n因此，启动时间的通用符号表达式是：\n$$T_{boot} = \\frac{1}{f} \\left( L \\cdot \\left\\lceil \\frac{8 \\cdot N \\cdot 2^{20}}{W \\cdot B} \\right\\rceil + \\frac{8 \\cdot N \\cdot 2^{20}}{W} \\right)$$\n这个公式明确地展示了启动时间（这是实现存储程序概念的直接结果）是如何由镜像大小（$N$）、内存总线带宽（与 $W$ 和 $f$ 相关）以及传输粒度/开销（与 $B$ 和 $L$ 相关）决定的。",
            "answer": "$$\\boxed{9.175 \\times 10^{-3}}$$"
        },
        {
            "introduction": "存储程序模型的一个强大优势是它赋予了程序加载位置的灵活性。这个练习探讨了我们如何编写与位置无关的代码 (Position-Independent Code, PIC)，使其无论被加载到内存的哪个地址都能正确运行。你将分析PC相对寻址机制，并计算一个具体的跳转目标地址，从而理解为什么这种寻址方式是实现代码重定位的关键。",
            "id": "3682297",
            "problem": "一台精简指令集计算处理器实现了存储程序概念：指令和数据共享一个单一的线性字节寻址内存，处理器使用程序计数器 (PC) 来获取下一条指令。考虑位置无关代码 (PIC)，其中控制流目标是相对于程序计数器 (PC) 表示的，而不是作为绝对内存地址。\n\n请仅从以下基本事实和定义出发：存储程序概念、程序计数器 (PC) 作为持有下一条待取指令地址的寄存器的定义、通过一个恒定地址增量 $\\Delta$ 对所有代码和数据地址进行统一平移（重定位）的概念，以及指令中存在一个以一条指令为单位表示的有符号位移字段。不要假设任何预先推导出的 PC 相对目标的公式。\n\n给定一个特定的顺序流水线和编码模型：\n- 流水线有 $n=7$ 个阶段，编号从 $1$ 到 $7$，其中阶段 $1$ 是指令获取（取指），阶段 $4$ 是算术/逻辑执行阶段，在该阶段形成控制流有效地址。\n- 指令宽度为 $w=4$ 字节。\n- 程序计数器 (PC) 在每个周期的阶段 $1$（取指）增加 $w$。当一条指令处于阶段 $4$（执行）时，阶段 $4$ 观察到的 PC 值对应于取指单元已经比执行阶段中的指令地址提前了恰好 $\\kappa$ 条完整指令的地址。在此微体系结构中，执行阶段是阶段 $4$，因此 $\\kappa=3$。\n- 一条控制流指令包含一个有符号位移 $\\delta$，该位移以一条指令为单位进行编码，意味着该位移是以 $w$ 字节的倍数来度量的。\n\nA 部分（概念性）：仅使用上述基本事实，论证为什么通过程序计数器 (PC) 和一个嵌入的有符号位移来形成控制流目标，在通过任意常量 $\\Delta$ 进行重定位时，能够产生平移不变性。也就是说，如果所有代码在内存中被移动了 $\\Delta$，请解释为什么在不修改指令编码的情况下，给定指令计算出的目标地址也恰好移动了相同的 $\\Delta$，正如位置无关代码 (PIC) 所要求的那样。\n\nB 部分（计算）：考虑一条重定位后的控制流指令，其自身地址为 $A = L + o$，其中加载基地址为 $L = 0x400000$，指令在其代码段内的偏移量为 $o = 0x160$。有符号位移字段为 $\\delta=-5$。根据上述流水线语义，确定执行阶段观察到的控制流目标的精确字节地址，表示为一个十进制整数。无需四舍五入；给出精确的整数值。最终数值答案中不要包含任何单位符号。",
            "solution": "所述问题是有效的。它在科学上基于计算机组成与体系结构的原理，特别是存储程序概念、流水线执行和位置无关代码 (PIC)。该问题定义良好，为得出唯一解提供了所有必要的定义、约束和数据。其语言客观而精确。\n\n本解答分为两部分，对应于问题陈述的两个部分。\n\n### A 部分：平移不变性的概念性论证\n\n位置无关代码 (PIC) 的核心原则是，控制流目标和数据访问的内存地址是相对于当前执行位置计算的，而不是作为绝对地址硬编码。这使得一段代码可以被加载到内存中的任何位置执行而无需修改。我们将演示 PC 相对寻址方案如何实现这种平移不变性。\n\n设 $A_{instr}$ 为给定控制流指令的绝对内存地址。\n根据问题的流水线模型，当该指令处于执行阶段（阶段 $i=4$）时，程序计数器 (PC) 已经更新了多次。PC 始终持有*下一条待取指令*（在阶段 $1$）的地址。鉴于地址为 $A_{instr}$ 的指令处于阶段 $4$，流水线自其被取指以来已经前进了 $4-1=3$ 个周期。问题将此前瞻定义为 $\\kappa = 3$ 条指令。\n指令宽度为 $w$ 字节。因此，执行阶段观察到的 PC 值，记作 $PC_{exec}$，是比当前正在执行的指令提前 $\\kappa$ 条指令的指令地址。\n$$PC_{exec} = A_{instr} + \\kappa \\cdot w$$\n\n控制流指令包含一个嵌入的有符号位移 $\\delta$，以一条指令为单位表示。为了计算字节偏移量，该位移必须乘以指令宽度 $w$。然后，通过将此字节偏移量加到执行阶段观察到的 PC 值上来计算目标地址 $A_{target}$。\n$$A_{target} = PC_{exec} + \\delta \\cdot w$$\n代入 $PC_{exec}$ 的表达式，我们得到：\n$$A_{target} = (A_{instr} + \\kappa \\cdot w) + \\delta \\cdot w$$\n\n现在，让我们考虑内存重定位的影响。假设整个代码和数据块在内存中被一个恒定的地址增量 $\\Delta$ 移动（平移）。每个原始地址 $X$ 都被映射到一个新地址 $X' = X + \\Delta$。\n\n我们的控制流指令的新地址变为：\n$$A'_{instr} = A_{instr} + \\Delta$$\n\n指令本身没有被修改；其二进制编码，包括位移字段 $\\delta$，保持不变。当这条重定位后的指令处于执行阶段时，处理器使用与之前相同的逻辑计算目标地址，但基于新的、重定位后的地址。在执行阶段观察到的 PC 值 $PC'_{exec}$ 将相对于新的指令地址 $A'_{instr}$：\n$$PC'_{exec} = A'_{instr} + \\kappa \\cdot w = (A_{instr} + \\Delta) + \\kappa \\cdot w$$\n\n新的目标地址 $A'_{target}$ 使用这个新的 PC 值和未改变的位移来计算：\n$$A'_{target} = PC'_{exec} + \\delta \\cdot w = ((A_{instr} + \\Delta) + \\kappa \\cdot w) + \\delta \\cdot w$$\n通过重新排列各项，我们可以分离出重定位偏移量 $\\Delta$：\n$$A'_{target} = (A_{instr} + \\kappa \\cdot w + \\delta \\cdot w) + \\Delta$$\n括号中的表达式正是原始的目标地址 $A_{target}$。因此，我们有：\n$$A'_{target} = A_{target} + \\Delta$$\n\n这个结果表明，代码通过一个常量 $\\Delta$ 的重定位，会导致计算出的目标地址也被重定位了完全相同的常量 $\\Delta$。这是在不修改指令编码的位移 $\\delta$ 的情况下实现的。目标地址与指令自身地址之间的差值 $A_{target} - A_{instr} = (\\kappa + \\delta)w$ 是一个由指令编码和流水线架构决定的常量，而不是由指令的绝对位置决定的。这就是平移不变性的本质，也是位置无关代码的功能。\n\n### B 部分：控制流目标地址的计算\n\n我们将使用 A 部分推导出的公式来计算控制流目标的精确字节地址。公式为：\n$$A_{target} = A_{instr} + (\\kappa + \\delta) \\cdot w$$\n\n首先，我们必须确定控制流指令的绝对地址 $A_{instr}$。问题陈述其位于地址 $A = L + o$，其中加载基地址为 $L = 0x400000$，偏移量为 $o = 0x160$。我们必须将这些十六进制值转换为十进制。\n\n加载基地址 $L$ 是：\n$$L = 0x400000 = 4 \\times 16^{5} = 4 \\times 1048576 = 4194304$$\n\n偏移量 $o$ 是：\n$$o = 0x160 = 1 \\times 16^{2} + 6 \\times 16^{1} + 0 \\times 16^{0} = 256 + 96 + 0 = 352$$\n\n指令的绝对地址 $A_{instr}$ 是这两个值的和：\n$$A_{instr} = L + o = 4194304 + 352 = 4194656$$\n\n接下来，我们整理问题陈述中提供的其余参数：\n- 流水线前瞻指令数：$\\kappa = 3$。\n- 指令中的有符号位移：$\\delta = -5$。\n- 指令宽度（字节）：$w = 4$。\n\n现在，我们将这些值代入目标地址 $A_{target}$ 的公式中：\n$$A_{target} = 4194656 + (3 + (-5)) \\cdot 4$$\n$$A_{target} = 4194656 + (-2) \\cdot 4$$\n$$A_{target} = 4194656 - 8$$\n$$A_{target} = 4194648$$\n\n因此，控制流目标的精确字节地址是 $4194648$。",
            "answer": "$$\\boxed{4194648}$$"
        },
        {
            "introduction": "在现代多核处理器中，“代码即数据”的思想催生了即时编译 (JIT) 等强大技术，但同时也带来了新的复杂挑战。本练习模拟了一个核心生成代码、另一个核心执行该代码的场景。你的任务是选择正确的操作序列以保证程序的正确性，这突显了在多核环境下处理缓存一致性和内存排序对于实现存储程序概念的至关重要性。",
            "id": "3682322",
            "problem": "考虑一个对称多处理器系统，该系统在单个中央处理器（CPU）内包含 $2$ 个核心，即核心 $0$ 和核心 $1$。该系统为共享物理内存实现了缓存一致性，但每个核心使用独立的指令缓存（I-cache）和数据缓存（D-cache），且不提供自动的指令-数据一致性。也就是说，在没有显式操作的情况下，通过 D-cache 执行的写入不保证会使任何 I-cache 无效化或更新。在此场景中，转译后备缓冲器（TLB）的映射保持不变。核心 $0$ 通过将 $N$ 字节写入一个共享的、页面对齐的区域 $[P, P+N)$ 来为函数 $F$ 生成机器码，然后通过向地址 $Q$ 写入一个就绪标志值来通知可用性。核心 $1$ 稍后会跳转到地址 $P$ 来执行函数 $F$。\n\n可用的原语及其语义：\n- $\\mathrm{flushD}(R)$: 确保调用核心对区域 $R$ 的所有先前存储操作都已从 D-cache 写回到一致性点，并对其他核心的内存层级结构可见。\n- $\\mathrm{mb\\_full}()$: 一个全局的、系统范围的内存屏障。它将所有先前的内存操作排序在所有后续的内存操作之前（跨核心），当与通过标志进行的核心间同步结合使用时，建立先行发生关系。\n- $\\mathrm{invalidateI}(R)$: 使调用核心中覆盖区域 $R$ 的 I-cache 行无效，以便后续的指令获取将从一致性点重新获取。\n- $\\mathrm{isync}()$: 一个指令同步屏障，确保任何后续的指令获取和解码都能观察到先前 I-cache 无效化和内存排序操作的效果。\n\n假设：\n- 在核心 $1$ 执行 $F$ 之前，核心 $1$ 对于 $[P, P+N)$ 可能存在过时的 I-cache 行。\n- 核心 $0$ 的写入最初驻留在核心 $0$ 的 D-cache 中，并且在被显式刷新之前可能不是全局可见的。\n- 地址 $Q$ 处的就绪标志由核心 $1$ 轮询，并用于协调何时继续执行。\n\n在这些假设和存储程序概念（即指令是存储在内存中并作为字节序列获取的数据）下，选择唯一能保证核心 $1$ 在第一次尝试时就能正确且确定性地执行新生成的函数 $F$ 的操作序列。\n\n选项：\n\nA. 核心 $0$：将 $F$ 写入 $[P,P+N)$；$\\mathrm{flushD}([P,P+N))$；$\\mathrm{mb\\_full}()$；将就绪标志值 $1$ 存储到 $Q$。核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；$\\mathrm{invalidateI}([P,P+N))$；$\\mathrm{isync}()$；跳转到 $P$。\n\nB. 核心 $0$：将 $F$ 写入 $[P,P+N)$；将就绪标志值 $1$ 存储到 $Q$。核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；$\\mathrm{mb\\_full}()$；跳转到 $P$。\n\nC. 核心 $0$：$\\mathrm{invalidateI}([P,P+N))$；将 $F$ 写入 $[P,P+N)$；$\\mathrm{mb\\_full}()$；将就绪标志值 $1$ 存储到 $Q$。核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；跳转到 $P$。\n\nD. 核心 $0$：将 $F$ 写入 $[P,P+N)$；$\\mathrm{flushD}([P,P+N))$；将就绪标志值 $1$ 存储到 $Q$。核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；$\\mathrm{isync}()$；跳转到 $P$。\n\n选择那个通过正确排序 $\\mathrm{flush}$ 和 $\\mathrm{barrier}$ 原语来保证核心 $1$ 执行由核心 $0$ 生成的代码的正确性的选项。",
            "solution": "问题描述了一个多核系统编程中的经典场景，涉及动态代码生成，这在即时（JIT）编译中经常遇到。核心挑战源于指令缓存（I-cache）和数据缓存（D-cache）的分离，并且它们之间没有由硬件自动管理的一致性。这需要一个显式的软件操作序列，以确保一个核心作为数据写入的代码能被另一个核心作为指令正确执行。\n\n该问题被判定为有效的，因为它科学地基于计算机组成和体系结构的原理，问题阐述清晰且客观。它准确地模拟了现代处理器在缓存一致性和内存排序方面的复杂性。\n\n为确保核心 $1$ 正确执行由核心 $0$ 生成的函数 $F$，必须强制执行一个精确的事件序列。让我们从第一性原理出发推导这个序列。\n\n**核心 $0$ （写入者/生产者）：**\n1.  **代码生成：** 核心 $0$ 将函数 $F$ 的机器码写入内存区域 $[P, P+N)$。这些写操作会修改核心 $0$ 的私有 D-cache 中的缓存行。此时，新代码对核心 $1$ 甚至主内存系统都是不可见的。\n2.  **数据可见性：** 新写入的代码必须从核心 $0$ 的私有 D-cache 传播到一致性点（例如，共享的末级缓存或主内存），核心 $1$ 可以从那里获取它。原语 $\\mathrm{flushD}([P, P+N))$ 完成了这项工作，确保数据被“写回”。\n3.  **内存排序：** 现代处理器可能会为了性能而对内存操作进行重排序。至关重要的是，函数代码的写入（通过 flush 操作使其可见）必须在就绪标志地址 $Q$ 被更新*之前*全局可见。如果核心 $1$ 在代码可用之前就看到了标志，它将尝试执行过时的或无用的指令。需要一个完整的内存屏障 $\\mathrm{mb\\_full}()$ 来强制执行此排序。它保证所有先前的内存操作（包括 $\\mathrm{flushD}$ 的效果）完成并全局可见，之后才能执行任何后续的内存操作（对 $Q$ 的存储）。\n4.  **同步信号：** 在确保代码可见且有序之后，核心 $0$ 向地址 $Q$ 处的就绪标志写入数据。这个存储操作作为给核心 $1$ 的一个信号。\n\n因此，核心 $0$ 正确且确定性的序列是：\n- 将 $F$ 写入 $[P,P+N)$\n- $\\mathrm{flushD}([P,P+N))$\n- $\\mathrm{mb\\_full}()$\n- 将就绪标志值 $1$ 存储到 $Q$\n\n**核心 $1$ （执行者/消费者）：**\n1.  **同步等待：** 核心 $1$ 自旋，重复从地址 $Q$ 加载值，直到读取到就绪值（$1$）。系统的基本数据缓存一致性确保核心 $0$ 的存储最终会被核心 $1$ 观察到。\n2.  **指令缓存一致性：** 读取到就绪标志后，核心 $1$ 就知道函数 $F$ 的正确机器码在一致性点已经可用。然而，它自己的 I-cache 可能为地址范围 $[P, P+N)$ 持有旧的指令。问题指出没有自动的 I-D 一致性。因此，核心 $1$ 必须显式地使这些过时的 I-cache 条目无效。原语 $\\mathrm{invalidateI}([P,P+N))$ 在调用核心的 I-cache 上执行此操作。\n3.  **指令流水线同步：** 仅仅使 I-cache 行无效本身是不够的。处理器的指令获取流水线可能在无效化完成*之前*就已经获取并解码了来自过时 I-cache 的指令。需要一个指令同步屏障 $\\mathrm{isync}()$ 来刷新流水线，并确保在屏障之后执行的任何指令都是从内存层级结构中重新获取的（此时会在 I-cache 中未命中，从而获取正确的代码）。\n4.  **执行：** 在其 I-cache 和指令流水线都正确同步后，核心 $1$ 现在可以安全地跳转到地址 $P$ 并开始执行正确的、新生成的函数 $F$。\n\n因此，核心 $1$ 正确且确定性的序列是：\n- 自旋等待直到从 $Q$ 加载的值返回 $1$\n- $\\mathrm{invalidateI}([P,P+N))$\n- $\\mathrm{isync}()$\n- 跳转到 $P$\n\n将这两个序列结合起来，就得到了完整、正确的协议。让我们基于这个推导来评估各个选项。\n\n**选项 A：**\n- 核心 $0$：将 $F$ 写入 $[P,P+N)$；$\\mathrm{flushD}([P,P+N))$；$\\mathrm{mb\\_full}()$；将就绪标志值 $1$ 存储到 $Q$。\n- 核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；$\\mathrm{invalidateI}([P,P+N))$；$\\mathrm{isync}()$；跳转到 $P$。\n这个序列与从第一性原理推导出的序列完全匹配。核心 $0$ 正确地确保了数据可见性和排序。核心 $1$ 正确地确保了指令缓存一致性和流水线同步。\n**结论：正确**\n\n**选项 B：**\n- 核心 $0$：将 $F$ 写入 $[P,P+N)$；将就绪标志值 $1$ 存储到 $Q$。\n这是有缺陷的。它省略了 $\\mathrm{flushD}()$，所以代码可能永远不会离开核心 $0$ 的 D-cache。它也省略了 $\\mathrm{mb\\_full}()$，允许标志存储被重排到代码写入可见之前，从而产生竞争条件。\n- 核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；$\\mathrm{mb\\_full}()$；跳转到 $P$。\n这是有缺陷的。它省略了关键的 $\\mathrm{invalidateI}()$ 和 $\\mathrm{isync}()$ 步骤，意味着核心 $1$ 很可能会执行其 I-cache 中的过时指令。\n**结论：错误**\n\n**选项 C：**\n- 核心 $0$：$\\mathrm{invalidateI}([P,P+N))$；将 $F$ 写入 $[P,P+N)$；$\\mathrm{mb\\_full}()$；将就绪标志值 $1$ 存储到 $Q$。\n这是有缺陷的。在核心 $0$ 上执行 $\\mathrm{invalidateI}()$ 是无关紧要的，因为核心 $0$ 并不执行该代码。关键的 $\\mathrm{flushD}()$ 操作被遗漏了，所以核心 $0$ 写入的代码不保证对核心 $1$ 可见。\n- 核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；跳转到 $P$。\n这是有缺陷的。它省略了 $\\mathrm{invalidateI}()$ 和 $\\mathrm{isync}()$，未能解决核心 $1$ 上的过时 I-cache 问题。\n**结论：错误**\n\n**选项 D：**\n- 核心 $0$：将 $F$ 写入 $[P,P+N)$；$\\mathrm{flushD}([P,P+N))$；将就绪标志值 $1$ 存储到 $Q$。\n这是有缺陷的。它在数据刷新和标志存储之间省略了 $\\mathrm{mb\\_full}()$。在弱序体系结构上，这会允许标志在被刷新的代码数据保证可见之前就对核心 $1$ 可见，从而导致竞争条件。\n- 核心 $1$：自旋等待直到从 $Q$ 加载的值返回 $1$；$\\mathrm{isync}()$；跳转到 $P$。\n这是有缺陷的。它省略了 $\\mathrm{invalidateI}()$。$\\mathrm{isync}()$ 原语是相对于先前的缓存维护操作来同步流水线；如果没有在它之前的 $\\mathrm{invalidateI}()$，它对 I-cache 内容没有相关的影响。核心 $1$ 仍有使用过时缓存指令的风险。\n**结论：错误**\n\n基于严谨的分析，只有选项 A 提供了在指定体系结构约束下保证确定性和正确执行所需的一套完整且顺序正确的原语。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}