{
    "hands_on_practices": [
        {
            "introduction": "真值表是定义数字逻辑函数最明确、最基本的方式。第一个练习将引导你完成一个核心工作流程：将一个功能性需求——用于容错计算的三模冗余（TMR）系统中的多数表决器——转化为一个完整的真值表，并进一步推导出其硬件实现。这个过程展示了如何从抽象概念到具体电路，这是数字逻辑设计的基石。",
            "id": "3686334",
            "problem": "在一个使用三重模块冗余 (TMR) 的容错数据通路中，三个名义上相同的模块产生二进制输出$A$、$B$和$C$。这些输出由一个$3$输入多数表决器$M(A,B,C)$进行组合。根据定义，当且仅当至少有$2$个输入为$1$时，多数表决器输出$1$，否则输出$0$。仅使用布尔代数的基本定义和真值表方法（枚举所有输入组合并确定输出为$1$的情况），完成以下任务：\n- 从基本原理出发，为$M(A,B,C)$构建真值表，并从中获得一个最简积之和布尔实现。\n- 通过将常数代入您的实现并使用布尔代数进行化简，分析当输入$A$出现固定为$0$故障和固定为$1$故障时对实现函数的影响。\n- 利用您的结果和TMR的定义，论证当另外两个模块无故障且对所有输入组合都相同时，一个模块输出上的单个固定型故障是否能被表决器完全屏蔽。\n\n选择所有正确的陈述：\nA. 多数表决器的最简积之和实现是$M(A,B,C)=AB+BC+AC$。\n\nB. 如果输入$A$固定为$0$，多数表决器的输出简化为$M(0,B,C)=B\\lor C$。\n\nC. 如果输入$A$固定为$1$，多数表决器的输出简化为$M(1,B,C)=B\\lor C$。\n\nD. 在 TMR 中，如果两个模块无故障且相同，第三个模块上的单个固定型故障可以被多数表决器对所有输入组合完全屏蔽。\n\nE. 多数表决器等同于奇偶校验函数：$M(A,B,C)=A\\oplus B\\oplus C$。",
            "solution": "主要任务是分析一个$3$输入多数表决器$M(A,B,C)$、其实现、其在故障下的行为，以及它在三重模块冗余 (TMR) 中的作用。题目定义了当且仅当至少有$2$个输入为$1$时，表决器输出为$1$，否则输出为$0$。\n\n**第1部分：真值表与最简积之和 (SOP) 实现**\n\n首先，我们通过枚举二进制输入$A$、$B$和$C$的所有$2^3 = 8$种可能组合来构建$M(A,B,C)$的真值表。当输入的和大于或等于$2$时，输出$M$为$1$。\n\n| $A$ | $B$ | $C$ | $1$ 的数量 | $M(A,B,C)$ |\n|---|---|---|---|---|\n| $0$ | $0$ | $0$ | $0$ | $0$ |\n| $0$ | $0$ | $1$ | $1$ | $0$ |\n| $0$ | $1$ | $0$ | $1$ | $0$ |\n| $0$ | $1$ | $1$ | $2$ | $1$ |\n| $1$ | $0$ | $0$ | $1$ | $0$ |\n| $1$ | $0$ | $1$ | $2$ | $1$ |\n| $1$ | $1$ | $0$ | $2$ | $1$ |\n| $1$ | $1$ | $1$ | $3$ | $1$ |\n\n从真值表中，函数$M(A,B,C)$在输入组合（最小项）$(0,1,1)$、$(1,0,1)$、$(1,1,0)$和$(1,1,1)$时为真。这给出了规范积之和 (SOP) 表达式：\n$$ M(A,B,C) = \\overline{A}BC + A\\overline{B}C + AB\\overline{C} + ABC $$\n\n为了找到最简SOP表达式，我们可以使用布尔代数。我们可以在表达式中再添加两次$ABC$项，因为$X+X=X$。\n$$ M(A,B,C) = \\overline{A}BC + A\\overline{B}C + AB\\overline{C} + ABC + ABC + ABC $$\n重新排列各项以对相邻的最小项进行分组：\n$$ M(A,B,C) = (\\overline{A}BC + ABC) + (A\\overline{B}C + ABC) + (AB\\overline{C} + ABC) $$\n使用分配律提出公因式：\n$$ M(A,B,C) = BC(\\overline{A}+A) + AC(\\overline{B}+B) + AB(\\overline{C}+C) $$\n使用恒等式$X+\\overline{X}=1$：\n$$ M(A,B,C) = BC(1) + AC(1) + AB(1) $$\n$$ M(A,B,C) = AB + BC + AC $$\n这就是$3$输入多数表决函数的最简SOP实现。\n\n**第2部分：固定型故障分析**\n\n接下来，我们分析当输入$A$出现固定型故障时表决器的行为。\n\n**情况1：输入$A$固定为$0$。**\n我们将$A=0$代入最简SOP表达式中：\n$$ M(0,B,C) = (0)B + BC + (0)C $$\n$$ M(0,B,C) = 0 + BC + 0 $$\n$$ M(0,B,C) = BC $$\n输出简化为输入$B$和$C$的逻辑与。\n\n**情况2：输入$A$固定为$1$。**\n我们将$A=1$代入最简SOP表达式中：\n$$ M(1,B,C) = (1)B + BC + (1)C $$\n$$ M(1,B,C) = B + BC + C $$\n使用布尔代数的吸收律$X+XY = X$，我们可以简化$B+BC$：\n$$ B+BC = B $$\n所以表达式变为：\n$$ M(1,B,C) = (B+BC) + C = B + C $$\n在标准逻辑符号中，这就是$B \\lor C$。输出简化为输入$B$和$C$的逻辑或。\n\n**第3部分：TMR中的故障屏蔽**\n\n在 TMR 系统中，三个相同的模块产生输出，这些输出被送入多数表决器。如果两个模块无故障，它们的输出将是相同的。设这个正确的输出值为$X$。第三个模块有单个固定型故障，所以其输出是一个常数（$0$或$1$）。我们必须确定表决器的输出$M$是否等于正确的值$X$。\n\n对于正确的输出$X$，有两种情况：\n\n*   **情况1：正确的输出为$X=0$。**\n    两个无故障模块输出$0$。表决器的输入为$(A,B,C)$，其中两个输入为$0$。\n    *   如果故障是固定为$0$，则输入为$(0,0,0)$。$M(0,0,0) = 0$。输出是正确的。\n    *   如果故障是固定为$1$，则输入为$(1,0,0)$的某种排列。$M(1,0,0) = 1(0)+0(0)+1(0) = 0$。输出是正确的。\n\n*   **情况2：正确的输出为$X=1$。**\n    两个无故障模块输出$1$。表决器的输入为$(A,B,C)$，其中两个输入为$1$。\n    *   如果故障是固定为$0$，则输入为$(0,1,1)$的某种排列。$M(0,1,1) = 0(1)+1(1)+0(1) = 1$。输出是正确的。\n    *   如果故障是固定为$1$，则输入为$(1,1,1)$。$M(1,1,1) = 1(1)+1(1)+1(1) = 1$。输出是正确的。\n\n在所有两个输入正确而一个输入有故障（固定为$0$或固定为$1$）的情况下，多数表决器都能产生正确的输出$X$。因此，一个模块输出上的单个固定型故障被完全屏蔽了。\n\n**选项评估**\n\n*   **A. 多数表决器的最简积之和实现是$M(A,B,C)=AB+BC+AC$。**\n    如第1部分所推导，这个陈述是准确的。$3$输入多数函数的SOP最简表达式确实是$AB+BC+AC$。\n    **结论：正确。**\n\n*   **B. 如果输入$A$固定为$0$，多数表决器的输出简化为$M(0,B,C)=B\\lor C$。**\n    如第2部分所推导，当$A$固定为$0$时，输出简化为$M(0,B,C)=BC$。表达式$BC$代表逻辑与，而不是逻辑或（$B \\lor C$，即$B+C$）。例如，如果$B=1$且$C=0$，则$BC=0$而$B \\lor C = 1$。\n    **结论：错误。**\n\n*   **C. 如果输入$A$固定为$1$，多数表决器的输出简化为$M(1,B,C)=B\\lor C$。**\n    如第2部分所推导，当$A$固定为$1$时，输出简化为$M(1,B,C)=B+C$。表达式$B+C$是逻辑或$B \\lor C$的布尔代数表示。\n    **结论：正确。**\n\n*   **D. 在 TMR 中，如果两个模块无故障且相同，第三个模块上的单个固定型故障可以被多数表决器对所有输入组合完全屏蔽。**\n    如第3部分所示，多数表决器的输出将始终与两个相同的正确输入的值相匹配，从而有效地屏蔽了单个故障输入。这是 TMR 的基本原理。\n    **结论：正确。**\n\n*   **E. 多数表决器等同于奇偶校验函数：$M(A,B,C)=A\\oplus B\\oplus C$。**\n    $3$输入异或（奇偶校验）函数$P(A,B,C)=A\\oplus B\\oplus C$，当输入中有奇数个$1$时输出$1$。让我们将其输出与多数表决器在输入为$(0,1,1)$时的输出进行比较。\n    *   $M(0,1,1) = 0(1)+1(1)+0(1) = 1$（因为有两个输入是$1$）。\n    *   $P(0,1,1) = 0 \\oplus 1 \\oplus 1 = 1 \\oplus 1 = 0$（因为有两个输入是$1$，是偶数）。\n    由于$M(0,1,1) \\neq P(0,1,1)$，这两个函数不相等。\n    **结论：错误。**",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "在掌握了基本定义之后，我们来探讨如何使用真值表来定义标准加减法之外的自定义算术运算。本练习将以饱和加法为例，这在数字信号处理器（DSP）中是一种常见的运算。你将通过构建一个真值表，为所有可能的输入精确定义其运算行为，这展示了真值表如何为复杂的非线性行为提供一个无歧义的规范。",
            "id": "3686422",
            "problem": "考虑使用两位二进制补码表示的定宽有符号整数运算。在宽度$n=2$的二进制补码表示中，可表示的整数为$-2$、$-1$、$0$和$1$，分别由位模式$10$、$11$、$00$和$01$编码，其中最高有效位是符号位。定义这两个两位整数上的饱和加法如下：给定输入$A=a_{1}a_{0}$和$B=b_{1}b_{0}$，设数学和为$V(A)+V(B)$，其中$V(\\cdot)$将一个两位位模式映射到其二进制补码整数值。饱和和$S$定义为：如果$V(A)+V(B)\\in[-2,1]$，则为正常和$V(A)+V(B)$；如果$V(A)+V(B)>1$，则为最大可表示整数$+1$（位模式$01$）；如果$V(A)+V(B) < -2$，则为最小可表示整数$-2$（位模式$10$）。\n\n任务：\n- 构建完整的真值表，将所有$16$种两位输入的输入对$(A,B)$映射到饱和和输出$S$，并以两位位模式及其二进制补码整数值的形式写出。\n- 假设输入$A$和$B$在四个可表示的值$\\{-2,-1,0,1\\}$上是独立且均匀分布的。使用您的真值表，计算饱和和$S$（解释为二进制补码整数）的精确期望值。\n\n将最终期望值表示为一个精确的分数。不要四舍五入。",
            "solution": "该问题要求两个结果：首先，是两位二进制补码饱和加法的完整真值表；其次，是假设输入均匀分布时饱和和的期望值。\n\n两位二进制补码表示法覆盖的整数范围是从$-2^{2-1}$到$2^{2-1}-1$，即$[-2, 1]$。问题提供了两位位模式与其整数值之间的映射关系：\n- $00_2 \\rightarrow V(00) = 0$\n- $01_2 \\rightarrow V(01) = 1$\n- $10_2 \\rightarrow V(10) = -2$\n- $11_2 \\rightarrow V(11) = -1$\n\n饱和加法是为两个输入$A$和$B$定义的。设$V(A)$和$V(B)$是它们的整数值。数学和是$Z = V(A) + V(B)$。饱和和$S$的整数值$V(S)$定义为：\n- $V(S) = Z$，如果$-2 \\le Z \\le 1$\n- $V(S) = 1$（最大可表示值），如果$Z > 1$\n- $V(S) = -2$（最小可表示值），如果$Z  -2$\n\n**第1部分：构建真值表**\n\n我们需要为$A=a_1a_0$和$B=b_1b_0$的所有$4 \\times 4 = 16$种可能的输入对计算饱和和。完整的真值表构建如下。各列显示了输入$A$和$B$的位模式、它们对应的整数值$V(A)$和$V(B)$、数学和$Z=V(A)+V(B)$、饱和和的结果整数值$V(S)$以及饱和和$S$的位模式。\n\n| $\\textbf{A}$ | $\\boldsymbol{V(A)}$ | $\\textbf{B}$ | $\\boldsymbol{V(B)}$ | $\\boldsymbol{Z = V(A)+V(B)}$ | $\\boldsymbol{V(S)}$ | $\\textbf{S}$ |\n|---|---|---|---|---|---|---|\n| 00 | 0 | 00 | 0 | 0 | 0 | 00 |\n| 00 | 0 | 01 | 1 | 1 | 1 | 01 |\n| 00 | 0 | 10 | -2 | -2 | -2 | 10 |\n| 00 | 0 | 11 | -1 | -1 | -1 | 11 |\n| 01 | 1 | 00 | 0 | 1 | 1 | 01 |\n| 01 | 1 | 01 | 1 | 2 | 1 | 01 |\n| 01 | 1 | 10 | -2 | -1 | -1 | 11 |\n| 01 | 1 | 11 | -1 | 0 | 0 | 00 |\n| 10 | -2 | 00 | 0 | -2 | -2 | 10 |\n| 10 | -2 | 01 | 1 | -1 | -1 | 11 |\n| 10 | -2 | 10 | -2 | -4 | -2 | 10 |\n| 10 | -2 | 11 | -1 | -3 | -2 | 10 |\n| 11 | -1 | 00 | 0 | -1 | -1 | 11 |\n| 11 | -1 | 01 | 1 | 0 | 0 | 00 |\n| 11 | -1 | 10 | -2 | -3 | -2 | 10 |\n| 11 | -1 | 11 | -1 | -2 | -2 | 10 |\n\n**第2部分：计算期望值**\n\n输入$A$和$B$被假定在四个可能的值$\\{-2, -1, 0, 1\\}$上是独立且均匀分布的。$V(A)$或$V(B)$的任何特定整数值的概率是$P = \\frac{1}{4}$。\n由于$A$和$B$是独立的，任何特定的输入值对$(V(A), V(B))$的概率是它们各自概率的乘积：\n$$P(V(A)=v_a, V(B)=v_b) = P(V(A)=v_a) \\times P(V(B)=v_b) = \\frac{1}{4} \\times \\frac{1}{4} = \\frac{1}{16}$$\n这意味着真值表中的16行中的每一行都是等可能的。\n\n饱和和的期望值$E[S]$是所有可能的输出值$V(S)$按其概率加权的和。由于16个结果中的每一个都有$\\frac{1}{16}$的概率，期望值是表中$V(S)$列中所有16个值的算术平均值。\n\n$$E[S] = \\sum_{i=1}^{16} V(S_i) \\cdot P_i = \\frac{1}{16} \\sum_{i=1}^{16} V(S_i)$$\n\n我们对$V(S)$列中的值求和：\n$$\n\\sum_{i=1}^{16} V(S_i) = (0+1-2-1) + (1+1-1+0) + (-2-1-2-2) + (-1+0-2-2)\n$$\n$$\n\\sum_{i=1}^{16} V(S_i) = (-2) + (1) + (-7) + (-5) = -13\n$$\n\n或者，我们可以计算每个输出值的频率：\n- 值$V(S)=1$出现$3$次。\n- 值$V(S)=0$出现$3$次。\n- 值$V(S)=-1$出现$4$次。\n- 值$V(S)=-2$出现$6$次。\n（检查：$3+3+4+6 = 16$）。\n\n值的总和是：\n$$\n\\sum V(S) = (3 \\times 1) + (3 \\times 0) + (4 \\times -1) + (6 \\times -2) = 3 + 0 - 4 - 12 = -13\n$$\n两种方法得出相同的总和。\n现在，我们可以计算期望值：\n$$\nE[S] = \\frac{1}{16} \\sum_{i=1}^{16} V(S_i) = \\frac{-13}{16}\n$$\n\n饱和和$S$的精确期望值为$-\\frac{13}{16}$。",
            "answer": "$$\n\\boxed{-\\frac{13}{16}}\n$$"
        },
        {
            "introduction": "最后，我们将真值表的应用从定义单个组件提升到实现体系结构层面的优化。这个练习将展示如何利用一个简单的逻辑函数——仅通过分析两个数字的符号位来定义——来创建一个控制信号。这个信号能够智能地决定是否需要执行一次完整的、消耗大量资源的比较操作，从而将位级逻辑与处理器的高层性能直接联系起来。",
            "id": "3686338",
            "problem": "考虑处理器数据通路中的一个比较器阶段，该阶段必须为两个二进制补码表示的有符号整数决定是调用低位的数值比较，还是仅使用符号信息来旁路该比较。设$A$和$B$是两个$n$位二进制补码整数，其最高有效位（MSB）符号位分别为$A_{msb}$和$B_{msb}$。定义一个检测器，该检测器仅由应用于$A_{msb}$和$B_{msb}$的逻辑非（用补码运算符$'$表示）和异或（XOR）运算构成；异或（XOR）是作用于比特$x$和$y$的二元运算，当且仅当$x \\neq y$时，$x \\oplus y = 1$，否则$x \\oplus y = 0$。您必须：\n- 从布尔逻辑和真值表的基本原理出发，推导出一个信号$SameSign$的正确真值表。当且仅当$A$和$B$的符号相同时，$SameSign$为真，否则为假。仅使用$A_{msb}$和$B_{msb}$作为输入。\n- 使用$SameSign$的真值表，定义一个门控信号$Bypass$。当仅凭$A$和$B$的符号就足以确定它们的顺序时，该信号会禁用数值比较。假设当$A$和$B$符号不同时，可以旁路数值比较，因为在二进制补码中，任何正数都大于任何负数。\n现在假设在大量工作负载中观察到的符号位是独立随机变量，满足$\\mathbb{P}(A_{msb} = 1) = p$和$\\mathbb{P}(B_{msb} = 1) = q$，其中，在二进制补码中，$1$表示负符号位，$0$表示非负符号。利用您的真值表和独立性，推导出一个封闭形式的解析表达式，用于表示将被旁路的比较所占的预期比例。以单一解析表达式的形式提供最终答案。无需四舍五入，该量为无量纲量。",
            "solution": "按照题目要求，解答分三个阶段进行。\n\n**1. `$SameSign` 信号的真值表**\n\n信号$SameSign$被定义为当且仅当整数$A$和$B$具有相同符号时为真（逻辑$1$）。在二进制补码表示中，最高有效位（MSB）是符号位。MSB值为$0$表示非负数，值为$1$表示负数。因此，当且仅当符号位$A_{msb}$和$B_{msb}$相等时，$SameSign$为真。\n\n我们构建以$A_{msb}$和$B_{msb}$为输入的$SameSign$真值表：\n- 如果$A_{msb} = 0$且$B_{msb} = 0$，两个数都是非负数，所以它们的符号相同。$SameSign = 1$。\n- 如果$A_{msb} = 0$且$B_{msb} = 1$，一个数是非负数，另一个是负数，所以它们的符号不同。$SameSign = 0$。\n- 如果$A_{msb} = 1$且$B_{msb} = 0$，符号不同。$SameSign = 0$。\n- 如果$A_{msb} = 1$且$B_{msb} = 1$，两个数都是负数，所以它们的符号相同。$SameSign = 1$。\n\n完整的真值表如下：\n$$\n\\begin{array}{cc|c}\nA_{msb}  B_{msb}  SameSign \\\\\n\\hline\n0  0  1 \\\\\n0  1  0 \\\\\n1  0  0 \\\\\n1  1  1\n\\end{array}\n$$\n该真值表对应于逻辑同或（XNOR）运算。根据规定，这可以由非门和异或门构成，因为$x \\text{ XNOR } y = (x \\oplus y)'$。因此，$SameSign = (A_{msb} \\oplus B_{msb})'$。\n\n**2. `$Bypass` 信号的定义**\n\n题目指出，当$A$和$B$的符号足以确定它们的顺序时，数值比较被旁路。对于有符号数，任何非负数都大于任何负数。这种情况恰好在符号不同时发生。因此，当$A$和$B$的符号不同时，$Bypass$信号应为真（逻辑$1$），而当它们的符号相同时，应为假（逻辑$0$）。\n\n这个条件与$SameSign$信号在逻辑上完全相反。\n$Bypass = (SameSign)'$。\n代入$SameSign$的表达式：\n$Bypass = ((A_{msb} \\oplus B_{msb})')' = A_{msb} \\oplus B_{msb}$。\n\n$Bypass$信号的真值表由“当且仅当$A_{msb} \\neq B_{msb}$时为真”的条件推导得出：\n$$\n\\begin{array}{cc|c}\nA_{msb}  B_{msb}  Bypass \\\\\n\\hline\n0  0  0 \\\\\n0  1  1 \\\\\n1  0  1 \\\\\n1  1  0\n\\end{array}\n$$\n该真值表证实了$Bypass$信号等价于符号位的异或（XOR）运算，$Bypass = A_{msb} \\oplus B_{msb}$。\n\n**3. 被旁路比较的预期比例的表达式**\n\n将被旁路的比较所占的预期比例是$Bypass$信号的期望值，记为$\\mathbb{E}[Bypass]$。$Bypass$信号是一个二元随机变量，取值于$\\{0, 1\\}$。对于这类变量，其期望值等于该变量为$1$的概率：\n$$ \\mathbb{E}[Bypass] = \\mathbb{P}(Bypass = 1) $$\n从$Bypass$的真值表中，我们看到$Bypass = 1$在以下两种互斥条件下成立：\n1. $A_{msb} = 0$且$B_{msb} = 1$。\n2. $A_{msb} = 1$且$B_{msb} = 0$。\n\n因此，概率$\\mathbb{P}(Bypass = 1)$是这两个不相交事件的概率之和：\n$$ \\mathbb{P}(Bypass = 1) = \\mathbb{P}(A_{msb} = 0 \\text{ and } B_{msb} = 1) + \\mathbb{P}(A_{msb} = 1 \\text{ and } B_{msb} = 0) $$\n题目指出$A_{msb}$和$B_{msb}$是独立随机变量。因此，联合事件的概率是个体概率的乘积：\n$$ \\mathbb{P}(Bypass = 1) = \\mathbb{P}(A_{msb} = 0) \\cdot \\mathbb{P}(B_{msb} = 1) + \\mathbb{P}(A_{msb} = 1) \\cdot \\mathbb{P}(B_{msb} = 0) $$\n我们已知以下概率：\n$$ \\mathbb{P}(A_{msb} = 1) = p $$\n$$ \\mathbb{P}(B_{msb} = 1) = q $$\n根据概率的补集法则：\n$$ \\mathbb{P}(A_{msb} = 0) = 1 - \\mathbb{P}(A_{msb} = 1) = 1 - p $$\n$$ \\mathbb{P}(B_{msb} = 0) = 1 - \\mathbb{P}(B_{msb} = 1) = 1 - q $$\n将这些表达式代入$\\mathbb{P}(Bypass = 1)$的方程中：\n$$ \\mathbb{P}(Bypass = 1) = (1 - p)q + p(1 - q) $$\n展开各项：\n$$ \\mathbb{P}(Bypass = 1) = q - pq + p - pq $$\n合并各项，得到被旁路比较的预期比例的最终封闭形式表达式：\n$$ \\mathbb{E}[Bypass] = p + q - 2pq $$\n该表达式表示在给定两个符号位分别为负的概率的情况下，这两个符号位不相同的概率。",
            "answer": "$$\n\\boxed{p+q-2pq}\n$$"
        }
    ]
}