{
    "hands_on_practices": [
        {
            "introduction": "The primary characteristic of a ripple counter is its sequential, stage-by-stage operation, which leads to an accumulation of propagation delay. This cumulative delay is the single most important factor limiting the counter's maximum operating speed. This first exercise provides a fundamental calculation to quantify this worst-case delay, a critical first step in evaluating whether a ripple counter's simple design is acceptable for a given timing-sensitive application .",
            "id": "1955756",
            "problem": "A digital control system relies on a 12-bit asynchronous binary counter, commonly known as a ripple counter, for event sequencing. The counter is constructed by cascading toggle flip-flops, where the output of one flip-flop serves as the clock input for the subsequent one. The manufacturer specifies that each individual flip-flop has a clock-to-output propagation delay of 15 nanoseconds (ns). To ensure the integrity of the system's operations, it is crucial to determine the maximum time the counter takes to settle to a stable value after a clock pulse is applied to its first stage. This duration is known as the total worst-case propagation delay.\n\nCalculate the total worst-case propagation delay for this 12-bit ripple counter. Express your answer in nanoseconds (ns).",
            "solution": "A ripple (asynchronous) counter is formed by cascading toggle flip-flops so that the output of each stage serves as the clock input to the next stage. If each flip-flop has a clock-to-output propagation delay $t_{pd}$, then a change at the first stage must propagate through each subsequent stage sequentially. The worst-case settling time occurs when the change ripples through all $N$ stages (e.g., a transition that causes every flip-flop to toggle).\n\nTherefore, the total worst-case propagation delay is the sum of the per-stage delays:\n$$\nT_{\\text{wc}} = N \\cdot t_{pd}.\n$$\nFor a $12$-bit ripple counter, $N = 12$, and with each flip-flop having $t_{pd} = 15 \\text{ ns}$,\n$$\nT_{\\text{wc}} = 12 \\times 15 \\text{ ns} = 180 \\text{ ns}.\n$$\nHence, the maximum time for the counter to settle after a clock pulse to the first stage is $180 \\text{ ns}$.",
            "answer": "$$\\boxed{180}$$"
        },
        {
            "introduction": "While a standard $N$-bit counter cycles through $2^N$ states, many applications require custom counting sequences, such as BCD counters that cycle from 0 to 9. This practice problem moves from analysis to practical design, demonstrating how to truncate a counter's natural sequence. By designing simple combinational logic to trigger an asynchronous reset, you will learn to create a modulo-N counter that meets specific application requirements, a foundational skill in digital system design .",
            "id": "1947821",
            "problem": "An asynchronous 4-bit binary ripple counter is constructed using four negative-edge-triggered J-K flip-flops, labeled FF0, FF1, FF2, and FF3. The outputs of these flip-flops are $Q_0, Q_1, Q_2, Q_3$ respectively, where $Q_0$ is the Least Significant Bit (LSB) and $Q_3$ is the Most Significant Bit (MSB). For all flip-flops, the J and K inputs are permanently tied to a logic HIGH voltage. The external clock signal is applied only to the clock input of FF0. The clock input for each subsequent flip-flop (FF1, FF2, FF3) is driven by the output of the preceding one (e.g., the clock for FF1 is connected to the $Q_0$ output). All four flip-flops share a common active-low asynchronous clear input, denoted as `CLR_N`.\n\nTo modify this counter into a modulo-9 counter (i.e., a counter that counts from 0 to 8 and then resets to 0), a combinational logic gate is used to drive the `CLR_N` line. The inputs to this gate are selected from the counter's outputs ($Q_3, Q_2, Q_1, Q_0$). The counter should reset as soon as it attempts to enter the invalid state of decimal 9.\n\nWhich of the following logic gate configurations correctly implements the required reset logic for the modulo-9 counter?\n\nA. A 2-input AND gate with its inputs connected to $Q_3$ and $Q_0$.\n\nB. A 2-input AND gate with its inputs connected to $Q_2$ and $Q_1$.\n\nC. A 2-input NAND gate with its inputs connected to $Q_3$ and $Q_1$.\n\nD. A 2-input NAND gate with its inputs connected to $Q_3$ and $Q_0$.\n\nE. A 2-input NOR gate with its inputs connected to $Q_3$ and $Q_0$.",
            "solution": "The problem requires us to design the reset logic for a 4-bit asynchronous counter to make it a modulo-9 counter.\n\nFirst, let's understand the desired behavior of a modulo-9 counter. It should count through the decimal states 0, 1, 2, 3, 4, 5, 6, 7, and 8. The corresponding binary representations using the outputs $Q_3Q_2Q_1Q_0$ are from `0000` to `1000`. The counter must not be allowed to stay in the state corresponding to decimal 9. When the counter reaches the state for decimal 9, it must be immediately reset to the initial state, which is decimal 0 (`0000`).\n\nThe state that triggers the reset is decimal 9. In binary, this state is represented as $Q_3Q_2Q_1Q_0 = 1001$. This is the first invalid state the counter will attempt to enter after reaching the maximum valid count of 8 (`1000`).\n\nThe problem states that the flip-flops have a common active-low asynchronous clear input, `CLR_N`. An \"active-low\" input means that the reset action (clearing the flip-flop outputs to 0) is triggered when the `CLR_N` line receives a logic `0`. For all other times, the `CLR_N` line must be at logic `1` to allow the counter to operate normally.\n\nTherefore, our task is to design a logic circuit whose output is connected to `CLR_N` and satisfies the following conditions:\n1. The output is logic `0` when the counter state is $Q_3Q_2Q_1Q_0 = 1001$.\n2. The output is logic `1` for all valid counting states from $Q_3Q_2Q_1Q_0 = 0000$ to $Q_3Q_2Q_1Q_0 = 1000$.\n\nLet's analyze the reset state `1001`. In this state, the outputs are $Q_3=1$, $Q_2=0$, $Q_1=0$, and $Q_0=1$. We need to find a simple logic gate that can detect this specific condition. A logic gate's output depends on its inputs. We can use the flip-flop outputs $Q_0, Q_1, Q_2, Q_3$ as inputs to our reset gate.\n\nConsider the condition required to generate a logic `0` for the reset. We are looking for a gate that outputs `0` when the state is `1001`.\nThe most straightforward way to detect a specific combination of inputs being HIGH is to use an AND gate or a NAND gate.\n- An AND gate outputs a `1` only when all its inputs are `1`.\n- A NAND gate outputs a `0` only when all its inputs are `1`.\n\nSince we need a logic `0` to trigger the active-low `CLR_N`, a NAND gate is the natural choice. The inputs to the NAND gate should be all `1`s for the state we want to detect.\nIn the state `1001`, the bits that are `1` are $Q_3$ and $Q_0$. So, if we connect $Q_3$ and $Q_0$ to the inputs of a 2-input NAND gate, the output of the gate will be:\n`Output = NOT (Q3 AND Q0)`\n\nLet's test this logic. When the counter tries to enter state 9 (`1001`), the inputs to the NAND gate will be $Q_3=1$ and $Q_0=1$.\n`Output = NOT (1 AND 1) = NOT(1) = 0`.\nThis logic `0` will activate the `CLR_N` line and reset all flip-flops to `0000`.\n\nNow we must verify that this logic does not cause a premature reset during the valid counting sequence (0 to 8).\nThe condition for reset is $Q_3=1$ AND $Q_0=1$. Let's check the states from 0 to 8:\n- State 0 (`0000`): $Q_3=0, Q_0=0$. Output = NOT(0 AND 0) = 1. No reset.\n- State 1 (`0001`): $Q_3=0, Q_0=1$. Output = NOT(0 AND 1) = 1. No reset.\n- ...\n- State 8 (`1000`): $Q_3=1, Q_0=0$. Output = NOT(1 AND 0) = 1. No reset.\nDuring the entire valid count sequence from 0 to 8, the condition ($Q_3=1$ and $Q_0=1$) is never met simultaneously. The first time it is met is at state 9 (`1001`). Therefore, connecting the `CLR_N` line to the output of a 2-input NAND gate with inputs $Q_3$ and $Q_0$ will correctly implement the modulo-9 counter.\n\nLet's evaluate the given options:\nA. A 2-input AND gate with inputs $Q_3$ and $Q_0$: At state 9, the output would be `1 AND 1 = 1`. This would not trigger an active-low reset.\nB. A 2-input AND gate with inputs $Q_2$ and $Q_1$: This would output 1 at state 6 (`0110`), not what is needed.\nC. A 2-input NAND gate with inputs $Q_3$ and $Q_1$: This would output 0 when $Q_3=1$ and $Q_1=1$. This condition first occurs at state 10 (`1010`). This would create a modulo-10 counter, not a modulo-9 counter.\nD. A 2-input NAND gate with inputs $Q_3$ and $Q_0$: As derived, this is the correct configuration. It detects state 9 (`1001`) and outputs a `0` to trigger the reset.\nE. A 2-input NOR gate with inputs $Q_3$ and $Q_0$: The output is `NOT (Q3 OR Q0)`. This would be `0` if either $Q_3$ or $Q_0$ is `1`. This would cause a reset at state 1 (`0001`), which is incorrect.\n\nThus, the correct configuration is a 2-input NAND gate with its inputs connected to $Q_3$ and $Q_0$.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "The ripple effect in asynchronous counters has consequences beyond simple delay accumulation; it also creates transient, invalid states between valid counts that can cause \"glitches\" in decoding logic. This advanced exercise delves into the root cause of these glitches, tasking you with analyzing how the staggered toggling of bits produces them. More importantly, it presents an optimization challenge: by strategically placing components with different speeds, you can actively minimize these hazardous effects, illustrating a key principle of robust, high-integrity digital design .",
            "id": "3674130",
            "problem": "A four-bit asynchronous ripple counter is built by cascading four edge-triggered toggle flip-flops (T flip-flops). Let the binary state be denoted by $\\{X_{3},X_{2},X_{1},X_{0}\\}$, with $X_{3}$ the most significant bit (MSB) and $X_{0}$ the least significant bit (LSB). On each active clock edge applied to $X_{0}$, the ripple carry propagates upward: $X_{0}$ toggles first after its own clock-to-$Q$ propagation delay, and any $X_{k}$ for $k \\geq 1$ toggles only after $X_{k-1}$ has toggled, accruing the clock-to-$Q$ delay of each intervening stage. Assume an ideal transport delay model for all devices: each flip-flop exhibits a fixed clock-to-$Q$ propagation delay and the delay through any logic gate is a fixed transport delay; wiring delays are negligible.\n\nYou are given four physically distinct T flip-flops: one “slow” device with clock-to-$Q$ delay $t_{s} = 5.00\\,\\text{ns}$ and three “fast” devices each with clock-to-$Q$ delay $t_{f} = 2.00\\,\\text{ns}$. You may assign these four devices arbitrarily to the bit positions $X_{3},X_{2},X_{1},X_{0}$, but each position must be occupied by exactly one device.\n\nA decoding function is implemented as a single four-input NOR gate whose inputs are the counter outputs $\\{X_{3},X_{2},X_{1},X_{0}\\}$; its output is therefore logic-high if and only if the counter state is $\\{0,0,0,0\\}$. The NOR gate itself has a fixed transport propagation delay $\\tau_{g} = 0.50\\,\\text{ns}$. The system is operated so that the counter free-runs, and the NOR output is observed on an ideal oscilloscope. Due to the asynchronous ripple, the decoder can produce spurious narrow pulses (“glitches”) when the counter passes through intermediate states during multi-bit transitions.\n\nStarting only from the core definitions above (asynchronous ripple sequencing and transport propagation delays), derive from first principles how the temporal ordering of bit toggles creates a transient window during which the decoder momentarily sees the all-zero pattern as the counter ripples through the sequence of intermediate states. Then, considering all possible counter transitions within a single count event that can produce such a transient all-zero pattern at the NOR inputs, determine the worst-case glitch pulse width at the NOR output for a given assignment of flip-flops to bit positions. Finally, choose the assignment of the slow device to either the LSB $X_{0}$ or the MSB $X_{3}$ so as to minimize this worst-case observed glitch width, and compute the corresponding minimal worst-case glitch width numerically.\n\nExpress your final numerical answer in nanoseconds, rounded to three significant figures.",
            "solution": "The problem requires an analysis of transient glitches in a $4$-bit asynchronous ripple counter decoded by a NOR gate. We must first establish from first principles the mechanism by which these glitches are generated and then determine the optimal assignment of non-identical flip-flops to minimize the worst-case glitch width.\n\nThe counter consists of four T flip-flops, with the state denoted by $\\{X_3, X_2, X_1, X_0\\}$, where $X_0$ is the least significant bit (LSB) and $X_3$ is the most significant bit (MSB). In an asynchronous ripple counter, an external clock signal is applied only to the LSB flip-flop ($X_0$). For any subsequent stage $k > 0$, the output of the flip-flop at stage $k-1$ (i.e., $X_{k-1}$) serves as the clock input for the flip-flop at stage $k$. We assume the flip-flops are edge-triggered, such that a change in $X_{k-1}$ can trigger a toggle in $X_k$. Let $t_{pd,k}$ be the clock-to-Q propagation delay of the flip-flop assigned to bit position $X_k$.\n\nWhen a clock edge arrives at the input of the $X_0$ flip-flop at time $t=0$, $X_0$ will toggle its state at time $t_{tog,0} = t_{pd,0}$. If this toggle of $X_0$ constitutes an active clock edge for the $X_1$ flip-flop, then $X_1$ will toggle at time $t_{tog,1} = t_{tog,0} + t_{pd,1} = t_{pd,0} + t_{pd,1}$. This propagation of toggles ripples through the counter. In general, if bit $X_k$ is triggered by a toggle of bit $X_{k-1}$, the time at which $X_k$ completes its toggle is given by the cumulative delay:\n$$t_{tog,k} = t_{tog,k-1} + t_{pd,k} = \\sum_{i=0}^{k} t_{pd,i}$$\n\nA glitch at the output of the $4$-input NOR decoder occurs if its inputs transiently become $\\{0,0,0,0\\}$ during a transition between two states, neither of which is the all-zero state. The NOR gate output is logic-high if and only if all its inputs, $\\{X_3, X_2, X_1, X_0\\}$, are logic-low. A transient high pulse (glitch) is produced when the counter passes through the $\\{0,0,0,0\\}$ state for a short duration.\n\nLet us analyze the state transitions of the up-counter to identify those that can produce a transient $\\{0,0,0,0\\}$ state. This occurs when all bits that are initially $1$ toggle to $0$ *before* any bit that is initially $0$ toggles to $1$. In an up-counter, this behavior is characteristic of transitions from a state of the form $2^k - 1$ to $2^k$.\n\n1.  **Transition from $1$ to $2$ ($\\{0,0,0,1\\} \\to \\{0,0,1,0\\}$)**:\n    - Initial state at $t<t_{pd,0}$: $\\{0,0,0,1\\}$. $X_0=1$, so the NOR output is low.\n    - At $t_{start} = t_{pd,0}$, $X_0$ toggles from $1 \\to 0$. The counter state becomes $\\{0,0,0,0\\}$. This is the all-zero state, so the inputs to the NOR gate are all low.\n    - The $1 \\to 0$ transition of $X_0$ triggers the $X_1$ flip-flop.\n    - At $t_{end} = t_{pd,0} + t_{pd,1}$, $X_1$ toggles from $0 \\to 1$. The counter state becomes $\\{0,0,1,0\\}$, which is the final stable state for this counting step. The NOR inputs are no longer all-zero.\n    - A transient $\\{0,0,0,0\\}$ state exists for the interval $[t_{start}, t_{end})$. The duration of this transient, which is the width of the glitch at the NOR gate's inputs, is $t_{end} - t_{start} = (t_{pd,0} + t_{pd,1}) - t_{pd,0} = t_{pd,1}$. The NOR gate's own delay, $\\tau_g = 0.50\\,\\text{ns}$, shifts this pulse in time but does not alter its width. So, the glitch width is $W_{1\\to2} = t_{pd,1}$.\n\n2.  **Transition from $3$ to $4$ ($\\{0,0,1,1\\} \\to \\{0,1,0,0\\}$)**:\n    - Initial state: $\\{0,0,1,1\\}$. NOR output is low.\n    - At $t=t_{pd,0}$, $X_0$ toggles $1 \\to 0$. State becomes $\\{0,0,1,0\\}$.\n    - At $t_{start} = t_{pd,0} + t_{pd,1}$, $X_1$ toggles $1 \\to 0$. State becomes $\\{0,0,0,0\\}$. This initiates the glitch condition.\n    - The $1 \\to 0$ transition of $X_1$ triggers the $X_2$ flip-flop.\n    - At $t_{end} = t_{pd,0} + t_{pd,1} + t_{pd,2}$, $X_2$ toggles $0 \\to 1$. State becomes $\\{0,1,0,0\\}$. The glitch condition ends.\n    - The glitch width is $t_{end} - t_{start} = (t_{pd,0} + t_{pd,1} + t_{pd,2}) - (t_{pd,0} + t_{pd,1}) = t_{pd,2}$. So, $W_{3\\to4} = t_{pd,2}$.\n\n3.  **Transition from $7$ to $8$ ($\\{0,1,1,1\\} \\to \\{1,0,0,0\\}$)**:\n    - Following the same logic, bits $X_0, X_1, X_2$ toggle from $1 \\to 0$ sequentially. The transient $\\{0,0,0,0\\}$ state begins when $X_2$ has toggled to $0$ and ends when $X_3$ toggles to $1$.\n    - The all-zero state begins at $t_{start} = t_{pd,0} + t_{pd,1} + t_{pd,2}$.\n    - It ends when $X_3$ toggles at $t_{end} = t_{pd,0} + t_{pd,1} + t_{pd,2} + t_{pd,3}$.\n    - The glitch width is $t_{end} - t_{start} = t_{pd,3}$. So, $W_{7\\to8} = t_{pd,3}$.\n\nOther transitions, such as $15 \\to 0$ ($\\{1,1,1,1\\} \\to \\{0,0,0,0\\}$), do not produce a glitch because the all-zero state is the stable final state, not a transient one. Transitions that do not involve a ripple carry past a bit that remains $0$ (e.g., $5 \\to 6$, which is $\\{0,1,0,1\\} \\to \\{0,1,1,0\\})$ will not pass through the all-zero state.\n\nFor a given assignment of flip-flop delays $\\{t_{pd,0}, t_{pd,1}, t_{pd,2}, t_{pd,3}\\}$, the set of possible glitch widths is $\\{t_{pd,1}, t_{pd,2}, t_{pd,3}\\}$. The worst-case (longest) glitch width is therefore:\n$$W_{max} = \\max(t_{pd,1}, t_{pd,2}, t_{pd,3})$$\nNoticeably, $t_{pd,0}$ does not determine the width of any glitch, only its timing.\n\nWe are given one slow flip-flop with delay $t_s = 5.00\\,\\text{ns}$ and three fast flip-flops with delay $t_f = 2.00\\,\\text{ns}$. We need to find the assignment of the slow device to either $X_0$ or $X_3$ that minimizes $W_{max}$.\n\n**Case 1: Slow device at LSB ($X_0$)**\nIn this configuration, we assign the slow flip-flop to the $X_0$ position and the fast ones to the other positions.\n- $t_{pd,0} = t_s = 5.00\\,\\text{ns}$\n- $t_{pd,1} = t_{pd,2} = t_{pd,3} = t_f = 2.00\\,\\text{ns}$\nThe worst-case glitch width is:\n$$W_{max}^{(1)} = \\max(t_{pd,1}, t_{pd,2}, t_{pd,3}) = \\max(t_f, t_f, t_f) = \\max(2.00\\,\\text{ns}, 2.00\\,\\text{ns}, 2.00\\,\\text{ns}) = 2.00\\,\\text{ns}$$\n\n**Case 2: Slow device at MSB ($X_3$)**\nIn this configuration, we assign the slow flip-flop to the $X_3$ position. The other three positions, $X_0, X_1, X_2$, must be occupied by the fast devices.\n- $t_{pd,3} = t_s = 5.00\\,\\text{ns}$\n- $t_{pd,0} = t_{pd,1} = t_{pd,2} = t_f = 2.00\\,\\text{ns}$\nThe worst-case glitch width is:\n$$W_{max}^{(2)} = \\max(t_{pd,1}, t_{pd,2}, t_{pd,3}) = \\max(t_f, t_f, t_s) = \\max(2.00\\,\\text{ns}, 2.00\\,\\text{ns}, 5.00\\,\\text{ns}) = 5.00\\,\\text{ns}$$\n\nTo minimize the worst-case glitch width, we compare the results from the two cases: $W_{max}^{(1)} = 2.00\\,\\text{ns}$ and $W_{max}^{(2)} = 5.00\\,\\text{ns}$. The minimum of these is $2.00\\,\\text{ns}$, which is achieved by placing the slow flip-flop at the LSB position ($X_0$). This choice ensures that the slow delay does not contribute to the width of any decoding glitch, as the glitch widths depend only on the delays of the flip-flops at positions $X_1, X_2,$ and $X_3$.\n\nThe minimal worst-case glitch width is $2.00\\,\\text{ns}$.",
            "answer": "$$\\boxed{2.00}$$"
        }
    ]
}