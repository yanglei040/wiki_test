{
    "hands_on_practices": [
        {
            "introduction": "解码器是计算机体系结构中的基本组件，其核心功能是解释二进制编码并激活相应的输出。一个经典的例子是地址对齐检查，这是现代CPU执行加载和存储指令时必须满足的约束。这个练习将引导你从第一性原理出发，设计一个用于检测访存地址是否对齐的解码器，并思考其在处理器流水线中的最佳位置，从而加深对解码器在指令执行中的关键作用的理解。",
            "id": "3633922",
            "problem": "一个中央处理器 (CPU) 实现了一个加载/存储指令集，带有一个由取指令 (IF)、指令译码 (ID)、执行 (EX)、访存 (MEM) 和写回 (WB) 组成的$5$级流水线。有效地址在执行阶段计算，公式为 $EA = R_s + \\text{imm}$，其中 $EA$ 是有效地址，$R_s$ 是一个基址寄存器，$\\text{imm}$ 是一个符号位扩展的立即数。该架构支持 $2^a$ 字节的访问宽度，其中 $a \\in \\{0,1,2,3\\}$ 分别对应于字节 ($1$)、半字 ($2$)、字 ($4$) 和双字 ($8$) 访问。指令译码器在指令译码阶段从操作码中产生 $a$。内存系统使用带有页表旁路缓冲 (TLB) 的虚拟内存，并且处理器必须在发出任何内存事务或修改寄存器文件之外的体系结构状态之前，对任何未对齐的加载或存储引发一个精确异常。对齐由一个经过充分检验的规则定义：宽度为 $W = 2^a$ 字节的访问必须满足 $EA \\bmod W = 0$。\n\n设计一个地址对齐译码器，通过译码 $EA$ 的低 $a$ 位来检测未对齐的 $2^a$ 字节访问。基于第一性原理，确定为检测未对齐必须检查低 $a$ 位的最小布尔条件，并指出在所述的流水线和虚拟内存假设下，放置此译码器以保证精确异常且无内存副作用的最早流水线阶段。\n\n哪个选项正确地指明了布尔条件和合适的流水线位置？\n\nA. 对于宽度为 $2^a$ 字节的访问，如果 $EA$ 的低 $a$ 位中有任何一位为 $1$，则为未对齐。通过一个 $a$ 输入的或非门或等价比较器检查 $EA[a-1:0] = 0$ 来实现；将译码器放置在执行 (EX) 阶段，因为 $EA$ 在此阶段最先可用，以便取消后续的访存 (MEM) 阶段并在任何内存事务发生前引发异常。\n\nB. 对于宽度为 $2^a$ 字节的访问，如果 $EA[a:0]$ 中有任何一位为 $1$，则为未对齐，因为访问跨越了 $2^a$ 个地址。将译码器放置在访存 (MEM) 阶段，因为数据内存宽度控制只在该阶段可用。\n\nC. 在有虚拟内存的情况下，未对齐只能在地址转换后确定，因为 TLB 可能会改变地址的低 $a$ 位。因此，译码器必须放置在访存 (MEM) 阶段中 TLB 之后。\n\nD. 字节访问 ($a=0$) 在 $64$ 位机器上是未对齐的，因为地址必须至少是 $2$ 字节对齐的；因此，译码器应为 $a=0$ 发出未对齐信号，并将检查放置在写回 (WB) 阶段以维持精确异常。\n\nE. 通过对 $EA$ 的低 $a$ 位进行与规约 (AND-reduction) 并在规约结果为 $0$ 时发出未对齐信号来检测未对齐；将译码器放置在指令译码 (ID) 阶段，以避免在执行 (EX) 阶段前浪费周期。",
            "solution": "我们从对齐的核心定义开始：宽度为 $W = 2^a$ 字节的访问是对齐的，当且仅当有效地址 $EA$ 满足\n$$EA \\bmod W = 0.$$\n在二进制中，这等价于 $EA$ 的低 $a$ 位全为零的陈述。要理解原因，可以观察到 $W = 2^a$ 定义了地址块，块内地址共享相同的高位，而块内偏移由低 $a$ 位给出。余数 $EA \\bmod 2^a$ 正是由 $EA[a-1:0]$ 所表示的值。因此，\n$$EA \\bmod 2^a = 0 \\quad \\Longleftrightarrow \\quad EA[a-1:0] = 0.$$\n因此，当\n$$EA \\bmod 2^a \\ne 0 \\quad \\Longleftrightarrow \\quad EA[a-1:0] \\ne 0 \\quad \\Longleftrightarrow \\quad \\bigvee_{i=0}^{a-1} EA_i = 1,$$\n时，可以精确地检测到未对齐访问，其中 $\\bigvee$ 表示对低 $a$ 位的逻辑或运算。\n\n从流水线的角度看，$EA$ 可用的最早阶段是执行 (EX) 阶段，因为 $EA = R_s + \\text{imm}$ 需要读取 $R_s$（在指令译码 (ID) 阶段执行）然后执行加法（在执行 (EX) 阶段执行）。虽然指令译码 (ID) 阶段从操作码中知道 $a$，但它不知道 $EA$；因此无法在该阶段判断是否对齐。将未对齐译码器放置在执行 (EX) 阶段，允许控制逻辑引发一个精确异常，并在发生任何内存副作用之前取消访存 (MEM) 阶段，从而满足精确异常的要求。对于虚拟内存，页表旁路缓冲 (TLB) 的地址转换会保留页内偏移，所以低位 $EA[a-1:0]$ 不受地址转换的影响；对齐检查可以安全地在地址转换前使用虚拟地址 $EA$ 进行。因此，最小且正确的条件是 $EA[a-1:0] \\ne 0$，通过一个 $a$ 输入的或非门或等价比较器检查 $EA[a-1:0] = 0$ 来实现，而合适的最早放置位置是执行 (EX) 阶段。\n\n逐项分析选项：\n\nA. 该选项指出，如果 $EA$ 的低 $a$ 位中有任何一位为 $1$，则 $2^a$ 字节的访问是未对齐的，并建议通过一个 $a$ 输入的或非门或等价比较器检查 $EA[a-1:0] = 0$ 来实现。这与我们的推导相符：$EA \\bmod 2^a = 0$ 当且仅当 $EA[a-1:0] = 0$，所以当这些位中有任何一位为 $1$ 时就会发生未对齐。放置在执行 (EX) 阶段是正确的，因为 $EA$ 在此阶段最先可用，允许流水线取消访存 (MEM) 阶段并在任何内存流量发生前引发精确异常。结论：正确。\n\nB. 该选项错误地将位 $a$ 包含在对齐掩码中，提议检查 $EA[a:0] = 0$。对于 $2^a$ 字节对齐，正确的掩码恰好覆盖低 $a$ 位，即 $EA[a-1:0]$。包含位 $a$ 会错误地拒绝那些 $EA[a] = 1$ 但 $EA[a-1:0] = 0$ 的对齐地址，这些是 $2^a$ 的有效倍数。它还错误地断言数据内存宽度控制只在访存 (MEM) 阶段可用；宽度 $a$ 在指令译码 (ID) 阶段被译码，$EA$ 在执行 (EX) 阶段计算，因此对齐检查可以在比访存 (MEM) 更早的执行 (EX) 阶段完成。结论：不正确。\n\nC. 该选项声称页表旁路缓冲 (TLB) 可能会改变低 $a$ 位，因此需要将检查放置在地址转换之后。在标准的虚拟内存系统中，页内偏移（页内的低位）在地址转换中是保留的；只有高位（页号）会被改变。因此，低 $a$ 位 $EA[a-1:0]$ 在地址转换下是不变的，对齐检查可以在访存 (MEM) 阶段之前进行。结论：不正确。\n\nD. 该选项声称字节访问 ($a=0$) 是未对齐的，并建议为 $a=0$ 发出未对齐信号，并将检查放置在写回 (WB) 阶段。根据定义，对于 $a=0$，我们有 $W = 2^0 = 1$，条件 $EA \\bmod 1 = 0$ 对所有整数 $EA$ 始终为真；字节访问总是对齐的。此外，写回 (WB) 阶段太晚了，无法确保没有内存副作用，因为内存在访存 (MEM) 阶段就已经被访问了。结论：不正确。\n\nE. 该选项建议通过对低 $a$ 位进行与规约 (AND-reduction) 并在规约结果为 $0$ 时发出未对齐信号来检测未对齐。正确的条件是，如果低 $a$ 位中有任何一位为 $1$，即或规约 (OR-reduction) 结果为 $1$ 时，发生未对齐。与规约结果为 $1$ 仅在所有位都为 $1$ 时发生，这并非对齐条件；使用与规约会产生错误的谓词。此外，将译码器放置在指令译码 (ID) 阶段是不可行的，因为 $EA$ 在 ID 阶段尚未计算出来。结论：不正确。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在掌握了单个解码器的基本功能后，让我们将其应用到更宏大的系统设计中——并行存储系统。为了提升存储器带宽，现代处理器常常采用存储体交错技术，通过解码器根据地址选择不同的存储体。这个练习将带你设计一个基于线性地址映射的交错存储系统，并从根本上分析在不同访问模式（如顺序访问和步长访问）下发生存储体冲突的概率，揭示简单解码方案潜在的性能瓶颈。",
            "id": "3633908",
            "problem": "您正在为向量处理器设计一个采用 bank 交错的主存储器子系统。该子系统使用 $B = 2^r$ 个相同的单端口 bank。物理地址的低 $r$ 位输入到一个 $r$-to-$2^r$ 二进制解码器，该解码器产生 $2^r$ 个 one-hot 编码的 bank 使能信号；每个内存请求恰好选择一个 bank。剩余的高位地址位用于选择所选 bank 内的位置。\n\n在每个周期中，一个向量加载操作会向地址 $\\{A_j\\}_{j=0}^{m-1}$ 发出 $m$ 个同时的标量内存请求，其中 $A_j = A_0 + j \\cdot d$，$A_0$ 是任意起始地址，$d$ 是步长。假设 $A_0 \\bmod B$ 在 $\\{0,1,\\dots,B-1\\}$ 上均匀分布。bank 冲突定义为存在索引 $j \\neq k$，使得对应的 bank 索引相等，即 $(A_j \\bmod B) = (A_k \\bmod B)$，从而导致在同一周期内至少有两个请求访问同一个 bank。\n\n从二进制解码器的基本定义以及低 $r$ 位选择 $2^r$ 个 bank 之一的属性出发，根据第一性原理推导在以下两种访问模式下，$m$ 个并发请求中至少发生一次冲突的概率：\n- 顺序访问：$d = 1$。\n- 步长访问：$d = s$，其中 $s$ 为给定的正整数。\n\n请用 $r$、$m$ 和 $s$ 的函数，以封闭形式表示您的结果，仅使用明确定义的数学运算和函数，并为您使用的任何数论对象提供理由。\n\n最后，对特定参数 $r = 5$、$m = 20$ 和 $s = 6$ 计算您推导出的概率，并将这两个概率报告为精确数值。无需四舍五入。您的最终答案必须是使用 LaTeX $\\texttt{pmatrix}$ 环境排列的数值概率对，形式为行向量，其中第一个条目对应顺序访问，第二个条目对应步长为 $s$ 的访问。",
            "solution": "问题要求计算在一个具有 $B = 2^r$ 个 bank 的 bank 交错存储系统中发生 bank 冲突的概率。给定物理地址 $A$ 的 bank 索引由其低 $r$ 位决定，这在数学上等同于运算 $A \\bmod B$。我们已知一个向量加载操作，它向地址 $A_j = A_0 + j \\cdot d$（其中 $j \\in \\{0, 1, \\dots, m-1\\}$）发出 $m$ 个并发请求。如果至少有两个不同的请求（例如索引为 $j$ 和 $k$，其中 $j \\neq k$）映射到同一个 bank，则发生 bank 冲突。\n\n发生 bank 冲突的条件是存在索引 $j, k \\in \\{0, 1, \\dots, m-1\\}$ 且 $j \\neq k$，使得：\n$$ A_j \\bmod B = A_k \\bmod B $$\n代入地址的表达式，我们得到：\n$$ (A_0 + j \\cdot d) \\bmod B = (A_0 + k \\cdot d) \\bmod B $$\n这个等式等价于同余式：\n$$ A_0 + j \\cdot d \\equiv A_0 + k \\cdot d \\pmod{B} $$\n从两边减去 $A_0$，我们得到：\n$$ j \\cdot d \\equiv k \\cdot d \\pmod{B} $$\n$$ (j-k) \\cdot d \\equiv 0 \\pmod{B} $$\n不失一般性，我们假设 $j > k$。令 $i = j-k$。由于 $0 \\le k  j \\le m-1$，整数 $i$ 必须在范围 $1 \\le i \\le m-1$ 内。因此，当且仅当存在一个整数 $i \\in \\{1, 2, \\dots, m-1\\}$ 使得：\n$$ i \\cdot d \\equiv 0 \\pmod{B} $$\n这个条件仅取决于参数 $m$、$d$ 和 $B$，而与起始地址 $A_0$ 无关。因此，对于给定的配置 $(m, d, B)$，冲突要么对任何 $A_0$ 都必然发生，要么对任何 $A_0$ 都必然不发生。冲突的概率要么是 $1$，要么是 $0$。因此，所提供的 $A_0 \\bmod B$ 均匀分布的信息对最终概率没有影响，因为冲突事件独立于 $A_0 \\bmod B$ 的具体值。\n\n我们现在分析两种指定的访问模式。\n\n情况 1：顺序访问 ($d=1$)\n对于顺序访问，步长 $d=1$。冲突的条件变为存在一个整数 $i \\in \\{1, 2, \\dots, m-1\\}$ 使得：\n$$ i \\cdot 1 \\equiv 0 \\pmod{B} $$\n这意味着 $i$ 必须是 $B$ 的倍数。当且仅当 $i$ 的可能取值集合 $\\{1, 2, \\dots, m-1\\}$ 中包含 $B=2^r$ 的倍数时，才会发生冲突。$B$ 的最小正倍数是 $B$ 本身。只有当 $B$ 在 $i$ 的取值范围内，即 $B \\le m-1$ 时，才可能发生冲突。这等价于 $m-1 \\ge B$，或 $m > B$。\n反之，如果 $m \\le B$，那么对于任何 $i \\in \\{1, 2, \\dots, m-1\\}$，我们有 $0  i  m \\le B$。因此，$i$ 不可能是 $B$ 的倍数。在这种情况下，不会发生冲突。\n因此，顺序访问的冲突概率 $P_1$ 为：\n$$ P_1 = \\begin{cases} 0  \\text{if } m \\le B \\\\ 1  \\text{if } m > B \\end{cases} $$\n代入 $B=2^r$，我们得到：\n$$ P_1 = \\begin{cases} 0  \\text{if } m \\le 2^r \\\\ 1  \\text{if } m > 2^r \\end{cases} $$\n\n情况 2：步长访问 ($d=s$)\n对于步长访问，步长 $d=s$。冲突的条件是存在一个整数 $i \\in \\{1, 2, \\dots, m-1\\}$ 使得：\n$$ i \\cdot s \\equiv 0 \\pmod{B} $$\n这是一个关于 $i$ 的线性同余方程。根据数论的第一性原理，我们必须找到 $i$ 的解。令 $g = \\gcd(s, B)$ 为步长 $s$ 和 bank 数量 $B$ 的最大公约数。我们可以写成 $s = g \\cdot s'$ 和 $B = g \\cdot B'$，其中 $\\gcd(s', B')=1$。同余方程变为：\n$$ i \\cdot g \\cdot s' \\equiv 0 \\pmod{g \\cdot B'} $$\n将整个关系式除以 $g$，我们得到一个等价的同余方程：\n$$ i \\cdot s' \\equiv 0 \\pmod{B'} $$\n由于 $s'$ 和 $B'$ 互质（$\\gcd(s', B')=1$），$s'$ 存在模 $B'$ 的乘法逆元。乘以这个逆元，我们发现 $i$ 必须是 $B'$ 的倍数。\n$$ i \\equiv 0 \\pmod{B'} $$\n回想一下 $B' = B/g = B/\\gcd(s, B)$，所以 $i$ 的解是 $B/\\gcd(s, B)$ 的整数倍。\n当且仅当 $i$ 的可能取值集合 $\\{1, 2, \\dots, m-1\\}$ 中至少包含一个 $B/\\gcd(s, B)$ 的倍数时，才会发生冲突。最小的正倍数是 $B/\\gcd(s, B)$ 本身。因此，如果这个最小解在 $i$ 的取值范围内，即：\n$$ \\frac{B}{\\gcd(s, B)} \\le m-1 $$\n则冲突必然发生。这等价于 $m-1 \\ge \\frac{B}{\\gcd(s, B)}$，或 $m > \\frac{B}{\\gcd(s, B)}$（因为 $m$ 是整数）。\n反之，如果 $m \\le \\frac{B}{\\gcd(s, B)}$，那么对于任何 $i \\in \\{1, 2, \\dots, m-1\\}$，我们有 $0  i  m \\le \\frac{B}{\\gcd(s, B)}$。因此，$i$ 不可能是 $\\frac{B}{\\gcd(s, B)}$ 的倍数，也就不会发生冲突。\n步长访问的冲突概率 $P_s$ 为：\n$$ P_s = \\begin{cases} 0  \\text{if } m \\le \\frac{B}{\\gcd(s, B)} \\\\ 1  \\text{if } m > \\frac{B}{\\gcd(s, B)} \\end{cases} $$\n代入 $B = 2^r$，我们得到：\n$$ P_s = \\begin{cases} 0  \\text{if } m \\le \\frac{2^r}{\\gcd(s, 2^r)} \\\\ 1  \\text{if } m > \\frac{2^r}{\\gcd(s, 2^r)} \\end{cases} $$\n\n最后，我们针对给定的参数 $r = 5$、$m = 20$ 和 $s = 6$ 计算这些概率。\nbank 的数量是 $B = 2^r = 2^5 = 32$。\n\n顺序访问（$d=1$）的评估：\n我们将 $m=20$ 与 $B=32$ 进行比较。\n由于 $20 \\le 32$，我们处于 $m \\le B$ 的情况。\n因此，冲突概率为 $P_1 = 0$。\n\n步长访问（$d=s=6$）的评估：\n我们首先计算最大公约数 $g = \\gcd(s, B) = \\gcd(6, 32)$。\n$6$ 的质因数分解是 $2^1 \\cdot 3^1$。\n$32$ 的质因数分解是 $2^5$。\n最大公约数是 $2^{\\min(1,5)} = 2^1 = 2$。所以，$g=2$。\n现在我们计算阈值 $\\frac{B}{g} = \\frac{32}{2} = 16$。\n我们将 $m=20$ 与此阈值进行比较。\n由于 $20 > 16$，我们处于 $m > \\frac{B}{\\gcd(s, B)}$ 的情况。\n因此，冲突概率为 $P_s = 1$。\n\n这两个概率是 $P_1=0$ 和 $P_s=1$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "简单的线性解码方案在特定访问模式下会导致严重的性能问题，正如上一个练习所揭示的。为了解决这一挑战，我们可以设计更智能的解码逻辑。本练习将介绍一种先进的优化技术——使用哈希函数（具体为异或逻辑）来生成存储体索引，旨在打乱地址到存储体的映射关系。你将需要推导这种哈希解码器的布尔逻辑，并定量分析它相比于线性方案在减少冲突方面的巨大优势，从而体会到解码器设计的巧思如何直接转化为系统性能的提升。",
            "id": "3633897",
            "problem": "一个内存子系统采用存储体交错技术，使用 $B=16$ 个相同的存储体来增加并行性。物理地址以大小为 $64$ 字节的缓存行为粒度进行考量，因此用于存储体选择的地址是缓存行索引 $A$，其二进制表示为 $\\{a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0\\}$，其中 $a_0$ 是行索引的最低有效位。在传统的线性交错方案中，存储体索引是 $A$ 的低 $4$ 位。为了减轻结构化访问模式下的存储体冲突，提出了一种替代的存储体哈希解码器，它将存储体索引映射到行字段的两个不相交的 $4$ 位组的按位异或（XOR）运算，具体映射为\n$$\nh_3 h_2 h_1 h_0 = (a_7 a_6 a_5 a_4)\\ \\oplus\\ (a_3 a_2 a_1 a_0),\n$$\n其中 $\\oplus$ 表示按位异或，$h_3$ 是存储体索引的最高有效位。存储体选择信号是由 $h_3 h_2 h_1 h_0$ 驱动的 $4$-to-$16$ 解码器的独热输出。\n\n任务：\n- 仅使用解码器和布尔组合逻辑的定义，根据输入位 $\\{a_7,\\dots,a_0\\}$ 和独热存储体选择输出 $\\{S_0,S_1,\\dots,S_{15}\\}$，指定地址解码器为实现哈希存储体选择必须实现的布尔方程。您的说明应清楚地阐明异或（XOR）网络如何馈入 $4$-to-$16$ 解码器。\n- 考虑一个步长为 $s=16$ 缓存行的流式访问模式，即地址形式为 $A_n = A_0 + n \\cdot s$，其中整数 $n \\ge 0$。将此流的存储体冲突定义为两次连续访问 $A_n$ 和 $A_{n+1}$ 映射到同一存储体的事件。仅从上述定义以及二进制加法和异或的标准属性出发，确定 (i) 线性交错和 (ii) 哈希解码器中连续访问对发生冲突的渐近比例。然后计算哈希解码器相对于线性交错的冲突减少量，定义为这两个比例之差。\n\n将冲突减少量报告为单个实数。不需要单位。不要四舍五入；给出精确值。",
            "solution": "解答按问题陈述的要求分为两部分。首先，我们推导哈希存储体选择解码器的布尔方程。其次，我们分析指定访问模式下线性交错和哈希交错方案的存储体冲突率，并计算相对冲突减少量。\n\n**第一部分：哈希存储体解码器的布尔方程**\n\n系统有 $B=16$ 个内存存储体。存储体选择由一个 $4$ 位存储体索引确定。存储体选择信号是 $4$-to-$16$ 解码器的独热输出 $\\{S_0, S_1, \\dots, S_{15}\\}$。这意味着对于给定的 $4$ 位输入，只有一个输出信号 $S_k$ 被置位（逻辑 $1$），而所有其他信号都未置位（逻辑 $0$）。\n\n该解码器的输入是哈希存储体索引，一个表示为 $h_3 h_2 h_1 h_0$ 的 $4$ 位向量。哈希函数根据 $8$ 位缓存行索引 $A = \\{a_7, a_6, a_5, a_4, a_3, a_2, a_1, a_0\\}$ 定义为两个 $4$ 位字段的按位异或（XOR）：\n$$\nh_3 h_2 h_1 h_0 = (a_7 a_6 a_5 a_4) \\oplus (a_3 a_2 a_1 a_0)\n$$\n这给出了各个哈希位：\n- $h_0 = a_4 \\oplus a_0$\n- $h_1 = a_5 \\oplus a_1$\n- $h_2 = a_6 \\oplus a_2$\n- $h_3 = a_7 \\oplus a_3$\n\n当且仅当输入向量 $h_3 h_2 h_1 h_0$ 的十进制值等于 $k$ 时，$4$-to-$16$ 解码器的输出 $S_k$ 才被置位。设整数 $k$（其中 $0 \\le k \\le 15$）的二进制表示为 $k_3 k_2 k_1 k_0$。$S_k$ 为 $1$ 的条件是输入位与 $k$ 的二进制表示相匹配。即 $h_3=k_3$, $h_2=k_2$, $h_1=k_1$ 和 $h_0=k_0$。这对应于输入变量 $h_3, h_2, h_1, h_0$ 的第 $k$ 个最小项。\n\n输出 $S_k$ 的通用布尔方程可以表示为各项的合取，每个输入位一项：\n$$\nS_k = \\bigwedge_{i=0}^{3} T_i\n$$\n其中项 $T_i$ 代表条件 $h_i = k_i$。这个条件可以用标准布尔逻辑写出。如果 $k_i=1$，条件就是 $h_i$。如果 $k_i=0$，条件是 $\\neg h_i$。\n\n现在，我们代入每个 $h_i$ 的定义：\n- 对于 $i=0$：如果 $k_0=1$，$T_0$ 是 $(a_4 \\oplus a_0)$；如果 $k_0=0$，$T_0$ 是 $\\neg(a_4 \\oplus a_0)$。\n- 对于 $i=1$：如果 $k_1=1$，$T_1$ 是 $(a_5 \\oplus a_1)$；如果 $k_1=0$，$T_1$ 是 $\\neg(a_5 \\oplus a_1)$。\n- 对于 $i=2$：如果 $k_2=1$，$T_2$ 是 $(a_6 \\oplus a_2)$；如果 $k_2=0$，$T_2$ 是 $\\neg(a_6 \\oplus a_2)$。\n- 对于 $i=3$：如果 $k_3=1$，$T_3$ 是 $(a_7 \\oplus a_3)$；如果 $k_3=0$，$T_3$ 是 $\\neg(a_7 \\oplus a_3)$。\n\n异或运算的逻辑非，$\\neg(P \\oplus Q)$，等价于同或（XNOR）运算，当且仅当 $P$ 和 $Q$ 相等时为真。我们将其表示为 $P \\iff Q$。\n\n因此，就地址位 $\\{a_7, \\dots, a_0\\}$ 而言，每个输出信号 $S_k$（其中 $k$ 由 $k_3k_2k_1k_0$ 表示）的完整布尔方程规范是：\n$$\nS_k = \\left[ (a_7 \\oplus a_3)^{k_3} \\right] \\land \\left[ (a_6 \\oplus a_2)^{k_2} \\right] \\land \\left[ (a_5 \\oplus a_1)^{k_1} \\right] \\land \\left[ (a_4 \\oplus a_0)^{k_0} \\right]\n$$\n其中符号 $X^1$ 表示表达式 $X$，$X^0$ 表示表达式 $\\neg X$。\n\n**第二部分：冲突分析与减少**\n\n问题定义了一个步长为 $s=16$ 缓存行的流式访问模式。缓存行索引序列由 $A_n = A_0 + n \\cdot s$ 给出，其中整数 $n \\ge 0$。如果两次连续访问 $A_n$ 和 $A_{n+1}$ 映射到同一个存储体，则发生存储体冲突。我们需要找到这种冲突的渐近比例。\n\n连续地址之间的关系是 $A_{n+1} = A_n + s = A_n + 16$。\n在二进制中，$16$ 是 $10000_2$。存储体选择逻辑使用 $8$ 位索引 $\\{a_7, \\dots, a_0\\}$。让我们分析将 $16$ 加到这个 $8$ 位值上的效果。设 $8$ 位索引 $A$ 分解为一个高 $4$ 位部分 $H = \\{a_7, a_6, a_5, a_4\\}$ 和一个低 $4$ 位部分 $L = \\{a_3, a_2, a_1, a_0\\}$。这使我们可以将 $8$ 位索引的整数值写为 $A_v = 2^4 \\cdot H_v + L_v$，其中 $H_v$ 和 $L_v$ 是 $H$ 和 $L$ 的整数值。\n\n下一个地址索引是 $A_{n+1,v} = (A_{n,v} + 16) \\pmod{2^8}$。\n$A_{n+1,v} = (2^4 \\cdot H_{n,v} + L_{n,v} + 2^4) \\pmod{2^8} = (2^4 \\cdot (H_{n,v} + 1) + L_{n,v}) \\pmod{2^8}$。\n这个加法不影响低 $4$ 位部分。高 $4$ 位部分增加 $1$。\n所以，对于表示这些部分的位向量：\n- $L_{n+1} = L_n$\n- $H_{n+1} = (H_n + 1) \\pmod{16}$ (其中操作是 $4$ 位二进制加法)\n\n**(i) 线性交错**\n\n在传统的线性交错方案中，存储体索引是 $A$ 的低 $4$ 位。\n$A_n$ 的存储体索引：$b_{lin}(A_n) = L_n$。\n$A_{n+1}$ 的存储体索引：$b_{lin}(A_{n+1}) = L_{n+1}$。\n正如我们所确定的，$L_{n+1} = L_n$。\n因此，对于所有 $n \\ge 0$，$b_{lin}(A_n) = b_{lin}(A_{n+1})$。\n这意味着对于给定的步长 $16$，每次连续访问都会访问同一个存储体。每一对连续访问都会发生冲突。\n线性交错的冲突渐近比例是 $f_{lin} = 1$。\n\n**(ii) 哈希解码器**\n\n使用哈希解码器，存储体索引是高位部分和低位部分的按位异或。\n$A_n$ 的存储体索引：$b_{hash}(A_n) = H_n \\oplus L_n$。\n$A_{n+1}$ 的存储体索引：$b_{hash}(A_{n+1}) = H_{n+1} \\oplus L_{n+1} = (H_n + 1) \\oplus L_n$。\n\n如果 $b_{hash}(A_n) = b_{hash}(A_{n+1})$，则发生冲突。\n$$\nH_n \\oplus L_n = (H_n + 1) \\oplus L_n\n$$\n异或运算具有消除性质：如果 $X \\oplus Y = Z \\oplus Y$，那么 $X = Z$。应用这个性质，我们可以用 $L_n$ 对等式两边进行异或运算：\n$$\n(H_n \\oplus L_n) \\oplus L_n = ((H_n + 1) \\oplus L_n) \\oplus L_n\n$$\n$$\nH_n \\oplus (L_n \\oplus L_n) = (H_n + 1) \\oplus (L_n \\oplus L_n)\n$$\n由于 $L_n \\oplus L_n$ 结果为零向量，这可以简化为：\n$$\nH_n = H_n + 1\n$$\n这个方程表明一个 $4$ 位二进制数等于它自己加一。这是一个矛盾，对于任何二进制向量 $H_n$ 都永远不成立。\n因此，对于所有 $n \\ge 0$，$b_{hash}(A_n) \\neq b_{hash}(A_{n+1})$。\n没有连续的访问会映射到同一个存储体。\n哈希解码器的冲突渐近比例是 $f_{hash} = 0$。\n\n**冲突减少**\n\n冲突减少量定义为这两个比例之差：\n$$\n\\text{冲突减少} = f_{lin} - f_{hash} = 1 - 0 = 1\n$$\n对于步长为 $16$ 的流式访问模式，哈希解码器完全消除了存储体冲突。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}