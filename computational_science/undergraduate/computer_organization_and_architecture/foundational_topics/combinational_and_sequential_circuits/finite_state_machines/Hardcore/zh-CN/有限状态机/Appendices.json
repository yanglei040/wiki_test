{
    "hands_on_practices": [
        {
            "introduction": "将抽象的状态图和转换表转化为实际的硬件是设计有限状态机（FSM）的核心步骤。本练习将通过分析一段VHDL代码，帮助你理解一个Mealy型FSM的具体行为，重点关注其如何根据当前状态和输入来产生输出。这是一个从代码反向推导设计意图的基本功训练，对于阅读和理解现有的数字逻辑设计至关重要。",
            "id": "1976119",
            "problem": "请看下面的 VHDL 代码，它描述了一个同步数字电路，该电路具有一个单位输入 `din` 和一个单位输出 `dout`。该电路是一个 Mealy 型有限状态机（FSM）。该 FSM 由时钟信号 `clk` 控制，并可通过 `reset` 信号进行异步复位。\n\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.all;\n\nENTITY sequence_detector IS\n    PORT (\n        clk   : IN  STD_LOGIC;\n        reset : IN  STD_LOGIC;\n        din   : IN  STD_LOGIC;\n        dout  : OUT STD_LOGIC\n    );\nEND ENTITY sequence_detector;\n\nARCHITECTURE behavioral OF sequence_detector IS\n    -- State type declaration\n    TYPE state_type IS (S0, S1);\n    \n    -- State signals\n    SIGNAL current_state, next_state : state_type;\n\nBEGIN\n    -- Process for state register (sequential logic)\n    state_register: PROCESS (clk, reset)\n    BEGIN\n        IF (reset = '1') THEN\n            current_state = S0;\n        ELSIF (rising_edge(clk)) THEN\n            current_state = next_state;\n        END IF;\n    END PROCESS state_register;\n    \n    -- Process for next state logic (combinational logic)\n    next_state_logic: PROCESS (current_state, din)\n    BEGIN\n        CASE current_state IS\n            WHEN S0 =>\n                IF (din = '0') THEN\n                    next_state = S1;\n                ELSE\n                    next_state = S0;\n                END IF;\n                \n            WHEN S1 =>\n                IF (din = '1') THEN\n                    next_state = S0;\n                ELSE\n                    next_state = S1;\n                END IF;\n        END CASE;\n    END PROCESS next_state_logic;\n    \n    -- Output logic (combinational logic for Mealy machine)\n    dout = '1' WHEN (current_state = S1 AND din = '1') ELSE '0';\n\nEND ARCHITECTURE behavioral;\n```\n\n通过分析所提供的 VHDL 代码，确定该 FSM 的具体行为。下列哪个陈述准确描述了导致输出 `dout` 置位（即变为 '1'）的条件？\n\nA. 无论输入 `din` 为何，只要 FSM 处于状态 `S1`，`dout` 就变为 '1'。\n\nB. 当 `reset` 信号被置位时，`dout` 变为 '1'。\n\nC. 在检测到输入序列 '10' 后，`dout` 立即变为 '1'。\n\nD. 在检测到输入序列 '01' 后，`dout` 立即变为 '1'。\n\nE. 在检测到输入序列 '00' 后，`dout` 立即变为 '1'。",
            "solution": "我们通过分离时序状态寄存器、组合下一状态逻辑和 Mealy 输出逻辑来分析该 FSM。\n\n1) 状态寄存器（带异步复位的时序逻辑）：\n复位时，状态被强制为 $S0$。在每个 $clk$ 的上升沿，状态更新为 $next\\_state$：\n- 如果 $reset=1$，则 $current\\_state \\leftarrow S0$。\n- 否则，在 $rising\\_edge(clk)$ 上，$current\\_state \\leftarrow next\\_state$。\n\n2) 下一状态逻辑（组合逻辑）：\n从代码中可知：\n- 当 $current\\_state=S0$ 时：如果 $din=0$ 则 $next\\_state=S1$，否则 $next\\_state=S0$。\n- 当 $current\\_state=S1$ 时：如果 $din=1$ 则 $next\\_state=S0$，否则 $next\\_state=S1$。\n\n通过仔细观察，可以发现下一状态仅取决于当前输入 `din`，而与当前状态无关。具体来说，当 `din='0'` 时，下一个状态是 `S1`；当 `din='1'` 时，下一个状态是 `S0`。这在代码中对两个状态 `S0` 和 `S1` 的 `case` 分支中都成立。因此，我们可以简化状态转换逻辑。\n\n3) 输出逻辑（Mealy 型）：\n从代码中可知，\n$$\ndout=1 \\;\\;\\text{iff}\\;\\; (current\\_state=S1) \\land (din=1),\n$$\n否则 $dout=0$。\n\n4) 综合分析：\n为了让 $dout$ 在时间点 $n$ 变为 '1'，必须满足两个条件：\n- `current_state` 在时间点 $n$ 是 `S1`。\n- `din` 在时间点 $n$ 是 '1'。\n\n`current_state` 在时间点 $n$ 的值是在前一个时钟沿（时间点 $n-1$）确定的，其值等于 `next_state` 在时间点 $n-1$ 的值。\n根据下一状态逻辑，要使 `current_state` 在时间点 $n$ 成为 `S1`，那么 `next_state` 在时间点 $n-1$ 必须是 `S1`。这要求 `din` 在时间点 $n-1$ 是 '0'。\n\n所以，要使 `dout[n] = 1`：\n- `din[n-1]` 必须是 '0'（这使得 `current_state[n]` 成为 `S1`）。\n- `din[n]` 必须是 '1'（这是 `dout` 输出为 '1' 的直接条件）。\n\n这两个条件合在一起意味着 FSM 检测到了输入序列 '01'。\n\n5) 评估选项：\n- A 是错误的，因为还需要 `din='1'`。\n- B 是错误的，`dout` 不依赖于 `reset`。\n- C 是错误的，序列 '10' 会使 FSM 最终处于 `S1` 状态，但输出 `dout` 会是 '0'。\n- D 是正确的：输入序列 '01' 满足 `din[n-1]='0'` 和 `din[n]='1'`，从而使 `dout` 置位。\n- E 是错误的，序列 '00' 不满足 `din[n]='1'` 的条件。\n\n因此，正确选项是 D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "虽然有限状态机本质上是同步的，但在实际系统中，它们必须与复位等异步信号进行交互。本练习探讨了当异步信号的时序不满足触发器要求（如复位恢复时间）时可能出现的关键问题。通过这个场景，你将深入理解亚稳态的概念，这是数字系统设计中一个必须谨慎处理的现实挑战。",
            "id": "1910785",
            "problem": "一个有限状态机（FSM）被设计用于控制一个高速数据采样过程。该 FSM 有三个状态：`IDLE`（状态 `00`）、`SAMPLING`（状态 `01`）和 `PROCESSING`（状态 `10`）。状态转换与系统时钟 `clk` 的上升沿同步。该设计包含一个低电平有效的异步复位输入 `areset_n`，其目的是在 `areset_n` 为低电平时，无论时钟活动如何，都将 FSM 强制置于 `IDLE` 状态。\n\n用于实现状态寄存器的触发器具有一个指定的*复位恢复时间*。这是 `areset_n` 信号在 `clk` 的下一个上升沿到来之前，必须在其非活动（高）状态下保持稳定的最短时间，以确保可预测的行为。\n\n在操作过程中，一个瞬态毛刺导致 `areset_n` 信号被置为有效（变为低电平），然后又被撤销（变为高电平）。`areset_n` 的撤销发生在一个违反了状态寄存器触发器的复位恢复时间规范的时刻。下列哪个陈述最准确地描述了在这种时序违规期间发生的时钟上升沿之后，FSM 状态可能出现的行为？\n\nA. FSM 将可靠地转换到 `SAMPLING` 状态，因为当启动条件满足时，这是从 `IDLE` 状态预期的下一个状态。\n\nB. FSM 将可靠地保持在 `IDLE` 状态，因为复位信号在时钟沿之前刚刚有效。\n\nC. FSM 的状态寄存器可能会进入亚稳态，其输出在短时间内不可预测，可能导致 FSM 转换到一个无效或非预期的状态。\n\nD. FSM 的内部时钟门控逻辑将被触发，阻止任何状态变化，直到下一个有效的复位脉冲到来。\n\nE. 由于时序违规引起的内部竞争，FSM 将遭受永久性物理损坏，需要通过电源重启来恢复。",
            "solution": "将低电平有效的异步复位定义为 $areset\\_n$，并将触发器的复位恢复时间表示为 $t_{rec}$。根据规范，$areset\\_n$ 必须在 `clk` 的下一个上升沿到来之前，保持高电平且稳定至少 $t_{rec}$ 的时间，以保证对状态寄存器的可预测采样。\n\n设 $areset\\_n$ 的撤销（从低到高的转换）发生在时间 $t_{d}$，`clk` 的下一个上升沿发生在时间 $t_{c}$。恢复时间的要求是\n$$\nt_{c} - t_{d} \\geq t_{rec}.\n$$\n违规对应于\n$$\nt_{c} - t_{d}  t_{rec}.\n$$\n当此不等式成立时，复位输入在 $t_{c}$ 时刻的采样事件发生前，其非活动状态的持续时间不足以让触发器的内部节点达到一个有效的稳定区域。这类似于违反数据输入的建立/保持时间：触发器可能会进入亚稳态。在亚稳态下，输出 $Q$ 可以在一个不确定的电压上保持一段有限的解析时间，然后不可预测地解析到任一逻辑电平。对于一个多位状态寄存器，不同的位可能会有不同的解析结果，可能产生一个无效的状态编码或一个非预期的合法状态。\n\n在这种行为下评估各个选项：\n- 选项 A 要求朝向预期下一状态的确定性行为；在恢复时间违规的情况下，这一点无法保证。\n- 选项 B 假设复位将在采样沿可靠地强制或保持状态在 $IDLE$；恢复时间违规消除了这一保证，允许亚稳态或非预期的解析。\n- 选项 C 正确地指出，状态寄存器可能会变得亚稳，输出不可预测，并可能转换到一个无效或非预期的状态。\n- 选项 D 引入了设计中未指定的时钟门控；异步复位本身不会触发时钟门控来阻止状态变化。\n- 选项 E 断言会发生永久性物理损坏；亚稳态是一种瞬态逻辑现象，并不意味着硬件损坏。\n\n因此，最准确的描述是选项 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "一个设计良好的有限状态机不仅要能正确执行其预定功能，还必须足够健壮，能够从意外的错误中恢复。本练习模拟了一个高风险应用场景，要求你验证FSM的安全恢复机制。你将分析一个测试平台如何通过强制FSM进入非法状态来检验其是否能可靠地返回到安全状态，这体现了现代数字系统验证中的重要思想。",
            "id": "1966464",
            "problem": "您的任务是验证一台有限状态机 (FSM) 的安全特性，该 FSM 用于控制高功率工业激光器的点火序列。该系统设计为带有同步高电平有效复位的摩尔型 FSM。\n\n**FSM 规范：**\n-   **输入**：`clk`、`reset`、`arm`（1位）、`fire`（1位）。\n-   **输出**：`laser_enable`（1位）。\n-   **状态寄存器**：一个名为 `state_reg` 的2位寄存器。\n-   **状态与编码**：\n    -   `S_OFF`：2'b00（指定的安全/复位状态）。\n    -   `S_ARMED`：2'b01\n    -   `S_FIRING`：2'b10\n    -   编码 2'b11 是一个未使用的非法状态。\n-   **输出逻辑**：\n    -   当且仅当 FSM 处于 `S_FIRING` 状态时，`laser_enable` 为 1。否则，`laser_enable` 为 0。\n-   **状态转换**：转换发生在 `clk` 的上升沿。\n    1.  如果 `reset` 为高电平，下一个状态是 `S_OFF`。\n    2.  从 `S_OFF` 状态：如果 `arm` 为高电平，下一个状态是 `S_ARMED`。否则，状态保持为 `S_OFF`。\n    3.  从 `S_ARMED` 状态：如果 `arm` 为低电平，下一个状态是 `S_OFF`（一个安全互锁）。如果 `arm` 和 `fire` 均为高电平，下一个状态是 `S_FIRING`。否则，状态保持为 `S_ARMED`。\n    4.  从 `S_FIRING` 状态：下一个状态无条件地变为 `S_OFF`（激光器发射一个单周期脉冲）。\n    5.  **安全恢复**：如果 `state_reg` 曾持有非法值 2'b11，则 FSM 必须在下一个时钟上升沿转换到 `S_OFF` 状态，无论 `arm` 和 `fire` 输入如何。\n\n**测试平台场景：**\n一个测试平台用周期为 10 ns 的时钟 (`clk`) 模拟该 FSM。时钟的第一个上升沿出现在 t = 10 ns。施加以下激励：\n-   从 t = 0 ns 到 t = 15 ns，`reset` 保持高电平。在 t = 15 ns，`reset` 被撤销为 0。\n-   在 t = 25 ns，`arm` 被置为高电平。\n-   在 t = 35 ns，`fire` 被置为高电平。`arm` 保持高电平。\n-   在 t = 42 ns，执行一个模拟器 `force` 命令，该命令瞬间强制将 `state_reg` 的值设置为非法编码 2'b11。此命令在该时刻覆盖了寄存器的正常同步行为。\n-   在 t = 45 ns，`arm` 和 `fire` 都被撤销为 0。\n\n**问题：**\n根据 FSM 规范和测试平台场景，确定输出 `laser_enable` 在 t = 41 ns、t = 43 ns 和 t = 51 ns 这几个特定仿真时间点的值序列。\n\n从以下选项中选择正确的序列。\n\nA. (1, 0, 0)\n\nB. (1, 1, 0)\n\nC. (0, 0, 0)\n\nD. (1, 0, 1)\n\nE. (1, 1, 1)",
            "solution": "我们对这个带有同步高电平有效复位和上升沿状态更新的摩尔型 FSM 进行建模。输出规则是：当且仅当 $state\\_reg=S\\_{\\mathrm{FIRING}}$ 时，$laser\\_enable=1$；否则 $laser\\_enable=0$。时钟上升沿出现在 $t=10\\,\\text{ns}, 20\\,\\text{ns}, 30\\,\\text{ns}, 40\\,\\text{ns}, 50\\,\\text{ns}, \\ldots$。\n\n复位行为：\n- 从 $t=0\\,\\text{ns}$ 到 $t=15\\,\\text{ns}$，$reset=1$。在第一个上升沿 $t=10\\,\\text{ns}$ 时，同步复位强制 $state\\_reg \\leftarrow S\\_{\\mathrm{OFF}}$。\n- 在 $t=20\\,\\text{ns}$ 时，$reset=0$，因此应用正常的状态转换逻辑。\n\n每个时钟沿之前的输入激励：\n- $arm$ 在 $t=25\\,\\text{ns}$ 时变为高电平，并保持至 $t=45\\,\\text{ns}$。\n- $fire$ 在 $t=35\\,\\text{ns}$ 时变为高电平，并保持至 $t=45\\,\\text{ns}$。\n\n逐个分析上升沿：\n1) 在 $t=10\\,\\text{ns}$ 时：$reset=1 \\Rightarrow$ 该时钟沿过后，$state\\_reg=S\\_{\\mathrm{OFF}}$。\n2) 在 $t=20\\,\\text{ns}$ 时：$reset=0$，$state\\_reg=S\\_{\\mathrm{OFF}}$，$arm=0 \\Rightarrow$ 保持在 $S\\_{\\mathrm{OFF}}$ 状态。\n3) 在 $t=30\\,\\text{ns}$ 时：$arm=1 \\Rightarrow S\\_{\\mathrm{OFF}} \\to S\\_{\\mathrm{ARMED}}$。\n4) 在 $t=40\\,\\text{ns}$ 时：$arm=1$ 且 $fire=1 \\Rightarrow S\\_{\\mathrm{ARMED}} \\to S\\_{\\mathrm{FIRING}}$。根据摩尔型输出逻辑，在此上升沿之后直到任何后续变化发生之前，$laser\\_enable=1$。\n\n强制非法状态与安全恢复：\n- 在 $t=42\\,\\text{ns}$ 时，一个 `force` 命令将 $state\\_reg$ 设为 $2'b11$（非法）。由于当且仅当 $state\\_reg=S\\_{\\mathrm{FIRING}}$ 时 $laser\\_enable=1$，而 $2'b11 \\neq S\\_{\\mathrm{FIRING}}$，因此从那一刻起直到下一次状态更新，输出变为 $0$。\n- 在 $t=50\\,\\text{ns}$（下一个上升沿），安全规则生效：如果 $state\\_reg$ 在时钟沿处为非法状态，则 $state\\_reg \\to S\\_{\\mathrm{OFF}}$，无论 $arm$ 和 `fire` 输入如何。因此，在 $t=50\\,\\text{ns}$ 之后，$state\\_reg=S\\_{\\mathrm{OFF}}$ 且 $laser\\_enable=0$。\n\n在请求的时间点进行评估：\n- 在 $t=41\\,\\text{ns}$ 时：在 $t=40\\,\\text{ns}$ 的时钟沿之后、`force` 命令之前，$state\\_reg=S\\_{\\mathrm{FIRING}} \\Rightarrow laser\\_enable=1$。\n- 在 $t=43\\,\\text{ns}$ 时：在 $t=42\\,\\text{ns}$ 的 `force` 命令之后，$state\\_reg=2'b11$（非法）$\\Rightarrow laser\\_enable=0$。\n- 在 $t=51\\,\\text{ns}$ 时：在 $t=50\\,\\text{ns}$ 的时钟沿之后，由于安全恢复机制，$state\\_reg=S\\_{\\mathrm{OFF}} \\Rightarrow laser\\_enable=0$。\n\n因此，序列为 $(1, 0, 0)$，对应选项 A。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}