{
    "hands_on_practices": [
        {
            "introduction": "将有限状态机（FSM）的理论知识付诸实践，第一步是理解其在硬件描述语言（HDL）中的具体实现。本练习将引导你分析一段给定的VHDL代码，通过解读状态转移和输出逻辑，来精确推断一个Mealy型状态机的功能。掌握这项技能是理解、设计和调试数字电路系统的基础。 ",
            "id": "1976119",
            "problem": "考虑以下 VHDL 代码，它描述了一个同步数字电路，该电路具有一个单位输入 `din` 和一个单位输出 `dout`。该电路是一个 Mealy 型有限状态机 (FSM)。该 FSM 由时钟信号 `clk` 控制，并可通过 `reset` 信号进行异步复位。\n\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.all;\n\nENTITY sequence_detector IS\n    PORT (\n        clk   : IN  STD_LOGIC;\n        reset : IN  STD_LOGIC;\n        din   : IN  STD_LOGIC;\n        dout  : OUT STD_LOGIC\n    );\nEND ENTITY sequence_detector;\n\nARCHITECTURE behavioral OF sequence_detector IS\n    -- State type declaration\n    TYPE state_type IS (S0, S1);\n    \n    -- State signals\n    SIGNAL current_state, next_state : state_type;\n\nBEGIN\n    -- Process for state register (sequential logic)\n    state_register: PROCESS (clk, reset)\n    BEGIN\n        IF (reset = '1') THEN\n            current_state = S0;\n        ELSIF (rising_edge(clk)) THEN\n            current_state = next_state;\n        END IF;\n    END PROCESS state_register;\n    \n    -- Process for next state logic (combinational logic)\n    next_state_logic: PROCESS (current_state, din)\n    BEGIN\n        CASE current_state IS\n            WHEN S0 =>\n                IF (din = '0') THEN\n                    next_state = S1;\n                ELSE\n                    next_state = S0;\n                END IF;\n                \n            WHEN S1 =>\n                IF (din = '1') THEN\n                    next_state = S0;\n                ELSE\n                    next_state = S1;\n                END IF;\n        END CASE;\n    END PROCESS next_state_logic;\n    \n    -- Output logic (combinational logic for Mealy machine)\n    dout = '1' WHEN (current_state = S1 AND din = '1') ELSE '0';\n\nEND ARCHITECTURE behavioral;\n```\n\n通过分析所提供的 VHDL 代码，确定该 FSM 的具体行为。以下哪个陈述准确地描述了导致输出 `dout` 被置为有效（即变为 '1'）的条件？\n\nA. 无论输入 `din` 为何，只要 FSM 处于状态 `S1`，`dout` 就变为 '1'。\n\nB. 当 `reset` 信号被置为有效时，`dout` 变为 '1'。\n\nC. 在检测到输入序列 '10' 后，`dout` 立即变为 '1'。\n\nD. 在检测到输入序列 '01' 后，`dout` 立即变为 '1'。\n\nE. 在检测到输入序列 '00' 后，`dout` 立即变为 '1'。",
            "solution": "我们通过将时序状态寄存器、组合次态逻辑和 Mealy 输出逻辑分开来分析该 FSM。\n\n1) 状态寄存器（带异步复位的时序逻辑）：\n复位时，状态被强制为 $S0$。在每个 `clk` 的上升沿，状态更新为 `next_state`：\n- 如果 $reset=1$，则 $\\text{current\\_state} \\leftarrow S0$。\n- 否则在 $\\text{rising\\_edge}(\\text{clk})$ 时， $\\text{current\\_state} \\leftarrow \\text{next\\_state}$。\n\n2) 次态逻辑（组合逻辑）：\n根据代码：\n- 当 $\\text{current\\_state}=S0$ 时：如果 $din=0$，则 $\\text{next\\_state}=S1$，否则 $\\text{next\\_state}=S0$。\n- 当 $\\text{current\\_state}=S1$ 时：如果 $din=1$，则 $\\text{next\\_state}=S0$，否则 $\\text{next\\_state}=S1$。\n\n这可以简化为一个仅关于 `din` 的函数：\n$$\n\\text{next\\_state}=\\begin{cases}\nS1,  \\text{if } din=0\\\\\nS0,  \\text{if } din=1\n\\end{cases}\n$$\n因此，在时钟索引 $n$ 处，寄存的状态等于前一个输入的函数：\n$$\n\\text{current\\_state}[n]=\\text{next\\_state}[n-1]=\n\\begin{cases}\nS1,  \\text{if } din[n-1]=0\\\\\nS0,  \\text{if } din[n-1]=1\n\\end{cases}\n$$\n\n3) 输出逻辑 (Mealy)：\n根据代码，\n$$\n\\text{dout}=1 \\;\\;\\text{iff}\\;\\; (\\text{current\\_state}=S1) \\land (din=1),\n$$\n否则 $\\text{dout}=0$。使用上面关于 $\\text{current\\_state}$ 的关系，在时间 $n$ 时，这变成\n$$\n\\text{dout}[n]=1 \\iff \\big(din[n-1]=0\\big)\\land\\big(din[n]=1\\big).\n$$\n因此，当且仅当输入在连续采样之间发生从 $0$ 到 $1$ 的转变时，输出才被置为有效，即在立即检测到序列 `01` 时。\n\n4) 评估选项：\n- A 是错误的，因为还需要 $din=1$。\n- B 是错误的，因为 `dout` 不依赖于 `reset`。\n- C 是错误的（那将需要 $(\\text{current\\_state}=S0)\\land(din=0)$）。\n- D 是正确的：立即检测到 `01` 会使 `dout` 置为有效。\n- E 是错误的，因为 $din=0$ 会使 $\\text{dout}=0$。\n\n因此，正确选项是 D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "理想的数字逻辑模型非常简洁，但真实世界的电路必须遵循严格的物理时序约束。本练习将探讨一个关键的实际问题：异步复位的恢复时间（recovery time）违例。你将分析这种时序违例如何导致亚稳态（metastability）这一危险现象，这是任何高可靠性FSM设计都必须考虑的核心因素。 ",
            "id": "1910785",
            "problem": "一个有限状态机 (FSM) 被设计用于控制一个高速数据采样过程。该 FSM 有三个状态：`IDLE` (状态 `00`)、`SAMPLING` (状态 `01`) 和 `PROCESSING` (状态 `10`)。状态转换与系统时钟 `clk` 的上升沿同步。该设计包含一个低电平有效异步复位输入 `areset_n`，其作用是在 `areset_n` 为低电平时，无论时钟活动如何，都将 FSM 强制置于 `IDLE` 状态。\n\n用于实现状态寄存器的触发器具有一个指定的*复位恢复时间* (reset recovery time)。这是指 `areset_n` 信号在 `clk` 的下一个上升沿到来之前，必须在其非活动（高）状态下保持稳定的最短时间，以确保可预测的行为。\n\n在操作过程中，一个瞬态毛刺导致 `areset_n` 信号被置为有效（变为低电平），然后被撤销（变为高电平）。`areset_n` 的撤销发生在一个违反了状态寄存器触发器的复位恢复时间规范的时刻。以下哪项陈述最准确地描述了在这种时序违规期间发生的时钟上升沿之后，FSM 状态的可能行为？\n\nA. FSM 将可靠地转换到 `SAMPLING` 状态，因为当满足启动条件时，这是从 `IDLE` 状态预期的下一个状态。\n\nB. FSM 将可靠地保持在 `IDLE` 状态，因为复位信号在时钟沿之前刚刚有效。\n\nC. FSM 的状态寄存器可能会进入亚稳态，其输出在短时间内变得不可预测，可能导致 FSM 转换到一个无效或非预期的状态。\n\nD. FSM 的内部时钟门控逻辑将被触发，从而阻止任何状态改变，直到下一个有效的复位脉冲到来。\n\nE. FSM 将因时序违规引起的内部竞争而遭受永久性物理损坏，需要通过电源重启来恢复。",
            "solution": "将低电平有效的异步复位定义为 $\\text{areset\\_n}$，并将触发器的复位恢复时间表示为 $t_{\\text{rec}}$。根据规范，$\\text{areset\\_n}$ 在 `clk` 的下一个上升沿到来之前，必须保持高电平稳定至少 $t_{\\text{rec}}$ 的时间，以保证状态寄存器的可预测采样。\n\n设 $\\text{areset\\_n}$ 的撤销（从低到高的转换）发生在时间 $t_{d}$，`clk` 的下一个上升沿发生在时间 $t_{c}$。恢复时间的要求是\n$$\nt_{c} - t_{d} \\geq t_{\\text{rec}}.\n$$\n违规对应于\n$$\nt_{c} - t_{d}  t_{\\text{rec}}.\n$$\n当此不等式成立时，复位输入在 $t_{c}$ 的采样事件发生之前，其处于非活动状态的时间不够长，无法使触发器的内部节点达到一个有效的稳定区域。这类似于违反了数据输入的建立/保持时间：触发器可能会进入亚稳态。在亚稳态下，输出 $Q$ 可以在一个不确定的电压上保持一段有限的判决时间，然后不可预测地稳定到任一逻辑电平。对于一个多比特的状态寄存器，不同的比特可能会以不同的方式判决，可能产生一个无效的状态编码或一个非预期的合法状态。\n\n根据这种行为评估各个选项：\n- 选项 A 要求向预期的下一状态确定性地转换；在恢复时间违规的情况下，这一点无法保证。\n- 选项 B 假设复位将在采样沿可靠地强制或保持状态在 `IDLE`；恢复时间违规消除了这一保证，可能导致亚稳态或非预期的判决。\n- 选项 C 正确地指出，状态寄存器可能会进入亚稳态，其输出不可预测，并可能转换到一个无效或非预期的状态。\n- 选项 D 引入了设计中未指定的时钟门控；异步复位本身不会触发时钟门控来阻止状态改变。\n- 选项 E 声称会发生永久性物理损坏；亚稳态是一种瞬态逻辑现象，并不意味着硬件损坏。\n\n因此，最准确的描述是选项 C。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "一个设计精良的有限状态机不仅要能正确执行预定功能，还应能在意外发生时（例如进入一个非法状态）安全地恢复。本练习将模拟一个这样的故障注入场景，考验状态机是否具备关键的安全恢复机制。这是数字系统验证中的一个核心环节，确保了系统在真实复杂环境下的鲁棒性。 ",
            "id": "1966464",
            "problem": "您的任务是验证一个有限状态机（FSM）的安全特性，该状态机用于控制高功率工业激光器的发射序列。该系统设计为一个带有同步高电平有效复位的 Moore 型 FSM。\n\n**FSM 规范：**\n-   **输入**：`clk`、`reset`、`arm`（1 位）、`fire`（1 位）。\n-   **输出**：`laser_enable`（1 位）。\n-   **状态寄存器**：一个名为 `state_reg` 的 2 位寄存器。\n-   **状态与编码**：\n    -   `S_OFF`：2'b00（指定的安全/复位状态）。\n    -   `S_ARMED`：2'b01\n    -   `S_FIRING`：2'b10\n    -   编码 2'b11 是一个未使用的非法状态。\n-   **输出逻辑**：\n    -   `laser_enable` 为 1 当且仅当 FSM 处于 `S_FIRING` 状态。否则，`laser_enable` 为 0。\n-   **状态转换**：状态转换发生在 `clk` 的上升沿。\n    1.  如果 `reset` 为高电平，下一个状态是 `S_OFF`。\n    2.  从 `S_OFF`：如果 `arm` 为高电平，下一个状态是 `S_ARMED`。否则，状态保持在 `S_OFF`。\n    3.  从 `S_ARMED`：如果 `arm` 为低电平，下一个状态是 `S_OFF`（一个安全互锁）。如果 `arm` 为高电平且 `fire` 为高电平，下一个状态是 `S_FIRING`。否则，状态保持在 `S_ARMED`。\n    4.  从 `S_FIRING`：下一个状态无条件地是 `S_OFF`（激光器发射一个单周期脉冲）。\n    5.  **安全恢复**：如果 `state_reg` 在任何时候保持非法值 2'b11，FSM 必须在下一个时钟上升沿转换到 `S_OFF`，无论 `arm` 和 `fire` 输入如何。\n\n**测试平台场景：**\n一个测试平台模拟该 FSM，其时钟（`clk`）周期为 10 ns。时钟的第一个上升沿出现在 t = 10 ns。施加以下激励：\n-   从 t = 0 ns 到 t = 15 ns，`reset` 保持为高电平。在 t = 15 ns，`reset` 被撤销为 0。\n-   在 t = 25 ns，`arm` 被置为高电平。\n-   在 t = 35 ns，`fire` 被置为高电平。`arm` 保持高电平。\n-   在 t = 42 ns，执行了一个模拟器的 `force` 命令，该命令瞬时地将 `state_reg` 的值强制设置为非法编码 2'b11。此命令在该时刻覆盖了寄存器的正常同步行为。\n-   在 t = 45 ns，`arm` 和 `fire` 都被撤销为 0。\n\n**问题：**\n根据 FSM 规范和测试平台场景，确定输出 `laser_enable` 在 t = 41 ns、t = 43 ns 和 t = 51 ns 这几个特定仿真时间点的值序列。\n\n从以下选项中选择正确的序列。\n\nA. (1, 0, 0)\n\nB. (1, 1, 0)\n\nC. (0, 0, 0)\n\nD. (1, 0, 1)\n\nE. (1, 1, 1)",
            "solution": "我们对这个具有同步高电平有效复位和上升沿状态更新的 Moore 型 FSM 进行建模。输出规则是：$\\text{laser\\_enable}=1$ 当且仅当 $\\text{state\\_reg}=S_{\\mathrm{FIRING}}$；否则 $\\text{laser\\_enable}=0$。时钟上升沿出现在 $t=10\\,\\text{ns}, 20\\,\\text{ns}, 30\\,\\text{ns}, 40\\,\\text{ns}, 50\\,\\text{ns}, \\ldots$。\n\n复位行为：\n- 从 $t=0\\,\\text{ns}$ 到 $t=15\\,\\text{ns}$，$reset=1$。在第一个上升沿 $t=10\\,\\text{ns}$ 时，同步复位将 $\\text{state\\_reg}$ 强制设置为 $S_{\\mathrm{OFF}}$。\n- 在 $t=20\\,\\text{ns}$ 时，$reset=0$，因此应用正常的状态转换逻辑。\n\n每个时钟沿之前的输入激励：\n- `arm` 在 $t=25\\,\\text{ns}$ 时变为高电平，并保持高电平直到 $t=45\\,\\text{ns}$。\n- `fire` 在 $t=35\\,\\text{ns}$ 时变为高电平，并保持高电平直到 $t=45\\,\\text{ns}$。\n\n逐个分析上升沿：\n1) 在 $t=10\\,\\text{ns}$：$reset=1 \\Rightarrow$ 该时钟沿之后 $\\text{state\\_reg}=S_{\\mathrm{OFF}}$。\n2) 在 $t=20\\,\\text{ns}$：$reset=0$，$state\\_reg=S_{\\mathrm{OFF}}$，$arm=0 \\Rightarrow$ 保持在 $S_{\\mathrm{OFF}}$ 状态。\n3) 在 $t=30\\,\\text{ns}$：$arm=1 \\Rightarrow S_{\\mathrm{OFF}} \\to S_{\\mathrm{ARMED}}$。\n4) 在 $t=40\\,\\text{ns}$：$arm=1$ 且 $fire=1 \\Rightarrow S_{\\mathrm{ARMED}} \\to S_{\\mathrm{FIRING}}$。根据 Moore 型输出逻辑，紧随此时钟沿之后直到任何后续变化发生前，$\\text{laser\\_enable}=1$。\n\n强制非法状态与安全恢复：\n- 在 $t=42\\,\\text{ns}$，一个 `force` 命令将 $\\text{state\\_reg}$ 设置为 $2'b11$（非法）。由于 $\\text{laser\\_enable}=1$ 当且仅当 $\\text{state\\_reg}=S_{\\mathrm{FIRING}}$，并且 $2'b11 \\neq S_{\\mathrm{FIRING}}$，所以从那一刻起直到下一次状态更新，输出变为 $0$。\n- 在 $t=50\\,\\text{ns}$（下一个上升沿），安全规则生效：如果时钟沿到来时 $\\text{state\\_reg}$ 是非法的，那么 $\\text{state\\_reg} \\to S_{\\mathrm{OFF}}$，无论 `arm` 和 `fire` 的值如何。因此，在 $t=50\\,\\text{ns}$ 之后，$\\text{state\\_reg}=S_{\\mathrm{OFF}}$ 且 $\\text{laser\\_enable}=0$。\n\n在所要求的时间点进行评估：\n- 在 $t=41\\,\\text{ns}$：在 $t=40\\,\\text{ns}$ 的时钟沿之后、`force` 命令执行之前，$\\text{state\\_reg}=S_{\\mathrm{FIRING}} \\Rightarrow \\text{laser\\_enable}=1$。\n- 在 $t=43\\,\\text{ns}$：在 $t=42\\,\\text{ns}$ 的 `force` 命令执行之后，$\\text{state\\_reg}=2'b11$（非法）$\\Rightarrow \\text{laser\\_enable}=0$。\n- 在 $t=51\\,\\text{ns}$：在 $t=50\\,\\text{ns}$ 的时钟沿之后，通过安全恢复机制，$\\text{state\\_reg}=S_{\\mathrm{OFF}} \\Rightarrow \\text{laser\\_enable}=0$。\n\n因此，序列为 $(1, 0, 0)$，对应选项 A。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}