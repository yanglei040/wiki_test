{
    "hands_on_practices": [
        {
            "introduction": "This practice focuses on a core skill: analyzing a finite state machine's implementation to determine its behavior. By examining the provided VHDL code, which describes a Mealy FSM, you will learn to dissect the next-state logic and output logic to deduce the specific input sequence the machine is designed to detect . This exercise bridges the gap between an abstract state diagram and its concrete realization in a hardware description language.",
            "id": "1976119",
            "problem": "Consider the following VHDL code which describes a synchronous digital circuit with a single bit input `din` and a single bit output `dout`. The circuit is a Mealy-type Finite State Machine (FSM). The FSM is controlled by a clock signal `clk` and can be reset asynchronously via the `reset` signal.\n\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.all;\n\nENTITY sequence_detector IS\n    PORT (\n        clk   : IN  STD_LOGIC;\n        reset : IN  STD_LOGIC;\n        din   : IN  STD_LOGIC;\n        dout  : OUT STD_LOGIC\n    );\nEND ENTITY sequence_detector;\n\nARCHITECTURE behavioral OF sequence_detector IS\n    -- State type declaration\n    TYPE state_type IS (S0, S1);\n    \n    -- State signals\n    SIGNAL current_state, next_state : state_type;\n\nBEGIN\n    -- Process for state register (sequential logic)\n    state_register: PROCESS (clk, reset)\n    BEGIN\n        IF (reset = '1') THEN\n            current_state <= S0;\n        ELSIF (rising_edge(clk)) THEN\n            current_state <= next_state;\n        END IF;\n    END PROCESS state_register;\n    \n    -- Process for next state logic (combinational logic)\n    next_state_logic: PROCESS (current_state, din)\n    BEGIN\n        CASE current_state IS\n            WHEN S0 =>\n                IF (din = '0') THEN\n                    next_state <= S1;\n                ELSE\n                    next_state <= S0;\n                END IF;\n                \n            WHEN S1 =>\n                IF (din = '1') THEN\n                    next_state <= S0;\n                ELSE\n                    next_state <= S1;\n                END IF;\n        END CASE;\n    END PROCESS next_state_logic;\n    \n    -- Output logic (combinational logic for Mealy machine)\n    dout <= '1' WHEN (current_state = S1 AND din = '1') ELSE '0';\n\nEND ARCHITECTURE behavioral;\n```\n\nBy analyzing the provided VHDL code, determine the specific behavior of the FSM. Which of the following statements accurately describes the condition that causes the output `dout` to be asserted (i.e., become '1')?\n\nA. `dout` becomes '1' whenever the FSM is in state `S1`, regardless of the input `din`.\n\nB. `dout` becomes '1' when the `reset` signal is asserted.\n\nC. `dout` becomes '1' immediately upon the detection of the input sequence '10'.\n\nD. `dout` becomes '1' immediately upon the detection of the input sequence '01'.\n\nE. `dout` becomes '1' immediately upon the detection of the input sequence '00'.",
            "solution": "We analyze the FSM by breaking down its three components: state transitions, output logic, and how they combine.\n\n1.  **Analyze the State Transitions:** We examine the next-state logic from the VHDL `CASE` statement.\n    *   When `current_state = S0`: If `din = '0'`, the next state becomes `S1`. If `din = '1'`, it remains `S0`. This means the FSM enters state `S1` only upon receiving a '0'.\n    *   When `current_state = S1`: If `din = '0'`, it remains in `S1`. If `din = '1'`, it transitions back to `S0`. This means the FSM stays in `S1` as long as it sees '0's and leaves `S1` when it sees a '1'.\n\n2.  **Analyze the Output Logic:** The machine is a Mealy type. The output logic is `dout = '1' WHEN (current_state = S1 AND din = '1') ELSE '0'`. The output is asserted high if and only if two conditions are met simultaneously: the FSM is currently in state `S1`, and the current input `din` is '1'.\n\n3.  **Combine Logic to Find the Sequence:** For `dout` to be '1', the FSM must first be in state `S1`. As determined from the state transitions, this happens on the cycle after the input is '0'. Then, on the current cycle, with the FSM now in state `S1`, the input must be '1' to trigger the output. This corresponds to the input sequence '0' followed immediately by '1'.\n\n4.  **Evaluation of Options:**\n    *   A is false: `dout` is not '1' just for being in `S1`; `din` must also be '1'.\n    *   B is false: The output `dout` has no dependency on `reset`.\n    *   C is false: The sequence '10' would transition from S0 to S0, then S0 to S1. No output would be generated.\n    *   D is true: The sequence '01' transitions the FSM from S0 to S1 on the '0', and then on the '1' input (with the state now being S1), it asserts the output `dout`.\n    *   E is false: After the sequence '00', the FSM would be in state S1, but since the final input is `din = '0'`, the output condition is not met.\n\nTherefore, the FSM asserts `dout` upon detection of the sequence '01'. The correct choice is D.",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "Finite state machines operate in the physical world, where timing is critical. This problem moves beyond pure logic to explore the practical challenges of asynchronous inputs, a common source of failure in digital systems . By analyzing the effects of an asynchronous reset signal that violates its timing specification, you will gain a crucial understanding of metastability, a temporary but dangerous state of unpredictability in digital circuits.",
            "id": "1910785",
            "problem": "A Finite State Machine (FSM) is designed to control a high-speed data sampling process. The FSM has three states: `IDLE` (state `00`), `SAMPLING` (state `01`), and `PROCESSING` (state `10`). The state transitions are synchronized to the rising edge of a system clock, `clk`. The design incorporates an active-low asynchronous reset input, `areset_n`, which is intended to force the FSM into the `IDLE` state whenever `areset_n` is low, regardless of clock activity.\n\nThe flip-flops used to implement the state register have a specified *reset recovery time*. This is the minimum time that the `areset_n` signal must be stable in its inactive (high) state before the next rising edge of `clk` to ensure predictable behavior.\n\nDuring operation, a transient glitch causes the `areset_n` signal to be asserted (go low) and then de-asserted (go high). The de-assertion of `areset_n` occurs at a moment that violates the reset recovery time specification of the state register's flip-flops. Which of the following statements most accurately describes the potential behavior of the FSM's state immediately following the rising clock edge that occurs during this timing violation?\n\nA. The FSM will reliably transition to the `SAMPLING` state, as that is the intended next state from `IDLE` when a start condition is met.\n\nB. The FSM will reliably remain in the `IDLE` state, as the reset signal was active just prior to the clock edge.\n\nC. The FSM's state register may enter a metastable condition, where its output is temporarily unpredictable, potentially causing the FSM to transition to an invalid or unintended state.\n\nD. The FSM's internal clock-gating logic will be triggered, preventing any state change until the next valid reset pulse.\n\nE. The FSM will suffer permanent physical damage due to the internal contention caused by the timing violation, requiring a power cycle to recover.",
            "solution": "Define the active-low asynchronous reset as $areset\\_n$ and denote the reset recovery time of the flip-flops by $t_{rec}$. By specification, $areset\\_n$ must be high and stable for at least $t_{rec}$ before the next rising edge of $clk$ to guarantee predictable sampling of the state register.\n\nLet the de-assertion (low-to-high transition) of $areset\\_n$ occur at time $t_{d}$ and the next rising edge of $clk$ occur at time $t_{c}$. The recovery-time requirement is\n$$\nt_{c} - t_{d} \\geq t_{rec}.\n$$\nA violation corresponds to\n$$\nt_{c} - t_{d}  t_{rec}.\n$$\nWhen this inequality holds, the reset input has not been inactive long enough for the internal nodes of the flip-flops to reach a valid stable region before the sampling event at $t_{c}$. This is analogous to violating setup/hold timing on a data input: the flip-flop may enter a metastable state. In metastability, the output $Q$ can remain at an indeterminate voltage for a finite resolution time and then resolve to either logic level unpredictably. For a multi-bit state register, different bits may resolve differently, potentially yielding an invalid state encoding or an unintended legal state.\n\nEvaluate the options under this behavior:\n- Option A requires deterministic behavior toward the intended next state; this is not guaranteed under a recovery-time violation.\n- Option B assumes the reset will reliably force or hold the state in $IDLE$ at the sampling edge; a recovery-time violation removes that guarantee, allowing metastability or unintended resolution.\n- Option C correctly states that the state register may become metastable with unpredictable outputs and potentially transition to an invalid or unintended state.\n- Option D introduces clock gating not specified in the design; asynchronous reset does not inherently trigger clock gating to block state changes.\n- Option E asserts permanent physical damage; metastability is a transient logical phenomenon and does not imply hardware damage.\n\nTherefore, the most accurate description is Option C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "In safety-critical applications, an FSM must not only perform its function correctly but also recover gracefully from unexpected errors. This advanced practice challenges you to analyze a Moore FSM designed with a crucial safety feature: recovery from an illegal state . You will trace a realistic verification scenario that uses a simulator `force` command to test this behavior, learning how engineers ensure that even in the face of faults, a system can return to a known, safe condition.",
            "id": "1966464",
            "problem": "You are tasked with verifying the safety features of a Finite State Machine (FSM) that controls the firing sequence of a high-power industrial laser. The system is designed as a Moore FSM with a synchronous active-high reset.\n\n**FSM Specification:**\n-   **Inputs**: `clk`, `reset`, `arm` (1-bit), `fire` (1-bit).\n-   **Output**: `laser_enable` (1-bit).\n-   **State Register**: A 2-bit register named `state_reg`.\n-   **States and Encodings**:\n    -   `S_OFF`: 2'b00 (The designated safe/reset state).\n    -   `S_ARMED`: 2'b01\n    -   `S_FIRING`: 2'b10\n    -   The encoding 2'b11 is an unused, illegal state.\n-   **Output Logic**:\n    -   `laser_enable` is 1 if and only if the FSM is in the `S_FIRING` state. Otherwise, `laser_enable` is 0.\n-   **State Transitions**: Transitions occur on the rising edge of `clk`.\n    1.  If `reset` is high, the next state is `S_OFF`.\n    2.  From `S_OFF`: If `arm` is high, the next state is `S_ARMED`. Otherwise, the state remains `S_OFF`.\n    3.  From `S_ARMED`: If `arm` is low, the next state is `S_OFF` (a safety interlock). If `arm` is high and `fire` is high, the next state is `S_FIRING`. Otherwise, the state remains `S_ARMED`.\n    4.  From `S_FIRING`: The next state is unconditionally `S_OFF` (the laser fires a single-cycle pulse).\n    5.  **Safety Recovery**: If `state_reg` ever holds the illegal value 2'b11, the FSM must transition to `S_OFF` on the next rising clock edge, regardless of the `arm` and `fire` inputs.\n\n**Testbench Scenario:**\nA testbench simulates the FSM with a clock (`clk`) that has a period of 10 ns. The first rising edge of the clock occurs at t = 10 ns. The following stimulus is applied:\n-   From t = 0 ns to t = 15 ns, `reset` is held high. At t = 15 ns, `reset` is de-asserted to 0.\n-   At t = 25 ns, `arm` is asserted high.\n-   At t = 35 ns, `fire` is asserted high. `arm` remains high.\n-   At t = 42 ns, a simulator `force` command is executed, which instantaneously and forcefully sets the value of the `state_reg` to the illegal encoding 2'b11. This command overrides the normal synchronous behavior of the register at that moment.\n-   At t = 45 ns, both `arm` and `fire` are de-asserted to 0.\n\n**Question:**\nBased on the FSM specification and the testbench scenario, determine the sequence of values for the output `laser_enable` at the specific simulation times of t = 41 ns, t = 43 ns, and t = 51 ns.\n\nChoose the correct sequence from the options below.\n\nA. (1, 0, 0)\n\nB. (1, 1, 0)\n\nC. (0, 0, 0)\n\nD. (1, 0, 1)\n\nE. (1, 1, 1)",
            "solution": "We trace the FSM's state and output through the simulation timeline. The FSM is a Moore machine, so its output `laser_enable` depends only on the current state. The output is 1 if and only if `state_reg` is `S_FIRING` (2'b10). Clock rising edges occur at $t=10, 20, 30, 40, 50, \\dots$ ns.\n\n**State Trace:**\n*   **t = 10 ns:** A rising clock edge occurs while `reset` is high. The synchronous reset forces the state: `state_reg` becomes `S_OFF` (2'b00).\n*   **t = 20 ns:** `reset` is now low. At the rising edge, the FSM is in `S_OFF` and `arm` is low, so it remains in `S_OFF`.\n*   **t = 30 ns:** At the rising edge, the FSM is in `S_OFF` and `arm` is now high. It transitions: `state_reg` becomes `S_ARMED` (2'b01).\n*   **t = 40 ns:** At the rising edge, the FSM is in `S_ARMED`, and both `arm` and `fire` are high. It transitions: `state_reg` becomes `S_FIRING` (2'b10).\n*   **t = 42 ns:** The simulator `force` command overrides the state register, setting `state_reg` to the illegal value 2'b11.\n*   **t = 50 ns:** At the rising edge, the FSM is in the illegal state 2'b11. The safety recovery rule applies, forcing a transition to the safe state regardless of inputs: `state_reg` becomes `S_OFF` (2'b00).\n\n**Output (`laser_enable`) Trace:**\n*   **At t = 41 ns:** This is after the transition to `S_FIRING` at t=40 ns but before the force command. Since the state is `S_FIRING`, the Moore output `laser_enable` is **1**.\n*   **At t = 43 ns:** This is after the state was forced to the illegal value 2'b11 at t=42 ns. Since the state is no longer `S_FIRING`, the output `laser_enable` becomes **0**.\n*   **At t = 51 ns:** This is after the FSM transitioned to `S_OFF` at t=50 ns due to the safety recovery mechanism. Since the state is `S_OFF`, the output `laser_enable` is **0**.\n\nThe sequence of `laser_enable` values at t = 41 ns, t = 43 ns, and t = 51 ns is (1, 0, 0).\n\nTherefore, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}