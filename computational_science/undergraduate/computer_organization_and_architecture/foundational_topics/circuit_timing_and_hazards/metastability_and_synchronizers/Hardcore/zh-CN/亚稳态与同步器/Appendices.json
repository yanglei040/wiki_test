{
    "hands_on_practices": [
        {
            "introduction": "在现代数字设计中，提高时钟频率是提升性能的常用手段。然而，这一做法直接影响到同步器的可靠性。本练习旨在让你量化这种权衡关系，通过计算你将学会如何在系统参数（如时钟速度）改变时，通过调整同步器设计（例如增加级数）来维持目标可靠性，这是高速数字设计中的一项基本技能 。",
            "id": "3658885",
            "problem": "一个事件率为 $f_{d}$ 的单位比特异步状态信号，使用一串边沿触发触发器链同步到一个目标时钟域中。最初，目标时钟频率为 $f_{c0}$，同步器使用 $k_{0}$ 级。在第一个可能进入亚稳态的触发器和最终采样触发器之间，可用的亚稳态判决时间模型为 $T_{r} = (k-1) T_{c} - \\delta$，其中 $k$ 是总级数，$T_{c}$ 是目标时钟周期，$\\delta$ 是一个包含了建立时间和传播延迟的恒定时间预算。该器件表现出由时间常数 $\\tau$ 表征的指数级亚稳态判决特性，并且所有与器件相关的常数和 $f_{d}$ 在不同工作点下保持不变。\n\n之后，目标时钟频率加倍至 $f_{c1} = 2 f_{c0}$。为了保持平均无故障时间（MTBF）在其初始值不变，你考虑为同步器增加额外的级数。假设 $k_{0} = 2$，$f_{c0} = 250\\,\\text{MHz}$，$f_{d} = 10\\,\\text{MHz}$，$\\tau = 28\\,\\text{ps}$，且 $\\delta = 120\\,\\text{ps}$。你可以假设 $\\delta$ 不随始终频率变化而改变，并且同步器标准的指数级MTBF与判决时间关系模型适用。\n\n求解：\n1) 时钟频率加倍后，为保持MTBF恒定所需增加的最小整数同步器级数。\n2) 从MTBF模型推导出的必须提供的额外判决时间 $\\Delta T_{r}$。\n\n将 $\\Delta T_{r}$ 以皮秒为单位表示，并四舍五入到三位有效数字。请将你的最终答案以一个双元素行矩阵的形式给出，按顺序包含额外级数和以皮秒为单位的 $\\Delta T_{r}$。在最终的方框答案中不要包含单位。",
            "solution": "一个双稳态元件保持亚稳态的概率随时间近似呈指数衰减。一个被广泛使用且经过实验验证的同步器失效模型指出，失效率与 $f_{c} f_{d}$ 的乘积成正比，再乘以一个由可用判决时间 $T_{r}$ 和器件时间常数 $\\tau$ 决定的指数衰减因子。因此，平均无故障时间（MTBF）的模型为\n$$\n\\text{MTBF} = \\frac{1}{K f_{c} f_{d}} \\exp\\!\\left(\\frac{T_{r}}{\\tau}\\right),\n$$\n其中 $K$ 是一个与器件/工艺相关的常数，包含孔径/窗口因子和其他比例项。这个形式抓住了两个关键事实：目标采样越频繁（$f_{c}$），异步事件发生越频繁（$f_{d}$），潜在的违规就越常发生；以及判决时间 $T_{r}$ 越长，违规传播的可能性就越小，其指数敏感度由 $\\tau$ 控制。\n\n我们已知，初始时目标时钟频率为 $f_{c0}$，变化后为 $f_{c1} = 2 f_{c0}$。异步事件率 $f_{d}$、$\\tau$ 和 $K$ 不变。为保持MTBF恒定，令初始和最终的MTBF相等，解出 $T_{r}$ 必须如何变化。\n\n设初始判决时间为 $T_{r0}$，最终所需的判决时间为 $T_{r1}$。令MTBF值相等，\n$$\n\\frac{1}{K f_{c0} f_{d}} \\exp\\!\\left(\\frac{T_{r0}}{\\tau}\\right)\n=\n\\frac{1}{K f_{c1} f_{d}} \\exp\\!\\left(\\frac{T_{r1}}{\\tau}\\right).\n$$\n消去公共常数并取自然对数：\n$$\n\\frac{T_{r0}}{\\tau} - \\ln(f_{c0})\n=\n\\frac{T_{r1}}{\\tau} - \\ln(f_{c1}).\n$$\n重新整理以获得补偿频率变化的额外判决时间 $\\Delta T_{r} \\equiv T_{r1} - T_{r0}$：\n$$\n\\Delta T_{r} = \\tau \\ln\\!\\left(\\frac{f_{c1}}{f_{c0}}\\right).\n$$\n对于时钟加倍，$f_{c1}/f_{c0} = 2$，所以\n$$\n\\Delta T_{r} = \\tau \\ln(2).\n$$\n当 $\\tau = 28\\,\\text{ps}$ 时，\n$$\n\\Delta T_{r} = 28\\,\\text{ps} \\times \\ln(2) \\approx 28\\,\\text{ps} \\times 0.693147\\ldots \\approx 19.409\\,\\text{ps}.\n$$\n四舍五入到三位有效数字并以皮秒表示，$\\Delta T_{r} \\approx 19.4\\,\\text{ps}$。\n\n接下来，将判决时间与级数联系起来。对于一个以周期 $T_{c}$ 工作的 $k$ 级链，从第一个可能进入亚稳态的触发器到最终采样触发器的有效判决时间的标准时序抽象为\n$$\nT_{r} = (k-1) T_{c} - \\delta,\n$$\n其中 $\\delta$ 包含了固定的建立时间和传播裕量。初始时，$k_{0} = 2$ 且 $T_{c0} = 1/f_{c0}$，\n$$\nT_{r0} = (2-1) T_{c0} - \\delta = T_{c0} - \\delta.\n$$\n将时钟加倍至 $f_{c1} = 2 f_{c0}$ 后，新周期为 $T_{c1} = 1/f_{c1} = \\frac{1}{2} T_{c0}$。如果我们选择一个新的级数 $k_{1}$，新的判决时间为\n$$\nT_{r1} = (k_{1}-1) T_{c1} - \\delta.\n$$\n为了维持相同的MTBF，我们必须满足\n$$\nT_{r1} \\ge T_{r0} + \\Delta T_{r}.\n$$\n代入表达式并消去 $\\delta$：\n$$\n(k_{1}-1) T_{c1} - \\delta \\ge (T_{c0} - \\delta) + \\Delta T_{r}\n\\quad\\Rightarrow\\quad\n(k_{1}-1) T_{c1} \\ge T_{c0} + \\Delta T_{r}.\n$$\n因此，满足要求的最小整数 $k_{1}$ 是\n$$\nk_{1} = \\left\\lceil 1 + \\frac{T_{c0} + \\Delta T_{r}}{T_{c1}} \\right\\rceil.\n$$\n现在进行数值计算。当 $f_{c0} = 250\\,\\text{MHz}$ 时，$T_{c0} = 1/f_{c0} = 4.0\\,\\text{ns}$。加倍后，$f_{c1} = 500\\,\\text{MHz}$，所以 $T_{c1} = 2.0\\,\\text{ns}$。使用计算出的 $\\Delta T_{r} \\approx 19.409\\,\\text{ps} = 0.019409\\,\\text{ns}$，\n$$\n1 + \\frac{T_{c0} + \\Delta T_{r}}{T_{c1}}\n=\n1 + \\frac{4.0\\,\\text{ns} + 0.019409\\,\\text{ns}}{2.0\\,\\text{ns}}\n=\n1 + \\frac{4.019409}{2.0}\n=\n1 + 2.0097045\n=\n3.0097045\\ldots.\n$$\n向上取整得到 $k_{1} = 4$。由于 $k_{0} = 2$，所需增加的最小同步器级数为\n$$\nk_{1} - k_{0} = 4 - 2 = 2.\n$$\n注意，在级数计算的条件中，$\\delta$ 在代数上被消掉了，因此它的具体值在这种情况下不影响最小整数级数；它会影响绝对的 $T_{r}$ 值，但在 $f_{c1}/f_{c0}$ 和 $\\tau$ 固定的情况下，不会影响所需的级数增量。\n\n因此，所需的额外判决时间为 $\\Delta T_{r} \\approx 19.4\\,\\text{ps}$（三位有效数字），而所需的最小额外级数为 2。",
            "answer": "$$\\boxed{\\begin{pmatrix}2  19.4\\end{pmatrix}}$$"
        },
        {
            "introduction": "一个真实的片上系统（SoC）通常包含数十甚至数百个时钟域交叉，每个交叉都需要同步器。整个芯片的可靠性取决于所有这些同步器的集体行为。这个问题将引导你从单个组件的视角转向系统级思维，你将运用可靠性理论的原理来计算一个包含多个独立故障源的系统的总体平均无故障时间（MTBF），从而理解系统复杂度如何影响整体可靠性 。",
            "id": "3658848",
            "problem": "一个片上系统集成了 $N$ 个相同的时钟域交叉接口，每个接口都由一个两级触发器同步器保护。根据经验观察，单个同步器中由亚稳态引发的失效事件遵循一个具有恒定失效率的无记忆过程，这与泊松点过程模型一致。在最坏工作条件下，单个同步器测得的平均无故障时间 (MTBF) 为 $MTBF_{\\text{single}} = 230$ 年。假设各个接口的同步器失效是相互独立的。\n\n基于以下假设：(i) 每个同步器的失效过程是具有恒定失效率的无记忆过程，以及 (ii) 独立的失效过程组合产生的总失效过程的失效率是各个失效率之和，请推导出系统级平均无故障时间 $MTBF_{\\text{sys}}$ 作为 $N$ 的函数。然后，确定满足系统级平均无故障时间 $MTBF_{\\text{sys}} \\ge 10$ 年连续运行的最大整数 $N$。\n\n最终答案以不带单位的整数 $N$ 表示。无需四舍五入。",
            "solution": "在进行求解之前，首先评估问题陈述的有效性。该问题在科学和数学上是合理的，其基础是应用于数字系统中亚稳态的可靠性理论标准原理，这是计算机组成与体系结构中的一个核心主题。已知条件包括接口数量 $N$、单个同步器的平均无故障时间 $MTBF_{\\text{single}}$ 为 $230$ 年，以及目标系统级平均无故障时间 $MTBF_{\\text{sys}}$ 至少为 $10$ 年。该问题依赖于以下假设：失效遵循具有恒定失效率的无记忆过程（泊松过程），并且系统的失效率是独立的单个失效率之和。这些前提对于此类工程分析是一致、完整且标准的。该问题是适定的、客观的，允许存在一个唯一且可验证的解。因此，该问题被认为是有效的，可以进行求解。\n\n问题陈述指出，同步器的失效过程是具有恒定失效率的无记忆过程。这意味着失效时间 $T$ 是一个服从指数分布的随机变量。对于这样的分布，平均无故障时间 $MTBF$ 是恒定失效率 $\\lambda$ 的倒数。\n$$MTBF = \\frac{1}{\\lambda}$$\n这个关系允许我们用 $MTBF$ 来表示失效率：\n$$\\lambda = \\frac{1}{MTBF}$$\n\n对于单个同步器，其失效率（我们可记作 $\\lambda_{\\text{single}}$）可根据其给定的平均无故障时间 $MTBF_{\\text{single}} = 230$ 年计算得出。\n$$\\lambda_{\\text{single}} = \\frac{1}{MTBF_{\\text{single}}} = \\frac{1}{230 \\text{ years}}$$\n\n系统由 $N$ 个相同且独立的同步器组成。根据问题的假设（这是可靠性理论中关于竞争性独立失效模式的一个标准结论），系统的总失效率 $\\lambda_{\\text{sys}}$ 是各个失效率之和。由于所有 $N$ 个同步器都是相同的，这个和为：\n$$\\lambda_{\\text{sys}} = \\sum_{i=1}^{N} \\lambda_{\\text{single}} = N \\cdot \\lambda_{\\text{single}}$$\n\n整个系统的失效过程也是一个具有恒定失效率 $\\lambda_{\\text{sys}}$ 的泊松过程。因此，系统级的平均无故障时间 $MTBF_{\\text{sys}}$ 是系统级失效率的倒数：\n$$MTBF_{\\text{sys}} = \\frac{1}{\\lambda_{\\text{sys}}}$$\n代入 $\\lambda_{\\text{sys}}$ 的表达式，我们可以将系统 MTBF 与单个组件的 MTBF 联系起来：\n$$MTBF_{\\text{sys}} = \\frac{1}{N \\cdot \\lambda_{\\text{single}}} = \\frac{1}{N} \\left( \\frac{1}{\\lambda_{\\text{single}}} \\right) = \\frac{MTBF_{\\text{single}}}{N}$$\n该方程给出了作为 $N$ 的函数的系统级平均无故障时间，这是要求推导的第一部分。\n\n问题的第二部分要求找到满足系统级 MTBF 大于或等于 $10$ 年的最大整数 $N$。该条件表示为以下不等式：\n$$MTBF_{\\text{sys}} \\ge 10 \\text{ years}$$\n代入 $MTBF_{\\text{sys}}$ 的推导表达式和 $MTBF_{\\text{single}}$ 的给定值：\n$$\\frac{230 \\text{ years}}{N} \\ge 10 \\text{ years}$$\n为了求解必须为正整数的 $N$，我们对不等式进行整理。由于 $N > 0$，我们可以在不等式两边同乘以 $N$，再同除以 $10$ 年，而不会改变不等号的方向：\n$$230 \\ge 10 \\cdot N$$\n$$ \\frac{230}{10} \\ge N$$\n$$23 \\ge N$$\n不等式 $N \\le 23$ 表明，如果要达到系统可靠性目标，接口数量不能超过 $23$。问题要求满足此条件的最大整数 $N$。小于或等于 $23$ 的最大整数 $N$ 值是 $23$。",
            "answer": "$$\\boxed{23}$$"
        },
        {
            "introduction": "到目前为止，我们主要关注单比特信号的同步。但是，当我们需要跨时钟域传输一个多比特数据值（如数据总线）时会发生什么？简单地为每个比特位独立放置一个同步器，可能会导致一个微妙而危险的问题。本练习揭示了多比特时钟域交叉中的数据不一致性这一关键问题，通过一个具体的反例和概率推导，你将理解为何独立的按位同步通常是不足够的，并探索更可靠的数据总线传输方案背后的基本原理 。",
            "id": "3658817",
            "problem": "考虑一个计算机系统中的异步时钟域交叉，其中一个时钟域中的生产者同步地将一个 $N$ 位数据总线更新为一个新字，而另一个时钟域中的消费者通过一个由两个级联的数据触发器 (DFF) 组成的每比特两级同步器对该总线进行采样。没有握手、选通信号或编码保护；消费者只是在每个周期采样 $N$ 个独立同步器的输出。假设生产者在其时钟域的某个特定边沿将总线从一个旧字更新为一个新字，使得 $N$ 个比特中的每一个都发生转换（即，所有 $N$ 个比特在源端同时变化）。由于亚稳态，每个比特的同步器表现出可变的延迟：在更新发生在靠近消费者采样边沿的条件下，一个给定的比特以概率 $p$ 在一个消费者周期后出现在消费者端，以概率 $1-p$ 在两个消费者周期后出现。假设不同比特之间的延迟结果是独立同分布的。\n\n任务：\n1. 仅使用双稳态存储元件中亚稳态的定义以及两级同步器在缓解亚稳态中的作用，为 $N=2$ 构建一个具体反例，证明消费者可能瞬时观察到一个既不等于旧字也不等于新字的字。您的构造必须指定旧的和新的两比特字，并解释每比特同步器延迟的独立性如何能在消费者端产生一个混合字。\n2. 在相同的独立性模型下，从第一性原理出发，推导出一个解析表达式，作为 $p$ 和 $N$ 的函数，表示消费者在给定采样时刻观察到的字是一致的概率，即在该时刻采样的所有 $N$ 个比特都来自同一个源周期（要么全部是旧的，要么全部是新的）。将您的最终答案表示为关于 $p$ 和 $N$ 的单个闭式表达式。\n\n不需要数值近似；请提供精确的表达式。最终答案必须是单个解析表达式。",
            "solution": "此问题探讨了异步时钟域交叉期间数据总线不一致性的可能性，并要求对此效应进行定量分析。问题陈述是有效的。它科学地基于数字电路中已被充分理解的亚稳态现象，其问题设定良好（well-posed），提供了所有必要的参数和定义，并且没有矛盾或含糊之处。该模型虽然是对复杂物理过程的简化，却是分析同步器行为的架构后果的标准且有效的抽象。我们着手处理任务的两个部分。\n\n**第1部分：$N=2$ 的反例**\n\n任务是为 $N=2$ 位的总线构建一个场景，在该场景中，消费者瞬时观察到一个既不是原始（旧）字也不是最终（新）字的字。\n\n设数据总线的两位为 $B_1$ 和 $B_0$。问题陈述所有比特都发生转换。我们可以选择旧字为 $W_{\\text{old}} = 01_2$，新字为 $W_{\\text{new}} = 10_2$。对于这个选择，$W_{\\text{old}}$ 对应于位向量 $(B_1, B_0) = (0, 1)$，$W_{\\text{new}}$ 对应于 $(B_1, B_0) = (1, 0)$。两个比特都翻转了，符合要求。\n\n生产者将总线从 $W_{\\text{old}}$ 更新到 $W_{\\text{new}}$ 的时间与消费者的时钟是异步的。每个比特都通过一个独立的两级同步器。由于存在亚稳态的可能性，每个比特的新值出现在消费者端的延迟是可变的。根据所提供的模型，对于每个比特 $i \\in \\{0, 1\\}$，其新值以概率 $p$ 在 $1$ 个消费者时钟周期后被消费者观察到，并以概率 $1-p$ 在 $2$ 个消费者时钟周期后被观察到。\n\n我们分析生产者更新后，消费者在第一个采样时刻观察到的字。在这一瞬间，如果比特 $B_i$ 的同步器有 $1$ 个周期的延迟，它将呈现其新值；如果其同步器有 $2$ 个周期的延迟，它将保留其旧值。\n\n让我们考虑两个比特延迟的一个特定结果，这是两个独立事件。假设比特 $B_1$ 的同步器有 $1$ 个周期的延迟，而比特 $B_0$ 的同步器有 $2$ 个周期的延迟。\n\\begin{itemize}\n    \\item 对于比特 $B_1$，一个 $1$ 周期的延迟意味着消费者采样到新值，$B_{1, \\text{new}} = 1$。\n    \\item 对于比特 $B_0$，一个 $2$ 周期的延迟意味着消费者采样到旧值，$B_{0, \\text{old}} = 1$。\n\\end{itemize}\n在这种情况下，消费者观察到的复合字是 $(B_1, B_0) = (1, 1)$，即 $11_2$。这个观察到的字 $11_2$ 既不等于旧字 $W_{\\text{old}} = 01_2$，也不等于新字 $W_{\\text{new}} = 10_2$。这构成了所要求的反例。\n\n此事件发生的概率为每个比特延迟的独立概率之积：$P(B_1 \\text{ 有 } 1\\text{-周期延迟}) \\times P(B_0 \\text{ 有 } 2\\text{-周期延迟}) = p \\times (1-p)$。因为 $p$ 是与亚稳态解决相关的概率，其范围通常在 $0  p  1$ 之间，所以这个结果有非零的发生概率。这个瞬态的无效字是每比特同步器独立、可变延迟的直接后果。\n\n**第2部分：一致性概率的推导**\n\n任务是推导出一个表达式，表示消费者观察到的字是一致的概率。一致的字被定义为所有 $N$ 个比特都来自同一个源周期的字，这意味着观察到的字要么是完整的旧字，要么是完整的新字。此分析集中于生产者更新后的第一个消费者采样时刻，因为在给定模型下，这是唯一可能出现不一致的时刻。在所有后续时刻，所有比特都将稳定到它们的新值。\n\n让我们考虑在这个关键采样时刻 $N$ 个比特的状态。对于每个比特 $i \\in \\{1, 2, \\ldots, N\\}$，根据其同步器的延迟，有两种可能的结果：\n\\begin{enumerate}\n    \\item 同步器有 $1$ 个周期的延迟：消费者采样到比特的*新*值。这以概率 $p$ 发生。\n    \\item 同步器有 $2$ 个周期的延迟：消费者采样到比特的*旧*值。这以概率 $1-p$ 发生。\n\\end{enumerate}\n\n所有 $N$ 个比特的延迟结果是独立同分布的。如果两个互斥事件之一发生，则观察到的 $N$ 位字是一致的：\n\n**事件A：所有比特都已转换到它们的新值。**\n这意味着对于每个比特 $i=1, \\ldots, N$，同步器都有 $1$ 个周期的延迟。由于事件是独立的，其概率是每个比特的独立概率之积：\n$$P(\\text{所有比特都是新值}) = \\prod_{i=1}^{N} P(\\text{比特 } i \\text{ 是新值}) = \\prod_{i=1}^{N} p = p^N$$\n在这种情况下，消费者观察到完整的新字 $W_{\\text{new}}$。\n\n**事件B：所有比特都保持其旧值。**\n这意味着对于每个比特 $i=1, \\ldots, N$，同步器都有 $2$ 个周期的延迟。再次利用独立性，其概率是各个独立概率的乘积：\n$$P(\\text{所有比特都是旧值}) = \\prod_{i=1}^{N} P(\\text{比特 } i \\text{ 是旧值}) = \\prod_{i=1}^{N} (1-p) = (1-p)^N$$\n在这种情况下，消费者观察到完整的旧字 $W_{\\text{old}}$。\n\n观察到一致字的总概率 $P(\\text{coherent})$ 是这两个互斥事件的概率之和。\n$$P(\\text{coherent}) = P(\\text{所有比特都是新值}) + P(\\text{所有比特都是旧值})$$\n代入上面推导出的表达式，我们得到：\n$$P(\\text{coherent}) = p^N + (1-p)^N$$\n这就是采样字一致的概率作为 $p$ 和 $N$ 的函数的闭式解析表达式。这也可以从二项分布的角度来看。设 $K$ 为已稳定到新值的比特数。那么 $K \\sim \\text{Binomial}(N,p)$。如果 $K=N$（全部为新）或 $K=0$（全部为旧），则该字是一致的。其概率为 $P(K=N) + P(K=0) = \\binom{N}{N}p^N(1-p)^0 + \\binom{N}{0}p^0(1-p)^N = p^N + (1-p)^N$，这证实了结果。",
            "answer": "$$\n\\boxed{p^{N} + (1-p)^{N}}\n$$"
        }
    ]
}