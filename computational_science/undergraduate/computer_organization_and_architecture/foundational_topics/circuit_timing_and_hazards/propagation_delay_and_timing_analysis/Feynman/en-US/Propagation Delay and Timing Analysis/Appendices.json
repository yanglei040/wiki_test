{
    "hands_on_practices": [
        {
            "introduction": "The maximum frequency at which a processor can operate is dictated by its longest delay path, known as the critical path. This exercise guides you through a complete timing analysis of a realistic processor component—a cache read path—to determine its minimum possible clock period, $T_{clk}$. By calculating the total delay from the source register's clock-to-Q output ($t_{cq}$) through all combinational logic ($t_{logic}$) and respecting the destination register's setup time ($t_{setup}$), you will master the fundamental timing constraint that governs synchronous circuit performance .",
            "id": "3670838",
            "problem": "A pipeline stage of a central processing unit (CPU) performs a single-cycle read from a Level-1 (L1) data cache implemented with Static Random Access Memory (SRAM). The address is launched by a source register on a rising clock edge and is captured by a destination register on the next rising clock edge. The read path includes the following stages:\n\n- Tag comparison in the tag array, with worst-case delay $t_{\\text{tag}}$.\n- Wordline activation in the data array, with worst-case delay $t_{\\text{wl}}$.\n- Bitline development and sensing in the data array, with worst-case delay $t_{\\text{bl}}$.\n- Sense amplifier (SA) decision time, with worst-case delay $t_{\\text{sa}}$.\n- Output multiplexer selection, with worst-case delay $t_{\\text{mux}}$.\n- Setup time of the destination register, $t_{\\text{setup}}$.\n\nAssume a simple organization in which the tag comparison and the data-array access proceed in parallel after the address is launched, and the output multiplexer is controlled by the tag match result. The destination register samples the multiplexer output. The clock distribution has bounded skew and jitter.\n\nGiven the following worst-case parameters at the target operating corner:\n- Source register clock-to-$Q$: $t_{\\text{cq}} = 37 \\ \\text{ps}$.\n- Tag compare delay: $t_{\\text{tag}} = 205 \\ \\text{ps}$.\n- Data-array wordline delay: $t_{\\text{wl}} = 135 \\ \\text{ps}$.\n- Data-array bitline development delay: $t_{\\text{bl}} = 295 \\ \\text{ps}$.\n- Sense amplifier delay: $t_{\\text{sa}} = 82 \\ \\text{ps}$.\n- Output multiplexer delay: $t_{\\text{mux}} = 58 \\ \\text{ps}$.\n- Destination register setup time: $t_{\\text{setup}} = 54 \\ \\text{ps}$.\n- Clock skew budget: $t_{\\text{skew}} = 22 \\ \\text{ps}$.\n- Cycle-to-cycle clock jitter budget: $t_{\\text{jitter}} = 13 \\ \\text{ps}$.\n\nUsing first principles of synchronous timing, compute the minimum feasible clock period $T_{\\text{clk}}$ that guarantees correct sampling for the worst-case path in this organization. Round your answer to four significant figures and express it in $\\text{ns}$.\n\nAlso, identify which single named stage among $\\{\\text{tag compare}, \\text{wordline}, \\text{bitline}, \\text{sense amplifier}, \\text{mux}\\}$ is the dominant contributor to the critical-path delay immediately before the multiplexer. Provide the name of that stage in your reasoning, but note that the final numeric answer must be only $T_{\\text{clk}}$ in $\\text{ns}$, rounded as specified.",
            "solution": "The problem requires the calculation of the minimum feasible clock period, $T_{\\text{clk}}$, for a synchronous digital circuit. The governing principle for such a calculation is the setup time constraint, which ensures that data arrives at a register input and is stable for a minimum duration ($t_{\\text{setup}}$) before the capturing clock edge arrives.\n\nThe general timing equation for the setup constraint is:\n$$T_{\\text{clk}} \\ge t_{\\text{cq}} + t_{\\text{logic}} + t_{\\text{setup}} + t_{\\text{uncertainty}}$$\nThe term $t_{\\text{uncertainty}}$ accounts for clock non-idealities, specifically clock skew ($t_{\\text{skew}}$) and clock jitter ($t_{\\text{jitter}}$). In a worst-case setup analysis, both skew and jitter reduce the available time for the logic to compute, so they are added to the path delay. The minimum clock period, $T_{\\text{clk,min}}$, is therefore given by:\n$$T_{\\text{clk,min}} = t_{\\text{cq}} + t_{\\text{logic}} + t_{\\text{setup}} + t_{\\text{skew}} + t_{\\text{jitter}}$$\n\nThe term $t_{\\text{logic}}$ represents the total delay of the combinational logic path between the source and destination registers. We must first determine the structure of this path based on the problem description.\n\nThe address is launched from a source register and propagates through two parallel paths:\n1.  The tag path, which consists of the tag comparison. The delay of this path is $t_{\\text{tag-path}} = t_{\\text{tag}}$.\n2.  The data path, which involves sequential activation of the wordline, bitline development, and sensing. The delay of this path is $t_{\\text{data-path}} = t_{\\text{wl}} + t_{\\text{bl}} + t_{\\text{sa}}$.\n\nThe results of these two paths converge at an output multiplexer. The multiplexer's select input is driven by the tag comparison result, and its data inputs are driven by the sense amplifier outputs from the data array. The multiplexer can only produce a stable output after both its select and data inputs are stable. Therefore, the delay to the multiplexer's inputs is the maximum of the two parallel path delays.\n$$t_{\\text{delay-to-mux}} = \\max(t_{\\text{tag-path}}, t_{\\text{data-path}}) = \\max(t_{\\text{tag}}, t_{\\text{wl}} + t_{\\text{bl}} + t_{\\text{sa}})$$\nAfter the signals arrive at the multiplexer, there is an additional delay, $t_{\\text{mux}}$, for the signal to propagate through it to the input of the destination register. Thus, the total combinational logic delay, $t_{\\text{logic}}$, is:\n$$t_{\\text{logic}} = \\max(t_{\\text{tag}}, t_{\\text{wl}} + t_{\\text{bl}} + t_{\\text{sa}}) + t_{\\text{mux}}$$\n\nNow, we substitute the given numerical values into these expressions. All delay values are in picoseconds ($\\text{ps}$).\nThe given delays are:\n- $t_{\\text{cq}} = 37 \\ \\text{ps}$\n- $t_{\\text{tag}} = 205 \\ \\text{ps}$\n- $t_{\\text{wl}} = 135 \\ \\text{ps}$\n- $t_{\\text{bl}} = 295 \\ \\text{ps}$\n- $t_{\\text{sa}} = 82 \\ \\text{ps}$\n- $t_{\\text{mux}} = 58 \\ \\text{ps}$\n- $t_{\\text{setup}} = 54 \\ \\text{ps}$\n- $t_{\\text{skew}} = 22 \\ \\text{ps}$\n- $t_{\\text{jitter}} = 13 \\ \\text{ps}$\n\nFirst, we calculate the delay of the data path:\n$$t_{\\text{data-path}} = t_{\\text{wl}} + t_{\\text{bl}} + t_{\\text{sa}} = 135 \\ \\text{ps} + 295 \\ \\text{ps} + 82 \\ \\text{ps} = 512 \\ \\text{ps}$$\nNext, we compare the data path delay with the tag path delay to find the critical path feeding into the multiplexer:\n$$t_{\\text{delay-to-mux}} = \\max(t_{\\text{tag}}, t_{\\text{data-path}}) = \\max(205 \\ \\text{ps}, 512 \\ \\text{ps}) = 512 \\ \\text{ps}$$\nThe critical path before the multiplexer is the data path. The problem asks to identify the dominant single named stage in this path. Comparing the components of the data path, $t_{\\text{wl}} = 135 \\ \\text{ps}$, $t_{\\text{bl}} = 295 \\ \\text{ps}$, and $t_{\\text{sa}} = 82 \\ \\text{ps}$, the bitline development delay ($t_{\\text{bl}}$) is the largest. Therefore, the dominant contributor is the **bitline** stage.\n\nNow, we calculate the total logic delay, $t_{\\text{logic}}$:\n$$t_{\\text{logic}} = t_{\\text{delay-to-mux}} + t_{\\text{mux}} = 512 \\ \\text{ps} + 58 \\ \\text{ps} = 570 \\ \\text{ps}$$\nFinally, we substitute all the component delays into the equation for the minimum clock period:\n$$T_{\\text{clk,min}} = t_{\\text{cq}} + t_{\\text{logic}} + t_{\\text{setup}} + t_{\\text{skew}} + t_{\\text{jitter}}$$\n$$T_{\\text{clk,min}} = 37 \\ \\text{ps} + 570 \\ \\text{ps} + 54 \\ \\text{ps} + 22 \\ \\text{ps} + 13 \\ \\text{ps} = 696 \\ \\text{ps}$$\nThe problem requires the answer to be expressed in nanoseconds ($\\text{ns}$) and rounded to four significant figures.\n$$T_{\\text{clk,min}} = 696 \\ \\text{ps} = 0.696 \\ \\text{ns}$$\nRounding to four significant figures, we get $0.6960 \\ \\text{ns}$.",
            "answer": "$$\\boxed{0.6960}$$"
        },
        {
            "introduction": "After learning to analyze a circuit's critical path, the next logical step is to optimize it. This practice demonstrates one of the most powerful techniques in processor design: pipelining. You will be tasked with strategically inserting a register to break a long computational path into two shorter stages, balancing their delays to achieve the fastest possible clock cycle . This exercise highlights how timing analysis is not just for verification, but is a crucial tool for making architectural decisions that directly enhance performance.",
            "id": "3670819",
            "problem": "A processor datapath contains an Arithmetic Logic Unit (ALU) that executes a composite operation whose worst-case data path is a fixed sequence of three combinational blocks: an adder, followed by a barrel shifter, followed by a final output multiplexer. You are allowed to insert exactly one pipeline register inside the ALU so that this ALU operation is executed over two pipeline stages. The block order is fixed: adder output feeds the shifter input, which then feeds the multiplexer input. The goal is to choose the register placement that minimizes the maximum per-stage combinational delay while ensuring that setup time requirements are met at each receiving register.\n\nAssume the following propagation delays for the blocks: adder delay $t_{A} = 0.317\\,\\text{ns}$, shifter delay $t_{S} = 0.183\\,\\text{ns}$, and multiplexer delay $t_{M} = 0.092\\,\\text{ns}$. Each pipeline register has setup time $t_{\\text{setup}} = 0.039\\,\\text{ns}$. Neglect clock-to-$q$ delay, clock skew, and any interconnect delay beyond the given block delays. The only two legal placements for the internal pipeline register are between the adder and the shifter, or between the shifter and the multiplexer. In both cases, the stage boundaries must respect the given block order.\n\nUsing only foundational definitions of synchronous timing, determine the minimum feasible single-cycle clock period $T_{\\text{clk,min}}$ that can be achieved by an optimal placement of the internal pipeline register, under the stated assumptions. Express your final answer in nanoseconds and round your answer to four significant figures.",
            "solution": "The fundamental principle of synchronous digital circuit design dictates that the clock period, $T_{\\text{clk}}$, must be greater than or equal to the total delay along the longest path between any two consecutive sequential elements (registers). This total delay comprises the clock-to-Q delay of the source register ($t_{\\text{clk-q}}$), the propagation delay of the combinational logic between the registers ($t_{\\text{comb}}$), the setup time of the destination register ($t_{\\text{setup}}$), and any clock skew ($t_{\\text{skew}}$). The relationship is formally expressed as:\n$$\nT_{\\text{clk}} \\ge t_{\\text{clk-q}} + t_{\\text{comb}} + t_{\\text{setup}} + t_{\\text{skew}}\n$$\nThe problem statement simplifies this by instructing us to neglect the clock-to-Q delay and clock skew. Therefore, the minimum clock period for any pipeline stage is determined by the combinational logic delay of that stage and the setup time of the register that captures its output.\n$$\nT_{\\text{clk,min, stage}} = t_{\\text{comb, stage}} + t_{\\text{setup}}\n$$\nFor a multi-stage pipeline, the overall system clock period is governed by the slowest stage, i.e., the one with the maximum combinational delay. Let $t_{\\text{comb,max}}$ be the maximum combinational delay across all stages. The minimum feasible clock period for the entire pipeline is then:\n$$\nT_{\\text{clk,min}} = t_{\\text{comb,max}} + t_{\\text{setup}}\n$$\nWe are given the following propagation delays:\n- Adder delay: $t_{A} = 0.317\\,\\text{ns}$\n- Shifter delay: $t_{S} = 0.183\\,\\text{ns}$\n- Multiplexer delay: $t_{M} = 0.092\\,\\text{ns}$\n- Register setup time: $t_{\\text{setup}} = 0.039\\,\\text{ns}$\n\nWe must analyze the two possible placements for the single pipeline register to determine which one yields the smaller maximum per-stage delay.\n\n**Case 1: Pipeline register placed between the adder and the shifter.**\nIn this configuration, the datapath is divided into two stages:\n- Stage $1$: Consists of the adder. The combinational delay of this stage is $t_{\\text{stage1}} = t_{A}$.\n- Stage $2$: Consists of the shifter followed by the multiplexer. The combinational delay of this stage is the sum of their individual delays, $t_{\\text{stage2}} = t_{S} + t_{M}$.\n\nLet's calculate the delays for each stage:\n$$\nt_{\\text{stage1}} = t_{A} = 0.317\\,\\text{ns}\n$$\n$$\nt_{\\text{stage2}} = t_{S} + t_{M} = 0.183\\,\\text{ns} + 0.092\\,\\text{ns} = 0.275\\,\\text{ns}\n$$\nThe maximum combinational delay for this placement, $t_{\\text{comb,max,1}}$, is the greater of the two stage delays:\n$$\nt_{\\text{comb,max,1}} = \\max(t_{\\text{stage1}}, t_{\\text{stage2}}) = \\max(0.317\\,\\text{ns}, 0.275\\,\\text{ns}) = 0.317\\,\\text{ns}\n$$\nThe minimum clock period achievable with this placement, $T_{\\text{clk},1}$, is:\n$$\nT_{\\text{clk},1} = t_{\\text{comb,max,1}} + t_{\\text{setup}} = 0.317\\,\\text{ns} + 0.039\\,\\text{ns} = 0.356\\,\\text{ns}\n$$\n\n**Case 2: Pipeline register placed between the shifter and the multiplexer.**\nIn this configuration, the datapath is divided differently:\n- Stage $1$: Consists of the adder followed by the shifter. The combinational delay is $t_{\\text{stage1}} = t_{A} + t_{S}$.\n- Stage $2$: Consists of the multiplexer. The combinational delay is $t_{\\text{stage2}} = t_{M}$.\n\nLet's calculate the delays for each stage:\n$$\nt_{\\text{stage1}} = t_{A} + t_{S} = 0.317\\,\\text{ns} + 0.183\\,\\text{ns} = 0.500\\,\\text{ns}\n$$\n$$\nt_{\\text{stage2}} = t_{M} = 0.092\\,\\text{ns}\n$$\nThe maximum combinational delay for this placement, $t_{\\text{comb,max,2}}$, is the greater of the two stage delays:\n$$\nt_{\\text{comb,max,2}} = \\max(t_{\\text{stage1}}, t_{\\text{stage2}}) = \\max(0.500\\,\\text{ns}, 0.092\\,\\text{ns}) = 0.500\\,\\text{ns}\n$$\nThe minimum clock period achievable with this placement, $T_{\\text{clk},2}$, is:\n$$\nT_{\\text{clk},2} = t_{\\text{comb,max,2}} + t_{\\text{setup}} = 0.500\\,\\text{ns} + 0.039\\,\\text{ns} = 0.539\\,\\text{ns}\n$$\n\n**Conclusion: Optimal Placement and Minimum Clock Period.**\nThe goal is to find the placement that minimizes the clock period. We compare the minimum clock periods calculated for the two cases:\n- Case $1$: $T_{\\text{clk},1} = 0.356\\,\\text{ns}$\n- Case $2$: $T_{\\text{clk},2} = 0.539\\,\\text{ns}$\n\nThe minimum of these two values determines the optimal achievable clock period for the entire system.\n$$\nT_{\\text{clk,min}} = \\min(T_{\\text{clk},1}, T_{\\text{clk},2}) = \\min(0.356\\,\\text{ns}, 0.539\\,\\text{ns}) = 0.356\\,\\text{ns}\n$$\nThe optimal placement is therefore between the adder and the shifter (Case $1$), as it results in more balanced stage delays ($0.317\\,\\text{ns}$ and $0.275\\,\\text{ns}$) compared to the highly unbalanced delays of Case $2$ ($0.500\\,\\text{ns}$ and $0.092\\,\\text{ns}$).\n\nThe problem asks for the final answer to be rounded to four significant figures. The calculated value is $0.356\\,\\text{ns}$. To express this with four significant figures, we append a zero.\n$$\nT_{\\text{clk,min}} = 0.3560\\,\\text{ns}\n$$",
            "answer": "$$\\boxed{0.3560}$$"
        },
        {
            "introduction": "While setup time analysis focuses on paths that are too slow, designers must also guard against paths that are too fast, which can corrupt data by changing it too soon. This exercise introduces the hold time constraint, a critical rule for ensuring data stability at a register's input after the clock edge arrives. You will analyze a scenario where a high-speed bypass path risks a hold violation and determine the necessary fix, illustrating how to ensure circuit correctness in the presence of non-ideal effects like clock skew .",
            "id": "3670803",
            "problem": "A pipeline stage in a single clock domain uses a bypass (forwarding) path to reduce the latency between a launching register and a capturing register. The two registers are positive-edge-triggered D flip-flops (DFFs). The bypass path reduces the minimum combinational delay, which risks violating the hold-time requirement at the capturing register when clock skew is present. The hold time is defined as the time interval during which the data at the capturing register’s input must remain stable after the capturing clock edge. Clock skew is defined as $s = t_{\\text{dest clk}} - t_{\\text{src clk}}$, where $t_{\\text{dest clk}}$ is the arrival time of the capturing clock edge and $t_{\\text{src clk}}$ is the arrival time of the launching clock edge. The minimum propagation from the launching register to the capturing register input is the sum of the launching register’s minimum clock-to-$Q$ delay and the minimum combinational path delay.\n\nYou are given the following parameters, all specified in picoseconds (ps):\n- Launching register minimum clock-to-$Q$ delay: $t_{\\text{cq,min}} = 35$.\n- Capturing register hold time: $t_{\\text{hold}} = 60$.\n- Clock skew (destination minus source): $s = 15$.\n- Bypass path minimum logic delay: $t_{\\text{bp,min}} = 10$.\n- Minimum interconnect delay on the bypass path: $t_{\\text{wire,min}} = 5$.\n- Each inserted unit buffer contributes a minimum propagation delay of $d_b = 20$ on the bypass path.\n\nUsing only the fundamental definition of hold time and the defined clock skew, derive from first principles the minimum number $N$ of identical unit buffers that must be inserted into the bypass path so that the minimum data arrival time at the capturing register input is sufficiently delayed to satisfy the hold-time requirement under the given skew. Express your final answer as the integer $N$. No rounding instruction is needed for the integer result. Do not include units in your final answer.",
            "solution": "The problem requires us to determine the minimum number of buffers needed in a bypass path to satisfy the hold-time requirement of a capturing flip-flop. We must start from the first principles of timing analysis.\n\nLet $t_{\\text{src clk}}$ be the arrival time of the clock edge at the launching register and $t_{\\text{dest clk}}$ be the arrival time of the same nominal clock edge at the capturing register. The problem defines clock skew as $s = t_{\\text{dest clk}} - t_{\\text{src clk}}$.\n\nThe hold-time requirement at the capturing register dictates that its input data must remain stable for a duration of $t_{\\text{hold}}$ after the capturing clock edge arrives. This means the data from the previous cycle must not be overwritten by new data until at least time $t_{\\text{dest clk}} + t_{\\text{hold}}$. The new data, which is launched by the source register, is therefore not allowed to arrive at the capturing register's input any earlier than this time.\n\nThe new data is launched from the source register at time $t_{\\text{src clk}}$. After the minimum clock-to-Q delay of the launching register, $t_{\\text{cq,min}}$, the new data appears at its output. The time of this event is $t_{\\text{src clk}} + t_{\\text{cq,min}}$.\n\nThis data then propagates through the combinational logic path to the input of the capturing register. To check for a hold violation, we must consider the fastest possible path, i.e., the one with the minimum propagation delay, which we denote as $t_{\\text{path,min}}$. The earliest possible arrival time of the new data at the capturing register's input, $t_{\\text{data arrival,min}}$, is given by:\n$$t_{\\text{data arrival,min}} = t_{\\text{src clk}} + t_{\\text{cq,min}} + t_{\\text{path,min}}$$\nTo prevent a hold violation, this earliest arrival time must be greater than or equal to the time the hold window closes. This gives the fundamental hold-time inequality:\n$$t_{\\text{data arrival,min}} \\ge t_{\\text{dest clk}} + t_{\\text{hold}}$$\nSubstituting the expression for $t_{\\text{data arrival,min}}$:\n$$t_{\\text{src clk}} + t_{\\text{cq,min}} + t_{\\text{path,min}} \\ge t_{\\text{dest clk}} + t_{\\text{hold}}$$\nThis inequality can be rearranged to incorporate the definition of clock skew, $s = t_{\\text{dest clk}} - t_{\\text{src clk}}$:\n$$t_{\\text{cq,min}} + t_{\\text{path,min}} \\ge (t_{\\text{dest clk}} - t_{\\text{src clk}}) + t_{\\text{hold}}$$\n$$t_{\\text{cq,min}} + t_{\\text{path,min}} \\ge s + t_{\\text{hold}}$$\nThis is the hold-time constraint equation. It establishes that the sum of the minimum clock-to-Q delay and the minimum path delay must be at least as large as the sum of the clock skew and the hold time.\n\nThe problem states that $N$ identical unit buffers are inserted into the bypass path to add delay. The total minimum path delay, $t_{\\text{path,min}}$, is the sum of the minimum delays of the bypass logic ($t_{\\text{bp,min}}$), the interconnect wire ($t_{\\text{wire,min}}$), and the $N$ added buffers, each with a minimum delay of $d_b$.\n$$t_{\\text{path,min}} = t_{\\text{bp,min}} + t_{\\text{wire,min}} + N \\cdot d_b$$\nSubstituting this into the hold-time constraint equation:\n$$t_{\\text{cq,min}} + (t_{\\text{bp,min}} + t_{\\text{wire,min}} + N \\cdot d_b) \\ge s + t_{\\text{hold}}$$\nOur goal is to find the minimum integer $N$ that satisfies this condition. We can isolate $N$:\n$$N \\cdot d_b \\ge s + t_{\\text{hold}} - t_{\\text{cq,min}} - t_{\\text{bp,min}} - t_{\\text{wire,min}}$$\n$$N \\ge \\frac{s + t_{\\text{hold}} - t_{\\text{cq,min}} - t_{\\text{bp,min}} - t_{\\text{wire,min}}}{d_b}$$\nNow, we substitute the specified numerical values, all of which are in picoseconds ($ps$):\n- $t_{\\text{cq,min}} = 35$\n- $t_{\\text{hold}} = 60$\n- $s = 15$\n- $t_{\\text{bp,min}} = 10$\n- $t_{\\text{wire,min}} = 5$\n- $d_b = 20$\n\nPlugging these values into the inequality for $N$:\n$$N \\ge \\frac{15 + 60 - 35 - 10 - 5}{20}$$\n$$N \\ge \\frac{75 - (35 + 10 + 5)}{20}$$\n$$N \\ge \\frac{75 - 50}{20}$$\n$$N \\ge \\frac{25}{20}$$\n$$N \\ge 1.25$$\nSince $N$ represents the number of physical buffers, it must be an integer. The minimum integer value for $N$ that satisfies the inequality $N \\ge 1.25$ is $2$. Thus, a minimum of $2$ buffers must be inserted to guarantee that the hold time is met.",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}