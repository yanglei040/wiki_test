{
    "hands_on_practices": [
        {
            "introduction": "在计算机系统中，使用固定位数表示数字时，不同的编码方案会导致不同的表示效率。这个练习将引导你直接比较最基础的纯二进制表示法和更面向人类可读性的压缩二进制编码十进制（BCD）表示法。通过量化在固定存储空间下两种方案的表示能力差异，你将能深刻理解数据类型设计中关于空间效率的基本权衡。",
            "id": "3666250",
            "problem": "在一个将无符号整数存储于固定大小字中的计算机系统中，考虑应用于一个大小为 $64$ 位的字的两种编码方案：\n\n- 直接二进制编码，该方案使用所有位模式作为无符号整数的有效表示。\n- 压缩二进制编码的十进制数 (BCD)，其中该字被划分为 $16$ 个连续的 $4$ 位字段 (半字节)。每个半字节使用 $4$ 位编码集合 $\\{0,1,2,3,4,5,6,7,8,9\\}$ 中的一个十进制数字；对应于值 $10$ 到 $15$ 的半字节模式是无效的且永不使用。该表示是固定长度的，恰好有 $16$ 个十进制数字，必要时使用左侧补零，因此每个有效的 $64$ 位模式都精确对应一个整数。\n\n仅使用位值记数法和计数原理的基本定义，推导出在固定的 $64$ 位字下每种编码方案可表示的不同整数的数量，然后计算在压缩BCD方案下不可用（浪费的）但在直接二进制编码下可用的 $64$ 位模式空间所占的比例。将这个浪费比例表示为一个四舍五入到六位有效数字的小数。不要使用百分号；以小数形式提供该比例。",
            "solution": "该问题要求分析在固定大小的 $64$ 位字中对无符号整数的两种不同编码方案，并计算其中一种方案相对于另一种方案的表示浪费。\n\n首先，我们确定一个 $64$ 位字中所有可能的位模式总数。一个位是一个二进制数字，能够表示两种状态（$0$ 或 $1$）。对于一个大小为 $n=64$ 位的字，不同模式的总数 $N_{total}$ 可以通过乘法法则确定。由于 $64$ 位中的每一位都可以独立地以 $2$ 种方式选择，因此组合的总数为：\n$$N_{total} = 2 \\times 2 \\times \\dots \\times 2 \\text{ ($64$ times)} = 2^{64}$$\n\n接下来，我们分析每种方案可表示的不同整数的数量。\n\n**1. 直接二进制编码**\n\n该方案使用所有可用的位模式来表示无符号整数。不同模式的数量是 $2^{64}$。问题陈述每个模式都是一个唯一的无符号整数的有效表示。因此，在直接二进制编码下可表示的不同整数数量 $N_{binary}$ 等于所有可能模式的总数。\n$$N_{binary} = 2^{64}$$\n所表示的整数范围从 $0$ (所有位都为 $0$ ) 到 $2^{64}-1$ (所有位都为 $1$ )。\n\n**2. 压缩二进制编码的十进制数 (BCD) 编码**\n\n在这种方案中，$64$ 位的字被划分为 $k=16$ 个连续的 $4$ 位字段，称为半字节。每个半字节用于编码集合 $\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\}$ 中的一个十进制数字。\n\n一个单独的 $4$ 位半字节可以表示 $2^4 = 16$ 个不同的值（从二进制的 $0000$ 到 $1111$，对应十进制的 $0$ 到 $15$）。然而，在 BCD 方案中，只有对应于十进制数字 $0$ 到 $9$ 的模式是有效的。这意味着每个半字节有 $10$ 种有效模式。对应于值 $10$ 到 $15$ （二进制 $1010$ 到 $1111$）的模式被认为是无效的。\n\n由于 $64$ 位的字由 $16$ 个独立的半字节组成，并且每个半字节有 $10$ 种可能的有效状态，我们可以再次使用乘法法则来找到压缩 BCD 方案的有效模式总数 $N_{BCD}$。\n$$N_{BCD} = 10 \\times 10 \\times \\dots \\times 10 \\text{ ($16$ times)} = 10^{16}$$\n问题陈述每个有效模式都精确对应一个整数。因此，在压缩 BCD 方案下可表示的不同整数数量为 $10^{16}$。这些整数表示的范围是从 $0$ 到 $10^{16}-1$。\n\n**3. 浪费空间的计算**\n\n问题要求计算在压缩 BCD 方案下不可用的 $64$ 位模式空间所占的比例。所有可能模式的集合大小为 $N_{total} = 2^{64}$。BCD 方案可用的模式集合大小为 $N_{BCD} = 10^{16}$。“在压缩 BCD 方案下不可用但在直接二进制编码下可用”的模式是总空间中所有模式减去对 BCD 有效的模式。\n\n浪费的模式数量 = $N_{total} - N_{BCD} = 2^{64} - 10^{16}$。\n\n浪费空间的分数（比例）$W$ 是浪费的模式数量与空间中总模式数量的比值：\n$$W = \\frac{N_{total} - N_{BCD}}{N_{total}} = \\frac{2^{64} - 10^{16}}{2^{64}}$$\n我们可以简化这个表达式：\n$$W = 1 - \\frac{10^{16}}{2^{64}}$$\n注意到 $2^{64} = (2^4)^{16} = 16^{16}$，可以将其进一步改写为：\n$$W = 1 - \\frac{10^{16}}{(2^4)^{16}} = 1 - \\frac{10^{16}}{16^{16}} = 1 - \\left(\\frac{10}{16}\\right)^{16} = 1 - \\left(\\frac{5}{8}\\right)^{16}$$\n\n现在，我们必须计算这个分数的数值，并将其四舍五入到六位有效数字。\n首先，我们计算项 $\\left(\\frac{5}{8}\\right)^{16}$：\n$$\\left(\\frac{5}{8}\\right)^{16} = (0.625)^{16}$$\n让我们来计算这个值：\n$(0.625)^2 = 0.390625$\n$(0.625)^4 = (0.390625)^2 = 0.152587890625$\n$(0.625)^8 = (0.152587890625)^2 \\approx 0.02328306436538696$\n$(0.625)^{16} = ((0.625)^8)^2 \\approx (0.023283064365)^2 \\approx 0.00054210108624275$\n现在我们计算浪费比例 $W$：\n$$W = 1 - (0.625)^{16} \\approx 1 - 0.00054210108624275$$\n$$W \\approx 0.99945789891375725$$\n问题要求将此值四舍五入到六位有效数字。前六位有效数字是 $9, 9, 9, 4, 5, 7$。第七位数字是 $8$，大于或等于 $5$，所以我们将第六位数字向上取整。\n$$W \\approx 0.999458$$\n这个小数表示与充分利用的直接二进制编码相比，在使用压缩 BCD 编码方案时浪费的 $64$ 位模式空间的比例。",
            "answer": "$$\\boxed{0.999458}$$"
        },
        {
            "introduction": "存储效率并非系统设计中唯一的考量因素。这个练习将我们带入一个真实的嵌入式系统场景：在资源受限的微控制器上存储和操作时间戳。你需要全面分析不同表示法在内存占用、数据转换（用于显示）延迟以及算术运算复杂度等方面的权衡，从而理解为何“最佳”数字表示法总是取决于具体应用的需求。",
            "id": "3666264",
            "problem": "一个资源受限的$8$位微控制器必须存储和操作具有以下字段和范围的时间戳：年 $y \\in [0,9999]$，月 $m \\in [1,12]$，日 $d \\in [1,31]$，时 $h \\in [0,23]$，分 $u \\in [0,59]$，秒 $s \\in [0,59]$。考虑两种基于位值记数系统的存储方案：\n\n- 方案 P（压缩二进制编码的十进制 (BCD)）：每个十进制数字用$4$位编码，并且数字之间无分隔符地连接。例如，一个两位数的字段正好使用$8$位。假设字段间没有填充或对齐开销。\n- 方案 B（纯二进制）：每个字段作为一个无符号二进制整数存储，使用表示其完整范围所需的最小位数，并且字段跨字节边界紧密打包。假设没有填充或对齐开销。\n\n假设该微控制器没有硬件除法指令，也没有类似十进制调整累加器 (DAA) 的指令（即没有直接的BCD校正支持）。当将时间戳导出到通用异步收发器 (UART) 时，固件会为所有字段打印带有前导零的固定宽度的十进制数字（例如，年份有$4$位数字，其他字段有$2$位数字），外加分隔符。对于本问题，仅关注这$14$个十进制数字；将分隔符的发送开销视为可忽略不计。将一个压缩BCD数字转换为其美国信息交换标准代码 (ASCII) 字符，可以通过解包这个半字节并加上字符$'0'$的代码点（即加上$0x30$）来实现。将一个二进制字段转换为十进制数字需要一个通用的二进制到十进制转换程序，在该平台上，这个程序是通过重复除以$10$或等效的基$10$转换算法以软件实现的。\n\n最后，考虑在每种方案下常见的算术运算“秒递增，并根据需要向分和时传播进位”。在方案B下，加法以基$2$进行；而在方案P下，加法在数字级别上以基$10$进行，当半字节超过$9$时需要进行十进制校正。\n\n哪个选项正确地描述了在该平台上内存使用、转换为十进制ASCII的延迟以及算术复杂性之间的权衡？\n\nA. 方案P使用$7$个字节存储时间戳，方案B使用$5$个字节；在该平台上，从方案P转换到十进制ASCII比从方案B更快；递增与进位算术在方案B下比在方案P下更简单、更快速。\n\nB. 方案P和方案B都使用$6$个字节；从方案B转换到十进制ASCII更快，因为除以$10$的运算开销很小；递增与进位算术在方案P下更简单，因为每个半字节已经是一个十进制数字。\n\nC. 由于半字节对齐，方案P使用$8$个字节，而方案B使用$6$个字节，因为位打包不切实际；两种方案的转换延迟相似；递增与进位算术在方案P下更简单，因为它与人类可读的十进制匹配。\n\nD. 方案P使用$7$个字节，方案B使用$5$个字节；从方案P转换到十进制ASCII更慢，因为半字节解包和加上$0x30$会增加开销；递增与进位算术在方案P下更简单，因为每个数字是独立的。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤1：提取已知条件\n- **平台：** $8$位微控制器，资源受限。\n- **时间戳字段和范围：**\n    - 年 $y \\in [0, 9999]$\n    - 月 $m \\in [1, 12]$\n    - 日 $d \\in [1, 31]$\n    - 时 $h \\in [0, 23]$\n    - 分 $u \\in [0, 59]$\n    - 秒 $s \\in [0, 59]$\n- **方案 P（压缩BCD）：**\n    - 每个十进制数字用$4$位编码。\n    - 数字之间无分隔符地连接。\n    - 字段间没有填充或对齐开销。\n- **方案 B（纯二进制）：**\n    - 每个字段作为一个无符号二进制整数存储。\n    - 使用表示其完整范围所需的最小位数。\n    - 字段跨字节边界紧密打包。\n    - 没有填充或对齐开销。\n- **平台限制：**\n    - 没有硬件除法指令。\n    - 没有类似十进制调整累加器 (DAA) 的指令。\n- **转换为ASCII以用于UART：**\n    - 输出格式：带有前导零的固定宽度的十进制数字（年$4$位数字，其他$2$位数字）。总数字数：$4+2+2+2+2+2 = 14$。\n    - BCD转ASCII：解包半字节，加上`$0x30`。\n    - 二进制转十进制：使用重复除以$10$或等效方法的软件程序。\n- **算术运算：**\n    - “秒递增并传播进位”。\n    - 方案B：基$2$加法。\n    - 方案P：数字级别的基$10$加法，带软件十进制校正。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地植根于计算机组成和体系结构，特别是嵌入式系统中的数据表示。压缩BCD和纯二进制是标准的编码方案。指定的约束（例如，$8$位平台、无硬件除法、无DAA）对于许多常见的微控制器（例如，8051、PIC、AVR系列）是现实的。\n2.  **良构性：** 这个问题是良构的。存储方案定义精确，可以明确地计算内存使用量。平台约束和操作都明确指定，从而可以对计算复杂度和延迟进行逻辑分析。可以对这些权衡进行唯一的比较。\n3.  **客观性：** 该问题使用精确的技术语言客观地陈述。比较的标准——内存使用、转换延迟和算术复杂性——是计算机工程中的客观度量。\n\n问题陈述没有表现出科学上不健全、不完整、矛盾或模糊等缺陷。它呈现了一个经典且实用的工程权衡场景。\n\n### 步骤3：结论与行动\n问题陈述是**有效**的。将推导解决方案。\n\n### 推导\n\n根据问题的要求，分析分为三个部分：内存使用、转换为十进制ASCII的延迟和算术复杂性。\n\n**1. 内存使用**\n\n*   **方案 P（压缩BCD）：**\n    每个十进制数字需要$4$位（一个半字节）。\n    -   年（$y$，$4$位数字）：$4 \\text{ digits} \\times 4 \\text{ bits/digit} = 16$ 位。\n    -   月（$m$，$2$位数字）：$2 \\text{ digits} \\times 4 \\text{ bits/digit} = 8$ 位。\n    -   日（$d$，$2$位数字）：$2 \\text{ digits} \\times 4 \\text{ bits/digit} = 8$ 位。\n    -   时（$h$，$2$位数字）：$2 \\text{ digits} \\times 4 \\text{ bits/digit} = 8$ 位。\n    -   分（$u$，$2$位数字）：$2 \\text{ digits} \\times 4 \\text{ bits/digit} = 8$ 位。\n    -   秒（$s$，$2$位数字）：$2 \\text{ digits} \\times 4 \\text{ bits/digit} = 8$ 位。\n    总位数为 $16 + 8 + 8 + 8 + 8 + 8 = 56$ 位。\n    由于 $1 \\text{ byte} = 8 \\text{ bits}$，总内存使用量为 $56 / 8 = 7$ 字节。\n\n*   **方案 B（纯二进制）：**\n    最小位数由每个字段范围内的最大值决定。存储最大值$N$所需的位数$k$为 $\\lceil \\log_2(N+1) \\rceil$。\n    -   年（$y \\in [0, 9999]$）：最大值为 $9999$。由于 $2^{13} = 8192$ 且 $2^{14} = 16384$，我们需要 $14$ 位。\n    -   月（$m \\in [1, 12]$）：最大值为 $12$。由于 $2^3 = 8$ 且 $2^4 = 16$，我们需要 $4$ 位。\n    -   日（$d \\in [1, 31]$）：最大值为 $31$。由于 $2^4 = 16$ 且 $2^5 = 32$，我们需要 $5$ 位。\n    -   时（$h \\in [0, 23]$）：最大值为 $23$。由于 $2^4 = 16$ 且 $2^5 = 32$，我们需要 $5$ 位。\n    -   分（$u \\in [0, 59]$）：最大值为 $59$。由于 $2^5 = 32$ 且 $2^6 = 64$，我们需要 $6$ 位。\n    -   秒（$s \\in [0, 59]$）：最大值为 $59$。由于 $2^5 = 32$ 且 $2^6 = 64$，我们需要 $6$ 位。\n    总位数为 $14 + 4 + 5 + 5 + 6 + 6 = 40$ 位。\n    由于字段是紧密打包的，总内存使用量为 $40 / 8 = 5$ 字节。\n\n**2. 转换为十进制ASCII的延迟**\n\n*   **方案 P：** 数据已经以十进制为中心的格式表示。要转换为ASCII，固件必须：\n    1.  隔离每个$4$位的半字节。这涉及简单的位运算（AND, SHIFT），这些运算非常快（在$8$位MCU上通常每个需要$1-2$个时钟周期）。\n    2.  加上'0'的ASCII偏移量（即值`$0x30$）。这是一个单一的`ADD`指令，也很快。\n    这个过程对每个数字来说，具有非常低且恒定的时间复杂度。不涉及循环或高开销的子程序。\n\n*   **方案 B：** 数据是纯二进制格式。为了获得用于打印的十进制数字，每个字段都必须从二进制转换为十进制。问题明确指出，这是通过一个涉及重复除以$10$的软件程序完成的，因为没有硬件除法指令。\n    -   例如，转换一个$14$位的年份需要多次软件除法。在没有原生指令的$8$位MCU上，一次软件除法是一个迭代算法（例如，使用移位和减法），需要许多时钟周期（通常是数百个）。\n    -   这个转换必须对$6$个字段中的每一个都执行。\n    这个过程是计算密集型的，并且比方案P所需的简单解包要慢得多。\n\n**结论：** 在指定的平台上，从方案P转换到十进制ASCII比从方案B快得多。\n\n**3. 算术复杂性（递增与进位）**\n\n*   **方案 B：** 要递增`second`字段：\n    1.  提取$6$位的`second`字段（可能需要移位和掩码操作）。\n    2.  使用CPU的原生二进制加法指令加$1$。这是一个单一、快速的操作。\n    3.  将结果与限制值$59$进行比较。这是一个快速的比较。\n    4.  如果超过$59$，则将该字段设置为$0$，并通过对`minute`字段执行相同的简单二进制递增来传播进位。\n    整个过程利用了微控制器快速高效的原生二进制算术逻辑单元（ALU）。它简单且计算效率高。\n\n*   **方案 P：** 字段是BCD格式。要递增$8$位的`second`字段（表示两个十进制数字）：\n    1.  使用二进制加法将BCD字节加$1$。例如，`$0x59 + 1 = 0x5A$`。\n    2.  结果`$0x5A$`不是一个有效的BCD数，因为低半字节（A）大于$9$。\n    3.  必须执行一个软件实现的“十进制调整”程序。由于没有DAA指令，这涉及：\n        a. 检查低半字节是否大于$9$。\n        b. 如果是，则给字节加上$6$以“跳过”无效的十六进制值（例如，`$0x5A + 0x06 = 0x60$`）。\n        c. 检查半字节之间的进位传播和整体字节溢出。\n    4.  然后必须将校正后的BCD结果与限制值（例如`$0x59$）进行比较。如果比较跨越多个字节，它本身可能比二进制比较更复杂。\n    5.  如果发生溢出（例如，`second`变为`$0x60$），则该字段被设置为`$0x00$`并传播进位，从而在`minute`字段上触发同样复杂的BCD递增操作。\n    这种基于软件的BCD算术比原生二进制算术要复杂得多，也慢得多。\n\n**结论：** 递增与进位算术在方案B下比在方案P下更简单、更快速。\n\n### 逐项分析选项\n\n**A. 方案P使用$7$个字节存储时间戳，方案B使用$5$个字节；在该平台上，从方案P转换到十进制ASCII比从方案B更快；递增与进位算术在方案B下比在方案P下更简单、更快速。**\n- **内存使用：** 这个说法（$7$字节 vs. $5$字节）与我们的推导相符。\n- **转换延迟：** 这个说法（P比B快）与我们的分析相符。\n- **算术复杂性：** 这个说法（B比P更简单/更快）与我们的分析相符。\n所有三个子陈述都正确。\n**结论：** 正确。\n\n**B. 方案P和方案B都使用$6$个字节；从方案B转换到十进制ASCII更快，因为除以$10$的运算开销很小；递增与进位算术在方案P下更简单，因为每个半字节已经是一个十进制数字。**\n- **内存使用：** 不正确。我们的推导显示P为$7$字节，B为$5$字节。\n- **转换延迟：** 不正确。从B转换更慢，并且前提“除以$10$的运算开销很小”对于这个平台是明确错误的。\n- **算术复杂性：** 不正确。P中的算术因需要软件十进制调整而更复杂。\n**结论：** 不正确。\n\n**C. 由于半字节对齐，方案P使用$8$个字节，而方案B使用$6$个字节，因为位打包不切实际；两种方案的转换延迟相似；递增与进位算术在方案P下更简单，因为它与人类可读的十进制匹配。**\n- **内存使用：** 不正确。问题陈述明确禁止了所做的假设（“没有填充或对齐开销”和“紧密打包”）。计算出的值是$7$和$5$字节。\n- **转换延迟：** 不正确。存在显著的性能差异。\n- **算术复杂性：** 不正确。“与人类可读的十进制匹配”并不意味着对于没有原生BCD支持的机器来说计算简单。\n**结论：** 不正确。\n\n**D. 方案P使用$7$个字节，方案B使用$5$个字节；从方案P转换到十进制ASCII更慢，因为半字节解包和加上$0x30$会增加开销；递增与进位算术在方案P下更简单，因为每个数字是独立的。**\n- **内存使用：** 正确。\n- **转换延迟：** 不正确。与软件除法相比，解包的开销微不足道，所以P更快，而不是更慢。\n- **算术复杂性：** 不正确。P更复杂。理由“因为每个数字是独立的”是错误的；一个数字的进位会影响下一个数字，这正是复杂性的关键所在。\n**结论：** 不正确。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "位值系统的多项式结构本身就是一个强大的数学工具，尤其在算法设计中。这个练习要求你利用该结构设计一个流式处理算法，用于计算一个以数字流形式给出的大数的模运算结果。这个过程揭示了如何通过利用位值表示法的底层原理来处理那些远超标准数据类型范围的数字，这项技术在密码学和数论等领域有重要应用。",
            "id": "3666216",
            "problem": "一个基数为 $b$ 的按位记数法使用数字 $d_0,d_1,\\dots,d_{n-1}$ 来表示一个非负整数 $x$，其中每个数字都满足 $0 \\le d_i  b$，使得 $x$ 等于一个以 $b$ 为变量、以这些数字为系数的多项式。当数字从最高有效位到最低有效位依次给出时，可以将读取该数字的过程看作是一个增量式的多项式求值过程。在计算机组成与体系结构中，流式求值是可取的，因为它避免了存储所有数字或计算巨大的中间值。仅使用按位记数法的核心原理和模运算的基本性质，设计一个算法，在每个新数字到达时，增量式地更新 $x$ 除以正整数模数 $m$ 的余数，而无需完整地构造出 $x$，并且不会产生超出计算余数所需范围的溢出。\n\n要求：\n- 从 $x$ 作为以数字为系数的 $b$ 的多项式的按位记数法定义出发，并利用模运算的分配律和结合律，推导出该算法。\n- 假设 $b \\ge 2$ 是一个整数，$m \\ge 1$ 是一个整数。\n- 假设数字以流的形式从最高有效位到最低有效位提供。对于基数10，数字是集合 $\\{0,1,2,3,4,5,6,7,8,9\\}$ 中的字符。对于基数2，数字是集合 $\\{0,1\\}$ 中的字符。对于基数16，数字是集合 $\\{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\\}$ 中的字符，并允许不区分大小写的解释。\n- 该算法必须仅通过在新数字到达时进行增量更新来计算余数 $r$ 等于 $x \\bmod m$，并且必须适用于任意长的数字流。\n- 为基数10的输入构建算法原型，同时保持设计足够通用，以处理允许集合中的任何基数 $b$。\n\n测试套件：\n- 使用以下固定的流和参数来验证正确性和边界条件。\n    1. 基数10，模数97，代表 $x$ 的数字字符串：\"12345678901234567890\"。\n    2. 基数10，模数13，代表 $x$ 的数字字符串：\"0000000\"。\n    3. 基数10，模数1，代表 $x$ 的数字字符串：\"31415926\"。\n    4. 基数10，模数123，代表 $x$ 的数字字符串：\"\"（空字符串，应表示0）。\n    5. 基数2，模数5，代表 $x$ 的数字字符串：\"101101\"。\n    6. 基数16，模数65535，代表 $x$ 的数字字符串：\"DEADBEEF\"。\n- 对于每个测试用例，要求的答案是 $x \\bmod m$ 的整数值。\n\n输出规范：\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按上述顺序包含测试套件的余数，并以基数10的整数表示。例如，程序应打印格式为“[r_1,r_2,r_3,r_4,r_5,r_6]”的一行。",
            "solution": "该问题要求设计一个算法来计算非负整数 $x$ 除以正整数模数 $m$ 的余数。整数 $x$ 以基数为 $b$ 的按位记数法表示，其数字以从最高有效位到最低有效位的流形式提供。该算法必须是增量式的，避免构造完整的整数 $x$，因为 $x$ 可能任意大。\n\n设整数 $x$ 在基数 $b$ 下由一个包含 $n$ 个数字的序列表示：$d_{n-1}, d_{n-2}, \\dots, d_1, d_0$，其中每个数字 $d_i$ 满足 $0 \\le d_i  b$。根据按位记数法的定义，$x$ 是一个以 $b$ 为变量、以这些数字为系数的多项式的值：\n$$x = \\sum_{i=0}^{n-1} d_i b^i = d_{n-1}b^{n-1} + d_{n-2}b^{n-2} + \\dots + d_1b^1 + d_0b^0$$\n\n数字以流的形式从最高有效位 $d_{n-1}$ 开始提供。这启发我们将多项式重构为一种嵌套形式，通常称为用于多项式求值的霍纳法（Horner's method）：\n$$x = (\\dots((d_{n-1} b + d_{n-2}) b + d_{n-3}) b + \\dots + d_1) b + d_0$$\n\n这种嵌套形式自然地对应于一个迭代过程。设 $x_k$ 是由流中的前 $k$ 个数字 $d_{n-1}, \\dots, d_{n-k}$ 所表示的整数。\n- 当 $k=1$ 时，$x_1 = d_{n-1}$。\n- 当 $k=2$ 时，$x_2 = d_{n-1}b + d_{n-2} = x_1 b + d_{n-2}$。\n- 当 $k=3$ 时，$x_3 = (d_{n-1}b + d_{n-2})b + d_{n-3} = x_2 b + d_{n-3}$。\n\n通常，由前 $k$ 个数字表示的值 $x_k$ 可以由前 $k-1$ 个数字表示的值 $x_{k-1}$ 和新数字 $d_{n-k}$ 计算得出：\n$$x_k = x_{k-1} b + d_{n-k}$$\n初始值在概念上为 $x_0 = 0$。最终的数字 $x$ 就是 $x_n$。\n\n我们的目标是计算 $x \\bmod m$。我们可以利用模运算的基本性质：\n1.  $(A + B) \\bmod m = ((A \\bmod m) + (B \\bmod m)) \\bmod m$\n2.  $(A \\times B) \\bmod m = ((A \\bmod m) \\times (B \\bmod m)) \\bmod m$\n\n设 $r_k$ 为 $x_k$ 除以 $m$ 的余数，即 $r_k = x_k \\bmod m$。我们寻求最终的余数 $r_n = x_n \\bmod m$。\n我们从一个表示数字0的初始状态开始，此时尚未处理任何数字。设当前余数为 $R$。初始时，$R=0$。\n当第一个数字 $d_{n-1}$ 到达时，新值为 $d_{n-1}$。余数更新为：\n$$R \\leftarrow (R \\cdot b + d_{n-1}) \\bmod m = (0 \\cdot b + d_{n-1}) \\bmod m = d_{n-1} \\bmod m$$\n当第二个数字 $d_{n-2}$ 到达时，新值为 $x_2 = x_1 b + d_{n-2}$。余数为：\n$$x_2 \\bmod m = (x_1 b + d_{n-2}) \\bmod m$$\n应用模运算的性质：\n$$x_2 \\bmod m = ((x_1 \\bmod m) \\cdot (b \\bmod m) + (d_{n-2} \\bmod m)) \\bmod m$$\n化简后，我们可以将其写为：\n$$r_2 = (r_1 \\cdot b + d_{n-2}) \\bmod m$$\n其中 $r_1 = x_1 \\bmod m$。\n\n这为余数建立了一个通用的递推关系。设 $R_{prev}$ 是从已处理的数字计算出的余数。当一个新数字 $d_{new}$ 到达时，新的余数 $R_{new}$ 计算如下：\n$$R_{new} = (R_{prev} \\cdot b + d_{new}) \\bmod m$$\n这个公式是该算法的核心。\n\n算法如下：\n1.  初始化一个余数变量 $r$ 为0。这代表空数字字符串的值，即0。余数为 $0 \\bmod m = 0$（对于 $m \\ge 1$）。\n2.  对于输入流中的每个数字 $d_i$（从最高有效位到最低有效位）：\n    a. 将数字字符转换为其整数值，记为 $d$。\n    b. 使用递推式更新余数：$r \\leftarrow (r \\cdot b + d) \\bmod m$。\n3.  处理完所有数字后，$r$ 的最终值就是结果 $x \\bmod m$。\n\n该算法符合所有要求。它逐个（增量式地）处理数字。它从不计算或存储 $x$ 的完整值。中间值 $r \\cdot b + d$ 是有界的。由于 $0 \\le r  m$ 和 $0 \\le d  b$，在进行模运算之前的最大值为 $(m-1)b + (b-1)$。这个值通常足够小，可以存放在一个标准整型（例如，一个64位的 `long long`）中，从而避免溢出。该算法适用于任意长的数字流，因为其状态完全包含在单个变量 $r$ 中。\n\n特殊情况：\n- **空字符串**：代表 $x=0$。算法初始化 $r=0$，跳过数字循环，最终结果为0，这是正确的，因为 $0 \\bmod m = 0$。\n- **模数 $m=1$**：对于任何整数 $x$，$x \\bmod 1 = 0$。算法计算 $r \\leftarrow (r \\cdot b + d) \\bmod 1$。由于任何整数模1都为0，余数 $r$ 在第一步之后将变为0，并在此后保持为0。最终结果正确地为0。\n\n该算法是霍纳法（Horner's method）在模运算框架内的直接应用。原型是为基数10开发的，但推导出的公式对于任何基数 $b \\ge 2$都是通用的。",
            "answer": "$$\\boxed{[5, 0, 0, 0, 0, 40349]}$$"
        }
    ]
}