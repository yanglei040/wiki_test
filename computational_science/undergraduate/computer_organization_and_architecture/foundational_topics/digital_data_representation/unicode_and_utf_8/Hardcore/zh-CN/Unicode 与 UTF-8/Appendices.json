{
    "hands_on_practices": [
        {
            "introduction": "掌握任何数据格式的第一步是能够验证其正确性。这项实践要求你将抽象的 UTF-8 编码规则转化为具体的位运算，从零开始构建一个验证器。通过这项练习，你将巩固对 UTF-8 可变长度结构及其二进制表示的理解。",
            "id": "3622809",
            "problem": "要求您设计并实现一个用于 Unicode 转换格式-8 (UTF-8) 的二进制验证器。该验证器必须基于二进制数系统的第一性原理，使用二进制位置表示法和位运算来对字节进行分类并重构代码点。一个字节由 $8$ 个二进制数字（比特）组成，按权重 $2^7, 2^6, \\dots, 2^0$ 排序。位掩码是一个二进制数，与位逻辑运算一起使用以选择特定的比特子集；例如，按位与（AND）运算仅在两个操作数在该位置都为 $1$ 时才保留该比特。\n\nUTF-8 将 Unicode 标量值编码为一到四个字节的序列。前导字节通过其最高有效位模式来编码序列长度，而延续字节使用固定的模式。验证器必须使用二进制掩码来区分前导字节和延续字节，并且必须重构代码点以检测无效编码和超长编码。您可以假定的基本事实是：\n\n- 整数的二进制位置表示法以及位运算的属性，包括按位与（AND）、按位或（OR）和位移。\n- UTF-8 字节结构，由最高有效位模式定性描述：\n  - 单字节字符：前导字节模式 $0xxxxxxx$。\n  - 双字节序列：前导字节模式 $110xxxxx$，后跟一个延续字节。\n  - 三字节序列：前导字节模式 $1110xxxx$，后跟两个延续字节。\n  - 四字节序列：前导字节模式 $11110xxx$，后跟三个延续字节。\n  - 延续字节模式 $10xxxxxx$。\n- 一个有效的重构代码点必须满足 $0 \\leq \\text{code point} \\leq 0x10FFFF$，并且不得位于 Unicode 代理项范围 $[0xD800, 0xDFFF]$ 内。\n- 序列不得超长：一个 $n$ 字节的序列所编码的值不得小于 $n$ 字节可表示的最小值，即 $n=2$ 时为 $0x80$，$n=3$ 时为 $0x800$，$n=4$ 时为 $0x10000$。\n\n您的程序必须：\n\n- 对于每个测试用例，将数据视为字节数组，如果整个数组是有效的 UTF-8 序列，则返回 $1$，否则返回 $0$。\n- 推导并使用二进制掩码来识别延续字节，并将前导字节按其序列长度进行分类。\n- 使用比特提取和拼接从序列中重构代码点，并验证上述基本原则中的所有约束条件。\n- 拒绝任何未被适当前导字节引导的游离延续字节、任何不完整的多字节序列、任何 $5$ 字节或更长的前导模式、任何超长编码、任何代理项代码点以及任何大于 $0x10FFFF$ 的代码点。\n\n用于验证解决方案不同方面的测试套件：\n\n- 案例 $1$：ASCII 字符串字节 $\\{0x48,0x65,0x6C,0x6C,0x6F\\}$。\n- 案例 $2$：双字节有效字符 $\\{0xC3,0xB1\\}$（拉丁小写字母 enye）。\n- 案例 $3$：三字节有效字符 $\\{0xE2,0x82,0xAC\\}$（欧元符号）。\n- 案例 $4$：四字节有效字符 $\\{0xF0,0x90,0x8D,0x88\\}$（哥特字母 hwair，代码点 $U+10348$）。\n- 案例 $5$：$U+0000$ 的超长编码：$\\{0xC0,0x80\\}$。\n- 案例 $6$：已编码的代理项代码点：$\\{0xED,0xA0,0x80\\}$（表示 $U+D800$）。\n- 案例 $7$：游离的延续字节：$\\{0x80\\}$。\n- 案例 $8$：不完整的三字节序列：$\\{0xE2,0x82\\}$。\n- 案例 $9$：最大有效代码点 $U+10FFFF$：$\\{0xF4,0x8F,0xBF,0xBF\\}$。\n- 案例 $10$：超出 $U+10FFFF$ 的代码点：$\\{0xF4,0x90,0x80,0x80\\}$。\n- 案例 $11$：无效的五字节前导模式：$\\{0xF8,0x80,0x80,0x80,0x80\\}$。\n- 案例 $12$：ASCII 后跟游离的延续字节：$\\{0x41,0x80\\}$。\n- 案例 $13$：最小有效双字节值 $U+0080$：$\\{0xC2,0x80\\}$。\n- 案例 $14$：最小有效三字节值 $U+0800$：$\\{0xE0,0xA0,0x80\\}$。\n- 案例 $15$：最小有效四字节值 $U+10000$：$\\{0xF0,0x90,0x80,0x80\\}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上述测试用例一致（例如，$\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{15}\\right]$）。该单行上的每个结果必须是整数 $0$ 或 $1$。",
            "solution": "在尝试解决方案之前，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n- **领域**：用于 Unicode 转换格式-8 (UTF-8) 的二进制验证器。\n- **核心原则**：验证器必须基于数字的二进制位置表示法和位运算。\n- **字节定义**：一个字节由 $8$ 个比特组成，权重从 $2^7$（最高有效位，MSB）到 $2^0$（最低有效位，LSB）。\n- **位掩码定义**：位掩码是一个二进制数，与位逻辑运算一起使用以选择特定的比特子集。\n- **UTF-8 字节结构（定性描述）**：\n    - 单字节：$0xxxxxxx$\n    - 双字节序列：$110xxxxx$ 后跟一个延续字节。\n    - 三字节序列：$1110xxxx$ 后跟两个延续字节。\n    - 四字节序列：$11110xxx$ 后跟三个延续字节。\n    - 延续字节：$10xxxxxx$\n- **验证约束**：\n    - 一个有效的重构代码点必须在范围 $[0, 0x10FFFF]$ 内。\n    - 一个有效的重构代码点不得位于 Unicode 代理项范围 $[0xD800, 0xDFFF]$ 内。\n    - 序列不得超长。多字节序列的最小值是：\n        - $n=2$ 字节：$0x80$\n        - $n=3$ 字节：$0x800$\n        - $n=4$ 字节：$0x10000$\n- **程序要求**：\n    - 输入：每个测试用例的字节数组。\n    - 输出：如果整个数组是有效的 UTF-8 序列，则返回 $1$，否则返回 $0$。\n    - 程序必须拒绝：\n        - 游离的延续字节。\n        - 不完整的多字节序列。\n        - $5$ 字节或更长的前导模式。\n        - 超长编码。\n        - 代理项代码点。\n        - 大于 $0x10FFFF$ 的代码点。\n- **测试套件**：提供了 $15$ 个特定的字节数组测试用例进行验证。\n- **最终输出格式**：包含用方括号括起来的逗号分隔的整数结果（$0$ 或 $1$）的单行，例如 `[result_1,result_2,...,result_15]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据既定的验证标准对问题进行评估。\n\n- **科学依据**：该问题牢固地植根于计算机科学，特别是在 UTF-8 编码方案（RFC 3629）的标准定义中。所有的定义和约束（字节结构、代码点范围、代理块、超长形式）在事实上都是正确的，并与既定标准一致。\n- **适定性**：该问题是适定的。输入是明确定义的字节数组，要求的输出是确定性的布尔分类（$1$ 表示有效，$0$ 表示无效）。所提供的规则是充分且明确的，对于任何给定的字节流都能导出一个唯一且有意义的解决方案。\n- **客观性**：语言精确且技术性强。它避免了主观性、模糊性和观点。所有术语要么是计算机组成和体系结构中的标准术语，要么被明确定义。\n\n该问题没有表现出任何列出的无效性缺陷。它是一个基于数字逻辑和数据编码基本原则的、形式化的、自洽的、可验证的问题。\n\n### 步骤 3：结论与行动\n问题被判定为**有效**。将根据提供的规范开发解决方案。\n\n### 解决方案推导\n\n从第一性原理设计 UTF-8 验证器需要对输入字节流进行系统性的、基于状态的遍历。必须对每个字节进行分类，并验证其所属序列的完整性。此过程依赖于位运算来检查每个字节的二进制结构。一个 $8$ 位字节在实现中将表示为 `unsigned char`，以防止在位操作期间发生符号扩展伪影。\n\n我们首先使用二进制掩码来形式化字节模式。字节和掩码之间的按位与（AND）运算（``）使我们能够隔离和测试特定的比特组。\n\n1.  **使用位掩码进行字节分类**：\n    字节的最高有效位决定了它在 UTF-8 序列中的角色。我们可以推导出掩码来识别每种类型的字节：\n    - **单字节（ASCII）**：模式是 `$0xxxxxxx$`。最高有效位必须为 $0$。我们通过与 `$10000000_2$`（或 `$0x80$`）进行掩码操作来测试这一点。如果 `(b  0x80) == 0x00`，则字节 `b` 是一个单字节字符。\n    - **延续字节**：模式是 `$10xxxxxx$`。最高的两个有效位必须是 `$10$`。我们通过与 `$11000000_2$`（或 `$0xC0$`）进行掩码操作，并将结果与 `$10000000_2$`（或 `$0x80$`）进行比较来测试这一点。如果 `(b  0xC0) == 0x80`，则字节 `b` 是一个延续字节。\n    - **双字节前导字节**：模式是 `$110xxxxx$`。最高的三个有效位必须是 `$110$`。掩码是 `$11100000_2$`（或 `$0xE0$`），期望的结果是 `$11000000_2$`（或 `$0xC0$`）。条件是 `(b  0xE0) == 0xC0`。\n    - **三字节前导字节**：模式是 `$1110xxxx$`。最高的四个有效位必须是 `$1110$`。掩码是 `$11110000_2$`（或 `$0xF0$`），期望的结果是 `$11100000_2$`（或 `$0xE0$`）。条件是 `(b  0xF0) == 0xE0`。\n    - **四字节前导字节**：模式是 `$11110xxx$`。最高的五个有效位必须是 `$11110$`。掩码是 `$11111000_2$`（或 `$0xF8$`），期望的结果是 `$11110000_2$`（或 `$0xF0$`）。条件是 `(b  0xF8) == 0xF0`。\n    - **无效字节**：任何不匹配上述模式之一的字节作为起始字节都是无效的。这包括游离的延续字节（已覆盖）以及具有 `$11111xxx$` 等模式的字节（例如 `$0xF8$`、`$0xFC$`），这些曾是过时的 $5$ 字节和 $6$ 字节 UTF-8 规范的一部分。\n\n2.  **状态处理算法**：\n    验证器将遍历字节数组。任何时刻的状态由期望的延续字节数决定。\n    - 设 `i` 为长度为 `L` 的字节数组的索引。只要 `i  L`，循环就继续进行。\n    - 在索引 `i` 处，读取字节 `b = data[i]`。\n    - 将 `b` 分类为前导字节。根据其类型，确定后续期望的延续字节数 `n_cont`。\n        - 如果 `(b  0x80) == 0x00`，则为 $1$ 字节序列。`n_cont = 0`。序列长度为 $1$。\n        - 如果 `(b  0xE0) == 0xC0`，则为 $2$ 字节序列。`n_cont = 1`。序列长度为 $2$。\n        - 如果 `(b  0xF0) == 0xE0`，则为 $3$ 字节序列。`n_cont = 2`。序列长度为 $3$。\n        - 如果 `(b  0xF8) == 0xF0`，则为 $4$ 字节序列。`n_cont = 3`。序列长度为 $4$。\n        - 否则，字节 `b` 是一个无效的起始字节（例如，游离的延续字节或像 `$0xF8$` 这样的无效模式）。整个流无效。\n    - 在识别出总长度为 `T = n_cont + 1` 的多字节序列的前导字节后：\n        - **检查不完整序列**：验证数组中是否还有足够的字节。必须满足 `i + T = L`。否则，序列不完整，因此无效。\n        - **验证延续字节**：对于 `n_cont` 个后续字节中的每一个 `data[i+j]`（其中 `j` 从 $1$ 到 `n_cont`），验证 `(data[i+j]  0xC0) == 0x80`。如果任何字节未能通过此测试，则序列无效。\n\n3.  **代码点重构与验证**：\n    在确认字节序列的结构完整性后，必须重构并验证 Unicode 代码点。这包括从每个字节中提取有效载荷比特并将它们拼接起来。\n    - 有效载荷比特通过掩码操作提取字节中携带数据的部分来获得。\n    - **1 字节序列 (`0xxxxxxx`)**：代码点就是字节值本身。由于其值小于 $0x80$，因此无需进一步验证。代码点：`data[i]`。\n    - **2 字节序列 (`110yyyyy 10zzzzzz`)**：有效载荷为 `yyyyyzzzzzz`。\n        - `val1 = data[i]  0x1F`（掩码 `$00011111_2$`）\n        - `val2 = data[i+1]  0x3F`（掩码 `$00111111_2$`）\n        - 代码点：`(val1  6) | val2`。\n        - 验证：不得超长。代码点必须 $\\ge 0x80$。\n    - **3 字节序列 (`1110wwww 10yyyyyy 10zzzzzz`)**：有效载荷为 `wwwwyyyyyyzzzzzz`。\n        - `val1 = data[i]  0x0F`（掩码 `$00001111_2$`）\n        - `val2 = data[i+1]  0x3F`\n        - `val3 = data[i+2]  0x3F`\n        - 代码点：`(val1  12) | (val2  6) | val3`。\n        - 验证：不得超长（代码点 $\\ge 0x800$）。不得是代理项（代码点不在范围 $[0xD800, 0xDFFF]$ 内）。\n    - **4 字节序列 (`11110vvv 10wwwwww 10yyyyyy 10zzzzzz`)**：有效载荷 `vvvwwwwwwyyyyyyzzzzzz`。\n        - `val1 = data[i]  0x07`（掩码 `$00000111_2$`）\n        - `val2 = data[i+1]  0x3F`\n        - `val3 = data[i+2]  0x3F`\n        - `val4 = data[i+3]  0x3F`\n        - 代码点：`(val1  18) | (val2  12) | (val3  6) | val4`。\n        - 验证：不得超长（代码点 $\\ge 0x10000$）。必须在 Unicode 范围内（代码点 $\\le 0x10FFFF$）。\n\n    如果任何验证检查失败，则整个流被声明为无效。如果一个序列的所有检查都通过，则主索引 `i` 按该序列中的字节数（`T`）递增，并从下一个字节继续处理。如果循环成功完成，处理完数组中的所有字节，则流有效。",
            "answer": "```c\n#include"
        },
        {
            "introduction": "UTF-8 的可变长度特性带来了另一个主要的性能挑战：低效的随机访问。这项练习将关注点从吞吐量转向延迟，解决如何快速定位字符串中第 $N$ 个字符的问题。你将分析一种分层跳跃算法，这是一种基于数据结构的方法，通过建立索引来避免缓慢的顺序扫描，并量化其性能优势。",
            "id": "3686841",
            "problem": "一个系统将文本存储为 UCS 转换格式 $8$ 位（UTF-8）编码的 Unicode 码点序列，其中每个码点占用 $1$ 到 $4$ 个字节。设字符串由一个指向其第一个字节的基指针 $P_{0}$ 寻址。给定一个目标码点索引 $i$（从字符串开头计数，从 $0$ 开始），你必须计算从 $P_{0}$ 到码点 $i$ 的起始字节的字节偏移量。\n\n为了加速随机访问，该系统预先计算了一个由整数粒度 $g \\ge 2$ 参数化的跳表层级结构。对于每个层级 $\\ell \\in \\{1,2,\\dots\\}$，层级-$\\ell$ 的表为每个码点位置是 $g^{\\ell}$ 的倍数的块边界存储从 $P_{0}$ 到该边界的累积字节偏移量。假设存在用于处理给定 $i$ 所需的所有层级的表。\n\n考虑以下自顶向下的跳跃算法。设 $L$ 为满足 $g^{L} \\le i$ 的最大整数。从层级 $L$ 开始，降至层级 $1$，在每个层级，于不超过 $i$ 的最大层级-$\\ell$ 块边界处执行一次查表操作，以将当前字节指针向前跳转到该边界。完成层级 $1$ 后，执行最终的顺序解码，解码剩余的码点以到达索引 $i$，每个解码步骤前进一个码点。将每次查表视为耗费 $1$ 步，每次顺序码点解码视为耗费 $1$ 步；忽略所有其他成本和影响。\n\n假设 $i \\ge 1$。仅根据这些定义和算法结构，推导出以下两种情况的闭式表达式（用 $i$ 和 $g$ 表示）：\n- 在 $i$ 在其最低层级块内的所有可能对齐方式下，算法所采取的最坏情况总步数，以及\n- 当 $i$ 在其最低层级块内的位置均匀分布于 $\\{0,1,\\dots,g-1\\}$ 时，算法所采取的平均情况总步数。\n\n将最终答案表示为一个二元行向量 $\\bigl[S_{\\text{worst}}(i,g),\\,S_{\\text{avg}}(i,g)\\bigr]$。无需四舍五入，最终答案中不包含单位。",
            "solution": "用户希望我解决一个关于在 UTF-8 编码字符串中查找字符字节偏移量的算法性能问题。我必须首先验证问题陈述，如果有效，则提供完整的解决方案。\n\n### 第 1 步：提取已知条件\n- **编码**：文本是 UCS 转换格式 $8$ 位（UTF-8）编码的 Unicode 码点序列。\n- **码点大小**：每个码点占用 $1$ 到 $4$ 个字节。\n- **寻址**：基指针 $P_{0}$ 指向字符串的第一个字节。\n- **目标**：计算从 $P_{0}$ 到索引为 $i$（$0$ 基索引的码点计数）的码点的起始字节的字节偏移量。\n- **加速结构**：一个由整数粒度 $g \\ge 2$ 参数化的跳表层级结构。\n- **表定义**：对于每个层级 $\\ell \\in \\{1, 2, \\dots\\}$，一个表存储对于每个码点位置是 $g^{\\ell}$ 的倍数的块边界，从 $P_0$ 开始的累积字节偏移量。\n- **算法**：定义了一个自顶向下的跳跃算法：\n    1.  设 $L$ 为满足 $g^{L} \\le i$ 的最大整数。\n    2.  从层级 $\\ell=L$ 开始，降至 $\\ell=1$，在每个层级，于不超过 $i$ 的最大层级-$\\ell$ 块边界处执行一次查表操作。这个跳转将当前字节指针向前移动。\n    3.  在循环完成（层级 1 之后）后，执行顺序解码，一次一个码点，直到达到索引 $i$。\n- **成本模型**：\n    - 每次查表耗费 $1$ 步。\n    - 每次顺序码点解码耗费 $1$ 步。\n    - 所有其他成本均被忽略。\n- **约束**：目标索引 $i \\ge 1$。\n- **要求输出**：\n    1.  $S_{\\text{worst}}(i,g)$：最坏情况总步数的闭式表达式，考虑 $i$ 在其最低层级块（大小为 $g$）内的所有可能对齐方式。\n    2.  $S_{\\text{avg}}(i,g)$：平均情况总步数的闭式表达式，假设 $i$ 在其最低层级块内的位置均匀分布于 $\\{0, 1, \\dots, g-1\\}$。\n- **最终答案格式**：一个二元行向量 $\\bigl[S_{\\text{worst}}(i,g), S_{\\text{avg}}(i,g)\\bigr]$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学基础**：该问题在计算机科学领域，特别是在文本处理的数据结构和算法方面，有坚实的基础。使用跳表（或类似的索引结构）来加速对像 UTF-8 这样的可变长度编码数据的访问是一个标准且实用的概念。\n- **良构性**：算法的步骤和成本模型都已明确定义。需要推导的量 $S_{\\text{worst}}(i,g)$ 和 $S_{\\text{avg}}(i,g)$ 有清晰的说明。问题是自包含的，并提供了推导唯一解所需的所有信息。\n- **客观性**：问题以正式、客观的语言陈述，没有歧义或主观元素。\n- **缺陷检查**：\n    1.  **科学/事实不健全**：无。该模型是一个简化，但没有违反任何基本原则。\n    2.  **不可形式化/不相关**：问题是可形式化的，并且与计算机科学直接相关。\n    3.  **不完整/矛盾的设置**：设置是完整和一致的。算法的定义是规定性的，足以进行分析。\n    4.  **不切实际/不可行**：成本模型是简化的，但对于理论分析而言并非不切实际。\n    5.  **病态/结构不良**：问题结构良好，可以导出一个确定的解析解。\n    6.  **伪深刻/琐碎**：该问题需要对其参数方面的算法复杂性进行非琐碎的分析，涉及对数和模运算。\n    7.  **超出科学可验证性**：推导出的表达式在数学上是可验证的。\n\n### 第 3 步：结论与行动\n问题被确定为有效。下面提供完整的解决方案。\n\n总步数 $S(i,g)$ 是查表步数和顺序解码步数之和。我们分别分析每个部分。\n\n**1. 查表步数**\n\n算法从层级 $\\ell=L$ 向下到 $1$ 执行查找。$L$ 定义为满足 $g^L \\le i$ 的最大整数。这等价于以 $g$ 为底的 $i$ 的对数的向下取整的定义，所以 $L = \\lfloor \\log_g(i) \\rfloor$。\n\n循环从 $\\ell = L, L-1, \\dots, 1$ 运行。如果 $L \\ge 1$，这个循环执行 $L$ 次。如果 $L=0$（当 $1 \\le i  g$ 时发生），循环不执行，查找次数为 $0$。因此，对于所有 $i \\ge 1$，查找次数可以表示为 $\\lfloor \\log_g(i) \\rfloor$。\n\n每次查找耗费 $1$ 步。因此，查表的总成本是 $\\lfloor \\log_g(i) \\rfloor$。\n\n**2. 顺序解码步数**\n\n顺序解码阶段在所有查表操作完成后开始。算法描述意味着一系列的跳转有效地为最终扫描定位了指针。最细粒度的信息来自层级-1的表，其边界位于 $g^1=g$ 的倍数处。在层级 $\\ell=1$ 的查找是在不超过 $i$ 的最大块边界处执行的，即索引为 $\\lfloor i/g \\rfloor \\cdot g$ 的码点。\n\n在最后一次查找之后，概念上的指针位于索引 $j = \\lfloor i/g \\rfloor \\cdot g$。然后，顺序扫描必须从索引 $j$ 前进到目标索引 $i$。需要解码的码点数是 $i - j$。每次解码耗费 $1$ 步。\n\n扫描步数是 $i - \\lfloor i/g \\rfloor \\cdot g$。这个表达式对于非负的 $i$ 和 $g$ 是 $i$ 除以 $g$ 的整数除法的余数的定义。这通常写作 $i \\pmod g$。\n\n**3. 总步数**\n\n结合这些成本，给定索引 $i$ 的总步数为：\n$$S(i,g) = (\\text{查表步数}) + (\\text{扫描步数}) = \\lfloor \\log_g(i) \\rfloor + (i \\pmod g)$$\n\n**4. 最坏情况和平均情况分析**\n\n题目要求我们找到在 $i$ 的“最低层级块”（一个大小为 $g$ 的块）内的所有可能对齐方式下的最坏情况和平均情况步数。$i$ 在其块内的对齐或位置由 $r = i \\pmod g$ 给出，其中 $r \\in \\{0, 1, \\dots, g-1\\}$。\n\n分析需要评估当 $r$ 变化时 $S(i,g)$ 的值。设包含 $i$ 的块起始于索引 $k \\cdot g$，其中 $k = \\lfloor i/g \\rfloor$。该块内的任何索引 $i'$ 都可以写成 $i' = k \\cdot g + r$，其中 $r \\in \\{0, 1, \\dots, g-1\\}$。这样一个索引 $i'$ 的成本是：\n$$S(i',g) = \\lfloor \\log_g(k \\cdot g + r) \\rfloor + r$$\n\n我们必须确定项 $\\lfloor \\log_g(k \\cdot g + r) \\rfloor$ 对于 $r \\in \\{0, 1, \\dots, g-1\\}$ 是否是常数。一个索引块的形式是 $[k \\cdot g, k \\cdot g + g - 1]$。对数项仅在其参数跨越 $g$ 的幂时才会改变。一个 $g$ 的幂，比如 $g^m$，只有当 $g^m$ 是 $g$ 的倍数时才能成为一个块的开始，这对于 $m \\ge 1$ 是成立的。对于任何 $k \\ge 1$ 和 $g \\ge 2$，块 $[k \\cdot g, k \\cdot g + g - 1]$ 不会跨越 $g$ 的整数次幂。对于 $k=0$（且 $i \\ge 1$），块是 $[1, g-1]$，在此范围内 $\\lfloor \\log_g(i') \\rfloor = 0$。因此，对于任何给定的块，项 $\\lfloor \\log_g(i') \\rfloor$ 是常数，等于 $\\lfloor \\log_g(i) \\rfloor$，其中 $i$ 是该块内的任何索引。\n\n设 $L_i = \\lfloor \\log_g(i) \\rfloor$。具有对齐方式 $r$ 的索引的成本是 $L_i + r$。\n\n**最坏情况步数, $S_{\\text{worst}}(i,g)$**\n\n为了找到最坏情况，我们必须最大化成本函数 $L_i + r$ 相对于 $r \\in \\{0, 1, \\dots, g-1\\}$。因为 $L_i$ 对于该块是常数，我们只需最大化 $r$。$r$ 的最大值是 $g-1$。\n\n$$S_{\\text{worst}}(i,g) = L_i + \\max_{r \\in \\{0, \\dots, g-1\\}} (r) = \\lfloor \\log_g(i) \\rfloor + g - 1$$\n\n**平均情况步数, $S_{\\text{avg}}(i,g)$**\n\n对于平均情况，我们假设对齐方式 $r$ 在 $\\{0, 1, \\dots, g-1\\}$ 上均匀分布。我们需要找到成本函数 $L_i + r$ 的平均值。\n$$S_{\\text{avg}}(i,g) = E[L_i + r] = E[L_i] + E[r]$$\n因为 $L_i$ 是常数，所以 $E[L_i] = L_i = \\lfloor \\log_g(i) \\rfloor$。\n$r$ 的期望是从 $0$ 到 $g-1$ 的整数的平均值：\n$$E[r] = \\frac{1}{g} \\sum_{r=0}^{g-1} r = \\frac{1}{g} \\cdot \\frac{(g-1)g}{2} = \\frac{g-1}{2}$$\n结合这些结果，平均情况的步数是：\n$$S_{\\text{avg}}(i,g) = \\lfloor \\log_g(i) \\rfloor + \\frac{g-1}{2}$$\n\n最终答案是这两个表达式的组合。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\lfloor \\log_g(i) \\rfloor + g - 1  \\lfloor \\log_g(i) \\rfloor + \\frac{g-1}{2}\n\\end{pmatrix}\n}\n$$"
        }
    ]
}