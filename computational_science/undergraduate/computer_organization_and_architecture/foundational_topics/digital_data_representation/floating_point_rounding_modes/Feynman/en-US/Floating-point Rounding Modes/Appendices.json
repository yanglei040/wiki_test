{
    "hands_on_practices": [
        {
            "introduction": "Mastering floating-point arithmetic begins with understanding how infinitely precise mathematical results are mapped into a finite number of bits. The IEEE 754 standard defines four distinct rounding modes to manage this process: round to nearest ($\\text{RN}$), round toward zero ($\\text{RZ}$), round toward positive infinity ($\\text{RU}$), and round toward negative infinity ($\\text{RD}$). This first exercise  provides a foundational workout, challenging you to apply all four modes to a single calculation and observe how the choice of mode directly impacts the final stored value.",
            "id": "3642267",
            "problem": "Consider a system that conforms to the Institute of Electrical and Electronics Engineers (IEEE) 754 standard for floating-point arithmetic, using the single-precision binary format (binary32). A normalized binary32 floating-point number is represented by a sign bit, an exponent field of 8 bits with bias 127, and a fraction field of 23 bits forming the significand of the form $(1.f)_2$, where $f$ is a 23-bit fractional binary string. Around values in the interval $[1,2)$, successive representable numbers differ by one unit in the last place of the fraction.\n\nLet $x=1.0$ and $y=2^{-25}$. Assume the exact real-valued sum $x+y$ is computed and then rounded once to the nearest representable binary32 number under each of the four IEEE 754 rounding modes: round to nearest, ties to even ($\\text{RN}$), round toward zero ($\\text{RZ}$), round toward $+\\infty$ ($\\text{RU}$), and round toward $-\\infty$ ($\\text{RD}$).\n\nUsing only the foundational definitions of binary normalized significands and the semantics of the four rounding modes, determine the rounded results of $x+y$ in binary32 under $\\text{RN}$, $\\text{RZ}$, $\\text{RU}$, and $\\text{RD}$. Express your final answer as a row matrix in the order $\\text{RN}$, $\\text{RZ}$, $\\text{RU}$, $\\text{RD}$. No numerical approximation is required; provide exact values.",
            "solution": "The problem requires determining the results of rounding the sum of two numbers, $x=1.0$ and $y=2^{-25}$, in the IEEE 754 single-precision (binary32) format under four specified rounding modes.\n\nFirst, we must validate the problem statement.\n\n### Step 1: Extract Givens\n- System: IEEE 754 standard, single-precision binary format (binary32).\n- Normalized binary32 number representation:\n  - $1$ sign bit.\n  - $8$-bit exponent field with a bias of $127$.\n  - $23$-bit fraction field, denoted as $f$.\n- Significand form for normalized numbers: $(1.f)_2$.\n- In the interval $[1,2)$, the difference between successive representable numbers is one unit in the last place (ULP) of the fraction.\n- Given values: $x=1.0$ and $y=2^{-25}$.\n- Task: Compute the exact sum $z=x+y$ and round it to the nearest representable binary32 number for each of the four rounding modes:\n  - $\\text{RN}$: round to nearest, ties to even.\n  - $\\text{RZ}$: round toward zero.\n  - $\\text{RU}$: round toward $+\\infty$.\n  - $\\text{RD}$: round toward $-\\infty$.\n- Output format: A row matrix of the four results in the order $\\text{RN}$, $\\text{RZ}$, $\\text{RU}$, $\\text{RD}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it is based on the well-defined IEEE 754 standard for floating-point arithmetic, a fundamental topic in computer architecture and numerical analysis. The language is precise and objective. All necessary information (number format, bias, values, rounding modes) is provided, making the problem well-posed and self-contained. There are no contradictions, ambiguities, or scientifically unsound premises. The problem tests a core concept of floating-point arithmetic and is not trivial.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe solution proceeds by first calculating the exact real-valued sum and then determining its relationship to the nearest representable binary32 floating-point numbers.\n\n1.  **Analyze the inputs and their exact sum.**\n    The given values are $x=1.0$ and $y=2^{-25}$.\n    The number $x=1.0$ is an exactly representable number in the binary32 format. Its representation is:\n    - Sign bit: $0$ (positive).\n    - Unbiased exponent: $0$, since $1.0 = (1.0)_2 \\times 2^0$.\n    - Biased exponent: $E = 0 + 127 = 127$.\n    - Fraction: $f = 0$, since the significand is $(1.0)_2$.\n\n    The exact real-valued sum is $z = x+y = 1.0 + 2^{-25}$.\n\n2.  **Identify the bracketing representable numbers.**\n    The value of the sum $z$ lies in the interval $[1,2)$. For any value $v$ in this interval, a normalized binary32 representation is of the form $v = (-1)^S \\times (1.f)_2 \\times 2^0$, where $f$ is the $23$-bit fraction. The unit in the last place (ULP) for this range is the value of the least significant bit of the fraction, which is $2^{-23}$.\n    Successive representable numbers in this range are separated by $2^{-23}$.\n\n    The exact sum is $z = 1.0 + 2^{-25}$. This value is not exactly representable because its fractional part, $2^{-25}$, requires more than $23$ bits of precision after the binary point. We need to find the two representable numbers that bracket $z$.\n\n    Let $N_1$ be the largest representable number less than or equal to $z$. This number is obtained by truncating the binary representation of $z$ to $23$ fractional bits.\n    $z = 1.0 + 2^{-25} = (1.\\underbrace{00\\dots0}_{24}1)_2 \\times 2^0$.\n    Truncating after the $23^{rd}$ fractional bit gives the significand $(1.\\underbrace{00\\dots0}_{23})_2$.\n    Thus, $N_1 = (1.0)_2 \\times 2^0 = 1.0$.\n\n    Let $N_2$ be the smallest representable number greater than or equal to $z$. This is the next representable number after $N_1$.\n    $N_2 = N_1 + \\text{ULP} = 1.0 + 2^{-23}$.\n\n    We can confirm that $N_1 < z < N_2$:\n    $1.0 < 1.0 + 2^{-25} < 1.0 + 2^{-23}$ since $0 < 2^{-25} < 2^{-23}$.\n\n3.  **Apply the rounding modes.**\n    The choice of rounding depends on the specific mode and, for $\\text{RN}$, on the position of $z$ relative to the midpoint $M$ of the interval $[N_1, N_2]$.\n    The midpoint is $M = \\frac{N_1 + N_2}{2} = \\frac{1.0 + (1.0 + 2^{-23})}{2} = 1.0 + \\frac{2^{-23}}{2} = 1.0 + 2^{-24}$.\n\n    - **Round to Nearest, ties to even ($\\text{RN}$):**\n      We compare $z$ to the midpoint $M$.\n      $z = 1.0 + 2^{-25}$\n      $M = 1.0 + 2^{-24}$\n      Since $2^{-25} < 2^{-24}$, we have $z < M$. This means $z$ is closer to $N_1$ than to $N_2$. There is no tie. The rule requires rounding to the nearest representable number, which is $N_1$.\n      Result for $\\text{RN}$: $1.0$.\n\n    - **Round toward Zero ($\\text{RZ}$):**\n      This mode truncates the value towards $0$. For a positive number such as $z$, this means rounding down to the largest representable number that is less than or equal to $z$. This is $N_1$.\n      Result for $\\text{RZ}$: $1.0$.\n\n    - **Round toward $+\\infty$ ($\\text{RU}$):**\n      This mode rounds the value up to the smallest representable number that is greater than or equal to $z$. Since $z$ is not exactly representable, this is $N_2$.\n      Result for $\\text{RU}$: $1.0 + 2^{-23}$.\n\n    - **Round toward $-\\infty$ ($\\text{RD}$):**\n      This mode rounds the value down to the largest representable number that is less than or equal to $z$. For any number, this corresponds to $N_1$.\n      Result for $\\text{RD}$: $1.0$.\n\n4.  **Final Results.**\n    The rounded results for the sum $x+y$ under the four specified rounding modes are:\n    - $\\text{RN}(x+y) = 1.0$\n    - $\\text{RZ}(x+y) = 1.0$\n    - $\\text{RU}(x+y) = 1.0 + 2^{-23}$\n    - $\\text{RD}(x+y) = 1.0$",
            "answer": "$$\\boxed{\\begin{pmatrix} 1.0 & 1.0 & 1.0 + 2^{-23} & 1.0 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Floating-point numbers harbor subtleties not present in real-number arithmetic, one of the most notable being signed zero. While $+0$ and $-0$ compare as equal, their sign carries information that is critical for certain algorithms, especially when dealing with functions that have discontinuities at zero. This practice  reveals how the choice between two seemingly similar rounding modes—round toward zero and round toward negative infinity—can determine the sign of a zero result, showcasing a nuanced but important feature of the IEEE 754 standard.",
            "id": "3642510",
            "problem": "You are given the Institute of Electrical and Electronics Engineers (IEEE) 754 Standard binary32 (single precision) floating-point format. Consider the two decimal inputs $x_{\\mathrm{dec}} = 1.0000001$ and $y_{\\mathrm{dec}} = 1.0000000$. Computation follows the IEEE 754 model: each decimal input is first converted to a binary32 datum under the currently active rounding mode, then the exact real subtraction is performed, and finally the exact result is rounded to binary32 under the same rounding mode.\n\nTwo rounding modes are to be considered:\n1. Round toward zero.\n2. Round toward negative infinity.\n\nUsing only foundational properties of IEEE 754 binary32 and its rounding modes, determine the final floating-point results of computing $x - y$ under each of the two modes, including the sign of zero if the result is zero. You may use the following facts as starting points:\n- In binary32, numbers in the interval $[1,2)$ have spacing (Unit in the Last Place (ULP)) equal to $2^{-23}$.\n- The value $y_{\\mathrm{dec}} = 1.0000000$ is exactly representable in binary32.\n- Round toward zero maps a real number to the representable value of the same sign whose magnitude is less than or equal to the exact value; round toward negative infinity maps a real number to the greatest representable value less than or equal to the exact value.\n\nExpress your final answer as a $1 \\times 2$ row matrix $\\big[z_{\\mathrm{tz}} \\;\\; z_{-\\infty}\\big]$, where $z_{\\mathrm{tz}}$ is the computed result under round toward zero and $z_{-\\infty}$ is the computed result under round toward negative infinity. If a zero arises, indicate its sign by writing $-0$ for negative zero and $0$ for positive zero. No decimal-place rounding is required.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Floating-point format:** Institute of Electrical and Electronics Engineers (IEEE) 754 `binary32` (single precision).\n- **Decimal inputs:** $x_{\\mathrm{dec}} = 1.0000001$ and $y_{\\mathrm{dec}} = 1.0000000$.\n- **Computation model:**\n    1. Each decimal input is converted to a `binary32` datum under the active rounding mode.\n    2. The exact real subtraction of the converted numbers is performed.\n    3. The exact result is rounded to `binary32` under the same rounding mode.\n- **Rounding modes to consider:**\n    1. Round toward zero ($z_{\\mathrm{tz}}$).\n    2. Round toward negative infinity ($z_{-\\infty}$).\n- **Provided facts:**\n    1. In `binary32`, for numbers in the interval $[1, 2)$, the spacing (Unit in the Last Place, ULP) is $2^{-23}$.\n    2. The value $y_{\\mathrm{dec}} = 1.0000000$ is exactly representable in `binary32`.\n    3. The definitions of the two rounding modes are provided.\n- **Required output:** A $1 \\times 2$ row matrix $\\begin{pmatrix} z_{\\mathrm{tz}} & z_{-\\infty} \\end{pmatrix}$, indicating the sign of zero if applicable.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined and scientifically sound. It is based on the standard IEEE 754 for floating-point arithmetic, a fundamental topic in computer architecture and numerical computation. All terms are precisely defined, and the required data is provided. The premises are factually correct: the ULP for `binary32` numbers in $[1, 2)$ is indeed $2^{-23}$, and $1.0$ is an exactly representable value. The problem is formalizable and solvable. Therefore, the problem is deemed valid.\n\n### Step 3: Solution\nThe overall computation for a result $z$ given decimal inputs $x_{\\mathrm{dec}}$ and $y_{\\mathrm{dec}}$ and a rounding mode $\\text{round}_{\\text{mode}}$ is given by:\n$$z = \\text{round}_{\\text{mode}} \\left( \\text{round}_{\\text{mode}}(x_{\\mathrm{dec}}) - \\text{round}_{\\text{mode}}(y_{\\mathrm{dec}}) \\right)$$\n\nLet's first analyze the representation of the inputs in the `binary32` format.\n\nThe input $y_{\\mathrm{dec}} = 1.0$ is stated to be exactly representable. Therefore, its conversion to `binary32` under any rounding mode will yield the exact value $1.0$. We denote this floating-point number as $y_{fp}$.\n$$y_{fp} = \\text{round}_{\\text{mode}}(y_{\\mathrm{dec}}) = 1.0 \\quad (\\text{for any mode})$$\n\nNow, let's analyze the input $x_{\\mathrm{dec}} = 1.0000001$. We need to determine its position relative to the neighboring `binary32` representable numbers. The problem states that for numbers in the range $[1, 2)$, the interval between consecutive representable numbers (the ULP) is $2^{-23}$. The number $1.0$ is representable. The next representable number greater than $1.0$ is $1.0 + 2^{-23}$.\nLet's evaluate the ULP:\n$$2^{-23} = \\frac{1}{2^{23}} = \\frac{1}{8388608} = 0.00000011920928955...$$\nWe compare $x_{\\mathrm{dec}}$ to the value of this next representable number:\n$$x_{\\mathrm{dec}} = 1.0000001$$\n$$1.0 + 2^{-23} \\approx 1.0000001192$$\nFrom this comparison, it is evident that $x_{\\mathrm{dec}}$ lies strictly between two consecutive `binary32` numbers:\n$$1.0 < x_{\\mathrm{dec}} < 1.0 + 2^{-23}$$\n\nWe now proceed to calculate the final result for each specified rounding mode.\n\n**1. Round toward zero (tz)**\n\nFirst, we convert the inputs to `binary32` using this mode. Let's denote the conversion of $x_{\\mathrm{dec}}$ as $x_{fp, \\mathrm{tz}}$.\n- For $y_{\\mathrm{dec}}$, $y_{fp, \\mathrm{tz}} = 1.0$.\n- For $x_{\\mathrm{dec}}$, the \"round toward zero\" mode maps a real number to the representable value of the same sign with a magnitude less than or equal to the real number's magnitude. For a positive number, this is equivalent to truncation. Since $1.0 < x_{\\mathrm{dec}} < 1.0 + 2^{-23}$, the largest representable number that is less than or equal to $x_{\\mathrm{dec}}$ is $1.0$.\n$$x_{fp, \\mathrm{tz}} = \\text{round}_{\\mathrm{tz}}(1.0000001) = 1.0$$\nNext, we perform the exact subtraction on the converted floating-point numbers:\n$$z_{exact, \\mathrm{tz}} = x_{fp, \\mathrm{tz}} - y_{fp, \\mathrm{tz}} = 1.0 - 1.0 = 0.0$$\nFinally, we round the exact result $z_{exact, \\mathrm{tz}}$ to `binary32`. The value $0.0$ is exactly representable, so the rounding operation does not change its value. The only remaining consideration is the sign. According to the IEEE 754 standard (section 6.3), when the difference of two operands with like signs results in an exact zero, the sign of the result is positive in all rounding modes except \"round toward negative infinity\". Since the current mode is \"round toward zero\", the result is positive zero, denoted as $0$.\n$$z_{\\mathrm{tz}} = \\text{round}_{\\mathrm{tz}}(0.0) = +0$$\n\n**2. Round toward negative infinity ($-\\infty$)**\n\nFirst, we convert the inputs to `binary32` using this mode. Let's denote the conversion of $x_{\\mathrm{dec}}$ as $x_{fp, -\\infty}$.\n- For $y_{\\mathrm{dec}}$, $y_{fp, -\\infty} = 1.0$.\n- For $x_{\\mathrm{dec}}$, the \"round toward negative infinity\" mode maps a real number to the greatest representable value less than or equal to it. Since $1.0 < x_{\\mathrm{dec}} < 1.0 + 2^{-23}$, the greatest representable number less than or equal to $x_{\\mathrm{dec}}$ is $1.0$.\n$$x_{fp, -\\infty} = \\text{round}_{-\\infty}(1.0000001) = 1.0$$\nNext, we perform the exact subtraction:\n$$z_{exact, -\\infty} = x_{fp, -\\infty} - y_{fp, -\\infty} = 1.0 - 1.0 = 0.0$$\nFinally, we round the exact result $z_{exact, -\\infty}$ to `binary32`. The value $0.0$ is exactly representable. We determine the sign using the IEEE 754 rule. For a difference of like-signed operands that is exactly zero, the sign is negative if and only if the rounding mode is \"round toward negative infinity\". This condition is met. Therefore, the result is negative zero, denoted as $-0$.\n$$z_{-\\infty} = \\text{round}_{-\\infty}(0.0) = -0$$\n\nCombining the results for both rounding modes into the required matrix format gives $\\begin{pmatrix} z_{\\mathrm{tz}} & z_{-\\infty} \\end{pmatrix}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0 & -0 \\end{pmatrix} } $$"
        },
        {
            "introduction": "One of the most common and dangerous assumptions programmers make is that floating-point arithmetic obeys the familiar laws of algebra, such as associativity. In reality, the accumulation of rounding errors means the order of operations can dramatically alter a result. This final practice  provides a stark demonstration of this principle, showing how a seemingly simple operation, $(y + a) - a$, can fail to return the original value $y$, a phenomenon that leads to baffling bugs in programs that rely on floating-point equality checks.",
            "id": "3642467",
            "problem": "A processor implements the Institute of Electrical and Electronics Engineers (IEEE) 754 binary32 (single precision) floating-point format. In binary32, a normalized floating-point number has a significand with $23$ explicitly stored fraction bits and an implicit leading $1$, giving a precision of $p=24$ bits. Arithmetic operations produce a real result that is then rounded according to the currently active rounding mode before being stored back in binary32. The available rounding modes include round-to-nearest ties-to-even, round-toward $+\\infty$, round-toward $-\\infty$, and round-toward $0$. The unit in the last place (ULP) at a given magnitude is the spacing between adjacent representable normalized numbers at that magnitude.\n\nA program first computes and stores the variable $y$ as the binary32 representation of the exact real number $1$, using the round-to-nearest ties-to-even mode. Later, due to a runtime change, the rounding mode is set to round-toward $+\\infty$ for all subsequent floating-point operations. In this changed environment, the program evaluates two consecutive operations in binary32:\n$$\nt \\leftarrow y + 2^{-24}, \\quad x \\leftarrow t - 2^{-24},\n$$\nwhere each operation is rounded according to round-toward $+\\infty$ at binary32 precision before the result is used by the next step. Immediately after computing $x$, the program branches on equality $x==y$.\n\nUsing only the core definitions of IEEE 754 binary floating-point representation, precision $p$, and the semantics of rounding modes, derive the exact value of $x - y$ as a single closed-form expression. Give your final answer as a power of two in exact form. No rounding of the final answer is required.",
            "solution": "The problem will be solved by a step-by-step analysis of the floating-point operations according to the IEEE 754 standard for binary32 format, with the specified rounding modes.\n\nFirst, we establish the value of the variable $y$. The problem states that $y$ is the binary32 representation of the exact real number $1$. The number $1$ is exactly representable in binary32. Its representation in binary scientific notation is $1.0 \\times 2^0$. For the binary32 format (single precision), the significand has a precision of $p=24$ bits ($1$ implicit leading bit and $23$ explicit fraction bits). The value $1$ is represented with a significand of $(1.00...0)_2$ (with $23$ zeros after the binary point) and an exponent of $0$. Since the value is exact, no rounding is necessary. Therefore, the value of $y$ is precisely:\n$$y = 1$$\n\nNext, the rounding mode is changed to round-toward $+\\infty$. We analyze the first computation:\n$$t \\leftarrow y + 2^{-24}$$\nThe exact real value of the sum is:\n$$R_t = y + 2^{-24} = 1 + 2^{-24}$$\nThis result must be rounded to fit into the binary32 format. A normalized binary32 number in the range $[1, 2)$ has the form $(1.f_{1}f_{2}...f_{23})_2 \\times 2^0$. The smallest increment between two such numbers is determined by the last bit of the fraction, $f_{23}$, which corresponds to a value of $2^{-23}$. This is the unit in the last place (ULP) for numbers in this range.\nLet us identify the two representable binary32 numbers that bracket the exact result $R_t$.\nThe number $1$ is representable: $N_1 = 1 = (1.00...0)_2 \\times 2^0$.\nThe next larger representable number is $N_2 = 1 + 2^{-23} = (1.00...1)_2 \\times 2^0$, where the final fraction bit is $1$.\n\nThe exact result $R_t = 1 + 2^{-24}$ lies between these two representable numbers. We can determine its position relative to them. The midpoint between $N_1$ and $N_2$ is:\n$$\\frac{N_1 + N_2}{2} = \\frac{1 + (1 + 2^{-23})}{2} = \\frac{2 + 2^{-23}}{2} = 1 + 2^{-24}$$\nThus, the exact result $R_t$ is exactly the midpoint between two consecutive representable numbers.\n\nThe active rounding mode is round-toward $+\\infty$. This mode dictates that any result that is not exactly representable must be rounded to the smallest representable number that is greater than or equal to the exact result. Since $R_t = 1 + 2^{-24}$ is not representable, it must be rounded up to the next representable value, which is $N_2$.\nTherefore, the value stored in the variable $t$ is:\n$$t = 1 + 2^{-23}$$\n\nNow, we analyze the second computation:\n$$x \\leftarrow t - 2^{-24}$$\nThe rounding mode is still round-toward $+\\infty$. We first find the exact real value of the difference, using the value of $t$ we just determined:\n$$R_x = t - 2^{-24} = (1 + 2^{-23}) - 2^{-24}$$\nTo simplify this expression, we can write $2^{-23}$ as $2 \\times 2^{-24}$:\n$$R_x = 1 + (2 \\times 2^{-24}) - 2^{-24} = 1 + (2-1) \\times 2^{-24} = 1 + 2^{-24}$$\nThe exact result $R_x$ is identical to the exact result $R_t$ from the previous step. It is the midpoint between the representable numbers $1$ and $1 + 2^{-23}$.\n\nWe must round $R_x$ using the round-toward $+\\infty$ mode. Just as before, the result is rounded up to the smallest representable number that is greater than or equal to $R_x$.\nTherefore, the value stored in the variable $x$ is:\n$$x = 1 + 2^{-23}$$\n\nFinally, the problem asks for the exact value of the difference $x-y$. Using the values we have derived for $x$ and $y$:\n$$x - y = (1 + 2^{-23}) - 1 = 2^{-23}$$\nThis result is derived from the mathematical values of $x$ and $y$, not a floating-point subtraction. The result is an exact power of two.",
            "answer": "$$\\boxed{2^{-23}}$$"
        }
    ]
}