{
    "hands_on_practices": [
        {
            "introduction": "Mastering any number system begins with the fundamentals of representation. This exercise provides essential practice in converting numbers between the familiar decimal system and one's complement binary, a process that is key to understanding how computers handle signed integers. By working through the encoding and decoding of various values, including the special cases of positive zero ($+0$) and negative zero ($-0$), you will build a solid foundation in the core rules of this representation .",
            "id": "3662341",
            "problem": "A digital system uses the one’s complement representation for signed $n$-bit integers. In one’s complement, positive values are encoded with a leading zero in the Most Significant Bit (MSB) and negative values are encoded by taking the bitwise complement of the positive encoding of the magnitude. There are two distinct encodings for zero, denoted $+0$ and $-0$. Consider the following two tasks that require conversion between decimal and one’s complement across two different word sizes.\n\nTask A (encoding for $n=5$ bits): Encode the decimal values $+7$, $-7$, $+0$, and $-0$ into $5$-bit one’s complement. For each resulting $5$-bit word, interpret the bits as an unsigned binary number to obtain an integer $U$. Let the four unsigned integers be $U_{+7}$, $U_{-7}$, $U_{+0}$, and $U_{-0}$.\n\nTask B (decoding for $n=6$ bits): Decode the following $6$-bit one’s complement words into signed decimal values: $101101$, $010010$, $111111$, and $000000$. Let the decoded decimal values be $D_{101101}$, $D_{010010}$, $D_{111111}$, and $D_{000000}$.\n\nUsing only the foundational definitions of one’s complement representation and without appealing to any memorized shortcut formulas, compute the quantity\n$$\nS = \\left(U_{+7} + U_{-7} + U_{+0} + U_{-0}\\right) + \\left(D_{101101} + D_{010010} + D_{111111} + D_{000000}\\right).\n$$\nProvide $S$ as a single integer. No rounding is required.",
            "solution": "The problem requires the computation of a sum $S$ derived from two tasks involving one's complement representation: an encoding task for a $5$-bit system and a decoding task for a $6$-bit system.\n\nThe problem statement has been validated and is deemed valid. It is scientifically sound, well-posed, and objective. All necessary definitions and data are provided. We proceed with the solution.\n\nThe solution is structured by first completing Task A, then Task B, and finally computing the total sum $S$.\n\n### Task A: Encoding for $n=5$ bits\n\nWe are asked to encode the decimal values $+7$, $-7$, $+0$, and $-0$ into $5$-bit one's complement and then interpret these binary words as unsigned integers.\n\n1.  **Encode $+7$**:\n    The number is positive, so its Most Significant Bit (MSB) must be $0$. The magnitude is $7$, which in binary is $111_2$. To represent $+7$ in a $5$-bit system, we pad the binary representation of the magnitude with leading zeros to a total length of $5$ bits.\n    $$ +7_{10} \\rightarrow 00111_2 $$\n    Interpreting $00111_2$ as an unsigned integer gives $U_{+7}$.\n    $$ U_{+7} = 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 0 + 4 + 2 + 1 = 7 $$\n\n2.  **Encode $-7$**:\n    The one's complement representation of a negative number is the bitwise complement of the representation of its positive magnitude. We take the complement of the binary word for $+7$.\n    $$ \\text{NOT}(00111_2) = 11000_2 $$\n    So, $-7_{10}$ is encoded as $11000_2$. Interpreting this as an unsigned integer gives $U_{-7}$.\n    $$ U_{-7} = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 8 + 0 + 0 + 0 = 24 $$\n\n3.  **Encode $+0$**:\n    The representation for positive zero ($+0$) is a bit string of all zeros.\n    $$ +0_{10} \\rightarrow 00000_2 $$\n    Interpreting $00000_2$ as an unsigned integer gives $U_{+0}$.\n    $$ U_{+0} = 0 $$\n\n4.  **Encode $-0$**:\n    The representation for negative zero ($-0$) is the bitwise complement of the representation for $+0$.\n    $$ \\text{NOT}(00000_2) = 11111_2 $$\n    Interpreting $11111_2$ as an unsigned integer gives $U_{-0}$.\n    $$ U_{-0} = 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 16 + 8 + 4 + 2 + 1 = 31 $$\n\nThe sum for Task A is:\n$$ U_{+7} + U_{-7} + U_{+0} + U_{-0} = 7 + 24 + 0 + 31 = 62 $$\nIt can be observed that for any value $x$, the sum of its unsigned interpretation $U_x$ and the unsigned interpretation of its one's complement negation $U_{-x}$ is $2^n-1$. Here, $n=5$, so $2^5-1=31$. Indeed, $U_{+7} + U_{-7} = 7 + 24 = 31$ and $U_{+0} + U_{-0} = 0 + 31 = 31$. The sum is $31 + 31 = 62$.\n\n### Task B: Decoding for $n=6$ bits\n\nWe are asked to decode four $6$-bit one's complement words into signed decimal values.\n\n1.  **Decode $101101_2$**:\n    The MSB is $1$, so this is a negative number. To find its magnitude, we take the bitwise complement.\n    $$ \\text{NOT}(101101_2) = 010010_2 $$\n    The magnitude is the decimal value of this complemented binary word.\n    $$ 010010_2 = 1 \\cdot 2^4 + 0 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 2 = 18 $$\n    Since the number is negative, its value is $-18$.\n    $$ D_{101101} = -18 $$\n\n2.  **Decode $010010_2$**:\n    The MSB is $0$, so this is a positive number. Its value is the direct interpretation of the binary word.\n    $$ 010010_2 = 1 \\cdot 2^4 + 1 \\cdot 2^1 = 16 + 2 = 18 $$\n    The value is $+18$.\n    $$ D_{010010} = 18 $$\n\n3.  **Decode $111111_2$**:\n    The MSB is $1$, so this is a negative number. This specific pattern of all ones represents negative zero ($-0$). To confirm, we take the bitwise complement.\n    $$ \\text{NOT}(111111_2) = 000000_2 $$\n    The magnitude is $0$. Thus, the value is $0$.\n    $$ D_{111111} = 0 $$\n\n4.  **Decode $000000_2$**:\n    The MSB is $0$. This pattern of all zeros represents positive zero ($+0$). Its value is $0$.\n    $$ D_{000000} = 0 $$\n\nThe sum for Task B is:\n$$ D_{101101} + D_{010010} + D_{111111} + D_{000000} = -18 + 18 + 0 + 0 = 0 $$\n\n### Final Calculation\n\nThe total sum $S$ is the sum of the results from Task A and Task B.\n$$ S = \\left(U_{+7} + U_{-7} + U_{+0} + U_{-0}\\right) + \\left(D_{101101} + D_{010010} + D_{111111} + D_{000000}\\right) $$\nSubstituting the computed values:\n$$ S = (62) + (0) = 62 $$\nThe final result is $62$.",
            "answer": "$$\\boxed{62}$$"
        },
        {
            "introduction": "Once you understand representation, the next step is performing arithmetic. One's complement subtraction is a signature operation that elegantly transforms subtraction into addition using bitwise inversion. This problem gives you a concrete opportunity to execute a subtraction, $M - S$, by calculating $M + \\overline{S}$ and handling the potential \"end-around carry,\" a defining feature of one's complement arithmetic .",
            "id": "1915012",
            "problem": "A micro-controller's 4-bit Arithmetic Logic Unit (ALU) is tasked with performing a subtraction operation. The ALU exclusively uses one's complement representation for signed numbers and for a subtraction operation of the form $M - S$, it calculates $M + (\\text{1's complement of } S)$.\n\nYour task is to determine the final 4-bit binary result of the operation $1001_2 - 1100_2$ as executed by this ALU. Present your final answer as a 4-bit binary string.",
            "solution": "In a 1's complement system, the negative of a binary number is obtained by bitwise complement. The ALU computes subtraction $M - S$ as $M + \\overline{S}$, where $\\overline{S}$ is the 1's complement of $S$, and uses 4-bit addition with end-around carry if generated.\n\nGiven $M = 1001_2$ and $S = 1100_2$, compute the 1's complement of $S$:\n$$\n\\overline{S} = \\overline{1100_2} = 0011_2.\n$$\nNow add $M$ and $\\overline{S}$ using 4-bit addition:\n$$\n1001_2 + 0011_2 = 1100_2.\n$$\nThere is no carry out of the most significant bit, so no end-around carry is added. Thus the final 4-bit result is $1100_2$.\n\nAs a consistency check in 1's complement: $1001_2$ represents $-6$ and $1100_2$ represents $-3$, so $-6 - (-3) = -3$, which matches $1100_2$.",
            "answer": "$$\\boxed{1100}$$"
        },
        {
            "introduction": "Moving beyond simple calculation, this practice challenges you to think like a system designer and analyze the subtraction algorithm itself. Why is the end-around carry step essential for correctness, and what role does normalizing the dual zeros play in producing reliable results? By evaluating several proposed implementations and identifying their flaws, you will gain a deeper, more robust understanding of the principles that make one's complement arithmetic work .",
            "id": "3662347",
            "problem": "You are given a fixed word size of $n$ bits and a machine that uses One's Complement (OC) representation for signed integers. The core definitions are as follows: in $n$-bit OC, the representable values are the integers from $-(2^{n-1}-1)$ through $+(2^{n-1}-1)$, and there are two encodings of zero: $+0$ as the all-zero pattern $00\\ldots 0_2$ and $-0$ as the all-one pattern $11\\ldots 1_2$. Negation is implemented by bitwise complement: for any representable value with bit pattern $b$, the bitwise complement $\\overline{b}$ encodes the negation of the value, with the special case that $\\overline{00\\ldots 0_2} = 11\\ldots 1_2$ and vice versa. One's Complement addition is defined as ordinary $n$-bit binary addition with carry-out from the Most Significant Bit (MSB) wrapped around and added back into the Least Significant Bit (LSB) (an “end-around carry”); the resulting all-one pattern $11\\ldots 1_2$ is interpreted as $-0$, which may optionally be normalized to $+0$.\n\nYou are to implement subtraction of two $n$-bit OC operands $x$ and $y$ by a method that reduces subtraction to addition. Consider corner cases, including $y=0$, and the role of end-around carry and zero normalization. Select all options that are correct.\n\nA. A correct OC subtraction procedure for computing $x - y$ on $n$-bit operands is: compute $s \\leftarrow x + \\overline{y}$ using OC addition (i.e., include the end-around carry if one is produced), and if the resulting $n$-bit pattern equals $11\\ldots 1_2$, replace it with $00\\ldots 0_2$. This yields the correct difference whenever $x - y$ is representable in $n$-bit OC.\n\nB. For computing $x - y$ in OC, the end-around carry step can be omitted without affecting correctness; that is, computing the $n$-bit sum $x + \\overline{y}$ with the MSB carry simply discarded still yields the correct result for all $x$ and $y$ in range.\n\nC. In the special case $y=0$, since $\\overline{y} = 11\\ldots 1_2$ (that is, $-0$), OC addition with end-around carry gives $x$ for any $x$, and if $x=0$ the intermediate sum $11\\ldots 1_2$ must be normalized to $00\\ldots 0_2$ to produce the canonical zero.\n\nD. The correct way to compute $x - y$ in OC is to mimic Two’s Complement (TC) subtraction and use $x + \\overline{y} + 1$ (with the $+1$ term), discarding any MSB carry-out; this works for all $x$ and $y$.\n\nE. If the end-around carry step is omitted, a concrete $n=4$ counterexample is $x=0101_2$ and $y=0011_2$. The raw $4$-bit sum $x + \\overline{y}$ is $0001_2$, which represents $+1$, whereas the true mathematical result is $+2$ and the correct OC result with end-around carry would be $0010_2$.\n\nF. If the $-0$ to $+0$ normalization step is omitted, then with $n=4$, $x=0000_2$ and $y=0000_2$, the procedure produces $1111_2$ whose MSB is $1$. A simple sign test based solely on the MSB would incorrectly classify the result as negative, despite the correct mathematical result being $0$; thus normalization is necessary to ensure canonical zero and consistent sign-based predicates.",
            "solution": "The problem statement is subjected to validation before proceeding with a solution.\n\n### Step 1: Extract Givens\n- Word size: $n$ bits.\n- Number system: One's Complement (OC) representation for signed integers.\n- Representable range: Integers from $-(2^{n-1}-1)$ to $+(2^{n-1}-1)$.\n- Zero representations: Two encodings for zero exist.\n  - $+0$ is represented by the all-zero pattern $00\\ldots 0_2$.\n  - $-0$ is represented by the all-one pattern $11\\ldots 1_2$.\n- Negation: Implemented by bitwise complement. For a value with bit pattern $b$, its negation is represented by $\\overline{b}$.\n- One's Complement Addition: Defined as $n$-bit binary addition with an \"end-around carry\" (EAC), where the carry-out from the Most Significant Bit (MSB) is added to the Least Significant Bit (LSB) of the sum.\n- Normalization: The result $11\\ldots 1_2$ (representing $-0$) may be optionally normalized to $00\\ldots 0_2$ (representing $+0$).\n- Task: Analyze methods for computing the subtraction $x - y$ by converting it to an addition problem.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem describes the One's Complement number system. All definitions provided—the range, the dual-zero representation, negation by bitwise complement, and addition with end-around carry—are standard and factually correct for this system, which is a fundamental topic in computer organization and architecture.\n- **Well-Posed:** The problem asks to evaluate several proposed algorithms for subtraction based on the given definitions. This is a clear, formalizable question with a definitive answer based on the rules of OC arithmetic.\n- **Objective:** The problem is stated in precise, technical language with no subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically sound, well-posed, and objective. A solution can be derived from the provided definitions.\n\n### Derivation of One's Complement Subtraction\n\nThe subtraction operation $x - y$ is arithmetically equivalent to the addition $x + (-y)$. In the One's Complement system, the representation of the negative of a value $y$ is obtained by taking the bitwise complement of its representation, denoted $\\overline{y}$. Therefore, the subtraction $x - y$ is implemented by performing a One's Complement addition of $x$ and $\\overline{y}$.\n\nLet the $n$-bit patterns for $x$ and $y$ have unsigned integer values $X$ and $Y$, respectively. The unsigned value of $\\overline{Y}$ is $(2^n - 1) - Y$.\nThe operation is to compute the sum $X + \\overline{Y}$ using OC addition. This involves two steps:\n1. Compute the $n+1$-bit sum $S_{temp} = X + ((2^n - 1) - Y)$.\n2. If this sum generates a carry-out (i.e., if $S_{temp} \\geq 2^n$), the carry has a value of $2^n$. The carry bit is $1$. The $n$-bit result is $S_{temp} \\pmod{2^n}$. The end-around carry rule requires adding this carry bit to the LSB. The final result is $(S_{temp} \\pmod{2^n}) + 1$.\n   If there is no carry-out (i.e., $S_{temp}  2^n$), the carry bit is $0$, and the final result is just $S_{temp}$.\n\nThis can be expressed concisely: the final result is $(X + \\overline{Y}) \\pmod{2^n-1}$ if one considers the ring of integers modulo $2^n-1$. More directly:\nResult $S = X + ((2^n - 1) - Y)$.\n- **Case 1: $x \\ge y$ (and thus $X \\ge Y$, assuming non-negative values for simplicity of illustration, though the logic holds generally).**\nThe mathematical difference is non-negative. The sum is $S = (X - Y) + (2^n - 1) = (X-Y-1) + 2^n$.\nThis operation produces a carry-out of $1$. The intermediate $n$-bit sum is $(X-Y-1)$. The end-around carry adds $1$ back, yielding $(X-Y-1)+1 = X-Y$, which is the correct bit pattern for the positive result $x-y$.\n- **Case 2: $x  y$ (and thus $X  Y$).**\nThe mathematical difference is negative. The sum is $S = (X - Y) + (2^n - 1) = (2^n - 1) - (Y - X)$.\nThis value is less than $2^n$, so there is no carry-out. The result is the bit pattern $(2^n-1)-(Y-X)$. This is precisely the OC representation of the negative number $-(y-x) = x-y$.\n\nTherefore, the correct procedure is to compute $x + \\overline{y}$ using addition with end-around carry. A special case arises when the result is $0$, which can be represented as either $+0$ ($00\\ldots 0_2$) or $-0$ ($11\\ldots 1_2$). Normalizing $-0$ to $+0$ is often required for canonical representation.\n\n### Option-by-Option Analysis\n\n**A. A correct OC subtraction procedure for computing $x - y$ on $n$-bit operands is: compute $s \\leftarrow x + \\overline{y}$ using OC addition (i.e., include the end-around carry if one is produced), and if the resulting $n$-bit pattern equals $11\\ldots 1_2$, replace it with $00\\ldots 0_2$. This yields the correct difference whenever $x - y$ is representable in $n$-bit OC.**\nThis option accurately describes the procedure derived above. The subtraction $x-y$ is performed as $x + \\overline{y}$ with end-around carry. For example, if $x=y$, we compute $x + \\overline{x}$. The sum of a number and its bitwise complement is always $11\\ldots 1_2$ ($-0$). The normalization step correctly proposes to convert this to $00\\ldots 0_2$ ($+0$) for a canonical result. This entire procedure is correct.\n**Verdict: Correct.**\n\n**B. For computing $x - y$ in OC, the end-around carry step can be omitted without affecting correctness; that is, computing the $n$-bit sum $x + \\overline{y}$ with the MSB carry simply discarded still yields the correct result for all $x$ and $y$ in range.**\nThis is incorrect. As shown in the derivation (Case 1), when $x-y0$, a carry is generated, and omitting the end-around carry would result in a value that is off by $1$. For instance, for $n=4$, $x=5$ ($0101_2$) and $y=3$ ($0011_2$), $\\overline{y}$ is $1100_2$. The sum $x+\\overline{y}$ is $0101_2 + 1100_2 = (1)0001_2$. Discarding the carry gives $0001_2$ ($+1$), while the correct answer is $5-3=2$. The EAC step corrects this: $0001_2+1 = 0010_2$ ($+2$).\n**Verdict: Incorrect.**\n\n**C. In the special case $y=0$, since $\\overline{y} = 11\\ldots 1_2$ (that is, $-0$), OC addition with end-around carry gives $x$ for any $x$, and if $x=0$ the intermediate sum $11\\ldots 1_2$ must be normalized to $00\\ldots 0_2$ to produce the canonical zero.**\nLet's analyze $x - 0$, which is $x +_{OC} \\overline{0}$. The bit pattern for $0$ is $Y = 00\\ldots 0_2$, so $\\overline{Y} = 11\\ldots 1_2$. Let $X$ be the bit pattern for $x$.\n- If $x \\neq 0$: The sum $X + (11\\ldots 1_2)$ in binary is $X + (2^n-1) = (X-1) + 2^n$. This produces a carry-out of $1$ and an intermediate sum of $X-1$. The EAC adds $1$ back, yielding $(X-1)+1=X$. The result is $x$.\n- If $x = 0$: The bit pattern is $X=00\\ldots 0_2$. The sum is $00\\ldots 0_2 + 11\\ldots 1_2 = 11\\ldots 1_2$. There is no carry-out. The result is $11\\ldots 1_2$ ($-0$). The statement correctly notes that this should be normalized to $00\\ldots 0_2$ to represent the result $0-0=0$ canonically.\nThe statement is entirely accurate.\n**Verdict: Correct.**\n\n**D. The correct way to compute $x - y$ in OC is to mimic Two’s Complement (TC) subtraction and use $x + \\overline{y} + 1$ (with the $+1$ term), discarding any MSB carry-out; this works for all $x$ and $y$.**\nThis statement describes the procedure for Two's Complement subtraction, as the two's complement of $y$ is $\\overline{y}+1$. This method is not generally correct for One's Complement. Let's test with a case where the result is negative. Let $n=4$, $x=2$ ($0010_2$), $y=5$ ($0101_2$). The expected OC result for $-3$ is $1100_2$.\nThe bit pattern for $\\overline{y}$ is $1010_2$. The TC negation is $\\overline{y}+1 = 1011_2$.\nThe sum is $x + (\\overline{y}+1) = 0010_2 + 1011_2 = 1101_2$. There is no carry-out.\nThe result is $1101_2$, which is the OC representation for $-2$. The correct answer is $-3$. The TC method fails.\n**Verdict: Incorrect.**\n\n**E. If the end-around carry step is omitted, a concrete $n=4$ counterexample is $x=0101_2$ and $y=0011_2$. The raw $4$-bit sum $x + \\overline{y}$ is $0001_2$, which represents $+1$, whereas the true mathematical result is $+2$ and the correct OC result with end-around carry would be $0010_2$.**\nThis option provides a specific counterexample to demonstrate the necessity of the EAC.\n- $x = 0101_2$ represents $+5$.\n- $y = 0011_2$ represents $+3$.\n- $\\overline{y} = 1100_2$.\n- Binary sum $x + \\overline{y}$: $0101_2 + 1100_2 = (1)0001_2$.\n- Without EAC, the result is $0001_2$, which represents $+1$. This is incorrect, as $5-3=2$.\n- With EAC, the carry of $1$ is added to the LSB: $0001_2 + 1 = 0010_2$, which represents $+2$. This is correct.\nThe counterexample is valid and correctly reasoned.\n**Verdict: Correct.**\n\n**F. If the $-0$ to $+0$ normalization step is omitted, then with $n=4$, $x=0000_2$ and $y=0000_2$, the procedure produces $1111_2$ whose MSB is $1$. A simple sign test based solely on the MSB would incorrectly classify the result as negative, despite the correct mathematical result being $0$; thus normalization is necessary to ensure canonical zero and consistent sign-based predicates.**\nLet's trace the example: $n=4$, $x=0000_2$ ($+0$), $y=0000_2$ ($+0$).\nThe operation is $x - y$, implemented as $x +_{OC} \\overline{y}$.\n- $\\overline{y} = \\overline{0000_2} = 1111_2$ ($-0$).\n- Binary sum: $0000_2 + 1111_2 = 1111_2$.\n- There is no carry-out, so no EAC is performed.\nThe result is $1111_2$, which is the OC representation for $-0$. Although its mathematical value is zero, its MSB is $1$. In OC, a MSB of $1$ signifies a negative number (or $-0$). A hardware or software predicate checking only the MSB to determine the sign would classify this result as negative. This is misleading since the mathematical result is $0$. Normalizing $1111_2$ to $0000_2$ resolves this ambiguity and ensures that zero has a non-negative sign bit. The reasoning is sound.\n**Verdict: Correct.**",
            "answer": "$$\\boxed{ACEF}$$"
        }
    ]
}