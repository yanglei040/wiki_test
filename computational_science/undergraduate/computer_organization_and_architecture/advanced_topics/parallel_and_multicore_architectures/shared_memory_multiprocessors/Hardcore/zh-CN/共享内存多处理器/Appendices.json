{
    "hands_on_practices": [
        {
            "introduction": "在评估处理器性能时，平均内存访问时间是一个关键指标。在多处理器系统中，当一个核心的缓存未命中时，所需数据可能来自另一个核心的缓存，这通常比从末级缓存或主存中获取要快得多。本练习将引导你通过概率和期望延迟的计算，来量化这种缓存间直接传输带来的性能优势。",
            "id": "3675527",
            "problem": "一个对称共享内存多处理器实现了修改、独占、共享、无效 (MESI) 缓存一致性协议，该处理器配备了私有的一级 (L1) 写回式缓存和一个包含式共享末级缓存 (LLC)。考虑一个稳态工作负载，其中每次内存访问都针对单个缓存行，并且根据测量和微架构特性分析，已知以下信息：\n\n- L1 命中延迟为 $t_{L1} = 4$ 个周期，在下文考虑的两种设计中，所有核心的该值都相同。\n- L1 未命中率为 $m_1 = 0.08$ 每次访问。\n- 在 L1 未命中的条件下，请求的行当前被另一个核心的私有缓存以允许直接转发的状态持有的概率为 $p_{\\text{owner}} = 0.35$。\n- 如果一个行通过缓存到缓存的传输直接转发，则端到端延迟（包括目录查找、一致性消息和数据传输）为 $t_{\\text{c2c}} = 80$ 个周期。\n- 如果一个行不是从另一个核心转发的，则该请求由 LLC 或主存提供服务，其有效平均延迟为 $t_{\\text{LLC}} = 140$ 个周期。\n\n假设没有排队、争用或重叠效应，并且除上述情况外，一致性状态分布是平稳的，且每次访问之间相互独立。考虑两种设计：\n\n- 设计 A：在可能的情况下支持缓存到缓存的转发。\n- 设计 B：不支持缓存到缓存的转发；在设计 B 中，每次 L1 未命中都由 LLC 或主存提供服务。\n\n仅使用未命中率作为概率和期望延迟作为互斥结果的概率加权平均值的基本定义，从第一性原理推导设计 A 相对于设计 B 的每次访问的期望延迟降低量（以周期为单位）。以周期为单位表示你的最终答案，并将答案四舍五入到 $4$ 位有效数字。",
            "solution": "问题要求计算支持缓存到缓存转发的多处理器设计（设计 A）相对于不支持该功能的设计（设计 B）的每次访问的期望延迟降低量。推导过程必须从第一性原理出发，使用期望延迟作为互斥结果的概率加权平均值的定义。\n\n设 $E[T]$ 表示一次内存访问的期望延迟。一次内存访问可能导致两种主要的互斥结果之一：在私有 L1 缓存中命中或在 L1 缓存中未命中。根据全期望定律，我们可以将期望延迟写为：\n$$\nE[T] = P(\\text{L1 hit}) \\times L_{\\text{hit}} + P(\\text{L1 miss}) \\times L_{\\text{miss}}\n$$\n其中 $P(\\text{L1 hit})$ 和 $P(\\text{L1 miss})$ 分别是 L1 命中和未命中的概率，而 $L_{\\text{hit}}$ 和 $L_{\\text{miss}}$ 是每种结果对应的总延迟。\n\n根据题目描述，我们已知：\n- L1 未命中率 $m_1 = 0.08$。这是 L1 未命中的概率，所以 $P(\\text{L1 miss}) = m_1$。\n- 因此，L1 命中的概率为 $P(\\text{L1 hit}) = 1 - m_1$。\n- L1 命中延迟为 $t_{L1} = 4$ 个周期。这是命中的总延迟，所以 $L_{\\text{hit}} = t_{L1}$。\n\nL1 未命中时的期望延迟，记作 $E[L_{\\text{miss}}]$，取决于系统设计。将已知值代入通用公式，得到：\n$$\nE[T] = (1 - m_1) t_{L1} + m_1 E[L_{\\text{miss}}]\n$$\n\n我们现在分别分析这两种设计。\n\n对于不支持缓存到缓存转发的设计 B，任何 L1 未命中都必须由 LLC 或主存提供服务。题目说明这个有效平均延迟是 $t_{\\text{LLC}} = 140$ 个周期。因此，对于设计 B，任何 L1 未命中的延迟始终是 $t_{\\text{LLC}}$。未命中时的期望延迟就是：\n$$\nE[L_{\\text{miss, B}}] = t_{\\text{LLC}}\n$$\n设计 B 的每次访问总期望延迟 $E[T_B]$ 为：\n$$\nE[T_B] = (1 - m_1) t_{L1} + m_1 t_{\\text{LLC}}\n$$\n\n对于支持缓存到缓存转发的设计 A，一次 L1 未命中后有两种可能的结果：\n1. 请求的缓存行从另一个核心的私有缓存中转发。这发生的条件概率为 $p_{\\text{owner}} = 0.35$，此次传输的端到端延迟为 $t_{\\text{c2c}} = 80$ 个周期。\n2. 该行不被转发，必须从 LLC 或主存中获取。这发生的互补条件概率为 $1 - p_{\\text{owner}}$，延迟为 $t_{\\text{LLC}} = 140$ 个周期。\n\n设计 A 在 L1 未命中时的期望延迟 $E[L_{\\text{miss, A}}]$ 是这两种结果的加权平均值：\n$$\nE[L_{\\text{miss, A}}] = p_{\\text{owner}} \\times t_{\\text{c2c}} + (1 - p_{\\text{owner}}) \\times t_{\\text{LLC}}\n$$\n设计 A 的每次访问总期望延迟 $E[T_A]$ 为：\n$$\nE[T_A] = (1 - m_1) t_{L1} + m_1 E[L_{\\text{miss, A}}] = (1 - m_1) t_{L1} + m_1 (p_{\\text{owner}} t_{\\text{c2c}} + (1 - p_{\\text{owner}}) t_{\\text{LLC}})\n$$\n\n问题要求的是设计 A 相对于设计 B 的期望延迟降低量，即差值 $\\Delta T = E[T_B] - E[T_A]$。\n$$\n\\Delta T = \\left[ (1 - m_1) t_{L1} + m_1 t_{\\text{LLC}} \\right] - \\left[ (1 - m_1) t_{L1} + m_1 (p_{\\text{owner}} t_{\\text{c2c}} + (1 - p_{\\text{owner}}) t_{\\text{LLC}}) \\right]\n$$\n项 $(1 - m_1) t_{L1}$ 代表 L1 命中的延迟贡献，在两个表达式中是相同的，因此相互抵消。延迟的减少完全是由于对 L1 未命中的处理方式不同。\n$$\n\\Delta T = m_1 t_{\\text{LLC}} - m_1 (p_{\\text{owner}} t_{\\text{c2c}} + (1 - p_{\\text{owner}}) t_{\\text{LLC}})\n$$\n将右边的项 $-m_1$ 展开：\n$$\n\\Delta T = m_1 t_{\\text{LLC}} - m_1 p_{\\text{owner}} t_{\\text{c2c}} - m_1(1 - p_{\\text{owner}}) t_{\\text{LLC}}\n$$\n$$\n\\Delta T = m_1 t_{\\text{LLC}} - m_1 p_{\\text{owner}} t_{\\text{c2c}} - m_1 t_{\\text{LLC}} + m_1 p_{\\text{owner}} t_{\\text{LLC}}\n$$\n项 $m_1 t_{\\text{LLC}}$ 和 $-m_1 t_{\\text{LLC}}$ 相互抵消，得到：\n$$\n\\Delta T = m_1 p_{\\text{owner}} t_{\\text{LLC}} - m_1 p_{\\text{owner}} t_{\\text{c2c}}\n$$\n提出公因式 $m_1 p_{\\text{owner}}$，得到延迟降低量的最终符号表达式：\n$$\n\\Delta T = m_1 p_{\\text{owner}} (t_{\\text{LLC}} - t_{\\text{c2c}})\n$$\n这个结果在直观上是正确的：总延迟降低量是因快速的缓存到缓存传输而得到满足的未命中概率 ($m_1 \\times p_{\\text{owner}}$) 乘以每次此类传输所节省的时间 ($t_{\\text{LLC}} - t_{\\text{c2c}}$)。\n\n现在，我们代入给定的数值：\n$m_1 = 0.08$\n$p_{\\text{owner}} = 0.35$\n$t_{\\text{LLC}} = 140$ 个周期\n$t_{\\text{c2c}} = 80$ 个周期\n\n$$\n\\Delta T = 0.08 \\times 0.35 \\times (140 - 80)\n$$\n$$\n\\Delta T = 0.08 \\times 0.35 \\times 60\n$$\n$$\n\\Delta T = 0.028 \\times 60\n$$\n$$\n\\Delta T = 1.68\n$$\n延迟降低量为每次访问 $1.68$ 个周期。题目要求答案四舍五入到 $4$ 位有效数字。为了将 $1.68$ 表示为四位有效数字，我们将其写为 $1.680$。",
            "answer": "$$\\boxed{1.680}$$"
        },
        {
            "introduction": "尽管像缓存间传输这样的优化可以减少延迟，但系统的整体吞吐量可能受限于其他因素。本练习探讨了一个“最坏情况”的场景：所有核心激烈争用一个共享变量。通过这个练习，你将发现串行化如何形成一个根本性的性能瓶颈，这个瓶颈与处理器的数量无关，从而深刻理解阿姆达尔定律在微架构层面的体现。",
            "id": "3675634",
            "problem": "考虑一个共享内存多处理器，它拥有 $N$ 个相同的核心、一个存储在单个缓存行中的共享计数器变量，以及一个基于失效的缓存一致性协议，该协议具有修改、独占、共享、无效 (MESI) 状态。该系统强制执行顺序一致性，这意味着所有内存操作都以与程序顺序一致的单一全局顺序出现。共享计数器的增量操作通过原子读-修改-写操作执行，这要求核心在写入之前持有处于修改状态的缓存行。\n\n定义缓存行交接延迟 $t_h$ 为缓存行的独占所有权从当前所有者转移到请求核心的端到端时间，包括一致性消息、失效操作、数据移动和任何仲裁延迟，但不包括一旦在修改状态下持有该行后增量操作的本地执行时间。假设采用以下压力测试配置：\n- 每个核心重复执行一次对共享计数器的原子增量操作，然后在某个其他核心完成增量操作后立即再次请求该行，从而在 $N$ 个核心之间强制执行严格的循环所有权模式。\n- 当一次交接完成时，总有至少一个请求核心，因此该行始终处于持续竞争状态。\n- 一旦在修改状态下获得缓存行，增量操作的本地执行时间与 $t_h$ 相比可以忽略不计，在进行吞吐量分析时可视为零。\n- 没有其他内存流量干扰，并且互连网络不会引入超出 $t_h$ 所包含范围的额外排队。\n\n在这些假设下，推导稳态系统吞吐量 $X(N, t_h)$（以每秒完成的增量操作次数为单位）的封闭形式。您的最终答案必须是关于 $N$ 和 $t_h$ 的单个解析表达式。不要提供不等式或需要求解的方程；请提供最终表达式。您无需对结果进行四舍五入。以每秒增量操作次数表示吞吐量。",
            "solution": "本题要求推导一个在高度竞争下的共享内存系统的稳态吞吐量 $X(N, t_h)$，单位为每秒完成的增量操作次数。\n\n首先，我们分析系统的核心行为。问题描述了一个场景，其中 $N$ 个核心激烈争用一个存储在单个缓存行中的共享计数器。对该计数器的原子增量操作要求核心独占性地持有该缓存行（即处于 MESI 协议的“修改”状态）。由于在任何时刻只有一个核心能持有该行，所有对计数器的增量操作在整个系统层面是被完全串行化的。这意味着在任何时间点，只有一个增量操作可以执行。\n\n接下来，我们计算完成一次增量操作所需的时间。假设在时间点 $T_0$，核心 $C_i$ 刚刚完成了它的增量操作。根据问题设定，系统处于“持续竞争”状态，并且遵循“严格的循环所有权模式”，这意味着序列中的下一个核心 $C_{i+1}$（索引以 $N$ 为模）已经发出了对该缓存行的请求。\n\n1.  将缓存行的独占所有权从核心 $C_i$ 转移到请求核心 $C_{i+1}$ 的过程立即开始。\n2.  这个所有权转移的端到端时间，包括所有一致性消息、仲裁和数据移动，被定义为缓存行交接延迟 $t_h$。\n3.  因此，在时间点 $T_0 + t_h$，核心 $C_{i+1}$ 获得了处于“修改”状态的缓存行。\n4.  根据假设，一旦获得缓存行，本地增量操作的执行时间可以忽略不计（视为零）。所以，核心 $C_{i+1}$ 在获得缓存行的瞬间，即在时间点 $T_1 = T_0 + t_h$，就完成了它的增量操作。\n\n这个分析表明，从系统完成一次增量操作（在 $T_0$ 时刻由 $C_i$ 完成）到完成下一次增量操作（在 $T_1$ 时刻由 $C_{i+1}$ 完成），所经过的时间恰好是 $t_h$。\n\n系统吞吐量 $X$ 定义为单位时间内完成的操作总数。既然系统每隔 $t_h$ 秒就能完成一次增量操作，那么其完成速率（即吞吐量）就是每次操作所需时间的倒数。\n$$ X = \\frac{1 \\text{ 次增量操作}}{t_h \\text{ 秒}} $$\n因此，系统吞吐量的封闭形式表达式为：\n$$ X(N, t_h) = \\frac{1}{t_h} $$\n值得注意的是，在这个完全串行化的瓶颈模型中，只要 $N > 1$ 以形成竞争，系统总吞吐量就仅取决于资源交接的延迟 $t_h$，而与竞争核心的数量 $N$ 无关。单个核心的吞吐量是 $\\frac{1}{N \\cdot t_h}$，因为一个核心必须等待其他 $N-1$ 个核心轮流操作后才能再次执行，整个周期耗时 $N \\cdot t_h$。$N$ 个核心的总吞吐量是 $N \\times \\left(\\frac{1}{N \\cdot t_h}\\right) = \\frac{1}{t_h}$，这也验证了我们的最终结果。",
            "answer": "$$\\boxed{\\frac{1}{t_h}}$$"
        },
        {
            "introduction": "共享内存系统中的性能问题有时非常微妙。“伪共享”就是这样一个典型例子，当逻辑上不相关的多个数据项恰好位于同一缓存行时，它们便会引发不必要的争用。本练习将通过建模和计算伪共享的开销，让你亲手实践如何通过优化数据布局来提升并行程序的性能，这是编写高性能并行代码的一项关键技能。",
            "id": "3675600",
            "problem": "考虑一个带有私有缓存和写-无效缓存一致性协议的共享内存多处理器。稀疏矩阵乘法的密集结果矩阵 $C$ 以行主序存储。设 $C$ 有 $M$ 行和 $N$ 列，每个元素占用 $s$ 字节。为简便起见，$C$ 的基地址取为 $\\text{base} = 0$。元素 $(i,j)$ 的地址定义为 $\\mathrm{addr}(i,j) = s \\cdot (iN + j)$，一个元素映射到的缓存行索引为 $$\\ell(i,j; L_c) = \\left\\lfloor \\frac{s \\cdot (iN + j)}{L_c} \\right\\rfloor,$$ 其中 $L_c$ 是缓存行大小（以字节为单位）。假设多个线程并发地写入 $C$ 的不同元素，这是由稀疏乘法的非零元素分布引起的。尽管线程写入不同的字，但当它们的字位于同一缓存行时，会发生伪共享，从而引发一致性失效。\n\n我们对给定的缓存行大小 $L_c$ 定义伪共享成本如下。对于每个缓存行索引 $\\ell$，设 $k_{\\ell}$ 是写入至少一个映射到 $\\ell$ 的元素的不同线程的数量。每行的伪共享事件计数为 $\\max(0, k_{\\ell} - 1)$，因为对于写-无效协议，写入者要获得独占访问权，至少需要 $k_{\\ell} - 1$ 次线程间的属主权转移。总伪共享成本为 $$F(L_c) = \\sum_{\\ell} \\max(0, k_{\\ell} - 1).$$ 您的程序必须对每个测试用例，为每个候选 $L_c$ 计算 $F(L_c)$，选择最小化 $F(L_c)$ 的 $L_c$，并返回所选的 $L_c$ 和最小成本。如果出现平局，选择具有最小 $F(L_c)$ 的 $L_c$ 中最小的那个。\n\n所有 $L_c$ 和 $s$ 的单位都必须是字节。\n\n使用以下测试套件。在所有情况下，线程都写入不同的元素（无真共享）。写入操作由整数对 $(i,j)$（行索引和列索引）指定，并且对于每个测试用例，候选缓存行大小以字节为单位的集合形式给出。\n\n- 测试用例 $1$：\n  - $M = 4$, $N = 16$, $s = 8$, $T = 3$, 候选 $\\{32, 64, 128\\}$。\n  - 线程 $0$ 写入 $\\{(0,0),(0,1),(0,2),(0,3),(1,8),(1,9),(1,10),(1,11)\\}$。\n  - 线程 $1$ 写入 $\\{(0,4),(0,5),(0,6),(0,7),(2,0),(2,1)\\}$。\n  - 线程 $2$ 写入 $\\{(1,0),(1,1),(1,2),(1,3),(2,8),(2,9)\\}$。\n- 测试用例 $2$：\n  - $M = 3$, $N = 2$, $s = 8$, $T = 3$, 候选 $\\{16, 32, 64\\}$。\n  - 线程 $0$ 写入 $\\{(0,0),(0,1)\\}$。\n  - 线程 $1$ 写入 $\\{(1,0),(1,1)\\}$。\n  - 线程 $2$ 写入 $\\{(2,0),(2,1)\\}$。\n- 测试用例 $3$：\n  - $M = 1$, $N = 16$, $s = 8$, $T = 4$, 候选 $\\{64, 128\\}$。\n  - 线程 $0$ 写入 $\\{(0,0),(0,1),(0,2),(0,3)\\}$。\n  - 线程 $1$ 写入 $\\{(0,4),(0,5),(0,6),(0,7)\\}$。\n  - 线程 $2$ 写入 $\\{(0,8),(0,9),(0,10),(0,11)\\}$。\n  - 线程 $3$ 写入 $\\{(0,12),(0,13),(0,14),(0,15)\\}$。\n- 测试用例 $4$：\n  - $M = 4$, $N = 16$, $s = 8$, $T = 3$, 候选 $\\{32, 64, 128\\}$。\n  - 线程 $0$ 写入 $\\{(0,0),(0,8)\\}$。\n  - 线程 $1$ 写入 $\\{(1,0)\\}$。\n  - 线程 $2$ 写入 $\\{(2,0)\\}$。\n\n您的任务是实现一个程序，对每个测试用例，计算能最小化总伪共享成本 $F(L_c)$ 的最优缓存行大小 $L_c$（以字节为单位）以及该最小成本。最终输出格式必须将所有提供的测试用例的结果聚合到单行中，包含一个由方括号括起来的逗号分隔列表，其中对每个测试用例，您需要输出所选的 $L_c$ 及其对应的最小 $F(L_c)$ 作为整数。例如，格式为 $[L_{c,1},F(L_{c,1}),L_{c,2},F(L_{c,2}),\\dots]$，不含空格。",
            "solution": "该问题要求我们为每个测试用例，从一组候选的缓存行大小 $L_c$ 中，找出一个能最小化总伪共享成本 $F(L_c)$ 的最优值。成本函数定义为 $F(L_c) = \\sum_{\\ell} \\max(0, k_{\\ell} - 1)$，其中 $k_{\\ell}$ 是写入缓存行 $\\ell$ 的不同线程的数量。\n\n我们的求解方法是，对每个测试用例中的每个候选 $L_c$，计算其对应的总成本 $F(L_c)$，然后根据题目的选择标准（成本最低，若成本相同则取最小的 $L_c$）来确定最优解。\n\n**测试用例 1:**\n$M=4, N=16, s=8$。地址 $\\mathrm{addr}(i,j) = 8 \\cdot (16i + j)$。\n- **$L_c = 32$**:\n  - T0 写入地址范围 $[0, 24]$ (元素0,0..0,3) 和 $[192, 216]$ (元素1,8..1,11)。对应的缓存行索引为 $\\ell_0 = \\lfloor [0,24]/32 \\rfloor = 0$ 和 $\\ell_1 = \\lfloor [192,216]/32 \\rfloor = 6$。\n  - T1 写入地址范围 $[32, 56]$ (元素0,4..0,7) 和 $[256, 264]$ (元素2,0..2,1)。对应的缓存行索引为 $\\ell_2 = \\lfloor [32,56]/32 \\rfloor = 1$ 和 $\\ell_3 = \\lfloor [256,264]/32 \\rfloor = 8$。\n  - T2 写入地址范围 $[128, 152]$ (元素1,0..1,3) 和 $[320, 328]$ (元素2,8..2,9)。对应的缓存行索引为 $\\ell_4 = \\lfloor [128,152]/32 \\rfloor = 4$ 和 $\\ell_5 = \\lfloor [320,328]/32 \\rfloor = 10$。\n  - 每个被写入的缓存行都只被一个线程写入，即所有 $k_\\ell=1$。因此，$F(32) = \\sum \\max(0, 1-1) = 0$。\n- **$L_c = 64$**:\n  - T0 (元素0,0..0,3) 写入地址 $[0, 24]$，对应 $\\ell = \\lfloor [0, 24]/64 \\rfloor = 0$。\n  - T1 (元素0,4..0,7) 写入地址 $[32, 56]$，对应 $\\ell = \\lfloor [32, 56]/64 \\rfloor = 0$。\n  - 缓存行0被 T0 和 T1 写入，$k_0=2$，成本为 $2-1=1$。其他所有写入都映射到不同的缓存行，成本为0。\n  - 因此，$F(64) = 1$。\n- **$L_c = 128$**:\n  - T0和T1对行0的写入都映射到缓存行0 ($k_0=2$, 成本=1)。\n  - T0对行1和T2对行1的写入都映射到缓存行1 ($k_1=2$, 成本=1)。\n  - T1对行2和T2对行2的写入都映射到缓存行2 ($k_2=2$, 成本=1)。\n  - 因此，$F(128) = 1+1+1 = 3$。\n- 结论: 成本最低为 $F=0$，对应的 $L_c=32$。**结果: (32, 0)**\n\n**测试用例 2:**\n$M=3, N=2, s=8$。地址 $\\mathrm{addr}(i,j) = 8 \\cdot (2i + j)$。\n- T0 写入地址 $0, 8$。\n- T1 写入地址 $16, 24$。\n- T2 写入地址 $32, 40$。\n- **$L_c = 16$**: T0 写入行0，T1 写入行1，T2 写入行2。所有 $k_\\ell=1$。$F(16)=0$。\n- **$L_c = 32$**: T0 和 T1 写入行0 ($k_0=2$, 成本=1)。T2 写入行1 ($k_1=1$, 成本=0)。$F(32)=1$。\n- **$L_c = 64$**: T0, T1, T2 都写入行0 ($k_0=3$, 成本=2)。$F(64)=2$。\n- 结论: 成本最低为 $F=0$，对应的 $L_c=16$。**结果: (16, 0)**\n\n**测试用例 3:**\n$M=1, N=16, s=8$。地址 $\\mathrm{addr}(i,j) = 8j$。\n- T0 写入地址 $[0, 24]$。T1 写入 $[32, 56]$。T2 写入 $[64, 88]$。T3 写入 $[96, 120]$。\n- **$L_c = 64$**:\n  - T0, T1 写入行0 ($k_0=2$, 成本=1)。\n  - T2, T3 写入行1 ($k_1=2$, 成本=1)。\n  - 总成本 $F(64)=1+1=2$。\n- **$L_c = 128$**:\n  - T0, T1, T2, T3 都写入行0 ($k_0=4$, 成本=3)。\n  - 总成本 $F(128)=3$。\n- 结论: 成本最低为 $F=2$，对应的 $L_c=64$。**结果: (64, 2)**\n\n**测试用例 4:**\n$M=4, N=16, s=8$。地址 $\\mathrm{addr}(i,j) = 8 \\cdot (16i + j)$。\n- T0 写入地址 $0, 64$。\n- T1 写入地址 $128$。\n- T2 写入地址 $256$。\n- **$L_c = 32$**: T0 写入行0, 2。T1 写入行4。T2 写入行8。所有 $k_\\ell=1$。$F(32)=0$。\n- **$L_c = 64$**: T0 写入行0, 1。T1 写入行2。T2 写入行4。所有 $k_\\ell=1$。$F(64)=0$。\n- **$L_c = 128$**: T0 写入行0。T1 写入行1。T2 写入行2。所有 $k_\\ell=1$。$F(128)=0$。\n- 结论: 三个候选 $L_c$ 的成本都为0。根据平局规则，选择最小的 $L_c$。**结果: (32, 0)**\n\n将所有结果聚合成指定格式，得到最终答案。",
            "answer": "[32,0,16,0,64,2,32,0]"
        }
    ]
}