{
    "hands_on_practices": [
        {
            "introduction": "现代处理器通过非阻塞缓存和乱序执行等技术来隐藏延迟，但其效果会受到程序中真实数据依赖的严重限制。本练习使用经典的“指针追逐”场景，帮助你深入理解数据依赖如何将内存级别并行度（$MLP$）限制为1，并探索内容导向预取等高级硬件技术如何通过打破依赖链来解锁更高的性能。通过分析此问题，你将能够辨别不同硬件特性在面对特定类型工作负载时的真正瓶颈与潜力 。",
            "id": "3625656",
            "problem": "一个单线程程序在一个包含 $N$ 个节点的单向链表上执行指针追逐。每个节点位于其自己的缓存行中，其地址依赖于前一个节点中的指针值，并且程序以没有空间局部性的对抗性顺序访问这些节点。在每次迭代中，程序从同一缓存行加载指向下一个节点的指针和一个值，每个节点最多导致一次缓存行填充。处理器是一个乱序 (OoO) 执行核心，其分发宽度为 $W$，拥有足够大的重排序缓冲，以及一个可以为阻塞式或非阻塞式的一级 (L1) 数据缓存。非阻塞式 L1 缓存有 $M$ 个未命中状态保持寄存器 (MSHRs)。对于此工作负载，二级 (L2) 缓存是冷的，所有 L1 缓存未命中都会访问动态随机存取存储器 (DRAM)。假设命中延迟与未命中服务时间相比可以忽略不计，因此执行时间主要由缓存未命中决定。将内存级并行度 (MLP) 定义为在稳态执行期间并发处理中的不同缓存未命中请求的平均数量。\n\n考虑三种配置：\n- 基准阻塞式 L1 缓存（无 MSHR）。\n- 非阻塞式 L1 缓存，有 $M \\ge 2$ 个 MSHR，无预取。\n- 非阻塞式 L1 缓存，有 $M \\ge 4$ 个 MSHR 和一个内容导向预取器，该预取器在接收到节点的缓存行后，读取下一节点指针字段，并能通过递归地跟随下一节点指针为未来节点维持最多 $P$ 个未完成的预取（假设预取是准确和及时的，并且可以分配 MSHR）。\n\n下列哪个陈述是正确的？\n\nA. 在具有 $M \\ge 2$ 个 MSHR 的非阻塞、无预取配置中，指针追逐循环期间的最大稳态 MLP 为 $1$。\n\nB. 在具有内容导向预取器和 $M \\ge 4$ 个 MSHR 的非阻塞配置中，如果预取器能够使最多 $3$ 个下一节点处于处理中（即 $P=3$），则最大稳态 MLP 可以超过 $1$。\n\nC. 对于此工作负载，简单的下一行预取器（顺序行预读）通常会提供与内容导向预取器相同的 MLP 提升。\n\nD. 在没有任何预取的情况下，从阻塞式 L1 缓存切换到具有 $M \\ge 8$ 个 MSHR 的非阻塞式 L1 缓存，会严格增加该指针追逐工作负载的稳态 MLP。\n\nE. 对于一个准确、及时的内容导向预取器（能维持最多 $P$ 个未完成的预取）和一个具有 $M$ 个 MSHR 的非阻塞式缓存，稳态 MLP 的上限为 $\\min(M, P+1)$。",
            "solution": "问题陈述经过审慎分析后被认为是有效的。它在科学上基于计算机组成和体系结构的原理，问题提出得当，并包含足够的信息以进行严谨的分析。所描述的工作负载——指针追逐，是研究内存级并行度 (MLP) 以及高级处理器和内存系统特性有效性的经典案例。\n\n问题的核心在于一个真数据依赖：迭代 $i+1$ 中加载操作的内存地址是迭代 $i$ 中加载操作的结果。假设当前节点的地址存储在寄存器 `r0` 中。程序执行像 `ld r1, [r0]` 这样的指令来获取指向下一个节点的指针。下一次迭代将使用 `r1` 中的值作为其加载操作的地址。这创建了一个串行依赖链：$\\text{load}(\\text{Node}_i) \\to \\text{Address}(\\text{Node}_{i+1}) \\to \\text{load}(\\text{Node}_{i+1}) \\to \\dots$。\n\n一个乱序 (OoO) 处理器自身无法打破这种依赖关系。它可以执行其他独立的指令，但在包含 $\\text{Node}_i$ 的缓存行被取回且加载指针的指令完成之前，它无法开始对 $\\text{Node}_{i+1}$ 的内存访问。\n\n我们将内存级并行度 (MLP) 定义为并发未完成的缓存未命中的平均数量。我们将基于这些原则分析每种配置的 MLP。\n\n### 选项评估\n\n**A. 在具有 $M \\ge 2$ 个 MSHR 的非阻塞、无预取配置中，指针追逐循环期间的最大稳态 MLP 为 $1$。**\n\n在此配置中，处理器有一个非阻塞式一级 (L1) 缓存，配有 $M \\ge 2$ 个未命中状态保持寄存器 (MSHRs)，但没有预取器。当加载 $\\text{Node}_i$ 的操作发生缓存未命中时，会分配一个 MSHR 并将请求发送到内存。由于处理器是非阻塞式的，它不必完全停顿。然而，由于指针链的真数据依赖，处理器无法计算 $\\text{Node}_{i+1}$ 的地址，因此无法发出链中的下一个加载指令。它必须等待当前对 $\\text{Node}_i$ 的未命中得到服务。因此，对于这个依赖链，在任何给定时间只能有一个缓存未命中在处理中。多个 MSHR ($M \\ge 2$) 的可用性是无关紧要的，因为处理器的指令流无法一次性为指针链生成多个未命中请求。因此，MLP 被限制为 $1$。\n\n结论：**正确**。\n\n**B. 在具有内容导向预取器和 $M \\ge 4$ 个 MSHR 的非阻塞配置中，如果预取器能够使最多 $3$ 个下一节点处于处理中（即 $P=3$），则最大稳态 MLP 可以超过 $1$。**\n\n内容导向预取器绕过了处理器的依赖限制。这个硬件单元可以在缓存行从内存到达时检查其内容。在接收到 $\\text{Node}_i$ 的缓存行后，预取器提取指向 $\\text{Node}_{i+1}$ 的指针，并为其发出一个预取请求。这个过程可以递归进行。由于能够维持 $P=3$ 个未完成的预取，预取器可以在处理器仍在等待或处理 $\\text{Node}_i$ 的同时，为 $\\text{Node}_{i+1}$、$\\text{Node}_{i+2}$ 和 $\\text{Node}_{i+3}$ 发出请求。除了这 $3$ 个预取请求外，还有处理器自身对当前节点的需求请求。这意味着最多可以有 $1+P = 1+3=4$ 个不同的缓存未命中并发处理中。这种级别的并行度至少需要 $4$ 个 MSHR，这满足了给定的 $M \\ge 4$ 的条件。因为高达 $4$ 的 MLP 是可能的，所以 MLP 肯定可以超过 $1$。\n\n结论：**正确**。\n\n**C. 对于此工作负载，简单的下一行预取器（顺序行预读）通常会提供与内容导向预取器相同的 MLP 提升。**\n\n下一行预取器基于空间局部性的假设进行操作。它在访问地址 $A$ 后预取地址为 $A+L$ 的缓存行，其中 $L$ 是缓存行大小。问题陈述指明，链表节点是以“没有空间局部性的对抗性顺序”访问的。这意味着 $\\text{Node}_{i+1}$ 的内存位置与 $\\text{Node}_i$ 的位置之间没有固定的、可预测的偏移量。因此，下一行预取器会持续预取错误且无用的数据，不会带来任何性能提升，反而可能通过缓存污染和带宽浪费造成损害。相比之下，内容导向预取器是专门为这种基于指针的结构设计的，并且会非常有效。因此，关于它们的 MLP 提升会相同的陈述是错误的。\n\n结论：**不正确**。\n\n**D. 在没有任何预取的情况下，从阻塞式 L1 缓存切换到具有 $M \\ge 8$ 个 MSHR 的非阻塞式 L1 缓存，会严格增加该指针追逐工作负载的稳态 MLP。**\n\n在具有阻塞式 L1 缓存的基准配置中，任何未命中都会使处理器完全停顿。只有一个内存请求可以处于未完成状态。MLP 恰好为 $1$。正如在对选项 A 的分析中所确立的，在*没有预取器*的非阻塞配置中，指针追逐的真数据依赖同样将 MLP 限制为 $1$。处理器在当前未命中请求解决之前无法生成下一个未命中请求。因此，对于这个特定的工作负载，从阻塞式缓存 (MLP = $1$) 切换到非阻塞式缓存 (MLP = $1$) 并不会增加 MLP。该陈述声称*严格*增加，这是错误的。\n\n结论：**不正确**。\n\n**E. 对于一个准确、及时的内容导向预取器（能维持最多 $P$ 个未完成的预取）和一个具有 $M$ 个 MSHR 的非阻塞式缓存，稳态 MLP 的上限为 $\\min(M, P+1)$。**\n\n最大可实现的 MLP 受到两个因素的限制：可以生成的请求数量和可用于跟踪这些请求的硬件资源数量。\n1.  **请求生成限制**：处理器本身为其正在处理的当前节点发出一个需求请求。内容导向预取器可以向前看，并为后续节点发出最多 $P$ 个额外的预取请求。总共，系统最多可以为指针链生成 $P+1$ 个并发的未命中请求。因此，$\\text{MLP} \\le P+1$。\n2.  **资源限制**：每个未完成的缓存未命中都需要一个 MSHR 来跟踪其状态。有 $M$ 个 MSHR 可用，系统物理上最多可以处理 $M$ 个并发未命中。因此，$\\text{MLP} \\le M$。\n\n结合这两个约束，实际的 MLP 受两者中较小者的限制。MLP 不能超过系统可以生成的请求数量，也不能超过硬件可以跟踪的请求数量。因此，稳态 MLP 的上限为 $\\min(M, P+1)$。\n\n结论：**正确**。",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "在理解了预取等技术对特定工作负载的有效性之后，一个自然的问题是：在多种优化方案中如何抉择？本练习要求你对两种截然不同的缓存优化技术——牺牲缓存（旨在减少冲突和容量未命中）和指针追逐预取（旨在隐藏延迟）——进行直接的性能比较。通过推导和分析它们在重用距离（$R$）趋于无穷大时的渐进行为，你将学会如何评估不同硬件设计在特定负载特征下的扩展性与最终效益 。",
            "id": "3625691",
            "problem": "一个系统执行一个指针追逐工作负载，该负载重复遍历一个循环单链表，其中每个节点位于一个独立的缓存块中。假设有一个一级（L1）缓存，其命中时间为 $t_h$ 个周期，基准主存未命中惩罚为 $L$ 个周期。在稳态下，该工作负载的 L1 未命中率为 $m$。重用距离 $R$ 定义为对同一块的两次使用之间访问的不同缓存块的数量；对于一个包含 $W$ 个节点的列表的循环遍历，$R = W - 1$。考虑两种独立的优化技术：\n\n- 牺牲缓存（Victim cache）：一个容量为 $V$ 个块的全相联牺牲缓存位于 L1 缓存和主存之间。在 L1 缓存中未命中但在牺牲缓存中命中的访问，会在 $t_h$ 的基础上产生额外的 $t_v$ 个周期的开销（也就是说，牺牲缓存命中的惩罚被建模为 $t_v$）。如果访问在 L1 缓存和牺牲缓存中都未命中，则需要支付完整的未命中惩罚 $L$。\n- 在非阻塞缓存上的指针追逐预取：在接收到一个节点后，硬件预取器会为下一个节点发出一个预取请求。处理器在解引用下一个指针之前，对每个节点执行 $c$ 个周期的计算。缓存是非阻塞的，并支持至少 1 个未完成的未命中，从而允许内存访问和计算之间存在重叠。\n\n使用平均内存访问时间（AMAT）的定义 $AMAT = t_h + \\text{(miss rate)} \\times \\text{(average miss penalty)}$，并根据第一性原理推导独立操作的重叠情况。假设节点之间没有空间局部性，并忽略带宽限制和争用。推导在每种技术下 AMAT 的符号表达式，将其表示为 $m, R, V, t_h, L, t_v, c$ 的函数，然后分析当 $R$ 增大而所有其他参数保持固定且有限时，其极限行为。当 $R$ 变得很大时，关于哪种技术能更多地减少 AMAT，下面的哪个陈述是正确的？\n\nA. 对于任何有限的 $V$ 和固定的 $t_h, t_v, L$，当 $c > 0$ 时，随着 $R \\to \\infty$，在非阻塞缓存上的指针追逐预取器产生的 $AMAT$ 严格低于使用牺牲缓存的情况；相对于基准情况，预取器将暴露的未命中惩罚减少了 $m \\cdot \\min(L, c)$，且与 $R$ 无关。\n\nB. 随着 $R \\to \\infty$，牺牲缓存总是优于预取，因为它能消除冲突未命中，而与 $R$ 无关，所以对于任何 $V \\ge 1$，其 AMAT 都严格更低。\n\nC. 随着 $R \\to \\infty$，两种技术变得同样有效，并将 $AMAT$ 降低到 $t_h + m \\cdot t_v$，而与 $c$ 无关。\n\nD. 随着 $R \\to \\infty$，两种技术都不会改变 $AMAT$；它等于 $t_h + m \\cdot L$，而与 $c$ 和 $V$ 无关。",
            "solution": "用户需要对一个关于缓存优化的计算机体系结构问题进行批判性分析。分析必须从验证问题陈述开始，然后从第一性原理推导解决方案，并对所有提供的选项进行详细评估。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **工作负载**：在循环单链表上进行指针追逐。\n- **节点布局**：每个节点位于一个独立的缓存块中。\n- **L1 缓存命中时间**：$t_h$ 个周期。\n- **基准主存未命中惩罚**：$L$ 个周期。\n- **L1 未命中率**：$m$（在稳态下）。\n- **重用距离**：$R = W - 1$，其中 $W$ 是列表中的节点数。$R$ 是对同一块的两次使用之间访问的不同缓存块的数量。\n- **技术 1 (牺牲缓存)**：\n    - 全相联，容量为 $V$ 个块。\n    - 位于 L1 缓存和主存之间。\n    - L1 未命中、牺牲缓存命中的惩罚：$t_v$ 个周期。总访问时间为 $t_h + t_v$。\n    - L1 未命中、牺牲缓存未命中的惩罚：$L$ 个周期。总访问时间为 $t_h + L$。\n- **技术 2 (指针追逐预取)**：\n    - 硬件预取器在接收到当前节点后，为下一个节点发出预取请求。\n    - 处理器对每个节点执行 $c$ 个周期的计算。\n    - 缓存是非阻塞的，并支持至少 1 个未完成的未命中。\n- **AMAT 定义**：$AMAT = t_h + \\text{(miss rate)} \\times \\text{(average miss penalty)}$。\n- **假设**：节点之间没有空间局部性，忽略带宽限制和争用。\n- **问题**：为每种技术推导 AMAT 的符号表达式。分析当 $R \\to \\infty$ 而所有其他参数（$m, V, t_h, L, t_v, c$）保持固定且有限时的极限行为。确定在此极限下哪种技术能更多地减少 AMAT。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述描述了计算机体系结构性能分析中的一个标准场景。平均内存访问时间（AMAT）、牺牲缓存、指针追逐、非阻塞缓存和硬件预取等概念是该领域的基础。为每种优化提供的性能模型是标准的，尽管是简化的教科书示例。将未命中率 $m$ 与重用距离 $R$ 解耦是一种抽象，它允许我们专注于分析优化机制本身，而不是特定 L1 缓存替换策略的行为。该问题在科学上是合理的、定义明确的、客观的，并包含足够的信息以根据给定的模型推导出唯一的解决方案。没有矛盾、歧义或事实上的不健全之处。\n\n**步骤 3：结论与行动**\n问题陈述是 **有效的**。现在开始求解过程。\n\n### 推导与分析\n\n分析需要推导三种情况下的平均内存访问时间（AMAT）：基准情况、带牺牲缓存的系统，以及带指针追逐预取器的系统。\n\n**1. 基准 AMAT**\nAMAT 定义为命中时间加上未命中惩罚。给定 L1 命中时间 $t_h$，未命中率 $m$，以及主存未命中惩罚 $L$，基准 AMAT，$AMAT_{base}$ 为：\n$$AMAT_{base} = t_h + m \\cdot L$$\n\n**2. 带牺牲缓存的 AMAT ($AMAT_{VC}$)**\n一个容量为 $V$ 的牺牲缓存（VC）存储了从 L1 缓存中被驱逐的最后 $V$ 个块。L1 未命中将在 VC 中命中，前提是所请求的块是那 $V$ 个最近被驱逐的块之一。该工作负载的重用距离为 $R$，意味着在对给定块的两次连续访问之间，会访问 $R$ 个不同的块。\n\n如果一个块从 L1 缓存中被驱逐，它会进入 VC。为了当再次需要这个块时它仍然在 VC 中，期间从 L1 缓存中被驱逐的其他块的数量必须小于 $V$。在这个工作负载中，这 $R$ 个中间访问本身就会导致驱逐。如果 $R > V$，则可以肯定会有超过 $V$ 个块被驱逐，从而将原始块从 VC 中冲刷掉。\n\n- 如果 $R \\le V$：对一个块的 L1 未命中将在 VC 中命中，因为被驱逐的其他块少于 $V$ 个。未命中惩罚为 $t_v$。\n- 如果 $R > V$：对一个块的 L1 未命中也将在 VC 中未命中，因为超过 $V$ 个其他块被驱逐，将该块从 VC 中冲刷掉了。未命中惩罚为 $L$。\n\n因此，带牺牲缓存系统的 AMAT 取决于 $R$：\n$$AMAT_{VC} = t_h + m \\cdot \\begin{cases} t_v  \\text{if } R \\le V \\\\ L  \\text{if } R > V \\end{cases}$$\n问题要求分析 $R \\to \\infty$ 时的行为。由于 $V$ 是一个固定的有限值，对于任何 $V$，随着 $R$ 的增长，我们最终都会有 $R > V$。在这个极限下，对于这种工作负载模式，VC 是无效的。\n$$ \\lim_{R \\to \\infty} AMAT_{VC} = t_h + m \\cdot L $$\n\n**3. 带指针追逐预取的 AMAT ($AMAT_{PF}$)**\n在此方案中，一旦接收到当前节点 ($N_i$)，就会立即为下一个节点 ($N_{i+1}$) 发起内存访问。然后，处理器在为 $N_{i+1}$ 进行的预取操作执行期间，对 $N_i$ 进行 $c$ 个周期的计算。\n\n如果对 $N_{i+1}$ 的预取是 L1 未命中，它会产生 $L$ 个周期的延迟。然而，处理器并不会在这整个期间都停顿。它会忙于计算 $c$ 个周期。因此，内存访问延迟与计算重叠。处理器仅在延迟中未被计算隐藏的部分停顿。这个*暴露延迟*是 $\\max(0, L - c)$。这成为有效的未命中惩罚。\n\n带预取器的 AMAT 为：\n$$AMAT_{PF} = t_h + m \\cdot \\max(0, L - c)$$\n该表达式的值与重用距离 $R$ 无关。因此，当 $R \\to \\infty$ 时，其极限就是表达式本身：\n$$ \\lim_{R \\to \\infty} AMAT_{PF} = t_h + m \\cdot \\max(0, L - c)$$\n\n**4. 在 $R \\to \\infty$ 极限下的比较**\n我们必须比较极限情况下的两个 AMAT 表达式：\n- $\\lim_{R \\to \\infty} AMAT_{VC} = t_h + m \\cdot L$\n- $\\lim_{R \\to \\infty} AMAT_{PF} = t_h + m \\cdot \\max(0, L - c)$\n\n问题设定意味着 $L > 0$ 并要求考虑 $c > 0$。\n- 如果 $c \\ge L$，那么 $\\max(0, L-c) = 0$。因为 $L > 0$，我们有 $0  L$。\n- 如果 $0  c  L$，那么 $\\max(0, L-c) = L-c$。因为 $c  0$，我们有 $L-c  L$。\n在所有相关情况下（$c  0$），使用预取时的有效未命中惩罚 $\\max(0, L - c)$ 严格小于基准未命中惩罚 $L$。\n因此，$\\lim_{R \\to \\infty} AMAT_{PF}  \\lim_{R \\to \\infty} AMAT_{VC}$。对于大的重用距离，预取技术严格更优。\n\n### 逐项分析选项\n\n**A. 对于任何有限的 $V$ 和固定的 $t_h, t_v, L$，当 $c  0$ 时，随着 $R \\to \\infty$，在非阻塞缓存上的指针追逐预取器产生的 $AMAT$ 严格低于使用牺牲缓存的情况；相对于基准情况，预取器将暴露的未命中惩罚减少了 $m \\cdot \\min(L, c)$，且与 $R$ 无关。**\n- 陈述的第一部分声称，当 $R \\to \\infty$ 时，$AMAT_{PF}  AMAT_{VC}$。我们的推导证实了这一点：对于 $c0$，$t_h + m \\cdot \\max(0, L - c)  t_h + m \\cdot L$。\n- 第二部分量化了相对于基准情况的 AMAT 减少量。减少量为 $AMAT_{base} - AMAT_{PF} = (t_h + m \\cdot L) - (t_h + m \\cdot \\max(0, L - c)) = m \\cdot [L - \\max(0, L - c)]$。\n让我们分析一下 $L - \\max(0, L - c)$ 这一项。\n  - 如果 $c \\ge L$，此项为 $L - 0 = L$。在这种情况下，$\\min(L, c) = L$。\n  - 如果 $c  L$，此项为 $L - (L - c) = c$。在这种情况下，$\\min(L, c) = c$。\n因此，$L - \\max(0, L - c)$ 等价于 $\\min(L, c)$。AMAT 减少量为 $m \\cdot \\min(L, c)$。\n- 第三部分声称这种减少与 $R$ 无关。表达式 $m \\cdot \\min(L, c)$ 不包含 $R$，所以这是正确的。\n整个陈述与我们的分析一致。\n结论：**正确**。\n\n**B. 随着 $R \\to \\infty$，牺牲缓存总是优于预取，因为它能消除冲突未命中，而与 $R$ 无关，所以对于任何 $V \\ge 1$，其 AMAT 都严格更低。**\n这个陈述是错误的。我们的分析表明，当 $R \\to \\infty$ 时，预取器优于牺牲缓存。这些未命中不是一个小的 VC 可以解决的经典冲突未命中；由于长的重用距离（$R  V$），它们实际上是相对于 L1+VC 系统的容量未命中。VC 系统的 AMAT 接近基准值，而基准值高于预取器的 AMAT。\n结论：**错误**。\n\n**C. 随着 $R \\to \\infty$，两种技术变得同样有效，并将 $AMAT$ 降低到 $t_h + m \\cdot t_v$，而与 $c$ 无关。**\n这个陈述在多个方面都是错误的。这两种技术并不会变得同样有效；预取更优越。$AMAT_{VC}$ 的极限是 $t_h + m \\cdot L$，而不是 $t_h + m \\cdot t_v$。$AMAT_{PF}$ 的极限取决于 $c$。\n结论：**错误**。\n\n**D. 随着 $R \\to \\infty$，两种技术都不会改变 $AMAT$；它等于 $t_h + m \\cdot L$，而与 $c$ 和 $V$ 无关。**\n这个陈述部分正确但最终是错误的。对于牺牲缓存，$\\lim_{R \\to \\infty} AMAT_{VC} = t_h + m \\cdot L$ 是正确的。然而，预取器*确实*改变了 AMAT，将其降低到 $t_h + m \\cdot \\max(0, L - c)$。由于该陈述声称“两种技术都”无效，所以它是错误的。\n结论：**错误**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当我们通过预取等技术成功提升了理论上的内存级别并行度后，一个关键的实践问题随之而来：需要多少硬件资源来支持这种并行性？本练习将理论与实践相结合，要求你应用排队论中的基本结论——利特尔定律（Little's Law），来解决一个具体的硬件设计问题。你将计算为了维持目标内存带宽所需的最小“未命中状态保持寄存器”（$MSHRs$）数量，从而将系统吞吐量与硬件资源配置直接联系起来 。",
            "id": "3625723",
            "problem": "一个采用非阻塞一级（L1）数据缓存的单核处理器使用一个**未命中**状态保持寄存器（MSHR）阵列来跟踪进行中的缓存**未命中**。它还包括一个附加到L1的小型牺牲缓存，以减少冲突**未命中**，以及一个发出推测性读取请求的基于步幅的预取器。下层内存系统是位于二级（L2）缓存之后的动态随机存取存储器（DRAM），端到端的平均**未命中**服务时间为 $L$。\n\n内存控制器在访问大小为 $S$ 字节的连续行时，提供 $B$ 的持续读取带宽。为确保L1缓存能够产生足够的并发**未命中**，以维持等于带宽限制速率的目标行完成率，系统必须配置足够多的MSHR，使得平均未完成**未命中**数等于或超过由目标到达率和服务时间所隐含的并发性。\n\n从排队论（Little定律）中一个关于稳定系统的第一性原理结果出发，推导出一个连接平均未完成缓存**未命中**数（即有效的内存级并行（MLP））与**未命中**到达率和平均**未命中**服务时间的关系。然后，使用此关系计算必须配置的MSHR的最小整数数量，记为 $N$，以使L1能够维持带宽限制的目标到达率。\n\n假设以下参数：\n- 平均端到端**未命中**服务时间 $L = 110 \\,\\text{ns}$，\n- 持续DRAM读取带宽 $B = 51.2 \\,\\text{GB/s}$，\n- 缓存行大小 $S = 64 \\,\\text{B}$。\n\n忽略排队引起的延迟膨胀，并假设由于对同一行的同时请求而发生的合并不会改变维持目标吞吐量所需的并发性，因为MSHR跟踪的是不同的进行中行。精确计算 $N$ 为满足带宽限制的目标到达率所隐含的并发性的最小整数。最终答案表示为一个不带单位的整数。",
            "solution": "非阻塞一级（L1）缓存使用**未命中**状态保持寄存器（MSHR）阵列来跟踪缓存对下层内存有未完成**未命中**的进行中行。有效的内存级并行（MLP）是这类进行中**未命中**的平均数量。\n\n我们从排队论中的一个基本且经过广泛验证的结果——Little定律开始。对于一个稳定系统，其到达服务设施的到达率为 $\\lambda$，在设施中的平均时间为 $W$，则设施中的平均作业数由下式给出：\n$$\nN_{\\text{avg}} = \\lambda W.\n$$\n在缓存**未命中**的背景下，“作业”是流向低层内存并花费平均时间 $L$ 被服务的缓存行**未命中**。平均未完成**未命中**数等于有效的MLP。因此，\n$$\n\\text{MLP} = \\lambda L.\n$$\n一个非阻塞缓存需要至少与平均未完成的不同缓存**未命中**数一样多的**未命中**状态保持寄存器（MSHR），以避免因跟踪资源不足而停顿。因此，所需的MSHR的最小整数数量为\n$$\nN = \\left\\lceil \\lambda L \\right\\rceil.\n$$\n\n问题陈述目标到达率是受带宽限制的。如果持续内存带宽为 $B$，每次**未命中**传输 $S$ 字节，那么以“行/秒”为单位的目标到达率为\n$$\n\\lambda_{\\text{target}} = \\frac{B}{S}.\n$$\n我们现在代入给定的参数：\n- $B = 51.2 \\,\\text{GB/s} = 51.2 \\times 10^{9} \\,\\text{B/s}$，\n- $S = 64 \\,\\text{B}$，\n- $L = 110 \\,\\text{ns} = 110 \\times 10^{-9} \\,\\text{s}$。\n\n计算目标到达率：\n$$\n\\lambda_{\\text{target}} = \\frac{51.2 \\times 10^{9}}{64} = 0.8 \\times 10^{9} = 8.0 \\times 10^{8} \\,\\text{lines/s}.\n$$\n应用Little定律以获得所需的平均并发性：\n$$\n\\lambda_{\\text{target}} L = \\left(8.0 \\times 10^{8}\\right)\\left(110 \\times 10^{-9}\\right) = 8.0 \\times 110 \\times 10^{8-9} = 880 \\times 10^{-1} = 88.\n$$\n因为 $N$ 必须是一个整数，并且在这种情况下我们计算出了一个精确值，所以所需的MSHR的最小整数数量是\n$$\nN = 88.\n$$\n\n最后，关于请求合并：当多个处理器侧的请求指向同一行时，合并会减少不同的未完成行的数量，但维持每秒 $\\lambda_{\\text{target}}$ 行的吞吐量所需的并发性严格由不同内存操作的数量及其服务时间 $L$ 决定。因此，结果 $N = \\left\\lceil \\lambda_{\\text{target}} L \\right\\rceil$ 正确地反映了维持目标带宽限制的到达率所需的MSHR的最小数量。",
            "answer": "$$\\boxed{88}$$"
        }
    ]
}