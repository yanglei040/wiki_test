{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习将帮助你理解包容性与排他性缓存之间最核心的权衡。通过一个简化的工作负载场景，包含频繁访问的“热”数据和流式访问的“冷”数据，我们将探讨一个关键问题：包容性设计虽然简化了一致性管理，但代价是牺牲了部分 $L_2$ 缓存的有效容量。 这个练习要求你分析在不同策略下，“冷”数据是否能装入 $L_2$ 缓存，从而具体感受包容性有时如何因容量冲突而导致更高的未命中率。",
            "id": "3649269",
            "problem": "考虑一个双层数据缓存层次结构，包含上层缓存 $L_1$ 和下层缓存 $L_2$。$L_2$ 实现包含属性（$L_1 \\subseteq L_2$，称为包含式层次结构）或排除属性（各层级之间无重复数据，称为排除式层次结构）。两个缓存都采用写回策略、使用最近最少使用（LRU）替换算法，并假设为全相联以分离纯粹的容量效应。设 $L_1$ 的容量为 $S_1 = 32\\,\\text{KiB}$，$L_2$ 的容量为 $S_2 = 256\\,\\text{KiB}$，块大小为 $B = 64\\,\\text{B}$。假设工作负载重复执行多轮，每一轮包括：首先，重复访问一个大小为 $\\lvert H \\rvert$ 的热数据集 $H$，该数据集恰好能放入 $L_1$ 并常驻其中；其次，对一个大小为 $\\lvert C \\rvert$ 个块的冷数据集 $C$ 进行单次顺序遍历，遍历内部没有时间局部性。将 $L_2$ 未命中率 $M_{L_2}$ 定义为 $L_1$ 未命中中也在 $L_2$ 未命中的比例。假设 $L_1$ 命中不访问 $L_2$，并且测量关注多轮运行后的稳态，因此启动瞬态可以忽略不计。你可以假设，当 $\\lvert C \\rvert$ 能放入未被 $H$ 的副本占用的可用 $L_2$ 容量时，冷数据集的块会跨轮次保留在 $L_2$ 中；否则，它们不会保留。\n\n仅根据这些事实和定义，判断以下关于包含与排除策略如何影响 $M_{L_2}$ 的陈述中哪些是正确的。选择所有适用项。\n\nA. 对于 $\\lvert C \\rvert = 4000$ 个块，包含式 $L_2$ 复制了 $H$ 导致没有足够空间容纳 $C$，因此在稳态下对冷数据的访问 $M_{L_2}$ 接近 $1$；排除式 $L_2$ 有足够空间容纳 $C$，因此对冷数据的访问 $M_{L_2}$ 接近 $0$。在这种情况下，包含策略增加了 $M_{L_2}$。\n\nB. 对于 $\\lvert C \\rvert = 3000$ 个块，包含式和排除式 $L_2$ 都能跨轮次保留整个冷数据集，因此在稳态下对冷数据的访问 $M_{L_2}$ 接近 $0$；包含策略不增加 $M_{L_2}$。\n\nC. 对于 $\\lvert C \\rvert = 4096$ 个块，包含式和排除式 $L_2$ 在稳态下都会因访问 $C$ 而发生抖动，因此包含策略不改变 $M_{L_2}$。\n\nD. 对于 $\\lvert C \\rvert = 3584$ 个块，包含式和排除式 $L_2$ 都能跨轮次保留冷数据集，因此在稳态下对冷数据的访问 $M_{L_2}$ 接近 $0$；包含策略不增加 $M_{L_2}$。\n\nE. 对于此工作负载，包含策略降低了 $M_{L_2}$，因为 $H$ 存在于 $L_2$ 中，即使 $L_1$ 命中，$L_2$ 也可以服务于对 $H$ 的命中。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n-   **缓存层次结构**：双层数据缓存，上层缓存 $L_1$ 和下层缓存 $L_2$。\n-   **$L_2$ 策略**：包含式（$L_1 \\subseteq L_2$）或排除式（无重复）。\n-   **缓存参数**：两个缓存都采用写回策略，使用最近最少使用（LRU）替换算法，且为全相联。\n-   **容量和块大小**：\n    -   $L_1$ 容量：$S_1 = 32\\,\\text{KiB}$。\n    -   $L_2$ 容量：$S_2 = 256\\,\\text{KiB}$。\n    -   块大小：$B = 64\\,\\text{B}$。\n-   **工作负载**：重复执行多轮。每一轮包括：\n    1.  重复访问一个大小为 $\\lvert H \\rvert$ 的热数据集 $H$，该数据集恰好能放入 $L_1$ 并常驻其中。\n    2.  对一个大小为 $\\lvert C \\rvert$ 个块的冷数据集 $C$ 进行单次顺序遍历，遍历内部没有时间局部性。\n-   **度量指标**：$L_2$ 未命中率 $M_{L_2}$，即 $L_1$ 未命中中也在 $L_2$ 未命中的比例。\n-   **假设**：\n    1.  $L_1$ 命中不访问 $L_2$。\n    2.  测量关注稳态；启动瞬态可以忽略不计。\n    3.  当 $\\lvert C \\rvert$ 能放入未被 $H$ 的副本占用的可用 $L_2$ 容量时，冷数据集的块会跨轮次保留在 $L_2$ 中；否则，它们不会保留。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n\n-   **科学依据**：该问题在计算机体系结构，特别是缓存存储层次结构的原理方面有充分的依据。包含式和排除式缓存策略是标准的、定义明确的概念。工作负载虽然经过简化，但是一个用于分析混合了高局部性和流式数据访问的缓存性能的标准模型。\n-   **定义明确**：问题定义清晰。目标是在变化的工作负载参数下，比较两种不同缓存策略的 $M_{L_2}$。给定的条件足以确定结果。关于稳态下数据集 $C$ 保留行为的假设为分析提供了清晰、确定性的规则，使问题可解。\n-   **客观性**：问题使用精确、定量的语言陈述。“热数据集”和“冷数据集”由其访问模式定义，而非主观标签。\n-   **完整性和一致性**：问题是自包含的。所有必需的容量、大小和行为都已指定。热数据集 $H$ 的大小被隐式定义为 $L_1$ 的容量。让我们计算以块为单位的相关大小。\n    -   $L_1$ 容量（以块为单位）：$S_{1, \\text{blocks}} = S_1 / B = (32 \\times 1024\\,\\text{B}) / (64\\,\\text{B}) = 512$ 个块。\n    -   $L_2$ 容量（以块为单位）：$S_{2, \\text{blocks}} = S_2 / B = (256 \\times 1024\\,\\text{B}) / (64\\,\\text{B}) = 4096$ 个块。\n    -   热数据集大小：$\\lvert H \\rvert = S_{1, \\text{blocks}} = 512$ 个块，因为它“恰好能放入 $L_1$”。\n    设置中没有矛盾之处。\n-   **无其他缺陷**：该问题并非不切实际、定义不善、模棱两可或微不足道。它要求将包含式和排除式缓存的定义正确应用于基于容量的分析。\n\n### 步骤 3：结论与行动\n问题陈述有效。可以根据所提供的信息推导出严谨的解决方案。\n\n## 解题推导\n\n问题的核心是确定在包含式和排除式策略下，$L_2$ 中可用于冷数据集 $C$ 的容量，然后应用给定的稳态规则。\n\n工作负载有两个部分：\n1.  对热数据集 $H$ 的访问。这些都是 $L_1$ 命中。问题陈述中提到“$L_1$ 命中不访问 $L_2$”。因此，这些访问不会产生到 $L_2$ 的流量，也不会影响其状态或 $M_{L_2}$ 指标。\n2.  对冷数据集 $C$ 的顺序遍历。由于 $L_1$ 已被常驻集 $H$ 占满，每次对 $C$ 中块的访问都将是 $L_1$ 未命中。因此，每轮的 $L_1$ 未命中次数为 $\\lvert C \\rvert$。\n$L_2$ 未命中率 $M_{L_2}$ 是这些 $L_1$ 未命中中同时也在 $L_2$ 未命中的比例。\n\n稳态行为取决于数据集 $C$ 是否能跨轮次保留在 $L_2$ 中。\n-   如果 $C$ 保留（即它能放入可用的 $L_2$ 容量中），那么在第一轮之后，后续对 $C$ 的访问将是 $L_2$ 命中。在稳态下，$M_{L_2} \\approx 0$。\n-   如果 $C$ 不保留（即它大于可用的 $L_2$ 容量），那么在一轮中获取的 $C$ 的块将在下一轮之前被驱逐。在稳态下，每次对 $C$ 中块的访问都将是 $L_2$ 未命中，所以 $M_{L_2} \\approx 1$。\n\n让我们分析每种策略下可用的 $L_2$ 容量。$L_2$ 的总容量是 $S_{2, \\text{blocks}} = 4096$ 个块。热数据集大小为 $\\lvert H \\rvert = 512$ 个块。\n\n### 包含式层次结构 ($L_1 \\subseteq L_2$)\n根据包含属性，任何存在于 $L_1$ 中的块也必须存在于 $L_2$ 中。由于热数据集 $H$ 常驻于 $L_1$，所有 $\\lvert H \\rvert = 512$ 个 $H$ 的块也必须常驻于 $L_2$ 中。这些块被重复访问，使其成为最近最常使用的块，因此它们不会被对 $C$ 的顺序扫描所驱逐。\n$L_2$ 中可用于冷数据集 $C$ 的容量是总 $L_2$ 容量减去 $H$ 的副本所占用的空间：\n$$ \\text{可用 } L_2 \\text{ 容量（包含式）} = S_{2, \\text{blocks}} - \\lvert H \\rvert = 4096 - 512 = 3584 \\text{ 个块} $$\n因此，对于包含式层次结构，$C$ 能保留的条件是 $\\lvert C \\rvert \\le 3584$。\n-   如果 $\\lvert C \\rvert \\le 3584$，$M_{L_2} \\approx 0$。\n-   如果 $\\lvert C \\rvert > 3584$，$M_{L_2} \\approx 1$。\n\n### 排除式层次结构\n根据排除属性，一个块不能同时存在于 $L_1$ 和 $L_2$ 中。热数据集 $H$ 驻留在 $L_1$ 中。因此，$H$ 的块不在 $L_2$ 中。$L_2$ 的全部容量可用于其他数据，例如冷数据集 $C$。\n$$ \\text{可用 } L_2 \\text{ 容量（排除式）} = S_{2, \\text{blocks}} = 4096 \\text{ 个块} $$\n因此，对于排除式层次结构，$C$ 能保留的条件是 $\\lvert C \\rvert \\le 4096$。\n-   如果 $\\lvert C \\rvert \\le 4096$，$M_{L_2} \\approx 0$。\n-   如果 $\\lvert C \\rvert > 4096$，$M_{L_2} \\approx 1$。\n\n## 逐项分析\n\n现在我们使用这些推导出的阈值来评估每个陈述。\n\n**A. 对于 $\\lvert C \\rvert = 4000$ 个块，包含式 $L_2$ 复制了 $H$ 导致没有足够空间容纳 $C$，因此在稳态下对冷数据的访问 $M_{L_2}$ 接近 $1$；排除式 $L_2$ 有足够空间容纳 $C$，因此对冷数据的访问 $M_{L_2}$ 接近 $0$。在这种情况下，包含策略增加了 $M_{L_2}$。**\n-   **包含式**：$\\lvert C \\rvert = 4000$。可用容量为 $3584$ 个块。由于 $4000 > 3584$，冷数据集 $C$ 无法放入。$C$ 的块将不会保留，$L_2$ 将会发生抖动。因此，$M_{L_2} \\approx 1$。该推理是正确的。\n-   **排除式**：$\\lvert C \\rvert = 4000$。可用容量为 $4096$ 个块。由于 $4000 \\le 4096$，冷数据集 $C$ 可以放入。$C$ 的块将会保留。因此，$M_{L_2} \\approx 0$。该推理是正确的。\n-   **比较**：包含策略导致 $M_{L_2} \\approx 1$，而排除策略导致 $M_{L_2} \\approx 0$。包含策略明显增加了 $M_{L_2}$。整个陈述是正确的。\n-   结论：**正确**。\n\n**B. 对于 $\\lvert C \\rvert = 3000$ 个块，包含式和排除式 $L_2$ 都能跨轮次保留整个冷数据集，因此在稳态下对冷数据的访问 $M_{L_2}$ 接近 $0$；包含策略不增加 $M_{L_2}$。**\n-   **包含式**：$\\lvert C \\rvert = 3000$。可用容量为 $3584$ 个块。由于 $3000 \\le 3584$，$C$ 可以放入并保留。$M_{L_2} \\approx 0$。\n-   **排除式**：$\\lvert C \\rvert = 3000$。可用容量为 $4096$ 个块。由于 $3000 \\le 4096$，$C$ 可以放入并保留。$M_{L_2} \\approx 0$。\n-   **比较**：两种策略都导致 $M_{L_2} \\approx 0$。因此，两者都保留了冷数据集，且包含策略没有增加 $M_{L_2}$（它保持在 $0$ 不变）。该陈述是正确的。\n-   结论：**正确**。\n\n**C. 对于 $\\lvert C \\rvert = 4096$ 个块，包含式和排除式 $L_2$ 在稳态下都会因访问 $C$ 而发生抖动，因此包含策略不改变 $M_{L_2}$。**\n-   **包含式**：$\\lvert C \\rvert = 4096$。可用容量为 $3584$ 个块。由于 $4096 > 3584$，包含式 $L_2$ 没有空间容纳 $C$，将会发生抖动。$M_{L_2} \\approx 1$。\n-   **排除式**：$\\lvert C \\rvert = 4096$。可用容量为 $4096$ 个块。由于 $4096 \\le 4096$，冷数据集 $C$ 恰好能放入并将保留。$M_{L_2} \\approx 0$。\n-   **比较**：该陈述声称两者都会发生抖动，这是错误的。排除式 $L_2$ 不会发生抖动。包含策略将 $M_{L_2}$ 从大约 $0$ 变为大约 $1$。该陈述不正确。\n-   结论：**不正确**。\n\n**D. 对于 $\\lvert C \\rvert = 3584$ 个块，包含式和排除式 $L_2$ 都能跨轮次保留冷数据集，因此在稳态下对冷数据的访问 $M_{L_2}$ 接近 $0$；包含策略不增加 $M_{L_2}$。**\n-   **包含式**：$\\lvert C \\rvert = 3584$。可用容量为 $3584$ 个块。由于 $3584 \\le 3584$，$C$ 恰好能放入并保留。$M_{L_2} \\approx 0$。\n-   **排除式**：$\\lvert C \\rvert = 3584$。可用容量为 $4096$ 个块。由于 $3584 \\le 4096$，$C$ 可以放入并保留。$M_{L_2} \\approx 0$。\n-   **比较**：两种策略都导致 $M_{L_2} \\approx 0$。因此，两者都保留了冷数据集，且包含策略没有增加 $M_{L_2}$。该陈述是正确的。\n-   结论：**正确**。\n\n**E. 对于此工作负载，包含策略降低了 $M_{L_2}$，因为 $H$ 存在于 $L_2$ 中，即使 $L_1$ 命中，$L_2$ 也可以服务于对 $H$ 的命中。**\n-   这个陈述提出了两个论点。第一，包含策略*降低*了 $M_{L_2}$。我们的分析表明，对于此工作负载，包含策略要么增加 $M_{L_2}$（例如，当 $3584  \\lvert C \\rvert \\le 4096$ 时），要么使其保持不变（当 $\\lvert C \\rvert \\le 3584$ 或 $\\lvert C \\rvert  4096$ 时）。它从未降低 $M_{L_2}$。\n-   第二，给出的理由是“$L_2$ 可以服务于对 $H$ 的命中”。这与问题的假设“$L_1$ 命中不访问 $L_2$”明确矛盾。由于对 $H$ 的所有访问都是 $L_1$ 命中，因此 $H$ 在 $L_2$ 中的存在对命中没有任何好处。事实上，它是有害的，因为它减少了 $L_2$ 对冷数据流 $C$ 的有效容量。这个选项的整个前提都是有问题的。\n-   结论：**不正确**。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "在建立了容量权衡的直观概念后，我们现在引入一个形式化的数学模型来对其进行量化。 这个练习使用独立参考模型（Independent Reference Model, IRM）来精确描述有效缓存容量的变化如何直接影响未命中率。你需要利用从排他性缓存结构中测量得到的数据，推导出包容性结构下的 $L_2$ 局部未命中率，从而加深对缓存性能分析模型的理解。",
            "id": "3649293",
            "problem": "一个单核中央处理器 (CPU) 在一个由一级缓存 $L1$ 和二级缓存 $L2$ 组成的两级缓存层次结构上执行工作负载。两个缓存都使用最近最少使用 (LRU) 替换策略，容量以缓存行的数量表示。$L1$ 的容量为 $C_{L1} = 64$ 行，$L2$ 的容量为 $C_{L2} = 256$ 行。首先考虑一个基准设计，其中 $L2$ 是与 $L1$ 独占的（即 $L2$ 中不保留 $L1$ 中数据的副本）。对于此工作负载，测得的局部未命中率分别为 $M_{L1} = 0.5$ 和 $M_{L2} = 0.0625$。\n\n假设采用独立引用模型 (IRM)，其重用距离 $D$ 服从参数为 $\\alpha  0$ 的指数分布，这意味着对于容量为 $C$ 行的 LRU 缓存，一次引用未命中的概率为 $\\mathbb{P}(D  C) = \\exp(-\\alpha C)$。某一级缓存的局部未命中率定义为对该级缓存的访问中发生未命中的比例。\n\n现在将缓存层次结构更改为包容性：为了维持包容性，$L2$ 必须保留 $C_{L1}$ 行来复制所有 $L1$ 的内容，这样 $L2$ 中仅剩下 $C_{L2,\\text{unique}} = C_{L2} - C_{L1}$ 行可用于存储不在 $L1$ 中的数据。\n\n从重用距离和 LRU 栈行为的定义出发，推导包容性设计中 $L2$ 局部未命中率的表达式。然后，使用给定的测量值和容量，计算包容性 $L2$ 局部未命中率的数值。将最终结果表示为小数，并四舍五入到四位有效数字。",
            "solution": "该问题要求在给定基准独占层次结构的测量值和未命中率的理论模型的情况下，计算包容性层次结构中 L2 缓存的局部未命中率。\n\n首先，我们必须验证问题的陈述。\n\n**步骤 1：提取已知条件**\n- CPU：单核\n- 缓存层次结构：两级 ($L1$, $L2$)\n- 替换策略：最近最少使用 (LRU)\n- $L1$ 容量：$C_{L1} = 64$ 行\n- $L2$ 容量：$C_{L2} = 256$ 行\n- 基准设计：$L2$ 与 $L1$ 独占。\n- 基准 $L1$ 局部未命中率：$M_{L1} = 0.5$\n- 基准 $L2$ 局部未命中率（独占）：$M_{L2} = 0.0625$\n- 工作负载模型：独立引用模型 (IRM)，重用距离为 $D$。\n- 重用距离分布：对于容量为 $C$ 的 LRU 缓存，$\\mathbb{P}(D  C) = \\exp(-\\alpha C)$，其中 $\\alpha  0$。\n- 新设计：$L2$ 对 $L1$ 具有包容性。\n- 陈述的包容性属性：$L2$ 为 $L1$ 的内容保留 $C_{L1}$ 行，剩下 $C_{L2,\\text{unique}} = C_{L2} - C_{L1}$ 行用于存储不在 $L1$ 中的数据。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在计算机体系结构和性能建模领域内是明确定义的。包容性/独占性缓存、LRU 替换和未命中率等概念都是标准概念。带有指数重用距离分布的独立引用模型是一种常见的分析工具，尽管它简化了真实世界的行为。\n\n我们必须验证所提供的数据与给定模型的一致性。\n在应用于 LRU 缓存的 IRM 模型下，容量为 $C$ 的独立缓存的未命中率由 $\\mathbb{P}(D  C)$ 给出。\n$L1$ 缓存是所有内存引用的第一个接触点，因此其局部未命中率可以直接建模为：\n$M_{L1} = \\mathbb{P}(D  C_{L1}) = \\exp(-\\alpha C_{L1})$\n\n对于独占性两级层次结构，只有当访问在 $L1$ 中未命中时，才会被发送到 $L2$。$L2$ 的局部未命中率 $M_{L2}$ 是指在引用已在 $L1$ 中未命中的条件下，该引用在 $L2$ 中也未命中的条件概率。在一个总唯一容量为 $C_{L1} + C_{L2}$ 的独占层次结构中，如果 $D  C_{L1} + C_{L2}$，则整个层次结构发生未命中。因此，局部 $L2$ 未命中率为：\n$M_{L2, \\text{excl}} = \\mathbb{P}(D  C_{L1} + C_{L2} | D  C_{L1}) = \\frac{\\mathbb{P}((D  C_{L1}+C_{L2}) \\cap (D  C_{L1}))}{\\mathbb{P}(D  C_{L1})}$\n由于 $C_{L1}$ 和 $C_{L2}$ 均为正数，所以 $C_{L1} + C_{L2}  C_{L1}$，因此事件 $D  C_{L1} + C_{L2}$ 蕴含了 $D  C_{L1}$。交集就是 $D  C_{L1} + C_{L2}$。\n$M_{L2, \\text{excl}} = \\frac{\\mathbb{P}(D  C_{L1} + C_{L2})}{\\mathbb{P}(D  C_{L1})} = \\frac{\\exp(-\\alpha(C_{L1} + C_{L2}))}{\\exp(-\\alpha C_{L1})} = \\exp(-\\alpha C_{L2})$\n\n我们来检查是否存在一个单一的 $\\alpha$ 值能同时满足给定的两个测量值：\n根据 $L1$ 的数据：$M_{L1} = 0.5$ 且 $C_{L1} = 64$。\n$0.5 = \\exp(-\\alpha \\cdot 64)$\n$\\ln(0.5) = -64\\alpha \\implies -\\ln(2) = -64\\alpha \\implies \\alpha = \\frac{\\ln(2)}{64}$\n\n根据 $L2$ 的数据：$M_{L2} = 0.0625$ 且 $C_{L2} = 256$。\n$0.0625 = \\exp(-\\alpha \\cdot 256)$\n注意 $0.0625 = \\frac{1}{16} = (\\frac{1}{2})^4 = 2^{-4}$。\n$\\ln(2^{-4}) = -256\\alpha \\implies -4\\ln(2) = -256\\alpha \\implies \\alpha = \\frac{4\\ln(2)}{256} = \\frac{\\ln(2)}{64}$\n$\\alpha$ 的值对于两个测量值是一致的。因此，该问题在科学上是合理的、自洽的，并且是适定的。\n\n**步骤 3：结论与行动**\n问题有效。我们继续进行求解。\n\n**求解推导**\n目标是求出包容性设计中 $L2$ 缓存的局部未命中率，我们将其表示为 $M_{L2, \\text{incl}}$。\n在包容性层次结构中，$L1$ 的内容是 $L2$ 内容的严格子集。整个 L1-L2 层次结构实际上相当于一个总容量为 $C_{L2}$ 的大型缓存，其中有一个命中速度更快、大小为 $C_{L1}$ 的部分。\n如果一次访问的重用距离 $D \\leq C_{L1}$，则它在 $L1$ 中命中。\n如果 $C_{L1}  D \\leq C_{L2}$，则它在 $L2$ 中命中（但在 $L1$ 中未命中）。\n如果 $D  C_{L2}$，则访问在整个层次结构中未命中（全局未命中）。\n根据定义，包容性层次结构中的 $L2$ 未命中就是一次全局未命中。\n\n$L2$ 的局部未命中率是指在一次访问是针对 $L2$（即它在 $L1$ 中未命中）的前提下，该引用在 $L2$ 中未命中的概率。\n$M_{L2, \\text{incl}} = \\mathbb{P}(\\text{在 } L2 \\text{ 中未命中} | \\text{在 } L1 \\text{ 中未命中})$\n事件“在 $L1$ 中未命中”对应于 $D  C_{L1}$。\n事件“在 $L2$ 中未命中”对应于 $D  C_{L2}$。\n所以，我们需要计算条件概率：\n$M_{L2, \\text{incl}} = \\mathbb{P}(D  C_{L2} | D  C_{L1})$\n\n使用条件概率的定义 $\\mathbb{P}(A|B) = \\frac{\\mathbb{P}(A \\cap B)}{\\mathbb{P}(B)}$：\n$M_{L2, \\text{incl}} = \\frac{\\mathbb{P}((D  C_{L2}) \\cap (D  C_{L1}))}{\\mathbb{P}(D  C_{L1})}$\n由于 $C_{L2} = 256$ 大于 $C_{L1} = 64$，任何大于 $C_{L2}$ 的重用距离 $D$ 也必然大于 $C_{L1}$。因此，这两个事件的交集就是事件 $D  C_{L2}$。\n$M_{L2, \\text{incl}} = \\frac{\\mathbb{P}(D  C_{L2})}{\\mathbb{P}(D  C_{L1})}$\n\n这就是在 IRM 模型和 LRU 策略下，包容性 $L2$ 局部未命中率的通用表达式。关于 $C_{L2,\\text{unique}}$ 的陈述是对包容性 L2 缓存内部空间分配的正确描述，但这并不改变整个层次结构所缓冲的唯一数据总量对应于容量 $C_{L2}$ 这一事实。\n\n现在，我们代入指数分布模型：\n$\\mathbb{P}(D  C_{L2}) = \\exp(-\\alpha C_{L2})$\n$\\mathbb{P}(D  C_{L1}) = \\exp(-\\alpha C_{L1})$\n\n所以，$M_{L2, \\text{incl}} = \\frac{\\exp(-\\alpha C_{L2})}{\\exp(-\\alpha C_{L1})}$。\n\n我们可以计算这个值。根据验证过程中的分析，我们认出这些项：\n分子 $\\exp(-\\alpha C_{L2})$ 正是基准设计中独占 L2 缓存的局部未命中率的表达式，其给定值为 $M_{L2, \\text{excl}} = 0.0625$。\n分母 $\\exp(-\\alpha C_{L1})$ 是 L1 缓存的局部未命中率，其给定值为 $M_{L1} = 0.5$。\n\n因此，我们无需显式计算 $\\alpha$ 即可得出结果：\n$M_{L2, \\text{incl}} = \\frac{M_{L2, \\text{excl}}}{M_{L1}} = \\frac{0.0625}{0.5}$\n$M_{L2, \\text{incl}} = \\frac{1/16}{1/2} = \\frac{1}{16} \\times 2 = \\frac{2}{16} = \\frac{1}{8}$\n$M_{L2, \\text{incl}} = 0.125$\n\n题目要求最终答案以小数形式表示，并四舍五入到四位有效数字。\n数字 $0.125$ 有三位有效数字（$1, 2, 5$）。\n为了用四位有效数字表示，我们在末尾追加一个零。\n$M_{L2, \\text{incl}} = 0.1250$。",
            "answer": "$$\n\\boxed{0.1250}\n$$"
        },
        {
            "introduction": "选择缓存策略不仅要考虑容量和未命中率，还涉及更深层次的系统行为。最后一个练习  探讨了包容性设计的一个关键机制：为维护数据一致性而引入的反向无效（back-invalidation）。本题构建了一个竞态条件场景，其中一致性维护操作可能与正常的处理器加载指令发生冲突，并要求你使用泊松过程模型来计算由此引发的停顿概率，让你体会到系统设计中性能、复杂度和正确性之间的精妙平衡。",
            "id": "3649215",
            "problem": "一个单核中央处理器 (CPU) 拥有一个私有的一级 (L$1$) 数据缓存和一个私有的二级 (L$2$) 缓存。该缓存层次结构是包容性的：存在于 L$1$ 中的每个缓存行也同时存在于 L$2$ 中，并且当 L$2$ 驱逐一个缓存行时，它会向 L$1$ 发送针对该行的回溯失效指令。考虑一个特定的缓存行，记为 $X$，它当前在 L$1$ 和 L$2$ 中都有效。命中 L$1$ 的对 $X$ 的加载操作具有一个确定的服务时间，为 $\\tau_{L1} = 5$ 个时钟周期。\n\n当 $X$ 驻留在 L$2$ 中且有效时，由 L$2$ 驱逐 $X$ 并触发对 L$1$ 的回溯失效，这一过程可以在 L$1$ 层面被建模为一个齐次泊松到达过程，其失效消息的到达率为每个时钟周期 $\\lambda_{i} = 0.03$。假设发起对 $X$ 的加载操作的时间与失效到达过程无关，并且在对 $X$ 的加载开始在 L$1$ 中服务之前，$X$ 在 L$1$ 中是有效的。\n\n定义一个停顿事件如下：如果在加载操作的 L$1$ 服务的开放区间内，即在 $[t, t + \\tau_{L1})$ 内（其中 $t$ 是加载的 L$1$ 服务开始时间），L$1$ 接收到针对 $X$ 的失效指令，则该加载操作将被废弃并重试，从而产生一次归因于包容性回溯失效竞争的停顿。\n\n仅使用包容性缓存的基本定义和齐次泊松过程的标准性质，从第一性原理推导出一个随机发起的对 $X$ 的加载操作因这种包容性回溯失效竞争而停顿的概率 $p_{s}$ 的表达式，然后计算在给定 $\\lambda_{i}$ 和 $\\tau_{L1}$ 下的数值。将您的答案四舍五入到 $4$ 位有效数字。以无单位的小数形式表示最终结果。作为背景知识，简要解释为什么在排他性层次结构中（其中 L$2$ 不维护 L$1$ 中缓存行的副本），同样的竞争不会发生。",
            "solution": "首先将根据指定的可靠性和完整性标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   系统：一个单核中央处理器 (CPU)。\n-   缓存层次结构：一个私有的一级 (L$1$) 数据缓存和一个私有的二级 (L$2$) 缓存。\n-   包容性：该层次结构是包容性的，意味着存在于 L$1$ 中的每个缓存行也同时存在于 L$2$ 中。当 L$2$ 驱逐一个缓存行时，它会向 L$1$ 发送针对该行的回溯失效指令。\n-   状态：一个缓存行 $X$ 当前在 L$1$ 和 L$2$ 中都有效。\n-   L$1$ 服务时间：命中 L$1$ 的对 $X$ 的加载操作具有一个确定的服务时间，为 $\\tau_{L1} = 5$ 个时钟周期。\n-   失效模型：由 L$2$ 驱逐 $X$ 并触发对 L$1$ 的回溯失效，这一过程被建模为 L$1$ 处的一个齐次泊松到达过程，其速率为每个时钟周期 $\\lambda_{i} = 0.03$。\n-   假设：\n    1.  发起对 $X$ 的加载操作的时间与失效到达过程无关。\n    2.  在对 $X$ 的加载开始在 L$1$ 中服务之前，$X$ 在 L$1$ 中是有效的。\n-   停顿事件定义：在加载操作的 L$1$ 服务的开放区间 $[t, t + \\tau_{L1})$ 内（其中 $t$ 是加载的 L$1$ 服务开始时间），L$1$ 接收到针对 $X$ 的失效指令。\n-   要求输出：\n    1.  从第一性原理推导停顿概率 $p_{s}$ 的表达式。\n    2.  计算给定 $\\lambda_{i}$ 和 $\\tau_{L1}$ 下 $p_{s}$ 的数值，并四舍五入到 $4$ 位有效数字。\n    3.  简要解释为什么这种竞争条件在排他性缓存层次结构中不会发生。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学基础**：该问题基于计算机体系结构的既定原则，特别是包容性缓存层次结构的行为。L$2$ 驱逐时进行回溯失效的概念是维持包容性属性的基础。使用齐次泊松过程是系统性能分析中为随机、独立事件建模的一种标准且科学有效的方法。\n-   **适定性**：该问题是适定的。它提供了所有必要的参数（$\\lambda_{i}$，$\\tau_{L1}$）、一个清晰的概率模型，以及对目标事件（停顿）的精确定义。这使得可以推导和计算出唯一的、有意义的解。\n-   **客观性**：语言正式、精确，没有主观或含糊的术语。\n-   **完整性和一致性**：该问题是自洽且内部一致的。关键假设——加载服务开始时缓存行 $X$ 在 L$1$ 中有效——将问题隔离到服务期间的竞争条件上，而这正是需要分析的核心。没有缺失基本信息，也没有相互矛盾的约束。\n-   **现实性和可行性**：所提供的 L$1$ 服务时间（$\\tau_{L1} = 5$ 个时钟周期）和失效率（每个时钟周期 $\\lambda_{i} = 0.03$）的数值对于现代处理器架构是物理上合理的。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**，因为它科学合理、适定且完整。将提供完整的解答。\n\n### 求解推导\n\n问题要求计算一个特定停顿事件的概率。该事件定义为：在 L$1$ 缓存为缓存行 $X$ 的加载操作提供服务期间，至少有一条针对该行 $X$ 的回溯失效消息到达。\n\n设 $N(T)$ 是一个随机变量，表示在持续时间为 $T$ 的时间间隔内失效消息到达的数量。问题指出，这些到达遵循一个恒定速率为 $\\lambda_{i}$ 的齐次泊松过程。泊松过程的概率质量函数给出了在持续时间为 $T$ 的间隔内观察到恰好 $k$ 个事件的概率：\n$$ P(N(T) = k) = \\frac{(\\lambda_{i} T)^{k} \\exp(-\\lambda_{i} T)}{k!} $$\n其中 $k$ 是一个非负整数（$k=0, 1, 2, \\dots$）。\n\n对缓存行 $X$ 的加载具有一个确定的服务时间 $\\tau_{L1}$。如果在此服务期间有一个或多个失效消息到达，则发生停顿事件。因此，所考虑的时间间隔的持续时间为 $T = \\tau_{L1}$。\n\n停顿概率 $p_{s}$ 是在长度为 $\\tau_{L1}$ 的时间间隔内，失效消息到达次数大于或等于 1 的概率。\n$$ p_{s} = P(N(\\tau_{L1}) \\ge 1) $$\n\n更直接的方法是首先计算其互补事件的概率：即在该时间间隔内没有失效消息到达。使用泊松概率质量函数，设 $k=0$ 且 $T=\\tau_{L1}$：\n$$ P(N(\\tau_{L1}) = 0) = \\frac{(\\lambda_{i} \\tau_{L1})^{0} \\exp(-\\lambda_{i} \\tau_{L1})}{0!} $$\n\n根据定义，对于任何非零 $x$，$x^{0} = 1$，且 $0! = 1$。这可将表达式简化为：\n$$ P(N(\\tau_{L1}) = 0) = \\exp(-\\lambda_{i} \\tau_{L1}) $$\n\n至少发生一个事件的概率是零个事件概率的补集。因此，停顿概率 $p_{s}$ 从第一性原理推导如下：\n$$ p_{s} = 1 - P(N(\\tau_{L1}) = 0) = 1 - \\exp(-\\lambda_{i} \\tau_{L1}) $$\n这就是停顿概率的解析表达式。\n\n接下来，我们使用给定的参数计算其数值：\n-   失效率：$\\lambda_{i} = 0.03 \\text{ 时钟周期}^{-1}$\n-   L$1$ 服务时间：$\\tau_{L1} = 5 \\text{ 时钟周期}$\n\n指数的参数是 $\\lambda_{i} \\tau_{L1}$ 的乘积：\n$$ \\lambda_{i} \\tau_{L1} = (0.03) \\times (5) = 0.15 $$\n该乘积是一个无量纲量，符合指数的要求。\n\n将此值代入 $p_{s}$ 的表达式中：\n$$ p_{s} = 1 - \\exp(-0.15) $$\n\n计算数值：\n$$ \\exp(-0.15) \\approx 0.860707976... $$\n$$ p_{s} \\approx 1 - 0.860707976... = 0.139292023... $$\n\n将结果四舍五入到 $4$ 位有效数字，我们得到：\n$$ p_{s} \\approx 0.1393 $$\n\n### 排他性层次结构背景\n\n问题的最后一部分询问为什么这种竞争条件在排他性缓存层次结构中不会发生。排他性层次结构强制执行一个属性，即一个给定的缓存行在层次结构中最多只能存在于一个缓存中（不包括主内存）。具体来说，如果一个缓存行存在于 L$1$ 缓存中，它就不能同时存在于 L$2$ 缓存中。\n\n1.  **竞争的基本前提**：所述的竞争条件由 L$2$ 缓存驱逐操作引发。L$2$ 缓存驱逐缓存行 $X$，由于层次结构是包容性的，它必须向 L$1$ 缓存发送回溯失效指令，以移除其在 L$1$ 中的副本并维持包容性。这个失效指令可能在 L$1$ 正在为对 $X$ 的加载操作提供服务时到达，从而导致停顿。\n\n2.  **排他性防止了触发**：在排他性层次结构中，如果缓存行 $X$ 在 L$1$ 缓存中是有效的（如同加载操作被服务时的情况），那么根据定义，它*不*存在于 L$2$ 缓存中。由于缓存行 $X$ 不在 L$2$ 缓存中，L$2$ 缓存无法驱逐它。L$2$ 的驱逐操作只能针对驻留在 L$2$ 中的缓存行。因此，在包容性情况下触发回溯失效的事件——即 L$2$ 对缓存行 $X$ 的驱逐——在排他性层次结构中从结构上就是不可能发生的。因此，L$1$ 加载访问与源自 L$2$ 的对同一缓存行的回溯失效之间的特定竞争条件不会发生。",
            "answer": "$$\\boxed{0.1393}$$"
        }
    ]
}