{
    "hands_on_practices": [
        {
            "introduction": "This first practice problem provides a direct look at the core power of Tomasulo's algorithm: out-of-order execution. By tracing a set of dependent and independent instructions, you will calculate the precise cycle at which each completes, demonstrating how the processor can bypass a stalled instruction to execute others that are ready. This exercise () solidifies the fundamental concepts of data dependency tracking through reservation stations and the role of the Common Data Bus in broadcasting results.",
            "id": "3685502",
            "problem": "Consider a Tomasulo-style dynamically scheduled pipeline with the following characteristics and definitions. Tomasulo’s algorithm performs register renaming using Reservation Stations (RS) to eliminate Write After Read (WAR) and Write After Write (WAW) hazards, begins execution in a Functional Unit (FU) as soon as all operands are available, and broadcasts produced results on a single Common Data Bus (CDB) to wake dependent RS entries. There is no Reorder Buffer (ROB); the register file is updated immediately upon CDB broadcast. An RS entry captures either operand values or tags to be matched on the CDB, and execution begins only when both operands are available and the corresponding FU is free. In this system:\n- Issue rate is one instruction per cycle, starting at cycle $1$.\n- Addition uses two identical add Functional Units (FUs) with latency $L_{\\text{add}} = 2$ cycles.\n- Multiplication uses one multiply Functional Unit (FU) with latency $L_{\\text{mul}} = 5$ cycles.\n- Add Reservation Stations: $3$ entries; Multiply Reservation Stations: $2$ entries.\n- Execution begins in the cycle immediately following issue if both operands are available and an FU is free; otherwise, it begins in the cycle immediately following the cycle in which both operands become available and an FU is free.\n- A result produced by an FU is broadcast on the CDB in the cycle immediately following the last execution cycle. If multiple results contend for the CDB in the same cycle, the RS entry with the lower index wins and the other result is delayed by exactly one cycle.\n- Source operands $R_5$, $R_6$, $R_8$, and $R_9$ are available at cycle $1$. Operand $R_3$ is available at cycle $1$. Operand $R_2$ is not available at issue due to a prior long-latency load and becomes available on the CDB at cycle $6$.\n\nYou are given the following instruction sequence (program order), where all three additions are independent of one another, and the two multiplications form a dependence chain on the additions:\n1. $I_1$: $R_1 \\leftarrow R_2 + R_3$\n2. $I_2$: $R_4 \\leftarrow R_5 + R_6$\n3. $I_3$: $R_7 \\leftarrow R_8 + R_9$\n4. $I_4$: $R_{10} \\leftarrow R_1 \\times R_4$\n5. $I_5$: $R_{11} \\leftarrow R_{10} \\times R_7$\n\nAssume RS indices are assigned in program order within each RS file (that is, the first add gets $\\text{A1}$, the next add gets $\\text{A2}$, and so on; the first multiply gets $\\text{M1}$, the next multiply gets $\\text{M2}$), and that RS index determines CDB arbitration priority in case of a tie. There are no cache misses other than the delayed availability of $R_2$ at cycle $6$, and no structural hazards beyond the FU counts stated above.\n\nTasks:\n- Using the operational definitions above, determine the exact CDB write-back cycle for each instruction $I_k$ ($k \\in \\{1,2,3,4,5\\}$).\n- From these write-back times, determine the final order in which the destination registers are committed to the register file in this Tomasulo system without a Reorder Buffer.\n\nExpress the final commit order as a single row matrix of the destination register identifiers in LaTeX. No rounding is required.",
            "solution": "The problem provides a detailed specification for a Tomasulo-based dynamically scheduled processor and asks for the write-back cycle of five specific instructions and the resulting commit order of their destination registers. The analysis requires a cycle-by-cycle simulation of the instruction flow through the pipeline stages: issue, execution, and write-back.\n\nFirst, we establish the timeline for each instruction, from issue to write-back on the Common Data Bus (CDB). The processor issues one instruction per cycle, starting at cycle $1$.\n\nInstruction $I_1: R_1 \\leftarrow R_2 + R_3$\n- **Issue:** $I_1$ is issued at cycle $1$. It is allocated to the first available Add Reservation Station, $\\text{A1}$.\n- **Operand Availability:** The value of $R_3$ is available at cycle $1$. The value of $R_2$ is specified to become available on the CDB at cycle $6$. Therefore, both operands for $I_1$ are ready at the end of cycle $6$.\n- **Execution:** According to the rules, execution begins in the cycle immediately following the one in which operands are ready and a Functional Unit (FU) is free. At the end of cycle $6$, both add FUs are free. Thus, $I_1$ begins execution at cycle $7$. The addition latency is $L_{\\text{add}} = 2$ cycles. Execution takes place during cycles $7$ and $8$, finishing at the end of cycle $8$.\n- **Write-Back (CDB):** The result is broadcast on the CDB in the cycle immediately following the last execution cycle. This occurs at cycle $8+1 = 9$.\n- **CDB Write Cycle for $I_1$: $9$.**\n\nInstruction $I_2: R_4 \\leftarrow R_5 + R_6$\n- **Issue:** $I_2$ is issued at cycle $2$. It is allocated to Reservation Station $\\text{A2}$.\n- **Operand Availability:** The values of $R_5$ and $R_6$ are available at cycle $1$, so they are ready at issue.\n- **Execution:** Both operands are ready and an add FU is free at the end of cycle $2$. Execution begins at cycle $2+1 = 3$. It uses one of the two add FUs. With a latency of $L_{\\text{add}} = 2$ cycles, execution occurs during cycles $3$ and $4$, finishing at the end of cycle $4$.\n- **Write-Back (CDB):** The result is broadcast on the CDB at cycle $4+1 = 5$.\n- **CDB Write Cycle for $I_2$: $5$.**\n\nInstruction $I_3: R_7 \\leftarrow R_8 + R_9$\n- **Issue:** $I_3$ is issued at cycle $3$. It is allocated to Reservation Station $\\text{A3}$.\n- **Operand Availability:** The values of $R_8$ and $R_9$ are available at cycle $1$, so they are ready at issue.\n- **Execution:** Both operands are ready at the end of cycle $3$. At the start of cycle $4$, one add FU is busy with $I_2$. However, the second add FU is free. Thus, $I_3$ begins execution at cycle $3+1 = 4$. With a latency of $L_{\\text{add}} = 2$ cycles, execution occurs during cycles $4$ and $5$, finishing at the end of cycle $5$.\n- **Write-Back (CDB):** The result is ready to be broadcast at cycle $5+1 = 6$. However, the problem states that the value for $R_2$ becomes available on the CDB at cycle $6$. This creates a CDB contention. The problem statement gives this external event a fixed timing, implying it has priority. The rule for contention states that the loser is \"delayed by exactly one cycle\". Therefore, $I_3$ writes its result to the CDB at cycle $6+1 = 7$.\n- **CDB Write Cycle for $I_3$: $7$.**\n\nInstruction $I_4: R_{10} \\leftarrow R_1 \\times R_4$\n- **Issue:** $I_4$ is issued at cycle $4$. It is allocated to the first Multiply Reservation Station, $\\text{M1}$.\n- **Operand Availability:** $I_4$ depends on the results of $I_1$ (producing $R_1$) and $I_2$ (producing $R_4$). The Reservation Station entry $\\text{M1}$ will wait for the tags $\\text{A1}$ and $\\text{A2}$.\n  - The result of $I_2$ (tag $\\text{A2}$) is broadcast on the CDB at cycle $5$.\n  - The result of $I_1$ (tag $\\text{A1}$) is broadcast on the CDB at cycle $9$.\n  Both operands for $I_4$ are available at the end of cycle $9$.\n- **Execution:** The single multiply FU is available. Execution begins at cycle $9+1 = 10$. The multiplication latency is $L_{\\text{mul}} = 5$ cycles. Execution takes place during cycles $10, 11, 12, 13, 14$, finishing at the end of cycle $14$.\n- **Write-Back (CDB):** The result is broadcast on the CDB at cycle $14+1 = 15$.\n- **CDB Write Cycle for $I_4$: $15$.**\n\nInstruction $I_5: R_{11} \\leftarrow R_{10} \\times R_7$\n- **Issue:** $I_5$ is issued at cycle $5$. It is allocated to the second Multiply Reservation Station, $\\text{M2}$.\n- **Operand Availability:** $I_5$ depends on the results of $I_4$ (producing $R_{10}$) and $I_3$ (producing $R_7$). The Reservation Station entry $\\text{M2}$ will wait for the tags $\\text{M1}$ and $\\text{A3}$.\n  - The result of $I_3$ (tag $\\text{A3}$) is broadcast on the CDB at cycle $7$.\n  - The result of $I_4$ (tag $\\text{M1}$) is broadcast on the CDB at cycle $15$.\n  Both operands for $I_5$ are available at the end of cycle $15$.\n- **Execution:** The multiply FU, used by $I_4$ until the end of cycle $14$, is free at cycle $15$. Execution begins at cycle $15+1 = 16$. With a latency of $L_{\\text{mul}} = 5$ cycles, execution takes place during cycles $16, 17, 18, 19, 20$, finishing at the end of cycle $20$.\n- **Write-Back (CDB):** The result is broadcast on the CDB at cycle $20+1 = 21$.\n- **CDB Write Cycle for $I_5$: $21$.**\n\nSummary of CDB write-back cycles:\n- $I_1$ (to $R_1$): Cycle $9$\n- $I_2$ (to $R_4$): Cycle $5$\n- $I_3$ (to $R_7$): Cycle $7$\n- $I_4$ (to $R_{10}$): Cycle $15$\n- $I_5$ (to $R_{11}$): Cycle $21$\n\nThe problem states there is no Reorder Buffer (ROB) and the register file is updated immediately upon CDB broadcast. This means the commit order of the destination registers is determined by the chronological order of their CDB write-back events.\n\nOrdering the write-back events by cycle number:\n1. Cycle $5$: $I_2$ writes to $R_4$.\n2. Cycle $7$: $I_3$ writes to $R_7$.\n3. Cycle $9$: $I_1$ writes to $R_1$.\n4. Cycle $15$: $I_4$ writes to $R_{10}$.\n5. Cycle $21$: $I_5$ writes to $R_{11}$.\n\nTherefore, the final commit order of the destination registers is $R_4$, then $R_7$, then $R_1$, then $R_{10}$, and finally $R_{11}$. This sequence is represented as a row matrix of the register identifiers.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nR_4 & R_7 & R_1 & R_{10} & R_{11}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While out-of-order execution is powerful, real processors have finite resources. This next exercise () simulates a 'broadcast storm,' where multiple instructions finish simultaneously and compete for the single Common Data Bus. Your task is to apply arbitration rules and track resource availability to determine how the processor resolves this contention and schedules the dependent operations, revealing the critical role of resource management in overall performance.",
            "id": "3685441",
            "problem": "Consider a Tomasulo-style out-of-order datapath with the following properties and policies, all of which are standard and well-tested in computer organization and architecture:\n\n- There is a single Common Data Bus (CDB), meaning at most one result may be broadcast in any given cycle.\n- Reservation Stations (RS) hold issued operations along with tags for operands that are not yet ready. An RS entry whose operands are both ready may be scheduled onto a free Functional Unit (FU).\n- There is exactly one floating-point adder Functional Unit (FU) with an execution latency of $\\ell_{a} = 3$ cycles. When an add operation starts execution at cycle $s$, it occupies the FU during cycles $s, s+1, s+2$, and it becomes eligible to broadcast its result beginning in cycle $s+\\ell_{a} = s+3$.\n- CDB arbitration is by ascending tag order: in any cycle with multiple completed results awaiting broadcast, the CDB selects the lowest tag. The broadcast delivers the value to all waiting RS entries that hold the corresponding tag.\n- Wake-up and start rules: an RS operand that matches the broadcast tag becomes ready in the same cycle as the broadcast; however, an operation may not start execution earlier than the next cycle after both operands are ready. Starting execution requires the appropriate FU to be free in that start cycle.\n- Issue has already occurred for all operations described below; no further issue, memory activity, or commits will interfere with the timeline.\n\nAt the beginning of cycle $10$, a pathological “broadcast storm” is created as follows. Exactly four independent floating-point operations (from any mix of older adders or multipliers not otherwise modeled here) become simultaneously eligible to write back; their tags are $\\tau_{1}, \\tau_{2}, \\tau_{3}, \\tau_{4}$ with strict priority $\\tau_{1} \\lt \\tau_{2} \\lt \\tau_{3} \\lt \\tau_{4}$. All four are contending for the single CDB starting in cycle $10$.\n\nSimultaneously, three pending floating-point add operations are resident in Reservation Stations:\n\n- Operation $A_{1}$ waits for two source operands tagged $\\tau_{1}$ and $\\tau_{2}$.\n- Operation $A_{2}$ waits for two source operands tagged $\\tau_{3}$ and $\\tau_{4}$.\n- Operation $A_{3}$ waits for the results of $A_{1}$ and $A_{2}$ (that is, $A_{3}$ will receive tags corresponding to the writebacks of $A_{1}$ and $A_{2}$ once those complete).\n\nAssume there are no other ready or executing operations besides the four completed-but-not-broadcast producers with tags $\\tau_{1}, \\tau_{2}, \\tau_{3}, \\tau_{4}$ and the three adds $A_{1}, A_{2}, A_{3}$. The floating-point adder FU is idle at the beginning of cycle $10$. All operations obey the above rules for broadcast, wake-up, scheduling, and latency.\n\nUnder these constraints, determine the cycle index $C_{\\text{final}}$ at which $A_{3}$ broadcasts its result on the CDB. Provide your answer as a single integer cycle count. No rounding is required, and no units should be included in the final answer.",
            "solution": "The problem asks for the cycle at which a specific floating-point addition operation, $A_{3}$, broadcasts its result on the Common Data Bus (CDB). The datapath follows Tomasulo's algorithm with specified rules for scheduling, execution, and result broadcast. To determine this, we must simulate the state of the relevant processor components—the Reservation Stations (RS), the floating-point adder Functional Unit (FU), and the CDB—on a cycle-by-cycle basis, starting from the initial state at the beginning of cycle $10$.\n\nThe key parameters are:\n- A single floating-point adder FU.\n- Adder execution latency $\\ell_{a} = 3$ cycles. An operation starting in cycle $s$ occupies the FU for cycles $s$, $s+1$, and $s+2$.\n- The result of an operation starting at cycle $s$ becomes eligible for broadcast on the CDB starting in cycle $s + \\ell_{a} = s+3$.\n- A single CDB, with arbitration based on the lowest tag value.\n- An operation can start execution in the cycle following the one in which both of its operands become ready, provided the necessary FU is free.\n\nWe construct a timeline of events:\n\n**Initial State (Beginning of Cycle $10$)**\n- Four results with tags $\\tau_{1}, \\tau_{2}, \\tau_{3}, \\tau_{4}$ (where $\\tau_{1} < \\tau_{2} < \\tau_{3} < \\tau_{4}$) are ready to be broadcast. They are competing for the CDB.\n- The adder FU is idle.\n- Operation $A_{1}$ is in an RS, waiting for operands with tags $\\tau_{1}$ and $\\tau_{2}$.\n- Operation $A_{2}$ is in an RS, waiting for operands with tags $\\tau_{3}$ and $\\tau_{4}$.\n- Operation $A_{3}$ is in an RS, waiting for the results of $A_{1}$ and $A_{2}$.\n\n**Cycle-by-Cycle Analysis**\n\n*   **Cycle $10$**:\n    *   **CDB**: The four pending results contend for the CDB. By the lowest-tag-first arbitration rule, the result with tag $\\tau_{1}$ is broadcast.\n    *   **Wake-up**: The RS entry for $A_{1}$ receives the value for $\\tau_{1}$. It is now waiting only for $\\tau_{2}$.\n\n*   **Cycle $11$**:\n    *   **CDB**: Three results ($\\tau_{2}, \\tau_{3}, \\tau_{4}$) are pending. The result with tag $\\tau_{2}$ wins arbitration and is broadcast.\n    *   **Wake-up**: The RS entry for $A_{1}$ receives the value for $\\tau_{2}$. At the end of cycle $11$, both operands for $A_{1}$ are ready.\n\n*   **Cycle $12$**:\n    *   **CDB**: Two results ($\\tau_{3}, \\tau_{4}$) are pending. The result with tag $\\tau_{3}$ is broadcast.\n    *   **Wake-up**: The RS entry for $A_{2}$ receives the value for $\\tau_{3}$.\n    *   **Execution Start**: $A_{1}$'s operands became ready in cycle $11$. According to the rules, it can start in the next cycle, cycle $12$. The adder FU is idle. Thus, **$A_{1}$ starts execution**. It will occupy the FU for cycles $12, 13, 14$.\n\n*   **Cycle $13$**:\n    *   **CDB**: The last pending initial result, with tag $\\tau_{4}$, is broadcast.\n    *   **Wake-up**: The RS entry for $A_{2}$ receives the value for $\\tau_{4}$. At the end of cycle $13$, both of $A_{2}$'s operands are ready.\n    *   **Execution**: $A_{1}$ continues execution (cycle $2$ of $3$). The adder FU is busy.\n\n*   **Cycle $14$**:\n    *   **CDB**: The CDB is idle as no new results are ready to be written back.\n    *   **Execution**: $A_{1}$ continues execution (cycle $3$ of $3$). The adder FU is busy. $A_{2}$, whose operands became ready in cycle $13$, is eligible to start in cycle $14$ but must wait because the FU is not free.\n\n*   **Cycle $15$**:\n    *   **Completion & Broadcast**: $A_{1}$ started at cycle $12$ with a latency of $3$ cycles. It completes at the end of cycle $14$ and becomes eligible to broadcast its result starting in cycle $12 + \\ell_{a} = 15$. The CDB is free, so **$A_{1}$ broadcasts its result**.\n    *   **Wake-up**: The RS for $A_{3}$ receives the value from $A_{1}$. It is now waiting for the result of $A_{2}$.\n    *   **Execution Start**: The adder FU is now free. $A_{2}$, which has been ready since the end of cycle $13$, can now start. Thus, **$A_{2}$ starts execution**. It will occupy the FU for cycles $15, 16, 17$.\n\n*   **Cycle $16$**:\n    *   **CDB**: Idle.\n    *   **Execution**: $A_{2}$ continues execution (cycle $2$ of $3$). The FU is busy.\n\n*   **Cycle $17$**:\n    *   **CDB**: Idle.\n    *   **Execution**: $A_{2}$ continues execution (cycle $3$ of $3$). The FU is busy.\n\n*   **Cycle $18$**:\n    *   **Completion & Broadcast**: $A_{2}$ started at cycle $15$. It completes at the end of cycle $17$ and is eligible for broadcast in cycle $15 + \\ell_{a} = 18$. The CDB is free, so **$A_{2}$ broadcasts its result**.\n    *   **Wake-up**: The RS for $A_{3}$ receives the value from $A_{2}$. At the end of cycle $18$, both of $A_{3}$'s operands are ready.\n    *   **FU Status**: The adder FU, having finished with $A_{2}$, is now idle.\n\n*   **Cycle $19$**:\n    *   **CDB**: Idle.\n    *   **Execution Start**: $A_{3}$'s operands became ready in cycle $18$. It can start in cycle $19$. The adder FU is free. Thus, **$A_{3}$ starts execution**. It will occupy the FU for cycles $19, 20, 21$.\n\n*   **Cycle $20$**:\n    *   **CDB**: Idle.\n    *   **Execution**: $A_{3}$ continues execution (cycle $2$ of $3$). The FU is busy.\n\n*   **Cycle $21$**:\n    *   **CDB**: Idle.\n    *   **Execution**: $A_{3}$ continues execution (cycle $3$ of $3$). The FU is busy.\n\n*   **Cycle $22$**:\n    *   **Completion & Broadcast**: $A_{3}$ started at cycle $19$ with a latency of $3$ cycles. It completes at the end of cycle $21$ and becomes eligible for broadcast in cycle $19 + \\ell_{a} = 22$. The CDB is free. Therefore, **$A_{3}$ broadcasts its result on the CDB in cycle $22$**.\n\nThe final cycle index $C_{\\text{final}}$ at which $A_{3}$ broadcasts its result is $22$.",
            "answer": "$$\n\\boxed{22}\n$$"
        },
        {
            "introduction": "Our final practice offers a different challenge: forensic analysis. Instead of simulating a timeline forward, you are given a snapshot of the processor's state at a specific moment and must deduce what has already happened (). This problem will test your integrated understanding of how reservation stations, the register result status table, and instruction dependencies interact, forcing you to use the rules of Tomasulo's algorithm as a set of logical constraints to reverse-engineer the execution history.",
            "id": "3685422",
            "problem": "A processor implements Tomasulo’s algorithm with the following microarchitectural characteristics and timing rules:\n\n- There is a single issue slot per cycle. At most one instruction issues per cycle, in program order.\n- Functional units and reservation stations (RS):\n  - One add/subtract unit with two reservation stations $A_1$ and $A_2$; latency $2$ cycles per operation.\n  - One multiply unit with two reservation stations $M_1$ and $M_2$; latency $4$ cycles per operation.\n  - One unified load/store unit with two load buffers $L_1$, $L_2$ and one store buffer $S_1$; each memory operation occupies the unit for $2$ cycles; the unit services at most one memory operation at a time.\n- There is a single Common Data Bus (CDB). At most one result can write back per cycle on the CDB.\n- Tomasulo pipeline semantics:\n  - After an instruction issues into an available reservation station with its source operand tags or values, its execution may begin no earlier than the next cycle, provided the functional unit is free and all of its source operands are available (i.e., have values rather than tags).\n  - An execution that requires $k$ cycles completes at the end of the $k$-th execution cycle; its result may be placed on the CDB in the following cycle, if the CDB is free. Upon CDB broadcast, all reservation stations and the register result status table capture the value and clear matching tags; the producing reservation station is then freed.\n  - The register result status table records, for each architectural register $F_i$, the tag of the reservation station that is the most recent in-flight writer of $F_i$; a blank (denoted $0$) indicates no in-flight writer. When a value is broadcast on the CDB, the register result status for that register is cleared to $0$ if and only if it matches the broadcasting tag at that moment.\n\nConsider the following instruction sequence (floating-point register names $F_i$ are used; the integer base register for addressing is $R_1$ and is always ready):\n\n- $\\mathrm{I1}$: $\\mathrm{L.D}\\ F2,\\ 0(R1)$\n- $\\mathrm{I2}$: $\\mathrm{L.D}\\ F4,\\ 8(R1)$\n- $\\mathrm{I3}$: $\\mathrm{MUL.D}\\ F6,\\ F2,\\ F4$\n- $\\mathrm{I4}$: $\\mathrm{ADD.D}\\ F6,\\ F6,\\ F2$\n- $\\mathrm{I5}$: $\\mathrm{SUB.D}\\ F2,\\ F4,\\ F2$\n- $\\mathrm{I6}$: $\\mathrm{S.D}\\ F6,\\ 16(R1)$\n- $\\mathrm{I7}$: $\\mathrm{ADD.D}\\ F8,\\ F2,\\ F6$\n\nAssume the processor begins issuing at cycle $1$, the base register $R_1$ is ready throughout, all memory accesses hit and take exactly $2$ cycles in the load/store unit, and no structural hazards occur other than those implied by the stated resources. Ties for CDB usage are resolved by program order (older instruction writes first).\n\nA forensic snapshot is taken at the end of cycle $c = 9$ (that is, immediately after any write-back that occurs in cycle $9$ has completed and all structures have been updated). The snapshot reveals the following state:\n\n- Reservation stations and buffers:\n  - $L_1$: not busy.\n  - $L_2$: not busy.\n  - $M_1$: busy, operation $\\mathrm{MUL.D}$, with $V_j$ and $V_k$ both valid and $Q_j = Q_k = 0$; remaining execution time $= 1$ cycle.\n  - $M_2$: not busy.\n  - $A_1$: busy, operation $\\mathrm{ADD.D}$, with one source operand valid ($Q = 0$) and the other source waiting on tag $M_1$ (i.e., $Q = M_1$).\n  - $A_2$: not busy.\n  - $S_1$: busy, effective address computed and valid; store data waiting on tag $A_1$ (i.e., data $Q = A_1$).\n- Register result status (only nonzero entries shown; all others are $0$):\n  - $F6 \\rightarrow A_1$.\n  - All of $F2$, $F4$, and $F8$ have entry $0$ (no in-flight writer recorded).\n\nUsing only the rules of Tomasulo’s algorithm, the given latencies, and the snapshot above, reconstruct which instructions among $\\mathrm{I1}$ through $\\mathrm{I7}$ have completed write-back by the end of cycle $9$, and explain which data hazards (read-after-write, write-after-write, and write-after-read) must have been present up to this point to be consistent with the snapshot.\n\nLet $N$ be the number of instructions among $\\mathrm{I1}$ through $\\mathrm{I7}$ that have completed write-back by the end of cycle $9$. Compute $N$. Your final answer must be a single integer with no units. No rounding is required.",
            "solution": "The problem statement describes a classic scenario for analyzing the behavior of Tomasulo's algorithm in a dynamically scheduled processor. It provides a complete set of microarchitectural parameters, pipeline rules, a specific instruction sequence, and a state snapshot at a particular cycle. The task is to deduce the execution history, identify which instructions have completed, and explain the data hazards involved.\n\nFirst, we validate the problem.\n\n**Step 1: Extract Givens**\n- **Issue:** Single issue, in order, 1 instruction/cycle.\n- **Functional Units:**\n    - 1 ADD/SUB unit: 2 RS ($A_1, A_2$), 2-cycle latency.\n    - 1 MULTIPLY unit: 2 RS ($M_1, M_2$), 4-cycle latency.\n    - 1 Load/Store unit: 2 Load Buffers ($L_1, L_2$), 1 Store Buffer ($S_1$), 2-cycle memory access. Unit is not pipelined.\n- **CDB:** 1 CDB, 1 write-back/cycle.\n- **Pipeline Rules:** Execute begins cycle after issue if operands/FU ready. A $k$-cycle operation finishes at end of cycle $k$, can WB in cycle $k+1$. Register Result Status (RRS) clears on matching tag WB.\n- **Instruction Sequence (I1-I7):**\n    - I1: `L.D F2, 0(R1)`\n    - I2: `L.D F4, 8(R1)`\n    - I3: `MUL.D F6, F2, F4`\n    - I4: `ADD.D F6, F6, F2`\n    - I5: `SUB.D F2, F4, F2`\n    - I6: `S.D F6, 16(R1)`\n    - I7: `ADD.D F8, F2, F6`\n- **Initial State:** Execution starts at cycle $1$. $R_1$ ready.\n- **Snapshot at end of cycle 9:**\n    - $L_1, L_2, M_2, A_2$ are not busy.\n    - $M_1$: Busy, `MUL.D`, operands valid, 1 cycle exec time remaining.\n    - $A_1$: Busy, `ADD.D`, one operand valid, other waits on tag $M_1$.\n    - $S_1$: Busy, address valid, data waits on tag $A_1$.\n    - RRS: $F6 \\rightarrow A_1$; $F2, F4, F8 \\rightarrow 0$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, using standard concepts from computer organization and architecture. It is well-posed, providing a set of logical rules and a state from which a prior history can be uniquely deduced. The language is objective and precise. The givens are self-contained and appear to be internally consistent. For example, the state of reservation station $A_1$ waiting on $M_1$ is consistent with instructions I4 (`ADD.D F6,...`) and I3 (`MUL.D F6,...`). The problem is a non-trivial but solvable logic puzzle based on established principles.\n\n**Step 3: Verdict and Action**\nThe problem is valid. We will proceed with the solution.\n\n**Reconstruction and Analysis**\n\nThe solution requires reconstructing the execution timeline from cycle $1$ to cycle $9$ that results in the given snapshot. We will analyze the snapshot first to establish key facts, then build the timeline chronologically.\n\n**Analysis of the Snapshot at the End of Cycle 9:**\n1.  **Reservation Station $M_1$**: It holds an instruction with a $4$-cycle latency and has $1$ cycle of execution remaining. This means it has been executing for $4-1=3$ cycles (cycles $7, 8, 9$). Execution must complete at the end of cycle $10$. This instruction must be I3 (`MUL.D F6, F2, F4`). For execution to start in cycle $7$, its source operands (from I1 and I2) must have been available by the end of cycle $6$.\n2.  **Reservation Station $A_1$**: It holds an `ADD.D` and is waiting for a result from $M_1$. This must be I4 (`ADD.D F6, F6, F2`), which has a true dependency (RAW) on I3 for register $F6$. The other operand, $F2$, is listed as valid, meaning the instruction that produced it has already written back.\n3.  **Reservation Station $S_1$**: It holds a store, I6 (`S.D F6, 16(R1)`), and is waiting for data from $A_1$. This reflects the RAW dependency on I4 for register $F6$.\n4.  **Register Result Status (RRS)**:\n    - $F6 \\rightarrow A_1$: This confirms that I4 is the last instruction issued that targets register $F6$. This demonstrates the handling of the Write-After-Write (WAW) hazard between I3 and I4.\n    - $F2 \\rightarrow 0, F4 \\rightarrow 0$: This implies that the last instructions to write to $F2$ (I5) and $F4$ (I2) must have completed their write-back phase. If they were still executing, the RRS would hold their reservation station tags.\n    - $F8 \\rightarrow 0$: The instruction that writes to $F8$ is I7. Since its RRS entry is $0$, I7 has not yet been issued. This is a structural hazard, as both adder reservation stations ($A_1, A_2$) were occupied when it was I7's turn to issue.\n5.  **Load/Store Buffers**: $L_1$ and $L_2$ are not busy. This means I1 and I2 have not only executed but have also completed their write-back phase, freeing their buffers.\n\n**Cycle-by-Cycle Timeline Reconstruction:**\n\nLet IS, EX, and WB denote the Issue, Execute, and Write-Back stages.\n\n- **Cycle 1**: I1 (`L.D F2,...`) issues to $L_1$. RRS: $F2 \\rightarrow L_1$.\n- **Cycle 2**: I1 begins execution (occupies L/S unit for cycles $2,3$). I2 (`L.D F4,...`) issues to $L_2$. RRS: $F2 \\rightarrow L_1, F4 \\rightarrow L_2$.\n- **Cycle 3**: I1 completes execution. I3 (`MUL.D F6,F2,F4`) issues to $M_1$. It requires $F2$ (tag $L_1$) and $F4$ (tag $L_2$). RRS: $F2 \\rightarrow L_1, F4 \\rightarrow L_2, F6 \\rightarrow M_1$.\n- **Cycle 4**: I1 writes back on the CDB (broadcasts tag $L_1$).\n    - $M_1$ and any other station waiting for $L_1$ capture the value for $F2$.\n    - The L/S unit is now free. I2 begins execution (occupies L/S unit for cycles $4,5$).\n    - I4 (`ADD.D F6,F6,F2`) issues to $A_1$. It requires $F6$ (tag $M_1$) and $F2$ (tag $L_1$ at time of issue). RRS for $F6$ is updated: $F6 \\rightarrow A_1$. At end of cycle, $A_1$ captures value of $F2$ from CDB.\n- **Cycle 5**: I2 completes execution. I5 (`SUB.D F2,F4,F2`) issues to $A_2$. It requires $F4$ (tag $L_2$) and $F2$. At issue, $RRS(F2)$ points to no producer since I1 has completed, so I5 gets the value of $F2$ directly from the register file. RRS is updated: $F2 \\rightarrow A_2$.\n- **Cycle 6**: I2 writes back on the CDB (broadcasts tag $L_2$).\n    - $M_1$ captures the value for $F4$. Both of its operands are now ready.\n    - $A_2$ captures the value for $F4$. Both of its operands are now ready.\n    - I6 (`S.D F6,...`) issues to $S_1$. It needs the value of $F6$ (tag $A_1$). Its effective address is computed.\n- **Cycle 7**:\n    - FUs for I3 and I5 are free and their operands are ready.\n    - I3 begins execution in the MULTIPLY unit (4 cycles: $7,8,9,10$).\n    - I5 begins execution in the ADD/SUB unit (2 cycles: $7,8$).\n    - I7 cannot issue because both adder reservation stations ($A_1, A_2$) are occupied.\n- **Cycle 8**: I3 continues execution (cycle 2/4). I5 completes execution.\n- **Cycle 9**: I3 continues execution (cycle 3/4). I5 is ready to write back. Since the CDB is free, I5 writes back.\n    - Tag $A_2$ is broadcast.\n    - $RRS(F2)$, which points to $A_2$, is cleared to $0$.\n    - Reservation station $A_2$ is freed.\n\nThis timeline perfectly matches the state described in the snapshot.\n\n**Instructions Completed Write-Back by End of Cycle 9:**\nBased on the timeline:\n- I1 (`L.D F2, ...`): Completed write-back in cycle $4$.\n- I2 (`L.D F4, ...`): Completed write-back in cycle $6$.\n- I3 (`MUL.D F6, ...`): Still executing.\n- I4 (`ADD.D F6, ...`): Stalled, waiting for I3.\n- I5 (`SUB.D F2, ...`): Completed write-back in cycle $9$.\n- I6 (`S.D F6, ...`): Stalled, waiting for I4.\n- I7 (`ADD.D F8, ...`): Not yet issued.\n\nA store instruction like I6 completes when it has written its data to memory. It is stalled waiting for its source operand, so it has not completed.\nThe instructions that have completed their write-back (or equivalent final action) are I1, I2, and I5.\n\nThe number of instructions that have completed write-back is $N=3$.\n\n**Data Hazard Analysis**\nThe execution trace reveals the presence and management of all three types of data hazards:\n1.  **Read-After-Write (RAW / True Dependency):** These are fundamental and cause stalls if data is not ready.\n    - `(I1, I3)` on `F2` and `(I2, I3)` on `F4`: Resolved by forwarding I1/I2 results to `M_1`.\n    - `(I3, I4)` on `F6`: Causes `A_1` to stall waiting for tag `M_1`, as seen in the snapshot.\n    - `(I4, I6)` on `F6`: Causes `S_1` to stall waiting for tag `A_1`, as seen in the snapshot.\n2.  **Write-After-Write (WAW / Output Dependency):** These are resolved by register renaming using reservation stations.\n    - `(I3, I4)` on `F6`: I3 is assigned `M_1` and I4 is assigned `A_1`. When I4 issues, `RRS(F6)` is updated to `A_1`, ensuring any subsequent instruction (like I6) gets its value from I4, not I3. This prevents the out-of-order completion of I3 and I4 from writing to `F6` in the wrong order.\n    - `(I1, I5)` on `F2`: Resolved similarly. I1 is assigned `L_1` and I5 is assigned `A_2`.\n3.  **Write-After-Read (WAR / Anti-Dependency):** Tomasulo's algorithm inherently resolves these hazards.\n    - `(I4, I5)` on `F2`: I4 reads `F2`, and I5 writes to `F2`. This is not a problem because when I4 issued in cycle $4$, it took a copy of the value/tag for `F2` into its reservation station `A_1`. I5's subsequent write to `F2` in cycle $9$ cannot affect the operand already secured in `A_1`.\n\nThe snapshot provides clear evidence for the management of these hazards, most notably the active stalls from RAW dependencies and the RRS state demonstrating WAW hazard resolution.\n\nThe final requested value is $N$, the number of instructions that have completed write-back.\n$N = 3$ (I1, I2, I5).",
            "answer": "$$\n\\boxed{3}\n$$"
        }
    ]
}