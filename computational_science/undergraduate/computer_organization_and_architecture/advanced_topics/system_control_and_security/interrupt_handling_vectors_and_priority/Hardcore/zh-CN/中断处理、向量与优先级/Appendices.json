{
    "hands_on_practices": [
        {
            "introduction": "中断处理并非没有代价；它会消耗宝贵的处理器周期，从而影响系统性能。理解并量化这个“开销”是优化实时系统和高吞吐量应用响应能力的第一步。本练习  将引导你详细分解中断处理的完整生命周期——包括进入、工作和退出阶段——并计算不同微架构优化策略对中断处理速率的实际影响。通过这个实践，你将对中断延迟的构成以及如何缩短延迟建立起一个具体而量化的认识。",
            "id": "3652721",
            "problem": "一个中央处理器 (CPU) 在饱和稳态下执行单个高优先级的中断服务程序 (ISR)，这意味着来自一个设备的中断一个接一个地到达，服务之间没有空闲周期。CPU 通过具有固定优先级的可编程中断控制器 (PIC) 使用向量中断方案。系统参数和微架构成本如下：\n\n- 时钟频率：$f_{clk} = 250 \\times 10^{6}\\,\\text{Hz}$。\n- 基线中断进入序列成本：\n  - PIC 中断确认握手：$3$ 个周期。\n  - 优先级解析：$3$ 个周期。\n  - 从片外存储器获取向量：$1$ 个总线周期加上 $2$ 个等待状态 $\\Rightarrow$ 共 $3$ 个周期。\n  - 流水线刷新：$5$ 个周期。\n  - 保存 $12$ 个通用寄存器，每个 $2$ 个周期：$24$ 个周期。\n  - 切换到中断状态的模式：$2$ 个周期。\n- 针对热点设备的基线 ISR 主体工作：\n  - 读取状态寄存器：$3$ 个周期。\n  - 读取数据寄存器：$3$ 个周期。\n  - 写入设备确认：$3$ 个周期。\n  - 算术和逻辑运算：$4$ 个周期。\n  - 条件分支：$3$ 个周期。\n- 基线中断退出序列成本：\n  - 向 PIC 写入中断结束 (EOI)：$3$ 个周期。\n  - 恢复 $12$ 个寄存器，每个 $2$ 个周期：$24$ 个周期。\n  - 中断返回指令：$4$ 个周期。\n  - 流水线重新填充：$5$ 个周期。\n\n您最多可以启用以下微架构优化策略中的一种；它们不能组合使用：\n\n- 策略 S1 (向量缓存和优先级屏蔽)：消除 PIC 握手和片外向量获取；通过屏蔽到单一源将优先级解析减少到 $1$ 个周期；在 PIC 中启用自动 EOI，从而无需在退出时显式 EOI。\n- 策略 S2 (快速中断请求 (FIRQ) 与寄存器组)：仅保存/恢复 $4$ 个寄存器，每个 $2$ 个周期（寄存器组覆盖其余部分）；将向量表重定位到片上暂存器，实现 $1$ 周期的向量获取；其他进入和退出活动不变。\n- 策略 S3 (针对来自同一源的背靠背中断的硬件尾链)：当退出时有新的中断挂起时，硬件会绕过完整的退出和下一次完整的进入。从一个 ISR 实例到下一个实例的稳态转换会产生一个固定的 $14$ 个周期的链边界开销（包括 $1$ 个周期的优先级检查，$1$ 个周期重用同一向量，$8$ 个周期的最小流水线调整，以及 $4$ 个周期的内部管理，包括 EOI）。在稳态下，每个事件的成本是 ISR 工作加上此链边界开销。\n\n假设系统持续被同一高优先级设备饱和，因此稳态假设适用。根据 $f_{clk}$ 和周期数，从第一性原理推导出每种策略的稳态事件率（事件/秒），然后确定 S1、S2 和 S3 中可实现的最大稳态事件率。将最终速率以事件/秒表示，并将您最终报告的答案四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它在科学上基于计算机体系结构的原理，题目设定良好，数据充分且一致，并且表达客观。\n\n目标是确定在三种不同的微架构优化策略下，单个高优先级中断源可实现的最大稳态事件率。事件率 $R$ 是时钟频率 $f_{clk}$ 除以每个事件的总时钟周期数 $T_{total}$。\n$$R = \\frac{f_{clk}}{T_{total}}$$\n给定时钟频率为 $f_{clk} = 250 \\times 10^{6}\\,\\text{Hz}$。我们必须为每个策略计算 $T_{total}$。\n\n首先，我们通过对中断处理的三个阶段（进入、ISR 主体工作和退出）的周期数求和来确定基线成本。\n\nISR 主体工作 $T_{work}$ 的总周期数在所有场景中都是恒定的。\n$T_{work} = (\\text{读取状态}) + (\\text{读取数据}) + (\\text{写入确认}) + (\\text{ALU 操作}) + (\\text{分支})$\n$T_{work} = 3 + 3 + 3 + 4 + 3 = 16$ 个周期。\n\n基线进入成本 $T_{entry,base}$ 是：\n$T_{entry,base} = (\\text{PIC 确认}) + (\\text{优先级解析}) + (\\text{向量获取}) + (\\text{流水线刷新}) + (\\text{保存寄存器}) + (\\text{模式切换})$\n$T_{entry,base} = 3 + 3 + 3 + 5 + (12 \\times 2) + 2 = 3 + 3 + 3 + 5 + 24 + 2 = 40$ 个周期。\n\n基线退出成本 $T_{exit,base}$ 是：\n$T_{exit,base} = (\\text{写入 EOI}) + (\\text{恢复寄存器}) + (\\text{reti}) + (\\text{流水线重新填充})$\n$T_{exit,base} = 3 + (12 \\times 2) + 4 + 5 = 3 + 24 + 4 + 5 = 36$ 个周期。\n\n总基线处理时间将是 $T_{total,base} = T_{entry,base} + T_{work} + T_{exit,base} = 40 + 16 + 36 = 92$ 个周期。\n\n现在，我们将分析每个策略，以找出其每个事件的总周期数。\n\n**策略 S1：向量缓存和优先级屏蔽**\n此策略对基线进入和退出序列进行如下修改：\n- PIC 中断确认握手（$3$ 个周期）被消除。\n- 优先级解析从 $3$ 个周期减少到 $1$ 个周期。\n- 片外向量获取（$3$ 个周期）被消除。\n- 由于自动 EOI，退出时显式写入 EOI（$3$ 个周期）被消除。\n\n新的进入成本 $T_{entry,S1}$ 是经过这些修改后的基线进入成本。\n$T_{entry,S1} = T_{entry,base} - 3_{\\text{ack}} - (3-1)_{\\text{prio}} - 3_{\\text{vector}} = 40 - 3 - 2 - 3 = 32$ 个周期。\n或者，从剩余部分计算：\n$T_{entry,S1} = 1_{\\text{prio}} + 5_{\\text{flush}} + 24_{\\text{save}} + 2_{\\text{mode}} = 32$ 个周期。\n\n新的退出成本 $T_{exit,S1}$ 是不包含 EOI 写入的基线退出成本。\n$T_{exit,S1} = T_{exit,base} - 3_{\\text{EOI}} = 36 - 3 = 33$ 个周期。\n或者，从剩余部分计算：\n$T_{exit,S1} = 24_{\\text{restore}} + 4_{\\text{reti}} + 5_{\\text{refill}} = 33$ 个周期。\n\n策略 S1 的总周期数为：\n$T_{total,S1} = T_{entry,S1} + T_{work} + T_{exit,S1} = 32 + 16 + 33 = 81$ 个周期。\n\n策略 S1 的事件率为：\n$R_{S1} = \\frac{f_{clk}}{T_{total,S1}} = \\frac{250 \\times 10^6}{81}$ 事件/秒。\n\n**策略 S2：快速中断请求 (FIRQ) 与寄存器组**\n此策略对基线进行如下修改：\n- 仅保存和恢复 $4$ 个寄存器，每个耗时 $4 \\times 2 = 8$ 个周期，而不是 $12$ 个寄存器耗时 $24$ 个周期。\n- 向量从片上存储器获取，耗时 $1$ 个周期而不是 $3$ 个周期。\n\n新的进入成本 $T_{entry,S2}$ 是经过这些更改后的基线进入成本。寄存器保存成本的减少量是 $24 - (4 \\times 2) = 16$ 个周期。向量获取成本的减少量是 $3 - 1 = 2$ 个周期。\n$T_{entry,S2} = T_{entry,base} - 16_{\\text{save}} - 2_{\\text{vector}} = 40 - 16 - 2 = 22$ 个周期。\n或者，从各部分计算：\n$T_{entry,S2} = 3_{\\text{ack}} + 3_{\\text{prio}} + 1_{\\text{vector}} + 5_{\\text{flush}} + (4 \\times 2)_{\\text{save}} + 2_{\\text{mode}} = 3+3+1+5+8+2 = 22$ 个周期。\n\n新的退出成本 $T_{exit,S2}$ 更新为减少的寄存器恢复成本。减少量是 $24 - (4 \\times 2) = 16$ 个周期。\n$T_{exit,S2} = T_{exit,base} - 16_{\\text{restore}} = 36 - 16 = 20$ 个周期。\n或者，从各部分计算：\n$T_{exit,S2} = 3_{\\text{EOI}} + (4 \\times 2)_{\\text{restore}} + 4_{\\text{reti}} + 5_{\\text{refill}} = 3+8+4+5 = 20$ 个周期。\n\n策略 S2 的总周期数为：\n$T_{total,S2} = T_{entry,S2} + T_{work} + T_{exit,S2} = 22 + 16 + 20 = 58$ 个周期。\n\n策略 S2 的事件率为：\n$R_{S2} = \\frac{f_{clk}}{T_{total,S2}} = \\frac{250 \\times 10^6}{58}$ 事件/秒。\n\n**策略 S3：硬件尾链**\n这个策略有根本性的不同。在饱和稳态下，硬件会绕过来自同一源的中断之间的完整退出和进入序列。每个事件的成本是 ISR 工作加上一个固定的链边界开销。\n$T_{overhead,S3} = 14$ 个周期。\nISR 工作仍为 $T_{work} = 16$ 个周期。\n\n策略 S3 的总周期数为：\n$T_{total,S3} = T_{work} + T_{overhead,S3} = 16 + 14 = 30$ 个周期。\n\n策略 S3 的事件率为：\n$R_{S3} = \\frac{f_{clk}}{T_{total,S3}} = \\frac{250 \\times 10^6}{30}$ 事件/秒。\n\n**事件率比较**\n现在我们比较这三个速率以找出最大值。\n$R_{S1} = \\frac{250 \\times 10^6}{81} \\approx 3.086 \\times 10^6$ 事件/秒。\n$R_{S2} = \\frac{250 \\times 10^6}{58} \\approx 4.310 \\times 10^6$ 事件/秒。\n$R_{S3} = \\frac{250 \\times 10^6}{30} = \\frac{25}{3} \\times 10^6 \\approx 8.333 \\times 10^6$ 事件/秒。\n\n通过比较分母（$30  58  81$），很明显 $R_{S3}$ 是最大值。\n$R_{\\max} = R_{S3} = \\frac{250 \\times 10^6}{30} = 8333333.\\overline{3}$ 事件/秒。\n\n题目要求最终答案四舍五入到四位有效数字。\n$R_{\\max} \\approx 8.333 \\times 10^6$ 事件/秒。",
            "answer": "$$\\boxed{8.333 \\times 10^6}$$"
        },
        {
            "introduction": "在支持抢占式中断的系统中，高优先级的中断可以打断正在执行的低优先级中断服务程序，形成中断嵌套。每一次中断上下文的切换都需要在栈上保存处理器的核心状态，这意味着每一次嵌套都会消耗额外的内存。本练习  将让你从时间维度的考量转向空间维度，通过一个具体的案例来计算在最坏情况下，为了防止栈溢出所需分配的最小栈空间。这项技能对于编写健壮的嵌入式系统至关重要，它将中断理论与严谨的内存管理实践联系在一起。",
            "id": "3652658",
            "problem": "一个微控制器，表示为架构 $\\mathcal{A}$，在具有 $32$ 位字长的满递减堆栈上执行单个线程。该系统采用向量中断控制器，具有严格的抢占式优先级：任何挂起的中断，只要其优先级数值低于当前运行上下文的优先级，就会被允许立即抢占。优先级 $0$ 是最高优先级；在此场景中没有启用非可屏蔽中断。中断向量表将四个可屏蔽中断分配给对应以下优先级的向量条目：$\\mathrm{I_A}$ 优先级为 $7$，$\\mathrm{I_B}$ 优先级为 $5$，$\\mathrm{I_C}$ 优先级为 $3$，以及 $\\mathrm{I_D}$ 优先级为 $1$。假设最坏情况下的到达时间，即每个更高优先级的中断都可以在当前执行的中断完成前到达并抢占它，并且控制器和编译器除了下面描述的架构延迟外，不引入任何人为延迟。\n\n在每次异常进入（包括中断进入）时，$\\mathcal{A}$ 架构的硬件会自动将一个固定的核心上下文压栈，该上下文包含通用寄存器 $r0$ 到 $r3$、寄存器 $r12$、链接寄存器 $lr$、程序计数器 $pc$ 以及程序状态寄存器 $\\mathrm{psr}$。这些寄存器每个都占用一个字，因此核心上下文压栈的字数是固定的。该微控制器包含一个浮点单元。操作系统配置处理器，在每次中断进入时总是保存浮点上下文。当保存浮点上下文时，硬件会额外压入寄存器 $f0$ 到 $f15$ 和浮点状态与控制寄存器 $\\mathrm{fpscr}$，并插入一个填充字以在进入时保持 $8$ 字节的堆栈对齐。假设中断程序的编写方式避免了在硬件压栈的上下文之外使用额外的堆栈空间。假设所描述的填充已满足堆栈对齐要求，因此不需要进一步的填充。\n\n被中断的线程在第一个中断发生时正在执行一个由三个函数组成的调用链 $T \\rightarrow P \\rightarrow C$。该应用程序使用标准调用约定，其中每个函数的堆栈帧由其本地存储、保存的被调用者保存寄存器以及链接寄存器 $lr$ 组成。三个活动帧的构成如下：\n- 在 $T$ 中：本地存储 $124$ 字节；保存的被调用者保存寄存器 $r4$ 到 $r11$（八个寄存器）；以及 $lr$。\n- 在 $P$ 中：本地存储 $44$ 字节；保存的被调用者保存寄存器 $r4$ 到 $r9$（六个寄存器）；以及 $lr$。\n- 在 $C$ 中：本地存储 $36$ 字节；保存的被调用者保存寄存器 $r4$ 到 $r7$（四个寄存器）；以及 $lr$。\n\n假设每个寄存器为一个字，每个字为 $4$ 字节。由于对齐约束，每个函数的帧大小向上舍入到 $8$ 字节的倍数；上面给出的本地存储大小是未舍入的量。所有三个函数都已执行完其序言（prologue），因此在第一个中断发生时，它们的完整帧都存在于堆栈上。\n\n仅使用抢占式优先级中断处理和上下文压栈的基本原理，确定在最坏情况下所需的最小堆栈分配 $S$（以字节为单位），以避免溢出。最坏情况是指四个中断 $\\mathrm{I_A}$、$\\mathrm{I_B}$、$\\mathrm{I_C}$ 和 $\\mathrm{I_D}$ 嵌套到最大深度，并且每个中断处理程序至少执行一条浮点指令，从而在进入时触发浮点上下文保存路径。忽略尾链（tail-chaining）对堆栈帧同时驻留的任何影响。\n\n将您的最终答案表示为单个整数字节数。无需四舍五入。不要在最终的方框答案中包含单位，但在您的推理过程中请以字节为单位表示答案。",
            "solution": "问题要求计算最小堆栈分配 $S$（以字节为单位），以在嵌套中断的最坏情况下防止堆栈溢出。总堆栈使用量是被中断的应用程序线程消耗的堆栈空间与最大可能数量的嵌套中断服务例程消耗的空间之和。\n\n字长指定为 $32$ 位，即 $4$ 字节。\n\n首先，我们计算应用程序线程使用的堆栈空间。该线程正在执行一个调用链 $T \\rightarrow P \\rightarrow C$，并且所有三个函数（$T$、$P$ 和 $C$）的堆栈帧都存在于堆栈上。必须计算每个函数帧的大小，包括本地存储、保存的被调用者保存寄存器和保存的链接寄存器（$lr$），然后为对齐而向上舍入到 $8$ 字节的倍数。\n\n单个寄存器的大小为一个字，即 $4$ 字节。\n\n函数 $C$ 的帧：\n- 本地存储：$36$ 字节。\n- 保存的被调用者保存寄存器（$r4$ 到 $r7$）：$4$ 个寄存器 $\\times 4$ 字节/寄存器 = $16$ 字节。\n- 保存的链接寄存器（$lr$）：$1$ 个寄存器 $\\times 4$ 字节/寄存器 = $4$ 字节。\n- 帧 $C$ 的未对齐总大小：$S_{C, \\text{unaligned}} = 36 + 16 + 4 = 56$ 字节。\n由于 $56$ 是 $8$ 的倍数，对齐后的大小为 $S_C = 56$ 字节。\n\n函数 $P$ 的帧：\n- 本地存储：$44$ 字节。\n- 保存的被调用者保存寄存器（$r4$ 到 $r9$）：$6$ 个寄存器 $\\times 4$ 字节/寄存器 = $24$ 字节。\n- 保存的链接寄存器（$lr$）：$1$ 个寄存器 $\\times 4$ 字节/寄存器 = $4$ 字节。\n- 帧 $P$ 的未对齐总大小：$S_{P, \\text{unaligned}} = 44 + 24 + 4 = 72$ 字节。\n由于 $72$ 是 $8$ 的倍数，对齐后的大小为 $S_P = 72$ 字节。\n\n函数 $T$ 的帧：\n- 本地存储：$124$ 字节。\n- 保存的被调用者保存寄存器（$r4$ 到 $r11$）：$8$ 个寄存器 $\\times 4$ 字节/寄存器 = $32$ 字节。\n- 保存的链接寄存器（$lr$）：$1$ 个寄存器 $\\times 4$ 字节/寄存器 = $4$ 字节。\n- 帧 $T$ 的未对齐总大小：$S_{T, \\text{unaligned}} = 124 + 32 + 4 = 160$ 字节。\n由于 $160$ 是 $8$ 的倍数，对齐后的大小为 $S_T = 160$ 字节。\n\n应用程序线程的总堆栈使用量 $S_{\\text{thread}}$ 是这三个帧的大小之和：\n$$S_{\\text{thread}} = S_C + S_P + S_T = 56 + 72 + 160 = 288 \\text{ 字节}$$\n\n接下来，我们计算单个中断使用的堆栈空间。问题指明，在每次中断进入时，核心上下文和浮点上下文都会被保存。\n\n核心上下文由寄存器 $r0$ 到 $r3$（$4$ 个寄存器）、$r12$（$1$ 个寄存器）、$lr$（$1$ 个寄存器）、$pc$（$1$ 个寄存器）和 $\\mathrm{psr}$（$1$ 个寄存器）组成。总共是 $4+1+1+1+1=8$ 个寄存器。\n核心上下文堆栈帧的大小为：\n$$S_{\\text{core}} = 8 \\text{ 寄存器} \\times 4 \\text{ 字节/寄存器} = 32 \\text{ 字节}$$\n\n浮点上下文保存会压入寄存器 $f0$ 到 $f15$（$16$ 个寄存器）、$\\mathrm{fpscr}$（$1$ 个寄存器）和一个填充字（$1$ 个字），以保持 $8$ 字节对齐。这总共是 $16+1+1 = 18$ 个字。\n浮点上下文堆栈帧的大小为：\n$$S_{\\text{fp}} = 18 \\text{ 字} \\times 4 \\text{ 字节/字} = 72 \\text{ 字节}$$\n\n单个中断消耗的总堆栈空间 $S_{\\text{interrupt}}$ 是核心上下文和浮点上下文大小的总和：\n$$S_{\\text{interrupt}} = S_{\\text{core}} + S_{\\text{fp}} = 32 + 72 = 104 \\text{ 字节}$$\n\n最坏情况涉及所有四个指定中断的最大嵌套。这些中断是 $\\mathrm{I_A}$（优先级 $7$）、$\\mathrm{I_B}$（优先级 $5$）、$\\mathrm{I_C}$（优先级 $3$）和 $\\mathrm{I_D}$（优先级 $1$）。由于较小的优先级数值表示较高的搶占优先级，因此当最低优先级的中断被下一个较高优先级的中断抢占时，会发生最深的嵌套，以此类推。顺序是：线程执行被 $\\mathrm{I_A}$ 抢占，$\\mathrm{I_A}$ 被 $\\mathrm{I_B}$ 抢占，$\\mathrm{I_B}$ 被 $\\mathrm{I_C}$ 抢占，最后 $\\mathrm{I_C}$ 被 $\\mathrm{I_D}$ 抢占。这导致 $4$ 个中断处理上下文被压入堆栈。\n\n所有嵌套中断的总堆栈使用量为：\n$$S_{\\text{interrupts\\_total}} = 4 \\times S_{\\text{interrupt}} = 4 \\times 104 = 416 \\text{ 字节}$$\n\n最后，为避免溢出所需的总最小堆栈分配 $S$ 是线程的堆栈使用量与总中断堆栈使用量之和：\n$$S = S_{\\text{thread}} + S_{\\text{interrupts\\_total}} = 288 + 416 = 704 \\text{ 字节}$$",
            "answer": "$$\\boxed{704}$$"
        },
        {
            "introduction": "从性能和资源分析转向逻辑正确性的设计，是掌握中断处理的最后一步。电平触发中断由于其“持续状态”的特性，在设计中断服务程序(ISR)时需要特别小心，以避免因未能正确清除中断源而导致的无限循环重入（即“活锁”）。本练习  提出了一个包含共享中断线、电平触发和虚假中断等现实世界复杂性的思想实验。它将挑战你设计一个逻辑上无懈可擊的中断服务程序，迫使你思考确保系统穩定运行所需操作的精确顺序。",
            "id": "3652686",
            "problem": "一个连接到共享电平触发中断线的中央处理器 (CPU) 由一个可编程中断控制器 (PIC) 服务。该 PIC 对多个中断线执行固定优先级解析，并在任何设备置位该线路时向 CPU 传递一个中断向量 $v$。一组设备共享此线路，并暴露一个内存映射的状态寄存器 $SR$，其位域 $\\{b_0, b_1, \\ldots, b_{m-1}\\}$ 指示挂起的中断源；读取 $SR$ 是原子且无副作用的，而每个设备的中断原因在服务完成后通过写入该设备的原因清除寄存器来清除。仅当一个有效请求被接受时，PIC 才会为该线路设置一个服务中锁存器 $IS$；在罕见的由噪声引发的情况下，CPU 可能会在 $SR=0$ 时收到一个向量 $v$，而 PIC 并未为该事件设置 $IS$。中断结束 (EOI) 命令会为有效中断清除 $IS$。CPU 可以在中断服务程序 (ISR) 执行期间提升其中断优先级 (IPL)，以屏蔽相同或更低优先级的后续中断，其中 ISR 代表中断服务程序 (Interrupt Service Routine)。\n\n您必须选择一种 ISR 执行顺序，该顺序既能正确处理真实中断，又能安全地处理由电气噪声引起的伪中断，且不会进入活锁状态。系统级要求如下：\n\n- 电平触发语义下的正确性：如果一个设备是真正的中断源，ISR 必须通过读取 $SR$ 来识别挂起的中断源，根据软件优先级函数 $\\pi : \\{0,1,\\ldots,m-1\\} \\to \\mathbb{N}$ 服务最高优先级的挂起源，并清除其原因，从而使共享线取消置位。只有在服务完一个有效的源之后，ISR 才应向 PIC 发出 EOI。\n- 伪中断鲁棒性：如果在进入时 $SR = 0$，ISR 必须检测到没有挂起的中断源，增加计数器 $C_{\\text{spurious}}$，然后返回且不产生活锁。在这种情况下，不應执行忙等待循环或重复的确认操作。\n- 优先级清洁性：在服务期间，ISR 应防止对同一向量的重入，并避免在当前中断源被平息之前，允许较低优先级的中断抢占。\n\n哪个选项最能满足这些要求？\n\nA. 进入时，提升 IPL 以屏蔽同一向量。读取一次 $SR$。如果 $SR = 0$，则增加 $C_{\\text{spurious}}$ 并返回，不发出 EOI。如果 $SR \\neq 0$，则选择最高优先级的挂起位索引 $i^\\ast = \\arg\\min_{i \\in \\{0,\\ldots,m-1\\},\\, b_i=1} \\pi(i)$，服务设备 $i^\\ast$，清除其原因，然后向 PIC 发出 EOI，降低 IPL，并返回。\n\nB. 进入时，提升 IPL。在一个循环中持续轮询 $SR$ 直到 $SR \\neq 0$。当一个位被置位时，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，服务并清除，然后发出 EOI 并返回。如果 $SR$ 保持为 $0$，则无限期地继续轮询。\n\nC. 进入时，立即向 PIC 发出 EOI 以释放较低优先级的中断，然后读取 $SR$。如果 $SR = 0$，增加 $C_{\\text{spurious}}$ 并返回。如果 $SR \\neq 0$，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，服务并清除，降低 IPL，然后返回。\n\nD. 进入时，如果 $SR = 0$，则在 PIC 中屏蔽共享中断线，忙等待一段时间 $T$（其中 $T > 0$）以查看 $SR$ 中是否有任何位被置位，如果没有，则增加 $C_{\\text{spurious}}$，取消屏蔽该线路，并返回。如果 $SR \\neq 0$，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，服务并清除，发出 EOI，然后返回。",
            "solution": "用户提供了一个关于中断服务程序 (ISR) 设计的详细问题，该 ISR 用于一个具有共享电平触发中断线、可编程中断控制器 (PIC) 且可能存在伪中断的系统。任务是选择 ISR 内正确的操作顺序，以满足三个特定的系统级要求：对电平触发源的正确性、对伪中断的鲁棒性以及正确的优先级管理。\n\n首先，我们来验证问题陈述。\n\n### 步骤1：提取已知条件\n-   **硬件设置**：一个中央处理器 (CPU) 连接到一条共享的电平触发中断线。一个 PIC 管理这条线上来自多个设备的中断，执行固定优先级解析，并向 CPU 传递一个中断向量 $v$。\n-   **设备接口**：共享线上的设备使用一个内存映射的状态寄存器 $SR$，其位域 $\\{b_0, b_1, \\ldots, b_{m-1}\\}$ 指示挂起的中断源。读取 $SR$ 是原子操作且无副作用。设备中断的原因通过写入一个独立的设备特定寄存器来清除。\n-   **PIC 行为**：当 CPU 接受一个有效请求时，PIC 会为该中断线设置一个服务中锁存器 $IS$。一个中断结束 (EOI) 命令会清除此锁存器。\n-   **伪中断**：由于噪声，可能会发生伪中断。在这些情况下，CPU 收到向量 $v$，但设备状态寄存器为零 ($SR=0$)，并且 PIC 的服务中锁存器 $IS$ 没有被设置。\n-   **CPU 能力**：CPU 可以提升其中断优先级 (IPL) 以屏蔽相同或更低优先级的中断。\n-   **软件优先级**：一个函数 $\\pi : \\{0,1,\\ldots,m-1\\} \\to \\mathbb{N}$ 定义了中断源的软件管理优先级，其中 $\\pi(i)$ 的值越小，优先级越高。\n-   **要求1（正确性）**：对于真实中断，ISR 必须读取 $SR$，根据 $\\pi$ 识别并服务最高优先级的中断源，清除设备的中斷原因，然后向 PIC 发出 EOI。\n-   **要求2（伪中断鲁棒性）**：如果进入时 $SR=0$，ISR 必须增加计数器 $C_{\\text{spurious}}$ 并返回，且不会造成活锁。不允许忙等待。\n-   **要求3（优先级清洁性）**：ISR 必须防止对同一中断向量的重入，以及在服务某个源时被较低优先级的中断抢占。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述具有科学依据、提法恰当且客观。它描述了计算机体系结构和嵌入式系统设计中的一个标准、现实的场景。电平触发中断、共享中断线、PIC（如 Intel $8259$ 或 ARM GIC）、服务中寄存器、EOI、伪中断和 CPU 优先级等概念都是基础且成熟的。这些要求清晰、一致，且不包含矛盾。该问题是对中断处理逻辑理解的一次有效且有深度的测试。\n\n### 步骤3：结论与行动\n问题陈述是有效的。我将继续推导解决方案并评估各个选项。\n\n### 正确 ISR 序列的推导\n\n基于基本原理和所述要求，ISR 必须按特定顺序执行其操作，以确保正确性和稳定性。\n\n1.  **优先级管理（要求3）**：进入 ISR 后，第一个动作必须是提升 CPU 的中断优先级 (IPL)。这可以防止当前的 ISR 被另一个相同或更低优先级的中断抢占。这对于防止竞争条件和确保优先级清洁性至关重要。它还能防止对同一中断向量的重入，因为该向量本身会被提升后的 IPL 屏蔽。\n\n2.  **中断源识别**：ISR 必须确定中断是合法的还是伪造的。对此，共享设备状态寄存器 $SR$ 是最终的真相来源。ISR 必须读取 $SR$。\n\n3.  **处理伪中断（要求2）**：如果读取的 $SR$ 值为 $0$，则该中断是伪中断。根据问题描述，对于此类事件，PIC 没有设置其服务中锁存器 $IS$。\n    -   因此，不应发送 EOI。发送 EOI 的目的是清除当前中断级别的 $IS$ 锁存器。如果没有设置锁存器，发送 EOI 是不正确的，并可能干扰 PIC 的状态机（例如，过早地结束另一个正在服务的合法中断）。\n    -   ISR 应增加计数器 $C_{\\text{spurious}}$。\n    -   然后 ISR 必须从中断中返回。明确禁止忙等待或轮询。\n\n4.  **处理有效中断（要求1）**：如果读取的 $SR$ 值非零 ($SR \\neq 0$)，则至少有一个设备在请求服务。\n    -   **服务**：ISR 必须通过找到对应于置位比特 $b_{i^\\ast}=1$ 且使优先级函数 $\\pi(i^\\ast)$最小化的索引 $i^\\ast$来确定最高优先级的挂起源。然后必须执行设备 $i^\\ast$ 的服务例程。\n    -   **清除中断源**：服务后，ISR 必须清除*设备端*的中断条件，通常是通过写入设备特定的寄存器。这个动作会导致设备取消其在电平触发线路上的信号置位。这是一个关键步骤；对于电平触发中断，若不这样做会导致中断持续存在。\n    -   **发出中断结束信号 (EOI)**：只有在设备已服务且其中断原因已清除后，ISR 才应向 PIC 发出 EOI 命令。这通知 PIC 当前中断的服务已完成，从而使 PIC 清除其 $IS$ 锁存器。对于电平触发系统，如果其他较低优先级的设备仍然保持线路高电平，PIC 现在可以在其优先级逻辑允许的情况下产生新的中断。在清除源*之前*发出 EOI 是一个经典错误，会导致同一中断立即重新触发，从而导致活锁。\n    -   **返回**：最后，ISR 应该返回。中断返回指令通常会恢复 CPU 的原始 IPL。\n\n这个推导出的序列为评估给定选项提供了一个坚实的框架。\n\n### 逐项选项分析\n\n**A. 进入时，提升 IPL 以屏蔽同一向量。读取一次 $SR$。如果 $SR = 0$，则增加 $C_{\\text{spurious}}$ 并返回，不发出 EOI。如果 $SR \\neq 0$，则选择最高优先级的挂起位索引 $i^\\ast = \\arg\\min_{i \\in \\{0,\\ldots,m-1\\},\\, b_i=1} \\pi(i)$，服务设备 $i^\\ast$，清除其原因，然后向 PIC 发出 EOI，降低 IPL，并返回。**\n\n-   **提升 IPL**：正确实现了要求3。\n-   **读取 $SR$**：正确识别了状态。\n-   **伪中断情况 ($SR=0$)**：正确地增加了 $C_{\\text{spurious}}$ 并返回而不发出 EOI，满足了要求2。\n-   **有效中断情况 ($SR \\neq 0$)**：正确识别了最高优先级的源，为其服务，清除原因，*然后*发出 EOI。这是电平触发中断的正确顺序，满足了要求1。返回前降低 IPL 也是正确的。\n-   **结论**：**正确**。该选项精确地遵循了推导出的理想序列。\n\n**B. 进入时，提升 IPL。在一个循环中持续轮询 $SR$ 直到 $SR \\neq 0$。当一个位被置位时，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，服务并清除，然后发出 EOI 并返回。如果 $SR$ 保持为 $0$，则无限期地继续轮询。**\n\n-   该选项通过进入无限轮询循环来处理伪中断情况 ($SR=0$)。这构成了活锁（或者更准确地说是 CPU 的死锁），并明确违反了要求2（“返回且不产生活锁。不应执行忙等待循环...”）。\n-   **结论**：**不正确**。\n\n**C. 进入时，立即向 PIC 发出 EOI 以释放较低优先级的中断，然后读取 $SR$。如果 $SR = 0$，增加 $C_{\\text{spurious}}$ 并返回。如果 $SR \\neq 0$，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，服务并清除，降低 IPL，然后返回。**\n\n-   在 ISR 开始时，清除设备端的中断源之前就发出 EOI，对于电平触发中断是一个致命缺陷。中断线保持置位状态，因此 PIC 在收到 EOI 后会立即重新发出相同的中断信号，导致 ISR 重入自身，从而引发堆栈溢出和系统锁死。这违反了要求1，该要求规定 EOI 应在*服务之后*发出。此外，它忽略了提升 IPL，违反了要求3。\n-   **结论**：**不正确**。\n\n**D. 进入时，如果 $SR = 0$，则在 PIC 中屏蔽共享中断线，忙等待一段时间 $T$（其中 $T > 0$）以查看 $SR$ 中是否有任何位被置位，如果没有，则增加 $C_{\\text{spurious}}$，取消屏蔽该线路，并返回。如果 $SR \\neq 0$，通过 $\\pi(\\cdot)$ 选择 $i^\\ast$，服务并清除，发出 EOI，然后返回。**\n\n-   对于伪中断情况 ($SR=0$)，此选项引入了持续时间为 $T$ 的忙等待。这违反了禁止忙等待的要求2。\n-   对于有效中断情况 ($SR \\neq 0$)，此选项未能在进入时提升 CPU 的 IPL。这违反了要求3，因为它未能防止较低优先级中断的重入和抢占。\n-   **结论**：**不正确**。\n\n结论：选项 A 是唯一一个正确排序所有必需操作，以满足指定的关于正确性、鲁棒性和优先级管理的系统级要求的选项。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}