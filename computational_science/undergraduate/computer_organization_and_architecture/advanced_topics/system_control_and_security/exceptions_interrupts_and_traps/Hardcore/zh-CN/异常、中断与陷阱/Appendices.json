{
    "hands_on_practices": [
        {
            "introduction": "中断的一个最直接的物理后果是栈空间的使用。每次中断抢占当前执行时，都必须保存上下文，而栈是实现这一目标的主要场所。这个练习将帮助你建立一个具体的、定量的模型，来理解嵌套中断场景下的资源消耗，并计算系统在耗尽栈空间之前可以安全处理的最大中断嵌套深度 。",
            "id": "3640485",
            "problem": "一个单核嵌入式处理器使用一个统一的向下增长的栈为线程模式和处理程序模式实现向量化的、可抢占的中断。中断服务程序（ISR）是为响应中断而执行的例程。每次中断进入时，硬件会自动在当前栈上保存一个上下文帧；编译器生成的ISR前序代码随后在同一个栈上保存额外的软件状态。系统没有实现尾链（tail-chaining）或懒加载（lazy stacking）；每次中断进入都会压入一个完整的硬件帧，并且每个ISR都使用相同的最坏情况前序代码。\n\n假设以下具体的、架构级别的事实，所有这些事实在不同中断和嵌套深度下都是不变的：\n\n- 栈的总大小为 $S=3072$ 字节。\n- 在第一个中断到达的瞬间，线程已经使用了 $B=1024$ 字节的栈空间。\n- 必须保留 $G=256$ 字节的保护边距（guard margin）不被使用，以应对异步活动并提供安全余量，因此超过 $S-G$ 字节的使用量是不安全的。\n- 每次中断进入时，硬件会压入一个固定大小的帧，包括返回程序计数器（$8$ 字节）、处理器状态（$8$ 字节）和中断标识符（$8$ 字节），随后进行填充以在进入ISR时保持栈指针的 $16$ 字节对齐。因此，每个硬件帧的大小为 $32$ 字节。\n- 每个ISR的前序代码保守地保存 $6$ 个被调用者保存（callee-saved）的寄存器，每个寄存器 $8$ 字节，并分配 $16$ 字节的局部溢出区域，同时保持 $16$ 字节对齐。因此，每个ISR的软件栈使用量为 $64$ 字节。\n- 系统有 $P=24$ 个不同的、严格排序的中断优先级，并且抢占只发生在较高优先级中断抢占较低优先级ISR的情况下。每个优先级最多只能有一个ISR处于活动状态。\n\n考虑一个在时间轴 $t$ 上的最坏情况嵌套抢占场景：一个最低优先级的ISR在时间 $t_0$ 开始执行，进入后立即在时间 $t_1$ 被一个更高优先级的中断抢占，后者又在时间 $t_2$ 被抢占，依此类推，构成一个嵌套深度为 $d$ 的时间图，其中时间严格递增 $t_0 < t_1 < \\dots < t_{d-1}$，优先级也严格递增。在每次抢占时，栈的增长量为新ISR的硬件帧和ISR软件前序代码之和，并且在达到最大嵌套深度之前，没有ISR会返回。\n\n从中断的定义、每个嵌套中断向栈中添加其独立上下文的不变性，以及总栈使用量必须严格低于不安全阈值的要求出发，根据第一性原理推导出一个关于最大安全嵌套深度 $d_{\\max}$ 的闭式表达式，该表达式是 $S$、$B$、$G$ 和每级栈增长量的函数。然后，使用上面给出的参数，计算 $d_{\\max}$ 的值。将最大安全嵌套深度报告为一个精确的整数（无单位）。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 栈总大小：$S=3072$ 字节。\n- 初始线程栈使用量：$B=1024$ 字节。\n- 保护边距：$G=256$ 字节。\n- 每次中断的硬件帧大小：$H=32$ 字节。这包括一个 $8$ 字节的返回程序计数器、一个 $8$ 字节的处理器状态、一个 $8$ 字节的中断标识符，以及用于 $16$ 字节对齐的填充。\n- 每个ISR的软件栈使用量：$W_{sw}=64$ 字节。这包括 $6$ 个寄存器，每个 $8$ 字节（共 $48$ 字节），以及 $16$ 字节的局部溢出区，同时保持 $16$ 字节对齐。\n- 不同的、严格排序的中断优先级数量：$P=24$。\n- 进入不安全状态的条件是栈使用量超过 $S-G$。\n- 场景是最坏情况的嵌套抢占，其中每次中断都会向栈中添加一个完整的上下文帧。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学性：** 问题描述了一个嵌入式系统中抢占式嵌套中断的标准栈管理模型。硬件/软件上下文保存、栈保护和基于优先级的抢占等概念是计算机体系结构和实时操作系统的基本原理。所提供的值是现实的。该问题具有科学合理性。\n- **良构性：** 问题定义清晰，提供了所有必要的参数（$S$、$B$、$G$、每级栈成本）。它要求一个具体的、可计算的量，即最大安全嵌套深度 $d_{\\max}$。约束条件明确无歧义。存在一个唯一的、稳定的解。\n- **客观性：** 问题以精确的技术语言陈述，不含主观性或个人观点。\n\n**步骤 3：结论与行动**\n该问题被认为是**有效的**，因为它具有科学性、良构性和客观性。将推导解答。\n\n### 解答推导\n\n支配此问题的基本原理是，总栈使用量不得超过最大安全限制。栈是向下增长的，但其大小（使用量）是一个从栈基址开始测量的正值。\n\n设 $S$ 为栈的总大小，$B$ 为任何中断发生前线程的初始栈使用量，$G$ 为必须保持未使用的所需保护边距。因此，最大允许栈使用量 $U_{max}$ 是总栈大小减去保护边距。\n$$U_{max} = S - G$$\n\n在所描述的最坏情况下，会发生一系列 $d$ 次嵌套中断。每个中断级别都会向栈中添加固定数量的数据。这个每级栈增长量，我们称之为 $W_{level}$，是硬件压入的上下文帧 $H$ 和由ISR前序代码保存的软件管理上下文 $W_{sw}$ 的总和。\n$$W_{level} = H + W_{sw}$$\n\n设 $d$ 为中断的嵌套深度。由于 $d$ 次嵌套中断中的每一次都在栈上消耗 $W_{level}$ 字节，因此由中断贡献的总栈使用量为 $d \\cdot W_{level}$。\n\n对于嵌套深度为 $d$ 的情况，总栈使用量 $U(d)$ 是初始线程使用量 $B$ 和来自 $d$ 次嵌套中断的使用量之和。\n$$U(d) = B + d \\cdot W_{level}$$\n\n为使系统保持在安全状态，总栈使用量 $U(d)$ 必须小于或等于最大允许使用量 $U_{max}$。\n$$U(d) \\leq U_{max}$$\n代入 $U(d)$ 和 $U_{max}$ 的表达式：\n$$B + d \\cdot W_{level} \\leq S - G$$\n\n为了找到最大安全嵌套深度 $d_{\\max}$，我们必须解此不等式，求出 $d$ 可能的最大整数值。\n$$d \\cdot W_{level} \\leq S - B - G$$\n$$d \\leq \\frac{S - B - G}{W_{level}}$$\n\n由于嵌套深度 $d$ 必须是整数，因此它可以安全取得的最大值 $d_{\\max}$ 是右侧表达式的向下取整（floor）值。\n$$d_{\\max} = \\left\\lfloor \\frac{S - B - G}{W_{level}} \\right\\rfloor$$\n这个表达式给出了受栈空间限制的最大深度。问题还指出有 $P=24$ 个不同的优先级，这对嵌套深度施加了一个绝对的物理限制。因此，真正的最大深度是由栈约束推导出的值与优先级数量两者中的较小者。然而，问题明确要求的是最大*安全*嵌套深度，这指的是资源限制。我们将根据公式计算该值，并验证其不超过 $P$。\n\n现在，我们将给定的数值代入推导出的表达式中。\n- $S = 3072$ 字节\n- $B = 1024$ 字节\n- $G = 256$ 字节\n- $H = 32$ 字节\n- $W_{sw} = 64$ 字节\n- $P = 24$\n\n首先，计算每级栈增长量 $W_{level}$：\n$$W_{level} = H + W_{sw} = 32 + 64 = 96 \\text{ 字节}$$\n接下来，计算可用于中断上下文的栈空间，即总大小减去初始使用量和保护边距：\n$$\\text{Available Space} = S - B - G = 3072 - 1024 - 256 = 1792 \\text{ 字节}$$\n现在，我们可以计算最大嵌套深度：\n$$d_{\\max} = \\left\\lfloor \\frac{1792}{96} \\right\\rfloor$$\n为了简化分数 $\\frac{1792}{96}$，我们可以将分子和分母同时除以它们的最大公约数。两者都可以被 $32$ 整除。\n$$d_{\\max} = \\left\\lfloor \\frac{1792 \\div 32}{96 \\div 32} \\right\\rfloor = \\left\\lfloor \\frac{56}{3} \\right\\rfloor$$\n计算该分数：\n$$\\frac{56}{3} = 18.666...$$\n应用向下取整函数得到最大整数深度：\n$$d_{\\max} = \\lfloor 18.666... \\rfloor = 18$$\n这个结果 $18$ 小于总中断优先级数 $P=24$。因此，限制因素是可用的栈空间，而不是优先级的数量。最大安全嵌套深度为 $18$。",
            "answer": "$$\n\\boxed{18}\n$$"
        },
        {
            "introduction": "正确处理异常的关键在于精确理解和使用处理器保存的状态，尤其是异常程序计数器（$EPC$）。这个练习模拟了一个常见的调试场景，其中陷阱处理程序中的一个微小逻辑错误导致了程序行为的偏差 。通过分析此问题，你将能更深刻地理解不同类型的陷阱（例如，需要重新执行指令的故障）在返回机制上的根本差异。",
            "id": "3640478",
            "problem": "一个32位的精简指令集计算机 (RISC) 处理器使用定长的 $4$ 字节指令和精确异常。\n\n根据精确异常的定义，当一个同步陷阱在某个程序计数器位置发生时，硬件会将导致异常的指令的程序计数器 (PC) 记录到异常程序计数器 (EPC) 中，将 $PC$ 设置为陷阱向量，并清空流水线，以确保后续指令没有提交。异常返回指令（此处表示为 $ERET$）通过设置 $PC \\leftarrow EPC$ 来恢复控制。\n\n考虑以下实验：一个用户程序在地址 $0x00001000$ 处的一条加载指令上触发了一个同步陷阱。陷阱处理程序的序言部分会将通用寄存器保存到栈中，并且，出于从早期仅处理中断的设计中继承的调试目的，在进行任何修复之前，包含一行调整 $EPC$ 一个指令长度的代码：\n\n- 处理程序设置栈指针 (SP) 为栈帧腾出空间：$SP \\leftarrow SP - 20$。\n- 它将几个寄存器存储在距离 $SP$ 偏移量为 $0$、$4$ 和 $8$ 的位置。\n- 它将 $EPC$ 存储在距离 $SP$ 偏移量为 $12$ 的位置。\n- 它将处理程序的返回地址寄存器存储在距离 $SP$ 偏移量为 $16$ 的位置。\n- 然后它执行一个无条件调整 $EPC \\leftarrow EPC + 4$（意图是“跳过”导致错误的指令）。\n- 在修复错误后（例如，映射缺失的页面），处理程序执行 $ERET$，根据定义，该指令会设置 $PC \\leftarrow EPC$。\n\n根据经验观察，在 $ERET$ 之后，观察到的 $PC$ 是 $0x00001004$，并且用户在 $0x00001000$ 处导致错误的加载指令没有被重新执行。仅使用上面陈述的关于 $EPC$、$PC$ 和 $ERET$ 的基本语义，以及所描述的处理程序序言，哪种解释最能说明返回到错误 $PC$ 的原因？\n\nA. 处理程序误解了 $EPC$ 的语义，在序言中错误地将 $EPC$ 增加了一个指令长度（$+4$ 字节）。因为 $EPC$ 已经包含了导致错误的指令的地址，这个差一的调整强制 $ERET$ 在 $0x00001004$ 而不是 $0x00001000$ 处恢复执行。\n\nB. 对于同步陷阱，硬件将 $EPC$ 记录为下一个顺序执行的 $PC$（$PC + 4$），因此在 $0x00001004$ 恢复执行是预期行为，不存在错误。\n\nC. 序言的栈布局存在一个槽位的偏差，因此在恢复时，处理程序从返回地址槽位加载了 $EPC$，导致 $ERET$ 跳转到 $0x00001004$；这个差一错误源于未对齐的栈偏移量，而非 $EPC$ 的语义。\n\nD. 分支延迟槽语义导致 $EPC$ 指向延迟槽，而无条件的 $ERET$ 在 $PC + 4$ 处恢复；这个差一错误是由于延迟分支造成的，尽管导致错误的指令是加载指令。",
            "solution": "在进行解答之前，我们对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- **处理器**：$32$ 位精简指令集计算机 (RISC)。\n- **指令大小**：定长 $4$ 字节指令。\n- **异常模型**：精确异常。\n- **同步陷阱定义**：\n    - 在特定的程序计数器 ($PC$) 位置发生。\n    - 硬件行为：将导致异常的指令的 $PC$ 记录到异常程序计数器 ($EPC$) 中。\n    - 硬件行为：将 $PC$ 设置为陷阱向量。\n    - 硬件行为：清空流水线。\n- **异常返回指令 ($ERET$) 定义**：\n    - 通过设置 $PC \\leftarrow EPC$ 恢复控制。\n- **实验场景**：\n    - 一个用户程序触发了一个同步陷阱。\n    - 陷阱位置 ($PC$)：$0x00001000$。\n    - 导致错误的指令类型：加载指令。\n- **陷阱处理程序序言操作**：\n    1.  $SP \\leftarrow SP - 20$。\n    2.  将通用寄存器存储在距离 $SP$ 偏移量为 $0$、$4$ 和 $8$ 的位置。\n    3.  将 $EPC$ 存储在距离 $SP$ 偏移量为 $12$ 的位置。\n    4.  将处理程序的返回地址寄存器存储在距离 $SP$ 偏移量为 $16$ 的位置。\n    5.  执行一个无条件调整：$EPC \\leftarrow EPC + 4$。\n- **修复后操作**：处理程序执行 $ERET$。\n- **观察到的实验结果**：\n    - $ERET$ 之后，观察到的 $PC$ 是 $0x00001004$。\n    - $0x00001000$ 处导致错误的加载指令没有被重新执行。\n- **问题**：仅根据所提供的语义和描述，对于返回到错误 $PC$ 的最佳解释是什么？\n\n### 步骤 2：使用提取的已知条件进行验证\n评估问题陈述的有效性。\n- **科学依据**：该问题描述了 RISC 架构中一个标准的异常处理模型，与现实世界的处理器（例如 MIPS）一致。程序计数器 ($PC$)、异常程序计数器 ($EPC$)、精确异常、同步陷阱（故障）、陷阱处理程序以及异常返回指令 ($ERET$) 等概念是计算机组成和体系结构中的基本主题。该描述在事实上和科学上是合理的。\n- **定义明确**：该问题是定义明确的。它为陷阱发生时和执行 $ERET$ 时硬件的行为提供了明确的定义。它描述了一系列事件和一个清晰、具体的结果。问题要求提供一个逻辑解释，将初始状态和处理程序的操作与最终结果联系起来。可以从所提供的信息中推导出一个唯一且确定的解决方案。\n- **客观性**：语言精确且技术性强。所有操作和状态都进行了定量描述（例如，内存地址、寄存器操作）。没有主观或模糊的术语。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。它内容自洽，逻辑一致，并基于公认的计算机体系结构原理。将推导出一个解决方案。\n\n### 正确行为的推导\n分析的核心是追踪 $EPC$ 寄存器在整个事件序列中的值。\n\n1.  **陷阱启动**：在执行 $PC = 0x00001000$ 处的指令时，发生了一个同步陷阱。\n2.  **硬件对陷阱的响应**：根据问题定义（“硬件会将导致异常的指令的程序计数器 (PC) 记录到异常程序计数器 (EPC) 中”），硬件执行以下操作：\n    $$EPC \\leftarrow 0x00001000$$\n    此时，控制权转移到陷阱处理程序。\n3.  **陷阱处理程序执行**：处理程序开始其序言。与本分析相关的操作是对 $EPC$ 寄存器的显式修改。问题陈述处理程序执行：\n    $$EPC \\leftarrow EPC + 4$$\n    代入上一步中 $EPC$ 的值：\n    $$EPC \\leftarrow 0x00001000 + 4$$\n    $$EPC \\leftarrow 0x00001004$$\n    其他序言操作，例如将寄存器保存到栈中，不会改变将由 $ERET$ 使用的硬件 $EPC$ 寄存器的值。它们是干扰核心逻辑的因素。\n4.  **从异常返回**：在据推测错误已修复后，处理程序执行 $ERET$ 指令。$ERET$ 的行为被明确定义为：\n    $$PC \\leftarrow EPC$$\n    使用 $EPC$ 寄存器的当前值：\n    $$PC \\leftarrow 0x00001004$$\n5.  **结论**：处理器在地址 $0x00001004$ 处的指令恢复执行。这意味着地址 $0x00001000$ 处的指令被跳过了。这个推导出的结果 ($PC = 0x00001004$) 与观察到的实验结果完全匹配。\n\n这被认为是“错误的 PC”的原因是，对于一个导致错误的指令（比如引起缺页故障的加载指令），修复错误后的标准行为是重新执行该指令。这将需要返回到其地址 $0x00001000$。处理程序增加 $EPC$ 的行为对于这类异常来说是一个错误；它将该错误当作一个事件（如软件中断/`syscall`）来处理，这种事件在返回时应该被“跳过”。因此，错误完全在于陷阱处理程序软件的逻辑中。\n\n### 逐项分析选项\n\n**A. 处理程序误解了 $EPC$ 的语义，在序言中错误地将 $EPC$ 增加了一个指令长度（$+4$ 字节）。因为 $EPC$ 已经包含了导致错误的指令的地址，这个差一的调整强制 $ERET$ 在 $0x00001004$ 而不是 $0x00001000$ 处恢复执行。**\n这个选项正确地指出了如上推导的事件链。硬件正确地将 $EPC$ 设置为导致错误的地址 ($0x00001000$)。然后，处理程序软件错误地将此值修改为 $0x00001004$。$ERET$ 指令接着使用这个修改后的值，导致了观察到的结果。“误解了 EPC 语义”这句话是对该错误的高层次准确描述：处理程序未能理解对于这种类型的陷阱，$EPC$ 的值应被保留以允许重新执行。\n**结论：正确。**\n\n**B. 对于同步陷阱，硬件将 $EPC$ 记录为下一个顺序执行的 $PC$（$PC + 4$），因此在 $0x00001004$ 恢复执行是预期行为，不存在错误。**\n这个选项与问题陈述中给出的一个基本前提相矛盾。问题明确定义了“硬件会将导致异常的指令的程序计数器 (PC) 记录到异常程序计数器 (EPC) 中”。这意味着 $EPC$ 被设置为 $PC$，而不是 $PC+4$。如果这个选项为真，硬件最初会将 $EPC$ 设置为 $0x00001004$。然后处理程序的调整（$EPC \\leftarrow EPC + 4$）将得出 $EPC = 0x00001008$。$ERET$ 随后将导致跳转到 $0x00001008$，这与观察到的结果 $0x00001004$ 相矛盾。\n**结论：不正确。**\n\n**C. 序言的栈布局存在一个槽位的偏差，因此在恢复时，处理程序从返回地址槽位加载了 $EPC$，导致 $ERET$ 跳转到 $0x00001004$；这个差一错误源于未对齐的栈偏移量，而非 $EPC$ 的语义。**\n这个选项假设了一个问题中没有描述的栈恢复操作。问题描述处理程序在其序言中*存储*值到栈中，然后执行 $ERET$。$ERET$ 的定义是 $PC \\leftarrow EPC$，意味着它直接从硬件 $EPC$ 寄存器中读取。没有提到在 $ERET$ 之前有从栈中恢复寄存器的结尾部分。硬件 $EPC$ 寄存器的最终值是由 $EPC \\leftarrow EPC + 4$ 指令决定的，而不是由任何从栈中加载的操作决定的。\n**结论：不正确。**\n\n**D. 分支延迟槽语义导致 $EPC$ 指向延迟槽，而无条件的 $ERET$ 在 $PC + 4$ 处恢复；这个差一错误是由于延迟分支造成的，尽管导致错误的指令是加载指令。**\n这个选项引入了分支延迟槽的概念，而问题描述中并未提及。我们必须*仅*根据给定的信息进行推理。此外，分支延迟槽与分支指令相关。导致错误的指令明确是一条*加载*指令，这使得分支延迟槽语义与错误本身无关。所提供的信息足以解释结果，无需对未提及的架构特性进行推测。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了中断和陷阱的基本机制后，我们可以探索如何利用它们来优化系统性能。这个练习介绍了一种真实世界中的优化技术——“惰性上下文切换”，它通过延迟保存浮点单元（FPU）状态来降低平均中断处理成本 。你将使用概率论来量化分析这种优化策略的性能收益和开销，从而确定其适用的临界条件。",
            "id": "3640499",
            "problem": "一个计算机系统实现惰性浮点上下文切换，以降低平均中断处理成本。考虑一个运行着操作系统的单核中央处理器（CPU），该系统在存在硬件异常和陷阱的情况下，采用两种备选策略来处理由中断引起的上下文切换中的浮点单元（FPU）状态：\n\n- 积极策略：在每次由中断引起的上下文切换时，操作系统立即保存传出任务的FPU状态，并恢复传入任务的FPU状态。\n- 惰性策略：在由中断引起的上下文切换时，操作系统不保存FPU状态。取而代之的是，它设置一个软件标志并将FPU标记为不可用。如果传入任务执行浮点指令，则会发生同步陷阱，之后操作系统保存传出任务的FPU状态，恢复传入任务的FPU状态，并启用FPU。\n\n假设以下符合科学实际的成本，以CPU周期表示：\n- 保存FPU状态的成本为 $C_{s} = 520$。\n- 恢复FPU状态的成本为 $C_{r} = 480$。\n- 处理第一条浮点指令的陷阱开销（包括异常进入/退出和最小寄存器帧处理）为 $C_{t} = 300$。\n- 惰性策略在每次上下文切换时产生的簿记开销（例如设置任务切换标志和禁用FPU）为 $C_{\\ell} = 35$。\n- 中断进入/退出开销 $C_{i}$ 对两种策略是相同的，可以视为一个公共的加法常数。\n\n设 $p$ 表示传入任务在下一次上下文切换前至少执行一条浮点指令的概率。假设在惰性策略下，每个任务在每次上下文切换中触发零次或一次陷阱。\n\n从异步中断、同步陷阱和概率论中期望值的基础定义出发，并且不使用任何快捷公式，完成以下任务：\n1. 推导在积极策略下，每次由中断引起的上下文切换的期望周期数，表示为 $C_{s}$、$C_{r}$ 和 $C_{i}$ 的函数。\n2. 推导在惰性策略下，每次由中断引起的上下文切换的期望周期数，表示为 $p$、$C_{\\ell}$、$C_{t}$、$C_{s}$、$C_{r}$ 和 $C_{i}$ 的函数。\n3. 推导使用惰性策略而非积极策略时，每次中断所节省的期望周期数表达式，表示为 $p$、$C_{\\ell}$、$C_{t}$、$C_{s}$ 和 $C_{r}$ 的函数（以每次中断的周期数表示）。\n4. 确定临界概率 $p^{\\star}$，使得每次中断节省的期望周期数为零，即惰性策略和积极策略的期望成本相等。使用给定的常数数值计算 $p^{\\star}$。\n\n将节省的期望周期数以每次中断的周期数表示。仅报告 $p^{\\star}$ 的最终值，作为一个无量纲数。将您的 $p^{\\star}$ 值四舍五入到四位有效数字。",
            "solution": "该问题要求分析在中断引起的上下文切换期间处理浮点单元（FPU）状态的两种策略。我们将基于概率论原理对成本进行建模，以确定性能上的权衡。分析将首先验证问题陈述的有效性，然后通过逐步推导进行。\n\n### 问题验证\n给定的问题是有效的。\n1.  **提取已知条件**：\n    *   保存FPU状态的成本：$C_s = 520$ 周期。\n    *   恢复FPU状态的成本：$C_r = 480$ 周期。\n    *   惰性策略的陷阱处理开销：$C_t = 300$ 周期。\n    *   惰性策略每次上下文切换的簿记开销：$C_{\\ell} = 35$ 周期。\n    *   公共的中断进入/退出开销：$C_i$ 周期。\n    *   传入任务执行浮点指令的概率：$p$。\n2.  **验证结论**：\n    *   **科学依据**：该问题描述了惰性FPU上下文切换，这是操作系统中的一种标准优化技术。异步中断和同步陷阱之间的区别是计算机体系结构的基础。使用期望值是分析概率条件下性能的正确数学工具。\n    *   **问题明确**：问题陈述清晰，所有必要参数均已定义。它要求进行具体的推导和数值计算，这些都可以从给定信息中唯一确定。\n    *   **客观性**：问题使用精确的技术术语表述，并提供客观的数值数据，没有主观偏见。\n\n因此，该问题是有效的，可以推导出解决方案。\n\n### 基本原理\n**异步中断**是由CPU当前指令流之外的硬件生成的事件（例如，磁盘控制器发出I/O完成信号）。其发生时间相对于程序执行是不可预测的。**同步陷阱**（或异常）是执行指令直接导致的事件（例如，除以零，或者在本问题中，尝试使用禁用的FPU）。\n\n离散随机变量 $X$ 的**期望值**，记为 $E[X]$，是其所有可能值的概率加权平均。如果 $X$ 可以取值为 $\\{x_1, x_2, \\dots, x_n\\}$，对应的概率为 $\\{P(X=x_1), P(X=x_2), \\dots, P(X=x_n)\\}$，其期望值由下式给出：\n$$E[X] = \\sum_{k=1}^{n} x_k P(X=x_k)$$\n在我们的情境中，随机变量是上下文切换所需的周期数，它取决于传入任务是否使用FPU。\n\n### 任务1：积极策略的期望周期数 ($E_{eager}$)\n在积极策略下，每次由中断引起的上下文切换都会保存传出任务的FPU状态，并恢复传入任务的FPU状态。这一系列操作是确定性的。总成本是公共中断开销以及保存和恢复FPU状态的特定成本之和。\n每次上下文切换的成本是恒定的。\n$$\n\\text{Cost}_{eager} = C_i + C_s + C_r\n$$\n由于此成本以概率 $1$ 发生，因此每次上下文切换的期望周期数 $E_{eager}$ 等于此成本。\n$$\nE_{eager} = C_i + C_s + C_r\n$$\n\n### 任务2：惰性策略的期望周期数 ($E_{lazy}$)\n在惰性策略下，成本取决于传入任务是否执行浮点指令。每次上下文切换有两种互斥的结果：\n\n1.  **情况1：传入任务不执行任何浮点指令。** 此事件发生的概率为 $1-p$。在这种情况下，操作系统只产生禁用FPU的初始簿记开销。昂贵的保存和恢复操作被完全避免。这种情况的成本是：\n    $$\n    \\text{Cost}_1 = C_i + C_{\\ell}\n    $$\n2.  **情况2：传入任务执行至少一条浮点指令。** 此事件发生的概率为 $p$。首次尝试执行浮点指令会触发同步陷阱。操作系统陷阱处理程序随后保存前一个任务的FPU状态，并恢复当前任务的FPU状态。总成本包括簿记开销、陷阱处理开销以及保存和恢复FPU状态的成本。这种情况的成本是：\n    $$\n    \\text{Cost}_2 = C_i + C_{\\ell} + C_t + C_s + C_r\n    $$\n\n根据期望值的定义，惰性策略下每次上下文切换的期望周期数 $E_{lazy}$ 是每种情况的成本乘以其相应概率的总和：\n$$\nE_{lazy} = (\\text{Cost}_1 \\times (1-p)) + (\\text{Cost}_2 \\times p)\n$$\n代入成本表达式：\n$$\nE_{lazy} = (C_i + C_{\\ell})(1-p) + (C_i + C_{\\ell} + C_t + C_s + C_r)p\n$$\n我们可以通过分配各项来简化此表达式：\n$$\nE_{lazy} = C_i(1-p) + C_{\\ell}(1-p) + C_i p + C_{\\ell} p + (C_t + C_s + C_r)p\n$$\n$$\nE_{lazy} = C_i - C_i p + C_{\\ell} - C_{\\ell} p + C_i p + C_{\\ell} p + p(C_t + C_s + C_r)\n$$\n项 $-C_i p$ 和 $+C_i p$ 相互抵消，$-C_{\\ell} p$ 和 $+C_{\\ell} p$ 也相互抵消。这导出了简化形式：\n$$\nE_{lazy} = C_i + C_{\\ell} + p(C_t + C_s + C_r)\n$$\n\n### 任务3：每次中断节省的期望周期数 ($\\Delta E$)\n节省的期望周期数 $\\Delta E$ 是积极策略的期望成本与惰性策略的期望成本之差。\n$$\n\\Delta E = E_{eager} - E_{lazy}\n$$\n代入任务1和任务2中推导出的表达式：\n$$\n\\Delta E = (C_i + C_s + C_r) - \\left( C_i + C_{\\ell} + p(C_t + C_s + C_r) \\right)\n$$\n公共中断开销 $C_i$ 相互抵消：\n$$\n\\Delta E = C_s + C_r - C_{\\ell} - p(C_t + C_s + C_r)\n$$\n这个表达式可以重新整理，以突出节省的成本与额外成本的对比：\n$$\n\\Delta E = (1-p)(C_s + C_r) - C_{\\ell} - pC_t\n$$\n这种形式表明，在概率为 $1-p$ 的情况下，我们节省了完整的保存/恢复成本 $C_s+C_r$。然而，我们总是会产生惰性簿记成本 $C_{\\ell}$，并且在概率为 $p$ 的情况下，我们会产生额外的陷阱成本 $C_t$。两种形式是等价的。我们将在下一步中使用第一种推导出的形式。\n$$\n\\Delta E = (C_s + C_r - C_{\\ell}) - p(C_t + C_s + C_r)\n$$\n\n### 任务4：临界概率 ($p^{\\star}$)\n临界概率 $p^{\\star}$ 是指两种策略具有相等期望成本时的 $p$ 值。这发生在节省的期望周期数 $\\Delta E$ 为零时。\n$$\n\\Delta E = 0\n$$\n$$\n(C_s + C_r - C_{\\ell}) - p^{\\star}(C_t + C_s + C_r) = 0\n$$\n求解 $p^{\\star}$：\n$$\np^{\\star}(C_t + C_s + C_r) = C_s + C_r - C_{\\ell}\n$$\n$$\np^{\\star} = \\frac{C_s + C_r - C_{\\ell}}{C_t + C_s + C_r}\n$$\n现在，我们代入给定的数值：$C_s = 520$，$C_r = 480$，$C_t = 300$ 和 $C_{\\ell} = 35$。\n$$\np^{\\star} = \\frac{520 + 480 - 35}{300 + 520 + 480}\n$$\n$$\np^{\\star} = \\frac{1000 - 35}{300 + 1000}\n$$\n$$\np^{\\star} = \\frac{965}{1300}\n$$\n进行除法运算：\n$$\np^{\\star} \\approx 0.74230769...\n$$\n四舍五入到四位有效数字，我们得到：\n$$\np^{\\star} \\approx 0.7423\n$$\n这意味着，如果超过大约 $74.23\\%$ 的上下文切换之后有浮点指令执行，那么积极策略将比惰性策略更高效。",
            "answer": "$$\\boxed{0.7423}$$"
        }
    ]
}