{
    "hands_on_practices": [
        {
            "introduction": "Modern processors use speculative execution to boost performance, but this can inadvertently create security vulnerabilities. When the processor guesses the outcome of a branch, its prediction mechanisms can become a side channel, leaking information between different security domains. A fundamental defense is to isolate these predictive structures, and this practice challenges you to think like a hardware designer and quantify the storage overhead required to implement such an isolation mechanism, providing a concrete measure of the cost of security .",
            "id": "3645422",
            "problem": "A modern out-of-order processor uses speculation guided by branch prediction. In the baseline design, the predictor maintains a single Branch History Table (BHT), defined as an array indexed by low-order bits of the program counter, where each entry is a saturating counter used to predict branch direction. Cross-domain interactions can create microarchitectural side channels, where predictor state learned in one security domain influences prediction behavior in another, potentially violating the noninterference principle in information flow security. One widely used mitigation in hardware security is to isolate predictor state across domains so that the predictor behavior does not carry information from one domain to another.\n\nConsider the following isolation mechanism: the processor maintains per-domain BHTs, one BHT for each security domain, and switches the active BHT based on a domain identifier when the operating system changes security domains. Assume the following:\n- The baseline predictor uses a single BHT with $H$ entries.\n- Each BHT entry stores a 2-bit saturating counter (a well-tested standard in branch prediction).\n- In the isolated design, there are $D$ security domains, each with its own BHT of $H$ entries, with the same 2-bit saturating counters per entry.\n- The processor also maintains a domain identifier register that encodes the current domain with enough bits to represent all $D$ domains.\n- Ignore all non-memory overheads (for example, combinational selection logic, wires, and control flip-flops other than the domain identifier register). Count only stored bits in memory arrays and the domain identifier register as storage.\n\nStarting from the definitions above and the security objective of noninterference, derive and express the total storage overhead of the isolated design relative to the baseline design as a single closed-form analytic expression in terms of $H$ and $D$. Express your final answer in bits. Do not perform any numerical substitutions. Do not round; return the exact symbolic expression.",
            "solution": "The problem statement is coherent and valid. It is scientifically grounded in the principles of computer architecture and information flow security, specifically addressing side-channel attacks in branch predictors. The problem is well-posed, providing all necessary definitions and variables to derive a unique analytical solution. It is objective and free from ambiguity or contradiction.\n\nThe objective is to derive an expression for the total storage overhead of an isolated branch predictor design relative to a baseline design. The overhead is defined as the additional storage, measured in bits, required by the isolated design.\n\nLet $S_{\\text{baseline}}$ be the total storage of the baseline design in bits.\nLet $S_{\\text{isolated}}$ be the total storage of the isolated design in bits.\nThe storage overhead, $S_{\\text{overhead}}$, is then defined as:\n$$S_{\\text{overhead}} = S_{\\text{isolated}} - S_{\\text{baseline}}$$\n\nFirst, we calculate the storage for the baseline design, $S_{\\text{baseline}}$. The baseline design consists of a single Branch History Table (BHT).\n- The BHT has $H$ entries.\n- Each entry is a 2-bit saturating counter.\nThe total storage for the baseline BHT is the product of the number of entries and the size of each entry in bits.\n$$S_{\\text{baseline}} = H \\times 2$$\n\nNext, we calculate the storage for the isolated design, $S_{\\text{isolated}}$. The problem specifies that this design includes two components whose storage must be counted: the per-domain BHTs and a domain identifier register.\n1.  **Storage for the BHTs:**\n    - There are $D$ security domains.\n    - For each domain, there is a dedicated BHT with $H$ entries.\n    - Each entry in every BHT is a 2-bit saturating counter.\n    The total storage for all $D$ BHTs is the product of the number of domains, the number of entries per BHT, and the size of each entry.\n    $$S_{\\text{BHTs\\_isolated}} = D \\times H \\times 2 = 2DH$$\n\n2.  **Storage for the domain identifier register:**\n    - This register must encode the current security domain, of which there are $D$.\n    - To represent $D$ distinct states, the minimum number of bits required, denoted by $k$, must satisfy the inequality $2^k \\ge D$.\n    - Solving for $k$ gives $k \\ge \\log_2(D)$. Since the number of bits must be an integer, we take the ceiling of this value.\n    - The storage for the domain identifier register is therefore:\n    $$S_{\\text{register}} = \\lceil \\log_2(D) \\rceil$$\n\nThe total storage for the isolated design, $S_{\\text{isolated}}$, is the sum of the storage for the BHTs and the domain identifier register.\n$$S_{\\text{isolated}} = S_{\\text{BHTs\\_isolated}} + S_{\\text{register}} = 2DH + \\lceil \\log_2(D) \\rceil$$\n\nFinally, we compute the storage overhead, $S_{\\text{overhead}}$, by subtracting the baseline storage from the isolated design storage.\n$$S_{\\text{overhead}} = S_{\\text{isolated}} - S_{\\text{baseline}}$$\n$$S_{\\text{overhead}} = \\left( 2DH + \\lceil \\log_2(D) \\rceil \\right) - (2H)$$\nRearranging the terms and factoring out the common factor $2H$ yields the final closed-form expression for the overhead:\n$$S_{\\text{overhead}} = 2DH - 2H + \\lceil \\log_2(D) \\rceil$$\n$$S_{\\text{overhead}} = 2H(D-1) + \\lceil \\log_2(D) \\rceil$$\nThis expression represents the total additional storage in bits required by the isolated design, in terms of the number of BHT entries $H$ and the number of security domains $D$.",
            "answer": "$$\\boxed{2H(D-1) + \\lceil \\log_{2}(D) \\rceil}$$"
        },
        {
            "introduction": "Beyond speculative state, the very time an operation takes to complete can betray secret information. These timing side channels are a pervasive threat, and a powerful defense is to enforce 'constant-time' execution, where an operation's duration is independent of the data it processes. This exercise asks you to analyze a realistic processor optimization that creates a timing vulnerability and to calculate the average performance penalty, measured in padded cycles, required to eliminate it .",
            "id": "3645417",
            "problem": "You are designing a constant-time integer divider to eliminate timing leakage through a Timing Side Channel (TSC). The existing divider implements a microarchitectural optimization: for any non-zero $w$-bit divisor $d$, write $d = 2^t m$ where $m$ is odd and $t \\in \\{0,1,\\dots,w-1\\}$ is the number of trailing zeros in the binary representation of $d$. The optimized divider saves a constant $\\delta$ cycles for each trailing zero, so its completion time is $C_{\\text{gen}} - \\delta t$ cycles, where $C_{\\text{gen}}$ is the cycle count of the baseline generic path with no optimization. To enforce constant-time operation, you pad the optimized cases by $\\delta t$ cycles so that every division takes $C_{\\text{gen}}$ cycles and no information about $t$ is leaked through timing.\n\nAssume that the secret divisor $d$ is uniformly distributed over the non-zero $w$-bit integers $\\{1,2,\\dots,2^{w}-1\\}$ and that division by zero never occurs. Starting from first principles (counting arguments over the set of non-zero $w$-bit integers and the arithmetic property that division by $2^{t}$ corresponds to a right shift by $t$), derive an exact closed-form expression, in terms of $w$ and $\\delta$, for the expected number of padding cycles per division under this equalization scheme. Then, evaluate this expression for $w = 32$ and $\\delta = 1$. Express your final answer as a single exact rational number of cycles. Do not approximate or round.",
            "solution": "The problem asks for the expected number of padding cycles required to make an optimized integer divider operate in constant time. The number of padding cycles for a given non-zero $w$-bit divisor $d$ is given by $\\delta t$, where $\\delta$ is a constant and $t$ is the number of trailing zeros in the binary representation of $d$. The divisor $d$ is assumed to be uniformly distributed over the set of non-zero $w$-bit integers, which is specified as $\\{1, 2, \\dots, 2^w-1\\}$.\n\nFirst, we formalize the problem. Let $D$ be the random variable representing the divisor, uniformly distributed on the sample space $\\Omega = \\{1, 2, \\dots, 2^w - 1\\}$. The size of the sample space is $|\\Omega| = 2^w - 1$. The probability of any specific divisor $d \\in \\Omega$ is $\\mathbb{P}(D=d) = \\frac{1}{2^w - 1}$.\n\nLet $t(d)$ be the function that maps a divisor $d$ to the number of its trailing zeros. The number of padding cycles for a divisor $d$ is a random variable $P(d) = \\delta \\cdot t(d)$. We are asked to find the expected value of these padding cycles, $E[P]$.\n\nBy the definition of expected value for a discrete random variable, we have:\n$$E[P] = \\sum_{d \\in \\Omega} P(d) \\cdot \\mathbb{P}(D=d)$$\nSubstituting the given values:\n$$E[P] = \\sum_{d=1}^{2^w-1} \\delta \\cdot t(d) \\cdot \\frac{1}{2^w - 1}$$\nWe can factor out the constant terms $\\delta$ and $\\frac{1}{2^w-1}$:\n$$E[P] = \\frac{\\delta}{2^w - 1} \\sum_{d=1}^{2^w-1} t(d)$$\nThe core of the problem is to compute the total sum of trailing zeros, $S = \\sum_{d=1}^{2^w-1} t(d)$, for all integers from $1$ to $2^w-1$.\n\nThe number of trailing zeros $t(d)$ of an integer $d$ is the highest power of $2$ that divides $d$. That is, $d$ is divisible by $2^{t(d)}$ but not by $2^{t(d)+1}$. An alternative characterization is that $t(d) = \\sum_{k=1}^{\\infty} [2^k | d]$, where $[2^k|d]$ is an indicator function that is $1$ if $2^k$ divides $d$ and $0$ otherwise. An integer $d$ with $t$ trailing zeros contributes $1$ to the count of multiples of $2^1$, $1$ to the count of multiples of $2^2$, ..., and $1$ to the count of multiples of $2^t$.\n\nUsing this insight, we can re-express the sum $S$ by changing the order of summation. Instead of summing the number of trailing zeros for each $d$, we can sum over the powers of $2$ and, for each power $2^k$, count how many numbers in the set $\\Omega$ are divisible by it.\n$$S = \\sum_{d=1}^{2^w-1} t(d) = \\sum_{d=1}^{2^w-1} \\sum_{k=1}^{w-1} [2^k | d]$$\nThe maximum power of $2$ that can divide a number in $\\Omega$ is $2^{w-1}$ (which divides $2^{w-1}$ itself), so the sum over $k$ can be terminated at $w-1$.\nBy swapping the order of summation:\n$$S = \\sum_{k=1}^{w-1} \\sum_{d=1}^{2^w-1} [2^k | d]$$\nThe inner sum, $\\sum_{d=1}^{2^w-1} [2^k|d]$, is simply the count of integers in the set $\\{1, 2, \\dots, 2^w-1\\}$ that are multiples of $2^k$. This count is given by $\\lfloor \\frac{2^w-1}{2^k} \\rfloor$.\n\nLet's analyze this term. For any integer $k \\ge 1$, we can write:\n$$\\lfloor \\frac{2^w-1}{2^k} \\rfloor = \\lfloor \\frac{2^w}{2^k} - \\frac{1}{2^k} \\rfloor = \\lfloor 2^{w-k} - 2^{-k} \\rfloor$$\nSince $k \\ge 1$, $0 < 2^{-k} \\le \\frac{1}{2}$. Therefore, $2^{w-k} - 2^{-k}$ is not an integer, and its floor is $2^{w-k} - 1$.\nSo, the number of multiples of $2^k$ in the set is $2^{w-k}-1$.\n\nNow we can compute the sum $S$:\n$$S = \\sum_{k=1}^{w-1} (2^{w-k}-1) = \\left(\\sum_{k=1}^{w-1} 2^{w-k}\\right) - \\left(\\sum_{k=1}^{w-1} 1\\right)$$\nThe second term is simply $w-1$.\nFor the first term, we can perform a change of index. Let $j = w-k$. As $k$ goes from $1$ to $w-1$, $j$ goes from $w-1$ to $1$.\n$$\\sum_{k=1}^{w-1} 2^{w-k} = \\sum_{j=1}^{w-1} 2^j = (2^1 + 2^2 + \\dots + 2^{w-1})$$\nThis is a geometric series with first term $a=2$, ratio $r=2$, and $n=w-1$ terms. The sum is $a\\frac{r^n-1}{r-1} = 2\\frac{2^{w-1}-1}{2-1} = 2(2^{w-1}-1) = 2^w - 2$.\n\nSubstituting these results back into the expression for $S$:\n$$S = (2^w-2) - (w-1) = 2^w - 2 - w + 1 = 2^w - w - 1$$\n\nNow we substitute this sum back into the formula for the expected number of padding cycles:\n$$E[P] = \\frac{\\delta}{2^w - 1} (2^w - w - 1)$$\nThis is the desired exact closed-form expression for the expected number of padding cycles in terms of $w$ and $\\delta$.\n\nThe problem then asks to evaluate this expression for $w=32$ and $\\delta=1$.\nSubstituting these values:\n$$E[P] = \\frac{1 \\cdot (2^{32} - 32 - 1)}{2^{32} - 1} = \\frac{2^{32} - 33}{2^{32} - 1}$$\nThis is an exact rational number as requested. We can also write it as:\n$$E[P] = \\frac{(2^{32} - 1) - 32}{2^{32} - 1} = 1 - \\frac{32}{2^{32} - 1}$$\nThis form shows that the expected number of padding cycles is slightly less than $1$ cycle. The form $\\frac{2^{32}-33}{2^{32}-1}$ is a single rational number.",
            "answer": "$$\\boxed{\\frac{2^{32}-33}{2^{32}-1}}$$"
        },
        {
            "introduction": "Hardware security is not just about individual microarchitectural units; it involves system-level policies that govern how resources are shared. Performance-enhancing features like huge pages in virtual memory systems can become a security risk, creating shared channels in the Translation Lookaside Buffer (TLB). This practice places you in the role of a system designer tasked with evaluating a security policy that restricts huge page usage, calculating the resulting performance degradation in terms of increased TLB misses and demonstrating how OS-level security decisions have a direct, measurable impact on hardware efficiency .",
            "id": "3645354",
            "problem": "A system designer is hardening a multiprogrammed, 64-bit system against cross-domain leakage via shared Translation Lookaside Buffer (TLB) entries when using huge pages. Consider a single out-of-order core that time-slices two security domains, Domain A and Domain B, with Domain A running in 1 millisecond quanta. For isolation, the operating system enforces the following secure policy: disable 1 gigabyte pages, allow 2 megabyte pages only for per-domain private regions, map any region visible in more than one domain using 4 kilobyte pages, and flush all TLB structures on every domain switch because Process-Context Identifiers (PCID) are not used.\n\nAssume the following hardware configuration and workload properties for Domain A while it is running:\n- Data Translation Lookaside Buffer (DTLB) is partitioned by page size and is fully associative in each partition with perfect least recently used replacement. It has $E_{4\\mathrm{K}} = 256$ entries for 4 kilobyte pages, $E_{2\\mathrm{M}} = 64$ entries for 2 megabyte pages, and $E_{1\\mathrm{G}} = 8$ entries for 1 gigabyte pages. Under the secure policy, 1 gigabyte pages are disabled.\n- Domain Aâ€™s data footprint during its time slice consists of a private hot region of size $S_{2\\mathrm{M}} = 256$ megabytes, eligible for 2 megabyte pages under the secure policy, and a shared read-only hot region of size $S_{4\\mathrm{K}} = 4$ megabytes, which must be mapped with 4 kilobyte pages. Accesses are uniformly random within each region. The fraction of data references targeting the private region is $p = 0.8$, and the fraction targeting the shared region is $1 - p$.\n- The core runs at frequency $f = 3.0$ gigahertz, retires $r = 2.5$ instructions per cycle on average, and performs $\\alpha = 0.4$ data memory references per retired instruction. Each data memory reference requires a DTLB translation.\n\nAdopt the secure policy as stated, and evaluate the effect of avoiding shared huge pages on TLB behavior by computing the expected number of DTLB misses incurred by Domain A per 1 millisecond slice. Assume a TLB flush occurs at the start of each slice. State any modeling assumptions you use that are consistent with well-tested models in the literature, and base your derivation on first principles such as working-set cardinality, page counts, and simple probability for uniformly random references.\n\nExpress the final answer in misses per millisecond, and round your answer to 4 significant figures.",
            "solution": "The problem as stated is valid, self-contained, and consistent with established principles of computer architecture and performance analysis. We can proceed to compute the expected number of Data Translation Lookaside Buffer (DTLB) misses for Domain A during its time slice.\n\nThe total number of expected DTLB misses is the sum of misses from accesses to the private region and misses from accesses to the shared region. The calculation proceeds as follows:\n\nFirst, we determine the total number of data memory references made by Domain A during its time slice. Each data memory reference requires a DTLB lookup.\nLet $T$ be the time slice duration, $f$ be the core frequency, $r$ be the average instructions retired per cycle (IPC), and $\\alpha$ be the average number of data memory references per instruction.\nThe given values are:\nTime slice, $T = 1 \\text{ ms} = 1 \\times 10^{-3} \\text{ s}$\nFrequency, $f = 3.0 \\text{ GHz} = 3.0 \\times 10^9 \\text{ cycles/s}$\nIPC, $r = 2.5 \\text{ instructions/cycle}$\nData references per instruction, $\\alpha = 0.4 \\text{ references/instruction}$\n\nThe total number of cycles in the time slice is:\n$$C = T \\times f = (1 \\times 10^{-3} \\text{ s}) \\times (3.0 \\times 10^9 \\text{ cycles/s}) = 3.0 \\times 10^6 \\text{ cycles}$$\nThe total number of instructions retired is:\n$$I = C \\times r = (3.0 \\times 10^6 \\text{ cycles}) \\times (2.5 \\text{ instructions/cycle}) = 7.5 \\times 10^6 \\text{ instructions}$$\nThe total number of data memory references, which is the total number of DTLB accesses, is:\n$$N_{\\text{ref}} = I \\times \\alpha = (7.5 \\times 10^6 \\text{ instructions}) \\times (0.4 \\text{ references/instruction}) = 3.0 \\times 10^6 \\text{ references}$$\n\nNext, we analyze the DTLB misses for the private and shared regions separately. The DTLB is partitioned by page size, so accesses to different regions do not interfere with each other's TLB entries.\n\nAnalysis for the private region (using 2 MB pages):\nThe fraction of references to the private region is $p = 0.8$. The number of references to this region is:\n$$N_{\\text{ref, 2M}} = N_{\\text{ref}} \\times p = (3.0 \\times 10^6) \\times 0.8 = 2.4 \\times 10^6$$\nThe size of the private region is $S_{2\\mathrm{M}} = 256 \\text{ MB}$. Under the secure policy, this region is mapped using $2 \\text{ MB}$ pages, so $P_{2\\mathrm{M}} = 2 \\text{ MB}$. The number of unique pages in this region's working set is:\n$$W_{2\\mathrm{M}} = \\frac{S_{2\\mathrm{M}}}{P_{2\\mathrm{M}}} = \\frac{256 \\text{ MB}}{2 \\text{ MB}} = 128 \\text{ pages}$$\nThe DTLB provides $E_{2\\mathrm{M}} = 64$ entries for $2 \\text{ MB}$ pages. Since the working set size ($W_{2\\mathrm{M}} = 128$) is greater than the DTLB capacity ($E_{2\\mathrm{M}} = 64$), capacity misses are inevitable after the initial compulsory misses.\n\nWe adopt a standard model for a fully associative cache with LRU replacement and a uniform random access pattern. For a large number of accesses, the steady-state miss rate, $m$, for a working set of $W$ pages and a cache capacity of $E$ pages (where $W > E$) is the fraction of the working set that does not fit in the cache.\n$$m = \\frac{W - E}{W} = 1 - \\frac{E}{W}$$\nThis model is appropriate here given the accesses are uniformly random and the number of references is much larger than the working set size, justifying the use of a steady-state approximation that accounts for both compulsory and capacity misses over the long run.\n\nThe miss rate for the private region is:\n$$m_{2\\mathrm{M}} = \\frac{W_{2\\mathrm{M}} - E_{2\\mathrm{M}}}{W_{2\\mathrm{M}}} = \\frac{128 - 64}{128} = \\frac{64}{128} = 0.5$$\nThe expected number of misses for the private region is:\n$$N_{\\text{miss, 2M}} = N_{\\text{ref, 2M}} \\times m_{2\\mathrm{M}} = (2.4 \\times 10^6) \\times 0.5 = 1,200,000$$\n\nAnalysis for the shared region (using 4 KB pages):\nThe fraction of references to the shared region is $1 - p = 0.2$. The number of references is:\n$$N_{\\text{ref, 4K}} = N_{\\text{ref}} \\times (1 - p) = (3.0 \\times 10^6) \\times 0.2 = 600,000$$\nThe size of the shared region is $S_{4\\mathrm{K}} = 4 \\text{ MB}$. Under the secure policy, this region is mapped using $4 \\text{ KB}$ pages, so $P_{4\\mathrm{K}} = 4 \\text{ KB}$. The number of unique pages in this region's working set is:\n$$W_{4\\mathrm{K}} = \\frac{S_{4\\mathrm{K}}}{P_{4\\mathrm{K}}} = \\frac{4 \\text{ MB}}{4 \\text{ KB}} = \\frac{4 \\times 1024 \\text{ KB}}{4 \\text{ KB}} = 1024 \\text{ pages}$$\nThe DTLB provides $E_{4\\mathrm{K}} = 256$ entries for $4 \\text{ KB}$ pages. Here again, the working set size ($W_{4\\mathrm{K}} = 1024$) exceeds the DTLB capacity ($E_{4\\mathrm{K}} = 256$).\nUsing the same miss rate model, the miss rate for the shared region is:\n$$m_{4\\mathrm{K}} = \\frac{W_{4\\mathrm{K}} - E_{4\\mathrm{K}}}{W_{4\\mathrm{K}}} = \\frac{1024 - 256}{1024} = \\frac{768}{1024} = 0.75$$\nThe expected number of misses for the shared region is:\n$$N_{\\text{miss, 4K}} = N_{\\text{ref, 4K}} \\times m_{4\\mathrm{K}} = 600,000 \\times 0.75 = 450,000$$\n\nFinally, the total expected number of DTLB misses per 1 ms slice is the sum of the misses from both regions:\n$$N_{\\text{miss}} = N_{\\text{miss, 2M}} + N_{\\text{miss, 4K}} = 1,200,000 + 450,000 = 1,650,000$$\nThe problem requires the answer to be rounded to 4 significant figures. The result is $1,650,000$, which can be written in scientific notation as $1.650 \\times 10^6$.",
            "answer": "$$\\boxed{1.650 \\times 10^{6}}$$"
        }
    ]
}