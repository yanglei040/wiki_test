{
    "hands_on_practices": [
        {
            "introduction": "上下文切换并非没有代价；它会产生可量化的时间开销，直接影响系统性能。本练习将引导你将总切换延迟分解为其主要组成部分：保存和恢复寄存器状态的内存操作时间，以及处理器流水线刷新和内存管理单元（MMU）重新配置等内部停顿时间。通过亲手计算这一总开销，你将对现代处理器中上下文切换所涉及的底层操作及其时间成本建立一个具体而量化的认识 。",
            "id": "3629511",
            "problem": "一个单线程微内核在中央处理器（CPU）上执行两个用户进程之间的上下文切换。一次上下文切换需要将当前的体系结构状态保存到内存中，然后再将其恢复。对于该处理器，体系结构状态包括 $M$ 个通用寄存器，$V$ 个向量寄存器和 $F$ 个浮点寄存器。这些寄存器的宽度是固定的：每个通用寄存器为 $8$ 字节，每个向量寄存器为 $32$ 字节，每个浮点寄存器为 $16$ 字节。内存管理单元（MMU）在每次切换时都会重新配置，产生一个以时钟周期为单位的固定停顿。\n\n一份性能研究报告指出，当内核在保存和恢复期间使用流式存储和加载时，持续内存带宽为 $BW$ 字节/秒，并报告CPU时钟频率为 $f$ 周期/秒。在上下文切换期间，CPU的流水线必须清空一次，这会导致一个以时钟周期为单位的停顿。同样，存在一次以时钟周期为单位的MMU上下文变更停顿。假设如下：\n- 保存寄存器状态会将整个体系结构寄存器组写入内存，而恢复则会使用饱和测量带宽的流式访问方式读回相同数量的数据。\n- 保存和恢复阶段彼此不重叠，也与流水线清空或MMU停顿不重叠。\n- 忽略指定寄存器之外的任何额外微体系结构状态。\n- 将流水线清空停顿和MMU停顿视为固定的时钟周期数，必须使用CPU频率将其转换为时间。\n\n给定参数 $M=32$，$V=32$，$F=32$，$BW=20 \\times 10^{9}$，$f=3.2 \\times 10^{9}$，流水线清空停顿为 $160$ 个周期，MMU停顿为 $800$ 个周期，计算总的上下文切换延迟。将您的最终答案四舍五入到四位有效数字。以微秒为单位表示您的最终延迟。",
            "solution": "问题陈述为计算上下文切换延迟提供了一个清晰、自洽且有科学依据的模型。所有参数都定义明确，并且这些假设在计算机体系结构领域内构成了一个适定问题。所提供的寄存器数量、大小、时钟频率和内存带宽值对于现代高性能计算系统是符合实际的。因此，该问题被认为是有效的，并且可以推导出解决方案。\n\n一次上下文切换的总延迟 $T_{total}$ 是其顺序执行的各个部分延迟的总和。根据问题规定，这些部分是：将体系结构状态保存到内存的时间（$T_{save}$），从内存恢复状态的时间（$T_{restore}$），流水线清空停顿的时间代价（$T_{flush}$），以及内存管理单元（MMU）重新配置停顿的时间代价（$T_{mmu}$）。\n\n$$T_{total} = T_{save} + T_{restore} + T_{flush} + T_{mmu}$$\n\n首先，我们计算必须传入和传出内存的体系结构状态的总大小 $S_{state}$。该状态由 $M$ 个通用寄存器，$V$ 个向量寄存器和 $F$ 个浮点寄存器组成。\n\n通用寄存器文件的大小是寄存器数量 $M$ 乘以其宽度 $W_{GPR} = 8$ 字节。\n$$S_{GPR} = M \\times W_{GPR}$$\n向量寄存器文件的大小是寄存器数量 $V$ 乘以其宽度 $W_{VR} = 32$ 字节。\n$$S_{VR} = V \\times W_{VR}$$\n浮点寄存器文件的大小是寄存器数量 $F$ 乘以其宽度 $W_{FPR} = 16$ 字节。\n$$S_{FPR} = F \\times W_{FPR}$$\n\n总的状态大小是这些部分的总和：\n$$S_{state} = S_{GPR} + S_{VR} + S_{FPR} = M \\cdot W_{GPR} + V \\cdot W_{VR} + F \\cdot W_{FPR}$$\n\n代入给定值 $M=32$，$V=32$ 和 $F=32$：\n$$S_{state} = (32 \\times 8) + (32 \\times 32) + (32 \\times 16) \\text{ bytes}$$\n$$S_{state} = 256 + 1024 + 512 \\text{ bytes}$$\n$$S_{state} = 1792 \\text{ bytes}$$\n\n接下来，我们计算内存操作所需的时间。问题陈述，上下文保存操作向内存写入 $S_{state}$ 字节，恢复操作从内存读出 $S_{state}$ 字节，两者都以持续带宽 $BW$ 进行。\n$$T_{save} = \\frac{S_{state}}{BW}$$\n$$T_{restore} = \\frac{S_{state}}{BW}$$\n内存操作的总时间为：\n$$T_{mem} = T_{save} + T_{restore} = \\frac{2 \\cdot S_{state}}{BW}$$\n\n使用给定值 $BW = 20 \\times 10^{9}$ 字节/秒和计算出的 $S_{state}$：\n$$T_{mem} = \\frac{2 \\times 1792}{20 \\times 10^{9}} \\text{ seconds} = \\frac{3584}{20 \\times 10^{9}} \\text{ seconds} = 179.2 \\times 10^{-9} \\text{ seconds}$$\n\n现在，我们计算CPU停顿引起的时间代价。停顿以时钟周期给出，必须使用CPU频率 $f$ 转换为时间。单个时钟周期的时间是 $T_{cycle} = 1/f$。\n流水线清空停顿为 $C_{flush} = 160$ 个周期。相关的时间代价是：\n$$T_{flush} = C_{flush} \\times T_{cycle} = \\frac{C_{flush}}{f}$$\nMMU重新配置停顿为 $C_{mmu} = 800$ 个周期。相关的时间代价是：\n$$T_{mmu} = C_{mmu} \\times T_{cycle} = \\frac{C_{mmu}}{f}$$\n\n使用给定值 $f = 3.2 \\times 10^{9}$ 周期/秒 (Hz)：\n$$T_{flush} = \\frac{160}{3.2 \\times 10^{9}} \\text{ seconds} = 50 \\times 10^{-9} \\text{ seconds}$$\n$$T_{mmu} = \\frac{800}{3.2 \\times 10^{9}} \\text{ seconds} = 250 \\times 10^{-9} \\text{ seconds}$$\n\n最后，我们将所有时间部分相加，以求得总的上下文切换延迟：\n$$T_{total} = T_{mem} + T_{flush} + T_{mmu}$$\n$$T_{total} = (179.2 \\times 10^{-9}) + (50 \\times 10^{-9}) + (250 \\times 10^{-9}) \\text{ seconds}$$\n$$T_{total} = (179.2 + 50 + 250) \\times 10^{-9} \\text{ seconds}$$\n$$T_{total} = 479.2 \\times 10^{-9} \\text{ seconds}$$\n\n问题要求最终答案以微秒 ($\\mu s$) 表示，并四舍五入到四位有效数字。\n$1 \\mu s = 10^{-6} s$.\n要将秒转换为微秒，我们乘以 $10^{6}$。\n$$T_{total} = 479.2 \\times 10^{-9} \\times 10^{6} \\mu s = 479.2 \\times 10^{-3} \\mu s = 0.4792 \\mu s$$\n值 $0.4792$ 正好有四位有效数字（$4$，$7$，$9$，$2$），因此不需要进一步的四舍五入。",
            "answer": "$$\\boxed{0.4792}$$"
        },
        {
            "introduction": "在理解了上下文切换的基本成本之后，我们将探讨一个更深层次的问题：并非所有上下文切换的开销都相同。此练习区分了重量级的进程切换和轻量级的线程切换，重点分析了管理独立地址空间（如切换页表和刷新翻译后备缓冲器 TLB）所带来的额外开销。通过计算一个“收支平衡”的时间片长度，你将能够量化这种开销差异，并理解其在并发编程和操作系统调度策略选择中的重要意义 。",
            "id": "3629564",
            "problem": "一个单处理器系统对 $N$ 个可运行的任务采用轮询调度算法，这些任务都具有固定的时间量 $Q$、都是计算密集型任务，并且从不主动阻塞。一次上下文切换会引入纯粹的开销，并假设在连续的时间片之间恰好发生一次；首次调度的成本可以忽略不计。当任务作为独立的进程实现时，上下文切换时间模型为 $t_{cs}^{proc} = t_{regs} + t_{pt} + t_{TLB}$，其中 $t_{regs}$ 是保存和恢复通用寄存器的时间，$t_{pt}$ 是切换活动页表的时间，而 $t_{TLB}$ 是刷新和重填转换旁路缓冲（TLB）的时间。当任务作为同一地址空间内的线程实现时，上下文切换时间模型为 $t_{cs}^{thread} = t_{regs}$。假设除了这些时间所包含的内容外，没有其他开销，也没有缓存效应。\n\n仅使用以下基本依据：根据定义，完成一系列调度时间片的墙上时钟时间等于有效执行时间与操作系统开销（如上下文切换）之和；在轮询调度中，一个完整的轮询包含 $N$ 个时间量和 $N$ 次上下文切换（忽略首次调度）。\n\n定义盈亏平衡时间量 $Q_{b}$ 为 $Q$ 的值，在该值下，对于一个包含 $N$ 个时间片的完整轮询，使用进程而非线程所产生的额外墙上时钟时间恰好等于一个有效执行时间的时间量 $Q$。\n\n给定 $N = 16$，$t_{regs} = 1.2\\,\\mu\\text{s}$，$t_{pt} = 2.8\\,\\mu\\text{s}$ 和 $t_{TLB} = 3.5\\,\\mu\\text{s}$，计算 $Q_{b}$ 并以微秒为单位表示你的答案。将答案四舍五入到 $4$ 位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学性、良定性和客观性。\n\n**步骤1：提取已知条件**\n- 调度算法：轮询\n- 时间量：$Q$\n- 可运行任务数量：$N$\n- 任务行为：计算密集型，从不主动阻塞\n- 上下文切换频率：在连续的时间片之间恰好一次\n- 进程的上下文切换时间：$t_{cs}^{proc} = t_{regs} + t_{pt} + t_{TLB}$\n- 线程的上下文切换时间：$t_{cs}^{thread} = t_{regs}$\n- 墙上时钟时间的定义：有效执行时间与操作系统开销之和\n- 一个完整轮询的定义：$N$ 个时间量和 $N$ 次上下文切换\n- 盈亏平衡时间量 $Q_{b}$ 的定义：$Q$ 的值，在该值下，在一个完整轮询中，使用进程而非线程所产生的额外墙上时钟时间恰好等于一个时间量 $Q$。\n- 给定的数值：$N = 16$，$t_{regs} = 1.2\\,\\mu\\text{s}$，$t_{pt} = 2.8\\,\\mu\\text{s}$，以及 $t_{TLB} = 3.5\\,\\mu\\text{s}$。\n\n**步骤2：使用提取的已知条件进行验证**\n问题被认定为有效。\n- 它在科学上基于操作系统和计算机体系结构的原理，特别是关于进程/线程上下文切换和调度开销。所提供的 $t_{cs}^{proc}$ 和 $t_{cs}^{thread}$ 模型准确地反映了开销上的根本差异，即为进程管理独立的地址空间。\n- 它是良定的。盈亏平衡时间量 $Q_b$ 的定义提供了一个清晰明确的条件，可以形式化为一个可解的方程。所有必要的参数都已提供。\n- 它是客观的，并使用了精确、正式的语言。\n- 问题是自洽的，提供的数据是一致的。所做的简化（例如，忽略 TLB 模型之外的缓存效应，固定的上下文切换时间）被明确说明，并且是此类分析的标准做法。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解答。\n\n**求解过程**\n目标是计算盈亏平衡时间量 $Q_{b}$。我们首先根据所提供的定义，为进程和线程两种情况，形式化一个完整调度轮询的总墙上时钟时间。\n\n设 $T_{round}^{proc}$ 为当任务作为进程实现时，完成一个完整轮询的总墙上时钟时间。根据问题陈述，一个完整轮询包含 $N$ 个时间量的有效执行和 $N$ 次上下文切换。\n一个轮询中的总有效执行时间是 $N$ 个时间量持续时间之和，即 $N \\cdot Q$。\n一个轮询中由上下文切换产生的总开销是进程上下文切换时间的 $N$ 倍，即 $N \\cdot t_{cs}^{proc}$。\n因此，总墙上时钟时间为：\n$$T_{round}^{proc} = N \\cdot Q + N \\cdot t_{cs}^{proc}$$\n代入给定的 $t_{cs}^{proc}$ 模型：\n$$T_{round}^{proc} = N \\cdot Q + N \\cdot (t_{regs} + t_{pt} + t_{TLB})$$\n\n类似地，设 $T_{round}^{thread}$ 为当任务作为线程实现时，一个完整轮询的总墙上时钟时间。有效执行时间仍为 $N \\cdot Q$。现在的开销基于线程上下文切换时间 $t_{cs}^{thread}$。\n$$T_{round}^{thread} = N \\cdot Q + N \\cdot t_{cs}^{thread}$$\n代入给定的 $t_{cs}^{thread}$ 模型：\n$$T_{round}^{thread} = N \\cdot Q + N \\cdot t_{regs}$$\n\n问题基于“使用进程而非线程所产生的额外墙上时钟时间”来定义盈亏平衡时间量 $Q_b$。这个额外的时间，我们称之为 $\\Delta T_{overhead}$，是进程和线程的总轮询时间之差。\n$$\\Delta T_{overhead} = T_{round}^{proc} - T_{round}^{thread}$$\n代入上面推导出的表达式：\n$$\\Delta T_{overhead} = [N \\cdot Q + N \\cdot (t_{regs} + t_{pt} + t_{TLB})] - [N \\cdot Q + N \\cdot t_{regs}]$$\n$N \\cdot Q$ 和 $N \\cdot t_{regs}$ 项相互抵消：\n$$\\Delta T_{overhead} = N \\cdot (t_{pt} + t_{TLB})$$\n这个结果是合乎逻辑的：在此模型中，使用进程相对于线程的额外开销完全来自于管理页表和 TLB 的每次切换成本，而这些成本在同一进程内的线程切换中是不需要的。\n\n盈亏平衡时间量 $Q_b$ 被定义为特定 $Q$ 值，在该值下，这个额外的开销时间恰好等于一个时间量。\n$$Q_b = \\Delta T_{overhead}$$\n因此，我们得到 $Q_b$ 的确定方程：\n$$Q_b = N \\cdot (t_{pt} + t_{TLB})$$\n\n现在，我们代入给定的数值来计算 $Q_b$ 的值。\n已知：\n- $N = 16$\n- $t_{pt} = 2.8\\,\\mu\\text{s}$\n- $t_{TLB} = 3.5\\,\\mu\\text{s}$\n\n页表和 TLB 开销之和为：\n$$t_{pt} + t_{TLB} = 2.8\\,\\mu\\text{s} + 3.5\\,\\mu\\text{s} = 6.3\\,\\mu\\text{s}$$\n现在，我们计算 $Q_b$：\n$$Q_b = 16 \\cdot (6.3\\,\\mu\\text{s})$$\n$$Q_b = 100.8\\,\\mu\\text{s}$$\n\n问题要求将答案四舍五入到 $4$ 位有效数字。计算出的值 $100.8$ 已经恰好包含四位有效数字（$1$、$0$、$0$、$8$）。因此，无需进一步四舍五入。结果的单位是微秒，符合要求。",
            "answer": "$$\\boxed{100.8}$$"
        },
        {
            "introduction": "既然我们已经了解了上下文切换的成本及其变化，自然会问：如何才能降低这些成本？本练习介绍了一种高级优化技术：“惰性”上下文切换。我们将分析一个仅在需要时才保存和恢复浮点单元（FPU）状态的场景，并运用概率论来评估其相对于“主动”切换策略的性能权衡。这个练习揭示了现代操作系统为提高效率而采用的巧妙策略，展示了在真实世界系统中如何通过概率性分析来优化性能 。",
            "id": "3629517",
            "problem": "一个单核处理器执行一个轮询调度器，该调度器每隔一个固定的时间量子抢占正在运行的任务。该处理器实现了一种惰性浮点单元（FPU）上下文切换机制：在每次上下文切换时，操作系统（OS）会设置任务切换标志，从而使得下一个任务执行的第一条FPU指令会引发一个设备不可用（$\\#NM$）陷阱。在陷阱处理程序中，操作系统保存前一个任务的FPU状态并恢复当前任务的FPU状态，然后继续执行。假设系统处于稳定状态，任何使用FPU的任务都有一个先前已保存且必须恢复的FPU状态。\n\n假设有以下参数：\n- 处理器频率 $f = 3.2 \\times 10^{9}$ 周期/秒。\n- 时间量子 $\\tau = 2 \\times 10^{-3}$ 秒（因此在稳定状态下，每 $\\tau$ 秒发生一次上下文切换）。\n- 保存FPU状态的成本 $S = 500$ 周期，恢复FPU状态的成本 $R = 500$ 周期。\n- 处理 $\\#NM$ 陷阱的成本（进入、处理程序簿记和返回） $H = 300$ 周期。\n- 令 $p$ 表示在一个给定的时间量子内，被调度的任务至少执行一条FPU指令的概率。\n\n对于一个基准的“积极”FPU切换方案，操作系统在每次上下文切换时总是保存和恢复FPU状态，每次切换确定性地产生 $S+R$ 的成本。对于惰性方案，与FPU相关的开销仅在任务在该时间量子内使用FPU时发生（概率为 $p$），在这种情况下会触发陷阱，并在处理程序中执行保存和恢复操作。\n\n仅使用上下文切换成本的基本定义、概率论中期望值的定义以及给定的参数，推导出惰性方案相对于积极方案每秒产生的预期额外时间，并将其表示为 $p$ 的函数。然后，在 $p \\to 1$（即 $p = 1$）的最坏情况下评估这个额外时间。将你的最终结果以微秒/秒表示，并四舍五入到四位有效数字。",
            "solution": "用户要求分析FPU上下文切换的开销，比较惰性方案和积极方案，并为此计算提供了一组参数。\n\n### 步骤 1：问题验证\n\n首先，我必须验证问题陈述。\n\n**提取的已知条件：**\n- 处理器频率：$f = 3.2 \\times 10^{9}$ 周期/秒。\n- 时间量子：$\\tau = 2 \\times 10^{-3}$ 秒。\n- 保存FPU状态的成本：$S = 500$ 周期。\n- 恢复FPU状态的成本：$R = 500$ 周期。\n- 处理 $\\#NM$ 陷阱的成本：$H = 300$ 周期。\n- 一个时间量子内包含至少一条FPU指令的概率：$p$。\n- **积极方案：** FPU状态总是被保存和恢复。每次上下文切换的开销成本是 $S+R$。\n- **惰性方案：** FPU开销仅在发生 $\\#NM$ 陷阱后产生，其发生概率为 $p$。在这种情况下，开销成本为 $H+S+R$。\n- **假设：** 系统处于稳定状态。每 $\\tau$ 秒发生一次上下文切换。\n- **目标：** 推导惰性方案相对于积极方案每秒产生的预期额外时间，作为 $p$ 的函数，然后在最坏情况 $p=1$ 时评估此时间。最终结果必须以微秒/秒为单位，并四舍五入到四位有效数字。\n\n**验证结论：**\n该问题在科学和技术上是合理的。它描述了操作系统和计算机体系结构中的一种标准优化技术（惰性上下文切换）。术语（上下文切换、时间量子、陷阱、FPU）和参数与该领域一致。问题提取得当，提供了推导唯一、有意义解所需的所有信息。问题是客观的，没有歧义或事实错误。因此，该问题是**有效的**。\n\n### 步骤 2：推导与求解\n\n问题要求计算惰性和积极FPU上下文切换方案之间每秒的时间开销差异。\n\n每秒的上下文切换次数 $N_{cs}$ 由时间量子 $\\tau$ 决定：\n$$N_{cs} = \\frac{1}{\\tau}$$\n\n设 $T_{cycle}$ 为单个处理器周期的持续时间。\n$$T_{cycle} = \\frac{1}{f}$$\n\n**积极方案分析：**\n在积极方案中，FPU上下文在每次上下文切换时都会被保存和恢复。每次上下文切换的成本（以周期计），$C_{eager}$，是确定性的。\n$$C_{eager} = S + R$$\n积极方案每秒的总时间开销 $T_{eager/sec}$ 是每次切换的周期成本乘以每秒的切换次数，再转换为时间。\n$$T_{eager/sec} = C_{eager} \\cdot N_{cs} \\cdot T_{cycle} = (S+R) \\cdot \\frac{1}{\\tau} \\cdot \\frac{1}{f} = \\frac{S+R}{f\\tau}$$\n\n**惰性方案分析：**\n在惰性方案中，开销取决于被调度的任务是否执行FPU指令。每次上下文切换的成本 $C_{lazy}$ 是一个随机变量。\n- 任务使用FPU的概率为 $p$。发生 $\\#NM$ 陷阱，FPU状态在处理程序中被保存和恢复。成本为 $H+S+R$ 周期。\n- 任务不使用FPU的概率为 $1-p$。不发生陷阱。与FPU相关的开销为 $0$ 周期。\n\n惰性方案每次上下文切换的预期成本（以周期计），$E[C_{lazy}]$，由期望值的定义给出：\n$$E[C_{lazy}] = p \\cdot (H + S + R) + (1-p) \\cdot 0 = p(H+S+R)$$\n惰性方案每秒的预期总时间开销 $E[T_{lazy/sec}]$ 为：\n$$E[T_{lazy/sec}] = E[C_{lazy}] \\cdot N_{cs} \\cdot T_{cycle} = p(H+S+R) \\cdot \\frac{1}{\\tau} \\cdot \\frac{1}{f} = \\frac{p(H+S+R)}{f\\tau}$$\n\n**相对额外时间：**\n惰性方案相对于积极方案每秒的预期额外时间 $\\Delta T_{sec}$ 是它们各自每秒时间开销的差值。\n$$\\Delta T_{sec}(p) = E[T_{lazy/sec}] - T_{eager/sec}$$\n$$\\Delta T_{sec}(p) = \\frac{p(H+S+R)}{f\\tau} - \\frac{S+R}{f\\tau}$$\n$$\\Delta T_{sec}(p) = \\frac{p(H+S+R) - (S+R)}{f\\tau}$$\n这是关于 $p$ 的通用表达式。\n\n**最坏情况评估 ($p=1$)：**\n问题要求在最坏情况 $p \\to 1$ 下进行评估。我们设置 $p=1$。\n$$\\Delta T_{sec}(1) = \\frac{1 \\cdot (H+S+R) - (S+R)}{f\\tau}$$\n$$\\Delta T_{sec}(1) = \\frac{H+S+R-S-R}{f\\tau}$$\n$$\\Delta T_{sec}(1) = \\frac{H}{f\\tau}$$\n这个结果是直观的：当 $p=1$ 时，两种方案在每次上下文切换时都执行保存和恢复操作，但惰性方案每次还会产生额外的陷阱处理程序开销 $H$。\n\n**数值计算：**\n现在，我们将给定值代入推导出的 $\\Delta T_{sec}(1)$ 表达式中。\n- $H = 300$ 周期\n- $f = 3.2 \\times 10^{9}$ 周期/秒\n- $\\tau = 2 \\times 10^{-3}$ 秒\n\n$$\\Delta T_{sec}(1) = \\frac{300}{(3.2 \\times 10^{9}) \\cdot (2 \\times 10^{-3})} = \\frac{300}{6.4 \\times 10^{6}} \\text{ s/s}$$\n$$\\Delta T_{sec}(1) = \\frac{300}{6.4} \\times 10^{-6} = 46.875 \\times 10^{-6} \\text{ s/s}$$\n结果是一个无量纲的量，表示每秒操作中的开销秒数。问题要求该值以“微秒/秒”为单位。我们将时间单位从秒转换为微秒（$1 \\text{ s} = 10^6 \\mu \\text{s}$）。\n\n$$\\Delta T_{\\mu s/s} = (46.875 \\times 10^{-6} \\text{ s}) \\times \\frac{10^6 \\mu \\text{s}}{1 \\text{ s}} = 46.875 \\mu \\text{s}$$\n因此，额外开销为每秒 $46.875$ 微秒。\n\n最后，将结果四舍五入到四位有效数字得到：\n$$46.88$$\n单位是每秒操作的微秒数。",
            "answer": "$$\\boxed{46.88}$$"
        }
    ]
}