{
    "hands_on_practices": [
        {
            "introduction": "At the heart of reconfigurable computing is the ability to create custom arithmetic circuits tailored to a specific application's needs. This often involves moving beyond standard, exact arithmetic. This practice explores the concept of approximate computing, where perfect numerical accuracy is strategically sacrificed to gain significant improvements in power efficiency or performance, a vital technique in energy-constrained applications like mobile computing and IoT devices. By modeling and comparing an exact adder to an approximate one, you will gain hands-on experience in quantifying the critical trade-off between error rate and hardware resource savings, a core skill in designing specialized accelerators on FPGAs. ",
            "id": "3671123",
            "problem": "You are implementing and evaluating an approximate arithmetic unit for reconfigurable logic in a Field-Programmable Gate Array (FPGA). The unit is a parameterized $N$-bit adder with two variants: (i) an exact ripple-carry adder, and (ii) a Lower-Part OR Adder (LOA), which computes the lower $K$ sum bits using bitwise logical OR and uses a single-bit carry prediction into the upper exact part. Your task is to write a complete, runnable program that, for a given set of $(N, K)$ parameters, quantifies the error rate and the normalized dynamic power savings of the LOA relative to the exact adder.\n\nFundamental base and definitions:\n- Boolean algebra for bitwise operations applies to signals $x_i \\in \\{0,1\\}$.\n- Complementary Metal–Oxide–Semiconductor (CMOS) dynamic power is governed by $P_{\\text{dyn}} = \\alpha C V^2 f$, where $\\alpha$ is the average switching activity per clock, $C$ is effective switched capacitance, $V$ is supply voltage, and $f$ is the clock frequency.\n- The exact adder is a standard $N$-bit ripple-carry adder constructed from bit-wise full adders with carry-in $c_i$ and carry-out $c_{i+1}$, where $c_0 = 0$ and the final sum is taken modulo $2^N$.\n- The Lower-Part OR Adder (LOA) computes the lower $K$ bits as $s_i = x_i \\lor y_i$ for $0 \\le i \\le K-1$. It predicts the carry-in to the upper exact part as $c_K = x_{K-1} \\land y_{K-1}$ when $K \\ge 1$; if $K = 0$, then $c_0 = 0$. The upper bits $i \\ge K$ are computed by an exact ripple-carry full adder chain starting from $c_K$. When $K = N$, there is no upper exact part.\n\nDynamic power proxy model:\n- Treat $V$ and $f$ as equal between designs, so relative dynamic power reduces to proportionality $P \\propto \\sum \\alpha_j C_j$ over gate outputs $j$.\n- Use normalized effective capacitance weights reflecting typical CMOS gate complexity: $\\text{XOR}$ has weight $4$, $\\text{AND}$ has weight $2$, and $\\text{OR}$ has weight $2$. These weights act as $C_j$ multipliers per gate output to reflect relative transistor counts and loads at advanced-undergraduate fidelity.\n- For the exact ripple-carry adder, at each bit $i$, consider the following gate-output nodes: $t_i = x_i \\oplus y_i$ ($\\text{XOR}$), $s_i = t_i \\oplus c_i$ ($\\text{XOR}$), $g_i = x_i \\land y_i$ ($\\text{AND}$), $m_i = t_i \\land c_i$ ($\\text{AND}$), and $c_{i+1} = g_i \\lor m_i$ ($\\text{OR}$). For the LOA lower part ($i < K$), only $s_i = x_i \\lor y_i$ ($\\text{OR}$) is present; for the LOA carry prediction, include $c_K^{\\text{pred}} = x_{K-1} \\land y_{K-1}$ ($\\text{AND}$) when $0 < K < N$; for the LOA upper part ($i \\ge K$), use the same exact nodes as above but with carry starting from $c_K^{\\text{pred}}$.\n\nError rate definition:\n- Enumerate all input pairs $(x, y)$ with $x, y \\in \\{0, 1, \\dots, 2^N - 1\\}$ and define the exact sum $S_{\\text{exact}} = (x + y) \\bmod 2^N$ and the LOA sum $S_{\\text{LOA}}$ from the bit-level construction described above. The error rate is the fraction of pairs for which $S_{\\text{LOA}} \\ne S_{\\text{exact}}$. Express it as a decimal fraction.\n\nPower savings definition:\n- Assume successive additions observe independent and identically distributed inputs with each bit independently and uniformly random. For any gate output node $j$, empirically estimate the stationary probability $p_j$ that the node equals $1$ by enumerating across all $(x, y)$. From $p_j$ and independence across additions, derive the expected per-cycle switching activity $\\alpha_j$ for node $j$, and then compute the total dynamic power proxy $P$ as the sum over nodes of $\\alpha_j$ times the gate-type weight. Compute this separately for the exact adder ($P_{\\text{exact}}$) and the LOA ($P_{\\text{LOA}}$). The normalized dynamic power savings is $(P_{\\text{exact}} - P_{\\text{LOA}})/P_{\\text{exact}}$, expressed as a decimal fraction.\n\nProgram requirements:\n- Implement both adders for general $(N, K)$ under the above behavioral definitions. All arithmetic is modulo $2^N$. Use the described gate-output nodes for the power proxy of each design.\n- Enumerate all $(x, y)$ pairs to compute the error rate and the empirical $p_j$ of every gate-output node required for each design. From these, derive per-node $\\alpha_j$ and aggregate $P_{\\text{exact}}$ and $P_{\\text{LOA}}$ under the given weights.\n- No user input is allowed; the program must run as-is and print only the final results line.\n\nTest suite:\n- Use the following $(N, K)$ pairs:\n    1. $N = 8$, $K = 4$ (typical LOA partition).\n    2. $N = 8$, $K = 0$ (boundary condition: LOA reduces to exact adder).\n    3. $N = 8$, $K = 8$ (boundary condition: fully approximate lower part with no exact upper part).\n    4. $N = 6$, $K = 2$ (smaller width to check scaling).\n\nFinal output format:\n- Your program should produce a single line of output containing a list of per-test-case results, each as a two-element list $[e, s]$ where $e$ is the error rate and $s$ is the normalized dynamic power savings. The overall output must be a comma-separated list of these pairs enclosed in square brackets, for example: $[[e_1,s_1],[e_2,s_2],[e_3,s_3],[e_4,s_4]]$. Print decimal values. No additional text may be printed.",
            "solution": "The problem has been analyzed and validated as a well-posed, scientifically-grounded computational exercise in digital logic design and computer architecture. It contains sufficient information and clear, consistent definitions to permit a unique solution. The task is to quantify the error rate and power savings of a Lower-Part OR Adder (LOA) relative to an exact ripple-carry adder (RCA) for specified bit-widths $N$ and approximate-part widths $K$.\n\nThe methodology to solve this problem involves two main computational stages for each $(N, K)$ pair: calculating the error rate and modeling the power consumption. Both stages require an exhaustive enumeration of all possible input pairs $(x, y)$, where $x, y \\in \\{0, 1, \\dots, 2^N - 1\\}$. The total number of such pairs is $(2^N)^2 = 2^{2N}$.\n\n### Error Rate Calculation\nThe error rate is the fraction of input pairs for which the output of the LOA, $S_{\\text{LOA}}$, differs from the output of the exact adder, $S_{\\text{exact}}$.\n\n1.  **Exact Sum**: The exact sum is computed as $S_{\\text{exact}} = (x + y) \\pmod{2^N}$. This is standard integer addition with overflow ignored.\n\n2.  **LOA Sum, $S_{\\text{LOA}}$**: The LOA sum is constructed bit-by-bit according to its definition.\n    - For the lower $K$ bits ($i \\in [0, K-1]$), the sum bit $s_i$ is computed as a bitwise OR: $s_i = x_i \\lor y_i$.\n    - A predicted carry-in to the upper part, $c_K$, is generated. If $K=0$, $c_0=0$. If $K > 0$, $c_K = x_{K-1} \\land y_{K-1}$. This prediction is only relevant for the power model if $0 < K < N$.\n    - For the upper $N-K$ bits ($i \\in [K, N-1]$), a standard ripple-carry addition is performed, starting with the carry-in $c_K$.\n\n3.  **Enumeration**: A counter is initialized to $0$. We iterate through all $2^{2N}$ pairs of $(x, y)$. In each iteration, we compute $S_{\\text{exact}}$ and $S_{\\text{LOA}}$. If $S_{\\text{LOA}} \\neq S_{\\text{exact}}$, the counter is incremented.\n\n4.  **Final Rate**: The error rate $e$ is the final counter value divided by the total number of pairs, $2^{2N}$.\n\n### Normalized Dynamic Power Savings Calculation\nThe power savings are determined using a proxy model for dynamic power, $P \\propto \\sum_j \\alpha_j C_j$, where $\\alpha_j$ is the switching activity of a gate output node $j$ and $C_j$ is its effective capacitance weight.\n\n1.  **Switching Activity, $\\alpha_j$**: Assuming statistically independent and uniformly random inputs between clock cycles, the switching activity of a node $j$ is given by $\\alpha_j = 2p_j(1 - p_j)$, where $p_j$ is the stationary probability that the node's output is $1$.\n\n2.  **Stationary Probability, $p_j$**: The probability $p_j$ is estimated empirically. For each of the $2^{2N}$ input pairs $(x,y)$, we simulate the gate-level logic of the adder and determine the binary value of each internal node $j$. A counter for each node, `count_j`, is incremented if its output is $1$. After the enumeration, $p_j = \\text{count}_j / 2^{2N}$.\n\n3.  **Gate-Level Node Simulation**:\n    - **Exact RCA**: For each bit slice $i \\in [0, N-1]$, the following $5$ gate outputs are monitored:\n        - $t_i = x_i \\oplus y_i$ (Weight $C=4$)\n        - $g_i = x_i \\land y_i$ (Weight $C=2$)\n        - $s_i = t_i \\oplus c_i$ (Weight $C=4$), where $c_i$ is the carry from bit $i-1$.\n        - $m_i = t_i \\land c_i$ (Weight $C=2$)\n        - $c_{i+1} = g_i \\lor m_i$ (Weight $C=2$)\n    - **LOA**: The set of monitored nodes depends on $K$.\n        - For the lower part ($i \\in [0, K-1]$): $s_i = x_i \\lor y_i$ (Weight $C=2$).\n        - For carry prediction (only if $0 < K < N$): $c_K = x_{K-1} \\land y_{K-1}$ (Weight $C=2$).\n        - For the upper part ($i \\in [K, N-1]$): The same $5$ gate outputs as the exact RCA are monitored, with the ripple-carry chain starting from the predicted carry $c_K$.\n    - The special case $K=0$ makes the LOA identical to the exact RCA. The case $K=N$ results in an adder composed solely of $N$ OR gates, with no upper part or carry prediction logic.\n\n4.  **Total Power Proxy**: The total power for each adder type, $P_{\\text{exact}}$ and $P_{\\text{LOA}}$, is computed by summing the contributions $\\alpha_j C_j$ from all of their respective internal nodes.\n\n5.  **Normalized Savings**: The final metric is calculated as $s = (P_{\\text{exact}} - P_{\\text{LOA}}) / P_{\\text{exact}}$.\n\n### Algorithmic Implementation\nFor each given $(N, K)$ test case, a single procedure executes the entire workflow. It iterates through all $x \\in [0, 2^N-1]$ and $y \\in [0, 2^N-1]$. Inside this nested loop, it performs three actions:\n1.  Computes $S_{\\text{exact}}$ and $S_{\\text{LOA}}$ and updates an error counter.\n2.  Simulates the exact RCA at the gate level and updates probability counters for its internal nodes.\n3.  Simulates the LOA at the gate level (with logic dependent on $K$) and updates its corresponding probability counters.\n\nAfter the loops complete, these counters are used to calculate the final error rate and normalized power savings as described above. The results for all test cases are then collected and printed in the specified format.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int N;\n    int K;\n} TestCase;\n\n// Function to compute the sum using the Lower-Part OR Adder (LOA) logic.\nunsigned int loa_sum(unsigned int x, unsigned int y, int N, int K) {\n    if (K == 0) {\n        // LOA is identical to an exact adder.\n        return (x + y) & ((1U << N) - 1);\n    }\n\n    if (K == N) {\n        // The entire adder is composed of OR gates.\n        return x | y;\n    }\n\n    // Mixed case: 0 < K < N\n    unsigned int lower_mask = (1U << K) - 1;\n    unsigned int lower_sum = (x | y) & lower_mask;\n\n    // Carry prediction to the upper part.\n    unsigned int c_k = ((x >> (K - 1)) & 1U) & ((y >> (K - 1)) & 1U);\n\n    // Exact addition for the upper part.\n    unsigned int upper_x = x >> K;\n    unsigned int upper_y = y >> K;\n    unsigned int upper_N = N - K;\n    \n    unsigned int upper_sum_val = upper_x + upper_y + c_k;\n    unsigned int upper_mask = (1U << upper_N) - 1;\n    unsigned int upper_sum = (upper_sum_val & upper_mask) << K;\n    \n    return lower_sum | upper_sum;\n}\n\n// Main function to calculate error rate and power savings for a given (N, K).\nvoid calculate_metrics(int N, int K, double* error_rate, double* power_savings) {\n    unsigned long long error_count = 0;\n    \n    // Counters for stationary probability (p_j) calculation.\n    // Max nodes for N=8 is 5*8=40. This is sufficient for all cases.\n    unsigned long long p_counts_exact[40] = {0};\n    unsigned long long p_counts_loa[40] = {0};\n\n    unsigned int num_inputs = 1U << N;\n    unsigned long long total_pairs = 1ULL << (2 * N);\n\n    for (unsigned int x = 0; x < num_inputs; ++x) {\n        for (unsigned int y = 0; y < num_inputs; ++y) {\n            // 1. Error Rate Calculation\n            unsigned int s_exact = (x + y) & ((1U << N) - 1);\n            unsigned int s_loa = loa_sum(x, y, N, K);\n            if (s_exact != s_loa) {\n                error_count++;\n            }\n\n            // 2. Power Modeling - Gate-level Simulation\n            // 2a. Exact Ripple-Carry Adder\n            unsigned int c_exact = 0;\n            for (int i = 0; i < N; ++i) {\n                unsigned int xi = (x >> i) & 1U;\n                unsigned int yi = (y >> i) & 1U;\n\n                unsigned int t = xi ^ yi;\n                unsigned int g = xi & yi;\n                unsigned int s = t ^ c_exact;\n                unsigned int m = t & c_exact;\n                unsigned int c_next = g | m;\n\n                p_counts_exact[i * 5 + 0] += t;\n                p_counts_exact[i * 5 + 1] += g;\n                p_counts_exact[i * 5 + 2] += s;\n                p_counts_exact[i * 5 + 3] += m;\n                p_counts_exact[i * 5 + 4] += c_next;\n\n                c_exact = c_next;\n            }\n\n            // 2b. Lower-Part OR Adder\n            unsigned int c_loa = 0;\n            // Lower Part (OR gates)\n            for (int i = 0; i < K; ++i) {\n                unsigned int xi = (x >> i) & 1U;\n                unsigned int yi = (y >> i) & 1U;\n                p_counts_loa[i] += (xi | yi);\n            }\n            \n            // Carry Prediction\n            if (K > 0 && K < N) {\n                unsigned int x_km1 = (x >> (K-1)) & 1U;\n                unsigned int y_km1 = (y >> (K-1)) & 1U;\n                c_loa = x_km1 & y_km1;\n                // Node index for carry prediction is K.\n                p_counts_loa[K] += c_loa;\n            } else if (K == 0) {\n                c_loa = 0; // Boundary condition c_0 = 0\n            }\n            // For K=N, c_loa is not used further.\n\n            // Upper Part (RCA)\n            for (int i = K; i < N; ++i) {\n                unsigned int xi = (x >> i) & 1U;\n                unsigned int yi = (y >> i) & 1U;\n               \n                unsigned int t = xi ^ yi;\n                unsigned int g = xi & yi;\n                unsigned int s = t ^ c_loa;\n                unsigned int m = t & c_loa;\n                unsigned int c_next = g | m;\n                \n                // Node indices for upper part of LOA are offset.\n                // For K=0, this loop is the whole RCA.\n                // For K>0, K lower OR gates + 1 carry pred gate.\n                int offset = (K > 0 && K < N) ? K + 1 : 0;\n                p_counts_loa[offset + (i-K) * 5 + 0] += t;\n                p_counts_loa[offset + (i-K) * 5 + 1] += g;\n                p_counts_loa[offset + (i-K) * 5 + 2] += s;\n                p_counts_loa[offset + (i-K) * 5 + 3] += m;\n                p_counts_loa[offset + (i-K) * 5 + 4] += c_next;\n\n                c_loa = c_next;\n            }\n        }\n    }\n\n    *error_rate = (double)error_count / total_pairs;\n\n    // 3. Aggregate Power Calculation\n    double p_exact_power = 0.0;\n    const int weights_exact[] = {4, 2, 4, 2, 2}; // XOR, AND, XOR, AND, OR\n    for (int i = 0; i < N * 5; ++i) {\n        double p_j = (double)p_counts_exact[i] / total_pairs;\n        double alpha_j = 2.0 * p_j * (1.0 - p_j);\n        p_exact_power += alpha_j * weights_exact[i % 5];\n    }\n\n    double p_loa_power = 0.0;\n    if (K == 0) {\n        p_loa_power = p_exact_power;\n    } else if (K == N) {\n        for (int i = 0; i < K; ++i) {\n            double p_j = (double)p_counts_loa[i] / total_pairs;\n            double alpha_j = 2.0 * p_j * (1.0 - p_j);\n            p_loa_power += alpha_j * 2; // OR gate weight\n        }\n    } else { // 0 < K < N\n        // Lower part ORs\n        for (int i = 0; i < K; ++i) {\n            double p_j = (double)p_counts_loa[i] / total_pairs;\n            double alpha_j = 2.0 * p_j * (1.0 - p_j);\n            p_loa_power += alpha_j * 2; // OR weight\n        }\n        // Carry pred AND\n        double p_j_pred = (double)p_counts_loa[K] / total_pairs;\n        double alpha_j_pred = 2.0 * p_j_pred * (1.0 - p_j_pred);\n        p_loa_power += alpha_j_pred * 2; // AND weight\n\n        // Upper part RCA\n        int offset = K + 1;\n        for (int i = 0; i < (N - K) * 5; ++i) {\n            double p_j = (double)p_counts_loa[offset + i] / total_pairs;\n            double alpha_j = 2.0 * p_j * (1.0 - p_j);\n            p_loa_power += alpha_j * weights_exact[i % 5];\n        }\n    }\n    \n    if (p_exact_power == 0) {\n        *power_savings = 0;\n    } else {\n        *power_savings = (p_exact_power - p_loa_power) / p_exact_power;\n    }\n}\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {8, 4},\n        {8, 0},\n        {8, 8},\n        {6, 2}\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases][2];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        calculate_metrics(test_cases[i].N, test_cases[i].K, &results[i][0], &results[i][1]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement.\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%f,%f]\", results[i][0], results[i][1]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "Real-world FPGA designs are rarely monolithic; they are complex systems built from multiple communicating modules. Ensuring reliable data transfer between these modules is paramount. This exercise focuses on the ubiquitous `valid/ready` handshake protocol, a fundamental mechanism for managing streaming data flow between components that may have varying processing speeds or intermittent stalls. Through a careful, cycle-by-cycle analysis of common implementation errors, you will develop a deep intuition for synchronous interface design and learn to recognize the subtle timing issues that can lead to catastrophic data loss or duplication. ",
            "id": "3671177",
            "problem": "A single-clock synchronous streaming interface on a Field-Programmable Gate Array (FPGA) connects a producer to a consumer using a two-signal handshake: $valid$ from the producer and $ready$ from the consumer. The system clock has period $T$, and all registers sample inputs on the rising edge at times $t_k = kT$ for integer $k \\ge 0$. The standard handshake semantics are: a transfer event occurs exactly on those rising edges $t_k$ such that $valid(t_k) = 1$ and $ready(t_k) = 1$, and the producer must hold the data bus $D$ stable whenever $valid = 1$ and $ready = 0$. Assume $D$ is a register driven by the producer and sampled by the consumer.\n\nConsider a burst of $N = 8$ distinct words $w_i$ with $w_i = i$ for $i \\in \\{0,1,\\dots,7\\}$, in order. The producer asserts $valid(t_k) = 1$ continuously for $k = 1,2,\\dots,8$, i.e., one word is offered per clock cycle across the burst. The consumer deasserts $ready(t_k)$ during a local stall from $k = 3$ through $k = 5$, i.e., $ready(t_k) = 0$ for $k \\in \\{3,4,5\\}$ and $ready(t_k) = 1$ otherwise.\n\nNow analyze two distinct handshake-violation implementations:\n\nCircuit X (producer-side violation): the producer ignores the consumer’s $ready$ entirely (as if $ready$ were always $1$) and updates $D$ to the next $w_i$ on each cycle whenever $valid = 1$, regardless of $ready$.\n\nCircuit Y (consumer-side violation): the producer obeys the correct handshake semantics and holds $D$ constant whenever $valid = 1$ and $ready = 0$, but the consumer’s input register is incorrectly implemented as “if $(valid)$ then sample $D$,” i.e., the consumer samples $D$ on every cycle with $valid = 1$ regardless of $ready$.\n\nUsing the foundational definitions above for synchronous sampling and handshake semantics, determine the observable consequences at the consumer for each circuit. Which statements are correct?\n\nA. In Circuit X, the consumer ultimately stores $w_0, w_1, w_5, w_6, w_7$; the words $w_2, w_3, w_4$ are lost.\n\nB. In Circuit X, no data loss occurs because $valid = 1$ continuously; the consumer will eventually capture all $8$ words.\n\nC. In Circuit Y, duplicates occur: the consumer records the same word multiple times during the stall window because $D$ is held constant while $valid = 1$.\n\nD. In Circuit Y, duplication cannot occur in a synchronous single clock domain; only loss is possible.",
            "solution": "The problem statement will first be validated for scientific soundness, consistency, and completeness.\n\n### Step 1: Extract Givens\n- **System:** A single-clock synchronous streaming interface on an FPGA.\n- **Clocking:** All registers sample inputs on the rising edge of a clock with period `$T$`. Sampling times are `$t_k = kT$` for integer `$k \\ge 0$`.\n- **Handshake Signals:**\n    - `$valid$`: from producer to consumer.\n    - `$ready$`: from consumer to producer.\n- **Standard Handshake Semantics:**\n    - A transfer event occurs on a rising edge `$t_k$` if and only if `$valid(t_k) = 1$` and `$ready(t_k) = 1$`.\n    - The producer must hold the data bus `$D$` stable whenever `$valid = 1$` and `$ready = 0$`.\n- **Data Bus:** `$D$` is a register driven by the producer and sampled by the consumer.\n- **Data Burst:** A sequence of `$N = 8$` distinct words, `$w_i = i$` for `$i \\in \\{0, 1, \\dots, 7\\}$`, transmitted in order.\n- **Producer Timing (`valid` signal):** `$valid(t_k) = 1$` for `$k \\in \\{1, 2, \\dots, 8\\}$`.\n- **Consumer Timing (`ready` signal):** `$ready(t_k) = 0$` for `$k \\in \\{3, 4, 5\\}$` and `$ready(t_k) = 1$` for all other `$k$`.\n- **Circuit X (Producer Violation):** The producer ignores `$ready$`. It updates `$D$` to the next word `$w_i$` on each cycle where `$valid=1$`.\n- **Circuit Y (Consumer Violation):** The producer correctly obeys the handshake protocol. The consumer's input register samples `$D$` on every clock cycle `$k$` for which `$valid(t_k) = 1$`, ignoring `$ready$`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated against the validation criteria.\n- **Scientifically Grounded:** Yes. The problem describes a standard `$valid/ready$` handshake protocol, a fundamental concept in digital logic design, computer architecture, and particularly relevant to FPGA-based systems. The described failure modes (ignoring `$ready$`, incorrect sampling conditions) are common design errors.\n- **Well-Posed:** Yes. The behavior of all signals (`$valid$`, `$ready$`), components (producer, consumer), and data (`$D$`) is explicitly defined for two distinct scenarios (Circuit X and Circuit Y). The initial conditions and signal waveforms are given, allowing for a unique, deterministic outcome to be derived for each circuit.\n- **Objective:** Yes. The language is technical and unambiguous. Terms like \"rising edge,\" \"register,\" \"asserts,\" and \"deasserts\" have precise meanings in this context.\n\nThe problem does not exhibit any of the invalidating flaws:\n1.  **Scientific Unsoundness:** None. It adheres to the principles of synchronous digital logic.\n2.  **Non-Formalizable:** None. The problem is a formal model of digital circuit behavior.\n3.  **Incomplete/Contradictory:** None. The signal timings and behavioral rules are fully specified.\n4.  **Unrealistic:** None. These scenarios represent plausible design bugs.\n5.  **Ill-Posed:** None. A unique solution can be determined by cycle-by-cycle analysis.\n6.  **Trivial/Tautological:** None. The problem requires a careful non-trivial analysis of timing and state.\n7.  **Unverifiable:** None. The described behavior can be modeled and simulated using standard Hardware Description Languages (e.g., Verilog, VHDL).\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. A step-by-step analysis of each circuit will be performed to determine the consequences at the consumer.\n\n### Derivation and Analysis\n\nA cycle-by-cycle analysis is required for both Circuit X and Circuit Y. The relevant time steps are the rising edges at `$t_k$` for `$k \\ge 1$`. The producer attempts to send the sequence `$w_0, w_1, ..., w_7$`. From the problem statement, word `$w_i$` is offered for the first time on cycle `$k=i+1$`.\n\nThe input signal waveforms are:\n- `$valid(t_k) = 1$` for `$k \\in \\{1, 2, 3, 4, 5, 6, 7, 8\\}$`, and `$0$` otherwise.\n- `$ready(t_k) = 1$` for `$k \\in \\{1, 2, 6, 7, 8, \\dots\\}$`, and `$0$` for `$k \\in \\{3, 4, 5\\}$`.\n\n#### Analysis of Circuit X (Producer-side Violation)\n- **Producer Behavior:** Ignores `$ready$`. On each cycle `$k \\in \\{1, ..., 8\\}$`, it places the next word `$w_{k-1}$` onto the data bus `$D$`.\n- **Consumer Behavior:** Correctly samples `$D$` only on rising edges `$t_k$` where `$valid(t_k) = 1$` and `$ready(t_k) = 1$`.\n\nThe table below traces the state of the interface for Circuit X. A \"Transfer\" occurs when the consumer samples the data.\n\n| Cycle `$k$` | Word on Bus `$D(t_k)$` | `$valid(t_k)`` | `$ready(t_k)`` | Transfer? (`$valid \\land ready$`) | Word Stored by Consumer |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| $1$ | `$w_0$` | $1$ | $1$ | **Yes** | `$w_0$` |\n| $2$ | `$w_1$` | $1$ | $1$ | **Yes** | `$w_1$` |\n| $3$ | `$w_2$` | $1$ | $0$ | No | -- |\n| $4$ | `$w_3$` | $1$ | $0$ | No | -- |\n| $5$ | `$w_4$` | $1$ | $0$ | No | -- |\n| $6$ | `$w_5$` | $1$ | $1$ | **Yes** | `$w_5$` |\n| $7$ | `$w_6$` | $1$ | $1$ | **Yes** | `$w_6$` |\n| $8$ | `$w_7$` | $1$ | $1$ | **Yes** | `$w_7$` |\n\n**Conclusion for Circuit X:** The consumer stores the sequence of words: `$w_0, w_1, w_5, w_6, w_7$`. During the consumer stall (`$k=3, 4, 5$`), the non-compliant producer continued to update the data bus with `$w_2, w_3, w_4$`. Since the consumer was not ready, it did not sample these words. By the time the consumer was ready again at `$t_6$`, the producer had moved on to offering `$w_5$`. Therefore, the words `$w_2, w_3, w_4$` are permanently lost.\n\n#### Analysis of Circuit Y (Consumer-side Violation)\n- **Producer Behavior:** Compliant. It advances to the next data word only after a successful transfer (`$valid=1$` and `$ready=1$`). If `$valid=1$` but `$ready=0$`, it holds the current data word on bus `$D$`. Let `$p_{ptr}$` be the index of the word the producer is currently offering.\n- **Consumer Behavior:** Incorrect. It samples `$D$` on every rising edge `$t_k$` where `$valid(t_k) = 1$`, ignoring `$ready$`.\n\nThe table below traces the state for Circuit Y. `Trans_prev` indicates if a valid transfer occurred on the previous cycle, which determines if the producer advances its data pointer.\n\n| Cycle `$k$` | `Trans_prev`? | `$p_{ptr}$` | Word on Bus `$D(t_k)$` | `$valid(t_k)`` | `$ready(t_k)`` | Consumer Samples? (`$valid=1$`) | Word Stored by Consumer |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| $1$ | -- | $0$ | `$w_0$` | $1$ | $1$ | **Yes** | `$w_0$` |\n| $2$ | Yes | $1$ | `$w_1$` | $1$ | $1$ | **Yes** | `$w_1$` |\n| $3$ | Yes | $2$ | `$w_2$` | $1$ | $0$ | **Yes** | `$w_2$` |\n| $4$ | No | $2$ | `$w_2$` | $1$ | $0$ | **Yes** | `$w_2$` (duplicate) |\n| $5$ | No | $2$ | `$w_2$` | $1$ | $0$ | **Yes** | `$w_2$` (duplicate) |\n| $6$ | No | $2$ | `$w_2$` | $1$ | $1$ | **Yes** | `$w_2$` (duplicate) |\n| $7$ | Yes | $3$ | `$w_3$` | $1$ | $1$ | **Yes** | `$w_3$` |\n| $8$ | Yes | $4$ | `$w_4$` | $1$ | $1$ | **Yes** | `$w_4$` |\n\n**Conclusion for Circuit Y:** The consumer stores the sequence `$w_0, w_1, w_2, w_2, w_2, w_2, w_3, w_4$`.\n- At `$t_3$`, the consumer is not ready (`$ready=0$`). The compliant producer correctly holds the data `$w_2$` on the bus for subsequent cycles (`$t_4, t_5, t_6$`) until a transfer is acknowledged at `$t_6$`.\n- However, the faulty consumer ignores `$ready$` and continues to sample on every cycle where `$valid=1$`. Since `$valid=1$` for `$k=3, 4, 5, 6$`, the consumer samples the held data `$w_2$` a total of four times. This results in data duplication.\n- Furthermore, because the producer was stalled for $3$ extra cycles (`$t_4, t_5, t_6$ consumed by `$w_2$`), it only gets to transmit up to `$w_4$` by the time the `$valid$` signal deasserts after `$t_8$`. The words `$w_5, w_6, w_7$` are never transmitted.\n\n### Option-by-Option Evaluation\n\n- **A. In Circuit X, the consumer ultimately stores `$w_0, w_1, w_5, w_6, w_7$`; the words `$w_2, w_3, w_4$` are lost.**\n  - Our analysis of Circuit X shows that the consumer captures the set of words `{$w_0, w_1, w_5, w_6, w_7}` and that `{$w_2, w_3, w_4}` are indeed lost. This statement is a precise description of the outcome.\n  - **Verdict: Correct.**\n\n- **B. In Circuit X, no data loss occurs because `$valid = 1$` continuously; the consumer will eventually capture all `$8$` words.**\n  - Our analysis of Circuit X clearly shows data loss. The producer's failure to wait for `$ready$` causes it to overwrite data that the consumer has not yet sampled.\n  - **Verdict: Incorrect.**\n\n- **C. In Circuit Y, duplicates occur: the consumer records the same word multiple times during the stall window because `$D$` is held constant while `$valid = 1$`.**\n  - Our analysis of Circuit Y shows that the word `$w_2$` is recorded four times. This happens precisely because the compliant producer holds `$D$` constant with `$w_2$` due to the consumer stall (`$ready=0$`), while the faulty consumer continues to sample because `$valid=1$`. This statement accurately describes the mechanism of failure.\n  - **Verdict: Correct.**\n\n- **D. In Circuit Y, duplication cannot occur in a synchronous single clock domain; only loss is possible.**\n  - This is a false general claim. Our specific analysis of Circuit Y demonstrates that data duplication is a direct and necessary consequence of this particular failure mode in a synchronous system. Duplication is a classic issue when a consumer samples based on an incomplete set of handshake conditions (e.g., only `$valid$`).\n  - **Verdict: Incorrect.**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "One of the most powerful applications of FPGAs is the implementation of custom processors, or \"soft cores,\" which can be tailored for specific tasks. Evaluating the performance of such a processor requires moving beyond simple clock speed to a more nuanced understanding of its pipeline behavior. This problem uses the classic processor performance equation to connect low-level hardware events—such as branch mispredictions, data hazards, and cache misses—to the overall system performance, as measured by Cycles Per Instruction ($CPI$). This practice provides a system-level perspective, challenging you to quantify how architectural and memory system characteristics collectively determine the true efficiency of a pipelined processor implemented on reconfigurable hardware. ",
            "id": "3671198",
            "problem": "Consider a hypothetical Reduced Instruction Set Computing (RISC) pipeline implemented on a Field Programmable Gate Array (FPGA). The pipeline has $5$ stages: instruction fetch (IF), instruction decode/register read (ID), execute (EX), memory access (MEM), and write-back (WB). The pipeline employs fully bypassed data paths for arithmetic instructions, resolves branches in the execute stage, and uses simple direct-mapped caches for instruction and data. The instrumentation consists of performance counters that increment in hardware according to the following fundamental definitions and observable events:\n\n- A cycle counter increments by $1$ every clock tick.\n- An instruction-retired counter increments by $1$ when an instruction completes the write-back stage without being flushed.\n- A branch-mispredict counter increments by $1$ on each branch misprediction event. The pipeline resolves branches in the execute stage, so a misprediction incurs a fixed penalty of $P_{br} = 2$ stall cycles because wrong-path instructions in the instruction fetch and instruction decode stages are flushed.\n- A load-use hazard counter increments by $1$ when a dependent instruction immediately follows a load and must stall due to the data becoming available only after the memory stage; the penalty is $P_{lu} = 1$ stall cycle per such event.\n- An instruction-cache-miss counter increments by $1$ whenever the instruction fetch stage encounters a cache miss, stalling fetch for $L_i$ cycles for each miss.\n- A data-cache-miss counter increments by $1$ whenever the memory stage encounters a cache miss, stalling memory for $L_d$ cycles for each miss.\n- Measurement begins with an empty pipeline and ends when the last instruction of the microbenchmark retires. The pipeline-fill overhead is $F = 4$ cycles for the $5$-stage pipeline when starting empty.\n\nFrom these definitions, the total number of cycles is the number of instruction-retirement cycles plus the number of stall cycles and the initial pipeline-fill overhead. The Cycles Per Instruction (CPI) is defined by $CPI = \\frac{C}{N}$, where $C$ is the total cycle count and $N$ is the total number of retired instructions.\n\nImplement a program that, given a set of microbenchmark parameters representing the observed performance counters and latencies, computes the CPI for each microbenchmark. Assume the penalties $P_{br} = 2$ and $P_{lu} = 1$ are fixed by the pipeline’s microarchitecture as described. For each microbenchmark, you are given $N$, $m$, $u$, $M_i$, $M_d$, $L_i$, $L_d$, and $F$ as integers, where:\n- $N$ is the total number of retired instructions.\n- $m$ is the number of branch mispredicts.\n- $u$ is the number of load-use stalls.\n- $M_i$ is the number of instruction cache misses.\n- $M_d$ is the number of data cache misses.\n- $L_i$ is the instruction cache miss latency in cycles.\n- $L_d$ is the data cache miss latency in cycles.\n- $F$ is the pipeline-fill overhead in cycles.\n\nYour program must produce CPIs as double-precision floating-point values for the following test suite of microbenchmarks, each specified by $(N, m, u, M_i, M_d, L_i, L_d, F)$:\n\n- Microbenchmark $1$ (balanced mix): $(N=1000, m=30, u=80, M_i=2, M_d=5, L_i=20, L_d=50, F=4)$.\n- Microbenchmark $2$ (hazardless, boundary): $(N=256, m=0, u=0, M_i=0, M_d=0, L_i=20, L_d=50, F=4)$.\n- Microbenchmark $3$ (branch-heavy): $(N=800, m=200, u=20, M_i=0, M_d=0, L_i=20, L_d=50, F=4)$.\n- Microbenchmark $4$ (memory-stress): $(N=500, m=5, u=10, M_i=10, M_d=40, L_i=30, L_d=80, F=4)$.\n- Microbenchmark $5$ (minimal, pipeline-fill dominated): $(N=1, m=0, u=0, M_i=0, M_d=0, L_i=20, L_d=50, F=4)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$). No other output should be produced. Each $result$ must be the CPI for the corresponding microbenchmark in the same order as listed above, represented as a floating-point number. The program must be self-contained and require no input.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in the fundamental principles of computer architecture, specifically the performance analysis of pipelined processors. The problem is well-posed, objective, and contains all necessary data and definitions to derive a unique, meaningful solution. All parameters and scenarios are consistent with established models used in the study of RISC architectures.\n\nThe primary objective is to calculate the Cycles Per Instruction ($CPI$) for several microbenchmarks. The $CPI$ is defined as the ratio of the total number of clock cycles ($C$) to the total number of retired instructions ($N$).\n$$CPI = \\frac{C}{N}$$\n\nThe total cycle count ($C$) must be formulated based on the provided pipeline characteristics and performance counter events. The problem states that \"the total number of cycles is the number of instruction-retirement cycles plus the number of stall cycles and the initial pipeline-fill overhead.\" This can be formally interpreted using the standard processor performance equation.\n\nThe total execution time for $N$ instructions in an ideal pipeline (i.e., one with no stalls) with $k$ stages is $C_{ideal} = k + (N-1)$ cycles. This consists of $k-1$ cycles to fill the pipeline, after which one instruction completes per cycle. The problem provides the pipeline depth indirectly through the pipeline-fill overhead, $F$. For a $k$-stage pipeline, the fill overhead is $F = k-1$ cycles. Here, the pipeline has $k=5$ stages, and consistently, the given fill overhead is $F=4$. Thus, the ideal base cycle count is:\n$$C_{base} = N + F = N + (k-1)$$\n\nTo this base cycle count, we must add the total number of stall cycles ($C_{stall}$) caused by various pipeline hazards and memory system latencies. The problem specifies that the performance counters track discrete events, and their penalties are additive. The total stall cycles are the sum of stalls from each source:\n1.  **Branch Misprediction Stalls**: Each of the $m$ mispredictions incurs a penalty of $P_{br}=2$ cycles. Total stall cycles from branches are $m \\cdot P_{br}$.\n2.  **Load-Use Hazard Stalls**: Each of the $u$ load-use hazards incurs a penalty of $P_{lu}=1$ cycle. Total stall cycles from load-use hazards are $u \\cdot P_{lu}$.\n3.  **Instruction Cache Miss Stalls**: Each of the $M_i$ instruction cache misses stalls the pipeline for $L_i$ cycles. Total stall cycles are $M_i \\cdot L_i$.\n4.  **Data Cache Miss Stalls**: Each of the $M_d$ data cache misses stalls the pipeline for $L_d$ cycles. Total stall cycles are $M_d \\cdot L_d$.\n\nAssuming these stall events are non-overlapping, the total number of stall cycles is the sum of the individual contributions:\n$$C_{stall} = m \\cdot P_{br} + u \\cdot P_{lu} + M_i \\cdot L_i + M_d \\cdot L_d$$\n\nCombining the base cycles and stall cycles gives the total cycle count $C$:\n$$C = C_{base} + C_{stall} = (N + F) + (m \\cdot P_{br} + u \\cdot P_{lu} + M_i \\cdot L_i + M_d \\cdot L_d)$$\n\nSubstituting the fixed microarchitectural penalties $P_{br}=2$ and $P_{lu}=1$:\n$$C = N + F + 2m + u + M_i L_i + M_d L_d$$\n\nFinally, the $CPI$ is calculated by dividing $C$ by $N$:\n$$CPI = \\frac{N + F + 2m + u + M_i L_i + M_d L_d}{N} = 1 + \\frac{F + 2m + u + M_i L_i + M_d L_d}{N}$$\n\nThis comprehensive formula will be applied to each of the specified microbenchmarks. As an illustrative example, let us compute the $CPI$ for Microbenchmark $1$:\n- Parameters: $(N=1000, m=30, u=80, M_i=2, M_d=5, L_i=20, L_d=50, F=4)$.\n- Total cycles $C_1$:\n$$C_1 = 1000 + 4 + 2(30) + 80 + 2(20) + 5(50)$$\n$$C_1 = 1000 + 4 + 60 + 80 + 40 + 250 = 1434$$\n- $CPI_1$:\n$$CPI_1 = \\frac{1434}{1000} = 1.434$$\n\nThe same procedure is systematically applied to the remaining four microbenchmarks to obtain their respective $CPI$ values. The implementation will perform these calculations for all test cases and format the output as required.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// A struct to hold the parameters for a single microbenchmark test case.\ntypedef struct {\n    int N;      // Total number of retired instructions\n    int m;      // Number of branch mispredicts\n    int u;      // Number of load-use stalls\n    int Mi;     // Number of instruction cache misses\n    int Md;     // Number of data cache misses\n    int Li;     // Instruction cache miss latency\n    int Ld;     // Data cache miss latency\n    int F;      // Pipeline-fill overhead\n} TestCase;\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        // N,   m,   u,  Mi, Md, Li, Ld,  F\n        {1000,  30,  80,   2,  5, 20, 50,  4}, // Microbenchmark 1 (balanced mix)\n        { 256,   0,   0,   0,  0, 20, 50,  4}, // Microbenchmark 2 (hazardless, boundary)\n        { 800, 200,  20,   0,  0, 20, 50,  4}, // Microbenchmark 3 (branch-heavy)\n        { 500,   5,  10,  10, 40, 30, 80,  4}, // Microbenchmark 4 (memory-stress)\n        {   1,   0,   0,   0,  0, 20, 50,  4}  // Microbenchmark 5 (minimal, pipeline-fill dominated)\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    double results[num_cases];\n\n    // Fixed pipeline penalties from the problem description.\n    const int P_br = 2; // Branch misprediction penalty\n    const int P_lu = 1; // Load-use hazard penalty\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n\n        // Calculate total stall cycles.\n        // C_stall = m*P_br + u*P_lu + Mi*Li + Md*Ld\n        // Note: Using double for calculations to avoid potential overflow with large numbers\n        // and to ensure floating-point precision for the final CPI.\n        double stall_cycles = (double)tc.m * P_br + \n                              (double)tc.u * P_lu + \n                              (double)tc.Mi * tc.Li + \n                              (double)tc.Md * tc.Ld;\n\n        // Calculate total cycles.\n        // C = Base_cycles + Stall_cycles\n        // Base_cycles = N + F\n        double total_cycles = (double)tc.N + (double)tc.F + stall_cycles;\n\n        // Calculate CPI = C / N.\n        // A check for N=0 is good practice, but not necessary here as N >= 1 in all test cases.\n        double cpi = total_cycles / (double)tc.N;\n        \n        results[i] = cpi;\n    }\n\n    // Print the results in the EXACT REQUIRED format: [result1,result2,...]\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"%f\", results[i]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}