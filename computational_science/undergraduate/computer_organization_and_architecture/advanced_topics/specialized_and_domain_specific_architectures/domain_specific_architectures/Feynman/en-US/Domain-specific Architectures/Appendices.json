{
    "hands_on_practices": [
        {
            "introduction": "For compute-intensive algorithms like matrix multiplication, performance is often limited not by the speed of computation, but by the rate at which data can be fetched from memory—a problem known as the \"memory wall\". This exercise explores tiling, a fundamental technique for structuring computation to maximize data reuse within a fast, on-chip scratchpad memory. By deriving the optimal tile size from first principles, you will directly connect an architectural constraint (SRAM capacity) to an algorithmic parameter (tile size) to minimize costly off-chip data traffic .",
            "id": "3636754",
            "problem": "Consider a Domain-Specific Architecture (DSA) designed for dense matrix multiplication on a large square problem of dimension $N$, computing $C = A B$ where $A$, $B$, and $C$ are $N \\times N$ matrices of $8$-bit integers. The accelerator has an on-chip static random-access memory (SRAM) scratchpad of capacity $S$ bytes and communicates with off-chip dynamic random-access memory (DRAM). The compute kernel uses a single-level, square tiling scheme with tile side length $T$, such that tiles of $A$, $B$, and $C$ of shape $T \\times T$ are brought into the scratchpad and reused while a $T \\times T$ output tile of $C$ is accumulated. Assume the following conditions:\n\n- Each element is $1$ byte, so the tile footprints are $T^{2}$ bytes for each of $A$, $B$, and $C$.\n- While producing one $T \\times T$ output tile of $C$, the algorithm streams across the $k$-dimension in tiles, loading one $T \\times T$ tile from $A$ and one $T \\times T$ tile from $B$ per $k$-step, and keeps the corresponding $T \\times T$ tile of $C$ resident in SRAM until its accumulation is complete.\n- The output tile $C$ is initialized on-chip (no initial read from off-chip) and is written back to off-chip memory once per tile after accumulation.\n- Ignore control overhead, boundary tiles for non-divisible $N$, and double-buffering; treat $T$ as a positive integer that must satisfy the SRAM capacity constraint.\n\nStarting from the definition of matrix multiplication and from first principles of data reuse under single-level blocking, derive the off-chip data movement in bytes, $B(T)$, as a function of $T$, and show the monotonicity of $B(T)$ over all feasible $T$. Using the SRAM capacity constraint and your monotonicity argument, determine the optimal integer tile side length $T$ that minimizes the total off-chip bytes. Express your final answer as a single closed-form analytic expression in terms of $S$. No rounding is required, and your answer should be dimensionless.",
            "solution": "The problem requires the derivation of the optimal integer tile side length, $T$, that minimizes off-chip data movement for a tiled matrix multiplication algorithm on a Domain-Specific Architecture (DSA). The derivation must proceed from first principles.\n\nFirst, let us establish the total data movement, $B(T)$, as a function of the tile side length $T$. The computation is the multiplication of two dense $N \\times N$ matrices, $C = AB$. The elements are $8$-bit integers, which means each element occupies $1$ byte.\n\nThe algorithm uses a single-level square tiling scheme. The $N \\times N$ matrices are partitioned into tiles of size $T \\times T$. The total number of tiles in any of the matrices $A$, $B$, or $C$ is $\\left(\\frac{N}{T}\\right) \\times \\left(\\frac{N}{T}\\right) = \\left(\\frac{N}{T}\\right)^2$, assuming $N$ is perfectly divisible by $T$ as per the problem statement.\n\nThe problem specifies an \"output-stationary\" dataflow. This means that a single $T \\times T$ tile of the output matrix $C$ is held resident in the on-chip SRAM scratchpad while it is being accumulated. Let us analyze the data movement required to compute one such output tile.\n\nThe computation of a single $T \\times T$ tile of $C$, say $C_{ii,jj}$, is given by the sum over the tile index $kk$:\n$$C_{ii,jj} = \\sum_{kk=0}^{(N/T)-1} A_{ii,kk} B_{kk,jj}$$\nwhere $A_{ii,kk}$ and $B_{kk,jj}$ are the corresponding $T \\times T$ input tiles.\n\nAccording to the problem description:\n$1.$ The $T \\times T$ output tile of $C$ is initialized on-chip. After its full accumulation over all $N/T$ values of $kk$, it is written back to off-chip DRAM once. Since each element is $1$ byte, the size of a tile is $T^2$ bytes. This contributes $T^2$ bytes to the total write traffic for this one output tile.\n$2.$ For each step in the accumulation (i.e., for each value of $kk$ from $0$ to $(N/T)-1$), one $T \\times T$ tile of $A$ and one $T \\times T$ tile of $B$ are loaded from DRAM into the SRAM.\nThe total number of such steps to compute one $C$ tile is $N/T$.\nThe volume of data read from DRAM for one $C$ tile is the number of steps multiplied by the data loaded per step:\n$$ \\text{Read traffic per C tile} = \\frac{N}{T} \\times (\\text{size of A tile} + \\text{size of B tile}) = \\frac{N}{T} \\times (T^2 + T^2) = \\frac{N}{T} \\times 2T^2 = 2NT \\text{ bytes} $$\nThe total off-chip data movement (reads + writes) to compute one $T \\times T$ tile of $C$ is therefore $2NT + T^2$ bytes.\n\nThe entire matrix $C$ consists of $(N/T)^2$ such tiles. The total data movement, $B(T)$, is the movement per tile multiplied by the total number of tiles:\n$$ B(T) = \\left(\\frac{N}{T}\\right)^2 \\times (2NT + T^2) $$\n$$ B(T) = \\frac{N^2}{T^2} (2NT) + \\frac{N^2}{T^2} (T^2) = \\frac{2N^3}{T} + N^2 $$\n\nNext, we must consider the constraint imposed by the on-chip SRAM capacity, $S$. The algorithm requires that at any point during the accumulation of a $C$ tile, the scratchpad must hold the $T \\times T$ accumulator for $C$, one $T \\times T$ tile of $A$, and one $T \\times T$ tile of $B$. The total required capacity is the sum of the sizes of these three tiles.\n$$ \\text{SRAM requirement} = \\text{size}(A_{\\text{tile}}) + \\text{size}(B_{\\text{tile}}) + \\text{size}(C_{\\text{tile}}) $$\n$$ \\text{SRAM requirement} = T^2 + T^2 + T^2 = 3T^2 \\text{ bytes} $$\nThis required capacity must not exceed the available SRAM size $S$:\n$$ 3T^2 \\le S $$\n\nOur goal is to find the integer $T$ that minimizes $B(T) = \\frac{2N^3}{T} + N^2$ subject to the constraint $3T^2 \\le S$ and $T$ being a positive integer.\n\nTo determine how $B(T)$ changes with $T$, we analyze its monotonicity. We can treat $T$ as a continuous positive variable for this purpose. The derivative of $B(T)$ with respect to $T$ is:\n$$ \\frac{dB}{dT} = \\frac{d}{dT} \\left( \\frac{2N^3}{T} + N^2 \\right) = \\frac{d}{dT} (2N^3 T^{-1}) + \\frac{d}{dT} (N^2) $$\n$$ \\frac{dB}{dT} = -1 \\cdot 2N^3 T^{-2} + 0 = -\\frac{2N^3}{T^2} $$\nSince $N$ is a problem dimension, $N > 0$, and $T$ is the tile side length, $T > 0$. Thus, $N^3 > 0$ and $T^2 > 0$. Consequently, the derivative $\\frac{dB}{dT}$ is strictly negative for all feasible $T$. This proves that $B(T)$ is a strictly monotonically decreasing function of $T$.\n\nTo minimize a monotonically decreasing function, one must select the largest possible value for its argument. The feasible range for $T$ is defined by the SRAM capacity constraint, $3T^2 \\le S$.\n$$ T^2 \\le \\frac{S}{3} $$\n$$ T \\le \\sqrt{\\frac{S}{3}} $$\nSince $T$ must be an integer, the optimal value for $T$ is the largest integer that satisfies this inequality. This is the floor of the expression on the right-hand side.\n$$ T_{\\text{optimal}} = \\left\\lfloor \\sqrt{\\frac{S}{3}} \\right\\rfloor $$\nThis expression gives the optimal integer tile side length $T$ as a closed-form analytic expression in terms of the SRAM capacity $S$.",
            "answer": "$$\\boxed{\\left\\lfloor \\sqrt{\\frac{S}{3}} \\right\\rfloor}$$"
        },
        {
            "introduction": "Not all applications benefit from caching large, general-purpose blocks of data; many, like real-time image processing, involve streaming dataflows where data is processed as it arrives. This practice shifts our focus to designing memory systems for such streaming architectures, specifically using line buffers for 2D convolutions. This exercise challenges you to calculate the minimum on-chip SRAM required to support a separable filter, demonstrating how data reuse patterns in streaming algorithms directly dictate the hardware memory requirements .",
            "id": "3636740",
            "problem": "A streaming accelerator is designed as a Domain-Specific Architecture (DSA) for real-time image processing using separable two-dimensional filters. The DSA implements a length-$K$ finite impulse response (FIR) filter horizontally followed by a length-$K$ FIR vertically to realize a separable $K \\times K$ convolution. The pipeline sustains one pixel per cycle after warm-up by reusing pixels through on-chip line buffers implemented in Static Random-Access Memory (SRAM). The horizontal stage uses only small shift registers local to the processing elements and does not consume SRAM. The vertical stage reads the current row from the stream and any previously seen rows from SRAM. The image border is handled by zero-extension without additional storage. There is no double buffering; the line buffers form a ring that stores exactly as many past rows as needed to make all vertical taps available.\n\nYou are given:\n- Image width $W = 1920$ pixels.\n- Square kernel size $K = 7$.\n- Number of color channels $C = 3$.\n- Each channel sample is stored in $B = 2$ bytes (for $16$-bit fixed-point).\n\nBased only on fundamental reuse constraints implied by a streaming pipeline, determine the minimum on-chip SRAM capacity required for the line buffers, in kibibytes (KiB), where $1$ KiB $= 1024$ bytes.\n\nExpress the final memory size in kibibytes (KiB) and round your answer to four significant figures. Do not include any storage other than the line buffers in your calculation.",
            "solution": "The problem requires calculating the minimum SRAM capacity needed for the line buffers in a streaming convolution accelerator. The architecture uses a separable filter, which consists of a horizontal filter followed by a vertical filter.\n\nThe problem states that the horizontal filtering stage uses only local shift registers and does not consume SRAM. This is a crucial piece of information, as it isolates the SRAM requirement to the vertical filtering stage.\n\nThe vertical filter is a finite impulse response (FIR) filter of length $K$. To compute the output for a pixel at a given spatial coordinate $(x, y)$, the filter needs access to a column of $K$ input values. In this pipelined design, these inputs are the results from the horizontal filtering stage at column $x$ for $K$ consecutive rows. Let the intermediate horizontally-filtered value be $h(x, y)$. The final output $o(x, y)$ requires the set $\\{h(x, y'), h(x, y'-1), \\dots, h(x, y' - K + 1)\\}$ for some row index $y'$.\n\nIn a streaming context where rows are processed sequentially, to compute the output for the current row, the accelerator has direct access to the data for that row as it is being processed. However, to complete the $K$-tap vertical convolution, it must also have access to the data from the previous $K-1$ rows. These previous rows must be stored in a buffer. The problem specifies these buffers as line buffers implemented in SRAM.\n\nThe number of rows that must be stored in SRAM is therefore $N_{rows} = K-1$.\n\nNext, we calculate the amount of data in a single row. The image has a width of $W$ pixels. Each pixel consists of $C$ color channels, and each channel sample is stored in $B$ bytes.\n\nThe size of a single row in bytes, denoted as $M_{row}$, is the product of these three quantities:\n$$M_{row} = W \\times C \\times B$$\n\nThe total SRAM capacity required, $M_{SRAM}$, is the number of rows to be stored multiplied by the size of each row.\n$$M_{SRAM} = N_{rows} \\times M_{row} = (K-1) \\times W \\times C \\times B$$\n\nWe are given the following values:\n- $W = 1920$\n- $K = 7$\n- $C = 3$\n- $B = 2$\n\nSubstituting these values into the formula:\nFirst, the number of rows to store is:\n$$N_{rows} = 7 - 1 = 6$$\n\nNext, the size of one row in bytes is:\n$$M_{row} = 1920 \\times 3 \\times 2 = 11520 \\text{ bytes}$$\n\nThe total SRAM capacity in bytes is:\n$$M_{SRAM} = 6 \\times 11520 = 69120 \\text{ bytes}$$\n\nThe problem asks for the result in kibibytes (KiB), with the conversion factor $1 \\text{ KiB} = 1024$ bytes. Let the capacity in KiB be $M_{KiB}$.\n$$M_{KiB} = \\frac{M_{SRAM}}{1024}$$\n$$M_{KiB} = \\frac{69120}{1024}$$\nPerforming the division:\n$$M_{KiB} = 67.5$$\n\nThe problem requires the answer to be rounded to four significant figures. The number $67.5$ has three significant figures. To express it with four, we add a trailing zero.\n$$M_{KiB} = 67.50$$\nThis value represents the minimum on-chip SRAM capacity required exclusively for the line buffers to support the vertical filtering stage of the described separable convolution.",
            "answer": "$$\n\\boxed{67.50}\n$$"
        },
        {
            "introduction": "Efficiently managing the memory hierarchy involves not only deciding what data to place on-chip but also how to move it there without stalling the processing elements. This final practice delves into the dynamics of overlapping computation with data transfers using double buffering and Direct Memory Access (DMA). You will determine the minimum tile size required to fully hide the latency of fetching new data and writing back results, a critical analysis for achieving high sustained performance in any pipelined accelerator .",
            "id": "3636696",
            "problem": "A Domain-Specific Architecture (DSA) with software-managed scratchpad memory processes a two-dimensional grid using a stencil that requires a halo of width $h$ around each compute tile. The DSA has two independent Direct Memory Access (DMA) channels (one for input, one for output), each with sustained bandwidth $b$ and a per-transfer setup latency $t_0$. The scratchpad is organized as a double buffer so that, while one buffer is used for computation, the other buffer is used for DMA transfers of the next tile’s input data and the previous tile’s output data. The computation for each grid point update is throughput-limited to $r$ updates per second. Each grid element is a word of size $s$ bytes. The stencil requires the tile input region to include the compute region plus the halo on all four sides.\n\nConsider streaming tiles of fixed width $W$ elements across a large grid of dimensions $N_x \\times N_y$ (with $N_x$ and $N_y$ large enough that boundary effects can be ignored for the purpose of steady-state scheduling). Each tile processes $W \\times H$ compute elements, and must read $(W + 2h) \\times (H + 2h)$ input elements (to cover halos) and write $W \\times H$ output elements. Assume the input and output transfers for a tile are each performed as a single DMA transaction per tile per channel.\n\nParameters:\n- Grid dimensions: $N_x = 8192$, $N_y = 8192$.\n- Halo width: $h = 2$.\n- Element size: $s = 8$ bytes.\n- Tile width: $W = 512$.\n- DMA bandwidth per channel: $b = 25 \\times 10^{9}$ bytes per second.\n- DMA setup latency per transfer: $t_0 = 2 \\times 10^{-6}$ seconds.\n- Compute throughput: $r = 2 \\times 10^{9}$ element updates per second.\n\nTask:\n1. Using first principles, derive the inequality that guarantees full overlap of DMA transfers with computation under double buffering, and solve for the minimal tile height $H_{\\min}$ that satisfies this inequality. Model the input transfer time for one tile as $T_{\\text{in}} = t_0 + \\frac{s (W + 2h)(H + 2h)}{b}$ and the output transfer time as $T_{\\text{out}} = t_0 + \\frac{s W H}{b}$. Model the compute time as $T_{\\text{comp}} = \\frac{W H}{r}$. Full overlap requires $T_{\\text{comp}} \\ge \\max\\{T_{\\text{in}}, T_{\\text{out}}\\}$.\n2. For $H = H_{\\min}$, quantify the required scratchpad capacity per buffer to hold both the input region (including halo) and the output region simultaneously during compute, i.e., $S_{\\text{buffer}} = s \\left[ (W + 2h)(H + 2h) + W H \\right]$ bytes. Also report the total scratchpad capacity for the double buffer, $S_{\\text{total}} = 2 S_{\\text{buffer}}$.\n3. Express $H_{\\min}$ as a dimensionless integer and the scratchpad capacities in kilobytes, where one kilobyte is defined as $1024$ bytes. Round all numerical results to four significant figures.\n\nYour final answer must be a single row matrix containing $H_{\\min}$, $S_{\\text{buffer}}$ in kilobytes, and $S_{\\text{total}}$ in kilobytes, in that order.",
            "solution": "The core task is to find the minimal tile height $H_{\\min}$ that allows computation to fully overlap with DMA transfers. The architecture uses a double buffer, meaning that while the processor computes on data in one buffer, the DMA engines can transfer data for the next tile into and out of the other buffer. For full overlap, the computation time for a tile, $T_{\\text{comp}}$, must be greater than or equal to the time required for data transfers. The input and output transfers for different tiles happen concurrently with computation, and since there are independent channels for input and output, the total transfer time is determined by the slower of the two transfers. The condition for full overlap is thus given as:\n$$\nT_{\\text{comp}} \\ge \\max\\{T_{\\text{in}}, T_{\\text{out}}\\}\n$$\n\nThe expressions for the times are provided:\n- Compute time: $T_{\\text{comp}} = \\frac{W H}{r}$\n- Input transfer time: $T_{\\text{in}} = t_0 + \\frac{s (W + 2h)(H + 2h)}{b}$\n- Output transfer time: $T_{\\text{out}} = t_0 + \\frac{s W H}{b}$\n\nHere, $W$ is the tile width, $H$ is the tile height, $r$ is the compute throughput, $t_0$ is the DMA setup latency, $s$ is the element size, $h$ is the halo width, and $b$ is the DMA channel bandwidth.\n\nFirst, we determine which of $T_{\\text{in}}$ or $T_{\\text{out}}$ is larger. Let's compare the size of the data being transferred. The input region is $(W + 2h) \\times (H + 2h)$ elements, while the output region is $W \\times H$ elements. Since $W, H, h$ are all positive integers, we have:\n$$\n(W + 2h)(H + 2h) = WH + 2hW + 2hH + 4h^2 > WH\n$$\nThis implies that the amount of input data is strictly greater than the amount of output data. Consequently, the transfer time for the input data will be longer than for the output data, as both have the same setup latency $t_0$.\n$$\nT_{\\text{in}} > T_{\\text{out}}\n$$\nTherefore, the condition for full overlap simplifies to:\n$$\nT_{\\text{comp}} \\ge T_{\\text{in}}\n$$\n\nSubstituting the expressions for $T_{\\text{comp}}$ and $T_{\\text{in}}$, we obtain the governing inequality:\n$$\n\\frac{W H}{r} \\ge t_0 + \\frac{s (W + 2h)(H + 2h)}{b}\n$$\nWe need to solve this inequality for $H$. Let's expand the term on the right-hand side and group terms involving $H$:\n$$\n\\frac{W H}{r} \\ge t_0 + \\frac{s}{b} (WH + 2hW + 2hH + 4h^2) \\\\\n\\frac{W H}{r} \\ge t_0 + \\frac{sWH}{b} + \\frac{2shH}{b} + \\frac{s(2hW + 4h^2)}{b}\n$$\nNow, we collect all terms with $H$ on one side of the inequality:\n$$\n\\frac{W H}{r} - \\frac{sWH}{b} - \\frac{2shH}{b} \\ge t_0 + \\frac{s(2hW + 4h^2)}{b} \\\\\nH \\left( \\frac{W}{r} - \\frac{sW}{b} - \\frac{2sh}{b} \\right) \\ge t_0 + \\frac{s}{b}(2hW + 4h^2)\n$$\nThe inequality is of the form $H \\cdot C_1 \\ge C_2$. To solve for $H$, we must first determine the sign of the coefficient $C_1 = \\frac{W}{r} - \\frac{sW}{b} - \\frac{2sh}{b}$. Let's substitute the given numerical values:\n- $W = 512$\n- $h = 2$\n- $s = 8 \\, \\text{bytes}$\n- $b = 25 \\times 10^{9} \\, \\text{bytes/s}$\n- $t_0 = 2 \\times 10^{-6} \\, \\text{s}$\n- $r = 2 \\times 10^9 \\, \\text{updates/s}$\n\nWe calculate the terms in the coefficient $C_1$:\n$$\n\\frac{1}{r} = \\frac{1}{2 \\times 10^9} \\, \\text{s/update} = 0.5 \\times 10^{-9} \\, \\text{s} \\\\\n\\frac{s}{b} = \\frac{8 \\, \\text{bytes}}{25 \\times 10^9 \\, \\text{bytes/s}} = 0.32 \\times 10^{-9} \\, \\text{s}\n$$\nSince $\\frac{1}{r} > \\frac{s}{b}$, the term $W(\\frac{1}{r} - \\frac{s}{b})$ is positive, indicating that computation is slower than data transfer on a per-element basis, making overlap possible.\nThe coefficient of $H$ is:\n$$\nC_1 = W\\left(\\frac{1}{r} - \\frac{s}{b}\\right) - \\frac{2sh}{b} = 512(0.5 \\times 10^{-9} - 0.32 \\times 10^{-9}) - \\frac{2(8)(2)}{25 \\times 10^9} \\\\\nC_1 = 512(0.18 \\times 10^{-9}) - \\frac{32}{25 \\times 10^9} = (92.16 \\times 10^{-9}) - (1.28 \\times 10^{-9}) = 90.88 \\times 10^{-9} \\, \\text{s}\n$$\nSince $C_1$ is positive, we can divide by it without changing the direction of the inequality:\n$$\nH \\ge \\frac{t_0 + \\frac{s}{b}(2hW + 4h^2)}{C_1}\n$$\nLet's calculate the numerator $C_2 = t_0 + \\frac{s}{b}(2hW + 4h^2)$:\n$$\nC_2 = 2 \\times 10^{-6} + (0.32 \\times 10^{-9})(2(2)(512) + 4(2^2)) \\\\\nC_2 = 2 \\times 10^{-6} + (0.32 \\times 10^{-9})(2048 + 16) \\\\\nC_2 = 2 \\times 10^{-6} + (0.32 \\times 10^{-9})(2064) = 2 \\times 10^{-6} + 660.48 \\times 10^{-9} \\\\\nC_2 = 2000 \\times 10^{-9} + 660.48 \\times 10^{-9} = 2660.48 \\times 10^{-9} \\, \\text{s}\n$$\nNow we find the lower bound for $H$:\n$$\nH \\ge \\frac{2660.48 \\times 10^{-9}}{90.88 \\times 10^{-9}} \\approx 29.2768\n$$\nSince the tile height $H$ must be an integer number of grid elements, the minimal value for $H$ is the smallest integer greater than or equal to this bound.\n$$\nH_{\\min} = \\lceil 29.2768 \\rceil = 30\n$$\n\nNext, we calculate the required scratchpad memory capacity per buffer, $S_{\\text{buffer}}$, and the total capacity for the double buffer, $S_{\\text{total}}$, using $H = H_{\\min} = 30$. The formula for the capacity of a single buffer is given as:\n$$\nS_{\\text{buffer}} = s \\left[ (W + 2h)(H + 2h) + W H \\right]\n$$\nSubstituting the known values:\n$$\nW + 2h = 512 + 2(2) = 516 \\\\\nH_{\\min} + 2h = 30 + 2(2) = 34\n$$\nThe number of elements in the input region is $(516)(34) = 17544$. The number of elements in the output region is $W H_{\\min} = 512 \\times 30 = 15360$.\n$$\nS_{\\text{buffer}} = 8 \\, \\text{bytes} \\times (17544 + 15360) = 8 \\times 32904 = 263232 \\, \\text{bytes}\n$$\nThe total scratchpad capacity is for two such buffers:\n$$\nS_{\\text{total}} = 2 \\times S_{\\text{buffer}} = 2 \\times 263232 = 526464 \\, \\text{bytes}\n$$\n\nFinally, we convert the capacities to kilobytes (where $1 \\, \\text{KB} = 1024 \\, \\text{bytes}$) and round to four significant figures.\n$$\nS_{\\text{buffer}} = \\frac{263232}{1024} \\, \\text{KB} = 257.0625 \\, \\text{KB} \\approx 257.1 \\, \\text{KB}\n$$\n$$\nS_{\\text{total}} = \\frac{526464}{1024} \\, \\text{KB} = 514.125 \\, \\text{KB} \\approx 514.1 \\, \\text{KB}\n$$\nThe three requested values are $H_{\\min}=30$, $S_{\\text{buffer}} \\approx 257.1 \\, \\text{KB}$, and $S_{\\text{total}} \\approx 514.1 \\, \\text{KB}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n30 & 257.1 & 514.1\n\\end{pmatrix}\n}\n$$"
        }
    ]
}