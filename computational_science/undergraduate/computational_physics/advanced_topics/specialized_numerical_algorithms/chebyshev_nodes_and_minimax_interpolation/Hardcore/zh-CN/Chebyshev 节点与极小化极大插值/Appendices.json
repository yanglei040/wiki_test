{
    "hands_on_practices": [
        {
            "introduction": "让我们从一个基础练习开始，亲手实践切比雪夫插值法。这个练习的目标是为一个简单的函数构建一个低阶插值多项式，让你能够专注于插值的核心步骤：确定节点、建立方程并求解。通过这个具体的计算，你将对理论概念有更扎实的理解。",
            "id": "2187288",
            "problem": "在数值分析中，使用切比雪夫节点进行插值是优于使用等距点的一种方法，尤其是在避免龙格现象方面。该方法选择的插值点是切比雪夫多项式的根，这些根聚集在区间的端点附近。\n\n考虑在区间 $[-1, 1]$ 上的函数 $f(x) = x^3$。您的任务是找到一个次数至多为2的唯一多项式，我们称之为 $P_2(x)$，它在该区间的三个切比雪夫节点上对 $f(x)$ 进行插值。这些节点被定义为3次第一类切比雪夫多项式 $T_3(x)$ 的根。\n\n将您的答案 $P_2(x)$ 表示为一个关于 $x$ 的简化多项式。",
            "solution": "给定在 $[-1,1]$ 上的函数 $f(x)=x^{3}$，我们必须找到一个次数至多为 $2$ 的唯一多项式 $P_{2}(x)$，它在 $[-1,1]$ 上的三个切比雪夫节点上对 $f$ 进行插值，这些节点被定义为3次第一类切比雪夫多项式 $T_{3}(x)$ 的根。\n\n使用恒等式 $T_{3}(x)=\\cos\\!\\big(3\\arccos x\\big)=4x^{3}-3x$。$T_{3}$ 的根是三个切比雪夫节点：\n$$\nT_{3}(x)=4x^{3}-3x=x\\big(4x^{2}-3\\big)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\n设 $P_{2}(x)=A x^{2}+B x+C$。插值条件是在每个节点 $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$ 处，都有 $P_{2}(\\xi)=\\xi^{3}$。\n\n1) 在 $x=0$ 处：\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) 设 $a=\\frac{\\sqrt{3}}{2}$。在 $x=a$ 和 $x=-a$ 处：\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\n将这两个方程相加可以消去 $B$：\n$$\n\\big(A a^{2}+B a\\big)+\\big(A a^{2}-B a\\big)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{因为 }a\\neq 0).\n$$\n将 $A=0$ 代入 $A a^{2}+B a=a^{3}$ 来求解 $B$：\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\n当 $a=\\frac{\\sqrt{3}}{2}$ 时，我们有\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\n因此，\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\n快速检验一下：$P_{2}(0)=0=f(0)$，并且 $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$，因此在所有三个切比雪夫节点处插值条件都得到满足。\n\n因此，次数至多为2的唯一插值多项式是 $P_{2}(x)=\\frac{3}{4}x$。",
            "answer": "$$\\boxed{\\frac{3}{4}x}$$"
        },
        {
            "introduction": "现在，我们将直面多项式插值中最著名的问题之一：龙格现象。这个实践将展示切比雪夫节点如何有效地抑制高阶插值在区间端点附近发生的剧烈振荡。通过对经典的龙格函数进行插值，并与另一组优质节点——勒让德节点——进行比较，你将亲眼见证并量化切比雪夫插值在提高近似稳定性和准确性方面的优越性。",
            "id": "2378832",
            "problem": "您的任务是，对于一个给定函数，在区间 $[-1,1]$ 上使用两组不同的节点集，构建并比较多项式插值。设目标函数为 $f(x)=\\dfrac{1}{1+25x^2}$，定义域为 $x\\in[-1,1]$。对于每个次数参数 $n\\in\\{1,5,10,25\\}$，执行以下步骤：\n\n1. 在 $[-1,1]$ 上定义两组包含 $n$ 个插值节点的节点集：\n   (a) Legendre 多项式 $P_n(x)$ 的 $n$ 个不同实根，任意排序。\n   (b) 第一类 Chebyshev 节点 $x_k=\\cos\\!\\left(\\dfrac{(2k-1)\\pi}{2n}\\right)$，其中 $k=1,2,\\dots,n$，余弦函数的参数以弧度为单位。\n\n2. 对每组节点集，构建唯一的、次数至多为 $n-1$ 的多项式插值 $p_{n-1}(x)$，使其在节点处与 $f(x)$ 的值相匹配。\n\n3. 在一个覆盖 $[-1,1]$ 区间（包含端点 $x=-1$ 和 $x=1$ 且等距分布）的 $M=2001$ 个点的均匀网格 $G$ 上，计算最大绝对插值误差\n$$\nE=\\max_{x\\in G}\\left|f(x)-p_{n-1}(x)\\right|.\n$$\n\n4. 对于每个 $n\\in\\{1,5,10,25\\}$，计算两个值：使用 Legendre 根的 $E_{\\text{Leg}}$ 和使用 Chebyshev 节点的 $E_{\\text{Cheb}}$，两者的定义如步骤 3 所示。将这两个误差均四舍五入到 8 位小数。\n\n您的程序必须生成单行输出，其中包含一个逗号分隔的四个结果的列表，每个 $n$ 对应一个结果，每个结果本身是一个有序对 $[E_{\\text{Leg}},E_{\\text{Cheb}}]$。具体来说，确切的输出格式必须是\n$$\n\\big[\\,[E_{\\text{Leg}}(1),E_{\\text{Cheb}}(1)],\\,[E_{\\text{Leg}}(5),E_{\\text{Cheb}}(5)],\\,[E_{\\text{Leg}}(10),E_{\\text{Cheb}}(10)],\\,[E_{\\text{Leg}}(25),E_{\\text{Cheb}}(25)]\\,\\big],\n$$\n其中每个浮点数在小数点后显示恰好 8 位数字，并且行内任何地方都没有空格。\n\n所有三角函数求值的角度单位必须是弧度。不涉及任何物理单位。\n\n测试套件：\n- $n=1$ （单个节点的边界情况）。\n- $n=5$ （中等次数）。\n- $n=10$ （较高次数）。\n- $n=25$ （插值数值稳定性的压力测试）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$），其中每个 $a_i$ 和 $b_i$ 都是四舍五入到 8 位小数的浮点数。",
            "solution": "在尝试任何解决方案之前，首先对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 待插值的函数：$f(x) = \\dfrac{1}{1+25x^2}$。\n- 插值定义域：$x \\in [-1, 1]$。\n- 多项式次数集合：$n \\in \\{1, 5, 10, 25\\}$。\n- 插值节点：对于每个 $n$，有两组各含 $n$ 个节点。\n    - (a) Legendre 节点：Legendre 多项式 $P_n(x)$ 的 $n$ 个不同实根。\n    - (b) 第一类 Chebyshev 节点：$x_k = \\cos\\left(\\dfrac{(2k-1)\\pi}{2n}\\right)$，其中 $k=1, 2, \\dots, n$。\n- 插值多项式：对于每组节点集，存在一个次数至多为 $n-1$ 的唯一多项式 $p_{n-1}(x)$。\n- 误差评估网格：在 $[-1, 1]$ 上的一个包含 $M=2001$ 个点的均匀网格 $G$，包含端点。\n- 误差度量：$E = \\max_{x \\in G} |f(x) - p_{n-1}(x)|$。\n- 要求输出：对于每个 $n$，误差 $E_{\\text{Leg}}$ 和 $E_{\\text{Cheb}}$ 需四舍五入到 8 位小数。\n- 最终输出格式：单行字符串 `[[...],[...],[...],[...]]`。\n\n步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行分析。\n- **科学上成立**：这是一个数值分析中的标准练习，特别是在多项式逼近理论方面。它涉及比较不同插值节点选择，这是计算科学中的一个基本课题。函数 $f(x) = \\dfrac{1}{1+25x^2}$ 是经典的 Runge 函数，用于演示高次多项式插值可能出现的发散现象。使用 Legendre 和 Chebyshev 节点是减轻这种被称为 Runge 现象的发散的成熟技术。该问题在科学上是正确且相关的。\n- **适定性**：问题是适定的。对于任意一组 $n$ 个不同的节点，存在一个次数至多为 $n-1$ 的唯一插值多项式。已知 Legendre 多项式 $P_n(x)$ 的根和指定的 Chebyshev 节点是区间 $(-1, 1)$ 内的 $n$ 个不同的实数。计算误差的说明是明确的。\n- **客观性**：问题以精确、客观和数学化的语言陈述。所有量和过程都得到了形式化定义。\n\n问题陈述没有表现出任何缺陷。它不是科学上不成立、无法形式化、不完整、相互矛盾、不切实际或不适定的。\n\n步骤 3：结论与行动\n问题被判定为**有效**。将提供一个解决方案。\n\n任务是比较两组插值节点——Legendre 多项式的根和第一类 Chebyshev 节点——在区间 $[-1, 1]$ 上对 Runge 函数 $f(x) = \\dfrac{1}{1+25x^2}$ 进行插值的效果。比较的依据是函数与其多项式插值在不同多项式次数 $n$ 下的最大绝对误差。\n\n问题的核心在于多项式插值理论。给定 $n$ 个不同的点 $(x_j, y_j)$（$j=0, \\dots, n-1$），存在一个次数至多为 $n-1$ 的唯一多项式 $p_{n-1}(x)$，使得对所有 $j$ 都有 $p_{n-1}(x_j) = y_j$。虽然这个多项式是唯一的，但它作为对整个区间上某一底层函数 $f(x)$（其中 $y_j = f(x_j)$）的近似的质量，高度依赖于节点 $x_j$ 的选择。\n\n对于高次插值，特别是对于像给定函数 $f(x)$ 这样的函数，天真地选择等距节点可能会导致灾难性的结果。当 $n \\to \\infty$ 时，误差在区间端点附近可能会无界增长，这种病态现象被称为 Runge 现象。\n\n为了克服这个问题，必须使用在区间端点附近分布更密集的节点。正交多项式的根是一个极好的选择。本问题研究了两种这样的节点集：\n1.  **Legendre 节点**：Legendre 多项式 $P_n(x)$ 的根，这些多项式是关于权重函数 $w(x)=1$ 在 $[-1, 1]$ 上的正交多项式。这些节点也是 Gauss-Legendre 求积的节点，其设计旨在为多项式积分达到尽可能高的精度。\n2.  **Chebyshev 节点**：第一类 Chebyshev 多项式 $T_n(x)$ 的根。这些节点是半圆上等距点在 $x$ 轴上的投影。已证明，在这些节点上进行插值可以最小化 Lebesgue 常数（该常数是插值误差的一个上界），并且在极小化极大意义上（最小化最大误差）是近乎最优的。\n\n对于插值多项式的数值构建和求值，我们避免使用众所周知是病态的 Vandermonde 矩阵。取而代之，我们采用重心插值公式，该公式计算效率高且数值稳定。插值函数表示为：\n$$\np_{n-1}(x) = \\frac{\\sum_{j=0}^{n-1} \\frac{w_j}{x-x_j} y_j}{\\sum_{j=0}^{n-1} \\frac{w_j}{x-x_j}}\n$$\n其中 $y_j = f(x_j)$，重心权重 $w_j$ 由 $w_j = \\frac{1}{\\prod_{k \\neq j} (x_j - x_k)}$ 给出。这些权重仅取决于节点，而不取决于函数值，并且可以预先计算。`scipy.interpolate.BarycentricInterpolator` 类提供了此方法的稳健实现。\n\n算法如下：\n1.  定义目标函数 $f(x) = (1+25x^2)^{-1}$ 和在 $[-1, 1]$ 上的包含 $M=2001$ 个点的高分辨率评估网格 $G$。\n2.  对于每个次数参数 $n \\in \\{1, 5, 10, 25\\}$：\n    a.  **Legendre 插值**：\n        i.  使用标准数值库函数（例如 `scipy.special.roots_legendre`）计算 $P_n(x)$ 的 $n$ 个根。\n        ii. 在这些节点上计算 $f(x)$ 的值以获得 $y_j$。\n        iii. 使用节点和函数值构建一个重心插值器。\n        iv. 在网格 $G$ 上计算得到的多项式 $p_{n-1, \\text{Leg}}(x)$ 的值。\n        v.  计算最大绝对误差 $E_{\\text{Leg}} = \\max_{x \\in G} |f(x) - p_{n-1, \\text{Leg}}(x)|$。\n\n    b.  **Chebyshev 插值**：\n        i.  使用公式 $x_k = \\cos\\left( \\frac{(2k-1)\\pi}{2n} \\right)$（其中 $k=1, \\dots, n$）计算 $n$ 个 Chebyshev 节点。\n        ii. 在这些节点上计算 $f(x)$ 的值。\n        iii. 构建第二个重心插值器。\n        iv. 在网格 $G$ 上计算多项式 $p_{n-1, \\text{Cheb}}(x)$ 的值。\n        v.  计算最大绝对误差 $E_{\\text{Cheb}} = \\max_{x \\in G} |f(x) - p_{n-1, \\text{Cheb}}(x)|$。\n\n3.  对于每个 $n$，收集有序对 $[E_{\\text{Leg}}, E_{\\text{Cheb}}]$，将值四舍五入到 8 位小数，并根据问题规范将最终输出格式化为单行字符串。\n\n对于 $n=1$ 的特殊情况，单个 Legendre 根是 $x=0$（因为 $P_1(x)=x$），单个 Chebyshev 节点是 $x_1=\\cos(\\pi/2)=0$。因此，两种方法使用相同的节点，得到相同的常数插值多项式 $p_0(x) = f(0) = 1$。误差为 $\\max_{x \\in [-1,1]} |(1+25x^2)^{-1} - 1| = |(1+25(1)^2)^{-1} - 1| = 25/26 \\approx 0.96153846$。这可以作为对程序的基本检查。对于更高的 $n$，预计两种方法都会表现出良好的收敛性，由于 Chebyshev 节点的极小化极大性质，它们通常会产生略低的最大误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Constructs and compares polynomial interpolants for the Runge function\n    using Legendre and Chebyshev nodes, and computes the maximum absolute error.\n    \"\"\"\n    # Define the set of degrees to test\n    degrees = [1, 5, 10, 25]\n\n    # Define the high-resolution grid for error evaluation\n    M = 2001\n    grid_points = np.linspace(-1.0, 1.0, M)\n\n    def target_function(x):\n        \"\"\"The Runge function.\"\"\"\n        return 1.0 / (1.0 + 25.0 * x**2)\n\n    # Evaluate the function on the grid\n    f_on_grid = target_function(grid_points)\n\n    all_results = []\n\n    for n in degrees:\n        # --- Case (a): Legendre Polynomial Roots ---\n\n        # 1. Get the n roots of the Legendre polynomial P_n(x).\n        # These are the nodes for Gauss-Legendre quadrature.\n        # The function returns roots and weights; we only need the roots.\n        leg_nodes, _ = roots_legendre(n)\n\n        # 2. Evaluate the function at the Legendre nodes.\n        leg_values = target_function(leg_nodes)\n\n        # 3. Construct the interpolant using the barycentric formula for stability.\n        leg_interpolator = BarycentricInterpolator(leg_nodes, leg_values)\n        p_leg_on_grid = leg_interpolator(grid_points)\n\n        # 4. Compute the maximum absolute error on the grid.\n        error_leg = np.max(np.abs(f_on_grid - p_leg_on_grid))\n\n        # --- Case (b): Chebyshev Nodes of the First Kind ---\n\n        # 1. Get the n Chebyshev nodes, which are the roots of T_n(x).\n        k = np.arange(1, n + 1)\n        cheb_nodes = np.cos((2 * k - 1) * np.pi / (2 * n))\n        # Ensure nodes are sorted for robustness, though not strictly necessary for BarycentricInterpolator.\n        cheb_nodes = np.sort(cheb_nodes)\n\n        # 2. Evaluate the function at the Chebyshev nodes.\n        cheb_values = target_function(cheb_nodes)\n\n        # 3. Construct the interpolant.\n        cheb_interpolator = BarycentricInterpolator(cheb_nodes, cheb_values)\n        p_cheb_on_grid = cheb_interpolator(grid_points)\n\n        # 4. Compute the maximum absolute error on the grid.\n        error_cheb = np.max(np.abs(f_on_grid - p_cheb_on_grid))\n\n        # Store the pair of rounded errors for the current n\n        all_results.append([error_leg, error_cheb])\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[val1,val2],[val3,val4],...] with 8 decimal places.\n    formatted_pairs = []\n    for pair in all_results:\n        formatted_pair_str = f\"[{pair[0]:.8f},{pair[1]:.8f}]\"\n        formatted_pairs.append(formatted_pair_str)\n    \n    final_output_string = f\"[{','.join(formatted_pairs)}]\"\n\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "虽然切比雪夫节点在处理光滑函数时表现出色，但了解其局限性也同样重要。这个高级实践将探讨当我们将切比雪夫插值应用于非光滑（不连续）函数时会发生什么。通过对符号函数进行插值，你将观察到一种被称为吉布斯现象的数值伪影，即在不连续点附近出现持续的过冲振荡，这揭示了多项式逼近理论中一个深刻而普遍的特性。",
            "id": "2378797",
            "problem": "给定区间 $[-1,1]$ 上的函数 $f(x) = \\operatorname{sgn}(x)$，其中 $\\operatorname{sgn}(0) = 0$。对于每个测试用例，您必须构造一个唯一的、次数至多为 $n$ 的插值多项式 $p_n(x)$，使其在 Chebyshev–Lobatto 节点 $x_k = \\cos\\left(\\frac{\\pi k}{n}\\right)$ (其中 $k = 0,1,\\dots,n$) 上满足 $p_n(x_k) = f(x_k)$。使用 $[-1,1]$ 上的一个包含 $M = 10001$ 个点的均匀网格来评估所有需要的上确界。所有计算都是无量纲的。\n\n对于下面测试套件中的每对参数 $(n,\\varepsilon)$，计算以下四个量：\n1. $E_{\\text{away}}(n,\\varepsilon) = \\max\\{\\,|p_n(x) - f(x)| : x \\in [-1,1],\\ |x| \\ge \\varepsilon\\,\\}$。\n2. $G_{\\text{right}}(n) = \\max\\left\\{\\,0,\\ \\max\\{\\,p_n(x) - 1 : x \\in [0,1]\\,\\}\\right\\}$。\n3. $E_{\\text{point}}(n) = |p_n(0.5) - f(0.5)|$。\n4. $E_{\\text{full}}(n) = \\max\\{\\,|p_n(x) - f(x)| : x \\in [-1,1]\\,\\}$。\n\n测试套件包含以下参数对 $(n,\\varepsilon)$：\n- $(3,\\ 0.1)$\n- $(16,\\ 0.1)$\n- $(64,\\ 0.1)$\n- $(64,\\ 0.01)$\n- $(128,\\ 0.05)$\n\n您的程序必须使用上述定义和指定的网格，为每个测试用例评估全部四个量。最终输出必须是单行，包含一个由五个子列表组成的列表，每个子列表包含对应测试用例的四个结果 $[E_{\\text{away}}(n,\\varepsilon),\\ G_{\\text{right}}(n),\\ E_{\\text{point}}(n),\\ E_{\\text{full}}(n)]$，其顺序与测试套件中的顺序相同。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表形式的结果，并严格按照测试套件的顺序，例如：\n$[[e_{1,1},e_{1,2},e_{1,3},e_{1,4}],[e_{2,1},e_{2,2},e_{2,3},e_{2,4}],\\dots]$,\n其中每个 $e_{i,j}$ 是一个浮点数。",
            "solution": "所提出的问题是有效的。这是数值分析中一个明确定义的练习，其基础是成熟的多项式插值理论。任务是为一个不连续函数构建插值多项式并分析其行为，这是一个用于演示 Gibbs 现象以及不同插值节点集属性的经典问题。我们将开始解答。\n\n目标是分析在区间 $[-1,1]$ 上对符号函数 $f(x) = \\operatorname{sgn}(x)$ （并满足指定条件 $\\operatorname{sgn}(0)=0$）进行插值的、次数至多为 $n$ 的多项式 $p_n(x)$。插值在 $n+1$ 个 Chebyshev-Lobatto 节点上进行。\n\n**1. 理论框架**\n\n对于任意一组 $n+1$ 个不同的点 $\\{x_k\\}_{k=0}^n$ 和对应的值 $\\{y_k\\}_{k=0}^n$，存在一个唯一的、次数至多为 $n$ 的多项式 $p_n(x)$，使得对所有 $k$ 都有 $p_n(x_k)=y_k$。问题指定了 Chebyshev-Lobatto 节点，其公式为：\n$$\nx_k = \\cos\\left(\\frac{\\pi k}{n}\\right), \\quad k = 0, 1, \\dots, n\n$$\n这些节点是 $n$ 次第一类 Chebyshev 多项式 $T_n(x)$ 在区间 $[-1,1]$ 上的极值点。它们是多项式插值的常用且优良的选择，因为它们具有最小化插值误差界中常数的性质，这反过来又可以减轻光滑函数的 Runge 现象。\n\n待插值的函数是 $f(x) = \\operatorname{sgn}(x)$，它在 $x=0$ 处有一个跳跃间断点。不连续函数的多项式插值已知会产生非一致收敛。在间断点附近，插值多项式表现出振荡行为，其超调量不会随着次数 $n$ 的增加而减小。这被称为 Gibbs 现象。\n\n函数 $f(x) = \\operatorname{sgn}(x)$ 是一个奇函数。Chebyshev-Lobatto 节点关于原点对称，即 $x_{n-k} = -x_k$。因此，数据值 $y_k = f(x_k)$ 满足 $y_{n-k} = -y_k$。这意味着唯一的插值多项式 $p_n(x)$也必须是奇函数。\n\n**2. 构造方法**\n\n虽然插值多项式的 Lagrange 形式在理论上很有用，但其计算效率低下且可能数值不稳定。一种更优的数值计算方法是重心插值公式：\n$$\np_n(x) = \\frac{\\displaystyle\\sum_{k=0}^{n} \\frac{w_k}{x - x_k} y_k}{\\displaystyle\\sum_{k=0}^{n} \\frac{w_k}{x - x_k}}\n$$\n此公式对任何具有相应重心权重 $w_k$ 的不同节点集 $x_k$ 都有效。对于 Chebyshev-Lobatto 节点，这些权重具有简单而稳定的形式：\n$$\nw_k = (-1)^k \\delta_k, \\quad \\text{其中} \\quad \\delta_k = \\begin{cases} 1/2  \\text{若 } k=0 \\text{ 或 } k=n \\\\ 1  \\text{若 } 1 \\le k \\le n-1 \\end{cases}\n$$\n该公式数值稳定且高效。我们将使用此方法的专业级实现，即 `scipy.interpolate.BarycentricInterpolator` 类，该类已为本任务进行了优化。\n\n**3. 计算步骤**\n\n对于测试套件中的每对参数 $(n, \\varepsilon)$，执行以下步骤：\n\n1.  **生成插值数据**：计算 $n+1$ 个 Chebyshev-Lobatto 节点 $x_k$。确定相应的函数值 $y_k = \\operatorname{sgn}(x_k)$。\n2.  **构造插值多项式**：使用节点 $x_k$ 和值 $y_k$ 创建一个重心插值器的实例。该实例代表多项式 $p_n(x)$。\n3.  **定义评估网格**：在区间 $[-1,1]$ 上创建一个包含 $M=10001$ 个点的精细均匀网格，作为近似所需上确界的定义域。设此网格为 $\\{z_j\\}_{j=1}^M$。\n4.  **评估函数**：在网格上的每个点 $z_j$ 处，评估多项式 $p_n(z_j)$ 和原函数 $f(z_j)$ 的值。\n5.  **计算各量值**：根据评估的网格数据计算所需的误差度量：\n    *   $E_{\\text{away}}(n,\\varepsilon) = \\max\\{\\,|p_n(z_j) - f(z_j)| : |z_j| \\ge \\varepsilon\\,\\}$。这衡量了远离间断点的最大误差。\n    *   $G_{\\text{right}}(n) = \\max\\left\\{\\,0,\\ \\max\\{\\,p_n(z_j) - 1 : z_j \\ge 0\\,\\}\\right\\}$。这个量捕捉了区间正半部分 Gibbs 现象超调的幅度。\n    *   $E_{\\text{point}}(n) = |p_n(0.5) - f(0.5)| = |p_n(0.5) - 1|$。这是一个特定的点态误差。\n    *   $E_{\\text{full}}(n) = \\max_{j} |p_n(z_j) - f(z_j)|$。这是整个区间上的最大绝对误差，代表了误差函数的 $L_\\infty$ 范数。\n\n这种对成熟数值方法的系统性应用确保了问题解答的正确性和可复现性。实现将在下一节中提供。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Constructs a Chebyshev-Lobatto interpolant for sgn(x) and computes\n    various error metrics for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0.1),\n        (16, 0.1),\n        (64, 0.1),\n        (64, 0.01),\n        (128, 0.05),\n    ]\n\n    # Define the high-resolution uniform grid for evaluating suprema.\n    M = 10001\n    eval_grid_x = np.linspace(-1.0, 1.0, M)\n    \n    # Evaluate the true function on the grid. np.sign(0) is 0.\n    func_values_f = np.sign(eval_grid_x)\n\n    results = []\n    for n, epsilon in test_cases:\n        # Step 1: Generate interpolation data at Chebyshev-Lobatto nodes.\n        # Nodes are x_k = cos(pi*k/n) for k = 0, ..., n.\n        k_indices = np.arange(n + 1)\n        nodes_xk = np.cos(np.pi * k_indices / n)\n        \n        # Function values at the nodes.\n        values_yk = np.sign(nodes_xk)\n\n        # Step 2: Construct the polynomial interpolant p_n(x).\n        # BarycentricInterpolator is highly efficient and stable, especially\n        # for Chebyshev points.\n        p_n = BarycentricInterpolator(nodes_xk, values_yk)\n\n        # Step 3: Evaluate the interpolant p_n(x) on the fine grid.\n        poly_values_p = p_n(eval_grid_x)\n\n        # Step 4: Compute the error vector on the grid.\n        error_values = poly_values_p - func_values_f\n\n        # Step 5: Calculate the four required quantities.\n\n        # 1. E_away(n, epsilon): Max error away from the discontinuity.\n        mask_away = np.abs(eval_grid_x) >= epsilon\n        e_away = np.max(np.abs(error_values[mask_away]))\n\n        # 2. G_right(n): Max overshoot on the right side [0, 1].\n        # f(x) = 1 for x in (0, 1]. The error is p_n(x) - 1.\n        mask_right = eval_grid_x >= 0\n        g_right = np.max(np.maximum(0.0, poly_values_p[mask_right] - 1.0))\n\n        # 3. E_point(n): Pointwise error at x = 0.5.\n        # f(0.5) is sign(0.5) which is 1.0.\n        p_at_0_5 = p_n(0.5)\n        e_point = np.abs(p_at_0_5 - 1.0) \n\n        # 4. E_full(n): Max error over the entire interval [-1, 1].\n        e_full = np.max(np.abs(error_values))\n\n        results.append([e_away, g_right, e_point, e_full])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, sublist))}]\" for sublist in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}