{
    "hands_on_practices": [
        {
            "introduction": "When using explicit time-stepping schemes with Discontinuous Galerkin methods, stability is not guaranteed. The time step size must be chosen carefully to prevent the numerical solution from becoming unstable. This exercise guides you through an energy analysis to derive the famous Courant–Friedrichs–Lewy (CFL) condition for a 1D advection problem, revealing how the maximum stable time step depends not only on the mesh size $h$ and wave speed $a$ but critically on the polynomial order $p$ of the approximation. ",
            "id": "2443069",
            "problem": "A constant-coefficient linear advection initial-value problem is posed on a periodic one-dimensional domain. Consider the partial differential equation $u_{t} + a\\,u_{x} = 0$ on $x \\in [0,L]$ with constant advection speed $a \\in \\mathbb{R}$ and periodic boundary conditions. The domain is partitioned into a uniform mesh of $N$ elements of width $h = L/N$. On each element, approximate $u$ by a polynomial of degree $p$ and construct a Discontinuous Galerkin (DG) semidiscretization using test functions from the same polynomial space. Use the upwind numerical flux at element interfaces. Advance the resulting system in time using the explicit forward Euler method.\n\nStarting from the weak form on each element and the definition of the DG numerical flux, derive a sufficient time-step restriction required by the Courant–Friedrichs–Lewy (CFL) condition for stability of the explicit time marching. Your derivation must:\n- Begin from the semidiscrete energy in the elementwise mass inner product and explain how interface terms control the growth of the energy.\n- Use only standard one-dimensional polynomial facts as the base, such as the sharp trace inequality for polynomials of degree $p$ on an interval, and the periodicity of the domain to eliminate global boundary terms.\n- Clearly identify how the dependence on the polynomial order $p$ arises in the final restriction.\n\nThen, evaluate your result for the concrete parameters $L = 1.0$ m, $N = 50$, $a = 1.5$ m/s, and $p = 2$. Report the maximum stable time step as a single real number rounded to four significant figures. Express the final time step in seconds (s).",
            "solution": "The problem requires the derivation of a sufficient time-step restriction for a Discontinuous Galerkin (DG) method applied to the one-dimensional linear advection equation, followed by a numerical evaluation. The derivation must be based on an energy analysis for the explicit forward Euler time integration scheme.\n\nThe governing partial differential equation (PDE) is the linear advection equation:\n$$u_t + a u_x = 0$$\non a periodic domain $x \\in [0,L]$ with constant advection speed $a$.\n\nFirst, we establish the semi-discrete DG formulation. The domain is divided into $N$ uniform elements $I_j = [x_{j-1/2}, x_{j+1/2}]$ of width $h = L/N$. The approximate solution $u_h(x,t)$ is sought in the space $V_h$ of functions that are polynomials of degree up to $p$ on each element $I_j$.\nThe weak formulation on an element $I_j$ is obtained by multiplying the PDE by a test function $v_h \\in P^p(I_j)$ and integrating over $I_j$:\n$$\\int_{I_j} (u_h)_t v_h \\,dx + \\int_{I_j} a (u_h)_x v_h \\,dx = 0$$\nApplying integration by parts to the advection term gives:\n$$\\int_{I_j} (u_h)_t v_h \\,dx - \\int_{I_j} a u_h (v_h)_x \\,dx + [a u_h v_h]_{x_{j-1/2}}^{x_{j+1/2}} = 0$$\nThe boundary term is $[a u_h v_h]_{x_{j-1/2}}^{x_{j+1/2}} = a u_h(x_{j+1/2}^-)v_h(x_{j+1/2}^-) - a u_h(x_{j-1/2}^+)v_h(x_{j-1/2}^+)$. In DG, the solution is discontinuous across element interfaces. The single-valued flux $a u_h$ is replaced by a numerical flux $\\hat{f}(u_h^-, u_h^+)$. For the upwind flux, $\\hat{f}(u^-, u^+) = a u^{\\text{upwind}}$, where $u^{\\text{upwind}}$ is the value from the upwind direction. This is $u^-$ if $a > 0$ and $u^+$ if $a  0$. This can be written compactly as $\\hat{f} = \\frac{a}{2}(u^-+u^+) - \\frac{|a|}{2}(u^+-u^-)$.\n\nThe DG formulation is then: for each element $I_j$, find $u_h|_{I_j} \\in P^p(I_j)$ such that for all $v_h \\in P^p(I_j)$:\n$$\\int_{I_j} (u_h)_t v_h \\,dx - \\int_{I_j} a u_h (v_h)_x \\,dx + \\hat{f}_{j+1/2}v_h(x_{j+1/2}^-) - \\hat{f}_{j-1/2}v_h(x_{j-1/2}^+) = 0$$\nwhere $\\hat{f}_{j+1/2} = \\hat{f}(u_h(x_{j+1/2}^-), u_h(x_{j+1/2}^+))$.\n\nTo perform the energy analysis, we set the test function $v_h = u_h$. The first term becomes $\\frac{1}{2}\\frac{d}{dt}\\int_{I_j} u_h^2 \\,dx$. The second term is $-\\int_{I_j} a u_h (u_h)_x \\,dx = -\\frac{a}{2}\\int_{I_j} \\frac{d}{dx}(u_h^2) \\,dx = -\\frac{a}{2}[u_h^2(x_{j+1/2}^-) - u_h^2(x_{j-1/2}^+)]$.\nSubstituting these into the weak form gives:\n$$\\frac{1}{2}\\frac{d}{dt}\\int_{I_j} u_h^2 \\,dx - \\frac{a}{2}(u_h(x_{j+1/2}^-)^2 - u_h(x_{j-1/2}^+)^2) + \\hat{f}_{j+1/2}u_h(x_{j+1/2}^-) - \\hat{f}_{j-1/2}u_h(x_{j-1/2}^+) = 0$$\nLet $\\|u_h\\|^2 = \\sum_{j=1}^N \\int_{I_j} u_h^2 \\,dx$ be the total energy. Summing the local energy equation over all elements $j=1, \\dots, N$:\n$$ \\frac{1}{2}\\frac{d}{dt}\\|u_h\\|^2 + \\sum_{j=1}^N \\left( -\\frac{a}{2}(u_h(x_{j+1/2}^-)^2 - u_h(x_{j-1/2}^+)^2) + \\hat{f}_{j+1/2}u_h(x_{j+1/2}^-) - \\hat{f}_{j-1/2}u_h(x_{j-1/2}^+) \\right) = 0 $$\nThe terms involving interface values form a telescoping sum. At a generic interface $x_{k+1/2}$ between elements $I_k$ and $I_{k+1}$, the contributions are:\nFrom $I_k$ (at its right boundary): $-\\frac{a}{2}u_h(x_{k+1/2}^-)^2 + \\hat{f}_{k+1/2}u_h(x_{k+1/2}^-)$\nFrom $I_{k+1}$ (at its left boundary): $+\\frac{a}{2}u_h(x_{k+1/2}^+)^2 - \\hat{f}_{k+1/2}u_h(x_{k+1/2}^+)$\nThe sum of interface terms at $x_{k+1/2}$ is $\\frac{a}{2}(u_h(x_{k+1/2}^+)^2 - u_h(x_{k+1/2}^-)^2) - \\hat{f}_{k+1/2}[u_h]_{k+1/2}$, where $[u_h] = u_h^+ - u_h^-$.\nSubstituting the upwind flux $\\hat{f}_{k+1/2} = \\frac{a}{2}(u_h^-+u_h^+) - \\frac{|a|}{2}[u_h]$:\n$$\\text{Sum} = \\frac{a}{2}(u_h^+ + u_h^-)[u_h] - \\left( \\frac{a}{2}(u_h^-+u_h^+) - \\frac{|a|}{2}[u_h] \\right)[u_h] = \\frac{|a|}{2}[u_h]_{k+1/2}^2$$\nDue to periodicity, there are no global boundary terms. The semi-discrete energy equation becomes:\n$$\\frac{d}{dt}\\|u_h\\|^2 = -|a| \\sum_{k=1}^N [u_h]_{k-1/2}^2 \\le 0$$\nThis shows the semi-discretization is energy-dissipative (or stable), with dissipation occurring at interfaces where the solution has a jump.\n\nNext, we consider the fully discrete scheme using forward Euler time integration. The semi-discrete system can be written as $\\frac{d}{dt}u_h = L_h(u_h)$. The forward Euler method is $u_h^{n+1} = u_h^n + \\Delta t L_h(u_h^n)$.\nThe energy at time step $n+1$ is:\n$$\\|u_h^{n+1}\\|^2 = \\|u_h^n + \\Delta t L_h(u_h^n)\\|^2 = \\|u_h^n\\|^2 + 2\\Delta t (u_h^n, L_h(u_h^n)) + \\Delta t^2 \\|L_h(u_h^n)\\|^2$$\nwhere $(f,g) = \\sum_j \\int_{I_j} fg \\,dx$. From the semi-discrete analysis, $(u_h, L_h(u_h)) = \\frac{1}{2}\\frac{d}{dt}\\|u_h\\|^2 = -\\frac{|a|}{2}\\sum_k [u_h]_k^2$.\nSubstituting this into the energy evolution equation gives:\n$$\\|u_h^{n+1}\\|^2 = \\|u_h^n\\|^2 - \\Delta t |a| \\sum_k [u_h^n]_k^2 + \\Delta t^2 \\|L_h(u_h^n)\\|^2$$\nFor stability, we require $\\|u_h^{n+1}\\|^2 \\le \\|u_h^n\\|^2$. This leads to the condition:\n$$\\Delta t^2 \\|L_h(u_h^n)\\|^2 \\le \\Delta t |a| \\sum_k [u_h^n]_k^2$$\nFor any solution where jumps exist ($\\sum [u_h]^2 \\ne 0$), we must have:\n$$ \\Delta t \\le \\frac{|a| \\sum_k [u_h^n]_k^2}{\\|L_h(u_h^n)\\|^2}$$\nThis condition must hold for any non-trivial solution $u_h \\in V_h$. Therefore, we need a time-step restriction based on the minimum of the right-hand side over all $u_h$. This requires an estimate relating the operator norm $\\|L_h(u_h)\\|$ to the dissipation term $\\sum [u_h]^2$. Such an estimate can be derived using inverse and trace inequalities for polynomials. A simple application of such inequalities leads to a pessimistic time-step restriction scaling with $1/p^4$ or $1/p^2$.\n\nA sharper result is obtained from a spectral analysis of the operator $L_h$. The stability of the forward Euler method requires that for all eigenvalues $\\lambda$ of $L_h$, the value $1+\\Delta t \\lambda$ must lie within the unit circle in the complex plane. This imposes the constraint $\\Delta t \\le \\min_{\\lambda \\ne 0} \\frac{-2 \\text{Re}(\\lambda)}{|\\lambda|^2}$.\nA detailed spectral analysis for the one-dimensional DG operator with upwind flux shows that the eigenvalues are constrained in such a way that the most restrictive condition scales inversely with the polynomial degree $p$. It is a standard result in the analysis of DG methods that this leads to a sufficient time-step restriction of the form:\n$$\\Delta t \\le \\frac{h}{|a|(2p+1)}$$\nThe factor $(2p+1)$ arises from the spectral properties of the discrete differentiation operator combined with the flux terms, especially relating to the behavior of high-frequency modes on the mesh. While a full derivation of this factor from first principles is highly technical and relies on advanced properties of orthogonal polynomials, it is the established sharp result for this scheme. The dependence on $p$ is a direct consequence of the trace inverse inequality for polynomials of degree $p$, which establishes that for a polynomial $v$, $\\|v'\\|_{L^2(I_j)}$ can be bounded by its values at the trace, and these values are what constitute the jumps that provide dissipation. This relationship is keenest for high-order polynomials, requiring smaller time steps to maintain stability.\n\nNow, we evaluate this restriction for the given parameters: $L = 1.0$ m, $N = 50$, $a = 1.5$ m/s, and $p = 2$.\nThe element width is $h = L/N = 1.0 / 50 = 0.02$ m.\nThe advection speed is $|a| = 1.5$ m/s.\nThe polynomial degree is $p=2$.\nThe maximum stable time step $\\Delta t_{\\text{max}}$ is:\n$$\\Delta t_{\\text{max}} = \\frac{h}{|a|(2p+1)} = \\frac{0.02}{1.5 \\times (2 \\cdot 2 + 1)} = \\frac{0.02}{1.5 \\times 5} = \\frac{0.02}{7.5}$$\n$$\\Delta t_{\\text{max}} = \\frac{2}{750} = \\frac{1}{375} \\approx 0.002666... \\text{ s}$$\nRounding to four significant figures, we get $\\Delta t_{\\text{max}} = 0.002667$ s.\nThe final answer is required as a single real number.",
            "answer": "$$\\boxed{0.002667}$$"
        },
        {
            "introduction": "The stability of DG methods for elliptic problems, such as the Symmetric Interior Penalty Galerkin (SIPG) method for the Poisson equation, hinges on a mathematical property called coercivity. While a method may be stable in theory, translating it into a working computer program introduces approximations, such as numerical quadrature to compute integrals. This practice explores what happens when these integrals are not computed accurately enough, a situation known as under-integration, providing a critical lesson on how implementation choices can impact the stability and convergence of the scheme. ",
            "id": "2386861",
            "problem": "Consider the scalar Poisson problem on a bounded Lipschitz domain $\\Omega \\subset \\mathbb{R}^d$ with homogeneous Dirichlet boundary conditions,\n$$\n-\\nabla \\cdot \\left(\\kappa \\nabla u \\right) = f \\quad \\text{in } \\Omega, \n\\qquad u = 0 \\quad \\text{on } \\partial \\Omega,\n$$\nwhere $\\kappa(\\boldsymbol{x}) \\ge \\kappa_{\\min}  0$ is a given coefficient and $f$ is a given source. Let $\\mathcal{T}_h$ be a shape-regular mesh of $\\Omega$, and let $V_h$ be the discontinuous finite element space of piecewise polynomials of total degree at most $p \\ge 1$ on $\\mathcal{T}_h$. Consider the standard symmetric interior penalty discontinuous Galerkin (DG) method, in which the stiffness matrix arises from a bilinear form obtained by integrating element-wise gradient terms and face terms that couple element traces through jumps, averages, and a penalty.\n\nSuppose that, when assembling the stiffness matrix, you replace all exact integrals in the bilinear form with numerical quadrature rules that are under-integrated relative to the polynomial degrees of the integrands. In particular, the chosen quadrature rules do not integrate exactly the polynomial (or mapped polynomial) degrees appearing in the element gradient terms and face terms.\n\nWhich of the following outcomes is the most accurate description of what can happen due to this under-integration?\n\nA. The discrete bilinear form can lose coercivity in the DG energy norm, leading to spurious zero-energy (hourglass) modes, mesh-dependent oscillations, and possible instability or loss of convergence.\n\nB. Only the right-hand side load vector is affected, producing at most a constant shift; the stiffness matrix still represents the same operator with the same stability and convergence properties.\n\nC. Choosing a sufficiently large penalty parameter completely eliminates any adverse effect of under-integration on stability and accuracy.\n\nD. The stiffness matrix necessarily becomes non-symmetric even though the symmetric interior penalty formulation is used.\n\nE. Under-integration acts as additional numerical diffusion that always improves stability and never reduces accuracy.",
            "solution": "The user requires an analysis of the consequences of under-integrating the bilinear form in a symmetric interior penalty discontinuous Galerkin (SIPG) method for the Poisson problem.\n\n### Problem Statement Validation\n\nFirst, I shall validate the problem statement.\n\n**Step 1: Extract Givens**\n- **Partial Differential Equation**: $-\\nabla \\cdot \\left(\\kappa \\nabla u \\right) = f$ in a bounded Lipschitz domain $\\Omega \\subset \\mathbb{R}^d$.\n- **Boundary Conditions**: $u = 0$ on $\\partial \\Omega$ (homogeneous Dirichlet).\n- **Coefficient**: $\\kappa(\\boldsymbol{x}) \\ge \\kappa_{\\min}  0$.\n- **Source Term**: $f(\\boldsymbol{x})$.\n- **Mesh**: $\\mathcal{T}_h$, a shape-regular mesh of $\\Omega$.\n- **Finite Element Space**: $V_h$, the space of piecewise polynomials of total degree at most $p \\ge 1$.\n- **Numerical Method**: Symmetric Interior Penalty Discontinuous Galerkin (SIPG).\n- **Core issue**: The exact integrals for the stiffness matrix bilinear form are replaced by numerical quadrature rules that are \"under-integrated,\" meaning they do not integrate the resulting polynomials exactly.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is well-grounded in the theory of numerical analysis for partial differential equations, specifically within the field of finite element methods. The Poisson equation, the SIPG method, and the concept of numerical quadrature are standard topics.\n- **Well-Posedness**: The question asks for the consequences of a specific procedural choice (under-integration) within a well-defined numerical algorithm. This is a standard question in an advanced numerical methods course, and it has a definite answer based on the mathematical theory of stability and convergence.\n- **Objectivity**: The problem is stated in precise, objective, and technical language, free from ambiguity or subjective claims.\n- **Completeness and Consistency**: The problem provides sufficient context to understand the setup. There are no missing definitions or contradictory statements.\n- **Realism**: Under-integration is a real-world consideration in computational code implementation, sometimes used deliberately to reduce computational cost (known as \"reduced integration\"). Analyzing its consequences is therefore a practical and important task.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is a standard, well-posed question in computational science. I will proceed with a detailed solution.\n\n### Derivation and Option Analysis\n\nThe DG method seeks a solution $u_h \\in V_h$ such that for all test functions $v_h \\in V_h$, the following holds:\n$$a_h(u_h, v_h) = l_h(v_h)$$\nwhere $l_h(v_h) = \\int_\\Omega f v_h \\, d\\boldsymbol{x}$ is the linear form for the load vector and $a_h(u_h, v_h)$ is the SIPG bilinear form for the stiffness matrix. The SIPG bilinear form is given by:\n$$\na_h(u_h, v_h) = \\sum_{K \\in \\mathcal{T}_h} \\int_K \\kappa \\nabla u_h \\cdot \\nabla v_h \\, d\\boldsymbol{x} - \\sum_{e \\in \\mathcal{F}_h} \\int_e \\left( \\{ \\kappa \\nabla u_h \\} \\cdot \\llbracket v_h \\rrbracket + \\{ \\kappa \\nabla v_h \\} \\cdot \\llbracket u_h \\rrbracket \\right) ds + \\sum_{e \\in \\mathcal{F}_h} \\int_e \\sigma_e \\llbracket u_h \\rrbracket \\cdot \\llbracket v_h \\rrbracket ds\n$$\nHere, $\\mathcal{F}_h$ is the set of all faces, $\\{ \\cdot \\}$ denotes the average, $\\llbracket \\cdot \\rrbracket$ denotes the jump operator across a face, and $\\sigma_e$ is the penalty parameter, which depends on the local mesh size $h_e$ and polynomial degree $p$.\n\nThe stability of the method is guaranteed by the coercivity of the bilinear form $a_h(\\cdot, \\cdot)$ in the DG energy norm, defined by $\\|v_h\\|_{DG}^2 = a_h(v_h, v_h)$ (for a sufficiently large penalty parameter). Specifically, there exists a constant $C_{coer} > 0$ such that:\n$$\na_h(v_h, v_h) \\ge C_{coer} \\|v_h\\|^2_{DG} \\quad \\forall v_h \\in V_h\n$$\nwhere\n$$\n\\|v_h\\|^2_{DG} = \\sum_{K \\in \\mathcal{T}_h} \\int_K \\kappa |\\nabla v_h|^2 \\, d\\boldsymbol{x} + \\sum_{e \\in \\mathcal{F}_h} \\int_e \\sigma_e |\\llbracket v_h \\rrbracket|^2 ds\n$$\nThis coercivity ensures that the resulting stiffness matrix $A$ is symmetric and positive-definite, which guarantees a unique and stable solution.\n\nThe problem states that the exact integrals $\\int$ are replaced with inexact numerical quadrature, which we denote by $(\\cdot)_q$. The discrete bilinear form becomes $a_{h,q}(u_h, v_h)$. The fundamental issue with under-integration is that the resulting discrete form $a_{h,q}(v_h, v_h)$ may no longer be positive for all non-zero $v_h \\in V_h$.\n\nConsider a non-zero function $v_h \\in V_h$. The integrands in $a_h(v_h, v_h)$, such as $\\kappa |\\nabla v_h|^2$ and $\\sigma_e |\\llbracket v_h \\rrbracket|^2$, are non-negative polynomials. If the quadrature rule is under-integrated, it might use a set of quadrature points where these polynomial integrands happen to be zero. For instance, if $\\nabla v_h$ is zero at all element quadrature points and $\\llbracket v_h \\rrbracket$ is zero at all face quadrature points, the quadrature-based norm would be zero: $\\|v_h\\|_{DG,q}^2 = 0$. This can happen even if $v_h$ is not the zero function.\n\nA non-zero function $v_h$ for which the discrete energy $a_{h,q}(v_h, v_h)$ is zero or negative is called a **spurious mode** or **zero-energy mode**. The term **hourglass mode** is a classic example from structural mechanics using low-order elements. If such modes exist, the discrete stiffness matrix $A_q$ is no longer positive-definite. It becomes singular (if $a_{h,q}(v_h, v_h) = 0$) or indefinite (if $a_{h,q}(v_h, v_h)  0$).\n\nA singular stiffness matrix means the linear system $A_q \\boldsymbol{U} = \\boldsymbol{F}$ does not have a unique solution. The solution is polluted by arbitrary multiples of these spurious modes, leading to severe, non-physical oscillations. This is a manifestation of numerical instability. This instability destroys the convergence properties of the method; refining the mesh will not lead to a better solution. Thus, under-integration can cause a loss of coercivity, leading to instability.\n\nNow I will analyze each option.\n\n**A. The discrete bilinear form can lose coercivity in the DG energy norm, leading to spurious zero-energy (hourglass) modes, mesh-dependent oscillations, and possible instability or loss of convergence.**\nThis statement is a precise and correct summary of the discussion above. Loss of coercivity is the fundamental mathematical failure. Spurious zero-energy modes are the vectors in the kernel of the under-integrated stiffness operator. These modes manifest as non-physical oscillations in the solution. The combined effect is numerical instability and a loss of the theoretical convergence rate.\n**Verdict: Correct.**\n\n**B. Only the right-hand side load vector is affected, producing at most a constant shift; the stiffness matrix still represents the same operator with the same stability and convergence properties.**\nThis is incorrect. The problem explicitly states that the integrals in the **bilinear form** are under-integrated. The bilinear form defines the stiffness matrix. An error in the bilinear form directly affects the operator, its stability, and its convergence properties. An error in the right-hand side `load vector` would be a separate issue, but the defect described here is in the matrix itself.\n**Verdict: Incorrect.**\n\n**C. Choosing a sufficiently large penalty parameter completely eliminates any adverse effect of under-integration on stability and accuracy.**\nThis is incorrect. The penalty parameter $\\sigma_e$ is a multiplicative factor within the penalty term integral, $\\int_e \\sigma_e |\\llbracket v_h \\rrbracket|^2 ds$. If the quadrature rule is so poor that it evaluates this integral as zero for a spurious mode (e.g., if $\\llbracket v_h \\rrbracket$ is zero at all face quadrature points), then increasing $\\sigma_e$ will have no effect. The computed integral will remain zero regardless of the magnitude of $\\sigma_e$. A large penalty cannot compensate for a quadrature rule that is \"blind\" to certain polynomial behaviors.\n**Verdict: Incorrect.**\n\n**D. The stiffness matrix necessarily becomes non-symmetric even though the symmetric interior penalty formulation is used.**\nThis is incorrect. The SIPG bilinear form $a_h(u, v)$ is symmetric by construction: $a_h(u,v) = a_h(v,u)$. Numerical quadrature is a linear operation, typically a weighted sum of integrand values. Applying a linear functional $(\\cdot)_q$ to a symmetric form preserves symmetry: $a_{h,q}(u, v) = (a_h(u,v))_q = (a_h(v,u))_q = a_{h,q}(v,u)$. Therefore, the resulting stiffness matrix $A_q$ remains symmetric. Loss of symmetry is not a characteristic of under-integration for a symmetric formulation.\n**Verdict: Incorrect.**\n\n**E. Under-integration acts as additional numerical diffusion that always improves stability and never reduces accuracy.**\nThis statement is the opposite of what happens. Under-integration typically degrades stability by creating spurious modes, making the system less robust, not more. Numerical diffusion is a mechanism that damps oscillations and is associated with increased stability. Furthermore, using an inexact quadrature rule introduces a quadrature error, which reduces the overall accuracy of the method and can lower the order of convergence. The claim that it \"never reduces accuracy\" is false.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The theoretical advantages of high-order DG methods, such as their ability to represent complex solutions accurately on coarse meshes, must be weighed against their practical computational costs. In large-scale 3D simulations, memory usage can become a significant bottleneck. This exercise involves creating a detailed memory model to compare the footprint of a high-order DG scheme against a more traditional high-order finite difference method for the 3D wave equation, offering tangible insight into the resource trade-offs inherent in choosing a numerical method. ",
            "id": "2386839",
            "problem": "You are tasked with building a small program that computes and compares the memory footprint of two spatial discretization strategies for the three-dimensional acoustic wave equation in first-order form with pressure and velocity components. The two strategies are: a discontinuous Galerkin method on tensor-product hexahedral elements and a high-order central finite difference method on a uniform Cartesian grid. In both cases, the number of physical state variables is fixed at $S=4$ (pressure $p$ and the three velocity components $v_x$, $v_y$, $v_z$). All scalar fields are stored in double precision with $8$ bytes per stored value. Your program must compute the memory usage in mebibytes (MiB), where $1$ MiB $=2^{20}$ bytes, and return results rounded to three decimals.\n\nDefinitions and memory model:\n\n- Domain resolution matching: For a fair comparison, let the discontinuous Galerkin discretization use $N_e$ elements per spatial dimension and a nodal polynomial degree $p$ per element with a tensor-product basis. The corresponding uniform-grid resolution for the finite difference method is defined as $N=N_e\\,(p+1)$ interior points per dimension.\n\n- Discontinuous Galerkin (DG):\n  - Let the number of elements be $E=N_e^3$.\n  - Each element has $N_p=(p+1)^3$ volume nodes and $N_f=(p+1)^2$ face nodes on each face.\n  - Per element, the following arrays are stored:\n    1. Solution array $Q$ of size $S\\,N_p$.\n    2. Residual or scratch array $R$ of size $S\\,N_p$.\n    3. Face trace buffers storing both interior ($-$) and exterior ($+$) traces for all faces and variables: total size $6\\cdot 2\\cdot S\\cdot N_f$.\n    4. A background wave-speed field $c$ stored at all volume nodes: size $N_p$.\n  - All counts above are per element and must be multiplied by $E$ to obtain the total number of stored scalars. Multiply by $8$ to obtain bytes and divide by $2^{20}$ to convert to MiB.\n\n- High-order finite difference (FD) of formal order $2m$ using central stencils:\n  - Interior grid has $N\\times N\\times N$ points with $N=N_e\\,(p+1)$.\n  - The stencil radius is $m$, so a halo of width $m$ points is stored on all sides. The total grid including halo has $(N+2m)^3$ points.\n  - The following arrays are stored:\n    1. Solution array $Q$ over the halo-extended grid: size $S\\,(N+2m)^3$.\n    2. Residual or scratch array $R$ over the halo-extended grid: size $S\\,(N+2m)^3$.\n    3. A background wave-speed field $c$ stored at interior grid points only: size $N^3$.\n  - Sum these counts to obtain the total number of stored scalars, then multiply by $8$ to obtain bytes and divide by $2^{20}$ to convert to MiB.\n\nYour program must implement the above model precisely and, for each test case, compute three quantities:\n- The DG memory in MiB.\n- The FD memory in MiB.\n- The ratio (FD memory)/(DG memory) as a unitless float.\n\nExpress all three values rounded to three decimals.\n\nTest suite:\n- Case $1$: $N_e=16$, $p=3$, $m=4$.\n- Case $2$: $N_e=1$, $p=0$, $m=1$.\n- Case $3$: $N_e=8$, $p=7$, $m=8$.\n- Case $4$: $N_e=24$, $p=2$, $m=3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list in square brackets of the form $[$DG\\_MiB,FD\\_MiB,ratio$]$. Values must be rounded to three decimals. For example: $[[12.345,67.890,5.500],[...],...]$.",
            "solution": "The problem as stated is valid. It is a well-defined exercise in computational analysis, requiring the calculation and comparison of memory requirements for two standard numerical schemes: the discontinuous Galerkin (DG) method and the finite difference (FD) method, applied to the three-dimensional acoustic wave equation. The definitions, parameters, and memory models are self-contained, scientifically sound, and objective. We shall proceed with the derivation of the required formulas.\n\nThe objective is to compute the memory footprint in Mebibytes (MiB) for both the DG and FD methods, along with their ratio, for a given set of parameters. All fields are stored in double precision, which corresponds to $8$ bytes per scalar value. One Mebibyte is defined as $1$ MiB $= 2^{20}$ bytes.\n\nFirst, we establish the memory model for the discontinuous Galerkin (DG) method.\nThe physical system is described by $S=4$ state variables. The discretization is defined by $N_e$ tensor-product hexahedral elements per spatial dimension and a polynomial approximation of degree $p$ within each element.\nThe total number of elements in the domain is $E = N_e^3$.\nFor a tensor-product basis, the number of volume nodes per element is $N_p = (p+1)^3$.\nThe number of nodes on each of the $6$ faces of an element is $N_f = (p+1)^2$.\n\nThe total number of scalars stored per element is the sum of scalars for each specified array:\n1. Solution array $Q$: $S \\cdot N_p$ scalars.\n2. Residual/scratch array $R$: $S \\cdot N_p$ scalars.\n3. Face trace buffers for interior ($-$) and exterior ($+$) solutions on all $6$ faces: $6 \\cdot 2 \\cdot S \\cdot N_f = 12 S N_f$ scalars.\n4. Background wave-speed field $c$: $N_p$ scalars.\n\nThe total number of scalars per element, $M_{DG,elem}$, is therefore:\n$$M_{DG,elem} = S N_p + S N_p + 12 S N_f + N_p = (2S+1)N_p + 12 S N_f$$\nSubstituting $S=4$, we have:\n$$M_{DG,elem} = (2 \\cdot 4 + 1)(p+1)^3 + 12 \\cdot 4 \\cdot (p+1)^2 = 9(p+1)^3 + 48(p+1)^2$$\nThe total number of scalars for the entire domain, $M_{DG,total}$, is this quantity multiplied by the total number of elements $E$:\n$$M_{DG,total} = E \\cdot M_{DG,elem} = N_e^3 \\left[ 9(p+1)^3 + 48(p+1)^2 \\right]$$\nThe memory footprint in MiB is obtained by multiplying by the size of a double ($8$ bytes) and dividing by the number of bytes in a MiB ($2^{20}$):\n$$Mem_{DG} = \\frac{8 \\cdot M_{DG,total}}{2^{20}}$$\n\nNext, we establish the memory model for the high-order finite difference (FD) method.\nFor a fair comparison, the resolution is matched such that the number of interior grid points per dimension is $N = N_e(p+1)$.\nThe FD scheme is of order $2m$, which implies a stencil radius of $m$ points. To handle boundary conditions, a halo of width $m$ is stored on all sides of the three-dimensional grid. The total grid, including the halo, thus has dimensions $(N+2m) \\times (N+2m) \\times (N+2m)$.\n\nThe total number of scalars stored for the FD method is the sum from the following arrays:\n1. Solution array $Q$ on the halo-extended grid: $S \\cdot (N+2m)^3$ scalars.\n2. Residual/scratch array $R$ on the halo-extended grid: $S \\cdot (N+2m)^3$ scalars.\n3. Background wave-speed field $c$ on the interior grid only: $N^3$ scalars.\n\nThe total number of scalars for the FD method, $M_{FD,total}$, is:\n$$M_{FD,total} = S(N+2m)^3 + S(N+2m)^3 + N^3 = 2S(N+2m)^3 + N^3$$\nSubstituting $S=4$ and $N = N_e(p+1)$, we obtain:\n$$M_{FD,total} = 2 \\cdot 4 \\cdot (N_e(p+1)+2m)^3 + (N_e(p+1))^3 = 8(N_e(p+1)+2m)^3 + (N_e(p+1))^3$$\nThe memory footprint in MiB is calculated similarly:\n$$Mem_{FD} = \\frac{8 \\cdot M_{FD,total}}{2^{20}}$$\n\nFinally, the required ratio is the memory of the FD method divided by the memory of the DG method:\n$$Ratio = \\frac{Mem_{FD}}{Mem_{DG}}$$\n\nThese formulas will be implemented to compute the required values for each test case. All results will be rounded to three decimal places as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the memory footprint of Discontinuous Galerkin (DG)\n    and Finite Difference (FD) methods for the 3D acoustic wave equation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Ne, p, m)\n    test_cases = [\n        (16, 3, 4),\n        (1, 0, 1),\n        (8, 7, 8),\n        (24, 2, 3),\n    ]\n\n    # Global constants\n    S = 4  # Number of state variables\n    BYTES_PER_SCALAR = 8\n    MIB_CONVERSION_FACTOR = 2**20\n\n    results_for_all_cases = []\n\n    for case in test_cases:\n        Ne, p, m = case\n\n        # --- Discontinuous Galerkin (DG) Memory Calculation ---\n        p1 = p + 1\n        E_dg = Ne**3\n        Np_dg = p1**3\n        Nf_dg = p1**2\n\n        # Total number of scalars stored for the DG method\n        total_scalars_dg = E_dg * ((2 * S + 1) * Np_dg + 12 * S * Nf_dg)\n        \n        # Memory in bytes and then in MiB\n        mem_dg_bytes = total_scalars_dg * BYTES_PER_SCALAR\n        mem_dg_mib = mem_dg_bytes / MIB_CONVERSION_FACTOR\n\n        # --- Finite Difference (FD) Memory Calculation ---\n        N_fd = Ne * p1\n\n        # Total number of scalars stored for the FD method\n        total_scalars_fd = 2 * S * (N_fd + 2 * m)**3 + N_fd**3\n        \n        # Memory in bytes and then in MiB\n        mem_fd_bytes = total_scalars_fd * BYTES_PER_SCALAR\n        mem_fd_mib = mem_fd_bytes / MIB_CONVERSION_FACTOR\n\n        # --- Ratio Calculation ---\n        # The ratio is computed from the unrounded memory values to maintain precision.\n        # Handling the edge case of zero DG memory, though not expected here.\n        if mem_dg_bytes == 0:\n            ratio = float('inf') if mem_fd_bytes > 0 else 0.0\n        else:\n            ratio = mem_fd_mib / mem_dg_mib\n        \n        # Store the results for the current case\n        results_for_all_cases.append([mem_dg_mib, mem_fd_mib, ratio])\n\n    # Format the final output string as specified in the problem\n    # Each value is formatted to three decimal places.\n    formatted_cases = []\n    for res in results_for_all_cases:\n        # Use f-string formatting to ensure rounding to 3 decimal places\n        formatted_res = f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\"\n        formatted_cases.append(formatted_res)\n\n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}