{
    "hands_on_practices": [
        {
            "introduction": "Our first practice focuses on the fundamental properties of Chebyshev approximation. By decomposing one-dimensional signals—representing a row of pixels—into Chebyshev polynomials, you will gain direct insight into how the approximation's accuracy depends on the smoothness of the underlying function. This exercise highlights the rapid convergence for smooth signals and introduces the challenges, like the Gibbs phenomenon, that arise when approximating discontinuities .",
            "id": "2379175",
            "problem": "Construct a program that, for a given one-dimensional sequence of pixel intensities, computes its expansion in the basis of Chebyshev polynomials of the first kind and quantifies the effect of truncating the series. Let $M$ denote the number of pixels in a single row, with pixel indices $i \\in \\{0,1,\\dots,M-1\\}$. Map pixel positions to the Chebyshev interval by $x_i = -1 + \\dfrac{2 i}{M-1}$ for all $i$. Let $\\{T_k(x)\\}_{k \\ge 0}$ denote the Chebyshev polynomials of the first kind defined on the interval $[-1,1]$ by the recurrence $T_0(x) = 1$, $T_1(x) = x$, and $T_{k+1}(x) = 2 x T_k(x) - T_{k-1}(x)$ for $k \\ge 1$. For a given integer truncation degree $N \\ge 0$, approximate a pixel row by the polynomial $p_N(x) = \\sum_{k=0}^{N} c_k T_k(x)$ whose coefficients $\\{c_k\\}_{k=0}^{N}$ minimize the discrete squared error $\\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2$ with respect to the given pixel intensities $\\{y_i\\}_{i=0}^{M-1}$. Quantify the approximation quality by the Root Mean Square Error (RMSE) defined by $\\mathrm{RMSE}(N) = \\sqrt{\\dfrac{1}{M} \\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2}$. All trigonometric function arguments are to be understood in radians.\n\nUse the following test suite. In every test case, let $M = 64$ and define $x_i$ as above. For each test case, compute $\\mathrm{RMSE}(N)$ for truncation degrees $N \\in \\{0,1,3,7,15,31\\}$.\n\nTest Case $1$ (smooth, low-to-moderate frequency content):\n- Pixel intensities: $y_i = 0.5 + 0.4 \\cos(\\pi x_i) + 0.1 \\cos(5 \\pi x_i)$ for all $i$.\n\nTest Case $2$ (step edge):\n- Pixel intensities: $y_i = 0.1$ if $x_i  0$, and $y_i = 0.9$ if $x_i \\ge 0$, for all $i$.\n\nTest Case $3$ (high-frequency oscillation):\n- Pixel intensities: $y_i = 0.5 + 0.45 \\cos(15 \\pi x_i)$ for all $i$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and structure: an outer list of length $3$ corresponding to the three test cases in the order given above, where each element is an inner list of length $6$ containing the $6$ $\\mathrm{RMSE}(N)$ values in the order $N \\in \\{0,1,3,7,15,31\\}$. For example, the format must be exactly of the form $[[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}],[r_{2,1},\\dots,r_{2,6}],[r_{3,1},\\dots,r_{3,6}]]$, where each $r_{j,\\ell}$ is a real number.",
            "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It constitutes a standard problem in numerical approximation theory, which is a fundamental component of computational physics. All parameters and objectives are defined with sufficient rigor. Therefore, we proceed to derive the solution.\n\nThe objective is to approximate a discrete signal $\\{y_i\\}_{i=0}^{M-1}$ defined on a grid of points $\\{x_i\\}_{i=0}^{M-1}$ with a truncated Chebyshev series of degree $N$. The approximation is a polynomial $p_N(x) = \\sum_{k=0}^{N} c_k T_k(x)$, where $T_k(x)$ is the Chebyshev polynomial of the first kind of degree $k$. The coefficients $\\{c_k\\}_{k=0}^{N}$ must be chosen to minimize the discrete squared error, $S$:\n$$\nS = \\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2 = \\sum_{i=0}^{M-1} \\left(\\left(\\sum_{k=0}^{N} c_k T_k(x_i)\\right) - y_i\\right)^2\n$$\nThis is a classical linear least-squares problem. We can express this in matrix-vector notation. Let $\\mathbf{y} \\in \\mathbb{R}^M$ be the column vector of pixel intensities, $\\mathbf{y} = [y_0, y_1, \\dots, y_{M-1}]^T$. Let $\\mathbf{c} \\in \\mathbb{R}^{N+1}$ be the column vector of unknown coefficients, $\\mathbf{c} = [c_0, c_1, \\dots, c_N]^T$. We define a matrix $\\mathbf{A} \\in \\mathbb{R}^{M \\times (N+1)}$ whose entries are given by the values of the basis functions at the grid points:\n$$\nA_{ik} = T_k(x_i) \\quad \\text{for } i \\in \\{0, \\dots, M-1\\}, k \\in \\{0, \\dots, N\\}\n$$\nThe vector of approximated values at the grid points is then given by the matrix-vector product $\\mathbf{p}_N = \\mathbf{A}\\mathbf{c}$. The sum of squared errors $S$ is the squared Euclidean norm of the residual vector $\\mathbf{r} = \\mathbf{A}\\mathbf{c} - \\mathbf{y}$:\n$$\nS = \\|\\mathbf{A}\\mathbf{c} - \\mathbf{y}\\|_2^2\n$$\nThe vector of coefficients $\\mathbf{c}$ that minimizes this quantity is the least-squares solution. It is formally given by the solution to the normal equations:\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{c} = \\mathbf{A}^T \\mathbf{y}\n$$\nFor numerical stability, especially when the columns of $\\mathbf{A}$ are nearly linearly dependent, it is not advisable to form and invert the matrix $\\mathbf{A}^T \\mathbf{A}$. Instead, robust numerical methods such as QR decomposition or Singular Value Decomposition (SVD) should be employed. Standard numerical libraries provide solvers that implement these stable algorithms.\n\nThe specified grid points $x_i = -1 + \\frac{2i}{M-1}$ are uniformly spaced. They are not the Chebyshev nodes (roots or extrema of $T_M(x)$). Consequently, the basis vectors $\\{ \\mathbf{v}_k \\}_{k=0}^N$, where $(\\mathbf{v}_k)_i = T_k(x_i)$, are not orthogonal with respect to the standard dot product. This necessitates solving a general least-squares system rather than simply projecting the data onto the basis vectors, which would be possible if the basis were orthogonal.\n\nThe algorithm to compute the required Root Mean Square Error (RMSE) for each test case is as follows:\n$1$. Set the number of pixels $M=64$. Define the set of truncation degrees $N \\in \\{0, 1, 3, 7, 15, 31\\}$.\n$2$. Construct the vector of grid points $\\mathbf{x} = [x_0, x_1, \\dots, x_{M-1}]^T$ where $x_i = -1 + \\frac{2i}{M-1}$.\n$3$. For each test case, generate the vector of pixel intensities $\\mathbf{y} = [y_0, y_1, \\dots, y_{M-1}]^T$ according to its specified function.\n$4$. For each truncation degree $N$ in the specified set:\n    a. Construct the $M \\times (N+1)$ matrix $\\mathbf{A}$. The columns of $\\mathbf{A}$ are the Chebyshev polynomials evaluated at the grid points. They are generated using the recurrence relation:\n    $$\n    T_0(x) = 1\n    $$\n    $$\n    T_1(x) = x\n    $$\n    $$\n    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x) \\quad \\text{for } k \\ge 1\n    $$\n    The $k$-th column of $\\mathbf{A}$ is the vector $[T_k(x_0), T_k(x_1), \\dots, T_k(x_{M-1})]^T$.\n    b. Solve the linear least-squares problem $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{y}$ to find the optimal coefficient vector $\\mathbf{c}$. This yields the minimal sum of squared residuals, $S_{min} = \\|\\mathbf{A}\\mathbf{c} - \\mathbf{y}\\|_2^2$.\n    c. Compute the approximation quality using the Root Mean Square Error:\n    $$\n    \\mathrm{RMSE}(N) = \\sqrt{\\frac{1}{M} \\sum_{i=0}^{M-1} (p_N(x_i) - y_i)^2} = \\sqrt{\\frac{S_{min}}{M}}\n    $$\n$5$. Collect the $\\mathrm{RMSE}(N)$ values for each test case and format the output as specified.\n\nThe behavior of the $\\mathrm{RMSE}(N)$ is expected to differ significantly across the test cases. For the smooth, low-frequency function in Test Case $1$, the Chebyshev series should converge very rapidly, resulting in a fast decrease of $\\mathrm{RMSE}(N)$ with increasing $N$. For the step function in Test Case $2$, the presence of a discontinuity will lead to the Gibbs phenomenon and slow convergence; the $\\mathrm{RMSE}(N)$ will decrease much more slowly. For the high-frequency function in Test Case $3$, the approximation will be poor for small $N$ but should improve dramatically once $N$ is large enough to resolve the oscillations (i.e., when $N$ is comparable to the argument of the cosine function scaled by $\\pi$). This procedure will now be implemented.",
            "answer": "```python\nimport numpy as np\n\ndef build_chebyshev_matrix(x, n_degree):\n    \"\"\"\n    Constructs the design matrix A_ik = T_k(x_i) for k=0...n_degree.\n    \n    Args:\n        x (np.ndarray): Array of points of shape (M,).\n        n_degree (int): The maximum degree N of the Chebyshev polynomials.\n\n    Returns:\n        np.ndarray: The design matrix A of shape (M, N+1).\n    \"\"\"\n    m_pixels = len(x)\n    A = np.zeros((m_pixels, n_degree + 1))\n    \n    # T_0(x) = 1\n    A[:, 0] = 1.0\n    \n    if n_degree  0:\n        # T_1(x) = x\n        A[:, 1] = x\n    \n    # T_{k+1}(x) = 2*x*T_k(x) - T_{k-1}(x)\n    for k in range(1, n_degree):\n        A[:, k + 1] = 2 * x * A[:, k] - A[:, k - 1]\n        \n    return A\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute RMSE values.\n    \"\"\"\n    M = 64\n    N_degrees = [0, 1, 3, 7, 15, 31]\n    \n    x = -1.0 + 2.0 * np.arange(M) / (M - 1.0)\n    \n    # Define test case functions\n    def case1_func(x_pts):\n        return 0.5 + 0.4 * np.cos(np.pi * x_pts) + 0.1 * np.cos(5 * np.pi * x_pts)\n        \n    def case2_func(x_pts):\n        y = np.full_like(x_pts, 0.9)\n        y[x_pts  0] = 0.1\n        return y\n        \n    def case3_func(x_pts):\n        return 0.5 + 0.45 * np.cos(15 * np.pi * x_pts)\n\n    test_cases = [\n        case1_func,\n        case2_func,\n        case3_func\n    ]\n\n    all_results = []\n    \n    for case_func in test_cases:\n        y = case_func(x)\n        case_results = []\n        for N in N_degrees:\n            A = build_chebyshev_matrix(x, N)\n            \n            # Solve the least-squares problem.\n            # `lstsq` returns coefficients, residuals, rank, and singular values.\n            # The 'residuals' is a one-element array containing the sum of squared errors.\n            _coeffs, residuals, _rank, _s = np.linalg.lstsq(A, y, rcond=None)\n            \n            # If the system is full rank, `residuals` contains the sum of squared errors.\n            if residuals.size  0:\n                sum_sq_res = residuals[0]\n            else:\n                # If no solution or system is rank deficient, calculate manually.\n                p_N = A @ _coeffs\n                sum_sq_res = np.sum((p_N - y)**2)\n\n            rmse = np.sqrt(sum_sq_res / M)\n            case_results.append(rmse)\n        \n        all_results.append(case_results)\n\n    # Format the final output string precisely as required, with no spaces.\n    outer_list_str = []\n    for res_list in all_results:\n      # Use a general format specifier to avoid trailing zeros and ensure precision.\n      inner_list_str = \",\".join(format(n, 'g') for n in res_list)\n      outer_list_str.append(f\"[{inner_list_str}]\")\n    final_output = f\"[{','.join(outer_list_str)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Next, we move from pure approximation to a powerful application: solving equations. This exercise guides you through finding the constant in Wien's displacement law by turning a transcendental equation, derived from Planck's law, into a polynomial root-finding problem. This demonstrates how Chebyshev approximation can provide highly accurate solutions to problems in fundamental physics that lack simple analytical answers .",
            "id": "2379178",
            "problem": "You will implement a complete program that models the peak wavelength of black-body radiation, denoted by $\\lambda_{\\max}(T)$ in meters, as a function of absolute temperature $T$ in Kelvin, by constructing and solving a Chebyshev polynomial approximation to the root of the transcendental stationarity condition arising from maximizing the spectral radiance with respect to wavelength. Begin exclusively from the following foundational base: the Planck spectral radiance per unit wavelength for a black body, given by\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\cdot \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{\\mathrm{B}} T}\\right) - 1},\n$$\nwhere $h$ is Planck’s constant (in joule-seconds), $c$ is the speed of light in vacuum (in meters per second), and $k_{\\mathrm{B}}$ is the Boltzmann constant (in joules per kelvin). The peak wavelength $\\lambda_{\\max}(T)$ is the value of $\\lambda$ that maximizes $B_{\\lambda}(\\lambda, T)$ for a fixed temperature $T$.\n\nYour tasks are:\n- Derive, from the stationarity condition $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda}(\\lambda, T) = 0$ and a non-dimensionalization using a suitable positive dimensionless variable $x$, a transcendental equation for $x$ whose unique positive root determines the peak via $\\lambda_{\\max}(T) = \\frac{b}{T}$, where $b$ is a constant depending only on fundamental constants and the root $x$.\n- Construct a Chebyshev polynomial approximation $p_{n}(x)$ of degree $n$ to the transcendental equation’s left-hand side over a closed interval $[x_{\\min}, x_{\\max}]$ that contains the unique positive root. You must use Chebyshev polynomials on $[-1,1]$ and an affine mapping to $[x_{\\min}, x_{\\max}]$. Choose a polynomial degree $n \\geq 12$ and a sampling strategy consistent with Chebyshev approximation (for example, mapped Chebyshev nodes). Then approximate the root $x^{\\star}$ by solving $p_{n}(x) = 0$ and select the physically meaningful real root in $[x_{\\min}, x_{\\max}]$.\n- Using the resulting approximate root $x^{\\star}$, compute the constant $b$ and then compute $\\lambda_{\\max}(T)$ for each test temperature.\n\nPhysical units and angle specification:\n- All wavelengths must be expressed in meters.\n- All temperatures are in Kelvin.\n- No angles are involved in this task.\n\nTest suite:\n- Use the following temperatures (Kelvin): $[\\,2.7255,\\;300.0,\\;1000.0,\\;3000.0,\\;5772.0,\\;10000.0\\,]$.\n- For each temperature $T$ in the list, compute $\\lambda_{\\max}(T)$ in meters.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value in meters formatted in scientific notation to $12$ significant digits. For example: $\\texttt{[1.23456789012e-03,2.34567890123e-04,...]}$.\n- The final outputs must be ordered in the same order as the test suite temperatures.\n\nYour solution must be a single, self-contained, runnable program that performs the derivation’s computational consequences, constructs the Chebyshev approximation, solves for the approximate root, and prints the final list in the specified format. No user input is allowed. All constants must be defined in the program using internationally accepted values in the International System of Units (SI).",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of quantum mechanics and statistical physics, specifically Planck's law of black-body radiation. The problem is well-posed, objective, and provides a clear, formalizable path to a unique solution using standard numerical methods from computational physics. There are no contradictions, ambiguities, or factual inaccuracies. We may therefore proceed with the solution.\n\nThe objective is to determine the peak emission wavelength, $\\lambda_{\\max}(T)$, of a black body at a given absolute temperature $T$. This wavelength maximizes the Planck spectral radiance function, $B_{\\lambda}(\\lambda, T)$. The starting point is the provided expression for $B_{\\lambda}(\\lambda, T)$:\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\cdot \\frac{1}{\\exp\\left(\\frac{h c}{\\lambda k_{\\mathrm{B}} T}\\right) - 1}\n$$\nwhere $h$ is Planck's constant, $c$ is the speed of light, and $k_{\\mathrm{B}}$ is the Boltzmann constant.\n\nTo find the maximum, we must solve the stationarity condition $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = 0$. For convenience, let us define a constant $A = 2hc^2$ and a dimensionless variable $x = \\frac{hc}{\\lambda k_{\\mathrm{B}} T}$. The radiance function can then be written as:\n$$\nB_{\\lambda}(\\lambda, T) = A \\lambda^{-5} \\left(e^{x} - 1\\right)^{-1}\n$$\nWe apply the product rule for differentiation with respect to $\\lambda$. Note that $x$ is a function of $\\lambda$.\n$$\n\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = A \\left[ \\left(\\frac{d}{d\\lambda}\\lambda^{-5}\\right) \\left(e^{x} - 1\\right)^{-1} + \\lambda^{-5} \\left(\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1}\\right) \\right] = 0\n$$\nThe individual derivatives are:\n$$\n\\frac{d}{d\\lambda}\\lambda^{-5} = -5\\lambda^{-6}\n$$\n$$\n\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1} = -1 \\left(e^{x} - 1\\right)^{-2} e^{x} \\frac{dx}{d\\lambda}\n$$\nThe derivative of $x$ with respect to $\\lambda$ is:\n$$\n\\frac{dx}{d\\lambda} = \\frac{d}{d\\lambda} \\left(\\frac{hc}{\\lambda k_{\\mathrm{B}} T}\\right) = \\frac{hc}{k_{\\mathrm{B}} T} \\left(-\\frac{1}{\\lambda^2}\\right) = -\\frac{x}{\\lambda}\n$$\nSubstituting this back, we get:\n$$\n\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1} = - \\left(e^{x} - 1\\right)^{-2} e^{x} \\left(-\\frac{x}{\\lambda}\\right) = \\frac{x e^{x}}{\\lambda (e^{x} - 1)^2}\n$$\nNow we assemble the stationarity condition:\n$$\nA \\left[ -5\\lambda^{-6} \\left(e^{x} - 1\\right)^{-1} + \\lambda^{-5} \\frac{x e^{x}}{\\lambda (e^{x} - 1)^2} \\right] = 0\n$$\nMultiplying the entire equation by the non-zero factor $\\frac{\\lambda^6 (e^x - 1)^2}{A}$ simplifies the expression:\n$$\n-5(e^x - 1) + \\lambda \\frac{x e^x}{\\lambda} = 0\n$$\n$$\n-5e^x + 5 + x e^x = 0\n$$\nThis can be rewritten into the final form of the transcendental equation we must solve for $x$:\n$$\nf(x) = (x-5)e^x + 5 = 0\n$$\nThe root of this equation, let us call it $x^{\\star}$, determines the relationship between $\\lambda_{\\max}$ and $T$. From the definition of $x$, we have $\\lambda_{\\max} = \\frac{hc}{x^{\\star} k_{\\mathrm{B}} T}$. This is precisely Wien's displacement law, $\\lambda_{\\max}(T) = \\frac{b}{T}$, where the constant $b$ is given by $b = \\frac{hc}{x^{\\star} k_{\\mathrm{B}}}$.\n\nTo find $x^{\\star}$, we first localize the root. Evaluating the function $f(x)$ at simple integer values:\n$f(4) = (4-5)e^4 + 5 = -e^4 + 5 \\approx -54.6 + 5  0$.\n$f(5) = (5-5)e^5 + 5 = 5  0$.\nThe derivative is $f'(x) = e^x + (x-5)e^x = (x-4)e^x$. For $x  4$, $f'(x)  0$, so the function is continuous and strictly increasing on the interval $[4, 5]$. This guarantees a unique root within this interval. We thus select $[x_{\\min}, x_{\\max}] = [4, 5]$ as the approximation domain.\n\nFollowing the problem requirements, we construct a Chebyshev polynomial approximation, $p_n(x)$, for the function $f(x)$ on the interval $[4, 5]$. We choose a degree $n = 20$, which is greater than the required minimum of $n=12$. The approximation is constructed by interpolation. Specifically, we evaluate $f(x)$ at the $N = n+1 = 21$ Chebyshev nodes of the first kind over the interval $[4, 5]$. These nodes $x_k$ are obtained by an affine mapping from the canonical nodes $z_k$ on $[-1, 1]$:\n$$\nz_k = \\cos\\left(\\frac{2k+1}{2N}\\pi\\right), \\quad k = 0, 1, \\dots, n\n$$\n$$\nx_k = \\frac{x_{\\max} - x_{\\min}}{2} z_k + \\frac{x_{\\max} + x_{\\min}}{2} = 0.5 z_k + 4.5\n$$\nThe Chebyshev interpolating polynomial $p_n(x)$ is the unique polynomial of degree at most $n$ that satisfies $p_n(x_k) = f(x_k)$ for all $k=0, \\dots, n$. Modern numerical libraries provide robust routines to compute the coefficients of this polynomial.\nThe approximate root $x^{\\star}$ is then found by solving the polynomial equation $p_n(x) = 0$. This is a standard algebraic procedure. From the resulting roots, we select the one that is real and lies within our chosen interval $[4, 5]$.\n\nWith the high-precision value of $x^{\\star}$ obtained numerically, we calculate Wien's constant:\n$$\nb = \\frac{hc}{x^{\\star} k_{\\mathrm{B}}}\n$$\nusing the 2018 CODATA values for the physical constants $h$, $c$, and $k_{\\mathrm{B}}$. Finally, for each temperature $T$ in the test suite $[\\,2.7255,\\;300.0,\\;1000.0,\\;3000.0,\\;5772.0,\\;10000.0\\,]$, we compute the peak wavelength:\n$$\n\\lambda_{\\max}(T) = \\frac{b}{T}\n$$\nThe implementation will perform these steps computationally.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the peak wavelength of black-body radiation using a Chebyshev approximation.\n\n    The method involves:\n    1. Defining the transcendental equation derived from Planck's law's stationarity condition.\n    2. Constructing a Chebyshev polynomial approximation of the function in this equation.\n    3. Finding the relevant root of the polynomial to approximate the true root x_star.\n    4. Using x_star to compute Wien's displacement constant, b.\n    5. Calculating the peak wavelength lambda_max = b/T for a set of test temperatures.\n    \"\"\"\n\n    # Physical constants (2018 CODATA values, SI units)\n    # h: Planck's constant in J·s\n    # c: Speed of light in vacuum in m/s\n    # k_B: Boltzmann constant in J/K\n    h = 6.62607015e-34\n    c = 299792458.0\n    k_B = 1.380649e-23\n\n    # Test suite temperatures in Kelvin\n    temperatures = np.array([2.7255, 300.0, 1000.0, 3000.0, 5772.0, 10000.0])\n\n    # Transcendental function f(x) = (x-5)exp(x) + 5, whose root we need to find.\n    def f(x):\n        return (x - 5.0) * np.exp(x) + 5.0\n\n    # Step 1: Set up Chebyshev approximation\n    # Degree of the polynomial (n = 12)\n    degree = 20\n    # Interval [xmin, xmax] known to contain the root\n    xmin, xmax = 4.0, 5.0\n    \n    # Step 2: Construct the Chebyshev polynomial interpolant\n    # We interpolate f(x) at the Chebyshev nodes of the first kind.\n    # We need degree + 1 points to define a polynomial of degree `degree`.\n    num_points = degree + 1\n    \n    # Generate Chebyshev nodes of the first kind in the canonical interval [-1, 1]\n    # These are the roots of the Chebyshev polynomial T_{num_points}(z).\n    z_nodes = np.cos(np.pi * (2 * np.arange(num_points) + 1) / (2 * num_points))\n    \n    # Map nodes to the approximation interval [xmin, xmax]\n    x_nodes = (xmax - xmin) / 2.0 * z_nodes + (xmax + xmin) / 2.0\n    \n    # Evaluate the function at these nodes\n    y_values = f(x_nodes)\n    \n    # Use numpy's Chebyshev.fit to create the polynomial approximation.\n    # The `domain` parameter correctly maps the problem domain to the canonical window [-1, 1].\n    p_cheb = np.polynomial.chebyshev.Chebyshev.fit(x_nodes, y_values, degree, domain=[xmin, xmax])\n\n    # Step 3: Find the approximate root x_star\n    # Find all roots of the polynomial approximation.\n    roots = p_cheb.roots()\n    \n    # Filter the roots to find the unique real root within our interval [xmin, xmax].\n    x_star = None\n    for r in roots:\n        # We are only interested in real roots.\n        if np.isreal(r):\n            real_r = np.real(r)\n            # Check if the root is within the physically meaningful interval.\n            if xmin = real_r = xmax:\n                x_star = real_r\n                break\n    \n    if x_star is None:\n        # This guard is for robustness; with a good approximation, a root must be found.\n        raise RuntimeError(\"Could not find the root in the specified interval.\")\n\n    # Step 4: Compute Wien's displacement constant, b\n    b = (h * c) / (x_star * k_B)\n    \n    # Step 5: Compute lambda_max for each temperature in the test suite\n    results = []\n    for T in temperatures:\n        lambda_max = b / T\n        results.append(lambda_max)\n    \n    # Final print statement in the exact required format.\n    # Format each result to scientific notation with 12 significant digits.\n    # The format code \"{:.11e}\" provides 1 digit before the decimal point and 11 after.\n    formatted_results = [f\"{val:.11e}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In our final practice, we tackle a common task in computational physics: creating an efficient model of a physical system. You will develop a Chebyshev polynomial approximation for the on-axis magnetic field of a Helmholtz coil, starting from the Biot-Savart law. This practice illustrates how complex physical formulas can be replaced with fast, accurate polynomial surrogates, a crucial technique for large-scale simulations and analysis .",
            "id": "2379180",
            "problem": "You are to develop, justify, and implement a numerical method to approximate the on-axis magnetic field of a slightly non-ideal Helmholtz coil pair using Chebyshev polynomial approximation. The physical model is based on magnetostatics and the Biot–Savart law, and the approximation method must use Chebyshev polynomials of the first kind. Your program must compute the maximum absolute uniform error of the Chebyshev polynomial approximation (over a specified interval) relative to the exact on-axis field and report those errors for a set of test cases.\n\nAssumptions and fundamental base:\n- The Biot–Savart law governs the magnetic field generated by a steady current, and symmetry reduces the on-axis field of a single circular loop to a scalar function along the symmetry axis. For a loop of radius $R$, carrying current $I$, with $N$ turns, centered at $z=z_0$ on the $z$-axis, the on-axis magnetic field magnitude is a function $B_{\\text{loop}}(z)$ that depends only on $z$, $R$, $I$, $N$, and the magnetic constant $\\mu_0$, with $\\mu_0 = 4\\pi \\times 10^{-7}\\ \\text{N}\\,\\text{A}^{-2}$ in the International System of Units (SI).\n- A Helmholtz-like pair consists of two such loops with their centers at $z=+s/2$ and $z=-s/2$, respectively, where $s$ is the center-to-center separation. If the two loops have possibly different radii and currents, the total on-axis field is the superposition of the fields due to each loop.\n- Chebyshev polynomials of the first kind $\\{T_k(x)\\}_{k=0}^\\infty$ on the interval $x\\in[-1,1]$ form an orthogonal basis with respect to the weight $(1-x^2)^{-1/2}$. Any sufficiently smooth function on $[-1,1]$ admits a convergent Chebyshev series. To approximate a function $f(z)$ on a finite interval $z\\in[-L,L]$, define the affine map $x = z/L$ to obtain a function $g(x)=f(Lx)$ on $[-1,1]$, then approximate $g(x)$ by a truncated Chebyshev series of degree $n$.\n\nTask:\n1) Starting from the Biot–Savart law and symmetry, derive an explicit on-axis expression $B_{\\text{loop}}(z)$ for a single loop and the superposed total field $B_{\\text{pair}}(z)$ for two loops at $z=\\pm s/2$ with possibly distinct radii and currents.\n2) Construct a degree-$n$ Chebyshev approximation $\\tilde B(z)$ to $B_{\\text{pair}}(z)$ on $z\\in[-L,L]$ by mapping to $x\\in[-1,1]$ and fitting in the Chebyshev basis of the first kind. The coefficients must be obtained numerically using a stable method appropriate for Chebyshev polynomials.\n3) Evaluate the exact field and the approximation on a uniform grid of $M$ points on $[-L,L]$ and compute the maximum absolute error $\\max_{z\\in[-L,L]} |B_{\\text{pair}}(z) - \\tilde B(z)|$. Report this error in tesla (SI unit).\n\nAngle unit: If any inverse trigonometric functions arise in your derivations, they are understood to use radians.\n\nYour program must implement the above and output the results for the following test suite. All physical constants and parameters are in SI units. In each case, the interval is $[-L,L]$, the uniform grid for the error computation has $M=2001$ points, and the output is the maximum absolute error in tesla.\n\nTest suite:\n- Case 1 (near-ideal Helmholtz):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.300\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 2.0\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = 0.300\\ \\text{m}$,\n  - $L = 0.150\\ \\text{m}$,\n  - degree $n = 8$.\n- Case 2 (slightly mismatched radii):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.305\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 2.0\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = (R_1 + R_2)/2 = 0.3025\\ \\text{m}$,\n  - $L = 0.150\\ \\text{m}$,\n  - degree $n = 10$.\n- Case 3 (slightly mismatched currents):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.300\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 1.95\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = 0.300\\ \\text{m}$,\n  - $L = 0.150\\ \\text{m}$,\n  - degree $n = 10$.\n- Case 4 (off-Helmholtz separation and wider interval):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.300\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 2.0\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = 0.250\\ \\text{m}$,\n  - $L = 0.300\\ \\text{m}$,\n  - degree $n = 12$.\n\nFinal output format:\n- Your program should produce a single line of output containing the four maximum absolute errors, in tesla, as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3,e4]\"). Each entry must be a floating-point number. No additional text should be printed.",
            "solution": "We begin from the Biot–Savart law of magnetostatics. The magnetic field $\\mathbf{B}(\\mathbf{r})$ generated by a steady current $I$ flowing in a wire with differential element $d\\boldsymbol{\\ell}$ is given by\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int \\frac{d\\boldsymbol{\\ell} \\times \\hat{\\mathbf{R}}}{R^2},\n$$\nwhere $\\mathbf{R} = \\mathbf{r} - \\mathbf{r}'$ points from source point $\\mathbf{r}'$ on the wire to the field point $\\mathbf{r}$, $R = \\|\\mathbf{R}\\|$, and $\\hat{\\mathbf{R}} = \\mathbf{R}/R$. For a circular loop of radius $R$ centered on the origin and lying in the $xy$-plane, by symmetry the magnetic field on the $z$-axis is directed along $\\hat{\\mathbf{z}}$ and has magnitude that depends only on $z$. Evaluating the integral (a well-tested textbook result following from symmetry and direct integration) yields the on-axis field for a single loop with $N$ turns and current $I$ centered at $z=z_0$:\n$$\nB_{\\text{loop}}(z; R, I, N, z_0) = \\frac{\\mu_0 N I R^2}{2 \\left(R^2 + (z - z_0)^2 \\right)^{3/2}}.\n$$\nFor two coaxial loops (a Helmholtz-like pair) with centers at $z = \\pm s/2$, possibly different radii and currents, superposition gives the total field\n$$\nB_{\\text{pair}}(z) = \\frac{\\mu_0 N_1 I_1 R_1^2}{2 \\left(R_1^2 + \\left(z - \\frac{s}{2}\\right)^2 \\right)^{3/2}} + \\frac{\\mu_0 N_2 I_2 R_2^2}{2 \\left(R_2^2 + \\left(z + \\frac{s}{2}\\right)^2 \\right)^{3/2}}.\n$$\nThis field is smooth for all real $z$ and is thus amenable to polynomial approximation on any finite interval $z \\in [-L, L]$.\n\nTo construct a Chebyshev approximation, we map the physical variable $z \\in [-L, L]$ to the canonical domain $x \\in [-1, 1]$ by the affine transformation\n$$\nx = \\frac{z}{L}, \\quad z = Lx.\n$$\nDefine the function $g(x) = B_{\\text{pair}}(Lx)$. The Chebyshev polynomials of the first kind $\\{T_k(x)\\}$ are defined by\n$$\nT_k(x) = \\cos\\left(k \\arccos x \\right), \\quad x \\in [-1,1], \\quad k = 0, 1, 2, \\dots,\n$$\nand satisfy the orthogonality relation\n$$\n\\int_{-1}^{1} \\frac{T_j(x) T_k(x)}{\\sqrt{1 - x^2}}\\, dx = \n\\begin{cases}\n0,  j \\neq k, \\\\\n\\pi,  j = k = 0, \\\\\n\\frac{\\pi}{2},  j = k \\ge 1.\n\\end{cases}\n$$\nA Chebyshev series approximation of degree $n$ takes the form\n$$\ng(x) \\approx \\sum_{k=0}^{n} c_k T_k(x).\n$$\nThe ideal Chebyshev coefficients $\\{c_k\\}$ are given by the weighted projections\n$$\nc_0 = \\frac{1}{\\pi} \\int_{-1}^{1} \\frac{g(x)}{\\sqrt{1-x^2}}\\, dx, \\quad\nc_k = \\frac{2}{\\pi} \\int_{-1}^{1} \\frac{g(x) T_k(x)}{\\sqrt{1-x^2}}\\, dx \\quad (k \\ge 1).\n$$\nIn practice, we compute a numerically stable approximation to the coefficients using a least-squares fit in the Chebyshev basis on a set of sample points in $[-L, L]$. This constructs the polynomial $\\tilde B(z)$ of degree $n$ that approximates $B_{\\text{pair}}(z)$ on the chosen interval in the Chebyshev basis. The fitting and evaluation are conveniently and robustly implemented using the Chebyshev basis tools in the Numerical Python (NumPy) library, which internally handles the scaling between $z$ and $x$ and the conditioning of the Vandermonde system.\n\nAlgorithmic design:\n1) For given physical parameters $(R_1, R_2, I_1, I_2, N_1, N_2, s)$ and interval half-width $L$, define the exact field $B_{\\text{pair}}(z)$ as above with $\\mu_0 = 4\\pi \\times 10^{-7}\\ \\text{N}\\,\\text{A}^{-2}$.\n2) Choose a polynomial degree $n$. Generate a sufficiently dense set of sample points $\\{z_j\\}$ in $[-L, L]$, for instance $M_{\\text{fit}}$ uniformly spaced points with $M_{\\text{fit}} \\gg n$, and compute $y_j = B_{\\text{pair}}(z_j)$.\n3) Fit a Chebyshev polynomial of degree $n$ to the sampled data $\\{(z_j, y_j)\\}$ over the domain $[-L, L]$, obtaining a Chebyshev series representation $\\tilde B(z) = \\sum_{k=0}^{n} \\tilde c_k T_k(z/L)$.\n4) On a uniform evaluation grid of $M$ points in $[-L, L]$ (with $M = 2001$), compute the exact field and the polynomial approximation and then the maximum absolute error\n$$\nE_{\\max} = \\max_{z \\in [-L, L]} \\left| B_{\\text{pair}}(z) - \\tilde B(z) \\right|.\n$$\n5) Repeat steps for each test case.\n\nDiscussion of edge cases and numerical considerations:\n- When $s$ equals the radius in an ideal Helmholtz configuration, the field is especially flat near $z=0$, so a modest $n$ on a moderate interval $[-L, L]$ yields very small errors.\n- Mismatch in radii or currents introduces asymmetry and curvature, requiring slightly higher $n$ to achieve the same uniform error on the same interval.\n- Enlarging $L$ while keeping $n$ fixed increases the difficulty of uniform approximation, typically increasing $E_{\\max}$.\n\nThe program below implements the above algorithm using the Numerical Python (NumPy) Chebyshev polynomial tools, evaluates the maximum absolute error for each test case, and prints a single line containing the four errors in tesla as a comma-separated list enclosed in square brackets.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial import Chebyshev as Cheb\n\n# Physical constant (SI)\nMU0 = 4.0 * np.pi * 1e-7  # N/A^2, equivalent T·m/A\n\ndef B_loop_on_axis(z, R, I, N, z0):\n    # On-axis magnetic field of a circular loop with N turns, current I, radius R, centered at z0.\n    # B(z) = mu0 N I R^2 / (2 (R^2 + (z - z0)^2)^(3/2))\n    denom = (R*R + (z - z0)**2)**1.5\n    return MU0 * N * I * (R*R) / (2.0 * denom)\n\ndef B_pair_on_axis(z, R1, R2, I1, I2, N1, N2, s):\n    # Two loops centered at z = +/- s/2\n    return (B_loop_on_axis(z, R1, I1, N1, +0.5*s) +\n            B_loop_on_axis(z, R2, I2, N2, -0.5*s))\n\ndef chebyshev_approximation(B_fun, L, deg, fit_points=2049):\n    \"\"\"\n    Fit a Chebyshev polynomial of degree 'deg' to the function B_fun over z in [-L, L].\n    Returns a Chebyshev object representing the approximation on the given domain.\n    \"\"\"\n    # Sample densely for a robust least-squares fit\n    z_samples = np.linspace(-L, L, fit_points)\n    y_samples = B_fun(z_samples)\n    # Fit Chebyshev polynomial on the domain [-L, L]\n    cheb_poly = Cheb.fit(z_samples, y_samples, deg=deg, domain=[-L, L])\n    return cheb_poly\n\ndef max_uniform_error(B_exact_fun, B_approx_poly, L, eval_points=2001):\n    z_eval = np.linspace(-L, L, eval_points)\n    exact = B_exact_fun(z_eval)\n    approx = B_approx_poly(z_eval)\n    return float(np.max(np.abs(exact - approx)))\n\ndef solve():\n    # Define test cases as tuples:\n    # (R1, R2, I1, I2, N1, N2, s, L, deg)\n    test_cases = [\n        (0.300, 0.300, 2.0, 2.0, 200, 200, 0.300, 0.150, 8),     # Case 1\n        (0.300, 0.305, 2.0, 2.0, 200, 200, 0.3025, 0.150, 10),   # Case 2\n        (0.300, 0.300, 2.0, 1.95, 200, 200, 0.300, 0.150, 10),   # Case 3\n        (0.300, 0.300, 2.0, 2.0, 200, 200, 0.250, 0.300, 12),    # Case 4\n    ]\n\n    results = []\n    for (R1, R2, I1, I2, N1, N2, s, L, deg) in test_cases:\n        # Define exact function for this case\n        exact_fun = lambda z: B_pair_on_axis(z, R1, R2, I1, I2, N1, N2, s)\n        # Build Chebyshev approximation\n        cheb_poly = chebyshev_approximation(exact_fun, L=L, deg=deg, fit_points=4097)\n        # Compute maximum uniform error over the interval\n        err = max_uniform_error(exact_fun, cheb_poly, L=L, eval_points=2001)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}