{
    "hands_on_practices": [
        {
            "introduction": "有限体积法的核心优势在于其内在的守恒特性。本练习将通过构建一个“有缺陷”的求解器来探讨这一基本原理，其中通量守恒被有意地破坏，让您能够直接观察到这种违背守恒律的后果 。通过分析全局总量的漂移，您将对为何单元交界面上的通量一致性对于物理上精确的仿真是不可或缺的，获得更深刻、更直观的理解。",
            "id": "2394360",
            "problem": "你的任务是分析并实现一个一维有限体积法 (FVM)，该方法在每个面上故意少量违反守恒定律，并量化由此产生的全局质量误差增长。考虑一维空间中的线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n该方程定义在一个周期性域 $[0,L]$ 上，具有恒定的平流速度 $a  0$。使用一个包含 $N$ 个控制体积的均匀网格，每个控制体积的宽度为 $\\Delta x = L/N$，并将时间层 $n$ 上单元 $i$ 内的单元平均值表示为 $U_i^n$。每个单元的 FVM 半离散平衡方程为\n$$\n\\frac{d U_i}{d t} = - \\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2}}^{(i)} - F_{i-\\frac{1}{2}}^{(i)} \\right),\n$$\n其前向欧拉时间离散格式为\n$$\nU_i^{n+1} = U_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n} \\right).\n$$\n对于基础数值通量，当 $a0$ 时，使用一阶迎风格式：\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = a\\, U_i^n.\n$$\n引入一个故意的非守恒扰动如下：在每个面 $i+\\tfrac{1}{2}$ 处，对其相邻的两个单元使用两个不同的通量值，使得左侧单元 $i$ 使用\n$$\nF_{i+\\frac{1}{2}}^{(i),n} = \\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon,\n$$\n而右侧单元 $i+1$ 使用\n$$\nF_{i+\\frac{1}{2}}^{(i+1),n} = \\widehat{F}_{i+\\frac{1}{2}}^n,\n$$\n其中 $\\epsilon$ 是一个小的常数偏差，对所有面和所有时间步都相同。这种选择使得离散格式在每个时间步的每个面上都因一个固定的不匹配量 $\\epsilon$ 而故意变得非守恒。对所有面上的量使用周期性索引。\n\n任务：\n1. 从守恒的积分形式、FVM 更新方程以及上述非守恒通量构造出发，根据第一性原理推导全局质量漂移的封闭形式表达式\n$$\n\\Delta M(T) = M(T) - M(0), \\quad M(t) \\equiv \\sum_{i=0}^{N-1} U_i(t)\\,\\Delta x,\n$$\n该表达式是关于面数 $N_{\\text{faces}}$、偏差 $\\epsilon$ 和最终时间 $T$ 的函数。假设 $\\epsilon$ 在时间和空间上是常数，并且时间步长 $\\Delta t$ 和步数 $n_{\\text{steps}}$ 满足 $T = n_{\\text{steps}} \\Delta t$。请用 $N_{\\text{faces}}$、$\\epsilon$ 和 $T$ 表示 $\\Delta M(T)$。\n\n2. 实现一个程序，该程序：\n   - 在单元中心 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ 处初始化解\n     $$\n     U_i^0 = \\sin\\left( \\frac{2\\pi x_i}{L} \\right) + 0.5.\n     $$\n   - 使用上述非守恒通量、显式欧拉时间步进和周期性边界条件，将解推进 $n_{\\text{steps}}$ 步，其中 $\\Delta t = \\text{CFL}\\,\\Delta x/a$，而 $\\text{CFL}\\in(0,1]$ 是一个给定的 Courant–Friedrichs–Lewy 数。\n   - 计算测得的全局质量漂移 $\\Delta M_{\\text{meas}} = M(T) - M(0)$，并将其与任务1中分析预测的漂移 $\\Delta M_{\\text{pred}}$ 进行比较。\n\n3. 对于下方的每个测试用例，返回标量差\n$$\n\\delta = \\Delta M_{\\text{meas}} - \\Delta M_{\\text{pred}},\n$$\n作为一个浮点数。\n\n所有量都是无量纲的。角度以弧度为单位。没有需要转换的物理单位。\n\n测试套件（每个元组为 $(N, L, a, \\epsilon, \\text{CFL}, n_{\\text{steps}})$）：\n- 用例 A: $(50, 1.0, 1.0, 1.0\\times 10^{-6}, 0.6, 100)$.\n- 用例 B: $(1, 1.0, 1.0, 2.0\\times 10^{-7}, 0.4, 1000)$.\n- 用例 C: $(10, 2.0, 0.5, -1.0\\times 10^{-6}, 0.8, 250)$.\n- 用例 D: $(37, 1.5, 1.0, 0.0, 0.7, 123)$.\n\n附加说明：\n- 对所有测试用例使用周期性边界，且 $N_{\\text{faces}}=N$。\n- 通过使用 $a0$ 和 $\\text{CFL}\\leq 1$ 来确保稳定性。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r_A,r_B,r_C,r_D]”），其中每个 $r_\\cdot$ 是对应于指定测试用例的 $\\delta$ 值，以标准浮点数格式打印。",
            "solution": "我们从一个标量在控制体积上的积分守恒定律开始。对于一个单元宽度为 $\\Delta x$、单元索引为 $i$ 的均匀网格，具有恒定速度 $a$ 的一维线性平流方程的积分形式可以导出半离散的有限体积法 (FVM)\n$$\n\\frac{dU_i}{dt} = -\\frac{1}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{(i)} - F_{i-\\frac{1}{2}}^{(i)} \\right),\n$$\n其中 $F_{i+\\frac{1}{2}}^{(i)}$ 表示单元 $i$ 在其右侧面 $i+\\tfrac{1}{2}$ 使用的数值通量，而 $F_{i-\\frac{1}{2}}^{(i)}$ 是单元 $i$ 在其左侧面 $i-\\tfrac{1}{2}$ 使用的数值通量。其前向欧拉时间离散格式为\n$$\nU_i^{n+1} = U_i^{n} - \\frac{\\Delta t}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n} \\right).\n$$\n对于一个守恒的 FVM，要求每个内表面 $i+\\tfrac{1}{2}$ 贡献一个单一的通量值，该值被其两个相邻单元以相反的符号使用，从而在对所有单元求和时通过伸缩求和来保证全局守恒。在这里，我们通过在每个面 $i+\\tfrac{1}{2}$ 定义两种不同的通量用法来故意违反这一点：\n- 对于左侧单元 $i$，我们取\n$$\nF_{i+\\frac{1}{2}}^{(i),n} = \\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon,\n$$\n- 对于右侧单元 $i+1$，我们取\n$$\nF_{i+\\frac{1}{2}}^{(i+1),n} = \\widehat{F}_{i+\\frac{1}{2}}^n,\n$$\n其中每个面、每个时间步都有一个恒定的偏差 $\\epsilon$。基础通量 $\\widehat{F}_{i+\\frac{1}{2}}^n$ 是当 $a0$ 时的标准迎风通量，\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = a\\,U_i^n,\n$$\n当两个相邻单元使用相同的通量时，该格式是一致且守恒的。在周期性边界和均匀间距下，共有 $N$ 个面，我们将其统称为面集。\n\n在时间层 $n$ 的全局质量为\n$$\nM^n = \\sum_{i=0}^{N-1} U_i^n \\,\\Delta x.\n$$\n对所有单元的更新方程求和，\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right)\n= -\\frac{\\Delta t}{\\Delta x}\\sum_{i=0}^{N-1}\\left(F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n}\\right).\n$$\n通过 $j=i-1$ 对第二个和式重新索引，得到\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right)\n= -\\frac{\\Delta t}{\\Delta x}\\sum_{\\text{faces}}\\left(F_{\\text{face}}^{(\\text{left}),n} - F_{\\text{face}}^{(\\text{right}),n}\\right).\n$$\n根据我们的构造，\n$$\nF_{\\text{face}}^{(\\text{left}),n} - F_{\\text{face}}^{(\\text{right}),n} = \\epsilon,\n$$\n对于每个时间层的每个面都成立。因此，\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{\\text{faces}} \\epsilon = -\\frac{\\Delta t}{\\Delta x}\\, N_{\\text{faces}}\\,\\epsilon.\n$$\n两边同乘以 $\\Delta x$ 得到每个时间步的全局质量变化\n$$\nM^{n+1} - M^n = -\\Delta t\\, N_{\\text{faces}}\\,\\epsilon.\n$$\n这表明每一步的质量漂移与解的值和空间离散宽度无关，仅取决于面数、时间步长和偏差 $\\epsilon$。在 $n_{\\text{steps}}$ 个时间步长为常数 $\\Delta t$ 的步之后，总漂移为\n$$\n\\Delta M(T) \\equiv M(T) - M(0) = \\sum_{n=0}^{n_{\\text{steps}}-1} \\left(M^{n+1}-M^n\\right) = - n_{\\text{steps}} \\Delta t \\, N_{\\text{faces}}\\, \\epsilon = - T\\, N_{\\text{faces}}\\, \\epsilon,\n$$\n因为 $T = n_{\\text{steps}}\\Delta t$。在均匀网格上的周期性边界条件下，$N_{\\text{faces}} = N$。因此，\n$$\n\\Delta M(T) = - T\\, N\\, \\epsilon.\n$$\n\n模拟的算法设计：\n- 在单元中心 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ (对于 $i=0,\\dots,N-1$) 处初始化解 $U_i^0 = \\sin\\left(\\frac{2\\pi x_i}{L}\\right) + 0.5$。\n- 选择 $\\Delta t = \\text{CFL}\\,\\Delta x / a$，其中 $a0$ 且 $\\text{CFL}\\leq 1$，以满足通常的迎风格式稳定性限制。\n- 在每个时间步，计算基础迎风通量 $\\widehat{F}_{i+\\frac{1}{2}}^n = a\\,U_i^n$ (对于 $i=0,\\dots,N-1$)，并使用周期性索引。通过以下方式更新每个单元来应用非守恒用法\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left[ \\left(\\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon\\right) - \\widehat{F}_{i-\\frac{1}{2}}^n \\right],\n$$\n其中索引对 $N$ 取模。\n- 在 $n_{\\text{steps}}$ 步后，计算测得的全局质量漂移 $\\Delta M_{\\text{meas}} = M(T) - M(0)$，其中 $M(t) = \\sum_i U_i(t)\\Delta x$，并将其与预测的漂移 $\\Delta M_{\\text{pred}} = - T\\,N\\,\\epsilon$ 进行比较，以获得 $\\delta = \\Delta M_{\\text{meas}} - \\Delta M_{\\text{pred}}$。\n\n程序应运行指定的测试套件：\n- 用例 A: $(N, L, a, \\epsilon, \\text{CFL}, n_{\\text{steps}}) = (50, 1.0, 1.0, 1.0\\times 10^{-6}, 0.6, 100)$,\n- 用例 B: $(1, 1.0, 1.0, 2.0\\times 10^{-7}, 0.4, 1000)$,\n- 用例 C: $(10, 2.0, 0.5, -1.0\\times 10^{-6}, 0.8, 250)$,\n- 用例 D: $(37, 1.5, 1.0, 0.0, 0.7, 123)$,\n\n并以“[r_A,r_B,r_C,r_D]”的格式输出单行结果，其中每个 $r_\\cdot$ 是该用例对应的浮点数 $\\delta$。由于对于所述构造，分析是精确的，因此差值应在浮点舍入误差范围内接近于零。",
            "answer": "```python\nimport numpy as np\n\ndef run_case(N, L, a, eps, CFL, n_steps):\n    # Spatial discretization\n    N = int(N)\n    dx = L / N\n    # Time step from CFL condition (assume a  0 as per problem statement)\n    dt = CFL * dx / a\n    # Initialize solution: U_i^0 = sin(2*pi*x_i/L) + 0.5 at cell centers\n    i = np.arange(N)\n    x = (i + 0.5) * dx\n    U = np.sin(2.0 * np.pi * x / L) + 0.5\n\n    # Initial mass\n    M0 = dx * np.sum(U)\n\n    # Time stepping with non-conservative flux usage\n    for _ in range(n_steps):\n        # Base upwind fluxes at faces: F_hat[i] = a * U[i] for a  0\n        F_hat = a * U.copy()\n        # Update: U^{n+1} = U^n - (dt/dx) * [ (F_hat[i] + eps) - F_hat[i-1] ]\n        # periodic indexing: F_hat[i-1] corresponds to np.roll(F_hat, 1)[i]\n        U = U - (dt / dx) * ((F_hat + eps) - np.roll(F_hat, 1))\n\n    # Final mass\n    M_end = dx * np.sum(U)\n\n    # Measured mass drift\n    dM_meas = M_end - M0\n    # Predicted mass drift: - T * N * eps, with T = n_steps * dt\n    T = n_steps * dt\n    dM_pred = - T * N * eps\n\n    # Return difference\n    return dM_meas - dM_pred\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, L, a, eps, CFL, n_steps)\n    test_cases = [\n        (50, 1.0, 1.0, 1.0e-6, 0.6, 100),    # Case A\n        (1, 1.0, 1.0, 2.0e-7, 0.4, 1000),    # Case B\n        (10, 2.0, 0.5, -1.0e-6, 0.8, 250),   # Case C\n        (37, 1.5, 1.0, 0.0, 0.7, 123),       # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, a, eps, CFL, n_steps = case\n        delta = run_case(N, L, a, eps, CFL, n_steps)\n        # For stable output, represent as a float string with sufficient precision\n        results.append(f\"{delta:.12e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "虽然简单的数值格式是稳定的，但它们通常会引入自身的计算“赝象”(artifact)。本练习聚焦于一个关键问题：数值耗散，它会导致尖锐的特征随时间逐渐模糊 。您将实现一个一阶迎风格式来模拟一个阶跃函数的平流过程，并量化这种弥散效应，从而对计算流体力学中稳定性与精度之间的权衡有一个切实的感受。",
            "id": "2394306",
            "problem": "考虑一维线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n定义在长度为 $L$ 的周期性域上，即 $x \\in [0,L)$，具有周期性边界条件。平流速度 $a$ 是一个正常数。从积分守恒定律和均匀网格上有限体积平均的定义出发，推导一个与 $a0$ 的信息传播物理特性一致的一阶显式守恒有限体积法。\n\n您将通过模拟方波阶梯函数的平流来研究数值扩散，并量化界面随时间的模糊程度。使用一个包含 $N$ 个单元的均匀网格，空间步长为 $\\Delta x = L/N$，单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，其中 $i=0,1,\\dots,N-1$。设初始条件为方波\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $x_L = 0.2\\,L$ 且 $x_R = 0.7\\,L$。使用一阶有限体积格式演化解，显式时间步长 $\\Delta t$ 的选择应满足预设的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。对于给定的模拟，所有时间步均使用相同的常数 $\\nu$。让模拟运行至预设的最终时间 $T$；使用整数个时间步 $n = \\text{round}(T/\\Delta t)$，使得模拟时间为 $t_n = n\\,\\Delta t$。\n\n将时间 $t_n$ 时下降界面的“模糊宽度”定义为，从单元中心剖面下穿 $\\theta_{\\text{hi}} = 0.9$ 水平的点到其后下穿 $\\theta_{\\text{lo}} = 0.1$ 水平的点之间的最小空间距离（沿周期性域测量）。使用相邻单元中心的单元中心值进行线性插值来计算这些交叉点。如果存在多个下降界面（由于周期性），计算每个下降界面周围的模糊宽度，并报告最小宽度。以与 $L$ 相同的无量纲长度单位表示该宽度。\n\n在单个程序中实现模拟和宽度测量。对于下面的每个测试用例，输出在时间 $t_n$ 测得的模糊宽度，四舍五入到8位小数。\n\n使用以下测试套件，参数为 $(N,\\ \\nu,\\ T,\\ a,\\ L)$：\n- 案例 1：$(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 案例 2：$(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 案例 3：$(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 案例 4：$(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 案例 5：$(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。例如，它应该看起来像\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\n其中每个 $\\text{result}_k$ 是案例 $k$ 的模糊宽度，四舍五入到8位小数。不允许有其他输出。",
            "solution": "我们从平流方程的积分守恒形式开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a0.\n$$\n令 $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ 为一个均匀宽度为 $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$ 的控制体，其单元中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，并采用周期性索引。定义单元平均值\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\n将守恒定律在 $\\mathcal{C}_i$ 上积分得到\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\n或等价地，\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\n其中 $f_{i\\pm \\tfrac{1}{2}}$ 是通过单元面的通量。采用时间步长为 $\\Delta t$ 的一阶显式时间离散化，得到\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\n其中数值通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n$ 与物理特性一致。对于 $a0$ 的线性平流，信息从左向右传播，每个界面处的精确黎曼解仅取决于左侧状态。因此，Godunov 迎风数值通量为\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a0.\n$$\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$，更新方程简化为一阶迎风格式\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a0,\n$$\n其中 $i$ 采用周期性索引。\n\n为了将此离散方法与连续过程联系起来并揭示数值扩散，我们进行修正方程分析。记 $\\bar{u}_i^n \\approx u(x_i,t^n)$，其中 $t^n = n\\Delta t$。在时间上进行泰勒展开得到\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\n对后向差分进行空间上的泰勒展开得到\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\n代入格式中得到\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\n两边除以 $\\Delta t$ 并回顾 $\\nu = a\\Delta t/\\Delta x$，\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\n主修正项是一个扩散项，其有效（人工）扩散系数为\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\n因此，对于 $0  \\nu  1$，一阶迎风法会引入数值扩散，使不连续性在宽度上模糊，其宽度增长类似于 $\\sqrt{D_{\\text{num}}\\,t}$。而当 $\\nu=1$ 时，主扩散项消失，该方法简化为网格上的纯位移算子。\n\n为了量化阶梯函数的模糊程度，我们定义 $10$–$90$ 厚度。考虑一个下降界面，其中 $u$ 的值从接近 $1$ 降至接近 $0$。令 $\\theta_{\\text{hi}} = 0.9$ 和 $\\theta_{\\text{lo}} = 0.1$。在分段常数的单元中心剖面 $\\{\\bar{u}_i^n\\}$ 上，我们通过相邻单元中心之间的线性插值来确定 $u=\\theta$ 的近似位置。具体来说，对于下降前沿上满足 $\\bar{u}_i^n \\ge \\theta  \\bar{u}_{i+1}^n$ 的一对相邻索引 $(i,i+1)$，\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\n我们收集整个域中所有向下的 $\\theta_{\\text{hi}}$ 交叉点和所有向下的 $\\theta_{\\text{lo}}$ 交叉点（考虑周期性环绕），对于每个 $\\theta_{\\text{hi}}$ 交叉点，我们确定沿周期性坐标到其后的 $\\theta_{\\text{lo}}$ 交叉点的距离。这个最小距离，记为 $w_{10\\text{–}90}$，就是测得的模糊宽度。该宽度以与 $L$ 相同的长度单位报告。\n\n算法设计：\n- 空间离散化：均匀单元，周期性边界条件，对于 $a0$ 使用一阶迎风通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$。\n- 时间步进：采用前向欧拉法，固定 $\\Delta t$ 以满足预设的 $\\nu = a\\,\\Delta t/\\Delta x$；推进 $n=\\text{round}(T/\\Delta t)$ 步。\n- 初始化：在 $[0.2L, 0.7L)$ 上 $u(x,0)=1$，在 $[0,L)$ 的其他位置为 $0$，在单元中心处采样。\n- 宽度测量：使用单元中心值的线性插值计算 $w_{10\\text{–}90}$，并取下降界面上 $\\theta_{\\text{hi}}$ 和 $\\theta_{\\text{lo}}$ 交叉点之间的最小下游距离；使用周期性展开处理靠近 $x=0$ 的界面。\n\n基于 $D_{\\text{num}}$ 的定性预期：对于固定的 $a$、$L$ 和 $T$，更精细的网格（更小的 $\\Delta x$）会减小 $D_{\\text{num}}$，从而减少模糊；更大的 $\\nu$（更接近 $1$）也会减小 $D_{\\text{num}}$，产生更窄的界面；在 $\\nu=1$ 时，主扩散项消失，界面基本上被限制在网格尺度的厚度内。程序精确地实现了该格式和测量方法，并对每个指定的测试用例 $(N,\\nu,T,a,L)$ 输出模糊宽度 $w_{10\\text{–}90}(t_n)$，四舍五入到8位小数，并按要求聚合成单行列表。",
            "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a  0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x >= xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i > u_ip1 (strict to avoid degenerate flat segments)\n        if u_i > u_ip1:\n            # theta_hi crossing: u_i >= theta_hi > u_ip1\n            if (u_i >= theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i >= theta_lo > u_ip1\n            if (u_i >= theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions) > 0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions) > 0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists) > 0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了基本原理之后，本练习将有限体积法扩展到求解椭圆型问题，例如稳态热传导。您将构建一个完整的二维泊松方程求解器，学习处理源项和狄利克雷边界条件，同时组装并求解一个大型线性方程组 。这个总结性的练习展示了该方法的多功能性，并介绍了解决多维工程与物理问题的实用技巧。",
            "id": "2394364",
            "problem": "您的任务是构建一个完整的、可运行的程序，应用有限体积法 (FVM) 计算二维矩形域中的稳态温度场。该域具有固定的温度（狄利克雷）边界条件和内部、与位置相关的热源。物理模型是具有恒定热导率的稳态热传导。您的程序必须从第一性原理实现控制体积离散化，并为一组指定的测试用例求解所产生的线性系统。\n\n连续模型由任意控制体积上的稳态能量守恒定律给出，对于恒定热导率，该定律简化为泊松型方程\n$$\n\\nabla \\cdot \\left( k \\, \\nabla T \\right) + q(x,y) = 0,\n$$\n在域\n$$\n\\Omega = \\{(x,y) \\mid 0 \\le x \\le L_x,\\; 0 \\le y \\le L_y\\},\n$$\n中，其中 $T$ 是温度，$k$ 是恒定热导率，$q(x,y)$ 是体积热源密度。狄利克雷边界条件固定了整个边界 $\\partial\\Omega$ 上的温度：\n$$\nT(0,y) = T_L,\\quad T(L_x,y) = T_R,\\quad T(x,0) = T_B,\\quad T(x,L_y) = T_T.\n$$\n\n离散化要求：\n- 将域划分为 $N_x \\times N_y$ 个尺寸均匀的矩形控制体积，大小为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。将未知温度 $T_{i,j}$ 放置在每个单元中心 $(x_i,y_j)$ 处，其中 $x_i = (i+\\tfrac{1}{2})\\Delta x$ 和 $y_j = (j+\\tfrac{1}{2})\\Delta y$，对于整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$。\n- 从通用控制体积上的积分守恒定律出发，并应用散度定理，为每个单元推导出一个使用通过其面的扩散通量的离散平衡方程。对于内部面，用法向相邻单元中心之间的中心两点差分来近似法向导数。对于具有固定边界温度的邻近边界的面，将边界施加在面上，并用法向跨越半单元距离（从单元中心到边界​​面）的差分来近似法向导数。\n- 为所有 $N_x N_y$ 个未知数组装得到的线性系统，并进行数值求解。\n\n输出要求：\n对于每个测试用例，您的程序必须计算以下三个量：\n1. 中心最接近 $(L_x/2, L_y/2)$ 的控制体积的温度，记为 $T_{\\mathrm{center}}$（单位：开尔文）。\n2. 域上的面积平均温度，对于均匀网格，计算为所有单元中心温度的算术平均值，记为 $T_{\\mathrm{avg}}$（单位：开尔文）。\n3. 所有单元中心的最大温度，记为 $T_{\\mathrm{max}}$（单位：开尔文）。\n\n所有温度均以开尔文表示，并将每个报告的浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n使用以下三个完全指定的测试用例。\n\n- 测试用例 A（高斯源，等温边界）：\n  - 域尺寸：$L_x = 1.0\\,\\mathrm{m}$, $L_y = 1.0\\,\\mathrm{m}$。\n  - 网格：$N_x = 51$, $N_y = 51$。\n  - 热导率：$k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n  - 边界温度：$T_L = 300.0\\,\\mathrm{K}$, $T_R = 300.0\\,\\mathrm{K}$, $T_B = 300.0\\,\\mathrm{K}$, $T_T = 300.0\\,\\mathrm{K}$。\n  - 热源：\n    $$\n    q(x,y) = A \\exp\\!\\big(-\\alpha\\big[(x-x_c)^2+(y-y_c)^2\\big]\\big),\\quad\n    A = 1.0\\times 10^6\\,\\mathrm{W\\,m^{-3}},\\;\\alpha = 80.0,\\;x_c = 0.5,\\;y_c = 0.5.\n    $$\n\n- 测试用例 B（无热源，左右温差）：\n  - 域尺寸：$L_x = 1.0\\,\\mathrm{m}$, $L_y = 1.0\\,\\mathrm{m}$。\n  - 网格：$N_x = 51$, $N_y = 51$。\n  - 热导率：$k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n  - 边界温度：$T_L = 300.0\\,\\mathrm{K}$, $T_R = 400.0\\,\\mathrm{K}$, $T_B = 300.0\\,\\mathrm{K}$, $T_T = 300.0\\,\\mathrm{K}$。\n  - 热源：$q(x,y) = 0$。\n\n- 测试用例 C（角点附近的高斯汇，等温边界）：\n  - 域尺寸：$L_x = 1.0\\,\\mathrm{m}$, $L_y = 1.0\\,\\mathrm{m}$。\n  - 网格：$N_x = 51$, $N_y = 51$。\n  - 热导率：$k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n  - 边界温度：$T_L = 300.0\\,\\mathrm{K}$, $T_R = 300.0\\,\\mathrm{K}$, $T_B = 300.0\\,\\mathrm{K}$, $T_T = 300.0\\,\\mathrm{K}$。\n  - 热源：\n    $\n    q(x,y) = A \\exp\\!\\big(-\\alpha\\big[(x-x_c)^2+(y-y_c)^2\\big]\\big),\\;\n    A = -7.0\\times 10^5\\,\\mathrm{W\\,m^{-3}},\\;\\alpha = 60.0,\\;x_c = 0.25,\\;y_c = 0.75.\n    $\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，形式为包含三个子列表的逗号分隔列表，每个子列表按 $[T_{\\mathrm{center}}, T_{\\mathrm{avg}}, T_{\\mathrm{max}}]$ 的顺序包含三个浮点数，每个浮点数四舍五入到 $6$ 位小数。该行必须如下所示：\n  $$\n  [[t_{A,\\mathrm{center}},t_{A,\\mathrm{avg}},t_{A,\\mathrm{max}}],[t_{B,\\mathrm{center}},t_{B,\\mathrm{avg}},t_{B,\\mathrm{max}}],[t_{C,\\mathrm{center}},t_{C,\\mathrm{avg}},t_{C,\\mathrm{max}}]]\n  $$\n不含任何附加文本。",
            "solution": "用户请求使用有限体积法 (FVM) 求解二维稳态热传导问题。首先对问题的科学性和逻辑完整性进行验证。\n\n### 问题验证\n\n**1. 提取的已知条件：**\n- **控制方程：** 对于恒定热导率 $k$，稳态热传导方程被指定为泊松型方程：$\\nabla \\cdot (k \\nabla T) + q(x,y) = 0$。\n- **域：** 矩形域 $\\Omega = \\{(x,y) \\mid 0 \\le x \\le L_x,\\; 0 \\le y \\le L_y\\}$。\n- **边界条件：** 在所有四个边界上都指定了狄利克雷条件：$T(0,y) = T_L$，$T(L_x,y) = T_R$，$T(x,0) = T_B$ 和 $T(x,L_y) = T_T$。\n- **离散化：** 域被划分为 $N_x \\times N_y$ 个控制体积的均匀网格。单元尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。未知温度 $T_{i,j}$ 位于单元中心 $(x_i, y_j) = ((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$。\n- **数值方法：** 问题要求基于积分守恒定律进行控制体积离散化。通量将使用内部面的中心差分和边界面上的半单元差分来近似。\n- **所需输出：** 对每个测试用例，计算 $T_{\\mathrm{center}}$、$T_{\\mathrm{avg}}$ 和 $T_{\\mathrm{max}}$。\n- **测试用例：** 三个特定的测试用例（A、B、C）被完全定义，包含域尺寸、网格分辨率、热导率、边界温度和源项函数所需的所有参数。\n\n**2. 验证分析：**\n- **科学依据：** 该问题基于应用于热传导的能量守恒基本原理，这是物理学和工程学的核心课题。控制方程是标准的椭圆型偏微分方程（泊松方程）。所提供的物理参数是现实的。该问题在科学上是合理的。\n- **适定性：** 该问题是一个适定的边值问题。对于具有狄利克雷边界条件的线性椭圆型偏微分方程，保证存在唯一且稳定的解。指定的 FVM 离散化方法会产生一个对角占优线性系统，这也保证了唯一的数值解。\n- **客观性与完整性：** 该问题以客观的数学术语陈述。解决问题所需的所有数据——控制方程、域、边界条件、材料属性、源项和离散化参数——都已明确提供。该问题是自洽且明确的。\n\n**3. 结论与行动：**\n该问题被判定为**有效**。这是一个计算物理学中标准的、定义明确的问题。将提供一个解决方案。\n\n### 使用有限体积法进行离散化\n\n分析始于通用控制体积 $V_{i,j}$ 上的控制方程的积分形式，该控制体积以 $(x_i, y_j)$ 为中心，体积为 $\\Delta V = \\Delta x \\Delta y \\cdot 1$：\n$$\n\\int_{V_{i,j}} \\left( \\nabla \\cdot (k \\, \\nabla T) + q(x,y) \\right) dV = 0\n$$\n对第一项应用散度定理，并将源项在单元上近似为常数，我们得到：\n$$\n\\oint_{\\partial V_{i,j}} (k \\, \\nabla T) \\cdot \\mathbf{n} \\, ds + \\bar{q}_{i,j} \\Delta x \\Delta y = 0\n$$\n其中 $\\partial V_{i,j}$ 是控制体积的边界，$\\mathbf{n}$ 是外法向单位向量，$\\bar{q}_{i,j} = q(x_i, y_j)$。该积分表示离开控制体积的净热通量。守恒原理指出，净热流出必须与体积内产生的热量相平衡。热通量矢量定义为 $\\mathbf{J} = -k \\nabla T$。因此，通过四个面（东、西、南、北）的热流出之和必须等于总产热量：\n$$\n(\\text{Flux}_{e} + \\text{Flux}_{w} + \\text{Flux}_{n} + \\text{Flux}_{s})_{\\text{out}} = q(x_i, y_j) \\Delta x \\Delta y\n$$\n令 $T_{i,j}$ 为控制体积 $V_{i,j}$ 中心的温度。其邻居为 $T_{i \\pm 1, j}$ 和 $T_{i, j \\pm 1}$。\n\n**1. 内部控制体积：**\n对于内部单元，通量使用相邻单元中心之间的中心差分来近似：\n- 东面 (e)：Flux$_{e} = k \\frac{T_{i,j} - T_{i+1,j}}{\\Delta x} \\Delta y$\n- 西面 (w)：Flux$_{w} = k \\frac{T_{i,j} - T_{i-1,j}}{\\Delta x} \\Delta y$\n- 北面 (n)：Flux$_{n} = k \\frac{T_{i,j} - T_{i,j+1}}{\\Delta y} \\Delta x$\n- 南面 (s)：Flux$_{s} = k \\frac{T_{i,j} - T_{i,j-1}}{\\Delta y} \\Delta x$\n\n代入平衡方程并除以 $\\Delta x \\Delta y$：\n$$\nk \\frac{T_{i,j}-T_{i+1,j}}{(\\Delta x)^2} + k \\frac{T_{i,j}-T_{i-1,j}}{(\\Delta x)^2} + k \\frac{T_{i,j}-T_{i,j+1}}{(\\Delta y)^2} + k \\frac{T_{i,j}-T_{i,j-1}}{(\\Delta y)^2} = q_{i,j}\n$$\n重新整理以形成关于 $T_{i,j}$ 的线性方程：\n$$\n\\left(\\frac{2k}{(\\Delta x)^2} + \\frac{2k}{(\\Delta y)^2}\\right)T_{i,j} - \\frac{k}{(\\Delta x)^2}T_{i+1,j} - \\frac{k}{(\\Delta x)^2}T_{i-1,j} - \\frac{k}{(\\Delta y)^2}T_{i,j+1} - \\frac{k}{(\\Delta y)^2}T_{i,j-1} = q_{i,j}\n$$\n\n**2. 边界控制体积：**\n对于邻近边界的控制体积，通量计算被修改。考虑靠近左边界的单元 $(0,j)$，其中 $T(0,y) = T_L$。从单元中心 $x_0 = \\Delta x/2$ 到 $x=0$ 处的边界的距离是 $\\Delta x/2$。\n通过西面的流出通量为：\n$$\n\\text{Flux}_{w} = k \\frac{T_{0,j} - T_L}{\\Delta x / 2} \\Delta y\n$$\n单元 $(0,j)$ 的能量平衡变为：\n$$\nk \\frac{T_{0,j}-T_{1,j}}{\\Delta x} \\Delta y + k \\frac{T_{0,j}-T_L}{\\Delta x/2} \\Delta y + \\text{(N/S fluxes)} = q_{0,j} \\Delta x \\Delta y\n$$\n除以 $\\Delta x \\Delta y$ 并重新整理，得到代数方程：\n$$\n\\left(\\frac{3k}{(\\Delta x)^2} + \\frac{2k}{(\\Delta y)^2}\\right)T_{0,j} - \\frac{k}{(\\Delta x)^2}T_{1,j} - \\frac{k}{(\\Delta y)^2}T_{0,j+1} - \\frac{k}{(\\Delta y)^2}T_{0,j-1} = q_{0,j} + \\frac{2k}{(\\Delta x)^2}T_L\n$$\n对于邻近其他三个边界（右、上、下）的单元以及邻近两个边界的角点单元，可以推导出类似的方程。\n\n**3. 线性系统组装：**\n所有 $N = N_x \\times N_y$ 个控制体积的离散方程构成一个大型线性方程组 $A\\mathbf{T} = \\mathbf{b}$，其中 $\\mathbf{T}$ 是未知单元中心温度的向量。使用单个索引 $p = i + j \\times N_x$ 将二维温度网格 $T_{i,j}$ 映射到一维向量 $\\mathbf{T}$。系数矩阵 $A$ 根据推导出的方程进行组装。对于索引为 $p$ 的单元 $(i,j)$：\n- 对角元素 $A_{p,p}$ 包含 $T_{i,j}$ 的系数。\n- 非对角元素 $A_{p, p\\pm1}$ 和 $A_{p, p\\pm N_x}$ 包含相邻温度的系数。\n- 右端项向量元素 $b_p$ 包含源项 $q_{i,j}$ 以及来自边界条件的任何贡献。\n然后求解该系统以找到温度场。得到的矩阵 $A$ 是稀疏、带状且对角占优的，这确保了可以高效地找到唯一解。\n所需的输出——$T_{\\mathrm{center}}$、$T_{\\mathrm{avg}}$ 和 $T_{\\mathrm{max}}$——从得到的温度场计算得出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_case(Lx, Ly, Nx, Ny, k, T_bcs, q_func):\n    \"\"\"\n    Solves the 2D steady-state heat conduction problem for one test case.\n\n    Args:\n        Lx (float): Domain size in x-direction.\n        Ly (float): Domain size in y-direction.\n        Nx (int): Number of control volumes in x-direction.\n        Ny (int): Number of control volumes in y-direction.\n        k (float): Thermal conductivity.\n        T_bcs (dict): Dictionary of boundary temperatures {'L', 'R', 'B', 'T'}.\n        q_func (callable): Function for the heat source q(x, y).\n\n    Returns:\n        list: A list containing [T_center, T_avg, T_max].\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    # Coefficients from discretization\n    Cx = k / dx**2\n    Cy = k / dy**2\n\n    N = Nx * Ny\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Cell center coordinates\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n\n    # Assemble matrix A and vector b\n    for j in range(Ny):\n        for i in range(Nx):\n            p = i + j * Nx  # 1D index for the current cell (i, j)\n            x, y = x_centers[i], y_centers[j]\n\n            # Diagonal element initialization (from interior point stencil)\n            A[p, p] = 2 * Cx + 2 * Cy\n            b[p] = q_func(x, y)\n\n            # West neighbor (i-1, j) or Left boundary\n            if i > 0:\n                A[p, p - 1] = -Cx\n            else:  # Left boundary at x=0\n                A[p, p] += Cx\n                b[p] += 2 * Cx * T_bcs['L']\n\n            # East neighbor (i+1, j) or Right boundary\n            if i  Nx - 1:\n                A[p, p + 1] = -Cx\n            else:  # Right boundary at x=Lx\n                A[p, p] += Cx\n                b[p] += 2 * Cx * T_bcs['R']\n\n            # South neighbor (i, j-1) or Bottom boundary\n            if j > 0:\n                A[p, p - Nx] = -Cy\n            else:  # Bottom boundary at y=0\n                A[p, p] += Cy\n                b[p] += 2 * Cy * T_bcs['B']\n\n            # North neighbor (i, j+1) or Top boundary\n            if j  Ny - 1:\n                A[p, p + Ny] = -Cy\n            else:  # Top boundary at y=Ly\n                A[p, p] += Cy\n                b[p] += 2 * Cy * T_bcs['T']\n\n    # Solve the linear system A * T = b\n    T_vector = linalg.solve(A, b)\n    T_field = T_vector.reshape((Ny, Nx))\n\n    # Calculate required outputs\n    center_ix = Nx // 2\n    center_iy = Ny // 2\n    T_center = T_field[center_iy, center_ix]\n    T_avg = np.mean(T_field)\n    T_max = np.max(T_field)\n\n    return [T_center, T_avg, T_max]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Define source functions for each case\n    def q_A(x, y):\n        A = 1.0e6\n        alpha = 80.0\n        xc, yc = 0.5, 0.5\n        return A * np.exp(-alpha * ((x - xc)**2 + (y - yc)**2))\n\n    def q_B(x, y):\n        return 0.0\n\n    def q_C(x, y):\n        A = -7.0e5\n        alpha = 60.0\n        xc, yc = 0.25, 0.75\n        return A * np.exp(-alpha * ((x - xc)**2 + (y - yc)**2))\n\n    test_cases = [\n        # Test case A\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 300.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_A},\n        # Test case B\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 400.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_B},\n        # Test case C\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 300.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_C}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(\n            case['Lx'], case['Ly'], case['Nx'], case['Ny'],\n            case['k'], case['T_bcs'], case['q_func']\n        )\n        results.append(case_results)\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res_case in results:\n        formatted_case = [f\"{val:.6f}\" for val in res_case]\n        formatted_results.append(f\"[{','.join(formatted_case)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}