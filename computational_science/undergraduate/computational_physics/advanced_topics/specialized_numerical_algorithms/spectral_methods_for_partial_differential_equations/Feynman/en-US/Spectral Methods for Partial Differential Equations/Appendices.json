{
    "hands_on_practices": [
        {
            "introduction": "Spectral methods hinge on representing continuous functions on discrete grids. This exercise delves into the fundamental concept of aliasing, where distinct continuous functions can appear identical when sampled discretely . By constructing a high-frequency wave that masquerades as a low-frequency one, you will gain a concrete understanding of the Nyquist sampling limit and the importance of resolving all relevant frequencies in a simulation.",
            "id": "2440939",
            "problem": "Consider a Fourier pseudospectral discretization of a periodic scalar field relevant to spectral methods for partial differential equations (PDE). Let the spatial domain be $[0,2\\pi)$ with periodic boundary conditions, and let the coarse grid consist of $N=12$ equispaced points $x_j=\\frac{2\\pi j}{N}$ for $j=0,1,\\dots, N-1$. Suppose the low-frequency mode of interest is $\\cos(3x)$. Construct a continuous function $f(x)$ that consists of a single high-frequency cosine component with wavenumber strictly greater than the Nyquist wavenumber $\\frac{N}{2}$, such that sampling $f(x)$ at the coarse grid points yields values identical to those of $\\cos(3x)$ at the same points for all $j=0,1,\\dots, N-1$. Provide your answer as a closed-form analytic expression for $f(x)$ in terms of $x$. All angles must be in radians.",
            "solution": "The problem requires the construction of a high-frequency cosine function, $f(x)$, that is an alias of a low-frequency cosine function, $g(x) = \\cos(3x)$, on a discrete grid. This is a fundamental concept in spectral methods known as aliasing.\n\nFirst, let us formalize the given information.\nThe spatial domain is $[0, 2\\pi)$ with periodic boundary conditions.\nThe discretization grid consists of $N=12$ equispaced points, defined as $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$.\nThe low-frequency function is $g(x) = \\cos(kx)$ with a wavenumber of $k=3$.\nThe target high-frequency function is of the form $f(x) = \\cos(k'x)$, where the wavenumber $k'$ must satisfy $k' > k_{Nyquist}$. The Nyquist wavenumber is defined as $k_{Nyquist} = \\frac{N}{2}$, which in this case is $\\frac{12}{2} = 6$. So, we require $k' > 6$.\nThe core condition is that the functions must be identical when sampled on the grid:\n$$f(x_j) = g(x_j) \\quad \\forall j \\in \\{0, 1, \\dots, N-1\\}$$\nSubstituting the function forms, we get:\n$$\\cos(k'x_j) = \\cos(3x_j)$$\n\nFor the equality $\\cos(A) = \\cos(B)$ to hold, it is necessary that $A = \\pm B + 2\\pi m$ for some integer $m$. Applying this to our condition at each grid point $x_j$:\n$$k'x_j = \\pm 3x_j + 2\\pi m_j$$\nwhere $m_j$ is an integer that could potentially depend on $j$.\nSubstituting $x_j = \\frac{2\\pi j}{N}$:\n$$k' \\frac{2\\pi j}{N} = \\pm 3 \\frac{2\\pi j}{N} + 2\\pi m_j$$\nDividing by $2\\pi$, we find:\n$$\\frac{k'j}{N} = \\pm \\frac{3j}{N} + m_j$$\nThis implies that $(k' \\mp 3)\\frac{j}{N}$ must be an integer for all $j \\in \\{0, 1, \\dots, N-1\\}$. For this to hold for all $j$, including $j=1$, the term $(k' \\mp 3)$ must be an integer multiple of $N$.\nLet $m$ be an integer. The condition for aliasing between two wavenumbers $k'$ and $k$ on a grid of size $N$ is therefore:\n$$k' = \\pm k + mN$$\nThis relationship defines all wavenumbers that are indistinguishable from the wavenumber $k$ on the discrete grid.\n\nIn our problem, we have $k=3$ and $N=12$. We are looking for a wavenumber $k'$ such that:\n$$k' = \\pm 3 + m \\cdot 12$$\nand $k' > 6$. We assume, as is standard, that wavenumbers are non-negative integers. Therefore, we search for $k' = |\\pm 3 + 12m| > 6$.\n\nLet us examine values of the integer $m$:\n- If $m=0$: $k' = |\\pm 3 + 0| = 3$. This is the original wavenumber, which is not greater than $6$.\n- If $m=1$:\n  - $k' = |3 + 12(1)| = 15$. This satisfies the condition $15 > 6$.\n  - $k' = |-3 + 12(1)| = |9| = 9$. This also satisfies the condition $9 > 6$.\n- If $m=-1$:\n  - $k' = |3 + 12(-1)| = |-9| = 9$. This is the same result as for $m=1$.\n  - $k' = |-3 + 12(-1)| = |-15| = 15$. This is also the same result as for $m=1$.\n- If $m=2$:\n  - $k' = |3 + 12(2)| = 27$.\n  - $k' = |-3 + 12(2)| = 21$.\n\nThe set of possible high-frequency wavenumbers that alias to $k=3$ on this grid includes $\\{9, 15, 21, 27, \\dots\\}$. The problem asks for the construction of *a* single such function. The simplest choice is the one corresponding to the smallest valid wavenumber, which is $k'=9$.\n\nTherefore, a continuous function that satisfies all the given conditions is $f(x) = \\cos(9x)$.\n\nLet us verify this solution. We need to show that $\\cos(9x_j) = \\cos(3x_j)$ for $x_j = \\frac{2\\pi j}{12} = \\frac{\\pi j}{6}$.\nThe values on the grid are $\\cos(9 \\frac{\\pi j}{6}) = \\cos(\\frac{3\\pi j}{2})$ and $\\cos(3 \\frac{\\pi j}{6}) = \\cos(\\frac{\\pi j}{2})$.\nThe aliasing relation is $k' = mN-k$, so $9 = 1 \\cdot 12 - 3$.\nAt the grid points $x_j$, we have:\n$$\\cos(k'x_j) = \\cos((mN-k)x_j) = \\cos\\left((mN-k)\\frac{2\\pi j}{N}\\right) = \\cos\\left(2\\pi mj - \\frac{2\\pi kj}{N}\\right)$$\nUsing the cosine angle subtraction identity, $\\cos(A-B) = \\cos(A)\\cos(B) + \\sin(A)\\sin(B)$, with $A=2\\pi mj$ and $B=\\frac{2\\pi kj}{N} = kx_j$. Since $m$ and $j$ are integers, $A$ is an integer multiple of $2\\pi$, so $\\cos(A)=1$ and $\\sin(A)=0$.\nThus,\n$$\\cos(k'x_j) = (1)\\cos(kx_j) + (0)\\sin(kx_j) = \\cos(kx_j)$$\nWith $k'=9$, $k=3$, and $N=12$, this identity holds, confirming that $\\cos(9x)$ is indeed an alias of $\\cos(3x)$ on the specified grid. The chosen function $f(x)=\\cos(9x)$ satisfies all criteria.",
            "answer": "$$\\boxed{\\cos(9x)}$$"
        },
        {
            "introduction": "When representing functions with sharp features or discontinuities using a truncated Fourier series, the infamous Gibbs phenomenon arises, causing persistent oscillations near the jump. This practice allows you to tackle this issue head-on by designing and applying a Lanczos spectral filter, a technique used to improve the quality of spectral approximations . You will quantitatively analyze the trade-off between suppressing these oscillations and maintaining the spatial resolution of the feature, a crucial consideration in many practical physics problems.",
            "id": "2440900",
            "problem": "You are asked to design and evaluate a Lanczos spectral filter for the Fourier representation of a discontinuous function in order to suppress the Gibbs phenomenon while quantifying the trade-off between oscillation reduction and spatial resolution. Consider the square wave $s(x)$ defined on the periodic domain $\\left[-\\pi,\\pi\\right)$ by\n$$\ns(x) =\n\\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (-\\pi,0),\\\\\n\\end{cases}\n$$\nwith $s(0)$ and $s(\\pm \\pi)$ defined by periodicity. Let $s(x)$ have the standard Fourier series representation\n$$\ns(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right),\n$$\nwith coefficients given by the integrals\n$$\na_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\cos(nx)\\,dx, \\quad b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\sin(nx)\\,dx.\n$$\nFor a given positive integer truncation level $N$, define the unfiltered truncated series\n$$\nS_N(x) = \\frac{a_0}{2} + \\sum_{n=1}^{N} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right).\n$$\nDefine the Lanczos-filtered truncated series of order $p \\in \\mathbb{N}_0$ (nonnegative integer) by applying the multiplicative spectral factors\n$$\n\\sigma_n^{(p)} = \\left(\\mathrm{sinc}\\!\\left(\\frac{n}{N+1}\\right)\\right)^{p}, \\quad \\mathrm{sinc}(u) = \\begin{cases}\n\\frac{\\sin(\\pi u)}{\\pi u}, & u \\neq 0,\\\\\n1, & u=0,\n\\end{cases}\n$$\nto obtain\n$$\nS_{N,p}^{\\text{(LZ)}}(x) = \\frac{a_0}{2}\\,\\sigma_0^{(p)} + \\sum_{n=1}^{N} \\sigma_n^{(p)}\\left(a_n \\cos(nx) + b_n \\sin(nx)\\right),\n$$\nwhere $\\sigma_0^{(p)} \\equiv 1$. All angles are to be interpreted in radians.\n\nYour task is to compute, for each specified pair $(N,p)$ in the provided test suite, the following two quantitative diagnostics for $S_{N,p}^{\\text{(LZ)}}(x)$ sampled on a uniform grid of $M$ points:\n- The oscillation amplitude near the discontinuity (overshoot magnitude), defined as\n$$\n\\mathcal{O}(N,p) = \\max\\left\\{\\,\\max_{x \\in (0,w_{\\text{ov}}]} \\left(S_{N,p}^{\\text{(LZ)}}(x) - 1\\right),\\ \\max_{x \\in [-w_{\\text{ov}},0)} \\left(-\\big(S_{N,p}^{\\text{(LZ)}}(x)+1\\big)\\right),\\ 0\\,\\right\\},\n$$\nwhich measures the largest positive excursion above the upper plateau or below the lower plateau within a symmetric window of half-width $w_{\\text{ov}}$ around the jump at $x=0$.\n- The effective transition width, defined by the reciprocal of the maximum slope in a neighborhood to the right of the jump,\n$$\n\\mathcal{W}(N,p) = \\frac{2}{\\displaystyle \\max_{x \\in [0,w_{\\text{sl}}]} \\left|\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x)\\right|},\n$$\nwhich quantifies the distance, in radians, required to traverse a unit step height of $2$ at the steepest point near the discontinuity.\n\nUse a uniform grid $x_j = -\\pi + j \\Delta x$ with $j=0,1,\\dots,M-1$, $\\Delta x = \\frac{2\\pi}{M}$, and $M = 16384$. Use $w_{\\text{ov}} = \\frac{\\pi}{4}$ and $w_{\\text{sl}} = \\frac{\\pi}{8}$. When evaluating $\\mathcal{W}(N,p)$, compute the derivative exactly by termwise differentiation of the truncated filtered series, that is,\n$$\n\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x) = -\\sum_{n=1}^{N} \\sigma_n^{(p)} a_n\\, n \\sin(nx) + \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n\\, n \\cos(nx).\n$$\n\nTest suite. Evaluate the ordered list of $(N,p)$ pairs\n$$\n\\big[(9,0),\\ (9,1),\\ (63,0),\\ (63,1),\\ (63,2),\\ (255,1)\\big].\n$$\n\nAnswer specification and units. For each $(N,p)$, produce a pair $[\\mathcal{O}(N,p),\\ \\mathcal{W}(N,p)]$ with both entries expressed as real numbers in radians for $\\mathcal{W}(N,p)$ and dimensionless for $\\mathcal{O}(N,p)$. Round each real number to $6$ decimal places.\n\nFinal output format. Your program should produce a single line of output containing a list of $6$ pairs, each pair formatted as $[\\text{overshoot},\\text{width}]$, and the list enclosed in square brackets, with pairs separated by commas and no additional spaces or text. The final output must therefore have the form\n$$\n\\big[[\\mathcal{O}(N_1,p_1),\\mathcal{W}(N_1,p_1)],\\dots,[\\mathcal{O}(N_6,p_6),\\mathcal{W}(N_6,p_6)]\\big],\n$$\nwith all numbers rounded to $6$ decimal places, and angles in radians.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, objective, and self-contained. It presents a standard exercise in computational physics and applied mathematics concerning the application of spectral filters to mitigate the Gibbs phenomenon in Fourier series representations of discontinuous functions. All necessary parameters, definitions, and evaluation metrics are provided unambiguously. Therefore, we may proceed with the solution.\n\nThe core of the problem is to analyze the Fourier series of a square wave and to quantify the effects of a Lanczos spectral filter on its partial sum. The solution involves three primary steps: first, determining the analytical form of the Fourier coefficients; second, constructing the truncated and filtered series representations; and third, numerically evaluating the specified diagnostics for overshoot and transition width.\n\n**1. Fourier Coefficients of the Square Wave**\n\nThe function $s(x)$ is defined on the interval $[-\\pi, \\pi)$ as:\n$$\ns(x) =\n\\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (-\\pi,0).\n\\end{cases}\n$$\nThis is an odd function, satisfying $s(-x) = -s(x)$. The Fourier series is given by\n$$\ns(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right).\n$$\nFor an odd function integrated over a symmetric interval $[-\\pi, \\pi]$, the cosine coefficients $a_n$ are identically zero. The integrand for $a_n$, which is $s(x)\\cos(nx)$, is an odd function (odd $\\times$ even), and its integral over $[-\\pi, \\pi]$ is zero.\n$$\na_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\cos(nx)\\,dx = 0, \\quad \\text{for all } n \\ge 0.\n$$\nThe sine coefficients $b_n$ are non-zero. The integrand $s(x)\\sin(nx)$ is an even function (odd $\\times$ odd), so the integral can be simplified:\n$$\nb_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\sin(nx)\\,dx = \\frac{2}{\\pi}\\int_{0}^{\\pi} s(x)\\sin(nx)\\,dx.\n$$\nSubstituting $s(x) = 1$ for $x \\in (0, \\pi)$:\n$$\nb_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} \\sin(nx)\\,dx = \\frac{2}{\\pi} \\left[-\\frac{\\cos(nx)}{n}\\right]_{0}^{\\pi} = \\frac{2}{n\\pi} \\left(-\\cos(n\\pi) + \\cos(0)\\right).\n$$\nUsing the identity $\\cos(n\\pi) = (-1)^n$, we get:\n$$\nb_n = \\frac{2}{n\\pi}(1 - (-1)^n).\n$$\nThese coefficients are zero for even $n$ and non-zero for odd $n$:\n$$\nb_n =\n\\begin{cases}\n\\frac{4}{n\\pi}, & \\text{if } n \\text{ is odd},\\\\\n0, & \\text{if } n \\text{ is even}.\n\\end{cases}\n$$\n\n**2. Lanczos-Filtered Truncated Series**\n\nSince $a_n=0$ for all $n$, the truncated Fourier series $S_N(x)$ and its Lanczos-filtered version $S_{N,p}^{\\text{(LZ)}}(x)$ simplify to sums of sine terms only:\n$$\nS_{N,p}^{\\text{(LZ)}}(x) = \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n \\sin(nx),\n$$\nwhere the Lanczos filter factors are given by $\\sigma_n^{(p)} = \\left(\\mathrm{sinc}\\!\\left(\\frac{n}{N+1}\\right)\\right)^{p}$. The purpose of these factors is to smoothly reduce the magnitude of the coefficients $b_n$ as $n$ approaches the truncation level $N$, thereby damping the high-frequency oscillations that cause the Gibbs phenomenon. For $p=0$, $\\sigma_n^{(0)}=1$, corresponding to the unfiltered series. For $p > 0$, the filter becomes progressively more aggressive.\n\nThe derivative of the filtered series is required for calculating the transition width. It is obtained by term-by-term differentiation:\n$$\n\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x) = \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n\\, n \\cos(nx).\n$$\n\n**3. Numerical Evaluation and Diagnostics**\n\nWe will evaluate the series and its derivative on a fine uniform grid of $M=16384$ points spanning the domain $[-\\pi, \\pi)$. Let the grid points be $x_j = -\\pi + j(2\\pi/M)$ for $j = 0, 1, \\dots, M-1$.\n\nFor each pair $(N,p)$ from the test suite, we perform the following computations:\n\n**a) Overshoot Amplitude $\\mathcal{O}(N,p)$:**\nThe overshoot is the maximum deviation from the plateau values of $\\pm 1$ near the discontinuity at $x=0$. It is calculated as:\n$$\n\\mathcal{O}(N,p) = \\max\\left\\{\\,\\max_{x_j \\in (0,w_{\\text{ov}}]} \\left(S_{N,p}^{\\text{(LZ)}}(x_j) - 1\\right),\\ \\max_{x_j \\in [-w_{\\text{ov}},0)} \\left(-\\big(S_{N,p}^{\\text{(LZ)}}(x_j)+1\\big)\\right),\\ 0\\,\\right\\},\n$$\nwith $w_{\\text{ov}} = \\pi/4$. We identify the grid points falling within the two windows $(0, \\pi/4]$ and $[-\\pi/4, 0)$, evaluate the series $S_{N,p}^{\\text{(LZ)}}(x_j)$ at these points, and compute the maximum deviations. By symmetry of the problem, the overshoot above the top plateau and below the bottom plateau will be equal.\n\n**b) Effective Transition Width $\\mathcal{W}(N,p)$:**\nThe transition width quantifies the \"steepness\" of the series as it crosses the discontinuity. A smaller width implies a sharper transition, which is desirable. It is defined as the reciprocal of the maximum slope near the jump, scaled by the total jump height of $2$:\n$$\n\\mathcal{W}(N,p) = \\frac{2}{\\displaystyle \\max_{x_j \\in [0,w_{\\text{sl}}]} \\left|\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x_j)\\right|},\n$$\nwith $w_{\\text{sl}} = \\pi/8$. We evaluate the derivative on the grid points within the window $[0, \\pi/8]$, find the maximum absolute value, and compute the width $\\mathcal{W}$. An increase in filtering ($p>0$) is expected to decrease the maximum slope, thus increasing the transition width $\\mathcal{W}$, demonstrating the trade-off between oscillation suppression and spatial resolution.\n\nThe numerical implementation will be vectorized for efficiency. For each $(N,p)$, we pre-compute the arrays of coefficients $b_n$ and $\\sigma_n^{(p)}$. The series and its derivative can then be evaluated at all grid points $x_j$ using matrix multiplication between the coefficient vectors and matrices of trigonometric function values, $\\sin(nx_j)$ and $\\cos(nx_j)$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Lanczos-filtered Fourier series diagnostics for a square wave.\n    \"\"\"\n    # Problem parameters\n    M = 16384\n    w_ov = np.pi / 4\n    w_sl = np.pi / 8\n    test_cases = [\n        (9, 0),\n        (9, 1),\n        (63, 0),\n        (63, 1),\n        (63, 2),\n        (255, 1)\n    ]\n\n    # Create the uniform grid for x\n    delta_x = 2 * np.pi / M\n    x = np.arange(M) * delta_x - np.pi\n\n    final_results = []\n\n    for N, p in test_cases:\n        # Array of mode numbers from 1 to N\n        n = np.arange(1, N + 1)\n\n        # 1. Compute Fourier and filter coefficients\n        # Fourier coefficients b_n for the square wave\n        b_n = np.zeros(N)\n        odd_indices = (n % 2) != 0\n        n_odd = n[odd_indices]\n        b_n[odd_indices] = 4 / (n_odd * np.pi)\n\n        # Lanczos filter coefficients sigma_n\n        if p == 0:\n            sigma_n = np.ones(N)\n        else:\n            # np.sinc(u) calculates sin(pi*u)/(pi*u)\n            u = n / (N + 1)\n            sigma_n = np.sinc(u)**p\n\n        # Combined coefficients for the series and its derivative\n        # For S(x): c_n = sigma_n * b_n\n        c_n = sigma_n * b_n\n        # For dS/dx(x): d_n = c_n * n\n        d_n = c_n * n\n\n        # 2. Evaluate the series and its derivative on the grid\n        # Reshape for broadcasting (n as column, x as row)\n        n_col = n.reshape(-1, 1)\n        x_row = x.reshape(1, -1)\n\n        # S(x) = sum(c_n * sin(n*x))\n        sin_matrix = np.sin(n_col * x_row)\n        S_x = c_n @ sin_matrix\n\n        # dS/dx(x) = sum(d_n * cos(n*x))\n        cos_matrix = np.cos(n_col * x_row)\n        S_prime_x = d_n @ cos_matrix\n        \n        # 3. Calculate diagnostics\n        \n        # --- Overshoot O(N, p) ---\n        # Window for upper overshoot: (0, w_ov]\n        idx_upper = (x > 0) & (x <= w_ov)\n        overshoot_upper = np.max(S_x[idx_upper] - 1) if np.any(idx_upper) else -np.inf\n\n        # Window for lower overshoot: [-w_ov, 0)\n        idx_lower = (x >= -w_ov) & (x < 0)\n        overshoot_lower = np.max(-(S_x[idx_lower] + 1)) if np.any(idx_lower) else -np.inf\n\n        O = np.max([overshoot_upper, overshoot_lower, 0.0])\n\n        # --- Transition Width W(N, p) ---\n        # Window for slope: [0, w_sl]\n        idx_slope = (x >= 0) & (x <= w_sl)\n        \n        max_slope = 0.0\n        if np.any(idx_slope):\n            max_slope = np.max(np.abs(S_prime_x[idx_slope]))\n        \n        W = 2.0 / max_slope if max_slope > 0 else np.inf\n\n        final_results.append((O, W))\n\n    # 4. Format the output string as per problem specification\n    formatted_pairs = []\n    for O, W in final_results:\n        # Round each value to 6 decimal places before formatting\n        O_rounded = round(O, 6)\n        W_rounded = round(W, 6)\n        formatted_pairs.append(f\"[{O_rounded:.6f},{W_rounded:.6f}]\")\n    \n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of Fourier spectral methods lies in their ability to transform complex differential operators into simple algebraic multiplication. This exercise guides you through solving the two-dimensional biharmonic equation, $\\nabla^4 u = f$, a high-order PDE that appears in fields like elasticity and fluid dynamics . By implementing a solver for this periodic problem, you will master the elegant and highly efficient \"FFT-Solve-IFFT\" workflow, which is a cornerstone of computational physics.",
            "id": "2440935",
            "problem": "Consider the two-dimensional biharmonic equation on a periodic square domain,\n$$\\nabla^4 u(x,y) = f(x,y), \\quad (x,y) \\in [0,1)\\times[0,1),$$\nwith periodic boundary conditions in both spatial directions. Assume the forcing $f$ has zero spatial average, which is necessary for solvability under periodic boundary conditions. You will construct a numerical solver based on spectral methods to recover $u$ from a given $f$.\n\nUse the following fundamental base.\n- Represent sufficiently smooth periodic functions by their Fourier series. On a periodic domain, differentiation in physical space corresponds to multiplication by the angular wave number in Fourier space: if $\\widehat{u}(\\kappa_x,\\kappa_y)$ denotes the Fourier coefficient at angular wave numbers $(\\kappa_x,\\kappa_y)$, then applying a spatial derivative $\\partial/\\partial x$ corresponds to multiplication by $i\\kappa_x$, and similarly for $\\partial/\\partial y$. Consequently, the Laplacian satisfies $\\widehat{\\nabla^2 u}(\\kappa_x,\\kappa_y) = -(\\kappa_x^2+\\kappa_y^2)\\widehat{u}(\\kappa_x,\\kappa_y)$.\n- The Discrete Fourier Transform (DFT), efficiently implemented by the Fast Fourier Transform (FFT), approximates these operations on a uniform grid by mapping grid values to discrete Fourier coefficients. Use the standard Discrete Fourier Transform conventions consistent with widely used numerical libraries. Angles are in radians.\n\nDesign and implement a program that:\n- Discretizes $[0,1)\\times[0,1)$ on a uniform $N\\times N$ grid with points $x_j = j/N$ and $y_k = k/N$ for integers $j,k \\in \\{0,1,\\dots,N-1\\}$.\n- Uses the Discrete Fourier Transform to move to Fourier space, applies the Laplacian operator twice in Fourier space, and inverts back to physical space to approximate $u$. Enforce the zero-mean solution by setting the zero Fourier mode of $u$ to zero. Handle the zero-wave-number division carefully in a mathematically consistent way.\n- Computes the root-mean-square error,\n$$\\mathrm{RMS}(u_{\\mathrm{num}},u_{\\mathrm{exact}})=\\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left(u_{\\mathrm{num}}(x_j,y_k)-u_{\\mathrm{exact}}(x_j,y_k)\\right)^2},$$\nfor each test case below.\n\nTest suite. For each case, construct $f$ analytically from the specified exact solution $u_{\\mathrm{exact}}$. Let $\\pi$ denote the usual circular constant and use the convention that $\\sin$ and $\\cos$ take arguments in radians. Define the angular wavenumbers by $\\kappa_x = 2\\pi n_x$ and $\\kappa_y = 2\\pi n_y$ where $n_x$ and $n_y$ are the integer mode numbers in the $x$ and $y$ directions, respectively. For a pure Fourier mode with mode numbers $(n_x,n_y)$, the biharmonic operator multiplies that mode by $(\\kappa_x^2+\\kappa_y^2)^2$.\n\n- Case A (happy path): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Then\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+1^2\\big)\\right)^2\\,u_{\\mathrm{exact}}(x,y).$$\n- Case B (resolution change): $N = 64$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Same $f$ formula as Case A.\n- Case C (superposition of distinct modes): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\cos(2\\pi x) + \\cos(4\\pi y)$. Then\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+0^2\\big)\\right)^2\\cos(2\\pi x) \\;+\\; \\left(\\big(2\\pi\\big)^2\\big(0^2+2^2\\big)\\right)^2\\cos(4\\pi y).$$\n- Case D (odd $N$ and mixed higher modes): $N = 33$, $u_{\\mathrm{exact}}(x,y) = \\sin(6\\pi x)\\sin(2\\pi y) - 2\\cos(2\\pi x)\\cos(6\\pi y)$. Here both $(n_x,n_y)=(3,1)$ and $(n_x,n_y)=(1,3)$ have $n_x^2+n_y^2 = 10$, so\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\sin(6\\pi x)\\sin(2\\pi y) \\;-\\; 2\\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\cos(2\\pi x)\\cos(6\\pi y).$$\n- Case E (edge case with zero forcing): $N = 40$, $u_{\\mathrm{exact}}(x,y) \\equiv 0$, so $f(x,y)\\equiv 0$.\n\nYour program should compute the numerical solution $u_{\\mathrm{num}}$ for each test case and output the corresponding root-mean-square errors as floating-point numbers. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where $r_i$ is the root-mean-square error for Case $i$. No extra text should be printed.",
            "solution": "The problem statement is scrutinized and found to be valid. It presents a well-posed mathematical problem from computational physics, grounded in established principles of partial differential equations and spectral analysis. All data and conditions are sufficient for the derivation of a unique, verifiable numerical solution. I will therefore proceed with a complete solution.\n\nThe problem is to solve the two-dimensional biharmonic equation,\n$$ \\nabla^4 u(x,y) = f(x,y) $$\non a periodic domain $(x,y) \\in [0,1) \\times [0,1)$. The operator $\\nabla^4$ is the bi-Laplacian, defined as $\\nabla^2(\\nabla^2 u)$. The periodicity of the domain makes the Fourier series an ideal choice of basis for representing the solution $u(x,y)$ and the forcing term $f(x,y)$.\n\nA sufficiently smooth, periodic function $g(x,y)$ on this domain can be represented by its complex Fourier series:\n$$ g(x,y) = \\sum_{n_x=-\\infty}^{\\infty} \\sum_{n_y=-\\infty}^{\\infty} \\widehat{g}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\nwhere $n_x$ and $n_y$ are integer wavenumbers, and $\\widehat{g}_{n_x,n_y}$ are the complex Fourier coefficients. A fundamental property of the Fourier series is that spatial differentiation transforms into algebraic multiplication in the Fourier domain. Applying the Laplacian operator $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ to the function $u(x,y)$ yields:\n$$ \\nabla^2 u(x,y) = \\sum_{n_x,n_y} \\left( (i 2\\pi n_x)^2 + (i 2\\pi n_y)^2 \\right) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} = \\sum_{n_x,n_y} -(2\\pi)^2(n_x^2 + n_y^2) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\nThe Fourier coefficients of $\\nabla^2 u$ are thus related to those of $u$ by $\\widehat{\\nabla^2 u}_{n_x,n_y} = -K^2 \\widehat{u}_{n_x,n_y}$, where $K^2 = (2\\pi n_x)^2 + (2\\pi n_y)^2 = \\kappa_x^2 + \\kappa_y^2$ is the squared magnitude of the wavevector.\n\nApplying the Laplacian twice, we find the action of the biharmonic operator in Fourier space:\n$$ \\widehat{\\nabla^4 u}_{n_x,n_y} = (-\\kappa_x^2 - \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} $$\nThe original partial differential equation $\\nabla^4 u = f$ thus transforms into a set of algebraic equations for the Fourier coefficients:\n$$ (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = \\widehat{f}_{n_x,n_y} $$\nWe can solve for $\\widehat{u}_{n_x,n_y}$:\n$$ \\widehat{u}_{n_x,n_y} = \\frac{\\widehat{f}_{n_x,n_y}}{(\\kappa_x^2 + \\kappa_y^2)^2} = \\frac{\\widehat{f}_{n_x,n_y}}{(2\\pi)^4(n_x^2 + n_y^2)^2} $$\nThis expression is valid for all wavenumbers $(n_x, n_y)$ except for the zero-wavenumber mode $(0,0)$. For this mode, the denominator is zero. The corresponding numerator, $\\widehat{f}_{0,0}$, represents the spatial average of the forcing function $f(x,y)$ over the domain. A necessary condition for the solvability of the biharmonic equation on a periodic domain is that this average must be zero, $\\widehat{f}_{0,0} = 0$. This leads to an indeterminate form $0/0$ for $\\widehat{u}_{0,0}$. The value of $\\widehat{u}_{0,0}$, which is the spatial average of the solution $u(x,y)$, is not determined by the equation. To ensure a unique solution, we enforce the problem's constraint that the solution has a zero mean, which is equivalent to setting $\\widehat{u}_{0,0} = 0$.\n\nThe numerical algorithm implements a discrete analogue of this procedure using the Discrete Fourier Transform (DFT), which is efficiently computed via the Fast Fourier Transform (FFT).\n\nThe algorithm proceeds as follows:\n$1$. The domain $[0,1) \\times [0,1)$ is discretized on a uniform $N \\times N$ grid, with points $(x_j, y_k) = (j/N, k/N)$ for $j, k \\in \\{0, 1, \\dots, N-1\\}$. The forcing function $f(x,y)$ is evaluated on this grid to produce a matrix $F_{jk} = f(x_j, y_k)$.\n\n$2$. The a $2$D FFT of the matrix $F$ is computed to obtain the discrete Fourier coefficients, $\\widehat{F}$. This is an approximation of $\\widehat{f}_{n_x,n_y}$.\n$$ \\widehat{F} = \\mathrm{FFT2D}(F) $$\n\n$3$. A corresponding $N \\times N$ grid of discrete integer wavenumbers $(n_x, n_y)$ is generated. For a domain of length $1$ discretized with $N$ points, the integer wavenumbers corresponding to the FFT output array are given by the sequence $[0, 1, \\dots, N/2-1, -N/2, \\dots, -1]$ for even $N$ (or a similar sequence for odd $N$), which can be generated using a library function like `numpy.fft.fftfreq`.\n\n$4$. The biharmonic operator is applied in the Fourier domain by dividing the coefficients $\\widehat{F}_{n_x,n_y}$ by the discrete version of the operator symbol, $L_{n_x,n_y} = \\left( (2\\pi n_x)^2 + (2\\pi n_y)^2 \\right)^2$. The zero-wavenumber mode is handled separately.\n$$ \\widehat{U}_{n_x,n_y} = \\begin{cases} \\widehat{F}_{n_x,n_y} / L_{n_x,n_y} & \\text{if } (n_x, n_y) \\neq (0,0) \\\\ 0 & \\text{if } (n_x, n_y) = (0,0) \\end{cases} $$\nThis step correctly handles the singularity and enforces the zero-mean solution constraint.\n\n$5$. The numerical solution on the grid, $U_{\\mathrm{num}}$, is recovered by applying the inverse $2$D FFT to the matrix of coefficients $\\widehat{U}$.\n$$ U_{\\mathrm{num}} = \\mathrm{real}(\\mathrm{IFFT2D}(\\widehat{U})) $$\nThe real part is taken to discard negligible imaginary components arising from floating-point inaccuracies.\n\n$6$. Finally, the root-mean-square error is calculated by comparing the numerical solution $U_{\\mathrm{num}}$ with the exact solution $U_{\\mathrm{exact}}$ evaluated on the grid:\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left( (U_{\\mathrm{num}})_{jk} - (U_{\\mathrm{exact}})_{jk} \\right)^2} $$\nThis procedure is applied to each test case to yield the required error values. Since all exact solutions are composed of low-wavenumber sinusoids that are perfectly represented on the specified grids, the expected error is on the order of machine floating-point precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D biharmonic equation on a periodic domain using a spectral method\n    and calculates the RMS error for several test cases.\n    \"\"\"\n    pi = np.pi\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 64,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.cos(2*pi*x) + np.cos(4*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 0**2))**2 * np.cos(2*pi*x) + \\\n                              ((2*pi)**2 * (0**2 + 2**2))**2 * np.cos(4*pi*y)\n        },\n        {\n            'N': 33,\n            'u_exact': lambda x, y: np.sin(6*pi*x)*np.sin(2*pi*y) - 2*np.cos(2*pi*x)*np.cos(6*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * 10)**2 * np.sin(6*pi*x)*np.sin(2*pi*y) - \\\n                              2*((2*pi)**2 * 10)**2 * np.cos(2*pi*x)*np.cos(6*pi*y)\n        },\n        {\n            'N': 40,\n            'u_exact': lambda x, y: 0.0 * x, # Ensures correct shape (N, N) with all zeros\n            'f': lambda x, y: 0.0 * x\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        u_exact_func = case['u_exact']\n        f_func = case['f']\n\n        # 1. Discretize domain and create grid\n        grid_pts = np.arange(N) / N\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='xy')\n\n        # 2. Evaluate exact solution and forcing term on the grid\n        u_exact = u_exact_func(X, Y)\n        f_grid = f_func(X, Y)\n\n        # 3. Solve the PDE using the spectral method\n        \n        # 3a. Forward FFT of the forcing term\n        f_hat = np.fft.fft2(f_grid)\n\n        # 3b. Define discrete integer wavenumbers (modes) n_x, n_y\n        # Using d=1/N in fftfreq scales the result to be the integer mode number.\n        nx = np.fft.fftfreq(N, d=1/N)\n        ny = np.fft.fftfreq(N, d=1/N)\n        NX, NY = np.meshgrid(nx, ny, indexing='xy')\n\n        # 3c. Construct the biharmonic operator symbol in Fourier space\n        # L_hat = ( (2*pi*n_x)^2 + (2*pi*n_y)^2 )^2\n        op_fourier = ((2*pi*NX)**2 + (2*pi*NY)**2)**2\n\n        # 3d. Solve for u_hat, handling the zero-wavenumber mode\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Create a mask for non-zero frequencies to avoid division by zero.\n        # The operator is zero only at the (0,0) frequency.\n        nonzero_mask = op_fourier != 0\n        u_hat[nonzero_mask] = f_hat[nonzero_mask] / op_fourier[nonzero_mask]\n\n        # The zero-mean constraint on u is enforced by setting u_hat[0,0] = 0.\n        # This is already implicitly true because f has zero mean (f_hat[0,0]~0),\n        # but setting it explicitly ensures robustness.\n        u_hat[0, 0] = 0.0\n        \n        # 3e. Inverse FFT to get numerical solution in physical space\n        u_num = np.real(np.fft.ifft2(u_hat))\n\n        # 4. Compute the root-mean-square error\n        rms_error = np.sqrt(np.mean((u_num - u_exact)**2))\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}