{
    "hands_on_practices": [
        {
            "introduction": "紧束缚模型的一个核心成果是能量色散关系 $E(k)$。这个练习将抽象的能带结构概念与电子在实空间中的具体运动联系起来。通过模拟一个高斯波包的时间演化 ，学生可以直观地观察其传播和展宽，从而对群速度和色散等概念建立起动态的理解。",
            "id": "2446520",
            "problem": "考虑一个由 $N$ 个原子位点构成的一维（$1$D）环，其由具有周期性边界条件的最近邻紧束缚（TB）哈密顿量描述。该哈密顿量作用于单粒子波函数 $|\\psi(t)\\rangle$，并在位点基 $|n\\rangle$（其中 $n \\in \\{0,1,\\dots,N-1\\}$ 且 $|n+N\\rangle \\equiv |n\\rangle$）上定义为\n$$\n\\hat{H} = -J \\sum_{n=0}^{N-1} \\left( |n\\rangle\\langle n+1| + |n+1\\rangle\\langle n| \\right),\n$$\n其中 $J>0$ 是跃迁能量。实时演化由含时薛定谔方程决定\n$$\ni \\hbar \\frac{d}{dt} |\\psi(t)\\rangle = \\hat{H} |\\psi(t)\\rangle.\n$$\n在时间 $t=0$ 时，系统被制备在一个归一化的高斯波包中，该波包在位点表象下以位点 $n_0$ 为中心，宽度参数为 $\\sigma$，载波矢为 $k_0$，\n$$\n\\psi_n(0) = \\mathcal{N} \\exp\\!\\left(-\\frac{(n-n_0)^2}{4 \\sigma^2}\\right) \\exp(i k_0 n),\n$$\n其中 $\\mathcal{N}$ 是归一化常数，且 $n \\in \\{0,1,\\dots,N-1\\}$。位点 $n$ 处的概率为 $P_n(t)=|\\psi_n(t)|^2$。将时间 $t$ 时的平均位置和方差定义为\n$$\n\\langle n \\rangle_t = \\sum_{n=0}^{N-1} n\\, P_n(t), \\qquad\n\\mathrm{Var}(t) = \\sum_{n=0}^{N-1} \\left(n - \\langle n \\rangle_t \\right)^2 P_n(t).\n$$\n假设对于下面的参数选择，波包保持良好局域化，不会环绕环，因此上述使用整数坐标 $n$ 的定义是有效的。\n\n仅从上述定义、含时薛定谔方程以及平移不变的最近邻紧束缚链具有平面波本征态这一事实出发，推导一个算法来计算精确的时间演化 $|\\psi(t)\\rangle$ 并评估波包的色散。你还必须通过对晶格平移不变性所产生的单粒子能带能量求导，来获得给定波矢 $k$ 下的解析群速度 $v_g$，并将其与在有限时间间隔内数值测量的平均速度进行比较。\n\n实现一个程序，对下面测试套件中的每组参数，计算两个量：\n- 色散比 $r = \\mathrm{Var}(t_\\mathrm{f}) / \\mathrm{Var}(0)$。\n- 群速度绝对误差 $\\Delta v = \\left| \\frac{\\langle n \\rangle_{t_\\mathrm{f}} - \\langle n \\rangle_{0}}{t_\\mathrm{f}} - v_g(k_0) \\right|$。\n\n约定和单位：使用无量纲的晶格单位，其中晶格间距 $a=1$，约化普朗克常数 $\\hbar=1$。能量以 $J$ 为单位，时间以 $\\hbar/J$ 为单位，位置以晶格位点为单位。所有角度，包括 $k_0$，都必须以弧度为单位。\n\n你的程序必须生成单行输出，其中包含所有结果，形式为方括号内的逗号分隔列表，每个测试用例的两个数字按 $[r_1,\\Delta v_1,r_2,\\Delta v_2,\\dots]$ 的顺序展开。每个数字必须四舍五入到六位小数。\n\n测试套件（每个元组为 $(N,J,\\sigma,k_0,t_\\mathrm{f})$；在所有情况下使用 $n_0 = \\lfloor N/2 \\rfloor$；$k_0$ 以弧度为单位）：\n- 情况 $1$（一般情况）：$(256, 1.0, 12.0, \\pi/3, 40.0)$。\n- 情况 $2$（能带边缘群速度）：$(256, 1.0, 12.0, 0.0, 40.0)$。\n- 情况 $3$（窄波包，更强色散）：$(256, 1.0, 2.0, \\pi/4, 40.0)$。\n- 情况 $4$（不同跃迁，宽波包）：$(512, 0.5, 20.0, \\pi/2, 60.0)$。\n\n你的程序应生成单行输出，其中包含结果，形式为方括号内的逗号分隔列表，顺序为 $[r_1,\\Delta v_1,r_2,\\Delta v_2,r_3,\\Delta v_3,r_4,\\Delta v_4]$，每个值根据上述约定四舍五入到六位小数且无单位。",
            "solution": "所提出的问题是计算量子力学中的一个标准的、适定的练习，具体来说是在一维紧束缚模型中模拟波包动力学。它在科学上是合理的，并提供了所有必要的信息。因此，我们可以直接进行解的推导和实现。\n\n问题的核心在于对给定的初始态求解含时薛定谔方程（TDSE）。哈密顿量是与时间无关的，这使得基于谱分解的高效且精确（达到机器精度）的求解方法成为可能。TDSE 给出为\n$$ i \\hbar \\frac{d}{dt} |\\psi(t)\\rangle = \\hat{H} |\\psi(t)\\rangle $$\n其中晶格常数 $a=1$ 且 $\\hbar=1$。其形式解为\n$$ |\\psi(t)\\rangle = e^{-i \\hat{H} t} |\\psi(0)\\rangle $$\n其中 $e^{-i \\hat{H} t}$ 是时间演化算符。对于大的 $N$，直接计算这个矩阵指数在计算上是不可行的。一个更有效的策略是在哈密顿量本征态的基下工作，此时该算符变为对角阵。\n\n首先，我们将哈密顿量对角化。该系统是一个具有周期性边界条件的 $N$ 位点环，这意味着它具有平移不变性。如问题所述，这样一个系统的本征态是离散的平面波，或称为布洛赫态，由下式给出\n$$ |\\phi_q\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{iqn} |n\\rangle $$\n周期性边界条件 $|n+N\\rangle = |n\\rangle$ 使允许的波矢 $q$ 量子化。为了使波函数是单值的，我们需要 $e^{iq(n+N)} = e^{iqn}$，这意味着 $e^{iqN} = 1$。解是\n$$ q = \\frac{2\\pi m}{N}, \\qquad m \\in \\{0, 1, \\dots, N-1\\} $$\n为了找到与这些本征态对应的能量本征值 $E(q)$，我们将哈密顿量 $\\hat{H} = -J \\sum_{n} (|n\\rangle\\langle n+1| + |n+1\\rangle\\langle n|)$ 应用于 $|\\phi_q\\rangle$：\n$$ \\hat{H} |\\phi_q\\rangle = \\frac{-J}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{iqn} \\left( |n+1\\rangle + |n-1\\rangle \\right) $$\n通过对求和重新索引，我们发现\n$$ \\hat{H} |\\phi_q\\rangle = \\frac{-J}{\\sqrt{N}} \\sum_{n=0}^{N-1} \\left( e^{iq(n-1)} + e^{iq(n+1)} \\right) |n\\rangle = -J(e^{-iq} + e^{iq}) \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{iqn} |n\\rangle $$\n这简化为本征值方程 $\\hat{H} |\\phi_q\\rangle = E(q) |\\phi_q\\rangle$，其能量色散关系为：\n$$ E(q) = -2J \\cos(q) $$\n\n有了完备的本征态集合 $|\\phi_q\\rangle$ 和本征值 $E(q)$，我们就可以表达时间演化。任何态矢量都可以在这个基上展开。初始态 $|\\psi(0)\\rangle = \\sum_{n=0}^{N-1} \\psi_n(0) |n\\rangle$ 被投影到本征基上：\n$$ |\\psi(0)\\rangle = \\sum_q c_q(0) |\\phi_q\\rangle $$\n其中系数 $c_q(0)$ 由交叠 $c_q(0) = \\langle \\phi_q | \\psi(0)\\rangle$ 给出。代入态的表达式，我们得到\n$$ c_q(0) = \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} e^{-iqn} \\psi_n(0) $$\n这个表达式，除去一个归一化因子，就是初始波函数分量 $\\psi_n(0)$ 的离散傅里叶变换（DFT）。这些系数的时间演化很简单：\n$$ c_q(t) = c_q(0) e^{-iE(q)t} $$\n为了获得在时间 $t$ 时位点基下的波函数 $|\\psi(t)\\rangle = \\sum_n \\psi_n(t) |n\\rangle$，我们执行逆变换：\n$$ \\psi_n(t) = \\langle n | \\psi(t)\\rangle = \\sum_q \\langle n | \\phi_q\\rangle c_q(t) = \\frac{1}{\\sqrt{N}} \\sum_q e^{iqn} c_q(t) $$\n这是一个逆离散傅里叶变换（IDFT）。\n\n因此，计算 $|\\psi(t)\\rangle$ 的算法如下：\n1.  构造初始态矢量 $[\\psi_n(0)]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。给定的形式为 $\\psi_n(0) = \\mathcal{N} \\exp(- (n-n_0)^2 / (4\\sigma^2) ) \\exp(ik_0n)$，其中 $\\mathcal{N}$ 是一个常数，其选择使得 $\\sum_n |\\psi_n(0)|^2 = 1$。\n2.  计算 $[\\psi_n(0)]$ 的DFT以获得动量空间系数 $[\\tilde{\\psi}_q(0)]$。在计算上，这是使用快速傅里叶变换（FFT）算法完成的。\n3.  对每个 $q$，计算能量 $E(q) = -2J \\cos(q)$。波矢集合 $\\{q\\}$ 对应于FFT算法使用的频率。\n4.  演化动量空间波函数：$[\\tilde{\\psi}_q(t)] = [\\tilde{\\psi}_q(0)] \\odot [e^{-iE(q)t}]$，其中 $\\odot$ 表示逐元素乘法。\n5.  计算 $[\\tilde{\\psi}_q(t)]$ 的IDFT（通过逆快速傅里叶变换）以获得最终态矢量 $[\\psi_n(t)]$。\n\n一旦波函数 $\\psi_n(0)$ 和 $\\psi_n(t_\\mathrm{f})$ 已知，我们就计算所需的可观测量。\n位点 $n$ 处的概率为 $P_n(t) = |\\psi_n(t)|^2$。平均位置 $\\langle n \\rangle_t$ 和方差 $\\mathrm{Var}(t)$ 由其定义计算：\n$$ \\langle n \\rangle_t = \\sum_{n=0}^{N-1} n P_n(t), \\quad \\mathrm{Var}(t) = \\sum_{n=0}^{N-1} (n - \\langle n \\rangle_t)^2 P_n(t) $$\n问题假设没有环绕效应，这证明了这些简单的求和形式是合理的。色散比为 $r = \\mathrm{Var}(t_\\mathrm{f}) / \\mathrm{Var}(0)$。\n\n具有载波动量 $k$ 的波包的解析群速度 $v_g$ 由色散关系的导数给出，$v_g(k) = dE(k)/dk$。这里，我们有\n$$ v_g(k) = \\frac{d}{dk}(-2J \\cos k) = 2J \\sin k $$\n我们在初始载波矢 $k_0$ 处评估此值。数值测量的平均速度计算为平均位置的总位移除以所用时间：$(\\langle n \\rangle_{t_\\mathrm{f}} - \\langle n \\rangle_0) / t_\\mathrm{f}$。绝对误差 $\\Delta v$ 是数值速度与解析群速度 $v_g(k_0)$ 之差的绝对值。此过程将应用于提供的每组参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tight-binding wave packet dynamics problem\n    for a given set of test cases.\n    \"\"\"\n    # Test suite: (N, J, sigma, k0, tf)\n    # k0 is in radians.\n    test_cases = [\n        (256, 1.0, 12.0, np.pi/3, 40.0),\n        (256, 1.0, 12.0, 0.0, 40.0),\n        (256, 1.0, 2.0, np.pi/4, 40.0),\n        (512, 0.5, 20.0, np.pi/2, 60.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, J, sigma, k0, tf = case\n        \n        # In dimensionless units, hbar=1, a=1.\n        \n        # 1. Construct the initial state\n        n0 = N // 2\n        n_coords = np.arange(N, dtype=float)\n        \n        # Position differences for Gaussian, using direct coordinates as per problem statement\n        # assuming no wrap-around for initial packet shape.\n        pos_diff = n_coords - n0\n        \n        # Unnormalized Gaussian wave packet\n        psi_n_0_un = np.exp(-pos_diff**2 / (4 * sigma**2)) * np.exp(1j * k0 * n_coords)\n        \n        # Normalize the wave function\n        norm_const = np.sqrt(np.sum(np.abs(psi_n_0_un)**2))\n        psi_n_0 = psi_n_0_un / norm_const\n        \n        # 2. Calculate initial observables\n        P_n_0 = np.abs(psi_n_0)**2\n        # Ensure probability is normalized to 1, guarding against floating point dust\n        P_n_0 /= np.sum(P_n_0)\n        \n        mean_n_0 = np.sum(n_coords * P_n_0)\n        var_0 = np.sum((n_coords - mean_n_0)**2 * P_n_0)\n\n        # 3. Time evolution using split-step Fourier method\n        # a. Go to momentum space\n        psi_q_0 = np.fft.fft(psi_n_0)\n        \n        # b. Define momentum grid and energy dispersion\n        # np.fft.fftfreq provides the correct frequencies for np.fft.fft\n        # d=1 corresponds to lattice spacing a=1\n        q_vals = 2 * np.pi * np.fft.fftfreq(N, d=1.0)\n        E_q = -2 * J * np.cos(q_vals)\n        \n        # c. Evolve in momentum space\n        time_evolution_operator = np.exp(-1j * E_q * tf)\n        psi_q_tf = psi_q_0 * time_evolution_operator\n        \n        # d. Go back to position space\n        psi_n_tf = np.fft.ifft(psi_q_tf)\n        \n        # 4. Calculate final observables\n        P_n_tf = np.abs(psi_n_tf)**2\n        P_n_tf /= np.sum(P_n_tf)\n        \n        mean_n_tf = np.sum(n_coords * P_n_tf)\n        var_tf = np.sum((n_coords - mean_n_tf)**2 * P_n_tf)\n        \n        # 5. Calculate required quantities\n        # a. Dispersion ratio r\n        if var_0 == 0:\n            # This case should not happen for sigma > 0\n            r = np.inf if var_tf > 0 else 1.0\n        else:\n            r = var_tf / var_0\n            \n        # b. Group velocity error Delta_v\n        # Analytical group velocity\n        vg_analytical = 2 * J * np.sin(k0)\n        \n        # Numerical group velocity\n        if tf == 0:\n            v_numerical = 0.0 # No motion if no time has passed\n        else:\n            v_numerical = (mean_n_tf - mean_n_0) / tf\n            \n        delta_v = np.abs(v_numerical - vg_analytical)\n        \n        results.extend([r, delta_v])\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的材料并非完美晶体，往往包含空位等缺陷，这些缺陷会显著改变材料的局域电子性质。本练习提供了一种具体的、可动手操作的方法来研究点缺陷的影响 。通过计算局域态密度 (LDOS) 的变化，学生将学习如何量化单个原子空位的电子“指纹”，这是计算材料科学中的一项基本技能。",
            "id": "2446549",
            "problem": "考虑一个由最近邻紧束缚哈密顿量描述的二维正方形晶格，其边界条件为开放边界。设晶格的线性尺寸为 $N$，因此原始系统中的总格点数为 $N^{2}$。设所有格点的在位能为 $\\varepsilon_{i}=0$，最近邻跃迁振幅为 $t>0$。在能量单位中，我们取 $t=1$，并对晶格格点 $(x,y)$ 采用从零开始的坐标系，其中 $x\\in\\{0,\\dots,N-1\\}$ 且 $y\\in\\{0,\\dots,N-1\\}$。二次量子化的哈密顿量为\n$$\n\\hat{H}=\\sum_{i}\\varepsilon_{i}\\,\\hat{c}_{i}^{\\dagger}\\hat{c}_{i}-t\\sum_{\\langle i,j\\rangle}\\left(\\hat{c}_{i}^{\\dagger}\\hat{c}_{j}+\\hat{c}_{j}^{\\dagger}\\hat{c}_{i}\\right),\n$$\n其中 $\\varepsilon_{i}=0$ 且为开放边界条件（没有环绕的邻居）。通过将坐标为 $(x_{v},y_{v})$ 的格点完全从希尔伯特空间中移除（等效于在该格点处施加无限大的在位势），引入一个单位空位缺陷。定义在格点 $r$ 和能量 $E$ 处的局域态密度 (LDOS) 为\n$$\n\\rho_{r}(E)=\\sum_{n}\\left|\\psi_{n}(r)\\right|^{2}\\,\\delta\\!\\left(E-E_{n}\\right),\n$$\n其中 $E_{n}$ 和 $\\psi_{n}(r)$ 分别是单粒子哈密顿量的本征值和归一化本征态的振幅。为了获得数值上明确定义的值，使用半峰全宽为 $\\eta>0$ 的归一化洛伦兹函数来正则化狄拉克δ函数，\n$$\n\\delta(E)\\;\\to\\;\\delta_{\\eta}(E)=\\frac{1}{\\pi}\\frac{\\eta}{E^{2}+\\eta^{2}}.\n$$\n对于一组给定的参数 $(N,E,\\eta,(x_{v},y_{v}),(x_{p},y_{p}))$，其中 $(x_{p},y_{p})$ 是一个不同于空位的探测格点，计算有缺陷晶格与原始晶格在探测格点处局域态密度的差值，\n$$\n\\Delta\\rho(E)\\equiv \\rho^{\\text{defect}}_{(x_{p},y_{p})}(E)-\\rho^{\\text{pristine}}_{(x_{p},y_{p})}(E),\n$$\n能量以 $t$ 为单位表示。\n\n你的任务是编写一个完整的、可运行的程序，对于下面的每个测试用例，构建相应的哈密顿矩阵（原始矩阵和移除空位后的矩阵），计算在指定探测格点和能量处，使用洛伦兹展宽 $\\eta$ 的局域态密度，并输出 $\\Delta\\rho(E)$ 作为一个浮点数。\n\n请使用以下测试套件。所有坐标都是从零开始的。所有能量都以 $t$ 为单位，且 $t=1$。展宽 $\\eta$ 是一个正实数，单位与能量相同。\n\n- 测试用例 $1$：$(N=10, E=0.0, \\eta=0.05, (x_{v},y_{v})=(5,5), (x_{p},y_{p})=(5,4))$。\n- 测试用例 $2$：$(N=10, E=3.9, \\eta=0.05, (x_{v},y_{v})=(1,1), (x_{p},y_{p})=(8,8))$。\n- 测试用例 $3$：$(N=6, E=5.0, \\eta=0.05, (x_{v},y_{v})=(2,3), (x_{p},y_{p})=(2,2))$。\n- 测试用例 $4$：$(N=8, E=0.0, \\eta=0.05, (x_{v},y_{v})=(0,0), (x_{p},y_{p})=(1,0))$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个浮点结果都四舍五入到恰好六位小数，并按顺序对应于上述测试用例。例如，输出必须具有以下形式\n$$\n[\\Delta\\rho_{1},\\Delta\\rho_{2},\\Delta\\rho_{3},\\Delta\\rho_{4}],\n$$\n其中每个 $\\Delta\\rho_{k}$ 都四舍五入到六位小数。",
            "solution": "所提出的问题是计算凝聚态物理学中一个标准的、定义明确的练习。它在科学上是合理的，包含了所有必要的信息，并且没有矛盾或模糊之处。因此，它被认为是有效的。我们将着手解决它。\n\n目标是计算在一个二维正方形晶格中，由于在格点 $(x_{v},y_{v})$ 处引入一个单位空位，而在特定探测格点 $(x_{p},y_{p})$ 处局域态密度 (LDOS) 的变化，记为 $\\Delta\\rho(E)$。该量定义为：\n$$\n\\Delta\\rho(E) \\equiv \\rho^{\\text{defect}}_{(x_{p},y_{p})}(E) - \\rho^{\\text{pristine}}_{(x_{p},y_{p})}(E)\n$$\n分析需要对原始系统和有缺陷的系统进行分别处理。\n\n首先，我们必须为尺寸为 $N \\times N$ 的正方形晶格构建单粒子哈密顿矩阵。格点由坐标 $(x,y)$ 索引，其中 $x, y \\in \\{0, 1, \\dots, N-1\\}$。为了进行矩阵表示，我们将这些二维坐标映射到一个一维索引 $i$。使用标准的行主序映射：\n$$\ni(x,y) = y \\cdot N + x\n$$\n总格点数为 $N^2$，因此索引 $i$ 的范围是从 $0$ 到 $N^2-1$。哈密顿量由下式给出：\n$$\n\\hat{H} = \\sum_{i}\\varepsilon_{i}\\,\\hat{c}_{i}^{\\dagger}\\hat{c}_{i} - t\\sum_{\\langle i,j\\rangle}\\left(\\hat{c}_{i}^{\\dagger}\\hat{c}_{j} + \\hat{c}_{j}^{\\dagger}\\hat{c}_{i}\\right)\n$$\n在单粒子基矢下，矩阵元 $H_{ij}$ 由 $\\langle i | \\hat{H} | j \\rangle$ 给出。当在位能 $\\varepsilon_i = 0$ 且跃迁振幅 $t=1$ 时，矩阵元为：\n$$\nH_{ij} =\n\\begin{cases}\n0   \\text{若 } i = j \\\\\n-1  \\text{若格点 } i \\text{ 和 } j \\text{ 是最近邻} \\\\\n0   \\text{其他情况}\n\\end{cases}\n$$\n这就定义了原始哈密顿矩阵 $H^{\\text{pristine}}$，它是一个实的、对称的 $N^2 \\times N^2$ 矩阵。\n\n接下来，我们考虑在 $(x_v, y_v)$ 处有空位的系统。该缺陷通过从希尔伯特空间中移除相应的格点来建模。如果空位格点的索引是 $v_{\\text{idx}} = y_v \\cdot N + x_v$，则有缺陷的哈密顿量 $H^{\\text{defect}}$ 是通过从 $H^{\\text{pristine}}$ 中删除第 $v_{\\text{idx}}$ 行和第 $v_{\\text{idx}}$ 列得到的。所得矩阵的尺寸为 $(N^2-1) \\times (N^2-1)$。\n\n在索引为 $p$ 的探测格点和能量为 $E$ 处的局域态密度由正则化公式给出：\n$$\n\\rho_{p}(E) = \\sum_{n} |\\psi_{n}(p)|^2 \\frac{1}{\\pi} \\frac{\\eta}{(E-E_n)^2 + \\eta^2}\n$$\n其中 $E_n$ 是本征值，$\\psi_n(p)$ 是第 $n$ 个归一化本征矢量在格点 $p$ 处的振幅。为了计算这个量，我们必须对相应的哈密顿矩阵进行对角化。\n\n对于原始系统：\n$1$. 构建 $N^2 \\times N^2$ 矩阵 $H^{\\text{pristine}}$。\n$2$. 数值求解本征值问题 $H^{\\text{pristine}}\\psi_n = E_n \\psi_n$，以获得本征值集合 $\\{E_n\\}$ 和相应的本征矢量矩阵 $\\Psi$，其中第 $n$ 列是矢量 $\\psi_n$。\n$3$. 确定探测格点的索引，$p_{\\text{idx}} = y_p \\cdot N + x_p$。\n$4$. 平方振幅 $|\\psi_n(p_{\\text{idx}})|^2$ 是本征矢量矩阵 $\\Psi$ 的第 $p_{\\text{idx}}$ 行元素的平方。\n$5$. 使用该公式计算 $\\rho^{\\text{pristine}}_{(x_p,y_p)}(E)$。\n\n对于有缺陷的系统：\n$1$. 通过从 $H^{\\text{pristine}}$ 中移除对应于空位索引 $v_{\\text{idx}} = y_v \\cdot N + x_v$ 的行和列，构建 $(N^2-1) \\times (N^2-1)$ 矩阵 $H^{\\text{defect}}$。\n$2$. 求解 $H^{\\text{defect}}$ 的本征值问题，得到本征值 $\\{E'_m\\}$ 和本征矢量 $\\{\\psi'_m\\}$。\n$3$. 在有缺陷系统的基矢中，探测格点的索引 $p'_{\\text{idx}}$ 必须进行调整。如果 $p_{\\text{idx}} > v_{\\text{idx}}$，则 $p'_{\\text{idx}} = p_{\\text{idx}} - 1$。否则，如果 $p_{\\text{idx}}  v_{\\text{idx}}$，则 $p'_{\\text{idx}} = p_{\\text{idx}}$。根据问题陈述，$p_{\\text{idx}} = v_{\\text{idx}}$ 的情况被排除在外。\n$4$. 使用本征值 $\\{E'_m\\}$、本征矢量振幅 $|\\psi'_m(p'_{\\text{idx}})|^2$ 以及相同的能量 $E$ 和展宽 $\\eta$ 来计算 $\\rho^{\\text{defect}}_{(x_p,y_p)}(E)$。\n\n最后，计算差值 $\\Delta\\rho(E)$。数值实现将利用 `numpy.linalg.eigh`，它对于对角化实对称矩阵非常高效。局域态密度的求和可以使用矢量化操作高效计算。\n\n每个测试用例的计算过程如下：\n$1$. 给定 $(N, E, \\eta, (x_v, y_v), (x_p, y_p))$。\n$2$. 构建原始哈密顿量 $H^{\\text{pristine}}$。\n$3$. 对角化 $H^{\\text{pristine}}$ 并计算 $\\rho^{\\text{pristine}}$。\n$4$. 构建有缺陷的哈密顿量 $H^{\\text{defect}}$。\n$5$. 对角化 $H^{\\text{defect}}$ 并计算 $\\rho^{\\text{defect}}$。\n$6$. 计算差值 $\\Delta\\rho(E) = \\rho^{\\text{defect}} - \\rho^{\\text{pristine}}$。\n\n此方法将应用于问题陈述中提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the change in Local Density of States (LDOS) for a 2D tight-binding model\n    with a single vacancy.\n    \"\"\"\n\n    test_cases = [\n        # (N, E, eta, (xv, yv), (xp, yp))\n        (10, 0.0, 0.05, (5, 5), (5, 4)),\n        (10, 3.9, 0.05, (1, 1), (8, 8)),\n        (6, 5.0, 0.05, (2, 3), (2, 2)),\n        (8, 0.0, 0.05, (0, 0), (1, 0)),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_ldos = calculate_delta_ldos(*case)\n        results.append(delta_ldos)\n\n    # Format the results as required: rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_ldos(hamiltonian, probe_idx, E, eta):\n    \"\"\"\n    Calculates the Local Density of States (LDOS) at a specific probe site.\n    \n    Args:\n        hamiltonian (np.ndarray): The single-particle Hamiltonian matrix.\n        probe_idx (int): The 1D index of the probe site.\n        E (float): The energy at which to calculate the LDOS.\n        eta (float): The Lorentzian broadening parameter.\n\n    Returns:\n        float: The calculated LDOS value.\n    \"\"\"\n    if hamiltonian.shape[0] == 0:\n        return 0.0\n\n    # Diagonalize the Hamiltonian. eigh is for Hermitian matrices.\n    eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian)\n    \n    # Get the squared eigenvector amplitudes at the probe site for all eigenstates.\n    psi_p_sq = eigenvectors[probe_idx, :]**2\n    \n    # Calculate the Lorentzian term for each eigenvalue.\n    lorentzian_terms = eta / ((E - eigenvalues)**2 + eta**2)\n    \n    # Compute the LDOS by summing the contributions from all eigenstates.\n    ldos = (1.0 / math.pi) * np.sum(psi_p_sq * lorentzian_terms)\n    \n    return ldos\n\ndef build_hamiltonian(N, t=1.0):\n    \"\"\"\n    Builds the tight-binding Hamiltonian matrix for an N x N square lattice\n    with open boundary conditions.\n\n    Args:\n        N (int): The linear size of the lattice.\n        t (float): The nearest-neighbor hopping amplitude.\n\n    Returns:\n        np.ndarray: The N^2 x N^2 Hamiltonian matrix.\n    \"\"\"\n    num_sites = N * N\n    hamiltonian = np.zeros((num_sites, num_sites), dtype=float)\n    \n    for i in range(num_sites):\n        # Map 1D index 'i' back to 2D coordinates (x, y)\n        y = i // N\n        x = i % N\n        \n        # Hopping to the right neighbor (x+1, y)\n        if x + 1  N:\n            j = i + 1\n            hamiltonian[i, j] = -t\n            hamiltonian[j, i] = -t\n            \n        # Hopping to the neighbor below (x, y+1)\n        if y + 1  N:\n            j = i + N\n            hamiltonian[i, j] = -t\n            hamiltonian[j, i] = -t\n            \n    return hamiltonian\n\ndef calculate_delta_ldos(N, E, eta, vacancy_coords, probe_coords):\n    \"\"\"\n    Calculates the difference in LDOS between a defective and a pristine lattice.\n\n    Args:\n        N (int): Linear size of the lattice.\n        E (float): Energy for LDOS calculation.\n        eta (float): Lorentzian broadening.\n        vacancy_coords (tuple): (xv, yv) coordinates of the vacancy.\n        probe_coords (tuple): (xp, yp) coordinates of the probe site.\n\n    Returns:\n        float: The value of Delta_rho(E).\n    \"\"\"\n    # Hopping parameter t=1, on-site energy epsilon=0\n    t = 1.0\n\n    # --- Pristine System ---\n    H_pristine = build_hamiltonian(N, t)\n    \n    xp, yp = probe_coords\n    p_idx = yp * N + xp\n    \n    ldos_pristine = calculate_ldos(H_pristine, p_idx, E, eta)\n\n    # --- Defective System ---\n    xv, yv = vacancy_coords\n    v_idx = yv * N + xv\n    \n    # Create the defective Hamiltonian by removing the vacancy row and column\n    H_defect = np.delete(H_pristine, v_idx, axis=0)\n    H_defect = np.delete(H_defect, v_idx, axis=1)\n    \n    # Adjust the probe index for the smaller defective matrix\n    if p_idx > v_idx:\n        p_idx_defect = p_idx - 1\n    else: # p_idx  v_idx, as they cannot be equal\n        p_idx_defect = p_idx\n        \n    ldos_defect = calculate_ldos(H_defect, p_idx_defect, E, eta)\n    \n    # --- Calculate the difference ---\n    delta_ldos = ldos_defect - ldos_pristine\n    \n    return delta_ldos\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "紧束缚模型的应用远不止描述常规的金属和绝缘体，它更是理解物质拓扑相的关键工具。Haldane模型便是一个典型的例子，它展示了在没有净磁场的情况下如何实现量子霍尔效应。这项高级练习将引导学生计算一个拓扑不变量——陈数 (Chern number) ，它用于表征这些奇特的拓扑物相。完成这个练习是通向现代凝聚态物理学的一扇窗口，它揭示了简单的格点模型如何能够承载深刻的、量子化的拓扑性质。",
            "id": "2446546",
            "problem": "你需要编写一个完整的程序，构建蜂窝晶格上 Haldane 模型的布洛赫哈密顿量，并为指定的参数集计算低能（占据）能带的陈数。所有能量均采用无量纲的紧束缚单位，角度必须使用弧度。最终要求的输出是单行文本，包含给定测试用例计算出的陈数列表，其格式严格为方括号括起来的逗号分隔列表（例如，“[1,0,-1]”）。\n\nHaldane 模型是一个定义在蜂窝晶格上的双能带紧束缚模型，具有一个标记为子晶格 $A$ 和 $B$ 的双格点基。该模型包括振幅为 $t_1$ 的最近邻跃迁，振幅为 $t_2 e^{i \\phi}$ 的复次近邻跃迁（该跃迁在每个原胞内无净磁通量的情况下破坏时间反演对称性），以及一个破坏反演对称性的子晶格交错在位势 $M$。\n\n使用以下蜂窝晶格几何结构。将最近邻距离设为单位长度。从子晶格 $A$ 到子晶格 $B$ 的三个最近邻位移矢量为\n$$\n\\boldsymbol{\\delta}_1 = (0,-1),\\quad\n\\boldsymbol{\\delta}_2 = \\left(\\frac{\\sqrt{3}}{2},\\frac{1}{2}\\right),\\quad\n\\boldsymbol{\\delta}_3 = \\left(-\\frac{\\sqrt{3}}{2},\\frac{1}{2}\\right).\n$$\n连接同一子晶格上格点的三个次近邻位移矢量为\n$$\n\\mathbf{a}_1 = \\boldsymbol{\\delta}_2 - \\boldsymbol{\\delta}_3 = (\\sqrt{3}, 0),\\quad\n\\mathbf{a}_2 = \\boldsymbol{\\delta}_3 - \\boldsymbol{\\delta}_1 = \\left(-\\frac{\\sqrt{3}}{2}, \\frac{3}{2}\\right),\\quad\n\\mathbf{a}_3 = \\boldsymbol{\\delta}_1 - \\boldsymbol{\\delta}_2 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2}\\right).\n$$\n为蜂窝结构所属的三角布拉维晶格选择原胞布拉维晶格矢量为\n$$\n\\mathbf{R}_1 = \\mathbf{a}_1,\\quad \\mathbf{R}_2 = \\mathbf{a}_1 + \\mathbf{a}_2.\n$$\n通过以下条件定义倒格矢 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$\n$$\n\\mathbf{R}_i \\cdot \\mathbf{G}_j = 2\\pi \\delta_{ij}.\n$$\n一个布洛赫动量 $\\mathbf{k}$ 位于由 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$ 张成的平行四边形所定义的第一布里渊区内。\n\n在 $(A,B)$ 子晶格基中，布洛赫哈密顿量 $H(\\mathbf{k})$ 是一个 $2\\times 2$ 的厄米矩阵，其矩阵元为\n$$\nH_{AA}(\\mathbf{k}) = M + 2 t_2 \\sum_{j=1}^{3} \\cos(\\phi)\\,\\cos(\\mathbf{k}\\cdot \\mathbf{a}_j) - 2 t_2 \\sum_{j=1}^{3} \\sin(\\phi)\\,\\sin(\\mathbf{k}\\cdot \\mathbf{a}_j),\n$$\n$$\nH_{BB}(\\mathbf{k}) = -M + 2 t_2 \\sum_{j=1}^{3} \\cos(\\phi)\\,\\cos(\\mathbf{k}\\cdot \\mathbf{a}_j) + 2 t_2 \\sum_{j=1}^{3} \\sin(\\phi)\\,\\sin(\\mathbf{k}\\cdot \\mathbf{a}_j),\n$$\n$$\nH_{AB}(\\mathbf{k}) = t_1 \\sum_{j=1}^{3} \\exp\\!\\left(i\\,\\mathbf{k}\\cdot \\boldsymbol{\\delta}_j\\right),\\qquad H_{BA}(\\mathbf{k}) = H_{AB}(\\mathbf{k})^*.\n$$\n令 $|u_-(\\mathbf{k})\\rangle$ 表示 $H(\\mathbf{k})$ 的归一化占据带本征矢量，对应其较低的本征值 $E_-(\\mathbf{k})$。\n\n占据带的陈数定义为\n$$\n\\mathcal{C} = \\frac{1}{2\\pi} \\int_{\\mathrm{BZ}} \\mathcal{F}_{12}(\\mathbf{k})\\, d^2 k,\n$$\n其中 $\\mathcal{F}_{12}(\\mathbf{k})$ 是由 $|u_-(\\mathbf{k})\\rangle$ 构建的贝里曲率，积分范围是第一布里渊区。你的程序必须计算 $\\mathcal{C}$ 的数值近似值，并将其作为四舍五入到最近整数的结果返回。\n\n角度必须使用弧度。没有物理单位；所有量都是无量纲的。\n\n测试用例。对于每一行，参数为 $(t_1, t_2, \\phi, M)$:\n- 情况 1：$(1.0, 0.1, \\tfrac{\\pi}{2}, 0.0)$\n- 情况 2：$(1.0, 0.1, \\tfrac{\\pi}{2}, 0.7)$\n- 情况 3：$(1.0, 0.1, -\\tfrac{\\pi}{2}, 0.0)$\n- 情况 4：$(1.0, 0.0, \\tfrac{\\pi}{3}, 0.0)$\n- 情况 5：$(1.0, 0.2, 0.0, 0.1)$\n\n最终输出格式。你的程序应生成单行输出，其中包含按规定顺序排列的各情况的结果，格式为方括号括起来的逗号分隔列表，每个条目是占据带的整数陈数，例如，“[c1,c2,c3,c4,c5]”。",
            "solution": "该问题要求计算蜂窝晶格上 Haldane 模型占据带的陈数。这将通过在第一布里渊区 (BZ) 上对贝里曲率进行数值积分来完成。\n\n首先，我们验证问题陈述的有效性。所有提供的数据，包括模型参数、晶格矢量和哈密顿量表达式，都与关于 Haldane 模型的既有文献一致。该问题在科学上是合理的、适定的、客观的，并包含足够的信息以获得唯一解。晶格几何和布里渊区的定义是标准的。该任务是计算凝聚态物理中的一个典型问题。因此，该问题被认为是有效的。\n\n对于一个双能带系统，布洛赫哈密顿量 $H(\\mathbf{k})$ 通常可以用泡利矩阵 $\\boldsymbol{\\sigma} = (\\sigma_x, \\sigma_y, \\sigma_z)$ 的基底表示为：\n$$\nH(\\mathbf{k}) = d_0(\\mathbf{k}) I + \\mathbf{d}(\\mathbf{k}) \\cdot \\boldsymbol{\\sigma}\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵，$\\mathbf{d}(\\mathbf{k}) = (d_x(\\mathbf{k}), d_y(\\mathbf{k}), d_z(\\mathbf{k}))$ 是布洛赫动量 $\\mathbf{k}$ 的矢量函数。其矩阵形式为：\n$$\nH(\\mathbf{k}) = \\begin{pmatrix} d_0(\\mathbf{k}) + d_z(\\mathbf{k})  d_x(\\mathbf{k}) - i d_y(\\mathbf{k}) \\\\ d_x(\\mathbf{k}) + i d_y(\\mathbf{k})  d_0(\\mathbf{k}) - d_z(\\mathbf{k}) \\end{pmatrix}\n$$\n通过将此一般形式与给定的哈密顿量矩阵元 $H_{AA}(\\mathbf{k})$、$H_{BB}(\\mathbf{k})$ 和 $H_{AB}(\\mathbf{k})$ 进行比较，我们可以确定 $\\mathbf{d}(\\mathbf{k})$ 的分量：\n$$\nd_0(\\mathbf{k}) = \\frac{1}{2}(H_{AA}(\\mathbf{k}) + H_{BB}(\\mathbf{k})) = 2 t_2 \\cos(\\phi) \\sum_{j=1}^{3} \\cos(\\mathbf{k} \\cdot \\mathbf{a}_j)\n$$\n$$\nd_x(\\mathbf{k}) = \\text{Re}(H_{AB}(\\mathbf{k})) = t_1 \\sum_{j=1}^{3} \\cos(\\mathbf{k} \\cdot \\boldsymbol{\\delta}_j)\n$$\n$$\nd_y(\\mathbf{k}) = -\\text{Im}(H_{AB}(\\mathbf{k})) = -t_1 \\sum_{j=1}^{3} \\sin(\\mathbf{k} \\cdot \\boldsymbol{\\delta}_j)\n$$\n$$\nd_z(\\mathbf{k}) = \\frac{1}{2}(H_{AA}(\\mathbf{k}) - H_{BB}(\\mathbf{k})) = M - 2 t_2 \\sin(\\phi) \\sum_{j=1}^{3} \\sin(\\mathbf{k} \\cdot \\mathbf{a}_j)\n$$\n该哈密顿量的本征值为 $E_\\pm(\\mathbf{k}) = d_0(\\mathbf{k}) \\pm |\\mathbf{d}(\\mathbf{k})|$，其中 $|\\mathbf{d}(\\mathbf{k})| = \\sqrt{d_x(\\mathbf{k})^2 + d_y(\\mathbf{k})^2 + d_z(\\mathbf{k})^2}$。我们关心的是较低的（占据）能带，它对应于本征值 $E_-(\\mathbf{k})$ 及其相关的本征矢量 $|u_-(\\mathbf{k})\\rangle$。\n\n陈数 $\\mathcal{C}$ 是能带结构的一个拓扑不变量，定义为贝里曲率 $\\mathcal{F}_{12}(\\mathbf{k})$ 在第一布里渊区上的积分：\n$$\n\\mathcal{C} = \\frac{1}{2\\pi} \\int_{\\mathrm{BZ}} \\mathcal{F}_{12}(\\mathbf{k})\\, d^2k\n$$\n直接通过其定义（涉及本征矢量的导数）来计算贝里曲率在数值上是不稳定的。一种更稳健且被广泛用于数值计算的方法是由 Fukui、Hatsugai 和 Suzuki 提出的方法。该方法将布里渊区离散化，并将陈数计算为一系列局域规范不变的量（格框相位）之和。\n\n算法如下：\n1.  定义原胞布拉维晶格矢量 $\\mathbf{R}_1$ 和 $\\mathbf{R}_2$，并由此得到满足 $\\mathbf{R}_i \\cdot \\mathbf{G}_j = 2\\pi \\delta_{ij}$ 的倒格矢 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$。使用所提供的矢量：\n    $\\mathbf{R}_1 = (\\sqrt{3}, 0)$ 和 $\\mathbf{R}_2 = (\\frac{\\sqrt{3}}{2}, \\frac{3}{2})$。\n    可求得倒格矢为 $\\mathbf{G}_1 = (\\frac{2\\pi}{\\sqrt{3}}, -\\frac{2\\pi}{3})$ 和 $\\mathbf{G}_2 = (0, \\frac{4\\pi}{3})$。\n2.  将由 $\\mathbf{G}_1$ 和 $\\mathbf{G}_2$ 张成的平行四边形所代表的第一布里渊区离散化为一个 $N \\times N$ 点的均匀网格。网格上的点由 $\\mathbf{k}_{nm} = \\frac{n}{N}\\mathbf{G}_1 + \\frac{m}{N}\\mathbf{G}_2$ 给出，其中整数 $n, m \\in [0, N-1]$。$N=100$ 的网格尺寸足以获得精确结果。\n3.  对于网格上的每个点 $\\mathbf{k}_{nm}$，构建哈密顿矩阵 $H(\\mathbf{k}_{nm})$ 并数值计算其本征值和本征矢量。存储对应于较低本征值 $E_-(\\mathbf{k}_{nm})$ 的本征矢量 $|u_{nm}\\rangle$。\n4.  在网格上的相邻点之间定义连接变量，表示基态波函数的交叠：\n    $$\n    U_{1,nm} = \\langle u_{nm} | u_{n+1,m} \\rangle \\qquad U_{2,nm} = \\langle u_{nm} | u_{n,m+1} \\rangle\n    $$\n    此处，索引对 $N$ 取模，以在布里渊区环面上强制施加周期性边界条件。k 空间矢量为 $\\mathbf{k}_{n+1,m} = \\mathbf{k}_{nm} + \\mathbf{G}_1/N$ 和 $\\mathbf{k}_{n,m+1} = \\mathbf{k}_{nm} + \\mathbf{G}_2/N$。\n5.  对于网格上的每个基本格框 $(n,m)$，计算格框相位，它是穿过该格框的贝里曲率通量的离散模拟：\n    $$\n    F_{nm} = \\arg\\left( U_{1,nm} U_{2,n+1,m} U_{1,n,m+1}^* U_{2,nm}^* \\right)\n    $$\n    复数辐角函数 $\\arg(z)$ 的取值范围必须在 $(-\\pi, \\pi]$ 内。\n6.  总陈数是所有格框上的这些局域相位之和，再用 $2\\pi$ 归一化：\n    $$\n    \\mathcal{C} = \\frac{1}{2\\pi} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} F_{nm}\n    $$\n    由于有能隙能带的陈数保证为整数，因此将数值结果四舍五入到最近的整数，以消除有限精度误差。\n\n所提供的程序实现了这种数值方案。它定义了一个函数，用于为给定的参数集 $(t_1, t_2, \\phi, M)$ 和动量 $\\mathbf{k}$ 构建哈密顿量。然后，它遍历每个测试用例，构建本征矢量网格，计算格框相位之和，并计算陈数。所有测试用例的最终结果被收集并以指定格式打印。计算中使用的矢量是：\n$\\boldsymbol{\\delta}_1 = (0,-1)$，$\\boldsymbol{\\delta}_2 = (\\frac{\\sqrt{3}}{2},\\frac{1}{2})$，$\\boldsymbol{\\delta}_3 = (-\\frac{\\sqrt{3}}{2},\\frac{1}{2})$。\n$\\mathbf{a}_1 = (\\sqrt{3}, 0)$，$\\mathbf{a}_2 = (-\\frac{\\sqrt{3}}{2}, \\frac{3}{2})$，$\\mathbf{a}_3 = (-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2})$。\n所有计算均按规定使用无量纲量进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Chern number of the Haldane model for a suite of test cases.\n    \"\"\"\n\n    # Define the honeycomb lattice geometry vectors\n    sqrt3 = np.sqrt(3.0)\n    delta1 = np.array([0.0, -1.0])\n    delta2 = np.array([sqrt3 / 2.0, 1.0 / 2.0])\n    delta3 = np.array([-sqrt3 / 2.0, 1.0 / 2.0])\n    deltas = [delta1, delta2, delta3]\n\n    a1 = delta2 - delta3\n    a2 = delta3 - delta1\n    a3 = delta1 - delta2\n    a_vecs = [a1, a2, a3]\n\n    # Define primitive reciprocal lattice vectors\n    # R1 = a1, R2 = a1 + a2\n    # G1, G2 are defined by R_i . G_j = 2*pi*delta_ij\n    # G1 = (2*pi/sqrt3, -2*pi/3)\n    # G2 = (0, 4*pi/3)\n    G1 = np.array([2.0 * np.pi / sqrt3, -2.0 * np.pi / 3.0])\n    G2 = np.array([0.0, 4.0 * np.pi / 3.0])\n\n    # Numerical parameters\n    N_k = 100  # Grid size for Brillouin zone discretization\n\n    test_cases = [\n        # (t1, t2, phi, M)\n        (1.0, 0.1, np.pi / 2.0, 0.0),\n        (1.0, 0.1, np.pi / 2.0, 0.7),\n        (1.0, 0.1, -np.pi / 2.0, 0.0),\n        (1.0, 0.0, np.pi / 3.0, 0.0),\n        (1.0, 0.2, 0.0, 0.1),\n    ]\n\n    results = []\n    for t1, t2, phi, M in test_cases:\n        \n        k_grid_points = np.zeros((N_k, N_k, 2))\n        for n in range(N_k):\n            for m in range(N_k):\n                k_grid_points[n, m] = (n / N_k) * G1 + (m / N_k) * G2\n\n        eigenvectors = np.zeros((N_k, N_k, 2), dtype=np.complex128)\n\n        for n in range(N_k):\n            for m in range(N_k):\n                k = k_grid_points[n, m]\n                \n                # Calculate sums for Hamiltonian components\n                sum_exp_k_delta = np.sum([np.exp(1j * np.dot(k, d)) for d in deltas])\n                \n                cos_k_a = [np.cos(np.dot(k, a)) for a in a_vecs]\n                sin_k_a = [np.sin(np.dot(k, a)) for a in a_vecs]\n\n                # Hamiltonian matrix elements\n                H_AA = M + 2.0 * t2 * np.cos(phi) * np.sum(cos_k_a) - 2.0 * t2 * np.sin(phi) * np.sum(sin_k_a)\n                H_BB = -M + 2.0 * t2 * np.cos(phi) * np.sum(cos_k_a) + 2.0 * t2 * np.sin(phi) * np.sum(sin_k_a)\n                H_AB = t1 * sum_exp_k_delta\n                H_BA = np.conjugate(H_AB)\n\n                H = np.array([[H_AA, H_AB], [H_BA, H_BB]])\n\n                # Diagonalize the Hamiltonian\n                # eigh ensures real eigenvalues and returns normalized eigenvectors\n                eigenvalues, evecs = np.linalg.eigh(H)\n                \n                # Store the eigenvector for the lower band (occupied band)\n                eigenvectors[n, m] = evecs[:, 0]\n\n        total_berry_phase = 0.0\n        for n in range(N_k):\n            for m in range(N_k):\n                # Get eigenvectors for the four corners of the plaquette\n                u_nm = eigenvectors[n, m]\n                u_n1m = eigenvectors[(n + 1) % N_k, m]\n                u_nm1 = eigenvectors[n, (m + 1) % N_k]\n                u_n1m1 = eigenvectors[(n + 1) % N_k, (m + 1) % N_k]\n\n                # Compute link variables\n                U1_nm = np.vdot(u_nm, u_n1m)\n                U2_nm = np.vdot(u_nm, u_nm1)\n                \n                # Need links from neighboring sites to complete the plaquette\n                U1_nm1 = np.vdot(u_nm1, u_n1m1)\n                U2_n1m = np.vdot(u_n1m, u_n1m1)\n                \n                # Compute plaquette phase (local Berry curvature)\n                # F = arg( U1(n,m) U2(n+1,m) U1(n,m+1)* U2(n,m)* )\n                # Plaquette gauge field must be gauge invariant\n                plaquette_val = U1_nm * U2_n1m * np.conjugate(U1_nm1) * np.conjugate(U2_nm)\n                \n                # np.angle returns argument in [-pi, pi]\n                berry_phase_nm = np.angle(plaquette_val)\n                total_berry_phase += berry_phase_nm\n\n        # The Chern number is the sum of phases divided by 2*pi\n        chern_number = total_berry_phase / (2.0 * np.pi)\n        \n        # Round to the nearest integer\n        results.append(int(np.round(chern_number)))\n    \n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}