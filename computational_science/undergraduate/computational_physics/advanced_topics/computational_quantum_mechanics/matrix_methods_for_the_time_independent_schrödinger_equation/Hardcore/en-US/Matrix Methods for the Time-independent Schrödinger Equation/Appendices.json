{
    "hands_on_practices": [
        {
            "introduction": "The best way to master a computational technique is to apply it. This first exercise grounds the theory in a concrete, one-dimensional problem, which is the foundational starting point for solving the Schrödinger equation numerically. You will construct a matrix for the Hamiltonian operator $\\hat{H}$ by discretizing space and then find its eigenvalues, which correspond to the quantized energy levels of a particle. To make things interesting and ensure a numerical approach is necessary, this problem uses a unique, non-standard potential landscape constructed from the digits of the mathematical constant $\\pi$, providing excellent practice in implementing the finite-difference method from the ground up .",
            "id": "2411985",
            "problem": "Consider the one-dimensional, time-independent Schrödinger equation $-\\dfrac{\\hbar^2}{2m}\\dfrac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)$ on a finite domain with homogeneous Dirichlet boundary conditions. In dimensionless units with $\\hbar^2/(2m) = 1$, this becomes $-\\dfrac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)$. Let the potential be a piecewise-constant function constructed from the decimal digits of the mathematical constant $\\pi$, as follows: for each integer $i \\in \\{0,1,2,\\dots\\}$, define $V(x) = \\pi_i$ for $x \\in [i,i+1)$, where $\\pi_i$ denotes the $i$-th digit in the sequence $(3,1,4,1,5,9,2,6,5,3,\\dots)$, starting from the integer part $3$ at $i=0$. Truncate the domain to $x \\in [0,L]$ with $L = N$, where $N$ is the number of digits used.\n\nYour task is to start from the definition of the time-independent Schrödinger equation and construct a matrix representation of the Hamiltonian using a uniform spatial discretization and the second-order central-difference approximation for the second derivative. Impose homogeneous Dirichlet boundary conditions $\\psi(0)=0$ and $\\psi(L)=0$. The potential must be sampled consistently with the piecewise-constant definition above: for each grid point $x_j$, assign $V_j = \\pi_{\\lfloor x_j \\rfloor}$, with the convention that $[i,i+1)$ is left-closed and right-open. Work entirely in units where $\\hbar^2/(2m)=1$, so that the energies $E$ are dimensionless and expressed in the same units as $V(x)$.\n\nAlgorithmic requirements:\n- Use a uniform grid with $r$ subintervals per unit length, i.e., grid spacing $h = 1/r$. This places grid points at $x_j = jh$ for integer $j$. On $x \\in [0,L]$ with Dirichlet boundary conditions at $x=0$ and $x=L$, the number of interior grid points is $M = Lr - 1$. You must build the Hamiltonian matrix on these $M$ interior points using the standard three-point stencil for the second derivative and add the diagonal matrix of sampled potential values.\n- Compute the lowest $k$ energy eigenvalues by solving the resulting symmetric matrix eigenvalue problem and sort them in ascending order.\n\nPhysical and numerical units:\n- Report all energies $E$ in the dimensionless units defined by $\\hbar^2/(2m)=1$.\n- Round each returned energy to $6$ decimal places.\n\nTest suite and answer specification:\nFor each of the parameter sets below, compute and return the lowest $k$ eigenvalues as a list of floats rounded to $6$ decimal places. The $\\pi$-digit potential must be formed from the initial digits $(3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,\\dots)$, ignoring the decimal point and using only as many digits as required by each test case:\n- Case $1$ (happy path): $N=4$, $r=51$ (i.e., $50$ interior points per unit interval), $k=3$.\n- Case $2$ (boundary condition and constant potential check): $N=1$, $r=61$, $k=2$.\n- Case $3$ (longer domain, moderate resolution): $N=8$, $r=41$, $k=4$.\n- Case $4$ (coarser resolution, longer domain): $N=12$, $r=31$, $k=3$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, with no spaces. Each inner list corresponds to one test case in the order given above and contains the lowest $k$ energies for that case. For example, the format must be exactly like $[[e_{1,1},e_{1,2},\\dots],[e_{2,1},e_{2,2},\\dots],\\dots]$ where every $e_{i,j}$ is a float rounded to $6$ decimals.",
            "solution": "The problem requires the computation of the lowest energy eigenvalues for the one-dimensional, time-independent Schrödinger equation (TISE) on a finite domain. The governing equation, in dimensionless units where $\\hbar^2/(2m)=1$, is:\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)\n$$\nThis constitutes an eigenvalue problem for the Hamiltonian operator $\\hat{H} = -\\frac{d^2}{dx^2} + V(x)$, where the eigenvalues $E$ correspond to the quantized energy levels of the system and $\\psi(x)$ are the corresponding energy eigenfunctions (stationary states). The system is confined to a spatial domain $x \\in [0, L]$, with the domain length $L$ specified as an integer $N$. Homogeneous Dirichlet boundary conditions are imposed at the edges of the domain, meaning $\\psi(0)=0$ and $\\psi(L)=0$. Such a configuration is a standard Sturm-Liouville problem, which guarantees the existence of a discrete, real-valued energy spectrum bounded from below.\n\nTo find the eigenvalues, we must solve this differential equation. We will employ the finite difference method, a robust numerical technique for approximating differential operators. The first step is to discretize the continuous spatial domain $[0, L]$ into a uniform grid. The grid spacing is defined as $h=1/r$, where $r$ is a given resolution parameter representing the number of subintervals per unit length. The grid points are located at positions $x_j = jh$ for integer indices $j=0, 1, 2, \\dots, Lr$. The wave function $\\psi(x)$ is then approximated by its values at these discrete points, $\\psi_j = \\psi(x_j)$. The boundary conditions directly imply that $\\psi_0 = 0$ and $\\psi_{Lr} = 0$. Our task is to determine the values of $\\psi_j$ for the $M = Lr-1$ interior grid points, where $j$ ranges from $1$ to $M$.\n\nThe second-order derivative term $\\frac{d^2\\psi}{dx^2}$ in the Hamiltonian is approximated at each interior grid point $x_j$ using the second-order accurate central difference formula:\n$$\n\\left. \\frac{d^2\\psi}{dx^2} \\right|_{x=x_j} \\approx \\frac{\\psi(x_{j+1}) - 2\\psi(x_j) + \\psi(x_{j-1})}{h^2} = \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{h^2}\n$$\nBy substituting this approximation into the TISE for each interior point $x_j$, we convert the single differential equation into a system of $M$ coupled algebraic equations:\n$$\n-\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{h^2} + V_j \\psi_j = E \\psi_j\n$$\nHere, $V_j = V(x_j)$ is the potential sampled at the grid point $x_j$. This equation can be rearranged to isolate the terms for a given grid point $j$:\n$$\n-\\frac{1}{h^2}\\psi_{j-1} + \\left(\\frac{2}{h^2} + V_j\\right)\\psi_j - \\frac{1}{h^2}\\psi_{j+1} = E\\psi_j\n$$\nThis system of $M$ linear equations is equivalent to a matrix eigenvalue equation $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$. In this formulation, $\\vec{\\psi} = (\\psi_1, \\psi_2, \\dots, \\psi_M)^T$ is the column vector of the wave function values at the interior points, and $\\mathbf{H}$ is the $M \\times M$ matrix representation of the Hamiltonian operator.\n\nThe Hamiltonian matrix $\\mathbf{H}$ is the sum of a kinetic energy matrix $\\mathbf{T}$ and a potential energy matrix $\\mathbf{V}$. The matrix $\\mathbf{T}$ is the discrete representation of the operator $-\\frac{d^2}{dx^2}$. It is a tridiagonal matrix with elements derived from the central difference formula:\n$$\nT_{ij} = \\frac{1}{h^2} \\begin{cases} 2  \\text{if } i=j \\\\ -1  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nThe boundary conditions $\\psi_0=0$ and $\\psi_{M+1}=0$ are implicitly handled by this structure when considering only the interior points. The potential energy matrix $\\mathbf{V}$ is a diagonal matrix, where the diagonal elements are the values of the potential at each corresponding interior grid point: $V_{ij} = V_i \\delta_{ij}$. The potential function $V(x)$ is specified as a piecewise-constant function constructed from the decimal digits of $\\pi$. Specifically, $V(x) = \\pi_i$ for $x \\in [i, i+1)$, where $\\pi_i$ is the $i$-th digit of $\\pi$ starting with $\\pi_0=3$. The potential at a grid point $x_j$ is thus given by the sampling rule $V_j = V(x_j) = \\pi_{\\lfloor x_j \\rfloor}$.\n\nThe full Hamiltonian matrix $\\mathbf{H} = \\mathbf{T} + \\mathbf{V}$ is therefore a real, symmetric, tridiagonal matrix with elements:\n$$\nH_{ij} = \\begin{cases} \\frac{2}{h^2} + V_i  \\text{if } i=j \\\\ -\\frac{1}{h^2}  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n(Note that matrix indices $i,j$ run from $1$ to $M$). The problem of finding the allowed energies $E$ is now reduced to finding the eigenvalues of this matrix $\\mathbf{H}$.\n\nThe computational algorithm for each specified test case $(N, r, k)$ is as follows:\n$1$. Set the physical and grid parameters: domain length $L=N$, grid spacing $h=1/r$, and the number of interior grid points $M=Nr-1$.\n$2$. Generate the $M$-element vector of potential values. For each interior grid index $j=1, \\dots, M$, calculate the grid point coordinate $x_j = jh$ and find the potential $V_j = \\pi_{\\lfloor x_j \\rfloor}$ using the provided sequence of $\\pi$ digits.\n$3$. Construct the main diagonal and the single off-diagonal of the Hamiltonian matrix $\\mathbf{H}$. The main diagonal elements are $\\frac{2}{h^2} + V_j$ and the off-diagonal elements are all $-\\frac{1}{h^2}$.\n$4$. Solve the resulting matrix eigenvalue problem. Because $\\mathbf{H}$ is symmetric and tridiagonal, specialized and highly efficient numerical methods can be used. We will target only the lowest $k$ eigenvalues as requested, using functions optimized for this purpose, such as `scipy.linalg.eigh_tridiagonal`.\n$5$. The computed eigenvalues are the numerical approximations of the lowest $k$ energy levels. These values are then rounded to $6$ decimal places and formatted as required.\nThis entire procedure provides a systematic and computationally sound method for solving the posed problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for a piecewise-constant potential\n    derived from the digits of pi, using a finite difference matrix method.\n    \"\"\"\n    # The sequence of pi digits to be used for the potential, starting from the integer part.\n    pi_digits = (\n        3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5,\n        0, 2, 8, 8, 4, 1, 9, 7, 1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0\n    )\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, r, k)\n    # N: number of pi digits used, defines the domain length L=N\n    # r: number of subintervals per unit length, defines grid spacing h=1/r\n    # k: number of lowest eigenvalues to compute\n    test_cases = [\n        (4, 51, 3),  # Case 1\n        (1, 61, 2),  # Case 2\n        (8, 41, 4),  # Case 3\n        (12, 31, 3), # Case 4\n    ]\n\n    all_results = []\n    for N, r, k in test_cases:\n        # 1. Set up grid parameters\n        L = float(N)\n        h = 1.0 / r\n        # Number of interior grid points\n        M = N * r - 1\n\n        # 2. Construct the potential vector for interior points\n        # Grid indices for interior points run from 1 to M\n        grid_indices = np.arange(1, M + 1)\n        # Coordinates of interior grid points\n        x_coords = grid_indices * h\n        # Potential at each grid point, V_j = pi_floor(x_j)\n        potential_indices = np.floor(x_coords).astype(int)\n        potential_values = np.array([pi_digits[idx] for idx in potential_indices])\n\n        # 3. Construct the Hamiltonian matrix diagonals\n        # The kinetic energy term -d^2/dx^2 is discretized as a tridiagonal matrix.\n        # Diagonal elements: 2/h^2\n        # Off-diagonal elements: -1/h^2\n        h_sq_inv = 1.0 / (h * h)\n        main_diag = (2.0 * h_sq_inv) + potential_values\n        off_diag = (-1.0 * h_sq_inv) * np.ones(M - 1)\n\n        # 4. Solve the eigenvalue problem\n        # We need the lowest k eigenvalues. eigh_tridiagonal is efficient for this.\n        # 'select='i'' with 'select_range=(0, k-1)' computes eigenvalues with indices 0 to k-1.\n        # The eigenvalues are sorted in ascending order by default.\n        eigenvalues = eigh_tridiagonal(\n            main_diag,\n            off_diag,\n            select='i',\n            select_range=(0, k - 1)\n        )[0]\n\n        # 5. Format and store the results\n        # Round each eigenvalue to 6 decimal places.\n        rounded_eigenvalues = np.round(eigenvalues, 6).tolist()\n        all_results.append(rounded_eigenvalues)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string with no spaces.\n    # e.g., [[val1,val2],[val3,val4]]\n    results_as_strings = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places and join into a comma-separated string\n        formatted_numbers = [f\"{num:.6f}\" for num in res_list]\n        results_as_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(results_as_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Having mastered the 1D case, we now advance to two dimensions, where the power of matrix methods becomes even more apparent. Many real-world quantum systems, from nanoscale electronic components to quantum dots, are defined by complex geometries where the Schrödinger equation is not analytically separable or solvable. This practice  challenges you to solve for the energy states of a particle confined within an L-shaped region, a classic problem that requires a numerical approach. This exercise will hone your skills in handling more complex grids and constructing the large, sparse matrices that are characteristic of higher-dimensional problems.",
            "id": "2412057",
            "problem": "Consider the time-independent Schrödinger equation (TISE) for a nonrelativistic particle of mass $m$ confined to a bounded two-dimensional region $\\Omega \\subset \\mathbb{R}^2$ with an infinite potential barrier outside $\\Omega$. Inside $\\Omega$ the wavefunction $\\psi$ satisfies\n$$\n-\\frac{\\hbar^2}{2m}\\,\\Delta \\psi(x,y) \\;=\\; E\\,\\psi(x,y),\\quad (x,y)\\in \\Omega,\n$$\nwith the Dirichlet boundary condition\n$$\n\\psi(x,y) \\;=\\; 0,\\quad (x,y)\\in \\partial\\Omega.\n$$\nWork in dimensionless units defined by $\\hbar^2/(2m)=1$ and $L=1$ as the characteristic length, so that the eigenvalue problem reduces to\n$$\n-\\,\\Delta \\psi(x,y) \\;=\\; E\\,\\psi(x,y),\\quad \\psi|_{\\partial\\Omega}=0,\n$$\nand the energy $E$ is dimensionless, measured in units of $\\hbar^2/(2mL^2)$.\n\nLet $\\Omega_c$ be the $L$-shaped region obtained by removing a top-right corner square from the unit square:\n$$\n\\Omega_c \\;=\\; (0,1)\\times(0,1)\\;\\setminus\\;\\Big([1-c,1]\\times[1-c,1]\\Big),\n$$\nwhere $c\\in[0,1)$ is a dimensionless parameter that controls the size of the removed corner. The Dirichlet boundary condition is imposed on the entire boundary $\\partial\\Omega_c$.\n\nFor a given positive integer $n$, define a uniform grid on $(0,1)\\times(0,1)$ with spacing $h=1/(n+1)$ along each axis, and approximate the Dirichlet Laplacian eigenvalue problem on $\\Omega_c$ by any consistent matrix method that converges to the Dirichlet spectrum as $n$ increases. Use the discrete problem at resolution $n$ to approximate the lowest $k$ distinct eigenvalues $E_1\\le E_2\\le\\cdots\\le E_k$ of the Dirichlet Laplacian on $\\Omega_c$. Your program must return these $k$ numerical approximations, sorted in nondecreasing order, rounded to six decimal places.\n\nTest suite:\n- Case $1$: $c=0.5$, $n=40$, $k=6$.\n- Case $2$: $c=0.0$, $n=40$, $k=6$.\n- Case $3$: $c=0.75$, $n=36$, $k=6$.\n\nSpecification of outputs:\n- For each case, compute a list of $k$ floats corresponding to the lowest $k$ eigenvalues in ascending order, each rounded to six decimal places.\n- Aggregate the three lists into a single list of lists in the same order as the cases above.\n- Your program should produce a single line of output containing the aggregated results as a comma-separated list enclosed in square brackets, with the inner lists also enclosed in square brackets. For example, the required format is\n`[[E_{1,1},E_{1,2},...,E_{1,6}],[E_{2,1},...,E_{2,6}],[E_{3,1},...,E_{3,6}]]`.\nNo other text should be printed.\n\nAll energies must be expressed in the specified dimensionless units, rounded to six decimal places. Angles are not involved in this problem. Percentages are not involved in this problem. The final output must adhere exactly to the single-line format described above.",
            "solution": "The core of the problem is to find the eigenvalues of the negative Laplacian operator, $-\\Delta$, on a two-dimensional domain $\\Omega_c$ with Dirichlet boundary conditions. We will solve this by discretizing the operator and the domain, which transforms the partial differential equation into a matrix eigenvalue problem.\n\n**1. Discretization via Finite Difference Method**\nWe employ the finite difference method (FDM) on a uniform grid. The grid points are defined as $(x_i, y_j) = (ih, jh)$, where $h=1/(n+1)$ is the grid spacing, and $i, j$ are integers from $1$ to $n$. The wavefunction at a grid point is denoted $\\psi_{i,j} = \\psi(x_i, y_j)$.\n\nThe Laplacian operator $\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ is approximated at each interior grid point $(x_i, y_j)$ using a five-point stencil, which is derived from centered finite differences:\n$$\n\\Delta\\psi\\big|_{(x_i,y_j)} \\approx \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2}\n$$\nSubstituting this into the dimensionless TISE, $-\\Delta\\psi = E\\psi$, yields:\n$$\n-\\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} = E \\psi_{i,j}\n$$\nRearranging this equation gives a system of linear equations for the values $\\psi_{i,j}$ at all interior grid points:\n$$\n4\\psi_{i,j} - \\psi_{i-1,j} - \\psi_{i+1,j} - \\psi_{i,j-1} - \\psi_{i,j+1} = (h^2 E) \\psi_{i,j}\n$$\nThis is a standard matrix eigenvalue problem, $H\\vec{\\psi} = \\lambda\\vec{\\psi}$. Here, $\\vec{\\psi}$ is a vector formed by flattening the grid values $\\psi_{i,j}$, $H$ is the discrete Hamiltonian matrix representing the stencil, and $\\lambda = h^2 E$ are the eigenvalues of $H$. The energy eigenvalues are then recovered as $E = \\lambda / h^2$.\n\n**2. Matrix Construction for the L-Shaped Domain**\nThe matrix $H$ must be constructed for the specific set of grid points that lie inside the domain $\\Omega_c$.\nA grid point $(x_i, y_j) = (ih, jh)$ is inside $\\Omega_c$ if it is not in the removed corner square. The condition for a point to be in the removed region $[1-c, 1]\\times[1-c, 1]$ is $x_i \\ge 1-c$ and $y_j \\ge 1-c$. In terms of grid indices, this is $i \\ge (n+1)(1-c)$ and $j \\ge (n+1)(1-c)$.\n\nThe algorithm for constructing the matrix $H$ is as follows:\n1.  Identify all valid interior grid points $(i, j)$ that satisfy $1 \\le i, j \\le n$ and are not in the removed corner. Let the total number of such points be $N_{domain}$.\n2.  Create a mapping from each valid coordinate pair $(i, j)$ to a unique linear index $p \\in \\{0, 1, \\dots, N_{domain}-1\\}$.\n3.  Construct an $N_{domain} \\times N_{domain}$ sparse matrix $H$. For each point $p$ corresponding to $(i, j)$:\n    -   The diagonal element $H_{p,p}$ is set to $4$.\n    -   For each of the four neighbors $(i', j')$ of $(i, j)$: if the neighbor is also an interior point with linear index $p'$, the off-diagonal element $H_{p,p'}$ is set to $-1$.\nIf a neighbor lies on the boundary $\\partial\\Omega_c$, the wavefunction value is zero by the Dirichlet condition, so it does not contribute to the equation for point $(i, j)$. This is correctly handled by only considering neighbors that are also interior points.\n\n**3. Eigenvalue Computation**\nThe resulting matrix $H$ is real, symmetric, and sparse. We seek its lowest $k$ eigenvalues. The most efficient method for this is an iterative eigensolver, such as the Lanczos algorithm, which is implemented in `scipy.sparse.linalg.eigsh`. This function is specifically designed for large, sparse, symmetric matrices and can be directed to find a specified number of eigenvalues from one end of the spectrum (in this case, the smallest magnitude, `'SM'`).\n\nOnce the eigenvalues $\\lambda_1, \\lambda_2, \\dots, \\lambda_k$ of $H$ are found, the corresponding physical energy eigenvalues are calculated using the relation $E_m = \\lambda_m / h^2 = \\lambda_m (n+1)^2$.\n\n**4. Special Case: Unit Square ($c=0$)**\nFor $c=0$, the domain $\\Omega_c$ becomes the unit square $(0,1)\\times(0,1)$. For this highly symmetric case, the eigenvalues of the discrete Laplacian matrix $H$ can be determined analytically without constructing and diagonalizing the matrix explicitly. The eigenvalues are given by:\n$$ \\lambda_{p,q} = 4 - 2\\cos\\left(\\frac{p\\pi}{n+1}\\right) - 2\\cos\\left(\\frac{q\\pi}{n+1}\\right) \\quad \\text{for } p,q \\in \\{1, 2, \\dots, n\\}. $$\nThe corresponding energy eigenvalues are $E_{p,q} = \\lambda_{p,q} / h^2$. To find the lowest $k$ eigenvalues, we compute all $n^2$ possible values, sort them in nondecreasing order, and take the first $k$ values. This provides a more direct and accurate result for the discrete system in this special case.\n\nThe final program will implement this logic for each test case, either using the general sparse matrix method for $c  0$ or the analytical formula for $c=0$, and format the results as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef compute_eigenvalues(c, n, k):\n    \"\"\"\n    Computes the k lowest eigenvalues of the Dirichlet Laplacian on an L-shaped domain.\n\n    The problem is discretized using a 5-point finite difference stencil, leading\n    to a matrix eigenvalue problem H*psi = lambda*psi, where E = lambda / h^2.\n\n    Args:\n        c (float): Parameter defining the L-shaped domain. c=0 is a full square.\n        n (int): Number of interior grid points along one dimension of the unit square.\n        k (int): Number of lowest eigenvalues to compute.\n\n    Returns:\n        list: A list of the k lowest eigenvalues, rounded to 6 decimal places.\n    \"\"\"\n    h = 1.0 / (n + 1)\n    h_sq = h**2\n\n    if c == 0.0:\n        # For the square domain (c=0), eigenvalues of the discrete Laplacian\n        # can be calculated analytically.\n        lambdas = []\n        for p in range(1, n + 1):\n            for q in range(1, n + 1):\n                lambda_pq = 4.0 - 2.0 * np.cos(p * np.pi * h) - 2.0 * np.cos(q * np.pi * h)\n                lambdas.append(lambda_pq)\n        \n        lambdas.sort()\n        lowest_lambdas = lambdas[:k]\n        energies = [lam / h_sq for lam in lowest_lambdas]\n        return [round(e, 6) for e in energies]\n\n    # General case for the L-shaped domain (c  0).\n    # We construct the sparse matrix H.\n\n    # Determine the grid points inside the L-shaped domain.\n    # A point (i, j) is removed if it's in the top-right corner.\n    cutoff = (n + 1) * (1.0 - c)\n\n    domain_points = []\n    # Grid indices i, j run from 1 to n.\n    for j in range(1, n + 1):  # y-axis\n        for i in range(1, n + 1):  # x-axis\n            if not (i = cutoff and j = cutoff):\n                domain_points.append((i, j))\n    \n    N_domain = len(domain_points)\n    coord_to_idx = {point: i for i, point in enumerate(domain_points)}\n\n    row_ind = []\n    col_ind = []\n    data = []\n\n    # Populate the lists for constructing the sparse matrix H.\n    for idx, (i, j) in enumerate(domain_points):\n        # Diagonal element is 4.\n        row_ind.append(idx)\n        col_ind.append(idx)\n        data.append(4.0)\n\n        # Off-diagonal elements are -1 for neighbors inside the domain.\n        neighbors = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n        for neighbor_coord in neighbors:\n            if neighbor_coord in coord_to_idx:\n                neighbor_idx = coord_to_idx[neighbor_coord]\n                row_ind.append(idx)\n                col_ind.append(neighbor_idx)\n                data.append(-1.0)\n    \n    # Construct the sparse matrix in CSR format for efficiency.\n    H = csr_matrix((data, (row_ind, col_ind)), shape=(N_domain, N_domain))\n    \n    # Find the k smallest eigenvalues using SciPy's sparse eigensolver for\n    # symmetric matrices. 'SM' means smallest magnitude. Since H is positive\n    # definite, these are the smallest positive eigenvalues.\n    # The solver returns eigenvalues in ascending order.\n    lambdas, _ = eigsh(H, k=k, which='SM', tol=1e-9)\n    \n    # Convert matrix eigenvalues to energy eigenvalues.\n    energies = lambdas / h_sq\n    \n    return [round(e, 6) for e in energies]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (c, n, k)\n        (0.5, 40, 6),\n        (0.0, 40, 6),\n        (0.75, 36, 6)\n    ]\n\n    results = []\n    for c, n, k in test_cases:\n        energies = compute_eigenvalues(c, n, k)\n        results.append(energies)\n    \n    # The final output must be a string representation of the list of lists,\n    # with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "A crucial part of being a computational scientist is not just using numerical methods, but also understanding their properties and limitations. Our Hamiltonian matrix is symmetric, which theoretically guarantees that its eigenvectors form a perfectly orthonormal set. In practice, however, numerical computations are performed with finite precision. This final exercise  shifts the focus from finding physical energies to verifying the integrity of our numerical solution by testing this orthogonality. You will write a program to measure the deviation from perfect orthogonality and see how this numerical error behaves as the size of the matrix grows, a vital lesson in the practical realities of computational physics.",
            "id": "2412055",
            "problem": "Consider the one-dimensional time-independent Schrödinger equation (TISE) for a particle of mass $m$ confined to an infinite square well on the interval $[0,L]$ with Dirichlet boundary conditions $\\psi(0)=\\psi(L)=0$ and potential $V(x)=0$ inside the well. Work in dimensionless units such that the reduced Planck constant $\\hbar$ equals $1$, the mass $m$ equals $1$, and the length $L$ equals $1$.\n\nRepresent the Hamiltonian operator\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\n$$\nas a real symmetric matrix $H \\in \\mathbb{R}^{M\\times M}$ by discretizing the spatial domain with a uniform grid of $M$ interior points and using the standard second-order central finite-difference representation for the second derivative on those interior points. Denote the uniform grid spacing by $a = \\frac{L}{M+1}$, and use the usual three-point stencil to define the discrete Laplacian with Dirichlet boundary conditions.\n\nLet $Q \\in \\mathbb{R}^{M\\times M}$ be the matrix whose columns are the normalized eigenvectors obtained from the full eigen-decomposition of $H$. Define the orthogonality deviation as the Frobenius norm of the difference between the Gram matrix and the identity,\n$$\ns(M) = \\left\\| Q^{\\mathsf{T}} Q - I_M \\right\\|_F,\n$$\nwhere $I_M$ is the $M\\times M$ identity matrix and $\\|\\cdot\\|_F$ denotes the Frobenius norm.\n\nYour task is to write a complete, runnable program that:\n- Constructs $H$ exactly as specified above for each given $M$.\n- Computes all eigenvectors of $H$ and forms $Q$ with columns normalized as returned by a standard symmetric eigensolver.\n- Computes $s(M)$ for each $M$.\n\nTest suite:\n- Use $M \\in \\{8,32,128,256\\}$.\n- For each $M$ in the set, compute $s(M)$ as a floating-point number.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the four $s(M)$ values in the order $M=8$, $M=32$, $M=128$, $M=256$, enclosed in square brackets (e.g., \"[x1,x2,x3,x4]\"). Since $s(M)$ is dimensionless, no physical units are required in the output. The values should be printed as decimal floating-point numbers.",
            "solution": "The problem presented is valid. It is scientifically grounded in the principles of quantum mechanics and numerical analysis, it is well-posed, and its formulation is objective and complete. We shall proceed with the solution.\n\nThe task is to compute a measure of numerical orthogonality error for the eigenvectors of a discretized Hamiltonian. The system is a particle of mass $m$ in a one-dimensional infinite square well of length $L$. The time-independent Schrödinger equation (TISE) is given by:\n$$\n\\hat{H}\\psi(x) = E\\psi(x)\n$$\nwhere the Hamiltonian operator $\\hat{H}$ is:\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\n$$\nThe problem specifies dimensionless units where $\\hbar=1$, $m=1$, and $L=1$. The potential $V(x)$ is $0$ inside the well, which spans the interval $[0, 1]$. The boundary conditions are $\\psi(0) = \\psi(1) = 0$. Under these conditions, the Hamiltonian simplifies to:\n$$\n\\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2}\n$$\n\nTo represent this operator as a matrix, we discretize the spatial domain $[0, 1]$. We define a uniform grid of $M$ interior points $x_i = i \\cdot a$ for $i=1, 2, \\dots, M$. The grid spacing is $a = \\frac{L}{M+1} = \\frac{1}{M+1}$. The boundary points are $x_0 = 0$ and $x_{M+1} = 1$. The wavefunction $\\psi(x)$ is represented by a vector $\\vec{\\psi}$ whose components are its values at the interior grid points, $\\psi_i = \\psi(x_i)$. The boundary conditions impose $\\psi_0 = \\psi(x_0) = 0$ and $\\psi_{M+1} = \\psi(x_{M+1}) = 0$.\n\nThe second derivative operator $\\frac{d^2}{dx^2}$ is approximated at each interior point $x_i$ using the second-order central finite-difference formula:\n$$\n\\left. \\frac{d^2\\psi}{dx^2} \\right|_{x_i} \\approx \\frac{\\psi(x_i+a) - 2\\psi(x_i) + \\psi(x_i-a)}{a^2} = \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{a^2}\n$$\nSubstituting this into the TISE for each point $x_i$:\n$$\n-\\frac{1}{2} \\left( \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{a^2} \\right) = E\\psi_i\n$$\nRearranging the terms, we obtain a system of linear equations:\n$$\n-\\frac{1}{2a^2}\\psi_{i-1} + \\frac{1}{a^2}\\psi_i - \\frac{1}{2a^2}\\psi_{i+1} = E\\psi_i\n$$\nThis system can be expressed in matrix form $H\\vec{\\psi} = E\\vec{\\psi}$, where $H$ is an $M \\times M$ matrix. The elements of $H$ are determined by the equation above. For the $i$-th row:\n- The diagonal element ($j=i$) is $H_{ii} = \\frac{1}{a^2}$.\n- The off-diagonal elements ($j=i \\pm 1$) are $H_{i,i-1} = H_{i,i+1} = -\\frac{1}{2a^2}$.\n- All other elements are zero.\n\nThe resulting Hamiltonian matrix $H$ is a real, symmetric, tridiagonal matrix:\n$$\nH = \\frac{1}{2a^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -1 \\\\\n0  0  \\cdots  -1  2\n\\end{pmatrix}\n$$\nThis matrix is constructed for each specified value of $M$.\n\nThe next step is to perform an eigen-decomposition of $H$. Since $H$ is a real symmetric matrix, the spectral theorem guarantees that it has $M$ real eigenvalues and a corresponding set of $M$ eigenvectors that form an orthonormal basis for $\\mathbb{R}^M$. We use a standard numerical eigensolver designed for symmetric matrices to find the eigenvalues and eigenvectors. Such solvers return a matrix $Q \\in \\mathbb{R}^{M\\times M}$ whose columns are the normalized eigenvectors of $H$. In theory, these eigenvectors are perfectly orthonormal, which means the matrix $Q$ is orthogonal, satisfying $Q^{\\mathsf{T}}Q = I_M$, where $I_M$ is the $M \\times M$ identity matrix.\n\nDue to finite-precision floating-point arithmetic, the numerically computed matrix of eigenvectors, which we also denote by $Q$, will only be approximately orthogonal. The problem requires us to quantify this numerical deviation from perfect orthogonality. The specified metric is the orthogonality deviation $s(M)$, defined as the Frobenius norm of the difference between the Gram matrix $Q^{\\mathsf{T}}Q$ and the identity matrix $I_M$:\n$$\ns(M) = \\left\\| Q^{\\mathsf{T}} Q - I_M \\right\\|_F\n$$\nThe Frobenius norm of a matrix $A$ is given by $\\|A\\|_F = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$.\n\nThe computational procedure is as follows for each $M \\in \\{8, 32, 128, 256\\}$:\n1.  Calculate the grid spacing $a = \\frac{1}{M+1}$.\n2.  Construct the $M \\times M$ Hamiltonian matrix $H$ with diagonal elements $H_{ii} = \\frac{1}{a^2}$ and off-diagonal elements $H_{i, i \\pm 1} = -\\frac{1}{2a^2}$.\n3.  Use a numerical routine for symmetric matrices (such as `numpy.linalg.eigh`) to compute the matrix $Q$ of normalized eigenvectors of $H$.\n4.  Compute the Gram matrix $G = Q^{\\mathsf{T}}Q$.\n5.  Calculate the deviation matrix $D = G - I_M$.\n6.  Compute the Frobenius norm $s(M) = \\|D\\|_F$.\n\nThis procedure is executed for all specified values of $M$, and the resulting values of $s(M)$ are reported. These values represent the accumulated floating-point errors in enforcing the orthogonality constraint by the eigensolver algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the orthogonality deviation for eigenvectors\n    of a discretized Hamiltonian for an infinite square well.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [8, 32, 128, 256]\n\n    results = []\n    for M in test_cases:\n        # Step 1: Define parameters based on the problem statement.\n        # hbar = 1, m = 1, L = 1.\n        # Grid spacing 'a'.\n        a = 1.0 / (M + 1.0)\n        \n        # Step 2: Construct the Hamiltonian matrix H.\n        # H is a real symmetric tridiagonal matrix.\n        # Diagonal elements are 1/a^2 (from the -2*psi_i term).\n        # Off-diagonal elements are -1/(2*a^2) (from psi_{i-1} and psi_{i+1} terms).\n        # The overall factor of -hbar^2/(2m) = -1/2 is included.\n        diag_val = 1.0 / (a**2)\n        offdiag_val = -0.5 / (a**2)\n        \n        # An efficient and clear way to build the tridiagonal matrix H.\n        # It's constructed from its diagonal and two off-diagonal vectors.\n        H = (np.diag(np.full(M, diag_val)) + \n             np.diag(np.full(M - 1, offdiag_val), k=1) + \n             np.diag(np.full(M - 1, offdiag_val), k=-1))\n        \n        # Step 3: Compute eigenvectors of H.\n        # numpy.linalg.eigh is used for symmetric/Hermitian matrices.\n        # It returns eigenvalues and a matrix Q of orthonormal eigenvectors.\n        # We only need the eigenvectors, so eigenvalues are discarded ('_').\n        _, Q = np.linalg.eigh(H)\n        \n        # Step 4: Compute the orthogonality deviation s(M).\n        # The definition is s(M) = ||Q^T Q - I||_F (Frobenius norm).\n        \n        # Compute the Gram matrix G = Q^T Q.\n        # In theory, for an orthogonal matrix Q, G should be the identity matrix.\n        gram_matrix = Q.T @ Q\n        \n        # Create the identity matrix of size M x M.\n        identity_matrix = np.identity(M)\n        \n        # Compute the difference matrix.\n        deviation_matrix = gram_matrix - identity_matrix\n        \n        # Compute the Frobenius norm of the difference.\n        s_M = np.linalg.norm(deviation_matrix, 'fro')\n        \n        results.append(s_M)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of float values enclosed in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}