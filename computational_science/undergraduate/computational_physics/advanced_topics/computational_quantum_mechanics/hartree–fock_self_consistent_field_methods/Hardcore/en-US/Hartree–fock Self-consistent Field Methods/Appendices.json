{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex code, it's crucial to understand the mechanics of the Self-Consistent Field (SCF) procedure at a fundamental level. This first practice provides a hands-on opportunity to manually construct the Fock matrix for a simple two-electron system, the helium atom, using pre-calculated integrals. By working through a single step of the calculation , you will gain a concrete understanding of how the electron density, represented by the density matrix $P$, influences the effective potential experienced by each electron via the Fock operator $F$.",
            "id": "2400276",
            "problem": "Consider an isolated helium atom with nuclear charge $Z=2$ treated at the closed-shell restricted Hartree–Fock (RHF) self-consistent field (SCF) level in a minimal Slater-type orbital contracted with three Gaussians (STO-3G) atomic orbital basis consisting of a single normalized $1s$-type function $\\chi_{1}$. Work in Hartree atomic units, where $\\hbar = m_{e} = e = 4\\pi \\epsilon_{0} = 1$, and assume an orthonormal basis with $S_{11}=1$. The system has two electrons occupying the single spatial orbital.\n\nYou are given the following one- and two-electron integrals over the atomic orbital $\\chi_{1}$:\n- One-electron (core) integral: $h_{11}=\\langle \\chi_{1} | \\hat{T} + \\hat{V}_{ne} | \\chi_{1} \\rangle = -2.038$.\n- Two-electron Coulomb integral: $(11|11)=\\langle \\chi_{1}\\chi_{1} | r_{12}^{-1} | \\chi_{1}\\chi_{1} \\rangle = 1.216$.\n\nUsing only first principles of the restricted Hartree–Fock formalism, manually construct the Fock matrix element $F_{11}$ from these data and then compute the total RHF electronic energy $E$ of the helium atom in this basis. Express the final energy in Hartree and round your answer to four significant figures. Your final reported result must be a single number.",
            "solution": "The problem is to compute the total restricted Hartree–Fock (RHF) electronic energy for a helium atom in a minimal STO-3G basis. The problem is well-posed and scientifically grounded. All necessary data are provided.\n\nThe system is a closed-shell atom with $N=2$ electrons. Both electrons occupy a single spatial orbital, which we denote as $\\psi_{1}$. This spatial orbital is constructed as a linear combination of atomic orbitals (LCAO). In this case, the basis is minimal, consisting of a single normalized $1s$-type function $\\chi_{1}$. The expansion is therefore trivial:\n$$ \\psi_{1} = c_{11} \\chi_{1} $$\nThe normalization condition for the spatial orbital is $\\langle \\psi_1 | \\psi_1 \\rangle = 1$. Expanding this gives:\n$$ \\langle c_{11} \\chi_{1} | c_{11} \\chi_{1} \\rangle = |c_{11}|^2 \\langle \\chi_{1} | \\chi_{1} \\rangle = |c_{11}|^2 S_{11} = 1 $$\nWe are given that the basis is orthonormal, meaning the overlap matrix element is $S_{11} = 1$. This implies $|c_{11}|^2 = 1$. We can choose the real, positive coefficient $c_{11}=1$, which means the spatial orbital is identical to the basis function:\n$$ \\psi_{1} = \\chi_{1} $$\nThe first step is to construct the Fock matrix. For a closed-shell RHF calculation, the elements of the Fock matrix $\\mathbf{F}$ are given by:\n$$ F_{\\mu\\nu} = h_{\\mu\\nu} + \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right] $$\nwhere $h_{\\mu\\nu}$ are the one-electron (core) integrals, $(\\mu\\nu|\\lambda\\sigma)$ are the two-electron repulsion integrals, and $P_{\\lambda\\sigma}$ are the elements of the density matrix. The indices $\\mu, \\nu, \\lambda, \\sigma$ refer to the basis functions. In this problem, we have only one basis function, $\\chi_{1}$, so all indices must be $1$.\n\nThe density matrix elements $P_{\\lambda\\sigma}$ are defined as:\n$$ P_{\\lambda\\sigma} = 2 \\sum_{i=1}^{N/2} c_{\\lambda i}^{*} c_{\\sigma i} $$\nwhere the sum is over the occupied spatial orbitals. Here, we have one occupied orbital ($i=1$) with $N=2$ electrons, and the coefficient is $c_{11}=1$. Thus, the only non-zero density matrix element is:\n$$ P_{11} = 2 c_{11}^{*} c_{11} = 2(1)(1) = 2 $$\nNow we can construct the single element of the Fock matrix, $F_{11}$:\n$$ F_{11} = h_{11} + \\sum_{\\lambda=1} \\sum_{\\sigma=1} P_{\\lambda\\sigma} \\left[ (11|\\lambda\\sigma) - \\frac{1}{2}(1\\lambda|1\\sigma) \\right] $$\nWith $\\lambda=1$ and $\\sigma=1$, the expression simplifies to:\n$$ F_{11} = h_{11} + P_{11} \\left[ (11|11) - \\frac{1}{2}(11|11) \\right] = h_{11} + \\frac{1}{2} P_{11} (11|11) $$\nSubstituting $P_{11}=2$:\n$$ F_{11} = h_{11} + \\frac{1}{2}(2)(11|11) = h_{11} + (11|11) $$\nWe are given the integral values $h_{11} = -2.038$ and $(11|11) = 1.216$. We can now compute the numerical value of $F_{11}$:\n$$ F_{11} = -2.038 + 1.216 = -0.822 $$\nThe next step is to compute the total RHF electronic energy, $E$. A general formula for the total energy in terms of the density and Fock matrices is:\n$$ E = \\frac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} (h_{\\mu\\nu} + F_{\\mu\\nu}) $$\nFor our minimal basis system, this sum collapses to a single term:\n$$ E = \\frac{1}{2} P_{11} (h_{11} + F_{11}) $$\nSubstituting the known values for $P_{11}$, $h_{11}$, and the calculated value for $F_{11}$:\n$$ E = \\frac{1}{2} (2) (-2.038 + (-0.822)) = 1 \\times (-2.860) = -2.860 $$\nThe total electronic energy is $E = -2.860$ Hartree.\n\nAlternatively, the total energy for a two-electron system in a single spatial orbital $\\psi_1$ is given by the expectation value of the electronic Hamiltonian:\n$$ E = \\langle \\Psi | \\hat{H}_{el} | \\Psi \\rangle $$\nwhere the Slater determinant is $\\Psi = \\frac{1}{\\sqrt{2}}|\\psi_1\\alpha \\psi_1\\beta|$ and $\\hat{H}_{el} = \\hat{h}_1 + \\hat{h}_2 + r_{12}^{-1}$. This evaluates to:\n$$ E = 2 \\langle \\psi_1 | \\hat{h} | \\psi_1 \\rangle + \\langle \\psi_1 \\psi_1 | r_{12}^{-1} | \\psi_1 \\psi_1 \\rangle $$\nSince $\\psi_1 = \\chi_1$, this becomes:\n$$ E = 2 h_{11} + (11|11) $$\nSubstituting the given values:\n$$ E = 2(-2.038) + 1.216 = -4.076 + 1.216 = -2.860 $$\nBoth methods yield the same result. The problem requires the answer to be rounded to four significant figures. The result $-2.860$ already has four significant figures.",
            "answer": "$$\n\\boxed{-2.860}\n$$"
        },
        {
            "introduction": "With a grasp of the core mechanics, the next step is to automate the iterative process by writing your own SCF solver from first principles. This exercise  guides you through implementing both the Restricted (RHF) and Unrestricted (UHF) Hartree-Fock methods for a closed-shell atom. This will not only solidify your understanding of the complete SCF cycle but also illuminate the fundamental relationship between the RHF and UHF formalisms, demonstrating how the more general UHF approach must collapse to the RHF solution for simple closed-shell singlet ground states.",
            "id": "2400234",
            "problem": "Implement from first principles a Self-Consistent Field (SCF) solver for both Restricted Hartree–Fock (RHF) and Unrestricted Hartree–Fock (UHF) for a closed-shell, two-electron atom or ion with a single point nucleus of charge $Z$ at the origin in atomic units. Use a fixed set of real, normalized, $s$-type Gaussian basis functions co-centered at the nucleus. Each basis function is defined by a positive exponent $\\alpha_i$ and has the spatial form $\\phi_i(\\mathbf{r}) = \\mathcal{N}(\\alpha_i)\\,e^{-\\alpha_i r^2}$, where $r = \\lVert \\mathbf{r} \\rVert$ and $\\mathcal{N}(\\alpha_i)$ is the normalization constant. The total number of electrons is $N_{\\mathrm{e}} = 2$ with $N_{\\alpha} = N_{\\beta} = 1$, and all computations must be performed in atomic units. There is a single nucleus, so the classical nuclear repulsion energy is zero.\n\nLet the one-electron Hamiltonian operator be $\\hat{h} = -\\frac{1}{2}\\nabla^2 - \\frac{Z}{r}$. Construct all one-electron integrals and the two-electron electron-repulsion integrals using their defining expressions:\n- Overlap integrals $S_{ij} = \\int \\phi_i(\\mathbf{r})\\,\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$.\n- Kinetic integrals $T_{ij} = \\int \\phi_i(\\mathbf{r})\\left(-\\frac{1}{2}\\nabla^2\\right)\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$.\n- Nuclear attraction integrals $V_{ij} = \\int \\phi_i(\\mathbf{r})\\left(-\\frac{Z}{r}\\right)\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$.\n- Two-electron integrals in chemists’ notation $(ij|kl) = \\int\\int \\phi_i(\\mathbf{r}_1)\\phi_j(\\mathbf{r}_1)\\frac{1}{\\lVert \\mathbf{r}_1 - \\mathbf{r}_2 \\rVert}\\phi_k(\\mathbf{r}_2)\\phi_l(\\mathbf{r}_2)\\,\\mathrm{d}^3 \\mathbf{r}_1\\,\\mathrm{d}^3 \\mathbf{r}_2$.\n\nUse these to form the core Hamiltonian matrix $h_{ij} = T_{ij} + V_{ij}$, the overlap matrix $S_{ij}$, and the electron-repulsion integral tensor $(ij|kl)$.\n\nFormulate the RHF and UHF SCF equations in the atomic orbital basis. In RHF, use a single spin-independent Fock matrix and a spinless density matrix for the closed-shell configuration. In UHF, build separate $\\alpha$ and $\\beta$ Fock matrices and density matrices, with the exchange operator acting only within the same spin channel. Solve the generalized eigenvalue problems for the Fock matrices with respect to the overlap metric to obtain canonical molecular orbitals and orbital energies. Iterate until convergence of the density matrices.\n\nFor each test case, after convergence:\n- Compute the maximum absolute matrix-element difference between the converged $\\alpha$ and $\\beta$ density matrices, that is $\\max_{i,j}\\lvert P^{\\alpha}_{ij} - P^{\\beta}_{ij} \\rvert$.\n- Compute the maximum absolute difference between the converged $\\alpha$ and $\\beta$ orbital energies, that is $\\max_k \\lvert \\varepsilon^{\\alpha}_k - \\varepsilon^{\\beta}_k \\rvert$.\n- Compute the absolute difference between the converged total UHF and RHF energies in Hartree, that is $\\lvert E_{\\mathrm{UHF}} - E_{\\mathrm{RHF}} \\rvert$.\n\nExpress all energy quantities in Hartree and report the three quantities for each test case as real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list of three floats in the order specified above, for example, \"[[x11,x12,x13],[x21,x22,x23],...]\" with no extra whitespace or text.\n\nUse the following test suite of three parameter sets, each specified by a nuclear charge $Z$ and a list of Gaussian exponents $\\{\\alpha_i\\}$:\n1. $Z = 2$, $\\{\\alpha\\} = [0.50]$.\n2. $Z = 2$, $\\{\\alpha\\} = [0.20, 0.80]$.\n3. $Z = 3$, $\\{\\alpha\\} = [0.15, 0.50, 1.20]$.\n\nThe program must implement the SCF procedure from the definitions above and produce the requested outputs for the test suite. The expected physical behavior for these closed-shell systems is that the Unrestricted Hartree–Fock (UHF) solution collapses to the Restricted Hartree–Fock (RHF) solution, leading to identical $\\alpha$ and $\\beta$ orbitals and energies; your numerical results should reflect this by returning values that are numerically indistinguishable from zero to within a reasonable tolerance. All angles, if any were to appear, must be in radians. All energies must be reported in Hartree as floats without units in the output string.",
            "solution": "The problem is subjected to validation and is found to be valid. It is a well-posed problem in computational quantum physics, based on established scientific principles (Hartree-Fock theory), with all necessary information provided for its solution. There are no contradictions, ambiguities, or factual inaccuracies. The task is to implement the Restricted and Unrestricted Hartree-Fock Self-Consistent Field (SCF) methods for a two-electron atomic system from first principles.\n\n### 1. Theoretical Framework\n\nThe system under consideration is a two-electron atom or ion with nuclear charge $Z$, described by the electronic Hamiltonian in atomic units:\n$$\n\\hat{H} = \\sum_{i=1}^{2} \\left( -\\frac{1}{2}\\nabla_i^2 - \\frac{Z}{r_i} \\right) + \\frac{1}{r_{12}} = \\sum_{i=1}^{2} \\hat{h}(i) + \\frac{1}{r_{12}}\n$$\nwhere $\\hat{h}(i)$ is the core Hamiltonian for electron $i$, and $r_{12} = \\lVert \\mathbf{r}_1 - \\mathbf{r}_2 \\rVert$ is the inter-electron distance. The nuclear-nuclear repulsion is zero for a single nucleus.\n\nIn the Hartree-Fock approximation, the many-electron wavefunction is approximated as a single Slater determinant. The molecular orbitals (MOs), $\\psi_a$, are expressed as a linear combination of atomic orbitals (AOs), $\\phi_i$:\n$$\n\\psi_a(\\mathbf{r}) = \\sum_{i=1}^{K} C_{ia} \\phi_i(\\mathbf{r})\n$$\nThe basis functions $\\{\\phi_i\\}$ are specified as real, normalized, s-type Gaussian functions centered at the origin:\n$$\n\\phi_i(\\mathbf{r}) = \\mathcal{N}(\\alpha_i)\\,e^{-\\alpha_i r^2} = \\left(\\frac{2\\alpha_i}{\\pi}\\right)^{3/4} e^{-\\alpha_i r^2}\n$$\nwhere $\\alpha_i$ is the exponent of the $i$-th basis function and $\\mathcal{N}(\\alpha_i)$ is its normalization constant.\n\n### 2. Integral Evaluation\n\nThe solution of the Hartree-Fock equations requires the evaluation of one- and two-electron integrals over the Gaussian basis functions. For s-type Gaussians centered at the origin, these integrals have analytical closed-form expressions.\n\n- **Overlap Integral ($S_{ij}$)**:\n$$\nS_{ij} = \\int \\phi_i(\\mathbf{r}) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = \\left( \\frac{2\\sqrt{\\alpha_i\\alpha_j}}{\\alpha_i+\\alpha_j} \\right)^{3/2}\n$$\n\n- **Kinetic Energy Integral ($T_{ij}$)**:\n$$\nT_{ij} = \\int \\phi_i(\\mathbf{r}) \\left(-\\frac{1}{2}\\nabla^2\\right) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = \\frac{3\\alpha_i\\alpha_j}{\\alpha_i+\\alpha_j} S_{ij}\n$$\n\n- **Nuclear Attraction Integral ($V_{ij}$)**:\n$$\nV_{ij} = \\int \\phi_i(\\mathbf{r}) \\left(-\\frac{Z}{r}\\right) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = -Z \\mathcal{N}(\\alpha_i)\\mathcal{N}(\\alpha_j) \\frac{2\\pi}{\\alpha_i+\\alpha_j} = -Z \\frac{2\\left(4\\alpha_i\\alpha_j\\right)^{3/4}}{\\sqrt{\\pi}(\\alpha_i+\\alpha_j)}\n$$\n\n- **Two-Electron Repulsion Integral (ERI) ($ij|kl$)**:\n$$\n(ij|kl) = \\iint \\phi_i(\\mathbf{r}_1)\\phi_j(\\mathbf{r}_1) \\frac{1}{r_{12}} \\phi_k(\\mathbf{r}_2)\\phi_l(\\mathbf{r}_2) d^3\\mathbf{r}_1 d^3\\mathbf{r}_2 = \\mathcal{N}_i\\mathcal{N}_j\\mathcal{N}_k\\mathcal{N}_l \\frac{2\\pi^{5/2}}{(\\alpha_i+\\alpha_j)(\\alpha_k+\\alpha_l)\\sqrt{\\alpha_i+\\alpha_j+\\alpha_k+\\alpha_l}}\n$$\nwhere $\\mathcal{N}_i, \\mathcal{N}_j, \\mathcal{N}_k, \\mathcal{N}_l$ are the respective normalization constants.\n\nThe core Hamiltonian matrix, $H_{\\mathrm{core}}$, is constructed by summing the kinetic and nuclear attraction integral matrices: $H_{\\mathrm{core}} = T + V$.\n\n### 3. Self-Consistent Field (SCF) Procedure\n\nThe SCF procedure iteratively refines the set of MO coefficients $\\{C_{ia}\\}$ until the electronic energy and density matrix converge.\n\n**A. Restricted Hartree-Fock (RHF) for Closed-Shell Systems**\n\nFor a closed-shell system ($N_\\alpha = N_\\beta$), RHF uses a single set of spatial orbitals for both spin-up and spin-down electrons. The electronic state has $N_e/2$ doubly occupied orbitals. The central equation is the Roothaan-Hall equation:\n$$\nFC = SCE\n$$\nwhere $F$ is the Fock matrix, $C$ is the matrix of MO coefficients, $S$ is the AO overlap matrix, and $E$ is a diagonal matrix of orbital energies $\\varepsilon_a$. The Fock matrix is given by:\n$$\nF = H_{\\mathrm{core}} + G(D)\n$$\nThe matrix $G$ represents the average two-electron potential, with elements:\n$$\nG_{ij} = \\sum_{k,l} D_{kl} \\left[ 2(ij|kl) - (ik|jl) \\right]\n$$\nHere, $D$ is the spinless density matrix, defined from the MO coefficients of the $N_e/2$ occupied orbitals:\n$$\nD_{kl} = \\sum_{a=1}^{N_e/2} C_{ka} C_{la}^*\n$$\nThe total RHF electronic energy is given by:\n$$\nE_{\\mathrm{RHF}} = \\sum_{i,j} D_{ij} (H_{\\mathrm{core},ij} + F_{ij}) = \\mathrm{Tr}[D(H_{\\mathrm{core}} + F)]\n$$\n\n**B. Unrestricted Hartree-Fock (UHF)**\n\nUHF allows different spatial orbitals for spin-up ($\\alpha$) and spin-down ($\\beta$) electrons. This leads to two coupled Roothaan-Hall equations:\n$$\nF^\\alpha C^\\alpha = S C^\\alpha E^\\alpha \\quad \\text{and} \\quad F^\\beta C^\\beta = S C^\\beta E^\\beta\n$$\nThe Fock matrices for each spin are:\n$$\nF^\\sigma = H_{\\mathrm{core}} + J(P^T) - K(P^\\sigma) \\quad (\\sigma = \\alpha, \\beta)\n$$\nwhere $P^\\alpha$ and $P^\\beta$ are the density matrices for $\\alpha$ and $\\beta$ electrons, and $P^T = P^\\alpha + P^\\beta$ is the total density matrix. The elements of the Coulomb ($J$) and exchange ($K$) matrices are:\n$$\nJ_{ij} = \\sum_{k,l} P^T_{lk} (ij|kl) \\qquad (K^\\sigma)_{ij} = \\sum_{k,l} P^\\sigma_{lk} (ik|jl)\n$$\nThe spin density matrices are built from their respective MO coefficients:\n$$\nP^\\alpha_{kl} = \\sum_{a=1}^{N_\\alpha} C^\\alpha_{ka} (C^\\alpha_{la})^* \\qquad P^\\beta_{kl} = \\sum_{a=1}^{N_\\beta} C^\\beta_{ka} (C^\\beta_{la})^*\n$$\nThe total UHF electronic energy is:\n$$\nE_{\\mathrm{UHF}} = \\frac{1}{2}\\sum_{i,j} \\left[ (P^\\alpha+P^\\beta)_{ji} H_{\\mathrm{core},ij} + P^\\alpha_{ji}F^\\alpha_{ij} + P^\\beta_{ji}F^\\beta_{ij} \\right] = \\frac{1}{2} \\left(\\mathrm{Tr}[P^T H_{\\mathrm{core}}] + \\mathrm{Tr}[P^\\alpha F^\\alpha] + \\mathrm{Tr}[P^\\beta F^\\beta] \\right)\n$$\n\n### 4. Algorithmic Implementation\n\nBoth RHF and UHF are solved iteratively:\n1.  **Compute Integrals**: Evaluate and store all one-electron ($S, T, V$) and two-electron ($ij|kl$) integrals. Form $H_{\\mathrm{core}}$.\n2.  **Initial Guess**: An initial guess for the density matrix is obtained by diagonalizing the core Hamiltonian. The generalized eigenvalue problem $H_{\\mathrm{core}}C = SCE$ is solved, and the MOs corresponding to the lowest energies are used to construct the initial density matrix/matrices. For UHF, the initial guess is symmetric, $P^\\alpha_0 = P^\\beta_0$.\n3.  **SCF Cycle**:\n    a. Construct the Fock matrix (or matrices for UHF) using the current density matrix/matrices.\n    b. Solve the generalized eigenvalue problem(s) $FC=SCE$ to obtain new MO coefficients and orbital energies.\n    c. Form new density matrix/matrices from the MO coefficients of the occupied orbitals ($N_e/2=1$ for RHF, $N_\\alpha=1$, $N_\\beta=1$ for UHF).\n    d. Check for convergence. The process is stopped if the maximum absolute change in the density matrix elements between iterations is below a threshold (e.g., $10^{-9}$).\n    e. If not converged, mix the new and old density matrices to aid stability and repeat the cycle.\n4.  **Post-SCF**: Once converged, compute the total electronic energy and the required observables. For the specified closed-shell systems, the UHF solution is expected to collapse to the RHF solution, meaning $P^\\alpha \\approx P^\\beta$, $\\varepsilon^\\alpha_k \\approx \\varepsilon^\\beta_k$, and $E_{\\mathrm{UHF}} \\approx E_{\\mathrm{RHF}}$. The program calculates the maximum absolute differences between these quantities.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, inv, sqrtm\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'Z': 2, 'alphas': [0.50]},\n        {'Z': 2, 'alphas': [0.20, 0.80]},\n        {'Z': 3, 'alphas': [0.15, 0.50, 1.20]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        Z = case['Z']\n        alphas = np.array(case['alphas'])\n        num_basis = len(alphas)\n        n_elec = 2\n        n_alpha = 1\n        n_beta = 1\n\n        # 1. Compute integrals\n        S, T, V, eri = compute_integrals(alphas, Z)\n        H_core = T + V\n\n        # 2. Run RHF and UHF\n        rhf_E, D_conv, _ = run_rhf(H_core, eri, S, n_elec, num_basis)\n        uhf_E, P_alpha_conv, P_beta_conv, eps_alpha, eps_beta = run_uhf(\n            H_core, eri, S, n_alpha, n_beta, num_basis\n        )\n\n        # 3. Compute final quantities\n        diff_P = np.max(np.abs(P_alpha_conv - P_beta_conv))\n        diff_eps = np.max(np.abs(eps_alpha - eps_beta))\n        diff_E = np.abs(uhf_E - rhf_E)\n        \n        all_results.append([diff_P, diff_eps, diff_E])\n    \n    # Format output as specified: \"[[x11,x12,x13],[x21,x22,x23],...]\"\n    result_str = \",\".join([f\"[{v[0]},{v[1]},{v[2]}]\" for v in all_results])\n    print(f\"[{result_str}]\")\n\n\ndef compute_integrals(alphas, Z):\n    \"\"\"\n    Computes all one- and two-electron integrals for s-type Gaussians at the origin.\n    \"\"\"\n    num_basis = len(alphas)\n    S = np.zeros((num_basis, num_basis))\n    T = np.zeros((num_basis, num_basis))\n    V = np.zeros((num_basis, num_basis))\n    eri = np.zeros((num_basis, num_basis, num_basis, num_basis))\n\n    # One-electron integrals\n    for i in range(num_basis):\n        for j in range(num_basis):\n            alpha_i = alphas[i]\n            alpha_j = alphas[j]\n            \n            # Overlap\n            S[i, j] = (2 * np.sqrt(alpha_i * alpha_j) / (alpha_i + alpha_j))**1.5\n            \n            # Kinetic\n            T[i, j] = 3 * alpha_i * alpha_j / (alpha_i + alpha_j) * S[i, j]\n            \n            # Nuclear Attraction\n            term1 = 2 * (4 * alpha_i * alpha_j)**0.75\n            term2 = np.sqrt(np.pi) * (alpha_i + alpha_j)\n            V[i, j] = -Z * term1 / term2\n    \n    # Two-electron integrals (ERI)\n    for i in range(num_basis):\n        for j in range(num_basis):\n            for k in range(num_basis):\n                for l in range(num_basis):\n                    alpha_i, alpha_j, alpha_k, alpha_l = alphas[i], alphas[j], alphas[k], alphas[l]\n                    p = alpha_i + alpha_j\n                    q = alpha_k + alpha_l\n                    \n                    term1 = 16 * (alpha_i * alpha_j * alpha_k * alpha_l)**0.75\n                    term2 = np.sqrt(np.pi) * p * q * np.sqrt(p + q)\n                    eri[i, j, k, l] = term1 / term2\n    \n    return S, T, V, eri\n\n\ndef run_rhf(H_core, eri, S, n_elec, num_basis):\n    \"\"\"\n    Performs the RHF-SCF calculation.\n    \"\"\"\n    max_iter = 100\n    conv_tol = 1e-9\n    mixing_alpha = 0.5\n    n_occ = n_elec // 2\n\n    # Initial guess\n    _, C = eigh(H_core, S)\n    D = C[:, :n_occ] @ C[:, :n_occ].T\n\n    for i in range(max_iter):\n        D_old = D.copy()\n        \n        # Build G matrix\n        J = np.einsum('kl,ijkl->ij', D, eri)\n        K = np.einsum('kl,ikjl->ij', D, eri)\n        G = 2 * J - K\n        \n        # Form Fock matrix\n        F = H_core + G\n        \n        # Solve Roothaan-Hall equations\n        eps, C = eigh(F, S)\n        \n        # Form new density matrix\n        D = C[:, :n_occ] @ C[:, :n_occ].T\n        \n        # Damping/Mixing\n        D = (1 - mixing_alpha) * D_old + mixing_alpha * D\n        \n        # Check convergence\n        if np.max(np.abs(D - D_old)) < conv_tol:\n            break\n            \n    # Calculate final energy\n    E = np.sum(D * (H_core + F))\n    \n    return E, D, eps\n\n\ndef run_uhf(H_core, eri, S, n_alpha, n_beta, num_basis):\n    \"\"\"\n    Performs the UHF-SCF calculation.\n    \"\"\"\n    max_iter = 100\n    conv_tol = 1e-9\n    mixing_alpha = 0.5\n\n    # Initial guess (symmetric)\n    _, C = eigh(H_core, S)\n    P_alpha = C[:, :n_alpha] @ C[:, :n_alpha].T\n    P_beta = C[:, :n_beta] @ C[:, :n_beta].T\n\n    for i in range(max_iter):\n        P_alpha_old = P_alpha.copy()\n        P_beta_old = P_beta.copy()\n        \n        P_total = P_alpha + P_beta\n        \n        # Build J and K matrices\n        J = np.einsum('lk,ijkl->ij', P_total, eri)\n        K_alpha = np.einsum('lk,ikjl->ij', P_alpha, eri)\n        K_beta = np.einsum('lk,ikjl->ij', P_beta, eri)\n        \n        # Form Fock matrices\n        F_alpha = H_core + J - K_alpha\n        F_beta = H_core + J - K_beta\n        \n        # Solve Roothaan-Hall equations for each spin\n        eps_alpha, C_alpha = eigh(F_alpha, S)\n        eps_beta, C_beta = eigh(F_beta, S)\n        \n        # Form new density matrices\n        P_alpha = C_alpha[:, :n_alpha] @ C_alpha[:, :n_alpha].T\n        P_beta = C_beta[:, :n_beta] @ C_beta[:, :n_beta].T\n        \n        # Damping/Mixing\n        P_alpha = (1 - mixing_alpha) * P_alpha_old + mixing_alpha * P_alpha\n        P_beta = (1 - mixing_alpha) * P_beta_old + mixing_alpha * P_beta\n        \n        # Check convergence\n        delta = max(np.max(np.abs(P_alpha - P_alpha_old)), \n                    np.max(np.abs(P_beta - P_beta_old)))\n        if delta < conv_tol:\n            break\n            \n    # Calculate final energy\n    E = 0.5 * (np.sum(P_total * H_core) + np.sum(P_alpha * F_alpha) + np.sum(P_beta * F_beta))\n    \n    return E, P_alpha, P_beta, eps_alpha, eps_beta\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A basic SCF implementation, while instructive, can sometimes fail to converge for more challenging systems, often due to oscillations in the orbital energies between iterations. This final practice  introduces a powerful technique called \"level shifting\" that is commonly used in production-level quantum chemistry software to ensure robust convergence. By implementing and testing this method, you will see firsthand how adding a positive energy shift $\\Delta$ to the virtual orbitals can stabilize the SCF iteration, providing a practical tool for tackling difficult electronic structure problems.",
            "id": "2400252",
            "problem": "Consider a closed-shell, Restricted Hartree–Fock (RHF) Self-Consistent Field (SCF) problem in a minimal, orthonormal atomic orbital basis of dimension $2$ (that is, the overlap matrix is the identity). Two electrons occupy the lowest-energy molecular orbital with double occupancy. The one-electron core Hamiltonian matrix $H$ (in Hartree atomic units) and the non-zero two-electron repulsion integrals in chemist’s notation $(\\mu\\nu\\mid\\lambda\\sigma)$ are given as follows:\n- One-electron matrix $H$ (symmetric): $H_{11}=0$, $H_{22}=0$, $H_{12}=H_{21}=0.05$ (all in Hartree).\n- Unique non-zero two-electron integrals (in Hartree), with all others defined by permutational symmetry:\n  1. $(11\\mid 11)=0.7$,\n  2. $(22\\mid 22)=0.7$,\n  3. $(11\\mid 22)=(22\\mid 11)=0.6$,\n  4. $(12\\mid 12)=(21\\mid 21)=0.5$,\n  5. $(12\\mid 21)=(21\\mid 12)=0.2$.\n\nLet the spin-summed density matrix be $P\\in\\mathbb{R}^{2\\times 2}$, constructed from the occupied molecular orbital column vector $c_{\\text{occ}}\\in\\mathbb{R}^{2}$ as $P=2\\,c_{\\text{occ}}c_{\\text{occ}}^{\\mathsf{T}}$ with $\\lVert c_{\\text{occ}}\\rVert_2=1$. The RHF Fock matrix $F$ is defined by\n$$\nF_{\\mu\\nu} \\;=\\; H_{\\mu\\nu} \\;+\\; \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma}\\,\\Big[(\\mu\\nu\\mid\\lambda\\sigma) \\;-\\; \\tfrac{1}{2}(\\mu\\lambda\\mid\\nu\\sigma)\\Big] \\quad \\text{for } \\mu,\\nu\\in\\{1,2\\}.\n$$\n\nLevel shifting is introduced as follows. Given a level-shift parameter $\\Delta\\ge 0$, at each SCF iteration, form the projector onto the virtual subspace defined by the occupied molecular orbital from the previous iteration, $Q_{\\mathrm{virt}}=I - c_{\\text{occ}}c_{\\text{occ}}^{\\mathsf{T}}$, and construct a level-shifted Fock matrix\n$$\nF^{(\\Delta)} \\;=\\; F \\;+\\; \\Delta\\,Q_{\\mathrm{virt}}.\n$$\nThe occupied molecular orbital for the next iteration is the normalized eigenvector of $F^{(\\Delta)}$ associated with its smallest eigenvalue. The initial guess for $c_{\\text{occ}}$ is the normalized eigenvector of the one-electron matrix $H$ associated with its smallest eigenvalue. Define convergence as $\\max_{\\,\\mu,\\nu}\\lvert P_{\\mu\\nu}^{(k)}-P_{\\mu\\nu}^{(k-1)}\\rvert < \\tau$, where $P^{(k)}$ is the density matrix at iteration $k$, with tolerance $\\tau=10^{-12}$, and impose a hard cap of $M=200$ iterations; if convergence is not reached within $M$ iterations, declare non-convergence.\n\nTask. For each specified level-shift parameter $\\Delta$, perform the RHF SCF procedure with level shifting as defined above and return the number of iterations required to converge; if the procedure does not converge within $M$ iterations, return the integer $-1$ for that case.\n\nUse the following test suite of level-shift parameters (in Hartree): $\\Delta\\in\\{0.0,\\,0.3,\\,0.6,\\,1.0,\\,5.0\\}$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets (e.g., \"[1,-1,3,2,1]\"), in the same order as the test suite. The integers represent the number of iterations to converge, with $-1$ indicating non-convergence within $M$ iterations. All internal energies are in Hartree; iteration counts are unitless.",
            "solution": "The problem statement is critically validated and is found to be scientifically grounded, well-posed, and free of contradictions or ambiguities. It presents a standard computational physics problem involving the Restricted Hartree–Fock (RHF) Self-Consistent Field (SCF) method, augmented with a level-shifting technique to aid convergence. We shall therefore proceed with a complete solution.\n\nThe problem asks for the number of iterations required for the SCF procedure to converge for a two-electron, two-orbital model system, given a set of level-shifting parameters $\\Delta$. The basis is stated to be orthonormal, which means the overlap matrix $S$ is the identity matrix, $S = I$. This simplifies the general Roothaan-Hall equations, $FC = SCE$, to a standard eigenvalue problem, $FC = CE$.\n\nThe RHF method seeks a self-consistent solution for the electronic structure of a closed-shell molecule. The core of the method is the iterative construction and diagonalization of the Fock matrix $F$. The Fock matrix is an effective one-electron Hamiltonian where the electron-electron interactions are treated in an average, mean-field way. Its elements in the atomic orbital basis are given by the provided formula:\n$$\nF_{\\mu\\nu} = H_{\\mu\\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu\\mid\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda\\mid\\nu\\sigma) \\right]\n$$\nHere, $H$ is the core Hamiltonian, representing the kinetic energy and nuclear attraction of an electron. The term $(\\mu\\nu\\mid\\lambda\\sigma)$ is a two-electron repulsion integral (ERI) in chemist's notation. $P$ is the spin-summed density matrix. For a system with $N$ electrons in doubly occupied orbitals, $P$ is constructed from the matrix of occupied molecular orbital coefficients, $C_{\\text{occ}}$, as $P = 2C_{\\text{occ}}C_{\\text{occ}}^{\\dagger}$. In our case, with a single occupied molecular orbital represented by the vector $c_{\\text{occ}}$, this becomes $P = 2c_{\\text{occ}}c_{\\text{occ}}^{\\mathsf{T}}$.\n\nThe SCF procedure is as follows:\n1.  **Initial Guess**: An initial guess for the molecular orbitals (and thus the density matrix $P$) is required. A standard choice, as specified, is to diagonalize the core Hamiltonian $H$. The eigenvector corresponding to the lowest eigenvalue is taken as the initial occupied molecular orbital, $c_{\\text{occ}}^{(0)}$. From this, the initial density matrix $P^{(0)}$ is constructed.\n\n2.  **Iterative Refinement**: The procedure enters a loop, where each iteration $k$ consists of:\n    a. **Construct Fock Matrix**: A new Fock matrix $F^{(k-1)}$ is built using the density matrix $P^{(k-1)}$ from the previous iteration.\n    b. **Apply Level Shifting**: The Fock matrix is modified using the level-shifting scheme. This technique is designed to improve or guarantee convergence, especially in cases prone to oscillation. A projector onto the virtual (unoccupied) orbital space, $Q_{\\mathrm{virt}} = I - c_{\\text{occ}}^{(k-1)}(c_{\\text{occ}}^{(k-1)})^{\\mathsf{T}}$, is constructed. The level-shifted Fock matrix is then $F^{(\\Delta)} = F^{(k-1)} + \\Delta\\,Q_{\\mathrm{virt}}$. This energetically penalizes the virtual orbitals by an amount $\\Delta$, increasing the gap between occupied and virtual eigenvalues and stabilizing the procedure.\n    c. **Solve Eigenvalue Problem**: The level-shifted Fock matrix $F^{(\\Delta)}$ is diagonalized. The eigenvector corresponding to the lowest eigenvalue becomes the new occupied molecular orbital, $c_{\\text{occ}}^{(k)}$.\n    d. **Update Density Matrix**: A new density matrix $P^{(k)}$ is constructed from $c_{\\text{occ}}^{(k)}$.\n\n3.  **Convergence Check**: The process is repeated until the change in the density matrix between successive iterations is smaller than a specified tolerance, $\\tau$. The convergence condition is given as $\\max_{\\mu,\\nu} \\left| P_{\\mu\\nu}^{(k)} - P_{\\mu\\nu}^{(k-1)} \\right| < \\tau$. If convergence is not achieved within a maximum number of iterations $M$, the calculation is terminated and considered non-convergent.\n\nThe specific numerical implementation will involve the following steps:\n- The core Hamiltonian $H$ is a $2 \\times 2$ matrix:\n$$\nH = \\begin{pmatrix} 0 & 0.05 \\\\ 0.05 & 0 \\end{pmatrix}\n$$\n- The two-electron integrals $(\\mu\\nu\\mid\\lambda\\sigma)$ with $\\mu, \\nu, \\lambda, \\sigma \\in \\{1, 2\\}$, will be stored in a $2 \\times 2 \\times 2 \\times 2$ tensor. The non-zero elements are populated according to the problem statement and permutational symmetry.\n- The SCF loop will be executed for each given value of $\\Delta \\in \\{0.0, 0.3, 0.6, 1.0, 5.0\\}$. The initial guess is the same for all cases.\n- The two-electron part of the Fock matrix, $G_{\\mu\\nu} = \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu\\mid\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda\\mid\\nu\\sigma) \\right]$, can be computed efficiently using tensor contractions, for instance, with `numpy.einsum`. The Coulomb-like term is $J_{\\mu\\nu} = \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} (\\mu\\nu\\mid\\lambda\\sigma)$ and the exchange-like term is $K_{\\mu\\nu} = \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} (\\mu\\lambda\\mid\\nu\\sigma)$, so that $G = J - \\frac{1}{2}K$.\n- Matrix diagonalization will be performed using a robust numerical library function, such as `scipy.linalg.eigh`, which is suitable for symmetric matrices and conveniently returns eigenvalues in ascending order.\n- The number of iterations will be tracked and returned. If the loop completes up to the maximum $M=200$ iterations without meeting the convergence criterion, a value of $-1$ will be returned.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_eri_tensor():\n    \"\"\"\n    Constructs the full 2x2x2x2 two-electron repulsion integral (ERI) tensor\n    from the unique non-zero values provided in the problem statement.\n    The indexing is 0-based, corresponding to the problem's 1-based orbital indices.\n    \"\"\"\n    # ERI tensor in chemist's notation (mu nu | lambda sigma)\n    ERI = np.zeros((2, 2, 2, 2))\n    \n    # (11|11) = 0.7\n    ERI[0, 0, 0, 0] = 0.7\n    # (22|22) = 0.7\n    ERI[1, 1, 1, 1] = 0.7\n    \n    # (11|22) = (22|11) = 0.6\n    ERI[0, 0, 1, 1] = 0.6\n    ERI[1, 1, 0, 0] = 0.6\n    \n    # (12|12) = (21|21) = 0.5\n    ERI[0, 1, 0, 1] = 0.5\n    ERI[1, 0, 1, 0] = 0.5\n    \n    # (12|21) = (21|12) = 0.2\n    ERI[0, 1, 1, 0] = 0.2\n    ERI[1, 0, 0, 1] = 0.2\n    \n    # Other integrals are zero based on the problem statement implying that\n    # any integral not derivable by permutation from the given list is zero.\n    \n    return ERI\n\ndef run_rhf_scf(delta, H, ERI, tau, max_iter):\n    \"\"\"\n    Performs the Restricted Hartree-Fock Self-Consistent Field (RHF-SCF)\n    calculation for a given level-shift parameter.\n\n    Args:\n        delta (float): The level-shift parameter value.\n        H (np.ndarray): The core Hamiltonian matrix.\n        ERI (np.ndarray): The two-electron repulsion integral tensor.\n        tau (float): The convergence tolerance.\n        max_iter (int): The maximum number of SCF iterations.\n\n    Returns:\n        int: The number of iterations to converge, or -1 if not converged.\n    \"\"\"\n    dim = H.shape[0]\n    I = np.identity(dim)\n\n    # 1. Initial Guess Generation\n    # Diagonalize the core Hamiltonian H to get the initial guess for MO coefficients.\n    # eigh returns eigenvalues in ascending order.\n    _, eigvecs_h = eigh(H)\n    \n    # The occupied MO is the eigenvector corresponding to the lowest eigenvalue.\n    # Reshape to ensure it is a column vector.\n    c_occ = eigvecs_h[:, 0].reshape(dim, 1)\n\n    # Construct the initial spin-summed density matrix P.\n    P = 2.0 * (c_occ @ c_occ.T)\n\n    # 2. SCF Iterative Procedure\n    for k in range(1, max_iter + 1):\n        P_old = P\n\n        # Build Fock Matrix F = H + G\n        # G = J - 0.5 * K\n        # J_uv = sum_ls P_ls * (uv|ls) -> Coulomb part\n        # K_uv = sum_ls P_ls * (ul|vs) -> Exchange part\n        \n        J = np.einsum('ls,uvls->uv', P_old, ERI)\n        # Transpose ERI for the exchange term calculation\n        K = np.einsum('ls,ulvs->uv', P_old, ERI.transpose(0, 2, 1, 3))\n        \n        F = H + J - 0.5 * K\n\n        # Apply Level Shifting\n        # Q_virt is the projector onto the virtual space: I - P_occ\n        # where P_occ = c_occ @ c_occ.T\n        Q_virt = I - (c_occ @ c_occ.T)\n        F_shifted = F + delta * Q_virt\n\n        # Diagonalize the shifted Fock matrix to find new orbitals\n        _, eigvecs_f = eigh(F_shifted)\n        c_occ = eigvecs_f[:, 0].reshape(dim, 1)\n\n        # Update Density Matrix with the new occupied MO\n        P = 2.0 * (c_occ @ c_occ.T)\n\n        # Check for convergence by comparing the maximum absolute change in the\n        # density matrix elements against the tolerance.\n        delta_P = np.max(np.abs(P - P_old))\n        \n        if delta_P < tau:\n            return k  # SCF procedure has converged.\n\n    return -1  # Did not converge within the maximum number of iterations.\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It sets up the problem, runs the SCF procedure for each level-shift\n    parameter, and prints the results in the required format.\n    \"\"\"\n    # Define problem parameters from the statement\n    H = np.array([[0.0, 0.05], [0.05, 0.0]])\n    ERI = get_eri_tensor()\n    tau = 1e-12\n    max_iter = 200\n    \n    test_cases = [0.0, 0.3, 0.6, 1.0, 5.0]\n\n    results = []\n    for delta in test_cases:\n        iterations = run_rhf_scf(delta, H, ERI, tau, max_iter)\n        results.append(iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}