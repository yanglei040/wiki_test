{
    "hands_on_practices": [
        {
            "introduction": "At the heart of the stream function-vorticity formulation lies the Poisson equation, $\\nabla^2 \\psi = -\\omega$, which relates the stream function $\\psi$ to the vorticity $\\omega$. This first practice focuses on the foundational task of solving this equation on a simple square domain using a finite-difference discretization. You will implement the Successive Over-Relaxation (SOR) method, a classic and robust iterative solver, and empirically investigate how its performance depends on the choice of the relaxation parameter $\\alpha$, a crucial skill for optimizing numerical codes .",
            "id": "2443760",
            "problem": "You are asked to design and implement a complete solver for the two-dimensional stream function equation in the stream function–vorticity formulation of incompressible flow, and to empirically study the effect of the relaxation parameter in the Successive Over-Relaxation (SOR) method.\n\nFundamental base. In two-dimensional incompressible flow, define the stream function $\\psi(x,y)$ such that the velocity components are $u = \\partial \\psi/\\partial y$ and $v = -\\partial \\psi/\\partial x$, and the scalar vorticity is $\\omega = \\partial v/\\partial x - \\partial u/\\partial y$. These definitions imply the Poisson equation for the stream function,\n$$\n\\nabla^2 \\psi = -\\omega.\n$$\nConsider the unit square domain $\\Omega = (0,1)\\times(0,1)$ with homogeneous Dirichlet boundary condition $ \\psi = 0 $ on $\\partial \\Omega$.\n\nManufactured solution. To obtain a known right-hand side, consider the manufactured stream function\n$$\n\\psi^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\nfor which\n$$\n\\omega(x,y) = -\\nabla^2 \\psi^\\star(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\nThus the problem to solve is\n$$\n\\nabla^2 \\psi(x,y) = -\\omega(x,y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) \\quad \\text{in } \\Omega,\n$$\nwith $ \\psi = 0 $ on $ \\partial \\Omega $. The exact solution is $ \\psi^\\star $.\n\nDiscretization. Use a uniform Cartesian grid with $N$ interior points per coordinate direction, grid spacing $h = 1/(N+1)$, and the standard five-point finite-difference discretization of the Laplacian on the interior grid points. Enforce $ \\psi = 0 $ on the boundary grid points.\n\nIterative solver. Implement the Successive Over-Relaxation (SOR) method to solve the discrete Poisson equation. Use a stopping criterion based on the infinity norm of the discrete residual\n$$\nr_{i,j} = \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} + \\omega_{i,j},\n$$\nthat is, stop when $\\max_{i,j} |r_{i,j}| < \\varepsilon$. Use the zero field as the initial guess for $\\psi$.\n\nEmpirical study. For a fixed set of candidate relaxation parameters $\\alpha \\in \\{1.0, 1.5, 1.7, 1.9\\}$, measure, for each $\\alpha$, the number of SOR iterations required to meet the tolerance $\\varepsilon$ on the residual infinity norm. If the method does not meet the tolerance within a specified maximum number of iterations, treat that run as non-convergent for the purpose of selecting the best $\\alpha$. Among the convergent candidates, define the empirically optimal relaxation parameter as the $\\alpha$ that minimizes the iteration count (break ties by choosing the smaller $\\alpha$).\n\nTest suite. Run your program on the following three cases:\n- Case A (happy path): $ N = 7 $, $ \\varepsilon = 10^{-8} $.\n- Case B (intermediate grid): $ N = 15 $, $ \\varepsilon = 10^{-8} $.\n- Case C (larger grid): $ N = 31 $, $ \\varepsilon = 10^{-8} $.\n\nFor all cases, use the same candidate set $\\alpha \\in \\{1.0, 1.5, 1.7, 1.9\\}$ and the same manufactured right-hand side and boundary conditions. Use a maximum of $ 20000 $ iterations for each SOR run.\n\nRequired program behavior. Your program must:\n- Assemble the right-hand side $ \\omega $ from the manufactured solution on the grid for each $ N $.\n- Solve the discrete Poisson equation by SOR for each candidate $\\alpha$ until the residual criterion is met or the maximum iteration count is reached.\n- For each test case, return the empirically optimal $\\alpha$ among the candidates as a floating-point number rounded to three decimal places, following the tie-break rule specified above.\n\nFinal output format. Your program should produce a single line of output containing the empirically optimal $\\alpha$ for Cases A, B, and C, in that order, as a comma-separated list enclosed in square brackets. For example, the output must look like\n[1.500,1.700,1.900]\nThere are no physical units involved in this problem, and all angles, where present in trigonometric functions, are in radians by definition of the functions used.\n\nYour program must be a complete, runnable implementation with no external input. It must adhere to the execution environment specified later and exactly match the output format described above.",
            "solution": "The problem presented is a well-defined exercise in computational physics, specifically in solving an elliptic partial differential equation using an iterative finite-difference method. The task is to solve the Poisson equation for a stream function $\\psi$ on a unit square domain, analyze the performance of the Successive Over-Relaxation (SOR) method, and determine an empirically optimal relaxation parameter. The problem statement is scientifically sound, self-contained, and algorithmically precise. It is therefore deemed valid and will be solved as stated.\n\nThe governing equation is the two-dimensional Poisson equation for the stream function $\\psi(x,y)$:\n$$\n\\nabla^2 \\psi = -\\omega\n$$\nwhere $\\omega$ is the scalar vorticity. The domain is the unit square $\\Omega = (0,1) \\times (0,1)$, and the boundary condition is a homogeneous Dirichlet condition, $\\psi = 0$ on the boundary $\\partial\\Omega$. A manufactured solution approach is used for verification, where the exact solution is prescribed as $\\psi^\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$. This implies the vorticity source term is $\\omega(x,y) = -\\nabla^2 \\psi^\\star(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n\nThe first step is to discretize the continuous problem. A uniform Cartesian grid is employed with $N$ interior points in each coordinate direction. The grid spacing is $h = 1/(N+1)$. The grid points are denoted by $(x_i, y_j) = (ih, jh)$ for indices $i, j \\in \\{0, 1, \\dots, N+1\\}$. The unknown values are the stream function at the interior points, $\\psi_{i,j} = \\psi(x_i, y_j)$, for $i, j \\in \\{1, \\dots, N\\}$. On the boundary, where $i=0, i=N+1, j=0,$ or $j=N+1$, the value is fixed at $\\psi_{i,j} = 0$.\n\nThe Laplacian operator $\\nabla^2$ is approximated using the standard second-order accurate five-point finite-difference stencil at each interior grid point $(i,j)$:\n$$\n\\nabla^2 \\psi \\bigg|_{(x_i,y_j)} \\approx \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2}\n$$\nSubstituting this into the governing equation $\\nabla^2 \\psi = -\\omega$ gives a system of linear algebraic equations for the unknown values $\\psi_{i,j}$:\n$$\n\\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} = -\\omega_{i,j}\n$$\nwhere $\\omega_{i,j} = 2\\pi^2 \\sin(\\pi x_i)\\sin(\\pi y_j)$.\n\nThis linear system is solved using the Successive Over-Relaxation (SOR) method. SOR is an iterative technique that accelerates the convergence of the Gauss-Seidel method. For each iteration, indexed by $k$, the value of $\\psi_{i,j}$ at the next iteration, $\\psi_{i,j}^{(k+1)}$, is computed by sweeping through the interior grid points. The update rule for $\\psi_{i,j}$ is:\n$$\n\\psi_{i,j}^{(k+1)} = (1 - \\alpha)\\psi_{i,j}^{(k)} + \\frac{\\alpha}{4} \\left( \\psi_{i-1,j}^{(k+1)} + \\psi_{i,j-1}^{(k+1)} + \\psi_{i+1,j}^{(k)} + \\psi_{i,j+1}^{(k)} + h^2 \\omega_{i,j} \\right)\n$$\nHere, $\\alpha$ is the relaxation parameter. For an in-place implementation with a lexicographical sweep (e.g., iterating through $i$ from $1$ to $N$, and then $j$ from $1$ to $N$), the formula uses the most recently updated values from the current iteration, $\\psi_{i-1,j}^{(k+1)}$ and $\\psi_{i,j-1}^{(k+1)}$, along with values from the previous iteration, $\\psi_{i+1,j}^{(k)}$ and $\\psi_{i,j+1}^{(k)}$. An implementation of this update is:\n$$\n\\psi_{i,j} \\leftarrow (1-\\alpha)\\psi_{i,j} + \\frac{\\alpha}{4}(\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} + h^2 \\omega_{i,j})\n$$\nThe initial guess for the entire field is $\\psi^{(0)} = 0$.\n\nThe iteration proceeds until a stopping criterion is met. This criterion is based on the infinity norm of the discrete residual, $\\|r\\|_\\infty = \\max_{i,j} |r_{i,j}|$. The residual at each interior point is defined as:\n$$\nr_{i,j} = \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} + \\omega_{i,j}\n$$\nAfter each full SOR sweep, the residual is computed for all interior points, and its maximum absolute value is compared against a specified tolerance $\\varepsilon$. The iteration stops when $\\|r\\|_\\infty < \\varepsilon$. If this condition is not met within a maximum number of iterations, the run is considered non-convergent.\n\nThe final part of the problem is an empirical study to find the optimal relaxation parameter $\\alpha$ from the set $\\{1.0, 1.5, 1.7, 1.9\\}$ for three different grid sizes ($N=7$, $N=15$, and $N=31$). For each grid size, the SOR solver is run with each candidate $\\alpha$. The number of iterations required for convergence is recorded. The empirically optimal $\\alpha$ is the one that results in the minimum number of iterations among all convergent runs. A tie is broken by selecting the smaller value of $\\alpha$. The final program will execute this procedure for each test case and report the determined optimal $\\alpha$ values.",
            "answer": "```python\nimport numpy as np\n\ndef sor_solver(N: int, alpha: float, epsilon: float, max_iter: int) -> int:\n    \"\"\"\n    Solves the 2D Poisson equation using the Successive Over-Relaxation (SOR) method.\n\n    Args:\n        N: Number of interior grid points in each direction.\n        alpha: The relaxation parameter.\n        epsilon: The convergence tolerance for the residual.\n        max_iter: The maximum number of iterations allowed.\n\n    Returns:\n        The number of iterations required for convergence, or max_iter + 1 if\n        the method did not converge.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    h_sq = h * h\n    \n    # Initialize psi grid (N+2 x N+2) with zeros for boundaries and initial guess.\n    psi = np.zeros((N + 2, N + 2), dtype=float)\n    \n    # Set up the source term omega on the grid.\n    # Grid coordinates including boundaries.\n    xy = np.linspace(0.0, 1.0, N + 2)\n    # Use meshgrid for vectorized computation of omega.\n    # 'ij' indexing matches the loop order (i=rows, j=cols).\n    X, Y = np.meshgrid(xy, xy, indexing='ij')\n    omega = 2.0 * (np.pi**2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    for k in range(max_iter):\n        # Perform one full SOR sweep over the interior points.\n        # This loop is inherently sequential.\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                term = (\n                    psi[i + 1, j] + psi[i - 1, j] +\n                    psi[i, j + 1] + psi[i, j - 1] +\n                    h_sq * omega[i, j]\n                )\n                psi[i, j] = (1.0 - alpha) * psi[i, j] + (alpha / 4.0) * term\n        \n        # Calculate the residual on the interior grid after the sweep using vectorization.\n        laplacian_psi = (\n            psi[2:, 1:-1] + psi[:-2, 1:-1] +\n            psi[1:-1, 2:] + psi[1:-1, :-2]\n            - 4.0 * psi[1:-1, 1:-1]\n        )\n        # Slicing omega to match the interior grid dimensions.\n        residual_grid = laplacian_psi / h_sq + omega[1:-1, 1:-1]\n        \n        # Compute the infinity norm of the residual.\n        max_residual = np.max(np.abs(residual_grid))\n        \n        # Check for convergence.\n        if max_residual < epsilon:\n            return k + 1  # Return number of iterations performed.\n\n    # Return a value indicating non-convergence.\n    return max_iter + 1\n\ndef find_optimal_alpha(N: int, epsilon: float, alphas: list, max_iter: int) -> float:\n    \"\"\"\n    Finds the empirically optimal alpha from a candidate list for a given problem setup.\n\n    Args:\n        N: Number of interior grid points.\n        epsilon: Convergence tolerance.\n        alphas: List of candidate relaxation parameters.\n        max_iter: Maximum number of iterations.\n\n    Returns:\n        The optimal alpha value.\n    \"\"\"\n    results = []\n    for alpha in alphas:\n        iterations = sor_solver(N, alpha, epsilon, max_iter)\n        # Only consider convergent runs.\n        if iterations <= max_iter:\n            results.append((alpha, iterations))\n\n    # Sort results first by iteration count (ascending), then by alpha (ascending)\n    # to handle the tie-breaking rule.\n    results.sort(key=lambda x: (x[1], x[0]))\n    \n    # The optimal alpha is the first element after sorting.\n    if results:\n        return results[0][0]\n    else:\n        # This case implies no candidate alpha converged.\n        # It should not happen for the given problem parameters.\n        # Returning a placeholder value.\n        return -1.0\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    # Test suite parameters from the problem statement.\n    test_cases = [\n        {'N': 7},   # Case A\n        {'N': 15},  # Case B\n        {'N': 31},  # Case C\n    ]\n    epsilon = 1e-8\n    candidate_alphas = [1.0, 1.5, 1.7, 1.9]\n    max_iter = 20000\n\n    optimal_alpha_results = []\n    for case in test_cases:\n        N = case['N']\n        opt_alpha = find_optimal_alpha(N, epsilon, candidate_alphas, max_iter)\n        optimal_alpha_results.append(opt_alpha)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join([f'{alpha:.3f}' for alpha in optimal_alpha_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from pure numerics to a physical model, this exercise explores the flow induced by a single point vortex, a fundamental element in fluid dynamics. You will learn to regularize the vortex singularity using a smooth Gaussian distribution and solve the governing Poisson equation on a periodic domain using a highly efficient spectral solver based on the Fast Fourier Transform (FFT). The core pedagogical goal is to perform a systematic grid refinement study, comparing your numerical results to the known analytical solution and calculating the empirical order of convergence, a critical practice for verifying the accuracy of any scientific simulation .",
            "id": "2443769",
            "problem": "Consider a two-dimensional incompressible flow in a square domain with doubly periodic boundary conditions of side length $L$. Let the stream function $\\psi(x,y)$ and vorticity $\\omega(x,y)$ be related by the stream function–vorticity formulation\n$$\\nabla^2 \\psi(x,y) = -\\omega(x,y),$$\nand the velocity field $\\mathbf{u}(x,y)$ be given by\n$$\\mathbf{u}(x,y) = \\left(\\frac{\\partial \\psi}{\\partial y}(x,y),\\,-\\frac{\\partial \\psi}{\\partial x}(x,y)\\right).$$\nA point vortex of circulation $\\Gamma$ located at the domain center $(L/2,L/2)$ is approximated on a uniform $N\\times N$ grid by a normalized Gaussian vorticity distribution of standard deviation $\\sigma(N)$,\n$$\\omega(x,y) = \\frac{\\Gamma}{2\\pi \\sigma(N)^2}\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{L}{2})^2+(y-\\tfrac{L}{2})^2}{2\\,\\sigma(N)^2}\\right),$$\nwith the regularization width scaled by the grid spacing $h=L/N$ as\n$\\sigma(N) = c\\,h,$\nwhere $c>0$ is a constant specified per test case. The analytical unbounded-point-vortex azimuthal velocity magnitude is\n$$u_\\theta^{\\text{exact}}(r) = \\frac{\\Gamma}{2\\pi r},\\quad r>0,$$\nwhere $r$ is the distance from the vortex center. For each grid size $N$ in a specified list, compute the numerical azimuthal velocity $u_\\theta^{\\text{num}}$ from $\\mathbf{u}(x,y)$ projected onto the local azimuthal direction centered at $(L/2,L/2)$, and evaluate the root-mean-square error over the annulus\n$r_{\\min}(N) \\le r \\le r_{\\max},\\quad r_{\\min}(N) = \\alpha\\,\\sigma(N),\\quad r_{\\max} = \\beta\\,L,$\nas\n$$E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M}\\left(u_\\theta^{\\text{num}}(\\mathbf{x}_m)-u_\\theta^{\\text{exact}}(r_m)\\right)^2},$$\nwhere the $\\{\\mathbf{x}_m\\}_{m=1}^M$ are all grid points whose distances $r_m$ from $(L/2,L/2)$ satisfy the annulus criterion. Let $h=L/N$. For each test case, estimate the observed order of convergence $p$ by fitting a line to $(\\log h,\\log E(N))$ over the provided set of $N$ values and reporting its slope $p$.\n\nAll quantities are nondimensional. Angles, if any are introduced internally, are not to be reported. The required outputs are real numbers.\n\nTest suite:\n- Case A: $\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=2$, $\\alpha=3$, $\\beta=0.25$.\n- Case B: $\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=0.5$, $\\alpha=6$, $\\beta=0.2$.\n- Case C: $\\Gamma=1$, $L=2$, $N\\in\\{32,64,128,256\\}$, $c=1$, $\\alpha=4$, $\\beta=0.5$.\n\nFinal output format:\nYour program should produce a single line of output containing the three estimated convergence orders as a comma-separated list enclosed in square brackets, in the order of the cases A, B, C, for example, \"[pA,pB,pC]\". The outputs must be real numbers.",
            "solution": "The user has provided a computational physics problem that must be validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Governing Equation**: The relationship between the stream function $\\psi(x,y)$ and vorticity $\\omega(x,y)$ is given by the Poisson equation $\\nabla^2 \\psi(x,y) = -\\omega(x,y)$.\n- **Domain**: A two-dimensional square domain of side length $L$ with doubly periodic boundary conditions.\n- **Velocity Field**: The velocity $\\mathbf{u}(x,y)$ is derived from the stream function as $\\mathbf{u}(x,y) = \\left(\\frac{\\partial \\psi}{\\partial y}(x,y),\\,-\\frac{\\partial \\psi}{\\partial x}(x,y)\\right)$.\n- **Vorticity Source**: A point vortex is modeled by a Gaussian distribution centered at $(L/2, L/2)$:\n$$ \\omega(x,y) = \\frac{\\Gamma}{2\\pi \\sigma(N)^2}\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{L}{2})^2+(y-\\tfrac{L}{2})^2}{2\\,\\sigma(N)^2}\\right) $$\n- **Regularization Width**: The standard deviation $\\sigma(N)$ is scaled by the grid spacing $h=L/N$ with a constant $c>0$: $\\sigma(N) = c\\,h$.\n- **Analytical Benchmark**: The analytical azimuthal velocity for an unbounded point vortex is $u_\\theta^{\\text{exact}}(r) = \\frac{\\Gamma}{2\\pi r}$ for $r>0$.\n- **Error Metric**: The Root-Mean-Square (RMS) error $E(N)$ is calculated over an annulus defined by $r_{\\min}(N) \\le r \\le r_{\\max}$, where $r_{\\min}(N) = \\alpha\\,\\sigma(N)$ and $r_{\\max} = \\beta\\,L$:\n$$ E(N) = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M}\\left(u_\\theta^{\\text{num}}(\\mathbf{x}_m)-u_\\theta^{\\text{exact}}(r_m)\\right)^2} $$\nThe sum is over all $M$ grid points $\\{\\mathbf{x}_m\\}$ within the annulus.\n- **Convergence Order**: The order of convergence $p$ is to be estimated from the slope of a linear fit to the data $(\\log h, \\log E(N))$.\n- **Test Cases**:\n    - **Case A**: $\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=2$, $\\alpha=3$, $\\beta=0.25$.\n    - **Case B**: $\\Gamma=1$, $L=1$, $N\\in\\{32,64,128,256\\}$, $c=0.5$, $\\alpha=6$, $\\beta=0.2$.\n    - **Case C**: $\\Gamma=1$, $L=2$, $N\\in\\{32,64,128,256\\}$, $c=1$, $\\alpha=4$, $\\beta=0.5$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n\n- **Scientific Grounding**: The problem is well-grounded in the principles of computational fluid dynamics. The stream function-vorticity formulation is a standard method for analyzing 2D incompressible flows. The use of a regularized \"vortex blob\" (the Gaussian distribution) to represent a point vortex is a valid and common technique in vortex methods to handle the singularity. The chosen method for solving the Poisson equation and for differentiation (implied to be spectral, given the periodic domain) is state-of-the-art for this problem class.\n- **Well-Posedness**: The problem is well-posed. The Poisson equation with periodic boundary conditions is solvable, provided the mean of the source term is zero. A standard procedure, subtracting the mean vorticity, ensures this. The subsequent steps to calculate velocity, error, and convergence order are mathematically defined and lead to a unique result.\n- **Objectivity**: The problem is stated in precise, objective mathematical language. All parameters are defined and quantified. There are no subjective or ambiguous claims.\n- **Flaw Checklist**: The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, feasible, well-structured, and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Design\nThe solution to this problem involves a numerical simulation for a series of grid resolutions, followed by an analysis of the resulting error to determine the order of convergence.\n\n1.  **Discretization**: The continuous domain $[0, L] \\times [0, L]$ is discretized into a uniform $N \\times N$ grid with spacing $h=L/N$. The grid points are located at $(x_i, y_j) = (i h, j h)$ for $i, j = 0, \\dots, N-1$.\n\n2.  **Vorticity Calculation**: The Gaussian vorticity distribution $\\omega(x,y)$ is evaluated at each grid point. The center of the vortex is at $(L/2, L/2)$, and the function is sufficiently localized that periodic summation is not necessary for the given parameters.\n\n3.  **Poisson Equation Solver**: The core of the problem is solving $\\nabla^2 \\psi = -\\omega$ on a doubly periodic domain. The Fast Fourier Transform (FFT) provides a highly efficient and accurate spectral method for this task.\n    - The equation is transformed into Fourier space: $\\widehat{\\nabla^2 \\psi} = \\widehat{-\\omega}$.\n    - The Fourier transform of the Laplacian operator is multiplication by the symbol $-|\\mathbf{k}|^2 = -(k_x^2 + k_y^2)$, where $\\mathbf{k}=(k_x, k_y)$ is the wavevector.\n    - This gives the algebraic relation for the Fourier coefficients of the stream function: $\\hat{\\psi}(\\mathbf{k}) = \\frac{\\hat{\\omega}(\\mathbf{k})}{k_x^2 + k_y^2}$.\n    - A compatibility condition for the periodic Poisson equation requires the integral (or mean) of a source term to be zero. Since $\\int \\omega \\,dA = \\Gamma \\neq 0$, we solve for a modified field $\\psi'$ using the source $\\omega' = \\omega - \\bar{\\omega}$, where $\\bar{\\omega} = \\frac{1}{L^2}\\int\\omega\\,dA$ is the mean vorticity. This ensures $\\hat{\\omega'}(\\mathbf{k}=0)=0$. The resulting constant offset in $\\psi$ does not affect the velocity field, which depends on its derivatives.\n    - At $\\mathbf{k}=0$, the denominator $k_x^2+k_y^2$ is zero. Since $\\hat{\\omega'}(0)=0$, this leads to a $0/0$ indeterminacy, corresponding to the arbitrary mean value of $\\psi$. We resolve this by setting $\\hat{\\psi}(0)=0$.\n    - The discrete stream function $\\psi(x_i, y_j)$ is then recovered via a 2D inverse FFT.\n\n4.  **Velocity Calculation**: The velocity components $u = \\partial\\psi/\\partial y$ and $v = -\\partial\\psi/\\partial x$ are also computed spectrally for consistency and accuracy. In Fourier space, differentiation corresponds to multiplication by $i\\mathbf{k}$.\n    - $\\hat{u}(\\mathbf{k}) = i k_y \\hat{\\psi}(\\mathbf{k})$\n    - $\\hat{v}(\\mathbf{k}) = -i k_x \\hat{\\psi}(\\mathbf{k})$\n    - The velocity fields $u(x_i,y_j)$ and $v(x_i,y_j)$ are obtained via inverse FFTs.\n\n5.  **Error Analysis**:\n    - The numerical azimuthal velocity $u_\\theta^{\\text{num}}$ is computed at each grid point in the specified annulus by projecting the numerical velocity vector $\\mathbf{u}^{\\text{num}}=(u,v)$ onto the local azimuthal unit vector $\\hat{\\mathbf{\\theta}} = (- (y-L/2)/r, (x-L/2)/r)$, where $r$ is the distance from the domain center.\n    - The RMS error $E(N)$ is calculated by comparing $u_\\theta^{\\text{num}}$ with the analytical solution for a point vortex, $u_\\theta^{\\text{exact}}(r) = \\Gamma/(2\\pi r)$, over all grid points in the annulus.\n\n6.  **Convergence Order**: The primary source of error is the \"regularization error\" — the difference between the velocity field of the Gaussian blob and that of an ideal point vortex. For a symmetric blob like a Gaussian, whose first moment is zero but second moment is non-zero and scales with $\\sigma^2$, vortex method theory predicts that the velocity error for $r \\gg \\sigma$ is proportional to $\\sigma^2$. Since $\\sigma = c h$, the error $E(N)$ is expected to scale as $h^2$. This implies a convergence order of $p=2$. The numerical experiment will measure this slope $p$ by performing a linear regression on $(\\log h, \\log E(N))$. The relationship is $\\log E(N) = p \\log h + \\text{constant}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the convergence analysis problem for the stream function-vorticity formulation.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A: (Gamma, L, N_values, c, alpha, beta)\n        (1.0, 1.0, [32, 64, 128, 256], 2.0, 3.0, 0.25),\n        # Case B: (Gamma, L, N_values, c, alpha, beta)\n        (1.0, 1.0, [32, 64, 128, 256], 0.5, 6.0, 0.2),\n        # Case C: (Gamma, L, N_values, c, alpha, beta)\n        (1.0, 2.0, [32, 64, 128, 256], 1.0, 4.0, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, L, N_values, c, alpha, beta = case\n        \n        errors = []\n        h_values = []\n\n        for N in N_values:\n            # 1. Grid and Parameters Setup\n            h = L / N\n            sigma = c * h\n            \n            # Create a uniform grid.\n            x = np.arange(N) * h\n            # meshgrid creates coordinates matrices from coordinate vectors.\n            XX, YY = np.meshgrid(x, x, indexing='ij')\n\n            # 2. Vorticity Field Calculation\n            # Compute coordinates relative to the domain center (L/2, L/2).\n            dx = XX - L / 2\n            dy = YY - L / 2\n            r_sq = dx**2 + dy**2\n            \n            # Evaluate the Gaussian vorticity distribution on the grid.\n            omega = (gamma / (2 * np.pi * sigma**2)) * np.exp(-r_sq / (2 * sigma**2))\n\n            # 3. Solve Poisson Equation using FFT\n            # The source term for the periodic Poisson equation must have zero mean.\n            omega_prime = omega - np.mean(omega)\n            omega_hat = np.fft.fft2(omega_prime)\n\n            # Define angular wavenumbers for the spectral method.\n            k = 2 * np.pi * np.fft.fftfreq(N, d=h)\n            kx, ky = np.meshgrid(k, k, indexing='ij')\n            \n            # The Laplacian operator in Fourier space is -|k|^2.\n            K_sq = kx**2 + ky**2\n            \n            # Solve for the stream function in Fourier space.\n            # Avoid division by zero at k=0. The numerator is zero anyway.\n            # np.divide is used here to suppress warnings.\n            psi_hat = np.divide(omega_hat, K_sq, out=np.zeros_like(omega_hat), where=(K_sq!=0))\n            \n            # The mean of the stream function is arbitrary; set to zero.\n            psi_hat[0, 0] = 0\n\n            # 4. Velocity Field Calculation\n            # Compute derivatives in Fourier space by multiplying with ik.\n            u_hat = 1j * ky * psi_hat\n            v_hat = -1j * kx * psi_hat\n\n            # Transform velocity field back to real space.\n            u = np.real(np.fft.ifft2(u_hat))\n            v = np.real(np.fft.ifft2(v_hat))\n\n            # 5. Error Calculation\n            r = np.sqrt(r_sq)\n            \n            # Define the evaluation annulus.\n            r_min = alpha * sigma\n            r_max = beta * L\n            annulus_mask = (r >= r_min) & (r <= r_max)\n\n            # Filter points that are within the annulus.\n            r_annulus = r[annulus_mask]\n            \n            # Project numerical velocity vector onto the local azimuthal direction.\n            u_annulus = u[annulus_mask]\n            v_annulus = v[annulus_mask]\n            dx_annulus = dx[annulus_mask]\n            dy_annulus = dy[annulus_mask]\n            \n            # The azimuthal unit vector is (-dy/r, dx/r) for CCW.\n            u_theta_num = u_annulus * (-dy_annulus / r_annulus) + v_annulus * (dx_annulus / r_annulus)\n            \n            # Analytical velocity for an unbounded point vortex.\n            u_theta_exact = gamma / (2 * np.pi * r_annulus)\n            \n            # Compute the Root-Mean-Square error.\n            error_sq = (u_theta_num - u_theta_exact)**2\n            rms_error = np.sqrt(np.mean(error_sq))\n            \n            errors.append(rms_error)\n            h_values.append(h)\n\n        # 6. Convergence Order Estimation\n        # Perform a linear fit on log-log data to find the slope p.\n        log_h = np.log(h_values)\n        log_E = np.log(errors)\n        \n        p, _ = np.polyfit(log_h, log_E, 1)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world problems rarely fit onto simple rectangular grids, and this advanced practice introduces a powerful technique for handling complex geometries. You will use a conformal map to transform a physically intricate domain, such as a channel with a wavy bottom, into a simple computational rectangle where the transformed governing equations can be solved efficiently. This exercise requires you to build a sophisticated hybrid solver that combines the spectral method you've seen previously with a finite-difference scheme, demonstrating how to synthesize foundational techniques to tackle challenging and realistic fluid dynamics problems .",
            "id": "2443755",
            "problem": "Consider steady, incompressible, two-dimensional viscous flow modeled by the stream function–vorticity formulation. Let the physical plane be the complex plane with coordinate $z = x + i y$, and let the computational plane be the complex plane with coordinate $\\zeta = \\xi + i \\eta$. You are given a conformal map $z = f(\\zeta)$ that maps the rectangle $\\{ (\\xi,\\eta) \\mid 0 \\le \\xi \\le 2\\pi,\\ 0 \\le \\eta \\le H \\}$ in the computational plane to a wavy channel in the physical plane. The mapping is\n$$\nf(\\zeta) = \\zeta + i a e^{i \\zeta},\n$$\nwith complex derivative\n$$\nf'(\\zeta) = 1 - a e^{i \\zeta}.\n$$\nAssume $|a| < 1$ so that $f$ is conformal and injective on the rectangle. Let the stream function in the physical plane be $\\psi(x,y)$, and define $\\Psi(\\xi,\\eta) = \\psi(x(\\xi,\\eta), y(\\xi,\\eta))$ as its pullback to the computational plane.\n\nThe steady, incompressible, two-dimensional viscous flow in stream function–vorticity variables is governed by the Poisson equation\n$$\n- \\nabla_{z}^{2} \\psi(x,y) = \\omega(x,y),\n$$\nwhere $\\omega(x,y)$ is the scalar vorticity and $\\nabla_{z}^{2}$ is the Laplacian with respect to the physical coordinates $(x,y)$. Under a conformal map, the Laplacian transforms according to a metric factor $h(\\xi,\\eta) = |f'(\\zeta)|$, and it holds that\n$$\n\\nabla_{z}^{2} \\psi(x,y) = \\frac{1}{h(\\xi,\\eta)^{2}} \\nabla_{\\zeta}^{2} \\Psi(\\xi,\\eta).\n$$\nTherefore, in the computational plane the stream function satisfies\n$$\n\\nabla_{\\zeta}^{2} \\Psi(\\xi,\\eta) = - h(\\xi,\\eta)^{2} \\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta)).\n$$\n\nBoundary conditions: impose a linear stream function drop between the bottom and top boundaries, corresponding to a constant volumetric flow rate in the computational strip. Specifically, set\n$$\n\\Psi(\\xi,0) = 0,\\quad \\Psi(\\xi,H) = Q,\n$$\nwith periodicity in $\\xi$ of period $2\\pi$. Let $Q = 1$ in nondimensional units. Define the auxiliary function $B(\\eta) = Q \\, \\eta / H$ so that $\\Psi(\\xi,\\eta) = \\Phi(\\xi,\\eta) + B(\\eta)$, and $\\Phi$ satisfies homogeneous Dirichlet conditions $\\Phi(\\xi,0) = \\Phi(\\xi,H) = 0$ with periodicity in $\\xi$.\n\nTask: Starting from the above fundamental definitions and transformations, implement a computational solver in the computational plane that:\n\n- Discretizes the rectangle $\\{(\\xi,\\eta)\\}$ with $N_{\\xi}$ equispaced points in $\\xi$ over $[0, 2\\pi)$ and $N_{\\eta}$ equispaced points in $\\eta$ over $[0,H]$, with $N_{\\xi} = 64$ and $N_{\\eta} = 65$.\n- Uses a Fourier spectral discretization in $\\xi$ (Fast Fourier Transform (FFT)) and a second-order centered finite-difference discretization in $\\eta$ to solve\n$$\n\\frac{\\partial^{2} \\Phi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Phi}{\\partial \\eta^{2}} = - h(\\xi,\\eta)^{2}\\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta)),\n$$\nsubject to homogeneous Dirichlet conditions on $\\eta = 0$ and $\\eta = H$ and periodicity in $\\xi$.\n- Reconstructs $\\Psi = \\Phi + B$ after solving for $\\Phi$.\n- Verifies the solution by computing the residual\n$$\n\\mathcal{R}(\\xi,\\eta) = \\frac{1}{h(\\xi,\\eta)^{2}} \\left( \\frac{\\partial^{2} \\Psi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Psi}{\\partial \\eta^{2}} \\right) + \\omega(x(\\xi,\\eta), y(\\xi,\\eta)),\n$$\nand reports the maximum absolute value of $\\mathcal{R}$ over the interior grid points $\\{ (\\xi_{i}, \\eta_{j}) \\mid i \\in \\{0,\\dots,N_{\\xi}-1\\},\\ j \\in \\{1,\\dots,N_{\\eta}-2\\} \\}$.\n\nUse the following vorticity fields $\\omega(x,y)$ in the physical plane for the test suite, each expressed in nondimensional units, with the understanding that $x$ is $2\\pi$-periodic:\n\n- Case A: $a = 0$, $H = 1$, $\\omega(x,y) = 0$.\n- Case B: $a = 0$, $H = 1$, $\\omega(x,y) = \\sin(x) \\sin(\\pi y)$.\n- Case C: $a = 0.15$, $H = 1$, $\\omega(x,y) = 0$.\n- Case D: $a = 0.15$, $H = 1$, $\\omega(x,y) = \\sin(x) \\sin(\\pi y)$.\n- Case E: $a = 0.30$, $H = 2$, $\\omega(x,y) = \\cos(2 x) \\sin\\!\\left(\\pi y / H\\right)$.\n\nYour program must:\n\n- Implement the conformal map $f(\\zeta) = \\zeta + i a e^{i \\zeta}$ and its derivative $f'(\\zeta)$ to compute $x(\\xi,\\eta)$, $y(\\xi,\\eta)$, and $h(\\xi,\\eta) = |f'(\\zeta)|$ on the computational grid.\n- Solve the Poisson problem in the computational plane for each case and evaluate the residual $\\mathcal{R}$.\n- For each case, compute a single floating-point number equal to the maximum absolute residual over interior grid points.\n\nFinal output format: Your program should produce a single line of output containing the five results as a comma-separated list enclosed in square brackets, with each floating-point number formatted in scientific notation with six digits after the decimal point (for example, $[1.234567\\mathrm{e}{-04},2.000000\\mathrm{e}{-06},\\dots]$). No other output should be printed.\n\nAll quantities are nondimensional, so no physical units are required and there are no angles outside of the periodic $\\xi$ coordinate, which is in radians by construction. The correctness criterion is the smallness of the residual values. The test suite is:\n\n- Case A: $(a,H,\\omega) = (0,1,\\text{zero})$.\n- Case B: $(a,H,\\omega) = (0,1,\\sin(x)\\sin(\\pi y))$.\n- Case C: $(a,H,\\omega) = (0.15,1,\\text{zero})$.\n- Case D: $(a,H,\\omega) = (0.15,1,\\sin(x)\\sin(\\pi y))$.\n- Case E: $(a,H,\\omega) = (0.30,2,\\cos(2x)\\sin(\\pi y/H))$.\n\nYour code must be entirely self-contained and must not read any input. It must implement the algorithm described above and output the required single line in the specified format.",
            "solution": "The problem statement is scrutinized and found to be valid. It is a well-posed problem in computational physics, grounded in the established principles of fluid dynamics and numerical analysis. The provided parameters and conditions are complete, consistent, and scientifically sound. We shall therefore proceed with the solution.\n\nThe objective is to solve for the stream function $\\Psi(\\xi,\\eta)$ in a computational rectangle $\\{(\\xi,\\eta) \\mid 0 \\le \\xi < 2\\pi, 0 \\le \\eta \\le H \\}$. The governing equation is a Poisson equation derived from the physical stream function-vorticity formulation via a conformal map $z=f(\\zeta)$:\n$$\n\\nabla_{\\zeta}^{2} \\Psi(\\xi,\\eta) = -h(\\xi,\\eta)^{2} \\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta))\n$$\nwhere $\\nabla_{\\zeta}^{2} = \\frac{\\partial^2}{\\partial \\xi^2} + \\frac{\\partial^2}{\\partial \\eta^2}$ is the Laplacian in computational coordinates, $h(\\xi,\\eta) = |f'(\\zeta)|$ is the metric factor of the map, and $\\omega$ is the physical vorticity field.\n\nThe boundary conditions are periodic in $\\xi$ and Dirichlet in $\\eta$: $\\Psi(\\xi,0) = 0$ and $\\Psi(\\xi,H) = Q$. To handle the inhomogeneous Dirichlet conditions, we decompose the stream function as $\\Psi(\\xi,\\eta) = \\Phi(\\xi,\\eta) + B(\\eta)$, where $B(\\eta) = Q \\eta / H$. The function $\\Phi$ must then satisfy homogeneous Dirichlet conditions, $\\Phi(\\xi,0) = 0$ and $\\Phi(\\xi,H) = 0$, and remains periodic in $\\xi$. Since $B(\\eta)$ is linear in $\\eta$, its Laplacian is zero, i.e., $\\nabla_{\\zeta}^{2} B(\\eta) = d^2B/d\\eta^2 = 0$. The problem thus reduces to solving the following Poisson equation for $\\Phi$:\n$$\n\\frac{\\partial^{2} \\Phi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Phi}{\\partial \\eta^{2}} = -h(\\xi,\\eta)^{2} \\, \\omega(x(\\xi,\\eta), y(\\xi,\\eta)) \\equiv F(\\xi,\\eta)\n$$\non the computational domain, with homogeneous boundary conditions.\n\nA hybrid numerical method is employed, leveraging the nature of the boundary conditions. The periodicity in the $\\xi$-direction suggests a spectral method using a Fourier series representation:\n$$\n\\Phi(\\xi,\\eta) = \\sum_{k=-\\infty}^{\\infty} \\hat{\\Phi}_k(\\eta) e^{ik\\xi}\n$$\nwhere $k$ are integer wavenumbers. Substituting this expansion into the Poisson equation for $\\Phi$ decouples the partial differential equation into a set of independent ordinary differential equations (ODEs), one for each wavenumber $k$:\n$$\n\\frac{d^2 \\hat{\\Phi}_k}{d\\eta^2} - k^2 \\hat{\\Phi}_k(\\eta) = \\hat{F}_k(\\eta)\n$$\nHere, $\\hat{\\Phi}_k(\\eta)$ and $\\hat{F}_k(\\eta)$ are the Fourier coefficients of $\\Phi(\\xi,\\eta)$ and $F(\\xi,\\eta)$ respectively, with respect to $\\xi$. The boundary conditions for $\\Phi$ transform to $\\hat{\\Phi}_k(0) = 0$ and $\\hat{\\Phi}_k(H) = 0$ for all $k$.\n\nThe numerical solution proceeds as follows:\nFirst, the computational domain is discretized into a grid of $N_\\xi \\times N_\\eta$ points, $(\\xi_i, \\eta_j)$, where $\\xi_i = i (2\\pi/N_\\xi)$ for $i \\in \\{0, \\dots, N_\\xi-1\\}$ and $\\eta_j = j(H/(N_\\eta-1))$ for $j \\in \\{0, \\dots, N_\\eta-1\\}$. On this grid, we compute the physical coordinates $(x_{ij}, y_{ij})$, the metric factor $h_{ij}$, and the right-hand side function $F_{ij}$.\n\nSecond, for each grid row corresponding to a fixed $\\eta_j$, the discrete version of the right-hand side, $F_{ij}$, is transformed into Fourier space using the Fast Fourier Transform (FFT) algorithm, yielding the discrete Fourier coefficients $\\hat{F}_{k,j}$.\n\nThird, for each discrete wavenumber $k$, the ODE is discretized in the $\\eta$-direction using a second-order centered finite difference scheme at the interior grid points $j \\in \\{1, \\dots, N_\\eta-2\\}$:\n$$\n\\frac{\\hat{\\Phi}_{k,j+1} - 2\\hat{\\Phi}_{k,j} + \\hat{\\Phi}_{k,j-1}}{(\\Delta\\eta)^2} - k^2 \\hat{\\Phi}_{k,j} = \\hat{F}_{k,j}\n$$\nwhere $\\Delta\\eta = H/(N_\\eta-1)$ is the grid spacing in $\\eta$. This approximation, combined with the boundary conditions $\\hat{\\Phi}_{k,0} = 0$ and $\\hat{\\Phi}_{k,N_\\eta-1} = 0$, results in a system of linear algebraic equations for the vector of unknowns $(\\hat{\\Phi}_{k,1}, \\dots, \\hat{\\Phi}_{k,N_\\eta-2})^T$. The coefficient matrix of this system is tridiagonal, symmetric, and diagonally dominant, which guarantees a unique solution and allows for highly efficient solution using a banded matrix solver.\n\nFourth, after solving the tridiagonal systems for all wavenumbers $k$, we obtain the full grid of Fourier coefficients $\\hat{\\Phi}_{k,j}$. An inverse FFT is then applied to each row (fixed $j$) to transform the solution back to the computational spatial domain, yielding the discrete solution for $\\Phi_{ij}$.\n\nFifth, the full stream function is reconstructed by adding the linear background flow: $\\Psi_{ij} = \\Phi_{ij} + B(\\eta_j)$.\n\nFinally, to verify the correctness of the implementation, the residual $\\mathcal{R}$ is computed:\n$$\n\\mathcal{R}(\\xi,\\eta) = \\frac{1}{h(\\xi,\\eta)^{2}} \\left( \\frac{\\partial^{2} \\Psi}{\\partial \\xi^{2}} + \\frac{\\partial^{2} \\Psi}{\\partial \\eta^{2}} \\right) + \\omega(x(\\xi,\\eta), y(\\xi,\\eta))\n$$\nThe derivatives in the Laplacian $\\nabla_\\zeta^2 \\Psi$ are computed numerically in a manner consistent with the solver: the $\\xi$-derivative is calculated spectrally via FFT, and the $\\eta$-derivative is calculated using second-order centered finite differences. The maximum absolute value of this residual over all interior grid points serves as a robust metric of the solution's accuracy. The expected value for a correct implementation is a small number, approaching machine precision for cases with analytical solutions and limited by discretization error otherwise.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    N_xi = 64\n    N_eta = 65\n    Q = 1.0\n\n    test_cases = [\n        # Case A: (a, H, omega_func)\n        (0.0, 1.0, lambda x, y, H: 0.0),\n        # Case B\n        (0.0, 1.0, lambda x, y, H: np.sin(x) * np.sin(np.pi * y)),\n        # Case C\n        (0.15, 1.0, lambda x, y, H: 0.0),\n        # Case D\n        (0.15, 1.0, lambda x, y, H: np.sin(x) * np.sin(np.pi * y)),\n        # Case E\n        (0.30, 2.0, lambda x, y, H: np.cos(2 * x) * np.sin(np.pi * y / H)),\n    ]\n\n    results = []\n    for a, H, omega_func in test_cases:\n        residual = solve_poisson_case(a, H, omega_func, N_xi, N_eta, Q)\n        results.append(f\"{residual:.6e}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef solve_poisson_case(a, H, omega_func, N_xi, N_eta, Q):\n    \"\"\"\n    Solves the Poisson equation for a single test case.\n    \n    Returns:\n        float: The maximum absolute residual over the interior grid points.\n    \"\"\"\n    # 1. Grid and coordinate setup\n    xi = np.linspace(0, 2 * np.pi, N_xi, endpoint=False)\n    eta = np.linspace(0, H, N_eta, endpoint=True)\n    delta_xi = 2 * np.pi / N_xi\n    delta_eta = H / (N_eta - 1)\n    \n    XI, ETA = np.meshgrid(xi, eta, indexing='xy') # (N_eta, N_xi) arrays\n\n    # 2. Conformal map, physical coordinates, and metric factor\n    ZETA = XI + 1j * ETA\n    Z = ZETA + 1j * a * np.exp(1j * ZETA)\n    X, Y = Z.real, Z.imag\n    \n    dZ_dZETA = 1 - a * np.exp(1j * ZETA)\n    h_sq = np.abs(dZ_dZETA)**2\n    \n    # 3. Right-hand side of the Poisson equation for Phi\n    omega = omega_func(X, Y, H)\n    F = -h_sq * omega\n    \n    # 4. Forward FFT of the RHS\n    F_hat = np.fft.fft(F, axis=1)\n    \n    # 5. Solve tridiagonal systems in Fourier space\n    k_vec = np.fft.fftfreq(N_xi) * N_xi # Integer wavenumbers\n    Phi_hat = np.zeros_like(F_hat, dtype=np.complex128)\n    \n    num_interior_eta = N_eta - 2\n    if num_interior_eta > 0:\n        # Construct the banded matrix diagonals\n        ab = np.zeros((3, num_interior_eta), dtype=float)\n        ab[0, 1:] = 1.0 / delta_eta**2  # Super-diagonal\n        ab[2, :-1] = 1.0 / delta_eta**2  # Sub-diagonal\n        \n        for k_idx, k in enumerate(k_vec):\n            # Main diagonal depends on wavenumber k\n            ab[1, :] = -(k**2 + 2.0 / delta_eta**2)\n            \n            # RHS vector for this wavenumber\n            RHS_k = F_hat[1:-1, k_idx]\n            \n            # Solve the banded system\n            sol = solve_banded((1, 1), ab, RHS_k)\n            Phi_hat[1:-1, k_idx] = sol\n            \n    # 6. Inverse FFT to find Phi\n    Phi = np.fft.ifft(Phi_hat, axis=1).real\n    \n    # 7. Reconstruct the full stream function Psi\n    B = Q * ETA / H\n    Psi = Phi + B\n    \n    # 8. Compute the residual to verify the solution\n    # d^2(Psi)/d(xi)^2 using spectral differentiation\n    Psi_hat = np.fft.fft(Psi, axis=1)\n    d2Psi_dxi2_hat = -(k_vec**2) * Psi_hat\n    d2Psi_dxi2 = np.fft.ifft(d2Psi_dxi2_hat, axis=1).real\n    \n    # d^2(Psi)/d(eta)^2 using second-order centered finite differences\n    d2Psi_deta2 = np.zeros_like(Psi)\n    d2Psi_deta2[1:-1, :] = (Psi[2:, :] - 2*Psi[1:-1, :] + Psi[:-2, :]) / delta_eta**2\n    \n    # Laplacian in computational coordinates\n    Laplacian_Psi = d2Psi_dxi2 + d2Psi_deta2\n    \n    # Residual: R = (1/h^2) * Laplacian(Psi) + omega\n    Residual = Laplacian_Psi / h_sq + omega\n    \n    # Maximum absolute residual over interior points\n    max_abs_residual = np.max(np.abs(Residual[1:-1, :]))\n    \n    return max_abs_residual\n\nsolve()\n```"
        }
    ]
}