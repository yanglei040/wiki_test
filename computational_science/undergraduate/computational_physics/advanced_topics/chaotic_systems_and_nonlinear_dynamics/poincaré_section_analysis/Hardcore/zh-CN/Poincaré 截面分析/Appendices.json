{
    "hands_on_practices": [
        {
            "introduction": "庞加莱截面不仅是可视化工具，也是一个强大的诊断工具。这个练习将引导你进行一次“逆向工程”：从一个已知的、几何上很简单的庞加莱截面出发，反向推导出产生它的最基本物理模型。通过解决这个问题，你将加深对相空间几何形态与系统哈密顿量（即能量）之间内在联系的理解。",
            "id": "2427582",
            "problem": "考虑一个具有单一自由度的不依赖于时间的哈密顿系统，其正则坐标为 $(q,p)$。对于此类系统，在庞加莱截面中观察到的不变曲线与哈密顿量在 $(q,p)$ 平面上的等能面重合。在某一特定能量下，通过实验获得的庞加莱截面显示出一条由椭圆方程给出的不变曲线\n$$(\\tfrac{q}{2})^{2}+(\\tfrac{p}{3})^{2}=1.$$\n假设使用无量纲单位且质量为单位质量，并且哈密顿量是可分离为动能和势能的最简单的正定二次型，\n$$H(q,p)=\\tfrac{1}{2}p^{2}+\\tfrac{1}{2}k q^{2},$$\n其中 $k>0$ 有待确定，以使给定的椭圆恰好是其一条等能曲线。确定 $H(q,p)$ 的显式闭式表达式。\n\n请用 $(q,p)$ 的单个解析表达式表示最终答案，使用无量纲单位。无需四舍五入。",
            "solution": "对问题陈述进行严格验证。\n\n步骤 1：提取已知条件。\n- 一个具有单一自由度的不依赖于时间的哈密顿系统，其正则坐标为 $(q,p)$。\n- 来自庞加莱截面的一条特定不变曲线由椭圆方程给出：$(\\frac{q}{2})^{2}+(\\frac{p}{3})^{2}=1$。\n- 假设使用无量纲单位且质量为单位质量。哈密顿量的形式为 $H(q,p)=\\frac{1}{2}p^{2}+\\frac{1}{2}k q^{2}$。\n- 参数 $k$ 为正， $k>0$。\n- 任务是找到 $H(q,p)$ 的显式闭式表达式。\n\n步骤 2：使用提取的已知条件进行验证。\n- 科学依据：该问题描述了一个简谐振子，这是经典力学中的一个基本模型。相空间中的等能面与系统轨迹之间的对应关系是哈密顿动力学的核心原则。所指定的哈密顿量形式是单位质量简谐振子的标准形式。该问题在科学上是合理的。\n- 良定性：该问题提供了哈密顿量的函数形式，其中包含一个未知参数 $k$ 和一个约束条件（特定能级的方程）。这些信息足以唯一确定 $k$ 以及哈密顿量。该问题是良定的。\n- 客观性：该问题以精确、定量的术语陈述，没有歧义或主观论断。\n\n步骤 3：结论与行动。\n该问题是有效的，因为它具有科学依据、良定、客观，并且包含足够的信息以获得唯一解。我将继续推导解答。\n\n问题陈述，对于一个具有单一自由度、不依赖于时间的哈密顿系统，相空间中的等能面就是不变曲线。哈密顿量以简谐振子的形式给出：\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2}$$\n其中 $k>0$ 是一个待定常数。一条等能曲线由方程 $H(q,p) = E$ 定义，其中 $E$ 是某个恒定的能量。\n$$\\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2} = E$$\n由于哈密顿量是平方和且 $k>0$，它是一个正定二次型。对于给定的非平凡椭圆，能量必须为正，即 $E>0$。为了将此方程与椭圆的标准形式进行比较，我们两边同除以 $E$：\n$$\\frac{p^{2}}{2E} + \\frac{k q^{2}}{2E} = 1$$\n该方程可以重写为椭圆的规范形式 $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$：\n$$\\left(\\frac{q}{\\sqrt{\\frac{2E}{k}}}\\right)^{2} + \\left(\\frac{p}{\\sqrt{2E}}\\right)^{2} = 1$$\n该方程描述了给定哈密顿量形式的所有可能的等能曲线族。\n\n问题提供了一条实验确定的不变曲线，它必须对应于一个特定的能级。该曲线的方程为：\n$$\\left(\\frac{q}{2}\\right)^{2} + \\left(\\frac{p}{3}\\right)^{2} = 1$$\n通过比较这两个椭圆表达式，我们可以令 $q$ 和 $p$ 方向上的半轴相等。\n$q$ 方向上的半轴给出方程：\n$$\\sqrt{\\frac{2E}{k}} = 2$$\n$p$ 方向上的半轴给出方程：\n$$\\sqrt{2E} = 3$$\n这为两个未知数 $E$ 和 $k$ 提供了一个包含两个方程的方程组。从第二个方程，我们可以解出这条特定不变曲线的能量 $E$。两边平方得到：\n$$2E = 9 \\implies E = \\frac{9}{2}$$\n现在，我们将这个 $E$ 的值代入第一个方程来求解 $k$：\n$$\\sqrt{\\frac{2\\left(\\frac{9}{2}\\right)}{k}} = 2$$\n$$\\sqrt{\\frac{9}{k}} = 2$$\n将此方程两边平方得到：\n$$\\frac{9}{k} = 4$$\n解出 $k$，我们得到：\n$$k = \\frac{9}{4}$$\n这个值满足条件 $k>0$。问题要求的是哈密顿量 $H(q,p)$ 的显式闭式表达式，而不是所观察到的特定曲线的能量。我们现在将确定的 $k$ 值代回到哈密顿量的一般形式中：\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}\\left(\\frac{9}{4}\\right)q^{2}$$\n简化此表达式得到哈密顿量的最终形式：\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}$$\n这就是在 $E = \\frac{9}{2}$ 时，生成给定椭圆作为其等能曲线的哈密顿量。",
            "answer": "$$\\boxed{\\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}}$$"
        },
        {
            "introduction": "许多有趣的物理系统，例如著名的 Hénon-Heiles 系统，其动力学行为过于复杂，无法用解析方法求解，必须依赖数值计算。本练习将带你进入计算物理的核心，学习如何为一个非线性的、可能表现出混沌行为的系统生成庞加莱截面。你将通过编写代码，亲手揭示从规则运动到混沌区域并存的复杂相空间结构。",
            "id": "2427559",
            "problem": "考虑无量纲单位下的二自由度 Hénon-Heiles 哈密顿系统，\n$$\nH(q_1,q_2,p_1,p_2) = \\frac{1}{2}\\left(p_1^2 + p_2^2 + q_1^2 + q_2^2\\right) + q_1^2 q_2 - \\frac{1}{3} q_2^3.\n$$\n其运动方程源自哈密顿方程。在 $(q_2,p_2)$ 子空间中，通过以下方式定义一个单参数旋转截面坐标族：\n$$\n\\begin{pmatrix}\nu \\\\\nv\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos \\theta & \\sin \\theta \\\\\n- \\sin \\theta & \\cos \\theta\n\\end{pmatrix}\n\\begin{pmatrix}\nq_2 \\\\\np_2\n\\end{pmatrix},\n$$\n其中角度 $\\theta$ 以弧度为单位。庞加莱截面超曲面由条件 $u=0$ 定义，横向穿越方向受限于 $v>0$。在每次这样的穿越时，记录下点对 $(q_1,p_1)$。\n\n对于给定的总能量 $E>0$，按如下方式在能量壳层上构造初始条件。固定 $q_1(0)=0$。选择一个小的正振幅 $\\alpha$ 和一个小的偏移量 $\\delta$ 并设置\n$$\nq_2^{\\star} = -\\alpha \\sin \\theta, \\quad p_2^{\\star} = \\alpha \\cos \\theta,\n$$\n然后施加一个位移\n$$\nq_2(0) = q_2^{\\star} - \\delta \\cos \\theta, \\quad p_2(0) = p_2^{\\star} - \\delta \\sin \\theta,\n$$\n使得 $u(0) = -\\delta < 0$ 且 $v(0)=\\alpha > 0$。通过取正根，从能量约束 $H(q_1(0),q_2(0),p_1(0),p_2(0))=E$ 中确定 $p_1(0)$，\n$$\np_1(0) = \\sqrt{\\,2\\left[E - \\left(\\frac{1}{2}\\left(q_1(0)^2 + q_2(0)^2\\right) + q_1(0)^2 q_2(0) - \\frac{1}{3}q_2(0)^3\\right) - \\frac{1}{2}p_2(0)^2\\right]\\,}.\n$$\n演化轨迹，并检测在时间 $t>0$（不包括 $t=0$）时，轨迹与超曲面 $u=0$ 且 $v>0$ 的前 $N$ 次穿越。在每次这样的穿越时，收集相应的 $(q_1,p_1)$ 点对。\n\n角度 $\\theta$ 必须以弧度为单位指定。所有量纲均与上述哈密顿量使用相同的无量纲单位。每个测试用例所需的输出是前 $N$ 个记录的点对 $(q_1,p_1)$ 的列表，其中每个数字都四舍五入到六位小数。\n\n使用以下测试套件，其中为每个案例指定了 $(E,\\theta,\\alpha,\\delta,T,N)$，其中 $T$ 是最大积分时间，$N$ 是要返回的穿越次数：\n- 案例 A (一般角度截面)：$(0.118,\\ \\pi/6,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$。\n- 案例 B (边界方向 $\\theta=0$)：$(0.125,\\ 0,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$。\n- 案例 C (接近逃逸阈值 $E \\approx 1/6$)：$(0.166,\\ 1.2,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$。\n- 案例 D (边界方向 $\\theta=\\pi/2$)：$(0.10,\\ \\pi/2,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身就是一个包含 $N$ 个双元素列表 $[q_1,p_1]$ 的列表，其中每个浮点数都四舍五入到六位小数。确切格式为\n$$\n\\big[\\, [ [q_{1,1},p_{1,1}], \\dots, [q_{1,N},p_{1,N}] ],\\ [ [q_{2,1},p_{2,1}], \\dots, [q_{2,N},p_{2,N}] ],\\ [ [q_{3,1},p_{3,1}], \\dots, [q_{3,N},p_{3,N}] ],\\ [ [q_{4,1},p_{4,1}], \\dots, [q_{4,N},p_{4,N}] ] \\,\\big],\n$$\n该行中任何地方都不能有空格。角度以弧度为单位，所有物理量均为无量纲。将所有报告的数字四舍五入到六位小数。",
            "solution": "该问题是有效的。它提出了计算物理学中一个明确定义的任务，特别是使用庞加莱截面对 Hénon-Heiles 系统进行分析。该问题具有科学依据，内容自洽，并且所有参数和初始条件都得到了明确的规定。\n\nHénon-Heiles 系统由哈密顿量描述：\n$$\nH(q_1, q_2, p_1, p_2) = \\frac{1}{2}(p_1^2 + p_2^2 + q_1^2 + q_2^2) + q_1^2 q_2 - \\frac{1}{3} q_2^3\n$$\n系统的动力学由哈密顿方程 $\\dot{q}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i$ 控制。对于状态向量 $\\mathbf{y}(t) = [q_1(t), q_2(t), p_1(t), p_2(t)]^T$，这些方程为：\n$$\n\\begin{aligned}\n\\dot{q}_1 = p_1 \\\\\n\\dot{q}_2 = p_2 \\\\\n\\dot{p}_1 = -q_1 - 2q_1 q_2 = -q_1(1 + 2q_2) \\\\\n\\dot{p}_2 = -q_2 - q_1^2 + q_2^2\n\\end{aligned}\n$$\n这构成了一个包含四个耦合一阶常微分方程 (ODEs) 的系统。总能量 $E = H(\\mathbf{y}(t))$ 是一个守恒量，这一事实可用于监测数值积分的准确性。\n\n庞加莱截面定义在相空间中的一个超曲面上。在此问题中，该截面定义在 $(q_2, p_2)$ 子空间中的一个旋转坐标系内：\n$$\n\\begin{pmatrix} u \\\\ v \\end{pmatrix} = \\begin{pmatrix} \\cos \\theta & \\sin \\theta \\\\ -\\sin \\theta & \\cos \\theta \\end{pmatrix} \\begin{pmatrix} q_2 \\\\ p_2 \\end{pmatrix}\n$$\n截面由条件 $u = q_2 \\cos \\theta + p_2 \\sin \\theta = 0$ 给出。只有当穿越满足附加条件 $v = -q_2 \\sin \\theta + p_2 \\cos \\theta > 0$ 时，才会被记录。\n\n求解方法涉及运动方程的数值积分，并结合事件检测机制来识别轨迹何时穿过庞加莱截面。步骤如下：\n\n1.  **初始化**：对于每个由参数 $(E, \\theta, \\alpha, \\delta, T, N)$ 指定的测试用例，构建初始状态向量 $\\mathbf{y}(0) = [q_1(0), q_2(0), p_1(0), p_2(0)]^T$。\n    -   $q_1(0) = 0$。\n    -   $q_2(0) = -\\alpha \\sin \\theta - \\delta \\cos \\theta$。\n    -   $p_2(0) = \\alpha \\cos \\theta - \\delta \\sin \\theta$。\n    -   $p_1(0)$ 通过求解能量守恒方程 $H(\\mathbf{y}(0)) = E$ 并取正根来确定：\n        $$\n        p_1(0) = \\sqrt{2E - p_2(0)^2 - q_2(0)^2 + \\frac{2}{3}q_2(0)^3}\n        $$\n    初始状态的构造使得 $u(0) = -\\delta < 0$，这意味着我们关心的是轨迹从 $u<0$ 区域移动到 $u>0$ 区域的穿越。\n\n2.  **数值积分**：从 $t=0$ 到最大时间 $t=T$，对常微分方程组进行时间上的正向积分。为保证准确性，需要使用高阶自适应步长积分器，因为混沌系统对初始条件和积分误差高度敏感。`scipy.integrate.solve_ivp` 函数与 `DOP853` 方法以及严格的误差容限（例如，相对容限 $rtol=10^{-11}$ 和绝对容限 $atol=10^{-12}$）适合此目的。\n\n3.  **事件检测**：使用 `solve_ivp` 积分器的事件检测功能来找到 $u(t_i) = 0$ 的时间点 $t_i > 0$。事件函数为 $g(t, \\mathbf{y}) = u(q_2(t), p_2(t)) = y_1(t) \\cos\\theta + y_3(t) \\sin\\theta$。我们指定一个正向穿越方向，这意味着事件仅在 $g(t, \\mathbf{y})$ 从负值穿越零到正值时触发。这对应于轨迹以 $\\dot{u}>0$ 穿透截面。\n\n4.  **数据收集**：对于在时间 $t_i$ 找到的每个事件，评估系统在该时间点的状态 $\\mathbf{y}(t_i)$。然后检查条件 $v(t_i) > 0$。如果满足此条件，则记录点对 $(q_1(t_i), p_1(t_i))$。重复此过程，直到收集到 $N$ 个这样的点对。\n\n5.  **输出格式化**：将每个测试用例收集到的点对四舍五入到六位小数，并格式化为指定的字符串表示形式。\n\n实现将包括一个用于 Hénon-Heiles 运动方程的函数，一个用于定义依赖于参数的事件函数 $u(t)$ 的函数或类，以及一个主循环，用于根据上述步骤处理每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the Poincaré section points of the Hénon-Heiles system for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (E, theta, alpha, delta, T, N)\n    test_cases = [\n        (0.118, np.pi/6, 0.05, 1e-6, 200, 5),\n        (0.125, 0.0, 0.05, 1e-6, 200, 5),\n        (0.166, 1.2, 0.05, 1e-6, 200, 5),\n        (0.10, np.pi/2, 0.05, 1e-6, 200, 5),\n    ]\n\n    all_results_str = []\n\n    def henon_heiles_eom(t, y):\n        \"\"\"\n        Equations of motion for the Hénon-Heiles system.\n        y = [q1, q2, p1, p2]\n        \"\"\"\n        q1, q2, p1, p2 = y\n        dq1_dt = p1\n        dq2_dt = p2\n        dp1_dt = -q1 * (1 + 2 * q2)\n        dp2_dt = -q2 - q1**2 + q2**2\n        return [dq1_dt, dq2_dt, dp1_dt, dp2_dt]\n\n    for E, theta, alpha, delta, T, N in test_cases:\n        # Calculate initial conditions\n        sin_theta, cos_theta = np.sin(theta), np.cos(theta)\n        \n        q1_0 = 0.0\n        q2_0 = -alpha * sin_theta - delta * cos_theta\n        p2_0 = alpha * cos_theta - delta * sin_theta\n        \n        # Ensure argument of sqrt is non-negative\n        p1_0_sq_arg = 2 * E - p2_0**2 - q2_0**2 + (2/3) * q2_0**3\n        if p1_0_sq_arg  0:\n            # This should not happen with the given test cases\n            p1_0 = 0.0 \n        else:\n            p1_0 = np.sqrt(p1_0_sq_arg)\n\n        y0 = [q1_0, q2_0, p1_0, p2_0]\n\n        # Define event function for Poincare section\n        def poincare_section_event(t, y, theta):\n            q2, p2 = y[1], y[3]\n            return q2 * np.cos(theta) + p2 * np.sin(theta)\n        \n        poincare_section_event.terminal = False\n        poincare_section_event.direction = 1  # Detect crossing from negative to positive\n\n        # Integrate ODE\n        sol = solve_ivp(\n            fun=lambda t, y: henon_heiles_eom(t, y),\n            t_span=(0, T),\n            y0=y0,\n            method='DOP853',\n            events=lambda t, y: poincare_section_event(t, y, theta),\n            dense_output=True,\n            rtol=1e-11,\n            atol=1e-12,\n        )\n        \n        # Collect results\n        crossings = []\n        if sol.t_events[0].size > 0:\n            for t_event in sol.t_events[0]:\n                if len(crossings) >= N:\n                    break\n                y_event = sol.sol(t_event)\n                q1, q2, p1, p2 = y_event\n\n                # Check the v > 0 condition\n                v = -q2 * sin_theta + p2 * cos_theta\n                if v > 0:\n                    crossings.append([float(q1), float(p1)])\n\n        # Format the result for the current case\n        case_str = f\"[{','.join([f'[{p[0]:.6f},{p[1]:.6f}]' for p in crossings])}]\"\n        all_results_str.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算物理学中，得到一个结果仅仅是开始，验证其准确性才是关键，尤其是在处理对初始条件和计算误差极其敏感的混沌系统时。这个练习将让你直面数值模拟的现实挑战，通过比较不同精度的时间积分方法（如欧拉法和龙格-库塔法）对杜芬振子混沌吸引子结构的影响，学习如何评估和量化数值误差。这能培养你作为一名计算科学家的严谨性和批判性思维。",
            "id": "2427621",
            "problem": "您将研究时间积分方法的选择如何影响受迫Duffing振子的庞加莱截面的几何形状。Duffing振子由一个自治一阶系统所控制，该系统从二阶方程 $$\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t),$$ 改写而来：$$\\frac{dx}{dt} = v,\\quad \\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi),\\quad \\frac{d\\phi}{dt} = \\omega,$$ 其中 $x$ 是位移，$v$ 是速度，$\\phi$ 是驱动相位。关于驱动的庞加莱截面是在 $\\phi$ 为 $2\\pi$ 整数倍时采样的一组状态。您的任务是实现并比较两种数值时间积分器：显式Euler法和经典四阶Runge–Kutta法，并量化它们的数值误差如何扭曲混沌Duffing吸引子的庞加莱截面。\n\n请从常微分方程初值问题的基本定义、作为在固定相位的频闪采样的Poincaré映射概念，以及用于时间步进的确定性数值积分出发。除了应用于 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y},t)$ 的显式Euler法和经典四阶Runge–Kutta法的标准更新规则外，不要假定任何其他专用公式。\n\n对于Duffing振子的混沌行为，请使用以下物理上合理且被广泛研究的参数集：$$\\alpha = -1.0,\\ \\beta = 1.0,\\ \\delta = 0.3,\\ \\gamma = 0.37,\\ \\omega = 1.2.$$ 使用初始条件 $$x(0) = 0,\\ v(0) = 0,\\ \\phi(0) = 0.$$ 将 $t$ 的单位解释为秒，$\\phi$ 的单位解释为弧度，并将 $x$ 和 $v$ 视为无量纲。通过检测 $\\phi = 2\\pi k$（其中 $k \\in \\mathbb{Z}_{\\ge 1}$）的连续穿越点来构建庞加莱截面，并使用时间步之间的线性插值来在确切的穿越时刻对状态进行采样。将前 $200$ 个穿越点作为暂态丢弃，然后收集接下来的 $300$ 个庞加莱点 $\\{(x_k, v_k)\\}$。\n\n为了量化两个庞加莱截面 $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ 和 $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$ 之间的几何差异，请计算对称平均最近邻距离 $$D(\\mathcal{A},\\mathcal{B}) = \\tfrac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\sqrt{(x_i - x'_j)^2 + (v_i - v'_j)^2} + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\sqrt{(x'_j - x_i)^2 + (v'_j - v_i)^2}\\right).$$\n\n为上述自治系统实现显式Euler法和经典四阶Runge–Kutta法，并为以下四个测试案例计算庞加莱截面。在所有案例中，将 $D(\\mathcal{A},\\mathcal{B})$ 报告为一个四舍五入到6位小数的浮点数。时间步长 $h$ 的单位是秒。\n\n测试套件：\n- 案例1（理想路径）：比较 $h = 0.02$ 时的显式Euler法与经典四阶Runge–Kutta法。\n- 案例2（更粗的步长）：比较 $h = 0.05$ 时的显式Euler法与经典四阶Runge–Kutta法。\n- 案例3（方法一致性控制）：比较 $h = 0.02$ 时的经典四阶Runge–Kutta法与 $h = 0.01$ 时的经典四阶Runge–Kutta法。\n- 案例4（Euler自洽性）：比较 $h = 0.02$ 时的显式Euler法与 $h = 0.01$ 时的显式Euler法。\n\n角度单位必须是弧度。最终输出必须是四个浮点数，每个浮点数等于相应案例的 $D(\\mathcal{A},\\mathcal{B})$ 值，并四舍五入到6位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），不含任何额外文本。\n\n确保科学真实性：使用线性插值、确定性步进和给定的参数值来精确构建庞加莱截面的相穿越，并以双精度执行所有计算。每个测试案例的答案都是无单位的浮点数，因为它们是无量纲 $(x,v)$ 平面上的距离。在整个过程中，角度必须以弧度为单位，时间必须以秒为单位。",
            "solution": "所提出的问题要求通过分析两种数值积分方案——显式Euler法和经典四阶Runge-Kutta法——对计算出的受迫Duffing振子庞加莱截面的影响，来进行定量比较。该分析属于计算动力学领域，以及混沌系统模拟中数值赝象的研究。此问题提法恰当，有科学依据，并为严谨的求解提供了所有必要的规范。\n\n基础物理系统是受迫Duffing振子，一个关于位移 $x(t)$ 的二阶非线性常微分方程（ODE）：\n$$\n\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t)\n$$\n为了便于数值积分，通过定义状态向量 $\\mathbf{y}(t) = [x(t), v(t), \\phi(t)]^T$，该方程被转换为一个包含三个一阶常微分方程的自治系统。其中 $v = dx/dt$ 是速度，$\\phi = \\omega t$ 是外部驱动的相位。该系统则由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 给出：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi)\n$$\n$$\n\\frac{d\\phi}{dt} = \\omega\n$$\n问题指定了产生混沌行为的参数：$\\alpha = -1.0$, $\\beta = 1.0$, $\\delta = 0.3$, $\\gamma = 0.37$, and $\\omega = 1.2$。初始条件设置为 $\\mathbf{y}(0) = [0, 0, 0]^T$。\n\n采用数值积分方法来在离散时间步上近似解轨迹 $\\mathbf{y}(t)$。我们考虑一个时间步长 $h$。在时间 $t_{n+1} = t_n + h$ 的状态是从时间 $t_n$ 的状态近似得出的。\n\n首先，显式Euler法是一种一阶方法，其更新规则定义为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\cdot \\mathbf{f}(\\mathbf{y}_n)\n$$\n该方法简单，但局部截断误差为 $O(h^2)$ 阶，全局误差为 $O(h)$ 阶，这使其对于刚性或混沌系统而言相对不准确且可能不稳定。\n\n其次，经典四阶Runge-Kutta法（RK4）提供了更精确的近似。它是一种四阶方法，全局误差为 $O(h^4)$ 阶。其更新规则由下式给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中中间斜率为：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h \\mathbf{k}_3)\n$$\n\n庞加莱截面提供了一种在低维空间中可视化系统动力学的方法。对于这个周期驱动系统，我们使用频闪映射，即在驱动相位 $\\phi$ 每次穿过 $2\\pi$ 的整数倍时对状态 $(x, v)$ 进行采样。由于 $\\phi(0)=0$ 且 $\\dot{\\phi}=\\omega$ 是一个正常数，我们监测轨迹并在时间 $t_k$ 记录状态，使得对整数 $k \\ge 1$ 有 $\\phi(t_k) = 2\\pi k$。一个从 $t_n$ 时的 $\\mathbf{y}_n$ 到 $t_{n+1}$ 时的 $\\mathbf{y}_{n+1}$ 的数值时间步可能会跨越这样一个穿越点。如果对于某个整数 $k$，有 $\\phi_n  2\\pi k \\le \\phi_{n+1}$，则发生了一次穿越。庞加莱截面上的状态 $(x^*, v^*)$ 通过线性插值求得。插值因子 $\\theta \\in [0, 1]$ 由相位计算得出：\n$$\n\\theta = \\frac{2\\pi k - \\phi_n}{\\phi_{n+1} - \\phi_n}\n$$\n然后插值状态为：\n$$\nx^* = (1 - \\theta)x_n + \\theta x_{n+1}\n$$\n$$\nv^* = (1 - \\theta)v_n + \\theta v_{n+1}\n$$\n前 $200$ 个点被丢弃，以确保轨迹已稳定在吸引子上，随后的 $300$ 个点被收集起来形成庞加莱截面。\n\n为了量化两个庞加莱截面 $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ 和 $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$（其中 $N = M = 300$）之间的几何差异，我们计算指定的对称平均最近邻距离 $D(\\mathcal{A},\\mathcal{B})$：\n$$\nD(\\mathcal{A},\\mathcal{B}) = \\frac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\|\\mathbf{p}_i - \\mathbf{p}'_j\\|_2 + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\|\\mathbf{p}'_j - \\mathbf{p}_i\\|_2\\right)\n$$\n其中 $\\mathbf{p}_i = (x_i, v_i)$ 和 $\\mathbf{p}'_j = (x'_j, v'_j)$，$\\|\\cdot\\|_2$ 是欧几里得距离。该度量计算从一个集合中的每个点到另一个集合中最近邻点的平均距离，并对结果进行对称化。它提供了一个稳健的度量，用于衡量两个点云的对齐程度。\n\n总体算法流程如下：对于四个测试案例中的每一个，我们使用指定的方法和时间步长生成两个庞加莱截面。对于每个截面，我们从初始条件开始对系统进行积分，检测相位穿越，插值以找到经过 $200$ 点暂态后的 $300$ 个吸引子点，并存储这些点。然后，我们计算两个生成的点集之间的距离 $D(\\mathcal{A}, \\mathcal{B})$，并报告四舍五入到6位小数的值。这个过程系统地评估了数值方法的选择和步长大小对混沌吸引子几何结构的影响。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Computes Poincaré sections of the Duffing oscillator and compares them\n    using a symmetric average nearest-neighbor distance.\n    \"\"\"\n\n    def generate_poincare_section(method, h, params):\n        \"\"\"\n        Generates a Poincaré section for the Duffing oscillator using a specified\n        integration method and step size.\n\n        Args:\n            method (str): The integration method, 'euler' or 'rk4'.\n            h (float): The time step.\n            params (dict): Dictionary of oscillator parameters.\n\n        Returns:\n            numpy.ndarray: An array of shape (300, 2) containing the (x, v)\n                           coordinates of the Poincaré section points.\n        \"\"\"\n        alpha = params['alpha']\n        beta = params['beta']\n        delta = params['delta']\n        gamma = params['gamma']\n        omega = params['omega']\n\n        def f(y):\n            \"\"\"The ODE function dy/dt = f(y) for the Duffing system.\"\"\"\n            x, v, phi = y\n            dxdt = v\n            dvdt = -delta * v - alpha * x - beta * x**3 + gamma * np.cos(phi)\n            dphidt = omega\n            return np.array([dxdt, dvdt, dphidt], dtype=np.float64)\n\n        y = np.array([0.0, 0.0, 0.0], dtype=np.float64)  # Initial state [x, v, phi]\n\n        poincare_points = []\n        num_transient = 200\n        total_points = num_transient + 300\n        \n        two_pi = 2.0 * np.pi\n\n        while len(poincare_points)  total_points:\n            y_prev = y\n            \n            if method == 'euler':\n                y = y_prev + h * f(y_prev)\n            elif method == 'rk4':\n                k1 = f(y_prev)\n                k2 = f(y_prev + 0.5 * h * k1)\n                k3 = f(y_prev + 0.5 * h * k2)\n                k4 = f(y_prev + h * k3)\n                y = y_prev + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n            phi_prev = y_prev[2]\n            phi_curr = y[2]\n\n            crossings_prev_count = np.floor(phi_prev / two_pi)\n            crossings_curr_count = np.floor(phi_curr / two_pi)\n\n            if crossings_curr_count > crossings_prev_count:\n                for k in range(int(crossings_prev_count) + 1, int(crossings_curr_count) + 1):\n                    if len(poincare_points) >= total_points:\n                        break\n                    \n                    phi_target = k * two_pi\n                    \n                    # Linear interpolation factor\n                    theta = (phi_target - phi_prev) / (phi_curr - phi_prev)\n                    \n                    # Interpolate x and v to the exact crossing time\n                    x_cross = y_prev[0] + theta * (y[0] - y_prev[0])\n                    v_cross = y_prev[1] + theta * (y[1] - y_prev[1])\n                    \n                    poincare_points.append([x_cross, v_cross])\n\n        return np.array(poincare_points[num_transient:], dtype=np.float64)\n\n    def compute_distance(set_A, set_B):\n        \"\"\"\n        Computes the symmetric average nearest-neighbor distance between two point sets.\n        \"\"\"\n        dist_matrix = cdist(set_A, set_B)\n        \n        nn_dist_A_to_B = np.min(dist_matrix, axis=1)\n        nn_dist_B_to_A = np.min(dist_matrix, axis=0)\n        \n        avg_A_to_B = np.mean(nn_dist_A_to_B)\n        avg_B_to_A = np.mean(nn_dist_B_to_A)\n        \n        return 0.5 * (avg_A_to_B + avg_B_to_A)\n\n    params = {\n        'alpha': -1.0, 'beta': 1.0, 'delta': 0.3,\n        'gamma': 0.37, 'omega': 1.2\n    }\n\n    test_cases = [\n        # Case 1: Euler h=0.02 vs RK4 h=0.02\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.02},\n        # Case 2: Euler h=0.05 vs RK4 h=0.05\n        {'method1': 'euler', 'h1': 0.05, 'method2': 'rk4', 'h2': 0.05},\n        # Case 3: RK4 h=0.02 vs RK4 h=0.01\n        {'method1': 'rk4', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.01},\n        # Case 4: Euler h=0.02 vs Euler h=0.01\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'euler', 'h2': 0.01}\n    ]\n\n    # Pre-compute all required sections to avoid redundant calculations\n    computations_to_run = set()\n    for case in test_cases:\n        computations_to_run.add((case['method1'], case['h1']))\n        computations_to_run.add((case['method2'], case['h2']))\n    \n    generated_sections = {\n        (method, h): generate_poincare_section(method, h, params)\n        for method, h in computations_to_run\n    }\n    \n    results = []\n    for case in test_cases:\n        set_A = generated_sections[(case['method1'], case['h1'])]\n        set_B = generated_sections[(case['method2'], case['h2'])]\n        \n        dist = compute_distance(set_A, set_B)\n        results.append(f\"{dist:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}