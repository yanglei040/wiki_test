{
    "hands_on_practices": [
        {
            "introduction": "This first practice lays the foundation for understanding Diffusion-Limited Aggregation (DLA). You will implement the canonical DLA model from first principles and measure its most important characteristic: the fractal dimension, $D_f$. By building the simulation for both square and hexagonal lattices, you will directly test the concept of universality, a cornerstone of statistical physics, which suggests that the large-scale properties of a system can be independent of its microscopic details . This exercise will solidify your understanding of the core DLA algorithm and the powerful mass-radius scaling relationship, $N \\propto R_g^{D_f}$.",
            "id": "2386014",
            "problem": "Write a complete, runnable program that simulates Diffusion-Limited Aggregation (DLA) for two two-dimensional lattices and estimates the fractal dimension by scaling of the radius of gyration. The objective is to model aggregation on both a square lattice and a hexagonal lattice and to compare the empirically estimated fractal dimension $D_f$ between the two. The program must run deterministically by using fixed random number seeds, and it must output a single line in the exact format specified below.\n\nFundamental base and definitions to be used:\n- Diffusion-Limited Aggregation (DLA) is a growth process in which particles perform unbiased nearest-neighbor random walks (a discrete model of Brownian motion consistent with the diffusion equation $\\partial_t \\rho = D \\nabla^2 \\rho$) until they stick to a cluster upon first contact with its boundary (adjacency to any occupied site).\n- A random walk step on a lattice chooses uniformly among the set of nearest neighbors. For the square lattice the walk has $4$ neighbors per site, and for the hexagonal lattice it has $6$ neighbors per site.\n- The radius of gyration $R_g$ of a set of $N$ points at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$ is defined by\n$$\nR_g^2 = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2,\n\\quad \\text{where} \\quad\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i.\n$$\nFor a statistically self-similar aggregate (fractal), the scaling $R_g \\propto N^{1/D_f}$ holds, so that a log-log linear regression of $\\log R_g$ versus $\\log N$ yields a slope $s$ with $D_f = 1/s$.\n- Distances and angles must be treated in a mathematically consistent embedding. For the square lattice, the Cartesian embedding is $\\mathbf{r}=(x,y)$ with integer $x$ and $y$. For the hexagonal lattice, use an axial coordinate system $(q,r)$ with nearest-neighbor directions $(1,0)$, $(-1,0)$, $(0,1)$, $(0,-1)$, $(1,-1)$, $(-1,1)$, and embed into the plane via\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\nso that Euclidean squared distance from the origin is\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\n\nSimulation rules and numerical details:\n- Initialize the aggregate with a single occupied site at the origin at $N=1$.\n- Launch each diffusing particle at a random direction on a circle of radius $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$, where $R_{\\max}^2$ is the current maximum squared Euclidean distance of any occupied site from the origin, and $\\Delta_{\\text{launch}}$ is a positive margin. Use a uniformly random angle in radians in $[0,2\\pi)$ to place the launch point, then round to the nearest lattice site (for the hexagonal lattice, perform rounding in axial coordinates consistent with the embedding; for the square lattice, round Cartesian coordinates). Angles must be treated in radians.\n- Perform an unbiased nearest-neighbor random walk until either:\n  1. The walker steps to a site whose neighbor set contains any currently occupied site. In that case, the walker sticks irreversibly at its current site and becomes part of the aggregate.\n  2. The walker wanders beyond a “kill” radius $R_{\\text{kill}} = R_{\\text{launch}} + \\Delta_{\\text{kill}}$, in which case the walker is discarded and a new walker is launched.\n- After each sticking event that increases $N$ to $N+1$, update the radius of gyration $R_g(N+1)$ using the exact definition above in the chosen embedding.\n- Estimate the fractal dimension $D_f$ by performing a least-squares linear regression of $\\log R_g(N)$ versus $\\log N$ over a range that avoids very small $N$ to reduce finite-size effects. Specifically, fit over $N \\ge N_{\\min}$ with $N_{\\min} = \\max(50, \\lfloor 0.2 N_{\\text{final}} \\rfloor)$ for $N_{\\text{final}} \\ge 100$, and $N_{\\min} = 10$ otherwise. Use natural logarithms.\n\nYour program must implement both lattice types and compute $D_f$ for each test case. The random number generator must be seeded per test case for deterministic behavior.\n\nRequired test suite (each tuple is $(\\text{lattice}, N_{\\text{final}}, \\text{seed}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$):\n- Case A: $(\\text{\"square\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- Case B: $(\\text{\"hex\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- Case C: $(\\text{\"square\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n- Case D: $(\\text{\"hex\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n\nAll distances are dimensionless lattice spacings; angles must be in radians. The outputs are real numbers (floating-point) with no units. For each test case, the program must output the estimated $D_f$ rounded to three decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[\\text{Case A}, \\text{Case B}, \\text{Case C}, \\text{Case D}]$. For example: [$1.700,1.690,1.660,1.650$].",
            "solution": "We model Diffusion-Limited Aggregation (DLA) by explicit nearest-neighbor random walks, grounding the approach in two fundamental elements. First, unbiased nearest-neighbor random walks on a lattice provide a discrete representation of Brownian motion, consistent with the diffusion equation $\\partial_t \\rho = D \\nabla^2 \\rho$. Second, fractal dimension $D_f$ of an aggregate is defined via mass-radius scaling. We avoid prescribing any lattice-specific shortcut formulas and instead derive the measurement procedure from definitions.\n\nPrinciples and derivation:\n1. Random walk dynamics and aggregation. Let $\\mathcal{S}$ denote the set of occupied sites, initially $\\mathcal{S}=\\{(0,0)\\}$. A walker is launched at Euclidean radius $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$, where $R_{\\max}^2=\\max_{\\mathbf{r}\\in\\mathcal{S}} \\|\\mathbf{r}\\|^2$. The launching direction is uniformly sampled in $[0,2\\pi)$ (radians), maintaining isotropy. For the square lattice, the position is rounded to integer Cartesian $(x,y)\\in\\mathbb{Z}^2$; for the hexagonal lattice, we use axial coordinates $(q,r)\\in\\mathbb{Z}^2$ with nearest neighbors $(1,0)$, $(-1,0)$, $(0,1)$, $(0,-1)$, $(1,-1)$, $(-1,1)$. The walk proceeds by picking a nearest neighbor uniformly at random at each step. If the walker’s current site has any neighbor in $\\mathcal{S}$, it sticks and the site is added to $\\mathcal{S}$. If it wanders beyond $R_{\\text{kill}}=R_{\\text{launch}}+\\Delta_{\\text{kill}}$, it is discarded and a new walker is launched. These rules implement growth limited by the diffusive flux to the aggregate boundary.\n\n2. Embedding and distance metrics. For the square lattice, we use $\\mathbf{r}=(x,y)$ with Euclidean squared distance $\\|\\mathbf{r}\\|^2=x^2+y^2$. For the hexagonal lattice, we embed axial coordinates $(q,r)$ as\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\nwhich yields the identity\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\nThis identity allows exact Euclidean squared distance computations from integer axial coordinates without floating-point ambiguity during the random walk. We round launch points to the nearest hex site by converting Cartesian $(x,y)$ to fractional axial $(q_f,r_f)$ via $q_f = x - y/\\sqrt{3}$ and $r_f = 2y/\\sqrt{3}$ and then applying standard cube-coordinate rounding with the constraint $x_c + y_c + z_c = 0$ to obtain integer axial $(q,r)$.\n\n3. Fractal dimension from the radius of gyration. The radius of gyration for $N$ occupied sites at $\\{\\mathbf{r}_i\\}$ is\n$$\nR_g^2(N) = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2\n= \\frac{1}{N}\\sum_{i=1}^N |\\mathbf{r}_i|^2 - \\left|\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i\\right|^2,\n$$\nwhich is exact and computationally convenient. For self-similar aggregates, the mass-radius scaling $N \\propto R^{{D_f}}$ implies $R \\propto N^{1/D_f}$ and therefore\n$$\n\\log R_g(N) = \\frac{1}{D_f}\\log N + \\text{constant}.\n$$\nThus, a least-squares fit of $\\log R_g$ versus $\\log N$ over a range avoiding small-$N$ transients yields a slope $s$ and estimate $D_f = 1/s$. To reduce finite-size and lattice artifacts, we fit over $N \\ge N_{\\min}$ with $N_{\\min}=\\max(50,\\lfloor 0.2 N_{\\text{final}}\\rfloor)$ when $N_{\\text{final}} \\ge 100$ and $N_{\\min}=10$ otherwise.\n\nAlgorithmic design:\n- Data structures: Maintain the occupied set $\\mathcal{S}$ as a hash set of lattice coordinates for $O(1)$ expected-time membership tests. Keep running sums $\\sum \\mathbf{r}_i$ and $\\sum |\\mathbf{r}_i|^2$ to update $R_g$ in $O(1)$ time at each sticking event. Track $R_{\\max}^2$ as the maximum Euclidean squared distance from the origin among occupied sites for launch radius updates.\n- Hexagonal implementation details: Use axial neighbors and exact formula $q^2 + q r + r^2$ for squared Euclidean distance during random walks for kill-radius checks. Convert only at sticking events to Cartesian $(x,y)$ for $R_g$ updates using $x=q+\\frac{1}{2}r$, $y=\\frac{\\sqrt{3}}{2}r$.\n- Determinism: Use a fixed seed per test case with an independent random number generator for reproducibility. Angles are sampled uniformly in radians in $[0,2\\pi)$.\n- Computational safeguards: Impose a generous maximum number of random-walk steps per launched walker to guarantee termination; if exceeded, discard and relaunch to avoid pathological trajectories. This does not bias results materially when the limit is set high.\n\nTest suite and output:\nWe run four cases with tuples $(\\text{lattice}, N_{\\text{final}}, \\text{seed}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$:\n- Case A: $(\\text{\"square\"}, 220, 2023, 5, 15)$.\n- Case B: $(\\text{\"hex\"}, 220, 2023, 5, 15)$.\n- Case C: $(\\text{\"square\"}, 60, 777, 5, 15)$.\n- Case D: $(\\text{\"hex\"}, 60, 777, 5, 15)$.\nFor each case, we compute $D_f$ by linear regression of $\\log R_g$ versus $\\log N$ as specified, and we round the result to three decimal places. The program prints a single line in the format [$D_A, D_B, D_C, D_D$]. Typical DLA values in two dimensions are near $D_f \\approx 1.7$; the two lattices may yield slightly different estimates due to coordination number and lattice anisotropy, but both should be in the same range at these sizes.\n\nThe entire implementation adheres to the required environment, uses only allowed libraries, and produces the specified single-line output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---------------------------\n# DLA simulation on square and hex lattices with R_g scaling\n# ---------------------------\n\n# Neighbor steps for square and hex lattices\nSQUARE_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1))\nHEX_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1))\n\nSQRT3 = np.sqrt(3.0)\nSQRT3_OVER_2 = SQRT3 / 2.0\n\ndef axial_to_cartesian(q: int, r: int) - tuple[float, float]:\n    \"\"\"\n    Map axial hex coordinates (q, r) to Cartesian coordinates (x, y).\n    x = q + r/2\n    y = (sqrt(3)/2) * r\n    \"\"\"\n    x = q + 0.5 * r\n    y = SQRT3_OVER_2 * r\n    return x, y\n\ndef hex_distance_sq_axial(q: int, r: int) - int:\n    \"\"\"\n    Exact Euclidean squared distance in the hex embedding:\n    x^2 + y^2 = q^2 + q*r + r^2\n    \"\"\"\n    return q*q + q*r + r*r\n\ndef cartesian_to_axial_round(x: float, y: float) - tuple[int, int]:\n    \"\"\"\n    Convert Cartesian (x, y) in the hex embedding to the nearest axial integer (q, r)\n    using cube-coordinate rounding. Inverse of axial_to_cartesian.\n    From axial to cart: x = q + r/2, y = (sqrt(3)/2) r.\n    Inverse (fractional axial): q_f = x - y/sqrt(3), r_f = 2y/sqrt(3).\n    \"\"\"\n    qf = x - y / SQRT3\n    rf = 2.0 * y / SQRT3\n    # Convert to cube coords (x_c, y_c, z_c) with x_c + y_c + z_c = 0\n    xf = qf\n    zf = rf\n    yf = -xf - zf\n    rx = round(xf)\n    ry = round(yf)\n    rz = round(zf)\n    dx = abs(rx - xf)\n    dy = abs(ry - yf)\n    dz = abs(rz - zf)\n    if dx  dy and dx  dz:\n        rx = -ry - rz\n    elif dy  dz:\n        ry = -rx - rz\n    else:\n        rz = -rx - ry\n    q = int(rx)\n    r = int(rz)\n    return q, r\n\ndef simulate_dla(lattice: str, N_final: int, seed: int, launch_margin: float, kill_margin: float) - float:\n    \"\"\"\n    Simulate DLA on the specified lattice ('square' or 'hex') until N_final occupied sites (including the seed),\n    return the estimated fractal dimension D_f by fitting log(R_g) vs log(N) with N = N_min (see problem statement).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    if lattice == \"square\":\n        neighbors = SQUARE_NEIGHBORS\n        # Distance from origin squared\n        dist2 = lambda pos: pos[0]*pos[0] + pos[1]*pos[1]\n        # Map lattice coord to cartesian\n        to_cart = lambda pos: (float(pos[0]), float(pos[1]))\n        # Round launch on circle to nearest lattice site\n        def launch_from_radius(R_launch: float) - tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return int(round(x)), int(round(y))\n    elif lattice == \"hex\":\n        neighbors = HEX_NEIGHBORS\n        dist2 = lambda pos: hex_distance_sq_axial(pos[0], pos[1])\n        to_cart = lambda pos: axial_to_cartesian(pos[0], pos[1])\n        def launch_from_radius(R_launch: float) - tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return cartesian_to_axial_round(x, y)\n    else:\n        raise ValueError(\"Unknown lattice type\")\n\n    occupied = set()\n    origin = (0, 0)\n    occupied.add(origin)\n\n    # Running sums for R_g computation\n    sum_x = 0.0\n    sum_y = 0.0\n    sum_sq = 0.0\n    # R_g at N=1 is zero\n    Rg_by_N = [(1, 0.0)]\n\n    # Track maximum squared radius\n    Rmax2 = 0.0  # includes the origin which is 0\n\n    # Simulation parameters\n    max_steps_per_walker = 10000  # safety limit to avoid very long walks\n\n    # Main aggregation loop\n    while len(occupied)  N_final:\n        # Set launch and kill radii\n        R_launch = np.sqrt(Rmax2) + float(launch_margin)\n        R_kill = R_launch + float(kill_margin)\n        R_kill2 = R_kill * R_kill\n\n        # Launch a new walker\n        pos = launch_from_radius(R_launch)\n\n        steps = 0\n        while True:\n            steps += 1\n            if steps  max_steps_per_walker:\n                # Discard and relaunch\n                break\n\n            # Propose a random nearest-neighbor step\n            # Choose index more cheaply than rng.choice on small tuple\n            di = int(rng.integers(0, len(neighbors)))\n            dx, dy = neighbors[di]\n            new_pos = (pos[0] + dx, pos[1] + dy)\n\n            # Do not move into already occupied site (reflect by rejecting step)\n            if new_pos in occupied:\n                continue\n\n            pos = new_pos\n\n            # Kill if beyond kill radius\n            if dist2(pos)  R_kill2:\n                break\n\n            # Stick if adjacent to occupied site\n            hit = False\n            # Test adjacency\n            for ndx, ndy in neighbors:\n                nb = (pos[0] + ndx, pos[1] + ndy)\n                if nb in occupied:\n                    hit = True\n                    break\n            if hit:\n                # Stick the walker\n                occupied.add(pos)\n                # Update R_g running sums using Cartesian embedding\n                x, y = to_cart(pos)\n                sum_x += x\n                sum_y += y\n                sum_sq += x*x + y*y\n                N_now = len(occupied)\n                # Update Rmax2\n                d2 = x*x + y*y\n                if d2  Rmax2:\n                    Rmax2 = d2\n                # Compute R_g from definition: R_g^2 = (sum |r|^2)/N - |sum r|^2 / N^2\n                cm2 = (sum_x*sum_x + sum_y*sum_y) / (N_now * N_now)\n                Rg2 = (sum_sq / N_now) - cm2\n                if Rg2  0.0:\n                    Rg2 = 0.0\n                Rg = float(np.sqrt(Rg2))\n                Rg_by_N.append((N_now, Rg))\n                break  # proceed to next walker\n\n    # Prepare data for fitting log(R_g) vs log(N)\n    Ns = np.array([n for n, _ in Rg_by_N], dtype=float)\n    Rgs = np.array([rg for _, rg in Rg_by_N], dtype=float)\n\n    # Select fitting range\n    if N_final = 100:\n        N_min = max(50, int(np.floor(0.2 * N_final)))\n    else:\n        N_min = 10\n    mask = Ns = N_min\n    # Ensure we have sufficient points; if not, relax to use all N = 2\n    if not np.any(mask):\n        mask = Ns = 2.0\n\n    # Avoid log of zero; filter R_g  0 as well\n    mask = mask  (Rgs  0.0)\n\n    # In degenerate cases with too few points, fall back to pseudo-estimate to avoid crash\n    if np.count_nonzero(mask)  2:\n        # Minimal fallback: return NaN-like but still numeric; choose 0.0 as indicator\n        return float(\"nan\")\n\n    logN = np.log(Ns[mask])\n    logRg = np.log(Rgs[mask])\n\n    # Linear regression: logRg = m * logN + b\n    m, b = np.polyfit(logN, logRg, 1)\n    if m == 0.0:\n        return float(\"nan\")\n    D_est = 1.0 / m\n    return float(D_est)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lattice, N_final, seed, launch_margin, kill_margin)\n    test_cases = [\n        (\"square\", 220, 2023, 5, 15),  # Case A\n        (\"hex\",    220, 2023, 5, 15),  # Case B\n        (\"square\",  60,  777, 5, 15),  # Case C\n        (\"hex\",     60,  777, 5, 15),  # Case D\n    ]\n\n    results = []\n    for lattice, N_final, seed, lmargin, kmargin in test_cases:\n        D_est = simulate_dla(lattice, N_final, seed, lmargin, kmargin)\n        # Round to three decimal places as required\n        if np.isnan(D_est):\n            # In the unlikely event of NaN, output 0.000 to maintain format\n            results.append(\"0.000\")\n        else:\n            results.append(f\"{D_est:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Standard DLA models generate highly branched, tenuous structures that may not accurately represent all natural phenomena. This exercise introduces a \"noise reduction\" mechanism, a classic and powerful modification that allows you to generate more compact aggregates. The core idea is to alter the sticking rule: instead of adhering on first contact, a potential growth site must be visited multiple times by diffusing particles before it solidifies . This practice demonstrates how a simple change in local rules can dramatically alter global morphology, allowing you to explore the fascinating crossover from fractal to compact growth by tuning a single parameter.",
            "id": "2386048",
            "problem": "Consider two-dimensional Diffusion-Limited Aggregation (DLA) on the integer lattice, where a single immobile seed occupies the origin at time $t=0$. Particles are released one at a time from a launching circle and perform unbiased nearest-neighbor random walks in discrete time. A noise-reduction rule is imposed: a particle does not immediately stick upon first landing adjacent to the cluster. Instead, each empty lattice site maintains an integer counter of how many times a random walker has landed there while that site has at least one nearest-neighbor already occupied. A site becomes permanently occupied only when its counter reaches a prescribed positive integer threshold $m$. The objective is to generate clusters for different $m$ and estimate the fractal dimension $D_f(m)$ via mass–radius scaling.\n\nModel specification:\n- Lattice: the set of integer pairs $(x,y)\\in\\mathbb{Z}^2$.\n- Seed: at time $t=0$, the occupied set is $\\{(0,0)\\}$.\n- Random walk dynamics: a walker at $(x,y)$ moves in one discrete step to $(x\\pm 1,y)$ or $(x,y\\pm 1)$ with equal probability $1/4$ per step.\n- Launch rule: let $R(t)$ denote the current cluster radius, defined as the maximum Euclidean distance $\\sqrt{x^2+y^2}$ over all occupied sites at time $t$. Define a margin $r_{\\mathrm{margin}}=5$ and a minimum launch radius $r_{\\min}=10$. Each new walker is launched from a uniformly random angle (in radians) on the circle of radius $r_{\\mathrm{launch}}=\\max\\{R(t)+r_{\\mathrm{margin}},\\,r_{\\min}\\}$, at the nearest lattice site to that circle. Angles must be sampled uniformly in $[0,2\\pi)$.\n- Kill rule: define a kill radius $r_{\\mathrm{kill}}=r_{\\mathrm{launch}}+3\\,r_{\\mathrm{margin}}$. If a walker’s Euclidean distance from the origin ever exceeds $r_{\\mathrm{kill}}$, that walker is discarded and a new walker is launched as above.\n- Exclusion: a proposed step that would place a walker on an occupied site is rejected and immediately resampled; equivalently, the walker remains at its current lattice site for that time step and draws a new direction on the next step.\n- Landing event and noise reduction: a landing event occurs whenever a walker is at an empty lattice site $(x,y)$ such that at least one of its four nearest neighbors is occupied. Each empty site $(x,y)$ maintains an integer counter $c(x,y)$ that starts at $0$ and is incremented by $1$ on each landing event at $(x,y)$. When $c(x,y)$ first reaches the threshold $m$, the site $(x,y)$ becomes permanently occupied, $c(x,y)$ is no longer needed for that site, and the current walker is removed. The cluster radius $R(t)$ is updated accordingly.\n- Termination: continue launching walkers and applying the above rules until the occupied set has cardinality exactly $N$.\n\nFractal dimension estimation:\n- For a completed cluster with occupied set $\\mathcal{C}$ of size $|\\mathcal{C}|=N$, define the cluster radius $R_{\\max}=\\max\\{\\sqrt{x^2+y^2}:(x,y)\\in\\mathcal{C}\\}$ and the mass function $M(R)=|\\{(x,y)\\in\\mathcal{C}:\\sqrt{x^2+y^2}\\le R\\}|$.\n- Define fitting window parameters $\\alpha=0.2$ and $\\beta=0.9$. Let $R_{\\min}=\\lceil\\alpha R_{\\max}\\rceil$ and $R_{\\mathrm{fit}}=\\lfloor\\beta R_{\\max}\\rfloor$. Consider the set of integer radii $\\{R_i\\}_{i=1}^K=\\{R\\in\\mathbb{Z}: R_{\\min}\\le R\\le R_{\\mathrm{fit}},\\,R\\ge 1\\}$, ordered increasingly, where $K$ is the number of such radii. For each $R_i$, compute $M(R_i)$. Estimate $D_f$ as the slope of the least-squares best-fit line to the points $\\{(\\log R_i,\\log M(R_i))\\}_{i=1}^K$.\n- All logarithms are natural logarithms.\n\nTest suite and required outputs:\n- Use the following test cases, each specified by the tuple $(m,N,\\text{seed})$, where “seed” initializes the random number generator to ensure reproducibility:\n  1. $(m=1,\\,N=900,\\,\\text{seed}=1337)$\n  2. $(m=3,\\,N=700,\\,\\text{seed}=2021)$\n  3. $(m=5,\\,N=600,\\,\\text{seed}=31415)$\n- For each case, simulate the cluster according to the model, estimate $D_f$ as above, and round the result to three decimal places.\n- Final output format: Your program should produce a single line of output containing the three rounded $D_f$ estimates as a comma-separated list enclosed in square brackets (for example, $[1.700,1.750,1.780]$). No additional text or lines should be printed. Angles must be in radians. All quantities are dimensionless, so no physical unit conversion is required.",
            "solution": "This problem requires simulating a noise-reduced variant of Diffusion-Limited Aggregation (DLA) and then estimating the resulting cluster's fractal dimension, $D_f$. The solution involves a two-stage process: a stochastic simulation of the growth followed by a data analysis step using linear regression on the mass-radius relationship.\n\n**Simulation Algorithm**\n\nThe core of the simulation is an iterative process that adds particles one by one to a growing cluster on a two-dimensional integer lattice, $\\mathbb{Z}^2$. The simulation is designed for a sparse lattice, as it is conceptually infinite. The key data structures are:\n1.  **`occupied_sites`**: A hash set storing the integer coordinates of the sites forming the cluster. This allows for efficient $O(1)$ average-time checking of whether a site is occupied.\n2.  **`perimeter_sites`**: A hash set containing the coordinates of all empty sites that are nearest neighbors to any occupied site. This set defines the growth boundary of the cluster.\n3.  **`landing_counters`**: A dictionary (or hash map) that maps each site in `perimeter_sites` to its integer landing count.\n\nThe simulation loop for adding a single particle proceeds as follows:\n1.  **Launch**: A walker particle is created. Its starting position is determined by randomly sampling an angle on a launch circle whose radius is slightly larger than the current maximum radius of the cluster. The particle is placed at the nearest integer lattice site.\n2.  **Random Walk**: The walker executes an unbiased random walk. At each step, it moves to one of the four nearest-neighbor sites, chosen with equal probability. The walk is subject to several conditions:\n    *   **Kill Condition**: If the walker strays too far from the cluster (beyond a predefined \"kill\" radius), it is discarded, and a new walker is launched.\n    *   **Exclusion**: The walker cannot move onto a site that is already part of the cluster.\n    *   **Landing Event**: If the walker lands on a site in the `perimeter_sites` set, its visit is recorded by incrementing the site's counter in `landing_counters`.\n    *   **Sticking**: If a landing event causes a perimeter site's counter to reach the threshold $m$, that site becomes permanently occupied. It is added to `occupied_sites`, removed from `perimeter_sites`, and its counter is deleted. The walker's journey ends, and the simulation proceeds to add the next particle.\n\nThis process is repeated until the cluster contains the target number of particles, $N$.\n\n**Fractal Dimension Estimation**\n\nOnce the final cluster of size $N$ is generated, its fractal dimension is estimated from the scaling law $M(R) \\propto R^{D_f}$, where $M(R)$ is the mass (number of particles) within a radius $R$. This relationship implies a linear correlation in a log-log plot: $\\log M(R) = D_f \\log R + \\text{constant}$.\n\n1.  **Data Collection**: The mass function $M(R)$ is measured for a range of integer radii $R$. To minimize finite-size and core-region effects, the fit is performed over an intermediate range of radii, from $R_{\\min} = \\lceil 0.2 R_{\\max} \\rceil$ to $R_{\\mathrm{fit}} = \\lfloor 0.9 R_{\\max} \\rfloor$, where $R_{\\max}$ is the maximum radius of the cluster. For each integer $R$ in this window, we compute the number of particles $M(R)$ whose distance from the origin is less than or equal to $R$.\n2.  **Linear Regression**: We perform a least-squares linear regression on the data points $(\\log R, \\log M(R))$. The slope of the resulting best-fit line is our estimate for the fractal dimension, $D_f$.\n\nThe entire procedure is encapsulated in a Python script using the `numpy` library. Seeding the random number generator ensures that the stochastic simulation is reproducible for each test case. As the noise-reduction threshold $m$ increases, we expect the cluster to become more compact, leading to a higher estimated fractal dimension, approaching the Euclidean dimension of 2.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_dla_and_get_df(m, N, seed):\n    \"\"\"\n    Simulates a noise-reduced DLA cluster and calculates its fractal dimension.\n\n    Args:\n        m (int): The noise reduction threshold.\n        N (int): The target number of particles in the cluster.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated fractal dimension D_f.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # --- Data Structures ---\n    # The set of occupied lattice sites\n    occupied_sites = {(0, 0)}\n    # The set of empty sites adjacent to the cluster\n    perimeter_sites = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n    # Counters for the number of landings on perimeter sites\n    landing_counters = {}\n    \n    current_R_sq = 0.0\n\n    # --- Model Parameters ---\n    R_MARGIN = 5\n    R_MIN_LAUNCH = 10\n    MOVES = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=np.int32)\n\n    # --- Main Simulation Loop ---\n    # Grow the cluster until it reaches size N\n    while len(occupied_sites)  N:\n        # --- 1. Set up for a new walker ---\n        current_R = np.sqrt(current_R_sq)\n        r_launch = max(current_R + R_MARGIN, R_MIN_LAUNCH)\n        r_kill_sq = (r_launch + 3 * R_MARGIN)**2\n\n        # Launch walker from a random position on the launch circle\n        while True:\n            angle = rng.uniform(0, 2 * np.pi)\n            x_c = r_launch * np.cos(angle)\n            y_c = r_launch * np.sin(angle)\n            walker_pos = (int(round(x_c)), int(round(y_c)))\n            if walker_pos not in occupied_sites:\n                break\n        \n        # --- 2. Random Walk Loop for the current walker ---\n        while True:\n            # Check kill condition\n            if walker_pos[0]**2 + walker_pos[1]**2  r_kill_sq:\n                break  # Walker is killed, launch a new one\n\n            # Check for landing event (walker is on the cluster perimeter)\n            if walker_pos in perimeter_sites:\n                landing_counters[walker_pos] = landing_counters.get(walker_pos, 0) + 1\n                \n                # Check for sticking condition\n                if landing_counters[walker_pos] = m:\n                    # Particle sticks!\n                    new_site = walker_pos\n                    occupied_sites.add(new_site)\n\n                    # Update cluster max radius\n                    current_R_sq = max(current_R_sq, new_site[0]**2 + new_site[1]**2)\n\n                    # Update perimeter and counters\n                    perimeter_sites.remove(new_site)\n                    if new_site in landing_counters:\n                        del landing_counters[new_site]\n\n                    for dx, dy in MOVES:\n                        neighbor = (new_site[0] + dx, new_site[1] + dy)\n                        if neighbor not in occupied_sites:\n                            perimeter_sites.add(neighbor)\n                    \n                    break # Walker has stuck, end its walk\n\n            # Perform one step of the random walk\n            move = MOVES[rng.integers(4)]\n            next_pos = (walker_pos[0] + move[0], walker_pos[1] + move[1])\n\n            # Exclusion rule: cannot move into an occupied site\n            if next_pos not in occupied_sites:\n                walker_pos = next_pos\n            # If next_pos is occupied, walker stays put for this time step\n\n    # --- 3. Fractal Dimension Estimation ---\n    ALPHA = 0.2\n    BETA = 0.9\n\n    R_max = np.sqrt(current_R_sq)\n    \n    R_min_fit = int(np.ceil(ALPHA * R_max))\n    R_fit = int(np.floor(BETA * R_max))\n\n    if R_min_fit  R_fit or R_fit  1:\n        return np.nan # Not enough range for fitting\n\n    radii_for_fit = list(range(max(1, R_min_fit), R_fit + 1))\n    if not radii_for_fit:\n      return np.nan\n\n    log_R_values = []\n    log_M_values = []\n    \n    # Pre-calculate squared distances of all particles from origin\n    dist_sq_array = np.array([x**2 + y**2 for x, y in occupied_sites])\n    \n    for R_i in radii_for_fit:\n        R_i_sq = R_i**2\n        mass = np.sum(dist_sq_array = R_i_sq)\n        if mass  0:\n            log_R_values.append(np.log(R_i))\n            log_M_values.append(np.log(mass))\n\n    if len(log_R_values)  2:\n        return np.nan # Not enough points for a linear regression\n\n    # Perform least-squares fit: log(M) = D_f * log(R) + C\n    # np.polyfit returns [slope, intercept]\n    slope, _ = np.polyfit(log_R_values, log_M_values, 1)\n    D_f = slope\n    \n    return D_f\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 900, 1337),\n        (3, 700, 2021),\n        (5, 600, 31415),\n    ]\n\n    results = []\n    for m, N, seed in test_cases:\n        df = simulate_dla_and_get_df(m, N, seed)\n        # Round result to three decimal places\n        results.append(f\"{df:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Building on the theme of creating more realistic structures, this final practice explores surface relaxation, an alternative mechanism for producing dense aggregates. Motivated by physical processes like annealing or surface tension, this model allows a newly-attached particle to migrate a short distance to find a more energetically favorable position, defined by having more neighbors. This exercise will challenge you to implement a search algorithm for this optimal site and introduce you to new metrics, such as the mean coordination number, for quantifying a cluster's compactness . Comparing the results from this model with the noise-reduction method provides a richer perspective on how different microscopic dynamics can shape macroscopic form.",
            "id": "2386015",
            "problem": "You will implement a lattice model of diffusion-limited aggregation (DLA) with a surface relaxation mechanism. The purpose is to connect the discrete random walk model of diffusion to aggregation dynamics and then to a physically motivated restructuring rule that favors locally higher coordination. The fundamental base consists of the following facts: (i) on a sufficiently fine lattice, an unbiased discrete-time random walk approximates Brownian motion, which models diffusion governed by Fick’s laws; (ii) DLA is modeled by launching random walkers that adhere irreversibly upon first encounter with the cluster boundary; (iii) local surface relaxation is motivated by the tendency of newly attached particles to seek configurations with greater local coordination.\n\nModel description. Consider the infinite square lattice $\\mathbb{Z}^{2}$. Initialize the cluster as the occupied set $\\mathcal{C}$ containing a single seed at the origin $(0,0)$. At all times, the cluster is a set of lattice sites. A single random walker is launched from a circle of radius $R_{\\text{launch}}$ centered at the origin, where $R_{\\text{launch}} = R_{\\text{cluster}} + m_{\\text{launch}}$, $R_{\\text{cluster}}$ is the current maximum Euclidean distance of any occupied site to the origin, and $m_{\\text{launch}}$ is a fixed integer margin. The launch point is sampled by choosing a uniform angle $\\theta \\in [0,2\\pi)$ (in radians) and placing the walker at the nearest lattice point $\\big(\\lfloor R_{\\text{launch}}\\cos\\theta \\rceil,\\lfloor R_{\\text{launch}}\\sin\\theta \\rceil\\big)$. The walker then executes an unbiased discrete random walk on $\\mathbb{Z}^{2}$ with equal probability $1/4$ to step to any of its $4$-neighbors at each step. If the walker’s Euclidean distance from the origin exceeds a kill radius $R_{\\text{kill}} = R_{\\text{cluster}} + m_{\\text{kill}}$, the walker is discarded and a new walker is launched as above.\n\nAttachment rule. When the walker occupies a site $\\mathbf{x} \\in \\mathbb{Z}^{2}$ such that at least one of its $4$-neighbors is in $\\mathcal{C}$, define $\\mathbf{x}$ as the nascent attachment site. Let $d_{\\text{relax}}$ be a nonnegative integer. Define the candidate set $\\mathcal{S}$ as all empty lattice sites $\\mathbf{y}$ with Chebyshev distance $\\|\\mathbf{y}-\\mathbf{x}\\|_{\\infty} \\le d_{\\text{relax}}$ such that $\\mathbf{y}$ has at least one occupied $4$-neighbor (equivalently, it lies on the perimeter of $\\mathcal{C}$). For each candidate $\\mathbf{y}$, define its coordination number $z(\\mathbf{y})$ as the number of occupied $4$-neighbors of $\\mathbf{y}$. The surface relaxation mechanism places the new particle at the $\\mathbf{y} \\in \\mathcal{S}$ that maximizes $z(\\mathbf{y})$. To ensure determinism, in the event of ties, choose the $\\mathbf{y}$ with minimum squared Euclidean distance $\\|\\mathbf{y}-\\mathbf{x}\\|_{2}^{2}$ to the nascent site, and if still tied, choose the lexicographically smallest $\\mathbf{y}$ by $(y\\text{-coordinate}, x\\text{-coordinate})$. Add the chosen $\\mathbf{y}$ to $\\mathcal{C}$ and update $R_{\\text{cluster}}$.\n\nMetrics. After aggregating $N$ particles (so that $|\\mathcal{C}| = N+1$ including the seed), compute:\n- The mean coordination number $\\bar{z}$, defined as the average of $z(\\mathbf{c})$ over all occupied sites $\\mathbf{c} \\in \\mathcal{C}$, where $z(\\mathbf{c})$ counts the number of occupied $4$-neighbors of $\\mathbf{c}$. This is a dimensionless quantity and must be reported rounded to $3$ decimal places.\n- The radius of gyration $R_{g}$ in lattice units, defined by\n$$\nR_{g} = \\sqrt{\\frac{1}{|\\mathcal{C}|}\\sum_{\\mathbf{c}\\in \\mathcal{C}} \\|\\mathbf{c} - \\mathbf{r}_{\\text{cm}}\\|_{2}^{2}}, \\quad \\mathbf{r}_{\\text{cm}} = \\frac{1}{|\\mathcal{C}|}\\sum_{\\mathbf{c}\\in \\mathcal{C}} \\mathbf{c},\n$$\nwhere $\\mathbf{r}_{\\text{cm}}$ is the center of mass of the occupied sites. Express $R_{g}$ in lattice units and round to $3$ decimal places.\n\nTest suite. Use the following three test cases on the same infinite lattice model, with the specified parameters and a fixed pseudo-random number generator seed for reproducibility:\n- Case A (baseline DLA without relaxation): $N=200$, $d_{\\text{relax}}=0$, $m_{\\text{launch}}=5$, $m_{\\text{kill}}=15$, seed $s=12345$.\n- Case B (mild relaxation): $N=200$, $d_{\\text{relax}}=1$, $m_{\\text{launch}}=5$, $m_{\\text{kill}}=15$, seed $s=12345$.\n- Case C (stronger relaxation): $N=200$, $d_{\\text{relax}}=2$, $m_{\\text{launch}}=5$, $m_{\\text{kill}}=15$, seed $s=12345$.\n\nAngle unit requirement. Any angles used for launch position sampling must be in radians.\n\nFinal output format. Your program must produce a single line of output containing a list of the results for the three cases as a comma-separated list enclosed in square brackets. Each case’s result must be a two-element list of the form $[\\bar{z}, R_{g}]$ with both entries rounded to $3$ decimal places as specified above. For example, the overall format must be\n\"[[zA,RgA],[zB,RgB],[zC,RgC]]\"\nwith no additional text. All radii are in lattice units, and all floating-point results must be rounded to $3$ decimal places.",
            "solution": "This problem implements a Diffusion-Limited Aggregation (DLA) model with an added surface relaxation mechanism. This mechanism allows a newly attached particle to migrate locally to a more stable position, mimicking physical processes like annealing. The solution involves a stochastic simulation of cluster growth, followed by the calculation of key structural metrics.\n\n**Simulation Algorithm**\n\nThe simulation proceeds by iteratively adding $N$ particles to a cluster, which starts as a single seed at the origin on a 2D square lattice. The cluster, $\\mathcal{C}$, is stored as a hash set of occupied integer coordinates for efficient lookup.\n\nFor each particle to be added:\n1.  **Walker Launch**: A random walker is launched from a circle with radius $R_{\\text{launch}}$, which is dynamically adjusted to be a fixed margin beyond the cluster's current maximum radius. The walker is placed at the nearest lattice site to a randomly chosen point on this circle.\n2.  **Random Walk**: The walker performs an unbiased random walk, moving to one of its four nearest neighbors at each step. The walk is terminated if the walker strays beyond a larger \"kill\" radius, at which point it is discarded and a new walker is launched.\n3.  **Contact and Relaxation**: The crucial part of the model occurs when the walker lands on a site, $\\mathbf{x}$, that is adjacent to the cluster. This \"nascent attachment site\" triggers the surface relaxation process:\n    a.  **Candidate Search**: A search is performed for all empty perimeter sites, $\\mathbf{y}$, within a square neighborhood of size $(2d_{\\text{relax}}+1) \\times (2d_{\\text{relax}}+1)$ centered on $\\mathbf{x}$. This forms the candidate set $\\mathcal{S}$.\n    b.  **Optimal Site Selection**: The particle's final position is chosen from $\\mathcal{S}$ by finding the site that maximizes local stability. This is done via a deterministic, hierarchical sorting process. We select the candidate site that:\n        i.  Maximizes the coordination number $z$ (the number of occupied neighbors).\n        ii.  For sites with the same maximal $z$, minimizes the squared Euclidean distance to the nascent site $\\mathbf{x}$.\n        iii. For sites still tied, is lexicographically smallest (by y-then-x coordinate).\n    c.  **Attachment**: The uniquely identified optimal site is added to the cluster $\\mathcal{C}$, and the simulation proceeds to the next particle.\n\n**Metrics Calculation**\n\nAfter the cluster has grown to its final size of $N+1$ particles, two metrics are calculated to quantify its structure:\n1.  **Mean Coordination Number ($\\bar{z}$)**: This metric measures the average \"connectedness\" of the particles. It is computed by summing the coordination numbers of every particle in the final cluster and dividing by the total number of particles. A higher $\\bar{z}$ indicates a more compact, less dendritic structure.\n2.  **Radius of Gyration ($R_g$)**: This is a measure of the cluster's overall spatial extent. It is calculated as the root-mean-square distance of the particles from the cluster's center of mass. A smaller $R_g$ for a given number of particles also indicates a more compact structure.\n\nThis entire procedure is implemented for three cases with varying relaxation distances ($d_{\\text{relax}}=0, 1, 2$). Using the same random seed ensures that the observed differences in $\\bar{z}$ and $R_g$ are attributable solely to the effect of the relaxation parameter. As $d_{\\text{relax}}$ increases, we expect to see an increase in $\\bar{z}$ and a corresponding decrease in $R_g$, reflecting the transition from a fractal DLA structure towards a denser, more compact aggregate.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, d_relax, m_launch, m_kill, seed):\n    \"\"\"\n    Runs a single DLA simulation with surface relaxation.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    cluster = {(0, 0)}\n    \n    num_particles_to_add = N\n    \n    # Pre-define the 4-neighbor relative coordinates\n    NEIGHBOR_DELTAS = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]])\n\n    for _ in range(num_particles_to_add):\n        # Update radii based on current cluster state\n        coords = np.array(list(cluster))\n        r_cluster_sq = np.max(np.sum(coords**2, axis=1))\n        r_cluster = np.sqrt(r_cluster_sq)\n        \n        r_launch = r_cluster + m_launch\n        r_kill_sq = (r_cluster + m_kill)**2\n\n        attached = False\n        while not attached:\n            # Launch a new walker\n            theta = rng.uniform(0, 2 * np.pi)\n            launch_pos_float = np.array([r_launch * np.cos(theta), r_launch * np.sin(theta)])\n            walker_pos = tuple(np.round(launch_pos_float).astype(int))\n\n            # Random walk loop for the current walker\n            while True:\n                # Check kill condition\n                if walker_pos[0]**2 + walker_pos[1]**2  r_kill_sq:\n                    break  # Walker is killed, launch a new one\n\n                # Check for contact (nascent attachment)\n                neighbors = [(walker_pos[0] + dx, walker_pos[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n                if any(n in cluster for n in neighbors):\n                    nascent_site = walker_pos\n                    \n                    # ATTACHMENT AND RELAXATION LOGIC\n                    \n                    # 1. Construct candidate set\n                    candidates = []\n                    x_n, y_n = nascent_site\n                    for dy in range(-d_relax, d_relax + 1):\n                        for dx in range(-d_relax, d_relax + 1):\n                            cand_site = (x_n + dx, y_n + dy)\n                            if cand_site in cluster:\n                                continue\n                            \n                            cand_neighbors = [(cand_site[0] + d_dx, cand_site[1] + d_dy) for d_dx, d_dy in NEIGHBOR_DELTAS]\n                            if any(n in cluster for n in cand_neighbors):\n                                candidates.append(cand_site)\n                    \n                    # 2. Find the best candidate using hierarchical sorting\n                    def get_sort_key(cand):\n                        # Calculate coordination number z\n                        cand_neighbors = [(cand[0] + dx, cand[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n                        z = sum(1 for n in cand_neighbors if n in cluster)\n                        \n                        # Calculate squared Euclidean distance to nascent site\n                        d2 = (cand[0] - nascent_site[0])**2 + (cand[1] - nascent_site[1])**2\n                        \n                        # Return tuple for sorting: max z, min d2, min y, min x\n                        return (-z, d2, cand[1], cand[0])\n\n                    candidates.sort(key=get_sort_key)\n                    best_site = candidates[0]\n                    \n                    cluster.add(best_site)\n                    attached = True\n                    break # Exit walk loop, then the launch loop for this particle\n\n                # Move walker to a random neighbor\n                move = NEIGHBOR_DELTAS[rng.integers(0, 4)]\n                walker_pos = (walker_pos[0] + move[0], walker_pos[1] + move[1])\n    \n    # Simulation complete, calculate metrics\n    final_coords = np.array(list(cluster))\n    num_total_particles = len(final_coords)\n    \n    # Metric 1: Mean coordination number\n    total_z = 0\n    for c in cluster:\n        c_neighbors = [(c[0] + dx, c[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n        total_z += sum(1 for n in c_neighbors if n in cluster)\n    mean_z = total_z / num_total_particles\n    \n    # Metric 2: Radius of gyration\n    r_cm = np.mean(final_coords, axis=0)\n    sq_dists_from_cm = np.sum((final_coords - r_cm)**2, axis=1)\n    r_g = np.sqrt(np.mean(sq_dists_from_cm))\n    \n    return [round(mean_z, 3), round(r_g, 3)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, d_relax, m_launch, m_kill, seed)\n        (200, 0, 5, 15, 12345),  # Case A\n        (200, 1, 5, 15, 12345),  # Case B\n        (200, 2, 5, 15, 12345),  # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, d_relax, m_launch, m_kill, seed = case\n        result = run_simulation(N, d_relax, m_launch, m_kill, seed)\n        results.append(result)\n\n    # Format the final output string exactly as specified, without spaces in the inner lists.\n    formatted_results = [f'[{z},{Rg}]' for z, Rg in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}