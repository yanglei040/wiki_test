{
    "hands_on_practices": [
        {
            "introduction": "这项练习提供了应用Green-Kubo关系的基石性动手实践。你将直接通过对微观时间相关函数进行时间积分，来计算宏观输运系数——自扩散系数。这项实践旨在巩固粒子速度的微观涨落与宏观扩散现象这一涌现属性之间的关键联系 。",
            "id": "2447051",
            "problem": "您将通过推导和评估一个基于时间相关函数的表达式，来确定轻间隙原子（例如氢）在重金属晶格（例如钯）中的自扩散系数。从连接粒子位移、速度和统计平稳性的第一性原理出发，推导出一个用单分量速度自相关函数表示自扩散系数的关系式。您不得假设任何预先给定的输运公式；需从均方位移和平稳时间相关的定义出发构建该关系式。然后，实现一个数值程序，为温度为 $T$、质量为 $m$ 的粒子，在三种人工合成但物理上合理的单分量速度自相关函数下评估此关系式。每种情况都定义了单分量速度自相关函数 $C(t)$，使得 $C(0) = \\langle v_x^2 \\rangle$ 由能量均分定理确定。您的实现必须使用一个均匀的时间网格，并在一个为控制截断误差而选择的有限域上使用收敛的数值积分方法。\n\n您可以使用的基本依据：\n- 基于均方位移的长时间极限的自扩散系数定义。\n- 位置和速度之间作为时间导数的关系。\n- 平稳随机过程和时间相关函数的性质。\n- 热平衡中单个速度分量的能量均分。\n\n物理模型和参数：\n- 将重晶格视为一个热浴，它使轻间隙原子的单分量速度成为一个具有指定自相关函数 $C(t)$ 的平稳随机过程。\n- 使用温度 $T = 300$ K 和氢的质量 $m = 1.6735575 \\times 10^{-27}$ kg。\n- 玻尔兹曼常数为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ J/K。\n- 根据能量均分定理，$C(0) = \\langle v_x^2 \\rangle = k_{\\mathrm{B}} T / m$。\n\n测试套件（$C(t)$ 的三种情况）：\n- 情况 A（单指数弛豫）：$C(t) = C_0 \\exp(-t/\\tau)$，其中 $C_0 = k_{\\mathrm{B}} T / m$ 且 $\\tau = 0.04$ ps。将皮秒解释为秒；即 $1$ ps $= 10^{-12}$ s。\n- 情况 B（用于模拟多时间尺度动力学的双指数弛豫）：$C(t) = C_0 \\left[a \\exp(-t/\\tau_1) + (1-a)\\exp(-t/\\tau_2)\\right]$，其中 $C_0 = k_{\\mathrm{B}} T / m$，$a = 0.7$，$\\tau_1 = 0.02$ ps，且 $\\tau_2 = 0.2$ ps。\n- 情况 C（用于模拟与晶格振动耦合的阻尼振荡相关）：$C(t) = C_0 \\exp(-\\gamma t)\\cos(\\omega t)$，其中 $C_0 = k_{\\mathrm{B}} T / m$，$\\gamma = 1/(0.05$ ps$)$，单位为 s$^{-1}$，且 $\\omega = 2\\pi \\times 5 \\times 10^{12}$ rad/s。\n\n数值要求：\n- 构建一个从 $t=0$ 到 $t=t_{\\max}$ 的均匀时间网格，选择 $t_{\\max}$ 使得对于每种情况，超出 $t_{\\max}$ 的被忽略的尾部都可忽略不计。一个科学上合理的选择是 $t_{\\max} \\geq 10$ 倍于存在的最大衰减时间（例如 $\\max\\{\\tau,\\tau_1,\\tau_2,1/\\gamma\\}$），并且对于振荡相关，还需包含几个振荡周期。时间步长 $\\Delta t$ 必须能够解析存在的最快尺度（例如，衰减时间和振荡周期中的最小值）。\n- 使用均匀网格上的收敛求积法（例如，复合辛普森法则或具有足够分辨率的梯形法则），数值计算所推导表达式的时间积分。\n- 所有计算必须在国际单位制（SI）中进行。最终的扩散系数以 m$^2$/s 表示。\n\n您必须生成的内容：\n1. 一个简要的推导（在您自己的开发过程中内部完成；不要打印出来），导出一个将自扩散系数与单分量速度自相关函数联系起来的可计算积分表达式。\n2. 一个程序，该程序：\n   - 实现上述三种 $C(t)$ 的定义，并使用给定的数值参数。\n   - 按照规定选择合适的时间网格，并为每种情况数值计算得出自扩散系数的积分。\n   - 分别输出情况 A、B 和 C 的三个扩散系数，单位为 m$^2$/s。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC]”），并按此顺序排列。\n- 每个浮点数结果必须以科学记数法打印，小数点后恰好有六位数字（例如，$9.900000\\mathrm{e}{-08}$），该行不包含单位；数值单位被理解为 m$^2$/s。\n\n测试套件即为上面列出的三种情况。每个测试用例的答案是一个实数（浮点数）。最终打印的行以指定的格式和顺序汇总这三个浮点数。",
            "solution": "所给出的问题陈述是有效的。它在科学上基于统计力学的原理，特别是将宏观输运系数与微观相关函数的时间积分联系起来的 Green-Kubo 关系。这个问题是适定的，提供了速度自相关函数（VACF）所需的所有物理常数、参数和函数形式。其设置是内部一致、客观且计算上可行的。我们现在开始求解。\n\n我们的目标是从单分量速度自相关函数 $C(t) = \\langle v_x(t) v_x(0) \\rangle$ 中求出自扩散系数，记为 $D$。我们从第一性原理开始。\n\n自扩散系数 $D$ 在三维空间中由粒子的均方位移（MSD）的长时间行为定义：\n$$\nD = \\lim_{t \\to \\infty} \\frac{1}{6t} \\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle\n$$\n其中 $\\mathbf{r}(t)$ 是粒子在时间 $t$ 的位置矢量，尖括号 $\\langle \\dots \\rangle$ 表示对处于热平衡状态的等效系统进行的系综平均。\n\n粒子的位移矢量 $\\mathbf{r}(t) - \\mathbf{r}(0)$ 是其速度矢量 $\\mathbf{v}(t)$ 的时间积分：\n$$\n\\mathbf{r}(t) - \\mathbf{r}(0) = \\int_0^t \\mathbf{v}(t') dt'\n$$\n将此代入 MSD 表达式中得到：\n$$\n\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle = \\left\\langle \\left( \\int_0^t \\mathbf{v}(t') dt' \\right) \\cdot \\left( \\int_0^t \\mathbf{v}(t'') dt'' \\right) \\right\\rangle\n$$\n根据积分和期望算符的线性性质，我们可以将其写成一个二重积分：\n$$\n\\text{MSD}(t) = \\int_0^t dt' \\int_0^t dt'' \\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t'') \\rangle\n$$\n项 $\\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t'') \\rangle$ 是全速度矢量的速度自相关函数。对于一个平稳过程，该相关性仅取决于时间差 $\\tau = |t' - t''|$。在各向同性系统中，不同速度分量之间的交叉相关平均为零，即当 $i \\neq j$ 时 $\\langle v_i(t') v_j(t'') \\rangle = 0$。此外，每个分量的自相关是相同的：$\\langle v_x(t') v_x(t'') \\rangle = \\langle v_y(t') v_y(t'') \\rangle = \\langle v_z(t') v_z(t'') \\rangle$。设单分量 VACF 为 $C(t' - t'') = \\langle v_x(t') v_x(t'') \\rangle$。\n那么，全 VACF 为：\n$$\n\\langle \\mathbf{v}(t') \\cdot \\mathbf{v}(t'') \\rangle = 3 \\langle v_x(t') v_x(t'') \\rangle = 3 C(t' - t'')\n$$\n然而，问题隐含地采用了文献中一种更常见的约定，该约定源于一个略有不同的起点，最终得到一个更简单的关系式。让我们仔细地重新推导。MSD 可以写为 $\\langle \\Delta x^2 + \\Delta y^2 + \\Delta z^2 \\rangle$。对于各向同性系统，这等于 $3\\langle \\Delta x^2 \\rangle$。一维 MSD 为：\n$$\n\\langle (x(t) - x(0))^2 \\rangle = \\int_0^t dt' \\int_0^t dt'' \\langle v_x(t') v_x(t'') \\rangle = \\int_0^t dt' \\int_0^t dt'' C(t' - t'')\n$$\n这个在方形域上的二重积分可以转换为一个单积分：\n$$\n\\langle (x(t) - x(0))^2 \\rangle = 2 \\int_0^t (t-\\tau) C(\\tau) d\\tau\n$$\n现在，我们将此代入 $D$ 的定义中：\n$$\nD = \\lim_{t \\to \\infty} \\frac{1}{6t} \\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle = \\lim_{t \\to \\infty} \\frac{3}{6t} \\langle (x(t) - x(0))^2 \\rangle = \\lim_{t \\to \\infty} \\frac{1}{2t} \\left( 2 \\int_0^t (t-\\tau) C(\\tau) d\\tau \\right)\n$$\n$$\nD = \\lim_{t \\to \\infty} \\left( \\int_0^t C(\\tau) d\\tau - \\frac{1}{t} \\int_0^t \\tau C(\\tau) d\\tau \\right)\n$$\n为了使扩散系数成为一个有限的非零常数，VACF $C(\\tau)$ 必须足够快地衰减到零，以使其积分收敛。假设 $\\int_0^\\infty C(\\tau)d\\tau$ 是一个有限值，并且积分 $\\int_0^\\infty \\tau C(\\tau) d\\tau$ 也收敛，则当 $t \\to \\infty$ 时第二项消失。这就得到了最终的表达式，一个基石性的 Green-Kubo 关系：\n$$\nD = \\int_0^\\infty C(t) dt\n$$\n这就是我们必须评估的公式。问题指明，单分量 VACF 的初始值由一维能量均分定理确定：$C(0) = \\langle v_x^2 \\rangle = k_{\\mathrm{B}} T / m$。\n\n积分 $D = \\int_0^\\infty C(t) dt$ 的数值评估需要用一个有限的截断值 $t_{\\max}$ 来近似无穷上界。因此，该积分近似为 $D \\approx \\int_0^{t_{\\max}} C(t) dt$。$t_{\\max}$ 的选择必须足够大，以确保被忽略的尾部 $\\int_{t_{\\max}}^\\infty C(t) dt$ 的贡献可以忽略不计。问题要求 $t_{\\max}$ 至少是最长特征衰减时间的 10 倍。特征时间尺度为：情况 A：$\\tau = 0.04$ ps；情况 B：$\\tau_2 = 0.2$ ps；情况 C：$1/\\gamma = 0.05$ ps。其中最大的是 $\\tau_2 = 0.2$ ps。因此，我们必须选择 $t_{\\max} \\geq 10 \\times 0.2$ ps $= 2.0$ ps。选择 $t_{\\max} = 2.5$ ps 是足够保守的。\n\n对于数值积分，我们将构建一个均匀时间网格 $t_i = i \\Delta t$，其中 $i=0, 1, \\dots, N$ 且 $t_N = t_{\\max}$。时间步长 $\\Delta t$ 必须足够小以解析最快的动力学过程。最快的时间尺度是情况 B 的 $\\tau_1 = 0.02$ ps，以及情况 C 的振荡周期 $P = 1/(5 \\times 10^{12} \\text{ Hz}) = 0.2$ ps。最短的特征时间是 $\\tau_1 = 0.02$ ps。$\\Delta t = 0.001$ ps 的时间步长为解析这个最快的衰减提供了 20 个点，这是足够的。这将产生 $N+1 = t_{\\max}/\\Delta t + 1 = 2.5/0.001 + 1 = 2501$ 个网格点。在这个网格上，我们将为每种情况评估函数 $C(t_i)$，然后使用一个收敛的数值积分方法。我们将采用复合辛普森法则，如在 `scipy.integrate.simpson` 中实现的，它非常适合对均匀网格上的采样数据进行积分，并且对于光滑的被积函数通常比梯形法则更准确。\n\n所有计算都必须以基本国际单位制（米、千克、秒、开尔文）进行。所提供的时间常数（单位为皮秒，$1$ ps $= 10^{-12}$ s）、衰减率和频率必须进行相应转换。$D$ 的最终结果将以 m$^2$/s 为单位。该实现将计算 $C_0 = k_{\\mathrm{B}} T / m$，然后为三种指定的 $C(t)$ 形式中的每一种评估定积分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Calculates the self-diffusion coefficient for three cases of a single-component\n    velocity autocorrelation function (VACF).\n    \"\"\"\n    # Physical constants in SI units\n    T = 300.0  # Temperature in Kelvin\n    M_H = 1.6735575e-27  # Mass of hydrogen in kg\n    K_B = 1.380649e-23  # Boltzmann's constant in J/K\n\n    # Conversion factor\n    PS_TO_S = 1e-12\n\n    # Calculate the initial value of the VACF, C(0), from equipartition theorem\n    c0 = (K_B * T) / M_H\n\n    # Define test case parameters\n    # Case A: Single-exponential relaxation\n    tau_A = 0.04 * PS_TO_S\n    # Case B: Bi-exponential relaxation\n    a_B = 0.7\n    tau1_B = 0.02 * PS_TO_S\n    tau2_B = 0.2 * PS_TO_S\n    # Case C: Damped oscillatory correlation\n    gamma_C = 1.0 / (0.05 * PS_TO_S)\n    omega_C = 2.0 * np.pi * 5.0e12\n\n    # Numerical integration parameters\n    # The longest decay timescale is tau2_B = 0.2 ps.\n    # Set t_max to be > 10 * 0.2 ps. We choose 2.5 ps.\n    t_max = 2.5 * PS_TO_S\n    # The fastest timescale is tau1_B = 0.02 ps.\n    # We choose dt to resolve this well. dt = 0.001 ps gives 20 points for 0.02 ps.\n    num_points = 2501  # Gives dt = t_max / (num_points - 1) = 1e-15 s = 0.001 ps\n    t = np.linspace(0, t_max, num_points)\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"func\": lambda t_vals: c0 * np.exp(-t_vals / tau_A)\n        },\n        {\n            \"name\": \"B\",\n            \"func\": lambda t_vals: c0 * (a_B * np.exp(-t_vals / tau1_B) + (1 - a_B) * np.exp(-t_vals / tau2_B))\n        },\n        {\n            \"name\": \"C\",\n            \"func\": lambda t_vals: c0 * np.exp(-gamma_C * t_vals) * np.cos(omega_C * t_vals)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Evaluate the VACF C(t) on the time grid\n        c_t = case[\"func\"](t)\n\n        # Numerically integrate C(t) from 0 to t_max using Simpson's rule\n        # D = integral from 0 to infinity of C(t) dt\n        diffusion_coeff = simpson(y=c_t, x=t)\n        results.append(diffusion_coeff)\n\n    # Format and print the final results as specified\n    formatted_results = [f\"{r:.6e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在速度自相关函数（VACF）分析的基础上，这项实践将更深入地探究其背后的动力学原理。你将通过数值求解一个Volterra方程，来提取广义Langevin方程中的核心概念——记忆函数 $K(t)$。此练习揭示了系统的“记忆”（即过去的力）如何支配VACF的衰减，从而让你对微观过程获得更深层次的理解 。",
            "id": "2447068",
            "problem": "您的任务是根据一个已知的、经过数值采样的速度自相关函数（VACF），从第一性原理出发，通过有原则的离散化方法，重建一个简单流体的记忆函数 $K(t)$。重建工作必须通过数值求解将归一化VACF与广义朗之万方程中的记忆核联系起来的沃尔泰拉（Volterra）卷积方程来完成。您的最终程序必须是完整且可运行的，并且必须在指定的测试集上计算一个量化的误差度量。\n\n假设归一化速度自相关函数（VACF），记作 $\\varphi(t)$，定义为 $\\varphi(t) \\equiv C_{vv}(t)/C_{vv}(0)$，其中 $C_{vv}(t) = \\langle \\mathbf{v}(t) \\cdot \\mathbf{v}(0) \\rangle$ 且 $C_{vv}(0) = \\langle \\mathbf{v}^{2} \\rangle$，并满足 $\\varphi(0) = 1$。对于处于热平衡状态的各向同性流体，$\\varphi(t)$ 是时间的偶函数，因此 $\\varphi'(0) = 0$。针对归一化VACF的广义朗之万方程（GLE）（Mori–Zwanzig投影算符形式理论的一个推论）导出了以下因果沃尔泰拉方程：\n$$\n\\frac{d\\varphi(t)}{dt} = - \\int_{0}^{t} K(t-\\tau)\\,\\varphi(\\tau)\\,d\\tau,\n$$\n其中 $K(t)$ 是一个实值的、因果的记忆核。您的任务是从离散采样的 $\\varphi(t)$ 中数值重建 $K(t)$。\n\n您必须：\n- 从上述沃尔泰拉卷积方程出发，推导出一个在均匀网格上计算 $K(t)$ 的数值稳定时间离散算法。该算法结合了对 $\\varphi'(t)$ 的有限差分近似和对时间积分的黎曼和近似。您必须使用均匀的时间步长 $\\Delta t$ 和左黎曼和来近似积分。对于网格时间 $t_n = n\\,\\Delta t$（$n \\ge 1$），所得到的离散格式必须能够根据先前计算的值递归地计算 $K$。\n- 实现该算法，从数值采样的 $\\varphi(t)$ 中重建 $K(t)$。\n\n为使问题完全可测试，请使用以下形式的物理一致模型记忆核在内部生成合成的 $\\varphi(t)$ 数据：\n$$\nK_{\\text{true}}(t) = a\\,e^{-b t},\n$$\n其中 $a>0$ 且 $b>0$。对于此选择，归一化VACF是上述沃尔泰拉方程所隐含的线性、常系数、齐次二阶常微分方程的解。您可以在网格上生成 $\\varphi(t)$，方法是使用该常微分方程的精确解析解，或者使用足够小的时间步长对其进行数值积分，以使 $\\varphi(t)$ 中的离散误差与反演误差相比可以忽略不计；在所有情况下，都需强制执行 $\\varphi(0)=1$ 和 $\\varphi'(0)=0$。\n\n数值规格：\n- 使用均匀的时间步长 $\\Delta t = 10^{-3}$ 和总时长 $T = 1.5$，因此网格包含 $N+1$ 个点，其中 $N = T/\\Delta t$，且 $t_n = n\\,\\Delta t$，$n=0,1,\\dots,N$。\n- 在可能的情况下，使用二阶精确的有限差分来近似 $\\varphi'(t_n)$（对内部点使用中心差分，如果需要，在端点使用单侧差分）。\n- 使用在 $\\tau$ 网格上的左黎曼和来近似沃尔泰拉方程中的时间积分，以便在每个时间步的离散方程中只出现先前计算过的 $K$ 值。\n\n测试集：\n- 对 $K_{\\text{true}}(t) = a\\,e^{-b t}$ 使用以下三组参数对 $(a,b)$：\n  - 情况1：$(a,b) = (1.0,\\,1.5)$。\n  - 情况2：$(a,b) = (0.25,\\,1.0)$。\n  - 情况3：$(a,b) = (0.10,\\,1.0)$。\n- 对每种情况，在规定的时间网格上生成 $\\varphi(t)$，数值重建 $K(t)$，并通过将重建的 $K(t)$ 与真实的 $K_{\\text{true}}(t)$ 进行比较，在评估时间 $t \\in \\{0.01,\\,0.20,\\,0.50,\\,1.00\\}$ 处评估重建质量。\n- 对每种情况，计算一个单一的标量误差，即在四个指定评估时间上绝对误差的均方根：\n$$\n\\varepsilon = \\sqrt{\\frac{1}{4}\\sum_{j=1}^{4}\\left| K_{\\text{num}}(t_j)-K_{\\text{true}}(t_j)\\right|^2 }.\n$$\n\n输出要求：\n- 此问题中没有物理单位；所有量在构造上都是无量纲的。\n- 您的程序必须输出一行，其中包含一个含有三个浮点数的列表，每个浮点数是对应一种情况的均方根绝对误差 $\\varepsilon$，顺序与上述情况一致。格式必须严格为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_k$ 是一个浮点数。\n\n您的程序必须是完全自包含的，不需要任何输入。它必须确定性地为三种情况生成合成的 $\\varphi(t)$，按照规定通过数值反演沃尔泰拉方程来重建 $K(t)$，在给定的时间点评估误差，并打印最终列表。您实现的算法步骤和近似必须源于给定的基本方程和标准的数值分析构造，而不是任何未声明的快捷公式。",
            "solution": "所提出的问题是计算物理学中一个有效且适定的练习。它在科学上植根于统计力学的Mori-Zwanzig投影算符形式理论，特别是广义朗之万方程（GLE），该方程通过一个沃尔泰拉积分方程将时间相关函数与记忆核联系起来。该问题要求对此方程进行数值反演，这是分析分子动力学模拟数据中的一项标准任务。所有参数、方法和约束都得到了清晰、客观的定义，构成了一个自包含且可验证的问题。因此，我们将着手解决它。\n\n主要任务是通过数值求解因果一类沃尔泰拉方程，从归一化速度自相关函数（VACF）$\\varphi(t)$ 中重建记忆函数 $K(t)$：\n$$\n\\frac{d\\varphi(t)}{dt} = - \\int_{0}^{t} K(t-\\tau)\\,\\varphi(\\tau)\\,d\\tau\n$$\n给定的初始条件是 $\\varphi(0) = 1$ 和 $\\varphi'(0) = 0$。\n\n首先，我们推导用于重建的离散算法。我们引入一个均匀的时间网格 $t_n = n\\,\\Delta t$，其中 $n = 0, 1, 2, \\dots, N$，$\\Delta t$ 是时间步长。令 $\\varphi_n = \\varphi(t_n)$ 和 $K_n = K(t_n)$。在 $t=t_n$ 处评估沃尔泰拉方程得到：\n$$\n\\varphi'(t_n) = - \\int_{0}^{t_n} K(t_n-\\tau)\\,\\varphi(\\tau)\\,d\\tau\n$$\n我们对导数和积分都进行离散化。导数 $\\varphi'(t_n)$ 对于内部点（$n \\ge 1$ 且 $n  N$）使用二阶精确的中心有限差分进行近似：\n$$\n\\varphi'(t_n) \\approx \\frac{\\varphi_{n+1} - \\varphi_{n-1}}{2\\,\\Delta t}\n$$\n积分使用指定的左黎曼和进行近似。积分区间 $[0, t_n]$ 被划分为 $n$ 个宽度为 $\\Delta t$ 的子区间。求和是对点 $\\tau_j = j\\,\\Delta t$（$j=0, 1, \\dots, n-1$）进行的：\n$$\n\\int_{0}^{t_n} K(t_n-\\tau)\\,\\varphi(\\tau)\\,d\\tau \\approx \\sum_{j=0}^{n-1} K(t_n - \\tau_j)\\,\\varphi(\\tau_j)\\,\\Delta t = \\Delta t \\sum_{j=0}^{n-1} K(t_{n-j})\\,\\varphi(t_j) = \\Delta t \\sum_{j=0}^{n-1} K_{n-j}\\,\\varphi_j\n$$\n左黎曼和的这种特定选择至关重要，因为它能导出一个可解的递归结构。将离散近似代入控制方程，得到：\n$$\n\\frac{\\varphi_{n+1} - \\varphi_{n-1}}{2\\,\\Delta t} \\approx - \\Delta t \\sum_{j=0}^{n-1} K_{n-j}\\,\\varphi_j\n$$\n我们可以从和式中分离出包含未知项 $K_n$ 的部分。和式为 $K_n\\varphi_0 + K_{n-1}\\varphi_1 + \\dots + K_1\\varphi_{n-1}$。\n$$\n\\frac{\\varphi_{n+1} - \\varphi_{n-1}}{2\\,\\Delta t} \\approx - \\Delta t \\left( K_n\\varphi_0 + \\sum_{j=1}^{n-1} K_{n-j}\\,\\varphi_j \\right)\n$$\n现在我们可以解出 $K_n$。根据给定条件 $\\varphi_0 = \\varphi(0) = 1$，我们得到对 $n \\ge 1$ 的递归公式：\n$$\nK_n \\approx -\\frac{\\varphi_{n+1} - \\varphi_{n-1}}{2\\,(\\Delta t)^2} - \\sum_{j=1}^{n-1} K_{n-j}\\,\\varphi_j\n$$\n这个公式允许顺序计算 $K_1, K_2, K_3, \\dots$。对于 $n=1$，和式为空，得到 $K_1 \\approx -(\\varphi_2 - \\varphi_0)/(2(\\Delta t)^2)$。对于 $n=2$，有 $K_2 \\approx -(\\varphi_3 - \\varphi_1)/(2(\\Delta t)^2) - K_1\\varphi_1$，依此类推。\n\n接下来，我们处理生成用于 $\\varphi(t)$ 的合成测试数据的问题。问题指定了一个真实的记忆核 $K_{\\text{true}}(t) = a\\,e^{-b t}$。为了找到对应的 $\\varphi(t)$，我们可以将该积分-微分方程转化为一个纯常微分方程（ODE）。使用莱布尼茨积分法则对沃尔泰拉方程关于 $t$ 求导，得到：\n$$\n\\varphi''(t) = - \\frac{d}{dt} \\int_{0}^{t} K(t-\\tau)\\,\\varphi(\\tau)\\,d\\tau = - \\left( K(0)\\varphi(t) + \\int_{0}^{t} K'(t-\\tau)\\varphi(\\tau)\\,d\\tau \\right)\n$$\n对于 $K(t) = a\\,e^{-b t}$，我们有 $K(0)=a$ 和 $K'(t) = -ab\\,e^{-b t} = -b K(t)$。将这些代入 $\\varphi''(t)$ 的方程中：\n$$\n\\varphi''(t) = -a\\varphi(t) - \\int_{0}^{t} [-b\\,K(t-\\tau)]\\varphi(\\tau)\\,d\\tau = -a\\varphi(t) + b\\int_{0}^{t} K(t-\\tau)\\varphi(\\tau)\\,d\\tau\n$$\n认识到剩下的积分等于 $-\\varphi'(t)$，我们得到一个二阶线性齐次常系数ODE：\n$$\n\\varphi''(t) + b\\,\\varphi'(t) + a\\,\\varphi(t) = 0\n$$\n该ODE必须在初始条件 $\\varphi(0) = 1$ 和 $\\varphi'(0) = 0$ 下求解。其解取决于特征方程 $r^2 + b\\,r + a = 0$ 的根，即 $r_{1,2} = (-b \\pm \\sqrt{b^2 - 4a})/2$。我们考虑判别式 $\\Delta = b^2 - 4a$ 的三种情况：\n\n1.  **过阻尼 ($\\Delta > 0$)：** $\\varphi(t) = \\frac{1}{r_1-r_2}(-r_2 e^{r_1 t} + r_1 e^{r_2 t})$。测试用例 $(a,b) = (0.10, 1.0)$ 属于此类别，因为 $1.0^2 - 4(0.10) = 0.6 > 0$。\n\n2.  **临界阻尼 ($\\Delta = 0$)：** $\\varphi(t) = (1 + \\frac{b}{2}t)e^{-bt/2}$。测试用例 $(a,b) = (0.25, 1.0)$ 属于此类别，因为 $1.0^2 - 4(0.25) = 0$。\n\n3.  **欠阻尼 ($\\Delta  0$)：** $\\varphi(t) = e^{-bt/2}\\left(\\cos(\\omega t) + \\frac{b}{2\\omega}\\sin(\\omega t)\\right)$，其中 $\\omega = \\frac{\\sqrt{4a - b^2}}{2}$。测试用例 $(a,b) = (1.0, 1.5)$ 属于此类别，因为 $1.5^2 - 4(1.0) = -1.75  0$。\n\n实现将按以下步骤进行。对于每个测试用例 $(a,b)$：\n1.  设置时间网格，$\\Delta t = 10^{-3}$ 且 $T = 1.5$。\n2.  通过在每个网格点 $t_n$ 上评估上述三种情况中相应的解析解，生成 $\\varphi_n$ 值的数组。\n3.  通过对 $n=1, \\dots, N-1$ 迭代应用推导出的递归公式，计算数值记忆核数组 $K_{\\text{num}}$。\n4.  在指定的评估时间 $t_j \\in \\{0.01, 0.20, 0.50, 1.00\\}$，找到对应的整数索引 $n_j = t_j/\\Delta t$。\n5.  计算均方根误差 $\\varepsilon = \\sqrt{\\frac{1}{4}\\sum_{j=1}^{4}\\left| K_{\\text{num}}(t_{n_j}) - K_{\\text{true}}(t_j)\\right|^2}$。\n此过程是确定性的，并直接实现了所推导的原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of reconstructing a memory kernel from a synthetic\n    velocity autocorrelation function (VACF) for three test cases and\n    computes the reconstruction error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.5),  # Case 1\n        (0.25, 1.0), # Case 2\n        (0.10, 1.0), # Case 3\n    ]\n\n    # Numerical specifications\n    dt = 1e-3\n    T = 1.5\n    N = int(T / dt)\n    t_grid = np.linspace(0, T, N + 1)\n    \n    evaluation_times = np.array([0.01, 0.20, 0.50, 1.00])\n    evaluation_indices = (evaluation_times / dt).astype(int)\n\n    results = []\n    for a, b in test_cases:\n        # Step 1: Generate synthetic VACF data phi(t)\n        phi = generate_phi(a, b, t_grid)\n\n        # Step 2: Reconstruct the memory kernel K(t) numerically\n        K_num = reconstruct_K(phi, dt, N)\n\n        # Step 3: Evaluate the error\n        error = calculate_error(K_num, a, b, evaluation_times, evaluation_indices)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\ndef generate_phi(a, b, t_grid):\n    \"\"\"\n    Generates the normalized VACF phi(t) for a given memory kernel K(t) = a*exp(-b*t).\n    The function phi(t) is the solution to phi'' + b*phi' + a*phi = 0\n    with phi(0)=1, phi'(0)=0.\n    \"\"\"\n    discriminant = b**2 - 4 * a\n    \n    if discriminant > 0: # Overdamped case\n        sqrt_delta = np.sqrt(discriminant)\n        r1 = (-b + sqrt_delta) / 2\n        r2 = (-b - sqrt_delta) / 2\n        C1 = -r2 / (r1 - r2)\n        C2 = r1 / (r1 - r2)\n        phi = C1 * np.exp(r1 * t_grid) + C2 * np.exp(r2 * t_grid)\n    elif discriminant == 0: # Critically damped case\n        r = -b / 2\n        C1 = 1\n        C2 = -r\n        phi = (C1 + C2 * t_grid) * np.exp(r * t_grid)\n    else: # Underdamped case\n        omega = np.sqrt(4 * a - b**2) / 2\n        alpha = b / 2\n        C1 = 1\n        C2 = alpha / omega\n        phi = np.exp(-alpha * t_grid) * (C1 * np.cos(omega * t_grid) + C2 * np.sin(omega * t_grid))\n        \n    return phi\n\ndef reconstruct_K(phi, dt, N):\n    \"\"\"\n    Numerically reconstructs the memory kernel K(t) from phi(t)\n    using the derived recursive formula.\n    \"\"\"\n    K_num = np.zeros(N + 1)\n    dt_sq = dt**2\n\n    # The recursion is for n >= 1. We compute up to K_{N-1}\n    # as the derivative approximation needs phi_{n+1}.\n    for n in range(1, N):\n        # Derivative part: -(phi_{n+1} - phi_{n-1}) / (2 * dt^2)\n        derivative_part = -(phi[n + 1] - phi[n - 1]) / (2 * dt_sq)\n        \n        # Summation part: sum_{j=1}^{n-1} K_{n-j} * phi_j\n        # This is a discrete convolution.\n        sum_part = 0.0\n        if n > 1:\n            # Vectorized summation for efficiency\n            # K_indices from 1 to n-1. phi_indices from n-1 down to 1.\n            sum_part = np.dot(K_num[1:n], phi[n-1:0:-1])\n        \n        K_num[n] = derivative_part - sum_part\n        \n    return K_num\n\ndef calculate_error(K_num, a, b, eval_times, eval_indices):\n    \"\"\"\n    Calculates the root-mean-square error between the numerical\n    and true memory kernel at specified evaluation times.\n    \"\"\"\n    K_true_eval = a * np.exp(-b * eval_times)\n    K_num_eval = K_num[eval_indices]\n    \n    squared_errors = (K_num_eval - K_true_eval)**2\n    mean_squared_error = np.mean(squared_errors)\n    rms_error = np.sqrt(mean_squared_error)\n    \n    return rms_error\n\nsolve()\n```"
        },
        {
            "introduction": "前面的练习都假设你已经获得了一个正确的时间相关函数。这最后一个实践则探讨了一个对任何从业者都至关重要的问题：我们如何从模拟中生成可靠的数据？你将分析恒温器（控制温度的必要工具）的选择如何巧妙地改变系统动力学，并可能对通过Green-Kubo关系计算出的输运系数产生偏差。这项练习对于培养进行有效的输运性质分子动力学模拟所需的批判性判断力至关重要 。",
            "id": "2674588",
            "problem": "一位分子动力学研究者希望在固定温度下，使用平衡态时间关联函数和 Green–Kubo 框架来计算一种简单流体的输运系数。在平衡化和数据收集过程中，考虑了两种恒温器：一种是确定性的 Nosé–Hoover 链，另一种是随机的 Langevin 恒温器，后者对每个粒子施加独立的白噪声和摩擦项。两种恒温器的实现都使得物理坐标和动量的边缘平衡分布在温度 $T$ 下是正则的。该研究者知道涨落-耗散定理将线性响应系数与自发平衡涨落联系起来，并担心恒温器的选择和强度可能会对计算输运系数所需的时间关联函数产生偏差。\n\n以下哪些陈述和程序是有效的，可以确保得到正确的平衡涨落和无偏的 Green–Kubo 输运系数？\n\nA. 如果恒温器在温度 $T$ 下对正则分布进行采样，那么任何 Langevin 摩擦系数 $\\gamma$ 或 Nosé–Hoover 耦合强度的选择对于 Green–Kubo 计算都是可以接受的，因为等时涨落决定了时间积分关联；动力学的扭曲不会影响最终的输运系数。\n\nB. 对于确定性的 Nosé–Hoover 链，应验证所选系统尺寸、耦合和时间步长的遍历性。如果遍历性不确定，可以增加链的长度，或者更保守地，在恒温器下进行平衡化，然后切换到微正则动力学进行关联函数测量，以避免恒温器引起的动力学赝象。\n\nC. 对于粒子级耦合破坏精确动量守恒的 Langevin 动力学，为了获得依赖于流体力学模式的无偏输运系数，应选择一个远小于最慢相关弛豫时间倒数的摩擦系数 $\\gamma$，或者更可取的方法是，用恒温器进行平衡化，然后在关闭恒温器的情况下收集关联函数。在所有情况下，都必须确保噪声和摩擦满足温度 $T$ 下的涨落-耗散关系。\n\nD. 仅对质心自由度施加恒温器可以保留流体力学模式，但会使平衡涨落无效，因为该系综不再是严格的正则系综；因此，即使在大型系统中，也必须避免在 Green–Kubo 计算中使用这种做法。\n\nE. 当从涉及力的微观通量计算输运系数时，如果恒温器对粒子施加非保守力，则必须将恒温器的贡献从关联函数中使用的微观通量定义中排除；否则，会因重复计算耗散而违反涨落-耗散关系。\n\n选择所有适用的选项。",
            "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- **系统**：一种简单流体。\n- **目标**：使用平衡态时间关联函数并通过 Green–Kubo 框架计算输运系数。\n- **系综**：固定温度 $T$ （正则系综）。\n- **模拟方法**：分子动力学。\n- **考虑的恒温器**：\n    1. 一种确定性的 Nosé–Hoover 链。\n    2. 一种对每个粒子施加独立白噪声和摩擦的随机 Langevin 恒温器。\n- **恒温器条件**：两种恒温器的实现都是为了生成物理坐标和动量的正则平衡分布。\n- **问题背景**：研究者担心恒温器的选择和强度会对用于计算输运系数的时间关联函数引入偏差。\n- **理论基础**：涨落-耗散定理。\n\n**第2步：使用提取的已知条件进行验证**\n问题陈述具有科学依据，提问得当且客观。它涉及计算统计力学中一个标准的、不容忽视的问题：恒温器对计算输运系数等动力学性质的影响。所提及的概念——Green–Kubo 关系、Nosé–Hoover 和 Langevin 恒温器、正则分布以及涨落-耗散定理——都是标准概念且在上下文中被正确使用。该问题是自洽的，没有科学缺陷、歧义或矛盾。\n\n**第3步：结论与行动**\n问题陈述有效。将推导完整解答。\n\nGreen-Kubo 关系将宏观输运系数 $\\Lambda$ 与相应微观通量 $J$ 的平衡态时间关联函数的时间积分联系起来：\n$$ \\Lambda \\propto \\int_0^\\infty \\langle J(0) J(t) \\rangle_{eq} dt $$\n平均值 $\\langle \\dots \\rangle_{eq}$ 是在平衡系综上进行的。恒温器的主要作用是确保模拟所采样的静态相空间分布是正则分布，$P(\\mathbf{q}, \\mathbf{p}) \\propto \\exp(-\\beta H(\\mathbf{q}, \\mathbf{p}))$，其中 $\\beta = 1/(k_B T)$。这保证了等时关联（如 $\\langle J(0)^2 \\rangle$）是正确的。\n\n然而，决定通量从 $J(0)$ 演化到 $J(t)$ 的动力学过程被恒温器所修改。运动方程不再是纯粹的哈密顿形式。对于动量为 $\\mathbf{p}_i$、受到粒子间作用力为 $\\mathbf{F}_i^{\\text{int}}$ 的粒子 $i$，运动方程被改变：\n- **Nosé-Hoover**：$\\dot{\\mathbf{p}}_i = \\mathbf{F}_i^{\\text{int}} - \\zeta \\mathbf{p}_i$，其中 $\\zeta$ 是一个动力学摩擦变量。\n- **Langevin**：$\\dot{\\mathbf{p}}_i = \\mathbf{F}_i^{\\text{int}} - \\gamma \\mathbf{p}_i + \\mathbf{R}_i(t)$，其中 $\\gamma$ 是摩擦系数，$\\mathbf{R}_i(t)$ 是随机力。\n\n这些非哈密顿项 $-\\zeta \\mathbf{p}_i$ 和 $-\\gamma \\mathbf{p}_i + \\mathbf{R}_i(t)$ 直接干扰系统的自然时间演化。这种干扰可以改变时间关联函数 $\\langle J(0) J(t) \\rangle$ 的衰减方式，从而对计算出的输运系数 $\\Lambda$ 值产生偏差。必须基于这一根本冲突来判断各陈述的有效性。\n\n**选项评估**\n\n**A. 如果恒温器在温度 $T$ 下对正则分布进行采样，那么任何 Langevin 摩擦系数 $\\gamma$ 或 Nosé–Hoover 耦合强度的选择对于 Green–Kubo 计算都是可以接受的，因为等时涨落决定了时间积分关联；动力学的扭曲不会影响最终的输运系数。**\n\n这个陈述有根本性的错误。它正确地指出恒温器对正则分布进行采样，这确定了等时涨落（$\\langle J(0)^2 \\rangle$）。然而，它错误地得出结论说这就足够了。输运系数是关联函数的*时间积分*，它深刻地依赖于系统在时间 $t>0$ 时的动力学。强的恒温器耦合（大的 $\\gamma$ 或强的 Nosé-Hoover 耦合）会引入人为的阻尼，导致关联比在未受扰动的物理系统中衰减得快得多。这会导致对输运系数的系统性低估。声称动力学的扭曲无关紧要是错误的。\n**结论：错误。**\n\n**B. 对于确定性的 Nosé–Hoover 链，应验证所选系统尺寸、耦合和时间步长的遍历性。如果遍历性不确定，可以增加链的长度，或者更保守地，在恒温器下进行平衡化，然后切换到微正则动力学进行关联函数测量，以避免恒温器引起的动力学赝象。**\n\n这个陈述描述了公认的最佳实践。单变量的 Nosé-Hoover 恒温器可能存在非遍历性问题，尤其是在刚性或小系统中，因为它可能无法采样整个等能面。Nosé-Hoover *链* 是缓解此问题的标准方法，增加链长通常能改善遍历性。此外，计算动力学性质最严谨的方法是在测量阶段完全避免恒温器引起的赝象。将在恒温器下将系统平衡到目标温度，然后在随后的微正则（NVE）运行中收集关联函数的数据，这是金标准。在足够大的系统中，NVE 运行中能量是守恒的，温度涨落极小，因此动力学能准确地代表未受扰动的物理系统。\n**结论：正确。**\n\n**C. 对于粒子级耦合破坏精确动量守恒的 Langevin 动力学，为了获得依赖于流体力学模式的无偏输运系数，应选择一个远小于最慢相关弛豫时间倒数的摩擦系数 $\\gamma$，或者更可取的方法是，用恒温器进行平衡化，然后在关闭恒温器的情况下收集关联函数。在所有情况下，都必须确保噪声和摩擦满足温度 $T$ 下的涨落-耗散关系。**\n\n这个陈述完全正确，并指出了关于 Langevin 恒温器的几个关键点。\n1. 对每个粒子施加独立的摩擦和噪声会破坏总动量守恒。这会非自然地阻尼长波长的集体运动（流体力学模式），而这些模式与剪切粘度等输运系数直接相关。\n2. 使用非常小的摩擦系数 $\\gamma$ 会使恒温器对动力学的扰动变弱。如果恒温器的特征时间尺度 $\\tau_{\\gamma} \\sim 1/\\gamma$ 远长于通量关联函数的弛豫时间，其对 Green-Kubo 积分的影响将很小。这是一个有效但需要精细操作的方法。\n3. 如选项 B 所述，首选方法是在数据收集期间通过平衡化后切换到 NVE 模拟，将系统与恒温器解耦。\n4. 至关重要的是，为了让 Langevin 恒温器在温度 $T$ 下生成正则分布，随机力的大小必须通过涨落-耗散关系与摩擦系数 $\\gamma$ 和温度 $T$ 相关联。这是恒温器发挥其基本功能的前提。\n**结论：正确。**\n\n**D. 仅对质心自由度施加恒温器可以保留流体力学模式，但会使平衡涨落无效，因为该系综不再是严格的正则系综；因此，即使在大型系统中，也必须避免在 Green–Kubo 计算中使用这种做法。**\n\n这个陈述包含一个有缺陷的结论。虽然仅对质心（CoM）进行恒温确实不会为整个 $3N$ 维相空间生成严格的正则系综，但在热力学极限下（$N \\to \\infty$），其对内部 $3N-3$ 个自由度的影响变得可以忽略不计。对于一个大系统，恒温的质心与内部自由度之间的能量交换足以维持一个对于内部部分来说与正则系综实际上无法区分的状态。这种方法的最大优点是，*相对*粒子位置和动量的运动方程是纯粹的牛顿形式，从而保留了总动量，并且不扰动流体力学模式。因此，声称这种做法“必须避免”是不正确的；它可能是一种有效且有用的技术，尤其对于大型系统。\n**结论：错误。**\n\n**E. 当从涉及力的微观通量计算输运系数时，如果恒温器对粒子施加非保守力，则必须将恒温器的贡献从关联函数中使用的微观通量定义中排除；否则，会因重复计算耗散而违反涨落-耗散关系。**\n\n这个陈述是正确的，并指出了一个微妙的必要性。Green-Kubo 关系中的微观通量 $J$ 是系统的物理量，根据粒子坐标、动量和*物理粒子间作用力*（$\\mathbf{F}^{\\text{int}}$）来定义。源自恒温器的力（$\\mathbf{F}^{\\text{thermo}}$）是用于维持温度的模拟算法的一部分；它们不是人们旨在测量的物理系统输运性质的一部分。将 $\\mathbf{F}^{\\text{thermo}}$ 包含在通量（如应力张量）的定义中，将等同于计算一个不同的、人为的系统的性质。关于“重复计算耗散”的概念论证是恰当的：Green-Kubo 积分本身通过关联的衰减来衡量系统的内在耗散响应。恒温器的力是一种*外部*的耗散/涨落机制。将两者混淆是一个根本性错误。$J$ 的定义必须完全基于物理系统的哈密顿量。\n**结论：正确。**",
            "answer": "$$\\boxed{BCE}$$"
        }
    ]
}