{
    "hands_on_practices": [
        {
            "introduction": "线性同余生成器 (LCG) 通过一个确定的递推关系 $X_{n+1} \\equiv a X_n + c \\pmod{m}$ 从一个状态生成下一个状态。一个自然而然的问题是：这个过程可逆吗？给定一个状态 $X_{n+1}$，我们能否唯一地确定其前一个状态 $X_n$？ 这项实践将引导你深入探讨这个问题的数学核心，从基本原理出发，推导求解前驱状态的条件，并处理存在唯一解、多解或无解等不同情况。通过这个练习，你将掌握求解线性同余方程的关键技能，并深刻理解乘数 $a$ 和模数 $m$ 之间的关系（即它们是否互质）是如何决定生成器行为的。",
            "id": "2408806",
            "problem": "要求您从第一性原理出发，推导线性同余生成器（LCG）的可逆性，然后实现一个程序，为给定的后继状态计算其所有单步前驱的完整集合。线性同余生成器（LCG）通过递推关系\n$$\nX_{n+1} \\equiv a X_n + c \\pmod{m},\n$$\n在模 $m$ 整数环中生成一个序列 $\\{X_n\\}$。其中 $a, c, m$ 是固定整数，满足 $m \\ge 2$，且对所有 $n$ 都有 $X_n \\in \\{0,1,2,\\dots,m-1\\}$。同余关系是在整数上定义的等价关系，即 $u \\equiv v \\pmod{m}$ 当且仅当 $m$ 整除 $u - v$。\n\n您的任务：\n\n1) 仅从同余的基本性质、最大公约数（gcd）的概念以及整数 $a$ 存在模 $m$ 的乘法逆元的充要条件是 $\\gcd(a,m) = 1$ 这一事实出发，推导出对于给定的 $X_{n+1}$，其单步前驱 $X_n$ 存在的充分必要条件，并确定当解存在时，在集合 $\\{0,1,\\dots,m-1\\}$ 中有多少个不同的前驱。您不能假设任何现成的“捷径”公式；相反，必须从同余的定义和最大公约数所蕴含的整除性质出发进行推理。\n\n2) 基于您的推导，设计一个算法。该算法在给定整数 $m, a, c$ 和一个特定的后继状态 $X_{n+1}$ 时，计算满足单步关系 $X_{n+1} \\equiv a X_n + c \\pmod{m}$ 的所有 $X_n \\in \\{0,1,\\dots,m-1\\}$ 的完整集合。您的算法必须：\n- 判断解是否存在。\n- 如果解不存在，则返回空集。\n- 如果解存在，则返回所有解，并且不能通过对 $\\{0,1,\\dots,m-1\\}$ 进行暴力迭代，而应仅使用数论推理和扩展欧几里得算法。\n- 将返回的解按严格递增顺序排序。\n\n3) 将您的算法实现为一个完整的、可运行的程序，用于解决以下测试套件。对于每个测试用例，输入为 $(m, a, c, X_{n+1})$。您的程序应计算并返回满足单步关系的所有 $X_n \\in \\{0,\\dots,m-1\\}$ 的列表。测试用例如下：\n- 案例 A（理想情况，素数模，乘法 LCG）：$m = 2147483647$, $a = 16807$, $c = 0$, $X_{n+1} = 16807$。\n- 案例 B（2的幂次模，奇数乘数）：$m = 2147483648$, $a = 65539$, $c = 0$, $X_{n+1} = 1663592255$。\n- 案例 C（不存在前驱，$a$ 和 $m$ 不互素）：$m = 12$, $a = 8$, $c = 3$, $X_{n+1} = 5$。\n- 案例 D（存在多个前驱，$a$ 和 $m$ 不互素）：$m = 12$, $a = 8$, $c = 4$, $X_{n+1} = 8$。\n- 案例 E（满周期 Java 风格参数，加性 LCG）：$m = 281474976710656$, $a = 25214903917$, $c = 11$, $X_{n+1} = 11$。\n\n为保证数值鲁棒性，所有算术运算都必须在整数上精确进行；此任务中不涉及浮点数。\n\n输出规范：\n- 对于每个测试用例，输出映射到给定 $X_{n+1}$ 的所有整数前驱 $X_n$（在 $\\{0,1,\\dots,m-1\\}$ 中）的完整列表，并按升序排序。如果没有前驱，则输出空列表。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个元素本身也是一个列表，例如：$[ [x_{A,1},x_{A,2}], [x_{B,1}], [], [x_{D,1},x_{D,2},x_{D,3}], [x_{E,1}] ]$。只使用整数；不要打印任何解释性文本或单位。\n\n您的最终程序不得从用户读取输入，也不得访问外部文件或网络。它必须能直接运行，并严格按照指定格式打印一行输出。",
            "solution": "所述问题是有效的。这是一个计算数论中的良置问题，其基础是线性同余的既定原理。所有定义都是标准的，提供的参数明确无误且在计算上是可行的。我们现在将对解法进行形式化推导。\n\n问题的核心是，对于给定的后继状态 $X_{n+1}$，找出在范围 $\\{0, 1, \\dots, m-1\\}$ 内所有满足线性同余生成器（LCG）单步递推关系的整数 $X_n$。该关系定义为：\n$$\nX_{n+1} \\equiv a X_n + c \\pmod{m}\n$$\n此处，$a$、$c$ 和 $m$ 是给定的整数，且 $m \\ge 2$。我们的目标是求解 $X_n$。这可以通过首先重新整理同余式以分离出含有未知数 $X_n$ 的项来实现：\n$$\na X_n \\equiv X_{n+1} - c \\pmod{m}\n$$\n这是一个标准形式为 $Ax \\equiv B \\pmod{N}$ 的线性同余式，其中我们对应 $A=a$，$x=X_n$，$B = X_{n+1} - c$，以及 $N=m$。为简洁起见，我们定义 $b = X_{n+1} - c$。需要求解的同余式是：\n$$\na X_n \\equiv b \\pmod{m}\n$$\n$X_n$ 解的存在性和数量完全由系数 $a$ 和模 $m$ 的最大公约数的性质决定。我们记 $d = \\gcd(a, m)$。\n\n根据同余的定义，$a X_n \\equiv b \\pmod{m}$ 等价于 $m$ 整除 $(a X_n - b)$。这又等价于存在一个整数 $k$ 使得：\n$$\na X_n - b = k m\n$$\n整理后得到关于两个变量 $X_n$ 和 $k$ 的线性丢番图方程：\n$$\na X_n - k m = b\n$$\n根据线性丢番图方程的基本理论（贝祖等式的一个推论），形如 $Ax + By = C$ 的方程有整数解 $(x, y)$ 的充要条件是 $\\gcd(A, B)$ 整除 $C$。在我们的例子中，$A = a$，$B = -m$，$C = b$。由于 $\\gcd(a, -m) = \\gcd(a, m) = d$，因此 $X_n$（和 $k$）的解存在的充要条件是 $d$ 整除 $b$。\n\n这就确立了至少存在一个前驱的充分必要条件：\n前驱 $X_n$ 存在，当且仅当 $\\gcd(a, m)$ 整除 $(X_{n+1} - c)$。\n\n如果不满足此条件 $d | b$，则 $X_n$ 不存在整数解，因此在 $\\{0, 1, \\dots, m-1\\}$ 中的前驱集合为空集。\n\n如果条件 $d | b$ 满足，则解存在，我们必须找出所有解。由于 $d$ 是 $a$、$m$ 和 $b$ 的公约数，我们可以将整个同余式 $a X_n \\equiv b \\pmod{m}$ 除以 $d$。同余式 $aX_n \\equiv b \\pmod{m}$ 意味着对于某个整数 $k$ 有 $aX_n = b + km$。两边同除以 $d$ 得到 $(a/d)X_n = (b/d) + k(m/d)$，这意味着 $(a/d)X_n \\equiv (b/d) \\pmod{m/d}$。我们定义 $a' = a/d$，$b' = b/d$，$m' = m/d$。约化后的同余式为：\n$$\na' X_n \\equiv b' \\pmod{m'}\n$$\n根据最大公约数的性质，我们知道 $\\gcd(a/d, m/d) = \\gcd(a', m') = 1$。这是关键的一步，因为它确保了 $a'$ 存在唯一的模 $m'$ 乘法逆元。这个逆元的存在使我们能够直接求解约化同余式。\n\n我们使用扩展欧几里得算法来找到 $a'$ 模 $m'$ 的逆元。该算法找到一对整数，比如 $(u, v)$，使得 $a'u + m'v = \\gcd(a', m') = 1$。将此恒等式对 $m'$ 取模，我们得到 $a'u \\equiv 1 \\pmod{m'}$。整数 $u$（或 $u \\pmod{m'}$）就是所需的模逆元，我们记为 $(a')^{-1}$。\n\n现在，我们将约化同余式 $a' X_n \\equiv b' \\pmod{m'}$ 的两边乘以这个逆元 $(a')^{-1}$：\n$$\n(a')^{-1} a' X_n \\equiv (a')^{-1} b' \\pmod{m'}\n$$\n$$\n1 \\cdot X_n \\equiv (a')^{-1} b' \\pmod{m'}\n$$\n这就给出了 $X_n$ 的一个解系。所有满足此关系的整数 $X_n$ 都是约化同余式的解。最小的非负解，我们称之为特解 $x_0$，由下式给出：\n$$\nx_0 = ((a')^{-1} \\cdot b') \\pmod{m'}\n$$\n这意味着任何解 $X_n$ 都必须是 $X_n = x_0 + j \\cdot m'$ 的形式，其中 $j$ 是某个整数。我们关心的是位于集合 $\\{0, 1, \\dots, m-1\\}$ 中的解。我们将解的形式代入这个范围约束：\n$$\n0 \\le x_0 + j \\cdot m' \\le m-1\n$$\n由于 $m' = m/d$，我们寻找的是 $0 \\le x_0 + j \\cdot (m/d) \\le m-1$。鉴于 $0 \\le x_0  m' = m/d$，$j$ 的有效整数值为 $0, 1, 2, \\dots, d-1$。当 $j=d$ 时，解变为 $x_0 + d \\cdot (m/d) = x_0 + m$，超出了所需范围。\n\n因此，如果解存在，则在集合 $\\{0, 1, \\dots, m-1\\}$ 中恰好有 $d = \\gcd(a, m)$ 个不同的解。这些解是：\n$$\n\\{ x_0 + j \\cdot (m/d) \\mid j = 0, 1, \\dots, d-1 \\}\n$$\n这个集合自然是按升序排列的。\n\n寻找前驱的算法如下：\n1.  给定 $m, a, c, X_{n+1}$，计算 $b = X_{n+1} - c$。\n2.  计算 $d = \\gcd(a, m)$。\n3.  检查 $b$ 是否能被 $d$ 整除。如果不能（$b \\pmod d \\neq 0$），则返回一个空解集。\n4.  如果 $b$ 能被 $d$ 整除，则继续。定义 $a' = a/d$，$b' = b/d$，$m' = m/d$。\n5.  使用扩展欧几里得算法找到 $a'$ 模 $m'$ 的模逆元。设其为 $inv\\_a'$。\n6.  计算特解 $x_0 = (b' \\cdot inv\\_a') \\pmod{m'}$。\n7.  生成包含 $d$ 个解的完整集合：$\\{x_0, x_0+m', x_0+2m', \\dots, x_0+(d-1)m'\\}$。\n8.  返回这个解集，它已经是有序的。\n该算法避免了暴力搜索，完全依赖于高效的数论计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n# from scipy import ...\n\ndef extended_gcd(a, b):\n    \"\"\"\n    Computes the extended greatest common divisor of integers a and b.\n    Returns a tuple (g, x, y) such that a*x + b*y = g, where g = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = extended_gcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef find_predecessors(m, a, c, X_next):\n    \"\"\"\n    Solves for all X_n in {0,...,m-1} such that X_{n+1} = (a * X_n + c) mod m.\n    \n    This function solves the linear congruence a*x = b (mod m),\n    where x = X_n and b = X_next - c.\n    \"\"\"\n    if m  2:\n        raise ValueError(\"Modulus m must be = 2\")\n\n    # The congruence to solve is a * X_n = X_next - c (mod m)\n    # Let's put it in the standard form a*x = b (mod m)\n    # Note that all arithmetic is done with Python's arbitrary-precision integers.\n    a_mod_m = a % m\n    b = X_next - c\n\n    # Let d = gcd(a, m). Solutions exist iff d divides b.\n    d = math.gcd(a_mod_m, m)\n\n    if b % d != 0:\n        # No solutions exist.\n        return []\n\n    # If we are here, there are exactly d solutions.\n    # We reduce the congruence to a' * x = b' (mod m'), where gcd(a', m') = 1.\n    a_prime = a_mod_m // d\n    b_prime = b // d\n    m_prime = m // d\n\n    # Find the modular multiplicative inverse of a' mod m'\n    # using the Extended Euclidean Algorithm.\n    # eea(a', m') returns (g, x, y) s.t. a'*x + m'*y = g. Here g is 1.\n    g, inv_a_prime_raw, _ = extended_gcd(a_prime, m_prime)\n    \n    if g != 1:\n        # This case should not be reachable due to the definition of gcd.\n        # It is a logical impossibility.\n        raise RuntimeError(\"Mathematical inconsistency: gcd(a/d, m/d) is not 1.\")\n\n    inv_a_prime = inv_a_prime_raw % m_prime\n\n    # A particular solution x0 for the reduced congruence is:\n    # x0 = b' * (a')^{-1} (mod m')\n    x0 = (b_prime * inv_a_prime) % m_prime\n\n    # The d solutions for the original congruence are x0 + k*m' for k in {0, ..., d-1}.\n    # This list is generated in increasing order.\n    solutions = [x0 + k * m_prime for k in range(d)]\n    \n    return solutions\n\ndef solve():\n    \"\"\"\n    Runs the predefined test suite and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, prime modulus, mult LCG\n        (2147483647, 16807, 0, 16807),\n        # Case B: power-of-two modulus, odd multiplier\n        (2147483648, 65539, 0, 1663592255),\n        # Case C: no predecessor exists\n        (12, 8, 3, 5),\n        # Case D: multiple predecessors exist\n        (12, 8, 4, 8),\n        # Case E: full-period Java-style parameters\n        (281474976710656, 25214903917, 11, 11),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        m, a, c, X_next = case\n        predecessors = find_predecessors(m, a, c, X_next)\n        all_results.append(predecessors)\n\n    # Format the results into a single string as specified in the problem.\n    # Each sub-list must be formatted without spaces, e.g., [1,2,3] not [1, 2, 3].\n    def format_list(lst):\n        return f\"[{','.join(map(str, lst))}]\"\n\n    final_output_string = f\"[{','.join(map(format_list, all_results))}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们将目光从纯数学转向一个实际的物理应用。一个高质量的随机数生成器是许多物理模拟（如蒙特卡洛方法）的基石。 在这项实践中，我们将模拟一个简单的一维随机游走过程，并揭示一个理论上有缺陷的生成器——臭名昭著的 RANDU——会如何给模拟结果带来系统性的、非物理的偏差。通过亲手诊断这个“失败”的模拟，你将直观地感受到，为何选择和验证随机数生成器对于保证科学计算结果的可靠性至关重要。",
            "id": "2408840",
            "problem": "为在计算物理学中使用，对一个一维随机游走进行建模。行走者在整数时间点上进行离散步进。伪随机数由一个线性同余生成器（LCG）生成，对于整数其定义为\n$$\nx_{n+1} \\equiv (a x_n + c) \\bmod m,\n$$\n其参数为 $a$、$c$、$m$ 和一个初始种子 $x_0$。在时间 $n$ 的模拟步长仅由 $x_n$ 的奇偶性决定，通过以下方式：\n$$\ns_n =\n\\begin{cases}\n+1,  \\text{if } x_n \\bmod 2 = 0,\\\\\n-1,  \\text{if } x_n \\bmod 2 = 1.\n\\end{cases}\n$$\n经过 $N$ 步后的净位移是\n$$\nS_N = \\sum_{n=1}^{N} s_n.\n$$\n在一个物理上无偏的一维随机游走中，期望位移应为零，因此大的系统性漂移在这种情况下是非物理的。\n\n编写一个完整的程序，对下面的每个测试用例，计算以下量：\n- 整数 $S_N$。\n- 浮点数 $f_{\\mathrm{even}}$，即在生成的数值 $\\{x_1,\\dots,x_N\\}$ 中偶数的比例，定义为\n$$\nf_{\\mathrm{even}} =\n\\begin{cases}\n\\frac{1}{N}\\left|\\{n \\in \\{1,\\dots,N\\} : x_n \\bmod 2 = 0\\}\\right|,  \\text{if } N  0,\\\\\n0.0,  \\text{if } N = 0,\n\\end{cases}\n$$\n以小数形式报告。\n- 布尔值 $D$，如果每步的绝对平均位移满足\n$$\n\\left|\\frac{S_N}{\\max(N,1)}\\right| \\ge \\theta,\n$$\n则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$，其中阈值为 $\\theta = 0.9$（无量纲）。\n- 布尔值 $R$，当且仅当 LCG 参数与历史上的 RANDU 选择 $a = 65539$, $c = 0$, $m = 2^{31}$ 相匹配时为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n使用以下测试用例，每个用例以 $(a,c,m,x_0,N)$ 的形式给出，所有量均为整数：\n- 测试 $1$：$a = 65539$, $c = 0$, $m = 2^{31}$, $x_0 = 1$, $N = 10000$。\n- 测试 $2$：$a = 65539$, $c = 0$, $m = 2^{31}$, $x_0 = 2$, $N = 10000$。\n- 测试 $3$：$a = 1664525$, $c = 1013904223$, $m = 2^{32}$, $x_0 = 123456789$, $N = 200000$。\n- 测试 $4$：$a = 16807$, $c = 0$, $m = 2147483647$, $x_0 = 1$, $N = 200000$。\n- 测试 $5$（边界情况）：$a = 65539$, $c = 0$, $m = 2^{31}$, $x_0 = 1$, $N = 0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个顶层列表，每个测试用例对应一个条目，并保持上述顺序。每个条目本身必须是一个形式如下的列表\n$$\n[S_N,\\ f_{\\mathrm{even}},\\ D,\\ R].\n$$\n例如，整个打印行必须看起来像\n$$\n[[S_1,f_{\\mathrm{even},1},D_1,R_1],[S_2,f_{\\mathrm{even},2},D_2,R_2],\\dots,[S_5,f_{\\mathrm{even},5},D_5,R_5]],\n$$\n不需要空格，并且所有布尔值都打印为 $\\mathrm{True}$ 或 $\\mathrm{False}$。不涉及物理单位，所有报告的量都是无量纲的。",
            "solution": "所陈述的问题是有效的。这是一个定义明确的计算练习，其基础是计算物理和数论的基本原理，特别是使用线性同余生成器（LCG）生成和分析伪随机数。所有参数、定义和要求的输出都以数学精度指定，不存在科学或逻辑上的矛盾、歧义或信息缺失。该问题是自包含的并且在计算上是可行的。\n\n任务是模拟一个随机游走，其步长由 LCG 生成的数字的奇偶性决定，并计算此游走的几个统计特性。LCG 由递推关系定义：\n$$\nx_{n+1} \\equiv (a x_n + c) \\pmod m\n$$\n其中 $a$ 是乘数，$c$ 是增量，$m$ 是模数，$x_0$ 是初始种子。所有这些都是整数。\n\n模拟进行 $N$ 步。对于从 $1$ 到 $N$ 的每一步 $n$，我们首先生成数字 $x_n$，然后确定行走者的步长 $s_n$。伪随机数序列为 $\\{x_1, x_2, \\dots, x_N\\}$，它是从给定的种子 $x_0$ 开始生成的。步长 $s_n$ 是根据 $x_n$ 的奇偶性定义的：\n$$\ns_n =\n\\begin{cases}\n+1,  \\text{if } x_n \\bmod 2 = 0 \\text{ (even)}\\\\\n-1,  \\text{if } x_n \\bmod 2 = 1 \\text{ (odd)}\n\\end{cases}\n$$\n经过 $N$ 步后的总位移 $S_N$ 是各个步长的总和：\n$$\nS_N = \\sum_{n=1}^{N} s_n\n$$\n\n解决方案需要为每个给定的测试用例 $(a, c, m, x_0, N)$ 计算四个量：\n1.  $S_N$：净整数位移。\n2.  $f_{\\mathrm{even}}$：生成的数字 $\\{x_1, \\dots, x_N\\}$ 中偶数的比例。\n3.  $D$：一个指示是否存在显著漂移的布尔值。\n4.  $R$：一个指示 LCG 参数是否与历史上的 RANDU 生成器相对应的布尔值。\n\n给定测试用例的算法过程如下：\n\n首先，我们处理 $N=0$ 的边界情况。没有生成任何数字。总位移 $S_0$ 是一个空和，即为 $0$。偶数比例 $f_{\\mathrm{even}}$ 定义为 $0.0$。漂移条件 $D$ 为 $\\left|\\frac{S_0}{\\max(0,1)}\\right| \\ge \\theta$，计算结果为 $\\left|\\frac{0}{1}\\right| \\ge 0.9$，即 $0 \\ge 0.9$，这是假的。所以，$D = \\mathrm{False}$。RANDU 检查 $R$ 仅取决于输入参数 $a$、$c$ 和 $m$。\n\n对于 $N  0$ 的一般情况，我们执行迭代模拟：\n1.  初始化状态变量：设当前 LCG 值为 `current_x` $= x_0$。初始化总位移 `displacement` $= 0$ 和偶数计数器 `num_even` $= 0$。\n2.  从 $n=1$ 迭代到 $N$：\n    a. 生成序列中的下一个数：`current_x` $= (a \\cdot \\text{current\\_x} + c) \\pmod m$。此值对应于 $x_n$。注意，Python 的 `%` 运算符处理负数结果的方式与数学上的模运算不同，但由于 $a, c, m, x_0$ 都是非负的，这不是一个问题。中间乘积 $a \\cdot \\text{current\\_x}$ 可能会超过标准64位整数的容量，但 Python 的任意精度整数会自动处理这个问题。\n    b. 检查 `current_x` 的奇偶性。如果 `current_x` $\\bmod 2 = 0$，则步长为 $s_n = +1$ 并且 `num_even` 递增。否则，步长为 $s_n = -1$。\n    c. 更新总位移：`displacement` = `displacement` $+ s_n$。\n3.  循环完成后，最终的 `displacement` 就是 $S_N$，偶数的总数是 `num_even`。\n\n计算出 $S_N$ 和 `num_even` 后，确定其余的输出：\n1.  $S_N$ 是 `displacement` 的最终值。\n2.  $f_{\\mathrm{even}} = \\frac{\\text{num\\_even}}{N}$。这必须是浮点数除法。\n3.  如果 $\\left|\\frac{S_N}{N}\\right| \\ge 0.9$ 则 $D$ 为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。绝对值是必要的。\n4.  如果 $a = 65539$，$c = 0$ 且 $m = 2^{31}$ 则 $R$ 为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。这是对输入参数的直接比较。\n\n一些测试用例表现出可以解析推导的属性。例如，使用奇数种子的 RANDU 生成器（$a=65539$, $c=0$, $m=2^{31}$）将只产生奇数。这是因为 $a$ 是奇数，对于任何奇数 $x_n$，乘积 $a \\cdot x_n$ 也是奇数。模数 $m=2^{31}$ 是2的幂。一个奇数除以2的幂的余数总是奇数。因此，所有的步长 $s_n$ 都将是 $-1$，导致 $S_N = -N$ 和 $f_{\\mathrm{even}} = 0.0$。相反，如果种子是偶数，所有后续的数字都将是偶数，导致 $S_N = N$ 和 $f_{\\mathrm{even}} = 1.0$。\n\n另一个案例涉及参数（$a=1664525$, $c=1013904223$, $m=2^{32}$），其中 $a$ 和 $c$ 是奇数，而 $m$ 是2的幂。如果 $x_n$ 是偶数，$x_{n+1} = (a \\cdot x_n + c) \\pmod m = (\\text{奇数} \\cdot \\text{偶数} + \\text{奇数}) \\pmod {\\text{偶数}} = \\text{奇数} \\pmod{\\text{偶数}}$，结果是奇数。如果 $x_n$ 是奇数，$x_{n+1} = (\\text{奇数} \\cdot \\text{奇数} + \\text{奇数}) \\pmod {\\text{偶数}} = \\text{偶数} \\pmod{\\text{偶数}}$，结果是偶数。序列 $\\{x_n\\}$ 的奇偶性将严格交替。这导致步长完全平衡，净位移 $S_N$ 为 $0$ 或 $\\pm 1$，具体取决于 $N$ 和初始奇偶性。\n\n对于一个通用的 LCG，例如使用素数模数 $m=2^{31}-1$ 的 LCG，这些简单的相关性不存在，需要直接模拟。下面的程序为所有测试用例实现了这个完整的模拟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the random walk problem for the given test cases.\n    \"\"\"\n    # Test cases are given as (a, c, m, x_0, N)\n    test_cases = [\n        # Test 1: RANDU, odd seed\n        (65539, 0, 2**31, 1, 10000),\n        # Test 2: RANDU, even seed\n        (65539, 0, 2**31, 2, 10000),\n        # Test 3: Numerical Recipes LCG\n        (1664525, 1013904223, 2**32, 123456789, 200000),\n        # Test 4: Park-Miller LCG\n        (16807, 0, 2147483647, 1, 200000),\n        # Test 5: Boundary case N=0\n        (65539, 0, 2**31, 1, 0),\n    ]\n\n    results = []\n    \n    # Threshold for drift detection\n    theta = 0.9\n\n    for case in test_cases:\n        a, c, m, x_0, N = case\n\n        # Initialize results\n        S_N = 0\n        f_even = 0.0\n        \n        # Handle the N  0 case\n        if N  0:\n            num_even = 0\n            current_x = x_0\n            \n            for _ in range(N):\n                # Generate the next number in the LCG sequence\n                # Python's integers handle arbitrary size, which is essential here\n                current_x = (a * current_x + c) % m\n                \n                # Determine step based on parity and update accumulators\n                if current_x % 2 == 0:\n                    S_N += 1\n                    num_even += 1\n                else:\n                    S_N -= 1\n            \n            f_even = float(num_even) / N\n        \n        # For N=0, S_N remains 0 and f_even is defined as 0.0\n        \n        # Calculate boolean D for drift\n        # The denominator is max(N, 1) to avoid division by zero for N=0\n        mean_displacement_abs = abs(S_N / max(N, 1))\n        D = mean_displacement_abs = theta\n        \n        # Calculate boolean R for RANDU parameters\n        is_randu = (a == 65539 and c == 0 and m == 2**31)\n        R = is_randu\n        \n        results.append([S_N, f_even, D, R])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces. \n    # To meet the \"no spaces required\" rule, we remove them.\n    # Example: str([[1, 2], [3, 4]]) - \"[[1, 2], [3, 4]]\"\n    # After replace: \"[[1,2],[3,4]]\"\n    output_str = str(results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "除了理论缺陷，代码实现中的错误同样具有毁灭性。这些错误往往十分隐蔽，却能悄无声息地毁掉整个模拟。 本次实践聚焦于一个常见且关键的编程陷阱：在定宽算术中的整数溢出。通过对比一个正确的 LCG 实现和一个存在溢出错误的实现，你将定量地分析这个看似微小的编程失误是如何灾难性地缩短生成器的周期，从而使其对于严谨的科学工作完全失效。",
            "id": "2408851",
            "problem": "您需要实现一个线性同余生成器 (LCG)，并严格量化在定宽整数算术中执行乘法会如何缩短序列最终达到的周期。从 LCG 的核心定义开始，它是一个关于整数模某个模数的一阶递推，由以下映射给出\n$$\nX_{n+1} = (a X_n + c) \\bmod m,\n$$\n其中对于所有 $n$，都有 $X_n \\in \\{0,1,\\dots,m-1\\}$，$a$ 是乘数，$c$ 是增量，$m$ 是模数。在具有无限精度（或精确模算术）的正确实现中，此递推在大小为 $m$ 的有限状态空间上定义了一个确定性映射，因此由于状态空间的有限性，每个轨道最终都是周期的。在定宽硬件上运行的实际代码中，乘积 $a \\cdot X_n$ 在以 $w$ 位算术计算时可能会溢出。一个不正确的实现，它在无符号 $w$ 位算术中计算乘积，然后才对 $m$ 取模，实际上是按照以下修改后的映射演化的：\n$$\nX_{n+1}^{\\text{bug}} \\;=\\; \\big( \\, \\big( (a X_n) \\bmod 2^w \\big) + c \\, \\big) \\bmod m,\n$$\n这可能会破坏预期的周期属性。\n\n任务：\n- 实现两种更新规则：正确的 LCG 更新 $X_{n+1} = (a X_n + c) \\bmod m$ 和有错误的更新 $X_{n+1}^{\\text{bug}} = \\big( \\big( (a X_n) \\bmod 2^w \\big) + c \\big) \\bmod m$。\n- 对于每个测试用例，从提供的种子 $X_0$ 开始，通过迭代更新计算最终达到的周期的长度。具体来说，将映射视为有限集上的确定性函数，并确定从 $X_0$ 开始的轨道遇到的周期长度（忽略任何不重复的瞬态前缀）。对于每种情况，报告两个整数：正确更新的周期长度和有错误更新的周期长度，以及一个布尔值，指示有错误的周期是否严格短于正确的周期。\n\n您可以假设的基础理论：\n- 状态空间 $\\{0,1,\\dots,m-1\\}$ 是有限的，因此其上的任何确定性映射产生的轨道最终都是周期的。\n- 整数模 $n$ 的算术定义了环 $\\mathbb{Z}/n\\mathbb{Z}$，而对 2 的幂 $2^w$ 取模模拟了 $w$ 位无符号整数算术的回绕行为。\n\n算法要求：\n- 使用有限状态迭代的基本原理来检测周期：跟踪访问过的状态及其首次出现的索引；当一个状态重复出现时，周期长度等于当前步数索引与该重复状态首次出现时的索引之差。\n\n测试套件：\n实现您的程序，使其精确运行以下四个测试用例，每个用例指定为一个元组 $\\big(m,a,c,X_0,w\\big)$：\n1. $\\big( m = 2^{16} = 65536,\\; a = 5,\\; c = 1,\\; X_0 = 0,\\; w = 12 \\big)$.\n2. $\\big( m = 2^{15} = 32768,\\; a = 1,\\; c = 1,\\; X_0 = 12345,\\; w = 8 \\big)$.\n3. $\\big( m = 2^{12} = 4096,\\; a = 109,\\; c = 0,\\; X_0 = 1,\\; w = 8 \\big)$.\n4. $\\big( m = 10007,\\; a = 1,\\; c = 4567,\\; X_0 = 789,\\; w = 32 \\big)$.\n\n输出规范：\n- 对于每个测试用例，计算并收集一个包含三个条目的列表：正确的周期长度（整数）、有错误的周期长度（整数），以及一个布尔值，该布尔值当且仅当有错误的长度严格小于正确的长度时为真。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身就是如上所述的列表。例如，包含两个用例的输出应类似于 \"[[L1_correct,L1_bug,B1],[L2_correct,L2_bug,B2]]\"。不得有多余的文本，也不需要空格。\n\n此问题不涉及物理单位或角度，因此不应报告任何此类值。所有数值必须以普通整数形式生成，布尔值应呈现为 \"True\" 或 \"False\"。",
            "solution": "该问题是有效的。它在科学上是合理的、适定的和客观的。它涉及计算科学中的一个标准主题：伪随机数生成器的属性，特别是线性同余生成器（LCG）的周期结构。将正确的实现与一个带有模拟整数溢出错误的实现进行比较的任务，是理解数值稳定性和实现陷阱的一个实用且有意义的练习。所有定义和参数都已提供，使得问题明确且可解。\n\n解决方案通过直接模拟由两种 LCG 更新规则生成的状态序列来获得。有限状态空间上任何确定性序列的周期长度通过检测第一个重复的状态来找到。\n\n设状态空间为 $S = \\{0, 1, \\dots, m-1\\}$。序列 $\\{X_n\\}_{n=0}^\\infty$ 由函数 $f: S \\to S$ 生成，其中 $X_{n+1} = f(X_n)$。因为 $S$ 是一个有限集，所以任何这样的序列最终都必须重复一个状态，此时它就变得周期性。目标是确定这个周期的长度，即周期长度。\n\n我们采用一个标准的周期检测算法。我们从初始种子 $X_0$ 开始迭代映射 $f$。我们维护一个可以称为 $visited$ 的字典，用于存储遇到的每个唯一状态及其首次出现的步数索引。在每一步 $n \\ge 0$，我们计算状态 $X_n$。如果 $X_n$ 已经存在于 $visited$ 字典中，则说明找到了一个周期。该周期的长度由 $L = n - visited[X_n]$ 给出。索引从 $visited[X_n]$ 到 $n-1$ 的状态序列构成了遇到的第一个完整周期。\n\n该问题指定了 2 个不同的更新函数 $f$。\n\n$1$. 正确的 LCG 更新规则由整数模 $m$ 环上的仿射变换给出：\n$$\nf_{\\text{correct}}(X_n) = (a X_n + c) \\bmod m\n$$\n该计算假定在最终对 $m$ 取模之前，乘积 $a X_n$ 是以足够的精度计算的（即，使用可以超过机器字长的整数）。\n\n$2$. 有错误的 LCG 更新规则模拟了定宽 $w$ 位无符号整数算术的行为，其中乘法可能会溢出。这由以下映射定义：\n$$\nf_{\\text{bugged}}(X_n) = \\big( \\big( (a X_n) \\bmod 2^w \\big) + c \\big) \\bmod m\n$$\n在这种情况下，乘积 $a X_n$ 首先被隐式地对 $2^w$ 取模，这正确地模拟了 $w$ 位无符号整数的回绕行为。然后，这个中间结果被用于 LCG 计算的其余部分。\n\n我们设计了一个单一的计算过程来寻找周期长度。该过程接受生成器参数 $(m, a, c, X_0, w)$ 和一个布尔标志，用于在 $f_{\\text{correct}}$ 和 $f_{\\text{bugged}}$ 之间进行选择。\n\n该算法的结构如下：\n设函数为 `find_cycle_length(m, a, c, x0, w, use_bugged_rule)`。\n$1$. 初始化一个空字典 $visited$。\n$2$. 初始化当前状态 $x = x_0$ 和步数计数器 $step = 0$。\n$3$. 进入一个循环，只要状态 $x$ 尚未记录在 $visited$ 中，就继续循环：\n    a. 记录当前状态和步数：$visited[x] = step$。\n    b. 计算下一个状态。如果 $use\\_bugged\\_rule$ 为真，则应用 $f_{\\text{bugged}}(x)$。否则，应用 $f_{\\text{correct}}(x)$。Python 的任意精度整数非常适合此目的，因为它们自然地处理了正确乘积 $a \\cdot x$ 所需的“无限精度”要求。更新规则实现如下：\n       - 正确：`x = (a * x + c) % m`\n       - 错误：`x = (((a * x) % (2**w)) + c) % m`\n    c. 增加步数计数器：$step = step + 1$。\n$4$. 当新计算出的状态 $x$ 在 $visited$ 中被找到时，循环终止。其首次出现的索引是 $first\\_occurrence = visited[x]$。\n$5$. 周期长度计算为 $length = step - first\\_occurrence$。返回此值。\n\n对提供的 4 个测试用例中的每一个执行此过程。对于每个用例，我们使用 $f_{\\text{correct}}$ 计算周期长度 $L_{\\text{correct}}$，并使用 $f_{\\text{bugged}}$ 计算周期长度 $L_{\\text{bugged}}$。然后生成一个布尔值，当且仅当 $L_{\\text{bugged}}  L_{\\text{correct}}$ 时为真。最终结果被收集并格式化为精确指定的字符串输出。",
            "answer": "```python\nimport numpy as np\n\ndef find_cycle_length(m, a, c, x0, w, is_bugged):\n    \"\"\"\n    Computes the cycle length of an LCG sequence.\n\n    Args:\n        m (int): The modulus.\n        a (int): The multiplier.\n        c (int): The increment.\n        x0 (int): The seed or starting value.\n        w (int): The bit width for the bugged multiplication.\n        is_bugged (bool): If True, use the bugged update rule.\n\n    Returns:\n        int: The length of the cycle.\n    \"\"\"\n    visited = {}\n    x = x0\n    step = 0\n    mod_w = 2**w\n\n    while x not in visited:\n        visited[x] = step\n        if is_bugged:\n            # Intermediate product overflows at w bits\n            term = (a * x) % mod_w\n            x = (term + c) % m\n        else:\n            # Correct update rule with exact intermediate product\n            x = (a * x + c) % m\n        step += 1\n\n    cycle_start_step = visited[x]\n    cycle_length = step - cycle_start_step\n    return cycle_length\n\ndef solve():\n    \"\"\"\n    Runs the specified test cases and prints the results.\n    \"\"\"\n    # Test suite: tuples of (m, a, c, X0, w)\n    test_cases = [\n        (2**16, 5, 1, 0, 12),\n        (2**15, 1, 1, 12345, 8),\n        (2**12, 109, 0, 1, 8),\n        (10007, 1, 4567, 789, 32),\n    ]\n\n    results = []\n    for m, a, c, x0, w in test_cases:\n        # Calculate cycle length for the correct LCG\n        l_correct = find_cycle_length(m, a, c, x0, w, is_bugged=False)\n        \n        # Calculate cycle length for the bugged LCG\n        l_bugged = find_cycle_length(m, a, c, x0, w, is_bugged=True)\n        \n        # Determine if the bugged cycle is strictly shorter\n        is_shorter = l_bugged  l_correct\n        \n        results.append([l_correct, l_bugged, is_shorter])\n\n    # Format the output string precisely as required, with no spaces.\n    formatted_results = []\n    for r in results:\n        # Python's str(bool) gives 'True' or 'False' as needed.\n        formatted_results.append(f\"[{r[0]},{r[1]},{str(r[2])}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}