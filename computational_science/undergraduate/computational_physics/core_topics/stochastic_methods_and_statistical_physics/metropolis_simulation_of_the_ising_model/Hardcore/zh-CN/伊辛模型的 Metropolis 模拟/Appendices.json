{
    "hands_on_practices": [
        {
            "introduction": "在深入学习像 Metropolis 这样的高级采样方法之前，理解统计力学中热力学平均值的基本定义至关重要。本练习将通过一个小型系统，让您通过遍历所有可能的状态来精确地计算可观测量。这个过程不仅能巩固您对配分函数和玻尔兹曼分布的理解，还能清晰地揭示为何对于大系统而言，蒙特卡洛方法是不可或缺的工具 。",
            "id": "2413243",
            "problem": "考虑一个由有限无向图上的自旋表示的二元观点系统。每个个体是一个由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的节点，其自旋为 $s_i \\in \\{-1,+1\\}$。设两个不同个体 $i$ 和 $j$ 之间的“友谊强度”为一个非负对称权重 $w_{ij} = w_{ji} \\ge 0$，且 $w_{ii} = 0$。我们假设 $i$ 和 $j$ 之间存在一条边当且仅当 $w_{ij}  0$。在温度为 $T  0$、外加均匀场为 $h$ 的情况下，一个构型 $s = (s_0,\\dots,s_{N-1})$ 的相互作用能由伊辛哈密顿量给出\n$$\nH(s) \\;=\\; -\\sum_{0 \\le i  j \\le N-1} J_{ij} \\, s_i s_j \\;-\\; h \\sum_{i=0}^{N-1} s_i,\n$$\n其中耦合常数 $J_{ij} = J_0 \\, w_{ij}$，$J_0  0$ 是一个均匀的耦合尺度。在玻尔兹曼常数 $k_B$ 等于 $1$ 的单位制下，构型 $s$ 的正则概率为\n$$\n\\mathbb{P}(s) \\;=\\; \\frac{1}{Z} \\exp\\!\\left(-\\frac{H(s)}{T}\\right), \\qquad Z \\;=\\; \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\!\\left(-\\frac{H(s)}{T}\\right).\n$$\n\n对于下面指定的每个测试用例，计算以下平衡可观测量：\n- 每个自旋的绝对磁化强度，\n$$\nm \\;=\\; \\frac{1}{N} \\, \\Big\\langle \\big| \\sum_{i=0}^{N-1} s_i \\big| \\Big\\rangle,\n$$\n- 每个自旋的能量，\n$$\ne \\;=\\; \\frac{1}{N} \\, \\langle H(s) \\rangle,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示在给定温度 $T$ 下关于 $\\mathbb{P}(s)$ 的正则期望。在这些单位中，所有量都是无量纲的。能量以 $J_0$ 为单位表示，温度以 $k_B = 1$ 的单位制表示。\n\n测试套件（每个用例由 $(N,\\{(i,j,w_{ij})\\},J_0,h,T)$ 完全指定）：\n- 用例 1：$N = 4$；加权边 $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$；$J_0 = 1.0$；$h = 0.0$；$T = 0.1$。\n- 用例 2：$N = 4$；加权边 $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$；$J_0 = 1.0$；$h = 0.0$；$T = 5.0$。\n- 用例 3：$N = 3$；加权边 $\\{(0,1,2.0),(1,2,0.5),(0,2,1.0)\\}$；$J_0 = 1.0$；$h = 0.0$；$T = 1.5$。\n- 用例 4：$N = 4$；加权边 $\\{(0,1,1.5),(2,3,1.5),(1,2,0.1)\\}$；$J_0 = 1.0$；$h = 0.2$；$T = 1.0$。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含四个用例的结果，格式为用方括号括起来的逗号分隔列表。每个用例的结果本身必须是一个双元素列表 $[m,e]$，其中 $m$ 和 $e$ 都使用标准四舍五入法精确到 $6$ 位小数。输出中不得有任何空格。\n- 具体来说，输出必须具有以下形式：\n$$\n[[m_1,e_1],[m_2,e_2],[m_3,e_3],[m_4,e_4]],\n$$\n其中每个 $m_k$ 和 $e_k$ 都是小数点后恰好有 $6$ 位数字的十进制数。\n\n不涉及角度或百分比；请勿使用角度单位或百分号。在指定的单位中，所有温度和能量都是无量纲的。问题完全由上述定义确定；仅使用提供的参数。您的代码必须严格使用上述测试套件，并以要求的单行格式生成最终输出。",
            "solution": "经过严格审查，问题陈述被认定为有效。它在科学上基于统计力学原理，对于其小系统规模而言是适定 (well-posed) 的，并以客观、数学的精度进行表述。它没有违反任何无效标准。该问题描述了有限、加权、无向图上的标准伊辛模型，并要求计算基本平衡可观测量：每个自旋的绝对磁化强度和每个自旋的能量。\n\n关键的观察点在于，对于测试用例中给出的少量自旋 $N$（$N=3$ 和 $N=4$），系统构型的总数 $2^N$ 非常小（分别为 $2^3 = 8$ 和 $2^4 = 16$）。这允许通过枚举所有可能的状态来直接、精确地计算配分函数和热力学期望值。这种方法在计算上是可行的，并能产生精确结果，从而避免了使用像 Metropolis 蒙特卡罗模拟这样的随机方法，后者只能提供统计估计。\n\n该解决方案基于统计力学中的正则系综原理。一个系统在给定温度 $T$ 下处于具有能量 $H(s)$ 的特定构型 $s$ 的概率由玻尔兹曼分布给出：\n$$\n\\mathbb{P}(s) = \\frac{1}{Z} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\n其中 $Z$ 是配分函数，它对概率分布进行归一化。它是对所有可能构型的玻尔兹曼因子求和：\n$$\nZ = \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\n给定构型 $s = (s_0, \\dots, s_{N-1})$ 的哈密顿量 $H(s)$ 定义为：\n$$\nH(s) = -\\sum_{0 \\le i  j \\le N-1} J_{ij} s_i s_j - h \\sum_{i=0}^{N-1} s_i\n$$\n耦合常数 $J_{ij}$ 由问题指定的友谊权重 $w_{ij}$ 和均匀耦合尺度 $J_0$ 导出，即 $J_{ij} = J_0 w_{ij}$。\n\n任何可观测量 $A(s)$ 的热力学期望值是通过对所有可能构型上的 $A(s)$ 进行加权平均来计算的，权重为其各自的概率：\n$$\n\\langle A \\rangle = \\sum_s A(s) \\mathbb{P}(s) = \\frac{1}{Z} \\sum_s A(s) \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\n需要计算的两个可观测量是：\n1.  每个自旋的能量，$e = \\frac{1}{N} \\langle H \\rangle$。\n2.  每个自旋的绝对磁化强度，$m = \\frac{1}{N} \\langle \\left| M \\right| \\rangle$，其中一个状态 $s$ 的总磁化强度是 $M(s) = \\sum_{i=0}^{N-1} s_i$。\n\n计算过程如下：\n首先，对于每个测试用例，我们构建对称的 $N \\times N$ 耦合矩阵 $J$，其中 $J_{ij} = J_0 w_{ij}$。\n其次，我们系统地生成所有 $2^N$ 个自旋构型 $s$。这通过遍历从 $0$ 到 $2^N - 1$ 的整数，并使用它们的二进制表示来定义自旋状态（例如，比特 $0 \\mapsto +1$，比特 $1 \\mapsto -1$）来实现。\n对于每个构型 $s$，我们计算其能量 $H(s)$ 和其总磁化强度的绝对值 $|M(s)|$。\n\n一个关键的数值考虑是玻尔兹曼因子 $\\exp(-H(s)/T)$ 的计算。当 $T$ 很小时，参数 $-H(s)/T$ 可能会变得非常大且为正，导致数值溢出。为确保稳定性，我们在进行指数运算之前，从所有能量中减去系统的最小能量 $H_{\\text{min}} = \\min_s H(s)$。期望值的计算在此平移下是不变的：\n$$\n\\langle A \\rangle = \\frac{\\sum_s A(s) \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}{\\sum_s \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}\n$$\n这种重新表述保证了指数函数的所有参数都小于或等于零，从而防止溢出并保持数值精度。\n\n每个测试用例的算法实现如下：\n1.  将 $\\langle H \\rangle$ 的分子、$\\langle |M| \\rangle$ 的分子和（平移后的）配分函数的求和项初始化为零。\n2.  遍历所有 $2^N$ 个状态。对于每个状态 $s$：\n    a.  计算 $H(s)$ 和 $|M(s)|$。\n    b.  计算平移后的玻尔兹曼因子 $W'(s) = \\exp(-(H(s) - H_{\\text{min}})/T)$。\n    c.  更新求和项：将 $W'(s)$ 加到配分函数求和项中，将 $H(s) \\cdot W'(s)$ 加到能量求和项中，并将 $|M(s)| \\cdot W'(s)$ 加到磁化强度求和项中。\n3.  遍历完所有状态后，通过将累积的求和项除以平移后的玻尔兹曼因子的总和，来计算最终的期望值 $\\langle H \\rangle$ 和 $\\langle |M| \\rangle$。\n4.  最后，将这些期望值除以 $N$ 以获得每个自旋的量 $e$ 和 $m$。然后按照问题陈述的要求对它们进行格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observables(N, edges, J0, h, T):\n    \"\"\"\n    Calculates equilibrium observables for an Ising model on a graph by exact enumeration.\n    \n    Args:\n        N (int): Number of spins.\n        edges (list): List of tuples (i, j, w_ij) representing weighted edges.\n        J0 (float): Uniform coupling scale.\n        h (float): External uniform field.\n        T (float): Temperature (with k_B = 1).\n        \n    Returns:\n        tuple: A tuple (m, e) containing the absolute magnetization per spin\n               and the energy per spin.\n    \"\"\"\n    # 1. Construct the coupling matrix J\n    J_mat = np.zeros((N, N))\n    for i, j, w_ij in edges:\n        J_mat[i, j] = J0 * w_ij\n        J_mat[j, i] = J0 * w_ij\n\n    num_states = 1  N\n    all_energies = np.zeros(num_states)\n    all_abs_mags = np.zeros(num_states)\n\n    # 2. Enumerate all 2^N states and calculate H and |M| for each\n    for i in range(num_states):\n        # Generate spin configuration s from the bits of integer i.\n        # bit 0 -> spin +1, bit 1 -> spin -1\n        s = np.array([1 if not ((i >> j)  1) else -1 for j in range(N)])\n        \n        # Calculate Hamiltonian H(s) = -0.5 * s.T @ J_mat @ s - h * sum(s)\n        interaction_energy = -0.5 * np.dot(s, np.dot(J_mat, s))\n        field_energy = -h * np.sum(s)\n        H_s = interaction_energy + field_energy\n        \n        M_s = np.sum(s)\n        \n        all_energies[i] = H_s\n        all_abs_mags[i] = np.abs(M_s)\n        \n    # 3. Calculate expectation values using numerically stable method\n    if T == 0:\n        # In the zero-temperature limit, the system occupies the ground state(s).\n        min_energy = np.min(all_energies)\n        ground_state_indices = np.where(all_energies == min_energy)[0]\n        \n        avg_H = min_energy\n        avg_abs_M = np.mean(all_abs_mags[ground_state_indices])\n    else:\n        # For T > 0, use Boltzmann statistics with a shift to avoid overflow.\n        min_energy = np.min(all_energies)\n        shifted_boltzmann_factors = np.exp(-(all_energies - min_energy) / T)\n        \n        Z_prime = np.sum(shifted_boltzmann_factors)\n        \n        avg_H = np.sum(all_energies * shifted_boltzmann_factors) / Z_prime\n        avg_abs_M = np.sum(all_abs_mags * shifted_boltzmann_factors) / Z_prime\n\n    # 4. Compute per-spin observables\n    e = avg_H / N\n    m = avg_abs_M / N\n\n    return m, e\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (N, edges, J0, h, T)\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 0.1),\n        # Case 2\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 5.0),\n        # Case 3\n        (3, [(0, 1, 2.0), (1, 2, 0.5), (0, 2, 1.0)], 1.0, 0.0, 1.5),\n        # Case 4\n        (4, [(0, 1, 1.5), (2, 3, 1.5), (1, 2, 0.1)], 1.0, 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, edges, J0, h, T = case\n        m, e = calculate_observables(N, edges, J0, h, T)\n        \n        # Format each [m, e] pair as a string with 6 decimal places and no spaces.\n        result_str = f\"[{m:.6f},{e:.6f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于任何现实尺寸的系统，精确枚举在计算上都是不可行的，这正是 Metropolis 算法作为强大采样工具的用武之地。本练习将指导您完整地实现一个 Metropolis 模拟程序，用于研究伊辛模型在不同边界条件（周期性、开放式和螺旋式）下的行为。您将亲手处理有限尺寸效应这一计算物理学中的核心议题，并学习到一种重要的加速技巧——棋盘格更新法，从而对蒙特卡洛模拟获得更深入的实践认识 。",
            "id": "2413296",
            "problem": "您的任务是设计并执行一个二维伊辛模型的梅特罗波利斯单自旋翻转模拟，以量化不同边界条件如何改变磁化强度的有限尺寸修正。您的实现必须是一个完整、可运行的程序。该模型由线性尺寸为 $L$ 的方形晶格上的自旋 $s_i \\in \\{-1,+1\\}$ 组成，其哈密顿量为\n$$\nH(\\{s\\}) = - J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\n其中 $J0$ 且 $\\langle i,j \\rangle$ 表示由边界条件定义的最近邻对。使用 $J=1$ 和玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此温度 $T$ 是无量纲的。必须采用带有单自旋翻转提议的梅特罗波利斯算法，使用接受概率\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right),\n$$\n其中 $\\Delta E$ 是由提议的翻转引起的能量变化，且 $\\beta = 1/T$。\n\n需要实现的边界条件：\n- 周期性边界条件 (PBC)：坐标为 $(x,y)$ 的格点的邻居是 $((x+1)\\!\\!\\mod L, y)$、 $ ((x-1)\\!\\!\\mod L, y)$、 $(x, (y+1)\\!\\!\\mod L)$ 和 $(x, (y-1)\\!\\!\\mod L)$。\n- 开放边界条件 (OBC)：晶格外的邻居不存在，对 $H$ 没有贡献。\n- 螺旋边界条件 (HBC)：将晶格展平为一维索引 $i = x + L y \\in \\{0,\\dots,L^2-1\\}$，并使用邻居 $\\{(i+1)\\!\\!\\mod N, (i-1)\\!\\!\\mod N, (i+L)\\!\\!\\mod N, (i-L)\\!\\!\\mod N\\}$，其中 $N=L^2$。为提高算法效率，您必须使用棋盘格（红黑）并行梅特罗波利斯更新；为严格保持螺旋边界条件下子晶格更新的独立性，请选择奇数 $L$。\n\n单位自旋磁化强度为\n$$\nm(\\{s\\}) = \\frac{1}{N}\\left|\\sum_{i=1}^N s_i\\right|, \\quad N=L^2.\n$$\n将温度为 $T$、尺寸为 $L$ 的晶格在边界条件 $\\mathcal{B}$ 下的有限尺寸修正定义为\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T},\n$$\n其中 $\\langle m \\rangle_{L,\\mathcal{B},T}$ 是平衡态下 $m(\\{s\\})$ 的蒙特卡洛平均值，而 $m_{\\infty}(T)$ 是当 $T  T_c$ 时已知的精确无限晶格磁化强度。您的模拟应从随机的“热”态开始，并在进行$N_{\\mathrm{meas}} = 2000$次测量扫描之前，运行$N_{\\mathrm{therm}} = 1000$次热化扫描。为保证可复现性，为每个单独的运行指定一个唯一的随机种子。\n\n您的任务是计算以下测试用例的$\\Delta m(L,\\mathcal{B},T)$：\n- (BC, L, T, 种子): (PBC, 9, 2.2, 20231101), (OBC, 9, 2.2, 20231102), (HBC, 9, 2.2, 20231103)\n- (BC, L, T, 种子): (PBC, 13, 2.2, 20231104), (OBC, 13, 2.2, 20231105), (HBC, 13, 2.2, 20231106)\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的六个值的逗号分隔列表，顺序为上面测试用例的顺序。每个值必须是$\\Delta m$，四舍五入到小数点后六位。\n- 例如，一个有效的输出格式类似于`[v1,v2,v3,v4,v5,v6]`。\n- 所有量都是无量纲的，并使用$J=k_B=1$的单位。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它具有科学依据、是适定的、客观且内部一致的。它提出了计算统计力学中的一个标准问题，并明确指定了所有必要的参数、定义和约束。\n\n任务是执行二维伊辛模型的梅特罗波利斯蒙特卡洛模拟，以计算在不同晶格尺寸和边界条件下自发磁化强度的有限尺寸修正 $\\Delta m$。该解决方案源于统计力学的基本原理和蒙特卡洛方法。\n\n基本原理是，在热平衡状态下，一个物理系统处于具有能量 $H(\\{s\\})$ 的微观状态 $\\{s\\}$ 的概率由玻尔兹曼分布给出：\n$$\nP(\\{s\\}) = \\frac{1}{Z} e^{-\\beta H(\\{s\\})}\n$$\n其中 $Z$ 是配分函数，$\\beta = 1/(k_{\\mathrm{B}}T)$。对于方形晶格上的伊辛模型，哈密顿量由下式给出：\n$$\nH(\\{s\\}) = -J \\sum_{\\langle i,j \\rangle} s_i s_j\n$$\n其中 $J=1$ 且 $k_{\\mathrm{B}}=1$。\n\n对于任何非平凡的系统尺寸，直接从玻尔兹曼分布中抽样都是难以处理的。因此，我们采用马尔可夫链蒙特卡洛 (MCMC) 方法，特别是梅特罗波利斯算法，来生成一系列根据 $P(\\{s\\})$ 分布的状态。该算法通过满足细致平衡条件来确保系统向平衡态演化。对于提议的单自旋翻转 $s_k \\to -s_k$，其梅特罗波利斯转移规则由接受概率决定：\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right)\n$$\n其中 $\\Delta E$ 是翻转导致的能量变化。对于自旋 $s_k$ 的翻转，能量变化为：\n$$\n\\Delta E = E_{\\text{final}} - E_{\\text{initial}} = -J \\sum_{\\langle k,j \\rangle} (-s_k)s_j - \\left(-J \\sum_{\\langle k,j \\rangle} s_k s_j\\right) = 2J s_k \\sum_{\\langle k,j \\rangle} s_j\n$$\n此处，$\\sum_{\\langle k,j \\rangle} s_j$ 是格点 $k$ 邻近自旋的总和。\n\n为提高计算效率，我们实现了一个棋盘格更新方案。晶格格点被划分为两个独立的子晶格，“红”格和“黑”格，类似于棋盘。如果 $(x+y)$ 是偶数，则格点 $(x,y)$ 是红格；如果是奇数，则是黑格。关键在于，红格的所有最近邻都是黑格，反之亦然。这种独立性允许对一个子晶格上的所有自旋进行同时（矢量化）更新，然后对另一个子晶格上的所有自旋进行同时更新。一次完整的蒙特卡洛扫描包括更新红子晶格，然后更新黑子晶格。\n\n每个测试用例的模拟协议如下：\n1.  **初始化**：系统被初始化为一个“热”态，其中每个自旋 $s_i$ 以相等的概率被随机赋值为 $+1$ 或 $-1$。为了可复现性，会为一个合适的随机数生成器设置种子。\n2.  **热化**：系统演化指定的的热化扫描次数 $N_{\\mathrm{therm}}$。在此阶段，系统从其随机初始状态弛豫至热平衡态。不进行测量。\n3.  **测量**：热化之后，模拟继续进行 $N_{\\mathrm{meas}}$ 次测量扫描。每次完整扫描后，计算并记录瞬时单位自旋绝对磁化强度 $m(\\{s\\}) = \\frac{1}{N}|\\sum_i s_i|$。\n4.  **平均**：通过对测量阶段收集的 $m(\\{s\\})$ 瞬时值进行平均，来估计磁化强度的平衡期望值 $\\langle m \\rangle_{L,\\mathcal{B},T}$。\n\n邻居和的计算严重依赖于边界条件 ($\\mathcal{B}$)：\n-   **周期性边界条件 (PBC)**：将晶格视为一个环面。通过对其坐标应用模 $L$ 运算来找到一个格点的邻居。这可以通过在二维数组上使用 `numpy.roll` 来高效实现。\n-   **开放边界条件 (OBC)**：由于任何延伸到晶格边界之外的连接都不存在，边缘和角落的自旋的邻居少于四个。这通过构建邻居和数组，并使用排除边界的适当数组切片来添加来自每个方向的贡献来实现。\n-   **螺旋边界条件 (HBC)**：将 $L \\times L$ 晶格展平为一个大小为 $N=L^2$ 的一维数组。索引为 $i$ 的格点的邻居位于索引 $(i\\pm 1) \\pmod N$ 和 $(i\\pm L) \\pmod N$ 处。如前所述，对于奇数 $L$，此构型与棋盘格更新方案兼容。这可以通过在一维数组上使用 `numpy.roll` 来高效实现。\n\n最后，使用为 $T  T_c$（其中 $T_c = 2/\\ln(1+\\sqrt{2}) \\approx 2.269$ 是二维伊辛模型的精确临界温度）的 Onsager 精确解来计算无限晶格磁化强度：\n$$\nm_{\\infty}(T) = \\left(1 - \\frac{1}{\\sinh^4(2\\beta J)}\\right)^{1/8}\n$$\n对于 $T \\ge T_c$, $m_{\\infty}(T) = 0$。问题中给出的温度 $T=2.2$ 低于 $T_c$，因此 $m_{\\infty}(2.2)  0$。然后可以计算每个用例的有限尺寸修正 $\\Delta m = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T}$ 并报告。该方法是解决此问题的标准且高效的数值方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Ising model simulations and compute finite-size corrections.\n    \"\"\"\n\n    def calculate_avg_m(L, T, bc_type, n_therm, n_meas, seed):\n        \"\"\"\n        Performs a Metropolis simulation of the 2D Ising model.\n\n        Args:\n            L (int): Linear size of the lattice.\n            T (float): Temperature.\n            bc_type (str): Boundary condition type ('PBC', 'OBC', 'HBC').\n            n_therm (int): Number of thermalization sweeps.\n            n_meas (int): Number of measurement sweeps.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            float: The time-averaged absolute magnetization per spin.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        beta = 1.0 / T\n        N = L * L\n        J = 1.0\n\n        # Initialize spins and checkerboard masks\n        if bc_type == 'HBC':\n            spins = rng.choice([-1, 1], size=N)\n            # Create 2D indices to define masks, then flatten\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = ((x + y) % 2 == 0).flatten()\n            mask_black = ((x + y) % 2 == 1).flatten()\n        else: # PBC, OBC\n            spins = rng.choice([-1, 1], size=(L, L))\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = (x + y) % 2 == 0\n            mask_black = (x + y) % 2 == 1\n        \n        num_red = np.sum(mask_red)\n        num_black = np.sum(mask_black)\n\n        def update_sublattice(spins, mask, num_sites_in_mask):\n            \"\"\"Applies one parallel update to a sublattice.\"\"\"\n            # Calculate sum of neighbors for all sites\n            if bc_type == 'PBC':\n                neighbors_sum = (np.roll(spins, 1, axis=0) + np.roll(spins, -1, axis=0) +\n                                 np.roll(spins, 1, axis=1) + np.roll(spins, -1, axis=1))\n            elif bc_type == 'OBC':\n                neighbors_sum = np.zeros_like(spins, dtype=np.int8)\n                neighbors_sum[1:, :] += spins[:-1, :]  # Neighbors from top\n                neighbors_sum[:-1, :] += spins[1:, :]  # Neighbors from bottom\n                neighbors_sum[:, 1:] += spins[:, :-1]  # Neighbors from left\n                neighbors_sum[:, :-1] += spins[:, 1:]  # Neighbors from right\n            elif bc_type == 'HBC':\n                neighbors_sum = (np.roll(spins, 1) + np.roll(spins, -1) +\n                                 np.roll(spins, L) + np.roll(spins, -L))\n\n            sublattice_spins = spins[mask]\n            sublattice_neighbors_sum = neighbors_sum[mask]\n\n            # Calculate energy change for a flip for all spins on the sublattice\n            delta_E = 2.0 * J * sublattice_spins * sublattice_neighbors_sum\n            \n            # Metropolis acceptance condition\n            accept = (delta_E = 0) | (rng.random(size=num_sites_in_mask)  np.exp(-beta * delta_E))\n            \n            # Apply flips. Must assign back to the masked array to modify in place.\n            new_sublattice_spins = sublattice_spins.copy()\n            new_sublattice_spins[accept] *= -1\n            spins[mask] = new_sublattice_spins\n            \n            return spins\n\n        # Thermalization sweeps\n        for _ in range(n_therm):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n\n        # Measurement sweeps\n        magnetization_values = []\n        for _ in range(n_meas):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n            m = np.abs(np.sum(spins)) / N\n            magnetization_values.append(m)\n        \n        return np.mean(magnetization_values)\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        ('PBC', 9, 2.2, 1000, 2000, 20231101),\n        ('OBC', 9, 2.2, 1000, 2000, 20231102),\n        ('HBC', 9, 2.2, 1000, 2000, 20231103),\n        ('PBC', 13, 2.2, 1000, 2000, 20231104),\n        ('OBC', 13, 2.2, 1000, 2000, 20231105),\n        ('HBC', 13, 2.2, 1000, 2000, 20231106),\n    ]\n\n    # Calculate exact infinite-lattice magnetization for T=2.2\n    T_val = 2.2\n    Tc = 2.0 / np.log(1.0 + np.sqrt(2.0))\n    if T_val  Tc:\n        m_infinity = (1.0 - np.sinh(2.0 / T_val)**(-4))**(1.0/8.0)\n    else:\n        m_infinity = 0.0\n\n    results = []\n    for case in test_cases:\n        bc_type, L, T_case, n_therm, n_meas, seed = case\n        avg_m = calculate_avg_m(L, T_case, bc_type, n_therm, n_meas, seed)\n        delta_m = m_infinity - avg_m\n        results.append(round(delta_m, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Metropolis 算法的逻辑框架远不止于模拟物理自旋系统，其思想具有广泛的通用性。本练习将通过一个经典的组合优化问题——旅行商问题（TSP），来展示这种思想的力量。通过将 TSP 的路径长度类比为物理系统的“能量”，我们可以运用一种名为“模拟退火”的改进 Metropolis 算法来寻找近似最优解，这生动地揭示了统计物理与计算优化之间深刻的联系 。",
            "id": "2413263",
            "problem": "您需要实现一个模拟退火程序，该程序可被解释为一种带有随时间变化温度的Metropolis算法，通过最小化一个具有物理动机的能量来近似求解旅行商问题（TSP）的实例。您的设计必须从Ising模型中使用的经典Metropolis框架出发，您的实现必须在代表排列的离散构型空间上应用相同的转移规则和玻尔兹曼接受逻辑。目标是生成一个可复现的程序，该程序能为指定的测试套件输出最终的路径长度。所有距离均以任意长度单位（a.u.）表示，所有报告的路径长度必须以a.u.为单位，并四舍五入到小数点后六位。\n\n使用的基本原理和推导基础：\n- 温度为 $T$ 时的玻尔兹曼分布为能量为 $E(\\boldsymbol{s})$ 的构型 $\\boldsymbol{s}$ 分配概率 $P(\\boldsymbol{s}) \\propto \\exp\\!\\left(-E(\\boldsymbol{s})/T\\right)$。\n- Metropolis转移规则使用接受概率 $A(\\boldsymbol{s}\\to\\boldsymbol{s}') = \\min\\!\\left\\{1,\\exp\\!\\left(-\\Delta E/T\\right)\\right\\}$（其中 $\\Delta E = E(\\boldsymbol{s}')-E(\\boldsymbol{s})$）来满足相对于玻尔兹曼分布的细致平衡条件。\n- 模拟退火是一种非平稳的Metropolis过程，其中温度 $T$ 根据降温方案 $T_{t+1} = \\alpha T_t$ 逐渐降低，其中 $0\\alpha1$ 为固定值，从初始温度 $T_0$ 开始。\n\n将旅行商问题（TSP）建模为能量最小化问题：\n- 考虑平面上的 $N$ 个城市，其位置为 $\\{\\boldsymbol{r}_i\\}_{i=0}^{N-1}$，并设 $d_{ij}$ 为 $\\boldsymbol{r}_i$ 和 $\\boldsymbol{r}_j$ 之间的欧几里得距离，单位为a.u.。\n- 一条路径是一个由排列 $\\boldsymbol{p} = (p_0,p_1,\\dots,p_{N-1})$ 表示的循环序列，其中每个 $p_k$ 是 $\\{0,\\dots,N-1\\}$ 中一个不同的城市索引，且 $p_N \\equiv p_0$。\n- 将路径能量（待最小化）定义为总路径长度\n$$\nE(\\boldsymbol{p}) \\equiv \\sum_{k=0}^{N-1} d_{p_k,\\,p_{k+1}} \\quad \\text{(in a.u.)}.\n$$\n\n算法要求：\n- 使用上述 $E(\\boldsymbol{p})$ 和几何降温方案 $T_{t+1}=\\alpha T_t$ 的Metropolis接受规则。\n- 使用一种保持排列约束的构型空间移动，以维持类似于Ising模型中单自旋翻转提议的物理真实性，但需适应于此约束流形。为了计算效率和作为循环路径局部拓扑变化的可物理解释性，请使用2-opt移动：选择索引 $i$ 和 $j$（其中 $0 \\le i  j \\le N-1$），它们在循环上不是直接相邻的（包括环绕情况），并反转它们之间的片段。能量变化 $\\Delta E$ 必须仅通过四个受影响边的距离精确计算，而不是通过重新计算总和。\n- 每次运行均以从所有 $N!$ 个排列中均匀随机抽取的排列进行初始化，使用给定的伪随机种子。\n\n使用的降温方案和参数：\n- 初始温度 $T_0 = 1.0$（能量单位与 $E$ 相同，即a.u.）。\n- 几何降温因子 $\\alpha = 0.995$。\n- 温度级别数 $N_T = 1000$。\n- 在每个温度级别，执行 $M = 20N$ 次独立的2-opt Metropolis提议。\n\n要实现和报告的测试套件：\n对于下方的每个测试用例，使用指定的种子和上述参数运行模拟退火，然后应用最终的确定性2-opt下降法（重复任何严格改进的2-opt移动，直到不存在此类移动为止），以确保达到一个2-opt局部最小值。报告最终的路径长度 $E(\\boldsymbol{p}_{\\mathrm{final}})$，单位为a.u.，四舍五入到小数点后六位。\n\n- 测试用例A（单位圆上的凸正方形）：$N=4$，城市位于角度 $\\theta_k = \\frac{2\\pi k}{4}$ 处，位置为 $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$，其中 $k\\in\\{0,1,2,3\\}$。使用种子 $7$。\n- 测试用例B（单位圆上的正五边形）：$N=5$，城市位于角度 $\\theta_k = \\frac{2\\pi k}{5}$ 处，位置为 $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$，其中 $k\\in\\{0,1,2,3,4\\}$。使用种子 $13$。\n- 测试用例C（单位圆上的正六边形）：$N=6$，城市位于角度 $\\theta_k = \\frac{2\\pi k}{6}$ 处，位置为 $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$，其中 $k\\in\\{0,1,2,3,4,5\\}$。使用种子 $29$。\n\n角度单位说明：所有角度均为弧度。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为[A,B,C]，其中每个条目是最终路径长度（a.u.），四舍五入到小数点后六位。例如，一个有效的输出格式类似于“[x.xxxxxx,y.yyyyyy,z.zzzzzz]”，每个值的小数点后恰好有六位数字。",
            "solution": "所给出的问题陈述是有效的。它具有科学依据，定义明确，客观且完整。它描述了Metropolis算法（以模拟退火的形式）在经典组合优化问题——旅行商问题（TSP）上的一个标准应用。将最小化路径长度类比为寻找系统基态能量，是统计力学在优化领域应用的基石。算法的所有参数、初始条件和测试用例都得到了明确规定，包括用于确保可复现性的伪随机种子。所要求的移动集，即2-opt移动，是针对TSP的一种定义明确的标准启发式方法。该问题是可形式化且算法上可处理的。\n\n现在我将对解决方案进行详细的推导和描述。\n\n### 1. 建模旅行商问题\n\n该问题旨在找到一条访问给定集合中每个城市恰好一次并返回起始城市的最短路径。这可以映射为一个统计物理学问题。\n\n- **构型空间 ($S$)：** 系统的一个状态，或一个构型，是一条特定的路径。对于从 $0$ 到 $N-1$ 索引的 $N$ 个城市，一条路径可以由城市索引的一个排列 $\\boldsymbol{p} = (p_0, p_1, \\dots, p_{N-1})$ 来表示。所有 $N!$ 个这样的排列集合构成了构型空间。\n\n- **能量函数 ($E$)：** 一个构型 $\\boldsymbol{p}$ 的“能量”被定义为路径的总长度。给定城市的位置 $\\{\\boldsymbol{r}_i\\}_{i=0}^{N-1}$，我们首先计算欧几里得距离矩阵 $d_{ij} = ||\\boldsymbol{r}_i - \\boldsymbol{r}_j||_2$。能量则为：\n$$ E(\\boldsymbol{p}) = \\sum_{k=0}^{N-1} d_{p_k, p_{(k+1) \\pmod N}} $$\nTSP的目标是找到使该能量函数最小化的排列 $\\boldsymbol{p}^*$，即系统的基态。\n\n### 2. 模拟退火算法\n\n模拟退火是一种受冶金学中退火过程启发的元启发式算法。它在一系列递减的温度下使用Metropolis算法，以引导其搜索能量函数的全局最小值。\n\n- **初始状态：** 模拟从一条随机路径开始，该路径通过均匀随机抽取城市索引 $\\{0, 1, \\dots, N-1\\}$ 的一个排列来生成。使用以特定种子初始化的伪随机数生成器来确保可复现性。\n\n- **Metropolis步骤：** 在给定温度 $T$下，系统从当前构型 $\\boldsymbol{p}$ 向一个新的提议构型 $\\boldsymbol{p}'$ 跃迁。该跃迁以Metropolis准则给出的概率被接受：\n$$ A(\\boldsymbol{p} \\to \\boldsymbol{p}') = \\min\\left\\{1, \\exp\\left(-\\frac{\\Delta E}{T}\\right)\\right\\} $$\n其中 $\\Delta E = E(\\boldsymbol{p}') - E(\\boldsymbol{p})$ 是能量的变化。如果 $\\Delta E \\le 0$，新构型更好或相等，该移动总是被接受。如果 $\\Delta E  0$，该移动以概率 $\\exp(-\\Delta E/T)$ 被接受，这使得系统能够偶尔跳出局部最小值。\n\n- **新构型的提议（2-Opt移动）：** 通过一次2-opt移动，从当前路径 $\\boldsymbol{p}$ 生成一条新路径 $\\boldsymbol{p}'$。此移动包括从排列数组中选择两个索引 $i$ 和 $j$（其中 $0 \\le i  j \\le N-1$），并反转它们之间的路径片段。\n设当前路径为 $\\boldsymbol{p} = (p_0, \\dots, p_{i-1}, p_i, \\dots, p_j, p_{j+1}, \\dots, p_{N-1})$。新路径 $\\boldsymbol{p}'$ 通过反转从索引 $i$ 到 $j$ 的子数组形成：\n$$ \\boldsymbol{p}' = (p_0, \\dots, p_{i-1}, \\boldsymbol{p_j, p_{j-1}, \\dots, p_i}, p_{j+1}, \\dots, p_{N-1}) $$\n此操作会断开路径中的两条边 $(p_{(i-1)\\pmod N}, p_i)$ 和 $(p_j, p_{(j+1)\\pmod N})$，并创建两条新边 $(p_{(i-1)\\pmod N}, p_j)$ 和 $(p_i, p_{(j+1)\\pmod N})$。能量变化可以高效计算，无需重新对整个路径长度求和：\n$$ \\Delta E = \\left( d_{p_{(i-1)\\pmod N}, p_j} + d_{p_i, p_{(j+1)\\pmod N}} \\right) - \\left( d_{p_{(i-1)\\pmod N}, p_i} + d_{p_j, p_{(j+1)\\pmod N}} \\right) $$\n为确保移动是非平凡的，我们必须选择 $i$ 和 $j$，使得片段反转不对应于反转整个路径（这会导致 $\\Delta E=0$）。当待反转片段的长度 $j-i+1$ 等于 $N$ 时，会发生这种情况。我们将生成 $(i, j)$ 对，并拒绝对应于此平凡情况的对。\n\n- **降温方案：** 温度 $T$ 根据几何降温方案逐渐降低。从初始温度 $T_0$ 开始，在固定数量的Metropolis步骤后更新温度：\n$$ T_{k+1} = \\alpha T_k $$\n其中 $\\alpha \\in (0, 1)$ 是降温因子。该过程运行固定的温度级别数 $N_T$。在每个温度级别，执行 $M = 20N$ 次Metropolis提议。\n\n### 3. 最终局部优化\n\n模拟退火过程结束后，最终路径可能不是关于2-opt移动的局部最小值。因此，执行确定性的局部搜索（或下降法），以保证得到一个2-opt局部最优解。此过程包括系统地检查当前路径上所有可能的2-opt移动。如果发现一个能严格减小路径长度（$\\Delta E  0$）的移动，则立即接受该移动，并从新的、改进后的路径重新开始搜索。重复此过程，直到对所有可能的2-opt移动进行一整轮检查后，不再有任何改进。\n\n### 4. 测试用例的实现\n\n算法将根据指定的参数实现：\n- **初始温度：** $T_0 = 1.0$\n- **降温因子：** $\\alpha = 0.995$\n- **温度级别数：** $N_T = 1000$\n- **每个温度的步数：** $M = 20N$\n\n每个测试用例的城市坐标在单位圆上生成：$\\boldsymbol{r}_k = (\\cos(2\\pi k/N), \\sin(2\\pi k/N))$。\n- **用例A：** $N=4$，种子$=7$\n- **用例B：** $N=5$，种子$=13$\n- **用例C：** $N=6$，种子$=29$\n\n对于每个用例，将执行完整的程序（初始化、模拟退火和最终的2-opt下降）。将报告最终的路径长度，四舍五入到小数点后六位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulated annealing for the TSP test cases.\n    \"\"\"\n    test_cases = [\n        # (N, seed)\n        (4, 7),  # Test case A\n        (5, 13), # Test case B\n        (6, 29)  # Test case C\n    ]\n\n    # Annealing parameters\n    t0 = 1.0\n    alpha = 0.995\n    n_temp_levels = 1000\n\n    results = []\n    for n_cities, seed in test_cases:\n        # Generate city coordinates on a unit circle\n        angles = 2 * np.pi * np.arange(n_cities) / n_cities\n        cities = np.array([np.cos(angles), np.sin(angles)]).T\n        \n        # Pre-compute distance matrix\n        dist_matrix = np.sqrt(\n            np.sum(\n                (cities[:, np.newaxis, :] - cities[np.newaxis, :, :]) ** 2, axis=2\n            )\n        )\n        \n        # Number of Metropolis steps per temperature\n        m_steps = 20 * n_cities\n\n        # Initialize random number generator with seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. INITIALIZATION: Start with a random tour\n        current_tour = rng.permutation(n_cities)\n        current_energy = 0\n        for i in range(n_cities):\n            current_energy += dist_matrix[current_tour[i], current_tour[(i + 1) % n_cities]]\n\n        # 2. SIMULATED ANNEALING\n        t = t0\n        for _ in range(n_temp_levels):\n            for _ in range(m_steps):\n                # Propose a 2-opt move\n                # Select two distinct indices i and j\n                i, j = rng.choice(n_cities, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n                \n                # A reversal of the whole tour is trivial (delta_E=0)\n                # and just wastes computation. Skip it.\n                if i == 0 and j == n_cities - 1:\n                    continue\n\n                # Calculate energy change (Delta E) for the 2-opt move\n                # Edges to be broken: (p[i-1], p[i]) and (p[j], p[j+1])\n                # New edges: (p[i-1], p[j]) and (p[i], p[j+1])\n                p_i_minus_1 = current_tour[i - 1] # works for i=0 due to -1 index\n                p_i = current_tour[i]\n                p_j = current_tour[j]\n                p_j_plus_1 = current_tour[(j + 1) % n_cities]\n\n                delta_e = (\n                    dist_matrix[p_i_minus_1, p_j] + dist_matrix[p_i, p_j_plus_1]\n                ) - (\n                    dist_matrix[p_i_minus_1, p_i] + dist_matrix[p_j, p_j_plus_1]\n                )\n\n                # Metropolis acceptance criterion\n                if delta_e  0 or rng.random()  np.exp(-delta_e / t):\n                    # Accept move: reverse the segment p[i:j+1]\n                    current_tour[i:j+1] = current_tour[i:j+1][::-1]\n                    current_energy += delta_e\n            \n            # Cool down\n            t *= alpha\n            \n        # 3. FINAL 2-OPT LOCAL SEARCH\n        improved = True\n        while improved:\n            improved = False\n            for i in range(n_cities - 1):\n                for j in range(i + 1, n_cities):\n                    # Avoid trivial full reversal\n                    if i == 0 and j == n_cities - 1:\n                        continue\n                    \n                    p_i_minus_1 = current_tour[i - 1]\n                    p_i = current_tour[i]\n                    p_j = current_tour[j]\n                    p_j_plus_1 = current_tour[(j + 1) % n_cities]\n\n                    delta_e = (\n                        dist_matrix[p_i_minus_1, p_j] + dist_matrix[p_i, p_j_plus_1]\n                    ) - (\n                        dist_matrix[p_i_minus_1, p_i] + dist_matrix[p_j, p_j_plus_1]\n                    )\n                    \n                    # Accept any strictly improving move\n                    if delta_e  -1e-9: # Use a small tolerance for float comparison\n                        current_tour[i:j+1] = current_tour[i:j+1][::-1]\n                        current_energy += delta_e\n                        improved = True\n                        # Restart search from the new tour\n                        break\n                if improved:\n                    break\n        \n        results.append(f\"{current_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}