{
    "hands_on_practices": [
        {
            "introduction": "对于小尺寸系统，我们可以通过遍历所有可能的状态来精确计算热力学平均值。这项基础练习  旨在通过计算一个二维伊辛模型在空间变化的磁场下的能量和磁化强度，来巩固这项基本技能。这项实践将加强对配分函数定义与可观测量之间直接联系的理解。",
            "id": "2380966",
            "problem": "考虑一个二维伊辛模型，该模型包含 $N=L_x L_y$ 个自旋 $s_i \\in \\{+1,-1\\}$，位于尺寸为 $L_x \\times L_y$ 的矩形晶格上，且在两个方向上均具有周期性边界条件。其哈密顿量定义为\n$$\nE(\\mathbf{s}) \\equiv -J \\sum_{\\langle i,j\\rangle} s_i s_j \\;-\\; \\sum_{i=1}^{N} h(x_i) s_i,\n$$\n其中 $\\langle i,j\\rangle$ 表示最近邻对，每条键只计算一次，$J0$ 是铁磁交换常数，而取决于格点的外部磁场为\n$$\nh(x) \\equiv H_0 \\,\\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right),\n$$\n其中 $x\\in \\{0,1,\\dots,L_x-1\\}$ 是一个格点的整数x坐标。正弦函数的参数必须以弧度为单位。使用无量纲单位，玻尔兹曼常数设为 $k_{\\mathrm{B}}=1$，能量以 $J$ 为单位测量，温度 $T$ 以 $J$ 为单位测量。温度为 $T$ 的正则系综定义了配分函数\n$$\nZ \\equiv \\sum_{\\mathbf{s}} e^{-\\beta E(\\mathbf{s})}, \\quad \\beta \\equiv \\frac{1}{T},\n$$\n和系综平均\n$$\n\\langle E \\rangle \\equiv \\frac{1}{Z}\\sum_{\\mathbf{s}} E(\\mathbf{s})\\, e^{-\\beta E(\\mathbf{s})}, \\qquad\n\\langle M \\rangle \\equiv \\frac{1}{Z}\\sum_{\\mathbf{s}} \\left(\\sum_{i=1}^{N} s_i\\right)\\, e^{-\\beta E(\\mathbf{s})}.\n$$\n对于每个指定的参数集，计算如上定义的每个自旋的平均能量 $\\langle E\\rangle/N$ 和每个自旋的平均总磁化强度 $\\langle M\\rangle/N$。\n\n所有量都是无量纲的，因此除了上述规定外，不需要其他物理单位。$h(x)$ 中的角度必须解释为弧度。你的程序必须生成四舍五入到六位小数的数值。\n\n测试套件（每个案例是一个元组 $(L_x,L_y,J,H_0,T)$）:\n- 案例 A: $(L_x,L_y,J,H_0,T)=(\\,3,\\,3,\\,1,\\,0,\\,2.5\\,)$。\n- 案例 B: $(L_x,L_y,J,H_0,T)=(\\,4,\\,3,\\,1,\\,0.8,\\,1.8\\,)$。\n- 案例 C: $(L_x,L_y,J,H_0,T)=(\\,2,\\,3,\\,1,\\,5.0,\\,1.0\\,)$。\n- 案例 D: $(L_x,L_y,J,H_0,T)=(\\,3,\\,3,\\,1,\\,0.7,\\,\\infty\\,)$，其中 $T=\\infty$ 表示极限 $\\beta=0$。\n\n最终输出格式:\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个案例，按以下顺序输出两个浮点数：首先是 $\\langle E\\rangle/N$，然后是 $\\langle M\\rangle/N$，每个都四舍五入到六位小数。\n- 按顺序将案例A、B、C和D的结果连接成一个单一的扁平列表。例如，输出格式必须是\n$$\n[\\langle E\\rangle/N\\text{(A)},\\langle M\\rangle/N\\text{(A)},\\langle E\\rangle/N\\text{(B)},\\langle M\\rangle/N\\text{(B)},\\langle E\\rangle/N\\text{(C)},\\langle M\\rangle/N\\text{(C)},\\langle E\\rangle/N\\text{(D)},\\langle M\\rangle/N\\text{(D)}].\n$$",
            "solution": "该问题陈述已经过严格验证，并被确定为有效。它具有科学依据，是适定、客观且内部一致的。它构成了统计物理学中的一个标准计算问题。\n\n解决方案通过使用精确枚举法直接计算正则系综平均值来进行。对于所有测试用例，系统大小 $N = L_x L_y$ 都足够小（最大为 $N=12$），使得对所有 $2^N$ 个微观态的求和在计算上是可行的。\n\n计算的基础在于统计力学中正则系综的原理。系统处于具有能量 $E(\\mathbf{s})$ 的特定微观态 $\\mathbf{s}$（一种自旋构型）的概率由玻尔兹曼分布给出：\n$$\nP(\\mathbf{s}) = \\frac{e^{-\\beta E(\\mathbf{s})}}{Z}\n$$\n其中 $\\beta = 1/T$ 是逆温度（玻尔兹曼常数 $k_B=1$），$Z$ 是配分函数，它作为一个归一化常数，确保所有概率之和为1。它被定义为对所有可能微观态的求和：\n$$\nZ = \\sum_{\\mathbf{s}} e^{-\\beta E(\\mathbf{s})}\n$$\n任何可观测量 $O(\\mathbf{s})$ 的热平均（或期望值）则计算如下：\n$$\n\\langle O \\rangle = \\sum_{\\mathbf{s}} O(\\mathbf{s}) P(\\mathbf{s}) = \\frac{1}{Z} \\sum_{\\mathbf{s}} O(\\mathbf{s}) e^{-\\beta E(\\mathbf{s})}\n$$\n所需的具体量是平均能量 $\\langle E \\rangle$ 和平均总磁化强度 $\\langle M \\rangle = \\langle \\sum_i s_i \\rangle$。\n\n在具有周期性边界条件的 $L_x \\times L_y$ 晶格上的二维伊辛模型的哈密顿量 $E(\\mathbf{s})$ 给出如下：\n$$\nE(\\mathbf{s}) = -J \\sum_{\\langle i,j\\rangle} s_i s_j - \\sum_{i=1}^{N} h(x_i) s_i\n$$\n第一项是铁磁相互作用能，其中 $J0$ 是耦合常数，求和遍及所有唯一的最近邻对 $\\langle i,j \\rangle$。第二项是由依赖于格点的外部磁场 $h(x) = H_0 \\sin(2\\pi x/L_x)$ 引起的能量，其中 $x \\in \\{0, 1, \\dots, L_x-1\\}$ 是一个格点的整数x坐标。\n\n计算算法如下：\n1. 对于由参数 $(L_x, L_y, J, H_0, T)$ 定义的每个测试用例，总自旋数为 $N = L_x L_y$。我们还计算逆温度 $\\beta = 1/T$。\n2. 我们遍历所有 $2^N$ 种可能的自旋构型。每个构型 $\\mathbf{s}$ 都可以唯一地映射到一个从 $0$ 到 $2^N-1$ 的整数。该整数的二进制表示用于设置自旋值 $s_i \\in \\{+1, -1\\}$。\n3. 对于每个构型 $\\mathbf{s}$：\n    a. 计算能量 $E(\\mathbf{s})$。相互作用项 $\\sum_{\\langle i,j \\rangle} s_i s_j$ 通过对每个格点 $i$ 的自旋 $s_i$ 与其“右侧”和“下方”邻居的自旋的乘积进行求和来高效计算，这考虑了周期性边界条件并确保每条键只被计算一次。外场能量通过对所有格点求和 $-h(x_i)s_i$ 来计算。\n    b. 计算总磁化强度 $M(\\mathbf{s}) = \\sum_i s_i$。\n    c. 确定玻尔兹曼因子 $w = e^{-\\beta E(\\mathbf{s})}$。\n    d. 更新三个和：$S_Z = \\sum w$，$S_E = \\sum E(\\mathbf{s})w$，以及 $S_M = \\sum M(\\mathbf{s})w$，其中求和是针对到目前为止访问过的所有构型。\n4. 在遍历所有 $2^N$ 个构型后，计算系综平均值：\n$$\n\\langle E \\rangle = \\frac{S_E}{S_Z} \\qquad \\text{和} \\qquad \\langle M \\rangle = \\frac{S_M}{S_Z}\n$$\n最后，通过除以总自旋数 $N$，将这些值转换为每个自旋的量。\n\n对于 $T \\to \\infty$（案例D），即对应于 $\\beta \\to 0$ 的情况，出现了一个特殊情况。在此极限下，无论能量如何，所有构型的玻尔兹曼因子 $e^{-\\beta E(\\mathbf{s})} \\to e^0 = 1$。所有 $2^N$ 个状态都变得等概率。由于自旋态的对称性 ($s_i = \\pm 1$) ，任何单个自旋的热平均都为零：$\\langle s_i \\rangle = (1/2)(+1) + (1/2)(-1) = 0$。类似地，对于任何不同的自旋对，$\\langle s_i s_j \\rangle = \\langle s_i \\rangle \\langle s_j \\rangle = 0$。\n平均磁化强度为 $\\langle M \\rangle = \\sum_i \\langle s_i \\rangle = 0$。平均能量为 $\\langle E \\rangle = -J \\sum_{\\langle i,j\\rangle} \\langle s_i s_j \\rangle - \\sum_i h(x_i) \\langle s_i \\rangle = 0$。因此，对于案例D，每个自旋的平均能量和每个自旋的平均磁化强度都恰好为 $0$。这个解析结果被直接使用。\n\n最终的实现将此精确枚举算法转换为一个Python脚本，利用 `numpy` 库进行高效的数组操作，特别是用于计算具有周期性边界的能量。对于每个案例，计算出的 $\\langle E \\rangle/N$ 和 $\\langle M \\rangle/N$ 的值按要求四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the average energy and magnetization per spin for a 2D Ising model\n    on a rectangular lattice with periodic boundary conditions using exact enumeration.\n    \"\"\"\n    # Test suite: (Lx, Ly, J, H0, T)\n    test_cases = [\n        (3, 3, 1.0, 0.0, 2.5),  # Case A\n        (4, 3, 1.0, 0.8, 1.8),  # Case B\n        (2, 3, 1.0, 5.0, 1.0),  # Case C\n        (3, 3, 1.0, 0.7, float('inf')),  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, J, H0, T = case\n        N = Lx * Ly\n\n        # Handle the infinite temperature limit analytically\n        if T == float('inf'):\n            E_per_spin = 0.0\n            M_per_spin = 0.0\n            results.extend([E_per_spin, M_per_spin])\n            continue\n\n        beta = 1.0 / T\n\n        # Pre-calculate the site-dependent magnetic field grid\n        x_coords = np.arange(Lx)\n        h_vals = H0 * np.sin(2.0 * np.pi * x_coords / Lx)\n        H_grid = np.tile(h_vals, (Ly, 1))\n\n        # Initialize sums for partition function and observables\n        Z_sum = 0.0\n        E_times_Z_sum = 0.0\n        M_times_Z_sum = 0.0\n\n        # Iterate through all 2^N spin configurations\n        for i in range(2**N):\n            # Generate the spin configuration from the integer's binary representation\n            # '0' bit maps to spin -1, '1' bit maps to spin +1\n            bits = bin(i)[2:].zfill(N)\n            spins_1d = np.array([int(b) * 2 - 1 for b in bits])\n            s = spins_1d.reshape((Ly, Lx))\n\n            # Calculate the total energy E(s) for the current configuration\n            # Interaction energy: sum over right and down neighbors to count each bond once\n            E_int = -J * np.sum(s * np.roll(s, -1, axis=1) + s * np.roll(s, -1, axis=0))\n            \n            # External field energy\n            E_field = -np.sum(s * H_grid)\n            \n            E = E_int + E_field\n\n            # Calculate the total magnetization M(s)\n            M = np.sum(s)\n\n            # Calculate the Boltzmann weight and update the sums\n            # Use a high-precision float to avoid overflow/underflow issues\n            boltzmann_weight = np.exp(-beta * E, dtype=np.float64)\n            \n            Z_sum += boltzmann_weight\n            E_times_Z_sum += E * boltzmann_weight\n            M_times_Z_sum += M * boltzmann_weight\n\n        # Calculate the ensemble averages\n        avg_E = E_times_Z_sum / Z_sum\n        avg_M = M_times_Z_sum / Z_sum\n\n        # Normalize to get per-spin quantities\n        E_per_spin = avg_E / N\n        M_per_spin = avg_M / N\n\n        results.append(round(E_per_spin, 6))\n        results.append(round(M_per_spin, 6))\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "能量和磁化强度等概念是强大的类比工具，其应用远远超出了物理学范畴。这项实践  将模拟一个网络中的共识建立过程，其中“能量”代表节点间的分歧。通过这个练习，你将熟悉异步更新和时间平均等在模拟动态和非平衡系统中常用的技术。",
            "id": "2380973",
            "problem": "给定一个节点网络，每个节点都有一个代表决策的二元状态，用自旋 $s_i(t) \\in \\{-1,+1\\}$ 表示，其中 $i$ 为节点索引，$t$ 为离散时间。该网络被建模为一个无向简单图，其节点集为 $\\{0,1,\\dots,N-1\\}$，边集为 $\\mathcal{E} \\subset \\{(i,j) \\mid 0 \\le i  j \\le N-1\\}$。系统在时间 $t$ 的微观构型是向量 $\\mathbf{s}(t) = (s_0(t),\\dots,s_{N-1}(t))$。构型的瞬时能量 $E(t)$ 定义为不一致连接（即端点具有相反自旋的边）的数量，由下式给出：\n$$\nE(t) = \\sum_{(i,j) \\in \\mathcal{E}} \\frac{1 - s_i(t) s_j(t)}{2}.\n$$\n瞬时磁化强度 $m(t)$ 定义为自旋的算术平均值，\n$$\nm(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} s_i(t).\n$$\n系统的动力学规定如下。在每个离散更新步 $t = 1,2,\\dots$，从 $\\{0,1,\\dots,N-1\\}$ 中均匀随机选择一个节点索引 $i$。设 $N(i)$ 为图中节点 $i$ 的邻居集合。定义局部邻居和\n$$\nh_i(t) = \\sum_{j \\in N(i)} s_j(t-1).\n$$\n更新后的自旋 $s_i(t)$ 按以下规则设置：\n$$\ns_i(t) = \n\\begin{cases}\n+1,  \\text{如果 } h_i(t) > 0,\\\\\n-1,  \\text{如果 } h_i(t)  0,\\\\\n\\xi_t,  \\text{如果 } h_i(t) = 0,\n\\end{cases}\n$$\n其中 $\\xi_t$ 是一个独立随机变量，以相等的概率 $1/2$ 取值为 $+1$ 和 $-1$。在时间 $t$，所有其他自旋保持不变，即对于所有 $k \\ne i$，$s_k(t) = s_k(t-1)$。更新调度是异步的，意味着每个离散时间步只更新一个节点。\n\n对于给定的有限数量的老化步数 $T_{\\mathrm{burn}}$ 和测量步数 $T_{\\mathrm{meas}}$，定义测量窗口内的时间平均能量 $\\overline{E}$ 和时间平均磁化强度 $\\overline{m}$ 如下：\n$$\n\\overline{E} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} E(t), \\quad\n\\overline{m} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} m(t).\n$$\n所有随机选择（节点选择和当 $h_i(t)=0$ 时的平局打破）必须由一个伪随机数生成器生成，并使用指定的非负整数种子 $S$ 进行初始化，以确保可复现性。\n\n你的任务是编写一个完整的程序，对下面的每个测试用例，使用指定的自旋向量 $\\mathbf{s}(0)$ 在时间 $t=0$ 初始化系统，然后根据上述规则执行 $T_{\\mathrm{burn}} + T_{\\mathrm{meas}}$ 次异步更新步骤，在每步 $t \\ge 1$ 后计算 $E(t)$ 和 $m(t)$，并最终报告该测试用例的 $\\overline{E}$ 和 $\\overline{m}$。\n\n测试套件（每个用例指定 $N$、$\\mathcal{E}$、$\\mathbf{s}(0)$、$T_{\\mathrm{burn}}$、$T_{\\mathrm{meas}}$ 和 $S$）：\n- 用例 1（4个节点上的完全图）：\n  - $N = 4$，\n  - $\\mathcal{E} = \\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$,\n  - $\\mathbf{s}(0) = [ +1, -1, +1, -1 ]$,\n  - $T_{\\mathrm{burn}} = 20$,\n  - $T_{\\mathrm{meas}} = 50$,\n  - $S = 1$.\n- 用例 2（10个节点上的环形图）：\n  - $N = 10$,\n  - $\\mathcal{E} = \\{(i,(i+1) \\bmod 10) \\mid i \\in \\{0,1,\\dots,9\\}\\}$,\n  - $\\mathbf{s}(0) = [ +1, -1, +1, -1, +1, -1, +1, -1, +1, -1 ]$,\n  - $T_{\\mathrm{burn}} = 200$,\n  - $T_{\\mathrm{meas}} = 400$,\n  - $S = 2$.\n- 用例 3（6个节点上的星形图，中心为节点0）：\n  - $N = 6$,\n  - $\\mathcal{E} = \\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$,\n  - $\\mathbf{s}(0) = [ +1, +1, -1, -1, -1, -1 ]$,\n  - $T_{\\mathrm{burn}} = 100$,\n  - $T_{\\mathrm{meas}} = 200$,\n  - $S = 3$.\n- 用例 4（5个节点上的路径图）：\n  - $N = 5$,\n  - $\\mathcal{E} = \\{(0,1),(1,2),(2,3),(3,4)\\}$,\n  - $\\mathbf{s}(0) = [ +1, +1, +1, +1, +1 ]$,\n  - $T_{\\mathrm{burn}} = 10$,\n  - $T_{\\mathrm{meas}} = 20$,\n  - $S = 4$.\n\n程序输出规范：\n- 对于每个用例，计算如上定义的 $\\overline{E}$ 和 $\\overline{m}$。\n- 将每个报告值四舍五入到6位小数。\n- 最终的程序输出必须是单行，包含一个逗号分隔的8个数字列表，顺序为 $[\\overline{E}_1,\\overline{m}_1,\\overline{E}_2,\\overline{m}_2,\\overline{E}_3,\\overline{m}_3,\\overline{E}_4,\\overline{m}_4]$，用方括号括起来，且没有空格。",
            "solution": "所提出的问题是统计物理学中一个定义明确的计算练习，具体来说是图上的离散时间随机过程的模拟。该模型是投票者模型的一个变体，其中节点（自旋）采纳局部多数派的状态。其动力学与类 Ising 系统的零温更新算法有关。该问题有科学依据，内部一致，并需要通过直接模拟来找到所需的时间平均可观测量。\n\n该系统由一组具有二元自旋 $s_i \\in \\{-1, +1\\}$ 的 $N$ 个节点定义，结构化为一个无向图 $G = (V, \\mathcal{E})$，其中 $V = \\{0, 1, \\dots, N-1\\}$。系统在离散时间 $t$ 的构型是向量 $\\mathbf{s}(t) = (s_0(t), \\dots, s_{N-1}(t))$。\n\n瞬时能量 $E(t)$ 定义为连接具有相反自旋的节点的边的数量：\n$$\nE(t) = \\sum_{(i,j) \\in \\mathcal{E}} \\frac{1 - s_i(t) s_j(t)}{2}\n$$\n如果 $s_i(t) \\ne s_j(t)$，该表达式的计算结果为 $1$，否则为 $0$，因此正确地计算了“不一致”或“反铁磁性”链接的数量。瞬时磁化强度 $m(t)$ 是整个网络上的平均自旋值：\n$$\nm(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} s_i(t)\n$$\n\n系统根据异步更新调度进行演化。在每个时间步 $t \\ge 1$，从所有节点中均匀随机选择一个节点 $i$ 以进行可能的状态改变。更新规则是确定性的，取决于该节点的邻居 $N(i)$ 在前一时间步 $t-1$ 的状态。新状态 $s_i(t)$ 由局部邻居和 $h_i(t)$ 的符号决定：\n$$\nh_i(t) = \\sum_{j \\in N(i)} s_j(t-1)\n$$\n自旋 $s_i(t)$ 更新如下：\n$$\ns_i(t) = \n\\begin{cases}\n+1,  \\text{if } h_i(t) > 0 \\\\\n-1,  \\text{if } h_i(t)  0 \\\\\n\\xi_t,  \\text{if } h_i(t) = 0\n\\end{cases}\n$$\n其中 $\\xi_t$ 是从 $\\{-1, +1\\}$ 中以等概率抽取的随机变量，$P(\\xi_t = 1) = P(\\xi_t = -1) = 1/2$。所有其他自旋保持不变：对于 $k \\ne i$，$s_k(t) = s_k(t-1)$。此更新规则使自旋与局部多数意见对齐，这对应于一个局部能量最小化步骤。随机性通过随机选择要更新的节点以及当 $h_i(t) = 0$ 时的平局打破规则引入。\n\n任务是计算在指定测量窗口内的时间平均能量 $\\overline{E}$ 和磁化强度 $\\overline{m}$。模拟总共运行 $T_{\\mathrm{burn}} + T_{\\mathrm{meas}}$ 步。最初的 $T_{\\mathrm{burn}}$ 步构成“老化”或热化阶段，在此期间系统向统计稳态演化，不进行测量。随后的 $T_{\\mathrm{meas}}$ 步构成测量阶段。平均值定义如下：\n$$\n\\overline{E} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} E(t), \\quad\n\\overline{m} = \\frac{1}{T_{\\mathrm{meas}}} \\sum_{t=T_{\\mathrm{burn}}+1}^{T_{\\mathrm{burn}}+T_{\\mathrm{meas}}} m(t)\n$$\n模拟中的所有随机元素必须由一个使用特定种子 $S$ 初始化的伪随机数生成器 (PRNG) 控制，以确保可复现性。\n\n每个测试用例的计算过程如下：\n1. 使用给定的种子 $S$ 初始化伪随机数生成器。\n2. 使用邻接表表示图，这对于访问邻居是高效的。初始自旋构型 $\\mathbf{s}(0)$ 存储在数值数组中。\n3. 初始化能量和磁化强度的累积和，$\\Sigma E = 0$ 和 $\\Sigma m = 0$。\n4. 执行一个从 $t=1$ 到 $T_{\\mathrm{burn}} + T_{\\mathrm{meas}}$ 的循环：\n    a. 使用伪随机数生成器从 $\\{0, \\dots, N-1\\}$ 中均匀随机选择一个节点索引 $i_{\\mathrm{update}}$。\n    b. 使用时间 $t-1$ 的自旋状态计算局部邻居和 $h_{i_{\\mathrm{update}}}(t)$。\n    c. 根据 $h_{i_{\\mathrm{update}}}(t)$ 的符号更新自旋 $s_{i_{\\mathrm{update}}}(t)$，如果 $h_{i_{\\mathrm{update}}}(t)=0$ 则使用伪随机数生成器进行平局打破。自旋数组被原地修改以反映状态 $\\mathbf{s}(t)$。\n    d. 如果当前步 $t$ 在测量窗口内（即 $t  T_{\\mathrm{burn}}$），则从新更新的状态 $\\mathbf{s}(t)$ 计算瞬时 $E(t)$ 和 $m(t)$。\n    e. 将这些瞬时值加到各自的累积和 $\\Sigma E$ 和 $\\Sigma m$ 中。\n5. 循环结束后，计算平均值：$\\overline{E} = \\Sigma E / T_{\\mathrm{meas}}$ 和 $\\overline{m} = \\Sigma m / T_{\\mathrm{meas}}$。\n6. 按要求将最终平均值四舍五入到6位小数。\n\n为每个提供的测试用例实现此算法，并将结果汇总成指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n\n    def solve_case(N, edges, s0, T_burn, T_meas, S):\n        \"\"\"\n        Solves a single test case of the spin network simulation.\n\n        Args:\n            N (int): Number of nodes.\n            edges (list of tuples): List of edges in the graph.\n            s0 (list of int): Initial spin configuration.\n            T_burn (int): Number of burn-in steps.\n            T_meas (int): Number of measurement steps.\n            S (int): Seed for the random number generator.\n\n        Returns:\n            tuple: A tuple containing the time-averaged energy and magnetization,\n                   each rounded to 6 decimal places.\n        \"\"\"\n        # 1. Initialize the PRNG with the given seed S.\n        rng = np.random.default_rng(seed=S)\n\n        # 2. Represent the graph using an adjacency list.\n        adj = [[] for _ in range(N)]\n        for i, j in edges:\n            adj[i].append(j)\n            adj[j].append(i)\n\n        # The spin configuration is stored in a NumPy array.\n        s = np.array(s0, dtype=np.int8)\n\n        # 3. Initialize cumulative sums for energy and magnetization.\n        total_E = 0.0\n        total_m = 0.0\n        \n        T_total = T_burn + T_meas\n\n        # 4. Execute the simulation loop.\n        for t in range(1, T_total + 1):\n            # a. Select a node to update uniformly at random.\n            i_update = rng.integers(N)\n\n            # b. Calculate the local neighbor sum h_i.\n            h_i = 0\n            for neighbor in adj[i_update]:\n                h_i += s[neighbor]\n\n            # c. Update the spin s_i based on the sign of h_i.\n            if h_i > 0:\n                s[i_update] = 1\n            elif h_i  0:\n                s[i_update] = -1\n            else:  # h_i == 0, tie-breaking\n                s[i_update] = rng.choice([-1, 1])\n\n            # d. If in measurement phase, compute and accumulate observables.\n            if t > T_burn:\n                # Calculate instantaneous energy E(t): number of disagreeing connections.\n                # The formula (1 - s_i*s_j)/2 is equivalent to counting disagreeing pairs.\n                current_E = 0.5 * sum(1 - s[u] * s[v] for u, v in edges)\n                \n                # Calculate instantaneous magnetization m(t): mean of spins.\n                current_m = np.mean(s)\n\n                # e. Add to cumulative sums.\n                total_E += current_E\n                total_m += current_m\n\n        # 5. Calculate final averages.\n        avg_E = total_E / T_meas if T_meas > 0 else 0\n        avg_m = total_m / T_meas if T_meas > 0 else 0\n\n        # 6. Round results.\n        return round(avg_E, 6), round(avg_m, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: complete graph on 4 nodes\n        {\n            \"N\": 4,\n            \"edges\": [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)],\n            \"s0\": [+1, -1, +1, -1],\n            \"T_burn\": 20,\n            \"T_meas\": 50,\n            \"S\": 1\n        },\n        # Case 2: ring on 10 nodes\n        {\n            \"N\": 10,\n            # Normalize edges to (i, j) with i  j\n            \"edges\": list(sorted({tuple(sorted(t)) for t in [(i, (i + 1) % 10) for i in range(10)]})),\n            \"s0\": [+1, -1, +1, -1, +1, -1, +1, -1, +1, -1],\n            \"T_burn\": 200,\n            \"T_meas\": 400,\n            \"S\": 2\n        },\n        # Case 3: star on 6 nodes\n        {\n            \"N\": 6,\n            \"edges\": [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)],\n            \"s0\": [+1, +1, -1, -1, -1, -1],\n            \"T_burn\": 100,\n            \"T_meas\": 200,\n            \"S\": 3\n        },\n        # Case 4: path on 5 nodes\n        {\n            \"N\": 5,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n            \"s0\": [+1, +1, +1, +1, +1],\n            \"T_burn\": 10,\n            \"T_meas\": 20,\n            \"S\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E_avg, m_avg = solve_case(**case)\n        results.append(E_avg)\n        results.append(m_avg)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成数据只是工作的一半，更关键的是分析数据以揭示其背后的物理规律。这项练习  专注于使用四阶能量累积量 $\\kappa_4$ 这一高级数据分析工具，来区分一级相变和二级相变。它展示了可观测量概率分布的形状如何能够揭示深刻的物理见解。",
            "id": "2380998",
            "problem": "考虑一个格点自旋系统，其微观态由整数 $i \\in \\{1,\\dots,N\\}$ 索引，每个微观态具有能量 $E_i$ 和总磁化强度 $M_i$。对于一组 $N$ 个统计独立的样本 $\\{(E_i,M_i)\\}_{i=1}^N$，定义样本平均值 $\\langle E \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N E_i$ 和 $\\langle |M| \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N |M_i|$。能量涨落由中心矩 $\\mu_k = \\frac{1}{N}\\sum_{i=1}^N (E_i - \\langle E \\rangle_N)^k$（对于整数 $k \\ge 1$）来量化。能量的累积量生成函数为 $K_E(t) = \\ln \\langle e^{t E} \\rangle$，第n阶能量累积量定义为 $\\kappa_n = \\left.\\frac{d^n}{dt^n} K_E(t) \\right|_{t=0}$。你的任务是纯粹根据最高为4阶的经验中心矩，推导出一个可计算的四阶能量累积量 $\\kappa_4$ 的表达式，然后在模拟单峰和双峰能量分布的合成数据集上对其进行数值实现。\n\n从上述基本定义出发，不使用任何预先提供的快捷公式，完成以下任务：\n- 推导一个公式，用从样本 $\\{E_i\\}_{i=1}^N$ 中计算出的中心矩 $\\mu_2$ 和 $\\mu_4$ 来表示四阶能量累积量 $\\kappa_4$。使用累积量生成函数的定义以及矩和累积量的性质来证明每一步。\n- 使用概率论的第一性原理，解释为什么在相共存点附近（一级相变的典型特征）的对称双峰能量分布，与在连续临界点附近（二级相变的典型特征）的单峰、近似高斯的能量分布，其 $\\kappa_4$ 的符号不同。\n- 实现一个程序，该程序：\n  - 为下面指定的每个测试用例生成独立样本 $(E_i,M_i)$。\n  - 计算经验平均值 $\\langle E \\rangle_N$ 和 $\\langle |M| \\rangle_N$。\n  - 计算能量的经验中心矩 $\\mu_2$ 和 $\\mu_4$，然后根据你推导的表达式计算四阶能量累积量 $\\kappa_4$。\n  - 如果 $\\kappa_4  0$，则将每个用例分类为“类一级”；否则分类为“类二级”。将此分类编码为整数标签，类一级为 $1$，类二级为 $2$。\n  - 为了可复现性，使用固定的伪随机数生成器种子 $12345$。\n\n你必须实现以下三个合成测试用例。所有分布都将使用独立的高斯分量进行采样，对于双分量混合分布，所有混合权重必须等于 $1/2$。以下所有数字都是无量纲的，并且必须完全按照给定的数值使用。\n\n测试套件：\n- 用例A（单峰，“类二级”基线）：抽取 $N = 50000$ 对 $(E,M)$，其中 $E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2)$ 且 $M \\sim \\mathcal{N}(\\mu_M, \\sigma_M^2)$，参数为 $\\mu_E = 0.0, \\sigma_E = 1.0, \\mu_M = 0.0, \\sigma_M = 1.0$。\n- 用例B（双峰，“类一级”清晰分离）：从 $E$ 和 $M$ 均为两个独立高斯分布的等权重混合中抽取 $N = 50000$ 对 $(E,M)$。对于 $E$，分量为 $\\mathcal{N}(-2.0, 0.2^2)$ 和 $\\mathcal{N}(+2.0, 0.2^2)$。对于 $M$，分量为 $\\mathcal{N}(-1.0, 0.1^2)$ 和 $\\mathcal{N}(+1.0, 0.1^2)$。\n- 用例C（双峰，“类一级”有限样本边缘情况）：从 $E$ 和 $M$ 均为两个独立高斯分布的等权重混合中抽取 $N = 1000$ 对 $(E,M)$。对于 $E$，分量为 $\\mathcal{N}(-1.5, 0.5^2)$ 和 $\\mathcal{N}(+1.5, 0.5^2)$。对于 $M$，分量为 $\\mathcal{N}(-0.5, 0.2^2)$ 和 $\\mathcal{N}(+0.5, 0.2^2)$。\n\n对于每个用例，你的程序必须按顺序输出一个包含四个量的列表：$[\\kappa_4, \\langle E \\rangle_N, \\langle |M| \\rangle_N, \\text{label}]$，其中 $\\kappa_4$, $\\langle E \\rangle_N$ 和 $\\langle |M| \\rangle_N$ 是实数，$\\text{label}$ 是如上定义的整数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含三个用例的结果，格式为由方括号括起来的逗号分隔的列表，严格如下：\n[[k4_A,meanE_A,meanAbsM_A,label_A],[k4_B,meanE_B,meanAbsM_B,label_B],[k4_C,meanE_C,meanAbsM_C,label_C]]\n不得打印任何其他文本。所有角度在此问题中均不相关，也不需要物理单位；报告所有数值结果时，应使用纯实数，不带单位，也不带百分号。",
            "solution": "问题提出了三项任务：首先，根据经验中心矩推导四阶能量累积量 $\\kappa_4$ 的表达式；其次，从理论上解释 $\\kappa_4$ 的符号如何区分单峰和双峰能量分布；第三，在合成数据集上对这些概念进行数值实现。该问题是适定的，并且在统计力学和概率论方面有坚实的科学基础。我们开始解答。\n\n### 第1部分：四阶累积量 $\\kappa_4$ 的推导\n\n累积量和矩之间的关系由它们各自的生成函数导出。随机变量 $E$ 的矩生成函数 (MGF) 定义为 $M_E(t) = \\langle e^{tE} \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示期望值。将指数展开为泰勒级数并逐项取期望，可以得到以原点矩 $m_k = \\langle E^k \\rangle$ 表示的 MGF：\n$$\nM_E(t) = \\left\\langle \\sum_{k=0}^{\\infty} \\frac{(tE)^k}{k!} \\right\\rangle = \\sum_{k=0}^{\\infty} \\frac{\\langle E^k \\rangle}{k!} t^k = \\sum_{k=0}^{\\infty} \\frac{m_k}{k!} t^k\n$$\n根据定义，$m_0 = 1$。累积量生成函数 (CGF) 定义为 $K_E(t) = \\ln M_E(t)$。第 $n$ 阶累积量 $\\kappa_n$ 是 $K_E(t)$ 在 $t=0$ 附近泰勒级数展开式中 $\\frac{t^n}{n!}$ 的系数：\n$$\nK_E(t) = \\sum_{n=1}^{\\infty} \\frac{\\kappa_n}{n!} t^n\n$$\n为了推导 $\\kappa_4$ 的表达式，我们将其与中心矩 $\\mu_k = \\langle (E - m_1)^k \\rangle$ 联系起来。累积量的一个关键性质是对于 $n \\ge 2$ 的阶数，其具有位移不变性。对于一个位移后的变量 $E' = E - c$，其 CGF 为 $K_{E'}(t) = K_E(t) - ct$。因此，$\\kappa_1(E') = \\kappa_1(E) - c$，而对于所有 $n \\ge 2$，$\\kappa_n(E') = \\kappa_n(E)$。这使我们可以对一个零均值变量 $E' = E - m_1$ 进行推导，该变量的原点矩与 $E$ 的中心矩相同，即 $\\langle(E')^k\\rangle = \\mu_k$。对于这个变量，$m_1' = \\mu_1 = 0$。\n\n零均值变量 $E'$ 的 MGF 为：\n$$\nM_{E'}(t) = 1 + \\mu_1 \\cdot t + \\frac{\\mu_2}{2!} t^2 + \\frac{\\mu_3}{3!} t^3 + \\frac{\\mu_4}{4!} t^4 + O(t^5)\n$$\n由于 $\\mu_1 = 0$，我们有：\n$$\nM_{E'}(t) = 1 + \\left( \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\frac{\\mu_4}{24} t^4 + \\dots \\right)\n$$\nCGF 为 $K_{E'}(t) = \\ln M_{E'}(t)$。使用泰勒展开式 $\\ln(1+x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\dots$，并令 $x = \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\frac{\\mu_4}{24} t^4 + \\dots$，我们展开 $K_{E'}(t)$：\n$$\nK_{E'}(t) = \\left( \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\frac{\\mu_4}{24} t^4 + \\dots \\right) - \\frac{1}{2} \\left( \\frac{\\mu_2}{2} t^2 + \\frac{\\mu_3}{6} t^3 + \\dots \\right)^2 + O(t^6)\n$$\n我们收集到 $t^4$ 阶的项：\n$K_{E'}(t)$ 展开式中的线性项为零，所以 $\\kappa_1(E') = 0$，符合预期。\n$t^2$ 项是 $\\frac{\\mu_2}{2}t^2$。将其与 $\\frac{\\kappa_2}{2!}t^2$ 比较，我们得到 $\\kappa_2 = \\mu_2$。\n$t^3$ 项是 $\\frac{\\mu_3}{6}t^3$。将其与 $\\frac{\\kappa_3}{3!}t^3$ 比较，我们得到 $\\kappa_3 = \\mu_3$。\n$t^4$ 项来自两个贡献：来自第一个括号的 $\\frac{\\mu_4}{24}t^4$，和来自第二个括号的 $-\\frac{1}{2}(\\frac{\\mu_2}{2}t^2)^2 = -\\frac{\\mu_2^2}{8}t^4$。所有其他项都是 $t$ 的更高阶项。因此，$t^4$ 的总系数是 $\\frac{\\mu_4}{24} - \\frac{\\mu_2^2}{8}$。\n我们将其与 CGF 定义中 $t^4$ 的系数 $\\frac{\\kappa_4}{4!} = \\frac{\\kappa_4}{24}$ 相等：\n$$\n\\frac{\\kappa_4}{24} = \\frac{\\mu_4}{24} - \\frac{\\mu_2^2}{8} = \\frac{\\mu_4 - 3\\mu_2^2}{24}\n$$\n这得出了四阶累积量所需的表达式：\n$$\n\\kappa_4 = \\mu_4 - 3\\mu_2^2\n$$\n这个公式纯粹用中心矩 $\\mu_2$ 和 $\\mu_4$ 表示，这些矩可以从样本 $\\{E_i\\}_{i=1}^N$ 中估算出来。\n\n### 第2部分：$\\kappa_4$ 符号的物理诠释\n\n$\\kappa_4$ 的符号提供了关于概率分布 $P(E)$ 形状的信息，特别是其与高斯形态的偏离程度。该量与超额峰度 $\\gamma_2 = \\frac{\\mu_4}{\\mu_2^2} - 3 = \\frac{\\kappa_4}{\\mu_2^2}$ 直接相关。由于 $\\mu_2 = \\sigma^2$ 是非负的，$\\kappa_4$ 的符号与超额峰度的符号相同。\n\n单峰、近似高斯的能量分布是二级（连续）相变附近系统的特征。对于一个完美的高斯分布，其中心矩为 $\\mu_2 = \\sigma^2$ 和 $\\mu_4 = 3\\sigma^4$。将这些代入我们推导的公式中得到：\n$$\n\\kappa_4 = (3\\sigma^4) - 3(\\sigma^2)^2 = 0\n$$\n因此，对于具有高斯能量涨落的系统（用例 A），我们预期 $\\kappa_4 \\approx 0$，任何偏离零的值都是由有限样本误差引起的。问题将这种情况定义为“类二级”，如果 $\\kappa_4 \\ge 0$，则为其分配标签 $2$。\n\n对称双峰能量分布是一级相变附近系统的特征，此时两个不同的热力学相（例如，高能态和低能态）共存。这导致能量的概率分布呈双峰状。考虑这样一个分布的理想化模型，它由两个对称的狄拉克δ函数组成：$P(E) = \\frac{1}{2}\\delta(E-a) + \\frac{1}{2}\\delta(E+a)$，其中 $a > 0$。平均能量为 $\\langle E \\rangle = 0$。中心矩可以很容易地计算出来：\n$$\n\\mu_2 = \\langle E^2 \\rangle = \\frac{1}{2}(-a)^2 + \\frac{1}{2}(a)^2 = a^2\n$$\n$$\n\\mu_4 = \\langle E^4 \\rangle = \\frac{1}{2}(-a)^4 + \\frac{1}{2}(a)^4 = a^4\n$$\n那么四阶累积量为：\n$$\n\\kappa_4 = \\mu_4 - 3\\mu_2^2 = a^4 - 3(a^2)^2 = -2a^4\n$$\n由于 $a > 0$，$\\kappa_4$ 严格为负。这种分布是低峰态的（比高斯分布更平坦）。对于用例 B 和 C 中指定的两个高斯分布的混合，只要均值之间的间隔相对于它们的标准差是显著的，该分布就具有强双峰性，并且同样的结论成立：概率质量集中在远离均值的两个峰上，这使得四阶矩 $\\mu_4$ 相对于方差 $\\mu_2^2$ 的平方“较小”，从而导致负的 $\\kappa_4$。这个负号是一级相共存的经典标志，这种情况被标记为“类一级”（标签 $1$）。\n\n### 第3部分：算法设计与实现\n\n问题的数值部分要求生成合成数据并计算指定的量。实现过程如下：\n\n_1. 数据生成：_ 使用指定的种子 `12345` 初始化一个伪随机数生成器，以确保可复现性。\n- 对于用例 A（单峰），从各自的高斯分布 $\\mathcal{N}(0.0, 1.0^2)$ 中抽取 $N=50000$ 个独立的 $E$ 和 $M$ 样本。\n- 对于用例 B 和 C（双峰），数据代表了两个分量的混合。问题陈述为“从 $E$ 和 $M$ 均为两个独立高斯分布的等权重混合中抽取 $N$ 对 $(E,M)$”。这意味着对于每一对 $(E_i, M_i)$，通过一次随机选择来决定它是从分量1还是分量2中抽取。这在 $E$ 和 $M$ 之间建立了关联，这在物理上代表了相共存。为了实现这一点，我们从第一个分量的二元分布（其中 $E$ 和 $M$ 独立）生成 $N/2$ 对样本，从第二个分量的二元分布生成 $N/2$ 对样本，然后将它们连接起来。\n  对于用例 B ($N=50000$):\n  - 分量 1: $E \\sim \\mathcal{N}(-2.0, 0.2^2)$, $M \\sim \\mathcal{N}(-1.0, 0.1^2)$\n  - 分量 2: $E \\sim \\mathcal{N}(+2.0, 0.2^2)$, $M \\sim \\mathcal{N}(+1.0, 0.1^2)$\n  对于用例 C ($N=1000$)，原理相同，只是参数不同。\n\n_2. 可观测量计算：_ 对于每个生成的数据集 $\\{E_i, M_i\\}_{i=1}^N$：\n- 样本平均能量计算为 $\\langle E \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N E_i$。\n- 样本平均绝对磁化强度为 $\\langle |M| \\rangle_N = \\frac{1}{N} \\sum_{i=1}^N |M_i|$。\n- 能量的二阶和四阶中心矩根据其定义计算：\n  $$ \\mu_2 = \\frac{1}{N}\\sum_{i=1}^N (E_i - \\langle E \\rangle_N)^2 $$\n  $$ \\mu_4 = \\frac{1}{N}\\sum_{i=1}^N (E_i - \\langle E \\rangle_N)^4 $$\n- 然后使用推导的公式计算四阶累积量：$\\kappa_4 = \\mu_4 - 3\\mu_2^2$。\n\n_3. 分类：_ 根据计算出的 $\\kappa_4$ 的符号对每个用例进行分类：\n- 如果 $\\kappa_4  0$，标签为 $1$（“类一级”）。\n- 如果 $\\kappa_4 \\ge 0$，标签为 $2$（“类二级”）。\n\n最终输出是一个列表，包含三个用例中每个用例的结果 $[\\kappa_4, \\langle E \\rangle_N, \\langle |M| \\rangle_N, \\text{label}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by generating synthetic data for three test cases,\n    computing the specified physical quantities including the fourth-order\n    energy cumulant, and classifying the cases based on its sign.\n    \"\"\"\n    # Use a fixed seed for the pseudorandom number generator for reproducibility.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the parameters for the three test cases.\n    test_cases_params = [\n        # Case A: Unimodal, \"second-order-like\"\n        {\n            \"N\": 50000,\n            \"type\": \"unimodal\",\n            \"E_params\": {\"mu\": 0.0, \"sigma\": 1.0},\n            \"M_params\": {\"mu\": 0.0, \"sigma\": 1.0},\n        },\n        # Case B: Bimodal, \"first-order-like\", clear separation\n        {\n            \"N\": 50000,\n            \"type\": \"bimodal\",\n            \"E_params\": [{\"mu\": -2.0, \"sigma\": 0.2}, {\"mu\": 2.0, \"sigma\": 0.2}],\n            \"M_params\": [{\"mu\": -1.0, \"sigma\": 0.1}, {\"mu\": 1.0, \"sigma\": 0.1}],\n        },\n        # Case C: Bimodal, \"first-order-like\", finite-sample edge\n        {\n            \"N\": 1000,\n            \"type\": \"bimodal\",\n            \"E_params\": [{\"mu\": -1.5, \"sigma\": 0.5}, {\"mu\": 1.5, \"sigma\": 0.5}],\n            \"M_params\": [{\"mu\": -0.5, \"sigma\": 0.2}, {\"mu\": 0.5, \"sigma\": 0.2}],\n        },\n    ]\n\n    results = []\n    for params in test_cases_params:\n        N = params[\"N\"]\n        \n        # Generate synthetic data (E, M) pairs\n        if params[\"type\"] == \"unimodal\":\n            E = rng.normal(loc=params[\"E_params\"][\"mu\"], scale=params[\"E_params\"][\"sigma\"], size=N)\n            M = rng.normal(loc=params[\"M_params\"][\"mu\"], scale=params[\"M_params\"][\"sigma\"], size=N)\n        elif params[\"type\"] == \"bimodal\":\n            # For bimodal cases, generate N/2 samples from each component,\n            # ensuring correlation between E and M by picking from the same\n            # component for each (E, M) pair.\n            n1 = N // 2\n            n2 = N - n1\n            \n            E1 = rng.normal(loc=params[\"E_params\"][0][\"mu\"], scale=params[\"E_params\"][0][\"sigma\"], size=n1)\n            E2 = rng.normal(loc=params[\"E_params\"][1][\"mu\"], scale=params[\"E_params\"][1][\"sigma\"], size=n2)\n            E = np.concatenate((E1, E2))\n            \n            M1 = rng.normal(loc=params[\"M_params\"][0][\"mu\"], scale=params[\"M_params\"][0][\"sigma\"], size=n1)\n            M2 = rng.normal(loc=params[\"M_params\"][1][\"mu\"], scale=params[\"M_params\"][1][\"sigma\"], size=n2)\n            M = np.concatenate((M1, M2))\n\n            # Shuffle the pairs to mix the components\n            p = rng.permutation(N)\n            E = E[p]\n            M = M[p]\n\n        # Compute empirical averages\n        mean_E = np.mean(E)\n        mean_abs_M = np.mean(np.abs(M))\n\n        # Compute empirical central moments of energy\n        # The sample central moments are defined with a 1/N normalization factor.\n        # np.var uses ddof=0 by default, which is equivalent to 1/N.\n        mu_2 = np.var(E)\n        mu_4 = np.mean((E - mean_E)**4)\n\n        # Compute the fourth-order energy cumulant using the derived formula\n        kappa_4 = mu_4 - 3 * (mu_2**2)\n\n        # Classify the case based on the sign of kappa_4\n        # Label 1: first-order-like (k4  0)\n        # Label 2: second-order-like (k4 >= 0)\n        label = 1 if kappa_4  0 else 2\n        \n        results.append([kappa_4, mean_E, mean_abs_M, label])\n\n    # Format the results into the required string format: [[...],[...],[...]]\n    results_str_list = [\n        f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results\n    ]\n    final_output_str = f\"[{','.join(results_str_list)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}