{
    "hands_on_practices": [
        {
            "introduction": "我们的探索始于前向时间中心空间（FTCS）格式，这是离散化热传导方程最直接的方法。虽然简单，但其行为受到数值稳定性这一关键概念的支配。这个动手练习  让你通过观察一个微小的舍入误差是如何衰减到无关紧要或灾难性地放大，来实验性地探究稳定性边界，从而对 Courant-Friedrichs-Lewy (CFL) 条件有一个直观的理解。",
            "id": "2400867",
            "problem": "你需要编写一个完整、可运行的程序，研究单点数值舍入误差在无量纲形式的一维热方程的前向时间中心空间（FTCS）格式下如何传播。从由偏微分方程 $u_t = u_{xx}$ 在周期性域上描述的热扩散基本模型开始。将空间离散化为 $N$ 个间距为 $\\Delta x$ 的均匀点，以步长 $\\Delta t$ 离散化时间，并在每个时间步应用 FTCS 更新。在无量纲单位下进行计算，因此你的答案中不需要物理单位。\n\n你的程序必须实现以下数学定义和任务，且在实现中不得使用任何预先推导的稳定性或放大公式：\n- 定义无量纲比率 $r = \\Delta t / \\Delta x^2$。\n- 对每个时间步，为索引 $i = 0, 1, \\dots, N - 1$ 使用周期性 FTCS 更新，\n  $$u_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n  其中周期性索引为 $u_{-1} = u_{N-1}$ 和 $u_N = u_0$。\n- 初始化一个扰动场，该场在除单个索引 $i_0 = \\lfloor N/2 \\rfloor$ 外恒为零，在该索引处，值被设为 IEEE $754$ 双精度机器精度 $\\varepsilon = 2^{-52}$。这模拟了一个单点数值舍入误差。\n- 使用 FTCS 更新将扰动演化 $T$ 个时间步。计算每个时间步的二范数放大因子\n  $$g = \\left(\\frac{\\lVert e^T \\rVert_2}{\\lVert e^0 \\rVert_2}\\right)^{1/T},$$\n  其中 $e^n$ 是经过 $n$ 步后的扰动向量，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n\n目标是通过报告测得的几何增长因子 $g$，来量化单点舍入误差在稳定 ($r \\le 0.5$) 和不稳定 ($r > 0.5$) 的 FTCS 区域中是如何被放大或衰减的。\n\n实现你的程序以处理以下参数集 $(N, r, T)$ 的测试套件，所有测试均采用周期性边界和索引 $i_0 = \\lfloor N/2 \\rfloor$：\n- 测试 $1$ (稳定，理想情况): $N = 64$, $r = 0.25$, $T = 200$。\n- 测试 $2$ (不稳定，轻度): $N = 64$, $r = 0.51$, $T = 80$。\n- 测试 $3$ (临界情况): $N = 33$, $r = 0.5$, $T = 200$。\n- 测试 $4$ (不稳定，严重): $N = 128$, $r = 0.9$, $T = 30$。\n\n你的程序应为每个测试计算 $g$，并生成一行输出，其中包含一个逗号分隔的浮点数列表，四舍五入到六位小数，并用方括号括起来，顺序与上述测试相同（例如，\"[$g_1, g_2, g_3, g_4$]\"）。输出是无量纲数，因此不需要物理单位。每个 $g$ 值必须打印为四舍五入到六位小数的浮点数。最终输出类型是一个浮点数列表。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它具有科学依据，是适定的、客观的，并包含了进行唯一且有意义的求解所需的所有必要信息。该问题构成了计算物理领域中研究有限差分格式稳定性的一个标准数值实验。我们现在将进行求解。\n\n所考虑的基本物理过程是一维热扩散，由以下偏微分方程（PDE）描述：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中 $u(x, t)$ 是在位置 $x$ 和时间 $t$ 的温度。问题指定了一个周期性域，这意味着对于某个周期 $L$，有 $u(x, t) = u(x+L, t)$。对于我们的数值模拟，域是 $N$ 个点的离散集合，周期性通过连接边界来强制实现，使得点 $i=0$ 的左邻居是 $i=N-1$，点 $i=N-1$ 的右邻居是 $i=0$。\n\n为了数值求解这个方程，我们对空间和时间都进行离散化。设空间域被离散化为 $N$ 个点，均匀间距为 $\\Delta x$，时间被离散化为大小为 $\\Delta t$ 的步长。我们将 $u(i\\Delta x, n\\Delta t)$ 的数值近似表示为 $u_i^n$。前向时间中心空间（FTCS）格式按如下方式近似导数：\n- 时间导数 $\\frac{\\partial u}{\\partial t}$ 使用前向差分进行近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(i,n)} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- 空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n将这些近似值代入热方程，得到 FTCS 更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n重新整理此方程以求解未来状态 $u_i^{n+1}$，得到问题陈述中提供的显式公式：\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right)\n$$\n其中 $r = \\frac{\\Delta t}{(\\Delta x)^2}$ 是该抛物线型问题的无量纲 Courant-Friedrichs-Lewy (CFL) 数。\n\n这个更新规则是一个线性变换。如果我们将时间步 $n$ 处的系统状态表示为一个向量 $\\mathbf{u}^n = [u_0^n, u_1^n, \\dots, u_{N-1}^n]^T$，那么从一个时间步到下一个时间步的演化可以用矩阵形式表示：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A} \\mathbf{u}^n\n$$\n其中 $\\mathbf{A}$ 是 $N \\times N$ 的放大矩阵。根据更新规则和周期性边界条件（$u_{-1} = u_{N-1}$ 和 $u_N = u_0$），矩阵 $\\mathbf{A}$ 是一个具有以下结构的循环矩阵：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1-2r  r  0  \\dots  0  r \\\\\nr  1-2r  r  \\dots  0  0 \\\\\n0  r  1-2r  \\dots  0  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  0  \\dots  1-2r  r \\\\\nr  0  0  \\dots  r  1-2r\n\\end{pmatrix}\n$$\n问题在于研究数值舍入误差的传播。由于演化方程是线性的，任何误差 $\\mathbf{e}^n$ 都将根据相同的规则演化：$\\mathbf{e}^{n+1} = \\mathbf{A} \\mathbf{e}^n$。根据归纳法，经过 $T$ 个时间步后的误差由 $\\mathbf{e}^T = \\mathbf{A}^T \\mathbf{e}^0$ 给出。\n\n模拟过程如下：\n1.  对于每个测试用例 $(N, r, T)$，创建一个大小为 $N$ 的初始误差向量 $\\mathbf{e}^0$。该向量在除中心索引 $i_0 = \\lfloor N/2 \\rfloor$ 外的所有位置都初始化为零。\n2.  将该单点的值设为双精度机器精度 $\\varepsilon = 2^{-52}$。因此，$\\mathbf{e}^0_{i_0} = \\varepsilon$。\n3.  计算此初始向量的欧几里得范数（或 $L_2$-范数）：$\\lVert \\mathbf{e}^0 \\rVert_2 = \\sqrt{\\sum_{i=0}^{N-1} (e_i^0)^2} = \\sqrt{\\varepsilon^2} = \\varepsilon$。\n4.  一个循环迭代 $T$ 个时间步。在每个步骤 $n$ 中，使用带有周期性边界条件的 FTCS 更新规则从 $\\mathbf{e}^n$ 计算误差向量 $\\mathbf{e}^{n+1}$。\n5.  经过 $T$ 步后，得到最终误差向量 $\\mathbf{e}^T$。计算其欧几里得范数 $\\lVert \\mathbf{e}^T \\rVert_2$。\n6.  然后根据其定义计算每个时间步的几何增长因子 $g$：\n$$\ng = \\left(\\frac{\\lVert \\mathbf{e}^T \\rVert_2}{\\lVert \\mathbf{e}^0 \\rVert_2}\\right)^{1/T}\n$$\n$g > 1$ 的值表示误差被放大，该格式对于给定参数是不稳定的。$g  1$ 的值表示误差被衰减，该格式是稳定的。$g \\approx 1$ 的值表示中性稳定或临界情况。对所提供的四个测试用例中的每一个都执行此过程。实现将使用 `numpy` 进行高效的数组操作，特别是使用 `numpy.roll` 来优雅地处理周期性边界条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical amplification factor for the FTCS scheme\n    for the 1D heat equation under different stability regimes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, r, T)\n    # N: number of spatial points\n    # r: nondimensional ratio delta_t / (delta_x)^2\n    # T: number of time steps\n    test_cases = [\n        (64, 0.25, 200),  # Test 1: stable\n        (64, 0.51, 80),   # Test 2: unstable (mild)\n        (33, 0.5, 200),   # Test 3: borderline\n        (128, 0.9, 30),   # Test 4: unstable (severe)\n    ]\n\n    results = []\n    \n    # The IEEE 754 double-precision machine epsilon\n    epsilon = np.finfo(float).eps\n\n    for N, r, T in test_cases:\n        # Initialize the perturbation field 'e'.\n        # It is zero everywhere except for a single point.\n        e = np.zeros(N, dtype=float)\n        \n        # Set the perturbation at the central grid point.\n        # i_0 = floor(N/2) is implemented via integer division.\n        i0 = N // 2\n        e[i0] = epsilon\n        \n        # The initial L2 norm of the error vector.\n        # Since only one element is non-zero, the norm is its absolute value.\n        norm_e0 = np.linalg.norm(e)\n\n        # Evolve the perturbation for T time steps using the FTCS scheme.\n        for _ in range(T):\n            # Applying periodic boundary conditions efficiently using np.roll.\n            # np.roll(e, 1) shifts elements to the right (e_{i-1})\n            # np.roll(e, -1) shifts elements to the left (e_{i+1})\n            e_im1 = np.roll(e, 1)\n            e_ip1 = np.roll(e, -1)\n            \n            # Apply the FTCS update rule.\n            e = e + r * (e_ip1 - 2 * e + e_im1)\n\n        # Calculate the L2 norm of the final error vector.\n        norm_eT = np.linalg.norm(e)\n        \n        # Calculate the geometric amplification factor per time step, g.\n        # Handle the case where the error is damped to zero to avoid division errors.\n        if norm_eT == 0.0 or norm_e0 == 0.0:\n            g = 0.0\n        else:\n            g = (norm_eT / norm_e0)**(1.0 / T)\n\n        results.append(g)\n\n    # Format the results as a list of strings, each rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "FTCS 格式的条件稳定性对时间步长施加了严格的限制，这在计算上可能代价高昂。这就引出了一个问题：是否所有显式方法都必须受此限制？Saul'yev 格式提供了一个出人意料且优雅的答案。在此练习  中，你将实现这种非对称的显式方法，并验证其非凡的无条件稳定性特性，展示深思熟虑的算法设计如何带来更强大、更高效的求解器。",
            "id": "2400852",
            "problem": "考虑定义在有限区间上、满足齐次狄利克雷边界条件的一维热方程（一个二阶线性偏微分方程）。设热扩散率为正常数 $a>0$，空间域为 $x \\in [0,L]$，时间为 $t \\ge 0$。温度场 $u(x,t)$ 满足\n$$\n\\frac{\\partial u}{\\partial t} = a \\,\\frac{\\partial^2 u}{\\partial x^2},\\quad x\\in(0,L),\\ t0,\n$$\n边界条件为\n$$\nu(0,t)=0,\\quad u(L,t)=0,\\quad t \\ge 0,\n$$\n初始条件为\n$$\nu(x,0)=\\sin(\\pi x),\\quad x \\in [0,L].\n$$\n取 $L=1$ 和 $a=1$。在这些条件下，精确解为\n$$\nu_{\\text{exact}}(x,t)=\\mathrm{e}^{-\\pi^2 t}\\,\\sin(\\pi x).\n$$\n使用具有 $N$ 个子区间的均匀网格，空间步长为 $\\Delta x = L/N$，并定义无量纲比率 $r = a\\,\\Delta t/(\\Delta x)^2$。对于给定的整数时间步数 $N_t\\ge 1$，时间步长为 $\\Delta t = r\\,(\\Delta x)^2/a$，最终时间为 $T = N_t\\,\\Delta t$。\n\n实现一个归属于 Saul'yev 的显式从左到右扫描的时间推进格式，该格式在每个时间层级上，使用已更新的左邻居点和尚未更新的右邻居点来顺序推进内部网格点的值，同时在每个时间层级强制施加齐次狄利克雷边界值。假设 $u$ 在网格点 $x_j=j\\,\\Delta x$（$j=0,1,\\dots,N$）上表示。\n\n对于下方的每个测试用例，从在网格上采样的初始条件 $u(x,0)=\\sin(\\pi x)$ 开始，精确推进 $N_t$ 个时间步，并计算所要求的量。所有要求的输出都是无量纲实数。您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，并按测试用例的顺序排列。\n\n测试套件（固定 $L=1$ 和 $a=1$）：\n- 用例 1（中等 $r$ 值下的精度）：$N=128$，$r=0.4$，$N_t=4096$。计算在时间 $T$ 的相对 $L^2$ 误差，定义为\n$$\nE_{\\mathrm{rel}} = \\frac{\\left(\\sum_{j=0}^{N} \\left(u_j^{N_t} - u_{\\text{exact}}(x_j,T)\\right)^2\\right)^{1/2}}{\\left(\\sum_{j=0}^{N} \\left(u_{\\text{exact}}(x_j,T)\\right)^2\\right)^{1/2}}.\n$$\n- 用例 2（一步后的边界强制）：$N=64$，$r=0.9$，$N_t=1$。计算\n$$\nB = \\max\\left(\\left|u_0^{1}\\right|,\\ \\left|u_{N}^{1}\\right|\\right).\n$$\n- 用例 3（大 $r$ 值压力测试）：$N=50$，$r=5.0$，$N_t=200$。计算最终时间的最大绝对值，\n$$\nM = \\max_{0\\le j\\le N}\\left|u_j^{N_t}\\right|.\n$$\n- 用例 4（相同最终时间下的网格加密比较）：使用两个网格和时间步数，选择它们以产生相同的最终时间。设 $N_1=50$，$N_2=100$，$r=0.3$，$N_{t,1}=2500$，$N_{t,2}=10000$。计算它们共同的最终时间 $T$ 时的相对 $L^2$ 误差 $E_{\\mathrm{rel}}(N_1)$ 和 $E_{\\mathrm{rel}}(N_2)$，然后报告其比率\n$$\nR = \\frac{E_{\\mathrm{rel}}(N_1)}{E_{\\mathrm{rel}}(N_2)}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"），顺序为：用例 1 的 $E_{\\mathrm{rel}}$，用例 2 的 $B$，用例 3 的 $M$，以及用例 4 的 $R$。",
            "solution": "该问题经过严格验证，被认为是有效的。它提出了一个适定的一维热方程初边值问题，并要求实现一种特定的数值格式，即 Saul'yev 方法。该问题在科学上是合理的，内容是自洽的，并且所有参数都得到了明确的定义。我们着手求解。\n\n控制偏微分方程是热方程：\n$$\n\\frac{\\partial u}{\\partial t} = a \\,\\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于定义在区域 $x \\in [0,L]$ 上且 $t \\ge 0$ 的函数 $u(x,t)$。参数固定为 $L=1$ 和热扩散率 $a=1$。该问题补充有齐次狄利克雷边界条件 $u(0,t)=u(L,t)=0$ 和初始条件 $u(x,0)=\\sin(\\pi x)$。\n\n任务是采用有限差分法来近似求解。空间域 $[0,L]$ 被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀子区间。网格点为 $x_j = j\\,\\Delta x$，其中 $j=0, 1, \\dots, N$。时间域以恒定的时间步长 $\\Delta t$ 进行离散化。我们将 $u(x_j, t_n)$ 的数值近似表示为 $u_j^n$，其中 $t_n = n\\,\\Delta t$。\n\n指定的数值算法是显式从左到右扫描的 Saul'yev 格式。这是一种交替方向显式（ADE）方法，以其无条件稳定性而闻名，相比于仅在 $r \\le 0.5$ 时条件稳定的标准 FTCS 格式，这是一个显著的改进。Saul'yev 格式的稳定性允许使用相对于空间网格间距大的时间步长（由无量纲比率 $r = a\\,\\Delta t/(\\Delta x)^2$ 量化），而不会导致数值解发散。\n\n为了推导更新公式，我们用前向差分来近似时间导数，并用不同时间层级上值的特定组合来近似空间导数。所描述的 Saul'yev 格式使用了时间层级 $n$ 和新时间层级 $n+1$ 上的值的混合：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = a \\left( \\frac{u_{j-1}^{n+1} - u_j^{n+1} - u_j^n + u_{j+1}^n}{(\\Delta x)^2} \\right)\n$$\n这种特殊的离散化方法旨在促进跨网格的顺序、显式更新。通过重新排列各项以求解 $u_j^{n+1}$，我们得到计算模板：\n$$\nu_j^{n+1} - u_j^n = r \\left( u_{j-1}^{n+1} - u_j^{n+1} - u_j^n + u_{j+1}^n \\right)\n$$\n$$\n(1+r) u_j^{n+1} = u_j^n + r u_{j-1}^{n+1} - r u_j^n + r u_{j+1}^n\n$$\n$$\nu_j^{n+1} = \\frac{r}{1+r} u_{j-1}^{n+1} + \\frac{1-r}{1+r} u_j^n + \\frac{r}{1+r} u_{j+1}^n\n$$\n这个方程是算法的核心。它应用于内部网格点 $j=1, 2, \\dots, N-1$。\n\n该格式的“从左到右扫描”性质从该公式的结构中可以清楚地看出。为了计算 $u_j^{n+1}$，需要访问 $u_{j-1}^{n+1}$，即新时间层级 $n+1$ 上左邻点的值。这需要从左边界（$j=1$ 处）开始并向右进行（到 $j=N-1$）的顺序计算。\n\n将解从时间 $t_n$ 推进到 $t_{n+1}$ 的计算过程如下：\n1.  为新时间层级上的解初始化一个临时数组 $u^{n+1}$。强制施加边界条件：$u_0^{n+1} = 0$ 和 $u_N^{n+1} = 0$。\n2.  对于 $j=1, 2, \\dots, N-1$（按升序），使用推导出的公式计算 $u_j^{n+1}$。在每一步 $j$ 中，值 $u_{j-1}^{n+1}$ 从扫描的前一步（或对于 $j=1$ 而言，从边界条件）已知，而 $u_j^n$ 和 $u_{j+1}^n$ 从前一时间层级 $n$ 已知。\n3.  对所有内部点完成扫描后，时间层级 $n+1$ 的解就完全确定了。然后用这些新值更新层级 $n$ 的解数组。\n\n整个算法包括以下几个阶段：\n1.  **设置**：基于给定的 $N$ 建立空间网格 $x_j$ 来离散化区域。根据给定的 $r$ 计算 $\\Delta x$ 和随后的 $\\Delta t$。\n2.  **初始化**：使用在网格点 $x_j$ 上求值的初始条件 $u(x,0)=\\sin(\\pi x)$ 来填充数值解数组 $u^0$。\n3.  **时间推进**：迭代 $N_t$ 次。在每次迭代中，应用上述的从左到右扫描过程将解从层级 $n$ 推进到 $n+1$。\n4.  **后处理**：经过 $N_t$ 步后，在时间 $T = N_t \\Delta t$ 得到最终的数值解 $u^{N_t}$。然后基于此最终状态，以及在必要时，基于在网格点上求值的精确解 $u_{\\text{exact}}(x,T)=\\mathrm{e}^{-\\pi^2 T}\\,\\sin(\\pi x)$，来计算所需的度量。\n\n对于用例 2，在单个时间步后计算量 $B = \\max\\left(\\left|u_0^{1}\\right|,\\ \\left|u_{N}^{1}\\right|\\right)$。由于齐次狄利克雷边界条件在每个时间步（包括第一步）都严格强制执行，因此值 $u_0^1$ 和 $u_N^1$ 必须恒为零。因此，$B$ 必须精确为 $0$。这可作为对边界条件正确实现的基本检查。\n\n对于用例 4，考察了格式的收敛性。该 Saul'yev 格式的理论误差为 $\\mathcal{O}(\\Delta t, (\\Delta x)^2)$。鉴于 $r = a\\Delta t / (\\Delta x)^2$ 保持不变，$\\Delta t$ 与 $(\\Delta x)^2$ 成正比。因此，主导误差项预计是空间误差，其缩放尺度为 $(\\Delta x)^2$。当空间网格加密一倍（即 $N$ 加倍，$\\Delta x$ 减半）时，误差预计会减少 $2^2=4$ 倍。因此，比率 $R$ 预计接近 $4$。\n\n实现将是模块化的，其中一个核心函数负责处理给定参数集 $(N, r, N_t)$ 的模拟，一个主驱动程序则负责执行四个指定的测试用例并格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the results.\n    \"\"\"\n    # Global parameters from the problem statement\n    L = 1.0\n    a = 1.0\n\n    def solve_saulyev(N, r, Nt):\n        \"\"\"\n        Solves the 1D heat equation using the left-to-right Saul'yev scheme.\n        \n        Args:\n            N (int): Number of subintervals.\n            r (float): Dimensionless ratio a*dt/(dx^2).\n            Nt (int): Number of time steps.\n\n        Returns:\n            tuple: (final numerical solution u, final time T, spatial grid x)\n        \"\"\"\n        # 1. Setup Phase\n        dx = L / N\n        dt = r * (dx**2) / a\n        T = Nt * dt\n        \n        # Spatial grid (N+1 points from x=0 to x=L)\n        x = np.linspace(0, L, N + 1)\n        \n        # 2. Initialization Phase\n        # u at current time step n\n        u = np.sin(np.pi * x)\n        # u at next time step n+1\n        u_new = np.zeros(N + 1)\n        \n        # Pre-calculate coefficients for efficiency\n        c1 = r / (1.0 + r)\n        c2 = (1.0 - r) / (1.0 + r)\n\n        # 3. Time Marching Phase\n        for _ in range(Nt):\n            # Boundary conditions u(0,t)=0 and u(L,t)=0 are enforced by\n            # initializing u_new to zeros and only updating interior points.\n            \n            # Left-to-right sweep for interior points j = 1, ..., N-1\n            for j in range(1, N):\n                # u_new[j-1] is the already-updated left neighbor at time n+1\n                # u[j] and u[j+1] are from the previous time step n\n                u_new[j] = c1 * u_new[j-1] + c2 * u[j] + c1 * u[j+1]\n                \n            # Update u for the next time step by copying values from u_new\n            u[:] = u_new[:]\n            \n        return u, T, x\n\n    def get_exact_solution(x, T):\n        \"\"\"Computes the exact solution u(x,T) on the grid x.\"\"\"\n        return np.exp(-np.pi**2 * T) * np.sin(np.pi * x)\n\n    def calculate_relative_L2_error(u_num, u_exact):\n        \"\"\"Calculates the relative L2 error norm.\"\"\"\n        norm_exact = np.linalg.norm(u_exact)\n        if norm_exact == 0.0:\n            return np.linalg.norm(u_num) if np.linalg.norm(u_num) > 0.0 else 0.0\n            \n        error_norm = np.linalg.norm(u_num - u_exact)\n        return error_norm / norm_exact\n\n    # --- Processing Test Cases ---\n    \n    results = []\n\n    # Case 1: Accuracy at moderate r\n    N1, r1, Nt1 = 128, 0.4, 4096\n    u_final1, T1, x1 = solve_saulyev(N1, r1, Nt1)\n    u_exact1 = get_exact_solution(x1, T1)\n    E_rel1 = calculate_relative_L2_error(u_final1, u_exact1)\n    results.append(E_rel1)\n    \n    # Case 2: Boundary enforcement after one step\n    N2, r2, Nt2 = 64, 0.9, 1\n    u_final2, _, _ = solve_saulyev(N2, r2, Nt2)\n    B = np.max([np.abs(u_final2[0]), np.abs(u_final2[-1])])\n    results.append(B)\n\n    # Case 3: Large r stress test\n    N3, r3, Nt3 = 50, 5.0, 200\n    u_final3, _, _ = solve_saulyev(N3, r3, Nt3)\n    M = np.max(np.abs(u_final3))\n    results.append(M)\n    \n    # Case 4: Refinement comparison\n    # First simulation\n    N4_1, r4, Nt4_1 = 50, 0.3, 2500\n    u_final4_1, T4_1, x4_1 = solve_saulyev(N4_1, r4, Nt4_1)\n    u_exact4_1 = get_exact_solution(x4_1, T4_1)\n    E_rel4_1 = calculate_relative_L2_error(u_final4_1, u_exact4_1)\n\n    # Second simulation\n    N4_2, r4, Nt4_2 = 100, 0.3, 10000\n    u_final4_2, T4_2, x4_2 = solve_saulyev(N4_2, r4, Nt4_2)\n    u_exact4_2 = get_exact_solution(x4_2, T4_2)\n    E_rel4_2 = calculate_relative_L2_error(u_final4_2, u_exact4_2)\n    \n    # Ratio of errors\n    R = E_rel4_1 / E_rel4_2\n    results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的问题很少会遵循简单的一维笛卡尔网格。这个练习  将我们的分析扩展到二维圆盘上的热扩散，引入了在极坐标下离散化热方程的挑战，尤其是在方程具有奇异性的原点处。你将使用稳健的 Crank-Nicolson 方法，这是一种强大的隐式格式，它能保证无论时间步长大小如何都保持稳定，并提供卓越的时间精度，为广大的物理和工程仿真问题提供了一种基石技术。",
            "id": "2400870",
            "problem": "考虑一个半径为 $R$ 的二维圆盘中的径向对称热传导问题，其中温度仅取决于径向坐标 $r$ 和时间 $t$。该问题的控制方程源于局部能量守恒和傅里叶热传导定律，是在极坐标下无角度依赖的热方程：\n$$\n\\frac{\\partial u}{\\partial t}(r,t) = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}(r,t) + \\frac{1}{r}\\frac{\\partial u}{\\partial r}(r,t) \\right), \\quad 0 \\le r \\le R, \\; t \\ge 0,\n$$\n其边界条件为对所有 $t \\ge 0$ 都有 $u(R,t) = 0$，并且在原点处具有与物理对称性一致的正则性。假设所有物理量均为无量纲。\n\n您的任务是编写一个完整、可运行的程序，使用一种时间上无条件稳定且二阶精确的格式来计算该初边值问题的温度演化。空间离散化必须是二阶精确的，并且其构建方式必须确保在原点 $r=0$ 处的离散化与拉普拉斯算子的极坐标形式以及由有限能量和傅里叶定律所蕴含的对称性条件相一致。您必须从守恒律形式出发，得到一个在 $r \\to 0$ 时遵循正确极限行为的离散格式。\n\n请使用以下规范：\n\n- 计算域为径向坐标上的区间 $[0,R]$。\n- 使用均匀网格 $r_i = i \\,\\Delta r$，其中 $i = 0,1,\\dots,N$，$ \\Delta r = R/N$。\n- 对所有时间层 $n$，施加边界条件 $u_N^n = 0$。\n- 初始条件为 $u(r,0) = \\exp\\!\\left( -\\left(\\frac{r}{\\sigma}\\right)^2 \\right)$。\n- 时间步进格式必须是 Crank–Nicolson 方法（在时间上也被称为梯形法则），当与二阶精确的空间离散化方法配合使用时，该方法是无条件稳定且时间上二阶精确的。将该方法组装成矩阵形式，并在每个时间步求解得到的线性系统。\n- 离散空间算子必须能正确处理 $r=0$ 处而没有奇异性，并且必须通过在原点处对极坐标拉普拉斯算子取适当极限，从第一性原理推导得出。您不能在 $r=0$ 处引入临时的低阶修正。\n\n测试套件和输出：\n\n- 针对以下四个测试用例运行您的程序。在每个用例中，按下文所列设置参数 $(\\alpha, R, \\sigma, N, M, T)$，其中 $M$ 是均匀时间步的数量，$\\Delta t = T/M$：\n  - 用例 $1$：$(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 200, 50, 0.05)$。\n  - 用例 $2$：$(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 50, 50, 0.05)$。\n  - 用例 $3$：$(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.05, 200, 100, 0.02)$。\n  - 用例 $4$：$(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.5, 200, 50, 0.05)$。\n- 对于每个用例，计算数值解直至最终时间 $T$，并报告原点处的温度，即 $u(0,T)$。\n- 您的程序必须生成单行输出，其中包含四个用例的结果，格式为方括号括起来的逗号分隔列表，并按用例 1 到用例 4 的顺序排列。每个数字必须四舍五入到八位小数。例如，输出格式必须严格为\n$[x_1,x_2,x_3,x_4]$\n其中每个 $x_i$ 是用例 $i$ 的 $u(0,T)$ 值，四舍五入到八位小数。\n\n您的实现必须是自包含的，不得读取任何用户输入，也不得需要任何外部文件或网络访问。问题的最终答案必须是代码。通过推导和使用与极坐标拉普拉斯算子极限行为一致的原点空间离散化方法，确保科学真实性。本问题中的数值量均为无量纲；不需要物理单位。最终输出格式的要求是严格的，必须严格遵守。",
            "solution": "所给出的问题是一个关于二维圆盘内径向对称线性热方程的适定初边值问题。它在科学上是合理的，并包含了进行数值求解所需的所有必要信息。因此，我们将着手解决此问题。\n\n我们的目标是计算由极坐标下径向对称热方程控制的温度演化 $u(r,t)$：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} \\right)\n$$\n对于 $r \\in [0, R]$ 和 $t \\ge 0$。该问题受边界条件 $u(R,t) = 0$ 和初始条件 $u(r,0) = \\exp(-(r/\\sigma)^2)$ 的约束。物理上的一致性要求，由于对称性，原点处的温度梯度必须为零，即 $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$。\n\n我们将采用 Crank-Nicolson 方法进行时间积分，这是一种二阶精确且无条件稳定的格式。该方程在时间上离散为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathcal{L}_h \\mathbf{u}^{n+1} + \\mathcal{L}_h \\mathbf{u}^n \\right)\n$$\n其中 $\\mathbf{u}^n$ 是在时间 $t_n = n\\Delta t$ 的数值解向量，$\\mathcal{L}_h$ 是逼近连续算子 $\\mathcal{L} \\equiv \\alpha \\left( \\frac{\\partial^2}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial}{\\partial r} \\right)$ 的离散空间算子。该格式是隐式的，可以整理成一个在每个时间步都需要求解的线性系统：\n$$\n\\left(I - \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^n\n$$\n其中 $L$ 是 $\\mathcal{L}_h$ 的矩阵表示。未知量向量由离散径向点上的温度组成，$\\mathbf{u} = [u_0, u_1, \\ldots, u_{N-1}]^T$，对应于半径 $r_i = i\\Delta r$，$i=0, \\ldots, N-1$，其中 $\\Delta r = R/N$。边界条件固定了对所有 $n$ 都有 $u_N^n = 0$。\n\n关键步骤是构建一个二阶精确的空间离散化 $\\mathcal{L}_h$。\n\n对于内部点 $r_i$ (其中 $i \\in \\{1, 2, \\ldots, N-1\\}$)，我们使用标准的二阶中心差分公式来计算导数：\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2}, \\quad \\frac{\\partial u}{\\partial r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2\\Delta r}\n$$\n将这些代入 $\\mathcal{L}u$ 的表达式中，得到节点 $i$ 处的离散算子：\n$$\n(\\mathcal{L}_h \\mathbf{u})_i = \\alpha \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2} + \\frac{1}{i\\Delta r} \\frac{u_{i+1} - u_{i-1}}{2\\Delta r} \\right) = \\frac{\\alpha}{(\\Delta r)^2} \\left[ \\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} \\right]\n$$\n\n在原点 $r=0$ ($i=0$) 处，项 $\\frac{1}{r}\\frac{\\partial u}{\\partial r}$ 是奇异的。正确的离散化必须通过考虑拉普拉斯算子的极限行为来推导。根据对称性，温度分布必须是 $r$ 的偶函数，这意味着 $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$。对奇异项应用 L'Hôpital 法则，我们发现：\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{\\partial u}{\\partial r} = \\lim_{r\\to 0} \\frac{\\frac{\\partial^2 u}{\\partial r^2}}{1} = \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\n因此，原点处的热方程变为：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{r=0} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} + \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} \\right) = 2\\alpha \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\n我们使用中心差分来离散 $r=0$ 处的二阶导数。对称性条件 $u_r(0)=0$ 意味着对于围绕 $r=0$ 的泰勒展开，$u(r) = u(0) + \\frac{1}{2}u_{rr}(0)r^2 + O(r^4)$。这表明 $u(\\Delta r) = u(-\\Delta r)$，在我们的离散记法中即为 $u_1 = u_{-1}$。$u_{rr}(0)$ 的中心差分为：\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{(\\Delta r)^2} = \\frac{u_1 - 2u_0 + u_1}{(\\Delta r)^2} = \\frac{2(u_1 - u_0)}{(\\Delta r)^2}\n$$\n将此代入原点处的特殊热方程，得到 $i=0$ 处的离散格式：\n$$\n(\\mathcal{L}_h \\mathbf{u})_0 = 2\\alpha \\left( \\frac{2(u_1 - u_0)}{(\\Delta r)^2} \\right) = \\frac{4\\alpha}{(\\Delta r)^2} (u_1 - u_0)\n$$\n这种离散化是二阶精确的，并且与几何形状相符。\n\n利用这些表达式，我们构造 $N \\times N$ 矩阵 $L$。设 $c = \\alpha/(\\Delta r)^2$。\n- 第一行 ($i=0$) 是：$L_{0,0} = -4c$，$L_{0,1} = 4c$，对于 $j1$，$L_{0,j}=0$。\n- 对于行 $i=1, \\ldots, N-2$，非零元素为：\n  $L_{i,i-1} = c(1 - 1/(2i))$，$L_{i,i} = -2c$，$L_{i,i+1} = c(1+1/(2i))$。\n- 最后一行 ($i=N-1$) 必须考虑边界条件 $u_N=0$：\n  $L_{N-1,N-2} = c(1 - 1/(2(N-1)))$ 和 $L_{N-1,N-1} = -2c$。\n\n算法流程如下：\n1.  对每个测试用例，定义参数 $(\\alpha, R, \\sigma, N, M, T)$ 并计算 $\\Delta r=R/N$ 和 $\\Delta t=T/M$。\n2.  构造矩阵 $A = I - \\frac{\\Delta t}{2} L$ 和 $B = I + \\frac{\\Delta t}{2} L$。为提高效率，我们在时间步进循环开始前，对矩阵 $A$ 进行一次 LU 分解。\n3.  使用初始条件初始化解向量 $\\mathbf{u}^0$：$u_i^0 = \\exp(-(i\\Delta r/\\sigma)^2)$，其中 $i=0, \\ldots, N-1$。\n4.  对 $n=0, \\ldots, M-1$ 进行迭代：\n    a. 计算右端向量 $\\mathbf{b} = B \\mathbf{u}^n$。\n    b. 使用预先计算的 $A$ 的 LU 分解，求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}$ 以得到 $\\mathbf{u}^{n+1}$。\n5.  经过 $M$ 步后，原点处的最终温度为 $u_0^M$，即最终解向量的第一个元素。报告此值。\n实现将使用 `numpy` 进行矩阵运算，并使用 `scipy.linalg` 来高效求解线性系统。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the radially symmetric heat equation for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, R, sigma, N, M, T)\n        (1.0, 1.0, 0.2, 200, 50, 0.05),\n        (1.0, 1.0, 0.2, 50, 50, 0.05),\n        (1.0, 1.0, 0.05, 200, 100, 0.02),\n        (1.0, 1.0, 0.5, 200, 50, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, R, sigma, N, M, T = case\n        result = run_simulation(alpha, R, sigma, N, M, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(alpha, R, sigma, N, M, T):\n    \"\"\"\n    Computes the temperature evolution for a single test case.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        R (float): Radius of the disk.\n        sigma (float): Width of the initial Gaussian profile.\n        N (int): Number of spatial grid points in the radius (excluding the boundary).\n        M (int): Number of time steps.\n        T (float): Final time.\n\n    Returns:\n        float: Temperature at the origin u(0, T).\n    \"\"\"\n    # Grid parameters\n    dr = R / N\n    dt = T / M\n    \n    # Grid points for r (interior points from r=0 to r=R-dr)\n    r = np.linspace(0, R - dr, N)\n\n    # Construct the spatial discretization matrix L\n    # The size of the system is N x N for points u_0, u_1, ..., u_{N-1}\n    L = np.zeros((N, N))\n    c = alpha / dr**2\n\n    # Equation at the origin (i=0)\n    L[0, 0] = -4.0 * c\n    L[0, 1] = 4.0 * c\n\n    # Equations for interior points (i=1 to N-2)\n    for i in range(1, N - 1):\n        # r_i = i * dr, so the coefficients simplify\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        L[i, i + 1] = c * (1.0 + 1.0 / (2.0 * i))\n\n    # Equation at the point next to the boundary (i=N-1)\n    # The u_N term is zero due to boundary condition and moves to the other side.\n    if N > 1:\n        i = N - 1\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        # The u_{N} term is u_N = 0, so L[i, i+1] which would reference u_N is zero.\n\n    # Construct Crank-Nicolson matrices A and B\n    # A u^{n+1} = B u^{n}\n    # where A = I - dt/2 * L, B = I + dt/2 * L\n    I = np.identity(N)\n    A = I - (dt / 2.0) * L\n    B = I + (dt / 2.0) * L\n\n    # Initial condition u(r, 0)\n    u = np.exp(-(r / sigma)**2)\n\n    # Pre-compute LU factorization of A for efficiency\n    try:\n        lu_and_piv = linalg.lu_factor(A)\n    except linalg.LinAlgError:\n        # This case should not be reached for a well-posed problem.\n        return np.nan\n\n    # Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side vector\n        b = B @ u\n        # Solve the linear system A u_next = b\n        u = linalg.lu_solve(lu_and_piv, b)\n\n    # Return the temperature at the origin at the final time\n    return u[0]\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}