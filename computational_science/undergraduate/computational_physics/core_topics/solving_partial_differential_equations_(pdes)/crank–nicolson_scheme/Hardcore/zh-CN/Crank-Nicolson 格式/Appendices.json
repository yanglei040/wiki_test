{
    "hands_on_practices": [
        {
            "introduction": "广义 $\\theta$ 方法提供了一个统一的框架，涵盖了从显式欧拉法到全隐式方法的多种格式，其中 Crank-Nicolson 方案是 $\\theta=0.5$ 的特例。本练习旨在通过数值实验来探索和验证这些方案的稳定性边界。通过改变参数 $\\theta$ 和扩散数，你将亲手验证 Crank-Nicolson 方案无条件稳定性的重要优势，并理解为何其他方案需要满足严格的时间步长限制 。",
            "id": "2443588",
            "problem": "实现一个程序，该程序使用均匀空间离散化和周期性边界条件，对一维热传导方程的时间广义 $\\theta$ 方法进行分析，并对指定的参数集进行稳定性分类。\n\n数学模型与离散化：\n- 连续问题：周期性域 $x \\in [0, L)$（其中 $L=1$）上的热传导方程 $u_t = \\alpha u_{xx}$，其中 $\\alpha > 0$ 是一个常数，所有量均为无量纲。\n- 空间离散化：使用 $N$ 个均匀点，网格间距为 $h = L/N$。定义离散二阶导数算子（离散拉普拉斯算子）$D \\in \\mathbb{R}^{N \\times N}$ 为\n$$\n(D \\mathbf{u})_i = \\frac{\\mathbf{u}_{i-1} - 2 \\mathbf{u}_i + \\mathbf{u}_{i+1}}{h^2},\n$$\n采用周期性索引，即 $\\mathbf{u}_{-1} \\equiv \\mathbf{u}_{N-1}$ 和 $\\mathbf{u}_{N} \\equiv \\mathbf{u}_{0}$。\n- 时间离散化：对于时间步长 $\\Delta t > 0$ 和参数 $\\theta \\in [0,1]$，广义 $\\theta$ 方法的单步更新算子 $M \\in \\mathbb{R}^{N \\times N}$ 定义为\n$$\n\\left(I - \\theta \\,\\alpha \\,\\Delta t \\, D \\right)\\,\\mathbf{u}^{n+1} = \\left(I + (1-\\theta)\\,\\alpha \\,\\Delta t \\, D \\right)\\,\\mathbf{u}^{n},\n$$\n因此\n$$\nM = \\left(I - \\theta \\,\\alpha \\,\\Delta t \\, D \\right)^{-1} \\left(I + (1-\\theta)\\,\\alpha \\,\\Delta t \\, D \\right).\n$$\n\n用于对各参数集进行分类的稳定性判据：\n- 定义谱半径 $\\rho(M)$ 为矩阵 $M$ 特征值的最大模。\n- 如果 $\\rho(M) \\le 1 + \\varepsilon$（其中 $\\varepsilon = 10^{-10}$ 是一个固定的数值容差），则该参数集被分类为稳定；否则分类为不稳定。\n\n测试集：\n使用以下六个参数集，每个参数集均设置 $L = 1$ 和 $\\alpha = 1$：\n1. $N = 64$, $\\theta = 0$, $\\Delta t = 0.25\\,h^2$。\n2. $N = 64$, $\\theta = 0$, $\\Delta t = 0.75\\,h^2$。\n3. $N = 64$, $\\theta = 0.5$, $\\Delta t = 30\\,h^2$。\n4. $N = 64$, $\\theta = 1$, $\\Delta t = 100\\,h^2$。\n5. $N = 64$, $\\theta = 0.25$, $\\Delta t = 1\\,h^2$。\n6. $N = 64$, $\\theta = 0.49$, $\\Delta t = 30\\,h^2$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述测试集顺序排列的六个布尔稳定性分类，形式为方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\dots]$。",
            "solution": "所提出的问题是确定一维热传导方程 $u_t = \\alpha u_{xx}$ 在周期性域上广义 $\\theta$ 方法的数值稳定性。需要对六个特定的参数集进行分析。该问题是良定的、科学上合理的，并且是计算科学中的一个标准课题——有限差分格式的稳定性分析。\n\n分析的关键在于单步时间演化算子 $M$ 的谱半径 $\\rho(M)$。如果对于给定的数值容差 $\\varepsilon = 10^{-10}$，有 $\\rho(M) \\le 1 + \\varepsilon$，则该格式被定义为稳定。算子 $M$ 由下式给出\n$$\nM = \\left(I - \\theta \\,\\alpha \\,\\Delta t \\, D \\right)^{-1} \\left(I + (1-\\theta)\\,\\alpha \\,\\Delta t \\, D \\right),\n$$\n其中 $I$ 是单位矩阵，$D$ 是表示离散空间二阶导数的矩阵，$\\Delta t$ 是时间步长，$\\alpha$ 是热扩散系数，$\\theta$ 是该方法的参数。\n\n一种直接的数值计算方法是构造 $N \\times N$ 矩阵 $M$ 并随后计算其特征值，这是一种有效但计算效率低下的方法。我们将遵循一种更严谨、更优雅的方法，即进行模态分析。离散拉普拉斯算子 $D$ 的特征向量是离散傅里叶模态，这些模态也构成了算子 $M$ 的一组特征向量基。因此，$M$ 的特征值（记为 $\\mu_k$）可以直接用 $D$ 的特征值（记为 $\\lambda_k$）来表示。如果 $\\mathbf{v}_k$ 是 $D$ 的一个特征向量，其特征值为 $\\lambda_k$，那么它也是 $M$ 的一个特征向量，其特征值为\n$$\n\\mu_k = \\frac{1 + (1-\\theta)\\alpha \\Delta t \\lambda_k}{1 - \\theta \\alpha \\Delta t \\lambda_k}.\n$$\n该表达式是第 $k$ 个模态的放大因子。因此，格式的稳定性由所有模态中这些放大因子的最大模决定，即 $\\rho(M) = \\max_k |\\mu_k|$。\n\n对于具有 $N$ 个点、间距为 $h = L/N$ 的均匀网格和周期性边界条件，离散拉普拉斯算子 $D$ 是一个循环矩阵。其特征值有解析解：\n$$\n\\lambda_k = -\\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right), \\quad \\text{for } k = 0, 1, \\dots, N-1.\n$$\n这些特征值是实数且非正的，范围从 $\\lambda_0 = 0$ 到最高频率模态的最小值（约为 $-\\frac{4}{h^2}$）。\n\n将 $\\lambda_k$ 的表达式代入 $\\mu_k$ 的方程中，得到：\n$$\n\\mu_k = \\frac{1 - (1-\\theta)\\alpha \\Delta t \\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right)}{1 + \\theta \\alpha \\Delta t \\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right)}.\n$$\n让我们引入无量纲参数 $r = \\frac{\\alpha \\Delta t}{h^2}$，通常称为抛物线型库朗数。放大因子简化为：\n$$\n\\mu_k = \\frac{1 - 4r(1-\\theta)\\sin^2\\left(\\frac{\\pi k}{N}\\right)}{1 + 4r\\theta\\sin^2\\left(\\frac{\\pi k}{N}\\right)}.\n$$\n谱半径是所有 $k$ 中 $|\\mu_k|$ 的最大值。项 $\\sin^2(\\frac{\\pi k}{N})$ 的值在 $0$（当 $k=0$ 时）和 $1$（如果 $N$ 是偶数，当 $k=N/2$ 时）之间变化。由于函数 $f(x) = \\frac{1 - 4r(1-\\theta)x}{1 + 4r\\theta x}$ 在 $x \\in [0, 1]$ 上是单调的，其模的最大值在端点之一处取到。在 $x=0$ 处，$\\mu_0 = 1$。临界值通常在 $x=1$ 处，对应于最高频率。因此，稳定性条件 $\\rho(M) \\le 1$ 可简化为 $|\\frac{1 - 4r(1-\\theta)}{1 + 4r\\theta}| \\le 1$。此不等式导出了著名的稳定性判据：\n$$\n2r(1 - 2\\theta) \\le 1.\n$$\n如果 $\\theta \\ge 1/2$，则 $(1 - 2\\theta)$ 项为非正数，因此该不等式对任何正数 $r$ 都成立。这些格式是无条件稳定的。这包括克兰克-尼科尔森格式（$\\theta=0.5$）和后向欧拉方法（$\\theta=1$）。如果 $0 \\le \\theta < 1/2$，稳定性是有条件的，要求 $r \\le \\frac{1}{2(1-2\\theta)}$。\n\n现在我们将此分析框架应用于每个测试用例，其中常数 $L=1$, $\\alpha=1$, $N=64$，因此 $h=1/64$。参数 $r$ 就是 $\\Delta t / h^2$。\n\n1.  $N = 64$, $\\theta = 0$ (前向欧拉), $\\Delta t = 0.25\\,h^2$。\n    此处 $r = 0.25$。对于 $\\theta=0$，稳定性条件是 $r \\le 0.5$。由于 $0.25 \\le 0.5$，该格式是**稳定**的。最大放大因子为 $|\\mu_{32}| = |1 - 4(0.25)| = 0$。谱半径为 $\\rho(M) = 1$ (来自 $k=0$ 模态)。\n\n2.  $N = 64$, $\\theta = 0$, $\\Delta t = 0.75\\,h^2$。\n    此处 $r = 0.75$。条件 $r \\le 0.5$ 不被满足。该格式是**不稳定**的。最大放大因子为 $|\\mu_{32}| = |1 - 4(0.75)| = |-2| = 2$。\n\n3.  $N = 64$, $\\theta = 0.5$ (克兰克-尼科尔森), $\\Delta t = 30\\,h^2$。\n    此处 $r = 30$。由于 $\\theta = 0.5$，该格式是无条件稳定的。该格式是**稳定**的。对于任何 $r$，只要正弦项非零，就有 $|\\mu_k| = |\\frac{1 - 2r \\sin^2(\\dots)}{1 + 2r \\sin^2(\\dots)}| = 1$。因此 $\\rho(M)=1$。\n\n4.  $N = 64$, $\\theta = 1$ (后向欧拉), $\\Delta t = 100\\,h^2$。\n    此处 $r = 100$。由于 $\\theta = 1$，该格式是无条件稳定的。该格式是**稳定**的。放大因子为 $\\mu_k = (1 + 4r \\sin^2(\\dots))^{-1}$，其值均小于或等于 $1$。\n\n5.  $N = 64$, $\\theta = 0.25$, $\\Delta t = 1\\,h^2$。\n    此处 $r=1$。对于 $\\theta = 0.25$，稳定性条件是 $r \\le \\frac{1}{2(1 - 2 \\cdot 0.25)} = 1$。由于 $r=1$，该条件在其边界上得到满足。该格式是**稳定**的。最大放大因子为 $|\\mu_{32}| = |\\frac{1-4(1-0.25)}{1+4(0.25)}| = |\\frac{1-3}{1+1}| = |-1| = 1$。\n\n6.  $N = 64$, $\\theta = 0.49$, $\\Delta t = 30\\,h^2$。\n    此处 $r=30$。对于 $\\theta = 0.49$，稳定性条件是 $r \\le \\frac{1}{2(1 - 2 \\cdot 0.49)} = \\frac{1}{0.04} = 25$。由于 $30 > 25$，该条件不被满足。该格式是**不稳定**的。确实， $|\\mu_{32}| = |\\frac{1-4(30)(0.51)}{1+4(30)(0.49)}| = |\\frac{1-61.2}{1+58.8}| = |\\frac{-60.2}{59.8}| \\approx 1.0067 > 1$。\n\n因此，最终结果是 `[True, False, True, True, True, False]`。所提供的程序实现了这种解析计算以得出解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the stability of the generalized theta-method for the 1D heat\n    equation by calculating the spectral radius of the update operator for\n    several parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, theta, dt_over_h_squared)\n    # L and alpha are fixed at 1 for all cases.\n    test_cases = [\n        (64, 0.0, 0.25),   # Case 1\n        (64, 0.0, 0.75),   # Case 2\n        (64, 0.5, 30.0),   # Case 3\n        (64, 1.0, 100.0),  # Case 4\n        (64, 0.25, 1.0),   # Case 5\n        (64, 0.49, 30.0),  # Case 6\n    ]\n\n    L = 1.0\n    alpha = 1.0\n    epsilon = 1e-10\n\n    results = []\n    \n    for N, theta, r in test_cases:\n        # The parameter 'r' in the code corresponds to the dimensionless\n        # number r = alpha * dt / h^2.\n        # Since the problem gives dt in terms of h^2 (e.g., dt = 0.25 * h^2),\n        # and alpha = 1, the value of r is simply the given coefficient.\n\n        # The eigenvalues of the update operator M are given by the\n        # amplification factor mu_k, which depends on the eigenvalues of the\n        # discrete Laplacian D. This avoids constructing the matrices explicitly.\n        # mu_k = (1 - 4*r*(1-theta)*sin^2(pi*k/N)) / \n        #        (1 + 4*r*theta*sin^2(pi*k/N))\n        # where k = 0, 1, ..., N-1.\n\n        # We compute the amplification factor for all Fourier modes.\n        k = np.arange(N)\n        sin_sq_term = np.sin(np.pi * k / N)**2\n\n        numerator = 1.0 - 4.0 * r * (1.0 - theta) * sin_sq_term\n        denominator = 1.0 + 4.0 * r * theta * sin_sq_term\n\n        # The eigenvalues of the update matrix M.\n        mu = numerator / denominator\n\n        # The spectral radius is the maximum absolute value of the eigenvalues.\n        spectral_radius = np.max(np.abs(mu))\n\n        # Check stability against the given criterion.\n        is_stable = spectral_radius = 1.0 + epsilon\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的问题很少是一维的。本练习将挑战你将 Crank-Nicolson 方案从一维推广到二维热方程，这是实际应用中的一个关键步骤。此处的核心挑战不再是时间步进本身，而是如何有效构建和求解由二维空间离散化产生的更大、更复杂的线性方程组，你将接触到块三对角矩阵和克罗内克积等重要概念 。",
            "id": "2383969",
            "problem": "考虑单位正方形域上的二维热方程（一种抛物型偏微分方程 (PDE)），其边界条件为齐次 Dirichlet 边界条件，初始条件为光滑可分离函数。设 $u(x,y,t)$ 满足\n$$\nu_t \\;=\\; D\\,(u_{xx} + u_{yy}), \\quad (x,y)\\in(0,1)\\times(0,1), \\; t\\in(0,T],\n$$\n边界条件为\n$$\nu(x,y,t) \\;=\\; 0, \\quad (x,y)\\in\\partial([0,1]\\times[0,1]), \\; t\\in[0,T],\n$$\n初始条件为\n$$\nu(x,y,0) \\;=\\; \\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n所有量均为无量纲量。\n\n使用均匀张量积网格对空间域进行离散化，其中 $x$ 方向有 $N_x$ 个内部点，$y$ 方向有 $N_y$ 个内部点，且 $h_x = 1/(N_x+1)$，$h_y = 1/(N_y+1)$。设时间区间被划分为 $N_t$ 个大小为 $\\Delta t = T/N_t$ 的均匀步长。使用 Crank–Nicolson (CN) 格式，半隐式时间离散在每个时间步长上都会为内部未知数导出一个线性系统，该系统的系数矩阵具有由张量积离散化引起的自然分块结构。\n\n实现一个程序，该程序：\n- 在每个时间步，构造并求解在内部网格上对上述 PDE 进行 Crank–Nicolson 离散化所产生的线性系统，同时施加齐次 Dirichlet 边界条件。\n- 从在内部网格上求值的给定初始条件开始，将数值解从 $t=0$ 推进到 $t=T$。\n- 将最终数值解与精确解 \n$$\nu_{\\mathrm{exact}}(x,y,T) \\;=\\; \\sin(\\pi x)\\,\\sin(\\pi y)\\,\\exp\\!\\left(-2\\pi^2 D\\,T\\right)\n$$\n在内部网格点上的值进行比较，并返回定义为如下的均方根 (RMS) 误差\n$$\n\\mathrm{RMS} \\;=\\; \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y}\\left(u_{i,j}^{\\mathrm{num}}(T) - u_{\\mathrm{exact}}(x_i,y_j,T)\\right)^2},\n$$\n其中 $x_i = i\\,h_x$ 且 $y_j = j\\,h_y$，对于 $i\\in\\{1,\\dots,N_x\\}$ 和 $j\\in\\{1,\\dots,N_y\\}$。\n\n使用以下测试套件，其中每个测试用例是一个元组 $(D,N_x,N_y,N_t,T)$：\n- 测试 1：$(0.1,\\,10,\\,14,\\,20,\\,0.05)$。\n- 测试 2：$(0.1,\\,1,\\,1,\\,2,\\,0.2)$。\n- 测试 3：$(1.0,\\,25,\\,15,\\,10,\\,0.01)$。\n- 测试 4：$(0.05,\\,12,\\,9,\\,100,\\,0.5)$。\n\n对每个测试，按规定计算 RMS 误差。您的程序必须生成单行输出，其中包含按上述测试顺序排列的结果，结果为用方括号括起来的逗号分隔列表，每个 RMS 误差都应四舍五入为八位小数的十进制数。例如，要求的格式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是测试 $k$ 的 RMS 误差，四舍五入到八位小数。不应打印任何其他文本。",
            "solution": "所给出的问题是二维热方程的一个标准的、适定的初边值问题。它要求实现 Crank–Nicolson 数值格式，这是计算物理学中用于求解抛物型偏微分方程的典型方法。该问题具有科学依据，在数学上是一致的，并且提供了获得唯一解所需的所有数据和条件。所提供的精确解经验证是正确的。因此，该问题被认为是有效的，并将构建一个解。\n\n控制偏微分方程 (PDE) 是二维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = D \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right), \\quad (x,y) \\in (0,1) \\times (0,1), \\; t \\in (0,T]\n$$\n其中 $D$ 为扩散系数。域是一个单位正方形，具有齐次 Dirichlet 边界条件，即在边界上 $u(x,y,t) = 0$。在 $t=0$ 时的初始条件是 $u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$。\n\n我们用均匀网格间距 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$ 对空间域进行离散化。网格点为 $(x_i, y_j)$，其中 $x_i = i h_x$（对于 $i \\in \\{1, \\dots, N_x\\}$）和 $y_j = j h_y$（对于 $j \\in \\{1, \\dots, N_y\\}$）。设 $u_{i,j}^n$ 表示在时间 $t_n = n \\Delta t$ 时 $u(x_i, y_j, t_n)$ 的数值近似，其中 $\\Delta t = T/N_t$。\n\nCrank–Nicolson 格式用在 $t_{n+1/2}$ 处的中心差分来近似时间导数，并在时间步长 $n$ 和 $n+1$ 上对空间拉普拉斯算子取平均：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\frac{D}{2} \\left[ (\\nabla_h^2 u^{n+1})_{i,j} + (\\nabla_h^2 u^n)_{i,j} \\right]\n$$\n其中 $\\nabla_h^2$ 是拉普拉斯算子的标准五点有限差分近似：\n$$\n(\\nabla_h^2 u)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\n重新整理方程，将时间步长 $n+1$（未知数）和 $n$（已知数）的项分开：\n$$\n\\left( 1 - \\frac{D \\Delta t}{2} \\nabla_h^2 \\right) u_{i,j}^{n+1} = \\left( 1 + \\frac{D \\Delta t}{2} \\nabla_h^2 \\right) u_{i,j}^n\n$$\n为了将其表示为矩阵系统，我们将二维未知数网格 $u_{i,j}$ 展平成一个大小为 $N_x N_y$ 的一维向量 $\\mathbf{u}$。我们采用行主序，其中索引 $k$ 对应网格点 $(i,j)$，即 $k = j N_x + i$（为了实现，采用从 0 开始的索引，$i \\in \\{0, \\dots, N_x-1\\}, j \\in \\{0, \\dots, N_y-1\\}$）。方程变为一个线性系统：\n$$\n\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{B} \\mathbf{u}^{n}\n$$\n其中矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$ 分别表示左手边和右手边的线性算子。这些矩阵是稀疏的，并且在所有时间步长上都是常数。\n\n离散拉普拉斯算子 $\\mathbf{L}$ 的矩阵表示可以使用克罗内克积 (Kronecker products) 高效地构造。设 $\\mathbf{I}_k$ 是大小为 $k \\times k$ 的单位矩阵，$\\mathbf{T}_k$ 是表示一维二阶导数的 $k \\times k$ 三对角矩阵：\n$$\n\\mathbf{T}_k = \\begin{pmatrix} -2  1   \\\\ 1  -2  1  \\\\  \\ddots  \\ddots  \\ddots \\\\   1  -2 \\end{pmatrix}\n$$\n对于行主序展平的网格向量，离散拉普拉斯矩阵 $\\mathbf{L}$ 是：\n$$\n\\mathbf{L} = \\frac{1}{h_x^2} \\left(\\mathbf{I}_{N_y} \\otimes \\mathbf{T}_{N_x}\\right) + \\frac{1}{h_y^2} \\left(\\mathbf{T}_{N_y} \\otimes \\mathbf{I}_{N_x}\\right)\n$$\n系统矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$ 则为：\n$$\n\\mathbf{A} = \\mathbf{I}_{N_x N_y} - \\frac{D \\Delta t}{2} \\mathbf{L}\n$$\n$$\n\\mathbf{B} = \\mathbf{I}_{N_x N_y} + \\frac{D \\Delta t}{2} \\mathbf{L}\n$$\n其中 $\\mathbf{I}_{N_x N_y}$ 是大小为 $N_x N_y \\times N_x N_y$ 的单位矩阵。\n\n算法流程如下：\n1.  对于给定的测试用例 $(D, N_x, N_y, N_t, T)$，确定离散化参数 $h_x, h_y, \\Delta t$。\n2.  构建内部空间网格 $(x_i, y_j)$，其中 $i \\in \\{1, \\dots, N_x\\}, j \\in \\{1, \\dots, N_y\\}$。\n3.  在此网格上计算初始条件 $u(x,y,0)$ 以获得初始状态向量 $\\mathbf{u}^0$。\n4.  使用克罗内克积公式构造稀疏矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$。\n5.  对 $n$ 从 $0$ 到 $N_t-1$ 进行迭代：\n    a. 计算右手边向量 $\\mathbf{b}^n = \\mathbf{B} \\mathbf{u}^n$。\n    b. 求解稀疏线性系统 $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}^n$ 以得到 $\\mathbf{u}^{n+1}$。\n6.  在 $t=T$ 时的最终数值解是向量 $\\mathbf{u}^{N_t}$。将此向量重塑回二维数组 $u_{i,j}^{\\mathrm{num}}(T)$。\n7.  在同一网格上计算精确解 $u_{\\mathrm{exact}}(x,y,T) = \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2 D T)$。\n8.  计算均方根 (RMS) 误差：\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y}\\left(u_{i,j}^{\\mathrm{num}}(T) - u_{\\mathrm{exact}}(x_i,y_j,T)\\right)^2}\n$$\n对每个测试用例重复此过程，以获得所需的 RMS 误差集合。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D heat equation using the Crank-Nicolson method for a suite of test cases\n    and computes the RMS error against the exact solution.\n    \"\"\"\n    test_cases = [\n        (0.1, 10, 14, 20, 0.05),\n        (0.1, 1, 1, 2, 0.2),\n        (1.0, 25, 15, 10, 0.01),\n        (0.05, 12, 9, 100, 0.5),\n    ]\n\n    results = []\n\n    for D, Nx, Ny, Nt, T in test_cases:\n        # Discretization parameters\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        dt = T / Nt\n\n        # Spatial grid (interior points only)\n        x = np.linspace(hx, 1.0 - hx, Nx)\n        y = np.linspace(hy, 1.0 - hy, Ny)\n        X, Y = np.meshgrid(x, y, indexing='ij') # Use 'ij' for matrix-style indexing\n\n        # Initial condition\n        u0 = np.sin(np.pi * X) * np.sin(np.pi * Y)\n        # For row-major flattening, use 'C' order (default)\n        u_vec = u0.flatten(order='C')  \n\n        # Construct sparse matrices for the Crank-Nicolson scheme\n        N = Nx * Ny\n        \n        # 1D Laplacian matrix components\n        Tx = diags([1, -2, 1], [-1, 0, 1], shape=(Nx, Nx), format='csc')\n        Ty = diags([1, -2, 1], [-1, 0, 1], shape=(Ny, Ny), format='csc')\n\n        # Identity matrices for Kronecker products\n        Ix = identity(Nx, format='csc')\n        Iy = identity(Ny, format='csc')\n        \n        # 2D Laplacian matrix using Kronecker products for row-major ordering\n        # For ij indexing and C-order flattening: L = kron(Tx, Iy)/hx^2 + kron(Ix, Ty)/hy^2\n        # However, Python's meshgrid 'xy' default matches Fortran-style, \n        # while 'ij' matches matrix-style. Let's be explicit and consistent.\n        # If u is flattened (Ny, Nx) -> (N), u_k with k = i*Nx + j, then L = kron(Iy,Tx) + kron(Ty,Ix)\n        # Let's re-verify the meshgrid and flattening.\n        # meshgrid(x,y,indexing='xy') -> X(Ny,Nx), Y(Ny,Nx). X varies along columns, Y along rows.\n        # u0.flatten() (row-major) takes rows of u0 one by one. A row corresponds to a fixed y.\n        # A_row_major = kron(Iy, Tx/hx**2) + kron(Ty/hy**2, Ix)\n        L = kron(Iy, Tx) / (hx**2) + kron(Ty, Ix) / (hy**2)\n\n        # Crank-Nicolson system matrices\n        A = identity(N, format='csc') - (D * dt / 2.0) * L\n        B = identity(N, format='csc') + (D * dt / 2.0) * L\n        \n        # Time-stepping loop\n        u_current = u_vec.copy()\n        for _ in range(Nt):\n            rhs = B @ u_current\n            u_current = spsolve(A, rhs)\n\n        # Final numerical solution as a 2D array\n        u_numerical = u_current.reshape((Ny, Nx))\n\n        # Recreate grid for exact solution, ensuring same shape\n        X_exact, Y_exact = np.meshgrid(x, y, indexing='xy')\n        \n        # Exact solution at t=T\n        u_exact = np.sin(np.pi * X_exact) * np.sin(np.pi * Y_exact) * np.exp(-2 * np.pi**2 * D * T)\n\n        # Calculate RMS error\n        rms_error = np.sqrt(np.mean((u_numerical - u_exact)**2))\n        \n        # Store result formatted to 8 decimal places\n        results.append(f\"{rms_error:.8f}\")\n\n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Crank-Nicolson 方案本质上是为线性问题设计的，但我们如何处理非线性偏微分方程呢？本练习将指导你实现一种强大的预测-校正技术，用于解决扩散系数依赖于解本身的非线性问题。通过在每个时间步使用一个“预测”的中间解来线性化问题，我们得以在处理非线性复杂性的同时，保留隐式格式优越的稳定性 。",
            "id": "2383916",
            "problem": "设计并实现一个完整的、可运行的程序，该程序使用 Crank-Nicolson (CN) 格式的预测-校正实现来推进标量场的一维非线性扩散。从守恒律和 Fick 定律作为基本出发点：空间区间 $x \\in [0,1]$ 上的守恒标量 $u(x,t)$ 满足偏微分方程 (PDE)\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(u)\\,\\frac{\\partial u}{\\partial x} \\right) + f(x,t),\n$$\n其中非线性扩散系数为 $D(u) = 1 + \\alpha\\,u^2$，$\\alpha \\ge 0$ 是一个给定的常数。使用人工解方法来定义一个光滑的精确解和源项：\n- 精确解：$u_{\\mathrm{exact}}(x,t) = e^{-t}\\,\\sin(\\pi x)$。\n- Dirichlet 边界条件：对于所有 $t$，有 $u(0,t) = u_{\\mathrm{exact}}(0,t)$ 和 $u(1,t) = u_{\\mathrm{exact}}(1,t)$。\n- 初始条件：对于所有 $x \\in [0,1]$，有 $u(x,0) = u_{\\mathrm{exact}}(x,0)$。\n- 选择源项以使 $u_{\\mathrm{exact}}$ 满足 PDE：\n$$\nf(x,t) = \\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} - \\frac{\\partial}{\\partial x}\\left( D\\!\\left(u_{\\mathrm{exact}}\\right)\\,\\frac{\\partial u_{\\mathrm{exact}}}{\\partial x} \\right),\n$$\n其中 $D(u) = 1+\\alpha u^2$。\n\n在空间上，使用一个包含 $N_x$ 个子区间的均匀网格，节点为 $x_i = i\\,\\Delta x$，其中 $i=0,\\dots,N_x$，$\\Delta x = 1/N_x$。以守恒通量形式离散化扩散算子，并使用面心系数。对于内部索引 $i=1,\\dots,N_x-1$，通过算术平均定义面扩散系数，\n$$\nD_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(D(u_i) + D(u_{i+1})\\right), \\quad D_{i-\\frac{1}{2}} = \\frac{1}{2}\\left(D(u_{i-1}) + D(u_i)\\right),\n$$\n作用于网格函数 $v$ 的离散算子定义为\n$$\n\\left[\\mathcal{A}(u)\\,v\\right]_i = \\frac{1}{\\Delta x^2}\\left( D_{i+\\frac{1}{2}}\\,(v_{i+1}-v_i) - D_{i-\\frac{1}{2}}\\,(v_i - v_{i-1}) \\right).\n$$\n\n在时间上，使用预测-校正 CN 步长从 $t^n$ 推进到 $t^{n+1}=t^n+\\Delta t$，通过中点线性化处理非线性项：\n- 预测步（使用在 $t^n$ 处冻结的系数的显式前向欧拉法）：\n$$\nu^{n+1,p}_i = u^n_i + \\Delta t\\,\\left( \\left[\\mathcal{A}(u^n)\\,u^n\\right]_i + f(x_i,t^n)\\right), \\quad i=1,\\dots,N_x-1,\n$$\n在 $t^n$ 和 $t^{n+1}$ 处强制施加 Dirichlet 边界条件：$u^n_0 = u_{\\mathrm{exact}}(0,t^n)$，$u^n_{N_x} = u_{\\mathrm{exact}}(1,t^n)$，$u^{n+1,p}_0 = u_{\\mathrm{exact}}(0,t^{n+1})$，$u^{n+1,p}_{N_x} = u_{\\mathrm{exact}}(1,t^{n+1})$。\n- 校正步（使用在时间中点状态 $u^{\\mathrm{avg}} = \\tfrac{1}{2}(u^n + u^{n+1,p})$ 处评估的系数进行单次 CN 求解）：\n$$\n\\left( I - \\frac{\\Delta t}{2}\\,\\mathcal{A}(u^{\\mathrm{avg}}) \\right)\\,u^{n+1} = \\left( I + \\frac{\\Delta t}{2}\\,\\mathcal{A}(u^{\\mathrm{avg}}) \\right)\\,u^{n} + \\frac{\\Delta t}{2}\\left( f(\\cdot,t^n) + f(\\cdot,t^{n+1}) \\right),\n$$\n应用于内部未知数 $i=1,\\dots,N_x-1$，并设置 Dirichlet 边界为 $u^{n+1}_0 = u_{\\mathrm{exact}}(0,t^{n+1})$ 和 $u^{n+1}_{N_x} = u_{\\mathrm{exact}}(1,t^{n+1})$。使用 $\\mathcal{A}(u^{\\mathrm{avg}})$ 的面系数将内部线性系统组装成三对角形式，并在每个时间步精确求解。\n\n通过一个与网格相关的规则来选择时间步长，该规则使显式预测步在所有测试中保持稳定：\n$$\n\\Delta t = c\\,\\frac{\\Delta x^2}{1+\\alpha}, \\quad c=0.2,\n$$\n并调整最后一步，以精确达到最终时间 $t^{n_{\\mathrm{final}}}=T$。对于下面的每个测试用例，计算最终时间的网格 $L^2$ 误差，\n$$\n\\| e \\|_{2,h} = \\left( \\sum_{i=0}^{N_x} \\left(u_i(T)-u_{\\mathrm{exact}}(x_i,T)\\right)^2\\,\\Delta x \\right)^{1/2},\n$$\n并将其报告为浮点数。\n\n在单次程序执行中运行的测试套件：\n- 案例 1：$N_x=40$, $T=0.1$, $\\alpha=1.0$。\n- 案例 2：$N_x=10$, $T=0.1$, $\\alpha=1.0$。\n- 案例 3：$N_x=80$, $T=0.1$, $\\alpha=0.0$。\n- 案例 4：$N_x=20$, $T=0.05$, $\\alpha=3.0$。\n- 案例 5：$N_x=8$, $T=0.0$, $\\alpha=2.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是相应测试用例的最终时间网格 $L^2$ 误差，表示为任意单位的浮点数。",
            "solution": "问题陈述已经过验证，并被认为是有效的。它具有科学依据、是适定的、客观且完整的。它描述了一个针对非线性偏微分方程的标准数值验证练习，使用了人工解方法和预测-校正 Crank-Nicolson 格式，这是计算物理学中的一种常用技术。所有参数和规格都定义明确，可以得到唯一且有意义的解。因此，我们可以继续进行推导和实现。\n\n该问题涉及一维非线性扩散方程的数值解：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(u)\\,\\frac{\\partial u}{\\partial x} \\right) + f(x,t)\n$$\n在域 $x \\in [0,1]$ 上。扩散系数是非线性的，由 $D(u) = 1 + \\alpha u^2$ 给出，其中常数 $\\alpha \\ge 0$。\n\n采用人工解方法。假设一个精确解，并通过一个源项 $f(x,t)$ 来修正控制方程，以确保这个精确解是修正后偏微分方程的有效解。这允许通过将数值解与已知的精确解进行比较来对数值格式进行严格的验证。\n\n规定的精确解是 $u_{\\mathrm{exact}}(x,t) = e^{-t}\\,\\sin(\\pi x)$。为了找到相应的源项 $f(x,t)$，我们计算必要的导数并将它们代入定义关系 $f(x,t) = \\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} - \\frac{\\partial}{\\partial x}\\left( D(u_{\\mathrm{exact}})\\,\\frac{\\partial u_{\\mathrm{exact}}}{\\partial x} \\right)$。\n\n首先，我们计算 $u_{\\mathrm{exact}}$ 的偏导数：\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} = -e^{-t}\\,\\sin(\\pi x)\n$$\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial x} = \\pi e^{-t}\\,\\cos(\\pi x)\n$$\n在精确解处评估的扩散系数为 $D(u_{\\mathrm{exact}}) = 1 + \\alpha (e^{-t}\\sin(\\pi x))^2 = 1 + \\alpha e^{-2t}\\sin^2(\\pi x)$。通量项为 $J = D(u_{\\mathrm{exact}}) \\frac{\\partial u_{\\mathrm{exact}}}{\\partial x}$：\n$$\nJ = \\left(1 + \\alpha e^{-2t}\\sin^2(\\pi x)\\right) \\left(\\pi e^{-t}\\cos(\\pi x)\\right) = \\pi e^{-t}\\cos(\\pi x) + \\alpha\\pi e^{-3t}\\sin^2(\\pi x)\\cos(\\pi x)\n$$\n接下来，我们计算通量的散度 $\\frac{\\partial J}{\\partial x}$：\n$$\n\\frac{\\partial J}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\pi e^{-t}\\cos(\\pi x) \\right) + \\frac{\\partial}{\\partial x} \\left( \\alpha\\pi e^{-3t}\\sin^2(\\pi x)\\cos(\\pi x) \\right)\n$$\n$$\n\\frac{\\partial J}{\\partial x} = -\\pi^2 e^{-t}\\sin(\\pi x) + \\alpha\\pi e^{-3t} \\left( 2\\pi\\sin(\\pi x)\\cos^2(\\pi x) - \\pi\\sin^3(\\pi x) \\right)\n$$\n$$\n\\frac{\\partial J}{\\partial x} = -\\pi^2 e^{-t}\\sin(\\pi x) + \\alpha\\pi^2 e^{-3t} \\sin(\\pi x) \\left( 2\\cos^2(\\pi x) - \\sin^2(\\pi x) \\right)\n$$\n使用恒等式 $\\cos^2(\\theta) = 1 - \\sin^2(\\theta)$，这可以简化为：\n$$\n\\frac{\\partial J}{\\partial x} = -\\pi^2 e^{-t}\\sin(\\pi x) + \\alpha\\pi^2 e^{-3t} \\sin(\\pi x) \\left( 2 - 3\\sin^2(\\pi x) \\right)\n$$\n最后，将这些代入 $f(x,t)$ 的表达式：\n$$\nf(x,t) = -e^{-t}\\sin(\\pi x) - \\left[ -\\pi^2 e^{-t}\\sin(\\pi x) + \\alpha\\pi^2 e^{-3t} \\sin(\\pi x) (2 - 3\\sin^2(\\pi x)) \\right]\n$$\n$$\nf(x,t) = (\\pi^2 - 1)e^{-t}\\sin(\\pi x) - \\alpha\\pi^2 e^{-3t}\\sin(\\pi x)(2 - 3\\sin^2(\\pi x))\n$$\n这就是必须在数值格式中实现的源项。\n\n空间域使用均匀网格 $x_i = i\\Delta x$ 进行离散化，其中 $i=0,\\dots,N_x$，$\\Delta x = 1/N_x$。空间算子以守恒有限差分形式离散化。对于网格函数 $v$，算子 $\\mathcal{A}(u)$ 由下式给出：\n$$\n\\left[\\mathcal{A}(u)\\,v\\right]_i = \\frac{1}{\\Delta x^2}\\left( D_{i+\\frac{1}{2}}(u)\\,(v_{i+1}-v_i) - D_{i-\\frac{1}{2}}(u)\\,(v_i - v_{i-1}) \\right)\n$$\n其中，单元面上的扩散系数通过算术平均计算：\n$$\nD_{i\\pm\\frac{1}{2}}(u) = \\frac{1}{2}\\left(D(u_{i\\pm1}) + D(u_i)\\right)\n$$\n\n从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的时间积分使用预测-校正方法进行。\n预测步是一个显式前向欧拉步，用于获得初步估计 $u^{n+1,p}$：\n$$\nu^{n+1,p}_i = u^n_i + \\Delta t\\,\\left( \\left[\\mathcal{A}(u^n)\\,u^n\\right]_i + f(x_i,t^n)\\right)\n$$\n对于内部点 $i=1,\\dots,N_x-1$。边界条件为 $u^{n+1,p}_0 = u_{\\mathrm{exact}}(0,t^{n+1})=0$ 和 $u^{n+1,p}_{N_x} = u_{\\mathrm{exact}}(1,t^{n+1})=0$。\n\n校正步使用此预测来形成一个中点线性化的 Crank-Nicolson 更新。我们首先定义一个平均状态 $u^{\\mathrm{avg}} = \\frac{1}{2}(u^n + u^{n+1,p})$，在该状态下评估非线性系数 $D$。然后 Crank-Nicolson 格式为：\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = \\frac{1}{2} \\left(\\mathcal{A}(u^{\\mathrm{avg}})u^{n+1} + \\mathcal{A}(u^{\\mathrm{avg}})u^n \\right) + \\frac{1}{2}\\left( f(\\cdot,t^n) + f(\\cdot,t^{n+1}) \\right)\n$$\n重新整理此方程得到一个关于未知数 $u^{n+1}$ 的线性系统：\n$$\n\\left( I - \\frac{\\Delta t}{2}\\,\\mathcal{A}(u^{\\mathrm{avg}}) \\right)\\,u^{n+1} = \\left( I + \\frac{\\Delta t}{2}\\,\\mathcal{A}(u^{\\mathrm{avg}}) \\right)\\,u^{n} + \\frac{\\Delta t}{2}\\left( f(\\cdot,t^n) + f(\\cdot,t^{n+1}) \\right)\n$$\n此方程应用于内部网格点 $i=1,\\dots,N_x-1$。令 $\\mathbf{u}^{n+1}$ 为 $N_x-1$ 个内部未知数的向量。算子 $\\left( I - \\frac{\\Delta t}{2}\\mathcal{A}(u^{\\mathrm{avg}}) \\right)$ 形成一个三对角矩阵。令 $c = \\frac{\\Delta t}{2\\Delta x^2}$ 且 $D^{\\mathrm{avg}}_{j+1/2} = D_{j+1/2}(u^{\\mathrm{avg}})$。对应于网格点 $x_i$ 的第 $i$ 行的矩阵元素为：\n- 下对角线 ($j=i-1$)：$-c\\,D^{\\mathrm{avg}}_{i-1/2}$\n- 主对角线 ($j=i$)：$1 + c\\,\\left(D^{\\mathrm{avg}}_{i-1/2} + D^{\\mathrm{avg}}_{i+1/2}\\right)$\n- 上对角线 ($j=i+1$)：$-c\\,D^{\\mathrm{avg}}_{i+1/2}$\n\n由于 $D(u) \\ge 1$，所有面系数都为正，确保矩阵是（严格）对角占优和正定的，这保证了唯一解的存在。这个三对角系统使用直接求解器求解。边界值 $u_0^{n+1}=0$ 和 $u_{N_x}^{n+1}=0$ 通过调整第一个和最后一个方程的右端向量来处理，但由于它们为零，所以没有贡献。\n\n时间步长 $\\Delta t$ 根据显式预测步的稳定性判据确定：$\\Delta t = c_{\\mathrm{CFL}}\\frac{\\Delta x^2}{1+\\alpha}$，其中 $c_{\\mathrm{CFL}}=0.2$。为确保模拟在时间 $T$ 精确结束，步数计算为 $N_t = \\lceil T/\\Delta t_{\\mathrm{nominal}} \\rceil$，实际步长调整为 $\\Delta t = T/N_t$。\n\n在最后一个时间步之后，将数值解 $u(T)$ 与精确解 $u_{\\mathrm{exact}}(x,T)$进行比较，计算离散 $L^2$ 误差：\n$$\n\\| e \\|_{2,h} = \\left( \\sum_{i=0}^{N_x} \\left(u_i(T)-u_{\\mathrm{exact}}(x_i,T)\\right)^2\\,\\Delta x \\right)^{1/2}\n$$\n实现将为提供的每个测试用例计算此误差。对于 $T=0$ 的特殊情况，不进行时间步进，误差在初始条件 $u(x,0)$ 和精确解 $u_{\\mathrm{exact}}(x,0)$ 之间计算，根据定义它们是相同的，因此误差为 0。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# Adherence to specified execution environment:\n# language: Python 3.12\n# libraries: numpy==1.23.5, scipy==1.11.4\n\ndef run_simulation(Nx: int, T: float, alpha: float) - float:\n    \"\"\"\n    Solves the 1D nonlinear diffusion equation using a predictor-corrector\n    Crank-Nicolson scheme and returns the L2 error at the final time.\n    \"\"\"\n    # Spatial grid setup\n    dx = 1.0 / Nx\n    x = np.linspace(0, 1, Nx + 1)\n\n    # Time stepping setup\n    c_cfl = 0.2\n    # Ensure denominator is not zero, though alpha = 0 makes it = 1\n    dt_nominal = c_cfl * dx**2 / (1.0 + alpha)\n\n    if T == 0.0:\n        n_steps = 0\n        dt = 0.0\n    else:\n        # Prevent division by zero if T  0 and dt_nominal is somehow zero\n        if dt_nominal  0:\n            n_steps = int(np.ceil(T / dt_nominal))\n        else: # Should not happen with given parameters\n            n_steps = 1\n        dt = T / n_steps\n\n    # Manufactured solution and source term functions (vectorized)\n    def u_exact(xt, t):\n        return np.exp(-t) * np.sin(np.pi * xt)\n\n    def source_term(xt, t):\n        term1 = (np.pi**2 - 1.0) * np.exp(-t) * np.sin(np.pi * xt)\n        sin_pi_x = np.sin(np.pi * xt)\n        term2 = alpha * np.pi**2 * np.exp(-3.0 * t) * sin_pi_x * (2.0 - 3.0 * sin_pi_x**2)\n        return term1 - term2\n\n    # Diffusion coefficient function\n    def D_func(u_vals):\n        return 1.0 + alpha * u_vals**2\n\n    # Initial condition from exact solution\n    u_n = u_exact(x, 0.0)\n    \n    # Time-stepping loop\n    for n in range(n_steps):\n        t_n = n * dt\n        t_np1 = (n + 1) * dt\n\n        # --- Predictor Step (Forward Euler) ---\n        D_un = D_func(u_n)\n        D_face_un = 0.5 * (D_un[:-1] + D_un[1:])\n        \n        flux_un = D_face_un * (u_n[1:] - u_n[:-1]) / dx\n        A_un_un_interior = (flux_un[1:] - flux_un[:-1]) / dx\n\n        f_n = source_term(x, t_n)\n        f_n_interior = f_n[1:-1]\n\n        u_p_interior = u_n[1:-1] + dt * (A_un_un_interior + f_n_interior)\n        \n        u_p = np.zeros_like(u_n)\n        u_p[1:-1] = u_p_interior\n        # BCs are u_p[0] = u_exact(0, t_np1) = 0 and u_p[Nx] = u_exact(1, t_np1) = 0\n        # which are already set by np.zeros_like\n\n        # --- Corrector Step (Crank-Nicolson) ---\n        u_avg = 0.5 * (u_n + u_p)\n        D_uavg = D_func(u_avg)\n        D_face_uavg = 0.5 * (D_uavg[:-1] + D_uavg[1:])\n\n        # Assemble RHS vector for interior points\n        flux_uavg_un = D_face_uavg * (u_n[1:] - u_n[:-1]) / dx\n        A_uavg_un_interior = (flux_uavg_un[1:] - flux_uavg_un[:-1]) / dx\n        \n        f_np1 = source_term(x, t_np1)\n        rhs_interior = u_n[1:-1] + 0.5 * dt * (A_uavg_un_interior + f_n[1:-1] + f_np1[1:-1])\n\n        # Assemble LHS tridiagonal matrix for interior points\n        num_interior = Nx - 1\n        c_mat = 0.5 * dt / dx**2\n        \n        main_diag = 1.0 + c_mat * (D_face_uavg[:-1] + D_face_uavg[1:])\n        upper_diag = -c_mat * D_face_uavg[1:-1]\n        lower_diag = -c_mat * D_face_uavg[1:-1]\n\n        # SciPy's solve_banded format: (l, u), ab, b\n        # ab is a (l+u+1, M) array. Here l=1, u=1.\n        ab = np.zeros((3, num_interior))\n        ab[0, 1:] = upper_diag\n        ab[1, :] = main_diag\n        ab[2, :-1] = lower_diag\n        \n        u_np1_interior = solve_banded((1, 1), ab, rhs_interior)\n\n        u_np1 = np.zeros_like(u_n)\n        u_np1[1:-1] = u_np1_interior\n        # BCs are u_np1[0]=0, u_np1[Nx]=0, already set.\n\n        # Update for next step\n        u_n = u_np1\n\n    # --- Error Calculation ---\n    u_final_exact = u_exact(x, T)\n    error_sq_sum = np.sum((u_n - u_final_exact)**2)\n    l2_error = np.sqrt(error_sq_sum * dx)\n    \n    return l2_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (Nx, T, alpha)\n        (40, 0.1, 1.0),\n        (10, 0.1, 1.0),\n        (80, 0.1, 0.0),\n        (20, 0.05, 3.0),\n        (8, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, T, alpha = case\n        error = run_simulation(Nx, T, alpha)\n        results.append(error)\n\n    # Format output as required: [r1,r2,r3,r4,r5]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}