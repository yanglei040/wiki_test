{
    "hands_on_practices": [
        {
            "introduction": "Householder变换的优雅之处不仅在于其几何解释，还在于其卓越的计算效率。一种天真的方法是显式地构建反射矩阵并执行矩阵乘法，但这种方法的计算成本远高于利用反射矩阵结构的方法。本练习通过比较这两种方法的浮点运算（flop）次数来量化这种差异。通过完成这个分析（），您将具体地理解为何数值算法的设计总是倾向于利用矩阵和向量的结构，这是计算科学中的一个基本原则。",
            "id": "2402001",
            "problem": "考虑一个实对称稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和在三对角化过程的第 $k$ 步构建的 Householder 反射 $H_k = I - \\tau v v^{\\mathsf T}$，其中向量 $v \\in \\mathbb{R}^{m}$ 在嵌入到 $\\mathbb{R}^{n}$ 时其前 $k$ 个分量为零，且 $m = n - k$，$1 \\le k \\le n - 2$。该相似更新仅作用于记为 $A_t$ 的 $m \\times m$ 维末尾主子矩阵，生成 $A_t' = H_k A_t H_k$。\n\n比较以下两种计算 $A_t'$ 的实现策略的主阶浮点运算（flop）次数，模型假设每次标量加法或乘法计为一次浮点运算：\n\n- 显式方法：将 $H_k$ 显式地构造为一个 $m \\times m$ 矩阵，并通过两次稠密矩阵-矩阵乘法计算 $A_t' = (H_k A_t) H_k$。\n- 基于向量的优化方法：利用 $A_t$ 的对称性和 $H_k$ 的秩-1 结构来应用相似变换，而不显式构造 $H_k$，方法是使用一次与 $A_t$ 的对称矩阵-向量乘积和一次对 $A_t$ 的对称秩-2 更新，外加一些在 $m$ 上成本为低阶的运算。\n\n设 $F_{\\mathrm{exp}}(n,k)$ 和 $F_{\\mathrm{opt}}(n,k)$ 分别表示显式方法和优化方法的主阶浮点运算次数（用 $n$ 和 $k$ 表示），并忽略所有在 $m$ 上的低阶项。定义比率 $R(n,k) = \\dfrac{F_{\\mathrm{exp}}(n,k)}{F_{\\mathrm{opt}}(n,k)}$。\n\n$R(n,k)$ 关于 $n$ 和 $k$ 的简化解析表达式是什么？请以闭式表达式的形式提供您的答案。不需要四舍五入，也不涉及单位。",
            "solution": "该问题要求比较两种不同方法将 Householder 相似变换应用于对称矩阵子块时的主阶浮点运算（flop）次数。目标是求出这些浮点运算次数的比率。\n\n首先，我将验证问题陈述。\n\n### 第1步：提取已知条件\n- 一个实对称稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n- 在第 $k$ 步的 Householder 反射 $H_k = I - \\tau v v^{\\mathsf T}$。\n- $v \\in \\mathbb{R}^{m}$，其中 $m = n - k$ 且 $1 \\le k \\le n - 2$。\n- 更新应用于维度为 $m \\times m$ 的末尾子矩阵 $A_t$，得到 $A_t' = H_k A_t H_k$。\n- 浮点运算模型：每次标量加法或乘法计为一次浮点运算。\n- 显式方法：显式构造 $H_k$ ($m \\times m$)，并通过两次稠密矩阵-矩阵乘法计算 $A_t' = (H_k A_t) H_k$。\n- 基于向量的优化方法：利用 $A_t$ 的对称性和 $H_k$ 的秩-1 结构，使用一次对称矩阵-向量乘积和一次对称秩-2 更新，忽略低阶项。\n- 记号：$F_{\\mathrm{exp}}(n,k)$ 和 $F_{\\mathrm{opt}}(n,k)$ 表示主阶浮点运算次数。\n- 目标：求比率 $R(n,k) = \\dfrac{F_{\\mathrm{exp}}(n,k)}{F_{\\mathrm{opt}}(n,k)}$。\n\n### 第2步：使用提取的已知条件进行验证\n根据所需标准评估问题陈述。\n\n- **科学依据：** 该问题是数值线性代数中的一个标准课题，特别是关于特征值计算算法的分析。所描述的方法（显式构造与基于向量应用的 Householder 反射）是公认的，并代表了计算科学中的一个基本权衡。该问题在科学上是合理的。\n- **适定性：** 该问题为两种计算策略和浮点运算的计算模型提供了明确的定义。它要求一个特定的、可推导的量（主阶浮点运算次数的比率）。可以保证存在唯一且有意义的解。\n- **客观性：** 其语言技术性强、精确，没有任何主观或含糊的术语。\n- **不完整或矛盾：** 该问题是自洽的。所有必要信息，包括矩阵性质、维度和算法描述，都已提供。没有矛盾之处。\n\n### 第3步：结论与行动\n问题是有效的。下面是严谨的求解过程。\n\n分析将集中于子矩阵维度 $m = n-k$ 的主阶浮点运算次数，因为与 $O(m^2)$ 或更高阶的项相比，$O(m)$ 或更低阶的运算被明确要求忽略。\n\n**显式方法（$F_{\\mathrm{exp}}$）的分析**\n\n此方法包含两个步骤来更新 $A_t' = H_k A_t H_k$。矩阵 $A_t \\in \\mathbb{R}^{m \\times m}$ 是对称的，Householder 反射 $H_k = I - \\tau v v^{\\mathsf T}$ 也是对称的。\n$1$. 构造 $H_k$：这涉及一个外积 $v v^{\\mathsf T}$（$m^2$ 次乘法），乘以 $-\\tau$ 进行缩放（$m^2$ 次乘法），以及加上单位矩阵（$m$ 次加法）。总成本为 $O(m^2)$。\n$2$. 矩阵乘法：问题陈述通过两次稠密矩阵-矩阵乘法来计算 $A_t'$。\n- 首先，计算中间矩阵 $C = H_k A_t$。两个稠密 $m \\times m$ 矩阵相乘的标准算法，对 $m^2$ 个元素中的每一个都需要 $m$ 次乘法和 $m-1$ 次加法，总计 $m^2(2m-1) = 2m^3 - m^2$ 次浮点运算。主阶成本为 $2m^3$。\n- 其次，计算 $A_t' = C H_k$。这是另一次稠密矩阵-矩阵乘法，主阶成本为 $2m^3$ 次浮点运算。\n\n构造 $H_k$ 的成本为 $O(m^2)$，与矩阵乘法相比是低阶项，因此被忽略。显式方法的总主阶浮点运算次数是两次矩阵乘积成本的总和。\n$$F_{\\mathrm{exp}}(n,k) \\approx 2m^3 + 2m^3 = 4m^3$$\n代入 $m = n-k$，我们得到：\n$$F_{\\mathrm{exp}}(n,k) = 4(n-k)^3$$\n\n**基于向量的优化方法（$F_{\\mathrm{opt}}$）的分析**\n\n这种方法避免构造 $H_k$，而是使用向量和矩阵-向量运算来应用变换。更新 $A_t' = H_k A_t H_k = (I - \\tau v v^{\\mathsf T}) A_t (I - \\tau v v^{\\mathsf T})$ 的执行方式利用了对称性和秩-1 结构。整个运算等效于对 $A_t$ 的一次对称秩-2 更新。如上所述，该过程包括两个主要步骤和一些低阶工作。\n\n$1$. 对称矩阵-向量乘积：计算向量 $p = A_t v$。\n- 对于每个分量 $p_i = \\sum_{j=1}^{m} (A_t)_{ij} v_j$，这需要 $m$ 次乘法和 $m-1$ 次加法。\n- 由于 $p$ 中有 $m$ 个分量，总浮点运算次数为 $m \\times (m + m-1) = 2m^2 - m$。\n- 此步骤的主阶成本为 $2m^2$。利用 $A_t$ 的对称性并不会减少此运算的主阶浮点运算次数。\n\n$2$. 对称秩-2 更新：更新的形式为 $A_t' = A_t - (v w^{\\mathsf T} + w v^{\\mathsf T})$，其中向量 $w$ 由 $v$ 和 $p$ 在 $O(m)$ 次浮点运算内构造（这是一个低阶成本，我们根据指示忽略它）。为了高效地执行此更新，我们利用结果的对称性。我们只需要计算 $A_t'$ 的下（或上）三角部分的元素，其数量为 $\\frac{m(m+1)}{2}$。\n- 对于每个满足 $i \\ge j$ 的元素 $(A_t')_{ij}$，更新为 $(A_t')_{ij} = (A_t)_{ij} - v_i w_j - w_i v_j$。\n- 这个计算需要 2 次乘法（$v_i w_j$ 和 $w_i v_j$）和 2 次减法，每个元素总共 4 次浮点运算。\n- 此更新的总浮点运算次数为 $4 \\times \\frac{m(m+1)}{2} = 2m^2 + 2m$。\n- 此步骤的主阶成本为 $2m^2$。\n\n优化方法的总主阶浮点运算次数是这两个主要步骤成本的总和。\n$$F_{\\mathrm{opt}}(n,k) \\approx 2m^2 + 2m^2 = 4m^2$$\n代入 $m = n-k$：\n$$F_{\\mathrm{opt}}(n,k) = 4(n-k)^2$$\n\n**比率 $R(n,k)$ 的计算**\n\n主阶浮点运算次数的比率为：\n$$R(n,k) = \\frac{F_{\\mathrm{exp}}(n,k)}{F_{\\mathrm{opt}}(n,k)} = \\frac{4(n-k)^3}{4(n-k)^2}$$\n化简该表达式得到：\n$$R(n,k) = n-k$$\n这个结果表明了利用结构的方法具有显著的计算优势，该优势随着被处理子矩阵的大小线性增长。",
            "answer": "$$\\boxed{n-k}$$"
        },
        {
            "introduction": "除了计算速度，数值算法的可靠性还取决于其稳定性——即其抵抗浮点运算中灾难性误差的能力。在构建Householder向量时，一个看似微不足道的正负号选择，却对数值精度有着深远的影响。本练习旨在探讨当选择“错误”的符号时可能发生的“灾难性相消”（subtractive cancellation）问题。这个问题（）提供了一个清晰、可量化的演示，说明了为什么标准实现中包含一个特定的符号约定，突显了数学理论与稳健的实际代码之间的关键联系。",
            "id": "2402000",
            "problem": "考虑实对称矩阵\n$$\nA(\\delta)=\n\\begin{pmatrix}\n2  1  \\delta  0\\\\\n1  3  0  0\\\\\n\\delta  0  4  0\\\\\n0  0  0  5\n\\end{pmatrix},\n$$\n其中 $\\delta>0$ 是一个实数参数，且 $\\delta \\ll 1$。在 Householder 三对角化的第一步中，构造一个 Householder 反射矩阵 $H=I-2uu^{\\mathsf{T}}$ 作用于尾部的 $(n-1)$ 维子空间，以将第一列对角线以下的元素消去。令 $x\\in\\mathbb{R}^{3}$ 表示由 $A(\\delta)$ 第一列中 $(1,1)$ 位置下方的元素构成的子向量，即 $x=A(\\delta)_{2:4,1}$。Householder 向量的一种标准构造方法是使用 $v=x\\pm \\alpha e_1$，其中 $\\alpha=\\|x\\|_2$ 且 $e_1=(1,0,0)^{\\mathsf{T}}$，然后进行归一化 $u=v/\\|v\\|_2$。在这里，两种符号的选择对应于两个代数上等价但在数值上不同的反射矩阵。\n\n定义 $v_{\\text{right}}=x+\\alpha e_1$ 和 $v_{\\text{wrong}}=x-\\alpha e_1$。计算下式的精确、闭式解析表达式\n$$\n\\kappa(\\delta)=\\frac{\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right|}{\\left| \\left(v_{\\text{right}}\\right)_1 \\right|},\n$$\n其中 $\\left(v\\right)_1$ 表示向量 $v$ 的第一个分量。你的最终答案必须是只含 $\\delta$ 的单个简化解析表达式，不得进行数值近似。",
            "solution": "所述问题具有科学依据，提法得当，客观且自洽。这是数值线性代数中关于构造 Householder 反射矩阵的数值稳定性的一个标准练习。我们来着手解题。\n\n给定矩阵为\n$$\nA(\\delta)=\n\\begin{pmatrix}\n2  1  \\delta  0\\\\\n1  3  0  0\\\\\n\\delta  0  4  0\\\\\n0  0  0  5\n\\end{pmatrix}\n$$\n其中 $\\delta > 0$ 是一个实数参数。\n\nHouseholder 三对角化的第一步针对矩阵的第一列。构造反射矩阵所需的向量 $x$ 是 $A(\\delta)$ 第一列中位于主对角元 $A(\\delta)_{1,1}$ 下方的子向量。$A(\\delta)$ 的第一列是 $(2, 1, \\delta, 0)^{\\mathsf{T}}$。因此，子向量 $x \\in \\mathbb{R}^3$ 由下式给出\n$$\nx = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix}.\n$$\nHouseholder 向量 $v$ 的构造基于 $v = x \\pm \\alpha e_1$，其中 $\\alpha = \\|x\\|_2$ 且 $e_1$ 是 $\\mathbb{R}^3$ 中的第一个标准基向量，$e_1 = (1, 0, 0)^{\\mathsf{T}}$。首先，我们计算向量 $x$ 的欧几里得范数 $\\alpha$：\n$$\n\\alpha = \\|x\\|_2 = \\sqrt{1^2 + \\delta^2 + 0^2} = \\sqrt{1 + \\delta^2}.\n$$\n问题定义了未归一化的 Householder 向量的两种可能选择：\n$$\nv_{\\text{right}} = x + \\alpha e_1\n$$\n$$\nv_{\\text{wrong}} = x - \\alpha e_1\n$$\n在数值算法中，标准的“正确”选择是使 $x \\pm \\alpha e_1$ 中的符号与 $x$ 的第一个分量的符号相匹配，以避免相消误差。由于 $(x)_1 = 1 > 0$，数值上稳定的选择是 $v_{\\text{right}}$。问题要求计算一个涉及两种选择的比率。\n\n我们来显式地构造这些向量：\n$$\nv_{\\text{right}} = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix} + \\sqrt{1 + \\delta^2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 + \\sqrt{1 + \\delta^2} \\\\ \\delta \\\\ 0 \\end{pmatrix}\n$$\n$$\nv_{\\text{wrong}} = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix} - \\sqrt{1 + \\delta^2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 - \\sqrt{1 + \\delta^2} \\\\ \\delta \\\\ 0 \\end{pmatrix}\n$$\n我们需要计算比率 $\\kappa(\\delta)$，其定义为\n$$\n\\kappa(\\delta)=\\frac{\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right|}{\\left| \\left(v_{\\text{right}}\\right)_1 \\right|}.\n$$\n第一个分量分别是 $(v_{\\text{right}})_1 = 1 + \\sqrt{1 + \\delta^2}$ 和 $(v_{\\text{wrong}})_1 = 1 - \\sqrt{1 + \\delta^2}$。\n\n我们计算这些分量的绝对值。由于 $\\delta > 0$，我们有 $\\delta^2 > 0$，这意味着 $1 + \\delta^2 > 1$，因此 $\\sqrt{1 + \\delta^2} > 1$。\n项 $(v_{\\text{right}})_1 = 1 + \\sqrt{1 + \\delta^2}$ 是严格为正的，所以其绝对值是其自身：\n$$\n\\left| \\left(v_{\\text{right}}\\right)_1 \\right| = 1 + \\sqrt{1 + \\delta^2}.\n$$\n项 $(v_{\\text{wrong}})_1 = 1 - \\sqrt{1 + \\delta^2}$ 是严格为负的。其绝对值是该项的相反数：\n$$\n\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right| = - (1 - \\sqrt{1 + \\delta^2}) = \\sqrt{1 + \\delta^2} - 1.\n$$\n现在，我们可以写出 $\\kappa(\\delta)$ 的表达式：\n$$\n\\kappa(\\delta) = \\frac{\\sqrt{1 + \\delta^2} - 1}{\\sqrt{1 + \\delta^2} + 1}.\n$$\n这个表达式是正确的，但可以进一步简化，特别是为了获得一个当 $\\delta$ 很小（如 $\\delta \\ll 1$ 所示）时在数值计算上更稳健的形式。这可以通过分子有理化来实现。我们将分子和分母同乘以分子的共轭项，即 $(\\sqrt{1 + \\delta^2} + 1)$：\n$$\n\\kappa(\\delta) = \\left( \\frac{\\sqrt{1 + \\delta^2} - 1}{\\sqrt{1 + \\delta^2} + 1} \\right) \\times \\left( \\frac{\\sqrt{1 + \\delta^2} + 1}{\\sqrt{1 + \\delta^2} + 1} \\right).\n$$\n分子简化为平方差：\n$$\n(\\sqrt{1 + \\delta^2} - 1)(\\sqrt{1 + \\delta^2} + 1) = (\\sqrt{1 + \\delta^2})^2 - 1^2 = (1 + \\delta^2) - 1 = \\delta^2.\n$$\n分母变成一个平方：\n$$\n(\\sqrt{1 + \\delta^2} + 1)(\\sqrt{1 + \\delta^2} + 1) = (\\sqrt{1 + \\delta^2} + 1)^2.\n$$\n结合这些结果，得到 $\\kappa(\\delta)$ 的最终、简化的闭式表达式：\n$$\n\\kappa(\\delta) = \\frac{\\delta^2}{(\\sqrt{1 + \\delta^2} + 1)^2}.\n$$\n这种形式避免了中间表达式分子中存在的相消误差，而这正是区分 $v_{\\text{right}}$ 和 $v_{\\text{wrong}}$ 的全部意义所在。",
            "answer": "$$\\boxed{\\frac{\\delta^2}{\\left(\\sqrt{1 + \\delta^2} + 1\\right)^2}}$$"
        },
        {
            "introduction": "为了节省内存和计算成本，数值计算库通常以紧凑的格式存储一系列Householder变换，而不是存储一个完整的正交矩阵$Q$。一个常见的任务是在需要时从这种紧凑的表示中重建显式的$Q$矩阵。本练习涉及实现一个算法，通过将存储的反射子序列$H_k$应用于一个单位矩阵来形成$Q$。通过完成这个编码练习（），您将把累积变换的数学定义转化为一个可工作的程序，从而巩固您对单个反射如何组合形成最终正交矩阵的理解。",
            "id": "2401995",
            "problem": "给定一个在 $n \\times n$ 阶实对称矩阵三对角化过程中产生的 Householder 反射序列的紧凑表示。对于每个满足 $0 \\le k \\le n-3$ 的整数 $k$（使用从零开始的索引），给定一个向量 $v_k \\in \\mathbb{R}^{n-k-1}$，它编码了后续子空间上的 Householder 方向。定义补零向量 $w_k \\in \\mathbb{R}^n$ 如下：\n$$\n(w_k)_i =\n\\begin{cases}\n0,  \\text{若 } 0 \\le i \\le k,\\\\\n(v_k)_{i-(k+1)},  \\text{若 } k+1 \\le i \\le n-1,\n\\end{cases}\n$$\n以及标量\n$$\n\\tau_k = \\frac{2}{w_k^\\mathsf{T} w_k}.\n$$\n第 $k$ 个 Householder 反射则为\n$$\nH_k = I - \\tau_k \\, w_k w_k^\\mathsf{T},\n$$\n完整的正交矩阵由以下乘积定义：\n$$\nQ = H_0 H_1 \\cdots H_{n-3}.\n$$\n对于阶数 $n \\le 2$，该乘积为空，此时必须取 $Q = I$。\n\n你的任务是根据上面定义的紧凑数据 $(v_k)$ 精确地重构 $Q$。矩阵元素使用从零开始的索引。\n\n对于下面的每个测试用例，在构建 $Q$ 后，计算两个量：\n- 元素 $Q_{1,1}$（第 1 行、第 1 列的元素），以四舍五入到 $10$ 位小数的实数形式返回。\n- 行列式 $\\det(Q)$，以整数形式返回，该整数等于与 $\\det(Q)$ 最接近的整数，对于正交矩阵，该值是 $-1$ 或 $1$。\n\n提供以下测试套件，它包含三个用例：\n\n- 用例 A：$n = 5$，向量为 $v_0 = \\left[1.0,\\, 0.3,\\, -0.4,\\, 0.5\\right]$，$v_1 = \\left[1.0,\\, -0.2,\\, 0.7\\right]$，$v_2 = \\left[1.0,\\, 0.6\\right]$。\n\n- 用例 B：$n = 3$，向量为 $v_0 = \\left[1.0,\\, -0.4\\right]$。\n\n- 用例 C：$n = 2$，没有反射（集合 $\\{v_k\\}$ 为空），因此 $Q = I$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\left[\\;Q_{1,1}\\text{ (用例 A)},\\; \\det(Q)\\text{ (用例 A)},\\; Q_{1,1}\\text{ (用例 B)},\\; \\det(Q)\\text{ (用例 B)},\\; Q_{1,1}\\text{ (用例 C)},\\; \\det(Q)\\text{ (用例 C)}\\;\\right].\n$$\n三个 $Q_{1,1}$ 值必须四舍五入到 10 位小数，三个行列式必须是整数。输出行中不允许有空格。本问题不涉及角度。任何量都不涉及物理单位。",
            "solution": "问题陈述经过仔细审查，被认为是有效的。它提出了一个数值线性代数中的适定问题，所有术语都有明确的定义，所有数据都是自洽的。任务是从一个正交矩阵的紧凑 Householder 表示中重构该矩阵，这是一个标准的、可通过算法指定的过程。\n\n目标是计算正交矩阵 $Q$，它被定义为 Householder 反射序列的乘积：\n$$\nQ = H_0 H_1 \\cdots H_{n-3}\n$$\n对于给定的矩阵阶数 $n$。对于 $n \\le 2$，$Q$ 被定义为单位矩阵 $I$。每个 Householder 反射 $H_k$ 由下式给出：\n$$\nH_k = I - \\tau_k w_k w_k^\\mathsf{T}\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。向量 $w_k \\in \\mathbb{R}^n$ 是通过在给定向量 $v_k \\in \\mathbb{R}^{n-k-1}$ 的前面添加 $k+1$ 个零来构造的，标量 $\\tau_k$ 定义为 $\\tau_k = 2 / (w_k^\\mathsf{T} w_k)$。\n\n为了重构 $Q$，我们避免显式地构建和乘以矩阵 $H_k$，因为这样计算成本高昂。一种更有效的方法是通过将变换应用于单位矩阵来计算乘积。乘积 $Q = H_0 H_1 \\cdots H_{n-3} I$ 可以通过依次应用反射来计算。正确的运算顺序至关重要。我们可以将乘积写为：\n$$\nQ = H_0 \\left( H_1 \\left( \\cdots \\left( H_{n-3} I \\right) \\cdots \\right) \\right)\n$$\n这种结构提示了一种算法：我们从一个初始矩阵开始，将其设为 $Q_{n-2} = I$，然后按索引降序（即 $k = n-3, n-4, \\ldots, 0$）迭代地应用反射。也就是说，我们计算：\n$$\nQ_{k} = H_k Q_{k+1}\n$$\n最终结果是 $Q = Q_{0}$。\n\n这个迭代的每一步，即与一个 Householder 矩阵的乘法，也可以高效地执行。我们不构建稠密矩阵 $H_k$，而是使用其定义来更新当前累积的矩阵 $Q_{current}$：\n$$\nQ_{new} = H_k Q_{current} = (I - \\tau_k w_k w_k^\\mathsf{T}) Q_{current} = Q_{current} - \\tau_k w_k (w_k^\\mathsf{T} Q_{current})\n$$\n这个操作是对 $Q_{current}$ 的一次秩-1 更新，其计算效率远高于完整的矩阵-矩阵乘法。首先计算向量 $w_k^\\mathsf{T} Q_{current}$，得到一个行向量，然后将其与 $w_k$ 用于外积。\n\n总体算法如下：\n1. 处理基本情况。如果 $n \\le 2$，$Q$ 是 $n \\times n$ 的单位矩阵。\n2. 对于 $n > 2$，将 $Q$ 初始化为 $n \\times n$ 的单位矩阵。\n3. 使用索引 $k$ 从 $n-3$ 递减到 $0$ 进行迭代。在每一步中：\n    a. 通过取用所提供的向量 $v_k$ 并在其前面添加 $k+1$ 个零来构建向量 $w_k \\in \\mathbb{R}^n$。\n    b. 计算标量 $\\tau_k = 2 / (w_k^\\mathsf{T} w_k)$。分母是 $w_k$ 的欧几里得范数的平方。由于问题给出的 $v_k$ 向量是非零的，所以 $w_k$ 也是非零的，该除法是良定义的。\n    c. 使用秩-1 更新来更新矩阵 $Q$：\n       i. 计算行向量 $z^\\mathsf{T} = w_k^\\mathsf{T} Q$。\n       ii. 更新 $Q \\leftarrow Q - \\tau_k w_k z^\\mathsf{T}$。\n4. 循环完成后，矩阵 $Q$ 即为最终的乘积 $H_0 H_1 \\cdots H_{n-3}$。\n5. 从最终的矩阵 $Q$ 中，提取元素 $Q_{1,1}$（基于零的索引，即第二行第二列的元素）并计算行列式 $\\det(Q)$。行列式可作为一致性检查；对于由 $m$ 个反射的乘积形成的正交矩阵，其行列式必须为 $(-1)^m$。这里，对于 $n \\ge 3$，有 $m = n-2$，因此 $\\det(Q) = (-1)^{n-2}$。\n\n该过程将应用于每个测试用例，以获得所需的数值结果。以下是用于生成结果的Python实现：\n```python\nimport numpy as np\n\ndef reconstruct_q(n, v_list):\n    \"\"\"\n    Reconstructs the orthogonal matrix Q from its compact Householder representation.\n\n    Args:\n        n (int): The dimension of the matrix.\n        v_list (list of list of float): A list containing the vectors v_k for k=0 to n-3.\n\n    Returns:\n        numpy.ndarray: The reconstructed n x n orthogonal matrix Q.\n    \"\"\"\n    if n = 2:\n        return np.identity(n)\n\n    Q = np.identity(n)\n\n    # The product is Q = H_0 H_1 ... H_{n-3}.\n    # We compute this by starting with I and applying transformations from right to left,\n    # which corresponds to applying H_k for k from n-3 down to 0.\n    # Q_final = H_0 (H_1 (... (H_{n-3} I)...))\n    num_reflectors = n - 2\n    for k in range(num_reflectors - 1, -1, -1):\n        # v_list is indexed by k, so v_list[k] is v_k.\n        vk = np.array(v_list[k])\n\n        # Construct the full Householder vector w_k padded with k+1 zeros.\n        wk = np.zeros(n)\n        wk[k + 1:] = vk\n\n        # Compute tau_k = 2 / (w_k^T w_k)\n        wTw = wk @ wk\n        if wTw == 0:\n            tau_k = 0.0\n        else:\n            tau_k = 2.0 / wTw\n\n        # Apply H_k to the current Q: Q_new = H_k * Q_old\n        # This is done efficiently without forming H_k.\n        # Q_new = (I - tau_k * w_k * w_k^T) * Q_old = Q_old - tau_k * w_k * (w_k^T * Q_old)\n        z_T = wk @ Q  # This computes the row vector w_k^T * Q\n        update_matrix = np.outer(wk, z_T)\n        Q -= tau_k * update_matrix\n\n    return Q\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"v_list\": [\n                [1.0, 0.3, -0.4, 0.5],  # v0\n                [1.0, -0.2, 0.7],     # v1\n                [1.0, 0.6]            # v2\n            ],\n        },\n        {\n            \"n\": 3,\n            \"v_list\": [\n                [1.0, -0.4]           # v0\n            ],\n        },\n        {\n            \"n\": 2,\n            \"v_list\": [],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        v_list = case[\"v_list\"]\n\n        Q = reconstruct_q(n, v_list)\n        \n        # Extract Q_1,1 (zero-based indexing)\n        q11 = Q[1, 1]\n        \n        # Compute the determinant\n        det_q = np.linalg.det(Q)\n\n        # Append results with specified formatting\n        results.append(f\"{q11:.10f}\")\n        results.append(str(int(np.rint(det_q))))\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```",
            "answer": "[-0.2119932415,-1,-0.7241379310,-1,1.0000000000,1]"
        }
    ]
}