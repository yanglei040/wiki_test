{
    "hands_on_practices": [
        {
            "introduction": "我们从一个熟悉且直观的现象开始：马车轮效应。这个练习将时间混叠 (temporal aliasing) 建模为一个采样问题，让你能够通过编程来模拟和预测人眼所感知的旋转速度和方向 。通过这个实践，你将建立起对混叠现象最基本的直观理解，明白离散采样如何“欺骗”我们对连续运动的感知。",
            "id": "2373299",
            "problem": "要求您将时间混叠（“车轮效应”）建模为一个旋转相位的采样问题。考虑一个刚性轮，其轮缘上有一个可区分的标记，以恒定的旋转频率 $f_{rot}$（单位：赫兹，即周/秒）旋转。一台理想相机以均匀的时间间隔、帧率 $f_{fps}$（单位：赫兹）对轮子的状态进行采样，曝光为瞬时曝光（无运动模糊）。标记的角相位为 $\\phi(t) = 2\\pi f_{rot} t + \\phi_0$，不失一般性，设 $\\phi_0 = 0$。设采样时间为 $t_n = n/f_{fps}$，其中 $n$ 为整数。帧间相位增量为 $\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$，对于所有 $n$ 而言，该值是相同的。\n\n假设人类感知系统会选择与采样图像一致的最小幅度的帧间变化，即与 $\\Delta \\phi$ 模 $2\\pi$ 同余且位于区间 $(-\\pi, \\pi]$ 内的唯一代表值 $\\Delta \\phi^{*}$。将感知到的连续时间旋转频率（单位：赫兹）定义为 $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$，将感知方向定义为整数 $s \\in \\{-1, 0, +1\\}$，由 $s = \\operatorname{sgn}(\\Delta \\phi^{*})$ 给出，并约定当 $f_{perc}$ 恰好为 $0$ 时 $s = 0$。此约定通过取 $\\Delta \\phi^{*} = +\\pi$ 来确定性地解决边界情况 $\\Delta \\phi \\equiv \\pi \\pmod{2\\pi}$。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 对于下面的每个测试用例，将 $f_{rot}$ 和 $f_{fps}$（均以赫兹为单位）作为输入。\n- 仅使用上述原理和定义，计算感知频率 $f_{perc}$（单位：赫兹）和感知方向 $s$。\n- 将 $f_{perc}$（单位：赫兹）表示为四舍五入到 $6$ 位小数的数值。\n- 为每个测试用例返回一个形式为 $[f_{perc}, s]$ 的列表。\n\n物理单位：所有频率必须以赫兹（Hz）表示。角度在内部以弧度处理。方向必须是整数 $-1$、$0$ 或 $+1$。将 $f_{perc}$ 四舍五入到 $6$ 位小数。\n\n参数值测试套件（包括正常、边缘和边界情况），每个均以 $(f_{rot}, f_{fps})$（单位：赫兹）的形式给出：\n- 用例 1：$(2.3,\\, 24.0)$\n- 用例 2：$(23.0,\\, 24.0)$\n- 用例 3：$(12.0,\\, 24.0)$\n- 用例 4：$(48.0,\\, 24.0)$\n- 用例 5：$(-1.2,\\, 24.0)$\n- 用例 6：$(103.0,\\, 24.0)$\n- 用例 7：$(0.49,\\, 24.0)$\n- 用例 8：$(31.0,\\, 30.0)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素本身是针对一个测试用例的列表 $[f_{perc}, s]$，其中 $f_{perc}$ 是一个精确到 $6$ 位小数的浮点数，$s$ 是一个整数。例如，整体结构必须类似于 $[[f_1, s_1],[f_2, s_2],\\ldots]$，并采用指定的数字格式，例如 $[[2.300000,1],[1.000000,-1],\\ldots]$。不应打印任何其他文本。",
            "solution": "问题陈述已经过严格的验证过程。\n\n给定条件如下：\n- 旋转轮上标记的角相位：$\\phi(t) = 2\\pi f_{rot} t$，其中 $f_{rot}$ 是以赫兹为单位的旋转频率。\n- 帧率为 $f_{fps}$ 的相机的采样时间：$t_n = n/f_{fps}$，其中整数 $n \\ge 0$。\n- 帧间相位增量：$\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$。\n- 感知相位增量 $\\Delta \\phi^{*}$ 是 $\\Delta \\phi$ 模 $2\\pi$ 的唯一同余代表，使得 $\\Delta \\phi^{*} \\in (-\\pi, \\pi]$。\n- 感知频率：$f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$。\n- 感知方向：$s = \\operatorname{sgn}(\\Delta \\phi^{*})$，如果 $\\Delta \\phi^{*} = 0$，则 $s=0$。\n\n验证确认该问题具有科学依据，定义明确且客观。它基于信号采样理论的基本原理，为时间混叠现象提供了一个清晰、形式化的模型。所有术语都得到了明确的定义，所需的计算在数学上是合理的，并能得出唯一的解。因此，该问题被认为是有效的，并按如下方式推导出解决方案。\n\n分析首先推导帧间相位增量 $\\Delta \\phi$。将相位 $\\phi(t)$ 和采样时间 $t_n$ 的表达式代入 $\\Delta \\phi$ 的定义中：\n$$\n\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n) = 2\\pi f_{rot} \\left(\\frac{n+1}{f_{fps}}\\right) - 2\\pi f_{rot} \\left(\\frac{n}{f_{fps}}\\right)\n$$\n简化表达式可得到一个恒定的相位增量：\n$$\n\\Delta \\phi = 2\\pi f_{rot} \\left(\\frac{n+1-n}{f_{fps}}\\right) = 2\\pi \\frac{f_{rot}}{f_{fps}}\n$$\n问题的核心在于感知模型，该模型将真实的相位增量 $\\Delta \\phi$ 映射到其感知对应值 $\\Delta \\phi^{*}$。这是一个数学上的回绕（wrapping）操作。我们必须找到一个整数 $k$，代表在感知上被舍弃的完整 $2\\pi$ 旋转的圈数，使得：\n$$\n\\Delta \\phi^{*} = \\Delta \\phi - 2\\pi k\n$$\n并且 $\\Delta \\phi^{*}$ 落在指定的主区间 $(-\\pi, \\pi]$ 内。\n\n为了系统地找到 $k$，我们可以处理归一化的频率和相位。令 $x$ 为旋转频率与采样频率之比：\n$$\nx = \\frac{f_{rot}}{f_{fps}}\n$$\n归一化的相位增量为 $\\frac{\\Delta \\phi}{2\\pi} = x$。我们寻求一个归一化的感知相位增量 $p = \\frac{\\Delta \\phi^{*}}{2\\pi}$，使得对于某个整数 $k$，$p = x - k$ 且 $p \\in (-0.5, 0.5]$。\n这个关于 $p$ 的不等式可以改写为关于 $x$ 和 $k$ 的形式：\n$$\n-0.5  x - k \\le 0.5\n$$\n重新整理以求解 $k$，得到条件：\n$$\nx - 0.5 \\le k  x + 0.5\n$$\n对于任何实数 $x$，满足此条件的唯一整数 $k$ 由上取整函数（ceiling function）给出：\n$$\nk = \\lceil x - 0.5 \\rceil\n$$\n确定 $k$ 后，归一化的感知相位增量 $p$ 计算为 $p = x - k$。\n\n感知频率 $f_{perc}$ 定义为 $f_{perc} = \\frac{f_{fps}}{2\\pi} |\\Delta \\phi^{*}|$。代入 $\\Delta \\phi^{*} = 2\\pi p$：\n$$\nf_{perc} = \\frac{f_{fps}}{2\\pi} |2\\pi p| = f_{fps} |p| = f_{fps} \\left| \\frac{f_{rot}}{f_{fps}} - k \\right|\n$$\n感知方向 $s$ 是感知相位增量的符号：\n$$\ns = \\operatorname{sgn}(\\Delta \\phi^{*}) = \\operatorname{sgn}(2\\pi p) = \\operatorname{sgn}(p)\n$$\n按照约定，$\\operatorname{sgn}(0) = 0$，这能正确处理感知图像静止（$f_{perc} = 0$）的情况。\n\n对于给定的 $(f_{rot}, f_{fps})$ 对，完整的计算算法如下：\n1. 计算频率比 $x = f_{rot} / f_{fps}$。\n2. 确定要减去的整数圈数 $k = \\lceil x - 0.5 \\rceil$。\n3. 计算归一化的感知相位增量 $p = x - k$。\n4. 计算感知频率 $f_{perc} = f_{fps} |p|$。\n5. 确定感知方向 $s = \\operatorname{sgn}(p)$。\n6. 将 $f_{perc}$ 四舍五入到 $6$ 位小数，并返回序对 $[f_{perc}, s]$。\n现在实现此算法以解决所提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the perceived frequency and direction of a rotating object\n    subject to temporal aliasing, based on the wagon-wheel effect model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (f_rot, f_fps) in hertz.\n    test_cases = [\n        (2.3, 24.0),     # Case 1\n        (23.0, 24.0),    # Case 2\n        (12.0, 24.0),    # Case 3\n        (48.0, 24.0),    # Case 4\n        (-1.2, 24.0),    # Case 5\n        (103.0, 24.0),   # Case 6\n        (0.49, 24.0),    # Case 7\n        (31.0, 30.0),    # Case 8\n    ]\n\n    # A list to store the string-formatted results for each case.\n    results_str_list = []\n\n    for case in test_cases:\n        f_rot, f_fps = case\n\n        # Step 1: Calculate the frequency ratio x.\n        # This represents the number of rotations per sample period.\n        x = f_rot / f_fps\n\n        # Step 2: Determine the integer number of full rotations k to subtract.\n        # The logic k = ceil(x - 0.5) ensures that the remainder p = x - k\n        # falls into the interval (-0.5, 0.5], which corresponds to a\n        # phase increment in (-pi, pi].\n        k = np.ceil(x - 0.5)\n\n        # Step 3: Compute the normalized perceived phase increment p.\n        p = x - k\n\n        # Step 4: Calculate the perceived frequency f_perc.\n        # This is the magnitude of the perceived rotation rate.\n        f_perc = f_fps * np.abs(p)\n\n        # Step 5: Determine the perceived direction s.\n        # This is the sign of the perceived phase increment.\n        # np.sign(0) correctly returns 0.\n        s = int(np.sign(p))\n\n        # Step 6: Format the result for the current case as a string '[f_perc,s]'\n        # f_perc is formatted to exactly 6 decimal places.\n        case_result_str = f\"[{f_perc:.6f},{s}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The final output is a single line: a list of lists.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了混叠的成因后，下一步是学习如何控制它。在信号处理中，降低采样率（或称“抽取”）是一项常见操作，但如果处理不当，就会引入混叠失真。这个练习  要求你对比两种处理流程——先滤波后抽取，与先抽取后滤波——并量化地展示抗混叠滤波器 (anti-aliasing filter) 的决定性作用。这是正确进行信号降采样的关键一步。",
            "id": "2373295",
            "problem": "一个离散时间信号由有限时长的、均匀采样的余弦和构成。我们对其应用两种处理顺序：先低通滤波后降采样，以及先降采样后低通滤波。任务是使用在离散傅里叶变换 (DFT) 网格上定义的数学理想低通滤波器，来量化操作顺序对最终频谱的影响。该问题涉及计算物理学中的混叠和奈奎斯特准则。\n\n给定采样频率 $F_{s}$（单位：赫兹，Hz）、时长 $T$（单位：秒，s）以及一组音调分量 $\\{(A_{i}, f_{i})\\}$，其中振幅 $A_{i}$ 为无量纲，频率 $f_{i}$ 单位为赫兹 (Hz)，定义连续时间信号\n$$\ns(t) = \\sum_{i} A_{i}\\cos\\!\\big(2\\pi f_{i} t\\big),\n$$\n以及以 $F_{s}$ 采样、时长为 $T$ 的离散时间信号\n$$\nx[n] = s\\!\\left(\\frac{n}{F_{s}}\\right), \\quad n=0,1,\\dots,N-1, \\quad N = \\lfloor F_{s} T \\rfloor.\n$$\n设 $M$ 为一个正整数降采样因子。定义降采样后的新采样频率为 $F_{s}^{(\\downarrow)} = F_{s}/M$，以及对应的新奈奎斯特频率为 $F_{\\mathrm{N,new}} = \\frac{F_{s}}{2M}$（单位：赫兹，Hz）。\n\n在 DFT 网格上定义一个理想低通滤波器 $H$ 如下。对于一个长度为 $L$ 的序列 $u[n]$，设 $U[k]$ 为其 $L$ 点 DFT，其频率仓中心频率（单位：赫兹，Hz）由 $f_{k} = \\frac{k}{L}F_{s}^{(u)}$ 给出（$k=0,\\dots,L-1$），通过 $\\mathrm{fftfreq}$ 使用 DFT 的标准中心化频率分配进行解释，其中 $F_{s}^{(u)}$ 是 $u[n]$ 的采样频率。具有截止频率 $f_{c}$（单位：赫兹，Hz）的理想低通滤波器（包含边界）在 DFT 网格上由以下频率响应定义：\n$$\nH(f) = \\begin{cases}\n1,  |f|\\le f_{c},\\\\\n0,  |f| f_{c},\n\\end{cases}\n$$\n该滤波器通过将 $U[k]$ 与 $H(f_{k})$ 相乘，然后用逆 DFT 变换回来实现。此定义在 DFT 频率仓上强制实现砖墙响应。\n\n将对 $x[n]$ 应用两种处理顺序：\n1. 先滤波后降采样：设 $f_{c} = F_{s}/(2M)$。对 $x[n]$ 应用截止频率为 $f_{c}$、采样频率为 $F_{s}$ 的理想低通滤波器，形成 $x_{\\mathrm{F}}[n]$。然后形成\n$$\ny_{A}[m] = x_{\\mathrm{F}}[mM], \\quad m=0,1,\\dots,\\left\\lfloor\\frac{N}{M}\\right\\rfloor-1.\n$$\n2. 先降采样后滤波：首先形成 $x_{\\downarrow}[m] = x[mM]$，其采样频率为 $F_{s}^{(\\downarrow)}=F_{s}/M$。然后，在采样频率 $F_{s}^{(\\downarrow)}$ 下，应用截止频率为 $f_{c} = F_{s}/(2M)$ 的相同理想低通滤波器定义，以获得 $y_{B}[m]$。\n\n对于长度均为 $L = \\left\\lfloor N/M \\right\\rfloor$ 的 $y_{A}[m]$ 和 $y_{B}[m]$，计算它们的 $L$ 点离散傅里叶变换 (DFT)，记作 $Y_{A}[k]$ 和 $Y_{B}[k]$。设幅度谱为 $|Y_{A}[k]|$ 和 $|Y_{B}[k]|$。定义归一化频谱差异\n$$\nR = \\frac{\\left\\|\\,|Y_{B}| - |Y_{A}|\\,\\right\\|_{2}}{\\left\\|\\,|Y_{A}|\\,\\right\\|_{2}},\n$$\n其中 $\\|\\cdot\\|_{2}$ 是在 $L$ 个 DFT 频率仓上的欧几里得范数。这个 $R$ 是无量纲的，它量化了操作顺序对最终频谱的影响。\n\n测试套件。使用以下三个测试用例，以涵盖一个一般情况、一个在新奈奎斯特频率上的边界情况以及一个无混叠的边缘情况。所有时长和频率分别以秒 (s) 和赫兹 (Hz) 提供。振幅是无量纲的。三角函数内的角度以弧度为单位。\n\n- 用例 1（一般情况，包含高于新奈奎斯特频率的内容）：\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$.\n  - 分量 $\\{(A_{i}, f_{i})\\}$: $(1.0, 100)$, $(0.6, 400)$, $(0.8, 700)$, $(0.5, 900)$.\n\n- 用例 2（在新奈奎斯特频率上的边界情况，且包含额外高于新奈奎斯特频率的内容）：\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$.\n  - 分量 $\\{(A_{i}, f_{i})\\}$: $(1.0, 512)$, $(0.8, 200)$, $(0.7, 900)$.\n\n- 用例 3（无混叠的边缘情况；所有音调都安全地低于新奈奎斯特频率）：\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$.\n  - 分量 $\\{(A_{i}, f_{i})\\}$: $(1.0, 80)$, $(0.5, 200)$, $(0.7, 350)$.\n\n要求的程序输出。对于每个用例，计算如上定义的 $R$ 值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按给定用例的顺序排列，每个值四舍五入到六位小数（例如，“[$0.123456,0.000000,1.234568$]”）。输出值为无量纲浮点数。",
            "solution": "问题陈述已经过严格验证，并被确定是合理的。它在科学上基于数字信号处理的原理，特别是关于混叠和奈奎斯特-香农采样定理。该问题是适定的、客观的，并提供了一套完整、一致的定义和数据，以得出一个唯一的、可验证的解。我们可以继续。\n\n这个问题的核心在于演示数字信号处理中抽取（降采样）的基本原理：为防止混叠，信号必须在降低其采样率*之前*进行低通滤波。该问题要求对两种处理顺序进行定量比较：一种是正确的（先滤波后降采样），另一种是错误的（先降采样后滤波）。\n\n让我们将初始离散信号记为 $x[n]$，其采样频率为 $F_s$，长度为 $N$。降采样因子为 $M$。目标采样频率是 $F_{s}^{(\\downarrow)} = F_s/M$，相应的奈奎斯特频率是 $F_{\\mathrm{N,new}} = F_{s}^{(\\downarrow)}/2 = F_s/(2M)$。\n\n路径 A：先滤波后降采样\n此过程代表了正确的抽取方法。\n1.  **抗混叠滤波器**：信号 $x[n]$ 首先由一个截止频率为 $f_c = F_{\\mathrm{N,new}}$ 的理想低通滤波器处理。这一步称为抗混叠滤波，它会从信号中移除所有位于新奈奎斯特频率之上的频率分量。滤波后的信号 $x_{\\mathrm{F}}[n]$ 保证是带限的，范围在 $[-F_{\\mathrm{N,new}}, F_{\\mathrm{N,new}}]$ 之内。数学上，如果 $X[k]$ 是 $x[n]$ 的离散傅里叶变换 (DFT)，则滤波后的频谱为 $X_{\\mathrm{F}}[k] = X[k] H(f_k)$，其中当 $|f_k| \\le f_c$ 时 $H(f_k)$ 为1，否则为0。\n2.  **降采样**：然后将滤波后的信号 $x_{\\mathrm{F}}[n]$ 以因子 $M$ 进行降采样，生成 $y_A[m] = x_{\\mathrm{F}}[mM]$。因为所有可能导致混叠的频率都已事先被移除，所以 $y_A[m]$ 的频谱是原始信号低频内容的一个干净、缩放的表示。频谱 $|Y_A[k]|$ 将只包含对应于原始信号音调 $(A_i, f_i)$ 中满足 $|f_i| \\le F_{\\mathrm{N,new}}$ 的峰值。\n\n路径 B：先降采样后滤波\n此过程说明了忽略抗混叠要求的后果。\n1.  **降采样**：原始信号 $x[n]$ 被立即降采样以生成 $x_{\\downarrow}[m] = x[mM]$。在频域中，此操作会导致频谱折叠，即混叠。延伸至 $\\pm F_s/2$ 的原始频谱被复制和求和。原始信号中的任何频率分量 $f_i$ 都会被映射到基带 $[-F_{\\mathrm{N,new}}, F_{\\mathrm{N,new}}]$ 中的一个新的表观频率 $f_{\\text{alias}}$。这个混叠频率由 $f_{\\text{alias}} = f_i \\pmod{F_{s}^{(\\downarrow)}}$ 给出，并对负频率进行适当的解释。具体来说，一个高频分量 $|f_i|  F_{\\mathrm{N,new}}$ 将被不可区分地叠加到一个较低的频率上。\n2.  **滤波**：现在已经混叠的信号 $x_{\\downarrow}[m]$ 由相同的理想低通滤波器处理。然而，该滤波器无法区分原始的带内分量和已被折叠到其通带内的新混叠分量。它将通过所有这些分量。因此，结果信号 $y_B[m]$ 不仅会包含原始的低频音调，还会包含原始高频音调的混叠产物。频谱 $|Y_B[k]|$ 将展示出对应于 $|f_i| \\le F_{\\mathrm{N,new}}$ 的原始音调的峰值，以及对应于 $|f_i|  F_{\\mathrm{N,new}}$ 的音调的混叠频率处的峰值。\n\n定量比较\n归一化频谱差异 $R = \\left\\|\\,|Y_{B}| - |Y_{A}|\\,\\right\\|_{2} / \\left\\|\\,|Y_{A}|\\,\\right\\|_{2}$ 量化了由不当处理引入的误差。\n-   如果原始信号在频率 $|f_i|  F_{\\mathrm{N,new}}$ 处含有能量，路径 B 将引入路径 A 中不存在的混叠分量。这将导致 $|Y_B| \\neq |Y_A|$，因此 $R  0$。这对于用例 1 和 2 是预期的结果。\n-   如果原始信号已经是带限的，以至于其所有分量都满足 $|f_i| \\le F_{\\mathrm{N,new}}$，那么路径 A 中的抗混叠滤波器对信号内容没有影响。降采样不会引起混叠。路径 B 中的滤波器也将通过整个信号。在这种理想情况下，$y_A[m]$ 和 $y_B[m]$ 将是相同的，它们的频谱将匹配，并且 $R$ 将为零。这是对用例 3 的预期，任何偏离零的值都可归因于有限精度计算。\n\n算法的流程是为每个测试用例实现这两个路径，计算最终的频谱 $|Y_A[k]|$ 和 $|Y_B[k]|$，然后评估度量 $R$。该实现将使用 `scipy.fft` 库来高效计算 DFT、逆 DFT 和相关的频率网格。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general, with above-new-Nyquist content)\n        (4096, 1, 4, [(1.0, 100), (0.6, 400), (0.8, 700), (0.5, 900)]),\n        # Case 2 (boundary at the new Nyquist and additional above-new-Nyquist content)\n        (4096, 1, 4, [(1.0, 512), (0.8, 200), (0.7, 900)]),\n        # Case 3 (no-aliasing edge case; all tones safely below the new Nyquist)\n        (4096, 1, 4, [(1.0, 80), (0.5, 200), (0.7, 350)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        Fs, T, M, components = case\n        R = calculate_spectral_difference(Fs, T, M, components)\n        results.append(f\"{R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_spectral_difference(Fs, T, M, components):\n    \"\"\"\n    Calculates the normalized spectral difference R for a given set of parameters.\n\n    Args:\n        Fs (int): Sampling frequency in Hz.\n        T (int): Signal duration in seconds.\n        M (int): Downsampling factor.\n        components (list): A list of tuples (A_i, f_i) representing signal components.\n\n    Returns:\n        float: The calculated normalized spectral difference R.\n    \"\"\"\n    # Define signal and processing parameters\n    N = int(np.floor(Fs * T))\n    L = int(np.floor(N / M))\n    fc = Fs / (2 * M)\n\n    # Generate the initial discrete-time signal x[n]\n    n = np.arange(N)\n    t = n / Fs\n    x = np.zeros(N, dtype=np.float64)\n    for A, f in components:\n        x += A * np.cos(2 * np.pi * f * t)\n\n    # --- Path A: Filter-then-downsample ---\n    # 1A. Apply ideal low-pass filter to x[n]\n    X = fft(x)\n    freqs_N = fftfreq(N, d=1/Fs)\n    h_mask_A = np.abs(freqs_N) = fc\n    X_F = X * h_mask_A\n    x_F = np.real(ifft(X_F))\n    \n    # 2A. Downsample the filtered signal\n    y_A = x_F[::M]\n\n    # --- Path B: Downsample-then-filter ---\n    # 1B. Downsample the original signal x[n]\n    x_down = x[::M]\n    Fs_down = Fs / M\n    \n    # 2B. Apply ideal low-pass filter to the downsampled signal\n    X_down = fft(x_down)\n    freqs_L = fftfreq(L, d=1/Fs_down)\n    h_mask_B = np.abs(freqs_L) = fc\n    X_down_filtered = X_down * h_mask_B\n    y_B = np.real(ifft(X_down_filtered))\n\n    # --- Compute Final Spectra and Metric R ---\n    # DFT of the final signals y_A and y_B\n    Y_A = fft(y_A)\n    Y_B = fft(y_B)\n\n    # Magnitude spectra\n    abs_YA = np.abs(Y_A)\n    abs_YB = np.abs(Y_B)\n\n    # Euclidean norms\n    norm_A = np.linalg.norm(abs_YA)\n    \n    # Avoid division by zero if signal A is null\n    if norm_A == 0:\n        return np.inf if np.linalg.norm(abs_YB)  0 else 0.0\n\n    norm_diff = np.linalg.norm(abs_YB - abs_YA)\n    \n    R = norm_diff / norm_A\n    return R\n\nsolve()\n```"
        },
        {
            "introduction": "混叠不仅仅是信号处理中的一个“错误”，在物理模拟中，它甚至可能导致违背基本物理定律的非物理结果。在这个练习中 ，我们将模拟一根振动的弦，其高频振动模式的能量在采样率不足时会“泄漏”到低频模式中。你将通过计算和对比不同采样率下的能量，亲眼见证混叠如何破坏一个数值模拟中已解析模式的能量守恒，从而深刻理解在计算物理中选择合适时间步长的极端重要性。",
            "id": "2373303",
            "problem": "考虑一根理想化的一维振动弦，其在某固定点的位移被建模为基频谐波的叠加。设连续时间信号为\n$$\ns(t) = \\sum_{n=1}^{H} a_n \\cos\\!\\big(2\\pi n f_0 t\\big),\n$$\n其中振幅为 $a_n = 1/n$，基频 $f_0$ 以赫兹为单位，$H$ 为最高谐波指数。在任何是基频周期整数倍的时间间隔内，不同谐波的交叉项的时间平均为零，而 $\\cos^2$ 的时间平均为 $1/2$。因此，在包含谐波 $\\{n: n f_0 \\le f_{\\mathrm{res}}\\}$ 的任何解析频带内的精确时间平均能量为\n$$\nE_{\\mathrm{true,low}} = \\frac{1}{2}\\sum_{\\substack{n=1 \\\\ n f_0 \\le f_{\\mathrm{res}}}}^{H} a_n^2.\n$$\n您将比较此连续时间解析频带能量与通过离散时间采样和使用快速傅里叶变换 (FFT, Fast Fourier Transform) 进行理想低通重构所获得的解析频带能量。当使用离散时间步长 $\\Delta t$ 时，采样点为 $s_k = s(k \\Delta t)$，其中 $k=0,1,\\dots,N-1$，总持续时间为 $T = N \\Delta t$。离散时间表示仅允许达到奈奎斯特极限的频率，连续信号中高于此极限的频率在采样时会变得与某些较低频率无法区分；这就是混叠。当发生混叠时，来自高频模式的能量可能会出现在采样数据的较低频率处，这会人为地夸大在解析频带中测得的能量，并违反了解析模式中的能量守恒。\n\n任务：实现一个程序，针对一组指定的物理和数值参数，构建 $s(t)$，对其进行采样，通过在频域中实现的理想滤波器分离出解析频带，并计算比率\n$$\nR = \\frac{E_{\\mathrm{disc,low}}}{E_{\\mathrm{true,low}}},\n$$\n其中 $E_{\\mathrm{disc,low}}$ 是从采样数据重构的理想低通滤波离散信号计算出的时间平均能量。$R \\approx 1$ 的值表示解析频带得到了忠实解析且无混叠污染，而 $R  1$ 则表明高频模式已混叠到解析频带中。\n\n仅使用基于以下基本原理的理性推导：\n- 时间平均能量的定义，即 $s(t)^2$ 在基频周期的整数倍上的时间平均。\n- 不同谐波在整数周期上的正交性以及恒等式 $\\langle \\cos^2(\\cdot)\\rangle = 1/2$。\n- 离散时间采样限制了可解析频率以及离散频谱在频率上是周期性的概念。\n\n程序要求：\n- 使用 $a_n = 1/n$ 构建 $s(t)$。\n- 对于每个测试用例，在持续时间 $T$（为整数秒）内以均匀步长 $\\Delta t$ 对 $s(t)$ 进行采样，以便频率仓位于 $1/T$ 的整数倍上。\n- 根据上述解析和计算 $E_{\\mathrm{true,low}}$。\n- 按如下方式计算 $E_{\\mathrm{disc,low}}$：\n  1. 使用 FFT 实现计算采样数据的离散傅里叶变换。\n  2. 将频率严格大于 $f_{\\mathrm{res}}$ 的所有傅里叶分量置零（离散频谱中的理想低通）。\n  3. 逆变换到时域，并计算整个持续时间内重构信号平方的时间平均值。\n- 报告每个测试用例的比率 $R$。\n\n使用的单位和约定：\n- 时间单位为秒，频率单位为赫兹，角度单位为弧度。\n\n测试套件：\n除非另有说明，否则所有测试用例均使用以下参数集：\n- 基频 $f_0 = 50$ 赫兹。\n- 最高谐波指数 $H = 40$。\n- 振幅 $a_n = 1/n$，其中 $n = 1,2,\\dots,H$。\n- 总持续时间 $T = 2.0$ 秒。\n- 解析频带截止频率 $f_{\\mathrm{res}} = 700$ 赫兹。\n\n评估以下四个采样时间步长 $\\Delta t$（均以秒为单位）：\n1. $\\Delta t_1 = 1/20000$（一个非常小的时间步长，远低于所选 $H$ 的任何混叠阈值）。\n2. $\\Delta t_2 = 1/6000$（一个较小的时间步长，仍能安全地解析所有包含的谐波）。\n3. $\\Delta t_3 = 1/2000$（一个较大的时间步长，使得一些谐波超出了可解析范围并发生混叠）。\n4. $\\Delta t_4 = 1/1600$（一个更大的时间步长，更接近解析频带的混叠边界）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含与四个 $\\Delta t$ 值相对应的四个比率 $R$，形式为方括号括起来的逗号分隔列表（例如，“[1.000000,1.000000,1.234567,1.345678]”）。每个比率必须是四舍五入到小数点后六位的浮点数。",
            "solution": "所述问题需要进行验证。\n\n步骤 1：提取已知条件。\n- 连续时间信号：$s(t) = \\sum_{n=1}^{H} a_n \\cos(2\\pi n f_0 t)$。\n- 振幅：$a_n = 1/n$。\n- 基频：$f_0$。\n- 最高谐波指数：$H$。\n- 解析频带中的精确时间平均能量：$E_{\\mathrm{true,low}} = \\frac{1}{2}\\sum_{\\substack{n=1 \\\\ n f_0 \\le f_{\\mathrm{res}}}}^{H} a_n^2$。\n- 采样：$s_k = s(k \\Delta t)$，其中 $k=0,1,\\dots,N-1$。\n- 总持续时间：$T = N \\Delta t$。\n- 目标比率：$R = E_{\\mathrm{disc,low}} / E_{\\mathrm{true,low}}$。\n- $E_{\\mathrm{disc,low}}$ 的计算过程：\n    1. 计算采样数据的离散傅里叶变换 (FFT)。\n    2. 将频率严格大于 $f_{\\mathrm{res}}$ 的傅里叶分量置零。\n    3. 逆变换到时域。\n    4. 计算重构信号平方的时间平均值。\n- 测试套件参数：\n    - $f_0 = 50$ 赫兹。\n    - $H = 40$。\n    - $a_n = 1/n$，其中 $n = 1, \\dots, H$。\n    - $T = 2.0$ 秒。\n    - $f_{\\mathrm{res}} = 700$ 赫兹。\n- 用于评估的四个采样时间步长：\n    1. $\\Delta t_1 = 1/20000$ 秒。\n    2. $\\Delta t_2 = 1/6000$ 秒。\n    3. $\\Delta t_3 = 1/2000$ 秒。\n    4. $\\Delta t_4 = 1/1600$ 秒。\n\n步骤 2：使用提取的已知条件进行验证。\n- **科学依据**：该问题基于数字信号处理的基本原理，特别是傅里叶变换、奈奎斯特-香农采样定理以及混叠现象。这些概念在物理学和工程学中是标准内容。振动弦的模型和时间平均能量的公式是正确的。该问题在科学上是合理的。\n- **适定性**：该问题定义精确。它为信号提供了清晰的数学模型，为其分析提供了具体的算法，并为计算提供了完整的参数集。每个测试用例都可以确定唯一的数值结果。\n- **客观性**：问题陈述使用客观、技术性的语言，没有主观性或模糊性。\n- **设置不完整或矛盾**：该问题是自洽的。所有必要的参数（$f_0$, $H$, $T$, $f_{\\mathrm{res}}$ 和 $\\Delta t$ 值）都已提供。像采样点数 $N$ 这样的派生量可以从已知条件（$N = T/\\Delta t$）中计算出来。没有矛盾之处。\n- **不切实际或不可行**：对于混叠的计算演示来说，物理和数值参数是切合实际的。\n- **不适定或结构不良**：该问题结构清晰，提出了一个需要直接应用指定原理的非平凡问题。\n\n步骤 3：结论与行动。\n该问题是有效的。这是一个适定的、有科学依据的计算物理练习。将提供一个解决方案。\n\n任务是通过比较从离散时间表示计算出的信号低频带能量含量与其精确的连续时间对应值，来研究混叠现象。这两种能量的比率 $R$ 作为混叠引起的污染的度量标准。$R  1$ 的值表示由于采样率不足，来自未解析高频分量的能量被错误地映射到了已解析的低频带中。\n\n首先，我们建立基准，即连续信号低频部分的解析时间平均能量 $E_{\\mathrm{true,low}}$。信号为 $s(t) = \\sum_{n=1}^{H} a_n \\cos(2\\pi n f_0 t)$。由于余弦基函数的正交性，$s(t)^2$ 在基频周期 $1/f_0$ 的整数倍区间上的时间平均得以简化。当 $n \\ne m$ 时，$\\cos(2\\pi n f_0 t) \\cos(2\\pi m f_0 t)$ 的时间平均为零；而 $\\cos^2(2\\pi n f_0 t)$ 的时间平均为 $1/2$。因此，总平均功率，或称“时间平均能量”，为 $\\frac{1}{2} \\sum_{n=1}^{H} a_n^2$。问题将解析频带定义为包含频率高达 $f_{\\mathrm{res}}$ 的所有谐波。第 $n$ 次谐波的频率是 $n f_0$。因此，包含在解析频带中的谐波是那些指数 $n$ 满足 $n f_0 \\le f_{\\mathrm{res}}$，即 $n \\le f_{\\mathrm{res}}/f_0$ 的谐波。给定 $f_{\\mathrm{res}} = 700$ Hz 和 $f_0 = 50$ Hz，解析频带中的最高谐波指数为 $n_{\\mathrm{max,res}} = \\lfloor 700/50 \\rfloor = 14$。因此，该频带内的真实能量为：\n$$\nE_{\\mathrm{true,low}} = \\frac{1}{2}\\sum_{n=1}^{14} a_n^2 = \\frac{1}{2}\\sum_{n=1}^{14} \\left(\\frac{1}{n}\\right)^2\n$$\n这个量在所有测试用例中都是恒定的，并作为我们的参考。\n\n接下来，我们对每个指定的采样时间步长 $\\Delta t$ 进行离散时间分析。采样频率为 $f_s = 1/\\Delta t$。奈奎斯特频率 $f_{\\mathrm{Nyquist}} = f_s / 2$ 定义了可以被唯一表示的最高频率。原始信号 $s(t)$ 中任何频率分量 $f$ 若满足 $f  f_{\\mathrm{Nyquist}}$，将会混叠到范围 $[0, f_{\\mathrm{Nyquist}}]$ 内的一个较低频率 $f_{\\mathrm{alias}}$。其关系为 $f_{\\mathrm{alias}} = |f - m f_s|$，其中整数 $m$ 使该绝对差值最小。\n\n每个 $\\Delta t$ 的计算步骤如下：\n1.  确定采样点数 $N = T / \\Delta t$。\n2.  生成离散时间序列 $t_k = k \\Delta t$，其中 $k = 0, \\dots, N-1$。\n3.  构建采样信号 $s_k = s(t_k) = \\sum_{n=1}^{H=40} \\frac{1}{n} \\cos(2\\pi n f_0 t_k)$。\n4.  使用快速傅里叶变换 (FFT) 算法计算 $s_k$ 的离散傅里叶变换 (DFT)，记为 $S_j$。与 DFT 指数 $j$ 对应的频率由 $f_j = j/T$ 给出，其中 $j=0, \\ldots, N-1$（负频率占据指数范围的后半部分）。\n5.  在频域中执行理想低通滤波。这是通过将所有对应频率 $|f_j|$ 严格大于截止频率 $f_{\\mathrm{res}}$ 的系数 $S_j$ 置零来实现的。设得到的滤波后频谱为 $S_{j, \\text{filtered}}$。\n6.  计算滤波后信号的时间平均能量 $E_{\\mathrm{disc,low}}$。虽然可以执行逆 FFT 以获得滤波后的时域信号，然后计算其均方值，但一个更直接且数值上更稳健的方法是应用帕塞瓦尔定理。对于标准科学库中使用的 DFT 归一化，时间平均功率由下式给出：\n$$\nE_{\\mathrm{disc,low}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |s_{k, \\text{low}}|^2 = \\frac{1}{N^2} \\sum_{j=0}^{N-1} |S_{j, \\text{filtered}}|^2\n$$\n该计算在频域中进行，避免了逆变换的计算开销和潜在的精度损失。\n\n最后，为每个 $\\Delta t$ 计算比率 $R = E_{\\mathrm{disc,low}} / E_{\\mathrm{true,low}}$。\n\n让我们分析给定测试用例的预期结果。连续信号中存在的最高频率是 $f_{\\mathrm{max}} = H \\cdot f_0 = 40 \\times 50 \\text{ Hz} = 2000 \\text{ Hz}$。\n- 对于 $\\Delta t_1 = 1/20000$ s，$f_s=20000$ Hz 且 $f_{\\mathrm{Nyquist}} = 10000$ Hz。由于 $f_{\\mathrm{max}}  f_{\\mathrm{Nyquist}}$，不会发生混叠。我们预期 $R \\approx 1.0$。\n- 对于 $\\Delta t_2 = 1/6000$ s，$f_s=6000$ Hz 且 $f_{\\mathrm{Nyquist}} = 3000$ Hz。由于 $f_{\\mathrm{max}}  f_{\\mathrm{Nyquist}}$，不会发生混叠。我们预期 $R \\approx 1.0$。\n- 对于 $\\Delta t_3 = 1/2000$ s，$f_s=2000$ Hz 且 $f_{\\mathrm{Nyquist}} = 1000$ Hz。这里，$f_{\\mathrm{max}}  f_{\\mathrm{Nyquist}}$。频率高于 $1000$ Hz 的谐波（即 $n  1000/50=20$）会发生混叠。一部分混叠能量会落入解析频带（$[0, 700 \\text{ Hz}]$），导致 $E_{\\mathrm{disc,low}}$ 大于 $E_{\\mathrm{true,low}}$。我们预期 $R  1.0$。例如，谐波 $n=27$ 的频率为 $f=1350$ Hz。它混叠为 $f_{\\mathrm{alias}} = |1350 - 2000| = 650$ Hz，该频率位于解析频带内。\n- 对于 $\\Delta t_4 = 1/1600$ s，$f_s=1600$ Hz 且 $f_{\\mathrm{Nyquist}} = 800$ Hz。频率高于 $800$ Hz 的谐波（即 $n  800/50 = 16$）会发生混叠。与前一个情况相比，将有更多的谐波混叠到解析频带中。例如，频率为 $f=950$ Hz 的谐波 $n=19$ 会混叠为 $f_{\\mathrm{alias}} = |950 - 1600|=650$ Hz。我们预期 $R  1.0$，并且这个比率很可能比第三种情况下的更大。\n接下来的实现将遵循这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, fftfreq\n\ndef solve():\n    \"\"\"\n    Computes the ratio of measured to true low-band energy in a sampled signal\n    to demonstrate the effects of aliasing.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a value for the sampling time step delta_t in seconds.\n    test_cases = [\n        1/20000.0,\n        1/6000.0,\n        1/2000.0,\n        1/1600.0,\n    ]\n\n    # Fixed physical and numerical parameters\n    f0 = 50.0  # Fundamental frequency in Hz\n    H = 40     # Highest harmonic index\n    T = 2.0    # Total duration in seconds\n    f_res = 700.0 # Resolved-band cutoff frequency in Hz\n\n    # --- Step 1: Calculate the true, continuous-time low-band energy ---\n    # The resolved band includes harmonics n where n*f0 = f_res.\n    n_max_res = int(f_res / f0)\n    \n    # Amplitudes are a_n = 1/n. The energy contribution is (1/2)*a_n^2.\n    n_series_res = np.arange(1, n_max_res + 1)\n    amplitudes_sq_res = (1.0 / n_series_res)**2\n    e_true_low = 0.5 * np.sum(amplitudes_sq_res)\n\n    results = []\n    # --- Step 2: Loop through each test case (each delta_t) ---\n    for dt in test_cases:\n        # Determine sampling parameters\n        N = int(T / dt)  # Total number of samples\n        \n        # Generate time vector for sampling\n        t = np.arange(N) * dt\n        \n        # Construct the sampled signal s(t)\n        s = np.zeros(N)\n        for n in range(1, H + 1):\n            a_n = 1.0 / n\n            s += a_n * np.cos(2 * np.pi * n * f0 * t)\n            \n        # --- Step 3: Analyze the sampled signal using FFT ---\n        \n        # Compute the Discrete Fourier Transform (DFT) of the signal\n        S = fft(s)\n        \n        # Get the frequency bins corresponding to the DFT components\n        freqs = fftfreq(N, d=dt)\n        \n        # Apply an ideal low-pass filter in the frequency domain.\n        # Create a copy of the spectrum and zero out components with frequencies\n        # strictly greater than f_res.\n        S_filtered = S.copy()\n        S_filtered[np.abs(freqs)  f_res] = 0.0\n        \n        # Compute the discrete-time, low-band energy using Parseval's theorem.\n        # The time-averaged energy (average power) is (1/N^2) * sum(|S_j|^2).\n        e_disc_low = np.sum(np.abs(S_filtered)**2) / (N**2)\n        \n        # Calculate the ratio R\n        ratio = e_disc_low / e_true_low\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    # Each ratio is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}