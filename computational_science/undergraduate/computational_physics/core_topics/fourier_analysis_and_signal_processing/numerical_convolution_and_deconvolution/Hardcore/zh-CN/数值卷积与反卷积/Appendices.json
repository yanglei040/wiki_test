{
    "hands_on_practices": [
        {
            "introduction": "在理论上，线性卷积的定义是一个直接的求和过程。然而，对于长序列，直接计算的效率非常低。本练习将指导你利用卷积定理和快速傅里叶变换（FFT）来实现高效的线性卷积算法 。通过这个实践，你将掌握信号处理和计算物理中一项至关重要的核心技术，并理解如何通过零填充（zero-padding）来确保计算的准确性。",
            "id": "2419128",
            "problem": "实现一个程序，使用快速傅里叶变换（FFT）计算两个有限长度离散时间实序列的线性卷积。从离散时间卷积和离散傅里叶变换（DFT）的定义出发，您将通过对每个序列进行零填充以避免循环混叠，从而数值化地实现线性卷积。您必须遵循以下通用方案实现卷积，不得使用内置的线性卷积例程：将两个序列都进行零填充，其长度需保证循环卷积等于线性卷积；通过FFT计算DFT；在频域中进行逐点相乘；然后计算逆DFT返回时域。最终结果必须是线性卷积。该算法必须对任意有限长度的实值输入序列有效。您可以假设所有输入均为实数且长度有限。您还必须通过将基于FFT的结果与一个可靠库例程（该例程实现了线性卷积的定义）计算的直接时域参考进行比较，来量化数值精度。\n\n您的程序必须执行以下任务：\n1) 实现一个函数，给定两个一维数组表示长度分别为 $N$ 和 $M$ 的序列 $x[n]$ 和 $h[n]$，通过以下步骤计算它们的线性卷积 $y[k] = \\sum_{n=-\\infty}^{\\infty} x[n]\\,h[k-n]$：\n- 将两个序列都零填充到长度 $L$，该长度至少为 $N+M-1$。\n- 计算零填充后序列的DFT（使用FFT）。\n- 将DFT逐点相乘。\n- 计算逆DFT，并将前 $L$ 个样本作为线性卷积返回。\n在此步骤中，您不得使用任何内置的线性卷积例程。但是，您仅可在测试套件中（见下文）使用直接卷积例程来验证数值精度。\n\n2) 为了验证，使用直接时域方法计算一个参考线性卷积，然后报告每次测试中基于FFT的结果与直接计算结果之间的最大绝对误差。\n\n3) 使用以下输入序列测试套件。所有角度均以弧度为单位。每个列表表示一个按索引递增顺序排列的有限序列。\n- 测试 A（一般小规模情况）：$x = [\\,1,\\,2,\\,3\\,]$, $h = [\\,0,\\,1,\\,0.5\\,]$。\n- 测试 B（类脉冲输入）：$x = [\\,1,\\,0,\\,0,\\,0\\,]$, $h = [\\,-1,\\,2,\\,-1\\,]$。\n- 测试 C（由短核平滑的正弦波）：对于 $n \\in \\{\\,0,\\,1,\\,2,\\,3,\\,4,\\,5,\\,6,\\,7\\,\\}$，$x[n] = \\sin\\!\\big(2\\pi n/8\\big)$，且 $h = [\\,0.25,\\,0.5,\\,0.25\\,]$。\n- 测试 D（长度为一的边界情况）：$x = [\\,2.5\\,]$, $h = [\\,-3.0,\\,4.0\\,]$。\n- 测试 E（带有短衰减核的交替符号序列）：$x = [\\,-1.0,\\,2.0,\\,-3.0,\\,4.0,\\,-5.0\\,]$, $h = [\\,0.5,\\,-0.25,\\,0.125,\\,-0.0625\\,]$。\n\n4) 对于每次测试，计算最大绝对误差 $e = \\max_k \\big| y_{\\text{FFT}}[k] - y_{\\text{direct}}[k] \\big|$。将测试 A 到 E 的误差按顺序汇总到一个列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。例如，$[r_1,r_2,r_3,r_4,r_5]$。\n- 每个 $r_i$ 必须是表示相应测试最大绝对误差的十进制浮点数，格式化为最多 $12$ 位有效数字。\n\n所有计算都应在无单位的纯数学环境中进行。实现必须是完全确定性的，并且不应需要任何用户输入。每次测试的结果是一个浮点数。程序必须是自包含的，并且可以直接运行。",
            "solution": "所述问题是有效的。它具有科学依据，提法明确，客观，并包含唯一解所需的所有必要信息。任务是基于卷积定理，实现使用快速傅里叶变换（FFT）计算线性卷积这一成熟的数值方法。该问题是计算物理和信号处理中的一个标准练习。\n\n解决方案首先建立连接线性卷积、循环卷积和离散傅里叶变换（DFT）的理论原理。随后，基于这些原理设计一个算法，并针对一组给定的测试用例，通过与直接计算方法的对比来验证其实现。\n\n两个有限长度实值序列 $x[n]$（长度为 $N$）和 $h[n]$（长度为 $M$）的离散线性卷积 $y[k]$ 定义为：\n$$\ny[k] = (x * h)[k] = \\sum_{n=-\\infty}^{\\infty} x[n] h[k-n]\n$$\n对于因果序列，其中 $x[n]$ 仅在索引 $n \\in [0, N-1]$ 上非零，而 $h[n]$ 仅在索引 $n \\in [0, M-1]$ 上非零，此和仅在有限范围内非零。得到的序列 $y[k]$ 长度为 $L = N+M-1$，其索引 $k \\in [0, N+M-2]$。\n\n长度为 $L$ 的序列 $x[n]$ 的离散傅里叶变换（DFT）由下式给出：\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n] e^{-i 2\\pi nk/L} \\quad \\text{for } k \\in [0, L-1]\n$$\n其对应的离散傅里叶逆变换（IDFT）为：\n$$\nx[n] = \\frac{1}{L} \\sum_{k=0}^{L-1} X[k] e^{i 2\\pi nk/L} \\quad \\text{for } n \\in [0, L-1]\n$$\n快速傅里叶变换（FFT）是计算DFT的一种高效算法。\n\nDFT的卷积定理指出，两个长度为 $L$ 的序列的循环卷积可以通过对其DFT的逐元素乘积进行IDFT来计算：\n$$\n(x_L \\circledast h_L)[n] = \\text{IDFT}(\\text{DFT}(x_L) \\cdot \\text{DFT}(h_L))\n$$\n其中 $\\cdot$ 表示逐元素相乘。循环卷积与线性卷积不同。然而，如果首先将序列零填充到足够长的长度，则可以使用循环卷积正确计算长度为 $N$ 和 $M$ 的序列的线性卷积。\n\n为了避免时域混叠（即循环卷积的结果发生回卷并污染自身），我们必须将两个序列都用零填充到长度 $L \\ge N+M-1$。设 $x_{pad}$ 和 $h_{pad}$ 是序列 $x$ 和 $h$ 零填充到长度 $L$ 后的序列。$x_{pad}$ 和 $h_{pad}$ 的循环卷积将在数值上与原始序列 $x$ 和 $h$ 的线性卷积相同。\n\n这就得出了使用FFT计算线性卷积的以下算法：\n1.  给定长度为 $N$ 的输入序列 $x[n]$ 和长度为 $M$ 的输入序列 $h[n]$。\n2.  确定所需的最小填充长度：$L = N+M-1$。\n3.  创建两个新序列 $x_{pad}$ 和 $h_{pad}$，两者长度均为 $L$。这是通过在 $x[n]$ 后附加 $M-1$ 个零，并在 $h[n]$ 后附加 $N-1$ 个零来完成的。\n4.  使用FFT算法计算填充后序列的DFT：\n    $$\n    X_{pad}[k] = \\text{FFT}(x_{pad})\n    $$\n    $$\n    H_{pad}[k] = \\text{FFT}(h_{pad})\n    $$\n5.  在频域中逐元素相乘DFT：\n    $$\n    Y_{pad}[k] = X_{pad}[k] \\cdot H_{pad}[k]\n    $$\n6.  使用逆FFT（IFFT）算法计算乘积的逆DFT：\n    $$\n    y_{fft}[n] = \\text{IFFT}(Y_{pad}[k])\n    $$\n得到的序列 $y_{fft}[n]$ 是 $x[n]$ 和 $h[n]$ 的线性卷积。由于输入序列是实值的，卷积的理论结果也应是实数。由于有限精度算术，计算出的 $y_{fft}[n]$ 的虚部将非零，但应该可以忽略不计。我们取结果的实部 $\\text{Re}(y_{fft}[n])$ 作为最终答案。\n\n为了验证这种基于FFT的方法的数值精度，我们将其结果 $y_{FFT}$ 与使用直接时域卷积算法计算的参考结果 $y_{direct}$进行比较。误差通过所得序列所有元素的最大绝对差来量化：\n$$\ne = \\max_{k} | y_{FFT}[k] - y_{direct}[k] |\n$$\n对每个指定的测试用例都计算此误差 $e$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Computes linear convolution using FFT and validates against a direct method.\n    \"\"\"\n\n    def compute_convolution_fft(x, h):\n        \"\"\"\n        Computes the linear convolution of two 1D sequences using the FFT method.\n        \n        Args:\n            x (np.ndarray): The first sequence.\n            h (np.ndarray): The second sequence (kernel).\n        \n        Returns:\n            np.ndarray: The linear convolution of x and h.\n        \"\"\"\n        N = len(x)\n        M = len(h)\n        # 1. Determine padding length L >= N + M - 1.\n        L = N + M - 1\n\n        # 2. Zero-pad both sequences to length L.\n        x_pad = np.zeros(L)\n        x_pad[:N] = x\n        \n        h_pad = np.zeros(L)\n        h_pad[:M] = h\n\n        # 3. Compute DFTs using FFT.\n        X_pad = fft(x_pad)\n        H_pad = fft(h_pad)\n\n        # 4. Multiply pointwise in the frequency domain.\n        Y_pad = X_pad * H_pad\n\n        # 5. Compute inverse DFT using IFFT.\n        y_fft = ifft(Y_pad)\n\n        # The result must be real since inputs are real.\n        # The length of the result is L.\n        return np.real(y_fft)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A\n        (np.array([1.0, 2.0, 3.0]), np.array([0.0, 1.0, 0.5])),\n        # Test B\n        (np.array([1.0, 0.0, 0.0, 0.0]), np.array([-1.0, 2.0, -1.0])),\n        # Test C\n        (np.sin(2 * np.pi * np.arange(8) / 8.0), np.array([0.25, 0.5, 0.25])),\n        # Test D\n        (np.array([2.5]), np.array([-3.0, 4.0])),\n        # Test E\n        (np.array([-1.0, 2.0, -3.0, 4.0, -5.0]), np.array([0.5, -0.25, 0.125, -0.0625]))\n    ]\n\n    errors = []\n    for x_test, h_test in test_cases:\n        # Compute convolution using the implemented FFT method.\n        y_fft_result = compute_convolution_fft(x_test, h_test)\n        \n        # Compute reference convolution using a direct, trusted method.\n        # The 'full' mode computes the linear convolution of length N+M-1.\n        y_direct_result = np.convolve(x_test, h_test, mode='full')\n        \n        # Ensure both results have the same length for comparison.\n        L = len(x_test) + len(h_test) - 1\n        # The FFT-based result will have length L. The direct one will as well.\n        if len(y_fft_result) != L or len(y_direct_result) != L:\n            # This check is for robusteness but shouldn't fail with correct logic.\n            raise ValueError(\"Convolution result lengths do not match.\")\n\n        # Calculate the maximum absolute error.\n        max_abs_error = np.max(np.abs(y_fft_result - y_direct_result))\n        errors.append(max_abs_error)\n\n    # Format the results according to the specification.\n    # The \"{:.12g}\" format specifier ensures at most 12 significant digits.\n    formatted_errors = [f\"{err:.12g}\" for err in errors]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_errors)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "卷积的一个基本数学性质是交换律，即 $f * g = g * f$。虽然这在理论上是成立的，但在有限精度的计算机上，运算的顺序可能会影响最终结果。本练习将引导你设计一个数值实验，通过直接实现卷积的定义来检验其交换律在浮点运算下的表现 。这个过程将加深你对数值稳定性和计算机算术局限性的理解。",
            "id": "2419015",
            "problem": "要求您设计并实现一个数值实验，该实验从两个有限序列离散卷积的基本定义出发，并用它来在计算中评估卷积的交换律。请完全在纯数学和数值分析的框架下进行；不涉及任何物理单位。\n\n给定两个有限序列 $f = \\{f_0, f_1, \\dots, f_{N-1}\\}$ 和 $g = \\{g_0, g_1, \\dots, g_{M-1}\\}$。$f$ 和 $g$ 的离散线性卷积，记作 $(f * g)$，对每个整数索引 $n$ 定义如下\n$$(f * g)[n] \\equiv \\sum_{k=-\\infty}^{\\infty} f[k]\\, g[n - k],$$\n我们约定，当 $k  0$ 或 $k \\ge N$ 时，$f[k] = 0$；当 $k  0$ 或 $k \\ge M$ 时，$g[k] = 0$。因此，$(f * g)[n]$ 仅在 $n \\in \\{0, 1, \\dots, N + M - 2\\}$ 时非零。\n\n您的任务是：\n\n1) 从上述定义出发（不允许使用变换域或谱方法），实现一个确定性算法，用于计算任意有限实值序列 $f$ 和 $g$ 的 $(f * g)$。该算法必须在每个输出索引 $n$ 处，按照求和索引固定的递增顺序，显式地执行有限求和 $\\sum_{k} f[k]\\, g[n - k]$。不得调用任何内置的卷积例程或任何隐式使用卷积定理的函数。\n\n2) 使用相同的算法计算 $(g * f)$，并在 IEEE $754$ 双精度浮点运算下，定量比较 $(f * g)$ 与 $(g * f)$。为任意一对计算输出 $y_{fg}$ 和 $y_{gf}$ 定义以下诊断指标：\n$$\\Delta_\\infty \\equiv \\frac{\\max_n \\left| y_{fg}[n] - y_{gf}[n] \\right|}{\\max\\left(1, \\max_n |y_{fg}[n]|, \\max_n |y_{gf}[n]|\\right)}.$$\n这是无穷范数下的相对误差，分母中设置了下限 $1$，以避免除以极小的数。\n\n3) 针对以下三个精心选择的、共同构成一个测试套件的测试用例，评估 $\\Delta_\\infty$。每个序列项都必须作为双精度实数处理。\n\n- 测试用例 A（范围内的精确算术体系）：$f_A = [\\,1, 2, 3, 4\\,]$, $g_A = [\\,5, 6, 7\\,]$。对于这些整数值，所有中间乘积和总和都保持在 $2^{53}$ 以下，因此这些整数的加法和乘法在双精度下可以精确表示。此用例旨在探究交换律应在机器精度下成立的体系。\n\n- 测试用例 B（平滑、良态信号）：令 $N = 64$，定义网格 $x_n = -3 + 6\\, n/(N - 1)$，其中 $n \\in \\{0, 1, \\dots, N - 1\\}$，并设置 $f_B[n] = \\exp\\!\\left(-\\tfrac{1}{2} x_n^2\\right)$。令 $g_B$ 为一个长度为 $9$ 的归一化盒状函数（boxcar），即当 $m \\in \\{0, 1, \\dots, 8\\}$ 时，$g_B[m] = 1/9$。此用例旨在探究典型的“理想路径”下的数值行为。\n\n- 测试用例 C（病态动态范围）：按如下方式独立生成 $f_C$ 和 $g_C$。令 $N = 256$ 且 $M = 257$。对于 $f_C$，从 $[-100, 100]$ 中均匀抽取 $N$ 个独立的指数 $e_k$，并以相等的概率抽取独立的符号 $s_k \\in \\{-1, +1\\}$，然后设置 $f_C[k] = s_k \\cdot 10^{e_k}$。对于 $g_C$，按照相同规则抽取 $M$ 个独立的指数和符号，并设置 $g_C[m] = s_m \\cdot 10^{e_m}$。使用固定的随机种子以确保序列是可复现的。此用例旨在探究在存在极大和极小数量级的情况下浮点数的非结合性。\n\n4) 对三个测试用例中的每一个，计算如上定义的 $\\Delta_\\infty$。您的程序必须生成单行输出，其中包含三个结果，格式为方括号括起来的逗号分隔列表，并采用科学记数法，小数点后恰好有 $12$ 位数字（例如，$[1.234567890123e-04,5.000000000000e-01,3.210000000000e-16]$）。三个输出必须按 A、B、C 的顺序排列，且必须是浮点数。\n\n注意：\n\n- 对于每个输出样本 $n$，您必须按索引递增的顺序实现求和，以便明确定义有限加法的顺序。不要按数量级重新排序项或使用补偿求和。\n- 您不得调用任何为您计算卷积的函数。您可以使用基本的数组操作来访问元素，并使用循环来执行求和。\n- 不要依赖快速傅里叶变换（FFT; Fast Fourier Transform）的任何属性，因为本任务不允许使用频域方法。",
            "solution": "该问题要求设计并实现一个数值实验，以评估离散卷积在有限精度浮点运算下的交换律。分析需要从离散线性卷积的基本定义开始，而不借助诸如快速傅里叶变换（FFT）等变换域方法。\n\n两个有限序列 $f = \\{f_0, f_1, \\dots, f_{N-1}\\}$ 和 $g = \\{g_0, g_1, \\dots, g_{M-1}\\}$ 的离散线性卷积是一个序列 $h = (f * g)$，其第 $n$ 项由下式给出\n$$h[n] = (f * g)[n] \\equiv \\sum_{k=-\\infty}^{\\infty} f[k]\\, g[n - k].$$\n鉴于序列 $f$ 和 $g$ 具有有限支撑集，即当 $k \\notin [0, N-1]$ 时 $f[k] = 0$，当 $m \\notin [0, M-1]$ 时 $g[m] = 0$，因此求和仅在有限的索引 $k$ 范围内非零。对于给定的输出索引 $n$，项 $f[k]g[n-k]$ 可能非零的条件是 $k \\in [0, N-1]$ 和 $n-k \\in [0, M-1]$ 同时成立。第二个条件等价于 $n - (M-1) \\le k \\le n$。结合这些约束，求和索引 $k$ 必须落在以下范围内\n$$ \\max(0, n - M + 1) \\le k \\le \\min(n, N-1). $$\n得到的卷积序列 $h$ 的长度为 $N + M - 1$，索引 $n$ 的范围从 $0$ 到 $N + M - 2$。\n\n第一个任务是构建一个确定性算法，通过显式地计算总和来为每个 $n$ 计算 $h[n]$，其中求和索引 $k$ 严格递增。该算法过程如下：\n1. 初始化一个长度为 $L = N + M - 1$ 的结果数组 $h$，并用零填充。所有计算都将使用 IEEE $754$ 双精度浮点数。\n2. 遍历每个输出索引 $n$，从 $0$ 到 $L-1$。\n3. 对于每个 $n$，计算求和索引 $k$ 的范围为 $k_{\\text{start}} = \\max(0, n - M + 1)$ 和 $k_{\\text{end}} = \\min(n, N-1)$。\n4. 初始化一个临时求和变量 $S_n = 0.0$。\n5. 按递增顺序从 $k_{\\text{start}}$ 到 $k_{\\text{end}}$ 迭代 $k$。在每一步中，计算乘积 $f[k] \\cdot g[n-k]$ 并将其加到 $S_n$ 上。这强制执行了指定的求和顺序。\n6. 内层循环完成后，赋值 $h[n] = S_n$。\n此过程直接按要求实现了卷积定义。\n\n第二个任务是研究交换律性质，即 $(f * g) = (g * f)$。在精确算术中，此性质成立。然而，浮点运算不具有结合律，即 $(a+b)+c$ 不一定等于 $a+(b+c)$。由于 $(f * g)$ 和 $(g * f)$ 的计算涉及对同一组乘积项以不同顺序求和，它们的数值结果可能会有所不同。\n\n令 $y_{fg}$ 为使用上述算法计算 $(f * g)$ 的结果，令 $y_{gf}$ 为计算 $(g * f)$ 的结果。为了量化差异，我们使用指定的诊断指标，即无穷范数下的相对误差：\n$$ \\Delta_\\infty \\equiv \\frac{\\max_n \\left| y_{fg}[n] - y_{gf}[n] \\right|}{\\max\\left(1, \\max_n |y_{fg}[n]|, \\max_n |y_{gf}[n]|\\right)}. $$\n分母的下限设为 $1$，以保持数值稳定性，并为误差提供一个合理的尺度，特别是当卷积后信号的最大振幅小于 $1$ 或恒为零时。\n\n第三和第四个任务涉及将此分析应用于三个测试用例。\n\n测试用例 A：$f_A = [\\,1, 2, 3, 4\\,]$ 和 $g_A = [\\,5, 6, 7\\,]$。所有输入都是小整数。中间乘积（例如 $4 \\times 7 = 28$）和最终和（例如 $(f_A * g_A)[3] = 52$）也都是足够小的整数，可以由 `float64` 的尾数精确表示（`float64` 可以表示所有直到 $2^{53}$ 的整数）。由于所有算术运算都是精确的，浮点加法的非结合性不会显现。因此，我们预测 $y_{fg}$ 和 $y_{gf}$ 将是逐比特相同的，从而得出 $\\Delta_\\infty = 0$。\n\n测试用例 B：$f_B$ 是一个采样的高斯函数，是一种平滑且行为良好的信号。$g_B$ 是一个归一化的盒状函数。这代表了信号处理中的一个常见场景，例如应用移动平均滤波器。$f_B$ 的分量都是正数且数量级相似。以不同顺序对这些值求和（如 $(f*g)$ 与 $(g*f)$ 的情况），会因浮点舍入而引入差异。对于双精度，预期的误差应在机器ε的数量级上，约为 $2.22 \\times 10^{-16}$。\n\n测试用例 C：序列 $f_C$ 和 $g_C$ 由其元素构成，这些元素的数量级是从对数尺度上的均匀分布中抽取的，跨越了许多数量级（大约从 $10^{-100}$ 到 $10^{100}$）。这为求和操作创建了一个病态问题。当对数量级差异巨大的数字求和时，灾难性抵消和吸收错误会变得非常突出。例如，如果 $A$ 非常大而 $b$ 非常小，$A+b$ 的计算结果可能就是 $A$。求和的顺序变得至关重要。由于 $(f * g)$ 和 $(g * f)$ 会对相同的乘积以不同的顺序求和，预期最终结果会有显著差异。预计会得到一个相当大的 $\\Delta_\\infty$ 值。为确保可复现性，必须为随机数生成器使用固定的种子。我们选择种子为 $0$。\n\n实现将严格遵循这些原则，生成序列，通过直接求和算法执行卷积，并为每种情况计算 $\\Delta_\\infty$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical convolution problem by direct implementation and assesses commutativity.\n    \"\"\"\n\n    def convolve_direct(f: np.ndarray, g: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the discrete linear convolution of two 1D sequences f and g\n        using direct summation as per the definition.\n\n        Args:\n            f: The first sequence, a 1D NumPy array of float64.\n            g: The second sequence, a 1D NumPy array of float64.\n\n        Returns:\n            The convolved sequence, a 1D NumPy array of float64.\n        \"\"\"\n        N = len(f)\n        M = len(g)\n        if N == 0 or M == 0:\n            return np.array([], dtype=np.float64)\n            \n        L = N + M - 1\n        h = np.zeros(L, dtype=np.float64)\n\n        for n in range(L):\n            s = 0.0\n            k_start = max(0, n - M + 1)\n            k_end = min(n, N - 1)\n            for k in range(k_start, k_end + 1):\n                s += f[k] * g[n - k]\n            h[n] = s\n        return h\n\n    def calculate_delta_inf(y_fg: np.ndarray, y_gf: np.ndarray) - float:\n        \"\"\"\n        Calculates the relative error in the infinity norm between two sequences.\n\n        Args:\n            y_fg: The result of (f * g).\n            y_gf: The result of (g * f).\n\n        Returns:\n            The diagnostic value Delta_infinity.\n        \"\"\"\n        if y_fg.size == 0 and y_gf.size == 0:\n            return 0.0\n\n        max_abs_diff = np.max(np.abs(y_fg - y_gf))\n        \n        norm_fg = np.max(np.abs(y_fg)) if y_fg.size  0 else 0.0\n        norm_gf = np.max(np.abs(y_gf)) if y_gf.size  0 else 0.0\n\n        denominator = max(1.0, norm_fg, norm_gf)\n        \n        return max_abs_diff / denominator\n\n    results = []\n\n    # Test Case A: Exact integer arithmetic regime\n    f_A = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float64)\n    g_A = np.array([5.0, 6.0, 7.0], dtype=np.float64)\n    \n    y_fg_A = convolve_direct(f_A, g_A)\n    y_gf_A = convolve_direct(g_A, f_A)\n    delta_A = calculate_delta_inf(y_fg_A, y_gf_A)\n    results.append(delta_A)\n\n    # Test Case B: Smooth, well-conditioned signals\n    N_B = 64\n    x_n = -3.0 + 6.0 * np.arange(N_B) / (N_B - 1)\n    f_B = np.exp(-0.5 * x_n**2, dtype=np.float64)\n    g_B = np.full(9, 1.0/9.0, dtype=np.float64)\n    \n    y_fg_B = convolve_direct(f_B, g_B)\n    y_gf_B = convolve_direct(g_B, f_B)\n    delta_B = calculate_delta_inf(y_fg_B, y_gf_B)\n    results.append(delta_B)\n\n    # Test Case C: Ill-conditioned dynamic range\n    np.random.seed(0) # For reproducibility\n    N_C = 256\n    M_C = 257\n    \n    # Generate f_C\n    exponents_f = np.random.uniform(-100, 100, N_C)\n    signs_f = np.random.choice([-1.0, 1.0], N_C)\n    f_C = signs_f * (10.0**exponents_f)\n    f_C = f_C.astype(np.float64)\n\n    # Generate g_C\n    exponents_g = np.random.uniform(-100, 100, M_C)\n    signs_g = np.random.choice([-1.0, 1.0], M_C)\n    g_C = signs_g * (10.0**exponents_g)\n    g_C = g_C.astype(np.float64)\n\n    y_fg_C = convolve_direct(f_C, g_C)\n    y_gf_C = convolve_direct(g_C, f_C)\n    delta_C = calculate_delta_inf(y_fg_C, y_gf_C)\n    results.append(delta_C)\n\n    # Format and print the final output\n    output_str = \",\".join([f\"{r:.12e}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "去卷积是卷积的逆过程，旨在从模糊的观测数据中恢复原始信号，但这是一个典型的“不适定”问题（ill-posed problem），对噪声非常敏感。本练习将介绍吉洪诺夫正则化（Tikhonov regularization），这是一种稳定去卷积过程的强大技术 。你将亲手实现一个稳定的去卷积算法，以处理被噪声污染的模糊信号，并学习如何通过选择合适的正则化参数 $\\lambda$ 来平衡解的保真度和光滑性。",
            "id": "2419120",
            "problem": "要求您实现一个完整的、确定性的程序，使用吉洪诺夫正则化（Tikhonov regularization）对被加性白噪声破坏的一维信号进行稳定反卷积。实现必须从离散卷积和离散傅里叶变换（DFT）的基本定义出发，并应用卷积定理来推导算法。您的程序必须评估一个固定的测试套件，并输出包含数值结果的单行格式化字符串。\n\n本任务的基础是：\n- 长度为 $N$ 的信号的离散循环卷积，定义为 $$(h \\circledast x)[n] = \\sum_{m=0}^{N-1} h[m]\\, x[(n-m) \\bmod N].$$\n- 离散傅里叶变换（DFT）及其逆变换，\n$$X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn/N}.$$\n- 卷积定理，它指出对于循环卷积，$$\\mathcal{F}\\{h \\circledast x\\}[k] = H[k]\\, X[k],$$\n其中 $\\mathcal{F}$ 表示DFT，而 $H[k], X[k]$ 分别是 $h[n]$ 和 $x[n]$ 的DFT。\n- 用于反卷积的吉洪诺夫正则化最小二乘目标函数（零阶，以单位矩阵作为正则化算子）由下式给出\n$$J(x) = \\lVert h \\circledast x - y \\rVert_2^2 + \\lambda \\lVert x \\rVert_2^2,$$\n其中 $y[n]$ 是观测到的含噪声的模糊信号，$\\lambda \\ge 0$ 是正则化参数，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n\n您的实现必须：\n1. 对前向建模（生成观测信号）和反卷积都使用长度为 $N$ 的循环卷积。\n2. 采用基于DFT的逐点解法求解吉洪诺夫正则化正规方程，以计算反卷积估计值 $\\hat{x}[n]$：\n   - 在DFT域中操作。对每个DFT频点 $k$，计算\n     $$\\hat{X}[k] = \\frac{H^*[k]}{|H[k]|^2 + \\lambda}\\, Y[k],$$\n     其中 $H^*[k]$ 是 $H[k]$ 的复共轭， $|H[k]|^2 = H^*[k] H[k]$，而 $Y[k]$ 是 $y[n]$ 的DFT。然后应用逆DFT以获得 $\\hat{x}[n]$。\n   - 对于特殊情况 $\\lambda = 0$，通过将分母 $|H[k]|^2$ 替换为 $|H[k]|^2 + \\varepsilon$（其中 $\\varepsilon = 10^{-12}$ 是一个固定值）来处理数值稳定性问题，以避免除以零。\n3. 在时域中生成具有零均值和指定标准差的加性高斯白噪声。使用固定的随机种子以保证可复现性。\n4. 对每个测试用例，评估一个固定的候选正则化参数列表 $\\lambda \\in \\{0, 10^{-8}, 10^{-6}, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}\\}$，并选择使反卷积估计值与已知的真实信号之间的均方根误差（RMSE）最小的 $\\lambda$ 值。RMSE定义为\n   $$\\mathrm{RMSE}(\\hat{x}, x) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{x}[n] - x[n]\\right)^2}.$$\n5. 对每个测试用例，还要计算与上述 $\\varepsilon$ 保护措施下的 $\\lambda=0$ 情况对应的朴素逆滤波器的RMSE。\n\n角度单位要求：所有三角函数必须接受弧度制角度。本问题不涉及物理单位。\n\n测试套件规范：\n- 共享参数：\n  - 信号长度 $N = 512$。\n  - 所有地方均使用长度为 $N$ 的循环卷积。\n  - 随机数生成器种子必须在开始时设置为 $12345$ 一次。\n  - 候选正则化参数：上面第4项中列出的七个值。\n  - 对于所有核，通过将其非零样本放置在数组的开头并补零至长度 $N$，将其表示为长度为 $N$ 的序列。\n\n- 测试用例1（中度高斯模糊，复合平滑信号）：\n  - 真实信号 $x_1[n]$ 对于 $n = 0,1,\\dots,N-1$：\n    $$x_1[n] = \\exp\\!\\left(-\\frac{(n-100)^2}{2\\cdot 8^2}\\right) + 0.6\\, \\exp\\!\\left(-\\frac{(n-300)^2}{2\\cdot 12^2}\\right) + 0.1\\, \\sin\\!\\left(2\\pi \\cdot 0.05 \\cdot n\\right).$$\n    正弦函数的参数以弧度为单位。\n  - 模糊核 $h_1[n]$ 是一个标准差为 $\\sigma_k = 2.0$ 个样本的离散高斯函数，在整数索引处采样并归一化使其总和为1。取 $m \\in \\{-\\lceil 6\\sigma_k \\rceil,\\dots,\\lceil 6\\sigma_k \\rceil\\}$ 上的对称抽头（taps），即包含足够的支撑来近似高斯函数，然后按 $m$ 的递增顺序将这些抽头放置在长度为 $N$ 的数组的开头，其余部分补零。\n  - 加性高斯白噪声标准差：$\\sigma_{\\text{noise}} = 0.02$。\n  - 观测数据：$y_1 = h_1 \\circledast x_1 + \\eta$，其中 $\\eta$ 是噪声序列。\n\n- 测试用例2（均匀运动模糊，阶跃状信号）：\n  - 真实信号 $x_2[n]$：\n    $$x_2[n] = \\begin{cases}1,  120 \\le n  220\\\\ 0,  \\text{otherwise}\\end{cases} + 0.1\\, \\sin\\!\\left(2\\pi \\cdot 0.03 \\cdot n\\right).$$\n  - 模糊核 $h_2[n]$ 是一个长度为 $L = 21$ 个样本的均匀盒状函数（boxcar），在其支撑域上的值为 $1/L$，其余地方为零，然后如上所述补零至长度 $N$。\n  - 加性高斯白噪声标准差：$\\sigma_{\\text{noise}} = 0.03$。\n  - 观测数据：$y_2 = h_2 \\circledast x_2 + \\eta$。\n\n- 测试用例3（单位核边界情况，带有背景的稀疏脉冲）：\n  - 真实信号 $x_3[n]$：\n    $$x_3[n] = 1.0\\cdot \\delta[n-50] + 0.7\\cdot \\delta[n-200] + 1.2\\cdot \\delta[n-350] + 0.05\\, \\exp\\!\\left(-\\frac{(n-256)^2}{2\\cdot 20^2}\\right),$$\n    其中 $\\delta[\\cdot]$ 是整数索引上的克罗内克（Kronecker）delta函数。\n  - 模糊核 $h_3[n]$ 是单位核（离散delta函数），其中 $h_3[0]=1$ 且对于 $n\\neq 0$ 有 $h_3[n]=0$。\n  - 加性高斯白噪声标准差：$\\sigma_{\\text{noise}} = 0.02$。\n  - 观测数据：$y_3 = h_3 \\circledast x_3 + \\eta$。\n\n所需输出：\n- 对于每个测试用例 $j \\in \\{1,2,3\\}$，计算：\n  1. 候选集中的 $\\lambda^{\\star}_j$ 值，该值使得吉洪诺夫反卷积估计值与真实信号之间的RMSE最小。\n  2. 在 $\\lambda^{\\star}_j$ 处达到的最小RMSE $\\mathrm{RMSE}_{\\min, j}$。\n  3. 由带有 $\\varepsilon$ 保护措施的 $\\lambda=0$ 情况定义的朴素逆滤波器的RMSE $\\mathrm{RMSE}_{\\text{naive}, j}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  $$[\\lambda^{\\star}_1, \\mathrm{RMSE}_{\\min,1}, \\mathrm{RMSE}_{\\text{naive},1}, \\lambda^{\\star}_2, \\mathrm{RMSE}_{\\min,2}, \\mathrm{RMSE}_{\\text{naive},2}, \\lambda^{\\star}_3, \\mathrm{RMSE}_{\\min,3}, \\mathrm{RMSE}_{\\text{naive},3}],$$\n  其中所有条目都打印为浮点数。不应打印任何额外文本。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。这是一个在计算物理领域，特别是在信号处理和逆问题领域的适定、科学上合理且自洽的问题。所有常数、函数和过程的定义都具有足够的清晰度和精确度，足以得出一个唯一的、确定性的解。因此，我们将着手推导和实现所需的算法。\n\n问题的核心是从一个退化的观测信号 $y[n]$ 中恢复原始信号 $x[n]$。该退化过程被建模为 $x[n]$ 与一个已知的模糊核 $h[n]$ 的循环卷积，并被加性高斯白噪声 $\\eta[n]$ 进一步破坏。因此，模型为 $y = h \\circledast x + \\eta$。一种通过在频域中对卷积进行求逆来求解 $x$ 的朴素尝试，即 $\\hat{X}[k] = Y[k]/H[k]$，是出了名的不稳定，因为模糊核的离散傅里叶变换（DFT）$H[k]$ 通常有接近于零的值。这会放大 $Y[k]$ 相应频率分量中的噪声。\n\n为了解决这种不稳定性，我们采用吉洪诺夫正则化。其目标是找到一个信号估计值 $\\hat{x}$，使正则化的最小二乘目标函数最小化：\n$$\nJ(x) = \\lVert h \\circledast x - y \\rVert_2^2 + \\lambda \\lVert x \\rVert_2^2\n$$\n在这里，$\\lambda \\ge 0$ 是正则化参数，它控制着对数据的保真度（第一项）与解的平滑度或大小（第二项）之间的权衡。通过利用卷积定理和帕塞瓦尔定理（Parseval's theorem），这个最小化过程可以在频域中高效执行。目标函数变成了对 $x[n]$ 的DFT的每个频率分量 $X[k]$ 的独立最小化问题的总和：\n$$\nJ(X) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( |H[k]X[k] - Y[k]|^2 + \\lambda|X[k]|^2 \\right)\n$$\n通过将关于 $X[k]$ 的梯度设置为零来求解最优的 $X[k]$，可以得到吉洪诺夫正则化反卷积滤波器：\n$$\n\\hat{X}[k] = \\frac{H^*[k] Y[k]}{|H[k]|^2 + \\lambda}\n$$\n其中 $H^*[k]$ 是 $H[k]$ 的复共轭。然后，通过对 $\\hat{X}[k]$ 应用逆DFT，可以恢复时域中的估计信号 $\\hat{x}[n]$。\n\n实现将按以下步骤进行：\n\n1.  **系统设置**：我们定义共享参数：信号长度 $N=512$，候选正则化参数列表 $\\lambda \\in \\{0, 10^{-8}, 10^{-6}, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}\\}$，以及一个用于在 $\\lambda=0$ 情况下保持数值稳定性的小常数 $\\varepsilon = 10^{-12}$。为了可复现性，随机数生成器使用种子 $12345$ 进行初始化。\n\n2.  **测试用例生成**：对于三个测试用例中的每一个，我们将根据其指定的数学定义，以编程方式生成长度为 $N$ 的数组，分别作为真实信号 $x[n]$ 和模糊核 $h[n]$。\n    - 对于高斯核 $h_1[n]$，我们首先计算在整数索引 $m$ 范围 $[-\\lceil 6\\sigma_k \\rceil, \\lceil 6\\sigma_k \\rceil]$ 内（其中 $\\sigma_k = 2.0$）的未归一化抽头。然后将这些抽头归一化，使其总和为1。将得到的抽头序列放置在长度为 $N$ 的核数组的开头。\n    - 对于盒状核 $h_2[n]$，创建一个长度为 $L=21$ 的数组，用值 $1/21$ 填充，并将其放置在长度为 $N$ 的核数组的开头。\n    - 单位核 $h_3[n]$ 是一个离散delta函数，其中 $h_3[0]=1$ 且所有其他元素为零。\n\n3.  **前向模型仿真**：为每个测试用例仿真观测信号 $y[n]$。\n    - 使用DFT通过卷积定理高效计算循环卷积 $h \\circledast x$：$h \\circledast x = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{h\\} \\cdot \\mathcal{F}\\{x\\}\\}$。\n    - 生成一个均值为零、标准差为指定值 $\\sigma_{\\text{noise}}$ 的加性高斯白噪声序列 $\\eta[n]$。\n    - 最终的观测信号为 $y[n] = (h \\circledast x)[n] + \\eta[n]$。\n\n4.  **反卷积与参数选择**：对每个测试用例，我们执行以下步骤：\n    - 我们计算观测信号 $y[n]$ 和核 $h[n]$ 的DFT，得到 $Y[k]$ 和 $H[k]$。\n    - 我们遍历 $\\lambda$ 的每个候选值。对于每个 $\\lambda$，我们使用吉洪诺夫滤波器公式计算估计信号的DFT $\\hat{X}[k]$。对于 $\\lambda=0$ 的情况，分母 $|H[k]|^2$ 按规定被替换为 $|H[k]|^2 + \\varepsilon$。\n    - 通过对 $\\hat{X}[k]$ 进行逆DFT获得估计信号 $\\hat{x}[n]$。我们取结果的实部，以舍弃由数值精度误差引起的可以忽略的虚部。\n    - 估计信号 $\\hat{x}[n]$ 和真实信号 $x[n]$ 之间的均方根误差（RMSE）计算公式为 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} (\\hat{x}[n] - x[n])^2}$。\n    - 产生最小RMSE的 $\\lambda$ 值被确定为最优参数 $\\lambda^\\star$。相应的最小RMSE，$\\mathrm{RMSE}_{\\min}$，被记录下来。此外，朴素逆滤波器（$\\lambda=0$ 的情况）的RMSE，$\\mathrm{RMSE}_{\\text{naive}}$，也被存储。\n\n5.  **输出格式化**：将得到的九个数值（$\\lambda^\\star_j, \\mathrm{RMSE}_{\\min,j}, \\mathrm{RMSE}_{\\text{naive},j}$ 对于 $j=1,2,3$）收集起来，并按要求格式化为单行字符串。\n\n这种结构化的方法确保了解决方案是对问题陈述中概述的原理和规范的直接且正确的实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the deconvolution test suite.\n    \"\"\"\n    # Shared parameters\n    N = 512\n    lambda_candidates = [0.0, 1e-8, 1e-6, 1e-4, 1e-3, 1e-2, 1e-1]\n    epsilon = 1e-12\n    rng = np.random.default_rng(12345)\n\n    # --- Test Case 1 ---\n    # True signal x1\n    n = np.arange(N)\n    x1 = (np.exp(-(n - 100)**2 / (2 * 8**2)) +\n          0.6 * np.exp(-(n - 300)**2 / (2 * 12**2)) +\n          0.1 * np.sin(2 * np.pi * 0.05 * n))\n\n    # Blur kernel h1\n    sigma_k = 2.0\n    support_half_width = int(np.ceil(6 * sigma_k))\n    m = np.arange(-support_half_width, support_half_width + 1)\n    h1_taps = np.exp(-m**2 / (2 * sigma_k**2))\n    h1_taps /= np.sum(h1_taps)\n    h1 = np.zeros(N)\n    h1[0:len(h1_taps)] = h1_taps\n    \n    # Noise and observation y1\n    noise_std1 = 0.02\n    \n    # --- Test Case 2 ---\n    # True signal x2\n    x2 = np.zeros(N)\n    x2[120:220] = 1.0\n    x2 += 0.1 * np.sin(2 * np.pi * 0.03 * n)\n\n    # Blur kernel h2\n    L = 21\n    h2 = np.zeros(N)\n    h2[0:L] = 1.0 / L\n\n    # Noise and observation y2\n    noise_std2 = 0.03\n\n    # --- Test Case 3 ---\n    # True signal x3\n    x3 = np.zeros(N)\n    x3[50] = 1.0\n    x3[200] = 0.7\n    x3[350] = 1.2\n    x3 += 0.05 * np.exp(-(n - 256)**2 / (2 * 20**2))\n    \n    # Blur kernel h3\n    h3 = np.zeros(N)\n    h3[0] = 1.0\n    \n    # Noise and observation y3\n    noise_std3 = 0.02\n\n    test_cases = [\n        (x1, h1, noise_std1),\n        (x2, h2, noise_std2),\n        (x3, h3, noise_std3),\n    ]\n\n    results = []\n    for x_true, h, noise_std in test_cases:\n        # Generate observed signal y = h * x + noise\n        noise = rng.normal(loc=0.0, scale=noise_std, size=N)\n        y = np.real(np.fft.ifft(np.fft.fft(h) * np.fft.fft(x_true))) + noise\n\n        # Pre-compute DFTs\n        Y = np.fft.fft(y)\n        H = np.fft.fft(h)\n        H_conj = np.conj(H)\n        H_mag_sq = np.abs(H)**2\n\n        min_rmse = float('inf')\n        best_lambda = -1.0\n        naive_rmse = -1.0\n\n        for lam in lambda_candidates:\n            # Apply Tikhonov filter in frequency domain\n            if lam == 0:\n                denominator = H_mag_sq + epsilon\n            else:\n                denominator = H_mag_sq + lam\n            \n            X_hat = (H_conj * Y) / denominator\n            \n            # Inverse FFT to get signal estimate\n            x_hat = np.real(np.fft.ifft(X_hat))\n            \n            # Calculate RMSE\n            current_rmse = np.sqrt(np.mean((x_hat - x_true)**2))\n            \n            if lam == 0:\n                naive_rmse = current_rmse\n            \n            if current_rmse  min_rmse:\n                min_rmse = current_rmse\n                best_lambda = lam\n        \n        results.extend([best_lambda, min_rmse, naive_rmse])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}