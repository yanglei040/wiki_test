{
    "hands_on_practices": [
        {
            "introduction": "要掌握打靶法，最好的起点是将其应用于一个可以清晰追踪每一步计算的物理问题。这个练习将引导你解决一个关于散热片稳态温度分布的线性边值问题。你将学习如何将边值问题转化为一个由初始斜率（“发射角度”）参数化的初值问题，并手动执行一步割线法来迭代逼近正确的初始条件，从而直观地理解打靶法与求根算法的结合。",
            "id": "2220751",
            "problem": "一根长度为 $L=2.0$ 米的一维散热片附着在热表面上，用于向周围环境散热。沿散热片长度的稳态温度分布 $T(x)$ 由以下二阶常微分方程决定：\n$$ T''(x) = \\gamma (T(x) - T_{env}) $$\n其中 $x$ 是距离散热片底部的距离，单位为米。物理参数如下：\n-   传热系数：$\\gamma = 0.09 \\text{ m}^{-2}$\n-   环境温度：$T_{env} = 20.0$ °C\n\n散热片底部的温度是固定的，其尖端的温度也是已知的。这些边界条件是：\n-   底部温度：$T(0) = 150.0$ °C\n-   尖端温度：$T(2.0) = 50.0$ °C\n\n您的任务是应用打靶法（shooting method）来寻找初始温度梯度 $s = T'(0)$ 的一个更好的近似值。您将使用割线法（secant method）作为求根算法。给定梯度的两个初始猜测值，$s_0 = -10.0$ °C/m 和 $s_1 = -30.0$ °C/m，计算下一个近似值 $s_2$。\n\n为了找到在给定初始梯度下散热片末端的温度，您应该使用由此产生的初值问题的解析解。\n\n以 °C/m 为单位表示您的最终答案。将您的答案四舍五入到三位有效数字。",
            "solution": "我们通过标准的打靶法将边值问题简化为初值问题。定义超温 $\\theta(x) = T(x) - T_{env}$。控制方程和初始条件变为\n$$\n\\theta''(x) = \\gamma\\,\\theta(x), \\quad \\theta(0) = T(0) - T_{env}, \\quad \\theta'(0) = s,\n$$\n其中 $\\gamma>0$。令 $\\lambda = \\sqrt{\\gamma}$。通解为\n$$\n\\theta(x) = C \\cosh(\\lambda x) + D \\sinh(\\lambda x).\n$$\n应用 $x=0$ 处的初始条件，得到 $C = \\theta(0) = T(0) - T_{env}$ 且 $\\theta'(x) = \\lambda\\big(C \\sinh(\\lambda x) + D \\cosh(\\lambda x)\\big)$，所以 $\\theta'(0) = \\lambda D = s$，因此 $D = \\frac{s}{\\lambda}$。所以，\n$$\nT(x;s) = T_{env} + \\theta(x) = T_{env} + \\big(T(0) - T_{env}\\big)\\cosh(\\lambda x) + \\frac{s}{\\lambda}\\sinh(\\lambda x).\n$$\n在 $x=L$ 处，尖端边界条件的残差为\n$$\nf(s) = T(L;s) - T(L) = \\big[T_{env} + \\big(T(0) - T_{env}\\big)\\cosh(\\lambda L) + \\tfrac{s}{\\lambda}\\sinh(\\lambda L)\\big] - T(L).\n$$\n根据给定数据 $L=2.0$，$\\gamma=0.09$，$T_{env}=20.0$，$T(0)=150.0$，$T(L)=50.0$，我们有 $\\lambda=\\sqrt{\\gamma}=0.3$ 以及\n$$\nf(s) = -30 + 130\\,\\cosh(0.6) + \\frac{s}{0.3}\\,\\sinh(0.6).\n$$\n使用 $\\cosh(0.6) = \\frac{\\exp(0.6)+\\exp(-0.6)}{2} \\approx 1.185465218242$ 和 $\\sinh(0.6) = \\frac{\\exp(0.6)-\\exp(-0.6)}{2} \\approx 0.636653582148$，这可以简化为线性形式\n$$\nf(s) \\approx 124.11047837146 + 2.12217860716\\,s.\n$$\n在给定的猜测值 $s_{0}=-10.0$ 和 $s_{1}=-30.0$ 处进行计算：\n$$\nf(s_{0}) \\approx 124.11047837146 + 2.12217860716(-10.0) = 102.88869229986,\n$$\n$$\nf(s_{1}) \\approx 124.11047837146 + 2.12217860716(-30.0) = 60.44512015666.\n$$\n应用割线法计算下一次迭代：\n$$\ns_{2} = s_{1} - f(s_{1})\\,\\frac{s_{1}-s_{0}}{f(s_{1}) - f(s_{0})}\n= -30.0 - 60.44512015666\\,\\frac{-20.0}{60.44512015666 - 102.88869229986}.\n$$\n计算分母 $60.44512015666 - 102.88869229986 = -42.44357214320$，所以\n$$\ns_{2} \\approx -30.0 - \\frac{-1208.9024031332}{-42.44357214320} \\approx -58.4825791536.\n$$\n因为 $f(s)$ 是关于 $s$ 的线性函数，所以这一步割线法得到了打靶残差的精确根。四舍五入到三位有效数字，得到 $-58.5$，单位符合要求。",
            "answer": "$$\\boxed{-58.5}$$"
        },
        {
            "introduction": "现实世界中的许多物理系统本质上是非线性的，这使得我们无法解析地求解相应的初值问题。本练习将带你进入非线性领域，通过解决一个描述大角度摆动或重力下导线形状的非线性边值问题。你将亲手使用改进欧拉法（一种数值积分方法）来近似求解路径，并推导出初始斜率 $s$ 必须满足的超越方程。这个过程清晰地揭示了为什么对于非线性问题，打靶法的核心挑战在于求解一个复杂的非线性方程。",
            "id": "2209834",
            "problem": "考虑非线性边值问题 (BVP)，该问题模拟了重线的静态形状或单摆的大角度振荡：\n$$\ny'' + \\sin(y) = 0\n$$\n边界条件为 $y(0) = 0$ 和 $y(L) = 0$，其中长度 $L=4$。\n\n我们希望找到初始斜率 $s = y'(0)$，使得该边值问题有解。这可以通过使用打靶法来完成。该方法包括将 BVP 转换为一个初值问题 (IVP)，方法是设定初始条件为 $y(0)=0$ 和 $y'(0)=s$。然后从 $x=0$ 到 $x=L$ 对该 IVP 进行数值求解。然后不断调整初始斜率 $s$ 的值，直到解满足第二个边界条件 $y(L)=0$。\n\n你的任务是应用步长为 $h=2$（即两步）的改进欧拉法（也称为 Heun 法）来求解该 IVP。通过符号计算，将解在 $x=L$ 处的值表示为未知斜率 $s$ 的函数，然后应用边界条件 $y(L)=0$，推导出 $s$ 必须满足的超越方程。所有涉及三角函数的计算都必须以弧度为单位进行。\n\n请将得到的方程以 $f(s) = 0$ 的最简形式给出。",
            "solution": "我们通过设 $y_{1}=y$ 和 $y_{2}=y'$，将二阶常微分方程转换为一个一阶方程组。则\n$$\ny_{1}'=y_{2}, \\quad y_{2}'=-\\sin(y_{1}),\n$$\n初始条件为 $y_{1}(0)=0$ 和 $y_{2}(0)=s$。我们应用步长为 $h=2$ 的改进欧拉（Heun）法，通过两步计算到达 $x=L=4$。对于一个方程组 $z' = F(z)$，Heun 法的更新公式为\n$$\nz_{n+1}=z_{n}+\\frac{h}{2}\\left[F(z_{n})+F\\bigl(z_{n}+h F(z_{n})\\bigr)\\right].\n$$\n\n第一步（从 $x=0$ 到 $x=2$）：令 $z_{0}=(y_{1,0},y_{2,0})=(0,s)$。\n计算\n$$\nF(z_{0})=\\begin{pmatrix}y_{2,0}\\\\ -\\sin(y_{1,0})\\end{pmatrix}=\\begin{pmatrix}s\\\\ 0\\end{pmatrix}.\n$$\n预测步：\n$$\nz_{0}+h F(z_{0})=\\begin{pmatrix}0\\\\ s\\end{pmatrix}+2\\begin{pmatrix}s\\\\ 0\\end{pmatrix}=\\begin{pmatrix}2s\\\\ s\\end{pmatrix}.\n$$\n在预测值处求值：\n$$\nF\\bigl(z_{0}+h F(z_{0})\\bigr)=\\begin{pmatrix}s\\\\ -\\sin(2s)\\end{pmatrix}.\n$$\n校正步：\n$$\nz_{1}=z_{0}+\\frac{h}{2}\\left[F(z_{0})+F\\bigl(z_{0}+h F(z_{0})\\bigr)\\right]\n=\\begin{pmatrix}0\\\\ s\\end{pmatrix}+\\frac{2}{2}\\left[\\begin{pmatrix}s\\\\ 0\\end{pmatrix}+\\begin{pmatrix}s\\\\ -\\sin(2s)\\end{pmatrix}\\right]\n=\\begin{pmatrix}2s\\\\ s-\\sin(2s)\\end{pmatrix}.\n$$\n因此 $y(2)=y_{1,1}=2s$ 且 $y'(2)=y_{2,1}=s-\\sin(2s)$。\n\n第二步（从 $x=2$ 到 $x=4$）：令 $z_{1}=(2s,\\,s-\\sin(2s))$。\n计算\n$$\nF(z_{1})=\\begin{pmatrix}s-\\sin(2s)\\\\ -\\sin(2s)\\end{pmatrix}.\n$$\n预测步：\n$$\nz_{1}+h F(z_{1})=\\begin{pmatrix}2s\\\\ s-\\sin(2s)\\end{pmatrix}\n+2\\begin{pmatrix}s-\\sin(2s)\\\\ -\\sin(2s)\\end{pmatrix}\n=\\begin{pmatrix}4s-2\\sin(2s)\\\\ s-3\\sin(2s)\\end{pmatrix}.\n$$\n在预测值处求值：\n$$\nF\\bigl(z_{1}+h F(z_{1})\\bigr)=\\begin{pmatrix}s-3\\sin(2s)\\\\ -\\sin\\!\\bigl(4s-2\\sin(2s)\\bigr)\\end{pmatrix}.\n$$\n校正步（只计算在 $x=4$ 处 $y$ 的第一个分量）：\n$$\ny(4)=y_{1,2}=y_{1,1}+\\frac{h}{2}\\left[\\bigl(y_{2}\\bigr)_{1}+\\bigl(y_{2}\\bigr)_{\\text{pred}}\\right]\n=2s+\\frac{2}{2}\\left[\\left(s-\\sin(2s)\\right)+\\left(s-3\\sin(2s)\\right)\\right]\n=4s-4\\sin(2s).\n$$\n\n施加边界条件 $y(L)=y(4)=0$（所有三角函数均以弧度为单位）：\n$$\n4s-4\\sin(2s)=0 \\quad \\Longleftrightarrow \\quad s-\\sin(2s)=0.\n$$\n因此，所求的写为 $f(s)=0$ 形式的超越方程为 $f(s)=s-\\sin(2s)$。",
            "answer": "$$\\boxed{s-\\sin(2 s)=0}$$"
        },
        {
            "introduction": "为了高效、精确地求解边值问题，我们需要结合更强大的求根算法，例如牛顿法。这个高级实践将指导你从头开始构建一个完整的、基于牛顿法的打靶法求解器，用于解决一个非线性热传导模型。你将推导并求解一组称为“敏感性方程”的伴随微分方程，以获得牛顿法所需的导数，最终实现一个能够快速、稳健地处理复杂边值问题的计算工具。",
            "id": "2437831",
            "problem": "考虑一个在闭区间 $[0,1]$ 上的非线性、稳态、一维热传导模型，其形式为一个常微分方程 (ODE) 边值问题 (BVP)：\n$$\ny''(x) + \\lambda \\sinh\\!\\big(y(x)\\big) = 0,\\quad x \\in [0,1],\n$$\n其边界条件为\n$$\ny(0) = \\alpha,\\qquad y(1) = \\beta,\n$$\n其中 $\\lambda$、$\\alpha$ 和 $\\beta$ 是给定的实常数，$\\sinh(\\cdot)$ 是双曲正弦函数。所有量均为无量纲（无物理单位）。打靶法将该 BVP 重新表述为一个由未知初始斜率 $s = y'(0)$ 参数化的初值问题 (IVP)：\n$$\ny'(x) = v(x),\\qquad v'(x) = -\\lambda \\sinh\\!\\big(y(x)\\big),\\qquad y(0)=\\alpha,\\quad v(0)=s.\n$$\n定义终端失配函数\n$$\n\\Phi(s) := y(1;s) - \\beta,\n$$\n其中 $y(1;s)$ 表示使用参数 $s$ 积分 IVP 在 $x=1$ 处得到的状态 $y$。数值目标是找到 $s^\\star$ 使得 $\\Phi(s^\\star)=0$。\n\n任务：\n- 从初值问题和打靶法公式的定义出发，仅使用标准变分法和链式法则，推导由 $z(x) := \\partial y(x;s)/\\partial s$ 满足的线性灵敏度（变分）ODE 及其在 $x=0$ 处的初始条件。解释为什么该灵敏度使得可以使用牛顿法来更新 $s$。\n- 为求解 $\\Phi(s)=0$ 的根，实现一个鲁棒的牛顿迭代法，该方法使用灵敏度方程来评估导数 $\\Phi'(s)$。在每个牛顿步中，将耦合的状态-灵敏度 IVP 从 $x=0$ 积分到 $x=1$，以同时获得 $y(1;s)$ 和 $z(1;s) = \\partial y(1;s)/\\partial s$。使用这些值来计算 $s$ 的牛顿更新量。如果需要，您可以使用简单的回溯线搜索来提高鲁棒性。\n- 使用一个具有严格局部误差控制的确定性自适应 ODE 积分器来积分耦合的 ODE 系统。确保绝对和相对容差足够严格，以便在终端残差 $|\\Phi(s)|$ 中将解和灵敏度解析到至少 $10^{-10}$ 的精度。\n- 使用以下参数集 $(\\lambda,\\alpha,\\beta)$ 测试套件：\n  1. $(\\lambda,\\alpha,\\beta)=(5.0,0.0,0.0)$\n  2. $(\\lambda,\\alpha,\\beta)=(1.0,0.0,1.0)$\n  3. $(\\lambda,\\alpha,\\beta)=(10.0,0.0,0.2)$\n  4. $(\\lambda,\\alpha,\\beta)=(0.01,0.0,0.5)$\n  5. $(\\lambda,\\alpha,\\beta)=(2.5,0.2,-0.3)$\n- 对于每个参数集，计算牛顿法收敛的初始斜率 $s^\\star$，使得 $|\\Phi(s^\\star)| \\le 10^{-10}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个 Python 风格的浮点数列表，每个测试用例对应一个数字，顺序与测试套件相同。每个数字必须是相应收敛的初始斜率 $s^\\star$，格式化为小数点后恰好 $8$ 位。例如，打印字符串 $[s\\_1,s\\_2,s\\_3,s\\_4,s\\_5]$，其中每个 $s\\_k$ 四舍五入到 $8$ 位小数，并且没有任何额外的空格或文本。",
            "solution": "所述问题是一个在数学和计算上都明确定义的任务。它是数学物理领域的一个标准非线性边值问题 (BVP)，通过打靶法进行重新表述是一种典型技术。该问题是自洽的、有科学依据的，并且其参数已指定，允许在给定初始猜测的情况下找到唯一的数值解。因此，该问题被认为是有效的。解法从第一性原理出发。\n\n该 BVP 由以下二阶常微分方程 (ODE) 定义：\n$$\ny''(x) + \\lambda \\sinh(y(x)) = 0, \\quad x \\in [0,1]\n$$\n边界条件为狄利克雷边界条件：\n$$\ny(0) = \\alpha, \\quad y(1) = \\beta\n$$\n\n打靶法将此 BVP 转换为一个初值问题 (IVP)。我们引入一个状态向量，其分量为 $y(x)$ 及其导数 $v(x) = y'(x)$。该二阶 ODE 被重写为两个一阶 ODE 组成的系统：\n$$\n\\begin{cases}\ny'(x) = v(x) \\\\\nv'(x) = -\\lambda \\sinh(y(x))\n\\end{cases}\n$$\n在 $x=0$ 处的边界条件 $y(0)=\\alpha$ 被用作初始条件。第二个初始条件 $v(0)=y'(0)$ 是未知的。我们将这个未知的初始斜率指定为一个参数 $s$：\n$$\ny(0) = \\alpha, \\quad v(0) = s\n$$\n此 IVP 的解取决于 $s$ 的选择，我们将其记为 $y(x;s)$。打靶法的目标是找到参数的特定值 $s^\\star$，使得解满足在 $x=1$ 处的第二个边界条件：\n$$\ny(1; s^\\star) = \\beta\n$$\n这是一个关于终端失配函数 $\\Phi(s)$ 的求根问题：\n$$\n\\Phi(s) := y(1;s) - \\beta = 0\n$$\n\n为使用牛顿法求解 $\\Phi(s)=0$，我们需要 $\\Phi(s)$ 对 $s$ 的导数。牛顿迭代公式如下：\n$$\ns_{k+1} = s_k - \\frac{\\Phi(s_k)}{\\Phi'(s_k)}\n$$\n导数 $\\Phi'(s)$ 计算如下：\n$$\n\\Phi'(s) = \\frac{d}{ds} \\left( y(1;s) - \\beta \\right) = \\frac{\\partial y(1;s)}{\\partial s}\n$$\n为了求这个偏导数，我们推导灵敏度方程。设 $z(x;s) = \\frac{\\partial y(x;s)}{\\partial s}$ 和 $w(x;s) = \\frac{\\partial v(x;s)}{\\partial s}$。我们将 IVP 系统对参数 $s$ 求导，应用链式法则，并注意到对 $x$ 和 $s$ 的微分顺序可以交换：\n$$\n\\frac{\\partial}{\\partial s} (y') = \\frac{d}{dx}\\left(\\frac{\\partial y}{\\partial s}\\right) = z'(x)\n$$\n从第一个 ODE $y' = v$ 可得：\n$$\nz'(x) = \\frac{\\partial v(x;s)}{\\partial s} = w(x)\n$$\n从第二个 ODE $v' = -\\lambda \\sinh(y)$ 可得：\n$$\n\\frac{\\partial}{\\partial s} (v') = \\frac{d}{dx}\\left(\\frac{\\partial v}{\\partial s}\\right) = w'(x)\n$$\n$$\nw'(x) = \\frac{\\partial}{\\partial s} \\left( -\\lambda \\sinh(y(x;s)) \\right) = -\\lambda \\cosh(y(x;s)) \\cdot \\frac{\\partial y(x;s)}{\\partial s} = -\\lambda \\cosh(y(x;s)) z(x)\n$$\n这就得出了关于灵敏度 $z(x)$ 和 $w(x)$ 的线性 ODE 系统：\n$$\n\\begin{cases}\nz'(x) = w(x) \\\\\nw'(x) = -\\lambda \\cosh(y(x;s)) z(x)\n\\end{cases}\n$$\n这等价于 $z(x)$ 的二阶线性变分方程：\n$$\nz''(x) + \\lambda \\cosh(y(x;s)) z(x) = 0\n$$\n该系统的初始条件通过将原始初始条件对 $s$ 求导得到：\n$$\nz(0) = \\frac{\\partial y(0)}{\\partial s} = \\frac{\\partial \\alpha}{\\partial s} = 0 \\quad (\\text{因为 } \\alpha \\text{ 是一个常数})\n$$\n$$\nw(0) = \\frac{\\partial v(0)}{\\partial s} = \\frac{\\partial s}{\\partial s} = 1\n$$\n牛顿法所需的导数是 $\\Phi'(s) = z(1;s)$。为求此值，我们必须求解一个由四个一阶 ODE 组成的耦合系统。设状态向量为 $\\mathbf{u}(x) = [y(x), v(x), z(x), w(x)]^T$。该耦合系统为：\n$$\n\\mathbf{u}'(x) = \\frac{d}{dx} \\begin{bmatrix} y \\\\ v \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\lambda \\sinh(y) \\\\ w \\\\ -\\lambda \\cosh(y) z \\end{bmatrix}\n$$\n对于给定的试探斜率 $s_k$，在 $x=0$ 处的初始条件为：\n$$\n\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T\n$$\n基于牛顿法的打靶法算法如下：\n1.  为斜率选择一个初始猜测值 $s_0$。\n2.  对于 $k=0, 1, 2, \\dots$，直到收敛：\n    a. 定义初始条件向量 $\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T$。\n    b. 使用高精度自适应 ODE 求解器将耦合的四维 ODE 系统从 $x=0$ 积分到 $x=1$。\n    c. 从 $x=1$ 处的数值解中，提取终端状态 $\\mathbf{u}(1) = [y(1;s_k), v(1;s_k), z(1;s_k), w(1;s_k)]^T$。\n    d. 评估失配函数：$\\Phi(s_k) = y(1;s_k) - \\beta$。\n    e. 检查收敛性：如果 $|\\Phi(s_k)|$ 小于指定的容差（例如 $10^{-10}$），则迭代完成，且 $s^\\star = s_k$。\n    f. 评估导数：$\\Phi'(s_k) = z(1;s_k)$。\n    g. 计算牛顿更新量：$\\Delta s = - \\Phi(s_k) / \\Phi'(s_k)$。\n    h. 为增强鲁棒性，可使用回溯线搜索。更新以 $s_{k+1} = s_k + \\gamma \\Delta s$ 的形式应用，其中 $\\gamma \\in (0, 1]$ 从 $\\gamma=1$ 开始递减，直到观察到残差 $|\\Phi(s)|$ 有充分的下降。\n    i. 更新斜率：$s_{k+1} = s_k + \\gamma \\Delta s$。\n\n对于给定的测试用例，初始猜测 $s_0 = \\beta - \\alpha$ 是一个合理的选择，因为它对应于边界之间线性插值的斜率。然而，对于对称情况 $(\\lambda=5.0, \\alpha=0.0, \\beta=0.0)$，该猜测值为 $s_0=0$。这会导致平凡解 $y(x)=0$，这确实是一个有效解，因为 $\\Phi(0) = 0 - 0 = 0$。为了找到一个非平凡解，必须使用一个非零的初始猜测，例如 $s_0=1.0$。对于所有其他指定情况，$s_0 = \\beta - \\alpha$ 是一个合适的非零猜测。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP using the Newton-shooting method with sensitivity analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, alpha, beta)\n        (5.0, 0.0, 0.0),\n        (1.0, 0.0, 1.0),\n        (10.0, 0.0, 0.2),\n        (0.01, 0.0, 0.5),\n        (2.5, 0.2, -0.3),\n    ]\n\n    results = []\n\n    def solve_bvp_for_case(lambda_val, alpha, beta):\n        \"\"\"\n        Computes the converged initial slope s* for a single set of parameters.\n        \"\"\"\n        \n        def coupled_ode(t, u, lambda_p):\n            \"\"\"\n            Defines the coupled state-sensitivity ODE system.\n            u = [y, v, z, w]\n            y' = v\n            v' = -lambda * sinh(y)\n            z' = w\n            w' = -lambda * cosh(y) * z\n            \"\"\"\n            y, v, z, w = u\n            y_dot = v\n            v_dot = -lambda_p * np.sinh(y)\n            z_dot = w\n            w_dot = -lambda_p * np.cosh(y) * z\n            return [y_dot, v_dot, z_dot, w_dot]\n\n        # Initial guess for the slope s = y'(0)\n        if lambda_val == 5.0 and alpha == 0.0 and beta == 0.0:\n            # For the symmetric case, s=0 gives the trivial solution y=0.\n            # To find a non-trivial solution, a non-zero guess is required.\n            s = 1.0\n        else:\n            # For other cases, the slope of the line connecting boundaries is a reasonable guess.\n            s = beta - alpha\n            \n        max_iter = 30\n        tolerance = 1e-10\n        ode_atol = 1e-13\n        ode_rtol = 1e-13\n\n        for i in range(max_iter):\n            # 1. Integrate the coupled system for the current guess s\n            u0 = np.array([alpha, s, 0.0, 1.0])\n            sol = solve_ivp(\n                fun=coupled_ode,\n                t_span=[0, 1],\n                y0=u0,\n                method='DOP853',\n                args=(lambda_val,),\n                atol=ode_atol,\n                rtol=ode_rtol\n            )\n            \n            # Check for integration failures\n            if sol.status != 0:\n                # Handle integration failure, e.g., by stopping.\n                # In a robust implementation, one might try another guess or method.\n                break\n\n            u1 = sol.y[:, -1]\n            y1, _, z1, _ = u1\n\n            # 2. Evaluate the residual (mismatch) and check for convergence\n            phi = y1 - beta\n            if abs(phi) = tolerance:\n                break\n                \n            # 3. Evaluate the derivative of the mismatch function\n            phi_prime = z1\n            if abs(phi_prime) = 1e-14:\n                # Derivative is too small; Newton's method may fail or diverge.\n                break\n\n            # 4. Compute the Newton update step\n            ds = -phi / phi_prime\n\n            # 5. Apply step with a simple backtracking line search for robustness\n            gamma = 1.0\n            max_backtrack = 10\n            s_next = s + gamma * ds\n            \n            for j in range(max_backtrack):\n                u0_next = np.array([alpha, s_next, 0.0, 1.0])\n                sol_next = solve_ivp(\n                    fun=coupled_ode,\n                    t_span=[0, 1],\n                    y0=u0_next,\n                    method='DOP853',\n                    args=(lambda_val,),\n                    atol=ode_atol,\n                    rtol=ode_rtol,\n                )\n                \n                if sol_next.status != 0:\n                     # If integration fails during line search, reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n                    continue\n\n                y1_next = sol_next.y[0, -1]\n                phi_next = y1_next - beta\n                \n                if abs(phi_next)  abs(phi):\n                    # Step accepted, break line search\n                    break\n                else:\n                    # Reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n            \n            s = s_next\n            \n        return s\n\n    for case in test_cases:\n        lambda_val, alpha, beta = case\n        s_star = solve_bvp_for_case(lambda_val, alpha, beta)\n        results.append(s_star)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}