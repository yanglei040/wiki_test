{
    "hands_on_practices": [
        {
            "introduction": "The core of the shooting method lies in defining a function whose root we must find, typically based on the mismatch at a boundary. This first exercise provides a crucial analytical foundation by asking you to derive the exact relationship between an initial slope guess, $s_g$, and the resulting value at the far boundary, $y(1; s_g)$. Solving this will give you direct insight into the structure of the root-finding problem and help you appreciate why the method can be highly sensitive for certain classes of differential equations.",
            "id": "2209816",
            "problem": "Consider a Boundary Value Problem (BVP), which is a differential equation with conditions specified at the boundaries of its domain. The specific BVP is defined by the second-order ordinary differential equation $y'' - k^2 y = 0$ on the domain $x \\in [0, 1]$, with boundary conditions $y(0) = 1$ and $y(1) = 1$. The parameter $k$ is a positive real constant.\n\nThe shooting method is a numerical technique to solve this BVP. It works by converting the BVP into an Initial Value Problem (IVP). An initial slope, $s_g = y'(0)$, is guessed. Then, the IVP consisting of the differential equation $y'' - k^2 y = 0$ and the initial conditions $y(0)=1$ and $y'(0)=s_g$ is solved to find the value of the solution at $x=1$. This value is compared to the desired boundary condition $y(1)=1$, and the guess $s_g$ is adjusted in an iterative process. For large values of $k$, this method becomes highly sensitive to the initial guess $s_g$.\n\nTo understand this sensitivity analytically, let $y(x; s_g)$ denote the solution to the IVP for a given initial slope guess $s_g$. Find a closed-form analytic expression for the value of this solution at the right boundary, $y(1; s_g)$. Your answer should be in terms of $k$, $s_g$, and hyperbolic functions.",
            "solution": "We solve the linear homogeneous ODE with constant coefficients $y''-k^{2}y=0$. The characteristic equation is $r^{2}-k^{2}=0$, giving roots $r=\\pm k$. A convenient real basis of solutions is $\\cosh(kx)$ and $\\sinh(kx)$, so the general solution is\n$$\ny(x)=C\\cosh(kx)+D\\sinh(kx).\n$$\nImposing the initial condition $y(0)=1$ gives\n$$\ny(0)=C\\cosh(0)+D\\sinh(0)=C=1,\n$$\nso $C=1$. Differentiating yields\n$$\ny'(x)=kD\\cosh(kx)+kC\\sinh(kx).\n$$\nUsing $y'(0)=s_{g}$ gives\n$$\ny'(0)=kD\\cosh(0)+kC\\sinh(0)=kD=s_{g},\n$$\nso $D=\\frac{s_{g}}{k}$. Therefore the IVP solution is\n$$\ny(x;s_{g})=\\cosh(kx)+\\frac{s_{g}}{k}\\sinh(kx).\n$$\nEvaluating at the right boundary $x=1$ gives\n$$\ny(1;s_{g})=\\cosh(k)+\\frac{s_{g}}{k}\\sinh(k).\n$$\nThis is the required closed-form expression in terms of $k$, $s_{g}$, and hyperbolic functions.",
            "answer": "$$\\boxed{\\cosh(k)+\\frac{s_{g}}{k}\\sinh(k)}$$"
        },
        {
            "introduction": "While analytical solutions are instructive, most real-world boundary value problems require a numerical approach to solve the intermediate initial value problems. This practice guides you through the process of manually applying a numerical integrator (Heun's method) to a nonlinear problem modeling a pendulum's motion. This hands-on calculation demystifies the process, showing exactly how the numerical integration steps build the complex, transcendental equation for the initial slope $s$ that we need to solve.",
            "id": "2209834",
            "problem": "Consider the nonlinear Boundary Value Problem (BVP), which models the static shape of a heavy wire or the large-angle oscillation of a pendulum:\n$$\ny'' + \\sin(y) = 0\n$$\nwith boundary conditions $y(0) = 0$ and $y(L) = 0$, where the length $L=4$.\n\nWe wish to find the initial slopes $s = y'(0)$ that yield a solution to this BVP. This can be accomplished using the shooting method. The method involves converting the BVP into an Initial Value Problem (IVP) by setting the initial conditions as $y(0)=0$ and $y'(0)=s$. This IVP is then solved numerically from $x=0$ to $x=L$. The value of the initial slope $s$ is then varied until the solution satisfies the second boundary condition, $y(L)=0$.\n\nYour task is to apply the Improved Euler method (also known as Heun's method) with a step size of $h=2$ (i.e., two steps) to the IVP. By symbolically computing the value of the solution at $x=L$ in terms of the unknown slope $s$, and then applying the boundary condition $y(L)=0$, derive the transcendental equation that $s$ must satisfy. All calculations involving trigonometric functions must be performed in radians.\n\nPresent the resulting equation in its simplest form, written as $f(s) = 0$.",
            "solution": "We convert the second-order ODE to a first-order system by setting $y_{1}=y$ and $y_{2}=y'$. Then\n$$\ny_{1}'=y_{2}, \\quad y_{2}'=-\\sin(y_{1}),\n$$\nwith initial conditions $y_{1}(0)=0$ and $y_{2}(0)=s$. We apply the Improved Euler (Heun) method with step size $h=2$ for two steps to reach $x=L=4$. For a system $z' = F(z)$, Heun’s method updates\n$$\nz_{n+1}=z_{n}+\\frac{h}{2}\\left[F(z_{n})+F\\bigl(z_{n}+h F(z_{n})\\bigr)\\right].\n$$\n\nStep 1 (from $x=0$ to $x=2$): Let $z_{0}=(y_{1,0},y_{2,0})=(0,s)$.\nCompute\n$$\nF(z_{0})=\\begin{pmatrix}y_{2,0}\\\\ -\\sin(y_{1,0})\\end{pmatrix}=\\begin{pmatrix}s\\\\ 0\\end{pmatrix}.\n$$\nPredictor:\n$$\nz_{0}+h F(z_{0})=\\begin{pmatrix}0\\\\ s\\end{pmatrix}+2\\begin{pmatrix}s\\\\ 0\\end{pmatrix}=\\begin{pmatrix}2s\\\\ s\\end{pmatrix}.\n$$\nEvaluate at the predictor:\n$$\nF\\bigl(z_{0}+h F(z_{0})\\bigr)=\\begin{pmatrix}s\\\\ -\\sin(2s)\\end{pmatrix}.\n$$\nCorrector:\n$$\nz_{1}=z_{0}+\\frac{h}{2}\\left[F(z_{0})+F\\bigl(z_{0}+h F(z_{0})\\bigr)\\right]\n=\\begin{pmatrix}0\\\\ s\\end{pmatrix}+\\frac{2}{2}\\left[\\begin{pmatrix}s\\\\ 0\\end{pmatrix}+\\begin{pmatrix}s\\\\ -\\sin(2s)\\end{pmatrix}\\right]\n=\\begin{pmatrix}2s\\\\ s-\\sin(2s)\\end{pmatrix}.\n$$\nThus $y(2)=y_{1,1}=2s$ and $y'(2)=y_{2,1}=s-\\sin(2s)$.\n\nStep 2 (from $x=2$ to $x=4$): Let $z_{1}=(2s,\\,s-\\sin(2s))$.\nCompute\n$$\nF(z_{1})=\\begin{pmatrix}s-\\sin(2s)\\\\ -\\sin(2s)\\end{pmatrix}.\n$$\nPredictor:\n$$\nz_{1}+h F(z_{1})=\\begin{pmatrix}2s\\\\ s-\\sin(2s)\\end{pmatrix}\n+2\\begin{pmatrix}s-\\sin(2s)\\\\ -\\sin(2s)\\end{pmatrix}\n=\\begin{pmatrix}4s-2\\sin(2s)\\\\ s-3\\sin(2s)\\end{pmatrix}.\n$$\nEvaluate at the predictor:\n$$\nF\\bigl(z_{1}+h F(z_{1})\\bigr)=\\begin{pmatrix}s-3\\sin(2s)\\\\ -\\sin\\!\\bigl(4s-2\\sin(2s)\\bigr)\\end{pmatrix}.\n$$\nCorrector (first component only for $y$ at $x=4$):\n$$\ny(4)=y_{1,2}=y_{1,1}+\\frac{h}{2}\\left[\\bigl(y_{2}\\bigr)_{1}+\\bigl(y_{2}\\bigr)_{\\text{pred}}\\right]\n=2s+\\frac{2}{2}\\left[\\left(s-\\sin(2s)\\right)+\\left(s-3\\sin(2s)\\right)\\right]\n=4s-4\\sin(2s).\n$$\n\nImpose the boundary condition $y(L)=y(4)=0$ (with all trigonometric functions in radians):\n$$\n4s-4\\sin(2s)=0 \\quad \\Longleftrightarrow \\quad s-\\sin(2s)=0.\n$$\nHence the required transcendental equation, written as $f(s)=0$, is $f(s)=s-\\sin(2s)$.",
            "answer": "$$\\boxed{s-\\sin(2 s)=0}$$"
        },
        {
            "introduction": "To build an efficient and robust shooting method solver, we can use a more powerful root-finding algorithm like Newton's method, which converges quadratically near a root. This requires calculating the derivative of the \"landing position\" with respect to our \"aim,\" a concept known as sensitivity analysis, which involves solving an auxiliary differential equation. This final, comprehensive practice challenges you to derive the necessary sensitivity equations and implement a complete Newton-shooting solver in code to tackle a challenging nonlinear problem.",
            "id": "2437831",
            "problem": "Consider a nonlinear, steady, one-dimensional conduction model written as an ordinary differential equation (ODE) boundary value problem (BVP) on the closed interval $[0,1]$:\n$$\ny''(x) + \\lambda \\sinh\\!\\big(y(x)\\big) = 0,\\quad x \\in [0,1],\n$$\nwith boundary conditions\n$$\ny(0) = \\alpha,\\qquad y(1) = \\beta,\n$$\nwhere $\\lambda$, $\\alpha$, and $\\beta$ are given real constants, and $\\sinh(\\cdot)$ is the hyperbolic sine function. All quantities are nondimensional (no physical units). The shooting method reformulates the BVP as an initial value problem (IVP) parametrized by the unknown initial slope $s = y'(0)$:\n$$\ny'(x) = v(x),\\qquad v'(x) = -\\lambda \\sinh\\!\\big(y(x)\\big),\\qquad y(0)=\\alpha,\\quad v(0)=s.\n$$\nDefine the terminal mismatch function\n$$\n\\Phi(s) := y(1;s) - \\beta,\n$$\nwhere $y(1;s)$ denotes the state $y$ at $x=1$ obtained by integrating the IVP with the parameter $s$. The numerical objective is to find $s^\\star$ such that $\\Phi(s^\\star)=0$.\n\nTask:\n- Starting from the definitions of an initial value problem and the shooting formulation, and using only standard calculus of variations and the chain rule, derive the linear sensitivity (variational) ODE satisfied by $z(x) := \\partial y(x;s)/\\partial s$ and its initial conditions at $x=0$. Explain why this sensitivity enables the use of Newton’s method to update $s$.\n- Implement a robust Newton iteration for the root finding of $\\Phi(s)=0$ that uses the sensitivity equation to evaluate the derivative $\\Phi'(s)$. At each Newton step, integrate the coupled state–sensitivity IVP from $x=0$ to $x=1$ to obtain both $y(1;s)$ and $z(1;s) = \\partial y(1;s)/\\partial s$. Use these to compute the Newton update for $s$. You may employ a simple backtracking line search to improve robustness if needed.\n- Use a deterministic, adaptive ODE integrator with rigorous local error control to integrate the coupled ODE system. Ensure the absolute and relative tolerances are tight enough to resolve the solution and the sensitivity to at least $10^{-10}$ in the terminal residual $|\\Phi(s)|$.\n- Use the following test suite of parameter sets $(\\lambda,\\alpha,\\beta)$:\n  1. $(\\lambda,\\alpha,\\beta)=(5.0,0.0,0.0)$\n  2. $(\\lambda,\\alpha,\\beta)=(1.0,0.0,1.0)$\n  3. $(\\lambda,\\alpha,\\beta)=(10.0,0.0,0.2)$\n  4. $(\\lambda,\\alpha,\\beta)=(0.01,0.0,0.5)$\n  5. $(\\lambda,\\alpha,\\beta)=(2.5,0.2,-0.3)$\n- For each parameter set, compute the Newton-converged initial slope $s^\\star$ such that $|\\Phi(s^\\star)| \\le 10^{-10}$.\n\nFinal output format:\n- Your program must produce a single line of output containing a Python-style list of floating-point numbers, one per test case, in the same order as the test suite. Each number must be the corresponding converged initial slope $s^\\star$, formatted with exactly $8$ digits after the decimal point. For example, print the string $[s\\_1,s\\_2,s\\_3,s\\_4,s\\_5]$ with each $s\\_k$ rounded to $8$ decimal places and no additional whitespace or text anywhere.",
            "solution": "The problem as stated is a mathematically and computationally well-defined task. It is a standard nonlinear boundary value problem (BVP) from the field of mathematical physics, and its reformulation via the shooting method is a canonical technique. The problem is self-contained, scientifically grounded, and its parameters are specified, allowing for a unique numerical solution to be found for a given initial guess. The problem is therefore deemed valid. The solution proceeds by first principles.\n\nThe BVP is defined by the second-order ordinary differential equation (ODE):\n$$\ny''(x) + \\lambda \\sinh(y(x)) = 0, \\quad x \\in [0,1]\n$$\nwith Dirichlet boundary conditions:\n$$\ny(0) = \\alpha, \\quad y(1) = \\beta\n$$\n\nThe shooting method transforms this BVP into an initial value problem (IVP). We introduce a state vector with components $y(x)$ and its derivative $v(x) = y'(x)$. The second-order ODE is rewritten as a system of two first-order ODEs:\n$$\n\\begin{cases}\ny'(x) = v(x) \\\\\nv'(x) = -\\lambda \\sinh(y(x))\n\\end{cases}\n$$\nThe boundary condition at $x=0$, $y(0)=\\alpha$, is used as an initial condition. The second initial condition, $v(0)=y'(0)$, is unknown. We designate this unknown initial slope as a parameter, $s$:\n$$\ny(0) = \\alpha, \\quad v(0) = s\n$$\nThe solution of this IVP depends on the choice of $s$, which we denote as $y(x;s)$. The objective of the shooting method is to find the specific value of the parameter, $s^\\star$, such that the solution satisfies the second boundary condition at $x=1$:\n$$\ny(1; s^\\star) = \\beta\n$$\nThis is a root-finding problem for the terminal mismatch function $\\Phi(s)$:\n$$\n\\Phi(s) := y(1;s) - \\beta = 0\n$$\n\nTo solve $\\Phi(s)=0$ using Newton's method, we require the derivative of $\\Phi(s)$ with respect to $s$. The Newton iteration is given by:\n$$\ns_{k+1} = s_k - \\frac{\\Phi(s_k)}{\\Phi'(s_k)}\n$$\nThe derivative $\\Phi'(s)$ is computed as:\n$$\n\\Phi'(s) = \\frac{d}{ds} \\left( y(1;s) - \\beta \\right) = \\frac{\\partial y(1;s)}{\\partial s}\n$$\nTo find this partial derivative, we derive the sensitivity equations. Let $z(x;s) = \\frac{\\partial y(x;s)}{\\partial s}$ and $w(x;s) = \\frac{\\partial v(x;s)}{\\partial s}$. We differentiate the IVP system with respect to the parameter $s$, applying the chain rule and noting that the order of differentiation with respect to $x$ and $s$ can be interchanged:\n$$\n\\frac{\\partial}{\\partial s} (y') = \\frac{d}{dx}\\left(\\frac{\\partial y}{\\partial s}\\right) = z'(x)\n$$\nFrom the first ODE, $y' = v$, we have:\n$$\nz'(x) = \\frac{\\partial v(x;s)}{\\partial s} = w(x)\n$$\nFrom the second ODE, $v' = -\\lambda \\sinh(y)$, we have:\n$$\n\\frac{\\partial}{\\partial s} (v') = \\frac{d}{dx}\\left(\\frac{\\partial v}{\\partial s}\\right) = w'(x)\n$$\n$$\nw'(x) = \\frac{\\partial}{\\partial s} \\left( -\\lambda \\sinh(y(x;s)) \\right) = -\\lambda \\cosh(y(x;s)) \\cdot \\frac{\\partial y(x;s)}{\\partial s} = -\\lambda \\cosh(y(x;s)) z(x)\n$$\nThis yields a system of linear ODEs for the sensitivities $z(x)$ and $w(x)$:\n$$\n\\begin{cases}\nz'(x) = w(x) \\\\\nw'(x) = -\\lambda \\cosh(y(x;s)) z(x)\n\\end{cases}\n$$\nThis is equivalent to the second-order linear variational equation for $z(x)$:\n$$\nz''(x) + \\lambda \\cosh(y(x;s)) z(x) = 0\n$$\nThe initial conditions for this system are found by differentiating the original initial conditions with respect to $s$:\n$$\nz(0) = \\frac{\\partial y(0)}{\\partial s} = \\frac{\\partial \\alpha}{\\partial s} = 0 \\quad (\\text{since } \\alpha \\text{ is a constant})\n$$\n$$\nw(0) = \\frac{\\partial v(0)}{\\partial s} = \\frac{\\partial s}{\\partial s} = 1\n$$\nThe derivative required for Newton's method is $\\Phi'(s) = z(1;s)$. To find this value, we must solve a coupled system of four first-order ODEs. Let the state vector be $\\mathbf{u}(x) = [y(x), v(x), z(x), w(x)]^T$. The coupled system is:\n$$\n\\mathbf{u}'(x) = \\frac{d}{dx} \\begin{bmatrix} y \\\\ v \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\lambda \\sinh(y) \\\\ w \\\\ -\\lambda \\cosh(y) z \\end{bmatrix}\n$$\nwith the initial condition at $x=0$ for a given trial slope $s_k$:\n$$\n\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T\n$$\nThe algorithm for the Newton-based shooting method is as follows:\n1.  Select an initial guess for the slope, $s_0$.\n2.  For $k=0, 1, 2, \\dots$ until convergence:\n    a. Define the initial condition vector $\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T$.\n    b. Integrate the coupled four-dimensional ODE system from $x=0$ to $x=1$ using a high-precision adaptive ODE solver.\n    c. From the numerical solution at $x=1$, extract the terminal state $\\mathbf{u}(1) = [y(1;s_k), v(1;s_k), z(1;s_k), w(1;s_k)]^T$.\n    d. Evaluate the mismatch function: $\\Phi(s_k) = y(1;s_k) - \\beta$.\n    e. Check for convergence: if $|\\Phi(s_k)|$ is below a specified tolerance (e.g., $10^{-10}$), the iteration is complete, and $s^\\star = s_k$.\n    f. Evaluate the derivative: $\\Phi'(s_k) = z(1;s_k)$.\n    g. Compute the Newton update: $\\Delta s = - \\Phi(s_k) / \\Phi'(s_k)$.\n    h. To enhance robustness, a backtracking line search may be used. The update is applied as $s_{k+1} = s_k + \\gamma \\Delta s$, where $\\gamma \\in (0, 1]$ is reduced from $\\gamma=1$ until a sufficient decrease in the residual $|\\Phi(s)|$ is observed.\n    i. Update the slope: $s_{k+1} = s_k + \\gamma \\Delta s$.\n\nFor the given test cases, the initial guess $s_0 = \\beta - \\alpha$ is a reasonable choice, as it corresponds to the slope of a linear interpolant between the boundaries. However, for the symmetric case $(\\lambda=5.0, \\alpha=0.0, \\beta=0.0)$, this guess is $s_0=0$. This leads to the trivial solution $y(x)=0$, which is indeed a valid solution since $\\Phi(0) = 0 - 0 = 0$. To find a non-trivial solution, a non-zero initial guess, such as $s_0=1.0$, must be used. For all other specified cases, $s_0 = \\beta - \\alpha$ is a suitable non-zero guess.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP using the Newton-shooting method with sensitivity analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, alpha, beta)\n        (5.0, 0.0, 0.0),\n        (1.0, 0.0, 1.0),\n        (10.0, 0.0, 0.2),\n        (0.01, 0.0, 0.5),\n        (2.5, 0.2, -0.3),\n    ]\n\n    results = []\n\n    def solve_bvp_for_case(lambda_val, alpha, beta):\n        \"\"\"\n        Computes the converged initial slope s* for a single set of parameters.\n        \"\"\"\n        \n        def coupled_ode(t, u, lambda_p):\n            \"\"\"\n            Defines the coupled state-sensitivity ODE system.\n            u = [y, v, z, w]\n            y' = v\n            v' = -lambda * sinh(y)\n            z' = w\n            w' = -lambda * cosh(y) * z\n            \"\"\"\n            y, v, z, w = u\n            y_dot = v\n            v_dot = -lambda_p * np.sinh(y)\n            z_dot = w\n            w_dot = -lambda_p * np.cosh(y) * z\n            return [y_dot, v_dot, z_dot, w_dot]\n\n        # Initial guess for the slope s = y'(0)\n        if lambda_val == 5.0 and alpha == 0.0 and beta == 0.0:\n            # For the symmetric case, s=0 gives the trivial solution y=0.\n            # To find a non-trivial solution, a non-zero guess is required.\n            s = 1.0\n        else:\n            # For other cases, the slope of the line connecting boundaries is a reasonable guess.\n            s = beta - alpha\n            \n        max_iter = 30\n        tolerance = 1e-10\n        ode_atol = 1e-13\n        ode_rtol = 1e-13\n\n        for i in range(max_iter):\n            # 1. Integrate the coupled system for the current guess s\n            u0 = np.array([alpha, s, 0.0, 1.0])\n            sol = solve_ivp(\n                fun=coupled_ode,\n                t_span=[0, 1],\n                y0=u0,\n                method='DOP853',\n                args=(lambda_val,),\n                atol=ode_atol,\n                rtol=ode_rtol\n            )\n            \n            # Check for integration failures\n            if sol.status != 0:\n                # Handle integration failure, e.g., by stopping.\n                # In a robust implementation, one might try another guess or method.\n                break\n\n            u1 = sol.y[:, -1]\n            y1, _, z1, _ = u1\n\n            # 2. Evaluate the residual (mismatch) and check for convergence\n            phi = y1 - beta\n            if abs(phi) < tolerance:\n                break\n                \n            # 3. Evaluate the derivative of the mismatch function\n            phi_prime = z1\n            if abs(phi_prime) < 1e-14:\n                # Derivative is too small; Newton's method may fail or diverge.\n                break\n\n            # 4. Compute the Newton update step\n            ds = -phi / phi_prime\n\n            # 5. Apply step with a simple backtracking line search for robustness\n            gamma = 1.0\n            max_backtrack = 10\n            s_next = s + gamma * ds\n            \n            for j in range(max_backtrack):\n                u0_next = np.array([alpha, s_next, 0.0, 1.0])\n                sol_next = solve_ivp(\n                    fun=coupled_ode,\n                    t_span=[0, 1],\n                    y0=u0_next,\n                    method='DOP853',\n                    args=(lambda_val,),\n                    atol=ode_atol,\n                    rtol=ode_rtol,\n                )\n                \n                if sol_next.status != 0:\n                     # If integration fails during line search, reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n                    continue\n\n                y1_next = sol_next.y[0, -1]\n                phi_next = y1_next - beta\n                \n                if abs(phi_next) < abs(phi):\n                    # Step accepted, break line search\n                    break\n                else:\n                    # Reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n            \n            s = s_next\n            \n        return s\n\n    for case in test_cases:\n        lambda_val, alpha, beta = case\n        s_star = solve_bvp_for_case(lambda_val, alpha, beta)\n        results.append(s_star)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}