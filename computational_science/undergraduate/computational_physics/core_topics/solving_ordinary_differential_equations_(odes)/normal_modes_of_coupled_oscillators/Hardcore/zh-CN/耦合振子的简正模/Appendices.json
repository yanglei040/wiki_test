{
    "hands_on_practices": [
        {
            "introduction": "我们对耦合振子链的理论分析通常始于理想化的边界条件，例如两端完全固定或完全自由。然而，在真实物理系统中，边界往往介于两者之间。这个练习将引导你探讨一种更贴近实际的“软”边界情况，即振子链的一端通过一个可变刚度的弹簧接地，这将让你深入实践如何从物理原理出发构建刚度矩阵，并观察边界条件如何改变系统的本征振动模式 。",
            "id": "2418616",
            "problem": "考虑一个一维链，由 $N$ 个质量为 $m$ 的相同质点组成，这些质点通过刚度为 $k$ 的线性弹簧连接。链的左端通过一个刚度为 $k$ 的弹簧连接到一堵固定的墙上，右端通过一个刚度为 $k_{\\text{end}}$ 的弹簧连接到一堵固定的墙上。所有弹簧都遵循胡克定律，且无阻尼。设 $x_i(t)$ 表示第 $i$ 个质点沿直线偏离其平衡位置的位移，其中 $i \\in \\{1,2,\\dots,N\\}$，$t$ 为时间。\n\n仅使用基本力学定律，对下面测试套件中的每一组参数，确定上述链的微小振动的最小正规正模角频率 $\\omega_1$（单位为弧度/秒）。将每个 $\\omega_1$ 以弧度/秒为单位表示，并四舍五入到六位小数。\n\n测试套件（每一项为 $(N, m, k, k_{\\text{end}})$，其中 $m$ 的单位是千克， $k$ 和 $k_{\\text{end}}$ 的单位是牛顿/米）：\n- $(5,\\, 0.20,\\, 50.0,\\, 50.0)$\n- $(5,\\, 0.20,\\, 50.0,\\, 10^{-3})$\n- $(5,\\, 0.20,\\, 50.0,\\, 10^{6})$\n- $(1,\\, 1.0,\\, 100.0,\\, 100.0)$\n- $(2,\\, 1.0,\\, 10.0,\\, 0.0)$\n\n最终输出格式要求：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试套件的顺序相同，例如，“[r1,r2,r3,r4,r5]”。每个 $r_j$ 必须是第 $j$ 个测试案例的 $\\omega_1$ 的浮点数表示，以弧度/秒为单位，四舍五入到六位小数。",
            "solution": "该问题要求确定一维耦合振子链的最低正规正模角频率。分析从经典力学的第一性原理出发。\n\n该系统由 $N$ 个质点组成，每个质点的质量为 $m$。设 $x_i(t)$ 为第 $i$ 个质点偏离其平衡位置的位移，其中 $i \\in \\{1, 2, \\dots, N\\}$。这些质点通过遵循胡克定律的无质量弹簧相互连接并固定在墙上。\n\n推导的基石是应用于每个质点的牛顿第二定律 $F_i = m \\ddot{x}_i$。力 $F_i$ 是连接在第 $i$ 个质点上的弹簧所施加的合力。\n\n我们必须考虑运动方程的三种不同情况：第一个质点（$i=1$）、内部质点（$1 < i < N$）和最后一个质点（$i=N$）。\n\n对于一个内部质点 $i$（$1 < i < N$），它通过刚度为 $k$ 的弹簧与质点 $i-1$ 和质点 $i+1$ 相连。左边弹簧施加的力是 $k(x_{i-1} - x_i)$，右边弹簧施加的力是 $k(x_{i+1} - x_i)$。总力为：\n$$F_i = k(x_{i-1} - x_i) + k(x_{i+1} - x_i) = k(x_{i-1} - 2x_i + x_{i+1})$$\n因此，运动方程为：\n$$m \\ddot{x}_i = k(x_{i-1} - 2x_i + x_{i+1})$$\n\n对于第一个质点 $i=1$，它通过一个刚度为 $k$ 的弹簧连接到一堵固定的墙上（$x_0 = 0$），并通过另一个刚度为 $k$ 的弹簧连接到质点 2。左边弹簧施加的力是 $k(x_0 - x_1) = -kx_1$。右边弹簧施加的力是 $k(x_2 - x_1)$。总力为：\n$$F_1 = -kx_1 + k(x_2 - x_1) = kx_2 - 2kx_1$$\n第一个质点的运动方程为：\n$$m \\ddot{x}_1 = k(x_2 - 2x_1)$$\n\n对于最后一个质点 $i=N$，它通过一个刚度为 $k$ 的弹簧连接到质点 $N-1$，并通过一个刚度为 $k_{\\text{end}}$ 的弹簧连接到一堵固定的墙上（$x_{N+1} = 0$）。左边弹簧施加的力是 $k(x_{N-1} - x_N)$。右边弹簧施加的力是 $k_{\\text{end}}(x_{N+1} - x_N) = -k_{\\text{end}}x_N$。总力为：\n$$F_N = k(x_{N-1} - x_N) - k_{\\text{end}}x_N = kx_{N-1} - (k + k_{\\text{end}})x_N$$\n最后一个质点的运动方程为：\n$$m \\ddot{x}_N = kx_{N-1} - (k + k_{\\text{end}})x_N$$\n\n为了找到正规正模，我们假设一个解，其中所有质点都以相同的角频率 $\\omega$ 振荡。我们将位移表示为复数形式 $x_i(t) = A_i e^{i\\omega t}$，其中 $A_i$ 是第 $i$ 个质点的复振幅。其对时间的二阶导数为 $\\ddot{x}_i(t) = -\\omega^2 A_i e^{i\\omega t} = -\\omega^2 x_i(t)$。将此代入运动方程并消去公因子 $e^{i\\omega t}$，得到关于振幅 $A_i$ 的线性代数方程组：\n$$-m\\omega^2 A_1 = kA_2 - 2kA_1$$\n$$-m\\omega^2 A_i = k(A_{i-1} - 2A_i + A_{i+1}) \\quad \\text{for } 1 < i < N$$\n$$-m\\omega^2 A_N = kA_{N-1} - (k + k_{\\text{end}})A_N$$\n\n这些方程可以重新排列并以矩阵形式表示。设 $\\mathbf{A}$ 为振幅的列向量 $[A_1, A_2, \\dots, A_N]^T$。该方程组等价于特征值问题 $\\mathbf{K}\\mathbf{A} = m\\omega^2\\mathbf{A}$，其中 $\\mathbf{K}$ 是 $N \\times N$ 的刚度矩阵。这是一个广义特征值问题，可以简化为一个标准特征值问题：\n$$\\frac{1}{m}\\mathbf{K}\\mathbf{A} = \\omega^2\\mathbf{A}$$\n矩阵 $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ 是动力学矩阵。其特征值 $\\lambda_j = \\omega_j^2$ 是正规正模角频率的平方。\n\n刚度矩阵 $\\mathbf{K}$ 是一个实的、对称的、三对角矩阵，由力方程中振幅 $A_i$ 的系数构成：\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\n2k & -k & 0 & \\dots & 0 \\\\\n-k & 2k & -k & \\dots & 0 \\\\\n0 & -k & 2k & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & 2k & -k \\\\\n0 & 0 & \\dots & -k & k+k_{\\text{end}}\n\\end{pmatrix}\n$$\n系统的势能 $U = \\frac{1}{2}\\mathbf{x}^T\\mathbf{K}\\mathbf{x} = \\frac{1}{2} k x_1^2 + \\frac{1}{2} k \\sum_{i=1}^{N-1} (x_{i+1}-x_i)^2 + \\frac{1}{2} k_{\\text{end}} x_N^2$，在 $k > 0$ 的条件下，对于任何非零位移向量都是正的。因此，矩阵 $\\mathbf{K}$ 是正定的，其所有特征值 $\\omega_j^2$ 都是严格为正的。\n\n因此，问题简化为一个计算任务：对于每组参数 $(N, m, k, k_{\\text{end}})$，构造矩阵 $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ 并计算其特征值。最小的正规正模角频率 $\\omega_1$ 是最小特征值 $\\lambda_{\\text{min}}$ 的平方根。\n$$\\omega_1 = \\sqrt{\\lambda_{\\text{min}}}$$\n\n解决方案通过执行此过程找到。对于给定的 $N$，我们构造 $N \\times N$ 矩阵 $\\mathbf{K}$，其对角元素对于 $i < N$ 为 $K_{ii} = 2k$，而 $K_{NN} = k + k_{\\text{end}}$，非对角元素为 $K_{i, i+1} = K_{i+1, i} = -k$。然后，我们求出 $\\mathbf{C} = \\frac{1}{m}\\mathbf{K}$ 的特征值。由于 $\\mathbf{C}$ 是实对称矩阵，其特征值是实数并且可以被高效地计算。这些特征值中的最小值给出了所需的频率 $\\omega_1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the smallest positive normal-mode angular frequency for a 1D chain of\n    masses and springs with specified boundary conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, m, k, k_end)\n    test_cases = [\n        (5, 0.20, 50.0, 50.0),\n        (5, 0.20, 50.0, 1e-3),\n        (5, 0.20, 50.0, 1e6),\n        (1, 1.0, 100.0, 100.0),\n        (2, 1.0, 10.0, 0.0),\n    ]\n\n    results = []\n    for N, m, k, k_end in test_cases:\n        # The problem reduces to solving the eigenvalue problem (1/m)K * A = omega^2 * A,\n        # where K is the stiffness matrix. The eigenvalues are the squared angular frequencies.\n        # We construct the dynamical matrix C = (1/m)K and find its eigenvalues.\n\n        # The stiffness matrix K is a real, symmetric, tridiagonal NxN matrix.\n        if N == 1:\n            # For N=1, the matrix K is a 1x1 matrix with element k + k_end.\n            main_diag = np.array([k + k_end])\n            K = np.diag(main_diag)\n        else:\n            # For N > 1, construct the tridiagonal matrix K.\n            # Main diagonal elements: 2k for the first N-1 masses.\n            main_diag = np.full(N, 2 * k)\n            # The last mass has a different diagonal term.\n            main_diag[N - 1] = k + k_end\n            \n            # Off-diagonal elements: -k for connections between masses.\n            off_diag = np.full(N - 1, -k)\n            \n            # Construct K using numpy.diag.\n            K = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # The dynamical matrix C.\n        C = (1 / m) * K\n\n        # Find the eigenvalues of the real symmetric matrix C.\n        # numpy.linalg.eigvalsh is efficient for this and returns eigenvalues\n        # sorted in ascending order.\n        eigenvalues = np.linalg.eigvalsh(C)\n        \n        # The smallest eigenvalue is the first element of the sorted array.\n        # For a stable system with k > 0, all eigenvalues are positive.\n        lambda_min = eigenvalues[0]\n        \n        # The smallest normal mode angular frequency is the square root of the smallest eigenvalue.\n        omega_1 = np.sqrt(lambda_min)\n        \n        results.append(round(omega_1, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了基本振子链的建模后，我们可以通过引入周期性结构来模拟更复杂的系统，例如晶格振动。在这个实践中，你将通过交替使用两种不同刚度的弹簧来构建一个“双原子”一维晶格模型。通过数值求解，你将亲眼见证一个深刻的物理现象的出现：振动模式分裂成声学分支和光学分支，并在它们之间形成一个频率禁带，即“带隙”，这是固态物理学中的一个奠基石概念 。",
            "id": "2418660",
            "problem": "考虑一个由$N$个质量为$m$（单位：$\\mathrm{kg}$）的相同质点组成的一维周期性链，这些质点排列在一个环上（周期性边界条件）。相邻的质点由线性弹簧连接，沿链的弹簧常数（单位：$\\mathrm{N/m}$）在$k_1$和$k_2$之间交替，环上的序列为$k_1, k_2, k_1, k_2, \\dots$。假设$N$为偶数，以使交替序列能够一致地闭合。位移很小，所有弹簧均遵循胡克定律。您的目标是基于第一性原理，模拟该双原子刚度链的简正模并分析其产生的能带结构。\n\n仅从牛顿第二定律和胡克定律出发，该系统的小振荡可以写成关于位移的线性常微分方程组。简正模是具有正弦时间依赖性的解，其角频率（单位：$\\mathrm{rad/s}$）通过求解一个适当的特征值问题得到，该问题取决于由弹簧连接组装而成的质量矩阵和刚度矩阵。对于具有双位点原胞和交替弹簧常数的无限长链，布洛赫波分析得出两个分支（一个声学支和一个光学支）以及在布里渊区边界处它们之间的一个频率间隙；该间隙取决于$m$、$k_1$和$k_2$。\n\n任务：\n- 从牛顿第二定律和胡克定律出发，推导具有$N$个质量和交替弹簧的有限周期性环的线性运动方程。确定质量矩阵和刚度矩阵，并解释为什么简正模满足一个广义特征值问题，其特征值给出角频率的平方。\n- 实现一个程序，该程序为给定的$(N,m,k_1,k_2)$在周期性边界条件下构建刚度矩阵，计算所有简正模的角频率（单位：$\\mathrm{rad/s}$），将它们按升序排序，并识别声学带和光学带。将带隙定义为上能带的最小角频率与下能带的最大角频率之差。对于具有偶数$N$的交替刚度链，每个能带有$N/2$个模式；因此，如果排序后的角频率列表为$\\{\\omega_0 \\le \\omega_1 \\le \\dots \\le \\omega_{N-1}\\}$，则数值带隙为$\\omega_{N/2} - \\omega_{N/2-1}$。\n- 独立地，对双位点原胞进行布洛赫波分析，以获得布里渊区边界处带隙作为$m$、$k_1$和$k_2$函数的理论表达式（不要假设任何预先存在的公式；从第一性原理推导）。为每个测试用例计算此理论带隙。\n\n数值要求：\n- 对于下面的每个情况，计算三个量（单位：$\\mathrm{rad/s}$）：来自有限环特征值问题的数值带隙，来自您的布洛赫分析的理论带隙，以及它们之间的绝对差。将每个报告值四舍五入到$6$位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例结果的逗号分隔列表，并用方括号括起来，其中每个测试用例贡献其自己的子列表，形式为$[\\text{gap\\_numeric},\\text{gap\\_theory},\\text{abs\\_difference}]$。例如：$[[x_1,y_1,z_1],[x_2,y_2,z_2],\\dots]$。\n\n测试套件（涵盖一般情况、弹簧常数相等、强对比度和小系统尺寸）：\n- 情况1：$N=200$，$m=1.0\\,\\mathrm{kg}$，$k_1=10.0\\,\\mathrm{N/m}$，$k_2=40.0\\,\\mathrm{N/m}$。\n- 情况2：$N=100$，$m=2.0\\,\\mathrm{kg}$，$k_1=30.0\\,\\mathrm{N/m}$，$k_2=30.0\\,\\mathrm{N/m}$。\n- 情况3：$N=200$，$m=0.5\\,\\mathrm{kg}$，$k_1=1.0\\,\\mathrm{N/m}$，$k_2=100.0\\,\\mathrm{N/m}$。\n- 情况4：$N=4$，$m=1.5\\,\\mathrm{kg}$，$k_1=5.0\\,\\mathrm{N/m}$，$k_2=15.0\\,\\mathrm{N/m}$。\n\n单位规范：\n- 所有角频率必须以$\\mathrm{rad/s}$表示。\n- 在布洛赫分析中隐式使用的角度以弧度为单位。\n\n最终输出格式：\n- 您的程序必须精确打印一行：一个包含四个按情况分子列表的、用方括号括起来的逗号分隔列表，每个子列表包含三个浮点数$[\\text{gap\\_numeric},\\text{gap\\_theory},\\text{abs\\_difference}]$，每个数都四舍五入到$6$位小数，没有额外的空白或文本。例如：$[[1.234000,1.234000,0.000000],[\\dots],\\dots]$。",
            "solution": "我们使用牛顿第二定律和胡克定律来为由$N$个相同质量通过交替弹簧连接而成的一维周期性链建模。设$x_i(t)$表示第$i$个质量偏离其平衡位置的位移，其中索引$i \\in \\{0,1,\\dots,N-1\\}$，并满足周期性边界条件$x_{i+N}=x_i$。每个粒子的质量为$m$（单位：$\\mathrm{kg}$）。连接质量$i$与质量$i+1$的弹簧的刚度为$k_i$（单位：$\\mathrm{N/m}$），其中如果$i$是偶数则$k_i = k_1$，如果$i$是奇数则$k_i = k_2$，因此环上弹簧的序列交替为$k_1,k_2,k_1,k_2,\\dots$。\n\n根据胡克定律，连接位移为$x$和$y$的质量的刚度为$k$的弹簧，对质量$x$施加的力为$-k(x-y)$，对质量$y$施加的力为$-k(y-x)$。作用在质量$i$上的净力来自其左侧（在$i-1$和$i$之间）刚度为$k_{i-1}$的弹簧和其右侧（在$i$和$i+1$之间）刚度为$k_i$的弹簧。牛顿第二定律得出\n$$\nm \\,\\ddot{x}_i \\;=\\; -k_i(x_i - x_{i+1}) \\;-\\; k_{i-1}(x_i - x_{i-1})\n\\;=\\; -(k_i+k_{i-1})\\, x_i \\;+\\; k_i x_{i+1} \\;+\\; k_{i-1} x_{i-1}.\n$$\n将所有$N$个方程以向量形式$x(t) = (x_0(t),x_1(t),\\dots,x_{N-1}(t))^\\top$集合起来，我们得到线性系统\n$$\nM \\,\\ddot{x}(t) + K\\, x(t) = 0,\n$$\n其中$M = m\\,I$是质量矩阵，$K$是由弹簧网络决定的对称刚度矩阵。对于连接索引 $i$ 和 $j$ 的刚度为 $k$ 的弹簧，其对刚度矩阵 $K$ 的贡献为：$K_{ii}$ 和 $K_{jj}$ 各增加 $k$，$K_{ij}$ 和 $K_{ji}$ 各减去 $k$。\n\n简正模具有$x(t) = v \\, e^{\\mathrm{i}\\omega t}$的形式，这导致了广义特征值问题\n$$\nK\\, v \\;=\\; \\omega^2\\, M\\, v.\n$$\n由于$M = m\\,I$，这简化为标准的对称特征值问题\n$$\nK\\, v \\;=\\; \\lambda\\, v, \\qquad \\omega^2 \\;=\\; \\frac{\\lambda}{m},\n$$\n其中$\\lambda \\ge 0$，因为$K$是半正定的。总存在一个$\\omega = 0$的刚性平移模式。\n\n有限环的能带识别和数值带隙：\n由于两种弹簧的交替，系统表现为具有两个能带的双原子链：一个包含$N/2$个模式（包括零频模式）的声学带和一个包含$N/2$个模式的光学带。将角频率$\\{\\omega_i\\}_{i=0}^{N-1}$按升序排序，声学带为$\\{\\omega_0,\\dots,\\omega_{N/2-1}\\}$，光学带为$\\{\\omega_{N/2},\\dots,\\omega_{N-1}\\}$。于是，数值带隙为\n$$\n\\Delta \\omega_{\\text{num}} \\;=\\; \\omega_{N/2} - \\omega_{N/2-1}.\n$$\n\n通过布洛赫分析得到的理论能带结构：\n对于无限长链，定义一个双位点原胞，其中第$n$个原胞中两个质量的位移分别为$u_n$和$v_n$。交替的弹簧在原胞内部为$k_1$（连接$u_n$和$v_n$），在原胞之间为$k_2$（连接$v_n$和$u_{n+1}$）。运动方程变为\n$$\nm \\,\\ddot{u}_n = -(k_1+k_2) u_n + k_1 v_n + k_2 v_{n-1}, \\qquad\nm \\,\\ddot{v}_n = -(k_1+k_2) v_n + k_1 u_n + k_2 u_{n+1}.\n$$\n对于等于单个质量间距两倍的晶格周期$a_c$，采用布洛赫假设$u_n = U\\, e^{\\mathrm{i}(q n a_c - \\omega t)}$和$v_n = V\\, e^{\\mathrm{i}(q n a_c - \\omega t)}$，我们得到特征值条件\n$$\n\\begin{pmatrix}\n(k_1+k_2) - \\omega^2 m & -(k_1 + k_2 e^{-\\mathrm{i} q a_c}) \\\\\n-(k_1 + k_2 e^{\\mathrm{i} q a_c}) & (k_1+k_2) - \\omega^2 m\n\\end{pmatrix}\n\\begin{pmatrix} U \\\\ V \\end{pmatrix}\n= 0.\n$$\n要求有非平凡解，可得\n$$\n\\big[(k_1+k_2) - \\omega^2 m\\big]^2 \\;-\\; \\big|k_1 + k_2 e^{\\mathrm{i} q a_c}\\big|^2 \\;=\\; 0,\n$$\n因此\n$$\n\\omega^2(q) \\;=\\; \\frac{(k_1+k_2) \\pm \\sqrt{k_1^2 + k_2^2 + 2 k_1 k_2 \\cos(q a_c)}}{m},\n$$\n其中负号产生声学支，正号产生光学支。在布里渊区边界$q = \\pi/a_c$处，我们有$\\cos(q a_c) = \\cos \\pi = -1$，因此\n$$\n\\omega_{\\text{ac}}^2\\big(\\tfrac{\\pi}{a_c}\\big) = \\frac{(k_1+k_2) - |k_1 - k_2|}{m} = \\frac{2 \\min(k_1,k_2)}{m}, \\quad\n\\omega_{\\text{op}}^2\\big(\\tfrac{\\pi}{a_c}\\big) = \\frac{(k_1+k_2) + |k_1 - k_2|}{m} = \\frac{2 \\max(k_1,k_2)}{m}.\n$$\n因此，在区域边界处的理论带隙为\n$$\n\\Delta \\omega_{\\text{theory}} \\;=\\; \\sqrt{\\frac{2\\,\\max(k_1,k_2)}{m}} \\;-\\; \\sqrt{\\frac{2\\,\\min(k_1,k_2)}{m}} \\quad \\text{单位：} \\mathrm{rad/s}.\n$$\n注意，如果$k_1 = k_2$，那么$\\Delta \\omega_{\\text{theory}} = 0$。\n\n算法实现：\n- 通过对$N$个弹簧进行周期性环绕循环来组装刚度矩阵$K$。对于$i$和$j=(i+1)\\bmod N$之间的弹簧，如果$i$为偶数，则使用$k=k_1$，如果$i$为奇数，则使用$k=k_2$，并在索引$(i,i)$、$(j,j)$、$(i,j)$和$(j,i)$处向$K$添加标准的$2 \\times 2$贡献。\n- 使用对称特征求解器计算$K$的特征值$\\{\\lambda_\\ell\\}$。通过$\\omega_\\ell^2 = \\lambda_\\ell/m$转换为频率的平方，将小的负数值误差截断为$0$，然后取平方根得到$\\omega_\\ell$（单位：$\\mathrm{rad/s}$）。将$\\{\\omega_\\ell\\}$按升序排序。\n- 计算$\\Delta \\omega_{\\text{num}} = \\omega_{N/2} - \\omega_{N/2-1}$。\n- 从上述闭式表达式计算$\\Delta \\omega_{\\text{theory}}$。\n- 对于每个测试用例，报告$[\\Delta \\omega_{\\text{num}}, \\Delta \\omega_{\\text{theory}}, |\\Delta \\omega_{\\text{num}} - \\Delta \\omega_{\\text{theory}}|]$，所有值均以$\\mathrm{rad/s}$为单位，并四舍五入到$6$位小数。\n- 打印一行，其中包含按确切格式要求的四个子列表的列表。\n\n此方法是基于第一性原理的，因为它从牛顿第二定律和胡克定律出发，构建了物理上的刚度矩阵和质量矩阵，并使用简正模的定义将其简化为特征值问题。布洛赫波的推导提供了能带结构及其带隙的第一性原理理论预测，从而可以与有限环的模拟进行定量比较。测试套件涵盖了一个典型情况、无带隙极限$k_1=k_2$、具有宽带隙的强对比度情况，以及布里渊区边界被精确采样的的小系统尺寸。",
            "answer": "```python\nimport numpy as np\n\ndef build_stiffness_matrix(N: int, k1: float, k2: float) -> np.ndarray:\n    \"\"\"\n    Construct the NxN stiffness matrix K for a ring of N masses with alternating springs.\n    Spring between i and (i+1)%N has stiffness k1 if i is even, else k2.\n    \"\"\"\n    K = np.zeros((N, N), dtype=float)\n    for i in range(N):\n        j = (i + 1) % N\n        k = k1 if (i % 2 == 0) else k2\n        # Add spring contributions\n        K[i, i] += k\n        K[j, j] += k\n        K[i, j] -= k\n        K[j, i] -= k\n    return K\n\ndef numerical_gap(N: int, m: float, k1: float, k2: float) -> float:\n    \"\"\"\n    Compute the numerical band gap for the finite ring as the difference between\n    the smallest optical frequency and the largest acoustic frequency.\n    \"\"\"\n    K = build_stiffness_matrix(N, k1, k2)\n    # Since M = m I, eigenvalues of K are lambda = m * omega^2\n    evals = np.linalg.eigvalsh(K)\n    # Frequencies in rad/s\n    omega2 = np.clip(evals / m, 0.0, None)\n    omega = np.sqrt(omega2)\n    omega.sort()\n    # Acoustic band: first N//2 modes, Optical band: last N//2 modes\n    gap = omega[N // 2] - omega[N // 2 - 1]\n    return float(gap)\n\ndef theoretical_gap(m: float, k1: float, k2: float) -> float:\n    \"\"\"\n    Theoretical band gap at the Brillouin zone boundary for alternating springs:\n    Δω = sqrt(2*max(k1,k2)/m) - sqrt(2*min(k1,k2)/m)\n    \"\"\"\n    kmax = max(k1, k2)\n    kmin = min(k1, k2)\n    return float(np.sqrt(2.0 * kmax / m) - np.sqrt(2.0 * kmin / m))\n\ndef format_results_no_spaces(results):\n    \"\"\"\n    Format a list of lists of floats as a bracketed string with no spaces,\n    e.g., [[1.0,2.0,3.0],[...],...]\n    \"\"\"\n    sublists = []\n    for sub in results:\n        sub_str = \"[\" + \",\".join(f\"{x:.6f}\" for x in sub) + \"]\"\n        sublists.append(sub_str)\n    return \"[\" + \",\".join(sublists) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, m [kg], k1 [N/m], k2 [N/m])\n    test_cases = [\n        (200, 1.0, 10.0, 40.0),   # General case\n        (100, 2.0, 30.0, 30.0),   # Equal springs -> zero gap\n        (200, 0.5, 1.0, 100.0),   # Strong contrast\n        (4,   1.5, 5.0, 15.0),    # Small system size\n    ]\n\n    results = []\n    for (N, m, k1, k2) in test_cases:\n        gap_num = numerical_gap(N, m, k1, k2)\n        gap_th = theoretical_gap(m, k1, k2)\n        abs_diff = abs(gap_num - gap_th)\n        # Round to 6 decimal places for reporting\n        results.append([round(gap_num, 6), round(gap_th, 6), round(abs_diff, 6)])\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_results_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "完美周期性系统中的波函数是扩展的，可以遍布整个系统，但现实世界中的材料总是存在无序。这个高级实践将带你探索无序对振动模式的颠覆性影响。你将通过在一个振子链中引入随机的弹簧常数来模拟一个无序系统，并学习使用“反参与率”（IPR）这一量化指标来分析模态的局域化程度，从而在计算上验证安德森局域化这一诺贝尔奖级别的重要物理思想 。",
            "id": "2418657",
            "problem": "您的任务是使用计算方法研究一维无序耦合振子链中的模式局域化。考虑一个由 $N$ 个相同点质量（每个质量为 $m$）组成的链，这些质量由弹簧串联，两端固定在墙上。连接左墙与质量 1 的弹簧的劲度系数为 $k_0$，连接质量 $i$ 与质量 $i+1$ 的弹簧的劲度系数为 $k_i$（其中 $i=1,\\dots,N-1$），连接质量 $N$ 与右墙的弹簧的劲度系数为 $k_N$。所有弹簧都遵循胡克定律。弹簧的劲度系数独立地从闭区间 $\\left[k_{\\mathrm{avg}} - \\frac{w}{2},\\, k_{\\mathrm{avg}} + \\frac{w}{2}\\right]$ 上的均匀随机分布中抽取，并满足每个实现的劲度系数都必须为正的约束。链的两端是固定的（墙壁处无位移）。没有外力作用在这些质量上。\n\n从牛顿第二定律和胡克定律出发，推导控制小振荡的线性化方程，将其简化为简正模的矩阵本征值问题，并实现一个程序，该程序能为给定参数构建动力学矩阵，数值计算所有简正模，并使用逆参与率（IPR）来量化局域化。对于动力学矩阵的归一化本征矢量 $\\mathbf{v}=\\left(v_1,\\dots,v_N\\right)$，将逆参与率（IPR）定义为 $I=\\sum_{i=1}^{N} v_i^4$。IPR 是无量纲的。扩展模的 $I$ 在 $1/N$ 的量级，而强局域模的 $I$ 则显著更大。\n\n您的程序必须：\n1. 对于每个指定的参数集，通过从指定的均匀分布中独立抽样来生成无序的弹簧劲度系数，使用固定的伪随机种子以保证可复现性，并构建由牛顿第二定律、胡克定律和固定墙壁边界条件所对应的动力学矩阵。\n2. 计算动力学矩阵的所有本征值和归一化本征矢量。如果需要，可将本征值解释为以 $\\text{rad}^2/\\text{s}^2$ 为单位的角频率的平方，但请注意，所要求的输出是无量纲的。\n3. 对于每次实现，计算每个模式的 IPR，然后在所有模式和所有实现上对 IPR 进行平均。将此平均 IPR 作为该参数集的单个浮点数报告。\n4. 对下面的整个测试套件重复这些步骤，并按规定格式聚合输出所有结果。\n\n使用以下参数集测试套件以确保覆盖不同的机制：\n- 测试用例 A（有序链，边界情况）：$N=64$， $m=1\\,\\text{kg}$， $k_{\\mathrm{avg}}=1\\,\\text{N}\\,\\text{m}^{-1}$， $w=0$，实现次数 $R=1$，随机种子 $s=1234$。此用例没有无序，应产生一个在 $1/N$ 量级的小的平均 IPR。\n- 测试用例 B（中等无序）：$N=64$， $m=1\\,\\text{kg}$， $k_{\\mathrm{avg}}=1\\,\\text{N}\\,\\text{m}^{-1}$， $w=0.6\\,\\text{N}\\,\\text{m}^{-1}$， $R=200$， $s=2024$。\n- 测试用例 C（强无序）：$N=64$， $m=1\\,\\text{kg}$， $k_{\\mathrm{avg}}=1\\,\\text{N}\\,\\text{m}^{-1}$， $w=1.8\\,\\text{N}\\,\\text{m}^{-1}$， $R=200$， $s=2024$。\n\n确保对于所有测试用例，均匀分布的边界 $\\left[k_{\\mathrm{avg}} - \\frac{w}{2},\\, k_{\\mathrm{avg}} + \\frac{w}{2}\\right]$ 都是严格为正的。IPR 是无量纲的，最终输出不需要进行单位换算。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试用例 A、B 和 C 的三个平均 IPR 值，格式为用方括号括起来的逗号分隔列表。每个值必须精确到小数点后六位。例如：$\\left[\\text{value}_A,\\text{value}_B,\\text{value}_C\\right]$ 以如下格式打印：\"[0.012345,0.067890,0.123456]\"。",
            "solution": "该问题已经过验证，并被确定为有效。这是一个在计算物理学中提法得当、有科学依据的问题，没有歧义和矛盾。因此，我们可以着手解决。\n\n问题的核心是分析一维耦合振子链的简正模。我们首先从第一性原理推导运动方程。\n\n设系统由 $N$ 个点质量组成，每个质量为 $m$。质量的索引从 $i=1$ 到 $N$。令 $x_i(t)$ 为第 $i$ 个质量偏离其平衡位置的位移。链的两端连接到固定的墙壁，这意味着对于所有时间 $t$，边界条件为 $x_0(t) = 0$ 和 $x_{N+1}(t) = 0$。连接左墙与质量 1 的弹簧的劲度系数为 $k_0$。连接质量 $i$ 与质量 $i+1$ 的弹簧的劲度系数为 $k_i$（其中 $i=1, \\dots, N-1$）。连接质量 $N$ 与右墙的弹簧的劲度系数为 $k_N$。总共有 $N+1$ 个弹簧。\n\n根据胡克定律，弹簧施加的力与其伸长量成正比。作用在质量 $i$ 上的合力是其左侧弹簧（劲度系数为 $k_{i-1}$）和右侧弹簧（劲度系数为 $k_i$）施加的力之和：\n$$F_i = F_{\\text{left}, i} + F_{\\text{right}, i} = k_{i-1}(x_{i-1} - x_i) + k_i(x_{i+1} - x_i)$$\n应用牛顿第二定律 $F_i = m\\ddot{x}_i$，我们得到用于描述小振荡的耦合微分方程组：\n$$m\\ddot{x}_i = k_{i-1}x_{i-1} - (k_{i-1} + k_i)x_i + k_i x_{i+1}$$\n该方程对 $i=1, \\dots, N$ 成立，并带有固定边界条件 $x_0 = 0$ 和 $x_{N+1} = 0$。\n\n为了找到简正模，我们寻找形式为 $x_i(t) = v_i e^{i\\omega t}$ 的解，其中 $\\omega$ 是角频率，$v_i$ 是质量 $i$ 不随时间变化的振幅。其二阶时间导数为 $\\ddot{x}_i(t) = -\\omega^2 v_i e^{i\\omega t}$。将此代入运动方程并消去公因子 $e^{i\\omega t}$ 可得：\n$$-m\\omega^2 v_i = k_{i-1}v_{i-1} - (k_{i-1} + k_i)v_i + k_i v_{i+1}$$\n重新排列各项，我们得到一个线性代数方程组：\n$$(k_{i-1} + k_i)v_i - k_{i-1}v_{i-1} - k_i v_{i+1} = m\\omega^2 v_i$$\n这个包含 $N$ 个方程的系统可以表示为一个矩阵本征值问题：\n$$\\mathbf{K}\\mathbf{v} = m\\omega^2\\mathbf{v}$$\n其中 $\\mathbf{v} = (v_1, \\dots, v_N)^T$ 是振幅的本征矢量，$\\mathbf{K}$ 是 $N \\times N$ 的刚度矩阵。$\\mathbf{K}$ 的元素由下式给出（使用基于 1 的索引）：\n$$K_{ij} = \\begin{cases} k_{i-1} + k_i & \\text{if } j=i \\\\ -k_i & \\text{if } j=i+1 \\\\ -k_{i-1} & \\text{if } j=i-1 \\\\ 0 & \\text{otherwise} \\end{cases}$$\n矩阵 $\\mathbf{K}$ 是实的、对称的、三对角的。为了将其转换为标准本征值问题，我们定义动力学矩阵 $\\mathbf{D} = \\frac{1}{m}\\mathbf{K}$ 和本征值 $\\lambda = \\omega^2$。问题变为：\n$$\\mathbf{D}\\mathbf{v} = \\lambda\\mathbf{v}$$\n$\\mathbf{D}$ 的本征值 $\\lambda_j$ 是简正模角频率的平方，相应的本征矢量 $\\mathbf{v}_j$ 描述了这些模式的空间分布。\n\n计算任务是实现这个模型。对每个参数集，步骤如下：\n1. 总共模拟 $R$ 次实现。对于每次实现，通过从区间 $\\left[k_{\\mathrm{avg}} - \\frac{w}{2}, k_{\\mathrm{avg}} + \\frac{w}{2}\\right]$ 上的均匀分布中独立随机抽样，生成一组 $N+1$ 个弹簧劲度系数 $\\{k_0, k_1, \\dots, k_N\\}$。使用固定的伪随机种子以确保可复现性。\n\n2. 构建 $N \\times N$ 的动力学矩阵 $\\mathbf{D}$。对于使用基于 0 的索引的实现，其中质量索引为 $0, \\dots, N-1$，弹簧劲度系数存储在长度为 $N+1$ 的数组 `k_const` 中，$\\mathbf{D}$ 的元素为：\n- 主对角线：$D_{i,i} = \\frac{\\texttt{k\\_const}[i] + \\texttt{k\\_const}[i+1]}{m}$，其中 $i=0, \\dots, N-1$。\n- 次对角线：$D_{i,i+1} = D_{i+1,i} = -\\frac{\\texttt{k\\_const}[i+1]}{m}$，其中 $i=0, \\dots, N-2$。\n\n3. 对称矩阵 $\\mathbf{D}$ 的本征值问题被数值求解。这将产生 $N$ 个实本征值 $\\lambda_j$ 和一组 $N$ 个相互正交的本征矢量 $\\mathbf{v}_j$。我们使用一个数值库函数（例如 `numpy.linalg.eigh`），它返回归一化为单位 L2 范数的本征矢量，即 $\\sum_{i=1}^{N} v_{ij}^2 = 1$。\n\n4. 对于每个归一化的本征矢量 $\\mathbf{v}_j$，使用公式 $I_j = \\sum_{i=1}^{N} v_{ij}^4$ 计算逆参与率（IPR）。这个无量纲量衡量了模式的局域化程度。一个扩展模（如正弦波）的 IPR 在 $1/N$ 的量级，而一个局域在少数几个格点上的模式则具有大得多的 IPR。\n\n5. 对于给定的参数集，最终结果是在所有 $N$ 个模式和所有 $R$ 次实现上计算的平均 IPR。这为给定无序水平下的局域化提供了一个统计度量。\n\n对每个指定的测试用例重复整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_average_ipr(N, m, k_avg, w, R, seed):\n    \"\"\"\n    Computes the average Inverse Participation Ratio (IPR) for a disordered chain.\n\n    Args:\n        N (int): Number of masses.\n        m (float): Mass of each oscillator.\n        k_avg (float): Average spring constant.\n        w (float): Width of the uniform distribution for spring constants.\n        R (int): Number of realizations for averaging.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The average IPR over all modes and all realizations.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # This list will store IPR values for each mode of each realization.\n    all_iprs = []\n\n    for _ in range(R):\n        # 1. Generate N+1 spring constants for one realization.\n        k_low = k_avg - w / 2.0\n        k_high = k_avg + w / 2.0\n        \n        # Spring constants k_0, k_1, ..., k_N\n        k_constants = rng.uniform(k_low, k_high, size=N + 1)\n        \n        # 2. Construct the dynamical matrix D (size N x N).\n        # We use 0-based indexing for the masses (0 to N-1).\n        # The main diagonal elements D_ii are (k_i + k_{i+1}) / m.\n        # This translates to (k_constants[0...N-1] + k_constants[1...N]) / m.\n        diag_elements = (k_constants[:-1] + k_constants[1:]) / m\n        \n        # The off-diagonal elements D_{i,i+1} are -k_{i+1} / m.\n        # This translates to -k_constants[1...N-1] / m.\n        off_diag_elements = -k_constants[1:-1] / m\n        \n        # Efficiently construct the tridiagonal matrix.\n        D = np.diag(diag_elements) + np.diag(off_diag_elements, k=1) + np.diag(off_diag_elements, k=-1)\n        \n        # 3. Compute eigenvalues and eigenvectors.\n        # np.linalg.eigh is used for symmetric matrices. It is efficient and\n        # returns real eigenvalues and normalized eigenvectors (L2 norm = 1).\n        _, eigvecs = np.linalg.eigh(D)\n        \n        # 4. Compute IPR for each mode.\n        # The columns of eigvecs are the eigenvectors.\n        # IPR is defined as sum(v_i^4) for each eigenvector v.\n        # The operation is vectorized for efficiency.\n        iprs_for_realization = np.sum(eigvecs**4, axis=0)\n        \n        all_iprs.extend(iprs_for_realization)\n        \n    # 5. Average IPR over all modes and all realizations.\n    return np.mean(all_iprs)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, m, k_avg, w, R, seed)\n        (64, 1.0, 1.0, 0.0, 1, 1234),    # Test case A\n        (64, 1.0, 1.0, 0.6, 200, 2024),  # Test case B\n        (64, 1.0, 1.0, 1.8, 200, 2024),  # Test case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m, k_avg, w, R, seed = case\n        avg_ipr = compute_average_ipr(N, m, k_avg, w, R, seed)\n        results.append(f\"{avg_ipr:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}