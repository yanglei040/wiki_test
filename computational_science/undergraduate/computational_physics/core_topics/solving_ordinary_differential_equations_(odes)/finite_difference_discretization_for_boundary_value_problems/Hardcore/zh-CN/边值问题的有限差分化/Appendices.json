{
    "hands_on_practices": [
        {
            "introduction": "虽然有限差分法为求解边值问题（BVP）提供了一个强大的框架，但其精度直接受网格间距 $h$ 的影响。本练习将引导您超越基本离散化，探索一种名为理查森外推（Richardson extrapolation）的强大技术。通过在两个不同尺度的网格上求解同一个问题，并巧妙地组合这两个数值解，您可以系统地消除截断误差中的主导项，从而以较小的计算成本获得更高阶的精度。",
            "id": "2392773",
            "problem": "考虑单位区间上的两点边值问题：寻找一个函数 $u(x)$，使得\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\n其中 $\\sin(\\cdot)$ 使用弧度制角。令 $n$ 表示在 $[0,1]$ 的均匀网格上的内部网格点数，网格间距为 $h = \\frac{1}{n+1}$，节点为 $x_i = i h$，其中 $i=0,1,\\ldots,n+1$。在此网格上，使用标准的二阶中心有限差分来近似 $u''(x)$，精确施加狄利克雷（Dirichlet）边界条件 $u(0)=0$ 和 $u(1)=0$，并求解得到的线性系统以获得内部未知数。\n\n接下来，通过将网格间距减半来加密网格（即，使用具有 $m = 2n+1$ 个内部点的网格，使得加密后的间距为 $h/2$，并且加密后的内部节点与粗网格节点重合）。在加密后的网格上求解相同的离散问题。使用理查森外推法（Richardson extrapolation），假设主截断误差与 $h^2$ 成正比，将两个数值解结合起来，以在粗网格内部节点上获得更高精度的近似值。\n\n使用精确解析解 $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$ 来量化精度。对于下面指定的每个测试用例，计算在粗网格内部节点上评估的理查森外推解的最大绝对误差，即：\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|.\n$$\n\n测试套件：\n- 用例 1：$n=1$。\n- 用例 2：$n=4$。\n- 用例 3：$n=10$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含上述用例的三个结果 $E_\\infty$，按顺序排列，并以逗号分隔的列表形式包含在方括号内（例如，$[e_1,e_2,e_3]$）。每个 $e_k$ 都必须是一个实数（浮点值）。不应打印任何其他文本。",
            "solution": "所呈现的问题是微分方程领域中一个适定的两点边值问题（BVP）。它具有科学依据，并包含了获得唯一数值解所需的所有必要信息。所提出的方法，即采用有限差分和理查森外推法，是计算物理学中的一种标准且有效的技术。因此，该问题是有效的，并将给出解答。\n\n问题是找到一个函数 $u(x)$，满足以下二阶常微分方程和边界条件：\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1)\n$$\n$$\nu(0)=0, \\quad u(1)=0\n$$\n其解析解为 $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$，这可以通过直接求导和代入来验证。\n\n第一步是使用均匀网格对定义域 $[0,1]$ 进行离散化。对于给定的整数 $n$，我们定义 $n$ 个内部网格点。网格间距为 $h = \\frac{1}{n+1}$，网格节点为 $x_i = ih$，其中 $i=0, 1, \\ldots, n+1$。解在这些节点上的值表示为 $u_i = u(x_i)$。边界条件规定了 $u_0 = 0$ 和 $u_{n+1} = 0$。我们寻求找到未知值 $u_i$，其中 $i=1, 2, \\ldots, n$。\n\n在内部节点 $x_i$ 处的二阶导数 $u''(x)$ 使用二阶精度的中心有限差分公式来近似：\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此近似代入原微分方程，得到关于未知数 $u_i$ 的代数方程组：\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = -\\sin(\\pi x_i), \\quad \\text{for } i = 1, 2, \\ldots, n\n$$\n整理这个方程，我们得到：\n$$\nu_{i-1} - 2u_i + u_{i+1} = -h^2 \\sin(\\pi x_i)\n$$\n结合边界条件（$u_0=0$ 和 $u_{n+1}=0$），我们可以写出第一个和最后一个内部节点的方程：\n对于 $i=1$：$u_0 - 2u_1 + u_2 = -h^2 \\sin(\\pi x_1) \\implies -2u_1 + u_2 = -h^2 \\sin(\\pi x_1)$。\n对于 $i=n$：$u_{n-1} - 2u_n + u_{n+1} = -h^2 \\sin(\\pi x_n) \\implies u_{n-1} - 2u_n = -h^2 \\sin(\\pi x_n)$。\n\n这 $n$ 个方程构成一个 $A \\mathbf{u} = \\mathbf{b}$ 形式的线性方程组，其中 $\\mathbf{u} = [u_1, u_2, \\ldots, u_n]^T$ 是内部节点上未知解值的向量。矩阵 $A$ 是一个 $n \\times n$ 的对称三对角矩阵，向量 $\\mathbf{b}$ 是右侧项。\n$$\nA = \\begin{pmatrix}\n-2  1  0  \\cdots  0 \\\\\n1  -2  1  \\cdots  0 \\\\\n0  1  -2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  -2  1 \\\\\n0  0  \\cdots  1  -2\n\\end{pmatrix}, \\quad \\mathbf{b} = -h^2 \\begin{pmatrix}\n\\sin(\\pi x_1) \\\\\n\\sin(\\pi x_2) \\\\\n\\vdots \\\\\n\\sin(\\pi x_n)\n\\end{pmatrix}\n$$\n该线性系统是对角占优的，因此有唯一解，可以使用标准的数值线性代数方法求得。\n\n该问题要求使用理查森外推法来提高解的精度。中心差分格式的全局误差具有关于 $h$ 的偶次幂的渐近展开式：\n$$\nu_h(x) = u_{\\text{exact}}(x) + C_1(x)h^2 + C_2(x)h^4 + \\dots\n$$\n其中 $u_h(x)$ 是在点 $x$ 处使用网格间距 $h$ 计算得到的数值解。\n\n我们计算两个数值解：\n1. 一个粗网格解 $\\mathbf{u}_h$，该网格有 $n$ 个内部点，间距为 $h = \\frac{1}{n+1}$。\n2. 一个细网格解 $\\mathbf{u}_{h/2}$，该网格有 $m = 2n+1$ 个内部点，间距为 $h/2 = \\frac{1}{m+1}$。\n\n在粗网格节点 $x_i$ 上，我们对精确解 $u_{\\text{exact}}(x_i)$ 有以下近似：\n$$\nu_h(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)h^2\n$$\n$$\nu_{h/2}(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)(h/2)^2 = u_{\\text{exact}}(x_i) + \\frac{1}{4}C_1(x_i)h^2\n$$\n我们可以通过代数组合这两个表达式来消除主误差项 $C_1(x_i)h^2$。将第二个方程乘以 4 并减去第一个方程，得到：\n$$\n4u_{h/2}(x_i) - u_h(x_i) \\approx 3u_{\\text{exact}}(x_i)\n$$\n这导出了理查森外推解 $u_{\\text{RE}}(x_i)$，其误差阶为 $O(h^4)$：\n$$\nu_{\\text{RE}}(x_i) = \\frac{4u_{h/2}(x_i) - u_h(x_i)}{3}\n$$\n对粗网格上的每个节点 $x_i$（$i = 1, \\ldots, n$）都执行此外推。注意，粗网格节点 $\\{x_i\\}$ 是细网格节点的一个子集。具体来说，粗网格节点 $x_i = i h$ 对应于相同位置的细网格节点，即细网格上的第 $(2i)$ 个内部节点。\n\n最后一步是量化外推解的精度。对于每个测试用例，我们计算在粗内部网格点上的最大绝对误差 $E_\\infty$：\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - u_{\\text{exact}}(x_i) \\right| = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|\n$$\n对每个测试值 $n$ 的计算过程如下：\n1.  求解具有 $n$ 个内部点的粗网格的 BVP，得到 $\\mathbf{u}_h$。\n2.  求解具有 $m=2n+1$ 个内部点的细网格的 BVP，得到 $\\mathbf{u}_{h/2}$。\n3.  从 $\\mathbf{u}_{h/2}$ 中提取与粗网格位置相对应的值。\n4.  计算理查森外推解向量 $\\mathbf{u}_{\\text{RE}}$。\n5.  计算粗网格点上的精确解。\n6.  计算最大绝对误差 $E_\\infty$。\n\n此过程将针对指定的测试用例进行实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(n):\n    \"\"\"\n    Solves the BVP u''(x) = -sin(pi*x) on [0,1] with u(0)=u(1)=0\n    using a centered finite difference scheme with n interior points.\n\n    Args:\n        n (int): The number of interior grid points.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The solution vector u at the interior points.\n            - np.ndarray: The x-coordinates of the interior points.\n    \"\"\"\n    if n == 0:\n        return np.array([]), np.array([])\n    \n    # Grid spacing\n    h = 1.0 / (n + 1)\n    \n    # Interior grid points\n    x_interior = np.linspace(h, 1.0 - h, n)\n    \n    # Construct the right-hand side vector b\n    b = -h**2 * np.sin(np.pi * x_interior)\n    \n    # Construct the tridiagonal matrix A\n    A = np.diag(-2 * np.ones(n)) + np.diag(np.ones(n - 1), k=1) + np.diag(np.ones(n - 1), k=-1)\n    \n    # Solve the linear system Au = b\n    u = np.linalg.solve(A, b)\n    \n    return u, x_interior\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all test cases and print the result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 4, 10]\n\n    results = []\n    for n in test_cases:\n        # 1. Solve on coarse mesh\n        u_coarse, x_coarse = solve_bvp(n)\n        \n        # 2. Solve on fine mesh\n        m = 2 * n + 1\n        u_fine, _ = solve_bvp(m)\n        \n        # 3. Extract fine solution at coarse grid points\n        # The coarse grid points correspond to every second point of the fine grid's interior.\n        # Python indices are 0-based. The i-th coarse point (1-indexed) is at the same\n        # spatial location as the (2i)-th fine point (1-indexed).\n        # This corresponds to slicing u_fine with [1::2].\n        u_fine_at_coarse_points = u_fine[1::2]\n\n        # 4. Apply Richardson extrapolation\n        # u_RE = (4 * u_h/2 - u_h) / 3\n        u_re = (4.0 * u_fine_at_coarse_points - u_coarse) / 3.0\n        \n        # 5. Compute exact solution at coarse grid points\n        u_exact = np.sin(np.pi * x_coarse) / (np.pi**2)\n        \n        # 6. Calculate the maximum absolute error\n        max_error = np.max(np.abs(u_re - u_exact))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理现象，例如静电场或稳态热分布，本质上是多维的。本练习将带领您从一维问题迈向二维空间，解决物理学中最经典的模型之一——方形区域内的拉普拉斯方程。您将学习如何使用“五点模板”来离散化二维拉普拉斯算子，将偏微分方程转化为一个大型线性方程组，并求解区域内部的电势分布。掌握此方法是解决各类描述稳态问题的椭圆型偏微分方程的基石。",
            "id": "2392730",
            "problem": "考虑一个方形区域内的静电势场，该区域由无自由电荷的静电学原理控制。其基本原理是，在静电学中，电场满足 $ \\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0 $ 且 $ \\mathbf{E} = -\\nabla \\phi $。对于一个 $ \\rho = 0 $（无自由电荷）的区域，电势 $ \\phi(x,y) $ 满足二维拉普拉斯方程 $ \\nabla^2 \\phi = 0 $，并带有 Dirichlet 边界条件（即在边界上电势为固定值）。你需要使用有限差分法（FDM）和二阶中心差分来离散化这个边值问题，从而得到一个关于内部网格点值的线性方程组，并对其进行数值求解。\n\n一个边长为 $ L $（单位：米）的方形盒子，其右侧壁（$ x = L $）保持在固定电势 $ V_0 $（单位：伏特），而其他三个壁（$ x = 0 $，$ y = 0 $ 和 $ y = L $）接地，电势为 $ 0 $ 伏特。使用一个均匀网格，每个方向上有 $ N $ 个网格点（包括边界），因此网格间距为 $ h = L / (N-1) $。令 $ \\phi_{i,j} $ 表示网格点 $ (x_i, y_j) = (i h, j h) $ 处的离散电势，其中 $ i, j \\in \\{0, 1, \\dots, N-1\\} $。内部的未知量是那些满足 $ i, j \\in \\{1, 2, \\dots, N-2\\} $ 的点。使用二阶中心差分来近似 $ \\nabla^2 \\phi $，为内部值 $ \\phi_{i,j} $ 建立相应的线性方程组，施加四壁上的 Dirichlet 边界条件，并求解电势。\n\n你的程序必须：\n- 构建与均匀网格上的二阶中心差分近似相对应的五点差分格式离散拉普拉斯算子。\n- 根据 Dirichlet 边界条件，将边界值整合到方程组的右侧。其中，右侧壁（$ x=L $）的电势为 $ \\phi = V_0 $，其他三壁的电势为 $ \\phi = 0 $。\n- 求解该线性方程组以获得内部未知量。\n- 提取并报告几何中心 $ (x,y) = (L/2, L/2) $ 处的电势。假设 $ N $ 为奇数，以使几何中心与一个网格点重合。以伏特为单位报告中心点的值。\n\n物理单位：电势必须以伏特为单位报告，表示为四舍五入到六位小数的浮点数。\n\n角度单位：不涉及角度。\n\n你的程序应使用以下测试套件，每个测试用例指定为一个元组 $ (L, N, V_0) $，其中 $ L $ 的单位为米，$ V_0 $ 的单位为伏特：\n- 测试 $ 1 $: $ (L, N, V_0) = (1.0, 3, 1.0) $\n- 测试 $ 2 $: $ (L, N, V_0) = (1.0, 5, 1.0) $\n- 测试 $ 3 $: $ (L, N, V_0) = (1.0, 21, 2.0) $\n\n对于每个测试，计算一个浮点数：几何中心处的 $ \\phi $ 值（单位：伏特），四舍五入到六位小数。你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，结果顺序与上述测试顺序一致。例如，格式必须与 $ [r_1,r_2,r_3] $ 完全一样，其中每个 $ r_k $ 是一个小数点后有六位数的小数浮点数。",
            "solution": "所呈现的问题是静电学中的一个经典边值问题，具体是在方形域内求解具有指定 Dirichlet 边界条件的二维拉普拉斯方程。该问题具有科学依据，是适定的，并包含了数值求解所需的所有必要信息。因此，该问题被认为是有效的。\n\n在无电荷区域（$\\rho=0$）中，静电势 $\\phi(x,y)$ 的控制偏微分方程是拉普拉斯方程：\n$$\n\\nabla^2 \\phi(x,y) = \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0\n$$\n区域是一个边长为 $L$ 的正方形，由 $x \\in [0, L]$ 和 $y \\in [0, L]$ 定义。边界条件为 Dirichlet 类型，意味着电势在边界上是固定的：\n- $\\phi(x,0) = 0$ (底壁)\n- $\\phi(x,L) = 0$ (顶壁)\n- $\\phi(0,y) = 0$ (左壁)\n- $\\phi(L,y) = V_0$ (右壁)\n\n为了数值求解此问题，我们采用有限差分法（FDM）。首先，将连续域离散化为一个由点 $(x_i, y_j)$ 组成的均匀网格，其中 $x_i = i h$ 且 $y_j = j h$。网格间距 $h$ 由 $h = L / (N-1)$ 给出，其中 $N$ 是每个方向上的网格点数。网格索引 $i$ 和 $j$ 的范围是从 $0$ 到 $N-1$。网格点 $(x_i, y_j)$ 处的电势记为 $\\phi_{i,j}$。\n\n二阶偏导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2}\n$$\n将这些近似值代入每个内部网格点（其中 $i, j \\in \\{1, 2, \\dots, N-2\\}$）的拉普拉斯方程，得到：\n$$\n\\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2} = 0\n$$\n两边乘以 $h^2$ 并重新整理各项，得到五点差分格式方程。该方程表明，一个内部点的电势是其四个最近邻点电势的平均值：\n$$\n4\\phi_{i,j} - \\phi_{i+1,j} - \\phi_{i-1,j} - \\phi_{i,j+1} - \\phi_{i,j-1} = 0\n$$\n该方程必须对所有 $M = (N-2)^2$ 个内部点都成立。这组方程构成了一个形如 $A\\vec{\\Phi} = \\vec{b}$ 的线性方程组，其中 $\\vec{\\Phi}$ 是一个包含内部点未知电势 $\\phi_{i,j}$ 的向量。\n\n为了构建该系统，我们必须将二维的未知数网格“展平”为一个一维向量 $\\vec{\\Phi}$。这需要一个一致的映射。我们使用列主序，其中未知数 $\\phi_{i,j}$（$i, j \\in \\{1, \\dots, N-2\\}$）的索引 $k$ 由 $k = (i-1)(N-2) + (j-1)$ 给出。\n\n矩阵 $A$ 是一个 $M \\times M$ 的矩阵，表示未知电势的系数。大小为 $M$ 的向量 $\\vec{b}$ 包含由已知边界值产生的项。对于一个内部点 $(i,j)$，方程重新整理为：\n$$\n4\\phi_{i,j} - \\phi_{i-1,j} - \\phi_{i+1,j} - \\phi_{i,j-1} - \\phi_{i,j-1} = b_{i,j}\n$$\n当一个邻近点 $(i', j')$ 位于边界上时，其电势 $\\phi_{i',j'}$ 是已知的。该项被移到方程的右侧。\n- 对于邻近左壁的点（$i=1$），项 $\\phi_{0,j}=0$ 是已知的。\n- 对于邻近底壁的点（$j=1$），项 $\\phi_{i,0}=0$ 是已知的。\n- 对于邻近顶壁的点（$j=N-2$），项 $\\phi_{i,N-1}=0$ 是已知的。\n这些零电势边界对右侧向量 $\\vec{b}$ 没有贡献。\n- 对于邻近右壁的点（$i=N-2$），项 $\\phi_{N-1,j}=V_0$ 是已知的。这样一个点的方程变为 $4\\phi_{N-2,j} - \\phi_{N-3,j} - \\phi_{N-2,j-1} - \\phi_{N-2,j+1} = V_0$。\n\n因此，向量 $\\vec{b}$ 的分量对于所有点都为零，除了那些邻近右壁的点（其中 $i = N-2$），其值为 $V_0$。矩阵 $A$ 具有稀疏的块三对角结构，主对角线上为 $4$，在某些对应于网格中邻近点的次对角线上为 $-1$。\n\n一旦矩阵 $A$ 和向量 $\\vec{b}$ 构建完成，就求解线性系统 $A\\vec{\\Phi} = \\vec{b}$ 以得到未知电势向量 $\\vec{\\Phi}$。\n\n最后一步是提取正方形几何中心 $(L/2, L/2)$ 处的电势。由于指定 $N$ 为奇数，该中心与一个网格点 $(x_{i_c}, y_{j_c})$ 重合，其索引为 $i_c = j_c = (N-1)/2$。对于 $N \\ge 3$，这些索引落在内部点范围 $\\{1, \\dots, N-2\\}$ 内。该点的电势是解向量 $\\vec{\\Phi}$ 的一个元素，可以使用相同的索引映射来定位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_laplace(L, N, V0):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using the Finite Difference Method.\n\n    Args:\n        L (float): Side length of the square domain in meters.\n        N (int): Number of grid points in each direction.\n        V0 (float): Potential on the right wall in volts.\n\n    Returns:\n        float: The potential at the geometric center of the grid.\n    \"\"\"\n    # Number of interior grid points in one dimension.\n    N_int = N - 2\n\n    # If N = 2, there are no interior points to solve for.\n    if N_int = 0:\n        return 0.0\n\n    # Total number of unknown interior potentials.\n    M = N_int * N_int\n\n    # Initialize the matrix A and vector b for the linear system A*phi = b.\n    A = np.zeros((M, M))\n    b = np.zeros(M)\n\n    # Function to map 2D interior grid indices (ii, jj) to a 1D vector index k.\n    # We use 0-indexed interior indices: ii, jj in [0, N_int-1].\n    # These correspond to original grid indices i=ii+1, j=jj+1.\n    # The mapping is column-major.\n    map_k = lambda ii, jj: ii * N_int + jj\n\n    for ii in range(N_int):  # Corresponds to x-direction index i = ii + 1\n        for jj in range(N_int):  # Corresponds to y-direction index j = jj + 1\n            k = map_k(ii, jj)\n\n            # Main diagonal from the term 4*phi_i,j\n            A[k, k] = 4\n\n            # Neighbor in negative x-direction (i-1, j)\n            if ii > 0:  # Neighbor is an interior point\n                A[k, map_k(ii - 1, jj)] = -1\n            # else: neighbor is on the boundary x=0, where phi=0. No contribution to b.\n\n            # Neighbor in positive x-direction (i+1, j)\n            if ii  N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii + 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=L, where phi=V0\n                b[k] += V0\n\n            # Neighbor in negative y-direction (i, j-1)\n            if jj > 0:  # Neighbor is an interior point\n                A[k, map_k(ii, jj - 1)] = -1\n            # else: neighbor is on the boundary y=0, where phi=0. No contribution to b.\n\n            # Neighbor in positive y-direction (i, j+1)\n            if jj  N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii, jj + 1)] = -1\n            # else: neighbor is on the boundary y=L, where phi=0. No contribution to b.\n    \n    # Solve the linear system for the unknown interior potentials.\n    phi_sol = np.linalg.solve(A, b)\n\n    # Find the potential at the geometric center.\n    # Since N is odd, the center (L/2, L/2) is a grid point.\n    center_grid_idx = (N - 1) // 2\n    \n    # Convert grid index to 0-indexed interior index.\n    ii_center = center_grid_idx - 1\n    jj_center = center_grid_idx - 1\n    \n    # Get the 1D vector index for the center point.\n    k_center = map_k(ii_center, jj_center)\n\n    return phi_sol[k_center]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 3, 1.0),\n        (1.0, 5, 1.0),\n        (1.0, 21, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, V0 = case\n        center_potential = solve_laplace(L, N, V0)\n        # Round the result to six decimal places as required.\n        results.append(f\"{center_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当处理二维或三维问题时，通过有限差分法产生的线性方程组的规模可能非常庞大，以至于直接求解（例如，通过矩阵求逆）变得不切实际。本练习介绍了一种优雅而强大的迭代求解策略——“虚拟时间”演化法。您将把一个泊松方程的求解过程，看作是一个相关的扩散（热传导）过程在达到稳态时的最终结果，通过在虚拟时间中步进，让解逐步“松弛”到正确的状态。这种方法是计算科学中迭代思想的绝佳体现，为处理大规模问题提供了重要思路。",
            "id": "2392695",
            "problem": "考虑单位正方形上的泊松边界值问题。令 $\\Omega = (0,1)\\times(0,1)$，其边界为 $\\partial\\Omega$。对于给定的源函数 $f:\\overline{\\Omega}\\rightarrow\\mathbb{R}$，求 $u:\\overline{\\Omega}\\rightarrow\\mathbb{R}$ 使得\n$$\n\\nabla^2 u(x,y) = f(x,y)\\quad \\text{对于 }(x,y)\\in\\Omega,\\qquad u(x,y)=0\\quad \\text{对于 }(x,y)\\in\\partial\\Omega.\n$$\n所有量均为无量纲。任何三角函数的求值都必须使用弧度制角。\n\n你需要计算以下抛物型初边值问题的稳态解\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) = \\nabla^2 u(x,y,t) - f(x,y),\\quad (x,y)\\in\\Omega,\\ t0,\n$$\n其齐次狄利克雷边界条件为 $u(x,y,t)=0$（对于 $(x,y)\\in\\partial\\Omega$），初始条件为 $u(x,y,0)=0$（对于 $(x,y)\\in\\Omega$）。当 $t\\to\\infty$ 时的稳态解即为上述泊松问题的解。\n\n使用均匀的笛卡尔网格对 $\\Omega$ 进行离散化，每个空间方向有 $N$ 个内部点，因此网格间距为 $h=1/(N+1)$。在内部点上使用标准的二阶中心有限差分近似拉普拉斯算子，通过在边界节点上固定为零值来施加边界条件，并使用常数时间步长 $\\Delta t=\\theta h^2$（其中 $\\theta=0.24$）在虚拟时间中进行演化。从 $t=0$ 时的 $u\\equiv 0$ 开始，执行显式时间步进，直到残差的离散 $\\ell_2$ 范数，\n$$\nR_h = \\left(h^2\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\left[\\left(\\nabla_h^2 u\\right)_{i,j} - f(x_i,y_j)\\right]^2\\right)^{1/2},\n$$\n满足 $R_h  \\varepsilon$。其中 $(\\nabla_h^2 u)_{i,j}$ 是内部网格点 $(x_i,y_j)$ 处的五点离散拉普拉斯算子，且对于 $i,j\\in\\{1,2,\\dots,N\\}$，有 $(x_i,y_j)=(ih,jh)$。为防止程序不终止，每种情况最多使用 $200000$ 个时间步。\n\n为了验证，下文为每个测试用例规定了精确解 $u_{\\text{exact}}$ 和相应的源函数 $f$。收敛后，计算离散 $\\ell_2$ 误差\n$$\nE_h = \\left(h^2\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\left[u_{i,j}-u_{\\text{exact}}(x_i,y_j)\\right]^2\\right)^{1/2}.\n$$\n\n测试套件（每个用例都是独立的，必须使用其自身的参数运行）：\n\n- 用例 $\\mathsf{A}$：$N=64$，$\\varepsilon=10^{-8}$，$u_{\\text{exact}}(x,y)=\\sin(\\pi x)\\sin(\\pi y)$，$f(x,y)=\\nabla^2 u_{\\text{exact}}(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。\n\n- 用例 $\\mathsf{B}$：$N=32$，$\\varepsilon=10^{-8}$，$u_{\\text{exact}}(x,y)=\\sin(2\\pi x)\\sin(\\pi y)$，$f(x,y)=\\nabla^2 u_{\\text{exact}}(x,y)=-5\\pi^2\\sin(2\\pi x)\\sin(\\pi y)$。\n\n- 用例 $\\mathsf{C}$：$N=24$，$\\varepsilon=10^{-10}$，$u_{\\text{exact}}(x,y)=x(1-x)\\,y(1-y)$，$f(x,y)=\\nabla^2 u_{\\text{exact}}(x,y)=-2\\big(x(1-x)+y(1-y)\\big)$。\n\n要求的最终输出格式：您的程序应生成单行输出，包含三个值 $[E_h^{(\\mathsf{A})},E_h^{(\\mathsf{B})},E_h^{(\\mathsf{C})}]$，其中 $E_h^{(\\cdot)}$ 是相应情况的离散 $\\ell_2$ 误差。每个数字必须是浮点值，并采用科学记数法格式化，小数点后精确到八位。例如，一个可接受的格式是 $[1.23456789e-04,2.34567891e-05,3.45678912e-06]$。",
            "solution": "该问题要求在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上，使用齐次狄利克雷边界条件，数值求解二维泊松方程。控制偏微分方程（PDE）为：\n$$\n\\nabla^2 u(x,y) = f(x,y) \\quad \\text{对于 } (x,y) \\in \\Omega\n$$\n边界条件为 $u(x,y) = 0$（对于 $(x,y) \\in \\partial\\Omega$），其中 $\\partial\\Omega$ 是正方形区域的边界。\n\n指定的求解方法是找到一个相关抛物型偏微分方程的稳态极限，这是一种常见的松弛技术。我们求解以下瞬态问题：\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) = \\nabla^2 u(x,y,t) - f(x,y)\n$$\n从初始状态 $u(x,y,0) = 0$ 开始，并在边界 $\\partial\\Omega$ 上施加相同的边界条件 $u(x,y,t)=0$。随着虚拟时间 $t$ 趋于无穷，时间导数 $\\frac{\\partial u}{\\partial t}$ 预计将收敛到零。届时，解 $u(x,y,t)$ 将收敛到一个满足 $\\nabla^2 u - f = 0$ 的稳态 $u(x,y)$，这正是原始的泊松方程。\n\n为了进行数值实现，首先使用均匀的笛卡尔网格对区域进行离散化。在每个空间方向上有 $N$ 个内部点，网格间距为 $h = 1/(N+1)$。网格点由 $(x_i, y_j) = (ih, jh)$ 给出，其中 $i, j \\in \\{0, 1, \\dots, N+1\\}$。在这些点上的数值解记为 $u_{i,j}$。如果 $i, j \\in \\{1, \\dots, N\\}$，则点为内部点，否则为边界点。\n\n空间算子，即拉普拉斯算子 $\\nabla^2$，在每个内部点 $(x_i, y_j)$ 处使用二阶精度的五点中心差分格式进行近似：\n$$\n(\\nabla_h^2 u)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n时间导数使用显式前向欧拉方法进行离散。设 $u_{i,j}^k$ 表示在时间步 $k$ 处的解。从时间 $t_k = k\\Delta t$ 到 $t_{k+1} = (k+1)\\Delta t$ 的更新由下式给出：\n$$\n\\frac{u_{i,j}^{k+1} - u_{i,j}^k}{\\Delta t} = (\\nabla_h^2 u^k)_{i,j} - f_{i,j}\n$$\n其中 $f_{i,j} = f(x_i, y_j)$。这可以重排为内部点解的显式更新规则：\n$$\nu_{i,j}^{k+1} = u_{i,j}^k + \\Delta t \\left( (\\nabla_h^2 u^k)_{i,j} - f_{i,j} \\right)\n$$\n括号中的项是离散泊松方程在第 $k$ 步的残差，我们称之为 $r_{i,j}^k$。问题指定时间步长为 $\\Delta t = \\theta h^2$，其中 $\\theta = 0.24$。对于二维热方程的这种显式格式，该 $\\theta$ 值的选择低于稳定性极限 $\\theta_{max} = 0.25$，从而确保了时间演化的数值稳定性。\n\n迭代过程从一个全零网格 $u_{i,j}^0 = 0$ 开始，这同时满足了初始条件和齐次边界条件。迭代持续进行，直到残差的离散 $\\ell_2$ 范数，\n$$\nR_h = \\left(h^2 \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left(r_{i,j}^k\\right)^2 \\right)^{1/2} = \\left(h^2 \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left[(\\nabla_h^2 u^k)_{i,j} - f_{i,j}\\right]^2 \\right)^{1/2}\n$$\n小于给定的容差 $\\varepsilon$。为安全起见，设置了 $200000$ 次迭代的上限。\n\n一旦迭代收敛，通过计算离散 $\\ell_2$ 误差，将最终数值解 $u_{i,j}$ 与已知的精确解 $u_{\\text{exact}}(x_i, y_j)$ 进行比较：\n$$\nE_h = \\left(h^2 \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left[u_{i,j} - u_{\\text{exact}}(x_i, y_j)\\right]^2 \\right)^{1/2}\n$$\n对三个测试用例中的每一个都执行此过程，并报告所得的误差范数 $E_h$。该实现使用 `numpy` 来高效地进行基于数组的拉普拉斯算子、残差、范数和解更新的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(N, epsilon, u_exact_func, f_func):\n    \"\"\"\n    Solves the Poisson BVP for a single test case using fictitious time stepping.\n\n    Args:\n        N (int): Number of interior grid points in each direction.\n        epsilon (float): Convergence tolerance for the residual norm.\n        u_exact_func (callable): Function for the exact solution u_exact(x, y).\n        f_func (callable): Function for the source term f(x, y).\n\n    Returns:\n        float: The discrete l2-error E_h of the final solution.\n    \"\"\"\n    # Grid and time step parameters\n    h = 1.0 / (N + 1)\n    dt = 0.24 * h**2\n    max_steps = 200000\n\n    # Grid coordinates for interior points\n    x_int = np.linspace(h, 1.0 - h, N)\n    y_int = np.linspace(h, 1.0 - h, N)\n    X, Y = np.meshgrid(x_int, y_int, indexing='ij')\n\n    # Initialize solution grid u (size (N+2)x(N+2)) to all zeros.\n    # This automatically sets initial condition u(x,y,0)=0 and\n    # boundary condition u=0 on the boundary.\n    u = np.zeros((N + 2, N + 2), dtype=np.float64)\n    \n    # Evaluate source function on the interior grid\n    f_grid = f_func(X, Y)\n\n    for _ in range(max_steps):\n        # Calculate discrete Laplacian on interior points.\n        lap_u = (u[2:, 1:-1] + u[:-2, 1:-1] + \n                 u[1:-1, 2:] + u[1:-1, :-2] - 4 * u[1:-1, 1:-1]) / h**2\n        \n        # Calculate residual field on interior points\n        res_grid = lap_u - f_grid\n        \n        # Calculate discrete l2-norm of the residual\n        # R_h = sqrt(h^2 * sum(res_grid^2)) = h * norm(res_grid)\n        R_h = h * np.linalg.norm(res_grid)\n        \n        # Check for convergence\n        if R_h  epsilon:\n            break\n            \n        # Update interior solution using forward Euler step\n        u[1:-1, 1:-1] += dt * res_grid\n\n    # After convergence, compute the error against the exact solution\n    u_exact_grid = u_exact_func(X, Y)\n    error_grid = u[1:-1, 1:-1] - u_exact_grid\n    \n    # Calculate discrete l2-error norm\n    # E_h = sqrt(h^2 * sum(error_grid^2)) = h * norm(error_grid)\n    E_h = h * np.linalg.norm(error_grid)\n    \n    return E_h\n\ndef solve():\n    # Centralized definition of pi for precision\n    pi = np.pi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'N': 64, 'epsilon': 1e-8, \n         'u_exact': lambda x, y: np.sin(pi * x) * np.sin(pi * y),\n         'f': lambda x, y: -2 * pi**2 * np.sin(pi * x) * np.sin(pi * y)},\n        # Case B\n        {'N': 32, 'epsilon': 1e-8,\n         'u_exact': lambda x, y: np.sin(2 * pi * x) * np.sin(pi * y),\n         'f': lambda x, y: -5 * pi**2 * np.sin(2 * pi * x) * np.sin(pi * y)},\n        # Case C\n        {'N': 24, 'epsilon': 1e-10,\n         'u_exact': lambda x, y: x * (1 - x) * y * (1 - y),\n         'f': lambda x, y: -2 * (x * (1 - x) + y * (1 - y))},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(case['N'], case['epsilon'], case['u_exact'], case['f'])\n        results.append(f\"{error:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}