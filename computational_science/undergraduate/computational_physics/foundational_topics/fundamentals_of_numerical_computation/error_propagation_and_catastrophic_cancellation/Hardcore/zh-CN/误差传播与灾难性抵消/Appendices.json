{
    "hands_on_practices": [
        {
            "introduction": "将数学公式直接翻译成代码有时会暗藏风险，尤其是在处理极限情况时。当两个几乎相等的数值相减时，会发生灾难性抵消（catastrophic cancellation），导致有效数字大量丢失。本练习  将通过函数 $f(x) = (\\tan(x) - \\sin(x))/x^3$ 在 $x \\to 0$ 时的求值，让你亲身体验这一过程。你将对比直接计算与经过三角恒等式变换后的数值稳定形式，从而理解如何通过代数重构来避免精度灾难。",
            "id": "2389878",
            "problem": "您的任务是评估在计算函数 $f(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$ 对于接近 $0$ 的 $x$ 值（以弧度为单位）时的数值稳定性和误差传播。您的程序必须为每个测试值 $x$ 实现两种不同的 $f(x)$ 数值计算方法，并量化每种计算相对于一个由截断级数展开式构建的高精度参考值的误差。\n\n定义和要求：\n\n- 使用弧度制。\n- 为任意给定的非零 $x$ 定义以下三种计算方法：\n  1. 直接计算 $f_{\\mathrm{dir}}(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$。\n  2. 通过三角变换获得的数值稳定计算\n     $$f_{\\mathrm{stab}}(x) = \\dfrac{2 \\sin(x) \\sin^2\\!\\left(\\dfrac{x}{2}\\right)}{x^3 \\cos(x)},$$\n     它通过使用 $1 - \\cos(x) = 2\\sin^2\\!\\left(\\dfrac{x}{2}\\right)$ 来避免相消误差。\n  3. 由 $f(x)$ 的 Maclaurin 级数在 $x^6$ 阶截断构建的参考值：\n     $$f_{\\mathrm{ref}}(x) = \\dfrac{1}{2} + \\dfrac{x^2}{8} + \\dfrac{91}{1680} x^4 + \\dfrac{529}{24192} x^6.$$\n     此参考值在 $|x| \\leq 10^{-1}$ 内有效，其余项为 $\\mathcal{O}(x^8)$。\n\n- 对于每个 $x$，计算绝对相对误差\n  $$E_{\\mathrm{dir}}(x) = \\dfrac{\\left| f_{\\mathrm{dir}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|}, \\quad E_{\\mathrm{stab}}(x) = \\dfrac{\\left| f_{\\mathrm{stab}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|}.$$\n\n测试集：\n\n计算并报告以下输入（均以弧度为单位）的误差：$x \\in \\{10^{-1}, 10^{-4}, 10^{-8}, -10^{-8}, 10^{-12}, 10^{-16}\\}$。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试值 $x$，该列表必须按顺序首先包含 $E_{\\mathrm{dir}}(x)$，然后是 $E_{\\mathrm{stab}}(x)$。对于上面按规定顺序给出的测试值，输出因此必须是\n$$[E_{\\mathrm{dir}}(10^{-1}), E_{\\mathrm{stab}}(10^{-1}), E_{\\mathrm{dir}}(10^{-4}), E_{\\mathrm{stab}}(10^{-4}), E_{\\mathrm{dir}}(10^{-8}), E_{\\mathrm{stab}}(10^{-8}), E_{\\mathrm{dir}}(-10^{-8}), E_{\\mathrm{stab}}(-10^{-8}), E_{\\mathrm{dir}}(10^{-12}), E_{\\mathrm{stab}}(10^{-12}), E_{\\mathrm{dir}}(10^{-16}), E_{\\mathrm{stab}}(10^{-16})].$$\n所有角度必须解释为弧度。所有报告的量必须是十进制浮点数。",
            "solution": "所述问题是有效的。这是一个计算物理学中适定（well-posed）的问题，它具有科学依据、内部一致且没有歧义。它探讨了灾难性抵消（catastrophic cancellation）这一基本数值概念及其缓解方法。\n\n核心任务是计算函数 $f(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$ 在 $x$ 接近 $0$ 时的值。此计算使用三种不同的方法来演示和量化数值误差。\n\n第一种方法是直接计算，$f_{\\mathrm{dir}}(x) = \\dfrac{\\tan(x) - \\sin(x)}{x^3}$。这种形式容易受到灾难性抵消的影响。对于 $x \\approx 0$，我们有 $\\tan(x) \\approx x$ 和 $\\sin(x) \\approx x$。在有限精度浮点运算中，计算 $\\tan(x) - \\sin(x)$ 涉及两个非常接近的数字相减。此操作会导致前面的有效数字相互抵消，留下的结果主要由表示误差主导。这种精度损失随后会被除以一个非常小的数 $x^3$ 而放大。\n\n为了理解 $f(x)$ 在 $x$ 很小时的行为，我们检查分子各部分的 Maclaurin 级数展开式：\n$$ \\tan(x) = x + \\frac{x^3}{3} + \\frac{2x^5}{15} + \\mathcal{O}(x^7) $$\n$$ \\sin(x) = x - \\frac{x^3}{6} + \\frac{x^5}{120} + \\mathcal{O}(x^7) $$\n将这些级数相减揭示了分子的真实行为：\n$$ \\tan(x) - \\sin(x) = \\left( \\frac{1}{3} - (-\\frac{1}{6}) \\right) x^3 + \\left( \\frac{2}{15} - \\frac{1}{120} \\right) x^5 + \\mathcal{O}(x^7) = \\frac{1}{2}x^3 + \\frac{1}{8}x^5 + \\mathcal{O}(x^7) $$\n因此，当 $x \\to 0$ 时，函数 $f(x)$ 趋于一个有限极限：\n$$ \\lim_{x \\to 0} f(x) = \\lim_{x \\to 0} \\frac{\\frac{1}{2}x^3 + \\frac{1}{8}x^5 + \\mathcal{O}(x^7)}{x^3} = \\frac{1}{2} $$\n直接公式试图通过减去两个大得多的 $\\mathcal{O}(x)$ 阶项来计算一个小的 $\\mathcal{O}(x^3)$ 阶首项，这正是数值灾难的根源。\n\n第二种方法 $f_{\\mathrm{stab}}(x)$ 采用三角恒等式来重构表达式以避免这种抵消。推导如下：\n$$ f(x) = \\frac{\\frac{\\sin(x)}{\\cos(x)} - \\sin(x)}{x^3} = \\frac{\\sin(x) \\left( \\frac{1}{\\cos(x)} - 1 \\right)}{x^3} = \\frac{\\sin(x) (1 - \\cos(x))}{x^3 \\cos(x)} $$\n对于小的 $x$，$1 - \\cos(x)$ 这一项仍然是一个有问题的减法。然而，可以用半角恒等式 $1 - \\cos(x) = 2 \\sin^2\\left(\\frac{x}{2}\\right)$ 来替换它。这就得出了数值稳定的形式：\n$$ f_{\\mathrm{stab}}(x) = \\frac{2 \\sin(x) \\sin^2\\left(\\frac{x}{2}\\right)}{x^3 \\cos(x)} $$\n这个表达式不包含近似相等量的减法，因此预期是数值稳定的。\n\n第三种方法使用 $f(x)$ 本身的截断 Maclaurin 级数，提供了一个高精度的参考值 $f_{\\mathrm{ref}}(x)$。从 $\\tan(x) - \\sin(x)$ 的展开式中，我们推导出 $f(x)$ 的级数：\n$$ f(x) = \\frac{\\frac{1}{2}x^3 + \\frac{1}{8}x^5 + \\frac{13}{240}x^7 + \\dots}{x^3} = \\frac{1}{2} + \\frac{1}{8}x^2 + \\frac{13}{240}x^4 + \\dots $$\n问题提供了一个更精确的截断式：\n$$ f_{\\mathrm{ref}}(x) = \\frac{1}{2} + \\frac{x^2}{8} + \\frac{91}{1680} x^4 + \\frac{529}{24192} x^6 $$\n这种多项式求值对于小的 $x$ 是内在稳定的，因为它只涉及正项（因为 $x$ 是平方的）的加法和乘法。这使其成为一个理想的基准。\n\n数值实现将包括三个分别对应于 $f_{\\mathrm{dir}}$、$f_{\\mathrm{stab}}$ 和 $f_{\\mathrm{ref}}$ 的函数。然后我们将遍历 $x$ 值的测试集：$\\{10^{-1}, 10^{-4}, 10^{-8}, -10^{-8}, 10^{-12}, 10^{-16}\\}$。对于每个 $x$，我们计算直接方法和稳定方法相对于参考值的绝对相对误差：\n$$ E_{\\mathrm{dir}}(x) = \\frac{\\left| f_{\\mathrm{dir}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|}, \\quad E_{\\mathrm{stab}}(x) = \\frac{\\left| f_{\\mathrm{stab}}(x) - f_{\\mathrm{ref}}(x) \\right|}{\\left| f_{\\mathrm{ref}}(x) \\right|} $$\n由于 $f_{\\mathrm{ref}}(x)$ 是一个正常数（$1/2$）和非负项之和，其值总是大于或等于 $1/2$，因此在误差计算中没有除以零的风险。函数 $f(x)$ 是一个偶函数，意味着 $f(x) = f(-x)$，所以 $x=10^{-8}$ 和 $x=-10^{-8}$ 的结果预期是相同的。\n\n实现将使用霍纳（Horner）方法对 $f_{\\mathrm{ref}}(x)$ 进行多项式求值，以优化性能并保持数值精度。最终输出将是一个包含每个测试用例按指定顺序计算出的误差 $E_{\\mathrm{dir}}(x)$ 和 $E_{\\mathrm{stab}}(x)$ 的列表。我们预计，随着 $|x| \\to 0$，$E_{\\mathrm{dir}}(x)$ 将急剧增加，而 $E_{\\mathrm{stab}}(x)$ 将保持很小，这证实了重构表达式的优越稳定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f_dir(x: float) -> float:\n    \"\"\"\n    Direct evaluation of f(x) = (tan(x) - sin(x)) / x**3.\n    This form is prone to catastrophic cancellation for x near 0.\n    \"\"\"\n    if x == 0.0:\n        return 0.5  # The limit as x -> 0\n    return (np.tan(x) - np.sin(x)) / (x**3)\n\ndef f_stab(x: float) -> float:\n    \"\"\"\n    Numerically stable evaluation of f(x) using trigonometric rearrangement.\n    f_stab(x) = (2 * sin(x) * sin(x/2)**2) / (x**3 * cos(x)).\n    \"\"\"\n    if x == 0.0:\n        return 0.5  # The limit as x -> 0\n    \n    # Pre-calculate common terms\n    sin_x = np.sin(x)\n    x_half = x / 2.0\n    sin_x_half = np.sin(x_half)\n    cos_x = np.cos(x)\n    x_cubed = x**3\n    \n    # Avoid division by zero if cos(x) is zero, though not for test cases\n    if cos_x == 0.0:\n        return np.inf * np.sign(sin_x)\n        \n    numerator = 2.0 * sin_x * sin_x_half**2\n    denominator = x_cubed * cos_x\n    \n    return numerator / denominator\n\ndef f_ref(x: float) -> float:\n    \"\"\"\n    Reference evaluation of f(x) using its Maclaurin series expansion\n    truncated at the O(x^6) term.\n    f_ref(x) = 1/2 + x^2/8 + (91/1680)x^4 + (529/24192)x^6.\n    \"\"\"\n    if x == 0.0:\n        return 0.5\n        \n    # Use Horner's method for efficient and stable polynomial evaluation\n    y = x**2\n    c0 = 1.0 / 2.0\n    c1 = 1.0 / 8.0\n    c2 = 91.0 / 1680.0\n    c3 = 529.0 / 24192.0\n\n    return c0 + y * (c1 + y * (c2 + y * c3))\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem's requirements.\n    It calculates and reports the relative errors for two numerical methods\n    against a reference value for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-1,\n        1e-4,\n        1e-8,\n        -1e-8,\n        1e-12,\n        1e-16\n    ]\n\n    results = []\n    for x in test_cases:\n        # Calculate the function value using all three methods\n        val_dir = f_dir(x)\n        val_stab = f_stab(x)\n        val_ref = f_ref(x)\n\n        # Calculate the absolute relative errors\n        # Note: abs(val_ref) is guaranteed to be >= 0.5, so no division by zero\n        error_dir = np.abs(val_dir - val_ref) / np.abs(val_ref)\n        error_stab = np.abs(val_stab - val_ref) / np.abs(val_ref)\n        \n        results.append(error_dir)\n        results.append(error_stab)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "灾难性抵消不仅存在于抽象的数学函数中，它同样会影响物理学中的基本矢量运算。当两个几近平行的矢量进行叉乘运算时，计算结果的精度可能会严重受损，这在模拟力矩或角动量等问题时是致命的。本练习  将引导你设计一个数值实验，来量化计算几乎平行矢量的叉乘时产生的误差，从而将灾难性抵消的概念从一维函数推广到三维矢量空间。",
            "id": "2389869",
            "problem": "要求您通过直接数值实验来评估计算两个几乎平行的三维向量的叉积的数值稳定性。分析必须严格基于叉积的数学定义和相对误差的定义。\n\n对于下面测试套件中的每一对有序向量 $\\mathbf{a}=(a_1,a_2,a_3)$ 和 $\\mathbf{b}=(b_1,b_2,b_3)$，请执行以下操作：\n\n1. 使用标准双精度浮点运算计算由下式定义的模 $\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert$：\n$$\n\\mathbf{a}\\times\\mathbf{b}=\\big(a_2 b_3 - a_3 b_2,\\; a_3 b_1 - a_1 b_3,\\; a_1 b_2 - a_2 b_1\\big)\n$$\n和\n$$\n\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert=\\sqrt{(a_2 b_3 - a_3 b_2)^2+(a_3 b_1 - a_1 b_3)^2+(a_1 b_2 - a_2 b_1)^2}.\n$$\n\n2. 独立地，使用至少有$80$位正确小数位数的算术方法计算同一模长的高精度参考值。\n\n3. 对于每一对向量，计算相对误差\n$$\n\\varepsilon=\\frac{\\left|\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert_{\\text{double}}-\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert_{\\text{high-precision}}\\right|}{\\lVert \\mathbf{a}\\times\\mathbf{b}\\rVert_{\\text{high-precision}}}.\n$$\n\n本问题中的所有量都是无量纲的，因此不适用任何物理单位。角度（尽管通过叉积的几何解释而隐式存在）不应被直接使用。\n\n测试套件（每个分量都以精确的十进制字符串形式给出）：\n\n- 情况 $1$（中等大小，几乎平行）：\n  - $\\mathbf{a}_1=(\\,$\"$1\"$, \"$1\"$, \"$1\"$)$, $\\mathbf{b}_1=(\\,$\"$1.000000000001\"$, \"$0.999999999999\"$, \"$1\"$)$.\n- 情况 $2$（大数值，几乎平行）：\n  - $\\mathbf{a}_2=(\\,$\"$10000000000000000\"$, \"$10000000000000000\"$, \"$10000000000000000\"$)$,\n    $\\mathbf{b}_2=(\\,$\"$10000000000010000\"$, \"$9999999999990000\"$, \"$10000000000000000\"$)$.\n- 情况 $3$（小数值，几乎平行）：\n  - $\\mathbf{a}_3=(\\,$\"$1e-16\"$, \"$1e-16\"$, \"$1e-16\"$)$, $\\mathbf{b}_3=(\\,$\"$1.000000000001e-16\"$, \"$0.999999999999e-16\"$, \"$1e-16\"$)$.\n- 情况 $4$（非常小的数值，几乎平行；在双精度下容易发生下溢）：\n  - $\\mathbf{a}_4=(\\,$\"$1e-200\"$, \"$1e-200\"$, \"$1e-200\"$)$, $\\mathbf{b}_4=(\\,$\"$1.000000000001e-200\"$, \"$0.999999999999e-200\"$, \"$1e-200\"$)$.\n- 情况 $5$（正交对照组）：\n  - $\\mathbf{a}_5=(\\,$\"$1\"$, \"$0\"$, \"$0\"$)$, $\\mathbf{b}_5=(\\,$\"$0\"$, \"$1\"$, \"$0\"$)$.\n\n您的程序必须为每个情况 $k\\in\\{1,2,3,4,5\\}$ 计算如上定义的相对误差 $\\varepsilon_k$，其中近似值使用双精度浮点运算，参考值使用至少$80$位十进制数字。最终输出必须是单行文本，包含按顺序排列的五个相对误差，四舍五入到$12$位有效数字，形式为用方括号括起来的逗号分隔列表，例如 \"$[x_1,x_2,x_3,x_4,x_5]$\"。",
            "solution": "该问题要求使用标准双精度浮点运算，评估计算两个几乎平行向量的叉积的模的数值稳定性。该分析将通过与高精度参考计算的结果进行比较来执行。\n\n所研究的基本原理是**灾难性抵消**，这是数值计算中误差的一个主要来源。当两个几乎相等的数相减时，就会发生这种现象。在浮点运算中，数字以有限数量的有效数字存储。当两个非常接近的数字相减时，前面的、最显著的数字会相互抵消，留下的结果主要由后面的、不太显著的数字决定，而这些数字通常被表示或舍入误差所污染。这实际上放大了输入的相对误差，导致结果的相对误差很大，几乎没有或根本没有正确的有效数字。\n\n叉积 $\\mathbf{c} = \\mathbf{a} \\times \\mathbf{b}$ 的标准笛卡尔坐标公式涉及三个这样的减法：\n$$c_1 = a_2 b_3 - a_3 b_2$$\n$$c_2 = a_3 b_1 - a_1 b_3$$\n$$c_3 = a_1 b_2 - a_2 b_1$$\n如果向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 几乎平行，则对于某个标量 $k$，有 $\\mathbf{b} \\approx k\\mathbf{a}$。因此，每次减法中的两项变得几乎相等：$a_i b_j \\approx a_i (k a_j) = k a_i a_j$ 且 $a_j b_i \\approx a_j (k a_i) = k a_i a_j$。因此，在使用有限精度算术时，这种设置极易受到灾难性抵消的影响。\n\n该解决方案通过为每个测试案例实现两种计算路径来进行：一种是双精度计算（`numpy.float64`），另一种是高精度参考计算（使用Python的 `decimal` 模块）。\n\n1.  **高精度参考值计算**：为了建立一个“基准真值”，我们使用Python的 `decimal` 模块，精度设置为$100$位，这轻松超过了要求的$80$位。以字符串形式给出的输入向量分量被转换为 `Decimal` 对象，以防止初始化时任何精度损失。叉积的分量和随后的模长都使用 `Decimal` 算术计算，得出 $\\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{high-precision}}$。\n\n2.  **双精度计算**：将相同的输入字符串转换为标准的Python `float` 对象，这对应于IEEE $754$ 双精度数（`numpy.float64`）。使用这些浮点数计算叉积及其模 $\\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{double}}$，以模拟标准的数值环境。\n\n3.  **相对误差**：然后按规定计算相对误差 $\\varepsilon$：\n    $$ \\varepsilon = \\frac{\\left| \\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{double}} - \\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{high-precision}} \\right|}{\\|\\mathbf{a} \\times \\mathbf{b}\\|_{\\text{high-precision}}} $$\n    为了精确地执行此计算，在减法之前将双精度结果转换为 `Decimal` 对象，确保误差计算本身不会引入更多显著误差。\n\n我们分析每种情况：\n\n-   **情况 1（中等大小，几乎平行）**：向量为 $\\mathbf{a}_1=(1, 1, 1)$ 和 $\\mathbf{b}_1=(1+10^{-12}, 1-10^{-12}, 1)$。分量减法，如 $a_{1,1}b_{1,2} - a_{1,2}b_{1,1} = 1 \\cdot (1-10^{-12}) - 1 \\cdot (1+10^{-12}) = -2 \\times 10^{-12}$，涉及减去相差约 $2 \\times 10^{-12}$ 的两个数。在双精度运算中，$1 \\pm 10^{-12}$ 的表示会引入一个小的初始误差。减法放大了这个误差对最终结果的贡献。分量的相对误差约为 $\\epsilon_{\\text{mach}} / (10^{-12}) \\approx 10^{-16} / 10^{-12} = 10^{-4}$，导致大约4位十进制精度的损失。计算出的模的相对误差就在这个数量级上。\n\n-   **情况 2（大数值，几乎平行）**：分量约为 $10^{16}$ 的数量级。叉积计算中的中间乘积约为 $10^{32}$ 的数量级。这些乘积之间的差值（本应为 $10^{20}$ 的数量级）由于灾难性抵消而完全丢失。例如，计算 $a_{2,2}b_{2,3} - a_{2,3}b_{2,2}$ 涉及 $(10^{16})^2 - 10^{16}(10^{16}-10^4) = 10^{32} - (10^{32} - 10^{20})$。一个双精度浮点数大约有16位十进制精度。因此，$10^{32} - 10^{20}$ 的计算结果为 $10^{32}$，因为第二项太小而无法表示。减法得到 $0$。叉积的所有分量都变为零，导致模为 $0$，相对误差为 $1$。\n\n-   **情况 3（小数值，几乎平行）**：分量约为 $10^{-16}$ 的数量级。初始的浮点表示是误差的来源。像 $1.000000000001 \\times 10^{-16} = 10^{-16} + 10^{-28}$ 这样的数被存储。由于双精度机器$\\epsilon$约为 $2.2 \\times 10^{-16}$，项 $10^{-28}$ 比 $10^{-16}$ 小12个数量级以上，在初始转换为 `float64` 时会丢失。处理器实际上看到 `1e-16 + 1e-28 == 1e-16`。因此，在双精度下，向量 $\\mathbf{b}_3$ 变得与 $\\mathbf{a}_3$ 相同。两个相同向量的叉积是零向量，所以计算出的模为 $0$，相对误差为 $1$。\n\n-   **情况 4（非常小的数值，几乎平行）**：分量约为 $10^{-200}$ 的数量级。叉积公式中的中间乘积约为 $(10^{-200})^2 = 10^{-400}$ 的数量级。这个值小于最小的可表示的非规格化双精度数（约为 $4.9 \\times 10^{-324}$）。计算结果下溢为$0$。叉积向量的所有分量都被计算为 $0$，得到模为 $0$，相对误差为 $1$。\n\n-   **情况 5（正交对照组）**：向量为 $\\mathbf{a}_5=(1, 0, 0)$ 和 $\\mathbf{b}_5=(0, 1, 0)$。所有分量都是小整数，在浮点数中可以精确表示。叉积计算只涉及 $0$ 和 $1$ 的乘法和减法，这些运算都是精确执行的。结果 $\\|\\mathbf{a}_5 \\times \\mathbf{b}_5\\|_{\\text{double}} = 1$ 与高精度结果相同，因此相对误差为 $0$。这个案例证实了当算法不受数值不稳定性影响时是正确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the relative error in the magnitude of the cross product\n    for several pairs of 3D vectors.\n    \"\"\"\n\n    # Set the precision for high-precision calculations.\n    # Required is at least 80 digits; 100 provides a safe margin.\n    getcontext().prec = 100\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (('1', '1', '1'), ('1.000000000001', '0.999999999999', '1')),\n        # Case 2\n        (('10000000000000000', '10000000000000000', '10000000000000000'),\n         ('10000000000010000', '9999999999990000', '10000000000000000')),\n        # Case 3\n        (('1e-16', '1e-16', '1e-16'),\n         ('1.000000000001e-16', '0.999999999999e-16', '1e-16')),\n        # Case 4\n        (('1e-200', '1e-200', '1e-200'),\n         ('1.000000000001e-200', '0.999999999999e-200', '1e-200')),\n        # Case 5\n        (('1', '0', '0'), ('0', '1', '0')),\n    ]\n\n    def compute_magnitude_hp(a_str, b_str):\n        a = [Decimal(s) for s in a_str]\n        b = [Decimal(s) for s in b_str]\n        \n        c1 = a[1] * b[2] - a[2] * b[1]\n        c2 = a[2] * b[0] - a[0] * b[2]\n        c3 = a[0] * b[1] - a[1] * b[0]\n        \n        mag_sq = c1**2 + c2**2 + c3**2\n        \n        return mag_sq.sqrt()\n\n    def compute_magnitude_dp(a_str, b_str):\n        a = np.array([float(s) for s in a_str], dtype=np.float64)\n        b = np.array([float(s) for s in b_str], dtype=np.float64)\n        \n        c1 = a[1] * b[2] - a[2] * b[1]\n        c2 = a[2] * b[0] - a[0] * b[2]\n        c3 = a[0] * b[1] - a[1] * b[0]\n        \n        mag_sq = c1**2 + c2**2 + c3**2\n        \n        return np.sqrt(mag_sq)\n\n    results = []\n    for a_vec_str, b_vec_str in test_cases:\n        mag_hp = compute_magnitude_hp(a_vec_str, b_vec_str)\n        mag_dp = compute_magnitude_dp(a_vec_str, b_vec_str)\n        \n        if mag_hp == 0:\n            # If the true value is zero, relative error is 0 if dp is also 0,\n            # otherwise it is infinite. In the given cases, this path is not taken.\n            relative_error = Decimal(0) if mag_dp == 0 else Decimal('inf')\n        else:\n            # Convert dp result to Decimal for high-precision error calculation\n            mag_dp_dec = Decimal(str(mag_dp))\n            absolute_error = abs(mag_dp_dec - mag_hp)\n            relative_error = absolute_error / mag_hp\n        \n        results.append(relative_error)\n\n    def format_to_12_sig_digits(d):\n        \"\"\"Formats a Decimal number to a string with 12 significant digits in scientific notation.\"\"\"\n        if d == 0:\n            return \"0.00000000000e+00\"\n        return f\"{d:.11e}\"\n\n    formatted_results = [format_to_12_sig_digits(res) for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值不稳定性不仅源于有效数字的丢失，也来自于浮点数表示范围的限制。在计算过程中，即使最终结果在可表示范围内，巨大的中间值也可能导致溢出（overflow），从而使整个计算失败。组合数 $\\binom{n}{k}$ 的计算就是一个典型例子，使用阶乘公式 $\\frac{n!}{k!(n-k)!}$ 很容易遇到中间结果溢出的问题。通过这个练习 ，你将对比朴素的阶乘方法和更稳健的连乘方法，体会到算法设计本身对数值稳定性的决定性作用。",
            "id": "2389940",
            "problem": "要求您评估在双精度浮点运算中计算二项式系数 $\\binom{n}{k}$ 时的数值稳定性和误差传播。\n\n考虑两种算法：(i) 阶乘商方法，使用恒等式 $\\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}$ 完全在浮点运算中计算；以及 (ii) 累乘方法，通过迭代乘以避免产生大的中间值的比率来形成乘积。目标是在一个设计的测试套件上量化和比较两种方法的前向相对误差，并解释任何灾难性抵消或有效位损失。\n\n推理和实现的基本依据：\n- 使用以 $2$ 为基数并采用舍入到最近的浮点运算标准模型，其中每个基本算术运算都满足 $\\mathrm{fl}(a \\,\\mathrm{op}\\, b) = (a \\,\\mathrm{op}\\, b)(1+\\delta)$，且 $|\\delta| \\leq \\varepsilon_{\\text{machine}}$。双精度下的 $\\varepsilon_{\\text{machine}} \\approx 2^{-53} \\approx 1.11\\times 10^{-16}$。\n- 二项式系数为整数 $n \\geq 0$ 和 $0 \\leq k \\leq n$ 定义为 $\\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}$，在精确算术中它是一个精确的整数。您可以假设您的编程语言中提供了精确整数运算来计算参考值。\n\n您必须实现的算法定义：\n- 阶乘商方法（浮点）：在浮点运算中计算 $n!$、$k!$ 和 $(n-k)!$（不使用对数），然后相除得到 $\\widehat{C}_{\\text{fact}} = \\dfrac{\\mathrm{fl}(n!)}{\\mathrm{fl}(k!)\\,\\mathrm{fl}((n-k)!)}$。如果任何中间阶乘溢出为 $+\\infty$ 或产生非数值（Not-a-Number），则所得近似值被认为是不可用的。\n- 累乘方法（浮点）：通过设置 $k \\leftarrow \\min(k, n-k)$ 并对 $i = 1,2,\\dots,k$ 进行迭代来计算 $\\widehat{C}_{\\text{mult}}$，\n$$\n\\widehat{C}_{\\text{mult}} \\leftarrow \\widehat{C}_{\\text{mult}} \\times \\frac{n - k + i}{i},\n$$\n完全在浮点运算中进行。\n\n要报告的误差度量：\n- 对于每个测试用例，使用精确整数运算计算精确参考值 $C_{\\text{exact}} = \\binom{n}{k}$。然后计算每种方法的前向相对误差：\n$$\ne_{\\text{fact}} = \\frac{\\left|\\widehat{C}_{\\text{fact}} - C_{\\text{exact}}\\right|}{C_{\\text{exact}}}, \\qquad\ne_{\\text{mult}} = \\frac{\\left|\\widehat{C}_{\\text{mult}} - C_{\\text{exact}}\\right|}{C_{\\text{exact}}}.\n$$\n如果 $\\widehat{C}_{\\text{fact}}$ 是 $+\\infty$ 或非数值（Not-a-Number），则设置 $e_{\\text{fact}} = +\\infty$。如果 $\\widehat{C}_{\\text{mult}}$ 溢出或为非数值，也进行类似处理。\n- 对于每个测试用例，还需报告一个布尔值 $b$，定义为：如果 $e_{\\text{mult}} \\leq e_{\\text{fact}}$，则 $b = \\text{True}$，否则 $b = \\text{False}$。\n\n角度单位：不适用。物理单位：不适用。\n\n您必须使用的测试套件：\n- 用例 $1$：$(n,k) = (10,5)$。\n- 用例 $2$：$(n,k) = (60,30)$。\n- 用例 $3$：$(n,k) = (100,1)$。\n- 用例 $4$：$(n,k) = (170,85)$。\n- 用例 $5$：$(n,k) = (200,2)$。\n- 用例 $6$：$(n,k) = (300,150)$。\n\n覆盖性设计：\n- 这些用例涵盖了小型对称 $(k \\approx n/2)$、中等对称、极端不对称 $(k \\ll n)$、接近双精度阶乘溢出边界 $(n=170)$ 的情况，以及阶乘溢出发生 $(n=200$ 和 $n=300)$ 但累乘方法应保持有限值的情况。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个长度为 $6$ 的列表，每个元素是一个包含三个条目 $[e_{\\text{fact}}, e_{\\text{mult}}, b]$ 的列表，按此顺序对应于上述用例 $1$ 到 $6$。\n- 每个有限浮点误差必须以科学记数法打印，并精确到六位有效数字（例如，$1.234560\\mathrm{e}{-07}$）。如果值是无穷大或非数值，则打印为 $inf$。\n- 布尔值必须打印为 $\\text{True}$ 或 $\\text{False}$。\n- 例如，整个打印行应如下所示：\n$[\\,[e_{1,\\text{fact}},e_{1,\\text{mult}},b_1],\\,[e_{2,\\text{fact}},e_{2,\\text{mult}},b_2],\\,\\dots,\\,[e_{6,\\text{fact}},e_{6,\\text{mult}},b_6]\\,]$。",
            "solution": "所述问题是有效的。它在科学上基于数值分析的原理，特别是浮点运算，并且问题提法得当，提供了一个清晰且可计算的任务。我们需要比较两种计算二项式系数 $\\binom{n}{k}$ 的算法。\n\n分析的核心在于理解浮点运算的局限性，即受限于有限的范围和精度。根据标准模型，任何基本算术运算 `op` 都会产生舍入误差：$\\mathrm{fl}(a \\,\\mathrm{op}\\, b) = (a \\,\\mathrm{op}\\, b)(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon_{\\text{machine}}$。对于 IEEE 754 双精度标准，机器ε $\\varepsilon_{\\text{machine}} \\approx 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n\n第一种算法是阶乘商方法，它基于恒等式 $\\binom{n}{k} = \\dfrac{n!}{k!(n-k)!}$ 来计算 $\\widehat{C}_{\\text{fact}}$。该实现方式在进行除法之前，用浮点运算计算分子 $\\mathrm{fl}(n!)$ 和分母 $\\mathrm{fl}(k!) \\times \\mathrm{fl}((n-k)!)$。该方法的主要弱点是**溢出**。阶乘函数 $n!$ 呈超指数增长。在双精度运算中，可表示的最大有限数约为 $1.8 \\times 10^{308}$。$170!$ 的值约为 $7.26 \\times 10^{306}$，这是可以表示的，但 $171!$ 约为 $1.24 \\times 10^{309}$，会溢出为无穷大 ($+\\infty$)。因此，对于任何 $n > 170$，$\\mathrm{fl}(n!)$ 将为 $+\\infty$。这使得该方法不可用，因为计算结果将是 $+\\infty$（如果分母是有限的）或非数值（`NaN`）（如果分母也溢出，例如出现不定式 $\\infty/\\infty$）。这是由于浮点数范围有限而导致的灾难性失败，而不是舍入误差导致的精度损失问题。\n\n第二种算法是累乘方法。该方法基于将二项式系数重写为乘积的形式：\n$$ \\binom{n}{k} = \\frac{n \\times (n-1) \\times \\dots \\times (n-k+1)}{k \\times (k-1) \\times \\dots \\times 1} = \\prod_{i=1}^{k} \\frac{n-i+1}{i} $$\n通过使用恒等式 $\\binom{n}{k} = \\binom{n}{n-k}$，我们可以通过选择 $k$ 和 $n-k$ 中较小的一个来确保乘积中的项数最少。然后，该算法由迭代 $\\widehat{C}_{\\text{mult}} \\leftarrow \\widehat{C}_{\\text{mult}} \\times \\frac{n - k' + i}{i}$ 定义，其中 $i = 1, \\dots, k'$ 且 $k' = \\min(k, n-k)$。这种形式的关键优势在于它避免了计算大的中间阶乘。项 $\\frac{n-k'+i}{i}$ 的量级适中，并且部分乘积 $\\prod_{j=1}^{i} \\frac{n-k'+j}{j} = \\binom{n-k'+i}{i}$ 平滑地增长到最终值。只要最终结果 $\\binom{n}{k}$ 本身不溢出，该方法就会产生一个有限的结果。这种方法在根本上更稳定，因为它将中间值维持在可管理的规模，从而避免了溢出，并减少了在处理处于浮点范围两端的数字时更为显著的舍入误差的累积。\n\n为了量化性能，我们针对使用任意精度整数运算得到的精确值 $C_{\\text{exact}}$，计算每种方法的前向相对误差 $e_{\\text{fact}}$ 和 $e_{\\text{mult}}$。由溢出或 `NaN` 导致的不可用结果被正确地处理为产生无穷大误差。测试套件旨在演示这些原理：它包括两种方法预期都能良好工作的用例（小 $n$）、阶乘方法处于溢出边界的用例 ($n=170$)，以及阶乘方法保证失败 ($n > 170$) 而累乘方法成功的用例。因此，比较布尔值 $b = (e_{\\text{mult}} \\leq e_{\\text{fact}})$ 将系统地评估累乘方法的优越稳定性。",
            "answer": "```python\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical error of two algorithms for the binomial coefficient.\n    \"\"\"\n\n    def float_factorial(m: int) -> float:\n        \"\"\"Computes factorial of m as a float, handling overflow to inf.\"\"\"\n        if m  0:\n            return float('nan')\n        if m == 0:\n            return 1.0\n        res = 1.0\n        for i in range(1, m + 1):\n            res *= float(i)\n        return res\n\n    def compute_fact_method(n: int, k: int) - float:\n        \"\"\"\n        Computes binomial(n, k) using the factorial-quotient method in floating-point.\n        C = n! / (k! * (n-k)!)\n        \"\"\"\n        if k  0 or k > n:\n            return float('nan')\n\n        n_fact = float_factorial(n)\n        k_fact = float_factorial(k)\n        nk_fact = float_factorial(n - k)\n\n        # The problem statement implies we perform the floating-point operations\n        # on the (potentially infinite) results of the factorials.\n        denominator = k_fact * nk_fact\n        if denominator == 0.0:\n            return float('inf') # Division by zero\n        \n        return n_fact / denominator\n\n    def compute_mult_method(n: int, k: int) - float:\n        \"\"\"\n        Computes binomial(n, k) using the stable multiplicative method.\n        C = product_{i=1 to k} (n-k+i)/i\n        \"\"\"\n        if k  0 or k > n:\n            return float('nan')\n\n        # Use symmetry property binom(n, k) = binom(n, n-k)\n        k_comp = n - k\n        if k_comp  k:\n            k = k_comp\n        \n        if k == 0:\n            return 1.0\n\n        res = 1.0\n        for i in range(1, k + 1):\n            # Formula is derived from C(n,k) = (n/k) * C(n-1, k-1)\n            # which can be iteratively computed as prod_{i=1 to k} (n-i+1)/i\n            # The problem gives an equivalent form: C_mult - C_mult * (n-k+i)/i\n            term = float(n - k + i) / float(i)\n            res *= term\n        \n        return res\n\n    def format_val(v: float) - str:\n        \"\"\"Formats a float value according to the problem specification.\"\"\"\n        if np.isinf(v) or np.isnan(v):\n            return 'inf'\n        # The problem example \"1.234560e-07\" corresponds to the format specifier \"{:.6e}\",\n        # which provides 1 digit before the decimal and 6 after, for a total of 7 significant digits.\n        # This is followed despite the text \"six significant digits\" due to the example's specificity.\n        return f\"{v:.6e}\"\n\n    test_cases = [\n        (10, 5),\n        (60, 30),\n        (100, 1),\n        (170, 85),\n        (200, 2),\n        (300, 150),\n    ]\n\n    results_list = []\n    for n, k in test_cases:\n        # Compute exact value using arbitrary-precision integers\n        c_exact = math.comb(n, k)\n        c_exact_float = float(c_exact)\n\n        # Method 1: Factorial-quotient\n        c_fact = compute_fact_method(n, k)\n        if np.isinf(c_fact) or np.isnan(c_fact):\n            e_fact = float('inf')\n        else:\n            e_fact = abs(c_fact - c_exact_float) / c_exact_float if c_exact_float != 0 else 0.0\n\n        # Method 2: Multiplicative\n        c_mult = compute_mult_method(n, k)\n        if np.isinf(c_mult) or np.isnan(c_mult):\n            e_mult = float('inf')\n        else:\n            e_mult = abs(c_mult - c_exact_float) / c_exact_float if c_exact_float != 0 else 0.0\n\n        # Comparison\n        b = e_mult = e_fact\n        \n        results_list.append(f\"[{format_val(e_fact)},{format_val(e_mult)},{str(b)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        }
    ]
}