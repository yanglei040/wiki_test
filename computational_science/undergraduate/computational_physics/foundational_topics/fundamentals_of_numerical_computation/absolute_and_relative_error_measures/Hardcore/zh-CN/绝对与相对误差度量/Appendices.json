{
    "hands_on_practices": [
        {
            "introduction": "在分析复杂算法中的误差之前，我们首先需要理解基础测量中的误差是如何通过物理公式传播的。本练习以斯特藩-玻尔兹曼定律为案例，探讨测量量（温度）中一个很小的相对误差如何导致计算量（辐射功率）中一个被放大的误差。这项练习  将锻炼您在误差传播方面的分析能力，并展示一种处理幂律关系的强大技巧——对数微分法。",
            "id": "2370476",
            "problem": "一个热辐射实验使用斯特藩-玻尔兹曼定律测量来自理想黑体表面的总辐射功率，该定律指出辐射功率由 $P=\\sigma A T^{4}$ 给出，其中 $P$ 是功率，$\\sigma$ 是斯特藩-玻尔兹曼常数，$A$ 是发射面积，$T$ 是绝对温度。假设发射面积 $A$ 和斯特藩-玻尔兹曼常数 $\\sigma$ 是精确已知的，并且测量不确定度的唯一来源是温度 $T$。如果测得的温度 $T$ 的相对误差为 $1/100$，请确定计算出的辐射功率 $P$ 的最终相对误差。请将您的最终答案表示为不带单位的小数。不要使用百分号。无需四舍五入。",
            "solution": "问题陈述需要经过验证。\n\n**步骤1：提取已知条件**\n- 控制方程为斯特藩-玻尔兹曼定律：$P = \\sigma A T^{4}$。\n- 变量 $P$ 是辐射功率。\n- 常数 $\\sigma$ 是斯特藩-玻尔兹曼常数，为精确已知。\n- 变量 $A$ 是发射面积，为精确已知。\n- 变量 $T$ 是绝对温度，并且是测量不确定度的唯一来源。\n- 测得的温度 $T$ 的相对误差为 $\\frac{1}{100}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它基于物理学的基本原理——斯特藩-玻尔兹曼定律。这是一个误差传播分析中的良构问题。问题的表述客观而精确。它包含了推导唯一解所需的所有信息，明确指出 $\\sigma$ 和 $A$ 的不确定度为零。问题设置是自洽的，没有矛盾或含糊之处。\n\n**步骤3：结论与行动**\n问题被判定为有效。将提供解答。\n\n辐射功率 $P$ 与绝对温度 $T$ 之间的关系由以下函数给出：\n$$P(T) = \\sigma A T^{4}$$\n在此，斯特藩-玻尔兹曼常数 $\\sigma$ 和面积 $A$ 被认为是精确的，意味着它们的相关不确定度为零。$P$ 的不确定度仅源于 $T$ 测量的不确定度。\n\n为了确定相对误差的传播，我们采用对数微分法，这对于幂律关系是最有效的方法。我们对等式两边取自然对数：\n$$\\ln(P) = \\ln(\\sigma A T^{4})$$\n利用对数的性质，我们可以展开右侧：\n$$\\ln(P) = \\ln(\\sigma) + \\ln(A) + \\ln(T^{4})$$\n$$\\ln(P) = \\ln(\\sigma) + \\ln(A) + 4\\ln(T)$$\n接下来，我们求此表达式的全微分，以关联变量的无穷小变化：\n$$d(\\ln(P)) = d(\\ln(\\sigma)) + d(\\ln(A)) + d(4\\ln(T))$$\n这得到：\n$$\\frac{dP}{P} = \\frac{d\\sigma}{\\sigma} + \\frac{dA}{A} + 4\\frac{dT}{T}$$\n对于小的、有限的不确定度，我们可以用有限差分 ($\\delta$) 来近似这些微分 ($\\mathit{d}$):\n$$\\frac{\\delta P}{P} \\approx \\frac{\\delta \\sigma}{\\sigma} + \\frac{\\delta A}{A} + 4\\frac{\\delta T}{T}$$\n这个方程表示了 $P$ 的相对误差与其所依赖的量的相对误差之间的关系。\n\n根据题目陈述，$\\sigma$ 和 $A$ 是精确已知的。这意味着它们的不确定度为零：$\\delta \\sigma = 0$ 和 $\\delta A = 0$。因此，它们的相对误差也为零：\n$$\\frac{\\delta \\sigma}{\\sigma} = 0$$\n$$\\frac{\\delta A}{A} = 0$$\n将这些代入误差传播公式，可简化为：\n$$\\frac{\\delta P}{P} \\approx 4\\frac{\\delta T}{T}$$\n这表明计算出的功率 $P$ 的相对误差是测量的温度 $T$ 的相对误差的四倍。我们关心的是这个误差的大小。设 $\\epsilon_X = \\left| \\frac{\\delta X}{X} \\right|$ 表示量 $X$ 的相对误差的大小。那么：\n$$\\epsilon_P = \\left| \\frac{\\delta P}{P} \\right| \\approx 4 \\left| \\frac{\\delta T}{T} \\right| = 4 \\epsilon_T$$\n题目说明温度的相对误差是 $\\frac{1}{100}$。所以，$\\epsilon_T = \\frac{1}{100}$。\n代入这个值，我们得到功率的相对误差：\n$$\\epsilon_P \\approx 4 \\times \\frac{1}{100} = \\frac{4}{100}$$\n根据要求，我们将此结果表示为小数：\n$$\\epsilon_P = 0.04$$\n这就是计算出的辐射功率 $P$ 的最终相对误差。",
            "answer": "$$\n\\boxed{0.04}\n$$"
        },
        {
            "introduction": "即使是数学上完全正确的公式，在计算机上实现时也可能因为浮点运算的固有限制而导致灾难性的失败。本练习  展示了一个“灾难性抵消”的经典案例，即两个几乎相等的数相减导致了相对精度的急剧损失。通过实现并比较一个“朴素”公式和一个经过代数变换的数值稳定等价公式，您将亲身体验如何识别并规避这一常见的数值计算陷阱。",
            "id": "2370414",
            "problem": "考虑实值函数 $f(a) = \\sqrt{a^2 + 1} - a$，其中 $a \\in \\mathbb{R}_{>0}$。对于较大的 $a$，$f(a)$ 中的减法运算涉及两个几乎相等的正数，这在标准浮点运算中可能导致灾难性抵消。定义近似值 $\\tilde{y}$ 相对于参考值 $y$ 的绝对误差为 $| \\tilde{y} - y |$，相对误差为 $| \\tilde{y} - y | / | y |$。\n\n您的任务是编写一个完整的、可运行的程序，对每个指定的测试值 $a$ 进行评估：\n1. 使用标准双精度浮点运算进行朴素的直接求值 $f_{\\text{naive}}(a) = \\sqrt{a^2 + 1} - a$。\n2. 使用相同的算术方法计算数学上等价的参考值 $f_{\\text{ref}}(a) = \\dfrac{1}{\\sqrt{a^2 + 1} + a}$。\n\n然后，对每个 $a$ 计算绝对误差 $E_{\\text{abs}}(a) = \\left| f_{\\text{naive}}(a) - f_{\\text{ref}}(a) \\right|$ 和相对误差 $E_{\\text{rel}}(a) = \\left| f_{\\text{naive}}(a) - f_{\\text{ref}}(a) \\right| \\big/ \\left| f_{\\text{ref}}(a) \\right|$。所有数值结果都表示为无量纲数。\n\n对 $a$ 使用以下测试套件：\n- $a = 1$\n- $a = 10^{4}$\n- $a = 10^{8}$\n- $a = 10^{16}$\n- $a = 10^{-8}$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序与测试套件相同。每个元素本身必须是一个双元素列表 $[E_{\\text{abs}}(a), E_{\\text{rel}}(a)]$。例如，具有三个测试用例的输出将类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，其中每个 $x_i$ 和 $y_i$ 都是十进制数。",
            "solution": "该问题要求在计算正实数 $a \\in \\mathbb{R}_{>0}$ 的函数 $f(a) = \\sqrt{a^2 + 1} - a$ 时分析数值误差。具体来说，我们必须将一种朴素的计算方法与一种数学上等价但数值上更优的方法进行比较，并使用绝对误差和相对误差来量化其差异。\n\n该问题陈述已经过验证，具有科学合理性、良定性和客观性。它展示了浮点运算中灾难性抵消的一个经典例子，这是计算科学中的一个基本课题。所有必需的定义、数据和约束都已提供。\n\n问题的核心在于函数在 $a$ 值较大时的行为。当 $a$ 变大时，项 $\\sqrt{a^2 + 1}$ 变得非常接近 $\\sqrt{a^2} = a$。例如，当 $a=10^8$ 时，我们有 $a^2=10^{16}$。使用二项式展开，$\\sqrt{a^2+1} = a\\sqrt{1+1/a^2} \\approx a(1 + \\frac{1}{2a^2}) = a + \\frac{1}{2a}$。对于 $a=10^8$，这等于 $10^8 + 0.5 \\times 10^{-8}$。减法 $f(a) = (a + \\frac{1}{2a}) - a$ 涉及两个几乎相同的数。标准的双精度浮点运算具有有限的精度（大约15-17个十进制数字）。当两个几乎相等的数相减时，前面的最高有效位相消，导致结果中的有效数字减少。这种精度损失被称为灾难性抵消。对于足够大的 $a$，$a^2+1$ 的值在有限精度下甚至可能与 $a^2$ 无法区分，导致 $\\sqrt{a^2+1}$ 被计算为精确的 $a$，从而得到结果 $0$。\n\n为了缓解这个问题，我们可以对表达式进行代数重构。通过乘以并除以共轭表达式 $\\sqrt{a^2+1} + a$，我们得到了一个数值稳定的形式：\n$$\nf(a) = \\sqrt{a^2 + 1} - a = (\\sqrt{a^2 + 1} - a) \\times \\frac{\\sqrt{a^2 + 1} + a}{\\sqrt{a^2 + 1} + a}\n$$\n$$\nf(a) = \\frac{(\\sqrt{a^2+1})^2 - a^2}{\\sqrt{a^2 + 1} + a} = \\frac{(a^2+1) - a^2}{\\sqrt{a^2 + 1} + a} = \\frac{1}{\\sqrt{a^2 + 1} + a}\n$$\n这个修改后的表达式，我们记作 $f_{\\text{ref}}(a)$，只涉及加法和最后的除法。这些运算是数值稳定的。相近数相减的问题已被消除。因此，使用浮点运算计算的 $f_{\\text{ref}}(a)$ 将比朴素求值 $f_{\\text{naive}}(a) = \\sqrt{a^2+1} - a$ 得出更接近真实数学值的结果。\n\n问题要求我们计算朴素公式相对于稳定公式的绝对误差和相对误差。我们将 $f_{\\text{ref}}(a)$ 的结果视为参考值 $y$，将 $f_{\\text{naive}}(a)$ 的结果视为近似值 $\\tilde{y}$。\n\n绝对误差定义为：\n$$\nE_{\\text{abs}}(a) = | f_{\\text{naive}}(a) - f_{\\text{ref}}(a) |\n$$\n相对误差定义为：\n$$\nE_{\\text{rel}}(a) = \\frac{| f_{\\text{naive}}(a) - f_{\\text{ref}}(a) |}{| f_{\\text{ref}}(a) |}\n$$\n对于每个测试值 $a$（$1$, $10^4$, $10^8$, $10^{16}$ 和 $10^{-8}$），计算过程如下：\n$1$. 使用双精度浮点表示定义 $a$ 的值。\n$2$. 计算 $f_{\\text{naive}}(a) = \\sqrt{a^2 + 1} - a$。\n$3$. 计算 $f_{\\text{ref}}(a) = \\frac{1}{\\sqrt{a^2 + 1} + a}$。\n$4$. 使用步骤2和3的结果计算 $E_{\\text{abs}}(a)$ 和 $E_{\\text{rel}}(a)$。\n\n对于较小的 $a$ 值（例如 $a=1, a=10^{-8}$），项 $\\sqrt{a^2+1}$ 和 $a$ 并非几乎相等，因此灾难性抵消不是一个重要因素。预计误差将在机器精度的数量级。对于较大的 $a$ 值（例如 $a=10^4, a=10^8, a=10^{16}$），我们预计误差，特别是相对误差，会随着灾难性抵消效应变得更加显著而大幅增长。对于 $a=10^8$ 及更大的值，在标准双精度下，$a^2+1$ 将被舍入为 $a^2$，导致 $f_{\\text{naive}}(a)$ 的计算结果为 $0$，从而产生 $1$ 或 $100\\%$ 的相对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the absolute and relative errors for the naive evaluation\n    of f(a) = sqrt(a^2 + 1) - a against a more numerically stable form.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1.0,\n        1.0e4,\n        1.0e8,\n        1.0e16,\n        1.0e-8,\n    ]\n\n    results = []\n    for a_val in test_cases:\n        # Ensure the value is treated as a double-precision float (numpy's default).\n        a = np.float64(a_val)\n        \n        # 1. Naive direct evaluation, prone to catastrophic cancellation for large a.\n        # f_naive(a) = sqrt(a^2 + 1) - a\n        # a**2 can cause overflow for very large a, but a=1e16 is fine.\n        # The key issue is sqrt(a^2+1) becoming indistinguishable from 'a'.\n        f_naive = np.sqrt(a**2 + 1) - a\n        \n        # 2. Mathematically equivalent reference value, numerically stable.\n        # f_ref(a) = 1 / (sqrt(a^2 + 1) + a)\n        # This form avoids subtracting nearly equal numbers.\n        f_ref = 1 / (np.sqrt(a**2 + 1) + a)\n        \n        # In the edge case where the reference value is exactly zero, which does not\n        # happen for a > 0, we would define the relative error as zero\n        # to avoid division by zero.\n        if f_ref == 0.0:\n            abs_error = np.abs(f_naive - f_ref)\n            rel_error = 0.0 if f_naive == 0.0 else np.inf\n        else:\n            # 3. Compute absolute error.\n            abs_error = np.abs(f_naive - f_ref)\n            \n            # 4. Compute relative error.\n            rel_error = abs_error / np.abs(f_ref)\n            \n        results.append([abs_error, rel_error])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) will convert each inner list [x, y] to its string\n    # representation, e.g., '[1.23, 4.56]'.\n    # ','.join(...) will create the comma-separated list of these strings.\n    # The outer f-string adds the final brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将从静态计算转向动态模拟，在动态模拟中，微小的误差会随着时间的推移而累积，并可能最终使模拟结果失效。本练习  将使用两种不同的数值积分器——简单的欧拉法和更复杂的四阶龙格-库塔（RK4）方法——来模拟一个简谐振子。通过将它们的表现与精确的解析解进行比较，您将观察到算法的选择如何显著影响误差的累积和物理模拟的长期稳定性。",
            "id": "2370478",
            "problem": "您将编写一个完整的、可运行的程序，比较两种显式时间步进格式在积分一维简谐振子运动时如何传播误差。所研究的系统由常微分方程 (ODE) $$\\frac{d^{2}x}{dt^{2}} + \\omega^{2} x = 0$$ 控制，其中 $x$ 是作为时间 $t$ 函数的位移，$\\omega$ 是角频率。通过定义状态向量 $y(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = \\frac{dx}{dt}$）引入一阶系统。该 ODE 变为 $$\\frac{d}{dt}\\begin{bmatrix} x \\\\ v \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\omega^{2} x \\end{bmatrix}.$$ 初始条件给定为 $x(0)=x_{0}$ 和 $v(0)=v_{0}$。时间单位为秒，位移单位为米，速度单位为米/秒。角频率 $\\omega$ 的单位为弧度/秒。\n\n基本原理与要求：\n- 使用上述定义的 ODE、简谐振子的守恒性质，以及显式欧拉法和经典四阶龙格-库塔 (RK4) 时间步进方法的标准算法定义。不假定任何未说明的稳定性性质；直接根据定义量化误差。\n- 简谐振子的精确解可通过求解具有给定初始条件的线性常系数 ODE 得出。您必须推导并实现该精确解，以计算每个时间的参考值。\n- 定义缩放状态 $s(t) = \\begin{bmatrix} x(t) \\\\ v(t)/\\omega \\end{bmatrix}$。当 $\\omega$ 为常数时，此缩放使得简谐振子的精确能量范数 $\\|s(t)\\|_{2}$ 保持恒定。\n- 在每个离散时间 $t_{n} = n h$（步长为 $h$），将数值方法的绝对误差定义为 $$E_{\\mathrm{abs}}(t_{n}) = \\left\\| s_{\\mathrm{num}}(t_{n}) - s_{\\mathrm{exact}}(t_{n}) \\right\\|_{2},$$ 相对误差定义为 $$E_{\\mathrm{rel}}(t_{n}) = \\frac{E_{\\mathrm{abs}}(t_{n})}{\\left\\| s_{\\mathrm{exact}}(t_{n}) \\right\\|_{2}}.$$ 此处 $\\|\\cdot\\|_{2}$ 是欧几里得范数。对于具有恒定 $\\omega$ 的简谐振子，只要 $x_{0}$ 和 $v_{0}$ 不全为零，$\\left\\| s_{\\mathrm{exact}}(t_{n}) \\right\\|_{2}$ 就等于恒定振幅 $\\sqrt{x_{0}^{2} + \\left(v_{0}/\\omega\\right)^{2}}$。\n- 为该一阶系统实现两个积分器：显式欧拉法和四阶经典龙格-库塔法 (RK4)。对于每个测试，追踪 $n = 0, 1, \\dots, N$（其中 $N = T/h$，$T$ 是最终时间）的 $E_{\\mathrm{rel}}(t_{n})$ 的完整时间历史。然后报告每种方法的最终时刻相对误差 $E_{\\mathrm{rel}}(T)$ 和整个轨迹上的最大相对误差 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}(t_{n})$。\n\n单位与角度规定：\n- 时间 $t$ 必须以秒为单位，位移 $x$ 以米为单位，速度 $v$ 以米/秒为单位，角频率 $\\omega$ 以弧度/秒为单位。\n- 用于精确解的三角函数必须将角度解释为弧度。\n\n测试套件与参数：\n对于每个测试用例，给定一个五元组 $(\\omega, x_{0}, v_{0}, h, T)$，其含义如上文所定义。请严格使用以下四个测试用例：\n- 测试用例 1：$(\\omega, x_{0}, v_{0}, h, T) = (\\,1.0,\\, 1.0,\\, 0.0,\\, 0.01,\\, 10.0\\,)$。\n- 测试用例 2：$(\\omega, x_{0}, v_{0}, h, T) = (\\,1.0,\\, 1.0,\\, 0.0,\\, 0.1,\\, 50.0\\,)$。\n- 测试用例 3：$(\\omega, x_{0}, v_{0}, h, T) = (\\,2.0,\\, 1.0,\\, 0.0,\\, 0.05,\\, 25.0\\,)$。\n- 测试用例 4：$(\\omega, x_{0}, v_{0}, h, T) = (\\,1.0,\\, 1.0,\\, 1.0,\\, 0.25,\\, 20.0\\,)$。\n\n输出规格：\n- 对每个测试用例，计算四个浮点数：$E_{\\mathrm{rel}}^{\\mathrm{Euler}}(T)$、 $E_{\\mathrm{rel}}^{\\mathrm{RK4}}(T)$、 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{Euler}}(t_{n})$ 和 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{RK4}}(t_{n})$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个由方括号括起来的逗号分隔列表，每个测试用例贡献一个包含上述四个浮点数的列表，顺序与指定一致。最终格式必须为\n  $$\\big[ [a_{1}, b_{1}, c_{1}, d_{1}], [a_{2}, b_{2}, c_{2}, d_{2}], [a_{3}, b_{3}, c_{3}, d_{3}], [a_{4}, b_{4}, c_{4}, d_{4}] \\big].$$\n- 每个浮点值必须以科学记数法打印，并四舍五入到 $10$ 位有效数字。\n\n科学真实性与约束：\n- 所有情景对于具有给定参数的简谐振子在物理上和数值上都是合理的。目标量是无量纲的相对误差。程序必须是自包含的，无需输入，并严格遵循输出格式。",
            "solution": "所述问题是有效的。这是一个在计算物理学中定义明确、有科学依据的练习，要求比较两种标准数值积分格式——显式欧拉法和经典四阶龙格-库塔法——在处理简谐振子时的表现。所有参数、定义和要求都以清晰明确的方式给出。该问题是自包含的，没有逻辑矛盾或事实错误。\n\n求解过程遵循一系列逻辑步骤：首先，我们推导系统的精确解析解，它将作为基准真值。其次，我们为两种数值方法构建迭代更新规则。第三，我们定义用于比较的误差度量。最后，我们描述用于为给定测试用例生成所需输出的计算算法。\n\n该系统是一个一维简谐振子，由二阶常微分方程 (ODE) 控制：\n$$\n\\frac{d^{2}x}{dt^{2}} + \\omega^{2} x = 0\n$$\n其中 $x$ 是位移，$t$ 是时间，$\\omega$ 是角频率。通过定义状态向量 $\\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = \\frac{dx}{dt}$ 是速度），可将其转换为一个一阶 ODE 系统。系统的动力学可表示为：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} v \\\\ -\\omega^{2} x \\end{bmatrix}\n$$\n初始条件为 $\\mathbf{y}(0) = \\begin{bmatrix} x(0) \\\\ v(0) \\end{bmatrix} = \\begin{bmatrix} x_{0} \\\\ v_{0} \\end{bmatrix}$。\n\n此线性常系数常微分方程的精确解可以通过假设解的形式为 $x(t) = A \\cos(\\omega t) + B \\sin(\\omega t)$ 来找到。应用初始条件：\n$x(0) = A = x_{0}$。\n速度为 $v(t) = \\frac{dx}{dt} = -A\\omega \\sin(\\omega t) + B\\omega \\cos(\\omega t)$。\n$v(0) = B\\omega = v_{0}$，这意味着 $B = \\frac{v_{0}}{\\omega}$。\n因此，状态向量分量的精确解为：\n$$\nx_{\\mathrm{exact}}(t) = x_{0} \\cos(\\omega t) + \\frac{v_{0}}{\\omega} \\sin(\\omega t)\n$$\n$$\nv_{\\mathrm{exact}}(t) = -x_{0} \\omega \\sin(\\omega t) + v_{0} \\cos(\\omega t)\n$$\n这些函数提供了用于与数值近似值进行比较的参考值。\n\n问题要求为系统 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 实现两种数值积分格式。对于离散时间步长 $h$，我们将时间 $t_{n} = n h$ 时的状态表示为 $\\mathbf{y}_{n}$。\n\n1. **显式欧拉法 (Explicit Euler Method)**：这是一种一阶方法。下一时间步的状态 $\\mathbf{y}_{n+1}$ 通过简单的前向外推得到：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_{n} + h \\mathbf{f}(\\mathbf{y}_{n})\n$$\n用分量形式表示为：\n$$\nx_{n+1} = x_{n} + h v_{n}\n$$\n$$\nv_{n+1} = v_{n} - h \\omega^{2} x_{n}\n$$\n\n2. **经典四阶龙格-库塔 (RK4) 法 (Classical Fourth-Order Runge-Kutta (RK4) Method)**：这是一种四阶方法，以其在精度和计算成本之间的良好平衡而闻名。其更新规则是：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_{n} + \\frac{h}{6} (\\mathbf{k}_{1} + 2\\mathbf{k}_{2} + 2\\mathbf{k}_{3} + \\mathbf{k}_{4})\n$$\n其中中间斜率 $\\mathbf{k}_{i}$ 的计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_{1} = \\mathbf{f}(\\mathbf{y}_{n}) \\\\\n\\mathbf{k}_{2} = \\mathbf{f}(\\mathbf{y}_{n} + \\frac{h}{2}\\mathbf{k}_{1}) \\\\\n\\mathbf{k}_{3} = \\mathbf{f}(\\mathbf{y}_{n} + \\frac{h}{2}\\mathbf{k}_{2}) \\\\\n\\mathbf{k}_{4} = \\mathbf{f}(\\mathbf{y}_{n} + h\\mathbf{k}_{3})\n\\end{aligned}\n$$\n\n为了量化误差，我们使用缩放状态向量 $\\mathbf{s}(t) = \\begin{bmatrix} x(t) \\\\ v(t)/\\omega \\end{bmatrix}$。对于精确解，该向量的欧几里得范数的平方 $\\|\\mathbf{s}_{\\mathrm{exact}}(t)\\|_{2}^{2} = x_{\\mathrm{exact}}(t)^2 + (v_{\\mathrm{exact}}(t)/\\omega)^2$ 是一个守恒量，等于常数值 $x_{0}^{2} + (v_{0}/\\omega)^{2}$。这为定义相对误差提供了一个稳定的归一化因子。\n\n在每个离散时间 $t_{n}$，绝对误差是数值和精确缩放状态之间的欧几里得距离：\n$$\nE_{\\mathrm{abs}}(t_{n}) = \\| \\mathbf{s}_{\\mathrm{num}}(t_{n}) - \\mathbf{s}_{\\mathrm{exact}}(t_{n}) \\|_{2}\n$$\n然后，相对误差定义为：\n$$\nE_{\\mathrm{rel}}(t_{n}) = \\frac{E_{\\mathrm{abs}}(t_{n})}{\\| \\mathbf{s}_{\\mathrm{exact}}(t_{0}) \\|_{2}} = \\frac{\\| \\mathbf{s}_{\\mathrm{num}}(t_{n}) - \\mathbf{s}_{\\mathrm{exact}}(t_{n}) \\|_{2}}{\\sqrt{x_{0}^{2} + (v_{0}/\\omega)^{2}}}\n$$\n只要初始状态不为平凡情况（$x_0$ 和 $v_0$ 不都为零），分母在整个模拟过程中是恒定的。\n\n每个测试用例的计算流程如下：\n1. 设置参数 $(\\omega, x_{0}, v_{0}, h, T)$。\n2. 确定步数 $N = T/h$。\n3. 创建时间点数组 $t_{n} = n h$，其中 $n = 0, 1, \\dots, N$。\n4. 计算所有时间点的精确解 $\\mathbf{y}_{\\mathrm{exact}}(t_{n})$。\n5. 用初始条件 $\\begin{bmatrix} x_{0} \\\\ v_{0} \\end{bmatrix}$ 初始化数值解 $\\mathbf{y}^{\\mathrm{Euler}}_{0}$ 和 $\\mathbf{y}^{\\mathrm{RK4}}_{0}$。\n6. 初始化相对误差 $E_{\\mathrm{rel}}^{\\mathrm{Euler}}$ 和 $E_{\\mathrm{rel}}^{\\mathrm{RK4}}$ 的历史记录，在 $t=0$ 时误差为 $0$。\n7. 对 $n$ 从 $0$ 到 $N-1$ 进行循环：\n    a. 使用各自的更新规则计算 $\\mathbf{y}^{\\mathrm{Euler}}_{n+1}$ 和 $\\mathbf{y}^{\\mathrm{RK4}}_{n+1}$。\n    b. 在 $t_{n+1}$ 时刻，为两种方法构建缩放状态向量 $\\mathbf{s}_{\\mathrm{num}}(t_{n+1})$ 以及精确的缩放状态向量 $\\mathbf{s}_{\\mathrm{exact}}(t_{n+1})$。\n    c. 计算两种方法的 $E_{\\mathrm{rel}}(t_{n+1})$ 并记录其值。\n8. 循环结束后，提取在 $t_N = T$ 时的最终相对误差，即 $E_{\\mathrm{rel}}^{\\mathrm{Euler}}(T)$ 和 $E_{\\mathrm{rel}}^{\\mathrm{RK4}}(T)$。\n9. 确定整个轨迹上的最大相对误差，即 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{Euler}}(t_{n})$ 和 $\\max_{0 \\le n \\le N} E_{\\mathrm{rel}}^{\\mathrm{RK4}}(t_{n})$。\n10. 报告这四个计算出的值，并按指定格式进行格式化。\n\n对所有给定的测试用例重复此过程。显式欧拉法预计会表现出误差增长，通常随时间线性增长，且误差阶为 $O(h)$。RK4 方法的阶数更高，预计能在更长的时间内保持小得多的误差，其误差阶为 $O(h^4)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Euler and RK4 integrators for a simple\n    harmonic oscillator, as specified in the problem statement.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (omega, x0, v0, h, T)\n        (1.0, 1.0, 0.0, 0.01, 10.0),\n        (1.0, 1.0, 0.0, 0.1, 50.0),\n        (2.0, 1.0, 0.0, 0.05, 25.0),\n        (1.0, 1.0, 1.0, 0.25, 20.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, x0, v0, h, T = case\n\n        # Ensure N is an integer to avoid floating-point issues in loop ranges\n        N = int(round(T / h))\n        times = np.linspace(0, T, N + 1)\n\n        # --- Define the ODE system ---\n        def f(y, omega_val):\n            \"\"\"RHS of the ODE system: dy/dt = f(y)\"\"\"\n            x, v = y\n            return np.array([v, -omega_val**2 * x])\n\n        # --- Exact Solution ---\n        # Vectorized calculation for all time points\n        x_exact = x0 * np.cos(omega * times) + (v0 / omega) * np.sin(omega * times)\n        v_exact = -x0 * omega * np.sin(omega * times) + v0 * np.cos(omega * times)\n        s_exact = np.vstack((x_exact, v_exact / omega)).T\n\n        # --- Normalization factor for relative error ---\n        norm = np.sqrt(x0**2 + (v0 / omega)**2)\n        if norm == 0:\n            # Handle trivial case, though not present in test suite\n            all_results.append([0.0, 0.0, 0.0, 0.0])\n            continue\n\n        # --- Numerical Integration ---\n        # Initialize states\n        y_euler = np.array([x0, v0])\n        y_rk4 = np.array([x0, v0])\n        \n        # Histories for relative errors (N+1 points, from t=0 to t=T)\n        rel_err_euler_hist = [0.0]\n        rel_err_rk4_hist = [0.0]\n\n        for i in range(N):\n            # Euler step\n            y_euler = y_euler + h * f(y_euler, omega)\n\n            # RK4 step\n            k1 = f(y_rk4, omega)\n            k2 = f(y_rk4 + 0.5 * h * k1, omega)\n            k3 = f(y_rk4 + 0.5 * h * k2, omega)\n            k4 = f(y_rk4 + h * k3, omega)\n            y_rk4 = y_rk4 + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # --- Error Calculation at step i+1 ---\n            # Scaled numerical states\n            s_euler_num = np.array([y_euler[0], y_euler[1] / omega])\n            s_rk4_num = np.array([y_rk4[0], y_rk4[1] / omega])\n            \n            # Exact scaled state at this time\n            s_exact_current = s_exact[i + 1]\n\n            # Absolute errors\n            abs_err_euler = np.linalg.norm(s_euler_num - s_exact_current)\n            abs_err_rk4 = np.linalg.norm(s_rk4_num - s_exact_current)\n\n            # Relative errors\n            rel_err_euler = abs_err_euler / norm\n            rel_err_rk4 = abs_err_rk4 / norm\n\n            rel_err_euler_hist.append(rel_err_euler)\n            rel_err_rk4_hist.append(rel_err_rk4)\n\n        # --- Collect results for this case ---\n        # Final-time relative errors\n        e_rel_euler_final = rel_err_euler_hist[-1]\n        e_rel_rk4_final = rel_err_rk4_hist[-1]\n        \n        # Maximum relative errors over the trajectory\n        max_e_rel_euler = max(rel_err_euler_hist)\n        max_e_rel_rk4 = max(rel_err_rk4_hist)\n\n        all_results.append([\n            e_rel_euler_final,\n            e_rel_rk4_final,\n            max_e_rel_euler,\n            max_e_rel_rk4\n        ])\n\n    # --- Final Output Formatting ---\n    # Format each number and build the final string representation\n    # Use {:.9e} to get 10 significant digits in scientific notation.\n    case_strings = []\n    for result_set in all_results:\n        formatted_nums = [f\"{num:.9e}\" for num in result_set]\n        case_strings.append(f\"[{','.join(formatted_nums)}]\")\n\n    final_output_str = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}