{
    "hands_on_practices": [
        {
            "introduction": "N体问题是计算物理学中的一个基石，广泛应用于天体物理学和分子动力学等领域。最直接的模拟方法是计算所有粒子对之间的相互作用，这个练习  将指导你分析这种“暴力”算法的计算成本（时间复杂度）和内存需求（空间复杂度）。通过这个过程，你将揭示经典的 $O(N^2)$ 时间复杂度，并理解为何需要发展更高级的算法。",
            "id": "2372962",
            "problem": "一个分子动力学代码使用蛙跳积分器，通过成对中心力，在三维空间中推进一个由$N$个质量为$m$的相同粒子组成的系统。一个大小为$\\Delta t$的完整时间步实现如下，其中粗体符号表示$\\mathbb{R}^{3}$中的向量，且索引遍历所有粒子：\n\n- 半步踢：对于$i = 1,\\dots,N$，按如下方式更新速度\n$$\\mathbf{v}_{i} \\leftarrow \\mathbf{v}_{i} + \\frac{\\Delta t}{2}\\,\\mathbf{a}_{i}.$$\n\n- 漂移：对于$i = 1,\\dots,N$，按如下方式更新位置\n$$\\mathbf{x}_{i} \\leftarrow \\mathbf{x}_{i} + \\Delta t\\,\\mathbf{v}_{i}.$$\n\n- 重新计算加速度：\n  - 重置：对于$i = 1,\\dots,N$，设置\n  $$\\mathbf{a}_{i} \\leftarrow \\mathbf{0}.$$\n  - 成对累加：对于$i = 1,\\dots,N-1$和$j = i+1,\\dots,N$，计算相对位移\n  $$\\mathbf{r}_{ij} = \\mathbf{x}_{i} - \\mathbf{x}_{j},$$\n  计算形式如下的中心对力\n  $$\\mathbf{f}_{ij} = \\varphi\\!\\left(|\\mathbf{r}_{ij}|\\right)\\,\\mathbf{r}_{ij},$$\n  其中$\\varphi$是一个与$N$无关的固定函数，并累加\n  $$\\mathbf{a}_{i} \\leftarrow \\mathbf{a}_{i} + \\frac{\\mathbf{f}_{ij}}{m}, \\qquad \\mathbf{a}_{j} \\leftarrow \\mathbf{a}_{j} - \\frac{\\mathbf{f}_{ij}}{m}.$$\n\n- 半步踢：对于$i = 1,\\dots,N$，按如下方式更新速度\n$$\\mathbf{v}_{i} \\leftarrow \\mathbf{v}_{i} + \\frac{\\Delta t}{2}\\,\\mathbf{a}_{i}.$$\n\n假设：\n- 空间维度$d=3$是固定的，不随$N$变化。\n- 对于单个粒子对$(i,j)$，计算$\\varphi\\!\\left(|\\mathbf{r}_{ij}|\\right)$、形成$\\mathbf{f}_{ij}$以及应用两个加速度更新，需要与$N$无关的常数数量的算术运算，并使用常数数量的额外内存。\n- 没有邻居列表、截断、区域分解或其他改变渐近粒子对计数的数据结构。\n- 所有算术运算都在常数时间内完成，循环开销与迭代次数成线性关系。\n- 积分器存储数组$\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$、$\\{\\mathbf{v}_{i}\\}_{i=1}^{N}$和$\\{\\mathbf{a}_{i}\\}_{i=1}^{N}$；除常数大小的参数和循环索引外，不计算任何其他数据。\n\n使用算法时间复杂度和空间复杂度的定义，以$N$的函数和大O表示法，确定每个时间步的总时间复杂度以及上述积分器状态的总空间复杂度。将最终答案以一个包含两个条目的行矩阵形式给出，第一个是时间复杂度，第二个是空间复杂度，每个都表示为单个大O表达式。",
            "solution": "首先验证问题陈述的正确性和可解性。\n\n**第1步：提取已知条件**\n- 系统：$N$个质量为$m$的相同粒子，位于三维空间中。\n- 算法：一个大小为$\\Delta t$的蛙跳积分器的单个时间步。\n  - 步骤1：半步踢速度更新：对于$i = 1,\\dots,N$，$\\mathbf{v}_{i} \\leftarrow \\mathbf{v}_{i} + \\frac{\\Delta t}{2}\\,\\mathbf{a}_{i}$。\n  - 步骤2：漂移位置更新：对于$i = 1,\\dots,N$，$\\mathbf{x}_{i} \\leftarrow \\mathbf{x}_{i} + \\Delta t\\,\\mathbf{v}_{i}$。\n  - 步骤3：重新计算加速度$\\mathbf{a}_i$。这包括将所有$\\mathbf{a}_i$重置为$\\mathbf{0}$，然后对所有满足 $1 \\le i  j \\le N$ 的粒子对 $(i,j)$ 计算力并更新加速度。\n  - 步骤4：第二个半步踢速度更新：同步骤1。\n- 成本模型：\n  - 算术运算成本恒定。\n  - 单个粒子对的力计算成本恒定。\n  - 循环开销与迭代次数成线性关系。\n- 内存模型：存储$\\{\\mathbf{x}_{i}\\}, \\{\\mathbf{v}_{i}\\}, \\{\\mathbf{a}_{i}\\}$，每个都是包含 $N$ 个三维向量的数组。\n\n**第2步：分析时间复杂度**\n我们将分析每个主要步骤的成本：\n1.  **第一个半步踢**：这个循环遍历所有$N$个粒子。对于每个粒子，它执行一次向量加法和一次标量-向量乘法。由于每个操作的成本都是恒定的，这个循环的总成本是$O(N)$。\n2.  **漂移**：这个循环也遍历所有$N$个粒子。与踢步骤类似，它的总成本是$O(N)$。\n3.  **重新计算加速度**：这一步是关键。\n    -   **重置**：将$N$个加速度向量$\\mathbf{a}_{i}$重置为零。这需要$O(N)$的操作。\n    -   **成对累加**：这是主导计算的部分。该算法使用一个嵌套循环遍历所有唯一的粒子对。外层循环从$i=1$到$N-1$，内层循环从$j=i+1$到$N$。总迭代次数是\n        $$ \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} 1 = \\sum_{i=1}^{N-1} (N-i) = (N-1) + (N-2) + \\dots + 1 = \\frac{(N-1)N}{2} $$\n        因此，有$O(N^2)$个粒子对。根据假设，对每个粒子对的力计算和加速度更新都花费常数时间。所以，成对累加步骤的总成本是$O(N^2)$。\n    -   重新计算加速度的总成本是$O(N) + O(N^2) = O(N^2)$。\n4.  **第二个半步踢**：与第一个踢步骤相同，成本为$O(N)$。\n\n将所有步骤的成本相加，得到单个时间步的总时间复杂度：\n$$ T(N) = O(N) + O(N) + O(N^2) + O(N) = O(N^2) $$\n主导项是成对力计算的$O(N^2)$。\n\n**第3步：分析空间复杂度**\n根据假设，积分器存储三个数组：位置$\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$、速度$\\{\\mathbf{v}_{i}\\}_{i=1}^{N}$和加速度$\\{\\mathbf{a}_{i}\\}_{i=1}^{N}$。\n- 每个数组存储$N$个三维向量。\n- 每个三维向量需要恒定的存储空间（例如，3个双精度浮点数）。\n- 因此，每个数组需要的存储空间是$O(N)$。\n- 三个数组的总存储空间是$O(N) + O(N) + O(N) = O(N)$。\n问题陈述还指出，除常数大小的变量外，没有使用其他数据结构。因此，总空间复杂度为$O(N)$。\n\n**第4步：总结结果**\n- 时间复杂度：$O(N^2)$\n- 空间复杂度：$O(N)$\n将结果表示为所要求的行矩阵形式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nO(N^2)  O(N)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从模拟离散粒子到模拟连续场，求解偏微分方程（PDEs）是计算物理的另一项核心任务。对于像热传导方程这样的问题，显式数值方法的稳定性通常要求时间步长 $\\Delta t$ 与空间步长 $\\Delta x$ 的平方成正比。这个练习  将向你展示这种稳定性条件如何决定了模拟所需的总时间步数，并最终影响整体的计算复杂度，得出一个可能超出你直觉预期的结果。",
            "id": "2373011",
            "problem": "考虑在方形域 $[0,L]\\times[0,L]$ 上，对二维（$2$-维）热方程进行显式有限差分时间积分，直至固定的最终时间 $T$。该域在均匀笛卡尔网格上进行离散化，每个空间方向上有 $M$ 个内部点，因此网格间距为 $\\Delta x = L/(M+1)$。令 $N = M^{2}$ 表示内部未知数的总数。假设在每个时间步中，算法会更新所有内部网格点，并且每次网格点更新需要恒定数量 $c_{\\mathrm{op}}$ 的浮点运算（FLOP），此数量与 $M$ 无关。该显式格式使用的时间步长受稳定性约束，为 $\\Delta t = \\kappa (\\Delta x)^{2}$，其中 $\\kappa0$ 是一个不依赖于 $M$、$N$、$L$ 或 $T$ 的常数。\n\n仅使用这些假设，确定当 $M\\to\\infty$ 时，达到时间 $T$ 所需的渐近总浮点运算次数，并将最终结果表示为仅含 $N$ 的单个 Big-$\\mathcal{O}$ 表达式。提供无单位的单个解析表达式作为最终答案。",
            "solution": "问题要求确定将二维热方程积分至固定时间 $T$ 所需的渐近总计算成本，以浮点运算（FLOP）次数衡量。该分析必须基于所给定的关于显式有限差分格式的假设。\n\n首先，我们形式化总浮点运算次数，记为 $F_{\\text{total}}$。该总成本是达到最终时间 $T$ 所需的每时间步的计算成本 $F_{\\text{step}}$ 与总时间步数 $K_{\\text{steps}}$ 的乘积。\n$$F_{\\text{total}} = F_{\\text{step}} \\times K_{\\text{steps}}$$\n\n问题陈述，在每个时间步中，算法会更新所有内部网格点。内部网格点的总数给定为 $N$。更新单个网格点的成本是一个常数 $c_{\\text{op}}$，它不依赖于网格尺寸。因此，每时间步的成本与被更新的点的数量成正比：\n$$F_{\\text{step}} = c_{\\text{op}} N$$\n这意味着每一步的成本是 $\\mathcal{O}(N)$ 阶。\n\n接下来，我们必须确定时间步数 $K_{\\text{steps}}$。模拟运行总时长为 $T$，每步将时间推进 $\\Delta t$。因此，\n$$K_{\\text{steps}} = \\frac{T}{\\Delta t}$$\n\n分析的关键在于理解时间步长 $\\Delta t$ 的标度关系。问题指明，对于这种显式格式，时间步长受稳定性条件的约束：\n$$\\Delta t = \\kappa (\\Delta x)^2$$\n其中 $\\kappa  0$ 是一个与离散化参数无关的常数，$\\Delta x$ 是网格间距。\n\n该域是一个边长为 $L$ 的正方形，沿每个维度用 $M$ 个内部点进行离散化。这给出的网格间距为：\n$$\\Delta x = \\frac{L}{M+1}$$\n内部未知数的总数 $N$ 与 $M$ 的关系是 $N = M^2$。由此，当 $M \\ge 0$ 时，我们可以将 $M$ 表示为 $N$ 的函数，即 $M = \\sqrt{N}$。将此代入 $\\Delta x$ 的表达式中：\n$$\\Delta x = \\frac{L}{\\sqrt{N}+1}$$\n\n现在，我们可以将时间步长 $\\Delta t$ 表示为 $N$ 的函数：\n$$\\Delta t = \\kappa \\left( \\frac{L}{\\sqrt{N}+1} \\right)^2 = \\frac{\\kappa L^2}{(\\sqrt{N}+1)^2}$$\n\n有了 $\\Delta t$ 的这个表达式，总时间步数变为：\n$$K_{\\text{steps}} = \\frac{T}{\\Delta t} = \\frac{T (\\sqrt{N}+1)^2}{\\kappa L^2}$$\n\n我们关心的是当 $M \\to \\infty$ 时的渐近行为，这对应于 $N \\to \\infty$。对于大的 $N$，$(\\sqrt{N}+1)^2$ 项的行为类似于 $N$。更正式地：\n$$(\\sqrt{N}+1)^2 = N + 2\\sqrt{N} + 1$$\n当 $N \\to \\infty$ 时，主导项是 $N$。因此，$K_{\\text{steps}}$ 渐近正比于 $N$：\n$$K_{\\text{steps}} = \\frac{T}{\\kappa L^2} (N + 2\\sqrt{N} + 1) = \\mathcal{O}(N)$$\n\n最后，我们可以结合 $F_{\\text{step}}$ 和 $K_{\\text{steps}}$ 的结果来求得总计算成本 $F_{\\text{total}}$：\n$$F_{\\text{total}} = F_{\\text{step}} \\times K_{\\text{steps}} = (c_{\\text{op}} N) \\times \\left( \\frac{T (\\sqrt{N}+1)^2}{\\kappa L^2} \\right)$$\n让我们将所有与 $N$ 无关的常数合并为一个项，$C = \\frac{c_{\\text{op}} T}{\\kappa L^2}$。\n$$F_{\\text{total}} = C \\cdot N \\cdot (\\sqrt{N}+1)^2 = C \\cdot N (N + 2\\sqrt{N} + 1) = C (N^2 + 2N^{3/2} + N)$$\n为了使用 Big-$\\mathcal{O}$ 记法，我们找出当 $N \\to \\infty$ 时 $F_{\\text{total}}$ 表达式中 $N$ 的最高次幂。在多项式 $N^2 + 2N^{3/2} + N$ 中，主导项是 $N^2$。\n因此，渐近总浮点运算次数由下式给出：\n$$F_{\\text{total}} = \\mathcal{O}(N^2)$$\n这个结果表明，对于二维热方程，显式方法的计算复杂度与未知数数量成二次方关系。这是由稳定性准则所施加的严格时间步长限制导致的，而这种限制是抛物型问题显式方法的典型特征。",
            "answer": "$$\n\\boxed{\\mathcal{O}(N^{2})}\n$$"
        },
        {
            "introduction": "在许多优化算法中，高效地对数据进行排序（例如按空间位置对粒子进行排序）是一个常见的预处理步骤。尽管像快速排序（Quicksort）这样的算法在平均情况下表现优异，但其最坏情况下的性能可能成为一个严重的问题。这个练习  挑战你从被动的分析者转变为主动的构建者：你需要设计一个“病态”输入，迫使快速排序算法达到其 $O(N^2)$ 的最坏性能，从而深刻理解算法的稳健性问题。",
            "id": "2372995",
            "problem": "您将处理一个形式化的空间排序任务，该任务出现在计算物理学中，用于为局部敏感操作（如邻近搜索）排列粒子数据。考虑三维空间中的一个包含 $N$ 个粒子的集合，其位置为 $\\mathbf{r}_i = (x_i,y_i,z_i) \\in \\mathbb{R}^3$。每个粒子都映射到一个空间键 $K(\\mathbf{r}_i) = (x_i,y_i,z_i)$，并且这些键按字典序进行全序排列：对于任意的 $\\mathbf{a} = (x_a,y_a,z_a)$ 和 $\\mathbf{b} = (x_b,y_b,z_b)$，我们定义 $K(\\mathbf{a}) \\le K(\\mathbf{b})$ 当且仅当 $x_a  x_b$，或 $x_a = x_b$ 且 $y_a  y_b$，或 $x_a = x_b$、$y_a = y_b$ 且 $z_a \\le z_b$。\n\n定义一个排序算法，该算法对一个空间键数组 $A$ 进行操作，并使用确定性快速排序（采用 Lomuto 分区方案且以最后一个元素为主元）按非递减字典序对其进行排序。对于子数组 $A[\\ell..r]$，分区过程设置主元 $p = A[r]$，初始化 $i = \\ell - 1$，然后对于从 $\\ell$ 到 $r-1$ 的每个 $j$，执行一次形如 $A[j] \\le p$ 的键比较；如果比较结果为真，则将 $i$ 递增并交换 $A[i]$ 和 $A[j]$。循环结束后，交换 $A[i+1]$ 和 $A[r]$，并返回主元索引 $i+1$。当 $\\ell  r$ 时，快速排序接着对 $A[\\ell..i]$ 和 $A[i+2..r]$ 进行递归。“键比较”精确地指在分区循环内部对形如 $K(\\cdot) \\le K(\\cdot)$ 的关系式进行一次求值；不计算任何其他操作。\n\n您的任务是为下面的每个测试用例设计一个具体的粒子分布（即一个遵循所述约束的位置 $\\mathbf{r}_i$ 的有序列表），当上述排序算法应用于您的粒子的空间键时，该分布会触发最坏情况的 $\\mathcal{O}(N^2)$ 行为。对于每个测试用例，您必须将定义的算法应用于您构建的分布，并报告在整个排序过程中执行的键比较的确切数量。\n\n测试套件（每个用例指定了 $N$ 和对允许的粒子坐标的约束）：\n\n- 用例 1：$N = 1$。约束：位置 $\\mathbf{r}_i$ 可以是任意实值三元组；无额外限制。\n- 用例 2：$N = 2$。约束：空间键 $K(\\mathbf{r}_i)$ 必须两两不同。\n- 用例 3：$N = 10$。约束：空间键 $K(\\mathbf{r}_i)$ 必须两两不同，并且对于所有 $i$ 都满足 $y_i = 0$ 和 $z_i = 0$，其中 $x_i \\in \\{0,1,2,3,4,5,6,7,8,9\\}$。\n- 用例 4：$N = 10$。约束：所有空间键都相同，即 $K(\\mathbf{r}_1) = K(\\mathbf{r}_2) = \\dots = K(\\mathbf{r}_{10})$。\n- 用例 5：$N = 9$。约束：对于所有 $i$，都满足 $x_i = 0$ 和 $z_i = 0$，而 $y_i$ 是两两不同的实数。\n\n对于每个用例，构建一个在指定算法下能达到最坏情况行为的有效粒子分布，并计算快速排序执行的键比较总数。您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中 $r_k$ 是用例 $k$（按顺序 $k=1,2,3,4,5$）的键比较次数的整数值。",
            "solution": "所提出的问题是有效的。这是一个基于计算物理学背景的、定义良好的算法分析练习，所有术语和过程都得到了严格的定义。不存在科学上的不一致、逻辑上的矛盾或歧义。我将开始解答。\n\n任务是确定特定 Quicksort 算法实现的最大键比较次数，并构建触发此最坏情况行为的输入分布。该算法是确定性快速排序，使用最后一个元素作为主元，并采用 Lomuto 分区方案。键比较被定义为在分区循环内对 $A[j] \\le p$ 的一次求值。\n\nQuicksort 的最坏情况时间复杂度为 $\\mathcal{O}(N^2)$，当分区过程持续产生最不平衡的可能划分时发生。对于大小为 $n$ 的子数组，Lomuto 分区过程恰好执行 $n-1$ 次键比较。一次最大程度不平衡的划分将大小为 $n$ 的数组划分为一个大小为 $n-1$ 的子问题和一个大小为 $0$ 的子问题。如果这在每个递归步骤中都发生，那么对于大小为 $N$ 的初始数组，总比较次数（记为 $C(N)$）遵循以下递推关系：\n$$\nC(n) = (n-1) + C(n-1)\n$$\n递归的基本情况是 $C(1) = 0$，因为不满足递归条件 $\\ell  r$。展开此递推式可得：\n$$\nC(N) = (N-1) + (N-2) + \\dots + C(1) = \\sum_{k=1}^{N-1} k = \\frac{(N-1)N}{2}\n$$\n这就是最大键比较次数的公式。\n\n我们的目标是为每个测试用例构建一个初始空间键数组，以确保在每一步都发生这种最坏情况的分区。对于主元 $p = A[r]$ 的 Lomuto 分区，如果主元是子数组 $A[\\ell..r]$ 中的最小或最大元素，就会实现最坏情况的划分。这是因为所有其他元素都将被放置在主元最终位置的一侧。为每个递归调用保证此条件的一个简单方法是提供一个已经排好序的初始数组（按非递减或非递增字典序）。\n\n我们来分析一个非递减有序数组的情况。初始主元是 $A[N-1]$，即最大元素。在 `partition` 函数中，对于所有从 $0$ 到 $N-2$ 的 $j$，比较 $A[j] \\le p$ 都将为真。这将导致 $N-1$ 次比较。分区将主元放置在索引 $N-1$ 处，从而导致对子数组 $A[0..N-2]$ 的递归调用，而该子数组本身也是有序的。这种模式会重复，从而产生最坏情况的比较次数。类似的分析也适用于所有元素都相同的数组（因为条件 $A[j] \\le p$ 始终为真），以及逆序数组（其中主元总是最小值）。\n\n现在我们将此原则应用于每个测试用例。\n\n**用例 1**：$N=1$\n输入是一个大小为 1 的数组。对 `quicksort(A, 0, 0)` 的初始调用不满足条件 $\\ell  r$（因为 $0 \\not 0$）。因此，不会发生分区，也不会进行比较。\n一个有效的粒子分布是 $\\mathbf{r}_1 = (0,0,0)$。\n比较次数：$C(1) = \\frac{1(0)}{2} = 0$。\n\n**用例 2**：$N=2$\n约束是键必须两两不同。为了触发最坏情况，我们构建一个有序的键数组。例如：\n$\\mathbf{r}_1 = (0,0,0)$ 和 $\\mathbf{r}_2 = (1,0,0)$。键为 $K_1=(0,0,0)$ 和 $K_2=(1,0,0)$，它们是按字典序排列的。\n比较次数：$C(2) = \\frac{2(1)}{2} = 1$。\n\n**用例 3**：$N=10$\n约束是 $y_i=0$，$z_i=0$，并且 $x_i \\in \\{0,1,2,3,4,5,6,7,8,9\\}$ 是不同的。字典序完全由 $x_i$ 坐标决定。我们构建一个有序分布：\n对于 $i=1, \\dots, 10$，$\\mathbf{r}_i = (i-1, 0, 0)$。这会得到有序的键数组 $A = [(0,0,0), (1,0,0), \\dots, (9,0,0)]$。\n比较次数：$C(10) = \\frac{10(9)}{2} = 45$。\n\n**用例 4**：$N=10$\n约束是所有键都相同。例如，对于所有 $i=1, ..., 10$，$\\mathbf{r}_i = (0,0,0)$。输入数组由 10 个相同的键组成。如前所述，当对所有元素都相同的子数组 $A[\\ell..r]$ 进行分区时，主元 $p=A[r]$ 与所有其他元素相等。比较 $A[j] \\le p$ 总是为真。这导致了与有序数组相同的最大程度不平衡的分区。\n比较次数：$C(10) = \\frac{10(9)}{2} = 45$。\n\n**用例 5**：$N=9$\n约束是 $x_i=0$，$z_i=0$，并且 $y_i$ 坐标是不同的。字典序完全由 $y_i$ 坐标决定。我们构建一个有序分布：\n对于 $i=1, \\dots, 9$，$\\mathbf{r}_i = (0, i-1, 0)$。这会得到有序的键数组 $A = [(0,0,0), (0,1,0), \\dots, (0,8,0)]$。\n比较次数：$C(9) = \\frac{9(8)}{2} = 36$。\n\n最终结果是为每个用例计算出的比较次数：$[0, 1, 45, 45, 36]$。以下程序实现了指定的算法，并在构建的最坏情况输入上验证了这些计数。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\nclass QuickSortAnalyzer:\n    \"\"\"\n    A class to encapsulate the specified Quicksort algorithm and count key comparisons.\n    \"\"\"\n    def __init__(self):\n        self.comparisons = 0\n\n    def _compare_keys(self, key1, key2):\n        \"\"\"\n        Performs a single lexicographical comparison and increments the counter.\n        Python's tuple comparison is lexicographical, matching the problem's definition.\n        \"\"\"\n        self.comparisons += 1\n        # The problem defines comparison as A[j] = p\n        return key1 = key2\n\n    def _partition(self, arr, low, high):\n        \"\"\"\n        Lomuto partition scheme using the last element as pivot.\n        \"\"\"\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if self._compare_keys(arr[j], pivot):\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        \n        # Place pivot in its final sorted position\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def _quicksort(self, arr, low, high):\n        \"\"\"\n        Recursive Quicksort algorithm as defined in the problem.\n        \"\"\"\n        if low  high:\n            # pi is the partitioning index, arr[pi] is now at the right place.\n            pi = self._partition(arr, low, high)\n\n            # Recursively sort elements before and after partition\n            self._quicksort(arr, low, pi - 1)\n            self._quicksort(arr, pi + 1, high)\n\n    def run_and_count(self, particle_distribution):\n        \"\"\"\n        Runs the Quicksort on a given particle distribution and returns the comparison count.\n        \"\"\"\n        self.comparisons = 0\n        keys = list(particle_distribution) # Make a mutable copy\n        n = len(keys)\n        if n > 0:\n            self._quicksort(keys, 0, n - 1)\n        return self.comparisons\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases and compute the results.\n    \"\"\"\n    \n    # Each test case is a list of particle positions (tuples) constructed to\n    # trigger the worst-case behavior of the specified Quicksort algorithm,\n    # while adhering to the problem's constraints. The worst-case is triggered\n    # by inputs that are already sorted, reverse-sorted, or have all equal elements.\n    \n    test_cases = [\n        # Case 1: N = 1. Trivial case. sorted.\n        [(0.0, 0.0, 0.0)],\n        \n        # Case 2: N = 2. Pairwise distinct keys. Constructed as sorted.\n        [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)],\n        \n        # Case 3: N = 10. Distinct keys with y_i=z_i=0, x_i in {0..9}. Constructed as sorted.\n        [(float(i), 0.0, 0.0) for i in range(10)],\n        \n        # Case 4: N = 10. All keys identical. This also triggers the worst-case.\n        [(0.0, 0.0, 0.0)] * 10,\n        \n        # Case 5: N = 9. Distinct keys with x_i=z_i=0. Constructed by sorting y_i.\n        [(0.0, float(i), 0.0) for i in range(9)]\n    ]\n\n    analyzer = QuickSortAnalyzer()\n    results = []\n    \n    for case_data in test_cases:\n        count = analyzer.run_and_count(case_data)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    # print(f\"[{','.join(map(str, results))}]\")\n    # This function is not called in the actual environment,\n    # but it verifies the hand-calculated results. The expected output is [0,1,45,45,36]\n\n# The following call is for local verification and would not be executed in the target environment.\n# solve()\n```",
            "answer": "$$\n\\boxed{[0, 1, 45, 45, 36]}\n$$"
        }
    ]
}