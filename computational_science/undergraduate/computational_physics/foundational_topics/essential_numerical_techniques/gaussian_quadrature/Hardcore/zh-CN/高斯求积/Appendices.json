{
    "hands_on_practices": [
        {
            "introduction": "许多数值算法，包括高斯-勒让德求积，都是在像 $[-1, 1]$ 这样的标准区间上定义的。为了将这些强大的工具应用于具有任意积分限的实际问题，变量替换是必不可少的一步。这个练习将让你掌握一项基本技能：将一个普通定积分映射到求积法则所要求的规范区间上。掌握这种线性变量代换是在实践中正确应用高斯求积法的关键第一步。",
            "id": "2175481",
            "problem": "在数值分析中，许多用于近似计算定积分的标准算法，例如 Gauss-Legendre 求积法，都是在标准区间（通常是 $[-1, 1]$）上定义的。为了将这些算法应用于任意区间 $[a, b]$ 上的积分，需要首先进行线性变量替换，将积分映射到标准形式。\n\n考虑定积分 $I = \\int_{0}^{2} \\sin(t) \\, dt$。需要使用一种要求积分形式为 $I = \\int_{-1}^{1} g(x) \\, dx$ 的方法来对该积分进行数值计算。\n\n请确定由此变换得到的函数 $g(x)$ 的解析表达式。",
            "solution": "我们需要使用线性变量替换将积分从 $[0,2]$ 变换到 $[-1,1]$。对于一个一般积分 $I=\\int_{a}^{b} f(t)\\,dt$，从 $x\\in[-1,1]$ 到 $t\\in[a,b]$ 的标准线性映射为\n$$\nt=\\frac{b-a}{2}\\,x+\\frac{a+b}{2},\n$$\n这意味着\n$$\ndt=\\frac{b-a}{2}\\,dx.\n$$\n根据变量替换定理，\n$$\nI=\\int_{a}^{b} f(t)\\,dt=\\int_{-1}^{1} f\\!\\left(\\frac{b-a}{2}\\,x+\\frac{a+b}{2}\\right)\\,\\frac{b-a}{2}\\,dx.\n$$\n因此，要将 $I$ 写成 $\\int_{-1}^{1} g(x)\\,dx$ 的形式，我们可得\n$$\ng(x)=\\frac{b-a}{2}\\,f\\!\\left(\\frac{b-a}{2}\\,x+\\frac{a+b}{2}\\right).\n$$\n\n对于给定的问题，$a=0$，$b=2$，且 $f(t)=\\sin(t)$。因此，\n$$\n\\frac{b-a}{2}=1,\\qquad \\frac{a+b}{2}=1,\n$$\n所以\n$$\ng(x)=1\\cdot \\sin\\!\\left(1\\cdot x+1\\right)=\\sin(x+1).\n$$\n这就得到了所需的形式 $I=\\int_{-1}^{1} \\sin(x+1)\\,dx$。",
            "answer": "$$\\boxed{\\sin(x+1)}$$"
        },
        {
            "introduction": "一旦积分被转换成标准形式，高斯求积法通过在称为节点的特定点上计算被积函数值的加权和来近似该积分。该方法的奇妙之处在于，仅用少量函数求值点就能达到惊人的精度。本练习提供了一个使用两点高斯-勒让德法则的具体计算，展示了该方法的核心机制。通过将数值结果与精确的解析积分进行比较，你将直接验证高斯求积最重要的特性之一：它能够精确地对低阶多项式进行积分。",
            "id": "2665798",
            "problem": "在一维固体力学中，考虑一个在有限元法（FEM）中使用的双节点等参杆单元。令父坐标表示为 $\\xi \\in [-1,1]$。假设与某个虚变形模式相关的、单位雅可比矩阵下的无量纲内能密度由二次函数 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ 给出。该模式对无量纲内部虚功的单元贡献是积分\n$$\nI = \\int_{-1}^{1} u(\\xi)\\, d\\xi.\n$$\n使用在 $[-1,1]$ 上的双点高斯-勒让德求积法则，其节点为 $\\xi = \\pm 1/\\sqrt{3}$，权重为 $w = 1$，通过求积法计算 $I$。然后，通过直接根据黎曼积分的定义计算积分的解析值来验证求积的精确性。将 $I$ 的值报告为一个纯数（无量纲）。由于结果是精确的，因此无需四舍五入。",
            "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n第1步：提取给定条件。\n- 背景是一维固体力学，具体是双节点等参有限元法（FEM）杆单元。\n- 父坐标为 $\\xi \\in [-1,1]$。\n- 单位雅可比矩阵下的内能密度函数为 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$。\n- 单元对内部虚功贡献的积分为 $I = \\int_{-1}^{1} u(\\xi)\\, d\\xi$。\n- 数值积分方法是双点高斯-勒让德求积法。\n- 求积节点为 $\\xi = \\pm \\frac{1}{\\sqrt{3}}$。\n- 求积权重为 $w = 1$。\n- 任务是使用此求积法则计算 $I$，并通过计算解析积分来验证结果。\n\n第2步：使用提取的给定条件进行验证。\n该问题在科学上是合理的。它描述了计算力学中的一个标准、基本的过程：使用高斯求积法对单元父域上的积分进行数值计算。被积函数 $u(\\xi)$ 是一个良态多项式。所有参数，包括积分限、函数定义、求积节点和权重，都已提供，并且它们与双点高斯-勒让德法则的标准公式一致。该问题是适定的、客观的，并且不含任何科学或逻辑上的缺陷。这个问题是在指定领域内数值分析原理的直接应用，因此是有效的。\n\n第3步：结论与行动。\n问题有效。将提供解答。\n\n该问题要求计算函数 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ 的积分 $I = \\int_{-1}^{1} u(\\xi)\\, d\\xi$。必须使用两种方法进行评估以作比较：双点高斯-勒让德求积法和直接解析积分。\n\n首先，我们应用双点高斯-勒让德求积法则。在区间 $[-1,1]$ 上，该求积的一般形式为：\n$$\n\\int_{-1}^{1} f(\\xi)\\, d\\xi \\approx \\sum_{i=1}^{n} w_i f(\\xi_i)\n$$\n对于双点法则（$n=2$），节点为 $\\xi_1 = -\\frac{1}{\\sqrt{3}}$ 和 $\\xi_2 = \\frac{1}{\\sqrt{3}}$，相应的权重为 $w_1 = 1$ 和 $w_2 = 1$。被积函数为 $f(\\xi) = u(\\xi) = 3\\xi^{2} + 2\\xi + 1$。\n\n我们在每个求积节点上计算函数 $u(\\xi)$ 的值：\n在 $\\xi_1 = -\\frac{1}{\\sqrt{3}}$ 处：\n$$\nu\\left(-\\frac{1}{\\sqrt{3}}\\right) = 3\\left(-\\frac{1}{\\sqrt{3}}\\right)^{2} + 2\\left(-\\frac{1}{\\sqrt{3}}\\right) + 1 = 3\\left(\\frac{1}{3}\\right) - \\frac{2}{\\sqrt{3}} + 1 = 1 - \\frac{2}{\\sqrt{3}} + 1 = 2 - \\frac{2}{\\sqrt{3}}\n$$\n在 $\\xi_2 = \\frac{1}{\\sqrt{3}}$ 处：\n$$\nu\\left(\\frac{1}{\\sqrt{3}}\\right) = 3\\left(\\frac{1}{\\sqrt{3}}\\right)^{2} + 2\\left(\\frac{1}{\\sqrt{3}}\\right) + 1 = 3\\left(\\frac{1}{3}\\right) + \\frac{2}{\\sqrt{3}} + 1 = 1 + \\frac{2}{\\sqrt{3}} + 1 = 2 + \\frac{2}{\\sqrt{3}}\n$$\n现在，我们计算积分的近似值，记为 $I_{GQ}$：\n$$\nI_{GQ} = w_1 u(\\xi_1) + w_2 u(\\xi_2) = (1) \\left(2 - \\frac{2}{\\sqrt{3}}\\right) + (1) \\left(2 + \\frac{2}{\\sqrt{3}}\\right)\n$$\n$$\nI_{GQ} = 2 - \\frac{2}{\\sqrt{3}} + 2 + \\frac{2}{\\sqrt{3}} = 4\n$$\n使用双点高斯求积法得到的积分值为 $4$。\n\n接下来，我们通过使用微积分基本定理，解析地计算积分的精确值来进行验证。\n$$\nI = \\int_{-1}^{1} (3\\xi^{2} + 2\\xi + 1)\\, d\\xi\n$$\n被积函数的反导数是：\n$$\n\\int (3\\xi^{2} + 2\\xi + 1)\\, d\\xi = 3\\frac{\\xi^{3}}{3} + 2\\frac{\\xi^{2}}{2} + \\xi + C = \\xi^{3} + \\xi^{2} + \\xi + C\n$$\n计算在 $\\xi = -1$ 和 $\\xi = 1$ 之间的定积分：\n$$\nI = \\left[ \\xi^{3} + \\xi^{2} + \\xi \\right]_{-1}^{1} = \\left( (1)^{3} + (1)^{2} + (1) \\right) - \\left( ((-1)^{3} + (-1)^{2} + (-1) \\right)\n$$\n$$\nI = (1 + 1 + 1) - (-1 + 1 - 1) = (3) - (-1) = 3 + 1 = 4\n$$\n积分的精确解析值为 $4$。\n\n双点高斯求积的结果 $I_{GQ} = 4$ 与精确解析结果 $I = 4$ 相匹配。这是预料之中的。一个具有 $n$ 个点的高斯-勒让德求积法则能精确地对最高 $2n-1$ 次的多项式进行积分。在本问题中，$n=2$，因此该法则对于任何最高次数为 $2(2)-1 = 3$ 的多项式都必须是精确的。被积函数 $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ 是一个2次多项式。由于 $2 \\le 3$，求积法得出了精确结果。验证证实了这一理论原理。因此，所求 $I$ 的值为 $4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "高斯求积令人印象深刻的“指数级”收敛速度仅对光滑、表现良好的函数有保证。但是，当被积函数存在“尖点”或其他非光滑特征时（这在物理和工程模型中很常见），它的表现如何呢？这个计算练习要求你研究高斯求积在一个导数不连续的函数上的性能。通过编写代码来测量收敛速度，你将获得关于该方法局限性的实践洞察，并了解其效率如何受到被积函数光滑性的影响。",
            "id": "2397754",
            "problem": "考虑函数 $f(x)=\\lvert x-c\\rvert$ 在区间 $[-1,1]$ 上的积分，其中 $c\\in(-1,1)$ 为一个固定参数。令 $I(c)$ 表示该积分的精确值，令 $Q_n(c)$ 表示在 $[-1,1]$ 上使用勒让德权重（Legendre weight）的 $n$ 点高斯求积（Gaussian quadrature）近似值。定义绝对误差 $E_n(c)=\\lvert Q_n(c)-I(c)\\rvert$。研究 $E_n(c)$ 相对于 $n$ 的经验代数收敛速率（empirical algebraic convergence rate）如何依赖于 $c$ 相对于求积节点的位置。\n\n您的程序必须：\n- 从第一性原理出发，计算积分的精确值 $I(c)$。\n- 对于整数集合 $\\{2,3,4,\\dots,80\\}$ 中的每个 $n$，计算 $Q_n(c)$ 和绝对误差 $E_n(c)$。\n- 对于每个固定的 $c$，通过对 $(\\log n,\\log E_n(c))$ 分别在偶数子序列 $\\{n\\in\\mathbb{N}: n\\in\\{2,4,6,\\dots,80\\}\\}$ 和奇数子序列 $\\{n\\in\\mathbb{N}: n\\in\\{3,5,7,\\dots,79\\}\\}$ 上拟合直线，来估计两个经验代数收敛速率 $p_{\\mathrm{even}}(c)$ 和 $p_{\\mathrm{odd}}(c)$。\n- 使用 $\\log E_n(c)$ 对 $\\log n$ 的最小二乘斜率 $\\hat{s}$，并将经验速率定义为 $p=-\\hat{s}$。\n- 为避免浮点饱和（floating-point saturation），从拟合中排除任何满足 $E_n(c)\\le 10^{-14}$ 的点对 $(n,E_n(c))$；如果剩余的点少于 3 个，则使用所有可用点而不进行排除。\n- 在速率估计中，所有对数均使用自然对数。\n\n使用以下参数值测试集：\n- $c_1=0$，\n- $c_2=0.1$，\n- $c_3=0.5773502691896257$。\n\n对于测试集中的每个 $c_j$，计算并报告点对 $\\big(p_{\\mathrm{even}}(c_j),\\,p_{\\mathrm{odd}}(c_j)\\big)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式和顺序如下：\n$[p_{\\mathrm{even}}(c_1),p_{\\mathrm{odd}}(c_1),p_{\\mathrm{even}}(c_2),p_{\\mathrm{odd}}(c_2),p_{\\mathrm{even}}(c_3),p_{\\mathrm{odd}}(c_3)]$。\n所有报告的值都必须是实数值（无单位），此任务中不涉及角度。最终输出必须是单行，且不得包含任何附加文本。",
            "solution": "问题陈述已经过验证，被认定为有效。它在数值分析领域具有科学依据，特别涉及高斯求积（Gaussian quadrature）的收敛性质。该问题是适定的（well-posed）、客观的，并包含计算唯一解所需的所有必要信息。\n\n任务是研究 n 点高斯-勒让德求积（Gauss-Legendre quadrature）对函数 $f(x) = \\lvert x-c \\rvert$ 在区间 $[-1, 1]$ 上的积分的经验代数收敛速率。函数 $f(x)$ 是连续的，但其一阶导数 $f'(x) = \\text{sgn}(x-c)$ 在 $x=c$ 处存在跳跃间断点。众所周知，这种不光滑性会将高阶求积法则的收敛速率从指数级（对于解析函数）降低到代数级。我们假设误差缩放遵循 $E_n(c) \\propto n^{-p}$ 的形式，其中 $E_n(c)$ 是 $n$ 点法则的绝对误差，$p$ 是代数收敛速率。\n\n首先，我们确定积分的精确值，记为 $I(c)$。对于 $c \\in (-1, 1)$，我们在不可微点 $x=c$ 处拆分积分：\n$$\nI(c) = \\int_{-1}^{1} \\lvert x-c \\rvert \\, dx = \\int_{-1}^{c} -(x-c) \\, dx + \\int_{c}^{1} (x-c) \\, dx\n$$\n计算该初等积分可得：\n$$\nI(c) = \\left[ cx - \\frac{x^2}{2} \\right]_{-1}^{c} + \\left[ \\frac{x^2}{2} - cx \\right]_{c}^{1}\n$$\n$$\nI(c) = \\left( (c^2 - \\frac{c^2}{2}) - (-c - \\frac{1}{2}) \\right) + \\left( (\\frac{1}{2} - c) - (\\frac{c^2}{2} - c^2) \\right)\n$$\n$$\nI(c) = \\left( \\frac{c^2}{2} + c + \\frac{1}{2} \\right) + \\left( \\frac{1}{2} - c + \\frac{c^2}{2} \\right) = c^2 + 1\n$$\n这个解析结果 $I(c) = c^2+1$ 是数值近似所要比较的基准。\n\n$n$ 点高斯-勒让德求积近似值 $Q_n(c)$ 由以下求和公式给出：\n$$\nQ_n(c) = \\sum_{i=1}^{n} w_i f(x_i) = \\sum_{i=1}^{n} w_i \\lvert x_i - c \\rvert\n$$\n其中 $\\{x_i\\}_{i=1}^n$ 是 $n$ 次勒让德多项式 $P_n(x)$ 的根，$\\{w_i\\}_{i=1}^n$ 是相应的求积权重。于是，绝对误差为 $E_n(c) = \\lvert Q_n(c) - I(c) \\rvert$。\n\n对于具有此类奇点（一阶导数有跳跃）的函数，理论上的渐近收敛速率为 $E_n(c) = O(n^{-2})$，因此我们预期会发现 $p \\approx 2$。然而，问题要求的是经验速率，我们必须根据数值数据进行计算。分析需要对偶数和奇数的 $n$ 值分别进行。这种区分很重要，因为对于偶数和奇数 $n$，高斯-勒让德求积的节点分布具有不同的对称性。具体来说，对于奇数 $n$，$x=0$ 始终是一个节点，这与 $c=0$ 的情况高度相关。\n\n为了估计收敛速率 $p$，我们假设模型为 $E_n(c) = A n^{-p}$，其中 $A$ 为某个常数。对该关系式两边取自然对数，得到一个线性方程：\n$$\n\\ln(E_n(c)) = \\ln(A) - p \\ln(n)\n$$\n该方程形如 $y = b + sx$，其中 $y = \\ln(E_n(c))$，$x = \\ln(n)$，截距为 $b = \\ln(A)$，斜率为 $s = -p$。问题要求我们使用最小二乘法，为数据点 $(\\ln(n), \\ln(E_n(c)))$ 找到最佳拟合线的斜率 $s$。然后，经验速率由 $p = -s$ 给出。\n\n计算流程如下：\n1. 对于测试集 $\\{0, 0.1, 0.5773502691896257\\}$ 中的每个 $c$ 值，我们计算精确积分 $I(c) = c^2+1$。\n2. 我们遍历 $n \\in \\{2, 3, \\ldots, 80\\}$。在每次迭代中，我们计算 $n$ 个高斯-勒让德节点和权重，计算求积近似值 $Q_n(c)$，并求出误差 $E_n(c)$。\n3. 收集点对 $(n, E_n(c))$，并根据 $n$ 的奇偶性将其分为两个子序列。\n4. 对每个子序列（偶数和奇数），我们对经过对数变换的数据 $(\\ln(n), \\ln(E_n(c)))$ 进行线性回归。应用特定的数据筛选规则：任何满足 $E_n(c) \\le 10^{-14}$ 的点都将从拟合中排除，除非这将导致剩余的点少于 3 个，在这种情况下将使用所有点。\n5. 获得线性拟合的斜率 $s$。然后收敛速率为 $p_{\\mathrm{even}}(c) = -s_{\\mathrm{even}}$ 和 $p_{\\mathrm{odd}}(c) = -s_{\\mathrm{odd}}$。\n6. 按指定格式报告所得的六个值，$(p_{\\mathrm{even}}(c_1), p_{\\mathrm{odd}}(c_1), \\ldots)$。\n\n以下程序实现了这整个流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_rate(n_values, E_values, min_points=3, threshold=1e-14):\n    \"\"\"\n    Estimates the algebraic convergence rate p from E ~ n^(-p).\n\n    This is done by a linear least-squares fit on log-log data.\n    The rate p is the negative of the slope of log(E) vs log(n).\n    \n    Args:\n        n_values (np.ndarray): Array of integer orders n.\n        E_values (np.ndarray): Array of corresponding errors E_n.\n        min_points (int): The minimum number of points required for a filtered fit.\n        threshold (float): The error threshold for filtering.\n    \n    Returns:\n        float: The estimated convergence rate p.\n    \"\"\"\n    # Ensure there are enough points to attempt a fit\n    if len(n_values)  2:\n        return np.nan\n\n    # Filter out points where the error is at or below the floating-point precision limit.\n    # This prevents these points from corrupting the log-log fit.\n    mask = E_values > threshold\n    \n    if np.sum(mask)  min_points:\n        # If filtering leaves too few points, use all available points as per the rule.\n        x_fit = np.log(n_values)\n        y_fit = np.log(E_values)\n    else:\n        # Use the filtered data for the fit.\n        x_fit = np.log(n_values[mask])\n        y_fit = np.log(E_values[mask])\n\n    # Check again if there are enough points for polyfit after filtering.\n    if len(x_fit)  2:\n        return np.nan\n\n    # Perform a linear fit (degree 1 polynomial) to the log-log data.\n    # The slope is the first element of the returned coefficients.\n    slope = np.polyfit(x_fit, y_fit, 1)[0]\n    \n    # The convergence rate p is the negative of the slope.\n    return -slope\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as stated.\n    - Computes exact and approximate integrals.\n    - Calculates errors for n-point Gaussian quadrature.\n    - Estimates convergence rates for even and odd n subsequences.\n    \"\"\"\n    # Test suite of parameter values for c.\n    test_cases = [\n        0.0,\n        0.1,\n        0.5773502691896257,  # This is 1/sqrt(3)\n    ]\n\n    # The range of n for the quadrature rule.\n    n_range = np.arange(2, 81)\n    \n    all_results = []\n    \n    for c in test_cases:\n        # Compute the exact integral I(c) = c^2 + 1.\n        I_c = c**2 + 1.0\n        \n        # Lists to store n and the corresponding errors for even and odd subsequences.\n        n_even, E_even = [], []\n        n_odd, E_odd = [], []\n        \n        # Compute errors for each n in the specified range.\n        for n in n_range:\n            # Get the n-point Gauss-Legendre quadrature nodes and weights.\n            nodes, weights = np.polynomial.legendre.leggauss(n)\n            \n            # Compute the quadrature approximation Q_n(c) for f(x) = |x-c|.\n            Q_n = np.sum(weights * np.abs(nodes - c))\n            \n            # Compute the absolute error.\n            E_n = np.abs(Q_n - I_c)\n            \n            # Separate the results into even and odd subsequences.\n            if n % 2 == 0:\n                n_even.append(n)\n                E_even.append(E_n)\n            else:\n                n_odd.append(n)\n                E_odd.append(E_n)\n        \n        # Estimate the convergence rates for both subsequences.\n        p_even = estimate_rate(np.array(n_even), np.array(E_even))\n        p_odd = estimate_rate(np.array(n_odd), np.array(E_odd))\n        \n        all_results.extend([p_even, p_odd])\n\n    # Print the final results in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}