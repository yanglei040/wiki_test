{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering the IEEE 754 standard is to learn how to interpret its binary representation. This practice provides a direct, hands-on exercise in translating a 32-bit hexadecimal pattern, a common sight in debugging and low-level programming, into its corresponding decimal value. By manually dissecting the number into its sign, exponent, and fraction components, you will solidify your understanding of the fundamental structure of single-precision floating-point numbers .",
            "id": "1948832",
            "problem": "In a 32-bit microprocessor architecture, a floating-point unit register contains the hexadecimal value $0xC1E80000$. This value is to be interpreted according to the Institute of Electrical and Electronics Engineers (IEEE) 754 standard for single-precision floating-point numbers.\n\nThe 32-bit single-precision format is structured as follows:\n- A 1-bit sign field (S), located at bit 31 (the most significant bit).\n- An 8-bit biased exponent field (E), located at bits 30 through 23.\n- A 23-bit fraction field (F), located at bits 22 through 0.\n\nFor a normalized number (where the exponent field is not all zeros or all ones), the decimal value is given by the formula $N = (-1)^S \\times (1.F)_2 \\times 2^{(E - \\text{bias})}$, where $(1.F)_2$ represents the implicit leading bit followed by the fraction bits, interpreted as a binary number. The exponent bias for single-precision is 127.\n\nDetermine the decimal value of the number represented by the bit pattern $0xC1E80000$.",
            "solution": "According to IEEE 754 single-precision, the fields are: sign bit $S$ (bit $31$), exponent field $E$ (bits $30$ through $23$), and fraction field $F$ (bits $22$ through $0$). The value is $N = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E - 127)}$ for a normalized number.\n\nThe hexadecimal value $0x\\text{C1E80000}$ in binary is $1100000111101000...$. The sign bit is $S = 1$ (negative). The exponent bits (bits $30$ through $23$) are $(10000011)_{2}$, so\n$$\nE = 1 \\cdot 2^{7} + 0 \\cdot 2^{6} + \\cdots + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 128 + 2 + 1 = 131.\n$$\nSince $E \\neq 0$ and $E \\neq 255$, the number is normalized, and the unbiased exponent is\n$$\ne = E - 127 = 131 - 127 = 4.\n$$\nThe fraction field $F$ begins with the bits from the hexadecimal digit `E`, which is `1110`. The rest of the fraction is zero. This means the nonzero bits are at positions $22$, $21$, and $20$ (counting from bit 22). The significand is\n$$\n(1.F)_{2} = 1 + 2^{-1} + 2^{-2} + 2^{-3} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} = \\frac{15}{8}.\n$$\nTherefore, the represented value is\n$$\nN = (-1)^{1} \\times \\frac{15}{8} \\times 2^{4} = - \\frac{15}{8} \\times 16 = -30.\n$$",
            "answer": "$$\\boxed{-30}$$"
        },
        {
            "introduction": "Now that we understand how individual numbers are represented, we can explore the broader consequences of this finite-precision format. A crucial implication is that not all integers can be represented exactly, a fact that has significant consequences in software development, particularly in simulations and financial applications. This exercise challenges you to determine the precise point at which single-precision floating-point numbers can no longer represent every consecutive integer, revealing the relationship between a number's magnitude and the precision available to represent it .",
            "id": "2215579",
            "problem": "A software engineer is developing a physics simulation for a new 3D video game. For performance reasons, all positional coordinates are stored using a standard 32-bit single-precision floating-point format. This format is defined as follows:\n- 1 bit for the sign ($S$).\n- 8 bits for the biased exponent ($E$).\n- 23 bits for the fractional part of the significand ($M$), also known as the mantissa.\n\nThe value of a normalized positive number is given by the formula $V = (1.M)_2 \\times 2^{E - \\text{bias}}$, where $(1.M)_2$ is the significand interpreted as a binary number (with an implicit leading 1), and the exponent bias is 127. The range of the biased exponent $E$ for normalized numbers is $1 \\le E \\le 254$.\n\nThe engineer needs to ensure that all integer-valued coordinates can be represented perfectly without any loss of precision up to a certain maximum distance from the origin. If an integer coordinate cannot be represented exactly, the object's position may be corrupted by rounding errors, leading to simulation glitches.\n\nDetermine the largest positive integer $N$ such that every integer $k$ in the range $1 \\le k \\le N$ can be represented exactly in this floating-point format. Note that the integer 0 is always exactly representable.",
            "solution": "We are using the standard binary32 (single-precision) floating-point format with 23 fraction bits and an implicit leading 1, so the total precision in the significand is $p=23+1=24$ bits. A normalized value has the form $V=(1.M)_{2}\\times 2^{e}$, where $e=E-\\text{bias}$ and $(1.M)_{2}$ changes in steps of $2^{-23}$ at fixed $e$.\n\nAt a fixed unbiased exponent $e$, increasing the least significant bit of $M$ by one changes the value by\n$$\n\\Delta V=2^{e}\\cdot 2^{-23}=2^{e-23}.\n$$\nThus the spacing (unit in the last place) among representable numbers in the interval $[2^{e},2^{e+1})$ is $2^{e-23}$.\n\nConsider integers $n$ in $[2^{e},2^{e+1})$. Since $2^{e}$ itself is exactly representable, the representable values in this bin are\n$$\n2^{e}+j\\cdot 2^{e-23}, \\quad j\\in\\mathbb{Z}_{\\ge 0}.\n$$\nAn integer $n$ in this interval is representable if and only if there exists an integer $j$ such that\n$$\nn=2^{e}+j\\cdot 2^{e-23}\\quad\\Longleftrightarrow\\quad j=(n-2^{e})\\cdot 2^{23-e}.\n$$\nFor all integers $n$ in this interval, $j$ is an integer precisely when $2^{23-e}$ is an integer, i.e., when $e\\le 23$. Therefore, for all bins with $e\\le 23$, every integer in $[2^{e},2^{e+1})$ is exactly representable. In particular, for $e=23$, the spacing is $2^{23-23}=1$, so every integer from $2^{23}$ up to $2^{24}-1$ is exactly representable.\n\nNow consider $2^{24}$. It is exactly representable as $(1.0)_{2}\\times 2^{24}$. However, the next integer $2^{24}+1$ lies in the bin with $e=24$, where the spacing is $2^{24-23}=2$, so only even integers are representable there; hence $2^{24}+1$ is not exactly representable.\n\nTherefore, every integer $k$ with $1\\le k\\le 2^{24}$ is exactly representable, but $2^{24}+1$ is not. The largest such $N$ is $2^{24}$.",
            "answer": "$$\\boxed{2^{24}}$$"
        },
        {
            "introduction": "The IEEE 754 standard includes several subtle features designed to make numerical computations more robust. One of the most important is the concept of signed zero ($-0$), which preserves information about operations that underflow to zero from the negative side. This practice moves beyond basic representation to explore how this nuance behaves in standard mathematical functions, demonstrating why the distinction between $+0$ and $-0$ is not merely academic but essential for writing correct and reliable numerical code .",
            "id": "2215621",
            "problem": "In numerical computing, the Institute of Electrical and Electronics Engineers (IEEE) 754 standard for floating-point arithmetic defines two representations for zero: positive zero ($+0$) and negative zero ($-0$). While they compare as equal (i.e., the expression `+0 == -0` evaluates to true), they can produce different results in certain calculations. This distinction is crucial for preserving sign information in operations that might underflow to zero.\n\nConsider the following mathematical expressions, which are evaluated using a computational environment that strictly conforms to the IEEE 754 standard for floating-point arithmetic (such as a standard C library's `math.h`). All floating-point literals (e.g., `2.0`, `-1.0`, `0.0`, `-0.0`) are to be interpreted as floating-point numbers.\n\nWhich of the following expressions is guaranteed to evaluate to a negative zero ($-0$)?\n\nA. `pow(-0.0, 2.0)`\n\nB. `pow(-0.0, 3.0)`\n\nC. `atan2(-0.0, -1.0)`\n\nD. `1.0 / (1.0 / 0.0)`\n\nE. `(-1.0) * 0.0`\n\nF. `sin(-0.0)`",
            "solution": "We analyze each option using IEEE 754 rules for signed zeros and the specified math library behaviors.\n\nA. For the power function, IEEE 754 and C Annex F specify that for $y$ a finite integer, $\\operatorname{pow}(\\pm 0,y)$ returns a signed zero whose sign depends on the parity of $y$: if $y$ is an even integer, the result is $+0$, and if $y$ is an odd integer, the result has the sign of the base. Since $2.0$ is an even integer,\n$$\\operatorname{pow}(-0.0,2.0)=+0.0,$$\nso not a negative zero.\n\nB. By the same rule, with $3.0$ an odd integer,\n$$\\operatorname{pow}(-0.0,3.0)=-0.0,$$\nso this is a negative zero.\n\nC. The two-argument arctangent returns an angle in $(-\\pi,\\pi]$ with quadrant determined by $(y,x)$. For $x<0$ and $y=\\pm 0$, IEEE 754–conforming libraries distinguish the sign of zero: $\\operatorname{atan2}(+0,-1) = \\pi$ and $\\operatorname{atan2}(-0,-1) = -\\pi$. Thus\n$$\\operatorname{atan2}(-0.0,-1.0)=-\\pi,$$\nwhich is not zero, so not a negative zero.\n\nD. Division by zero with positive numerator yields positive infinity:\n$$\\frac{1.0}{0.0}=+\\infty.$$\nThen\n$$\\frac{1.0}{+\\infty}=+0.0,$$\nso the overall result is $+0.0$, not a negative zero.\n\nE. Multiplication in IEEE 754 assigns the sign of the result by the exclusive-or of operand signs, and zero results retain sign. Thus\n$$(-1.0)\\times 0.0 = -0.0,$$\nso this is a negative zero.\n\nF. The sine function is odd and IEEE 754–conforming math libraries preserve the sign of zero for odd functions at exact zeros. Hence\n$$\\sin(-0.0)=-\\sin(0.0)=-0.0,$$\nso this is a negative zero.\n\nTherefore, the expressions that are guaranteed to evaluate to a negative zero are B, E, and F.",
            "answer": "$$\\boxed{BEF}$$"
        }
    ]
}