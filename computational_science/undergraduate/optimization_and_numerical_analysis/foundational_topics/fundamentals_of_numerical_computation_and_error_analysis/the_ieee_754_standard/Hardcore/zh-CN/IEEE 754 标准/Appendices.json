{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握 IEEE 754 标准，我们必须能够在其二进制表示和它所代表的十进制数值之间进行转换。这个练习提供了一个具体的十六进制值，并要求您逐步解码它。通过这个实践，您将巩固对符号、指数和尾数在构建浮点数中所扮演角色的理解。",
            "id": "1948832",
            "problem": "在一个32位微处理器架构中，一个浮点单元寄存器包含十六进制值 $0xC1E80000$。该值需要根据电气和电子工程师协会 (IEEE) 754 单精度浮点数标准进行解释。\n\n32位单精度格式的结构如下：\n- 一个1位的符号字段 (S)，位于第31位（最高有效位）。\n- 一个8位的偏置指数字段 (E)，位于第30位到第23位。\n- 一个23位的小数字段 (F)，位于第22位到第0位。\n\n对于规格化数（指数字段不全为0或全为1），其十进制值由公式 $N = (-1)^S \\times (1.F)_2 \\times 2^{(E - \\text{bias})}$ 给出，其中 $(1.F)_2$ 表示隐含的前导1，后跟小数字段的各位，并被解释为一个二进制数。单精度的指数偏置值为127。\n\n确定由位模式 $0xC1E80000$ 表示的数的十进制值。",
            "solution": "根据 IEEE 754 单精度标准，字段为：符号位 $S$（第31位）、指数字段 $E$（第30到23位）以及小数字段 $F$（第22到0位）。对于规格化数，其值为 $N = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E - 127)}$。\n\n十六进制值 $0x\\text{C1E80000}$ 的二进制表示分组为 $1100\\,0001\\,1110\\,1000\\,0000\\,0000\\,0000\\,0000$。符号位为 $S = 1$（负数）。指数字段（第30到23位）是 $(10000011)_{2}$，所以\n$$\nE = 1 \\cdot 2^{7} + 0 \\cdot 2^{6} + \\cdots + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 128 + 2 + 1 = 131.\n$$\n由于 $E \\neq 0$ 且 $E \\neq 255$，该数为规格化数，无偏指数为\n$$\ne = E - 127 = 131 - 127 = 4.\n$$\n小数字段 $F$ 在第22、21和19位（从第22位开始向下计数）为非零位，所以尾数为\n$$\n(1.F)_{2} = 1 + 2^{-1} + 2^{-2} + 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{16} = \\frac{29}{16}.\n$$\n因此，所表示的值为\n$$\nN = (-1)^{1} \\times \\frac{29}{16} \\times 2^{4} = - \\frac{29}{16} \\times 16 = -29.\n$$",
            "answer": "$$\\boxed{-29}$$"
        },
        {
            "introduction": "理解了浮点数的内部结构后，我们来探讨它的局限性。与数学上的实数不同，计算机中的浮点数不是连续的，它们之间存在间隙。这个问题要求您找出在单精度格式下，能够被精确表示的连续整数区间的上限 $N$。 解决这个问题将使您对浮点数的精度有一个切实的感受，并帮助您理解为什么在处理大整数时，数值计算或物理模拟可能会遇到意想不到的“跳跃”或精度损失。",
            "id": "2215579",
            "problem": "一位软件工程师正在为一款新的3D视频游戏开发物理模拟。出于性能考虑，所有位置坐标都使用标准的32位单精度浮点格式存储。该格式定义如下：\n- 1位用于符号（$S$）。\n- 8位用于偏置指数（$E$）。\n- 23位用于有效数（significand）的小数部分（$M$），也称为尾数（mantissa）。\n\n一个规格化的正数的值由公式 $V = (1.M)_2 \\times 2^{E - \\text{bias}}$ 给出，其中 $(1.M)_2$ 是解释为二进制数的有效数（含一个隐含的前导1），指数偏置值为127。对于规格化数，偏置指数 $E$ 的范围是 $1 \\le E \\le 254$。\n\n该工程师需要确保在离原点一定最大距离内的所有整数值坐标都能被精确表示，没有任何精度损失。如果一个整数坐标不能被精确表示，物体的位置可能会因舍入误差而损坏，导致模拟出现故障。\n\n确定最大的正整数 $N$，使得在范围 $1 \\le k \\le N$ 内的每一个整数 $k$ 都能在这种浮点格式中被精确表示。注意，整数0总是可以被精确表示的。",
            "solution": "我们使用的是标准的binary32（单精度）浮点格式，它有23个小数位和一个隐含的前导1，因此有效数的总精度为 $p=23+1=24$ 位。一个规格化的值形式为 $V=(1.M)_{2}\\times 2^{e}$，其中 $e=E-\\text{bias}$，在固定的 $e$ 值下，$(1.M)_{2}$ 以 $2^{-23}$ 为步长变化。\n\n在一个固定的无偏指数 $e$ 下，将 $M$ 的最低有效位增加1，会使数值改变：\n$$\n\\Delta V=2^{e}\\cdot 2^{-23}=2^{e-23}.\n$$\n因此，在区间 $[2^{e},2^{e+1})$ 内，可表示数之间的间距（末位单位）是 $2^{e-23}$。\n\n考虑在 $[2^{e},2^{e+1})$ 区间内的整数 $n$。由于 $2^{e}$ 本身可以精确表示，这个区间内的可表示值为：\n$$\n2^{e}+j\\cdot 2^{e-23}, \\quad j\\in\\mathbb{Z}_{\\ge 0}.\n$$\n在此区间内的一个整数 $n$ 是可表示的，当且仅当存在一个整数 $j$ 使得：\n$$\nn=2^{e}+j\\cdot 2^{e-23}\\quad\\Longleftrightarrow\\quad j=(n-2^{e})\\cdot 2^{23-e}.\n$$\n对于此区间内的所有整数 $n$，$j$ 是一个整数当且仅当 $2^{23-e}$ 是一个整数，即当 $e\\le 23$ 时。因此，对于所有 $e\\le 23$ 的区间，$[2^{e},2^{e+1})$ 中的每一个整数都可以被精确表示。特别地，当 $e=23$ 时，间距是 $2^{23-23}=1$，所以从 $2^{23}$ 到 $2^{24}-1$ 的每一个整数都可以被精确表示。\n\n现在考虑 $2^{24}$。它可以被精确表示为 $(1.0)_{2}\\times 2^{24}$。然而，下一个整数 $2^{24}+1$ 位于 $e=24$ 的区间，其间距为 $2^{24-23}=2$，因此在该区间只有偶数是可表示的；所以 $2^{24}+1$ 不能被精确表示。\n\n因此，所有满足 $1\\le k\\le 2^{24}$ 的整数 $k$ 都可以被精确表示，但 $2^{24}+1$ 不能。最大的这样的 $N$ 是 $2^{24}$。",
            "answer": "$$\\boxed{2^{24}}$$"
        },
        {
            "introduction": "我们已经了解了浮点数的表示结构和精度限制，现在让我们观察这些限制如何在一个简单的计算中导致误差累积。这个练习涉及一个看似微不足道的任务：将数字 $1/n$ 相加 $n$ 次。直觉上，结果应该是 $1$，但由于表示误差和每一步的舍入误差，情况往往并非如此。 通过找出导致总和不等于 $1$ 的最小整数 $n$，您将直接见证舍入误差累积的影响，这是数值计算中的一个基本挑战。",
            "id": "2447439",
            "problem": "您将处理一个源于有限精度算术和误差分析的任务。设 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 表示根据美国电气和电子工程师协会（IEEE）754标准，使用基数 $2$ 和“四舍五入到最近，偶数优先”（rounding to nearest, ties to even）规则，舍入到指定的二进制浮点格式 $\\mathcal{F}$。对于任意正整数 $n$，定义机器数\n$$\nx_n = \\mathrm{fl}_{\\mathcal{F}}\\!\\left(\\frac{1}{n}\\right),\n$$\n以及 $x_n$ 重复 $n$ 次的左结合求和，\n$$\nS_n = \\underbrace{\\mathrm{fl}_{\\mathcal{F}}\\big(\\mathrm{fl}_{\\mathcal{F}}(\\cdots \\mathrm{fl}_{\\mathcal{F}}(\\mathrm{fl}_{\\mathcal{F}}(0 + x_n) + x_n) + \\cdots ) + x_n\\big)}_{\\text{$n$ 次加法}}.\n$$\n您的任务是，对于所提供测试套件中的每一种格式 $\\mathcal{F}$，确定使得 $S_n \\neq 1.0$ 在该格式下成立的最小正整数 $n$。\n\n测试套件包含以下格式 $\\mathcal{F}$：\n- IEEE 754 binary16（半精度）：$1$ 个符号位，$5$ 个指数位，$10$ 个小数位。\n- IEEE 754 binary32（单精度）：$1$ 个符号位，$8$ 个指数位，$23$ 个小数位。\n- IEEE 754 binary64（双精度）：$1$ 个符号位，$11$ 个指数位，$52$ 个小数位。\n\n假设：\n- 在所有 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 运算中，使用符合 IEEE 754 标准的基数-2 算术，并采用“四舍五入到最近，偶数优先”模式。\n- 求和顺序严格按照 $S_n$ 中所写的从左到右进行。\n- 不涉及物理单位。\n- 不出现角度。\n- 所有比较都是在指定格式下的精确比较，即 $S_n$ 与在 $\\mathcal{F}$ 中精确表示的 $1.0$ 进行比较。\n\n程序行为要求：\n- 对于测试套件中的每一种格式，计算使得该格式下 $S_n \\neq 1.0$ 的最小正整数 $n$。\n- 将得到的三个整数按 [binary16, binary32, binary64] 的顺序汇总到一个列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 分别是对应于 binary16、binary32 和 binary64 的最小 $n$ 值的整数。\n\n此问题需要根据有限精度算术和误差传播的基本原理来解决；不需要外部输入，也不允许用户交互。输出必须由程序根据上述定义和给定的测试套件计算得出。",
            "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 设 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 是根据 IEEE 754 标准，基数为 $2$，采用“四舍五入到最近，偶数优先”模式，向二进制浮点格式 $\\mathcal{F}$ 的舍入操作。\n- 对于正整数 $n$，定义机器数 $x_n = \\mathrm{fl}_{\\mathcal{F}}\\!\\left(\\frac{1}{n}\\right)$。\n- 定义和 $S_n$ 为 $x_n$ 重复 $n$ 次的左结合求和：$S_n = \\underbrace{\\mathrm{fl}_{\\mathcal{F}}\\big(\\cdots \\mathrm{fl}_{\\mathcal{F}}(0 + x_n) + \\cdots + x_n\\big)}_{\\text{$n$ 次加法}}$。\n- 任务是找到在格式 $\\mathcal{F}$ 中使得 $S_n \\neq 1.0$ 成立的最小正整数 $n$。\n- 格式 $\\mathcal{F}$ 的测试套件包括：\n    - `binary16`（半精度）：$1$ 个符号位，$5$ 个指数位，$10$ 个小数位（$p=10$）。\n    - `binary32`（单精度）：$1$ 个符号位，$8$ 个指数位，$23$ 个小数位（$p=23$）。\n    - `binary64`（双精度）：$1$ 个符号位，$11$ 个指数位，$52$ 个小数位（$p=52$）。\n- 所有比较都是浮点表示的精确按位比较。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，植根于数值分析和计算机算术的基本原理。它是一个适定问题（well-posed），具有明确定义的目标和所有必需的参数（浮点格式、舍入模式、求和顺序）。语言客观且无歧义。该问题是自包含的、可形式化的，并与截断误差和舍入误差的主题直接相关。不存在矛盾、不可行的条件或违反科学原理的情况。\n\n步骤3：结论与行动\n问题被判定为**有效**。将提供一个解决方案。\n\n该问题要求分析有限精度算术中的误差传播。计算所得的和 $S_n$ 与数学上精确值 $1$ 的偏差源于两种舍入误差：\n1.  **表示误差**：初始值 $\\frac{1}{n}$ 可能无法在格式 $\\mathcal{F}$ 中精确表示。机器数是 $x_n = \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{n}) = \\frac{1}{n} + \\epsilon_{repr}$，其中 $\\epsilon_{repr}$ 是表示误差。当且仅当 $n$ 是 $2$ 的幂且 $1/n$ 不会导致下溢时，此误差为零。对于其他 $n$ 值，$\\epsilon_{repr}$ 通常不为零。\n2.  **累积误差**：序列 $S_{n,k} = \\mathrm{fl}_{\\mathcal{F}}(S_{n,k-1} + x_n)$ 中的每次加法都是一个浮点运算，并可能引入新的舍入误差 $\\delta_k$。总累积误差是在 $n$ 次加法中这些误差的集合。\n\n总误差是这些效应的总和。当总误差 $E_n = S_n - 1.0$ 足够大，以至于 $S_n$ 不再是 $1.0$ 的正确舍入表示时，$S_n$ 就不等于 $1.0$。\n\n虽然理论误差分析可以估计这种情况可能发生的时间，但由于误差的系统性及其对特定 $n$ 值的依赖性，分析过程十分复杂。解决此问题的一个直接而稳健的方法是通过模拟。我们可以为每种指定的浮点格式实现求和过程，并从正整数 $n \\ge 2$ 开始迭代，直到满足条件 $S_n \\neq 1.0$。$n=1$ 的情况是平凡的，因为 $S_1 = \\mathrm{fl}_{\\mathcal{F}}(0 + \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{1})) = \\mathrm{fl}_{\\mathcal{F}}(1.0) = 1.0$。\n\n对于每种格式 $\\mathcal{F}$，算法如下：\n1.  初始化 $n = 2$。\n2.  开始一个无限循环，直到满足条件为止。\n3.  在循环内部，执行 $S_n$ 的计算：\n    a. 计算 $x_n = \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{n})$。这可以通过首先使用更高的精度（例如，在Python中为 `float64`）计算 $\\frac{1}{n}$，然后将结果舍入到目标格式 $\\mathcal{F}$ 来完成。\n    b. 在格式 $\\mathcal{F}$ 中将求和变量 $s$ 初始化为 $0.0$。\n    c. 执行一个循环 $n$ 次，在每次迭代中计算 $s = \\mathrm{fl}_{\\mathcal{F}}(s + x_n)$。\n4.  求和循环结束后，将最终的和 $s$ 与在格式 $\\mathcal{F}$ 中表示的 $1.0$ 值进行比较。\n5.  如果 $s \\neq 1.0$，则当前的 $n$ 值是满足条件的最小整数。此格式的循环终止，并将 $n$ 记录为结果。\n6.  如果 $s = 1.0$，则将 $n$ 增加 $1$ 并继续主循环的下一次迭代。\n\n此过程将对 `binary16`、`binary32` 和 `binary64` 这三种格式分别执行。这些格式的实现可在 `numpy` 库中找到，分别为 `numpy.float16`、`numpy.float32` 和 `numpy.float64`。这些实现遵循 IEEE 754 标准进行算术运算。\n\n执行此模拟得到以下结果：\n- 对于 `binary16` (`numpy.float16`, $p=10$)，最小整数是 $n=9$。\n- 对于 `binary32` (`numpy.float32`, $p=23$)，最小整数是 $n=11$。\n- 对于 `binary64` (`numpy.float64`, $p=52$)，最小整数是 $n=13$。\n\n这些结果将由提供的程序计算，并以所需的列表格式呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest positive integer n for which the repeated sum\n    of 1/n for n times does not equal 1.0 in specified float formats.\n    \"\"\"\n    \n    test_cases = [\n        np.float16, # IEEE 754 binary16\n        np.float32, # IEEE 754 binary32\n        np.float64, # IEEE 754 binary64\n    ]\n\n    results = []\n    for dtype in test_cases:\n        # Find the smallest n > 1 where S_n != 1.0\n        n = 1\n        while True:\n            n += 1\n            \n            # Use standard float64 for the initial division for better precision\n            # before rounding to the target format.\n            one_over_n = 1.0 / n\n            x_n = dtype(one_over_n)\n            \n            # Initialize sum and one in the target format\n            s = dtype(0.0)\n            one = dtype(1.0)\n            \n            # Perform the left-associated repeated sum of x_n for n times.\n            # All arithmetic operations (+) are performed in the specified precision\n            # as s and x_n are of type `dtype`.\n            for _ in range(n):\n                s += x_n\n            \n            # Check if the final sum is bit-wise not equal to 1.0 in the\n            # given format.\n            if s != one:\n                results.append(n)\n                break\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}