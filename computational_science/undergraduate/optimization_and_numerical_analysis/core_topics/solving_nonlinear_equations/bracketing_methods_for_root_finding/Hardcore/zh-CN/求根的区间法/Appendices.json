{
    "hands_on_practices": [
        {
            "introduction": "掌握一种新算法的最佳方式之一就是亲手实践。本练习将引导你逐步完成二分法的计算过程，通过在一个实际的商业情境（确定盈亏平衡点）中手动执行几次迭代，你将直观地感受到区间是如何不断缩小并逼近根的。",
            "id": "2157541",
            "problem": "一家小型制造公司希望确定其盈亏平衡的生产水平。生产和销售 $x$ 千单位某产品的利润 $P$ 由函数 $P(x) = -1.5x^2 + 140x - 1000$ 建模。该函数的一个根对应于利润为零的盈亏平衡点。公司分析师使用二分法来寻找这个盈亏平衡点。他们从初始区间 $[a_0, b_0] = [5, 10]$ 开始。在执行三次二分法迭代后，他们得到了一个新的、更小的包含根的区间 $[a_3, b_3]$。$a_3$ 和 $b_3$ 的值是多少？\n\n将你的答案表示为行矩阵 $\\begin{pmatrix} a_3  b_3 \\end{pmatrix}$。",
            "solution": "我们已知利润函数 $P(x) = -1.5x^{2} + 140x - 1000$ 是一个连续多项式。根据中值定理，如果 $P(a)$ 和 $P(b)$ 的符号相反，则在 $(a,b)$ 内存在一个根。二分法通过重复地将区间减半并选择符号变化持续存在的子区间来进行。我们从 $[a_{0},b_{0}] = [5,10]$ 开始。\n\n首先，计算端点处的函数值的符号：\n$$\nP(5) = -1.5(25) + 140(5) - 1000 = -37.5 + 700 - 1000 = -337.5  0,\n$$\n$$\nP(10) = -1.5(100) + 140(10) - 1000 = -150 + 1400 - 1000 = 250 > 0.\n$$\n由于 $P(5) \\cdot P(10)  0$，因此在 $[5,10]$ 内存在一个根。\n\n第一次迭代：中点 $m_{1} = \\frac{a_{0}+b_{0}}{2} = \\frac{5+10}{2} = 7.5 = \\frac{15}{2}$。\n计算\n$$\nP\\!\\left(\\frac{15}{2}\\right) = -1.5\\left(\\frac{15}{2}\\right)^2 + 140\\left(\\frac{15}{2}\\right) - 1000 = -84.375 + 1050 - 1000 = -34.375  0.\n$$\n由于 $P(m_{1})  0$ 且 $P(b_{0}) > 0$，符号变化发生在 $[m_{1},b_{0}]$ 区间内。因此 $[a_{1},b_{1}] = \\left[\\frac{15}{2}, 10\\right]$。\n\n第二次迭代：中点 $m_{2} = \\frac{a_{1}+b_{1}}{2} = \\frac{7.5+10}{2} = 8.75 = \\frac{35}{4}$。\n计算\n$$\nP\\!\\left(\\frac{35}{4}\\right) = -1.5\\left(\\frac{35}{4}\\right)^2 + 140\\left(\\frac{35}{4}\\right) - 1000 = -114.84375 + 1225 - 1000 = 110.15625 > 0.\n$$\n由于 $P(a_{1})  0$ 且 $P(m_{2}) > 0$，符号变化发生在 $[a_{1},m_{2}]$ 区间内。因此 $[a_{2},b_{2}] = \\left[\\frac{15}{2}, \\frac{35}{4}\\right]$。\n\n第三次迭代：中点 $m_{3} = \\frac{a_{2}+b_{2}}{2} = \\frac{7.5+8.75}{2} = 8.125 = \\frac{65}{8}$。\n计算\n$$\nP\\!\\left(\\frac{65}{8}\\right) = -1.5\\left(\\frac{65}{8}\\right)^2 + 140\\left(\\frac{65}{8}\\right) - 1000 = -99.0234375 + 1137.5 - 1000 = 38.4765625 > 0.\n$$\n由于 $P(a_{2})  0$ 且 $P(m_{3}) > 0$，符号变化发生在 $[a_{2},m_{3}]$ 区间内。因此，经过三次迭代后，区间为\n$$\n[a_{3},b_{3}] = \\left[\\frac{15}{2}, \\frac{65}{8}\\right].\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{15}{2}  \\frac{65}{8} \\end{pmatrix}}$$"
        },
        {
            "introduction": "除了二分法，试位法（Regula Falsi）是另一种重要的区间套法。与二分法机械地将区间对半分割不同，试位法会利用函数在区间端点的值来做出一个更“聪明”的预测。这个练习将直接比较这两种方法的第一步迭代，帮助你理解它们各自的策略和收敛特性。",
            "id": "2157489",
            "problem": "考虑在区间 $[1, 2]$ 内寻找函数 $f(x) = x^3 - 5$ 的一个根。解决此问题的两种常用迭代求根区间法是二分法和试位法（也称为伪位置法）。\n\n令 $c_B$ 为对初始区间 $[1, 2]$ 应用一次二分法迭代所得到的根的第一个近似值。\n令 $c_{RF}$ 为对同一初始区间 $[1, 2]$ 应用一次试位法迭代所得到的根的第一个近似值。\n\n该函数的真实根是 $x_{true} = \\sqrt[3]{5}$。为便于本题计算，您可以使用近似值 $x_{true} \\approx 1.709976$。\n\n计算这两种方法的近似误差之间的绝对差。即，计算 $| |c_B - x_{true}| - |c_{RF} - x_{true}| |$ 的值。将您的最终答案四舍五入到四位有效数字。",
            "solution": "我们已知函数 $f(x) = x^{3} - 5$ 在区间 $[1,2]$ 上，其中 $f(1) = -4$ 且 $f(2) = 3$，因此根位于 $[1,2]$ 内。\n\n对于一步二分法，中点为\n$$\nc_{B} = \\frac{1 + 2}{2} = \\frac{3}{2}.\n$$\n\n对于从 $(a,f(a)) = (1,-4)$ 和 $(b,f(b)) = (2,3)$ 开始的一步试位法，线性插值的根为\n$$\nc_{RF} = a - f(a)\\,\\frac{b - a}{f(b) - f(a)} = 1 - (-4)\\,\\frac{2 - 1}{3 - (-4)} = 1 + \\frac{4}{7} = \\frac{11}{7}.\n$$\n\n由于 $f$ 在 $[1,2]$ 上是严格递增的，且 $x_{true} \\in [1,2]$，我们有 $c_{B}  x_{true}$ 和 $c_{RF}  x_{true}$，因此\n$$\n|c_{B} - x_{true}| = x_{true} - \\frac{3}{2}, \\quad |c_{RF} - x_{true}| = x_{true} - \\frac{11}{7}.\n$$\n因此，误差的绝对差为\n$$\n\\left||c_{B} - x_{true}| - |c_{RF} - x_{true}|\\right| = \\left|(x_{true} - \\tfrac{3}{2}) - (x_{true} - \\tfrac{11}{7})\\right| = \\left|\\frac{11}{7} - \\frac{3}{2}\\right| = \\left|\\frac{22 - 21}{14}\\right| = \\frac{1}{14}.\n$$\n\n数值上，\n$$\n\\frac{1}{14} \\approx 0.071428571\\ldots,\n$$\n四舍五入到四位有效数字为 $0.07143$。",
            "answer": "$$\\boxed{0.07143}$$"
        },
        {
            "introduction": "在实际的科学计算中，单一算法往往无法完美应对所有情况。例如，区间套法虽然可靠但收敛较慢，而牛顿法等开放方法虽然收敛快但对初值敏感。这项高级实践将挑战你设计并实现一个混合算法，它结合了二分法的稳定收敛性和牛顿法的局部快速收敛性，从而将理论知识与编程实践联系起来。",
            "id": "2377926",
            "problem": "您需要实现一种混合区间求根算法，该算法结合了保证收敛的区间二分法与局部快速收敛的牛顿-拉夫逊方法。该算法必须从一个严格区间 $\\left[a,b\\right]$ 开始，该区间对于连续函数 $f(x)$ 满足 $f(a)\\,f(b)  0$，从而应用介值定理。在满足一个明确定义的切换准则之前，算法必须保持该区间不变性。\n\n从基本原理来看，区间法阶段基于连续函数 $f(x)$ 在 $\\left[a,b\\right]$ 上的介值定理，通过重复选择符号变化得以保持的子区间来更新区间。牛顿-拉夫逊阶段基于 $f(x)$ 在当前迭代点 $x$ 附近的一阶泰勒线性化，当 $f'(x)$ 非零且初始猜测足够接近时，该迭代会趋近于一个根。\n\n混合方法的设计要求：\n- 使用一个始终保持 $f(a)\\,f(b)  0$ 的区间法阶段。持续此阶段，直到当前区间宽度满足 $(b-a) \\le \\delta$，其中 $\\delta  0$ 是一个预设的阈值。\n- 一旦 $(b-a) \\le \\delta$，切换到区间内的牛顿-拉夫逊阶段，使用中点 $x=\\frac{a+b}{2}$ 作为初始猜测。一个牛顿步 $x_{\\text{new}} = x - \\frac{f(x)}{f'(x)}$ 仅在 $x_{\\text{new}} \\in (a,b)$ 且 $f'(x)$ 为有限非零值时才能被接受。如果接受条件不满足，则执行一个二分步。在产生候选点 $x_{\\text{new}}$ 后，通过选择保留符号变化的子区间来更新区间 $\\left[a,b\\right]$，然后继续。\n- 终止条件：当 $|f(x)| \\le \\tau_f$ 或 $(b-a) \\le \\tau_x$ 时停止，其中 $\\tau_f  0$ 和 $\\tau_x  0$ 是绝对容差。\n- 任何三角函数的角度必须以弧度为单位。\n- 您的实现必须是确定性的，并且不得使用随机性。\n\n对所有测试用例使用以下绝对容差：$\\tau_f = 10^{-12}$ 和 $\\tau_x = 10^{-12}$。为防止无限循环，最多使用 $N_{\\max} = 1000$ 次总迭代。\n\n测试套件规范。实现您的求解器并将其应用于以下五个案例。对于每个案例，完全按照给定的方式定义 $f(x)$ 及其导数 $f'(x)$。确保初始端点如所述满足 $f(a)\\,f(b)  0$。\n\n- 案例 $1$（多项式，单实根）：\n  - $f_1(x) = x^3 - 2x - 5$\n  - $f_1'(x) = 3x^2 - 2$\n  - $\\left[a,b\\right] = \\left[2,3\\right]$, $\\delta = 10^{-3}$\n\n- 案例 $2$（超越方程，不动点类型，角度以弧度为单位）：\n  - $f_2(x) = \\cos(x) - x$\n  - $f_2'(x) = -\\sin(x) - 1$\n  - $\\left[a,b\\right] = \\left[0,1\\right]$, $\\delta = 10^{-8}$\n\n- 案例 $3$（奇数重根，导数在根处为零）：\n  - $f_3(x) = (x - 1)^3$\n  - $f_3'(x) = 3(x - 1)^2$\n  - $\\left[a,b\\right] = \\left[0.5,2.0\\right]$, $\\delta = 10^{-4}$\n\n- 案例 $4$（初始宽度等于阈值的立即切换边界）：\n  - $f_4(x) = e^x - 3$\n  - $f_4'(x) = e^x$\n  - $\\left[a,b\\right] = \\left[1.0,1.1\\right]$, $\\delta = 10^{-1}$\n\n- 案例 $5$（根在区间中点，在区间法阶段精确检测）：\n  - $f_5(x) = x^3$\n  - $f_5'(x) = 3x^2$\n  - $\\left[a,b\\right] = \\left[-10^{-1},10^{-1}\\right]$, $\\delta = 10^{-6}$\n\n所有函数在其各自的区间上都是连续的，对于案例 $1$、$2$、$3$ 和 $5$，端点满足 $f(a)\\,f(b)  0$。对于案例 $4$，初始区间宽度恰好等于 $\\delta$。\n\n要求的输出：\n- 对每个案例，将计算出的根的近似值作为浮点数输出。在适用的情况下，角度以弧度表示。不涉及物理单位。\n- 使用定点格式将每个根四舍五入到小数点后恰好 $12$ 位。\n- 您的程序应生成单行输出，其中包含按案例 $1$ 到 $5$ 的顺序排列的结果，形式为用逗号分隔并用方括号括起来的列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$）。",
            "solution": "该问题要求实现一种混合求根算法。以下是该算法的逐步逻辑形式化，旨在满足所有给定的设计要求。\n\n1.  **初始化**：算法始于一个初始区间 $[a, b]$、函数 $f(x)$ 及其导数 $f'(x)$、切换阈值 $\\delta$、收敛容差 $\\tau_f$ 和 $\\tau_x$，以及最大迭代次数 $N_{\\max}$。计算端点处的函数值 $f_a = f(a)$ 和 $f_b = f(b)$。根据问题规范，初始区间已保证 $f_a f_b  0$。如果 $|f_a| \\le \\tau_f$ 或 $|f_b| \\le \\tau_f$，则根已在端点处找到。\n\n2.  **迭代循环**：该过程进行迭代，不断缩小区间 $[a, b]$，直到满足终止条件，最多进行 $N_{\\max}$ 次迭代。\n\n3.  **终止条件检查**：在每次迭代开始时，检查区间宽度。如果 $(b-a) \\le \\tau_x$，则过程停止，根的最佳估计值为最终区间的中点 $\\frac{a+b}{2}$。\n\n4.  **阶段确定与选点**：混合策略的核心在于根据当前区间宽度选择下一个候选点 $x_{\\text{next}}$。\n    -   **阶段 1：二分法 ($ (b-a) > \\delta $)**：如果区间宽度大于阈值 $\\delta$，则使用保证收敛但较慢的二分法。候选点为区间中点：$x_{\\text{next}} = \\frac{a+b}{2}$。\n    -   **阶段 2：混合牛顿/二分法 ($ (b-a) \\le \\delta $)**：一旦区间足够窄，切换到更快的策略。\n        a. 将当前区间中点 $x_k = \\frac{a+b}{2}$ 作为牛顿-拉夫逊方法的初始猜测。\n        b. 计算导数 $f'(x_k)$。如果导数非有限或为零，则牛顿步无效，算法回退到二分法。\n        c. 如果导数有效，计算牛顿-拉夫逊更新：$x_{\\text{Newton}} = x_k - \\frac{f(x_k)}{f'(x_k)}$。\n        d. 仅当新点 $x_{\\text{Newton}}$ 严格落在当前区间 $(a, b)$ 内时，才接受该点。此安全措施可防止迭代跳出已知包含根的区域。\n        e. 如果牛顿步被接受，则 $x_{\\text{next}} = x_{\\text{Newton}}$。\n        f. 如果牛顿步的任何条件不满足，算法将对当前迭代回退到安全的二分步：$x_{\\text{next}} = \\frac{a+b}{2}$。\n\n5.  **区间更新**：确定 $x_{\\text{next}}$ 后，计算 $f_{\\text{next}} = f(x_{\\text{next}})$。\n    -   如果 $|f_{\\text{next}}| \\le \\tau_f$，则认为已找到根，并返回 $x_{\\text{next}}$。\n    -   否则，根据 $f_{\\text{next}}$ 的符号更新区间以保持根被包围：\n        - 如果 $f_a \\cdot f_{\\text{next}}  0$，根位于前半部分，更新 $b = x_{\\text{next}}$ 和 $f_b = f_{\\text{next}}$。\n        - 否则，根位于后半部分，更新 $a = x_{\\text{next}}$ 和 $f_a = f_{\\text{next}}$。\n    然后循环以新的、更窄的区间继续。\n\n6.  **最终结果**：如果达到最大迭代次数 $N_{\\max}$ 仍未收敛，算法终止并返回最后区间的中心点 $\\frac{a+b}{2}$ 作为最佳近似值。\n\n以下是实现此逻辑的 Python 代码：\n\n```python\nimport numpy as np\n\ndef hybrid_root_finder(f, df, a, b, delta, tau_f, tau_x, n_max):\n    \"\"\"\n    Finds a root of a function using a hybrid bisection-Newton-Raphson method.\n\n    Args:\n        f (callable): The function for which to find a root.\n        df (callable): The derivative of the function f.\n        a (float): The lower bound of the initial bracket.\n        b (float): The upper bound of the initial bracket.\n        delta (float): The bracket width threshold to switch to Newton's method.\n        tau_f (float): The absolute tolerance for the function value.\n        tau_x (float): The absolute tolerance for the bracket width.\n        n_max (int): The maximum number of iterations.\n\n    Returns:\n        float: The approximation of the root.\n    \"\"\"\n    fa = f(a)\n    fb = f(b)\n\n    if np.sign(fa) == np.sign(fb):\n        # As per problem specification, initial brackets are valid.\n        pass\n\n    if abs(fa) = tau_f:\n        return a\n    if abs(fb) = tau_f:\n        return b\n\n    for _ in range(n_max):\n        # Termination condition 1: Bracket width is smaller than tolerance.\n        if (b - a) = tau_x:\n            return (a + b) / 2\n\n        x_next = None\n\n        # Check for switching condition to attempt Newton-Raphson.\n        if (b - a) = delta:\n            # Candidate for Newton's method is the midpoint.\n            x_mid = (a + b) / 2\n            f_mid = f(x_mid)\n\n            # Termination condition 2: Function value at midpoint is small enough.\n            if abs(f_mid) = tau_f:\n                return x_mid\n\n            df_mid = df(x_mid)\n\n            # Check if Newton step is valid and safe.\n            if df_mid != 0 and np.isfinite(df_mid):\n                x_newton = x_mid - f_mid / df_mid\n                # Accept step only if it's within the current bracket.\n                if a  x_newton  b:\n                    x_next = x_newton\n\n        # If Newton step was not attempted or failed, fall back to bisection.\n        if x_next is None:\n            x_next = (a + b) / 2\n\n        f_next = f(x_next)\n\n        # Termination condition 3: Function value at the new point is small enough.\n        if abs(f_next) = tau_f:\n            return x_next\n\n        # Update the bracket to maintain the sign change.\n        if np.sign(fa) * np.sign(f_next)  0:\n            b = x_next\n            fb = f_next\n        else:\n            a = x_next\n            fa = f_next\n    \n    # If max iterations reached, return the midpoint of the final bracket.\n    return (a + b) / 2\n```",
            "answer": "[2.094551481542,0.739085133215,1.000000000000,1.098612288668,0.000000000000]"
        }
    ]
}