{
    "hands_on_practices": [
        {
            "introduction": "时间序列分析的第一步通常是检查平稳性。这个练习将帮助你通过自相关函数 ($ACF$) 和偏自相关函数 ($PACF$) 的图形来识别季节性非平稳性，这是许多现实世界数据（如零售销售数据）的共同特征。掌握这种诊断技能对于正确选择季节性差分至关重要，从而为后续建立有效的 $SARIMA$ 模型奠定基础。",
            "id": "3187708",
            "problem": "一个零售产品的月度时间序列 $\\{x_t\\}_{t=1}^{120}$ 表现出周期为 $s=12$ 的规律性季节性。为了在拟合季节性自回归积分移动平均 (SARIMA) 模型之前评估适当的季节性处理方法，一位从业者计算了未差分序列 $\\{x_t\\}$ 的样本自相关函数 $\\hat{\\rho}(k)$ 和样本偏自相关函数 $\\widehat{\\phi}(k)$。观察到以下特征：\n\n- 在季节性滞后阶数上，自相关系数很大且衰减缓慢：$\\hat{\\rho}(12) \\approx 0.82$，$\\hat{\\rho}(24) \\approx 0.65$，$\\hat{\\rho}(36) \\approx 0.51$；在 $k \\in \\{12,24,36,\\dots\\}$ 处的峰值序列持续高于典型的显著性阈值，并且仅逐渐减小。\n- 在非季节性滞后阶数 $k \\in \\{1,2,3,4,5\\}$ 上，自相关系数也很大，但表现为逐渐衰减，而非急剧截尾。\n- 偏自相关函数在季节性滞后阶数上显示出显著的尖峰：$\\widehat{\\phi}(12) \\approx 0.80$，$\\widehat{\\phi}(24) \\approx 0.58$，$\\widehat{\\phi}(36) \\approx 0.43$，而周期 $s$ 倍数之间的中间滞后阶数的偏自相关系数相对较小；在 $k=12$ 处没有单一的急剧截尾。\n\n使用弱平稳性（恒定均值、有限方差和仅依赖于滞后阶数的自协方差）的基本定义、总体自相关函数和偏自相关函数，推断关于季节性成分的最合适的下一步建模步骤。以下哪个选项与这些诊断结果最一致，并且最有可能产生一个适合后续非季节性部分识别的季节性平稳序列？\n\nA. 进行周期为 $s=12$ 的 $D=1$ 阶季节性差分，即在进一步建模前，将序列转换为 $\\nabla_{12} x_t = x_t - x_{t-12}$。\n\nB. 保持 $\\{x_t\\}$ 季节性未差分，并在 SARIMA 结构中引入一个周期为 $s=12$ 的 $P=1$ 阶季节性自回归项。\n\nC. 进行 $d=1$ 阶的非季节性差分（无季节性差分），并包含一个周期为 $s=12$ 的 $P=1$ 阶季节性自回归项。\n\nD. 保持 $\\{x_t\\}$ 季节性未差分，并在 SARIMA 结构中添加一个周期为 $s=12$ 的 $Q=1$ 阶季节性移动平均项。",
            "solution": "将通过首先提取给定信息，然后评估其科学有效性和结构完整性来验证问题陈述。\n\n### 步骤1：提取已知信息\n\n-   时间序列表示为 $\\{x_t\\}_{t=1}^{120}$。\n-   数据是月度的，意味着季节周期为 $s=12$。\n-   目标是确定拟合季节性自回归积分移动平均 (SARIMA) 模型的适当季节性处理方法。\n-   分析是在未差分的序列 $\\{x_t\\}$ 上进行的。\n-   来自样本自相关函数 (ACF) $\\hat{\\rho}(k)$ 的诊断信息：\n    -   在季节性滞后阶数 $k=12, 24, 36, \\dots$ 上，ACF 值很大且衰减缓慢。\n    -   提供了具体数值：$\\hat{\\rho}(12) \\approx 0.82$，$\\hat{\\rho}(24) \\approx 0.65$，$\\hat{\\rho}(36) \\approx 0.51$。\n    -   在非季节性滞后阶数 $k \\in \\{1,2,3,4,5\\}$ 上，ACF 值也很大并显示出逐渐衰减。\n-   来自样本偏自相关函数 (PACF) $\\widehat{\\phi}(k)$ 的诊断信息：\n    -   在季节性滞后阶数上，存在显著的尖峰：$\\widehat{\\phi}(12) \\approx 0.80$，$\\widehat{\\phi}(24) \\approx 0.58$，$\\widehat{\\phi}(36) \\approx 0.43$。\n    -   在周期 $s=12$ 的倍数之间的中间滞后阶数上，PACF 值相对较小。\n    -   在 $k=12$ 处没有单一的急剧截尾。\n\n### 步骤2：使用提取的已知信息进行验证\n\n-   **科学依据：** 该问题设定在成熟的 Box-Jenkins 时间序列分析方法论框架内。ACF、PACF、平稳性、差分和 SARIMA 模型的概念是现代统计学和计量经济学的基础。给定的 $\\hat{\\rho}(k)$ 和 $\\widehat{\\phi}(k)$ 的数值对于一个具有强季节性和非平稳性的序列是合理的。该问题在科学上是合理的。\n-   **良构性：** 该问题提供了具体的、标准的诊断信息（ACF 和 PACF 的行为），并要求得出相应的标准建模结论。这是应用时间序列分析中一个经典的模式识别任务，旨在导出一个具体的、明确定义的操作。\n-   **客观性：** 对 ACF 和 PACF 的描述使用了标准术语（“衰减缓慢”、“显著尖峰”、“急剧截尾”），并用量化数值支持这些定性陈述。问题是客观的，没有主观论断。\n-   **完整性和一致性：** 所提供的信息足以对季节性成分做出合理的决策。季节性非平稳性的关键诊断指标——季节性滞后阶数上缓慢衰减的 ACF——被明确陈述和量化。这一观察结果与在第一个季节性滞后阶数上 PACF 出现大尖峰的报告相一致，这两者共同构成了季节性单位根的经典特征。\n-   **无其他缺陷：** 该问题既不简单也非病态。它代表了实践中遇到的现实情景。\n\n### 步骤3：结论和行动\n\n问题陈述是有效的。这是一个时间序列分析中的标准且良构的问题。我将继续推导解决方案。\n\n### 推导与选项分析\n\n主要目标是确定使序列达到季节性平稳的适当变换。如果一个时间序列的均值、方差和自协方差不随时间变化，则该序列是弱平稳的。时间序列中的非平稳性通常表现为均值不恒定的趋势或季节性模式。在 SARIMA 模型的背景下，非平稳性通常通过对序列进行差分来处理。\n\n我们被要求确定针对季节性成分的适当步骤，因此我们必须关注 ACF 和 PACF 在季节性滞后阶数上的行为，即季节周期 $s=12$ 的倍数（即滞后 $k=12, 24, 36, \\dots$）。\n\n1.  **自相关函数 (ACF) 分析：**\n    问题陈述指出，样本 ACF $\\hat{\\rho}(k)$ 在季节性滞后阶数上“很大且衰减缓慢”。具体数值为 $\\hat{\\rho}(12) \\approx 0.82$，$\\hat{\\rho}(24) \\approx 0.65$，以及 $\\hat{\\rho}(36) \\approx 0.51$。ACF 的这种缓慢衰减是非平稳性的典型标志。一个平稳的自回归 (AR) 过程也有一个衰减的 ACF，但其衰减通常是指数级的且速度更快。这里看到的非常缓慢、近乎线性的衰减是过程中存在单位根的强烈信号。由于这种行为是在季节性滞后阶数上观察到的，它表明存在一个**季节性单位根**。具有季节性单位根的过程是季节性非平稳的。对季节性单位根的标准处理方法是进行一阶季节性差分，即变换 $y_t = x_t - x_{t-s}$。对于本问题，这对应于 $\\nabla_{12} x_t = x_t - x_{t-12}$。\n\n2.  **偏自相关函数 (PACF) 分析：**\n    问题陈述指出，样本 PACF $\\widehat{\\phi}(k)$ 在“季节性滞后阶数上显示出显著的尖峰”，其中 $\\widehat{\\phi}(12) \\approx 0.80$。PACF 在第一个季节性滞后阶数（$k=s$）处出现一个大的、显著的尖峰，结合缓慢衰减的季节性 ACF，强化了存在季节性单位根的诊断。对于一个非季节性随机游走过程 $x_t = x_{t-1} + \\epsilon_t$，其 ACF 从接近 1 的值开始缓慢衰减，而 PACF 在滞后 1 处有一个单一的尖峰。以此类推，对于一个带有单位根的纯季节性过程 $(1-B^{12})x_t = \\epsilon_t$，其在滞后 $12, 24, \\dots$ 处的 ACF 会缓慢衰减，而 PACF 在滞后 12 处会有一个显著的尖峰。给定的诊断结果与此模式相符。在滞后 24 和 36 处也存在尖峰并且衰减的现象表明，在进行一次季节性差分后，可能仍然存在一个季节性 AR 过程。然而，根据非平稳性的强有力证据，最紧迫和必要的步骤是执行季节性差分。\n\n3.  **建模策略结论：**\n    季节性滞后阶数上缓慢衰减的 ACF 和第一个季节性滞后阶数上大的 PACF 尖峰的组合，强烈表明存在季节性单位根。适当的建模操作是对序列进行 $D=1$ 阶的季节性差分，以获得季节性平稳性。在此变换之后，需要重新检查差分后序列 $\\nabla_{12} x_t$ 的 ACF 和 PACF，以确定非季节性成分的阶数（$p,d,q$）和任何剩余的季节性成分的阶数（$P,Q$）。关于非季节性滞后阶数的观察（ACF 逐渐衰减）表明可能也需要进行常规差分（$d=1$），但问题是根据给定的诊断信息，具体询问关于季节性部分的处理。对于季节性部分而言，最直接和关键的步骤是差分。\n\n### 逐项选项分析\n\n**A. 进行周期为 $s=12$ 的 $D=1$ 阶季节性差分，即在进一步建模前，将序列转换为 $\\nabla_{12} x_t = x_t - x_{t-12}$。**\n这个选项提出的正是诊断证据所指示的操作。在季节性滞后阶数上 ACF 的缓慢衰减是季节性非平稳性的经典特征，这需要进行季节性差分。这是处理季节性成分的正确第一步。\n**结论：正确。**\n\n**B. 保持 $\\{x_t\\}$ 季节性未差分，并在 SARIMA 结构中引入一个周期为 $s=12$ 的 $P=1$ 阶季节性自回归项。**\n这是不正确的。一个平稳的季节性 AR(1) 过程，$(1 - \\Phi_1 B^{12})x_t = \\epsilon_t$ 且 $|\\Phi_1|  1$，其季节性 ACF 会呈指数衰减，而季节性 PACF 在滞后 12 处会急剧截尾。观察到的 ACF 缓慢衰减指向一个单位根（$\\Phi_1=1$），这意味着该过程是非平稳的。对一个非平稳序列拟合一个平稳的 AR 模型是模型设定错误。必须先对序列进行差分。\n**结论：不正确。**\n\n**C. 进行 $d=1$ 阶的非季节性差分（无季节性差分），并包含一个周期为 $s=12$ 的 $P=1$ 阶季节性自回归项。**\n这个选项未能解决季节性非平稳性的主要问题。仅应用非季节性差分 $\\nabla x_t = x_t - x_{t-1}$，不会消除在季节性滞后阶数上的强烈的、缓慢衰减的相关性。得到的序列仍然是季节性非平稳的。此外，与选项 B 的原因相同，在未首先应用必要的季节性差分的情况下包含季节性 AR 项是不合适的。\n**结论：不正确。**\n\n**D. 保持 $\\{x_t\\}$ 季节性未差分，并在 SARIMA 结构中添加一个周期为 $s=12$ 的 $Q=1$ 阶季节性移动平均项。**\n这是不正确的。一个季节性 MA(1) 过程的特征是 ACF 在滞后 $s=12$ 处有一个单一的显著尖峰，而 PACF 在季节性滞后阶数（$k=12, 24, \\dots$）上拖尾（衰减）。观察到的诊断结果与此模式相反：ACF 拖尾，而 PACF 显示尖峰。因此，数据并未表明需要一个季节性 MA 项。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "虽然差分是处理非平稳性的有力工具，但过度差分也会引入问题，导致模型不必要的复杂化和参数估计困难。这个练习通过一个经典案例——对随机游走（一个 $I(1)$ 过程）进行二次差分——来揭示过度差分的典型信号。理解这种信号能让你在模型诊断中避免常见的陷阱，并选择最恰当的差分阶数 $d$。",
            "id": "2372420",
            "problem": "考虑一个金融对数价格时间序列 $\\{X_t\\}$，它服从随机游走：$X_t = X_{t-1} + u_t$，其中 $\\{u_t\\}$ 是独立同分布的，均值为 $0$，方差为 $\\sigma^2$。一位分析师错误地对 $\\{X_t\\}$ 进行了二阶差分，并研究转换后的序列 $Y_t = \\Delta^2 X_t = X_t - 2X_{t-1} + X_{t-2}$。以下哪项最能描述这种错误差分所隐含的 $\\{Y_t\\}$ 的自相关函数 (ACF) 和偏自相关函数 (PACF) 的理论行为？\n\nA. ACF 在滞后 1 阶处显示一个约 -0.5 的显著负向尖峰，并且在大于 1 阶的滞后处基本为 $0$；PACF 逐渐衰减至 $0$，可能带有交替的符号。\n\nB. ACF 从接近 $1$ 的值开始非常缓慢地正向衰减，这是近单位根自回归的特征；PACF 在滞后 1 阶处有一个大的正向尖峰，之后基本为 $0$。\n\nC. ACF 在滞后 1 阶处显示一个接近 $+0.5$ 的显著正向尖峰，并且在大于 1 阶的滞后处基本为 $0$；PACF 逐渐衰减至 $0$。\n\nD. ACF 和 PACF 都在滞后 2 阶后截尾，表明这是一个只有两个非零依赖滞后阶数的短记忆过程。\n\nE. ACF 在多个滞后阶数上符号交替，并呈缓慢衰减的振荡；PACF 在滞后 1 阶处有一个大的负向尖峰，之后基本为 $0$。",
            "solution": "首先必须对问题陈述进行严格的验证。\n\n步骤 1：提取已知条件\n提供的已知信息如下：\n- 对数价格时间序列表示为 $\\{X_t\\}$。\n- 过程 $\\{X_t\\}$ 是一个随机游走，由方程 $X_t = X_{t-1} + u_t$ 定义。\n- 项 $\\{u_t\\}$ 代表一个独立同分布 (i.i.d.) 的随机变量序列。\n- 噪声项的均值为 $E[u_t] = 0$。\n- 噪声项的方差为 $Var(u_t) = \\sigma^2$。\n- 通过对 $\\{X_t\\}$ 进行二阶差分构建了一个新的时间序列 $\\{Y_t\\}$：$Y_t = \\Delta^2 X_t = X_t - 2X_{t-1} + X_{t-2}$。\n\n问题要求解的是生成的序列 $\\{Y_t\\}$ 的自相关函数 (ACF) 和偏自相关函数 (PACF) 的理论行为。\n\n步骤 2：使用提取的已知条件进行验证\n该问题是使用时间序列分析中的标准、明确定义的概念来表述的。随机游走模型是计量经济学和金融学中的一个基本构念。差分操作是获得平稳性的一种标准技术。ACF 和 PACF 的概念是识别平稳时间序列结构的主要工具。该问题是自洽的，提供了推导 $\\{Y_t\\}$ 性质所需的所有必要定义。问题是客观的，并且可以进行数学形式化。问题中没有科学或逻辑上的矛盾，没有缺失信息，也不依赖于主观或不科学的前提。\n\n步骤 3：结论与行动\n问题陈述有效。可以推导出解答。\n\n解答推导\n过程 $\\{X_t\\}$ 是一个随机游走：\n$$X_t = X_{t-1} + u_t$$\n这意味着 $\\{X_t\\}$ 的一阶差分是白噪声过程 $\\{u_t\\}$：\n$$\\Delta X_t = X_t - X_{t-1} = u_t$$\n过程 $\\{u_t\\}$ 是平稳的，因为它是独立同分布的，具有恒定均值 $E[u_t]=0$ 和恒定方差 $Var(u_t)=\\sigma^2$。\n\n分析师错误地对 $\\{X_t\\}$ 进行二阶差分，得到过程 $\\{Y_t\\}$：\n$$Y_t = \\Delta^2 X_t = \\Delta(\\Delta X_t) = \\Delta(u_t) = u_t - u_{t-1}$$\n这表明 $\\{Y_t\\}$ 是一个 1 阶移动平均过程，记作 MA($1$)。一个 MA($1$) 过程的一般形式是 $Y_t = \\epsilon_t + \\theta_1 \\epsilon_{t-1}$。在我们的例子中，噪声项是 $\\epsilon_t = u_t$，MA 参数是 $\\theta_1 = -1$。\n\n为了确定 $\\{Y_t\\}$ 的 ACF 和 PACF，我们首先计算它的自协方差。\n$\\{Y_t\\}$ 的均值为：\n$$E[Y_t] = E[u_t - u_{t-1}] = E[u_t] - E[u_{t-1}] = 0 - 0 = 0$$\n方差，或滞后 0 阶的自协方差为 $\\gamma_0$：\n$$\\gamma_0 = Var(Y_t) = E[Y_t^2] = E[(u_t - u_{t-1})^2] = E[u_t^2 - 2u_t u_{t-1} + u_{t-1}^2]$$\n由于 $\\{u_t\\}$ 是独立同分布且均值为 0，所以 $E[u_t u_{t-1}] = E[u_t]E[u_{t-1}] = 0$。因此：\n$$\\gamma_0 = E[u_t^2] + E[u_{t-1}^2] = Var(u_t) + Var(u_{t-1}) = \\sigma^2 + \\sigma^2 = 2\\sigma^2$$\n滞后 1 阶的自协方差 $\\gamma_1$ 为：\n$$\\gamma_1 = Cov(Y_t, Y_{t-1}) = E[Y_t Y_{t-1}] = E[(u_t - u_{t-1})(u_{t-1} - u_{t-2})]$$\n$$= E[u_t u_{t-1} - u_t u_{t-2} - u_{t-1}^2 + u_{t-1} u_{t-2}]$$\n由于 $\\{u_t\\}$ 的独立同分布性质，所有具有不同时间索引的交叉乘积项的期望值都为零。\n$$\\gamma_1 = 0 - 0 - E[u_{t-1}^2] + 0 = -Var(u_{t-1}) = -\\sigma^2$$\n滞后 $k \\ge 2$ 阶的自协方差 $\\gamma_k$ 为：\n$$\\gamma_k = E[Y_t Y_{t-k}] = E[(u_t - u_{t-1})(u_{t-k} - u_{t-k-1})]$$\n对于 $k \\ge 2$，展开式中的所有时间索引 ($t, t-1, t-k, t-k-1$) 都是不同的。因此，每一项的期望值都为零。\n$$\\gamma_k = 0 \\quad \\text{for } k \\ge 2$$\n\n现在我们计算自相关函数 (ACF)，$\\rho_k = \\gamma_k / \\gamma_0$。\n对于滞后 1 阶：\n$$\\rho_1 = \\frac{\\gamma_1}{\\gamma_0} = \\frac{-\\sigma^2}{2\\sigma^2} = -0.5$$\n对于滞后 $k \\ge 2$ 阶：\n$$\\rho_k = \\frac{\\gamma_k}{\\gamma_0} = \\frac{0}{2\\sigma^2} = 0$$\n$\\{Y_t\\}$ 的理论 ACF 在滞后 1 阶处有唯一的非零值，恰好为 $-0.5$，并且在所有后续滞后阶数上截尾至零。这是 MA($1$) 过程的定义性特征。\n\n接下来，我们讨论偏自相关函数 (PACF)。对于一个一般的 MA($q$) 过程，PACF 是拖尾的，这意味着它会逐渐衰减至零，而不是突然截尾。过程 $Y_t = u_t - u_{t-1}$ 是参数 $\\theta_1 = -1$ 的 MA($1$) 过程的一个特例。这是一个不可逆的 MA 过程，因为可逆性要求 $|\\theta_1|  1$。PACF $\\phi_{kk}$ 可以被证明遵循以下模式：\n$$\\phi_{kk} = -\\frac{1}{k+1}$$\n例如：\n- $\\phi_{11} = \\rho_1 = -0.5 = -1/2$\n- $\\phi_{22} = -1/3 \\approx -0.333$\n- $\\phi_{33} = -1/4 = -0.25$\n这表明随着滞后阶数 $k$ 的增加，PACF 会逐渐、单调地衰减至 0。PACF 的符号不交替。\n\n理论行为总结：\n- **ACF**：在滞后 1 阶后截尾，且 $\\rho_1 = -0.5$。\n- **PACF**：逐渐衰减至 0 (具体来说，$\\phi_{kk} = -1/(k+1)$)。\n\n逐项分析\n\nA. ACF 在滞后 1 阶处显示一个约 -0.5 的显著负向尖峰，并且在大于 1 阶的滞后处基本为 $0$；PACF 逐渐衰减至 $0$，可能带有交替的符号。\n- ACF 描述：“在滞后 1 阶处有一个约 -0.5 的显著负向尖峰”并且“在大于 1 阶的滞后处基本为 $0$”。这是对我们推导出的 ACF 的精确描述。\n- PACF 描述：“逐渐衰减至 $0$”。这是对 MA 过程 PACF 的正确描述。短语“可能带有交替的符号”是关于衰减的 PACF 的一般性陈述；在这个具体案例中，衰减是单调且为负的，这也是逐渐衰减的一种形式。此选项与我们的推导完全一致。\n- 结论：**正确**。\n\nB. ACF 从接近 $1$ 的值开始非常缓慢地正向衰减，这是近单位根自回归的特征；PACF 在滞后 1 阶处有一个大的正向尖峰，之后基本为 $0$。\n- ACF 描述：不正确。ACF 在滞后 1 阶后截尾且为负。缓慢衰减的正 ACF 是自回归部分具有单位根或近单位根的过程的特征，例如 $\\phi \\approx 1$ 的 AR($1$) 过程。\n- PACF 描述：不正确。PACF 是逐渐衰减的。PACF 中的单个尖峰是 AR 过程的特征。\n- 结论：**不正确**。\n\nC. ACF 在滞后 1 阶处显示一个接近 $+0.5$ 的显著正向尖峰，并且在大于 1 阶的滞后处基本为 $0$；PACF 逐渐衰减至 $0$。\n- ACF 描述：不正确。滞后 1 阶的尖峰是负的 ($-0.5$)，不是正的。一个正的尖峰会意味着一个像 $Y_t = u_t + u_{t-1}$ 这样的过程。\n- 结论：**不正确**。\n\nD. ACF 和 PACF 都在滞后 2 阶后截尾，表明这是一个只有两个非零依赖滞后阶数的短记忆过程。\n- ACF 描述：不正确。ACF 在滞后 1 阶后截尾，而不是 2 阶。\n- PACF 描述：不正确。PACF 是逐渐衰减的；它不截尾。\n- 结论：**不正确**。\n\nE. ACF 在多个滞后阶数上符号交替，并呈缓慢衰减的振荡；PACF 在滞后 1 阶处有一个大的负向尖峰，之后基本为 $0$。\n- ACF 描述：不正确。ACF 是截尾的。一个衰减、振荡的 ACF 是具有复数根的 AR($2$) 过程或具有负系数的 AR 过程的特征。\n- PACF 描述：不正确。PACF 是逐渐衰减的。PACF 中的单个尖峰是 AR($1$) 过程的特征。\n- 结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "理论知识最终需要应用于解决实际问题。这个综合性练习将指导你完成一个完整的端到端时间序列分析流程，从原始计数数据（模拟社交媒体话题热度）开始，经过方差稳定化、差分、模型拟合，最终通过残差分析来识别异常冲击。通过这个编码实践，你将把前面学到的概念整合起来，体验如何使用 $ARIMA(1,1,1)$ 模型从数据中提取有价值的信息。",
            "id": "3187631",
            "problem": "考虑一个表示单位时间内话题标签使用频率的离散时间计数过程 $\\{x_t\\}_{t=0}^{T-1}$。在许多实际案例中，计数数据可以被合理地近似为遵循一种类泊松机制，其中 $\\operatorname{Var}(x_t)$ 随 $\\operatorname{E}(x_t)$ 增长，这为建模前的方差稳定化提供了动机。设 $z_t$ 表示 $x_t$ 的方差稳定化变换，设 $w_t$ 表示用于为整合模型诱导平稳性的 $d$ 阶差分序列。\n\n基本定义与事实：\n- 如果对所有 $t$ 都有 $\\operatorname{E}(y_t) = \\mu$ 且 $\\operatorname{Cov}(y_t, y_{t+h})$ 仅取决于 $h$ 而不取决于 $t$，则时间序列 $\\{y_t\\}$ 是宽平稳的。\n- 滞后 $h$ 的自相关函数 (ACF) 为 $\\rho(h) = \\frac{\\operatorname{Cov}(y_t,y_{t+h})}{\\operatorname{Var}(y_t)}$。\n- $\\{x_t\\}$ 的 $(p,d,q)$ 阶自回归整合移动平均 (ARIMA) 模型意味着，经过 $d$ 次差分、可能经过变换的序列满足自回归移动平均 (ARMA)$(p,q)$ 动态：$w_t = \\mu + \\sum_{i=1}^{p}\\phi_i w_{t-i} + \\epsilon_t + \\sum_{j=1}^{q}\\theta_j \\epsilon_{t-j}$，其中 $\\{\\epsilon_t\\}$ 是白噪声，$\\epsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 对于类泊松计数，使用小常数 $c$ 的平方根变换 $z_t = \\sqrt{x_t + c}$ 可产生近似恒定的方差；通过德尔塔方法，对于大的 $\\lambda$，当 $X \\sim \\operatorname{Poisson}(\\lambda)$ 时，$\\operatorname{Var}(\\sqrt{X+c}) \\approx \\frac{1}{4}$。\n- 阶数 $d=1$ 的差分定义为 $w_t = z_t - z_{t-1}$ (对于 $t \\ge 1$) (并产生一个索引为 $t=1,\\dots,T-1$ 的序列)。原始序列在索引 $t^\\star$ 处的冲击表现为大的 $|w_{t^\\star}|$ 或 $|w_{t^\\star+1}|$，具体取决于变化的方向和持续性。\n\n任务：\n实现一个程序，对每个提供的测试用例，将话题标签频率视为计数时间序列，稳定方差，通过对差分序列进行条件高斯估计来拟合 ARIMA$(1,1,1)$ 模型（等价于对 $w_t$ 拟合一个 ARMA$(1,1)$ 模型），并将大的标准化残差评估为冲击。您的实现必须遵循以下源于第一性原理的建模步骤：\n\n1.  方差稳定化：给定计数 $x_t$，根据每个测试用例的指定，使用平方根变换 $z_t = \\sqrt{x_t + 0.5}$ 或对数变换 $z_t = \\log(x_t + 1)$ 生成 $z_t$。\n2.  差分：对于差分阶数 $d=1$，计算 $w_t = z_t - z_{t-1}$ (对于 $t=1,\\dots,T-1$)。\n3.  中心化：计算 $y_t = w_t - \\bar{w}$，其中 $\\bar{w}$ 是 $\\{w_t\\}$ 的样本均值，以与零均值的 ARMA$(1,1)$ 形式对齐。\n4.  高斯噪声下的条件平方和 ARMA$(1,1)$ 拟合：最小化平均平方新息\n    $$J(\\phi,\\theta) = \\frac{1}{N}\\sum_{t=0}^{N-1}\\epsilon_t^2,$$\n    使用递归\n    $$\\epsilon_t = y_t - \\phi y_{t-1} - \\theta \\epsilon_{t-1},$$\n    并使用初始条件 $y_{-1} = 0$ 和 $\\epsilon_{-1} = 0$。将 $\\phi,\\theta \\in (-1,1)$ 约束在 $(-1,1)$ 内，以在条件意义上尊重平稳性和可逆性。\n5.  残差标准化：通过 $\\hat{\\sigma}^2 = \\frac{1}{N}\\sum_{t=0}^{N-1}\\epsilon_t^2$ 估计 $\\sigma^2$，并计算标准化残差 $r_t = \\epsilon_t / \\hat{\\sigma}$。\n6.  冲击识别：使用指定的阈值 $T$ (无量纲)，只要差分序列中残差索引 $\\tau$ 的 $|r_\\tau| \\ge T$，就在原始索引 $t = \\tau + d$ 处声明一个冲击。报告冲击位置时使用从 0 开始的索引。\n\n测试套件：\n对于每个案例，完全按照规定生成计数时间序列 $\\{x_t\\}$，使用从 0 开始的索引和通过向下取整得到的整数计数。设 $\\lfloor\\cdot\\rfloor$ 表示底函数。\n\n- 案例 A (理想情况，中等计数，含两次冲击)：\n  - 长度 $T = 120$。\n  - 基线：$b_t = 20 + 5\\sin\\left(\\frac{2\\pi t}{20}\\right)$，对于 $t=0,\\dots,119$。\n  - 冲击：如果 $t \\in \\{30,75\\}$ 则 $s_t = 40$，否则 $s_t = 0$。\n  - 计数：$x_t = \\left\\lfloor b_t \\right\\rfloor + s_t$。\n  - 方差稳定化：平方根 $z_t = \\sqrt{x_t + 0.5}$。\n  - 差分阶数：$d=1$。\n  - 冲击阈值：$T = 3$。\n\n- 案例 B (边界情况，无冲击)：\n  - 长度 $T = 120$。\n  - 基线：$b_t = 25 + 3\\sin\\left(\\frac{2\\pi t}{30}\\right)$，对于 $t=0,\\dots,119$。\n  - 冲击：对所有 $t$，$s_t = 0$。\n  - 计数：$x_t = \\left\\lfloor b_t \\right\\rfloor$。\n  - 方差稳定化：平方根 $z_t = \\sqrt{x_t + 0.5}$。\n  - 差分阶数：$d=1$。\n  - 冲击阈值：$T = 3$。\n\n- 案例 C (边界条件，短序列，含一次冲击)：\n  - 长度 $T = 20$。\n  - 基线：$b_t = 15 + 2\\sin\\left(\\frac{2\\pi t}{15}\\right)$，对于 $t=0,\\dots,19$。\n  - 冲击：如果 $t=10$ 则 $s_t = 30$，否则 $s_t = 0$。\n  - 计数：$x_t = \\left\\lfloor b_t \\right\\rfloor + s_t$。\n  - 方差稳定化：平方根 $z_t = \\sqrt{x_t + 0.5}$。\n  - 差分阶数：$d=1$。\n  - 冲击阈值：$T = 3$。\n\n- 案例 D (高计数，对数稳定化，含一次冲击)：\n  - 长度 $T = 100$。\n  - 基线：$b_t = 200 + 10\\sin\\left(\\frac{2\\pi t}{25}\\right)$，对于 $t=0,\\dots,99$。\n  - 冲击：如果 $t=60$ 则 $s_t = 300$，否则 $s_t = 0$。\n  - 计数：$x_t = \\left\\lfloor b_t \\right\\rfloor + s_t$。\n  - 方差稳定化：对数 $z_t = \\log(x_t + 1)$。\n  - 差分阶数：$d=1$。\n  - 冲击阈值：$T = 3$。\n\n所需输出：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出检测到的冲击索引列表（使用从 0 开始的索引）。例如，最终输出必须是以下形式：\n$[\\,[\\text{案例 A 的索引}],\\,[\\text{案例 B 的索引}],\\,[\\text{案例 C 的索引}],\\,[\\text{案例 D 的索引}]\\,]$，\n每个内部列表仅由升序排列的整数组成。\n\n不涉及物理单位；阈值是无量纲的。三角函数中的角度通过 $\\sin$ 函数的参数构造，单位为弧度。所有报告的量必须是整数或整数列表。计算必须是确定性的，并且不需要生成随机数。",
            "solution": "问题陈述经过了细致的验证，并被确定为有效的。它科学地基于时间序列分析的既定原则，具有明确和确定性的指令集，问题设定良好，并且其表述是客观的。任务是使用 ARIMA(1,1,1) 模型实现一个检测计数时间序列中冲击的特定算法，这涉及方差稳定化、差分、参数估计和残差分析。\n\n解决方案将通过系统地遵循指定的建模步骤序列来构建。\n\n### 1. 时间序列生成与变换\n\n对于每个测试用例，都会生成一个长度为 $T$ 的离散时间计数过程 $\\{x_t\\}_{t=0}^{T-1}$。该过程由基线分量 $b_t$ 和冲击分量 $s_t$ 定义，使得时间 $t$ 的最终计数为 $x_t = \\lfloor b_t \\rfloor + s_t$。\n\n计数数据通常表现出异方差性，即方差是均值的函数。对于泊松过程，$\\operatorname{Var}(x_t) = \\operatorname{E}(x_t) = \\lambda_t$。为了满足许多时间序列模型的恒定方差假设，会应用方差稳定化变换。问题指定了两种此类变换：\n1.  **平方根变换：** $z_t = \\sqrt{x_t + c}$，其中 $c=0.5$。此变换的动机是德尔塔方法，该方法表明，对于均值为 $\\lambda$ 的泊松分布随机变量 $X$，对于较大的 $\\lambda$，$\\sqrt{X}$ 的方差近似为常数 ($\\approx 1/4$)。\n2.  **对数变换：** $z_t = \\log(x_t + 1)$。当数据的标准差与均值成正比时，此变换是有效的。\n\n得到的序列是 $\\{z_t\\}_{t=0}^{T-1}$。\n\n### 2. 平稳性诱导与中心化\n\nARIMA 中的“I”代表“整合的”（Integrated），意味着原始时间序列是非平稳的，但其差分序列是平稳的。通过对变换后的序列 $\\{z_t\\}$ 进行差分来诱导平稳性。对于差分阶数 $d=1$，新序列 $\\{w_t\\}$ 定义为：\n$$w_t = z_t - z_{t-1}, \\quad \\text{对于 } t = 1, \\dots, T-1$$\n此操作产生一个长度为 $N = T-1$ 的序列。原始索引 $t^\\star$ 处的冲击会在 $w_{t^\\star}$ 和 $w_{t^\\star+1}$ 中引入大数值。\n\nARMA 模型将拟合到一个零均值序列。因此，通过减去其样本均值 $\\bar{w}$ 来对序列 $\\{w_t\\}$ 进行中心化：\n$$y_\\tau = w_{\\tau+1} - \\bar{w}, \\quad \\text{对于 } \\tau = 0, \\dots, N-1$$\n其中 $\\bar{w} = \\frac{1}{N}\\sum_{t=1}^{T-1} w_t$。新序列 $\\{y_\\tau\\}_{\\tau=0}^{N-1}$ 的样本均值为零。请注意为了实现方便，将索引从 $t$ 重新标记为 $\\tau$，其中 $\\tau = t-1$。\n\n### 3. ARMA(1,1) 参数估计\n\n为平稳、中心化的序列 $\\{y_\\tau\\}$ 指定了一个自回归移动平均 ARMA(1,1) 模型。该模型由下式给出：\n$$y_\\tau = \\phi y_{\\tau-1} + \\epsilon_\\tau + \\theta \\epsilon_{\\tau-1}$$\n其中 $\\{\\epsilon_\\tau\\}$ 是一个白噪声过程，$\\epsilon_\\tau \\sim \\mathcal{N}(0, \\sigma^2)$，$\\phi$ 和 $\\theta$ 分别是自回归和移动平均参数。\n\n为了估计 $(\\phi, \\theta)$，我们使用条件平方和 (CSS) 方法。这涉及最小化一个代表均方新息（残差）的目标函数 $J(\\phi, \\theta)$。新息通过重新排列模型方程来定义：\n$$\\epsilon_\\tau = y_\\tau - \\phi y_{\\tau-1} - \\theta \\epsilon_{\\tau-1}$$\n要最小化的目标函数是：\n$$J(\\phi, \\theta) = \\frac{1}{N}\\sum_{\\tau=0}^{N-1}\\epsilon_\\tau^2$$\n该递归需要初始条件。按照规定，我们使用 $y_{-1} = 0$ 和 $\\epsilon_{-1} = 0$。那么第一个新息是 $\\epsilon_0 = y_0$。\n\n这是一个数值优化问题。我们寻求 $(\\hat{\\phi}, \\hat{\\theta})$ 使得：\n$$(\\hat{\\phi}, \\hat{\\theta}) = \\underset{\\phi, \\theta}{\\operatorname{argmin}} \\, J(\\phi, \\theta)$$\n优化在约束 $\\phi \\in (-1, 1)$ 和 $\\theta \\in (-1, 1)$ 下进行，这些是 ARMA 过程平稳性和可逆性的必要条件。数值求解器，如带箱型约束的拟牛顿法（例如 L-BFGS-B），适合此任务。\n\n### 4. 通过标准化残差进行冲击检测\n\n在获得最优参数 $(\\hat{\\phi}, \\hat{\\theta})$ 后，使用这些估计参数通过递归公式计算最终的残差序列 $\\{\\hat{\\epsilon}_\\tau\\}_{\\tau=0}^{N-1}$。这些残差代表了拟合的 ARMA 模型未能解释的数据部分。冲击或异常预计会表现为大幅值的残差。\n\n白噪声过程的方差 $\\sigma^2$ 使用平方残差的均值来估计：\n$$\\hat{\\sigma}^2 = \\frac{1}{N}\\sum_{\\tau=0}^{N-1}\\hat{\\epsilon}_\\tau^2$$\n请注意，$\\hat{\\sigma}^2$ 就是目标函数 $J(\\hat{\\phi}, \\hat{\\theta})$ 的最小值。估计的标准差是 $\\hat{\\sigma} = \\sqrt{\\hat{\\sigma}^2}$。\n\n然后将残差标准化以具有单位方差：\n$$r_\\tau = \\frac{\\hat{\\epsilon}_\\tau}{\\hat{\\sigma}}$$\n绝对值大的标准化残差表示相对于模型而言是离群点的点。\n\n最后一步是识别冲击位置。只要标准化残差的绝对值超过指定的无量纲阈值 $T_{\\text{thresh}}$，就声明存在冲击。也就是说，对于满足以下条件的每个残差索引 $\\tau$，检测到一个冲击：\n$$|r_\\tau| \\ge T_{\\text{thresh}}$$\n问题指定了一个规则，将残差索引 $\\tau$ 映射回原始时间序列索引 $t$。对于每个满足冲击条件的 $\\tau$，报告的相应原始索引为 $t = \\tau + d$。当差分阶数 $d=1$ 时，这变为：\n$$t = \\tau + 1$$\n每个测试用例的最终输出是这些检测到的冲击索引 $t$ 的排序列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef _process_case(case_params):\n    \"\"\"\n    Processes a single test case for shock detection in a time series.\n    \"\"\"\n    # Unpack parameters for the case\n    T_len, b_func, s_dict, transform_type, d_order, T_thresh = case_params\n\n    # 1. Generate the count time series {x_t}\n    t_series = np.arange(T_len)\n    baseline = b_func(t_series)\n    shocks = np.zeros(T_len)\n    for t_idx, val in s_dict.items():\n        shocks[t_idx] = val\n    x = np.floor(baseline) + shocks\n\n    # 2. Variance stabilization to get {z_t}\n    if transform_type == 'sqrt':\n        z = np.sqrt(x + 0.5)\n    elif transform_type == 'log':\n        z = np.log(x + 1)\n    else:\n        raise ValueError(\"Invalid transform type\")\n\n    # 3. Differencing to get {w_t}\n    if d_order != 1:\n        raise NotImplementedError(\"Only d=1 is implemented.\")\n    w = z[1:] - z[:-1]\n\n    # 4. Centering to get {y_t}\n    y = w - np.mean(w)\n    N = len(y)\n\n    # 5. ARMA(1,1) fitting by conditional sum-of-squares\n    def cost_function(params, y_data):\n        phi, theta = params\n        n_obs = len(y_data)\n        epsilons = np.zeros(n_obs)\n        \n        # Calculate residuals recursively\n        # Initial conditions y_{-1}=0, epsilon_{-1}=0 are implicit\n        \n        # for tau = 0\n        epsilons[0] = y_data[0] # from eps_0 = y_0 - phi*y_{-1} - theta*eps_{-1}\n        \n        # for tau = 1 to N-1\n        for tau in range(1, n_obs):\n            epsilons[tau] = y_data[tau] - phi * y_data[tau-1] - theta * epsilons[tau-1]\n            \n        return np.mean(epsilons**2)\n\n    # Use L-BFGS-B for optimization with bounds\n    initial_guess = [0.0, 0.0]\n    # Use bounds slightly inside (-1, 1) for stability\n    bnds = ((-0.999999, 0.999999), (-0.999999, 0.999999))\n    opt_result = minimize(cost_function, initial_guess, args=(y,), method='L-BFGS-B', bounds=bnds)\n    phi_hat, theta_hat = opt_result.x\n\n    # 6. Residual standardization\n    # Recalculate final residuals with optimal parameters\n    eps_hat = np.zeros(N)\n    eps_hat[0] = y[0]\n    for tau in range(1, N):\n        eps_hat[tau] = y[tau] - phi_hat * y[tau-1] - theta_hat * eps_hat[tau-1]\n\n    # Estimate sigma\n    sigma_hat_sq = np.mean(eps_hat**2)\n    sigma_hat = np.sqrt(sigma_hat_sq)\n\n    # Compute standardized residuals {r_t}\n    # Avoid division by zero if sigma_hat is very small\n    if sigma_hat  1e-9:\n        r = np.zeros(N)\n    else:\n        r = eps_hat / sigma_hat\n\n    # 7. Shock identification\n    # Find residual indices tau where |r_tau| >= T_thresh\n    shock_residual_indices = np.where(np.abs(r) >= T_thresh)[0]\n\n    # Convert residual indices back to original time series indices t = tau + d\n    shock_original_indices = [int(tau + d_order) for tau in shock_residual_indices]\n    \n    return sorted(shock_original_indices)\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        (120, \n         lambda t: 20 + 5 * np.sin(2 * np.pi * t / 20), \n         {30: 40, 75: 40}, \n         'sqrt', 1, 3),\n        # Case B\n        (120, \n         lambda t: 25 + 3 * np.sin(2 * np.pi * t / 30), \n         {}, \n         'sqrt', 1, 3),\n        # Case C\n        (20, \n         lambda t: 15 + 2 * np.sin(2 * np.pi * t / 15), \n         {10: 30}, \n         'sqrt', 1, 3),\n        # Case D\n        (100, \n         lambda t: 200 + 10 * np.sin(2 * np.pi * t / 25), \n         {60: 300}, \n         'log', 1, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        shock_indices = _process_case(case)\n        results.append(shock_indices)\n\n    # Final print statement in the exact required format.\n    # The str() of a list produces the required '[...]' format for inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}