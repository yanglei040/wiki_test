{
    "hands_on_practices": [
        {
            "introduction": "在我们能有效使用平滑样条之前，理解其计算原理至关重要。本练习将深入剖析拟合算法的内部机制，揭示样条方法为何不仅在理论上优美，而且即使在处理大量数据点时也具有计算上的可行性。通过推导正规方程的结构，你将发现一个关键的数学特性，正是这一特性使得高效的线性时间求解器成为可能。",
            "id": "3174213",
            "problem": "考虑一个闭区间 $[a,b]$ 上的一组严格递增的设计点 $\\{x_i\\}_{i=1}^{n}$ 和观测到的响应值 $\\{y_i\\}_{i=1}^{n}$。将平滑样条估计量 $\\hat{f}$ 定义为最小化惩罚经验风险的函数\n$$\n\\sum_{i=1}^{n}\\big(y_i-f(x_i)\\big)^{2}+\\lambda\\int_{a}^{b}\\big(f''(x)\\big)^{2}\\,dx\n$$\n该函数在 $[a,b]$ 上的自然三次样条类别中进行选择，其中 $\\lambda>0$ 是一个固定的平滑参数。使用一组自然三次样条基 $\\{B_j(x)\\}_{j=1}^{m}$（由包含不同点 $\\{x_i\\}$ 的节点序列构成，并满足自然边界条件 $f''(a)=f''(b)=0$），并将 $f$ 表示为 $f(x)=\\sum_{j=1}^{m}\\theta_j B_j(x)$，其系数向量为 $\\boldsymbol{\\theta}\\in\\mathbb{R}^{m}$。关于三次 B 样条基，以下经过充分验证的事实成立，并可加以使用：\n- 每个三次 B 样条基函数 $B_j$ 具有紧支集，最多跨越四个连续的节点区间。\n- 两个三次 B 样条基函数 $B_j$ 和 $B_k$ 的支集重叠，当且仅当 $|j-k|\\leq 3$。\n\n从这些基础出发，推导由该最小化问题所蕴含的关于 $\\boldsymbol{\\theta}$ 的正规方程组，并确定系数矩阵的稀疏性和块结构，这种结构使得可以使用带状求解法，其计算成本与 $n$ 呈线性关系。最后，确定最小的非负整数 $b$（半带宽），使得系数矩阵在宽度为 $2b+1$ 的中心带之外的元素均为零。\n\n你的最终答案必须是整数 $b$。无需四舍五入。",
            "solution": "问题要求解用于平滑样条估计量的正规方程组中系数矩阵的半带宽。我们首先用矩阵-向量表示法将问题形式化，然后分析所得矩阵的结构。\n\n平滑样条估计量 $\\hat{f}$ 最小化惩罚经验风险：\n$$\nS(f) = \\sum_{i=1}^{n}\\big(y_{i}-f(x_{i})\\big)^{2}+\\lambda\\int_{a}^{b}\\big(f''(x)\\big)^{2}\\,dx\n$$\n函数 $f$ 表示为自然三次样条基函数 $\\{B_j(x)\\}_{j=1}^{m}$ 的线性组合：\n$$\nf(x) = \\sum_{j=1}^{m}\\theta_{j}B_{j}(x) = \\mathbf{B}(x)^T \\boldsymbol{\\theta}\n$$\n其中 $\\mathbf{B}(x) = (B_1(x), \\dots, B_m(x))^T$ 是基函数向量，$\\boldsymbol{\\theta} = (\\theta_1, \\dots, \\theta_m)^T$ 是系数向量。\n\n让我们用 $\\boldsymbol{\\theta}$ 来表示目标函数 $S(f)$ 的两项。\n\n第一项是残差平方和 (RSS)。令 $\\mathbf{y} = (y_1, \\dots, y_n)^T$。函数 $f$ 在设计点 $x_i$ 处的值可以写成一个向量 $\\mathbf{f}_{\\mathbf{x}} = (f(x_1), \\dots, f(x_n))^T$。该向量可以表示为：\n$$\n\\mathbf{f}_{\\mathbf{x}} = \\mathbf{B} \\boldsymbol{\\theta}\n$$\n其中 $\\mathbf{B}$ 是 $n \\times m$ 的求值矩阵，其元素为 $B_{ij} = B_j(x_i)$。RSS 项则为：\n$$\n\\sum_{i=1}^{n}\\big(y_{i}-f(x_{i})\\big)^{2} = \\|\\mathbf{y} - \\mathbf{B}\\boldsymbol{\\theta}\\|_{2}^{2} = (\\mathbf{y} - \\mathbf{B}\\boldsymbol{\\theta})^T (\\mathbf{y} - \\mathbf{B}\\boldsymbol{\\theta})\n$$\n\n第二项是惩罚项，它依赖于 $f(x)$ 的二阶导数：\n$$\nf''(x) = \\frac{d^2}{dx^2} \\sum_{j=1}^{m}\\theta_{j}B_{j}(x) = \\sum_{j=1}^{m}\\theta_{j}B''_{j}(x)\n$$\n该积分可以写为：\n$$\n\\int_{a}^{b}\\big(f''(x)\\big)^{2}\\,dx = \\int_{a}^{b} \\left( \\sum_{j=1}^{m}\\theta_{j}B''_{j}(x) \\right) \\left( \\sum_{k=1}^{m}\\theta_{k}B''_{k}(x) \\right) dx = \\sum_{j=1}^{m}\\sum_{k=1}^{m} \\theta_j \\theta_k \\left( \\int_{a}^{b} B''_{j}(x) B''_{k}(x) dx \\right)\n$$\n这是关于 $\\boldsymbol{\\theta}$ 的二次型。我们定义 $m \\times m$ 的惩罚矩阵 $\\mathbf{\\Omega}$，其元素为：\n$$\n\\Omega_{jk} = \\int_{a}^{b} B''_{j}(x) B''_{k}(x) dx\n$$\n惩罚项可以写为 $\\boldsymbol{\\theta}^T \\mathbf{\\Omega} \\boldsymbol{\\theta}$。\n\n结合两项，需要关于 $\\boldsymbol{\\theta}$ 最小化的目标函数是：\n$$\nS(\\boldsymbol{\\theta}) = (\\mathbf{y} - \\mathbf{B}\\boldsymbol{\\theta})^T (\\mathbf{y} - \\mathbf{B}\\boldsymbol{\\theta}) + \\lambda \\boldsymbol{\\theta}^T \\mathbf{\\Omega} \\boldsymbol{\\theta}\n$$\n展开第一项得到 $S(\\boldsymbol{\\theta}) = \\mathbf{y}^T\\mathbf{y} - 2\\mathbf{y}^T\\mathbf{B}\\boldsymbol{\\theta} + \\boldsymbol{\\theta}^T\\mathbf{B}^T\\mathbf{B}\\boldsymbol{\\theta} + \\lambda \\boldsymbol{\\theta}^T \\mathbf{\\Omega} \\boldsymbol{\\theta}$。\n为了找到最小化器 $\\hat{\\boldsymbol{\\theta}}$，我们计算 $S(\\boldsymbol{\\theta})$ 关于 $\\boldsymbol{\\theta}$ 的梯度并令其为零。\n$$\n\\nabla_{\\boldsymbol{\\theta}} S(\\boldsymbol{\\theta}) = -2\\mathbf{B}^T\\mathbf{y} + 2\\mathbf{B}^T\\mathbf{B}\\boldsymbol{\\theta} + 2\\lambda\\mathbf{\\Omega}\\boldsymbol{\\theta}\n$$\n将梯度设为 $\\mathbf{0}$：\n$$\n-2\\mathbf{B}^T\\mathbf{y} + 2(\\mathbf{B}^T\\mathbf{B} + \\lambda\\mathbf{\\Omega})\\boldsymbol{\\theta} = \\mathbf{0}\n$$\n这就得到了系数向量 $\\boldsymbol{\\theta}$ 的正规方程组：\n$$\n(\\mathbf{B}^T\\mathbf{B} + \\lambda\\mathbf{\\Omega})\\boldsymbol{\\theta} = \\mathbf{B}^T\\mathbf{y}\n$$\n这个线性系统的系数矩阵是 $\\mathbf{M} = \\mathbf{B}^T\\mathbf{B} + \\lambda\\mathbf{\\Omega}$。问题要求我们确定这个矩阵 $\\mathbf{M}$ 的半带宽 $b$。这取决于 $\\mathbf{B}^T\\mathbf{B}$ 和 $\\mathbf{\\Omega}$ 的稀疏模式。\n\n我们使用所提供的关于三次 B 样条基函数的性质：\n1. 每个 $B_j$ 都有紧支集。\n2. 两个基函数 $B_j$ 和 $B_k$ 的支集重叠，当且仅当 $|j-k| \\leq 3$。\n\n让我们分析 $\\mathbf{\\Omega}$ 的结构。其第 $(j,k)$ 个元素是 $\\Omega_{jk} = \\int_{a}^{b} B''_{j}(x) B''_{k}(x) dx$。$B''_j(x)$ 的支集包含在 $B_j(x)$ 的支集之内。因此，如果 $B_j(x)$ 和 $B_k(x)$ 的支集不相交，那么 $B''_j(x)$ 和 $B''_k(x)$ 的支集也不相交。在这种情况下，被积函数 $B''_j(x) B''_k(x)$ 恒为零，于是 $\\Omega_{jk}=0$。根据给定的性质，$B_j$ 和 $B_k$ 的支集在 $|j-k| > 3$ 时不相交。因此，当 $|j-k| > 3$ 时，$\\Omega_{jk} = 0$。这意味着 $\\mathbf{\\Omega}$ 是一个半带宽为 $3$ 的带状矩阵。\n\n接下来，我们分析 $\\mathbf{B}^T\\mathbf{B}$ 的结构。其第 $(j,k)$ 个元素是：\n$$\n(\\mathbf{B}^T\\mathbf{B})_{jk} = \\sum_{i=1}^{n} B_{ij}^T B_{ik} = \\sum_{i=1}^{n} B_j(x_i) B_k(x_i)\n$$\n要使和中的任意一项 $B_j(x_i) B_k(x_i)$ 不为零，则 $B_j(x_i)$ 和 $B_k(x_i)$ 都必须不为零。这只可能在点 $x_i$ 位于 $B_j$ 和 $B_k$ 支集的交集内时发生。如果 $B_j$ 和 $B_k$ 的支集不相交，则不存在这样的 $x_i$，和将为零。再次利用给定的性质，当 $|j-k| > 3$ 时，支集不相交。因此，当 $|j-k| > 3$ 时，$(\\mathbf{B}^T\\mathbf{B})_{jk} = 0$。所以，$\\mathbf{B}^T\\mathbf{B}$ 也是一个半带宽为 $3$ 的带状矩阵。\n\n系数矩阵是 $\\mathbf{M} = \\mathbf{B}^T\\mathbf{B} + \\lambda\\mathbf{\\Omega}$。$\\mathbf{M}$ 的第 $(j,k)$ 个元素是 $M_{jk} = (\\mathbf{B}^T\\mathbf{B})_{jk} + \\lambda \\Omega_{jk}$。\n如果 $|j-k| > 3$，则 $(\\mathbf{B}^T\\mathbf{B})_{jk}=0$ 和 $\\Omega_{jk}=0$ 都成立。因此，当 $|j-k| > 3$ 时，$M_{jk}=0$。这就确定了 $\\mathbf{M}$ 的半带宽最多为 $3$。\n\n为确认半带宽不小于 $3$，我们必须检查当 $|j-k|=3$ 时元素是否可以为非零。让我们考虑 $M_{j, j+3}$。$B_j$ 和 $B_{j+3}$ 的支集是重叠的。对于一个典型的节点序列，这个重叠区域是一个非空区间，并且 $B_j(x)$ 和 $B_{j+3}(x)$（以及它们的二阶导数）在这个区间内都是非零的。因此，通常情况下 $\\Omega_{j, j+3} = \\int B''_j(x)B''_{j+3}(x)dx \\neq 0$。类似地，如果有任何数据点 $x_i$ 落入这个重叠区域，那么 $(\\mathbf{B}^T\\mathbf{B})_{j, j+3}$ 将为非零。由于 $\\lambda > 0$，不能保证这两项会相互抵消。一般而言，$M_{j, j+3} \\neq 0$。\n\n因此，使得对于所有满足 $|j-k|>b$ 的 $j,k$ 都有 $M_{jk}=0$ 的最小非负整数 $b$ 是 $3$。矩阵 $\\mathbf{M}$ 是一个对称带状矩阵，其总带宽为 $2b+1 = 2(3)+1 = 7$（即，它是一个七对角矩阵）。\n\n使用带状求解器（如带状 Cholesky 分解）求解这样一个 $m \\times m$ 的带状矩阵线性系统的计算成本为 $O(m b^2)$。考虑到基函数的数量 $m$ 通常与数据点的数量 $n$ 成正比（通常 $m \\approx n$），其成本为 $O(n \\cdot 3^2) = O(n)$，与 $n$ 呈线性关系。这与问题的陈述相符。\n\n半带宽是 $b=3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "平滑样条的性能不仅取决于所选的平滑参数 $\\lambda$，还受到数据点空间分布的显著影响。本练习旨在通过研究“等价核”这一概念，帮助你建立关于平滑器在不同数据区域行为方式的直观理解。通过对“对抗性”数据布局的实验，你将观察到数据点的聚集和稀疏如何影响估计器的偏差，并可能导致不希望出现的振荡。",
            "id": "3174196",
            "problem": "给定一个在惩罚最小二乘框架下的平滑样条问题。目标是分析当设计点被对抗性地放置以引发振荡时，等价核的行为以及由此产生的偏差。所有工作都在一维区间 $[0,1]$ 上进行。\n\n从以下基本基础出发：在有限设计点集 $\\{x_i\\}_{i=0}^{n-1}$ 上的平滑样条估计量 $\\hat{\\mathbf{f}}$ 是通过最小化以下惩罚目标函数得到的\n$$\n\\sum_{i=0}^{n-1} \\left( y_i - f(x_i) \\right)^2 \\;+\\; \\lambda \\int_{0}^{1} \\left( f''(t) \\right)^2 \\, dt,\n$$\n其中 $\\lambda > 0$ 是一个固定的平滑参数，$f''$ 表示二阶导数。在非均匀设计点上的离散近似中，使用非均匀有限差分格式来近似内部点的二阶导数：\n$$\nf''(x_i) \\approx \\frac{2}{h_i + h_{i-1}} \\left( \\frac{f_{i+1} - f_i}{h_i} - \\frac{f_i - f_{i-1}}{h_{i-1}} \\right), \\quad i = 1,2,\\dots,n-2,\n$$\n其中 $h_i = x_{i+1} - x_i$ 且 $f_i := f(x_i)$。使用类梯形权重 $w_i = \\frac{1}{2}(h_{i-1} + h_i)$，通过加权和来近似该积分。令 $\\mathbf{D}$ 为一个 $(n-2) \\times n$ 矩阵，它编码了线性映射 $\\mathbf{r} = \\mathbf{D}\\mathbf{f}$，其分量为\n$$\nr_i \\;=\\; a_i f_{i-1} + b_i f_i + c_i f_{i+1}, \\quad\na_i = \\frac{2}{(h_i + h_{i-1}) h_{i-1}}, \\quad\nb_i = -\\frac{2}{h_i + h_{i-1}}\\left(\\frac{1}{h_{i}}+\\frac{1}{h_{i-1}}\\right), \\quad\nc_i = \\frac{2}{(h_i + h_{i-1}) h_{i}},\n$$\n并令 $\\mathbf{W}$ 为一个 $(n-2) \\times (n-2)$ 的对角矩阵，其对角线元素为 $w_i$。那么离散惩罚项可以写为 $\\mathbf{f}^\\top \\mathbf{Q} \\mathbf{f}$，其中 $\\mathbf{Q} = \\mathbf{D}^\\top \\mathbf{W} \\mathbf{D}$。在设计点上的最终估计量是以下线性系统的唯一解\n$$\n\\left( \\mathbf{I}_n + \\lambda \\mathbf{Q} \\right) \\hat{\\mathbf{f}} \\;=\\; \\mathbf{y},\n$$\n其中 $\\mathbf{I}_n$ 是 $n \\times n$ 的单位矩阵，$\\mathbf{y}$ 是观测向量。这定义了一个线性平滑器，其等价核矩阵为\n$$\n\\mathbf{S}_\\lambda \\;=\\; \\left( \\mathbf{I}_n + \\lambda \\mathbf{Q} \\right)^{-1},\n$$\n因此 $\\hat{\\mathbf{f}} = \\mathbf{S}_\\lambda \\mathbf{y}$。考虑无噪声情况 $\\mathbf{y} = \\mathbf{f}^{\\star}$，其中 $f^{\\star}(x)$ 是已知的平滑真实函数，因此点态偏差为 $\\hat{f}(x_i) - f^{\\star}(x_i)$。\n\n您的任务是构建对抗性设计，以在 $\\mathbf{S}_\\lambda$ 的行（在设计点上评估的等价核）中引发振荡行为，并在固定的 $\\lambda$ 下凭经验证明偏差的最坏情况区域。振荡可以通过计算核函数某一行中的符号变化次数来量化。\n\n请使用固定的 $\\lambda$ 和固定的真实函数 $f^{\\star}(x)$ 实现以下测试套件：\n\n- 全局参数：\n  - 定义域： $[0,1]$。\n  - 点数： $n = 51$。\n  - 平滑参数： $\\lambda = 10^{-4}$。\n  - 真实函数： $f^{\\star}(x) = \\sin(6\\pi x)$。\n\n- 测试用例（每个用例定义设计点 $\\{x_i\\}_{i=0}^{n-1}$）：\n  1. 均匀网格（理想情况）：$x_i = \\frac{i}{n-1}$，其中 $i = 0,1,\\dots,n-1$。\n  2. 大小间隙交替（对抗性振荡）：使用连续的区间，这些区间在小间隙 $h_s = 0.005$ 和大间隙 $h_b$ 之间交替，选择 $h_b$ 以使总长度为 1。具体来说，由于有 $n-1 = 50$ 个区间和 25 对，设置 $h_b = \\frac{1}{25} - h_s$，并定义 $x_0 = 0$ 和 $x_{i+1} = x_i + h_i$，其中 $h_i$ 以 $h_s, h_b, h_s, h_b, \\dots$ 的方式交替。\n  3. 中心聚集（在 $x = 0.5$ 附近的对抗性聚集）：从均匀参数 $u_i = \\frac{i}{n-1}$ 开始，并通过 $x_i = \\frac{1}{2} + \\frac{\\tanh\\left(\\alpha(u_i - \\frac{1}{2})\\right)}{2 \\tanh(\\alpha/2)}$ 进行映射，其中 $\\alpha = 3$。\n  4. 左边界聚集（在 $x = 0$ 附近的对抗性聚集）：设置 $x_i = u_i^{\\gamma}$，其中 $u_i = \\frac{i}{n-1}$ 且 $\\gamma = 3$。\n\n对于每个测试用例，计算：\n- 在设计点上的估计量 $\\hat{\\mathbf{f}} = \\mathbf{S}_\\lambda \\mathbf{f}^{\\star}$。\n- 绝对偏差向量 $\\mathbf{b}$，其分量为 $b_i = \\left|\\hat{f}(x_i) - f^{\\star}(x_i)\\right|$。\n- 识别具有最大绝对偏差的索引 $i^{\\star}$，如果出现平局，则取最小的索引。\n- 令 $\\mathbf{k}^{(i^{\\star})}$ 表示 $\\mathbf{S}_\\lambda$ 的第 $i^{\\star}$ 行。计算 $\\mathbf{k}^{(i^{\\star})}$ 中连续条目的符号变化次数，将零视为无符号且不计入符号变化。\n\n您的程序应为每个测试用例输出一个三元组，包括：\n- 位置 $x_{i^{\\star}}$。\n- 最大绝对偏差 $\\max_i b_i$。\n- $\\mathbf{k}^{(i^{\\star})}$ 中符号变化的整数计数。\n\n格式和数值规范：\n- 将前两个量报告为四舍五入到 $6$ 位小数的浮点数，将最后一个量报告为整数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，其中每个测试用例的结果本身就是按所述顺序排列的列表。例如，一个有效的输出格式是 $[[x_1,b_1,c_1],[x_2,b_2,c_2],[x_3,b_3,c_3],[x_4,b_4,c_4]]$，其中每个 $x_k$ 和 $b_k$ 四舍五入到 $6$ 位小数，而 $c_k$ 是一个整数。",
            "solution": "用户提供了一个有效的问题陈述。\n\n### 问题验证\n\n1.  **提取给定条件**：\n    -   目标函数：$\\sum_{i=0}^{n-1} ( y_i - f(x_i) )^2 + \\lambda \\int_{0}^{1} ( f''(t) )^2 \\, dt$。\n    -   $x_i$ 处的离散二阶导数：$f''(x_i) \\approx \\frac{2}{h_i + h_{i-1}} ( \\frac{f_{i+1} - f_i}{h_i} - \\frac{f_i - f_{i-1}}{h_{i-1}} )$，其中 $i=1, \\dots, n-2$。\n    -   惩罚矩阵：$\\mathbf{Q} = \\mathbf{D}^\\top \\mathbf{W} \\mathbf{D}$，其中 $\\mathbf{D}$ 编码离散二阶导数算子，$\\mathbf{W}$ 是权重为 $w_i = \\frac{1}{2}(h_{i-1} + h_i)$ 的对角矩阵。\n    -   平滑器解：$\\hat{\\mathbf{f}} = (\\mathbf{I}_n + \\lambda \\mathbf{Q})^{-1} \\mathbf{y}$。\n    -   等价核：$\\mathbf{S}_\\lambda = (\\mathbf{I}_n + \\lambda \\mathbf{Q})^{-1}$。\n    -   全局参数：$n=51$，$\\lambda=10^{-4}$，定义域 $[0,1]$，真实函数 $f^{\\star}(x) = \\sin(6\\pi x)$。\n    -   用于生成设计点 $\\{x_i\\}_{i=0}^{n-1}$ 的四个测试用例：均匀、大小间隙交替、中心聚集和左边界聚集。\n    -   每个案例的所需输出：最大偏差位置 $x_{i^{\\star}}$、最大偏差值 $\\max_i |\\hat{f}(x_i) - f^\\star(x_i)|$ 以及核函数行 $\\mathbf{k}^{(i^{\\star})}$ 中的符号变化次数。\n\n2.  **使用提取的给定条件进行验证**：\n    -   **科学依据**：该问题是将数值方法应用于平滑样条统计问题的标准应用。有限差分格式、惩罚项公式以及由此产生的线性平滑器都是成熟的概念。\n    -   **适定性**：对于 $\\lambda > 0$，矩阵 $(\\mathbf{I}_n + \\lambda \\mathbf{Q})$ 是一个正定单位矩阵和一个半正定矩阵 $\\lambda\\mathbf{Q}$ 的和。因此，它是正定的并且可逆，从而保证了唯一解的存在。\n    -   **完整性和一致性**：所有必要的参数、公式和测试用例规范均已提供，并且在数学上是一致的。\n\n3.  **结论和行动**：问题是有效的。将提供一个合理的解决方案。\n\n### 基于原理的解决方案\n\n此问题的解决方案涉及实现一维平滑样条的离散近似，并分析其在数据点不同空间分布下的属性。其核心原理是，在一组设计点 $\\mathbf{x} = (x_0, \\dots, x_{n-1})^\\top$ 上的平滑样条估计量 $\\hat{\\mathbf{f}}$ 对观测数据向量 $\\mathbf{y}$ 进行线性变换，使得 $\\hat{\\mathbf{f}} = \\mathbf{S}_\\lambda \\mathbf{y}$。矩阵 $\\mathbf{S}_\\lambda$ 被称为平滑矩阵或等价核。该矩阵的行 $\\mathbf{k}^{(i)}$ 决定了在单一点 $\\hat{f}(x_i)$ 上的估计值是如何通过所有观测值的加权平均构建的，即 $\\hat{f}(x_i) = \\sum_{j=0}^{n-1} S_{\\lambda,ij} y_j$。这些行（“等价核”）的形状揭示了平滑器的行为。对抗性的点放置会扭曲这些核函数，导致诸如高偏差等不良的统计特性。\n\n分步实现过程如下：\n\n1.  **生成设计点**：对于四个测试用例中的每一个，我们首先根据指定规则在区间 $[0,1]$ 上生成包含 $n=51$ 个设计点的向量 $\\mathbf{x}$。\n\n2.  **构建惩罚矩阵 $\\mathbf{Q}$**：惩罚项 $\\lambda \\int (f'')^2 dt$ 被离散化为 $\\lambda \\mathbf{f}^\\top \\mathbf{Q} \\mathbf{f}$。构建 $\\mathbf{Q}$ 需要两个中间矩阵 $\\mathbf{D}$ 和 $\\mathbf{W}$。\n    -   计算间距 $h_i = x_{i+1} - x_i$，其中 $i=0, \\dots, n-2$。\n    -   构建 $(n-2) \\times n$ 矩阵 $\\mathbf{D}$。其第 $j$ 行（$j=0, \\dots, n-3$）包含在内部点 $x_i$（其中 $i=j+1$）处二阶导数的有限差分近似的系数。第 $j$ 行的非零项位于第 $i-1$、$i$ 和 $i+1$ 列。这些系数取决于 $h_{i-1}$ 和 $h_i$。\n    -   构建 $(n-2) \\times (n-2)$ 的对角矩阵 $\\mathbf{W}$。其第 $j$ 个对角元素是在点 $x_i$（同样 $i=j+1$）处用于类梯形积分规则的权重 $w_{i} = \\frac{1}{2}(h_{i-1} + h_i)$。\n    -   然后通过矩阵乘法计算惩罚矩阵 $\\mathbf{Q}$：$\\mathbf{Q} = \\mathbf{D}^\\top \\mathbf{W} \\mathbf{D}$。\n\n3.  **计算等价核 $\\mathbf{S}_\\lambda$**：平滑矩阵是矩阵 $(\\mathbf{I}_n + \\lambda \\mathbf{Q})$ 的逆。我们构建这个 $n \\times n$ 矩阵并计算其逆以获得 $\\mathbf{S}_\\lambda$。该矩阵是对称且正定的。\n\n4.  **分析偏差和核振荡**：对于每种情况，我们在无噪声设置下分析平滑器的性能，其中观测值为真实函数值 $\\mathbf{y} = \\mathbf{f}^\\star$，且 $f^\\star(x) = \\sin(6\\pi x)$。\n    -   平滑后的估计值为 $\\hat{\\mathbf{f}} = \\mathbf{S}_\\lambda \\mathbf{f}^\\star$。\n    -   绝对偏差向量计算为 $\\mathbf{b} = |\\hat{\\mathbf{f}} - \\mathbf{f}^\\star|$。\n    -   我们识别出索引 $i^\\star = \\arg\\max_i b_i$ 并记录相应的位置 $x_{i^\\star}$ 和最大偏差值 $b_{i^\\star}$。\n    -   提取 $\\mathbf{S}_\\lambda$ 的第 $i^\\star$ 行，记为 $\\mathbf{k}^{(i^\\star)}$。\n    -   为量化其振荡特性，我们计算 $\\mathbf{k}^{(i^\\star)}$ 中连续非零元素的符号变化的次数。这通过滤除零项，然后计算剩余序列中相邻符号差异的次数来完成。\n\n对四个指定的设计点分布中的每一个重复此过程，并为每个分布收集所要求的三元组结果（$x_{i^\\star}$、$\\max_i b_i$、符号变化次数）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Implements the smoothing spline analysis for four adversarial design cases.\n    \"\"\"\n    n = 51\n    lambda_val = 1e-4\n\n    def f_star(x):\n        \"\"\"The true underlying function.\"\"\"\n        return np.sin(6 * np.pi * x)\n\n    def generate_design_points(n_pts, params):\n        \"\"\"Generates the design points x for a given test case.\"\"\"\n        n_intervals = n_pts - 1\n        \n        if params['type'] == 'uniform':\n            return np.linspace(0, 1, n_pts)\n        \n        elif params['type'] == 'alternating':\n            h_s = params['h_s']\n            num_pairs = n_intervals // 2\n            h_b = (1.0 / num_pairs) - h_s\n            \n            x = np.zeros(n_pts)\n            gaps = [h_s, h_b] * num_pairs\n            \n            current_x = 0.0\n            x[0] = 0.0\n            for i in range(n_intervals):\n                current_x += gaps[i]\n                x[i+1] = current_x\n            return x\n\n        elif params['type'] == 'center_cluster':\n            alpha = params['alpha']\n            u = np.linspace(0, 1, n_pts)\n            numerator = np.tanh(alpha * (u - 0.5))\n            denominator = 2.0 * np.tanh(alpha / 2.0)\n            if np.isclose(denominator, 0): # Avoid division by zero\n                return u\n            return 0.5 + numerator / denominator\n\n        elif params['type'] == 'left_cluster':\n            gamma = params['gamma']\n            u = np.linspace(0, 1, n_pts)\n            return u ** gamma\n        \n        else:\n            raise ValueError(\"Unknown test case type\")\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'uniform'},\n        {'type': 'alternating', 'h_s': 0.005},\n        {'type': 'center_cluster', 'alpha': 3.0},\n        {'type': 'left_cluster', 'gamma': 3.0}\n    ]\n    \n    all_results = []\n    for params in test_cases:\n        # 1. Generate design points\n        x = generate_design_points(n, params)\n        \n        # 2. Construct matrices D and W\n        h = np.diff(x)\n        \n        D = np.zeros((n - 2, n))\n        W_diag = np.zeros(n - 2)\n        \n        for i in range(1, n - 1): # Iterate over interior points\n            j = i - 1 # Matrix row index\n            \n            h_im1 = h[i-1]\n            h_i   = h[i]\n            \n            common_denom = h_i + h_im1\n            \n            # Coefficients from finite difference formula for f''(x_i)\n            a_i = 2.0 / (common_denom * h_im1)\n            b_i = -2.0 * (1.0/h_i + 1.0/h_im1) / common_denom\n            c_i = 2.0 / (common_denom * h_i)\n            \n            D[j, i-1] = a_i\n            D[j, i]   = b_i\n            D[j, i+1] = c_i\n            \n            # Trapezoidal-like weight w_i\n            w_i = 0.5 * common_denom\n            W_diag[j] = w_i\n            \n        W = np.diag(W_diag)\n        \n        # 3. Construct penalty matrix Q and system matrix A\n        Q = D.T @ W @ D\n        A = np.identity(n) + lambda_val * Q\n        \n        # 4. Calculate equivalent kernel S_lambda\n        S_lambda = inv(A)\n        \n        # 5. Perform analysis\n        y_true = f_star(x)\n        f_hat = S_lambda @ y_true\n        \n        bias = np.abs(f_hat - y_true)\n        \n        i_star = np.argmax(bias)\n        max_bias = bias[i_star]\n        x_istar = x[i_star]\n        \n        k_istar_row = S_lambda[i_star, :]\n        \n        # Count sign changes in the kernel row\n        signs = np.sign(k_istar_row)\n        nonzero_indices = np.where(signs != 0)[0]\n        \n        if len(nonzero_indices)  2:\n            sign_changes = 0\n        else:\n            signs_nonzero = signs[nonzero_indices]\n            sign_changes = np.sum(signs_nonzero[:-1] != signs_nonzero[1:])\n        \n        all_results.append([x_istar, max_bias, sign_changes])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in all_results:\n        x_str = f\"{res[0]:.6f}\"\n        b_str = f\"{res[1]:.6f}\"\n        c_str = f\"{res[2]}\"\n        formatted_results.append(f\"[{x_str},{b_str},{c_str}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "自然三次样条的一个关键特性是，它会在训练数据范围之外进行线性外插。虽然这是一个合理的默认行为，但当我们知道真实函数具有紧支集时，这种外插可能会产生不符合物理实际的“人工尾部”。本练习将演示这一常见问题，并检验一种实用的修正方法：在边界处添加带权重的“锚点”，以引导样条函数展现出正确的行为。",
            "id": "3174194",
            "problem": "您的任务是研究当真实回归函数具有紧支集时，三次平滑样条的表现，并量化边界线性外推是否会引入人为尾部。研究必须从平滑样条作为罚化最小二乘泛函的最小化子的定义开始。具体而言，考虑二阶可微函数的空间和基本变分公式：对于给定的观测值 $\\{(x_i, y_i)\\}_{i=1}^n$ 和非负权重 $\\{w_i\\}_{i=1}^n$，平滑样条估计量 $\\hat{f}$ 定义为目标函数在所有函数 $f$ 上的最小化子\n$$\nJ[f] = \\sum_{i=1}^n w_i^2 \\left(y_i - f(x_i)\\right)^2 + \\lambda \\int_{a}^{b} \\left(f''(t)\\right)^2 \\, dt,\n$$\n其中 $\\lambda \\ge 0$ 控制平滑度，$[a,b]$ 是训练域。对于具有自然边界条件的三次平滑样条，所得到的 $\\hat{f}$ 是一个自然三次样条，它在 $[a,b]$ 之外进行线性外推。当真实函数具有紧支集时，这种线性外推会引入人为尾部。\n\n构建一个程序，以完全确定的方式实现以下协议。\n\n1) 数据生成过程。\n- 定义具有紧支集的真实目标函数 $f^\\star(x)$ 如下：\n$$\nf^\\star(x) = \\max\\left(0, 1 - |x|\\right),\n$$\n其支集为 $[-1,1]$。\n- 定义一个确定性的加性扰动 $\\varepsilon(x)$ 如下：\n$$\n\\varepsilon(x) = 0.05 \\sin(13 x) + 0.02 \\cos(7 x),\n$$\n其中角度以弧度为单位。\n- 将训练输入网格 $\\{x_i\\}_{i=1}^n$ 定义为在 $[-1.2, 1.2]$ 上的 $n$ 个等距点，其中 $n = 481$。定义响应值 $y_i = f^\\star(x_i) + \\varepsilon(x_i)$。\n\n2) 基线平滑样条。\n- 使用单位权重，将三次平滑样条 $\\hat{f}_{\\text{base}}$ 拟合到 $\\{(x_i, y_i)\\}$，平滑因子由下述测试套件选择。使用三次平滑样条公式所隐含的标准自然边界条件。\n\n3) 边界节点补救法。\n- 通过在已知支集边缘添加高置信度边界锚点来形成一个增广数据集，以抑制边界线性外推产生非零尾部。具体来说，在以下位置添加四个锚点\n$$\nx = -1.000,\\quad x = -1.000 + 10^{-3},\\quad x = 1.000 - 10^{-3},\\quad x = 1.000,\n$$\n其响应值固定为 $0$。为原始的 $n$ 个训练点分配单位权重，并为四个锚点中的每一个分配一个较大的权重 $W = 1000$。使用与基线相同的平滑因子，将三次平滑样条 $\\hat{f}_{\\text{anch}}$ 拟合到这个增广加权数据集。\n\n4) 尾部度量。\n- 为了量化超出观测范围的线性外推所导致的人为尾部，在训练域之外未用于拟合的尾部区域上评估每个拟合函数。将两个不相交的尾部区间定义为 $[-1.8, -1.2]$ 和 $[1.2, 1.8]$。在每个尾部区间上，采样 $M = 301$ 个等距点，并定义大小为 $2M$ 的聚合尾部网格。对于任何拟合函数 $\\hat{f}$，定义其尾部幅度\n$$\nT(\\hat{f}) = \\frac{1}{2M}\\sum_{j=1}^{2M} \\left| \\hat{f}(z_j) \\right|,\n$$\n其中 $\\{z_j\\}_{j=1}^{2M}$ 是从两个区间连接而来的尾部网格点。\n\n5) 输出度量。\n- 对于每个测试用例，计算比率\n$$\nR = \\frac{T\\left(\\hat{f}_{\\text{anch}}\\right)}{T\\left(\\hat{f}_{\\text{base}}\\right)},\n$$\n并约定如果 $T\\left(\\hat{f}_{\\text{base}}\\right)$ 等于 $0$，则将分母替换为 $\\max\\left(T\\left(\\hat{f}_{\\text{base}}\\right), 10^{-12}\\right)$ 以避免除以零。\n\n测试套件：\n- 使用以下平滑因子（上述目标函数中的第二项由三次平滑样条例程实现的平滑因子控制；每个值都产生保真度与平滑度之间的不同权衡）：\n    - 情况 A：$s = 0.05$。\n    - 情况 B：$s = 0.5$。\n    - 情况 C：$s = 2.0$。\n\n对于每种情况，运行步骤 $1$–$5$ 并将比率 $R$ 记录为浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个比率 $[R_A, R_B, R_C]$，形式为用方括号括起来的逗号分隔列表。每个比率必须精确到小数点后六位。例如，输出格式必须如下所示\n$$\n[\\;0.123456,0.234567,0.345678\\;].\n$$\n不得打印任何其他文本。",
            "solution": "该问题要求对三次平滑样条产生人为尾部的现象进行定量分析，并提出一种使用边界锚点的补救方法。验证过程确认了该问题在科学上是合理的、适定的，并且所有必要组成部分都得到了明确定义。因此，该问题是有效的。我们继续执行求解协议。\n\n三次平滑样条 $\\hat{f}$ 背后的基本原理是最小化一个罚化平方和：\n$$\nJ[f] = \\sum_{i=1}^n w_i^2 \\left(y_i - f(x_i)\\right)^2 + \\lambda \\int_{a}^{b} \\left(f''(t)\\right)^2 \\, dt\n$$\n第一项衡量对带权重 $\\{w_i\\}_{i=1}^n$ 的数据 $\\{(x_i, y_i)\\}_{i=1}^n$ 的保真度，而第二项则惩罚粗糙度，该粗糙度由二阶导数平方的积分来衡量。参数 $\\lambda \\ge 0$ 控制着这种权衡。在自然边界条件 $f''(a) = 0$ 和 $f''(b) = 0$ 下，这个变分问题的解是一个自然三次样条。这种样条的一个关键特性是，它在由数据定义的区间 $[a, b]$ 之外进行线性外推。当真实函数具有紧支集时，这种线性外推会引入不符合物理实际的非零尾部。\n\n实现将遵循指定的步骤，使用为此目的设计的 `scipy.interpolate.UnivariateSpline` 函数。该函数使用一个与 $\\lambda$ 相关的平滑因子 $s$；它找到样条 $f$，该样条在约束条件 $\\sum_i w_i^2 (y_i - f(x_i))^2 \\le s$ 下，最小化 $\\int (f''(t))^2 dt$。\n\n**步骤 1：数据生成过程**\n我们首先以确定性的方式定义用于生成合成数据的组件。\n真实回归函数是一个三角形或“帐篷”函数 $f^\\star(x)$，其紧支集在 $[-1, 1]$ 上：\n$$\nf^\\star(x) = \\max(0, 1 - |x|)\n$$\n一个确定性的高频扰动 $\\varepsilon(x)$ 被添加到真实函数中以模拟噪声：\n$$\n\\varepsilon(x) = 0.05 \\sin(13x) + 0.02 \\cos(7x)\n$$\n训练数据由 $n=481$ 个点组成。输入 $\\{x_i\\}$ 是在区间 $[-1.2, 1.2]$ 上生成的等距网格。相应的响应值 $\\{y_i\\}$ 计算如下：\n$$\ny_i = f^\\star(x_i) + \\varepsilon(x_i)\n$$\n这个 $x_i$ 值的网格有意地延伸到了 $f^\\star(x)$ 的支集之外。\n\n**步骤 2：基线平滑样条**\n对于测试套件 $\\{0.05, 0.5, 2.0\\}$ 中的每个平滑因子 $s$，我们首先拟合一个基线三次平滑样条 $\\hat{f}_{\\text{base}}$。这是通过将 `UnivariateSpline` 应用于具有单位权重（即对所有 $i$，$w_i=1$）的训练数据 $\\{(x_i, y_i)\\}_{i=1}^{481}$ 来完成的。该函数将在数据区间 $[-1.2, 1.2]$ 之外进行线性外推。由于当 $|x_i|  1$ 时，观测值 $y_i$ 因扰动 $\\varepsilon(x_i)$ 而非零，因此样条在边界 $x=\\pm 1.2$ 处很可能具有非零斜率，从而导致显著的人为尾部。\n\n**步骤 3：边界节点补救法**\n为了抵消线性外推造成的人为现象，我们实施了所提出的边界节点补救法。我们通过在 $f^\\star(x)$ 的已知支集边缘添加四个锚点来构建一个增广数据集。这些点是：\n$$\n(-1.000, 0), \\quad (-1.000 + 10^{-3}, 0), \\quad (1.000 - 10^{-3}, 0), \\quad (1.000, 0)\n$$\n这些锚点作为高置信度的陈述，表明函数在其支集边界处及附近应为零。为强制执行此点，它们被赋予一个很大的权重 $W=1000$，而原始的 $n=481$ 个数据点保留其单位权重。使用与相应基线模型相同的平滑因子 $s$，将一个新的三次平滑样条 $\\hat{f}_{\\text{anch}}$ 拟合到这个组合加权数据集。锚点上的大权重将强烈惩罚在这些位置上与 $0$ 的任何偏差，从而有效地将样条‘锚定’在x轴上，进而抑制线性尾部。在为样条拟合器构建输入时，组合的数据点必须按其 $x$ 坐标排序。\n\n**步骤 4：尾部度量计算**\n为了量化人为尾部的幅度，我们定义了一个特定的评估度量。我们创建了一个包含 $2M$ 个点的尾部评估网格，其中 $M=301$。该网格是训练范围之外两个不相交区间的并集：$[-1.8, -1.2]$ 和 $[1.2, 1.8]$。让这些网格点表示为 $\\{z_j\\}_{j=1}^{2M}$。对于任何拟合的样条 $\\hat{f}$，其尾部幅度 $T(\\hat{f})$ 定义为在该网格上评估的函数绝对值的平均值：\n$$\nT(\\hat{f}) = \\frac{1}{2M}\\sum_{j=1}^{2M} | \\hat{f}(z_j) |\n$$\n我们为基线样条 $T(\\hat{f}_{\\text{base}})$ 和锚定样条 $T(\\hat{f}_{\\text{anch}})$ 计算这个度量。\n\n**步骤 5：输出度量计算**\n锚定补救法的有效性通过尾部幅度的比率 $R$ 来衡量：\n$$\nR = \\frac{T(\\hat{f}_{\\text{anch}})}{T(\\hat{f}_{\\text{base}})}\n$$\n比率 $R  1$ 表示由于锚定程序，人为尾部有所减少。为处理基线样条可能具有零尾部的情况（这在该问题中不太可能发生，但代表了良好的数值实践），分母的下限设为一个小的正值 $10^{-12}$。对与 $s \\in \\{0.05, 0.5, 2.0\\}$ 相对应的三个测试用例中的每一个重复此过程，并报告所得的三个比率。",
            "answer": "[0.000003,0.000007,0.000043]"
        }
    ]
}