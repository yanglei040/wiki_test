{
    "hands_on_practices": [
        {
            "introduction": "The best way to begin understanding backpatching is to see it in action. This first exercise provides a stream of three-address code with unresolved jump targets, marked by placeholders. Your task is to act as the final backpatching phase of a compiler, filling in these targets to correctly implement control flow for an `if-then-else` statement and a `while` loop, paying close attention to the short-circuit evaluation of logical operators `AND` ($\\land$) and `OR` ($\\lor$). This practice will solidify your understanding of how abstract control structures are mapped to a concrete sequence of conditional and unconditional jumps.",
            "id": "3623495",
            "problem": "Consider a compiler front-end that generates a three-address Intermediate Representation (IR) as quadruples for structured control-flow constructs. The quadruples are indexed starting at $1$ and use conditional branches and unconditional branches with placeholder targets denoted by the symbol $?$ that must be resolved via backpatching. The IR follows these widely accepted foundations:\n\n- Short-circuit semantics for logical conjunction ($\\land$) and disjunction ($\\lor$): for $E_{1} \\land E_{2}$, if $E_{1}$ is false, the entire expression is false; otherwise $E_{2}$ is evaluated. For $E_{1} \\lor E_{2}$, if $E_{1}$ is true, the entire expression is true; otherwise $E_{2}$ is evaluated.\n- Backpatching: boolean expressions are compiled to produce lists of unresolved jumps corresponding to true and false outcomes, which are patched to the entry points of the appropriate blocks (then-part, else-part, loop body, or exit) once those targets become known.\n- Structured control flow: for an $\\text{if}$–$\\text{then}$–$\\text{else}$ statement, the true exits of the condition target the then-block and the false exits target the else-block; the then-block ends with a jump to the join point after the conditional. For a $\\text{while}$ loop, the condition is re-evaluated at the loop head; true exits target the loop body and false exits target the exit point after the loop; the loop body ends with a jump back to the loop head.\n\nThe following IR quadruple stream uses placeholders $?$ for unresolved branch targets that must be backpatched. The program structure it encodes is an $\\text{if}$–$\\text{then}$–$\\text{else}$ followed by an assignment and then a $\\text{while}$ loop with a short-circuit condition:\n\n- $1$: if $a  b$ goto $?$\n- $2$: goto $?$\n- $3$: if $c \\neq d$ goto $?$\n- $4$: goto $?$\n- $5$: $x := x + 1$\n- $6$: goto $?$\n- $7$: $x := x - 1$\n- $8$: $y := 0$\n- $9$: if $p \\le q$ goto $?$\n- $10$: goto $?$\n- $11$: if $r > s$ goto $?$\n- $12$: goto $?$\n- $13$: $y := y + 2$\n- $14$: goto $?$\n- $15$: $\\text{noop}$\n\nTasks:\n\n1. Using only the foundations stated above, determine the final backpatched targets for each placeholder $?$ so that the IR correctly implements:\n   - An $\\text{if}$ condition $(a  b) \\land (c \\neq d)$ with a then-block at quad $5$ and an else-block at quad $7$, and a join point after the conditional at quad $8$.\n   - A $\\text{while}$ loop with condition $(p \\le q) \\lor (r > s)$ whose body starts at quad $13$, whose condition head is at quad $9$, and whose exit point is at quad $15$.\n2. Enumerate the set of quad indices that were patched.\n3. Let the checksum $\\Sigma$ be defined by\n$$\n\\Sigma \\;=\\; \\sum_{i \\in P} i \\times t_{i},\n$$\nwhere $P$ is the set of patched quad indices and $t_{i}$ is the final backpatched target index for quad $i$. Compute $\\Sigma$ exactly as an integer. No rounding is required. Report only the value of $\\Sigma$ as your final answer.\n\nYour response must include the completed quad array after backpatching and a clear enumeration of the patched indices, but the final answer must be the single number specified above.",
            "solution": "We begin from the stated foundations: short-circuit evaluation for logical conjunction and disjunction, and the structural rules for $\\text{if}$–$\\text{then}$–$\\text{else}$ and $\\text{while}$ constructs, with backpatching used to resolve conditional and unconditional jump targets once the corresponding block entry or exit points are known.\n\nFirst, we analyze the $\\text{if}$–$\\text{then}$–$\\text{else}$ portion. The condition is $(a  b) \\land (c \\neq d)$ with then-block at quad $5$ and else-block at quad $7$, and a join point after the conditional at quad $8$.\n\n- For a logical conjunction $E_{1} \\land E_{2}$ under short-circuit semantics:\n  - If $E_{1}$ is false, the whole condition is false and control transfers to the else-block.\n  - If $E_{1}$ is true, evaluation proceeds to $E_{2}$.\n  - If $E_{2}$ is true, the whole condition is true and control transfers to the then-block.\n  - If $E_{2}$ is false, control transfers to the else-block.\n\nApplying this to the quads:\n\n- Quad $1$ is the test for $E_{1}$: if $a  b$ goto $?$.\n  - True branch from quad $1$ should go to the evaluation of $E_{2}$ at quad $3$, so we patch quad $1$ to target $3$.\n- Quad $2$ is the false branch after testing $E_{1}$: goto $?$.\n  - False outcome should go to the else-block at quad $7$, so we patch quad $2$ to target $7$.\n- Quad $3$ is the test for $E_{2}$: if $c \\neq d$ goto $?$.\n  - True branch should go to the then-block at quad $5$, so we patch quad $3$ to target $5$.\n- Quad $4$ is the false branch after testing $E_{2}$: goto $?$.\n  - False outcome should go to the else-block at quad $7$, so we patch quad $4$ to target $7$.\n- Quad $5$ is the then-block body: $x := x + 1$.\n- Quad $6$ is the jump to the join point: goto $?$.\n  - After executing the then-block, we must skip the else-block and go to the join point at quad $8$, so we patch quad $6$ to target $8$.\n- Quad $7$ is the else-block body: $x := x - 1$.\n- Quad $8$ is the join point after the conditional: $y := 0$.\n\nNext, we analyze the $\\text{while}$ loop with condition $(p \\le q) \\lor (r > s)$, whose body starts at quad $13$, whose condition head is at quad $9$, and whose exit is at quad $15$.\n\n- For a logical disjunction $E_{1} \\lor E_{2}$ under short-circuit semantics:\n  - If $E_{1}$ is true, the whole condition is true and control transfers to the loop body.\n  - If $E_{1}$ is false, evaluation proceeds to $E_{2}$.\n  - If $E_{2}$ is true, transfer to the loop body.\n  - If $E_{2}$ is false, transfer to the loop exit.\n\nApplying this to the quads:\n\n- Quad $9$ is the test for $E_{1}$: if $p \\le q$ goto $?$.\n  - True branch goes to the loop body at quad $13$, so we patch quad $9$ to target $13$.\n- Quad $10$ is the transfer to evaluate $E_{2}$ if $E_{1}$ is false: goto $?$.\n  - It should go to the next test at quad $11$, so we patch quad $10$ to target $11$.\n- Quad $11$ is the test for $E_{2}$: if $r > s$ goto $?$.\n  - True branch goes to the loop body at quad $13$, so we patch quad $11$ to target $13$.\n- Quad $12$ is the false branch after testing $E_{2}$: goto $?$.\n  - False outcome exits the loop, so we patch quad $12$ to target $15$.\n- Quad $13$ is the loop body: $y := y + 2$.\n- Quad $14$ is the back edge of the loop: goto $?$.\n  - It must transfer control back to the loop head at quad $9$ to re-evaluate the condition, so we patch quad $14$ to target $9$.\n- Quad $15$ is the loop exit point: $\\text{noop}$.\n\nTherefore, the completed quad array after backpatching is:\n\n- $1$: if $a  b$ goto $3$\n- $2$: goto $7$\n- $3$: if $c \\neq d$ goto $5$\n- $4$: goto $7$\n- $5$: $x := x + 1$\n- $6$: goto $8$\n- $7$: $x := x - 1$\n- $8$: $y := 0$\n- $9$: if $p \\le q$ goto $13$\n- $10$: goto $11$\n- $11$: if $r > s$ goto $13$\n- $12$: goto $15$\n- $13$: $y := y + 2$\n- $14$: goto $9$\n- $15$: $\\text{noop}$\n\nThe set of patched quad indices is $P = \\{1, 2, 3, 4, 6, 9, 10, 11, 12, 14\\}$, and the corresponding patched targets $\\{t_{i}\\}$ are:\n- $t_{1} = 3$\n- $t_{2} = 7$\n- $t_{3} = 5$\n- $t_{4} = 7$\n- $t_{6} = 8$\n- $t_{9} = 13$\n- $t_{10} = 11$\n- $t_{11} = 13$\n- $t_{12} = 15$\n- $t_{14} = 9$\n\nWe now compute the checksum\n$$\n\\Sigma \\;=\\; \\sum_{i \\in P} i \\times t_{i}\n\\;=\\;\n(1 \\times 3)\n+ (2 \\times 7)\n+ (3 \\times 5)\n+ (4 \\times 7)\n+ (6 \\times 8)\n+ (9 \\times 13)\n+ (10 \\times 11)\n+ (11 \\times 13)\n+ (12 \\times 15)\n+ (14 \\times 9).\n$$\nEvaluate term by term:\n- $1 \\times 3 = 3$\n- $2 \\times 7 = 14$\n- $3 \\times 5 = 15$\n- $4 \\times 7 = 28$\n- $6 \\times 8 = 48$\n- $9 \\times 13 = 117$\n- $10 \\times 11 = 110$\n- $11 \\times 13 = 143$\n- $12 \\times 15 = 180$\n- $14 \\times 9 = 126$\n\nSumming,\n$$\n\\Sigma = 3 + 14 + 15 + 28 + 48 + 117 + 110 + 143 + 180 + 126 = 784.\n$$\nThus the required checksum is $784$.",
            "answer": "$$\\boxed{784}$$"
        },
        {
            "introduction": "After seeing the final result of backpatching, let's now simulate the generation process itself. This exercise puts you in the role of the compiler's code generator, tracking the `nextquad` counter as you translate a nested control-flow structure. By carefully applying a formal translation scheme, you will manage the `truelist`, `falselist`, and a `breaklist` to see how jump targets are determined incrementally. This hands-on trace  is crucial for appreciating how backpatching elegantly solves the problem of forward jumps without multiple passes over the code.",
            "id": "3623441",
            "problem": "Consider a translation scheme for control-flow statements in a compiler that emits three-address code (Three-Address Code (TAC)) into a linear sequence of quadruples, indexed by a global $nextquad$ counter. The compiler uses the backpatching method: boolean expressions produce lists of forward jumps ($truelist$ and $falselist$); loops maintain a $breaklist$ capturing unpatched jumps from `break` statements to the loop’s exit. The following fundamental facts define the base of the derivation:\n\n- A boolean test for a relational condition is translated into two TAC quadruples: one conditional jump for the true branch and one unconditional jump for the false branch. Thus each boolean expression $E$ contributes $2$ quadruples and yields $E.truelist$ and $E.falselist$ holding indices of the emitted jumps to be backpatched later.\n- For a `while` statement of the form `while (B) do S`, the translation scheme is:\n  1. Record $M$, defined as $M = nextquad$, before emitting $B$.\n  2. Translate $B$ to produce $B.truelist$ and $B.falselist$.\n  3. Record $N = nextquad$ at the beginning of $S$ and backpatch $B.truelist$ to $N$.\n  4. Translate $S$.\n  5. Emit a back-edge $goto\\ M$.\n  6. Let $L = nextquad$ after emitting the back-edge; backpatch $B.falselist$ to $L$ and also backpatch the loop’s $breaklist$ to $L$.\n- For an `if (B) then S_1 else S_2` statement, the scheme is:\n  1. Translate $B$, yielding $B.truelist$ and $B.falselist$.\n  2. Record $N_{then} = nextquad$ and backpatch $B.truelist$ to $N_{then}$; translate $S_1$.\n  3. Emit $goto\\ \\_\\_\\_$ (one TAC quadruple) to skip $S_2$, collecting its index into a $nextlist$ to be backpatched to the “after-if” join point.\n  4. Record $N_{else} = nextquad$ and backpatch $B.falselist$ to $N_{else}$; translate $S_2$.\n  5. Let $J = nextquad$ after $S_2$; backpatch the $nextlist$ from step $3$ to $J$.\n- A `break` inside a loop emits $1$ TAC quadruple $goto\\ \\_\\_\\_$ and appends its index to the innermost enclosing loop’s $breaklist$. That $breaklist$ is backpatched to the loop’s exit label $L$ defined in the `while` scheme above.\n\nYou are given the following nested control-flow program fragment:\n\n- Program:\n  - $while\\ (E_1)\\ do$\n    - $while\\ (E_2)\\ do$\n      - $if\\ (E_3)\\ then$\n        - $break;$\n      - $else$\n        - $S_a;$\n      - $S_b;$\n    - $S_c;$\n\nAssume the following TAC emission costs:\n- Each boolean expression $E_i$ emits $2$ TAC quadruples.\n- The statement `break` emits $1$ TAC quadruple.\n- The statement $S_a$ emits $3$ TAC quadruples.\n- The statement $S_b$ emits $2$ TAC quadruples.\n- The statement $S_c$ emits $1$ TAC quadruple.\n- The unconditional $goto$ used at the end of the $then$ part in the $if$ translation emits $1$ TAC quadruple.\n\nAssume the global counter initially satisfies $nextquad = q_0$ with $q_0 = 500$. Apply the translation schemes exactly as stated above, with no optimizations or elisions. Compute the precise quadruple index to which the `break` inside the `then` block of the inner `if` is ultimately backpatched. Your answer must be a single integer (no units, no rounding).",
            "solution": "The problem requires a precise trace of the given compiler translation scheme to determine the target quadruple index for a specific `break` statement. The method of backpatching is used for generating three-address code (TAC), where the location of each quadruple is tracked by a global counter, which we will denote as $q$. The initial value is given as $q_0 = 500$.\n\nThe program fragment has a nested structure:\n- Outer loop: `while` ($E_1$) `do` {$S_{outer}$}\n- Inner loop: `while` ($E_2$) `do` {$S_{inner}$}\n- `if` statement: `if` ($E_3$) `then` `break;` `else` {$S_a$;}\n\nWe will trace the value of the $q$ counter step-by-step as the compiler processes the fragment according to the specified rules.\n\n1.  **Outer `while` loop (`while (E_1) ...`)**:\n    - The address of the start of the loop condition test is recorded: $M_1 = q = 500$.\n    - The boolean expression $E_1$ is translated. Per the problem, this emits $2$ quadruples. The counter is updated: $q = 500 + 2 = 502$. These two quadruples are the jumps for the true and false cases of $E_1$.\n    - The beginning of the loop body is at the current address, $N_1 = q = 502$. The true-list of $E_1$, which contains the index of the first jump (at $500$), is backpatched to target $N_1$.\n\n2.  **Outer loop body (contains inner `while` loop)**:\n    - The first statement inside the outer loop's body is the inner `while` loop. The translation starts with $q=502$.\n\n3.  **Inner `while` loop (`while (E_2) ...`)**:\n    - The address of the start of this loop's condition test is recorded: $M_2 = q = 502$.\n    - The boolean expression $E_2$ is translated, emitting $2$ quadruples. The counter is updated: $q = 502 + 2 = 504$. These jumps, at indices $502$ and $503$, populate the true and false lists for $E_2$.\n    - The beginning of the inner loop's body is at the current address, $N_2 = q = 504$. The true-list of $E_2$ (containing index $502$) is backpatched to target $N_2$.\n\n4.  **Inner loop body (contains `if-else` and $S_b$)**:\n    - The translation proceeds for the body of the inner loop, starting at $q=504$. The first statement is the `if` statement.\n\n5.  **`if (E_3) then ... else ...` statement**:\n    - The boolean expression $E_3$ is translated, emitting $2$ quadruples. The counter becomes $q = 504 + 2 = 506$. The jumps at indices $504$ and $505$ populate the true and false lists for $E_3$.\n    - The `then` block starts at $N_{then} = q = 506$. The true-list of $E_3$ (containing index $504$) is backpatched to target $N_{then}$.\n    - The `then` block contains a single `break` statement. According to the rules, a `break` emits $1$ TAC quadruple of the form `goto ___`. This quadruple is generated at the current address, which is $q=506$. The index of this `goto`, $506$, is added to the `breaklist` of the innermost enclosing loop (the `while (E_2)` loop). Let's call this list `breaklist_2`. After emitting this quadruple, the counter is incremented: $q = 506 + 1 = 507$.\n    - After the `then` block, an unconditional jump is emitted to skip the `else` block. This costs $1$ quadruple. This `goto ___` is generated at index $q=507$ and its index is added to a list called $nextlist$. The counter is updated: $q = 507 + 1 = 508$.\n    - The `else` block starts at $N_{else} = q = 508$. The false-list of $E_3$ (containing index $505$) is backpatched to target $N_{else}$.\n    - The statement $S_a$ in the `else` block is translated. It emits $3$ quadruples. The counter becomes $q = 508 + 3 = 511$.\n    - The `if-else` statement translation concludes. The join point after the statement is at the current address, $J = q = 511$. The $nextlist$ (containing index $507$) is backpatched to this target $J$.\n\n6.  **Continuing the inner loop body**:\n    - The statement $S_b$, which follows the `if` statement, is translated. It emits $2$ quadruples. The counter becomes $q = 511 + 2 = 513$.\n\n7.  **Conclusion of the inner `while` loop**:\n    - The body of the inner `while` loop is now fully translated. The final steps for the `while` statement rule are applied.\n    - An unconditional back-edge `goto M_2` is emitted. We recorded $M_2 = 502$. This instruction is a single quadruple, placed at index $q=513$. The counter is incremented: $q = 513 + 1 = 514$.\n    - The address immediately following the generated code for the inner loop defines the loop's exit point. Let this be $L_2$. Therefore, $L_2 = q = 514$.\n    - According to the `while` rule, the loop's `falselist` (from $E_2$) and the loop's `breaklist` (`breaklist_2`) are both backpatched to this exit address $L_2$.\n\nThe `break` statement in the `if` block generated a `goto` quadruple at index $506$. The reference to this quadruple was stored in `breaklist_2`. This list is backpatched to the target $L_2$. The calculated value of $L_2$ is $514$. Thus, the `goto` instruction at index $506$ is completed to become `goto 514`.\n\nThe quadruple index to which the `break` is backpatched is $514$.",
            "answer": "$$\n\\boxed{514}\n$$"
        },
        {
            "introduction": "Now that you have practiced generating correct code, it's time to think like a compiler developer and debug a faulty implementation. This problem  presents a scenario where a bug in the backpatching logic creates an infinite loop. Your goal is to move beyond mere application and reason about the fundamental invariants of the backpatching process. By evaluating different diagnostic methods, you will connect the abstract rules of list management to more formal concepts like Control Flow Graphs (CFGs) and reachability, deepening your understanding of why backpatching is a robust technique.",
            "id": "3623500",
            "problem": "A compiler uses the standard backpatching method to translate structured control flow into three-address code. For boolean expressions, it maintains a true list and a false list, denoted $\\mathtt{truelist}$ and $\\mathtt{falselist}$, which are sets of incomplete jumps to be patched later. For statements, it maintains a next list, denoted $\\mathtt{nextlist}$, of incomplete jumps that should be patched to the statement’s successor. The essential invariants are: for a `while (B) S` statement, the entries in $B.\\mathtt{truelist}$ are patched to the first instruction of $S$, and the entries in $B.\\mathtt{falselist}$ are patched to the first instruction after the loop. The Control Flow Graph (CFG) has nodes that are basic blocks (leaders at the first instruction, at targets of jumps, and at instructions immediately following a jump), and edges induced by conditional and unconditional jumps and by fall-through to the next instruction when no jump overrides it.\n\nConsider the following three-address code emitted for a loop before backpatching, where instruction numbers are the leftmost integers, and markers $M$ and $N$ record, respectively, the loop-head and the first instruction after the loop as captured by the syntax-directed translation (so $M$ points to the test and $N$ to the code after the loop):\n\n- $10$: if $x  y$ goto $\\_$ \n- $11$: goto $\\_$ \n- $12$: $...$ code for $S$ begins $...$\n- $13$: $...$\n- $14$: $...$ code for $S$ ends $...$\n- $15$: goto $10$\n- $16$: $...$ code after loop begins $...$\n\nAt the point right after parsing $B$ but before backpatching, $B.\\mathtt{truelist} = \\{10\\}$ (the conditional at $10$) and $B.\\mathtt{falselist} = \\{11\\}$, and $S.\\mathtt{nextlist} = \\varnothing$. A bug in the compiler’s backpatching routine mistakenly patches $B.\\mathtt{falselist}$ to $M$ (i.e., to instruction $10$) instead of to $N$ (i.e., to instruction $16$). The resulting patched code is:\n\n- $10$: if $x  y$ goto $12$\n- $11$: goto $10$\n- $12$: $...$ code for $S$ begins $...$\n- $13$: $...$\n- $14$: $...$ code for $S$ ends $...$\n- $15$: goto $10$\n- $16$: $...$ code after loop begins $...$\n\nThis program exhibits an infinite loop even when the condition $x  y$ is false initially, because control flows $10 \\to 11 \\to 10 \\to 11 \\to \\cdots$.\n\nYou are asked to diagnose this mispatch using only first principles: the invariants of backpatching lists and the definition of a Control Flow Graph (CFG) together with standard reachability and dominance concepts. Which of the following diagnosis methods will provably identify the mispatch and correctly attribute it to the wrong target of $B.\\mathtt{falselist}$?\n\nSelect all that apply.\n\nA. Construct the CFG by introducing edges for conditional jumps (both to the target and to the fall-through), edges for unconditional jumps, and fall-through edges to the next instruction when no jump overrides it. Using the recorded marker $N$ for the after-loop leader (instruction $16$), check reachability from the loop test (instruction $10$) to $N$ along the false successor. If no such path exists, report a mispatch of $B.\\mathtt{falselist}$ and identify the offending goto by tracing which instruction in $B.\\mathtt{falselist}$ was not patched to $N$.\n\nB. Construct the CFG and compute dominators. Flag any back edge whose head does not dominate its tail as evidence of a mispatch in this loop. If such an edge exists, attribute the infinite loop to a wrongly patched $B.\\mathtt{falselist}$.\n\nC. Use list provenance without building the full CFG: verify the while-statement invariant by checking that every entry in $B.\\mathtt{falselist}$ was patched to $N$ (the marker for the after-loop leader) and that no entry in $B.\\mathtt{falselist}$ was patched to $M$ (the loop-head marker). If a member of $B.\\mathtt{falselist}$ equals $M$, report the mispatch and the exact instruction index responsible.\n\nD. Execute the emitted code on any input and, if it does not terminate within a fixed timeout, attribute the non-termination to an incorrect $\\mathtt{nextlist}$ patch in the loop body rather than to $B.\\mathtt{falselist}$.\n\nE. Renumber instructions to force all false edges of conditionals to point to strictly larger instruction numbers. If the program then terminates on a given input, conclude that the original non-termination was caused by a mispatched $B.\\mathtt{falselist}$.\n\nOnly methods that are guaranteed by the definitions above to find this specific class of backpatching bug and to correctly pinpoint its cause should be selected. Give your answer as the set of all correct options.",
            "solution": "The problem statement is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Step 1: Extract Givens\n\n- **Compiler method**: Standard backpatching for structured control flow into three-address code.\n- **Data structures**:\n    - `truelist`: A set of incomplete jumps for a boolean expression $B$ that should be patched to the true-exit.\n    - `falselist`: A set of incomplete jumps for a boolean expression $B$ that should be patched to the false-exit.\n    - `nextlist`: A set of incomplete jumps for a statement $S$ that should be patched to the statement's successor.\n- **Invariant for `while (B) S`**:\n    - Entries in $B.\\mathtt{truelist}$ are patched to the first instruction of $S$.\n    - Entries in $B.\\mathtt{falselist}$ are patched to the first instruction after the loop.\n- **CFG definition**:\n    - Nodes are basic blocks.\n    - Leaders are identified at the first instruction, at targets of jumps, and at instructions immediately following a jump.\n    - Edges are induced by conditional jumps, unconditional jumps, and fall-through.\n- **Scenario Code (pre-backpatching)**:\n    - $10$: if $x  y$ goto $\\_$\n    - $11$: goto $\\_$\n    - $12$: $...$ code for $S$ begins $...$\n    - $...$\n    - $15$: goto $10$\n    - $16$: $...$ code after loop begins $...$\n- **Scenario State**:\n    - Marker $M$ points to instruction $10$ (loop head).\n    - Marker $N$ points to instruction $16$ (after loop).\n    - $B.\\mathtt{truelist} = \\{10\\}$.\n    - $B.\\mathtt{falselist} = \\{11\\}$.\n    - $S.\\mathtt{nextlist} = \\varnothing$.\n- **The Bug**: $B.\\mathtt{falselist}$ is mistakenly patched to $M$ (instruction $10$) instead of $N$ (instruction $16$).\n- **Resulting\nPatched Code**:\n    - $10$: if $x  y$ goto $12$\n    - $11$: goto $10$\n    - $12$: $...$ code for $S$ begins $...$\n    - $...$\n    - $15$: goto $10$\n    - $16$: $...$ code after loop begins $...$\n- **The Question**: Identify which diagnosis methods will provably identify the mispatch and correctly attribute it to the wrong target of $B.\\mathtt{falselist}$, based on first principles.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is well-defined and grounded in the established principles of compiler design, specifically syntax-directed translation and code generation. The concepts of backpatching, three-address code, Control Flow Graphs (CFGs), and dominators are standard in computer science. The scenario presents a specific, plausible bug and asks for a formal method to detect it. The problem is self-contained, with all necessary definitions and data provided. It is objective and does not contain any scientific or factual unsoundness.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. The solution will proceed by analyzing each proposed method against the provided principles.\n\n### Principle-Based Derivation and Option Analysis\n\nThe core of the problem lies in the violation of a fundamental invariant of structured programming translation. For a `while` loop, the boolean condition must provide two distinct paths: one that enters (or continues) the loop body and one that exits the loop. In the context of backpatching, this translates to:\n- Jumps in $B.\\mathtt{truelist}$ must be patched to the start of the loop body ($S$).\n- Jumps in $B.\\mathtt{falselist}$ must be patched to the instruction immediately following the loop ($N$).\n\nThe bug described is that an instruction from $B.\\mathtt{falselist}$ (instruction $11$) is patched to the loop head $M$ (instruction $10$) instead of the loop exit $N$ (instruction $16$). This creates a situation where the \"false\" path of the condition leads back to the condition itself, preventing the loop from ever terminating when the condition is false. A valid diagnostic method must detect this specific violation and identify its cause.\n\nLet's analyze the Control Flow Graph (CFG) of the buggy code. The leaders are instructions $10$ (target of jumps), $11$ (follows a conditional jump), $12$ (target of a jump), and $16$ (follows a jump).\nThe basic blocks are:\n- $B_1$: instruction $10$\n- $B_2$: instruction $11$\n- $B_3$: instructions $12-15$\n- $B_4$: instruction $16$ and onwards\n\nThe edges are:\n- $B_1 \\to B_3$ (true branch from `if` at $10$ to $12$)\n- $B_1 \\to B_2$ (false branch, fall-through from $10$ to $11$)\n- $B_2 \\to B_1$ (unconditional jump from $11$ to $10$)\n- $B_3 \\to B_1$ (unconditional jump from $15$ to $10$)\n\nNotice that there are no edges leading to $B_4$, meaning the code after the loop is unreachable.\n\n**A. Construct the CFG... check reachability from the loop test (instruction $10$) to $N$ (instruction $16$) along the false successor.**\n\nThis method proposes building the CFG and performing a reachability analysis. The loop test is at instruction $10$. Its \"false successor\" path begins with the edge from node $B_1$ (containing $10$) to node $B_2$ (containing $11$). Following this path, we have the cycle $B_1 \\to B_2 \\to B_1 \\to \\dots$. The node $B_4$ (containing $N=16$) is not reachable from $B_1$ or $B_2$. Therefore, the check \"If no such path exists, report a mispatch\" will correctly trigger an error. The method then proposes to \"identify the offending goto by tracing which instruction in $B.\\mathtt{falselist}$ was not patched to $N$\". The compiler has the metadata that $B.\\mathtt{falselist}=\\{11\\}$. By examining the generated code, it can see that instruction $11$ is `goto 10`. Since the target $10 \\neq N$, the method correctly identifies the instruction from the list and its incorrect patch. This method is sound and correctly attributes the cause.\nVerdict: **Correct**.\n\n**B. Construct the CFG and compute dominators. Flag any back edge whose head does not dominate its tail...**\n\nThis method relies on the definition of a back edge in a CFG, which is an edge $(u, v)$ where the head $v$ dominates the tail $u$. This property is used to identify natural loops. Let's compute dominators for our CFG, with $B_1$ as the entry.\n- $\\mathrm{dom}(B_1) = \\{B_1\\}$\n- $\\mathrm{dom}(B_3) = \\{B_1, B_3\\}$\n- $\\mathrm{dom}(B_2) = \\{B_1, B_2\\}$\nThe back edges are those that point to a dominator.\n- Edge $B_3 \\to B_1$: The head is $B_1$, tail is $B_3$. $B_1 \\in \\mathrm{dom}(B_3)$. This is a valid back edge.\n- Edge $B_2 \\to B_1$: The head is $B_1$, tail is $B_2$. $B_1 \\in \\mathrm{dom}(B_2)$. This is also a valid back edge.\nThe check proposed is \"Flag any back edge whose head does not dominate its tail\". In our case, both back edges have heads that dominate their tails. Thus, this method will **not** flag any error. The bug creates a structurally sound (but semantically incorrect) loop. Dominance analysis alone is insufficient to detect this kind of logical error.\nVerdict: **Incorrect**.\n\n**C. Use list provenance without building the full CFG: verify the while-statement invariant by checking that every entry in $B.\\mathtt{falselist}$ was patched to $N$...**\n\nThis method bypasses complex graph analysis and instead directly verifies the backpatching invariants using the metadata maintained by the compiler (the lists and markers). The invariant for the `while` statement explicitly requires that all instructions in $B.\\mathtt{falselist}$ be patched to target $N$. The proposed check is to iterate through the entries in $B.\\mathtt{falselist}$ and verify their patched target is indeed $N$.\nIn this case, $B.\\mathtt{falselist} = \\{11\\}$ and $N = 16$. The check examines instruction $11$ in the patched code, which is `goto 10`. The target is $10$. Since $10 \\neq 16$, the invariant is violated. The method correctly reports a mispatch and identifies the exact instruction ($11$) and list ($B.\\mathtt{falselist}$) responsible. This is a direct, precise, and provably correct way to find this specific bug.\nVerdict: **Correct**.\n\n**D. Execute the emitted code on any input and, if it does not terminate within a fixed timeout, attribute the non-termination to an incorrect $\\mathtt{nextlist}$ patch...**\n\nThis method proposes dynamic analysis (testing) rather than static analysis. While testing can reveal the presence of a bug (non-termination), it has several fundamental flaws as a diagnostic tool.\n1. It is not a *proof*. It only works for the specific inputs tested. With a different initial state (e.g., $x \\ge y$), the loop might terminate correctly (by entering the body, and eventually exiting if the variables change appropriately), and the bug would not be found.\n2. The fixed timeout is arbitrary and could lead to false positives (on a correct but long-running loop) or false negatives (if the timeout is too long).\n3. The attribution is incorrect. It blames the `S.nextlist` when the actual bug is in the patching of $B.\\mathtt{falselist}$. In the given scenario, the loop body $S$ is never even entered, so `S.nextlist` (which is empty anyway) is irrelevant.\nVerdict: **Incorrect**.\n\n**E. Renumber instructions to force all false edges of conditionals to point to strictly larger instruction numbers. If the program then terminates... conclude that the original non-termination was caused by a mispatched $B.\\mathtt{falselist}$.**\n\nThis is another method based on a heuristic modification followed by testing. The phrase \"renumber instructions\" is ambiguous. If it means simply changing the labels (e.g., $10 \\to 100, 11 \\to 101$), the `goto 100` would preserve the infinite loop. A more charitable interpretation is that it means to enforce a code layout where all control flow for \"false\" cases goes forward. The false path from instruction $10$ is the fall-through to $11$. The instruction at $11$ is `goto 10`, a backward jump. The method seems to suggest altering this jump to point forward. This is essentially proposing a \"fix\" (patching $11$ to point to $16$) and then re-testing. Like option D, this is a form of dynamic analysis, not a static proof. It's a \"guess and check\" approach, not a diagnostic method that finds and attributes the error from first principles. It does not provably identify the mispatch; it observes that a particular change fixed a symptom for one test case.\nVerdict: **Incorrect**.",
            "answer": "$$\\boxed{AC}$$"
        }
    ]
}