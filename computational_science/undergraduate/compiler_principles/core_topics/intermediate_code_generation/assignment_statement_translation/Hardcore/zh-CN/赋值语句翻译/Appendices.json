{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。本节的第一个练习旨在训练你精确遵循语言规范的能力，特别是处理带有副作用的表达式时。通过细致地追踪一个包含后自增运算符的赋值序列，你将深入理解编译器如何通过引入临时变量和遵循严格的求值顺序，来保证源代码语义的正确实现 。",
            "id": "3622053",
            "problem": "您正在为一种简单的命令式语言设计一个代码生成器，该语言包含整型变量和两种构造：赋值 $:=$ 和后自增 $++$。目标是将带有副作用的表达式正确地翻译成三地址码 (TAC)，同时保留源语言的语义保证。\n\n核心定义与保证：\n- 每个变量表示一个存储整数的独立内存位置。所有算术运算都基于数学上的整数，并且不会溢出。\n- 后自增 $v++$ 产生 $v$ 的当前值，并作为副作用将 $v$ 的值增加 $1$。这个增量必须被持久化。\n- 在任何二元表达式 $E_1 \\circ E_2$ 中（对于任何运算符 $\\circ$），求值从左到右进行：$E_1$ 被完全求值（包括所有副作用），然后是 $E_2$，最后应用该运算符。\n- 在赋值语句 $x := E$ 中，右侧的表达式 $E$ 在存入 $x$ 之前被完全求值（包括所有副作用）。\n- 后自增出现的翻译模式：为了对 $v++$ 求值，生成 TAC 时需使用一个新的临时变量 $t$ 将其拆分为一个求值阶段和一个回写阶段：首先是 $t := v$（求值），然后是 $v := v + 1$（回写）；表达式 $v++$ 所贡献的值是 $t$。\n\n考虑以下顺序执行的程序片段，其中括号表示显式分组，并且如上所述，每个运算符的求值顺序都是从左到右：\n1. $a := y++$\n2. $b := (y++) + (y++)$\n3. $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n4. $y := y++$\n5. $w := a + b + c + y$\n\n假设在执行该片段之前，初始状态为 $y = 3$，所有其他变量均未初始化。请仅使用上述核心定义和翻译模式，并确保每个 $v++$ 都通过使用新的临时变量拆分为求值阶段和回写阶段来处理，从而确定在执行正确翻译的 TAC 后 $w$ 的最终值。\n\n请以单个整数形式提供您的答案。无需四舍五入。",
            "solution": "该问题陈述经核实具有科学依据、定义明确且客观。它描述了编译器设计中的一个标准问题，即关于将带有副作用的表达式翻译成中间代码。求值顺序、后自增的副作用以及赋值语义的规则都得到了明确且无歧义的定义，从而可以对程序执行进行唯一、确定性的追踪。因此，该问题是有效的。\n\n任务是通过追踪五个语句序列的执行来确定变量 $w$ 的最终值。我们将严格遵守所提供的语义规则，一步一步地进行追踪。我们从初始状态 $y=3$ 开始，所有其他变量均未初始化。每个后自增操作 $v++$ 的翻译都将使用一个新的临时变量 $t_i$ 来将值获取与增加 $v$ 的副作用分离开。\n\n初始状态：$y=3$。\n\n1.  **语句 1:** $a := y++$\n    首先对右侧 (RHS) 的 $y++$ 进行求值。\n    *   求值阶段：一个临时变量 $t_1$ 被赋予 $y$ 的当前值。$t_1 := y$，所以 $t_1$ 变为 $3$。\n    *   回写阶段：变量 $y$ 被增加。$y := y + 1$，所以 $y$ 变为 $3+1=4$。\n    RHS 表达式的值是在临时变量中捕获的值，即 $3$。\n    最后，执行对 $a$ 的赋值：$a := 3$。\n    **语句 1 后的状态：** $y=4$, $a=3$。\n\n2.  **语句 2:** $b := (y++) + (y++)$\n    RHS 是一个二元加法。根据规则，左操作数在右操作数之前被完全求值。\n    *   对左操作数，即第一个 $y++$ 进行求值：\n        *   求值阶段：$t_2 := y$。$y$ 的当前值为 $4$，所以 $t_2$ 变为 $4$。\n        *   回写阶段：$y := y + 1$。$y$ 的值变为 $4+1=5$。\n        左操作数的值是 $4$。\n    *   对右操作数，即第二个 $y++$ 进行求值。来自左操作数的副作用已经完成。\n        *   求值阶段：$t_3 := y$。$y$ 的当前值为 $5$，所以 $t_3$ 变为 $5$。\n        *   回写阶段：$y := y + 1$。$y$ 的值变为 $5+1=6$。\n        右操作数的值是 $5$。\n    *   应用加法运算符：$4 + 5 = 9$。\n    执行对 $b$ 的赋值：$b := 9$。\n    **语句 2 后的状态：** $y=6$, $a=3$, $b=9$。\n\n3.  **语句 3:** $c := (y++) \\times \\big((y++) - 1\\big) - (y++)$\n    表达式根据同级运算符从左到右的求值顺序进行计算，并强制执行括号内的运算。其结构是 $(E_1 \\times E_2) - E_3$。\n    *   首先，对子表达式 $(y++) \\times \\big((y++) - 1\\big)$ 进行求值。\n        *   对其左操作数，即第一个 $y++$ 进行求值：\n            *   求值阶段：$t_4 := y$。$y$ 的当前值为 $6$，所以 $t_4$ 变为 $6$。\n            *   回写阶段：$y := y + 1$。$y$ 的值变为 $6+1=7$。\n            这个操作数的值是 $6$。\n        *   对其右操作数 $\\big((y++) - 1\\big)$ 进行求值。\n            *   对内部的 $y++$ 进行求值：\n                *   求值阶段：$t_5 := y$。$y$ 的当前值为 $7$，所以 $t_5$ 变为 $7$。\n                *   回写阶段：$y := y + 1$。$y$ 的值变为 $7+1=8$。\n                这个内部的 $y++$ 的值是 $7$。\n            *   应用减法：$7 - 1 = 6$。子表达式 $\\big((y++) - 1\\big)$ 的值是 $6$。\n        *   应用乘法运算符：$6 \\times 6 = 36$。\n    *   整个表达式现在简化为 $36 - (y++)$。\n        *   对右操作数，即最后一个 $y++$ 进行求值。\n            *   求值阶段：$t_6 := y$。$y$ 的当前值为 $8$，所以 $t_6$ 变为 $8$。\n            *   回写阶段：$y := y + 1$。$y$ 的值变为 $8+1=9$。\n            这个操作数的值是 $8$。\n    *   应用最后的减法运算符：$36 - 8 = 28$。\n    执行对 $c$ 的赋值：$c := 28$。\n    **语句 3 后的状态：** $y=9$, $a=3$, $b=9$, $c=28$。\n\n4.  **语句 4:** $y := y++$\n    该语句的处理方式是先完全对 RHS 求值，然后执行赋值。\n    *   对 RHS, $y++$ 进行求值：\n        *   求值阶段：$t_7 := y$。$y$ 的当前值为 $9$，所以 $t_7$ 变为 $9$。\n        *   回写阶段：$y := y + 1$。$y$ 的值变为 $9+1=10$。\n    *   RHS 表达式的值是 $t_7$，即 $9$。\n    *   最后，执行赋值：$y := 9$。这个赋值操作覆盖了回写阶段产生的 $y$ 值。\n    **语句 4 后的状态：** $y=9$, $a=3$, $b=9$, $c=28$。\n\n5.  **语句 5:** $w := a + b + c + y$\n    RHS 表达式不涉及副作用。我们代入变量的当前值。\n    *   $a=3$, $b=9$, $c=28$, $y=9$。\n    *   计算总和：$3 + 9 + 28 + 9 = 12 + 28 + 9 = 40 + 9 = 49$。\n    执行对 $w$ 的赋值：$w := 49$。\n    **最终状态：** $y=9$, $a=3$, $b=9$, $c=28$, $w=49$。\n\n在整个片段执行完毕后，$w$ 的最终值为 $49$。",
            "answer": "$$\n\\boxed{49}\n$$"
        },
        {
            "introduction": "在掌握了基础的副作用处理后，我们来挑战一个更复杂且在实际编译中容易出错的场景。这个练习探讨了当副作用（如后自增）出现在赋值语句左侧的数组索引中时，如何正确地进行翻译。这个问题要求你严格遵守“先完全求值右侧，再求值左侧地址”的规则，这对于避免难以察觉的编译错误至关重要 。",
            "id": "3622020",
            "problem": "我们正在设计一个用于小型命令式源语言的编译器，该编译器旨在将涉及数组和后置自增运算符的赋值语句转换为低级中间表示（IR）。该源语言具有以下语义，这些语义由语言规范定义并保证：\n\n- 表达式求值顺序为从左到右。\n- 在赋值语句 $L := R$ 中，首先对右侧 $R$ 进行完全求值以产生一个值，然后对左侧 $L$ 求值以得到一个地址，最后将产生的值赋给该地址。\n- 后置自增运算符 $x++$ 产生 $x$ 的当前值，并在操作数求值后，作为副作用将 $x$ 的值增加 1。\n\n该编译器目标为经典的三地址码（TAC），其中三地址码（TAC）是一种中间表示（IR），其每条指令最多包含一个运算符，作用于最多两个操作数，并产生最多一个结果。此处使用的三地址码（TAC）遵循以下约束：\n\n- 唯一有状态的内存位置是标量变量（如 $i$）和数组（如 $a$）；$i$ 和 $a$ 之间不存在函数调用或别名。\n- 允许的指令形式包括将标量读入临时变量（$t := i$）、对临时变量或标量进行整数加法（$t := u + c$ 或 $i := i + c$）、数组加载（$t := \\mathrm{load}(a, t_{\\mathrm{idx}})$）和数组存储（$\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$）。每个临时变量最多被写入一次（临时变量的单次赋值），并且由源运算符引起的副作用（如 $i := i + 1$）必须只出现一次。\n- 生成的 TAC 必须保留指定的源码级求值顺序和由 $i++$ 暗示的单次副作用；编译器不得引入虚假的增量操作或跨副作用对求值进行重排序。\n\n考虑在上述语义和 TAC 约束下，降解单个源语句 $a[i++] := a[i]$。设 $\\tau$ 表示为确保语义正确性（包括保留定义的求值顺序和避免任何双重增量或重排序错误）而必须在 TAC 中引入的最小不同临时变量数。\n\n确定最小的 $\\tau$ 值。请用一个整数表示你的答案。无需四舍五入，不涉及单位。",
            "solution": "该问题要求确定将源语句 $a[i++] := a[i]$ 正确翻译为指定的三地址码（TAC）所需的最少临时变量数 $\\tau$，同时遵守语言定义的语义。\n\n首先，我们来形式化给定的语义和约束。\n1.  **赋值语义 ($L := R$)**：首先对右侧 $R$ 进行完全求值以产生一个值。然后，对左侧 $L$ 进行求值以确定一个内存地址。最后，将来自 $R$ 的值存储到由 $L$ 决定的地址中。\n2.  **后置自增语义 ($x++$)**：该表达式产生变量 $x$ 的当前值。在其值被获取后，作为副作用，$x$ 的值增加 1。\n3.  **TAC 指令形式**：翻译必须使用一组受限的指令，包括 $t := i$、$t := u + c$、$i := i+c$、$t := \\mathrm{load}(a, t_{\\mathrm{idx}})$ 和 $\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$。从这些形式中得出的一个关键约束是，用于数组索引的操作数（$t_{\\mathrm{idx}}$）和被存储的值（$t_{\\mathrm{val}}$）必须保存在临时变量中（用 $t$、$u$、$t_{\\mathrm{idx}}$、$t_{\\mathrm{val}}$ 表示）。\n\n让我们应用这些规则来翻译语句 $a[i++] := a[i]$。设 $i_0$ 表示在语句开始执行时变量 $i$ 的值。\n\n**步骤 1：右侧（RHS）求值**\nRHS 是表达式 $a[i]$。根据赋值语义，首先对它进行求值。\n- 为了对 $a[i]$ 求值，编译器必须首先确定索引，即 $i$ 的当前值，也就是 $i_0$。\n- 从数组加载的 TAC 指令是 $t := \\mathrm{load}(a, t_{\\mathrm{idx}})$，它要求索引位于一个临时变量中。因此，我们必须首先将 $i$ 的值复制到一个临时变量中。我们称这个临时变量为 $t_1$。\n  $$t_1 := i$$\n  执行此指令后，$t_1$ 持有值 $i_0$。\n- 现在，我们可以从数组中加载值。加载的结果必须存储在一个临时变量中。我们称之为 $t_2$。\n  $$t_2 := \\mathrm{load}(a, t_1)$$\n  执行此指令后，$t_2$ 持有 $a[i_0]$ 的值。\n至此，RHS 的求值完成。要赋的值现在存储在 $t_2$ 中。\n\n**步骤 2：左侧（LHS）求值**\nLHS 是表达式 $a[i++]$，必须对其求值以产生一个地址。此求值发生在 RHS 完全求值之后。\n- 数组访问的索引由表达式 $i++$ 确定。\n- 后置自增运算符产生 $i$ 的当前值，该值仍然是 $i_0$（因为副作用尚未发生）。我们最终 `store` 操作所需的这个值 $i_0$，已经方便地存储在我们的临时变量 $t_1$ 中。\n- 在为索引获取到值 $i_0$ 之后，必须执行后置自增运算符的副作用。这包括增加变量 $i$ 的值。\n  $$i := i + 1$$\n  变量 $i$ 现在持有值 $i_0 + 1$。LHS 的求值现已完成。目标地址由数组 $a$ 和索引 $i_0$ 指定，该索引保存在 $t_1$ 中。\n\n**步骤 3：执行赋值**\n最后一步是将从 RHS 获得的值存储到由 LHS 决定的地址中。\n- 用于此操作的 TAC 指令是 $\\mathrm{store}(a, t_{\\mathrm{idx}}, t_{\\mathrm{val}})$。这种指令形式要求索引和值都位于临时变量中。\n- 索引是 $i_0$，保存在 $t_1$ 中。\n- 要存储的值是 $a[i_0]$，保存在 $t_2$ 中。\n- 因此，最终的指令是：\n  $$\\mathrm{store}(a, t_1, t_2)$$\n\n**完整的 TAC 序列与最小性分析**\n完整且顺序正确的 TAC 指令序列是：\n$1$. $t_1 := i$\n$2$. $t_2 := \\mathrm{load}(a, t_1)$\n$3$. $i := i + 1$\n$4$. $\\mathrm{store}(a, t_1, t_2)$\n\n此序列使用了两个不同的临时变量，$t_1$ 和 $t_2$。这表明用 $\\tau = 2$ 可以实现正确的翻译。\n\n为了确定这是否是最小数量，我们分析数据依赖和生命周期。\n1.  `store` 操作的索引值 $i_0$ 必须在步骤 4 时可用。但是，变量 $i$ 在步骤 3 被修改了。因此，值 $i_0$ 必须在增量操作发生前保存在一个与 $i$ 分开的位置。由于编译器只能为此目的引入临时变量，因此至少需要一个临时变量来保存索引。\n2.  从 RHS 加载的值 $a[i_0]$ 也必须在步骤 4 时可用。TAC 指令 $t := \\mathrm{load}(...)$ 要求将结果放入一个临时变量中。\n3.  关键点在于，对于最终的 $\\mathrm{store}(a, t_1, t_2)$ 指令，索引值 ($i_0$) 和源值 ($a[i_0]$) 都必须同时存在于临时变量中。尝试使用单个临时变量（比如 $t$）将会失败：\n    - $t := i$ （现在 $t$ 持有索引 $i_0$）\n    - $t := \\mathrm{load}(a, t)$ （现在 $t$ 持有值 $a[i_0]$，但之前在 $t$ 中的索引 $i_0$ 被覆盖并丢失了）。\n    由于最终的 `store` 指令需要索引，而该索引已被覆盖，因此这个序列是不正确的。\n4.  索引值 $i_0$ 和加载值 $a[i_0]$ 的生命周期重叠。它们在最终的 `store` 指令中都需要。由于 TAC 形式要求这两个量在 `store` 时都驻留在临时变量中，因此它们必须占据两个不同的临时变量。\n\n因此，所需的最少临时变量数量为 $\\tau=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "正确的代码生成不仅要保证计算结果的准确性，还必须考虑与后续优化阶段的交互，尤其是在处理指针和内存别名时。这个练习将引导你思考一个高级主题：如何确保赋值操作的可观察行为在存在别名可能性的情况下得以保留，即使这意味着要阻止像“死代码删除”这样的标准优化。通过这个练习，你将学会如何生成既高效又鲁棒的底层代码，以应对复杂的内存交互情况 。",
            "id": "3621961",
            "problem": "一个编译器后端必须将高级赋值语句 $x := *\\mathrm{alias}$ 翻译成适用于加载/存储机器的低级指令序列，同时在可能存在别名的情况下保留可观察语义。程序状态由一个顺序一致性内存和多个寄存器组成。赋值的操作语义规定，首先对右侧表达式求值，然后将所得的值写入左侧变量。指针变量 $\\mathrm{alias}$ 在运行时可能求值为地址 $\\$，因此 $\\mathrm{alias}$ 和 $\\$ 可能指向同一个内存位置。对 $x$ 的写入是一个可观察事件，即使写入的值与 $x$ 中已存储的值相同，也不得被消除。编译器的优化器包含无用存储消除 (Dead Store Elimination, DSE) 功能，该功能会移除被证明是冗余的存储操作，但后端提供一种特殊的“必须存储”操作来强制执行可观察的写入。\n\n给定以下目标级指令形式及其开销，所有开销都是按每条执行指令计算的非负整数：\n- 加载 (Load): $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$ 将内存地址 $r_{p}$ 处的字读取到寄存器 $r_{t}$ 中；开销为 $3$。\n- 强制存储 (Mandatory store): $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$ 将寄存器 $r_{t}$ 中的字写入内存地址 $r_{x}$ 处，且此操作不能被无用存储消除移除；开销为 $4$。\n- 寄存器移动 (Register move): $\\mathrm{MOV}\\ r_{d},\\ r_{s}$ 将寄存器 $r_{s}$ 的内容复制到寄存器 $r_{d}$；开销为 $1$。\n\n没有内存到内存的移动指令。翻译前的初始寄存器分配如下：$r_{x}$ 保存 $\\$，$r_{p}$ 保存 $\\mathrm{alias}$ 的运行时值（一个地址），并且有一个暂存寄存器 $r_{t}$ 可用。不允许使用其他寄存器或指令。除 $\\mathrm{ST!}$ 以外的任何存储操作，如果被证明是冗余的，就可能被无用存储消除移除，且这种移除不得改变可观察行为。\n\n请仅使用这些指令翻译 $x := *\\mathrm{alias}$，以满足以下条件：\n- 在所有运行时情况下，包括当 $r_{p}$ 和 $r_{x}$ 持有相同地址时，可观察语义都得以保留。\n- 翻译过程遵循赋值语义，即在执行写入操作之前对右侧表达式求值。\n- 对 $x$ 的写入保持可观察性，且不被无用存储消除功能所移除。\n\n在满足这些约束的前提下，确定执行一次此赋值所需的最小总动态开销，表示为所执行指令的开销之和。请以单个整数形式提供您的答案；无需四舍五入。",
            "solution": "已根据指定的验证标准对问题陈述进行了分析。\n\n### 第 1 步：提取已知信息\n- **赋值语句：** $x := *\\mathrm{alias}$\n- **操作语义：** 对右侧（RHS）求值，然后将结果值写入左侧（LHS）。\n- **别名条件：** 指针 $\\mathrm{alias}$ 可能持有 $x$ 的地址，这意味着它们各自的地址寄存器 $r_p$ 和 $r_x$ 可能包含相同的值。\n- **可观察性约束：** 对 $x$ 的写入是一个可观察事件，不得被无用存储消除（DSE）移除，即使写入的值与已存在的值相同。\n- **初始寄存器状态：**\n    - 寄存器 $r_x$ 保存 $x$ 的地址，表示为 $\\$。\n    - 寄存器 $r_p$ 保存指针 $\\mathrm{alias}$ 的地址值。\n    - 寄存器 $r_t$ 是一个通用暂存寄存器。\n- **指令集与开销：**\n    - $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$：从内存地址 $r_p$ 加载一个字到寄存器 $r_t$。开销：$3$。\n    - $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$：将寄存器 $r_t$ 中的字存储到内存地址 $r_x$。这是一个强制性存储，不能被 DSE 移除。开销：$4$。\n    - $\\mathrm{MOV}\\ r_{d},\\ r_{s}$：将寄存器 $r_s$ 的值复制到寄存器 $r_d$。开销：$1$。\n- **目标：** 在遵守所有约束的情况下，确定正确翻译并执行一次该赋值语句的最小总动态开销。结果必须为整数。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题定义明确，在编译器构造和计算机体系结构领域具有科学依据。\n- **科学性：** 加载/存储体系结构、别名分析、无用存储消除和可观察程序行为等概念在编译器理论中是基础且标准的。\n- **适定性：** 问题提供了明确的目标（最小化开销）、带显式开销的受限指令集，以及对初始状态和所需语义的完整描述。可以通过逻辑推导确定唯一的最小开销。\n- **客观性：** 问题使用精确、无歧义的技术术语进行表述。\n\n验证清单中列出的缺陷均不存在。该问题被认定为有效。\n\n### 第 3 步：求解\n任务是将高级赋值语句 $x := *\\mathrm{alias}$ 翻译成适用于加载/存储机器的低级指令序列。根据给定的寄存器，这对应于用内存地址 $r_p$ 处的值来更新内存地址 $r_x$ 处的位置。\n\n赋值语义规定了一个两阶段过程：\n1.  **对 RHS 求值：** 必须首先对右侧表达式 $*\\mathrm{alias}$ 求值。这涉及从 $\\mathrm{alias}$ 指向的内存位置获取值。该地址位于寄存器 $r_p$ 中。唯一能从内存读取的指令是加载指令 $\\mathrm{LD}$。我们必须将值加载到一个临时存储位置，即暂存寄存器 $r_t$。\n    - 指令：$\\mathrm{LD}\\ r_{t},\\ [r_{p}]$\n    - 效果：内存地址 $r_p$ 处的值被加载到 $r_t$ 中。\n    - 开销：$3$。\n\n2.  **写入 LHS：** 从 RHS求值得到的值（现在保存在寄存器 $r_t$ 中）必须被写入与 LHS 变量 $x$ 对应的内存位置。$x$ 的地址在寄存器 $r_x$ 中。问题陈述要求这次写入必须是一个可观察事件，且不能被优化消除。这明确要求使用强制存储指令 $\\mathrm{ST!}$。\n    - 指令：$\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$\n    - 效果：$r_t$ 中的值被写入内存地址 $r_x$。这个写入操作保证会发生。\n    - 开销：$4$。\n\n按指定顺序组合这两个步骤，得到指令序列：\n1.  $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$\n2.  $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$\n\n让我们验证该序列在所有指定条件下是否正确。\n- **正确的语义：** 该序列首先将 $*\\mathrm{alias}$ 的值加载到寄存器（$r_t$）中，然后将该寄存器的值存储到 $x$。这正确地实现了“先对 RHS 求值，后写入 LHS”的语义。\n- **别名情况下的正确性：** 我们必须考虑 $r_p = r_x$ 的情况。\n    - $\\mathrm{LD}\\ r_{t},\\ [r_{p}]$ 变为 $\\mathrm{LD}\\ r_{t},\\ [r_{x}]$。$x$ 的初始值被加载到 $r_t$ 中。\n    - $\\mathrm{ST!}\\ [r_{x}],\\ r_{t}$ 将 $r_t$ 中的值存回 $x$。写入操作发生，保留了 $x$ 的值，但满足了可观察性要求。\n- **可观察性：** 使用 $\\mathrm{ST!}$ 确保了对 $x$ 的写入不会被无用存储消除优化移除，从而满足了问题的一个关键约束。\n\n此序列的总动态开销是各个指令开销的总和：\n$$ \\text{总开销} = \\text{开销}(\\mathrm{LD}) + \\text{开销}(\\mathrm{ST!}) = 3 + 4 = 7 $$\n\n我们必须确认这是最小开销。\n- 从内存加载是获取 $*\\mathrm{alias}$ 值的必要步骤。唯一能实现此目的的指令是 $\\mathrm{LD}$，其开销为 $3$。\n- 向内存存储是更新 $x$ 的必要步骤。为满足可观察性约束，必须使用 $\\mathrm{ST!}$，其开销为 $4$。\n- $\\mathrm{MOV}$ 指令（开销为 $1$）在寄存器之间移动数据。由于只有一个暂存寄存器 $r_t$，并且地址寄存器 $r_x$ 和 $r_p$ 必须分别保留到被 $\\mathrm{ST!}$ 和 $\\mathrm{LD}$ 指令使用时为止，因此没有机会使用 $\\mathrm{MOV}$ 指令来降低总开销。例如，尝试使用地址寄存器作为临时寄存器会导致一个开销更高（开销为 $8$）的序列或破坏必要信息。\n\n因此，这个双指令序列是满足所有问题约束的最有效序列。最小总动态开销为 $7$。",
            "answer": "$$\\boxed{7}$$"
        }
    ]
}