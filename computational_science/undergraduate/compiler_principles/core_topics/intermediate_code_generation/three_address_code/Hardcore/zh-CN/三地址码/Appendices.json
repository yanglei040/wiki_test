{
    "hands_on_practices": [
        {
            "introduction": "将高级语言中的控制流结构翻译成三地址码是编译器的一项核心任务。本练习将通过一个常见的条件表达式（三元运算符）来探讨这一过程，特别关注“短路求值”的实现。短路求值不仅是一种优化，更是保证程序正确性的关键，如此练习中所示，它能从结构上避免诸如“除以零”之类的运行时错误。",
            "id": "3675498",
            "problem": "您正在将表达式 $x = (a == 0 ? 0 : b / a)$ 编译为三地址码 (TAC)，其中三地址码 (TAC) 使用带有显式临时变量和标签的线性化原始指令序列。条件运算符必须保留短路语义：即如果 $a == 0$，则不得对右侧的备选项 $b / a$ 进行求值。特别地，生成的 TAC 必须在结构上避免除以零的操作。\n\n假设可以使用以下原始 TAC 指令形式：\n- 条件分支：“if $u$ relop $v$ goto $L$”。\n- 无条件跳转：“goto $L$”。\n- 二元算术运算：“$t = y$ op $z$”（其中“$/$”为一种特定的运算）。\n- 赋值：“$x = y$”。\n\n标签是分支目标的注解，其本身不产生运行时成本。所有临时变量都必须显式引入。\n\n任务：\n1) 推导一个带有显式标签和临时变量的最小 TAC 序列，以实现 $x = (a == 0 ? 0 : b / a)$，同时保留短路语义并在结构上避免除以零。请展示所使用的分支和临时变量。\n\n2) 假设每条执行的指令产生的成本如下：每个条件分支的成本为 $c_{\\mathrm{br}}$，每个无条件跳转的成本为 $c_{\\mathrm{goto}}$，每个除法操作的成本为 $c_{\\mathrm{div}}$，每次赋值的成本为 $c_{\\mathrm{as}}$。设 $p = \\Pr[a = 0]$。仅使用第一性原理（条件运算符的语义和带分支的 TAC 的线性执行），计算您的 TAC 的期望执行成本，结果应为一个关于 $p$、$c_{\\mathrm{br}}$、$c_{\\mathrm{goto}}$、$c_{\\mathrm{div}}$ 和 $c_{\\mathrm{as}}$ 的封闭形式表达式。标签不产生任何成本。假设没有其他成本来源。\n\n您的最终答案必须是一个单一的封闭形式解析表达式。不要四舍五入。不要包含单位。",
            "solution": "所述问题是有效的。这是一个编译器构造领域中定义明确的问题，提供了推导正确生成的三地址码 (TAC) 序列的期望成本所需的所有必要定义、约束和数据，从而得出一个唯一的解。该问题具有科学依据、客观且自成体系。\n\n任务是将表达式 $x = (a == 0 ? 0 : b / a)$ 编译为 TAC，然后计算期望执行成本。一个关键约束是保留短路语义，即如果 $a=0$，子表达式 $b / a$ 不得被求值。\n\n**第1部分：三地址码的推导**\n\n为了实现三元运算符的短路行为，我们必须使用条件分支指令。其逻辑如下：首先，对条件 $a == 0$ 进行求值。如果为真，控制流必须分支到将 $0$ 赋给 $x$ 的指令序列。如果条件为假，控制流应继续执行一个序列，该序列计算 $b / a$，将结果赋给 $x$，然后无条件跳转越过为真情况的代码。\n\n设 $L_1$ 为真路径代码（即当 $a == 0$ 时）的标签，$L_2$ 为紧跟在整个三元运算之后指令的标签。根据所提供的原始 TAC 指令形式，一个最小的序列是：\n\n1. `if` $a == 0$ `goto` $L_1$\n2. $t_1 = b / a$\n3. $x = t_1$\n4. `goto` $L_2$\n5. $L_1$: $x = 0$\n6. $L_2$:\n\n该序列正确地实现了表达式，同时满足所有约束条件：\n- 第一条指令 `if` $a == 0$ `goto` $L_1$ 实现了检查。如果 $a$ 确实为 $0$，控制流跳转到标签 $L_1$，完全绕过指令 $2$、$3$ 和 $4$。\n- 第二条指令 $t_1 = b / a$ 执行除法，只有在第一条指令的条件为假时（即 $a \\neq 0$）才可达。这在结构上避免了除以零。结果存储在一个显式引入的临时变量 $t_1$ 中。\n- 第三条指令 $x = t_1$ 将除法的结果赋给目标变量 $x$。\n- 第四条指令 `goto` $L_2$ 是一个无条件跳转，用于跳过真路径的代码（指令 $5$）并在条件块后恢复执行。\n- 第五条指令 $x = 0$ 位于标签 $L_1$ 处，是初始条件跳转的目标。它通过将 $0$ 赋给 $x$ 来处理真路径。\n- 标签 $L_2$ 标记了条件逻辑完成后的汇合点。\n\n该序列由 $5$ 条指令组成，对于给定的指令集和语义来说是最小的。\n\n**第2部分：期望执行成本计算**\n\n我们用 $E$ 表示的期望执行成本，由两条可能的执行路径的成本及其各自的概率加权决定。我们已知 $p = \\Pr[a = 0]$，因此 $\\Pr[a \\neq 0] = 1-p$。每种指令类型的成本给定为 $c_{\\mathrm{br}}$、$c_{\\mathrm{goto}}$、$c_{\\mathrm{div}}$ 和 $c_{\\mathrm{as}}$。\n\n**路径1：$a=0$ 的情况（发生概率为 $p$）**\n执行的指令是：\n1. `if` $a == 0$ `goto` $L_1$：执行条件分支，并进行跳转。成本为 $c_{\\mathrm{br}}$。\n2. （控制流跳转到 $L_1$）\n3. $x = 0$：执行赋值。成本为 $c_{\\mathrm{as}}$。\n此路径的总成本 $C_{\\text{true}}$ 是已执行指令成本的总和：\n$$C_{\\text{true}} = c_{\\mathrm{br}} + c_{\\mathrm{as}}$$\n\n**路径2：$a \\neq 0$ 的情况（发生概率为 $1-p$）**\n执行的指令是：\n1. `if` $a == 0$ `goto` $L_1$：执行条件分支，但不进行跳转（顺序执行）。成本为 $c_{\\mathrm{br}}$。\n2. $t_1 = b / a$：执行除法。成本为 $c_{\\mathrm{div}}$。\n3. $x = t_1$：执行赋值。成本为 $c_{\\mathrm{as}}$。\n4. `goto` $L_2$：执行无条件跳转。成本为 $c_{\\mathrm{goto}}$。\n此路径的总成本 $C_{\\text{false}}$ 是：\n$$C_{\\text{false}} = c_{\\mathrm{br}} + c_{\\mathrm{div}} + c_{\\mathrm{as}} + c_{\\mathrm{goto}}$$\n\n**计算期望成本**\n期望成本 $E$ 是各路径成本按其概率加权后的总和：\n$$E = (\\Pr[a=0] \\cdot C_{\\text{true}}) + (\\Pr[a \\neq 0] \\cdot C_{\\text{false}})$$\n代入概率和成本表达式：\n$$E = p(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{br}} + c_{\\mathrm{div}} + c_{\\mathrm{as}} + c_{\\mathrm{goto}})$$\n我们可以简化这个表达式。注意，两条路径都执行了条件分支和对 $x$ 的一次赋值。我们可以重新组合这些项：\n$$E = p(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n从前两项中提取公因式 $(c_{\\mathrm{br}} + c_{\\mathrm{as}})$：\n$$E = (p + 1 - p)(c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n$$E = 1 \\cdot (c_{\\mathrm{br}} + c_{\\mathrm{as}}) + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n这就得出了期望成本的最终封闭形式表达式：\n$$E = c_{\\mathrm{br}} + c_{\\mathrm{as}} + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})$$\n这个表达式直观地说明了总期望成本是始终执行的指令成本（$c_{\\mathrm{br}} + c_{\\mathrm{as}}$）加上仅当 $a \\neq 0$ 时才执行的指令成本（$c_{\\mathrm{div}} + c_{\\mathrm{goto}}$）乘以该情况发生的概率（$1-p$）。",
            "answer": "$$ \\boxed{c_{\\mathrm{br}} + c_{\\mathrm{as}} + (1-p)(c_{\\mathrm{div}} + c_{\\mathrm{goto}})} $$"
        },
        {
            "introduction": "高级编程语言常常将复杂的行为（例如副作用）封装在简洁的表达式中，如 `i++` 这样的后自增操作。本练习要求你准确地将一个包含副作用的赋值语句转换成三地址码。通过这个过程，你将理解编译器如何利用临时变量和严格的指令顺序来正确实现源语言的语义，确保在副作用（自增）发生之前，表达式使用的是变量的原始值。",
            "id": "3675439",
            "problem": "一种简化的命令式源语言支持整型变量和数组，以及变量的后自增运算符。考虑一个在数组索引中使用了后自增的赋值语句：\n$$\na[i++] = b + c \\cdot d\n$$\n假设遵循以下基本语义规则。\n- 后自增语义：对 $x^{++}$ 求值会得到 $x$ 的当前值作为表达式的值，并安排副作用 $x := x + 1$ 在获取该值之后、包含它的完整表达式结束之前发生。\n- 赋值语义：对 $L := R$ 求值时，会先对左侧表达式求值得到一个位置，并对右侧表达式求值得到一个值；对该位置的存储操作在两侧都求值完毕后发生。算术运算是纯粹的，没有副作用。\n- 无别名和纯粹性：变量 $a$、$b$、$c$、$d$ 和 $i$ 指向不相交的存储空间；$b$、$c$ 和 $d$ 是标量；对 $b$、$c$ 和 $d$ 求值没有副作用，也不会读取 $i$；数组 $a$ 除了通过其自身元素外，不与 $b$、$c$、$d$ 或 $i$ 中的任何一个产生别名。\n\n编译器使用临时变量 $t_1$、$t_2$、$t_3$ 将源语句降级为三地址码（TAC；three-address code）。考虑两种候选的 TAC 变体：\n\n变体 X：\n1. $t_1 := i$\n2. $t_2 := c \\cdot d$\n3. $t_3 := b + t_2$\n4. $a[t_1] := t_3$\n5. $i := i + 1$\n\n变体 Y：\n1. $t_1 := i$\n2. $i := i + 1$\n3. $t_2 := c \\cdot d$\n4. $t_3 := b + t_2$\n5. $a[t_1] := t_3$\n\n设执行任一变体前 $i$ 的初始值为任意整数，记为 $i_0$。定义 $\\Delta$ 为变体 X 中用于存储的数组索引与变体 Y 中用于存储的数组索引之差：\n$$\n\\Delta := \\big(\\text{store index in X}\\big) - \\big(\\text{store index in Y}\\big).\n$$\n在所述的语义规则和假设下，确定 $\\Delta$ 的精确值。你的最终答案必须是一个实数。不需要四舍五入。最终答案应表示为一个不带任何单位的纯数字。",
            "solution": "问题要求确定两个三地址码变体（标记为变体 X 和变体 Y）中存储指令所使用的数组索引之差 $\\Delta$。\n\n设在执行任一代码变体之前，整型变量 $i$ 的初始值为 $i_0$。我们的分析将从这个初始状态开始，通过跟踪每个变体的执行过程来进行。\n\n首先，我们分析变体 X。指令序列如下：\n1.  $t_1 := i$\n2.  $t_2 := c \\cdot d$\n3.  $t_3 := b + t_2$\n4.  $a[t_1] := t_3$\n5.  $i := i + 1$\n\n我们跟踪相关变量的值，特别是作为数组索引的 $i$ 和临时变量 $t_1$。\n-   最初，$i$ 的值为 $i_0$。\n-   在指令 1，$t_1 := i$ 中，$i$ 的当前值 $i_0$ 被赋给临时变量 $t_1$。此指令执行后，$t_1$ 的值为 $i_0$。$i$ 的值仍为 $i_0$。\n-   指令 2 和 3 计算原始赋值语句的右侧。它们不涉及或修改变量 $i$ 或 $t_1$。因此，在指令 4 之前，$t_1$ 的值仍然是 $i_0$。\n-   指令 4，$a[t_1] := t_3$，是存储操作。使用的数组索引是变量 $t_1$ 的值。在执行的这一点上，$t_1$ 的值是 $i_0$。因此，变体 X 中的存储索引是 $i_0$。\n-   指令 5，$i := i + 1$，将 $i$ 的值增加。这发生在存储操作（通过 $t_1$）使用了 $i$ 的原始值之后。\n\n根据此分析，我们得出结论，变体 X 中的存储索引为 $i_0$。\n\n接下来，我们分析变体 Y。指令序列如下：\n1.  $t_1 := i$\n2.  $i := i + 1$\n3.  $t_2 := c \\cdot d$\n4.  $t_3 := b + t_2$\n5.  $a[t_1] := t_3$\n\n我们为此变体跟踪 $i$ 和 $t_1$ 的值，同样从 $i = i_0$ 开始。\n-   最初，$i$ 的值为 $i_0$。\n-   在指令 1，$t_1 := i$ 中，$i$ 的当前值 $i_0$ 被赋给临时变量 $t_1$。此指令执行后，$t_1$ 的值为 $i_0$。\n-   在指令 2，$i := i + 1$ 中，$i$ 的值被增加到 $i_0 + 1$。此指令修改了 $i$ 的存储位置。但是，它不影响临时变量 $t_1$ 的值，该变量占用一个不同的存储位置，并且已经持有值 $i_0$。\n-   指令 3 和 4 计算右侧表达式，并且不修改 $i$ 或 $t_1$。在指令 5 之前，$t_1$ 的值仍为 $i_0$，而 $i$ 的值为 $i_0+1$。\n-   指令 5，$a[t_1] := t_3$，是存储操作。使用的数组索引是 $t_1$ 的值。在这一点上，$t_1$ 的值仍然是 $i_0$。因此，变体 Y 中的存储索引是 $i_0$。\n\n根据此分析，我们得出结论，变体 Y 中的存储索引也是 $i_0$。\n\n问题将 $\\Delta$ 定义为两个变体存储索引之差：\n$$\n\\Delta := (\\text{store index in X}) - (\\text{store index in Y})\n$$\n代入我们确定的值：\n$$\n\\Delta = i_0 - i_0\n$$\n$$\n\\Delta = 0\n$$\n变体 X 和变体 Y 中用于存储操作的数组索引之差为 $0$。根据后自增语义规则的要求，两个变体都正确地捕获了自增前 $i$ 的值以用作数组索引。自增指令 `i := i + 1` 的不同位置并没有改变用于索引的值，因为该值在两个序列的开头都已保存在临时变量 $t_1$ 中。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在掌握了单个语句的翻译后，我们可以挑战更复杂的结构，例如包含递归的完整函数。本练习将引导你为递归阶乘函数生成三地址码，并跟踪其执行过程。通过细致地追踪函数调用、参数传递以及临时变量的动态创建，你将深刻理解三地址码如何模拟程序的运行时行为，包括调用栈和局部状态管理的底层机制。",
            "id": "3675465",
            "problem": "给定一个整数输入 $n \\ge 0$ 的阶乘函数 $f(n)$ 的高级递归定义：\n如果 $n \\le 1$，则返回 $1$，否则返回 $n \\times f(n-1)$。\n从编译器原理中三地址码（TAC）的核心定义出发——其中每条 TAC 指令最多有三个地址，并遵循包含临时变量、标签、条件和无条件分支、参数传递、过程调用和返回的规范指令集——请执行以下任务。\n\n1. 使用以下指令形式，将函数 $f(n)$ 翻译成规范的三地址码形式：\n- 将一个基本操作的结果赋值给一个新的临时变量：$t := x \\ \\text{op} \\ y$。\n- 将一个布尔比较的结果赋值给一个新的临时变量：$t := x \\ \\text{relop} \\ y$。\n- 条件分支：$\\text{if} \\ t \\ \\text{goto} \\ L$。\n- 无条件跳转：$\\text{goto} \\ L$。\n- 参数传递：对每个实际参数使用 $\\text{param} \\ x$。\n- 过程调用，返回值存入一个新的临时变量：$t := \\text{call} \\ f, k$，其中 $k$ 是由前面的 $\\text{param}$ 指令传递的实际参数的数量。\n- 从过程返回：$\\text{ret} \\ x$。\n- 标签：$L:$，它不是一个可执行指令。\n\n请遵循以下约定。\n- 每次执行对临时变量的赋值都会引入一个新的临时变量 $t_i$，其索引 $i \\in \\mathbb{N}$ 是全局递增的，在整个运行过程中的第一次此类赋值时从 $i=1$ 开始。序列 $t_1, t_2, \\dots$ 记录了所有过程中临时变量的动态创建顺序。\n- 标签不计为执行的指令。当控制流经过指令 $\\text{if}$、$\\text{goto}$、$\\text{param}$、$\\text{call}$ 和 $\\text{ret}$ 时，它们被计为已执行的指令，但它们本身不创建新的临时变量，除了上述指定的 $\\text{call}$ 形式会将返回值赋给一个新的临时变量。基本情况返回常量时直接使用 $\\text{ret} \\ 1$，不创建临时变量。\n- 求值顺序为从左到右，递归遵循自然的深度优先调用序列。\n\n一个驱动程序执行以下代码来调用 $f$：\n- $\\text{param} \\ n$\n- $t := \\text{call} \\ f, 1$\n- $\\text{halt}$\n\n假设输入为 $n = 7$。\n\n在这些约定下，推导出一个正确的 $f(n)$ 的 TAC。然后，通过跟踪动态调用序列和临时变量 $t_i$ 在运行时（包括驱动程序的调用）的创建顺序，确定在驱动程序调用 $f$ 的整个执行过程中直到从 $f$ 返回时所创建的最大临时变量 $t_{i_{\\max}}$ 的索引 $i_{\\max}$。你的最终答案必须是一个单独的数字（无单位，无解释），精确表示 $i_{\\max}$（不进行四舍五入）。",
            "solution": "该问题陈述经证实具有科学依据、问题明确、客观且自成一体。它提出了一个编译器理论中的标准问题，涉及为递归函数生成和执行三地址码。所提供的临时变量创建和指令执行规则是明确且一致的，从而可以得出一个唯一的、确定性的解。\n\n首先，我们必须将递归阶乘函数 $f(n)$ 翻译成指定的三地址码（TAC）格式。该函数定义如下：\n如果 $n \\le 1$，则返回 $1$，否则返回 $n \\times f(n-1)$。\n\n假设传递给函数 $f$ 的单个参数由地址 `arg` 表示。$f$ 的一个规范 TAC 表示如下：\n\n`L_f_begin:`\n$t_a := \\text{arg} \\le 1$\n$\\text{if } t_a \\text{ goto } \\text{L_base}$\n$t_b := \\text{arg} - 1$\n$\\text{param } t_b$\n$t_c := \\text{call } f, 1$\n$t_d := \\text{arg} \\times t_c$\n$\\text{ret } t_d$\n$\\text{goto } \\text{L_end}$\n`L_base:`\n$\\text{ret } 1$\n`L_end:`\n\n在这里，$t_a、t_b、t_c$ 和 $t_d$ 代表动态创建的临时变量。根据问题的规则，在创建它们的指令执行时，每个变量都将在序列 $t_1, t_2, \\dots$ 中获得一个唯一的、全局递增的索引 $i$。\n\n任务是找出由驱动程序发起的 $f(7)$ 执行期间创建的临时变量的最大索引 $i_{\\max}$。我们必须跟踪动态执行序列。在此跟踪过程中，临时变量由四种类型的指令创建：\n1. 驱动程序的调用：`t := call f, 1`\n2. 比较：`t := arg = 1`\n3. 减法：`t := arg - 1`\n4. 乘法：`t := arg * t_result`\n\n跟踪从输入 $n=7$ 的驱动程序执行开始。设 $i$ 为临时变量的全局索引，初始化为 $0$。\n\n1.  **驱动程序执行：**\n    - 执行 `param 7`。\n    - 执行 `t := call f, 1`。这是第一条创建临时变量的指令。索引 $i$ 变为 $1$。创建一个临时变量 $t_1$ 来保存 $f(7)$ 的最终返回值。\n    - 控制权传递给函数 $f$，其参数 `arg` 设置为 $7$。\n\n2.  **递归下降：** 执行沿着递归调用链向下进行。\n    - **在 `f(7)` 中** (`arg = 7`)：\n        - 评估条件 `arg = 1`。执行 `t_2 := 7 = 1`。$i$ 变为 $2$。\n        - 分支不被采纳。\n        - 计算下一次调用的参数。执行 `t_3 := 7 - 1`。$i$ 变为 $3$。\n        - 执行 `param t_3`。\n        - 进行递归调用。执行 `t_4 := call f, 1`。$i$ 变为 $4$。控制权传递给 `f(6)`。\n    - **在 `f(6)` 中** (`arg = 6`)：\n        - 执行 `t_5 := 6 = 1`。$i$ 变为 $5$。\n        - 执行 `t_6 := 6 - 1`。$i$ 变为 $6$。\n        - 执行 `t_7 := call f, 1`。$i$ 变为 $7$。控制权传递给 `f(5)`。\n    - **在 `f(5)` 中** (`arg = 5`)：\n        - 执行 `t_8 := 5 = 1`。$i$ 变为 $8$。\n        - 执行 `t_9 := 5 - 1`。$i$ 变为 $9$。\n        - 执行 `t_{10} := call f, 1`。$i$ 变为 $10$。控制权传递给 `f(4)`。\n    - **在 `f(4)` 中** (`arg = 4`)：\n        - 执行 `t_{11} := 4 = 1`。$i$ 变为 $11$。\n        - 执行 `t_{12} := 4 - 1`。$i$ 变为 $12$。\n        - 执行 `t_{13} := call f, 1`。$i$ 变为 $13$。控制权传递给 `f(3)`。\n    - **在 `f(3)` 中** (`arg = 3`)：\n        - 执行 `t_{14} := 3 = 1`。$i$ 变为 $14$。\n        - 执行 `t_{15} := 3 - 1`。$i$ 变为 $15$。\n        - 执行 `t_{16} := call f, 1`。$i$ 变为 $16$。控制权传递给 `f(2)`。\n    - **在 `f(2)` 中** (`arg = 2`)：\n        - 执行 `t_{17} := 2 = 1`。$i$ 变为 $17$。\n        - 执行 `t_{18} := 2 - 1`。$i$ 变为 $18$。\n        - 执行 `t_{19} := call f, 1`。$i$ 变为 $19$。控制权传递给 `f(1)`。\n\n3.  **基本情况：**\n    - **在 `f(1)` 中** (`arg = 1`)：\n        - 评估条件 `arg = 1`。执行 `t_{20} := 1 = 1`。此时 $i$ 的值为 $20$。\n        - 采纳条件分支 `if t_{20} goto L_base`。\n        - 执行 `ret 1`。这不会创建新的临时变量。函数返回值为 $1$。递归开始回溯。\n\n4.  **递归回升：** 控制权沿调用栈向上返回。\n    - **返回到 `f(2)`：**\n        - 返回值 $1$ 被赋给临时变量 `t_{19}`。\n        - 执行乘法。执行 `t_{21} := 2 \\times t_{19}`。此时 $i$ 的值为 $21$。\n        - 执行 `ret t_{21}`，返回值为 $2$。\n    - **返回到 `f(3)`：**\n        - 返回值 $2$ 被赋给 `t_{16}`。\n        - 执行 `t_{22} := 3 \\times t_{16}`。此时 $i$ 的值为 $22$。\n        - 函数返回值为 $6$。\n    - **返回到 `f(4)`：**\n        - 返回值 $6$ 被赋给 `t_{13}`。\n        - 执行 `t_{23} := 4 \\times t_{13}`。此时 $i$ 的值为 $23$。\n        - 函数返回值为 $24$。\n    - **返回到 `f(5)`：**\n        - 返回值 $24$ 被赋给 `t_{10}`。\n        - 执行 `t_{24} := 5 \\times t_{10}`。此时 $i$ 的值为 $24$。\n        - 函数返回值为 $120$。\n    - **返回到 `f(6)`：**\n        - 返回值 $120$ 被赋给 `t_7`。\n        - 执行 `t_{25} := 6 \\times t_7`。此时 $i$ 的值为 $25$。\n        - 函数返回值为 $720$。\n    - **返回到 `f(7)`：**\n        - 返回值 $720$ 被赋给 `t_4`。\n        - 执行最后的乘法。执行 `t_{26} := 7 \\times t_4`。此时 $i$ 的值为 $26$。\n        - 执行 `ret t_{26}`，返回值为 $5040$。\n\n5.  **最终返回到驱动程序：**\n    - 返回值 $5040$ 被赋给初始的临时变量 `t_1`。\n    - 执行 `halt` 指令。\n\n在整个过程中创建的最后一个临时变量是 $t_{26}$。因此，最大索引 $i_{\\max}$ 是 $26$。\n\n我们可以为输入 $n > 1$ 概括出创建的临时变量数量：\n- 初始驱动程序调用产生 $1$ 个临时变量。\n- 对于从 $f(n)$ 到 $f(2)$ 的每次递归调用（共 $n-1$ 次），在下降阶段创建 $3$ 个临时变量（`=`、`-`、`call`）。总计：$3 \\times (n-1)$。\n- 对于基本情况的调用 $f(1)$，创建 $1$ 个临时变量（`=`）。\n- 对于从 $f(1)$ 到 $f(n-1)$ 的每次返回（共 $n-1$ 次返回），为乘法创建 $1$ 个临时变量。总计：$1 \\times (n-1)$。\n对于 $n > 1$ 的总临时变量数：$i_{\\max} = 1 + 3(n-1) + 1 + 1(n-1) = 2 + 4(n-1) = 4n - 2$。\n对于给定的输入 $n=7$，此公式得出：$i_{\\max} = 4(7) - 2 = 28 - 2 = 26$。这证实了详细跟踪的结果。",
            "answer": "$$\\boxed{26}$$"
        }
    ]
}