{
    "hands_on_practices": [
        {
            "introduction": "本练习聚焦于短路求值的核心原则。通过分析一个嵌套的布尔表达式，你将应用逻辑“与”（$E_1 \\land E_2$）和逻辑“或”（$E_1 \\lor E_2$）的规则，来精确判断哪些函数调用是必需的，哪些则会被跳过。这项练习旨在提高你追踪执行流的能力，并通过计算函数调用的期望次数，将抽象的逻辑规则与具体、可量化的性能影响联系起来。",
            "id": "3677918",
            "problem": "考虑一门具有从左到右求值顺序的语言中，短路布尔表达式到底层控制流的降级（lowering）过程。该语言实现了短路逻辑与（AND）和逻辑或（OR），记为 $E_{1} \\land E_{2}$ 和 $E_{1} \\lor E_{2}$，其求值语义如下：对于 $E_{1} \\land E_{2}$，只有当 $E_{1}$ 的值为 $\\text{true}$ 时，才会对 $E_{2}$ 求值；对于 $E_{1} \\lor E_{2}$，只有当 $E_{1}$ 的值为 $\\text{false}$ 时，才会对 $E_{2}$ 求值。一个正确的到标签和条件跳转的降级过程必须保留这些语义，以确保那些其值不会影响最终结果的操作数不被求值。\n\n给定四个均返回布尔值的函数 $f(), g(), h(), k()$。高级表达式为\n$$\n(f() \\land g()) \\lor (h() \\land k()).\n$$\n假设编译器目标是使用基本块和条件分支的控制流图（CFG）结构；正确的降级必须确保只有确定表达式值所必需的操作数才被执行。这些函数的库合约警告说，在结果已经确定后执行不必要的操作数可能会因副作用而导致未定义行为；因此，降级过程必须严格遵守短路控制流，并且不应推测性地对任何操作数求值。\n\n假设每次独立调用的返回值与其他调用无关，并且在多次求值中是独立同分布的，其中\n- $\\mathbb{P}(f() \\text{ 返回 } \\text{true}) = p_{f}$，\n- $\\mathbb{P}(g() \\text{ 返回 } \\text{true}) = p_{g}$，\n- $\\mathbb{P}(h() \\text{ 返回 } \\text{true}) = p_{h}$，\n- $\\mathbb{P}(k() \\text{ 返回 } \\text{true}) = p_{k}$。\n假设在函数之间以及对整个表达式的重复求值之间都存在独立性。\n\n一个程序在独立输入上对上述表达式求值 $N$ 次。在一个保留了短路特性并确保只有必要调用发生的正确降级下，这 $N$ 次求值过程中执行的函数调用总数的期望值的闭式解析表达式是什么？请仅用 $N$、$p_{f}$、$p_{g}$ 和 $p_{h}$ 表示你的答案。不要四舍五入；请给出精确表达式。",
            "solution": "问题陈述经过严谨分析，被认为是有效的。它在科学上基于编译器设计和概率论的原理，问题定义良好、客观且自洽。最终表达式必须不包含 $p_k$ 这一最初看似奇特的特点，是短路求值语义的直接逻辑结果，这使得函数调用的数量与链中最后一个潜在函数的返回值无关。\n\n问题要求计算在 $N$ 次独立试验中对表达式 $(f() \\land g()) \\lor (h() \\land k())$ 求值时函数调用总数的期望值。求值遵循从左到右的短路语义。\n\n设 $C$ 是表示单次求值中函数调用次数的随机变量。在 $N$ 次求值中的总调用次数为 $C_{total} = \\sum_{i=1}^{N} C_i$，其中 $C_i$ 是第 $i$ 次求值中的调用次数。根据期望的线性性，总调用次数的期望值为 $E[C_{total}] = \\sum_{i=1}^{N} E[C_i]$。由于所有求值都是独立同分布的，因此对所有 $i$ 都有 $E[C_i] = E[C]$，所以 $E[C_{total}] = N \\cdot E[C]$。\n\n我们可以通过对单次求值中的各个函数调用应用期望的线性性来求得 $E[C]$。设 $I_f, I_g, I_h, I_k$ 为指示变量，如果函数 $x()$ 被调用，则 $I_x = 1$，否则 $I_x = 0$。单次求值中的总调用次数为 $C = I_f + I_g + I_h + I_k$。\n那么，期望调用次数为：\n$$\nE[C] = E[I_f + I_g + I_h + I_k] = E[I_f] + E[I_g] + E[I_h] + E[I_k]\n$$\n指示变量的期望是它所指示事件的概率，所以 $E[I_x] = \\mathbb{P}(x() \\text{ 被调用})$。我们现在将根据指定的短路求值规则来计算这些概率。\n\n1.  **调用 $f()$ 的概率**：函数 $f()$ 是表达式中的第一个操作数。它总是被求值。\n    $$\n    \\mathbb{P}(f() \\text{ 被调用}) = 1\n    $$\n\n2.  **调用 $g()$ 的概率**：表达式的形式为 $E_1 \\land E_2$，其中 $E_1 = f()$。函数 $g()$ 是第二个操作数的一部分。由于短路效应，$g()$ 被调用的当且仅当 $f()$ 的求值结果为 $\\text{true}$。\n    $$\n    \\mathbb{P}(g() \\text{ 被调用}) = \\mathbb{P}(f() \\text{ 返回 true}) = p_f\n    $$\n\n3.  **调用 $h()$ 的概率**：整个表达式的形式为 $(f() \\land g()) \\lor (h() \\land k())$。设第一个子表达式为 $E_{left} = f() \\land g()$。作为第二个子表达式的第一部分，函数 $h()$ 被调用的当且仅当 $E_{left}$ 的求值结果为 $\\text{false}$。$E_{left}$ 为 false 的情况是：或者 $f()$ 返回 $\\text{false}$，或者 $f()$ 返回 $\\text{true}$ 但 $g()$ 返回 $\\text{false}$。这些是互斥事件。\n    $$\n    \\mathbb{P}(h() \\text{ 被调用}) = \\mathbb{P}(E_{left} \\text{ 为 false}) = \\mathbb{P}(f() \\text{ 为 false}) + \\mathbb{P}(f() \\text{ 为 true} \\land g() \\text{ 为 false})\n    $$\n    利用给定的概率和独立性：\n    $$\n    \\mathbb{P}(h() \\text{ 被调用}) = (1 - p_f) + p_f(1 - p_g) = 1 - p_f + p_f - p_f p_g = 1 - p_f p_g\n    $$\n\n4.  **调用 $k()$ 的概率**：函数 $k()$ 是子表达式 $h() \\land k()$ 的第二部分。它被调用的当且仅当求值过程到达这个子表达式（即 $h()$ 被调用）并且 $h()$ 的求值结果为 $\\text{true}$。\n    $$\n    \\mathbb{P}(k() \\text{ 被调用}) = \\mathbb{P}(h() \\text{ 被调用 且 } h() \\text{ 返回 true})\n    $$\n    由于 $h()$ 的返回值与导致其被调用的条件无关：\n    $$\n    \\mathbb{P}(k() \\text{ 被调用}) = \\mathbb{P}(h() \\text{ 被调用}) \\times \\mathbb{P}(h() \\text{ 返回 true}) = (1 - p_f p_g) p_h\n    $$\n    关键要注意的是，调用 $k()$ 的决定取决于 $h()$ 的返回值（概率为 $p_h$），而不取决于 $k()$ 本身的返回值（那将是 $p_k$）。因此，调用次数的表达式正确地排除了 $p_k$，正如问题陈述所要求的那样。\n\n现在我们把这些概率相加，求出单次求值的期望调用次数 $E[C]$：\n$$\nE[C] = \\mathbb{P}(f() \\text{ 被调用}) + \\mathbb{P}(g() \\text{ 被调用}) + \\mathbb{P}(h() \\text{ 被调用}) + \\mathbb{P}(k() \\text{ 被调用})\n$$\n$$\nE[C] = 1 + p_f + (1 - p_f p_g) + (1 - p_f p_g)p_h\n$$\n这个表达式可以通过提出公因式 $(1 - p_f p_g)$ 来简化：\n$$\nE[C] = 1 + p_f + (1 - p_f p_g)(1 + p_h)\n$$\n展开以得到另一种表示形式：\n$$\nE[C] = 1 + p_f + 1 + p_h - p_f p_g - p_f p_g p_h = 2 + p_f + p_h - p_f p_g - p_f p_g p_h\n$$\n最后，在 $N$ 次独立求值中，函数调用的期望总次数是这个值的 $N$ 倍：\n$$\nE[C_{total}] = N \\cdot E[C] = N (1 + p_f + (1 - p_f p_g)(1 + p_h))\n$$\n这就是用 $N$、$p_f$、$p_g$ 和 $p_h$ 表示的闭式解析表达式。",
            "answer": "$$\n\\boxed{N(1 + p_f + (1 - p_f p_g)(1 + p_h))}\n$$"
        },
        {
            "introduction": "在理解了控制流的逻辑之后，本练习将深入探讨其实现的具体机制。你将把一个高级循环结构（do-while）转换为其机器级表示，重点是计算程序计数器（$PC$）相对跳转所需的精确位移。这个动手计算的过程揭示了编译器如何通过操作程序计数器来创建循环，从而在抽象的控制结构和具体的机器指令之间架起一座桥梁。",
            "id": "3677994",
            "problem": "考虑一个编译器，它使用经典的布尔表达式短路求值回填技术，将一个高级 do-while 循环翻译成三地址码。目标机器使用程序计数器（PC）相对条件分支：位于指令地址 $i$ 的条件分支指令编码一个整数位移 $\\delta$，当且仅当 $T = (i + 1) + \\delta$ 时，控制流转移到目标地址 $T$。其中，地址按指令计数，标签不占用指令槽。\n\n对于形式为 do $S$ while $(B)$ 的语句，其翻译方案基于以下核心定义：\n- do-while 的语义：循环体 $S$ 在布尔表达式 $B$ 被求值之前至少执行一次；如果 $B$ 的值为真，则控制流重复该循环；否则，退出循环。\n- 布尔表达式的回填：翻译 $B$ 会生成一个代码序列以及两个列表 $B.true$ 和 $B.false$，这两个列表包含目标地址尚不确定的条件和无条件跳转指令的地址。回填 $B.true$ 会将循环头作为目标地址，使得为真时继续循环；回填 $B.false$ 会将循环出口作为目标地址，使得为假时离开循环。\n\n假设某个特定的 do-while 循环有以下具体的布局约束：\n- 循环的第一条指令（循环头）位于地址 $pc_{0} = 1000$。\n- 翻译循环体 $S$ 产生恰好 $\\ell_{S} = 73$ 条指令。\n- 翻译布尔表达式 $B$ 产生恰好 $\\ell_{B} = 9$ 条指令，其位于地址 $pc_{end}$ 的最后一条指令是唯一的条件分支指令，其为真时的目标将被回填到循环头。所有标签不占用指令槽，并且在回填过程中不引入额外的指令。\n\n在这些条件下，将 $B$ 的代码紧跟在循环体 $S$ 之后放置，编译器将 $B.true$ 回填到位于 $pc_{0}$ 的循环头。仅使用上述基本原理和定义，确定当 $B$ 的值为真时，为了跳回到循环头，必须在位于 $pc_{end}$ 的条件分支指令中编码的带符号 PC 相对位移 $\\delta$。请以整数形式提供最终答案，无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是合理、独立且定义明确的。它提出了一个编译器构造中的标准场景，涉及将控制流语句翻译成带有程序计数器（PC）相对寻址的机器级指令。所有必要的参数都已提供，目标也已明确定义。\n\n目标是确定一个条件分支指令的带符号 PC 相对位移，记为 $\\delta$。目标地址 $T$、分支指令地址 $i$ 和位移 $\\delta$ 之间的关系由以下公式给出：\n$$T = (i + 1) + \\delta$$\n该公式模拟了一种常见的体系结构，其中在应用位移之前，PC 会前进到下一条指令的地址。为了求出 $\\delta$，我们可以重排这个方程：\n$$\\delta = T - (i + 1)$$\n\n我们必须根据问题的具体说明来确定目标地址 $T$ 和分支指令地址 $i$ 的值。\n\n1.  **确定目标地址 $T$**：\n    问题描述了 `do S while (B)` 循环的翻译。在这种循环中，如果条件 $B$ 为真，控制流会跳回到循环的开始处，重新执行循环体 $S$。问题指出，条件分支的为真目标被回填到循环头。循环头的地址，即语句 $S$ 的第一条指令的地址，被给出为 $pc_{0}$。\n    因此，目标地址 $T$ 是：\n    $$T = pc_{0} = 1000$$\n\n2.  **确定分支指令地址 $i$**：\n    条件分支被指定为为布尔表达式 $B$ 生成的代码的最后一条指令。要找到它的地址，我们必须确定生成代码在内存中的布局。\n    `do S while (B)` 生成的代码结构是 $S$ 的代码紧跟着 $B$ 的代码。\n    - 循环的第一条指令，即循环体 $S$ 代码的开始，位于地址 $pc_{0} = 1000$。\n    - $S$ 的代码包含 $\\ell_{S} = 73$ 条指令。这些指令占据了从 $pc_{0}$ 到 $pc_{0} + \\ell_{S} - 1$ 的地址范围。\n      具体来说，是从地址 $1000$ 到 $1000 + 73 - 1 = 1072$。\n    - 布尔表达式 $B$ 的代码紧跟在 $S$ 的代码之后。因此，它的第一条指令位于地址 $(pc_{0} + \\ell_{S} - 1) + 1 = pc_{0} + \\ell_{S}$。\n      具体来说，是地址 $1073$。\n    - $B$ 的代码包含 $\\ell_{B} = 9$ 条指令。该代码块的最后一条指令是我们正在寻找的条件分支指令。它的地址 $i$，在问题中记为 $pc_{end}$，是序列中的最后一个地址。\n    该地址可以计算为 $B$ 代码块的起始地址加上其指令数再减一。\n    $$i = pc_{end} = (pc_{0} + \\ell_{S}) + \\ell_{B} - 1$$\n    代入给定值：\n    $$i = 1000 + 73 + 9 - 1 = 1000 + 82 - 1 = 1081$$\n    所以，条件分支指令位于地址 $i = 1081$。\n\n3.  **计算位移 $\\delta$**：\n    现在我们将确定的 $T$ 和 $i$ 的值代入重排后的 $\\delta$ 公式中：\n    $$\\delta = T - (i + 1)$$\n    $$\\delta = 1000 - (1081 + 1)$$\n    $$\\delta = 1000 - 1082$$\n    $$\\delta = -82$$\n\n位移是负数，这对于将控制流返回到程序中较早点（循环头）的跳转是符合预期的。跳转的幅度为 $82$，对应于循环体 ($S$) 和条件检查 ($B$) 中的总指令数，即 $\\ell_S + \\ell_B = 73 + 9 = 82$。从地址 $i = 1081$ 的指令发出的跳转必须到达 $T = 1000$。PC 首先增加到 $1082$，然后加上位移 $\\delta = -82$，得到正确的目标地址 $1082 + (-82) = 1000$。",
            "answer": "$$\\boxed{-82}$$"
        },
        {
            "introduction": "最后的这项练习将挑战你进行逆向工程，从非结构化的“面条式代码”出发，重构其等价的高级结构化形式。通过重建程序的逻辑并构建其控制流图（Control-Flow Graph, CFG），你将发现不同的源码级表示可以产生完全相同的底层控制结构。计算圈复杂度为你提供了一个形式化的度量标准，用以分析和验证控制流的复杂性，从而巩固你对程序结构与分析的理解。",
            "id": "3677965",
            "problem": "考虑以下基于 goto 的程序，它使用整数变量 $i$、$n$、$s$、$t$ 和 $r$。初始条件为 $s \\leftarrow 0$ 且 $n \\ge 0$ 是一个给定的输入。标签用整数 $k$ 表示为 $L_{k}$，控制转移使用条件或无条件跳转。\n\n$L_{0}$: $i \\leftarrow 0$; $s \\leftarrow 0$; goto $L_{1}$\n\n$L_{1}$: if $i \\ge n$ goto $L_{7}$ else goto $L_{2}$\n\n$L_{2}$: $t \\leftarrow i \\times i$; if $(t \\pmod 3) = 0$ goto $L_{5}$ else goto $L_{4}$\n\n$L_{4}$: $s \\leftarrow s + t$; goto $L_{6}$\n\n$L_{5}$: $s \\leftarrow s - i$; goto $L_{6}$\n\n$L_{6}$: $i \\leftarrow i + 1$; goto $L_{1}$\n\n$L_{7}$: if $s  0$ goto $L_{9}$ else goto $L_{8}$\n\n$L_{8}$: $r \\leftarrow s$; goto $L_{10}$\n\n$L_{9}$: $r \\leftarrow -s$; goto $L_{10}$\n\n$L_{10}$: halt\n\n从编译器设计中转换控制流语句的基本原则出发，即将结构化构造转换为带有标签、条件跳转和基本块的中间表示（IR），请执行以下操作：\n\n1. 使用循环和条件语句将此程序重构为结构化构造，使其在语义上等同于给定的基于 goto 的版本，并且不改变为 $r$ 计算的可观察行为。\n2. 使用针对 $if$ 语句和 $while$ 循环的标准转换方案，将结构化版本重新降级为规范的三地址码中间表示（IR），引入标签和条件/无条件跳转来划分基本块。\n3. 构建重新降级的 IR 的控制流图（CFG），识别其基本块以及它们之间的有向边，并证明该 CFG 与原始基于 goto 的程序的 CFG 同构（从而建立 IR 的等价性）。\n4. 计算重新降级的 IR 的 CFG 的圈复杂度，结果为一个实数值。将最终的圈复杂度值作为您的答案。无需四舍五入。\n\n您的最终答案必须是重新降级的 IR 的 CFG 的圈复杂度值。",
            "solution": "问题陈述是有效的。它在编译器原理领域内提出了一个明确定义的任务，提供了一个用于控制流分析的、自包含的、逻辑一致且无歧义的基于 goto 的程序。该问题在已建立的计算机科学理论中有科学依据，可以通过形式化、客观的方法解决。我们将继续执行四个要求的任务。\n\n### 1. 重构为结构化构造\n\n可以分析所提供的基于 goto 的程序，以揭示其底层的结构化逻辑。\n\n- 标签 $L_{0}$ 处的语句（$i \\leftarrow 0; s \\leftarrow 0;$）是在任何循环之前执行一次的初始化步骤。\n- 从 $L_{1}$ 开始并以从 $L_{6}$ 跳回 $L_{1}$ 结束的代码块形成一个循环。$L_{1}$ 处的入口条件是 `if i >= n goto L_exit`，这等同于一个 `while (i  n)` 循环。\n- 在这个循环内部（标签 $L_{2}$ 到 $L_{6}$），程序计算 $t \\leftarrow i \\times i$。根据条件 $(t \\pmod 3) = 0$，它遵循两条路径之一：\n    - 如果 $(t \\pmod 3) = 0$ 为假，则程序前进到 $L_{4}$ 并执行 $s \\leftarrow s + t$。\n    - 如果 $(t \\pmod 3) = 0$ 为真，则程序前进到 $L_{5}$ 并执行 $s \\leftarrow s - i$。\n    - 两条路径在 $L_{6}$ 处汇合，在此处循环计数器 `i` 递增（$i \\leftarrow i + 1$），然后控制返回到 $L_{1}$ 处的循环条件。这个结构是一个嵌套在循环内的 `if-else` 语句。\n- 循环终止后（当 $i \\ge n$ 时），控制转移到 $L_{7}$。标签 $L_{7}$、$L_{8}$ 和 $L_{9}$ 处的语句计算 $s$ 的绝对值并将其存储在 $r$ 中。具体来说，`if s  0` 则 $r \\leftarrow -s$，否则 $r \\leftarrow s$。\n- 最后，程序在 $L_{10}$ 处停止。\n\n基于此分析，语义上等价的结构化程序是：\n```c\ns = 0;\ni = 0;\nwhile (i  n) {\n    t = i * i;\n    if ((t % 3) == 0) {\n        s = s - i;\n    } else {\n        s = s + t;\n    }\n    i = i + 1;\n}\nif (s  0) {\n    r = -s;\n} else {\n    r = s;\n}\nhalt;\n```\n注意，初始化 $s \\leftarrow 0$ 在问题中明确给出，并且也出现在 $L_0$ 处。其效果是相同的。\n\n### 2. 重新降级为三地址码 IR\n\n使用结构化控制流语句的标准转换方案，我们可以将上述程序降级为三地址码中间表示（IR）。此过程涉及创建由标签和跳转划分的基本块。\n\n- **块 $B'_{0}$ (初始化):**\n  $i \\leftarrow 0$\n  $s \\leftarrow 0$\n  goto $B'_{1}$\n\n- **块 $B'_{1}$ (循环头):**\n  if $i \\ge n$ goto $B'_{6}$\n  else goto $B'_{2}$\n\n- **块 $B'_{2}$ (循环体，条件):**\n  $t \\leftarrow i \\times i$\n  $tmp \\leftarrow t \\pmod 3$\n  if $tmp = 0$ goto $B'_{4}$\n  else goto $B'_{3}$\n\n- **块 $B'_{3}$ (内部 `else` 分支):**\n  $s \\leftarrow s + t$\n  goto $B'_{5}$\n\n- **块 $B'_{4}$ (内部 `then` 分支):**\n  $s \\leftarrow s - i$\n  goto $B'_{5}$\n\n- **块 $B'_{5}$ (循环递增):**\n  $i \\leftarrow i + 1$\n  goto $B'_{1}$\n\n- **块 $B'_{6}$ (循环后，绝对值):**\n  if $s  0$ goto $B'_{8}$\n  else goto $B'_{7}$\n\n- **块 $B'_{7}$ (绝对值 `else` 分支):**\n  $r \\leftarrow s$\n  goto $B'_{9}$\n\n- **块 $B'_{8}$ (绝对值 `then` 分支):**\n  $r \\leftarrow -s$\n  goto $B'_{9}$\n\n- **块 $B'_{9}$ (停止):**\n  halt\n\n该 IR 由 $10$ 个基本块组成，标记为 $B'_{0}$ 到 $B'_{9}$。\n\n### 3. 控制流图（CFG）的构建与同构\n\n首先，我们识别**原始**基于 goto 的程序的基本块。一个基本块始于一个作为跳转目标的标签或程序的开头，并结束于一个跳转或紧邻另一个首指令之前。原始代码中的首指令是标签 $L_{0}, L_{1}, L_{2}, L_{4}, L_{5}, L_{6}, L_{7}, L_{8}, L_{9}, L_{10}$ 处的指令。这产生了 $10$ 个基本块，我们用 $B_{k}$ 表示从标签 $L_{k}$ 开始的块（即 $B_0, B_1, B_2, B_4, B_5, B_6, B_7, B_8, B_9, B_{10}$）。\n\n原始程序的控制流图 $G = (V, E)$ 有一个顶点集 $V = \\{B_{0}, B_{1}, B_{2}, B_{4}, B_{5}, B_{6}, B_{7}, B_{8}, B_{9}, B_{10}\\}$（$|V| = N = 10$）和一个由跳转决定的有向边集 $E$：\n- $E = \\{ (B_{0}, B_{1}), (B_{1}, B_{2}), (B_{1}, B_{7}), (B_{2}, B_{4}), (B_{2}, B_{5}), (B_{4}, B_{6}), (B_{5}, B_{6}), (B_{6}, B_{1}), (B_{7}, B_{8}), (B_{7}, B_{9}), (B_{8}, B_{10}), (B_{9}, B_{10}) \\}$\n边的数量是 $|E| = 12$。\n\n**重新降级后的 IR** 的 CFG $G' = (V', E')$ 有一个顶点集 $V' = \\{B'_{0}, B'_{1}, B'_{2}, B'_{3}, B'_{4}, B'_{5}, B'_{6}, B'_{7}, B'_{8}, B'_{9}\\}$（$|V'| = N = 10$）和一个有向边集 $E'$：\n- $E' = \\{ (B'_{0}, B'_{1}), (B'_{1}, B'_{2}), (B'_{1}, B'_{6}), (B'_{2}, B'_{3}), (B'_{2}, B'_{4}), (B'_{3}, B'_{5}), (B'_{4}, B'_{5}), (B'_{5}, B'_{1}), (B'_{6}, B'_{7}), (B'_{6}, B'_{8}), (B'_{7}, B'_{9}), (B'_{8}, B'_{9}) \\}$\n边的数量是 $|E'| = 12$。\n\n为了证明 $G$ 和 $G'$ 是同构的，我们必须展示一个保持邻接关系的双射 $f: V \\to V'$。让我们根据每个块的功能角色来定义这个映射：\n- $f(B_{0}) = B'_{0}$（初始化）\n- $f(B_{1}) = B'_{1}$（循环头）\n- $f(B_{2}) = B'_{2}$（循环体条件前）\n- $f(B_{4}) = B'_{3}$（内部 `if` 的 `else` 分支）\n- $f(B_{5}) = B'_{4}$（内部 `if` 的 `then` 分支）\n- $f(B_{6}) = B'_{5}$（循环递增并继续）\n- $f(B_{7}) = B'_{6}$（循环后条件）\n- $f(B_{8}) = B'_{7}$（外部 `if` 的 `else` 分支）\n- $f(B_{9}) = B'_{8}$（外部 `if` 的 `then` 分支）\n- $f(B_{10}) = B'_{9}$（停止/退出）\n\n这个函数 $f$ 是 $V$ 和 $V'$ 之间的一个双射。我们检查对于 $E$ 中的任意边 $(u, v)$，边 $(f(u), f(v))$ 都在 $E'$ 中。例如，$(B_{6}, B_{1}) \\in E$，在 $G'$ 中对应的边是 $(f(B_{6}), f(B_{1})) = (B'_{5}, B'_{1})$，它在 $E'$ 中。类似地，$(B_{2}, B_{4}) \\in E$ 对应于 $(f(B_{2}), f(B_{4})) = (B'_{2}, B'_{3}) \\in E'$。全面检查确认所有 $12$ 条边在此映射下都得以保留。因此，重新降级的 IR 的 CFG 与原始程序的 CFG 是同构的。\n\n### 4. 圈复杂度计算\n\n控制流图的圈复杂度 $M$ 可以使用几个等价的公式计算。我们将使用基于图中节点数、边数和连通分量数的公式。对于具有单一入口和单一出口点的 CFG，有 $P=1$ 个连通分量。公式是：\n$$M = E - N + 2P$$\n使用重新降级的 IR 的 CFG（它与原始 CFG 同构），我们有：\n- 节点数（基本块数）$N = 10$。\n- 边数（控制转移数）$E = 12$。\n- 连通分量数 $P = 1$。\n\n将这些值代入公式：\n$$M = 12 - 10 + 2(1) = 2 + 2 = 4$$\n\n或者，我们可以使用公式 $M = D + 1$，其中 $D$ 是判定节点（出度为 $2$ 的节点）的数量。\n图中的判定节点是：\n1.  $B'_{1}$（或 $B_{1}$）：`if i >= n`\n2.  $B'_{2}$（或 $B_{2}$）：`if tmp = 0`\n3.  $B'_{6}$（或 $B_{7}$）：`if s  0`\n共有 $D=3$ 个判定节点。因此，复杂度是：\n$$M = 3 + 1 = 4$$\n\n两种方法得出了相同的结果。该 CFG 的圈复杂度是 $4$。",
            "answer": "$$\\boxed{4}$$"
        }
    ]
}