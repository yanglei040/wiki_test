{
    "hands_on_practices": [
        {
            "introduction": "理解调用栈的工作原理是编译原理的基础。每次过程调用都会为其活动记录消耗栈空间。本练习 () 聚焦于活动记录的布局，包括参数、控制信息和局部变量，并特别对比了值传递和引用传递这两种方式。通过亲手模拟递归过程中的栈增长，你将具体地理解调用约定如何影响内存使用和程序性能，尤其是在处理大型数据结构时。",
            "id": "3678364",
            "problem": "一台机器为过程调用实现了一个向下增长的运行时栈。以下核心事实和定义支配其执行模型。\n\n- 运行时栈为活动过程保存活动记录（也称为栈帧）。栈指针 (SP) 始终指向栈顶，推入 $k$ 字节会从 $SP$ 中减去 $k$，而弹出 $k$ 字节会给 $SP$ 加上 $k$。帧指针 (FP) 是当前活动记录中的一个稳定指针；它在入口处被保存，在返回时被恢复。\n- 每次调用都遵循标准的调用者推入参数、被调用者保存寄存器的约定：\n  1. 调用者计算并推入被调用者的实参，总共占用 $P$ 字节。\n  2. 调用指令推入大小为 $w$ 字节的返回地址。\n  3. 被调用者的序言推入调用者的 $FP$（大小为 $w$），设置 $FP \\leftarrow SP$，并从 $SP$ 中减去其本地存储大小 $L$。\n  4. 返回时，被调用者的尾声将 $L$ 加回 $SP$，通过弹出 $w$ 字节来恢复保存的 $FP$，并执行返回指令，该指令通过给 $SP$ 加上 $w$ 来弹出返回地址。最后，调用者通过给 $SP$ 加上 $P$ 来移除参数块。\n- 按值传递将实参复制到被调用者的参数区域。按引用传递只传递实参的地址（一个指针）。在这两种情况下，整数参数占用 $w$ 字节，指针也占用 $w$ 字节。\n\n考虑如下定义的两个相互递归的过程 $f$ 和 $g$。它们接受两个参数：一个大小为 $s$ 字节的结构化聚合体 $S$ 和一个整数 $n$。当 $n \\le 0$ 时，这两个过程执行的简单相互递归会终止。\n\n- 过程 $f(S, n)$:\n  - 如果 $n \\le 0$，立即返回。\n  - 否则，调用 $g(S, n - 1)$ 然后返回。\n- 过程 $g(S, n)$:\n  - 如果 $n \\le 0$，立即返回。\n  - 否则，调用 $f(S, n - 1)$ 然后返回。\n\n假设具体大小如下：\n- 字长 $w = 8$ 字节。\n- 聚合体大小 $s = 48$ 字节。\n- $f$ 的本地存储（包括任何被保存的由被调用者保存的寄存器）为 $L_f = 16$ 字节。\n- $g$ 的本地存储为 $L_g = 24$ 字节。\n- 程序从一个名为 $main$ 的过程开始，该过程的本地存储为 $L_{m} = 32$ 字节且没有参数。在建立自己的活动记录后，$main$ 调用 $f(S_0, N)$，其中 $S_0$ 是一个全局聚合体，$N = 4$。\n\n你需要针对第一个参数 $S$ 的两种不同调用约定，模拟整个执行过程中的栈增长和内容：\n- 场景 A：$S$ 按值传递。\n- 场景 B：$S$ 按引用传递。\n\n对于这两种场景，跟踪每次调用和返回时上述约定所隐含的 $SP$ 和 $FP$ 的逐步变化，并确定 $SP$ 相对于其在 $main$ 序言完成后立即的值的最大向下位移。然后计算这两个最大值之间的差（场景 A 减去场景 B）。用一个以字节为单位的数字表示你的最终答案。不需要四舍五入。",
            "solution": "为了确定$SP$的最大位移，我们计算调用链 `main -> f(4) -> g(3) -> f(2) -> g(1) -> f(0)` 中累积的栈帧大小。一次过程调用的栈消耗包括参数、返回地址、保存的帧指针和局部变量。\n\n**场景 A：按值传递**\n- 参数大小 $P_A = s + w = 48 + 8 = 56$ 字节。\n- $f$ 的栈帧大小: $P_A + w (\\text{ret}) + w (\\text{FP}) + L_f = 56 + 8 + 8 + 16 = 88$ 字节。\n- $g$ 的栈帧大小: $P_A + w (\\text{ret}) + w (\\text{FP}) + L_g = 56 + 8 + 8 + 24 = 96$ 字节。\n- 调用链 `f, g, f, g, f` 产生的总位移为：$88 (\\text{for } f(4)) + 96 (\\text{for } g(3)) + 88 (\\text{for } f(2)) + 96 (\\text{for } g(1)) + 88 (\\text{for } f(0)) = 456$ 字节。\n\n**场景 B：按引用传递**\n- 参数大小 $P_B = w + w = 8 + 8 = 16$ 字节 (结构体地址 + 整数)。\n- $f$ 的栈帧大小: $P_B + w (\\text{ret}) + w (\\text{FP}) + L_f = 16 + 8 + 8 + 16 = 48$ 字节。\n- $g$ 的栈帧大小: $P_B + w (\\text{ret}) + w (\\text{FP}) + L_g = 16 + 8 + 8 + 24 = 56$ 字节。\n- 调用链 `f, g, f, g, f` 产生的总位移为：$48 (\\text{for } f(4)) + 56 (\\text{for } g(3)) + 48 (\\text{for } f(2)) + 56 (\\text{for } g(1)) + 48 (\\text{for } f(0)) = 256$ 字节。\n\n**差值**\n最大位移差为 $456 - 256 = 200$ 字节。",
            "answer": "$$\n\\boxed{200}\n$$"
        },
        {
            "introduction": "现代计算系统依赖于标准化的应用程序二进制接口 (ABI) 来确保独立编译的代码能够正确协同工作。ABI 的一个关键部分是关于参数传递的规则。本练习 () 探讨了一条至关重要的 ABI 规则：在调用点将窄整型（如 8 位或 16 位整数）扩展到完整的寄存器宽度（例如 64 位）。这要求我们准确区分有符号类型的符号扩展和无符号类型的零扩展。完成此练习将帮助你明晰高级语言中的类型是如何安全、正确地转换为其底层机器表示的，这是生成正确机器码的关键一步。",
            "id": "3678301",
            "problem": "考虑一个$64$位架构，其应用程序二进制接口 (ABI) 要求，在调用点，所有比机器寄存器宽度窄的整数参数在放入参数寄存器之前都必须被扩展到$64$位。规则是：有符号窄整数必须符号扩展到$64$位，无符号窄整数必须零扩展到$64$位。被调用者将从其$64$位参数寄存器中读取参数。假设所有有符号整数都使用补码表示法，并且机器寄存器以补码算术的标准方式解释位运算。\n\n你正在编译一个从调用者过程到被调用者过程 $g$ 的调用，调用者中具有以下源级别的类型和值：\n- 一个值为$-45$的有符号$8$位整数 $a$。\n- 一个值为$0x\\mathrm{F234}$的无符号$16$位整数 $b$。\n- 一个值为$0x\\mathrm{80001234}$的有符号$32$位整数 $c$。\n\n被调用者 $g$ 期望在其寄存器 $\\mathrm{X0}$、$\\mathrm{X1}$ 和 $\\mathrm{X2}$ 中接收三个$64$位参数，分别对应于调用者的 $a$、$b$ 和 $c$。在其序言代码中，$g$ 使用位运算和算术运算对$64$位寄存器执行以下验证和计算：\n- 它通过取 $\\mathrm{X0}$ 的低$8$位并将其算术扩展到$64$位，来计算一个规范的符号扩展，从而得到一个值 $x'$。\n- 它通过取 $\\mathrm{X1}$ 的低$16$位并将其逻辑扩展到$64$位，来计算一个规范的零扩展，从而得到一个值 $y'$。\n- 它通过取 $\\mathrm{X2}$ 的低$32$位并将其算术扩展到$64$位，来计算一个规范的符号扩展，从而得到一个值 $z'$。\n- 它构成一个由下式定义的惩罚项 $P$\n$$\nP \\;=\\; |\\mathrm{X0} - x'| \\;+\\; 2\\,|\\mathrm{X1} - y'| \\;+\\; 3\\,|\\mathrm{X2} - z'| ,\n$$\n其中 $|\\,\\cdot\\,|$ 表示有符号$64$位整数的绝对值。\n- 它返回一个$64$位整数\n$$\nR \\;=\\; x' \\;+\\; 2y' \\;+\\; 4z' \\;+\\; P .\n$$\n\n你的任务是，遵照上述ABI规则，在调用点插入所需的扩展，从而将调用者的过程调用转换为被调用者的调用约定，然后确定当调用点遵守ABI时，$g$ 为给定的 $a$、$b$ 和 $c$ 所产生的确切数值返回值 $R$。将最终答案以单个整数形式提供。不需要四舍五入，也不涉及任何单位。在相关处将任何中间的十六进制常数和所有数字表示为数学实体，但最终答案必须是单个整数。",
            "solution": "该问题要求我们确定一个过程调用的返回值，这涉及到理解应用程序二进制接口（ABI）关于参数传递的规则，特别是整数扩展，然后执行被调用者过程中定义的一系列算术和位运算。这个过程可以分解为四个主要步骤：\n1. 确定调用者放入参数寄存器 $\\mathrm{X0}$、$\\mathrm{X1}$ 和 $\\mathrm{X2}$ 中的$64$位值。\n2. 确定被调用者计算出的值 $x'$、$y'$ 和 $z'$。\n3. 计算惩罚项 $P$。\n4. 计算最终返回值 $R$。\n\n**步骤1：确定寄存器 $\\mathrm{X0}$、$\\mathrm{X1}$ 和 $\\mathrm{X2}$ 中的值**\n\nABI规定，在调用点，比$64$位寄存器宽度窄的整数参数需要被扩展。有符号整数进行符号扩展，无符号整数进行零扩展。我们将此规则应用于每个参数。\n\n*   **参数 `a` 到寄存器 $\\mathrm{X0}$：**\n    参数 $a$ 是一个值为$-45$的有符号$8$位整数。首先，我们找到它的$8$位补码表示。正值$45$的$8$位二进制是 $00101101_2$。为了得到$-45$，我们取其补码：将各位取反（$11010010_2$）然后加$1$，得到 $11010011_2$。用十六进制表示，这是 $0x\\mathrm{D3}$。\n    由于 $a$ 是有符号类型，ABI要求进行符号扩展到$64$位。其$8$位表示（$11010011_2$）的最高有效位（MSB）是$1$，所以我们必须在其前面加上$56$个1。\n    寄存器 $\\mathrm{X0}$ 中得到的$64$位值是：\n    $$ \\mathrm{X0} = 0x\\mathrm{FFFFFFFFFFFFFFD3} $$\n    这个$64$位有符号整数的十进制值是$-45$。\n\n*   **参数 `b` 到寄存器 $\\mathrm{X1}$：**\n    参数 $b$ 是一个值为 $0x\\mathrm{F234}$ 的无符号$16$位整数。\n    由于 $b$ 是无符号类型，ABI要求进行零扩展到$64$位。我们在其$16$位表示前加上$48$个0。\n    寄存器 $\\mathrm{X1}$ 中得到的$64$位值是：\n    $$ \\mathrm{X1} = 0x\\mathrm{000000000000F234} $$\n    这个整数的十进制值是 $0x\\mathrm{F234} = 15 \\cdot 16^3 + 2 \\cdot 16^2 + 3 \\cdot 16^1 + 4 \\cdot 16^0 = 61440 + 512 + 48 + 4 = 62004$。\n\n*   **参数 `c` 到寄存器 $\\mathrm{X2}$：**\n    参数 $c$ 是一个值为 $0x\\mathrm{80001234}$ 的有符号$32$位整数。\n    由于 $c$ 是有符号类型，我们必须对其进行符号扩展。其$32$位表示（$0x\\mathrm{8...}$）的MSB是$1$，表示这是一个负数。因此，我们在其前面加上$32$个1。\n    寄存器 $\\mathrm{X2}$ 中得到的$64$位值是：\n    $$ \\mathrm{X2} = 0x\\mathrm{FFFFFFFF80001234} $$\n    为了找到 $c$ 的十进制值，我们可以解释这个$32$位补码数。其大小是 $0x\\mathrm{80001234}$ 的补码，即 $2^{32} - 0x\\mathrm{80001234}$。或者，更简单地，其值为 $-(2^{31} - 0x\\mathrm{00001234}) = -(2147483648 - 4660) = -2147478988$。\n\n**步骤2：确定值 $x'$、$y'$ 和 $z'$**\n\n被调用者 $g$ 计算参数的规范版本。\n\n*   **$x'$ 的计算：**\n    $g$ 通过取 $\\mathrm{X0}$ 的低$8$位并将其符号扩展到$64$位来计算 $x'$。$\\mathrm{X0}$（$0x\\mathrm{FFFFFFFFFFFFFFD3}$）的低$8$位是 $0x\\mathrm{D3}$。$0x\\mathrm{D3}$ 的MSB是$1$，所以符号扩展的结果是：\n    $$ x' = 0x\\mathrm{FFFFFFFFFFFFFFD3} $$\n    这与 $\\mathrm{X0}$ 中的值相同。$x'$ 的十进制值是$-45$。\n\n*   **$y'$ 的计算：**\n    $g$ 通过取 $\\mathrm{X1}$ 的低$16$位并将其零扩展到$64$位来计算 $y'$。$\\mathrm{X1}$（$0x\\mathrm{000000000000F234}$）的低$16$位是 $0x\\mathrm{F234}$。零扩展得到：\n    $$ y' = 0x\\mathrm{000000000000F234} $$\n    这与 $\\mathrm{X1}$ 中的值相同。$y'$ 的十进制值是$62004$。\n\n*   **$z'$ 的计算：**\n    $g$ 通过取 $\\mathrm{X2}$ 的低$32$位并将其符号扩展到$64$位来计算 $z'$。$\\mathrm{X2}$（$0x\\mathrm{FFFFFFFF80001234}$）的低$32$位是 $0x\\mathrm{80001234}$。MSB是$1$，所以符号扩展的结果是：\n    $$ z' = 0x\\mathrm{FFFFFFFF80001234} $$\n    这与 $\\mathrm{X2}$ 中的值相同。$z'$ 的十进制值是$-2147478988$。\n\n**步骤3：计算惩罚项 $P$**\n\n惩罚项 $P$ 定义为 $P = |\\mathrm{X0} - x'| + 2|\\mathrm{X1} - y'| + 3|\\mathrm{X2} - z'|$。由于调用者正确地遵守了ABI规则，它放入寄存器中的值已经是正确扩展的。被调用者对低位的规范性重新扩展会产生完全相同的值。\n*   $\\mathrm{X0} - x' = 0x\\mathrm{FFFFFFFFFFFFFFD3} - 0x\\mathrm{FFFFFFFFFFFFFFD3} = 0$\n*   $\\mathrm{X1} - y' = 0x\\mathrm{000000000000F234} - 0x\\mathrm{000000000000F234} = 0$\n*   $\\mathrm{X2} - z' = 0x\\mathrm{FFFFFFFF80001234} - 0x\\mathrm{FFFFFFFF80001234} = 0$\n\n因此，惩罚项是：\n$$ P = |0| + 2|0| + 3|0| = 0 $$\n\n**步骤4：计算最终返回值 $R$**\n\n最终返回值 $R$ 由公式 $R = x' + 2y' + 4z' + P$ 给出。我们代入找到的十进制值：\n*   $x' = -45$\n*   $y' = 62004$\n*   $z' = -2147478988$\n*   $P = 0$\n\n计算如下：\n$$ R = (-45) + 2(62004) + 4(-2147478988) + 0 $$\n$$ R = -45 + 124008 - 8589915952 $$\n$$ R = 123963 - 8589915952 $$\n$$ R = -8589791989 $$\n\n因此，确切的数值返回值是$-8589791989$。",
            "answer": "$$ \\boxed{-8589791989} $$"
        },
        {
            "introduction": "支持嵌套作用域的语言（如 Pascal 或包含闭包的现代语言）带来了一个独特的挑战：一个嵌套的子过程如何访问其外层作用域中的变量？这个综合性的编程练习 () 要求你实现并比较解决此问题的两种经典方案：静态链和 display。它还通过实现沿动态链的查找，将这些静态作用域机制与动态作用域的行为进行对比。通过这次动手实践，你不仅能理解这些运行时机制在理论上的权衡（例如 $O(d)$ 与 $O(1)$ 的访问成本），还将对静态作用域和动态作用域在变量名解析方式上的根本差异获得深刻而实际的认识。",
            "id": "3678308",
            "problem": "你需要设计、实现并评估两种用于在具有嵌套词法作用域的类 Pascal 语言中转换过程调用的经典运行时环境机制：静态链（使用静态链接）和显示表（一个按词法层级索引的指针数组）。你的实现必须是一个完整的、可运行的程序，该程序模拟栈上的活动记录，支持嵌套过程调用，并测量静态作用域下非局部变量访问的代价。此外，还需实现一个基于动态链接的搜索，该搜索沿调用者链进行，以说明在动态作用域下会发生什么，并将其与静态作用域进行对比。\n\n推导的基本依据必须始于以下编译器原理中经过充分检验的定义和事实：\n- 活动记录（栈帧）持有过程局部数据和管理指针。\n- 静态作用域通过过程的词法嵌套结构来解析非局部引用。\n- 静态链接从词法层级为 $L$ 的活动记录指向其直接词法父级（在层级 $L-1$）的最新活动记录。\n- 动态链接从一个活动记录指向其调用者的活动记录。\n- 显示表是一个按词法层级索引的数组；索引 $L$ 处的条目持有一个指向词法层级为 $L$ 的最新活动记录的指针。\n- 在静态作用域下，静态链的访问时间与词法距离 $d$（需要遍历的静态链接数量）成正比，即 $O(d)$，而显示表通过直接索引可实现 $O(1)$ 的访问。\n- 基于动态链接的搜索的访问时间与动态调用链距离 $d'$ 相关，为 $O(d')$，并且即使词法上不可访问的绑定存在于调用者链上，它也可能查找失败。\n\n你必须实现以下行为：\n1. 模拟一个活动记录的运行时栈。每个活动记录存储：\n   - 其词法层级 $L$（一个整数）。\n   - 一个静态链接指针，指向层级 $L-1$ 的最新活动记录（如果 $L=0$ 则为 $\\varnothing$）。\n   - 一个动态链接指针，指向调用者的活动记录（对于入口点则为 $\\varnothing$）。\n   - 一小组带有存在标志的整型变量。使用两个变量标识符：$v$（标识符 $1$）和 $x$（标识符 $2$）。对于每个变量，存储它是否在该帧中声明及其整数值。\n   - 为其所在层级保存的显示表条目，以便在返回时可以恢复显示表。\n2. 提供函数，在给定当前栈顶帧的情况下：\n   - 静态链查找：给定目标词法层级 $T$ 和一个变量标识符，遍历静态链接直到找到层级为 $T$ 的帧；如果变量存在于该帧中，则返回其值和遍历次数作为代价；否则报告失败，代价为 $-1$，值为 $-999$。\n   - 显示表查找：给定当前层级 $C$、目标层级 $T$ 和一个变量标识符，访问索引为 $T$ 的显示表；如果 $T=C$（局部），则定义代价为 $0$；否则，当在显示表指向的帧中找到变量时，定义代价为 $1$；如果变量不存在或显示表条目为 $\\varnothing$，则报告失败，代价为 $-1$，值为 $-999$。\n   - 基于动态链接的查找：遍历动态链接（调用者链）直到找到声明该变量的帧；返回其值和遍历次数作为代价；如果未找到，则报告失败，代价为 $-1$，值为 $-999$。\n\n代价模型和正确性标准：\n- 对于静态链查找，代价是到达层级 $T$ 所需的静态链接遍历次数。当 $T=C$（局部）时，代价为 $0$。如果找不到，则代价为 $-1$。",
            "solution": "该问题要求设计并实现一个仿真程序，以比较在块结构语言中访问非局部变量的三种机制：静态链、显示表和基于动态链接的搜索。该仿真必须基于编译器运行时环境的既定原则。\n\n管理过程调用的一个基本数据结构是活动记录或称栈帧。每次调用一个过程时，一个活动记录被压入运行时栈。该记录包含局部变量、参数和管理信息。对于本问题，一个位于词法层级 $L$ 的过程的每个活动记录将包含：\n- 其词法层级 $L \\in \\mathbb{Z}_{\\ge 0}$。\n- 一个动态链接，是指向其调用者活动记录的指针。这条动态链接链代表了程序的动态执行路径。\n- 一个静态链接，是指向词法上外层过程（位于层级 $L-1$）的最新活动记录的指针。静态链接链反映了过程的静态、文本嵌套关系。对于层级 $L=0$ 的全局作用域，静态链接为空。\n- 一小组局部变量及其存在标志。我们考虑两个变量，$v$ 和 $x$。\n- 为其词法层级保存的显示表指针，用于在过程返回时恢复显示表。\n\n三种访问机制的实现如下：\n\n1.  **静态链查找**：静态（或词法）作用域规定，变量引用通过搜索当前过程的作用域，然后是其词法外层过程的作用域，依此类推，直至全局作用域来解析。这条搜索路径由静态链明确表示。要从当前层级 $C$ 找到在目标词法层级 $T$ 声明的变量，需要遍历 $d = C - T$ 个静态链接以到达正确的活动记录。因此，此访问的代价与词法距离 $d$ 成正比，即 $O(d)$。如果是局部访问（$d=0$），代价为 $0$。\n\n2.  **显示表查找**：显示表是一种避免重复遍历静态链的优化方法。它是一个指针数组，其中索引 $i$ 处的条目指向词法层级为 $i$ 的过程的最新活动记录。当调用一个层级为 $L$ 的过程时，它会保存 `display[L]` 的当前内容，然后将 `display[L]` 设置为指向其自己的新活动记录。返回时，它会恢复保存的指针。这种机制允许在常数时间内访问任何可见外层作用域的帧。要访问目标层级 $T$ 的变量，我们直接使用指针 `display[T]`。对于任何非局部访问（$T \\neq C$），代价定义为 $1$，对于局部访问（$T = C$），代价定义为 $0$，代表一个 $O(1)$ 操作。如果找不到变量，或者显示表条目为空，则代价为 $-1$。\n\n3.  **基于动态链接的查找**：为作说明，我们还实现了一种基于动态作用域的查找。在此方法中，变量引用通过搜索当前过程的作用域，然后是其调用者的作用域，再是其调用者的调用者的作用域，依此类推来解析。这条搜索路径遵循动态链接。代价是遍历的动态链接数量。此方法解析引用的方式可能与静态作用域不同，并且可能会找到词法上超出作用域的变量。\n\n我们的实现模拟了一个带有活动记录栈和显示表数组的运行时环境。`push` 操作创建一个新的活动记录，并正确建立其静态和动态链接。新帧（层级为 $L$）的静态链接由调用时显示表的状态决定；它被设置为 `display[L-1]`，该指针指向外层作用域的最新帧。\n\n三个测试场景验证了这些机制的行为：\n\n-   **测试 1**：一个深度嵌套调用（$0 \\to 1 \\to 2 \\to 3$）演示了非局部访问。从层级 $C=3$ 查询层级 $T=0$ 的变量，其词法距离为 $d=3$。静态链遍历需要 $3$ 步。由于调用序列遵循词法结构，动态链也需要 $3$ 步。然而，显示表查找直接访问 `display[0]`，代价为 $1$。\n\n-   **测试 2**：测试了局部访问（$C=T=2$）。所有三种方法都在当前活动记录中找到变量，链接遍历次数为 $0$，因此代价为 $0$。\n\n-   **测试 3**：这个案例突显了静态作用域和动态作用域之间的根本区别。两个兄弟过程 $A$ 和 $B$ 在层级 $0$ 内部的层级 $1$ 定义。调用序列是 $0 \\to B \\to A$。当 $A$ 中的代码（当前层级 $C=1$）试图访问在 $B$ 中声明的变量 $x$（目标层级 $T=1$）时，静态作用域规则会阻止这一行为。$A$ 的静态链接指向其词法父级（层级 $0$），而不是其兄弟调用者 $B$。因此，在层级 $1$ 搜索变量的静态链查找只会检查 $A$ 自己的帧并失败。类似地，对层级 $1$ 的显示表查找使用 `display[1]`，它指向 $A$ 的帧，因此也失败。相比之下，基于动态链接的搜索会沿着调用者链从 $A$ 到 $B$，在一步之内（代价 $1$）找到变量 $x$。这正确地模拟了动态作用域如何根据调用历史而非词法结构来解析引用。\n\nC 程序实现了这些数据结构和算法，运行了三个测试用例，并报告了代价和结果值，从而验证了理论行为。",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n```"
        }
    ]
}