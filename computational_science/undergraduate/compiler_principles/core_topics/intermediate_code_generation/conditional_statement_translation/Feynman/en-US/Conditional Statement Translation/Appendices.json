{
    "hands_on_practices": [
        {
            "introduction": "The first step in translating a conditional statement is to generate the appropriate control flow, creating the jumps and labels that form the `if-then-else` structure. This exercise guides you through the classic technique of backpatching, an elegant single-pass algorithm for generating jump instructions even before their target addresses are known . By carefully tracing the generation of Three-Address Code (TAC), you will gain a concrete understanding of how a compiler lays out code for complex boolean expressions and resolves control flow paths.",
            "id": "3630921",
            "problem": "A compiler generates Three-Address Code (TAC) for boolean conditions using short-circuit evaluation and the backpatching method. The backpatching method maintains, for each boolean expression $E$, two lists: $E.true$ and $E.false$, which contain the indices of jump instructions whose targets are not yet known and must be filled in later. Short-circuit evaluation enforces left-to-right execution, so subexpression code for the left operand is emitted and decides whether the right operand is evaluated.\n\nAssume the following translation scheme for primitive boolean subexpressions with possible function calls and side effects. For any primitive boolean subexpression $P$:\n- The compiler first emits exactly $s_P$ TAC instructions that evaluate $P$ (including all function calls and side effects) and leave the boolean result in a temporary $t_P$.\n- Immediately after these $s_P$ instructions, the compiler emits two TAC instructions: a conditional jump “if $t_P$ goto $\\_$” and an unconditional “goto $\\_$,” each recorded respectively into $P.true$ and $P.false$ as single unresolved targets.\n\nFor boolean composition using short-circuit semantics with backpatching:\n- For $E_1 \\lor E_2$: the compiler backpatches all indices in $E_1.false$ to the start of $E_2$’s test, and constructs $E.true = \\operatorname{merge}(E_1.true, E_2.true)$ and $E.false = E_2.false$. No extra TAC instructions are emitted beyond those of $E_1$ and $E_2$.\n- For $E_1 \\land E_2$: the compiler backpatches all indices in $E_1.true$ to the start of $E_2$’s test, and constructs $E.true = E_2.true$ and $E.false = \\operatorname{merge}(E_1.false, E_2.false)$. No extra TAC instructions are emitted beyond those of $E_1$ and $E_2$.\n\nFinally, for a conditional statement “if $E$ goto $L_T$ else goto $L_F$,” the compiler backpatches all indices in $E.true$ to $L_T$ and all indices in $E.false$ to $L_F$. Labels are addresses, not instructions; placing a label does not emit a TAC instruction.\n\nConsider translating the condition $E \\equiv \\bigl(A \\lor (B \\land C)\\bigr)$ where $A$, $B$, and $C$ are primitive boolean subexpressions that may contain function calls with side effects, as per the above scheme. Assume that the evaluation of $A$, $B$, and $C$ takes $s_A = 11$, $s_B = 6$, and $s_C = 4$ TAC instructions, respectively, before their two jump instructions are emitted. Assume code generation begins at TAC index $q_0 = 250$.\n\nUsing only the scheme above, and ensuring that short-circuit evaluation preserves the left-to-right order of side effects, determine the total number of TAC instructions emitted solely to evaluate the condition and branch to the appropriate target (i.e., all TAC emitted for $A$, $B$, $C$, and their associated conditional and unconditional jumps, together with any control-flow needed to implement the short circuit), excluding any instructions in the bodies at $L_T$ or $L_F$. Provide your answer as a single integer. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed valid. It is a well-posed problem within the domain of compiler design, providing a clear and consistent set of rules for generating Three-Address Code (TAC) for a boolean expression. All necessary data are provided, and the problem is free of scientific flaws or ambiguities.\n\nThe task is to determine the total number of TAC instructions generated for the conditional expression $E \\equiv \\bigl(A \\lor (B \\land C)\\bigr)$, following the specified scheme for short-circuit evaluation and backpatching.\n\nThe translation scheme for any primitive boolean subexpression $P$ states that the compiler emits:\n1.  $s_P$ instructions to evaluate $P$.\n2.  Two subsequent jump instructions: one conditional (\"if $t_P$ goto $\\_ $\") and one unconditional (\"goto $\\_ $\").\n\nTherefore, the total number of TAC instructions emitted for any single primitive subexpression $P$ is $s_P + 2$.\n\nThe problem specifies that the composition rules for $E_1 \\lor E_2$ and $E_1 \\land E_2$ do not emit any extra TAC instructions. The logical connections are made by backpatching the jump targets. This implies that the total number of instructions generated for a compound expression is the sum of the instructions generated for its constituent primitive subexpressions, arranged sequentially in memory according to the order of evaluation.\n\nThe expression to be translated is $E \\equiv \\bigl(A \\lor (B \\land C)\\bigr)$. Due to short-circuit evaluation with left-to-right processing of side effects, the evaluation order is $A$, then if necessary $B$, and then if necessary $C$. The code for these primitives will be generated in this sequence.\n\n1.  **Code for primitive subexpression $A$:**\n    The number of evaluation instructions for $A$ is given as $s_A = 11$.\n    The total number of TAC instructions generated for $A$ is $N_A = s_A + 2 = 11 + 2 = 13$.\n\n2.  **Code for primitive subexpression $B$:**\n    The number of evaluation instructions for $B$ is given as $s_B = 6$.\n    The total number of TAC instructions generated for $B$ is $N_B = s_B + 2 = 6 + 2 = 8$.\n\n3.  **Code for primitive subexpression $C$:**\n    The number of evaluation instructions for $C$ is given as $s_C = 4$.\n    The total number of TAC instructions generated for $C$ is $N_C = s_C + 2 = 4 + 2 = 6$.\n\nThe overall code for the entire condition $E$ consists of the block of code for $A$, followed immediately by the block of code for $B$, followed immediately by the block of code for $C$. The control flow between these blocks is handled entirely by patching the jump instructions included within each block.\n\nLet's trace the arrangement of the generated code blocks. Let the code generation start at instruction index $q_0 = 250$.\n-   **Code for $A$**: This generates $N_A = 13$ instructions, occupying indices from $250$ to $250 + 13 - 1 = 262$. The next available instruction index is $263$.\n-   **Code for $B$**: The rule for $E_1 \\lor E_2$ dictates that the `false` exit of $E_1$ (which is $A$) jumps to the beginning of $E_2$'s code (which is $B \\land C$). The code for $B$ is generated first for $B \\land C$. It will be placed starting at index $263$. This block generates $N_B = 8$ instructions, occupying indices from $263$ to $263 + 8 - 1 = 270$. The next available index is $271$.\n-   **Code for $C$**: The rule for $E_1 \\land E_2$ dictates that the `true` exit of $E_1$ (which is $B$) jumps to the beginning of $E_2$'s code (which is $C$). The code for $C$ will be placed starting at index $271$. This block generates $N_C = 6$ instructions, occupying indices from $271$ to $271 + 6 - 1 = 276$.\n\nThe total set of instructions generated for the condition spans from index $250$ to $276$. The total number of instructions is the sum of the instructions for each primitive part.\n\nTotal number of instructions, $N_{total}$:\n$$N_{total} = N_A + N_B + N_C$$\n$$N_{total} = (s_A + 2) + (s_B + 2) + (s_C + 2)$$\nSubstituting the given values $s_A=11$, $s_B=6$, and $s_C=4$:\n$$N_{total} = (11 + 2) + (6 + 2) + (4 + 2)$$\n$$N_{total} = 13 + 8 + 6$$\n$$N_{total} = 27$$\n\nThe entire code for evaluating the condition and performing the necessary jumps consists of $27$ TAC instructions. The final backpatching for the overall statement \"if $E$ goto $L_T$ else goto $L_F$\" only fills in the target addresses of these already generated jump instructions and does not add any new instructions.",
            "answer": "$$\\boxed{27}$$"
        },
        {
            "introduction": "Once branching structures are in place, the compiler faces a new challenge: how to manage variables that are assigned different values in separate branches. This practice explores the solution used in most modern compilers: Static Single Assignment (SSA) form, which uses special $\\phi$-functions to merge different versions of a variable at control flow join points . Determining exactly where these merge functions are necessary is a critical skill for understanding the foundations of compiler optimization.",
            "id": "3630892",
            "problem": "Consider the following source-level conditional in an imperative language with scalar variables and a conventional Control-Flow Graph (CFG), where Static Single Assignment (SSA) form is to be constructed:\n\nif (p) { x = a; y = b; } else { x = c; y = d; }\nuse(x, y);\n\nAssume the following foundational model and constraints:\n- Static Single Assignment (SSA) form requires that each variable is assigned exactly once, and special merge functions, called $\\phi$-functions, are placed at CFG join points to reconcile multiple reaching definitions.\n- A $\\phi$-function is inserted at a join node when a variable has $\\geq 2$ distinct reaching definitions from different predecessors and the variable is live at that join.\n- Use pruned SSA: insert $\\phi$-functions only for variables that are live at the join.\n- Only scalar $\\phi$-functions are permitted; there are no aggregate or tuple $\\phi$-functions. Parallel copies are available but do not change the count of $\\phi$-functions.\n- The CFG has one entry block that branches on predicate $p$ to a then-block and an else-block, which immediately reconverge at a single join block before the call to $use(x, y)$.\n- The right-hand sides $a$, $b$, $c$, and $d$ are distinct SSA names defined strictly before the branch and are available in both branches.\n- The variables $x$ and $y$ are each live at the join, since they are used by $use(x, y)$ after the join.\n\nUnder these assumptions, and minimizing $\\phi$-nodes by grouping both branches into a single join block (no duplicated or cascaded joins), determine the minimal number $n_{\\phi}$ of $\\phi$-functions that must be inserted at the join to correctly translate the conditional into pruned SSA form. Your final answer must be a single number. No rounding is required.",
            "solution": "The problem requires determining the minimal number of $\\phi$-functions needed to translate a given conditional statement into pruned Static Single Assignment (SSA) form. The analysis proceeds by applying the rules of SSA construction to the variables involved.\n\nThe source-level conditional statement is:\n`if (p) { x = a; y = b; } else { x = c; y = d; } use(x, y);`\n\nThe problem specifies a Control-Flow Graph (CFG) with an entry block that contains the conditional branch on predicate $p$. This entry block has two successors: a 'then' block ($B_{then}$) and an 'else' block ($B_{else}$). These two blocks then reconverge at a single join block, $B_{join}$.\n\nIn SSA form, every variable is assigned a value exactly once. When a variable is assigned in multiple control-flow paths that later merge, its name must be versioned. Let's trace the assignments to variables $x$ and $y$.\n\n1.  **Variable Renaming**:\n    The original variables $x$ and $y$ are assigned in both the 'then' and 'else' branches. To adhere to the single assignment rule, we introduce new versions (names) for each assignment.\n    - In $B_{then}$, the assignments become $x_1 = a$ and $y_1 = b$.\n    - In $B_{else}$, the assignments become $x_2 = c$ and $y_2 = d$.\n    The variables $a, b, c, d$ are defined before the branch and are assumed to be in proper SSA form.\n\n2.  **Insertion of $\\phi$-functions**:\n    The problem states that a $\\phi$-function is inserted at a join node for a variable if two conditions are met:\n    a) The variable has two or more distinct reaching definitions from different predecessors of the join node.\n    b) The variable is live at that join node.\n\n    This corresponds to the definition of pruned SSA form, which AVOIDS inserting $\\phi$-functions for variables that are not live at the join point. We analyze each variable assigned within the conditional, $x$ and $y$, at the join block $B_{join}$.\n\n    **Analysis for variable $x$**:\n    - **Reaching Definitions**: At the entry to $B_{join}$, there are two distinct definitions for the conceptual variable $x$ arriving from its two predecessors, $B_{then}$ and $B_{else}$. The definition $x_1$ reaches from $B_{then}$, and the definition $x_2$ reaches from $B_{else}$. Thus, condition (a) is met.\n    - **Liveness**: The problem explicitly states that \"$x$ and $y$ are each live at the join, since they are used by $use(x, y)$ after the join.\" Thus, condition (b) is met for $x$.\n    - Since both conditions are satisfied, a $\\phi$-function for $x$ is mandatory at $B_{join}$. This function will merge the two versions of $x$:\n    $$x_3 = \\phi(x_1, x_2)$$\n    The new version, $x_3$, will be used in the call to $use$. This accounts for one $\\phi$-function.\n\n    **Analysis for variable $y$**:\n    - **Reaching Definitions**: Similarly for $y$, at the entry to $B_{join}$, there are two distinct reaching definitions: $y_1$ from $B_{then}$ and $y_2$ from $B_{else}$. Condition (a) is met.\n    - **Liveness**: The problem also states that $y$ is live at the join. Condition (b) is met.\n    - Since both conditions are satisfied, a $\\phi$-function for $y$ is also mandatory at $B_{join}$:\n    $$y_3 = \\phi(y_1, y_2)$$\n    The new version, $y_3$, will be used in the call to $use$. This accounts for a second $\\phi$-function.\n\n3.  **Counting the $\\phi$-functions**:\n    The problem specifies that \"Only scalar $\\phi$-functions are permitted; there are no aggregate or tuple $\\phi$-functions.\" This means we cannot group the merging of $x$ and $y$ into a single composite operation. Each variable that requires merging must have its own separate $\\phi$-function.\n\n    Based on the analysis:\n    - One $\\phi$-function is required for variable $x$.\n    - One $\\phi$-function is required for variable $y$.\n\n    The total minimal number of $\\phi$-functions, $n_{\\phi}$, is the sum of the $\\phi$-functions required for each variable.\n    $$n_{\\phi} = 1 + 1 = 2$$\n    This number is minimal because the insertion of each $\\phi$-function is dictated by the necessary and sufficient conditions of the pruned SSA construction algorithm. No other variables are assigned within the branches, so no other $\\phi$-functions are needed.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While branching is fundamental, it can be costly on modern CPUs, which may suffer performance penalties from flushed instruction pipelines. In many cases, compilers can perform a powerful optimization known as \"if-conversion\" to eliminate branches entirely. This hands-on problem places you in the role of the optimizer, challenging you to convert simple conditional assignments into an equivalent sequence of branchless arithmetic and bitwise operations, vividly illustrating the transformation of control flow into data flow .",
            "id": "3630902",
            "problem": "You are to implement the translation of a pair of conditional updates into branchless code within a compiler-like mindset. The source-level construct to be translated is the canonical running minimum and maximum update, applied to a finite sequence of signed integers:\n- For each new input value $x$, update the running minimum $m$ with the conditional statement “if $x  m$ then $m := x$”, and update the running maximum $M$ with the conditional statement “if $x  M$ then $M := x$”.\n\nYour task is to replace these two conditional statements with a branchless sequence that uses a comparison-to-mask conversion and bitwise selection. The intent is to model how a compiler can lower control flow to data flow in an intermediate representation (IR), without emitting branches for these updates. You must base your approach on the following well-tested facts:\n- In the C abstract machine for unsigned integers, subtraction is performed modulo $2^w$ for a $w$-bit type.\n- For comparisons in C, a relational expression such as $(x  y)$ evaluates to an integer in $\\{0,1\\}$.\n- Two's complement arithmetic is used for signed integers and can be modeled as modulo $2^w$, and bitwise operations $\\land$, $\\lor$, and bitwise complement $\\lnot$ act bitwise on fixed-width integers.\n- Selecting between two values $a$ and $b$ can be accomplished without branches using a mask $U$ that is either all $1$ bits or all $0$ bits at the target width by combining bitwise operations appropriately.\n\nConstraints and assumptions that you must adopt and implement:\n- Use a fixed-width signed integer model with $w = 64$. Represent the smallest and largest signed values as $-2^{63}$ and $2^{63}-1$, respectively.\n- For each input value $x$, the updates to $m$ and $M$ must be performed without any branching instructions for the update step itself. Concretely, each update must be expressible using only comparison-to-$\\{0,1\\}$, unsigned subtraction to form a mask $U \\in \\{0,2^{64}-1\\}$, and bitwise operations to select between alternatives.\n- You must start the running minimum $m$ and maximum $M$ for each sequence at its first element, then process the remaining elements in order.\n\nDesign and implement a complete program that:\n- Applies the above branchless translation to each of the sequences in the test suite below.\n- Produces a single line of output containing the results as a comma-separated list of pairs enclosed in square brackets, where each pair is itself a bracketed comma-separated list $[m,M]$. For example, the format is $[[m_1,M_1],[m_2,M_2],\\dots]$ with no spaces.\n\nTest suite to cover typical, boundary, and edge cases:\n- Case A (general mixed signs): $\\langle 3,-1,4,-5,2 \\rangle$.\n- Case B (all equal): $\\langle 7,7,7,7 \\rangle$.\n- Case C (increasing): $\\langle -2,0,5,9,12 \\rangle$.\n- Case D (decreasing): $\\langle 10,9,8,7,6 \\rangle$.\n- Case E (near extremes without the absolute minimum): $\\langle 0,2^{63}-1,-(2^{63}-1),-1,1 \\rangle$.\n- Case F (includes absolute minimum and maximum): $\\langle 5,-2^{63},0,2^{63}-1 \\rangle$.\n\nYour program must compute, for each case, the final running minimum $m$ and maximum $M$ after processing the entire sequence using the branchless updates and output them in the exact single-line format:\n- Output format: a single line with $[[m_A,M_A],[m_B,M_B],[m_C,M_C],[m_D,M_D],[m_E,M_E],[m_F,M_F]]$ where the subscript denotes the case. No additional whitespace or text is permitted.\n\nDo not read any input. Hard-code the above test suite in your program. The final outputs are plain integers. No physical units are involved. Angles and percentages are not applicable in this problem.",
            "solution": "The problem requires the implementation of a branchless algorithm to find the running minimum and maximum of a sequence of signed integers. This task models a common compiler optimization where conditional branches are transformed into a sequence of arithmetic and bitwise operations, a technique known as \"if-conversion\" or \"predication\". The solution must adhere to a specific method using comparison-to-mask conversion and bitwise selection on $w=64$-bit two's complement integers.\n\nThe source-level conditional statements to be translated are:\n1. For the running minimum $m$: `if (x  m) then m := x`\n2. For the running maximum $M$: `if (x > M) then M := x`\n\nThese can be expressed using the ternary operator as:\n`m = (x  m) ? x : m`\n`M = (x > M) ? x : M`\n\nThe core of the branchless translation lies in replacing the ternary conditional selection with a bitwise selection mechanism. A general formula for selecting between two values, $v_a$ and $v_b$, using a bitmask $U$ is:\n$$v_{new} = (v_a \\land U) \\lor (v_b \\land \\lnot U)$$\nHere, $\\land$ represents the bitwise AND operator, $\\lor$ represents the bitwise OR operator, and $\\lnot$ represents the bitwise NOT (complement) operator. This formula works if the mask $U$ is either all $1$s or all $0$s at the target bit width.\n- If $U$ is a bitmask of all $1$s (e.g., `0xFF...FF`), then $\\lnot U$ is all $0$s. The expression simplifies to $(v_a \\land \\text{all}_1s) \\lor (v_b \\land \\text{all}_0s) = v_a \\lor 0 = v_a$.\n- If $U$ is a bitmask of all $0$s (e.g., `0x00...00`), then $\\lnot U$ is all $1$s. The expression simplifies to $(v_a \\land \\text{all}_0s) \\lor (v_b \\land \\text{all}_1s) = 0 \\lor v_b = v_b$.\n\nThe crucial step is to generate such a mask $U$ directly from the result of a comparison, without branching. The problem states that a C relational expression like $(x  y)$ evaluates to an integer, either $1$ (for true) or $0$ (for false). We need to map this boolean result to a full-width bitmask. The specified method is to use unsigned subtraction.\n\nLet's formalize this for a $w=64$-bit system.\n1. The result of a comparison, say $c = (x  m)$, is an `int` with value $1$ or $0$.\n2. We cast this result to a $64$-bit unsigned integer, let's call it $c_{64u}$. So, $c_{64u} \\in \\{0, 1\\}$.\n3. We generate the mask $U$ using unsigned subtraction: $U = 0 - c_{64u}$. In a $w$-bit unsigned system, this operation is performed modulo $2^w$.\n   - If the comparison is true, $c_{64u} = 1$. The mask becomes $U = 0 - 1 \\pmod{2^{64}} = 2^{64} - 1$. In binary, this is a sequence of $64$ ones (`0xFFFFFFFFFFFFFFFF`).\n   - If the comparison is false, $c_{64u} = 0$. The mask becomes $U = 0 - 0 = 0$. In binary, this is a sequence of $64$ zeros (`0x0000000000000000`).\n\nThis generated mask $U$ is precisely what is needed for the bitwise selection formula. The bit patterns of the mask, when reinterpreted as signed $64$-bit integers in a two's complement system, correspond to $-1$ (all ones) and $0$ (all zeros).\n\nApplying this to the minimum update: `if (x  m) then m := x`.\n- The value to select if true ($v_a$) is $x$.\n- The value to select if false ($v_b$) is $m$.\n- The condition is $(x  m)$.\n- The mask is $U_{min} = 0 - (\\text{unsigned long long})(x  m)$.\n- The new minimum is calculated as $m_{new} = (x \\land (\\text{long long})U_{min}) \\lor (m \\land \\lnot((\\text{long long})U_{min}))$.\n\nApplying this to the maximum update: `if (x > M) then M := x`.\n- The value to select if true ($v_a$) is $x$.\n- The value to select if false ($v_b$) is $M$.\n- The condition is $(x > M)$.\n- The mask is $U_{max} = 0 - (\\text{unsigned long long})(x > M)$.\n- The new maximum is calculated as $M_{new} = (x \\land (\\text{long long})U_{max}) \\lor (M \\land \\lnot((\\text{long long})U_{max}))$.\n\nThe C implementation will use `long long` for the $64$-bit signed integers $x$, $m$, and $M$, and `unsigned long long` for the intermediate mask generation. The reinterpretive cast from the `unsigned long long` mask to a `long long` for the bitwise selection is well-defined on the assumed two's complement architecture, preserving the bit patterns for $0$ and $-1$.\n\nThe program initializes $m$ and $M$ to the first element of each test sequence and then iterates through the remaining elements, applying these two branchless update steps for each element. The final values of $m$ and $M$ for each sequence are then collected and printed in the specified format. The constants for the extreme values, $2^{63}-1$ and $-2^{63}$, are defined using `long long` literals to ensure they have the correct value and type.",
            "answer": "```c\n#include stdio.h\n#include stdlib.h\n#include string.h\n#include math.h\n\n// Define 64-bit signed integer constants as specified in the problem.\n// w = 64, range is [-2^63, 2^63 - 1].\n// Using LL suffix to ensure literals are of type long long.\n#define INT64_MAX_VAL 9223372036854775807LL\n#define INT64_MIN_VAL (-9223372036854775807LL - 1LL)\n#define VAL_NEG_2_63_M1 (-9223372036854775807LL)\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    long long* data;\n    int size;\n} TestCase;\n\n// Define the data for each test case as global arrays.\nlong long data_A[] = {3, -1, 4, -5, 2};\nlong long data_B[] = {7, 7, 7, 7};\nlong long data_C[] = {-2, 0, 5, 9, 12};\nlong long data_D[] = {10, 9, 8, 7, 6};\nlong long data_E[] = {0, INT64_MAX_VAL, VAL_NEG_2_63_M1, -1, 1};\nlong long data_F[] = {5, INT64_MIN_VAL, 0, INT64_MAX_VAL};\n\nint main(void) {\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {data_A, sizeof(data_A) / sizeof(data_A[0])},\n        {data_B, sizeof(data_B) / sizeof(data_B[0])},\n        {data_C, sizeof(data_C) / sizeof(data_C[0])},\n        {data_D, sizeof(data_D) / sizeof(data_D[0])},\n        {data_E, sizeof(data_E) / sizeof(data_E[0])},\n        {data_F, sizeof(data_F) / sizeof(data_F[0])},\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long results[num_cases][2];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i  num_cases; ++i) {\n        // As per problem, initialize with the first element.\n        // Assume all sequences have at least one element.\n        long long m = test_cases[i].data[0];\n        long long M = test_cases[i].data[0];\n\n        // Process the rest of the sequence.\n        for (int j = 1; j  test_cases[i].size; ++j) {\n            long long x = test_cases[i].data[j];\n\n            // Branchless update for minimum 'm'.\n            // The comparison (x  m) evaluates to 1 if true, 0 if false.\n            // In unsigned 64-bit arithmetic, 0ULL - 1ULL wraps around to UINT64_MAX (all 1s).\n            // This creates a mask that is all 1s if true, all 0s if false.\n            unsigned long long mask_min = 0ULL - (unsigned long long)(x  m);\n            \n            // The bitwise selection then chooses 'x' if the mask is all 1s,\n            // or 'm' if the mask is all 0s.\n            // On a two's complement system, casting the mask to a signed long long\n            // preserves the bit pattern (0 remains 0, all-1s becomes -1).\n            m = (x  (long long)mask_min) | (m  ~(long long)mask_min);\n\n            // Symmetrically, a branchless update for maximum 'M'.\n            unsigned long long mask_max = 0ULL - (unsigned long long)(x  M);\n            M = (x  (long long)mask_max) | (M  ~(long long)mask_max);\n        }\n\n        results[i][0] = m;\n        results[i][1] = M;\n    }\n\n    // Print the results in the exact required format before the final return statement.\n    // Format: [[m_A,M_A],[m_B,M_B],...] with no spaces.\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        if (i  0) {\n            printf(\",\");\n        }\n        // \"%lld\" is the standard format specifier for long long.\n        printf(\"[%lld,%lld]\", results[i][0], results[i][1]);\n    }\n    printf(\"]\");\n\n    return EXIT_SUCCESS;\n}\n```"
        }
    ]
}