{
    "hands_on_practices": [
        {
            "introduction": "许多现代编程语言（如Python）支持像 `$a \\lt b \\lt c$` 这样的链式比较，这不仅简洁而且高效。这个练习将挑战你将这种结构翻译成遵循短路求值规则的三地址代码，确保共享操作数（如 `$b$`）只被计算一次。通过这种方式，你不仅能掌握布尔表达式的控制流翻译，还能定量分析短路求值带来的性能优势。",
            "id": "3677567",
            "problem": "一个编译器前端的目标是一种带有条件和无条件跳转的三地址中间表示，并对布尔表达式使用短路求值。源语言的链式比较语义与 Python 的相匹配：表达式 $a  b  c  d$ 在逻辑上等价于 $(a  b) \\land (b  c) \\land (c  d)$，并有以下操作约束：操作数从左到右求值，像 $b$ 或 $c$ 这样的中间操作数只求值一次并在相邻的比较中被重用，且一旦结果确定，求值就会短路。假设对操作数求值可能会产生副作用，因此禁止对 $b$ 或 $c$ 进行重新计算。\n\n任务：\n- 推导一个短路三地址代码序列，该序列将 $a  b  c  d$ 的布尔值计算到目标临时变量 $t_{\\mathrm{res}}$ 中，其中布尔值用 $1$ (真) 和 $0$ (假) 表示。你的序列必须：\n  - 严格从左到右对操作数 $a$、$b$、$c$ 和 $d$ 求值，每个最多一次。\n  - 通过重用临时变量来避免对 $b$ 和 $c$ 的重新计算。\n  - 使用条件分支在第一个失败的比较处进行短路。\n  - 当且仅当链式比较成立时，将 $t_{\\mathrm{res}}$ 设置为 $1$，否则将其设置为 $0$，然后跳转到一个公共的退出标签。\n\n- 在一个成本模型下，其中对每个操作数求值的成本为零，每次原始比较 $x  y$ 的成本为单位成本，假设事件 $(a  b)$、$(b  c)$ 和 $(c  d)$ 是独立的，其概率分别为 $\\Pr(a  b) = p_{ab}$、$\\Pr(b  c) = p_{bc}$ 和 $\\Pr(c  d) = p_{cd}$。使用上述操作语义和你的代码结构，推导一个关于 $p_{ab}$、$p_{bc}$ 和 $p_{cd}$ 的闭式解析表达式，表示执行的原始比较的期望数量。将此表达式作为你的最终答案。不需要进行四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于编译器设计的原理，提法恰当，信息充分且一致，并且陈述客观。它提出了一个可形式化的任务，具有唯一的、可推导的解。\n\n该任务包括两个部分。第一，在特定的操作语义下，为链式比较 $a  b  c  d$ 推导一个三地址代码序列。第二，基于给定的概率模型，计算执行的原始比较的期望数量。\n\n### 第 1 部分：三地址代码生成\n\n表达式 $a  b  c  d$ 等价于 $(a  b) \\land (b  c) \\land (c  d)$。操作语义要求短路求值、从左到右的操作数求值以及对共享操作数（$b$ 和 $c$）的单次求值。我们可以使用条件分支来实现这一点。如果合取中的任何一个比较失败，整个表达式就为假，我们可以立即跳转到处理假情况的位置。\n\n设 $t_{\\mathrm{res}}$ 为保存结果的目标临时变量，用 $1$ 表示真，$0$ 表示假。对操作数 $a, b, c, d$ 的求值可能有副作用，因此必须按顺序且仅求值一次。我们可以将它们的值存储在临时变量 $t_a, t_b, t_c, t_d$ 中，不过为了最终代码的简洁性，我们可以直接使用这些操作数，前提是假设三地址代码求值器会处理所要求的单次求值。关键在于控制流。\n\n一个合适的三地址代码序列如下。我们定义两个标签：`L_false` 用于表达式求值为假的情况，`L_end` 用于一个公共的退出点。\n\n1.  求值第一个比较 $a  b$。如果为假，则整个表达式为假。\n    `if a  b goto L1`\n    `goto L_false`\n\n2.  `L1:` 求值第二个比较 $b  c$。这里重用了操作数 $b$。如果为假，则表达式为假。\n    `if b  c goto L2`\n    `goto L_false`\n\n3.  `L2:` 求值第三个比较 $c  d$。这里重用了操作数 $c$。如果为假，则表达式为假。\n    `if c  d goto L_true`\n    `goto L_false`\n\n4.  `L_true:` 如果控制流到达此点，说明所有比较都成功了。表达式为真。\n    `t_res = 1`\n    `goto L_end`\n\n5.  `L_false:` 如果有任何比较失败，控制流会跳转到这里。表达式为假。\n    `t_res = 0`\n\n6.  `L_end:` 后续代码的公共退出点。\n\n这个序列可以写得更紧凑，这在中间表示中很典型：\n\n`if not (a  b) goto L_false`\n`if not (b  c) goto L_false`\n`if not (c  d) goto L_false`\n`t_res = 1`\n`goto L_end`\n`L_false: t_res = 0`\n`L_end: ...`\n\n这个结构正确地实现了指定的短路语义。比较 $(a  b)$、$(b  c)$ 和 $(c  d)$ 按顺序执行，并且求值在第一个返回假的地方停止。\n\n### 第 2 部分：期望的比较次数\n\n设 $N$ 为表示执行的原始比较次数的随机变量。成本模型为每次比较分配成本 $1$，为操作数求值分配成本 $0$。我们已知每个比较为真的概率是独立事件：$\\Pr(a  b) = p_{ab}$、$\\Pr(b  c) = p_{bc}$ 和 $\\Pr(c  d) = p_{cd}$。\n\n我们可以利用期望的线性性来确定 $N$ 的期望值，记为 $E[N]$。设 $I_k$ 是一个指示随机变量，用于表示第 $k$ 次比较被执行的事件。\n-   如果比较 $(a  b)$ 被执行，则 $I_1 = 1$，否则 $I_1 = 0$。\n-   如果比较 $(b  c)$ 被执行，则 $I_2 = 1$，否则 $I_2 = 0$。\n-   如果比较 $(c  d)$ 被执行，则 $I_3 = 1$，否则 $I_3 = 0$。\n\n总比较次数为 $N = I_1 + I_2 + I_3$。根据期望的线性性，$E[N] = E[I_1] + E[I_2] + E[I_3]$。指示变量的期望等于它所指示事件的概率，因此 $E[I_k] = \\Pr(I_k = 1)$。\n\n1.  **$I_1$ 的期望值**：第一个比较 $(a  b)$ 总是被执行。因此，它被执行的概率是 $1$。\n    $$E[I_1] = \\Pr(I_1 = 1) = 1$$\n\n2.  **$I_2$ 的期望值**：第二个比较 $(b  c)$ 只有在第一个比较 $(a  b)$ 求值为真时才被执行。根据短路规则，如果 $(a  b)$ 为假，求值就会终止。\n    $$E[I_2] = \\Pr(I_2 = 1) = \\Pr(a  b) = p_{ab}$$\n\n3.  **$I_3$ 的期望值**：第三个比较 $(c  d)$ 只有在第一个比较 $(a  b)$ 和第二个比较 $(b  c)$ 都求值为真时才被执行。\n    $$E[I_3] = \\Pr(I_3 = 1) = \\Pr((a  b) \\land (b  c))$$\n    因为给定事件是独立的，我们可以将它们的概率相乘：\n    $$\\Pr((a  b) \\land (b  c)) = \\Pr(a  b) \\cdot \\Pr(b  c) = p_{ab} p_{bc}$$\n    因此，\n    $$E[I_3] = p_{ab} p_{bc}$$\n\n总的期望比较次数是这些期望的总和：\n$$E[N] = E[I_1] + E[I_2] + E[I_3]$$\n$$E[N] = 1 + p_{ab} + p_{ab}p_{bc}$$\n\n这就是期望比较次数的闭式解析表达式。值得注意的是，概率 $p_{cd}$ 并未出现在表达式中。这是正确的，因为执行的比较*次数*仅取决于前两次比较的结果，而与第三次无关。第三次比较一旦被执行，无论其结果如何都会完成。$p_{cd}$ 的值对于计算整个表达式为真的概率是相关的，但对于此成本模型下期望的求值步骤数则不相关。",
            "answer": "$$\\boxed{1 + p_{ab} + p_{ab}p_{bc}}$$"
        },
        {
            "introduction": "短路求值不仅是为了提高效率，更是保证程序正确性和安全性的关键。一个经典的例子是在访问数组成员之前检查数组索引是否越界。这个练习要求你为一个包含 `$(i \\lt n) \\land a[i] \\neq 0$` 条件的循环生成遵循短路规则的底层控制流代码，并在此基础上，通过概率模型分析循环的平均执行行为。",
            "id": "3677647",
            "problem": "一个编译器后端必须将高级语言语句\n`while ((i  n)  a[i] != 0) { i := i + 1; }`\n中的循环条件翻译为遵循短路求值原则的低级控制流，这意味着仅当第一个合取项为真时，才对第二个合取项求值。请使用将布尔表达式翻译为带有显式标签的三地址码 (TAC) 的标准面向控制流的方法，确保边界检查 $i  n$ 总是在数组访问 $a[i]$ 之前执行。然后，将此翻译扩展到等价 for 循环的规范化形式：\n`for (i := i_0; (i  n)  (a[i] \\neq 0); i := i + 1) { /* empty body */ }`\n其中 $i_0$ 是 $i$ 的给定初始值，且 $0 \\le i_0 \\le n$。\n\n对于此规范化的 for 循环，假设采用以下程序输入的概率模型：\n- 数组段 $a[i_0], a[i_0+1], \\dots, a[n-1]$ 由独立的元素组成。\n- 对于每个索引 $j \\in \\{i_0, i_0+1, \\dots, n-1\\}$，事件 $a[j] = 0$ 发生的概率为 $p$，其中 $p \\in (0,1]$，否则 $a[j] \\neq 0$。\n\n在此模型下，翻译后的 TAC 在每次迭代中以短路方式执行测试序列：它首先检查 $i  n$；仅当该条件为真时，才读取并比较 $a[i]$。令 $X$ 为随机变量，其值等于该 TAC 在循环退出前执行的形如 $a[i]$ 的数组读取总次数。\n\n仅使用短路求值的基本定义、TAC 生成的控制流的语义，以及非负整数值随机变量的数学期望定义，推导期望值 $\\mathbb{E}[X]$ 作为 $n$、$i_0$ 和 $p$ 的函数的闭式解析表达式。请用最简闭式形式表示您的最终答案。无需四舍五入。",
            "solution": "该问题要求基于数组内容的概率模型，为一个带有短路条件的循环推导其数组读取的期望次数。我们首先形式化问题陈述所隐含的控制流语义，然后进行概率分析。\n\n首先，我们分析为布尔表达式 `(i  n)  (a[i] != 0)` 生成的控制流。`` 运算符意味着短路求值，即仅当第一个操作数 `i  n` 为真时，才对第二个操作数 `a[i] != 0` 求值。在到三地址码 (TAC) 的标准翻译中，这是通过条件跳转实现的。对于形式为 `while (B1  B2) S` 的 `while` 循环，其结构如下：\n\n`L_loop:`\n`  if not B1 goto L_exit`\n`  if not B2 goto L_exit`\n`  S`\n`  goto L_loop`\n`L_exit:`\n\n将此应用于具体问题，其中 `B1` 为 `$i  n$`，`B2` 为 `$a[i] \\neq 0$`，循环体 `S` 为 `$i := i + 1$`，则 TAC 代码如下：\n`L_loop:`\n`  t1 := i  n`\n`  if t1 = 0 goto L_exit`\n`  t2 := a[i]       ; Array read occurs here`\n`  t3 := t2 != 0`\n`  if t3 = 0 goto L_exit`\n`  i := i + 1`\n`  goto L_loop`\n`L_exit:`\n\n此控制流明确证实，数组访问 `a[i]` 仅在条件 `$i  n$` 满足时发生。这是我们将使用的关键语义属性。给定的 `for` 循环等价于一个初始化 `$i := i_0$`，后跟此 `while` 循环结构。\n\n令 `$X$` 为表示数组读取总次数的随机变量。一次数组读取的形式为 `$a[i]$`。根据控制流，对于给定的 `$i$` 值，在一次迭代中发生数组读取，当且仅当测试 `$i  n$` 的结果为真。循环从 `$i = i_0$` 开始，并在每次成功迭代后将 `$i$` 递增。循环可能对从 `$i_0$` 到 `$n-1$` 的 `$i$` 值运行。如果 `$i$` 达到 `$n$`，条件 `$i  n$` 变为假，循环终止，且不会对该 `$i$` 值进行数组读取。\n\n我们需要计算 `$X$` 的期望值，记为 `$\\mathbb{E}[X]$`。由于 `$X$` 是一个非负整数值随机变量，其期望可以使用尾和公式计算：\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{\\infty} P(X \\ge k) $$\n数组读取的次数不能超过可能发生读取的 `$i$` 值的数量，即 `$n - i_0$` (对于 `$i = i_0, i_0+1, \\dots, n-1$`)。因此，`$X$` 的最大值为 `$n-i_0$`，且该和是有限的：\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} P(X \\ge k) $$\n注意，如果 `$i_0 \\ge n$`，求和范围为空，正确地得到 `$\\mathbb{E}[X] = 0$`，因为循环条件 `$i  n$` 初始为假。在主推导中，我们将假设 `$i_0  n$`。\n\n让我们确定对于整数 `$k$`（其中 `$1 \\le k \\le n-i_0$`），概率 `$P(X \\ge k)$` 的值。事件 `$X \\ge k$` 意味着至少执行了 `$k$` 次数组读取。第一次读取是 `$a[i_0]$`，第二次是 `$a[i_0+1]$`，第 `$k$` 次读取是 `$a[i_0+k-1]$`。\n要使第 `$k$` 次读取（读取 `$a[i_0+k-1]$`）发生，必须满足两个条件：\n1. 对于 `$i = i_0, i_0+1, \\dots, i_0+k-2$`，循环必须没有在之前的任何一次迭代中终止。这要求循环条件的第二部分 `$a[i] \\neq 0$` 对所有这些 `$i$` 的值都为真。\n2. 当前迭代的边界检查 `$i  n$` 必须通过，即 `$i_0+k-1  n$`。这由我们的求和上限 `$k \\le n-i_0$` 保证。\n\n因此，发生第 `$k$` 次读取的条件是，对于所有 `$j \\in \\{i_0, i_0+1, \\dots, i_0+k-2\\}$`，都有 `$a[j] \\neq 0$`。概率模型指出，对于任何 `$j$`，`$P(a[j] \\neq 0) = 1 - p$`，并且这些事件是独立的。因此，这一系列 `$k-1$` 个事件的概率是：\n$$ P(X \\ge k) = \\prod_{j=i_0}^{i_0+k-2} P(a[j] \\neq 0) = (1-p)^{k-1} $$\n这对 `$1 \\le k \\le n-i_0$` 成立。对于 `$k=1$`，乘积是关于一个空集的，其值为 `$1$`，所以 `$P(X \\ge 1) = (1-p)^0 = 1$`。这是正确的，因为如果 `$i_0  n$`，至少会进行一次读取尝试，其是否成功取决于 `$a[i_0]$`，但读取次数 `$X$` 在此时至少为1。\n不，这个逻辑有点问题。$X \\ge 1$ 表示至少发生了一次读取。这当且仅当 `$i_0  n$` 时发生。我们已经假设了这一点。所以 `$P(X \\ge 1) = 1$` 是正确的。\n\n因此，`$\\mathbb{E}[X]$` 是一个几何级数的部分和：\n$$ \\mathbb{E}[X] = \\sum_{k=1}^{n-i_0} (1-p)^{k-1} $$\n令 `$j = k-1$` 且 `$m = n-i_0$`。该和变为：\n$$ \\mathbb{E}[X] = \\sum_{j=0}^{m-1} (1-p)^j $$\n这是首项为 `$1$`，公比为 `$1-p$` 的几何级数的和。其闭式形式为：\n$$ \\sum_{j=0}^{m-1} r^j = \\frac{1 - r^m}{1 - r} $$\n将 `$r = 1-p$` 和 `$m = n-i_0$` 代入，我们得到：\n$$ \\mathbb{E}[X] = \\frac{1 - (1-p)^{n-i_0}}{1 - (1-p)} = \\frac{1 - (1-p)^{n-i_0}}{p} $$\n这个表达式在 `$p=1$` 时也成立，此时 `$\\mathbb{E}[X]=1$`（除非 `$n-i_0=0$`，此时为0），这是正确的，因为循环在第一次读取到0后立即终止。它在 `$p \\to 0^+$` 的极限情况下也表现正确，此时 `$\\mathbb{E}[X] \\to n-i_0$` (使用洛必达法则)。",
            "answer": "$$ \\boxed{\\frac{1 - (1-p)^{n-i_0}}{p}} $$"
        },
        {
            "introduction": "编译器的内部实现同样充满了优化的机会，即使是对于简单的逻辑非运算。本练习将带你深入回填（backpatching）技术的内部，比较两种处理逻辑表达式 `if (!(A \\land B))` 的策略：一种是通过交换真假链表实现，另一种是生成一个显式的逻辑非节点。通过计算和比较两种策略所需的回填操作数量，你将学会如何从编译器实现者的角度评估和优化编译过程本身的开销。",
            "id": "3677573",
            "problem": "考虑一种命令式语言，它被翻译成中间表示（IR），其中布尔表达式使用短路求值和回填方法进行编译。在该方法中，每个布尔子表达式由两个前向分支列表表示，一个真列表和一个假列表，分别表示为 $TL(\\cdot)$ 和 $FL(\\cdot)$。这些列表中的每个元素都是一个未解析的分支，当控制目标已知时，它将被回填到一个具体的标号。一次回填操作定义为用一个具体标号填充一个未解析的分支目标；每个未解析的跳转在被解析时计为一次回填操作。\n\n你需要使用短路求值来翻译一个形如 `if (!(A \\wedge B))` 的语句。考虑两种策略：\n\n- 策略 $\\mathsf{Swap}$：使用短路控制流翻译 $A \\wedge B$，并通过翻转结果表达式的真假列表来实现逻辑非，而不为该否定操作引入任何额外的 IR 节点或分支指令。\n\n- 策略 $\\mathsf{NegNode}$：翻译 $A \\wedge B$ 以生成带有用于合取结果的显式临时真假标号的代码，然后将逻辑非实现为一个单独的 IR 节点，该节点在这些临时标号处，发出指向最终 then 和 else 目标的前向分支。在发出否定节点时，最终的 then/else 目标是未知的，因此这两个分支是必须稍后回填的前向分支。\n\n假设子表达式 $A$ 和 $B$ 具有以下属性，这些属性基于它们的内部结构以及关系原子到 `if ... goto L_true; goto L_false` 形式的标准短路翻译：\n\n- $|TL(A)| = 3$, $|FL(A)| = 2$。\n- $|TL(B)| = 4$, $|FL(B)| = 3$。\n\n在 $A \\wedge B$ 的短路求值下，只有当 $A$ 的值为真时才会对 $B$ 进行求值，这意味着 $TL(A)$ 中的所有条目都必须回填到 $B$ 的入口标号。构建合取后，$TL(A \\wedge B)$ 是到达合取整体真结果的前向分支集合，而 $FL(A \\wedge B)$ 是到达整体假结果的集合。\n\n使用上述定义和这些基数，计算策略 $\\mathsf{Swap}$ 和策略 $\\mathsf{NegNode}$ 所需的回填操作总数，然后计算节省量（定义为策略 $\\mathsf{NegNode}$ 中的回填操作数减去策略 $\\mathsf{Swap}$ 中的回填操作数）。将你的最终答案表示为一个没有单位的整数。不需要四舍五入；报告精确的整数。",
            "solution": "该问题要求分析两种不同的编译器策略在翻译语句 `if (!(A \\wedge B))` 时所需的回填操作总数。一次回填操作定义为解析一个未解析的前向分支。因此，回填操作的总数等于在编译过程中创建和解析的未解析前向分支的总数。\n\n首先，我们确定合取 $E = A \\wedge B$ 的短路求值语义。控制流规定只有当 $A$ 为真时才对 $B$ 求值。如果 $A$ 为假，整个表达式都为假。\n1.  $A$ 的真列表 $TL(A)$ 中的分支必须被解析，以指向子表达式 $B$ 代码的入口点。这构成了一组回填操作，数量为 $|TL(A)|$。\n2.  组合表达式 $E$ 的真列表 $TL(E)$ 仅包含那些使整个表达式为真的分支。这仅在 $A$ 和 $B$ 都为真时发生。因此，$TL(A \\wedge B) = TL(B)$。\n3.  组合表达式 $E$ 的假列表 $FL(E)$ 包含任何使表达式为假的分支。这在 $A$ 为假，或者 $A$ 为真且 $B$ 为假时发生。因此，$FL(A \\wedge B)$ 是其组成部分假列表的并集：$FL(A \\wedge B) = FL(A) \\cup FL(B)$。子表达式 $A$ 和 $B$ 是不同的，所以它们的跳转列表是不相交的。其基数为 $|FL(A \\wedge B)| = |FL(A)| + |FL(B)|$。\n\n给定的子表达式基数是：\n- $|TL(A)| = 3$\n- $|FL(A)| = 2$\n- $|TL(B)| = 4$\n- $|FL(B)| = 3$\n\n源于 $A$ 和 $B$ 原子翻译的未解析分支总数为 $|TL(A)| + |FL(A)| + |TL(B)| + |FL(B)| = 3 + 2 + 4 + 3 = 12$。\n\n我们现在分析每种策略。\n\n**策略 $\\mathsf{Swap}$**\n\n该策略首先计算 $A \\wedge B$ 的列表，然后交换它们以实现逻辑非。\n1.  **代码生成：** 如上计算，子表达式 $A$ 和 $B$ 的翻译总共引入了 $12$ 个未解析的分支。$\\mathsf{Swap}$ 策略不引入任何新的分支；它只是重新利用现有的分支。因此，回填操作的总数必须恰好是 $12$。我们可以通过追踪它们的解析过程来验证这一点。\n2.  **内部回填：** 为了形成 $A \\wedge B$ 的代码，$TL(A)$ 中的分支被回填到 $B$ 代码的开头。这需要 $|TL(A)| = 3$ 次回填操作。\n3.  **最终列表解析：** `if` 语句对条件 $C = !(A \\wedge B)$ 求值。\n    - $C$ 的真列表 $TL(C)$ 是通过交换得到的，所以 $TL(C) = FL(A \\wedge B) = FL(A) \\cup FL(B)$。这些分支被回填到 `then` 子句。操作次数为 $|FL(A)| + |FL(B)| = 2 + 3 = 5$。\n    - 类似地，$C$ 的假列表 $FL(C)$ 为 $FL(C) = TL(A \\wedge B) = TL(B)$。这些分支被回填到 `else` 子句。操作次数为 $|TL(B)| = 4$。\n4.  **总操作数：** 策略 $\\mathsf{Swap}$ 的回填操作总数，记为 $N_{\\mathsf{Swap}}$，是所有已解析分支的总和。\n    $$N_{\\mathsf{Swap}} = |TL(A)| + (|FL(A)| + |FL(B)|) + |TL(B)|$$\n    $$N_{\\mathsf{Swap}} = 3 + (2 + 3) + 4 = 3 + 5 + 4 = 12$$\n    这证实了所有 $12$ 个初始未解析分支都得到了解析。\n\n**策略 $\\mathsf{NegNode}$**\n\n该策略首先将 $A \\wedge B$ 的真假结果解析到临时标号，然后为否定操作生成新的分支。\n1.  **代码生成和内部分辨：** 和之前一样，翻译 $A$ 和 $B$ 会创建 $12$ 个初始未解析分支。该策略在内部解析所有这些分支，然后创建新的分支。\n    - 将 $TL(A)$ 回填到 $B$ 的入口：$|TL(A)| = 3$ 次操作。\n    - $A \\wedge B$ 的列表为 $TL(A \\wedge B)=TL(B)$ 和 $FL(A \\wedge B)=FL(A) \\cup FL(B)$。\n    - 将 $TL(A \\wedge B)$ 回填到临时真标号 $L_{true\\_temp}$：$|TL(B)| = 4$ 次操作。\n    - 将 $FL(A \\wedge B)$ 回填到临时假标号 $L_{false\\_temp}$：$|FL(A)| + |FL(B)| = 2 + 3 = 5$ 次操作。\n    - 此时，所有 $3 + 4 + 5 = 12$ 个原始未解析分支都已被回填。\n2.  **否定节点生成：** `NegNode` 本身在临时标号处生成新代码和新的未解析分支。\n    - 在 $L_{true\\_temp}$ 处（$A \\wedge B$ 为真），否定 `!` 使结果为假。创建一个新的分支 `goto L_final_else`。这是 $1$ 个新的未解析分支。\n    - 在 $L_{false\\_temp}$ 处（$A \\wedge B$ 为假），否定 `!` 使结果为真。创建一个新的分支 `goto L_final_true`。这是第 $2$ 个新的未解析分支。\n3.  **最终列表解析：** 这两个新分支构成了条件 $C = !(A \\wedge B)$ 的最终真假列表。\n    - $TL(C)$ 包含一个指向 `L_final_true` 的分支。将其回填到 `then` 子句需要 $1$ 次操作。\n    - $FL(C)$ 包含一个指向 `L_final_false` 的分支。将其回填到 `else` 子句需要 $1$ 次操作。\n4.  **总操作数：** 策略 $\\mathsf{NegNode}$ 的回填操作总数 $N_{\\mathsf{NegNode}}$ 是解析初始分支和新生成分支的操作数之和。\n    $$N_{\\mathsf{NegNode}} = (\\text{初始分支的操作数}) + (\\text{新分支的操作数})$$\n    $$N_{\\mathsf{NegNode}} = (|TL(A)| + |TL(B)| + |FL(A)| + |FL(B)|) + 2$$\n    $$N_{\\mathsf{NegNode}} = (3 + 4 + 2 + 3) + 2 = 12 + 2 = 14$$\n\n**节省量计算**\n\n问题将节省量定义为策略 $\\mathsf{NegNode}$ 中的回填操作数减去策略 $\\mathsf{Swap}$ 中的回填操作数。\n$$节省量 = N_{\\mathsf{NegNode}} - N_{\\mathsf{Swap}}$$\n$$节省量 = 14 - 12 = 2$$\n策略 $\\mathsf{NegNode}$ 比策略 $\\mathsf{Swap}$ 多需要 $2$ 次回填操作，因此后者相对于前者节省了 $2$ 次操作。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}