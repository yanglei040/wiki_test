{
    "hands_on_practices": [
        {
            "introduction": "理解活动记录（或称栈帧）的精确布局，是系统程序员和编译器设计者的基本功。本练习将要求你应用真实世界中应用程序二进制接口（Application Binary Interface, ABI）的具体规则来构建一个栈帧，通过实践加深对局部变量、函数参数和对齐约束如何协同工作的理解 。",
            "id": "3680344",
            "problem": "在用于 Advanced Micro Devices 64 位架构 (AMD64) 的 System V 应用程序二进制接口 (SysV ABI) 中，一个函数通过寄存器接收其前六个整数参数，任何额外的整数参数则通过栈接收。栈向低地址方向增长。调用者执行一个 `call` 指令，该指令会推入返回地址；被调用者执行一个标准序言 (prologue)，该序言会推入基址指针 ($\\mathrm{RBP}$)，将 $\\mathrm{RBP}$ 设置为栈指针 ($\\mathrm{RSP}$)，然后减去一个连续的块用于本地存储。在此环境中，对齐不变性要求是在任何 `call` 指令之前，$\\mathrm{RSP}$ 必须对齐到 $16$ 字节边界。此处描述的函数是非可变参数函数，使用帧指针，调用另一个函数（因此不能依赖于红色区域 (red zone)），并且除了 $\\mathrm{RBP}$ 之外不推入任何被调用者保存的寄存器。\n\n给定该函数恰好有 $7$ 个整数参数和三个局部变量，其大小和对齐要求如下：\n- 局部变量 $L_{1}$ 大小为 $8$ 字节，要求 $8$ 字节对齐。\n- 局部变量 $L_{2}$ 大小为 $16$ 字节，要求 $16$ 字节对齐。\n- 局部变量 $L_{3}$ 大小为 $24$ 字节，要求 $8$ 字节对齐。\n\n假设局部变量按源顺序 $L_{1}$、然后 $L_{2}$、然后 $L_{3}$ 分配，从高地址到低地址连续布局，仅插入满足每个局部变量相对于 $\\mathrm{RBP}$ 的指定对齐要求所需的最小填充。将每个局部变量的“基地址”定义为其存储空间的最低地址字节，并将所有字节偏移量定义为相对于 $\\mathrm{RBP}$ 的值。\n\n从上述基本事实（栈向下增长、`call` 指令推入返回地址、序言推入并设置 $\\mathrm{RBP}$、SysV ABI 寄存器/栈参数规则，以及在调用点 $\\mathrm{RSP}$ 的 $16$ 字节对齐要求）出发，通过以下步骤重建确切的栈帧布局：\n1. 确定 $L_{1}$、$L_{2}$ 和 $L_{3}$ 的基偏移量（相对于 $\\mathrm{RBP}$），满足它们的对齐要求且不重叠。\n2. 确定第七个整数参数的偏移量（相对于 $\\mathrm{RBP}$）。\n3. 确定必须在局部区域（除了局部变量本身所需的空间之外）添加的最小额外填充字节数，以确保从此函数发出的任何 `call` 指令之前，$\\mathrm{RSP}$ 对齐到 $16$ 字节边界。\n\n将你的最终答案表示为一个行矩阵，顺序为 $\\left(L_{1}, L_{2}, L_{3}, \\text{arg}_{7}, \\text{padding}\\right)$，其中每个条目是所需的偏移量或填充量（以字节为单位）。无需四舍五入。",
            "solution": "用户希望确定一个在 System V AMD64 ABI 下编译的函数的栈帧布局。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **架构/ABI：** 用于 AMD64 的 System V 应用程序二进制接口 (SysV ABI)。\n- **参数传递：** 前六个整数参数在寄存器中；额外的整数参数在栈上。\n- **栈增长：** 朝向更低的内存地址。\n- **`call` 指令：** 推入 8 字节的返回地址。\n- **函数序言：** 标准序言：`push RBP`, `mov RBP, RSP`, `sub RSP, N`。\n- **栈对齐：** 在任何 `call` 指令之前，`RSP` 必须对齐到 $16$ 字节边界。\n- **函数属性：** 非可变参数，使用帧指针 (`RBP`)，调用另一个函数（非叶函数），不使用红色区域 (red zone)，除了 `RBP` 外不推入任何被调用者保存的寄存器。\n- **函数签名：** 恰好 $7$ 个整数参数。\n- **局部变量：**\n    - $L_{1}$：大小 $8$ 字节，对齐 $8$ 字节。\n    - $L_{2}$：大小 $16$ 字节，对齐 $16$ 字节。\n    - $L_{3}$：大小 $24$ 字节，对齐 $8$ 字节。\n- **局部变量布局：** 按源顺序（$L_{1}$、$L_{2}$、$L_{3}$）分配，从高地址到低地址连续布局，使用最小填充以满足相对于 `RBP` 的对齐要求。\n- **定义：** “基地址”是局部变量存储空间的最低地址字节。偏移量相对于 `RBP`。\n\n**1.2. 使用提取的已知条件进行验证**\n根据验证标准评估问题陈述。\n- **科学依据：** 该问题基于真实世界中明确定义的 System V AMD64 ABI。所有陈述的行为（栈增长、`call` 指令、序言、寄存器/栈参数传递、对齐规则）都是对该标准的事实正确描述。这是计算机组成和编译器设计中的一个典型问题。**(有效)**\n- **定义明确：** 该问题提供了一整套约束条件（参数数量、局部变量属性、ABI 规则），并要求得出具体的、可量化的结果（偏移量和填充）。这些约束足以确定一个唯一的解。**(有效)**\n- **客观性：** 问题以精确的技术语言陈述，没有歧义、主观性或意见。**(有效)**\n- **完整性与一致性：** 已知条件是自洽的，并且足以求解。没有矛盾。**(有效)**\n- **现实性：** 该场景是理解编译器如何生成代码和管理栈的标准练习，这是计算机科学中的一个基本主题。**(有效)**\n\n**1.3. 结论与行动**\n问题有效。将提供详细的解决方案。\n\n### 步骤 2：详细解决方案\n\n解决方案是通过根据 System V AMD64 ABI 的规则重建栈帧布局来得出的。所有偏移量都是相对于函数序言执行后的基址指针 `RBP`。\n\n**2.1. 确定 RBP 的对齐**\n首先，我们确定基址指针 `RBP` 的对齐方式。\n1.  ABI 规定，在 `call` 指令之前，栈指针 `RSP` 必须对齐到 $16$ 字节边界。设调用者在调用我们函数之前的 `RSP` 为 $S_{caller}$，其中 $S_{caller} \\pmod{16} = 0$。\n2.  `call` 指令将 $8$ 字节的返回地址推入栈中。因此，在进入我们的函数时，`RSP` 位于地址 $S_{caller} - 8$。因此，入口处的 `RSP` 值为 $16k - 8$（对于某个整数 $k$），这意味着 $RSP \\pmod{16} = 8$。这与 ABI 要求函数入口处的 `(RSP + 8)` 是 $16$ 的倍数一致。\n3.  被调用者序言的第一条指令是 `push RBP`。这将旧 `RBP` 的 $8$ 字节值推入栈，并使 `RSP` 减 $8$。`RSP` 现在位于 $(S_{caller} - 8) - 8 = S_{caller} - 16$。这个地址是 $16$ 的倍数。\n4.  下一条指令是 `mov RBP, RSP`。这将新帧的基址指针 `RBP` 设置为 `RSP` 的当前值。\n因此，在我们函数的执行期间，`RBP` 的值是对齐到 $16$ 字节边界的。这是确定局部变量偏移量的一个关键事实。\n\n**2.2. 确定第七个参数（`arg_7`）的偏移量**\n参数位于相对于 `RBP` 的正偏移量处。\n-   `[RBP + 0]`：此位置存储调用者帧中保存的 `RBP`（由我们的序言推入）。\n-   `[RBP + 8]`：此位置存储返回地址（由 `call` 指令推入）。\n-   前六个整数参数通过寄存器传递。第七个参数 `arg_7` 是第一个通过栈传递的参数。调用者在 `call` 之前将其放置在栈上。它位于返回地址的正上方。\n-   因此，第七个参数位于 `[RBP + 16]`。\n`arg_7` 相对于 `RBP` 的偏移量是 $+16$ 字节。\n\n**2.3. 确定局部变量（$L_1, L_2, L_3$）的偏移量**\n局部变量存储在相对于 `RBP` 的负偏移量处。它们从高地址（更靠近 `RBP`）向低地址布局。问题指定了满足对齐约束的最小填充。我们已经确定 `RBP` 是 $16$ 字节对齐的。一个相对于 `RBP` 偏移量为 `off` 的对象，其地址为 `RBP + off`。为了使该地址具有 `A` 的对齐方式，我们需要 `(RBP + off) \\pmod A = 0`。由于 `RBP` 是任何所需对齐（$8$ 或 $16$）的倍数，这可以简化为 `off \\pmod A = 0`。\n\n-   **$L_{1}$ 的布局（大小 $8$，对齐 $8$）：**\n    $L_1$ 是第一个局部变量，所以它被放置在最靠近 `RBP` 的位置。我们需要为一个 $8$ 字节且 $8$ 字节对齐的对象找到基偏移量 $off_1  0$。为了尽可能靠近 `RBP`，我们将其基地址放在 `RBP-8`。偏移量为 $off_1 = -8$。这满足对齐要求，因为 $-8 \\pmod 8 = 0$。\n    -   $L_{1}$ 占据内存范围 `[RBP - 8, RBP - 1]`。\n    -   $L_1$ 的基偏移量是 $-8$。\n\n-   **$L_{2}$ 的布局（大小 $16$，对齐 $16$）：**\n    $L_2$ 必须紧接着 $L_1$ 下方连续放置。$L_1$ 占用的内存到 `RBP - 8` 结束，所以下一个可用地址是 `RBP - 9`。$L_2$ 是一个 $16$ 字节的对象，所以它的内存块是 `[base, base + 15]`。这个块的顶部 `base + 15` 必须位于小于或等于 `RBP - 9` 的地址。用偏移量来说，设基偏移量为 $off_2$。该块是 `[RBP + off_2, RBP + off_2 + 15]`。我们必须有 $off_2 + 15 \\le -9$，这意味着 $off_2 \\le -24$。此外，基偏移量必须是 $16$ 字节对齐的：$off_2 \\pmod{16} = 0$。我们需要找到小于或等于 $-24$ 且是 $16$ 的倍数的最大整数偏移量（最接近 $0$）。这个值是 $-32$。\n    -   $L_{2}$ 占据内存范围 `[RBP - 32, RBP - 17]`。\n    -   $L_2$ 的基偏移量是 $-32$。\n    -   注意：这在 `RBP - 16` 和 `RBP - 9` 之间创建了一个 $8$ 字节的填充区域。\n\n-   **$L_{3}$ 的布局（大小 $24$，对齐 $8$）：**\n    $L_3$ 放置在 $L_2$ 的下方。$L_2$ 占据的内存范围是 `[RBP - 32, RBP - 17]`，因此下一个可用地址是 `RBP - 33`。设 $L_3$ 的基偏移量为 $off_3$。其内存块是 `[RBP + off_3, RBP + off_3 + 23]`，我们必须有 $off_3 + 23 \\le -33$，这意味着 $off_3 \\le -56$。基偏移量必须是 $8$ 字节对齐的：$off_3 \\pmod 8 = 0$。我们需要找到小于或等于 $-56$ 且是 $8$ 的倍数的最大整数偏移量。这个值是 $-56$。\n    -   $L_{3}$ 占据内存范围 `[RBP - 56, RBP - 33]`。\n    -   $L_3$ 的基偏移量是 $-56$。\n    -   $L_2$ 和 $L_3$ 之间没有填充。\n\n所有局部变量及其内部填充所需的连续内存块从 `RBP - 1` 向下延伸到 `RBP - 56`，总大小为 $56$ 字节。\n\n**2.4. 确定用于调用对齐的额外填充**\n该函数调用另一个函数，所以它是非叶函数。在它发出 `call` 指令之前，`RSP` 必须是 $16$ 字节对齐的。\n局部存储区域占据 $56$ 字节。序言必须通过 `sub RSP, N` 分配至少这么大的空间。\n设总分配为 $N$ 字节，其中 $N = 56 + P$，而 $P$ 是额外填充。序言之后，`RSP = RBP - N`。\n一种标准且稳健的编译策略是在序言之后立即对齐栈指针。这为函数体提供了一个正确对齐的栈来进行操作，简化了后续为调用所做的准备。为实现这一点，局部区域的总分配大小 `N` 必须是 $16$ 的倍数，因为 `RBP` 是 $16$ 字节对齐的。\n-   局部变量所需大小：$56$ 字节。\n-   我们需要找到不小于 $56$ 的最小的 $16$ 的倍数，我们称之为 $N$。\n-   $16$ 的倍数：$16, 32, 48, 64, ...$\n-   大于或等于 $56$ 的最小的 $16$ 的倍数是 $64$。\n-   所以，总分配大小是 $N=64$ 字节。\n-   所需的额外填充是 $P = N - 56 = 64 - 56 = 8$ 字节。\n\n有了这个填充，序言指令将是 `sub RSP, 64`。`RSP` 随后将是 `RBP - 64`，这是 $16$ 字节对齐的。当此函数随后调用另一个函数时，`RSP` 已经对齐（假设子调用不带栈参数）。如果子调用需要栈参数，编译器会从这个对齐的基址开始执行进一步的栈调整来准备参数，同时保持对齐不变性。静态帧中的这 $8$ 字节填充是建立这个对齐基址所需的最小量。\n\n**结果摘要：**\n-   $L_{1}$ 的偏移量：$-8$ 字节。\n-   $L_{2}$ 的偏移量：$-32$ 字节。\n-   $L_{3}$ 的偏移量：$-56$ 字节。\n-   `arg_7` 的偏移量：$+16$ 字节。\n-   额外填充：$8$ 字节。\n\n最终答案是按指定顺序排列的这些值的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-8  -32  -56  16  8\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在基本栈帧布局之上，现代编译器会加入安全特性以缓解诸如缓冲区溢出之类的常见漏洞。本练习通过要求你确定“栈金丝雀”（stack canary）在活动记录中的最佳位置来保护关键控制数据，从而探讨了这一概念 。这个练习突出了编译器设计、系统架构和软件安全之间的相互作用。",
            "id": "3680369",
            "problem": "一个函数 $f$ 有两个局部变量：一个大小为 $64$ 字节的字符缓冲区和一个 $32$ 位整数。目标机器是一台 $64$ 位机器，遵循适用于 Advanced Micro Devices $64$ 位 (AMD64) 的 System V 应用程序二进制接口 (ABI)，并以下列经过充分验证的事实为基本依据：栈向低地址方向增长，`call` 指令将返回地址压入当前栈指针 $RSP$ 所在的栈顶，标准的函数序言（prologue）通过压入 $RBP$ 来保存调用者的基指针，然后设置 $RBP \\leftarrow RSP$，通过从 $RSP$ 中减去一个非负值来分配局部存储空间，并且在调用边界处 $RSP$ 保持 $16$ 字节对齐。栈金丝雀（stack canary）是一个大小为 $8$ 字节的哨兵值，旨在检测连续的缓冲区溢出；它必须被放置在这样的位置：从局部数组向控制数据的线性覆写在到达控制数据之前会先破坏该哨兵值。在函数尾声（epilogue）中，该金丝雀会与一个已知的守卫值进行比较，如果不匹配，控制流必须转移到一个不会返回的处理程序。\n\n假设没有变长数组，没有使用 $alloca$ 进行动态分配，并且除了 $RBP$ 之外没有其他被调用者保存的寄存器溢出到栈上。整数的自然对齐是 $4$ 字节；字符缓冲区的自然对齐是 $1$ 字节；金丝雀的对齐是 $8$ 字节。编译器会安排局部变量和填充（padding）以满足这些对齐要求，同时也要满足 $16$ 字节的栈对齐规则。请选择正确描述以下内容的选项：\n- 活动记录（activation record）中字段的顺序（相对于 $RBP$ 从高地址到低地址），\n- $8$ 字节金丝雀相对于局部变量和已保存的帧指针的精确位置，\n- 局部栈分配的总大小（以字节为单位），\n- 以及在函数尾声中何时以及如何验证金丝雀。\n\nA. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $80$ 字节来分配帧。编译器将 $8$ 字节的金丝雀写入 $[RBP-8]$。在金丝雀下方，是位于 $[RBP-12..RBP-9]$ 的 $4$ 字节填充以对齐整数，然后是位于 $[RBP-16..RBP-13]$ 的 $4$ 字节整数，再然后是位于 $[RBP-80..RBP-17]$ 的 $64$ 字节缓冲区。因此，从 $RBP$ 附近的高地址到低地址依次是：位于 $[RBP]$ 的已保存的 $RBP$，位于 $[RBP-8]$ 的金丝雀，其下的填充和小的局部变量，最后是位于帧内最低地址的缓冲区。在函数尾声中，在恢复 $RBP$ 或 $RSP$ 之前，函数加载已知的守卫值并将其与 $[RBP-8]$ 处的值进行比较；若不匹配，则调用一个不返回的失败例程；若匹配，则恢复 $RBP$ 并执行 $RET$。\n\nB. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $72$ 字节来分配帧。编译器将 $8$ 字节的金丝雀写入缓冲区正下方的最低地址槽位，以便检测任何下溢（underflow）：$64$ 字节的缓冲区位于 $[RBP-8..RBP-71]$，金丝雀位于 $[RBP-80..RBP-73]$；$4$ 字节的整数被放置在紧邻 $RBP$ 下方的位置，即 $[RBP-4..RBP-1]$。在函数尾声中，在执行 $leave$（恢复 $RBP$）之后，函数比较金丝雀，若不匹配，则执行 $RET$ 返回到失败处理程序。\n\nC. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $76$ 字节，恰好为局部变量和金丝雀分配空间，没有额外的填充。为了最大程度地保护返回地址，编译器将 $8$ 字节的金丝雀写入已保存的 $RBP$ 和返回地址之间，即 $[RBP+8..RBP+15]$。局部变量完全放置在 $RBP$ 下方，不考虑填充：$64$ 字节的缓冲区紧邻于 $[RBP-64..RBP-1]$，$4$ 字节的整数位于 $[RBP-68..RBP-65]$。在函数尾声中，从 $[RBP+8]$ 读取金丝雀并进行比较；如果与守卫值匹配，函数执行 $RET$。\n\nD. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $68$ 字节仅为局部变量分配空间。为避免额外的内存流量，编译器仅在被调用者保存的寄存器 $RBX$ 中保留 $8$ 字节的金丝雀，而不将其存储在栈上。局部变量紧密地排列在 $RBP$ 下方，$4$ 字节的整数位于 $[RBP-4..RBP-1]$，其后是位于 $[RBP-68..RBP-5]$ 的 $64$ 字节缓冲区。在函数尾声中，它将 $RBX$ 与守卫值进行比较，如果相等，则执行 $leave$ 和 $RET$；如果不等，则将 $RBX$ 置零并通过 $RET$ 返回到失败处理程序。",
            "solution": "用户提供了一个关于在启用栈金丝雀保护的情况下，遵循 System V AMD64 ABI 的 $64$ 位机器上函数活动记录（栈帧）布局的问题。任务是验证问题陈述，推导正确的栈帧配置，并评估给定的选项。\n\n### 问题验证\n\n首先，我将验证问题陈述本身。\n\n**第 1 步：提取已知条件**\n-   **函数 `f` 的局部变量**：一个大小为 $64$ 字节的字符缓冲区和一个 $32$ 位（$4$ 字节）的整数。\n-   **体系结构**：$64$ 位机器，System V AMD64 ABI。\n-   **栈属性**：向低地址方向增长。\n-   **`call` 指令**：压入 $8$ 字节的返回地址到栈上。\n-   **函数序言**：`push RBP`，然后 `mov RBP, RSP`。\n-   **局部存储分配**：`sub RSP, size`，其中 `size` $\\ge 0$。\n-   **栈对齐**：在 `call` 边界处，`RSP` 必须是 $16$ 字节对齐的。\n-   **栈金丝雀**：一个 $8$ 字节的哨兵值。\n-   **金丝雀放置规则**：必须放置在局部数组和控制数据（已保存的 `RBP`、返回地址）之间，以检测缓冲区溢出。溢出是从低地址向高地址写入。\n-   **金丝雀验证**：在函数尾声中与一个守卫值进行检查；如果不匹配，则转移到一个不返回的处理程序。\n-   **局部变量对齐**：整数的自然对齐是 $4$ 字节；字符缓冲区的自然对齐是 $1$ 字节；金丝雀的对齐是 $8$ 字节。\n-   **假设**：没有变长数组，没有 `alloca`，除了 `RBP` 外没有其他被调用者保存的寄存器溢出。\n\n**第 2 步：使用提取的已知条件进行验证**\n-   **科学依据**：问题陈述坚实地植根于计算机体系结构和编译器设计的原理。System V AMD64 ABI、栈帧结构、函数序言/尾声、栈对齐以及栈金丝雀的概念都是系统编程中标准且有据可查的主题。描述在事实上是正确的。\n-   **问题定义良好**：问题提供了一套完整的约束条件（变量大小、对齐方式、ABI 规则），足以确定栈帧的布局。问题是具体的，可以通过从这些规则推导布局来回答。\n-   **客观性**：问题以精确的技术语言（如 “RSP”、“RBP”、“ABI”、“16-byte aligned”）陈述，没有主观或模糊的术语。\n\n**第 3 步：结论与行动**\n问题陈述内部一致、科学合理且定义良好。它准确地模拟了一个真实世界的场景。因此，该问题是**有效的**。我将继续进行推导和分析。\n\n### 正确栈帧布局的推导\n\n1.  **初始栈状态**：在 `call` 函数 `f` 之前，`RSP` 是 $16$ 字节对齐的，意味着 `RSP = 16k`（对于某个整数 `k`）。\n2.  **`call` 指令**：`call` 指令压入 $8$ 字节的返回地址。新的 `RSP` 是 `16k - 8`。\n3.  **函数序言**：\n    -   `push RBP`：调用者的 $8$ 字节 `RBP` 被压入。新的 `RSP` 是 `16k - 8 - 8 = 16k - 16`，这又回到了 $16$ 字节对齐。\n    -   `mov RBP, RSP`：`RBP` 寄存器被设置为当前的 `RSP`。因此，`RBP` 现在持有一个 $16$ 字节对齐的地址。已保存的 `RBP` 位于 `[RBP]`，返回地址位于 `[RBP+8]`。这些构成了栈上的控制数据。\n\n4.  **局部数据和金丝雀的放置**：栈向下（向低地址）增长。缓冲区溢出将向上（向高地址）写入。为了保护位于 `[RBP]` 和 `[RBP+8]` 的控制数据，金丝雀必须放置在比缓冲区更高的地址。标准的布局，从高地址到低地址，是：`已保存的 RBP` $\\rightarrow$ `金丝雀` $\\rightarrow$ `其他局部变量` $\\rightarrow$ `缓冲区`。\n\n5.  **布局和大小计算**：我们需要为空出一个 $8$ 字节的金丝雀、一个 $4$ 字节的整数和一个 $64$ 字节的缓冲区分配空间。\n    -   **金丝雀**：大小 $8$ 字节，对齐 $8$ 字节。它被放置在已保存的 `RBP` 的正下方。由于 `RBP` 是 $16$ 字节对齐的，地址 `RBP-8` 是 $8$ 字节对齐的。我们将金丝雀放置在 `[RBP-8]`，占据内存范围 `[RBP-8, RBP-1]`。\n    -   **整数**：大小 $4$ 字节，对齐 $4$ 字节。它必须放置在金丝雀的下方。金丝雀下方的内存从地址 `RBP-9` 开始。整数的基地址必须是 $4$ 的倍数。下一个较低的、是 $4$ 的倍数的地址是 `RBP-12`。为简单和性能起见，一种常见的编译器策略可能是将局部变量对齐到更大的边界。让我们考虑将整数放置在 `RBP-16`，这也是一个 $4$ 字节对齐的地址。这会留下一个间隙。\n    -   **缓冲区**：大小 $64$ 字节，对齐 $1$ 字节。放置在最低的地址。\n    -   让我们分析一个基于这些项目的连续布局：\n        -   **金丝雀**（8 字节）：占据 `[RBP-8, RBP-1]`。\n        -   要接着放置**整数**（4 字节，对齐 4），我们需要尊重它的对齐要求。如果从 `RBP-16` 开始放置它，它将占据 `[RBP-16, RBP-13]`。这是有效的，因为 `RBP-16` 是 $4$ 字节对齐的。金丝雀和整数之间的空间，即 `[RBP-12, RBP-9]`，成为 $4$ 字节的填充。\n        -   接下来，我们放置**缓冲区**（64 字节，对齐 1）。它被放置在整数的正下方。整数结束于地址 `...-16`。缓冲区将从 `...-17` 开始，并向下延伸 $64$ 字节。它将占据范围 `[RBP-80, RBP-17]`。\n    -   这个布局为所有局部数据（金丝雀、填充、整数、缓冲区）创建了一个从 `RBP-80` 到 `RBP-1` 的连续块。总大小为 $80$ 字节。\n\n6.  **总栈分配大小**：所需的总大小是 $80$ 字节。分配通过 `sub RSP, 80` 完成。由于 `RBP` 是 $16$ 字节对齐的，新的 `RSP` 将是 `RBP - 80`。因为 $80$ 是 $16$ 的倍数，新的 `RSP` 也将是 $16$ 字节对齐的。这满足了 ABI 对 `RSP` 在函数 `f` 进行任何后续 `call` 指令之前必须对齐的要求。\n\n7.  **尾声和金丝雀检查**：函数尾声必须反转序言的操作。在恢复 `RBP` 和 `RSP` 之前，函数必须验证金丝雀。\n    -   位于金丝雀位置 `[RBP-8]` 的值将与原始的守卫值（通常存储在线程局部段中，通过 `FS` 寄存器访问）进行比较。\n    -   如果它们不匹配，就检测到了栈粉碎攻击，控制流被转移到一个不返回的错误处理程序（例如 `__stack_chk_fail`）。\n    -   如果它们匹配，函数继续其正常的尾声：`mov RSP, RBP` 后跟 `pop RBP`（或等效的 `leave` 指令），然后是 `ret`。\n\n这个推导出的模型提供了一个关于栈帧的完整而正确的描述。\n\n### 逐项分析选项\n\n**A. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $80$ 字节来分配帧。编译器将 $8$ 字节的金丝雀写入 $[RBP-8]$。在金丝雀下方，是位于 $[RBP-12..RBP-9]$ 的 $4$ 字节填充以对齐整数，然后是位于 $[RBP-16..RBP-13]$ 的 $4$ 字节整数，再然后是位于 $[RBP-80..RBP-17]$ 的 $64$ 字节缓冲区。因此，从 $RBP$ 附近的高地址到低地址依次是：位于 $[RBP]$ 的已保存的 $RBP$，位于 $[RBP-8]$ 的金丝雀，其下的填充和小的局部变量，最后是位于帧内最低地址的缓冲区。在函数尾声中，在恢复 $RBP$ 或 $RSP$ 之前，函数加载已知的守卫值并将其与 $[RBP-8]$ 处的值进行比较；若不匹配，则调用一个不返回的失败例程；若匹配，则恢复 $RBP$ 并执行 $RET$。**\n\n-   **分析**：该选项的描述与推导出的模型完全匹配。\n    -   初始状态“返回地址位于 $[RSP]$”在 `call` 后立即是正确的。序言是标准的。\n    -   $80$ 字节的分配大小对于维持 $16$ 字节的 `RSP` 对齐是正确的。\n    -   将金丝雀放置在 `[RBP-8]` 对于保护已保存的 `RBP` 是正确的。\n    -   填充、整数和缓冲区的布局是合理的、连续的，满足所有对齐和排序约束，并导致总大小为 $80$ 字节。\n    -   对尾声的描述，包括金丝雀检查的时机和逻辑，是正确的。\n-   **结论**：**正确**。\n\n**B. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $72$ 字节来分配帧。编译器将 $8$ 字节的金丝雀写入缓冲区正下方的最低地址槽位，以便检测任何下溢（underflow）：$64$ 字节的缓冲区位于 $[RBP-8..RBP-71]$，金丝雀位于 $[RBP-80..RBP-73]$；$4$ 字节的整数被放置在紧邻 $RBP$ 下方的位置，即 $[RBP-4..RBP-1]$。在函数尾声中，在执行 $leave$（恢复 $RBP$）之后，函数比较金丝雀，若不匹配，则执行 $RET$ 返回到失败处理程序。**\n\n-   **分析**：该选项存在多个根本性缺陷。\n    -   $72$ 字节的分配大小不正确。它不是 $16$ 的倍数，因此违反了 `RSP` 对齐规则。\n    -   金丝雀的放置是错误的。它被放置在缓冲区的下方，因此无法保护控制数据（已保存的 `RBP` 和返回地址）免受向更高地址写入的缓冲区*溢出*的影响。金丝雀的目的是检测溢出，而不是下溢。\n    -   尾声逻辑是错误的。金丝雀检查发生在 `leave` 指令*之后*。`leave` 指令会释放栈帧，使得金丝雀的内存位置无效，从而使检查变得无用。\n-   **结论**：**不正确**。\n\n**C. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $76$ 字节，恰好为局部变量和金丝雀分配空间，没有额外的填充。为了最大程度地保护返回地址，编译器将 $8$ 字节的金丝雀写入已保存的 $RBP$ 和返回地址之间，即 $[RBP+8..RBP+15]$。局部变量完全放置在 $RBP$ 下方，不考虑填充：$64$ 字节的缓冲区紧邻于 $[RBP-64..RBP-1]$，$4$ 字节的整数位于 $[RBP-68..RBP-65]$。在函数尾声中，从 $[RBP+8]$ 读取金丝雀并进行比较；如果与守卫值匹配，函数执行 $RET$。**\n\n-   **分析**：该选项存在严重缺陷。\n    -   $76$ 字节的分配大小违反了 $16$ 字节的 `RSP` 对齐规则。\n    -   将金丝雀放置在 `[RBP+8]` 是灾难性的。这个地址保存着 `call` 指令压入的返回地址。覆写它会破坏函数返回机制。栈的这一部分属于调用者，而不是被调用者。\n    -   局部变量的布局没有为已保存的 `RBP` 提供金丝雀保护。\n    -   尾声从 `[RBP+8]` 读取，这将是读取它本应保护（并且现在已经损坏）的返回地址，而不是一个金丝雀值。\n-   **结论**：**不正确**。\n\n**D. 调用之后，返回地址位于 $[RSP]$。函数序言执行 $push\\ RBP$ 然后 $mov\\ RBP, RSP$，并减去 $68$ 字节仅为局部变量分配空间。为避免额外的内存流量，编译器仅在被调用者保存的寄存器 $RBX$ 中保留 $8$ 字节的金丝雀，而不将其存储在栈上。局部变量紧密地排列在 $RBP$ 下方，$4$ 字节的整数位于 $[RBP-4..RBP-1]$，其后是位于 $[RBP-68..RBP-5]$ 的 $64$ 字节缓冲区。在函数尾声中，它将 $RBX$ 与守卫值进行比较，如果相等，则执行 $leave$ 和 $RET$；如果不等，则将 $RBX$ 置零并通过 $RET$ 返回到失败处理程序。**\n\n-   **分析**：该选项从根本上误解了栈金丝雀的机制。\n    -   栈金丝雀必须在栈上才能检测到*栈上*的内存损坏。保存在寄存器中的值无法检测到覆写栈上相邻内存位置的缓冲区溢出。这不是栈金丝雀。\n    -   $68$ 字节的分配大小违反了 $16$ 字节的 `RSP` 对齐规则。\n-   **结论**：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "虽然正确性至关重要，但效率也是编译过程中的一个关键目标。本练习介绍了一种重要的优化技术：通过分析变量的生命周期并复用栈上的槽位，来最小化活动记录的大小 。通过计算峰值内存需求，你将量化此优化所节省的空间，从而深入了解编译器如何高效地管理内存。",
            "id": "3620340",
            "problem": "编译器的函数帧，也称为活动记录（Activation Record, AR），用于存储局部变量在其生命周期内的数据。在基于栈的后进先出（LIFO）执行模型中，AR 必须足够大，以容纳在任何程序点上同时活跃的所有局部变量。考虑一个函数，其 AR 中只包含以下局部变量，每个变量都需要连续的存储空间，并且具有共同的对齐方式 $A = 8$ 字节。每个局部变量 $x_i$ 都有一个以字节为单位的大小 $|x_i|$ 和一个生命周期，表示为抽象时间轴上的半开区间 $[s_i, e_i)$，单位为程序点。这意味着对于所有满足 $s_i \\le t  e_i$ 的时间 $t$，$x_i$ 都是活跃的。编译器可以为生命周期不重叠的变量覆盖存储空间，通过复用内存槽来最小化 AR 的峰值大小。假设所有变量的大小都是 $A$ 的倍数，因此对齐要求得到满足。忽略 AR 中的任何其他组件，如保存的寄存器或返回地址。这些变量是：\n- $x_1$: 大小 $|x_1| = 24$ 字节，生命周期 $[2, 10)$\n- $x_2$: 大小 $|x_2| = 16$ 字节，生命周期 $[5, 18)$\n- $x_3$: 大小 $|x_3| = 40$ 字节，生命周期 $[0, 7)$\n- $x_4$: 大小 $|x_4| = 8$ 字节，生命周期 $[9, 16)$\n- $x_5$: 大小 $|x_5| = 32$ 字节，生命周期 $[12, 20)$\n- $x_6$: 大小 $|x_6| = 24$ 字节，生命周期 $[17, 25)$\n- $x_7$: 大小 $|x_7| = 56$ 字节，生命周期 $[3, 14)$\n- $x_8$: 大小 $|x_8| = 16$ 字节，生命周期 $[22, 29)$\n\n从 AR 必须容纳同时活跃的局部变量这一基本原则出发，确定与为所有局部变量分配不相交内存槽的朴素布局相比，基于生命周期的内存槽复用策略可以节省的确切内存字节数。用字节表示你的最终答案。不需要四舍五入，并且除了这里列出的局部变量外，没有其他 AR 组件。",
            "solution": "问题陈述是有效的。它在科学上基于编译器设计的原理，特别是栈帧布局和通过生命周期分析进行的优化。问题提法清晰，提供了所有必要的数据（变量大小和生命周期）以确定一个唯一的、定量的答案。语言是客观的，没有歧义。\n\n任务是计算一个函数的活动记录（AR）中，相较于朴素分配策略，优化分配策略为局部变量所节省的内存。\n\n首先，让我们定义两种分配策略，并计算每种策略所需的内存。\n\n朴素分配策略为每个局部变量分配一个独立的、不重叠的内存槽。在这种方案下，AR 的总大小（表示为 $S_{\\text{naive}}$）就是所有变量大小的总和。给定的变量是：\n- $x_1$: 大小 $|x_1| = 24$ 字节，生命周期 $[2, 10)$\n- $x_2$: 大小 $|x_2| = 16$ 字节，生命周期 $[5, 18)$\n- $x_3$: 大小 $|x_3| = 40$ 字节，生命周期 $[0, 7)$\n- $x_4$: 大小 $|x_4| = 8$ 字节，生命周期 $[9, 16)$\n- $x_5$: 大小 $|x_5| = 32$ 字节，生命周期 $[12, 20)$\n- $x_6$: 大小 $|x_6| = 24$ 字节，生命周期 $[17, 25)$\n- $x_7$: 大小 $|x_7| = 56$ 字节，生命周期 $[3, 14)$\n- $x_8$: 大小 $|x_8| = 16$ 字节，生命周期 $[22, 29)$\n\n朴素分配策略下的总大小为：\n$$S_{\\text{naive}} = \\sum_{i=1}^{8} |x_i|$$\n$$S_{\\text{naive}} = |x_1| + |x_2| + |x_3| + |x_4| + |x_5| + |x_6| + |x_7| + |x_8|$$\n$$S_{\\text{naive}} = 24 + 16 + 40 + 8 + 32 + 24 + 56 + 16 = 216 \\text{ 字节}$$\n\n接下来，我们考虑优化分配策略。该策略为生命周期不重叠的变量复用内存位置（槽）。所需的 AR 大小 $S_{\\text{opt}}$ 由峰值内存需求决定，即在任何单个时间点 $t$ 上同时活跃的变量的总大小的最大值。设 $M(t)$ 为在时间 $t$ 活跃的变量的总大小。我们需要找到 $S_{\\text{opt}} = \\max_{t} M(t)$。\n\n活跃变量的集合，以及因此的 $M(t)$，仅在生命周期区间的起点和终点发生变化。我们可以沿时间轴执行扫描线分析，计算由这些事件点定义的每个区间内所使用的总内存。\n\n事件点是 $0, 2, 3, 5, 7, 9, 10, 12, 14, 16, 17, 18, 20, 22, 25, 29$。让我们计算这些点之间各个区间的内存使用量 $M(t)$。\n\n- 对于 $t \\in [0, 2)$：活跃变量：{$x_3$}。总大小：$|x_3| = 40$。\n- 对于 $t \\in [2, 3)$：活跃变量：{$x_3, x_1$}。总大小：$|x_3| + |x_1| = 40 + 24 = 64$。\n- 对于 $t \\in [3, 5)$：活跃变量：{$x_3, x_1, x_7$}。总大小：$64 + |x_7| = 64 + 56 = 120$。\n- 对于 $t \\in [5, 7)$：活跃变量：{$x_3, x_1, x_7, x_2$}。总大小：$120 + |x_2| = 120 + 16 = 136$。\n- 对于 $t \\in [7, 9)$：变量 $x_3$ 不再活跃。活跃变量：{$x_1, x_7, x_2$}。总大小：$136 - |x_3| = 136 - 40 = 96$。\n- 对于 $t \\in [9, 10)$：活跃变量：{$x_1, x_7, x_2, x_4$}。总大小：$96 + |x_4| = 96 + 8 = 104$。\n- 对于 $t \\in [10, 12)$：变量 $x_1$ 不再活跃。活跃变量：{$x_7, x_2, x_4$}。总大小：$104 - |x_1| = 104 - 24 = 80$。\n- 对于 $t \\in [12, 14)$：活跃变量：{$x_7, x_2, x_4, x_5$}。总大小：$80 + |x_5| = 80 + 32 = 112$。\n- 对于 $t \\in [14, 16)$：变量 $x_7$ 不再活跃。活跃变量：{$x_2, x_4, x_5$}。总大小：$112 - |x_7| = 112 - 56 = 56$。\n- 对于 $t \\in [16, 17)$：变量 $x_4$ 不再活跃。活跃变量：{$x_2, x_5$}。总大小：$56 - |x_4| = 56 - 8 = 48$。\n- 对于 $t \\in [17, 18)$：活跃变量：{$x_2, x_5, x_6$}。总大小：$48 + |x_6| = 48 + 24 = 72$。\n- 对于 $t \\in [18, 20)$：变量 $x_2$ 不再活跃。活跃变量：{$x_5, x_6$}。总大小：$72 - |x_2| = 72 - 16 = 56$。\n- 对于 $t \\in [20, 22)$：变量 $x_5$ 不再活跃。活跃变量：{$x_6$}。总大小：$56 - |x_5| = 56 - 32 = 24$。\n- 对于 $t \\in [22, 25)$：活跃变量：{$x_6, x_8$}。总大小：$24 + |x_8| = 24 + 16 = 40$。\n- 对于 $t \\in [25, 29)$：变量 $x_6$ 不再活跃。活跃变量：{$x_8$}。总大小：$40 - |x_6| = 40 - 24 = 16$。\n\n在此分析中观察到的 $M(t)$ 的最大值为 $136$ 字节，出现在区间 $[5, 7)$ 内。因此，优化 AR 所需的最小大小为：\n$$S_{\\text{opt}} = \\max_{t} M(t) = 136 \\text{ 字节}$$\n\n节省的内存量 $\\Delta S$ 是朴素分配大小与优化分配大小之差：\n$$\\Delta S = S_{\\text{naive}} - S_{\\text{opt}}$$\n$$\\Delta S = 216 - 136 = 80 \\text{ 字节}$$\n\n通过采用基于生命周期的分配策略节省的内存为 $80$ 字节。",
            "answer": "$$\n\\boxed{80}\n$$"
        }
    ]
}