{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the mark-and-sweep algorithm, we must move from theory to implementation. This first practice treats the object heap as a directed graph and asks you to simulate the entire garbage collection cycle, from marking reachable objects to sweeping the rest. By implementing a specific cost model based on graph operations, you will empirically verify the algorithm's fundamental time complexity of $O(n+m)$ and understand how the workload is distributed across the mark and sweep phases .",
            "id": "3657162",
            "problem": "You are given a directed graph $G = (V, E)$ with $|V| = n$ and $|E| = m$, and a root set $R \\subseteq V$. Consider a classical tracing garbage collector using the mark-and-sweep strategy. In the mark phase, the collector starts from the root set and explores reachable objects by following outgoing pointers; in the sweep phase, it linearly scans all objects to reclaim those not marked. The fundamental base for reasoning is the following: (i) graph reachability in a directed graph, (ii) the fact that each vertex can be marked at most once, (iii) the fact that the total number of outgoing edges across all vertices equals $m$, and (iv) a linear sweep visits all $n$ vertices.\n\nYou must implement a complete, deterministic program that simulates the mark-and-sweep process under the following cost model:\n- In the mark phase, every time a vertex is marked the action costs $1$ unit, and scanning the outgoing adjacency list of that vertex costs $1$ unit per edge encountered.\n- In the sweep phase, every vertex examined costs $1$ unit, regardless of whether it is reclaimed.\n\nYour program must compute, for each test case, the following quantities:\n- The total number of marked vertices $M$.\n- The total number of scanned edges $S$ in the mark phase, counted as the sum of outgoing edges of each vertex the collector scans exactly once when that vertex is first marked.\n- The total number of sweep checks $W$, which must equal $n$.\n- The total operation count $T$, defined as $T = M + S + W$.\n- A boolean $B$ indicating whether the inequality $T \\leq 2n + m$ holds in that test case, encoded as $1$ for true and $0$ for false.\n- The number of visited zero-out-degree vertices $Z_{\\text{vis}}$, that is, $|\\{ v \\in V \\mid v \\text{ is marked and } \\deg^{+}(v) = 0 \\}|$.\n- The total number of zero-out-degree vertices in the graph $Z_{\\text{tot}}$, that is, $|\\{ v \\in V \\mid \\deg^{+}(v) = 0 \\}|$.\n\nThe conceptual focus is to explain why, even when half of the nodes have zero out-degree, the time complexity of the mark-and-sweep remains $O(n+m)$, and how the edge scanning cost is distributed among vertices. You must derive this from the graph theoretical facts stated above and the explicit cost model, without relying on any pre-stated shortcut formulas beyond these fundamentals.\n\nYour program must hard-code and evaluate the following test suite, which covers a general case, two boundary conditions, and a case with unreachable edges:\n- Test case $A$: $n = 8$, edges are $0 \\rightarrow 1$, $0 \\rightarrow 2$, $1 \\rightarrow 3$, $2 \\rightarrow 3$, $2 \\rightarrow 6$, $4 \\rightarrow 5$. The root set is $R = \\{0, 4\\}$. This graph has $m = 6$ and exactly $4$ vertices with zero out-degree.\n- Test case $B$: $n = 0$, $m = 0$, $R = \\emptyset$.\n- Test case $C$: $n = 6$, no edges ($m = 0$), and $R = \\{0, 3\\}$. All vertices have zero out-degree.\n- Test case $D$: $n = 10$, edges are $0 \\rightarrow 1$, $1 \\rightarrow 2$, $2 \\rightarrow 0$, $3 \\rightarrow 4$, $4 \\rightarrow 3$, and vertices $5, 6, 7, 8, 9$ have zero out-degree ($m = 5$). The root set is $R = \\{0\\}$.\n\nFor each test case, you must perform an iterative depth-first graph traversal in the mark phase that scans each marked vertex’s adjacency list exactly once. The sweep phase must scan all $n$ vertices. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of the form $[n,m,M,S,W,T,B,Z_{\\text{vis}},Z_{\\text{tot}}]$. For example, the output should look like $[[x_1,x_2,\\dots,x_k],[y_1,y_2,\\dots,y_k],\\dots]$ with all entries as integers.",
            "solution": "The problem as stated is valid. It presents a well-defined algorithmic task grounded in the fundamental principles of graph theory and compiler design, specifically garbage collection. The problem is self-contained, with all necessary data, definitions, and constraints provided, and it is free from scientific inaccuracies, ambiguities, or contradictions. We shall therefore proceed with a complete solution.\n\nThe core of the problem is to analyze the computational cost of a classical mark-and-sweep garbage collector. This process is modeled as a graph traversal problem on a directed graph $G = (V, E)$, where vertices $V$ represent objects in memory and edges $E$ represent pointers between them. The set $R \\subseteq V$ constitutes the root set—objects directly accessible to the program (e.g., global variables or variables on the call stack).\n\nThe mark-and-sweep algorithm operates in two phases:\n1.  **Mark Phase**: All objects reachable from the root set $R$ are identified and marked as \"live\". This is a graph reachability problem. We can solve this using a traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS). The problem specifies an iterative depth-first traversal, which we will implement using an explicit stack. A vertex is processed at most once. When a vertex $u$ is processed, it is marked, and its outgoing edges are scanned to discover new, unmarked vertices.\n2.  **Sweep Phase**: The entire set of vertices (objects) $V$ is scanned linearly. Any vertex that was not marked during the mark phase is deemed \"garbage\" and is reclaimed.\n\nWe are given a precise cost model to quantify the work performed:\n- Marking a vertex costs $1$ unit.\n- Scanning an outgoing edge from a marked vertex costs $1$ unit.\n- Examining a vertex during the sweep phase costs $1$ unit.\n\nLet us formally analyze the total operation count, $T$. The quantities to compute are defined as follows:\n- $M$: The total number of marked vertices. This is the size of the set of vertices reachable from $R$, let's call this set $V_{\\text{mark}}$. So, $M = |V_{\\text{mark}}|$.\n- $S$: The total number of scanned edges. According to the model, we scan the adjacency list of a vertex when it is marked. Since each marked vertex is processed exactly once, all its outgoing edges are scanned once. Thus, $S$ is the sum of the out-degrees of all marked vertices: $S = \\sum_{v \\in V_{\\text{mark}}} \\deg^{+}(v)$.\n- $W$: The total number of sweep checks. The sweep phase linearly scans all vertices in the graph, so $W = |V| = n$.\n- $T$: The total operation count, defined as the sum $T = M + S + W$.\n- $B$: A boolean value, $1$ if $T \\leq 2n + m$ holds, and $0$ otherwise.\n- $Z_{\\text{vis}}$: The number of marked vertices with an out-degree of zero: $Z_{\\text{vis}} = |\\{ v \\in V_{\\text{mark}} \\mid \\deg^{+}(v) = 0 \\}|$.\n- $Z_{\\text{tot}}$: The total number of vertices in the graph with an out-degree of zero: $Z_{\\text{tot}} = |\\{ v \\in V \\mid \\deg^{+}(v) = 0 \\}|$.\n\nA key conceptual point is to explain the time complexity of the algorithm, which is $O(n+m)$. We can derive this directly from our cost analysis.\nThe number of marked vertices, $M$, cannot exceed the total number of vertices, $n$.\n$$M = |V_{\\text{mark}}| \\leq |V| = n$$\nThe number of scanned edges, $S$, is the sum of out-degrees of the marked vertices. This sum is necessarily less than or equal to the sum of out-degrees of all vertices in the graph, which by the handshaking lemma for directed graphs is exactly the total number of edges, $m$.\n$$S = \\sum_{v \\in V_{\\text{mark}}} \\deg^{+}(v) \\leq \\sum_{v \\in V} \\deg^{+}(v) = |E| = m$$\nThe sweep cost, $W$, is always equal to $n$.\n$$W = n$$\nNow, we can bound the total cost $T$:\n$$T = M + S + W \\leq n + m + n = 2n + m$$\nThis inequality, $T \\leq 2n + m$, demonstrates that the total number of operations is bounded by a linear function of the number of vertices $n$ and the number of edges $m$. This is the definition of a time complexity of $O(n+m)$. This result holds irrespective of the graph's structure, such as the number of vertices with zero out-degree. The presence of such vertices simply means that for them, $\\deg^{+}(v)=0$, which may reduce the value of $S$ but does not invalidate the upper bound. Our derivation also proves that the boolean indicator $B$ must always evaluate to $1$ under the specified cost model, as the inequality $T \\leq 2n + m$ is a provable property of the algorithm.\n\nThe implementation will proceed as follows:\nFor each test case, we construct an adjacency list representation of the graph $G$. We also compute the out-degree of each vertex and determine $Z_{\\text{tot}}$. The mark phase is implemented with an iterative DFS. An array `marked` of size $n$ keeps track of visited vertices, and a stack is used for the traversal. We initialize the stack with the vertices in the root set $R$. The algorithm proceeds by popping a vertex $u$, and if it's not yet marked, we mark it, increment $M$, add its out-degree to $S$, and check if its out-degree is zero to update $Z_{\\text{vis}}$. Then, we push all of its un-marked neighbors onto the stack. After the mark phase concludes, we calculate the remaining quantities $W$, $T$, and $B$ and store the results.",
            "answer": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_N 10\n#define MAX_M 10\n#define MAX_R 10\n\n// A struct to represent an edge in the graph\ntypedef struct {\n    int u;\n    int v;\n} Edge;\n\n// A struct to hold the parameters for a single test case\ntypedef struct {\n    const char* name;\n    int n;\n    int m;\n    int num_roots;\n    Edge edges[MAX_M];\n    int roots[MAX_R];\n} TestCase;\n\n// A struct for a node in an adjacency list\ntypedef struct AdjNode {\n    int vertex;\n    struct AdjNode* next;\n} AdjNode;\n\n// Function to add an edge to the adjacency list\nvoid add_edge(AdjNode** adj, int u, int v) {\n    AdjNode* newNode = (AdjNode*)malloc(sizeof(AdjNode));\n    if (!newNode) {\n        perror(\"Failed to allocate memory for AdjNode\");\n        exit(EXIT_FAILURE);\n    }\n    newNode->vertex = v;\n    newNode->next = adj[u];\n    adj[u] = newNode;\n}\n\n// Function to free the adjacency list\nvoid free_adj_list(AdjNode** adj, int n) {\n    for (int i = 0; i < n; ++i) {\n        AdjNode* current = adj[i];\n        while (current != NULL) {\n            AdjNode* temp = current;\n            current = current->next;\n            free(temp);\n        }\n    }\n}\n\nint main(void) {\n    // Define the test cases from the problem statement\n    TestCase test_cases[] = {\n        {'A', 8, 6, 2, {{0,1}, {0,2}, {1,3}, {2,3}, {2,6}, {4,5}}, {0, 4}},\n        {'B', 0, 0, 0, {}, {}},\n        {'C', 6, 0, 2, {}, {0, 3}},\n        {'D', 10, 5, 1, {{0,1}, {1,2}, {2,0}, {3,4}, {4,3}}, {0}}\n    };\n\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    long long results[num_cases][9];\n\n    for (int i = 0; i < num_cases; ++i) {\n        TestCase tc = test_cases[i];\n        int n = tc.n;\n        int m = tc.m;\n\n        if (n == 0) {\n            results[i][0] = 0; // n\n            results[i][1] = 0; // m\n            results[i][2] = 0; // M\n            results[i][3] = 0; // S\n            results[i][4] = 0; // W\n            results[i][5] = 0; // T\n            results[i][6] = 1; // B\n            results[i][7] = 0; // Z_vis\n            results[i][8] = 0; // Z_tot\n            continue;\n        }\n\n        AdjNode* adj[n];\n        int out_degree[n];\n        int marked[n];\n        int stack[n];\n        int top = -1;\n        \n        for (int j = 0; j < n; ++j) {\n            adj[j] = NULL;\n            out_degree[j] = 0;\n            marked[j] = 0; // 0 for not marked\n        }\n\n        // Build graph and calculate out-degrees\n        for (int j = 0; j < m; ++j) {\n            add_edge(adj, tc.edges[j].u, tc.edges[j].v);\n            out_degree[tc.edges[j].u]++;\n        }\n\n        // Calculate Z_tot\n        long long Z_tot = 0;\n        for (int j = 0; j < n; ++j) {\n            if (out_degree[j] == 0) {\n                Z_tot++;\n            }\n        }\n\n        // Mark Phase (Iterative DFS)\n        long long M = 0, S = 0, Z_vis = 0;\n\n        for (int j = 0; j < tc.num_roots; ++j) {\n            int root = tc.roots[j];\n            if (!marked[root]) {\n                if (top < n - 1) {\n                    stack[++top] = root;\n                }\n            }\n        }\n\n        while (top != -1) {\n            int u = stack[top--];\n            \n            if (marked[u]) {\n                continue;\n            }\n            \n            marked[u] = 1;\n            M++;\n            S += out_degree[u];\n            if (out_degree[u] == 0) {\n                Z_vis++;\n            }\n\n            AdjNode* current = adj[u];\n            while (current != NULL) {\n                int v = current->vertex;\n                if (!marked[v]) {\n                    if (top < n - 1) {\n                        stack[++top] = v;\n                    }\n                }\n                current = current->next;\n            }\n        }\n\n        // Sweep Phase Cost\n        long long W = n;\n\n        // Total Cost and Boolean check\n        long long T = M + S + W;\n        long long B = (T <= 2LL * n + m) ? 1 : 0;\n\n        // Store results\n        results[i][0] = n;\n        results[i][1] = m;\n        results[i][2] = M;\n        results[i][3] = S;\n        results[i][4] = W;\n        results[i][5] = T;\n        results[i][6] = B;\n        results[i][7] = Z_vis;\n        results[i][8] = Z_tot;\n\n        // Cleanup\n        free_adj_list(adj, n);\n    }\n\n    // Print the results in the EXACT REQUIRED format\n    printf(\"[\");\n    for (int i = 0; i < num_cases; ++i) {\n        printf(\"[%lld,%lld,%lld,%lld,%lld,%lld,%lld,%lld,%lld]\",\n               results[i][0], results[i][1], results[i][2], results[i][3],\n               results[i][4], results[i][5], results[i][6], results[i][7],\n               results[i][8]);\n        if (i < num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "While the basic traversal algorithm seems straightforward, a purely recursive implementation can fail in real-world scenarios with deep or wide object graphs, leading to stack overflow. This practice challenges you to implement a more robust mark phase that uses a fixed-size mark stack and an auxiliary overflow worklist on the heap. Your goal is to quantify the exact overhead, in terms of heap reads and writes, incurred by this essential overflow mechanism when faced with challenging graph structures .",
            "id": "3657156",
            "problem": "You are to implement the mark phase of a mark-and-sweep garbage collector with a bounded-capacity mark stack and an overflow worklist stored on the heap. The purpose is to reason from the foundational definition of reachability in directed graphs and the operational model of worklist-based graph traversal. You will quantify the additional memory operations due solely to spilling work from the bounded-capacity stack to a heap-resident overflow queue.\n\nDefinitions and operational model to use:\n- A heap object graph is a finite directed graph with vertices representing objects and directed edges representing pointers. A root set is a finite set of vertices considered initially reachable.\n- An object is reachable if there exists a directed path from any root to that object.\n- The mark phase discovers all reachable objects using a worklist. Use an explicit mark stack with capacity $s \\in \\mathbb{Z}_{>0}$ and an overflow worklist stored on the heap as a first-in-first-out queue.\n- Use the following precise traversal policy:\n  1. Use a \"mark-on-push\" policy: when you first discover an unmarked object $u$, set its mark bit immediately, and then schedule it for future processing by placing it into the worklist (either the bounded-capacity stack or, if the stack is full, the overflow queue).\n  2. Initialization: for each root $r$ in the given order, if it is unmarked then mark it and schedule it (attempt to push to the stack if there is space; otherwise, enqueue it to the overflow queue).\n  3. Main loop: while there exists scheduled work, do:\n     - If the stack is nonempty, pop one object $v$ from the stack and scan $v$’s outgoing edges in the given adjacency order. For each neighbor $u$, if $u$ is unmarked, then mark $u$ and schedule $u$ by pushing to the stack if the stack currently has fewer than $s$ elements; otherwise, enqueue $u$ to the overflow queue.\n     - If the stack is empty and the overflow queue is nonempty, dequeue one object from the overflow queue and push it onto the stack. This dequeue operation is considered a \"heap read\".\n- Count only the additional memory operations caused by the overflow mechanism:\n  - Each enqueue to the overflow queue counts as one \"heap write\".\n  - Each dequeue from the overflow queue counts as one \"heap read\".\n  - Do not count stack pushes or pops, nor reads of adjacency, nor reads/writes of mark bits. You must compute the total $w$, defined as the sum of all heap writes and heap reads performed due to overflow.\n\nImplementation constraints:\n- Graphs are provided as fixed adjacency lists; scan neighbors strictly in the given order.\n- The traversal must adhere to the exact policy above, with \"mark-on-push\" and draining the overflow queue only when the stack is empty.\n- The stack capacity $s$ is a positive integer $s \\geq 1$.\n\nTest suite:\nImplement your program to run the following four test cases, each consisting of a directed graph, a root set, and a stack capacity $s$.\n\n- Case A (wide star forcing overflow):\n  - Vertices are indexed by nonnegative integers.\n  - Adjacency:\n    - Node $0$ has outgoing edges to nodes $1,2,3,4,5,6,7,8,9,10$ in that order.\n    - Nodes $1,2,3,4,5,6,7,8,9,10$ have no outgoing edges.\n  - Root set: $\\{0\\}$.\n  - Stack capacity: $s = 3$.\n  - The expected behavior is that $7$ newly discovered children of node $0$ are spilled to the overflow queue because only $3$ can be pushed, yielding a computed $w$ to be determined by your program.\n\n- Case B (comb: a chain with side leaves, minimal stack):\n  - Vertices: nodes $0,1,2,3,4$ form a chain, and nodes $5,6,7,8,9$ are leaves.\n  - Adjacency:\n    - For $i \\in \\{0,1,2,3\\}$, node $i$ has outgoing edges in order to $i+1$ and $5+i$.\n    - Node $4$ has an outgoing edge to $9$.\n    - Nodes $5,6,7,8,9$ have no outgoing edges.\n  - Root set: $\\{0\\}$.\n  - Stack capacity: $s = 1$.\n\n- Case C (ample stack, no overflow expected):\n  - Vertices: nodes $0,1,2,3,4$.\n  - Adjacency:\n    - Node $0$ has outgoing edges to $1$ and $2$ in that order.\n    - Node $1$ has an outgoing edge to $3$.\n    - Node $2$ has an outgoing edge to $4$.\n    - Nodes $3$ and $4$ have no outgoing edges.\n  - Root set: $\\{0\\}$.\n  - Stack capacity: $s = 10$.\n\n- Case D (cycle with two extra leaves per cycle node, minimal stack, ensures overflow even in presence of cycles):\n  - Vertices: cycle nodes $0,1,2,3$ and leaves $4,5,6,7,8,9,10,11$.\n  - Adjacency, for each $i \\in \\{0,1,2,3\\}$ in this exact order:\n    - Node $i$ has outgoing edges to $(i+1) \\bmod 4$, then to $4 + 2i$, then to $4 + 2i + 1$.\n    - Leaves $4,5,6,7,8,9,10,11$ have no outgoing edges.\n  - Root set: $\\{0\\}$.\n  - Stack capacity: $s = 1$.\n\nYour program must execute all four cases internally and output a single line containing the four computed integers $w$ corresponding to Cases A, B, C, and D, in that order, aggregated as a comma-separated list enclosed in square brackets. For example, the output format must be exactly like $[w_A,w_B,w_C,w_D]$ with no spaces.\n\nThere are no physical units, and all angles are irrelevant. All outputs are integers. The program must be completely self-contained and require no input. Your implementation must adhere strictly to the traversal policy above so that the computation of $w$ is well-defined and reproducible across platforms.",
            "solution": "The user's request is to implement a specific variant of the mark-and-sweep garbage collection algorithm, counting the memory operations related to a stack overflow mechanism. The problem is scientifically grounded in compiler theory and graph traversal algorithms, is well-posed with a deterministic procedure, and is expressed with objective, formal definitions. Therefore, the problem is valid and a solution can be derived.\n\nThe solution requires a direct implementation of the traversal policy described. We will simulate the process for each of the four test cases provided. The core of the implementation is a graph traversal that uses a hybrid worklist: a primary, bounded-capacity stack and a secondary, unbounded FIFO queue on the heap for overflow.\n\nThe state of the simulation for each graph traversal is maintained using the following data structures:\n-   An integer array, `mark_bits`, indexed by object ID, where a value of $1$ indicates the object is marked and $0$ indicates it is unmarked. The total number of objects is denoted by $N$.\n-   An integer array, `stack`, of fixed capacity $s$, representing the mark stack. A stack pointer, `stack_ptr`, tracks the number of elements currently on the stack.\n-   An integer array, `overflow_queue`, representing the heap-resident FIFO queue. A head pointer, `q_head`, and a tail pointer, `q_tail`, manage the queue.\n-   An integer counter, $w$, initialized to $0$, to accumulate the total number of heap writes and heap reads.\n\nThe algorithm proceeds as follows:\n\n1.  **Initialization**:\n    -   The `mark_bits` array is initialized to all $0$s (unmarked).\n    -   The stack and queue are initialized to their empty states (e.g., `stack_ptr = 0`, `q_head = 0`, `q_tail = 0$).\n    -   The counter $w$ is set to $0$.\n    -   The root set is processed. For each root object $r$ in the specified order, if it is not marked:\n        -   The mark bit for $r$ is set to $1$.\n        -   The object $r$ is scheduled for processing. If the stack is not full (`stack_ptr < s`), $r$ is pushed onto the stack.\n        -   If the stack is full, $r$ is enqueued into the `overflow_queue`. This operation is a \"heap write\", so $w$ is incremented.\n\n2.  **Main Processing Loop**:\n    -   The loop continues as long as there is work to be done, which is true if either the stack is not empty (`stack_ptr > 0`) or the overflow queue is not empty (`q_head < q_tail`).\n\n3.  **Work Selection**:\n    -   **Case 1: Stack is not empty (`stack_ptr > 0`).**\n        -   An object $v$ is popped from the stack (`v = stack[--stack_ptr]`).\n        -   The neighbors of $v$ are scanned in the exact order given by the graph's adjacency list. For each neighbor $u$:\n            -   If $u$ is unmarked (`mark_bits[u] == 0`):\n                -   The mark bit for $u$ is set to $1$. This is the \"mark-on-push\" policy.\n                -   The object $u$ is scheduled. If the stack is not full (`stack_ptr < s`), $u$ is pushed onto the stack.\n                -   If the stack is full, $u$ is enqueued into the `overflow_queue`, and $w$ is incremented (heap write).\n    -   **Case 2: Stack is empty (`stack_ptr == 0`) but the overflow queue is not.**\n        -   An object $v$ is dequeued from the `overflow_queue` (`v = overflow_queue[q_head++]`). This operation is a \"heap read\", so $w$ is incremented.\n        -   The object $v$ is pushed onto the (now empty) stack (`stack[stack_ptr++] = v`). This refills the stack to ensure the depth-first nature of the main traversal can resume.\n\n4.  **Termination**:\n    -   When the main loop condition is no longer met (both stack and queue are empty), the traversal is complete. All reachable objects have been marked.\n    -   The final value of the counter $w$ represents the total number of heap operations due to overflow for that test case.\n\nThis exact procedure is implemented in the provided C program. Each of the four test cases is defined with its specific graph structure, root set, and stack capacity $s$. The program executes the simulation for each case, computes the corresponding value of $w$, and prints the results in the required format.",
            "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n// #include <complex.h>\n// #include <threads.h>\n// #include <stdatomic.h>\n\n#define MAX_NODES 16\n#define MAX_NEIGHBORS 16\n#define MAX_ROOTS 1\n#define MAX_STACK_CAPACITY 16\n\n// A struct to hold the parameters for a single test case.\ntypedef struct {\n    int num_nodes;\n    const int* const* adj;\n    const int* num_neighbors;\n    const int* roots;\n    int num_roots;\n    int stack_capacity;\n} TestCase;\n\n// Solves a single test case according to the specified algorithm.\nint solve_gc_trace(const TestCase* tc) {\n    int s = tc->stack_capacity;\n    int num_nodes = tc->num_nodes;\n    \n    // Data structures for the simulation\n    int mark_bits[MAX_NODES] = {0};\n    int stack[MAX_STACK_CAPACITY];\n    int overflow_queue[MAX_NODES];\n    \n    int stack_ptr = 0;\n    int q_head = 0;\n    int q_tail = 0;\n    int w = 0;\n\n    // 1. Initialization: Schedule roots\n    for (int i = 0; i < tc->num_roots; ++i) {\n        int root_node = tc->roots[i];\n        if (mark_bits[root_node] == 0) {\n            mark_bits[root_node] = 1; // Mark on schedule\n            if (stack_ptr < s) {\n                stack[stack_ptr++] = root_node;\n            } else {\n                overflow_queue[q_tail++] = root_node;\n                w++; // Heap write\n            }\n        }\n    }\n\n    // 2. Main loop\n    while (stack_ptr > 0 || q_head < q_tail) {\n        if (stack_ptr > 0) {\n            // Process from stack\n            int v = stack[--stack_ptr]; // Pop\n            int v_num_neighbors = tc->num_neighbors[v];\n            const int* v_neighbors = tc->adj[v];\n\n            for (int i = 0; i < v_num_neighbors; ++i) {\n                int u = v_neighbors[i];\n                if (mark_bits[u] == 0) {\n                    mark_bits[u] = 1; // Mark on schedule\n                    if (stack_ptr < s) {\n                        stack[stack_ptr++] = u; // Push\n                    } else {\n                        overflow_queue[q_tail++] = u; // Enqueue\n                        w++; // Heap write\n                    }\n                }\n            }\n        } else {\n            // Stack is empty, refill from overflow queue\n            int node_to_push = overflow_queue[q_head++]; // Dequeue\n            w++; // Heap read\n            stack[stack_ptr++] = node_to_push; // Push to stack\n        }\n    }\n\n    return w;\n}\n\nint main(void) {\n    // === Define Graph Data for Test Cases ===\n\n    // Case A Data\n    const int adj_A_0[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    const int* adj_A[] = {adj_A_0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};\n    const int num_neighbors_A[] = {10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const int roots_A[] = {0};\n\n    // Case B Data\n    const int adj_B_0[] = {1, 5};\n    const int adj_B_1[] = {2, 6};\n    const int adj_B_2[] = {3, 7};\n    const int adj_B_3[] = {4, 8};\n    const int adj_B_4[] = {9};\n    const int* adj_B[] = {adj_B_0, adj_B_1, adj_B_2, adj_B_3, adj_B_4, NULL, NULL, NULL, NULL, NULL};\n    const int num_neighbors_B[] = {2, 2, 2, 2, 1, 0, 0, 0, 0, 0};\n    const int roots_B[] = {0};\n\n    // Case C Data\n    const int adj_C_0[] = {1, 2};\n    const int adj_C_1[] = {3};\n    const int adj_C_2[] = {4};\n    const int* adj_C[] = {adj_C_0, adj_C_1, adj_C_2, NULL, NULL};\n    const int num_neighbors_C[] = {2, 1, 1, 0, 0};\n    const int roots_C[] = {0};\n\n    // Case D Data\n    const int adj_D_0[] = {1, 4, 5};\n    const int adj_D_1[] = {2, 6, 7};\n    const int adj_D_2[] = {3, 8, 9};\n    const int adj_D_3[] = {0, 10, 11};\n    const int* adj_D[] = {adj_D_0, adj_D_1, adj_D_2, adj_D_3, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};\n    const int num_neighbors_D[] = {3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0};\n    const int roots_D[] = {0};\n\n    // Define the test cases from the problem statement.\n    TestCase test_cases[] = {\n        {11, adj_A, num_neighbors_A, roots_A, 1, 3}, // Case A\n        {10, adj_B, num_neighbors_B, roots_B, 1, 1}, // Case B\n        {5,  adj_C, num_neighbors_C, roots_C, 1, 10},// Case C\n        {12, adj_D, num_neighbors_D, roots_D, 1, 1}  // Case D\n    };\n\n    // Calculate the number of test cases.\n    int num_cases = sizeof(test_cases) / sizeof(test_cases[0]);\n    int results[num_cases];\n\n    // Calculate the result for each test case.\n    for (int i = 0; i < num_cases; ++i) {\n        results[i] = solve_gc_trace(&test_cases[i]);\n    }\n\n    // Print the results in the EXACT REQUIRED format before the final return statement\n    printf(\"[%d,%d,%d,%d]\", results[0], results[1], results[2], results[3]);\n\n    return EXIT_SUCCESS;\n}\n```"
        },
        {
            "introduction": "After implementing the mechanics of traversal, it's crucial to solidify your conceptual understanding of reachability. This exercise presents a hypothetical scenario: a heap containing only a cycle of objects with no external pointers from the root set. Your task is to reason from first principles, without writing code, to determine the fate of these objects and calculate the total collection time based on a formal cost model, thereby clarifying the distinct and separate roles of the mark and sweep phases .",
            "id": "3657165",
            "problem": "You are given a managed runtime that uses a stop-the-world mark-and-sweep Garbage Collector (GC). The heap at the moment of collection contains exactly $n$ identical objects, each with exactly $1$ outgoing pointer that forms a single directed cycle over all $n$ objects. There is no pointer from any root in the root set to any of these $n$ objects. Assume the following foundational definitions and facts:\n- The heap can be modeled as a directed graph whose vertices are heap objects and whose edges are object-to-object pointers.\n- The root set is a distinguished set of references held outside the heap (for example, in registers, stacks, and statics). The set of reachable objects is defined as the least set containing the root set and closed under the outgoing edges of heap objects.\n- The mark phase of a mark-and-sweep GC visits and marks exactly those heap objects that are reachable from the root set by following object pointers.\n- The sweep phase linearly scans all heap objects and reclaims those that are unmarked.\n\nFor the purpose of this problem, adopt a uniform cost model:\n- Scanning the root set costs a constant $c_{r}$ time, independent of $n$.\n- Each discovered heap object during the mark phase costs $c_{m}$ time for mark bookkeeping.\n- Each pointer traversal during the mark phase costs $c_{p}$ time.\n- Each heap object examined in the sweep phase costs $c_{s}$ time.\n\nAssume there is no incremental or generational optimization: a full-heap mark-and-sweep is performed. Using only the above definitions and facts, first reason whether the $n$-object cycle will be reclaimed in a single collection, and then derive a closed-form expression for the total time to realize that the heap contains no reachable objects, denoted $T(n)$, as a function of $n$, $c_{r}$, $c_{m}$, $c_{p}$, and $c_{s}$. Provide your final answer as a single analytic expression for $T(n)$. No rounding is required.",
            "solution": "The problem statement is analyzed for validity.\n\n### Step 1: Extract Givens\n- **Garbage Collector (GC)**: Stop-the-world mark-and-sweep.\n- **Heap State**: Exactly $n$ identical objects forming a single directed cycle of length $n$. Each object has exactly $1$ outgoing pointer.\n- **Root Set Connectivity**: No pointer from the root set to any of the $n$ objects.\n- **Definitions**:\n    - Heap is a directed graph (vertices are objects, edges are pointers).\n    - Reachable objects are the least set containing the root set and closed under pointer traversal.\n    - Mark phase marks all reachable objects.\n    - Sweep phase linearly scans all heap objects and reclaims unmarked ones.\n- **Cost Model**:\n    - $c_{r}$: Time to scan the root set (constant).\n    - $c_{m}$: Time for mark bookkeeping per discovered heap object.\n    - $c_{p}$: Time for each pointer traversal during the mark phase.\n    - $c_{s}$: Time to examine each heap object during the sweep phase.\n- **Assumptions**: Full-heap collection, no incremental or generational optimizations.\n- **Task**: First, determine if the $n$-object cycle is reclaimed. Second, derive a closed-form expression for the total time $T(n)$ for the collection process as a function of $n$, $c_{r}$, $c_{m}$, $c_{p}$, and $c_{s}$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the principles of compiler design and runtime systems, specifically garbage collection algorithms. The model of the heap, reachability, and the mark-and-sweep process are standard formalisms. The cost model is a valid simplification for algorithmic analysis. The problem is well-posed, providing all necessary definitions and constraints to arrive at a unique, logical solution. The terminology is precise and objective. All components are self-contained and consistent.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\nThe problem requires two parts: reasoning about the reclamation of the object cycle and deriving the total time for the garbage collection process.\n\n**Part 1: Reclamation of the Object Cycle**\n\nThe reclamation of objects depends on the outcome of the mark phase. The mark phase identifies all objects that are *reachable* from the root set. The problem defines the set of reachable objects as \"the least set containing the root set and closed under the outgoing edges of heap objects.\" This is equivalent to finding all nodes in the heap graph that are reachable via a path starting from any member of the root set.\n\nThe problem statement explicitly provides the crucial condition: \"There is no pointer from any root in the root set to any of these $n$ objects.\" This means there is no path from the root set to any of the $n$ objects that constitute the cycle. Consequently, the graph traversal algorithm of the mark phase, which begins at the root set, will terminate without ever visiting any of the $n$ heap objects.\n\nAccording to the definition, the mark phase \"marks exactly those heap objects that are reachable from the root set.\" Since none of the $n$ objects are reachable, zero objects will be marked. The set of marked objects is empty.\n\nThe sweep phase then \"linearly scans all heap objects and reclaims those that are unmarked.\" Since all $n$ objects on the heap are unmarked, the sweep phase will identify and reclaim every one of them.\n\nTherefore, the $n$-object cycle will be entirely reclaimed in a single collection cycle.\n\n**Part 2: Derivation of the Total Time $T(n)$**\n\nThe total time for the garbage collection cycle, $T(n)$, is the sum of the time taken for the mark phase, $T_{\\text{mark}}(n)$, and the time taken for the sweep phase, $T_{\\text{sweep}}(n)$.\n\n$$T(n) = T_{\\text{mark}}(n) + T_{\\text{sweep}}(n)$$\n\nLet us analyze the cost of each phase based on the provided uniform cost model.\n\n**Mark Phase Time, $T_{\\text{mark}}(n)$:**\nThe mark phase begins by scanning the root set to find the initial set of references to the heap.\n1.  **Scanning the root set**: The cost for this operation is given as a constant, $c_{r}$.\n2.  **Marking heap objects**: The cost for marking each discovered object is $c_{m}$. As established above, zero heap objects are reachable from the root set. Therefore, the number of discovered and marked objects is $0$. The total cost contribution from this activity is $0 \\times c_{m} = 0$.\n3.  **Traversing pointers**: The cost for each pointer traversal is $c_{p}$. Since no heap objects are ever visited during the mark phase, no outgoing pointers from heap objects are traversed. The number of pointer traversals is $0$. The total cost contribution from this activity is $0 \\times c_{p} = 0$.\n\nSumming the costs for the mark phase, we get:\n$$T_{\\text{mark}}(n) = c_{r} + 0 + 0 = c_{r}$$\nThe time for the mark phase is constant and independent of $n$ in this specific scenario.\n\n**Sweep Phase Time, $T_{\\text{sweep}}(n)$:**\nThe definition of the sweep phase states that it \"linearly scans all heap objects.\"\n1.  **Scanning heap objects**: There are exactly $n$ objects on the heap. The sweep phase must examine each one to check its mark bit.\n2.  **Cost per object**: The cost to examine each heap object is given as $c_{s}$.\n\nThe total time for the sweep phase is the number of objects multiplied by the per-object cost:\n$$T_{\\text{sweep}}(n) = n \\cdot c_{s}$$\n\n**Total Time, $T(n)$:**\nCombining the costs for both phases gives the total time for the garbage collection cycle.\n$$T(n) = T_{\\text{mark}}(n) + T_{\\text{sweep}}(n) = c_{r} + n c_{s}$$\n\nThis expression represents the total time to perform a full mark-and-sweep collection on the given heap configuration. The term \"total time to realize that the heap contains no reachable objects\" is interpreted as the time for the entire collection process that performs this discovery and acts upon it by reclaiming the memory, as this interpretation is the only one consistent with the notation $T(n)$ and the provided cost components. The cost components $c_{m}$ and $c_{p}$ do not appear in the final expression because the activities they correspond to do not occur under the problem's specific conditions.",
            "answer": "$$\\boxed{c_{r} + n c_{s}}$$"
        }
    ]
}