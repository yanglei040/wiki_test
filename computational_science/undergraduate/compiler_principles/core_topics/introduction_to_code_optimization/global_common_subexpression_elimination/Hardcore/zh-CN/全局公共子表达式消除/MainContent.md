## 引言
在追求软件性能的道路上，消除不必要的计算是[编译器优化](@entry_id:747548)工程师永恒的目标。当我们的程序在不同位置反复执行相同的计算时，便产生了性能上的浪费。全局[公共子表达式消除](@entry_id:747511) (Global Common Subexpression Elimination, GCSE) 正是解决此类冗余问题的强大武器，它通过在整个函数范围内识别并消除重复计算，从而显著提升程序的执行效率。然而，要安全且有效地实现这一目标，远比听起来要复杂，它要求编译器对程序的控制流和[数据流](@entry_id:748201)有深刻的洞察。

本文旨在系统性地揭示全局[公共子表达式消除](@entry_id:747511)的奥秘。我们将不仅仅停留在表面概念，而是深入其核心，解决“编译器如何确信一个远处的计算结果在此处依然有效？”以及“在复杂的程序结构中，如何系统性地发现这些优化机会？”等关键问题。

为了构建一个完整的知识体系，本文将分为三个核心部分：
*   在 **第一章：原理和机制** 中，我们将奠定理论基础，详细阐述实现GCSE所必须满足的可用性、支配性等条件，并深入剖析[全局值编号](@entry_id:749934) (GVN) 和[静态单赋值](@entry_id:755378) (SSA) 等核心实现技术。
*   在 **第二章：应用与跨学科关联** 中，我们将视野拓宽，探讨GCSE如何在更广阔的[编译器优化](@entry_id:747548)生态中与其他技术协同工作，并展示其思想如何在计算机图形学、数据库系统和[并发编程](@entry_id:637538)等不同领域中发挥作用。
*   最后，在 **第三章：动手实践** 中，你将有机会通过具体问题，亲手实践规范化、控制流改造和[内存别名](@entry_id:174277)分析等关键概念，从而将理论知识转化为解决实际问题的能力。

通过本次学习，你将对这一经典的[编译器优化](@entry_id:747548)技术建立起全面而深刻的理解，并能从更专业的角度审视代码中的性能瓶颈。

## 原理和机制

在[编译器优化](@entry_id:747548)的领域中，消除程序中的冗余计算是一项核心任务。如果一个程序在不同的地方多次计算相同的值，那么通过只计算一次并复用结果，我们可以提升程序的执行效率。当这种优化跨越了单个基本块的边界，在整个函数或过程的[控制流图](@entry_id:747825)中寻找机会时，我们就称之为**全局[公共子表达式消除](@entry_id:747511)** (Global Common Subexpression Elimination, GCSE)。本章将深入探讨实现安全有效的全局[公共子表达式消除](@entry_id:747511)所依赖的核心原理和关键机制。

### 冗余与复用的核心思想

[公共子表达式消除](@entry_id:747511)的基本思想非常直观：如果一个表达式已经被计算过，并且其所有操作数的值从上次计算至今没有发生任何变化，那么再次计算该表达式就是多余的。这个重复出现的表达式被称为**[公共子表达式](@entry_id:747510)**。

在最简单的形式中，**局部[公共子表达式消除](@entry_id:747511)** (Local CSE) 在单个基本块内部进行操作。例如，考虑以下代码序列：

```
x = a * b;
... // 不改变 a 或 b 的指令
y = a * b;
```

一个局部 CSE 分析可以轻易地发现第二个 `a * b` 是冗余的，并将其替换为 `y = x`。然而，局部 CSE 的视野有限。当冗余计算[分布](@entry_id:182848)在不同的基本块时，它就[无能](@entry_id:201612)为力了。例如，在  的一个场景中，`a * b` 可能在一个 `if` 分支中计算，然后在另一个 `else` 分支中再次计算。这种跨越块边界的冗余是全局 CSE 的目标。要实现这一目标，我们需要一个更强大的理论框架。

### 全局消除的基本要求：可用性、支配性和纯粹性

为了安全地在全局范围内消除一个表达式的重新计算，并用先前计算过的值来代替，必须满足三个基本条件：值的**可用性** (availability)，定义的**支配性** (dominance)，以及表达式的**纯粹性** (purity)。

#### [可用表达式分析](@entry_id:746601)

一个表达式 $e$ 在程序的某个点 $p$ 是**可用的** (available)，意味着从程序入口到点 $p$ 的**每一条**控制流路径上，$e$ 都已经被计算过，并且自最后一次计算以来，$e$ 的任何操作数都没有被重新定义。这是 GCSE 的基石，因为它保证了我们想要复用的那个“旧值”在当前点是有效且正确的。

这个条件的严格性在于“每一条路径”的要求。如果只在某些路径上表达式是可用的，而在其他路径上不是，那么在该点它就不是一个可用的表达式。

更重要的是，“操作数没有被重新定义”这一条件。任何可能改变表达式值的写操作都会**杀死** (kill) 该表达式的可用性。对于持有标量变量的表达式，例如 $a+b$，任何对 $a$ 或 $b$ 的赋值都会杀死这个表达式。然而，在处理指针和间接内存访问时，情况变得复杂得多，这引出了**[别名](@entry_id:146322)分析** (alias analysis) 的重要性。

考虑  中提出的一个场景：程序首先计算 `strlen(s)`，然后在一个分支中，执行了一个写操作 `t[0] = '\0'`。如果别名分析表明指针 `t` **可能**与 `s` 指向同一内存区域（即 `MayAlias(s, t)` 为真），那么编译器必须做出保守的假设。这个写操作可能会修改字符串 `s` 的内容，从而改变其长度。因此，这个写操作杀死了 `strlen(s)` 表达式的可用性。即使在另一个分支中执行的写操作 `t[0] = 'X'` 看起来不会引入空字符，但它仍然可能改变一个空字符串的长度，因此同样会杀死表达式的可用性。在这种情况下，由于 `strlen(s)` 的值在两条路径上都可能被改变，它在后续的汇合点不再是可用的，编译器也就不能安全地消除对 `strlen(s)` 的第二次调用。

#### 支配性

支配性是另一个源于[静态单赋值形式](@entry_id:755286) (SSA) 的关键概念。在一个[控制流图](@entry_id:747825)中，如果从入口节点到节点 $N$ 的每一条路径都必须经过节点 $D$，则称节点 $D$ **支配** (dominates) 节点 $N$。当我们将一个冗余计算替换为一个持有先前结果的变量时，该变量的定义点必须支配当前的使用点。这保证了无论程序沿着哪条路径执行到使用点，该变量都已经被明确地赋值。

#### 表达式的纯粹性

最后，我们只能消除**纯函数** (pure functions) 或纯粹的操作。一个纯表达式的求值除了计算出一个结果外，不产生任何其他可观测的副作用，比如修改全局变量、执行 I/O 操作或抛出异常。它的返回值也只依赖于其输入参数。

 中的例子清晰地说明了这一点。假设我们有表达式 `g(h(x))`，其中 `h` 是纯函数，但 `g` 是不纯的——它每次被调用时都会记录日志并与一个全局变量 `G` 交互。在这种情况下，我们可以安全地消除 `h(x)` 的冗余计算，因为计算它多少次、在何处计算，都不会影响程序的行为。然而，我们**不能**消除对 `g` 的调用。即使 `g` 的输入相同，其副作用（如记录日志）是程序可观测行为的一部分。在不同的分支中调用 `g`，其读取到的全局变量 `G` 的值可能不同，导致其返回值和日志内容也不同。消除其中一个调用或移动它的位置都会改变程序的语义。只有当 `g` 和 `h` 都是纯函数时，我们才能安全地对整个表达式 `g(h(x))` 进行[全局优化](@entry_id:634460)。

### 机制一：在[控制流](@entry_id:273851)汇合点合并计算

一个典型的 GCSE 场景出现在 `if-then-else` 结构（即“钻石”形[控制流](@entry_id:273851)）之后。如果同一个表达式在 `then` 分支和 `else` 分支中都被计算了，我们就有机会在它们共同的后续节点（[汇合](@entry_id:148680)点）进行优化。

考虑  和  中的例子。在这两个场景中，一个表达式（分别是 `a + b` 和 `hashKey(k)`）在钻石结构的两条分支中都被计算，并且其结果仅在汇合点或之后被使用。在这种情况下，一个有效的优化策略不是将计算**提升** (hoisting) 到 `if` 语句之前，而是将其**下沉** (sinking) 到[汇合](@entry_id:148680)点。

这种变换的正确性依赖于以下条件：
1.  表达式在通往[汇合](@entry_id:148680)点的所有路径上都被计算。
2.  从计算点到[汇合](@entry_id:148680)点，表达式的操作数没有被修改。
3.  在各个分支中，表达式的计算结果在到达汇合点之前没有被使用。换言之，汇合点支配了表达式值的所有用途。
4.  该操作是纯粹的，移动它不会引入新的行为。

满足这些条件时，我们可以删除两个分支中的计算，而在[汇合](@entry_id:148680)点插入一次计算。 指出，与提升相比，下沉通常是更优的策略，因为它能最小化临时变量的**[活跃范围](@entry_id:751371)** (live range)，从而减轻[寄存器分配](@entry_id:754199)的压力。从理论上讲，安全地向下移动代码要求目标块**后置支配** (post-dominate) 所有源块——即从源块到程序出口的每一条路径都必须经过目标块。钻石结构的汇合点正是满足此条件的典型例子。

### 超越语法一致性：[全局值编号](@entry_id:749934) (GVN)

传统的 GCSE 算法依赖于表达式的**语法一致性** (syntactic equality)。它只能识别那些文本上完全相同的表达式。然而，很多情况下，不同写法的表达式在语义上是等价的。例如，对于无符号整数，`x * 4` 和 `x  2` 会产生完全相同的结果。一个只看语法的 GCSE 无法发现这种冗余 。

为了克服这一限制，编译器采用了一种更强大的技术：**[全局值编号](@entry_id:749934)** (Global Value Numbering, GVN)。GVN 的核心思想是为程序中计算出的每一个唯一的值分配一个唯一的“[值编号](@entry_id:756409)”。当遇到一个新表达式时，编译器会计算它的[值编号](@entry_id:756409)；如果该编号已经存在，就意味着这个表达式是冗余的。

GVN 的威力取决于它如何确定值的等价性：
-   **结构等价性** (Structural Equivalence): 这是最简单的形式，类似于语法匹配。
-   **代数等价性** (Algebraic Equivalence): 一个更强大的 GVN可以利用代数恒等式。例如，如果加法是满足[结合律](@entry_id:151180)和[交换律](@entry_id:141214)的，GVN 可以将表达式 `(x + y) + z`，`x + (y + z)` 和 `(z + x) + y` 视为等价的 。它通过将表达式规范化（例如，将操作数排序）来实现这一点，从而为这些语法不同但语义相同的表达式分配相同的[值编号](@entry_id:756409) 。

### 发挥 SSA 的全部威力

当 GVN 与[静态单赋值](@entry_id:755378) (SSA) 形式相结合时，其威力会得到极大的增强。SSA 形式通过 `φ` 函数在[控制流](@entry_id:273851)的汇合点显式地合并来自不同路径的值。这为 GVN 提供了一个强大的推理工具。

一个关键的规则是：**如果一个 `φ` 函数的所有输入参数都具有相同的[值编号](@entry_id:756409) $v$，那么 `φ` 函数的输出结果也将获得[值编号](@entry_id:756409) $v$**。

让我们通过  中的例子来理解这一点。假设 `if` 分支计算 `t1 = a * b`，`else` 分支计算 `t2 = a * b`。在汇合点，SSA 形式会引入 `t3 = φ(t1, t2)`。GVN 分析如下：
1.  在 `if` 分支，为 `a * b` 分配[值编号](@entry_id:756409)，比如 $v_{10}$。因此 `VN(t1)` = $v_{10}$。
2.  在 `else` 分支，`a * b` 得到相同的[值编号](@entry_id:756409) $v_{10}$。因此 `VN(t2)` = $v_{10}$。
3.  在[汇合](@entry_id:148680)点，GVN 发现 `φ(t1, t2)` 的两个参数 `t1` 和 `t2` 具有相同的[值编号](@entry_id:756409) $v_{10}$。根据 `φ` 规则，`VN(t3)` 也被设为 $v_{10}$。
4.  现在，如果在[汇合](@entry_id:148680)块中有一个后续计算 `t4 = a * b`，GVN 会发现这个表达式的[值编号](@entry_id:756409)也是 $v_{10}$，并且已经有一个由 `t3` 持有的、支配当前点的可用值。因此，`t4 = a * b` 是冗余的，可以被替换为 `t4 = t3`。

这种基于 `φ` 函数的推理能力，使得 SSA-based GVN 能够系统地、优雅地发现并消除跨越控制流的冗余。

此外，SSA 还使得表达**值[同余](@entry_id:143700)** (value congruence) 成为可能。例如，对于纯粹的操作符 `+`，表达式 `φ(a1, a2) + φ(b1, b2)` 在语义上等同于 `φ(a1 + b1, a2 + b2)` 。这种 `φ` 函数和纯操作之间的“分配”性质是许多高级 SSA 优化的基础。

### 推广 CSE：[部分冗余消除](@entry_id:753187) (PRE)

GCSE 处理的是**完全冗余** (fully redundant) 的表达式——即在所有通往某点的路径上都可用的表达式。但是，如果一个表达式只在**部分**路径上是冗余的呢？这就是**[部分冗余消除](@entry_id:753187)** (Partial Redundancy Elimination, PRE) 要解决的问题。

PRE 可以被看作是 GCSE 和[循环不变代码外提](@entry_id:751465)的统一框架。它的目标是通过在某些路径上插入计算，将部分冗余转换成完全冗余，从而实现消除。

[@problem_id:f4044027] 提供了一个清晰的例子：表达式 `a + b` 在一条通往[汇合](@entry_id:148680)点的路径上被计算了，但在另一条上没有，然后在[汇合](@entry_id:148680)点本身被再次计算。这里的第二次计算就是部分冗余的。PRE 的策略是：
1.  识别出那条“缺失”表达式的路径。
2.  在该路径上（通常是在分支块的末尾）插入对 `a + b` 的计算。
3.  现在，`a + b` 在通往汇合点的所有路径上都变得可用了。
4.  因此，[汇合](@entry_id:148680)点的计算 `a + b` 成为了完全冗余，可以安全地消除，并替换为一个 `φ` 函数来合并来自不同路径的结果。

### 一个重要的警示：推测性执行的风险

到目前为止，我们讨论的所有变换都假设表达式的计算是**安全**的。然而，某些操作在特定条件下可能会导致程序崩溃。最经典的例子就是除零。

考虑  中的场景，原始代码经过精心设计，只有在确定除数 `b` 不为零时才执行 `a / b`。一个天真的 GCSE 算法可能会注意到 `a / b` 在多个地方出现，并试图将其提升到一个支配所有使用点的公共祖先块中。

这个看似合理的[代码移动](@entry_id:747440)是极其危险的。如果被移动的计算被放置在一个程序原来会跳过它的路径上，这种行为被称为**推测性执行** (speculative execution)。如果原始程序中 `b` 为零的路径可以到达这个新的计算点，那么变换后的程序就会在一条原本安全的路径上触发一个除零异常。这引入了原始程序中不存在的、可观测的错误行为，严重违反了语义保持原则。

因此，对于可能产生异常或具有其他副作用的操作，[代码移动](@entry_id:747440)必须非常谨慎。编译器必须能够证明，被移动的指令在其新的位置上不会执行任何在原始程序中不会发生的可观察行为。如果无法证明这一点（例如，无法证明除数一定不为零），那么就不能进行推测性执行，或者必须用 guarding code 来保护它。这是确保优化正确性的最后一道，也是至关重要的一道防线。