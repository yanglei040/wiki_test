{
    "hands_on_practices": [
        {
            "introduction": "循环展开是一项基本的优化技术，它通过增加代码体积来换取更少的循环开销和更好的指令调度机会。第一个练习将挑战你将这种权衡形式化。通过构建一个简单的执行时间成本模型，你将学会如何定量地分析一项优化的有效性，并在给定的代码大小硬性约束下，确定最佳策略。",
            "id": "3628478",
            "problem": "考虑一个在归纳变量 $i$ 上、步长为 $s$、精确执行 $N$ 次迭代的简单计数循环。循环体在每次迭代中执行计算，并以地址步长 $s$ 访问内存。假设在单核中央处理器（CPU）上采用以下成本模型，以周期为单位：\n- 循环体的数据处理部分（不包括循环控制和停顿）每次原始迭代的成本为 $b$ 个周期。\n- 如果不进行展开，循环控制（$i$ 增加 $s$、与边界比较、以及分支）每次原始迭代的成本为 $h$ 个周期。\n- 当迭代严格串行执行时，内存延迟和流水线冒险会带来每次原始迭代 $d(s)$ 个周期的额外停顿成本。假设迭代是独立的，因此当循环体被展开并交错执行 $u$ 个副本时，这些停顿可以在 $u$ 个副本之间完全重叠（即，迭代间的重叠可以分摊延迟）。\n- 按因子 $u$ 进行展开，会将循环体复制 $u$ 次，按比例减少循环控制的执行次数，并保持每次原始迭代的数据处理工作量 $b$ 不变。\n\n设单个循环体副本的代码大小为 $S$ 字节，并假设存在一个 $M$ 字节的硬性预算，使得生成的循环必须满足 $u\\cdot S \\leq M$。假设 $M \\geq S$ 以确保至少未展开的循环体能够容纳，并且 $u$ 必须是不超过 $N$ 的正整数。\n\n仅使用以下基本定义：总执行时间（周期数）是动态工作量与单位成本的乘积；循环展开将动态循环控制的执行次数减少一个因子 $u$；完全可重叠的停顿可以在独立工作之间均匀分摊。请推导出执行时间 $T(u)$（周期数）作为 $u$ 的函数，然后确定在满足 $u \\cdot S \\leq M$ 和 $1 \\leq u \\leq N$ 的约束条件下，能使 $T(u)$ 最小化的整数展开因子 $u^{\\star}$。请将您的最终答案表示为关于 $M$、$S$ 和 $N$ 的单一封闭形式符号表达式。",
            "solution": "总执行时间 $T(u)$ 是其组成部分成本的总和：数据处理、循环控制和停顿。我们推导在 $N$ 次原始迭代中，每个部分的总成本作为展开因子 $u$ 的函数。\n\n1.  **数据处理成本 ($C_{proc}$)**：问题陈述指出，数据处理工作每次原始迭代的成本为 $b$ 个周期，并且不受展开影响。因此，总数据处理成本是恒定的。\n    $$C_{proc} = N \\cdot b$$\n\n2.  **循环控制成本 ($C_{ctrl}$)**：对于未展开的循环，控制开销会发生 $N$ 次。当循环按因子 $u$ 展开时，循环体被复制 $u$ 次，新循环运行 $\\frac{N}{u}$ 次迭代。成本为 $h$ 个周期的循环控制逻辑（增量、比较、分支）在新循环的每次迭代中执行一次。因此，总循环控制成本为：\n    $$C_{ctrl}(u) = \\frac{N}{u} \\cdot h$$\n\n3.  **停顿成本 ($C_{stall}$)**：在串行情况下，每次迭代产生 $d(s)$ 个周期的停顿。当 $u$ 次迭代被展开时，停顿是“完全可重叠的”。这意味着对于每块包含 $u$ 次原始迭代的执行，总停顿成本是 $d(s)$，而不是 $u \\cdot d(s)$。由于总共有 $\\frac{N}{u}$ 个这样的块，所以总停顿成本是：\n    $$C_{stall}(u) = \\frac{N}{u} \\cdot d(s)$$\n\n总执行时间 $T(u)$ 是这些组成部分之和。\n$$T(u) = C_{proc} + C_{ctrl}(u) + C_{stall}(u) = N \\cdot b + \\frac{N}{u} \\cdot h + \\frac{N}{u} \\cdot d(s)$$\n我们可以对该表达式进行因式分解，以分离出依赖于 $u$ 的项：\n$$T(u) = N \\left( b + \\frac{h + d(s)}{u} \\right)$$\n\n接下来，我们必须找到在给定约束条件下最小化 $T(u)$ 的整数展开因子 $u^{\\star}$。\n$u$ 的约束条件是：\n- $u$ 必须是正整数：$u \\in \\{1, 2, 3, \\dots\\}$。\n- 展开后循环体的代码大小不得超过预算 $M$：$u \\cdot S \\leq M$。由于 $u$ 必须是整数，这等价于 $u \\leq \\left\\lfloor \\frac{M}{S} \\right\\rfloor$。\n- 展开因子不能大于迭代次数：$u \\leq N$。\n\n综合这些约束，$u$ 的可行整数值集合由 $1 \\leq u \\leq \\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)$ 给出。问题陈述 $M \\geq S$，这确保了 $\\left\\lfloor \\frac{M}{S} \\right\\rfloor \\geq 1$，因此这个范围永远不为空。\n\n为了最小化 $T(u) = N \\left( b + \\frac{h + d(s)}{u} \\right)$，我们分析它对 $u$ 的依赖性。对于给定的循环，参数 $N$、$b$、$h$ 和 $d(s)$ 都是非负常数。我们假设 $h + d(s)  0$，否则 $T(u)$ 将与 $u$ 无关，优化将变得无意义。在 $h + d(s)  0$ 的情况下，对于 $u  0$，项 $\\frac{h+d(s)}{u}$ 是 $u$ 的严格递减函数。因此，$T(u)$ 的整个表达式也是 $u$ 的严格递减函数。\n\n要在整数的闭区间上最小化一个严格递减函数，必须选择该区间内的最大整数值。$u$ 的最大允许整数值是可行集的上界。\n$$u_{max} = \\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)$$\n因此，最优展开因子 $u^{\\star}$ 就是这个最大允许值。\n$$u^{\\star} = \\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)$$\n该表达式给出了在给定模型和约束条件下，使执行时间最小化的整数展开因子。",
            "answer": "$$\\boxed{\\min\\left(N, \\left\\lfloor \\frac{M}{S} \\right\\rfloor\\right)}$$"
        },
        {
            "introduction": "一项在孤立环境中看似正确的优化，在更广阔的分析范围下可能变得极其危险。本问题探讨了一个关键场景：一个标准的单线程优化——将边界检查提出循环——在并发环境中如何引发灾as性的失败。这个练习将提升你对内存模型和为保证程序语义及内存安全而定义正确分析范围的重要性的认识。",
            "id": "3628541",
            "problem": "考虑一个采用简单命令式语言编写的共享内存程序，该程序有两个线程，一个容量为 $N$ 的共享数组 $A$，以及一个表示 $A$ 当前逻辑长度的共享整数 $n$，满足 $0 \\leq n \\leq N$。内存模型是顺序一致性 (Sequential Consistency, SC)，意味着所有线程的所有操作可以看作是交错在一个单一的总序列中，该序列尊重每个线程的程序顺序。编译器必须在此 SC 模型下保留可观察行为，其中可观察行为包括内存安全（无越界访问）、读写共享位置的值以及依赖于共享数据的控制流决策。\n\n线程 $T_1$ 执行一个循环，聚合 $A$ 的元素，每次迭代都使用 $n$ 的当前值进行边界检查：\n- 对于从 $0$ 开始、每次加 $1$、直到并包括 $N-1$ 的每个整数 $i$，循环体读取 $n$ 并执行：如果 $i  n$，则读取 $A[i]$ 并将其加到一个局部累加器 $s$ 中。累加是局部计算，不写入共享内存。形式上，在第 $i$ 次迭代中，$T_1$ 使用在该次迭代中读取的 $n$ 的值来评估谓词 $i  n$，并且当且仅当该谓词为真时才访问 $A[i]$。\n\n线程 $T_2$ 可以在 $T_1$ 执行期间并发地减小 $n$ 的值，以反映逻辑数组的缩小。此外，当 $T_2$ 将 $n$ 减小到某个值 $n'$ 时，它可能会立即重用或使所有满足 $n' \\leq j \\leq N-1$ 的整数 $j$ 的位置 $A[j]$ 失效（例如，通过将这些位置转移到另一个池或将其标记为不可访问）。假设对 $n$ 和 $A[\\cdot]$ 的所有读写在 SC 意义上都是原子的，但没有同步来建立 $T_1$ 和 $T_2$ 之间的“先于发生”（happens-before）关系。\n\n一个编译器考虑对 $T_1$ 进行以下优化：它不在每次迭代中读取 $n$ 并检查 $i  n$，而是在循环前获取 $n$ 的单个快照 $n_0$，并将受保护的循环替换为一个无保护的循环，该循环使 $i$ 从 $0$ 运行到 $n_0 - 1$，并在每次迭代中访问 $A[i]$。换句话说，它将每次迭代的检查 $i  n$ 转换为一个固定的边界 $n_0$，并假设 $n$ 在循环期间是不变的。\n\n基于以上场景和 SC 模型，关于此优化正确性的以下陈述中，哪些是正确的？\n\nA. 在顺序一致性下，如果 $T_2$ 可以在 $T_1$ 的循环期间减小 $n$ 并在减小操作的瞬间立即使 $j \\geq n$ 的 $A[j]$ 失效，那么将每次迭代的检查 $i  n$ 替换为单个循环前快照 $n_0$ 的做法不是语义保持的，因为优化后的循环可能访问索引 $i$ 对应的 $A[i]$，而访问时 $i \\geq n$，这违反了内存安全。\n\nB. 仅将 $n$ 声明为原子变量就足以使该优化合理，因为原子性保证了并发写入的可见性，因此单个快照 $n_0$ 是对重复检查的可接受的替代。\n\nC. 如果优化的范围被限制在有证据（例如，通过全程序分析或语言级保证）证明在循环的动态范围内除了 $T_1$ 没有其他线程写入 $n$，从而使 $n$ 在循环运行时实际上是不变的，那么该优化是合理的。\n\nD. 该优化是合理的，无论是否存在并发，因为 $i$ 单调递增，且在循环入口处 $i  n$ 意味着在所有后续迭代中 $i  n$。\n\nE. 如果编译器的范围被定义为忽略来自其他线程对共享变量的并发写入的线程内语义，那么该优化是合理的，因为正确性可以仅由 $T_1$ 的行为来判断。\n\n选择所有适用的选项。使用 SC 模型和所述的可观察行为概念来证明你的选择。你的证明应明确使用顺序一致性、可观察行为的定义，以及每次迭代检查 $i  n$ 与循环前快照 $n_0$ 在决定访问哪些 $A[i]$ 时的作用。",
            "solution": "优化的正确性取决于优化后的程序的所有可观察行为是否也是原始程序在顺序一致性（SC）模型下的合法行为。可观察行为明确包括内存安全。我们通过分析一个具体的并发执行场景来评估该优化。\n\n**场景分析：**\n假设初始共享状态为 $n=k$（例如，$k=10$）。\n1.  **优化后程序的执行**：线程 $T_1$ 在循环前读取 $n$，得到快照 $n_0=k$。它将执行一个从 $i=0$ 到 $k-1$ 的循环。\n2.  **并发干预**：在 $T_1$ 的循环执行到某次迭代（例如 $i=m$，其中 $m  k$，比如 $m=5$）之前，线程 $T_2$ 并发执行，将共享变量 $n$ 的值减小到 $m$，并立即使所有索引 $j \\ge m$ 的数组位置 $A[j]$ 失效。\n3.  **违反安全**：之后，$T_1$ 继续执行其循环到达迭代 $i=m$。由于其循环边界是固定的 $n_0=k$，并且 $m  k$，$T_1$ 将无条件地访问 $A[m]$。然而，此时 $A[m]$ 已经被 $T_2$ 设为无效。这次访问是对无效内存的访问，违反了内存安全，这是一个原始程序不会发生的行为。\n在同样的情景下，原始程序是安全的，因为当 $T_1$ 到达迭代 $i=m$ 时，它会重新读取 $n$ 的当前值（即 $m$），评估 $i  n$（即 $m  m$）为假，从而避免访问 $A[m]$。\n\n**结论**：由于存在一个合法的并发执行，使得优化后的程序会产生原始程序不可能有的行为（即内存访问错误），因此该优化不保持程序的语义，是错误的。\n\n基于以上分析，我们评估各个选项：\n\n**A.** 此陈述正确。如场景分析所示，由于 $T_2$ 可以动态缩小逻辑数组的大小并使内存失效，优化后的循环使用陈旧的边界 $n_0$ 会导致访问本应受 $i  n$ 保护的已失效内存，违反了内存安全。\n\n**B.** 此陈述错误。将 $n$ 声明为原子变量仅能保证对 $n$ 的读写是不可分的，但不能保证 $T_1$ 读取的值在稍后的使用中仍然有效。这是一个典型的“检查时-使用时”（TOCTOU）竞争条件，原子性本身无法解决。\n\n**C.** 此陈述正确。如果分析（例如全程序分析）可以证明在 $T_1$ 循环执行期间没有其他线程会写入 $n$，那么 $n$ 对于该循环就是事实上的不变量。在这种情况下，将边界检查外提是安全的。这强调了优化的安全范围取决于对并发写入的了解。\n\n**D.** 此陈述错误。该论证忽略了 $n$ 可能并发地减小。虽然 $i$ 单调递增，但 $n$ 不是单调的，因此 $i  n$ 的真值可以在迭代之间改变。\n\n**E.** 此陈述错误。一个正确的编译器必须遵守目标语言的内存模型，该模型定义了线程间的交互。忽略并发写入意味着编译器为共享内存并发程序生成了不正确的代码。编译器的范围必须包括语言规范所要求的所有线程交互。\n\n因此，正确的选项是 A 和 C。",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "现实世界中的编译器优化目标通常比单纯地最小化执行时间更为复杂。最后的这个实践深入探讨了一个场景，其中管理内部资源——可用寄存器的数量——成为首要任务。你将执行存活变量分析来计算寄存器压力，并应用一个字典序的优化目标，来决定是否应该采用“重新物质化”这项能用速度换取更少寄存器使用的优化。",
            "id": "3628550",
            "problem": "考虑一个包含十二条指令的单一基本块，以及一个简单的机器成本模型，其中每条指令都有一个整数周期成本。主要优化目标按字典序定义如下：当寄存器压力 $R$ 超过阈值 $\\rho$ 时，首先最小化 $R$；否则，最小化执行时间 $T$。假设仅允许对从常量计算出的值进行重新物化，并且重新物化是在每个使用点重新计算该值，而不是使其在整个块中保持活跃。\n\n使用以下基本定义作为推理的基础。寄存器压力 $R$ 是所有程序点上同时活跃的变量数量的最大值。如果一个变量的值将在块中的某个后续指令中使用，则该变量在该程序点是活跃的。执行时间 $T$ 被建模为块中所有指令的周期成本之和。重新物化是一种转换，它移除一个可重算值的定义，并在其每个使用点之前立即插入一个等效的定义；这种转换缩短了该值的活跃范围，但通过增加指令来增加 $T$。重点严格在于确定优化目标和范围：只有当 $R  \\rho$ 时，为了满足主要目标，才会做出重新物化的决定。\n\n该基本块为：\n$$(I_1):\\ x \\leftarrow \\mathrm{load}(M_1)\\ (\\text{cost }4)$$\n$$(I_2):\\ y \\leftarrow \\mathrm{load}(M_2)\\ (\\text{cost }4)$$\n$$(I_3):\\ v \\leftarrow d + e\\ (\\text{cost }1)$$\n$$(I_4):\\ t_1 \\leftarrow x + y\\ (\\text{cost }1)$$\n$$(I_5):\\ t_2 \\leftarrow t_1 \\times c\\ (\\text{cost }2)$$\n$$(I_6):\\ t_3 \\leftarrow x - y\\ (\\text{cost }1)$$\n$$(I_7):\\ t_4 \\leftarrow t_3 + t_2\\ (\\text{cost }1)$$\n$$(I_8):\\ r_2 \\leftarrow t_3 + 1\\ (\\text{cost }1)$$\n$$(I_9):\\ r_3 \\leftarrow t_2 + 1\\ (\\text{cost }1)$$\n$$(I_{10}):\\ r_1 \\leftarrow t_1 + v\\ (\\text{cost }1)$$\n$$(I_{11}):\\ r_4 \\leftarrow t_4 + 1\\ (\\text{cost }1)$$\n$$(I_{12}):\\ r_5 \\leftarrow v + 1\\ (\\text{cost }1)$$\n\n假设 $d$、$e$ 和 $c$ 是常量，因此 $v$ 是可重新物化的。各变量的使用情况如下：\n- $x$ 在 $(I_4)$ 和 $(I_6)$ 使用，\n- $y$ 在 $(I_4)$ 和 $(I_6)$ 使用，\n- $v$ 在 $(I_{10})$ 和 $(I_{12})$ 使用，\n- $t_1$ 在 $(I_5)$ 和 $(I_{10})$ 使用，\n- $t_2$ 在 $(I_7)$ 和 $(I_9)$ 使用，\n- $t_3$ 在 $(I_7)$ 和 $(I_8)$ 使用，\n- $t_4$ 在 $(I_{11})$ 使用。\n\n设阈值为 $\\rho = 4$。根据所述目标和成本模型，决定是否应对 $v$ 应用重新物化，并计算满足该目标所需的最小额外执行时间（以周期为单位）。将你的最终数值答案表示为单个数字。无需四舍五入。",
            "solution": "问题要求评估是否应对给定基本块中的变量 $v$ 应用重新物化优化。该决策受一个按字典序定义的优化目标支配：首先，如果寄存器压力 $R$ 超过阈值 $\\rho$，则最小化 $R$；其次，最小化执行时间 $T$。\n\n首先，我们分析没有任何转换的基本块的初始状态。\n\n总执行时间 $T_{orig}$ 是这 12 条指令的成本之和：\n$$T_{orig} = 4 + 4 + 1 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 19 \\text{ cycles}$$\n\n接下来，我们必须确定寄存器压力 $R_{orig}$。寄存器压力是任何程序点上同时活跃的变量的最大数量。如果一个变量的值被后续指令使用，那么它在该点是活跃的。我们确定在每条指令执行后紧接着的程序点上的活跃变量集合。\n\n临时变量的活跃范围如下：\n- $x$：在 $I_1$ 定义，最后一次使用在 $I_6$。\n- $y$：在 $I_2$ 定义，最后一次使用在 $I_6$。\n- $v$：在 $I_3$ 定义，最后一次使用在 $I_{12}$。\n- $t_1$：在 $I_4$ 定义，最后一次使用在 $I_{10}$。\n- $t_2$：在 $I_5$ 定义，最后一次使用在 $I_9$。\n- $t_3$：在 $I_6$ 定义，最后一次使用在 $I_8$。\n- $t_4$：在 $I_7$ 定义，最后一次使用在 $I_{11}$。\n\n让我们确定关键程序点上活跃变量集合的大小：\n- 在 $I_1$ 之后：$\\{x\\}$，大小为 1。\n- 在 $I_2$ 之后：$\\{x, y\\}$，大小为 2。\n- 在 $I_3$ 之后：$\\{x, y, v\\}$，大小为 3。\n- 在 $I_4$ 之后：$\\{x, y, v, t_1\\}$，大小为 4。\n- 在 $I_5$ 之后：变量 $x$（在 $I_6$ 使用）、$y$（在 $I_6$ 使用）、$v$（在 $I_{10}, I_{12}$ 使用）、$t_1$（在 $I_{10}$ 使用）和 $t_2$（在 $I_7, I_9$ 使用）都是活跃的。活跃集是 $\\{x, y, v, t_1, t_2\\}$，其大小为 5。\n- 在 $I_6$ 之后：$x$ 和 $y$ 不再活跃。$t_3$ 变为活跃。活跃集是 $\\{v, t_1, t_2, t_3\\}$，大小为 4。\n- 在 $I_7$ 之后：$t_2$（在 $I_9$ 使用）和 $t_3$（在 $I_8$ 使用）仍然活跃。$t_4$ 变为活跃。活跃集是 $\\{v, t_1, t_2, t_3, t_4\\}$，大小为 5。\n\n同时活跃的变量的最大数量是 5。因此，初始寄存器压力为 $R_{orig} = 5$。\n问题陈述了寄存器压力阈值为 $\\rho = 4$。由于 $R_{orig} = 5  \\rho = 4$，主要优化目标是最小化寄存器压力。我们必须评估重新物化是否能实现这一目标。\n\n其次，我们分析对 $v$ 进行重新物化后基本块的状态。\n变量 $v$ 是从常量（$d$ 和 $e$）计算得出的，因此是可重新物化的。该转换涉及移除指令 $I_3$ 处 $v$ 的原始定义，并在其每个使用点 $I_{10}$ 和 $I_{12}$ 之前立即插入一个新的定义。\n\n指令 $I_3$（成本 1）被移除。两条新指令被插入到块中，每条都是 $I_3$ 的副本，成本均为 1。\n指令总数变为 $12 - 1 + 2 = 13$。\n新的执行时间 $T_{remat}$ 是：\n$$T_{remat} = T_{orig} - \\text{cost}(I_3) + 2 \\times \\text{cost}(\\text{remat_op}) = 19 - 1 + 2 \\times 1 = 20 \\text{ cycles}$$\n\n现在，我们计算新的寄存器压力 $R_{remat}$。重新物化 $v$ 的关键效果是消除了其从 $I_3$ 之后到 $I_{12}$ 之后的长活跃范围。新的重新物化的 $v$ 实例具有极短的活跃范围，仅存在于其新定义和其唯一的对应使用之间。\n我们重新评估相同关键程序点上的活跃集大小，注意到变量 $v$ 已不存在：\n- 在 $I_5$ 之后：活跃集现在是 $\\{x, y, t_1, t_2\\}$。其大小为 4。\n- 在 $I_7$ 之后：活跃集现在是 $\\{t_1, t_2, t_3, t_4\\}$。其大小为 4。\n\n现在块主体中任何一点的最大活跃变量数为 4。新定义的插入不会产生新的最大值。例如，在 $I_{10}$ 之前对 $v$ 进行重新物化之后，活跃集是 $\\{t_1, t_4, v\\}$，其大小为 3。因此，新的寄存器压力为 $R_{remat} = 4$。\n\n最后，我们应用决策逻辑。\n初始状态下 $R_{orig} = 5$，这违反了条件 $R \\le \\rho$。主要目标是最小化 $R$。\n重新物化转换将寄存器压力从 $R_{orig} = 5$ 降低到 $R_{remat} = 4$。由于 $R_{remat}  R_{orig}$，该转换是有益的，并且根据所述目标，是强制性的。通过应用重新物化，新的寄存器压力 $R_{remat} = 4$ 满足了条件 $R \\le \\rho$。\n\n问题要求的是满足该目标所需的最小额外执行时间。为了满足主要目标，该转换是必需的，而此转换增加了执行时间。\n额外的执行时间是新旧执行时间之差：\n$$\\Delta T = T_{remat} - T_{orig} = 20 - 19 = 1$$\n\n因此，应当对 $v$ 应用重新物化，并且满足优化目标所需的最小额外执行时间为 1 个周期。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}