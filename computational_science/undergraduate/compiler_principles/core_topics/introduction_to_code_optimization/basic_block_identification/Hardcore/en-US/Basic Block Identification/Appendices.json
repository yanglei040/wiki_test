{
    "hands_on_practices": [
        {
            "introduction": "Mastering the process of identifying basic blocks begins with a direct application of the rules. This first practice provides a straightforward sequence of three-address code, allowing you to focus on methodically applying the leader identification algorithm without the complexity of high-level language constructs. By partitioning this code , you will build a solid foundation for analyzing more intricate control flow.",
            "id": "3624020",
            "problem": "Consider the following straight-line, three-address-like program fragment with two adjacent conditional branches whose fall-through flows converge to the same computation. Labels indicate potential jump targets, and the program counter advances sequentially unless redirected by a jump.\n1. `if a goto T1`\n2. `if b goto T2`\n3. `Lf: t := t + 1`\n4. `goto End`\n5. `T1: u := u * 2`\n6. `goto End`\n7. `T2: v := v - 3`\n8. `goto End`\n9. `End: return`\nUsing only the foundational definitions in compiler theory that a Basic Block (BB) is a maximal sequence of instructions with a single entry and single exit, and that leaders of basic blocks are determined as follows:\n- The first instruction of the program is a leader.\n- Any instruction that is the target of a conditional or unconditional jump is a leader.\n- Any instruction that immediately follows a conditional or unconditional jump is a leader.\nPartition the program into a minimal set of basic blocks and then construct the corresponding Control Flow Graph (CFG) conceptually, where nodes are basic blocks and edges represent possible control transfers. Let $V$ denote the number of nodes in this CFG. What is the value of $V$? Provide the exact integer value; no rounding is needed and no units are required.",
            "solution": "The problem requires partitioning a given program fragment into basic blocks and determining the number of nodes, denoted by $V$, in the corresponding Control Flow Graph (CFG). The process is governed by the provided definitions of a basic block and the rules for identifying leaders.\n\nFirst, let us restate the program fragment with each instruction numbered:\n1. `if a goto T1`\n2. `if b goto T2`\n3. `Lf: t := t + 1`\n4. `goto End`\n5. `T1: u := u * 2`\n6. `goto End`\n7. `T2: v := v - 3`\n8. `goto End`\n9. `End: return`\n\nThe core of the task is to identify the \"leaders\" of the basic blocks using the three specified rules. A basic block begins with a leader and includes all instructions up to, but not including, the next leader.\n\nRule 1: The first instruction of the program is a leader.\nApplying this rule, instruction 1 (`if a goto T1`) is a leader.\n\nRule 2: Any instruction that is the target of a conditional or unconditional jump is a leader.\nWe examine the jump instructions in the program:\n- Instruction 1 (`if a goto T1`): The target is the instruction at label `T1`, which is instruction 5. Therefore, instruction 5 (`u := u * 2`) is a leader.\n- Instruction 2 (`if b goto T2`): The target is the instruction at label `T2`, which is instruction 7. Therefore, instruction 7 (`v := v - 3`) is a leader.\n- Instructions 4, 6, and 8 (`goto End`): The target is the instruction at label `End`, which is instruction 9. Therefore, instruction 9 (`return`) is a leader.\n\nRule 3: Any instruction that immediately follows a conditional or unconditional jump is a leader.\nWe examine the instructions immediately following each jump:\n- Instruction 1 is a conditional jump. The instruction that immediately follows it is instruction 2 (`if b goto T2`). Therefore, instruction 2 is a leader.\n- Instruction 2 is a conditional jump. The instruction that immediately follows it is instruction 3 (`t := t + 1`). Therefore, instruction 3 is a leader.\n- Instruction 4 is an unconditional jump. The instruction that immediately follows it is instruction 5. Instruction 5 has already been identified as a leader.\n- Instruction 6 is an unconditional jump. The instruction that immediately follows it is instruction 7. Instruction 7 has already been identified as a leader.\n- Instruction 8 is an unconditional jump. The instruction that immediately follows it is instruction 9. Instruction 9 has already been identified as a leader.\n\nConsolidating our findings, the set of leader instructions is {instruction 1, instruction 2, instruction 3, instruction 5, instruction 7, instruction 9}.\n\nNow, we partition the program into basic blocks. Each basic block starts at a leader and extends to the instruction just before the next leader, or to the end of a block (which is typically a jump instruction).\n\n- **Basic Block 1 (BB1)**: Starts at leader 1. Instruction 1 is a conditional jump, which must be the last instruction in its basic block. The next instruction, 2, is also a leader. Thus, BB1 contains only instruction 1.\n  - BB1: {1: `if a goto T1`}\n\n- **Basic Block 2 (BB2)**: Starts at leader 2. Instruction 2 is a conditional jump. The next instruction, 3, is also a leader. Thus, BB2 contains only instruction 2.\n  - BB2: {2: `if b goto T2`}\n\n- **Basic Block 3 (BB3)**: Starts at leader 3. The block includes instruction 3 (`t := t + 1`) and continues until the next leader (instruction 5) or a jump. Instruction 4 (`goto End`) is a jump. Thus, the block consists of instructions 3 and 4.\n  - BB3: {3: `t := t + 1`, 4: `goto End`}\n\n- **Basic Block 4 (BB4)**: Starts at leader 5. The block includes instruction 5 (`u := u * 2`) and continues. Instruction 6 (`goto End`) is a jump. The instruction following it, 7, is a leader. Thus, the block consists of instructions 5 and 6.\n  - BB4: {5: `u := u * 2`, 6: `goto End`}\n\n- **Basic Block 5 (BB5)**: Starts at leader 7. The block includes instruction 7 (`v := v - 3`) and continues. Instruction 8 (`goto End`) is a jump. The instruction following it, 9, is a leader. Thus, the block consists of instructions 7 and 8.\n  - BB5: {7: `v := v - 3`, 8: `goto End`}\n\n- **Basic Block 6 (BB6)**: Starts at leader 9. This block contains only instruction 9 (`return`), as it is the last instruction in the program fragment.\n  - BB6: {9: `return`}\n\nBy partitioning the program according to the rules, we have identified 6 distinct basic blocks. In a Control Flow Graph (CFG), each basic block corresponds to a single node. Therefore, the number of nodes $V$ in the CFG is equal to the number of basic blocks.\n\nThe number of basic blocks is 6.\nHence, the value of $V$ is 6.",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "The structure of a program's control flow graph is not arbitrary; it is a direct consequence of the source language's semantics. This exercise  explores this connection by comparing the bitwise AND (``) and logical AND (``) operators. You will see firsthand how short-circuit evaluation introduces additional branches, fundamentally altering the basic block partitioning and demonstrating why understanding language rules is critical for a compiler.",
            "id": "3624102",
            "problem": "Consider a C-like language that follows the conventional semantics for logical and bitwise operators. The program fragment below is written in two variants, identical except for the operator used in the conditional. The functions $f()$, $g()$, and $h(x)$ return integers; they may have side effects but do not themselves branch or throw exceptions. Assume a standard construction of a Control Flow Graph (CFG), where nodes are Basic Blocks (BB). A Basic Block (BB) is a maximal sequence of instructions with a single entry and a single exit, and control can only enter at the beginning and leave at the end; branching and jumping occur only at the end of a basic block. The Control Flow Graph (CFG) has directed edges representing possible control transfers between basic blocks. The conditional in the statement uses either logical AND `a  b` (which short-circuits) or bitwise AND `a  b` (which evaluates both operands without short-circuiting). The fragment is:\n\n- Initialize $x := 0$.\n- If $\\Phi$ then assign $x := 1$, else assign $x := 2$.\n- Assign $y := h(x)$ and then terminate (no further statements).\n\nVariant 1 uses the bitwise AND `Φ ≡ (f()  g())`. Variant 2 uses the logical AND `Φ ≡ (f()  g())`.\n\nStarting from the definitions above and the conventional semantics of `` and `` in C-like languages, determine the number of Basic Blocks (BB) in the Control Flow Graph (CFG) for each variant, under the standard leader-based partitioning: the first statement is a leader, any target of a branch is a leader, and any statement immediately following a branch is a leader. Ignore exceptional control flow such as interrupts or asynchronous signals, and treat function calls $f()$, $g()$, and $h(x)$ as single instructions that do not branch.\n\nWhich option correctly gives the pair $(\\text{BB count for } (f() \\,\\, g()), \\text{ BB count for } (f() \\,\\, g()))$?\n\nA. $(4, 5)$\n\nB. $(5, 4)$\n\nC. $(4, 4)$\n\nD. $(5, 5)$",
            "solution": "The core of the problem lies in translating the high-level code constructs into a sequence of rudimentary instructions (akin to three-address code) and applying the given rules for identifying \"leaders,\" which mark the beginning of new Basic Blocks (BBs). A Basic Block is a maximal sequence of straight-line code.\n\nThe rules for identifying leaders are:\n1. The first statement in the program is a leader.\n2. Any statement that is the target of a branch instruction is a leader.\n3. Any statement that immediately follows a branch instruction is a leader.\n\nLet us analyze the two variants of the expression $\\Phi$.\n\n**Case 1: `(f()  g())` (Bitwise AND)**\n\nThe bitwise AND operator `` in C-like languages does not exhibit short-circuit behavior. Both operands, `f()` and `g()`, are always evaluated. The control flow can be represented by the following sequence of instructions:\n\n1. `x := 0`\n2. `t_1 := f()`\n3. `t_2 := g()`\n4. `t_3 := t_1  t_2`\n5. `if t_3 == 0 goto L_ELSE` (Conditional branch)\n6. `x := 1`\n7. `goto L_END` (Unconditional branch)\n8. `L_ELSE: x := 2`\n9. `L_END: y := h(x)`\n\nNow, we apply the leader identification rules:\n- Instruction 1 is a leader by Rule 1.\n- Instruction 8 (labeled `L_ELSE`) is a leader by Rule 2, as it is the target of the branch at instruction 5.\n- Instruction 9 (labeled `L_END`) is a leader by Rule 2, as it is the target of the branch at instruction 7.\n- Instruction 6 is a leader by Rule 3, as it immediately follows the conditional branch at instruction 5.\n\nThe set of leaders is therefore the set of instructions {1, 6, 8, 9}. A basic block starts at a leader and extends to the instruction just before the next leader or to the end of a branch instruction.\n\n- **BB1**: Starts at leader 1. It includes instructions 1, 2, 3, 4, 5. It ends with a conditional branch.\n- **BB2**: Starts at leader 6. It includes instructions 6, 7. It ends with an unconditional branch.\n- **BB3**: Starts at leader 8. It includes only instruction 8. The next instruction, 9, is a leader, so this block terminates here and control falls through to the next block.\n- **BB4**: Starts at leader 9. It includes only instruction 9. The program fragment ends here.\n\nThus, for the expression `(f()  g())`, there are a total of 4 basic blocks.\n\n**Case 2: `(f()  g())` (Logical AND)**\n\nThe logical AND operator `` exhibits short-circuit behavior. If `f()` evaluates to false (a value of 0), the second operand `g()` is not evaluated, and control flow jumps directly to the `else` part of the conditional. This introduces an additional branch compared to the bitwise case.\n\nThe control flow can be represented as:\n\n1. `x := 0`\n2. `t_1 := f()`\n3. `if t_1 == 0 goto L_ELSE` (Short-circuit conditional branch)\n4. `t_2 := g()`\n5. `if t_2 == 0 goto L_ELSE` (Second part of the condition)\n6. `x := 1`\n7. `goto L_END` (Unconditional branch)\n8. `L_ELSE: x := 2`\n9. `L_END: y := h(x)`\n\nApplying the leader identification rules:\n- Instruction 1 is a leader by Rule 1.\n- Instruction 8 (labeled `L_ELSE`) is a leader by Rule 2, being the target of branches at instructions 3 and 5.\n- Instruction 9 (labeled `L_END`) is a leader by Rule 2, being the target of the branch at instruction 7.\n- Instruction 4 is a leader by Rule 3, as it immediately follows the conditional branch at instruction 3.\n- Instruction 6 is a leader by Rule 3, as it immediately follows the conditional branch at instruction 5.\n\nThe set of leaders is {1, 4, 6, 8, 9}.\n\n- **BB1**: Starts at leader 1. It includes instructions 1, 2, 3. It ends with a conditional branch.\n- **BB2**: Starts at leader 4. It includes instructions 4, 5. It ends with a conditional branch.\n- **BB3**: Starts at leader 6. It includes instructions 6, 7. It ends with an unconditional branch.\n- **BB4**: Starts at leader 8. It includes only instruction 8.\n- **BB5**: Starts at leader 9. It includes only instruction 9.\n\nThus, for the expression `(f()  g())`, there are a total of 5 basic blocks. The short-circuit evaluation introduced an extra branch, which split the initial evaluation block into two separate basic blocks.\n\nThe question asks for the pair $(\\text{BB count for } (f() \\,\\, g()), \\text{ BB count for } (f() \\,\\, g()))$. Based on our analysis, this pair is $(4, 5)$.\n\nWe now evaluate the given options:\n\nA. $(4, 5)$: This matches our derived result. The number of basic blocks for the bitwise AND `` case is 4, and for the logical AND `` case is 5. **Correct**.\n\nB. $(5, 4)$: This inverts the correct counts for the two cases. **Incorrect**.\n\nC. $(4, 4)$: This correctly identifies the count for the bitwise AND case but fails to account for the additional basic block created by the short-circuiting logic of the logical AND. **Incorrect**.\n\nD. $(5, 5)$: This correctly identifies the count for the logical AND case but incorrectly overestimates the number of blocks for the non-short-circuiting bitwise AND. **Incorrect**.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Real-world code often contains complex control structures like the `switch` statement, which can include fall-through cases, `break` statements, and explicit jumps. This problem  challenges you to apply the leader identification rules to such a scenario, testing your ability to handle multiple branch targets and non-linear control flow. Successfully partitioning this code demonstrates a comprehensive grasp of basic block analysis in a practical context.",
            "id": "3624092",
            "problem": "Consider the following C-like function that uses a switch statement with fall-through cases, a default, and a case that jumps to a label outside the switch. Your task is to identify basic blocks and compute how many basic blocks the resulting control flow graph contains.\n\nUse the following fundamental base:\n- A basic block is a maximal sequence of instructions with a single entry and a single exit, with no possibility of branching into or out of the middle of the sequence.\n- Leaders are determined by the standard rules: the first instruction in the program is a leader; any instruction that is the target of a jump (including each case and default label of a switch, and any explicit label such as a goto target) is a leader; any instruction immediately following a jump (such as a goto, break, return, or a switch dispatch) is a leader.\n- For a switch, treat each case and the default as possible targets of the multiway branch. Adjacent labels that precede the same first instruction denote multiple entries into the same basic block. A break inside a switch transfers control to the first instruction following the switch, which is therefore a leader.\n\nAnalyze the following function:\n\n```c\nvoid f(int $x$, int *$p$) {\n  int $y$ = $0$;\n  switch ($x$) {\n    case $0$:\n      $y$ = $y$ + $1$;\n      /* fall-through */\n    case $1$:\n      *$p$ = $y$;\n      goto $\\mathrm{Lout}$;\n    case $2$:\n      $y$ = $y$ + $2$;\n      break;\n    case $3$:\n    case $4$:\n      $y$ = $y$ + $x$;\n      /* fall-through to default */\n    default:\n      $y$ = -$y$;\n      if ($x$ > $0$) break;\n      $y$ = $y$ + $1$;\n      /* no break: falls out of switch */\n  }\n  $y$ = $y$ \\times $2$;\n$\\mathrm{Lout}$:\n  $y$ = $y$ - $1$;\n}\n```\n\nInstructions:\n- Apply the definitions above to identify leaders and form basic blocks.\n- Pay close attention to fall-through behavior, both between cases and from the default to after the switch, and to the jump to $\\mathrm{Lout}$ outside the switch.\n- Then compute the total number of basic blocks in the resulting Control Flow Graph (CFG). Express your final answer as a single integer. No rounding is required and no units are needed.",
            "solution": "The problem requires us to determine the number of basic blocks in the control flow graph (CFG) for a given C-like function. The process involves two main steps: identifying leader instructions and then partitioning the instruction sequence into basic blocks based on these leaders. A basic block begins with a leader and includes all subsequent instructions up to, but not including, the next leader, or up to the end of a jump instruction.\n\nThe rules for identifying leaders are as follows:\n1.  The first instruction in the function is a leader.\n2.  Any instruction that is the target of a jump is a leader.\n3.  Any instruction that immediately follows a jump instruction is a leader.\n\nLet us analyze the provided function and identify all leaders by systematically applying these rules. For clarity, we will represent the function's instructions in a linearized sequence.\n\nThe function code is:\n```c\nvoid f(int $x$, int *$p$) {\n  1: int $y$ = $0$;\n  2: switch ($x$) {\n  3:   case $0$:\n       $y$ = $y$ + $1$;\n  4:   case $1$:\n       *$p$ = $y$;\n  5:   goto $\\mathrm{Lout}$;\n  6:   case $2$:\n       $y$ = $y$ + $2$;\n  7:   break;\n  8:   case $3$:\n  9:   case $4$:\n       $y$ = $y$ + $x$;\n 10:   default:\n       $y$ = -$y$;\n 11:   if ($x$ > $0$) break;\n 12:   $y$ = $y$ + $1$;\n 13: }\n 14: $y$ = $y$ \\times $2$;\n 15: $\\mathrm{Lout}$:\n 16: $y$ = $y$ - $1$;\n 17: }\n```\n\nWe identify the leaders as follows:\n\n1.  **Instruction `int $y$ = $0$;` is a leader.**\n    This is because it is the first instruction of the function (Rule 1). This marks the beginning of the first basic block.\n\n2.  **Instruction `$y = y + 1$;` (following `case $0$:`) is a leader.**\n    This instruction is the target of the `switch` statement for `case $0$`. The `switch` is a multi-way jump, and `case` labels mark the targets of this jump (Rule 2).\n\n3.  **Instruction `*$p$ = $y$;` (following `case $1$:`) is a leader.**\n    This is the target for `case $1$` of the `switch` statement (Rule 2).\n\n4.  **Instruction `$y = y + 2$;` (following `case $2$:`) is a leader.**\n    This is the target for `case $2$` of the `switch` statement (Rule 2).\n\n5.  **Instruction `$y = y + x$;` (following `case $3$:` and `case $4$:`) is a leader.**\n    This is the target for both `case $3$` and `case $4$` of the `switch` statement (Rule 2).\n\n6.  **Instruction `$y = -$y$;` (following `default:`) is a leader.**\n    This is the target for the `default` case of the `switch` statement (Rule 2).\n\n7.  **Instruction `$y = y \\times 2$;` is a leader.**\n    This instruction is the target of the `break;` statements (from `case $2$` and from the conditional `if`). A `break` inside a `switch` jumps to the instruction immediately following the `switch` block. Therefore, this instruction is a jump target (Rule 2).\n\n8.  **Instruction `$y = y - 1$;` (at label `$\\mathrm{Lout}$:`) is a leader.**\n    This instruction is the target of the `goto $\\mathrm{Lout}$;` statement (Rule 2).\n\n9.  **Instruction `$y = y + 1$;` (following `if ($x$ > $0$) break;`) is a leader.**\n    This instruction immediately follows the conditional jump `if ($x$ > $0$) break;`. According to Rule 3, the instruction following a jump is a leader.\n\nHaving identified all the leaders, we can now partition the code into basic blocks. Each block starts at a leader and ends just before the next leader or at a jump instruction.\n\n*   **Block 1**:\n    Starts at `int $y$ = $0$;` (Leader 1).\n    Contains: `int $y$ = $0$;`, `switch ($x$)`.\n    Ends with the multi-way jump `switch ($x$)`.\n\n*   **Block 2**:\n    Starts at `$y = y + 1$;` (Leader 2).\n    Contains: `$y = y + 1$;`.\n    Ends by falling through to the next instruction, which is Leader 3.\n\n*   **Block 3**:\n    Starts at `*$p$ = $y$;` (Leader 3).\n    Contains: `*$p$ = $y$;`, `goto $\\mathrm{Lout}$;`.\n    Ends with the unconditional jump `goto`.\n\n*   **Block 4**:\n    Starts at `$y = y + 2$;` (Leader 4).\n    Contains: `$y = y + 2$;`, `break;`.\n    Ends with the unconditional jump `break`.\n\n*   **Block 5**:\n    Starts at `$y = y + x$;` (Leader 5).\n    Contains: `$y = y + x$;`.\n    Ends by falling through to the `default` case, whose first instruction is Leader 6.\n\n*   **Block 6**:\n    Starts at `$y = -$y$;` (Leader 6).\n    Contains: `$y = -$y$;`, `if ($x$ > $0$) break;`.\n    Ends with the conditional jump `if`.\n\n*   **Block 7**:\n    Starts at `$y = y + 1$;` (Leader 9).\n    Contains: `$y = y + 1$;`.\n    Ends by falling through out of the `switch` statement to the next instruction, which is Leader 7.\n\n*   **Block 8**:\n    Starts at `$y = y \\times 2$;` (Leader 7).\n    Contains: `$y = y \\times 2$;`.\n    Ends by falling through to the instruction at label `$\\mathrm{Lout}$`, which is Leader 8.\n\n*   **Block 9**:\n    Starts at `$y = y - 1$;` (Leader 8).\n    Contains: `$y = y - 1$;`.\n    Ends with the implicit return at the end of the function.\n\nBy counting the distinct leaders, which correspond to the start of each basic block, we find there are 9 leaders. This means the instruction sequence is partitioned into 9 basic blocks.\nThe leaders are:\n1. `int $y$ = $0$;`\n2. `$y = y + 1$;`\n3. `*$p$ = $y$;`\n4. `$y = y + 2$;`\n5. `$y = y + x$;`\n6. `$y = -$y$;`\n7. `$y = y \\times 2$;`\n8. `$y = y - 1$;`\n9. `$y = y + 1$;` (the one after the `if`)\n\nAll these leaders start a new basic block. Therefore, the total number of basic blocks is 9.",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}