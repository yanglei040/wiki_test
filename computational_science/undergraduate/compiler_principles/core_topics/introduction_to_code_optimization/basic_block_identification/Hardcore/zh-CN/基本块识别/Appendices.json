{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。本节的第一个练习旨在帮助你掌握识别基本块的核心算法。通过分析一段包含相邻条件分支的简单三地址码，你将练习如何应用首指令、跳转目标和跳转后续指令这三条规则来准确地找出所有首指令，从而为构建控制流图（CFG）打下坚实的基础。这个练习是理解代码结构化表示的第一步 。",
            "id": "3624020",
            "problem": "考虑以下直线式、类三地址码的程序片段，其中包含两个相邻的条件分支，其顺序执行流（fall-through）汇合到相同的计算。标签指示了潜在的跳转目标，程序计数器按顺序前进，除非被跳转指令重定向。每行代码的行号都已明确标出：\n$1$: if a goto T1\n$2$: if b goto T2\n$3$: Lf: t := t + 1\n$4$: goto End\n$5$: T1: u := u * 2\n$6$: goto End\n$7$: T2: v := v - 3\n$8$: goto End\n$9$: End: return\n仅使用编译器理论中的基本定义，即基本块（Basic Block, BB）是具有单一入口和单一出口的最大指令序列，并且基本块的首指令（leader）按如下方式确定：\n- 程序的第一个指令是首指令。\n- 任何作为条件跳转或无条件跳转目标的指令是首指令。\n- 任何紧跟在条件跳转或无条件跳转之后的指令是首指令。\n将该程序划分为一个最小的基本块集合，然后从概念上构建相应的控制流图（Control Flow Graph, CFG），其中节点是基本块，边代表可能的控制转移。令 $V$ 表示此CFG中节点的数量。$V$ 的值是多少？请提供确切的整数值；无需四舍五入，也无需单位。",
            "solution": "该问题要求将给定的程序片段划分为基本块，并确定相应控制流图（CFG）中节点的数量，用 $V$ 表示。此过程遵循所提供的基本块定义和识别首指令的规则。\n\n首先，让我们重述带有编号的程序片段：\n$1$: `if a goto T1`\n$2$: `if b goto T2`\n$3$: `Lf: t := t + 1`\n$4$: `goto End`\n$5$: `T1: u := u * 2`\n$6$: `goto End`\n$7$: `T2: v := v - 3`\n$8$: `goto End`\n$9$: `End: return`\n\n任务的核心是使用三个指定规则来识别基本块的“首指令”（leader）。一个基本块以一个首指令开始，并包含直到（但不包括）下一个首指令之前的所有指令。\n\n规则1：程序的第一个指令是首指令。\n应用此规则，指令1 (`if a goto T1`) 是一个首指令。\n\n规则2：任何作为条件跳转或无条件跳转目标的指令是首指令。\n我们检查程序中的跳转指令：\n- 指令1 (`if a goto T1`)：目标是标签T1处的指令，即指令5。因此，指令5 (`u := u * 2`) 是一个首指令。\n- 指令2 (`if b goto T2`)：目标是标签T2处的指令，即指令7。因此，指令7 (`v := v - 3`) 是一个首指令。\n- 指令4、6和8 (`goto End`)：目标是标签End处的指令，即指令9。因此，指令9 (`return`) 是一个首指令。\n\n规则3：任何紧跟在条件跳转或无条件跳转之后的指令是首指令。\n我们检查每个跳转指令紧随其后的指令：\n- 指令1是条件跳转。紧随其后的指令是指令2 (`if b goto T2`)。因此，指令2是一个首指令。\n- 指令2是条件跳转。紧随其后的指令是指令3 (`t := t + 1`)。因此，指令3是一个首指令。\n- 指令4是无条件跳转。紧随其后的指令是指令5。指令5已经被确定为首指令。\n- 指令6是无条件跳转。紧随其后的指令是指令7。指令7已经被确定为首指令。\n- 指令8是无条件跳转。紧随其后的指令是指令9。指令9已经被确定为首指令。\n\n综合我们的发现，首指令的集合是{指令1, 指令2, 指令3, 指令5, 指令7, 指令9}。\n\n现在，我们将程序划分为基本块。每个基本块从一个首指令开始，并延伸到下一个首指令之前的指令，或者到该块的末尾（通常是一个跳转指令）。\n\n- **基本块1 (BB1)**：从首指令1开始。指令1是一个条件跳转，它必须是其所在基本块的最后一条指令。下一条指令2也是一个首指令。因此，BB1仅包含指令1。\n  - BB1: {$1$: `if a goto T1`}\n\n- **基本块2 (BB2)**：从首指令2开始。指令2是一个条件跳转。下一条指令3也是一个首指令。因此，BB2仅包含指令2。\n  - BB2: {$2$: `if b goto T2`}\n\n- **基本块3 (BB3)**：从首指令3开始。该块包含指令3 (`t := t + 1`)，并一直延续到下一个首指令（指令5）或一个跳转指令。指令4 (`goto End`) 是一个跳转。因此，该块由指令3和4组成。\n  - BB3: {$3$: `t := t + 1`, $4$: `goto End`}\n\n- **基本块4 (BB4)**：从首指令5开始。该块包含指令5 (`u := u * 2`)，并继续。指令6 (`goto End`) 是一个跳转。其后的指令7是一个首指令。因此，该块由指令5和6组成。\n  - BB4: {$5$: `u := u * 2`, $6$: `goto End`}\n\n- **基本块5 (BB5)**：从首指令7开始。该块包含指令7 (`v := v - 3`)，并继续。指令8 (`goto End`) 是一个跳转。其后的指令9是一个首指令。因此，该块由指令7和8组成。\n  - BB5: {$7$: `v := v - 3`, $8$: `goto End`}\n\n- **基本块6 (BB6)**：从首指令9开始。此块仅包含指令9 (`return`)，因为它是该程序片段的最后一条指令。\n  - BB6: {$9$: `return`}\n\n通过根据规则划分程序，我们确定了6个不同的基本块。在控制流图（CFG）中，每个基本块对应一个节点。因此，CFG中的节点数 $V$ 等于基本块的数量。\n\n基本块的数量是6。\n因此，$V$ 的值是6。",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "在掌握了基本规则后，下一个挑战是将这些规则应用于更接近高级语言的场景。此练习探讨了编程语言的语义细节（例如，逻辑与 `` 的短路求值行为与按位与 `` 的完全求值）如何深刻影响底层控制流。通过比较这两种情况，你将亲身体会到为何编译器设计者必须精确理解语言规范，因为它直接决定了代码的控制流图结构，并最终影响优化机会 。",
            "id": "3624102",
            "problem": "考虑一个遵循逻辑运算符和位运算符常规语义的类 C 语言。下面的程序片段有两个变体，除了条件语句中使用的运算符不同外，其他完全相同。函数 $f()$、$g()$ 和 $h(x)$ 返回整数；它们可能有副作用，但自身不会分支或抛出异常。假设采用标准的控制流图（CFG）构建方法，其中节点为基本块（BB）。一个基本块（BB）是具有单一入口和单一出口的指令的最大序列，控制流只能在开始处进入并在末尾处离开；分支和跳转仅在基本块的末尾发生。控制流图（CFG）具有表示基本块之间可能控制转移的有向边。语句中的条件使用逻辑与 ``（会短路）或位与 ``（会计算两个操作数而不会短路）。该片段如下：\n\n- 初始化 $x := 0$。\n- 如果 $\\Phi$ 为真，则赋值 $x := 1$，否则赋值 $x := 2$。\n- 赋值 $y := h(x)$ 然后终止（没有后续语句）。\n\n变体 1 使用 $\\Phi \\equiv (f() \\\\ g())$。变体 2 使用 $\\Phi \\equiv (f() \\ g())$。\n\n从上述定义以及类 C 语言中 `` 和 `` 的常规语义出发，确定在标准的基于首指令的分区下，每个变体的控制流图（CFG）中的基本块（BB）数量：第一条语句是首指令，任何分支的目标是首指令，任何紧跟在分支之后的语句是首指令。忽略异常控制流，如中断或异步信号，并将函数调用 $f()$、$g()$ 和 $h(x)$ 视为不产生分支的单条指令。\n\n哪个选项正确地给出了数对 (`BB count for (f()  g())`, `BB count for (f()  g())`)？\n\nA. $(4, 5)$\n\nB. $(5, 4)$\n\nC. $(4, 4)$\n\nD. $(5, 5)$",
            "solution": "问题的核心在于将高级代码结构翻译成一系列基本指令（类似于三地址码），并应用给定的规则来识别“首指令（leader）”，首指令标志着新基本块（BB）的开始。一个基本块是直线型代码的最大序列。\n\n识别首指令的规则如下：\n$1$. 程序中的第一条语句是首指令。\n$2$. 任何作为分支指令目标的语句是首指令。\n$3$. 任何紧跟在分支指令之后的语句是首指令。\n\n让我们分析表达式 $\\Phi$ 的两种变体。\n\n**情况 1：`(f()  g())` (位与)**\n\n类 C 语言中的位与运算符 `` 不表现出短路行为。两个操作数 `f()` 和 `g()` 总是会被求值。其控制流可以用以下指令序列表示：\n\n$1$. `x := 0`\n$2$. `t_1 := f()`\n$3$. `t_2 := g()`\n$4$. `t_3 := t_1  t_2`\n$5$. `if t_3 == 0 goto L_ELSE` (条件分支)\n$6$. `x := 1`\n$7$. `goto L_END` (无条件分支)\n$8$. `L_ELSE: x := 2`\n$9$. `L_END: y := h(x)`\n\n现在，我们应用首指令识别规则：\n- 指令 $1$ 根据规则 $1$ 是首指令。\n- 指令 $8$ (标签为 `L_ELSE`) 根据规则 $2$ 是首指令，因为它是指令 $5$ 处分支的目标。\n- 指令 $9$ (标签为 `L_END`) 根据规则 $2$ 是首指令，因为它是指令 $7$ 处分支的目标。\n- 指令 $6$ 根据规则 $3$ 是首指令，因为它紧跟在指令 $5$ 的条件分支之后。\n\n因此，首指令集合是指令 $\\{1, 6, 8, 9\\}$。一个基本块从一个首指令开始，延伸到下一个首指令之前的指令，或到一个分支指令的末尾。\n\n- **BB1**：从首指令 $1$ 开始。它包括指令 $1, 2, 3, 4, 5$。它以一个条件分支结束。\n- **BB2**：从首指令 $6$ 开始。它包括指令 $6, 7$。它以一个无条件分支结束。\n- **BB3**：从首指令 $8$ 开始。它只包括指令 $8$。下一条指令 $9$ 是一个首指令，所以这个块在这里终止，控制流顺序执行到下一个块。\n- **BB4**：从首指令 $9$ 开始。它只包括指令 $9$。程序片段在此结束。\n\n因此，对于表达式 `(f()  g())`，总共有 $4$ 个基本块。\n\n**情况 2：`(f()  g())` (逻辑与)**\n\n逻辑与运算符 `` 表现出短路行为。如果 `f()` 的求值结果为假（值为 $0$），第二个操作数 `g()` 就不会被求值，控制流会直接跳转到条件的 `else` 部分。与位运算的情况相比，这引入了一个额外的分支。\n\n其控制流可以表示为：\n\n$1$. `x := 0`\n$2$. `t_1 := f()`\n$3$. `if t_1 == 0 goto L_ELSE` (短路条件分支)\n$4$. `t_2 := g()`\n$5$. `if t_2 == 0 goto L_ELSE` (条件的第二部分)\n$6$. `x := 1`\n$7$. `goto L_END` (无条件分支)\n$8$. `L_ELSE: x := 2`\n$9$. `L_END: y := h(x)`\n\n应用首指令识别规则：\n- 指令 $1$ 根据规则 $1$ 是首指令。\n- 指令 $8$ (标签为 `L_ELSE`) 根据规则 $2$ 是首指令，因为它是指令 $3$ 和 $5$ 处分支的目标。\n- 指令 $9$ (标签为 `L_END`) 根据规则 $2$ 是首指令，因为它是指令 $7$ 处分支的目标。\n- 指令 $4$ 根据规则 $3$ 是首指令，因为它紧跟在指令 $3$ 的条件分支之后。\n- 指令 $6$ 根据规则 $3$ 是首指令，因为它紧跟在指令 $5$ 的条件分支之后。\n\n首指令集合是 $\\{1, 4, 6, 8, 9\\}$。\n\n- **BB1**：从首指令 $1$ 开始。它包括指令 $1, 2, 3$。它以一个条件分支结束。\n- **BB2**：从首指令 $4$ 开始。它包括指令 $4, 5$。它以一个条件分支结束。\n- **BB3**：从首指令 $6$ 开始。它包括指令 $6, 7$。它以一个无条件分支结束。\n- **BB4**：从首指令 $8$ 开始。它只包括指令 $8$。\n- **BB5**：从首指令 $9$ 开始。它只包括指令 $9$。\n\n因此，对于表达式 `(f()  g())`，总共有 $5$ 个基本块。短路求值引入了一个额外的分支，它将初始的求值块分成了两个独立的基本块。\n\n问题要求的是数对 (`BB count for (f()  g())`, `BB count for (f()  g())`)。根据我们的分析，这个数对是 $(4, 5)$。\n\n我们现在评估给出的选项：\n\nA. $(4, 5)$: 这与我们推导出的结果相符。位与 `` 情况下的基本块数量是 $4$，逻辑与 `` 情况下的基本块数量是 $5$。**正确**。\n\nB. $(5, 4)$: 这颠倒了两种情况的正确计数。**不正确**。\n\nC. $(4, 4)$: 这正确地识别了位与情况下的计数，但未能解释由逻辑与的短路逻辑创建的额外基本块。**不正确**。\n\nD. $(5, 5)$: 这正确地识别了逻辑与情况下的计数，但错误地高估了非短路位与的块数。**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在，让我们来应对一个更复杂的挑战：分析一个带有多种控制流机制的 `switch` 语句。`switch` 语句功能强大，但其 `case` 的贯穿（fall-through）、`break`、`default` 和 `goto` 跳转的组合会产生错综复杂的控制路径。这个练习旨在证明，即使面对如此复杂的代码结构，我们之前学习的首指令识别规则依然有效。通过系统地应用这些规则，你可以将看似混乱的控制流分解为一组定义清晰的基本块，从而揭示其内在的结构 。",
            "id": "3624092",
            "problem": "考虑以下 C 风格的函数，它使用了一个 switch 语句，其中包含了贯穿 (fall-through) 的 case、一个 default 分支，以及一个跳转到 switch 外部标签的 case。你的任务是识别基本块，并计算最终的控制流图包含多少个基本块。\n\n请使用以下基本原则：\n- 基本块是指一个指令的最大序列，它只有一个入口和一个出口，不能从序列的中间分支进入或分支出去。\n- 首指令由标准规则确定：程序的第一条指令是首指令；任何作为跳转目标的指令（包括 switch 的每个 case 和 default 标签，以及任何显式标签如 goto 目标）是首指令；任何紧跟在跳转指令（如 goto、break、return 或 switch 分派）之后的指令是首指令。\n- 对于 switch 语句，将每个 case 和 default 视为多路分支的可能目标。在同一条首指令之前的相邻标签表示进入同一基本块的多个入口。switch 内部的 break 会将控制权转移到 switch 之后的第一条指令，因此该指令是首指令。\n\n分析以下函数：\n\n```c\nvoid f(int $x$, int *$p$) {\n  int $y$ = $0$;\n  switch ($x$) {\n    case $0$:\n      $y$ = $y$ + $1$;\n      /* fall-through */\n    case $1$:\n      *$p$ = $y$;\n      goto $\\mathrm{Lout}$;\n    case $2$:\n      $y$ = $y$ + $2$;\n      break;\n    case $3$:\n    case $4$:\n      $y$ = $y$ + $x$;\n      /* fall-through to default */\n    default:\n      $y$ = -$y$;\n      if ($x$  $0$) break;\n      $y$ = $y$ + $1$;\n      /* no break: falls out of switch */\n  }\n  $y$ = $y$ \\times $2$;\n$\\mathrm{Lout}$:\n  $y$ = $y$ - $1$;\n}\n```\n\n指令：\n- 应用上述定义来识别首指令并构成基本块。\n- 密切注意贯穿行为，包括 case 之间的贯穿、从 default 到 switch 之后的贯穿，以及跳转到 switch 外部 $\\mathrm{Lout}$ 的行为。\n- 然后，计算生成的控制流图（CFG）中基本块的总数。将最终答案表示为单个整数。不需要四舍五入，也不需要单位。",
            "solution": "该问题要求我们确定给定 C 风格函数的控制流图（CFG）中基本块的数量。这个过程包括两个主要步骤：识别首指令，然后根据这些首指令将指令序列划分为基本块。一个基本块从一个首指令开始，包含所有后续指令，直到但不包括下一个首指令，或者直到一个跳转指令的末尾。\n\n识别首指令的规则如下：\n1.  函数中的第一条指令是首指令。\n2.  任何作为跳转目标的指令是首指令。\n3.  任何紧跟在跳转指令之后的指令是首指令。\n\n让我们通过系统地应用这些规则来分析所提供的函数并识别所有的首指令。为清晰起见，我们将函数的指令表示为一个线性序列。\n\n函数代码是：\n```c\nvoid f(int $x$, int *$p$) {\n  1: int $y$ = $0$;\n  2: switch ($x$) {\n  3:   case $0$:\n       $y$ = $y$ + $1$;\n  4:   case $1$:\n       *$p$ = $y$;\n  5:   goto $\\mathrm{Lout}$;\n  6:   case $2$:\n       $y$ = $y$ + $2$;\n  7:   break;\n  8:   case $3$:\n  9:   case $4$:\n       $y$ = $y$ + $x$;\n 10:   default:\n       $y$ = -$y$;\n 11:   if ($x$ > $0$) break;\n 12:   $y$ = $y$ + $1$;\n 13: }\n 14: $y$ = $y$ \\times $2$;\n 15: $\\mathrm{Lout}$:\n 16: $y$ = $y$ - $1$;\n 17: }\n```\n\n我们按如下方式识别首指令：\n\n1.  **指令 `int $y$ = $0$;` 是一个首指令。**\n    这是因为它是函数的第一条指令（规则 1）。这标志着第一个基本块的开始。\n\n2.  **指令 `$y = y + 1$;`（在 `case $0$:` 之后）是一个首指令。**\n    该指令是 `switch` 语句 `case $0$` 的目标。`switch` 是一个多路跳转，`case` 标签标记了此跳转的目标（规则 2）。\n\n3.  **指令 `*$p$ = $y$;`（在 `case $1$:` 之后）是一个首指令。**\n    这是 `switch` 语句 `case $1$` 的目标（规则 2）。\n\n4.  **指令 `$y = y + 2$;`（在 `case $2$:` 之后）是一个首指令。**\n    这是 `switch` 语句 `case $2$` 的目标（规则 2）。\n\n5.  **指令 `$y = y + x$;`（在 `case $3$:` 和 `case $4$:` 之后）是一个首指令。**\n    这是 `switch` 语句 `case $3$` 和 `case $4$` 的共同目标（规则 2）。\n\n6.  **指令 `$y = -$y$;`（在 `default:` 之后）是一个首指令。**\n    这是 `switch` 语句 `default` 分支的目标（规则 2）。\n\n7.  **指令 `$y = y \\times 2$;` 是一个首指令。**\n    该指令是 `break;` 语句（来自 `case $2$` 和条件 `if`）的目标。`switch` 内部的 `break` 会跳转到紧跟在 `switch` 块之后的指令。因此，该指令是一个跳转目标（规则 2）。\n\n8.  **指令 `$y = y - 1$;`（在标签 `$\\mathrm{Lout}$:` 处）是一个首指令。**\n    该指令是 `goto $\\mathrm{Lout}$;` 语句的目标（规则 2）。\n\n9.  **指令 `$y = y + 1$;`（在 `if ($x > 0$) break;` 之后）是一个首指令。**\n    该指令紧跟在条件跳转 `if ($x > 0$) break;` 之后。根据规则 3，跳转指令之后的指令是首指令。\n\n识别了所有首指令后，我们现在可以将代码划分为基本块。每个块从一个首指令开始，结束于下一个首指令之前或一个跳转指令处。\n\n*   **块 $1$**:\n    从 `int $y$ = $0$;` (首指令 1) 开始。\n    包含：`int $y$ = $0$;`，`switch ($x$)`。\n    结束于多路跳转 `switch ($x$)`。\n\n*   **块 $2$**:\n    从 `$y = y + 1$;` (首指令 2) 开始。\n    包含：`$y = y + 1$;`。\n    通过贯穿到下一条指令（即首指令 3）来结束。\n\n*   **块 $3$**:\n    从 `*$p$ = $y$;` (首指令 3) 开始。\n    包含：`*$p$ = $y$;`，`goto $\\mathrm{Lout}$;`。\n    结束于无条件跳转 `goto`。\n\n*   **块 $4$**:\n    从 `$y = y + 2$;` (首指令 4) 开始。\n    包含：`$y = y + 2$;`，`break;`。\n    结束于无条件跳转 `break`。\n\n*   **块 $5$**:\n    从 `$y = y + x$;` (首指令 5) 开始。\n    包含：`$y = y + x$;`。\n    通过贯穿到 `default` 分支结束，其第一条指令是首指令 6。\n\n*   **块 $6$**:\n    从 `$y = -$y$;` (首指令 6) 开始。\n    包含：`$y = -$y$;`，`if ($x > 0$) break;`。\n    结束于条件跳转 `if`。\n\n*   **块 $7$**:\n    从 `$y = y + 1$;` (首指令 9) 开始。\n    包含：`$y = y + 1$;`。\n    通过贯穿出 `switch` 语句到下一条指令（即首指令 7）来结束。\n\n*   **块 $8$**:\n    从 `$y = y \\times 2$;` (首指令 7) 开始。\n    包含：`$y = y \\times 2$;`。\n    通过贯穿到标签 `$\\mathrm{Lout}$` 处的指令（即首指令 8）来结束。\n\n*   **块 $9$**:\n    从 `$y = y - 1$;` (首指令 8) 开始。\n    包含：`$y = y - 1$;`。\n    结束于函数末尾的隐式返回。\n\n通过计算不同的首指令（每个首指令对应一个基本块的开始），我们发现有 9 个首指令。这意味着指令序列被划分为 9 个基本块。\n首指令是：\n1. `int $y$ = $0$;`\n2. `$y = y + 1$;`\n3. `*$p$ = $y$;`\n4. `$y = y + 2$;`\n5. `$y = y + x$;`\n6. `$y = -$y$;`\n7. `$y = y \\times 2$;`\n8. `$y = y - 1$;`\n9. `$y = y + 1$;` (在 `if` 之后的那一个)\n\n所有这些首指令都开始一个新的基本块。因此，基本块的总数是 9。",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}