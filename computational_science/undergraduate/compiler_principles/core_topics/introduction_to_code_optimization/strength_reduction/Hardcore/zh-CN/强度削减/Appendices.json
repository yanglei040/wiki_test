{
    "hands_on_practices": [
        {
            "introduction": "强度削减的一个基本应用是将昂贵的乘法运算替换为更快的位移和加法操作。本练习将引导你探索如何将一个常数乘法分解为一系列位移和加法指令，并比较两种不同策略的成本，从而让你深入理解编译器如何在底层优化代码执行效率。你将通过计算具体成本来量化优化的效果，体会算法选择对性能的直接影响。",
            "id": "3672269",
            "problem": "一个编译器通过将与一个正编译时常数的乘法替换为一系列左移和加法操作来进行强度削减。考虑一个具有以下成本模型的目标机器：每左移一位的成本为 $s$ 个单位，两个先前计算出的值的加法成本为 $a$ 个单位。假设初始值 $x$ 已经在一个寄存器中，成本为零，并且不允许使用减法。左移运算符 $x \\ll k$ 表示值 $2^{k} x$。\n\n你将为三个常数 $c \\in \\{\\,45,\\,75,\\,119\\,\\}$ 比较计算 $c x$ 的两种策略：\n\n- 二进制分解策略：推导出一个序列，该序列首先通过对 $x$ 进行左移来构造所有 $0 \\le i \\le \\lfloor \\log_{2}(c) \\rfloor$ 的2的幂倍数 $2^{i} x$，然后使用加法将与 $c$ 的二进制展开中的1位相对应的子集求和。从第一性原理（二进制表示和操作计数）出发，推导此策略的总成本。\n\n- 最小加法链策略：推导出一个移位-加法序列，通过重用中间结果、在有利时对 $c$ 进行因式分解以及策略性地应用左移，来最小化加法总数。使用二进制表示的基本性质（例如，非2的幂的常数至少需要一次加法）以及在没有减法的情况下必须形成所需的非2的幂中间值的必要性，来证明其最小性。\n\n使用具体的成本参数 $s = 1$ 和 $a = 2$。对于每个常数 $c$，计算二进制分解策略的成本和你的最小加法链策略的成本，并报告该 $c$ 的节省成本，即二者之差（二进制分解成本减去最小加法链成本）。最后，将所有三个常数的节省成本相加，并将这个单一数字作为你的最终答案。最终节省的成本以原始成本计数（无量纲）表示。无需四舍五入。",
            "solution": "问题要求在给定特定操作成本模型的情况下，对于三个不同的常数 $c$，计算 $c x$ 时，使用最小加法链策略相比于二进制分解策略所实现的总节省成本。\n\n首先，我们来形式化定义成本模型和两种策略。\n\n**成本模型：**\n-   左移一位的成本为 $s$。题目指定 $s=1$。\n-   两个先前计算出的值的加法成本为 $a$。题目指定 $a=2$。\n-   初始值 $x$ 可用，成本为零。\n-   不允许使用减法。\n-   操作 $y \\ll k$ 计算 $2^k y$。题目说明“每左移一位的成本为 $s$ 个单位”，这意味着操作 $y \\ll k$ 被实现为 $k$ 次连续的单位左移。我们必须假设这些移位作用于值 $y$，如果 $y$ 是一个中间结果，则不一定能从对 $x$ 的移位链接而来。因此，$y \\ll k$ 的成本是 $k \\times s$。当 $s=1$ 时，成本为 $k$。\n\n**策略1：二进制分解策略**\n设 $c$ 为正整数常数。其二进制表示为 $c = \\sum_{i=0}^{m} b_i 2^i$，其中 $m = \\lfloor \\log_{2}(c) \\rfloor$ 且 $b_i \\in \\{0, 1\\}$。\n该策略分为两个阶段：\n1.  **构造2的幂**：“构造所有 $0 \\le i \\le m$ 的2的幂倍数 $2^i x$”。最高效的方法是顺序进行：\n    -   $v_0 = x$ (成本 $0$)\n    -   $v_1 = v_0 \\ll 1 = 2x$ (成本 $s$)\n    -   $v_2 = v_1 \\ll 1 = 4x$ (成本 $s$)\n    -   ...\n    -   $v_m = v_{m-1} \\ll 1 = 2^m x$ (成本 $s$)\n    这将生成所有必要的幂 $\\{2^1 x, 2^2 x, \\dots, 2^m x\\}$。此阶段的总成本为 $m \\times s$。\n2.  **求和**：将与 $c$ 的二进制展开中的1位相对应的 $\\{2^i x\\}$ 子集求和。设 $b(c)$ 为 $c$ 的二进制表示中置位（1）的数量（也称为汉明权重或置位计数）。我们需要对 $b(c)$ 个项求和。对 $k$ 个项求和需要 $k-1$ 次加法。此阶段的成本为 $(b(c) - 1) \\times a$。\n\n二进制分解策略的总成本 $C_B(c)$ 为：\n$$C_B(c) = m \\times s + (b(c) - 1) \\times a$$\n当 $s=1$ 和 $a=2$ 时：\n$$C_B(c) = \\lfloor \\log_{2}(c) \\rfloor + 2(b(c) - 1)$$\n\n**策略2：最小加法链策略**\n此策略旨在通过重用中间结果并利用 $c$ 的数论性质（如因式分解），找到一个计算 $c x$ 的最优移位和加法序列。目标是找到一个序列，其总成本 $C_M(c)$ 最小。我们必须证明所找到序列的最小性。与一个非2的幂的常数相乘必须至少涉及一次加法。\n\n我们现在分析每个常数 $c \\in \\{45, 75, 119\\}$。\n\n**情况1：$c = 45$**\n\n1.  **二进制分解成本 ($C_B(45)$)**:\n    -   45的二进制表示为 $101101_2$。\n    -   $45 = 32 + 8 + 4 + 1 = 2^5 + 2^3 + 2^2 + 2^0$。\n    -   $m = \\lfloor \\log_{2}(45) \\rfloor = 5$。\n    -   置位数为 $b(45) = 4$。\n    -   $C_B(45) = m \\cdot s + (b(45)-1) \\cdot a = 5 \\cdot 1 + (4-1) \\cdot 2 = 5 + 6 = 11$。\n\n2.  **最小加法链成本 ($C_M(45)$)**:\n    -   我们可以将 $45$ 因式分解为 $45 = 5 \\times 9$。这建议先计算 $5x$，然后将结果乘以 $9$。\n    -   计算 $y = 5x$：$y = x + 4x = x + (x \\ll 2)$。\n        -   `t1 = x  2` (成本 $2s=2$)\n        -   `y = x + t1` (成本 $a=2$)\n        -   计算 $5x$ 的成本为 $2s+a = 4$。\n    -   计算 $45x = 9y$：$9y = y + 8y = y + (y \\ll 3)$。\n        -   `t2 = y  3` (成本 $3s=3$)\n        -   `res = y + t2` (成本 $a=2$)\n        -   从 $y$ 计算 $9y$ 的成本为 $3s+a = 5$。\n    -   总成本是每一步成本的总和：$C_M(45) = (2s+a) + (3s+a) = 5s+2a = 5(1)+2(2) = 9$。\n    -   **最小性证明**：要生成一个非2的幂的倍数，至少需要一次加法。$45$ 不是两个2的幂的和，所以如果我们只对 $x$ 的移位版本进行相加，一次加法是不够的。像找到的这个包含两次加法的序列，是最小性的候选者。其成本为 $9$。另一种因式分解 $45 = 3 \\times 15$ 会导致成本为 $10$。其他组合，如 $45x=32x+13x$，则成本更高。成本 $9$ 来自于两次加法和总共 $5$ 次单位左移。这比二进制策略的成本 $11$ 有所改进，并且广泛的搜索证实它是最优的。\n\n3.  **c=45时的节省成本**:\n    -   Savings$(45) = C_B(45) - C_M(45) = 11 - 9 = 2$。\n\n**情况2：$c = 75$**\n\n1.  **二进制分解成本 ($C_B(75)$)**:\n    -   75的二进制表示为 $1001011_2$。\n    -   $75 = 64 + 8 + 2 + 1 = 2^6 + 2^3 + 2^1 + 2^0$。\n    -   $m = \\lfloor \\log_{2}(75) \\rfloor = 6$。\n    -   置位数为 $b(75) = 4$。\n    -   $C_B(75) = m \\cdot s + (b(75)-1) \\cdot a = 6 \\cdot 1 + (4-1) \\cdot 2 = 6 + 6 = 12$。\n\n2.  **最小加法链成本 ($C_M(75)$)**:\n    -   我们将 $75$ 因式分解为 $75 = 3 \\times 25 = 3 \\times 5 \\times 5$。\n    -   计算 $y = 3x$：$y = x + (x \\ll 1)$。\n        -   成本：$s+a=1+2=3$。\n    -   计算 $z = 5y$：$z = y + (y \\ll 2)$。\n        -   从 $y$ 计算的成本：$2s+a=2+2=4$。\n    -   计算 $75x = 5z$：$5z = z + (z \\ll 2)$。\n        -   从 $z$ 计算的成本：$2s+a=2+2=4$。\n    -   总成本是每一步成本的总和：$C_M(75) = (s+a) + (2s+a) + (2s+a) = 5s + 3a = 5(1) + 3(2) = 11$。\n    -   **最小性证明**：此计算涉及三次加法。总移位成本为 $1s+2s+2s=5s$。总成本为 $11$。这优于二进制策略的成本 $12$。任何与形如 $2^k+1$ 的奇数（如 $3=2^1+1$ 和 $5=2^2+1$）的乘法都可以用一次加法完成。由于 $75=3 \\times 5 \\times 5$，三次加法似乎是最小的。其他的分解方式，如 $75x = 15x + (15x \\ll 2)$，也会得到成本 $11$。成本 $11$ 似乎是最小的。\n\n3.  **c=75时的节省成本**:\n    -   Savings$(75) = C_B(75) - C_M(75) = 12 - 11 = 1$。\n\n**情况3：$c = 119$**\n\n1.  **二进制分解成本 ($C_B(119)$)**:\n    -   119的二进制表示为 $1110111_2$。\n    -   $119 = 64 + 32 + 16 + 4 + 2 + 1 = 2^6+2^5+2^4+2^2+2^1+2^0$。\n    -   $m = \\lfloor \\log_{2}(119) \\rfloor = 6$。\n    -   置位数为 $b(119) = 6$。\n    -   $C_B(119) = m \\cdot s + (b(119)-1) \\cdot a = 6 \\cdot 1 + (6-1) \\cdot 2 = 6 + 10 = 16$。\n\n2.  **最小加法链成本 ($C_M(119)$)**:\n    -   我们将 $119$ 因式分解为 $119 = 7 \\times 17$。\n    -   计算 $y=7x$。由于不允许减法，$7x=8x-x$ 不是一个可选方案。我们可以使用 $7x = x+6x = x+(3x \\ll 1)$。\n        -   计算 $3x$：$x + (x \\ll 1)$。成本 $s+a=3$。\n        -   从 $3x$ 计算 $7x$：$y = x + ((x+(x \\ll 1)) \\ll 1)$。这可以分步进行：\n            1. `t1 = x  1` (成本 `s=1`)\n            2. `t2 = x + t1` (`3x`) (成本 `a=2`)\n            3. `t3 = t2  1` (`6x`) (成本 `s=1`)\n            4. `y = x + t3` (`7x`) (成本 `a=2`)\n        -   计算 $7x$ 的成本为 $2s+2a = 2+4=6$。\n    -   计算 $119x = 17y$：$17y = y + 16y = y + (y \\ll 4)$。\n        -   从 $y$ 计算的成本：$4s+a=4+2=6$。\n    -   总成本：$C_M(119) = (\\text{计算 } 7x \\text{ 的成本}) + (\\text{计算 } 17y \\text{ 的成本}) = (2s+2a)+(4s+a) = 6s+3a = 6(1)+3(2) = 12$。\n    -   **最小性证明**：该序列使用了 $3$ 次加法和总共 $6$ 次单位左移。成本为 $12$，比 $16$ 节省了很多。常数 $7$ 不能通过一次加法形成，至少需要两次。常数 $17$ 是 $2^4+1$ 的形式，需要一次加法。因此，基于因式分解 $7 \\times 17$ 的序列至少需要 $2+1=3$ 次加法。我们的方法使用了 $3$ 次加法，因此其加法次数是最小的。总成本 $12$ 是最小的。\n\n3.  **c=119时的节省成本**:\n    -   Savings$(119) = C_B(119) - C_M(119) = 16 - 12 = 4$。\n\n**总节省成本**\n总节省成本是每个常数的节省成本之和：\n总节省成本 = Savings$(45) +$ Savings$(75) +$ Savings$(119)$\n总节省成本 = $2 + 1 + 4 = 7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "在强度削减中，一个更高级但非常强大的技术是用乘法和位移来代替昂贵的整数除法。这个看似“魔术”般的转换背后是严谨的数学推导。本练习将带你从第一性原理出发，推导出一个用于替换“除以10”的“魔数”乘子和相应的位移量，并证明其在整个无符号32位整数范围内的正确性，揭示这一关键优化技术背后的秘密。",
            "id": "3672258",
            "problem": "你正在一个32位架构的系统程序中优化一个循环，其中所有整数值都表示为32位无符号整数。该循环为 $x \\in \\{0,1,\\dots,2^{32}-1\\}$ 重复计算无符号整数商 $y = \\left\\lfloor x / 10 \\right\\rfloor$。为了降低成本，你考虑进行强度削减：将除以编译时常量的除法替换为乘以一个预计算的常量和一次右移。乘法在64位累加器中执行，以便在移位前可以得到完整的64位乘积。\n\n任务：\n- 精确说明变换\n$$\n\\left\\lfloor \\frac{x}{10} \\right\\rfloor \\;\\;\\text{替换为}\\;\\; \\left\\lfloor \\frac{x\\cdot M}{2^{s}} \\right\\rfloor\n$$\n在何种情况下可以安全使用，以及在真实的中央处理器（CPU）上通常何时是有益的。\n- 从第一性原理出发，推导出最小的移位数 $s \\in \\mathbb{N}$ 和相应的整数乘数 $M \\in \\mathbb{N}$，使得对于所有 $x \\in \\{0,1,\\dots,2^{32}-1\\}$，\n$$\n\\left\\lfloor \\frac{x}{10} \\right\\rfloor \\;=\\; \\left\\lfloor \\frac{x\\cdot M}{2^{s}} \\right\\rfloor,\n$$\n假设中间乘积 $x\\cdot M$ 为64位，并进行 $s$ 位的逻辑右移。\n- 仅从关于商-余数分解 $x = 10q + r$（其中 $q = \\left\\lfloor x/10 \\right\\rfloor$ 且 $r \\in \\{0,1,\\dots,9\\}$）的基本事实以及向下取整函数的性质出发，通过建立与 $x$ 无关的界限来证明其正确性，这些界限对范围内的所有 $x$ 都意味着上述等式成立。\n\n以数对 $(M,s)$ 的形式报告你的最终答案。不允许使用代码。你的最终数值答案必须是精确的；不需要四舍五入。",
            "solution": "问题要求分析强度削减优化，该优化将无符号整数除以一个常量（具体为 $\\left\\lfloor x/10 \\right\\rfloor$）替换为乘以一个常量 $M$ 和右移 $s$ 位。$x$ 的定义域是32位无符号整数集合 $\\{0, 1, \\dots, 2^{32}-1\\}$。\n\n首先，我们讨论这种变换在什么条件下是安全和有益的。\n安全性要求满足两个条件：\n1.  数学正确性：等式 $\\left\\lfloor \\frac{x}{10} \\right\\rfloor = \\left\\lfloor \\frac{x\\cdot M}{2^{s}} \\right\\rfloor$ 必须对每个 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$ 都成立。\n2.  实现正确性：中间乘积 $x \\cdot M$ 不得溢出指定的64位累加器。由于 $x  2^{32}$，如果我们选择一个也能容纳在32位字中的乘数 $M$，即 $M  2^{32}$，那么乘积 $x \\cdot M$ 将小于 $2^{32} \\cdot 2^{32} = 2^{64}$，从而可以容纳在一个64位无符号整数中。我们的推导将得出一个这样的 $M$。\n\n如果在中央处理器（CPU）上，一次乘法和一次移位的总执行时间小于一次除法的执行时间，那么这种变换就是有益的。对于几乎所有现代处理器架构，整数除法（在延迟和吞吐量方面）都是比整数乘法和位移操作开销大得多的操作。例如，一个硬件除法操作可能需要几十个时钟周期，而乘法通常可以在一个周期内完成，或者是深度流水线化的。因此，这种强度削减几乎总是有利于性能。\n\n接下来，我们推导最小的移位数 $s \\in \\mathbb{N}$ 和相应的乘数 $M \\in \\mathbb{N}$。\n目标是找到整数常量 $M$ 和 $s$，使得对于所有 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$：\n$$ \\left\\lfloor \\frac{x}{10} \\right\\rfloor = \\left\\lfloor \\frac{x \\cdot M}{2^s} \\right\\rfloor $$\n令 $q = \\left\\lfloor \\frac{x}{10} \\right\\rfloor$。当且仅当对于所有 $x$ 都满足以下条件时，等式成立：\n$$ q \\le \\frac{x \\cdot M}{2^s}  q+1 $$\n我们希望比率 $\\frac{M}{2^s}$ 是 $\\frac{1}{10}$ 的一个良好近似。由于整数除法是截断的，我们应该从上方进行近似。让我们设 $\\frac{M}{2^s} = \\frac{1}{10} + \\epsilon$，其中 $\\epsilon$ 是某个小的正误差。\n这可以写成 $M = \\frac{2^s}{10} + \\epsilon \\cdot 2^s$。为了使 $M$ 为整数，我们可以写成 $10M = 2^s + k$，其中 $k = 10 \\cdot \\epsilon \\cdot 2^s$ 必须是一个正整数。这意味着 $10M > 2^s$。\n\n让我们分析 $q \\le \\frac{x \\cdot M}{2^s}  q+1$ 中的两个不等式。\n根据问题陈述，我们使用商-余数分解 $x = 10q+r$，其中 $r \\in \\{0, 1, \\dots, 9\\}$。\n\n1.  左不等式：$q \\le \\frac{xM}{2^s}$。\n    代入 $x=10q+r$ 和 $M=(2^s+k)/10$：\n    $$ q \\le \\frac{(10q+r)(2^s+k)}{10 \\cdot 2^s} $$\n    $$ 10q \\cdot 2^s \\le (10q+r)(2^s+k) = 10q \\cdot 2^s + 10qk + r \\cdot 2^s + rk $$\n    $$ 0 \\le 10qk + r(2^s+k) $$\n    由于 $q \\ge 0$，$r \\ge 0$，$s \\in \\mathbb{N}$，并且我们寻求 $k$ 为一个正整数，因此这个不等式总是满足的。\n\n2.  右不等式：$\\frac{xM}{2^s}  q+1$。\n    $$ \\frac{(10q+r)(2^s+k)}{10 \\cdot 2^s}  q+1 $$\n    $$ (q + \\frac{r}{10}) (1 + \\frac{k}{2^s})  q+1 $$\n    $$ q + \\frac{qk}{2^s} + \\frac{r}{10} + \\frac{rk}{10 \\cdot 2^s}  q+1 $$\n    $$ \\frac{qk}{2^s} + \\frac{r}{10} + \\frac{rk}{10 \\cdot 2^s}  1 $$\n    乘以 $10 \\cdot 2^s$ 以消除分母：\n    $$ 10qk + r \\cdot 2^s + rk  10 \\cdot 2^s $$\n    $$ k(10q+r)  (10-r) \\cdot 2^s $$\n    $$ kx  (10-r) \\cdot 2^s $$\n    这个不等式必须对所有 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$ 成立，其中 $r = x \\pmod{10}$。\n    左侧的 $kx$ 随 $x$ 增大而增大。右侧的 $(10-r) \\cdot 2^s$ 取决于 $r$。为了确保这对所有 $x$ 都成立，我们可以建立一个充分条件。对于任何给定的 $r$，当 $x$ 取可能的最大值时，不等式最严格。由于 $x  2^{32}$，一个充分条件是对于所有 $r \\in \\{0, \\dots, 9\\}$，都有 $k \\cdot 2^{32} \\le (10-r) \\cdot 2^s$。当 $r$ 最大化时，即 $r=9$ 时，右侧最小。这给出了最严格的条件：\n    $$ k \\cdot 2^{32} \\le (10-9) \\cdot 2^s = 2^s $$\n    $$ k \\le 2^{s-32} $$\n    由于 $k$ 必须是一个正整数，这意味着 $1 \\le k \\le 2^{s-32}$，这要求 $s-32 \\ge 0$，因此 $s \\ge 32$。\n\n    我们还有约束条件 $10M = 2^s+k$，意味着 $2^s+k$ 必须能被10整除。这等价于 $2^s+k \\equiv 0 \\pmod{10}$。\n    我们需要找到最小的整数 $s \\ge 32$，使得存在一个整数 $k \\ge 1$ 同时满足这两个条件。\n    让我们从 $s=32$ 开始测试 $s$ 的值：\n    - 当 $s=32$ 时：$2^{32} \\pmod{10}$。2的幂对10取模的周期是 $(2, 4, 8, 6)$，对应指数 $(1, 2, 3, 4)$ 并重复。由于32是4的倍数，$2^{32} \\equiv 6 \\pmod{10}$。条件 $2^{32}+k \\equiv 0 \\pmod{10}$ 变为 $6+k \\equiv 0 \\pmod{10}$，所以最小的正整数 $k$ 是4。现在我们检查 $k \\le 2^{s-32}$：$4 \\le 2^{32-32} = 2^0 = 1$。这是错误的。所以 $s=32$ 不是一个解。\n    - 当 $s=33$ 时：$2^{33} \\equiv 2 \\pmod{10}$。我们需要 $2+k \\equiv 0 \\pmod{10}$，所以最小的 $k$ 是8。检查：$8 \\le 2^{33-32} = 2^1 = 2$。错误。\n    - 当 $s=34$ 时：$2^{34} \\equiv 4 \\pmod{10}$。我们需要 $4+k \\equiv 0 \\pmod{10}$，所以最小的 $k$ 是6。检查：$6 \\le 2^{34-32} = 2^2 = 4$。错误。\n    - 当 $s=35$ 时：$2^{35} \\equiv 8 \\pmod{10}$。我们需要 $8+k \\equiv 0 \\pmod{10}$，所以最小的 $k$ 是2。检查：$2 \\le 2^{35-32} = 2^3 = 8$。这是正确的。\n\n    因此，最小的整数移位数是 $s=35$。相应的乘数 $M$ 用 $k=2$ 求得：\n    $$ 10M = 2^{35} + 2 $$\n    $$ M = \\frac{2^{35} + 2}{10} = \\frac{34359738368 + 2}{10} = \\frac{34359738370}{10} = 3435973837 $$\n    这个 $M$ 的值小于 $2^{32}-1=4294967295$，所以它可以容纳在一个32位无符号整数寄存器中。\n\n最后，我们证明数对 $(M, s)=(3435973837, 35)$ 的正确性。\n我们必须验证对于所有 $x \\in \\{0, \\dots, 2^{32}-1\\}$，条件 $kx  (10-r)2^s$ 在 $k=2, s=35, r=x\\pmod{10}$ 的情况下成立。条件是 $2x  (10-r)2^{35}$。\n对于给定的 $r \\in \\{0, \\dots, 9\\}$，当 $x$ 取具有该余数的最大值 $x_{max, r}$ 时，不等式最受约束。当 $r=9$ 时，右侧最小。所以需要检查的整体最坏情况是 $r=9$：\n$$ 2 \\cdot x_{max, 9}  (10-9) \\cdot 2^{35} = 2^{35} $$\n$$ x_{max, 9}  2^{34} $$\n最大的32位无符号整数是 $2^{32}-1$。$2^{32}-1 = 4294967295$，它除以10的余数是5。小于 $2^{32}$ 且余数为9的最大 $x$ 是 $2^{32}-1 - ((5-9)\\pmod{10}) = 2^{32}-1 - 6 = 2^{32}-7$。\n不等式变为 $2^{32}-7  2^{34}$，这显然是正确的。由于这个最严格的情况成立，所有其他不同 $r$ 值的案例也将成立，因为左侧会更小，而右侧会更大。\n\n我们还必须验证中间乘积 $x \\cdot M$ 不超过64位的容量，即 $x \\cdot M  2^{64}$。当 $x_{max} = 2^{32}-1$ 时，乘积最大。\n$$ (2^{32}-1) \\cdot M = (2^{32}-1) \\cdot \\frac{2^{35}+2}{10} $$\n我们需要证明这小于 $2^{64}$。\n$$ (2^{32}-1)(2^{35}+2)  10 \\cdot 2^{64} $$\n$$ 2^{67} + 2 \\cdot 2^{32} - 2^{35} - 2  10 \\cdot 2^{64} $$\n$$ 8 \\cdot 2^{64} + 2^{33} - 8 \\cdot 2^{32} - 2  10 \\cdot 2^{64} $$\n$$ 8 \\cdot 2^{64} - 6 \\cdot 2^{32} - 2  10 \\cdot 2^{64} $$\n这可以简化为 $-6 \\cdot 2^{32} - 2  2 \\cdot 2^{64}$，这显然是正确的。\n中间乘积不会溢出。该变换是安全和正确的。\n\n推导出的值为 $M=3435973837$ 和 $s=35$。",
            "answer": "$$\n\\boxed{(3435973837, 35)}\n$$"
        },
        {
            "introduction": "任何编译优化都必须以保证程序的原始语义不被改变为前提，这是一个核心原则。本练习提供了一个典型但充满陷阱的例子：用位与（``）操作替换取模（`%`）操作。你将分析为什么这个看似等价的优化在不同编程语言以及处理负数时可能会失效，从而深刻理解编译器设计者在进行代码转换时必须严格遵守语言规范的重要性。",
            "id": "3672310",
            "problem": "一位编译器设计者考虑进行一项强度削减优化，在一个紧凑循环中，将计算 `$i \\% 8$` 替换为位掩码 `$i \\ \\ \\ 7$`，以避免除法运算。请判断在何种语言和有无符号条件下，这种替换能够保持程序语义。请从基本定义出发：在数学中，对于任意整数 $i$ 和正模数 $m$，余数 $r$ 是满足 $0 \\le r  m$ 且 $i \\equiv r \\pmod{m}$ 的唯一整数；在主流编程语言中，余数运算符可能根据向零取整的除法（truncated division）或向下取整的除法（floor division）来定义，这会影响 $r$ 的符号。另外，回想一下，对于二进制表示，用 $2^k - 1$ 进行掩码操作会提取表示的低 $k$ 位。分析这些定义与有无符号性以及语言的整数语义之间的相互作用。选择所有正确的陈述。\n\nA. 在 C（自 C99 标准起）和 C++（自 C++11 标准起）中，将 `$i \\% 8$` 替换为 `$i \\ \\ \\ 7$` 对所有整型类型（包括负值）都是安全的，因为这两个操作都是在二进制补码表示上定义的。\n\nB. 在 C 和 C++ 中，如果 $i$ 是一个无符号类型，或者 $i$ 是一个有符号类型且在运行时已知 $i \\ge 0$，那么将 `$i \\% 8$` 替换为 `$i \\ \\ \\ 7$` 是安全的。\n\nC. 在 Java（运行于 Java 虚拟机 (JVM) 上）中，对于负数 $i$，该替换是不安全的，因为 `$i \\% 8$` 可能是负数，而 `$i \\ \\ \\ 7$` 的结果总是在 $[0,7]$ 范围内。\n\nD. 在 Python 中，替换 `$i \\% 8 \\to i \\ \\ \\ 7$` 对所有整数都是安全的，因为 Python 将 `$i \\% 8$` 定义为满足 $0 \\le r  8$ 和 $i \\equiv r \\pmod{8}$ 的唯一 $r$，这与低 3 位 `$i \\ \\ \\ 7$` 的值相等。\n\nE. 在 C 和 C++ 中，当 $i$ 是一个有符号负整数时，计算 `$i \\ \\ \\ 7$` 会触发未定义行为 (Undefined Behavior, UB)，这就是为什么在这些情况下替换是不安全的。",
            "solution": "用户希望我分析一项编译器优化的有效性，具体来说就是将计算 `$i \\% 8$` 替换为 `$i \\ \\ \\ 7$` 的强度削减。我将首先验证问题陈述的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **优化：** 一项将 `$i \\% 8$` 替换为 `$i \\ \\ \\ 7$` 的强度削减。\n- **上下文：** 发生在紧凑循环内部。\n- **目标：** 确定在何种语言和有无符号条件下，这种替换能够保持程序语义。\n- **余数的数学定义：** 对于一个整数 $i$ 和正模数 $m$，余数 $r$ 是满足 $0 \\le r  m$ 且 $i \\equiv r \\pmod{m}$ 的唯一整数。\n- **编程语言中的余数：** `%` 运算符的行为可以基于向零取整的除法或向下取整的除法来定义。\n- **按位与操作：** 使用 $2^k - 1$ 进行掩码操作会提取一个数二进制表示的低 $k$ 位。此处 $k=3$，所以 `$i \\ \\ \\ 7$` (其中 $7 = 2^3 - 1$) 提取 $i$ 的低 3 位。\n\n**步骤 2：使用已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于计算机科学，特别是编译器设计、计算机算术和编程语言语义。所提供的关于余数、按位与以及数学和编程语言余数约定之间区别的定义都是标准且正确的。\n- **适定性：** 这个问题是适定的（well-posed）。它要求在各种明确定义的条件下（不同的编程语言、有符号 vs. 无符号类型）分析两个表达式的等价性。通过查阅语言标准和计算机算术原理，可以确定一组明确的正确和不正确的条件。\n- **客观性：** 问题陈述是客观、精确的，没有主观论断。它引用了特定的语言标准（C99、C++11）和通用平台（JVM）。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。它提出了一个编译器理论中标准的、不简单的分析任务。我将继续进行详细的推导和对选项的评估。\n\n### 推导与分析\n\n问题的核心是比较余数运算符（`%`）和按位与运算符（``）的语义。\n\n**对 `$i \\ \\ \\ 7$` 的分析**\n表达式 `$i \\ \\ \\ 7$` 对整数 $i$ 和整数 $7$ 执行按位与操作。在二进制中，7 表示为 `...000111`。此操作有效地将 $i$ 的二进制表示中除了最后三位之外的所有位都清零。结果总是一个在 $[0, 7]$ 范围内的整数。\n对于任何整数 $i$（正数、负数或零），如果我们以二进制补码（现代系统中带符号整数的标准表示法）来解释其位模式，`$i \\ \\ \\ (2^k - 1)$` 的值是一个非负整数 $r$，满足 $i \\equiv r \\pmod{2^k}$。对于我们 $k=3$ 的情况，`$i \\ \\ \\ 7$` 计算出一个值 $r \\in [0, 7]$，使得 $i \\equiv r \\pmod{8}$。这与问题陈述中提供的余数的数学定义完全一致。\n\n**对 `$i \\% 8$` 的分析**\n余数运算符 `%` 的行为取决于编程语言的定义，特别是对于负操作数。\n\n1.  **对于非负的 `i` ($i \\ge 0$)：**\n    对于任何非负整数 $i$，所有相关编程语言（C、C++、Java、Python）都将 `$i \\% 8$` 定义为标准余数，其值在 $[0, 7]$ 范围内。这与 `$i \\ \\ \\ 7$` 的结果相同。因此，对于 $i \\ge 0$，替换总是安全的。\n\n2.  **对于负的 `i` ($i  0$)：**\n    这是语言规范出现差异的地方。其行为通常与整数除法的定义相关联。\n    -   **向零取整的除法（Truncated Division）（如 C99、C++11、Java）：** 整数除法 `a / b` 的结果向零取整。余数由恒等式 `(a / b) * b + a % b == a` 定义。\n        我们以 $i = -1$ 和除数 $m=8$ 为例。\n        - 除法：`(-1) / 8 = 0`（将 `-0.125` 向零取整）。\n        - 恒等式：`(0 * 8) + (-1 % 8) == -1`。\n        - 结果：这意味着 `(-1) % 8 = -1`。\n        然而，`(-1)  7` 是 $7$。由于 $-1 \\ne 7$，在这些语言中，对于负数 $i$，该替换在语义上是不正确的。通常，对于 $i  0$，`$i \\% 8$` 将产生一个在 $[-7, 0]$ 范围内的结果，而 `$i \\ \\ \\ 7$` 产生一个在 $[0, 7]$ 范围内的结果。\n\n    -   **向下取整的除法（Floor Division）（如 Python）：** 整数除法 `a // b` 的结果向下取整（朝负无穷方向舍入）。余数由恒等式 `(a // b) * b + a % b == a` 定义。此定义的一个特性是余数 `a % b` 的符号与除数 `b` 的符号相匹配。\n        我们以 $i = -1$ 和除数 $m=8$ 为例。\n        - 除法：`(-1) // 8 = -1`（将 `-0.125` 向下取整）。\n        - 恒等式：`(-1 * 8) + (-1 % 8) == -1`，所以 `-8 + (-1 % 8) == -1`。\n        - 结果：这意味着 `(-1) % 8 = 7`。\n        这与 `(-1)  7 = 7` 的结果相匹配。通常，对于正除数 $m$，Python 的 `$i \\% m$` 操作产生一个在 $[0, m-1]$ 范围内的结果。这就是数学上的余数，当 $m$ 是 2 的幂时，它与 `$i \\ \\ \\ (m-1)$` 的结果相同。\n\n有了这个基础，我们来逐一评估每个选项。\n\n### 逐项分析\n\n**A. 在 C（自 C99 标准起）和 C++（自 C++11 标准起）中，将 $i \\% 8$ 替换为 $i \\ \\ \\ 7$ 对所有整型类型，包括负值，都是安全的，因为这两个操作都是在二进制补码表示上定义的。**\n这个陈述是错误的。如上所述，对于负值 $i$，C99/C++11 标准规定 `$i \\% m$` 的符号与 $i$ 的符号相同。例如，`(-1) \\% 8` 是 $-1$。相比之下，`(-1)  7` 是 $7$。结果不相等。所给出的理由——两个操作都定义在二进制补码表示上——是一个不合逻辑的推论；它们都有明确定义这一事实并不意味着它们是等价的。\n**结论：错误。**\n\n**B. 在 C 和 C++ 中，如果 $i$ 是一个 `unsigned` 类型，或者 $i$ 是一个 `signed` 类型且在运行时已知 $i \\ge 0$，那么将 $i \\% 8$ 替换为 $i \\ \\ \\ 7$ 是安全的。**\n这个陈述是正确的。\n- 如果 $i$ 是一个 `unsigned` 类型，其值根据定义是非负的。\n- 如果 $i$ 是一个 `signed` 类型但保证为非负（$i \\ge 0$），则适用相同的逻辑。\n对于任何非负整数 $i$，`$i \\% 8$` 和 `$i \\ \\ \\ 7$` 都计算数学上的余数，产生在 $[0, 7]$ 范围内的相同结果。因此，在这些条件下，该替换在语义上是保持不变的。\n**结论：正确。**\n\n**C. 在 Java（运行于 Java 虚拟机 (JVM) 上）中，对于负数 $i$，该替换是不安全的，因为 $i \\% 8$ 可能是负数，而 $i \\ \\ \\ 7$ 总是处于 $[0,7]$ 范围内。**\n这个陈述是正确的。Java 语言规范定义了余数运算符 `%`，使得 `(a/b)*b + (a%b)` 的结果等于 `a`。整数除法向零取整。这与 C99/C++11 中的规则相同。因此，对于负数 $i$，`$i \\% 8$` 将是非正数（例如，`(-1) \\% 8` 的结果是 $-1$）。而按位操作 `$i \\ \\ \\ 7$` 的结果总是一个非负值。因为对于负数 $i$ 结果不同，所以替换是不安全的。所给出的理由是准确的。\n**结论：正确。**\n\n**D. 在 Python 中，替换 $i \\% 8 \\to i \\ \\ \\ 7$ 对所有整数都是安全的，因为 Python 将 $i \\% 8$ 定义为满足 $0 \\le r  8$ 和 $i \\equiv r \\pmod{8}$ 的唯一 $r$，这与低 3 位 $i \\ \\ \\ 7$ 的值相等。**\n这个陈述是正确的。Python 的 `%` 运算符是基于向下取整的除法定义的，这保证了余数 `$i \\% m$` 与除数 $m$ 的符号相同。由于除数是 $8$（正数），`$i \\% 8$` 的结果总是在 $[0, 7]$ 范围内。这个定义与模 8 的数学余数定义相匹配。如前所述，按位操作 `$i \\ \\ \\ 7$` 对于任何整数 $i$ 也计算模 8 的数学余数。因此，在 Python 中，这两个表达式对所有整数都是等价的。\n**结论：正确。**\n\n**E. 在 C 和 C++ 中，当 $i$ 是一个有符号负整数时，计算 $i \\ \\ \\ 7$ 会触发未定义行为 (Undefined Behavior, UB)，这就是为什么在这些情况下替换是不安全的。**\n这个陈述是错误的。在 C 和 C++ 中，对有符号整数（包括负数）的位运算是有明确定义的。C 标准（例如 C11 §6.5.10）规定了按位与的行为。现代系统普遍使用二进制补码表示有符号整数，按位与操作只是作用于这种位级表示。例如，`(-1)  7` 是有明确定义的，其值为 $7$。在 C/C++ 中，对于负数 $i$，替换 `$i \\% 8 \\to i \\ \\ \\ 7$` 是不安全的，这是因为两个运算符的结果不同，而不是因为按位与操作本身有任何未定义行为。\n**结论：错误。**",
            "answer": "$$\\boxed{BCD}$$"
        }
    ]
}