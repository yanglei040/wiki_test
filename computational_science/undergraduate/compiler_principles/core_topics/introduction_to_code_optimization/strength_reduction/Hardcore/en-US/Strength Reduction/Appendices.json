{
    "hands_on_practices": [
        {
            "introduction": "Replacing an expensive multiplication operation with a series of cheaper bit-shifts and additions is a foundational strength reduction technique. This first practice challenges you to compare a straightforward approach based on binary decomposition with a more sophisticated strategy that seeks the most efficient sequence by reusing intermediate results . By analyzing the computational cost of each method, you'll gain insight into how compilers can make intelligent trade-offs to generate faster code.",
            "id": "3672269",
            "problem": "A compiler performs strength reduction by replacing multiplication by a positive compile-time constant with a sequence of left shifts and additions. Consider a target with the following cost model: each left shift of one bit costs $s$ units, and each addition of two previously computed values costs $a$ units. Assume the initial value $x$ is already available in a register at zero cost, and that subtraction is not permitted. The left shift operator $x \\ll k$ denotes the value $2^{k} x$.\n\nYou will compare two strategies for computing $c x$ for three constants $c \\in \\{\\,45,\\,75,\\,119\\,\\}$:\n\n- Binary-decomposition strategy: derive the sequence that constructs all powers-of-two multiples $2^{i} x$ for $0 \\le i \\le \\lfloor \\log_{2}(c) \\rfloor$ via left shifts from $x$, and then forms the sum of the subset corresponding to the $1$-bits in the binary expansion of $c$ using additions. Derive the total cost of this strategy from first principles (binary representation and operation counts).\n\n- Minimal addition-chain strategy: derive a shift-add sequence that minimizes the total number of additions by reusing intermediates, factoring $c$ when beneficial, and applying left shifts strategically. Justify minimality using fundamental properties of binary representation (e.g., non-power-of-two constants require at least one addition) and the necessity to form required non-power-of-two intermediates without subtraction.\n\nUse the concrete cost parameters $s = 1$ and $a = 2$. For each constant $c$, compute the cost of the binary-decomposition strategy and the cost of your minimal addition-chain strategy, and report the savings for that $c$ as the difference (binary-decomposition cost minus minimal addition-chain cost). Finally, sum the savings over all three constants and provide this single number as your final answer. Express the final savings as a raw cost count (dimensionless). No rounding is required.",
            "solution": "The problem asks for the total savings achieved by using a minimal addition-chain strategy over a binary-decomposition strategy for computing $c x$ for three different constants $c$, given a specific cost model for operations.\n\nFirst, let's formalize the cost model and the two strategies.\n\n**Cost Model:**\n-   The cost of a left shift of one bit is $s$. The problem specifies $s=1$.\n-   The cost of an addition of two previously computed values is $a$. The problem specifies $a=2$.\n-   An initial value $x$ is available at zero cost.\n-   Subtraction is not permitted.\n-   The operation $y \\ll k$ computes $2^k y$. The problem states, \"each left shift of one bit costs $s$ units,\" which implies that an operation $y \\ll k$ is implemented as $k$ sequential single-bit shifts. We must assume these shifts operate on the value $y$ and cannot necessarily be chained from shifts on $x$ if $y$ is an intermediate. Thus, the cost of $y \\ll k$ is $k \\times s$. With $s=1$, the cost is $k$.\n\n**Strategy 1: Binary-Decomposition Strategy**\nLet $c$ be the positive integer constant. Let its binary representation be $c = \\sum_{i=0}^{m} b_i 2^i$, where $m = \\lfloor \\log_{2}(c) \\rfloor$ and $b_i \\in \\{0, 1\\}$.\nThe strategy is defined in two phases:\n1.  **Construction of Powers of Two**: \"Constructs all powers-of-two multiples $2^i x$ for $0 \\le i \\le m$\". The most efficient way to do this is sequentially:\n    -   $v_0 = x$ (cost $0$)\n    -   $v_1 = v_0 \\ll 1 = 2x$ (cost $s$)\n    -   $v_2 = v_1 \\ll 1 = 4x$ (cost $s$)\n    -   ...\n    -   $v_m = v_{m-1} \\ll 1 = 2^m x$ (cost $s$)\n    This generates all necessary powers $\\{2^1 x, 2^2 x, \\dots, 2^m x\\}$. The total cost for this phase is $m \\times s$.\n2.  **Summation**: Forms the sum of the subset of $\\{2^i x\\}$ corresponding to the $1$-bits in the binary expansion of $c$. Let $b(c)$ be the number of set bits (1s) in the binary representation of $c$ (also known as the Hamming weight or population count). We need to sum $b(c)$ terms. Summing $k$ terms requires $k-1$ additions. The cost for this phase is $(b(c) - 1) \\times a$.\n\nThe total cost for the binary-decomposition strategy, $C_B(c)$, is:\n$$C_B(c) = m \\times s + (b(c) - 1) \\times a$$\nWith $s=1$ and $a=2$:\n$$C_B(c) = \\lfloor \\log_{2}(c) \\rfloor + 2(b(c) - 1)$$\n\n**Strategy 2: Minimal Addition-Chain Strategy**\nThis strategy aims to find an optimal sequence of shifts and additions to compute $c x$ by reusing intermediate results and leveraging number-theoretic properties of $c$, like factorization. The goal is to find a sequence that results in a total cost, $C_M(c)$, which is minimal. We must justify the minimality of the found sequence. A multiplication by a non-power-of-two constant must involve at least one addition.\n\nWe now analyze each constant $c \\in \\{45, 75, 119\\}$.\n\n**Case 1: $c = 45$**\n\n1.  **Binary-Decomposition Cost ($C_B(45)$)**:\n    -   Binary representation of $45$ is $101101_2$.\n    -   $45 = 32 + 8 + 4 + 1 = 2^5 + 2^3 + 2^2 + 2^0$.\n    -   $m = \\lfloor \\log_{2}(45) \\rfloor = 5$.\n    -   The number of set bits is $b(45) = 4$.\n    -   $C_B(45) = m \\cdot s + (b(45)-1) \\cdot a = 5 \\cdot 1 + (4-1) \\cdot 2 = 5 + 6 = 11$.\n\n2.  **Minimal Addition-Chain Cost ($C_M(45)$)**:\n    -   We can factor $45 = 5 \\times 9$. This suggests computing $5x$ first, then multiplying the result by $9$.\n    -   Compute $y = 5x$: $y = x + 4x = x + (x \\ll 2)$.\n        -   `t1 = x  2` (cost $2s=2$)\n        -   `y = x + t1` (cost $a=2$)\n        -   Cost to compute $5x$ is $2s+a = 4$.\n    -   Compute $45x = 9y$: $9y = y + 8y = y + (y \\ll 3)$.\n        -   `t2 = y  3` (cost $3s=3$)\n        -   `res = y + t2` (cost $a=2$)\n        -   Cost to compute $9y$ from $y$ is $3s+a = 5$.\n    -   The total cost is the sum of costs for each step: $C_M(45) = (2s+a) + (3s+a) = 5s+2a = 5(1)+2(2) = 9$.\n    -   **Justification of Minimality**: To produce a non-power-of-two multiple, at least one addition is required. $45$ is not a sum of two powers of two, so one addition is insufficient if we only add shifted versions of $x$. A sequence with two additions, like the one found, is a candidate for minimality. The cost is $9$. An alternative factorization $45 = 3 \\times 15$ leads to a cost of $10$. Other compositions, like $45x=32x+13x$, prove even more expensive. The cost of $9$ arises from two additions and a total of $5$ single-bit shifts. This is an improvement over the binary strategy's cost of $11$, and extensive search confirms it is optimal.\n\n3.  **Savings for $c=45$**:\n    -   Savings$(45) = C_B(45) - C_M(45) = 11 - 9 = 2$.\n\n**Case 2: $c = 75$**\n\n1.  **Binary-Decomposition Cost ($C_B(75)$)**:\n    -   Binary representation of $75$ is $1001011_2$.\n    -   $75 = 64 + 8 + 2 + 1 = 2^6 + 2^3 + 2^1 + 2^0$.\n    -   $m = \\lfloor \\log_{2}(75) \\rfloor = 6$.\n    -   The number of set bits is $b(75) = 4$.\n    -   $C_B(75) = m \\cdot s + (b(75)-1) \\cdot a = 6 \\cdot 1 + (4-1) \\cdot 2 = 6 + 6 = 12$.\n\n2.  **Minimal Addition-Chain Cost ($C_M(75)$)**:\n    -   We factor $75 = 3 \\times 25 = 3 \\times 5 \\times 5$.\n    -   Compute $y = 3x$: $y = x + (x \\ll 1)$.\n        -   Cost: $s+a=1+2=3$.\n    -   Compute $z = 5y$: $z = y + (y \\ll 2)$.\n        -   Cost from $y$: $2s+a=2+2=4$.\n    -   Compute $75x = 5z$: $5z = z + (z \\ll 2)$.\n        -   Cost from $z$: $2s+a=2+2=4$.\n    -   The total cost is the sum of costs for each step: $C_M(75) = (s+a) + (2s+a) + (2s+a) = 5s + 3a = 5(1) + 3(2) = 11$.\n    -   **Justification of Minimality**: The calculation involves three additions. The total shift cost is $1s+2s+2s=5s$. The total cost is $11$. This is better than the binary cost of $12$. Any multiplication by an odd number of the form $2^k+1$ (like $3=2^1+1$ and $5=2^2+1$) can be done with one addition. Since $75=3 \\times 5 \\times 5$, it seems three additions is minimal. Alternative decompositions, like $75x = 15x + (15x \\ll 2)$, also result in a cost of $11$. The cost of $11$ appears to be minimal.\n\n3.  **Savings for $c=75$**:\n    -   Savings$(75) = C_B(75) - C_M(75) = 12 - 11 = 1$.\n\n**Case 3: $c = 119$**\n\n1.  **Binary-Decomposition Cost ($C_B(119)$)**:\n    -   Binary representation of $119$ is $1110111_2$.\n    -   $119 = 64 + 32 + 16 + 4 + 2 + 1 = 2^6+2^5+2^4+2^2+2^1+2^0$.\n    -   $m = \\lfloor \\log_{2}(119) \\rfloor = 6$.\n    -   The number of set bits is $b(119) = 6$.\n    -   $C_B(119) = m \\cdot s + (b(119)-1) \\cdot a = 6 \\cdot 1 + (6-1) \\cdot 2 = 6 + 10 = 16$.\n\n2.  **Minimal Addition-Chain Cost ($C_M(119)$)**:\n    -   We factor $119 = 7 \\times 17$.\n    -   Compute $y=7x$. Since subtraction is disallowed, $7x=8x-x$ is not an option. We can use $7x = x+6x = x+(3x \\ll 1)$.\n        -   Compute $3x$: $x + (x \\ll 1)$. Cost $s+a=3$.\n        -   Compute $7x$ from $3x$: $y = x + ((x+(x \\ll 1)) \\ll 1)$. This can be staged:\n            1. `t1 = x  1` (cost `s=1`)\n            2. `t2 = x + t1` (`3x`) (cost `a=2`)\n            3. `t3 = t2  1` (`6x`) (cost `s=1`)\n            4. `y = x + t3` (`7x`) (cost `a=2`)\n        -   Cost to compute $7x$ is $2s+2a = 2+4=6$.\n    -   Compute $119x = 17y$: $17y = y + 16y = y + (y \\ll 4)$.\n        -   Cost from $y$: $4s+a=4+2=6$.\n    -   Total cost: $C_M(119) = (\\text{cost for } 7x) + (\\text{cost for } 17y) = (2s+2a)+(4s+a) = 6s+3a = 6(1)+3(2) = 12$.\n    -   **Justification of Minimality**: This sequence uses $3$ additions and $6$ total single-bit shifts. The cost is $12$, a significant saving over $16$. The constant $7$ cannot be formed with a single addition, requiring a minimum of two. The constant $17$ is of the form $2^4+1$, requiring one addition. Thus, a sequence based on the factorization $7 \\times 17$ requires at least $2+1=3$ additions. Our method uses $3$ additions and is therefore minimal in its number of additions. The total cost of $12$ is minimal.\n\n3.  **Savings for $c=119$**:\n    -   Savings$(119) = C_B(119) - C_M(119) = 16 - 12 = 4$.\n\n**Total Savings**\nThe total savings is the sum of the savings for each constant:\nTotal Savings = Savings$(45) +$ Savings$(75) +$ Savings$(119)$\nTotal Savings = $2 + 1 + 4 = 7$.",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "Strength reduction for division by a constant involves replacing it with a 'magic number' multiplication and a shift, but this transformation is subtle and potentially dangerous. This exercise puts you in the role of a compiler engineer analyzing code for a language like C, where signed integer overflow leads to undefined behavior . You must carefully evaluate different proposed implementations to identify one that is not only mathematically correct but also robust against invoking undefined behavior.",
            "id": "3672232",
            "problem": "A key optimization in compiler principles is strength reduction, where an expensive operation is replaced by a cheaper but equivalent one under the language’s semantics. Consider a function written in the C programming language that computes the quotient for signed $32$-bit integers using $x / 3$ for an input $x$ in the domain $0 \\le x \\le 2^{31} - 1$. Under the C standard, signed overflow has undefined behavior, and integer division truncates toward zero. A common strength reduction for division by a constant uses multiplication by a “magic” constant followed by a right shift, provided the multiplication is carried out in a wider type to avoid overflow and the mapping preserves defined semantics.\n\nLet $M$ be defined by $M = \\left\\lceil \\dfrac{2^{32}}{3} \\right\\rceil$. For concreteness, note that $2^{32} \\equiv 1 \\pmod{3}$, so $M = \\dfrac{2^{32} + 2}{3}$. The intended transformation approximates $x / 3$ for non-negative $x$ by computing the high $32$ bits of the $64$-bit product $x \\cdot M$, i.e., $\\left\\lfloor \\dfrac{x \\cdot M}{2^{32}} \\right\\rfloor$.\n\nYou are asked to evaluate the semantic correctness and definedness (i.e., the absence of undefined behavior) of several candidate rewrites of $x / 3$ under the C language rules for the domain $0 \\le x \\le 2^{31} - 1$. Each rewrite targets the same purpose: to reduce computational strength by replacing the division with a multiply and shift. Some rewrites introduce a guard to avoid undefined behavior (a conditional check that restricts execution of a dangerous code path to inputs that will not cause undefined behavior, otherwise falling back to $x / 3$).\n\nWhich of the following options are semantics-preserving for all $x$ in the stated domain and do not invoke undefined behavior? Choose all that apply.\n\n- A. Replace $x / 3$ with:\n  “compute `(int64_t) ((x * M)) >> 32`”\n  i.e., the multiplication $x * M$ is performed in the original $32$-bit signed type and only after that the result is converted to $64$ bits, then right-shifted by $32$.\n\n- B. Replace $x / 3$ with:\n  “compute `(int64_t) x * M >> 32`”\n  i.e., first widen $x$ to $64$ bits so the product `(int64_t) x * M` is computed in $64$ bits, then right-shift by $32$.\n\n- C. Use a guarded rewrite: if $-1 \\le x \\le 1$, compute `(int64_t) ((x * M)) >> 32`; otherwise, compute $x / 3$.\n\n- D. Replace $x / 3$ with:\n  “compute `((uint32_t) x * (uint32_t) M) >> 32`”\n  i.e., perform the multiplication in $32$-bit unsigned arithmetic and then right-shift by $32$ without any prior widening to $64$ bits.\n\nAssume the usual integer promotion and usual arithmetic conversions rules in C, and that the target architecture is two’s-complement with $32$-bit $int$ and $64$-bit $long\\ long$. Provide your choice(s) and be ready to justify them using only the foundational facts: the C language’s semantics for signed overflow, truncation of integer division toward zero, and the arithmetic identity $M = \\dfrac{2^{32} + 2}{3}$ for the chosen magic constant, together with the relationship between high-word extraction and division by a constant for non-negative inputs.",
            "solution": "The user wants me to validate and solve a problem concerning compiler strength reduction for integer division.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Operation to Optimize**: Division of a signed $32$-bit integer $x$ by the constant $3$, i.e., $x / 3$.\n*   **Input Domain**: $x$ is an integer such that $0 \\le x \\le 2^{31} - 1$.\n*   **C Language Semantics**:\n    *   Signed integer overflow results in undefined behavior (UB).\n    *   Integer division `/` truncates toward zero. For non-negative operands, this is equivalent to the floor function.\n*   **Strength Reduction Technique**:\n    *   The proposed replacement for $x/3$ computes the high $32$ bits of a $64$-bit product.\n    *   The mathematical formula for the approximation is $\\left\\lfloor \\dfrac{x \\cdot M}{2^{32}} \\right\\rfloor$.\n*   **Magic Constant**:\n    *   The constant $M$ is defined as $M = \\left\\lceil \\dfrac{2^{32}}{3} \\right\\rceil$.\n    *   It is also stated that $M = \\dfrac{2^{32} + 2}{3}$.\n*   **Target Architecture Assumptions**:\n    *   `int` is a $32$-bit signed integer.\n    *   `long long` is a $64$-bit signed integer.\n    *   `int64_t` is a $64$-bit signed integer type.\n    *   `uint32_t` is a $32$-bit unsigned integer type.\n    *   The architecture is two's complement.\n    *   Standard C integer promotion and arithmetic conversion rules apply.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientific Groundedness**: The problem is well-grounded in computer science, specifically in the domain of compiler optimizations. The technique of replacing division by a constant with multiplication by a \"magic number\" and a shift is a standard, widely-used algorithm (e.g., as described in \"Hacker's Delight\" by Henry S. Warren Jr.).\n2.  **Mathematical Correctness**: The definition of the magic number $M$ is mathematically sound. $2^{32} = (3 \\cdot 1 + 1)^{16} \\equiv 1^{16} \\equiv 1 \\pmod 3$. Thus, $2^{32} = 3k+1$ for some integer $k$. Then, $\\dfrac{2^{32}}{3} = k + \\dfrac{1}{3}$, so $\\left\\lceil \\dfrac{2^{32}}{3} \\right\\rceil = k+1$. Also, $\\dfrac{2^{32}+2}{3} = \\dfrac{(3k+1)+2}{3} = \\dfrac{3k+3}{3} = k+1$. The two definitions given for $M$ are equivalent.\n3.  **Well-Posed and Objective**: The problem is objective, using precise mathematical and programming language terms. It specifies the input domain, language semantics, and the exact expressions to be evaluated, making it a well-posed problem with a verifiable solution.\n4.  **Flaw Checklist**: The problem does not violate any of the criteria for invalidity. It is scientifically sound, formalizable, complete, realistic, and well-posed.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. The solution process will now proceed.\n\n### Solution Derivation\n\nThe core task is to determine which of the proposed C code rewrites correctly and safely computes $q = \\lfloor x/3 \\rfloor$ for all integers $x$ in the domain $0 \\le x \\le 2^{31} - 1$. This requires both mathematical and C language semantic analysis.\n\n**1. Mathematical Analysis of the Transformation**\n\nThe proposed transform is to compute $q' = \\left\\lfloor \\dfrac{x \\cdot M}{2^{32}} \\right\\rfloor$, where $M = \\dfrac{2^{32} + 2}{3}$. Let's verify if $q' = q$ for the given domain of $x$.\n\nSubstitute the expression for $M$:\n$$q' = \\left\\lfloor \\frac{x}{2^{32}} \\left( \\frac{2^{32} + 2}{3} \\right) \\right\\rfloor = \\left\\lfloor \\frac{x}{3} \\left( \\frac{2^{32} + 2}{2^{32}} \\right) \\right\\rfloor = \\left\\lfloor \\frac{x}{3} \\left( 1 + \\frac{2}{2^{32}} \\right) \\right\\rfloor = \\left\\lfloor \\frac{x}{3} + \\frac{2x}{3 \\cdot 2^{32}} \\right\\rfloor$$\nLet $x/3 = \\lfloor x/3 \\rfloor + f$, where $f = \\{x/3\\} \\in \\{0, 1/3, 2/3\\}$ is the fractional part.\n$$q' = \\lfloor \\lfloor x/3 \\rfloor + f + \\frac{2x}{3 \\cdot 2^{32}} \\rfloor = \\lfloor x/3 \\rfloor + \\left\\lfloor f + \\frac{2x}{3 \\cdot 2^{32}} \\right\\rfloor$$\nFor the transformation to be correct, we must have $\\left\\lfloor f + \\dfrac{2x}{3 \\cdot 2^{32}} \\right\\rfloor = 0$. This holds if and only if $f + \\dfrac{2x}{3 \\cdot 2^{32}}  1$.\n\nLet's find the maximum value of this expression. The maximum value of $f$ is $2/3$. The input domain is $0 \\le x \\le 2^{31}-1$.\nThe maximum value of the expression occurs at the maximum values of $f$ and $x$:\n$$ f_{\\text{max}} + \\frac{2x_{\\text{max}}}{3 \\cdot 2^{32}} \\approx \\frac{2}{3} + \\frac{2(2^{31}-1)}{3 \\cdot 2^{32}} = \\frac{2}{3} + \\frac{2^{32}-2}{3 \\cdot 2^{32}} = \\frac{2}{3} + \\left(\\frac{1}{3} - \\frac{2}{3 \\cdot 2^{32}}\\right) = 1 - \\frac{2}{3 \\cdot 2^{32}} $$\nSince this value is strictly less than $1$, the floor is always $0$. Thus, $q' = \\lfloor x/3 \\rfloor$, and the mathematical transformation is correct for the entire specified domain of $x$.\n\n**2. Analysis of C Language Implementations**\n\nThe computation $\\lfloor (x \\cdot M) / 2^{32} \\rfloor$ is equivalent to taking the high $32$ bits of the $64$-bit product of $x$ and $M$. In C, this corresponds to `(product_64bit)  32`. The value of the constant is $M = \\frac{2^{32}+2}{3} = 1431655766$. This fits in a $32$-bit signed integer, since $2^{31}-1 = 2147483647$. We assume $M$ is a compile-time constant of type `int`.\n\n**Option A Evaluation**\n*   **Expression**: `(int64_t) ((x * M)) >> 32`\n*   **Analysis**: The expression `(x * M)` involves two operands of type `int` (signed $32$-bit). The multiplication is performed using $32$-bit arithmetic, and the result is of type `int`. We must check for signed overflow. The maximum value of $x$ is $2^{31}-1$. For $x=2$, the product is $2 \\cdot 1431655766 = 2863311532$, which exceeds the maximum value for a signed $32$-bit integer, $2^{31}-1 = 2147483647$. According to the C standard, signed integer overflow results in undefined behavior.\n*   **Verdict**: **Incorrect**. The expression invokes undefined behavior for $x \\ge 2$.\n\n**Option B Evaluation**\n*   **Expression**: `(int64_t) x * M >> 32`\n*   **Analysis**: Due to C operator precedence, this is parsed as `(((int64_t)x) * M) >> 32`. First, `x` is cast to `int64_t`, a $64$-bit signed integer. Then, the multiplication `((int64_t)x) * M` is performed. According to the usual arithmetic conversions, the `int` operand `M` is promoted to `int64_t`. The multiplication is therefore a $64$-bit by $64$-bit multiplication, yielding a $64$-bit result. Let's check for overflow. The maximum product is for $x = 2^{31}-1$:\n$$ (2^{31}-1) \\cdot M = (2^{31}-1) \\cdot \\frac{2^{32}+2}{3} = \\frac{2^{63} + 2 \\cdot 2^{31} - 2^{32} - 2}{3} = \\frac{2^{63} - 2}{3} $$\nThis value is positive and significantly smaller than the maximum `int64_t` value, $2^{63}-1$. Thus, no overflow occurs. The product is non-negative, so the right shift ` 32` is an arithmetic shift that is equivalent to floor division by $2^{32}$, correctly extracting the high $32$ bits.\n*   **Verdict**: **Correct**. This implementation is semantically equivalent to $x/3$ and does not invoke undefined behavior.\n\n**Option C Evaluation**\n*   **Expression**: `if (-1 = x = 1), compute (int64_t) ((x * M)) >> 32; otherwise, compute x / 3.`\n*   **Analysis**: This is a guarded rewrite. The domain of $x$ is $0 \\le x \\le 2^{31}-1$. The condition `-1 = x = 1` is true only for $x=0$ and $x=1$ within this domain.\n    *   For $x=0$ and $x=1$: The expression `(int64_t)((x * M)) >> 32` is executed. As established in the analysis of option A, the potential issue is overflow in `x * M`. For $x=0$, the product is $0$. For $x=1$, the product is $M = 1431655766$. Neither of these results overflows a $32$-bit signed integer. The results are `0` for $x=0$ and `(int64_t)M >> 32 = 0` for $x=1$. These match the true values of $0/3$ and $1/3$. So, for the inputs where this branch is taken, the computation is safe and correct.\n    *   For $x \\ge 2$: The `otherwise` branch is taken, computing `x / 3`. This is the original, correct-by-definition operation.\n    *   The guarded expression as a whole covers the entire input domain correctly and without invoking undefined behavior, as the guard prevents the UB-causing inputs from reaching the dangerous code path.\n*   **Verdict**: **Correct**. This is a valid, safe, and semantics-preserving replacement for $x/3$.\n\n**Option D Evaluation**\n*   **Expression**: `((uint32_t) x * (uint32_t) M) >> 32`\n*   **Analysis**: This expression involves casting `x` and `M` to `uint32_t`. The multiplication `(uint32_t)x * (uint32_t)M` is performed using $32$-bit unsigned arithmetic. In C, the result of this operation is also of type `uint32_t`, and any overflow wraps around (i.e., the result is congruent to the mathematical product modulo $2^{32}$). This means the result is only the lower $32$ bits of the full $64$-bit product. Let this $32$-bit result be `res_32`. The expression then becomes `res_32 >> 32`. According to the C standard (C99 §6.5.7 and C11 §6.5.7), if the value of the right operand of a shift operator is greater than or equal to the width of the promoted left operand, the behavior is undefined. Here, a $32$-bit value is shifted by $32$, which invokes undefined behavior.\n*   **Verdict**: **Incorrect**. The expression relies on undefined behavior. Even under a common compiler-specific behavior where this shift yields $0$, the overall result would be $0$ for all $x$, which is semantically incorrect for $x \\ge 3$.",
            "answer": "$$\\boxed{BC}$$"
        },
        {
            "introduction": "The validity of a strength reduction often depends critically on the precise semantics defined by a programming language standard. This practice explores the common optimization of replacing a modulo operation with a bitwise AND, a transformation that is only valid under specific conditions . By comparing the behavior of these operations across different languages and for both signed and unsigned integers, you will learn why a deep understanding of language specifications is essential for writing a correct and robust compiler.",
            "id": "3672310",
            "problem": "A compiler designer considers a strength reduction that replaces the computation $i \\% 8$ with a bitwise mask $i \\ 7$ inside a tight loop to avoid division. Decide under which language and signedness conditions this replacement preserves program semantics. Use fundamental definitions as your starting point: in mathematics, for any integer $i$ and positive modulus $m$, the remainder $r$ is the unique integer with $0 \\le r  m$ such that $i \\equiv r \\pmod{m}$; in mainstream programming languages, the remainder operator may be defined in terms of truncated division or floor division, influencing the sign of $r$. Also recall that for base-$2$ representations, masking by $2^k - 1$ extracts the low $k$ bits of the representation. Analyze the interaction of these definitions with signedness and the language’s integer semantics. Select all correct statements.\n\nA. In C (since C99) and C++ (since C++11), replacing $i \\% 8$ with $i \\ 7$ is safe for all integral types, including negative values, because both operations are defined on two’s complement representations.\n\nB. In C and C++, replacing $i \\% 8$ with $i \\ 7$ is safe if $i$ is an unsigned type, or if $i$ is a signed type and it is known that $i \\ge 0$ at runtime.\n\nC. In Java (running on the Java Virtual Machine (JVM)), the replacement is unsafe for negative $i$, because $i \\% 8$ may be negative while $i \\ 7$ is always in $[0,7]$.\n\nD. In Python, the replacement $i \\% 8 \\to i \\ 7$ is safe for all integers, because Python defines $i \\% 8$ as the unique $r$ with $0 \\le r  8$ and $i \\equiv r \\pmod{8}$, which equals the value of the low $3$ bits `i  7`.\n\nE. In C and C++, evaluating $i \\ 7$ when $i$ is a negative signed integer triggers Undefined Behavior (UB), which is why the replacement is unsafe in those cases.",
            "solution": "The user wants me to analyze the validity of a compiler optimization, specifically the strength reduction that replaces the computation $i \\% 8$ with $i \\ 7$. I will start by validating the problem statement.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Optimization:** A strength reduction that replaces `$i \\% 8$` with `$i \\ 7$`.\n- **Context:** Occurs inside a tight loop.\n- **Objective:** Determine the conditions (language, signedness) under which this replacement preserves program semantics.\n- **Mathematical Definition of Remainder:** For an integer $i$ and a positive modulus $m$, the remainder $r$ is the unique integer satisfying $0 \\le r  m$ and $i \\equiv r \\pmod{m}$.\n- **Programming Language Remainder:** The behavior of the `%` operator can be defined based on either truncated division or floor division.\n- **Bitwise AND Operation:** Masking with $2^k - 1$ extracts the low $k$ bits of a number's base-$2$ representation. Here, $k=3$, so `$i \\ 7$` (where $7 = 2^3 - 1$) extracts the low $3$ bits of $i$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly rooted in computer science, specifically compiler design, computer arithmetic, and programming language semantics. The definitions provided for remainder, bitwise AND, and the distinction between mathematical and programming language remainder conventions are standard and correct.\n- **Well-Posed:** The problem is well-posed. It asks for an analysis of the equivalence of two expressions under various well-defined conditions (different programming languages, signed vs. unsigned types). A definite set of correct and incorrect conditions can be determined by consulting language standards and the principles of computer arithmetic.\n- **Objective:** The problem statement is objective, precise, and free of subjective claims. It references specific language standards (C99, C++11) and common platforms (JVM).\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It presents a standard, non-trivial analysis task in compiler theory. I will proceed with a detailed derivation and evaluation of the options.\n\n### Derivation and Analysis\n\nThe core of the problem is to compare the semantics of the remainder operator (`%`) and the bitwise AND operator (``).\n\n**Analysis of `$i \\ 7$`**\nThe expression `$i \\ 7$` performs a bitwise AND operation between the integer $i$ and the integer $7$. In binary, $7$ is represented as `...000111`. This operation effectively zeros out all but the last three bits of the binary representation of $i$. The result is always an integer in the range $[0, 7]$.\nFor any integer $i$ (positive, negative, or zero), if we interpret its bit pattern in two's complement (the standard for signed integers in modern systems), the value of `$i \\ (2^k - 1)$` is a non-negative integer $r$ such that $i \\equiv r \\pmod{2^k}$. For our case with $k=3$, `$i \\ 7$` computes a value $r \\in [0, 7]$ such that $i \\equiv r \\pmod{8}$. This corresponds exactly to the mathematical definition of the remainder as provided in the problem statement.\n\n**Analysis of `$i \\% 8$`**\nThe behavior of the remainder operator `%` is dependent on the programming language's definition, particularly for negative operands.\n\n1.  **For non-negative `i` ($i \\ge 0$):**\n    For any non-negative integer $i$, all relevant programming languages (C, C++, Java, Python) define `$i \\% 8$` to be the standard remainder, which will be a value in $[0, 7]$. This is identical to the result of `$i \\ 7$`. Thus, for $i \\ge 0$, the replacement is always safe.\n\n2.  **For negative `i` ($i  0$):**\n    This is where language specifications differ. The behavior is typically tied to the definition of integer division.\n    -   **Truncated Division (as in C99, C++11, Java):** The result of integer division `a / b` is truncated towards zero. The remainder is defined by the identity `(a / b) * b + a % b == a`.\n        Let's take $i = -1$ and the divisor $m=8$.\n        - Division: `(-1) / 8 = 0` (truncating `-0.125` towards zero).\n        - Identity: `(0 * 8) + (-1 % 8) == -1`.\n        - Result: This implies `(-1) % 8 = -1`.\n        However, `(-1)  7` is $7$. Since $-1 \\ne 7$, the replacement is semantically incorrect for negative $i$ in these languages. In general, for $i  0$, `$i \\% 8$` will yield a result in $[-7, 0]$, while `$i \\ 7$` yields a result in $[0, 7]$.\n\n    -   **Floor Division (as in Python):** The result of integer division `a // b` is floored (rounded towards negative infinity). The remainder is defined by `(a // b) * b + a % b == a`. A property of this definition is that the sign of the remainder `a % b` matches the sign of the divisor `b`.\n        Let's take $i = -1$ and the divisor $m=8$.\n        - Division: `(-1) // 8 = -1` (flooring `-0.125`).\n        - Identity: `(-1 * 8) + (-1 % 8) == -1`, so `-8 + (-1 % 8) == -1`.\n        - Result: This implies `(-1) % 8 = 7`.\n        This matches the result of `(-1)  7 = 7`. In general, for a positive divisor $m$, Python's `$i \\% m$` operation yields a result in $[0, m-1]$. This is the mathematical remainder, which is identical to the result of `$i \\ (m-1)$` when $m$ is a power of $2$.\n\nWith this foundation, let's evaluate each option.\n\n### Option-by-Option Analysis\n\n**A. In C (since C99) and C++ (since C++11), replacing $i \\% 8$ with $i \\ 7$ is safe for all integral types, including negative values, because both operations are defined on two’s complement representations.**\nThis statement is incorrect. As demonstrated above, for negative values of $i$, the C99/C++11 standard specifies that the sign of `$i \\% m$` is the same as the sign of $i$. For example, `(-1) % 8` is $-1$. In contrast, `(-1)  7` is $7$. The results are not equivalent. The reason provided—that both operations are defined on two's complement representations—is a non sequitur; the fact that they are well-defined does not imply they are equivalent.\n**Verdict: Incorrect.**\n\n**B. In C and C++, replacing $i \\% 8$ with $i \\ 7$ is safe if $i$ is an unsigned type, or if $i$ is a signed type and it is known that $i \\ge 0$ at runtime.**\nThis statement is correct.\n- If $i$ is an `unsigned` type, its value is by definition non-negative.\n- If $i$ is a `signed` type but guaranteed to be non-negative ($i \\ge 0$), the same logic applies.\nFor any non-negative integer $i$, both `$i \\% 8$` and `$i \\ 7$` compute the mathematical remainder, yielding identical results in the range $[0, 7]$. Therefore, the replacement is semantically preserving under these conditions.\n**Verdict: Correct.**\n\n**C. In Java (running on the Java Virtual Machine (JVM)), the replacement is unsafe for negative $i$, because $i \\% 8$ may be negative while $i \\ 7$ is always in $[0,7]$.**\nThis statement is correct. The Java Language Specification defines the remainder operator `%` such that the result of `(a/b)*b + (a%b)` is equal to `a`. Integer division truncates towards zero. This is the same rule as in C99/C++11. Consequently, for a negative $i$, `$i \\% 8$` will be non-positive (e.g., `(-1) \\% 8` results in $-1$). The bitwise operation `$i \\ 7$` always results in a non-negative value. Because the results differ for negative $i$, the replacement is unsafe. The reason provided is accurate.\n**Verdict: Correct.**\n\n**D. In Python, the replacement $i \\% 8 \\to i \\ 7$ is safe for all integers, because Python defines $i \\% 8$ as the unique $r$ with $0 \\le r  8$ and $i \\equiv r \\pmod{8}$, which equals the value of the low $3$ bits `i  7`.**\nThis statement is correct. Python's `%` operator is defined based on floor division, which ensures the remainder `$i \\% m$` has the same sign as the divisor $m$. Since the divisor is $8$ (positive), the result of `$i \\% 8$` is always in the range $[0, 7]$. This definition matches the mathematical definition of remainder modulo $8$. As established earlier, the bitwise operation `$i \\ 7$` also computes the mathematical remainder modulo $8$ for any integer $i$. Therefore, the two expressions are equivalent for all integers in Python.\n**Verdict: Correct.**\n\n**E. In C and C++, evaluating $i \\ 7$ when $i$ is a negative signed integer triggers Undefined Behavior (UB), which is why the replacement is unsafe in those cases.**\nThis statement is incorrect. Bitwise operations on signed integers, including negative ones, are well-defined in C and C++. The C standard (e.g., C11 §6.5.10) specifies the behavior of bitwise AND. Modern systems universally use two's complement representation for signed integers, and the bitwise AND operation simply acts on this bit-level representation. For example, `(-1)  7` is well-defined and evaluates to $7$. The replacement `$i \\% 8 \\to i \\ 7$` is unsafe for negative $i$ in C/C++ due to the differing results of the two operators, not because of any Undefined Behavior associated with the bitwise AND operation itself.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{BCD}$$"
        }
    ]
}