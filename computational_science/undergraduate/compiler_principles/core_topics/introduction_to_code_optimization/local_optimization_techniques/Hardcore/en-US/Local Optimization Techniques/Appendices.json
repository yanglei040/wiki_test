{
    "hands_on_practices": [
        {
            "introduction": "Peephole optimization involves examining a small \"window\" of instructions and replacing them with a shorter or faster sequence. A common technique is algebraic simplification, where the compiler uses mathematical properties like associativity and commutativity to simplify expressions. This exercise  provides a perfect hands-on opportunity to think like an optimizer by applying the fundamental rules of bitwise XOR to reduce a complex sequence of operations to a single value.",
            "id": "3651920",
            "problem": "A local peephole optimizer in an optimizing compiler is analyzing a small region of Intermediate Representation (IR) expressed in Static Single Assignment (SSA) form. The IR uses the caret symbol $^$ to denote bitwise exclusive-or (XOR) on $w$-bit machine words, not exponentiation. Assume all operands are pure values (no side effects), and all operations are on fixed-width unsigned words so that bitwise XOR is well defined. The semantics of bitwise XOR are the component-wise addition modulo two of corresponding bits, with properties inherited from addition modulo two such as associativity and commutativity and the existence of an identity element $0$.\n\nThe IR fragment computes temporaries $t_0$ through $t_5$ as follows:\n$$t_0 = a \\mathbin{^} b$$\n$$t_1 = t_0 \\mathbin{^} a$$\n$$t_2 = c \\mathbin{^} d$$\n$$t_3 = t_2 \\mathbin{^} c$$\n$$t_4 = t_1 \\mathbin{^} t_3$$\n$$t_5 = t_4 \\mathbin{^} d$$\n\nUsing only the fundamental properties of bitwise XOR as described above and reasoning valid for local optimization in SSA form, derive the simplest closed-form expression for the value computed by $t_5$ in terms of $a$, $b$, $c$, $d$, and constants (if any). Express your final answer as a single symbolic expression. No numerical rounding is required.",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Context**: Local peephole optimization in a compiler on Intermediate Representation (IR) in Static Single Assignment (SSA) form.\n- **Operator**: The caret symbol `$^$` denotes bitwise exclusive-or (XOR), not exponentiation.\n- **Operands**: All operands ($a$, $b$, $c$, $d$) are pure values on fixed-width $w$-bit unsigned machine words.\n- **Properties of XOR**:\n  - Associativity: $(x \\mathbin{^} y) \\mathbin{^} z = x \\mathbin{^} (y \\mathbin{^} z)$\n  - Commutativity: $x \\mathbin{^} y = y \\mathbin{^} x$\n  - Identity Element: $x \\mathbin{^} 0 = x$\n  - Self-Inverse Property: A consequence of component-wise addition modulo two is that $x \\mathbin{^} x = 0$.\n- **IR Definitions**:\n  $$t_0 = a \\mathbin{^} b$$\n  $$t_1 = t_0 \\mathbin{^} a$$\n  $$t_2 = c \\mathbin{^} d$$\n  $$t_3 = t_2 \\mathbin{^} c$$\n  $$t_4 = t_1 \\mathbin{^} t_3$$\n  $$t_5 = t_4 \\mathbin{^} d$$\n- **Task**: Derive the simplest closed-form expression for $t_5$ in terms of $a$, $b$, $c$, and $d$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It is based on fundamental principles of computer science (compiler optimization) and discrete mathematics (the algebraic properties of the XOR operation, which forms an abelian group over the set of $w$-bit words). The use of Static Single Assignment (SSA) form ensures that each temporary variable is defined exactly once, making the problem unambiguous. The definitions are self-contained and consistent. No scientific laws are violated, and no information is missing or contradictory. The problem is a standard exercise in expression simplification, a common task for an optimizing compiler.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\nThe objective is to find a simplified expression for the final temporary variable, $t_5$. This will be achieved by substituting the definitions of the intermediate temporaries and applying the algebraic properties of the bitwise XOR operation. The fact that the code is in SSA form is critical as it allows for direct substitution, since each variable has only one definition point.\n\nThe final computation is:\n$$t_5 = t_4 \\mathbin{^} d$$\n\nWe begin by substituting the expression for $t_4$:\n$$t_5 = (t_1 \\mathbin{^} t_3) \\mathbin{^} d$$\n\nNext, we substitute the expressions for $t_1$ and $t_3$:\n$$t_5 = ((t_0 \\mathbin{^} a) \\mathbin{^} (t_2 \\mathbin{^} c)) \\mathbin{^} d$$\n\nDue to the associative property of XOR, the grouping parentheses can be removed:\n$$t_5 = t_0 \\mathbin{^} a \\mathbin{^} t_2 \\mathbin{^} c \\mathbin{^} d$$\n\nNow, we substitute the initial expressions for $t_0$ and $t_2$:\n$$t_5 = (a \\mathbin{^} b) \\mathbin{^} a \\mathbin{^} (c \\mathbin{^} d) \\mathbin{^} c \\mathbin{^} d$$\n\nAgain, applying associativity, we remove all parentheses:\n$$t_5 = a \\mathbin{^} b \\mathbin{^} a \\mathbin{^} c \\mathbin{^} d \\mathbin{^} c \\mathbin{^} d$$\n\nUsing the commutative property of XOR, we can reorder the terms to group identical variables together:\n$$t_5 = (a \\mathbin{^} a) \\mathbin{^} b \\mathbin{^} (c \\mathbin{^} c) \\mathbin{^} (d \\mathbin{^} d)$$\n\nWe now apply the self-inverse property, $x \\mathbin{^} x = 0$, to each pair of identical variables:\n- $a \\mathbin{^} a = 0$\n- $c \\mathbin{^} c = 0$\n- $d \\mathbin{^} d = 0$\n\nSubstituting these results into the expression for $t_5$:\n$$t_5 = 0 \\mathbin{^} b \\mathbin{^} 0 \\mathbin{^} 0$$\n\nFinally, we apply the identity property, $x \\mathbin{^} 0 = x$. We can simplify the expression by repeatedly applying this property:\n$$t_5 = (0 \\mathbin{^} b) \\mathbin{^} (0 \\mathbin{^} 0)$$\n$$t_5 = b \\mathbin{^} 0$$\n$$t_5 = b$$\n\nThe entire sequence of computations, which seemed complex, simplifies to the single variable $b$. A peephole optimizer performing this analysis would replace the entire block of code with a single assignment, `t_5 = b` (or more likely, replace all uses of $t_5$ with $b$), thus eliminating six instructions and five temporary variables.",
            "answer": "$$\\boxed{b}$$"
        },
        {
            "introduction": "Strength reduction is a powerful optimization that replaces costly operations, such as division, with cheaper ones, like bitwise shifts or masks. However, a compiler must guarantee that such transformations are semantically equivalent to the original code across all possible inputs. This practice  challenges you to analyze the validity of replacing a modulus operation with a bitwise AND, uncovering crucial distinctions between signed and unsigned integer semantics that are vital for building a correct optimizer.",
            "id": "3651912",
            "problem": "A compiler applies local peephole optimizations to integer expressions while preserving program semantics. Consider a language whose integer semantics are as follows: for unsigned integers of width $w$ bits, arithmetic is performed modulo $2^w$ and bitwise operations act on the $w$-bit binary representation; for signed integers, integer division defines $q = \\operatorname{trunc}(a/b)$ and $r = a - qb$ with $b \\ne 0$, satisfying $0 \\le |r|  |b|$ and $\\operatorname{sign}(r) = \\operatorname{sign}(a)$. The physical representation of signed integers is implementation-defined and may be two's complement or another representation, although modern systems are typically two's complement. The compiler considers replacing the expression $x \\% 2$ with $x \\ 1$ to reduce cost and eliminate division on platforms where modulus is expensive.\n\nStarting from the core definitions of modulo and bitwise operations, as well as binary integer representation, analyze the equivalence of $x \\% 2$ and $x \\ 1$ for unsigned $x$ and for signed $x$ (including negative operands), and the generalization to $x \\% 2^k$ versus $x \\ (2^k - 1)$. Evaluate how implementation-defined signed representations affect the validity of such rewrites.\n\nWhich of the following statements are true?\n\nA. For unsigned $x$, rewriting $x \\% 2$ as $x \\ 1$ is semantics-preserving for all values of $x$ under modulo $2^w$ arithmetic for unsigned integers, with no implementation-defined corner cases.\n\nB. For signed $x$ under two's complement representation and truncation-toward-zero division semantics, rewriting $x \\% 2$ as $x \\ 1$ preserves semantics for all $x$ (including negative $x$).\n\nC. For signed $x$, inserting a cast to unsigned and then rewriting $x \\% 2$ as $(\\text{unsigned})\\,x \\ 1$ preserves the semantics of the original signed modulus for all $x$, because parity depends only on the least significant bit regardless of representation.\n\nD. In a language that specifies the Euclidean remainder (so that $r$ satisfies $0 \\le r  |b|$ for all $a$), the rewrite $x \\% 2 \\to x \\ 1$ is valid for both signed and unsigned $x$ under two's complement representation.\n\nE. The generalization $x \\% 2^k \\to x \\ (2^k - 1)$ is valid for unsigned $x$ under modulo $2^w$ arithmetic, but it does not generally preserve semantics for signed $x$ with truncation-toward-zero semantics, because for negative $x$ the remainder $r$ has the sign of $x$ and thus differs from the nonnegative mask result.",
            "solution": "The user wants me to validate the problem statement and then provide a detailed solution.\n\n### Step 1: Extract Givens\n\n- **Language Semantics for Unsigned Integers:**\n  - Width: `$w$` bits.\n  - Arithmetic: Modulo `$2^w$`.\n  - Bitwise operations: Act on the `$w$`-bit binary representation.\n- **Language Semantics for Signed Integers:**\n  - Division definition: `$q = \\operatorname{trunc}(a/b)$` and `$r = a - qb$`, for a dividend `$a$` and a non-zero divisor `$b$`. This is \"truncation toward zero\" or \"symmetric\" division.\n  - Remainder properties: `$0 \\le |r|  |b|$` and `$\\operatorname{sign}(r) = \\operatorname{sign}(a)$`.\n  - Physical representation: Implementation-defined (e.g., two's complement).\n- **Optimization Under Consideration:**\n  - Replacing `$x \\% 2$` with `$x \\ 1$`.\n- **Analysis Task:**\n  - Analyze the equivalence of `$x \\% 2$` and `$x \\ 1$` for unsigned and signed `$x$`.\n  - Analyze the equivalence of the generalization `$x \\% 2^k$` and `$x \\ (2^k - 1)$`.\n  - Evaluate how implementation-defined signed representations affect the validity.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem statement is based on the formal definitions of integer arithmetic and bitwise operations as specified in computer science and programming language standards (e.g., C, C++). The division and remainder semantics (`truncation toward zero`) are one of the common standards. The problem is scientifically and technically sound.\n- **Well-Posed:** The problem provides clear, unambiguous definitions for the arithmetic operations to be analyzed. The questions asked have definite answers that can be derived by applying these definitions.\n- **Objective:** The language is formal and precise, based on mathematical definitions. It is free from subjective or opinion-based statements.\n\n### Step 3: Verdict and Action\n\nThe problem statement is valid. It is self-contained, consistent, and grounded in established principles of computer science. I will now proceed to the solution.\n\n### Derivation of Solution\n\nThe analysis requires examining the equivalence of an arithmetic modulus operation and a bitwise AND operation for unsigned and signed integers under the specified rules.\n\n**1. Analysis for Unsigned Integers**\n\nFor an unsigned `$w$`-bit integer `$x$`, its value is given by its binary representation `$x = \\sum_{i=0}^{w-1} b_i 2^i$`, where `$b_i \\in \\{0, 1\\}$` is the bit at position `$i$`.\n\n- **Modulo operation, `$x \\% 2$`:** The remainder of `$x$` when divided by `$2$`. We can rewrite `$x$` as:\n  $$x = (b_{w-1} 2^{w-1} + \\dots + b_1 2^1) + b_0 2^0 = 2 \\left( \\sum_{i=1}^{w-1} b_i 2^{i-1} \\right) + b_0$$\n  The first term is an integer multiple of `$2$`. The second term, `$b_0$`, is either `$0$` or `$1$`. By the definition of remainder, `$x \\% 2 = b_0$`, which is the least significant bit (LSB) of `$x$`.\n\n- **Bitwise AND operation, `$x \\ 1$`:** The integer `$1$` has a binary representation where only the LSB is `$1$` and all other bits are `$0$`. The bitwise AND operation `$x \\ 1$` isolates the LSB of `$x$`. The result is an integer whose value is `$b_0$`.\n\nSince both `$x \\% 2$` and `$x \\ 1$` evaluate to the value of the LSB of `$x$`, the expressions are semantically equivalent for all unsigned integers. This holds regardless of the bit width `$w$`.\n\n- **Generalization to `$x \\% 2^k$` vs. `$x \\ (2^k - 1)$` (unsigned):**\n  We can express `$x$` as `$x = q \\cdot 2^k + r$`, where `$r = \\sum_{i=0}^{k-1} b_i 2^i$`. The remainder `$r$` is the value represented by the lower `$k$` bits of `$x$`. The value `$2^k - 1$` is a bitmask with its `$k$` least significant bits set to `$1$`. The operation `$x \\ (2^k - 1)$` isolates the lower `$k$` bits of `$x$`, and the resulting value is precisely `$r$`. Thus, for unsigned integers, `$x \\% 2^k \\equiv x \\ (2^k - 1)$`.\n\n**2. Analysis for Signed Integers (Truncation-toward-Zero Semantics)**\n\nThe problem defines the remainder for signed integers as `$r = a - qb$` where `$q = \\operatorname{trunc}(a/b)$`. The key additional constraint is `$\\operatorname{sign}(r) = \\operatorname{sign}(a)$`, which means the remainder must be non-positive if `$a$` is negative.\n\n- **Modulo operation, `$x \\% 2$`:**\n  - For non-negative `$x$`: Here, `$\\operatorname{trunc}(x/2)` is the same as integer division for positive numbers. The analysis is identical to the unsigned case. `$x \\% 2$` is equal to the LSB, so the equivalence `$x \\% 2 \\equiv x \\ 1$` holds.\n  - For negative `$x$`: The bitwise operation `$x \\ 1$` will always yield a result of `$0$` or `$1$`, which are non-negative. However, for a negative `$x$`, the signed remainder `$x \\% 2$` must be non-positive (i.e., `$0$` or `$-1$`). Therefore, the equivalence can only hold if the result is `$0$`, which is not always the case.\n  - **Counterexample:** Let `$x = -1$`.\n    - `$x \\% 2 = -1 - \\operatorname{trunc}(-1/2) \\cdot 2 = -1 - \\operatorname{trunc}(-0.5) \\cdot 2 = -1 - 0 \\cdot 2 = -1$`. This respects `$\\operatorname{sign}(r) = \\operatorname{sign}(a)$`.\n    - Now consider `$x \\ 1$`. The bitwise operation depends on the physical representation. In a typical `$w$`-bit two's complement system, the representation of `$-1$` is a string of `$w$` ones (`11...11`).\n    - `$-1 \\ 1$` is therefore `11...11_2 \\ 00...01_2 = 00...01_2`, which has the value `$1$`.\n    - Since `$x \\% 2 = -1$` and `$x \\ 1 = 1$`, the expressions are not equivalent for `$x=-1$`.\n\n- **Generalization to `$x \\% 2^k$` vs. `$x \\ (2^k - 1)$` (signed):**\n  The same logic applies. For a negative `$x$` that is not a multiple of `$2^k$`, `$x \\% 2^k$` will be a negative number (or zero), whereas `$x \\ (2^k - 1)$` will be a non-negative number. For example, for `$x=-3$` and `$k=3$` (i.e., `$x \\% 8$`),\n  `$-3 \\% 8 = -3 - \\operatorname{trunc}(-3/8) \\cdot 8 = -3 - 0 = -3$`.\n  In `$8$`-bit two's complement, `$-3$` is `11111101`. `$2^3-1=7$` is `00000111`.\n  `$-3 \\ 7 = 11111101_2 \\ 00000111_2 = 00000101_2 = 5$`.\n  As `$-3 \\ne 5$`, the equivalence does not hold.\n\n### Option-by-Option Analysis\n\n**A. For unsigned $x$, rewriting $x \\% 2$ as $x \\ 1$ is semantics-preserving for all values of $x$ under modulo $2^w$ arithmetic for unsigned integers, with no implementation-defined corner cases.**\nAs shown in Analysis 1, for any unsigned integer `$x$`, both `$x \\% 2$` and `$x \\ 1$` compute the value of the least significant bit. The representation of unsigned integers is standard, and the results `$0$` or `$1$` cause no issues with modulo `$2^w$` arithmetic. This statement is true.\n**Verdict: Correct**\n\n**B. For signed $x$ under two's complement representation and truncation-toward-zero division semantics, rewriting $x \\% 2$ as $x \\ 1$ preserves semantics for all $x$ (including negative $x$).**\nAs shown in the counterexample in Analysis 2, for `$x=-1$`, `$x \\% 2$` equals `$-1$`, while `$x \\ 1$` (in two's complement) equals `$1$`. Since `$-1 \\ne 1$`, the rewrite does not preserve semantics for all `$x$`.\n**Verdict: Incorrect**\n\n**C. For signed $x$, inserting a cast to unsigned and then rewriting $x \\% 2$ as $(\\text{unsigned})\\,x \\ 1$ preserves the semantics of the original signed modulus for all $x$, because parity depends only on the least significant bit regardless of representation.**\nLet's test this with `$x=-1$`. The original expression is `$x \\% 2 = -1$`. The proposed rewrite is `$(\\text{unsigned})\\,x \\ 1$`. In a typical `$w$`-bit two's complement system, casting `$-1$` to unsigned reinterprets the bit pattern `11...11` as the unsigned value `$2^w - 1$`. Then, `$(2^w - 1) \\ 1 = 1$`. Since `$-1 \\ne 1$`, the rewrite does not preserve semantics. The reasoning about parity is misleading; the issue is that the *value* of the remainder for negative inputs is defined to be negative (or zero) by the language, which differs from the *value* produced by the bitwise operation.\n**Verdict: Incorrect**\n\n**D. In a language that specifies the Euclidean remainder (so that $r$ satisfies $0 \\le r  |b|$ for all $a$), the rewrite $x \\% 2 \\to x \\ 1$ is valid for both signed and unsigned $x$ under two's complement representation.**\nThis option introduces a hypothetical language with Euclidean remainder rules. For a divisor `$b=2$`, the remainder `$r$` must satisfy `$0 \\le r  2$`, meaning `$r$` is always `$0$` or `$1$`. Specifically, `$x \\% 2$` is `$0$` if `$x$` is even and `$1$` if `$x$` is odd. For two's complement integers (both signed and unsigned), the bitwise operation `$x \\ 1$` also yields `$0$` if `$x$` is even (LSB is `$0$`) and `$1$` if `$x$` is odd (LSB is `$1$`). Since both expressions are equivalent to computing the parity of `$x$` and yield a result of `$0$` or `$1$`, they are semantically equivalent under these rules. The statement is a correct assertion about this hypothetical language.\n**Verdict: Correct**\n \n**E. The generalization $x \\% 2^k \\to x \\ (2^k - 1)$ is valid for unsigned $x$ under modulo $2^w$ arithmetic, but it does not generally preserve semantics for signed $x$ with truncation-toward-zero semantics, because for negative $x$ the remainder $r$ has the sign of $x$ and thus differs from the nonnegative mask result.**\nThis statement has two clauses.\n1. The generalization is valid for unsigned `$x$`: As shown in Analysis 1, this is true.\n2. It is not valid for signed `$x$` with truncation-toward-zero semantics, and the reason is the sign difference: As shown in Analysis 2, for negative `$x$`, `$x \\% 2^k$` gives a non-positive result, while `$x \\ (2^k-1)$` gives a non-negative result. These can only be equal if both are `$0$`. They are not equal in general. The provided reason is precisely the core of the issue.\nBoth clauses and the reasoning are correct.\n**Verdict: Correct**",
            "answer": "$$\\boxed{ADE}$$"
        },
        {
            "introduction": "Optimizing floating-point code requires special care due to the complexities of the IEEE 754 standard, which includes special values like infinity and Not-a-Number (NaN). Seemingly obvious algebraic identities, such as `$x = x$` always being true, do not necessarily hold for all values. This problem  delves into the specific case of self-equality, forcing you to consider the unique behavior of NaNs and the subtle but critical role of exception side effects in program semantics.",
            "id": "3651963",
            "problem": "A typed intermediate representation (IR) uses a binary equality operator $\\mathrm{eq}(x,y)$ that returns a Boolean value $\\mathrm{true}$ or $\\mathrm{false}$. The IR is language-agnostic but follows these widely accepted semantics:\n\n- For integer types, equality is defined by the standard law of reflexivity: for any integer value $x$, $x = x$ holds. Evaluating integer equality has no side effects.\n- For floating-point types, the IR follows the semantics of Institute of Electrical and Electronics Engineers (IEEE) $754$ floating-point arithmetic. Let $x$ be a floating-point value.\n  - If $x$ is a finite number or an infinity, then $x = x$ holds and the comparison returns $\\mathrm{true}$ with no floating-point exceptions.\n  - If $x$ is Not-a-Number (NaN), then $x = x$ does not hold, and $\\mathrm{eq}(x,x)$ returns $\\mathrm{false}$. If $x$ is a signaling NaN (sNaN), evaluating an ordered comparison such as $x == x$ raises the invalid-operation exception (sets the invalid status flag) and quiets the NaN internally for the purpose of the operation. If $x$ is a quiet NaN (qNaN), no exception is raised.\n  - A classification predicate $\\mathrm{isNaN}(x)$ is available in the IR, which returns $\\mathrm{true}$ if and only if $x$ is NaN (either quiet or signaling). It is defined as a non-arithmetic classification operation that does not raise any floating-point exceptions.\n\nTwo compilation modes are considered:\n- Strict mode: The program may observe floating-point status flags (for example, via a floating-point environment API), so transformations must preserve both the computed Boolean value and any exception side effects.\n- Ignore-exceptions mode: The program cannot observe floating-point status flags and traps are disabled; only the computed Boolean value matters.\n\nSeparately, the optimizer may run a dataflow analysis that can prove a variable is non-NaN in a given region. The property “no NaNs possible for $x$” means $x$ is guaranteed to be neither a quiet NaN nor a signaling NaN at the program point.\n\nConsider applying local optimization to the pattern $\\mathrm{eq}(x,x)$. Which of the following transformation scenarios are semantics-preserving under the stated conditions?\n\nA. For integer-typed $x$, rewrite $\\mathrm{eq}(x,x)$ to the constant $\\mathrm{true}$.\n\nB. For floating-point-typed $x$ in strict mode, rewrite $\\mathrm{eq}(x,x)$ to $\\lnot \\mathrm{isNaN}(x)$.\n\nC. For floating-point-typed $x$ in strict mode, if analysis proves “no NaNs possible for $x$” at the program point, rewrite $\\mathrm{eq}(x,x)$ to the constant $\\mathrm{true}$.\n\nD. For floating-point-typed $x$ in ignore-exceptions mode, rewrite $\\mathrm{eq}(x,x)$ to $\\lnot \\mathrm{isNaN}(x)$.\n\nE. For floating-point-typed $x$, rewrite $\\mathrm{eq}(x,x)$ to the constant $\\mathrm{true}$ unconditionally.\n\nSelect all correct options.",
            "solution": "We begin from the core definitions and facts:\n\n- Integer equality is reflexive: for any integer $x$, $x = x$. Evaluating equality on integers has no side effects beyond producing the Boolean result.\n- IEEE $754$ floating-point semantics:\n  - Ordered comparisons like $x == x$ produce $\\mathrm{true}$ for all numeric $x$ (finite or infinite) and $\\mathrm{false}$ for any $\\mathrm{NaN}$.\n  - For signaling NaN $x$, ordered comparisons raise the invalid-operation exception (set the invalid flag). For quiet NaN $x$, ordered comparisons do not raise exceptions.\n  - The classification predicate $\\mathrm{isNaN}(x)$ is defined here as a non-arithmetic test that returns $\\mathrm{true}$ exactly when $x$ is NaN and does not raise floating-point exceptions.\n- In strict mode, exception side effects (such as setting the invalid flag) are part of the observable semantics and must be preserved. In ignore-exceptions mode, exception side effects are unobservable and may be altered as long as the Boolean result is preserved.\n- A proven “no NaNs possible for $x$” property implies $x$ is guaranteed to be numeric (finite or infinite) at the point of the comparison.\n\nWith these fundamentals, we analyze each option.\n\nOption A: For integer-typed $x$, rewrite $\\mathrm{eq}(x,x)$ to $\\mathrm{true}$.\n- By the reflexivity of equality on integers, for any integer $x$, $x = x$ holds, so $\\mathrm{eq}(x,x)$ computes $\\mathrm{true}$.\n- There are no floating-point exceptions involved, and integer equality has no side effects.\n- Therefore, replacing $\\mathrm{eq}(x,x)$ with the constant $\\mathrm{true}$ preserves both the value and side-effect semantics.\nVerdict: Correct.\n\nOption B: For floating-point-typed $x$ in strict mode, rewrite $\\mathrm{eq}(x,x)$ to $\\lnot \\mathrm{isNaN}(x)$.\n- For Boolean value: $\\mathrm{eq}(x,x)$ returns $\\mathrm{true}$ if $x$ is numeric and $\\mathrm{false}$ if $x$ is NaN. The expression $\\lnot \\mathrm{isNaN}(x)$ returns $\\mathrm{true}$ if $x$ is not NaN and $\\mathrm{false}$ if $x$ is NaN. Thus, the Boolean values match for all $x$.\n- For exception behavior: if $x$ is a signaling NaN, evaluating $\\mathrm{eq}(x,x)$ raises the invalid-operation exception. By assumption, $\\mathrm{isNaN}(x)$ does not raise exceptions. Therefore, the rewrite would remove the invalid exception that would have been raised by the original. In strict mode, this change is observable and disallowed.\nVerdict: Incorrect.\n\nOption C: For floating-point-typed $x$ in strict mode, if analysis proves “no NaNs possible for $x$,” rewrite $\\mathrm{eq}(x,x)$ to $\\mathrm{true}$.\n- Under the “no NaNs possible” assumption, $x$ is numeric (finite or infinite) at the comparison point.\n- For Boolean value: $\\mathrm{eq}(x,x)$ returns $\\mathrm{true}$ for numeric $x$; thus the constant $\\mathrm{true}$ matches the original.\n- For exception behavior: with $x$ guaranteed non-NaN, $\\mathrm{eq}(x,x)$ does not raise the invalid exception (only NaNs could cause it). Replacing with a constant avoids performing the comparison and thus raises no exception. Since the original also raises no exception under the assumption, exception behavior is preserved.\nVerdict: Correct.\n\nOption D: For floating-point-typed $x$ in ignore-exceptions mode, rewrite $\\mathrm{eq}(x,x)$ to $\\lnot \\mathrm{isNaN}(x)$.\n- For Boolean value: as in Option B, the values match for all $x$.\n- For exception behavior: if $x$ is a signaling NaN, the original $\\mathrm{eq}(x,x)$ would raise invalid; $\\mathrm{isNaN}(x)$ does not. However, in ignore-exceptions mode, exception flags are unobservable and traps are disabled, so changes to exception side effects are irrelevant to program semantics. There is no other observable difference introduced by $\\mathrm{isNaN}(x)$ under the given definition.\n- Therefore, in this mode, preserving only the Boolean value is sufficient, and the rewrite is allowed.\nVerdict: Correct.\n\nOption E: For floating-point-typed $x$, rewrite $\\mathrm{eq}(x,x)$ to $\\mathrm{true}$ unconditionally.\n- If $x$ is NaN (either quiet or signaling), the original $\\mathrm{eq}(x,x)$ evaluates to $\\mathrm{false}$, but the rewrite would produce $\\mathrm{true}$. This changes the computed Boolean value.\n- Consequently, this violates the semantics regardless of mode or exception observability.\nVerdict: Incorrect.\n\nTherefore, the semantics-preserving transformations are A, C, and D under their stated conditions.",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}