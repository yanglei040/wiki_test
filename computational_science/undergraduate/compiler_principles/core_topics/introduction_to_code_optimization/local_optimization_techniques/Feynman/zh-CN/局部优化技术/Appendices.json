{
    "hands_on_practices": [
        {
            "introduction": "编译器优化的核心任务之一是识别并简化复杂的表达式。本练习  将通过一个看似复杂的按位异或（XOR）运算序列，向你展示如何运用代数定律（如结合律、交换律和自反性）进行化简。这种基于代数恒等式的窥孔优化技术，能够显著减少指令数量，是提升代码效率的基础。",
            "id": "3651920",
            "problem": "一个优化编译器中的局部窥孔优化器正在分析一小块以静态单赋值（SSA）形式表示的中间表示（IR）。该IR使用脱字符号 $^$ 表示在 $w$ 位机器字上的按位异或（XOR）运算，而非幂运算。假设所有操作数都是纯值（无副作用），并且所有运算都作用于定宽无符号字，因此按位异或有明确定义。按位异或的语义是对应比特位的按位模2加法，其性质继承自模2加法，例如结合律、交换律以及存在单位元 $0$。\n\n该IR片段计算临时变量 $t_0$ 到 $t_5$ 如下：\n$$t_0 = a \\mathbin{^} b$$\n$$t_1 = t_0 \\mathbin{^} a$$\n$$t_2 = c \\mathbin{^} d$$\n$$t_3 = t_2 \\mathbin{^} c$$\n$$t_4 = t_1 \\mathbin{^} t_3$$\n$$t_5 = t_4 \\mathbin{^} d$$\n\n仅使用上述按位异或的基本性质以及适用于SSA形式下局部优化的推理方法，推导出以 $a$、$b$、$c$、$d$ 和任何可能的常数表示的 $t_5$ 计算值的最简闭式表达式。将最终答案表示为单个符号表达式。无需进行数值舍入。",
            "solution": "对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- **背景**：优化编译器中对静态单赋值（SSA）形式的中间表示（IR）进行的局部窥孔优化。\n- **运算符**：脱字符号 `$^$` 表示按位异或（XOR），而非幂运算。\n- **操作数**：所有操作数（$a$、$b$、$c$、$d$）都是作用于定宽 $w$ 位无符号机器字上的纯值。\n- **XOR的性质**：\n  - 结合律：$(x \\mathbin{^} y) \\mathbin{^} z = x \\mathbin{^} (y \\mathbin{^} z)$\n  - 交换律：$x \\mathbin{^} y = y \\mathbin{^} x$\n  - 单位元：$x \\mathbin{^} 0 = x$\n  - 自反性质：作为按位模2加法的一个推论，有 $x \\mathbin{^} x = 0$。\n- **IR 定义**：\n  $$t_0 = a \\mathbin{^} b$$\n  $$t_1 = t_0 \\mathbin{^} a$$\n  $$t_2 = c \\mathbin{^} d$$\n  $$t_3 = t_2 \\mathbin{^} c$$\n  $$t_4 = t_1 \\mathbin{^} t_3$$\n  $$t_5 = t_4 \\mathbin{^} d$$\n- **任务**：推导 $t_5$ 关于 $a$、$b$、$c$ 和 $d$ 的最简闭式表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，提法完善且客观。它基于计算机科学（编译器优化）和离散数学（按位异或运算的代数性质，它在 $w$ 位字的集合上构成一个阿贝尔群）的基本原理。使用静态单赋值（SSA）形式确保了每个临时变量只被定义一次，使得问题没有歧义。这些定义是自洽且一致的。没有违反任何科学定律，也没有信息缺失或矛盾。该问题是表达式简化的一个标准练习，这是优化编译器的一项常见任务。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 求解推导\n目标是找到最终临时变量 $t_5$ 的简化表达式。这将通过代入中间临时变量的定义并应用按位异或运算的代数性质来实现。代码采用SSA形式这一事实至关重要，因为它允许直接代入，因为每个变量只有一个定义点。\n\n最终的计算是：\n$$t_5 = t_4 \\mathbin{^} d$$\n\n我们首先代入 $t_4$ 的表达式：\n$$t_5 = (t_1 \\mathbin{^} t_3) \\mathbin{^} d$$\n\n接着，我们代入 $t_1$ 和 $t_3$ 的表达式：\n$$t_5 = ((t_0 \\mathbin{^} a) \\mathbin{^} (t_2 \\mathbin{^} c)) \\mathbin{^} d$$\n\n根据XOR的结合律，可以移除分组的括号：\n$$t_5 = t_0 \\mathbin{^} a \\mathbin{^} t_2 \\mathbin{^} c \\mathbin{^} d$$\n\n现在，我们代入 $t_0$ 和 $t_2$ 的初始表达式：\n$$t_5 = (a \\mathbin{^} b) \\mathbin{^} a \\mathbin{^} (c \\mathbin{^} d) \\mathbin{^} c \\mathbin{^} d$$\n\n再次应用结合律，我们移除所有括号：\n$$t_5 = a \\mathbin{^} b \\mathbin{^} a \\mathbin{^} c \\mathbin{^} d \\mathbin{^} c \\mathbin{^} d$$\n\n使用XOR的交换律，我们可以重新排序各项，将相同的变量组合在一起：\n$$t_5 = (a \\mathbin{^} a) \\mathbin{^} b \\mathbin{^} (c \\mathbin{^} c) \\mathbin{^} (d \\mathbin{^} d)$$\n\n现在我们将自反性质 $x \\mathbin{^} x = 0$ 应用于每一对相同的变量：\n- $a \\mathbin{^} a = 0$\n- $c \\mathbin{^} c = 0$\n- $d \\mathbin{^} d = 0$\n\n将这些结果代入 $t_5$ 的表达式中：\n$$t_5 = 0 \\mathbin{^} b \\mathbin{^} 0 \\mathbin{^} 0$$\n\n最后，我们应用单位元性质 $x \\mathbin{^} 0 = x$。通过重复应用此性质，我们可以简化表达式：\n$$t_5 = (0 \\mathbin{^} b) \\mathbin{^} (0 \\mathbin{^} 0)$$\n$$t_5 = b \\mathbin{^} 0$$\n$$t_5 = b$$\n\n整个看似复杂的计算序列，简化为单个变量 $b$。执行此分析的窥孔优化器会将整个代码块替换为单个赋值语句 `t_5 = b`（或者更可能地，将所有对 $t_5$ 的使用替换为 $b$），从而消除六条指令和五个临时变量。",
            "answer": "$$\\boxed{b}$$"
        },
        {
            "introduction": "强度削减是一种经典的局部优化技术，旨在用计算成本更低的操作（“弱”操作）替代等效的高成本操作（“强”操作）。在本练习  中，你将扮演编译器的角色，将一个整数乘以常数的操作，转换为一系列更高效的位移和加法指令。这个过程不仅能让你深入理解整数的二进制表示，还能体会到编译器如何根据目标机器的指令成本模型做出优化决策。",
            "id": "3651960",
            "problem": "一个用于无符号整数的编译器后端，在固定成本的机器模型下，使用局部强度削减技术，将乘以常数的操作替换为更廉价的移位-加法序列。考虑计算以下值的基本块\n- $r \\leftarrow \\left(x \\cdot \\left(1 \\ll 7\\right)\\right) + \\left(x \\cdot 45\\right) - \\left(x \\cdot 77\\right)$\n其中 $x$ 是一个无符号 $w$ 位整数，并且所有算术运算都在模 $2^{w}$ 下进行。目标机器提供：\n- 左移一个非负常数 $k$，写作 $y \\ll k$，成本为 $c_{s} = 2$，\n- 两个 $w$ 位值的加法或减法，成本为 $c_{a} = 3$，\n- 但不提供通用整数乘法指令。\n\n局部优化器在每个乘法点独立应用以下语义保持的重写规则（各个点之间不共享中间结果，并且不对给定的顶层 $+$ 和 $-$ 运算符进行重组）：\n- 对于任何非负整数 $k$，使用模-$2^{w}$ 算术恒等式将 $x \\cdot 2^{k}$ 替换为 $x \\ll k$。\n- 对于任何其他正整数常数 $m$，将其表示为规范有符号数位（CSD）形式（也称为非相邻形式），即 $m = \\sum_{i=1}^{t} s_{i} 2^{a_{i}}$，其中 $s_{i} \\in \\{-1, +1\\}$，指数 $0 \\le a_{1}  \\cdots  a_{t}$ 严格递增，并且没有两个相邻的幂次同时存在。相应地，将 $x \\cdot m$ 实现为移位值 $(x \\ll a_{i})$ 的加法和减法运算。\n\n在这些假设下，计算评估该基本块的确切总动态指令成本，计算在上述局部重写后出现的每一次左移和每一次加法或减法。你的最终答案必须是给出此总成本的单个整数。",
            "solution": "用户想要计算在一个具有特定指令成本模型和一组局部优化规则的处理器上，评估一个给定表达式的总动态指令成本。\n\n该问题是有效的，因为它在编译器理论中有科学依据，具有清晰客观的规则集，问题提法得当，且没有矛盾或歧义。我将继续进行解答。\n\n需要评估的表达式是：\n$$r \\leftarrow \\left(x \\cdot \\left(1 \\ll 7\\right)\\right) + \\left(x \\cdot 45\\right) - \\left(x \\cdot 77\\right)$$\n可用指令的成本如下：\n- 左移一个常数 $k$，$y \\ll k$：$c_s = 2$。\n- 加法或减法：$c_a = 3$。\n\n问题陈述，局部优化器独立处理每个乘法点，它们之间不共享中间结果，也不对顶层加法和减法进行重组。这意味着我们必须分别计算三个乘法项中每一个的成本，然后加上最后两个顶层操作的成本。\n\n总成本 $C_{\\text{total}}$ 可以表示为：\n$$C_{\\text{total}} = C(x \\cdot (1 \\ll 7)) + C(x \\cdot 45) + C(x \\cdot 77) + C_{\\text{top-level}}$$\n顶层操作包括一次加法和一次减法，这在三个乘法被评估后执行。\n$$C_{\\text{top-level}} = c_a + c_a = 3 + 3 = 6$$\n\n我们现在计算每个乘法项的成本。\n\n**1. $x \\cdot (1 \\ll 7)$ 的成本**\n\n首先，评估常数：$1 \\ll 7$ 是 $1 \\cdot 2^7 = 128$。\n该操作是 $x \\cdot 128$。\n根据第一条优化规则，乘法 $x \\cdot 2^k$ 被替换为左移 $x \\ll k$。这里，$k=7$。\n所以，$x \\cdot 128$ 被替换为 $x \\ll 7$。\n这是一个单独的左移操作。其成本是：\n$$C(x \\cdot 128) = c_s = 2$$\n\n**2. $x \\cdot 45$ 的成本**\n\n常数是 $m=45$。因为它不是2的幂，我们必须使用第二条规则，这涉及到寻找 $45$ 的规范有符号数位（CSD）形式。一个数 $m$ 的CSD表示是一个和 $m = \\sum_{i=0}^{N} s_i 2^i$，其中 $s_i \\in \\{-1, 0, 1\\}$ 并且没有两个连续的数字 $s_i, s_{i+1}$ 是非零的。\n\n让我们来找 $45$ 的CSD。一个标准的算法是重复检查数字的两个最低有效位。设 $m_0=45$。\n- 对于 $i=0$：$m_0 = 45$。$m_0 \\pmod 4 = 1$。CSD数位是 $s_0=1$。我们将数字更新为 $m_1 = (m_0 - s_0)/2 = (45 - 1)/2 = 22$。\n- 对于 $i=1$：$m_1 = 22$。$m_1$ 是偶数，所以 $s_1=0$。我们更新为 $m_2 = m_1/2 = 11$。\n- 对于 $i=2$：$m_2 = 11$。$m_2 \\pmod 4 = 3$。CSD数位是 $s_2=-1$。我们更新为 $m_3 = (m_2 - s_2)/2 = (11 - (-1))/2 = 6$。\n- 对于 $i=3$：$m_3 = 6$。$m_3$ 是偶数，所以 $s_3=0$。我们更新为 $m_4 = m_3/2 = 3$。\n- 对于 $i=4$：$m_4 = 3$。$m_4 \\pmod 4 = 3$。CSD数位是 $s_4=-1$。我们更新为 $m_5 = (m_4 - s_4)/2 = (3 - (-1))/2 = 2$。\n- 对于 $i=5$：$m_5 = 2$。$m_5$ 是偶数，所以 $s_5=0$。我们更新为 $m_6 = m_5/2 = 1$。\n- 对于 $i=6$：$m_6 = 1$。$m_6 \\pmod 4 = 1$。CSD数位是 $s_6=1$。我们更新为 $m_7 = (m_6-s_6)/2 = (1-1)/2 = 0$。过程终止。\n\n$45$ 的CSD表示为：\n$$45 = 1 \\cdot 2^6 - 1 \\cdot 2^4 - 1 \\cdot 2^2 + 1 \\cdot 2^0 = 64 - 16 - 4 + 1$$\n有 $t=4$ 个非零项。\n$x \\cdot 45$ 的计算被重写为 $x \\cdot (2^6 - 2^4 - 2^2 + 2^0)$，其实现为：\n$$(x \\ll 6) - (x \\ll 4) - (x \\ll 2) + (x \\ll 0)$$\n这个序列需要 $t=4$ 次左移操作和 $t-1=3$ 次加/减操作。成本是：\n$$C(x \\cdot 45) = (4 \\cdot c_s) + (3 \\cdot c_a) = (4 \\cdot 2) + (3 \\cdot 3) = 8 + 9 = 17$$\n\n**3. $x \\cdot 77$ 的成本**\n\n常数是 $m=77$。我们使用相同的算法找到它的CSD形式。设 $m_0=77$。\n- 对于 $i=0$：$m_0 = 77$。$m_0 \\pmod 4 = 1$。所以 $s_0=1$。$m_1 = (77-1)/2 = 38$。\n- 对于 $i=1$：$m_1 = 38$。$s_1=0$。$m_2 = 38/2 = 19$。\n- 对于 $i=2$：$m_2 = 19$。$m_2 \\pmod 4 = 3$。所以 $s_2=-1$。$m_3 = (19-(-1))/2 = 10$。\n- 对于 $i=3$：$m_3 = 10$。$s_3=0$。$m_4 = 10/2 = 5$。\n- 对于 $i=4$：$m_4 = 5$。$m_4 \\pmod 4 = 1$。所以 $s_4=1$。$m_5 = (5-1)/2 = 2$。\n- 对于 $i=5$：$m_5 = 2$。$s_5=0$。$m_6 = 2/2 = 1$。\n- 对于 $i=6$：$m_6 = 1$。$m_6 \\pmod 4 = 1$。所以 $s_6=1$。$m_7 = (1-1)/2 = 0$。\n\n$77$ 的CSD表示为：\n$$77 = 1 \\cdot 2^6 + 1 \\cdot 2^4 - 1 \\cdot 2^2 + 1 \\cdot 2^0 = 64 + 16 - 4 + 1$$\n有 $t=4$ 个非零项。\n$x \\cdot 77$ 的计算被重写为：\n$$(x \\ll 6) + (x \\ll 4) - (x \\ll 2) + (x \\ll 0)$$\n这个序列需要 $t=4$ 次左移和 $t-1=3$ 次加/减法。成本是：\n$$C(x \\cdot 77) = (4 \\cdot c_s) + (3 \\cdot c_a) = (4 \\cdot 2) + (3 \\cdot 3) = 8 + 9 = 17$$\n\n**4. 总成本**\n\n我们将所有部分的成本相加：\n$$C_{\\text{total}} = C(x \\cdot 128) + C(x \\cdot 45) + C(x \\cdot 77) + C_{\\text{top-level}}$$\n$$C_{\\text{total}} = 2 + 17 + 17 + 6$$\n$$C_{\\text{total}} = 42$$\n\n评估该基本块的总动态指令成本是 $42$。",
            "answer": "$$ \\boxed{42} $$"
        },
        {
            "introduction": "一个看似无懈可击的优化，有时会因底层数据类型的特殊语义而失效。本练习  探讨了将 $x == x$ 优化为 `true` 这一常见模式的有效性。虽然这个变换对整数总是安全的，但 IEEE 754 浮点标准中的“非数值”（NaN）给它带来了挑战，深刻揭示了优化必须严格遵守语言和硬件规范的重要性。",
            "id": "3651963",
            "problem": "一种类型化的中间表示（IR）使用二元相等运算符 $\\mathrm{eq}(x,y)$，它返回一个布尔值 $\\mathrm{true}$ 或 $\\mathrm{false}$。该 IR 与语言无关，但遵循以下广为接受的语义：\n\n- 对于整数类型，相等性由标准自反律定义：对于任何整数值 $x$，$x = x$ 成立。求值整数相等性没有副作用。\n- 对于浮点类型，该 IR 遵循电气和电子工程师协会（IEEE）$754$ 浮点算术的语义。设 $x$ 为一个浮点值。\n  - 如果 $x$ 是一个有限数或无穷大，那么 $x = x$ 成立，且比较返回 $\\mathrm{true}$，不产生浮点异常。\n  - 如果 $x$ 是非数值（NaN），那么 $x = x$ 不成立，且 $\\mathrm{eq}(x,x)$ 返回 $\\mathrm{false}$。如果 $x$ 是一个信令 NaN（sNaN），求值一个有序比较（如 $x == x$）会引发无效操作异常（设置无效状态标志）并为了该操作的目的在内部将 NaN 静默化。如果 $x$ 是一个静默 NaN（qNaN），则不会引发异常。\n  - IR 中提供了一个分类谓词 $\\mathrm{isNaN}(x)$，当且仅当 $x$ 是 NaN（无论是静默型还是信令型）时，它返回 $\\mathrm{true}$。它被定义为一个非算术分类操作，不会引发任何浮点异常。\n\n考虑两种编译模式：\n- 严格模式（Strict mode）：程序可能会观察浮点状态标志（例如，通过浮点环境 API），因此转换必须同时保留计算出的布尔值和任何异常副作用。\n- 忽略异常模式（Ignore-exceptions mode）：程序无法观察浮点状态标志且陷阱被禁用；只有计算出的布尔值是重要的。\n\n另外，优化器可能会运行数据流分析，以证明一个变量在给定区域内是非 NaN 的。属性“$x$ 不可能是 NaN”意味着在程序点上，$x$ 被保证既不是静默 NaN 也不是信令 NaN。\n\n考虑对模式 $\\mathrm{eq}(x,x)$ 应用局部优化。在所述条件下，以下哪种转换场景是语义保持的？\n\nA. 对于整数类型的 $x$，将 $\\mathrm{eq}(x,x)$ 重写为常量 $\\mathrm{true}$。\n\nB. 对于严格模式下的浮点类型 $x$，将 $\\mathrm{eq}(x,x)$ 重写为 $\\lnot \\mathrm{isNaN}(x)$。\n\nC. 对于严格模式下的浮点类型 $x$，如果分析证明在程序点上“$x$ 不可能是 NaN”，则将 $\\mathrm{eq}(x,x)$ 重写为常量 $\\mathrm{true}$。\n\nD. 对于忽略异常模式下的浮点类型 $x$，将 $\\mathrm{eq}(x,x)$ 重写为 $\\lnot \\mathrm{isNaN}(x)$。\n\nE. 对于浮点类型的 $x$，无条件地将 $\\mathrm{eq}(x,x)$ 重写为常量 $\\mathrm{true}$。\n\n选择所有正确的选项。",
            "solution": "我们从核心定义和事实开始分析：\n\n- 整数相等性是自反的：对于任何整数 $x$，$x = x$。对整数求值相等性除了产生布尔结果外没有其他副作用。\n- IEEE $754$ 浮点语义：\n  - 像 $x == x$ 这样的有序比较对所有数值 $x$（有限或无穷）产生 $\\mathrm{true}$，对任何 $\\mathrm{NaN}$ 产生 $\\mathrm{false}$。\n  - 对于信令 NaN $x$，有序比较会引发无效操作异常（设置无效标志）。对于静默 NaN $x$，有序比较不会引发异常。\n  - 分类谓词 $\\mathrm{isNaN}(x)$ 在此被定义为一个非算术测试，它仅在 $x$ 是 NaN 时返回 $\\mathrm{true}$，并且不引发浮点异常。\n- 在严格模式下，异常副作用（例如设置无效标志）是可观察语义的一部分，必须被保留。在忽略异常模式下，异常副作用是不可观察的，只要布尔结果被保留，就可以被改变。\n- 一个已证明的“$x$ 不可能是 NaN”属性意味着在比较点上，$x$ 被保证是数值（有限或无穷）。\n\n基于这些基本原则，我们分析每个选项。\n\n选项 A: 对于整数类型的 $x$，将 $\\mathrm{eq}(x,x)$ 重写为 $\\mathrm{true}$。\n- 根据整数相等性的自反律，对于任何整数 $x$，$x = x$ 成立，所以 $\\mathrm{eq}(x,x)$ 计算结果为 $\\mathrm{true}$。\n- 不涉及浮点异常，且整数相等性没有副作用。\n- 因此，用常量 $\\mathrm{true}$ 替换 $\\mathrm{eq}(x,x)$ 保留了值和副作用两方面的语义。\n结论：正确。\n\n选项 B: 对于严格模式下的浮点类型 $x$，将 $\\mathrm{eq}(x,x)$ 重写为 $\\lnot \\mathrm{isNaN}(x)$。\n- 对于布尔值：如果 $x$ 是数值，$\\mathrm{eq}(x,x)$ 返回 $\\mathrm{true}$；如果 $x$ 是 NaN，则返回 $\\mathrm{false}$。表达式 $\\lnot \\mathrm{isNaN}(x)$ 在 $x$ 不是 NaN 时返回 $\\mathrm{true}$，在 $x$ 是 NaN 时返回 $\\mathrm{false}$。因此，对于所有 $x$，布尔值是匹配的。\n- 对于异常行为：如果 $x$ 是一个信令 NaN，求值 $\\mathrm{eq}(x,x)$ 会引发无效操作异常。根据假设，$\\mathrm{isNaN}(x)$ 不会引发异常。因此，重写会移除原操作本应引发的无效异常。在严格模式下，这种改变是可观察的，因此是不允许的。\n结论：不正确。\n\n选项 C: 对于严格模式下的浮点类型 $x$，如果分析证明“$x$ 不可能是 NaN”，则将 $\\mathrm{eq}(x,x)$ 重写为 $\\mathrm{true}$。\n- 在“不可能是 NaN”的假设下，$x$ 在比较点上是数值（有限或无穷）。\n- 对于布尔值：对于数值 $x$，$\\mathrm{eq}(x,x)$ 返回 $\\mathrm{true}$；因此常量 $\\mathrm{true}$ 与原始值匹配。\n- 对于异常行为：由于保证 $x$ 非 NaN，$\\mathrm{eq}(x,x)$ 不会引发无效异常（只有 NaN 会导致）。替换为常量避免了执行比较，因此也不会引发异常。既然在假设下原始表达式也不引发异常，那么异常行为得以保留。\n结论：正确。\n\n选项 D: 对于忽略异常模式下的浮点类型 $x$，将 $\\mathrm{eq}(x,x)$ 重写为 $\\lnot \\mathrm{isNaN}(x)$。\n- 对于布尔值：与选项 B 中一样，对于所有 $x$ 值都匹配。\n- 对于异常行为：如果 $x$ 是一个信令 NaN，原始的 $\\mathrm{eq}(x,x)$ 会引发无效异常；而 $\\mathrm{isNaN}(x)$ 不会。然而，在忽略异常模式下，异常标志是不可观察的，并且陷阱被禁用，因此对异常副作用的更改与程序语义无关。根据给定的定义，$\\mathrm{isNaN}(x)$ 不会引入其他可观察的差异。\n- 因此，在这种模式下，仅保留布尔值就足够了，这种重写是允许的。\n结论：正确。\n\n选项 E: 对于浮点类型的 $x$，无条件地将 $\\mathrm{eq}(x,x)$ 重写为 $\\mathrm{true}$。\n- 如果 $x$ 是 NaN（静默型或信令型），原始的 $\\mathrm{eq}(x,x)$ 求值为 $\\mathrm{false}$，但重写会产生 $\\mathrm{true}$。这改变了计算出的布尔值。\n- 因此，无论在哪种模式或异常是否可观察，这都违反了语义。\n结论：不正确。\n\n因此，在所述条件下，保持语义的转换是 A、C 和 D。",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}