{
    "hands_on_practices": [
        {
            "introduction": "Building an accurate interference graph is the cornerstone of graph-coloring register allocation. This first practice problem challenges you to apply liveness analysis to a program with branching control flow. By calculating the live sets at each program point, you will determine the correct set of interferences and identify which ones are missing from a given faulty graph, a crucial skill for debugging a compiler's backend. ",
            "id": "3647421",
            "problem": "A compiler back end constructs an interference graph for register allocation by using liveness analysis over a Control Flow Graph (CFG). Two program variables interfere if and only if their live ranges overlap at some program point, meaning they are simultaneously live with respect to the standard definition of liveness in non-Static Single Assignment (non-SSA) form.\n\nConsider the following imperative program with four basic blocks (BB), annotated by line numbers and branch labels. The program uses assignment statements and a single conditional branch. Each assignment $v := \\text{expr}$ defines the left-hand variable $v$ and uses all variables appearing in $\\text{expr}$. There are no function calls, no aliasing, and no memory side effects other than those implied by assignments.\n\nBlock $B_1$:\n- Line $1$: $d := a + 1$\n- Line $2$: $b := d + c$\n- Line $3$: $x := b + e$\n- Line $4$: if $(x  m)$ goto $B_2$ else goto $B_3$\n\nBlock $B_2$ (taken when the condition in line $4$ is true):\n- Line $5$: $y := x + c$\n- Line $6$: $t := y + n$\n- Line $7$: $b := t + a$\n- Line $8$: goto $B_4$\n\nBlock $B_3$ (taken when the condition in line $4$ is false):\n- Line $9$: $y := m + c$\n- Line $10$: $x := y + a$\n- Line $11$: $t := x + p$\n- Line $12$: goto $B_4$\n\nBlock $B_4$ (join block):\n- Line $13$: $z := x + y$\n- Line $14$: $r := z + b$\n- Line $15$: return $r$\n\nAssume that only the temporaries $\\{b, x, y, t, z\\}$ are considered for graph construction; all other identifiers ($a, c, d, e, m, n, p, r$) are treated as external values or precolored registers and do not contribute nodes to the interference graph. The compiler’s purported interference graph $G$ over nodes $\\{b, x, y, t, z\\}$ currently contains exactly the edges\n$$\n\\{(t,x),\\ (t,y),\\ (z,b)\\}.\n$$\n\nUsing the standard non-SSA liveness definition, a variable is live at a program point if and only if there exists a path from that point to a subsequent use of the variable before any redefinition of that variable along that path. Two variables interfere if and only if there exists at least one program point at which both variables are simultaneously live.\n\nYour task: Recompute liveness at program points where $x$ and $y$ are simultaneously live, determine all interference edges involving $x$ and $y$ that must exist as a result, and compare with the edges given in $G$. Compute, as a single integer, the number of missing edges in $G$ relative to the correct interference graph induced by $\\{b, x, y, t, z\\}$. Express your final answer as an exact integer; no rounding is required.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of compiler theory, specifically liveness analysis and interference graph construction. It is well-posed, objective, and provides all necessary information to derive a unique solution.\n\nThe task is to determine the correct interference graph for the set of variables $\\{b, x, y, t, z\\}$ and find the number of edges missing from a given graph $G$. Two variables interfere if they are simultaneously live at any program point. A variable is live at a point if there is a path from that point to a use of the variable that is not intercepted by a redefinition.\n\nThe analysis proceeds by computing the set of live variables at the entry and exit of each instruction, working backward from the end of the program. The Control Flow Graph (CFG) has block $B_1$ as the entry, which branches to $B_2$ and $B_3$. Both $B_2$ and $B_3$ branch to the join block $B_4$, which is the exit block.\n\nLet $\\text{LiveAfter}(i)$ be the set of variables live immediately after instruction $i$. For an instruction $i$, $\\text{def}(i)$ is the set of variables it defines and $\\text{use}(i)$ is the set of variables it uses. The set of variables live immediately before instruction $i$ is given by the standard dataflow equation:\n$$\n\\text{LiveBefore}(i) = \\text{use}(i) \\cup (\\text{LiveAfter}(i) - \\text{def}(i))\n$$\nAny variable in $\\text{def}(i)$ interferes with every variable in $\\text{LiveAfter}(i)$. Also, any two variables that are members of the same $\\text{LiveAfter}(i)$ set interfere. We will compute these sets for each instruction, considering only the variables of interest: $\\{b, x, y, t, z\\}$.\n\nThe analysis starts from the end of the program. After the last instruction (line $15$), no variables are live.\n$\\text{LiveAfter}(15) = \\emptyset$.\n\n**Block $B_4$ (lines $13$-$15$):**\n- **Line $15$: `return r`**: `def(15) = \\emptyset`, `use(15) = \\emptyset` (variable $r$ is not in our set).\n$\\text{LiveBefore}(15) = \\emptyset \\cup (\\emptyset - \\emptyset) = \\emptyset$.\n- **Line $14$: `r := z + b`**: `def(14) = \\emptyset`, `use(14) = \\{z, b\\}$.\n$\\text{LiveAfter}(14) = \\text{LiveBefore}(15) = \\emptyset$.\n$\\text{LiveBefore}(14) = \\{z, b\\} \\cup (\\emptyset - \\emptyset) = \\{z, b\\}$.\n- **Line $13$: `z := x + y`**: `def(13) = \\{z\\}$, `use(13) = \\{x, y\\}$.\n$\\text{LiveAfter}(13) = \\text{LiveBefore}(14) = \\{z, b\\}$. At this program point, variables $z$ and $b$ are simultaneously live. This implies an interference edge $(z, b)$. The definition of $z$ also interferes with other variables live after line $13$, which is just $b$. This confirms the edge **$(z, b)$**.\n$\\text{LiveBefore}(13) = \\{x, y\\} \\cup (\\{z, b\\} - \\{z\\}) = \\{x, y, b\\}$. This is the set of variables live at the entry to block $B_4$.\n\nThe set of live variables at the entry to $B_4$, $\\text{Live}_{\\text{in}}(B_4)$, is $\\{x, y, b\\}$. Since $B_4$ is the successor to both $B_2$ and $B_3$, we have $\\text{Live}_{\\text{out}}(B_2) = \\text{Live}_{\\text{out}}(B_3) = \\text{Live}_{\\text{in}}(B_4) = \\{x, y, b\\}$.\n\n**Block $B_3$ (lines $9$-$12$):**\nWe work backward from the end of the block, where the live set is $\\text{Live}_{\\text{out}}(B_3) = \\{x, y, b\\}$.\n- **Line $12$: `goto B4`**: `def(12) = \\emptyset`, `use(12) = \\emptyset$.\n$\\text{LiveAfter}(12) = \\{x, y, b\\}$.\n$\\text{LiveBefore}(12) = \\emptyset \\cup (\\{x, y, b\\} - \\emptyset) = \\{x, y, b\\}$.\n- **Line $11$: `t := x + p`**: `def(11) = \\{t\\}$, `use(11) = \\{x\\}$.\nA critical observation is that the variable $t$ defined at line $11$ is never used subsequently. According to the liveness definition, this instance of $t$ is a dead variable; its live range is empty. Therefore, it cannot interfere with any other variable.\n$\\text{LiveAfter}(11) = \\text{LiveBefore}(12) = \\{x, y, b\\}$. At this point, variables $x$, $y$, and $b$ are simultaneously live. This implies the interference edges **$(x, y)$**, **$(x, b)$**, and **$(y, b)$**.\n$\\text{LiveBefore}(11) = \\{x\\} \\cup (\\{x, y, b\\} - \\{t\\}) = \\{x, y, b\\}$.\n- **Line $10$: `x := y + a`**: `def(10) = \\{x\\}$, `use(10) = \\{y\\}$.\n$\\text{LiveAfter}(10) = \\text{LiveBefore}(11) = \\{x, y, b\\}$. The definition of $x$ interferes with other variables in this set, which are $\\{y, b\\}$. This confirms edges **$(x, y)$** and **$(x, b)$**.\n$\\text{LiveBefore}(10) = \\{y\\} \\cup (\\{x, y, b\\} - \\{x\\}) = \\{y, b\\}$.\n- **Line $9$: `y := m + c`**: `def(9) = \\{y\\}$, `use(9) = \\emptyset$.\n$\\text{LiveAfter}(9) = \\text{LiveBefore}(10) = \\{y, b\\}$. At this point, $y$ and $b$ are live, implying edge **$(y, b)$**. The definition of $y$ interferes with $b$.\n$\\text{LiveBefore}(9) = \\emptyset \\cup (\\{y, b\\} - \\{y\\}) = \\{b\\}$. This is $\\text{Live}_{\\text{in}}(B_3)$.\n\n**Block $B_2$ (lines $5$-$8$):**\nWe work backward from the end of the block, where the live set is $\\text{Live}_{\\text{out}}(B_2) = \\{x, y, b\\}$.\n- **Line $8$: `goto B4`**:\n$\\text{LiveAfter}(8) = \\{x, y, b\\}$. Live variables imply edges **$(x, y)$**, **$(x, b)$**, and **$(y, b)$**.\n$\\text{LiveBefore}(8) = \\{x, y, b\\}$.\n- **Line $7$: `b := t + a`**: `def(7) = \\{b\\}$, `use(7) = \\{t\\}$.\n$\\text{LiveAfter}(7) = \\text{LiveBefore}(8) = \\{x, y, b\\}$. The definition of $b$ interferes with $\\{x, y\\}$. This yields edges **$(b, x)$** and **$(b, y)$**.\n$\\text{LiveBefore}(7) = \\{t\\} \\cup (\\{x, y, b\\} - \\{b\\}) = \\{t, x, y\\}$.\n- **Line $6$: `t := y + n`**: `def(6) = \\{t\\}$, `use(6) = \\{y\\}$.\n$\\text{LiveAfter}(6) = \\text{LiveBefore}(7) = \\{t, x, y\\}$. At this point, $t$, $x$, and $y$ are simultaneously live, implying edges **$(t, x)$**, **$(t, y)$**, and **$(x, y)$**.\n$\\text{LiveBefore}(6) = \\{y\\} \\cup (\\{t, x, y\\} - \\{t\\}) = \\{x, y\\}$.\n- **Line $5$: `y := x + c`**: `def(5) = \\{y\\}$, `use(5) = \\{x\\}$.\n$\\text{LiveAfter}(5) = \\text{LiveBefore}(6) = \\{x, y\\}$. This implies edge **$(x, y)$**.\n$\\text{LiveBefore}(5) = \\{x\\} \\cup (\\{x, y\\} - \\{y\\}) = \\{x\\}$. This is $\\text{Live}_{\\text{in}}(B_2)$.\n\n**Block $B_1$ (lines $1$-$4$):**\nThe set of live variables at the exit of $B_1$ is $\\text{Live}_{\\text{out}}(B_1) = \\text{Live}_{\\text{in}}(B_2) \\cup \\text{Live}_{\\text{in}}(B_3) = \\{x\\} \\cup \\{b\\} = \\{x, b\\}$.\n- **Line $4$: `if (x  m) ...`**: `def(4) = \\emptyset`, `use(4) = \\{x\\}$.\n$\\text{LiveAfter}(4) = \\{x, b\\}$. At this point, $x$ and $b$ are live, implying an edge **$(x, b)$**.\n$\\text{LiveBefore}(4) = \\{x\\} \\cup (\\{x, b\\} - \\emptyset) = \\{x, b\\}$.\n- **Line $3$: `x := b + e`**: `def(3) = \\{x\\}$, `use(3) = \\{b\\}$.\n$\\text{LiveAfter}(3) = \\text{LiveBefore}(4) = \\{x, b\\}$. The definition of $x$ interferes with $b$, confirming edge **$(x, b)$**.\n$\\text{LiveBefore}(3) = \\{b\\} \\cup (\\{x, b\\} - \\{x\\}) = \\{b\\}$.\n- **Line $2$: `b := d + c`**: `def(2) = \\{b\\}$, `use(2) = \\emptyset$.\n$\\text{LiveAfter}(2) = \\text{LiveBefore}(3) = \\{b\\}$. No interferences.\n$\\text{LiveBefore}(2) = \\emptyset \\cup (\\{b\\} - \\{b\\}) = \\emptyset$.\n- **Line $1$: `d := a + 1`**: Does not involve any variables from our set. $\\text{LiveBefore}(1) = \\emptyset$.\n\n**Consolidating the Edges:**\nWe collect all unique interference edges identified:\n1. $(z, b)$, also written as $(b, z)$.\n2. $(x, y)$.\n3. $(x, b)$, also written as $(b, x)$.\n4. $(y, b)$, also written as $(b, y)$.\n5. $(t, x)$.\n6. $(t, y)$.\n\nThe complete set of edges in the correct interference graph is $E_{\\text{correct}} = \\{(b, z), (x, y), (x, b), (y, b), (t, x), (t, y)\\}$.\nThe number of correct edges is $|E_{\\text{correct}}| = 6$.\n\n**Comparison with the Given Graph:**\nThe problem states the given interference graph $G$ has edges $E_{\\text{given}} = \\{(t,x), (t,y), (z,b)\\}$.\nTo find the missing edges, we compute the set difference $E_{\\text{correct}} - E_{\\text{given}}$.\n$$\nE_{\\text{missing}} = \\{(b, z), (x, y), (x, b), (y, b), (t, x), (t, y)\\} - \\{(t, x), (t, y), (z, b)\\}\n$$\nThe edges from $E_{\\text{correct}}$ that are not in $E_{\\text{given}}$ are:\n- $(x, y)$\n- $(x, b)$\n- $(y, b)$\n\nThe number of missing edges is the cardinality of this set, which is $3$.",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "The correctness of liveness analysis hinges on the precise application of its dataflow equations. This exercise focuses on a common conceptual pitfall: how to merge liveness information at control-flow join points. You will analyze the consequences of using an incorrect set operation and, by comparing it to the correct method, gain a deeper appreciation for why a set union is essential to capture all possible future uses of a variable. ",
            "id": "3647411",
            "problem": "A compiler backend implements register allocation by graph coloring over an interference graph constructed from liveness information on a Control-Flow Graph (CFG). Consider the following straight-line code with a conditional split and a join, written as basic blocks with labeled instructions. Assignment is written with $:=$. The CFG has edges from the end of $B_1$ to the starts of $B_2$ and $B_3$, from the ends of $B_2$ and $B_3$ to the start of $B_4$, and $B_4$ falls through to a return.\n\nBasic blocks:\n- $B_1$:\n  - Instruction $1$: $u := x + y$\n  - Instruction $2$: \\textit{if} $u > 0$ \\textit{goto} $B_2$ \\textit{else} $B_3$\n- $B_2$:\n  - Instruction $3$: $v := u + z$\n  - Instruction $4$: $w := v + 1$\n  - Instruction $5$: \\textit{goto} $B_4$\n- $B_3$:\n  - Instruction $6$: $v := u + 1$\n  - Instruction $7$: $w := v + y$\n  - Instruction $8$: \\textit{goto} $B_4$\n- $B_4$:\n  - Instruction $9$: $x := w + 1$\n  - Instruction $10$: \\textit{return} $x$\n\nAssume variables $x$, $y$, and $z$ are live on entry to $B_1$ and there are no other external uses except the explicit uses shown. The interference graph $G = (V,E)$ has a vertex for each variable in $\\{x,y,z,u,v,w\\}$, and an undirected edge $\\{a,b\\} \\in E$ whenever variables $a$ and $b$ cannot be assigned the same register because they are simultaneously live at some program point according to the standard instruction-level interference construction rule: for each instruction that defines a variable $d$, add edges between $d$ and every variable in the live-out set immediately after that instruction.\n\nA teammate performed a faulty liveness analysis by mistakenly computing the live-out set at the conditional in instruction $2$ using a set intersection over successors instead of a set union. Concretely, at the join arising from instruction $2$, they set\n$$\\mathrm{live\\_out}[2] = \\mathrm{live\\_in}[3] \\cap \\mathrm{live\\_in}[6],$$\nand then built an interference graph $G_f = (V,E_f)$ with the rule above. They reported that $E_f$ contains only the edge $\\{v,y\\}$.\n\nUsing the correct backward dataflow equations for liveness at the instruction level and the interference edge construction rule stated above, determine the exact number of missing edges, that is, compute the integer value of $|E \\setminus E_f|$. Provide your answer as a single integer. Do not round.",
            "solution": "The problem as stated is valid. It presents a well-defined scenario within the domain of compiler construction, specifically liveness analysis and interference graph generation. All necessary data, including the code, Control-Flow Graph (CFG) structure, initial liveness conditions, and the specific rules for constructing the graph, are provided. The task is to compare a correctly constructed graph with a faulty one and quantify the difference.\n\nThe core of the problem lies in applying the principles of backward dataflow analysis to determine the set of live variables at various points in the program, and then using a specified rule to construct the interference graphs. We must first perform a correct liveness analysis, then replicate the faulty analysis, build the corresponding interference graphs for both cases, and finally compute the number of edges missing from the faulty graph.\n\nThe variables involved are $V = \\{x, y, z, u, v, w\\}$. The CFG is defined by the basic blocks and their connections.\n\nFirst, we establish the dataflow equations for liveness analysis. For an instruction $i$, let $\\mathrm{use}[i]$ be the set of variables used by $i$, and $\\mathrm{def}[i]$ be the set of variables defined by $i$. The live-in and live-out sets are related by:\n$$ \\mathrm{live\\_in}[i] = \\mathrm{use}[i] \\cup (\\mathrm{live\\_out}[i] \\setminus \\mathrm{def}[i]) $$\n$$ \\mathrm{live\\_out}[i] = \\bigcup_{s \\in \\mathrm{succ}(i)} \\mathrm{live\\_in}[s] $$\nwhere $\\mathrm{succ}(i)$ is the set of successor instructions to $i$. We begin the analysis from the end of the program, with $\\mathrm{live\\_out}[10] = \\emptyset$ as the program returns after instruction $10$.\n\nLet's perform the correct backward liveness analysis.\n\n1.  **Instruction $10$**: $\\textit{return } x$\n    *   $\\mathrm{use}[10] = \\{x\\}$, $\\mathrm{def}[10] = \\emptyset$.\n    *   $\\mathrm{live\\_out}[10] = \\emptyset$.\n    *   $\\mathrm{live\\_in}[10] = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}$.\n\n2.  **Instruction $9$**: $x := w + 1$\n    *   $\\mathrm{use}[9] = \\{w\\}$, $\\mathrm{def}[9] = \\{x\\}$, $\\mathrm{succ}(9) = \\{10\\}$.\n    *   $\\mathrm{live\\_out}[9] = \\mathrm{live\\_in}[10] = \\{x\\}$.\n    *   $\\mathrm{live\\_in}[9] = \\{w\\} \\cup (\\{x\\} \\setminus \\{x\\}) = \\{w\\}$.\n    *   The live-in set for block $B_4$ is $\\mathrm{live\\_in}[B_4] = \\mathrm{live\\_in}[9] = \\{w\\}$.\n\nSince blocks $B_2$ and $B_3$ both jump to $B_4$, the live-out sets at the end of these blocks are the live-in set of $B_4$.\n*   $\\mathrm{live\\_out}[B_2] = \\mathrm{live\\_in}[B_4] = \\{w\\}$. This is $\\mathrm{live\\_out}[5]$.\n*   $\\mathrm{live\\_out}[B_3] = \\mathrm{live\\_in}[B_4] = \\{w\\}$. This is $\\mathrm{live\\_out}[8]$.\n\n3.  **Analysis of Block $B_2$ (instructions $3, 4, 5$)**:\n    *   **Instruction $5$**: $\\textit{goto } B_4$. $\\mathrm{use}[5]=\\emptyset, \\mathrm{def}[5]=\\emptyset, \\mathrm{succ}(5)=\\{9\\}$. $\\mathrm{live\\_out}[5]=\\mathrm{live\\_in}[9]=\\{w\\}$. $\\mathrm{live\\_in}[5]=\\{w\\}$.\n    *   **Instruction $4$**: $w := v + 1$. $\\mathrm{use}[4]=\\{v\\}, \\mathrm{def}[4]=\\{w\\}, \\mathrm{succ}(4)=\\{5\\}$. $\\mathrm{live\\_out}[4]=\\mathrm{live\\_in}[5]=\\{w\\}$. $\\mathrm{live\\_in}[4]=\\{v\\} \\cup (\\{w\\} \\setminus \\{w\\}) = \\{v\\}$.\n    *   **Instruction $3$**: $v := u + z$. $\\mathrm{use}[3]=\\{u, z\\}, \\mathrm{def}[3]=\\{v\\}, \\mathrm{succ}(3)=\\{4\\}$. $\\mathrm{live\\_out}[3]=\\mathrm{live\\_in}[4]=\\{v\\}$. $\\mathrm{live\\_in}[3]=\\{u, z\\} \\cup (\\{v\\} \\setminus \\{v\\}) = \\{u, z\\}$.\n\n4.  **Analysis of Block $B_3$ (instructions $6, 7, 8$)**:\n    *   **Instruction $8$**: $\\textit{goto } B_4$. $\\mathrm{use}[8]=\\emptyset, \\mathrm{def}[8]=\\emptyset, \\mathrm{succ}(8)=\\{9\\}$. $\\mathrm{live\\_out}[8]=\\mathrm{live\\_in}[9]=\\{w\\}$. $\\mathrm{live\\_in}[8]=\\{w\\}$.\n    *   **Instruction $7$**: $w := v + y$. $\\mathrm{use}[7]=\\{v, y\\}, \\mathrm{def}[7]=\\{w\\}, \\mathrm{succ}(7)=\\{8\\}$. $\\mathrm{live\\_out}[7]=\\mathrm{live\\_in}[8]=\\{w\\}$. $\\mathrm{live\\_in}[7]=\\{v, y\\} \\cup (\\{w\\} \\setminus \\{w\\}) = \\{v, y\\}$.\n    *   **Instruction $6$**: $v := u + 1$. $\\mathrm{use}[6]=\\{u\\}, \\mathrm{def}[6]=\\{v\\}, \\mathrm{succ}(6)=\\{7\\}$. $\\mathrm{live\\_out}[6]=\\mathrm{live\\_in}[7]=\\{v, y\\}$. $\\mathrm{live\\_in}[6]=\\{u\\} \\cup (\\{v, y\\} \\setminus \\{v\\}) = \\{u, y\\}$.\n\n5.  **Analysis of Block $B_1$ (instructions $1, 2$)**:\n    *   **Instruction $2$**: $\\textit{if } \\dots$. $\\mathrm{use}[2]=\\{u\\}, \\mathrm{def}[2]=\\emptyset, \\mathrm{succ}(2)=\\{3, 6\\}$.\n    *   The correct rule for a join is union: $\\mathrm{live\\_out}[2] = \\mathrm{live\\_in}[3] \\cup \\mathrm{live\\_in}[6]$.\n    *   $\\mathrm{live\\_out}[2] = \\{u, z\\} \\cup \\{u, y\\} = \\{u, y, z\\}$.\n    *   $\\mathrm{live\\_in}[2] = \\mathrm{use}[2] \\cup (\\mathrm{live\\_out}[2] \\setminus \\mathrm{def}[2]) = \\{u\\} \\cup (\\{u, y, z\\} \\setminus \\emptyset) = \\{u, y, z\\}$.\n    *   **Instruction $1$**: $u := x + y$. $\\mathrm{use}[1]=\\{x, y\\}, \\mathrm{def}[1]=\\{u\\}, \\mathrm{succ}(1)=\\{2\\}$.\n    *   $\\mathrm{live\\_out}[1] = \\mathrm{live\\_in}[2] = \\{u, y, z\\}$.\n    *   $\\mathrm{live\\_in}[1] = \\{x, y\\} \\cup (\\{u, y, z\\} \\setminus \\{u\\}) = \\{x, y, z\\}$. This matches the problem's premise that $x, y, z$ are live on entry to $B_1$.\n\nNow, we construct the correct interference graph $G=(V, E)$ using the problem's rule: for each instruction defining variable $d$, add edges between $d$ and every variable in the live-out set of that instruction (excluding self-loops).\n\n*   **Instruction $1$** ($u := x+y$): $\\mathrm{def}[1]=\\{u\\}$, $\\mathrm{live\\_out}[1]=\\{u, y, z\\}$. Edges added: $\\{u, y\\}, \\{u, z\\}$.\n*   **Instruction $3$** ($v := u+z$): $\\mathrm{def}[3]=\\{v\\}$, $\\mathrm{live\\_out}[3]=\\{v\\}$. No edges added.\n*   **Instruction $4$** ($w := v+1$): $\\mathrm{def}[4]=\\{w\\}$, $\\mathrm{live\\_out}[4]=\\{w\\}$. No edges added.\n*   **Instruction $6$** ($v := u+1$): $\\mathrm{def}[6]=\\{v\\}$, $\\mathrm{live\\_out}[6]=\\{v, y\\}$. Edge added: $\\{v, y\\}$.\n*   **Instruction $7$** ($w := v+y$): $\\mathrm{def}[7]=\\{w\\}$, $\\mathrm{live\\_out}[7]=\\{w\\}$. No edges added.\n*   **Instruction $9$** ($x := w+1$): $\\mathrm{def}[9]=\\{x\\}$, $\\mathrm{live\\_out}[9]=\\{x\\}$. No edges added.\n\nThe set of edges in the correct graph is $E = \\{\\{u, y\\}, \\{u, z\\}, \\{v, y\\}\\}$.\n\nNext, we determine the faulty interference graph $G_f = (V, E_f)$. The fault occurs in the calculation of $\\mathrm{live\\_out}[2]$, which then affects the analysis backwards from that point.\n\n*   **Faulty analysis at Instruction 2**:\n    *   $\\mathrm{live\\_out\\_f}[2] = \\mathrm{live\\_in}[3] \\cap \\mathrm{live\\_in}[6] = \\{u, z\\} \\cap \\{u, y\\} = \\{u\\}$.\n    *   $\\mathrm{live\\_in\\_f}[2] = \\mathrm{use}[2] \\cup (\\mathrm{live\\_out\\_f}[2] \\setminus \\mathrm{def}[2]) = \\{u\\} \\cup (\\{u\\} \\setminus \\emptyset) = \\{u\\}$.\n*   **Faulty analysis at Instruction 1**:\n    *   $\\mathrm{live\\_out\\_f}[1] = \\mathrm{live\\_in\\_f}[2] = \\{u\\}$.\n\nThe liveness information for instructions $3$ through $10$ is unaffected, as the backward pass from the program's exit up to the entry points of the conditional branches (instructions $3$ and $6$) is independent of what happens before the branch.\n\nNow, we build the faulty graph $E_f$ using the same construction rule but with the faulty liveness data.\n\n*   **Instruction $1$** ($u := x+y$): $\\mathrm{def}[1]=\\{u\\}$, $\\mathrm{live\\_out\\_f}[1]=\\{u\\}$. No edges added.\n*   **Instruction $6$** ($v := u+1$): $\\mathrm{def}[6]=\\{v\\}$, $\\mathrm{live\\_out}[6]=\\{v, y\\}$. Edge added: $\\{v, y\\}$.\n*   All other defining instructions ($3, 4, 7, 9$) still add no edges, as their live-out sets are unchanged and only contain the defined variable itself.\n\nThe set of edges in the faulty graph is $E_f = \\{\\{v, y\\}\\}$. This matches the teammate's report, confirming our understanding of the process.\n\nFinally, we are asked to compute the number of missing edges, which is the cardinality of the set difference $E \\setminus E_f$.\n$$ E \\setminus E_f = \\{\\{u, y\\}, \\{u, z\\}, \\{v, y\\}\\} \\setminus \\{\\{v, y\\}\\} $$\n$$ E \\setminus E_f = \\{\\{u, y\\}, \\{u, z\\}\\} $$\nThe number of missing edges is the size of this set.\n$$ |E \\setminus E_f| = 2 $$\nThe two missing edges are $\\{u, y\\}$ and $\\{u, z\\}$. They were missed because the faulty intersection at the join point incorrectly determined that $y$ and $z$ were not live after instruction $2$, which in turn meant they were not live after instruction $1$.",
            "answer": "$$ \\boxed{2} $$"
        },
        {
            "introduction": "Liveness analysis becomes particularly powerful when applied to programs with loops, where variable lifetimes can span many iterations. This final practice problem examines how variables that are used after a loop must be kept 'alive' throughout its execution, creating interferences that are crucial to capture. By solving this, you will master the fixed-point iterative process required for analyzing loops and understand how a variable's live range can be non-local and far-reaching. ",
            "id": "3647442",
            "problem": "A compiler back end performs register allocation by constructing an interference graph whose vertices are program variables and whose undirected edges connect pairs of variables that are simultaneously live at some program point. In the classical data-flow framework for liveness, the basic definitions are: for each statement $s$, the live-in set $\\mathrm{IN}[s]$ and live-out set $\\mathrm{OUT}[s]$ satisfy\n$$\n\\mathrm{IN}[s] = \\mathrm{USE}[s] \\cup \\left( \\mathrm{OUT}[s] \\setminus \\mathrm{DEF}[s] \\right), \\quad \\mathrm{OUT}[s] = \\bigcup_{s' \\in \\mathrm{succ}(s)} \\mathrm{IN}[s'],\n$$\nwhere $\\mathrm{USE}[s]$ and $\\mathrm{DEF}[s]$ are, respectively, the sets of variables read and written in statement $s$, and $\\mathrm{succ}(s)$ is the set of successors in the Control Flow Graph (CFG).\n\nConsider the following straight-line three-address code with a single loop, written with labeled statements and basic blocks. All variables are scalar temporaries. The only control-flow is as indicated, and there are no function calls or aliasing. The program is designed so that interference emerges only due to variables that are live at the loop exit.\n\nBasic blocks and statements:\n- Preheader:\n  - Line $1$: $u \\leftarrow 0$\n  - Line $2$: $v \\leftarrow 1$\n  - Line $3$: w \\leftarrow \\mathrm{input}()\n  - Line $4$: \\mathrm{goto}~L\n- Loop header $L$:\n  - Line $5$: \\mathrm{if} $(w \\leq 0)$ \\mathrm{goto} E \\mathrm{else} \\mathrm{goto} B\n- Loop body $B$:\n  - Line $6$: w \\leftarrow w - 1\n  - Line $7$: \\mathrm{goto}~L\n- Exit $E$:\n  - Line $8$: x \\leftarrow u + w\n  - Line $9$: y \\leftarrow v + w\n  - Line $10$: z \\leftarrow x + y\n\nAssume the CFG successors are as follows: $\\mathrm{succ}(1)=\\{2\\}$, $\\mathrm{succ}(2)=\\{3\\}$, $\\mathrm{succ}(3)=\\{4\\}$, $\\mathrm{succ}(4)=\\{5\\}$, $\\mathrm{succ}(5)=\\{8,6\\}$, $\\mathrm{succ}(6)=\\{7\\}$, $\\mathrm{succ}(7)=\\{5\\}$, $\\mathrm{succ}(8)=\\{9\\}$, $\\mathrm{succ}(9)=\\{10\\}$, $\\mathrm{succ}(10)=\\emptyset$. The $\\mathrm{USE}$ and $\\mathrm{DEF}$ sets are: $\\mathrm{DEF}[1]=\\{u\\}$, $\\mathrm{DEF}[2]=\\{v\\}$, $\\mathrm{DEF}[3]=\\{w\\}$, $\\mathrm{DEF}[6]=\\{w\\}$, $\\mathrm{DEF}[8]=\\{x\\}$, $\\mathrm{DEF}[9]=\\{y\\}$, $\\mathrm{DEF}[10]=\\{z\\}$. The nonempty $\\mathrm{USE}$ sets are $\\mathrm{USE}[5]=\\{w\\}$, $\\mathrm{USE}[6]=\\{w\\}$, $\\mathrm{USE}[8]=\\{u,w\\}$, $\\mathrm{USE}[9]=\\{v,w\\}$, $\\mathrm{USE}[10]=\\{x,y\\}$.\n\nUsing the above definitions, compute the liveness sets to a fixed point. Then, construct the interference graph by the standard edge-generation rule: for each non-move assignment $a \\leftarrow \\cdots$ at statement $s$, add undirected edges connecting $a$ to every variable in $\\mathrm{OUT}[s]$ except $a$ itself. Finally, determine the total number of distinct edges in the interference graph. Report that number as your final answer. No rounding is needed. The answer has no physical units.",
            "solution": "The user-provided problem is a well-defined exercise in liveness analysis and interference graph construction, rooted in the principles of compiler design. All necessary components—the code, Control Flow Graph (CFG) successors, USE/DEF sets, and formal definitions—are provided and are internally consistent. The problem is scientifically grounded, objective, and well-posed. Therefore, the problem is valid and a complete solution can be derived.\n\nThe solution proceeds in two main stages:\n1. Computation of the live-in ($\\mathrm{IN}[s]$) and live-out ($\\mathrm{OUT}[s]$) sets for each statement $s$ by iterating the data-flow equations to a fixed point.\n2. Construction of the interference graph by applying the specified edge-generation rule to each definition in the code, using the computed live-out sets.\n\nThe data-flow equations for liveness analysis are given as:\n$$\n\\mathrm{IN}[s] = \\mathrm{USE}[s] \\cup \\left( \\mathrm{OUT}[s] \\setminus \\mathrm{DEF}[s] \\right)\n$$\n$$\n\\mathrm{OUT}[s] = \\bigcup_{s' \\in \\mathrm{succ}(s)} \\mathrm{IN}[s']\n$$\nThe variables in the program are $u$, $v$, $w$, $x$, $y$, and $z$. The analysis is a backward data-flow analysis, meaning we propagate liveness information from a statement's successors back to the statement itself. We initialize all $\\mathrm{IN}$ and $\\mathrm{OUT}$ sets to the empty set, $\\emptyset$, and iterate until no set changes.\n\nThe provided USE and DEF sets are:\n- $\\mathrm{USE}[1]=\\emptyset, \\mathrm{DEF}[1]=\\{u\\}$\n- $\\mathrm{USE}[2]=\\emptyset, \\mathrm{DEF}[2]=\\{v\\}$\n- $\\mathrm{USE}[3]=\\emptyset, \\mathrm{DEF}[3]=\\{w\\}$\n- $\\mathrm{USE}[4]=\\emptyset, \\mathrm{DEF}[4]=\\emptyset$\n- $\\mathrm{USE}[5]=\\{w\\}, \\mathrm{DEF}[5]=\\emptyset$\n- $\\mathrm{USE}[6]=\\{w\\}, \\mathrm{DEF}[6]=\\{w\\}$\n- $\\mathrm{USE}[7]=\\emptyset, \\mathrm{DEF}[7]=\\emptyset$\n- $\\mathrm{USE}[8]=\\{u,w\\}, \\mathrm{DEF}[8]=\\{x\\}$\n- $\\mathrm{USE}[9]=\\{v,w\\}, \\mathrm{DEF}[9]=\\{y\\}$\n- $\\mathrm{USE}[10]=\\{x,y\\}, \\mathrm{DEF}[10]=\\{z\\}$\n\nThe successors $\\mathrm{succ}(s)$ are given in the problem statement. The analysis proceeds as follows, iterating until a fixed point is reached.\n\nAfter the iterative fixed-point computation converges, the final liveness sets are:\n- Statement $1$: $\\mathrm{OUT}[1] = \\{u\\}$, $\\mathrm{IN}[1] = \\emptyset$\n- Statement $2$: $\\mathrm{OUT}[2] = \\{u, v\\}$, $\\mathrm{IN}[2] = \\{u\\}$\n- Statement $3$: $\\mathrm{OUT}[3] = \\{u, v, w\\}$, $\\mathrm{IN}[3] = \\{u, v\\}$\n- Statement $4$: $\\mathrm{OUT}[4] = \\{u, v, w\\}$, $\\mathrm{IN}[4] = \\{u, v, w\\}$\n- Statement $5$: $\\mathrm{OUT}[5] = \\{u, v, w\\}$, $\\mathrm{IN}[5] = \\{u, v, w\\}$\n- Statement $6$: $\\mathrm{OUT}[6] = \\{u, v, w\\}$, $\\mathrm{IN}[6] = \\{u, v, w\\}$\n- Statement $7$: $\\mathrm{OUT}[7] = \\{u, v, w\\}$, $\\mathrm{IN}[7] = \\{u, v, w\\}$\n- Statement $8$: $\\mathrm{OUT}[8] = \\{v, w, x\\}$, $\\mathrm{IN}[8] = \\{u, v, w\\}$\n- Statement $9$: $\\mathrm{OUT}[9] = \\{x, y\\}$, $\\mathrm{IN}[9] = \\{v, w, x\\}$\n- Statement $10$: $\\mathrm{OUT}[10] = \\emptyset$, $\\mathrm{IN}[10] = \\{x, y\\}$\n\nWith the final liveness sets established, we construct the interference graph. The rule is: for each non-move assignment $a \\leftarrow \\dots$ at statement $s$, add an undirected edge between $a$ and every variable in $\\mathrm{OUT}[s] \\setminus \\{a\\}$. The definition statements are $1, 2, 3, 6, 8, 9, 10$.\n\n1.  **Statement $1$**: $u \\leftarrow 0$. Here, $a=u$ and $s=1$. The set of interfering variables is $\\mathrm{OUT}[1] \\setminus \\{u\\} = \\{u\\} \\setminus \\{u\\} = \\emptyset$. No edges are added.\n\n2.  **Statement $2$**: $v \\leftarrow 1$. Here, $a=v$ and $s=2$. The set of interfering variables is $\\mathrm{OUT}[2] \\setminus \\{v\\} = \\{u, v\\} \\setminus \\{v\\} = \\{u\\}$. An edge $\\{u, v\\}$ is added.\n\n3.  **Statement $3$**: $w \\leftarrow \\mathrm{input}()$. Here, $a=w$ and $s=3$. The set of interfering variables is $\\mathrm{OUT}[3] \\setminus \\{w\\} = \\{u, v, w\\} \\setminus \\{w\\} = \\{u, v\\}$. Edges $\\{u, w\\}$ and $\\{v, w\\}$ are added.\n\n4.  **Statement $6$**: $w \\leftarrow w-1$. Here, $a=w$ and $s=6$. The set of interfering variables is $\\mathrm{OUT}[6] \\setminus \\{w\\} = \\{u, v, w\\} \\setminus \\{w\\} = \\{u, v\\}$. Edges $\\{u, w\\}$ and $\\{v, w\\}$ are added. These are the same edges as from statement $3$.\n\n5.  **Statement $8$**: $x \\leftarrow u+w$. Here, $a=x$ and $s=8$. The set of interfering variables is $\\mathrm{OUT}[8] \\setminus \\{x\\} = \\{v, w, x\\} \\setminus \\{x\\} = \\{v, w\\}$. Edges $\\{v, x\\}$ and $\\{w, x\\}$ are added.\n\n6.  **Statement $9$**: $y \\leftarrow v+w$. Here, $a=y$ and $s=9$. The set of interfering variables is $\\mathrm{OUT}[9] \\setminus \\{y\\} = \\{x, y\\} \\setminus \\{y\\} = \\{x\\}$. An edge $\\{x, y\\}$ is added.\n\n7.  **Statement $10$**: $z \\leftarrow x+y$. Here, $a=z$ and $s=10$. The set of interfering variables is $\\mathrm{OUT}[10] \\setminus \\{z\\} = \\emptyset \\setminus \\{z\\} = \\emptyset$. No edges are added.\n\nCollecting all distinct edges generated:\n- From statement $2$: $\\{u, v\\}$\n- From statement $3$: $\\{u, w\\}$, $\\{v, w\\}$\n- From statement $8$: $\\{v, x\\}$, $\\{w, x\\}$\n- From statement $9$: $\\{x, y\\}$\n\nThe complete set of distinct, undirected edges in the interference graph is:\n1.  $\\{u, v\\}$\n2.  $\\{u, w\\}$\n3.  $\\{v, w\\}$\n4.  $\\{v, x\\}$\n5.  $\\{w, x\\}$\n6.  $\\{x, y\\}$\n\nCounting these distinct edges gives a total of $6$. The variable $z$ does not interfere with any other variable as it is not live at any point where another variable is defined, and no other variable is live-out of the statement where $z$ is defined.",
            "answer": "$$\n\\boxed{6}\n$$"
        }
    ]
}