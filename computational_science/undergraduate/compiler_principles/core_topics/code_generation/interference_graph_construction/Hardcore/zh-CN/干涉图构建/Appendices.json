{
    "hands_on_practices": [
        {
            "introduction": "构建干扰图是一个细致的过程，任何错误都可能导致寄存器分配失败。这个练习将你置于编译器开发者的角色，任务是验证一个既有干扰图的正确性。通过对一段包含分支和合并的复杂代码进行从零开始的活性分析，你将能够识别出给定图中缺失的干扰边，从而磨练你进行精确数据流分析的技能。",
            "id": "3647421",
            "problem": "编译器后端通过在控制流图（CFG；Control Flow Graph）上使用存活分析来为寄存器分配构建一个干涉图。两个程序变量当且仅当它们的存活范围在某个程序点重叠时才会发生干涉，这意味着根据非静态单赋值（non-SSA；Static Single Assignment）形式下的标准存活定义，它们是同时存活的。\n\n考虑以下由四个基本块（Basic Block；BB）组成的命令式程序，其已用行号和分支标签进行注释。该程序使用赋值语句和单个条件分支。每个赋值语句 $v := \\text{expr}$ 定义了左侧变量 $v$ 并使用了出现在 $\\text{expr}$ 中的所有变量。程序中没有函数调用，没有别名，除了赋值所隐含的内存副作用外，没有其他内存副作用。\n\n块 $B_{1}$：\n- 第 $1$ 行：$d := a + 1$\n- 第 $2$ 行：$b := d + c$\n- 第 $3$ 行：$x := b + e$\n- 第 $4$ 行：if $(x > m)$ goto $B_{2}$ else goto $B_{3}$\n\n块 $B_{2}$（当第 $4$ 行的条件为真时执行）：\n- 第 $5$ 行：$y := x + c$\n- 第 $6$ 行：$t := y + n$\n- 第 $7$ 行：$b := t + a$\n- 第 $8$ 行：goto $B_{4}$\n\n块 $B_{3}$（当第 $4$ 行的条件为假时执行）：\n- 第 $9$ 行：$y := m + c$\n- 第 $10$ 行：$x := y + a$\n- 第 $11$ 行：$t := x + p$\n- 第 $12$ 行：goto $B_{4}$\n\n块 $B_{4}$（汇合块）：\n- 第 $13$ 行：$z := x + y$\n- 第 $14$ 行：$r := z + b$\n- 第 $15$ 行：return $r$\n\n假设仅考虑临时变量 $\\{b, x, y, t, z\\}$ 用于图的构建；所有其他标识符（$a, c, d, e, m, n, p, r$）被视为外部值或预着色寄存器，并且不为干涉图贡献节点。编译器声称的关于节点 $\\{b, x, y, t, z\\}$ 的干涉图 $G$ 目前恰好包含以下边\n$$\n\\{(t,x),\\ (t,y),\\ (z,b)\\}.\n$$\n\n根据标准的非 SSA 存活定义，一个变量在某个程序点是存活的，当且仅当存在一条从该点到该变量后续使用的路径，且该路径上在此次使用前没有任何对该变量的重新定义。两个变量发生干涉，当且仅当存在至少一个程序点，使得这两个变量在该点同时存活。\n\n您的任务是：重新计算 $x$ 和 $y$ 同时存活的程序点处的存活情况，确定因此必须存在的所有涉及 $x$ 和 $y$ 的干涉边，并与 $G$ 中给出的边进行比较。计算 $G$ 相对于由 $\\{b, x, y, t, z\\}$ 导出的正确干涉图所缺少的边的数量，结果为一个整数。请以精确整数形式表达您的最终答案；无需四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于编译器理论的原理，特别是存活分析和干涉图构建。该问题提法恰当、客观，并提供了推导唯一解所需的所有信息。\n\n任务是确定变量集 $\\{b, x, y, t, z\\}$ 的正确干涉图，并找出给定图 $G$ 中缺少的边的数量。如果两个变量在任何程序点同时存活，它们就发生干涉。一个变量在某一点是存活的，如果存在从该点到该变量的一次使用的路径，且该路径上没有被任何对该变量的重新定义所截断。\n\n分析过程是通过计算每条指令入口和出口处的存活变量集来进行的，从程序的末尾向前反向工作。控制流图（CFG）以块 $B_1$ 为入口，它分支到 $B_2$ 和 $B_3$。$B_2$ 和 $B_3$ 都分支到汇合块 $B_4$，后者是出口块。\n\n设 $\\text{LiveAfter}(i)$ 为紧跟在指令 $i$ 之后的存活变量集合。对于一条指令 $i$，$\\text{def}(i)$ 是它定义的变量集合，$\\text{use}(i)$ 是它使用的变量集合。紧邻指令 $i$ 之前的存活变量集合由标准的数据流方程给出：\n$$\n\\text{LiveBefore}(i) = \\text{use}(i) \\cup (\\text{LiveAfter}(i) - \\text{def}(i))\n$$\n$\\text{def}(i)$ 中的任何变量都与 $\\text{LiveAfter}(i)$ 中的每个变量发生干涉。此外，同一 $\\text{LiveAfter}(i)$ 集合中的任意两个变量也相互干涉。我们将为每条指令计算这些集合，只考虑我们关心的变量：$\\{b, x, y, t, z\\}$。\n\n分析从程序的末尾开始。在最后一条指令（第 $15$ 行）之后，没有变量是存活的。\n$\\text{LiveAfter}(15) = \\emptyset$。\n\n**块 $B_4$（第 $13$-$15$ 行）：**\n- **第 $15$ 行：`return r`**：`def(15) = \\emptyset`，`use(15) = \\emptyset`（变量 $r$ 不在我们的集合中）。\n$\\text{LiveBefore}(15) = \\emptyset \\cup (\\emptyset - \\emptyset) = \\emptyset$。\n- **第 $14$ 行：`r := z + b`**：`def(14) = \\emptyset`，`use(14) = \\{z, b\\}$。\n$\\text{LiveAfter}(14) = \\text{LiveBefore}(15) = \\emptyset$。\n$\\text{LiveBefore}(14) = \\{z, b\\} \\cup (\\emptyset - \\emptyset) = \\{z, b\\}$。\n- **第 $13$ 行：`z := x + y`**：`def(13) = \\{z\\}`，`use(13) = \\{x, y\\}$。\n$\\text{LiveAfter}(13) = \\text{LiveBefore}(14) = \\{z, b\\}$。在这个程序点，变量 $z$ 和 $b$ 同时存活。这意味着存在一条干涉边 $(z, b)$。$z$ 的定义也与第 $13$ 行之后存活的其他变量（这里只有 $b$）发生干涉。这确认了边 **$(z, b)$**。\n$\\text{LiveBefore}(13) = \\{x, y\\} \\cup (\\{z, b\\} - \\{z\\}) = \\{x, y, b\\}$。这是在块 $B_4$ 入口处存活的变量集合。\n\n在 $B_4$ 入口处的存活变量集 $\\text{Live}_{\\text{in}}(B_4)$ 为 $\\{x, y, b\\}$。由于 $B_4$ 是 $B_2$ 和 $B_3$ 的后继，我们有 $\\text{Live}_{\\text{out}}(B_2) = \\text{Live}_{\\text{out}}(B_3) = \\text{Live}_{\\text{in}}(B_4) = \\{x, y, b\\}$。\n\n**块 $B_3$（第 $9$-$12$ 行）：**\n我们从块的末尾开始反向分析，此处的存活集是 $\\text{Live}_{\\text{out}}(B_3) = \\{x, y, b\\}$。\n- **第 $12$ 行：`goto B4`**：`def(12) = \\emptyset`，`use(12) = \\emptyset$。\n$\\text{LiveAfter}(12) = \\{x, y, b\\}$。\n$\\text{LiveBefore}(12) = \\emptyset \\cup (\\{x, y, b\\} - \\emptyset) = \\{x, y, b\\}$。\n- **第 $11$ 行：`t := x + p`**：`def(11) = \\{t\\}`，`use(11) = \\{x\\}$。\n一个关键的观察是，在第 $11$ 行定义的变量 $t$ 在之后从未被使用。根据存活定义，这个 $t$ 的实例是一个死变量；其存活范围为空。因此，它不能与任何其他变量发生干涉。\n$\\text{LiveAfter}(11) = \\text{LiveBefore}(12) = \\{x, y, b\\}$。在这一点，变量 $x$、 $y$ 和 $b$ 同时存活。这意味着存在干涉边 **$(x, y)$**、 **$(x, b)$** 和 **$(y, b)$**。\n$\\text{LiveBefore}(11) = \\{x\\} \\cup (\\{x, y, b\\} - \\{t\\}) = \\{x, y, b\\}$。\n- **第 $10$ 行：`x := y + a`**：`def(10) = \\{x\\}`，`use(10) = \\{y\\}$。\n$\\text{LiveAfter}(10) = \\text{LiveBefore}(11) = \\{x, y, b\\}$。$x$ 的定义与此集合中的其他变量（即 $\\{y, b\\}$）发生干涉。这确认了边 **$(x, y)$** 和 **$(x, b)$**。\n$\\text{LiveBefore}(10) = \\{y\\} \\cup (\\{x, y, b\\} - \\{x\\}) = \\{y, b\\}$。\n- **第 $9$ 行：`y := m + c`**：`def(9) = \\{y\\}`，`use(9) = \\emptyset$。\n$\\text{LiveAfter}(9) = \\text{LiveBefore}(10) = \\{y, b\\}$。在这一点，$y$ 和 $b$ 存活，意味着边 **$(y, b)$**。$y$ 的定义与 $b$ 干涉。\n$\\text{LiveBefore}(9) = \\emptyset \\cup (\\{y, b\\} - \\{y\\}) = \\{b\\}$。这是 $\\text{Live}_{\\text{in}}(B_3)$。\n\n**块 $B_2$（第 $5$-$8$ 行）：**\n我们从块的末尾开始反向分析，此处的存活集是 $\\text{Live}_{\\text{out}}(B_2) = \\{x, y, b\\}$。\n- **第 $8$ 行：`goto B4`**：\n$\\text{LiveAfter}(8) = \\{x, y, b\\}$。存活的变量意味着边 **$(x, y)$**、**$(x, b)$** 和 **$(y, b)$**。\n$\\text{LiveBefore}(8) = \\{x, y, b\\}$。\n- **第 $7$ 行：`b := t + a`**：`def(7) = \\{b\\}`，`use(7) = \\{t\\}$。\n$\\text{LiveAfter}(7) = \\text{LiveBefore}(8) = \\{x, y, b\\}$。$b$ 的定义与 $\\{x, y\\}$ 干涉。这产生了边 **$(b, x)$** 和 **$(b, y)$**。\n$\\text{LiveBefore}(7) = \\{t\\} \\cup (\\{x, y, b\\} - \\{b\\}) = \\{t, x, y\\}$。\n- **第 $6$ 行：`t := y + n`**：`def(6) = \\{t\\}`，`use(6) = \\{y\\}$。\n$\\text{LiveAfter}(6) = \\text{LiveBefore}(7) = \\{t, x, y\\}$。在这一点，$t$、$x$ 和 $y$ 同时存活，意味着边 **$(t, x)$**、**$(t, y)$** 和 **$(x, y)$**。\n$\\text{LiveBefore}(6) = \\{y\\} \\cup (\\{t, x, y\\} - \\{t\\}) = \\{x, y\\}$。\n- **第 $5$ 行：`y := x + c`**：`def(5) = \\{y\\}`，`use(5) = \\{x\\}$。\n$\\text{LiveAfter}(5) = \\text{LiveBefore}(6) = \\{x, y\\}$。这意味着边 **$(x, y)$**。\n$\\text{LiveBefore}(5) = \\{x\\} \\cup (\\{x, y\\} - \\{y\\}) = \\{x\\}$。这是 $\\text{Live}_{\\text{in}}(B_2)$。\n\n**块 $B_1$（第 $1$-$4$ 行）：**\n在 $B_1$ 出口处的存活变量集合是 $\\text{Live}_{\\text{out}}(B_1) = \\text{Live}_{\\text{in}}(B_2) \\cup \\text{Live}_{\\text{in}}(B_3) = \\{x\\} \\cup \\{b\\} = \\{x, b\\}$。\n- **第 $4$ 行：`if (x > m) ...`**：`def(4) = \\emptyset`，`use(4) = \\{x\\}$。\n$\\text{LiveAfter}(4) = \\{x, b\\}$。在这一点，$x$ 和 $b$ 存活，意味着边 **$(x, b)$**。\n$\\text{LiveBefore}(4) = \\{x\\} \\cup (\\{x, b\\} - \\emptyset) = \\{x, b\\}$。\n- **第 $3$ 行：`x := b + e`**：`def(3) = \\{x\\}`，`use(3) = \\{b\\}$。\n$\\text{LiveAfter}(3) = \\text{LiveBefore}(4) = \\{x, b\\}$。$x$ 的定义与 $b$ 干涉，确认了边 **$(x, b)$**。\n$\\text{LiveBefore}(3) = \\{b\\} \\cup (\\{x, b\\} - \\{x\\}) = \\{b\\}$。\n- **第 $2$ 行：`b := d + c`**：`def(2) = \\{b\\}`，`use(2) = \\emptyset$。\n$\\text{LiveAfter}(2) = \\text{LiveBefore}(3) = \\{b\\}$。没有干涉。\n$\\text{LiveBefore}(2) = \\emptyset \\cup (\\{b\\} - \\{b\\}) = \\emptyset$。\n- **第 $1$ 行：`d := a + 1`**：不涉及我们集合中的任何变量。$\\text{LiveBefore}(1) = \\emptyset$。\n\n**合并边：**\n我们收集所有已识别的唯一干涉边：\n1. $(z, b)$，也可写作 $(b, z)$。\n2. $(x, y)$。\n3. $(x, b)$，也可写作 $(b, x)$。\n4. $(y, b)$，也可写作 $(b, y)$。\n5. $(t, x)$。\n6. $(t, y)$。\n\n正确干涉图中的完整边集是 $E_{\\text{correct}} = \\{(b, z), (x, y), (x, b), (y, b), (t, x), (t, y)\\}$。\n正确边的数量是 $|E_{\\text{correct}}| = 6$。\n\n**与给定图的比较：**\n问题陈述给定的干涉图 $G$ 包含边 $E_{\\text{given}} = \\{(t,x), (t,y), (z,b)\\}$。\n为了找到缺失的边，我们计算集合差 $E_{\\text{correct}} - E_{\\text{given}}$。\n$$\nE_{\\text{missing}} = \\{(b, z), (x, y), (x, b), (y, b), (t, x), (t, y)\\} - \\{(t, x), (t, y), (z, b)\\}\n$$\n在 $E_{\\text{correct}}$ 中但不在 $E_{\\text{given}}$ 中的边是：\n- $(x, y)$\n- $(x, b)$\n- $(y, b)$\n\n缺失边的数量是这个集合的基数，即 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "准确应用数据流方程是至关重要的，尤其是在控制流的合并点（join point）。本练习聚焦于一个常见的概念性错误：在计算合并点的活跃变量集时，错误地使用了集合的交集（intersection）而非并集（union）。你将分析这一错误导致的后果，并量化错误图与正确图之间的差异，从而巩固你对活性信息如何在控制流图中传播的理解。",
            "id": "3647411",
            "problem": "一个编译器后端通过在一个根据控制流图（CFG）上的活跃度信息构建的冲突图上进行图着色来实现寄存器分配。考虑以下带有条件分支和汇合的直线代码，它被写成带有标记指令的基本块。赋值用 $:=$ 表示。CFG 的边从 $B_1$ 的末尾指向 $B_2$ 和 $B_3$ 的开头，从 $B_2$ 和 $B_3$ 的末尾指向 $B_4$ 的开头，并且 $B_4$ 顺序执行到一个返回语句。\n\n基本块：\n- $B_1$:\n  - 指令 $1$: $u := x + y$\n  - 指令 $2$: if $u > 0$ goto $B_2$ else $B_3$\n- $B_2$:\n  - 指令 $3$: $v := u + z$\n  - 指令 $4$: $w := v + 1$\n  - 指令 $5$: goto $B_4$\n- $B_3$:\n  - 指令 $6$: $v := u + 1$\n  - 指令 $7$: $w := v + y$\n  - 指令 $8$: goto $B_4$\n- $B_4$:\n  - 指令 $9$: $x := w + 1$\n  - 指令 $10$: return $x$\n\n假设变量 $x$、$y$ 和 $z$ 在进入 $B_1$ 时是活跃的，并且除了显示的用途外，没有其他外部使用。冲突图 $G = (V,E)$ 对 $\\{x,y,z,u,v,w\\}$ 中的每个变量都有一个顶点，并且当变量 $a$ 和 $b$ 由于在某个程序点根据标准的指令级冲突构建规则同时活跃而不能被分配到同一个寄存器时，就存在一条无向边 $\\{a,b\\} \\in E$：对于每条定义变量 $d$ 的指令，在 $d$ 和该指令之后立即出现的活跃出口集合中的每个变量之间添加边。\n\n一位团队成员进行了一次错误的活跃度分析，他在计算指令 2 中条件语句的活跃出口集合时，错误地使用了后继集合的交集而不是并集。具体来说，在指令 2 产生的汇合点，他们设置了\n$$\\mathrm{live\\_out}[2] = \\mathrm{live\\_in}[3] \\cap \\mathrm{live\\_in}[6],$$\n然后使用上述规则构建了一个冲突图 $G_f = (V,E_f)$。他们报告说 $E_f$ 只包含边 $\\{v,y\\}$。\n\n使用指令级别活跃度的正确后向数据流方程和上面陈述的冲突边构建规则，确定缺失边的确切数量，即计算整数值 $|E \\setminus E_f|$。请以单个整数形式提供你的答案。不要四舍五入。",
            "solution": "所述问题是有效的。它在编译器构造领域，特别是活跃度分析和冲突图生成方面，提出了一个明确定义的场景。所有必要的数据，包括代码、控制流图（CFG）结构、初始活跃度条件以及构建图的具体规则，都已提供。任务是比较一个正确构建的图和一个错误的图，并量化它们之间的差异。\n\n问题的核心在于应用后向数据流分析的原理来确定程序中各个点的活跃变量集合，然后使用指定的规则来构建冲突图。我们必须首先执行正确的活跃度分析，然后复现错误的分析，为两种情况构建相应的冲突图，最后计算错误图中缺失的边的数量。\n\n涉及的变量是 $V = \\{x, y, z, u, v, w\\}$。CFG 由基本块及其连接定义。\n\n首先，我们建立活跃度分析的数据流方程。对于一条指令 $i$，令 $\\mathrm{use}[i]$ 为 $i$ 使用的变量集合，$\\mathrm{def}[i]$ 为 $i$ 定义的变量集合。活跃入口和活跃出口集合之间的关系如下：\n$$ \\mathrm{live\\_in}[i] = \\mathrm{use}[i] \\cup (\\mathrm{live\\_out}[i] \\setminus \\mathrm{def}[i]) $$\n$$ \\mathrm{live\\_out}[i] = \\bigcup_{s \\in \\mathrm{succ}(i)} \\mathrm{live\\_in}[s] $$\n其中 $\\mathrm{succ}(i)$ 是指令 $i$ 的后继指令集合。我们从程序的末尾开始分析，由于程序在指令 10 后返回，所以 $\\mathrm{live\\_out}[10] = \\emptyset$。\n\n让我们执行正确的后向活跃度分析。\n\n1.  **指令 $10$**: $\\textit{return } x$\n    *   $\\mathrm{use}[10] = \\{x\\}$, $\\mathrm{def}[10] = \\emptyset$。\n    *   $\\mathrm{live\\_out}[10] = \\emptyset$。\n    *   $\\mathrm{live\\_in}[10] = \\{x\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x\\}$。\n\n2.  **指令 $9$**: $x := w + 1$\n    *   $\\mathrm{use}[9] = \\{w\\}$, $\\mathrm{def}[9] = \\{x\\}$, $\\mathrm{succ}(9) = \\{10\\}$。\n    *   $\\mathrm{live\\_out}[9] = \\mathrm{live\\_in}[10] = \\{x\\}$。\n    *   $\\mathrm{live\\_in}[9] = \\{w\\} \\cup (\\{x\\} \\setminus \\{x\\}) = \\{w\\}$。\n    *   基本块 $B_4$ 的活跃入口集合是 $\\mathrm{live\\_in}[B_4] = \\mathrm{live\\_in}[9] = \\{w\\}$。\n\n由于基本块 $B_2$ 和 $B_3$都跳转到 $B_4$，这两个块末尾的活跃出口集合就是 $B_4$ 的活跃入口集合。\n*   $\\mathrm{live\\_out}[B_2] = \\mathrm{live\\_in}[B_4] = \\{w\\}$。这是 $\\mathrm{live\\_out}[5]$。\n*   $\\mathrm{live\\_out}[B_3] = \\mathrm{live\\_in}[B_4] = \\{w\\}$。这是 $\\mathrm{live\\_out}[8]$。\n\n3.  **分析基本块 $B_2$（指令 $3, 4, 5$）**:\n    *   **指令 $5$**: $\\textit{goto } B_4$。 $\\mathrm{use}[5]=\\emptyset, \\mathrm{def}[5]=\\emptyset, \\mathrm{succ}(5)=\\{9\\}$。 $\\mathrm{live\\_out}[5]=\\mathrm{live\\_in}[9]=\\{w\\}$。 $\\mathrm{live\\_in}[5]=\\{w\\}$。\n    *   **指令 $4$**: $w := v + 1$。 $\\mathrm{use}[4]=\\{v\\}, \\mathrm{def}[4]=\\{w\\}, \\mathrm{succ}(4)=\\{5\\}$。 $\\mathrm{live\\_out}[4]=\\mathrm{live\\_in}[5]=\\{w\\}$。 $\\mathrm{live\\_in}[4]=\\{v\\} \\cup (\\{w\\} \\setminus \\{w\\}) = \\{v\\}$。\n    *   **指令 $3$**: $v := u + z$。 $\\mathrm{use}[3]=\\{u, z\\}, \\mathrm{def}[3]=\\{v\\}, \\mathrm{succ}(3)=\\{4\\}$。 $\\mathrm{live\\_out}[3]=\\mathrm{live\\_in}[4]=\\{v\\}$。 $\\mathrm{live\\_in}[3]=\\{u, z\\} \\cup (\\{v\\} \\setminus \\{v\\}) = \\{u, z\\}$。\n\n4.  **分析基本块 $B_3$（指令 $6, 7, 8$）**:\n    *   **指令 $8$**: $\\textit{goto } B_4$。 $\\mathrm{use}[8]=\\emptyset, \\mathrm{def}[8]=\\emptyset, \\mathrm{succ}(8)=\\{9\\}$。 $\\mathrm{live\\_out}[8]=\\mathrm{live\\_in}[9]=\\{w\\}$。 $\\mathrm{live\\_in}[8]=\\{w\\}$。\n    *   **指令 $7$**: $w := v + y$。 $\\mathrm{use}[7]=\\{v, y\\}, \\mathrm{def}[7]=\\{w\\}, \\mathrm{succ}(7)=\\{8\\}$。 $\\mathrm{live\\_out}[7]=\\mathrm{live\\_in}[8]=\\{w\\}$。 $\\mathrm{live\\_in}[7]=\\{v, y\\} \\cup (\\{w\\} \\setminus \\{w\\}) = \\{v, y\\}$。\n    *   **指令 $6$**: $v := u + 1$。 $\\mathrm{use}[6]=\\{u\\}, \\mathrm{def}[6]=\\{v\\}, \\mathrm{succ}(6)=\\{7\\}$。 $\\mathrm{live\\_out}[6]=\\mathrm{live\\_in}[7]=\\{v, y\\}$。 $\\mathrm{live\\_in}[6]=\\{u\\} \\cup (\\{v, y\\} \\setminus \\{v\\}) = \\{u, y\\}$。\n\n5.  **分析基本块 $B_1$（指令 $1, 2$）**:\n    *   **指令 $2$**: $\\textit{if } \\dots$。 $\\mathrm{use}[2]=\\{u\\}, \\mathrm{def}[2]=\\emptyset, \\mathrm{succ}(2)=\\{3, 6\\}$。\n    *   对于一个汇合点，正确的规则是并集： $\\mathrm{live\\_out}[2] = \\mathrm{live\\_in}[3] \\cup \\mathrm{live\\_in}[6]$。\n    *   $\\mathrm{live\\_out}[2] = \\{u, z\\} \\cup \\{u, y\\} = \\{u, y, z\\}$。\n    *   $\\mathrm{live\\_in}[2] = \\mathrm{use}[2] \\cup (\\mathrm{live\\_out}[2] \\setminus \\mathrm{def}[2]) = \\{u\\} \\cup (\\{u, y, z\\} \\setminus \\emptyset) = \\{u, y, z\\}$。\n    *   **指令 $1$**: $u := x + y$。 $\\mathrm{use}[1]=\\{x, y\\}, \\mathrm{def}[1]=\\{u\\}, \\mathrm{succ}(1)=\\{2\\}$。\n    *   $\\mathrm{live\\_out}[1] = \\mathrm{live\\_in}[2] = \\{u, y, z\\}$。\n    *   $\\mathrm{live\\_in}[1] = \\{x, y\\} \\cup (\\{u, y, z\\} \\setminus \\{u\\}) = \\{x, y, z\\}$。这与问题的前提条件，$x, y, z$ 在进入 $B_1$ 时是活跃的，相匹配。\n\n现在，我们使用问题的规则构建正确的冲突图 $G=(V, E)$：对于每条定义变量 $d$ 的指令，在 $d$ 和该指令的活跃出口集合中的每个变量之间添加边（不包括自环）。\n\n*   **指令 $1$** ($u := x+y$)：$\\mathrm{def}[1]=\\{u\\}$，$\\mathrm{live\\_out}[1]=\\{u, y, z\\}$。添加的边：$\\{u, y\\}, \\{u, z\\}$。\n*   **指令 $3$** ($v := u+z$)：$\\mathrm{def}[3]=\\{v\\}$，$\\mathrm{live\\_out}[3]=\\{v\\}$。未添加边。\n*   **指令 $4$** ($w := v+1$)：$\\mathrm{def}[4]=\\{w\\}$，$\\mathrm{live\\_out}[4]=\\{w\\}$。未添加边。\n*   **指令 $6$** ($v := u+1$)：$\\mathrm{def}[6]=\\{v\\}$，$\\mathrm{live\\_out}[6]=\\{v, y\\}$。添加的边：$\\{v, y\\}$。\n*   **指令 $7$** ($w := v+y$)：$\\mathrm{def}[7]=\\{w\\}$，$\\mathrm{live\\_out}[7]=\\{w\\}$。未添加边。\n*   **指令 $9$** ($x := w+1$)：$\\mathrm{def}[9]=\\{x\\}$，$\\mathrm{live\\_out}[9]=\\{x\\}$。未添加边。\n\n正确图中的边集是 $E = \\{\\{u, y\\}, \\{u, z\\}, \\{v, y\\}\\}$。\n\n接下来，我们确定错误的冲突图 $G_f = (V, E_f)$。错误发生在 $\\mathrm{live\\_out}[2]$ 的计算中，这会影响从该点开始的后向分析。\n\n*   **指令 2 处的错误分析**：\n    *   $\\mathrm{live\\_out\\_f}[2] = \\mathrm{live\\_in}[3] \\cap \\mathrm{live\\_in}[6] = \\{u, z\\} \\cap \\{u, y\\} = \\{u\\}$。\n    *   $\\mathrm{live\\_in\\_f}[2] = \\mathrm{use}[2] \\cup (\\mathrm{live\\_out\\_f}[2] \\setminus \\mathrm{def}[2]) = \\{u\\} \\cup (\\{u\\} \\setminus \\emptyset) = \\{u\\}$。\n*   **指令 1 处的错误分析**：\n    *   $\\mathrm{live\\_out\\_f}[1] = \\mathrm{live\\_in\\_f}[2] = \\{u\\}$。\n\n指令 3 到 10 的活跃度信息不受影响，因为从程序出口到条件分支入口点（指令 3 和 6）的后向传递与分支之前发生的事情无关。\n\n现在，我们使用相同的构建规则，但使用错误的活跃度数据来构建错误的图 $E_f$。\n\n*   **指令 $1$** ($u := x+y$)：$\\mathrm{def}[1]=\\{u\\}$，$\\mathrm{live\\_out\\_f}[1]=\\{u\\}$。未添加边。\n*   **指令 $6$** ($v := u+1$)：$\\mathrm{def}[6]=\\{v\\}$，$\\mathrm{live\\_out}[6]=\\{v, y\\}$。添加的边：$\\{v, y\\}$。\n*   所有其他定义指令（$3, 4, 7, 9$）仍然没有添加任何边，因为它们的活跃出口集合没有改变，并且只包含被定义的变量本身。\n\n错误图中的边集是 $E_f = \\{\\{v, y\\}\\}$。这与团队成员的报告相符，证实了我们对过程的理解。\n\n最后，我们被要求计算缺失边的数量，也就是集合差 $E \\setminus E_f$ 的基数。\n$$ E \\setminus E_f = \\{\\{u, y\\}, \\{u, z\\}, \\{v, y\\}\\} \\setminus \\{\\{v, y\\}\\} $$\n$$ E \\setminus E_f = \\{\\{u, y\\}, \\{u, z\\}\\} $$\n缺失边的数量就是这个集合的大小。\n$$ |E \\setminus E_f| = 2 $$\n两条缺失的边是 $\\{u, y\\}$ 和 $\\{u, z\\}$。它们之所以被遗漏，是因为在汇合点的错误交集操作错误地判定 $y$ 和 $z$ 在指令 2 之后不活跃，这又意味着它们在指令 1 之后也不活跃。",
            "answer": "$$ \\boxed{2} $$"
        },
        {
            "introduction": "循环是程序中常见且关键的控制结构，而变量的活性分析不能局限于循环体内。一个变量的生命周期完全可能延伸到循环之外，特别是当它在循环结束后被使用时。这个最终练习将挑战你分析一个带有循环的程序，揭示那些仅看循环体本身时不易察觉的干扰关系是如何产生的。这有助于你深入理解变量在复杂控制流路径下的完整生命周期。",
            "id": "3647442",
            "problem": "编译器后端通过构建一个干涉图来进行寄存器分配，该图的顶点是程序变量，其无向边连接在某个程序点上同时活跃的变量对。在经典的活跃性数据流框架中，基本定义如下：对于每个语句 $s$，其活跃入集合 $\\mathrm{IN}[s]$ 和活跃出集合 $\\mathrm{OUT}[s]$ 满足\n$$\n\\mathrm{IN}[s] = \\mathrm{USE}[s] \\cup \\left( \\mathrm{OUT}[s] \\setminus \\mathrm{DEF}[s] \\right), \\quad \\mathrm{OUT}[s] = \\bigcup_{s' \\in \\mathrm{succ}(s)} \\mathrm{IN}[s'],\n$$\n其中 $\\mathrm{USE}[s]$ 和 $\\mathrm{DEF}[s]$ 分别是在语句 $s$ 中读取和写入的变量集合，而 $\\mathrm{succ}(s)$ 是控制流图（CFG）中的后继语句集合。\n\n考虑以下带有单个循环的直线型三地址代码，代码以带标签的语句和基本块的形式编写。所有变量都是标量临时变量。唯一的控制流如文中所述，并且没有函数调用或别名。该程序的设计使得干涉仅由在循环出口处活跃的变量引起。\n\n基本块和语句：\n- 前导头(Preheader):\n  - 第 $1$ 行: $u \\leftarrow 0$\n  - 第 $2$ 行: $v \\leftarrow 1$\n  - 第 $3$ 行: w \\leftarrow \\mathrm{input}()\n  - 第 $4$ 行: \\mathrm{goto}~L\n- 循环头(Loop header) $L$:\n  - 第 $5$ 行: \\mathrm{if}~(w \\leq 0)~\\mathrm{goto}~E~\\mathrm{else}~\\mathrm{goto}~B\n- 循环体(Loop body) $B$:\n  - 第 $6$ 行: w \\leftarrow w - 1\n  - 第 $7$ 行: \\mathrm{goto}~L\n- 出口(Exit) $E$:\n  - 第 $8$ 行: x \\leftarrow u + w\n  - 第 $9$ 行: y \\leftarrow v + w\n  - 第 $10$ 行: z \\leftarrow x + y\n\n假设控制流图的后继如下：$\\mathrm{succ}(1)=\\{2\\}$, $\\mathrm{succ}(2)=\\{3\\}$, $\\mathrm{succ}(3)=\\{4\\}$, $\\mathrm{succ}(4)=\\{5\\}$, $\\mathrm{succ}(5)=\\{8,6\\}$, $\\mathrm{succ}(6)=\\{7\\}$, $\\mathrm{succ}(7)=\\{5\\}$, $\\mathrm{succ}(8)=\\{9\\}$, $\\mathrm{succ}(9)=\\{10\\}$, $\\mathrm{succ}(10)=\\emptyset$。$\\mathrm{USE}$ 和 $\\mathrm{DEF}$ 集合为：$\\mathrm{DEF}[1]=\\{u\\}$, $\\mathrm{DEF}[2]=\\{v\\}$, $\\mathrm{DEF}[3]=\\{w\\}$, $\\mathrm{DEF}[6]=\\{w\\}$, $\\mathrm{DEF}[8]=\\{x\\}$, $\\mathrm{DEF}[9]=\\{y\\}$, $\\mathrm{DEF}[10]=\\{z\\}$。非空的 $\\mathrm{USE}$ 集合为 $\\mathrm{USE}[5]=\\{w\\}$, $\\mathrm{USE}[6]=\\{w\\}$, $\\mathrm{USE}[8]=\\{u,w\\}$, $\\mathrm{USE}[9]=\\{v,w\\}$, $\\mathrm{USE}[10]=\\{x,y\\}$。\n\n使用上述定义，计算活跃性集合直至达到不动点。然后，通过标准的边生成规则构建干涉图：对于语句 $s$ 处的每个非移动赋值 $a \\leftarrow \\cdots$，添加连接 $a$ 与 $\\mathrm{OUT}[s]$ 中除 $a$ 自身以外的每个变量的无向边。最后，确定干涉图中不同边的总数。将该数字作为最终答案报告。无需四舍五入。答案没有物理单位。",
            "solution": "用户提供的问题是一个关于活跃性分析和干涉图构建的明确定义的练习，其根植于编译器设计的原理。所有必要的组成部分——代码、控制流图（CFG）后继、USE/DEF集合和形式化定义——都已提供且内部一致。该问题具有科学依据、客观且定义明确。因此，问题是有效的，可以推导出完整的解决方案。\n\n解决方案分为两个主要阶段：\n1. 通过迭代数据流方程至不动点，计算每个语句 $s$ 的活跃入（$\\mathrm{IN}[s]$）和活跃出（$\\mathrm{OUT}[s]$）集合。\n2. 使用计算出的活跃出集合，将指定的边生成规则应用于代码中的每个定义，从而构建干涉图。\n\n活跃性分析的数据流方程如下：\n$$\n\\mathrm{IN}[s] = \\mathrm{USE}[s] \\cup \\left( \\mathrm{OUT}[s] \\setminus \\mathrm{DEF}[s] \\right)\n$$\n$$\n\\mathrm{OUT}[s] = \\bigcup_{s' \\in \\mathrm{succ}(s)} \\mathrm{IN}[s']\n$$\n程序中的变量是 $u$、$v$、$w$、$x$、$y$ 和 $z$。该分析是一种后向数据流分析，意味着我们将活跃性信息从一个语句的后继传播回该语句本身。我们将所有的 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合初始化为空集 $\\emptyset$，然后进行迭代，直到没有集合发生变化为止。\n\n提供的 USE 和 DEF 集合如下：\n- $\\mathrm{USE}[1]=\\emptyset, \\mathrm{DEF}[1]=\\{u\\}$\n- $\\mathrm{USE}[2]=\\emptyset, \\mathrm{DEF}[2]=\\{v\\}$\n- $\\mathrm{USE}[3]=\\emptyset, \\mathrm{DEF}[3]=\\{w\\}$\n- $\\mathrm{USE}[4]=\\emptyset, \\mathrm{DEF}[4]=\\emptyset$\n- $\\mathrm{USE}[5]=\\{w\\}, \\mathrm{DEF}[5]=\\emptyset$\n- $\\mathrm{USE}[6]=\\{w\\}, \\mathrm{DEF}[6]=\\{w\\}$\n- $\\mathrm{USE}[7]=\\emptyset, \\mathrm{DEF}[7]=\\emptyset$\n- $\\mathrm{USE}[8]=\\{u,w\\}, \\mathrm{DEF}[8]=\\{x\\}$\n- $\\mathrm{USE}[9]=\\{v,w\\}, \\mathrm{DEF}[9]=\\{y\\}$\n- $\\mathrm{USE}[10]=\\{x,y\\}, \\mathrm{DEF}[10]=\\{z\\}$\n\n后继 $\\mathrm{succ}(s)$ 在问题描述中已给出。分析过程如下，迭代进行直至达到不动点。\n\n在迭代不动点计算收敛后，最终的活跃性集合为：\n- 语句 1: $\\mathrm{OUT}[1] = \\{u\\}$, $\\mathrm{IN}[1] = \\emptyset$\n- 语句 2: $\\mathrm{OUT}[2] = \\{u, v\\}$, $\\mathrm{IN}[2] = \\{u\\}$\n- 语句 3: $\\mathrm{OUT}[3] = \\{u, v, w\\}$, $\\mathrm{IN}[3] = \\{u, v\\}$\n- 语句 4: $\\mathrm{OUT}[4] = \\{u, v, w\\}$, $\\mathrm{IN}[4] = \\{u, v, w\\}$\n- 语句 5: $\\mathrm{OUT}[5] = \\{u, v, w\\}$, $\\mathrm{IN}[5] = \\{u, v, w\\}$\n- 语句 6: $\\mathrm{OUT}[6] = \\{u, v, w\\}$, $\\mathrm{IN}[6] = \\{u, v, w\\}$\n- 语句 7: $\\mathrm{OUT}[7] = \\{u, v, w\\}$, $\\mathrm{IN}[7] = \\{u, v, w\\}$\n- 语句 8: $\\mathrm{OUT}[8] = \\{v, w, x\\}$, $\\mathrm{IN}[8] = \\{u, v, w\\}$\n- 语句 9: $\\mathrm{OUT}[9] = \\{x, y\\}$, $\\mathrm{IN}[9] = \\{v, w, x\\}$\n- 语句 10: $\\mathrm{OUT}[10] = \\emptyset$, $\\mathrm{IN}[10] = \\{x, y\\}$\n\n在确定了最终的活跃性集合后，我们构建干涉图。规则是：对于语句 $s$ 处的每个非移动赋值 $a \\leftarrow \\dots$，在 $a$ 和 $\\mathrm{OUT}[s] \\setminus \\{a\\}$ 中的每个变量之间添加一条无向边。定义语句是 $1, 2, 3, 6, 8, 9, 10$。\n\n1.  **语句 1**：$u \\leftarrow 0$。此处，$a=u$，$s=1$。干涉变量集合为 $\\mathrm{OUT}[1] \\setminus \\{u\\} = \\{u\\} \\setminus \\{u\\} = \\emptyset$。不添加任何边。\n\n2.  **语句 2**：$v \\leftarrow 1$。此处，$a=v$，$s=2$。干涉变量集合为 $\\mathrm{OUT}[2] \\setminus \\{v\\} = \\{u, v\\} \\setminus \\{v\\} = \\{u\\}$。添加一条边 $\\{u, v\\}$。\n\n3.  **语句 3**：$w \\leftarrow \\mathrm{input}()$。此处，$a=w$，$s=3$。干涉变量集合为 $\\mathrm{OUT}[3] \\setminus \\{w\\} = \\{u, v, w\\} \\setminus \\{w\\} = \\{u, v\\}$。添加边 $\\{u, w\\}$ 和 $\\{v, w\\}$。\n\n4.  **语句 6**：$w \\leftarrow w-1$。此处，$a=w$，$s=6$。干涉变量集合为 $\\mathrm{OUT}[6] \\setminus \\{w\\} = \\{u, v, w\\} \\setminus \\{w\\} = \\{u, v\\}$。添加边 $\\{u, w\\}$ 和 $\\{v, w\\}$。这些边与语句 3 生成的边相同。\n\n5.  **语句 8**：$x \\leftarrow u+w$。此处，$a=x$，$s=8$。干涉变量集合为 $\\mathrm{OUT}[8] \\setminus \\{x\\} = \\{v, w, x\\} \\setminus \\{x\\} = \\{v, w\\}$。添加边 $\\{v, x\\}$ 和 $\\{w, x\\}$。\n\n6.  **语句 9**：$y \\leftarrow v+w$。此处，$a=y$，$s=9$。干涉变量集合为 $\\mathrm{OUT}[9] \\setminus \\{y\\} = \\{x, y\\} \\setminus \\{y\\} = \\{x\\}$。添加一条边 $\\{x, y\\}$。\n\n7.  **语句 10**：$z \\leftarrow x+y$。此处，$a=z$，$s=10$。干涉变量集合为 $\\mathrm{OUT}[10] \\setminus \\{z\\} = \\emptyset \\setminus \\{z\\} = \\emptyset$。不添加任何边。\n\n收集所有生成的不同边：\n- 来自语句 2：$\\{u, v\\}$\n- 来自语句 3：$\\{u, w\\}$, $\\{v, w\\}$\n- 来自语句 8：$\\{v, x\\}$, $\\{w, x\\}$\n- 来自语句 9：$\\{x, y\\}$\n\n干涉图中所有不同的无向边集合为：\n1.  $\\{u, v\\}$\n2.  $\\{u, w\\}$\n3.  $\\{v, w\\}$\n4.  $\\{v, x\\}$\n5.  $\\{w, x\\}$\n6.  $\\{x, y\\}$\n\n计算这些不同的边，总数为 $6$。变量 $z$ 不与任何其他变量发生干涉，因为它在任何其他变量被定义的点都不是活跃的，并且在定义 $z$ 的语句处，没有其他变量是活跃出的。",
            "answer": "$$\n\\boxed{6}\n$$"
        }
    ]
}