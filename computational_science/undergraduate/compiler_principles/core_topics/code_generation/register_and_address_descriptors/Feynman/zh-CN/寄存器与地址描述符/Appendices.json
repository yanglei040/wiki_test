{
    "hands_on_practices": [
        {
            "introduction": "编译器在编译代码时，面临一个核心决策：是将一个频繁使用的变量保留在速度更快的寄存器中，还是将其存放在内存（例如，栈）中。这个决策并非总是显而易见的，因为它涉及到一个权衡：寄存器访问速度快，但管理它们（如保存和恢复）会带来开销。本练习将引导你进行一次量化分析，通过建立成本模型来精确计算决定一个变量是否值得被“提升”到寄存器中所需要的最小使用次数，从而揭示编译器优化中的一个基本经济学原理。",
            "id": "3667165",
            "problem": "一个编译器后端维护一个地址描述符 (AD)，它记录了保存变量当前值的内存位置（如栈槽），以及一个寄存器描述符 (RD)，它记录了哪个机器寄存器保存了该值。考虑一个标量临时变量 $t$，它在一个线性基本块的开始处定义，然后在一系列 $u$ 次算术运算（例如，重复加法）中被更新，期间没有函数调用，并且 $t$ 在该基本块末尾是活跃出口（live-out）。编译器总是为 $t$ 分配一个栈槽，并要求在基本块退出时，该栈槽包含当前值。你需要比较两种策略：\n\n- 策略 S（驻留栈中）：仅将 $t$ 保存在其栈槽中（由 AD 跟踪）。每次更新 $t$ 时，编译器从栈槽加载，执行算术运算，然后将更新后的值存回栈槽，以保持 AD 的一致性。\n\n- 策略 R（寄存器提升）：在该基本块的持续时间内，将 $t$ 提升到一个寄存器中（由 RD 跟踪）。编译器执行一次性加载，将 $t$ 放入寄存器，在寄存器中执行所有 $u$ 次更新，并在块退出前执行一次存储，以更新栈槽，从而保持 AD 的一致性。在 $u$ 次更新过程中将 $t$ 保存在寄存器中，会产生预期的每次更新的寄存器干扰开销。\n\n假设使用以下被广泛接受的成本模型，所有成本以周期为单位计算：\n- 从内存加载到寄存器的成本为 $c_{\\mathrm{ld}} = 6$。\n- 从寄存器存储到内存的成本为 $c_{\\mathrm{st}} = 8$。\n- 每次更新的算术运算本身成本为 $c_{\\mathrm{alu}}$，在两种策略下相同。\n- 将 $t$ 提升到寄存器并更新描述符会产生一次性开销 $c_{\\mathrm{prom}} = 3$。\n- 当 $t$ 保存在寄存器中时，预期的每次更新的寄存器干扰开销为 $c_{\\mathrm{int}} = 1$。\n\n从上述定义出发，推导出比较策略 R 与策略 S 的总预期周期成本的盈亏平衡不等式，符号化地解出使用次数 $u$，然后计算使得策略 R 的预期周期成本严格低于策略 S 的最小整数 $u$。给出你的最终答案，形式为一个整数。无需四舍五入。",
            "solution": "该问题要求比较两种在基本块内管理临时变量 $t$ 的编译器策略。要确定策略 R（寄存器提升）何时比策略 S（驻留栈中）更具成本效益，我们必须首先将每种策略的总周期成本表示为更新次数 $u$ 的函数。\n\n设 $C_S(u)$ 为策略 S 的总周期成本， $C_R(u)$ 为策略 R 的总预期周期成本。变量 $u$ 代表对临时变量 $t$ 的算术更新次数。\n\n首先，我们定义策略 S（驻留栈中）的成本。在此策略中， $u$ 次更新中的每一次都涉及从 $t$ 的栈槽中加载值，执行算术运算，然后将新值存回栈槽。成本如下：\n- 一次加载操作的成本：$c_{\\mathrm{ld}}$。\n- 一次算术运算的成本：$c_{\\mathrm{alu}}$。\n- 一次存储操作的成本：$c_{\\mathrm{st}}$。\n\n对于 $u$ 次更新中的每一次，总成本是这三个部分的总和。因此，策略 S 的总成本是：\n$$C_S(u) = u \\cdot (c_{\\mathrm{ld}} + c_{\\mathrm{alu}} + c_{\\mathrm{st}})$$\n\n接下来，我们定义策略 R（寄存器提升）的成本。此策略涉及几个部分：\n- 将 $t$ 提升到寄存器的一次性开销，成本为 $c_{\\mathrm{prom}}$。\n- 将 $t$ 的初始值从内存加载到指定寄存器的一次性加载，成本为 $c_{\\mathrm{ld}}$。\n- 在寄存器上直接执行的一系列 $u$ 次更新。每次更新都包含算术运算本身（成本为 $c_{\\mathrm{alu}}$）和预期的寄存器干扰开销（成本为 $c_{\\mathrm{int}}$）。因此，每次更新的成本为 $(c_{\\mathrm{alu}} + c_{\\mathrm{int}})$。\n- 最后一次性存储，将 $t$ 的最终值从寄存器写回其栈槽，成本为 $c_{\\mathrm{st}}$。这是必要的，因为问题规定在块退出时栈槽必须是正确的。\n\n将这些部分相加，策略 R 的总预期成本为：\n$$C_R(u) = c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + u \\cdot (c_{\\mathrm{alu}} + c_{\\mathrm{int}}) + c_{\\mathrm{st}}$$\n\n我们需要找到使得策略 R 的预期周期成本严格低于策略 S 的最小整数 $u$。这对应于不等式：\n$$C_R(u)  C_S(u)$$\n\n代入 $C_R(u)$ 和 $C_S(u)$ 的表达式：\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}} + u \\cdot (c_{\\mathrm{alu}} + c_{\\mathrm{int}})  u \\cdot (c_{\\mathrm{ld}} + c_{\\mathrm{alu}} + c_{\\mathrm{st}})$$\n\n我们可以展开包含 $u$ 的项：\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}} + u \\cdot c_{\\mathrm{alu}} + u \\cdot c_{\\mathrm{int}}  u \\cdot c_{\\mathrm{ld}} + u \\cdot c_{\\mathrm{alu}} + u \\cdot c_{\\mathrm{st}}$$\n\n项 $u \\cdot c_{\\mathrm{alu}}$ 出现在不等式两侧，可以消去。这是合乎逻辑的，因为核心算术工作的成本在两种策略中是相同的。\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}} + u \\cdot c_{\\mathrm{int}}  u \\cdot c_{\\mathrm{ld}} + u \\cdot c_{\\mathrm{st}}$$\n\n现在，我们通过将所有包含 $u$ 的项集中到不等式的一侧来解出 $u$。\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}}  u \\cdot c_{\\mathrm{ld}} + u \\cdot c_{\\mathrm{st}} - u \\cdot c_{\\mathrm{int}}$$\n$$c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}}  u \\cdot (c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}})$$\n\n为了分离出 $u$，我们除以因子 $(c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}})$。我们必须首先确保这个因子是正数。使用给定值，$c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}} = 6 + 8 - 1 = 13 > 0$，所以不等号的方向保持不变。\n$$u > \\frac{c_{\\mathrm{prom}} + c_{\\mathrm{ld}} + c_{\\mathrm{st}}}{c_{\\mathrm{ld}} + c_{\\mathrm{st}} - c_{\\mathrm{int}}}$$\n这就是为 $u$ 解出的符号化盈亏平衡不等式。\n\n现在，我们将给定的数值成本代入此表达式：\n- $c_{\\mathrm{ld}} = 6$\n- $c_{\\mathrm{st}} = 8$\n- $c_{\\mathrm{prom}} = 3$\n- $c_{\\mathrm{int}} = 1$\n\n$$u > \\frac{3 + 6 + 8}{6 + 8 - 1}$$\n$$u > \\frac{17}{13}$$\n\n为了找到满足此严格不等式的最小整数值 $u$，我们计算这个分数：\n$$\\frac{17}{13} \\approx 1.30769...$$\n不等式为 $u > 1.30769...$。由于 $u$ 必须是一个整数（代表操作次数），严格大于 $1.30769...$ 的最小整数是 $2$。\n\n因此，使得策略 R 严格比策略 S 更高效的最小整数更新次数是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在真实的程序中，寄存器是一种宝贵的稀缺资源。当所有寄存器都被占用时，编译器为了给新的临时变量腾出空间，必须做出一个关键的“寄存器溢出”决策：选择哪个现有变量来写回内存。一个明智的选择可以显著减少性能损失，而地址描述符（AD）为此提供了至关重要的信息。本练习将让你扮演编译器的角色，利用地址描述符和程序运行的剖析数据，来制定一个成本最低的寄存器溢出策略，从而深入理解描述符在实际优化决策中的作用。",
            "id": "3667154",
            "problem": "在程序点 $P$ 处，一个编译器后端必须释放一个寄存器，以存放一个新的临时变量 $t$。该机器提供 $3$ 个通用寄存器，记为 $R_1$、$R_2$ 和 $R_3$，在 $P$ 点它们分别存放变量 $a$、$b$ 和 $c$。编译器维护一个寄存器描述符 (RD) 和一个地址描述符 (AD)。寄存器描述符 (RD) 将每个寄存器映射到其当前值存放在该寄存器中的变量名。地址描述符 (AD) 将每个变量映射到其最新值所在的位置集合，该集合可能包括一个或多个寄存器，也可能包括该变量的内存位置。如果一个变量的地址描述符 (AD) 中包含了其内存位置，那么内存中已经保存了该变量的当前值；否则，该变量的内存值是陈旧的。\n\n在点 $P$ 处，地址描述符 (AD) 的状态如下：\n- 对于 $a$：$AD(a) = \\{R_1\\}$，且 $a$ 的内存值是陈旧的（即，最新值不在内存中）。\n- 对于 $b$：$AD(b) = \\{R_2, M\\}$，其中 $M$ 表示 $b$ 的内存位置是最新值。\n- 对于 $c$：$AD(c) = \\{R_3\\}$，且 $c$ 的内存值是陈旧的。\n\n紧接着 $P$ 点之后，控制流将分支到基本块 $B_1$ 或 $B_2$。一次性能剖析运行报告称，在到达 $P$ 点的条件下，总共 $N = 5000$ 次执行中，到 $B_1$ 的分支被执行了 $N_1 = 3000$ 次，到 $B_2$ 的分支被执行了 $N_2 = 2000$ 次。在每个后继块中，变量的使用和可能的重定义情况如下（只计算在同一变量下一次重定义之前的使用次数）：\n- 在 $B_1$ 中：变量 $a$ 被使用 $2$ 次然后被重定义；变量 $b$ 被使用 $1$ 次且在 $B_1$ 中未被重定义；变量 $c$ 在任何使用之前被重定义（即，重定义前的使用次数为 $0$）。\n- 在 $B_2$ 中：变量 $a$ 立即被重定义（即，使用次数为 $0$）；变量 $b$ 被使用 $2$ 次且在 $B_2$ 中未被重定义；变量 $c$ 被使用 $1$ 次且在 $B_2$ 中未被重定义。\n\n假设在 $P$ 点的寄存器溢出遵循以下成本模型：\n- 如果选择在 $P$ 点溢出变量 $x \\in \\{a,b,c\\}$，那么当且仅当根据其地址描述符 (AD)，$x$ 的内存值不是最新时，才需要一次溢出存储。将此记为 $\\text{spill}(x) \\in \\{0,1\\}$，其中如果在 $P$ 点需要存储操作，则 $\\text{spill}(x) = 1$，否则 $\\text{spill}(x) = 0$。\n- 对于在 $P$ 点被溢出的变量 $x$，其未来的每次使用都会在该次使用前引发恰好一次重载，并且重载后的寄存器值不会在不同的使用之间保留（即，在不同的使用之间没有复用）。令 $\\text{reload}(x)$ 表示从 $P$ 点开始的一次动态执行中，直到 $x$ 下一次被重定义（如果存在）之前，此类重载的期望次数，该值使用从 $N_1$、$N_2$ 和 $N$ 导出的经验分支频率计算。\n\n定义选择溢出 $x$ 的总成本为\n$$\n\\text{cost}(x) = \\alpha \\cdot \\text{spill}(x) + \\beta \\cdot \\text{reload}(x),\n$$\n权重为 $\\alpha = 3$ 和 $\\beta = 2$。\n\n仅使用上述信息以及寄存器描述符 (RD) 和地址描述符 (AD) 的定义，计算在选择 $x \\in \\{a,b,c\\}$ 的情况下，每次执行点 $P$ 的最小化期望总成本。将您的最终答案表示为一个精确的有理数，代表指令成本单位。不要四舍五入。",
            "solution": "该问题要求我们确定在程序点 $P$ 处要溢出的最佳寄存器，以便为新的临时变量腾出空间。该决策基于一个成本模型，该模型考虑了将变量值存储到内存（“溢出”）的直接成本以及为后续使用而从内存重载该值的未来成本。最佳选择是使这个总期望成本最小化的那一个。机器有三个寄存器，$R_1$、$R_2$ 和 $R_3$，分别存放变量 $a$、$b$ 和 $c$。\n\n溢出一个变量 $x$ 的总成本由以下函数给出：\n$$\n\\text{cost}(x) = \\alpha \\cdot \\text{spill}(x) + \\beta \\cdot \\text{reload}(x)\n$$\n其中 $\\alpha = 3$ 且 $\\beta = 2$。我们必须为三个候选变量 $a$、$b$ 和 $c$ 中的每一个计算此成本，然后找出其中的最小值。\n\n首先，我们计算从点 $P$ 出发的两条可能的控制流路径的概率。程序可以分支到基本块 $B_1$ 或 $B_2$。给定的频率是，在总共 $N = N_1 + N_2 = 5000$ 次执行中，到 $B_1$ 的分支有 $N_1 = 3000$ 次，到 $B_2$ 的分支有 $N_2 = 2000$ 次。\n概率为：\n$$\nP(B_1) = \\frac{N_1}{N} = \\frac{3000}{5000} = \\frac{3}{5}\n$$\n$$\nP(B_2) = \\frac{N_2}{N} = \\frac{2000}{5000} = \\frac{2}{5}\n$$\n\n接下来，我们为每个变量 $x \\in \\{a, b, c\\}$ 评估成本函数的两个组成部分：$\\text{spill}(x)$ 和 $\\text{reload}(x)$。\n\n$\\text{spill}(x)$ 项表示在点 $P$ 处的存储操作成本。当且仅当寄存器中变量的当前值尚未存在于其内存位置时（即内存是“陈旧的”），才需要进行存储。如果需要存储，则 $\\text{spill}(x) = 1$，否则 $\\text{spill}(x) = 0$。\n根据给定的地址描述符 (AD) 状态：\n- 对于 $a$：$AD(a) = \\{R_1\\}$，内存是陈旧的。因此，需要一次存储。$\\text{spill}(a) = 1$。\n- 对于 $b$：$AD(b) = \\{R_2, M\\}$，内存是最新值。因此，不需要存储。$\\text{spill}(b) = 0$。\n- 对于 $c$：$AD(c) = \\{R_3\\}$，内存是陈旧的。因此，需要一次存储。$\\text{spill}(c) = 1$。\n\n$\\text{reload}(x)$ 项表示如果变量 $x$ 被溢出，未来所需的重载的期望次数。被溢出变量在下一次重定义前的每次使用都会引发一次重载。我们通过将每个分支中的使用次数按分支概率加权求和，来计算期望使用次数。令 $U_1(x)$ 和 $U_2(x)$ 分别为在基本块 $B_1$ 和 $B_2$ 中，$x$ 在被重定义之前的使用次数。\n$$\n\\text{reload}(x) = U_1(x) \\cdot P(B_1) + U_2(x) \\cdot P(B_2)\n$$\n根据问题描述：\n- 对于变量 $a$：$U_1(a) = 2$（在 $B_1$ 中使用两次），$U_2(a) = 0$（在 $B_2$ 中立即被重定义）。\n$$\n\\text{reload}(a) = 2 \\cdot \\frac{3}{5} + 0 \\cdot \\frac{2}{5} = \\frac{6}{5}\n$$\n- 对于变量 $b$：$U_1(b) = 1$（在 $B_1$ 中使用一次），$U_2(b) = 2$（在 $B_2$ 中使用两次）。\n$$\n\\text{reload}(b) = 1 \\cdot \\frac{3}{5} + 2 \\cdot \\frac{2}{5} = \\frac{3}{5} + \\frac{4}{5} = \\frac{7}{5}\n$$\n- 对于变量 $c$：$U_1(c) = 0$（在 $B_1$ 中使用前被重定义），$U_2(c) = 1$（在 $B_2$ 中使用一次）。\n$$\n\\text{reload}(c) = 0 \\cdot \\frac{3}{5} + 1 \\cdot \\frac{2}{5} = \\frac{2}{5}\n$$\n\n现在我们可以使用权重 $\\alpha = 3$ 和 $\\beta = 2$ 来计算溢出每个变量的总成本。\n\n溢出变量 $a$ 的成本：\n$$\n\\text{cost}(a) = \\alpha \\cdot \\text{spill}(a) + \\beta \\cdot \\text{reload}(a) = 3 \\cdot 1 + 2 \\cdot \\frac{6}{5} = 3 + \\frac{12}{5} = \\frac{15}{5} + \\frac{12}{5} = \\frac{27}{5}\n$$\n\n溢出变量 $b$ 的成本：\n$$\n\\text{cost}(b) = \\alpha \\cdot \\text{spill}(b) + \\beta \\cdot \\text{reload}(b) = 3 \\cdot 0 + 2 \\cdot \\frac{7}{5} = 0 + \\frac{14}{5} = \\frac{14}{5}\n$$\n\n溢出变量 $c$ 的成本：\n$$\n\\text{cost}(c) = \\alpha \\cdot \\text{spill}(c) + \\beta \\cdot \\text{reload}(c) = 3 \\cdot 1 + 2 \\cdot \\frac{2}{5} = 3 + \\frac{4}{5} = \\frac{15}{5} + \\frac{4}{5} = \\frac{19}{5}\n$$\n\n最后，我们比较这三个成本以找到最小值。\n$$\n\\text{cost}(a) = \\frac{27}{5} = 5.4\n$$\n$$\n\\text{cost}(b) = \\frac{14}{5} = 2.8\n$$\n$$\n\\text{cost}(c) = \\frac{19}{5} = 3.8\n$$\n最小成本是 $\\frac{14}{5}$。这对应于溢出变量 $b$。问题要求的是最小化的期望总成本。\n\n最小化的成本是 $\\min(\\text{cost}(a), \\text{cost}(b), \\text{cost}(c)) = \\min(\\frac{27}{5}, \\frac{14}{5}, \\frac{19}{5}) = \\frac{14}{5}$。",
            "answer": "$$\\boxed{\\frac{14}{5}}$$"
        },
        {
            "introduction": "现代编译器广泛采用静态单赋值（SSA）形式来简化和增强优化。在SSA中，当多个控制流路径汇合时，会使用Φ函数来合并来自不同路径的变量值。将这些抽象的Φ函数高效地转换为具体的机器指令，是后端编译器的关键任务之一。本练习模拟了这一高级代码生成过程，你需要利用来自前驱基本块的寄存器和地址描述符信息，通过巧妙地选择一个目标寄存器来消除Φ函数，并最小化数据移动的开销。",
            "id": "3667221",
            "problem": "考虑一个编译器后端中的控制流连接点，该后端用于一台拥有3个通用寄存器 $r_1$、$r_2$ 和 $r_3$ 的机器，且代码处于静态单赋值 (SSA) 形式。连接块 $J$ 有两个前驱 $B_a$ 和 $B_b$。在每个前驱块的末尾，寄存器描述符 (RD) 和地址描述符 (AD) 反映了变量值的当前存放位置。使用标准定义：寄存器描述符 $RD$ 将每个寄存器映射到在该程序点其当前值存放在该寄存器中的变量集合，地址描述符 $AD(v)$ 将每个变量 $v$ 映射到存放 $v$ 的当前值的位置集合（寄存器和可能的内存位置）。\n\n假设在 $B_a$ 块末尾有以下描述符：\n- $RD_{a}(r_1) = \\{a, c\\}$, $RD_{a}(r_2) = \\{b\\}$, $RD_{a}(r_3) = \\emptyset$。\n- $AD_{a}(a) = \\{r_1, M\\}$, $AD_{a}(b) = \\{r_2\\}$。\n\n假设在 $B_b$ 块末尾有以下描述符：\n- $RD_{b}(r_1) = \\{b\\}$, $RD_{b}(r_2) = \\{a, b\\}$, $RD_{b}(r_3) = \\{f\\}$。\n- $AD_{b}(a) = \\{r_2\\}$, $AD_{b}(b) = \\{r_1, r_2, M\\}$。\n\n在 $J$ 的开始处，有一个 $\\phi$ 函数 $x = \\phi(a, b)$，它在来自 $B_a$ 的路径上选择 $a$，在来自 $B_b$ 的路径上选择 $b$。通过仅在前驱块 $B_a$ 和 $B_b$ 中插入复制操作来消除该 $\\phi$ 函数，使得在进入 $J$ 时，$x$ 的值位于单个目标寄存器 $r_t$ 中。目标寄存器 $r_t$ 必须从 $\\{r_1, r_2\\}$ 中选择，因为在 $B_b$ 的末尾 $r_3$ 中存放着 $f$，并且 $f$ 在进入 $J$ 时是活跃的。用于消除 $\\phi$ 函数的允许操作是寄存器到寄存器的移动和从内存加载到寄存器的操作；每个这样的操作都算作一次移动。此时不插入存储到内存的操作，并且除了选择 $r_t$ 之外，不允许进行额外的合并。\n\n从 SSA $\\phi$ 函数消除的标准语义以及寄存器和地址描述符的定义出发，确定能够最小化在 $B_a$ 和 $B_b$ 中插入的总移动次数的 $r_t$ 选择，并计算该最小总数。在你的推理中，分析进入 $J$ 时得到的地址描述符 $AD(x)$，但最终答案只需报告最小总移动次数，形式为一个不带单位的整数。无需四舍五入。",
            "solution": "题目要求我们确定在控制流连接点消除一个 $\\phi$ 函数 $x = \\phi(a, b)$ 所需的最小移动操作次数。在进入连接块 $J$ 时，新变量 $x$ 的值必须位于单个目标寄存器 $r_t$ 中。目标寄存器 $r_t$ 必须从集合 $\\{r_1, r_2\\}$ 中选择。代价是在前驱块 $B_a$ 和 $B_b$ 的末尾插入的寄存器到寄存器移动或内存到寄存器加载的总次数。\n\n令 $C(B_{pred}, v_{pred}, r_t)$ 表示为确保前驱变量 $v_{pred}$ 的值在前驱块 $B_{pred}$ 末尾存在于目标寄存器 $r_t$ 中所需的代价（以移动次数计）。对于给定的 $r_t$ 选择，总代价是每个前驱路径代价的总和：\n$$\n\\text{Total Cost}(r_t) = C(B_a, a, r_t) + C(B_b, b, r_t)\n$$\n我们的目标是找到 $\\min_{r_t \\in \\{r_1, r_2\\}} \\text{Total Cost}(r_t)$。\n\n代价 $C(B_{pred}, v_{pred}, r_t)$ 通过检查块 $B_{pred}$ 末尾的地址描述符 $AD_{pred}(v_{pred})$ 来确定。\n- 如果 $v_{pred}$ 的值已经在 $r_t$ 中（即 $r_t \\in AD_{pred}(v_{pred})$），则不需要任何操作，代价为 $0$。\n- 如果 $v_{pred}$ 的值不在 $r_t$ 中（即 $r_t \\notin AD_{pred}(v_{pred})$），但在另一个寄存器或内存中可用（即 $AD_{pred}(v_{pred}) \\neq \\emptyset$），则需要一条移动或加载指令。代价为 $1$。\n\n我们分析目标寄存器 $r_t$ 的两种可能选择。\n\n**情况 1：目标寄存器为 $r_t = r_1$。**\n\n1.  **来自 $B_a$ 的路径**：我们需要确保变量 $a$ 的值在寄存器 $r_1$ 中。给定 $B_a$ 末尾的地址描述符为 $AD_{a}(a) = \\{r_1, M\\}$。由于 $r_1$ 在 $a$ 的位置集合中，所以 $a$ 的值已经存在于目标寄存器 $r_1$ 中。\n    因此，这条路径的代价是 $C(B_a, a, r_1) = 0$。\n\n2.  **来自 $B_b$ 的路径**：我们需要确保变量 $b$ 的值在寄存器 $r_1$ 中。给定 $B_b$ 末尾的地址描述符为 $AD_{b}(b) = \\{r_1, r_2, M\\}$。由于 $r_1$ 在 $b$ 的位置集合中，所以 $b$ 的值已经存在于目标寄存器 $r_1$ 中。\n    因此，这条路径的代价是 $C(B_b, b, r_1) = 0$。\n\n选择 $r_t = r_1$ 的总代价为：\n$$\n\\text{Total Cost}(r_1) = C(B_a, a, r_1) + C(B_b, b, r_1) = 0 + 0 = 0\n$$\n\n**情况 2：目标寄存器为 $r_t = r_2$。**\n\n1.  **来自 $B_a$ 的路径**：我们需要确保变量 $a$ 的值在寄存器 $r_2$ 中。给定的地址描述符为 $AD_{a}(a) = \\{r_1, M\\}$。寄存器 $r_2$ 不在该集合中。因此，我们必须在 $B_a$ 的末尾插入一条指令，将 $a$ 的值移动到 $r_2$ 中。这可以是从 $r_1$ 进行的寄存器到寄存器移动（`move r2, r1`）或从内存加载。这两种操作的代价都是 $1$。题目说明 $RD_a(r_2) = \\{b\\}$，但由于来自路径 $B_a$ 的 $b$ 的值不是正在解决的 $\\phi$ 函数的输入，并且我们没有得到关于 $b$ 的任何其他活跃性信息，因此我们可以假设 $r_2$ 可以被覆盖。\n    因此，这条路径的代价是 $C(B_a, a, r_2) = 1$。\n\n2.  **来自 $B_b$ 的路径**：我们需要确保变量 $b$ 的值在寄存器 $r_2$ 中。给定的地址描述符为 $AD_{b}(b) = \\{r_1, r_2, M\\}$。由于 $r_2$ 在 $b$ 的位置集合中，所以 $b$ 的值已经存在于目标寄存器 $r_2$ 中。\n    因此，这条路径的代价是 $C(B_b, b, r_2) = 0$。\n\n选择 $r_t = r_2$ 的总代价为：\n$$\n\\text{Total Cost}(r_2) = C(B_a, a, r_2) + C(B_b, b, r_2) = 1 + 0 = 1\n$$\n\n**结论**\n\n比较两种可能的目标寄存器的总代价：\n- 使用 $r_t = r_1$ 的总代价是 $0$。\n- 使用 $r_t = r_2$ 的总代价是 $1$。\n\n最小总移动次数为 $0$，通过选择 $r_t = r_1$ 来实现。\n\n为求完整，我们分析在最优选择 $r_t=r_1$ 的情况下，进入 $J$ 时 $x$ 的最终地址描述符。在进入 $J$ 时，现在可以保证 $x$ 的值在 $r_1$ 中。为了确定该值是否也在内存中，我们检查两个前驱路径。沿着来自 $B_a$ 的路径，该值来自 $a$，并且 $AD_a(a) = \\{r_1, M\\}$，所以该值在内存中。沿着来自 $B_b$ 的路径，该值来自 $b$，并且 $AD_b(b) = \\{r_1, r_2, M\\}$，所以该值也在内存中。由于没有插入会使内存副本失效的操作，因此在连接点处，$x$ 的值也在内存中。因此，最终的地址描述符是 $AD_J(x) = \\{r_1, M\\}$。\n\n题目要求的是最小总移动次数，即 $0$。",
            "answer": "$$\\boxed{0}$$"
        }
    ]
}