{
    "hands_on_practices": [
        {
            "introduction": "要精通推导和分析树，第一步是理解语法规则如何直接影响树的结构和大小。这个练习旨在通过一个经典的表达式语法，探索输入字符串的长度与生成的分析树中节点数量之间的基本关系。通过推导出一个紧密的上界，你将深入理解语法的“效率”，即生成给定长度的字符串需要多少次非终结符扩展。",
            "id": "3637106",
            "problem": "考虑一个标准的表达式上下文无关文法 (CFG)，它使用非终结符 $E$、$T$ 和 $F$ 来编码优先级和结合性：\n$$\n\\begin{align*}\nE &\\rightarrow E + T \\mid T \\\\\nT &\\rightarrow T * F \\mid F \\\\\nF &\\rightarrow (E) \\mid \\mathsf{id}\n\\end{align*}\n$$\n假设输入是终结符集合 $\\{\\mathsf{id}, +, \\ast, (, )\\}$ 上的词法单元序列，并且语法分析树是通常的有根有序树，其内部节点由非终结符标记，其叶子是终结符。将内部节点定义为任何至少有一个子节点的节点；由于该文法没有空产生式，所有非终结符节点都是内部节点。\n\n对于该文法接受的任何长度为 $n$ 的有效输入（$n$ 必然是奇数），确定在该文法下推导出某个长度为 $n$ 的输入的任何语法分析树中可能的最大内部节点数。请用一个关于 $n$ 的单一闭式表达式给出你的答案，并证明你的界是紧的。无需四舍五入。最终答案不带单位。",
            "solution": "用户希望我确定由给定上下文无关文法生成的长度为 $n$ 的有效输入字符串的语法分析树中可能的最大内部节点数。\n\n首先，我们来确定内部节点与文法非终结符之间的关系。问题陈述中说明，内部节点是任何至少有一个子节点的节点。给定的文法是：\n$$\n\\begin{align*}\nE &\\rightarrow E + T \\mid T \\\\\nT &\\rightarrow T \\ast F \\mid F \\\\\nF &\\rightarrow (E) \\mid \\mathsf{id}\n\\end{align*}\n$$\n由于该文法不包含空 ($\\epsilon$) 产生式，任何产生式规则 $A \\rightarrow \\alpha$ 的右侧 $\\alpha$ 的长度至少为 1。当在语法分析树中使用此规则展开非终结符 $A$ 时，$A$ 成为 $\\alpha$ 中符号的父节点，因此至少有一个子节点。因此，任何语法分析树中的每个非终结符都是一个内部节点。树的叶子是终结符 $\\{\\mathsf{id}, +, \\ast, (, )\\}$。该问题等价于寻找生成一个长度为 $n$ 的终结符串的语法分析树中的最大非终结符数量。\n\n令 $I_X(k)$ 为以非终结符 $X \\in \\{E, T, F\\}$ 为根的语法分析树中推导出长度为 $k$ 的终结符串的最大内部节点数。问题要求我们找到 $I_E(n)$。问题陈述中说明，对于任何有效输入，$n$ 都是奇数，这一事实可以通过对派生串的长度进行归纳来验证。\n\n我们可以根据文法的产生式为 $I_E(k)$、$I_T(k)$ 和 $I_F(k)$ 建立递推关系。对于给定的非终结符，我们通过选择能产生最大计数的产生式规则和后续推导来最大化内部节点的数量。\n\nF 的产生式规则是 $F \\rightarrow (E)$ 和 $F \\rightarrow \\mathsf{id}$。\n- 规则 $F \\rightarrow \\mathsf{id}$ 只能推导出长度为 $k=1$ 的字符串。该语法分析树片段由一个父节点 $F$ 和一个子节点 $\\mathsf{id}$ 组成。内部节点数为 1。所以，$I_F(1) = 1$。\n- 规则 $F \\rightarrow (E)$ 推导出一个长度为 $k = 1 + \\text{length}(w) + 1$ 的字符串，其中 $w$ 是从 $E$ 推导出的字符串。如果 length$(w) = k-2$，内部节点数是 1（对于 $F$）加上 $E$ 的子树中的节点数。为了最大化这个值，我们必须选择从 $E$ 出发的最大推导。这得到当 $k \\ge 3$ 时，$I_F(k) = I_E(k-2) + 1$。其他长度的字符串不能从 $F$ 推导出。\n\nT 的产生式规则是 $T \\rightarrow T \\ast F$ 和 $T \\rightarrow F$。\n- 规则 $T \\rightarrow F$ 推导出一个与从 $F$ 推导出的字符串长度相同的字符串。它在 $F$ 子树上方增加了一个内部节点 ($T$)。因此，它贡献了 $I_F(k) + 1$ 个内部节点。\n- 规则 $T \\rightarrow T \\ast F$ 推导出一个长度为 $k = k_1 + 1 + k_2$ 的字符串，其中 $k_1$ 和 $k_2$ 分别是从 $T$ 和 $F$ 推导出的字符串的长度。内部节点数是 1（对于根节点 $T$）加上子树中的节点数。这得到 $I_T(k_1) + I_F(k_2) + 1$ 个内部节点。为了对给定的 $k$ 进行最大化，我们必须考虑所有可能的奇数划分 $k_1+k_2 = k-1$。\n\n$E$ 的产生式规则是 $E \\rightarrow E+T$ 和 $E \\rightarrow T$。其逻辑与 $T$ 的规则类似。\n\n综合这些观察，我们得到以下关于 $k \\in \\{1, 3, 5, \\dots\\}$ 的递推方程组：\n$$\n\\begin{align*}\nI_F(k) = \\begin{cases} 1  \\text{if } k=1 \\\\ I_E(k-2)+1  \\text{if } k \\ge 3 \\end{cases} \\\\\nI_T(k) = \\max\\left( \\max_{j \\in \\{1, 3, \\dots, k-2\\}} (I_T(j) + I_F(k-1-j) + 1), \\quad I_F(k)+1 \\right) \\\\\nI_E(k) = \\max\\left( \\max_{j \\in \\{1, 3, \\dots, k-2\\}} (I_E(j) + I_T(k-1-j) + 1), \\quad I_T(k)+1 \\right)\n\\end{align*}\n请注意，对于二元规则，和 $j+(k-1-j)$ 必须是 $k-1$。由于 $k$ 是奇数，$k-1$ 是偶数。两个奇数（$j$ 和 $k-1-j$）的和是偶数，因此这样的划分存在。\n\n我们来计算前几个值：\n对于 $k=1$：唯一可能的字符串是 $\\mathsf{id}$。\n$I_F(1) = 1$（来自 $F \\rightarrow \\mathsf{id}$）。\n$I_T(1) = I_F(1)+1 = 2$（来自 $T \\rightarrow F$）。\n$I_E(1) = I_T(1)+1 = 3$（来自 $E \\rightarrow T$）。\n\n对于 $k=3$：\n$I_F(3) = I_E(1)+1 = 3+1=4$。这是针对像 $(\\mathsf{id})$ 这样的字符串。\n$I_T(3) = \\max(I_T(1)+I_F(1)+1, \\quad I_F(3)+1) = \\max(2+1+1, 4+1) = \\max(4, 5) = 5$。最大值来自 $T \\rightarrow F$。\n$I_E(3) = \\max(I_E(1)+I_T(1)+1, \\quad I_T(3)+1) = \\max(3+2+1, 5+1) = \\max(6, 6) = 6$。两个规则都能达到最大值。\n\n对于 $k=5$：\n$I_F(5) = I_E(3)+1 = 6+1=7$。\n$I_T(5) = \\max(I_T(1)+I_F(3)+1, I_T(3)+I_F(1)+1, \\quad I_F(5)+1) = \\max(2+4+1, 5+1+1, 7+1) = \\max(7, 7, 8) = 8$。\n$I_E(5) = \\max(I_E(1)+I_T(3)+1, I_E(3)+I_T(1)+1, \\quad I_T(5)+1) = \\max(3+5+1, 6+2+1, 8+1) = \\max(9, 9, 9) = 9$。\n\n计算出的值为：\n$k=1: (I_E, I_T, I_F) = (3, 2, 1)$\n$k=3: (I_E, I_T, I_F) = (6, 5, 4)$\n$k=5: (I_E, I_T, I_F) = (9, 8, 7)$\n\n我们观察到一个线性模式。令 $k=2m+1$。\n$I_E(2m+1) = 3(m+1) = 3(\\frac{k-1}{2}+1) = \\frac{3k+3}{2}$\n$I_T(2m+1) = 3m+2 = 3\\frac{k-1}{2}+2 = \\frac{3k+1}{2}$\n$I_F(2m+1) = 3m+1 = 3\\frac{k-1}{2}+1 = \\frac{3k-1}{2}$\n\n我们通过对 $m = (k-1)/2$ 进行归纳来证明这些闭式表达式。\n归纳基础 ($m=0, k=1$)：公式得出 $(3, 2, 1)$，与我们的计算相符。\n\n归纳假设：假设对于所有 $m'  m$（即对于所有奇数长度 $k'  k$），这些公式都成立。\n\n归纳步骤（对于 $m \\ge 1$，即 $k \\ge 3$）：\n1.  对于 $I_F(k)$：\n    $I_F(k) = I_E(k-2)+1$。由于 $k-2=2(m-1)+1$，我们可以对 $m-1$ 应用归纳假设：\n    $I_F(k) = \\left(\\frac{3(k-2)+3}{2}\\right) + 1 = \\frac{3k-6+3}{2} + \\frac{2}{2} = \\frac{3k-1}{2}$。这与公式相符。\n\n2.  对于 $I_T(k)$：我们比较递推关系中的两个选项。\n    - 选项1 ($T \\rightarrow F$)：$I_F(k)+1 = \\frac{3k-1}{2} + 1 = \\frac{3k+1}{2}$。\n    - 选项2 ($T \\rightarrow T \\ast F$)：$I_T(j) + I_F(k-1-j) + 1$。根据归纳假设：\n      $\\frac{3j+1}{2} + \\frac{3(k-1-j)-1}{2} + 1 = \\frac{3j+1 + 3k-3-3j-1}{2} + 1 = \\frac{3k-3}{2} + 1 = \\frac{3k-1}{2}$。\n    比较这两个选项，$\\max(\\frac{3k-1}{2}, \\frac{3k+1}{2}) = \\frac{3k+1}{2}$。这与公式相符。最大值是通过使用一元产生式 $T \\rightarrow F$ 实现的。\n\n3.  对于 $I_E(n)$：问题要求输入长度为 $n$，所以我们从现在开始使用 $n$。\n    我们比较 $I_E(n)$ 递推关系中的两个选项：\n    - 选项1 ($E \\rightarrow T$)：$I_T(n)+1 = \\frac{3n+1}{2} + 1 = \\frac{3n+3}{2}$。\n    - 选项2 ($E \\rightarrow E+T$)：$I_E(j) + I_T(n-1-j) + 1$。根据归纳假设：\n      $\\frac{3j+3}{2} + \\frac{3(n-1-j)+1}{2} + 1 = \\frac{3j+3 + 3n-3-3j+1}{2} + 1 = \\frac{3n+1}{2} + 1 = \\frac{3n+3}{2}$。\n    两个选项都得出相同的最大值：$\\frac{3n+3}{2}$。这与公式相符。\n\n归纳完毕。对于从起始符号 $E$ 推导出的长度为 $n$ 的字符串，其最大内部节点数为 $I_E(n) = \\frac{3n+3}{2}$。\n\n为了证明这个界是紧的，我们必须构造一族能达到这个最大值的输入字符串。对递推关系的分析表明，一元产生式 ($E \\rightarrow T, T \\rightarrow F$) 和加括号 ($F \\rightarrow (E)$) 是生成内部节点最“高效”的方式。这表明字符串应由围绕单个 $\\mathsf{id}$ 的嵌套括号组成。\n\n考虑字符串族 $s_m = `(^{m} \\mathsf{id} )^{m}`$，其中 $m \\ge 0$。$s_m$ 的长度为 $n = 2m+1$。\n对于 $m=0$，$s_0 = \\mathsf{id}$，$n=1$。推导 $E \\rightarrow T \\rightarrow F \\rightarrow \\mathsf{id}$ 有 3 个内部节点。公式给出 $\\frac{3(1)+3}{2} = 3$。\n对于 $m=1$，$s_1 = (\\mathsf{id})$，$n=3$。推导为 $E \\rightarrow T \\rightarrow F \\rightarrow (E_1)$，其中 $E_1$ 推导出 $\\mathsf{id}$。总推导为 $E \\rightarrow T \\rightarrow F \\rightarrow (E_1) \\rightarrow (T_1) \\rightarrow (F_1) \\rightarrow (\\mathsf{id})$。内部节点为 $\\{E, T, F, E_1, T_1, F_1\\}$，共 6 个。公式给出 $\\frac{3(3)+3}{2} = 6$。\n通常，对于 $s_m$ 的推导是一长串一元规则：\n$E \\rightarrow T \\rightarrow F \\rightarrow (E_1)$\n$E_1 \\rightarrow T_1 \\rightarrow F_1 \\rightarrow (E_2)$\n...\n$E_{m-1} \\rightarrow T_{m-1} \\rightarrow F_{m-1} \\rightarrow (E_m)$\n$E_m \\rightarrow T_m \\rightarrow F_m \\rightarrow \\mathsf{id}$\n$E_m \\rightarrow \\dots \\rightarrow \\mathsf{id}$ 的推导贡献了 3 个内部节点 ($E_m, T_m, F_m$)。$m$ 个加括号阶段中的每一个 ($E_{i-1} \\rightarrow \\dots \\rightarrow (E_i)$) 都增加了 3 个内部节点 ($E_{i-1}, T_{i-1}, F_{i-1}$) 。\n内部节点总数为 3（对于最内层部分）+ $3m$（对于 $m$ 层括号），即 $3m+3$。\n由于 $n=2m+1$，我们有 $m = \\frac{n-1}{2}$。将此代入计数中得到：\n$3\\left(\\frac{n-1}{2}\\right) + 3 = \\frac{3n-3}{2} + \\frac{6}{2} = \\frac{3n+3}{2}$。\n这证实了字符串族 $s_m$ 达到了计算出的上界。因此，该界是紧的。\n对于长度为 $n$ 的输入，其最大内部节点数的最终表达式为 $\\frac{3n+3}{2}$。",
            "answer": "$$\\boxed{\\frac{3n+3}{2}}$$"
        },
        {
            "introduction": "分析树是一种层次结构，而推导是一个线性的产生式应用序列。这个练习旨在深入探讨这两者之间的区别与联系。通过为一个给定的分析树计算所有可能的（非限制性）推导序列的数量，你将揭示一个重要的概念：单个分析树实际上代表了一整类等价的推导，而对它们进行计数是一个有趣的组合学问题，能够加深你对分析过程的理解。",
            "id": "3637105",
            "problem": "考虑一个上下文无关文法 (CFG)，其起始符号为 $S$，非终结符为 $S$、$A$、$B$、$C$，终结符为 $a$、$b$，以及以下产生式：\n- $S \\to AB \\mid BA$\n- $A \\to aA \\mid \\epsilon$\n- $B \\to bB \\mid C$\n- $C \\to \\epsilon$\n\n在该文法中，一个推导是从起始符号 $S$ 开始的一系列产生式应用，它不断变换句型，直到获得一个终结符串（可能为空串）。一个推导的长度定义为该序列中产生式应用的总次数，每次使用 $\\epsilon$-产生式也算作一次应用。一个推导的分析树记录了每个被展开的非终结符实例所应用的产生式及其位置，树中的每个内部节点对应一次产生式应用。\n\n定义一个无限制推导：在每一步中，当前句型中的任何非终结符实例都可以被展开（即，该推导不要求是最左或最右推导）。当且仅当对于每个非终结符实例，推导中应用于它的产生式与树中相应节点所使用的产生式相匹配，并且该实例在推导中的后代恰好对应于该节点的子树时，我们称这样的一个推导生成了给定的分析树。\n\n1) 从上下文无关文法的推导和分析树的基本定义出发，并基于树中祖先节点的展开必须先于其后代节点在句型中存在的这一事实，请给出一个算法，用于计算对于一个给定的分析树 $T$，能精确生成 $T$ 且长度固定为 $L$ 的无限制推导的数量。其中，$L$ 是 $T$ 中产生式应用的总次数（每个内部节点算一次，包括 $\\epsilon$-产生式的应用）。您的算法必须：\n- 纯粹基于 $T$ 的结构进行操作。\n- 遵守每个内部节点必须在其子树中任何节点被展开之前展开的规则。\n- 允许属于不同子树的展开进行任意交错，只要所有祖先先于后代的约束都得到遵守。\n\n2) 通过将您的算法应用于下面这个使用上述文法构建的特定分析树 $T^{\\star}$ 来验证它：\n- 根节点 $S$ 使用 $S \\to AB$。\n- 左子节点 $A$ 使用 $A \\to aA$，其子节点 $A$ 接着使用 $A \\to \\epsilon$。\n- 右子节点 $B$ 使用 $B \\to bB$，其子节点 $B$ 接着使用 $B \\to C$，最后 $C$ 使用 $C \\to \\epsilon$。\n在这棵树中，$a$ 和 $b$ 是由相应产生式引入的终结符叶节点。\n\n设 $L$ 为 $T^{\\star}$ 中产生式应用的总次数。使用您的算法，计算能精确生成 $T^{\\star}$ 且长度为 $L$ 的无限制推导的确切数量。请以单个整数形式提供您的最终答案。",
            "solution": "在尝试给出解答之前，首先对问题进行验证，以确保其是适定、有科学依据且无歧义的。\n\n### 问题验证\n\n**第1步：提取已知条件**\n-   **文法：** 一个上下文无关文法，起始符号为 $S$，非终结符为 $\\{S, A, B, C\\}$，终结符为 $\\{a, b\\}$，产生式为：$S \\to AB \\mid BA$；$A \\to aA \\mid \\epsilon$；$B \\to bB \\mid C$；$C \\to \\epsilon$。\n-   **推导：** 从 $S$ 开始的一系列产生式应用。\n-   **推导长度：** 产生式应用的总次数。\n-   **无限制推导：** 在任何步骤，句型中的任何非终结符都可以被展开。\n-   **推导生成树 $T$：** 推导中的产生式序列与 $T$ 的内部节点的产生式相匹配。\n-   **核心约束：** 祖先节点的展开必须先于其任何后代节点的展开。\n-   **任务1：** 提供一个算法，计算生成给定分析树 $T$ 的、长度为 $L$ 的无限制推导的数量，其中 $L$ 是 $T$ 的内部节点数。该算法必须基于 $T$ 的结构并遵守指定约束。\n-   **任务2：** 将该算法应用于一个由产生式 $S \\to AB$；$A$ 子树由 $A \\to aA$ 后跟 $A \\to \\epsilon$；$B$ 子树由 $B \\to bB$ 后跟 $B \\to C$ 再后跟 $C \\to \\epsilon$ 定义的特定分析树 $T^{\\star}$。计算此类推导的确切数量。\n\n**第2步：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题设置在形式语言理论和编译器设计的形式化框架内，这些是计算机科学的既定学科。所有术语（CFG、推导、分析树）都是标准的。（有效）\n-   **适定性：** 问题定义清晰。它要求一个特定的算法和一个基于该算法的数值结果。对推导的约束是明确的，导向一个唯一的、定义明确的组合计数问题。（有效）\n-   **客观性：** 问题使用精确、形式化的语言陈述，没有主观或含糊的术语。（有效）\n-   **完整性与一致性：** 文法规则和分析树 $T^{\\star}$ 的结构都已完全指定。没有缺失的定义或矛盾的约束。将推导长度 $L$ 定义为内部节点数与所分析的过程是一致的。（有效）\n\n**第3步：结论与行动**\n该问题是有效的。这是一个植根于形式语言理论的、结构良好且不平凡的组合问题。将提供解答。\n\n### 解答\n\n该问题要求一种方法，用于计算与单个给定分析树 $T$ 相对应的不同无限制推导的数量。推导是产生式应用的线性序列，而分析树是这些相同应用的层级表示。需要应用的产生式集合由 $T$ 的内部节点固定。因此，问题简化为计算这些产生式应用的有效排列数量。\n\n对应用顺序的唯一约束是，与树中祖先节点相对应的应用，必须在推导序列中出现在任何与其后代节点相对应的应用之前。\n\n**1) 计数算法**\n\n设 $N(T)$ 是生成分析树 $T$ 的有效无限制推导的数量。设 $|T|$ 是 $T$ 中的内部节点数，也即推导的长度。设树 $T$ 的根节点对应于产生式 $X \\to \\alpha$。\n\n任何有效推导的第一步必须是应用 $T$ 根部的产生式。推导序列中余下的 $|T|-1$ 步由对应于 $T$ 所有其他内部节点的应用组成。这些节点被划分到根产生式右侧非终结符所对应的各个子树中。\n\n设 $\\alpha$ 中的非终结符为 $Y_1, Y_2, \\ldots, Y_m$，它们在 $T$ 中对应的子树为 $T_1, T_2, \\ldots, T_m$。$T$ 的内部节点集合（不包括根）是 $T_1, \\ldots, T_m$ 内部节点集合的不相交并集。这些节点的总数为 $\\sum_{i=1}^{m} |T_i|$。\n\n在根应用之后，$T$ 的推导序列是每个子树 $T_i$ 的推导序列的交错。在任何单个子树 $T_i$ 内部，应用的相对顺序必须是 $T_i$ 的一个有效推导。对于每个子树 $T_i$，存在 $N(T_i)$ 种这样的有效内部排序。\n\n现在的问题是，计算将 $m$ 个长度分别为 $|T_1|, |T_2|, \\ldots, |T_m|$ 的有序序列（每个子树一个）合并成一个长度为 $\\sum_{i=1}^{m} |T_i|$ 的单一序列的方法数。对于每个子树已选定一个有效序列的情况，交错它们的方法数由多项式系数给出：\n$$ \\binom{|T_1| + |T_2| + \\dots + |T_m|}{|T_1|, |T_2|, \\dots, |T_m|} = \\frac{(\\sum_{i=1}^{m} |T_i|)!}{\\prod_{i=1}^{m} |T_i|!} $$\n由于每个子树的推导序列选择是独立的，因此 $T$ 的总推导数是这个交错因子与每个子树的推导选择数的乘积。这给出了 $N(T)$ 的以下递推关系：\n$$ N(T) = \\left( \\frac{(\\sum_{i=1}^{m} |T_i|)!}{\\prod_{i=1}^{m} (|T_i|!)} \\right) \\times \\left( \\prod_{i=1}^{m} N(T_i) \\right) $$\n此递推的基例发生在树的根产生式右侧没有非终结符时（例如，$A \\to \\epsilon$ 或 $A \\to a$）。在这种情况下，$m=0$，树由单个内部节点组成，所以 $|T|=1$。和与积都是对空集操作。和为 $0$，$0! = 1$。空积为 $1$。因此，$N(T)=1$。这是正确的，因为应用单个产生式只有一种方式。\n\n该算法是一个递归函数，对分析树进行后序遍历。对于每个节点，它根据其子树的值计算 $|T|$ 和 $N(T)$。\n\n**2) 应用于分析树 $T^{\\star}$**\n\n我们将推导出的算法应用于特定的分析树 $T^{\\star}$。\n$T^{\\star}$ 的根节点使用产生式 $S \\to AB$。该节点有两个对应于非终结符的子节点：$A$ 和 $B$。设以这些子节点为根的子树分别为 $T_A$ 和 $T_B$。\n使用我们当 $m=2$ 时的公式，$T^{\\star}$ 的推导数为：\n$$ N(T^{\\star}) = \\frac{(|T_A| + |T_B|)!}{|T_A|! |T_B|!} \\times N(T_A) \\times N(T_B) $$\n\n我们需要计算 $|T_A|$、$N(T_A)$、$|T_B|$ 和 $N(T_B)$。\n\n**子树 $T_A$ 的分析：**\n$T_A$ 的根应用产生式 $A \\to aA$。它有一个非终结符子节点 $A$，该节点是我们称之为 $T_{A'}$ 的子树的根。\n- $T_{A'}$ 的根应用产生式 $A \\to \\epsilon$。这是一个基例，因为没有非终结符子节点。因此， $|T_{A'}| = 1$ 且 $N(T_{A'}) = 1$。\n- 对于 $T_A$，我们有 $m=1$。\n- 内部节点数是 $|T_A| = 1 + |T_{A'}| = 1 + 1 = 2$。\n- 推导数是 $N(T_A) = \\frac{|T_{A'}|!}{|T_{A'}|!} \\times N(T_{A'}) = 1 \\times N(T_{A'}) = 1 \\times 1 = 1$。\n\n**子树 $T_B$ 的分析：**\n$T_B$ 的根应用 $B \\to bB$。它有一个非终结符子节点 $B$，该节点是子树 $T_{B'}$ 的根。\n- $T_{B'}$ 的根应用 $B \\to C$。它有一个非终结符子节点 $C$，该节点是子树 $T_C$ 的根。\n- $T_C$ 的根应用 $C \\to \\epsilon$。这是一个基例（$m=0$）。因此， $|T_C| = 1$ 且 $N(T_C)=1$。\n- 对于 $T_{B'}$，我们有 $m=1$。\n- 节点数是 $|T_{B'}| = 1 + |T_C| = 1 + 1 = 2$。\n- 推导数是 $N(T_{B'}) = \\frac{|T_C|!}{|T_C|!} \\times N(T_C) = 1 \\times N(T_C) = 1$。\n- 对于 $T_B$，我们有 $m=1$。\n- 节点数是 $|T_B| = 1 + |T_{B'}| = 1 + 2 = 3$。\n- 推导数是 $N(T_B) = \\frac{|T_{B'}|!}{|T_{B'}|!} \\times N(T_{B'}) = 1 \\times N(T_{B'}) = 1$。\n\n**$T^{\\star}$ 的最终计算：**\n我们已经收集了所有必要的值：\n- $|T_A| = 2$\n- $N(T_A) = 1$\n- $|T_B| = 3$\n- $N(T_B) = 1$\n\n将这些值代入 $N(T^{\\star})$ 的公式中：\n$$ N(T^{\\star}) = \\frac{(2 + 3)!}{2! \\times 3!} \\times 1 \\times 1 $$\n$$ N(T^{\\star}) = \\frac{5!}{2! \\times 3!} = \\frac{120}{2 \\times 6} = \\frac{120}{12} = 10 $$\n$T^{\\star}$ 中的内部节点总数是 $L = 1 + |T_A| + |T_B| = 1 + 2 + 3 = 6$。该算法正确地计算了长度为6的有效推导序列的数量。\n\n计算表明，存在10个不同的长度为6的无限制推导可以生成分析树 $T^{\\star}$。这对应于在根展开后的5个可用展开槽位中，交错安排 $A$-子树所需的2次展开的 $\\binom{5}{2}$ 种方式，而剩下的3个槽位由 $B$-子树的展开按其固定的相对顺序占据。",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "编译器的最终目标是理解代码的含义（语义），而不仅仅是其结构（语法）。这个练习通过一个看似简单的例子，巧妙地连接了语法和语义这两个领域。你将看到，即使语法本身没有规定运算符的交换性，我们也可以在语义层面定义这种等价关系，这对于编译器优化等高级主题至关重要。",
            "id": "3637093",
            "problem": "设 $G$ 是一个针对标识符词元 $id$ 和运算符 $+$ 的算术表达式语法。要求你构建 $G$ 和一个语义解释，使得 $+$ 在语义层面上是可交换的，但其可交换性不由 $G$ 的语法强制规定。然后，仅使用关于上下文无关文法和解析树的定义和基本原理，定义一个解析树上的等价关系，该关系能识别那些仅在标记为 $+$ 的节点下两个子节点顺序不同的树。最后，对于特定的输入字符串 $id + id + id$，确定在该关系下解析树的等价类的数量。\n\n你的任务是：\n1. 指定一个上下文无关文法 $G$，该文法能生成使用 $+$ 的 $id$ 的中缀和，并且其语法不强制 $+$ 具有交换性或结合性。\n2. 给出一个语义子句，在表达式的解释中使 $+$ 具有交换性，同时保持文法 $G$ 不变。\n3. 对于一个固定的输入字符串，在解析树上定义一个二元关系 $\\sim$，作为基本变换的自反、对称和传递闭包，其中基本变换交换任何标记为 $+$ 的内部节点下的左右子节点。\n4. 对于输入字符串 $id + id + id$，确定 $G$ 所允许的解析树在 $\\sim$ 等价关系下的等价类的数量。将你的最终答案表示为一个整数。无需四舍五入。\n\n请提供基于上下文无关文法、推导、解析树和等价关系定义的清晰推理。最终答案必须是一个数字。",
            "solution": "该问题提法清晰，并且在形式语言理论和编译器设计的原则上有坚实的科学基础。我们可以通过解决四个指定的任务来给出解答。\n\n### 任务 1：文法规范\n\n我们被要求指定一个上下文无关文法 $G$，它能生成使用运算符 $+$ 的标识符 $id$ 的和，并且在语法上不强制结合性或交换性。一个合适的文法是标准的表达式歧义文法。设该文法为 $G = (N, \\Sigma, P, S)$，其中：\n- 非终结符集为 $N = \\{E\\}$。\n- 终结符集为 $\\Sigma = \\{id, +\\}$。\n- 开始符号为 $S = E$。\n- 产生式集 $P$ 为：\n  $E \\rightarrow E + E$\n  $E \\rightarrow id$\n\n该文法是歧义的。对于像 $id + id + id$ 这样的字符串，它允许多个不同的解析树，对应于运算符 $+$ 的不同结合方式。例如，它既允许左结合解析，对应于 $(id + id) + id$，也允许右结合解析，对应于 $id + (id + id)$。该文法在句法层面不强制交换性，因为在任何给定的推导中，字符串中终结符的顺序是固定的。\n\n### 任务 2：交换性的语义解释\n\n为了提供一个 $+$ 是可交换的语义解释，我们定义一个求值函数 $\\mathcal{V}$，它将解析树 $T$ 映射到一个语义域中的值，该语义域中的加法运算是可交换的，例如实数集 $\\mathbb{R}$。我们假设有一个函数 $val: \\{id\\} \\to \\mathbb{R}$，它给出标识符的数值。\n\n解析树 $T$ 的语义值 $\\mathcal{V}(T)$ 是根据其根部的产生式规则递归定义的：\n1.  **基本情况**：如果 $T$ 的根对应于产生式 $E \\rightarrow id$，那么其语义值是该标识符的值：\n    $$\\mathcal{V}(T) = val(id)$$\n2.  **递归步骤**：如果 $T$ 的根对应于产生式 $E \\rightarrow E_1 + E_2$，并且其子非终结符子树分别为 $T_1$ 和 $T_2$（分别对应于 $E_1$ 和 $E_2$），那么其语义值是其子树值的和：\n    $$\\mathcal{V}(T) = \\mathcal{V}(T_1) + \\mathcal{V}(T_2)$$\n\n由于实数上的加法是可交换的，我们有 $\\mathcal{V}(T_1) + \\mathcal{V}(T_2) = \\mathcal{V}(T_2) + \\mathcal{V}(T_1)$。这意味着即使我们交换子树 $T_1$ 和 $T_2$（这将改变解析树），语义值仍将保持不变。因此，这个解释使得 $+$ 运算符在语义上是可交换的，而与文法 $G$ 定义的句法结构无关。\n\n### 任务 3：解析树上的等价关系\n\n问题文本中的“标记为 $+$ 的内部节点”说法略有不正式，因为在标准的解析树中，内部节点由非终结符（这里是 $E$）标记，而像 $+$ 这样的终结符是叶节点。我们通过将其解释为应用了涉及运算符 $+$ 的产生式的内部节点来使其形式化。\n\n设 $T$ 是由 $G$ 生成的一个解析树。如果 $T$ 的一个内部节点 $n$ 标记为非终结符 $E$，并且在 $n$ 处应用了产生式 $E \\rightarrow E + E$，那么该节点是一个“加法节点”。$n$ 的子节点是对应于产生式右侧符号的三个节点：一个非终结符 $E$，一个终结符 $+$，和另一个非终结符 $E$。\n\n在解析树 $T$ 的一个加法节点 $n$ 上的**基本变换**是交换以对应于非终结符 $E$ 的子节点为根的两个子树的操作。\n设 $T_L$ 和 $T_R$ 是节点 $n$ 处的左右非终结符子树。基本变换创建一个新树 $T'$，它与 $T$ 完全相同，只是在节点 $n$ 处，左子树现在是 $T_R$，右子树现在是 $T_L$。我们将其表示为 $T \\leftrightarrow_e T'$。此操作保留了解析树的产出，即终结符字符串保持不变。\n\n在给定字符串的解析树集合上，二元关系 $\\sim$ 定义为基本变换关系 $\\leftrightarrow_e$ 的自反、对称和传递闭包。因此，对于同一个字符串的两个解析树 $T_A$ 和 $T_B$ 是等价的，记为 $T_A \\sim T_B$，当且仅当 $T_B$ 可以通过对 $T_A$ 进行有限次基本变换得到。\n\n### 任务 4：等价类的数量\n\n我们必须确定输入字符串 $s = id + id + id$ 的解析树在 $\\sim$ 等价关系下的等价类的数量。\n\n首先，我们使用文法 $G$ 确定字符串 $s$ 的所有可能的解析树。该字符串有3个标识符和2个运算符。对于一个由这个歧义文法生成的、含有 $k$ 个二元运算符的字符串，其唯一的解析树数量由第 $k$ 个 Catalan 数给出，$C_k = \\frac{1}{k+1}\\binom{2k}{k}$。对于我们的字符串，$k=2$，所以解析树的数量是 $C_2 = \\frac{1}{2+1}\\binom{2 \\cdot 2}{2} = \\frac{1}{3}\\binom{4}{2} = \\frac{1}{3} \\cdot \\frac{4 \\cdot 3}{2} = 2$。\n\n设这两个解析树为 $T_L$ 和 $T_R$。\n1.  $T_L$ 是左结合树，对应于推导 $E \\Rightarrow E+E \\Rightarrow (E+E)+E \\Rightarrow (id+E)+E \\Rightarrow (id+id)+E \\Rightarrow (id+id)+id$。\n2.  $T_R$ 是右结合树，对应于推导 $E \\Rightarrow E+E \\Rightarrow E+(E+E) \\Rightarrow id+(E+E) \\Rightarrow id+(id+E) \\Rightarrow id+(id+id)$。\n\n字符串 $s$ 的所有解析树的集合是 $\\mathcal{T}_s = \\{T_L, T_R\\}$。我们现在分析基本变换对这些树的影响。\n\n考虑树 $T_L$。它有两个加法节点。\n- 根节点对应于 $(E+E)+E$ 中的顶层产生式。它的左非终结符子节点是 $id+id$ 的子树，右非终结符子节点是 $id$ 的子树。让我们在这个根节点应用基本变换（交换）。新树的左子树将是 $id$ 的子树，右子树将是 $id+id$ 的子树。这个结构对应于解析 $id+(id+id)$，这正是树 $T_R$。因此，$T_L \\leftrightarrow_e T_R$。\n- 另一个加法节点在 $T_L$ 的左子树中，对应于 $id+id$ 部分。它的子节点是两个相同的子树，每个子树都代表一个单独的 $id$。交换这两个相同的子树会得到相同的树。所以，这个变换将 $T_L$ 映射到其自身。\n\n由于 $T_L$ 可以通过一次基本变换转换成 $T_R$，它们是相关的，即 $T_L \\sim T_R$。根据等价关系的性质，它们必须属于同一个等价类。\n\n需要划分的解析树集合是 $\\mathcal{T}_s = \\{T_L, T_R\\}$。由于 $T_L \\sim T_R$，整个集合构成一个单一的等价类。\n$\\mathcal{T}_s$ 到等价类的划分为 $\\{\\{T_L, T_R\\}\\}$。\n\n因此，对于字符串 $id + id + id$，在关系 $\\sim$ 下只有一个解析树等价类。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}