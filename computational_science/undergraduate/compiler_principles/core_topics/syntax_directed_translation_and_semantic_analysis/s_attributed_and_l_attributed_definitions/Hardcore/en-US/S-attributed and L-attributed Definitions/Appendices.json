{
    "hands_on_practices": [
        {
            "introduction": "Let's begin with a foundational problem that reveals the limitations of S-attributed definitions and the necessity of L-attributes. We will design an attribute grammar to find the character positions of commas in a simple list. This exercise  demonstrates how inherited attributes can carry contextual information, like a starting position, down the parse tree, enabling calculations that are impossible with synthesized attributes alone.",
            "id": "3668936",
            "problem": "An Attribute Grammar is a context-free grammar augmented with attributes and semantic rules. Synthesized-attributed (S-attributed) definitions allow only synthesized attributes, computed from attributes of children and combined upward. Left-to-right-attributed (L-attributed) definitions permit inherited attributes whose values depend on attributes of a node’s parent and its left siblings, supporting a single left-to-right evaluation over a parse tree consistent with a left-to-right reading of the input.\n\nConsider the left-recursive list grammar $L \\to L, \\text{id} \\mid \\text{id}$, where $\\text{id}$ is a terminal corresponding to an identifier token. Suppose the input string is the comma-separated list `alphaX,b,cc,ddd,eeeee,f,gg` with no spaces and using $1$-based character positions in the input stream. Let $|\\text{id}_k|$ denote the number of characters in the $k$-th identifier’s lexeme as it appears in the input; for this input, the lexeme lengths are $|\\text{alphaX}|=6$, $|\\text{b}|=1$, $|\\text{cc}|=2$, $|\\text{ddd}|=3$, $|\\text{eeeee}|=5$, $|\\text{f}|=1$, and $|\\text{gg}|=2$.\n\nStarting from the foundational definitions above, design an L-attributed inherited index for the nonterminal $L$ to compute, at each application of the production $L \\to L, \\text{id}$, the character position of the comma that separates the prefix list and the next identifier. Then, using that L-attributed scheme, evaluate on the given input and compute the positions (in $1$-based indices) of all commas in the input. Express your final result as a row vector of the comma positions. No rounding is required. Additionally, explain in your reasoning how the left recursion in $L \\to L, \\text{id}$ affects the feasibility of S-attributed versus L-attributed definitions for this computation and the evaluation order of attributes, but ensure that your final numeric answer contains only the positions.",
            "solution": "The problem requires the design and application of an L-attributed definition to compute the positions of commas in a string generated by a left-recursive grammar.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Grammar**: $L \\to L, \\text{id} \\mid \\text{id}$\n- **Definitions**: Synthesized-attributed (S-attributed) and Left-to-right-attributed (L-attributed) definitions.\n- **Input String**: `alphaX,b,cc,ddd,eeeee,f,gg`\n- **Indexing**: $1$-based character positions.\n- **Lexeme Lengths**: $|\\text{id}_1|=|\\text{alphaX}|=6$, $|\\text{id}_2|=|\\text{b}|=1$, $|\\text{id}_3|=|\\text{cc}|=2$, $|\\text{id}_4|=|\\text{ddd}|=3$, $|\\text{id}_5|=|\\text{eeeee}|=5$, $|\\text{id}_6|=|\\text{f}|=1$, and $|\\text{id}_7|=|\\text{gg}|=2$.\n- **Task**:\n    1. Design an L-attributed inherited index for nonterminal $L$ to compute the comma's character position in the production $L \\to L, \\text{id}$.\n    2. Evaluate this scheme on the given input to find all comma positions.\n    3. Express the result as a row vector.\n    4. Explain the effect of left recursion on the choice between S-attributed and L-attributed definitions.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the formal theory of compilers and attribute grammars. It is well-posed, providing a specific grammar, input, and a clear computational objective. The language used is objective and unambiguous. All necessary data (lexeme lengths, indexing scheme) are provided, making the problem self-contained and consistent. The task is a standard exercise in compiler principles and does not violate any scientific laws, contain factual errors, or rely on subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A complete solution will be provided.\n\n### Solution Derivation\n\nThe core of the problem is to determine the absolute character position of each comma in the input string. The position of a given comma depends on the total length of the substring that precedes it. This preceding substring is composed of identifiers and other commas. To calculate this, a node in the parse tree needs information about its context—specifically, its starting position in the overall input stream. This information must flow from the parent node to the child node, which is the defining characteristic of an inherited attribute.\n\n#### S-Attributed vs. L-Attributed Definitions for This Problem\n\nA purely S-attributed definition allows only synthesized attributes, which are computed from the attributes of a node's children. A synthesized attribute passes information up the parse tree. For this problem, we could easily define a synthesized attribute, say $L.len$, to compute the length of the string derived from a nonterminal $L$. For the production $L_1 \\to L_2, \\text{id}$, the rule would be $L_1.len := L_2.len + 1 + |\\text{id}|$. However, this length information alone is insufficient to determine a comma's absolute position. The comma's position in the production $L_1 \\to L_2, \\text{id}$ is not simply $L_2.len + 1$. It is the starting position of the substring for $L_1$ plus the length of the substring for $L_2$. The starting position is contextual information that is not available within the production's right-hand side; it must be inherited from the parent of $L_1$. Since an inherited attribute is required, a purely S-attributed definition is not feasible.\n\nAn L-attributed definition allows both synthesized attributes and inherited attributes, with the constraint that an inherited attribute for a symbol $X_j$ in a production $A \\to X_1 \\dots X_n$ can only depend on attributes of its left siblings $X_1, \\dots, X_{j-1}$ and the inherited attributes of the parent $A$. This is sufficient for our task.\n\nThe left recursion in the grammar $L \\to L, \\text{id}$ creates a left-associative parse tree that grows downwards and to the left. For an L-attributed scheme, evaluation can proceed in a single depth-first, left-to-right traversal. For a production $L_1 \\to L_2, \\text{id}$, the evaluation process passes an inherited attribute down to $L_2$. It then recursively evaluates the subtree for $L_2$ to compute its synthesized attributes. Upon returning, these synthesized attributes of $L_2$ (a left sibling) are available to compute attributes for the symbols to its right (the comma and $\\text{id}$). This makes L-attributed definitions compatible with the structure of the left-recursive parse tree.\n\n#### L-Attributed Scheme Design\n\nWe define an attribute grammar to solve the problem. Let us augment the grammar with a start symbol $S$ for clarity: $S \\to L$.\n\n**Attributes:**\n- For the nonterminal $L$:\n    - $L.pos_{in}$: An inherited attribute representing the $1$-based starting character position of the substring derived from this instance of $L$.\n    - $L.len$: A synthesized attribute representing the total character length of the substring derived from this instance of $L$.\n- For the terminal $\\text{id}$:\n    - $|\\text{id}|$: A synthesized attribute provided by the lexical analyzer, representing the length of the identifier's lexeme.\n\n**Semantic Rules:**\n\n1.  **Production $S \\to L$**:\n    - $L.pos_{in} := 1$\n    This rule initializes the process, setting the starting position of the entire list to $1$.\n\n2.  **Production $L \\to \\text{id}$**:\n    - $L.len := |\\textid|$\n    The base case. The length of the list is simply the length of the single identifier.\n\n3.  **Production $L_1 \\to L_2, \\text{id}$**:\n    - $L_2.pos_{in} := L_1.pos_{in}$\n    The prefix list $L_2$ starts at the same position as the full list $L_1$. This rule passes the starting position down the left spine of the parse tree.\n    - $L_1.len := L_2.len + 1 + |\\text{id}|$\n    The total length of the list $L_1$ is the length of the sub-list $L_2$, plus $1$ for the comma, plus the length of the new identifier.\n    - `comma_pos` := $L_2.pos_{in} + L_2.len$\n    This is an action, not an attribute. The comma's position is found by taking the starting position of the sub-list $L_2$ and adding its length. The character immediately following the substring for $L_2$ is the comma.\n\nThis set of rules constitutes a valid L-attributed definition. The inherited attribute $L_2.pos_{in}$ depends only on the inherited attribute of its parent $L_1$. The calculation of `comma_pos` depends on the inherited attribute $L_2.pos_{in}$ and the synthesized attribute $L_2.len$. During a depth-first traversal, $L.pos_{in}$ is passed down. After the subtree for $L_2$ is fully evaluated, its synthesized attribute $L_2.len$ becomes available, allowing the computation of the comma's position.\n\n#### Evaluation on the Given Input\n\nThe input string is $\\text{alphaX,b,cc,ddd,eeeee,f,gg}$. There are $7$ identifiers, so there will be $6$ applications of the recursive production $L \\to L, \\text{id}$ and thus $6$ commas. Let $L_k$ denote the nonterminal representing the list of the first $k$ identifiers. The left-associative parse will proceed as follows, with evaluation unwinding from the base case.\n\n- **Base Case**: $L_1 \\to \\text{id}_1$ ($\\text{id}_1 = \\text{alphaX}$)\n    From the parent production $L_2 \\to L_1, \\text{id}_2$, the rule $L_1.pos_{in} := L_2.pos_{in}$ applies. Tracing this all the way from the root, $L_1.pos_{in}$ is initialized to $1$.\n    - $L_1.pos_{in} = 1$\n    - $L_1.len := |\\text{id}_1| = 6$\n\n- **Step 1**: Production $L_2 \\to L_1, \\text{id}_2$ ($\\text{id}_2 = \\text{b}$)\n    The inherited attribute $L_2.pos_{in}$ is $1$. The rule $L_1.pos_{in} := L_2.pos_{in}$ gives $L_1.pos_{in} = 1$. From the base case, we have $L_1.len = 6$.\n    - `comma_pos`$_1 := L_1.pos_{in} + L_1.len = 1 + 6 = 7$.\n    - $L_2.len := L_1.len + 1 + |\\text{id}_2| = 6 + 1 + 1 = 8$.\n\n- **Step 2**: Production $L_3 \\to L_2, \\text{id}_3$ ($\\text{id}_3 = \\text{cc}$)\n    The inherited attribute $L_3.pos_{in}$ is $1$, so $L_2.pos_{in}$ is also $1$. From Step 1, we have $L_2.len = 8$.\n    - `comma_pos`$_2 := L_2.pos_{in} + L_2.len = 1 + 8 = 9$.\n    - $L_3.len := L_2.len + 1 + |\\text{id}_3| = 8 + 1 + 2 = 11$.\n\n- **Step 3**: Production $L_4 \\to L_3, \\text{id}_4$ ($\\text{id}_4 = \\text{ddd}$)\n    The inherited attribute $L_4.pos_{in}$ is $1$, so $L_3.pos_{in}$ is also $1$. From Step 2, we have $L_3.len = 11$.\n    - `comma_pos`$_3 := L_3.pos_{in} + L_3.len = 1 + 11 = 12$.\n    - $L_4.len := L_3.len + 1 + |\\text{id}_4| = 11 + 1 + 3 = 15$.\n\n- **Step 4**: Production $L_5 \\to L_4, \\text{id}_5$ ($\\text{id}_5 = \\text{eeeee}$)\n    The inherited attribute $L_5.pos_{in}$ is $1$, so $L_4.pos_{in}$ is also $1$. From Step 3, we have $L_4.len = 15$.\n    - `comma_pos`$_4 := L_4.pos_{in} + L_4.len = 1 + 15 = 16$.\n    - $L_5.len := L_4.len + 1 + |\\text{id}_5| = 15 + 1 + 5 = 21$.\n\n- **Step 5**: Production $L_6 \\to L_5, \\text{id}_6$ ($\\text{id}_6 = \\text{f}$)\n    The inherited attribute $L_6.pos_{in}$ is $1$, so $L_5.pos_{in}$ is also $1$. From Step 4, we have $L_5.len = 21$.\n    - `comma_pos`$_5 := L_5.pos_{in} + L_5.len = 1 + 21 = 22$.\n    - $L_6.len := L_5.len + 1 + |\\text{id}_6| = 21 + 1 + 1 = 23$.\n\n- **Step 6**: Production $L_7 \\to L_6, \\text{id}_7$ ($\\text{id}_7 = \\text{gg}$)\n    The inherited attribute $L_7.pos_{in}$ is $1$, so $L_6.pos_{in}$ is also $1$. From Step 5, we have $L_6.len = 23$.\n    - `comma_pos`$_6 := L_6.pos_{in} + L_6.len = 1 + 23 = 24$.\n    - $L_7.len := L_6.len + 1 + |\\text{id}_7| = 23 + 1 + 2 = 26$.\n\nThe sequence of computed comma positions is $7$, $9$, $12$, $16$, $22$, and $24$. This result can be verified by manual inspection of the input string:\n`alphaX,b,cc,ddd,eeeee,f,gg`\n123456^7 8^9 10 11^12 13 14 15^16 17 18 19 20 21^22 23^24 25 26\n\nThe positions match the calculation. The final answer is the row vector of these positions.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n7 & 9 & 12 & 16 & 22 & 24\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Building on the concept of passing contextual information, we now apply L-attributed definitions to a classic compiler task: type checking. In this practice problem , we will use an inherited attribute to pass down an *expected type* to an array index expression. This demonstrates how a compiler can enforce rules like 'array indices must be integers' in a systematic, left-to-right pass.",
            "id": "3668987",
            "problem": "Consider the context-free grammar $E \\to \\text{id}\\,[E] \\mid \\text{id}$, where each occurrence of $\\text{id}$ in the input is a specific identifier whose declared type is obtained from a symbol table. Use the framework of Syntax-Directed Definition (SDD) and L-attributed definitions: an SDD is L-attributed if every inherited attribute of a node can be computed from attributes of the node’s parent and attributes of siblings to its left, ensuring a single left-to-right pass along each production’s right-hand side suffices to evaluate inherited attributes.\n\nYou are to design attributes that check the type of the array index using a single inherited attribute $E.\\text{expect}$, which when $E$ serves as an index must be set to $\\text{int}$. The attributes are:\n- An inherited attribute $E.\\text{expect}$, ranging over $\\{\\text{int}\\}$ or the distinguished value $\\bot$ meaning “no constraint.”\n- A synthesized attribute $E.\\text{type}$, ranging over $\\{\\text{int}, \\text{float}, \\text{array}(\\text{int}), \\text{array}(\\text{float}), \\text{err}\\}$, where $\\text{err}$ denotes a type error propagated for convenience.\n- A synthesized attribute $E.\\text{errors}$, a nonnegative integer counting type violations.\n\nThe intended attribute rules, to be justified as L-attributed, are:\n\nFor the production $E \\to \\text{id}$:\n- $E.\\text{type} := \\text{decl}(\\text{id})$,\n- $E.\\text{errors} := 0$,\n- If $E.\\text{expect} = \\text{int}$ and $E.\\text{type} \\neq \\text{int}$, then a violation is recorded at the use site that required the expectation (see below); this rule does not record it here.\n\nFor the production $E \\to \\text{id}\\,[E_1]$:\n- Before analyzing $E_1$, set $E_1.\\text{expect} := \\text{int}$.\n- After $E_1$ is analyzed, define two local checks:\n  - $\\text{errNonArray} := 1$ if $\\text{decl}(\\text{id})$ is not of the form $\\text{array}(\\tau)$ for some $\\tau \\in \\{\\text{int}, \\text{float}\\}$; otherwise $\\text{errNonArray} := 0$.\n  - $\\text{errBadIndex} := 1$ if $E_1.\\text{type} \\neq \\text{int}$; otherwise $\\text{errBadIndex} := 0$.\n- Set $E.\\text{type} := \\tau$ if $\\text{decl}(\\text{id}) = \\text{array}(\\tau)$ for some $\\tau \\in \\{\\text{int}, \\text{float}\\}$; otherwise $E.\\text{type} := \\text{err}$.\n- Set $E.\\text{errors} := E_1.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex}$.\n\nThese rules check two independent constraints whenever the production $E \\to \\text{id}\\,[E_1]$ is used: the left $\\text{id}$ must be an array, and the index expression to its right must have type $\\text{int}$. The inherited attribute $E_1.\\text{expect}$ enforces that expectation in a left-to-right fashion and ensures the design is L-attributed.\n\nNow consider the input string $A\\,[\\,B\\,[\\,C\\,[\\,D\\,]\\,]\\,]$, which is in the language of the grammar and whose $\\text{id}$ lexemes and declared types are given by the symbol table\n- $\\text{decl}(A) = \\text{array}(\\text{float})$,\n- $\\text{decl}(B) = \\text{array}(\\text{int})$,\n- $\\text{decl}(C) = \\text{float}$,\n- $\\text{decl}(D) = \\text{array}(\\text{float})$.\n\nAssume the outermost $E$ (the entire input) starts with $E.\\text{expect} := \\bot$. Using only the attribute scheme and rules above, evaluate all attributes on the unique parse tree induced by the grammar and compute the total number of type violations $E.\\text{errors}$ at the root of the tree.\n\nGive your final answer as a single integer. No rounding is needed, and no units apply.",
            "solution": "The user wants me to solve the problem. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- **Grammar**: $E \\to \\text{id}\\,[E] \\mid \\text{id}$\n- **Symbol Table**:\n  - $\\text{decl}(A) = \\text{array}(\\text{float})$\n  - $\\text{decl}(B) = \\text{array}(\\text{int})$\n  - $\\text{decl}(C) = \\text{float}$\n  - $\\text{decl}(D) = \\text{array}(\\text{float})$\n- **Input String**: $A\\,[\\,B\\,[\\,C\\,[\\,D\\,]\\,]\\,]$\n- **Attributes**:\n  - Inherited: $E.\\text{expect} \\in \\{\\text{int}, \\bot\\}$\n  - Synthesized: $E.\\text{type} \\in \\{\\text{int}, \\text{float}, \\text{array}(\\text{int}), \\text{array}(\\text{float}), \\text{err}\\}$\n  - Synthesized: $E.\\text{errors}$ (nonnegative integer)\n- **Initial Condition**: For the root of the parse tree, $E.\\text{expect} := \\bot$.\n- **Attribute Rules for $E \\to \\text{id}$**:\n  - $E.\\text{type} := \\text{decl}(\\text{id})$\n  - $E.\\text{errors} := 0$\n  - A conditional check on $E.\\text{expect}$ is noted, but the error is recorded by the parent production.\n- **Attribute Rules for $E \\to \\text{id}\\,[E_1]$**:\n  1. $E_1.\\text{expect} := \\text{int}$\n  2. $\\text{errNonArray} := 1$ if $\\text{decl}(\\text{id})$ is not of the form $\\text{array}(\\tau)$; otherwise $\\text{errNonArray} := 0$.\n  3. $\\text{errBadIndex} := 1$ if $E_1.\\text{type} \\neq \\text{int}$; otherwise $\\text{errBadIndex} := 0$.\n  4. $E.\\text{type} := \\tau$ if $\\text{decl}(\\text{id}) = \\text{array}(\\tau)$; otherwise $E.\\text{type} := \\text{err}$.\n  5. $E.\\text{errors} := E_1.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is grounded in the well-established principles of compiler design, specifically syntax-directed translation, attribute grammars, and type checking. The concepts of L-attributed definitions, inherited attributes, and synthesized attributes are standard in this field.\n- **Well-Posed**: The problem provides a context-free grammar, a specific input string, a complete symbol table, and a full set of attribute evaluation rules. The task is to compute a specific value (total errors) by applying these rules. The grammar is unambiguous for the given input, leading to a unique parse tree. The rules are deterministic. Therefore, a unique and meaningful solution exists.\n- **Objective**: The problem is stated using formal, precise language common to computer science and compiler theory. It is free of ambiguity and subjective claims.\n- **Completeness and Consistency**: All necessary information is provided. The rules are internally consistent and do not contradict each other. The framework is L-attributed as claimed, since the only inherited attribute ($E_1.\\text{expect}$) is computed from the parent node and does not depend on siblings to its right.\n\n### Step 3: Verdict and Action\nThe problem is valid. A detailed solution will be provided.\n\nThe problem requires the evaluation of attributes on the parse tree for the input string $A\\,[\\,B\\,[\\,C\\,[\\,D\\,]\\,]\\,]$. The evaluation follows the principles of an L-attributed syntax-directed definition, which can be performed during a depth-first traversal of the parse tree.\n\nFirst, we construct the parse tree for the input string. Let's label the non-terminal nodes for clarity:\n- $E_0 \\to \\text{id}_A\\,[\\,E_1\\,]$ (root of the tree)\n- $E_1 \\to \\text{id}_B\\,[\\,E_2\\,]$\n- $E_2 \\to \\text{id}_C\\,[\\,E_3\\,]$\n- $E_3 \\to \\text{id}_D$\n\nThe attribute evaluation proceeds via a depth-first traversal. Inherited attributes are passed down the tree, and synthesized attributes are computed on the way back up.\n\n**Step 1: Traversal to the leaf node $E_3$**\n- The traversal starts at the root, $E_0$. The initial condition is $E_0.\\text{expect} := \\bot$.\n- At node $E_0$ (production $E_0 \\to \\text{id}_A\\,[\\,E_1\\,]$), the rule $E_1.\\text{expect} := \\text{int}$ is applied. We descend to $E_1$.\n- At node $E_1$ (production $E_1 \\to \\text{id}_B\\,[\\,E_2\\,]$), $E_1.\\text{expect}$ is $\\text{int}$. The rule $E_2.\\text{expect} := \\text{int}$ is applied. We descend to $E_2$.\n- At node $E_2$ (production $E_2 \\to \\text{id}_C\\,[\\,E_3\\,]$), $E_2.\\text{expect}$ is $\\text{int}$. The rule $E_3.\\text{expect} := \\text{int}$ is applied. We descend to $E_3$.\n\n**Step 2: Attribute evaluation for node $E_3$ (innermost expression `D`)**\n- Node $E_3$ corresponds to the production $E_3 \\to \\text{id}_D$.\n- The inherited attribute is $E_3.\\text{expect} = \\text{int}$.\n- We apply the rules for $E \\to \\text{id}$:\n  - $E_3.\\text{type} := \\text{decl}(\\text{id}_D) = \\text{array}(\\text{float})$.\n  - $E_3.\\text{errors} := 0$. The check for the expected type is handled by the parent node.\n- The synthesized attributes for $E_3$ are: $E_3.\\text{type} = \\text{array}(\\text{float})$ and $E_3.\\text{errors} = 0$.\n\n**Step 3: Attribute evaluation for node $E_2$ (expression `C[D]`)**\n- Node $E_2$ corresponds to the production $E_2 \\to \\text{id}_C\\,[\\,E_3\\,]$. We have the synthesized attributes of its child $E_3$.\n- We apply the rules for $E \\to \\text{id}\\,[E_1]$ (with $E_2$ as $E$ and $E_3$ as $E_1$):\n  - Check $\\text{errNonArray}$: $\\text{decl}(\\text{id}_C) = \\text{float}$. This is not of the form $\\text{array}(\\tau)$. Therefore, $\\text{errNonArray} := 1$.\n  - Check $\\text{errBadIndex}$: $E_3.\\text{type} = \\text{array}(\\text{float})$, which is not equal to $\\text{int}$. Therefore, $\\text{errBadIndex} := 1$.\n  - Compute $E_2.\\text{type}$: Since $\\text{decl}(\\text{id}_C)$ is not an array, $E_2.\\text{type} := \\text{err}$.\n  - Compute $E_2.\\text{errors}$: $E_2.\\text{errors} := E_3.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex} = 0 + 1 + 1 = 2$.\n- The synthesized attributes for $E_2$ are: $E_2.\\text{type} = \\text{err}$ and $E_2.\\text{errors} = 2$.\n\n**Step 4: Attribute evaluation for node $E_1$ (expression `B[C[D]]`)**\n- Node $E_1$ corresponds to the production $E_1 \\to \\text{id}_B\\,[\\,E_2\\,]$. We have the synthesized attributes of its child $E_2$.\n- We apply the rules for $E \\to \\text{id}\\,[E_1]$ (with $E_1$ as $E$ and $E_2$ as $E_1$):\n  - Check $\\text{errNonArray}$: $\\text{decl}(\\text{id}_B) = \\text{array}(\\text{int})$. This is of the form $\\text{array}(\\tau)$ with $\\tau = \\text{int}$. Therefore, $\\text{errNonArray} := 0$.\n  - Check $\\text{errBadIndex}$: $E_2.\\text{type} = \\text{err}$, which is not equal to $\\text{int}$. Therefore, $\\text{errBadIndex} := 1$.\n  - Compute $E_1.\\text{type}$: Since $\\text{decl}(\\text{id}_B) = \\text{array}(\\text{int})$, we have $\\tau = \\text{int}$. Thus, $E_1.\\text{type} := \\text{int}$.\n  - Compute $E_1.\\text{errors}$: $E_1.\\text{errors} := E_2.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex} = 2 + 0 + 1 = 3$.\n- The synthesized attributes for $E_1$ are: $E_1.\\text{type} = \\text{int}$ and $E_1.\\text{errors} = 3$.\n\n**Step 5: Attribute evaluation for node $E_0$ (the root expression `A[B[C[D]]`)**\n- Node $E_0$ corresponds to the production $E_0 \\to \\text{id}_A\\,[\\,E_1\\,]$. We have the synthesized attributes of its child $E_1$.\n- We apply the rules for $E \\to \\text{id}\\,[E_1]$ (with $E_0$ as $E$ and $E_1$ as $E_1$):\n  - Check $\\text{errNonArray}$: $\\text{decl}(\\text{id}_A) = \\text{array}(\\text{float})$. This is of the form $\\text{array}(\\tau)$ with $\\tau = \\text{float}$. Therefore, $\\text{errNonArray} := 0$.\n  - Check $\\text{errBadIndex}$: $E_1.\\text{type} = \\text{int}$. This is equal to $\\text{int}$. Therefore, $\\text{errBadIndex} := 0$.\n  - Compute $E_0.\\text{type}$: Since $\\text{decl}(\\text{id}_A) = \\text{array}(\\text{float})$, we have $\\tau = \\text{float}$. Thus, $E_0.\\text{type} := \\text{float}$.\n  - Compute $E_0.\\text{errors}$: $E_0.\\text{errors} := E_1.\\text{errors} + \\text{errNonArray} + \\text{errBadIndex} = 3 + 0 + 0 = 3$.\n- The final synthesized attributes for the root node $E_0$ are: $E_0.\\text{type} = \\text{float}$ and $E_0.\\text{errors} = 3$.\n\nThe total number of type violations is the value of the $E.\\text{errors}$ attribute at the root of the parse tree, which is $3$. The errors detected are:\n$1$. At $C[D]$, $C$ is not an array ($\\text{errNonArray}=1$).\n$2$. At $C[D]$, the index expression $D$ does not have type $\\text{int}$ ($\\text{errBadIndex}=1$).\n$3$. At $B[C[D]]$, the index expression $C[D]$ does not have type $\\text{int}$ ($\\text{errBadIndex}=1$).\n\nTotal errors = $0$ (from $E_3$) $+ 2$ (from $E_2$) $+ 1$ (added at $E_1$) $+ 0$ (added at $E_0$) = $3$. Note that the errors are accumulated up the tree. The value at the root is the total sum.\n$E_2.\\text{errors} = E_3.\\text{errors} + 2 = 0+2=2$.\n$E_1.\\text{errors} = E_2.\\text{errors} + 1 = 2+1=3$.\n$E_0.\\text{errors} = E_1.\\text{errors} + 0 = 3+0=3$.\n\nThe total number of type violations is $3$.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "Our final practice problem showcases the full power of L-attributed definitions for sophisticated static analysis. Here, we will tackle the crucial task of ensuring every variable is initialized before it is used . By 'threading' a set of initialized variables through the program structure using an inherited attribute, we can build a system that detects a common and critical source of bugs, illustrating a fundamental technique in data-flow analysis.",
            "id": "3669020",
            "problem": "You are given the statement-sequence grammar with expressions:\n- $S \\to \\mathrm{id} = E ; S \\mid \\mathrm{print}(E) ; S \\mid \\epsilon$\n- $E \\to E + T \\mid T$\n- $T \\to T \\times F \\mid F$\n- $F \\to \\mathrm{id} \\mid \\mathrm{num} \\mid (E)$\n\nStarting from the foundational definition of attribute grammars: an $L$-attributed definition is one in which, for every production, each inherited attribute of a symbol on the right-hand side depends only on inherited attributes of the head and on attributes of symbols to its left on the right-hand side. Use this principle to design an $L$-attributed definition that enforces the static semantic property “every variable use must be preceded by its initialization in the left-to-right statement order,” by threading an inherited set of initialized identifiers down the parse tree and synthesizing an integer count of uninitialized uses.\n\nConstraints for your design:\n- Introduce an inherited attribute $\\,\\mathrm{InSet}\\,$ on $S$, $E$, $T$, and $F$ that represents the set of identifiers known to be initialized upon entry to the construct.\n- Introduce a synthesized attribute $\\,\\mathrm{OutSet}\\,$ on $S$, $E$, $T$, and $F$ that represents the set of identifiers known to be initialized upon exit from the construct.\n- Introduce a synthesized attribute $\\,\\mathrm{Err}\\,$ on $S$, $E$, $T$, and $F$ that represents the count of uninitialized identifier uses detected within the construct.\n- Ensure $\\,\\mathrm{InSet}\\,$ for any right-hand side symbol depends only on the head’s inherited attributes and left siblings’ attributes, so that your definition is $L$-attributed.\n\nAssume that, at the top-level start symbol, the initial set of initialized identifiers is empty, that is, $\\,\\mathrm{InSet}(S_{\\mathrm{start}}) = \\varnothing$.\n\nNow consider the following concrete statement sequence (it matches the grammar above):\n$\\;a = b + 1 \\ ; \\ \\mathrm{print}( \\, a + c \\, ) \\ ; \\ b = a + 2 \\ ; \\ \\mathrm{print}( \\, b + d \\, ) \\ ; \\ \\mathrm{print}( \\, ( e ) + ( f + 3 ) \\, ) \\ ; \\ g = 0 \\ ; \\ \\mathrm{print}( \\, g + a \\, ) \\ ;$\n\nUsing your $L$-attributed definition, evaluate the synthesized attribute $\\,\\mathrm{Err}\\,$ at the root of the parse tree for this sequence, that is, compute the total number of uninitialized identifier uses detected under these rules. Express your final answer as a single integer. No rounding is required and no units are involved.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of compiler theory, is well-posed, and is stated objectively. It presents a standard task in syntax-directed translation: designing and applying an attribute grammar to perform static analysis. All necessary components—the context-free grammar, the specific semantic constraints, the required attributes, and the initial conditions—are provided, and they are internally consistent. The problem is formalizable and requires a rigorous application of established computer science principles.\n\nWe will first construct the L-attributed definition as specified, defining the semantic rules for computing the attributes $\\mathrm{InSet}$, $\\mathrm{OutSet}$, and $\\mathrm{Err}$ for each production in the grammar. Then, we will apply these rules to the provided code sequence to determine the total count of uninitialized variable uses.\n\n### L-Attributed Definition Design\n\nThe grammar is given by:\n- $S \\to \\mathrm{id} = E ; S \\mid \\mathrm{print}(E) ; S \\mid \\epsilon$\n- $E \\to E + T \\mid T$\n- $T \\to T \\times F \\mid F$\n- $F \\to \\mathrm{id} \\mid \\mathrm{num} \\mid (E)$\n\nWe define the semantic rules for each production. Note that attribute assignments are denoted by `:=`.\n\n**1. Production: $S_0 \\to \\mathrm{id} = E ; S_1$**\nThis production models a variable assignment. The expression $E$ is evaluated in the context inherited by $S_0$. The statement sequence $S_1$ that follows is evaluated in a context where $\\mathrm{id}$ is now considered initialized.\n- $E.\\mathrm{InSet} := S_0.\\mathrm{InSet}$\n- $S_1.\\mathrm{InSet} := E.\\mathrm{OutSet} \\cup \\{\\mathrm{id.name}\\}$\n- $S_0.\\mathrm{Err} := E.\\mathrm{Err} + S_1.\\mathrm{Err}$\n- $S_0.\\mathrm{OutSet} := S_1.\\mathrm{OutSet}$\n\n**2. Production: $S_0 \\to \\mathrm{print}(E) ; S_1$**\nThis production prints the value of an expression. It does not initialize any variables.\n- $E.\\mathrm{InSet} := S_0.\\mathrm{InSet}$\n- $S_1.\\mathrm{InSet} := E.\\mathrm{OutSet}$\n- $S_0.\\mathrm{Err} := E.\\mathrm{Err} + S_1.\\mathrm{Err}$\n- $S_0.\\mathrm{OutSet} := S_1.\\mathrm{OutSet}$\n\n**3. Production: $S \\to \\epsilon$**\nThis is the termination of a statement sequence. It contributes no errors and passes its inherited set of initialized variables through as its output set.\n- $S.\\mathrm{Err} := 0$\n- $S.\\mathrm{OutSet} := S.\\mathrm{InSet}$\n\n**4. Production: $E_0 \\to E_1 + T$**\nThe operands are evaluated from left to right. The context for the right operand $T$ includes the context of the left operand $E_1$.\n- $E_1.\\mathrm{InSet} := E_0.\\mathrm{InSet}$\n- $T.\\mathrm{InSet} := E_1.\\mathrm{OutSet}$\n- $E_0.\\mathrm{Err} := E_1.\\mathrm{Err} + T.\\mathrm{Err}$\n- $E_0.\\mathrm{OutSet} := T.\\mathrm{OutSet}$\n\n**5. Production: $E \\to T$**\nThe attributes are passed directly through.\n- $T.\\mathrm{InSet} := E.\\mathrm{InSet}$\n- $E.\\mathrm{Err} := T.\\mathrm{Err}$\n- $E.\\mathrm{OutSet} := T.\\mathrm{OutSet}$\n\n**6. Production: $T_0 \\to T_1 \\times F$**\nSimilar to addition, operands are evaluated left-to-right.\n- $T_1.\\mathrm{InSet} := T_0.\\mathrm{InSet}$\n- $F.\\mathrm{InSet} := T_1.\\mathrm{OutSet}$\n- $T_0.\\mathrm{Err} := T_1.\\mathrm{Err} + F.\\mathrm{Err}$\n- $T_0.\\mathrm{OutSet} := F.\\mathrm{OutSet}$\n\n**7. Production: $T \\to F$**\nThe attributes are passed directly through.\n- $F.\\mathrm{InSet} := T.\\mathrm{InSet}$\n- $T.\\mathrm{Err} := F.\\mathrm{Err}$\n- $T.\\mathrm{OutSet} := F.\\mathrm{OutSet}$\n\n**8. Production: $F \\to \\mathrm{id}$**\nThis is a use of a variable. We check if the identifier's name is in the set of initialized variables.\n- $F.\\mathrm{Err} := \\begin{cases} 1 & \\text{if } \\mathrm{id.name} \\notin F.\\mathrm{InSet} \\\\ 0 & \\text{if } \\mathrm{id.name} \\in F.\\mathrm{InSet} \\end{cases}$\n- $F.\\mathrm{OutSet} := F.\\mathrm{InSet}$\n\n**9. Production: $F \\to \\mathrm{num}$**\nA numeric literal is always valid and does not involve variables.\n- $F.\\mathrm{Err} := 0$\n- $F.\\mathrm{OutSet} := F.\\mathrm{InSet}$\n\n**10. Production: $F \\to (E)$**\nParentheses only affect parsing order; attributes are passed through.\n- $E.\\mathrm{InSet} := F.\\mathrm{InSet}$\n- $F.\\mathrm{Err} := E.\\mathrm{Err}$\n- $F.\\mathrm{OutSet} := E.\\mathrm{OutSet}$\n\nAn important property of this definition for the given expression grammar ($E, T, F$) is that no expression non-terminal initializes a variable. Thus, for any production with $X, Y \\in \\{E, T, F\\}$, $Y.\\mathrm{OutSet} = Y.\\mathrm{InSet}$. This implies that for any expression non-terminal $X$, $X.\\mathrm{OutSet} = X.\\mathrm{InSet}$. This simplifies the propagation of the $\\mathrm{InSet}$ attribute. For example, in $S_0 \\to \\mathrm{print}(E); S_1$, the rule $S_1.\\mathrm{InSet} := E.\\mathrm{OutSet}$ simplifies to $S_1.\\mathrm{InSet} := E.\\mathrm{InSet}$, which in turn is $S_1.\\mathrm{InSet} := S_0.\\mathrm{InSet}$.\n\n### Evaluation of the Input Sequence\n\nWe trace the evaluation of the synthesized attribute $\\mathrm{Err}$ for the given sequence, starting with $\\mathrm{InSet} = \\varnothing$ and a total error count of $0$.\n\n**Initial State:**\n- $\\mathrm{InSet} = \\varnothing$\n- Total $\\mathrm{Err} = 0$\n\n**1. Statement: `a = b + 1 ;`**\n- The expression `b + 1` is evaluated with $\\mathrm{InSet} = \\varnothing$.\n- The use of identifier $b$ is checked: $b \\notin \\varnothing$. This is an error.\n- The use of number $1$ causes no error.\n- $\\mathrm{Err}$ for this statement: $1$.\n- New state for the next statement:\n  - $\\mathrm{InSet} := \\varnothing \\cup \\{a\\} = \\{a\\}$\n  - Total $\\mathrm{Err} := 0 + 1 = 1$\n\n**2. Statement: `print( a + c ) ;`**\n- The expression `a + c` is evaluated with $\\mathrm{InSet} = \\{a\\}$.\n- Use of $a$: $a \\in \\{a\\}$. No error.\n- Use of $c$: $c \\notin \\{a\\}$. This is an error.\n- $\\mathrm{Err}$ for this statement: $1$.\n- New state for the next statement:\n  - $\\mathrm{InSet}$ remains $\\{a\\}$.\n  - Total $\\mathrm{Err} := 1 + 1 = 2$\n\n**3. Statement: `b = a + 2 ;`**\n- The expression `a + 2` is evaluated with $\\mathrm{InSet} = \\{a\\}$.\n- Use of $a$: $a \\in \\{a\\}$. No error.\n- Use of number $2$: no error.\n- $\\mathrm{Err}$ for this statement: $0$.\n- New state for the next statement:\n  - $\\mathrm{InSet} := \\{a\\} \\cup \\{b\\} = \\{a, b\\}$\n  - Total $\\mathrm{Err} := 2 + 0 = 2$\n\n**4. Statement: `print( b + d ) ;`**\n- The expression `b + d` is evaluated with $\\mathrm{InSet} = \\{a, b\\}$.\n- Use of $b$: $b \\in \\{a, b\\}$. No error.\n- Use of $d$: $d \\notin \\{a, b\\}$. This is an error.\n- $\\mathrm{Err}$ for this statement: $1$.\n- New state for the next statement:\n  - $\\mathrm{InSet}$ remains $\\{a, b\\}$.\n  - Total $\\mathrm{Err} := 2 + 1 = 3$\n\n**5. Statement: `print( ( e ) + ( f + 3 ) ) ;`**\n- The expression `( e ) + ( f + 3 )` is evaluated with $\\mathrm{InSet} = \\{a, b\\}$.\n- In the sub-expression `( e )`, use of $e$: $e \\notin \\{a, b\\}$. This is an error.\n- In the sub-expression `( f + 3 )`, use of $f$: $f \\notin \\{a, b\\}$. This is an error.\n- $\\mathrm{Err}$ for this statement: $1 + 1 = 2$.\n- New state for the next statement:\n  - $\\mathrm{InSet}$ remains $\\{a, b\\}$.\n  - Total $\\mathrm{Err} := 3 + 2 = 5$\n\n**6. Statement: `g = 0 ;`**\n- The expression `0` is evaluated with $\\mathrm{InSet} = \\{a, b\\}$.\n- Use of number $0$: no error.\n- $\\mathrm{Err}$ for this statement: $0$.\n- New state for the next statement:\n  - $\\mathrm{InSet} := \\{a, b\\} \\cup \\{g\\} = \\{a, b, g\\}$\n  - Total $\\mathrm{Err} := 5 + 0 = 5$\n\n**7. Statement: `print( g + a ) ;`**\n- The expression `g + a` is evaluated with $\\mathrm{InSet} = \\{a, b, g\\}$.\n- Use of $g$: $g \\in \\{a, b, g\\}$. No error.\n- Use of $a$: $a \\in \\{a, b, g\\}$. No error.\n- $\\mathrm{Err}$ for this statement: $0$.\n- New state for the next statement:\n  - $\\mathrm{InSet}$ remains $\\{a, b, g\\}$.\n  - Total $\\mathrm{Err} := 5 + 0 = 5$\n\nThe sequence ends. The final synthesized error count at the root of the parse tree is the sum of the errors from all statements.\n\nThe uninitialized uses detected are: $b$ (statement 1), $c$ (statement 2), $d$ (statement 4), $e$ (statement 5), and $f$ (statement 5).\n\nThe total number of uninitialized identifier uses is $5$.",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}