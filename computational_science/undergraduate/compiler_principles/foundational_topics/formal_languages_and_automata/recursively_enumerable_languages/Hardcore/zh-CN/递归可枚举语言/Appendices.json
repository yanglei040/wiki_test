{
    "hands_on_practices": [
        {
            "introduction": "我们经常通过组合简单的语言来构建复杂的语言。本练习探讨递归可枚举（RE）语言类在右商运算下是否封闭。 通过这个练习，你将实践可计算性理论中的一项基本技术：通过“多路交错执行”（dovetailing）现有图灵机的计算过程来构造一个新的图灵机识别器，从而加深对语言可识别性概念的理解。",
            "id": "1444605",
            "problem": "在形式语言理论中，我们研究不同语言类的性质。设 $\\Sigma$ 是一个有限字母表。一个语言 $L$ 是 $\\Sigma^*$ 的一个子集，其中 $\\Sigma^*$ 是 $\\Sigma$ 上所有有限字符串的集合。如果存在一台图灵机，对于每个输入字符串 $w \\in L$ 它都会停机并接受，而对于任何输入字符串 $w \\notin L$ 它要么停机并拒绝，要么永远运行，那么语言 $L$ 就被称为**可识别的**（或递归可枚举的）。\n\n一个重要的问题是，一个语言类在某些运算下是否是封闭的。考虑语言 $L_1$ 对语言 $L_2$ 的**右商**，记作 $L_1 / L_2$，其定义如下：\n$$L_1 / L_2 = \\{w \\in \\Sigma^* \\mid \\exists x \\in L_2 \\text{ 使得 } wx \\in L_1\\}$$\n这里，$wx$ 表示字符串 $w$ 和字符串 $x$ 的连接。\n\n下列哪个陈述准确地描述了可识别语言类在右商运算下的闭包性质？\n\nA. 可识别语言类在右商运算下是封闭的。\nB. 可识别语言类在右商运算下是不封闭的。\nC. 可识别语言类在右商运算下是封闭的，当且仅当语言 $L_2$ 是可判定的。\nD. 可识别语言类在右商运算下是封闭的，当且仅当语言 $L_1$ 是可判定的。\nE. 可识别语言类在右商运算下是封闭的，当且仅当 $L_1$ 和 $L_2$ 都是正则语言。",
            "solution": "我们回顾定义：一个语言 $L \\subseteq \\Sigma^{*}$ 是可识别的，如果存在一台图灵机（TM）$M$，它在输入 $w$ 时，如果 $w \\in L$ 则停机并接受，如果 $w \\notin L$ 则要么拒绝，要么永远运行。$L_{1}$ 对 $L_{2}$ 的右商是\n$$\nL_{1}/L_{2}=\\{\\,w \\in \\Sigma^{*} \\mid \\exists x \\in L_{2}\\ \\text{使得}\\ wx \\in L_{1}\\,\\}.\n$$\n我们必须确定可识别语言类在此运算下是否封闭。\n\n设 $L_{1},L_{2} \\subseteq \\Sigma^{*}$ 是可识别的。根据可识别性，存在图灵机 $M_{1}$ 和 $M_{2}$，使得 $M_{1}$ 识别 $L_{1}$ 且 $M_{2}$ 识别 $L_{2}$。定义 $L=L_{1}/L_{2}$。\n\n$L$ 的识别器的构造：\n1. 因为 $L_{2}$ 是可识别的，所以存在一个 $L_{2}$ 的枚举器 $E_{2}$，它通过对 $\\Sigma^{*}$ 中所有字符串上的 $M_{2}$ 进行交叉模拟来获得：枚举 $\\Sigma^{*}$ 中的所有字符串 $x$，并以交叉模拟的方式模拟 $M_{2}(x)$；每当 $M_{2}(x)$ 接受时，就输出 $x$。这将产生一个（可能带有重复的）无限序列 $x_{1},x_{2},\\dots$，该序列恰好列出了 $L_{2}$ 的所有成员。\n\n2. 对于输入 $w \\in \\Sigma^{*}$，我们通过在时间步 $t=1,2,3,\\dots$ 上进行两级交叉模拟来为 $L$ 构建一个识别器 $M$：\n   - 在阶段 $t$，读取（或生成）$E_{2}$ 到目前为止输出的前 $t$ 个字符串 $x_{1},\\dots,x_{t}$。\n   - 对于每个 $i \\in \\{1,\\dots,t\\}$，在输入 $w x_{i}$ 上模拟 $M_{1}$ 正好 $t$ 步（从先前阶段模拟中断的地方继续）。\n   - 如果在这些 $t$ 步内，任何一个模拟接受了，那么就停机并接受 $w$。\n\n正确性证明：\n- 可靠性：如果 $M$ 接受 $w$，那么在某个阶段 $t$，其中一个模拟 $M_{1}(w x_{i})$ 会接受，而 $x_{i}$ 是由 $E_{2}$ 枚举的一个元素，因此 $x_{i} \\in L_{2}$。所以 $w x_{i} \\in L_{1}$ 且 $w \\in L_{1}/L_{2}$。\n\n- 完备性：假设 $w \\in L_{1}/L_{2}$。那么存在 $x \\in L_{2}$ 使得 $w x \\in L_{1}$。因为 $x \\in L_{2}$，所以 $x$ 会在枚举 $E_{2}$ 中以某个有限索引 $j$ 作为 $x_{j}$ 出现。因为 $w x \\in L_{1}$，所以 $M_{1}(w x)$ 会在某个有限步数 $s$ 内接受。选择任何阶段 $t \\geq \\max\\{j,s\\}$。根据构造，在阶段 $t$ 我们会模拟 $M_{1}(w x_{j})$ 至少 $s$ 步，因此我们会检测到接受状态，并且 $M$ 会接受 $w$。\n\n- 对非成员的不接受性：如果 $w \\notin L_{1}/L_{2}$，那么对于每一个 $x \\in L_{2}$，都有 $w x \\notin L_{1}$，所以 $M_{1}(w x)$ 永远不会接受。因此，没有一个阶段会产生接受状态，并且 $M$ 会在输入 $w$ 上永远运行，这对于一个识别器处理不属于语言的成员是允许的。\n\n因此 $M$ 识别 $L=L_{1}/L_{2}$，这证明了只要 $L_{1}$ 和 $L_{2}$ 是可识别的，那么 $L_{1}/L_{2}$ 也是可识别的。因此，可识别语言类在右商运算下是封闭的。在这些选项中，这与陈述A完全对应，而陈述B、C、D和E都是错误的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在了解到RE语言在某些运算下是封闭的之后，一个自然的问题是：这种封闭性是否适用于所有基本的集合运算？这个问题研究了两个RE集的差集和补集的性质。 这个练习揭示了可计算性理论中一些微妙但至关重要的边界，通过分析反例，你将理解为何像集合差集这样的运算可能会产生非RE语言，并巩固关于递归集和RE集之间基本关系的定理。",
            "id": "1399643",
            "problem": "在可计算性理论中，我们根据能够处理集合的算法对集合进行分类。设全集为自然数集 $\\mathbb{N} = \\{0, 1, 2, ...\\}$。\n\n- 一个集合 $S \\subseteq \\mathbb{N}$ 被称为**递归集**（或可判定集），如果存在一个算法，它以任意数字 $n \\in \\mathbb{N}$ 为输入，在所有输入上都会停机，并且当 $n \\in S$ 时正确输出“是”，当 $n \\notin S$ 时正确输出“否”。\n- 一个集合 $S \\subseteq \\mathbb{N}$ 被称为**递归可枚举（RE）集**，如果存在一个算法，它对于任何输入 $n \\in S$ 都会停机并输出“是”，但如果 $n \\notin S$ 则可能永远运行。\n\n一个已知的事实是，每个递归集也是递归可枚举集，但存在不是递归集的递归可枚举集。\n\n设 $A$ 和 $B$ 是两个递归可枚举集，但 $A$ 和 $B$ 都不是递归集。考虑以下关于集合 $A^c = \\mathbb{N} \\setminus A$（$A$ 的补集）和 $A \\setminus B$（差集）的可计算性性质的陈述。\n\nI. 集合 $A^c$ 永远不可能是递归可枚举的。\nII. 集合 $A \\setminus B$ 必须是递归可枚举的。\nIII. 集合 $A \\setminus B$ 不可能是递归的。\n\n以上哪个（些）陈述必然为真？\n\nA. 仅 I\nB. 仅 II\nC. 仅 III\nD. I 和 II\nE. I 和 III\nF. 以上陈述均不必然为真。",
            "solution": "我们回顾一些标准事实。一个集合 $S \\subseteq \\mathbb{N}$ 是递归的，当且仅当 $S$ 和 $S^{c}$ 都是递归可枚举的。正向成立，因为如果 $S$ 是可判定的，那么 $S^{c}$ 也是可判定的，因此是递归可枚举的。反向成立，因为如果 $S$ 和 $S^{c}$ 都是递归可枚举的，那么对于输入 $n$，可以交叉执行这两个半判定过程，并在其中一个确认成员关系时立即接受；由于 $n$ 恰好属于 $S$ 或 $S^{c}$ 中的一个，这个过程会停机并判定 $n$ 是否属于 $S$。\n\n陈述 I：根据假设，$A$ 是递归可枚举的但不是递归的。利用上述等价性，如果 $A^{c}$ 是递归可枚举的，那么 $A$ 将是递归的，这与假设矛盾。因此，$A^{c}$ 不是递归可枚举的。所以 I 必然为真。\n\n陈述 II：我们通过构造特定的递归可枚举但非递归的集合 $A$ 和 $B$，使得 $A \\setminus B$ 不是递归可枚举的，来证明 $A \\setminus B$ 不必是递归可枚举的。固定一个标准的可计算配对函数 $\\langle \\cdot,\\cdot \\rangle \\colon \\mathbb{N}^{2} \\to \\mathbb{N}$。令 $K=\\{e \\in \\mathbb{N} : \\text{机器 } e \\text{ 在输入 } e \\text{ 上停机}\\}$ 为停机集，它是递归可枚举的但不是递归的，并令 $\\overline{K}=\\mathbb{N}\\setminus K$，它不是递归可枚举的。定义\n$$\nA=\\{\\langle e,0\\rangle : e \\in K\\}\\ \\cup\\ \\{\\langle e,1\\rangle : e \\in \\mathbb{N}\\},\n$$\n$$\nB=\\{\\langle e,1\\rangle : e \\in K\\}.\n$$\n那么 $A$ 是两个递归可枚举集的并集，因此是递归可枚举的；如果 $A$ 是递归的，那么判定 $\\langle e,0\\rangle \\in A$ 就等同于判定 $e \\in K$，这是不可能的，所以 $A$ 不是递归的。类似地，$B$ 是递归可枚举且非递归的，因为判定 $\\langle e,1\\rangle \\in B$ 就等同于判定 $e \\in K$。计算差集：\n$$\nA \\setminus B=\\{\\langle e,0\\rangle : e \\in K\\}\\ \\cup\\ \\{\\langle e,1\\rangle : e \\in \\overline{K}\\}.\n$$\n考虑可计算映射 $f(e)=\\langle e,1\\rangle$。对于每个 $e \\in \\mathbb{N}$，\n$$\ne \\in \\overline{K}\\ \\Longleftrightarrow\\ \\langle e,1\\rangle \\in A \\setminus B.\n$$\n因此，通过多一归约，有 $\\overline{K} \\leq_{m} A \\setminus B$。如果 $A \\setminus B$ 是递归可枚举的，那么 $\\overline{K}$ 也将是递归可枚举的，这是一个矛盾。因此 $A \\setminus B$ 不必是递归可枚举的，所以 II 是假的。\n\n陈述 III：我们通过一个简单的反例来表明 $A \\setminus B$ 可以是递归的。取 $A=B=K$。那么 $A$ 和 $B$ 都是递归可枚举且非递归的，并且\n$$\nA \\setminus B=K \\setminus K=\\varnothing,\n$$\n这是递归的。因此，$A \\setminus B$ 不必是非递归的，所以 III 是假的。\n\n综合以上分析，只有陈述 I 必然为真。正确选项是 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "软件开发中的一个关键挑战是识别可能永不终止的程序。这个问题将研究所有“在至少一个输入上会无限循环”的程序的集合所构成的语言。 这项实践将可计算性理论应用于一个实际问题，展示了自动化程序分析的内在局限性。你将学会使用归约证明——一种对计算问题进行难度分类的强大工具——通过将此问题与经典的停机问题联系起来，来证明其不可计算性。",
            "id": "3666183",
            "problem": "考虑语言 $L_{\\text{loop}} = \\{ \\langle p \\rangle \\mid \\exists x\\; p(x) \\text{ 不停机} \\}$，其中 $\\langle p \\rangle$ 表示由编译器前端生成的程序 $p$ 的标准编码，$x$ 的范围是编码后的输入。请使用以下基本依据：语言 $L$ 是递归可枚举的（RE）的定义，即存在一台图灵机，它对且仅对 $L$ 中的字符串停机并接受，等价地，存在一个枚举器，它列出且仅列出 $L$ 中的所有字符串；以及经典停机问题集合 $HALT = \\{ \\langle p, x \\rangle \\mid p(x) \\text{ 停机} \\}$ 的定义，以及已证实的结论 $\\overline{HALT} = \\{ \\langle p, x \\rangle \\mid p(x) \\text{ 不停机} \\}$ 不是递归可枚举的。假设有人提议证明 $L_{\\text{loop}}$ 是递归可枚举的，方法是构造一个枚举器，对于每个程序编码 $\\langle p \\rangle$，它对所有输入 $x$ 进行交叉模拟，并逐步模拟 $p(x)$，同时交错地搜索“非停机证据”，例如重复的格局或其他句法循环模式；当对某个 $x$ 找到此类证据时，枚举器输出 $\\langle p \\rangle$。下列哪个陈述正确地分析了这一提议和 $L_{\\text{loop}}$ 的 RE 状态？\n\nA. 不存在一个可计算的、有限的证书能够统一地证明任意图灵完备程序的非停机性，因此所提议的枚举器不能保证最终对 $L_{\\text{loop}}$ 的所有成员输出；此外，如果 $L_{\\text{loop}}$ 是递归可枚举的，那么 $\\overline{HALT}$ 将可以通过一个映射归约成为递归可枚举的，这与一个经过充分检验的结果相矛盾。\n\nB. 通过交叉模拟并等待格局重复，最终将检测到所有的发散（即不停机）；因此该枚举器有效，且 $L_{\\text{loop}}$ 是递归可枚举的。\n\nC. 通过在一个可靠且完备的非停机逻辑中枚举形式化证明，可以使该提议有效，该逻辑能为每个发散的程序证明其非停机性；因此 $L_{\\text{loop}}$ 是递归可枚举的。\n\nD. 如所述，该提议实际上枚举了补集 $\\overline{L_{\\text{loop}}}$，因为任何在所有输入上都停机的程序都会为每个输入产生一个有限的模拟轨迹，从而为全体停机性提供了有效证据。\n\nE. 该提议为一个受限的有限状态程序类正确地生成了一个枚举器，在此类程序中，格局重复是非停机性的完备证据，但它不能扩展到图灵完备程序；因此，它并未能证明 $L_{\\text{loop}}$ 在一般情况下是递归可枚举的。\n\n选择所有适用项。",
            "solution": "从定义开始。一个语言 $L$ 是递归可枚举的，如果存在一个图灵机 $M$，使得对于每个字符串 $w$，如果 $w \\in L$，则 $M$ 停机并接受 $w$，而如果 $w \\notin L$，则 $M$ 要么拒绝要么不停机；等价地，存在一个枚举器，它恰好打印出 $L$ 的所有字符串。停机问题集合 $HALT = \\{ \\langle p, x \\rangle \\mid p(x) \\text{ 停机} \\}$ 已知是递归可枚举的，而其补集 $\\overline{HALT} = \\{ \\langle p, x \\rangle \\mid p(x) \\text{ 不停机} \\}$ 不是递归可枚举的。\n\n我们分析所提议的策略。它试图将非停机性视为具有某种肯定的、可检测的证书的事物，例如重复的格局或句法循环。对于图灵完备模型，这通常是不可能的：一个计算可能通过不断增加其访问的纸带部分而发散，而从不重复一个完整的格局。更根本地说，如果存在一个系统的、可计算的过程，当程序 $p$ 在某个输入 $x$ 上使得 $p(x)$ 不停机时，该过程最终能产生一个可被枚举器识别的有限见证，那么 $L_{\\text{loop}}$ 的成员资格将是半可判定的。\n\n一个精确的论证使用从 $\\overline{HALT}$到 $L_{\\text{loop}}$ 的映射归约。给定任意实例 $\\langle p, x \\rangle$，构造一个程序 $q$，它忽略自己的输入并模拟 $p(x)$；形式上，定义 $q(y)$ 为运行 $p(x)$ 而不做其他任何事。那么：\n- 如果 $p(x)$ 停机，$q(y)$ 对每个 $y$ 都停机，因此不存在使 $q$ 发散的输入，从而 $\\langle q \\rangle \\notin L_{\\text{loop}}$。\n- 如果 $p(x)$ 不停机，$q(y)$ 对每个 $y$ 都不停机，因此存在使 $q$ 发散的输入，从而 $\\langle q \\rangle \\in L_{\\text{loop}}$。\n\n因此，$\\langle p, x \\rangle \\in \\overline{HALT}$ 当且仅当 $\\langle q \\rangle \\in L_{\\text{loop}}$。如果 $L_{\\text{loop}}$ 是递归可枚举的，那么通过将可计算的变换 $\\langle p, x \\rangle \\mapsto \\langle q \\rangle$ 与 $L_{\\text{loop}}$ 的枚举器组合起来，我们将得到一个针对 $\\overline{HALT}$ 的半判定过程，这与 $\\overline{HALT}$ 不是递归可枚举的既定事实相矛盾。因此 $L_{\\text{loop}}$ 不是递归可枚举的。\n\n现在评估各个选项：\n\nA. 该选项阐明了两点。首先，不存在一个通用的、可计算的、有限的非停机证书，能保证图灵机对所有发散的计算都能找到它，因为发散不是半可判定的。其次，它陈述了映射归约论证：从任意 $\\langle p, x \\rangle$ 构造一个忽略其输入并模拟 $p(x)$ 的程序 $q$，得到 $\\langle p, x \\rangle \\in \\overline{HALT}$ 当且仅当 $\\langle q \\rangle \\in L_{\\text{loop}}$。如果 $L_{\\text{loop}}$ 是递归可枚举的，那么 $\\overline{HALT}$ 也将是递归可枚举的，这与一个经过充分检验的结果相矛盾。这两部分都是正确的。结论：正确。\n\nB. 该选项声称格局重复足以检测所有的发散。对于图灵机，一个计算可以发散而从不重复一个完整的格局（例如，通过无限地写入新符号并向右移动）。循环检测是发散的不完备证据。因此，该枚举器会漏掉那些不重复而发散的程序，从而无法枚举 $L_{\\text{loop}}$ 的所有成员。此外，即使发生重复，也无法保证枚举器能在有界时间内为所有发散的运行检测到它。$L_{\\text{loop}}$ 是递归可枚举的这一结论是错误的。结论：不正确。\n\nC. 该选项假设存在一个针对任意图灵完备程序的非停机性的可靠且完备的证明系统，并提议枚举此类证明。如果这样一个系统存在并且是有效可枚举的，那么 $\\overline{HALT}$ 将是递归可枚举的，因为对于任何对 $\\langle p, x \\rangle$，人们可以枚举证明直到找到一个证明 $p(x)$ 发散的证明。这与 $\\overline{HALT}$ 的非递归可枚举性相矛盾。不存在针对任意程序的非停机性的可计算枚举的、完备的证明系统。结论：不正确。\n\nD. 该选项断言该提议通过累积全体停机性的证据来枚举 $\\overline{L_{\\text{loop}}}$。然而，“在所有输入上停机”是一个全称性质，并且通常不接受有限的、可计算的证书；观察到在许多输入上停机并不能证明在所有输入上停机。不存在一个有效的过程，能在给定 $\\langle p \\rangle$ 和有限的模拟后，确认其在 $\\overline{L_{\\text{loop}}}$ 中的成员资格。结论：不正确。\n\nE. 该选项区分了有限状态模型和图灵完备模型。对于有限状态程序，如确定性有限自动机，重复一个格局确实意味着非停机，并且循环检测可以是完备的证据，因此基于循环检测的枚举器对那个受限的类是可行的。然而，问题涉及图灵完备程序，其中这类证据是不完备的，并且上面的归约论证表明 $L_{\\text{loop}}$ 不是递归可枚举的。该选项的结论，即该提议并未能证明 $L_{\\text{loop}}$ 在一般情况下是递归可枚举的，是正确的。结论：正确。\n\n因此，正确的陈述是 A 和 E。",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}