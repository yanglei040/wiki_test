{
    "hands_on_practices": [
        {
            "introduction": "掌握了 $\\varepsilon$-闭包的定义后，我们首先通过一个基本练习来实践其在 NFA 模拟中的应用。这个练习将指导你如何追踪一个给定的 NFA 在处理输入字符串时，状态集如何因 $\\varepsilon$-转移而演化。通过这个过程，你将熟悉在每一步输入后计算 $\\varepsilon$-闭包的核心算法。",
            "id": "1388210",
            "problem": "一位计算机科学家正在设计一个基于非确定性有限自动机 (NFA) 的简单词法分析工具，用于检测二进制数据流中的特定模式。该 NFA 被形式化定义，包含以下组成部分：\n- 状态集 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 输入字母表 $\\Sigma = \\{0, 1\\}$。\n- 起始状态 $q_{start} = q_0$。\n- 接受状态集 $F = \\{q_3\\}$。\n\n转移函数 $\\delta: Q \\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，$\\varepsilon$ 表示空字符串，由以下规则表给出。注意，如果某个状态-输入对未被列出，其转移将导向空集 $\\emptyset$。\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\varepsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\n给定输入字符串 `101`，确定在处理完整个字符串后，该自动机可能处于的所有可能状态的集合。从以下选项中选择正确的集合。\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$",
            "solution": "对于一个带有 $\\varepsilon$-转移的 NFA，在每一步中，我们先计算当前状态集的 $\\varepsilon$-闭包，然后根据输入符号进行转移，最后再次计算 $\\varepsilon$-闭包。令 $\\text{E}(S)$ 表示集合 $S$ 的 $\\varepsilon$-闭包。未指定的转移导向空集。\n\n初始闭包：\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\n读入第一个符号 $1$ 后：\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\varepsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\n读入第二个符号 $0$ 后：\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\n读入第三个符号 $1$ 后：\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\varepsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\n因此，在处理完整个字符串 $101$ 后，可能的状态集合是 $\\{q_{0},q_{1},q_{2},q_{3}\\}$，这对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "理解了模拟的机理之后，下一个关键步骤是建立关于 $\\varepsilon$-转移影响的直观认识。这个练习展示了如何仅通过添加一条 $\\varepsilon$-转移，就能改变 NFA 所接受的语言，例如使其能够接受一个更短的前缀。这个思想实验有助于你从单纯的计算转向对自动机行为的深入理解。",
            "id": "3683714",
            "problem": "考虑一个基于字母表 $\\Sigma = \\{a, b\\}$ 的非确定性有限自动机 (NFA) $\\mathcal{N}_0$，其状态集为 $Q = \\{q_0, q_1, q_2, q_3\\}$，起始状态为 $q_0$，接受状态集为 $F = \\{q_3\\}$，转移函数 $\\delta$ 定义如下：\n- $\\delta(q_0, a) = \\{q_1\\}$，\n- $\\delta(q_1, b) = \\{q_2\\}$，\n- $\\delta(q_2, a) = \\{q_3\\}$，\n- 对于 $x \\in \\{a, b\\}$，所有其他的 $\\delta(q_i, x)$ 均为 $\\emptyset$，\n- $\\mathcal{N}_0$ 中没有 $\\varepsilon$-转移。\n\n通过在中间状态 $q_2$ 到接受状态 $q_3$ 之间增加一个 $\\varepsilon$-转移，即 $\\delta(q_2, \\varepsilon) = \\{q_3\\}$，同时保持所有其他部分不变，我们得到了一个修改后的 NFA $\\mathcal{N}_1$。直观上，这个改变可能导致 $\\mathcal{N}_1$ 接受某些字符串的前缀，而这些字符串在 $\\mathcal{N}_0$ 中原本需要用一个最终符号来扩展才能被接受。\n\n利用带有 $\\varepsilon$-转移的 NFA 的接受原理和 $\\varepsilon$-闭包的基本原理，确定下列哪些输入字符串被 $\\mathcal{N}_1$ 接受但不被 $\\mathcal{N}_0$ 接受。选择所有适用的选项。\n\nA. $ab$\n\nB. $aba$\n\nC. $a$\n\nD. $\\varepsilon$\n\nE. $b$",
            "solution": "问题的核心是比较两个 NFA 所接受的语言 $L(\\mathcal{N}_0)$ 和 $L(\\mathcal{N}_1)$。如果一个字符串 $w$ 满足 $w \\in L(\\mathcal{N}_1)$ 且 $w \\notin L(\\mathcal{N}_0)$，那么它就是一个解。\n\n**对 NFA $\\mathcal{N}_0$ 的分析**\n\n一个 NFA 接受字符串 $w$，如果存在一条从起始状态到某个接受状态的路径，其标签为 $w$ 的符号序列。\n在 $\\mathcal{N}_0$ 中，状态集为 $Q = \\{q_0, q_1, q_2, q_3\\}$，起始状态为 $q_0$，唯一的接受状态为 $q_3$。转移如下：\n$q_0 \\xrightarrow{a} q_1$\n$q_1 \\xrightarrow{b} q_2$\n$q_2 \\xrightarrow{a} q_3$\n\n要到达接受状态 $q_3$，必须从 $q_0$ 开始并遵循转移序列。从 $q_0$ 到 $q_3$ 的唯一路径是 $q_0 \\xrightarrow{a} q_1 \\xrightarrow{b} q_2 \\xrightarrow{a} q_3$。这条路径对应于输入字符串 $aba$。因此，$\\mathcal{N}_0$ 接受的语言是 $L(\\mathcal{N}_0) = \\{aba\\}$。\n\n我们来正式检查每个选项字符串对于 $\\mathcal{N}_0$ 的状态：\n-   对于字符串 $ab$：自动机遵循路径 $q_0 \\xrightarrow{a} q_1 \\xrightarrow{b} q_2$。到达的最终状态是 $q_2$。由于 $q_2 \\notin F$，字符串 $ab$ **不被** $\\mathcal{N}_0$ 接受。\n-   对于字符串 $aba$：自动机遵循路径 $q_0 \\xrightarrow{a} q_1 \\xrightarrow{b} q_2 \\xrightarrow{a} q_3$。最终状态是 $q_3$。由于 $q_3 \\in F$，字符串 $aba$ **被** $\\mathcal{N}_0$ 接受。\n-   对于字符串 $a$：自动机遵循路径 $q_0 \\xrightarrow{a} q_1$。最终状态是 $q_1 \\notin F$。字符串 $a$ **不被** $\\mathcal{N}_0$ 接受。\n-   对于字符串 $\\varepsilon$（空字符串）：起始状态是 $q_0$。由于 $q_0 \\notin F$，$\\varepsilon$ **不被** $\\mathcal{N}_0$ 接受。\n-   对于字符串 $b$：从 $q_0$ 没有关于输入 $b$ 的转移，即 $\\delta_0(q_0, b) = \\emptyset$。自动机在非接受配置下停止。字符串 $b$ **不被** $\\mathcal{N}_0$ 接受。\n\n**对 NFA $\\mathcal{N}_1$ 的分析**\n\nNFA $\\mathcal{N}_1$ 包含一个从 $q_2$到 $q_3$ 的 $\\varepsilon$-转移。在带有 $\\varepsilon$-转移的 NFA 中，接受性是使用 $\\varepsilon$-闭包的概念来确定的。一个状态 $q$ 的 $\\varepsilon$-闭包，记为 $E(q)$，是指从 $q$ 出发仅通过 $\\varepsilon$-转移（包括 $q$ 自身）所能到达的状态集合。\n\n让我们计算 $\\mathcal{N}_1$ 中各状态的 $\\varepsilon$-闭包：\n-   $E(q_0) = \\{q_0\\}$\n-   $E(q_1) = \\{q_1\\}$\n-   $E(q_2) = \\{q_2, q_3\\}$ (因为可以停留在 $q_2$ 或通过 $\\varepsilon$ 移动到 $q_3$)\n-   $E(q_3) = \\{q_3\\}$\n\n要检查字符串 $w$ 是否被 $\\mathcal{N}_1$ 接受，我们计算在读取 $w$ 后自动机可能处于的所有状态的集合，然后看这个集合是否包含接受状态。这在形式上是通过扩展转移函数 $\\hat{\\delta}_1(q, w)$ 完成的。一个字符串 $w$ 被接受，如果 $\\hat{\\delta}_1(q_0, w) \\cap F \\neq \\emptyset$。\n\n扩展转移函数递归定义如下：\n1.  $\\hat{\\delta}_1(p, \\varepsilon) = E(p)$\n2.  $\\hat{\\delta}_1(p, wa) = E(\\bigcup_{r \\in \\hat{\\delta}_1(p, w)} \\delta_1(r, a))$\n\n我们来正式检查每个选项字符串对于 $\\mathcal{N}_1$ 的状态：\n-   对于字符串 $\\varepsilon$：$\\hat{\\delta}_1(q_0, \\varepsilon) = E(q_0) = \\{q_0\\}$。集合 $\\{q_0\\}$ 不包含接受状态 ($q_3$)。因此，$\\varepsilon$ **不被**接受。\n\n-   对于字符串 $a$：\n    1.  从 $\\hat{\\delta}_1(q_0, \\varepsilon) = \\{q_0\\}$ 开始。\n    2.  读入 $a$：下一个状态的集合是 $\\delta_1(q_0, a) = \\{q_1\\}$。\n    3.  取 $\\varepsilon$-闭包：$E(\\{q_1\\}) = \\{q_1\\}$。\n    最终的状态集合是 $\\{q_1\\}$，其中不包含 $q_3$。因此，$a$ **不被**接受。\n\n-   对于字符串 $b$：\n    1.  从 $\\hat{\\delta}_1(q_0, \\varepsilon) = \\{q_0\\}$ 开始。\n    2.  读入 $b$：下一个状态的集合是 $\\delta_1(q_0, b) = \\emptyset$。\n    最终的状态集合是 $\\emptyset$。因此，$b$ **不被**接受。\n\n-   对于字符串 $ab$：\n    1.  处理完 $a$ 后，我们处于状态集 $\\{q_1\\}$ 中（根据上述分析）。\n    2.  从 $\\{q_1\\}$ 中的状态出发，读入 $b$：下一个状态的集合是 $\\delta_1(q_1, b) = \\{q_2\\}$。\n    3.  取 $\\varepsilon$-闭包：$E(\\{q_2\\}) = \\{q_2, q_3\\}$。\n    最终的状态集合是 $\\{q_2, q_3\\}$。由于这个集合包含接受状态 $q_3$，字符串 $ab$ **被** $\\mathcal{N}_1$ 接受。\n\n-   对于字符串 $aba$：\n    1.  处理完 $ab$ 后，我们处于状态集 $\\{q_2, q_3\\}$ 中（根据上述分析）。\n    2.  从 $\\{q_2, q_3\\}$ 中的状态出发，读入 $a$：下一个状态的集合是 $\\delta_1(q_2, a) \\cup \\delta_1(q_3, a) = \\{q_3\\} \\cup \\emptyset = \\{q_3\\}$。\n    3.  取 $\\varepsilon$-闭包：$E(\\{q_3\\}) = \\{q_3\\}$。\n    最终的状态集合是 $\\{q_3\\}$。由于这个集合包含接受状态 $q_3$，字符串 $aba$ **被** $\\mathcal{N}_1$ 接受。\n\n### 逐项分析\n\n我们在寻找被 $\\mathcal{N}_1$ 接受但**不被** $\\mathcal{N}_0$ 接受的字符串。\n\n**A. $ab$**\n-   被 $\\mathcal{N}_0$ 接受吗？否。处理 $ab$ 结束于状态 $q_2 \\notin F$。\n-   被 $\\mathcal{N}_1$ 接受吗？是。处理 $ab$ 到达状态 $q_2$，然后自动机可以从 $q_2$ 进行一次 $\\varepsilon$-转移到达最终状态 $q_3$。\n-   结论：字符串 $ab$ 满足条件。此选项**正确**。\n\n**B. $aba$**\n-   被 $\\mathcal{N}_0$ 接受吗？是。处理 $aba$ 结束于状态 $q_3 \\in F$。\n-   结论：字符串 $aba$ 不满足“不被 $\\mathcal{N}_0$ 接受”的条件。此选项**不正确**。\n\n**C. $a$**\n-   被 $\\mathcal{N}_0$ 接受吗？否。\n-   被 $\\mathcal{N}_1$ 接受吗？否。\n-   结论：字符串 $a$ 不满足“被 $\\mathcal{N}_1$ 接受”的条件。此选项**不正确**。\n\n**D. $\\varepsilon$**\n-   被 $\\mathcal{N}_0$ 接受吗？否。\n-   被 $\\mathcal{N}_1$ 接受吗？否。\n-   结论：字符串 $\\varepsilon$ 不满足“被 $\\mathcal{N}_1$ 接受”的条件。此选项**不正确**。\n\n**E. $b$**\n-   被 $\\mathcal{N}_0$ 接受吗？否。\n-   被 $\\mathcal{N}_1$ 接受吗？否。\n-   结论：字符串 $b$ 不满足“被 $\\mathcal{N}_1$ 接受”的条件。此选项**不正确**。\n\n根据详细分析，只有字符串 $ab$ 是被 $\\mathcal{N}_1$ 接受但不被 $\\mathcal{N}_0$ 接受的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "最后的练习将理论与词法分析这一实际应用场景联系起来。当我们将多个正则表达式合并成一个 NFA 时（这是词法分析器生成器的标准做法），$\\varepsilon$-转移会自然产生。此练习探讨了由此带来的关键实际问题，例如意外接受零长度词法单元，并突显了为什么深入理解 $\\varepsilon$-闭包对编译器开发者至关重要。",
            "id": "3683718",
            "problem": "考虑构建一个词法分析器，它将多个正则表达式词法单元规则组合成一个单一的非确定性有限自动机（NFA）。一个NFA被定义为一个五元组 $\\left(Q,\\Sigma,\\delta,q_0,F\\right)$，其中 $Q$ 是一个有限状态集，$\\Sigma$ 是一个有限输入字母表，$\\delta:Q\\times\\left(\\Sigma\\cup\\{\\varepsilon\\}\\right)\\to 2^Q$ 是转移函数，$q_0\\in Q$ 是起始状态，$F\\subseteq Q$ 是接受状态集。当且仅当存在一条从 $q_0$ 到某个 $f\\in F$ 的路径，其边上的标签（允许 $\\varepsilon$-转移）连接起来等于 $w$ 时，NFA才接受字符串 $w\\in\\Sigma^*$。对于任何状态集 $S\\subseteq Q$，$S$ 的 $\\varepsilon$-闭包（表示为 $\\varepsilon\\text{-closure}(S)$）是从 $S$ 中任何状态出发，仅通过零次或多次 $\\varepsilon$ 转移可达的状态集合。在用于多个词法单元规则的标准组合NFA构造中，全局起始状态 $q_0$ 有到每个规则NFA起始状态的 $\\varepsilon$-转移。\n\n假设我们组合以下两个在 $\\Sigma=\\{a,b\\}$ 上的词法单元规则：\n\n- 规则 $A$：正则表达式 $a^*$，词法单元类型为 $\\text{A}$。\n- 规则 $B$：正则表达式 $ab$，词法单元类型为 $\\text{B}$。\n\n令组合后的NFA为 $\\mathcal{N}=\\left(Q,\\Sigma,\\delta,q_0,F\\right)$，使用常规的片段NFA：\n\n- 对于 $a^*$，一个单一状态 $q_A$，其中 $\\delta\\!\\left(q_A,a\\right)=\\{q_A\\}$ 且 $q_A\\in F$。\n- 对于 $ab$，一个状态链 $q_B \\xrightarrow{a} p_1 \\xrightarrow{b} p_2$，其中 $p_2\\in F$。\n\n组合过程引入了 $\\delta\\!\\left(q_0,\\varepsilon\\right)=\\{q_A,q_B\\}$，且没有其他 $\\varepsilon$-转移。除了所述的转移外，没有其他转移。假设词法分析器实现常规的最长匹配（maximal-munch）策略：在所有模式与剩余输入的前缀匹配的词法单元中，它在当前位置发出消耗长度最大的那一个，并在长度相同时使用规则优先级。\n\n仅使用上述基本原理和构造，对 $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 以及是否有任何接受状态可以在不消耗输入的情况下达到进行推理，然后考虑其对词法分析器的操作影响。选择所有正确的陈述：\n\nA. $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 包含一个接受状态，因此 $\\mathcal{N}$ 接受 $\\varepsilon$。在词法分析器中，这可能导致在没有其他规则匹配任何符号的位置发出零长度的词法单元。\n\nB. 对于输入 $\\text{\"ab\"}$，最大吞噬策略会发出消耗 $\\text{\"ab\"}$ 的词法单元 $\\text{B}$，而不是长度为 $0$ 或 $1$ 的词法单元 $\\text{A}$，尽管 $\\text{A}$ 的模式可以匹配 $\\varepsilon$。\n\nC. 将 $a^*$ 替换为 $a^+$ 会从规则 $A$ 的语言中移除 $\\varepsilon$，并从 $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 中消除任何接受状态；这可以防止零长度词法单元的发出，并修复过早接受的问题。\n\nD. 仅仅将规则 $B$ 的优先级置于规则 $A$ 之上，就足以在所有输入（包括 $\\varepsilon$ 和像 $\\text{\"b\"}$ 这样的输入）上防止零长度词法单元。\n\nE. 从 $q_0$ 移除到 $q_A$ 和 $q_B$ 的 $\\varepsilon$-转移，可以在消除过早接受的同时保留对预期词法单元的识别，因为自动机在分支到规则 NFA 之前会等待读取一个符号。\n\n通过选择正确的选项来回答。",
            "solution": "让我们首先根据提供的信息，正式定义组合后的 NFA $\\mathcal{N}=\\left(Q,\\Sigma,\\delta,q_0,F\\right)$。\n\n-   状态集为 $Q = \\{q_0, q_A, q_B, p_1, p_2\\}$。\n-   字母表为 $\\Sigma = \\{a, b\\}$。\n-   起始状态为 $q_0$。\n-   接受状态集为 $F = \\{q_A, p_2\\}$，因为 $q_A$ 是规则 $A$ 的接受状态，$p_2$ 是规则 $B$ 的接受状态。\n-   转移函数 $\\delta$ 定义如下：\n    -   $\\delta(q_0, \\varepsilon) = \\{q_A, q_B\\}$\n    -   $\\delta(q_A, a) = \\{q_A\\}$\n    -   $\\delta(q_B, a) = \\{p_1\\}$\n    -   $\\delta(p_1, b) = \\{p_2\\}$\n    -   对于所有其他对 $(q, c)$，$\\delta(q, c) = \\emptyset$。\n\n现在我们分析这个NFA的属性。\n\n起始状态 $\\{q_0\\}$ 的 $\\varepsilon\\text{-closure}$ 是从 $q_0$ 出发仅使用 $\\varepsilon$-转移可达的所有状态的集合。根据定义，$q_0$ 在其自身的闭包中（零次转移）。从 $q_0$，我们可以通过一次 $\\varepsilon$-转移到达 $q_A$ 和 $q_B$。从 $q_A$ 或 $q_B$ 没有进一步的 $\\varepsilon$-转移。因此：\n$$ \\varepsilon\\text{-closure}(\\{q_0\\}) = \\{q_0, q_A, q_B\\} $$\n当且仅当一个NFA的起始状态的 $\\varepsilon$-闭包包含至少一个接受状态时，该NFA接受空字符串 $\\varepsilon$。在数学上，这表示为 $\\varepsilon\\text{-closure}(\\{q_0\\}) \\cap F \\neq \\emptyset$。\n让我们检查这个条件：\n$$ \\varepsilon\\text{-closure}(\\{q_0\\}) \\cap F = \\{q_0, q_A, q_B\\} \\cap \\{q_A, p_2\\} = \\{q_A\\} $$\n由于交集非空，NFA $\\mathcal{N}$ 接受空字符串 $\\varepsilon$。\n\n现在我们评估每个选项：\n\n**A. $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 包含一个接受状态，因此 $\\mathcal{N}$ 接受 $\\varepsilon$。在词法分析器中，这可能导致在没有其他规则匹配任何符号的位置发出零长度的词法单元。**\n-   如上所述，$\\varepsilon\\text{-closure}(\\{q_0\\}) = \\{q_0, q_A, q_B\\}$。接受状态集是 $F = \\{q_A, p_2\\}$。交集是 $\\{q_A\\}$，这是非空的。所以，起始状态的 $\\varepsilon$-闭包确实包含一个接受状态（$q_A$）。\n-   这直接意味着NFA $\\mathcal{N}$ 接受空字符串 $\\varepsilon$。\n-   在词法分析器中，如果输入指针位于一个没有任何规则能匹配非空前缀的位置（例如，输入是 $\"b...\"$ 或者到达文件末尾），词法分析器将搜索所有可能的匹配。规则 $A$ ($a^*$) 总能匹配长度为 $0$ 的空字符串 $\\varepsilon$。如果这是找到的唯一匹配，最大吞噬策略将选择它。这导致发出一个零长度的词法单元。如果词法分析器没有特殊机制来处理这种情况，这可能会导致无限循环，因为输入指针不会前进。该陈述完全正确。\n-   **结论：正确。**\n\n**B. 对于输入 $\\text{\"ab\"}$，最大吞噬策略会发出消耗 $\\text{\"ab\"}$ 的词法单元 $\\text{B}$，而不是长度为 $0$ 或 $1$ 的词法单元 $\\text{A}$，尽管 $\\text{A}$ 的模式可以匹配 $\\varepsilon$。**\n-   让我们分析输入字符串 $\"ab\"$ 的可能匹配。\n    1.  **规则 A ($a^*$):** 这个规则可以匹配前缀 $\\varepsilon$（长度 $0$）和前缀 $\"a\"$（长度 $1$）。相应的词法单元类型为 $\\text{A}$。\n    2.  **规则 B ($ab$):** 这个规则可以匹配前缀 $\"ab\"$（长度 $2$）。相应的词法单元类型为 $\\text{B}$。\n-   词法分析器识别出所有可能的匹配及其长度：一个长度为 $0$ 的匹配（类型 $\\text{A}$），一个长度为 $1$ 的匹配（类型 $\\text{A}$），以及一个长度为 $2$ 的匹配（类型 $\\text{B}$）。\n-   最大吞噬策略规定词法分析器必须选择最长的有效匹配。在这里，最长的匹配长度为 $2$。\n-   因此，词法分析器将在消耗字符串 $\"ab\"$ 后发出词法单元 $\\text{B}$。来自规则 $\\text{A}$ 的较短匹配被丢弃。该陈述准确地描述了这种行为。\n-   **结论：正确。**\n\n**C. 将 $a^*$ 替换为 $a^+$ 会从规则 $A$ 的语言中移除 $\\varepsilon$，并从 $\\varepsilon\\text{-closure}\\!\\left(\\{q_0\\}\\right)$ 中消除任何接受状态；这可以防止零长度词法单元的发出，并修复过早接受的问题。**\n-   正则表达式 $a^+$ 匹配一个或多个 $a$ 的出现。其语言不包含空字符串 $\\varepsilon$。\n-   $a^+$ 的一个标准NFA片段可以构建为 $q_{A,1} \\xrightarrow{a} q_{A,2}$，带有一个循环 $\\delta(q_{A,2}, a) = \\{q_{A,2}\\}$，且 $q_{A,2}$ 是该片段唯一的接受状态。\n-   在新的组合NFA中，组合规则会给出 $\\delta(q_0, \\varepsilon) = \\{q_{A,1}, q_B\\}$。这里，$q_{A,1}$ 是 $a^+$ 片段的起始状态。\n-   新的 $\\varepsilon\\text{-closure}(\\{q_0\\})$ 将是 $\\{q_0, q_{A,1}, q_B\\}$。\n-   新的接受状态集将是 $F' = \\{q_{A,2}, p_2\\}$。\n-   交集为 $\\varepsilon\\text{-closure}(\\{q_0\\}) \\cap F' = \\{q_0, q_{A,1}, q_B\\} \\cap \\{q_{A,2}, p_2\\} = \\emptyset$。\n-   由于起始状态的 $\\varepsilon$-闭包不再包含接受状态，NFA不再接受 $\\varepsilon$。这意味着它永远不能产生零长度的匹配，从而解决了发出零长度词法单元并卡住的问题。该陈述是正确的。\n-   **结论：正确。**\n\n**D. 仅仅将规则 $B$ 的优先级置于规则 $A$ 之上，就足以在所有输入（包括 $\\varepsilon$ 和像 $\\text{\"b\"}$ 这样的输入）上防止零长度词法单元。**\n-   词法分析器的算法首先应用最大吞噬规则来找到最长的可能匹配。规则优先级仅在多个规则产生*相同*最大长度的匹配时用于打破平局。\n-   考虑输入字符串 $\"b\"$。\n    -   规则 $A$ ($a^*$) 匹配前缀 $\\varepsilon$（长度 $0$）。\n    -   规则 $B$ ($ab$) 不匹配 $\"b\"$ 的任何前缀，因为第一个字符必须是 $a$。\n-   词法分析器找到的唯一匹配是规则 $A$ 的长度为 $0$ 的匹配。由于这是唯一的匹配，它也是最长的匹配。在长度上没有平局，所以规则优先级根本不会被考虑。\n-   词法分析器将选择长度为 $0$ 的匹配，并发出一个类型为 $\\text{A}$ 的零长度词法单元。陈述中说优先考虑规则 $B$ 就“足以防止”这种情况是错误的。\n-   **结论：不正确。**\n\n**E. 从 $q_0$ 移除到 $q_A$ 和 $q_B$ 的 $\\varepsilon$-转移，可以在消除过早接受的同时保留对预期词法单元的识别，因为自动机在分支到规则 NFA 之前会等待读取一个符号。**\n-   该陈述建议移除转移 $\\delta(q_0, \\varepsilon) = \\{q_A, q_B\\}$。\n-   根据问题描述，“除了所述的转移外，没有其他转移”。这意味着如果这些 $\\varepsilon$-转移被移除，状态 $q_0$ 将没有任何出向转移。\n-   一个从状态 $q_0$ 开始且没有任何出向转移的NFA永远无法离开 $q_0$。\n-   由于 $q_0$ 不是一个接受状态（$F = \\{q_A, p_2\\}$），这个修改后的NFA在任何输入上都无法到达任何接受状态。\n-   这样一个自动机所识别的语言将是空集 $\\emptyset$。这当然不能“保留对预期词法单元的识别”。自动机变得无法工作。该陈述的前提存在根本性缺陷。\n-   **结论：不正确。**",
            "answer": "$$\\boxed{ABC}$$"
        }
    ]
}